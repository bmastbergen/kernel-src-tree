dma-buf: make reservation_object_copy_fences rcu save

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Christian König <christian.koenig@amd.com>
commit 39e16ba16c147e662bf9fbcee9a99d70d420382f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/39e16ba1.failed

Stop requiring that the src reservation object is locked for this operation.

	Acked-by: Chunming Zhou <david1.zhou@amd.com>
	Signed-off-by: Christian König <christian.koenig@amd.com>
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Link: https://patchwork.freedesktop.org/patch/msgid/1504551766-5093-1-git-send-email-deathsimple@vodafone.de
(cherry picked from commit 39e16ba16c147e662bf9fbcee9a99d70d420382f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dma-buf/reservation.c
diff --cc drivers/dma-buf/reservation.c
index 393817e849ed,b44d9d7db347..000000000000
--- a/drivers/dma-buf/reservation.c
+++ b/drivers/dma-buf/reservation.c
@@@ -264,6 -262,94 +264,97 @@@ void reservation_object_add_excl_fence(
  EXPORT_SYMBOL(reservation_object_add_excl_fence);
  
  /**
++<<<<<<< HEAD
++=======
+ * reservation_object_copy_fences - Copy all fences from src to dst.
+ * @dst: the destination reservation object
+ * @src: the source reservation object
+ *
+ * Copy all fences from src to dst. dst-lock must be held.
+ */
+ int reservation_object_copy_fences(struct reservation_object *dst,
+ 				   struct reservation_object *src)
+ {
+ 	struct reservation_object_list *src_list, *dst_list;
+ 	struct dma_fence *old, *new;
+ 	size_t size;
+ 	unsigned i;
+ 
+ 	rcu_read_lock();
+ 	src_list = rcu_dereference(src->fence);
+ 
+ retry:
+ 	if (src_list) {
+ 		unsigned shared_count = src_list->shared_count;
+ 
+ 		size = offsetof(typeof(*src_list), shared[shared_count]);
+ 		rcu_read_unlock();
+ 
+ 		dst_list = kmalloc(size, GFP_KERNEL);
+ 		if (!dst_list)
+ 			return -ENOMEM;
+ 
+ 		rcu_read_lock();
+ 		src_list = rcu_dereference(src->fence);
+ 		if (!src_list || src_list->shared_count > shared_count) {
+ 			kfree(dst_list);
+ 			goto retry;
+ 		}
+ 
+ 		dst_list->shared_count = 0;
+ 		dst_list->shared_max = shared_count;
+ 		for (i = 0; i < src_list->shared_count; ++i) {
+ 			struct dma_fence *fence;
+ 
+ 			fence = rcu_dereference(src_list->shared[i]);
+ 			if (test_bit(DMA_FENCE_FLAG_SIGNALED_BIT,
+ 				     &fence->flags))
+ 				continue;
+ 
+ 			if (!dma_fence_get_rcu(fence)) {
+ 				kfree(dst_list);
+ 				src_list = rcu_dereference(src->fence);
+ 				goto retry;
+ 			}
+ 
+ 			if (dma_fence_is_signaled(fence)) {
+ 				dma_fence_put(fence);
+ 				continue;
+ 			}
+ 
+ 			dst_list->shared[dst_list->shared_count++] = fence;
+ 		}
+ 	} else {
+ 		dst_list = NULL;
+ 	}
+ 
+ 	new = dma_fence_get_rcu_safe(&src->fence_excl);
+ 	rcu_read_unlock();
+ 
+ 	kfree(dst->staged);
+ 	dst->staged = NULL;
+ 
+ 	src_list = reservation_object_get_list(dst);
+ 	old = reservation_object_get_excl(dst);
+ 
+ 	preempt_disable();
+ 	write_seqcount_begin(&dst->seq);
+ 	/* write_seqcount_begin provides the necessary memory barrier */
+ 	RCU_INIT_POINTER(dst->fence_excl, new);
+ 	RCU_INIT_POINTER(dst->fence, dst_list);
+ 	write_seqcount_end(&dst->seq);
+ 	preempt_enable();
+ 
+ 	if (src_list)
+ 		kfree_rcu(src_list, rcu);
+ 	dma_fence_put(old);
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(reservation_object_copy_fences);
+ 
+ /**
++>>>>>>> 39e16ba16c14 (dma-buf: make reservation_object_copy_fences rcu save)
   * reservation_object_get_fences_rcu - Get an object's shared and exclusive
   * fences without update side lock held
   * @obj: the reservation object
* Unmerged path drivers/dma-buf/reservation.c
