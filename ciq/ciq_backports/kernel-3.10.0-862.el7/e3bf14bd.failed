rdma: Autoload netlink client modules

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [infiniband] Autoload netlink client modules (Don Dutile) [1499364]
Rebuild_FUZZ: 91.18%
commit-author Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
commit e3bf14bdc17a8e917f337760cc7cacf3232d7dbc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e3bf14bd.failed

If a message comes in and we do not have the client in the table, then
try to load the module supplying that client using MODULE_ALIAS to find
it.

This duplicates the scheme seen in other netlink muxes (eg nfnetlink).

	Signed-off-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
	Reviewed-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit e3bf14bdc17a8e917f337760cc7cacf3232d7dbc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/netlink.c
#	drivers/infiniband/core/nldev.c
diff --cc drivers/infiniband/core/netlink.c
index ffb44107c49a,e685148dd3e6..000000000000
--- a/drivers/infiniband/core/netlink.c
+++ b/drivers/infiniband/core/netlink.c
@@@ -41,76 -41,101 +41,93 @@@
  #include <linux/module.h>
  #include "core_priv.h"
  
 -#include "core_priv.h"
 -
 -static DEFINE_MUTEX(rdma_nl_mutex);
 +struct ibnl_client {
 +	struct list_head		list;
 +	int				index;
 +	int				nops;
 +	const struct ibnl_client_cbs   *cb_table;
 +};
 +
 +static DEFINE_MUTEX(ibnl_mutex);
  static struct sock *nls;
 -static struct {
 -	const struct rdma_nl_cbs   *cb_table;
 -} rdma_nl_types[RDMA_NL_NUM_CLIENTS];
 -
 -int rdma_nl_chk_listeners(unsigned int group)
 -{
 -	return (netlink_has_listeners(nls, group)) ? 0 : -1;
 -}
 -EXPORT_SYMBOL(rdma_nl_chk_listeners);
 +static LIST_HEAD(client_list);
  
 -static bool is_nl_msg_valid(unsigned int type, unsigned int op)
 +int ibnl_chk_listeners(unsigned int group)
  {
 -	static const unsigned int max_num_ops[RDMA_NL_NUM_CLIENTS - 1] = {
 -				  RDMA_NL_RDMA_CM_NUM_OPS,
 -				  RDMA_NL_IWPM_NUM_OPS,
 -				  0,
 -				  RDMA_NL_LS_NUM_OPS,
 -				  RDMA_NLDEV_NUM_OPS };
 -
 -	/*
 -	 * This BUILD_BUG_ON is intended to catch addition of new
 -	 * RDMA netlink protocol without updating the array above.
 -	 */
 -	BUILD_BUG_ON(RDMA_NL_NUM_CLIENTS != 6);
 -
 -	if (type > RDMA_NL_NUM_CLIENTS - 1)
 -		return false;
 -
 -	return (op < max_num_ops[type - 1]) ? true : false;
 +	if (netlink_has_listeners(nls, group) == 0)
 +		return -1;
 +	return 0;
  }
  
 -static bool is_nl_valid(unsigned int type, unsigned int op)
 +int ibnl_add_client(int index, int nops,
 +		    const struct ibnl_client_cbs cb_table[])
  {
 -	const struct rdma_nl_cbs *cb_table;
 +	struct ibnl_client *cur;
 +	struct ibnl_client *nl_client;
  
 -	if (!is_nl_msg_valid(type, op))
 -		return false;
 +	nl_client = kmalloc(sizeof *nl_client, GFP_KERNEL);
 +	if (!nl_client)
 +		return -ENOMEM;
  
++<<<<<<< HEAD
 +	nl_client->index	= index;
 +	nl_client->nops		= nops;
 +	nl_client->cb_table	= cb_table;
++=======
+ 	cb_table = rdma_nl_types[type].cb_table;
+ #ifdef CONFIG_MODULES
+ 	if (!cb_table) {
+ 		mutex_unlock(&rdma_nl_mutex);
+ 		request_module("rdma-netlink-subsys-%d", type);
+ 		mutex_lock(&rdma_nl_mutex);
+ 		cb_table = rdma_nl_types[type].cb_table;
+ 	}
+ #endif
+ 
+ 	if (!cb_table || (!cb_table[op].dump && !cb_table[op].doit))
+ 		return false;
+ 	return true;
+ }
++>>>>>>> e3bf14bdc17a (rdma: Autoload netlink client modules)
  
 -void rdma_nl_register(unsigned int index,
 -		      const struct rdma_nl_cbs cb_table[])
 -{
 -	mutex_lock(&rdma_nl_mutex);
 -	if (!is_nl_msg_valid(index, 0)) {
 -		/*
 -		 * All clients are not interesting in success/failure of
 -		 * this call. They want to see the print to error log and
 -		 * continue their initialization. Print warning for them,
 -		 * because it is programmer's error to be here.
 -		 */
 -		mutex_unlock(&rdma_nl_mutex);
 -		WARN(true,
 -		     "The not-valid %u index was supplied to RDMA netlink\n",
 -		     index);
 -		return;
 -	}
 +	mutex_lock(&ibnl_mutex);
  
 -	if (rdma_nl_types[index].cb_table) {
 -		mutex_unlock(&rdma_nl_mutex);
 -		WARN(true,
 -		     "The %u index is already registered in RDMA netlink\n",
 -		     index);
 -		return;
 +	list_for_each_entry(cur, &client_list, list) {
 +		if (cur->index == index) {
 +			pr_warn("Client for %d already exists\n", index);
 +			mutex_unlock(&ibnl_mutex);
 +			kfree(nl_client);
 +			return -EINVAL;
 +		}
  	}
  
 -	rdma_nl_types[index].cb_table = cb_table;
 -	mutex_unlock(&rdma_nl_mutex);
 +	list_add_tail(&nl_client->list, &client_list);
 +
 +	mutex_unlock(&ibnl_mutex);
 +
 +	return 0;
  }
 -EXPORT_SYMBOL(rdma_nl_register);
 +EXPORT_SYMBOL(ibnl_add_client);
  
 -void rdma_nl_unregister(unsigned int index)
 +int ibnl_remove_client(int index)
  {
 -	mutex_lock(&rdma_nl_mutex);
 -	rdma_nl_types[index].cb_table = NULL;
 -	mutex_unlock(&rdma_nl_mutex);
 +	struct ibnl_client *cur, *next;
 +
 +	mutex_lock(&ibnl_mutex);
 +	list_for_each_entry_safe(cur, next, &client_list, list) {
 +		if (cur->index == index) {
 +			list_del(&(cur->list));
 +			mutex_unlock(&ibnl_mutex);
 +			kfree(cur);
 +			return 0;
 +		}
 +	}
 +	pr_warn("Can't remove callback for client idx %d. Not found\n", index);
 +	mutex_unlock(&ibnl_mutex);
 +
 +	return -EINVAL;
  }
 -EXPORT_SYMBOL(rdma_nl_unregister);
 +EXPORT_SYMBOL(ibnl_remove_client);
  
  void *ibnl_put_msg(struct sk_buff *skb, struct nlmsghdr **nlh, int seq,
  		   int len, int client, int op, int flags)
* Unmerged path drivers/infiniband/core/nldev.c
diff --git a/drivers/infiniband/core/cma.c b/drivers/infiniband/core/cma.c
index ae818a6311c2..28416b1710d7 100644
--- a/drivers/infiniband/core/cma.c
+++ b/drivers/infiniband/core/cma.c
@@ -4616,5 +4616,7 @@ static void __exit cma_cleanup(void)
 	destroy_workqueue(cma_wq);
 }
 
+MODULE_ALIAS_RDMA_NETLINK(RDMA_NL_RDMA_CM, 1);
+
 module_init(cma_init);
 module_exit(cma_cleanup);
diff --git a/drivers/infiniband/core/device.c b/drivers/infiniband/core/device.c
index 50e31193a367..a73ae4efc942 100644
--- a/drivers/infiniband/core/device.c
+++ b/drivers/infiniband/core/device.c
@@ -1106,5 +1106,7 @@ static void __exit ib_core_cleanup(void)
 	destroy_workqueue(ib_wq);
 }
 
+MODULE_ALIAS_RDMA_NETLINK(RDMA_NL_LS, 4);
+
 module_init(ib_core_init);
 module_exit(ib_core_cleanup);
diff --git a/drivers/infiniband/core/iwcm.c b/drivers/infiniband/core/iwcm.c
index ff6d7bc44c1f..f21402c3a9c1 100644
--- a/drivers/infiniband/core/iwcm.c
+++ b/drivers/infiniband/core/iwcm.c
@@ -1204,5 +1204,7 @@ static void __exit iw_cm_cleanup(void)
 	iwpm_exit(RDMA_NL_IWCM);
 }
 
+MODULE_ALIAS_RDMA_NETLINK(RDMA_NL_IWCM, 2);
+
 module_init(iw_cm_init);
 module_exit(iw_cm_cleanup);
* Unmerged path drivers/infiniband/core/netlink.c
* Unmerged path drivers/infiniband/core/nldev.c
diff --git a/include/rdma/rdma_netlink.h b/include/rdma/rdma_netlink.h
index 3d228061a9e1..ad4d7ab065d6 100644
--- a/include/rdma/rdma_netlink.h
+++ b/include/rdma/rdma_netlink.h
@@ -10,6 +10,18 @@ struct ibnl_client_cbs {
 	struct module *module;
 };
 
+/* Define this module as providing netlink services for NETLINK_RDMA, with
+ * index _index.  Since the client indexes were setup in a uapi header as an
+ * enum and we do no want to change that, the user must supply the expanded
+ * constant as well and the compiler checks they are the same.
+ */
+#define MODULE_ALIAS_RDMA_NETLINK(_index, _val)                                \
+	static inline void __chk_##_index(void)                                \
+	{                                                                      \
+		BUILD_BUG_ON(_index != _val);                                  \
+	}                                                                      \
+	MODULE_ALIAS("rdma-netlink-subsys-" __stringify(_val))
+
 /**
  * Add a a client to the list of IB netlink exporters.
  * @index: Index of the added client
