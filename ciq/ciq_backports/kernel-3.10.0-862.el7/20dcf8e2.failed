lpfc debugfs: get rid of pointless access_ok()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] lpfc: debugfs: get rid of pointless access_ok() (Dick Kennedy) [1385844 1461977 1387768]
Rebuild_FUZZ: 98.92%
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 20dcf8e244b963a5c64cdda336d00d5169d17985
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/20dcf8e2.failed

copy_from_user() needs no protection - it does the checks itself

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 20dcf8e244b963a5c64cdda336d00d5169d17985)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_debugfs.c
diff --cc drivers/scsi/lpfc/lpfc_debugfs.c
index e6cf568b0f02,ca08d3730d7b..000000000000
--- a/drivers/scsi/lpfc/lpfc_debugfs.c
+++ b/drivers/scsi/lpfc/lpfc_debugfs.c
@@@ -1243,6 -1895,406 +1243,409 @@@ lpfc_debugfs_dumpDataDif_release(struc
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ 
+ static int
+ lpfc_debugfs_nvmestat_open(struct inode *inode, struct file *file)
+ {
+ 	struct lpfc_vport *vport = inode->i_private;
+ 	struct lpfc_debug *debug;
+ 	int rc = -ENOMEM;
+ 
+ 	debug = kmalloc(sizeof(*debug), GFP_KERNEL);
+ 	if (!debug)
+ 		goto out;
+ 
+ 	 /* Round to page boundary */
+ 	debug->buffer = kmalloc(LPFC_NVMESTAT_SIZE, GFP_KERNEL);
+ 	if (!debug->buffer) {
+ 		kfree(debug);
+ 		goto out;
+ 	}
+ 
+ 	debug->len = lpfc_debugfs_nvmestat_data(vport, debug->buffer,
+ 		LPFC_NVMESTAT_SIZE);
+ 
+ 	debug->i_private = inode->i_private;
+ 	file->private_data = debug;
+ 
+ 	rc = 0;
+ out:
+ 	return rc;
+ }
+ 
+ static ssize_t
+ lpfc_debugfs_nvmestat_write(struct file *file, const char __user *buf,
+ 			    size_t nbytes, loff_t *ppos)
+ {
+ 	struct lpfc_debug *debug = file->private_data;
+ 	struct lpfc_vport *vport = (struct lpfc_vport *)debug->i_private;
+ 	struct lpfc_hba   *phba = vport->phba;
+ 	struct lpfc_nvmet_tgtport *tgtp;
+ 	char mybuf[64];
+ 	char *pbuf;
+ 
+ 	if (!phba->targetport)
+ 		return -ENXIO;
+ 
+ 	if (nbytes > 64)
+ 		nbytes = 64;
+ 
+ 	memset(mybuf, 0, sizeof(mybuf));
+ 
+ 	if (copy_from_user(mybuf, buf, nbytes))
+ 		return -EFAULT;
+ 	pbuf = &mybuf[0];
+ 
+ 	tgtp = (struct lpfc_nvmet_tgtport *)phba->targetport->private;
+ 	if ((strncmp(pbuf, "reset", strlen("reset")) == 0) ||
+ 	    (strncmp(pbuf, "zero", strlen("zero")) == 0)) {
+ 		atomic_set(&tgtp->rcv_ls_req_in, 0);
+ 		atomic_set(&tgtp->rcv_ls_req_out, 0);
+ 		atomic_set(&tgtp->rcv_ls_req_drop, 0);
+ 		atomic_set(&tgtp->xmt_ls_abort, 0);
+ 		atomic_set(&tgtp->xmt_ls_rsp, 0);
+ 		atomic_set(&tgtp->xmt_ls_drop, 0);
+ 		atomic_set(&tgtp->xmt_ls_rsp_error, 0);
+ 		atomic_set(&tgtp->xmt_ls_rsp_cmpl, 0);
+ 
+ 		atomic_set(&tgtp->rcv_fcp_cmd_in, 0);
+ 		atomic_set(&tgtp->rcv_fcp_cmd_out, 0);
+ 		atomic_set(&tgtp->rcv_fcp_cmd_drop, 0);
+ 		atomic_set(&tgtp->xmt_fcp_abort, 0);
+ 		atomic_set(&tgtp->xmt_fcp_drop, 0);
+ 		atomic_set(&tgtp->xmt_fcp_read_rsp, 0);
+ 		atomic_set(&tgtp->xmt_fcp_read, 0);
+ 		atomic_set(&tgtp->xmt_fcp_write, 0);
+ 		atomic_set(&tgtp->xmt_fcp_rsp, 0);
+ 		atomic_set(&tgtp->xmt_fcp_rsp_cmpl, 0);
+ 		atomic_set(&tgtp->xmt_fcp_rsp_error, 0);
+ 		atomic_set(&tgtp->xmt_fcp_rsp_drop, 0);
+ 
+ 		atomic_set(&tgtp->xmt_abort_rsp, 0);
+ 		atomic_set(&tgtp->xmt_abort_rsp_error, 0);
+ 		atomic_set(&tgtp->xmt_abort_cmpl, 0);
+ 	}
+ 	return nbytes;
+ }
+ 
+ static int
+ lpfc_debugfs_nvmektime_open(struct inode *inode, struct file *file)
+ {
+ 	struct lpfc_vport *vport = inode->i_private;
+ 	struct lpfc_debug *debug;
+ 	int rc = -ENOMEM;
+ 
+ 	debug = kmalloc(sizeof(*debug), GFP_KERNEL);
+ 	if (!debug)
+ 		goto out;
+ 
+ 	 /* Round to page boundary */
+ 	debug->buffer = kmalloc(LPFC_NVMEKTIME_SIZE, GFP_KERNEL);
+ 	if (!debug->buffer) {
+ 		kfree(debug);
+ 		goto out;
+ 	}
+ 
+ 	debug->len = lpfc_debugfs_nvmektime_data(vport, debug->buffer,
+ 		LPFC_NVMEKTIME_SIZE);
+ 
+ 	debug->i_private = inode->i_private;
+ 	file->private_data = debug;
+ 
+ 	rc = 0;
+ out:
+ 	return rc;
+ }
+ 
+ static ssize_t
+ lpfc_debugfs_nvmektime_write(struct file *file, const char __user *buf,
+ 			     size_t nbytes, loff_t *ppos)
+ {
+ 	struct lpfc_debug *debug = file->private_data;
+ 	struct lpfc_vport *vport = (struct lpfc_vport *)debug->i_private;
+ 	struct lpfc_hba   *phba = vport->phba;
+ 	char mybuf[64];
+ 	char *pbuf;
+ 
+ 	if (nbytes > 64)
+ 		nbytes = 64;
+ 
+ 	memset(mybuf, 0, sizeof(mybuf));
+ 
+ 	if (copy_from_user(mybuf, buf, nbytes))
+ 		return -EFAULT;
+ 	pbuf = &mybuf[0];
+ 
+ 	if ((strncmp(pbuf, "on", sizeof("on") - 1) == 0)) {
+ 		phba->ktime_data_samples = 0;
+ 		phba->ktime_status_samples = 0;
+ 		phba->ktime_seg1_total = 0;
+ 		phba->ktime_seg1_max = 0;
+ 		phba->ktime_seg1_min = 0xffffffff;
+ 		phba->ktime_seg2_total = 0;
+ 		phba->ktime_seg2_max = 0;
+ 		phba->ktime_seg2_min = 0xffffffff;
+ 		phba->ktime_seg3_total = 0;
+ 		phba->ktime_seg3_max = 0;
+ 		phba->ktime_seg3_min = 0xffffffff;
+ 		phba->ktime_seg4_total = 0;
+ 		phba->ktime_seg4_max = 0;
+ 		phba->ktime_seg4_min = 0xffffffff;
+ 		phba->ktime_seg5_total = 0;
+ 		phba->ktime_seg5_max = 0;
+ 		phba->ktime_seg5_min = 0xffffffff;
+ 		phba->ktime_seg6_total = 0;
+ 		phba->ktime_seg6_max = 0;
+ 		phba->ktime_seg6_min = 0xffffffff;
+ 		phba->ktime_seg7_total = 0;
+ 		phba->ktime_seg7_max = 0;
+ 		phba->ktime_seg7_min = 0xffffffff;
+ 		phba->ktime_seg8_total = 0;
+ 		phba->ktime_seg8_max = 0;
+ 		phba->ktime_seg8_min = 0xffffffff;
+ 		phba->ktime_seg9_total = 0;
+ 		phba->ktime_seg9_max = 0;
+ 		phba->ktime_seg9_min = 0xffffffff;
+ 		phba->ktime_seg10_total = 0;
+ 		phba->ktime_seg10_max = 0;
+ 		phba->ktime_seg10_min = 0xffffffff;
+ 
+ 		phba->ktime_on = 1;
+ 		return strlen(pbuf);
+ 	} else if ((strncmp(pbuf, "off",
+ 		   sizeof("off") - 1) == 0)) {
+ 		phba->ktime_on = 0;
+ 		return strlen(pbuf);
+ 	} else if ((strncmp(pbuf, "zero",
+ 		   sizeof("zero") - 1) == 0)) {
+ 		phba->ktime_data_samples = 0;
+ 		phba->ktime_status_samples = 0;
+ 		phba->ktime_seg1_total = 0;
+ 		phba->ktime_seg1_max = 0;
+ 		phba->ktime_seg1_min = 0xffffffff;
+ 		phba->ktime_seg2_total = 0;
+ 		phba->ktime_seg2_max = 0;
+ 		phba->ktime_seg2_min = 0xffffffff;
+ 		phba->ktime_seg3_total = 0;
+ 		phba->ktime_seg3_max = 0;
+ 		phba->ktime_seg3_min = 0xffffffff;
+ 		phba->ktime_seg4_total = 0;
+ 		phba->ktime_seg4_max = 0;
+ 		phba->ktime_seg4_min = 0xffffffff;
+ 		phba->ktime_seg5_total = 0;
+ 		phba->ktime_seg5_max = 0;
+ 		phba->ktime_seg5_min = 0xffffffff;
+ 		phba->ktime_seg6_total = 0;
+ 		phba->ktime_seg6_max = 0;
+ 		phba->ktime_seg6_min = 0xffffffff;
+ 		phba->ktime_seg7_total = 0;
+ 		phba->ktime_seg7_max = 0;
+ 		phba->ktime_seg7_min = 0xffffffff;
+ 		phba->ktime_seg8_total = 0;
+ 		phba->ktime_seg8_max = 0;
+ 		phba->ktime_seg8_min = 0xffffffff;
+ 		phba->ktime_seg9_total = 0;
+ 		phba->ktime_seg9_max = 0;
+ 		phba->ktime_seg9_min = 0xffffffff;
+ 		phba->ktime_seg10_total = 0;
+ 		phba->ktime_seg10_max = 0;
+ 		phba->ktime_seg10_min = 0xffffffff;
+ 		return strlen(pbuf);
+ 	}
+ 	return -EINVAL;
+ }
+ 
+ static int
+ lpfc_debugfs_nvmeio_trc_open(struct inode *inode, struct file *file)
+ {
+ 	struct lpfc_hba *phba = inode->i_private;
+ 	struct lpfc_debug *debug;
+ 	int rc = -ENOMEM;
+ 
+ 	debug = kmalloc(sizeof(*debug), GFP_KERNEL);
+ 	if (!debug)
+ 		goto out;
+ 
+ 	 /* Round to page boundary */
+ 	debug->buffer = kmalloc(LPFC_NVMEIO_TRC_SIZE, GFP_KERNEL);
+ 	if (!debug->buffer) {
+ 		kfree(debug);
+ 		goto out;
+ 	}
+ 
+ 	debug->len = lpfc_debugfs_nvmeio_trc_data(phba, debug->buffer,
+ 		LPFC_NVMEIO_TRC_SIZE);
+ 
+ 	debug->i_private = inode->i_private;
+ 	file->private_data = debug;
+ 
+ 	rc = 0;
+ out:
+ 	return rc;
+ }
+ 
+ static ssize_t
+ lpfc_debugfs_nvmeio_trc_write(struct file *file, const char __user *buf,
+ 			      size_t nbytes, loff_t *ppos)
+ {
+ 	struct lpfc_debug *debug = file->private_data;
+ 	struct lpfc_hba *phba = (struct lpfc_hba *)debug->i_private;
+ 	int i;
+ 	unsigned long sz;
+ 	char mybuf[64];
+ 	char *pbuf;
+ 
+ 	if (nbytes > 64)
+ 		nbytes = 64;
+ 
+ 	memset(mybuf, 0, sizeof(mybuf));
+ 
+ 	if (copy_from_user(mybuf, buf, nbytes))
+ 		return -EFAULT;
+ 	pbuf = &mybuf[0];
+ 
+ 	if ((strncmp(pbuf, "off", sizeof("off") - 1) == 0)) {
+ 		lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
+ 				"0570 nvmeio_trc_off\n");
+ 		phba->nvmeio_trc_output_idx = 0;
+ 		phba->nvmeio_trc_on = 0;
+ 		return strlen(pbuf);
+ 	} else if ((strncmp(pbuf, "on", sizeof("on") - 1) == 0)) {
+ 		lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
+ 				"0571 nvmeio_trc_on\n");
+ 		phba->nvmeio_trc_output_idx = 0;
+ 		phba->nvmeio_trc_on = 1;
+ 		return strlen(pbuf);
+ 	}
+ 
+ 	/* We must be off to allocate the trace buffer */
+ 	if (phba->nvmeio_trc_on != 0)
+ 		return -EINVAL;
+ 
+ 	/* If not on or off, the parameter is the trace buffer size */
+ 	i = kstrtoul(pbuf, 0, &sz);
+ 	if (i)
+ 		return -EINVAL;
+ 	phba->nvmeio_trc_size = (uint32_t)sz;
+ 
+ 	/* It must be a power of 2 - round down */
+ 	i = 0;
+ 	while (sz > 1) {
+ 		sz = sz >> 1;
+ 		i++;
+ 	}
+ 	sz = (1 << i);
+ 	if (phba->nvmeio_trc_size != sz)
+ 		lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
+ 				"0572 nvmeio_trc_size changed to %ld\n",
+ 				sz);
+ 	phba->nvmeio_trc_size = (uint32_t)sz;
+ 
+ 	/* If one previously exists, free it */
+ 	kfree(phba->nvmeio_trc);
+ 
+ 	/* Allocate new trace buffer and initialize */
+ 	phba->nvmeio_trc = kmalloc((sizeof(struct lpfc_debugfs_nvmeio_trc) *
+ 				    sz), GFP_KERNEL);
+ 	if (!phba->nvmeio_trc) {
+ 		lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
+ 				"0573 Cannot create debugfs "
+ 				"nvmeio_trc buffer\n");
+ 		return -ENOMEM;
+ 	}
+ 	memset(phba->nvmeio_trc, 0,
+ 	       (sizeof(struct lpfc_debugfs_nvmeio_trc) * sz));
+ 	atomic_set(&phba->nvmeio_trc_cnt, 0);
+ 	phba->nvmeio_trc_on = 0;
+ 	phba->nvmeio_trc_output_idx = 0;
+ 
+ 	return strlen(pbuf);
+ }
+ 
+ static int
+ lpfc_debugfs_cpucheck_open(struct inode *inode, struct file *file)
+ {
+ 	struct lpfc_vport *vport = inode->i_private;
+ 	struct lpfc_debug *debug;
+ 	int rc = -ENOMEM;
+ 
+ 	debug = kmalloc(sizeof(*debug), GFP_KERNEL);
+ 	if (!debug)
+ 		goto out;
+ 
+ 	 /* Round to page boundary */
+ 	debug->buffer = kmalloc(LPFC_CPUCHECK_SIZE, GFP_KERNEL);
+ 	if (!debug->buffer) {
+ 		kfree(debug);
+ 		goto out;
+ 	}
+ 
+ 	debug->len = lpfc_debugfs_cpucheck_data(vport, debug->buffer,
+ 		LPFC_NVMEKTIME_SIZE);
+ 
+ 	debug->i_private = inode->i_private;
+ 	file->private_data = debug;
+ 
+ 	rc = 0;
+ out:
+ 	return rc;
+ }
+ 
+ static ssize_t
+ lpfc_debugfs_cpucheck_write(struct file *file, const char __user *buf,
+ 			    size_t nbytes, loff_t *ppos)
+ {
+ 	struct lpfc_debug *debug = file->private_data;
+ 	struct lpfc_vport *vport = (struct lpfc_vport *)debug->i_private;
+ 	struct lpfc_hba   *phba = vport->phba;
+ 	char mybuf[64];
+ 	char *pbuf;
+ 	int i;
+ 
+ 	if (nbytes > 64)
+ 		nbytes = 64;
+ 
+ 	memset(mybuf, 0, sizeof(mybuf));
+ 
+ 	if (copy_from_user(mybuf, buf, nbytes))
+ 		return -EFAULT;
+ 	pbuf = &mybuf[0];
+ 
+ 	if ((strncmp(pbuf, "on", sizeof("on") - 1) == 0)) {
+ 		if (phba->nvmet_support)
+ 			phba->cpucheck_on |= LPFC_CHECK_NVMET_IO;
+ 		else
+ 			phba->cpucheck_on |= LPFC_CHECK_NVME_IO;
+ 		return strlen(pbuf);
+ 	} else if ((strncmp(pbuf, "rcv",
+ 		   sizeof("rcv") - 1) == 0)) {
+ 		if (phba->nvmet_support)
+ 			phba->cpucheck_on |= LPFC_CHECK_NVMET_RCV;
+ 		else
+ 			return -EINVAL;
+ 		return strlen(pbuf);
+ 	} else if ((strncmp(pbuf, "off",
+ 		   sizeof("off") - 1) == 0)) {
+ 		phba->cpucheck_on = LPFC_CHECK_OFF;
+ 		return strlen(pbuf);
+ 	} else if ((strncmp(pbuf, "zero",
+ 		   sizeof("zero") - 1) == 0)) {
+ 		for (i = 0; i < phba->sli4_hba.num_present_cpu; i++) {
+ 			if (i >= LPFC_CHECK_CPU_CNT)
+ 				break;
+ 			phba->cpucheck_rcv_io[i] = 0;
+ 			phba->cpucheck_xmt_io[i] = 0;
+ 			phba->cpucheck_cmpl_io[i] = 0;
+ 			phba->cpucheck_ccmpl_io[i] = 0;
+ 		}
+ 		return strlen(pbuf);
+ 	}
+ 	return -EINVAL;
+ }
+ 
++>>>>>>> 20dcf8e244b9 (lpfc debugfs: get rid of pointless access_ok())
  /*
   * ---------------------------------
   * iDiag debugfs file access methods
* Unmerged path drivers/scsi/lpfc/lpfc_debugfs.c
