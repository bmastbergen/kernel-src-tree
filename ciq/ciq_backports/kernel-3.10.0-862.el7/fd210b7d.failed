ovl: move copy up lock out

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit fd210b7d67ee3768bf1ad3e07d55797d4b45fcc1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/fd210b7d.failed

Move ovl_copy_up_start()/ovl_copy_up_end() out so that it's used for both
tempfile and workdir copy ups.

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit fd210b7d67ee3768bf1ad3e07d55797d4b45fcc1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/copy_up.c
diff --cc fs/overlayfs/copy_up.c
index 6e96b99a973d,0d9de353f42b..000000000000
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@@ -393,35 -504,73 +393,101 @@@ static int ovl_copy_up_one(struct dentr
  	if (err)
  		return err;
  
++<<<<<<< HEAD
 +	if (S_ISLNK(stat->mode)) {
 +		link = ovl_read_symlink(lowerpath->dentry);
 +		if (IS_ERR(link))
 +			return PTR_ERR(link);
++=======
+ 	/* Should we copyup with O_TMPFILE or with workdir? */
+ 	if (S_ISREG(c->stat.mode) && ofs->tmpfile) {
+ 		c->tmpfile = true;
+ 		return  ovl_copy_up_locked(c);
++>>>>>>> fd210b7d67ee (ovl: move copy up lock out)
  	}
  
  	err = -EIO;
 -	if (lock_rename(c->workdir, c->upperdir) != NULL) {
 +	if (lock_rename(workdir, upperdir) != NULL) {
  		pr_err("overlayfs: failed to lock workdir+upperdir\n");
- 		goto out_unlock;
+ 	} else {
+ 		err = ovl_copy_up_locked(c);
+ 		unlock_rename(c->workdir, c->upperdir);
  	}
++<<<<<<< HEAD
 +	upperdentry = ovl_dentry_upper(dentry);
 +	if (upperdentry) {
 +		/* Raced with another copy-up?  Nothing to do, then... */
 +		err = 0;
 +		goto out_unlock;
 +	}
 +
 +	err = ovl_copy_up_locked(workdir, upperdir, dentry, lowerpath,
 +				 stat, link);
 +	if (!err) {
 +		/* Restore timestamps on parent (best effort) */
 +		ovl_set_timestamps(upperdir, &pstat);
++=======
+ 
+ 	return err;
+ }
+ 
+ static int ovl_copy_up_one(struct dentry *parent, struct dentry *dentry,
+ 			   int flags)
+ {
+ 	int err;
+ 	DEFINE_DELAYED_CALL(done);
+ 	struct path parentpath;
+ 	struct ovl_copy_up_ctx ctx = {
+ 		.parent = parent,
+ 		.dentry = dentry,
+ 		.workdir = ovl_workdir(dentry),
+ 	};
+ 
+ 	if (WARN_ON(!ctx.workdir))
+ 		return -EROFS;
+ 
+ 	ovl_path_lower(dentry, &ctx.lowerpath);
+ 	err = vfs_getattr(&ctx.lowerpath, &ctx.stat,
+ 			  STATX_BASIC_STATS, AT_STATX_SYNC_AS_STAT);
+ 	if (err)
+ 		return err;
+ 
+ 	ovl_path_upper(parent, &parentpath);
+ 	ctx.upperdir = parentpath.dentry;
+ 
+ 	err = vfs_getattr(&parentpath, &ctx.pstat,
+ 			  STATX_ATIME | STATX_MTIME, AT_STATX_SYNC_AS_STAT);
+ 	if (err)
+ 		return err;
+ 
+ 	/* maybe truncate regular file. this has no effect on dirs */
+ 	if (flags & O_TRUNC)
+ 		ctx.stat.size = 0;
+ 
+ 	if (S_ISLNK(ctx.stat.mode)) {
+ 		ctx.link = vfs_get_link(ctx.lowerpath.dentry, &done);
+ 		if (IS_ERR(ctx.link))
+ 			return PTR_ERR(ctx.link);
++>>>>>>> fd210b7d67ee (ovl: move copy up lock out)
  	}
 -	ovl_do_check_copy_up(ctx.lowerpath.dentry);
 +out_unlock:
 +	unlock_rename(workdir, upperdir);
  
++<<<<<<< HEAD
 +	if (link)
 +		free_page((unsigned long) link);
++=======
+ 	err = ovl_copy_up_start(dentry);
+ 	/* err < 0: interrupted, err > 0: raced with another copy-up */
+ 	if (unlikely(err)) {
+ 		if (err > 0)
+ 			err = 0;
+ 	} else {
+ 		err = ovl_do_copy_up(&ctx);
+ 		ovl_copy_up_end(dentry);
+ 	}
+ 	do_delayed_call(&done);
++>>>>>>> fd210b7d67ee (ovl: move copy up lock out)
  
  	return err;
  }
* Unmerged path fs/overlayfs/copy_up.c
