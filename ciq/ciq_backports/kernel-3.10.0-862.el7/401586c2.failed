i40e: don't clear suspended state until we finish resuming

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit 401586c2b9bb16147f3dcc64d3596013625e2c44
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/401586c2.failed

When handling suspend and resume callbacks we want to make sure that (a)
we don't suspend again if we're already suspended and (b) we don't
resume again if we're already resuming. Lets make sure we test_and_set
the __I40E_SUSPENDED bit in i40e_suspend which ensures that a suspend
call when already suspended will exit early. Additionally, if
__I40E_SUSPENDED is not set when we begin resuming, exit early as well.

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 401586c2b9bb16147f3dcc64d3596013625e2c44)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_main.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_main.c
index 25ede5194921,494cafde6b26..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@@ -11984,15 -12059,16 +11984,23 @@@ static int i40e_suspend(struct device *
  	struct i40e_pf *pf = pci_get_drvdata(pdev);
  	struct i40e_hw *hw = &pf->hw;
  
++<<<<<<< HEAD
 +	set_bit(__I40E_SUSPENDED, &pf->state);
 +	set_bit(__I40E_DOWN, &pf->state);
++=======
+ 	/* If we're already suspended, then there is nothing to do */
+ 	if (test_and_set_bit(__I40E_SUSPENDED, pf->state))
+ 		return 0;
+ 
+ 	set_bit(__I40E_DOWN, pf->state);
++>>>>>>> 401586c2b9bb (i40e: don't clear suspended state until we finish resuming)
  
 -	if (pf->wol_en && (pf->hw_features & I40E_HW_WOL_MC_MAGIC_PKT_WAKE))
 +	if (pf->wol_en && (pf->flags & I40E_FLAG_WOL_MC_MAGIC_PKT_WAKE))
  		i40e_enable_mc_magic_wake(pf);
  
 -	i40e_prep_for_reset(pf, false);
 +	rtnl_lock();
 +	i40e_prep_for_reset(pf);
 +	rtnl_unlock();
  
  	wr32(hw, I40E_PFPM_APM, (pf->wol_en ? I40E_PFPM_APM_APME_MASK : 0));
  	wr32(hw, I40E_PFPM_WUFC, (pf->wol_en ? I40E_PFPM_WUFC_MAG_MASK : 0));
@@@ -12011,13 -12087,15 +12019,25 @@@ static int i40e_resume(struct device *d
  	struct pci_dev *pdev = to_pci_dev(dev);
  	struct i40e_pf *pf = pci_get_drvdata(pdev);
  
++<<<<<<< HEAD
 +	/* handling the reset will rebuild the device state */
 +	if (test_and_clear_bit(__I40E_SUSPENDED, &pf->state)) {
 +		clear_bit(__I40E_DOWN, &pf->state);
 +		rtnl_lock();
 +		i40e_reset_and_rebuild(pf, false);
 +		rtnl_unlock();
 +	}
++=======
+ 	/* If we're not suspended, then there is nothing to do */
+ 	if (!test_bit(__I40E_SUSPENDED, pf->state))
+ 		return 0;
+ 
+ 	clear_bit(__I40E_DOWN, pf->state);
+ 	i40e_reset_and_rebuild(pf, false, false);
+ 
+ 	/* Clear suspended state last after everything is recovered */
+ 	clear_bit(__I40E_SUSPENDED, pf->state);
++>>>>>>> 401586c2b9bb (i40e: don't clear suspended state until we finish resuming)
  
  	return 0;
  }
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_main.c
