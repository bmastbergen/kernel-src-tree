IB/hfi1: Enhance PIO/SDMA send for 16B

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Don Hiatt <don.hiatt@intel.com>
commit 566d53a8264452ee75aa6eb1f2f1970391c1a271
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/566d53a8.failed

PIO/SDMA send logic now uses the hdr_type field to determine
the type of packet that has been constructed. Based on the hdr_type,
certain things such as PBC flags, padding count and the LT extra
trailing bytes are determined.

	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Dasaratharaman Chandramouli <dasaratharaman.chandramouli@intel.com>
	Signed-off-by: Don Hiatt <don.hiatt@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 566d53a8264452ee75aa6eb1f2f1970391c1a271)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/verbs.c
diff --cc drivers/infiniband/hw/hfi1/verbs.c
index 06ac08cf82a6,d279f53fc66e..000000000000
--- a/drivers/infiniband/hw/hfi1/verbs.c
+++ b/drivers/infiniband/hw/hfi1/verbs.c
@@@ -858,14 -908,18 +894,23 @@@ int hfi1_verbs_send_dma(struct rvt_qp *
  	if (!sdma_txreq_built(&tx->txreq)) {
  		if (likely(pbc == 0)) {
  			u32 vl = sc_to_vlt(dd_from_ibdev(qp->ibqp.device), sc5);
- 			u8 opcode = get_opcode(&tx->phdr.hdr);
  
  			/* No vl15 here */
++<<<<<<< HEAD
 +			/* set PBC_DC_INFO bit (aka SC[4]) in pbc_flags */
 +			pbc |= (!!(sc5 & 0x10)) << PBC_DC_INFO_SHIFT;
++=======
+ 			/* set PBC_DC_INFO bit (aka SC[4]) in pbc */
+ 			if (ps->s_txreq->phdr.hdr.hdr_type)
+ 				pbc |= PBC_PACKET_BYPASS |
+ 				       PBC_INSERT_BYPASS_ICRC;
+ 			else
+ 				pbc |= (ib_is_sc5(sc5) << PBC_DC_INFO_SHIFT);
++>>>>>>> 566d53a82644 (IB/hfi1: Enhance PIO/SDMA send for 16B)
  
- 			if (unlikely(hfi1_dbg_fault_opcode(qp, opcode, false)))
- 				pbc = hfi1_fault_tx(qp, opcode, pbc);
+ 			if (unlikely(hfi1_dbg_fault_opcode(qp, ps->opcode,
+ 							   false)))
+ 				pbc = hfi1_fault_tx(qp, ps->opcode, pbc);
  			pbc = create_pbc(ppd,
  					 pbc,
  					 qp->srate_mbps,
@@@ -994,13 -1067,14 +1056,21 @@@ int hfi1_verbs_send_pio(struct rvt_qp *
  
  	if (likely(pbc == 0)) {
  		u8 vl = sc_to_vlt(dd_from_ibdev(qp->ibqp.device), sc5);
- 		struct verbs_txreq *tx = ps->s_txreq;
- 		u8 opcode = get_opcode(&tx->phdr.hdr);
  
++<<<<<<< HEAD
 +		/* set PBC_DC_INFO bit (aka SC[4]) in pbc_flags */
 +		pbc |= (!!(sc5 & 0x10)) << PBC_DC_INFO_SHIFT;
 +		if (unlikely(hfi1_dbg_fault_opcode(qp, opcode, false)))
 +			pbc = hfi1_fault_tx(qp, opcode, pbc);
++=======
+ 		/* set PBC_DC_INFO bit (aka SC[4]) in pbc */
+ 		if (ps->s_txreq->phdr.hdr.hdr_type)
+ 			pbc |= PBC_PACKET_BYPASS | PBC_INSERT_BYPASS_ICRC;
+ 		else
+ 			pbc |= (ib_is_sc5(sc5) << PBC_DC_INFO_SHIFT);
+ 		if (unlikely(hfi1_dbg_fault_opcode(qp, ps->opcode, false)))
+ 			pbc = hfi1_fault_tx(qp, ps->opcode, pbc);
++>>>>>>> 566d53a82644 (IB/hfi1: Enhance PIO/SDMA send for 16B)
  		pbc = create_pbc(ppd, pbc, qp->srate_mbps, vl, plen);
  	}
  	if (cb)
@@@ -1182,7 -1264,7 +1260,11 @@@ static inline send_routine get_send_rou
  {
  	struct hfi1_devdata *dd = dd_from_ibdev(qp->ibqp.device);
  	struct hfi1_qp_priv *priv = qp->priv;
++<<<<<<< HEAD
 +	struct ib_header *h = &tx->phdr.hdr;
++=======
+ 	struct verbs_txreq *tx = ps->s_txreq;
++>>>>>>> 566d53a82644 (IB/hfi1: Enhance PIO/SDMA send for 16B)
  
  	if (unlikely(!(dd->flags & HFI1_HAS_SEND_DMA)))
  		return dd->process_pio_send;
@@@ -1223,25 -1303,38 +1303,42 @@@ int hfi1_verbs_send(struct rvt_qp *qp, 
  	struct hfi1_devdata *dd = dd_from_ibdev(qp->ibqp.device);
  	struct hfi1_qp_priv *priv = qp->priv;
  	struct ib_other_headers *ohdr;
- 	struct ib_header *hdr;
  	send_routine sr;
  	int ret;
- 	u8 lnh;
+ 	u16 pkey;
+ 	u32 slid;
  
++<<<<<<< HEAD
 +	hdr = &ps->s_txreq->phdr.hdr;
++=======
++>>>>>>> 566d53a82644 (IB/hfi1: Enhance PIO/SDMA send for 16B)
  	/* locate the pkey within the headers */
- 	lnh = ib_get_lnh(hdr);
- 	if (lnh == HFI1_LRH_GRH)
- 		ohdr = &hdr->u.l.oth;
- 	else
- 		ohdr = &hdr->u.oth;
- 
- 	sr = get_send_routine(qp, ps->s_txreq);
- 	ret = egress_pkey_check(dd->pport,
- 				hdr->lrh,
- 				ohdr->bth,
- 				priv->s_sc,
- 				qp->s_pkey_index);
+ 	if (ps->s_txreq->phdr.hdr.hdr_type) {
+ 		struct hfi1_16b_header *hdr = &ps->s_txreq->phdr.hdr.opah;
+ 		u8 l4 = hfi1_16B_get_l4(hdr);
+ 
+ 		if (l4 == OPA_16B_L4_IB_GLOBAL)
+ 			ohdr = &hdr->u.l.oth;
+ 		else
+ 			ohdr = &hdr->u.oth;
+ 		slid = hfi1_16B_get_slid(hdr);
+ 		pkey = hfi1_16B_get_pkey(hdr);
+ 	} else {
+ 		struct ib_header *hdr = &ps->s_txreq->phdr.hdr.ibh;
+ 		u8 lnh = ib_get_lnh(hdr);
+ 
+ 		if (lnh == HFI1_LRH_GRH)
+ 			ohdr = &hdr->u.l.oth;
+ 		else
+ 			ohdr = &hdr->u.oth;
+ 		slid = ib_get_slid(hdr);
+ 		pkey = ib_bth_get_pkey(ohdr);
+ 	}
+ 
+ 	ps->opcode = ib_bth_get_opcode(ohdr);
+ 	sr = get_send_routine(qp, ps);
+ 	ret = egress_pkey_check(dd->pport, slid, pkey,
+ 				priv->s_sc, qp->s_pkey_index);
  	if (unlikely(ret)) {
  		/*
  		 * The value we are returning here does not get propagated to
diff --git a/drivers/infiniband/hw/hfi1/hfi.h b/drivers/infiniband/hw/hfi1/hfi.h
index 9719cf207532..46e66fafac5f 100644
--- a/drivers/infiniband/hw/hfi1/hfi.h
+++ b/drivers/infiniband/hw/hfi1/hfi.h
@@ -1427,7 +1427,7 @@ void return_cnp(struct hfi1_ibport *ibp, struct rvt_qp *qp, u32 remote_qpn,
 		u32 pkey, u32 slid, u32 dlid, u8 sc5,
 		const struct ib_grh *old_grh);
 #define PKEY_CHECK_INVALID -1
-int egress_pkey_check(struct hfi1_pportdata *ppd, __be16 *lrh, __be32 *bth,
+int egress_pkey_check(struct hfi1_pportdata *ppd, u32 slid, u16 pkey,
 		      u8 sc5, int8_t s_pkey_index);
 
 #define PACKET_EGRESS_TIMEOUT 350
diff --git a/drivers/infiniband/hw/hfi1/user_sdma.c b/drivers/infiniband/hw/hfi1/user_sdma.c
index 44eb867b91f4..95e726a9ffe8 100644
--- a/drivers/infiniband/hw/hfi1/user_sdma.c
+++ b/drivers/infiniband/hw/hfi1/user_sdma.c
@@ -550,6 +550,8 @@ int hfi1_user_sdma_process_request(struct file *fp, struct iovec *iovec,
 	struct sdma_req_info info;
 	struct user_sdma_request *req;
 	u8 opcode, sc, vl;
+	u16 pkey;
+	u32 slid;
 	int req_queued = 0;
 	u16 dlid;
 	u32 selector;
@@ -683,8 +685,9 @@ int hfi1_user_sdma_process_request(struct file *fp, struct iovec *iovec,
 	}
 
 	/* Checking P_KEY for requests from user-space */
-	if (egress_pkey_check(dd->pport, req->hdr.lrh, req->hdr.bth, sc,
-			      PKEY_CHECK_INVALID)) {
+	pkey = (u16)be32_to_cpu(req->hdr.bth[0]);
+	slid = be16_to_cpu(req->hdr.lrh[3]);
+	if (egress_pkey_check(dd->pport, slid, pkey, sc, PKEY_CHECK_INVALID)) {
 		ret = -EINVAL;
 		goto free_req;
 	}
* Unmerged path drivers/infiniband/hw/hfi1/verbs.c
diff --git a/drivers/infiniband/hw/hfi1/verbs.h b/drivers/infiniband/hw/hfi1/verbs.h
index 76081f770f70..7ae847bf5cce 100644
--- a/drivers/infiniband/hw/hfi1/verbs.h
+++ b/drivers/infiniband/hw/hfi1/verbs.h
@@ -142,6 +142,7 @@ struct hfi1_pkt_state {
 	unsigned long timeout;
 	unsigned long timeout_int;
 	int cpu;
+	u8 opcode;
 	bool in_thread;
 };
 
