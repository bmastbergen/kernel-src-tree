scsi: lpfc: Fix NVME PRLI handling during RSCN

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] lpfc: Fix NVME PRLI handling during RSCN (Dick Kennedy) [1385844 1461977 1387768]
Rebuild_FUZZ: 93.02%
commit-author Dick Kennedy <dick.kennedy@broadcom.com>
commit 991f0c0e33e2a57120970d28c08384c77505bfca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/991f0c0e.failed

A race condition was found whereby the initiator would receive the RSCN
for a new NVME device before it had a chance to register its FC4 support
with the fabric. Thus, when queried by the initiator, it would see that
the target supported FC-NVME.

Corrected by making the assumption that the target always supports
FC-NVME thus a PRLI is sent. It's ok for the target to reject it.

	Signed-off-by: Dick Kennedy <dick.kennedy@broadcom.com>
	Signed-off-by: James Smart <james.smart@broadcom.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 991f0c0e33e2a57120970d28c08384c77505bfca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_els.c
diff --cc drivers/scsi/lpfc/lpfc_els.c
index 87524fc4d391,6de470e158ef..000000000000
--- a/drivers/scsi/lpfc/lpfc_els.c
+++ b/drivers/scsi/lpfc/lpfc_els.c
@@@ -2147,10 -2174,51 +2147,54 @@@ lpfc_issue_els_prli(struct lpfc_vport *
  	struct lpfc_iocbq *elsiocb;
  	uint8_t *pcmd;
  	uint16_t cmdsize;
++<<<<<<< HEAD
++=======
+ 	u32 local_nlp_type, elscmd;
+ 
+ 	/*
+ 	 * If we are in RSCN mode, the FC4 types supported from a
+ 	 * previous GFT_ID command may not be accurate. So, if we
+ 	 * are a NVME Initiator, always look for the possibility of
+ 	 * the remote NPort beng a NVME Target.
+ 	 */
+ 	if (phba->sli_rev == LPFC_SLI_REV4 &&
+ 	    vport->fc_flag & FC_RSCN_MODE &&
+ 	    vport->nvmei_support)
+ 		ndlp->nlp_fc4_type |= NLP_FC4_NVME;
+ 	local_nlp_type = ndlp->nlp_fc4_type;
+ 
+  send_next_prli:
+ 	if (local_nlp_type & NLP_FC4_FCP) {
+ 		/* Payload is 4 + 16 = 20 x14 bytes. */
+ 		cmdsize = (sizeof(uint32_t) + sizeof(PRLI));
+ 		elscmd = ELS_CMD_PRLI;
+ 	} else if (local_nlp_type & NLP_FC4_NVME) {
+ 		/* Payload is 4 + 20 = 24 x18 bytes. */
+ 		cmdsize = (sizeof(uint32_t) + sizeof(struct lpfc_nvme_prli));
+ 		elscmd = ELS_CMD_NVMEPRLI;
+ 	} else {
+ 		lpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,
+ 				 "3083 Unknown FC_TYPE x%x ndlp x%06x\n",
+ 				 ndlp->nlp_fc4_type, ndlp->nlp_DID);
+ 		return 1;
+ 	}
+ 
+ 	/* SLI3 ports don't support NVME.  If this rport is a strict NVME
+ 	 * FC4 type, implicitly LOGO.
+ 	 */
+ 	if (phba->sli_rev == LPFC_SLI_REV3 &&
+ 	    ndlp->nlp_fc4_type == NLP_FC4_NVME) {
+ 		lpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,
+ 				 "3088 Rport fc4 type 0x%x not supported by SLI3 adapter\n",
+ 				 ndlp->nlp_type);
+ 		lpfc_disc_state_machine(vport, ndlp, NULL, NLP_EVT_DEVICE_RM);
+ 		return 1;
+ 	}
++>>>>>>> 991f0c0e33e2 (scsi: lpfc: Fix NVME PRLI handling during RSCN)
  
 +	cmdsize = (sizeof(uint32_t) + sizeof(PRLI));
  	elsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp,
 -				     ndlp->nlp_DID, elscmd);
 +				     ndlp->nlp_DID, ELS_CMD_PRLI);
  	if (!elsiocb)
  		return 1;
  
* Unmerged path drivers/scsi/lpfc/lpfc_els.c
