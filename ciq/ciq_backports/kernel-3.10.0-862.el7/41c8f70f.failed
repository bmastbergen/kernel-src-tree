xprtrdma: Harden backchannel call decoding

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 41c8f70f5a3db7e06179186b6525fd9ee1d7d314
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/41c8f70f.failed

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 41c8f70f5a3db7e06179186b6525fd9ee1d7d314)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/sunrpc/xdr.h
diff --cc include/linux/sunrpc/xdr.h
index 56c48c884a24,86b59e3525a5..000000000000
--- a/include/linux/sunrpc/xdr.h
+++ b/include/linux/sunrpc/xdr.h
@@@ -242,6 -239,198 +242,201 @@@ extern unsigned int xdr_read_pages(stru
  extern void xdr_enter_page(struct xdr_stream *xdr, unsigned int len);
  extern int xdr_process_buf(struct xdr_buf *buf, unsigned int offset, unsigned int len, int (*actor)(struct scatterlist *, void *), void *data);
  
++<<<<<<< HEAD
++=======
+ /**
+  * xdr_stream_remaining - Return the number of bytes remaining in the stream
+  * @xdr: pointer to struct xdr_stream
+  *
+  * Return value:
+  *   Number of bytes remaining in @xdr before xdr->end
+  */
+ static inline size_t
+ xdr_stream_remaining(const struct xdr_stream *xdr)
+ {
+ 	return xdr->nwords << 2;
+ }
+ 
+ ssize_t xdr_stream_decode_string_dup(struct xdr_stream *xdr, char **str,
+ 		size_t maxlen, gfp_t gfp_flags);
+ /**
+  * xdr_align_size - Calculate padded size of an object
+  * @n: Size of an object being XDR encoded (in bytes)
+  *
+  * Return value:
+  *   Size (in bytes) of the object including xdr padding
+  */
+ static inline size_t
+ xdr_align_size(size_t n)
+ {
+ 	const size_t mask = sizeof(__u32) - 1;
+ 
+ 	return (n + mask) & ~mask;
+ }
+ 
+ /**
+  * xdr_stream_encode_u32 - Encode a 32-bit integer
+  * @xdr: pointer to xdr_stream
+  * @n: integer to encode
+  *
+  * Return values:
+  *   On success, returns length in bytes of XDR buffer consumed
+  *   %-EMSGSIZE on XDR buffer overflow
+  */
+ static inline ssize_t
+ xdr_stream_encode_u32(struct xdr_stream *xdr, __u32 n)
+ {
+ 	const size_t len = sizeof(n);
+ 	__be32 *p = xdr_reserve_space(xdr, len);
+ 
+ 	if (unlikely(!p))
+ 		return -EMSGSIZE;
+ 	*p = cpu_to_be32(n);
+ 	return len;
+ }
+ 
+ /**
+  * xdr_stream_encode_u64 - Encode a 64-bit integer
+  * @xdr: pointer to xdr_stream
+  * @n: 64-bit integer to encode
+  *
+  * Return values:
+  *   On success, returns length in bytes of XDR buffer consumed
+  *   %-EMSGSIZE on XDR buffer overflow
+  */
+ static inline ssize_t
+ xdr_stream_encode_u64(struct xdr_stream *xdr, __u64 n)
+ {
+ 	const size_t len = sizeof(n);
+ 	__be32 *p = xdr_reserve_space(xdr, len);
+ 
+ 	if (unlikely(!p))
+ 		return -EMSGSIZE;
+ 	xdr_encode_hyper(p, n);
+ 	return len;
+ }
+ 
+ /**
+  * xdr_stream_encode_opaque_fixed - Encode fixed length opaque xdr data
+  * @xdr: pointer to xdr_stream
+  * @ptr: pointer to opaque data object
+  * @len: size of object pointed to by @ptr
+  *
+  * Return values:
+  *   On success, returns length in bytes of XDR buffer consumed
+  *   %-EMSGSIZE on XDR buffer overflow
+  */
+ static inline ssize_t
+ xdr_stream_encode_opaque_fixed(struct xdr_stream *xdr, const void *ptr, size_t len)
+ {
+ 	__be32 *p = xdr_reserve_space(xdr, len);
+ 
+ 	if (unlikely(!p))
+ 		return -EMSGSIZE;
+ 	xdr_encode_opaque_fixed(p, ptr, len);
+ 	return xdr_align_size(len);
+ }
+ 
+ /**
+  * xdr_stream_encode_opaque - Encode variable length opaque xdr data
+  * @xdr: pointer to xdr_stream
+  * @ptr: pointer to opaque data object
+  * @len: size of object pointed to by @ptr
+  *
+  * Return values:
+  *   On success, returns length in bytes of XDR buffer consumed
+  *   %-EMSGSIZE on XDR buffer overflow
+  */
+ static inline ssize_t
+ xdr_stream_encode_opaque(struct xdr_stream *xdr, const void *ptr, size_t len)
+ {
+ 	size_t count = sizeof(__u32) + xdr_align_size(len);
+ 	__be32 *p = xdr_reserve_space(xdr, count);
+ 
+ 	if (unlikely(!p))
+ 		return -EMSGSIZE;
+ 	xdr_encode_opaque(p, ptr, len);
+ 	return count;
+ }
+ 
+ /**
+  * xdr_stream_decode_u32 - Decode a 32-bit integer
+  * @xdr: pointer to xdr_stream
+  * @ptr: location to store integer
+  *
+  * Return values:
+  *   %0 on success
+  *   %-EBADMSG on XDR buffer overflow
+  */
+ static inline ssize_t
+ xdr_stream_decode_u32(struct xdr_stream *xdr, __u32 *ptr)
+ {
+ 	const size_t count = sizeof(*ptr);
+ 	__be32 *p = xdr_inline_decode(xdr, count);
+ 
+ 	if (unlikely(!p))
+ 		return -EBADMSG;
+ 	*ptr = be32_to_cpup(p);
+ 	return 0;
+ }
+ 
+ /**
+  * xdr_stream_decode_opaque_fixed - Decode fixed length opaque xdr data
+  * @xdr: pointer to xdr_stream
+  * @ptr: location to store data
+  * @len: size of buffer pointed to by @ptr
+  *
+  * Return values:
+  *   On success, returns size of object stored in @ptr
+  *   %-EBADMSG on XDR buffer overflow
+  */
+ static inline ssize_t
+ xdr_stream_decode_opaque_fixed(struct xdr_stream *xdr, void *ptr, size_t len)
+ {
+ 	__be32 *p = xdr_inline_decode(xdr, len);
+ 
+ 	if (unlikely(!p))
+ 		return -EBADMSG;
+ 	xdr_decode_opaque_fixed(p, ptr, len);
+ 	return len;
+ }
+ 
+ /**
+  * xdr_stream_decode_opaque_inline - Decode variable length opaque xdr data
+  * @xdr: pointer to xdr_stream
+  * @ptr: location to store pointer to opaque data
+  * @maxlen: maximum acceptable object size
+  *
+  * Note: the pointer stored in @ptr cannot be assumed valid after the XDR
+  * buffer has been destroyed, or even after calling xdr_inline_decode()
+  * on @xdr. It is therefore expected that the object it points to should
+  * be processed immediately.
+  *
+  * Return values:
+  *   On success, returns size of object stored in *@ptr
+  *   %-EBADMSG on XDR buffer overflow
+  *   %-EMSGSIZE if the size of the object would exceed @maxlen
+  */
+ static inline ssize_t
+ xdr_stream_decode_opaque_inline(struct xdr_stream *xdr, void **ptr, size_t maxlen)
+ {
+ 	__be32 *p;
+ 	__u32 len;
+ 
+ 	*ptr = NULL;
+ 	if (unlikely(xdr_stream_decode_u32(xdr, &len) < 0))
+ 		return -EBADMSG;
+ 	if (len != 0) {
+ 		p = xdr_inline_decode(xdr, len);
+ 		if (unlikely(!p))
+ 			return -EBADMSG;
+ 		if (unlikely(len > maxlen))
+ 			return -EMSGSIZE;
+ 		*ptr = p;
+ 	}
+ 	return len;
+ }
++>>>>>>> 41c8f70f5a3d (xprtrdma: Harden backchannel call decoding)
  #endif /* __KERNEL__ */
  
  #endif /* _SUNRPC_XDR_H_ */
* Unmerged path include/linux/sunrpc/xdr.h
diff --git a/net/sunrpc/xprtrdma/backchannel.c b/net/sunrpc/xprtrdma/backchannel.c
index 03f6b5840764..183a103e08a8 100644
--- a/net/sunrpc/xprtrdma/backchannel.c
+++ b/net/sunrpc/xprtrdma/backchannel.c
@@ -271,9 +271,6 @@ void xprt_rdma_bc_free_rqst(struct rpc_rqst *rqst)
  * @xprt: transport receiving the call
  * @rep: receive buffer containing the call
  *
- * Called in the RPC reply handler, which runs in a tasklet.
- * Be quick about it.
- *
  * Operational assumptions:
  *    o Backchannel credits are ignored, just as the NFS server
  *      forechannel currently does
@@ -284,7 +281,6 @@ void rpcrdma_bc_receive_call(struct rpcrdma_xprt *r_xprt,
 			     struct rpcrdma_rep *rep)
 {
 	struct rpc_xprt *xprt = &r_xprt->rx_xprt;
-	struct rpcrdma_msg *headerp;
 	struct svc_serv *bc_serv;
 	struct rpcrdma_req *req;
 	struct rpc_rqst *rqst;
@@ -292,24 +288,15 @@ void rpcrdma_bc_receive_call(struct rpcrdma_xprt *r_xprt,
 	size_t size;
 	__be32 *p;
 
-	headerp = rdmab_to_msg(rep->rr_rdmabuf);
+	p = xdr_inline_decode(&rep->rr_stream, 0);
+	size = xdr_stream_remaining(&rep->rr_stream);
+
 #ifdef RPCRDMA_BACKCHANNEL_DEBUG
 	pr_info("RPC:       %s: callback XID %08x, length=%u\n",
-		__func__, be32_to_cpu(headerp->rm_xid), rep->rr_len);
-	pr_info("RPC:       %s: %*ph\n", __func__, rep->rr_len, headerp);
+		__func__, be32_to_cpup(p), size);
+	pr_info("RPC:       %s: %*ph\n", __func__, size, p);
 #endif
 
-	/* Sanity check:
-	 * Need at least enough bytes for RPC/RDMA header, as code
-	 * here references the header fields by array offset. Also,
-	 * backward calls are always inline, so ensure there
-	 * are some bytes beyond the RPC/RDMA header.
-	 */
-	if (rep->rr_len < RPCRDMA_HDRLEN_MIN + 24)
-		goto out_short;
-	p = (__be32 *)((unsigned char *)headerp + RPCRDMA_HDRLEN_MIN);
-	size = rep->rr_len - RPCRDMA_HDRLEN_MIN;
-
 	/* Grab a free bc rqst */
 	spin_lock(&xprt->bc_pa_lock);
 	if (list_empty(&xprt->bc_pa_list)) {
@@ -325,7 +312,7 @@ void rpcrdma_bc_receive_call(struct rpcrdma_xprt *r_xprt,
 	/* Prepare rqst */
 	rqst->rq_reply_bytes_recvd = 0;
 	rqst->rq_bytes_sent = 0;
-	rqst->rq_xid = headerp->rm_xid;
+	rqst->rq_xid = *p;
 
 	rqst->rq_private_buf.len = size;
 	set_bit(RPC_BC_PA_IN_USE, &rqst->rq_bc_pa_state);
@@ -337,9 +324,9 @@ void rpcrdma_bc_receive_call(struct rpcrdma_xprt *r_xprt,
 	buf->len = size;
 
 	/* The receive buffer has to be hooked to the rpcrdma_req
-	 * so that it can be reposted after the server is done
-	 * parsing it but just before sending the backward
-	 * direction reply.
+	 * so that it is not released while the req is pointing
+	 * to its buffer, and so that it can be reposted after
+	 * the Upper Layer is done decoding it.
 	 */
 	req = rpcr_to_rdmar(rqst);
 	dprintk("RPC:       %s: attaching rep %p to req %p\n",
@@ -367,13 +354,4 @@ out_overflow:
 	 * when the connection is re-established.
 	 */
 	return;
-
-out_short:
-	pr_warn("RPC/RDMA short backward direction call\n");
-
-	if (rpcrdma_ep_post_recv(&r_xprt->rx_ia, rep))
-		xprt_disconnect_done(xprt);
-	else
-		pr_warn("RPC:       %s: reposting rep %p\n",
-			__func__, rep);
 }
diff --git a/net/sunrpc/xprtrdma/rpc_rdma.c b/net/sunrpc/xprtrdma/rpc_rdma.c
index 24f58c7b3106..9b5ab598ab7b 100644
--- a/net/sunrpc/xprtrdma/rpc_rdma.c
+++ b/net/sunrpc/xprtrdma/rpc_rdma.c
@@ -949,35 +949,59 @@ rpcrdma_mark_remote_invalidation(struct list_head *mws,
 		}
 }
 
-#if defined(CONFIG_SUNRPC_BACKCHANNEL)
 /* By convention, backchannel calls arrive via rdma_msg type
  * messages, and never populate the chunk lists. This makes
  * the RPC/RDMA header small and fixed in size, so it is
  * straightforward to check the RPC header's direction field.
  */
 static bool
-rpcrdma_is_bcall(struct rpcrdma_msg *headerp)
+rpcrdma_is_bcall(struct rpcrdma_xprt *r_xprt, struct rpcrdma_rep *rep,
+		 __be32 xid, __be32 proc)
+#if defined(CONFIG_SUNRPC_BACKCHANNEL)
 {
-	__be32 *p = (__be32 *)headerp;
+	struct xdr_stream *xdr = &rep->rr_stream;
+	__be32 *p;
 
-	if (headerp->rm_type != rdma_msg)
+	if (proc != rdma_msg)
 		return false;
-	if (headerp->rm_body.rm_chunks[0] != xdr_zero)
+
+	/* Peek at stream contents without advancing. */
+	p = xdr_inline_decode(xdr, 0);
+
+	/* Chunk lists */
+	if (*p++ != xdr_zero)
 		return false;
-	if (headerp->rm_body.rm_chunks[1] != xdr_zero)
+	if (*p++ != xdr_zero)
 		return false;
-	if (headerp->rm_body.rm_chunks[2] != xdr_zero)
+	if (*p++ != xdr_zero)
 		return false;
 
-	/* sanity */
-	if (p[7] != headerp->rm_xid)
+	/* RPC header */
+	if (*p++ != xid)
 		return false;
-	/* call direction */
-	if (p[8] != cpu_to_be32(RPC_CALL))
+	if (*p != cpu_to_be32(RPC_CALL))
 		return false;
 
+	/* Now that we are sure this is a backchannel call,
+	 * advance to the RPC header.
+	 */
+	p = xdr_inline_decode(xdr, 3 * sizeof(*p));
+	if (unlikely(!p))
+		goto out_short;
+
+	rpcrdma_bc_receive_call(r_xprt, rep);
+	return true;
+
+out_short:
+	pr_warn("RPC/RDMA short backward direction call\n");
+	if (rpcrdma_ep_post_recv(&r_xprt->rx_ia, rep))
+		xprt_disconnect_done(&r_xprt->rx_xprt);
 	return true;
 }
+#else	/* CONFIG_SUNRPC_BACKCHANNEL */
+{
+	return false;
+}
 #endif	/* CONFIG_SUNRPC_BACKCHANNEL */
 
 /* Process received RPC/RDMA messages.
@@ -1020,10 +1044,8 @@ rpcrdma_reply_handler(struct work_struct *work)
 	proc = *p++;
 
 	headerp = rdmab_to_msg(rep->rr_rdmabuf);
-#if defined(CONFIG_SUNRPC_BACKCHANNEL)
-	if (rpcrdma_is_bcall(headerp))
-		goto out_bcall;
-#endif
+	if (rpcrdma_is_bcall(r_xprt, rep, xid, proc))
+		return;
 
 	/* Match incoming rpcrdma_rep to an rpcrdma_req to
 	 * get context for handling any incoming chunks.
@@ -1159,12 +1181,6 @@ out_badstatus:
 	}
 	return;
 
-#if defined(CONFIG_SUNRPC_BACKCHANNEL)
-out_bcall:
-	rpcrdma_bc_receive_call(r_xprt, rep);
-	return;
-#endif
-
 /* If the incoming reply terminated a pending RPC, the next
  * RPC call will post a replacement receive buffer as it is
  * being marshaled.
