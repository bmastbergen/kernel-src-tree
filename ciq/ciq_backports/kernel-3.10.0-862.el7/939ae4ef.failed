ovl: fix false positive ESTALE on lookup

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 939ae4efd51c627da270af74ef069db5124cb5b0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/939ae4ef.failed

Commit b9ac5c274b8c ("ovl: hash overlay non-dir inodes by copy up origin")
verifies that the origin lower inode stored in the overlayfs inode matched
the inode of a copy up origin dentry found by lookup.

There is a false positive result in that check when lower fs does not
support file handles and copy up origin cannot be followed by file handle
at lookup time.

The false negative happens when finding an overlay inode in cache on a
copied up overlay dentry lookup. The overlay inode still 'remembers' the
copy up origin inode, but the copy up origin dentry is not available for
verification.

Relax the check in case copy up origin dentry is not available.

Fixes: b9ac5c274b8c ("ovl: hash overlay non-dir inodes by copy up...")
	Cc: <stable@vger.kernel.org> # v4.13
	Reported-by: Jordi Pujol <jordipujolp@gmail.com>
	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 939ae4efd51c627da270af74ef069db5124cb5b0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/inode.c
diff --cc fs/overlayfs/inode.c
index e60c6d748742,a619addecafc..000000000000
--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@@ -436,18 -576,81 +436,44 @@@ static int ovl_inode_set(struct inode *
  	return 0;
  }
  
 -static bool ovl_verify_inode(struct inode *inode, struct dentry *lowerdentry,
 -			     struct dentry *upperdentry)
 +struct inode *ovl_get_inode(struct super_block *sb, struct inode *realinode)
 +
  {
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * Allow non-NULL lower inode in ovl_inode even if lowerdentry is NULL.
+ 	 * This happens when finding a copied up overlay inode for a renamed
+ 	 * or hardlinked overlay dentry and lower dentry cannot be followed
+ 	 * by origin because lower fs does not support file handles.
+ 	 */
+ 	if (lowerdentry && ovl_inode_lower(inode) != d_inode(lowerdentry))
+ 		return false;
+ 
+ 	/*
+ 	 * Allow non-NULL __upperdentry in inode even if upperdentry is NULL.
+ 	 * This happens when finding a lower alias for a copied up hard link.
+ 	 */
+ 	if (upperdentry && ovl_inode_upper(inode) != d_inode(upperdentry))
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ struct inode *ovl_get_inode(struct dentry *dentry, struct dentry *upperdentry)
+ {
+ 	struct dentry *lowerdentry = ovl_dentry_lower(dentry);
+ 	struct inode *realinode = upperdentry ? d_inode(upperdentry) : NULL;
++>>>>>>> 939ae4efd51c (ovl: fix false positive ESTALE on lookup)
  	struct inode *inode;
  
 -	if (!realinode)
 -		realinode = d_inode(lowerdentry);
 -
 -	if (!S_ISDIR(realinode->i_mode) &&
 -	    (upperdentry || (lowerdentry && ovl_indexdir(dentry->d_sb)))) {
 -		struct inode *key = d_inode(lowerdentry ?: upperdentry);
 -		unsigned int nlink;
 -
 -		inode = iget5_locked(dentry->d_sb, (unsigned long) key,
 -				     ovl_inode_test, ovl_inode_set, key);
 -		if (!inode)
 -			goto out_nomem;
 -		if (!(inode->i_state & I_NEW)) {
 -			/*
 -			 * Verify that the underlying files stored in the inode
 -			 * match those in the dentry.
 -			 */
 -			if (!ovl_verify_inode(inode, lowerdentry, upperdentry)) {
 -				iput(inode);
 -				inode = ERR_PTR(-ESTALE);
 -				goto out;
 -			}
 -
 -			dput(upperdentry);
 -			goto out;
 -		}
 -
 -		nlink = ovl_get_nlink(lowerdentry, upperdentry,
 -				      realinode->i_nlink);
 -		set_nlink(inode, nlink);
 -	} else {
 -		inode = new_inode(dentry->d_sb);
 -		if (!inode)
 -			goto out_nomem;
 +	inode = iget5_locked(sb, (unsigned long) realinode,
 +			     ovl_inode_test, ovl_inode_set, realinode);
 +	if (inode && inode->i_state & I_NEW) {
 +		ovl_fill_inode(inode, realinode->i_mode);
 +		set_nlink(inode, realinode->i_nlink);
 +		unlock_new_inode(inode);
  	}
 -	ovl_fill_inode(inode, realinode->i_mode, realinode->i_rdev);
 -	ovl_inode_init(inode, upperdentry, lowerdentry);
 -
 -	if (upperdentry && ovl_is_impuredir(upperdentry))
 -		ovl_set_flag(OVL_IMPURE, inode);
  
 -	if (inode->i_state & I_NEW)
 -		unlock_new_inode(inode);
 -out:
  	return inode;
 -
 -out_nomem:
 -	inode = ERR_PTR(-ENOMEM);
 -	goto out;
  }
* Unmerged path fs/overlayfs/inode.c
