x86/intel_rdt/cqm: Add info files for RDT monitoring

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] intel_rdt/cqm: Add info files for RDT monitoring (Jiri Olsa) [1457533]
Rebuild_FUZZ: 96.00%
commit-author Vikas Shivappa <vikas.shivappa@linux.intel.com>
commit d4ab33201029913b594ae785a9665f45040396ab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d4ab3320.failed

Add info directory files specific to RDT monitoring.

 num_rmids:
    The number of RMIDs which are valid for the resource.

 mon_features:
    Lists the monitoring events if monitoring is enabled for the
    resource.

 max_threshold_occupancy:
    This is specific to llc_occupancy monitoring and is used to
    determine if an RMID can be reused. Provides an upper bound on the
    threshold and is shown to the user in bytes though the internal
    value will be rounded to the scaling factor supported by the h/w.

	Signed-off-by: Vikas Shivappa <vikas.shivappa@linux.intel.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: ravi.v.shankar@intel.com
	Cc: tony.luck@intel.com
	Cc: fenghua.yu@intel.com
	Cc: peterz@infradead.org
	Cc: eranian@google.com
	Cc: vikas.shivappa@intel.com
	Cc: ak@linux.intel.com
	Cc: davidcc@google.com
	Cc: reinette.chatre@intel.com
Link: http://lkml.kernel.org/r/1501017287-28083-12-git-send-email-vikas.shivappa@linux.intel.com

(cherry picked from commit d4ab33201029913b594ae785a9665f45040396ab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/intel_rdt.h
#	arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
diff --cc arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
index 1c3603d97e9d,14489a5ecf12..000000000000
--- a/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
+++ b/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
@@@ -475,8 -454,177 +475,182 @@@ static int rdtgroup_tasks_show(struct k
  	return ret;
  }
  
++<<<<<<< HEAD
 +/* Files in each rdtgroup */
 +static struct rftype rdtgroup_base_files[] = {
++=======
+ static int rdt_num_closids_show(struct kernfs_open_file *of,
+ 				struct seq_file *seq, void *v)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 
+ 	seq_printf(seq, "%d\n", r->num_closid);
+ 	return 0;
+ }
+ 
+ static int rdt_default_ctrl_show(struct kernfs_open_file *of,
+ 			     struct seq_file *seq, void *v)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 
+ 	seq_printf(seq, "%x\n", r->default_ctrl);
+ 	return 0;
+ }
+ 
+ static int rdt_min_cbm_bits_show(struct kernfs_open_file *of,
+ 			     struct seq_file *seq, void *v)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 
+ 	seq_printf(seq, "%u\n", r->cache.min_cbm_bits);
+ 	return 0;
+ }
+ 
+ static int rdt_min_bw_show(struct kernfs_open_file *of,
+ 			     struct seq_file *seq, void *v)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 
+ 	seq_printf(seq, "%u\n", r->membw.min_bw);
+ 	return 0;
+ }
+ 
+ static int rdt_num_rmids_show(struct kernfs_open_file *of,
+ 			      struct seq_file *seq, void *v)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 
+ 	seq_printf(seq, "%d\n", r->num_rmid);
+ 
+ 	return 0;
+ }
+ 
+ static int rdt_mon_features_show(struct kernfs_open_file *of,
+ 				 struct seq_file *seq, void *v)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 	struct mon_evt *mevt;
+ 
+ 	list_for_each_entry(mevt, &r->evt_list, list)
+ 		seq_printf(seq, "%s\n", mevt->name);
+ 
+ 	return 0;
+ }
+ 
+ static int rdt_bw_gran_show(struct kernfs_open_file *of,
+ 			     struct seq_file *seq, void *v)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 
+ 	seq_printf(seq, "%u\n", r->membw.bw_gran);
+ 	return 0;
+ }
+ 
+ static int rdt_delay_linear_show(struct kernfs_open_file *of,
+ 			     struct seq_file *seq, void *v)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 
+ 	seq_printf(seq, "%u\n", r->membw.delay_linear);
+ 	return 0;
+ }
+ 
+ static int max_threshold_occ_show(struct kernfs_open_file *of,
+ 				  struct seq_file *seq, void *v)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 
+ 	seq_printf(seq, "%u\n", intel_cqm_threshold * r->mon_scale);
+ 
+ 	return 0;
+ }
+ 
+ static ssize_t max_threshold_occ_write(struct kernfs_open_file *of,
+ 				       char *buf, size_t nbytes, loff_t off)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 	unsigned int bytes;
+ 	int ret;
+ 
+ 	ret = kstrtouint(buf, 0, &bytes);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (bytes > (boot_cpu_data.x86_cache_size * 1024))
+ 		return -EINVAL;
+ 
+ 	intel_cqm_threshold = bytes / r->mon_scale;
+ 
+ 	return ret ?: nbytes;
+ }
+ 
+ /* rdtgroup information files for one cache resource. */
+ static struct rftype res_common_files[] = {
+ 	{
+ 		.name		= "num_closids",
+ 		.mode		= 0444,
+ 		.kf_ops		= &rdtgroup_kf_single_ops,
+ 		.seq_show	= rdt_num_closids_show,
+ 		.fflags		= RF_CTRL_INFO,
+ 	},
+ 	{
+ 		.name		= "mon_features",
+ 		.mode		= 0444,
+ 		.kf_ops		= &rdtgroup_kf_single_ops,
+ 		.seq_show	= rdt_mon_features_show,
+ 		.fflags		= RF_MON_INFO,
+ 	},
+ 	{
+ 		.name		= "num_rmids",
+ 		.mode		= 0444,
+ 		.kf_ops		= &rdtgroup_kf_single_ops,
+ 		.seq_show	= rdt_num_rmids_show,
+ 		.fflags		= RF_MON_INFO,
+ 	},
+ 	{
+ 		.name		= "cbm_mask",
+ 		.mode		= 0444,
+ 		.kf_ops		= &rdtgroup_kf_single_ops,
+ 		.seq_show	= rdt_default_ctrl_show,
+ 		.fflags		= RF_CTRL_INFO | RFTYPE_RES_CACHE,
+ 	},
+ 	{
+ 		.name		= "min_cbm_bits",
+ 		.mode		= 0444,
+ 		.kf_ops		= &rdtgroup_kf_single_ops,
+ 		.seq_show	= rdt_min_cbm_bits_show,
+ 		.fflags		= RF_CTRL_INFO | RFTYPE_RES_CACHE,
+ 	},
+ 	{
+ 		.name		= "min_bandwidth",
+ 		.mode		= 0444,
+ 		.kf_ops		= &rdtgroup_kf_single_ops,
+ 		.seq_show	= rdt_min_bw_show,
+ 		.fflags		= RF_CTRL_INFO | RFTYPE_RES_MB,
+ 	},
+ 	{
+ 		.name		= "bandwidth_gran",
+ 		.mode		= 0444,
+ 		.kf_ops		= &rdtgroup_kf_single_ops,
+ 		.seq_show	= rdt_bw_gran_show,
+ 		.fflags		= RF_CTRL_INFO | RFTYPE_RES_MB,
+ 	},
+ 	{
+ 		.name		= "delay_linear",
+ 		.mode		= 0444,
+ 		.kf_ops		= &rdtgroup_kf_single_ops,
+ 		.seq_show	= rdt_delay_linear_show,
+ 		.fflags		= RF_CTRL_INFO | RFTYPE_RES_MB,
+ 	},
++>>>>>>> d4ab33201029 (x86/intel_rdt/cqm: Add info files for RDT monitoring)
+ 	{
+ 		.name		= "max_threshold_occupancy",
+ 		.mode		= 0644,
+ 		.kf_ops		= &rdtgroup_kf_single_ops,
+ 		.write		= max_threshold_occ_write,
+ 		.seq_show	= max_threshold_occ_show,
+ 		.fflags		= RF_MON_INFO | RFTYPE_RES_CACHE,
+ 	},
  	{
  		.name		= "cpus",
  		.mode		= 0644,
@@@ -508,62 -659,63 +682,67 @@@
  	},
  };
  
 -static int rdtgroup_add_files(struct kernfs_node *kn, unsigned long fflags)
 +static int rdt_num_closids_show(struct kernfs_open_file *of,
 +				struct seq_file *seq, void *v)
  {
 -	struct rftype *rfts, *rft;
 -	int ret, len;
 -
 -	rfts = res_common_files;
 -	len = ARRAY_SIZE(res_common_files);
 -
 -	lockdep_assert_held(&rdtgroup_mutex);
 +	struct rdt_resource *r = of->kn->parent->priv;
  
 -	for (rft = rfts; rft < rfts + len; rft++) {
 -		if ((fflags & rft->fflags) == rft->fflags) {
 -			ret = rdtgroup_add_file(kn, rft);
 -			if (ret)
 -				goto error;
 -		}
 -	}
 +	seq_printf(seq, "%d\n", r->num_closid);
  
  	return 0;
 -error:
 -	pr_warn("Failed to add %s, err=%d\n", rft->name, ret);
 -	while (--rft >= rfts) {
 -		if ((fflags & rft->fflags) == rft->fflags)
 -			kernfs_remove_by_name(kn, rft->name);
 -	}
 -	return ret;
  }
  
 -static int rdtgroup_mkdir_info_resdir(struct rdt_resource *r, char *name,
 -				      unsigned long fflags)
 +static int rdt_cbm_mask_show(struct kernfs_open_file *of,
 +			     struct seq_file *seq, void *v)
  {
 -	struct kernfs_node *kn_subdir;
 -	int ret;
 +	struct rdt_resource *r = of->kn->parent->priv;
  
 -	kn_subdir = kernfs_create_dir(kn_info, name,
 -				      kn_info->mode, r);
 -	if (IS_ERR(kn_subdir))
 -		return PTR_ERR(kn_subdir);
 +	seq_printf(seq, "%x\n", r->max_cbm);
  
 -	kernfs_get(kn_subdir);
 -	ret = rdtgroup_kn_set_ugid(kn_subdir);
 -	if (ret)
 -		return ret;
 +	return 0;
 +}
  
 -	ret = rdtgroup_add_files(kn_subdir, fflags);
 -	if (!ret)
 -		kernfs_activate(kn_subdir);
 +static int rdt_min_cbm_bits_show(struct kernfs_open_file *of,
 +			     struct seq_file *seq, void *v)
 +{
 +	struct rdt_resource *r = of->kn->parent->priv;
  
 -	return ret;
 +	seq_printf(seq, "%d\n", r->min_cbm_bits);
 +
 +	return 0;
  }
  
 +/* rdtgroup information files for one cache resource. */
 +static struct rftype res_info_files[] = {
 +	{
 +		.name		= "num_closids",
 +		.mode		= 0444,
 +		.kf_ops		= &rdtgroup_kf_single_ops,
 +		.seq_show	= rdt_num_closids_show,
 +	},
 +	{
 +		.name		= "cbm_mask",
 +		.mode		= 0444,
 +		.kf_ops		= &rdtgroup_kf_single_ops,
 +		.seq_show	= rdt_cbm_mask_show,
 +	},
 +	{
 +		.name		= "min_cbm_bits",
 +		.mode		= 0444,
 +		.kf_ops		= &rdtgroup_kf_single_ops,
 +		.seq_show	= rdt_min_cbm_bits_show,
 +	},
 +};
 +
  static int rdtgroup_create_info_dir(struct kernfs_node *parent_kn)
  {
 +	struct kernfs_node *kn_subdir;
  	struct rdt_resource *r;
++<<<<<<< HEAD
++=======
+ 	unsigned long fflags;
+ 	char name[32];
++>>>>>>> d4ab33201029 (x86/intel_rdt/cqm: Add info files for RDT monitoring)
  	int ret;
  
  	/* create the directory */
@@@ -572,24 -724,21 +751,35 @@@
  		return PTR_ERR(kn_info);
  	kernfs_get(kn_info);
  
 -	for_each_alloc_enabled_rdt_resource(r) {
 -		fflags =  r->fflags | RF_CTRL_INFO;
 -		ret = rdtgroup_mkdir_info_resdir(r, r->name, fflags);
 +	for_each_enabled_rdt_resource(r) {
 +		kn_subdir = kernfs_create_dir(kn_info, r->name,
 +					      kn_info->mode, r);
 +		if (IS_ERR(kn_subdir)) {
 +			ret = PTR_ERR(kn_subdir);
 +			goto out_destroy;
 +		}
 +		kernfs_get(kn_subdir);
 +		ret = rdtgroup_kn_set_ugid(kn_subdir);
  		if (ret)
  			goto out_destroy;
 +		ret = rdtgroup_add_files(kn_subdir, res_info_files,
 +					 ARRAY_SIZE(res_info_files));
 +		if (ret)
 +			goto out_destroy;
 +		kernfs_activate(kn_subdir);
  	}
  
++<<<<<<< HEAD
++=======
+ 	for_each_mon_enabled_rdt_resource(r) {
+ 		fflags =  r->fflags | RF_MON_INFO;
+ 		sprintf(name, "%s_MON", r->name);
+ 		ret = rdtgroup_mkdir_info_resdir(r, name, fflags);
+ 		if (ret)
+ 			goto out_destroy;
+ 	}
+ 
++>>>>>>> d4ab33201029 (x86/intel_rdt/cqm: Add info files for RDT monitoring)
  	/*
  	 * This extra ref will be put in kernfs_remove() and guarantees
  	 * that @rdtgrp->kn is always accessible.
* Unmerged path arch/x86/kernel/cpu/intel_rdt.h
* Unmerged path arch/x86/kernel/cpu/intel_rdt.h
* Unmerged path arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
