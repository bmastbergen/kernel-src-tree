x86/dumpstack: Convert show_trace_log_lvl() to use the new unwinder

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] dumpstack: Convert show_trace_log_lvl() to use the new unwinder (Josh Poimboeuf) [1430637]
Rebuild_FUZZ: 96.92%
commit-author Josh Poimboeuf <jpoimboe@redhat.com>
commit e18bcccd1a4ecb41e99678e002ef833586185bf1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e18bcccd.failed

Convert show_trace_log_lvl() to use the new unwinder.  dump_trace() has
been deprecated.

show_trace_log_lvl() is special compared to other users of the unwinder.
It's the only place where both reliable *and* unreliable addresses are
needed.  With frame pointers enabled, most callers of the unwinder don't
want to know about unreliable addresses.  But in this case, when we're
dumping the stack to the console because something presumably went
wrong, the unreliable addresses are useful:

- They show stale data on the stack which can provide useful clues.

- If something goes wrong with the unwinder, or if frame pointers are
  corrupt or missing, all the stack addresses still get shown.

So in order to show all addresses on the stack, and at the same time
figure out which addresses are reliable, we have to do the scanning and
the unwinding in parallel.

The scanning is done with the help of get_stack_info() to traverse the
stacks.  The unwinding is done separately by the new unwinder.

In theory we could simplify show_trace_log_lvl() by instead pushing some
of this logic into the unwind code.  But then we would need some kind of
"fake" frame logic in the unwinder which would add a lot of complexity
and wouldn't be worth it in order to support only one user.

Another benefit of this approach is that once we have a DWARF unwinder,
we should be able to just plug it in with minimal impact to this code.

Another change here is that callers of show_trace_log_lvl() don't need
to provide the 'bp' argument.  The unwinder already finds the relevant
frame pointer by unwinding until it reaches the first frame after the
provided stack pointer.

	Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Byungchul Park <byungchul.park@lge.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Kees Cook <keescook@chromium.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Nilay Vaish <nilayvaish@gmail.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Steven Rostedt <rostedt@goodmis.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/703b5998604c712a1f801874b43f35d6dac52ede.1474045023.git.jpoimboe@redhat.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit e18bcccd1a4ecb41e99678e002ef833586185bf1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/dumpstack.c
#	arch/x86/kernel/dumpstack_32.c
#	arch/x86/kernel/dumpstack_64.c
diff --cc arch/x86/kernel/dumpstack.c
index 08594671b59f,c08f32ab8ace..000000000000
--- a/arch/x86/kernel/dumpstack.c
+++ b/arch/x86/kernel/dumpstack.c
@@@ -147,58 -142,122 +147,147 @@@ print_context_stack_bp(struct thread_in
  }
  EXPORT_SYMBOL_GPL(print_context_stack_bp);
  
++<<<<<<< HEAD
 +static int print_trace_stack(void *data, char *name)
++=======
+ void show_trace_log_lvl(struct task_struct *task, struct pt_regs *regs,
+ 			unsigned long *stack, char *log_lvl)
++>>>>>>> e18bcccd1a4e (x86/dumpstack: Convert show_trace_log_lvl() to use the new unwinder)
  {
- 	printk("%s <%s> ", (char *)data, name);
- 	return 0;
- }
+ 	struct unwind_state state;
+ 	struct stack_info stack_info = {0};
+ 	unsigned long visit_mask = 0;
+ 	int graph_idx = 0;
  
- /*
-  * Print one address/symbol entries per line.
-  */
- static int print_trace_address(void *data, unsigned long addr, int reliable)
- {
- 	printk_stack_address(addr, reliable, data);
- 	return 0;
- }
+ 	printk("%sCall Trace:\n", log_lvl);
  
- static const struct stacktrace_ops print_trace_ops = {
- 	.stack			= print_trace_stack,
- 	.address		= print_trace_address,
- 	.walk_stack		= print_context_stack,
- };
+ 	unwind_start(&state, task, regs, stack);
  
- void
- show_trace_log_lvl(struct task_struct *task, struct pt_regs *regs,
- 		unsigned long *stack, unsigned long bp, char *log_lvl)
- {
- 	printk("%sCall Trace:\n", log_lvl);
- 	dump_trace(task, regs, stack, bp, &print_trace_ops, log_lvl);
+ 	/*
+ 	 * Iterate through the stacks, starting with the current stack pointer.
+ 	 * Each stack has a pointer to the next one.
+ 	 *
+ 	 * x86-64 can have several stacks:
+ 	 * - task stack
+ 	 * - interrupt stack
+ 	 * - HW exception stacks (double fault, nmi, debug, mce)
+ 	 *
+ 	 * x86-32 can have up to three stacks:
+ 	 * - task stack
+ 	 * - softirq stack
+ 	 * - hardirq stack
+ 	 */
+ 	for (; stack; stack = stack_info.next_sp) {
+ 		const char *str_begin, *str_end;
+ 
+ 		/*
+ 		 * If we overflowed the task stack into a guard page, jump back
+ 		 * to the bottom of the usable stack.
+ 		 */
+ 		if (task_stack_page(task) - (void *)stack < PAGE_SIZE)
+ 			stack = task_stack_page(task);
+ 
+ 		if (get_stack_info(stack, task, &stack_info, &visit_mask))
+ 			break;
+ 
+ 		stack_type_str(stack_info.type, &str_begin, &str_end);
+ 		if (str_begin)
+ 			printk("%s <%s> ", log_lvl, str_begin);
+ 
+ 		/*
+ 		 * Scan the stack, printing any text addresses we find.  At the
+ 		 * same time, follow proper stack frames with the unwinder.
+ 		 *
+ 		 * Addresses found during the scan which are not reported by
+ 		 * the unwinder are considered to be additional clues which are
+ 		 * sometimes useful for debugging and are prefixed with '?'.
+ 		 * This also serves as a failsafe option in case the unwinder
+ 		 * goes off in the weeds.
+ 		 */
+ 		for (; stack < stack_info.end; stack++) {
+ 			unsigned long real_addr;
+ 			int reliable = 0;
+ 			unsigned long addr = *stack;
+ 			unsigned long *ret_addr_p =
+ 				unwind_get_return_address_ptr(&state);
+ 
+ 			if (!__kernel_text_address(addr))
+ 				continue;
+ 
+ 			if (stack == ret_addr_p)
+ 				reliable = 1;
+ 
+ 			/*
+ 			 * When function graph tracing is enabled for a
+ 			 * function, its return address on the stack is
+ 			 * replaced with the address of an ftrace handler
+ 			 * (return_to_handler).  In that case, before printing
+ 			 * the "real" address, we want to print the handler
+ 			 * address as an "unreliable" hint that function graph
+ 			 * tracing was involved.
+ 			 */
+ 			real_addr = ftrace_graph_ret_addr(task, &graph_idx,
+ 							  addr, stack);
+ 			if (real_addr != addr)
+ 				printk_stack_address(addr, 0, log_lvl);
+ 			printk_stack_address(real_addr, reliable, log_lvl);
+ 
+ 			if (!reliable)
+ 				continue;
+ 
+ 			/*
+ 			 * Get the next frame from the unwinder.  No need to
+ 			 * check for an error: if anything goes wrong, the rest
+ 			 * of the addresses will just be printed as unreliable.
+ 			 */
+ 			unwind_next_frame(&state);
+ 		}
+ 
+ 		if (str_end)
+ 			printk("%s <%s> ", log_lvl, str_end);
+ 	}
  }
  
 +void show_trace(struct task_struct *task, struct pt_regs *regs,
 +		unsigned long *stack, unsigned long bp)
 +{
 +	show_trace_log_lvl(task, regs, stack, bp, "");
 +}
 +
  void show_stack(struct task_struct *task, unsigned long *sp)
  {
++<<<<<<< HEAD
 +	unsigned long bp = 0;
 +	unsigned long stack;
++=======
+ 	task = task ? : current;
++>>>>>>> e18bcccd1a4e (x86/dumpstack: Convert show_trace_log_lvl() to use the new unwinder)
  
  	/*
  	 * Stack frames below this one aren't interesting.  Don't show them
  	 * if we're printing for %current.
  	 */
++<<<<<<< HEAD
 +	if (!sp && (!task || task == current)) {
 +		sp = &stack;
 +		bp = stack_frame(current, NULL);
 +	}
++=======
+ 	if (!sp && task == current)
+ 		sp = get_stack_pointer(current, NULL);
++>>>>>>> e18bcccd1a4e (x86/dumpstack: Convert show_trace_log_lvl() to use the new unwinder)
  
- 	show_stack_log_lvl(task, NULL, sp, bp, "");
+ 	show_stack_log_lvl(current, NULL, sp, "");
+ }
+ 
++<<<<<<< HEAD
++=======
+ void show_stack_regs(struct pt_regs *regs)
+ {
+ 	show_stack_log_lvl(current, regs, NULL, "");
  }
  
++>>>>>>> e18bcccd1a4e (x86/dumpstack: Convert show_trace_log_lvl() to use the new unwinder)
  static arch_spinlock_t die_lock = __ARCH_SPIN_LOCK_UNLOCKED;
  static int die_owner = -1;
  static unsigned int die_nest_count;
diff --cc arch/x86/kernel/dumpstack_32.c
index c90b53d2857e,e476eb774278..000000000000
--- a/arch/x86/kernel/dumpstack_32.c
+++ b/arch/x86/kernel/dumpstack_32.c
@@@ -83,7 -180,9 +82,13 @@@ void show_stack_log_lvl(struct task_str
  		touch_nmi_watchdog();
  	}
  	pr_cont("\n");
++<<<<<<< HEAD
 +	show_trace_log_lvl(task, regs, sp, bp, log_lvl);
++=======
+ 	show_trace_log_lvl(task, regs, sp, log_lvl);
+ 
+ 	put_task_stack(task);
++>>>>>>> e18bcccd1a4e (x86/dumpstack: Convert show_trace_log_lvl() to use the new unwinder)
  }
  
  
@@@ -105,7 -204,7 +110,11 @@@ void show_regs(struct pt_regs *regs
  		u8 *ip;
  
  		pr_emerg("Stack:\n");
++<<<<<<< HEAD
 +		show_stack_log_lvl(NULL, regs, &regs->sp, 0, KERN_EMERG);
++=======
+ 		show_stack_log_lvl(current, regs, NULL, KERN_EMERG);
++>>>>>>> e18bcccd1a4e (x86/dumpstack: Convert show_trace_log_lvl() to use the new unwinder)
  
  		pr_emerg("Code:");
  
diff --cc arch/x86/kernel/dumpstack_64.c
index 101e30243d5b,4e9f2cf64ac8..000000000000
--- a/arch/x86/kernel/dumpstack_64.c
+++ b/arch/x86/kernel/dumpstack_64.c
@@@ -285,15 -241,22 +284,21 @@@ void show_stack_log_lvl(struct task_str
  		if ((i % STACKSLOTS_PER_LINE) == 0) {
  			if (i != 0)
  				pr_cont("\n");
 -			printk("%s %016lx", log_lvl, word);
 +			printk("%s %016lx", log_lvl, *stack++);
  		} else
 -			pr_cont(" %016lx", word);
 -
 -		stack++;
 +			pr_cont(" %016lx", *stack++);
  		touch_nmi_watchdog();
  	}
 +	preempt_enable();
  
  	pr_cont("\n");
++<<<<<<< HEAD
 +	show_trace_log_lvl(task, regs, sp, bp, log_lvl);
++=======
+ 	show_trace_log_lvl(task, regs, sp, log_lvl);
+ 
+ 	put_task_stack(task);
++>>>>>>> e18bcccd1a4e (x86/dumpstack: Convert show_trace_log_lvl() to use the new unwinder)
  }
  
  void show_regs(struct pt_regs *regs)
@@@ -316,8 -277,7 +321,12 @@@
  		u8 *ip;
  
  		printk(KERN_DEFAULT "Stack:\n");
++<<<<<<< HEAD
 +		show_stack_log_lvl(NULL, regs, (unsigned long *)sp,
 +				   0, KERN_DEFAULT);
++=======
+ 		show_stack_log_lvl(current, regs, NULL, KERN_DEFAULT);
++>>>>>>> e18bcccd1a4e (x86/dumpstack: Convert show_trace_log_lvl() to use the new unwinder)
  
  		printk(KERN_DEFAULT "Code: ");
  
diff --git a/arch/x86/include/asm/stacktrace.h b/arch/x86/include/asm/stacktrace.h
index 7c247e7404be..874b3f9f8d3c 100644
--- a/arch/x86/include/asm/stacktrace.h
+++ b/arch/x86/include/asm/stacktrace.h
@@ -81,13 +81,11 @@ stack_frame(struct task_struct *task, struct pt_regs *regs)
 }
 #endif
 
-extern void
-show_trace_log_lvl(struct task_struct *task, struct pt_regs *regs,
-		   unsigned long *stack, unsigned long bp, char *log_lvl);
+void show_trace_log_lvl(struct task_struct *task, struct pt_regs *regs,
+			unsigned long *stack, char *log_lvl);
 
-extern void
-show_stack_log_lvl(struct task_struct *task, struct pt_regs *regs,
-		   unsigned long *sp, unsigned long bp, char *log_lvl);
+void show_stack_log_lvl(struct task_struct *task, struct pt_regs *regs,
+			unsigned long *sp, char *log_lvl);
 
 extern unsigned int code_bytes;
 
* Unmerged path arch/x86/kernel/dumpstack.c
* Unmerged path arch/x86/kernel/dumpstack_32.c
* Unmerged path arch/x86/kernel/dumpstack_64.c
