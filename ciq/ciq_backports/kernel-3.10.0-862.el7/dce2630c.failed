NFSv4: always set NFS_LOCK_LOST when a lock is lost.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [fs] nfsv4: always set NFS_LOCK_LOST when a lock is lost (Steve Dickson) [1540324]
Rebuild_FUZZ: 99.03%
commit-author NeilBrown <neilb@suse.com>
commit dce2630c7da73b0634686bca557cc8945cc450c8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/dce2630c.failed

There are 2 comments in the NFSv4 code which suggest that
SIGLOST should possibly be sent to a process.  In these
cases a lock has been lost.
The current practice is to set NFS_LOCK_LOST so that
read/write returns EIO when a lock is lost.
So change these comments to code when sets NFS_LOCK_LOST.

One case is when lock recovery after apparent server restart
fails with NFS4ERR_DENIED, NFS4ERR_RECLAIM_BAD, or
NFS4ERRO_RECLAIM_CONFLICT.  The other case is when a lock
attempt as part of lease recovery fails with NFS4ERR_DENIED.

In an ideal world, these should not happen.  However I have
a packet trace showing an NFSv4.1 session getting
NFS4ERR_BADSESSION after an extended network parition.  The
NFSv4.1 client treats this like server reboot until/unless
it get NFS4ERR_NO_GRACE, in which case it switches over to
"nograce" recovery mode.  In this network trace, the client
attempts to recover a lock and the server (incorrectly)
reports NFS4ERR_DENIED rather than NFS4ERR_NO_GRACE.  This
leads to the ineffective comment and the client then
continues to write using the OPEN stateid.

	Signed-off-by: NeilBrown <neilb@suse.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit dce2630c7da73b0634686bca557cc8945cc450c8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs4state.c
diff --cc fs/nfs/nfs4state.c
index e1c886af9fe2,91a4d4eeb235..000000000000
--- a/fs/nfs/nfs4state.c
+++ b/fs/nfs/nfs4state.c
@@@ -1425,50 -1482,59 +1425,79 @@@ static int nfs4_reclaim_locks(struct nf
  	struct inode *inode = state->inode;
  	struct nfs_inode *nfsi = NFS_I(inode);
  	struct file_lock *fl;
+ 	struct nfs4_lock_state *lsp;
  	int status = 0;
 -	struct file_lock_context *flctx = inode->i_flctx;
 -	struct list_head *list;
  
 -	if (flctx == NULL)
 +	if (inode->i_flock == NULL)
  		return 0;
  
 -	list = &flctx->flc_posix;
 -
  	/* Guard against delegation returns and new lock/unlock calls */
  	down_write(&nfsi->rwsem);
 -	spin_lock(&flctx->flc_lock);
 -restart:
 -	list_for_each_entry(fl, list, fl_list) {
 +	/* Protect inode->i_flock using the BKL */
 +	spin_lock(&inode->i_lock);
 +	for (fl = inode->i_flock; fl != NULL; fl = fl->fl_next) {
 +		if (!(fl->fl_flags & (FL_POSIX|FL_FLOCK)))
 +			continue;
  		if (nfs_file_open_context(fl->fl_file)->state != state)
  			continue;
 -		spin_unlock(&flctx->flc_lock);
 +		spin_unlock(&inode->i_lock);
  		status = ops->recover_lock(state, fl);
  		switch (status) {
++<<<<<<< HEAD
 +			case 0:
 +				break;
 +			case -ESTALE:
 +			case -NFS4ERR_ADMIN_REVOKED:
 +			case -NFS4ERR_STALE_STATEID:
 +			case -NFS4ERR_BAD_STATEID:
 +			case -NFS4ERR_EXPIRED:
 +			case -NFS4ERR_NO_GRACE:
 +			case -NFS4ERR_STALE_CLIENTID:
 +			case -NFS4ERR_BADSESSION:
 +			case -NFS4ERR_BADSLOT:
 +			case -NFS4ERR_BAD_HIGH_SLOT:
 +			case -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:
 +				goto out;
 +			default:
 +				printk(KERN_ERR "NFS: %s: unhandled error %d\n",
 +					 __func__, status);
 +			case -ENOMEM:
 +			case -NFS4ERR_DENIED:
 +			case -NFS4ERR_RECLAIM_BAD:
 +			case -NFS4ERR_RECLAIM_CONFLICT:
 +				/* kill_proc(fl->fl_pid, SIGLOST, 1); */
 +				status = 0;
++=======
+ 		case 0:
+ 			break;
+ 		case -ESTALE:
+ 		case -NFS4ERR_ADMIN_REVOKED:
+ 		case -NFS4ERR_STALE_STATEID:
+ 		case -NFS4ERR_BAD_STATEID:
+ 		case -NFS4ERR_EXPIRED:
+ 		case -NFS4ERR_NO_GRACE:
+ 		case -NFS4ERR_STALE_CLIENTID:
+ 		case -NFS4ERR_BADSESSION:
+ 		case -NFS4ERR_BADSLOT:
+ 		case -NFS4ERR_BAD_HIGH_SLOT:
+ 		case -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:
+ 			goto out;
+ 		default:
+ 			pr_err("NFS: %s: unhandled error %d\n",
+ 					__func__, status);
+ 		case -ENOMEM:
+ 		case -NFS4ERR_DENIED:
+ 		case -NFS4ERR_RECLAIM_BAD:
+ 		case -NFS4ERR_RECLAIM_CONFLICT:
+ 			lsp = fl->fl_u.nfs4_fl.owner;
+ 			if (lsp)
+ 				set_bit(NFS_LOCK_LOST, &lsp->ls_flags);
+ 			status = 0;
++>>>>>>> dce2630c7da7 (NFSv4: always set NFS_LOCK_LOST when a lock is lost.)
  		}
 -		spin_lock(&flctx->flc_lock);
 +		spin_lock(&inode->i_lock);
  	}
 -	if (list == &flctx->flc_posix) {
 -		list = &flctx->flc_flock;
 -		goto restart;
 -	}
 -	spin_unlock(&flctx->flc_lock);
 +	spin_unlock(&inode->i_lock);
  out:
  	up_write(&nfsi->rwsem);
  	return status;
diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index 7c82e8d4ff55..c49db14b2b8c 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -1953,7 +1953,7 @@ static int nfs4_open_reclaim(struct nfs4_state_owner *sp, struct nfs4_state *sta
 	return ret;
 }
 
-static int nfs4_handle_delegation_recall_error(struct nfs_server *server, struct nfs4_state *state, const nfs4_stateid *stateid, int err)
+static int nfs4_handle_delegation_recall_error(struct nfs_server *server, struct nfs4_state *state, const nfs4_stateid *stateid, struct file_lock *fl, int err)
 {
 	switch (err) {
 		default:
@@ -2000,7 +2000,11 @@ static int nfs4_handle_delegation_recall_error(struct nfs_server *server, struct
 			return -EAGAIN;
 		case -ENOMEM:
 		case -NFS4ERR_DENIED:
-			/* kill_proc(fl->fl_pid, SIGLOST, 1); */
+			if (fl) {
+				struct nfs4_lock_state *lsp = fl->fl_u.nfs4_fl.owner;
+				if (lsp)
+					set_bit(NFS_LOCK_LOST, &lsp->ls_flags);
+			}
 			return 0;
 	}
 	return err;
@@ -2036,7 +2040,7 @@ int nfs4_open_delegation_recall(struct nfs_open_context *ctx,
 		err = nfs4_open_recover_helper(opendata, FMODE_READ);
 	}
 	nfs4_opendata_put(opendata);
-	return nfs4_handle_delegation_recall_error(server, state, stateid, err);
+	return nfs4_handle_delegation_recall_error(server, state, stateid, NULL, err);
 }
 
 static void nfs4_open_confirm_prepare(struct rpc_task *task, void *calldata)
@@ -6573,7 +6577,7 @@ int nfs4_lock_delegation_recall(struct file_lock *fl, struct nfs4_state *state,
 	if (err != 0)
 		return err;
 	err = _nfs4_do_setlk(state, F_SETLK, fl, NFS_LOCK_NEW);
-	return nfs4_handle_delegation_recall_error(server, state, stateid, err);
+	return nfs4_handle_delegation_recall_error(server, state, stateid, fl, err);
 }
 
 struct nfs_release_lockowner_data {
* Unmerged path fs/nfs/nfs4state.c
