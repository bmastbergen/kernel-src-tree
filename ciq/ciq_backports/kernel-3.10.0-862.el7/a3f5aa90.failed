i40e: Enable VF to negotiate number of allocated queues

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Alan Brady <alan.brady@intel.com>
commit a3f5aa907340b5d7b54223ddbaa90410f168864d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a3f5aa90.failed

Currently the PF allocates a default number of queues for each VF and
cannot be changed.  This patch enables the VF to request a different
number of queues allocated to it.  This patch also adds a new virtchnl
op and capability flag to facilitate this negotiation.

After the PF receives a request message, it will set a requested number
of queues for that VF.  Then when the VF resets, its VSI will get a new
number of queues allocated to it.

This is a best effort request and since we only allocate a guaranteed
default number, if the VF tries to ask for more than the guaranteed
number, there may not be enough in HW to accommodate it unless other
queues for other VFs are freed. It should also be noted decreasing the
number queues allocated to a VF to below the default will NOT enable the
allocation of more than 32 VFs per PF and will not free queues guaranteed
to each VF by default.

	Signed-off-by: Alan Brady <alan.brady@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit a3f5aa907340b5d7b54223ddbaa90410f168864d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
#	include/linux/avf/virtchnl.h
diff --cc drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
index 0d4402b556cf,a75396c157d9..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
@@@ -1467,15 -1593,18 +1490,18 @@@ static int i40e_vc_get_vf_resources_msg
  			aq_ret = I40E_ERR_PARAM;
  			goto err;
  		}
 -		vfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_RX_POLLING;
 +		vfres->vf_offload_flags |= I40E_VIRTCHNL_VF_OFFLOAD_RX_POLLING;
  	}
  
 -	if (pf->hw_features & I40E_HW_WB_ON_ITR_CAPABLE) {
 -		if (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_WB_ON_ITR)
 -			vfres->vf_cap_flags |=
 -					VIRTCHNL_VF_OFFLOAD_WB_ON_ITR;
 +	if (pf->flags & I40E_FLAG_WB_ON_ITR_CAPABLE) {
 +		if (vf->driver_caps & I40E_VIRTCHNL_VF_OFFLOAD_WB_ON_ITR)
 +			vfres->vf_offload_flags |=
 +					I40E_VIRTCHNL_VF_OFFLOAD_WB_ON_ITR;
  	}
  
+ 	if (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_REQ_QUEUES)
+ 		vfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_REQ_QUEUES;
+ 
  	vfres->num_vsis = num_vsis;
  	vfres->num_queue_pairs = vf->num_queue_pairs;
  	vfres->max_vectors = pf->hw.func_caps.num_msix_vectors_vf;
@@@ -2645,47 -2735,56 +2717,59 @@@ int i40e_vc_process_vf_msg(struct i40e_
  		ret = i40e_vc_enable_queues_msg(vf, msg, msglen);
  		i40e_vc_notify_vf_link_state(vf);
  		break;
 -	case VIRTCHNL_OP_DISABLE_QUEUES:
 +	case I40E_VIRTCHNL_OP_DISABLE_QUEUES:
  		ret = i40e_vc_disable_queues_msg(vf, msg, msglen);
  		break;
 -	case VIRTCHNL_OP_ADD_ETH_ADDR:
 +	case I40E_VIRTCHNL_OP_ADD_ETHER_ADDRESS:
  		ret = i40e_vc_add_mac_addr_msg(vf, msg, msglen);
  		break;
 -	case VIRTCHNL_OP_DEL_ETH_ADDR:
 +	case I40E_VIRTCHNL_OP_DEL_ETHER_ADDRESS:
  		ret = i40e_vc_del_mac_addr_msg(vf, msg, msglen);
  		break;
 -	case VIRTCHNL_OP_ADD_VLAN:
 +	case I40E_VIRTCHNL_OP_ADD_VLAN:
  		ret = i40e_vc_add_vlan_msg(vf, msg, msglen);
  		break;
 -	case VIRTCHNL_OP_DEL_VLAN:
 +	case I40E_VIRTCHNL_OP_DEL_VLAN:
  		ret = i40e_vc_remove_vlan_msg(vf, msg, msglen);
  		break;
 -	case VIRTCHNL_OP_GET_STATS:
 +	case I40E_VIRTCHNL_OP_GET_STATS:
  		ret = i40e_vc_get_stats_msg(vf, msg, msglen);
  		break;
 -	case VIRTCHNL_OP_IWARP:
 +	case I40E_VIRTCHNL_OP_IWARP:
  		ret = i40e_vc_iwarp_msg(vf, msg, msglen);
  		break;
 -	case VIRTCHNL_OP_CONFIG_IWARP_IRQ_MAP:
 +	case I40E_VIRTCHNL_OP_CONFIG_IWARP_IRQ_MAP:
  		ret = i40e_vc_iwarp_qvmap_msg(vf, msg, msglen, true);
  		break;
 -	case VIRTCHNL_OP_RELEASE_IWARP_IRQ_MAP:
 +	case I40E_VIRTCHNL_OP_RELEASE_IWARP_IRQ_MAP:
  		ret = i40e_vc_iwarp_qvmap_msg(vf, msg, msglen, false);
  		break;
 -	case VIRTCHNL_OP_CONFIG_RSS_KEY:
 +	case I40E_VIRTCHNL_OP_CONFIG_RSS_KEY:
  		ret = i40e_vc_config_rss_key(vf, msg, msglen);
  		break;
 -	case VIRTCHNL_OP_CONFIG_RSS_LUT:
 +	case I40E_VIRTCHNL_OP_CONFIG_RSS_LUT:
  		ret = i40e_vc_config_rss_lut(vf, msg, msglen);
  		break;
 -	case VIRTCHNL_OP_GET_RSS_HENA_CAPS:
 +	case I40E_VIRTCHNL_OP_GET_RSS_HENA_CAPS:
  		ret = i40e_vc_get_rss_hena(vf, msg, msglen);
  		break;
 -	case VIRTCHNL_OP_SET_RSS_HENA:
 +	case I40E_VIRTCHNL_OP_SET_RSS_HENA:
  		ret = i40e_vc_set_rss_hena(vf, msg, msglen);
  		break;
++<<<<<<< HEAD
++=======
+ 	case VIRTCHNL_OP_ENABLE_VLAN_STRIPPING:
+ 		ret = i40e_vc_enable_vlan_stripping(vf, msg, msglen);
+ 		break;
+ 	case VIRTCHNL_OP_DISABLE_VLAN_STRIPPING:
+ 		ret = i40e_vc_disable_vlan_stripping(vf, msg, msglen);
+ 		break;
+ 	case VIRTCHNL_OP_REQUEST_QUEUES:
+ 		ret = i40e_vc_request_queues_msg(vf, msg, msglen);
+ 		break;
++>>>>>>> a3f5aa907340 (i40e: Enable VF to negotiate number of allocated queues)
  
 -	case VIRTCHNL_OP_UNKNOWN:
 +	case I40E_VIRTCHNL_OP_UNKNOWN:
  	default:
  		dev_err(&pf->pdev->dev, "Unsupported opcode %d from VF %d\n",
  			v_opcode, local_vf_id);
* Unmerged path include/linux/avf/virtchnl.h
diff --git a/drivers/net/ethernet/intel/i40e/i40e.h b/drivers/net/ethernet/intel/i40e/i40e.h
index 4852c04654f3..b4690c406cee 100644
--- a/drivers/net/ethernet/intel/i40e/i40e.h
+++ b/drivers/net/ethernet/intel/i40e/i40e.h
@@ -80,6 +80,7 @@
 #define i40e_default_queues_per_vmdq(pf) \
 		(((pf)->flags & I40E_FLAG_RSS_AQ_CAPABLE) ? 4 : 1)
 #define I40E_DEFAULT_QUEUES_PER_VF	4
+#define I40E_MAX_VF_QUEUES		16
 #define I40E_DEFAULT_QUEUES_PER_TC	1 /* should be a power of 2 */
 #define i40e_pf_get_max_q_per_tc(pf) \
 		(((pf)->flags & I40E_FLAG_128_QP_RSS_CAPABLE) ? 128 : 64)
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
diff --git a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h
index 8227923dbc7f..e54fa7bb657a 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h
+++ b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h
@@ -101,6 +101,7 @@ struct i40e_vf {
 	u16 lan_vsi_id;		/* ID as used by firmware */
 
 	u8 num_queue_pairs;	/* num of qps assigned to VF vsis */
+	u8 num_req_queues;	/* num of requested qps */
 	u64 num_mdd_events;	/* num of mdd events detected */
 	/* num of continuous malformed or invalid msgs detected */
 	u64 num_invalid_msgs;
* Unmerged path include/linux/avf/virtchnl.h
