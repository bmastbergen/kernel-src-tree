net: sched: avoid duplicates in qdisc dump

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] sched: avoid duplicates in qdisc dump (Ivan Vecera) [1445420]
Rebuild_FUZZ: 93.67%
commit-author Jiri Kosina <jkosina@suse.cz>
commit ea3274695353127d12155d45be1f2d62ab19c897
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ea327469.failed

tc_dump_qdisc() performs dumping of the per-device qdiscs in two phases;
first, the "standard" dev->qdisc is being dumped. Second, if there is/are
ingress queue(s), they are being dumped as well.

After conversion of netdevice's qdisc linked-list into hashtable, these
two sets are not in two disjunctive sets/lists any more, but are both
"reachable" directly from netdevice's hashtable. As a consequence, the
"full-depth" dump of the ingress qdiscs results in immediately hitting the
netdevice hashtable again, and duplicating the dump that has already been
performed for dev->qdisc.
What in fact needs to be dumped in case of ingress queue is "just" the
top-level ingress qdisc, as everything else has been dumped already.

Fix this by extending tc_dump_qdisc_root() in a way that it can be instructed
whether it should (while performing the "full" per-netdev qdisc dump) perform
the whole recursion, or just dump "additional" top-level (ingress) qdiscs
without performing any kind of recursion.

This fixes duplicate dumps such as

	qdisc mq 0: root
	qdisc pfifo_fast 0: parent :4 bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1
	qdisc pfifo_fast 0: parent :3 bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1
	qdisc pfifo_fast 0: parent :2 bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1
	qdisc pfifo_fast 0: parent :1 bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1
	qdisc clsact ffff: parent ffff:fff1
	qdisc pfifo_fast 0: parent :4 bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1
	qdisc pfifo_fast 0: parent :3 bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1
	qdisc pfifo_fast 0: parent :2 bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1
	qdisc pfifo_fast 0: parent :1 bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1

Fixes: 59cc1f61f ("net: sched: convert qdisc linked list to hashtable")
	Reported-by: Daniel Borkmann <daniel@iogearbox.net>
	Tested-by: Daniel Borkmann <daniel@iogearbox.net>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ea3274695353127d12155d45be1f2d62ab19c897)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/sch_api.c
diff --cc net/sched/sch_api.c
index ccf895cad848,d677b3484d81..000000000000
--- a/net/sched/sch_api.c
+++ b/net/sched/sch_api.c
@@@ -1454,7 -1454,17 +1454,21 @@@ static int tc_dump_qdisc_root(struct Qd
  			goto done;
  		q_idx++;
  	}
++<<<<<<< HEAD
 +	list_for_each_entry(q, &root->list, list) {
++=======
+ 
+ 	/* If dumping singletons, there is no qdisc_dev(root) and the singleton
+ 	 * itself has already been dumped.
+ 	 *
+ 	 * If we've already dumped the top-level (ingress) qdisc above and the global
+ 	 * qdisc hashtable, we don't want to hit it again
+ 	 */
+ 	if (!qdisc_dev(root) || !recur)
+ 		goto out;
+ 
+ 	hash_for_each(qdisc_dev(root)->qdisc_hash, b, q, hash) {
++>>>>>>> ea3274695353 (net: sched: avoid duplicates in qdisc dump)
  		if (q_idx < s_q_idx) {
  			q_idx++;
  			continue;
* Unmerged path net/sched/sch_api.c
