x86/platform/UV: Fix GAM MMR references in the UV x2apic code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] platform/uv: Fix GAM MMR references in the UV x2apic code (Frank Ramsay) [1535031]
Rebuild_FUZZ: 96.61%
commit-author Mike Travis <mike.travis@hpe.com>
commit 09c3ae12b2bf6dc2837d89c1017bf151af610a1f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/09c3ae12.failed

Along with the fixes in UV4A (rev2) MMRs, the code to access those
MMRs also was modified by the fixes.  UV3, UV4, and UV4A no longer
have compatible setups for Global Address Memory (GAM).

Correct the new mistakes.

	Signed-off-by: Mike Travis <mike.travis@hpe.com>
	Acked-by: Andrew Banman <abanman@hpe.com>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Dimitri Sivanich <sivanich@hpe.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Russ Anderson <rja@hpe.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/1515440405-20880-6-git-send-email-mike.travis@hpe.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 09c3ae12b2bf6dc2837d89c1017bf151af610a1f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/apic/x2apic_uv_x.c
diff --cc arch/x86/kernel/apic/x2apic_uv_x.c
index dd27b8dad976,46b675aaf20b..000000000000
--- a/arch/x86/kernel/apic/x2apic_uv_x.c
+++ b/arch/x86/kernel/apic/x2apic_uv_x.c
@@@ -769,64 -794,64 +769,94 @@@ static __init void map_mmr_high(int max
  		pr_info("UV: MMR disabled\n");
  }
  
- /*
-  * This commonality works because both 0 & 1 versions of the MMIOH OVERLAY
-  * and REDIRECT MMR regs are exactly the same on UV3.
-  */
- struct mmioh_config {
- 	unsigned long overlay;
- 	unsigned long redirect;
- 	char *id;
- };
- 
- static __initdata struct mmioh_config mmiohs[] = {
- 	{
- 		UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR,
- 		UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR,
- 		"MMIOH0"
- 	},
- 	{
- 		UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR,
- 		UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR,
- 		"MMIOH1"
- 	},
- };
- 
- /* UV3 & UV4 have identical MMIOH overlay configs */
- static __init void map_mmioh_high_uv3(int index, int min_pnode, int max_pnode)
+ /* UV3/4 have identical MMIOH overlay configs, UV4A is slightly different */
+ static __init void map_mmioh_high_uv34(int index, int min_pnode, int max_pnode)
  {
++<<<<<<< HEAD
 +	union uv3h_rh_gam_mmioh_overlay_config0_mmr_u overlay;
 +	unsigned long mmr;
 +	unsigned long base;
++=======
+ 	unsigned long overlay;
+ 	unsigned long mmr;
+ 	unsigned long base;
+ 	unsigned long nasid_mask;
+ 	unsigned long m_overlay;
++>>>>>>> 09c3ae12b2bf (x86/platform/UV: Fix GAM MMR references in the UV x2apic code)
  	int i, n, shift, m_io, max_io;
  	int nasid, lnasid, fi, li;
  	char *id;
  
++<<<<<<< HEAD
 +	id = mmiohs[index].id;
 +	overlay.v = uv_read_local_mmr(mmiohs[index].overlay);
 +	pr_info("UV: %s overlay 0x%lx base:0x%x m_io:%d\n",
 +		id, overlay.v, overlay.s3.base, overlay.s3.m_io);
 +	if (!overlay.s3.enable) {
++=======
+ 	if (index == 0) {
+ 		id = "MMIOH0";
+ 		m_overlay = UVH_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR;
+ 		overlay = uv_read_local_mmr(m_overlay);
+ 		base = overlay & UVH_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_BASE_MASK;
+ 		mmr = UVH_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR;
+ 		m_io = (overlay & UVH_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_M_IO_MASK)
+ 			>> UVH_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_M_IO_SHFT;
+ 		shift = UVH_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_M_IO_SHFT;
+ 		n = UVH_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_DEPTH;
+ 		nasid_mask = UVH_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_NASID_MASK;
+ 	} else {
+ 		id = "MMIOH1";
+ 		m_overlay = UVH_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR;
+ 		overlay = uv_read_local_mmr(m_overlay);
+ 		base = overlay & UVH_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_BASE_MASK;
+ 		mmr = UVH_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR;
+ 		m_io = (overlay & UVH_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_M_IO_MASK)
+ 			>> UVH_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_M_IO_SHFT;
+ 		shift = UVH_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_M_IO_SHFT;
+ 		n = UVH_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR_DEPTH;
+ 		nasid_mask = UVH_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR_NASID_MASK;
+ 	}
+ 	pr_info("UV: %s overlay 0x%lx base:0x%lx m_io:%d\n", id, overlay, base, m_io);
+ 	if (!(overlay & UVH_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_ENABLE_MASK)) {
++>>>>>>> 09c3ae12b2bf (x86/platform/UV: Fix GAM MMR references in the UV x2apic code)
  		pr_info("UV: %s disabled\n", id);
  		return;
  	}
  
++<<<<<<< HEAD
 +	shift = UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_BASE_SHFT;
 +	base = (unsigned long)overlay.s3.base;
 +	m_io = overlay.s3.m_io;
 +	mmr = mmiohs[index].redirect;
 +	n = UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_DEPTH;
 +	min_pnode *= 2;				/* convert to NASID */
++=======
+ 	/* Convert to NASID: */
+ 	min_pnode *= 2;
++>>>>>>> 09c3ae12b2bf (x86/platform/UV: Fix GAM MMR references in the UV x2apic code)
  	max_pnode *= 2;
  	max_io = lnasid = fi = li = -1;
  
  	for (i = 0; i < n; i++) {
++<<<<<<< HEAD
 +		union uv3h_rh_gam_mmioh_redirect_config0_mmr_u redirect;
 +
 +		redirect.v = uv_read_local_mmr(mmr + i * 8);
 +		nasid = redirect.s3.nasid;
++=======
+ 		unsigned long m_redirect = mmr + i * 8;
+ 		unsigned long redirect = uv_read_local_mmr(m_redirect);
+ 
+ 		nasid = redirect & nasid_mask;
+ 		if (i == 0)
+ 			pr_info("UV: %s redirect base 0x%lx(@0x%lx) 0x%04x\n",
+ 				id, redirect, m_redirect, nasid);
+ 
+ 		/* Invalid NASID: */
++>>>>>>> 09c3ae12b2bf (x86/platform/UV: Fix GAM MMR references in the UV x2apic code)
  		if (nasid < min_pnode || max_pnode < nasid)
 -			nasid = -1;
 +			nasid = -1;		/* invalid NASID */
  
  		if (nasid == lnasid) {
  			li = i;
@@@ -873,9 -895,9 +903,15 @@@ static __init void map_mmioh_high(int m
  	int shift, enable, m_io, n_io;
  
  	if (is_uv3_hub() || is_uv4_hub()) {
++<<<<<<< HEAD
 +		/* Map both MMIOH Regions */
 +		map_mmioh_high_uv3(0, min_pnode, max_pnode);
 +		map_mmioh_high_uv3(1, min_pnode, max_pnode);
++=======
+ 		/* Map both MMIOH regions: */
+ 		map_mmioh_high_uv34(0, min_pnode, max_pnode);
+ 		map_mmioh_high_uv34(1, min_pnode, max_pnode);
++>>>>>>> 09c3ae12b2bf (x86/platform/UV: Fix GAM MMR references in the UV x2apic code)
  		return;
  	}
  
* Unmerged path arch/x86/kernel/apic/x2apic_uv_x.c
