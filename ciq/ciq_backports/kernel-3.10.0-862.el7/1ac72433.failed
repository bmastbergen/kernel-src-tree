qed: Remove assumption on SB order in IGU

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Mintz, Yuval <Yuval.Mintz@cavium.com>
commit 1ac72433c565c8db38fd1f9db80a73193369e5fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1ac72433.failed

Current code assumes there's a known layout for SBs in the IGU,
where all the SBs of a single entity would be laid in consecutive
order of vectors.

While the assumption is still kept by management firmware, we already
have the necessary information to eliminate it, so no reason to keep
it in code.

	Signed-off-by: Yuval Mintz <Yuval.Mintz@cavium.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1ac72433c565c8db38fd1f9db80a73193369e5fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qed/qed_int.c
#	drivers/net/ethernet/qlogic/qed/qed_int.h
diff --cc drivers/net/ethernet/qlogic/qed/qed_int.c
index 37b56d7fa1f8,a49484a8726c..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_int.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_int.c
@@@ -2991,16 -1730,24 +2991,24 @@@ static void qed_int_igu_cleanup_sb(stru
  
  void qed_int_igu_init_pure_rt_single(struct qed_hwfn *p_hwfn,
  				     struct qed_ptt *p_ptt,
 -				     u16 igu_sb_id, u16 opaque, bool b_set)
 +				     u32 sb_id, u16 opaque, bool b_set)
  {
+ 	struct qed_igu_block *p_block;
  	int pi, i;
  
+ 	p_block = &p_hwfn->hw_info.p_igu_info->entry[igu_sb_id];
+ 	DP_VERBOSE(p_hwfn, NETIF_MSG_INTR,
+ 		   "Cleaning SB [%04x]: func_id= %d is_pf = %d vector_num = 0x%0x\n",
+ 		   igu_sb_id,
+ 		   p_block->function_id,
+ 		   p_block->is_pf, p_block->vector_number);
+ 
  	/* Set */
  	if (b_set)
 -		qed_int_igu_cleanup_sb(p_hwfn, p_ptt, igu_sb_id, 1, opaque);
 +		qed_int_igu_cleanup_sb(p_hwfn, p_ptt, sb_id, 1, opaque);
  
  	/* Clear */
 -	qed_int_igu_cleanup_sb(p_hwfn, p_ptt, igu_sb_id, 0, opaque);
 +	qed_int_igu_cleanup_sb(p_hwfn, p_ptt, sb_id, 0, opaque);
  
  	/* Wait for the IGU SB to cleanup */
  	for (i = 0; i < IGU_CLEANUP_SLEEP_LENGTH; i++) {
@@@ -3028,63 -1776,51 +3036,95 @@@ void qed_int_igu_init_pure_rt(struct qe
  			      struct qed_ptt *p_ptt,
  			      bool b_set, bool b_slowpath)
  {
++<<<<<<< HEAD
 +	u32 igu_base_sb = p_hwfn->hw_info.p_igu_info->igu_base_sb;
 +	u32 igu_sb_cnt = p_hwfn->hw_info.p_igu_info->igu_sb_cnt;
 +	u32 sb_id = 0, val = 0;
++=======
+ 	struct qed_igu_info *p_info = p_hwfn->hw_info.p_igu_info;
+ 	struct qed_igu_block *p_block;
+ 	u16 igu_sb_id = 0;
+ 	u32 val = 0;
++>>>>>>> 1ac72433c565 (qed: Remove assumption on SB order in IGU)
  
  	val = qed_rd(p_hwfn, p_ptt, IGU_REG_BLOCK_CONFIGURATION);
  	val |= IGU_REG_BLOCK_CONFIGURATION_VF_CLEANUP_EN;
  	val &= ~IGU_REG_BLOCK_CONFIGURATION_PXP_TPH_INTERFACE_EN;
  	qed_wr(p_hwfn, p_ptt, IGU_REG_BLOCK_CONFIGURATION, val);
  
- 	DP_VERBOSE(p_hwfn, NETIF_MSG_INTR,
- 		   "IGU cleaning SBs [%d,...,%d]\n",
- 		   igu_base_sb, igu_base_sb + igu_sb_cnt - 1);
+ 	for (igu_sb_id = 0;
+ 	     igu_sb_id < QED_MAPPING_MEMORY_SIZE(p_hwfn->cdev); igu_sb_id++) {
+ 		p_block = &p_info->entry[igu_sb_id];
+ 
+ 		if (!(p_block->status & QED_IGU_STATUS_VALID) ||
+ 		    !p_block->is_pf ||
+ 		    (p_block->status & QED_IGU_STATUS_DSB))
+ 			continue;
  
++<<<<<<< HEAD
 +	for (sb_id = igu_base_sb; sb_id < igu_base_sb + igu_sb_cnt; sb_id++)
 +		qed_int_igu_init_pure_rt_single(p_hwfn, p_ptt, sb_id,
++=======
+ 		qed_int_igu_init_pure_rt_single(p_hwfn, p_ptt, igu_sb_id,
++>>>>>>> 1ac72433c565 (qed: Remove assumption on SB order in IGU)
  						p_hwfn->hw_info.opaque_fid,
  						b_set);
+ 	}
  
++<<<<<<< HEAD
 +	if (!b_slowpath)
 +		return;
 +
 +	sb_id = p_hwfn->hw_info.p_igu_info->igu_dsb_id;
 +	DP_VERBOSE(p_hwfn, NETIF_MSG_INTR,
 +		   "IGU cleaning slowpath SB [%d]\n", sb_id);
 +	qed_int_igu_init_pure_rt_single(p_hwfn, p_ptt, sb_id,
 +					p_hwfn->hw_info.opaque_fid, b_set);
++=======
+ 	if (b_slowpath)
+ 		qed_int_igu_init_pure_rt_single(p_hwfn, p_ptt,
+ 						p_info->igu_dsb_id,
+ 						p_hwfn->hw_info.opaque_fid,
+ 						b_set);
++>>>>>>> 1ac72433c565 (qed: Remove assumption on SB order in IGU)
  }
  
 -static void qed_int_igu_read_cam_block(struct qed_hwfn *p_hwfn,
 -				       struct qed_ptt *p_ptt, u16 igu_sb_id)
 +static u32 qed_int_igu_read_cam_block(struct qed_hwfn *p_hwfn,
 +				      struct qed_ptt *p_ptt, u16 sb_id)
  {
  	u32 val = qed_rd(p_hwfn, p_ptt,
 -			 IGU_REG_MAPPING_MEMORY + sizeof(u32) * igu_sb_id);
 +			 IGU_REG_MAPPING_MEMORY + sizeof(u32) * sb_id);
  	struct qed_igu_block *p_block;
  
 -	p_block = &p_hwfn->hw_info.p_igu_info->entry[igu_sb_id];
 +	p_block = &p_hwfn->hw_info.p_igu_info->igu_map.igu_blocks[sb_id];
 +
 +	/* stop scanning when hit first invalid PF entry */
 +	if (!GET_FIELD(val, IGU_MAPPING_LINE_VALID) &&
 +	    GET_FIELD(val, IGU_MAPPING_LINE_PF_VALID))
 +		goto out;
  
  	/* Fill the block information */
++<<<<<<< HEAD
 +	p_block->status		= QED_IGU_STATUS_VALID;
 +	p_block->function_id	= GET_FIELD(val,
 +					    IGU_MAPPING_LINE_FUNCTION_NUMBER);
 +	p_block->is_pf		= GET_FIELD(val, IGU_MAPPING_LINE_PF_VALID);
 +	p_block->vector_number	= GET_FIELD(val,
 +					    IGU_MAPPING_LINE_VECTOR_NUMBER);
 +
 +	DP_VERBOSE(p_hwfn, NETIF_MSG_INTR,
 +		   "IGU_BLOCK: [SB 0x%04x, Value in CAM 0x%08x] func_id = %d is_pf = %d vector_num = 0x%x\n",
 +		   sb_id, val, p_block->function_id,
 +		   p_block->is_pf, p_block->vector_number);
 +
 +out:
 +	return val;
++=======
+ 	p_block->function_id = GET_FIELD(val, IGU_MAPPING_LINE_FUNCTION_NUMBER);
+ 	p_block->is_pf = GET_FIELD(val, IGU_MAPPING_LINE_PF_VALID);
+ 	p_block->vector_number = GET_FIELD(val, IGU_MAPPING_LINE_VECTOR_NUMBER);
+ 	p_block->igu_sb_id = igu_sb_id;
++>>>>>>> 1ac72433c565 (qed: Remove assumption on SB order in IGU)
  }
  
  int qed_int_igu_read_cam(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)
@@@ -3101,12 -1836,10 +3141,19 @@@
  
  	p_igu_info = p_hwfn->hw_info.p_igu_info;
  
++<<<<<<< HEAD
 +	/* Initialize base sb / sb cnt for PFs and VFs */
 +	p_igu_info->igu_base_sb		= 0xffff;
 +	p_igu_info->igu_sb_cnt		= 0;
 +	p_igu_info->igu_dsb_id		= 0xffff;
 +	p_igu_info->igu_base_sb_iov	= 0xffff;
 +
++=======
+ 	/* Distinguish between existent and non-existent default SB */
+ 	p_igu_info->igu_dsb_id = QED_SB_INVALID_IDX;
+ 
+ 	/* Find the range of VF ids whose SB belong to this PF */
++>>>>>>> 1ac72433c565 (qed: Remove assumption on SB order in IGU)
  	if (p_hwfn->cdev->p_iov_info) {
  		struct qed_hw_sriov_info *p_iov = p_hwfn->cdev->p_iov_info;
  
@@@ -3114,63 -1847,50 +3161,98 @@@
  		max_vf	= p_iov->first_vf_in_pf + p_iov->total_vfs;
  	}
  
 -	for (igu_sb_id = 0;
 -	     igu_sb_id < QED_MAPPING_MEMORY_SIZE(p_hwfn->cdev); igu_sb_id++) {
 -		/* Read current entry; Notice it might not belong to this PF */
 -		qed_int_igu_read_cam_block(p_hwfn, p_ptt, igu_sb_id);
 -		p_block = &p_igu_info->entry[igu_sb_id];
 -
 -		if ((p_block->is_pf) &&
 -		    (p_block->function_id == p_hwfn->rel_pf_id)) {
 -			p_block->status = QED_IGU_STATUS_PF |
 -					  QED_IGU_STATUS_VALID |
 -					  QED_IGU_STATUS_FREE;
 +	for (sb_id = 0; sb_id < QED_MAPPING_MEMORY_SIZE(p_hwfn->cdev);
 +	     sb_id++) {
 +		blk = &p_igu_info->igu_map.igu_blocks[sb_id];
 +
 +		val	= qed_int_igu_read_cam_block(p_hwfn, p_ptt, sb_id);
  
++<<<<<<< HEAD
 +		/* stop scanning when hit first invalid PF entry */
 +		if (!GET_FIELD(val, IGU_MAPPING_LINE_VALID) &&
 +		    GET_FIELD(val, IGU_MAPPING_LINE_PF_VALID))
 +			break;
 +
 +		if (blk->is_pf) {
 +			if (blk->function_id == p_hwfn->rel_pf_id) {
 +				blk->status |= QED_IGU_STATUS_PF;
 +
 +				if (blk->vector_number == 0) {
 +					if (p_igu_info->igu_dsb_id == 0xffff)
 +						p_igu_info->igu_dsb_id = sb_id;
 +				} else {
 +					if (p_igu_info->igu_base_sb ==
 +					    0xffff) {
 +						p_igu_info->igu_base_sb = sb_id;
 +					} else if (prev_sb_id != sb_id - 1) {
 +						DP_NOTICE(p_hwfn->cdev,
 +							  "consecutive igu vectors for HWFN %x broken",
 +							  p_hwfn->rel_pf_id);
 +						break;
 +					}
 +					prev_sb_id = sb_id;
 +					/* we don't count the default */
 +					(p_igu_info->igu_sb_cnt)++;
 +				}
 +			}
 +		} else {
 +			if ((blk->function_id >= min_vf) &&
 +			    (blk->function_id < max_vf)) {
 +				/* Available for VFs of this PF */
 +				if (p_igu_info->igu_base_sb_iov == 0xffff) {
 +					p_igu_info->igu_base_sb_iov = sb_id;
 +				} else if (last_iov_sb_id != sb_id - 1) {
 +					if (!val) {
 +						DP_VERBOSE(p_hwfn->cdev,
 +							   NETIF_MSG_INTR,
 +							   "First uninitialized IGU CAM entry at index 0x%04x\n",
 +							   sb_id);
 +					} else {
 +						DP_NOTICE(p_hwfn->cdev,
 +							  "Consecutive igu vectors for HWFN %x vfs is broken [jumps from %04x to %04x]\n",
 +							  p_hwfn->rel_pf_id,
 +							  last_iov_sb_id,
 +							  sb_id); }
 +					break;
 +				}
 +				blk->status |= QED_IGU_STATUS_FREE;
 +				p_hwfn->hw_info.p_igu_info->free_blks++;
 +				last_iov_sb_id = sb_id;
 +			}
++=======
+ 			if (p_igu_info->igu_dsb_id != QED_SB_INVALID_IDX)
+ 				p_igu_info->usage.cnt++;
+ 		} else if (!(p_block->is_pf) &&
+ 			   (p_block->function_id >= min_vf) &&
+ 			   (p_block->function_id < max_vf)) {
+ 			/* Available for VFs of this PF */
+ 			p_block->status = QED_IGU_STATUS_VALID |
+ 					  QED_IGU_STATUS_FREE;
+ 
+ 			if (p_igu_info->igu_dsb_id != QED_SB_INVALID_IDX)
+ 				p_igu_info->usage.iov_cnt++;
+ 		}
+ 
+ 		/* Mark the First entry belonging to the PF or its VFs
+ 		 * as the default SB.
+ 		 */
+ 		if ((p_block->status & QED_IGU_STATUS_VALID) &&
+ 		    (p_igu_info->igu_dsb_id == QED_SB_INVALID_IDX)) {
+ 			p_igu_info->igu_dsb_id = igu_sb_id;
+ 			p_block->status |= QED_IGU_STATUS_DSB;
+ 		}
+ 
+ 		/* limit number of prints by having each PF print only its
+ 		 * entries with the exception of PF0 which would print
+ 		 * everything.
+ 		 */
+ 		if ((p_block->status & QED_IGU_STATUS_VALID) ||
+ 		    (p_hwfn->abs_pf_id == 0)) {
+ 			DP_VERBOSE(p_hwfn, NETIF_MSG_INTR,
+ 				   "IGU_BLOCK: [SB 0x%04x] func_id = %d is_pf = %d vector_num = 0x%x\n",
+ 				   igu_sb_id, p_block->function_id,
+ 				   p_block->is_pf, p_block->vector_number);
++>>>>>>> 1ac72433c565 (qed: Remove assumption on SB order in IGU)
  		}
  	}
  
@@@ -3317,33 -2006,9 +3399,36 @@@ void qed_int_get_num_sbs(struct qed_hwf
  	if (!info || !p_sb_cnt_info)
  		return;
  
 -	memcpy(p_sb_cnt_info, &info->usage, sizeof(*p_sb_cnt_info));
 +	p_sb_cnt_info->sb_cnt		= info->igu_sb_cnt;
 +	p_sb_cnt_info->sb_iov_cnt	= info->igu_sb_cnt_iov;
 +	p_sb_cnt_info->sb_free_blk	= info->free_blks;
 +}
 +
++<<<<<<< HEAD
 +u16 qed_int_queue_id_from_sb_id(struct qed_hwfn *p_hwfn, u16 sb_id)
 +{
 +	struct qed_igu_info *p_info = p_hwfn->hw_info.p_igu_info;
 +
 +	/* Determine origin of SB id */
 +	if ((sb_id >= p_info->igu_base_sb) &&
 +	    (sb_id < p_info->igu_base_sb + p_info->igu_sb_cnt)) {
 +		return sb_id - p_info->igu_base_sb;
 +	} else if ((sb_id >= p_info->igu_base_sb_iov) &&
 +		   (sb_id < p_info->igu_base_sb_iov + p_info->igu_sb_cnt_iov)) {
 +		/* We want the first VF queue to be adjacent to the
 +		 * last PF queue. Since L2 queues can be partial to
 +		 * SBs, we'll use the feature instead.
 +		 */
 +		return sb_id - p_info->igu_base_sb_iov +
 +		       FEAT_NUM(p_hwfn, QED_PF_L2_QUE);
 +	} else {
 +		DP_NOTICE(p_hwfn, "SB %d not in range for function\n", sb_id);
 +		return 0;
 +	}
  }
  
++=======
++>>>>>>> 1ac72433c565 (qed: Remove assumption on SB order in IGU)
  void qed_int_disable_post_isr_release(struct qed_dev *cdev)
  {
  	int i;
diff --cc drivers/net/ethernet/qlogic/qed/qed_int.h
index a8e48e14efef,b55334ff76a2..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_int.h
+++ b/drivers/net/ethernet/qlogic/qed/qed_int.h
@@@ -208,20 -211,17 +208,31 @@@ struct qed_igu_block 
  	u8	vector_number;
  	u8	function_id;
  	u8	is_pf;
+ 
+ 	/* Index inside IGU [meant for back reference] */
+ 	u16	igu_sb_id;
  };
  
 +struct qed_igu_map {
 +	struct qed_igu_block igu_blocks[MAX_TOT_SB_PER_PATH];
 +};
 +
  struct qed_igu_info {
++<<<<<<< HEAD
 +	struct qed_igu_map	igu_map;
 +	u16			igu_dsb_id;
 +	u16			igu_base_sb;
 +	u16			igu_base_sb_iov;
 +	u16			igu_sb_cnt;
 +	u16			igu_sb_cnt_iov;
 +	u16			free_blks;
++=======
+ 	struct qed_igu_block entry[MAX_TOT_SB_PER_PATH];
+ 	u16 igu_dsb_id;
+ 
+ 	struct qed_sb_cnt_info usage;
+ 
++>>>>>>> 1ac72433c565 (qed: Remove assumption on SB order in IGU)
  };
  
  /* TODO Names of function may change... */
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_int.c
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_int.h
