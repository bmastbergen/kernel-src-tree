net/mlx4_en: Do not allocate redundant TX queues when TC is disabled

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx4_en: Do not allocate redundant TX queues when TC is disabled (Don Dutile) [1499363 1456692]
Rebuild_FUZZ: 96.97%
commit-author Inbar Karmy <inbark@mellanox.com>
commit ec327f7a4340b635d89ca9667935adefa3905be1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ec327f7a.failed

Currently the number of TX queues that are allocated doesn't depend
on the number of TCs, the module always loads with max num of UP
per channel.
In order to prevent the allocation of unnecessary memory, the
module will load with minimum number of UPs per channel, and the
user will be able to control the number of TX queues per channel
by changing the number of TC to 8 using the tc command.
The variable num_up will hold the information about the current
number of UPs.
Due to the change, needed to remove the lines that set the value of
UP to be different than zero in the func "mlx4_en_select_queue",
since now the num of TX queues that are allocated is only one per channel
in default.
In order not to force the UP to be zero in case of only one TC, added
a condition before forcing it in the func "mlx4_en_fill_qp_context".

Tested:
After the module is loaded with minimum number of UP per channel, to
increase num of TCs to 8, use:
tc qdisc add dev ens8 root mqprio num_tc 8
In order to decrease the number of TCs to minimum number of UP per channel,
use:
tc qdisc del dev ens8 root

	Signed-off-by: Inbar Karmy <inbark@mellanox.com>
	Signed-off-by: Tariq Toukan <tariqt@mellanox.com>
	Cc: Tarick Bedeir <tarick@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ec327f7a4340b635d89ca9667935adefa3905be1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx4/en_dcb_nl.c
#	drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
#	drivers/net/ethernet/mellanox/mlx4/en_main.c
#	drivers/net/ethernet/mellanox/mlx4/en_netdev.c
#	drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
diff --cc drivers/net/ethernet/mellanox/mlx4/en_dcb_nl.c
index 5e48e60aa1d9,5f41dc92aa68..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/en_dcb_nl.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_dcb_nl.c
@@@ -303,7 -303,7 +303,11 @@@ static int mlx4_en_ets_validate(struct 
  	int has_ets_tc = 0;
  
  	for (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {
++<<<<<<< HEAD
 +		if (ets->prio_tc[i] >= MLX4_EN_NUM_UP) {
++=======
+ 		if (ets->prio_tc[i] >= MLX4_EN_NUM_UP_HIGH) {
++>>>>>>> ec327f7a4340 (net/mlx4_en: Do not allocate redundant TX queues when TC is disabled)
  			en_err(priv, "Bad priority in UP <=> TC mapping. TC: %d, UP: %d\n",
  					i, ets->prio_tc[i]);
  			return -EINVAL;
diff --cc drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
index 4654dc55644b,c751a1d434ad..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
@@@ -1776,11 -1802,11 +1777,16 @@@ static int mlx4_en_set_channels(struct 
  
  	mlx4_en_safe_replace_resources(priv, tmp);
  
- 	netif_set_real_num_tx_queues(dev, priv->tx_ring_num[TX]);
  	netif_set_real_num_rx_queues(dev, priv->rx_ring_num);
  
++<<<<<<< HEAD
 +	if (netdev_get_num_tc(dev))
 +		mlx4_en_setup_tc(dev, MLX4_EN_NUM_UP);
++=======
+ 	up = (priv->prof->num_up == MLX4_EN_NUM_UP_LOW) ?
+ 				    0 : priv->prof->num_up;
+ 	mlx4_en_setup_tc(dev, up);
++>>>>>>> ec327f7a4340 (net/mlx4_en: Do not allocate redundant TX queues when TC is disabled)
  
  	en_warn(priv, "Using %d TX rings\n", priv->tx_ring_num[TX]);
  	en_warn(priv, "Using %d RX rings\n", priv->rx_ring_num);
diff --cc drivers/net/ethernet/mellanox/mlx4/en_main.c
index a89a9a605f46,2b0cbca4beb5..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_main.c
@@@ -169,8 -169,10 +169,13 @@@ static int mlx4_en_get_profile(struct m
  		params->prof[i].tx_ppp = pfctx;
  		params->prof[i].tx_ring_size = MLX4_EN_DEF_TX_RING_SIZE;
  		params->prof[i].rx_ring_size = MLX4_EN_DEF_RX_RING_SIZE;
++<<<<<<< HEAD
++=======
+ 		params->prof[i].num_up = MLX4_EN_NUM_UP_LOW;
+ 		params->prof[i].num_tx_rings_p_up = params->num_tx_rings_p_up;
++>>>>>>> ec327f7a4340 (net/mlx4_en: Do not allocate redundant TX queues when TC is disabled)
  		params->prof[i].tx_ring_num[TX] = params->num_tx_rings_p_up *
 -			params->prof[i].num_up;
 +			MLX4_EN_NUM_UP;
  		params->prof[i].rss_rings = 0;
  		params->prof[i].inline_thold = inline_thold;
  	}
diff --cc drivers/net/ethernet/mellanox/mlx4/en_netdev.c
index b129285d1076,3a291fc1780a..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
@@@ -82,13 -86,63 +82,71 @@@ int mlx4_en_setup_tc(struct net_device 
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int __mlx4_en_setup_tc(struct net_device *dev, u32 handle, __be16 proto,
++=======
+ int mlx4_en_alloc_tx_queue_per_tc(struct net_device *dev, u8 tc)
+ {
+ 	struct mlx4_en_priv *priv = netdev_priv(dev);
+ 	struct mlx4_en_dev *mdev = priv->mdev;
+ 	struct mlx4_en_port_profile new_prof;
+ 	struct mlx4_en_priv *tmp;
+ 	int port_up = 0;
+ 	int err = 0;
+ 
+ 	tmp = kzalloc(sizeof(*tmp), GFP_KERNEL);
+ 	if (!tmp)
+ 		return -ENOMEM;
+ 
+ 	mutex_lock(&mdev->state_lock);
+ 	memcpy(&new_prof, priv->prof, sizeof(struct mlx4_en_port_profile));
+ 	new_prof.num_up = (tc == 0) ? MLX4_EN_NUM_UP_LOW :
+ 				      MLX4_EN_NUM_UP_HIGH;
+ 	new_prof.tx_ring_num[TX] = new_prof.num_tx_rings_p_up *
+ 				   new_prof.num_up;
+ 	err = mlx4_en_try_alloc_resources(priv, tmp, &new_prof, true);
+ 	if (err)
+ 		goto out;
+ 
+ 	if (priv->port_up) {
+ 		port_up = 1;
+ 		mlx4_en_stop_port(dev, 1);
+ 	}
+ 
+ 	mlx4_en_safe_replace_resources(priv, tmp);
+ 	if (port_up) {
+ 		err = mlx4_en_start_port(dev);
+ 		if (err) {
+ 			en_err(priv, "Failed starting port for setup TC\n");
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	err = mlx4_en_setup_tc(dev, tc);
+ out:
+ 	mutex_unlock(&mdev->state_lock);
+ 	kfree(tmp);
+ 	return err;
+ }
+ 
+ static int __mlx4_en_setup_tc(struct net_device *dev, u32 handle,
+ 			      u32 chain_index, __be16 proto,
++>>>>>>> ec327f7a4340 (net/mlx4_en: Do not allocate redundant TX queues when TC is disabled)
  			      struct tc_to_netdev *tc)
  {
  	if (tc->type != TC_SETUP_MQPRIO)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	return mlx4_en_setup_tc(dev, tc->tc);
++=======
+ 	if (tc->mqprio->num_tc && tc->mqprio->num_tc != MLX4_EN_NUM_UP_HIGH)
+ 		return -EINVAL;
+ 
+ 	tc->mqprio->hw = TC_MQPRIO_HW_OFFLOAD_TCS;
+ 
+ 	return mlx4_en_alloc_tx_queue_per_tc(dev, tc->mqprio->num_tc);
++>>>>>>> ec327f7a4340 (net/mlx4_en: Do not allocate redundant TX queues when TC is disabled)
  }
  
  #ifdef CONFIG_RFS_ACCEL
diff --cc drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
index c8bcd3a38f69,d350b2158104..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
+++ b/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
@@@ -130,7 -115,8 +130,12 @@@ enum 
  #define MLX4_EN_SMALL_PKT_SIZE		64
  #define MLX4_EN_MIN_TX_RING_P_UP	1
  #define MLX4_EN_MAX_TX_RING_P_UP	32
++<<<<<<< HEAD
 +#define MLX4_EN_NUM_UP			8
++=======
+ #define MLX4_EN_NUM_UP_LOW		1
+ #define MLX4_EN_NUM_UP_HIGH		8
++>>>>>>> ec327f7a4340 (net/mlx4_en: Do not allocate redundant TX queues when TC is disabled)
  #define MLX4_EN_DEF_RX_RING_SIZE  	1024
  #define MLX4_EN_DEF_TX_RING_SIZE	MLX4_EN_DEF_RX_RING_SIZE
  #define MAX_TX_RINGS			(MLX4_EN_MAX_TX_RING_P_UP * \
* Unmerged path drivers/net/ethernet/mellanox/mlx4/en_dcb_nl.c
* Unmerged path drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
* Unmerged path drivers/net/ethernet/mellanox/mlx4/en_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx4/en_netdev.c
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_resources.c b/drivers/net/ethernet/mellanox/mlx4/en_resources.c
index a6b0db0e0383..86d2d42d658d 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_resources.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_resources.c
@@ -63,7 +63,8 @@ void mlx4_en_fill_qp_context(struct mlx4_en_priv *priv, int size, int stride,
 	context->local_qpn = cpu_to_be32(qpn);
 	context->pri_path.ackto = 1 & 0x07;
 	context->pri_path.sched_queue = 0x83 | (priv->port - 1) << 6;
-	if (user_prio >= 0) {
+	/* force user priority per tx ring */
+	if (user_prio >= 0 && priv->prof->num_up == MLX4_EN_NUM_UP_HIGH) {
 		context->pri_path.sched_queue |= user_prio << 3;
 		context->pri_path.feup = MLX4_FEUP_FORCE_ETH_UP;
 	}
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_tx.c b/drivers/net/ethernet/mellanox/mlx4/en_tx.c
index 8c25cc789ee8..2c5c7723db01 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_tx.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_tx.c
@@ -683,15 +683,11 @@ u16 mlx4_en_select_queue(struct net_device *dev, struct sk_buff *skb,
 {
 	struct mlx4_en_priv *priv = netdev_priv(dev);
 	u16 rings_p_up = priv->num_tx_rings_p_up;
-	u8 up = 0;
 
 	if (netdev_get_num_tc(dev))
 		return skb_tx_hash(dev, skb);
 
-	if (skb_vlan_tag_present(skb))
-		up = skb_vlan_tag_get(skb) >> VLAN_PRIO_SHIFT;
-
-	return fallback(dev, skb) % rings_p_up + up * rings_p_up;
+	return fallback(dev, skb) % rings_p_up;
 }
 
 static void mlx4_bf_copy(void __iomem *dst, const void *src,
* Unmerged path drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
