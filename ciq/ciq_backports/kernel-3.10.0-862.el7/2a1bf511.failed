ibmvnic: Fix failover error path for non-fatal resets

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author John Allen <jallen@linux.vnet.ibm.com>
commit 2a1bf51111975846f412f47449edefdf6fa17ee4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2a1bf511.failed

For all non-fatal reset conditions, the hypervisor will send a failover when
we attempt to initialize the crq and the vnic client is expected to handle
that failover instead of the existing non-fatal reset. To handle this, we
need to return from init with a return code that indicates that we have hit
this case.

	Signed-off-by: John Allen <jallen@linux.vnet.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2a1bf51111975846f412f47449edefdf6fa17ee4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/ibm/ibmvnic.c
diff --cc drivers/net/ethernet/ibm/ibmvnic.c
index 372983d733ad,d0cff2807d0b..000000000000
--- a/drivers/net/ethernet/ibm/ibmvnic.c
+++ b/drivers/net/ethernet/ibm/ibmvnic.c
@@@ -1001,6 -1466,218 +1001,221 @@@ static int ibmvnic_change_mtu(struct ne
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * do_reset returns zero if we are able to keep processing reset events, or
+  * non-zero if we hit a fatal error and must halt.
+  */
+ static int do_reset(struct ibmvnic_adapter *adapter,
+ 		    struct ibmvnic_rwi *rwi, u32 reset_state)
+ {
+ 	struct net_device *netdev = adapter->netdev;
+ 	int i, rc;
+ 
+ 	netdev_dbg(adapter->netdev, "Re-setting driver (%d)\n",
+ 		   rwi->reset_reason);
+ 
+ 	netif_carrier_off(netdev);
+ 	adapter->reset_reason = rwi->reset_reason;
+ 
+ 	if (rwi->reset_reason == VNIC_RESET_MOBILITY) {
+ 		rc = ibmvnic_reenable_crq_queue(adapter);
+ 		if (rc)
+ 			return 0;
+ 	}
+ 
+ 	rc = __ibmvnic_close(netdev);
+ 	if (rc)
+ 		return rc;
+ 
+ 	if (adapter->reset_reason == VNIC_RESET_CHANGE_PARAM ||
+ 	    adapter->wait_for_reset) {
+ 		release_resources(adapter);
+ 		release_sub_crqs(adapter);
+ 		release_crq_queue(adapter);
+ 	}
+ 
+ 	if (adapter->reset_reason != VNIC_RESET_NON_FATAL) {
+ 		/* remove the closed state so when we call open it appears
+ 		 * we are coming from the probed state.
+ 		 */
+ 		adapter->state = VNIC_PROBED;
+ 
+ 		rc = ibmvnic_init(adapter);
+ 		if (rc)
+ 			return IBMVNIC_INIT_FAILED;
+ 
+ 		/* If the adapter was in PROBE state prior to the reset,
+ 		 * exit here.
+ 		 */
+ 		if (reset_state == VNIC_PROBED)
+ 			return 0;
+ 
+ 		rc = ibmvnic_login(netdev);
+ 		if (rc) {
+ 			adapter->state = VNIC_PROBED;
+ 			return 0;
+ 		}
+ 
+ 		if (adapter->reset_reason == VNIC_RESET_CHANGE_PARAM ||
+ 		    adapter->wait_for_reset) {
+ 			rc = init_resources(adapter);
+ 			if (rc)
+ 				return rc;
+ 		} else {
+ 			rc = reset_tx_pools(adapter);
+ 			if (rc)
+ 				return rc;
+ 
+ 			rc = reset_rx_pools(adapter);
+ 			if (rc)
+ 				return rc;
+ 
+ 			if (reset_state == VNIC_CLOSED)
+ 				return 0;
+ 		}
+ 	}
+ 
+ 	rc = __ibmvnic_open(netdev);
+ 	if (rc) {
+ 		if (list_empty(&adapter->rwi_list))
+ 			adapter->state = VNIC_CLOSED;
+ 		else
+ 			adapter->state = reset_state;
+ 
+ 		return 0;
+ 	}
+ 
+ 	netif_carrier_on(netdev);
+ 
+ 	/* kick napi */
+ 	for (i = 0; i < adapter->req_rx_queues; i++)
+ 		napi_schedule(&adapter->napi[i]);
+ 
+ 	if (adapter->reset_reason != VNIC_RESET_FAILOVER)
+ 		netdev_notify_peers(netdev);
+ 
+ 	return 0;
+ }
+ 
+ static struct ibmvnic_rwi *get_next_rwi(struct ibmvnic_adapter *adapter)
+ {
+ 	struct ibmvnic_rwi *rwi;
+ 
+ 	mutex_lock(&adapter->rwi_lock);
+ 
+ 	if (!list_empty(&adapter->rwi_list)) {
+ 		rwi = list_first_entry(&adapter->rwi_list, struct ibmvnic_rwi,
+ 				       list);
+ 		list_del(&rwi->list);
+ 	} else {
+ 		rwi = NULL;
+ 	}
+ 
+ 	mutex_unlock(&adapter->rwi_lock);
+ 	return rwi;
+ }
+ 
+ static void free_all_rwi(struct ibmvnic_adapter *adapter)
+ {
+ 	struct ibmvnic_rwi *rwi;
+ 
+ 	rwi = get_next_rwi(adapter);
+ 	while (rwi) {
+ 		kfree(rwi);
+ 		rwi = get_next_rwi(adapter);
+ 	}
+ }
+ 
+ static void __ibmvnic_reset(struct work_struct *work)
+ {
+ 	struct ibmvnic_rwi *rwi;
+ 	struct ibmvnic_adapter *adapter;
+ 	struct net_device *netdev;
+ 	u32 reset_state;
+ 	int rc = 0;
+ 
+ 	adapter = container_of(work, struct ibmvnic_adapter, ibmvnic_reset);
+ 	netdev = adapter->netdev;
+ 
+ 	mutex_lock(&adapter->reset_lock);
+ 	adapter->resetting = true;
+ 	reset_state = adapter->state;
+ 
+ 	rwi = get_next_rwi(adapter);
+ 	while (rwi) {
+ 		rc = do_reset(adapter, rwi, reset_state);
+ 		kfree(rwi);
+ 		if (rc && rc != IBMVNIC_INIT_FAILED)
+ 			break;
+ 
+ 		rwi = get_next_rwi(adapter);
+ 	}
+ 
+ 	if (adapter->wait_for_reset) {
+ 		adapter->wait_for_reset = false;
+ 		adapter->reset_done_rc = rc;
+ 		complete(&adapter->reset_done);
+ 	}
+ 
+ 	if (rc) {
+ 		netdev_dbg(adapter->netdev, "Reset failed\n");
+ 		free_all_rwi(adapter);
+ 		mutex_unlock(&adapter->reset_lock);
+ 		return;
+ 	}
+ 
+ 	adapter->resetting = false;
+ 	mutex_unlock(&adapter->reset_lock);
+ }
+ 
+ static void ibmvnic_reset(struct ibmvnic_adapter *adapter,
+ 			  enum ibmvnic_reset_reason reason)
+ {
+ 	struct ibmvnic_rwi *rwi, *tmp;
+ 	struct net_device *netdev = adapter->netdev;
+ 	struct list_head *entry;
+ 
+ 	if (adapter->state == VNIC_REMOVING ||
+ 	    adapter->state == VNIC_REMOVED) {
+ 		netdev_dbg(netdev, "Adapter removing, skipping reset\n");
+ 		return;
+ 	}
+ 
+ 	if (adapter->state == VNIC_PROBING) {
+ 		netdev_warn(netdev, "Adapter reset during probe\n");
+ 		adapter->init_done_rc = EAGAIN;
+ 		return;
+ 	}
+ 
+ 	mutex_lock(&adapter->rwi_lock);
+ 
+ 	list_for_each(entry, &adapter->rwi_list) {
+ 		tmp = list_entry(entry, struct ibmvnic_rwi, list);
+ 		if (tmp->reset_reason == reason) {
+ 			netdev_dbg(netdev, "Skipping matching reset\n");
+ 			mutex_unlock(&adapter->rwi_lock);
+ 			return;
+ 		}
+ 	}
+ 
+ 	rwi = kzalloc(sizeof(*rwi), GFP_KERNEL);
+ 	if (!rwi) {
+ 		mutex_unlock(&adapter->rwi_lock);
+ 		ibmvnic_close(netdev);
+ 		return;
+ 	}
+ 
+ 	rwi->reset_reason = reason;
+ 	list_add_tail(&rwi->list, &adapter->rwi_list);
+ 	mutex_unlock(&adapter->rwi_lock);
+ 
+ 	netdev_dbg(adapter->netdev, "Scheduling reset (reason %d)\n", reason);
+ 	schedule_work(&adapter->ibmvnic_reset);
+ }
+ 
++>>>>>>> 2a1bf5111197 (ibmvnic: Fix failover error path for non-fatal resets)
  static void ibmvnic_tx_timeout(struct net_device *dev)
  {
  	struct ibmvnic_adapter *adapter = netdev_priv(dev);
* Unmerged path drivers/net/ethernet/ibm/ibmvnic.c
diff --git a/drivers/net/ethernet/ibm/ibmvnic.h b/drivers/net/ethernet/ibm/ibmvnic.h
index 082a339df814..a1f92eb81625 100644
--- a/drivers/net/ethernet/ibm/ibmvnic.h
+++ b/drivers/net/ethernet/ibm/ibmvnic.h
@@ -30,6 +30,8 @@
 #define IBMVNIC_DRIVER_VERSION	"1.0"
 #define IBMVNIC_INVALID_MAP	-1
 #define IBMVNIC_STATS_TIMEOUT	1
+#define IBMVNIC_INIT_FAILED	2
+
 /* basic structures plus 100 2k buffers */
 #define IBMVNIC_IO_ENTITLEMENT_DEFAULT	610305
 
