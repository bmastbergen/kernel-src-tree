nfp: add helpers for FEC support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Dirk van der Merwe <dirk.vandermerwe@netronome.com>
commit b471232e2caa054e006fa4b5fd4bf15544b00b0f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b471232e.failed

Implement helpers to determine and modify FEC modes via the NSP.
The NSP advertises FEC capabilities on a per port basis and provides
support for:
* Auto mode selection
* Reed Solomon
* BaseR
* None/Off

	Signed-off-by: Dirk van der Merwe <dirk.vandermerwe@netronome.com>
	Signed-off-by: Simon Horman <simon.horman@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b471232e2caa054e006fa4b5fd4bf15544b00b0f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.c
#	drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.h
diff --cc drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.c
index f94361014b87,7ca589660e4d..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.c
+++ b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.c
@@@ -62,10 -65,29 +64,34 @@@
  #define NSP_ETH_STATE_TX_ENABLED	BIT_ULL(2)
  #define NSP_ETH_STATE_RX_ENABLED	BIT_ULL(3)
  #define NSP_ETH_STATE_RATE		GENMASK_ULL(11, 8)
++<<<<<<< HEAD
++=======
+ #define NSP_ETH_STATE_INTERFACE		GENMASK_ULL(19, 12)
+ #define NSP_ETH_STATE_MEDIA		GENMASK_ULL(21, 20)
+ #define NSP_ETH_STATE_OVRD_CHNG		BIT_ULL(22)
+ #define NSP_ETH_STATE_ANEG		GENMASK_ULL(25, 23)
+ #define NSP_ETH_STATE_FEC		GENMASK_ULL(27, 26)
++>>>>>>> b471232e2caa (nfp: add helpers for FEC support)
  
 -#define NSP_ETH_CTRL_CONFIGURED		BIT_ULL(0)
  #define NSP_ETH_CTRL_ENABLED		BIT_ULL(1)
  #define NSP_ETH_CTRL_TX_ENABLED		BIT_ULL(2)
  #define NSP_ETH_CTRL_RX_ENABLED		BIT_ULL(3)
++<<<<<<< HEAD
++=======
+ #define NSP_ETH_CTRL_SET_RATE		BIT_ULL(4)
+ #define NSP_ETH_CTRL_SET_LANES		BIT_ULL(5)
+ #define NSP_ETH_CTRL_SET_ANEG		BIT_ULL(6)
+ #define NSP_ETH_CTRL_SET_FEC		BIT_ULL(7)
+ 
+ enum nfp_eth_raw {
+ 	NSP_ETH_RAW_PORT = 0,
+ 	NSP_ETH_RAW_STATE,
+ 	NSP_ETH_RAW_MAC,
+ 	NSP_ETH_RAW_CONTROL,
+ 
+ 	NSP_ETH_NUM_RAW
+ };
++>>>>>>> b471232e2caa (nfp: add helpers for FEC support)
  
  enum nfp_eth_rate {
  	RATE_INVALID = 0,
@@@ -110,10 -152,11 +136,11 @@@ static void nfp_eth_copy_mac_reverse(u
  }
  
  static void
 -nfp_eth_port_translate(struct nfp_nsp *nsp, const union eth_table_entry *src,
 -		       unsigned int index, struct nfp_eth_table_port *dst)
 +nfp_eth_port_translate(const struct eth_table_entry *src, unsigned int index,
 +		       struct nfp_eth_table_port *dst)
  {
  	unsigned int rate;
+ 	unsigned int fec;
  	u64 port, state;
  
  	port = le64_to_cpu(src->port);
@@@ -129,14 -172,76 +156,79 @@@
  	dst->tx_enabled = FIELD_GET(NSP_ETH_STATE_TX_ENABLED, state);
  	dst->rx_enabled = FIELD_GET(NSP_ETH_STATE_RX_ENABLED, state);
  
 -	rate = nfp_eth_rate2speed(FIELD_GET(NSP_ETH_STATE_RATE, state));
 +	rate = nfp_eth_rate(FIELD_GET(NSP_ETH_STATE_RATE, state));
  	dst->speed = dst->lanes * rate;
  
 -	dst->interface = FIELD_GET(NSP_ETH_STATE_INTERFACE, state);
 -	dst->media = FIELD_GET(NSP_ETH_STATE_MEDIA, state);
 -
  	nfp_eth_copy_mac_reverse(dst->mac_addr, src->mac_addr);
  
++<<<<<<< HEAD
 +	snprintf(dst->label, sizeof(dst->label) - 1, "%llu.%llu",
 +		 FIELD_GET(NSP_ETH_PORT_PHYLABEL, port),
 +		 FIELD_GET(NSP_ETH_PORT_LABEL, port));
++=======
+ 	dst->label_port = FIELD_GET(NSP_ETH_PORT_PHYLABEL, port);
+ 	dst->label_subport = FIELD_GET(NSP_ETH_PORT_LABEL, port);
+ 
+ 	if (nfp_nsp_get_abi_ver_minor(nsp) < 17)
+ 		return;
+ 
+ 	dst->override_changed = FIELD_GET(NSP_ETH_STATE_OVRD_CHNG, state);
+ 	dst->aneg = FIELD_GET(NSP_ETH_STATE_ANEG, state);
+ 
+ 	if (nfp_nsp_get_abi_ver_minor(nsp) < 22)
+ 		return;
+ 
+ 	fec = FIELD_GET(NSP_ETH_PORT_FEC_SUPP_BASER, port);
+ 	dst->fec_modes_supported |= fec << NFP_FEC_BASER_BIT;
+ 	fec = FIELD_GET(NSP_ETH_PORT_FEC_SUPP_RS, port);
+ 	dst->fec_modes_supported |= fec << NFP_FEC_REED_SOLOMON_BIT;
+ 	if (dst->fec_modes_supported)
+ 		dst->fec_modes_supported |= NFP_FEC_AUTO | NFP_FEC_DISABLED;
+ 
+ 	dst->fec = 1 << FIELD_GET(NSP_ETH_STATE_FEC, state);
+ }
+ 
+ static void
+ nfp_eth_calc_port_geometry(struct nfp_cpp *cpp, struct nfp_eth_table *table)
+ {
+ 	unsigned int i, j;
+ 
+ 	for (i = 0; i < table->count; i++) {
+ 		table->max_index = max(table->max_index, table->ports[i].index);
+ 
+ 		for (j = 0; j < table->count; j++) {
+ 			if (table->ports[i].label_port !=
+ 			    table->ports[j].label_port)
+ 				continue;
+ 			table->ports[i].port_lanes += table->ports[j].lanes;
+ 
+ 			if (i == j)
+ 				continue;
+ 			if (table->ports[i].label_subport ==
+ 			    table->ports[j].label_subport)
+ 				nfp_warn(cpp,
+ 					 "Port %d subport %d is a duplicate\n",
+ 					 table->ports[i].label_port,
+ 					 table->ports[i].label_subport);
+ 
+ 			table->ports[i].is_split = true;
+ 		}
+ 	}
+ }
+ 
+ static void
+ nfp_eth_calc_port_type(struct nfp_cpp *cpp, struct nfp_eth_table_port *entry)
+ {
+ 	if (entry->interface == NFP_INTERFACE_NONE) {
+ 		entry->port_type = PORT_NONE;
+ 		return;
+ 	}
+ 
+ 	if (entry->media == NFP_MEDIA_FIBRE)
+ 		entry->port_type = PORT_FIBRE;
+ 	else
+ 		entry->port_type = PORT_DA;
++>>>>>>> b471232e2caa (nfp: add helpers for FEC support)
  }
  
  /**
@@@ -251,26 -348,290 +343,227 @@@ int nfp_eth_set_mod_enable(struct nfp_c
  	if (!(entries[idx].port & NSP_ETH_PORT_LANES_MASK)) {
  		nfp_warn(cpp, "trying to set port state on disabled port %d\n",
  			 idx);
 -		goto err;
 +		ret = -EINVAL;
 +		goto exit_close_nsp;
  	}
  
 -	nfp_nsp_config_set_state(nsp, entries, idx);
 -	return nsp;
 -
 -err:
 -	nfp_nsp_close(nsp);
 -	kfree(entries);
 -	return ERR_PTR(-EIO);
 -}
 +	/* Check if we are already in requested state */
 +	reg = le64_to_cpu(entries[idx].state);
 +	if (enable == FIELD_GET(NSP_ETH_CTRL_ENABLED, reg)) {
 +		ret = 0;
 +		goto exit_close_nsp;
 +	}
  
 -void nfp_eth_config_cleanup_end(struct nfp_nsp *nsp)
 -{
 -	union eth_table_entry *entries = nfp_nsp_config_entries(nsp);
++<<<<<<< HEAD
 +	reg = le64_to_cpu(entries[idx].control);
 +	reg &= ~NSP_ETH_CTRL_ENABLED;
 +	reg |= FIELD_PREP(NSP_ETH_CTRL_ENABLED, enable);
 +	entries[idx].control = cpu_to_le64(reg);
  
 -	nfp_nsp_config_set_modified(nsp, false);
 -	nfp_nsp_config_clear_state(nsp);
 +	ret = nfp_nsp_write_eth_table(nsp, entries, NSP_ETH_TABLE_SIZE);
 +exit_close_nsp:
  	nfp_nsp_close(nsp);
  	kfree(entries);
 -}
 -
 -/**
 - * nfp_eth_config_commit_end() - perform recorded configuration changes
 - * @nsp:	NFP NSP handle returned from nfp_eth_config_start()
 - *
 - * Perform the configuration which was requested with __nfp_eth_set_*()
 - * helpers and recorded in @nsp state.  If device was already configured
 - * as requested or no __nfp_eth_set_*() operations were made no NSP command
 - * will be performed.
 - *
 - * Return:
 - * 0 - configuration successful;
 - * 1 - no changes were needed;
 - * -ERRNO - configuration failed.
 - */
 -int nfp_eth_config_commit_end(struct nfp_nsp *nsp)
 -{
 -	union eth_table_entry *entries = nfp_nsp_config_entries(nsp);
 -	int ret = 1;
 -
 -	if (nfp_nsp_config_modified(nsp)) {
 -		ret = nfp_nsp_write_eth_table(nsp, entries, NSP_ETH_TABLE_SIZE);
 -		ret = ret < 0 ? ret : 0;
 -	}
 -
 -	nfp_eth_config_cleanup_end(nsp);
 -
 -	return ret;
 -}
 -
 -/**
 - * nfp_eth_set_mod_enable() - set PHY module enable control bit
 - * @cpp:	NFP CPP handle
 - * @idx:	NFP chip-wide port index
 - * @enable:	Desired state
 - *
 - * Enable or disable PHY module (this usually means setting the TX lanes
 - * disable bits).
 - *
 - * Return:
 - * 0 - configuration successful;
 - * 1 - no changes were needed;
 - * -ERRNO - configuration failed.
 - */
 -int nfp_eth_set_mod_enable(struct nfp_cpp *cpp, unsigned int idx, bool enable)
 -{
 -	union eth_table_entry *entries;
 -	struct nfp_nsp *nsp;
 -	u64 reg;
 -
 -	nsp = nfp_eth_config_start(cpp, idx);
 -	if (IS_ERR(nsp))
 -		return PTR_ERR(nsp);
 -
 -	entries = nfp_nsp_config_entries(nsp);
 -
 -	/* Check if we are already in requested state */
 -	reg = le64_to_cpu(entries[idx].state);
 -	if (enable != FIELD_GET(NSP_ETH_CTRL_ENABLED, reg)) {
 -		reg = le64_to_cpu(entries[idx].control);
 -		reg &= ~NSP_ETH_CTRL_ENABLED;
 -		reg |= FIELD_PREP(NSP_ETH_CTRL_ENABLED, enable);
 -		entries[idx].control = cpu_to_le64(reg);
 -
 -		nfp_nsp_config_set_modified(nsp, true);
 -	}
  
 +	return ret < 0 ? ret : 0;
++=======
+ 	return nfp_eth_config_commit_end(nsp);
+ }
+ 
+ /**
+  * nfp_eth_set_configured() - set PHY module configured control bit
+  * @cpp:	NFP CPP handle
+  * @idx:	NFP chip-wide port index
+  * @configed:	Desired state
+  *
+  * Set the ifup/ifdown state on the PHY.
+  *
+  * Return:
+  * 0 - configuration successful;
+  * 1 - no changes were needed;
+  * -ERRNO - configuration failed.
+  */
+ int nfp_eth_set_configured(struct nfp_cpp *cpp, unsigned int idx, bool configed)
+ {
+ 	union eth_table_entry *entries;
+ 	struct nfp_nsp *nsp;
+ 	u64 reg;
+ 
+ 	nsp = nfp_eth_config_start(cpp, idx);
+ 	if (IS_ERR(nsp))
+ 		return PTR_ERR(nsp);
+ 
+ 	/* Older ABI versions did support this feature, however this has only
+ 	 * been reliable since ABI 20.
+ 	 */
+ 	if (nfp_nsp_get_abi_ver_minor(nsp) < 20) {
+ 		nfp_eth_config_cleanup_end(nsp);
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	entries = nfp_nsp_config_entries(nsp);
+ 
+ 	/* Check if we are already in requested state */
+ 	reg = le64_to_cpu(entries[idx].state);
+ 	if (configed != FIELD_GET(NSP_ETH_STATE_CONFIGURED, reg)) {
+ 		reg = le64_to_cpu(entries[idx].control);
+ 		reg &= ~NSP_ETH_CTRL_CONFIGURED;
+ 		reg |= FIELD_PREP(NSP_ETH_CTRL_CONFIGURED, configed);
+ 		entries[idx].control = cpu_to_le64(reg);
+ 
+ 		nfp_nsp_config_set_modified(nsp, true);
+ 	}
+ 
+ 	return nfp_eth_config_commit_end(nsp);
+ }
+ 
+ static int
+ nfp_eth_set_bit_config(struct nfp_nsp *nsp, unsigned int raw_idx,
+ 		       const u64 mask, const unsigned int shift,
+ 		       unsigned int val, const u64 ctrl_bit)
+ {
+ 	union eth_table_entry *entries = nfp_nsp_config_entries(nsp);
+ 	unsigned int idx = nfp_nsp_config_idx(nsp);
+ 	u64 reg;
+ 
+ 	/* Note: set features were added in ABI 0.14 but the error
+ 	 *	 codes were initially not populated correctly.
+ 	 */
+ 	if (nfp_nsp_get_abi_ver_minor(nsp) < 17) {
+ 		nfp_err(nfp_nsp_cpp(nsp),
+ 			"set operations not supported, please update flash\n");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	/* Check if we are already in requested state */
+ 	reg = le64_to_cpu(entries[idx].raw[raw_idx]);
+ 	if (val == (reg & mask) >> shift)
+ 		return 0;
+ 
+ 	reg &= ~mask;
+ 	reg |= (val << shift) & mask;
+ 	entries[idx].raw[raw_idx] = cpu_to_le64(reg);
+ 
+ 	entries[idx].control |= cpu_to_le64(ctrl_bit);
+ 
+ 	nfp_nsp_config_set_modified(nsp, true);
+ 
+ 	return 0;
+ }
+ 
+ #define NFP_ETH_SET_BIT_CONFIG(nsp, raw_idx, mask, val, ctrl_bit)	\
+ 	({								\
+ 		__BF_FIELD_CHECK(mask, 0ULL, val, "NFP_ETH_SET_BIT_CONFIG: "); \
+ 		nfp_eth_set_bit_config(nsp, raw_idx, mask, __bf_shf(mask), \
+ 				       val, ctrl_bit);			\
+ 	})
+ 
+ /**
+  * __nfp_eth_set_aneg() - set PHY autonegotiation control bit
+  * @nsp:	NFP NSP handle returned from nfp_eth_config_start()
+  * @mode:	Desired autonegotiation mode
+  *
+  * Allow/disallow PHY module to advertise/perform autonegotiation.
+  * Will write to hwinfo overrides in the flash (persistent config).
+  *
+  * Return: 0 or -ERRNO.
+  */
+ int __nfp_eth_set_aneg(struct nfp_nsp *nsp, enum nfp_eth_aneg mode)
+ {
+ 	return NFP_ETH_SET_BIT_CONFIG(nsp, NSP_ETH_RAW_STATE,
+ 				      NSP_ETH_STATE_ANEG, mode,
+ 				      NSP_ETH_CTRL_SET_ANEG);
+ }
+ 
+ /**
+  * __nfp_eth_set_fec() - set PHY forward error correction control bit
+  * @nsp:	NFP NSP handle returned from nfp_eth_config_start()
+  * @mode:	Desired fec mode
+  *
+  * Set the PHY module forward error correction mode.
+  * Will write to hwinfo overrides in the flash (persistent config).
+  *
+  * Return: 0 or -ERRNO.
+  */
+ static int __nfp_eth_set_fec(struct nfp_nsp *nsp, enum nfp_eth_fec mode)
+ {
+ 	return NFP_ETH_SET_BIT_CONFIG(nsp, NSP_ETH_RAW_STATE,
+ 				      NSP_ETH_STATE_FEC, mode,
+ 				      NSP_ETH_CTRL_SET_FEC);
+ }
+ 
+ /**
+  * nfp_eth_set_fec() - set PHY forward error correction control mode
+  * @cpp:	NFP CPP handle
+  * @idx:	NFP chip-wide port index
+  * @mode:	Desired fec mode
+  *
+  * Return:
+  * 0 - configuration successful;
+  * 1 - no changes were needed;
+  * -ERRNO - configuration failed.
+  */
+ int
+ nfp_eth_set_fec(struct nfp_cpp *cpp, unsigned int idx, enum nfp_eth_fec mode)
+ {
+ 	struct nfp_nsp *nsp;
+ 	int err;
+ 
+ 	nsp = nfp_eth_config_start(cpp, idx);
+ 	if (IS_ERR(nsp))
+ 		return PTR_ERR(nsp);
+ 
+ 	err = __nfp_eth_set_fec(nsp, mode);
+ 	if (err) {
+ 		nfp_eth_config_cleanup_end(nsp);
+ 		return err;
+ 	}
+ 
+ 	return nfp_eth_config_commit_end(nsp);
+ }
+ 
+ /**
+  * __nfp_eth_set_speed() - set interface speed/rate
+  * @nsp:	NFP NSP handle returned from nfp_eth_config_start()
+  * @speed:	Desired speed (per lane)
+  *
+  * Set lane speed.  Provided @speed value should be subport speed divided
+  * by number of lanes this subport is spanning (i.e. 10000 for 40G, 25000 for
+  * 50G, etc.)
+  * Will write to hwinfo overrides in the flash (persistent config).
+  *
+  * Return: 0 or -ERRNO.
+  */
+ int __nfp_eth_set_speed(struct nfp_nsp *nsp, unsigned int speed)
+ {
+ 	enum nfp_eth_rate rate;
+ 
+ 	rate = nfp_eth_speed2rate(speed);
+ 	if (rate == RATE_INVALID) {
+ 		nfp_warn(nfp_nsp_cpp(nsp),
+ 			 "could not find matching lane rate for speed %u\n",
+ 			 speed);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return NFP_ETH_SET_BIT_CONFIG(nsp, NSP_ETH_RAW_STATE,
+ 				      NSP_ETH_STATE_RATE, rate,
+ 				      NSP_ETH_CTRL_SET_RATE);
+ }
+ 
+ /**
+  * __nfp_eth_set_split() - set interface lane split
+  * @nsp:	NFP NSP handle returned from nfp_eth_config_start()
+  * @lanes:	Desired lanes per port
+  *
+  * Set number of lanes in the port.
+  * Will write to hwinfo overrides in the flash (persistent config).
+  *
+  * Return: 0 or -ERRNO.
+  */
+ int __nfp_eth_set_split(struct nfp_nsp *nsp, unsigned int lanes)
+ {
+ 	return NFP_ETH_SET_BIT_CONFIG(nsp, NSP_ETH_RAW_PORT, NSP_ETH_PORT_LANES,
+ 				      lanes, NSP_ETH_CTRL_SET_LANES);
++>>>>>>> b471232e2caa (nfp: add helpers for FEC support)
  }
diff --cc drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.h
index 40eb6f95d0ce,650ca1a5bd21..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.h
+++ b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.h
@@@ -37,6 -37,60 +37,63 @@@
  #include <linux/types.h>
  #include <linux/if_ether.h>
  
++<<<<<<< HEAD:drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.h
++=======
+ struct firmware;
+ struct nfp_cpp;
+ struct nfp_nsp;
+ 
+ struct nfp_nsp *nfp_nsp_open(struct nfp_cpp *cpp);
+ void nfp_nsp_close(struct nfp_nsp *state);
+ u16 nfp_nsp_get_abi_ver_major(struct nfp_nsp *state);
+ u16 nfp_nsp_get_abi_ver_minor(struct nfp_nsp *state);
+ int nfp_nsp_wait(struct nfp_nsp *state);
+ int nfp_nsp_device_soft_reset(struct nfp_nsp *state);
+ int nfp_nsp_load_fw(struct nfp_nsp *state, const struct firmware *fw);
+ int nfp_nsp_mac_reinit(struct nfp_nsp *state);
+ 
+ static inline bool nfp_nsp_has_mac_reinit(struct nfp_nsp *state)
+ {
+ 	return nfp_nsp_get_abi_ver_minor(state) > 20;
+ }
+ 
+ enum nfp_eth_interface {
+ 	NFP_INTERFACE_NONE	= 0,
+ 	NFP_INTERFACE_SFP	= 1,
+ 	NFP_INTERFACE_SFPP	= 10,
+ 	NFP_INTERFACE_SFP28	= 28,
+ 	NFP_INTERFACE_QSFP	= 40,
+ 	NFP_INTERFACE_CXP	= 100,
+ 	NFP_INTERFACE_QSFP28	= 112,
+ };
+ 
+ enum nfp_eth_media {
+ 	NFP_MEDIA_DAC_PASSIVE = 0,
+ 	NFP_MEDIA_DAC_ACTIVE,
+ 	NFP_MEDIA_FIBRE,
+ };
+ 
+ enum nfp_eth_aneg {
+ 	NFP_ANEG_AUTO = 0,
+ 	NFP_ANEG_SEARCH,
+ 	NFP_ANEG_25G_CONSORTIUM,
+ 	NFP_ANEG_25G_IEEE,
+ 	NFP_ANEG_DISABLED,
+ };
+ 
+ enum nfp_eth_fec {
+ 	NFP_FEC_AUTO_BIT = 0,
+ 	NFP_FEC_BASER_BIT,
+ 	NFP_FEC_REED_SOLOMON_BIT,
+ 	NFP_FEC_DISABLED_BIT,
+ };
+ 
+ #define NFP_FEC_AUTO		BIT(NFP_FEC_AUTO_BIT)
+ #define NFP_FEC_BASER		BIT(NFP_FEC_BASER_BIT)
+ #define NFP_FEC_REED_SOLOMON	BIT(NFP_FEC_REED_SOLOMON_BIT)
+ #define NFP_FEC_DISABLED	BIT(NFP_FEC_DISABLED_BIT)
+ 
++>>>>>>> b471232e2caa (nfp: add helpers for FEC support):drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp.h
  /**
   * struct nfp_eth_table - ETH table information
   * @count:	number of table entries
@@@ -48,11 -103,22 +105,27 @@@
   * @base:	first channel index (within NBI)
   * @lanes:	number of channels
   * @speed:	interface speed (in Mbps)
++<<<<<<< HEAD:drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.h
++=======
+  * @interface:	interface (module) plugged in
+  * @media:	media type of the @interface
+  * @fec:	forward error correction mode
+  * @aneg:	auto negotiation mode
++>>>>>>> b471232e2caa (nfp: add helpers for FEC support):drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp.h
   * @mac_addr:	interface MAC address
 - * @label_port:	port id
 - * @label_subport:  id of interface within port (for split ports)
 + * @label:	interface id string
   * @enabled:	is enabled?
   * @tx_enabled:	is TX enabled?
   * @rx_enabled:	is RX enabled?
++<<<<<<< HEAD:drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.h
++=======
+  * @override_changed: is media reconfig pending?
+  *
+  * @port_type:	one of %PORT_* defines for ethtool
+  * @port_lanes:	total number of lanes on the port (sum of lanes of all subports)
+  * @is_split:	is interface part of a split port
+  * @fec_modes_supported:	bitmap of FEC modes supported
++>>>>>>> b471232e2caa (nfp: add helpers for FEC support):drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp.h
   */
  struct nfp_eth_table {
  	unsigned int count;
@@@ -64,19 -131,62 +137,68 @@@
  		unsigned int lanes;
  		unsigned int speed;
  
++<<<<<<< HEAD:drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.h
++=======
+ 		unsigned int interface;
+ 		enum nfp_eth_media media;
+ 
+ 		enum nfp_eth_fec fec;
+ 		enum nfp_eth_aneg aneg;
+ 
++>>>>>>> b471232e2caa (nfp: add helpers for FEC support):drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp.h
  		u8 mac_addr[ETH_ALEN];
 -
 -		u8 label_port;
 -		u8 label_subport;
 +		char label[8];
  
  		bool enabled;
  		bool tx_enabled;
  		bool rx_enabled;
++<<<<<<< HEAD:drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.h
++=======
+ 
+ 		bool override_changed;
+ 
+ 		/* Computed fields */
+ 		u8 port_type;
+ 
+ 		unsigned int port_lanes;
+ 
+ 		bool is_split;
+ 
+ 		unsigned int fec_modes_supported;
++>>>>>>> b471232e2caa (nfp: add helpers for FEC support):drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp.h
  	} ports[0];
  };
  
  struct nfp_eth_table *nfp_eth_read_ports(struct nfp_cpp *cpp);
  struct nfp_eth_table *
  __nfp_eth_read_ports(struct nfp_cpp *cpp, struct nfp_nsp *nsp);
 -
  int nfp_eth_set_mod_enable(struct nfp_cpp *cpp, unsigned int idx, bool enable);
++<<<<<<< HEAD:drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.h
++=======
+ int nfp_eth_set_configured(struct nfp_cpp *cpp, unsigned int idx,
+ 			   bool configed);
+ int
+ nfp_eth_set_fec(struct nfp_cpp *cpp, unsigned int idx, enum nfp_eth_fec mode);
+ 
+ static inline bool nfp_eth_can_support_fec(struct nfp_eth_table_port *eth_port)
+ {
+ 	return !!eth_port->fec_modes_supported;
+ }
+ 
+ static inline unsigned int
+ nfp_eth_supported_fec_modes(struct nfp_eth_table_port *eth_port)
+ {
+ 	return eth_port->fec_modes_supported;
+ }
+ 
+ struct nfp_nsp *nfp_eth_config_start(struct nfp_cpp *cpp, unsigned int idx);
+ int nfp_eth_config_commit_end(struct nfp_nsp *nsp);
+ void nfp_eth_config_cleanup_end(struct nfp_nsp *nsp);
+ 
+ int __nfp_eth_set_aneg(struct nfp_nsp *nsp, enum nfp_eth_aneg mode);
+ int __nfp_eth_set_speed(struct nfp_nsp *nsp, unsigned int speed);
+ int __nfp_eth_set_split(struct nfp_nsp *nsp, unsigned int lanes);
++>>>>>>> b471232e2caa (nfp: add helpers for FEC support):drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp.h
  
  /**
   * struct nfp_nsp_identify - NSP static information
* Unmerged path drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.h
