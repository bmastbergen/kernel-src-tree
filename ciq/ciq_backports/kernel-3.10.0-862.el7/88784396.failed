mm: fix bad rss-counter if remap_file_pages raced migration

jira LE-1907
cve CVE-2017-5754
cve CVE-2017-5753
cve CVE-2017-5715
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [mm] fix bad rss-counter if remap_file_pages raced migration (Andrea Arcangeli) [1519801 1519798 1519786] {CVE-2017-5715 CVE-2017-5753 CVE-2017-5754}
Rebuild_FUZZ: 96.49%
commit-author Hugh Dickins <hughd@google.com>
commit 887843961c4b4681ee993c36d4997bf4b4aa8253
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/88784396.failed

Fix some "Bad rss-counter state" reports on exit, arising from the
interaction between page migration and remap_file_pages(): zap_pte()
must count a migration entry when zapping it.

And yes, it is possible (though very unusual) to find an anon page or
swap entry in a VM_SHARED nonlinear mapping: coming from that horrid
get_user_pages(write, force) case which COWs even in a shared mapping.

	Signed-off-by: Hugh Dickins <hughd@google.com>
	Tested-by: Sasha Levin sasha.levin@oracle.com>
	Tested-by: Dave Jones davej@redhat.com>
	Cc: Cyrill Gorcunov <gorcunov@gmail.com>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 887843961c4b4681ee993c36d4997bf4b4aa8253)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/fremap.c
diff --cc mm/fremap.c
index e4699e0d501b,34feba60a17e..000000000000
--- a/mm/fremap.c
+++ b/mm/fremap.c
@@@ -28,24 -32,35 +33,40 @@@ static void zap_pte(struct mm_struct *m
  			unsigned long addr, pte_t *ptep)
  {
  	pte_t pte = *ptep;
+ 	struct page *page;
+ 	swp_entry_t entry;
  
  	if (pte_present(pte)) {
- 		struct page *page;
- 
  		flush_cache_page(vma, addr, pte_pfn(pte));
 -		pte = ptep_clear_flush(vma, addr, ptep);
 +		pte = ptep_clear_flush_notify(vma, addr, ptep);
  		page = vm_normal_page(vma, addr, pte);
  		if (page) {
  			if (pte_dirty(pte))
  				set_page_dirty(page);
+ 			update_hiwater_rss(mm);
+ 			dec_mm_counter(mm, mm_counter(page));
  			page_remove_rmap(page);
  			page_cache_release(page);
++<<<<<<< HEAD
 +			update_hiwater_rss(mm);
 +			dec_mm_counter(mm, mm_counter_file(page));
++=======
++>>>>>>> 887843961c4b (mm: fix bad rss-counter if remap_file_pages raced migration)
+ 		}
+ 	} else {	/* zap_pte() is not called when pte_none() */
+ 		if (!pte_file(pte)) {
+ 			update_hiwater_rss(mm);
+ 			entry = pte_to_swp_entry(pte);
+ 			if (non_swap_entry(entry)) {
+ 				if (is_migration_entry(entry)) {
+ 					page = migration_entry_to_page(entry);
+ 					dec_mm_counter(mm, mm_counter(page));
+ 				}
+ 			} else {
+ 				free_swap_and_cache(entry);
+ 				dec_mm_counter(mm, MM_SWAPENTS);
+ 			}
  		}
- 	} else {
- 		if (!pte_file(pte))
- 			free_swap_and_cache(pte_to_swp_entry(pte));
  		pte_clear_not_present_full(mm, addr, ptep, 0);
  	}
  }
* Unmerged path mm/fremap.c
