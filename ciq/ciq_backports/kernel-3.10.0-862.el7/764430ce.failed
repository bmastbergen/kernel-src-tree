i40e/virtchnl: refactor code for validate checks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jesse Brandeburg <jesse.brandeburg@intel.com>
commit 764430ce6f8c38d7ed3b6d2cfe9450b9d3c78809
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/764430ce.failed

This change updates the arguments passed to the validate function
and fixes the caller, as well as uses the new return values added to
virtchnl.h

One other minor tweak, remove a duplicate set to zero of valid_len.

This is in preparation for moving the function to virtchnl.h.

	Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 764430ce6f8c38d7ed3b6d2cfe9450b9d3c78809)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
index c607db0defb5,61f948c587ad..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
@@@ -2444,35 -2550,31 +2445,40 @@@ i40e_vc_validate_vf_msg(struct virtchnl
  	bool err_msg_format = false;
  	int valid_len = 0;
  
 +	/* Check if VF is disabled. */
 +	if (test_bit(I40E_VF_STATE_DISABLED, &vf->vf_states))
 +		return I40E_ERR_PARAM;
 +
  	/* Validate message length. */
  	switch (v_opcode) {
 -	case VIRTCHNL_OP_VERSION:
 -		valid_len = sizeof(struct virtchnl_version_info);
 +	case I40E_VIRTCHNL_OP_VERSION:
 +		valid_len = sizeof(struct i40e_virtchnl_version_info);
  		break;
 -	case VIRTCHNL_OP_RESET_VF:
 +	case I40E_VIRTCHNL_OP_RESET_VF:
  		break;
++<<<<<<< HEAD
 +	case I40E_VIRTCHNL_OP_GET_VF_RESOURCES:
 +		if (VF_IS_V11(vf))
++=======
+ 	case VIRTCHNL_OP_GET_VF_RESOURCES:
+ 		if (VF_IS_V11(ver))
++>>>>>>> 764430ce6f8c (i40e/virtchnl: refactor code for validate checks)
  			valid_len = sizeof(u32);
  		break;
 -	case VIRTCHNL_OP_CONFIG_TX_QUEUE:
 -		valid_len = sizeof(struct virtchnl_txq_info);
 +	case I40E_VIRTCHNL_OP_CONFIG_TX_QUEUE:
 +		valid_len = sizeof(struct i40e_virtchnl_txq_info);
  		break;
 -	case VIRTCHNL_OP_CONFIG_RX_QUEUE:
 -		valid_len = sizeof(struct virtchnl_rxq_info);
 +	case I40E_VIRTCHNL_OP_CONFIG_RX_QUEUE:
 +		valid_len = sizeof(struct i40e_virtchnl_rxq_info);
  		break;
 -	case VIRTCHNL_OP_CONFIG_VSI_QUEUES:
 -		valid_len = sizeof(struct virtchnl_vsi_queue_config_info);
 +	case I40E_VIRTCHNL_OP_CONFIG_VSI_QUEUES:
 +		valid_len = sizeof(struct i40e_virtchnl_vsi_queue_config_info);
  		if (msglen >= valid_len) {
 -			struct virtchnl_vsi_queue_config_info *vqc =
 -			    (struct virtchnl_vsi_queue_config_info *)msg;
 +			struct i40e_virtchnl_vsi_queue_config_info *vqc =
 +			    (struct i40e_virtchnl_vsi_queue_config_info *)msg;
  			valid_len += (vqc->num_queue_pairs *
  				      sizeof(struct
 -					     virtchnl_queue_pair_info));
 +					     i40e_virtchnl_queue_pair_info));
  			if (vqc->num_queue_pairs == 0)
  				err_msg_format = true;
  		}
@@@ -2531,14 -2633,13 +2537,18 @@@
  		else
  			err_msg_format = true;
  		break;
++<<<<<<< HEAD
 +	case I40E_VIRTCHNL_OP_RELEASE_IWARP_IRQ_MAP:
 +		valid_len = 0;
++=======
+ 	case VIRTCHNL_OP_RELEASE_IWARP_IRQ_MAP:
++>>>>>>> 764430ce6f8c (i40e/virtchnl: refactor code for validate checks)
  		break;
 -	case VIRTCHNL_OP_CONFIG_IWARP_IRQ_MAP:
 -		valid_len = sizeof(struct virtchnl_iwarp_qvlist_info);
 +	case I40E_VIRTCHNL_OP_CONFIG_IWARP_IRQ_MAP:
 +		valid_len = sizeof(struct i40e_virtchnl_iwarp_qvlist_info);
  		if (msglen >= valid_len) {
 -			struct virtchnl_iwarp_qvlist_info *qv =
 -				(struct virtchnl_iwarp_qvlist_info *)msg;
 +			struct i40e_virtchnl_iwarp_qvlist_info *qv =
 +				(struct i40e_virtchnl_iwarp_qvlist_info *)msg;
  			if (qv->num_vectors == 0) {
  				err_msg_format = true;
  				break;
@@@ -2571,24 -2664,22 +2581,22 @@@
  			valid_len += vrl->lut_entries - 1;
  		}
  		break;
 -	case VIRTCHNL_OP_GET_RSS_HENA_CAPS:
 +	case I40E_VIRTCHNL_OP_GET_RSS_HENA_CAPS:
  		break;
 -	case VIRTCHNL_OP_SET_RSS_HENA:
 -		valid_len = sizeof(struct virtchnl_rss_hena);
 +	case I40E_VIRTCHNL_OP_SET_RSS_HENA:
 +		valid_len = sizeof(struct i40e_virtchnl_rss_hena);
  		break;
  	/* These are always errors coming from the VF. */
 -	case VIRTCHNL_OP_EVENT:
 -	case VIRTCHNL_OP_UNKNOWN:
 +	case I40E_VIRTCHNL_OP_EVENT:
 +	case I40E_VIRTCHNL_OP_UNKNOWN:
  	default:
- 		return -EPERM;
+ 		return VIRTCHNL_ERR_PARAM;
  	}
  	/* few more checks */
- 	if ((valid_len != msglen) || (err_msg_format)) {
- 		i40e_vc_send_resp_to_vf(vf, v_opcode, I40E_ERR_PARAM);
- 		return -EINVAL;
- 	} else {
- 		return 0;
- 	}
+ 	if ((valid_len != msglen) || (err_msg_format))
+ 		return VIRTCHNL_STATUS_ERR_OPCODE_MISMATCH;
+ 
+ 	return 0;
  }
  
  /**
@@@ -2614,13 -2705,37 +2622,19 @@@ int i40e_vc_process_vf_msg(struct i40e_
  	if (local_vf_id >= pf->num_alloc_vfs)
  		return -EINVAL;
  	vf = &(pf->vf[local_vf_id]);
 -
 -	/* Check if VF is disabled. */
 -	if (test_bit(I40E_VF_STATE_DISABLED, &vf->vf_states))
 -		return I40E_ERR_PARAM;
 -
  	/* perform basic checks on the msg */
- 	ret = i40e_vc_validate_vf_msg(vf, v_opcode, v_retval, msg, msglen);
+ 	ret = i40e_vc_validate_vf_msg(&vf->vf_ver, v_opcode, msg, msglen);
  
 -	/* perform additional checks specific to this driver */
 -	if (v_opcode == VIRTCHNL_OP_CONFIG_RSS_KEY) {
 -		struct virtchnl_rss_key *vrk = (struct virtchnl_rss_key *)msg;
 -
 -		if (vrk->key_len != I40E_HKEY_ARRAY_SIZE)
 -			ret = -EINVAL;
 -	} else if (v_opcode == VIRTCHNL_OP_CONFIG_RSS_LUT) {
 -		struct virtchnl_rss_lut *vrl = (struct virtchnl_rss_lut *)msg;
 -
 -		if (vrl->lut_entries != I40E_VF_HLUT_ARRAY_SIZE)
 -			ret = -EINVAL;
 -	}
 -
  	if (ret) {
+ 		i40e_vc_send_resp_to_vf(vf, v_opcode, I40E_ERR_PARAM);
  		dev_err(&pf->pdev->dev, "Invalid message from VF %d, opcode %d, len %d\n",
  			local_vf_id, v_opcode, msglen);
- 		return ret;
+ 		switch (ret) {
+ 		case VIRTCHNL_ERR_PARAM:
+ 			return -EPERM;
+ 		default:
+ 			return -EINVAL;
+ 		}
  	}
  
  	switch (v_opcode) {
diff --git a/drivers/net/ethernet/intel/i40e/i40e_virtchnl.h b/drivers/net/ethernet/intel/i40e/i40e_virtchnl.h
index 974ba2baf6ea..79f8c3b73b5a 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_virtchnl.h
+++ b/drivers/net/ethernet/intel/i40e/i40e_virtchnl.h
@@ -55,6 +55,23 @@
  * its queues, optionally add MAC and VLAN filters, and process traffic.
  */
 
+/* START GENERIC DEFINES
+ * Need to ensure the following enums and defines hold the same meaning and
+ * value in current and future projects
+ */
+
+/* Error Codes */
+enum virtchnl_status_code {
+	VIRTCHNL_STATUS_SUCCESS				= 0,
+	VIRTCHNL_ERR_PARAM				= -5,
+	VIRTCHNL_STATUS_ERR_OPCODE_MISMATCH		= -38,
+	VIRTCHNL_STATUS_ERR_CQP_COMPL_ERROR		= -39,
+	VIRTCHNL_STATUS_ERR_INVALID_VF_ID		= -40,
+	VIRTCHNL_STATUS_NOT_SUPPORTED			= -64,
+};
+
+/* END GENERIC DEFINES */
+
 /* Opcodes for VF-PF communication. These are placed in the v_opcode field
  * of the virtchnl_msg structure.
  */
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
