i2c: check for proper length of the reg property

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [i2c] check for proper length of the reg property (Gopal Tiwari) [1456705]
Rebuild_FUZZ: 94.51%
commit-author Wolfram Sang <wsa+renesas@sang-engineering.com>
commit 4c1344f105b626c222ea64669dc6dcfe100ccf3b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4c1344f1.failed

int is vague, let's simply use the type of the variable in question.

	Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
	Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
	Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
(cherry picked from commit 4c1344f105b626c222ea64669dc6dcfe100ccf3b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/i2c/i2c-core.c
diff --cc drivers/i2c/i2c-core.c
index 7113f77a4086,b8f11b82485c..000000000000
--- a/drivers/i2c/i2c-core.c
+++ b/drivers/i2c/i2c-core.c
@@@ -1076,9 -1254,55 +1076,59 @@@ static inline void acpi_i2c_register_de
  /* OF support code */
  
  #if IS_ENABLED(CONFIG_OF)
++<<<<<<< HEAD
++=======
+ static struct i2c_client *of_i2c_register_device(struct i2c_adapter *adap,
+ 						 struct device_node *node)
+ {
+ 	struct i2c_client *result;
+ 	struct i2c_board_info info = {};
+ 	struct dev_archdata dev_ad = {};
+ 	const __be32 *addr;
+ 	int len;
+ 
+ 	dev_dbg(&adap->dev, "of_i2c: register %s\n", node->full_name);
+ 
+ 	if (of_modalias_node(node, info.type, sizeof(info.type)) < 0) {
+ 		dev_err(&adap->dev, "of_i2c: modalias failure on %s\n",
+ 			node->full_name);
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 
+ 	addr = of_get_property(node, "reg", &len);
+ 	if (!addr || (len < sizeof(*addr))) {
+ 		dev_err(&adap->dev, "of_i2c: invalid reg on %s\n",
+ 			node->full_name);
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 
+ 	info.addr = be32_to_cpup(addr);
+ 	if (info.addr > (1 << 10) - 1) {
+ 		dev_err(&adap->dev, "of_i2c: invalid addr=%x on %s\n",
+ 			info.addr, node->full_name);
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 
+ 	info.of_node = of_node_get(node);
+ 	info.archdata = &dev_ad;
+ 
+ 	if (of_get_property(node, "wakeup-source", NULL))
+ 		info.flags |= I2C_CLIENT_WAKE;
+ 
+ 	result = i2c_new_device(adap, &info);
+ 	if (result == NULL) {
+ 		dev_err(&adap->dev, "of_i2c: Failure registering %s\n",
+ 			node->full_name);
+ 		of_node_put(node);
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 	return result;
+ }
+ 
++>>>>>>> 4c1344f105b6 (i2c: check for proper length of the reg property)
  static void of_i2c_register_devices(struct i2c_adapter *adap)
  {
 +	void *result;
  	struct device_node *node;
  
  	/* Only register child devices if the adapter has a node pointer set */
* Unmerged path drivers/i2c/i2c-core.c
