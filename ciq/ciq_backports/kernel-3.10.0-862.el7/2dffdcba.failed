s390/vmem: introduce and use SEGMENT_KERNEL and REGION3_KERNEL

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [s390] vmem: introduce and use SEGMENT_KERNEL and REGION3_KERNEL (Hendrik Brueckner) [1489742]
Rebuild_FUZZ: 95.80%
commit-author Heiko Carstens <heiko.carstens@de.ibm.com>
commit 2dffdcbac91c8da1eb0663d6eab92f2e5b56a798
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2dffdcba.failed

Instead of open-coded SEGMENT_KERNEL and REGION3_KERNEL assignments use
defines.  Also to make e.g. pmd_wrprotect() work on the kernel mapping
a couple more flags must be set. Therefore add the missing flags also.

In order to make everything symmetrical this patch also adds software
dirty, young, read and write bits for region 3 table entries.

	Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
	Acked-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 2dffdcbac91c8da1eb0663d6eab92f2e5b56a798)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/pgtable.h
#	arch/s390/mm/vmem.c
diff --cc arch/s390/include/asm/pgtable.h
index cff6ed1e6f32,898456957c44..000000000000
--- a/arch/s390/include/asm/pgtable.h
+++ b/arch/s390/include/asm/pgtable.h
@@@ -345,19 -270,23 +345,34 @@@ extern unsigned long MODULES_END
  #define _REGION3_ENTRY		(_REGION_ENTRY_TYPE_R3 | _REGION_ENTRY_LENGTH)
  #define _REGION3_ENTRY_EMPTY	(_REGION_ENTRY_TYPE_R3 | _REGION_ENTRY_INVALID)
  
++<<<<<<< HEAD
 +#define _REGION3_ENTRY_ORIGIN_LARGE ~0x7fffffffUL /* large page address>     */
 +#define _REGION3_ENTRY_ORIGIN  ~0x7ffUL/* region third table origin>	     */
 +
 +#define _REGION3_ENTRY_LARGE	0x400	/* RTTE-format control, large page  */
++=======
++>>>>>>> 2dffdcbac91c (s390/vmem: introduce and use SEGMENT_KERNEL and REGION3_KERNEL)
  #define _REGION3_ENTRY_RO	0x200	/* page protection bit		    */
 +#define _REGION3_ENTRY_CO	0x100	/* change-recording override	    */
 +
 +#define _REGION_ENTRY_BITS	0xfffffffffffff227UL
 +#define _REGION_ENTRY_BITS_LARGE 0xffffffff8000fe27UL
  
+ #define _REGION3_ENTRY_DIRTY	0x2000	/* SW region dirty bit */
+ #define _REGION3_ENTRY_YOUNG	0x1000	/* SW region young bit */
+ #define _REGION3_ENTRY_LARGE	0x0400	/* RTTE-format control, large page  */
+ #define _REGION3_ENTRY_READ	0x0002	/* SW region read bit */
+ #define _REGION3_ENTRY_WRITE	0x0001	/* SW region write bit */
+ 
+ #ifdef CONFIG_MEM_SOFT_DIRTY
+ #define _REGION3_ENTRY_SOFT_DIRTY 0x4000 /* SW region soft dirty bit */
+ #else
+ #define _REGION3_ENTRY_SOFT_DIRTY 0x0000 /* SW region soft dirty bit */
+ #endif
+ 
  /* Bits in the segment table entry */
  #define _SEGMENT_ENTRY_BITS	0xfffffffffffffe33UL
 -#define _SEGMENT_ENTRY_BITS_LARGE 0xfffffffffff0ff33UL
 +#define _SEGMENT_ENTRY_BITS_LARGE 0xfffffffffff1ff33UL
  #define _SEGMENT_ENTRY_ORIGIN_LARGE ~0xfffffUL /* large page address	    */
  #define _SEGMENT_ENTRY_ORIGIN	~0x7ffUL/* segment table origin		    */
  #define _SEGMENT_ENTRY_PROTECT	0x200	/* page protection bit		    */
@@@ -366,31 -295,40 +381,49 @@@
  #define _SEGMENT_ENTRY		(0)
  #define _SEGMENT_ENTRY_EMPTY	(_SEGMENT_ENTRY_INVALID)
  
 -#define _SEGMENT_ENTRY_DIRTY	0x2000	/* SW segment dirty bit */
 -#define _SEGMENT_ENTRY_YOUNG	0x1000	/* SW segment young bit */
 -#define _SEGMENT_ENTRY_LARGE	0x0400	/* STE-format control, large page */
 -#define _SEGMENT_ENTRY_READ	0x0002	/* SW segment read bit */
 -#define _SEGMENT_ENTRY_WRITE	0x0001	/* SW segment write bit */
 -
 -#ifdef CONFIG_MEM_SOFT_DIRTY
 -#define _SEGMENT_ENTRY_SOFT_DIRTY 0x4000 /* SW segment soft dirty bit */
 -#else
 -#define _SEGMENT_ENTRY_SOFT_DIRTY 0x0000 /* SW segment soft dirty bit */
 -#endif
 +#define _SEGMENT_ENTRY_LARGE	0x400	/* STE-format control, large page   */
 +#define _SEGMENT_ENTRY_CO	0x100	/* change-recording override   */
 +#define _SEGMENT_ENTRY_SPLIT	0x001	/* THP splitting bit */
 +#define _SEGMENT_ENTRY_YOUNG	0x002	/* SW segment young bit */
 +#define _SEGMENT_ENTRY_NONE	_SEGMENT_ENTRY_YOUNG
  
  /*
++<<<<<<< HEAD
 + * Segment table entry encoding (R = read-only, I = invalid, y = young bit):
 + *			..R...I...y.
 + * prot-none, old	..0...1...1.
 + * prot-none, young	..1...1...1.
 + * read-only, old	..1...1...0.
 + * read-only, young	..1...0...1.
 + * read-write, old	..0...1...0.
 + * read-write, young	..0...0...1.
++=======
+  * Segment table and region3 table entry encoding
+  * (R = read-only, I = invalid, y = young bit):
+  *				dy..R...I...rw
+  * prot-none, clean, old	00..1...1...00
+  * prot-none, clean, young	01..1...1...00
+  * prot-none, dirty, old	10..1...1...00
+  * prot-none, dirty, young	11..1...1...00
+  * read-only, clean, old	00..1...1...10
+  * read-only, clean, young	01..1...0...10
+  * read-only, dirty, old	10..1...1...10
+  * read-only, dirty, young	11..1...0...10
+  * read-write, clean, old	00..1...1...11
+  * read-write, clean, young	01..1...0...11
+  * read-write, dirty, old	10..0...1...11
+  * read-write, dirty, young	11..0...0...11
++>>>>>>> 2dffdcbac91c (s390/vmem: introduce and use SEGMENT_KERNEL and REGION3_KERNEL)
   * The segment table origin is used to distinguish empty (origin==0) from
   * read-write, old segment table entries (origin!=0)
 - * HW-bits: R read-only, I invalid
 - * SW-bits: y young, d dirty, r read, w write
   */
  
 +#define _SEGMENT_ENTRY_SPLIT_BIT 0	/* THP splitting bit number */
 +
 +/* Set of bits not changed in pmd_modify */
 +#define _SEGMENT_CHG_MASK	(_SEGMENT_ENTRY_ORIGIN | _SEGMENT_ENTRY_LARGE \
 +				 | _SEGMENT_ENTRY_SPLIT | _SEGMENT_ENTRY_CO)
 +
  /* Page status table bits for virtualization */
  #define PGSTE_ACC_BITS	0xf000000000000000UL
  #define PGSTE_FP_BIT	0x0800000000000000UL
@@@ -455,16 -398,38 +488,50 @@@
   * Segment entry (large page) protection definitions.
   */
  #define SEGMENT_NONE	__pgprot(_SEGMENT_ENTRY_INVALID | \
 +				 _SEGMENT_ENTRY_NONE)
 +#define SEGMENT_READ	__pgprot(_SEGMENT_ENTRY_INVALID | \
  				 _SEGMENT_ENTRY_PROTECT)
++<<<<<<< HEAD
 +#define SEGMENT_WRITE	__pgprot(_SEGMENT_ENTRY_INVALID)
 +
 +static inline int mm_exclusive(struct mm_struct *mm)
 +{
 +	return likely(mm == current->active_mm &&
 +		      atomic_read(&mm->context.attach_count) <= 1);
 +}
++=======
+ #define SEGMENT_READ	__pgprot(_SEGMENT_ENTRY_PROTECT | \
+ 				 _SEGMENT_ENTRY_READ)
+ #define SEGMENT_WRITE	__pgprot(_SEGMENT_ENTRY_READ | \
+ 				 _SEGMENT_ENTRY_WRITE)
+ #define SEGMENT_KERNEL	__pgprot(_SEGMENT_ENTRY |	\
+ 				 _SEGMENT_ENTRY_LARGE |	\
+ 				 _SEGMENT_ENTRY_READ |	\
+ 				 _SEGMENT_ENTRY_WRITE | \
+ 				 _SEGMENT_ENTRY_YOUNG | \
+ 				 _SEGMENT_ENTRY_DIRTY)
+ #define SEGMENT_KERNEL_RO __pgprot(_SEGMENT_ENTRY |	\
+ 				 _SEGMENT_ENTRY_LARGE |	\
+ 				 _SEGMENT_ENTRY_READ |	\
+ 				 _SEGMENT_ENTRY_YOUNG |	\
+ 				 _SEGMENT_ENTRY_PROTECT)
+ 
+ /*
+  * Region3 entry (large page) protection definitions.
+  */
+ 
+ #define REGION3_KERNEL	__pgprot(_REGION_ENTRY_TYPE_R3 | \
+ 				 _REGION3_ENTRY_LARGE |	 \
+ 				 _REGION3_ENTRY_READ |	 \
+ 				 _REGION3_ENTRY_WRITE |	 \
+ 				 _REGION3_ENTRY_YOUNG |	 \
+ 				 _REGION3_ENTRY_DIRTY)
+ #define REGION3_KERNEL_RO __pgprot(_REGION_ENTRY_TYPE_R3 | \
+ 				   _REGION3_ENTRY_LARGE |  \
+ 				   _REGION3_ENTRY_READ |   \
+ 				   _REGION3_ENTRY_YOUNG |  \
+ 				   _REGION_ENTRY_PROTECT)
++>>>>>>> 2dffdcbac91c (s390/vmem: introduce and use SEGMENT_KERNEL and REGION3_KERNEL)
  
  static inline int mm_has_pgste(struct mm_struct *mm)
  {
diff --cc arch/s390/mm/vmem.c
index c109b6bb46f8,2020ef8c0413..000000000000
--- a/arch/s390/mm/vmem.c
+++ b/arch/s390/mm/vmem.c
@@@ -98,12 -96,11 +98,19 @@@ static int vmem_add_mem(unsigned long s
  			pgd_populate(&init_mm, pg_dir, pu_dir);
  		}
  		pu_dir = pud_offset(pg_dir, address);
 +#if defined(CONFIG_64BIT) && !defined(CONFIG_DEBUG_PAGEALLOC)
  		if (MACHINE_HAS_EDAT2 && pud_none(*pu_dir) && address &&
++<<<<<<< HEAD
 +		    !(address & ~PUD_MASK) && (address + PUD_SIZE <= end)) {
 +			pud_val(*pu_dir) = __pa(address) |
 +				_REGION_ENTRY_TYPE_R3 | _REGION3_ENTRY_LARGE |
 +				(ro ? _REGION_ENTRY_PROTECT : 0);
++=======
+ 		    !(address & ~PUD_MASK) && (address + PUD_SIZE <= end) &&
+ 		     !debug_pagealloc_enabled()) {
+ 			pud_val(*pu_dir) = address |
+ 				pgprot_val(ro ? REGION3_KERNEL_RO : REGION3_KERNEL);
++>>>>>>> 2dffdcbac91c (s390/vmem: introduce and use SEGMENT_KERNEL and REGION3_KERNEL)
  			address += PUD_SIZE;
  			continue;
  		}
@@@ -115,13 -111,11 +122,20 @@@
  			pud_populate(&init_mm, pu_dir, pm_dir);
  		}
  		pm_dir = pmd_offset(pu_dir, address);
 +#if defined(CONFIG_64BIT) && !defined(CONFIG_DEBUG_PAGEALLOC)
  		if (MACHINE_HAS_EDAT1 && pmd_none(*pm_dir) && address &&
++<<<<<<< HEAD
 +		    !(address & ~PMD_MASK) && (address + PMD_SIZE <= end)) {
 +			pmd_val(*pm_dir) = __pa(address) |
 +				_SEGMENT_ENTRY | _SEGMENT_ENTRY_LARGE |
 +				_SEGMENT_ENTRY_YOUNG |
 +				(ro ? _SEGMENT_ENTRY_PROTECT : 0);
++=======
+ 		    !(address & ~PMD_MASK) && (address + PMD_SIZE <= end) &&
+ 		    !debug_pagealloc_enabled()) {
+ 			pmd_val(*pm_dir) = address |
+ 				pgprot_val(ro ? SEGMENT_KERNEL_RO : SEGMENT_KERNEL);
++>>>>>>> 2dffdcbac91c (s390/vmem: introduce and use SEGMENT_KERNEL and REGION3_KERNEL)
  			address += PMD_SIZE;
  			continue;
  		}
* Unmerged path arch/s390/include/asm/pgtable.h
* Unmerged path arch/s390/mm/vmem.c
