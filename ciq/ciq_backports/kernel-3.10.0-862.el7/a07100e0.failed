qla2xxx: Fix TMR ABORT interaction issue between qla2xxx and TCM

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Quinn Tran <quinn.tran@qlogic.com>
commit a07100e00ac42a4474530ce17b4978c9e06bde55
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a07100e0.failed

During lun reset, TMR thread from TCM would issue abort
to qla driver.  At abort time, each command is in different
state.  Depending on the state, qla will use the TMR thread
to trigger a command free(cmd_kref--) if command is not
down at firmware.

	Signed-off-by: Quinn Tran <quinn.tran@qlogic.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@qlogic.com>
	Cc: stable@vger.kernel.org # 3.10+
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit a07100e00ac42a4474530ce17b4978c9e06bde55)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_target.c
#	drivers/scsi/qla2xxx/qla_target.h
#	drivers/scsi/qla2xxx/tcm_qla2xxx.c
diff --cc drivers/scsi/qla2xxx/qla_target.c
index 45ccae5ec6af,74eb776d2faa..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -98,9 -105,21 +98,9 @@@ static void qlt_response_pkt(struct scs
  static int qlt_issue_task_mgmt(struct qla_tgt_sess *sess, uint32_t lun,
  	int fn, void *iocb, int flags);
  static void qlt_send_term_exchange(struct scsi_qla_host *ha, struct qla_tgt_cmd
- 	*cmd, struct atio_from_isp *atio, int ha_locked);
+ 	*cmd, struct atio_from_isp *atio, int ha_locked, int ul_abort);
  static void qlt_reject_free_srr_imm(struct scsi_qla_host *ha,
  	struct qla_tgt_srr_imm *imm, int ha_lock);
 -static void qlt_abort_cmd_on_host_reset(struct scsi_qla_host *vha,
 -	struct qla_tgt_cmd *cmd);
 -static void qlt_alloc_qfull_cmd(struct scsi_qla_host *vha,
 -	struct atio_from_isp *atio, uint16_t status, int qfull);
 -static void qlt_disable_vha(struct scsi_qla_host *vha);
 -static void qlt_clear_tgt_db(struct qla_tgt *tgt);
 -static void qlt_send_notify_ack(struct scsi_qla_host *vha,
 -	struct imm_ntfy_from_isp *ntfy,
 -	uint32_t add_flags, uint16_t resp_code, int resp_code_valid,
 -	uint16_t srr_flags, uint16_t srr_reject_code, uint8_t srr_explan);
 -static void qlt_send_term_imm_notif(struct scsi_qla_host *vha,
 -	struct imm_ntfy_from_isp *imm, int ha_locked);
  /*
   * Global Variables
   */
@@@ -2027,6 -2658,19 +2027,22 @@@ int qlt_xmit_response(struct qla_tgt_cm
  	unsigned long flags = 0;
  	int res;
  
++<<<<<<< HEAD
++=======
+ 	spin_lock_irqsave(&ha->hardware_lock, flags);
+ 	if (cmd->sess && cmd->sess->deleted == QLA_SESS_DELETION_IN_PROGRESS) {
+ 		cmd->state = QLA_TGT_STATE_PROCESSED;
+ 		if (cmd->sess->logout_completed)
+ 			/* no need to terminate. FW already freed exchange. */
+ 			qlt_abort_cmd_on_host_reset(cmd->vha, cmd);
+ 		else
+ 			qlt_send_term_exchange(vha, cmd, &cmd->atio, 1, 0);
+ 		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+ 		return 0;
+ 	}
+ 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+ 
++>>>>>>> a07100e00ac4 (qla2xxx: Fix TMR ABORT interaction issue between qla2xxx and TCM)
  	memset(&prm, 0, sizeof(prm));
  	qlt_check_srr_debug(cmd, &xmit_type);
  
@@@ -2256,9 -3173,10 +2272,10 @@@ static int __qlt_send_term_exchange(str
  }
  
  static void qlt_send_term_exchange(struct scsi_qla_host *vha,
- 	struct qla_tgt_cmd *cmd, struct atio_from_isp *atio, int ha_locked)
+ 	struct qla_tgt_cmd *cmd, struct atio_from_isp *atio, int ha_locked,
+ 	int ul_abort)
  {
 -	unsigned long flags = 0;
 +	unsigned long flags;
  	int rc;
  
  	if (qlt_issue_marker(vha, ha_locked) < 0)
@@@ -2270,35 -3190,132 +2287,143 @@@
  	}
  	spin_lock_irqsave(&vha->hw->hardware_lock, flags);
  	rc = __qlt_send_term_exchange(vha, cmd, atio);
 -	if (rc == -ENOMEM)
 -		qlt_alloc_qfull_cmd(vha, atio, 0, 0);
 -
 +	spin_unlock_irqrestore(&vha->hw->hardware_lock, flags);
  done:
++<<<<<<< HEAD
 +	/*
 +	 * Terminate exchange will tell fw to release any active CTIO
 +	 * that's in FW posession and cleanup the exchange.
 +	 *
 +	 * "cmd->state == QLA_TGT_STATE_ABORTED" means CTIO is still
 +	 * down at FW.  Free the cmd later when CTIO comes back later
 +	 * w/aborted(0x2) status.
 +	 *
 +	 * "cmd->state != QLA_TGT_STATE_ABORTED" means CTIO is already
 +	 * back w/some err.  Free the cmd now.
 +	 */
 +	if ((rc == 1) && (cmd->state != QLA_TGT_STATE_ABORTED)) {
 +		if (!ha_locked && !in_interrupt())
 +			msleep(250); /* just in case */
 +
++=======
+ 	if (cmd && !ul_abort && !cmd->aborted) {
+ 		if (cmd->sg_mapped)
+ 			qlt_unmap_sg(vha, cmd);
++>>>>>>> a07100e00ac4 (qla2xxx: Fix TMR ABORT interaction issue between qla2xxx and TCM)
  		vha->hw->tgt.tgt_ops->free_cmd(cmd);
  	}
 -
 -	if (!ha_locked)
 -		spin_unlock_irqrestore(&vha->hw->hardware_lock, flags);
 -
  	return;
  }
  
++<<<<<<< HEAD
++void qlt_free_cmd(struct qla_tgt_cmd *cmd)
++{
++=======
+ static void qlt_init_term_exchange(struct scsi_qla_host *vha)
+ {
+ 	struct list_head free_list;
+ 	struct qla_tgt_cmd *cmd, *tcmd;
+ 
+ 	vha->hw->tgt.leak_exchg_thresh_hold =
+ 	    (vha->hw->cur_fw_xcb_count/100) * LEAK_EXCHG_THRESH_HOLD_PERCENT;
+ 
+ 	cmd = tcmd = NULL;
+ 	if (!list_empty(&vha->hw->tgt.q_full_list)) {
+ 		INIT_LIST_HEAD(&free_list);
+ 		list_splice_init(&vha->hw->tgt.q_full_list, &free_list);
+ 
+ 		list_for_each_entry_safe(cmd, tcmd, &free_list, cmd_list) {
+ 			list_del(&cmd->cmd_list);
+ 			/* This cmd was never sent to TCM.  There is no need
+ 			 * to schedule free or call free_cmd
+ 			 */
+ 			qlt_free_cmd(cmd);
+ 			vha->hw->tgt.num_qfull_cmds_alloc--;
+ 		}
+ 	}
+ 	vha->hw->tgt.num_qfull_cmds_dropped = 0;
+ }
+ 
+ static void qlt_chk_exch_leak_thresh_hold(struct scsi_qla_host *vha)
+ {
+ 	uint32_t total_leaked;
+ 
+ 	total_leaked = vha->hw->tgt.num_qfull_cmds_dropped;
+ 
+ 	if (vha->hw->tgt.leak_exchg_thresh_hold &&
+ 	    (total_leaked > vha->hw->tgt.leak_exchg_thresh_hold)) {
+ 
+ 		ql_dbg(ql_dbg_tgt, vha, 0xe079,
+ 		    "Chip reset due to exchange starvation: %d/%d.\n",
+ 		    total_leaked, vha->hw->cur_fw_xcb_count);
+ 
+ 		if (IS_P3P_TYPE(vha->hw))
+ 			set_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags);
+ 		else
+ 			set_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);
+ 		qla2xxx_wake_dpc(vha);
+ 	}
+ 
+ }
+ 
+ int qlt_abort_cmd(struct qla_tgt_cmd *cmd)
+ {
+ 	struct qla_tgt *tgt = cmd->tgt;
+ 	struct scsi_qla_host *vha = tgt->vha;
+ 	struct se_cmd *se_cmd = &cmd->se_cmd;
+ 	unsigned long flags;
+ 
+ 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf014,
+ 	    "qla_target(%d): terminating exchange for aborted cmd=%p "
+ 	    "(se_cmd=%p, tag=%llu)", vha->vp_idx, cmd, &cmd->se_cmd,
+ 	    se_cmd->tag);
+ 
+ 	spin_lock_irqsave(&cmd->cmd_lock, flags);
+ 	if (cmd->aborted) {
+ 		spin_unlock_irqrestore(&cmd->cmd_lock, flags);
+ 		/*
+ 		 * It's normal to see 2 calls in this path:
+ 		 *  1) XFER Rdy completion + CMD_T_ABORT
+ 		 *  2) TCM TMR - drain_state_list
+ 		 */
+ 	        ql_dbg(ql_dbg_tgt_mgt, vha, 0xffff,
+ 			"multiple abort. %p transport_state %x, t_state %x,"
+ 			" se_cmd_flags %x \n", cmd, cmd->se_cmd.transport_state,
+ 			cmd->se_cmd.t_state,cmd->se_cmd.se_cmd_flags);
+ 		return EIO;
+ 	}
+ 	cmd->aborted = 1;
+ 	cmd->cmd_flags |= BIT_6;
+ 	spin_unlock_irqrestore(&cmd->cmd_lock, flags);
+ 
+ 	qlt_send_term_exchange(vha, cmd, &cmd->atio, 0, 1);
+ 	return 0;
+ }
+ EXPORT_SYMBOL(qlt_abort_cmd);
+ 
  void qlt_free_cmd(struct qla_tgt_cmd *cmd)
  {
+ 	struct qla_tgt_sess *sess = cmd->sess;
+ 
+ 	ql_dbg(ql_dbg_tgt, cmd->vha, 0xe074,
+ 	    "%s: se_cmd[%p] ox_id %04x\n",
+ 	    __func__, &cmd->se_cmd,
+ 	    be16_to_cpu(cmd->atio.u.isp24.fcp_hdr.ox_id));
+ 
+ 	BUG_ON(cmd->cmd_in_wq);
+ 
+ 	if (cmd->sg_mapped)
+ 		qlt_unmap_sg(cmd->vha, cmd);
+ 
+ 	if (!cmd->q_full)
+ 		qlt_decr_num_pend_cmds(cmd->vha);
+ 
++>>>>>>> a07100e00ac4 (qla2xxx: Fix TMR ABORT interaction issue between qla2xxx and TCM)
  	BUG_ON(cmd->sg_mapped);
 -	cmd->jiffies_at_free = get_jiffies_64();
 +
  	if (unlikely(cmd->free_sg))
  		kfree(cmd->sg);
 -
 -	if (!sess || !sess->se_sess) {
 -		WARN_ON(1);
 -		return;
 -	}
 -	cmd->jiffies_at_free = get_jiffies_64();
 -	percpu_ida_free(&sess->se_sess->sess_tag_pool, cmd->se_cmd.map_tag);
 +	kmem_cache_free(qla_tgt_cmd_cachep, cmd);
  }
  EXPORT_SYMBOL(qlt_free_cmd);
  
@@@ -2638,43 -3766,18 +2763,47 @@@ static void qlt_do_work(struct work_str
  	if (tgt->tgt_stop)
  		goto out_term;
  
 -	if (cmd->aborted) {
 -		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf082,
 -		    "cmd with tag %u is aborted\n",
 -		    cmd->atio.u.isp24.exchange_addr);
 -		goto out_term;
 +	spin_lock_irqsave(&ha->hardware_lock, flags);
 +	sess = ha->tgt.tgt_ops->find_sess_by_s_id(vha,
 +	    atio->u.isp24.fcp_hdr.s_id);
 +	/* Do kref_get() before dropping qla_hw_data->hardware_lock. */
 +	if (sess)
 +		kref_get(&sess->se_sess->sess_kref);
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +
 +	if (unlikely(!sess)) {
 +		uint8_t *s_id =	atio->u.isp24.fcp_hdr.s_id;
 +
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf022,
 +			"qla_target(%d): Unable to find wwn login"
 +			" (s_id %x:%x:%x), trying to create it manually\n",
 +			vha->vp_idx, s_id[0], s_id[1], s_id[2]);
 +
 +		if (atio->u.raw.entry_count > 1) {
 +			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf023,
 +				"Dropping multy entry cmd %p\n", cmd);
 +			goto out_term;
 +		}
 +
 +		mutex_lock(&ha->tgt.tgt_mutex);
 +		sess = qlt_make_local_sess(vha, s_id);
 +		/* sess has an extra creation ref. */
 +		mutex_unlock(&ha->tgt.tgt_mutex);
 +
 +		if (!sess)
 +			goto out_term;
  	}
  
++<<<<<<< HEAD
 +	cmd->sess = sess;
 +	cmd->loop_id = sess->loop_id;
 +	cmd->conf_compl_supported = sess->conf_compl_supported;
 +
++=======
+ 	spin_lock_init(&cmd->cmd_lock);
++>>>>>>> a07100e00ac4 (qla2xxx: Fix TMR ABORT interaction issue between qla2xxx and TCM)
  	cdb = &atio->u.isp24.fcp_cmnd.cdb[0];
 -	cmd->se_cmd.tag = atio->u.isp24.exchange_addr;
 +	cmd->tag = atio->u.isp24.exchange_addr;
  	cmd->unpacked_lun = scsilun_to_int(
  	    (struct scsi_lun *)&atio->u.isp24.fcp_cmnd.lun);
  
@@@ -2715,12 -3816,134 +2844,40 @@@ out_term
  	 * cmd has not sent to target yet, so pass NULL as the second
  	 * argument to qlt_send_term_exchange() and free the memory here.
  	 */
 -	cmd->cmd_flags |= BIT_2;
  	spin_lock_irqsave(&ha->hardware_lock, flags);
++<<<<<<< HEAD
 +	qlt_send_term_exchange(vha, NULL, &cmd->atio, 1);
 +	kmem_cache_free(qla_tgt_cmd_cachep, cmd);
++=======
+ 	qlt_send_term_exchange(vha, NULL, &cmd->atio, 1, 0);
+ 
+ 	qlt_decr_num_pend_cmds(vha);
+ 	percpu_ida_free(&sess->se_sess->sess_tag_pool, cmd->se_cmd.map_tag);
++>>>>>>> a07100e00ac4 (qla2xxx: Fix TMR ABORT interaction issue between qla2xxx and TCM)
  	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 -
 -	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
 -	ha->tgt.tgt_ops->put_sess(sess);
 -	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
 -}
 -
 -static void qlt_do_work(struct work_struct *work)
 -{
 -	struct qla_tgt_cmd *cmd = container_of(work, struct qla_tgt_cmd, work);
 -	scsi_qla_host_t *vha = cmd->vha;
 -	unsigned long flags;
 -
 -	spin_lock_irqsave(&vha->cmd_list_lock, flags);
 -	list_del(&cmd->cmd_list);
 -	spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
 -
 -	__qlt_do_work(cmd);
 -}
 -
 -static struct qla_tgt_cmd *qlt_get_tag(scsi_qla_host_t *vha,
 -				       struct qla_tgt_sess *sess,
 -				       struct atio_from_isp *atio)
 -{
 -	struct se_session *se_sess = sess->se_sess;
 -	struct qla_tgt_cmd *cmd;
 -	int tag;
 -
 -	tag = percpu_ida_alloc(&se_sess->sess_tag_pool, TASK_RUNNING);
 -	if (tag < 0)
 -		return NULL;
 -
 -	cmd = &((struct qla_tgt_cmd *)se_sess->sess_cmd_map)[tag];
 -	memset(cmd, 0, sizeof(struct qla_tgt_cmd));
 -
 -	memcpy(&cmd->atio, atio, sizeof(*atio));
 -	cmd->state = QLA_TGT_STATE_NEW;
 -	cmd->tgt = vha->vha_tgt.qla_tgt;
 -	qlt_incr_num_pend_cmds(vha);
 -	cmd->vha = vha;
 -	cmd->se_cmd.map_tag = tag;
 -	cmd->sess = sess;
 -	cmd->loop_id = sess->loop_id;
 -	cmd->conf_compl_supported = sess->conf_compl_supported;
 -
 -	cmd->cmd_flags = 0;
 -	cmd->jiffies_at_alloc = get_jiffies_64();
 -
 -	cmd->reset_count = vha->hw->chip_reset;
 -
 -	return cmd;
 -}
 -
 -static void qlt_send_busy(struct scsi_qla_host *, struct atio_from_isp *,
 -			  uint16_t);
 -
 -static void qlt_create_sess_from_atio(struct work_struct *work)
 -{
 -	struct qla_tgt_sess_op *op = container_of(work,
 -					struct qla_tgt_sess_op, work);
 -	scsi_qla_host_t *vha = op->vha;
 -	struct qla_hw_data *ha = vha->hw;
 -	struct qla_tgt_sess *sess;
 -	struct qla_tgt_cmd *cmd;
 -	unsigned long flags;
 -	uint8_t *s_id = op->atio.u.isp24.fcp_hdr.s_id;
 -
 -	spin_lock_irqsave(&vha->cmd_list_lock, flags);
 -	list_del(&op->cmd_list);
 -	spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
 -
 -	if (op->aborted) {
 -		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf083,
 -		    "sess_op with tag %u is aborted\n",
 -		    op->atio.u.isp24.exchange_addr);
 -		goto out_term;
 -	}
 -
 -	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf022,
 -	    "qla_target(%d): Unable to find wwn login"
 -	    " (s_id %x:%x:%x), trying to create it manually\n",
 -	    vha->vp_idx, s_id[0], s_id[1], s_id[2]);
 -
 -	if (op->atio.u.raw.entry_count > 1) {
 -		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf023,
 -		    "Dropping multy entry atio %p\n", &op->atio);
 -		goto out_term;
 -	}
 -
 -	sess = qlt_make_local_sess(vha, s_id);
 -	/* sess has an extra creation ref. */
 -
 -	if (!sess)
 -		goto out_term;
 -	/*
 -	 * Now obtain a pre-allocated session tag using the original op->atio
 -	 * packet header, and dispatch into __qlt_do_work() using the existing
 -	 * process context.
 -	 */
 -	cmd = qlt_get_tag(vha, sess, &op->atio);
 -	if (!cmd) {
 -		spin_lock_irqsave(&ha->hardware_lock, flags);
 -		qlt_send_busy(vha, &op->atio, SAM_STAT_BUSY);
 +	if (sess)
  		ha->tgt.tgt_ops->put_sess(sess);
++<<<<<<< HEAD
++=======
+ 		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+ 		kfree(op);
+ 		return;
+ 	}
+ 	/*
+ 	 * __qlt_do_work() will call ha->tgt.tgt_ops->put_sess() to release
+ 	 * the extra reference taken above by qlt_make_local_sess()
+ 	 */
+ 	__qlt_do_work(cmd);
+ 	kfree(op);
+ 	return;
+ 
+ out_term:
+ 	spin_lock_irqsave(&ha->hardware_lock, flags);
+ 	qlt_send_term_exchange(vha, NULL, &op->atio, 1, 0);
+ 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+ 	kfree(op);
+ 
++>>>>>>> a07100e00ac4 (qla2xxx: Fix TMR ABORT interaction issue between qla2xxx and TCM)
  }
  
  /* ha->hardware_lock supposed to be held on entry */
@@@ -3246,8 -4791,10 +3403,15 @@@ out_reject
  	if (cmd->state == QLA_TGT_STATE_NEED_DATA) {
  		cmd->state = QLA_TGT_STATE_DATA_IN;
  		dump_stack();
++<<<<<<< HEAD
 +	} else
 +		qlt_send_term_exchange(vha, cmd, &cmd->atio, 1);
++=======
+ 	} else {
+ 		cmd->cmd_flags |= BIT_9;
+ 		qlt_send_term_exchange(vha, cmd, &cmd->atio, 1, 0);
+ 	}
++>>>>>>> a07100e00ac4 (qla2xxx: Fix TMR ABORT interaction issue between qla2xxx and TCM)
  	spin_unlock_irqrestore(&ha->hardware_lock, flags);
  }
  
@@@ -3593,12 -5138,15 +3757,17 @@@ static void qlt_send_busy(struct scsi_q
  	struct qla_hw_data *ha = vha->hw;
  	request_t *pkt;
  	struct qla_tgt_sess *sess = NULL;
 -	unsigned long flags;
  
 -	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
  	sess = ha->tgt.tgt_ops->find_sess_by_s_id(vha,
  	    atio->u.isp24.fcp_hdr.s_id);
 -	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
  	if (!sess) {
++<<<<<<< HEAD
 +		qlt_send_term_exchange(vha, NULL, atio, 1);
 +		return;
++=======
+ 		qlt_send_term_exchange(vha, NULL, atio, 1, 0);
+ 		return 0;
++>>>>>>> a07100e00ac4 (qla2xxx: Fix TMR ABORT interaction issue between qla2xxx and TCM)
  	}
  	/* Sending marker isn't necessary, since we called from ISR */
  
@@@ -3696,8 -5424,17 +3865,8 @@@ static void qlt_24xx_atio_pkt(struct sc
  #if 1 /* With TERM EXCHANGE some FC cards refuse to boot */
  				qlt_send_busy(vha, atio, SAM_STAT_BUSY);
  #else
- 				qlt_send_term_exchange(vha, NULL, atio, 1);
+ 				qlt_send_term_exchange(vha, NULL, atio, 1, 0);
  #endif
 -
 -				if (!ha_locked)
 -					spin_unlock_irqrestore
 -						(&ha->hardware_lock, flags);
 -
  			} else {
  				if (tgt->tgt_stop) {
  					ql_dbg(ql_dbg_tgt, vha, 0xe059,
@@@ -4232,10 -5981,11 +4401,14 @@@ static void qlt_tmr_work(struct qla_tg
  	return;
  
  out_term:
++<<<<<<< HEAD
 +	qlt_send_term_exchange(vha, NULL, &prm->tm_iocb2, 1);
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
++=======
+ 	qlt_send_term_exchange(vha, NULL, &prm->tm_iocb2, 1, 0);
++>>>>>>> a07100e00ac4 (qla2xxx: Fix TMR ABORT interaction issue between qla2xxx and TCM)
  	if (sess)
  		ha->tgt.tgt_ops->put_sess(sess);
 -	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
  }
  
  static void qlt_sess_work_fn(struct work_struct *work)
diff --cc drivers/scsi/qla2xxx/qla_target.h
index b33e411f28a0,22a6a767fe07..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.h
+++ b/drivers/scsi/qla2xxx/qla_target.h
@@@ -826,12 -939,44 +826,42 @@@ struct qla_tgt_sess 
  
  	uint8_t port_name[WWN_SIZE];
  	struct work_struct free_work;
 -
 -	qlt_plogi_ack_t *plogi_link[QLT_PLOGI_LINK_MAX];
  };
  
+ typedef enum {
+ 	/*
+ 	 * BIT_0 - Atio Arrival / schedule to work
+ 	 * BIT_1 - qlt_do_work
+ 	 * BIT_2 - qlt_do work failed
+ 	 * BIT_3 - xfer rdy/tcm_qla2xxx_write_pending
+ 	 * BIT_4 - read respond/tcm_qla2xx_queue_data_in
+ 	 * BIT_5 - status respond / tcm_qla2xx_queue_status
+ 	 * BIT_6 - tcm request to abort/Term exchange.
+ 	 *	pre_xmit_response->qlt_send_term_exchange
+ 	 * BIT_7 - SRR received (qlt_handle_srr->qlt_xmit_response)
+ 	 * BIT_8 - SRR received (qlt_handle_srr->qlt_rdy_to_xfer)
+ 	 * BIT_9 - SRR received (qla_handle_srr->qlt_send_term_exchange)
+ 	 * BIT_10 - Data in - hanlde_data->tcm_qla2xxx_handle_data
+ 
+ 	 * BIT_12 - good completion - qlt_ctio_do_completion -->free_cmd
+ 	 * BIT_13 - Bad completion -
+ 	 *	qlt_ctio_do_completion --> qlt_term_ctio_exchange
+ 	 * BIT_14 - Back end data received/sent.
+ 	 * BIT_15 - SRR prepare ctio
+ 	 * BIT_16 - complete free
+ 	 * BIT_17 - flush - qlt_abort_cmd_on_host_reset
+ 	 * BIT_18 - completion w/abort status
+ 	 * BIT_19 - completion w/unknown status
+ 	 * BIT_20 - tcm_qla2xxx_free_cmd
+ 	 */
+ 	CMD_FLAG_DATA_WORK = BIT_11,
+ 	CMD_FLAG_DATA_WORK_FREE = BIT_21,
+ } cmd_flags_t;
+ 
  struct qla_tgt_cmd {
 -	struct se_cmd se_cmd;
  	struct qla_tgt_sess *sess;
  	int state;
 +	struct se_cmd se_cmd;
  	struct work_struct free_work;
  	struct work_struct work;
  	/* Sense buffer that will be mapped into outgoing status */
@@@ -858,6 -1009,16 +889,19 @@@
  	struct list_head cmd_list;
  
  	struct atio_from_isp atio;
++<<<<<<< HEAD
++=======
+ 	/* t10dif */
+ 	struct scatterlist *prot_sg;
+ 	uint32_t prot_sg_cnt;
+ 	uint32_t blk_sz;
+ 	struct crc_context *ctx;
+ 
+ 	uint64_t jiffies_at_alloc;
+ 	uint64_t jiffies_at_free;
+ 
+ 	cmd_flags_t cmd_flags;
++>>>>>>> a07100e00ac4 (qla2xxx: Fix TMR ABORT interaction issue between qla2xxx and TCM)
  };
  
  struct qla_tgt_sess_work_param {
@@@ -977,6 -1157,7 +1021,10 @@@ extern void qlt_24xx_atio_pkt_all_vps(s
  extern void qlt_response_pkt_all_vps(struct scsi_qla_host *, response_t *);
  extern int qlt_rdy_to_xfer(struct qla_tgt_cmd *);
  extern int qlt_xmit_response(struct qla_tgt_cmd *, int, uint8_t);
++<<<<<<< HEAD
++=======
+ extern int qlt_abort_cmd(struct qla_tgt_cmd *);
++>>>>>>> a07100e00ac4 (qla2xxx: Fix TMR ABORT interaction issue between qla2xxx and TCM)
  extern void qlt_xmit_tm_rsp(struct qla_tgt_mgmt_cmd *);
  extern void qlt_free_mcmd(struct qla_tgt_mgmt_cmd *);
  extern void qlt_free_cmd(struct qla_tgt_cmd *cmd);
diff --cc drivers/scsi/qla2xxx/tcm_qla2xxx.c
index 8e939971fec1,3eecdd1bc6fb..000000000000
--- a/drivers/scsi/qla2xxx/tcm_qla2xxx.c
+++ b/drivers/scsi/qla2xxx/tcm_qla2xxx.c
@@@ -413,8 -296,14 +413,17 @@@ static void tcm_qla2xxx_complete_free(s
   */
  static void tcm_qla2xxx_free_cmd(struct qla_tgt_cmd *cmd)
  {
++<<<<<<< HEAD
++=======
+ 	cmd->vha->tgt_counters.core_qla_free_cmd++;
+ 	cmd->cmd_in_wq = 1;
+ 
+ 	BUG_ON(cmd->cmd_flags & BIT_20);
+ 	cmd->cmd_flags |= BIT_20;
+ 
++>>>>>>> a07100e00ac4 (qla2xxx: Fix TMR ABORT interaction issue between qla2xxx and TCM)
  	INIT_WORK(&cmd->work, tcm_qla2xxx_complete_free);
 -	queue_work_on(smp_processor_id(), tcm_qla2xxx_free_wq, &cmd->work);
 +	queue_work(tcm_qla2xxx_free_wq, &cmd->work);
  }
  
  /*
@@@ -508,8 -379,22 +517,25 @@@ static int tcm_qla2xxx_write_pending(st
  	struct qla_tgt_cmd *cmd = container_of(se_cmd,
  				struct qla_tgt_cmd, se_cmd);
  
++<<<<<<< HEAD
++=======
+ 	if (cmd->aborted) {
+ 		/* Cmd can loop during Q-full.  tcm_qla2xxx_aborted_task
+ 		 * can get ahead of this cmd. tcm_qla2xxx_aborted_task
+ 		 * already kick start the free.
+ 		 */
+ 		pr_debug("write_pending aborted cmd[%p] refcount %d "
+ 			"transport_state %x, t_state %x, se_cmd_flags %x\n",
+ 			cmd,cmd->se_cmd.cmd_kref.refcount.counter,
+ 			cmd->se_cmd.transport_state,
+ 			cmd->se_cmd.t_state,
+ 			cmd->se_cmd.se_cmd_flags);
+ 		return 0;
+ 	}
+ 	cmd->cmd_flags |= BIT_3;
++>>>>>>> a07100e00ac4 (qla2xxx: Fix TMR ABORT interaction issue between qla2xxx and TCM)
  	cmd->bufflen = se_cmd->data_length;
 -	cmd->dma_data_direction = target_reverse_dma_direction(se_cmd);
 +	cmd->dma_data_direction = tcm_qla2xxx_mapping_dir(se_cmd);
  
  	cmd->sg_cnt = se_cmd->t_data_nents;
  	cmd->sg = se_cmd->t_data_sg;
@@@ -605,6 -489,20 +632,23 @@@ static void tcm_qla2xxx_handle_data_wor
  	 * Ensure that the complete FCP WRITE payload has been received.
  	 * Otherwise return an exception via CHECK_CONDITION status.
  	 */
++<<<<<<< HEAD
++=======
+ 	cmd->cmd_in_wq = 0;
+ 
+ 	spin_lock_irqsave(&cmd->cmd_lock, flags);
+ 	cmd->cmd_flags |= CMD_FLAG_DATA_WORK;
+ 	if (cmd->aborted) {
+ 		cmd->cmd_flags |= CMD_FLAG_DATA_WORK_FREE;
+ 		spin_unlock_irqrestore(&cmd->cmd_lock, flags);
+ 
+ 		tcm_qla2xxx_free_cmd(cmd);
+ 		return;
+ 	}
+ 	spin_unlock_irqrestore(&cmd->cmd_lock, flags);
+ 
+ 	cmd->vha->tgt_counters.qla_core_ret_ctio++;
++>>>>>>> a07100e00ac4 (qla2xxx: Fix TMR ABORT interaction issue between qla2xxx and TCM)
  	if (!cmd->write_data_transferred) {
  		/*
  		 * Check if se_cmd has already been aborted via LUN_RESET, and
@@@ -650,9 -576,23 +694,27 @@@ static int tcm_qla2xxx_queue_data_in(st
  	struct qla_tgt_cmd *cmd = container_of(se_cmd,
  				struct qla_tgt_cmd, se_cmd);
  
++<<<<<<< HEAD
++=======
+ 	if (cmd->aborted) {
+ 		/* Cmd can loop during Q-full.  tcm_qla2xxx_aborted_task
+ 		 * can get ahead of this cmd. tcm_qla2xxx_aborted_task
+ 		 * already kick start the free.
+ 		 */
+ 		pr_debug("queue_data_in aborted cmd[%p] refcount %d "
+ 			"transport_state %x, t_state %x, se_cmd_flags %x\n",
+ 			cmd,cmd->se_cmd.cmd_kref.refcount.counter,
+ 			cmd->se_cmd.transport_state,
+ 			cmd->se_cmd.t_state,
+ 			cmd->se_cmd.se_cmd_flags);
+ 		return 0;
+ 	}
+ 
+ 	cmd->cmd_flags |= BIT_4;
++>>>>>>> a07100e00ac4 (qla2xxx: Fix TMR ABORT interaction issue between qla2xxx and TCM)
  	cmd->bufflen = se_cmd->data_length;
 -	cmd->dma_data_direction = target_reverse_dma_direction(se_cmd);
 +	cmd->dma_data_direction = tcm_qla2xxx_mapping_dir(se_cmd);
 +	cmd->aborted = (se_cmd->transport_state & CMD_T_ABORTED);
  
  	cmd->sg_cnt = se_cmd->t_data_nents;
  	cmd->sg = se_cmd->t_data_sg;
@@@ -730,8 -679,36 +792,39 @@@ static int tcm_qla2xxx_queue_tm_rsp(str
  	 * CTIO response packet.
  	 */
  	qlt_xmit_tm_rsp(mcmd);
 -}
  
++<<<<<<< HEAD
 +	return 0;
++=======
+ 
+ #define DATA_WORK_NOT_FREE(_flags) \
+ 	(( _flags & (CMD_FLAG_DATA_WORK|CMD_FLAG_DATA_WORK_FREE)) == \
+ 	 CMD_FLAG_DATA_WORK)
+ static void tcm_qla2xxx_aborted_task(struct se_cmd *se_cmd)
+ {
+ 	struct qla_tgt_cmd *cmd = container_of(se_cmd,
+ 				struct qla_tgt_cmd, se_cmd);
+ 	unsigned long flags;
+ 
+ 	if (qlt_abort_cmd(cmd))
+ 		return;
+ 
+ 	spin_lock_irqsave(&cmd->cmd_lock, flags);
+ 	if ((cmd->state == QLA_TGT_STATE_NEW)||
+ 		((cmd->state == QLA_TGT_STATE_DATA_IN) &&
+ 		 DATA_WORK_NOT_FREE(cmd->cmd_flags)) ) {
+ 
+ 		cmd->cmd_flags |= CMD_FLAG_DATA_WORK_FREE;
+ 		spin_unlock_irqrestore(&cmd->cmd_lock, flags);
+ 		/* Cmd have not reached firmware.
+ 		 * Use this trigger to free it. */
+ 		tcm_qla2xxx_free_cmd(cmd);
+ 		return;
+ 	}
+ 	spin_unlock_irqrestore(&cmd->cmd_lock, flags);
+ 	return;
+ 
++>>>>>>> a07100e00ac4 (qla2xxx: Fix TMR ABORT interaction issue between qla2xxx and TCM)
  }
  
  static void tcm_qla2xxx_clear_sess_lookup(struct tcm_qla2xxx_lport *,
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.h
* Unmerged path drivers/scsi/qla2xxx/tcm_qla2xxx.c
