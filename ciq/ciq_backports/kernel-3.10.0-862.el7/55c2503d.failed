net/mlx5e: Introduce switch channels

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Introduce switch channels (Don Dutile) [1456659 1499362]
Rebuild_FUZZ: 94.12%
commit-author Saeed Mahameed <saeedm@mellanox.com>
commit 55c2503dae1ac8aed14d261dc02f967b4d6b1f88
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/55c2503d.failed

A fail safe helper functions that allows switching to new channels on the
fly,  In simple words:

make_new_config(new_params)
{
    new_channels = open_channels(new_params);
    if (!new_channels)
         return "Failed, but current channels are still active :)"

    switch_channels(new_channels);

    return "SUCCESS";
}

Demonstrate mlx5e_switch_priv_channels usage in set channels ethtool
callback and make it fail-safe using the new switch channels mechanism.

	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Reviewed-by: Tariq Toukan <tariqt@mellanox.com>
(cherry picked from commit 55c2503dae1ac8aed14d261dc02f967b4d6b1f88)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
index 35c9cc1953cf,e5cee400a4d3..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
@@@ -584,14 -590,8 +595,19 @@@ static int mlx5e_set_channels(struct ne
  	if (arfs_enabled)
  		mlx5e_arfs_disable(priv);
  
++<<<<<<< HEAD
 +	priv->params.num_channels = count;
 +	mlx5e_build_default_indir_rqt(priv->mdev, priv->params.indirection_rqt,
 +				      MLX5E_INDIR_RQT_SIZE, count);
 +
 +	if (was_opened)
 +		err = mlx5e_open_locked(dev);
 +	if (err)
 +		goto out;
++=======
+ 	/* Switch to new channels, set new parameters and close old ones */
+ 	mlx5e_switch_priv_channels(priv, &new_channels);
++>>>>>>> 55c2503dae1a (net/mlx5e: Introduce switch channels)
  
  	if (arfs_enabled) {
  		err = mlx5e_arfs_enable(priv);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index fc92406a15c4,97e153209834..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -1718,43 -1963,32 +1718,48 @@@ static void mlx5e_build_channel_param(s
  {
  	u8 icosq_log_wq_sz = MLX5E_PARAMS_MINIMUM_LOG_SQ_SIZE;
  
 -	mlx5e_build_rq_param(priv, params, &cparam->rq);
 -	mlx5e_build_sq_param(priv, params, &cparam->sq);
 -	mlx5e_build_xdpsq_param(priv, params, &cparam->xdp_sq);
 -	mlx5e_build_icosq_param(priv, icosq_log_wq_sz, &cparam->icosq);
 -	mlx5e_build_rx_cq_param(priv, params, &cparam->rx_cq);
 -	mlx5e_build_tx_cq_param(priv, params, &cparam->tx_cq);
 -	mlx5e_build_ico_cq_param(priv, icosq_log_wq_sz, &cparam->icosq_cq);
 +	mlx5e_build_rq_param(priv, &cparam->rq);
 +	mlx5e_build_sq_param(priv, &cparam->sq);
 +	mlx5e_build_icosq_param(priv, &cparam->icosq, icosq_log_wq_sz);
 +	mlx5e_build_rx_cq_param(priv, &cparam->rx_cq);
 +	mlx5e_build_tx_cq_param(priv, &cparam->tx_cq);
 +	mlx5e_build_ico_cq_param(priv, &cparam->icosq_cq, icosq_log_wq_sz);
  }
  
++<<<<<<< HEAD
 +static int mlx5e_open_channels(struct mlx5e_priv *priv)
++=======
+ int mlx5e_open_channels(struct mlx5e_priv *priv,
+ 			struct mlx5e_channels *chs)
++>>>>>>> 55c2503dae1a (net/mlx5e: Introduce switch channels)
  {
  	struct mlx5e_channel_param *cparam;
 +	int nch = priv->params.num_channels;
  	int err = -ENOMEM;
  	int i;
 +	int j;
  
 -	chs->num = chs->params.num_channels;
 +	priv->channel = kcalloc(nch, sizeof(struct mlx5e_channel *),
 +				GFP_KERNEL);
 +
 +	priv->txq_to_sq_map = kcalloc(nch * priv->params.num_tc,
 +				      sizeof(struct mlx5e_sq *), GFP_KERNEL);
  
 -	chs->c = kcalloc(chs->num, sizeof(struct mlx5e_channel *), GFP_KERNEL);
  	cparam = kzalloc(sizeof(struct mlx5e_channel_param), GFP_KERNEL);
 -	if (!chs->c || !cparam)
 -		goto err_free;
  
 -	mlx5e_build_channel_param(priv, &chs->params, cparam);
 -	for (i = 0; i < chs->num; i++) {
 -		err = mlx5e_open_channel(priv, i, &chs->params, cparam, &chs->c[i]);
 +	if (!priv->channel || !priv->txq_to_sq_map || !cparam)
 +		goto err_free_txq_to_sq_map;
 +
 +	mlx5e_build_channel_param(priv, cparam);
 +
 +	for (i = 0; i < nch; i++) {
 +		err = mlx5e_open_channel(priv, i, cparam, &priv->channel[i]);
 +		if (err)
 +			goto err_close_channels;
 +	}
 +
 +	for (j = 0; j < nch; j++) {
 +		err = mlx5e_wait_for_min_rx_wqes(&priv->channel[j]->rq);
  		if (err)
  			goto err_close_channels;
  	}
@@@ -1783,38 -2011,33 +1788,44 @@@ static void mlx5e_close_channels(struc
  {
  	int i;
  
 -	for (i = 0; i < chs->num; i++)
 -		mlx5e_activate_channel(chs->c[i]);
 -}
 +	/* FIXME: This is a W/A only for tx timeout watch dog false alarm when
 +	 * polling for inactive tx queues.
 +	 */
 +	netif_tx_stop_all_queues(priv->netdev);
 +	netif_tx_disable(priv->netdev);
  
 -static int mlx5e_wait_channels_min_rx_wqes(struct mlx5e_channels *chs)
++<<<<<<< HEAD
 +	for (i = 0; i < priv->params.num_channels; i++)
 +		mlx5e_close_channel(priv->channel[i]);
++=======
++void mlx5e_close_channels(struct mlx5e_channels *chs)
+ {
 -	int err = 0;
+ 	int i;
++>>>>>>> 55c2503dae1a (net/mlx5e: Introduce switch channels)
  
 -	for (i = 0; i < chs->num; i++) {
 -		err = mlx5e_wait_for_min_rx_wqes(&chs->c[i]->rq);
 -		if (err)
 -			break;
 -	}
 +	kfree(priv->txq_to_sq_map);
 +	kfree(priv->channel);
 +}
  
 -	return err;
 +static int mlx5e_rx_hash_fn(int hfunc)
 +{
 +	return (hfunc == ETH_RSS_HASH_TOP) ?
 +	       MLX5_RX_HASH_FN_TOEPLITZ :
 +	       MLX5_RX_HASH_FN_INVERTED_XOR8;
  }
  
 -static void mlx5e_deactivate_channels(struct mlx5e_channels *chs)
 +static int mlx5e_bits_invert(unsigned long a, int size)
  {
 +	int inv = 0;
  	int i;
  
 -	for (i = 0; i < chs->num; i++)
 -		mlx5e_deactivate_channel(chs->c[i]);
 +	for (i = 0; i < size; i++)
 +		inv |= (test_bit(size - i - 1, &a) ? 1 : 0) << i;
 +
 +	return inv;
  }
  
 -void mlx5e_close_channels(struct mlx5e_channels *chs)
 +static void mlx5e_fill_indir_rqt_rqns(struct mlx5e_priv *priv, void *rqtc)
  {
  	int i;
  
@@@ -2195,6 -2477,86 +2206,89 @@@ static void mlx5e_netdev_set_tcs(struc
  		netdev_set_tc_queue(netdev, tc, nch, 0);
  }
  
++<<<<<<< HEAD
++=======
+ static void mlx5e_build_channels_tx_maps(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5e_channel *c;
+ 	struct mlx5e_txqsq *sq;
+ 	int i, tc;
+ 
+ 	for (i = 0; i < priv->channels.num; i++)
+ 		for (tc = 0; tc < priv->profile->max_tc; tc++)
+ 			priv->channel_tc2txq[i][tc] = i + tc * priv->channels.num;
+ 
+ 	for (i = 0; i < priv->channels.num; i++) {
+ 		c = priv->channels.c[i];
+ 		for (tc = 0; tc < c->num_tc; tc++) {
+ 			sq = &c->sq[tc];
+ 			priv->txq2sq[sq->txq_ix] = sq;
+ 		}
+ 	}
+ }
+ 
+ static void mlx5e_activate_priv_channels(struct mlx5e_priv *priv)
+ {
+ 	int num_txqs = priv->channels.num * priv->channels.params.num_tc;
+ 	struct net_device *netdev = priv->netdev;
+ 
+ 	mlx5e_netdev_set_tcs(netdev);
+ 	if (netdev->real_num_tx_queues != num_txqs)
+ 		netif_set_real_num_tx_queues(netdev, num_txqs);
+ 	if (netdev->real_num_rx_queues != priv->channels.num)
+ 		netif_set_real_num_rx_queues(netdev, priv->channels.num);
+ 
+ 	mlx5e_build_channels_tx_maps(priv);
+ 	mlx5e_activate_channels(&priv->channels);
+ 	netif_tx_start_all_queues(priv->netdev);
+ 
+ 	if (MLX5_CAP_GEN(priv->mdev, vport_group_manager))
+ 		mlx5e_add_sqs_fwd_rules(priv);
+ 
+ 	mlx5e_wait_channels_min_rx_wqes(&priv->channels);
+ 	mlx5e_redirect_rqts_to_channels(priv, &priv->channels);
+ }
+ 
+ static void mlx5e_deactivate_priv_channels(struct mlx5e_priv *priv)
+ {
+ 	mlx5e_redirect_rqts_to_drop(priv);
+ 
+ 	if (MLX5_CAP_GEN(priv->mdev, vport_group_manager))
+ 		mlx5e_remove_sqs_fwd_rules(priv);
+ 
+ 	/* FIXME: This is a W/A only for tx timeout watch dog false alarm when
+ 	 * polling for inactive tx queues.
+ 	 */
+ 	netif_tx_stop_all_queues(priv->netdev);
+ 	netif_tx_disable(priv->netdev);
+ 	mlx5e_deactivate_channels(&priv->channels);
+ }
+ 
+ void mlx5e_switch_priv_channels(struct mlx5e_priv *priv,
+ 				struct mlx5e_channels *new_chs)
+ {
+ 	struct net_device *netdev = priv->netdev;
+ 	int new_num_txqs;
+ 
+ 	new_num_txqs = new_chs->num * new_chs->params.num_tc;
+ 
+ 	netif_carrier_off(netdev);
+ 
+ 	if (new_num_txqs < netdev->real_num_tx_queues)
+ 		netif_set_real_num_tx_queues(netdev, new_num_txqs);
+ 
+ 	mlx5e_deactivate_priv_channels(priv);
+ 	mlx5e_close_channels(&priv->channels);
+ 
+ 	priv->channels = *new_chs;
+ 
+ 	mlx5e_refresh_tirs(priv, false);
+ 	mlx5e_activate_priv_channels(priv);
+ 
+ 	mlx5e_update_carrier(priv);
+ }
+ 
++>>>>>>> 55c2503dae1a (net/mlx5e: Introduce switch channels)
  int mlx5e_open_locked(struct net_device *netdev)
  {
  	struct mlx5e_priv *priv = netdev_priv(netdev);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en.h b/drivers/net/ethernet/mellanox/mlx5/core/en.h
index 16c2c2d53ebb..a428ee454589 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@ -785,6 +785,13 @@ void mlx5e_build_indir_tir_ctx_hash(struct mlx5e_priv *priv, void *tirc,
 
 int mlx5e_open_locked(struct net_device *netdev);
 int mlx5e_close_locked(struct net_device *netdev);
+
+int mlx5e_open_channels(struct mlx5e_priv *priv,
+			struct mlx5e_channels *chs);
+void mlx5e_close_channels(struct mlx5e_channels *chs);
+void mlx5e_switch_priv_channels(struct mlx5e_priv *priv,
+				struct mlx5e_channels *new_chs);
+
 void mlx5e_build_default_indir_rqt(struct mlx5_core_dev *mdev,
 				   u32 *indirection_rqt, int len,
 				   int num_channels);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
