Revert "sysfs: drop kobj_ns_type handling"

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Linus Torvalds <torvalds@linux-foundation.org>
commit a1212d278c05ca0a38f5cbd7ae90ac2e367228a8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a1212d27.failed

This reverts commit cb26a311578e67769e92a39a0a63476533cb7e12.

It mysteriously causes NetworkManager to not find the wireless device
for me.  As far as I can tell, Tejun *meant* for this commit to not make
any semantic changes, but there clearly are some.  So revert it, taking
into account some of the calling convention changes that happened in
this area in subsequent commits.

	Cc: Tejun Heo <tj@kernel.org>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit a1212d278c05ca0a38f5cbd7ae90ac2e367228a8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/sysfs/dir.c
#	fs/sysfs/mount.c
#	fs/sysfs/symlink.c
#	fs/sysfs/sysfs.h
#	lib/kobject.c
diff --cc fs/sysfs/dir.c
index fd502d3fc9fc,5e73d6626e50..000000000000
--- a/fs/sysfs/dir.c
+++ b/fs/sysfs/dir.c
@@@ -437,15 -426,15 +437,27 @@@ int __sysfs_add_one(struct sysfs_addrm_
  	struct sysfs_inode_attrs *ps_iattr;
  	int ret;
  
++<<<<<<< HEAD
 +	if (!!sysfs_ns_type(acxt->parent_sd) != !!sd->s_ns) {
 +		WARN(1, KERN_WARNING "sysfs: ns %s in '%s' for '%s'\n",
 +			sysfs_ns_type(acxt->parent_sd)? "required": "invalid",
 +			acxt->parent_sd->s_name, sd->s_name);
 +		return -EINVAL;
 +	}
 +
 +	sd->s_hash = sysfs_name_hash(sd->s_ns, sd->s_name);
 +	sd->s_parent = sysfs_get(acxt->parent_sd);
++=======
+ 	if (!!sysfs_ns_type(parent_sd) != !!sd->s_ns) {
+ 		WARN(1, KERN_WARNING "sysfs: ns %s in '%s' for '%s'\n",
+ 			sysfs_ns_type(parent_sd) ? "required" : "invalid",
+ 			parent_sd->s_name, sd->s_name);
+ 		return -EINVAL;
+ 	}
+ 
+ 	sd->s_hash = sysfs_name_hash(sd->s_name, sd->s_ns);
+ 	sd->s_parent = sysfs_get(parent_sd);
++>>>>>>> a1212d278c05 (Revert "sysfs: drop kobj_ns_type handling")
  
  	ret = sysfs_link_sibling(sd);
  	if (ret)
@@@ -612,12 -614,12 +624,20 @@@ struct sysfs_dirent *sysfs_find_dirent(
  
  	if (!!sysfs_ns_type(parent_sd) != !!ns) {
  		WARN(1, KERN_WARNING "sysfs: ns %s in '%s' for '%s'\n",
++<<<<<<< HEAD
 +			sysfs_ns_type(parent_sd)? "required": "invalid",
++=======
+ 			sysfs_ns_type(parent_sd) ? "required" : "invalid",
++>>>>>>> a1212d278c05 (Revert "sysfs: drop kobj_ns_type handling")
  			parent_sd->s_name, name);
  		return NULL;
  	}
  
++<<<<<<< HEAD
 +	hash = sysfs_name_hash(ns, name);
++=======
+ 	hash = sysfs_name_hash(name, ns);
++>>>>>>> a1212d278c05 (Revert "sysfs: drop kobj_ns_type handling")
  	while (node) {
  		struct sysfs_dirent *sd;
  		int result;
@@@ -661,13 -664,14 +681,19 @@@ struct sysfs_dirent *sysfs_get_dirent(s
  
  	return sd;
  }
 -EXPORT_SYMBOL_GPL(sysfs_get_dirent_ns);
 +EXPORT_SYMBOL_GPL(sysfs_get_dirent);
  
  static int create_dir(struct kobject *kobj, struct sysfs_dirent *parent_sd,
++<<<<<<< HEAD
 +	enum kobj_ns_type type, const void *ns, const char *name,
 +	struct sysfs_dirent **p_sd)
++=======
+ 		      enum kobj_ns_type type,
+ 		      const char *name, const void *ns,
+ 		      struct sysfs_dirent **p_sd)
++>>>>>>> a1212d278c05 (Revert "sysfs: drop kobj_ns_type handling")
  {
 -	umode_t mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;
 +	umode_t mode = S_IFDIR| S_IRWXU | S_IRUGO | S_IXUGO;
  	struct sysfs_addrm_cxt acxt;
  	struct sysfs_dirent *sd;
  	int rc;
@@@ -698,43 -702,43 +724,75 @@@ int sysfs_create_subdir(struct kobject 
  			struct sysfs_dirent **p_sd)
  {
  	return create_dir(kobj, kobj->sd,
++<<<<<<< HEAD
 +			  KOBJ_NS_TYPE_NONE, NULL, name, p_sd);
++=======
+ 			  KOBJ_NS_TYPE_NONE, name, NULL, p_sd);
+ }
+ 
+ /**
+  *	sysfs_read_ns_type: return associated ns_type
+  *	@kobj: the kobject being queried
+  *
+  *	Each kobject can be tagged with exactly one namespace type
+  *	(i.e. network or user).  Return the ns_type associated with
+  *	this object if any
+  */
+ static enum kobj_ns_type sysfs_read_ns_type(struct kobject *kobj)
+ {
+ 	const struct kobj_ns_type_operations *ops;
+ 	enum kobj_ns_type type;
+ 
+ 	ops = kobj_child_ns_ops(kobj);
+ 	if (!ops)
+ 		return KOBJ_NS_TYPE_NONE;
+ 
+ 	type = ops->type;
+ 	BUG_ON(type <= KOBJ_NS_TYPE_NONE);
+ 	BUG_ON(type >= KOBJ_NS_TYPES);
+ 	BUG_ON(!kobj_ns_type_registered(type));
+ 
++	return type;
++>>>>>>> a1212d278c05 (Revert "sysfs: drop kobj_ns_type handling")
 +}
 +
 +/**
 + *	sysfs_read_ns_type: return associated ns_type
 + *	@kobj: the kobject being queried
 + *
 + *	Each kobject can be tagged with exactly one namespace type
 + *	(i.e. network or user).  Return the ns_type associated with
 + *	this object if any
 + */
 +static enum kobj_ns_type sysfs_read_ns_type(struct kobject *kobj)
 +{
++<<<<<<< HEAD
 +	const struct kobj_ns_type_operations *ops;
 +	enum kobj_ns_type type;
 +
 +	ops = kobj_child_ns_ops(kobj);
 +	if (!ops)
 +		return KOBJ_NS_TYPE_NONE;
 +
 +	type = ops->type;
 +	BUG_ON(type <= KOBJ_NS_TYPE_NONE);
 +	BUG_ON(type >= KOBJ_NS_TYPES);
 +	BUG_ON(!kobj_ns_type_registered(type));
 +
  	return type;
  }
  
  /**
 - * sysfs_create_dir_ns - create a directory for an object with a namespace tag
 - * @kobj: object we're creating directory for
 - * @ns: the namespace tag to use
 + *	sysfs_create_dir - create a directory for an object.
 + *	@kobj:		object we're creating directory for.
   */
 -int sysfs_create_dir_ns(struct kobject *kobj, const void *ns)
 +int sysfs_create_dir(struct kobject * kobj)
  {
++=======
++>>>>>>> a1212d278c05 (Revert "sysfs: drop kobj_ns_type handling")
  	enum kobj_ns_type type;
  	struct sysfs_dirent *parent_sd, *sd;
 +	const void *ns = NULL;
  	int error = 0;
  
  	BUG_ON(!kobj);
@@@ -747,11 -751,9 +805,17 @@@
  	if (!parent_sd)
  		return -ENOENT;
  
++<<<<<<< HEAD
 +	if (sysfs_ns_type(parent_sd))
 +		ns = kobj->ktype->namespace(kobj);
 +	type = sysfs_read_ns_type(kobj);
 +
 +	error = create_dir(kobj, parent_sd, type, ns, kobject_name(kobj), &sd);
++=======
+ 	type = sysfs_read_ns_type(kobj);
+ 
+ 	error = create_dir(kobj, parent_sd, type, kobject_name(kobj), ns, &sd);
++>>>>>>> a1212d278c05 (Revert "sysfs: drop kobj_ns_type handling")
  	if (!error)
  		kobj->sd = sd;
  	return error;
@@@ -992,68 -1091,38 +1056,83 @@@ static struct sysfs_dirent *sysfs_dir_n
  	return pos;
  }
  
 -static int sysfs_readdir(struct file *file, struct dir_context *ctx)
 +static int sysfs_readdir(struct file * filp, void * dirent, filldir_t filldir)
  {
++<<<<<<< HEAD
 +	struct dentry *dentry = filp->f_path.dentry;
 +	struct sysfs_dirent * parent_sd = dentry->d_fsdata;
 +	struct sysfs_dirent *pos = filp->private_data;
 +	enum kobj_ns_type type;
 +	const void *ns;
 +	ino_t ino;
 +	loff_t off;
++=======
+ 	struct dentry *dentry = file->f_path.dentry;
+ 	struct sysfs_dirent *parent_sd = dentry->d_fsdata;
+ 	struct sysfs_dirent *pos = file->private_data;
+ 	enum kobj_ns_type type;
+ 	const void *ns;
+ 
+ 	type = sysfs_ns_type(parent_sd);
+ 	ns = sysfs_info(dentry->d_sb)->ns[type];
++>>>>>>> a1212d278c05 (Revert "sysfs: drop kobj_ns_type handling")
  
 -	if (!dir_emit_dots(file, ctx))
 -		return 0;
 +	type = sysfs_ns_type(parent_sd);
 +	ns = sysfs_info(dentry->d_sb)->ns[type];
 +
 +	if (filp->f_pos == 0) {
 +		ino = parent_sd->s_ino;
 +		if (filldir(dirent, ".", 1, filp->f_pos, ino, DT_DIR) == 0)
 +			filp->f_pos++;
 +		else
 +			return 0;
 +	}
 +	if (filp->f_pos == 1) {
 +		if (parent_sd->s_parent)
 +			ino = parent_sd->s_parent->s_ino;
 +		else
 +			ino = parent_sd->s_ino;
 +		if (filldir(dirent, "..", 2, filp->f_pos, ino, DT_DIR) == 0)
 +			filp->f_pos++;
 +		else
 +			return 0;
 +	}
  	mutex_lock(&sysfs_mutex);
++<<<<<<< HEAD
 +	off = filp->f_pos;
 +	for (pos = sysfs_dir_pos(ns, parent_sd, filp->f_pos, pos);
++=======
+ 	for (pos = sysfs_dir_pos(ns, parent_sd, ctx->pos, pos);
++>>>>>>> a1212d278c05 (Revert "sysfs: drop kobj_ns_type handling")
  	     pos;
 -	     pos = sysfs_dir_next_pos(ns, parent_sd, ctx->pos, pos)) {
 -		const char *name = pos->s_name;
 -		unsigned int type = dt_type(pos);
 -		int len = strlen(name);
 -		ino_t ino = pos->s_ino;
 -		ctx->pos = pos->s_hash;
 -		file->private_data = sysfs_get(pos);
 +	     pos = sysfs_dir_next_pos(ns, parent_sd, filp->f_pos, pos)) {
 +		const char * name;
 +		unsigned int type;
 +		int len, ret;
 +
 +		name = pos->s_name;
 +		len = strlen(name);
 +		ino = pos->s_ino;
 +		type = dt_type(pos);
 +		off = filp->f_pos = pos->s_hash;
 +		filp->private_data = sysfs_get(pos);
  
  		mutex_unlock(&sysfs_mutex);
 -		if (!dir_emit(ctx, name, len, ino, type))
 -			return 0;
 +		ret = filldir(dirent, name, len, off, ino, type);
  		mutex_lock(&sysfs_mutex);
 +		if (ret < 0)
 +			break;
  	}
  	mutex_unlock(&sysfs_mutex);
 -	file->private_data = NULL;
 -	ctx->pos = INT_MAX;
 +
 +	/* don't reference last entry if its refcount is dropped */
 +	if (!pos) {
 +		filp->private_data = NULL;
 +
 +		/* EOF and not changed as 0 or 1 in read/write path */
 +		if (off == filp->f_pos && off > 1)
 +			filp->f_pos = INT_MAX;
 +	}
  	return 0;
  }
  
diff --cc fs/sysfs/mount.c
index afd83273e6ce,834ec2cdb7a3..000000000000
--- a/fs/sysfs/mount.c
+++ b/fs/sysfs/mount.c
@@@ -112,8 -112,15 +112,20 @@@ static struct dentry *sysfs_mount(struc
  	struct super_block *sb;
  	int error;
  
++<<<<<<< HEAD
 +	if (!(flags & MS_KERNMOUNT) && !current_user_ns()->may_mount_sysfs)
 +		return ERR_PTR(-EPERM);
++=======
+ 	if (!(flags & MS_KERNMOUNT)) {
+ 		if (!capable(CAP_SYS_ADMIN) && !fs_fully_visible(fs_type))
+ 			return ERR_PTR(-EPERM);
+ 
+ 		for (type = KOBJ_NS_TYPE_NONE; type < KOBJ_NS_TYPES; type++) {
+ 			if (!kobj_ns_current_may_mount(type))
+ 				return ERR_PTR(-EPERM);
+ 		}
+ 	}
++>>>>>>> a1212d278c05 (Revert "sysfs: drop kobj_ns_type handling")
  
  	info = kzalloc(sizeof(*info), GFP_KERNEL);
  	if (!info)
diff --cc fs/sysfs/symlink.c
index 9fab2e7f7357,3ae3f1bf1a09..000000000000
--- a/fs/sysfs/symlink.c
+++ b/fs/sysfs/symlink.c
@@@ -52,18 -54,18 +52,32 @@@ static int sysfs_do_create_link_sd(stru
  
  	ns_type = sysfs_ns_type(parent_sd);
  	if (ns_type)
++<<<<<<< HEAD
 +		sd->s_ns = target->ktype->namespace(target);
 +	sd->s_symlink.target_sd = target_sd;
 +	target_sd = NULL;	/* reference is now owned by the symlink */
 +
 +	sysfs_addrm_start(&acxt, parent_sd);
++=======
+ 		sd->s_ns = target_sd->s_ns;
+ 	sd->s_symlink.target_sd = target_sd;
+ 	target_sd = NULL;	/* reference is now owned by the symlink */
+ 
+ 	sysfs_addrm_start(&acxt);
++>>>>>>> a1212d278c05 (Revert "sysfs: drop kobj_ns_type handling")
  	/* Symlinks must be between directories with the same ns_type */
  	if (!ns_type ||
  	    (ns_type == sysfs_ns_type(sd->s_symlink.target_sd->s_parent))) {
  		if (warn)
++<<<<<<< HEAD
 +			error = sysfs_add_one(&acxt, sd);
 +		else
 +			error = __sysfs_add_one(&acxt, sd);
++=======
+ 			error = sysfs_add_one(&acxt, sd, parent_sd);
+ 		else
+ 			error = __sysfs_add_one(&acxt, sd, parent_sd);
++>>>>>>> a1212d278c05 (Revert "sysfs: drop kobj_ns_type handling")
  	} else {
  		error = -EINVAL;
  		WARN(1, KERN_WARNING
@@@ -155,11 -157,17 +169,21 @@@ void sysfs_delete_link(struct kobject *
  			const char *name)
  {
  	const void *ns = NULL;
++<<<<<<< HEAD
 +	spin_lock(&sysfs_assoc_lock);
++=======
+ 
+ 	/*
+ 	 * We don't own @target and it may be removed at any time.
+ 	 * Synchronize using sysfs_symlink_target_lock.  See
+ 	 * sysfs_remove_dir() for details.
+ 	 */
+ 	spin_lock(&sysfs_symlink_target_lock);
++>>>>>>> a1212d278c05 (Revert "sysfs: drop kobj_ns_type handling")
  	if (targ->sd && sysfs_ns_type(kobj->sd))
  		ns = targ->sd->s_ns;
 -	spin_unlock(&sysfs_symlink_target_lock);
 -	sysfs_hash_and_remove(kobj->sd, name, ns);
 +	spin_unlock(&sysfs_assoc_lock);
 +	sysfs_hash_and_remove(kobj->sd, ns, name);
  }
  
  /**
diff --cc fs/sysfs/sysfs.h
index e18c3f38727c,0af09fbfb3f6..000000000000
--- a/fs/sysfs/sysfs.h
+++ b/fs/sysfs/sysfs.h
@@@ -113,8 -110,9 +113,13 @@@ static inline enum kobj_ns_type sysfs_n
  {
  	return (sd->s_flags & SYSFS_NS_TYPE_MASK) >> SYSFS_NS_TYPE_SHIFT;
  }
++<<<<<<< HEAD
++=======
+ 
+ #ifdef CONFIG_DEBUG_LOCK_ALLOC
++>>>>>>> a1212d278c05 (Revert "sysfs: drop kobj_ns_type handling")
  
 +#ifdef CONFIG_DEBUG_LOCK_ALLOC
  #define sysfs_dirent_init_lockdep(sd)				\
  do {								\
  	struct attribute *attr = sd->s_attr.attr;		\
diff --cc lib/kobject.c
index b201420a4a54,5b4b8886435e..000000000000
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@@ -18,6 -19,24 +18,27 @@@
  #include <linux/stat.h>
  #include <linux/slab.h>
  
++<<<<<<< HEAD
++=======
+ /**
+  * kobject_namespace - return @kobj's namespace tag
+  * @kobj: kobject in question
+  *
+  * Returns namespace tag of @kobj if its parent has namespace ops enabled
+  * and thus @kobj should have a namespace tag associated with it.  Returns
+  * %NULL otherwise.
+  */
+ const void *kobject_namespace(struct kobject *kobj)
+ {
+ 	const struct kobj_ns_type_operations *ns_ops = kobj_ns_ops(kobj);
+ 
+ 	if (!ns_ops || ns_ops->type == KOBJ_NS_TYPE_NONE)
+ 		return NULL;
+ 
+ 	return kobj->ktype->namespace(kobj);
+ }
+ 
++>>>>>>> a1212d278c05 (Revert "sysfs: drop kobj_ns_type handling")
  /*
   * populate_dir - populate directory with attributes.
   * @kobj: object we're working on.
* Unmerged path fs/sysfs/dir.c
* Unmerged path fs/sysfs/mount.c
* Unmerged path fs/sysfs/symlink.c
* Unmerged path fs/sysfs/sysfs.h
* Unmerged path lib/kobject.c
