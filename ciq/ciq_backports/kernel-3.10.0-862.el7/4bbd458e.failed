scsi: csiostor: add support for Chelsio T6 adapters

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] csiostor: add support for Chelsio T6 adapters (Arjun Vynipadath) [1458318]
Rebuild_FUZZ: 93.75%
commit-author Varun Prakash <varun@chelsio.com>
commit 4bbd458eaa789959f23f4c998d30b972715e1013
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4bbd458e.failed

Enable probe for T6 adapters, add code to flash T6 firmware and firmware
config file, use T6 specific macros.

	Signed-off-by: Varun Prakash <varun@chelsio.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 4bbd458eaa789959f23f4c998d30b972715e1013)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/csiostor/csio_hw.c
diff --cc drivers/scsi/csiostor/csio_hw.c
index 660dba7be3a9,c6e18140759c..000000000000
--- a/drivers/scsi/csiostor/csio_hw.c
+++ b/drivers/scsi/csiostor/csio_hw.c
@@@ -1715,10 -1587,16 +1721,22 @@@ csio_hw_flash_config(struct csio_hw *hw
  	unsigned int mtype = 0, maddr = 0;
  	uint32_t *cfg_data;
  	int value_to_add = 0;
+ 	const char *fw_cfg_file;
  
++<<<<<<< HEAD
 +	if (request_firmware(&cf, CSIO_CF_FNAME(hw), dev) < 0) {
 +		csio_err(hw, "could not find config file %s, err: %d\n",
 +			 CSIO_CF_FNAME(hw), ret);
++=======
+ 	if (csio_is_t5(pci_dev->device & CSIO_HW_CHIP_MASK))
+ 		fw_cfg_file = FW_CFG_NAME_T5;
+ 	else
+ 		fw_cfg_file = FW_CFG_NAME_T6;
+ 
+ 	if (request_firmware(&cf, fw_cfg_file, dev) < 0) {
+ 		csio_err(hw, "could not find config file %s, err: %d\n",
+ 			 fw_cfg_file, ret);
++>>>>>>> 4bbd458eaa78 (scsi: csiostor: add support for Chelsio T6 adapters)
  		return -ENOENT;
  	}
  
@@@ -1757,9 -1635,8 +1775,14 @@@
  		ret = csio_memory_write(hw, mtype, maddr + size, 4, &last.word);
  	}
  	if (ret == 0) {
++<<<<<<< HEAD
 +		csio_info(hw, "config file upgraded to %s\n",
 +			  CSIO_CF_FNAME(hw));
 +		snprintf(path, 64, "%s%s", "/lib/firmware/", CSIO_CF_FNAME(hw));
++=======
+ 		csio_info(hw, "config file upgraded to %s\n", fw_cfg_file);
+ 		snprintf(path, 64, "%s%s", "/lib/firmware/", fw_cfg_file);
++>>>>>>> 4bbd458eaa78 (scsi: csiostor: add support for Chelsio T6 adapters)
  	}
  
  leave:
@@@ -2123,10 -2039,17 +2160,24 @@@ csio_hw_flash_fw(struct csio_hw *hw, in
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	if (request_firmware(&fw, CSIO_FW_FNAME(hw), dev) < 0) {
 +		csio_err(hw, "could not find firmware image %s, err: %d\n",
 +			 CSIO_FW_FNAME(hw), ret);
 +		return -EINVAL;
++=======
+ 	if (csio_is_t5(pci_dev->device & CSIO_HW_CHIP_MASK))
+ 		fw_bin_file = FW_FNAME_T5;
+ 	else
+ 		fw_bin_file = FW_FNAME_T6;
+ 
+ 	if (request_firmware(&fw, fw_bin_file, dev) < 0) {
+ 		csio_err(hw, "could not find firmware image %s, err: %d\n",
+ 			 fw_bin_file, ret);
+ 	} else {
+ 		fw_data = fw->data;
+ 		fw_size = fw->size;
++>>>>>>> 4bbd458eaa78 (scsi: csiostor: add support for Chelsio T6 adapters)
  	}
  
  	/* allocate memory to read the header of the firmware on the
* Unmerged path drivers/scsi/csiostor/csio_hw.c
diff --git a/drivers/scsi/csiostor/csio_hw_chip.h b/drivers/scsi/csiostor/csio_hw_chip.h
index eec98f523ec9..5f3794a3692d 100644
--- a/drivers/scsi/csiostor/csio_hw_chip.h
+++ b/drivers/scsi/csiostor/csio_hw_chip.h
@@ -41,6 +41,8 @@
 #define CSIO_T4_FCOE_ASIC			0x4600
 #define CSIO_HW_T5				0x5000
 #define CSIO_T5_FCOE_ASIC			0x5600
+#define CSIO_HW_T6				0x6000
+#define CSIO_T6_FCOE_ASIC			0x6600
 #define CSIO_HW_CHIP_MASK			0xF000
 
 #define T4_REGMAP_SIZE				(160 * 1024)
@@ -49,6 +51,8 @@
 #define FW_FNAME_T5				"cxgb4/t5fw.bin"
 #define FW_CFG_NAME_T4				"cxgb4/t4-config.txt"
 #define FW_CFG_NAME_T5				"cxgb4/t5-config.txt"
+#define FW_FNAME_T6				"cxgb4/t6fw.bin"
+#define FW_CFG_NAME_T6				"cxgb4/t6-config.txt"
 
 #define T4FW_VERSION_MAJOR 0x01
 #define T4FW_VERSION_MINOR 0x0B
@@ -67,6 +71,7 @@
 
 #define CHELSIO_T4		0x4
 #define CHELSIO_T5		0x5
+#define CHELSIO_T6		0x6
 
 enum chip_type {
 	T4_A1 = CHELSIO_CHIP_CODE(CHELSIO_T4, 1),
@@ -78,6 +83,10 @@ enum chip_type {
 	T5_A1 = CHELSIO_CHIP_CODE(CHELSIO_T5, 1),
 	T5_FIRST_REV	= T5_A0,
 	T5_LAST_REV	= T5_A1,
+
+	T6_A0 = CHELSIO_CHIP_CODE(CHELSIO_T6, 0),
+	T6_FIRST_REV    = T6_A0,
+	T6_LAST_REV     = T6_A0,
 };
 
 /* Define static functions */
@@ -91,6 +100,11 @@ static inline int csio_is_t5(uint16_t chip)
 	return (chip == CSIO_HW_T5);
 }
 
+static inline int csio_is_t6(uint16_t chip)
+{
+	return (chip == CSIO_HW_T6);
+}
+
 /* Define MACRO DEFINITIONS */
 #define CSIO_DEVICE(devid, idx)						\
 	{ PCI_VENDOR_ID_CHELSIO, (devid), PCI_ANY_ID, PCI_ANY_ID, 0, 0, (idx) }
diff --git a/drivers/scsi/csiostor/csio_hw_t5.c b/drivers/scsi/csiostor/csio_hw_t5.c
index 3267f4f627c9..f24def6c6fd1 100644
--- a/drivers/scsi/csiostor/csio_hw_t5.c
+++ b/drivers/scsi/csiostor/csio_hw_t5.c
@@ -71,27 +71,6 @@ csio_t5_set_mem_win(struct csio_hw *hw, uint32_t win)
 static void
 csio_t5_pcie_intr_handler(struct csio_hw *hw)
 {
-	static struct intr_info sysbus_intr_info[] = {
-		{ RNPP_F, "RXNP array parity error", -1, 1 },
-		{ RPCP_F, "RXPC array parity error", -1, 1 },
-		{ RCIP_F, "RXCIF array parity error", -1, 1 },
-		{ RCCP_F, "Rx completions control array parity error", -1, 1 },
-		{ RFTP_F, "RXFT array parity error", -1, 1 },
-		{ 0, NULL, 0, 0 }
-	};
-	static struct intr_info pcie_port_intr_info[] = {
-		{ TPCP_F, "TXPC array parity error", -1, 1 },
-		{ TNPP_F, "TXNP array parity error", -1, 1 },
-		{ TFTP_F, "TXFT array parity error", -1, 1 },
-		{ TCAP_F, "TXCA array parity error", -1, 1 },
-		{ TCIP_F, "TXCIF array parity error", -1, 1 },
-		{ RCAP_F, "RXCA array parity error", -1, 1 },
-		{ OTDD_F, "outbound request TLP discarded", -1, 1 },
-		{ RDPE_F, "Rx data parity error", -1, 1 },
-		{ TDUE_F, "Tx uncorrectable data error", -1, 1 },
-		{ 0, NULL, 0, 0 }
-	};
-
 	static struct intr_info pcie_intr_info[] = {
 		{ MSTGRPPERR_F, "Master Response Read Queue parity error",
 		-1, 1 },
@@ -133,13 +112,7 @@ csio_t5_pcie_intr_handler(struct csio_hw *hw)
 	};
 
 	int fat;
-	fat = csio_handle_intr_status(hw,
-				      PCIE_CORE_UTL_SYSTEM_BUS_AGENT_STATUS_A,
-				      sysbus_intr_info) +
-	      csio_handle_intr_status(hw,
-				      PCIE_CORE_UTL_PCI_EXPRESS_PORT_STATUS_A,
-				      pcie_port_intr_info) +
-	      csio_handle_intr_status(hw, PCIE_INT_CAUSE_A, pcie_intr_info);
+	fat = csio_handle_intr_status(hw, PCIE_INT_CAUSE_A, pcie_intr_info);
 	if (fat)
 		csio_hw_fatal_err(hw);
 }
diff --git a/drivers/scsi/csiostor/csio_init.c b/drivers/scsi/csiostor/csio_init.c
index f36357fc278e..b9ca9e117e53 100644
--- a/drivers/scsi/csiostor/csio_init.c
+++ b/drivers/scsi/csiostor/csio_init.c
@@ -955,8 +955,9 @@ static int csio_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 	struct csio_hw *hw;
 	struct csio_lnode *ln;
 
-	/* probe only T5 cards */
-	if (!csio_is_t5((pdev->device & CSIO_HW_CHIP_MASK)))
+	/* probe only T5 and T6 cards */
+	if (!csio_is_t5((pdev->device & CSIO_HW_CHIP_MASK)) &&
+	    !csio_is_t6((pdev->device & CSIO_HW_CHIP_MASK)))
 		return -ENODEV;
 
 	rv = csio_pci_init(pdev, &bars);
@@ -1260,3 +1261,4 @@ MODULE_DEVICE_TABLE(pci, csio_pci_tbl);
 MODULE_VERSION(CSIO_DRV_VERSION);
 MODULE_FIRMWARE(FW_FNAME_T4);
 MODULE_FIRMWARE(FW_FNAME_T5);
+MODULE_FIRMWARE(FW_FNAME_T6);
diff --git a/drivers/scsi/csiostor/csio_wr.c b/drivers/scsi/csiostor/csio_wr.c
index 097956f9defa..0733f50ba2b6 100644
--- a/drivers/scsi/csiostor/csio_wr.c
+++ b/drivers/scsi/csiostor/csio_wr.c
@@ -486,12 +486,14 @@ csio_wr_iq_create(struct csio_hw *hw, void *priv, int iq_idx,
 
 	flq_idx = csio_q_iq_flq_idx(hw, iq_idx);
 	if (flq_idx != -1) {
+		enum chip_type chip = CHELSIO_CHIP_VERSION(hw->chip_id);
 		struct csio_q *flq = hw->wrm.q_arr[flq_idx];
 
 		iqp.fl0paden	= 1;
 		iqp.fl0packen	= flq->un.fl.packen ? 1 : 0;
 		iqp.fl0fbmin	= X_FETCHBURSTMIN_64B;
-		iqp.fl0fbmax	= X_FETCHBURSTMAX_512B;
+		iqp.fl0fbmax	= ((chip == CHELSIO_T5) ?
+				  X_FETCHBURSTMAX_512B : X_FETCHBURSTMAX_256B);
 		iqp.fl0size	= csio_q_size(hw, flq_idx) / CSIO_QCREDIT_SZ;
 		iqp.fl0addr	= csio_q_pstart(hw, flq_idx);
 	}
