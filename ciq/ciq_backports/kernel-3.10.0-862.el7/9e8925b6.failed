locks: Allow disabling mandatory locking at compile time

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jeff Layton <jeff.layton@primarydata.com>
commit 9e8925b67a809bb27ce4b7d352d67f25cf1d7fc5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9e8925b6.failed

Mandatory locking appears to be almost unused and buggy and there
appears no real interest in doing anything with it.  Since effectively
no one uses the code and since the code is buggy let's allow it to be
disabled at compile time.  I would just suggest removing the code but
undoubtedly that will break some piece of userspace code somewhere.

For the distributions that don't care about this piece of code
this gives a nice starting point to make mandatory locking go away.

	Cc: Benjamin Coddington <bcodding@redhat.com>
	Cc: Dmitry Vyukov <dvyukov@google.com>
	Cc: Jeff Layton <jeff.layton@primarydata.com>
	Cc: J. Bruce Fields <bfields@fieldses.org>
	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
	Signed-off-by: Jeff Layton <jeff.layton@primarydata.com>
(cherry picked from commit 9e8925b67a809bb27ce4b7d352d67f25cf1d7fc5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/fs.h
diff --cc include/linux/fs.h
index ecd81bb56cab,cbf08d5c246e..000000000000
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@@ -2285,11 -2026,13 +2285,11 @@@ extern void iput(struct inode *)
  extern struct kobject *fs_kobj;
  
  #define MAX_RW_COUNT (INT_MAX & PAGE_CACHE_MASK)
 -
 -#define FLOCK_VERIFY_READ  1
 -#define FLOCK_VERIFY_WRITE 2
 +extern int rw_verify_area(int, struct file *, loff_t *, size_t);
  
- #ifdef CONFIG_FILE_LOCKING
+ #ifdef CONFIG_MANDATORY_FILE_LOCKING
  extern int locks_mandatory_locked(struct file *);
 -extern int locks_mandatory_area(int, struct inode *, struct file *, loff_t, size_t);
 +extern int locks_mandatory_area(struct inode *, struct file *, loff_t, loff_t, unsigned char);
  
  /*
   * Candidates for mandatory locking have the setgid bit set
@@@ -2319,21 -2062,58 +2319,60 @@@ static inline int locks_verify_locked(s
  }
  
  static inline int locks_verify_truncate(struct inode *inode,
 -				    struct file *filp,
 +				    struct file *f,
  				    loff_t size)
  {
 -	if (inode->i_flctx && mandatory_lock(inode))
 -		return locks_mandatory_area(
 -			FLOCK_VERIFY_WRITE, inode, filp,
 -			size < inode->i_size ? size : inode->i_size,
 -			(size < inode->i_size ? inode->i_size - size
 -			 : size - inode->i_size)
 -		);
 -	return 0;
 +	if (!inode->i_flock || !mandatory_lock(inode))
 +		return 0;
 +
 +	if (size < inode->i_size) {
 +		return locks_mandatory_area(inode, f, size, inode->i_size - 1,
 +				F_WRLCK);
 +	} else {
 +		return locks_mandatory_area(inode, f, inode->i_size, size - 1,
 +				F_WRLCK);
 +	}
  }
  
+ #else /* !CONFIG_MANDATORY_FILE_LOCKING */
+ 
+ static inline int locks_mandatory_locked(struct file *file)
+ {
+ 	return 0;
+ }
+ 
+ static inline int locks_mandatory_area(int rw, struct inode *inode,
+ 				       struct file *filp, loff_t offset,
+ 				       size_t count)
+ {
+ 	return 0;
+ }
+ 
+ static inline int __mandatory_lock(struct inode *inode)
+ {
+ 	return 0;
+ }
+ 
+ static inline int mandatory_lock(struct inode *inode)
+ {
+ 	return 0;
+ }
+ 
+ static inline int locks_verify_locked(struct file *file)
+ {
+ 	return 0;
+ }
+ 
+ static inline int locks_verify_truncate(struct inode *inode, struct file *filp,
+ 					size_t size)
+ {
+ 	return 0;
+ }
+ 
+ #endif /* CONFIG_MANDATORY_FILE_LOCKING */
+ 
+ 
+ #ifdef CONFIG_FILE_LOCKING
  static inline int break_lease(struct inode *inode, unsigned int mode)
  {
  	/*
@@@ -2387,38 -2175,6 +2426,41 @@@ static inline int break_layout(struct i
  }
  
  #else /* !CONFIG_FILE_LOCKING */
++<<<<<<< HEAD
 +static inline int locks_mandatory_locked(struct file *file)
 +{
 +	return 0;
 +}
 +
 +static inline int locks_mandatory_area(struct inode *inode, struct file *filp,
 +		loff_t start, loff_t end, unsigned char type)
 +{
 +	return 0;
 +}
 +
 +static inline int __mandatory_lock(struct inode *inode)
 +{
 +	return 0;
 +}
 +
 +static inline int mandatory_lock(struct inode *inode)
 +{
 +	return 0;
 +}
 +
 +static inline int locks_verify_locked(struct file *file)
 +{
 +	return 0;
 +}
 +
 +static inline int locks_verify_truncate(struct inode *inode, struct file *filp,
 +					size_t size)
 +{
 +	return 0;
 +}
 +
++=======
++>>>>>>> 9e8925b67a80 (locks: Allow disabling mandatory locking at compile time)
  static inline int break_lease(struct inode *inode, unsigned int mode)
  {
  	return 0;
diff --git a/fs/Kconfig b/fs/Kconfig
index a93dc61a1371..17ff6a614fc7 100644
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -78,6 +78,16 @@ config FILE_LOCKING
           for filesystems like NFS and for the flock() system
           call. Disabling this option saves about 11k.
 
+config MANDATORY_FILE_LOCKING
+	bool "Enable Mandatory file locking"
+	depends on FILE_LOCKING
+	default y
+	help
+	  This option enables files appropriately marked files on appropriely
+	  mounted filesystems to support mandatory locking.
+
+	  To the best of my knowledge this is dead code that no one cares about.
+
 source "fs/notify/Kconfig"
 
 source "fs/quota/Kconfig"
diff --git a/fs/locks.c b/fs/locks.c
index 2cc42b9f6985..177cb7eeaa6b 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -1202,6 +1202,7 @@ int posix_lock_inode_wait(struct inode *inode, struct file_lock *fl)
 }
 EXPORT_SYMBOL(posix_lock_inode_wait);
 
+#ifdef CONFIG_MANDATORY_FILE_LOCKING
 /**
  * locks_mandatory_locked - Check for an active lock
  * @file: the file to check
@@ -1289,6 +1290,7 @@ int locks_mandatory_area(struct inode *inode, struct file *filp, loff_t start,
 }
 
 EXPORT_SYMBOL(locks_mandatory_area);
+#endif /* CONFIG_MANDATORY_FILE_LOCKING */
 
 static void lease_clear_pending(struct file_lock *fl, int arg)
 {
diff --git a/fs/namespace.c b/fs/namespace.c
index c3276b690896..7b9d7910435d 100644
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -1640,6 +1640,14 @@ static inline bool may_mount(void)
 	return ns_capable(current->nsproxy->mnt_ns->user_ns, CAP_SYS_ADMIN);
 }
 
+static inline bool may_mandlock(void)
+{
+#ifndef	CONFIG_MANDATORY_FILE_LOCKING
+	return false;
+#endif
+	return true;
+}
+
 /*
  * Now umount can handle mount points as well as block devices.
  * This is important for filesystems which use unnamed block devices.
@@ -2729,6 +2737,8 @@ long do_mount(const char *dev_name, const char __user *dir_name,
 				   type_page, flags, data_page);
 	if (!retval && !may_mount())
 		retval = -EPERM;
+	if (!retval && (flags & MS_MANDLOCK) && !may_mandlock())
+		retval = -EPERM;
 	if (retval)
 		goto dput_out;
 
* Unmerged path include/linux/fs.h
