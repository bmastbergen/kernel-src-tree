scsi: smartpqi: enhance BMIC cache flush

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] smartpqi: enhance BMIC cache flush (Don Brace) [1457414]
Rebuild_FUZZ: 91.89%
commit-author Kevin Barnett <kevin.barnett@microseim.com>
commit 58322fe0069a2ae2a19cf29023cc0b82c7245762
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/58322fe0.failed

 - distinguish between shutdown and non-shutdown.

	Reviewed-by: Scott Benesh <scott.benesh@microsemi.com>
	Signed-off-by: Kevin Barnett <kevin.barnett@microsemi.com>
	Signed-off-by: Don Brace <don.brace@microsemi.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 58322fe0069a2ae2a19cf29023cc0b82c7245762)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/smartpqi/smartpqi_init.c
diff --cc drivers/scsi/smartpqi/smartpqi_init.c
index 13a5a9aaadf9,b36d3382dd5c..000000000000
--- a/drivers/scsi/smartpqi/smartpqi_init.c
+++ b/drivers/scsi/smartpqi/smartpqi_init.c
@@@ -6105,6 -6703,91 +6106,94 @@@ error
  		"unable to flush controller cache\n");
  }
  
++<<<<<<< HEAD
++=======
+ static void pqi_process_lockup_action_param(void)
+ {
+ 	unsigned int i;
+ 
+ 	if (!pqi_lockup_action_param)
+ 		return;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(pqi_lockup_actions); i++) {
+ 		if (strcmp(pqi_lockup_action_param,
+ 			pqi_lockup_actions[i].name) == 0) {
+ 			pqi_lockup_action = pqi_lockup_actions[i].action;
+ 			return;
+ 		}
+ 	}
+ 
+ 	pr_warn("%s: invalid lockup action setting \"%s\" - supported settings: none, reboot, panic\n",
+ 		DRIVER_NAME_SHORT, pqi_lockup_action_param);
+ }
+ 
+ static void pqi_process_module_params(void)
+ {
+ 	pqi_process_lockup_action_param();
+ }
+ 
+ static __maybe_unused int pqi_suspend(struct pci_dev *pci_dev, pm_message_t state)
+ {
+ 	struct pqi_ctrl_info *ctrl_info;
+ 
+ 	ctrl_info = pci_get_drvdata(pci_dev);
+ 
+ 	pqi_disable_events(ctrl_info);
+ 	pqi_cancel_update_time_worker(ctrl_info);
+ 	pqi_cancel_rescan_worker(ctrl_info);
+ 	pqi_wait_until_scan_finished(ctrl_info);
+ 	pqi_wait_until_lun_reset_finished(ctrl_info);
+ 	pqi_flush_cache(ctrl_info, SUSPEND);
+ 	pqi_ctrl_block_requests(ctrl_info);
+ 	pqi_ctrl_wait_until_quiesced(ctrl_info);
+ 	pqi_wait_until_inbound_queues_empty(ctrl_info);
+ 	pqi_ctrl_wait_for_pending_io(ctrl_info);
+ 	pqi_stop_heartbeat_timer(ctrl_info);
+ 
+ 	if (state.event == PM_EVENT_FREEZE)
+ 		return 0;
+ 
+ 	pci_save_state(pci_dev);
+ 	pci_set_power_state(pci_dev, pci_choose_state(pci_dev, state));
+ 
+ 	ctrl_info->controller_online = false;
+ 	ctrl_info->pqi_mode_enabled = false;
+ 
+ 	return 0;
+ }
+ 
+ static __maybe_unused int pqi_resume(struct pci_dev *pci_dev)
+ {
+ 	int rc;
+ 	struct pqi_ctrl_info *ctrl_info;
+ 
+ 	ctrl_info = pci_get_drvdata(pci_dev);
+ 
+ 	if (pci_dev->current_state != PCI_D0) {
+ 		ctrl_info->max_hw_queue_index = 0;
+ 		pqi_free_interrupts(ctrl_info);
+ 		pqi_change_irq_mode(ctrl_info, IRQ_MODE_INTX);
+ 		rc = request_irq(pci_irq_vector(pci_dev, 0), pqi_irq_handler,
+ 			IRQF_SHARED, DRIVER_NAME_SHORT,
+ 			&ctrl_info->queue_groups[0]);
+ 		if (rc) {
+ 			dev_err(&ctrl_info->pci_dev->dev,
+ 				"irq %u init failed with error %d\n",
+ 				pci_dev->irq, rc);
+ 			return rc;
+ 		}
+ 		pqi_start_heartbeat_timer(ctrl_info);
+ 		pqi_ctrl_unblock_requests(ctrl_info);
+ 		return 0;
+ 	}
+ 
+ 	pci_set_power_state(pci_dev, PCI_D0);
+ 	pci_restore_state(pci_dev);
+ 
+ 	return pqi_ctrl_init_resume(ctrl_info);
+ }
+ 
++>>>>>>> 58322fe0069a (scsi: smartpqi: enhance BMIC cache flush)
  /* Define the PCI IDs for the controllers that we support. */
  static const struct pci_device_id pqi_pci_id_table[] = {
  	{
diff --git a/drivers/scsi/smartpqi/smartpqi.h b/drivers/scsi/smartpqi/smartpqi.h
index 591b0f1547e0..9a551a489d23 100644
--- a/drivers/scsi/smartpqi/smartpqi.h
+++ b/drivers/scsi/smartpqi/smartpqi.h
@@ -1001,9 +1001,9 @@ enum pqi_ctrl_mode {
 #define BMIC_SENSE_CONTROLLER_PARAMETERS	0x64
 #define BMIC_SENSE_SUBSYSTEM_INFORMATION	0x66
 #define BMIC_WRITE_HOST_WELLNESS		0xa5
-#define BMIC_CACHE_FLUSH			0xc2
+#define BMIC_FLUSH_CACHE			0xc2
 
-#define SA_CACHE_FLUSH				0x1
+#define SA_FLUSH_CACHE				0x1
 
 #define MASKED_DEVICE(lunid)			((lunid)[3] & 0xc0)
 #define CISS_GET_LEVEL_2_BUS(lunid)		((lunid)[7] & 0x3f)
@@ -1109,6 +1109,23 @@ struct bmic_identify_physical_device {
 	u8	padding_to_multiple_of_512[9];
 };
 
+struct bmic_flush_cache {
+	u8	disable_flag;
+	u8	system_power_action;
+	u8	ndu_flush;
+	u8	shutdown_event;
+	u8	reserved[28];
+};
+
+/* for shutdown_event member of struct bmic_flush_cache */
+enum bmic_flush_cache_shutdown_event {
+	NONE_CACHE_FLUSH_ONLY = 0,
+	SHUTDOWN = 1,
+	HIBERNATE = 2,
+	SUSPEND = 3,
+	RESTART = 4
+};
+
 #pragma pack()
 
 int pqi_add_sas_host(struct Scsi_Host *shost, struct pqi_ctrl_info *ctrl_info);
* Unmerged path drivers/scsi/smartpqi/smartpqi_init.c
