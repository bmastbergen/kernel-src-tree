x86/mm: Use proper encryption attributes with /dev/mem

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] mm: Use proper encryption attributes with /dev/mem (Suravee Suthikulpanit) [1361287]
Rebuild_FUZZ: 96.15%
commit-author Tom Lendacky <thomas.lendacky@amd.com>
commit 8458bf94b0399cd1bca6c437366bcafb29c230c5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8458bf94.failed

When accessing memory using /dev/mem (or /dev/kmem) use the proper
encryption attributes when mapping the memory.

To insure the proper attributes are applied when reading or writing
/dev/mem, update the xlate_dev_mem_ptr() function to use memremap()
which will essentially perform the same steps of applying __va for
RAM or using ioremap() if not RAM.

To insure the proper attributes are applied when mmapping /dev/mem,
update the phys_mem_access_prot() to call phys_mem_access_encrypted(),
a new function which will check if the memory should be mapped encrypted
or not. If it is not to be mapped encrypted then the VMA protection
value is updated to remove the encryption bit.

	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
	Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Borislav Petkov <bp@suse.de>
	Cc: Alexander Potapenko <glider@google.com>
	Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Arnd Bergmann <arnd@arndb.de>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brijesh Singh <brijesh.singh@amd.com>
	Cc: Dave Young <dyoung@redhat.com>
	Cc: Dmitry Vyukov <dvyukov@google.com>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
	Cc: Larry Woodman <lwoodman@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Matt Fleming <matt@codeblueprint.co.uk>
	Cc: Michael S. Tsirkin <mst@redhat.com>
	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Radim Krčmář <rkrcmar@redhat.com>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Toshimitsu Kani <toshi.kani@hpe.com>
	Cc: kasan-dev@googlegroups.com
	Cc: kvm@vger.kernel.org
	Cc: linux-arch@vger.kernel.org
	Cc: linux-doc@vger.kernel.org
	Cc: linux-efi@vger.kernel.org
	Cc: linux-mm@kvack.org
Link: http://lkml.kernel.org/r/c917f403ab9f61cbfd455ad6425ed8429a5e7b54.1500319216.git.thomas.lendacky@amd.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 8458bf94b0399cd1bca6c437366bcafb29c230c5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/io.h
#	arch/x86/mm/ioremap.c
diff --cc arch/x86/include/asm/io.h
index fff8cdcbedae,e080a39b2108..000000000000
--- a/arch/x86/include/asm/io.h
+++ b/arch/x86/include/asm/io.h
@@@ -357,4 -375,18 +357,21 @@@ extern void arch_phys_wc_del(int handle
  #define arch_phys_wc_add arch_phys_wc_add
  #endif
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_X86_PAT
+ extern int arch_io_reserve_memtype_wc(resource_size_t start, resource_size_t size);
+ extern void arch_io_free_memtype_wc(resource_size_t start, resource_size_t size);
+ #define arch_io_reserve_memtype_wc arch_io_reserve_memtype_wc
+ #endif
+ 
+ extern bool arch_memremap_can_ram_remap(resource_size_t offset,
+ 					unsigned long size,
+ 					unsigned long flags);
+ #define arch_memremap_can_ram_remap arch_memremap_can_ram_remap
+ 
+ extern bool phys_mem_access_encrypted(unsigned long phys_addr,
+ 				      unsigned long size);
+ 
++>>>>>>> 8458bf94b039 (x86/mm: Use proper encryption attributes with /dev/mem)
  #endif /* _ASM_X86_IO_H */
diff --cc arch/x86/mm/ioremap.c
index b9bd86bd567f,34f0e1847dd6..000000000000
--- a/arch/x86/mm/ioremap.c
+++ b/arch/x86/mm/ioremap.c
@@@ -357,25 -410,266 +355,228 @@@ void *xlate_dev_mem_ptr(unsigned long p
  	return vaddr;
  }
  
 -void unxlate_dev_mem_ptr(phys_addr_t phys, void *addr)
 +void unxlate_dev_mem_ptr(unsigned long phys, void *addr)
  {
- 	if (page_is_ram(phys >> PAGE_SHIFT))
- 		return;
- 
- 	iounmap((void __iomem *)((unsigned long)addr & PAGE_MASK));
+ 	memunmap((void *)((unsigned long)addr & PAGE_MASK));
  }
  
 -/*
 - * Examine the physical address to determine if it is an area of memory
 - * that should be mapped decrypted.  If the memory is not part of the
 - * kernel usable area it was accessed and created decrypted, so these
 - * areas should be mapped decrypted. And since the encryption key can
 - * change across reboots, persistent memory should also be mapped
 - * decrypted.
 - */
 -static bool memremap_should_map_decrypted(resource_size_t phys_addr,
 -					  unsigned long size)
 -{
 -	int is_pmem;
 -
 -	/*
 -	 * Check if the address is part of a persistent memory region.
 -	 * This check covers areas added by E820, EFI and ACPI.
 -	 */
 -	is_pmem = region_intersects(phys_addr, size, IORESOURCE_MEM,
 -				    IORES_DESC_PERSISTENT_MEMORY);
 -	if (is_pmem != REGION_DISJOINT)
 -		return true;
 +static int __initdata early_ioremap_debug;
  
 -	/*
 -	 * Check if the non-volatile attribute is set for an EFI
 -	 * reserved area.
 -	 */
 -	if (efi_enabled(EFI_BOOT)) {
 -		switch (efi_mem_type(phys_addr)) {
 -		case EFI_RESERVED_TYPE:
 -			if (efi_mem_attributes(phys_addr) & EFI_MEMORY_NV)
 -				return true;
 -			break;
 -		default:
 -			break;
 -		}
 -	}
 -
 -	/* Check if the address is outside kernel usable area */
 -	switch (e820__get_entry_type(phys_addr, phys_addr + size - 1)) {
 -	case E820_TYPE_RESERVED:
 -	case E820_TYPE_ACPI:
 -	case E820_TYPE_NVS:
 -	case E820_TYPE_UNUSABLE:
 -	case E820_TYPE_PRAM:
 -		return true;
 -	default:
 -		break;
 -	}
 +static int __init early_ioremap_debug_setup(char *str)
 +{
 +	early_ioremap_debug = 1;
  
 -	return false;
 +	return 0;
  }
 +early_param("early_ioremap_debug", early_ioremap_debug_setup);
  
++<<<<<<< HEAD
 +static __initdata int after_paging_init;
++=======
+ /*
+  * Examine the physical address to determine if it is EFI data. Check
+  * it against the boot params structure and EFI tables and memory types.
+  */
+ static bool memremap_is_efi_data(resource_size_t phys_addr,
+ 				 unsigned long size)
+ {
+ 	u64 paddr;
+ 
+ 	/* Check if the address is part of EFI boot/runtime data */
+ 	if (!efi_enabled(EFI_BOOT))
+ 		return false;
+ 
+ 	paddr = boot_params.efi_info.efi_memmap_hi;
+ 	paddr <<= 32;
+ 	paddr |= boot_params.efi_info.efi_memmap;
+ 	if (phys_addr == paddr)
+ 		return true;
+ 
+ 	paddr = boot_params.efi_info.efi_systab_hi;
+ 	paddr <<= 32;
+ 	paddr |= boot_params.efi_info.efi_systab;
+ 	if (phys_addr == paddr)
+ 		return true;
+ 
+ 	if (efi_is_table_address(phys_addr))
+ 		return true;
+ 
+ 	switch (efi_mem_type(phys_addr)) {
+ 	case EFI_BOOT_SERVICES_DATA:
+ 	case EFI_RUNTIME_SERVICES_DATA:
+ 		return true;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return false;
+ }
+ 
+ /*
+  * Examine the physical address to determine if it is boot data by checking
+  * it against the boot params setup_data chain.
+  */
+ static bool memremap_is_setup_data(resource_size_t phys_addr,
+ 				   unsigned long size)
+ {
+ 	struct setup_data *data;
+ 	u64 paddr, paddr_next;
+ 
+ 	paddr = boot_params.hdr.setup_data;
+ 	while (paddr) {
+ 		unsigned int len;
+ 
+ 		if (phys_addr == paddr)
+ 			return true;
+ 
+ 		data = memremap(paddr, sizeof(*data),
+ 				MEMREMAP_WB | MEMREMAP_DEC);
+ 
+ 		paddr_next = data->next;
+ 		len = data->len;
+ 
+ 		memunmap(data);
+ 
+ 		if ((phys_addr > paddr) && (phys_addr < (paddr + len)))
+ 			return true;
+ 
+ 		paddr = paddr_next;
+ 	}
+ 
+ 	return false;
+ }
+ 
+ /*
+  * Examine the physical address to determine if it is boot data by checking
+  * it against the boot params setup_data chain (early boot version).
+  */
+ static bool __init early_memremap_is_setup_data(resource_size_t phys_addr,
+ 						unsigned long size)
+ {
+ 	struct setup_data *data;
+ 	u64 paddr, paddr_next;
+ 
+ 	paddr = boot_params.hdr.setup_data;
+ 	while (paddr) {
+ 		unsigned int len;
+ 
+ 		if (phys_addr == paddr)
+ 			return true;
+ 
+ 		data = early_memremap_decrypted(paddr, sizeof(*data));
+ 
+ 		paddr_next = data->next;
+ 		len = data->len;
+ 
+ 		early_memunmap(data, sizeof(*data));
+ 
+ 		if ((phys_addr > paddr) && (phys_addr < (paddr + len)))
+ 			return true;
+ 
+ 		paddr = paddr_next;
+ 	}
+ 
+ 	return false;
+ }
+ 
+ /*
+  * Architecture function to determine if RAM remap is allowed. By default, a
+  * RAM remap will map the data as encrypted. Determine if a RAM remap should
+  * not be done so that the data will be mapped decrypted.
+  */
+ bool arch_memremap_can_ram_remap(resource_size_t phys_addr, unsigned long size,
+ 				 unsigned long flags)
+ {
+ 	if (!sme_active())
+ 		return true;
+ 
+ 	if (flags & MEMREMAP_ENC)
+ 		return true;
+ 
+ 	if (flags & MEMREMAP_DEC)
+ 		return false;
+ 
+ 	if (memremap_is_setup_data(phys_addr, size) ||
+ 	    memremap_is_efi_data(phys_addr, size) ||
+ 	    memremap_should_map_decrypted(phys_addr, size))
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ /*
+  * Architecture override of __weak function to adjust the protection attributes
+  * used when remapping memory. By default, early_memremap() will map the data
+  * as encrypted. Determine if an encrypted mapping should not be done and set
+  * the appropriate protection attributes.
+  */
+ pgprot_t __init early_memremap_pgprot_adjust(resource_size_t phys_addr,
+ 					     unsigned long size,
+ 					     pgprot_t prot)
+ {
+ 	if (!sme_active())
+ 		return prot;
+ 
+ 	if (early_memremap_is_setup_data(phys_addr, size) ||
+ 	    memremap_is_efi_data(phys_addr, size) ||
+ 	    memremap_should_map_decrypted(phys_addr, size))
+ 		prot = pgprot_decrypted(prot);
+ 	else
+ 		prot = pgprot_encrypted(prot);
+ 
+ 	return prot;
+ }
+ 
+ bool phys_mem_access_encrypted(unsigned long phys_addr, unsigned long size)
+ {
+ 	return arch_memremap_can_ram_remap(phys_addr, size, 0);
+ }
+ 
+ #ifdef CONFIG_ARCH_USE_MEMREMAP_PROT
+ /* Remap memory with encryption */
+ void __init *early_memremap_encrypted(resource_size_t phys_addr,
+ 				      unsigned long size)
+ {
+ 	return early_memremap_prot(phys_addr, size, __PAGE_KERNEL_ENC);
+ }
+ 
+ /*
+  * Remap memory with encryption and write-protected - cannot be called
+  * before pat_init() is called
+  */
+ void __init *early_memremap_encrypted_wp(resource_size_t phys_addr,
+ 					 unsigned long size)
+ {
+ 	/* Be sure the write-protect PAT entry is set for write-protect */
+ 	if (__pte2cachemode_tbl[_PAGE_CACHE_MODE_WP] != _PAGE_CACHE_MODE_WP)
+ 		return NULL;
+ 
+ 	return early_memremap_prot(phys_addr, size, __PAGE_KERNEL_ENC_WP);
+ }
+ 
+ /* Remap memory without encryption */
+ void __init *early_memremap_decrypted(resource_size_t phys_addr,
+ 				      unsigned long size)
+ {
+ 	return early_memremap_prot(phys_addr, size, __PAGE_KERNEL_NOENC);
+ }
+ 
+ /*
+  * Remap memory without encryption and write-protected - cannot be called
+  * before pat_init() is called
+  */
+ void __init *early_memremap_decrypted_wp(resource_size_t phys_addr,
+ 					 unsigned long size)
+ {
+ 	/* Be sure the write-protect PAT entry is set for write-protect */
+ 	if (__pte2cachemode_tbl[_PAGE_CACHE_MODE_WP] != _PAGE_CACHE_MODE_WP)
+ 		return NULL;
+ 
+ 	return early_memremap_prot(phys_addr, size, __PAGE_KERNEL_NOENC_WP);
+ }
+ #endif	/* CONFIG_ARCH_USE_MEMREMAP_PROT */
+ 
++>>>>>>> 8458bf94b039 (x86/mm: Use proper encryption attributes with /dev/mem)
  static pte_t bm_pte[PAGE_SIZE/sizeof(pte_t)] __page_aligned_bss;
  
  static inline pmd_t * __init early_ioremap_pmd(unsigned long addr)
* Unmerged path arch/x86/include/asm/io.h
* Unmerged path arch/x86/mm/ioremap.c
diff --git a/arch/x86/mm/pat.c b/arch/x86/mm/pat.c
index 25b8aa9d4620..debad9d4cf2a 100644
--- a/arch/x86/mm/pat.c
+++ b/arch/x86/mm/pat.c
@@ -489,6 +489,9 @@ void io_free_memtype(resource_size_t start, resource_size_t end)
 pgprot_t phys_mem_access_prot(struct file *file, unsigned long pfn,
 				unsigned long size, pgprot_t vma_prot)
 {
+	if (!phys_mem_access_encrypted(pfn << PAGE_SHIFT, size))
+		vma_prot = pgprot_decrypted(vma_prot);
+
 	return vma_prot;
 }
 
