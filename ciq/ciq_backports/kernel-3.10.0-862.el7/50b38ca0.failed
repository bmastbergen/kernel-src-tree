sysfs, kernfs: prepare write path for kernfs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Tejun Heo <tj@kernel.org>
commit 50b38ca086e4d9920eede98b871b971e9958d70d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/50b38ca0.failed

We're in the process of separating out core sysfs functionality into
kernfs which will deal with sysfs_dirents directly.  This patch
rearranges write path so that the kernfs and sysfs parts are separate.

kernfs_file_write() handles all boilerplate work including buffer
management and locking and invokes sysfs_kf_write() or
sysfs_kf_bin_write() depending on the file type which deals with the
interaction with kobj store or bin_attribute write method.

While this patch changes the order of some operations, it shouldn't
change any visible behavior.

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 50b38ca086e4d9920eede98b871b971e9958d70d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/sysfs/file.c
diff --cc fs/sysfs/file.c
index d8887c896abc,2f849e82c0eb..000000000000
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@@ -98,146 -121,455 +98,383 @@@ static int fill_read_buffer(struct dent
  		/* Try to struggle along */
  		count = PAGE_SIZE - 1;
  	}
++<<<<<<< HEAD
 +	if (count >= 0) {
 +		buffer->needs_read_fill = 0;
 +		buffer->count = count;
 +	} else {
 +		ret = count;
 +	}
 +	return ret;
 +}
 +
 +/**
 + *	sysfs_read_file - read an attribute.
 + *	@file:	file pointer.
 + *	@buf:	buffer to fill.
 + *	@count:	number of bytes to read.
 + *	@ppos:	starting offset in file.
 + *
 + *	Userspace wants to read an attribute file. The attribute descriptor
 + *	is in the file's ->d_fsdata. The target object is in the directory's
 + *	->d_fsdata.
++=======
+ 	seq_commit(sf, count);
+ 	return 0;
+ }
+ 
+ static ssize_t sysfs_kf_bin_read(struct sysfs_open_file *of, char *buf,
+ 				 size_t count, loff_t pos)
+ {
+ 	struct bin_attribute *battr = of->sd->priv;
+ 	struct kobject *kobj = of->sd->s_parent->priv;
+ 	loff_t size = file_inode(of->file)->i_size;
+ 
+ 	if (!count)
+ 		return 0;
+ 
+ 	if (size) {
+ 		if (pos > size)
+ 			return 0;
+ 		if (pos + count > size)
+ 			count = size - pos;
+ 	}
+ 
+ 	if (!battr->read)
+ 		return -EIO;
+ 
+ 	return battr->read(of->file, kobj, battr, buf, pos, count);
+ }
+ 
+ static void *kernfs_seq_start(struct seq_file *sf, loff_t *ppos)
+ {
+ 	struct sysfs_open_file *of = sf->private;
+ 
+ 	/*
+ 	 * @of->mutex nests outside active ref and is just to ensure that
+ 	 * the ops aren't called concurrently for the same open file.
+ 	 */
+ 	mutex_lock(&of->mutex);
+ 	if (!sysfs_get_active(of->sd))
+ 		return ERR_PTR(-ENODEV);
+ 
+ 	/*
+ 	 * The same behavior and code as single_open().  Returns !NULL if
+ 	 * pos is at the beginning; otherwise, NULL.
+ 	 */
+ 	return NULL + !*ppos;
+ }
+ 
+ static void *kernfs_seq_next(struct seq_file *sf, void *v, loff_t *ppos)
+ {
+ 	/*
+ 	 * The same behavior and code as single_open(), always terminate
+ 	 * after the initial read.
+ 	 */
+ 	++*ppos;
+ 	return NULL;
+ }
+ 
+ static void kernfs_seq_stop(struct seq_file *sf, void *v)
+ {
+ 	struct sysfs_open_file *of = sf->private;
+ 
+ 	sysfs_put_active(of->sd);
+ 	mutex_unlock(&of->mutex);
+ }
+ 
+ static int kernfs_seq_show(struct seq_file *sf, void *v)
+ {
+ 	struct sysfs_open_file *of = sf->private;
+ 
+ 	of->event = atomic_read(&of->sd->s_attr.open->event);
+ 
+ 	return sysfs_kf_seq_show(sf, v);
+ }
+ 
+ static const struct seq_operations kernfs_seq_ops = {
+ 	.start = kernfs_seq_start,
+ 	.next = kernfs_seq_next,
+ 	.stop = kernfs_seq_stop,
+ 	.show = kernfs_seq_show,
+ };
+ 
+ /*
+  * As reading a bin file can have side-effects, the exact offset and bytes
+  * specified in read(2) call should be passed to the read callback making
+  * it difficult to use seq_file.  Implement simplistic custom buffering for
+  * bin files.
+  */
+ static ssize_t kernfs_file_direct_read(struct sysfs_open_file *of,
+ 				       char __user *user_buf, size_t count,
+ 				       loff_t *ppos)
+ {
+ 	ssize_t len = min_t(size_t, count, PAGE_SIZE);
+ 	char *buf;
+ 
+ 	buf = kmalloc(len, GFP_KERNEL);
+ 	if (!buf)
+ 		return -ENOMEM;
+ 
+ 	/*
+ 	 * @of->mutex nests outside active ref and is just to ensure that
+ 	 * the ops aren't called concurrently for the same open file.
+ 	 */
+ 	mutex_lock(&of->mutex);
+ 	if (!sysfs_get_active(of->sd)) {
+ 		len = -ENODEV;
+ 		mutex_unlock(&of->mutex);
+ 		goto out_free;
+ 	}
+ 
+ 	len = sysfs_kf_bin_read(of, buf, len, *ppos);
+ 
+ 	sysfs_put_active(of->sd);
+ 	mutex_unlock(&of->mutex);
+ 
+ 	if (len < 0)
+ 		goto out_free;
+ 
+ 	if (copy_to_user(user_buf, buf, len)) {
+ 		len = -EFAULT;
+ 		goto out_free;
+ 	}
+ 
+ 	*ppos += len;
+ 
+  out_free:
+ 	kfree(buf);
+ 	return len;
+ }
+ 
+ /**
+  * kernfs_file_read - kernfs vfs read callback
+  * @file: file pointer
+  * @user_buf: data to write
+  * @count: number of bytes
+  * @ppos: starting offset
+  */
+ static ssize_t kernfs_file_read(struct file *file, char __user *user_buf,
+ 				size_t count, loff_t *ppos)
+ {
+ 	struct sysfs_open_file *of = sysfs_of(file);
+ 
+ 	if (sysfs_is_bin(of->sd))
+ 		return kernfs_file_direct_read(of, user_buf, count, ppos);
+ 	else
+ 		return seq_read(file, user_buf, count, ppos);
+ }
+ 
+ /* kernfs write callback for regular sysfs files */
+ static ssize_t sysfs_kf_write(struct sysfs_open_file *of, char *buf,
+ 			      size_t count, loff_t pos)
+ {
+ 	const struct sysfs_ops *ops = sysfs_file_ops(of->sd);
+ 	struct kobject *kobj = of->sd->s_parent->priv;
+ 
+ 	if (!count)
+ 		return 0;
+ 
+ 	return ops->store(kobj, of->sd->priv, buf, count);
+ }
+ 
+ /* kernfs write callback for bin sysfs files */
+ static ssize_t sysfs_kf_bin_write(struct sysfs_open_file *of, char *buf,
+ 				  size_t count, loff_t pos)
+ {
+ 	struct bin_attribute *battr = of->sd->priv;
+ 	struct kobject *kobj = of->sd->s_parent->priv;
+ 	loff_t size = file_inode(of->file)->i_size;
+ 
+ 	if (size) {
+ 		if (size <= pos)
+ 			return 0;
+ 		count = min_t(ssize_t, count, size - pos);
+ 	}
+ 	if (!count)
+ 		return 0;
+ 
+ 	if (!battr->write)
+ 		return -EIO;
+ 
+ 	return battr->write(of->file, kobj, battr, buf, pos, count);
+ }
+ 
+ /**
+  * kernfs_file_write - kernfs vfs write callback
+  * @file: file pointer
+  * @user_buf: data to write
+  * @count: number of bytes
+  * @ppos: starting offset
+  *
+  * Copy data in from userland and pass it to the matching kernfs write
+  * operation.
++>>>>>>> 50b38ca086e4 (sysfs, kernfs: prepare write path for kernfs)
 + *
 + *	We call fill_read_buffer() to allocate and fill the buffer from the
 + *	object's show() method exactly once (if the read is happening from
 + *	the beginning of the file). That should fill the entire buffer with
 + *	all the data the object has to offer for that attribute.
 + *	We then call flush_read_buffer() to copy the buffer to userspace
 + *	in the increments specified.
 + */
++<<<<<<< HEAD
 +
 +static ssize_t
 +sysfs_read_file(struct file *file, char __user *buf, size_t count, loff_t *ppos)
 +{
 +	struct sysfs_buffer * buffer = file->private_data;
 +	ssize_t retval = 0;
 +
 +	mutex_lock(&buffer->mutex);
 +	if (buffer->needs_read_fill || *ppos == 0) {
 +		retval = fill_read_buffer(file->f_path.dentry,buffer);
 +		if (retval)
 +			goto out;
 +	}
 +	pr_debug("%s: count = %zd, ppos = %lld, buf = %s\n",
 +		 __func__, count, *ppos, buffer->page);
 +	retval = simple_read_from_buffer(buf, count, ppos, buffer->page,
 +					 buffer->count);
 +out:
 +	mutex_unlock(&buffer->mutex);
 +	return retval;
 +}
 +
 +/**
 + *	fill_write_buffer - copy buffer from userspace.
 + *	@buffer:	data buffer for file.
 + *	@buf:		data from user.
 + *	@count:		number of bytes in @userbuf.
   *
 - * There is no easy way for us to know if userspace is only doing a partial
 - * write, so we don't support them. We expect the entire buffer to come on
 - * the first write.  Hint: if you're writing a value, first read the file,
 - * modify only the the value you're changing, then write entire buffer
 - * back.
 + *	Allocate @buffer->page if it hasn't been already, then
 + *	copy the user-supplied buffer into it.
   */
 +static int fill_write_buffer(struct sysfs_buffer * buffer,
 +			     const char __user * buf, size_t count)
 +{
 +	int error;
 +
 +	if (!buffer->page)
 +		buffer->page = (char *)get_zeroed_page(GFP_KERNEL);
 +	if (!buffer->page)
 +		return -ENOMEM;
 +
 +	if (count >= PAGE_SIZE)
 +		count = PAGE_SIZE - 1;
 +	error = copy_from_user(buffer->page,buf,count);
 +	buffer->needs_read_fill = 1;
 +	/* if buf is assumed to contain a string, terminate it by \0,
 +	   so e.g. sscanf() can scan the string easily */
 +	buffer->page[count] = 0;
 +	return error ? -EFAULT : count;
++=======
+ static ssize_t kernfs_file_write(struct file *file, const char __user *user_buf,
+ 				 size_t count, loff_t *ppos)
+ {
+ 	struct sysfs_open_file *of = sysfs_of(file);
+ 	ssize_t len = min_t(size_t, count, PAGE_SIZE);
+ 	char *buf;
+ 
+ 	buf = kmalloc(len + 1, GFP_KERNEL);
+ 	if (!buf)
+ 		return -ENOMEM;
+ 
+ 	if (copy_from_user(buf, user_buf, len)) {
+ 		len = -EFAULT;
+ 		goto out_free;
+ 	}
+ 	buf[len] = '\0';	/* guarantee string termination */
+ 
+ 	/*
+ 	 * @of->mutex nests outside active ref and is just to ensure that
+ 	 * the ops aren't called concurrently for the same open file.
+ 	 */
+ 	mutex_lock(&of->mutex);
+ 	if (!sysfs_get_active(of->sd)) {
+ 		mutex_unlock(&of->mutex);
+ 		len = -ENODEV;
+ 		goto out_free;
+ 	}
+ 
+ 	if (sysfs_is_bin(of->sd))
+ 		len = sysfs_kf_bin_write(of, buf, len, *ppos);
+ 	else
+ 		len = sysfs_kf_write(of, buf, len, *ppos);
+ 
+ 	sysfs_put_active(of->sd);
+ 	mutex_unlock(&of->mutex);
+ 
+ 	if (len > 0)
+ 		*ppos += len;
+ out_free:
+ 	kfree(buf);
+ 	return len;
++>>>>>>> 50b38ca086e4 (sysfs, kernfs: prepare write path for kernfs)
  }
  
 -static void sysfs_bin_vma_open(struct vm_area_struct *vma)
 -{
 -	struct file *file = vma->vm_file;
 -	struct sysfs_open_file *of = sysfs_of(file);
 -
 -	if (!of->vm_ops)
 -		return;
 -
 -	if (!sysfs_get_active(of->sd))
 -		return;
 -
 -	if (of->vm_ops->open)
 -		of->vm_ops->open(vma);
 -
 -	sysfs_put_active(of->sd);
 -}
 -
 -static int sysfs_bin_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
 -{
 -	struct file *file = vma->vm_file;
 -	struct sysfs_open_file *of = sysfs_of(file);
 -	int ret;
 -
 -	if (!of->vm_ops)
 -		return VM_FAULT_SIGBUS;
 -
 -	if (!sysfs_get_active(of->sd))
 -		return VM_FAULT_SIGBUS;
 -
 -	ret = VM_FAULT_SIGBUS;
 -	if (of->vm_ops->fault)
 -		ret = of->vm_ops->fault(vma, vmf);
 -
 -	sysfs_put_active(of->sd);
 -	return ret;
 -}
 -
 -static int sysfs_bin_page_mkwrite(struct vm_area_struct *vma,
 -				  struct vm_fault *vmf)
 -{
 -	struct file *file = vma->vm_file;
 -	struct sysfs_open_file *of = sysfs_of(file);
 -	int ret;
 -
 -	if (!of->vm_ops)
 -		return VM_FAULT_SIGBUS;
 -
 -	if (!sysfs_get_active(of->sd))
 -		return VM_FAULT_SIGBUS;
 -
 -	ret = 0;
 -	if (of->vm_ops->page_mkwrite)
 -		ret = of->vm_ops->page_mkwrite(vma, vmf);
 -	else
 -		file_update_time(file);
 -
 -	sysfs_put_active(of->sd);
 -	return ret;
 -}
 -
 -static int sysfs_bin_access(struct vm_area_struct *vma, unsigned long addr,
 -			    void *buf, int len, int write)
 -{
 -	struct file *file = vma->vm_file;
 -	struct sysfs_open_file *of = sysfs_of(file);
 -	int ret;
 -
 -	if (!of->vm_ops)
 -		return -EINVAL;
 -
 -	if (!sysfs_get_active(of->sd))
 -		return -EINVAL;
  
 -	ret = -EINVAL;
 -	if (of->vm_ops->access)
 -		ret = of->vm_ops->access(vma, addr, buf, len, write);
 -
 -	sysfs_put_active(of->sd);
 -	return ret;
 -}
 -
 -#ifdef CONFIG_NUMA
 -static int sysfs_bin_set_policy(struct vm_area_struct *vma,
 -				struct mempolicy *new)
 -{
 -	struct file *file = vma->vm_file;
 -	struct sysfs_open_file *of = sysfs_of(file);
 -	int ret;
 -
 -	if (!of->vm_ops)
 -		return 0;
 -
 -	if (!sysfs_get_active(of->sd))
 -		return -EINVAL;
 -
 -	ret = 0;
 -	if (of->vm_ops->set_policy)
 -		ret = of->vm_ops->set_policy(vma, new);
 -
 -	sysfs_put_active(of->sd);
 -	return ret;
 -}
 -
 -static struct mempolicy *sysfs_bin_get_policy(struct vm_area_struct *vma,
 -					      unsigned long addr)
 +/**
 + *	flush_write_buffer - push buffer to kobject.
 + *	@dentry:	dentry to the attribute
 + *	@buffer:	data buffer for file.
 + *	@count:		number of bytes
 + *
 + *	Get the correct pointers for the kobject and the attribute we're
 + *	dealing with, then call the store() method for the attribute,
 + *	passing the buffer that we acquired in fill_write_buffer().
 + */
 +static int
 +flush_write_buffer(struct dentry * dentry, struct sysfs_buffer * buffer, size_t count)
  {
 -	struct file *file = vma->vm_file;
 -	struct sysfs_open_file *of = sysfs_of(file);
 -	struct mempolicy *pol;
 +	struct sysfs_dirent *attr_sd = dentry->d_fsdata;
 +	struct kobject *kobj = attr_sd->s_parent->s_dir.kobj;
 +	const struct sysfs_ops * ops = buffer->ops;
 +	int rc;
  
 -	if (!of->vm_ops)
 -		return vma->vm_policy;
 +	/* need attr_sd for attr and ops, its parent for kobj */
 +	if (!sysfs_get_active(attr_sd))
 +		return -ENODEV;
  
 -	if (!sysfs_get_active(of->sd))
 -		return vma->vm_policy;
 +	rc = ops->store(kobj, attr_sd->s_attr.attr, buffer->page, count);
  
 -	pol = vma->vm_policy;
 -	if (of->vm_ops->get_policy)
 -		pol = of->vm_ops->get_policy(vma, addr);
 +	sysfs_put_active(attr_sd);
  
 -	sysfs_put_active(of->sd);
 -	return pol;
 +	return rc;
  }
  
 -static int sysfs_bin_migrate(struct vm_area_struct *vma, const nodemask_t *from,
 -			     const nodemask_t *to, unsigned long flags)
 -{
 -	struct file *file = vma->vm_file;
 -	struct sysfs_open_file *of = sysfs_of(file);
 -	int ret;
 -
 -	if (!of->vm_ops)
 -		return 0;
 -
 -	if (!sysfs_get_active(of->sd))
 -		return 0;
  
 -	ret = 0;
 -	if (of->vm_ops->migrate)
 -		ret = of->vm_ops->migrate(vma, from, to, flags);
 -
 -	sysfs_put_active(of->sd);
 -	return ret;
 -}
 -#endif
 -
 -static const struct vm_operations_struct sysfs_bin_vm_ops = {
 -	.open		= sysfs_bin_vma_open,
 -	.fault		= sysfs_bin_fault,
 -	.page_mkwrite	= sysfs_bin_page_mkwrite,
 -	.access		= sysfs_bin_access,
 -#ifdef CONFIG_NUMA
 -	.set_policy	= sysfs_bin_set_policy,
 -	.get_policy	= sysfs_bin_get_policy,
 -	.migrate	= sysfs_bin_migrate,
 -#endif
 -};
 +/**
 + *	sysfs_write_file - write an attribute.
 + *	@file:	file pointer
 + *	@buf:	data to write
 + *	@count:	number of bytes
 + *	@ppos:	starting offset
 + *
 + *	Similar to sysfs_read_file(), though working in the opposite direction.
 + *	We allocate and fill the data from the user in fill_write_buffer(),
 + *	then push it to the kobject in flush_write_buffer().
 + *	There is no easy way for us to know if userspace is only doing a partial
 + *	write, so we don't support them. We expect the entire buffer to come
 + *	on the first write.
 + *	Hint: if you're writing a value, first read the file, modify only the
 + *	the value you're changing, then write entire buffer back.
 + */
  
 -static int sysfs_bin_mmap(struct file *file, struct vm_area_struct *vma)
 +static ssize_t
 +sysfs_write_file(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
  {
 -	struct sysfs_open_file *of = sysfs_of(file);
 -	struct bin_attribute *battr = of->sd->priv;
 -	struct kobject *kobj = of->sd->s_parent->priv;
 -	int rc;
 -
 -	mutex_lock(&of->mutex);
 +	struct sysfs_buffer * buffer = file->private_data;
 +	ssize_t len;
  
 -	/* need of->sd for battr, its parent for kobj */
 -	rc = -ENODEV;
 -	if (!sysfs_get_active(of->sd))
 -		goto out_unlock;
 -
 -	if (!battr->mmap)
 -		goto out_put;
 -
 -	rc = battr->mmap(file, kobj, battr, vma);
 -	if (rc)
 -		goto out_put;
 -
 -	/*
 -	 * PowerPC's pci_mmap of legacy_mem uses shmem_zero_setup()
 -	 * to satisfy versions of X which crash if the mmap fails: that
 -	 * substitutes a new vm_file, and we don't then want bin_vm_ops.
 -	 */
 -	if (vma->vm_file != file)
 -		goto out_put;
 -
 -	rc = -EINVAL;
 -	if (of->mmapped && of->vm_ops != vma->vm_ops)
 -		goto out_put;
 -
 -	/*
 -	 * It is not possible to successfully wrap close.
 -	 * So error if someone is trying to use close.
 -	 */
 -	rc = -EINVAL;
 -	if (vma->vm_ops && vma->vm_ops->close)
 -		goto out_put;
 -
 -	rc = 0;
 -	of->mmapped = 1;
 -	of->vm_ops = vma->vm_ops;
 -	vma->vm_ops = &sysfs_bin_vm_ops;
 -out_put:
 -	sysfs_put_active(of->sd);
 -out_unlock:
 -	mutex_unlock(&of->mutex);
 -
 -	return rc;
 +	mutex_lock(&buffer->mutex);
 +	len = fill_write_buffer(buffer, buf, count);
 +	if (len > 0)
 +		len = flush_write_buffer(file->f_path.dentry, buffer, len);
 +	if (len > 0)
 +		*ppos += len;
 +	mutex_unlock(&buffer->mutex);
 +	return len;
  }
  
  /**
@@@ -484,55 -874,27 +721,72 @@@ void sysfs_notify(struct kobject *k, co
  EXPORT_SYMBOL_GPL(sysfs_notify);
  
  const struct file_operations sysfs_file_operations = {
++<<<<<<< HEAD
 +	.read		= sysfs_read_file,
 +	.write		= sysfs_write_file,
++=======
+ 	.read		= kernfs_file_read,
+ 	.write		= kernfs_file_write,
++>>>>>>> 50b38ca086e4 (sysfs, kernfs: prepare write path for kernfs)
  	.llseek		= generic_file_llseek,
  	.open		= sysfs_open_file,
  	.release	= sysfs_release,
  	.poll		= sysfs_poll,
  };
  
++<<<<<<< HEAD
 +static int sysfs_attr_ns(struct kobject *kobj, const struct attribute *attr,
 +			 const void **pns)
 +{
 +	struct sysfs_dirent *dir_sd = kobj->sd;
 +	const struct sysfs_ops *ops;
 +	const void *ns = NULL;
 +	int err;
++=======
+ const struct file_operations sysfs_bin_operations = {
+ 	.read		= kernfs_file_read,
+ 	.write		= kernfs_file_write,
+ 	.llseek		= generic_file_llseek,
+ 	.mmap		= sysfs_bin_mmap,
+ 	.open		= sysfs_open_file,
+ 	.release	= sysfs_release,
+ 	.poll		= sysfs_poll,
+ };
++>>>>>>> 50b38ca086e4 (sysfs, kernfs: prepare write path for kernfs)
 +
 +	if (!dir_sd) {
 +		WARN(1, KERN_ERR "sysfs: kobject %s without dirent\n",
 +			kobject_name(kobj));
 +		return -ENOENT;
 +	}
  
 -int sysfs_add_file_mode_ns(struct sysfs_dirent *dir_sd,
 -			   const struct attribute *attr, int type,
 -			   umode_t amode, const void *ns)
 +	err = 0;
 +	if (!sysfs_ns_type(dir_sd))
 +		goto out;
 +
 +	err = -EINVAL;
 +	if (!kobj->ktype)
 +		goto out;
 +	ops = kobj->ktype->sysfs_ops;
 +	if (!ops)
 +		goto out;
 +	if (!ops->namespace)
 +		goto out;
 +
 +	err = 0;
 +	ns = ops->namespace(kobj, attr);
 +out:
 +	if (err) {
 +		WARN(1, KERN_ERR
 +		     "missing sysfs namespace attribute operation for kobject: %s\n",
 +		     kobject_name(kobj));
 +	}
 +	*pns = ns;
 +	return err;
 +}
 +
 +int sysfs_add_file_mode(struct sysfs_dirent *dir_sd,
 +			const struct attribute *attr, int type, umode_t amode)
  {
  	umode_t mode = (amode & S_IALLUGO) | S_IFREG;
  	struct sysfs_addrm_cxt acxt;
* Unmerged path fs/sysfs/file.c
