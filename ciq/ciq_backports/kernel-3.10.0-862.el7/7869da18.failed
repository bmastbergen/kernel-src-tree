scsi: lpfc: Fix NMI watchdog assertions when running nvmet IOPS tests

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] lpfc: Fix NMI watchdog assertions when running nvmet IOPS tests (Dick Kennedy) [1385844 1461977 1387768]
Rebuild_FUZZ: 95.45%
commit-author James Smart <jsmart2021@gmail.com>
commit 7869da183a7cfc8a2189f6eddd3bc558be40d5e3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/7869da18.failed

After running IOPS test for 30 second we get kernel:NMI watchdog:
Watchdog detected hard LOCKUP on cpu 0

The driver is speend too much time in its ISR.

In ISR EQ and CQ processing routines, if we hit the entry_repost numbers
of EQE/CQEs just break out of the routine as opposed to hitting the
doorbell with NOARM and continue processing.

	Signed-off-by: Dick Kennedy <dick.kennedy@broadcom.com>
	Signed-off-by: James Smart <james.smart@broadcom.com>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 7869da183a7cfc8a2189f6eddd3bc558be40d5e3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_debugfs.c
#	drivers/scsi/lpfc/lpfc_sli.c
diff --cc drivers/scsi/lpfc/lpfc_debugfs.c
index e6cf568b0f02,7284533f4df2..000000000000
--- a/drivers/scsi/lpfc/lpfc_debugfs.c
+++ b/drivers/scsi/lpfc/lpfc_debugfs.c
@@@ -1988,6 -3061,201 +1988,204 @@@ error_out
  	return -EINVAL;
  }
  
++<<<<<<< HEAD
++=======
+ static int
+ __lpfc_idiag_print_wq(struct lpfc_queue *qp, char *wqtype,
+ 			char *pbuffer, int len)
+ {
+ 	if (!qp)
+ 		return len;
+ 
+ 	len += snprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,
+ 			"\t\t%s WQ info: ", wqtype);
+ 	len += snprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,
+ 			"AssocCQID[%04d]: WQ-STAT[oflow:x%x posted:x%llx]\n",
+ 			qp->assoc_qid, qp->q_cnt_1,
+ 			(unsigned long long)qp->q_cnt_4);
+ 	len += snprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,
+ 			"\t\tWQID[%02d], QE-CNT[%04d], QE-SZ[%04d], "
+ 			"HST-IDX[%04d], PRT-IDX[%04d], PST[%03d]",
+ 			qp->queue_id, qp->entry_count,
+ 			qp->entry_size, qp->host_index,
+ 			qp->hba_index, qp->entry_repost);
+ 	len +=  snprintf(pbuffer + len,
+ 			LPFC_QUE_INFO_GET_BUF_SIZE - len, "\n");
+ 	return len;
+ }
+ 
+ static int
+ lpfc_idiag_wqs_for_cq(struct lpfc_hba *phba, char *wqtype, char *pbuffer,
+ 		int *len, int max_cnt, int cq_id)
+ {
+ 	struct lpfc_queue *qp;
+ 	int qidx;
+ 
+ 	for (qidx = 0; qidx < phba->cfg_fcp_io_channel; qidx++) {
+ 		qp = phba->sli4_hba.fcp_wq[qidx];
+ 		if (qp->assoc_qid != cq_id)
+ 			continue;
+ 		*len = __lpfc_idiag_print_wq(qp, wqtype, pbuffer, *len);
+ 		if (*len >= max_cnt)
+ 			return 1;
+ 	}
+ 	for (qidx = 0; qidx < phba->cfg_nvme_io_channel; qidx++) {
+ 		qp = phba->sli4_hba.nvme_wq[qidx];
+ 		if (qp->assoc_qid != cq_id)
+ 			continue;
+ 		*len = __lpfc_idiag_print_wq(qp, wqtype, pbuffer, *len);
+ 		if (*len >= max_cnt)
+ 			return 1;
+ 	}
+ 	return 0;
+ }
+ 
+ static int
+ __lpfc_idiag_print_cq(struct lpfc_queue *qp, char *cqtype,
+ 			char *pbuffer, int len)
+ {
+ 	if (!qp)
+ 		return len;
+ 
+ 	len += snprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,
+ 			"\t%s CQ info: ", cqtype);
+ 	len += snprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,
+ 			"AssocEQID[%02d]: CQ STAT[max:x%x relw:x%x "
+ 			"xabt:x%x wq:x%llx]\n",
+ 			qp->assoc_qid, qp->q_cnt_1, qp->q_cnt_2,
+ 			qp->q_cnt_3, (unsigned long long)qp->q_cnt_4);
+ 	len += snprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,
+ 			"\tCQID[%02d], QE-CNT[%04d], QE-SZ[%04d], "
+ 			"HST-IDX[%04d], PRT-IDX[%04d], PST[%03d]",
+ 			qp->queue_id, qp->entry_count,
+ 			qp->entry_size, qp->host_index,
+ 			qp->hba_index, qp->entry_repost);
+ 
+ 	len +=  snprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len, "\n");
+ 
+ 	return len;
+ }
+ 
+ static int
+ __lpfc_idiag_print_rqpair(struct lpfc_queue *qp, struct lpfc_queue *datqp,
+ 			char *rqtype, char *pbuffer, int len)
+ {
+ 	if (!qp || !datqp)
+ 		return len;
+ 
+ 	len += snprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,
+ 			"\t\t%s RQ info: ", rqtype);
+ 	len += snprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,
+ 			"AssocCQID[%02d]: RQ-STAT[nopost:x%x nobuf:x%x "
+ 			"posted:x%x rcv:x%llx]\n",
+ 			qp->assoc_qid, qp->q_cnt_1, qp->q_cnt_2,
+ 			qp->q_cnt_3, (unsigned long long)qp->q_cnt_4);
+ 	len += snprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,
+ 			"\t\tHQID[%02d], QE-CNT[%04d], QE-SZ[%04d], "
+ 			"HST-IDX[%04d], PRT-IDX[%04d], PST[%03d]\n",
+ 			qp->queue_id, qp->entry_count, qp->entry_size,
+ 			qp->host_index, qp->hba_index, qp->entry_repost);
+ 	len += snprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,
+ 			"\t\tDQID[%02d], QE-CNT[%04d], QE-SZ[%04d], "
+ 			"HST-IDX[%04d], PRT-IDX[%04d], PST[%03d]\n",
+ 			datqp->queue_id, datqp->entry_count,
+ 			datqp->entry_size, datqp->host_index,
+ 			datqp->hba_index, datqp->entry_repost);
+ 	return len;
+ }
+ 
+ static int
+ lpfc_idiag_cqs_for_eq(struct lpfc_hba *phba, char *pbuffer,
+ 		int *len, int max_cnt, int eqidx, int eq_id)
+ {
+ 	struct lpfc_queue *qp;
+ 	int qidx, rc;
+ 
+ 	for (qidx = 0; qidx < phba->cfg_fcp_io_channel; qidx++) {
+ 		qp = phba->sli4_hba.fcp_cq[qidx];
+ 		if (qp->assoc_qid != eq_id)
+ 			continue;
+ 
+ 		*len = __lpfc_idiag_print_cq(qp, "FCP", pbuffer, *len);
+ 
+ 		/* Reset max counter */
+ 		qp->CQ_max_cqe = 0;
+ 
+ 		if (*len >= max_cnt)
+ 			return 1;
+ 
+ 		rc = lpfc_idiag_wqs_for_cq(phba, "FCP", pbuffer, len,
+ 				max_cnt, qp->queue_id);
+ 		if (rc)
+ 			return 1;
+ 	}
+ 
+ 	for (qidx = 0; qidx < phba->cfg_nvme_io_channel; qidx++) {
+ 		qp = phba->sli4_hba.nvme_cq[qidx];
+ 		if (qp->assoc_qid != eq_id)
+ 			continue;
+ 
+ 		*len = __lpfc_idiag_print_cq(qp, "NVME", pbuffer, *len);
+ 
+ 		/* Reset max counter */
+ 		qp->CQ_max_cqe = 0;
+ 
+ 		if (*len >= max_cnt)
+ 			return 1;
+ 
+ 		rc = lpfc_idiag_wqs_for_cq(phba, "NVME", pbuffer, len,
+ 				max_cnt, qp->queue_id);
+ 		if (rc)
+ 			return 1;
+ 	}
+ 
+ 	if (eqidx < phba->cfg_nvmet_mrq) {
+ 		/* NVMET CQset */
+ 		qp = phba->sli4_hba.nvmet_cqset[eqidx];
+ 		*len = __lpfc_idiag_print_cq(qp, "NVMET CQset", pbuffer, *len);
+ 
+ 		/* Reset max counter */
+ 		qp->CQ_max_cqe = 0;
+ 
+ 		if (*len >= max_cnt)
+ 			return 1;
+ 
+ 		/* RQ header */
+ 		qp = phba->sli4_hba.nvmet_mrq_hdr[eqidx];
+ 		*len = __lpfc_idiag_print_rqpair(qp,
+ 				phba->sli4_hba.nvmet_mrq_data[eqidx],
+ 				"NVMET MRQ", pbuffer, *len);
+ 
+ 		if (*len >= max_cnt)
+ 			return 1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int
+ __lpfc_idiag_print_eq(struct lpfc_queue *qp, char *eqtype,
+ 			char *pbuffer, int len)
+ {
+ 	if (!qp)
+ 		return len;
+ 
+ 	len += snprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,
+ 			"\n%s EQ info: EQ-STAT[max:x%x noE:x%x "
+ 			"bs:x%x proc:x%llx]\n",
+ 			eqtype, qp->q_cnt_1, qp->q_cnt_2, qp->q_cnt_3,
+ 			(unsigned long long)qp->q_cnt_4);
+ 	len += snprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,
+ 			"EQID[%02d], QE-CNT[%04d], QE-SZ[%04d], "
+ 			"HST-IDX[%04d], PRT-IDX[%04d], PST[%03d]",
+ 			qp->queue_id, qp->entry_count, qp->entry_size,
+ 			qp->host_index, qp->hba_index, qp->entry_repost);
+ 	len +=  snprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len, "\n");
+ 
+ 	return len;
+ }
+ 
++>>>>>>> 7869da183a7c (scsi: lpfc: Fix NMI watchdog assertions when running nvmet IOPS tests)
  /**
   * lpfc_idiag_queinfo_read - idiag debugfs read queue information
   * @file: The file pointer to read from.
diff --cc drivers/scsi/lpfc/lpfc_sli.c
index c54385fd9058,cc45e9191062..000000000000
--- a/drivers/scsi/lpfc/lpfc_sli.c
+++ b/drivers/scsi/lpfc/lpfc_sli.c
@@@ -12438,7 -13128,113 +12438,117 @@@ lpfc_sli4_fp_handle_rel_wcqe(struct lpf
  }
  
  /**
++<<<<<<< HEAD
 + * lpfc_sli4_fp_handle_wcqe - Process fast-path work queue completion entry
++=======
+  * lpfc_sli4_nvmet_handle_rcqe - Process a receive-queue completion queue entry
+  * @phba: Pointer to HBA context object.
+  * @rcqe: Pointer to receive-queue completion queue entry.
+  *
+  * This routine process a receive-queue completion queue entry.
+  *
+  * Return: true if work posted to worker thread, otherwise false.
+  **/
+ static bool
+ lpfc_sli4_nvmet_handle_rcqe(struct lpfc_hba *phba, struct lpfc_queue *cq,
+ 			    struct lpfc_rcqe *rcqe)
+ {
+ 	bool workposted = false;
+ 	struct lpfc_queue *hrq;
+ 	struct lpfc_queue *drq;
+ 	struct rqb_dmabuf *dma_buf;
+ 	struct fc_frame_header *fc_hdr;
+ 	struct lpfc_nvmet_tgtport *tgtp;
+ 	uint32_t status, rq_id;
+ 	unsigned long iflags;
+ 	uint32_t fctl, idx;
+ 
+ 	if ((phba->nvmet_support == 0) ||
+ 	    (phba->sli4_hba.nvmet_cqset == NULL))
+ 		return workposted;
+ 
+ 	idx = cq->queue_id - phba->sli4_hba.nvmet_cqset[0]->queue_id;
+ 	hrq = phba->sli4_hba.nvmet_mrq_hdr[idx];
+ 	drq = phba->sli4_hba.nvmet_mrq_data[idx];
+ 
+ 	/* sanity check on queue memory */
+ 	if (unlikely(!hrq) || unlikely(!drq))
+ 		return workposted;
+ 
+ 	if (bf_get(lpfc_cqe_code, rcqe) == CQE_CODE_RECEIVE_V1)
+ 		rq_id = bf_get(lpfc_rcqe_rq_id_v1, rcqe);
+ 	else
+ 		rq_id = bf_get(lpfc_rcqe_rq_id, rcqe);
+ 
+ 	if ((phba->nvmet_support == 0) ||
+ 	    (rq_id != hrq->queue_id))
+ 		return workposted;
+ 
+ 	status = bf_get(lpfc_rcqe_status, rcqe);
+ 	switch (status) {
+ 	case FC_STATUS_RQ_BUF_LEN_EXCEEDED:
+ 		lpfc_printf_log(phba, KERN_ERR, LOG_SLI,
+ 				"6126 Receive Frame Truncated!!\n");
+ 	case FC_STATUS_RQ_SUCCESS:
+ 		lpfc_sli4_rq_release(hrq, drq);
+ 		spin_lock_irqsave(&phba->hbalock, iflags);
+ 		dma_buf = lpfc_sli_rqbuf_get(phba, hrq);
+ 		if (!dma_buf) {
+ 			hrq->RQ_no_buf_found++;
+ 			spin_unlock_irqrestore(&phba->hbalock, iflags);
+ 			goto out;
+ 		}
+ 		spin_unlock_irqrestore(&phba->hbalock, iflags);
+ 		hrq->RQ_rcv_buf++;
+ 		hrq->RQ_buf_posted--;
+ 		fc_hdr = (struct fc_frame_header *)dma_buf->hbuf.virt;
+ 
+ 		/* Just some basic sanity checks on FCP Command frame */
+ 		fctl = (fc_hdr->fh_f_ctl[0] << 16 |
+ 		fc_hdr->fh_f_ctl[1] << 8 |
+ 		fc_hdr->fh_f_ctl[2]);
+ 		if (((fctl &
+ 		    (FC_FC_FIRST_SEQ | FC_FC_END_SEQ | FC_FC_SEQ_INIT)) !=
+ 		    (FC_FC_FIRST_SEQ | FC_FC_END_SEQ | FC_FC_SEQ_INIT)) ||
+ 		    (fc_hdr->fh_seq_cnt != 0)) /* 0 byte swapped is still 0 */
+ 			goto drop;
+ 
+ 		if (fc_hdr->fh_type == FC_TYPE_FCP) {
+ 			dma_buf->bytes_recv = bf_get(lpfc_rcqe_length,  rcqe);
+ 			lpfc_nvmet_unsol_fcp_event(
+ 				phba, phba->sli4_hba.els_wq->pring, dma_buf,
+ 				cq->assoc_qp->isr_timestamp);
+ 			return false;
+ 		}
+ drop:
+ 		lpfc_in_buf_free(phba, &dma_buf->dbuf);
+ 		break;
+ 	case FC_STATUS_INSUFF_BUF_FRM_DISC:
+ 		if (phba->nvmet_support) {
+ 			tgtp = phba->targetport->private;
+ 			lpfc_printf_log(phba, KERN_ERR, LOG_SLI | LOG_NVME,
+ 					"6401 RQE Error x%x, posted %d err_cnt "
+ 					"%d: %x %x %x\n",
+ 					status, hrq->RQ_buf_posted,
+ 					hrq->RQ_no_posted_buf,
+ 					atomic_read(&tgtp->rcv_fcp_cmd_in),
+ 					atomic_read(&tgtp->rcv_fcp_cmd_out),
+ 					atomic_read(&tgtp->xmt_fcp_release));
+ 		}
+ 		/* fallthrough */
+ 
+ 	case FC_STATUS_INSUFF_BUF_NEED_BUF:
+ 		hrq->RQ_no_posted_buf++;
+ 		/* Post more buffers if possible */
+ 		break;
+ 	}
+ out:
+ 	return workposted;
+ }
+ 
+ /**
+  * lpfc_sli4_fp_handle_cqe - Process fast-path work queue completion entry
++>>>>>>> 7869da183a7c (scsi: lpfc: Fix NMI watchdog assertions when running nvmet IOPS tests)
   * @cq: Pointer to the completion queue.
   * @eqe: Pointer to fast-path completion queue entry.
   *
@@@ -12550,11 -13373,14 +12660,11 @@@ lpfc_sli4_hba_handle_eqe(struct lpfc_hb
  		return;
  	}
  
 -	/* Save EQ associated with this CQ */
 -	cq->assoc_qp = phba->sli4_hba.hba_eq[qidx];
 -
  	/* Process all the entries to the CQ */
  	while ((cqe = lpfc_sli4_cq_get(cq))) {
 -		workposted |= lpfc_sli4_fp_handle_cqe(phba, cq, cqe);
 +		workposted |= lpfc_sli4_fp_handle_wcqe(phba, cq, cqe);
  		if (!(++ecount % cq->entry_repost))
- 			lpfc_sli4_cq_release(cq, LPFC_QUEUE_NOARM);
+ 			break;
  	}
  
  	/* Track the max number of CQEs processed in 1 EQ */
@@@ -12643,9 -13469,9 +12753,9 @@@ lpfc_sli4_fof_handle_eqe(struct lpfc_hb
  
  	/* Process all the entries to the OAS CQ */
  	while ((cqe = lpfc_sli4_cq_get(cq))) {
 -		workposted |= lpfc_sli4_fp_handle_cqe(phba, cq, cqe);
 +		workposted |= lpfc_sli4_fp_handle_wcqe(phba, cq, cqe);
  		if (!(++ecount % cq->entry_repost))
- 			lpfc_sli4_cq_release(cq, LPFC_QUEUE_NOARM);
+ 			break;
  	}
  
  	/* Track the max number of CQEs processed in 1 EQ */
@@@ -12837,9 -13668,9 +12947,9 @@@ lpfc_sli4_hba_intr_handler(int irq, voi
  		if (eqe == NULL)
  			break;
  
 -		lpfc_sli4_hba_handle_eqe(phba, eqe, hba_eqidx);
 +		lpfc_sli4_hba_handle_eqe(phba, eqe, fcp_eqidx);
  		if (!(++ecount % fpeq->entry_repost))
- 			lpfc_sli4_eq_release(fpeq, LPFC_QUEUE_NOARM);
+ 			break;
  		fpeq->EQ_processed++;
  	}
  
* Unmerged path drivers/scsi/lpfc/lpfc_debugfs.c
* Unmerged path drivers/scsi/lpfc/lpfc_sli.c
