netvsc: make sure napi enabled before vmbus_open

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author stephen hemminger <stephen@networkplumber.org>
commit 2be0f2644598ee4b8ea0ed6a32913e1ce0212c9c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2be0f264.failed

This fixes a race where vmbus callback for new packet arriving
could occur before NAPI is initialized.

	Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2be0f2644598ee4b8ea0ed6a32913e1ce0212c9c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/netvsc.c
#	drivers/net/hyperv/rndis_filter.c
diff --cc drivers/net/hyperv/netvsc.c
index cca2c8eb4baa,652453d9fb08..000000000000
--- a/drivers/net/hyperv/netvsc.c
+++ b/drivers/net/hyperv/netvsc.c
@@@ -1362,14 -1304,36 +1362,19 @@@ int netvsc_device_add(struct hv_device 
  
  	net_device->ring_size = ring_size;
  
 -	/* Because the device uses NAPI, all the interrupt batching and
 -	 * control is done via Net softirq, not the channel handling
 -	 */
 -	set_channel_read_mode(device->channel, HV_CALL_ISR);
 -
 -	/* If we're reopening the device we may have multiple queues, fill the
 -	 * chn_table with the default channel to use it before subchannels are
 -	 * opened.
 -	 * Initialize the channel state before we open;
 -	 * we can be interrupted as soon as we open the channel.
 -	 */
 -
 -	for (i = 0; i < VRSS_CHANNEL_MAX; i++) {
 -		struct netvsc_channel *nvchan = &net_device->chan_table[i];
 -
 -		nvchan->channel = device->channel;
 -	}
 +	set_per_channel_state(device->channel, net_device->cb_buffer);
  
+ 	/* Enable NAPI handler before init callbacks */
+ 	netif_napi_add(ndev, &net_device->chan_table[0].napi,
+ 		       netvsc_poll, NAPI_POLL_WEIGHT);
+ 
  	/* Open the channel */
  	ret = vmbus_open(device->channel, ring_size * PAGE_SIZE,
  			 ring_size * PAGE_SIZE, NULL, 0,
 -			 netvsc_channel_cb,
 -			 net_device->chan_table);
 +			 netvsc_channel_cb, device->channel);
  
  	if (ret != 0) {
+ 		netif_napi_del(&net_device->chan_table[0].napi);
  		netdev_err(ndev, "unable to open channel: %d\n", ret);
  		goto cleanup;
  	}
@@@ -1377,12 -1341,7 +1382,16 @@@
  	/* Channel is opened */
  	netdev_dbg(ndev, "hv_netvsc channel opened successfully\n");
  
++<<<<<<< HEAD
 +	/* If we're reopening the device we may have multiple queues, fill the
 +	 * chn_table with the default channel to use it before subchannels are
 +	 * opened.
 +	 */
 +	for (i = 0; i < VRSS_CHANNEL_MAX; i++)
 +		net_device->chn_table[i] = device->channel;
++=======
+ 	napi_enable(&net_device->chan_table[0].napi);
++>>>>>>> 2be0f2644598 (netvsc: make sure napi enabled before vmbus_open)
  
  	/* Writing nvdev pointer unlocks netvsc_send(), make sure chn_table is
  	 * populated.
diff --cc drivers/net/hyperv/rndis_filter.c
index b6bc44dd1f92,f9d5b0b8209a..000000000000
--- a/drivers/net/hyperv/rndis_filter.c
+++ b/drivers/net/hyperv/rndis_filter.c
@@@ -925,17 -1007,20 +925,25 @@@ static void netvsc_sc_open(struct vmbus
  	 */
  	set_channel_read_mode(new_sc, HV_CALL_ISR);
  
 -	/* Set the channel before opening.*/
 -	nvchan->channel = new_sc;
 -	netif_napi_add(ndev, &nvchan->napi,
 -		       netvsc_poll, NAPI_POLL_WEIGHT);
 -
  	ret = vmbus_open(new_sc, nvscdev->ring_size * PAGE_SIZE,
  			 nvscdev->ring_size * PAGE_SIZE, NULL, 0,
++<<<<<<< HEAD
 +			 netvsc_channel_cb, new_sc);
++=======
+ 			 netvsc_channel_cb, nvchan);
+ 	if (ret == 0)
+ 		napi_enable(&nvchan->napi);
+ 	else
+ 		netif_napi_del(&nvchan->napi);
++>>>>>>> 2be0f2644598 (netvsc: make sure napi enabled before vmbus_open)
 +
 +	if (ret == 0)
 +		nvscdev->chn_table[chn_index] = new_sc;
  
 -	if (refcount_dec_and_test(&nvscdev->sc_offered))
 +	spin_lock_irqsave(&nvscdev->sc_lock, flags);
 +	nvscdev->num_sc_offered--;
 +	spin_unlock_irqrestore(&nvscdev->sc_lock, flags);
 +	if (nvscdev->num_sc_offered == 0)
  		complete(&nvscdev->channel_init_wait);
  }
  
* Unmerged path drivers/net/hyperv/netvsc.c
* Unmerged path drivers/net/hyperv/rndis_filter.c
