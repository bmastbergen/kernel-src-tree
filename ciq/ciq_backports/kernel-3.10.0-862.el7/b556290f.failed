ALSA: x86: Unify local function prefix

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Takashi Iwai <tiwai@suse.de>
commit b556290f9a8386ff6afeec12cae29fbab77321a3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b556290f.failed

Use had_ prefix consistently to all local helper functions, as well as
had_pcm_ for PCM ops.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit b556290f9a8386ff6afeec12cae29fbab77321a3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/x86/intel_hdmi_audio.c
diff --cc sound/x86/intel_hdmi_audio.c
index 063e2be94d05,57042ef3a480..000000000000
--- a/sound/x86/intel_hdmi_audio.c
+++ b/sound/x86/intel_hdmi_audio.c
@@@ -238,49 -212,54 +238,60 @@@ int had_read_modify(struct snd_intelha
   * causes the "channels" field to be updated as 0xy binary resulting in
   * bad audio. The fix is to always write the AUD_CONFIG[6:4] with
   * appropriate value when doing read-modify of AUD_CONFIG register.
 + *
 + * @substream: the current substream or NULL if no active substream
 + * @data : data to be written
 + * @mask : mask
 + *
   */
++<<<<<<< HEAD
 +static int had_read_modify_aud_config_v2(struct snd_pcm_substream *substream,
 +					u32 data, u32 mask)
++=======
+ static void had_enable_audio(struct snd_pcm_substream *substream,
+ 			     struct snd_intelhad *intelhaddata,
+ 			     bool enable)
++>>>>>>> b556290f9a83 (ALSA: x86: Unify local function prefix)
  {
 -	union aud_cfg cfg_val = {.regval = 0};
 +	struct snd_intelhad *intelhaddata = snd_pcm_substream_chip(substream);
 +	union aud_cfg cfg_val = {.cfg_regval = 0};
  	u8 channels;
 -	u32 mask, val;
  
  	/*
  	 * If substream is NULL, there is no active stream.
  	 * In this case just set channels to 2
  	 */
 -	channels = substream ? substream->runtime->channels : 2;
 -	dev_dbg(intelhaddata->dev, "enable %d, ch=%d\n", enable, channels);
 -
 -	cfg_val.regx.num_ch = channels - 2;
 -	if (enable)
 -		cfg_val.regx.aud_en = 1;
 -	mask = AUD_CONFIG_CH_MASK | 1;
 -
 -	had_read_register(intelhaddata, AUD_CONFIG, &val);
 -	val &= ~mask;
 -	val |= cfg_val.regval;
 -	had_write_register(intelhaddata, AUD_CONFIG, val);
 +	if (substream)
 +		channels = substream->runtime->channels;
 +	else
 +		channels = 2;
 +	cfg_val.cfg_regx_v2.num_ch = channels - 2;
 +
 +	data = data | cfg_val.cfg_regval;
 +	mask = mask | AUD_CONFIG_CH_MASK_V2;
 +
 +	pr_debug("%s : data = %x, mask =%x\n", __func__, data, mask);
 +
 +	return had_read_modify(intelhaddata, AUD_CONFIG, data, mask);
  }
  
++<<<<<<< HEAD
 +void snd_intelhad_enable_audio(struct snd_pcm_substream *substream, u8 enable)
++=======
+ /* enable / disable the audio interface */
+ static void had_enable_audio_int(struct snd_intelhad *ctx, bool enable)
++>>>>>>> b556290f9a83 (ALSA: x86: Unify local function prefix)
  {
 -	u32 status_reg;
 -
 -	if (enable) {
 -		had_read_register(ctx, AUD_HDMI_STATUS, &status_reg);
 -		status_reg |= HDMI_AUDIO_BUFFER_DONE | HDMI_AUDIO_UNDERRUN;
 -		had_write_register(ctx, AUD_HDMI_STATUS, status_reg);
 -		had_read_register(ctx, AUD_HDMI_STATUS, &status_reg);
 -	}
 +	had_read_modify_aud_config_v2(substream, enable, BIT(0));
  }
  
 -/* Reset buffer pointers */
 -static void had_reset_audio(struct snd_intelhad *intelhaddata)
 +static void snd_intelhad_reset_audio(struct snd_intelhad *intelhaddata,
 +				     u8 reset)
  {
 -	had_write_register(intelhaddata, AUD_HDMI_STATUS, 1);
 -	had_write_register(intelhaddata, AUD_HDMI_STATUS, 0);
 +	had_write_register(intelhaddata, AUD_HDMI_STATUS_v2, reset);
  }
  
 -/*
 +/**
   * initialize audio channel status registers
   * This function is called in the prepare callback
   */
@@@ -355,11 -332,11 +366,11 @@@ static int had_prog_status_reg(struct s
   * registers and buffer confgiuration registers
   * This function is called in the prepare callback
   */
- static int snd_intelhad_audio_ctrl(struct snd_pcm_substream *substream,
- 				   struct snd_intelhad *intelhaddata)
+ static int had_init_audio_ctrl(struct snd_pcm_substream *substream,
+ 			       struct snd_intelhad *intelhaddata)
  {
 -	union aud_cfg cfg_val = {.regval = 0};
 -	union aud_buf_config buf_cfg = {.regval = 0};
 +	union aud_cfg cfg_val = {.cfg_regval = 0};
 +	union aud_buf_config buf_cfg = {.buf_cfgval = 0};
  	u8 channels;
  
  	had_prog_status_reg(substream, intelhaddata);
@@@ -588,52 -570,48 +599,56 @@@ static int had_register_chmap_ctls(stru
  }
  
  /*
 - * Initialize Data Island Packets registers
 + * snd_intelhad_prog_dip - to initialize Data Island Packets registers
 + *
 + * @substream:substream for which the prepare function is called
 + * @intelhaddata:substream private data
 + *
   * This function is called in the prepare callback
   */
- static void snd_intelhad_prog_dip(struct snd_pcm_substream *substream,
- 				  struct snd_intelhad *intelhaddata)
+ static void had_prog_dip(struct snd_pcm_substream *substream,
+ 			 struct snd_intelhad *intelhaddata)
  {
  	int i;
 -	union aud_ctrl_st ctrl_state = {.regval = 0};
 -	union aud_info_frame2 frame2 = {.regval = 0};
 -	union aud_info_frame3 frame3 = {.regval = 0};
 +	union aud_ctrl_st ctrl_state = {.ctrl_val = 0};
 +	union aud_info_frame2 frame2 = {.fr2_val = 0};
 +	union aud_info_frame3 frame3 = {.fr3_val = 0};
  	u8 checksum = 0;
  	u32 info_frame;
  	int channels;
  
  	channels = substream->runtime->channels;
  
 -	had_write_register(intelhaddata, AUD_CNTL_ST, ctrl_state.regval);
 +	had_write_register(intelhaddata, AUD_CNTL_ST, ctrl_state.ctrl_val);
  
++<<<<<<< HEAD
++=======
+ 	ca = had_channel_allocation(intelhaddata, channels);
++>>>>>>> b556290f9a83 (ALSA: x86: Unify local function prefix)
  	if (intelhaddata->dp_output) {
  		info_frame = DP_INFO_FRAME_WORD1;
 -		frame2.regval = (substream->runtime->channels - 1) | (ca << 24);
 +		frame2.fr2_val = 1;
  	} else {
  		info_frame = HDMI_INFO_FRAME_WORD1;
 -		frame2.regx.chnl_cnt = substream->runtime->channels - 1;
 -		frame3.regx.chnl_alloc = ca;
 +		frame2.fr2_regx.chnl_cnt = substream->runtime->channels - 1;
 +
 +		frame3.fr3_regx.chnl_alloc = snd_intelhad_channel_allocation(
 +			intelhaddata, channels);
  
 -		/* Calculte the byte wide checksum for all valid DIP words */
 +		/*Calculte the byte wide checksum for all valid DIP words*/
  		for (i = 0; i < BYTES_PER_WORD; i++)
 -			checksum += (info_frame >> (i * 8)) & 0xff;
 +			checksum += (info_frame >> i*BITS_PER_BYTE) & MASK_BYTE0;
  		for (i = 0; i < BYTES_PER_WORD; i++)
 -			checksum += (frame2.regval >> (i * 8)) & 0xff;
 +			checksum += (frame2.fr2_val >> i*BITS_PER_BYTE) & MASK_BYTE0;
  		for (i = 0; i < BYTES_PER_WORD; i++)
 -			checksum += (frame3.regval >> (i * 8)) & 0xff;
 +			checksum += (frame3.fr3_val >> i*BITS_PER_BYTE) & MASK_BYTE0;
  
 -		frame2.regx.chksum = -(checksum);
 +		frame2.fr2_regx.chksum = -(checksum);
  	}
  
 -	had_write_register(intelhaddata, AUD_HDMIW_INFOFR, info_frame);
 -	had_write_register(intelhaddata, AUD_HDMIW_INFOFR, frame2.regval);
 -	had_write_register(intelhaddata, AUD_HDMIW_INFOFR, frame3.regval);
 +	had_write_register(intelhaddata, AUD_HDMIW_INFOFR_v2, info_frame);
 +	had_write_register(intelhaddata, AUD_HDMIW_INFOFR_v2, frame2.fr2_val);
 +	had_write_register(intelhaddata, AUD_HDMIW_INFOFR_v2, frame3.fr3_val);
  
  	/* program remaining DIP words with zero */
  	for (i = 0; i < HAD_MAX_DIP_WORDS-VALID_DIP_WORDS; i++)
@@@ -891,10 -859,10 +906,10 @@@ static int had_calculate_n_value(u32 au
   * This function is called in the prepare callback.
   * It programs based on the audio and display sampling frequency
   */
- static int snd_intelhad_prog_n(u32 aud_samp_freq, u32 *n_param,
- 			       struct snd_intelhad *intelhaddata)
+ static int had_prog_n(u32 aud_samp_freq, u32 *n_param,
+ 		      struct snd_intelhad *intelhaddata)
  {
 -	int n_val;
 +	s32 n_val;
  
  	if (intelhaddata->dp_output) {
  		/*
@@@ -942,16 -911,13 +957,16 @@@ void snd_intelhad_handle_underrun(struc
  			break;
  	} while (i < MAX_CNT);
  	if (i >= MAX_CNT)
 -		dev_err(intelhaddata->dev, "Unable to clear UNDERRUN bits\n");
 +		pr_err("Unable to clear UNDERRUN bits\n");
  }
  
 -/*
 - * ALSA PCM open callback
 +/**
 + * snd_intelhad_open - stream initializations are done here
 + * @substream:substream for which the stream function is called
 + *
 + * This function is called whenever a PCM stream is opened
   */
- static int snd_intelhad_open(struct snd_pcm_substream *substream)
+ static int had_pcm_open(struct snd_pcm_substream *substream)
  {
  	struct snd_intelhad *intelhaddata;
  	struct snd_pcm_runtime *runtime;
@@@ -981,16 -936,8 +996,16 @@@
  	}
  
  	/* set the runtime hw parameter with local snd_pcm_hardware struct */
- 	runtime->hw = snd_intel_hadstream;
+ 	runtime->hw = had_pcm_hardware;
  
 +	stream = kzalloc(sizeof(*stream), GFP_KERNEL);
 +	if (!stream) {
 +		retval = -ENOMEM;
 +		goto exit_put_handle;
 +	}
 +	stream->stream_status = STREAM_INIT;
 +	runtime->private_data = stream;
 +
  	retval = snd_pcm_hw_constraint_integer(runtime,
  			 SNDRV_PCM_HW_PARAM_PERIODS);
  	if (retval < 0)
@@@ -1015,100 -968,37 +1030,100 @@@ exit_put_handle
  	return retval;
  }
  
 -/*
 - * ALSA PCM close callback
 +/**
 + * had_period_elapsed - updates the hardware pointer status
 + * @had_substream:substream for which the stream function is called
 + *
 + */
 +static void had_period_elapsed(void *had_substream)
 +{
 +	struct snd_pcm_substream *substream = had_substream;
 +	struct had_stream_pvt *stream;
 +
 +	/* pr_debug("had_period_elapsed called\n"); */
 +
 +	if (!substream || !substream->runtime)
 +		return;
 +	stream = substream->runtime->private_data;
 +	if (!stream)
 +		return;
 +
 +	if (stream->stream_status != STREAM_RUNNING)
 +		return;
 +	snd_pcm_period_elapsed(substream);
 +}
 +
 +/**
 + * snd_intelhad_init_stream - internal function to initialize stream info
 + * @substream:substream for which the stream function is called
 + *
 + */
 +static int snd_intelhad_init_stream(struct snd_pcm_substream *substream)
 +{
 +	struct snd_intelhad *intelhaddata = snd_pcm_substream_chip(substream);
 +
 +	pr_debug("snd_intelhad_init_stream called\n");
 +
 +	pr_debug("setting buffer ptr param\n");
 +	intelhaddata->stream_info.period_elapsed = had_period_elapsed;
 +	intelhaddata->stream_info.had_substream = substream;
 +	intelhaddata->stream_info.buffer_ptr = 0;
 +	intelhaddata->stream_info.buffer_rendered = 0;
 +	intelhaddata->stream_info.sfreq = substream->runtime->rate;
 +	return 0;
 +}
 +
 +/**
 + * snd_intelhad_close- to free parameteres when stream is stopped
 + *
 + * @substream:  substream for which the function is called
 + *
 + * This function is called by ALSA framework when stream is stopped
   */
- static int snd_intelhad_close(struct snd_pcm_substream *substream)
+ static int had_pcm_close(struct snd_pcm_substream *substream)
  {
  	struct snd_intelhad *intelhaddata;
 +	struct snd_pcm_runtime *runtime;
 +
 +	pr_debug("snd_intelhad_close called\n");
  
  	intelhaddata = snd_pcm_substream_chip(substream);
 +	runtime = substream->runtime;
  
 -	/* unreference and sync with the pending PCM accesses */
 -	spin_lock_irq(&intelhaddata->had_spinlock);
 -	intelhaddata->stream_info.substream = NULL;
 -	intelhaddata->stream_info.substream_refcount--;
 -	while (intelhaddata->stream_info.substream_refcount > 0) {
 -		spin_unlock_irq(&intelhaddata->had_spinlock);
 -		cpu_relax();
 -		spin_lock_irq(&intelhaddata->had_spinlock);
 +	if (!runtime->private_data) {
 +		pr_debug("close() might have called after failed open");
 +		return 0;
  	}
 -	spin_unlock_irq(&intelhaddata->had_spinlock);
  
 +	intelhaddata->stream_info.buffer_rendered = 0;
 +	intelhaddata->stream_info.buffer_ptr = 0;
 +	intelhaddata->stream_info.str_id = 0;
 +	intelhaddata->stream_info.had_substream = NULL;
 +
 +	/* Check if following drv_status modification is required - VA */
 +	if (intelhaddata->drv_status != HAD_DRV_DISCONNECTED) {
 +		intelhaddata->drv_status = HAD_DRV_CONNECTED;
 +		pr_debug("%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_CONNECTED\n",
 +			__func__, __LINE__);
 +	}
 +	kfree(runtime->private_data);
 +	runtime->private_data = NULL;
  	pm_runtime_put(intelhaddata->dev);
  	return 0;
  }
  
 -/*
 - * ALSA PCM hw_params callback
 +/**
 + * snd_intelhad_hw_params- to setup the hardware parameters
 + * like allocating the buffers
 + *
 + * @substream:  substream for which the function is called
 + * @hw_params: hardware parameters
 + *
 + * This function is called by ALSA framework when hardware params are set
   */
- static int snd_intelhad_hw_params(struct snd_pcm_substream *substream,
- 				    struct snd_pcm_hw_params *hw_params)
+ static int had_pcm_hw_params(struct snd_pcm_substream *substream,
+ 			     struct snd_pcm_hw_params *hw_params)
  {
 -	struct snd_intelhad *intelhaddata;
  	unsigned long addr;
  	int pages, buf_size, retval;
  
@@@ -1135,16 -1023,10 +1150,16 @@@
  	return retval;
  }
  
 -/*
 - * ALSA PCM hw_free callback
 +/**
 + * snd_intelhad_hw_free- to release the resources allocated during
 + * hardware params setup
 + *
 + * @substream:  substream for which the function is called
 + *
 + * This function is called by ALSA framework before close callback.
 + *
   */
- static int snd_intelhad_hw_free(struct snd_pcm_substream *substream)
+ static int had_pcm_hw_free(struct snd_pcm_substream *substream)
  {
  	unsigned long addr;
  	u32 pages;
@@@ -1162,26 -1042,15 +1177,25 @@@
  	return 0;
  }
  
 -/*
 - * ALSA PCM trigger callback
 +/**
 + * snd_intelhad_pcm_trigger - stream activities are handled here
 + * @substream:substream for which the stream function is called
 + * @cmd:the stream commamd thats requested from upper layer
 + * This function is called whenever an a stream activity is invoked
   */
- static int snd_intelhad_pcm_trigger(struct snd_pcm_substream *substream,
- 					int cmd)
+ static int had_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
  {
 -	int retval = 0;
 +	int caps, retval = 0;
 +	unsigned long flag_irq;
  	struct snd_intelhad *intelhaddata;
 +	struct had_stream_pvt *stream;
 +	struct had_pvt_data *had_stream;
 +
 +	pr_debug("snd_intelhad_pcm_trigger called\n");
  
  	intelhaddata = snd_pcm_substream_chip(substream);
 +	stream = substream->runtime->private_data;
 +	had_stream = intelhaddata->private_data;
  
  	switch (cmd) {
  	case SNDRV_PCM_TRIGGER_START:
@@@ -1193,48 -1063,29 +1207,61 @@@
  			retval = -ENODEV;
  			break;
  		}
 +		stream->stream_status = STREAM_RUNNING;
  
 -		intelhaddata->stream_info.running = true;
 +		had_stream->stream_type = HAD_RUNNING_STREAM;
  
  		/* Enable Audio */
++<<<<<<< HEAD
 +		/*
 +		 * ToDo: Need to enable UNDERRUN interrupts as well
 +		 *   caps = HDMI_AUDIO_UNDERRUN | HDMI_AUDIO_BUFFER_DONE;
 +		 */
 +		caps = HDMI_AUDIO_BUFFER_DONE;
 +		retval = had_set_caps(intelhaddata, HAD_SET_ENABLE_AUDIO_INT,
 +				      &caps);
 +		retval = had_set_caps(intelhaddata, HAD_SET_ENABLE_AUDIO, NULL);
 +		snd_intelhad_enable_audio(substream, 1);
 +
 +		pr_debug("Processed _Start\n");
 +
++=======
+ 		had_enable_audio_int(intelhaddata, true);
+ 		had_enable_audio(substream, intelhaddata, true);
++>>>>>>> b556290f9a83 (ALSA: x86: Unify local function prefix)
  		break;
  
  	case SNDRV_PCM_TRIGGER_STOP:
 -	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 -	case SNDRV_PCM_TRIGGER_SUSPEND:
 -		spin_lock(&intelhaddata->had_spinlock);
 +		pr_debug("Trigger Stop\n");
 +		spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irq);
 +		intelhaddata->stream_info.str_id = 0;
 +		intelhaddata->curr_buf = 0;
  
 -		/* Stop reporting BUFFER_DONE/UNDERRUN to above layers */
 +		/* Stop reporting BUFFER_DONE/UNDERRUN to above layers*/
  
 -		intelhaddata->stream_info.running = false;
 -		spin_unlock(&intelhaddata->had_spinlock);
 +		had_stream->stream_type = HAD_INIT;
 +		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irq);
  		/* Disable Audio */
++<<<<<<< HEAD
 +		/*
 +		 * ToDo: Need to disable UNDERRUN interrupts as well
 +		 *   caps = HDMI_AUDIO_UNDERRUN | HDMI_AUDIO_BUFFER_DONE;
 +		 */
 +		caps = HDMI_AUDIO_BUFFER_DONE;
 +		had_set_caps(intelhaddata, HAD_SET_DISABLE_AUDIO_INT, &caps);
 +		snd_intelhad_enable_audio(substream, 0);
 +		/* Reset buffer pointers */
 +		snd_intelhad_reset_audio(intelhaddata, 1);
 +		snd_intelhad_reset_audio(intelhaddata, 0);
 +		stream->stream_status = STREAM_DROPPED;
 +		had_set_caps(intelhaddata, HAD_SET_DISABLE_AUDIO, NULL);
++=======
+ 		had_enable_audio_int(intelhaddata, false);
+ 		had_enable_audio(substream, intelhaddata, false);
+ 		/* Reset buffer pointers */
+ 		had_reset_audio(intelhaddata);
+ 		had_enable_audio_int(intelhaddata, false);
++>>>>>>> b556290f9a83 (ALSA: x86: Unify local function prefix)
  		break;
  
  	default:
@@@ -1243,14 -1094,10 +1270,14 @@@
  	return retval;
  }
  
 -/*
 - * ALSA PCM prepare callback
 +/**
 + * snd_intelhad_pcm_prepare- internal preparation before starting a stream
 + *
 + * @substream:  substream for which the function is called
 + *
 + * This function is called when a stream is started for internal preparation.
   */
- static int snd_intelhad_pcm_prepare(struct snd_pcm_substream *substream)
+ static int had_pcm_prepare(struct snd_pcm_substream *substream)
  {
  	int retval;
  	u32 disp_samp_freq, n_param;
@@@ -1271,58 -1115,40 +1298,56 @@@
  		goto prep_end;
  	}
  
 -	dev_dbg(intelhaddata->dev, "period_size=%d\n",
 +	pr_debug("period_size=%d\n",
  		(int)frames_to_bytes(runtime, runtime->period_size));
 -	dev_dbg(intelhaddata->dev, "periods=%d\n", runtime->periods);
 -	dev_dbg(intelhaddata->dev, "buffer_size=%d\n",
 -		(int)snd_pcm_lib_buffer_bytes(substream));
 -	dev_dbg(intelhaddata->dev, "rate=%d\n", runtime->rate);
 -	dev_dbg(intelhaddata->dev, "channels=%d\n", runtime->channels);
 +	pr_debug("periods=%d\n", runtime->periods);
 +	pr_debug("buffer_size=%d\n", (int)snd_pcm_lib_buffer_bytes(substream));
 +	pr_debug("rate=%d\n", runtime->rate);
 +	pr_debug("channels=%d\n", runtime->channels);
 +
 +	if (intelhaddata->stream_info.str_id) {
 +		pr_debug("_prepare is called for existing str_id#%d\n",
 +					intelhaddata->stream_info.str_id);
 +		retval = snd_intelhad_pcm_trigger(substream,
 +						SNDRV_PCM_TRIGGER_STOP);
 +		return retval;
 +	}
 +
 +	retval = snd_intelhad_init_stream(substream);
 +	if (retval)
 +		goto prep_end;
  
 -	intelhaddata->curr_buf = 0;
 -	intelhaddata->underrun_count = 0;
 -	intelhaddata->stream_info.buffer_rendered = 0;
  
  	/* Get N value in KHz */
 -	disp_samp_freq = intelhaddata->tmds_clock_speed;
 +	retval = had_get_caps(intelhaddata, HAD_GET_DISPLAY_RATE,
 +			      &disp_samp_freq);
 +	if (retval) {
 +		pr_err("querying display sampling freq failed %#x\n", retval);
 +		goto prep_end;
 +	}
 +
 +	had_get_caps(intelhaddata, HAD_GET_ELD, &intelhaddata->eeld);
 +	had_get_caps(intelhaddata, HAD_GET_DP_OUTPUT, &intelhaddata->dp_output);
  
- 	retval = snd_intelhad_prog_n(substream->runtime->rate, &n_param,
- 				     intelhaddata);
+ 	retval = had_prog_n(substream->runtime->rate, &n_param, intelhaddata);
  	if (retval) {
 -		dev_err(intelhaddata->dev,
 -			"programming N value failed %#x\n", retval);
 +		pr_err("programming N value failed %#x\n", retval);
  		goto prep_end;
  	}
  
  	if (intelhaddata->dp_output)
 -		link_rate = intelhaddata->link_rate;
 +		had_get_caps(intelhaddata, HAD_GET_LINK_RATE, &link_rate);
 +
  
- 	snd_intelhad_prog_cts(substream->runtime->rate,
- 			      disp_samp_freq, link_rate,
- 			      n_param, intelhaddata);
+ 	had_prog_cts(substream->runtime->rate, disp_samp_freq, link_rate,
+ 		     n_param, intelhaddata);
  
- 	snd_intelhad_prog_dip(substream, intelhaddata);
+ 	had_prog_dip(substream, intelhaddata);
  
- 	retval = snd_intelhad_audio_ctrl(substream, intelhaddata);
+ 	retval = had_init_audio_ctrl(substream, intelhaddata);
  
  	/* Prog buffer address */
 -	retval = snd_intelhad_prog_buffer(substream, intelhaddata,
 +	retval = snd_intelhad_prog_buffer(intelhaddata,
  			HAD_BUF_TYPE_A, HAD_BUF_TYPE_D);
  
  	/*
@@@ -1336,16 -1162,10 +1361,20 @@@ prep_end
  	return retval;
  }
  
 -/*
 - * ALSA PCM pointer callback
 +/**
 + * snd_intelhad_pcm_pointer- to send the current buffer pointerprocessed by hw
 + *
 + * @substream:  substream for which the function is called
 + *
 + * This function is called by ALSA framework to get the current hw buffer ptr
 + * when a period is elapsed
   */
++<<<<<<< HEAD
 +static snd_pcm_uframes_t snd_intelhad_pcm_pointer(
 +					struct snd_pcm_substream *substream)
++=======
+ static snd_pcm_uframes_t had_pcm_pointer(struct snd_pcm_substream *substream)
++>>>>>>> b556290f9a83 (ALSA: x86: Unify local function prefix)
  {
  	struct snd_intelhad *intelhaddata;
  	u32 bytes_rendered = 0;
@@@ -1392,124 -1209,324 +1421,416 @@@
  			intelhaddata->stream_info.ring_buf_size,
  			&(bytes_rendered));
  
 -	return bytes_to_frames(substream->runtime, bytes_rendered + t);
 +	intelhaddata->stream_info.buffer_ptr = bytes_to_frames(
 +						substream->runtime,
 +						bytes_rendered + t);
 +	return intelhaddata->stream_info.buffer_ptr;
  }
  
 -/*
 - * ALSA PCM mmap callback
 +/**
 + * snd_intelhad_pcm_mmap- mmaps a kernel buffer to user space for copying data
 + *
 + * @substream:  substream for which the function is called
 + * @vma:		struct instance of memory VMM memory area
 + *
 + * This function is called by OS when a user space component
 + * tries to get mmap memory from driver
   */
- static int snd_intelhad_pcm_mmap(struct snd_pcm_substream *substream,
- 	struct vm_area_struct *vma)
+ static int had_pcm_mmap(struct snd_pcm_substream *substream,
+ 			struct vm_area_struct *vma)
  {
 +
 +	pr_debug("snd_intelhad_pcm_mmap called\n");
 +
 +	pr_debug("entry with prot:%s\n", __func__);
  	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
  	return remap_pfn_range(vma, vma->vm_start,
  			substream->dma_buffer.addr >> PAGE_SHIFT,
  			vma->vm_end - vma->vm_start, vma->vm_page_prot);
  }
  
++<<<<<<< HEAD
 +int hdmi_audio_mode_change(struct snd_pcm_substream *substream)
 +{
 +	int retval = 0;
 +	u32 disp_samp_freq, n_param;
 +	u32 link_rate = 0;
 +	struct snd_intelhad *intelhaddata;
 +
 +	intelhaddata = snd_pcm_substream_chip(substream);
 +
 +	/* Disable Audio */
 +	snd_intelhad_enable_audio(substream, 0);
 +
 +	/* Update CTS value */
 +	retval = had_get_caps(intelhaddata, HAD_GET_DISPLAY_RATE,
 +			      &disp_samp_freq);
 +	if (retval) {
 +		pr_err("querying display sampling freq failed %#x\n", retval);
 +		goto out;
 +	}
 +
 +	retval = snd_intelhad_prog_n(substream->runtime->rate, &n_param,
 +				     intelhaddata);
 +	if (retval) {
 +		pr_err("programming N value failed %#x\n", retval);
 +		goto out;
 +	}
 +
 +	if (intelhaddata->dp_output)
 +		had_get_caps(intelhaddata, HAD_GET_LINK_RATE, &link_rate);
 +
 +	snd_intelhad_prog_cts(substream->runtime->rate,
 +			      disp_samp_freq, link_rate,
 +			      n_param, intelhaddata);
 +
 +	/* Enable Audio */
 +	snd_intelhad_enable_audio(substream, 1);
 +
 +out:
 +	return retval;
 +}
 +
 +/*PCM operations structure and the calls back for the same */
 +struct snd_pcm_ops snd_intelhad_playback_ops = {
 +	.open =		snd_intelhad_open,
 +	.close =	snd_intelhad_close,
++=======
+ /*
+  * ALSA PCM ops
+  */
+ static const struct snd_pcm_ops had_pcm_ops = {
+ 	.open =		had_pcm_open,
+ 	.close =	had_pcm_close,
++>>>>>>> b556290f9a83 (ALSA: x86: Unify local function prefix)
  	.ioctl =	snd_pcm_lib_ioctl,
- 	.hw_params =	snd_intelhad_hw_params,
- 	.hw_free =	snd_intelhad_hw_free,
- 	.prepare =	snd_intelhad_pcm_prepare,
- 	.trigger =	snd_intelhad_pcm_trigger,
- 	.pointer =	snd_intelhad_pcm_pointer,
- 	.mmap =	snd_intelhad_pcm_mmap,
+ 	.hw_params =	had_pcm_hw_params,
+ 	.hw_free =	had_pcm_hw_free,
+ 	.prepare =	had_pcm_prepare,
+ 	.trigger =	had_pcm_trigger,
+ 	.pointer =	had_pcm_pointer,
+ 	.mmap =		had_pcm_mmap,
  };
  
++<<<<<<< HEAD
 +/**
 + * snd_intelhad_create - to crete alsa card instance
 + *
 + * @intelhaddata: pointer to internal context
 + * @card: pointer to card
 + *
 + * This function is called when the hdmi cable is plugged in
 + */
 +static int snd_intelhad_create(
 +		struct snd_intelhad *intelhaddata,
 +		struct snd_card *card)
++=======
+ /* process mode change of the running stream; called in mutex */
+ static int had_process_mode_change(struct snd_intelhad *intelhaddata)
++>>>>>>> b556290f9a83 (ALSA: x86: Unify local function prefix)
  {
 -	struct snd_pcm_substream *substream;
 -	int retval = 0;
 -	u32 disp_samp_freq, n_param;
 -	u32 link_rate = 0;
 +	int retval;
 +	static struct snd_device_ops ops = {
 +	};
  
 -	substream = had_substream_get(intelhaddata);
 -	if (!substream)
 -		return 0;
 +	pr_debug("snd_intelhad_create called\n");
 +
++<<<<<<< HEAD
 +	if (!intelhaddata)
 +		return -EINVAL;
  
 +	/* ALSA api to register the device */
 +	retval = snd_device_new(card, SNDRV_DEV_LOWLEVEL, intelhaddata, &ops);
 +	return retval;
 +}
 +/**
 + * snd_intelhad_pcm_free - to free the memory allocated
 + *
 + * @pcm: pointer to pcm instance
 + * This function is called when the device is removed
++=======
+ 	/* Disable Audio */
+ 	had_enable_audio(substream, intelhaddata, false);
+ 
+ 	/* Update CTS value */
+ 	disp_samp_freq = intelhaddata->tmds_clock_speed;
+ 
+ 	retval = had_prog_n(substream->runtime->rate, &n_param, intelhaddata);
+ 	if (retval) {
+ 		dev_err(intelhaddata->dev,
+ 			"programming N value failed %#x\n", retval);
+ 		goto out;
+ 	}
+ 
+ 	if (intelhaddata->dp_output)
+ 		link_rate = intelhaddata->link_rate;
+ 
+ 	had_prog_cts(substream->runtime->rate, disp_samp_freq, link_rate,
+ 		     n_param, intelhaddata);
+ 
+ 	/* Enable Audio */
+ 	had_enable_audio(substream, intelhaddata, true);
+ 
+ out:
+ 	had_substream_put(intelhaddata);
+ 	return retval;
+ }
+ 
+ static inline int had_chk_intrmiss(struct snd_intelhad *intelhaddata,
+ 		enum intel_had_aud_buf_type buf_id)
+ {
+ 	int i, intr_count = 0;
+ 	enum intel_had_aud_buf_type buff_done;
+ 	u32 buf_size, buf_addr;
+ 
+ 	buff_done = buf_id;
+ 
+ 	intr_count = snd_intelhad_read_len(intelhaddata);
+ 	if (intr_count > 1) {
+ 		/* In case of active playback */
+ 		dev_err(intelhaddata->dev,
+ 			"Driver detected %d missed buffer done interrupt(s)\n",
+ 			(intr_count - 1));
+ 		if (intr_count > 3)
+ 			return intr_count;
+ 
+ 		buf_id += (intr_count - 1);
+ 		/* Reprogram registers*/
+ 		for (i = buff_done; i < buf_id; i++) {
+ 			int j = i % 4;
+ 
+ 			buf_size = intelhaddata->buf_info[j].buf_size;
+ 			buf_addr = intelhaddata->buf_info[j].buf_addr;
+ 			had_write_register(intelhaddata,
+ 					   AUD_BUF_A_LENGTH +
+ 					   (j * HAD_REG_WIDTH), buf_size);
+ 			had_write_register(intelhaddata,
+ 					   AUD_BUF_A_ADDR+(j * HAD_REG_WIDTH),
+ 					   (buf_addr | BIT(0) | BIT(1)));
+ 		}
+ 		buf_id = buf_id % 4;
+ 		intelhaddata->buff_done = buf_id;
+ 	}
+ 
+ 	return intr_count;
+ }
+ 
+ /* called from irq handler */
+ static int had_process_buffer_done(struct snd_intelhad *intelhaddata)
+ {
+ 	u32 len = 1;
+ 	enum intel_had_aud_buf_type buf_id;
+ 	enum intel_had_aud_buf_type buff_done;
+ 	struct pcm_stream_info *stream;
+ 	struct snd_pcm_substream *substream;
+ 	u32 buf_size;
+ 	int intr_count;
+ 	unsigned long flags;
+ 
+ 	stream = &intelhaddata->stream_info;
+ 	intr_count = 1;
+ 
+ 	spin_lock_irqsave(&intelhaddata->had_spinlock, flags);
+ 	if (!intelhaddata->connected) {
+ 		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flags);
+ 		dev_dbg(intelhaddata->dev,
+ 			"%s:Device already disconnected\n", __func__);
+ 		return 0;
+ 	}
+ 	buf_id = intelhaddata->curr_buf;
+ 	intelhaddata->buff_done = buf_id;
+ 	buff_done = intelhaddata->buff_done;
+ 	buf_size = intelhaddata->buf_info[buf_id].buf_size;
+ 
+ 	/* Every debug statement has an implication
+ 	 * of ~5msec. Thus, avoid having >3 debug statements
+ 	 * for each buffer_done handling.
+ 	 */
+ 
+ 	/* Check for any intr_miss in case of active playback */
+ 	if (stream->running) {
+ 		intr_count = had_chk_intrmiss(intelhaddata, buf_id);
+ 		if (!intr_count || (intr_count > 3)) {
+ 			spin_unlock_irqrestore(&intelhaddata->had_spinlock,
+ 					       flags);
+ 			dev_err(intelhaddata->dev,
+ 				"HAD SW state in non-recoverable mode\n");
+ 			return 0;
+ 		}
+ 		buf_id += (intr_count - 1);
+ 		buf_id = buf_id % 4;
+ 	}
+ 
+ 	intelhaddata->buf_info[buf_id].is_valid = true;
+ 	if (intelhaddata->valid_buf_cnt-1 == buf_id) {
+ 		if (stream->running)
+ 			intelhaddata->curr_buf = HAD_BUF_TYPE_A;
+ 	} else
+ 		intelhaddata->curr_buf = buf_id + 1;
+ 
+ 	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flags);
+ 
+ 	if (!intelhaddata->connected) {
+ 		dev_dbg(intelhaddata->dev, "HDMI cable plugged-out\n");
+ 		return 0;
+ 	}
+ 
+ 	/* Reprogram the registers with addr and length */
+ 	had_write_register(intelhaddata,
+ 			   AUD_BUF_A_LENGTH + (buf_id * HAD_REG_WIDTH),
+ 			   buf_size);
+ 	had_write_register(intelhaddata,
+ 			   AUD_BUF_A_ADDR + (buf_id * HAD_REG_WIDTH),
+ 			   intelhaddata->buf_info[buf_id].buf_addr |
+ 			   BIT(0) | BIT(1));
+ 
+ 	had_read_register(intelhaddata,
+ 			  AUD_BUF_A_LENGTH + (buf_id * HAD_REG_WIDTH),
+ 			  &len);
+ 	dev_dbg(intelhaddata->dev, "%s:Enabled buf[%d]\n", __func__, buf_id);
+ 
+ 	/* In case of actual data,
+ 	 * report buffer_done to above ALSA layer
+ 	 */
+ 	substream = had_substream_get(intelhaddata);
+ 	if (substream) {
+ 		buf_size = intelhaddata->buf_info[buf_id].buf_size;
+ 		intelhaddata->stream_info.buffer_rendered +=
+ 			(intr_count * buf_size);
+ 		snd_pcm_period_elapsed(substream);
+ 		had_substream_put(intelhaddata);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /* called from irq handler */
+ static int had_process_buffer_underrun(struct snd_intelhad *intelhaddata)
+ {
+ 	enum intel_had_aud_buf_type buf_id;
+ 	struct pcm_stream_info *stream;
+ 	struct snd_pcm_substream *substream;
+ 	unsigned long flags;
+ 	int connected;
+ 
+ 	stream = &intelhaddata->stream_info;
+ 
+ 	spin_lock_irqsave(&intelhaddata->had_spinlock, flags);
+ 	buf_id = intelhaddata->curr_buf;
+ 	intelhaddata->buff_done = buf_id;
+ 	connected = intelhaddata->connected;
+ 	if (stream->running)
+ 		intelhaddata->curr_buf = HAD_BUF_TYPE_A;
+ 
+ 	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flags);
+ 
+ 	dev_dbg(intelhaddata->dev, "Enter:%s buf_id=%d, stream_running=%d\n",
+ 			__func__, buf_id, stream->running);
+ 
+ 	snd_intelhad_handle_underrun(intelhaddata);
+ 
+ 	if (!connected) {
+ 		dev_dbg(intelhaddata->dev,
+ 			"%s:Device already disconnected\n", __func__);
+ 		return 0;
+ 	}
+ 
+ 	/* Report UNDERRUN error to above layers */
+ 	substream = had_substream_get(intelhaddata);
+ 	if (substream) {
+ 		snd_pcm_stop_xrun(substream);
+ 		had_substream_put(intelhaddata);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /* process hot plug, called from wq with mutex locked */
+ static void had_process_hot_plug(struct snd_intelhad *intelhaddata)
+ {
+ 	enum intel_had_aud_buf_type buf_id;
+ 	struct snd_pcm_substream *substream;
+ 
+ 	spin_lock_irq(&intelhaddata->had_spinlock);
+ 	if (intelhaddata->connected) {
+ 		dev_dbg(intelhaddata->dev, "Device already connected\n");
+ 		spin_unlock_irq(&intelhaddata->had_spinlock);
+ 		return;
+ 	}
+ 
+ 	buf_id = intelhaddata->curr_buf;
+ 	intelhaddata->buff_done = buf_id;
+ 	intelhaddata->connected = true;
+ 	dev_dbg(intelhaddata->dev,
+ 		"%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_CONNECTED\n",
+ 			__func__, __LINE__);
+ 	spin_unlock_irq(&intelhaddata->had_spinlock);
+ 
+ 	dev_dbg(intelhaddata->dev, "Processing HOT_PLUG, buf_id = %d\n",
+ 		buf_id);
+ 
+ 	/* Safety check */
+ 	substream = had_substream_get(intelhaddata);
+ 	if (substream) {
+ 		dev_dbg(intelhaddata->dev,
+ 			"Force to stop the active stream by disconnection\n");
+ 		/* Set runtime->state to hw_params done */
+ 		snd_pcm_stop(substream, SNDRV_PCM_STATE_SETUP);
+ 		had_substream_put(intelhaddata);
+ 	}
+ 
+ 	had_build_channel_allocation_map(intelhaddata);
+ }
+ 
+ /* process hot unplug, called from wq with mutex locked */
+ static void had_process_hot_unplug(struct snd_intelhad *intelhaddata)
+ {
+ 	enum intel_had_aud_buf_type buf_id;
+ 	struct snd_pcm_substream *substream;
+ 
+ 	buf_id = intelhaddata->curr_buf;
+ 
+ 	substream = had_substream_get(intelhaddata);
+ 
+ 	spin_lock_irq(&intelhaddata->had_spinlock);
+ 
+ 	if (!intelhaddata->connected) {
+ 		dev_dbg(intelhaddata->dev, "Device already disconnected\n");
+ 		spin_unlock_irq(&intelhaddata->had_spinlock);
+ 		goto out;
+ 
+ 	}
+ 
+ 	/* Disable Audio */
+ 	had_enable_audio_int(intelhaddata, false);
+ 	had_enable_audio(substream, intelhaddata, false);
+ 
+ 	intelhaddata->connected = false;
+ 	dev_dbg(intelhaddata->dev,
+ 		"%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_DISCONNECTED\n",
+ 			__func__, __LINE__);
+ 	spin_unlock_irq(&intelhaddata->had_spinlock);
+ 
+ 	/* Report to above ALSA layer */
+ 	if (substream)
+ 		snd_pcm_stop(substream, SNDRV_PCM_STATE_SETUP);
+ 
+  out:
+ 	if (substream)
+ 		had_substream_put(intelhaddata);
+ 	kfree(intelhaddata->chmap->chmap);
+ 	intelhaddata->chmap->chmap = NULL;
+ }
+ 
+ /*
+  * ALSA iec958 and ELD controls
++>>>>>>> b556290f9a83 (ALSA: x86: Unify local function prefix)
   */
 +static void snd_intelhad_pcm_free(struct snd_pcm *pcm)
 +{
 +	pr_debug("Freeing PCM preallocated pages\n");
 +	snd_pcm_lib_preallocate_free_for_all(pcm);
 +}
  
  static int had_iec958_info(struct snd_kcontrol *kcontrol,
  				struct snd_ctl_elem_info *uinfo)
@@@ -1576,71 -1628,240 +1897,220 @@@ static struct snd_kcontrol_new had_cont
  };
  
  /*
++<<<<<<< HEAD
 + * hdmi_audio_probe - to create sound card instance for HDMI audio playabck
++=======
+  * audio interrupt handler
+  */
+ static irqreturn_t display_pipe_interrupt_handler(int irq, void *dev_id)
+ {
+ 	struct snd_intelhad *ctx = dev_id;
+ 	u32 audio_stat, audio_reg;
+ 
+ 	audio_reg = AUD_HDMI_STATUS;
+ 	had_read_register(ctx, audio_reg, &audio_stat);
+ 
+ 	if (audio_stat & HDMI_AUDIO_UNDERRUN) {
+ 		had_write_register(ctx, audio_reg, HDMI_AUDIO_UNDERRUN);
+ 		had_process_buffer_underrun(ctx);
+ 	}
+ 
+ 	if (audio_stat & HDMI_AUDIO_BUFFER_DONE) {
+ 		had_write_register(ctx, audio_reg, HDMI_AUDIO_BUFFER_DONE);
+ 		had_process_buffer_done(ctx);
+ 	}
+ 
+ 	return IRQ_HANDLED;
+ }
+ 
+ /*
+  * monitor plug/unplug notification from i915; just kick off the work
+  */
+ static void notify_audio_lpe(struct platform_device *pdev)
+ {
+ 	struct snd_intelhad *ctx = platform_get_drvdata(pdev);
+ 
+ 	schedule_work(&ctx->hdmi_audio_wq);
+ }
+ 
+ /* the work to handle monitor hot plug/unplug */
+ static void had_audio_wq(struct work_struct *work)
+ {
+ 	struct snd_intelhad *ctx =
+ 		container_of(work, struct snd_intelhad, hdmi_audio_wq);
+ 	struct intel_hdmi_lpe_audio_pdata *pdata = ctx->dev->platform_data;
+ 
+ 	pm_runtime_get_sync(ctx->dev);
+ 	mutex_lock(&ctx->mutex);
+ 	if (!pdata->hdmi_connected) {
+ 		dev_dbg(ctx->dev, "%s: Event: HAD_NOTIFY_HOT_UNPLUG\n",
+ 			__func__);
+ 		memset(ctx->eld, 0, sizeof(ctx->eld)); /* clear the old ELD */
+ 		had_process_hot_unplug(ctx);
+ 	} else {
+ 		struct intel_hdmi_lpe_audio_eld *eld = &pdata->eld;
+ 
+ 		dev_dbg(ctx->dev, "%s: HAD_NOTIFY_ELD : port = %d, tmds = %d\n",
+ 			__func__, eld->port_id,	pdata->tmds_clock_speed);
+ 
+ 		switch (eld->pipe_id) {
+ 		case 0:
+ 			ctx->had_config_offset = AUDIO_HDMI_CONFIG_A;
+ 			break;
+ 		case 1:
+ 			ctx->had_config_offset = AUDIO_HDMI_CONFIG_B;
+ 			break;
+ 		case 2:
+ 			ctx->had_config_offset = AUDIO_HDMI_CONFIG_C;
+ 			break;
+ 		default:
+ 			dev_dbg(ctx->dev, "Invalid pipe %d\n",
+ 				eld->pipe_id);
+ 			break;
+ 		}
+ 
+ 		memcpy(ctx->eld, eld->eld_data, sizeof(ctx->eld));
+ 
+ 		ctx->dp_output = pdata->dp_output;
+ 		ctx->tmds_clock_speed = pdata->tmds_clock_speed;
+ 		ctx->link_rate = pdata->link_rate;
+ 
+ 		had_process_hot_plug(ctx);
+ 
+ 		/* Process mode change if stream is active */
+ 		had_process_mode_change(ctx);
+ 	}
+ 	mutex_unlock(&ctx->mutex);
+ 	pm_runtime_put(ctx->dev);
+ }
+ 
+ /*
+  * PM callbacks
+  */
+ 
+ static int hdmi_lpe_audio_runtime_suspend(struct device *dev)
+ {
+ 	struct snd_intelhad *ctx = dev_get_drvdata(dev);
+ 	struct snd_pcm_substream *substream;
+ 
+ 	substream = had_substream_get(ctx);
+ 	if (substream) {
+ 		snd_pcm_suspend(substream);
+ 		had_substream_put(ctx);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int hdmi_lpe_audio_suspend(struct device *dev)
+ {
+ 	struct snd_intelhad *ctx = dev_get_drvdata(dev);
+ 	int err;
+ 
+ 	err = hdmi_lpe_audio_runtime_suspend(dev);
+ 	if (!err)
+ 		snd_power_change_state(ctx->card, SNDRV_CTL_POWER_D3hot);
+ 	return err;
+ }
+ 
+ static int hdmi_lpe_audio_resume(struct device *dev)
+ {
+ 	struct snd_intelhad *ctx = dev_get_drvdata(dev);
+ 
+ 	snd_power_change_state(ctx->card, SNDRV_CTL_POWER_D0);
+ 	return 0;
+ }
+ 
+ /* release resources */
+ static void hdmi_lpe_audio_free(struct snd_card *card)
+ {
+ 	struct snd_intelhad *ctx = card->private_data;
+ 
+ 	cancel_work_sync(&ctx->hdmi_audio_wq);
+ 
+ 	if (ctx->mmio_start)
+ 		iounmap(ctx->mmio_start);
+ 	if (ctx->irq >= 0)
+ 		free_irq(ctx->irq, ctx);
+ }
+ 
+ /*
+  * hdmi_lpe_audio_probe - start bridge with i915
++>>>>>>> b556290f9a83 (ALSA: x86: Unify local function prefix)
 + *
 + * @devptr: platform device
 + * @had_ret: pointer to store the created snd_intelhad object
   *
 - * This function is called when the i915 driver creates the
 - * hdmi-lpe-audio platform device.
 + * This function is called when the platform device is probed. This function
 + * creates and registers the sound card with ALSA
   */
 -static int hdmi_lpe_audio_probe(struct platform_device *pdev)
 +int hdmi_audio_probe(struct platform_device *devptr,
 +		     struct snd_intelhad **had_ret)
  {
 -	struct snd_card *card;
 -	struct snd_intelhad *ctx;
 +	int retval;
  	struct snd_pcm *pcm;
 -	struct intel_hdmi_lpe_audio_pdata *pdata;
 -	int irq;
 -	struct resource *res_mmio;
 -	int i, ret;
 -
 -	pdata = pdev->dev.platform_data;
 -	if (!pdata) {
 -		dev_err(&pdev->dev, "%s: quit: pdata not allocated by i915!!\n", __func__);
 -		return -EINVAL;
 -	}
 +	struct snd_card *card;
 +	struct snd_intelhad *intelhaddata;
 +	struct had_pvt_data *had_stream;
  
 -	/* get resources */
 -	irq = platform_get_irq(pdev, 0);
 -	if (irq < 0) {
 -		dev_err(&pdev->dev, "Could not get irq resource\n");
 -		return -ENODEV;
 -	}
 +	pr_debug("Enter %s\n", __func__);
  
 -	res_mmio = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 -	if (!res_mmio) {
 -		dev_err(&pdev->dev, "Could not get IO_MEM resources\n");
 -		return -ENXIO;
 -	}
 +	pr_debug("hdmi_audio_probe dma_mask: %p\n", devptr->dev.dma_mask);
  
 -	/* create a card instance with ALSA framework */
 -	ret = snd_card_new(&pdev->dev, hdmi_card_index, hdmi_card_id,
 -			   THIS_MODULE, sizeof(*ctx), &card);
 -	if (ret)
 -		return ret;
 -
 -	ctx = card->private_data;
 -	spin_lock_init(&ctx->had_spinlock);
 -	mutex_init(&ctx->mutex);
 -	ctx->connected = false;
 -	ctx->dev = &pdev->dev;
 -	ctx->card = card;
 -	ctx->aes_bits = SNDRV_PCM_DEFAULT_CON_SPDIF;
 -	strcpy(card->driver, INTEL_HAD);
 -	strcpy(card->shortname, INTEL_HAD);
 -
 -	ctx->irq = -1;
 -	ctx->tmds_clock_speed = DIS_SAMPLE_RATE_148_5;
 -	INIT_WORK(&ctx->hdmi_audio_wq, had_audio_wq);
 -
 -	card->private_free = hdmi_lpe_audio_free;
 -
 -	/* assume pipe A as default */
 -	ctx->had_config_offset = AUDIO_HDMI_CONFIG_A;
 -
 -	platform_set_drvdata(pdev, ctx);
 -
 -	dev_dbg(&pdev->dev, "%s: mmio_start = 0x%x, mmio_end = 0x%x\n",
 -		__func__, (unsigned int)res_mmio->start,
 -		(unsigned int)res_mmio->end);
 -
 -	ctx->mmio_start = ioremap_nocache(res_mmio->start,
 -					  (size_t)(resource_size(res_mmio)));
 -	if (!ctx->mmio_start) {
 -		dev_err(&pdev->dev, "Could not get ioremap\n");
 -		ret = -EACCES;
 -		goto err;
 -	}
 +	/* allocate memory for saving internal context and working */
 +	intelhaddata = kzalloc(sizeof(*intelhaddata), GFP_KERNEL);
 +	if (!intelhaddata)
 +		return -ENOMEM;
  
 -	/* setup interrupt handler */
 -	ret = request_irq(irq, display_pipe_interrupt_handler, 0,
 -			  pdev->name, ctx);
 -	if (ret < 0) {
 -		dev_err(&pdev->dev, "request_irq failed\n");
 -		goto err;
 +	had_stream = kzalloc(sizeof(*had_stream), GFP_KERNEL);
 +	if (!had_stream) {
 +		retval = -ENOMEM;
 +		goto free_haddata;
  	}
  
 -	ctx->irq = irq;
 +	spin_lock_init(&intelhaddata->had_spinlock);
 +	intelhaddata->drv_status = HAD_DRV_DISCONNECTED;
 +	pr_debug("%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_DISCONNECTED\n",
 +			__func__, __LINE__);
  
 -	ret = snd_pcm_new(card, INTEL_HAD, PCM_INDEX, MAX_PB_STREAMS,
 -			  MAX_CAP_STREAMS, &pcm);
 -	if (ret)
 +	/* create a card instance with ALSA framework */
 +	retval = snd_card_new(&devptr->dev, hdmi_card_index, hdmi_card_id,
 +				THIS_MODULE, 0, &card);
 +
 +	if (retval)
 +		goto free_hadstream;
 +	intelhaddata->card = card;
 +	intelhaddata->card_id = hdmi_card_id;
 +	intelhaddata->card_index = card->number;
 +	intelhaddata->private_data = had_stream;
 +	intelhaddata->flag_underrun = 0;
 +	intelhaddata->aes_bits = SNDRV_PCM_DEFAULT_CON_SPDIF;
 +	strncpy(card->driver, INTEL_HAD, strlen(INTEL_HAD));
 +	strncpy(card->shortname, INTEL_HAD, strlen(INTEL_HAD));
 +
 +	retval = snd_pcm_new(card, INTEL_HAD, PCM_INDEX, MAX_PB_STREAMS,
 +						MAX_CAP_STREAMS, &pcm);
 +	if (retval)
  		goto err;
  
  	/* setup private data which can be retrieved when required */
 -	pcm->private_data = ctx;
 +	pcm->private_data = intelhaddata;
 +	pcm->private_free = snd_intelhad_pcm_free;
  	pcm->info_flags = 0;
  	strncpy(pcm->name, card->shortname, strlen(card->shortname));
++<<<<<<< HEAD
 +	/* setup the ops for palyabck */
 +	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
 +			    &snd_intelhad_playback_ops);
++=======
+ 	/* setup the ops for playabck */
+ 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &had_pcm_ops);
+ 
+ 	/* only 32bit addressable */
+ 	dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));
+ 	dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
+ 
++>>>>>>> b556290f9a83 (ALSA: x86: Unify local function prefix)
  	/* allocate dma pages for ALSA stream operations
  	 * memory allocated is based on size, not max value
  	 * thus using same argument for max & size
@@@ -1708,30 -1907,17 +2178,36 @@@ free_haddata
  }
  
  /*
 - * hdmi_lpe_audio_remove - stop bridge with i915
 + * hdmi_audio_remove - removes the alsa card
   *
 - * This function is called when the platform device is destroyed.
 + *@haddata: pointer to HAD private data
 + *
 + * This function is called when the hdmi cable is un-plugged. This function
 + * free the sound card.
   */
 -static int hdmi_lpe_audio_remove(struct platform_device *pdev)
 +int hdmi_audio_remove(struct snd_intelhad *intelhaddata)
  {
 -	struct snd_intelhad *ctx = platform_get_drvdata(pdev);
 +	int caps;
  
++<<<<<<< HEAD
 +	pr_debug("Enter %s\n", __func__);
 +
 +	if (!intelhaddata)
 +		return 0;
 +
 +	if (intelhaddata->drv_status != HAD_DRV_DISCONNECTED) {
 +		caps = HDMI_AUDIO_UNDERRUN | HDMI_AUDIO_BUFFER_DONE;
 +		had_set_caps(intelhaddata, HAD_SET_DISABLE_AUDIO_INT, &caps);
 +		had_set_caps(intelhaddata, HAD_SET_DISABLE_AUDIO, NULL);
 +	}
 +	snd_card_free(intelhaddata->card);
 +	kfree(intelhaddata->private_data);
 +	kfree(intelhaddata);
++=======
+ 	if (ctx->connected)
+ 		had_enable_audio_int(ctx, false);
+ 	snd_card_free(ctx->card);
++>>>>>>> b556290f9a83 (ALSA: x86: Unify local function prefix)
  	return 0;
  }
  
* Unmerged path sound/x86/intel_hdmi_audio.c
