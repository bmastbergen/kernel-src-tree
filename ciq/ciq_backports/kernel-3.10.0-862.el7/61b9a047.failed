l2tp: fix race in l2tp_recv_common()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Guillaume Nault <g.nault@alphalink.fr>
commit 61b9a047729bb230978178bca6729689d0c50ca2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/61b9a047.failed

Taking a reference on sessions in l2tp_recv_common() is racy; this
has to be done by the callers.

To this end, a new function is required (l2tp_session_get()) to
atomically lookup a session and take a reference on it. Callers then
have to manually drop this reference.

Fixes: fd558d186df2 ("l2tp: Split pppol2tp patch into separate l2tp and ppp parts")
	Signed-off-by: Guillaume Nault <g.nault@alphalink.fr>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 61b9a047729bb230978178bca6729689d0c50ca2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/l2tp/l2tp_core.h
#	net/l2tp/l2tp_ip6.c
diff --cc net/l2tp/l2tp_core.h
index 0733c826b163,4544e81a3d27..000000000000
--- a/net/l2tp/l2tp_core.h
+++ b/net/l2tp/l2tp_core.h
@@@ -235,29 -230,42 +235,42 @@@ out
  	return tunnel;
  }
  
++<<<<<<< HEAD
 +extern struct sock *l2tp_tunnel_sock_lookup(struct l2tp_tunnel *tunnel);
 +extern void l2tp_tunnel_sock_put(struct sock *sk);
 +extern struct l2tp_session *l2tp_session_find(struct net *net, struct l2tp_tunnel *tunnel, u32 session_id);
 +extern struct l2tp_session *l2tp_session_find_nth(struct l2tp_tunnel *tunnel, int nth);
 +extern struct l2tp_session *l2tp_session_find_by_ifname(struct net *net, char *ifname);
 +extern struct l2tp_tunnel *l2tp_tunnel_find(struct net *net, u32 tunnel_id);
 +extern struct l2tp_tunnel *l2tp_tunnel_find_nth(struct net *net, int nth);
++=======
+ struct l2tp_session *l2tp_session_get(struct net *net,
+ 				      struct l2tp_tunnel *tunnel,
+ 				      u32 session_id, bool do_ref);
+ struct l2tp_session *l2tp_session_find(struct net *net,
+ 				       struct l2tp_tunnel *tunnel,
+ 				       u32 session_id);
+ struct l2tp_session *l2tp_session_find_nth(struct l2tp_tunnel *tunnel, int nth);
+ struct l2tp_session *l2tp_session_find_by_ifname(struct net *net, char *ifname);
+ struct l2tp_tunnel *l2tp_tunnel_find(struct net *net, u32 tunnel_id);
+ struct l2tp_tunnel *l2tp_tunnel_find_nth(struct net *net, int nth);
 -
 -int l2tp_tunnel_create(struct net *net, int fd, int version, u32 tunnel_id,
 -		       u32 peer_tunnel_id, struct l2tp_tunnel_cfg *cfg,
 -		       struct l2tp_tunnel **tunnelp);
 -void l2tp_tunnel_closeall(struct l2tp_tunnel *tunnel);
 -int l2tp_tunnel_delete(struct l2tp_tunnel *tunnel);
 -struct l2tp_session *l2tp_session_create(int priv_size,
 -					 struct l2tp_tunnel *tunnel,
 -					 u32 session_id, u32 peer_session_id,
 -					 struct l2tp_session_cfg *cfg);
 -void __l2tp_session_unhash(struct l2tp_session *session);
 -int l2tp_session_delete(struct l2tp_session *session);
 -void l2tp_session_free(struct l2tp_session *session);
 -void l2tp_recv_common(struct l2tp_session *session, struct sk_buff *skb,
 -		      unsigned char *ptr, unsigned char *optr, u16 hdrflags,
 -		      int length, int (*payload_hook)(struct sk_buff *skb));
 -int l2tp_session_queue_purge(struct l2tp_session *session);
 -int l2tp_udp_encap_recv(struct sock *sk, struct sk_buff *skb);
 -void l2tp_session_set_header_len(struct l2tp_session *session, int version);
 -
 -int l2tp_xmit_skb(struct l2tp_session *session, struct sk_buff *skb,
 -		  int hdr_len);
 -
 -int l2tp_nl_register_ops(enum l2tp_pwtype pw_type,
 -			 const struct l2tp_nl_cmd_ops *ops);
 -void l2tp_nl_unregister_ops(enum l2tp_pwtype pw_type);
++>>>>>>> 61b9a047729b (l2tp: fix race in l2tp_recv_common())
 +
 +extern int l2tp_tunnel_create(struct net *net, int fd, int version, u32 tunnel_id, u32 peer_tunnel_id, struct l2tp_tunnel_cfg *cfg, struct l2tp_tunnel **tunnelp);
 +extern void l2tp_tunnel_closeall(struct l2tp_tunnel *tunnel);
 +extern int l2tp_tunnel_delete(struct l2tp_tunnel *tunnel);
 +extern struct l2tp_session *l2tp_session_create(int priv_size, struct l2tp_tunnel *tunnel, u32 session_id, u32 peer_session_id, struct l2tp_session_cfg *cfg);
 +extern void __l2tp_session_unhash(struct l2tp_session *session);
 +extern int l2tp_session_delete(struct l2tp_session *session);
 +extern void l2tp_session_free(struct l2tp_session *session);
 +extern void l2tp_recv_common(struct l2tp_session *session, struct sk_buff *skb, unsigned char *ptr, unsigned char *optr, u16 hdrflags, int length, int (*payload_hook)(struct sk_buff *skb));
 +extern int l2tp_session_queue_purge(struct l2tp_session *session);
 +extern int l2tp_udp_encap_recv(struct sock *sk, struct sk_buff *skb);
 +
 +extern int l2tp_xmit_skb(struct l2tp_session *session, struct sk_buff *skb, int hdr_len);
 +
 +extern int l2tp_nl_register_ops(enum l2tp_pwtype pw_type, const struct l2tp_nl_cmd_ops *ops);
 +extern void l2tp_nl_unregister_ops(enum l2tp_pwtype pw_type);
  int l2tp_ioctl(struct sock *sk, int cmd, unsigned long arg);
  
  /* Session reference counts. Incremented when code obtains a reference
diff --cc net/l2tp/l2tp_ip6.c
index 636e3095420e,88b397c30d86..000000000000
--- a/net/l2tp/l2tp_ip6.c
+++ b/net/l2tp/l2tp_ip6.c
@@@ -155,8 -156,8 +155,13 @@@ static int l2tp_ip6_recv(struct sk_buf
  	}
  
  	/* Ok, this is a data packet. Lookup the session. */
++<<<<<<< HEAD
 +	session = l2tp_session_find(&init_net, NULL, session_id);
 +	if (session == NULL)
++=======
+ 	session = l2tp_session_get(net, NULL, session_id, true);
+ 	if (!session)
++>>>>>>> 61b9a047729b (l2tp: fix race in l2tp_recv_common())
  		goto discard;
  
  	tunnel = session->tunnel;
@@@ -167,8 -168,11 +172,8 @@@
  	if (tunnel->debug & L2TP_MSG_DATA) {
  		length = min(32u, skb->len);
  		if (!pskb_may_pull(skb, length))
- 			goto discard;
+ 			goto discard_sess;
  
 -		/* Point to L2TP header */
 -		optr = ptr = skb->data;
 -		ptr += 4;
  		pr_debug("%s: ip recv\n", tunnel->name);
  		print_hex_dump_bytes("", DUMP_PREFIX_OFFSET, ptr, length);
  	}
diff --git a/net/l2tp/l2tp_core.c b/net/l2tp/l2tp_core.c
index 7316f2868a0c..2417ed7224d0 100644
--- a/net/l2tp/l2tp_core.c
+++ b/net/l2tp/l2tp_core.c
@@ -280,6 +280,55 @@ struct l2tp_session *l2tp_session_find(struct net *net, struct l2tp_tunnel *tunn
 }
 EXPORT_SYMBOL_GPL(l2tp_session_find);
 
+/* Like l2tp_session_find() but takes a reference on the returned session.
+ * Optionally calls session->ref() too if do_ref is true.
+ */
+struct l2tp_session *l2tp_session_get(struct net *net,
+				      struct l2tp_tunnel *tunnel,
+				      u32 session_id, bool do_ref)
+{
+	struct hlist_head *session_list;
+	struct l2tp_session *session;
+
+	if (!tunnel) {
+		struct l2tp_net *pn = l2tp_pernet(net);
+
+		session_list = l2tp_session_id_hash_2(pn, session_id);
+
+		rcu_read_lock_bh();
+		hlist_for_each_entry_rcu(session, session_list, global_hlist) {
+			if (session->session_id == session_id) {
+				l2tp_session_inc_refcount(session);
+				if (do_ref && session->ref)
+					session->ref(session);
+				rcu_read_unlock_bh();
+
+				return session;
+			}
+		}
+		rcu_read_unlock_bh();
+
+		return NULL;
+	}
+
+	session_list = l2tp_session_id_hash(tunnel, session_id);
+	read_lock_bh(&tunnel->hlist_lock);
+	hlist_for_each_entry(session, session_list, hlist) {
+		if (session->session_id == session_id) {
+			l2tp_session_inc_refcount(session);
+			if (do_ref && session->ref)
+				session->ref(session);
+			read_unlock_bh(&tunnel->hlist_lock);
+
+			return session;
+		}
+	}
+	read_unlock_bh(&tunnel->hlist_lock);
+
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(l2tp_session_get);
+
 struct l2tp_session *l2tp_session_find_nth(struct l2tp_tunnel *tunnel, int nth)
 {
 	int hash;
@@ -560,6 +609,9 @@ out:
  * a data (not control) frame before coming here. Fields up to the
  * session-id have already been parsed and ptr points to the data
  * after the session-id.
+ *
+ * session->ref() must have been called prior to l2tp_recv_common().
+ * session->deref() will be called automatically after skb is processed.
  */
 void l2tp_recv_common(struct l2tp_session *session, struct sk_buff *skb,
 		      unsigned char *ptr, unsigned char *optr, u16 hdrflags,
@@ -569,14 +621,6 @@ void l2tp_recv_common(struct l2tp_session *session, struct sk_buff *skb,
 	int offset;
 	u32 ns, nr;
 
-	/* The ref count is increased since we now hold a pointer to
-	 * the session. Take care to decrement the refcnt when exiting
-	 * this function from now on...
-	 */
-	l2tp_session_inc_refcount(session);
-	if (session->ref)
-		(*session->ref)(session);
-
 	/* Parse and check optional cookie */
 	if (session->peer_cookie_len > 0) {
 		if (memcmp(ptr, &session->peer_cookie[0], session->peer_cookie_len)) {
@@ -747,8 +791,6 @@ void l2tp_recv_common(struct l2tp_session *session, struct sk_buff *skb,
 	/* Try to dequeue as many skbs from reorder_q as we can. */
 	l2tp_recv_dequeue(session);
 
-	l2tp_session_dec_refcount(session);
-
 	return;
 
 discard:
@@ -757,8 +799,6 @@ discard:
 
 	if (session->deref)
 		(*session->deref)(session);
-
-	l2tp_session_dec_refcount(session);
 }
 EXPORT_SYMBOL(l2tp_recv_common);
 
@@ -865,8 +905,14 @@ static int l2tp_udp_recv_core(struct l2tp_tunnel *tunnel, struct sk_buff *skb,
 	}
 
 	/* Find the session context */
-	session = l2tp_session_find(tunnel->l2tp_net, tunnel, session_id);
+	session = l2tp_session_get(tunnel->l2tp_net, tunnel, session_id, true);
 	if (!session || !session->recv_skb) {
+		if (session) {
+			if (session->deref)
+				session->deref(session);
+			l2tp_session_dec_refcount(session);
+		}
+
 		/* Not found? Pass to userspace to deal with */
 		l2tp_info(tunnel, L2TP_MSG_DATA,
 			  "%s: no session found (%u/%u). Passing up.\n",
@@ -875,6 +921,7 @@ static int l2tp_udp_recv_core(struct l2tp_tunnel *tunnel, struct sk_buff *skb,
 	}
 
 	l2tp_recv_common(session, skb, ptr, optr, hdrflags, length, payload_hook);
+	l2tp_session_dec_refcount(session);
 
 	return 0;
 
* Unmerged path net/l2tp/l2tp_core.h
diff --git a/net/l2tp/l2tp_ip.c b/net/l2tp/l2tp_ip.c
index 967e60504f38..b42fab2b15a4 100644
--- a/net/l2tp/l2tp_ip.c
+++ b/net/l2tp/l2tp_ip.c
@@ -144,25 +144,26 @@ static int l2tp_ip_recv(struct sk_buff *skb)
 	}
 
 	/* Ok, this is a data packet. Lookup the session. */
-	session = l2tp_session_find(net, NULL, session_id);
-	if (session == NULL)
+	session = l2tp_session_get(net, NULL, session_id, true);
+	if (!session)
 		goto discard;
 
 	tunnel = session->tunnel;
-	if (tunnel == NULL)
-		goto discard;
+	if (!tunnel)
+		goto discard_sess;
 
 	/* Trace packet contents, if enabled */
 	if (tunnel->debug & L2TP_MSG_DATA) {
 		length = min(32u, skb->len);
 		if (!pskb_may_pull(skb, length))
-			goto discard;
+			goto discard_sess;
 
 		pr_debug("%s: ip recv\n", tunnel->name);
 		print_hex_dump_bytes("", DUMP_PREFIX_OFFSET, ptr, length);
 	}
 
 	l2tp_recv_common(session, skb, ptr, optr, 0, skb->len, tunnel->recv_payload_hook);
+	l2tp_session_dec_refcount(session);
 
 	return 0;
 
@@ -201,6 +202,12 @@ pass_up:
 
 	return sk_receive_skb(sk, skb, 1);
 
+discard_sess:
+	if (session->deref)
+		session->deref(session);
+	l2tp_session_dec_refcount(session);
+	goto discard;
+
 discard_put:
 	sock_put(sk);
 
* Unmerged path net/l2tp/l2tp_ip6.c
