mei: drop amthif internal client

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Alexander Usyskin <alexander.usyskin@intel.com>
commit 394a77d0bb63756871750400068d8b0c3582fba7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/394a77d0.failed

AMTHIF has special support in the mei drive, it handles multiplexing
multiple user space connection above single me client connection.
Since there is no additional addressing information there is a strict
requirement on the traffic order on each connection and on the "read
after write" order within the connection. This creates a lot of
complexity mostly because the other client types do not necessarily fall
under the same restriction.    After carefully studying the use of the
AMTHIF client, we came to conclusion that the multiplexing is not really
utilized by any application and we may safely remove that support and
significantly simplify the driver.

	Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 394a77d0bb63756871750400068d8b0c3582fba7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/amthif.c
#	drivers/misc/mei/client.c
#	drivers/misc/mei/client.h
#	drivers/misc/mei/init.c
#	drivers/misc/mei/interrupt.c
#	drivers/misc/mei/main.c
#	drivers/misc/mei/mei_dev.h
diff --cc drivers/misc/mei/client.c
index beb942e6c248,be64969d986a..000000000000
--- a/drivers/misc/mei/client.c
+++ b/drivers/misc/mei/client.c
@@@ -410,14 -411,30 +410,33 @@@ void mei_io_list_flush(struct mei_cl_c
  }
  
  /**
 - * mei_io_list_free_cl - removes cb belonging to cl and free them
 + * mei_io_list_free - removes cb belonging to cl and free them
   *
 - * @head: An instance of our list structure
 + * @list:  An instance of our list structure
   * @cl: host client
   */
 -static inline void mei_io_list_free_cl(struct list_head *head,
 -				       const struct mei_cl *cl)
 +static inline void mei_io_list_free(struct mei_cl_cb *list, struct mei_cl *cl)
  {
++<<<<<<< HEAD
 +	__mei_io_list_flush(list, cl, true);
++=======
+ 	__mei_io_list_flush_cl(head, cl, true);
+ }
+ 
+ /**
+  * mei_io_list_free_fp - free cb from a list that matches file pointer
+  *
+  * @head: io list
+  * @fp: file pointer (matching cb file object), may be NULL
+  */
+ static void mei_io_list_free_fp(struct list_head *head, const struct file *fp)
+ {
+ 	struct mei_cl_cb *cb, *next;
+ 
+ 	list_for_each_entry_safe(cb, next, head, list)
+ 		if (!fp || fp == cb->fp)
+ 			mei_io_cb_free(cb);
++>>>>>>> 394a77d0bb63 (mei: drop amthif internal client)
  }
  
  /**
@@@ -760,10 -756,10 +776,17 @@@ void mei_cl_set_disconnected(struct mei
  		return;
  
  	cl->state = MEI_FILE_DISCONNECTED;
++<<<<<<< HEAD
 +	mei_io_list_free(&dev->write_list, cl);
 +	mei_io_list_free(&dev->write_waiting_list, cl);
 +	mei_io_list_flush(&dev->ctrl_rd_list, cl);
 +	mei_io_list_flush(&dev->ctrl_wr_list, cl);
++=======
+ 	mei_io_list_free_cl(&dev->write_list, cl);
+ 	mei_io_list_free_cl(&dev->write_waiting_list, cl);
+ 	mei_io_list_flush_cl(&dev->ctrl_rd_list, cl);
+ 	mei_io_list_flush_cl(&dev->ctrl_wr_list, cl);
++>>>>>>> 394a77d0bb63 (mei: drop amthif internal client)
  	mei_cl_wake_all(cl);
  	cl->rx_flow_ctrl_creds = 0;
  	cl->tx_flow_ctrl_creds = 0;
diff --cc drivers/misc/mei/client.h
index f2545af9be7b,5371df4d8af3..000000000000
--- a/drivers/misc/mei/client.h
+++ b/drivers/misc/mei/client.h
@@@ -83,17 -83,6 +83,20 @@@ static inline u8 mei_me_cl_ver(const st
   * MEI IO Functions
   */
  void mei_io_cb_free(struct mei_cl_cb *priv_cb);
++<<<<<<< HEAD
 +
 +/**
 + * mei_io_list_init - Sets up a queue list.
 + *
 + * @list: An instance cl callback structure
 + */
 +static inline void mei_io_list_init(struct mei_cl_cb *list)
 +{
 +	INIT_LIST_HEAD(&list->list);
 +}
 +void mei_io_list_flush(struct mei_cl_cb *list, struct mei_cl *cl);
++=======
++>>>>>>> 394a77d0bb63 (mei: drop amthif internal client)
  
  /*
   * MEI Host Client Functions
@@@ -215,13 -200,11 +216,16 @@@ int mei_cl_irq_disconnect(struct mei_c
  int mei_cl_connect(struct mei_cl *cl, struct mei_me_client *me_cl,
  		   const struct file *file);
  int mei_cl_irq_connect(struct mei_cl *cl, struct mei_cl_cb *cb,
 -		       struct list_head *cmpl_list);
 +			      struct mei_cl_cb *cmpl_list);
  int mei_cl_read_start(struct mei_cl *cl, size_t length, const struct file *fp);
++<<<<<<< HEAD
 +int mei_cl_irq_read_msg(struct mei_cl *cl, struct mei_msg_hdr *hdr,
 +			struct mei_cl_cb *cmpl_list);
++=======
++>>>>>>> 394a77d0bb63 (mei: drop amthif internal client)
  int mei_cl_write(struct mei_cl *cl, struct mei_cl_cb *cb);
  int mei_cl_irq_write(struct mei_cl *cl, struct mei_cl_cb *cb,
 -		     struct list_head *cmpl_list);
 +		     struct mei_cl_cb *cmpl_list);
  
  void mei_cl_complete(struct mei_cl *cl, struct mei_cl_cb *cb);
  
diff --cc drivers/misc/mei/init.c
index a9a5b4e2105e,c8ad9ee7cb80..000000000000
--- a/drivers/misc/mei/init.c
+++ b/drivers/misc/mei/init.c
@@@ -387,9 -392,6 +378,12 @@@ void mei_device_init(struct mei_device 
  	INIT_WORK(&dev->reset_work, mei_reset_work);
  	INIT_WORK(&dev->bus_rescan_work, mei_cl_bus_rescan_work);
  
++<<<<<<< HEAD
 +	INIT_LIST_HEAD(&dev->iamthif_cl.link);
 +	mei_io_list_init(&dev->amthif_cmd_list);
 +
++=======
++>>>>>>> 394a77d0bb63 (mei: drop amthif internal client)
  	bitmap_zero(dev->host_clients_map, MEI_CLIENTS_MAX);
  	dev->open_handle_count = 0;
  
diff --cc drivers/misc/mei/interrupt.c
index b4e3ec92784a,c14e35201721..000000000000
--- a/drivers/misc/mei/interrupt.c
+++ b/drivers/misc/mei/interrupt.c
@@@ -96,9 -93,9 +93,15 @@@ static void mei_irq_discard_msg(struct 
   *
   * Return: always 0
   */
++<<<<<<< HEAD
 +int mei_cl_irq_read_msg(struct mei_cl *cl,
 +		       struct mei_msg_hdr *mei_hdr,
 +		       struct mei_cl_cb *complete_list)
++=======
+ static int mei_cl_irq_read_msg(struct mei_cl *cl,
+ 			       struct mei_msg_hdr *mei_hdr,
+ 			       struct list_head *cmpl_list)
++>>>>>>> 394a77d0bb63 (mei: drop amthif internal client)
  {
  	struct mei_device *dev = cl->dev;
  	struct mei_cl_cb *cb;
@@@ -438,12 -414,9 +437,9 @@@ int mei_irq_write_handler(struct mei_de
  	}
  	/* complete  write list CB */
  	dev_dbg(dev->dev, "complete write list cb.\n");
 -	list_for_each_entry_safe(cb, next, &dev->write_list, list) {
 +	list_for_each_entry_safe(cb, next, &dev->write_list.list, list) {
  		cl = cb->cl;
- 		if (cl == &dev->iamthif_cl)
- 			ret = mei_amthif_irq_write(cl, cb, cmpl_list);
- 		else
- 			ret = mei_cl_irq_write(cl, cb, cmpl_list);
+ 		ret = mei_cl_irq_write(cl, cb, cmpl_list);
  		if (ret)
  			return ret;
  	}
diff --cc drivers/misc/mei/main.c
index 0c610d790d13,9802c5930c10..000000000000
--- a/drivers/misc/mei/main.c
+++ b/drivers/misc/mei/main.c
@@@ -184,32 -179,26 +181,55 @@@ static ssize_t mei_read(struct file *fi
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	if (rets == -EBUSY &&
 +	    !mei_cl_enqueue_ctrl_wr_cb(cl, length, MEI_FOP_READ, file)) {
 +		rets = -ENOMEM;
 +		goto out;
 +	}
 +
 +	do {
 +		mutex_unlock(&dev->device_lock);
 +
 +		if (wait_event_interruptible(cl->rx_wait,
 +					     (!list_empty(&cl->rd_completed)) ||
 +					     (!mei_cl_is_connected(cl)))) {
 +
 +			if (signal_pending(current))
 +				return -EINTR;
 +			return -ERESTARTSYS;
 +		}
 +
 +		mutex_lock(&dev->device_lock);
 +		if (!mei_cl_is_connected(cl)) {
 +			rets = -ENODEV;
 +			goto out;
 +		}
 +
 +		cb = mei_cl_read_cb(cl, file);
 +	} while (!cb);
++=======
+ 	mutex_unlock(&dev->device_lock);
+ 	if (wait_event_interruptible(cl->rx_wait,
+ 				     !list_empty(&cl->rd_completed) ||
+ 				     !mei_cl_is_connected(cl))) {
+ 		if (signal_pending(current))
+ 			return -EINTR;
+ 		return -ERESTARTSYS;
+ 	}
+ 	mutex_lock(&dev->device_lock);
+ 
+ 	if (!mei_cl_is_connected(cl)) {
+ 		rets = -ENODEV;
+ 		goto out;
+ 	}
+ 
+ 	cb = mei_cl_read_cb(cl, file);
+ 	if (!cb) {
+ 		rets = 0;
+ 		goto out;
+ 	}
++>>>>>>> 394a77d0bb63 (mei: drop amthif internal client)
  
  copy_buffer:
  	/* now copy the data to user space */
diff --cc drivers/misc/mei/mei_dev.h
index 6fb341d0b992,63a67c99fc78..000000000000
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@@ -488,17 -478,9 +469,20 @@@ struct mei_device 
  	DECLARE_BITMAP(me_clients_map, MEI_CLIENTS_MAX);
  	DECLARE_BITMAP(host_clients_map, MEI_CLIENTS_MAX);
  
 -	bool allow_fixed_address;
 +	u32 allow_fixed_address;
  	bool override_fixed_address;
  
++<<<<<<< HEAD
 +	/* amthif list for cmd waiting */
 +	struct mei_cl_cb amthif_cmd_list;
 +	struct mei_cl iamthif_cl;
 +	long iamthif_open_count;
 +	u32 iamthif_stall_timer;
 +	enum iamthif_states iamthif_state;
 +	bool iamthif_canceled;
 +
++=======
++>>>>>>> 394a77d0bb63 (mei: drop amthif internal client)
  	struct work_struct reset_work;
  	struct work_struct bus_rescan_work;
  
@@@ -564,34 -546,12 +548,37 @@@ void mei_cancel_work(struct mei_device 
  void mei_timer(struct work_struct *work);
  void mei_schedule_stall_timer(struct mei_device *dev);
  int mei_irq_read_handler(struct mei_device *dev,
 -			 struct list_head *cmpl_list, s32 *slots);
 +		struct mei_cl_cb *cmpl_list, s32 *slots);
 +
 +int mei_irq_write_handler(struct mei_device *dev, struct mei_cl_cb *cmpl_list);
 +void mei_irq_compl_handler(struct mei_device *dev, struct mei_cl_cb *cmpl_list);
 +
 +/*
++<<<<<<< HEAD
 + * AMTHIF - AMT Host Interface Functions
 + */
 +void mei_amthif_reset_params(struct mei_device *dev);
 +
 +int mei_amthif_host_init(struct mei_device *dev, struct mei_me_client *me_cl);
 +
 +unsigned int mei_amthif_poll(struct file *file, poll_table *wait);
 +
 +int mei_amthif_release(struct mei_device *dev, struct file *file);
  
 -int mei_irq_write_handler(struct mei_device *dev, struct list_head *cmpl_list);
 -void mei_irq_compl_handler(struct mei_device *dev, struct list_head *cmpl_list);
 +int mei_amthif_write(struct mei_cl *cl, struct mei_cl_cb *cb);
 +int mei_amthif_run_next_cmd(struct mei_device *dev);
 +int mei_amthif_irq_write(struct mei_cl *cl, struct mei_cl_cb *cb,
 +			struct mei_cl_cb *cmpl_list);
 +
 +void mei_amthif_complete(struct mei_cl *cl, struct mei_cl_cb *cb);
 +int mei_amthif_irq_read_msg(struct mei_cl *cl,
 +			    struct mei_msg_hdr *mei_hdr,
 +			    struct mei_cl_cb *complete_list);
 +int mei_amthif_irq_read(struct mei_device *dev, s32 *slots);
  
  /*
++=======
++>>>>>>> 394a77d0bb63 (mei: drop amthif internal client)
   * Register Access Function
   */
  
* Unmerged path drivers/misc/mei/amthif.c
diff --git a/drivers/misc/mei/Makefile b/drivers/misc/mei/Makefile
index 59e6b0aede34..12cceb011a23 100644
--- a/drivers/misc/mei/Makefile
+++ b/drivers/misc/mei/Makefile
@@ -8,7 +8,6 @@ mei-objs += hbm.o
 mei-objs += interrupt.o
 mei-objs += client.o
 mei-objs += main.o
-mei-objs += amthif.o
 mei-objs += bus.o
 mei-objs += bus-fixup.o
 mei-$(CONFIG_DEBUG_FS) += debugfs.o
* Unmerged path drivers/misc/mei/amthif.c
diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 94cf8c82fe53..48f0603d2b2a 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -986,12 +986,6 @@ void mei_cl_bus_rescan_work(struct work_struct *work)
 {
 	struct mei_device *bus =
 		container_of(work, struct mei_device, bus_rescan_work);
-	struct mei_me_client *me_cl;
-
-	me_cl = mei_me_cl_by_uuid(bus, &mei_amthif_guid);
-	if (me_cl)
-		mei_amthif_host_init(bus, me_cl);
-	mei_me_cl_put(me_cl);
 
 	mei_cl_bus_rescan(bus);
 }
* Unmerged path drivers/misc/mei/client.c
* Unmerged path drivers/misc/mei/client.h
* Unmerged path drivers/misc/mei/init.c
* Unmerged path drivers/misc/mei/interrupt.c
* Unmerged path drivers/misc/mei/main.c
* Unmerged path drivers/misc/mei/mei_dev.h
