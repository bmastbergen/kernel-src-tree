scsi_dh_alua: remove 'rel_port' from alua_dh_data structure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Hannes Reinecke <hare@suse.de>
commit 7af33612f4dae69d6a8c79fd9313c618e20b0f7c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/7af33612.failed

The 'relative port' field is not used, and might get stale when
the port group changes. So remove the field altogether.

	Reviewed-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 7af33612f4dae69d6a8c79fd9313c618e20b0f7c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/device_handler/scsi_dh_alua.c
diff --cc drivers/scsi/device_handler/scsi_dh_alua.c
index 9c9d9c3d8e9b,7a351cf19ed2..000000000000
--- a/drivers/scsi/device_handler/scsi_dh_alua.c
+++ b/drivers/scsi/device_handler/scsi_dh_alua.c
@@@ -72,10 -81,12 +72,18 @@@ struct alua_dh_data 
  	int			state;
  	int			pref;
  	unsigned		flags; /* used for optimizing STPG */
 +	unsigned char		inq[ALUA_INQUIRY_SIZE];
 +	unsigned char		*buff;
 +	int			bufflen;
  	unsigned char		transition_tmo;
++<<<<<<< HEAD
++=======
+ };
+ 
+ struct alua_dh_data {
+ 	struct alua_port_group	*pg;
+ 	int			group_id;
++>>>>>>> 7af33612f4da (scsi_dh_alua: remove 'rel_port' from alua_dh_data structure)
  	struct scsi_device	*sdev;
  	activate_complete	callback_fn;
  	void			*callback_data;
@@@ -240,14 -317,19 +248,28 @@@ static int alua_check_vpd(struct scsi_d
  			    ALUA_DH_NAME);
  		return SCSI_DH_DEV_UNSUPP;
  	}
++<<<<<<< HEAD
 +	h->state = TPGS_STATE_OPTIMIZED;
 +	h->group_id = group_id;
 +
 +	sdev_printk(KERN_INFO, sdev,
 +		    "%s: port group %02x rel port %02x\n",
 +		    ALUA_DH_NAME, h->group_id, h->rel_port);
++=======
+ 
+ 	h->pg = alua_alloc_pg(sdev, group_id, tpgs);
+ 	if (IS_ERR(h->pg)) {
+ 		if (PTR_ERR(h->pg) == -ENOMEM)
+ 			return SCSI_DH_NOMEM;
+ 		return SCSI_DH_DEV_UNSUPP;
+ 	}
+ 	sdev_printk(KERN_INFO, sdev,
+ 		    "%s: device %s port group %x rel port %x\n",
+ 		    ALUA_DH_NAME, h->pg->device_id_str,
+ 		    h->group_id, rel_port);
++>>>>>>> 7af33612f4da (scsi_dh_alua: remove 'rel_port' from alua_dh_data structure)
  
 -	return alua_rtpg(sdev, h->pg);
 +	return 0;
  }
  
  static char print_alua_state(int state)
@@@ -658,13 -746,49 +680,36 @@@ static int alua_prep_fn(struct scsi_dev
  
  }
  
 -/*
 - * alua_bus_attach - Attach device handler
 - * @sdev: device to be attached to
 - */
 -static int alua_bus_attach(struct scsi_device *sdev)
 +static bool alua_match(struct scsi_device *sdev)
  {
++<<<<<<< HEAD
 +	return (scsi_device_tpgs(sdev) != 0);
++=======
+ 	struct alua_dh_data *h;
+ 	int err, ret = -EINVAL;
+ 
+ 	h = kzalloc(sizeof(*h) , GFP_KERNEL);
+ 	if (!h)
+ 		return -ENOMEM;
+ 	h->pg = NULL;
+ 	h->sdev = sdev;
+ 
+ 	err = alua_initialize(sdev, h);
+ 	if (err == SCSI_DH_NOMEM)
+ 		ret = -ENOMEM;
+ 	if (err != SCSI_DH_OK && err != SCSI_DH_DEV_OFFLINED)
+ 		goto failed;
+ 
+ 	sdev->handler_data = h;
+ 	return 0;
+ failed:
+ 	kfree(h);
+ 	return ret;
++>>>>>>> 7af33612f4da (scsi_dh_alua: remove 'rel_port' from alua_dh_data structure)
  }
  
 -/*
 - * alua_bus_detach - Detach device handler
 - * @sdev: device to be detached from
 - */
 -static void alua_bus_detach(struct scsi_device *sdev)
 -{
 -	struct alua_dh_data *h = sdev->handler_data;
 -
 -	if (h->pg) {
 -		kref_put(&h->pg->kref, release_port_group);
 -		h->pg = NULL;
 -	}
 -	sdev->handler_data = NULL;
 -	kfree(h);
 -}
 +static int alua_bus_attach(struct scsi_device *sdev);
 +static void alua_bus_detach(struct scsi_device *sdev);
  
  static struct scsi_device_handler alua_dh = {
  	.name = ALUA_DH_NAME,
* Unmerged path drivers/scsi/device_handler/scsi_dh_alua.c
