Drivers: hv: vmbus: Define an API to retrieve virtual processor index

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [hv] vmbus: Define an API to retrieve virtual processor index (Mohammed Gamal) [1467258]
Rebuild_FUZZ: 89.60%
commit-author K. Y. Srinivasan <kys@microsoft.com>
commit 7297ff0ca9db7e2d830841035b95d8b94b529142
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/7297ff0c.failed

As part of cleaning up architecture specific code, define an API
to retrieve the virtual procesor index.

	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 7297ff0ca9db7e2d830841035b95d8b94b529142)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/mshyperv.h
diff --cc arch/x86/include/asm/mshyperv.h
index 766df316b67a,2d40bfc57e7a..000000000000
--- a/arch/x86/include/asm/mshyperv.h
+++ b/arch/x86/include/asm/mshyperv.h
@@@ -70,6 -99,58 +70,61 @@@ static inline  __u64 generate_guest_id(
  	return guest_id;
  }
  
++<<<<<<< HEAD
++=======
+ 
+ /* Free the message slot and signal end-of-message if required */
+ static inline void vmbus_signal_eom(struct hv_message *msg, u32 old_msg_type)
+ {
+ 	/*
+ 	 * On crash we're reading some other CPU's message page and we need
+ 	 * to be careful: this other CPU may already had cleared the header
+ 	 * and the host may already had delivered some other message there.
+ 	 * In case we blindly write msg->header.message_type we're going
+ 	 * to lose it. We can still lose a message of the same type but
+ 	 * we count on the fact that there can only be one
+ 	 * CHANNELMSG_UNLOAD_RESPONSE and we don't care about other messages
+ 	 * on crash.
+ 	 */
+ 	if (cmpxchg(&msg->header.message_type, old_msg_type,
+ 		    HVMSG_NONE) != old_msg_type)
+ 		return;
+ 
+ 	/*
+ 	 * Make sure the write to MessageType (ie set to
+ 	 * HVMSG_NONE) happens before we read the
+ 	 * MessagePending and EOMing. Otherwise, the EOMing
+ 	 * will not deliver any more messages since there is
+ 	 * no empty slot
+ 	 */
+ 	mb();
+ 
+ 	if (msg->header.message_flags.msg_pending) {
+ 		/*
+ 		 * This will cause message queue rescan to
+ 		 * possibly deliver another msg from the
+ 		 * hypervisor
+ 		 */
+ 		wrmsrl(HV_X64_MSR_EOM, 0);
+ 	}
+ }
+ 
+ #define hv_get_current_tick(tick) rdmsrl(HV_X64_MSR_TIME_REF_COUNT, tick)
+ #define hv_init_timer(timer, tick) wrmsrl(timer, tick)
+ #define hv_init_timer_config(config, val) wrmsrl(config, val)
+ 
+ #define hv_get_simp(val) rdmsrl(HV_X64_MSR_SIMP, val)
+ #define hv_set_simp(val) wrmsrl(HV_X64_MSR_SIMP, val)
+ 
+ #define hv_get_siefp(val) rdmsrl(HV_X64_MSR_SIEFP, val)
+ #define hv_set_siefp(val) wrmsrl(HV_X64_MSR_SIEFP, val)
+ 
+ #define hv_get_synic_state(val) rdmsrl(HV_X64_MSR_SCONTROL, val)
+ #define hv_set_synic_state(val) wrmsrl(HV_X64_MSR_SCONTROL, val)
+ 
+ #define hv_get_vp_index(index) rdmsrl(HV_X64_MSR_VP_INDEX, index)
+ 
++>>>>>>> 7297ff0ca9db (Drivers: hv: vmbus: Define an API to retrieve virtual processor index)
  void hyperv_callback_vector(void);
  #ifdef CONFIG_TRACING
  #define trace_hyperv_callback_vector hyperv_callback_vector
* Unmerged path arch/x86/include/asm/mshyperv.h
diff --git a/drivers/hv/hv.c b/drivers/hv/hv.c
index f6a591c69dfd..898737123bfe 100644
--- a/drivers/hv/hv.c
+++ b/drivers/hv/hv.c
@@ -479,7 +479,7 @@ int hv_synic_init(unsigned int cpu)
 	 * of cpuid and Linux' notion of cpuid.
 	 * This array will be indexed using Linux cpuid.
 	 */
-	rdmsrl(HV_X64_MSR_VP_INDEX, vp_index);
+	hv_get_vp_index(vp_index);
 	hv_context.vp_index[cpu] = (u32)vp_index;
 
 	/*
