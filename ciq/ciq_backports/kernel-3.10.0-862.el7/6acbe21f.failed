s390/zcrypt: remove duplicate low level functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [s390] zcrypt: remove duplicate low level functions (Hendrik Brueckner) [1380349]
Rebuild_FUZZ: 94.62%
commit-author Martin Schwidefsky <schwidefsky@de.ibm.com>
commit 6acbe21f473f5cff8a11546f090967459b63ab3e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/6acbe21f.failed

ap_test_queue, ap_query_facilities, __ap_query_functions all use
the same PQAP(TAPQ) command. Consolidate the three into a single
ap_test_queue function that returns the AP status and the 64-bit
result. The exception table entry for PQAP(TAPQ) can be avoided
if the T bit for the APFT facility is set only if test_facility(15)
indicated that the facility is present.

Integrate ap_query_function into ap_query queue to avoid calling
PQAP(TAPQ) twice.

	Reviewed-by: Ingo Tuchscherer <ingo.tuchscherer@linux.vnet.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 6acbe21f473f5cff8a11546f090967459b63ab3e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/ap_bus.c
diff --cc drivers/s390/crypto/ap_bus.c
index 5386d81f8cd3,613c92b22445..000000000000
--- a/drivers/s390/crypto/ap_bus.c
+++ b/drivers/s390/crypto/ap_bus.c
@@@ -266,30 -241,7 +249,33 @@@ ap_queue_interruption_control(ap_qid_t 
  		: "cc" );
  	return reg1_out;
  }
 +#endif
 +
++<<<<<<< HEAD
 +#ifdef CONFIG_64BIT
 +static inline struct ap_queue_status
 +__ap_query_functions(ap_qid_t qid, unsigned int *functions)
 +{
 +	register unsigned long reg0 asm ("0") = 0UL | qid | (1UL << 23);
 +	register struct ap_queue_status reg1 asm ("1") = AP_QUEUE_STATUS_INVALID;
 +	register unsigned long reg2 asm ("2");
 +
 +	asm volatile(
 +		".long 0xb2af0000\n"		/* PQAP(TAPQ) */
 +		"0:\n"
 +		EX_TABLE(0b, 0b)
 +		: "+d" (reg0), "+d" (reg1), "=d" (reg2)
 +		:
 +		: "cc");
  
 +	*functions = (unsigned int)(reg2 >> 32);
 +	return reg1;
 +}
 +#endif
 +
 +#ifdef CONFIG_64BIT
++=======
++>>>>>>> 6acbe21f473f (s390/zcrypt: remove duplicate low level functions)
  static inline int __ap_query_configuration(struct ap_config_info *config)
  {
  	register unsigned long reg0 asm ("0") = 0x04000000UL;
@@@ -307,49 -259,8 +293,52 @@@
  
  	return reg1;
  }
 +#endif
 +
 +/**
++<<<<<<< HEAD
 + * ap_query_functions(): Query supported functions.
 + * @qid: The AP queue number
 + * @functions: Pointer to functions field.
 + *
 + * Returns
 + *   0	     on success.
 + *   -ENODEV  if queue not valid.
 + *   -EBUSY   if device busy.
 + *   -EINVAL  if query function is not supported
 + */
 +static int ap_query_functions(ap_qid_t qid, unsigned int *functions)
 +{
 +#ifdef CONFIG_64BIT
 +	struct ap_queue_status status;
 +
 +	status = __ap_query_functions(qid, functions);
 +
 +	if (ap_queue_status_invalid_test(&status))
 +		return -ENODEV;
 +
 +	switch (status.response_code) {
 +	case AP_RESPONSE_NORMAL:
 +		return 0;
 +	case AP_RESPONSE_Q_NOT_AVAIL:
 +	case AP_RESPONSE_DECONFIGURED:
 +	case AP_RESPONSE_CHECKSTOPPED:
 +	case AP_RESPONSE_INVALID_ADDRESS:
 +		return -ENODEV;
 +	case AP_RESPONSE_RESET_IN_PROGRESS:
 +	case AP_RESPONSE_BUSY:
 +	case AP_RESPONSE_OTHERWISE_CHANGED:
 +	default:
 +		return -EBUSY;
 +	}
 +#else
 +	return -EINVAL;
 +#endif
 +}
  
  /**
++=======
++>>>>>>> 6acbe21f473f (s390/zcrypt: remove duplicate low level functions)
   * ap_queue_enable_interruption(): Enable interruption on an AP.
   * @qid: The AP queue number
   * @ind: the notification indicator byte
@@@ -1493,7 -1402,10 +1488,14 @@@ static void ap_scan_bus(struct work_str
  			continue;
  		}
  		ap_dev->queue_depth = queue_depth;
++<<<<<<< HEAD
 +		ap_dev->unregistered = AP_DEV_REGIST_IN_PROGRESS;
++=======
+ 		ap_dev->raw_hwtype = device_type;
+ 		ap_dev->device_type = device_type;
+ 		ap_dev->functions = device_functions;
+ 		ap_dev->unregistered = 1;
++>>>>>>> 6acbe21f473f (s390/zcrypt: remove duplicate low level functions)
  		spin_lock_init(&ap_dev->lock);
  		INIT_LIST_HEAD(&ap_dev->pendingq);
  		INIT_LIST_HEAD(&ap_dev->requestq);
@@@ -1507,20 -1418,6 +1508,23 @@@
  				kfree(ap_dev);
  				continue;
  			}
++<<<<<<< HEAD
 +			break;
 +		default:
 +			ap_dev->device_type = device_type;
 +		}
 +		ap_dev->raw_hwtype = device_type;
 +		/* CEX6 toleration: map to CEX5 */
 +		if (device_type == AP_DEVICE_TYPE_CEX6)
 +			ap_dev->device_type = AP_DEVICE_TYPE_CEX5;
 +
 +		rc = ap_query_functions(qid, &device_functions);
 +		if (!rc)
 +			ap_dev->functions = device_functions;
 +		else
 +			ap_dev->functions = 0u;
++=======
++>>>>>>> 6acbe21f473f (s390/zcrypt: remove duplicate low level functions)
  
  		ap_dev->device.bus = &ap_bus_type;
  		ap_dev->device.parent = ap_root_device;
* Unmerged path drivers/s390/crypto/ap_bus.c
diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 2da8ecdc7a5f..b3299447d5e6 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -76,15 +76,6 @@ struct ap_queue_status {
 	unsigned int pad2		: 16;
 } __packed;
 
-#define AP_QUEUE_STATUS_INVALID \
-		{ 1, 1, 1, 0xF, 1, 0xFF, 0xFFFF }
-
-static inline
-int ap_queue_status_invalid_test(struct ap_queue_status *status)
-{
-	struct ap_queue_status invalid = AP_QUEUE_STATUS_INVALID;
-	return !(memcmp(status, &invalid, sizeof(struct ap_queue_status)));
-}
 
 #define AP_MAX_BITS 31
 static inline int ap_test_bit(unsigned int *ptr, unsigned int nr)
