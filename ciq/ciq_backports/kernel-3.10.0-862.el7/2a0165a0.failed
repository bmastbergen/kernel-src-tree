net/mlx5: Cancel delayed recovery work when unloading the driver

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Cancel delayed recovery work when unloading the driver (Kamal Heib) [1456694]
Rebuild_FUZZ: 96.77%
commit-author Mohamad Haj Yahia <mohamad@mellanox.com>
commit 2a0165a034ac024b60cca49c61e46f4afa2e4d98
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2a0165a0.failed

Draining the health workqueue will ignore future health works including
the one that report hardware failure and thus we can't enter error state
Instead cancel the recovery flow and make sure only recovery flow won't
be scheduled.

Fixes: 5e44fca50470 ('net/mlx5: Only cancel recovery work when cleaning up device')
	Signed-off-by: Mohamad Haj Yahia <mohamad@mellanox.com>
	Signed-off-by: Moshe Shemesh <moshe@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 2a0165a034ac024b60cca49c61e46f4afa2e4d98)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/health.c
#	include/linux/mlx5/driver.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/health.c
index c6679b21884e,8a8b5f0e497c..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/health.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/health.c
@@@ -193,8 -193,8 +194,13 @@@ static void health_care(struct work_str
  	mlx5_core_warn(dev, "handling bad device here\n");
  	mlx5_handle_bad_state(dev);
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&health->wq_lock, flags);
 +	if (!test_bit(MLX5_DROP_NEW_HEALTH_WORK, &health->flags))
++=======
+ 	spin_lock(&health->wq_lock);
+ 	if (!test_bit(MLX5_DROP_NEW_RECOVERY_WORK, &health->flags))
++>>>>>>> 2a0165a034ac (net/mlx5: Cancel delayed recovery work when unloading the driver)
  		schedule_delayed_work(&health->recover_work, recover_delay);
  	else
  		dev_err(&dev->pdev->dev,
@@@ -341,11 -334,11 +348,16 @@@ void mlx5_stop_health_poll(struct mlx5_
  void mlx5_drain_health_wq(struct mlx5_core_dev *dev)
  {
  	struct mlx5_core_health *health = &dev->priv.health;
 +	unsigned long flags;
  
 -	spin_lock(&health->wq_lock);
 +	spin_lock_irqsave(&health->wq_lock, flags);
  	set_bit(MLX5_DROP_NEW_HEALTH_WORK, &health->flags);
++<<<<<<< HEAD
 +	spin_unlock_irqrestore(&health->wq_lock, flags);
++=======
+ 	set_bit(MLX5_DROP_NEW_RECOVERY_WORK, &health->flags);
+ 	spin_unlock(&health->wq_lock);
++>>>>>>> 2a0165a034ac (net/mlx5: Cancel delayed recovery work when unloading the driver)
  	cancel_delayed_work_sync(&health->recover_work);
  	cancel_work_sync(&health->work);
  }
diff --cc include/linux/mlx5/driver.h
index a9905f6fdc14,ba260330ce5e..000000000000
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@@ -850,7 -925,7 +850,11 @@@ int mlx5_health_init(struct mlx5_core_d
  void mlx5_start_health_poll(struct mlx5_core_dev *dev);
  void mlx5_stop_health_poll(struct mlx5_core_dev *dev);
  void mlx5_drain_health_wq(struct mlx5_core_dev *dev);
++<<<<<<< HEAD
 +void mlx5_trigger_health_work(struct mlx5_core_dev *dev);
++=======
+ void mlx5_drain_health_recovery(struct mlx5_core_dev *dev);
++>>>>>>> 2a0165a034ac (net/mlx5: Cancel delayed recovery work when unloading the driver)
  int mlx5_buf_alloc_node(struct mlx5_core_dev *dev, int size,
  			struct mlx5_buf *buf, int node);
  int mlx5_buf_alloc(struct mlx5_core_dev *dev, int size, struct mlx5_buf *buf);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/health.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/main.c b/drivers/net/ethernet/mellanox/mlx5/core/main.c
index a49e8e69727c..f6ae02216abe 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c
@@ -1210,7 +1210,7 @@ static int mlx5_unload_one(struct mlx5_core_dev *dev, struct mlx5_priv *priv,
 	int err = 0;
 
 	if (cleanup)
-		mlx5_drain_health_wq(dev);
+		mlx5_drain_health_recovery(dev);
 
 	mutex_lock(&dev->intf_state_mutex);
 	if (test_bit(MLX5_INTERFACE_STATE_DOWN, &dev->intf_state)) {
* Unmerged path include/linux/mlx5/driver.h
