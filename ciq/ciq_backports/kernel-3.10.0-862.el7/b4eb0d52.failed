ALSA: x86: Split snd_intelhad into card and PCM specific structures

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit b4eb0d522fcba0ee819f955fd3279ff4682b8b33
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b4eb0d52.failed

To allow multiple PCM devices to be registered for the LPE audio card,
split the private data into card and PCM specific chunks. For now we'll
stick to just one PCM device as before.

v2: Rework to do a pcm device per port instead of per pipe

	Cc: Takashi Iwai <tiwai@suse.de>
	Cc: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/20170427160231.13337-11-ville.syrjala@linux.intel.com
	Reviewed-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit b4eb0d522fcba0ee819f955fd3279ff4682b8b33)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/x86/intel_hdmi_audio.c
#	sound/x86/intel_hdmi_audio.h
diff --cc sound/x86/intel_hdmi_audio.c
index 3dd33e089501,12fae26e70bb..000000000000
--- a/sound/x86/intel_hdmi_audio.c
+++ b/sound/x86/intel_hdmi_audio.c
@@@ -34,9 -37,14 +34,12 @@@
  #include <sound/pcm_params.h>
  #include <sound/initval.h>
  #include <sound/control.h>
 -#include <sound/jack.h>
 -#include <drm/drm_edid.h>
 -#include <drm/intel_lpe_audio.h>
 +#include <sound/initval.h>
  #include "intel_hdmi_audio.h"
  
+ #define for_each_port(card_ctx, port) \
+ 	for ((port) = 0; (port) < (card_ctx)->num_ports; (port)++)
+ 
  /*standard module options for ALSA. This module supports only one card*/
  static int hdmi_card_index = SNDRV_DEFAULT_IDX1;
  static char *hdmi_card_id = SNDRV_DEFAULT_STR1;
@@@ -151,81 -162,66 +154,89 @@@ static const struct snd_pcm_hardware sn
  	.fifo_size = HAD_FIFO_SIZE,
  };
  
 -/* Get the active PCM substream;
 - * Call had_substream_put() for unreferecing.
 - * Don't call this inside had_spinlock, as it takes by itself
 - */
 -static struct snd_pcm_substream *
 -had_substream_get(struct snd_intelhad *intelhaddata)
 +/* Register access functions */
 +
 +int had_get_hwstate(struct snd_intelhad *intelhaddata)
  {
 -	struct snd_pcm_substream *substream;
 -	unsigned long flags;
++<<<<<<< HEAD
 +	/* Check for device presence -SW state */
 +	if (intelhaddata->drv_status == HAD_DRV_DISCONNECTED) {
 +		pr_debug("%s:Device not connected:%d\n", __func__,
 +				intelhaddata->drv_status);
 +		return -ENODEV;
 +	}
  
 -	spin_lock_irqsave(&intelhaddata->had_spinlock, flags);
 -	substream = intelhaddata->stream_info.substream;
 -	if (substream)
 -		intelhaddata->stream_info.substream_refcount++;
 -	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flags);
 -	return substream;
 +	return 0;
++=======
++	return ioread32(ctx->card_ctx->mmio_start + ctx->had_config_offset + reg);
++>>>>>>> b4eb0d522fcb (ALSA: x86: Split snd_intelhad into card and PCM specific structures)
  }
  
 -/* Unref the active PCM substream;
 - * Don't call this inside had_spinlock, as it takes by itself
 - */
 -static void had_substream_put(struct snd_intelhad *intelhaddata)
 +int had_get_caps(struct snd_intelhad *intelhaddata,
 +		 enum had_caps_list query, void *caps)
  {
 -	unsigned long flags;
++<<<<<<< HEAD
 +	int retval;
  
 -	spin_lock_irqsave(&intelhaddata->had_spinlock, flags);
 -	intelhaddata->stream_info.substream_refcount--;
 -	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flags);
 +	retval = had_get_hwstate(intelhaddata);
 +	if (!retval)
 +		retval = mid_hdmi_audio_get_caps(query, caps);
 +
 +	return retval;
++=======
++	iowrite32(val, ctx->card_ctx->mmio_start + ctx->had_config_offset + reg);
++>>>>>>> b4eb0d522fcb (ALSA: x86: Split snd_intelhad into card and PCM specific structures)
  }
  
 -/* Register access functions */
 -static u32 had_read_register_raw(struct snd_intelhad *ctx, u32 reg)
 +int had_set_caps(struct snd_intelhad *intelhaddata,
 +		 enum had_caps_list set_element, void *caps)
  {
 -	return ioread32(ctx->card_ctx->mmio_start + ctx->had_config_offset + reg);
 +	int retval;
 +
 +	retval = had_get_hwstate(intelhaddata);
 +	if (!retval)
 +		retval = mid_hdmi_audio_set_caps(set_element, caps);
 +
 +	return retval;
  }
  
 -static void had_write_register_raw(struct snd_intelhad *ctx, u32 reg, u32 val)
 +int had_read_register(struct snd_intelhad *intelhaddata, u32 offset, u32 *data)
  {
 -	iowrite32(val, ctx->card_ctx->mmio_start + ctx->had_config_offset + reg);
 +	int retval;
 +
 +	retval = had_get_hwstate(intelhaddata);
 +	if (!retval)
 +		retval = mid_hdmi_audio_read(offset, data);
 +
 +	return retval;
  }
  
 -static void had_read_register(struct snd_intelhad *ctx, u32 reg, u32 *val)
 +int had_write_register(struct snd_intelhad *intelhaddata, u32 offset, u32 data)
  {
 -	if (!ctx->connected)
 -		*val = 0;
 -	else
 -		*val = had_read_register_raw(ctx, reg);
 +	int retval;
 +
 +	retval = had_get_hwstate(intelhaddata);
 +	if (!retval)
 +		retval = mid_hdmi_audio_write(offset, data);
 +
 +	return retval;
  }
  
 -static void had_write_register(struct snd_intelhad *ctx, u32 reg, u32 val)
 +int had_read_modify(struct snd_intelhad *intelhaddata, u32 offset,
 +		    u32 data, u32 mask)
  {
 -	if (ctx->connected)
 -		had_write_register_raw(ctx, reg, val);
 -}
 +	int retval;
  
 -/*
 - * enable / disable audio configuration
 - *
 - * The normal read/modify should not directly be used on VLV2 for
 - * updating AUD_CONFIG register.
 +	retval = had_get_hwstate(intelhaddata);
 +	if (!retval)
 +		retval = mid_hdmi_audio_rmw(offset, data, mask);
 +
 +	return retval;
 +}
 +/**
 + * function to read-modify
 + * AUD_CONFIG register on VLV2.The had_read_modify() function should not
 + * directly be used on VLV2 for updating AUD_CONFIG register.
   * This is because:
   * Bit6 of AUD_CONFIG register is writeonly due to a silicon bug on VLV2
   * HDMI IP. As a result a read-modify of AUD_CONFIG regiter will always
@@@ -1573,162 -1518,377 +1584,503 @@@ static struct snd_kcontrol_new had_cont
  };
  
  /*
++<<<<<<< HEAD
 + * hdmi_audio_probe - to create sound card instance for HDMI audio playabck
++=======
+  * audio interrupt handler
+  */
+ static irqreturn_t display_pipe_interrupt_handler(int irq, void *dev_id)
+ {
+ 	struct snd_intelhad_card *card_ctx = dev_id;
+ 	int port;
+ 
+ 	for_each_port(card_ctx, port) {
+ 		struct snd_intelhad *ctx = &card_ctx->pcm_ctx[port];
+ 		u32 audio_stat;
+ 
+ 		/* use raw register access to ack IRQs even while disconnected */
+ 		audio_stat = had_read_register_raw(ctx, AUD_HDMI_STATUS);
+ 
+ 		if (audio_stat & HDMI_AUDIO_UNDERRUN) {
+ 			had_write_register_raw(ctx, AUD_HDMI_STATUS,
+ 					       HDMI_AUDIO_UNDERRUN);
+ 			had_process_buffer_underrun(ctx);
+ 		}
+ 
+ 		if (audio_stat & HDMI_AUDIO_BUFFER_DONE) {
+ 			had_write_register_raw(ctx, AUD_HDMI_STATUS,
+ 					       HDMI_AUDIO_BUFFER_DONE);
+ 			had_process_buffer_done(ctx);
+ 		}
+ 	}
+ 
+ 	return IRQ_HANDLED;
+ }
+ 
+ /*
+  * monitor plug/unplug notification from i915; just kick off the work
+  */
+ static void notify_audio_lpe(struct platform_device *pdev)
+ {
+ 	struct snd_intelhad_card *card_ctx = platform_get_drvdata(pdev);
+ 	int port;
+ 
+ 	for_each_port(card_ctx, port) {
+ 		struct snd_intelhad *ctx = &card_ctx->pcm_ctx[port];
+ 
+ 		schedule_work(&ctx->hdmi_audio_wq);
+ 	}
+ }
+ 
+ /* the work to handle monitor hot plug/unplug */
+ static void had_audio_wq(struct work_struct *work)
+ {
+ 	struct snd_intelhad *ctx =
+ 		container_of(work, struct snd_intelhad, hdmi_audio_wq);
+ 	struct intel_hdmi_lpe_audio_pdata *pdata = ctx->dev->platform_data;
+ 	struct intel_hdmi_lpe_audio_port_pdata *ppdata = &pdata->port;
+ 
+ 	pm_runtime_get_sync(ctx->dev);
+ 	mutex_lock(&ctx->mutex);
+ 	if (ppdata->pipe < 0) {
+ 		dev_dbg(ctx->dev, "%s: Event: HAD_NOTIFY_HOT_UNPLUG\n",
+ 			__func__);
+ 		memset(ctx->eld, 0, sizeof(ctx->eld)); /* clear the old ELD */
+ 		had_process_hot_unplug(ctx);
+ 	} else {
+ 		dev_dbg(ctx->dev, "%s: HAD_NOTIFY_ELD : port = %d, tmds = %d\n",
+ 			__func__, ppdata->port, ppdata->ls_clock);
+ 
+ 		switch (ppdata->pipe) {
+ 		case 0:
+ 			ctx->had_config_offset = AUDIO_HDMI_CONFIG_A;
+ 			break;
+ 		case 1:
+ 			ctx->had_config_offset = AUDIO_HDMI_CONFIG_B;
+ 			break;
+ 		case 2:
+ 			ctx->had_config_offset = AUDIO_HDMI_CONFIG_C;
+ 			break;
+ 		default:
+ 			dev_dbg(ctx->dev, "Invalid pipe %d\n",
+ 				ppdata->pipe);
+ 			break;
+ 		}
+ 
+ 		memcpy(ctx->eld, ppdata->eld, sizeof(ctx->eld));
+ 
+ 		ctx->dp_output = ppdata->dp_output;
+ 		if (ctx->dp_output) {
+ 			ctx->tmds_clock_speed = 0;
+ 			ctx->link_rate = ppdata->ls_clock;
+ 		} else {
+ 			ctx->tmds_clock_speed = ppdata->ls_clock;
+ 			ctx->link_rate = 0;
+ 		}
+ 
+ 		had_process_hot_plug(ctx);
+ 
+ 		/* Process mode change if stream is active */
+ 		had_process_mode_change(ctx);
+ 	}
+ 	mutex_unlock(&ctx->mutex);
+ 	pm_runtime_mark_last_busy(ctx->dev);
+ 	pm_runtime_put_autosuspend(ctx->dev);
+ }
+ 
+ /*
+  * Jack interface
+  */
+ static int had_create_jack(struct snd_intelhad *ctx,
+ 			   struct snd_pcm *pcm)
+ {
+ 	char hdmi_str[32];
+ 	int err;
+ 
+ 	snprintf(hdmi_str, sizeof(hdmi_str),
+ 		 "HDMI/DP,pcm=%d", pcm->device);
+ 
+ 	err = snd_jack_new(ctx->card_ctx->card, hdmi_str,
+ 			   SND_JACK_AVOUT, &ctx->jack,
+ 			   true, false);
+ 	if (err < 0)
+ 		return err;
+ 	ctx->jack->private_data = ctx;
+ 	return 0;
+ }
+ 
+ /*
+  * PM callbacks
+  */
+ 
+ static int hdmi_lpe_audio_runtime_suspend(struct device *dev)
+ {
+ 	struct snd_intelhad_card *card_ctx = dev_get_drvdata(dev);
+ 	int port;
+ 
+ 	for_each_port(card_ctx, port) {
+ 		struct snd_intelhad *ctx = &card_ctx->pcm_ctx[port];
+ 		struct snd_pcm_substream *substream;
+ 
+ 		substream = had_substream_get(ctx);
+ 		if (substream) {
+ 			snd_pcm_suspend(substream);
+ 			had_substream_put(ctx);
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int __maybe_unused hdmi_lpe_audio_suspend(struct device *dev)
+ {
+ 	struct snd_intelhad_card *card_ctx = dev_get_drvdata(dev);
+ 	int err;
+ 
+ 	err = hdmi_lpe_audio_runtime_suspend(dev);
+ 	if (!err)
+ 		snd_power_change_state(card_ctx->card, SNDRV_CTL_POWER_D3hot);
+ 	return err;
+ }
+ 
+ static int hdmi_lpe_audio_runtime_resume(struct device *dev)
+ {
+ 	pm_runtime_mark_last_busy(dev);
+ 	return 0;
+ }
+ 
+ static int __maybe_unused hdmi_lpe_audio_resume(struct device *dev)
+ {
+ 	struct snd_intelhad_card *card_ctx = dev_get_drvdata(dev);
+ 
+ 	hdmi_lpe_audio_runtime_resume(dev);
+ 	snd_power_change_state(card_ctx->card, SNDRV_CTL_POWER_D0);
+ 	return 0;
+ }
+ 
+ /* release resources */
+ static void hdmi_lpe_audio_free(struct snd_card *card)
+ {
+ 	struct snd_intelhad_card *card_ctx = card->private_data;
+ 	struct intel_hdmi_lpe_audio_pdata *pdata = card_ctx->dev->platform_data;
+ 	int port;
+ 
+ 	spin_lock_irq(&pdata->lpe_audio_slock);
+ 	pdata->notify_audio_lpe = NULL;
+ 	spin_unlock_irq(&pdata->lpe_audio_slock);
+ 
+ 	for_each_port(card_ctx, port) {
+ 		struct snd_intelhad *ctx = &card_ctx->pcm_ctx[port];
+ 
+ 		cancel_work_sync(&ctx->hdmi_audio_wq);
+ 	}
+ 
+ 	if (card_ctx->mmio_start)
+ 		iounmap(card_ctx->mmio_start);
+ 	if (card_ctx->irq >= 0)
+ 		free_irq(card_ctx->irq, card_ctx);
+ }
+ 
+ /*
+  * hdmi_lpe_audio_probe - start bridge with i915
++>>>>>>> b4eb0d522fcb (ALSA: x86: Split snd_intelhad into card and PCM specific structures)
   *
 - * This function is called when the i915 driver creates the
 - * hdmi-lpe-audio platform device.
 + * @devptr: platform device
 + * @had_ret: pointer to store the created snd_intelhad object
 + *
 + * This function is called when the platform device is probed. This function
 + * creates and registers the sound card with ALSA
   */
 -static int hdmi_lpe_audio_probe(struct platform_device *pdev)
 +int hdmi_audio_probe(struct platform_device *devptr,
 +		     struct snd_intelhad **had_ret)
  {
++<<<<<<< HEAD
 +	int retval;
 +	struct snd_pcm *pcm;
 +	struct snd_card *card;
 +	struct snd_intelhad *intelhaddata;
 +	struct had_pvt_data *had_stream;
++=======
+ 	struct snd_card *card;
+ 	struct snd_intelhad_card *card_ctx;
+ 	struct snd_pcm *pcm;
+ 	struct intel_hdmi_lpe_audio_pdata *pdata;
+ 	int irq;
+ 	struct resource *res_mmio;
+ 	int port, ret;
++>>>>>>> b4eb0d522fcb (ALSA: x86: Split snd_intelhad into card and PCM specific structures)
  
 -	pdata = pdev->dev.platform_data;
 -	if (!pdata) {
 -		dev_err(&pdev->dev, "%s: quit: pdata not allocated by i915!!\n", __func__);
 -		return -EINVAL;
 -	}
 +	pr_debug("Enter %s\n", __func__);
  
 -	/* get resources */
 -	irq = platform_get_irq(pdev, 0);
 -	if (irq < 0) {
 -		dev_err(&pdev->dev, "Could not get irq resource\n");
 -		return -ENODEV;
 -	}
 +	pr_debug("hdmi_audio_probe dma_mask: %p\n", devptr->dev.dma_mask);
  
 -	res_mmio = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 -	if (!res_mmio) {
 -		dev_err(&pdev->dev, "Could not get IO_MEM resources\n");
 -		return -ENXIO;
 +	/* allocate memory for saving internal context and working */
 +	intelhaddata = kzalloc(sizeof(*intelhaddata), GFP_KERNEL);
 +	if (!intelhaddata)
 +		return -ENOMEM;
 +
 +	had_stream = kzalloc(sizeof(*had_stream), GFP_KERNEL);
 +	if (!had_stream) {
 +		retval = -ENOMEM;
 +		goto free_haddata;
  	}
  
 +	spin_lock_init(&intelhaddata->had_spinlock);
 +	intelhaddata->drv_status = HAD_DRV_DISCONNECTED;
 +	pr_debug("%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_DISCONNECTED\n",
 +			__func__, __LINE__);
 +
  	/* create a card instance with ALSA framework */
++<<<<<<< HEAD
 +	retval = snd_card_new(&devptr->dev, hdmi_card_index, hdmi_card_id,
 +				THIS_MODULE, 0, &card);
 +
 +	if (retval)
 +		goto free_hadstream;
 +	intelhaddata->card = card;
 +	intelhaddata->card_id = hdmi_card_id;
 +	intelhaddata->card_index = card->number;
 +	intelhaddata->private_data = had_stream;
 +	intelhaddata->flag_underrun = 0;
 +	intelhaddata->aes_bits = SNDRV_PCM_DEFAULT_CON_SPDIF;
 +	strncpy(card->driver, INTEL_HAD, strlen(INTEL_HAD));
 +	strncpy(card->shortname, INTEL_HAD, strlen(INTEL_HAD));
 +
 +	retval = snd_pcm_new(card, INTEL_HAD, PCM_INDEX, MAX_PB_STREAMS,
 +						MAX_CAP_STREAMS, &pcm);
 +	if (retval)
 +		goto err;
 +
 +	/* setup private data which can be retrieved when required */
 +	pcm->private_data = intelhaddata;
 +	pcm->private_free = snd_intelhad_pcm_free;
 +	pcm->info_flags = 0;
 +	strncpy(pcm->name, card->shortname, strlen(card->shortname));
 +	/* setup the ops for palyabck */
 +	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
 +			    &snd_intelhad_playback_ops);
 +	/* allocate dma pages for ALSA stream operations
 +	 * memory allocated is based on size, not max value
 +	 * thus using same argument for max & size
 +	 */
 +	retval = snd_pcm_lib_preallocate_pages_for_all(pcm,
 +			SNDRV_DMA_TYPE_DEV, NULL,
 +			HAD_MAX_BUFFER, HAD_MAX_BUFFER);
 +
 +	if (card->dev == NULL)
 +		pr_debug("card->dev is NULL!!!!! Should not be this case\n");
 +	else if (card->dev->dma_mask == NULL)
 +		pr_debug("hdmi_audio_probe dma_mask is NULL!!!!!\n");
 +	else
 +		pr_debug("hdmi_audio_probe dma_mask is : %p\n",
 +				card->dev->dma_mask);
 +
 +	if (retval)
 +		goto err;
 +
 +	/* internal function call to register device with ALSA */
 +	retval = snd_intelhad_create(intelhaddata, card);
 +	if (retval)
 +		goto err;
 +
 +	card->private_data = &intelhaddata;
 +	retval = snd_card_register(card);
 +	if (retval)
 +		goto err;
 +
 +	/* IEC958 controls */
 +	retval = snd_ctl_add(card, snd_ctl_new1(&had_control_iec958_mask,
 +						intelhaddata));
 +	if (retval < 0)
 +		goto err;
 +	retval = snd_ctl_add(card, snd_ctl_new1(&had_control_iec958,
 +						intelhaddata));
 +	if (retval < 0)
 +		goto err;
 +
 +	init_channel_allocations();
 +
 +	/* Register channel map controls */
 +	retval = had_register_chmap_ctls(intelhaddata, pcm);
 +	if (retval < 0)
 +		goto err;
 +
 +	intelhaddata->dev = &devptr->dev;
 +	pm_runtime_set_active(intelhaddata->dev);
 +	pm_runtime_enable(intelhaddata->dev);
 +
 +	*had_ret = intelhaddata;
++=======
+ 	ret = snd_card_new(&pdev->dev, hdmi_card_index, hdmi_card_id,
+ 			   THIS_MODULE, sizeof(*card_ctx), &card);
+ 	if (ret)
+ 		return ret;
+ 
+ 	card_ctx = card->private_data;
+ 	card_ctx->dev = &pdev->dev;
+ 	card_ctx->card = card;
+ 	strcpy(card->driver, INTEL_HAD);
+ 	strcpy(card->shortname, "Intel HDMI/DP LPE Audio");
+ 	strcpy(card->longname, "Intel HDMI/DP LPE Audio");
+ 
+ 	card_ctx->irq = -1;
+ 
+ 	card->private_free = hdmi_lpe_audio_free;
+ 
+ 	platform_set_drvdata(pdev, card_ctx);
+ 
+ 	dev_dbg(&pdev->dev, "%s: mmio_start = 0x%x, mmio_end = 0x%x\n",
+ 		__func__, (unsigned int)res_mmio->start,
+ 		(unsigned int)res_mmio->end);
+ 
+ 	card_ctx->mmio_start = ioremap_nocache(res_mmio->start,
+ 					       (size_t)(resource_size(res_mmio)));
+ 	if (!card_ctx->mmio_start) {
+ 		dev_err(&pdev->dev, "Could not get ioremap\n");
+ 		ret = -EACCES;
+ 		goto err;
+ 	}
+ 
+ 	/* setup interrupt handler */
+ 	ret = request_irq(irq, display_pipe_interrupt_handler, 0,
+ 			  pdev->name, card_ctx);
+ 	if (ret < 0) {
+ 		dev_err(&pdev->dev, "request_irq failed\n");
+ 		goto err;
+ 	}
+ 
+ 	card_ctx->irq = irq;
+ 
+ 	/* only 32bit addressable */
+ 	dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));
+ 	dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
+ 
+ 	init_channel_allocations();
+ 
+ 	card_ctx->num_ports = 1;
+ 
+ 	for_each_port(card_ctx, port) {
+ 		struct snd_intelhad *ctx = &card_ctx->pcm_ctx[port];
+ 		int i;
+ 
+ 		ctx->card_ctx = card_ctx;
+ 		ctx->dev = card_ctx->dev;
+ 
+ 		INIT_WORK(&ctx->hdmi_audio_wq, had_audio_wq);
+ 
+ 		ctx->had_config_offset = AUDIO_HDMI_CONFIG_A;
+ 
+ 		ret = snd_pcm_new(card, INTEL_HAD, PCM_INDEX, MAX_PB_STREAMS,
+ 				  MAX_CAP_STREAMS, &pcm);
+ 		if (ret)
+ 			goto err;
+ 
+ 		/* setup private data which can be retrieved when required */
+ 		pcm->private_data = ctx;
+ 		pcm->info_flags = 0;
+ 		strncpy(pcm->name, card->shortname, strlen(card->shortname));
+ 		/* setup the ops for playabck */
+ 		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &had_pcm_ops);
+ 
+ 		/* allocate dma pages;
+ 		 * try to allocate 600k buffer as default which is large enough
+ 		 */
+ 		snd_pcm_lib_preallocate_pages_for_all(pcm,
+ 						      SNDRV_DMA_TYPE_DEV, NULL,
+ 						      HAD_DEFAULT_BUFFER, HAD_MAX_BUFFER);
+ 
+ 		/* create controls */
+ 		for (i = 0; i < ARRAY_SIZE(had_controls); i++) {
+ 			struct snd_kcontrol *kctl;
+ 
+ 			kctl = snd_ctl_new1(&had_controls[i], ctx);
+ 			if (!kctl) {
+ 				ret = -ENOMEM;
+ 				goto err;
+ 			}
+ 
+ 			kctl->id.device = pcm->device;
+ 
+ 			ret = snd_ctl_add(card, kctl);
+ 			if (ret < 0)
+ 				goto err;
+ 		}
+ 
+ 		/* Register channel map controls */
+ 		ret = had_register_chmap_ctls(ctx, pcm);
+ 		if (ret < 0)
+ 			goto err;
+ 
+ 		ret = had_create_jack(ctx, pcm);
+ 		if (ret < 0)
+ 			goto err;
+ 	}
+ 
+ 	ret = snd_card_register(card);
+ 	if (ret)
+ 		goto err;
+ 
+ 	spin_lock_irq(&pdata->lpe_audio_slock);
+ 	pdata->notify_audio_lpe = notify_audio_lpe;
+ 	spin_unlock_irq(&pdata->lpe_audio_slock);
+ 
+ 	pm_runtime_use_autosuspend(&pdev->dev);
+ 	pm_runtime_mark_last_busy(&pdev->dev);
+ 	pm_runtime_set_active(&pdev->dev);
+ 
+ 	dev_dbg(&pdev->dev, "%s: handle pending notification\n", __func__);
+ 	for_each_port(card_ctx, port) {
+ 		struct snd_intelhad *ctx = &card_ctx->pcm_ctx[port];
+ 
+ 		schedule_work(&ctx->hdmi_audio_wq);
+ 	}
++>>>>>>> b4eb0d522fcb (ALSA: x86: Split snd_intelhad into card and PCM specific structures)
  
  	return 0;
 -
  err:
  	snd_card_free(card);
 -	return ret;
 +free_hadstream:
 +	kfree(had_stream);
 +	pm_runtime_disable(intelhaddata->dev);
 +	intelhaddata->dev = NULL;
 +free_haddata:
 +	kfree(intelhaddata);
 +	intelhaddata = NULL;
 +	pr_err("Error returned from %s api %#x\n", __func__, retval);
 +	return retval;
  }
  
  /*
 - * hdmi_lpe_audio_remove - stop bridge with i915
 + * hdmi_audio_remove - removes the alsa card
 + *
 + *@haddata: pointer to HAD private data
   *
 - * This function is called when the platform device is destroyed.
 + * This function is called when the hdmi cable is un-plugged. This function
 + * free the sound card.
   */
 -static int hdmi_lpe_audio_remove(struct platform_device *pdev)
 +int hdmi_audio_remove(struct snd_intelhad *intelhaddata)
  {
++<<<<<<< HEAD
 +	int caps;
 +
 +	pr_debug("Enter %s\n", __func__);
 +
 +	if (!intelhaddata)
 +		return 0;
 +
 +	if (intelhaddata->drv_status != HAD_DRV_DISCONNECTED) {
 +		caps = HDMI_AUDIO_UNDERRUN | HDMI_AUDIO_BUFFER_DONE;
 +		had_set_caps(intelhaddata, HAD_SET_DISABLE_AUDIO_INT, &caps);
 +		had_set_caps(intelhaddata, HAD_SET_DISABLE_AUDIO, NULL);
 +	}
 +	snd_card_free(intelhaddata->card);
 +	kfree(intelhaddata->private_data);
 +	kfree(intelhaddata);
++=======
+ 	struct snd_intelhad_card *card_ctx = platform_get_drvdata(pdev);
+ 
+ 	snd_card_free(card_ctx->card);
++>>>>>>> b4eb0d522fcb (ALSA: x86: Split snd_intelhad into card and PCM specific structures)
  	return 0;
  }
  
diff --cc sound/x86/intel_hdmi_audio.h
index 32a2fb766e47,2725964ebc46..000000000000
--- a/sound/x86/intel_hdmi_audio.h
+++ b/sound/x86/intel_hdmi_audio.h
@@@ -115,70 -98,48 +115,109 @@@ struct had_pvt_data 
   * @aes_bits: IEC958 status bits
   * @buff_done: id of current buffer done intr
   * @dev: platoform device handle
 + * @kctl: holds kctl ptrs used for channel map
   * @chmap: holds channel map info
 + * @audio_reg_base: hdmi audio register base offset
 + * @underrun_count: PCM stream underrun counter
   */
  struct snd_intelhad {
++<<<<<<< HEAD
 +	struct snd_card	*card;
 +	int		card_index;
 +	char		*card_id;
 +	enum had_drv_status	drv_status;
 +	struct		ring_buf_info buf_info[HAD_NUM_OF_RING_BUFS];
++=======
+ 	struct snd_intelhad_card *card_ctx;
+ 	bool		connected;
++>>>>>>> b4eb0d522fcb (ALSA: x86: Split snd_intelhad into card and PCM specific structures)
  	struct		pcm_stream_info stream_info;
 -	unsigned char	eld[HDMI_MAX_ELD_BYTES];
 +	union otm_hdmi_eld_t	eeld;
  	bool dp_output;
 +	enum		intel_had_aud_buf_type curr_buf;
 +	int		valid_buf_cnt;
  	unsigned int	aes_bits;
 +	int flag_underrun;
 +	struct had_pvt_data *private_data;
  	spinlock_t had_spinlock;
 +	enum		intel_had_aud_buf_type buff_done;
  	struct device *dev;
 +	struct snd_kcontrol *kctl;
  	struct snd_pcm_chmap *chmap;
++<<<<<<< HEAD
 +	unsigned int	*audio_reg_base;
 +	unsigned int	audio_cfg_offset;
 +	int underrun_count;
 +};
 +
 +int had_event_handler(enum had_event_type event_type, void *data);
 +
 +int hdmi_audio_query(void *drv_data, struct hdmi_audio_event event);
 +int hdmi_audio_suspend(void *drv_data);
 +int hdmi_audio_resume(void *drv_data);
 +int hdmi_audio_mode_change(struct snd_pcm_substream *substream);
 +extern struct snd_pcm_ops snd_intelhad_playback_ops;
 +
 +int snd_intelhad_init_audio_ctrl(struct snd_pcm_substream *substream,
 +					struct snd_intelhad *intelhaddata,
 +					int flag_silence);
 +int snd_intelhad_prog_buffer(struct snd_intelhad *intelhaddata,
 +					int start, int end);
 +int snd_intelhad_invd_buffer(int start, int end);
 +int snd_intelhad_read_len(struct snd_intelhad *intelhaddata);
 +void had_build_channel_allocation_map(struct snd_intelhad *intelhaddata);
 +
 +void snd_intelhad_enable_audio(struct snd_pcm_substream *substream, u8 enable);
 +void snd_intelhad_handle_underrun(struct snd_intelhad *intelhaddata);
 +
 +/* Register access functions */
 +int had_get_hwstate(struct snd_intelhad *intelhaddata);
 +int had_get_caps(struct snd_intelhad *intelhaddata,
 +		 enum had_caps_list query_element, void *capabilties);
 +int had_set_caps(struct snd_intelhad *intelhaddata,
 +		 enum had_caps_list set_element, void *capabilties);
 +int had_read_register(struct snd_intelhad *intelhaddata,
 +		      u32 reg_addr, u32 *data);
 +int had_write_register(struct snd_intelhad *intelhaddata,
 +		       u32 reg_addr, u32 data);
 +int had_read_modify(struct snd_intelhad *intelhaddata,
 +		    u32 reg_addr, u32 data, u32 mask);
 +
 +int hdmi_audio_probe(struct platform_device *devptr,
 +		     struct snd_intelhad **had_ret);
 +int hdmi_audio_remove(struct snd_intelhad *intelhaddata);
++=======
+ 	int tmds_clock_speed;
+ 	int link_rate;
+ 
+ 	/* ring buffer (BD) position index */
+ 	unsigned int bd_head;
+ 	/* PCM buffer position indices */
+ 	unsigned int pcmbuf_head;	/* being processed */
+ 	unsigned int pcmbuf_filled;	/* to be filled */
+ 
+ 	unsigned int num_bds;		/* number of BDs */
+ 	unsigned int period_bytes;	/* PCM period size in bytes */
+ 
+ 	/* internal stuff */
+ 	unsigned int had_config_offset;
+ 	union aud_cfg aud_config;	/* AUD_CONFIG reg value cache */
+ 	struct work_struct hdmi_audio_wq;
+ 	struct mutex mutex; /* for protecting chmap and eld */
+ 	bool need_reset;
+ 	struct snd_jack *jack;
+ };
+ 
+ struct snd_intelhad_card {
+ 	struct snd_card	*card;
+ 	struct device *dev;
+ 
+ 	/* internal stuff */
+ 	int irq;
+ 	void __iomem *mmio_start;
+ 	int num_ports;
+ 	struct snd_intelhad pcm_ctx[3];
+ };
++>>>>>>> b4eb0d522fcb (ALSA: x86: Split snd_intelhad into card and PCM specific structures)
  
  #endif /* _INTEL_HDMI_AUDIO_ */
* Unmerged path sound/x86/intel_hdmi_audio.c
* Unmerged path sound/x86/intel_hdmi_audio.h
