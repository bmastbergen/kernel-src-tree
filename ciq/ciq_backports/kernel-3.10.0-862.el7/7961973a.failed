net: sched: move TC_H_MAJ macro call into tcf_auto_prio

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] sched: move TC_H_MAJ macro call into tcf_auto_prio (Ivan Vecera) [1445420]
Rebuild_FUZZ: 95.24%
commit-author Jiri Pirko <jiri@mellanox.com>
commit 7961973a0087824fdc9d0303b0033ab79b557278
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/7961973a.failed

Call the helper from the function rather than to always adjust the
return value of the function.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7961973a0087824fdc9d0303b0033ab79b557278)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/cls_api.c
diff --cc net/sched/cls_api.c
index 1dc6d123ed94,690457c988b2..000000000000
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@@ -124,12 -125,152 +124,12 @@@ static inline u32 tcf_auto_prio(struct 
  	if (tp)
  		first = tp->prio - 1;
  
- 	return first;
+ 	return TC_H_MAJ(first);
  }
  
 -static struct tcf_proto *tcf_proto_create(const char *kind, u32 protocol,
 -					  u32 prio, u32 parent, struct Qdisc *q,
 -					  struct tcf_block *block)
 -{
 -	struct tcf_proto *tp;
 -	int err;
 -
 -	tp = kzalloc(sizeof(*tp), GFP_KERNEL);
 -	if (!tp)
 -		return ERR_PTR(-ENOBUFS);
 -
 -	err = -ENOENT;
 -	tp->ops = tcf_proto_lookup_ops(kind);
 -	if (!tp->ops) {
 -#ifdef CONFIG_MODULES
 -		rtnl_unlock();
 -		request_module("cls_%s", kind);
 -		rtnl_lock();
 -		tp->ops = tcf_proto_lookup_ops(kind);
 -		/* We dropped the RTNL semaphore in order to perform
 -		 * the module load. So, even if we succeeded in loading
 -		 * the module we have to replay the request. We indicate
 -		 * this using -EAGAIN.
 -		 */
 -		if (tp->ops) {
 -			module_put(tp->ops->owner);
 -			err = -EAGAIN;
 -		} else {
 -			err = -ENOENT;
 -		}
 -		goto errout;
 -#endif
 -	}
 -	tp->classify = tp->ops->classify;
 -	tp->protocol = protocol;
 -	tp->prio = prio;
 -	tp->classid = parent;
 -	tp->q = q;
 -	tp->block = block;
 -
 -	err = tp->ops->init(tp);
 -	if (err) {
 -		module_put(tp->ops->owner);
 -		goto errout;
 -	}
 -	return tp;
 -
 -errout:
 -	kfree(tp);
 -	return ERR_PTR(err);
 -}
 -
 -static void tcf_proto_destroy(struct tcf_proto *tp)
 -{
 -	tp->ops->destroy(tp);
 -	module_put(tp->ops->owner);
 -	kfree_rcu(tp, rcu);
 -}
 -
 -static void tcf_chain_destroy(struct tcf_proto __rcu **fl)
 -{
 -	struct tcf_proto *tp;
 -
 -	while ((tp = rtnl_dereference(*fl)) != NULL) {
 -		RCU_INIT_POINTER(*fl, tp->next);
 -		tcf_proto_destroy(tp);
 -	}
 -}
 -
 -int tcf_block_get(struct tcf_block **p_block,
 -		  struct tcf_proto __rcu **p_filter_chain)
 -{
 -	struct tcf_block *block = kzalloc(sizeof(*block), GFP_KERNEL);
 -
 -	if (!block)
 -		return -ENOMEM;
 -	block->p_filter_chain = p_filter_chain;
 -	*p_block = block;
 -	return 0;
 -}
 -EXPORT_SYMBOL(tcf_block_get);
 -
 -void tcf_block_put(struct tcf_block *block)
 -{
 -	if (!block)
 -		return;
 -	tcf_chain_destroy(block->p_filter_chain);
 -	kfree(block);
 -}
 -EXPORT_SYMBOL(tcf_block_put);
 -
 -/* Main classifier routine: scans classifier chain attached
 - * to this qdisc, (optionally) tests for protocol and asks
 - * specific classifiers.
 - */
 -int tcf_classify(struct sk_buff *skb, const struct tcf_proto *tp,
 -		 struct tcf_result *res, bool compat_mode)
 -{
 -	__be16 protocol = tc_skb_protocol(skb);
 -#ifdef CONFIG_NET_CLS_ACT
 -	const int max_reclassify_loop = 4;
 -	const struct tcf_proto *old_tp = tp;
 -	int limit = 0;
 -
 -reclassify:
 -#endif
 -	for (; tp; tp = rcu_dereference_bh(tp->next)) {
 -		int err;
 -
 -		if (tp->protocol != protocol &&
 -		    tp->protocol != htons(ETH_P_ALL))
 -			continue;
 -
 -		err = tp->classify(skb, tp, res);
 -#ifdef CONFIG_NET_CLS_ACT
 -		if (unlikely(err == TC_ACT_RECLASSIFY && !compat_mode))
 -			goto reset;
 -#endif
 -		if (err >= 0)
 -			return err;
 -	}
 -
 -	return TC_ACT_UNSPEC; /* signal: continue lookup */
 -#ifdef CONFIG_NET_CLS_ACT
 -reset:
 -	if (unlikely(limit++ >= max_reclassify_loop)) {
 -		net_notice_ratelimited("%s: reclassify loop, rule prio %u, protocol %02x\n",
 -				       tp->q->ops->id, tp->prio & 0xffff,
 -				       ntohs(tp->protocol));
 -		return TC_ACT_SHOT;
 -	}
 -
 -	tp = old_tp;
 -	protocol = tc_skb_protocol(skb);
 -	goto reclassify;
 -#endif
 -}
 -EXPORT_SYMBOL(tcf_classify);
 -
  /* Add/change/delete/get a filter node */
  
 -static int tc_ctl_tfilter(struct sk_buff *skb, struct nlmsghdr *n,
 -			  struct netlink_ext_ack *extack)
 +static int tc_ctl_tfilter(struct sk_buff *skb, struct nlmsghdr *n)
  {
  	struct net *net = sock_net(skb->sk);
  	struct nlattr *tca[TCA_MAX + 1];
@@@ -308,10 -410,20 +308,22 @@@ replay
  			goto errout;
  		}
  
++<<<<<<< HEAD
++=======
+ 		if (prio_allocate)
+ 			prio = tcf_auto_prio(rtnl_dereference(*back));
+ 
+ 		tp = tcf_proto_create(nla_data(tca[TCA_KIND]),
+ 				      protocol, prio, parent, q, block);
+ 		if (IS_ERR(tp)) {
+ 			err = PTR_ERR(tp);
+ 			goto errout;
+ 		}
++>>>>>>> 7961973a0087 (net: sched: move TC_H_MAJ macro call into tcf_auto_prio)
  		tp_created = 1;
 -	} else if (tca[TCA_KIND] && nla_strcmp(tca[TCA_KIND], tp->ops->kind)) {
 -		err = -EINVAL;
 +
 +	} else if (tca[TCA_KIND] && nla_strcmp(tca[TCA_KIND], tp->ops->kind))
  		goto errout;
 -	}
  
  	fh = tp->ops->get(tp, t->tcm_handle);
  
* Unmerged path net/sched/cls_api.c
