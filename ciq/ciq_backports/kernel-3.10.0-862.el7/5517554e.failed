cifs: Add support for writing attributes on SMB2+

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ronnie Sahlberg <lsahlber@redhat.com>
commit 5517554e43131f542e5f95c94c5cd9a1bb989fab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5517554e.failed

This adds support for writing extended attributes on SMB2+ shares.
Attributes can be written using the setfattr command.

RH-bz: 1110709

	Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
	Signed-off-by: Steve French <smfrench@gmail.com>
	Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
(cherry picked from commit 5517554e43131f542e5f95c94c5cd9a1bb989fab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/smb2ops.c
#	fs/cifs/xattr.c
diff --cc fs/cifs/smb2ops.c
index f4acb0a6593b,fb2934b9b97c..000000000000
--- a/fs/cifs/smb2ops.c
+++ b/fs/cifs/smb2ops.c
@@@ -423,6 -426,194 +423,197 @@@ smb2_query_file_info(const unsigned in
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ static ssize_t
+ move_smb2_ea_to_cifs(char *dst, size_t dst_size,
+ 		     struct smb2_file_full_ea_info *src, size_t src_size,
+ 		     const unsigned char *ea_name)
+ {
+ 	int rc = 0;
+ 	unsigned int ea_name_len = ea_name ? strlen(ea_name) : 0;
+ 	char *name, *value;
+ 	size_t name_len, value_len, user_name_len;
+ 
+ 	while (src_size > 0) {
+ 		name = &src->ea_data[0];
+ 		name_len = (size_t)src->ea_name_length;
+ 		value = &src->ea_data[src->ea_name_length + 1];
+ 		value_len = (size_t)le16_to_cpu(src->ea_value_length);
+ 
+ 		if (name_len == 0) {
+ 			break;
+ 		}
+ 
+ 		if (src_size < 8 + name_len + 1 + value_len) {
+ 			cifs_dbg(FYI, "EA entry goes beyond length of list\n");
+ 			rc = -EIO;
+ 			goto out;
+ 		}
+ 
+ 		if (ea_name) {
+ 			if (ea_name_len == name_len &&
+ 			    memcmp(ea_name, name, name_len) == 0) {
+ 				rc = value_len;
+ 				if (dst_size == 0)
+ 					goto out;
+ 				if (dst_size < value_len) {
+ 					rc = -ERANGE;
+ 					goto out;
+ 				}
+ 				memcpy(dst, value, value_len);
+ 				goto out;
+ 			}
+ 		} else {
+ 			/* 'user.' plus a terminating null */
+ 			user_name_len = 5 + 1 + name_len;
+ 
+ 			rc += user_name_len;
+ 
+ 			if (dst_size >= user_name_len) {
+ 				dst_size -= user_name_len;
+ 				memcpy(dst, "user.", 5);
+ 				dst += 5;
+ 				memcpy(dst, src->ea_data, name_len);
+ 				dst += name_len;
+ 				*dst = 0;
+ 				++dst;
+ 			} else if (dst_size == 0) {
+ 				/* skip copy - calc size only */
+ 			} else {
+ 				/* stop before overrun buffer */
+ 				rc = -ERANGE;
+ 				break;
+ 			}
+ 		}
+ 
+ 		if (!src->next_entry_offset)
+ 			break;
+ 
+ 		if (src_size < le32_to_cpu(src->next_entry_offset)) {
+ 			/* stop before overrun buffer */
+ 			rc = -ERANGE;
+ 			break;
+ 		}
+ 		src_size -= le32_to_cpu(src->next_entry_offset);
+ 		src = (void *)((char *)src +
+ 			       le32_to_cpu(src->next_entry_offset));
+ 	}
+ 
+ 	/* didn't find the named attribute */
+ 	if (ea_name)
+ 		rc = -ENODATA;
+ 
+ out:
+ 	return (ssize_t)rc;
+ }
+ 
+ static ssize_t
+ smb2_query_eas(const unsigned int xid, struct cifs_tcon *tcon,
+ 	       const unsigned char *path, const unsigned char *ea_name,
+ 	       char *ea_data, size_t buf_size,
+ 	       struct cifs_sb_info *cifs_sb)
+ {
+ 	int rc;
+ 	__le16 *utf16_path;
+ 	__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;
+ 	struct cifs_open_parms oparms;
+ 	struct cifs_fid fid;
+ 	struct smb2_file_full_ea_info *smb2_data;
+ 
+ 	utf16_path = cifs_convert_path_to_utf16(path, cifs_sb);
+ 	if (!utf16_path)
+ 		return -ENOMEM;
+ 
+ 	oparms.tcon = tcon;
+ 	oparms.desired_access = FILE_READ_EA;
+ 	oparms.disposition = FILE_OPEN;
+ 	oparms.create_options = 0;
+ 	oparms.fid = &fid;
+ 	oparms.reconnect = false;
+ 
+ 	rc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);
+ 	kfree(utf16_path);
+ 	if (rc) {
+ 		cifs_dbg(FYI, "open failed rc=%d\n", rc);
+ 		return rc;
+ 	}
+ 
+ 	smb2_data = kzalloc(SMB2_MAX_EA_BUF, GFP_KERNEL);
+ 	if (smb2_data == NULL) {
+ 		SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	rc = SMB2_query_eas(xid, tcon, fid.persistent_fid, fid.volatile_fid,
+ 			    smb2_data);
+ 	SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);
+ 
+ 	if (!rc)
+ 		rc = move_smb2_ea_to_cifs(ea_data, buf_size, smb2_data,
+ 					  SMB2_MAX_EA_BUF, ea_name);
+ 
+ 	kfree(smb2_data);
+ 	return rc;
+ }
+ 
+ 
+ static int
+ smb2_set_ea(const unsigned int xid, struct cifs_tcon *tcon,
+ 	    const char *path, const char *ea_name, const void *ea_value,
+ 	    const __u16 ea_value_len, const struct nls_table *nls_codepage,
+ 	    struct cifs_sb_info *cifs_sb)
+ {
+ 	int rc;
+ 	__le16 *utf16_path;
+ 	__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;
+ 	struct cifs_open_parms oparms;
+ 	struct cifs_fid fid;
+ 	struct smb2_file_full_ea_info *ea;
+ 	int ea_name_len = strlen(ea_name);
+ 	int len;
+ 
+ 	if (ea_name_len > 255)
+ 		return -EINVAL;
+ 
+ 	utf16_path = cifs_convert_path_to_utf16(path, cifs_sb);
+ 	if (!utf16_path)
+ 		return -ENOMEM;
+ 
+ 	oparms.tcon = tcon;
+ 	oparms.desired_access = FILE_WRITE_EA;
+ 	oparms.disposition = FILE_OPEN;
+ 	oparms.create_options = 0;
+ 	oparms.fid = &fid;
+ 	oparms.reconnect = false;
+ 
+ 	rc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);
+ 	kfree(utf16_path);
+ 	if (rc) {
+ 		cifs_dbg(FYI, "open failed rc=%d\n", rc);
+ 		return rc;
+ 	}
+ 
+ 	len = sizeof(ea) + ea_name_len + ea_value_len + 1;
+ 	ea = kzalloc(len, GFP_KERNEL);
+ 	if (ea == NULL) {
+ 		SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	ea->ea_name_length = ea_name_len;
+ 	ea->ea_value_length = cpu_to_le16(ea_value_len);
+ 	memcpy(ea->ea_data, ea_name, ea_name_len + 1);
+ 	memcpy(ea->ea_data + ea_name_len + 1, ea_value, ea_value_len);
+ 
+ 	rc = SMB2_set_ea(xid, tcon, fid.persistent_fid, fid.volatile_fid, ea,
+ 			 len);
+ 	SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);
+ 
+ 	return rc;
+ }
+ 
++>>>>>>> 5517554e4313 (cifs: Add support for writing attributes on SMB2+)
  static bool
  smb2_can_echo(struct TCP_Server_Info *server)
  {
@@@ -1631,9 -2755,20 +1822,23 @@@ struct smb_version_operations smb20_ope
  	.set_oplock_level = smb2_set_oplock_level,
  	.create_lease_buf = smb2_create_lease_buf,
  	.parse_lease_buf = smb2_parse_lease_buf,
 -	.copychunk_range = smb2_copychunk_range,
 +	.clone_range = smb2_clone_range,
  	.wp_retry_size = smb2_wp_retry_size,
  	.dir_needs_close = smb2_dir_needs_close,
++<<<<<<< HEAD
++=======
+ 	.get_dfs_refer = smb2_get_dfs_refer,
+ 	.select_sectype = smb2_select_sectype,
+ #ifdef CONFIG_CIFS_XATTR
+ 	.query_all_EAs = smb2_query_eas,
+ 	.set_EA = smb2_set_ea,
+ #endif /* CIFS_XATTR */
+ #ifdef CONFIG_CIFS_ACL
+ 	.get_acl = get_smb2_acl,
+ 	.get_acl_by_fid = get_smb2_acl_by_fid,
+ 	.set_acl = set_smb2_acl,
+ #endif /* CIFS_ACL */
++>>>>>>> 5517554e4313 (cifs: Add support for writing attributes on SMB2+)
  };
  
  struct smb_version_operations smb21_operations = {
@@@ -1715,6 -2852,17 +1920,20 @@@
  	.wp_retry_size = smb2_wp_retry_size,
  	.dir_needs_close = smb2_dir_needs_close,
  	.enum_snapshots = smb3_enum_snapshots,
++<<<<<<< HEAD
++=======
+ 	.get_dfs_refer = smb2_get_dfs_refer,
+ 	.select_sectype = smb2_select_sectype,
+ #ifdef CONFIG_CIFS_XATTR
+ 	.query_all_EAs = smb2_query_eas,
+ 	.set_EA = smb2_set_ea,
+ #endif /* CIFS_XATTR */
+ #ifdef CONFIG_CIFS_ACL
+ 	.get_acl = get_smb2_acl,
+ 	.get_acl_by_fid = get_smb2_acl_by_fid,
+ 	.set_acl = set_smb2_acl,
+ #endif /* CIFS_ACL */
++>>>>>>> 5517554e4313 (cifs: Add support for writing attributes on SMB2+)
  };
  
  struct smb_version_operations smb30_operations = {
@@@ -1802,6 -2952,21 +2021,24 @@@
  	.dir_needs_close = smb2_dir_needs_close,
  	.fallocate = smb3_fallocate,
  	.enum_snapshots = smb3_enum_snapshots,
++<<<<<<< HEAD
++=======
+ 	.init_transform_rq = smb3_init_transform_rq,
+ 	.free_transform_rq = smb3_free_transform_rq,
+ 	.is_transform_hdr = smb3_is_transform_hdr,
+ 	.receive_transform = smb3_receive_transform,
+ 	.get_dfs_refer = smb2_get_dfs_refer,
+ 	.select_sectype = smb2_select_sectype,
+ #ifdef CONFIG_CIFS_XATTR
+ 	.query_all_EAs = smb2_query_eas,
+ 	.set_EA = smb2_set_ea,
+ #endif /* CIFS_XATTR */
+ #ifdef CONFIG_CIFS_ACL
+ 	.get_acl = get_smb2_acl,
+ 	.get_acl_by_fid = get_smb2_acl_by_fid,
+ 	.set_acl = set_smb2_acl,
+ #endif /* CIFS_ACL */
++>>>>>>> 5517554e4313 (cifs: Add support for writing attributes on SMB2+)
  };
  
  #ifdef CONFIG_CIFS_SMB311
@@@ -1890,6 -3057,16 +2127,19 @@@ struct smb_version_operations smb311_op
  	.dir_needs_close = smb2_dir_needs_close,
  	.fallocate = smb3_fallocate,
  	.enum_snapshots = smb3_enum_snapshots,
++<<<<<<< HEAD
++=======
+ 	.init_transform_rq = smb3_init_transform_rq,
+ 	.free_transform_rq = smb3_free_transform_rq,
+ 	.is_transform_hdr = smb3_is_transform_hdr,
+ 	.receive_transform = smb3_receive_transform,
+ 	.get_dfs_refer = smb2_get_dfs_refer,
+ 	.select_sectype = smb2_select_sectype,
+ #ifdef CONFIG_CIFS_XATTR
+ 	.query_all_EAs = smb2_query_eas,
+ 	.set_EA = smb2_set_ea,
+ #endif /* CIFS_XATTR */
++>>>>>>> 5517554e4313 (cifs: Add support for writing attributes on SMB2+)
  };
  #endif /* CIFS_SMB311 */
  
diff --cc fs/cifs/xattr.c
index 2e99ffdf4d21,52f975d848a0..000000000000
--- a/fs/cifs/xattr.c
+++ b/fs/cifs/xattr.c
@@@ -125,40 -70,30 +125,46 @@@ int cifs_setxattr(struct dentry *dirent
  	/* if proc/fs/cifs/streamstoxattr is set then
  		search server for EAs or streams to
  		returns as xattrs */
 -	if (size > MAX_EA_VALUE_SIZE) {
 +	if (value_size > MAX_EA_VALUE_SIZE) {
  		cifs_dbg(FYI, "size of EA value too large\n");
  		rc = -EOPNOTSUPP;
 -		goto out;
 +		goto set_ea_exit;
  	}
  
 -	switch (handler->flags) {
 -	case XATTR_USER:
 +	if (ea_name == NULL) {
 +		cifs_dbg(FYI, "Null xattr names not supported\n");
 +	} else if (strncmp(ea_name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN)
 +		   == 0) {
  		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_XATTR)
 -			goto out;
 +			goto set_ea_exit;
 +		if (strcmp(ea_name, CIFS_XATTR_DOS_ATTRIB) == 0)
 +			cifs_dbg(FYI, "attempt to set cifs inode metadata\n");
  
 +		ea_name += XATTR_USER_PREFIX_LEN; /* skip past user. prefix */
  		if (pTcon->ses->server->ops->set_EA)
  			rc = pTcon->ses->server->ops->set_EA(xid, pTcon,
++<<<<<<< HEAD
 +				full_path, ea_name, ea_value, (__u16)value_size,
 +				cifs_sb->local_nls, cifs_remap(cifs_sb));
 +	} else if (strncmp(ea_name, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN)
 +		   == 0) {
 +		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_XATTR)
 +			goto set_ea_exit;
++=======
+ 				full_path, name, value, (__u16)size,
+ 				cifs_sb->local_nls, cifs_sb);
+ 		break;
++>>>>>>> 5517554e4313 (cifs: Add support for writing attributes on SMB2+)
  
 -	case XATTR_CIFS_ACL: {
 +		ea_name += XATTR_OS2_PREFIX_LEN; /* skip past os2. prefix */
 +		if (pTcon->ses->server->ops->set_EA)
 +			rc = pTcon->ses->server->ops->set_EA(xid, pTcon,
 +				full_path, ea_name, ea_value, (__u16)value_size,
 +				cifs_sb->local_nls, cifs_remap(cifs_sb));
 +	} else if (strcmp(ea_name, CIFS_XATTR_CIFS_ACL) == 0) {
  #ifdef CONFIG_CIFS_ACL
  		struct cifs_ntsd *pacl;
 -
 -		if (!value)
 -			goto out;
 -		pacl = kmalloc(size, GFP_KERNEL);
 +		pacl = kmalloc(value_size, GFP_KERNEL);
  		if (!pacl) {
  			rc = -ENOMEM;
  		} else {
diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index a6a7b3af79ed..a7c5bcab7925 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -418,7 +418,7 @@ struct smb_version_operations {
 			size_t, const struct nls_table *, int);
 	int (*set_EA)(const unsigned int, struct cifs_tcon *, const char *,
 			const char *, const void *, const __u16,
-			const struct nls_table *, int);
+			const struct nls_table *, struct cifs_sb_info *);
 	struct cifs_ntsd * (*get_acl)(struct cifs_sb_info *, struct inode *,
 			const char *, u32 *);
 	struct cifs_ntsd * (*get_acl_by_fid)(struct cifs_sb_info *,
diff --git a/fs/cifs/cifsproto.h b/fs/cifs/cifsproto.h
index 56e78412bf1f..a587dcd2d673 100644
--- a/fs/cifs/cifsproto.h
+++ b/fs/cifs/cifsproto.h
@@ -485,7 +485,8 @@ extern ssize_t CIFSSMBQAllEAs(const unsigned int xid, struct cifs_tcon *tcon,
 extern int CIFSSMBSetEA(const unsigned int xid, struct cifs_tcon *tcon,
 		const char *fileName, const char *ea_name,
 		const void *ea_value, const __u16 ea_value_len,
-		const struct nls_table *nls_codepage, int remap_special_chars);
+		const struct nls_table *nls_codepage,
+		struct cifs_sb_info *cifs_sb);
 extern int CIFSSMBGetCIFSACL(const unsigned int xid, struct cifs_tcon *tcon,
 			__u16 fid, struct cifs_ntsd **acl_inf, __u32 *buflen);
 extern int CIFSSMBSetCIFSACL(const unsigned int, struct cifs_tcon *, __u16,
diff --git a/fs/cifs/cifssmb.c b/fs/cifs/cifssmb.c
index 9752794d2e10..75a24288e787 100644
--- a/fs/cifs/cifssmb.c
+++ b/fs/cifs/cifssmb.c
@@ -6265,7 +6265,7 @@ int
 CIFSSMBSetEA(const unsigned int xid, struct cifs_tcon *tcon,
 	     const char *fileName, const char *ea_name, const void *ea_value,
 	     const __u16 ea_value_len, const struct nls_table *nls_codepage,
-	     int remap)
+	     struct cifs_sb_info *cifs_sb)
 {
 	struct smb_com_transaction2_spi_req *pSMB = NULL;
 	struct smb_com_transaction2_spi_rsp *pSMBr = NULL;
@@ -6274,6 +6274,7 @@ CIFSSMBSetEA(const unsigned int xid, struct cifs_tcon *tcon,
 	int rc = 0;
 	int bytes_returned = 0;
 	__u16 params, param_offset, byte_count, offset, count;
+	int remap = cifs_remap(cifs_sb);
 
 	cifs_dbg(FYI, "In SetEA\n");
 SetEARetry:
* Unmerged path fs/cifs/smb2ops.c
diff --git a/fs/cifs/smb2pdu.c b/fs/cifs/smb2pdu.c
index 75aad307324d..a99cbb30cf29 100644
--- a/fs/cifs/smb2pdu.c
+++ b/fs/cifs/smb2pdu.c
@@ -3170,6 +3170,16 @@ SMB2_set_acl(const unsigned int xid, struct cifs_tcon *tcon,
 			1, (void **)&pnntsd, &pacllen);
 }
 
+int
+SMB2_set_ea(const unsigned int xid, struct cifs_tcon *tcon,
+	    u64 persistent_fid, u64 volatile_fid,
+	    struct smb2_file_full_ea_info *buf, int len)
+{
+	return send_set_info(xid, tcon, persistent_fid, volatile_fid,
+		current->tgid, FILE_FULL_EA_INFORMATION, SMB2_O_INFO_FILE,
+		0, 1, (void **)&buf, &len);
+}
+
 int
 SMB2_oplock_break(const unsigned int xid, struct cifs_tcon *tcon,
 		  const u64 persistent_fid, const u64 volatile_fid,
diff --git a/fs/cifs/smb2proto.h b/fs/cifs/smb2proto.h
index 55229cb2ba8e..167b1dc69840 100644
--- a/fs/cifs/smb2proto.h
+++ b/fs/cifs/smb2proto.h
@@ -160,6 +160,9 @@ extern int SMB2_set_info(const unsigned int xid, struct cifs_tcon *tcon,
 extern int SMB2_set_acl(const unsigned int xid, struct cifs_tcon *tcon,
 			u64 persistent_fid, u64 volatile_fid,
 			struct cifs_ntsd *pnntsd, int pacllen, int aclflag);
+extern int SMB2_set_ea(const unsigned int xid, struct cifs_tcon *tcon,
+		       u64 persistent_fid, u64 volatile_fid,
+		       struct smb2_file_full_ea_info *buf, int len);
 extern int SMB2_set_compression(const unsigned int xid, struct cifs_tcon *tcon,
 				u64 persistent_fid, u64 volatile_fid);
 extern int SMB2_oplock_break(const unsigned int xid, struct cifs_tcon *tcon,
* Unmerged path fs/cifs/xattr.c
