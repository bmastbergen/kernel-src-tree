target: put struct target_fabric_configfs on a diet

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [target] put struct target_fabric_configfs on a diet (Maurizio Lombardi) [1366062]
Rebuild_FUZZ: 91.49%
commit-author Christoph Hellwig <hch@lst.de>
commit 0dc2e8d1435318dc448ac390d6d31e6cd2516684
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0dc2e8d1.failed

Remove all fields that are either unused or can be replaced by trivially
following pointers.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 0dc2e8d1435318dc448ac390d6d31e6cd2516684)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_configfs.c
#	drivers/target/target_core_fabric_configfs.c
#	include/target/target_core_configfs.h
diff --cc drivers/target/target_core_configfs.c
index 5a4ad5ca14f6,f63e4dda8a90..000000000000
--- a/drivers/target/target_core_configfs.c
+++ b/drivers/target/target_core_configfs.c
@@@ -212,14 -212,6 +212,17 @@@ static struct config_group *target_core
  
  	pr_debug("Target_Core_ConfigFS: REGISTER -> Allocated Fabric:"
  			" %s\n", tf->tf_group.cg_item.ci_name);
++<<<<<<< HEAD
 +	/*
 +	 * Setup tf_ops.tf_subsys pointer for usage with configfs_depend_item()
 +	 */
 +	tf->tf_ops.tf_subsys = tf->tf_subsys;
 +	tf->tf_fabric = &tf->tf_group.cg_item;
 +	pr_debug("Target_Core_ConfigFS: REGISTER -> Set tf->tf_fabric"
 +			" for %s\n", name);
 +
++=======
++>>>>>>> 0dc2e8d14353 (target: put struct target_fabric_configfs on a diet)
  	return &tf->tf_group;
  }
  
@@@ -508,77 -411,50 +507,106 @@@ static int target_fabric_tf_ops_check
  	return 0;
  }
  
 -int target_register_template(const struct target_core_fabric_ops *fo)
 +/*
 + * Called 2nd from fabric module with returned parameter of
 + * struct target_fabric_configfs * from target_fabric_configfs_init().
 + *
 + * Upon a successful registration, the new fabric's struct config_item is
 + * return.  Also, a pointer to this struct is set in the passed
 + * struct target_fabric_configfs.
 + */
 +int target_fabric_configfs_register(
 +	struct target_fabric_configfs *tf)
  {
 -	struct target_fabric_configfs *tf;
  	int ret;
  
 -	ret = target_fabric_tf_ops_check(fo);
 -	if (ret)
 +	if (!tf) {
 +		pr_err("Unable to locate target_fabric_configfs"
 +			" pointer\n");
 +		return -EINVAL;
 +	}
 +	if (!tf->tf_subsys) {
 +		pr_err("Unable to target struct config_subsystem"
 +			" pointer\n");
 +		return -EINVAL;
 +	}
 +	ret = target_fabric_tf_ops_check(tf);
 +	if (ret < 0)
  		return ret;
  
++<<<<<<< HEAD
 +	pr_debug("<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>"
 +		">>>>>>>>>>\n");
++=======
+ 	tf = kzalloc(sizeof(struct target_fabric_configfs), GFP_KERNEL);
+ 	if (!tf) {
+ 		pr_err("%s: could not allocate memory!\n", __func__);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	INIT_LIST_HEAD(&tf->tf_list);
+ 	atomic_set(&tf->tf_access_cnt, 0);
+ 	tf->tf_ops = fo;
+ 	target_fabric_setup_cits(tf);
+ 
+ 	mutex_lock(&g_tf_lock);
+ 	list_add_tail(&tf->tf_list, &g_tf_list);
+ 	mutex_unlock(&g_tf_lock);
+ 
++>>>>>>> 0dc2e8d14353 (target: put struct target_fabric_configfs on a diet)
  	return 0;
  }
 -EXPORT_SYMBOL(target_register_template);
 +EXPORT_SYMBOL(target_fabric_configfs_register);
  
 -void target_unregister_template(const struct target_core_fabric_ops *fo)
 +void target_fabric_configfs_deregister(
 +	struct target_fabric_configfs *tf)
  {
 -	struct target_fabric_configfs *t;
 +	struct configfs_subsystem *su;
  
++<<<<<<< HEAD
 +	if (!tf) {
 +		pr_err("Unable to locate passed target_fabric_"
 +			"configfs\n");
 +		return;
++=======
+ 	mutex_lock(&g_tf_lock);
+ 	list_for_each_entry(t, &g_tf_list, tf_list) {
+ 		if (!strcmp(t->tf_ops->name, fo->name)) {
+ 			BUG_ON(atomic_read(&t->tf_access_cnt));
+ 			list_del(&t->tf_list);
+ 			kfree(t);
+ 			break;
+ 		}
++>>>>>>> 0dc2e8d14353 (target: put struct target_fabric_configfs on a diet)
 +	}
 +	su = tf->tf_subsys;
 +	if (!su) {
 +		pr_err("Unable to locate passed tf->tf_subsys"
 +			" pointer\n");
 +		return;
 +	}
 +	pr_debug("<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>>>"
 +			">>>>>>>>>>>>\n");
 +	mutex_lock(&g_tf_lock);
 +	if (atomic_read(&tf->tf_access_cnt)) {
 +		mutex_unlock(&g_tf_lock);
 +		pr_err("Non zero tf->tf_access_cnt for fabric %s\n",
 +			tf->tf_name);
 +		BUG();
  	}
 +	list_del(&tf->tf_list);
  	mutex_unlock(&g_tf_lock);
 +
 +	pr_debug("Target_Core_ConfigFS: DEREGISTER -> Releasing tf:"
 +			" %s\n", tf->tf_name);
 +	tf->tf_module = NULL;
 +	tf->tf_subsys = NULL;
 +	kfree(tf);
 +
 +	pr_debug("<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>>>>>>"
 +			">>>>>\n");
  }
 -EXPORT_SYMBOL(target_unregister_template);
 +EXPORT_SYMBOL(target_fabric_configfs_deregister);
  
  /*##############################################################################
  // Stop functions called by external Target Fabrics Modules
diff --cc drivers/target/target_core_fabric_configfs.c
index 0c3f90130b7d,d2ce61a07afd..000000000000
--- a/drivers/target/target_core_fabric_configfs.c
+++ b/drivers/target/target_core_fabric_configfs.c
@@@ -56,6 -56,20 +56,23 @@@ static void target_fabric_setup_##_name
  	pr_debug("Setup generic %s\n", __stringify(_name));		\
  }
  
++<<<<<<< HEAD
++=======
+ #define TF_CIT_SETUP_DRV(_name, _item_ops, _group_ops)		\
+ static void target_fabric_setup_##_name##_cit(struct target_fabric_configfs *tf) \
+ {									\
+ 	struct target_fabric_configfs_template *tfc = &tf->tf_cit_tmpl;	\
+ 	struct config_item_type *cit = &tfc->tfc_##_name##_cit;		\
+ 	struct configfs_attribute **attrs = tf->tf_ops->tfc_##_name##_attrs; \
+ 									\
+ 	cit->ct_item_ops = _item_ops;					\
+ 	cit->ct_group_ops = _group_ops;					\
+ 	cit->ct_attrs = attrs;						\
+ 	cit->ct_owner = tf->tf_ops->module;				\
+ 	pr_debug("Setup generic %s\n", __stringify(_name));		\
+ }
+ 
++>>>>>>> 0dc2e8d14353 (target: put struct target_fabric_configfs on a diet)
  /* Start of tfc_tpg_mappedlun_cit */
  
  static int target_fabric_mappedlun_link(
diff --cc include/target/target_core_configfs.h
index e0801386e4dc,3f11d2ead63d..000000000000
--- a/include/target/target_core_configfs.h
+++ b/include/target/target_core_configfs.h
@@@ -42,15 -35,7 +41,19 @@@ struct target_fabric_configfs 
  	struct config_group	tf_group;
  	struct config_group	tf_disc_group;
  	struct config_group	*tf_default_groups[2];
++<<<<<<< HEAD
 +	/* Pointer to fabric's config_item */
 +	struct config_item	*tf_fabric;
 +	/* Passed from fabric modules */
 +	struct config_item_type	*tf_fabric_cit;
 +	/* Pointer to target core subsystem */
 +	struct configfs_subsystem *tf_subsys;
 +	/* Pointer to fabric's struct module */
 +	struct module *tf_module;
 +	struct target_core_fabric_ops tf_ops;
++=======
+ 	const struct target_core_fabric_ops *tf_ops;
++>>>>>>> 0dc2e8d14353 (target: put struct target_fabric_configfs on a diet)
  	struct target_fabric_configfs_template tf_cit_tmpl;
  };
  
* Unmerged path drivers/target/target_core_configfs.c
* Unmerged path drivers/target/target_core_fabric_configfs.c
* Unmerged path include/target/target_core_configfs.h
