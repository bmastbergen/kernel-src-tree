libnvdimm, btt: fix a missed NVDIMM_IO_ATOMIC case in the write path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Vishal Verma <vishal.l.verma@intel.com>
commit 1db1f3cea1d8886c686832d4618b346ae16c03c8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1db1f3ce.failed

The IO context conversion for rw_bytes missed a case in the BTT write
path (btt_map_write) which should've been marked as atomic.

In reality this should not cause a problem, because map writes are to
small for nsio_rw_bytes to attempt error clearing, but it should be
fixed for posterity.

Add a might_sleep() in the non-atomic section of nsio_rw_bytes so that
things like the nfit unit tests, which don't actually sleep, can catch
bugs like this.

	Cc: Dan Williams <dan.j.williams@intel.com>
	Signed-off-by: Vishal Verma <vishal.l.verma@intel.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 1db1f3cea1d8886c686832d4618b346ae16c03c8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvdimm/btt.c
diff --cc drivers/nvdimm/btt.c
index 870e0156bc06,a5e4134e1ed0..000000000000
--- a/drivers/nvdimm/btt.c
+++ b/drivers/nvdimm/btt.c
@@@ -1106,7 -1156,8 +1106,12 @@@ static int btt_write_pg(struct btt *btt
  		if (ret)
  			goto out_map;
  
++<<<<<<< HEAD
 +		ret = btt_map_write(arena, premap, new_postmap, 0, 0);
++=======
+ 		ret = btt_map_write(arena, premap, new_postmap, 0, 0,
+ 			NVDIMM_IO_ATOMIC);
++>>>>>>> 1db1f3cea1d8 (libnvdimm, btt: fix a missed NVDIMM_IO_ATOMIC case in the write path)
  		if (ret)
  			goto out_map;
  
* Unmerged path drivers/nvdimm/btt.c
diff --git a/drivers/nvdimm/claim.c b/drivers/nvdimm/claim.c
index 961c67033dc8..1dce4d6b5489 100644
--- a/drivers/nvdimm/claim.c
+++ b/drivers/nvdimm/claim.c
@@ -290,6 +290,7 @@ static int nsio_rw_bytes(struct nd_namespace_common *ndns,
 				&& (!ndns->claim || !is_nd_btt(ndns->claim))) {
 			long cleared;
 
+			might_sleep();
 			cleared = nvdimm_clear_poison(&ndns->dev,
 					nsio->res.start + offset, size);
 			if (cleared < size)
