IB/CM: Add OPA Path record support to CM

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Hiatt, Don <don.hiatt@intel.com>
commit e92aa00a518971fca6b79aa87a1a9c5e5aa51f3b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e92aa00a.failed

Add OPA path record support to the Connection Manager.

	Signed-off-by: Don Hiatt <don.hiatt@intel.com>
	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit e92aa00a518971fca6b79aa87a1a9c5e5aa51f3b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/cm.c
diff --cc drivers/infiniband/core/cm.c
index 70c24aef631d,885c429b4942..000000000000
--- a/drivers/infiniband/core/cm.c
+++ b/drivers/infiniband/core/cm.c
@@@ -1172,8 -1173,13 +1172,18 @@@ static void cm_format_req(struct cm_req
  			  struct cm_id_private *cm_id_priv,
  			  struct ib_cm_req_param *param)
  {
++<<<<<<< HEAD
 +	struct ib_sa_path_rec *pri_path = param->primary_path;
 +	struct ib_sa_path_rec *alt_path = param->alternate_path;
++=======
+ 	struct sa_path_rec *pri_path = param->primary_path;
+ 	struct sa_path_rec *alt_path = param->alternate_path;
+ 	bool pri_ext = false;
+ 
+ 	if (pri_path->rec_type == SA_PATH_REC_TYPE_OPA)
+ 		pri_ext = opa_is_extended_lid(pri_path->opa.dlid,
+ 					      pri_path->opa.slid);
++>>>>>>> e92aa00a5189 (IB/CM: Add OPA Path record support to CM)
  
  	cm_format_mad_hdr(&req_msg->hdr, CM_REQ_ATTR_ID,
  			  cm_form_tid(cm_id_priv, CM_MSG_SEQUENCE_REQ));
@@@ -1201,9 -1207,19 +1211,24 @@@
  		cm_req_set_srq(req_msg, param->srq);
  	}
  
+ 	req_msg->primary_local_gid = pri_path->sgid;
+ 	req_msg->primary_remote_gid = pri_path->dgid;
+ 	if (pri_ext) {
+ 		req_msg->primary_local_gid.global.interface_id
+ 			= OPA_MAKE_ID(be32_to_cpu(pri_path->opa.slid));
+ 		req_msg->primary_remote_gid.global.interface_id
+ 			= OPA_MAKE_ID(be32_to_cpu(pri_path->opa.dlid));
+ 	}
  	if (pri_path->hop_limit <= 1) {
++<<<<<<< HEAD
 +		req_msg->primary_local_lid = pri_path->slid;
 +		req_msg->primary_remote_lid = pri_path->dlid;
++=======
+ 		req_msg->primary_local_lid = pri_ext ? 0 :
+ 			htons(ntohl(sa_path_get_slid(pri_path)));
+ 		req_msg->primary_remote_lid = pri_ext ? 0 :
+ 			htons(ntohl(sa_path_get_dlid(pri_path)));
++>>>>>>> e92aa00a5189 (IB/CM: Add OPA Path record support to CM)
  	} else {
  		/* Work-around until there's a way to obtain remote LID info */
  		req_msg->primary_local_lid = IB_LID_PERMISSIVE;
@@@ -1222,9 -1236,25 +1245,30 @@@
  			       pri_path->packet_life_time));
  
  	if (alt_path) {
+ 		bool alt_ext = false;
+ 
+ 		if (alt_path->rec_type == SA_PATH_REC_TYPE_OPA)
+ 			alt_ext = opa_is_extended_lid(alt_path->opa.dlid,
+ 						      alt_path->opa.slid);
+ 
+ 		req_msg->alt_local_gid = alt_path->sgid;
+ 		req_msg->alt_remote_gid = alt_path->dgid;
+ 		if (alt_ext) {
+ 			req_msg->alt_local_gid.global.interface_id
+ 				= OPA_MAKE_ID(be32_to_cpu(alt_path->opa.slid));
+ 			req_msg->alt_remote_gid.global.interface_id
+ 				= OPA_MAKE_ID(be32_to_cpu(alt_path->opa.dlid));
+ 		}
  		if (alt_path->hop_limit <= 1) {
++<<<<<<< HEAD
 +			req_msg->alt_local_lid = alt_path->slid;
 +			req_msg->alt_remote_lid = alt_path->dlid;
++=======
+ 			req_msg->alt_local_lid = alt_ext ? 0 :
+ 				htons(ntohl(sa_path_get_slid(alt_path)));
+ 			req_msg->alt_remote_lid = alt_ext ? 0 :
+ 				htons(ntohl(sa_path_get_dlid(alt_path)));
++>>>>>>> e92aa00a5189 (IB/CM: Add OPA Path record support to CM)
  		} else {
  			req_msg->alt_local_lid = IB_LID_PERMISSIVE;
  			req_msg->alt_remote_lid = IB_LID_PERMISSIVE;
@@@ -2822,10 -2878,18 +2869,16 @@@ static void cm_format_lap(struct cm_lap
  	cm_lap_set_remote_qpn(lap_msg, cm_id_priv->remote_qpn);
  	/* todo: need remote CM response timeout */
  	cm_lap_set_remote_resp_timeout(lap_msg, 0x1F);
 -	lap_msg->alt_local_lid =
 -		htons(ntohl(sa_path_get_slid(alternate_path)));
 -	lap_msg->alt_remote_lid =
 -		htons(ntohl(sa_path_get_dlid(alternate_path)));
 +	lap_msg->alt_local_lid = alternate_path->slid;
 +	lap_msg->alt_remote_lid = alternate_path->dlid;
  	lap_msg->alt_local_gid = alternate_path->sgid;
  	lap_msg->alt_remote_gid = alternate_path->dgid;
+ 	if (alt_ext) {
+ 		lap_msg->alt_local_gid.global.interface_id
+ 			= OPA_MAKE_ID(be32_to_cpu(alternate_path->opa.slid));
+ 		lap_msg->alt_remote_gid.global.interface_id
+ 			= OPA_MAKE_ID(be32_to_cpu(alternate_path->opa.dlid));
+ 	}
  	cm_lap_set_flow_label(lap_msg, alternate_path->flow_label);
  	cm_lap_set_traffic_class(lap_msg, alternate_path->traffic_class);
  	lap_msg->alt_hop_limit = alternate_path->hop_limit;
* Unmerged path drivers/infiniband/core/cm.c
diff --git a/include/rdma/opa_addr.h b/include/rdma/opa_addr.h
index eace28f1555d..df6bbafe34ec 100644
--- a/include/rdma/opa_addr.h
+++ b/include/rdma/opa_addr.h
@@ -76,4 +76,22 @@ static inline u32 opa_get_lid_from_gid(union ib_gid *gid)
 {
 	return be64_to_cpu(gid->global.interface_id) & 0xFFFFFFFF;
 }
+
+/**
+ * opa_is_extended_lid: Returns true if dlid or slid are
+ * extended.
+ *
+ * @dlid: The DLID
+ * @slid: The SLID
+ */
+static inline bool opa_is_extended_lid(u32 dlid, u32 slid)
+{
+	if ((be32_to_cpu(dlid) >=
+	     be16_to_cpu(IB_MULTICAST_LID_BASE)) ||
+	    (be32_to_cpu(slid) >=
+	     be16_to_cpu(IB_MULTICAST_LID_BASE)))
+		return true;
+	else
+		return false;
+}
 #endif /* OPA_ADDR_H */
