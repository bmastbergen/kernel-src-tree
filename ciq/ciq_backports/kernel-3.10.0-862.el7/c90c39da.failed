genetlink: introduce and use genl_family_attrbuf()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Johannes Berg <johannes.berg@intel.com>
commit c90c39dab3e02ce45427a214746711f33ad13be6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c90c39da.failed

This helper function allows family implementations to access
their family's attrbuf. This gets rid of the attrbuf usage
in families, and also adds locking validation, since it's not
valid to use the attrbuf with parallel_ops or outside of the
dumpit callback.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c90c39dab3e02ce45427a214746711f33ad13be6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/tipc/netlink.c
#	net/wireless/nl80211.c
diff --cc net/tipc/netlink.c
index 1e6081fb6078,4b94f3cfe3af..000000000000
--- a/net/tipc/netlink.c
+++ b/net/tipc/netlink.c
@@@ -35,53 -35,239 +35,59 @@@
   */
  
  #include "core.h"
 -#include "socket.h"
 -#include "name_table.h"
 -#include "bearer.h"
 -#include "link.h"
 -#include "node.h"
 -#include "net.h"
 -#include "udp_media.h"
 +#include "config.h"
  #include <net/genetlink.h>
  
 -static const struct nla_policy tipc_nl_policy[TIPC_NLA_MAX + 1] = {
 -	[TIPC_NLA_UNSPEC]	= { .type = NLA_UNSPEC, },
 -	[TIPC_NLA_BEARER]	= { .type = NLA_NESTED, },
 -	[TIPC_NLA_SOCK]		= { .type = NLA_NESTED, },
 -	[TIPC_NLA_PUBL]		= { .type = NLA_NESTED, },
 -	[TIPC_NLA_LINK]		= { .type = NLA_NESTED, },
 -	[TIPC_NLA_MEDIA]	= { .type = NLA_NESTED, },
 -	[TIPC_NLA_NODE]		= { .type = NLA_NESTED, },
 -	[TIPC_NLA_NET]		= { .type = NLA_NESTED, },
 -	[TIPC_NLA_NAME_TABLE]	= { .type = NLA_NESTED, },
 -	[TIPC_NLA_MON]		= { .type = NLA_NESTED, },
 -};
 -
 -const struct nla_policy
 -tipc_nl_name_table_policy[TIPC_NLA_NAME_TABLE_MAX + 1] = {
 -	[TIPC_NLA_NAME_TABLE_UNSPEC]	= { .type = NLA_UNSPEC },
 -	[TIPC_NLA_NAME_TABLE_PUBL]	= { .type = NLA_NESTED }
 -};
 -
 -const struct nla_policy tipc_nl_monitor_policy[TIPC_NLA_MON_MAX + 1] = {
 -	[TIPC_NLA_MON_UNSPEC]			= { .type = NLA_UNSPEC },
 -	[TIPC_NLA_MON_REF]			= { .type = NLA_U32 },
 -	[TIPC_NLA_MON_ACTIVATION_THRESHOLD]	= { .type = NLA_U32 },
 -};
 -
 -const struct nla_policy tipc_nl_sock_policy[TIPC_NLA_SOCK_MAX + 1] = {
 -	[TIPC_NLA_SOCK_UNSPEC]		= { .type = NLA_UNSPEC },
 -	[TIPC_NLA_SOCK_ADDR]		= { .type = NLA_U32 },
 -	[TIPC_NLA_SOCK_REF]		= { .type = NLA_U32 },
 -	[TIPC_NLA_SOCK_CON]		= { .type = NLA_NESTED },
 -	[TIPC_NLA_SOCK_HAS_PUBL]	= { .type = NLA_FLAG }
 -};
 -
 -const struct nla_policy tipc_nl_net_policy[TIPC_NLA_NET_MAX + 1] = {
 -	[TIPC_NLA_NET_UNSPEC]		= { .type = NLA_UNSPEC },
 -	[TIPC_NLA_NET_ID]		= { .type = NLA_U32 }
 -};
 -
 -const struct nla_policy tipc_nl_link_policy[TIPC_NLA_LINK_MAX + 1] = {
 -	[TIPC_NLA_LINK_UNSPEC]		= { .type = NLA_UNSPEC },
 -	[TIPC_NLA_LINK_NAME]		= { .type = NLA_STRING,
 -					    .len = TIPC_MAX_LINK_NAME },
 -	[TIPC_NLA_LINK_MTU]		= { .type = NLA_U32 },
 -	[TIPC_NLA_LINK_BROADCAST]	= { .type = NLA_FLAG },
 -	[TIPC_NLA_LINK_UP]		= { .type = NLA_FLAG },
 -	[TIPC_NLA_LINK_ACTIVE]		= { .type = NLA_FLAG },
 -	[TIPC_NLA_LINK_PROP]		= { .type = NLA_NESTED },
 -	[TIPC_NLA_LINK_STATS]		= { .type = NLA_NESTED },
 -	[TIPC_NLA_LINK_RX]		= { .type = NLA_U32 },
 -	[TIPC_NLA_LINK_TX]		= { .type = NLA_U32 }
 -};
 -
 -const struct nla_policy tipc_nl_node_policy[TIPC_NLA_NODE_MAX + 1] = {
 -	[TIPC_NLA_NODE_UNSPEC]		= { .type = NLA_UNSPEC },
 -	[TIPC_NLA_NODE_ADDR]		= { .type = NLA_U32 },
 -	[TIPC_NLA_NODE_UP]		= { .type = NLA_FLAG }
 -};
 -
 -/* Properties valid for media, bearer and link */
 -const struct nla_policy tipc_nl_prop_policy[TIPC_NLA_PROP_MAX + 1] = {
 -	[TIPC_NLA_PROP_UNSPEC]		= { .type = NLA_UNSPEC },
 -	[TIPC_NLA_PROP_PRIO]		= { .type = NLA_U32 },
 -	[TIPC_NLA_PROP_TOL]		= { .type = NLA_U32 },
 -	[TIPC_NLA_PROP_WIN]		= { .type = NLA_U32 }
 -};
 -
 -const struct nla_policy tipc_nl_bearer_policy[TIPC_NLA_BEARER_MAX + 1]	= {
 -	[TIPC_NLA_BEARER_UNSPEC]	= { .type = NLA_UNSPEC },
 -	[TIPC_NLA_BEARER_NAME]		= { .type = NLA_STRING,
 -					    .len = TIPC_MAX_BEARER_NAME },
 -	[TIPC_NLA_BEARER_PROP]		= { .type = NLA_NESTED },
 -	[TIPC_NLA_BEARER_DOMAIN]	= { .type = NLA_U32 }
 -};
 -
 -const struct nla_policy tipc_nl_media_policy[TIPC_NLA_MEDIA_MAX + 1] = {
 -	[TIPC_NLA_MEDIA_UNSPEC]		= { .type = NLA_UNSPEC },
 -	[TIPC_NLA_MEDIA_NAME]		= { .type = NLA_STRING },
 -	[TIPC_NLA_MEDIA_PROP]		= { .type = NLA_NESTED }
 -};
 +static int handle_cmd(struct sk_buff *skb, struct genl_info *info)
 +{
 +	struct sk_buff *rep_buf;
 +	struct nlmsghdr *rep_nlh;
 +	struct nlmsghdr *req_nlh = info->nlhdr;
 +	struct tipc_genlmsghdr *req_userhdr = info->userhdr;
 +	int hdr_space = nlmsg_total_size(GENL_HDRLEN + TIPC_GENL_HDRLEN);
 +	u16 cmd;
 +
++<<<<<<< HEAD
 +	if ((req_userhdr->cmd & 0xC000) && (!netlink_capable(skb, CAP_NET_ADMIN)))
 +		cmd = TIPC_CMD_NOT_NET_ADMIN;
 +	else
 +		cmd = req_userhdr->cmd;
++=======
++	*attr = genl_family_attrbuf(&tipc_genl_family);
++	if (!*attr)
++		return -EOPNOTSUPP;
++>>>>>>> c90c39dab3e0 (genetlink: introduce and use genl_family_attrbuf())
 +
 +	rep_buf = tipc_cfg_do_cmd(req_userhdr->dest, cmd,
 +			nlmsg_data(req_nlh) + GENL_HDRLEN + TIPC_GENL_HDRLEN,
 +			nlmsg_attrlen(req_nlh, GENL_HDRLEN + TIPC_GENL_HDRLEN),
 +			hdr_space);
 +
 +	if (rep_buf) {
 +		skb_push(rep_buf, hdr_space);
 +		rep_nlh = nlmsg_hdr(rep_buf);
 +		memcpy(rep_nlh, req_nlh, hdr_space);
 +		rep_nlh->nlmsg_len = rep_buf->len;
 +		genlmsg_unicast(&init_net, rep_buf, NETLINK_CB(skb).portid);
 +	}
  
 -const struct nla_policy tipc_nl_udp_policy[TIPC_NLA_UDP_MAX + 1] = {
 -	[TIPC_NLA_UDP_UNSPEC]	= {.type = NLA_UNSPEC},
 -	[TIPC_NLA_UDP_LOCAL]	= {.type = NLA_BINARY,
 -				   .len = sizeof(struct sockaddr_storage)},
 -	[TIPC_NLA_UDP_REMOTE]	= {.type = NLA_BINARY,
 -				   .len = sizeof(struct sockaddr_storage)},
 -};
 +	return 0;
 +}
  
 -/* Users of the legacy API (tipc-config) can't handle that we add operations,
 - * so we have a separate genl handling for the new API.
 - */
 -struct genl_family tipc_genl_family = {
 +static struct genl_family tipc_genl_family = {
  	.id		= GENL_ID_GENERATE,
 -	.name		= TIPC_GENL_V2_NAME,
 -	.version	= TIPC_GENL_V2_VERSION,
 -	.hdrsize	= 0,
 -	.maxattr	= TIPC_NLA_MAX,
 -	.netnsok	= true,
 +	.name		= TIPC_GENL_NAME,
 +	.version	= TIPC_GENL_VERSION,
 +	.hdrsize	= TIPC_GENL_HDRLEN,
 +	.maxattr	= 0,
  };
  
 -static const struct genl_ops tipc_genl_v2_ops[] = {
 -	{
 -		.cmd	= TIPC_NL_BEARER_DISABLE,
 -		.doit	= tipc_nl_bearer_disable,
 -		.policy = tipc_nl_policy,
 -	},
 -	{
 -		.cmd	= TIPC_NL_BEARER_ENABLE,
 -		.doit	= tipc_nl_bearer_enable,
 -		.policy = tipc_nl_policy,
 -	},
 -	{
 -		.cmd	= TIPC_NL_BEARER_GET,
 -		.doit	= tipc_nl_bearer_get,
 -		.dumpit	= tipc_nl_bearer_dump,
 -		.policy = tipc_nl_policy,
 -	},
 -	{
 -		.cmd	= TIPC_NL_BEARER_ADD,
 -		.doit	= tipc_nl_bearer_add,
 -		.policy = tipc_nl_policy,
 -	},
 -	{
 -		.cmd	= TIPC_NL_BEARER_SET,
 -		.doit	= tipc_nl_bearer_set,
 -		.policy = tipc_nl_policy,
 -	},
 -	{
 -		.cmd	= TIPC_NL_SOCK_GET,
 -		.dumpit	= tipc_nl_sk_dump,
 -		.policy = tipc_nl_policy,
 -	},
 -	{
 -		.cmd	= TIPC_NL_PUBL_GET,
 -		.dumpit	= tipc_nl_publ_dump,
 -		.policy = tipc_nl_policy,
 -	},
 -	{
 -		.cmd	= TIPC_NL_LINK_GET,
 -		.doit   = tipc_nl_node_get_link,
 -		.dumpit	= tipc_nl_node_dump_link,
 -		.policy = tipc_nl_policy,
 -	},
 -	{
 -		.cmd	= TIPC_NL_LINK_SET,
 -		.doit	= tipc_nl_node_set_link,
 -		.policy = tipc_nl_policy,
 -	},
 -	{
 -		.cmd	= TIPC_NL_LINK_RESET_STATS,
 -		.doit   = tipc_nl_node_reset_link_stats,
 -		.policy = tipc_nl_policy,
 -	},
 -	{
 -		.cmd	= TIPC_NL_MEDIA_GET,
 -		.doit	= tipc_nl_media_get,
 -		.dumpit	= tipc_nl_media_dump,
 -		.policy = tipc_nl_policy,
 -	},
 -	{
 -		.cmd	= TIPC_NL_MEDIA_SET,
 -		.doit	= tipc_nl_media_set,
 -		.policy = tipc_nl_policy,
 -	},
 -	{
 -		.cmd	= TIPC_NL_NODE_GET,
 -		.dumpit	= tipc_nl_node_dump,
 -		.policy = tipc_nl_policy,
 -	},
 -	{
 -		.cmd	= TIPC_NL_NET_GET,
 -		.dumpit	= tipc_nl_net_dump,
 -		.policy = tipc_nl_policy,
 -	},
 -	{
 -		.cmd	= TIPC_NL_NET_SET,
 -		.doit	= tipc_nl_net_set,
 -		.policy = tipc_nl_policy,
 -	},
 -	{
 -		.cmd	= TIPC_NL_NAME_TABLE_GET,
 -		.dumpit	= tipc_nl_name_table_dump,
 -		.policy = tipc_nl_policy,
 -	},
 -	{
 -		.cmd	= TIPC_NL_MON_SET,
 -		.doit	= tipc_nl_node_set_monitor,
 -		.policy = tipc_nl_policy,
 -	},
 -	{
 -		.cmd	= TIPC_NL_MON_GET,
 -		.doit	= tipc_nl_node_get_monitor,
 -		.dumpit	= tipc_nl_node_dump_monitor,
 -		.policy = tipc_nl_policy,
 -	},
 -	{
 -		.cmd	= TIPC_NL_MON_PEER_GET,
 -		.dumpit	= tipc_nl_node_dump_monitor_peer,
 -		.policy = tipc_nl_policy,
 -	},
 -	{
 -		.cmd	= TIPC_NL_PEER_REMOVE,
 -		.doit	= tipc_nl_peer_rm,
 -		.policy = tipc_nl_policy,
 -	},
 -#ifdef CONFIG_TIPC_MEDIA_UDP
 -	{
 -		.cmd	= TIPC_NL_UDP_GET_REMOTEIP,
 -		.dumpit	= tipc_udp_nl_dump_remoteip,
 -		.policy = tipc_nl_policy,
 -	},
 -#endif
 +static struct genl_ops tipc_genl_ops = {
 +	.cmd		= TIPC_GENL_CMD,
 +	.doit		= handle_cmd,
  };
  
 -int tipc_nlmsg_parse(const struct nlmsghdr *nlh, struct nlattr ***attr)
 -{
 -	u32 maxattr = tipc_genl_family.maxattr;
 -
 -	*attr = genl_family_attrbuf(&tipc_genl_family);
 -	if (!*attr)
 -		return -EOPNOTSUPP;
 -
 -	return nlmsg_parse(nlh, GENL_HDRLEN, *attr, maxattr, tipc_nl_policy);
 -}
 +static int tipc_genl_family_registered;
  
  int tipc_netlink_start(void)
  {
diff --cc net/wireless/nl80211.c
index aea6305a7568,7d8cb3330c86..000000000000
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@@ -545,17 -547,22 +545,27 @@@ static int nl80211_prepare_wdev_dump(st
  {
  	int err;
  
 -	rtnl_lock();
 -
  	if (!cb->args[0]) {
  		err = nlmsg_parse(cb->nlh, GENL_HDRLEN + nl80211_fam.hdrsize,
- 				  nl80211_fam.attrbuf, nl80211_fam.maxattr,
- 				  nl80211_policy);
+ 				  genl_family_attrbuf(&nl80211_fam),
+ 				  nl80211_fam.maxattr, nl80211_policy);
  		if (err)
 -			goto out_unlock;
 +			return err;
  
++<<<<<<< HEAD
 +		*wdev = __cfg80211_wdev_from_attrs(sock_net(skb->sk),
 +						   nl80211_fam.attrbuf);
 +		if (IS_ERR(*wdev))
 +			return PTR_ERR(*wdev);
++=======
+ 		*wdev = __cfg80211_wdev_from_attrs(
+ 					sock_net(skb->sk),
+ 					genl_family_attrbuf(&nl80211_fam));
+ 		if (IS_ERR(*wdev)) {
+ 			err = PTR_ERR(*wdev);
+ 			goto out_unlock;
+ 		}
++>>>>>>> c90c39dab3e0 (genetlink: introduce and use genl_family_attrbuf())
  		*rdev = wiphy_to_rdev((*wdev)->wiphy);
  		/* 0 is the first index - add 1 to parse only once */
  		cb->args[0] = (*rdev)->wiphy_idx + 1;
@@@ -7774,13 -7652,12 +7785,13 @@@ static int nl80211_dump_survey(struct s
  	int res;
  	bool radio_stats;
  
 +	rtnl_lock();
  	res = nl80211_prepare_wdev_dump(skb, cb, &rdev, &wdev);
  	if (res)
 -		return res;
 +		goto out_err;
  
  	/* prepare_wdev_dump parsed the attributes */
- 	radio_stats = nl80211_fam.attrbuf[NL80211_ATTR_SURVEY_RADIO_STATS];
+ 	radio_stats = attrbuf[NL80211_ATTR_SURVEY_RADIO_STATS];
  
  	if (!wdev->netdev) {
  		res = -EINVAL;
@@@ -8627,16 -8479,11 +8638,17 @@@ static int nl80211_testmode_dump(struc
  		 * so we need to offset by 1.
  		 */
  		phy_idx = cb->args[0] - 1;
 +
 +		rdev = cfg80211_rdev_by_wiphy_idx(phy_idx);
 +		if (!rdev) {
 +			err = -ENOENT;
 +			goto out_err;
 +		}
  	} else {
+ 		struct nlattr **attrbuf = genl_family_attrbuf(&nl80211_fam);
+ 
  		err = nlmsg_parse(cb->nlh, GENL_HDRLEN + nl80211_fam.hdrsize,
- 				  nl80211_fam.attrbuf, nl80211_fam.maxattr,
- 				  nl80211_policy);
+ 				  attrbuf, nl80211_fam.maxattr, nl80211_policy);
  		if (err)
  			goto out_err;
  
@@@ -8647,10 -8493,10 +8658,9 @@@
  			goto out_err;
  		}
  		phy_idx = rdev->wiphy_idx;
 -		rdev = NULL;
  
- 		if (nl80211_fam.attrbuf[NL80211_ATTR_TESTDATA])
- 			cb->args[1] =
- 				(long)nl80211_fam.attrbuf[NL80211_ATTR_TESTDATA];
+ 		if (attrbuf[NL80211_ATTR_TESTDATA])
+ 			cb->args[1] = (long)attrbuf[NL80211_ATTR_TESTDATA];
  	}
  
  	if (cb->args[1]) {
@@@ -11530,27 -11314,28 +11541,41 @@@ static int nl80211_prepare_vendor_dump(
  	}
  
  	err = nlmsg_parse(cb->nlh, GENL_HDRLEN + nl80211_fam.hdrsize,
- 			  nl80211_fam.attrbuf, nl80211_fam.maxattr,
- 			  nl80211_policy);
+ 			  attrbuf, nl80211_fam.maxattr, nl80211_policy);
  	if (err)
 -		goto out_unlock;
 +		return err;
  
++<<<<<<< HEAD
 +	if (!nl80211_fam.attrbuf[NL80211_ATTR_VENDOR_ID] ||
 +	    !nl80211_fam.attrbuf[NL80211_ATTR_VENDOR_SUBCMD])
 +		return -EINVAL;
++=======
+ 	if (!attrbuf[NL80211_ATTR_VENDOR_ID] ||
+ 	    !attrbuf[NL80211_ATTR_VENDOR_SUBCMD]) {
+ 		err = -EINVAL;
+ 		goto out_unlock;
+ 	}
++>>>>>>> c90c39dab3e0 (genetlink: introduce and use genl_family_attrbuf())
  
- 	*wdev = __cfg80211_wdev_from_attrs(sock_net(skb->sk),
- 					   nl80211_fam.attrbuf);
+ 	*wdev = __cfg80211_wdev_from_attrs(sock_net(skb->sk), attrbuf);
  	if (IS_ERR(*wdev))
  		*wdev = NULL;
  
++<<<<<<< HEAD
 +	*rdev = __cfg80211_rdev_from_attrs(sock_net(skb->sk),
 +					   nl80211_fam.attrbuf);
 +	if (IS_ERR(*rdev))
 +		return PTR_ERR(*rdev);
++=======
+ 	*rdev = __cfg80211_rdev_from_attrs(sock_net(skb->sk), attrbuf);
+ 	if (IS_ERR(*rdev)) {
+ 		err = PTR_ERR(*rdev);
+ 		goto out_unlock;
+ 	}
++>>>>>>> c90c39dab3e0 (genetlink: introduce and use genl_family_attrbuf())
  
- 	vid = nla_get_u32(nl80211_fam.attrbuf[NL80211_ATTR_VENDOR_ID]);
- 	subcmd = nla_get_u32(nl80211_fam.attrbuf[NL80211_ATTR_VENDOR_SUBCMD]);
+ 	vid = nla_get_u32(attrbuf[NL80211_ATTR_VENDOR_ID]);
+ 	subcmd = nla_get_u32(attrbuf[NL80211_ATTR_VENDOR_SUBCMD]);
  
  	for (i = 0; i < (*rdev)->wiphy.n_vendor_commands; i++) {
  		const struct wiphy_vendor_command *vcmd;
@@@ -11567,12 -11354,14 +11592,12 @@@
  		break;
  	}
  
 -	if (vcmd_idx < 0) {
 -		err = -EOPNOTSUPP;
 -		goto out_unlock;
 -	}
 +	if (vcmd_idx < 0)
 +		return -EOPNOTSUPP;
  
- 	if (nl80211_fam.attrbuf[NL80211_ATTR_VENDOR_DATA]) {
- 		data = nla_data(nl80211_fam.attrbuf[NL80211_ATTR_VENDOR_DATA]);
- 		data_len = nla_len(nl80211_fam.attrbuf[NL80211_ATTR_VENDOR_DATA]);
+ 	if (attrbuf[NL80211_ATTR_VENDOR_DATA]) {
+ 		data = nla_data(attrbuf[NL80211_ATTR_VENDOR_DATA]);
+ 		data_len = nla_len(attrbuf[NL80211_ATTR_VENDOR_DATA]);
  	}
  
  	/* 0 is the first index - add 1 to parse only once */
diff --git a/include/net/genetlink.h b/include/net/genetlink.h
index f37e06abcb6d..857ce2ced03c 100644
--- a/include/net/genetlink.h
+++ b/include/net/genetlink.h
@@ -74,6 +74,8 @@ struct genl_family {
 	RH_KABI_RESERVE(4)
 };
 
+struct nlattr **genl_family_attrbuf(struct genl_family *family);
+
 /**
  * struct genl_info - receiving information
  * @snd_seq: sending sequence number
diff --git a/net/ieee802154/nl802154.c b/net/ieee802154/nl802154.c
index 0a289ced1d31..bab1246fe56d 100644
--- a/net/ieee802154/nl802154.c
+++ b/net/ieee802154/nl802154.c
@@ -263,13 +263,14 @@ nl802154_prepare_wpan_dev_dump(struct sk_buff *skb,
 
 	if (!cb->args[0]) {
 		err = nlmsg_parse(cb->nlh, GENL_HDRLEN + nl802154_fam.hdrsize,
-				  nl802154_fam.attrbuf, nl802154_fam.maxattr,
+				  genl_family_attrbuf(&nl802154_fam),
+				  nl802154_fam.maxattr,
 				  nl802154_policy);
 		if (err)
 			goto out_unlock;
 
 		*wpan_dev = __cfg802154_wpan_dev_from_attrs(sock_net(skb->sk),
-							    nl802154_fam.attrbuf);
+							    genl_family_attrbuf(&nl802154_fam));
 		if (IS_ERR(*wpan_dev)) {
 			err = PTR_ERR(*wpan_dev);
 			goto out_unlock;
@@ -575,7 +576,7 @@ static int nl802154_dump_wpan_phy_parse(struct sk_buff *skb,
 					struct netlink_callback *cb,
 					struct nl802154_dump_wpan_phy_state *state)
 {
-	struct nlattr **tb = nl802154_fam.attrbuf;
+	struct nlattr **tb = genl_family_attrbuf(&nl802154_fam);
 	int ret = nlmsg_parse(cb->nlh, GENL_HDRLEN + nl802154_fam.hdrsize,
 			      tb, nl802154_fam.maxattr, nl802154_policy);
 
diff --git a/net/netlink/genetlink.c b/net/netlink/genetlink.c
index a93aabe188f7..9a9d208cc940 100644
--- a/net/netlink/genetlink.c
+++ b/net/netlink/genetlink.c
@@ -1043,6 +1043,25 @@ problem:
 
 subsys_initcall(genl_init);
 
+/**
+ * genl_family_attrbuf - return family's attrbuf
+ * @family: the family
+ *
+ * Return the family's attrbuf, while validating that it's
+ * actually valid to access it.
+ *
+ * You cannot use this function with a family that has parallel_ops
+ * and you can only use it within (pre/post) doit/dumpit callbacks.
+ */
+struct nlattr **genl_family_attrbuf(struct genl_family *family)
+{
+	if (!WARN_ON(family->parallel_ops))
+		lockdep_assert_held(&genl_mutex);
+
+	return family->attrbuf;
+}
+EXPORT_SYMBOL(genl_family_attrbuf);
+
 static int genlmsg_mcast(struct sk_buff *skb, u32 portid, unsigned long group,
 			 gfp_t flags)
 {
diff --git a/net/nfc/netlink.c b/net/nfc/netlink.c
index 851f6e469c68..580226abc2ad 100644
--- a/net/nfc/netlink.c
+++ b/net/nfc/netlink.c
@@ -103,21 +103,20 @@ nla_put_failure:
 
 static struct nfc_dev *__get_device_from_cb(struct netlink_callback *cb)
 {
+	struct nlattr **attrbuf = genl_family_attrbuf(&nfc_genl_family);
 	struct nfc_dev *dev;
 	int rc;
 	u32 idx;
 
 	rc = nlmsg_parse(cb->nlh, GENL_HDRLEN + nfc_genl_family.hdrsize,
-			 nfc_genl_family.attrbuf,
-			 nfc_genl_family.maxattr,
-			 nfc_genl_policy);
+			 attrbuf, nfc_genl_family.maxattr, nfc_genl_policy);
 	if (rc < 0)
 		return ERR_PTR(rc);
 
-	if (!nfc_genl_family.attrbuf[NFC_ATTR_DEVICE_INDEX])
+	if (!attrbuf[NFC_ATTR_DEVICE_INDEX])
 		return ERR_PTR(-EINVAL);
 
-	idx = nla_get_u32(nfc_genl_family.attrbuf[NFC_ATTR_DEVICE_INDEX]);
+	idx = nla_get_u32(attrbuf[NFC_ATTR_DEVICE_INDEX]);
 
 	dev = nfc_get_device(idx);
 	if (!dev)
* Unmerged path net/tipc/netlink.c
* Unmerged path net/wireless/nl80211.c
