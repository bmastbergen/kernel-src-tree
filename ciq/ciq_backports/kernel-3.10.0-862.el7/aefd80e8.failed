hv_netvsc: preserve hw_features on mtu/channels/ringparam changes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit aefd80e874e98a864915df5b7d90824a4340b450
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/aefd80e8.failed

rndis_filter_device_add() is called both from netvsc_probe() when we
initially create the device and from set channels/mtu/ringparam
routines where we basically remove the device and add it back.

hw_features is reset in rndis_filter_device_add() and filled with
host data. However, we lose all additional flags which are set outside
of the driver, e.g. register_netdevice() adds NETIF_F_SOFT_FEATURES and
many others.

Unfortunately, calls to rndis_{query_hwcaps(), _set_offload_params()}
calls cannot be avoided on every RNDIS reset: host expects us to set
required features explicitly. Moreover, in theory hardware capabilities
can change and we need to reflect the change in hw_features.

Reset net->hw_features bits according to host data in
rndis_netdev_set_hwcaps(), clear corresponding feature bits
from net->features in case some features went missing (will never happen
in real life I guess but let's be consistent).

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit aefd80e874e98a864915df5b7d90824a4340b450)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/hyperv_net.h
#	drivers/net/hyperv/netvsc_drv.c
#	drivers/net/hyperv/rndis_filter.c
diff --cc drivers/net/hyperv/hyperv_net.h
index a32d7f1b2505,88ddfb92122b..000000000000
--- a/drivers/net/hyperv/hyperv_net.h
+++ b/drivers/net/hyperv/hyperv_net.h
@@@ -628,10 -646,13 +628,18 @@@ struct nvsp_message 
  #define NETVSC_RECEIVE_BUFFER_ID		0xcafe
  #define NETVSC_SEND_BUFFER_ID			0
  
++<<<<<<< HEAD
 +#define NETVSC_PACKET_SIZE                      4096
 +
 +#define VRSS_SEND_TAB_SIZE 16
++=======
+ #define NETVSC_SUPPORTED_HW_FEATURES (NETIF_F_RXCSUM | NETIF_F_IP_CSUM | \
+ 				      NETIF_F_TSO | NETIF_F_IPV6_CSUM | \
+ 				      NETIF_F_TSO6)
+ 
+ #define VRSS_SEND_TAB_SIZE 16  /* must be power of 2 */
++>>>>>>> aefd80e874e9 (hv_netvsc: preserve hw_features on mtu/channels/ringparam changes)
  #define VRSS_CHANNEL_MAX 64
 -#define VRSS_CHANNEL_DEFAULT 8
  
  #define RNDIS_MAX_PKT_DEFAULT 8
  #define RNDIS_PKT_ALIGN_DEFAULT 8
diff --cc drivers/net/hyperv/netvsc_drv.c
index 6db06d7e4863,5129647d420c..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -1534,20 -1996,35 +1534,37 @@@ static int netvsc_probe(struct hv_devic
  	/* Notify the netvsc driver of the new device */
  	memset(&device_info, 0, sizeof(device_info));
  	device_info.ring_size = ring_size;
 -	device_info.num_chn = VRSS_CHANNEL_DEFAULT;
 -	device_info.send_sections = NETVSC_DEFAULT_TX;
 -	device_info.send_section_size = NETVSC_SEND_SECTION_SIZE;
 -	device_info.recv_sections = NETVSC_DEFAULT_RX;
 -	device_info.recv_section_size = NETVSC_RECV_SECTION_SIZE;
 -
 -	nvdev = rndis_filter_device_add(dev, &device_info);
 -	if (IS_ERR(nvdev)) {
 -		ret = PTR_ERR(nvdev);
 +	device_info.max_num_vrss_chns = max_num_vrss_chns;
 +	ret = rndis_filter_device_add(dev, &device_info);
 +	if (ret != 0) {
  		netdev_err(net, "unable to add netvsc device (ret %d)\n", ret);
 -		goto rndis_failed;
 +		netvsc_free_netdev(net);
 +		hv_set_drvdata(dev, NULL);
 +		return ret;
  	}
 -
  	memcpy(net->dev_addr, device_info.mac_adr, ETH_ALEN);
  
++<<<<<<< HEAD
 +	nvdev = net_device_ctx->nvdev;
 +	netif_set_real_num_tx_queues(net, nvdev->num_chn);
 +	netif_set_real_num_rx_queues(net, nvdev->num_chn);
 +	netif_set_gso_max_size(net, NETVSC_GSO_MAX_SIZE);
++=======
+ 	/* hw_features computed in rndis_netdev_set_hwcaps() */
+ 	net->features = net->hw_features |
+ 		NETIF_F_HIGHDMA | NETIF_F_SG |
+ 		NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX;
+ 	net->vlan_features = net->features;
+ 
+ 	netdev_lockdep_set_classes(net);
+ 
+ 	/* MTU range: 68 - 1500 or 65521 */
+ 	net->min_mtu = NETVSC_MTU_MIN;
+ 	if (nvdev->nvsp_version >= NVSP_PROTOCOL_VERSION_2)
+ 		net->max_mtu = NETVSC_MTU - ETH_HLEN;
+ 	else
+ 		net->max_mtu = ETH_DATA_LEN;
++>>>>>>> aefd80e874e9 (hv_netvsc: preserve hw_features on mtu/channels/ringparam changes)
  
  	ret = register_netdev(net);
  	if (ret != 0) {
diff --cc drivers/net/hyperv/rndis_filter.c
index b6bc44dd1f92,7b637c7dd1e5..000000000000
--- a/drivers/net/hyperv/rndis_filter.c
+++ b/drivers/net/hyperv/rndis_filter.c
@@@ -925,110 -1037,242 +925,332 @@@ static void netvsc_sc_open(struct vmbus
  	 */
  	set_channel_read_mode(new_sc, HV_CALL_ISR);
  
 -	/* Set the channel before opening.*/
 -	nvchan->channel = new_sc;
 -
  	ret = vmbus_open(new_sc, nvscdev->ring_size * PAGE_SIZE,
  			 nvscdev->ring_size * PAGE_SIZE, NULL, 0,
 -			 netvsc_channel_cb, nvchan);
 +			 netvsc_channel_cb, new_sc);
 +
  	if (ret == 0)
 -		napi_enable(&nvchan->napi);
 -	else
 -		netdev_notice(ndev, "sub channel open failed: %d\n", ret);
 +		nvscdev->chn_table[chn_index] = new_sc;
  
 -	if (atomic_inc_return(&nvscdev->open_chn) == nvscdev->num_chn)
 -		wake_up(&nvscdev->subchan_open);
 +	spin_lock_irqsave(&nvscdev->sc_lock, flags);
 +	nvscdev->num_sc_offered--;
 +	spin_unlock_irqrestore(&nvscdev->sc_lock, flags);
 +	if (nvscdev->num_sc_offered == 0)
 +		complete(&nvscdev->channel_init_wait);
  }
  
++<<<<<<< HEAD
 +int rndis_filter_device_add(struct hv_device *dev,
 +			    void *additional_info)
++=======
+ /* Open sub-channels after completing the handling of the device probe.
+  * This breaks overlap of processing the host message for the
+  * new primary channel with the initialization of sub-channels.
+  */
+ void rndis_set_subchannel(struct work_struct *w)
  {
- 	struct net_device *net = hv_get_drvdata(dev);
+ 	struct netvsc_device *nvdev
+ 		= container_of(w, struct netvsc_device, subchan_work);
+ 	struct nvsp_message *init_packet = &nvdev->channel_init_pkt;
+ 	struct net_device_context *ndev_ctx;
+ 	struct rndis_device *rdev;
+ 	struct net_device *ndev;
+ 	struct hv_device *hv_dev;
+ 	int i, ret;
+ 
+ 	if (!rtnl_trylock()) {
+ 		schedule_work(w);
+ 		return;
+ 	}
+ 
+ 	rdev = nvdev->extension;
+ 	if (!rdev)
+ 		goto unlock;	/* device was removed */
+ 
+ 	ndev = rdev->ndev;
+ 	ndev_ctx = netdev_priv(ndev);
+ 	hv_dev = ndev_ctx->device_ctx;
+ 
+ 	memset(init_packet, 0, sizeof(struct nvsp_message));
+ 	init_packet->hdr.msg_type = NVSP_MSG5_TYPE_SUBCHANNEL;
+ 	init_packet->msg.v5_msg.subchn_req.op = NVSP_SUBCHANNEL_ALLOCATE;
+ 	init_packet->msg.v5_msg.subchn_req.num_subchannels =
+ 						nvdev->num_chn - 1;
+ 	ret = vmbus_sendpacket(hv_dev->channel, init_packet,
+ 			       sizeof(struct nvsp_message),
+ 			       (unsigned long)init_packet,
+ 			       VM_PKT_DATA_INBAND,
+ 			       VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);
+ 	if (ret) {
+ 		netdev_err(ndev, "sub channel allocate send failed: %d\n", ret);
+ 		goto failed;
+ 	}
+ 
+ 	wait_for_completion(&nvdev->channel_init_wait);
+ 	if (init_packet->msg.v5_msg.subchn_comp.status != NVSP_STAT_SUCCESS) {
+ 		netdev_err(ndev, "sub channel request failed\n");
+ 		goto failed;
+ 	}
+ 
+ 	nvdev->num_chn = 1 +
+ 		init_packet->msg.v5_msg.subchn_comp.num_subchannels;
+ 
+ 	/* wait for all sub channels to open */
+ 	wait_event(nvdev->subchan_open,
+ 		   atomic_read(&nvdev->open_chn) == nvdev->num_chn);
+ 
+ 	/* ignore failues from setting rss parameters, still have channels */
+ 	rndis_filter_set_rss_param(rdev, netvsc_hash_key);
+ 
+ 	netif_set_real_num_tx_queues(ndev, nvdev->num_chn);
+ 	netif_set_real_num_rx_queues(ndev, nvdev->num_chn);
+ 
+ 	for (i = 0; i < VRSS_SEND_TAB_SIZE; i++)
+ 		ndev_ctx->tx_table[i] = i % nvdev->num_chn;
+ 
+ 	rtnl_unlock();
+ 	return;
+ 
+ failed:
+ 	/* fallback to only primary channel */
+ 	for (i = 1; i < nvdev->num_chn; i++)
+ 		netif_napi_del(&nvdev->chan_table[i].napi);
+ 
+ 	nvdev->max_chn = 1;
+ 	nvdev->num_chn = 1;
+ unlock:
+ 	rtnl_unlock();
+ }
+ 
+ static int rndis_netdev_set_hwcaps(struct rndis_device *rndis_device,
+ 				   struct netvsc_device *nvdev)
++>>>>>>> aefd80e874e9 (hv_netvsc: preserve hw_features on mtu/channels/ringparam changes)
+ {
+ 	struct net_device *net = rndis_device->ndev;
  	struct net_device_context *net_device_ctx = netdev_priv(net);
++<<<<<<< HEAD
 +	struct netvsc_device *net_device;
 +	struct rndis_device *rndis_device;
 +	struct netvsc_device_info *device_info = additional_info;
 +	struct ndis_offload_params offloads;
 +	struct nvsp_message *init_packet;
 +	struct ndis_recv_scale_cap rsscap;
 +	u32 rsscap_size = sizeof(struct ndis_recv_scale_cap);
 +	u32 mtu, size;
 +	u32 num_rss_qs;
 +	u32 sc_delta;
 +	const struct cpumask *node_cpu_mask;
 +	u32 num_possible_rss_qs;
 +	unsigned long flags;
 +	int i, ret;
 +
 +	rndis_device = get_rndis_device();
 +	if (!rndis_device)
 +		return -ENODEV;
 +
 +	/*
 +	 * Let the inner driver handle this first to create the netvsc channel
 +	 * NOTE! Once the channel is created, we may get a receive callback
 +	 * (RndisFilterOnReceive()) before this call is completed
 +	 */
 +	ret = netvsc_device_add(dev, additional_info);
 +	if (ret != 0) {
 +		kfree(rndis_device);
 +		return ret;
 +	}
 +
 +	/* Initialize the rndis device */
 +	net_device = net_device_ctx->nvdev;
 +	net_device->max_chn = 1;
 +	net_device->num_chn = 1;
 +
 +	spin_lock_init(&net_device->sc_lock);
 +
 +	net_device->extension = rndis_device;
 +	rndis_device->ndev = net;
 +
 +	/* Send the rndis initialization message */
 +	ret = rndis_filter_init_device(rndis_device);
 +	if (ret != 0) {
 +		rndis_filter_device_remove(dev);
 +		return ret;
 +	}
 +
 +	/* Get the MTU from the host */
 +	size = sizeof(u32);
 +	ret = rndis_filter_query_device(rndis_device,
 +					RNDIS_OID_GEN_MAXIMUM_FRAME_SIZE,
 +					&mtu, &size);
 +	if (ret == 0 && size == sizeof(u32) && mtu < net->mtu)
 +		net->mtu = mtu;
 +
 +	/* Get the mac address */
 +	ret = rndis_filter_query_device_mac(rndis_device);
 +	if (ret != 0) {
 +		rndis_filter_device_remove(dev);
 +		return ret;
 +	}
 +
 +	memcpy(device_info->mac_adr, rndis_device->hw_mac_adr, ETH_ALEN);
 +
 +	/* Turn on the offloads; the host supports all of the relevant
 +	 * offloads.
 +	 */
++=======
+ 	struct ndis_offload hwcaps;
+ 	struct ndis_offload_params offloads;
+ 	unsigned int gso_max_size = GSO_MAX_SIZE;
+ 	int ret;
+ 
+ 	/* Find HW offload capabilities */
+ 	ret = rndis_query_hwcaps(rndis_device, nvdev, &hwcaps);
+ 	if (ret != 0)
+ 		return ret;
+ 
+ 	/* A value of zero means "no change"; now turn on what we want. */
++>>>>>>> aefd80e874e9 (hv_netvsc: preserve hw_features on mtu/channels/ringparam changes)
  	memset(&offloads, 0, sizeof(struct ndis_offload_params));
 -
 +	/* A value of zero means "no change"; now turn on what we
 +	 * want.
 +	 */
 +	offloads.ip_v4_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;
 +	offloads.tcp_ip_v4_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;
 +	offloads.udp_ip_v4_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;
 +	offloads.tcp_ip_v6_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;
 +	offloads.udp_ip_v6_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;
 +	offloads.lso_v2_ipv4 = NDIS_OFFLOAD_PARAMETERS_LSOV2_ENABLED;
 +
++<<<<<<< HEAD
 +	ret = rndis_filter_set_offload_params(net, &offloads);
 +	if (ret)
++=======
+ 	/* Linux does not care about IP checksum, always does in kernel */
+ 	offloads.ip_v4_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_DISABLED;
+ 
+ 	/* Reset previously set hw_features flags */
+ 	net->hw_features &= ~NETVSC_SUPPORTED_HW_FEATURES;
+ 	net_device_ctx->tx_checksum_mask = 0;
+ 
+ 	/* Compute tx offload settings based on hw capabilities */
+ 	net->hw_features |= NETIF_F_RXCSUM;
+ 
+ 	if ((hwcaps.csum.ip4_txcsum & NDIS_TXCSUM_ALL_TCP4) == NDIS_TXCSUM_ALL_TCP4) {
+ 		/* Can checksum TCP */
+ 		net->hw_features |= NETIF_F_IP_CSUM;
+ 		net_device_ctx->tx_checksum_mask |= TRANSPORT_INFO_IPV4_TCP;
+ 
+ 		offloads.tcp_ip_v4_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;
+ 
+ 		if (hwcaps.lsov2.ip4_encap & NDIS_OFFLOAD_ENCAP_8023) {
+ 			offloads.lso_v2_ipv4 = NDIS_OFFLOAD_PARAMETERS_LSOV2_ENABLED;
+ 			net->hw_features |= NETIF_F_TSO;
+ 
+ 			if (hwcaps.lsov2.ip4_maxsz < gso_max_size)
+ 				gso_max_size = hwcaps.lsov2.ip4_maxsz;
+ 		}
+ 
+ 		if (hwcaps.csum.ip4_txcsum & NDIS_TXCSUM_CAP_UDP4) {
+ 			offloads.udp_ip_v4_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;
+ 			net_device_ctx->tx_checksum_mask |= TRANSPORT_INFO_IPV4_UDP;
+ 		}
+ 	}
+ 
+ 	if ((hwcaps.csum.ip6_txcsum & NDIS_TXCSUM_ALL_TCP6) == NDIS_TXCSUM_ALL_TCP6) {
+ 		net->hw_features |= NETIF_F_IPV6_CSUM;
+ 
+ 		offloads.tcp_ip_v6_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;
+ 		net_device_ctx->tx_checksum_mask |= TRANSPORT_INFO_IPV6_TCP;
+ 
+ 		if ((hwcaps.lsov2.ip6_encap & NDIS_OFFLOAD_ENCAP_8023) &&
+ 		    (hwcaps.lsov2.ip6_opts & NDIS_LSOV2_CAP_IP6) == NDIS_LSOV2_CAP_IP6) {
+ 			offloads.lso_v2_ipv6 = NDIS_OFFLOAD_PARAMETERS_LSOV2_ENABLED;
+ 			net->hw_features |= NETIF_F_TSO6;
+ 
+ 			if (hwcaps.lsov2.ip6_maxsz < gso_max_size)
+ 				gso_max_size = hwcaps.lsov2.ip6_maxsz;
+ 		}
+ 
+ 		if (hwcaps.csum.ip6_txcsum & NDIS_TXCSUM_CAP_UDP6) {
+ 			offloads.udp_ip_v6_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;
+ 			net_device_ctx->tx_checksum_mask |= TRANSPORT_INFO_IPV6_UDP;
+ 		}
+ 	}
+ 
+ 	/* In case some hw_features disappeared we need to remove them from
+ 	 * net->features list as they're no longer supported.
+ 	 */
+ 	net->features &= ~NETVSC_SUPPORTED_HW_FEATURES | net->hw_features;
+ 
+ 	netif_set_gso_max_size(net, gso_max_size);
+ 
+ 	ret = rndis_filter_set_offload_params(net, nvdev, &offloads);
+ 
+ 	return ret;
+ }
+ 
+ struct netvsc_device *rndis_filter_device_add(struct hv_device *dev,
+ 				      struct netvsc_device_info *device_info)
+ {
+ 	struct net_device *net = hv_get_drvdata(dev);
+ 	struct netvsc_device *net_device;
+ 	struct rndis_device *rndis_device;
+ 	struct ndis_recv_scale_cap rsscap;
+ 	u32 rsscap_size = sizeof(struct ndis_recv_scale_cap);
+ 	u32 mtu, size;
+ 	const struct cpumask *node_cpu_mask;
+ 	u32 num_possible_rss_qs;
+ 	int i, ret;
+ 
+ 	rndis_device = get_rndis_device();
+ 	if (!rndis_device)
+ 		return ERR_PTR(-ENODEV);
+ 
+ 	/* Let the inner driver handle this first to create the netvsc channel
+ 	 * NOTE! Once the channel is created, we may get a receive callback
+ 	 * (RndisFilterOnReceive()) before this call is completed
+ 	 */
+ 	net_device = netvsc_device_add(dev, device_info);
+ 	if (IS_ERR(net_device)) {
+ 		kfree(rndis_device);
+ 		return net_device;
+ 	}
+ 
+ 	/* Initialize the rndis device */
+ 	net_device->max_chn = 1;
+ 	net_device->num_chn = 1;
+ 
+ 	net_device->extension = rndis_device;
+ 	rndis_device->ndev = net;
+ 
+ 	/* Send the rndis initialization message */
+ 	ret = rndis_filter_init_device(rndis_device, net_device);
+ 	if (ret != 0)
+ 		goto err_dev_remv;
+ 
+ 	/* Get the MTU from the host */
+ 	size = sizeof(u32);
+ 	ret = rndis_filter_query_device(rndis_device, net_device,
+ 					RNDIS_OID_GEN_MAXIMUM_FRAME_SIZE,
+ 					&mtu, &size);
+ 	if (ret == 0 && size == sizeof(u32) && mtu < net->mtu)
+ 		net->mtu = mtu;
+ 
+ 	/* Get the mac address */
+ 	ret = rndis_filter_query_device_mac(rndis_device, net_device);
+ 	if (ret != 0)
+ 		goto err_dev_remv;
+ 
+ 	memcpy(device_info->mac_adr, rndis_device->hw_mac_adr, ETH_ALEN);
+ 
+ 	/* Query and set hardware capabilities */
+ 	ret = rndis_netdev_set_hwcaps(rndis_device, net_device);
+ 	if (ret != 0)
++>>>>>>> aefd80e874e9 (hv_netvsc: preserve hw_features on mtu/channels/ringparam changes)
  		goto err_dev_remv;
  
 -	rndis_filter_query_device_link_status(rndis_device, net_device);
 +	rndis_filter_query_device_link_status(rndis_device);
 +
 +	device_info->link_state = rndis_device->link_state;
  
  	netdev_dbg(net, "Device MAC %pM link state %s\n",
  		   rndis_device->hw_mac_adr,
* Unmerged path drivers/net/hyperv/hyperv_net.h
* Unmerged path drivers/net/hyperv/netvsc_drv.c
* Unmerged path drivers/net/hyperv/rndis_filter.c
