nfp: add nfp_net_pf_free_vnic() function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 9140b30d318520e6d7dfe3b48aa62e6a7336b510
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9140b30d.failed

Soon a third place will need to free a struct nfp_net.  Add a free
counterpart to nfp_net_pf_alloc_vnic().

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Simon Horman <simon.horman@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9140b30d318520e6d7dfe3b48aa62e6a7336b510)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net_main.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_main.c
index acc8cfe284f3,5f0c58a56182..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
@@@ -268,15 -268,20 +268,32 @@@ static u8 __iomem *nfp_net_pf_map_ctrl_
  	return ctrl_bar;
  }
  
++<<<<<<< HEAD
 +static void nfp_net_pf_free_netdevs(struct nfp_pf *pf)
 +{
 +	struct nfp_net *nn;
 +
 +	while (!list_empty(&pf->ports)) {
 +		nn = list_first_entry(&pf->ports, struct nfp_net, port_list);
 +		list_del(&nn->port_list);
 +
 +		nfp_net_netdev_free(nn);
++=======
+ static void nfp_net_pf_free_vnic(struct nfp_pf *pf, struct nfp_net *nn)
+ {
+ 	list_del(&nn->vnic_list);
+ 	pf->num_vnics--;
+ 	nfp_net_free(nn);
+ }
+ 
+ static void nfp_net_pf_free_vnics(struct nfp_pf *pf)
+ {
+ 	struct nfp_net *nn;
+ 
+ 	while (!list_empty(&pf->vnics)) {
+ 		nn = list_first_entry(&pf->vnics, struct nfp_net, vnic_list);
+ 		nfp_net_pf_free_vnic(pf, nn);
++>>>>>>> 9140b30d3185 (nfp: add nfp_net_pf_free_vnic() function)
  	}
  }
  
@@@ -482,44 -520,47 +499,48 @@@ static void nfp_net_refresh_netdevs(str
  		nn_warn(nn, "Port config changed, unregistering. Reboot required before port will be operational again.\n");
  
  		nfp_net_debugfs_dir_clean(&nn->debugfs_dir);
 -		nfp_net_clean(nn);
 +		nfp_net_netdev_clean(nn->dp.netdev);
  
++<<<<<<< HEAD
 +		list_del(&nn->port_list);
 +		pf->num_netdevs--;
 +		nfp_net_netdev_free(nn);
++=======
+ 		nfp_net_pf_free_vnic(pf, nn);
++>>>>>>> 9140b30d3185 (nfp: add nfp_net_pf_free_vnic() function)
  	}
  
 -	if (list_empty(&pf->vnics))
 +	if (list_empty(&pf->ports))
  		nfp_net_pci_remove_finish(pf);
  out:
 -	mutex_unlock(&pf->lock);
 +	mutex_unlock(&pf->port_lock);
  }
  
 -void nfp_net_refresh_port_table(struct nfp_net *nn)
 +void nfp_net_refresh_port_config(struct nfp_net *nn)
  {
  	struct nfp_pf *pf = pci_get_drvdata(nn->pdev);
 +	struct nfp_eth_table *old_table;
  
 -	schedule_work(&pf->port_refresh_work);
 -}
 +	ASSERT_RTNL();
  
 -int nfp_net_refresh_eth_port(struct nfp_net *nn)
 -{
 -	struct nfp_eth_table_port *eth_port;
 -	struct nfp_eth_table *eth_table;
 +	old_table = pf->eth_tbl;
  
 -	eth_table = nfp_eth_read_ports(nn->cpp);
 -	if (!eth_table) {
 -		nn_err(nn, "Error refreshing port state table!\n");
 -		return -EIO;
 -	}
 +	list_for_each_entry(nn, &pf->ports, port_list)
 +		nfp_net_link_changed_read_clear(nn);
  
 -	eth_port = nfp_net_find_port(eth_table, nn->eth_port->eth_index);
 -	if (!eth_port) {
 -		nn_err(nn, "Error finding state of the port!\n");
 -		kfree(eth_table);
 -		return -EIO;
 +	pf->eth_tbl = nfp_eth_read_ports(pf->cpp);
 +	if (!pf->eth_tbl) {
 +		pf->eth_tbl = old_table;
 +		nfp_err(pf->cpp, "Error refreshing port config!\n");
 +		return;
  	}
  
 -	memcpy(nn->eth_port, eth_port, sizeof(*eth_port));
 +	list_for_each_entry(nn, &pf->ports, port_list)
 +		nn->eth_port = nfp_net_find_port(pf, nn->eth_port->eth_index);
  
 -	kfree(eth_table);
 +	kfree(old_table);
  
 -	return 0;
 +	schedule_work(&pf->port_refresh_work);
  }
  
  /*
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_main.c
