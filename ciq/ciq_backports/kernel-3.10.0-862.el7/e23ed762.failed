netfilter: ipset: pernet ops must be unregistered last

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Florian Westphal <fw@strlen.de>
commit e23ed762db7ed1950a6408c3be80bc56909ab3d4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e23ed762.failed

Removing the ipset module leaves a small window where one cpu performs
module removal while another runs a command like 'ipset flush'.

ipset uses net_generic(), unregistering the pernet ops frees this
storage area.

Fix it by first removing the user-visible api handlers and the pernet
ops last.

Fixes: 1785e8f473082 ("netfiler: ipset: Add net namespace for ipset")
	Reported-by: Li Shuang <shuali@redhat.com>
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Acked-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit e23ed762db7ed1950a6408c3be80bc56909ab3d4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipset/ip_set_core.c
diff --cc net/netfilter/ipset/ip_set_core.c
index 98b197a78f1a,a7f049ff3049..000000000000
--- a/net/netfilter/ipset/ip_set_core.c
+++ b/net/netfilter/ipset/ip_set_core.c
@@@ -1801,49 -2023,88 +1801,79 @@@ static struct nf_sockopt_ops so_set __r
  	.owner		= THIS_MODULE,
  };
  
 -static int __net_init
 -ip_set_net_init(struct net *net)
 +static int __init
 +ip_set_init(void)
  {
 -	struct ip_set_net *inst = ip_set_pernet(net);
++<<<<<<< HEAD
  	struct ip_set **list;
 +	int ret;
  
 -	inst->ip_set_max = max_sets ? max_sets : CONFIG_IP_SET_MAX;
 -	if (inst->ip_set_max >= IPSET_INVALID_ID)
 -		inst->ip_set_max = IPSET_INVALID_ID - 1;
 +	if (max_sets)
 +		ip_set_max = max_sets;
 +	if (ip_set_max >= IPSET_INVALID_ID)
 +		ip_set_max = IPSET_INVALID_ID - 1;
  
 -	list = kcalloc(inst->ip_set_max, sizeof(struct ip_set *), GFP_KERNEL);
 +	list = kzalloc(sizeof(struct ip_set *) * ip_set_max, GFP_KERNEL);
  	if (!list)
  		return -ENOMEM;
 -	inst->is_deleted = false;
 -	inst->is_destroyed = false;
 -	rcu_assign_pointer(inst->ip_set_list, list);
 -	return 0;
 -}
 -
 -static void __net_exit
 -ip_set_net_exit(struct net *net)
 -{
 -	struct ip_set_net *inst = ip_set_pernet(net);
 -
 -	struct ip_set *set = NULL;
 -	ip_set_id_t i;
 -
 -	inst->is_deleted = true; /* flag for ip_set_nfnl_put */
  
 -	for (i = 0; i < inst->ip_set_max; i++) {
 -		set = ip_set(inst, i);
 -		if (set) {
 -			ip_set(inst, i) = NULL;
 -			ip_set_destroy_set(set);
 -		}
 -	}
 -	kfree(rcu_dereference_protected(inst->ip_set_list, 1));
 -}
 -
 -static struct pernet_operations ip_set_net_ops = {
 -	.init	= ip_set_net_init,
 -	.exit   = ip_set_net_exit,
 -	.id	= &ip_set_net_id,
 -	.size	= sizeof(struct ip_set_net)
 -};
 -
 -static int __init
 -ip_set_init(void)
 -{
 +	rcu_assign_pointer(ip_set_list, list);
 +	ret = nfnetlink_subsys_register(&ip_set_netlink_subsys);
 +	if (ret != 0) {
 +		pr_err("ip_set: cannot register with nfnetlink.\n");
 +		kfree(list);
++=======
+ 	int ret = register_pernet_subsys(&ip_set_net_ops);
+ 
+ 	if (ret) {
+ 		pr_err("ip_set: cannot register pernet_subsys.\n");
++>>>>>>> e23ed762db7e (netfilter: ipset: pernet ops must be unregistered last)
+ 		return ret;
+ 	}
+ 
+ 	ret = nfnetlink_subsys_register(&ip_set_netlink_subsys);
+ 	if (ret != 0) {
+ 		pr_err("ip_set: cannot register with nfnetlink.\n");
+ 		unregister_pernet_subsys(&ip_set_net_ops);
  		return ret;
  	}
+ 
  	ret = nf_register_sockopt(&so_set);
  	if (ret != 0) {
  		pr_err("SO_SET registry failed: %d\n", ret);
  		nfnetlink_subsys_unregister(&ip_set_netlink_subsys);
++<<<<<<< HEAD
 +		kfree(list);
 +		return ret;
 +	}
 +
 +	pr_notice("ip_set: protocol %u\n", IPSET_PROTOCOL);
++=======
+ 		unregister_pernet_subsys(&ip_set_net_ops);
+ 		return ret;
+ 	}
+ 
+ 	pr_info("ip_set: protocol %u\n", IPSET_PROTOCOL);
++>>>>>>> e23ed762db7e (netfilter: ipset: pernet ops must be unregistered last)
  	return 0;
  }
  
  static void __exit
  ip_set_fini(void)
  {
++<<<<<<< HEAD
 +	struct ip_set **list = rcu_dereference_protected(ip_set_list, 1);
 +
 +	/* There can't be any existing set */
 +	nf_unregister_sockopt(&so_set);
 +	nfnetlink_subsys_unregister(&ip_set_netlink_subsys);
 +	kfree(list);
++=======
+ 	nf_unregister_sockopt(&so_set);
+ 	nfnetlink_subsys_unregister(&ip_set_netlink_subsys);
+ 
+ 	unregister_pernet_subsys(&ip_set_net_ops);
++>>>>>>> e23ed762db7e (netfilter: ipset: pernet ops must be unregistered last)
  	pr_debug("these are the famous last words\n");
  }
  
* Unmerged path net/netfilter/ipset/ip_set_core.c
