VSOCK: Don't set sk_state to TCP_CLOSE before testing it

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jorgen Hansen <jhansen@vmware.com>
commit 4a5def7f6a758aef1a0a3b10e981881c1e914f69
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4a5def7f.failed

A recent commit (3b4477d2dcf2) converted the sk_state to use
TCP constants. In that change, vmci_transport_handle_detach
was changed such that sk->sk_state was set to TCP_CLOSE before
we test whether it is TCP_SYN_SENT. This change moves the
sk_state change back to the original locations in that function.

	Signed-off-by: Jorgen Hansen <jhansen@vmware.com>
	Reviewed-by: Stefan Hajnoczi <stefanha@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4a5def7f6a758aef1a0a3b10e981881c1e914f69)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/vmw_vsock/vmci_transport.c
diff --cc net/vmw_vsock/vmci_transport.c
index e2a5d25d192d,a7a73ffe675b..000000000000
--- a/net/vmw_vsock/vmci_transport.c
+++ b/net/vmw_vsock/vmci_transport.c
@@@ -805,10 -797,14 +805,16 @@@ static void vmci_transport_handle_detac
  
  		/* We should not be sending anymore since the peer won't be
  		 * there to receive, but we can still receive if there is data
 -		 * left in our consume queue. If the local endpoint is a host,
 -		 * we can't call vsock_stream_has_data, since that may block,
 -		 * but a host endpoint can't read data once the VM has
 -		 * detached, so there is no available data in that case.
 +		 * left in our consume queue.
  		 */
++<<<<<<< HEAD
 +		if (vsock_stream_has_data(vsk) <= 0) {
 +			if (sk->sk_state == SS_CONNECTING) {
++=======
+ 		if (vsk->local_addr.svm_cid == VMADDR_CID_HOST ||
+ 		    vsock_stream_has_data(vsk) <= 0) {
+ 			if (sk->sk_state == TCP_SYN_SENT) {
++>>>>>>> 4a5def7f6a75 (VSOCK: Don't set sk_state to TCP_CLOSE before testing it)
  				/* The peer may detach from a queue pair while
  				 * we are still in the connecting state, i.e.,
  				 * if the peer VM is killed after attaching to
@@@ -817,12 -813,12 +823,20 @@@
  				 * event like a reset.
  				 */
  
++<<<<<<< HEAD
 +				sk->sk_state = SS_UNCONNECTED;
++=======
+ 				sk->sk_state = TCP_CLOSE;
++>>>>>>> 4a5def7f6a75 (VSOCK: Don't set sk_state to TCP_CLOSE before testing it)
  				sk->sk_err = ECONNRESET;
  				sk->sk_error_report(sk);
  				return;
  			}
++<<<<<<< HEAD
 +			sk->sk_state = SS_UNCONNECTED;
++=======
+ 			sk->sk_state = TCP_CLOSE;
++>>>>>>> 4a5def7f6a75 (VSOCK: Don't set sk_state to TCP_CLOSE before testing it)
  		}
  		sk->sk_state_change(sk);
  	}
* Unmerged path net/vmw_vsock/vmci_transport.c
