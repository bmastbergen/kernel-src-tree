geneve: fix ip_hdr_len reserved for geneve6 tunnel.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] geneve: fix ip_hdr_len reserved for geneve6 tunnel (Jakub Sitnicki) [1467288]
Rebuild_FUZZ: 99.01%
commit-author Haishuang Yan <yanhaishuang@cmss.chinamobile.com>
commit 31ac1c19455f8aee1872512d62be1f41a497cde0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/31ac1c19.failed

It shold reserved sizeof(ipv6hdr) for geneve in ipv6 tunnel.

Fixes: c3ef5aa5e5 ('geneve: Merge ipv4 and ipv6 geneve_build_skb()')
	Signed-off-by: Haishuang Yan <yanhaishuang@cmss.chinamobile.com>
	Acked-by: Pravin B Shelar <pshelar@ovn.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 31ac1c19455f8aee1872512d62be1f41a497cde0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/geneve.c
diff --cc drivers/net/geneve.c
index c4c93ccffa85,45301cb98bc1..000000000000
--- a/drivers/net/geneve.c
+++ b/drivers/net/geneve.c
@@@ -865,11 -798,82 +865,52 @@@ static netdev_tx_t geneve_xmit_skb(stru
  	__u8 tos, ttl;
  	__be16 sport;
  	__be16 df;
 -	int err;
 -
 -	rt = geneve_get_v4_rt(skb, dev, &fl4, info);
 -	if (IS_ERR(rt))
 -		return PTR_ERR(rt);
 -
 -	sport = udp_flow_src_port(geneve->net, skb, 1, USHRT_MAX, true);
 -	if (geneve->collect_md) {
 -		tos = ip_tunnel_ecn_encap(key->tos, ip_hdr(skb), skb);
 -		ttl = key->ttl;
 -	} else {
 -		tos = ip_tunnel_ecn_encap(fl4.flowi4_tos, ip_hdr(skb), skb);
 -		ttl = key->ttl ? : ip4_dst_hoplimit(&rt->dst);
 -	}
 -	df = key->tun_flags & TUNNEL_DONT_FRAGMENT ? htons(IP_DF) : 0;
 -
 -	err = geneve_build_skb(&rt->dst, skb, info, xnet, sizeof(struct iphdr));
 -	if (unlikely(err))
 -		return err;
 -
 -	udp_tunnel_xmit_skb(rt, gs4->sock->sk, skb, fl4.saddr, fl4.daddr,
 -			    tos, ttl, df, sport, geneve->info.key.tp_dst,
 -			    !net_eq(geneve->net, dev_net(geneve->dev)),
 -			    !(info->key.tun_flags & TUNNEL_CSUM));
 -	return 0;
 -}
 -
 -#if IS_ENABLED(CONFIG_IPV6)
 -static int geneve6_xmit_skb(struct sk_buff *skb, struct net_device *dev,
 -			    struct geneve_dev *geneve,
 -			    const struct ip_tunnel_info *info)
 -{
  	bool xnet = !net_eq(geneve->net, dev_net(geneve->dev));
++<<<<<<< HEAD
 +	u32 flags = geneve->flags;
++=======
+ 	struct geneve_sock *gs6 = rcu_dereference(geneve->sock6);
+ 	const struct ip_tunnel_key *key = &info->key;
+ 	struct dst_entry *dst = NULL;
+ 	struct flowi6 fl6;
+ 	__u8 prio, ttl;
+ 	__be16 sport;
+ 	int err;
+ 
+ 	dst = geneve_get_v6_dst(skb, dev, &fl6, info);
+ 	if (IS_ERR(dst))
+ 		return PTR_ERR(dst);
+ 
+ 	sport = udp_flow_src_port(geneve->net, skb, 1, USHRT_MAX, true);
+ 	if (geneve->collect_md) {
+ 		prio = ip_tunnel_ecn_encap(key->tos, ip_hdr(skb), skb);
+ 		ttl = key->ttl;
+ 	} else {
+ 		prio = ip_tunnel_ecn_encap(ip6_tclass(fl6.flowlabel),
+ 					   ip_hdr(skb), skb);
+ 		ttl = key->ttl ? : ip6_dst_hoplimit(dst);
+ 	}
+ 	err = geneve_build_skb(dst, skb, info, xnet, sizeof(struct ipv6hdr));
+ 	if (unlikely(err))
+ 		return err;
+ 
+ 	udp_tunnel6_xmit_skb(dst, gs6->sock->sk, skb, dev,
+ 			     &fl6.saddr, &fl6.daddr, prio, ttl,
+ 			     info->key.label, sport, geneve->info.key.tp_dst,
+ 			     !(info->key.tun_flags & TUNNEL_CSUM));
+ 	return 0;
+ }
+ #endif
+ 
+ static netdev_tx_t geneve_xmit(struct sk_buff *skb, struct net_device *dev)
+ {
+ 	struct geneve_dev *geneve = netdev_priv(dev);
+ 	struct ip_tunnel_info *info = NULL;
+ 	int err;
++>>>>>>> 31ac1c19455f (geneve: fix ip_hdr_len reserved for geneve6 tunnel.)
  
  	if (geneve->collect_md) {
 -		info = skb_tunnel_info(skb);
  		if (unlikely(!info || !(info->mode & IP_TUNNEL_INFO_TX))) {
 -			err = -EINVAL;
  			netdev_dbg(dev, "no tunnel metadata\n");
  			goto tx_error;
  		}
* Unmerged path drivers/net/geneve.c
