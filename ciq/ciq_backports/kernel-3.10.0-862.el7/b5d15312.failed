scsi: qla2xxx: Fix slow mem alloc behind lock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Fix slow mem alloc behind lock (Himanshu Madhani) [1460030]
Rebuild_FUZZ: 92.86%
commit-author Quinn Tran <quinn.tran@qlogic.com>
commit b5d1531260b9e5819edcaed8b549859e582e4ca4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b5d15312.failed

Call Trace:
 [<ffffffff81341687>] dump_stack+0x6b/0xa4
 [<ffffffff810c3e30>] ? print_irqtrace_events+0xd0/0xe0
 [<ffffffff8109e3c3>] ___might_sleep+0x183/0x240
 [<ffffffff8109e4d2>] __might_sleep+0x52/0x90
 [<ffffffff811fe17b>] kmem_cache_alloc_trace+0x5b/0x300
 [<ffffffff810c666b>] ? __lock_acquired+0x30b/0x420
 [<ffffffffa0733c28>] qla2x00_alloc_fcport+0x38/0x2a0 [qla2xxx]
 [<ffffffffa07217f4>] ? qla2x00_do_work+0x34/0x2b0 [qla2xxx]
 [<ffffffff816cc82b>] ? _raw_spin_lock_irqsave+0x7b/0x90
 [<ffffffffa072169a>] ? qla24xx_create_new_sess+0x3a/0x160 [qla2xxx]
 [<ffffffffa0721723>] qla24xx_create_new_sess+0xc3/0x160 [qla2xxx]
 [<ffffffff810c91ed>] ? trace_hardirqs_on+0xd/0x10
 [<ffffffffa07218f8>] qla2x00_do_work+0x138/0x2b0 [qla2xxx]

	Signed-off-by: Quinn Tran <quinn.tran@qlogic.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit b5d1531260b9e5819edcaed8b549859e582e4ca4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_os.c
#	drivers/scsi/qla2xxx/qla_target.c
diff --cc drivers/scsi/qla2xxx/qla_os.c
index c724f888aca6,5b2437a5ea44..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -4277,6 -4661,98 +4277,101 @@@ qlafx00_post_aenfx_work(struct scsi_qla
  	return qla2x00_post_work(vha, e);
  }
  
++<<<<<<< HEAD
++=======
+ int qla24xx_post_upd_fcport_work(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	struct qla_work_evt *e;
+ 
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_UPD_FCPORT);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.fcport.fcport = fcport;
+ 	return qla2x00_post_work(vha, e);
+ }
+ 
+ static
+ void qla24xx_create_new_sess(struct scsi_qla_host *vha, struct qla_work_evt *e)
+ {
+ 	unsigned long flags;
+ 	fc_port_t *fcport =  NULL, *tfcp;
+ 	struct qlt_plogi_ack_t *pla =
+ 	    (struct qlt_plogi_ack_t *)e->u.new_sess.pla;
+ 	uint8_t free_fcport = 0;
+ 
+ 	spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
+ 	fcport = qla2x00_find_fcport_by_wwpn(vha, e->u.new_sess.port_name, 1);
+ 	if (fcport) {
+ 		fcport->d_id = e->u.new_sess.id;
+ 		if (pla) {
+ 			fcport->fw_login_state = DSC_LS_PLOGI_PEND;
+ 			qlt_plogi_ack_link(vha, pla, fcport, QLT_PLOGI_LINK_SAME_WWN);
+ 			/* we took an extra ref_count to prevent PLOGI ACK when
+ 			 * fcport/sess has not been created.
+ 			 */
+ 			pla->ref_count--;
+ 		}
+ 	} else {
+ 		spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ 		fcport = qla2x00_alloc_fcport(vha, GFP_KERNEL);
+ 		if (fcport) {
+ 			fcport->d_id = e->u.new_sess.id;
+ 			fcport->scan_state = QLA_FCPORT_FOUND;
+ 			fcport->flags |= FCF_FABRIC_DEVICE;
+ 			fcport->fw_login_state = DSC_LS_PLOGI_PEND;
+ 
+ 			memcpy(fcport->port_name, e->u.new_sess.port_name,
+ 			    WWN_SIZE);
+ 		} else {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 				   "%s %8phC mem alloc fail.\n",
+ 				   __func__, e->u.new_sess.port_name);
+ 
+ 			if (pla)
+ 				kmem_cache_free(qla_tgt_plogi_cachep, pla);
+ 			return;
+ 		}
+ 
+ 		spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
+ 		/* search again to make sure one else got ahead */
+ 		tfcp = qla2x00_find_fcport_by_wwpn(vha,
+ 		    e->u.new_sess.port_name, 1);
+ 		if (tfcp) {
+ 			/* should rarily happen */
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			    "%s %8phC found existing fcport b4 add. DS %d LS %d\n",
+ 			    __func__, tfcp->port_name, tfcp->disc_state,
+ 			    tfcp->fw_login_state);
+ 
+ 			free_fcport = 1;
+ 		} else {
+ 			list_add_tail(&fcport->list, &vha->vp_fcports);
+ 
+ 			if (pla) {
+ 				qlt_plogi_ack_link(vha, pla, fcport,
+ 				    QLT_PLOGI_LINK_SAME_WWN);
+ 				pla->ref_count--;
+ 			}
+ 		}
+ 	}
+ 	spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ 
+ 	if (fcport) {
+ 		if (pla)
+ 			qlt_plogi_ack_unref(vha, pla);
+ 		else
+ 			qla24xx_async_gnl(vha, fcport);
+ 	}
+ 
+ 	if (free_fcport) {
+ 		qla2x00_free_fcport(fcport);
+ 		if (pla)
+ 			kmem_cache_free(qla_tgt_plogi_cachep, pla);
+ 	}
+ }
+ 
++>>>>>>> b5d1531260b9 (scsi: qla2xxx: Fix slow mem alloc behind lock)
  void
  qla2x00_do_work(struct scsi_qla_host *vha)
  {
diff --cc drivers/scsi/qla2xxx/qla_target.c
index 4244f37d5d93,192554b1536f..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -104,8 -144,8 +104,12 @@@ static void qlt_reject_free_srr_imm(str
  /*
   * Global Variables
   */
 +static struct kmem_cache *qla_tgt_cmd_cachep;
  static struct kmem_cache *qla_tgt_mgmt_cmd_cachep;
++<<<<<<< HEAD
++=======
+ struct kmem_cache *qla_tgt_plogi_cachep;
++>>>>>>> b5d1531260b9 (scsi: qla2xxx: Fix slow mem alloc behind lock)
  static mempool_t *qla_tgt_mgmt_cmd_mempool;
  static struct workqueue_struct *qla_tgt_wq;
  static DEFINE_MUTEX(qla_tgt_mutex);
diff --git a/drivers/scsi/qla2xxx/qla_gbl.h b/drivers/scsi/qla2xxx/qla_gbl.h
index c4f068539cd6..8908e6b92430 100644
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@ -98,6 +98,7 @@ extern int qla2xxx_delete_qpair(struct scsi_qla_host *, struct qla_qpair *);
 extern char qla2x00_version_str[];
 
 extern struct kmem_cache *srb_cachep;
+extern struct kmem_cache *qla_tgt_plogi_cachep;
 
 extern int ql2xlogintimeout;
 extern int qlport_down_retry;
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
