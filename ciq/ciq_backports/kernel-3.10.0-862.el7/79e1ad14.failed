rtnetlink: use netnsid to query interface

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jiri Benc <jbenc@redhat.com>
commit 79e1ad148c844f5c8b9d76b36b26e3886dca95ae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/79e1ad14.failed

Currently, when an application gets netnsid from the kernel (for example as
the result of RTM_GETLINK call on one end of the veth pair), it's not much
useful. There's no reliable way to get to the netns fd from the netnsid, nor
does any kernel API accept netnsid.

Extend the RTM_GETLINK call to also accept netnsid. It will operate on the
netns with the given netnsid in such case. Of course, the calling process
needs to have enough capabilities in the target name space; for now, require
CAP_NET_ADMIN. This can be relaxed in the future.

To signal to the calling process that the kernel understood the new
IFLA_IF_NETNSID attribute in the query, it will include it in the response.
This is needed to detect older kernels, as they will just ignore
IFLA_IF_NETNSID and query in the current name space.

This patch implemetns IFLA_IF_NETNSID only for get and dump. For set
operations, this can be extended later.

	Signed-off-by: Jiri Benc <jbenc@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 79e1ad148c844f5c8b9d76b36b26e3886dca95ae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/if_link.h
#	net/core/rtnetlink.c
diff --cc include/uapi/linux/if_link.h
index 996998dd2fff,19fc02660e0c..000000000000
--- a/include/uapi/linux/if_link.h
+++ b/include/uapi/linux/if_link.h
@@@ -160,6 -157,10 +160,13 @@@ enum 
  	IFLA_GSO_MAX_SEGS,
  	IFLA_GSO_MAX_SIZE,
  	IFLA_PAD,
++<<<<<<< HEAD
++=======
+ 	IFLA_XDP,
+ 	IFLA_EVENT,
+ 	IFLA_NEW_NETNSID,
+ 	IFLA_IF_NETNSID,
++>>>>>>> 79e1ad148c84 (rtnetlink: use netnsid to query interface)
  	__IFLA_MAX
  };
  
diff --cc net/core/rtnetlink.c
index 1df92b36501c,8a8c51937edf..000000000000
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@@ -916,8 -917,12 +916,9 @@@ static noinline size_t if_nlmsg_size(co
  	       + nla_total_size(MAX_PHYS_ITEM_ID_LEN) /* IFLA_PHYS_PORT_ID */
  	       + nla_total_size(MAX_PHYS_ITEM_ID_LEN) /* IFLA_PHYS_SWITCH_ID */
  	       + nla_total_size(IFNAMSIZ) /* IFLA_PHYS_PORT_NAME */
 -	       + rtnl_xdp_size() /* IFLA_XDP */
 -	       + nla_total_size(4)  /* IFLA_EVENT */
 -	       + nla_total_size(4)  /* IFLA_NEW_NETNSID */
  	       + nla_total_size(1); /* IFLA_PROTO_DOWN */
- 
+ 	       + nla_total_size(4)  /* IFLA_IF_NETNSID */
+ 	       + 0;
  }
  
  static int rtnl_vf_ports_fill(struct sk_buff *skb, struct net_device *dev)
@@@ -1219,9 -1257,183 +1220,189 @@@ static int rtnl_fill_link_ifmap(struct 
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int rtnl_fill_ifinfo(struct sk_buff *skb, struct net_device *dev,
 +			    int type, u32 pid, u32 seq, u32 change,
 +			    unsigned int flags, u32 ext_filter_mask)
++=======
+ static u8 rtnl_xdp_attached_mode(struct net_device *dev, u32 *prog_id)
+ {
+ 	const struct net_device_ops *ops = dev->netdev_ops;
+ 	const struct bpf_prog *generic_xdp_prog;
+ 
+ 	ASSERT_RTNL();
+ 
+ 	*prog_id = 0;
+ 	generic_xdp_prog = rtnl_dereference(dev->xdp_prog);
+ 	if (generic_xdp_prog) {
+ 		*prog_id = generic_xdp_prog->aux->id;
+ 		return XDP_ATTACHED_SKB;
+ 	}
+ 	if (!ops->ndo_xdp)
+ 		return XDP_ATTACHED_NONE;
+ 
+ 	return __dev_xdp_attached(dev, ops->ndo_xdp, prog_id);
+ }
+ 
+ static int rtnl_xdp_fill(struct sk_buff *skb, struct net_device *dev)
+ {
+ 	struct nlattr *xdp;
+ 	u32 prog_id;
+ 	int err;
+ 
+ 	xdp = nla_nest_start(skb, IFLA_XDP);
+ 	if (!xdp)
+ 		return -EMSGSIZE;
+ 
+ 	err = nla_put_u8(skb, IFLA_XDP_ATTACHED,
+ 			 rtnl_xdp_attached_mode(dev, &prog_id));
+ 	if (err)
+ 		goto err_cancel;
+ 
+ 	if (prog_id) {
+ 		err = nla_put_u32(skb, IFLA_XDP_PROG_ID, prog_id);
+ 		if (err)
+ 			goto err_cancel;
+ 	}
+ 
+ 	nla_nest_end(skb, xdp);
+ 	return 0;
+ 
+ err_cancel:
+ 	nla_nest_cancel(skb, xdp);
+ 	return err;
+ }
+ 
+ static u32 rtnl_get_event(unsigned long event)
+ {
+ 	u32 rtnl_event_type = IFLA_EVENT_NONE;
+ 
+ 	switch (event) {
+ 	case NETDEV_REBOOT:
+ 		rtnl_event_type = IFLA_EVENT_REBOOT;
+ 		break;
+ 	case NETDEV_FEAT_CHANGE:
+ 		rtnl_event_type = IFLA_EVENT_FEATURES;
+ 		break;
+ 	case NETDEV_BONDING_FAILOVER:
+ 		rtnl_event_type = IFLA_EVENT_BONDING_FAILOVER;
+ 		break;
+ 	case NETDEV_NOTIFY_PEERS:
+ 		rtnl_event_type = IFLA_EVENT_NOTIFY_PEERS;
+ 		break;
+ 	case NETDEV_RESEND_IGMP:
+ 		rtnl_event_type = IFLA_EVENT_IGMP_RESEND;
+ 		break;
+ 	case NETDEV_CHANGEINFODATA:
+ 		rtnl_event_type = IFLA_EVENT_BONDING_OPTIONS;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return rtnl_event_type;
+ }
+ 
+ static int put_master_ifindex(struct sk_buff *skb, struct net_device *dev)
+ {
+ 	const struct net_device *upper_dev;
+ 	int ret = 0;
+ 
+ 	rcu_read_lock();
+ 
+ 	upper_dev = netdev_master_upper_dev_get_rcu(dev);
+ 	if (upper_dev)
+ 		ret = nla_put_u32(skb, IFLA_MASTER, upper_dev->ifindex);
+ 
+ 	rcu_read_unlock();
+ 	return ret;
+ }
+ 
+ static int nla_put_iflink(struct sk_buff *skb, const struct net_device *dev)
+ {
+ 	int ifindex = dev_get_iflink(dev);
+ 
+ 	if (dev->ifindex == ifindex)
+ 		return 0;
+ 
+ 	return nla_put_u32(skb, IFLA_LINK, ifindex);
+ }
+ 
+ static noinline_for_stack int nla_put_ifalias(struct sk_buff *skb,
+ 					      struct net_device *dev)
+ {
+ 	char buf[IFALIASZ];
+ 	int ret;
+ 
+ 	ret = dev_get_alias(dev, buf, sizeof(buf));
+ 	return ret > 0 ? nla_put_string(skb, IFLA_IFALIAS, buf) : 0;
+ }
+ 
+ static int rtnl_fill_link_netnsid(struct sk_buff *skb,
+ 				  const struct net_device *dev,
+ 				  struct net *src_net)
+ {
+ 	if (dev->rtnl_link_ops && dev->rtnl_link_ops->get_link_net) {
+ 		struct net *link_net = dev->rtnl_link_ops->get_link_net(dev);
+ 
+ 		if (!net_eq(dev_net(dev), link_net)) {
+ 			int id = peernet2id_alloc(src_net, link_net);
+ 
+ 			if (nla_put_s32(skb, IFLA_LINK_NETNSID, id))
+ 				return -EMSGSIZE;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int rtnl_fill_link_af(struct sk_buff *skb,
+ 			     const struct net_device *dev,
+ 			     u32 ext_filter_mask)
+ {
+ 	const struct rtnl_af_ops *af_ops;
+ 	struct nlattr *af_spec;
+ 
+ 	af_spec = nla_nest_start(skb, IFLA_AF_SPEC);
+ 	if (!af_spec)
+ 		return -EMSGSIZE;
+ 
+ 	list_for_each_entry_rcu(af_ops, &rtnl_af_ops, list) {
+ 		struct nlattr *af;
+ 		int err;
+ 
+ 		if (!af_ops->fill_link_af)
+ 			continue;
+ 
+ 		af = nla_nest_start(skb, af_ops->family);
+ 		if (!af)
+ 			return -EMSGSIZE;
+ 
+ 		err = af_ops->fill_link_af(skb, dev, ext_filter_mask);
+ 		/*
+ 		 * Caller may return ENODATA to indicate that there
+ 		 * was no data to be dumped. This is not an error, it
+ 		 * means we should trim the attribute header and
+ 		 * continue.
+ 		 */
+ 		if (err == -ENODATA)
+ 			nla_nest_cancel(skb, af);
+ 		else if (err < 0)
+ 			return -EMSGSIZE;
+ 
+ 		nla_nest_end(skb, af);
+ 	}
+ 
+ 	nla_nest_end(skb, af_spec);
+ 	return 0;
+ }
+ 
+ static int rtnl_fill_ifinfo(struct sk_buff *skb,
+ 			    struct net_device *dev, struct net *src_net,
+ 			    int type, u32 pid, u32 seq, u32 change,
+ 			    unsigned int flags, u32 ext_filter_mask,
+ 			    u32 event, int *new_nsid, int tgt_netnsid)
++>>>>>>> 79e1ad148c84 (rtnetlink: use netnsid to query interface)
  {
  	struct ifinfomsg *ifm;
  	struct nlmsghdr *nlh;
@@@ -1320,47 -1519,17 +1504,51 @@@
  			goto nla_put_failure;
  	}
  
++<<<<<<< HEAD
 +	if (dev->rtnl_link_ops &&
 +	    dev->rtnl_link_ops->get_link_net) {
 +		struct net *link_net = dev->rtnl_link_ops->get_link_net(dev);
 +
 +		if (!net_eq(dev_net(dev), link_net)) {
 +			int id = peernet2id_alloc(dev_net(dev), link_net);
 +
 +			if (nla_put_s32(skb, IFLA_LINK_NETNSID, id))
 +				goto nla_put_failure;
 +		}
 +	}
 +
 +	if (!(af_spec = nla_nest_start(skb, IFLA_AF_SPEC)))
++=======
+ 	if (rtnl_fill_link_netnsid(skb, dev, src_net))
++>>>>>>> 79e1ad148c84 (rtnetlink: use netnsid to query interface)
  		goto nla_put_failure;
  
 -	if (new_nsid &&
 -	    nla_put_s32(skb, IFLA_NEW_NETNSID, *new_nsid) < 0)
 -		goto nla_put_failure;
 +	list_for_each_entry(af_ops, &rtnl_af_ops, list) {
 +		if (af_ops->fill_link_af) {
 +			struct nlattr *af;
 +			int err;
  
 -	rcu_read_lock();
 -	if (rtnl_fill_link_af(skb, dev, ext_filter_mask))
 -		goto nla_put_failure_rcu;
 -	rcu_read_unlock();
 +			if (!(af = nla_nest_start(skb, af_ops->family)))
 +				goto nla_put_failure;
 +
 +			err = af_ops->fill_link_af(skb, dev);
 +
 +			/*
 +			 * Caller may return ENODATA to indicate that there
 +			 * was no data to be dumped. This is not an error, it
 +			 * means we should trim the attribute header and
 +			 * continue.
 +			 */
 +			if (err == -ENODATA)
 +				nla_nest_cancel(skb, af);
 +			else if (err < 0)
 +				goto nla_put_failure;
 +
 +			nla_nest_end(skb, af);
 +		}
 +	}
 +
 +	nla_nest_end(skb, af_spec);
  
  	nlmsg_end(skb, nlh);
  	return 0;
@@@ -1400,6 -1574,10 +1588,13 @@@ static const struct nla_policy ifla_pol
  	[IFLA_PHYS_SWITCH_ID]	= { .type = NLA_BINARY, .len = MAX_PHYS_ITEM_ID_LEN },
  	[IFLA_LINK_NETNSID]	= { .type = NLA_S32 },
  	[IFLA_PROTO_DOWN]	= { .type = NLA_U8 },
++<<<<<<< HEAD
++=======
+ 	[IFLA_XDP]		= { .type = NLA_NESTED },
+ 	[IFLA_EVENT]		= { .type = NLA_U32 },
+ 	[IFLA_GROUP]		= { .type = NLA_U32 },
+ 	[IFLA_IF_NETNSID]	= { .type = NLA_S32 },
++>>>>>>> 79e1ad148c84 (rtnetlink: use netnsid to query interface)
  };
  
  static const struct nla_policy ifla_info_policy[IFLA_INFO_MAX+1] = {
@@@ -1445,8 -1612,93 +1640,89 @@@ static const struct nla_policy ifla_por
  				    .len = PORT_UUID_MAX },
  	[IFLA_PORT_REQUEST]	= { .type = NLA_U8, },
  	[IFLA_PORT_RESPONSE]	= { .type = NLA_U16, },
 -
 -	/* Unused, but we need to keep it here since user space could
 -	 * fill it. It's also broken with regard to NLA_BINARY use in
 -	 * combination with structs.
 -	 */
 -	[IFLA_PORT_VSI_TYPE]	= { .type = NLA_BINARY,
 -				    .len = sizeof(struct ifla_port_vsi) },
  };
  
++<<<<<<< HEAD
++=======
+ static const struct nla_policy ifla_xdp_policy[IFLA_XDP_MAX + 1] = {
+ 	[IFLA_XDP_FD]		= { .type = NLA_S32 },
+ 	[IFLA_XDP_ATTACHED]	= { .type = NLA_U8 },
+ 	[IFLA_XDP_FLAGS]	= { .type = NLA_U32 },
+ 	[IFLA_XDP_PROG_ID]	= { .type = NLA_U32 },
+ };
+ 
+ static const struct rtnl_link_ops *linkinfo_to_kind_ops(const struct nlattr *nla)
+ {
+ 	const struct rtnl_link_ops *ops = NULL;
+ 	struct nlattr *linfo[IFLA_INFO_MAX + 1];
+ 
+ 	if (nla_parse_nested(linfo, IFLA_INFO_MAX, nla,
+ 			     ifla_info_policy, NULL) < 0)
+ 		return NULL;
+ 
+ 	if (linfo[IFLA_INFO_KIND]) {
+ 		char kind[MODULE_NAME_LEN];
+ 
+ 		nla_strlcpy(kind, linfo[IFLA_INFO_KIND], sizeof(kind));
+ 		ops = rtnl_link_ops_get(kind);
+ 	}
+ 
+ 	return ops;
+ }
+ 
+ static bool link_master_filtered(struct net_device *dev, int master_idx)
+ {
+ 	struct net_device *master;
+ 
+ 	if (!master_idx)
+ 		return false;
+ 
+ 	master = netdev_master_upper_dev_get(dev);
+ 	if (!master || master->ifindex != master_idx)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ static bool link_kind_filtered(const struct net_device *dev,
+ 			       const struct rtnl_link_ops *kind_ops)
+ {
+ 	if (kind_ops && dev->rtnl_link_ops != kind_ops)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ static bool link_dump_filtered(struct net_device *dev,
+ 			       int master_idx,
+ 			       const struct rtnl_link_ops *kind_ops)
+ {
+ 	if (link_master_filtered(dev, master_idx) ||
+ 	    link_kind_filtered(dev, kind_ops))
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ static struct net *get_target_net(struct sk_buff *skb, int netnsid)
+ {
+ 	struct net *net;
+ 
+ 	net = get_net_ns_by_id(sock_net(skb->sk), netnsid);
+ 	if (!net)
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	/* For now, the caller is required to have CAP_NET_ADMIN in
+ 	 * the user namespace owning the target net ns.
+ 	 */
+ 	if (!netlink_ns_capable(skb, net->user_ns, CAP_NET_ADMIN)) {
+ 		put_net(net);
+ 		return ERR_PTR(-EACCES);
+ 	}
+ 	return net;
+ }
+ 
++>>>>>>> 79e1ad148c84 (rtnetlink: use netnsid to query interface)
  static int rtnl_dump_ifinfo(struct sk_buff *skb, struct netlink_callback *cb)
  {
  	struct net *net = sock_net(skb->sk);
@@@ -1456,6 -1709,10 +1733,13 @@@
  	struct hlist_head *head;
  	struct nlattr *tb[IFLA_MAX+1];
  	u32 ext_filter_mask = 0;
++<<<<<<< HEAD
++=======
+ 	const struct rtnl_link_ops *kind_ops = NULL;
+ 	unsigned int flags = NLM_F_MULTI;
+ 	int master_idx = 0;
+ 	int netnsid = -1;
++>>>>>>> 79e1ad148c84 (rtnetlink: use netnsid to query interface)
  	int err;
  	int hdrlen;
  
@@@ -1474,7 -1729,16 +1758,20 @@@
  	hdrlen = nlmsg_len(cb->nlh) < sizeof(struct ifinfomsg) ?
  		 sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);
  
++<<<<<<< HEAD
 +	if (nlmsg_parse(cb->nlh, hdrlen, tb, IFLA_MAX, ifla_policy) >= 0) {
++=======
+ 	if (nlmsg_parse(cb->nlh, hdrlen, tb, IFLA_MAX,
+ 			ifla_policy, NULL) >= 0) {
+ 		if (tb[IFLA_IF_NETNSID]) {
+ 			netnsid = nla_get_s32(tb[IFLA_IF_NETNSID]);
+ 			tgt_net = get_target_net(skb, netnsid);
+ 			if (IS_ERR(tgt_net)) {
+ 				tgt_net = net;
+ 				netnsid = -1;
+ 			}
+ 		}
++>>>>>>> 79e1ad148c84 (rtnetlink: use netnsid to query interface)
  
  		if (tb[IFLA_EXT_MASK])
  			ext_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);
@@@ -1482,38 -1755,47 +1779,52 @@@
  
  	for (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {
  		idx = 0;
- 		head = &net->dev_index_head[h];
+ 		head = &tgt_net->dev_index_head[h];
  		hlist_for_each_entry(dev, head, index_hlist) {
 -			if (link_dump_filtered(dev, master_idx, kind_ops))
 -				goto cont;
  			if (idx < s_idx)
  				goto cont;
- 			err = rtnl_fill_ifinfo(skb, dev, RTM_NEWLINK,
+ 			err = rtnl_fill_ifinfo(skb, dev, net,
+ 					       RTM_NEWLINK,
  					       NETLINK_CB(cb->skb).portid,
  					       cb->nlh->nlmsg_seq, 0,
++<<<<<<< HEAD
 +					       NLM_F_MULTI,
 +					       ext_filter_mask);
 +			/* If we ran out of room on the first message,
 +			 * we're in trouble
 +			 */
 +			WARN_ON((err == -EMSGSIZE) && (skb->len == 0));
++=======
+ 					       flags,
+ 					       ext_filter_mask, 0, NULL,
+ 					       netnsid);
++>>>>>>> 79e1ad148c84 (rtnetlink: use netnsid to query interface)
  
 -			if (err < 0) {
 -				if (likely(skb->len))
 -					goto out;
 +			if (err < 0)
 +				goto out;
  
 -				goto out_err;
 -			}
 +			nl_dump_check_consistent(cb, nlmsg_hdr(skb));
  cont:
  			idx++;
  		}
  	}
  out:
 -	err = skb->len;
 -out_err:
  	cb->args[1] = idx;
  	cb->args[0] = h;
++<<<<<<< HEAD
++=======
+ 	cb->seq = net->dev_base_seq;
+ 	nl_dump_check_consistent(cb, nlmsg_hdr(skb));
+ 	if (netnsid >= 0)
+ 		put_net(tgt_net);
++>>>>>>> 79e1ad148c84 (rtnetlink: use netnsid to query interface)
  
 -	return err;
 +	return skb->len;
  }
  
 -int rtnl_nla_parse_ifla(struct nlattr **tb, const struct nlattr *head, int len,
 -			struct netlink_ext_ack *exterr)
 +int rtnl_nla_parse_ifla(struct nlattr **tb, const struct nlattr *head, int len)
  {
 -	return nla_parse(tb, IFLA_MAX, head, len, ifla_policy, exterr);
 +	return nla_parse(tb, IFLA_MAX, head, len, ifla_policy);
  }
  EXPORT_SYMBOL(rtnl_nla_parse_ifla);
  
@@@ -2485,9 -2863,11 +2805,10 @@@ out_unregister
  	}
  }
  
 -static int rtnl_getlink(struct sk_buff *skb, struct nlmsghdr *nlh,
 -			struct netlink_ext_ack *extack)
 +static int rtnl_getlink(struct sk_buff *skb, struct nlmsghdr* nlh)
  {
  	struct net *net = sock_net(skb->sk);
+ 	struct net *tgt_net = net;
  	struct ifinfomsg *ifm;
  	char ifname[IFNAMSIZ];
  	struct nlattr *tb[IFLA_MAX+1];
@@@ -2506,23 -2894,28 +2835,33 @@@
  	if (tb[IFLA_EXT_MASK])
  		ext_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);
  
+ 	err = -EINVAL;
  	ifm = nlmsg_data(nlh);
  	if (ifm->ifi_index > 0)
- 		dev = __dev_get_by_index(net, ifm->ifi_index);
+ 		dev = __dev_get_by_index(tgt_net, ifm->ifi_index);
  	else if (tb[IFLA_IFNAME])
- 		dev = __dev_get_by_name(net, ifname);
+ 		dev = __dev_get_by_name(tgt_net, ifname);
  	else
- 		return -EINVAL;
+ 		goto out;
  
+ 	err = -ENODEV;
  	if (dev == NULL)
- 		return -ENODEV;
+ 		goto out;
  
+ 	err = -ENOBUFS;
  	nskb = nlmsg_new(if_nlmsg_size(dev, ext_filter_mask), GFP_KERNEL);
  	if (nskb == NULL)
- 		return -ENOBUFS;
+ 		goto out;
  
++<<<<<<< HEAD
 +	err = rtnl_fill_ifinfo(nskb, dev, RTM_NEWLINK, NETLINK_CB(skb).portid,
 +			       nlh->nlmsg_seq, 0, 0, ext_filter_mask);
++=======
+ 	err = rtnl_fill_ifinfo(nskb, dev, net,
+ 			       RTM_NEWLINK, NETLINK_CB(skb).portid,
+ 			       nlh->nlmsg_seq, 0, 0, ext_filter_mask,
+ 			       0, NULL, netnsid);
++>>>>>>> 79e1ad148c84 (rtnetlink: use netnsid to query interface)
  	if (err < 0) {
  		/* -EMSGSIZE implies BUG in if_nlmsg_size */
  		WARN_ON(err == -EMSGSIZE);
@@@ -2605,7 -3014,9 +2947,13 @@@ struct sk_buff *rtmsg_ifinfo_build_skb(
  	if (skb == NULL)
  		goto errout;
  
++<<<<<<< HEAD
 +	err = rtnl_fill_ifinfo(skb, dev, type, 0, 0, change, 0, 0);
++=======
+ 	err = rtnl_fill_ifinfo(skb, dev, dev_net(dev),
+ 			       type, 0, 0, change, 0, 0, event,
+ 			       new_nsid, -1);
++>>>>>>> 79e1ad148c84 (rtnetlink: use netnsid to query interface)
  	if (err < 0) {
  		/* -EMSGSIZE implies BUG in if_nlmsg_size() */
  		WARN_ON(err == -EMSGSIZE);
* Unmerged path include/uapi/linux/if_link.h
* Unmerged path net/core/rtnetlink.c
