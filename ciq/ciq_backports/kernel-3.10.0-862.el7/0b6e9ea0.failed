fuse: Add support for pid namespaces

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Seth Forshee <seth.forshee@canonical.com>
commit 0b6e9ea041e6c932f5b3a86fae2d60cbcfad4dd2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0b6e9ea0.failed

When the userspace process servicing fuse requests is running in
a pid namespace then pids passed via the fuse fd are not being
translated into that process' namespace. Translation is necessary
for the pid to be useful to that process.

Since no use case currently exists for changing namespaces all
translations can be done relative to the pid namespace in use
when fuse_conn_init() is called. For fuse this translates to
mount time, and for cuse this is when /dev/cuse is opened. IO for
this connection from another namespace will return errors.

Requests from processes whose pid cannot be translated into the
target namespace will have a value of 0 for in.h.pid.

File locking changes based on previous work done by Eric
Biederman.

	Signed-off-by: Seth Forshee <seth.forshee@canonical.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 0b6e9ea041e6c932f5b3a86fae2d60cbcfad4dd2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/dev.c
#	fs/fuse/file.c
#	fs/fuse/fuse_i.h
#	fs/fuse/inode.c
diff --cc fs/fuse/dev.c
index e5326f13da17,f95682115bc2..000000000000
--- a/fs/fuse/dev.c
+++ b/fs/fuse/dev.c
@@@ -19,7 -20,7 +19,11 @@@
  #include <linux/pipe_fs_i.h>
  #include <linux/swap.h>
  #include <linux/splice.h>
++<<<<<<< HEAD
 +#include <linux/aio.h>
++=======
+ #include <linux/sched.h>
++>>>>>>> 0b6e9ea041e6 (fuse: Add support for pid namespaces)
  
  MODULE_ALIAS_MISCDEV(FUSE_MINOR);
  MODULE_ALIAS("devname:fuse");
@@@ -120,17 -109,23 +124,17 @@@ void __fuse_get_request(struct fuse_re
  /* Must be called with > 1 refcount */
  static void __fuse_put_request(struct fuse_req *req)
  {
 -	refcount_dec(&req->count);
 +	BUG_ON(atomic_read(&req->count) < 2);
 +	atomic_dec(&req->count);
  }
  
- static void fuse_req_init_context(struct fuse_req *req)
+ static void fuse_req_init_context(struct fuse_conn *fc, struct fuse_req *req)
  {
  	req->in.h.uid = from_kuid_munged(&init_user_ns, current_fsuid());
  	req->in.h.gid = from_kgid_munged(&init_user_ns, current_fsgid());
- 	req->in.h.pid = current->pid;
+ 	req->in.h.pid = pid_nr_ns(task_pid(current), fc->pid_ns);
  }
  
 -void fuse_set_initialized(struct fuse_conn *fc)
 -{
 -	/* Make sure stores before this are seen on another CPU */
 -	smp_wmb();
 -	fc->initialized = 1;
 -}
 -
  static bool fuse_block_alloc(struct fuse_conn *fc, bool for_background)
  {
  	return !fc->initialized || (for_background && fc->blocked);
@@@ -168,9 -163,11 +172,17 @@@ static struct fuse_req *__fuse_get_req(
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	fuse_req_init_context(req);
 +	req->waiting = 1;
 +	req->background = for_background;
++=======
+ 	fuse_req_init_context(fc, req);
+ 	__set_bit(FR_WAITING, &req->flags);
+ 	if (for_background)
+ 		__set_bit(FR_BACKGROUND, &req->flags);
+ 
++>>>>>>> 0b6e9ea041e6 (fuse: Add support for pid namespaces)
  	return req;
  
   out:
@@@ -257,9 -256,9 +269,15 @@@ struct fuse_req *fuse_get_req_nofail_no
  	if (!req)
  		req = get_reserved_req(fc, file);
  
++<<<<<<< HEAD
 +	fuse_req_init_context(req);
 +	req->waiting = 1;
 +	req->background = 0;
++=======
+ 	fuse_req_init_context(fc, req);
+ 	__set_bit(FR_WAITING, &req->flags);
+ 	__clear_bit(FR_BACKGROUND, &req->flags);
++>>>>>>> 0b6e9ea041e6 (fuse: Add support for pid namespaces)
  	return req;
  }
  
@@@ -1204,38 -1223,43 +1222,41 @@@ static ssize_t fuse_dev_do_read(struct 
  	struct fuse_in *in;
  	unsigned reqsize;
  
+ 	if (task_active_pid_ns(current) != fc->pid_ns)
+ 		return -EIO;
+ 
   restart:
 -	spin_lock(&fiq->waitq.lock);
 +	spin_lock(&fc->lock);
  	err = -EAGAIN;
 -	if ((file->f_flags & O_NONBLOCK) && fiq->connected &&
 -	    !request_pending(fiq))
 -		goto err_unlock;
 -
 -	err = wait_event_interruptible_exclusive_locked(fiq->waitq,
 -				!fiq->connected || request_pending(fiq));
 -	if (err)
 +	if ((file->f_flags & O_NONBLOCK) && fc->connected &&
 +	    !request_pending(fc))
  		goto err_unlock;
  
 +	request_wait(fc);
  	err = -ENODEV;
 -	if (!fiq->connected)
 +	if (!fc->connected)
 +		goto err_unlock;
 +	err = -ERESTARTSYS;
 +	if (!request_pending(fc))
  		goto err_unlock;
  
 -	if (!list_empty(&fiq->interrupts)) {
 -		req = list_entry(fiq->interrupts.next, struct fuse_req,
 +	if (!list_empty(&fc->interrupts)) {
 +		req = list_entry(fc->interrupts.next, struct fuse_req,
  				 intr_entry);
 -		return fuse_read_interrupt(fiq, cs, nbytes, req);
 +		return fuse_read_interrupt(fc, cs, nbytes, req);
  	}
  
 -	if (forget_pending(fiq)) {
 -		if (list_empty(&fiq->pending) || fiq->forget_batch-- > 0)
 -			return fuse_read_forget(fc, fiq, cs, nbytes);
 +	if (forget_pending(fc)) {
 +		if (list_empty(&fc->pending) || fc->forget_batch-- > 0)
 +			return fuse_read_forget(fc, cs, nbytes);
  
 -		if (fiq->forget_batch <= -8)
 -			fiq->forget_batch = 16;
 +		if (fc->forget_batch <= -8)
 +			fc->forget_batch = 16;
  	}
  
 -	req = list_entry(fiq->pending.next, struct fuse_req, list);
 -	clear_bit(FR_PENDING, &req->flags);
 -	list_del_init(&req->list);
 -	spin_unlock(&fiq->waitq.lock);
 +	req = list_entry(fc->pending.next, struct fuse_req, list);
 +	req->state = FUSE_REQ_READING;
 +	list_move(&req->list, &fc->io);
  
  	in = &req->in;
  	reqsize = in->h.len;
diff --cc fs/fuse/file.c
index bd73f4f40c3a,aa93f09ae6e6..000000000000
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@@ -1709,19 -2149,13 +1717,19 @@@ static int fuse_getlk(struct file *file
  	struct fuse_lk_out outarg;
  	int err;
  
 -	fuse_lk_fill(&args, file, fl, FUSE_GETLK, 0, 0, &inarg);
 -	args.out.numargs = 1;
 -	args.out.args[0].size = sizeof(outarg);
 -	args.out.args[0].value = &outarg;
 -	err = fuse_simple_request(fc, &args);
 +	req = fuse_get_req_nopages(fc);
 +	if (IS_ERR(req))
 +		return PTR_ERR(req);
 +
 +	fuse_lk_fill(req, file, fl, FUSE_GETLK, 0, 0);
 +	req->out.numargs = 1;
 +	req->out.args[0].size = sizeof(outarg);
 +	req->out.args[0].value = &outarg;
 +	fuse_request_send(fc, req);
 +	err = req->out.h.error;
 +	fuse_put_request(fc, req);
  	if (!err)
- 		err = convert_fuse_file_lock(&outarg.lk, fl);
+ 		err = convert_fuse_file_lock(fc, &outarg.lk, fl);
  
  	return err;
  }
@@@ -1730,9 -2164,11 +1738,10 @@@ static int fuse_setlk(struct file *file
  {
  	struct inode *inode = file_inode(file);
  	struct fuse_conn *fc = get_fuse_conn(inode);
 -	FUSE_ARGS(args);
 -	struct fuse_lk_in inarg;
 +	struct fuse_req *req;
  	int opcode = (fl->fl_flags & FL_SLEEP) ? FUSE_SETLKW : FUSE_SETLK;
- 	pid_t pid = fl->fl_type != F_UNLCK ? current->tgid : 0;
+ 	struct pid *pid = fl->fl_type != F_UNLCK ? task_tgid(current) : NULL;
+ 	pid_t pid_nr = pid_nr_ns(pid, fc->pid_ns);
  	int err;
  
  	if (fl->fl_lmops && fl->fl_lmops->lm_grant) {
@@@ -1741,16 -2177,15 +1750,24 @@@
  	}
  
  	/* Unlock on close is handled by the flush method */
 -	if (fl->fl_flags & FL_CLOSE)
 +	if ((fl->fl_flags & FL_CLOSE_POSIX) == FL_CLOSE_POSIX)
  		return 0;
  
++<<<<<<< HEAD
 +	req = fuse_get_req_nopages(fc);
 +	if (IS_ERR(req))
 +		return PTR_ERR(req);
++=======
+ 	if (pid && pid_nr == 0)
+ 		return -EOVERFLOW;
+ 
+ 	fuse_lk_fill(&args, file, fl, opcode, pid_nr, flock, &inarg);
+ 	err = fuse_simple_request(fc, &args);
++>>>>>>> 0b6e9ea041e6 (fuse: Add support for pid namespaces)
  
 +	fuse_lk_fill(req, file, fl, opcode, pid, flock);
 +	fuse_request_send(fc, req);
 +	err = req->out.h.error;
  	/* locking is restartable */
  	if (err == -EINTR)
  		err = -ERESTARTSYS;
diff --cc fs/fuse/fuse_i.h
index 17ee3b10a0c2,041521d29d33..000000000000
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@@ -22,6 -22,10 +22,13 @@@
  #include <linux/rbtree.h>
  #include <linux/poll.h>
  #include <linux/workqueue.h>
++<<<<<<< HEAD
++=======
+ #include <linux/kref.h>
+ #include <linux/xattr.h>
+ #include <linux/pid_namespace.h>
+ #include <linux/refcount.h>
++>>>>>>> 0b6e9ea041e6 (fuse: Add support for pid namespaces)
  
  /** Max number of pages that can be used in a single read request */
  #define FUSE_MAX_PAGES_PER_REQ 32
@@@ -386,8 -463,8 +393,13 @@@ struct fuse_conn 
  	/** The group id for this mount */
  	kgid_t group_id;
  
++<<<<<<< HEAD
 +	/** The fuse mount flags for this mount */
 +	unsigned flags;
++=======
+ 	/** The pid namespace for this mount */
+ 	struct pid_namespace *pid_ns;
++>>>>>>> 0b6e9ea041e6 (fuse: Add support for pid namespaces)
  
  	/** Maximum read size */
  	unsigned max_read;
diff --cc fs/fuse/inode.c
index 9a1a0ea97732,a137f1c99a33..000000000000
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@@ -20,6 -20,8 +20,11 @@@
  #include <linux/random.h>
  #include <linux/sched.h>
  #include <linux/exportfs.h>
++<<<<<<< HEAD
++=======
+ #include <linux/posix_acl.h>
+ #include <linux/pid_namespace.h>
++>>>>>>> 0b6e9ea041e6 (fuse: Add support for pid namespaces)
  
  MODULE_AUTHOR("Miklos Szeredi <miklos@szeredi.hu>");
  MODULE_DESCRIPTION("Filesystem in Userspace");
@@@ -583,20 -622,21 +588,25 @@@ void fuse_conn_init(struct fuse_conn *f
  	fc->congestion_threshold = FUSE_DEFAULT_CONGESTION_THRESHOLD;
  	fc->khctr = 0;
  	fc->polled_files = RB_ROOT;
 +	fc->reqctr = 0;
  	fc->blocked = 0;
  	fc->initialized = 0;
 -	fc->connected = 1;
  	fc->attr_version = 1;
  	get_random_bytes(&fc->scramble_key, sizeof(fc->scramble_key));
+ 	fc->pid_ns = get_pid_ns(task_active_pid_ns(current));
  }
  EXPORT_SYMBOL_GPL(fuse_conn_init);
  
  void fuse_conn_put(struct fuse_conn *fc)
  {
 -	if (refcount_dec_and_test(&fc->count)) {
 +	if (atomic_dec_and_test(&fc->count)) {
  		if (fc->destroy_req)
  			fuse_request_free(fc->destroy_req);
++<<<<<<< HEAD
 +		mutex_destroy(&fc->inst_mutex);
++=======
+ 		put_pid_ns(fc->pid_ns);
++>>>>>>> 0b6e9ea041e6 (fuse: Add support for pid namespaces)
  		fc->release(fc);
  	}
  }
* Unmerged path fs/fuse/dev.c
* Unmerged path fs/fuse/file.c
* Unmerged path fs/fuse/fuse_i.h
* Unmerged path fs/fuse/inode.c
