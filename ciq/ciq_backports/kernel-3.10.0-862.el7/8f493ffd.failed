net/mlx5e: IPoIB, RX steering RSS RQTs and TIRs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: IPoIB, RX steering RSS RQTs and TIRs (Don Dutile) [1385325 1499362]
Rebuild_FUZZ: 95.56%
commit-author Saeed Mahameed <saeedm@mellanox.com>
commit 8f493ffd88eac1b45685f0f21005b65352320b8a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8f493ffd.failed

Implement IPoIB RX RSS (RQTs and TIRs) HW objects creation,
All we do here is simply reuse the mlx5e implementation to create
direct and indirect (RSS) steering HW objects.

For that we just expose
mlx5e_{create,destroy}_{direct,indirect}_{rqt,tir} functions into en.h
and call them from ipoib.c in init/cleanup_rx IPoIB netdevice profile
callbacks.

	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Reviewed-by: Erez Shitrit <erezsh@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8f493ffd88eac1b45685f0f21005b65352320b8a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en.h
index f6e3d4bf0928,e5518536d56f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@@ -930,4 -1023,16 +937,19 @@@ bool mlx5e_has_offload_stats(const stru
  
  bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv);
  bool mlx5e_is_vf_vport_rep(struct mlx5e_priv *priv);
++<<<<<<< HEAD
++=======
+ 
+ /* mlx5e generic netdev management API */
+ struct net_device*
+ mlx5e_create_netdev(struct mlx5_core_dev *mdev, const struct mlx5e_profile *profile,
+ 		    void *ppriv);
+ int mlx5e_attach_netdev(struct mlx5e_priv *priv);
+ void mlx5e_detach_netdev(struct mlx5e_priv *priv);
+ void mlx5e_destroy_netdev(struct mlx5e_priv *priv);
+ void mlx5e_build_nic_params(struct mlx5_core_dev *mdev,
+ 			    struct mlx5e_params *params,
+ 			    u16 max_channels);
+ 
++>>>>>>> 8f493ffd88ea (net/mlx5e: IPoIB, RX steering RSS RQTs and TIRs)
  #endif /* __MLX5_EN_H__ */
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index fc92406a15c4,08b67aa24644..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -1783,17 -2063,98 +1783,104 @@@ static void mlx5e_close_channels(struc
  {
  	int i;
  
 -	for (i = 0; i < chs->num; i++)
 -		mlx5e_deactivate_channel(chs->c[i]);
 -}
 +	/* FIXME: This is a W/A only for tx timeout watch dog false alarm when
 +	 * polling for inactive tx queues.
 +	 */
 +	netif_tx_stop_all_queues(priv->netdev);
 +	netif_tx_disable(priv->netdev);
  
 -void mlx5e_close_channels(struct mlx5e_channels *chs)
 -{
 -	int i;
 +	for (i = 0; i < priv->params.num_channels; i++)
 +		mlx5e_close_channel(priv->channel[i]);
  
++<<<<<<< HEAD
 +	kfree(priv->txq_to_sq_map);
 +	kfree(priv->channel);
++=======
+ 	for (i = 0; i < chs->num; i++)
+ 		mlx5e_close_channel(chs->c[i]);
+ 
+ 	kfree(chs->c);
+ 	chs->num = 0;
+ }
+ 
+ static int
+ mlx5e_create_rqt(struct mlx5e_priv *priv, int sz, struct mlx5e_rqt *rqt)
+ {
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	void *rqtc;
+ 	int inlen;
+ 	int err;
+ 	u32 *in;
+ 	int i;
+ 
+ 	inlen = MLX5_ST_SZ_BYTES(create_rqt_in) + sizeof(u32) * sz;
+ 	in = mlx5_vzalloc(inlen);
+ 	if (!in)
+ 		return -ENOMEM;
+ 
+ 	rqtc = MLX5_ADDR_OF(create_rqt_in, in, rqt_context);
+ 
+ 	MLX5_SET(rqtc, rqtc, rqt_actual_size, sz);
+ 	MLX5_SET(rqtc, rqtc, rqt_max_size, sz);
+ 
+ 	for (i = 0; i < sz; i++)
+ 		MLX5_SET(rqtc, rqtc, rq_num[i], priv->drop_rq.rqn);
+ 
+ 	err = mlx5_core_create_rqt(mdev, in, inlen, &rqt->rqtn);
+ 	if (!err)
+ 		rqt->enabled = true;
+ 
+ 	kvfree(in);
+ 	return err;
+ }
+ 
+ void mlx5e_destroy_rqt(struct mlx5e_priv *priv, struct mlx5e_rqt *rqt)
+ {
+ 	rqt->enabled = false;
+ 	mlx5_core_destroy_rqt(priv->mdev, rqt->rqtn);
+ }
+ 
+ int mlx5e_create_indirect_rqt(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5e_rqt *rqt = &priv->indir_rqt;
+ 	int err;
+ 
+ 	err = mlx5e_create_rqt(priv, MLX5E_INDIR_RQT_SIZE, rqt);
+ 	if (err)
+ 		mlx5_core_warn(priv->mdev, "create indirect rqts failed, %d\n", err);
+ 	return err;
+ }
+ 
+ int mlx5e_create_direct_rqts(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5e_rqt *rqt;
+ 	int err;
+ 	int ix;
+ 
+ 	for (ix = 0; ix < priv->profile->max_nch(priv->mdev); ix++) {
+ 		rqt = &priv->direct_tir[ix].rqt;
+ 		err = mlx5e_create_rqt(priv, 1 /*size */, rqt);
+ 		if (err)
+ 			goto err_destroy_rqts;
+ 	}
+ 
+ 	return 0;
+ 
+ err_destroy_rqts:
+ 	mlx5_core_warn(priv->mdev, "create direct rqts failed, %d\n", err);
+ 	for (ix--; ix >= 0; ix--)
+ 		mlx5e_destroy_rqt(priv, &priv->direct_tir[ix].rqt);
+ 
+ 	return err;
++>>>>>>> 8f493ffd88ea (net/mlx5e: IPoIB, RX steering RSS RQTs and TIRs)
+ }
+ 
+ void mlx5e_destroy_direct_rqts(struct mlx5e_priv *priv)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < priv->profile->max_nch(priv->mdev); i++)
+ 		mlx5e_destroy_rqt(priv, &priv->direct_tir[i].rqt);
  }
  
  static int mlx5e_rx_hash_fn(int hfunc)
@@@ -3309,6 -3809,66 +3398,69 @@@ u32 mlx5e_choose_lro_timeout(struct mlx
  	return MLX5_CAP_ETH(mdev, lro_timer_supported_periods[i]);
  }
  
++<<<<<<< HEAD
++=======
+ void mlx5e_build_nic_params(struct mlx5_core_dev *mdev,
+ 			    struct mlx5e_params *params,
+ 			    u16 max_channels)
+ {
+ 	u8 cq_period_mode = 0;
+ 	u32 link_speed = 0;
+ 	u32 pci_bw = 0;
+ 
+ 	params->num_channels = max_channels;
+ 	params->num_tc       = 1;
+ 
+ 	/* SQ */
+ 	params->log_sq_size = is_kdump_kernel() ?
+ 		MLX5E_PARAMS_MINIMUM_LOG_SQ_SIZE :
+ 		MLX5E_PARAMS_DEFAULT_LOG_SQ_SIZE;
+ 
+ 	/* set CQE compression */
+ 	params->rx_cqe_compress_def = false;
+ 	if (MLX5_CAP_GEN(mdev, cqe_compression) &&
+ 	     MLX5_CAP_GEN(mdev, vport_group_manager)) {
+ 		mlx5e_get_max_linkspeed(mdev, &link_speed);
+ 		mlx5e_get_pci_bw(mdev, &pci_bw);
+ 		mlx5_core_dbg(mdev, "Max link speed = %d, PCI BW = %d\n",
+ 			       link_speed, pci_bw);
+ 		params->rx_cqe_compress_def = cqe_compress_heuristic(link_speed, pci_bw);
+ 	}
+ 	MLX5E_SET_PFLAG(params, MLX5E_PFLAG_RX_CQE_COMPRESS, params->rx_cqe_compress_def);
+ 
+ 	/* RQ */
+ 	mlx5e_set_rq_params(mdev, params);
+ 
+ 	/* HW LRO */
+ 	if (params->rq_wq_type == MLX5_WQ_TYPE_LINKED_LIST_STRIDING_RQ)
+ 		params->lro_en = true;
+ 	params->lro_timeout = mlx5e_choose_lro_timeout(mdev, MLX5E_DEFAULT_LRO_TIMEOUT);
+ 
+ 	/* CQ moderation params */
+ 	cq_period_mode = MLX5_CAP_GEN(mdev, cq_period_start_from_cqe) ?
+ 			MLX5_CQ_PERIOD_MODE_START_FROM_CQE :
+ 			MLX5_CQ_PERIOD_MODE_START_FROM_EQE;
+ 	params->rx_am_enabled = MLX5_CAP_GEN(mdev, cq_moderation);
+ 	mlx5e_set_rx_cq_mode_params(params, cq_period_mode);
+ 
+ 	params->tx_cq_moderation.usec = MLX5E_PARAMS_DEFAULT_TX_CQ_MODERATION_USEC;
+ 	params->tx_cq_moderation.pkts = MLX5E_PARAMS_DEFAULT_TX_CQ_MODERATION_PKTS;
+ 
+ 	/* TX inline */
+ 	params->tx_max_inline = mlx5e_get_max_inline_cap(mdev);
+ 	mlx5_query_min_inline(mdev, &params->tx_min_inline_mode);
+ 	if (params->tx_min_inline_mode == MLX5_INLINE_MODE_NONE &&
+ 	    !MLX5_CAP_ETH(mdev, wqe_vlan_insert))
+ 		params->tx_min_inline_mode = MLX5_INLINE_MODE_L2;
+ 
+ 	/* RSS */
+ 	params->rss_hfunc = ETH_RSS_HASH_XOR;
+ 	netdev_rss_key_fill(params->toeplitz_hash_key, sizeof(params->toeplitz_hash_key));
+ 	mlx5e_build_default_indir_rqt(mdev, params->indirection_rqt,
+ 				      MLX5E_INDIR_RQT_SIZE, max_channels);
+ }
+ 
++>>>>>>> 8f493ffd88ea (net/mlx5e: IPoIB, RX steering RSS RQTs and TIRs)
  static void mlx5e_build_nic_netdev_priv(struct mlx5_core_dev *mdev,
  					struct net_device *netdev,
  					const struct mlx5e_profile *profile,
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index abcb1976163d,da85b0ad3e92..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -470,22 -465,18 +470,16 @@@ static int mlx5e_init_rep_rx(struct mlx
  {
  	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
  	struct mlx5_eswitch_rep *rep = priv->ppriv;
- 	struct mlx5_core_dev *mdev = priv->mdev;
  	struct mlx5_flow_handle *flow_rule;
  	int err;
- 	int i;
  
 -	mlx5e_init_l2_addr(priv);
 -
  	err = mlx5e_create_direct_rqts(priv);
- 	if (err) {
- 		mlx5_core_warn(mdev, "create direct rqts failed, %d\n", err);
+ 	if (err)
  		return err;
- 	}
  
  	err = mlx5e_create_direct_tirs(priv);
- 	if (err) {
- 		mlx5_core_warn(mdev, "create direct tirs failed, %d\n", err);
+ 	if (err)
  		goto err_destroy_direct_rqts;
- 	}
  
  	flow_rule = mlx5_eswitch_create_vport_rx_rule(esw,
  						      rep->vport,
@@@ -507,8 -498,7 +501,12 @@@ err_del_flow_rule
  err_destroy_direct_tirs:
  	mlx5e_destroy_direct_tirs(priv);
  err_destroy_direct_rqts:
++<<<<<<< HEAD
 +	for (i = 0; i < priv->params.num_channels; i++)
 +		mlx5e_destroy_rqt(priv, &priv->direct_tir[i].rqt);
++=======
+ 	mlx5e_destroy_direct_rqts(priv);
++>>>>>>> 8f493ffd88ea (net/mlx5e: IPoIB, RX steering RSS RQTs and TIRs)
  	return err;
  }
  
@@@ -520,8 -509,7 +517,12 @@@ static void mlx5e_cleanup_rep_rx(struc
  	mlx5e_tc_cleanup(priv);
  	mlx5_del_flow_rules(rep->vport_rx_rule);
  	mlx5e_destroy_direct_tirs(priv);
++<<<<<<< HEAD
 +	for (i = 0; i < priv->params.num_channels; i++)
 +		mlx5e_destroy_rqt(priv, &priv->direct_tir[i].rqt);
++=======
+ 	mlx5e_destroy_direct_rqts(priv);
++>>>>>>> 8f493ffd88ea (net/mlx5e: IPoIB, RX steering RSS RQTs and TIRs)
  }
  
  static int mlx5e_init_rep_tx(struct mlx5e_priv *priv)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/ipoib.c b/drivers/net/ethernet/mellanox/mlx5/core/ipoib.c
index 2f65927a8d03..f0318920844e 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/ipoib.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/ipoib.c
@@ -44,8 +44,15 @@ static void mlx5i_init(struct mlx5_core_dev *mdev,
 {
 	struct mlx5e_priv *priv  = mlx5i_epriv(netdev);
 
-	priv->ppriv = ppriv;
-	/*  TODO: init netdev and mlx5e_params here */
+	priv->mdev        = mdev;
+	priv->netdev      = netdev;
+	priv->profile     = profile;
+	priv->ppriv       = ppriv;
+
+	mlx5e_build_nic_params(mdev, &priv->channels.params, profile->max_nch(mdev));
+
+	mutex_init(&priv->state_lock);
+	/* TODO : init netdev features here */
 }
 
 /* Called directly before IPoIB netdevice is destroyed to cleanup SW structs */
@@ -67,12 +74,41 @@ static void mlx5i_cleanup_tx(struct mlx5e_priv *priv)
 
 static int mlx5i_init_rx(struct mlx5e_priv *priv)
 {
-	/* TODO: create IPoIB RX HW steering contexts */
+	int err;
+
+	err = mlx5e_create_indirect_rqt(priv);
+	if (err)
+		return err;
+
+	err = mlx5e_create_direct_rqts(priv);
+	if (err)
+		goto err_destroy_indirect_rqts;
+
+	err = mlx5e_create_indirect_tirs(priv);
+	if (err)
+		goto err_destroy_direct_rqts;
+
+	err = mlx5e_create_direct_tirs(priv);
+	if (err)
+		goto err_destroy_indirect_tirs;
+
 	return 0;
+
+err_destroy_indirect_tirs:
+	mlx5e_destroy_indirect_tirs(priv);
+err_destroy_direct_rqts:
+	mlx5e_destroy_direct_rqts(priv);
+err_destroy_indirect_rqts:
+	mlx5e_destroy_rqt(priv, &priv->indir_rqt);
+	return err;
 }
 
 static void mlx5i_cleanup_rx(struct mlx5e_priv *priv)
 {
+	mlx5e_destroy_direct_tirs(priv);
+	mlx5e_destroy_indirect_tirs(priv);
+	mlx5e_destroy_direct_rqts(priv);
+	mlx5e_destroy_rqt(priv, &priv->indir_rqt);
 }
 
 static const struct mlx5e_profile mlx5i_nic_profile = {
