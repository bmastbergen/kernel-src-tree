drm/amdgpu: reserve root PD while releasing it

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Christian König <christian.koenig@amd.com>
commit 2642cf110d08a403f585a051e4cbf45a90b3adea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2642cf11.failed

Otherwise somebody could try to evict it at the same time and try to use
half torn down structures.

	Signed-off-by: Christian König <christian.koenig@amd.com>
Reviewed-and-Tested-by: Michel Dänzer <michel.daenzer@amd.com>
	Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit 2642cf110d08a403f585a051e4cbf45a90b3adea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
diff --cc drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
index 1dda9321bd5a,010d14195a5e..000000000000
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
@@@ -1604,7 -2758,22 +1604,14 @@@ err
  void amdgpu_vm_fini(struct amdgpu_device *adev, struct amdgpu_vm *vm)
  {
  	struct amdgpu_bo_va_mapping *mapping, *tmp;
++<<<<<<< HEAD
 +	int i;
++=======
+ 	bool prt_fini_needed = !!adev->gart.gart_funcs->set_prt;
+ 	struct amdgpu_bo *root;
+ 	u64 fault;
+ 	int i, r;
 -
 -	/* Clear pending page faults from IH when the VM is destroyed */
 -	while (kfifo_get(&vm->faults, &fault))
 -		amdgpu_ih_clear_fault(adev, fault);
 -
 -	if (vm->pasid) {
 -		unsigned long flags;
 -
 -		spin_lock_irqsave(&adev->vm_manager.pasid_lock, flags);
 -		idr_remove(&adev->vm_manager.pasid_idr, vm->pasid);
 -		spin_unlock_irqrestore(&adev->vm_manager.pasid_lock, flags);
 -	}
++>>>>>>> 2642cf110d08 (drm/amdgpu: reserve root PD while releasing it)
  
  	amd_sched_entity_fini(vm->entity.sched, &vm->entity);
  
@@@ -1617,24 -2787,57 +1624,40 @@@
  		kfree(mapping);
  	}
  	list_for_each_entry_safe(mapping, tmp, &vm->freed, list) {
 -		if (mapping->flags & AMDGPU_PTE_PRT && prt_fini_needed) {
 -			amdgpu_vm_prt_fini(adev, vm);
 -			prt_fini_needed = false;
 -		}
 -
  		list_del(&mapping->list);
 -		amdgpu_vm_free_mapping(adev, vm, mapping, NULL);
 +		kfree(mapping);
  	}
  
++<<<<<<< HEAD
 +	for (i = 0; i < amdgpu_vm_num_pdes(adev); i++) {
 +		struct amdgpu_bo *pt = vm->page_tables[i].bo;
++=======
+ 	root = amdgpu_bo_ref(vm->root.base.bo);
+ 	r = amdgpu_bo_reserve(root, true);
+ 	if (r) {
+ 		dev_err(adev->dev, "Leaking page tables because BO reservation failed\n");
+ 	} else {
+ 		amdgpu_vm_free_levels(&vm->root);
+ 		amdgpu_bo_unreserve(root);
+ 	}
+ 	amdgpu_bo_unref(&root);
+ 	dma_fence_put(vm->last_update);
+ 	for (i = 0; i < AMDGPU_MAX_VMHUBS; i++)
+ 		amdgpu_vm_free_reserved_vmid(adev, vm, i);
+ }
++>>>>>>> 2642cf110d08 (drm/amdgpu: reserve root PD while releasing it)
  
 -/**
 - * amdgpu_vm_pasid_fault_credit - Check fault credit for given PASID
 - *
 - * @adev: amdgpu_device pointer
 - * @pasid: PASID do identify the VM
 - *
 - * This function is expected to be called in interrupt context. Returns
 - * true if there was fault credit, false otherwise
 - */
 -bool amdgpu_vm_pasid_fault_credit(struct amdgpu_device *adev,
 -				  unsigned int pasid)
 -{
 -	struct amdgpu_vm *vm;
 -
 -	spin_lock(&adev->vm_manager.pasid_lock);
 -	vm = idr_find(&adev->vm_manager.pasid_idr, pasid);
 -	spin_unlock(&adev->vm_manager.pasid_lock);
 -	if (!vm)
 -		/* VM not found, can't track fault credit */
 -		return true;
 +		if (!pt)
 +			continue;
  
 -	/* No lock needed. only accessed by IRQ handler */
 -	if (!vm->fault_credit)
 -		/* Too many faults in this VM */
 -		return false;
 +		amdgpu_bo_unref(&pt->shadow);
 +		amdgpu_bo_unref(&pt);
 +	}
 +	drm_free_large(vm->page_tables);
  
 -	vm->fault_credit--;
 -	return true;
 +	amdgpu_bo_unref(&vm->page_directory->shadow);
 +	amdgpu_bo_unref(&vm->page_directory);
 +	dma_fence_put(vm->page_directory_fence);
  }
  
  /**
* Unmerged path drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
