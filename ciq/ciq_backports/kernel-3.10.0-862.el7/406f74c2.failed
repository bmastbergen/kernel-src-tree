tcmu: fix sense handling during completion

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [tcmu] fix sense handling during completion (Mike Christie) [1412979]
Rebuild_FUZZ: 92.31%
commit-author Mike Christie <mchristi@redhat.com>
commit 406f74c20dc258f8258b64d16d159c3fff06a506
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/406f74c2.failed

We were just copying the sense to the cmd sense_buffer and
did not implement a transport_complete or set the
SCF_TRANSPORT_TASK_SENSE, so the sense was ignored.

	Signed-off-by: Mike Christie <mchristi@redhat.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 406f74c20dc258f8258b64d16d159c3fff06a506)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_user.c
diff --cc drivers/target/target_core_user.c
index 7dc2f05f8e5e,cbbfba0c1352..000000000000
--- a/drivers/target/target_core_user.c
+++ b/drivers/target/target_core_user.c
@@@ -715,26 -956,14 +715,30 @@@ static void tcmu_handle_completion(stru
  			cmd->se_cmd);
  		entry->rsp.scsi_status = SAM_STAT_CHECK_CONDITION;
  	} else if (entry->rsp.scsi_status == SAM_STAT_CHECK_CONDITION) {
++<<<<<<< HEAD
 +		memcpy(se_cmd->sense_buffer, entry->rsp.sense_buffer,
 +			       se_cmd->scsi_sense_length);
 +		free_data_area(udev, cmd);
++=======
+ 		transport_copy_sense_to_cmd(se_cmd, entry->rsp.sense_buffer);
++>>>>>>> 406f74c20dc2 (tcmu: fix sense handling during completion)
  	} else if (se_cmd->se_cmd_flags & SCF_BIDI) {
 +		DECLARE_BITMAP(bitmap, DATA_BLOCK_BITS);
 +
  		/* Get Data-In buffer before clean up */
 -		gather_data_area(udev, cmd, true);
 +		bitmap_copy(bitmap, cmd->data_bitmap, DATA_BLOCK_BITS);
 +		gather_data_area(udev, bitmap,
 +			se_cmd->t_bidi_data_sg, se_cmd->t_bidi_data_nents);
 +		free_data_area(udev, cmd);
  	} else if (se_cmd->data_direction == DMA_FROM_DEVICE) {
 -		gather_data_area(udev, cmd, false);
 +		DECLARE_BITMAP(bitmap, DATA_BLOCK_BITS);
 +
 +		bitmap_copy(bitmap, cmd->data_bitmap, DATA_BLOCK_BITS);
 +		gather_data_area(udev, bitmap,
 +			se_cmd->t_data_sg, se_cmd->t_data_nents);
 +		free_data_area(udev, cmd);
  	} else if (se_cmd->data_direction == DMA_TO_DEVICE) {
 -		/* TODO: */
 +		free_data_area(udev, cmd);
  	} else if (se_cmd->data_direction != DMA_NONE) {
  		pr_warn("TCMU: data direction was %d!\n",
  			se_cmd->data_direction);
* Unmerged path drivers/target/target_core_user.c
