ipv6: expose RFC4191 route preference via rtnetlink

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Lubomir Rintel <lkundrak@v3.sk>
commit c78ba6d64c78634a875d1e316676667cabfea256
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c78ba6d6.failed

This makes it possible to retain the route preference when RAs are handled in
userspace.

	Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>
	Reviewed-by: Jiri Pirko <jiri@resnulli.us>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c78ba6d64c78634a875d1e316676667cabfea256)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/rtnetlink.h
#	net/ipv6/route.c
diff --cc include/uapi/linux/rtnetlink.h
index d8701000036f,bea910f924dd..000000000000
--- a/include/uapi/linux/rtnetlink.h
+++ b/include/uapi/linux/rtnetlink.h
@@@ -309,13 -303,9 +309,19 @@@ enum rtattr_type_t 
  	RTA_TABLE,
  	RTA_MARK,
  	RTA_MFC_STATS,
++<<<<<<< HEAD
 +	__RH_RESERVED_RTA_VIA,
 +	__RH_RESERVED_RTA_NEWDST,
 +	__RH_RESERVED_RTA_PREF,
 +	RTA_ENCAP_TYPE,
 +	RTA_ENCAP,
 +	RTA_EXPIRES,
 +	RTA_PAD,
++=======
+ 	RTA_VIA,
+ 	RTA_NEWDST,
+ 	RTA_PREF,
++>>>>>>> c78ba6d64c78 (ipv6: expose RFC4191 route preference via rtnetlink)
  	__RTA_MAX
  };
  
diff --cc net/ipv6/route.c
index bac9d71c26f1,58c0e6a4d15d..000000000000
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@@ -2746,9 -2398,7 +2746,13 @@@ static const struct nla_policy rtm_ipv6
  	[RTA_PRIORITY]          = { .type = NLA_U32 },
  	[RTA_METRICS]           = { .type = NLA_NESTED },
  	[RTA_MULTIPATH]		= { .len = sizeof(struct rtnexthop) },
++<<<<<<< HEAD
 +	[RTA_ENCAP_TYPE]	= { .type = NLA_U16 },
 +	[RTA_ENCAP]		= { .type = NLA_NESTED },
 +	[RTA_EXPIRES]           = { .type = NLA_U32 },
++=======
+ 	[RTA_PREF]              = { .type = NLA_U8 },
++>>>>>>> c78ba6d64c78 (ipv6: expose RFC4191 route preference via rtnetlink)
  };
  
  static int rtm_to_fib6_config(struct sk_buff *skb, struct nlmsghdr *nlh,
@@@ -2834,21 -2482,14 +2839,32 @@@
  		cfg->fc_mp_len = nla_len(tb[RTA_MULTIPATH]);
  	}
  
++<<<<<<< HEAD
 +	if (tb[RTA_EXPIRES]) {
 +		unsigned long timeout = addrconf_timeout_fixup(nla_get_u32(tb[RTA_EXPIRES]), HZ);
 +
 +		if (addrconf_finite_timeout(timeout)) {
 +			cfg->fc_expires = jiffies_to_clock_t(timeout * HZ);
 +			cfg->fc_flags |= RTF_EXPIRES;
 +		}
 +	}
 +
 +	if (tb[RTA_ENCAP])
 +		cfg->fc_encap = tb[RTA_ENCAP];
 +
 +	if (tb[RTA_ENCAP_TYPE])
 +		cfg->fc_encap_type = nla_get_u16(tb[RTA_ENCAP_TYPE]);
 +
++=======
+ 	if (tb[RTA_PREF]) {
+ 		pref = nla_get_u8(tb[RTA_PREF]);
+ 		if (pref != ICMPV6_ROUTER_PREF_LOW &&
+ 		    pref != ICMPV6_ROUTER_PREF_HIGH)
+ 			pref = ICMPV6_ROUTER_PREF_MEDIUM;
+ 		cfg->fc_flags |= RTF_PREF(pref);
+ 	}
+ 
++>>>>>>> c78ba6d64c78 (ipv6: expose RFC4191 route preference via rtnetlink)
  	err = 0;
  errout:
  	return err;
@@@ -3086,8 -2593,8 +3102,13 @@@ static inline size_t rt6_nlmsg_size(str
  	       + nla_total_size(4) /* RTA_PRIORITY */
  	       + RTAX_MAX * nla_total_size(4) /* RTA_METRICS */
  	       + nla_total_size(sizeof(struct rta_cacheinfo))
++<<<<<<< HEAD
 +	       + nla_total_size(TCP_CA_NAME_MAX)  /* RTAX_CC_ALGO */
 +	       + lwtunnel_get_encap_size(rt->dst.lwtstate);
++=======
+ 	       + nla_total_size(TCP_CA_NAME_MAX) /* RTAX_CC_ALGO */
+ 	       + nla_total_size(1); /* RTA_PREF */
++>>>>>>> c78ba6d64c78 (ipv6: expose RFC4191 route preference via rtnetlink)
  }
  
  static int rt6_fill_node(struct net *net,
@@@ -3232,7 -2735,8 +3253,12 @@@
  	if (rtnl_put_cacheinfo(skb, &rt->dst, 0, expires, rt->dst.error) < 0)
  		goto nla_put_failure;
  
++<<<<<<< HEAD
 +	lwtunnel_fill_encap(skb, rt->dst.lwtstate);
++=======
+ 	if (nla_put_u8(skb, RTA_PREF, IPV6_EXTRACT_PREF(rt->rt6i_flags)))
+ 		goto nla_put_failure;
++>>>>>>> c78ba6d64c78 (ipv6: expose RFC4191 route preference via rtnetlink)
  
  	nlmsg_end(skb, nlh);
  	return 0;
* Unmerged path include/uapi/linux/rtnetlink.h
* Unmerged path net/ipv6/route.c
