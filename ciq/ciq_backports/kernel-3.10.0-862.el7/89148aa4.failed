radix-tree: tidy up __radix_tree_create()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Matthew Wilcox <willy@linux.intel.com>
commit 89148aa40201def3fa552f9d07dd99740d880ab2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/89148aa4.failed

1. Rename the existing variable 'slot' to 'child'.
2. Introduce a new variable called 'slot' which is the address of the
   slot we're dealing with.  This lets us simplify the tree insertion,
   and removes the recalculation of 'slot' at the end of the function.
3. Using 'slot' in the sibling pointer insertion part makes the code
   more readable.

	Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
	Cc: Konstantin Khlebnikov <koct9i@gmail.com>
	Cc: Kirill Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Jan Kara <jack@suse.com>
	Cc: Neil Brown <neilb@suse.de>
	Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 89148aa40201def3fa552f9d07dd99740d880ab2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/radix-tree.c
diff --cc lib/radix-tree.c
index 467d6e0a3a58,9d9b4b9af4b6..000000000000
--- a/lib/radix-tree.c
+++ b/lib/radix-tree.c
@@@ -493,12 -499,13 +493,17 @@@ int __radix_tree_create(struct radix_tr
  			unsigned order, struct radix_tree_node **nodep,
  			void ***slotp)
  {
- 	struct radix_tree_node *node = NULL, *slot;
+ 	struct radix_tree_node *node = NULL, *child;
+ 	void **slot = (void **)&root->rnode;
  	unsigned long maxindex;
++<<<<<<< HEAD
 +	unsigned int height, shift, offset;
++=======
+ 	unsigned int shift, offset = 0;
++>>>>>>> 89148aa40201 (radix-tree: tidy up __radix_tree_create())
  	unsigned long max = index | ((1UL << order) - 1);
  
- 	shift = radix_tree_load_root(root, &slot, &maxindex);
+ 	shift = radix_tree_load_root(root, &child, &maxindex);
  
  	/* Make sure the tree is high enough.  */
  	if (max > maxindex) {
@@@ -506,49 -513,43 +511,83 @@@
  		if (error < 0)
  			return error;
  		shift = error;
++<<<<<<< HEAD
 +		slot = root->rnode;
 +		if (order == shift) {
++=======
+ 		child = root->rnode;
+ 		if (order == shift)
++>>>>>>> 89148aa40201 (radix-tree: tidy up __radix_tree_create())
  			shift += RADIX_TREE_MAP_SHIFT;
 +			root->height++;
 +		}
  	}
  
++<<<<<<< HEAD
 +	height = root->height;
 +
 +	offset = 0;			/* uninitialised var warning */
 +	while (shift > order) {
 +		if (slot == NULL) {
 +			/* Have to add a child node.  */
 +			if (!(slot = radix_tree_node_alloc(root)))
 +				return -ENOMEM;
 +			slot->path = height;
 +			slot->parent = node;
 +			if (node) {
 +				rcu_assign_pointer(node->slots[offset],
 +							ptr_to_indirect(slot));
 +				node->count++;
 +				slot->path |= offset << RADIX_TREE_HEIGHT_SHIFT;
 +			} else
 +				rcu_assign_pointer(root->rnode,
 +							ptr_to_indirect(slot));
 +		} else if (!radix_tree_is_indirect_ptr(slot))
 +			break;
 +
 +		/* Go a level down */
 +		height--;
 +		shift -= RADIX_TREE_MAP_SHIFT;
 +		offset = (index >> shift) & RADIX_TREE_MAP_MASK;
 +		node = indirect_to_ptr(slot);
 +		slot = node->slots[offset];
++=======
+ 	while (shift > order) {
+ 		shift -= RADIX_TREE_MAP_SHIFT;
+ 		if (child == NULL) {
+ 			/* Have to add a child node.  */
+ 			child = radix_tree_node_alloc(root);
+ 			if (!child)
+ 				return -ENOMEM;
+ 			child->shift = shift;
+ 			child->offset = offset;
+ 			child->parent = node;
+ 			rcu_assign_pointer(*slot, node_to_entry(child));
+ 			if (node)
+ 				node->count++;
+ 		} else if (!radix_tree_is_internal_node(child))
+ 			break;
+ 
+ 		/* Go a level down */
+ 		node = entry_to_node(child);
+ 		offset = (index >> shift) & RADIX_TREE_MAP_MASK;
+ 		offset = radix_tree_descend(node, &child, offset);
+ 		slot = &node->slots[offset];
++>>>>>>> 89148aa40201 (radix-tree: tidy up __radix_tree_create())
  	}
  
 -#ifdef CONFIG_RADIX_TREE_MULTIORDER
  	/* Insert pointers to the canonical entry */
  	if (order > shift) {
- 		int i, n = 1 << (order - shift);
+ 		unsigned i, n = 1 << (order - shift);
  		offset = offset & ~(n - 1);
++<<<<<<< HEAD
 +		slot = ptr_to_indirect(&node->slots[offset]);
++=======
+ 		slot = &node->slots[offset];
+ 		child = node_to_entry(slot);
++>>>>>>> 89148aa40201 (radix-tree: tidy up __radix_tree_create())
  		for (i = 0; i < n; i++) {
- 			if (node->slots[offset + i])
+ 			if (slot[i])
  				return -EEXIST;
  		}
  
* Unmerged path lib/radix-tree.c
