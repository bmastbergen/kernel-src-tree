ip6_gre: skb_push ipv6hdr before packing the header in ip6gre_header

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Xin Long <lucien.xin@gmail.com>
commit 76cc0d3282d4b933fa144fa41fbc5318e0fdca24
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/76cc0d32.failed

Now in ip6gre_header before packing the ipv6 header, it skb_push t->hlen
which only includes encap_hlen + tun_hlen. It means greh and inner header
would be over written by ipv6 stuff and ipv6h might have no chance to set
up.

Jianlin found this issue when using remote any on ip6_gre, the packets he
captured on gre dev are truncated:

22:50:26.210866 Out ethertype IPv6 (0x86dd), length 120: truncated-ip6 -\
8128 bytes missing!(flowlabel 0x92f40, hlim 0, next-header Options (0)  \
payload length: 8192) ::1:2000:0 > ::1:0:86dd: HBH [trunc] ip-proto-128 \
8184

It should also skb_push ipv6hdr so that ipv6h points to the right position
to set ipv6 stuff up.

This patch is to skb_push hlen + sizeof(*ipv6h) and also fix some indents
in ip6gre_header.

Fixes: c12b395a4664 ("gre: Support GRE over IPv6")
	Reported-by: Jianlin Shi <jishi@redhat.com>
	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 76cc0d3282d4b933fa144fa41fbc5318e0fdca24)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_gre.c
diff --cc net/ipv6/ip6_gre.c
index 98dccbd41025,20f66f4c9460..000000000000
--- a/net/ipv6/ip6_gre.c
+++ b/net/ipv6/ip6_gre.c
@@@ -933,14 -940,17 +933,24 @@@ done
  }
  
  static int ip6gre_header(struct sk_buff *skb, struct net_device *dev,
- 			unsigned short type,
- 			const void *daddr, const void *saddr, unsigned int len)
+ 			 unsigned short type, const void *daddr,
+ 			 const void *saddr, unsigned int len)
  {
  	struct ip6_tnl *t = netdev_priv(dev);
++<<<<<<< HEAD
 +	struct ipv6hdr *ipv6h = (struct ipv6hdr *)skb_push(skb, t->hlen);
 +	__be16 *p = (__be16 *)(ipv6h+1);
 +
 +	ip6_flow_hdr(ipv6h, 0, t->fl.u.ip6.flowlabel);
++=======
+ 	struct ipv6hdr *ipv6h;
+ 	__be16 *p;
+ 
+ 	ipv6h = skb_push(skb, t->hlen + sizeof(*ipv6h));
+ 	ip6_flow_hdr(ipv6h, 0, ip6_make_flowlabel(dev_net(dev), skb,
+ 						  t->fl.u.ip6.flowlabel,
+ 						  true, &t->fl.u.ip6));
++>>>>>>> 76cc0d3282d4 (ip6_gre: skb_push ipv6hdr before packing the header in ip6gre_header)
  	ipv6h->hop_limit = t->parms.hop_limit;
  	ipv6h->nexthdr = NEXTHDR_GRE;
  	ipv6h->saddr = t->parms.laddr;
* Unmerged path net/ipv6/ip6_gre.c
