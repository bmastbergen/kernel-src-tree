hv_netvsc: Fix the queue index computation in forwarding case

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Haiyang Zhang <haiyangz@microsoft.com>
commit 8db91f6a9b2ff2bb5355ad11c668fe63eb8ae0c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8db91f6a.failed

If the outgoing skb has a RX queue mapping available, we use the queue
number directly, other than put it through Send Indirection Table.

	Signed-off-by: Haiyang Zhang <haiyangz@microsoft.com>
	Reviewed-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8db91f6a9b2ff2bb5355ad11c668fe63eb8ae0c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/netvsc_drv.c
diff --cc drivers/net/hyperv/netvsc_drv.c
index 1f2fdf8f9b74,e813eaf69256..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -214,30 -221,23 +232,48 @@@ static inline int netvsc_get_tx_queue(s
   * TODO support XPS - but get_xps_queue not exported
   */
  static u16 netvsc_select_queue(struct net_device *ndev, struct sk_buff *skb,
 -			void *accel_priv, select_queue_fallback_t fallback)
 +		       void *accel_priv, select_queue_fallback_t fallback)
  {
++<<<<<<< HEAD
 +	struct net_device_context *net_device_ctx = netdev_priv(ndev);
 +	struct netvsc_device *nvsc_dev = net_device_ctx->nvdev;
 +	struct sock *sk = skb->sk;
 +	int q_idx = sk_tx_queue_get(sk);
 +
 +	if (q_idx < 0 || skb->ooo_okay ||
 +	    q_idx >= ndev->real_num_tx_queues) {
 +		u16 hash = __skb_tx_hash(ndev, skb, VRSS_SEND_TAB_SIZE);
 +		int new_idx;
 +
 +		new_idx = nvsc_dev->send_table[hash]
 +			% nvsc_dev->num_chn;
 +
 +		if (q_idx != new_idx && sk &&
 +		    sk_fullsock(sk) && rcu_access_pointer(sk->sk_dst_cache))
 +			sk_tx_queue_set(sk, new_idx);
 +
 +		q_idx = new_idx;
 +	}
 +
 +	if (unlikely(!nvsc_dev->chn_table[q_idx]))
 +		q_idx = 0;
++=======
+ 	unsigned int num_tx_queues = ndev->real_num_tx_queues;
+ 	int q_idx = sk_tx_queue_get(skb->sk);
+ 
+ 	if (q_idx < 0 || skb->ooo_okay) {
+ 		/* If forwarding a packet, we use the recorded queue when
+ 		 * available for better cache locality.
+ 		 */
+ 		if (skb_rx_queue_recorded(skb))
+ 			q_idx = skb_get_rx_queue(skb);
+ 		else
+ 			q_idx = netvsc_get_tx_queue(ndev, skb, q_idx);
+ 	}
+ 
+ 	while (unlikely(q_idx >= num_tx_queues))
+ 		q_idx -= num_tx_queues;
++>>>>>>> 8db91f6a9b2f (hv_netvsc: Fix the queue index computation in forwarding case)
  
  	return q_idx;
  }
diff --git a/drivers/net/hyperv/hyperv_net.h b/drivers/net/hyperv/hyperv_net.h
index 34a80d16df32..709750b1bba1 100644
--- a/drivers/net/hyperv/hyperv_net.h
+++ b/drivers/net/hyperv/hyperv_net.h
@@ -630,7 +630,7 @@ struct nvsp_message {
 
 #define NETVSC_PACKET_SIZE                      4096
 
-#define VRSS_SEND_TAB_SIZE 16
+#define VRSS_SEND_TAB_SIZE 16  /* must be power of 2 */
 #define VRSS_CHANNEL_MAX 64
 
 #define RNDIS_MAX_PKT_DEFAULT 8
* Unmerged path drivers/net/hyperv/netvsc_drv.c
