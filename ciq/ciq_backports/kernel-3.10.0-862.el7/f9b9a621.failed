sysfs: prepare path write for unified regular / bin file handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Tejun Heo <tj@kernel.org>
commit f9b9a6217cf10fd5d3002627cc13c4789a777213
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f9b9a621.failed

sysfs bin file handling will be merged into the regular file support.
This patch prepares the write path.

bin file write is almost identical to regular file write except that
the write length is capped by the inode size and @off is passed to the
write method.  This patch adds bin file handling to sysfs_write_file()
so that it can handle both regular and bin files.

A new file_operations struct sysfs_bin_operations is added, which
currently only hosts sysfs_write_file() and generic_file_llseek().
This isn't used yet but will eventually replace fs/sysfs/bin.c.

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit f9b9a6217cf10fd5d3002627cc13c4789a777213)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/sysfs/file.c
diff --cc fs/sysfs/file.c
index d8887c896abc,b36473f21824..000000000000
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@@ -55,38 -54,76 +55,54 @@@ struct sysfs_buffer 
  	struct list_head	list;
  };
  
++<<<<<<< HEAD
 +/**
 + *	fill_read_buffer - allocate and fill buffer from object.
 + *	@dentry:	dentry pointer.
 + *	@buffer:	data buffer for file.
 + *
 + *	Allocate @buffer->page, if it hasn't been already, then call the
 + *	kobject's show() method to fill the buffer with this attribute's
 + *	data.
 + *	This is called only once, on the file's first read unless an error
 + *	is returned.
++=======
+ static bool sysfs_is_bin(struct sysfs_dirent *sd)
+ {
+ 	return sysfs_type(sd) == SYSFS_KOBJ_BIN_ATTR;
+ }
+ 
+ static struct sysfs_open_file *sysfs_of(struct file *file)
+ {
+ 	return ((struct seq_file *)file->private_data)->private;
+ }
+ 
+ /*
+  * Determine ktype->sysfs_ops for the given sysfs_dirent.  This function
+  * must be called while holding an active reference.
++>>>>>>> f9b9a6217cf1 (sysfs: prepare path write for unified regular / bin file handling)
   */
 -static const struct sysfs_ops *sysfs_file_ops(struct sysfs_dirent *sd)
 +static int fill_read_buffer(struct dentry * dentry, struct sysfs_buffer * buffer)
  {
 -	struct kobject *kobj = sd->s_parent->s_dir.kobj;
 -
 -	lockdep_assert_held(sd);
 -	return kobj->ktype ? kobj->ktype->sysfs_ops : NULL;
 -}
 -
 -/*
 - * Reads on sysfs are handled through seq_file, which takes care of hairy
 - * details like buffering and seeking.  The following function pipes
 - * sysfs_ops->show() result through seq_file.
 - */
 -static int sysfs_seq_show(struct seq_file *sf, void *v)
 -{
 -	struct sysfs_open_file *of = sf->private;
 -	struct kobject *kobj = of->sd->s_parent->s_dir.kobj;
 -	const struct sysfs_ops *ops;
 -	char *buf;
 +	struct sysfs_dirent *attr_sd = dentry->d_fsdata;
 +	struct kobject *kobj = attr_sd->s_parent->s_dir.kobj;
 +	const struct sysfs_ops * ops = buffer->ops;
 +	int ret = 0;
  	ssize_t count;
  
 -	/* acquire buffer and ensure that it's >= PAGE_SIZE */
 -	count = seq_get_buf(sf, &buf);
 -	if (count < PAGE_SIZE) {
 -		seq_commit(sf, -1);
 -		return 0;
 -	}
 +	if (!buffer->page)
 +		buffer->page = (char *) get_zeroed_page(GFP_KERNEL);
 +	if (!buffer->page)
 +		return -ENOMEM;
  
 -	/*
 -	 * Need @of->sd for attr and ops, its parent for kobj.  @of->mutex
 -	 * nests outside active ref and is just to ensure that the ops
 -	 * aren't called concurrently for the same open file.
 -	 */
 -	mutex_lock(&of->mutex);
 -	if (!sysfs_get_active(of->sd)) {
 -		mutex_unlock(&of->mutex);
 +	/* need attr_sd for attr and ops, its parent for kobj */
 +	if (!sysfs_get_active(attr_sd))
  		return -ENODEV;
 -	}
  
 -	of->event = atomic_read(&of->sd->s_attr.open->event);
 +	buffer->event = atomic_read(&attr_sd->s_attr.open->event);
 +	count = ops->show(kobj, attr_sd->s_attr.attr, buffer->page);
  
 -	/*
 -	 * Lookup @ops and invoke show().  Control may reach here via seq
 -	 * file lseek even if @ops->show() isn't implemented.
 -	 */
 -	ops = sysfs_file_ops(of->sd);
 -	if (ops->show)
 -		count = ops->show(kobj, of->sd->s_attr.attr, buf);
 -	else
 -		count = 0;
 -
 -	sysfs_put_active(of->sd);
 -	mutex_unlock(&of->mutex);
 -
 -	if (count < 0)
 -		return count;
 +	sysfs_put_active(attr_sd);
  
  	/*
  	 * The code works fine with PAGE_SIZE return but it's likely to
@@@ -108,135 -140,100 +124,195 @@@
  }
  
  /**
++<<<<<<< HEAD
 + *	sysfs_read_file - read an attribute.
 + *	@file:	file pointer.
 + *	@buf:	buffer to fill.
 + *	@count:	number of bytes to read.
 + *	@ppos:	starting offset in file.
++=======
+  * flush_write_buffer - push buffer to kobject
+  * @of: open file
+  * @buf: data buffer for file
+  * @off: file offset to write to
+  * @count: number of bytes
++>>>>>>> f9b9a6217cf1 (sysfs: prepare path write for unified regular / bin file handling)
 + *
 + *	Userspace wants to read an attribute file. The attribute descriptor
 + *	is in the file's ->d_fsdata. The target object is in the directory's
 + *	->d_fsdata.
   *
 - * Get the correct pointers for the kobject and the attribute we're dealing
 - * with, then call the store() method for it with @buf.
 + *	We call fill_read_buffer() to allocate and fill the buffer from the
 + *	object's show() method exactly once (if the read is happening from
 + *	the beginning of the file). That should fill the entire buffer with
 + *	all the data the object has to offer for that attribute.
 + *	We then call flush_read_buffer() to copy the buffer to userspace
 + *	in the increments specified.
   */
++<<<<<<< HEAD
 +
 +static ssize_t
 +sysfs_read_file(struct file *file, char __user *buf, size_t count, loff_t *ppos)
 +{
 +	struct sysfs_buffer * buffer = file->private_data;
 +	ssize_t retval = 0;
++=======
+ static int flush_write_buffer(struct sysfs_open_file *of, char *buf, loff_t off,
+ 			      size_t count)
+ {
+ 	struct kobject *kobj = of->sd->s_parent->s_dir.kobj;
+ 	int rc = 0;
++>>>>>>> f9b9a6217cf1 (sysfs: prepare path write for unified regular / bin file handling)
  
 -	/*
 -	 * Need @of->sd for attr and ops, its parent for kobj.  @of->mutex
 -	 * nests outside active ref and is just to ensure that the ops
 -	 * aren't called concurrently for the same open file.
 -	 */
 -	mutex_lock(&of->mutex);
 -	if (!sysfs_get_active(of->sd)) {
 -		mutex_unlock(&of->mutex);
 -		return -ENODEV;
 +	mutex_lock(&buffer->mutex);
 +	if (buffer->needs_read_fill || *ppos == 0) {
 +		retval = fill_read_buffer(file->f_path.dentry,buffer);
 +		if (retval)
 +			goto out;
  	}
 +	pr_debug("%s: count = %zd, ppos = %lld, buf = %s\n",
 +		 __func__, count, *ppos, buffer->page);
 +	retval = simple_read_from_buffer(buf, count, ppos, buffer->page,
 +					 buffer->count);
 +out:
 +	mutex_unlock(&buffer->mutex);
 +	return retval;
 +}
  
++<<<<<<< HEAD
 +/**
 + *	fill_write_buffer - copy buffer from userspace.
 + *	@buffer:	data buffer for file.
 + *	@buf:		data from user.
 + *	@count:		number of bytes in @userbuf.
 + *
 + *	Allocate @buffer->page if it hasn't been already, then
 + *	copy the user-supplied buffer into it.
 + */
 +static int fill_write_buffer(struct sysfs_buffer * buffer,
 +			     const char __user * buf, size_t count)
 +{
 +	int error;
++=======
+ 	if (sysfs_is_bin(of->sd)) {
+ 		struct bin_attribute *battr = of->sd->s_bin_attr.bin_attr;
+ 
+ 		rc = -EIO;
+ 		if (battr->write)
+ 			rc = battr->write(of->file, kobj, battr, buf, off,
+ 					  count);
+ 	} else {
+ 		const struct sysfs_ops *ops = sysfs_file_ops(of->sd);
+ 
+ 		rc = ops->store(kobj, of->sd->s_attr.attr, buf, count);
+ 	}
++>>>>>>> f9b9a6217cf1 (sysfs: prepare path write for unified regular / bin file handling)
  
 -	sysfs_put_active(of->sd);
 -	mutex_unlock(&of->mutex);
 +	if (!buffer->page)
 +		buffer->page = (char *)get_zeroed_page(GFP_KERNEL);
 +	if (!buffer->page)
 +		return -ENOMEM;
  
 -	return rc;
 +	if (count >= PAGE_SIZE)
 +		count = PAGE_SIZE - 1;
 +	error = copy_from_user(buffer->page,buf,count);
 +	buffer->needs_read_fill = 1;
 +	/* if buf is assumed to contain a string, terminate it by \0,
 +	   so e.g. sscanf() can scan the string easily */
 +	buffer->page[count] = 0;
 +	return error ? -EFAULT : count;
  }
  
 +
  /**
 - * sysfs_write_file - write an attribute
 - * @file: file pointer
 - * @user_buf: data to write
 - * @count: number of bytes
 - * @ppos: starting offset
 + *	flush_write_buffer - push buffer to kobject.
 + *	@dentry:	dentry to the attribute
 + *	@buffer:	data buffer for file.
 + *	@count:		number of bytes
   *
 - * Copy data in from userland and pass it to the matching
 - * sysfs_ops->store() by invoking flush_write_buffer().
 + *	Get the correct pointers for the kobject and the attribute we're
 + *	dealing with, then call the store() method for the attribute,
 + *	passing the buffer that we acquired in fill_write_buffer().
 + */
 +static int
 +flush_write_buffer(struct dentry * dentry, struct sysfs_buffer * buffer, size_t count)
 +{
 +	struct sysfs_dirent *attr_sd = dentry->d_fsdata;
 +	struct kobject *kobj = attr_sd->s_parent->s_dir.kobj;
 +	const struct sysfs_ops * ops = buffer->ops;
 +	int rc;
 +
 +	/* need attr_sd for attr and ops, its parent for kobj */
 +	if (!sysfs_get_active(attr_sd))
 +		return -ENODEV;
 +
 +	rc = ops->store(kobj, attr_sd->s_attr.attr, buffer->page, count);
 +
 +	sysfs_put_active(attr_sd);
 +
 +	return rc;
 +}
 +
 +
 +/**
 + *	sysfs_write_file - write an attribute.
 + *	@file:	file pointer
 + *	@buf:	data to write
 + *	@count:	number of bytes
 + *	@ppos:	starting offset
   *
 - * There is no easy way for us to know if userspace is only doing a partial
 - * write, so we don't support them. We expect the entire buffer to come on
 - * the first write.  Hint: if you're writing a value, first read the file,
 - * modify only the the value you're changing, then write entire buffer
 - * back.
 + *	Similar to sysfs_read_file(), though working in the opposite direction.
 + *	We allocate and fill the data from the user in fill_write_buffer(),
 + *	then push it to the kobject in flush_write_buffer().
 + *	There is no easy way for us to know if userspace is only doing a partial
 + *	write, so we don't support them. We expect the entire buffer to come
 + *	on the first write.
 + *	Hint: if you're writing a value, first read the file, modify only the
 + *	the value you're changing, then write entire buffer back.
   */
 -static ssize_t sysfs_write_file(struct file *file, const char __user *user_buf,
 -				size_t count, loff_t *ppos)
 +
 +static ssize_t
 +sysfs_write_file(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
  {
++<<<<<<< HEAD
 +	struct sysfs_buffer * buffer = file->private_data;
 +	ssize_t len;
 +
 +	mutex_lock(&buffer->mutex);
 +	len = fill_write_buffer(buffer, buf, count);
 +	if (len > 0)
 +		len = flush_write_buffer(file->f_path.dentry, buffer, len);
++=======
+ 	struct sysfs_open_file *of = sysfs_of(file);
+ 	ssize_t len = min_t(size_t, count, PAGE_SIZE);
+ 	char *buf;
+ 
+ 	if (sysfs_is_bin(of->sd)) {
+ 		loff_t size = file_inode(file)->i_size;
+ 
+ 		if (size <= *ppos)
+ 			return 0;
+ 		len = min_t(ssize_t, len, size - *ppos);
+ 	}
+ 
+ 	if (!len)
+ 		return 0;
+ 
+ 	buf = kmalloc(len + 1, GFP_KERNEL);
+ 	if (!buf)
+ 		return -ENOMEM;
+ 
+ 	if (copy_from_user(buf, user_buf, len)) {
+ 		len = -EFAULT;
+ 		goto out_free;
+ 	}
+ 	buf[len] = '\0';	/* guarantee string termination */
+ 
+ 	len = flush_write_buffer(of, buf, *ppos, len);
++>>>>>>> f9b9a6217cf1 (sysfs: prepare path write for unified regular / bin file handling)
  	if (len > 0)
  		*ppos += len;
 -out_free:
 -	kfree(buf);
 +	mutex_unlock(&buffer->mutex);
  	return len;
  }
  
@@@ -492,47 -494,14 +568,58 @@@ const struct file_operations sysfs_file
  	.poll		= sysfs_poll,
  };
  
++<<<<<<< HEAD
 +static int sysfs_attr_ns(struct kobject *kobj, const struct attribute *attr,
 +			 const void **pns)
 +{
 +	struct sysfs_dirent *dir_sd = kobj->sd;
 +	const struct sysfs_ops *ops;
 +	const void *ns = NULL;
 +	int err;
 +
 +	if (!dir_sd) {
 +		WARN(1, KERN_ERR "sysfs: kobject %s without dirent\n",
 +			kobject_name(kobj));
 +		return -ENOENT;
 +	}
 +
 +	err = 0;
 +	if (!sysfs_ns_type(dir_sd))
 +		goto out;
 +
 +	err = -EINVAL;
 +	if (!kobj->ktype)
 +		goto out;
 +	ops = kobj->ktype->sysfs_ops;
 +	if (!ops)
 +		goto out;
 +	if (!ops->namespace)
 +		goto out;
 +
 +	err = 0;
 +	ns = ops->namespace(kobj, attr);
 +out:
 +	if (err) {
 +		WARN(1, KERN_ERR
 +		     "missing sysfs namespace attribute operation for kobject: %s\n",
 +		     kobject_name(kobj));
 +	}
 +	*pns = ns;
 +	return err;
 +}
 +
 +int sysfs_add_file_mode(struct sysfs_dirent *dir_sd,
 +			const struct attribute *attr, int type, umode_t amode)
++=======
+ const struct file_operations sysfs_bin_operations = {
+ 	.write		= sysfs_write_file,
+ 	.llseek		= generic_file_llseek,
+ };
+ 
+ int sysfs_add_file_mode_ns(struct sysfs_dirent *dir_sd,
+ 			   const struct attribute *attr, int type,
+ 			   umode_t amode, const void *ns)
++>>>>>>> f9b9a6217cf1 (sysfs: prepare path write for unified regular / bin file handling)
  {
  	umode_t mode = (amode & S_IALLUGO) | S_IFREG;
  	struct sysfs_addrm_cxt acxt;
* Unmerged path fs/sysfs/file.c
diff --git a/fs/sysfs/sysfs.h b/fs/sysfs/sysfs.h
index b6deca3e301d..22cc606b3ecc 100644
--- a/fs/sysfs/sysfs.h
+++ b/fs/sysfs/sysfs.h
@@ -226,6 +226,7 @@ int sysfs_inode_init(void);
  * file.c
  */
 extern const struct file_operations sysfs_file_operations;
+extern const struct file_operations sysfs_bin_operations;
 
 int sysfs_add_file(struct sysfs_dirent *dir_sd,
 		   const struct attribute *attr, int type);
