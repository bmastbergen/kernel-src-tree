revert commit a8e5a2d593cb ("[SCSI] scsi_dh_alua: ALUA handler attach should succeed while TPG is transitioning")

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] revert commit a8e5a2d593cb ("[scsi] scsi_dh_alua: ALUA handler attach should succeed while TPG is transitioning") (Mike Snitzer) [1499107]
Rebuild_FUZZ: 96.80%
commit-author Hannes Reinecke <hare@suse.de>
commit 28261402ddae5e6753fc6e25fae9fe492b869898
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/28261402.failed

This reverts commit a8e5a2d593cbfccf530c3382c2c328d2edaa7b66

Obsoleted by the next patch.

	Reviewed-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Ewan Milne <emilne@redhat.com>
	Signed-off-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 28261402ddae5e6753fc6e25fae9fe492b869898)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/device_handler/scsi_dh_alua.c
diff --cc drivers/scsi/device_handler/scsi_dh_alua.c
index 9c9d9c3d8e9b,0ae25368ce44..000000000000
--- a/drivers/scsi/device_handler/scsi_dh_alua.c
+++ b/drivers/scsi/device_handler/scsi_dh_alua.c
@@@ -84,26 -92,18 +84,30 @@@ struct alua_dh_data 
  #define ALUA_POLICY_SWITCH_CURRENT	0
  #define ALUA_POLICY_SWITCH_ALL		1
  
++<<<<<<< HEAD
++=======
+ static int alua_rtpg(struct scsi_device *, struct alua_port_group *);
++>>>>>>> 28261402ddae (revert commit a8e5a2d593cb ("[SCSI] scsi_dh_alua: ALUA handler attach should succeed while TPG is transitioning"))
  static char print_alua_state(int);
  
 -static void release_port_group(struct kref *kref)
 +static inline struct alua_dh_data *get_alua_data(struct scsi_device *sdev)
  {
 -	struct alua_port_group *pg;
 +	return container_of(sdev->scsi_dh_data, struct alua_dh_data, dh_data);
 +}
  
 -	pg = container_of(kref, struct alua_port_group, kref);
 -	spin_lock(&port_group_lock);
 -	list_del(&pg->node);
 -	spin_unlock(&port_group_lock);
 -	kfree(pg);
 +static int realloc_buffer(struct alua_dh_data *h, unsigned len)
 +{
 +	if (h->buff && h->buff != h->inq)
 +		kfree(h->buff);
 +
 +	h->buff = kmalloc(len, GFP_NOIO);
 +	if (!h->buff) {
 +		h->buff = h->inq;
 +		h->bufflen = ALUA_INQUIRY_SIZE;
 +		return 1;
 +	}
 +	h->bufflen = len;
 +	return 0;
  }
  
  /*
@@@ -240,14 -312,21 +244,18 @@@ static int alua_check_vpd(struct scsi_d
  			    ALUA_DH_NAME);
  		return SCSI_DH_DEV_UNSUPP;
  	}
 -
 -	h->pg = alua_alloc_pg(sdev, group_id, tpgs);
 -	if (IS_ERR(h->pg)) {
 -		if (PTR_ERR(h->pg) == -ENOMEM)
 -			return SCSI_DH_NOMEM;
 -		return SCSI_DH_DEV_UNSUPP;
 -	}
 -	h->rel_port = rel_port;
 +	h->state = TPGS_STATE_OPTIMIZED;
 +	h->group_id = group_id;
  
  	sdev_printk(KERN_INFO, sdev,
 -		    "%s: device %s port group %x rel port %x\n",
 -		    ALUA_DH_NAME, h->pg->device_id_str,
 -		    h->group_id, h->rel_port);
 +		    "%s: port group %02x rel port %02x\n",
 +		    ALUA_DH_NAME, h->group_id, h->rel_port);
  
++<<<<<<< HEAD
 +	return 0;
++=======
+ 	return alua_rtpg(sdev, h->pg);
++>>>>>>> 28261402ddae (revert commit a8e5a2d593cb ("[SCSI] scsi_dh_alua: ALUA handler attach should succeed while TPG is transitioning"))
  }
  
  static char print_alua_state(int state)
@@@ -336,11 -414,11 +343,15 @@@ static int alua_check_sense(struct scsi
   * Returns SCSI_DH_DEV_OFFLINED if the path is
   * found to be unusable.
   */
++<<<<<<< HEAD
 +static int alua_rtpg(struct scsi_device *sdev, struct alua_dh_data *h, int wait_for_transition)
++=======
+ static int alua_rtpg(struct scsi_device *sdev, struct alua_port_group *pg)
++>>>>>>> 28261402ddae (revert commit a8e5a2d593cb ("[SCSI] scsi_dh_alua: ALUA handler attach should succeed while TPG is transitioning"))
  {
  	struct scsi_sense_hdr sense_hdr;
 -	int len, k, off, valid_states = 0, bufflen = ALUA_RTPG_SIZE;
 -	unsigned char *ucp, *buff;
 +	int len, k, off, valid_states = 0;
 +	unsigned char *ucp;
  	unsigned err, retval;
  	unsigned long expiry, interval = 0;
  	unsigned int tpg_desc_tbl_off;
@@@ -412,20 -499,20 +423,24 @@@
  		goto retry;
  	}
  
 -	orig_transition_tmo = pg->transition_tmo;
 -	if ((buff[4] & RTPG_FMT_MASK) == RTPG_FMT_EXT_HDR && buff[5] != 0)
 -		pg->transition_tmo = buff[5];
 +	orig_transition_tmo = h->transition_tmo;
 +	if ((h->buff[4] & RTPG_FMT_MASK) == RTPG_FMT_EXT_HDR && h->buff[5] != 0)
 +		h->transition_tmo = h->buff[5];
  	else
 -		pg->transition_tmo = ALUA_FAILOVER_TIMEOUT;
 +		h->transition_tmo = ALUA_FAILOVER_TIMEOUT;
  
++<<<<<<< HEAD
 +	if (wait_for_transition && (orig_transition_tmo != h->transition_tmo)) {
++=======
+ 	if (orig_transition_tmo != pg->transition_tmo) {
++>>>>>>> 28261402ddae (revert commit a8e5a2d593cb ("[SCSI] scsi_dh_alua: ALUA handler attach should succeed while TPG is transitioning"))
  		sdev_printk(KERN_INFO, sdev,
  			    "%s: transition timeout set to %d seconds\n",
 -			    ALUA_DH_NAME, pg->transition_tmo);
 -		expiry = jiffies + pg->transition_tmo * HZ;
 +			    ALUA_DH_NAME, h->transition_tmo);
 +		expiry = jiffies + h->transition_tmo * HZ;
  	}
  
 -	if ((buff[4] & RTPG_FMT_MASK) == RTPG_FMT_EXT_HDR)
 +	if ((h->buff[4] & RTPG_FMT_MASK) == RTPG_FMT_EXT_HDR)
  		tpg_desc_tbl_off = 8;
  	else
  		tpg_desc_tbl_off = 4;
@@@ -454,22 -541,17 +469,21 @@@
  		    valid_states&TPGS_SUPPORT_NONOPTIMIZED?'N':'n',
  		    valid_states&TPGS_SUPPORT_OPTIMIZED?'A':'a');
  
 -	switch (pg->state) {
 +	switch (h->state) {
  	case TPGS_STATE_TRANSITIONING:
- 		if (wait_for_transition) {
- 			if (time_before(jiffies, expiry)) {
- 				/* State transition, retry */
- 				interval += 2000;
- 				msleep(interval);
- 				goto retry;
- 			}
- 			err = SCSI_DH_RETRY;
- 		} else {
- 			err = SCSI_DH_OK;
+ 		if (time_before(jiffies, expiry)) {
+ 			/* State transition, retry */
+ 			interval += 2000;
+ 			msleep(interval);
+ 			goto retry;
  		}
- 
  		/* Transitioning time exceeded, set port to standby */
++<<<<<<< HEAD
 +		h->state = TPGS_STATE_STANDBY;
++=======
+ 		err = SCSI_DH_RETRY;
+ 		pg->state = TPGS_STATE_STANDBY;
++>>>>>>> 28261402ddae (revert commit a8e5a2d593cb ("[SCSI] scsi_dh_alua: ALUA handler attach should succeed while TPG is transitioning"))
  		break;
  	case TPGS_STATE_OFFLINE:
  		/* Path unusable */
@@@ -616,19 -695,26 +630,31 @@@ MODULE_PARM_DESC(optimize_stpg, "Allow 
  static int alua_activate(struct scsi_device *sdev,
  			activate_complete fn, void *data)
  {
 -	struct alua_dh_data *h = sdev->handler_data;
 +	struct alua_dh_data *h = get_alua_data(sdev);
  	int err = SCSI_DH_OK;
  
 -	if (!h->pg)
 +	err = alua_rtpg(sdev, h, 1);
 +	if (err != SCSI_DH_OK)
  		goto out;
  
 -	kref_get(&h->pg->kref);
 -
  	if (optimize_stpg)
 -		h->pg->flags |= ALUA_OPTIMIZE_STPG;
 +		h->flags |= ALUA_OPTIMIZE_STPG;
  
++<<<<<<< HEAD
 +	err = alua_stpg(sdev, h);
 +	if (err == SCSI_DH_RETRY)
 +		err = alua_rtpg(sdev, h, 1);
++=======
+ 	err = alua_rtpg(sdev, h->pg);
+ 	if (err != SCSI_DH_OK) {
+ 		kref_put(&h->pg->kref, release_port_group);
+ 		goto out;
+ 	}
+ 	err = alua_stpg(sdev, h->pg);
+ 	if (err == SCSI_DH_RETRY)
+ 		err = alua_rtpg(sdev, h->pg);
+ 	kref_put(&h->pg->kref, release_port_group);
++>>>>>>> 28261402ddae (revert commit a8e5a2d593cb ("[SCSI] scsi_dh_alua: ALUA handler attach should succeed while TPG is transitioning"))
  out:
  	if (fn)
  		fn(data, err);
* Unmerged path drivers/scsi/device_handler/scsi_dh_alua.c
