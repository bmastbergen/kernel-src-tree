mlxsw: spectrum_router: Sanitize IPv6 FIB rules

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ido Schimmel <idosch@mellanox.com>
commit 583419fdf22bd2fc39e49520b29960f206b7ab44
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/583419fd.failed

We only allow FIB offload in the presence of default rules or an l3mdev
rule. In a similar fashion to IPv4 FIB rules, sanitize IPv6 rules.

	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 583419fdf22bd2fc39e49520b29960f206b7ab44)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index cd0a7dcb3528,6c7fc6a66aca..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -46,6 -48,13 +46,16 @@@
  #include <net/neighbour.h>
  #include <net/arp.h>
  #include <net/ip_fib.h>
++<<<<<<< HEAD
++=======
+ #include <net/ip6_fib.h>
+ #include <net/fib_rules.h>
+ #include <net/l3mdev.h>
+ #include <net/addrconf.h>
+ #include <net/ndisc.h>
+ #include <net/ipv6.h>
+ #include <net/fib_notifier.h>
++>>>>>>> 583419fdf22b (mlxsw: spectrum_router: Sanitize IPv6 FIB rules)
  
  #include "spectrum.h"
  #include "core.h"
@@@ -2718,6 -3086,66 +2728,69 @@@ static void mlxsw_sp_router_fib_event_w
  	kfree(fib_work);
  }
  
++<<<<<<< HEAD
++=======
+ static void mlxsw_sp_router_fib6_event_work(struct work_struct *work)
+ {
+ 	struct mlxsw_sp_fib_event_work *fib_work =
+ 		container_of(work, struct mlxsw_sp_fib_event_work, work);
+ 	struct mlxsw_sp *mlxsw_sp = fib_work->mlxsw_sp;
+ 	struct fib_rule *rule;
+ 
+ 	rtnl_lock();
+ 	switch (fib_work->event) {
+ 	case FIB_EVENT_RULE_ADD: /* fall through */
+ 	case FIB_EVENT_RULE_DEL:
+ 		rule = fib_work->fr_info.rule;
+ 		if (!fib6_rule_default(rule) && !rule->l3mdev)
+ 			mlxsw_sp_router_fib_abort(mlxsw_sp);
+ 		fib_rule_put(rule);
+ 		break;
+ 	}
+ 	rtnl_unlock();
+ 	kfree(fib_work);
+ }
+ 
+ static void mlxsw_sp_router_fib4_event(struct mlxsw_sp_fib_event_work *fib_work,
+ 				       struct fib_notifier_info *info)
+ {
+ 	switch (fib_work->event) {
+ 	case FIB_EVENT_ENTRY_REPLACE: /* fall through */
+ 	case FIB_EVENT_ENTRY_APPEND: /* fall through */
+ 	case FIB_EVENT_ENTRY_ADD: /* fall through */
+ 	case FIB_EVENT_ENTRY_DEL:
+ 		memcpy(&fib_work->fen_info, info, sizeof(fib_work->fen_info));
+ 		/* Take referece on fib_info to prevent it from being
+ 		 * freed while work is queued. Release it afterwards.
+ 		 */
+ 		fib_info_hold(fib_work->fen_info.fi);
+ 		break;
+ 	case FIB_EVENT_RULE_ADD: /* fall through */
+ 	case FIB_EVENT_RULE_DEL:
+ 		memcpy(&fib_work->fr_info, info, sizeof(fib_work->fr_info));
+ 		fib_rule_get(fib_work->fr_info.rule);
+ 		break;
+ 	case FIB_EVENT_NH_ADD: /* fall through */
+ 	case FIB_EVENT_NH_DEL:
+ 		memcpy(&fib_work->fnh_info, info, sizeof(fib_work->fnh_info));
+ 		fib_info_hold(fib_work->fnh_info.fib_nh->nh_parent);
+ 		break;
+ 	}
+ }
+ 
+ static void mlxsw_sp_router_fib6_event(struct mlxsw_sp_fib_event_work *fib_work,
+ 				       struct fib_notifier_info *info)
+ {
+ 	switch (fib_work->event) {
+ 	case FIB_EVENT_RULE_ADD: /* fall through */
+ 	case FIB_EVENT_RULE_DEL:
+ 		memcpy(&fib_work->fr_info, info, sizeof(fib_work->fr_info));
+ 		fib_rule_get(fib_work->fr_info.rule);
+ 		break;
+ 	}
+ }
+ 
++>>>>>>> 583419fdf22b (mlxsw: spectrum_router: Sanitize IPv6 FIB rules)
  /* Called with rcu_read_lock() */
  static int mlxsw_sp_router_fib_event(struct notifier_block *nb,
  				     unsigned long event, void *ptr)
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
