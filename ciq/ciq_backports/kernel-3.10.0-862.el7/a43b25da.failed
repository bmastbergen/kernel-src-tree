net/mlx5e: CQ and RQ don't need priv pointer

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: CQ and RQ don't need priv pointer (Don Dutile) [1456659 1499362]
Rebuild_FUZZ: 95.24%
commit-author Saeed Mahameed <saeedm@mellanox.com>
commit a43b25daef78610ccef025d59f82ce8e0c42ab6c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a43b25da.failed

Remove mlx5e_priv pointer from CQ and RQ structs,
it was needed only to access mdev pointer from priv pointer.

Instead we now pass mdev where needed.

	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Reviewed-by: Tariq Toukan <tariqt@mellanox.com>
(cherry picked from commit a43b25daef78610ccef025d59f82ce8e0c42ab6c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index fc92406a15c4,a6e09c46440b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -523,21 -528,20 +522,30 @@@ static int mlx5e_create_umr_mkey(struc
  	return err;
  }
  
- static int mlx5e_create_rq_umr_mkey(struct mlx5e_rq *rq)
+ static int mlx5e_create_rq_umr_mkey(struct mlx5_core_dev *mdev, struct mlx5e_rq *rq)
  {
++<<<<<<< HEAD
 +	struct mlx5e_priv *priv = rq->priv;
 +	u64 num_mtts = MLX5E_REQUIRED_MTTS(BIT(priv->params.log_rq_size));
++=======
+ 	u64 num_mtts = MLX5E_REQUIRED_MTTS(mlx5_wq_ll_get_size(&rq->wq));
++>>>>>>> a43b25daef78 (net/mlx5e: CQ and RQ don't need priv pointer)
  
- 	return mlx5e_create_umr_mkey(priv, num_mtts, PAGE_SHIFT, &rq->umr_mkey);
+ 	return mlx5e_create_umr_mkey(mdev, num_mtts, PAGE_SHIFT, &rq->umr_mkey);
  }
  
 -static int mlx5e_alloc_rq(struct mlx5e_channel *c,
 -			  struct mlx5e_params *params,
 -			  struct mlx5e_rq_param *rqp,
 -			  struct mlx5e_rq *rq)
 +static int mlx5e_create_rq(struct mlx5e_channel *c,
 +			   struct mlx5e_rq_param *param,
 +			   struct mlx5e_rq *rq)
  {
++<<<<<<< HEAD
 +	struct mlx5e_priv *priv = c->priv;
 +	struct mlx5_core_dev *mdev = priv->mdev;
 +	void *rqc = param->rqc;
++=======
+ 	struct mlx5_core_dev *mdev = c->mdev;
+ 	void *rqc = rqp->rqc;
++>>>>>>> a43b25daef78 (net/mlx5e: CQ and RQ don't need priv pointer)
  	void *rqc_wq = MLX5_ADDR_OF(rqc, rqc, wq);
  	u32 byte_count;
  	u32 frag_sz;
@@@ -557,17 -561,32 +565,17 @@@
  
  	wq_sz = mlx5_wq_ll_get_size(&rq->wq);
  
 -	rq->wq_type = params->rq_wq_type;
 +	rq->wq_type = priv->params.rq_wq_type;
  	rq->pdev    = c->pdev;
  	rq->netdev  = c->netdev;
- 	rq->tstamp  = &priv->tstamp;
+ 	rq->tstamp  = c->tstamp;
  	rq->channel = c;
  	rq->ix      = c->ix;
- 	rq->priv    = c->priv;
+ 	rq->mdev    = mdev;
  
 -	rq->xdp_prog = params->xdp_prog ? bpf_prog_inc(params->xdp_prog) : NULL;
 -	if (IS_ERR(rq->xdp_prog)) {
 -		err = PTR_ERR(rq->xdp_prog);
 -		rq->xdp_prog = NULL;
 -		goto err_rq_wq_destroy;
 -	}
 -
 -	if (rq->xdp_prog) {
 -		rq->buff.map_dir = DMA_BIDIRECTIONAL;
 -		rq->rx_headroom = XDP_PACKET_HEADROOM;
 -	} else {
 -		rq->buff.map_dir = DMA_FROM_DEVICE;
 -		rq->rx_headroom = MLX5_RX_HEADROOM;
 -	}
 -
 -	switch (rq->wq_type) {
 +	switch (priv->params.rq_wq_type) {
  	case MLX5_WQ_TYPE_LINKED_LIST_STRIDING_RQ:
- 		if (mlx5e_is_vf_vport_rep(priv)) {
+ 		if (mlx5e_is_vf_vport_rep(c->priv)) {
  			err = -EINVAL;
  			goto err_rq_wq_destroy;
  		}
@@@ -607,9 -626,9 +615,15 @@@
  		rq->alloc_wqe = mlx5e_alloc_rx_wqe;
  		rq->dealloc_wqe = mlx5e_dealloc_rx_wqe;
  
++<<<<<<< HEAD
 +		rq->buff.wqe_sz = (priv->params.lro_en) ?
 +				priv->params.lro_wqe_sz :
 +				MLX5E_SW2HW_MTU(priv->netdev->mtu);
++=======
+ 		rq->buff.wqe_sz = params->lro_en  ?
+ 				params->lro_wqe_sz :
+ 				MLX5E_SW2HW_MTU(c->netdev->mtu);
++>>>>>>> a43b25daef78 (net/mlx5e: CQ and RQ don't need priv pointer)
  		byte_count = rq->buff.wqe_sz;
  
  		/* calc the required page order */
@@@ -671,10 -694,10 +685,9 @@@ static void mlx5e_destroy_rq(struct mlx
  	mlx5_wq_destroy(&rq->wq_ctrl);
  }
  
 -static int mlx5e_create_rq(struct mlx5e_rq *rq,
 -			   struct mlx5e_rq_param *param)
 +static int mlx5e_enable_rq(struct mlx5e_rq *rq, struct mlx5e_rq_param *param)
  {
- 	struct mlx5e_priv *priv = rq->priv;
- 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	struct mlx5_core_dev *mdev = rq->mdev;
  
  	void *in;
  	void *rqc;
@@@ -770,25 -789,28 +780,30 @@@ static int mlx5e_modify_rq_vsd(struct m
  	return err;
  }
  
 -static void mlx5e_destroy_rq(struct mlx5e_rq *rq)
 +static void mlx5e_disable_rq(struct mlx5e_rq *rq)
  {
- 	mlx5_core_destroy_rq(rq->priv->mdev, rq->rqn);
+ 	mlx5_core_destroy_rq(rq->mdev, rq->rqn);
  }
  
  static int mlx5e_wait_for_min_rx_wqes(struct mlx5e_rq *rq)
  {
  	unsigned long exp_time = jiffies + msecs_to_jiffies(20000);
  	struct mlx5e_channel *c = rq->channel;
- 	struct mlx5e_priv *priv = c->priv;
+ 
  	struct mlx5_wq_ll *wq = &rq->wq;
 -	u16 min_wqes = mlx5_min_rx_wqes(rq->wq_type, mlx5_wq_ll_get_size(wq));
  
  	while (time_before(jiffies, exp_time)) {
 -		if (wq->cur_sz >= min_wqes)
 +		if (wq->cur_sz >= priv->params.min_rx_wqes)
  			return 0;
  
  		msleep(20);
  	}
  
++<<<<<<< HEAD
++=======
+ 	netdev_warn(c->netdev, "Failed to get min RX wqes on RQN[0x%x] wq cur_sz(%d) min_rx_wqes(%d)\n",
+ 		    rq->rqn, wq->cur_sz, min_wqes);
++>>>>>>> a43b25daef78 (net/mlx5e: CQ and RQ don't need priv pointer)
  	return -ETIMEDOUT;
  }
  
@@@ -856,14 -884,75 +871,76 @@@ static void mlx5e_close_rq(struct mlx5e
  {
  	clear_bit(MLX5E_RQ_STATE_ENABLED, &rq->state);
  	napi_synchronize(&rq->channel->napi); /* prevent mlx5e_post_rx_wqes */
 -}
 -
 -static void mlx5e_close_rq(struct mlx5e_rq *rq)
 -{
  	cancel_work_sync(&rq->am.work);
 -	mlx5e_destroy_rq(rq);
 +
 +	mlx5e_disable_rq(rq);
  	mlx5e_free_rx_descs(rq);
 -	mlx5e_free_rq(rq);
 +	mlx5e_destroy_rq(rq);
  }
  
++<<<<<<< HEAD
 +static void mlx5e_free_sq_ico_db(struct mlx5e_sq *sq)
++=======
+ static void mlx5e_free_xdpsq_db(struct mlx5e_xdpsq *sq)
+ {
+ 	kfree(sq->db.di);
+ }
+ 
+ static int mlx5e_alloc_xdpsq_db(struct mlx5e_xdpsq *sq, int numa)
+ {
+ 	int wq_sz = mlx5_wq_cyc_get_size(&sq->wq);
+ 
+ 	sq->db.di = kzalloc_node(sizeof(*sq->db.di) * wq_sz,
+ 				     GFP_KERNEL, numa);
+ 	if (!sq->db.di) {
+ 		mlx5e_free_xdpsq_db(sq);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int mlx5e_alloc_xdpsq(struct mlx5e_channel *c,
+ 			     struct mlx5e_params *params,
+ 			     struct mlx5e_sq_param *param,
+ 			     struct mlx5e_xdpsq *sq)
+ {
+ 	void *sqc_wq               = MLX5_ADDR_OF(sqc, param->sqc, wq);
+ 	struct mlx5_core_dev *mdev = c->mdev;
+ 	int err;
+ 
+ 	sq->pdev      = c->pdev;
+ 	sq->mkey_be   = c->mkey_be;
+ 	sq->channel   = c;
+ 	sq->uar_map   = mdev->mlx5e_res.bfreg.map;
+ 	sq->min_inline_mode = params->tx_min_inline_mode;
+ 
+ 	param->wq.db_numa_node = cpu_to_node(c->cpu);
+ 	err = mlx5_wq_cyc_create(mdev, &param->wq, sqc_wq, &sq->wq, &sq->wq_ctrl);
+ 	if (err)
+ 		return err;
+ 	sq->wq.db = &sq->wq.db[MLX5_SND_DBR];
+ 
+ 	err = mlx5e_alloc_xdpsq_db(sq, cpu_to_node(c->cpu));
+ 	if (err)
+ 		goto err_sq_wq_destroy;
+ 
+ 	return 0;
+ 
+ err_sq_wq_destroy:
+ 	mlx5_wq_destroy(&sq->wq_ctrl);
+ 
+ 	return err;
+ }
+ 
+ static void mlx5e_free_xdpsq(struct mlx5e_xdpsq *sq)
+ {
+ 	mlx5e_free_xdpsq_db(sq);
+ 	mlx5_wq_destroy(&sq->wq_ctrl);
+ }
+ 
+ static void mlx5e_free_icosq_db(struct mlx5e_icosq *sq)
++>>>>>>> a43b25daef78 (net/mlx5e: CQ and RQ don't need priv pointer)
  {
  	kfree(sq->db.ico_wqe);
  }
@@@ -880,14 -969,53 +957,44 @@@ static int mlx5e_alloc_sq_ico_db(struc
  	return 0;
  }
  
 -static int mlx5e_alloc_icosq(struct mlx5e_channel *c,
 -			     struct mlx5e_sq_param *param,
 -			     struct mlx5e_icosq *sq)
 +static void mlx5e_free_sq_txq_db(struct mlx5e_sq *sq)
  {
++<<<<<<< HEAD
 +	kfree(sq->db.txq.wqe_info);
 +	kfree(sq->db.txq.dma_fifo);
 +	kfree(sq->db.txq.skb);
++=======
+ 	void *sqc_wq               = MLX5_ADDR_OF(sqc, param->sqc, wq);
+ 	struct mlx5_core_dev *mdev = c->mdev;
+ 	int err;
+ 
+ 	sq->pdev      = c->pdev;
+ 	sq->mkey_be   = c->mkey_be;
+ 	sq->channel   = c;
+ 	sq->uar_map   = mdev->mlx5e_res.bfreg.map;
+ 
+ 	param->wq.db_numa_node = cpu_to_node(c->cpu);
+ 	err = mlx5_wq_cyc_create(mdev, &param->wq, sqc_wq, &sq->wq, &sq->wq_ctrl);
+ 	if (err)
+ 		return err;
+ 	sq->wq.db = &sq->wq.db[MLX5_SND_DBR];
+ 
+ 	err = mlx5e_alloc_icosq_db(sq, cpu_to_node(c->cpu));
+ 	if (err)
+ 		goto err_sq_wq_destroy;
+ 
+ 	sq->edge = (sq->wq.sz_m1 + 1) - MLX5E_ICOSQ_MAX_WQEBBS;
+ 
+ 	return 0;
+ 
+ err_sq_wq_destroy:
+ 	mlx5_wq_destroy(&sq->wq_ctrl);
+ 
+ 	return err;
++>>>>>>> a43b25daef78 (net/mlx5e: CQ and RQ don't need priv pointer)
  }
  
 -static void mlx5e_free_icosq(struct mlx5e_icosq *sq)
 -{
 -	mlx5e_free_icosq_db(sq);
 -	mlx5_wq_destroy(&sq->wq_ctrl);
 -}
 -
 -static void mlx5e_free_txqsq_db(struct mlx5e_txqsq *sq)
 -{
 -	kfree(sq->db.wqe_info);
 -	kfree(sq->db.dma_fifo);
 -	kfree(sq->db.skb);
 -}
 -
 -static int mlx5e_alloc_txqsq_db(struct mlx5e_txqsq *sq, int numa)
 +static int mlx5e_alloc_sq_txq_db(struct mlx5e_sq *sq, int numa)
  {
  	int wq_sz = mlx5_wq_cyc_get_size(&sq->wq);
  	int df_sz = wq_sz * MLX5_SEND_WQEBB_NUM_DS;
@@@ -908,76 -1036,32 +1015,81 @@@
  	return 0;
  }
  
 -static int mlx5e_alloc_txqsq(struct mlx5e_channel *c,
 -			     int txq_ix,
 -			     struct mlx5e_params *params,
 -			     struct mlx5e_sq_param *param,
 -			     struct mlx5e_txqsq *sq)
 +static void mlx5e_free_sq_db(struct mlx5e_sq *sq)
 +{
++<<<<<<< HEAD
 +	switch (sq->type) {
 +	case MLX5E_SQ_TXQ:
 +		mlx5e_free_sq_txq_db(sq);
 +		break;
 +	case MLX5E_SQ_ICO:
 +		mlx5e_free_sq_ico_db(sq);
 +		break;
 +	}
 +}
 +
 +static int mlx5e_alloc_sq_db(struct mlx5e_sq *sq, int numa)
 +{
 +	switch (sq->type) {
 +	case MLX5E_SQ_TXQ:
 +		return mlx5e_alloc_sq_txq_db(sq, numa);
 +	case MLX5E_SQ_ICO:
 +		return mlx5e_alloc_sq_ico_db(sq, numa);
 +	}
 +
 +	return 0;
 +}
 +
 +static int mlx5e_create_sq(struct mlx5e_channel *c,
 +			   int tc,
 +			   struct mlx5e_sq_param *param,
 +			   struct mlx5e_sq *sq)
  {
 +	struct mlx5e_priv *priv = c->priv;
 +	struct mlx5_core_dev *mdev = priv->mdev;
 +
 +	void *sqc = param->sqc;
 +	void *sqc_wq = MLX5_ADDR_OF(sqc, sqc, wq);
 +	u16 sq_max_wqebbs;
++=======
+ 	void *sqc_wq               = MLX5_ADDR_OF(sqc, param->sqc, wq);
+ 	struct mlx5_core_dev *mdev = c->mdev;
++>>>>>>> a43b25daef78 (net/mlx5e: CQ and RQ don't need priv pointer)
  	int err;
  
 +	sq->type      = param->type;
  	sq->pdev      = c->pdev;
- 	sq->tstamp    = &priv->tstamp;
+ 	sq->tstamp    = c->tstamp;
  	sq->mkey_be   = c->mkey_be;
  	sq->channel   = c;
 -	sq->txq_ix    = txq_ix;
 -	sq->uar_map   = mdev->mlx5e_res.bfreg.map;
 -	sq->max_inline      = params->tx_max_inline;
 -	sq->min_inline_mode = params->tx_min_inline_mode;
 +	sq->tc        = tc;
  
 -	param->wq.db_numa_node = cpu_to_node(c->cpu);
 -	err = mlx5_wq_cyc_create(mdev, &param->wq, sqc_wq, &sq->wq, &sq->wq_ctrl);
 +	err = mlx5_alloc_map_uar(mdev, &sq->uar, !!MLX5_CAP_GEN(mdev, bf));
  	if (err)
  		return err;
 -	sq->wq.db    = &sq->wq.db[MLX5_SND_DBR];
  
 -	err = mlx5e_alloc_txqsq_db(sq, cpu_to_node(c->cpu));
 +	sq->uar_map = sq->bfreg.map;
 +	param->wq.db_numa_node = cpu_to_node(c->cpu);
 +
 +	err = mlx5_wq_cyc_create(mdev, &param->wq, sqc_wq, &sq->wq,
 +				 &sq->wq_ctrl);
 +	if (err)
 +		goto err_unmap_free_uar;
 +
 +	sq->wq.db       = &sq->wq.db[MLX5_SND_DBR];
 +	if (sq->uar.bf_map) {
 +		set_bit(MLX5E_SQ_STATE_BF_ENABLE, &sq->state);
 +		sq->uar_map = sq->uar.bf_map;
 +	} else {
 +		sq->uar_map = sq->uar.map;
 +	}
 +	sq->bf_buf_size = (1 << MLX5_CAP_GEN(mdev, log_bf_reg_size)) / 2;
 +	sq->max_inline  = param->max_inline;
 +	sq->min_inline_mode =
 +		MLX5_CAP_ETH(mdev, wqe_inline_mode) == MLX5_CAP_INLINE_MODE_VPORT_CONTEXT ?
 +		param->min_inline_mode : 0;
 +
 +	err = mlx5e_alloc_sq_db(sq, cpu_to_node(c->cpu));
  	if (err)
  		goto err_sq_wq_destroy;
  
@@@ -1007,22 -1075,25 +1119,38 @@@ err_unmap_free_uar
  	return err;
  }
  
 -static void mlx5e_free_txqsq(struct mlx5e_txqsq *sq)
 +static void mlx5e_destroy_sq(struct mlx5e_sq *sq)
  {
 -	mlx5e_free_txqsq_db(sq);
 +	struct mlx5e_channel *c = sq->channel;
 +	struct mlx5e_priv *priv = c->priv;
 +
 +	mlx5e_free_sq_db(sq);
  	mlx5_wq_destroy(&sq->wq_ctrl);
 +	mlx5_unmap_free_uar(priv->mdev, &sq->uar);
  }
  
++<<<<<<< HEAD
 +static int mlx5e_enable_sq(struct mlx5e_sq *sq, struct mlx5e_sq_param *param)
 +{
 +	struct mlx5e_channel *c = sq->channel;
 +	struct mlx5e_priv *priv = c->priv;
 +	struct mlx5_core_dev *mdev = priv->mdev;
 +
++=======
+ struct mlx5e_create_sq_param {
+ 	struct mlx5_wq_ctrl        *wq_ctrl;
+ 	u32                         cqn;
+ 	u32                         tisn;
+ 	u8                          tis_lst_sz;
+ 	u8                          min_inline_mode;
+ };
+ 
+ static int mlx5e_create_sq(struct mlx5_core_dev *mdev,
+ 			   struct mlx5e_sq_param *param,
+ 			   struct mlx5e_create_sq_param *csp,
+ 			   u32 *sqn)
+ {
++>>>>>>> a43b25daef78 (net/mlx5e: CQ and RQ don't need priv pointer)
  	void *in;
  	void *sqc;
  	void *wq;
@@@ -1039,37 -1110,40 +1167,55 @@@
  	wq = MLX5_ADDR_OF(sqc, sqc, wq);
  
  	memcpy(sqc, param->sqc, sizeof(param->sqc));
 -	MLX5_SET(sqc,  sqc, tis_lst_sz, csp->tis_lst_sz);
 -	MLX5_SET(sqc,  sqc, tis_num_0, csp->tisn);
 -	MLX5_SET(sqc,  sqc, cqn, csp->cqn);
 -
 -	if (MLX5_CAP_ETH(mdev, wqe_inline_mode) == MLX5_CAP_INLINE_MODE_VPORT_CONTEXT)
 -		MLX5_SET(sqc,  sqc, min_wqe_inline_mode, csp->min_inline_mode);
  
 -	MLX5_SET(sqc,  sqc, state, MLX5_SQC_STATE_RST);
 +	MLX5_SET(sqc,  sqc, tis_num_0, param->type == MLX5E_SQ_ICO ?
 +				       0 : priv->tisn[sq->tc]);
 +	MLX5_SET(sqc,  sqc, cqn,		sq->cq.mcq.cqn);
 +	MLX5_SET(sqc,  sqc, min_wqe_inline_mode, sq->min_inline_mode);
 +	MLX5_SET(sqc,  sqc, state,		MLX5_SQC_STATE_RST);
 +	MLX5_SET(sqc,  sqc, tis_lst_sz, param->type == MLX5E_SQ_ICO ? 0 : 1);
  
  	MLX5_SET(wq,   wq, wq_type,       MLX5_WQ_TYPE_CYCLIC);
++<<<<<<< HEAD
 +	MLX5_SET(wq,   wq, uar_page,      sq->uar.index);
 +	MLX5_SET(wq,   wq, log_wq_pg_sz,  sq->wq_ctrl.buf.page_shift -
++=======
+ 	MLX5_SET(wq,   wq, uar_page,      mdev->mlx5e_res.bfreg.index);
+ 	MLX5_SET(wq,   wq, log_wq_pg_sz,  csp->wq_ctrl->buf.page_shift -
++>>>>>>> a43b25daef78 (net/mlx5e: CQ and RQ don't need priv pointer)
  					  MLX5_ADAPTER_PAGE_SHIFT);
 -	MLX5_SET64(wq, wq, dbr_addr,      csp->wq_ctrl->db.dma);
 +	MLX5_SET64(wq, wq, dbr_addr,      sq->wq_ctrl.db.dma);
  
 -	mlx5_fill_page_array(&csp->wq_ctrl->buf, (__be64 *)MLX5_ADDR_OF(wq, wq, pas));
 +	mlx5_fill_page_array(&sq->wq_ctrl.buf,
 +			     (__be64 *)MLX5_ADDR_OF(wq, wq, pas));
  
 -	err = mlx5_core_create_sq(mdev, in, inlen, sqn);
 +	err = mlx5_core_create_sq(mdev, in, inlen, &sq->sqn);
  
  	kvfree(in);
  
  	return err;
  }
  
++<<<<<<< HEAD
 +static int mlx5e_modify_sq(struct mlx5e_sq *sq, int curr_state,
 +			   int next_state, bool update_rl, int rl_index)
 +{
 +	struct mlx5e_channel *c = sq->channel;
 +	struct mlx5e_priv *priv = c->priv;
 +	struct mlx5_core_dev *mdev = priv->mdev;
 +
++=======
+ struct mlx5e_modify_sq_param {
+ 	int curr_state;
+ 	int next_state;
+ 	bool rl_update;
+ 	int rl_index;
+ };
+ 
+ static int mlx5e_modify_sq(struct mlx5_core_dev *mdev, u32 sqn,
+ 			   struct mlx5e_modify_sq_param *p)
+ {
++>>>>>>> a43b25daef78 (net/mlx5e: CQ and RQ don't need priv pointer)
  	void *in;
  	void *sqc;
  	int inlen;
@@@ -1096,42 -1170,62 +1242,98 @@@
  	return err;
  }
  
++<<<<<<< HEAD
 +static void mlx5e_disable_sq(struct mlx5e_sq *sq)
 +{
 +	struct mlx5e_channel *c = sq->channel;
 +	struct mlx5e_priv *priv = c->priv;
 +	struct mlx5_core_dev *mdev = priv->mdev;
 +
 +	mlx5_core_destroy_sq(mdev, sq->sqn);
 +	if (sq->rate_limit)
 +		mlx5_rl_remove_rate(mdev, sq->rate_limit);
 +}
 +
 +static int mlx5e_open_sq(struct mlx5e_channel *c,
 +			 int tc,
 +			 struct mlx5e_sq_param *param,
 +			 struct mlx5e_sq *sq)
 +{
++=======
+ static void mlx5e_destroy_sq(struct mlx5_core_dev *mdev, u32 sqn)
+ {
+ 	mlx5_core_destroy_sq(mdev, sqn);
+ }
+ 
+ static int mlx5e_create_sq_rdy(struct mlx5_core_dev *mdev,
+ 			       struct mlx5e_sq_param *param,
+ 			       struct mlx5e_create_sq_param *csp,
+ 			       u32 *sqn)
+ {
+ 	struct mlx5e_modify_sq_param msp = {0};
+ 	int err;
+ 
+ 	err = mlx5e_create_sq(mdev, param, csp, sqn);
+ 	if (err)
+ 		return err;
+ 
+ 	msp.curr_state = MLX5_SQC_STATE_RST;
+ 	msp.next_state = MLX5_SQC_STATE_RDY;
+ 	err = mlx5e_modify_sq(mdev, *sqn, &msp);
+ 	if (err)
+ 		mlx5e_destroy_sq(mdev, *sqn);
+ 
+ 	return err;
+ }
+ 
+ static int mlx5e_set_sq_maxrate(struct net_device *dev,
+ 				struct mlx5e_txqsq *sq, u32 rate);
+ 
+ static int mlx5e_open_txqsq(struct mlx5e_channel *c,
+ 			    u32 tisn,
+ 			    int txq_ix,
+ 			    struct mlx5e_params *params,
+ 			    struct mlx5e_sq_param *param,
+ 			    struct mlx5e_txqsq *sq)
+ {
+ 	struct mlx5e_create_sq_param csp = {};
+ 	u32 tx_rate;
++>>>>>>> a43b25daef78 (net/mlx5e: CQ and RQ don't need priv pointer)
  	int err;
  
 -	err = mlx5e_alloc_txqsq(c, txq_ix, params, param, sq);
 +	err = mlx5e_create_sq(c, tc, param, sq);
  	if (err)
  		return err;
  
++<<<<<<< HEAD
 +	err = mlx5e_enable_sq(sq, param);
++=======
+ 	csp.tisn            = tisn;
+ 	csp.tis_lst_sz      = 1;
+ 	csp.cqn             = sq->cq.mcq.cqn;
+ 	csp.wq_ctrl         = &sq->wq_ctrl;
+ 	csp.min_inline_mode = sq->min_inline_mode;
+ 	err = mlx5e_create_sq_rdy(c->mdev, param, &csp, &sq->sqn);
++>>>>>>> a43b25daef78 (net/mlx5e: CQ and RQ don't need priv pointer)
 +	if (err)
 +		goto err_destroy_sq;
 +
++<<<<<<< HEAD
 +	set_bit(MLX5E_SQ_STATE_ENABLED, &sq->state);
 +	err = mlx5e_modify_sq(sq, MLX5_SQC_STATE_RST, MLX5_SQC_STATE_RDY,
 +			      false, 0);
  	if (err)
 -		goto err_free_txqsq;
 +		goto err_disable_sq;
  
 +	if (sq->txq) {
 +		netdev_tx_reset_queue(sq->txq);
 +		netif_tx_start_queue(sq->txq);
 +	}
++=======
+ 	tx_rate = c->priv->tx_rates[sq->txq_ix];
+ 	if (tx_rate)
+ 		mlx5e_set_sq_maxrate(c->netdev, sq, tx_rate);
++>>>>>>> a43b25daef78 (net/mlx5e: CQ and RQ don't need priv pointer)
  
  	return 0;
  
@@@ -1144,6 -1236,14 +1346,17 @@@ err_destroy_sq
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static void mlx5e_activate_txqsq(struct mlx5e_txqsq *sq)
+ {
+ 	sq->txq = netdev_get_tx_queue(sq->channel->netdev, sq->txq_ix);
+ 	set_bit(MLX5E_SQ_STATE_ENABLED, &sq->state);
+ 	netdev_tx_reset_queue(sq->txq);
+ 	netif_tx_start_queue(sq->txq);
+ }
+ 
++>>>>>>> a43b25daef78 (net/mlx5e: CQ and RQ don't need priv pointer)
  static inline void netif_tx_disable_queue(struct netdev_queue *txq)
  {
  	__netif_tx_lock_bh(txq);
@@@ -1151,33 -1251,148 +1364,143 @@@
  	__netif_tx_unlock_bh(txq);
  }
  
 -static void mlx5e_deactivate_txqsq(struct mlx5e_txqsq *sq)
 +static void mlx5e_close_sq(struct mlx5e_sq *sq)
  {
 -	struct mlx5e_channel *c = sq->channel;
 -
  	clear_bit(MLX5E_SQ_STATE_ENABLED, &sq->state);
  	/* prevent netif_tx_wake_queue */
 -	napi_synchronize(&c->napi);
 +	napi_synchronize(&sq->channel->napi);
  
 -	netif_tx_disable_queue(sq->txq);
 +	if (sq->txq) {
 +		netif_tx_disable_queue(sq->txq);
  
++<<<<<<< HEAD
 +		/* last doorbell out, godspeed .. */
 +		if (mlx5e_sq_has_room_for(sq, 1)) {
 +			sq->db.txq.skb[(sq->pc & sq->wq.sz_m1)] = NULL;
 +			mlx5e_send_nop(sq, true);
 +		}
++=======
+ 	/* last doorbell out, godspeed .. */
+ 	if (mlx5e_wqc_has_room_for(&sq->wq, sq->cc, sq->pc, 1)) {
+ 		struct mlx5e_tx_wqe *nop;
+ 
+ 		sq->db.skb[(sq->pc & sq->wq.sz_m1)] = NULL;
+ 		nop = mlx5e_post_nop(&sq->wq, sq->sqn, &sq->pc);
+ 		mlx5e_notify_hw(&sq->wq, sq->pc, sq->uar_map, &nop->ctrl);
+ 	}
+ }
+ 
+ static void mlx5e_close_txqsq(struct mlx5e_txqsq *sq)
+ {
+ 	struct mlx5e_channel *c = sq->channel;
+ 	struct mlx5_core_dev *mdev = c->mdev;
+ 
+ 	mlx5e_destroy_sq(mdev, sq->sqn);
+ 	if (sq->rate_limit)
+ 		mlx5_rl_remove_rate(mdev, sq->rate_limit);
+ 	mlx5e_free_txqsq_descs(sq);
+ 	mlx5e_free_txqsq(sq);
+ }
+ 
+ static int mlx5e_open_icosq(struct mlx5e_channel *c,
+ 			    struct mlx5e_params *params,
+ 			    struct mlx5e_sq_param *param,
+ 			    struct mlx5e_icosq *sq)
+ {
+ 	struct mlx5e_create_sq_param csp = {};
+ 	int err;
+ 
+ 	err = mlx5e_alloc_icosq(c, param, sq);
+ 	if (err)
+ 		return err;
+ 
+ 	csp.cqn             = sq->cq.mcq.cqn;
+ 	csp.wq_ctrl         = &sq->wq_ctrl;
+ 	csp.min_inline_mode = params->tx_min_inline_mode;
+ 	set_bit(MLX5E_SQ_STATE_ENABLED, &sq->state);
+ 	err = mlx5e_create_sq_rdy(c->mdev, param, &csp, &sq->sqn);
+ 	if (err)
+ 		goto err_free_icosq;
+ 
+ 	return 0;
+ 
+ err_free_icosq:
+ 	clear_bit(MLX5E_SQ_STATE_ENABLED, &sq->state);
+ 	mlx5e_free_icosq(sq);
+ 
+ 	return err;
+ }
+ 
+ static void mlx5e_close_icosq(struct mlx5e_icosq *sq)
+ {
+ 	struct mlx5e_channel *c = sq->channel;
+ 
+ 	clear_bit(MLX5E_SQ_STATE_ENABLED, &sq->state);
+ 	napi_synchronize(&c->napi);
+ 
+ 	mlx5e_destroy_sq(c->mdev, sq->sqn);
+ 	mlx5e_free_icosq(sq);
+ }
+ 
+ static int mlx5e_open_xdpsq(struct mlx5e_channel *c,
+ 			    struct mlx5e_params *params,
+ 			    struct mlx5e_sq_param *param,
+ 			    struct mlx5e_xdpsq *sq)
+ {
+ 	unsigned int ds_cnt = MLX5E_XDP_TX_DS_COUNT;
+ 	struct mlx5e_create_sq_param csp = {};
+ 	unsigned int inline_hdr_sz = 0;
+ 	int err;
+ 	int i;
+ 
+ 	err = mlx5e_alloc_xdpsq(c, params, param, sq);
+ 	if (err)
+ 		return err;
+ 
+ 	csp.tis_lst_sz      = 1;
+ 	csp.tisn            = c->priv->tisn[0]; /* tc = 0 */
+ 	csp.cqn             = sq->cq.mcq.cqn;
+ 	csp.wq_ctrl         = &sq->wq_ctrl;
+ 	csp.min_inline_mode = sq->min_inline_mode;
+ 	set_bit(MLX5E_SQ_STATE_ENABLED, &sq->state);
+ 	err = mlx5e_create_sq_rdy(c->mdev, param, &csp, &sq->sqn);
+ 	if (err)
+ 		goto err_free_xdpsq;
+ 
+ 	if (sq->min_inline_mode != MLX5_INLINE_MODE_NONE) {
+ 		inline_hdr_sz = MLX5E_XDP_MIN_INLINE;
+ 		ds_cnt++;
++>>>>>>> a43b25daef78 (net/mlx5e: CQ and RQ don't need priv pointer)
  	}
  
 -	/* Pre initialize fixed WQE fields */
 -	for (i = 0; i < mlx5_wq_cyc_get_size(&sq->wq); i++) {
 -		struct mlx5e_tx_wqe      *wqe  = mlx5_wq_cyc_get_wqe(&sq->wq, i);
 -		struct mlx5_wqe_ctrl_seg *cseg = &wqe->ctrl;
 -		struct mlx5_wqe_eth_seg  *eseg = &wqe->eth;
 -		struct mlx5_wqe_data_seg *dseg;
 -
 -		cseg->qpn_ds = cpu_to_be32((sq->sqn << 8) | ds_cnt);
 -		eseg->inline_hdr.sz = cpu_to_be16(inline_hdr_sz);
 -
 -		dseg = (struct mlx5_wqe_data_seg *)cseg + (ds_cnt - 1);
 -		dseg->lkey = sq->mkey_be;
 -	}
 -
 -	return 0;
 -
 -err_free_xdpsq:
 -	clear_bit(MLX5E_SQ_STATE_ENABLED, &sq->state);
 -	mlx5e_free_xdpsq(sq);
 -
 -	return err;
 +	mlx5e_disable_sq(sq);
 +	mlx5e_free_tx_descs(sq);
 +	mlx5e_destroy_sq(sq);
  }
  
++<<<<<<< HEAD
 +static int mlx5e_create_cq(struct mlx5e_channel *c,
 +			   struct mlx5e_cq_param *param,
 +			   struct mlx5e_cq *cq)
++=======
+ static void mlx5e_close_xdpsq(struct mlx5e_xdpsq *sq)
  {
- 	struct mlx5e_priv *priv = c->priv;
- 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	struct mlx5e_channel *c = sq->channel;
+ 
+ 	clear_bit(MLX5E_SQ_STATE_ENABLED, &sq->state);
+ 	napi_synchronize(&c->napi);
+ 
+ 	mlx5e_destroy_sq(c->mdev, sq->sqn);
+ 	mlx5e_free_xdpsq_descs(sq);
+ 	mlx5e_free_xdpsq(sq);
+ }
+ 
+ static int mlx5e_alloc_cq(struct mlx5e_channel *c,
+ 			  struct mlx5e_cq_param *param,
+ 			  struct mlx5e_cq *cq)
++>>>>>>> a43b25daef78 (net/mlx5e: CQ and RQ don't need priv pointer)
+ {
+ 	struct mlx5_core_dev *mdev = c->mdev;
  	struct mlx5_core_cq *mcq = &cq->mcq;
  	int eqn_not_used;
  	unsigned int irqn;
@@@ -1225,10 -1439,9 +1548,9 @@@ static void mlx5e_destroy_cq(struct mlx
  	mlx5_cqwq_destroy(&cq->wq_ctrl);
  }
  
 -static int mlx5e_create_cq(struct mlx5e_cq *cq, struct mlx5e_cq_param *param)
 +static int mlx5e_enable_cq(struct mlx5e_cq *cq, struct mlx5e_cq_param *param)
  {
- 	struct mlx5e_priv *priv = cq->priv;
- 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	struct mlx5_core_dev *mdev = cq->mdev;
  	struct mlx5_core_cq *mcq = &cq->mcq;
  
  	void *in;
@@@ -1272,24 -1485,20 +1594,20 @@@
  	return 0;
  }
  
 -static void mlx5e_destroy_cq(struct mlx5e_cq *cq)
 +static void mlx5e_disable_cq(struct mlx5e_cq *cq)
  {
- 	struct mlx5e_priv *priv = cq->priv;
- 	struct mlx5_core_dev *mdev = priv->mdev;
- 
- 	mlx5_core_destroy_cq(mdev, &cq->mcq);
+ 	mlx5_core_destroy_cq(cq->mdev, &cq->mcq);
  }
  
  static int mlx5e_open_cq(struct mlx5e_channel *c,
 -			 struct mlx5e_cq_moder moder,
  			 struct mlx5e_cq_param *param,
 -			 struct mlx5e_cq *cq)
 +			 struct mlx5e_cq *cq,
 +			 struct mlx5e_cq_moder moderation)
  {
+ 	struct mlx5_core_dev *mdev = c->mdev;
  	int err;
- 	struct mlx5e_priv *priv = c->priv;
- 	struct mlx5_core_dev *mdev = priv->mdev;
  
 -	err = mlx5e_alloc_cq(c, param, cq);
 +	err = mlx5e_create_cq(c, param, cq);
  	if (err)
  		return err;
  
@@@ -1357,8 -1565,11 +1675,16 @@@ static int mlx5e_open_sqs(struct mlx5e_
  	int err;
  	int tc;
  
++<<<<<<< HEAD
 +	for (tc = 0; tc < c->num_tc; tc++) {
 +		err = mlx5e_open_sq(c, tc, &cparam->sq, &c->sq[tc]);
++=======
+ 	for (tc = 0; tc < params->num_tc; tc++) {
+ 		int txq_ix = c->ix + tc * params->num_channels;
+ 
+ 		err = mlx5e_open_txqsq(c, c->priv->tisn[tc], txq_ix,
+ 				       params, &cparam->sq, &c->sq[tc]);
++>>>>>>> a43b25daef78 (net/mlx5e: CQ and RQ don't need priv pointer)
  		if (err)
  			goto err_close_sqs;
  	}
@@@ -1416,8 -1619,11 +1742,16 @@@ static int mlx5e_set_sq_maxrate(struct 
  		}
  	}
  
++<<<<<<< HEAD
 +	err = mlx5e_modify_sq(sq, MLX5_SQC_STATE_RDY,
 +			      MLX5_SQC_STATE_RDY, true, rl_index);
++=======
+ 	msp.curr_state = MLX5_SQC_STATE_RDY;
+ 	msp.next_state = MLX5_SQC_STATE_RDY;
+ 	msp.rl_index   = rl_index;
+ 	msp.rl_update  = true;
+ 	err = mlx5e_modify_sq(mdev, sq->sqn, &msp);
++>>>>>>> a43b25daef78 (net/mlx5e: CQ and RQ don't need priv pointer)
  	if (err) {
  		netdev_err(dev, "Failed configuring rate %u: %d\n",
  			   rate, err);
@@@ -1561,6 -1774,25 +1897,28 @@@ err_napi_del
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static void mlx5e_activate_channel(struct mlx5e_channel *c)
+ {
+ 	int tc;
+ 
+ 	for (tc = 0; tc < c->num_tc; tc++)
+ 		mlx5e_activate_txqsq(&c->sq[tc]);
+ 	mlx5e_activate_rq(&c->rq);
+ 	netif_set_xps_queue(c->netdev, get_cpu_mask(c->cpu), c->ix);
+ }
+ 
+ static void mlx5e_deactivate_channel(struct mlx5e_channel *c)
+ {
+ 	int tc;
+ 
+ 	mlx5e_deactivate_rq(&c->rq);
+ 	for (tc = 0; tc < c->num_tc; tc++)
+ 		mlx5e_deactivate_txqsq(&c->sq[tc]);
+ }
+ 
++>>>>>>> a43b25daef78 (net/mlx5e: CQ and RQ don't need priv pointer)
  static void mlx5e_close_channel(struct mlx5e_channel *c)
  {
  	mlx5e_close_rq(&c->rq);
@@@ -2296,11 -2608,10 +2654,16 @@@ int mlx5e_close(struct net_device *netd
  	return err;
  }
  
++<<<<<<< HEAD
 +static int mlx5e_create_drop_rq(struct mlx5e_priv *priv,
 +				struct mlx5e_rq *rq,
 +				struct mlx5e_rq_param *param)
++=======
+ static int mlx5e_alloc_drop_rq(struct mlx5_core_dev *mdev,
+ 			       struct mlx5e_rq *rq,
+ 			       struct mlx5e_rq_param *param)
++>>>>>>> a43b25daef78 (net/mlx5e: CQ and RQ don't need priv pointer)
  {
- 	struct mlx5_core_dev *mdev = priv->mdev;
  	void *rqc = param->rqc;
  	void *rqc_wq = MLX5_ADDR_OF(rqc, rqc, wq);
  	int err;
@@@ -2317,11 -2628,10 +2680,16 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int mlx5e_create_drop_cq(struct mlx5e_priv *priv,
 +				struct mlx5e_cq *cq,
 +				struct mlx5e_cq_param *param)
++=======
+ static int mlx5e_alloc_drop_cq(struct mlx5_core_dev *mdev,
+ 			       struct mlx5e_cq *cq,
+ 			       struct mlx5e_cq_param *param)
++>>>>>>> a43b25daef78 (net/mlx5e: CQ and RQ don't need priv pointer)
  {
- 	struct mlx5_core_dev *mdev = priv->mdev;
  	struct mlx5_core_cq *mcq = &cq->mcq;
  	int eqn_not_used;
  	unsigned int irqn;
@@@ -2343,61 -2653,58 +2711,93 @@@
  	mcq->comp       = mlx5e_completion_event;
  	mcq->event      = mlx5e_cq_error_event;
  	mcq->irqn       = irqn;
 +	mcq->uar        = &mdev->mlx5e_res.cq_uar;
  
- 	cq->priv = priv;
+ 	cq->mdev = mdev;
  
  	return 0;
  }
  
- static int mlx5e_open_drop_rq(struct mlx5e_priv *priv)
+ static int mlx5e_open_drop_rq(struct mlx5_core_dev *mdev,
+ 			      struct mlx5e_rq *drop_rq)
  {
- 	struct mlx5e_cq_param cq_param;
- 	struct mlx5e_rq_param rq_param;
- 	struct mlx5e_rq *rq = &priv->drop_rq;
- 	struct mlx5e_cq *cq = &priv->drop_rq.cq;
+ 	struct mlx5e_cq_param cq_param = {};
+ 	struct mlx5e_rq_param rq_param = {};
+ 	struct mlx5e_cq *cq = &drop_rq->cq;
  	int err;
  
- 	memset(&cq_param, 0, sizeof(cq_param));
- 	memset(&rq_param, 0, sizeof(rq_param));
  	mlx5e_build_drop_rq_param(&rq_param);
  
++<<<<<<< HEAD
 +	err = mlx5e_create_drop_cq(priv, cq, &cq_param);
 +	if (err)
 +		return err;
 +
 +	err = mlx5e_enable_cq(cq, &cq_param);
 +	if (err)
 +		goto err_destroy_cq;
 +
 +	err = mlx5e_create_drop_rq(priv, rq, &rq_param);
++=======
+ 	err = mlx5e_alloc_drop_cq(mdev, cq, &cq_param);
+ 	if (err)
+ 		return err;
+ 
+ 	err = mlx5e_create_cq(cq, &cq_param);
+ 	if (err)
+ 		goto err_free_cq;
+ 
+ 	err = mlx5e_alloc_drop_rq(mdev, drop_rq, &rq_param);
+ 	if (err)
+ 		goto err_destroy_cq;
+ 
+ 	err = mlx5e_create_rq(drop_rq, &rq_param);
++>>>>>>> a43b25daef78 (net/mlx5e: CQ and RQ don't need priv pointer)
 +	if (err)
 +		goto err_disable_cq;
 +
 +	err = mlx5e_enable_rq(rq, &rq_param);
  	if (err)
 -		goto err_free_rq;
 +		goto err_destroy_rq;
  
  	return 0;
  
++<<<<<<< HEAD
 +err_destroy_rq:
 +	mlx5e_destroy_rq(&priv->drop_rq);
 +
 +err_disable_cq:
 +	mlx5e_disable_cq(&priv->drop_rq.cq);
++=======
+ err_free_rq:
+ 	mlx5e_free_rq(drop_rq);
++>>>>>>> a43b25daef78 (net/mlx5e: CQ and RQ don't need priv pointer)
  
  err_destroy_cq:
- 	mlx5e_destroy_cq(&priv->drop_rq.cq);
+ 	mlx5e_destroy_cq(cq);
+ 
++<<<<<<< HEAD
++=======
+ err_free_cq:
+ 	mlx5e_free_cq(cq);
  
++>>>>>>> a43b25daef78 (net/mlx5e: CQ and RQ don't need priv pointer)
  	return err;
  }
  
- static void mlx5e_close_drop_rq(struct mlx5e_priv *priv)
+ static void mlx5e_close_drop_rq(struct mlx5e_rq *drop_rq)
  {
++<<<<<<< HEAD
 +	mlx5e_disable_rq(&priv->drop_rq);
 +	mlx5e_destroy_rq(&priv->drop_rq);
 +	mlx5e_disable_cq(&priv->drop_rq.cq);
 +	mlx5e_destroy_cq(&priv->drop_rq.cq);
++=======
+ 	mlx5e_destroy_rq(drop_rq);
+ 	mlx5e_free_rq(drop_rq);
+ 	mlx5e_destroy_cq(&drop_rq->cq);
+ 	mlx5e_free_cq(&drop_rq->cq);
++>>>>>>> a43b25daef78 (net/mlx5e: CQ and RQ don't need priv pointer)
  }
  
  static int mlx5e_create_tis(struct mlx5e_priv *priv, int tc)
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en.h b/drivers/net/ethernet/mellanox/mlx5/core/en.h
index 16c2c2d53ebb..0ad5bae78afb 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@ -273,7 +273,6 @@ struct mlx5e_cq {
 	struct napi_struct        *napi;
 	struct mlx5_core_cq        mcq;
 	struct mlx5e_channel      *channel;
-	struct mlx5e_priv         *priv;
 
 	/* cqe decompression */
 	struct mlx5_cqe64          title;
@@ -283,6 +282,7 @@ struct mlx5e_cq {
 	u16                        decmprs_wqe_counter;
 
 	/* control */
+	struct mlx5_core_dev      *mdev;
 	struct mlx5_frag_wq_ctrl   wq_ctrl;
 } ____cacheline_aligned_in_smp;
 
@@ -375,7 +375,7 @@ struct mlx5e_rq {
 	u32                    mpwqe_num_strides;
 	u32                    rqn;
 	struct mlx5e_channel  *channel;
-	struct mlx5e_priv     *priv;
+	struct mlx5_core_dev  *mdev;
 	struct mlx5_core_mkey  umr_mkey;
 } ____cacheline_aligned_in_smp;
 
@@ -499,6 +499,8 @@ struct mlx5e_channel {
 
 	/* control */
 	struct mlx5e_priv         *priv;
+	struct mlx5_core_dev      *mdev;
+	struct mlx5e_tstamp       *tstamp;
 	int                        ix;
 	int                        cpu;
 };
@@ -652,22 +654,6 @@ enum {
 	MLX5E_NIC_PRIO
 };
 
-struct mlx5e_profile {
-	void	(*init)(struct mlx5_core_dev *mdev,
-			struct net_device *netdev,
-			const struct mlx5e_profile *profile, void *ppriv);
-	void	(*cleanup)(struct mlx5e_priv *priv);
-	int	(*init_rx)(struct mlx5e_priv *priv);
-	void	(*cleanup_rx)(struct mlx5e_priv *priv);
-	int	(*init_tx)(struct mlx5e_priv *priv);
-	void	(*cleanup_tx)(struct mlx5e_priv *priv);
-	void	(*enable)(struct mlx5e_priv *priv);
-	void	(*disable)(struct mlx5e_priv *priv);
-	void	(*update_stats)(struct mlx5e_priv *priv);
-	int	(*max_nch)(struct mlx5_core_dev *mdev);
-	int	max_tc;
-};
-
 struct mlx5e_priv {
 	/* priv data path fields - start */
 	struct mlx5e_sq            **txq_to_sq_map;
@@ -708,6 +694,22 @@ struct mlx5e_priv {
 	void                      *ppriv;
 };
 
+struct mlx5e_profile {
+	void	(*init)(struct mlx5_core_dev *mdev,
+			struct net_device *netdev,
+			const struct mlx5e_profile *profile, void *ppriv);
+	void	(*cleanup)(struct mlx5e_priv *priv);
+	int	(*init_rx)(struct mlx5e_priv *priv);
+	void	(*cleanup_rx)(struct mlx5e_priv *priv);
+	int	(*init_tx)(struct mlx5e_priv *priv);
+	void	(*cleanup_tx)(struct mlx5e_priv *priv);
+	void	(*enable)(struct mlx5e_priv *priv);
+	void	(*disable)(struct mlx5e_priv *priv);
+	void	(*update_stats)(struct mlx5e_priv *priv);
+	int	(*max_nch)(struct mlx5_core_dev *mdev);
+	int	max_tc;
+};
+
 void mlx5e_build_ptys2ethtool_map(void);
 
 void mlx5e_send_nop(struct mlx5e_sq *sq, bool notify_hw);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rx_am.c b/drivers/net/ethernet/mellanox/mlx5/core/en_rx_am.c
index cbfac06b7ffd..02dd3a95ed8f 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rx_am.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rx_am.c
@@ -293,7 +293,7 @@ void mlx5e_rx_am_work(struct work_struct *work)
 	struct mlx5e_rq *rq = container_of(am, struct mlx5e_rq, am);
 	struct mlx5e_cq_moder cur_profile = profile[am->mode][am->profile_ix];
 
-	mlx5_core_modify_cq_moderation(rq->priv->mdev, &rq->cq.mcq,
+	mlx5_core_modify_cq_moderation(rq->mdev, &rq->cq.mcq,
 				       cur_profile.usec, cur_profile.pkts);
 
 	am->state = MLX5E_AM_START_MEASURE;
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_txrx.c b/drivers/net/ethernet/mellanox/mlx5/core/en_txrx.c
index 8689b7bebc3c..82902412dec7 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_txrx.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_txrx.c
@@ -161,8 +161,7 @@ void mlx5e_cq_error_event(struct mlx5_core_cq *mcq, enum mlx5_event event)
 {
 	struct mlx5e_cq *cq = container_of(mcq, struct mlx5e_cq, mcq);
 	struct mlx5e_channel *c = cq->channel;
-	struct mlx5e_priv *priv = c->priv;
-	struct net_device *netdev = priv->netdev;
+	struct net_device *netdev = c->netdev;
 
 	netdev_err(netdev, "%s: cqn=0x%.6x event=0x%.2x\n",
 		   __func__, mcq->cqn, event);
