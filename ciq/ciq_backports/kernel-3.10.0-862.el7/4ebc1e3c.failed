net: sched: remove unneeded tcf_em_tree_change

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] sched: remove unneeded tcf_em_tree_change (Ivan Vecera) [1445420]
Rebuild_FUZZ: 94.25%
commit-author Jiri Pirko <jiri@mellanox.com>
commit 4ebc1e3cfcd8778e2150bdb799b19e85348b8efa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4ebc1e3c.failed

Since tcf_em_tree_validate could be always called on a newly created
filter, there is no need for this change function.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4ebc1e3cfcd8778e2150bdb799b19e85348b8efa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/cls_flow.c
diff --cc net/sched/cls_flow.c
index 109b18b99cbb,71fd1af01726..000000000000
--- a/net/sched/cls_flow.c
+++ b/net/sched/cls_flow.c
@@@ -418,21 -424,25 +417,21 @@@ static int flow_change(struct net *net
  			return -EOPNOTSUPP;
  	}
  
 -	err = tcf_exts_init(&e, TCA_FLOW_ACT, TCA_FLOW_POLICE);
 -	if (err < 0)
 -		goto err1;
 +	tcf_exts_init(&e, TCA_FLOW_ACT, TCA_FLOW_POLICE);
  	err = tcf_exts_validate(net, tp, tb, tca[TCA_RATE], &e, ovr);
  	if (err < 0)
 -		goto err1;
 +		return err;
  
- 	err = tcf_em_tree_validate(tp, tb[TCA_FLOW_EMATCHES], &t);
- 	if (err < 0)
- 		goto err1;
- 
  	err = -ENOBUFS;
  	fnew = kzalloc(sizeof(*fnew), GFP_KERNEL);
  	if (!fnew)
+ 		goto err1;
+ 
+ 	err = tcf_em_tree_validate(tp, tb[TCA_FLOW_EMATCHES], &fnew->ematches);
+ 	if (err < 0)
  		goto err2;
  
 -	err = tcf_exts_init(&fnew->exts, TCA_FLOW_ACT, TCA_FLOW_POLICE);
 -	if (err < 0)
 -		goto err3;
 +	tcf_exts_init(&fnew->exts, TCA_FLOW_ACT, TCA_FLOW_POLICE);
  
  	fold = (struct flow_filter *)*arg;
  	if (fold) {
@@@ -541,8 -550,10 +539,13 @@@
  		call_rcu(&fold->rcu, flow_destroy_filter);
  	return 0;
  
++<<<<<<< HEAD
++=======
+ err3:
+ 	tcf_exts_destroy(&fnew->exts);
+ 	tcf_em_tree_destroy(&fnew->ematches);
++>>>>>>> 4ebc1e3cfcd8 (net: sched: remove unneeded tcf_em_tree_change)
  err2:
- 	tcf_em_tree_destroy(&t);
  	kfree(fnew);
  err1:
  	tcf_exts_destroy(&e);
diff --git a/include/net/pkt_cls.h b/include/net/pkt_cls.h
index ddbf01b80b4c..47369c457d9e 100644
--- a/include/net/pkt_cls.h
+++ b/include/net/pkt_cls.h
@@ -270,26 +270,6 @@ int tcf_em_tree_dump(struct sk_buff *, struct tcf_ematch_tree *, int);
 int __tcf_em_tree_match(struct sk_buff *, struct tcf_ematch_tree *,
 			struct tcf_pkt_info *);
 
-/**
- * tcf_em_tree_change - replace ematch tree of a running classifier
- *
- * @tp: classifier kind handle
- * @dst: destination ematch tree variable
- * @src: source ematch tree (temporary tree from tcf_em_tree_validate)
- *
- * This functions replaces the ematch tree in @dst with the ematch
- * tree in @src. The classifier in charge of the ematch tree may be
- * running.
- */
-static inline void tcf_em_tree_change(struct tcf_proto *tp,
-				      struct tcf_ematch_tree *dst,
-				      struct tcf_ematch_tree *src)
-{
-	tcf_tree_lock(tp);
-	memcpy(dst, src, sizeof(*dst));
-	tcf_tree_unlock(tp);
-}
-
 /**
  * tcf_em_tree_match - evaulate an ematch tree
  *
@@ -324,7 +304,6 @@ struct tcf_ematch_tree {
 #define tcf_em_tree_validate(tp, tb, t) ((void)(t), 0)
 #define tcf_em_tree_destroy(t) do { (void)(t); } while(0)
 #define tcf_em_tree_dump(skb, t, tlv) (0)
-#define tcf_em_tree_change(tp, dst, src) do { } while(0)
 #define tcf_em_tree_match(skb, t, info) ((void)(info), 1)
 
 #endif /* CONFIG_NET_EMATCH */
diff --git a/net/sched/cls_basic.c b/net/sched/cls_basic.c
index 9d68a920c5a4..748222d3ce33 100644
--- a/net/sched/cls_basic.c
+++ b/net/sched/cls_basic.c
@@ -129,14 +129,13 @@ static int basic_set_parms(struct net *net, struct tcf_proto *tp,
 {
 	int err;
 	struct tcf_exts e;
-	struct tcf_ematch_tree t;
 
 	tcf_exts_init(&e, TCA_BASIC_ACT, TCA_BASIC_POLICE);
 	err = tcf_exts_validate(net, tp, tb, est, &e, ovr);
 	if (err < 0)
 		return err;
 
-	err = tcf_em_tree_validate(tp, tb[TCA_BASIC_EMATCHES], &t);
+	err = tcf_em_tree_validate(tp, tb[TCA_BASIC_EMATCHES], &f->ematches);
 	if (err < 0)
 		goto errout;
 
@@ -146,7 +145,6 @@ static int basic_set_parms(struct net *net, struct tcf_proto *tp,
 	}
 
 	tcf_exts_change(tp, &f->exts, &e);
-	tcf_em_tree_change(tp, &f->ematches, &t);
 	f->tp = tp;
 
 	return 0;
diff --git a/net/sched/cls_cgroup.c b/net/sched/cls_cgroup.c
index 1e87931dbe99..3aff1813922a 100644
--- a/net/sched/cls_cgroup.c
+++ b/net/sched/cls_cgroup.c
@@ -188,7 +188,6 @@ static int cls_cgroup_change(struct net *net, struct sk_buff *in_skb,
 	struct nlattr *tb[TCA_CGROUP_MAX + 1];
 	struct cls_cgroup_head *head = rtnl_dereference(tp->root);
 	struct cls_cgroup_head *new;
-	struct tcf_ematch_tree t;
 	struct tcf_exts e;
 	int err;
 
@@ -218,14 +217,13 @@ static int cls_cgroup_change(struct net *net, struct sk_buff *in_skb,
 	if (err < 0)
 		goto errout;
 
-	err = tcf_em_tree_validate(tp, tb[TCA_CGROUP_EMATCHES], &t);
+	err = tcf_em_tree_validate(tp, tb[TCA_CGROUP_EMATCHES], &new->ematches);
 	if (err < 0) {
 		tcf_exts_destroy(&e);
 		goto errout;
 	}
 
 	tcf_exts_change(tp, &new->exts, &e);
-	tcf_em_tree_change(tp, &new->ematches, &t);
 
 	rcu_assign_pointer(tp->root, new);
 	if (head)
* Unmerged path net/sched/cls_flow.c
