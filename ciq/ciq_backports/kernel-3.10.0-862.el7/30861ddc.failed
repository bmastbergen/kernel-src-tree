perf/x86/amd: Add IOMMU Performance Counter resource management

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Steven L Kinney <Steven.Kinney@amd.com>
commit 30861ddc9cca479a7fc6a5efef4e5c69d6b274f4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/30861ddc.failed

Add functionality to check the availability of the AMD IOMMU Performance
Counters and export this functionality to other core drivers, such as in this
case, a perf AMD IOMMU PMU.  This feature is not bound to any specific AMD
family/model other than the presence of the IOMMU with P-C enabled.

The AMD IOMMU P-C support static counting only at this time.

	Signed-off-by: Steven Kinney <steven.kinney@amd.com>
	Signed-off-by: Suravee Suthikulpanit <suravee.suthikulpanit@amd.com>
	Signed-off-by: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/1370466709-3212-2-git-send-email-suravee.suthikulpanit@amd.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 30861ddc9cca479a7fc6a5efef4e5c69d6b274f4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/amd_iommu_init.c
diff --cc drivers/iommu/amd_iommu_init.c
index 72c0a035599f,7acbf351e9af..000000000000
--- a/drivers/iommu/amd_iommu_init.c
+++ b/drivers/iommu/amd_iommu_init.c
@@@ -151,9 -151,10 +151,10 @@@ int amd_iommus_present
  bool amd_iommu_np_cache __read_mostly;
  bool amd_iommu_iotlb_sup __read_mostly = true;
  
 -u32 amd_iommu_max_pasids __read_mostly = ~0;
 +u32 amd_iommu_max_pasid __read_mostly = ~0;
  
  bool amd_iommu_v2_present __read_mostly;
+ bool amd_iommu_pc_present __read_mostly;
  
  bool amd_iommu_force_isolation __read_mostly;
  
@@@ -1143,39 -1172,32 +1155,68 @@@ static int __init init_iommu_all(struc
  	return 0;
  }
  
++<<<<<<< HEAD
 +static ssize_t amd_iommu_show_cap(struct device *dev,
 +				  struct device_attribute *attr,
 +				  char *buf)
 +{
 +	struct amd_iommu *iommu = dev_get_drvdata(dev);
 +	return sprintf(buf, "%x\n", iommu->cap);
 +}
 +static DEVICE_ATTR(cap, S_IRUGO, amd_iommu_show_cap, NULL);
 +
 +static ssize_t amd_iommu_show_features(struct device *dev,
 +				       struct device_attribute *attr,
 +				       char *buf)
 +{
 +	struct amd_iommu *iommu = dev_get_drvdata(dev);
 +	return sprintf(buf, "%llx\n", iommu->features);
 +}
 +static DEVICE_ATTR(features, S_IRUGO, amd_iommu_show_features, NULL);
 +
 +static struct attribute *amd_iommu_attrs[] = {
 +	&dev_attr_cap.attr,
 +	&dev_attr_features.attr,
 +	NULL,
 +};
 +
 +static struct attribute_group amd_iommu_group = {
 +	.name = "amd-iommu",
 +	.attrs = amd_iommu_attrs,
 +};
 +
 +static const struct attribute_group *amd_iommu_groups[] = {
 +	&amd_iommu_group,
 +	NULL,
 +};
++=======
+ 
+ static void init_iommu_perf_ctr(struct amd_iommu *iommu)
+ {
+ 	u64 val = 0xabcd, val2 = 0;
+ 
+ 	if (!iommu_feature(iommu, FEATURE_PC))
+ 		return;
+ 
+ 	amd_iommu_pc_present = true;
+ 
+ 	/* Check if the performance counters can be written to */
+ 	if ((0 != amd_iommu_pc_get_set_reg_val(0, 0, 0, 0, &val, true)) ||
+ 	    (0 != amd_iommu_pc_get_set_reg_val(0, 0, 0, 0, &val2, false)) ||
+ 	    (val != val2)) {
+ 		pr_err("AMD-Vi: Unable to write to IOMMU perf counter.\n");
+ 		amd_iommu_pc_present = false;
+ 		return;
+ 	}
+ 
+ 	pr_info("AMD-Vi: IOMMU performance counters supported\n");
+ 
+ 	val = readl(iommu->mmio_base + MMIO_CNTR_CONF_OFFSET);
+ 	iommu->max_banks = (u8) ((val >> 12) & 0x3f);
+ 	iommu->max_counters = (u8) ((val >> 7) & 0xf);
+ }
+ 
++>>>>>>> 30861ddc9cca (perf/x86/amd: Add IOMMU Performance Counter resource management)
  
  static int iommu_init_pci(struct amd_iommu *iommu)
  {
* Unmerged path drivers/iommu/amd_iommu_init.c
diff --git a/drivers/iommu/amd_iommu_proto.h b/drivers/iommu/amd_iommu_proto.h
index dcfc5958ce85..9ed1c4330551 100644
--- a/drivers/iommu/amd_iommu_proto.h
+++ b/drivers/iommu/amd_iommu_proto.h
@@ -55,6 +55,13 @@ extern int amd_iommu_domain_set_gcr3(struct iommu_domain *dom, int pasid,
 extern int amd_iommu_domain_clear_gcr3(struct iommu_domain *dom, int pasid);
 extern struct iommu_domain *amd_iommu_get_v2_domain(struct pci_dev *pdev);
 
+/* IOMMU Performance Counter functions */
+extern bool amd_iommu_pc_supported(void);
+extern u8 amd_iommu_pc_get_max_banks(u16 devid);
+extern u8 amd_iommu_pc_get_max_counters(u16 devid);
+extern int amd_iommu_pc_get_set_reg_val(u16 devid, u8 bank, u8 cntr, u8 fxn,
+				    u64 *value, bool is_write);
+
 #define PPR_SUCCESS			0x0
 #define PPR_INVALID			0x1
 #define PPR_FAILURE			0xf
diff --git a/drivers/iommu/amd_iommu_types.h b/drivers/iommu/amd_iommu_types.h
index efadc91c9fd2..7714a240b438 100644
--- a/drivers/iommu/amd_iommu_types.h
+++ b/drivers/iommu/amd_iommu_types.h
@@ -39,9 +39,6 @@
 #define ALIAS_TABLE_ENTRY_SIZE		2
 #define RLOOKUP_TABLE_ENTRY_SIZE	(sizeof(void *))
 
-/* Length of the MMIO region for the AMD IOMMU */
-#define MMIO_REGION_LENGTH       0x4000
-
 /* Capability offsets used by the driver */
 #define MMIO_CAP_HDR_OFFSET	0x00
 #define MMIO_RANGE_OFFSET	0x0c
@@ -79,6 +76,10 @@
 #define MMIO_STATUS_OFFSET	0x2020
 #define MMIO_PPR_HEAD_OFFSET	0x2030
 #define MMIO_PPR_TAIL_OFFSET	0x2038
+#define MMIO_CNTR_CONF_OFFSET	0x4000
+#define MMIO_CNTR_REG_OFFSET	0x40000
+#define MMIO_REG_END_OFFSET	0x80000
+
 
 
 /* Extended Feature Bits */
@@ -443,6 +444,10 @@ struct amd_iommu {
 
 	/* physical address of MMIO space */
 	u64 mmio_phys;
+
+	/* physical end address of MMIO space */
+	u64 mmio_phys_end;
+
 	/* virtual address of MMIO space */
 	u8 __iomem *mmio_base;
 
@@ -511,6 +516,10 @@ struct amd_iommu {
 
 	/* The l2 indirect registers */
 	u32 stored_l2[0x83];
+
+	/* The maximum PC banks and counters/bank (PCSup=1) */
+	u8 max_banks;
+	u8 max_counters;
 };
 
 struct devid_map {
