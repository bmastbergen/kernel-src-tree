ACPICA: Make it possible to enable runtime GPEs earlier

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 1312b7e0caca44e7ff312bc2eaa888943384e3e1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1312b7e0.failed

Runtime GPEs have corresponding _Lxx/_Exx methods and are enabled
automatically during the initialization of the ACPI subsystem through
acpi_update_all_gpes() with the assumption that acpi_setup_gpe_for_wake()
will be called in advance for all of the GPEs pointed to by _PRW
objects in the namespace that may be affected by acpi_update_all_gpes().
That is, acpi_ev_initialize_gpe_block() can only be called for a GPE
block after acpi_setup_gpe_for_wake() has been called for all of the
_PRW (wakeup) GPEs in it.

The platform firmware on some systems, however, expects GPEs to be
enabled before the enumeration of devices which is when
acpi_setup_gpe_for_wake() is called and that goes against the above
assumption.

For this reason, introduce a new flag to be set by
acpi_ev_initialize_gpe_block() when automatically enabling a GPE
to indicate to acpi_setup_gpe_for_wake() that it needs to drop the
reference to the GPE coming from acpi_ev_initialize_gpe_block()
and modify acpi_setup_gpe_for_wake() accordingly.  These changes
allow acpi_setup_gpe_for_wake() and acpi_ev_initialize_gpe_block()
to be invoked in any order.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit 1312b7e0caca44e7ff312bc2eaa888943384e3e1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/acpica/evgpeblk.c
#	include/acpi/actypes.h
diff --cc drivers/acpi/acpica/evgpeblk.c
index ef2c009793e7,3a3cb8624f41..000000000000
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@@ -493,6 -496,16 +493,19 @@@ acpi_ev_initialize_gpe_block(struct acp
  				continue;
  			}
  
++<<<<<<< HEAD
++=======
+ 			gpe_event_info->flags |= ACPI_GPE_AUTO_ENABLED;
+ 
+ 			if (event_status & ACPI_EVENT_FLAG_STATUS_SET) {
+ 				ACPI_INFO(("GPE 0x%02X active on init",
+ 					   gpe_number));
+ 				(void)acpi_ev_gpe_dispatch(gpe_block->node,
+ 							   gpe_event_info,
+ 							   gpe_number);
+ 			}
+ 
++>>>>>>> 1312b7e0caca (ACPICA: Make it possible to enable runtime GPEs earlier)
  			gpe_enabled_count++;
  		}
  	}
diff --cc include/acpi/actypes.h
index 50e47dab668a,71eddf645566..000000000000
--- a/include/acpi/actypes.h
+++ b/include/acpi/actypes.h
@@@ -723,26 -768,30 +723,43 @@@ typedef u32 acpi_event_status
  
  /*
   * GPE info flags - Per GPE
++<<<<<<< HEAD
 + * +-------+-+-+---+
 + * |  7:4  |3|2|1:0|
 + * +-------+-+-+---+
 + *     |    | |  |
 + *     |    | |  +-- Type of dispatch:to method, handler, notify, or none
 + *     |    | +----- Interrupt type: edge or level triggered
 + *     |    +------- Is a Wake GPE
 + *     +------------ <Reserved>
++=======
+  * +---+-+-+-+---+
+  * |7:6|5|4|3|2:0|
+  * +---+-+-+-+---+
+  *   |  | | |  |
+  *   |  | | |  +-- Type of dispatch:to method, handler, notify, or none
+  *   |  | | +----- Interrupt type: edge or level triggered
+  *   |  | +------- Is a Wake GPE
+  *   |  +--------- Has been enabled automatically at init time
+  *   +------------ <Reserved>
++>>>>>>> 1312b7e0caca (ACPICA: Make it possible to enable runtime GPEs earlier)
   */
  #define ACPI_GPE_DISPATCH_NONE          (u8) 0x00
  #define ACPI_GPE_DISPATCH_METHOD        (u8) 0x01
  #define ACPI_GPE_DISPATCH_HANDLER       (u8) 0x02
  #define ACPI_GPE_DISPATCH_NOTIFY        (u8) 0x03
 -#define ACPI_GPE_DISPATCH_RAW_HANDLER   (u8) 0x04
 -#define ACPI_GPE_DISPATCH_MASK          (u8) 0x07
 -#define ACPI_GPE_DISPATCH_TYPE(flags)   ((u8) ((flags) & ACPI_GPE_DISPATCH_MASK))
 +#define ACPI_GPE_DISPATCH_MASK          (u8) 0x03
  
 -#define ACPI_GPE_LEVEL_TRIGGERED        (u8) 0x08
 +#define ACPI_GPE_LEVEL_TRIGGERED        (u8) 0x04
  #define ACPI_GPE_EDGE_TRIGGERED         (u8) 0x00
 -#define ACPI_GPE_XRUPT_TYPE_MASK        (u8) 0x08
 +#define ACPI_GPE_XRUPT_TYPE_MASK        (u8) 0x04
  
++<<<<<<< HEAD
 +#define ACPI_GPE_CAN_WAKE               (u8) 0x08
++=======
+ #define ACPI_GPE_CAN_WAKE               (u8) 0x10
+ #define ACPI_GPE_AUTO_ENABLED           (u8) 0x20
++>>>>>>> 1312b7e0caca (ACPICA: Make it possible to enable runtime GPEs earlier)
  
  /*
   * Flags for GPE and Lock interfaces
* Unmerged path drivers/acpi/acpica/evgpeblk.c
diff --git a/drivers/acpi/acpica/evxfgpe.c b/drivers/acpi/acpica/evxfgpe.c
index fab40d9b3bd6..11e44da1cd50 100644
--- a/drivers/acpi/acpica/evxfgpe.c
+++ b/drivers/acpi/acpica/evxfgpe.c
@@ -267,6 +267,14 @@ acpi_setup_gpe_for_wake(acpi_handle wake_device,
 		 */
 		gpe_event_info->flags =
 		    (ACPI_GPE_DISPATCH_NOTIFY | ACPI_GPE_LEVEL_TRIGGERED);
+	} else if (gpe_event_info->flags & ACPI_GPE_AUTO_ENABLED) {
+		/*
+		 * A reference to this GPE has been added during the GPE block
+		 * initialization, so drop it now to prevent the GPE from being
+		 * permanently enabled and clear its ACPI_GPE_AUTO_ENABLED flag.
+		 */
+		(void)acpi_ev_remove_gpe_reference(gpe_event_info);
+		gpe_event_info->flags &= ~ACPI_GPE_AUTO_ENABLED;
 	}
 
 	/*
* Unmerged path include/acpi/actypes.h
