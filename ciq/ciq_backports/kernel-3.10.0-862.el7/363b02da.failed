KEYS: Fix race between updating and finding a negative key

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author David Howells <dhowells@redhat.com>
commit 363b02dab09b3226f3bd1420dad9c72b79a42a76
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/363b02da.failed

Consolidate KEY_FLAG_INSTANTIATED, KEY_FLAG_NEGATIVE and the rejection
error into one field such that:

 (1) The instantiation state can be modified/read atomically.

 (2) The error can be accessed atomically with the state.

 (3) The error isn't stored unioned with the payload pointers.

This deals with the problem that the state is spread over three different
objects (two bits and a separate variable) and reading or updating them
atomically isn't practical, given that not only can uninstantiated keys
change into instantiated or rejected keys, but rejected keys can also turn
into instantiated keys - and someone accessing the key might not be using
any locking.

The main side effect of this problem is that what was held in the payload
may change, depending on the state.  For instance, you might observe the
key to be in the rejected state.  You then read the cached error, but if
the key semaphore wasn't locked, the key might've become instantiated
between the two reads - and you might now have something in hand that isn't
actually an error code.

The state is now KEY_IS_UNINSTANTIATED, KEY_IS_POSITIVE or a negative error
code if the key is negatively instantiated.  The key_is_instantiated()
function is replaced with key_is_positive() to avoid confusion as negative
keys are also 'instantiated'.

Additionally, barriering is included:

 (1) Order payload-set before state-set during instantiation.

 (2) Order state-read before payload-read when using the key.

Further separate barriering is necessary if RCU is being used to access the
payload content after reading the payload pointers.

Fixes: 146aa8b1453b ("KEYS: Merge the type-specific data with the payload data")
	Cc: stable@vger.kernel.org # v4.4+
	Reported-by: Eric Biggers <ebiggers@google.com>
	Signed-off-by: David Howells <dhowells@redhat.com>
	Reviewed-by: Eric Biggers <ebiggers@google.com>
(cherry picked from commit 363b02dab09b3226f3bd1420dad9c72b79a42a76)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/key.h
#	net/dns_resolver/dns_key.c
#	security/keys/big_key.c
#	security/keys/encrypted-keys/encrypted.c
#	security/keys/key.c
#	security/keys/keyring.c
#	security/keys/request_key.c
#	security/keys/trusted.c
#	security/keys/user_defined.c
diff --cc include/linux/key.h
index 1f08a8d33a01,8a15cabe928d..000000000000
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@@ -121,6 -127,22 +121,25 @@@ static inline bool is_key_possessed(con
  	return (unsigned long) key_ref & 1UL;
  }
  
++<<<<<<< HEAD
++=======
+ typedef int (*key_restrict_link_func_t)(struct key *dest_keyring,
+ 					const struct key_type *type,
+ 					const union key_payload *payload,
+ 					struct key *restriction_key);
+ 
+ struct key_restriction {
+ 	key_restrict_link_func_t check;
+ 	struct key *key;
+ 	struct key_type *keytype;
+ };
+ 
+ enum key_state {
+ 	KEY_IS_UNINSTANTIATED,
+ 	KEY_IS_POSITIVE,		/* Positively instantiated */
+ };
+ 
++>>>>>>> 363b02dab09b (KEYS: Fix race between updating and finding a negative key)
  /*****************************************************************************/
  /*
   * authentication token / access credential / keyring
@@@ -159,18 -182,16 +179,31 @@@ struct key 
  #endif
  
  	unsigned long		flags;		/* status flags (change with bitops) */
++<<<<<<< HEAD
 +#define KEY_FLAG_INSTANTIATED	0	/* set if key has been instantiated */
 +#define KEY_FLAG_DEAD		1	/* set if key type has been deleted */
 +#define KEY_FLAG_REVOKED	2	/* set if key had been revoked */
 +#define KEY_FLAG_IN_QUOTA	3	/* set if key consumes quota */
 +#define KEY_FLAG_USER_CONSTRUCT	4	/* set if key is being constructed in userspace */
 +#define KEY_FLAG_NEGATIVE	5	/* set if key is negative */
 +#define KEY_FLAG_ROOT_CAN_CLEAR	6	/* set if key can be cleared by root without permission */
 +#define KEY_FLAG_INVALIDATED	7	/* set if key has been invalidated */
 +#define KEY_FLAG_TRUSTED	8	/* set if key is trusted */
 +#define KEY_FLAG_TRUSTED_ONLY	9	/* set if keyring only accepts links to trusted keys */
 +#define KEY_FLAG_BUILTIN	10	/* set if key is builtin */
 +#define KEY_FLAG_ROOT_CAN_INVAL	11	/* set if key can be invalidated by root without permission */
++=======
+ #define KEY_FLAG_DEAD		0	/* set if key type has been deleted */
+ #define KEY_FLAG_REVOKED	1	/* set if key had been revoked */
+ #define KEY_FLAG_IN_QUOTA	2	/* set if key consumes quota */
+ #define KEY_FLAG_USER_CONSTRUCT	3	/* set if key is being constructed in userspace */
+ #define KEY_FLAG_ROOT_CAN_CLEAR	4	/* set if key can be cleared by root without permission */
+ #define KEY_FLAG_INVALIDATED	5	/* set if key has been invalidated */
+ #define KEY_FLAG_BUILTIN	6	/* set if key is built in to the kernel */
+ #define KEY_FLAG_ROOT_CAN_INVAL	7	/* set if key can be invalidated by root without permission */
+ #define KEY_FLAG_KEEP		8	/* set if key should not be removed */
+ #define KEY_FLAG_UID_KEYRING	9	/* set if key is a user or user session keyring */
++>>>>>>> 363b02dab09b (KEYS: Fix race between updating and finding a negative key)
  
  	/* the key type and key description string
  	 * - the desc is used to match a key against search criteria
@@@ -200,14 -211,26 +233,23 @@@
  	 *   whatever
  	 */
  	union {
++<<<<<<< HEAD
 +		union {
 +			unsigned long		value;
 +			void __rcu		*rcudata;
 +			void			*data;
 +			void			*data2[2];
 +		} payload;
 +		struct assoc_array keys;
++=======
+ 		union key_payload payload;
+ 		struct {
+ 			/* Keyring bits */
+ 			struct list_head name_link;
+ 			struct assoc_array keys;
+ 		};
++>>>>>>> 363b02dab09b (KEYS: Fix race between updating and finding a negative key)
  	};
 -
 -	/* This is set on a keyring to restrict the addition of a link to a key
 -	 * to it.  If this structure isn't provided then it is assumed that the
 -	 * keyring is open to any addition.  It is ignored for non-keyring
 -	 * keys. Only set this value using keyring_restrict(), keyring_alloc(),
 -	 * or key_alloc().
 -	 *
 -	 * This is intended for use with rings of trusted keys whereby addition
 -	 * to the keyring needs to be controlled.  KEY_ALLOC_BYPASS_RESTRICTION
 -	 * overrides this, allowing the kernel to add extra keys without
 -	 * restriction.
 -	 */
 -	struct key_restriction *restrict_link;
  };
  
  extern struct key *key_alloc(struct key_type *type,
@@@ -310,21 -345,45 +352,45 @@@ static inline key_serial_t key_serial(c
  
  extern void key_set_timeout(struct key *, unsigned);
  
++<<<<<<< HEAD
++=======
+ /*
+  * The permissions required on a key that we're looking up.
+  */
+ #define	KEY_NEED_VIEW	0x01	/* Require permission to view attributes */
+ #define	KEY_NEED_READ	0x02	/* Require permission to read content */
+ #define	KEY_NEED_WRITE	0x04	/* Require permission to update / modify */
+ #define	KEY_NEED_SEARCH	0x08	/* Require permission to search (keyring) or find (key) */
+ #define	KEY_NEED_LINK	0x10	/* Require permission to link */
+ #define	KEY_NEED_SETATTR 0x20	/* Require permission to change attributes */
+ #define	KEY_NEED_ALL	0x3f	/* All the above permissions */
+ 
+ static inline short key_read_state(const struct key *key)
+ {
+ 	/* Barrier versus mark_key_instantiated(). */
+ 	return smp_load_acquire(&key->state);
+ }
+ 
++>>>>>>> 363b02dab09b (KEYS: Fix race between updating and finding a negative key)
  /**
-  * key_is_instantiated - Determine if a key has been positively instantiated
+  * key_is_positive - Determine if a key has been positively instantiated
   * @key: The key to check.
   *
   * Return true if the specified key has been positively instantiated, false
   * otherwise.
   */
- static inline bool key_is_instantiated(const struct key *key)
+ static inline bool key_is_positive(const struct key *key)
+ {
+ 	return key_read_state(key) == KEY_IS_POSITIVE;
+ }
+ 
+ static inline bool key_is_negative(const struct key *key)
  {
- 	return test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&
- 		!test_bit(KEY_FLAG_NEGATIVE, &key->flags);
+ 	return key_read_state(key) < 0;
  }
  
 -#define dereference_key_rcu(KEY)					\
 -	(rcu_dereference((KEY)->payload.rcu_data0))
 -
 -#define dereference_key_locked(KEY)					\
 -	(rcu_dereference_protected((KEY)->payload.rcu_data0,		\
 +#define rcu_dereference_key(KEY)					\
 +	(rcu_dereference_protected((KEY)->payload.rcudata,		\
  				   rwsem_is_locked(&((struct key *)(KEY))->sem)))
  
  #define rcu_assign_keypointer(KEY, PAYLOAD)				\
diff --cc net/dns_resolver/dns_key.c
index 0a69d0757795,e1d4d898a007..000000000000
--- a/net/dns_resolver/dns_key.c
+++ b/net/dns_resolver/dns_key.c
@@@ -209,10 -223,10 +209,16 @@@ no_match
   */
  static void dns_resolver_describe(const struct key *key, struct seq_file *m)
  {
 +	int err = key->type_data.x[0];
 +
  	seq_puts(m, key->description);
++<<<<<<< HEAD
 +	if (key_is_instantiated(key)) {
++=======
+ 	if (key_is_positive(key)) {
+ 		int err = PTR_ERR(key->payload.data[dns_key_error]);
+ 
++>>>>>>> 363b02dab09b (KEYS: Fix race between updating and finding a negative key)
  		if (err)
  			seq_printf(m, ": %d", err);
  		else
diff --cc security/keys/big_key.c
index c2f91a0cf889,929e14978c42..000000000000
--- a/security/keys/big_key.c
+++ b/security/keys/big_key.c
@@@ -129,7 -247,8 +129,12 @@@ void big_key_revoke(struct key *key
  
  	/* clear the quota */
  	key_payload_reserve(key, 0);
++<<<<<<< HEAD
 +	if (key_is_instantiated(key) && key->type_data.x[1] > BIG_KEY_FILE_THRESHOLD)
++=======
+ 	if (key_is_positive(key) &&
+ 	    (size_t)key->payload.data[big_key_len] > BIG_KEY_FILE_THRESHOLD)
++>>>>>>> 363b02dab09b (KEYS: Fix race between updating and finding a negative key)
  		vfs_truncate(path, 0);
  }
  
@@@ -158,8 -279,8 +163,13 @@@ void big_key_describe(const struct key 
  
  	seq_puts(m, key->description);
  
++<<<<<<< HEAD
 +	if (key_is_instantiated(key))
 +		seq_printf(m, ": %lu [%s]",
++=======
+ 	if (key_is_positive(key))
+ 		seq_printf(m, ": %zu [%s]",
++>>>>>>> 363b02dab09b (KEYS: Fix race between updating and finding a negative key)
  			   datalen,
  			   datalen > BIG_KEY_FILE_THRESHOLD ? "file" : "buff");
  }
diff --cc security/keys/encrypted-keys/encrypted.c
index f03ff1a51afe,d92cbf9687c3..000000000000
--- a/security/keys/encrypted-keys/encrypted.c
+++ b/security/keys/encrypted-keys/encrypted.c
@@@ -822,6 -854,8 +822,11 @@@ static int encrypted_update(struct key 
  	size_t datalen = prep->datalen;
  	int ret = 0;
  
++<<<<<<< HEAD
++=======
+ 	if (key_is_negative(key))
+ 		return -ENOKEY;
++>>>>>>> 363b02dab09b (KEYS: Fix race between updating and finding a negative key)
  	if (datalen <= 0 || datalen > 32767 || !prep->data)
  		return -EINVAL;
  
diff --cc security/keys/key.c
index 4942670578b2,9385e7cc710f..000000000000
--- a/security/keys/key.c
+++ b/security/keys/key.c
@@@ -548,13 -589,10 +560,17 @@@ int key_reject_and_link(struct key *key
  	mutex_lock(&key_construction_mutex);
  
  	/* can't instantiate twice */
- 	if (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {
+ 	if (key->state == KEY_IS_UNINSTANTIATED) {
  		/* mark the key as being negatively instantiated */
  		atomic_inc(&key->user->nikeys);
++<<<<<<< HEAD
 +		key->type_data.reject_error = -error;
 +		smp_wmb();
 +		set_bit(KEY_FLAG_NEGATIVE, &key->flags);
 +		set_bit(KEY_FLAG_INSTANTIATED, &key->flags);
++=======
+ 		mark_key_instantiated(key, -error);
++>>>>>>> 363b02dab09b (KEYS: Fix race between updating and finding a negative key)
  		now = current_kernel_time();
  		key->expiry = now.tv_sec + timeout;
  		key_schedule_gc(key->expiry + key_gc_delay);
diff --cc security/keys/keyring.c
index 001cd5fa73ad,06173b091a74..000000000000
--- a/security/keys/keyring.c
+++ b/security/keys/keyring.c
@@@ -546,9 -598,8 +547,14 @@@ static int keyring_search_iterator(cons
  
  	if (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {
  		/* we set a different error code if we pass a negative key */
++<<<<<<< HEAD
 +		if (kflags & (1 << KEY_FLAG_NEGATIVE)) {
 +			smp_rmb();
 +			ctx->result = ERR_PTR(key->type_data.reject_error);
++=======
+ 		if (state < 0) {
+ 			ctx->result = ERR_PTR(state);
++>>>>>>> 363b02dab09b (KEYS: Fix race between updating and finding a negative key)
  			kleave(" = %d [neg]", ctx->skipped_ret);
  			goto skipped;
  		}
diff --cc security/keys/request_key.c
index 5fbc2bb545f6,e8036cd0ad54..000000000000
--- a/security/keys/request_key.c
+++ b/security/keys/request_key.c
@@@ -586,10 -595,9 +586,16 @@@ int wait_for_key_construction(struct ke
  			  intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);
  	if (ret)
  		return -ERESTARTSYS;
++<<<<<<< HEAD
 +	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {
 +		smp_rmb();
 +		return key->type_data.reject_error;
 +	}
++=======
+ 	ret = key_read_state(key);
+ 	if (ret < 0)
+ 		return ret;
++>>>>>>> 363b02dab09b (KEYS: Fix race between updating and finding a negative key)
  	return key_validate(key);
  }
  EXPORT_SYMBOL(wait_for_key_construction);
diff --cc security/keys/trusted.c
index 85c9acff3892,bd85315cbfeb..000000000000
--- a/security/keys/trusted.c
+++ b/security/keys/trusted.c
@@@ -1067,6 -1066,9 +1067,12 @@@ static int trusted_update(struct key *k
  	char *datablob;
  	int ret = 0;
  
++<<<<<<< HEAD
++=======
+ 	if (key_is_negative(key))
+ 		return -ENOKEY;
+ 	p = key->payload.data[0];
++>>>>>>> 363b02dab09b (KEYS: Fix race between updating and finding a negative key)
  	if (!p->migratable)
  		return -EPERM;
  	if (datalen <= 0 || datalen > 32767 || !prep->data)
diff --cc security/keys/user_defined.c
index faa2caeb593f,9f558bedba23..000000000000
--- a/security/keys/user_defined.c
+++ b/security/keys/user_defined.c
@@@ -97,54 -104,27 +97,63 @@@ EXPORT_SYMBOL_GPL(user_instantiate)
   */
  int user_update(struct key *key, struct key_preparsed_payload *prep)
  {
 -	struct user_key_payload *zap = NULL;
 +	struct user_key_payload *upayload, *zap;
 +	size_t datalen = prep->datalen;
  	int ret;
  
 +	ret = -EINVAL;
 +	if (datalen <= 0 || datalen > 32767 || !prep->data)
 +		goto error;
 +
++<<<<<<< HEAD
 +	/* construct a replacement payload */
 +	ret = -ENOMEM;
 +	upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
 +	if (!upayload)
 +		goto error;
 +
 +	upayload->datalen = datalen;
 +	memcpy(upayload->data, prep->data, datalen);
 +
  	/* check the quota and attach the new data */
 -	ret = key_payload_reserve(key, prep->datalen);
 -	if (ret < 0)
 -		return ret;
 +	zap = upayload;
 +
 +	ret = key_payload_reserve(key, datalen);
  
 +	if (ret == 0) {
 +		/* attach the new data, displacing the old */
 +		zap = key->payload.data;
 +		rcu_assign_keypointer(key, upayload);
 +		key->expiry = 0;
 +	}
++=======
+ 	/* attach the new data, displacing the old */
+ 	key->expiry = prep->expiry;
+ 	if (key_is_positive(key))
+ 		zap = dereference_key_locked(key);
+ 	rcu_assign_keypointer(key, prep->payload.data[0]);
+ 	prep->payload.data[0] = NULL;
++>>>>>>> 363b02dab09b (KEYS: Fix race between updating and finding a negative key)
  
  	if (zap)
 -		call_rcu(&zap->rcu, user_free_payload_rcu);
 +		kfree_rcu(zap, rcu);
 +
 +error:
  	return ret;
  }
 +
  EXPORT_SYMBOL_GPL(user_update);
  
 +/*
 + * match users on their name
 + */
 +int user_match(const struct key *key, const void *description)
 +{
 +	return strcmp(key->description, description) == 0;
 +}
 +
 +EXPORT_SYMBOL_GPL(user_match);
 +
  /*
   * dispose of the links from a revoked keyring
   * - called with the key sem write-locked
* Unmerged path include/linux/key.h
* Unmerged path net/dns_resolver/dns_key.c
* Unmerged path security/keys/big_key.c
* Unmerged path security/keys/encrypted-keys/encrypted.c
diff --git a/security/keys/gc.c b/security/keys/gc.c
index adc72e4e6a23..028413d65c98 100644
--- a/security/keys/gc.c
+++ b/security/keys/gc.c
@@ -129,15 +129,15 @@ static noinline void key_gc_unused_keys(struct list_head *keys)
 	while (!list_empty(keys)) {
 		struct key *key =
 			list_entry(keys->next, struct key, graveyard_link);
+		short state = key->state;
+
 		list_del(&key->graveyard_link);
 
 		kdebug("- %u", key->serial);
 		key_check(key);
 
 		/* Throw away the key data if the key is instantiated */
-		if (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&
-		    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&
-		    key->type->destroy)
+		if (state == KEY_IS_POSITIVE && key->type->destroy)
 			key->type->destroy(key);
 
 		security_key_free(key);
@@ -151,7 +151,7 @@ static noinline void key_gc_unused_keys(struct list_head *keys)
 		}
 
 		atomic_dec(&key->user->nkeys);
-		if (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))
+		if (state != KEY_IS_UNINSTANTIATED)
 			atomic_dec(&key->user->nikeys);
 
 		key_user_put(key->user);
* Unmerged path security/keys/key.c
diff --git a/security/keys/keyctl.c b/security/keys/keyctl.c
index d50537fd5d4f..68f7dddb87a6 100644
--- a/security/keys/keyctl.c
+++ b/security/keys/keyctl.c
@@ -748,10 +748,9 @@ long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)
 
 	key = key_ref_to_ptr(key_ref);
 
-	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {
-		ret = -ENOKEY;
-		goto error2;
-	}
+	ret = key_read_state(key);
+	if (ret < 0)
+		goto error2; /* Negatively instantiated */
 
 	/* see if we can read it directly */
 	ret = key_permission(key_ref, KEY_READ);
@@ -883,7 +882,7 @@ long keyctl_chown_key(key_serial_t id, uid_t user, gid_t group)
 		atomic_dec(&key->user->nkeys);
 		atomic_inc(&newowner->nkeys);
 
-		if (test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {
+		if (key->state != KEY_IS_UNINSTANTIATED) {
 			atomic_dec(&key->user->nikeys);
 			atomic_inc(&newowner->nikeys);
 		}
* Unmerged path security/keys/keyring.c
diff --git a/security/keys/proc.c b/security/keys/proc.c
index 350f5f61c840..3201851bfd6d 100644
--- a/security/keys/proc.c
+++ b/security/keys/proc.c
@@ -188,6 +188,7 @@ static int proc_keys_show(struct seq_file *m, void *v)
 	unsigned long timo;
 	key_ref_t key_ref, skey_ref;
 	char xbuf[16];
+	short state;
 	int rc;
 
 	struct keyring_search_context ctx = {
@@ -246,17 +247,19 @@ static int proc_keys_show(struct seq_file *m, void *v)
 			sprintf(xbuf, "%luw", timo / (60*60*24*7));
 	}
 
+	state = key_read_state(key);
+
 #define showflag(KEY, LETTER, FLAG) \
 	(test_bit(FLAG,	&(KEY)->flags) ? LETTER : '-')
 
 	seq_printf(m, "%08x %c%c%c%c%c%c%c %5d %4s %08x %5d %5d %-9.9s ",
 		   key->serial,
-		   showflag(key, 'I', KEY_FLAG_INSTANTIATED),
+		   state != KEY_IS_UNINSTANTIATED ? 'I' : '-',
 		   showflag(key, 'R', KEY_FLAG_REVOKED),
 		   showflag(key, 'D', KEY_FLAG_DEAD),
 		   showflag(key, 'Q', KEY_FLAG_IN_QUOTA),
 		   showflag(key, 'U', KEY_FLAG_USER_CONSTRUCT),
-		   showflag(key, 'N', KEY_FLAG_NEGATIVE),
+		   state < 0 ? 'N' : '-',
 		   showflag(key, 'i', KEY_FLAG_INVALIDATED),
 		   atomic_read(&key->usage),
 		   xbuf,
diff --git a/security/keys/process_keys.c b/security/keys/process_keys.c
index 221b509138f9..4258f23ec023 100644
--- a/security/keys/process_keys.c
+++ b/security/keys/process_keys.c
@@ -722,7 +722,7 @@ try_again:
 
 	ret = -EIO;
 	if (!(lflags & KEY_LOOKUP_PARTIAL) &&
-	    !test_bit(KEY_FLAG_INSTANTIATED, &key->flags))
+	    key_read_state(key) == KEY_IS_UNINSTANTIATED)
 		goto invalid_key;
 
 	/* check the permissions */
* Unmerged path security/keys/request_key.c
diff --git a/security/keys/request_key_auth.c b/security/keys/request_key_auth.c
index cb3e3e577090..2dab9516082e 100644
--- a/security/keys/request_key_auth.c
+++ b/security/keys/request_key_auth.c
@@ -60,7 +60,7 @@ static void request_key_auth_describe(const struct key *key,
 
 	seq_puts(m, "key:");
 	seq_puts(m, key->description);
-	if (key_is_instantiated(key))
+	if (key_is_positive(key))
 		seq_printf(m, " pid:%d ci:%zu", rka->pid, rka->callout_len);
 }
 
* Unmerged path security/keys/trusted.c
* Unmerged path security/keys/user_defined.c
