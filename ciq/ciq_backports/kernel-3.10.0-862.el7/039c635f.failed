ide, scsi: Tell the block layer at request allocation time about preempt requests

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Bart Van Assche <bart.vanassche@wdc.com>
commit 039c635f4e666b647df2100038de276a83fb3fca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/039c635f.failed

Convert blk_get_request(q, op, __GFP_RECLAIM) into
blk_get_request_flags(q, op, BLK_MQ_PREEMPT). This patch does not
change any functionality.

	Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
	Tested-by: Martin Steigerwald <martin@lichtvoll.de>
	Acked-by: David S. Miller <davem@davemloft.net> [ for IDE ]
	Acked-by: Martin K. Petersen <martin.petersen@oracle.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Tested-by: Oleksandr Natalenko <oleksandr@natalenko.name>
	Cc: Ming Lei <ming.lei@redhat.com>
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 039c635f4e666b647df2100038de276a83fb3fca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/ide/ide-pm.c
#	drivers/scsi/scsi_lib.c
diff --cc drivers/ide/ide-pm.c
index 8d1e32d7cd97,f56d742908df..000000000000
--- a/drivers/ide/ide-pm.c
+++ b/drivers/ide/ide-pm.c
@@@ -58,9 -89,9 +58,15 @@@ int generic_ide_resume(struct device *d
  	}
  
  	memset(&rqpm, 0, sizeof(rqpm));
++<<<<<<< HEAD
 +	rq = blk_get_request(drive->queue, READ, __GFP_WAIT);
 +	rq->cmd_type = REQ_TYPE_PM_RESUME;
 +	rq->cmd_flags |= REQ_PREEMPT;
++=======
+ 	rq = blk_get_request_flags(drive->queue, REQ_OP_DRV_IN,
+ 				   BLK_MQ_REQ_PREEMPT);
+ 	ide_req(rq)->type = ATA_PRIV_PM_RESUME;
++>>>>>>> 039c635f4e66 (ide, scsi: Tell the block layer at request allocation time about preempt requests)
  	rq->special = &rqpm;
  	rqpm.pm_step = IDE_PM_START_RESUME;
  	rqpm.pm_state = PM_EVENT_ON;
diff --cc drivers/scsi/scsi_lib.c
index 540886abddcc,eb129dfc2ebe..000000000000
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@@ -184,25 -249,26 +184,36 @@@ int scsi_execute(struct scsi_device *sd
  		 int *resid)
  {
  	struct request *req;
 -	struct scsi_request *rq;
 +	int write = (data_direction == DMA_TO_DEVICE);
  	int ret = DRIVER_ERROR << 24;
  
++<<<<<<< HEAD
 +	req = blk_get_request(sdev->request_queue, write, __GFP_WAIT);
++=======
+ 	req = blk_get_request_flags(sdev->request_queue,
+ 			data_direction == DMA_TO_DEVICE ?
+ 			REQ_OP_SCSI_OUT : REQ_OP_SCSI_IN, BLK_MQ_REQ_PREEMPT);
++>>>>>>> 039c635f4e66 (ide, scsi: Tell the block layer at request allocation time about preempt requests)
  	if (IS_ERR(req))
  		return ret;
 -	rq = scsi_req(req);
 +	blk_rq_set_block_pc(req);
  
  	if (bufflen &&	blk_rq_map_kern(sdev->request_queue, req,
 -					buffer, bufflen, __GFP_RECLAIM))
 +					buffer, bufflen, __GFP_WAIT))
  		goto out;
  
 -	rq->cmd_len = COMMAND_SIZE(cmd[0]);
 -	memcpy(rq->cmd, cmd, rq->cmd_len);
 -	rq->retries = retries;
 +	req->cmd_len = COMMAND_SIZE(cmd[0]);
 +	memcpy(req->cmd, cmd, req->cmd_len);
 +	req->sense = sense;
 +	req->sense_len = 0;
 +	req->retries = retries;
  	req->timeout = timeout;
++<<<<<<< HEAD
 +	req->cmd_flags |= flags | REQ_QUIET | REQ_PREEMPT;
++=======
+ 	req->cmd_flags |= flags;
+ 	req->rq_flags |= rq_flags | RQF_QUIET;
++>>>>>>> 039c635f4e66 (ide, scsi: Tell the block layer at request allocation time about preempt requests)
  
  	/*
  	 * head injection *required* here otherwise quiesce won't work
* Unmerged path drivers/ide/ide-pm.c
* Unmerged path drivers/scsi/scsi_lib.c
