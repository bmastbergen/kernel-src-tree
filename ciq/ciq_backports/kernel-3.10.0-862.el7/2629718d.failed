fsnotify: Remove useless list deletion and comment

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jan Kara <jack@suse.cz>
commit 2629718dd26f89e064dcdec6c8e5b9713502e1f8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2629718d.failed

After removing all the indirection it is clear that

hlist_del_init_rcu(&mark->obj_list);

in fsnotify_destroy_marks() is not needed as the mark gets removed from
the list shortly afterwards in fsnotify_destroy_mark() ->
fsnotify_detach_mark() -> fsnotify_detach_from_object(). Also there is
no problem with mark being visible on object list while we call
fsnotify_destroy_mark() as parallel destruction of marks from several
places is properly handled (as mentioned in the comment in
fsnotify_destroy_marks(). So just remove the list removal and also the
stale comment.

	Reviewed-by: Miklos Szeredi <mszeredi@redhat.com>
	Reviewed-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
(cherry picked from commit 2629718dd26f89e064dcdec6c8e5b9713502e1f8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/notify/mark.c
diff --cc fs/notify/mark.c
index 44836e539169,b5b641a2b557..000000000000
--- a/fs/notify/mark.c
+++ b/fs/notify/mark.c
@@@ -499,6 -592,41 +499,44 @@@ void fsnotify_detach_group_marks(struc
  	}
  }
  
++<<<<<<< HEAD
++=======
+ void fsnotify_destroy_marks(struct fsnotify_mark_connector *conn)
+ {
+ 	struct fsnotify_mark *mark;
+ 	spinlock_t *lock;
+ 
+ 	if (!conn)
+ 		return;
+ 
+ 	if (conn->flags & FSNOTIFY_OBJ_TYPE_INODE)
+ 		lock = &conn->inode->i_lock;
+ 	else
+ 		lock = &conn->mnt->mnt_root->d_lock;
+ 
+ 	while (1) {
+ 		/*
+ 		 * We have to be careful since we can race with e.g.
+ 		 * fsnotify_clear_marks_by_group() and once we drop 'lock',
+ 		 * mark can get removed from the obj_list and destroyed. But
+ 		 * we are holding mark reference so mark cannot be freed and
+ 		 * calling fsnotify_destroy_mark() more than once is fine.
+ 		 */
+ 		spin_lock(lock);
+ 		if (hlist_empty(&conn->list)) {
+ 			spin_unlock(lock);
+ 			break;
+ 		}
+ 		mark = hlist_entry(conn->list.first, struct fsnotify_mark,
+ 				   obj_list);
+ 		fsnotify_get_mark(mark);
+ 		spin_unlock(lock);
+ 		fsnotify_destroy_mark(mark, mark->group);
+ 		fsnotify_put_mark(mark);
+ 	}
+ }
+ 
++>>>>>>> 2629718dd26f (fsnotify: Remove useless list deletion and comment)
  /*
   * Nothing fancy, just initialize lists and locks and counters.
   */
* Unmerged path fs/notify/mark.c
