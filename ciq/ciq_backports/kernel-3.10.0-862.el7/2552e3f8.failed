blk-mq: get rid of confusing blk_map_ctx structure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jens Axboe <axboe@fb.com>
commit 2552e3f878c2b43b41d7728a328821d8220c28da
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2552e3f8.failed

We can just use struct blk_mq_alloc_data - it has a few more
members, but we allocate it further down the stack anyway. So
this cleans up the code, and reduces the stack overhead a bit.

	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 2552e3f878c2b43b41d7728a328821d8220c28da)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq.c
diff --cc block/blk-mq.c
index 49418900af65,d74a74a9f9ef..000000000000
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@@ -1306,35 -1197,21 +1301,48 @@@ static struct request *blk_mq_map_reque
  	struct blk_mq_hw_ctx *hctx;
  	struct blk_mq_ctx *ctx;
  	struct request *rq;
++<<<<<<< HEAD
 +	int rw = bio_data_dir(bio);
 +	struct blk_mq_alloc_data alloc_data;
++=======
+ 	int op = bio_data_dir(bio);
+ 	int op_flags = 0;
++>>>>>>> 2552e3f878c2 (blk-mq: get rid of confusing blk_map_ctx structure)
  
  	blk_queue_enter_live(q);
  	ctx = blk_mq_get_ctx(q);
 -	hctx = blk_mq_map_queue(q, ctx->cpu);
 +	hctx = q->mq_ops->map_queue(q, ctx->cpu);
  
 -	if (rw_is_sync(bio_op(bio), bio->bi_opf))
 -		op_flags |= REQ_SYNC;
 +	if (rw_is_sync(bio->bi_rw))
 +		rw |= REQ_SYNC;
  
++<<<<<<< HEAD
 +	trace_block_getrq(q, bio, rw);
 +	blk_mq_set_alloc_data(&alloc_data, q, BLK_MQ_REQ_NOWAIT, ctx, hctx);
 +	rq = __blk_mq_alloc_request(&alloc_data, rw);
 +	if (unlikely(!rq)) {
 +		__blk_mq_run_hw_queue(hctx);
 +		blk_mq_put_ctx(ctx);
 +		trace_block_sleeprq(q, bio, rw);
 +
 +		ctx = blk_mq_get_ctx(q);
 +		hctx = q->mq_ops->map_queue(q, ctx->cpu);
 +		blk_mq_set_alloc_data(&alloc_data, q, 0, ctx, hctx);
 +		rq = __blk_mq_alloc_request(&alloc_data, rw);
 +		ctx = alloc_data.ctx;
 +		hctx = alloc_data.hctx;
 +	}
 +
 +	hctx->queued++;
 +	data->hctx = hctx;
 +	data->ctx = ctx;
++=======
+ 	trace_block_getrq(q, bio, op);
+ 	blk_mq_set_alloc_data(data, q, 0, ctx, hctx);
+ 	rq = __blk_mq_alloc_request(data, op, op_flags);
+ 
+ 	data->hctx->queued++;
++>>>>>>> 2552e3f878c2 (blk-mq: get rid of confusing blk_map_ctx structure)
  	return rq;
  }
  
@@@ -1379,15 -1255,16 +1387,21 @@@ insert
   * but will attempt to bypass the hctx queueing if we can go straight to
   * hardware for SYNC IO.
   */
 -static blk_qc_t blk_mq_make_request(struct request_queue *q, struct bio *bio)
 +static void blk_mq_make_request(struct request_queue *q, struct bio *bio)
  {
++<<<<<<< HEAD
 +	const int is_sync = rw_is_sync(bio->bi_rw);
 +	const int is_flush_fua = bio->bi_rw & (REQ_FLUSH | REQ_FUA);
 +	struct blk_map_ctx data;
++=======
+ 	const int is_sync = rw_is_sync(bio_op(bio), bio->bi_opf);
+ 	const int is_flush_fua = bio->bi_opf & (REQ_PREFLUSH | REQ_FUA);
+ 	struct blk_mq_alloc_data data;
++>>>>>>> 2552e3f878c2 (blk-mq: get rid of confusing blk_map_ctx structure)
  	struct request *rq;
 -	unsigned int request_count = 0;
 +	unsigned int request_count = 0, srcu_idx;
  	struct blk_plug *plug;
  	struct request *same_queue_rq = NULL;
 -	blk_qc_t cookie;
  
  	blk_queue_bounce(q, &bio);
  
@@@ -1473,14 -1349,15 +1487,14 @@@ run_queue
   * Single hardware queue variant. This will attempt to use any per-process
   * plug for merging and IO deferral.
   */
 -static blk_qc_t blk_sq_make_request(struct request_queue *q, struct bio *bio)
 +static void blk_sq_make_request(struct request_queue *q, struct bio *bio)
  {
 -	const int is_sync = rw_is_sync(bio_op(bio), bio->bi_opf);
 -	const int is_flush_fua = bio->bi_opf & (REQ_PREFLUSH | REQ_FUA);
 +	const int is_sync = rw_is_sync(bio->bi_rw);
 +	const int is_flush_fua = bio->bi_rw & (REQ_FLUSH | REQ_FUA);
  	struct blk_plug *plug;
  	unsigned int request_count = 0;
- 	struct blk_map_ctx data;
+ 	struct blk_mq_alloc_data data;
  	struct request *rq;
 -	blk_qc_t cookie;
  
  	blk_queue_bounce(q, &bio);
  
* Unmerged path block/blk-mq.c
