IB/hfi1: Convert hfi1_error_port_qps() to use new QP iterator

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Mike Marciniszyn <mike.marciniszyn@intel.com>
commit dff2fe7e8cd92435a93555b29d9d95fed955c558
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/dff2fe7e.failed

Change hfi1_error_port_qps() to use the new rvt_qp_iter() in its QP
scanning.

	Reviewed-by: Kaike Wan <kaike.wan@intel.com>
	Signed-off-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit dff2fe7e8cd92435a93555b29d9d95fed955c558)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/qp.c
diff --cc drivers/infiniband/hw/hfi1/qp.c
index 702e03b67466,af711318f84b..000000000000
--- a/drivers/infiniband/hw/hfi1/qp.c
+++ b/drivers/infiniband/hw/hfi1/qp.c
@@@ -849,44 -919,8 +888,44 @@@ static void hfi1_qp_iter_cb(struct rvt_
   */
  void hfi1_error_port_qps(struct hfi1_ibport *ibp, u8 sl)
  {
- 	struct rvt_qp *qp = NULL;
  	struct hfi1_pportdata *ppd = ppd_from_ibp(ibp);
  	struct hfi1_ibdev *dev = &ppd->dd->verbs_dev;
- 	int n;
- 	int lastwqe;
- 	struct ib_event ev;
  
++<<<<<<< HEAD
 +	rcu_read_lock();
 +
 +	/* Deal only with RC/UC qps that use the given SL. */
 +	for (n = 0; n < dev->rdi.qp_dev->qp_table_size; n++) {
 +		for (qp = rcu_dereference(dev->rdi.qp_dev->qp_table[n]); qp;
 +			qp = rcu_dereference(qp->next)) {
 +			if (qp->port_num == ppd->port &&
 +			    (qp->ibqp.qp_type == IB_QPT_UC ||
 +			     qp->ibqp.qp_type == IB_QPT_RC) &&
 +			    qp->remote_ah_attr.sl == sl &&
 +			    (ib_rvt_state_ops[qp->state] &
 +			     RVT_POST_SEND_OK)) {
 +				spin_lock_irq(&qp->r_lock);
 +				spin_lock(&qp->s_hlock);
 +				spin_lock(&qp->s_lock);
 +				lastwqe = rvt_error_qp(qp,
 +						       IB_WC_WR_FLUSH_ERR);
 +				spin_unlock(&qp->s_lock);
 +				spin_unlock(&qp->s_hlock);
 +				spin_unlock_irq(&qp->r_lock);
 +				if (lastwqe) {
 +					ev.device = qp->ibqp.device;
 +					ev.element.qp = &qp->ibqp;
 +					ev.event =
 +						IB_EVENT_QP_LAST_WQE_REACHED;
 +					qp->ibqp.event_handler(&ev,
 +						qp->ibqp.qp_context);
 +				}
 +			}
 +		}
 +	}
 +
 +	rcu_read_unlock();
++=======
+ 	rvt_qp_iter(&dev->rdi, sl, hfi1_qp_iter_cb);
++>>>>>>> dff2fe7e8cd9 (IB/hfi1: Convert hfi1_error_port_qps() to use new QP iterator)
  }
* Unmerged path drivers/infiniband/hw/hfi1/qp.c
