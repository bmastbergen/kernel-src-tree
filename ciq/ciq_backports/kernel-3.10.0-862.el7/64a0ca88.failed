nvmet: Introduced helper routine for controller status check.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [nvme] Introduced helper routine for controller status check (David Milburn) [1457880 1456486 1454365]
Rebuild_FUZZ: 92.98%
commit-author Parav Pandit <parav@mellanox.com>
commit 64a0ca88eaa66e3d219296b17aa08b78894e42c8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/64a0ca88.failed

This patch introduces helper function for checking controller
status during admin and io command processing which returns u16
status. As to bring consistency on returning status, other
friend functions also now return u16 status instead of int
to match the spec.

As part of the theseerror log prints in also prints qid on
which command error occured.

	Signed-off-by: Parav Pandit <parav@mellanox.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 64a0ca88eaa66e3d219296b17aa08b78894e42c8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/target/admin-cmd.c
#	drivers/nvme/target/io-cmd.c
diff --cc drivers/nvme/target/admin-cmd.c
index 0950c2264854,105ace88d07e..000000000000
--- a/drivers/nvme/target/admin-cmd.c
+++ b/drivers/nvme/target/admin-cmd.c
@@@ -483,16 -487,9 +484,22 @@@ u16 nvmet_parse_admin_cmd(struct nvmet_
  
  	req->ns = NULL;
  
++<<<<<<< HEAD
 +	if (unlikely(!(req->sq->ctrl->cc & NVME_CC_ENABLE))) {
 +		pr_err("nvmet: got admin cmd %d while CC.EN == 0\n",
 +				cmd->common.opcode);
 +		return NVME_SC_CMD_SEQ_ERROR | NVME_SC_DNR;
 +	}
 +	if (unlikely(!(req->sq->ctrl->csts & NVME_CSTS_RDY))) {
 +		pr_err("nvmet: got admin cmd %d while CSTS.RDY == 0\n",
 +				cmd->common.opcode);
 +		return NVME_SC_CMD_SEQ_ERROR | NVME_SC_DNR;
 +	}
++=======
+ 	ret = nvmet_check_ctrl_status(req, cmd);
+ 	if (unlikely(ret))
+ 		return ret;
++>>>>>>> 64a0ca88eaa6 (nvmet: Introduced helper routine for controller status check.)
  
  	switch (cmd->common.opcode) {
  	case nvme_admin_get_log_page:
@@@ -542,6 -539,7 +549,11 @@@
  		return 0;
  	}
  
++<<<<<<< HEAD
 +	pr_err("nvmet: unhandled cmd %d\n", cmd->common.opcode);
++=======
+ 	pr_err("unhandled cmd %d on qid %d\n", cmd->common.opcode,
+ 	       req->sq->qid);
++>>>>>>> 64a0ca88eaa6 (nvmet: Introduced helper routine for controller status check.)
  	return NVME_SC_INVALID_OPCODE | NVME_SC_DNR;
  }
diff --cc drivers/nvme/target/io-cmd.c
index 625d63c62bf4,27623f2bfe6b..000000000000
--- a/drivers/nvme/target/io-cmd.c
+++ b/drivers/nvme/target/io-cmd.c
@@@ -174,22 -170,41 +174,60 @@@ static void nvmet_execute_dsm(struct nv
  	}
  }
  
++<<<<<<< HEAD
 +int nvmet_parse_io_cmd(struct nvmet_req *req)
++=======
+ static void nvmet_execute_write_zeroes(struct nvmet_req *req)
+ {
+ 	struct nvme_write_zeroes_cmd *write_zeroes = &req->cmd->write_zeroes;
+ 	struct bio *bio = NULL;
+ 	u16 status = NVME_SC_SUCCESS;
+ 	sector_t sector;
+ 	sector_t nr_sector;
+ 
+ 	sector = le64_to_cpu(write_zeroes->slba) <<
+ 		(req->ns->blksize_shift - 9);
+ 	nr_sector = (((sector_t)le32_to_cpu(write_zeroes->length)) <<
+ 		(req->ns->blksize_shift - 9)) + 1;
+ 
+ 	if (__blkdev_issue_zeroout(req->ns->bdev, sector, nr_sector,
+ 				GFP_KERNEL, &bio, true))
+ 		status = NVME_SC_INTERNAL | NVME_SC_DNR;
+ 
+ 	if (bio) {
+ 		bio->bi_private = req;
+ 		bio->bi_end_io = nvmet_bio_done;
+ 		submit_bio(bio);
+ 	} else {
+ 		nvmet_req_complete(req, status);
+ 	}
+ }
+ 
+ u16 nvmet_parse_io_cmd(struct nvmet_req *req)
++>>>>>>> 64a0ca88eaa6 (nvmet: Introduced helper routine for controller status check.)
  {
  	struct nvme_command *cmd = req->cmd;
+ 	u16 ret;
  
++<<<<<<< HEAD
 +	if (unlikely(!(req->sq->ctrl->cc & NVME_CC_ENABLE))) {
 +		pr_err("nvmet: got io cmd %d while CC.EN == 0\n",
 +				cmd->common.opcode);
 +		req->ns = NULL;
 +		return NVME_SC_CMD_SEQ_ERROR | NVME_SC_DNR;
 +	}
 +
 +	if (unlikely(!(req->sq->ctrl->csts & NVME_CSTS_RDY))) {
 +		pr_err("nvmet: got io cmd %d while CSTS.RDY == 0\n",
 +				cmd->common.opcode);
 +		req->ns = NULL;
 +		return NVME_SC_CMD_SEQ_ERROR | NVME_SC_DNR;
++=======
+ 	ret = nvmet_check_ctrl_status(req, cmd);
+ 	if (unlikely(ret)) {
+ 		req->ns = NULL;
+ 		return ret;
++>>>>>>> 64a0ca88eaa6 (nvmet: Introduced helper routine for controller status check.)
  	}
  
  	req->ns = nvmet_find_namespace(req->sq->ctrl, cmd->rw.nsid);
@@@ -208,11 -223,15 +246,16 @@@
  		return 0;
  	case nvme_cmd_dsm:
  		req->execute = nvmet_execute_dsm;
 -		req->data_len = le32_to_cpu(cmd->dsm.nr + 1) *
 +		req->data_len = (le32_to_cpu(cmd->dsm.nr) + 1) *
  			sizeof(struct nvme_dsm_range);
  		return 0;
 -	case nvme_cmd_write_zeroes:
 -		req->execute = nvmet_execute_write_zeroes;
 -		return 0;
  	default:
++<<<<<<< HEAD
 +		pr_err("nvmet: unhandled cmd %d\n", cmd->common.opcode);
++=======
+ 		pr_err("unhandled cmd %d on qid %d\n", cmd->common.opcode,
+ 		       req->sq->qid);
++>>>>>>> 64a0ca88eaa6 (nvmet: Introduced helper routine for controller status check.)
  		return NVME_SC_INVALID_OPCODE | NVME_SC_DNR;
  	}
  }
* Unmerged path drivers/nvme/target/admin-cmd.c
diff --git a/drivers/nvme/target/core.c b/drivers/nvme/target/core.c
index b29e7483affb..0865505d55da 100644
--- a/drivers/nvme/target/core.c
+++ b/drivers/nvme/target/core.c
@@ -659,6 +659,23 @@ out:
 	return status;
 }
 
+u16 nvmet_check_ctrl_status(struct nvmet_req *req, struct nvme_command *cmd)
+{
+	if (unlikely(!(req->sq->ctrl->cc & NVME_CC_ENABLE))) {
+		pr_err("got io cmd %d while CC.EN == 0 on qid = %d\n",
+		       cmd->common.opcode, req->sq->qid);
+		return NVME_SC_CMD_SEQ_ERROR | NVME_SC_DNR;
+	}
+
+	if (unlikely(!(req->sq->ctrl->csts & NVME_CSTS_RDY))) {
+		pr_err("got io cmd %d while CSTS.RDY == 0 on qid = %d\n",
+		       cmd->common.opcode, req->sq->qid);
+		req->ns = NULL;
+		return NVME_SC_CMD_SEQ_ERROR | NVME_SC_DNR;
+	}
+	return 0;
+}
+
 static bool __nvmet_host_allowed(struct nvmet_subsys *subsys,
 		const char *hostnqn)
 {
diff --git a/drivers/nvme/target/discovery.c b/drivers/nvme/target/discovery.c
index 12f39eea569f..c704cceda657 100644
--- a/drivers/nvme/target/discovery.c
+++ b/drivers/nvme/target/discovery.c
@@ -159,7 +159,7 @@ out:
 	nvmet_req_complete(req, status);
 }
 
-int nvmet_parse_discovery_cmd(struct nvmet_req *req)
+u16 nvmet_parse_discovery_cmd(struct nvmet_req *req)
 {
 	struct nvme_command *cmd = req->cmd;
 
diff --git a/drivers/nvme/target/fabrics-cmd.c b/drivers/nvme/target/fabrics-cmd.c
index 8bd022af3df6..2a3c15b57f6e 100644
--- a/drivers/nvme/target/fabrics-cmd.c
+++ b/drivers/nvme/target/fabrics-cmd.c
@@ -73,7 +73,7 @@ static void nvmet_execute_prop_get(struct nvmet_req *req)
 	nvmet_req_complete(req, status);
 }
 
-int nvmet_parse_fabrics_cmd(struct nvmet_req *req)
+u16 nvmet_parse_fabrics_cmd(struct nvmet_req *req)
 {
 	struct nvme_command *cmd = req->cmd;
 
@@ -214,7 +214,7 @@ out_ctrl_put:
 	goto out;
 }
 
-int nvmet_parse_connect_cmd(struct nvmet_req *req)
+u16 nvmet_parse_connect_cmd(struct nvmet_req *req)
 {
 	struct nvme_command *cmd = req->cmd;
 
* Unmerged path drivers/nvme/target/io-cmd.c
diff --git a/drivers/nvme/target/nvmet.h b/drivers/nvme/target/nvmet.h
index b3b9aadd9d09..e115ae68ca80 100644
--- a/drivers/nvme/target/nvmet.h
+++ b/drivers/nvme/target/nvmet.h
@@ -254,11 +254,11 @@ struct nvmet_async_event {
 	u8			log_page;
 };
 
-int nvmet_parse_connect_cmd(struct nvmet_req *req);
-int nvmet_parse_io_cmd(struct nvmet_req *req);
-int nvmet_parse_admin_cmd(struct nvmet_req *req);
-int nvmet_parse_discovery_cmd(struct nvmet_req *req);
-int nvmet_parse_fabrics_cmd(struct nvmet_req *req);
+u16 nvmet_parse_connect_cmd(struct nvmet_req *req);
+u16 nvmet_parse_io_cmd(struct nvmet_req *req);
+u16 nvmet_parse_admin_cmd(struct nvmet_req *req);
+u16 nvmet_parse_discovery_cmd(struct nvmet_req *req);
+u16 nvmet_parse_fabrics_cmd(struct nvmet_req *req);
 
 bool nvmet_req_init(struct nvmet_req *req, struct nvmet_cq *cq,
 		struct nvmet_sq *sq, struct nvmet_fabrics_ops *ops);
@@ -279,6 +279,7 @@ u16 nvmet_alloc_ctrl(const char *subsysnqn, const char *hostnqn,
 u16 nvmet_ctrl_find_get(const char *subsysnqn, const char *hostnqn, u16 cntlid,
 		struct nvmet_req *req, struct nvmet_ctrl **ret);
 void nvmet_ctrl_put(struct nvmet_ctrl *ctrl);
+u16 nvmet_check_ctrl_status(struct nvmet_req *req, struct nvme_command *cmd);
 
 struct nvmet_subsys *nvmet_subsys_alloc(const char *subsysnqn,
 		enum nvme_subsys_type type);
