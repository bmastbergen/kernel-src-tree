net/mlx5e: Change 1PPS out scheme

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Change 1PPS out scheme (Kamal Heib) [1456694]
Rebuild_FUZZ: 93.55%
commit-author Eugenia Emantayev <eugenia@mellanox.com>
commit 4272f9b88db9223216cdf87314f570f6d81295b4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4272f9b8.failed

In order to fix the drift in 1PPS out need to adjust the next pulse.
On each 1PPS out falling edge driver gets the event, then the event
handler adjusts the next pulse starting time.

Fixes: ee7f12205abc ('net/mlx5e: Implement 1PPS support')
	Signed-off-by: Eugenia Emantayev <eugenia@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 4272f9b88db9223216cdf87314f570f6d81295b4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_clock.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_clock.c
index 4a787dea75a4,464ddd10ebbc..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_clock.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_clock.c
@@@ -208,18 -249,6 +235,21 @@@ static int mlx5e_ptp_adjfreq(struct ptp
  	int neg_adj = 0;
  	struct mlx5e_tstamp *tstamp = container_of(ptp, struct mlx5e_tstamp,
  						  ptp_info);
++<<<<<<< HEAD
 +	struct mlx5e_priv *priv =
 +		container_of(tstamp, struct mlx5e_priv, tstamp);
 +
 +	if (MLX5_CAP_GEN(priv->mdev, pps_modify)) {
 +		u32 in[MLX5_ST_SZ_DW(mtpps_reg)] = {0};
 +
 +		/* For future use need to add a loop for finding all 1PPS out pins */
 +		MLX5_SET(mtpps_reg, in, pin_mode, MLX5E_PIN_MODE_OUT);
 +		MLX5_SET(mtpps_reg, in, out_periodic_adjustment, delta & 0xFFFF);
 +
 +		mlx5_set_mtpps(priv->mdev, in, sizeof(in));
 +	}
++=======
++>>>>>>> 4272f9b88db9 (net/mlx5e: Change 1PPS out scheme)
  
  	if (delta < 0) {
  		neg_adj = 1;
@@@ -294,10 -330,14 +324,11 @@@ static int mlx5e_perout_configure(struc
  	u64 cycles_now, cycles_delta;
  	struct timespec64 ts;
  	unsigned long flags;
 -	u32 field_select = 0;
 -	u8 pin_mode = 0;
 -	u8 pattern = 0;
  	int pin = -1;
+ 	int err = 0;
  	s64 ns;
  
 -	if (!MLX5_PPS_CAP(priv->mdev))
 +	if (!MLX5_CAP_GEN(priv->mdev, pps_modify))
  		return -EOPNOTSUPP;
  
  	if (rq->perout.index >= tstamp->ptp_info.n_pins)
@@@ -308,32 -348,49 +339,37 @@@
  				   rq->perout.index);
  		if (pin < 0)
  			return -EBUSY;
 +	}
  
 -		pin_mode = MLX5E_PIN_MODE_OUT;
 -		pattern = MLX5E_OUT_PATTERN_PERIODIC;
 -		ts.tv_sec = rq->perout.period.sec;
 -		ts.tv_nsec = rq->perout.period.nsec;
 -		ns = timespec64_to_ns(&ts);
 -
 +	ts.tv_sec = rq->perout.period.sec;
 +	ts.tv_nsec = rq->perout.period.nsec;
 +	ns = timespec64_to_ns(&ts);
 +	if (on)
  		if ((ns >> 1) != 500000000LL)
  			return -EINVAL;
 -
 -		ts.tv_sec = rq->perout.start.sec;
 -		ts.tv_nsec = rq->perout.start.nsec;
 -		ns = timespec64_to_ns(&ts);
 -		cycles_now = mlx5_read_internal_timer(tstamp->mdev);
 -		write_lock_irqsave(&tstamp->lock, flags);
 -		nsec_now = timecounter_cyc2time(&tstamp->clock, cycles_now);
 -		nsec_delta = ns - nsec_now;
 -		cycles_delta = div64_u64(nsec_delta << tstamp->cycles.shift,
 -					 tstamp->cycles.mult);
 -		write_unlock_irqrestore(&tstamp->lock, flags);
 -		time_stamp = cycles_now + cycles_delta;
 -		field_select = MLX5E_MTPPS_FS_PIN_MODE |
 -			       MLX5E_MTPPS_FS_PATTERN |
 -			       MLX5E_MTPPS_FS_ENABLE |
 -			       MLX5E_MTPPS_FS_TIME_STAMP;
 -	} else {
 -		pin = rq->perout.index;
 -		field_select = MLX5E_MTPPS_FS_ENABLE;
 -	}
 -
 +	ts.tv_sec = rq->perout.start.sec;
 +	ts.tv_nsec = rq->perout.start.nsec;
 +	ns = timespec64_to_ns(&ts);
 +	cycles_now = mlx5_read_internal_timer(tstamp->mdev);
 +	write_lock_irqsave(&tstamp->lock, flags);
 +	nsec_now = timecounter_cyc2time(&tstamp->clock, cycles_now);
 +	nsec_delta = ns - nsec_now;
 +	cycles_delta = div64_u64(nsec_delta << tstamp->cycles.shift,
 +				 tstamp->cycles.mult);
 +	write_unlock_irqrestore(&tstamp->lock, flags);
 +	time_stamp = cycles_now + cycles_delta;
  	MLX5_SET(mtpps_reg, in, pin, pin);
 -	MLX5_SET(mtpps_reg, in, pin_mode, pin_mode);
 -	MLX5_SET(mtpps_reg, in, pattern, pattern);
 +	MLX5_SET(mtpps_reg, in, pin_mode, MLX5E_PIN_MODE_OUT);
 +	MLX5_SET(mtpps_reg, in, pattern, MLX5E_OUT_PATTERN_PERIODIC);
  	MLX5_SET(mtpps_reg, in, enable, on);
  	MLX5_SET64(mtpps_reg, in, time_stamp, time_stamp);
 -	MLX5_SET(mtpps_reg, in, field_select, field_select);
  
- 	return mlx5_set_mtpps(priv->mdev, in, sizeof(in));
+ 	err = mlx5_set_mtpps(priv->mdev, in, sizeof(in));
+ 	if (err)
+ 		return err;
+ 
+ 	return mlx5_set_mtppse(priv->mdev, pin, 0,
+ 			       MLX5E_EVENT_MODE_REPETETIVE & on);
  }
  
  static int mlx5e_ptp_enable(struct ptp_clock_info *ptp,
@@@ -479,16 -565,10 +544,23 @@@ void mlx5e_timestamp_init(struct mlx5e_
  	snprintf(tstamp->ptp_info.name, 16, "mlx5 ptp");
  
  	/* Initialize 1PPS data structures */
++<<<<<<< HEAD
 +#define MAX_PIN_NUM	8
 +	tstamp->pps_pin_caps = kzalloc(sizeof(u8) * MAX_PIN_NUM, GFP_KERNEL);
 +	if (tstamp->pps_pin_caps) {
 +		if (MLX5_CAP_GEN(priv->mdev, pps))
 +			mlx5e_get_pps_caps(priv, tstamp);
 +		if (tstamp->ptp_info.n_pins)
 +			mlx5e_init_pin_config(tstamp);
 +	} else {
 +		mlx5_core_warn(priv->mdev, "1PPS initialization failed\n");
 +	}
++=======
+ 	if (MLX5_PPS_CAP(priv->mdev))
+ 		mlx5e_get_pps_caps(priv, tstamp);
+ 	if (tstamp->ptp_info.n_pins)
+ 		mlx5e_init_pin_config(tstamp);
++>>>>>>> 4272f9b88db9 (net/mlx5e: Change 1PPS out scheme)
  
  	tstamp->ptp = ptp_clock_register(&tstamp->ptp_info,
  					 &priv->mdev->pdev->dev);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en.h b/drivers/net/ethernet/mellanox/mlx5/core/en.h
index 08e121a5e7e2..904d7f657fbb 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@ -253,6 +253,13 @@ struct mlx5e_dcbx {
 };
 #endif
 
+#define MAX_PIN_NUM	8
+struct mlx5e_pps {
+	u8                         pin_caps[MAX_PIN_NUM];
+	struct work_struct         out_work;
+	u64                        start[MAX_PIN_NUM];
+};
+
 struct mlx5e_tstamp {
 	rwlock_t                   lock;
 	struct cyclecounter        cycles;
@@ -264,7 +271,7 @@ struct mlx5e_tstamp {
 	struct mlx5_core_dev      *mdev;
 	struct ptp_clock          *ptp;
 	struct ptp_clock_info      ptp_info;
-	u8                        *pps_pin_caps;
+	struct mlx5e_pps           pps_info;
 };
 
 enum {
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_clock.c
