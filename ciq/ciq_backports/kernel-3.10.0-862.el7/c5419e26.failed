scsi: qla2xxx: Combine Active command arrays.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Combine Active command arrays (Himanshu Madhani) [1460030]
Rebuild_FUZZ: 91.57%
commit-author Quinn Tran <quinn.tran@cavium.com>
commit c5419e2618b951a73d590e0752810686d52c45cf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c5419e26.failed

Merge active/outstanding cmd arrays from target side and initiator side
together in prepration for Target Multi Queue support.

	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit c5419e2618b951a73d590e0752810686d52c45cf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_gbl.h
#	drivers/scsi/qla2xxx/qla_isr.c
#	drivers/scsi/qla2xxx/qla_os.c
#	drivers/scsi/qla2xxx/qla_target.c
#	drivers/scsi/qla2xxx/qla_target.h
diff --cc drivers/scsi/qla2xxx/qla_def.h
index 3f28536dc812,1b5049b1ef4a..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -382,11 -430,28 +382,22 @@@ struct srb_iocb 
  #define SRB_FXIOCB_DCMD	10
  #define SRB_FXIOCB_BCMD	11
  #define SRB_ABT_CMD	12
 -#define SRB_ELS_DCMD	13
 -#define SRB_MB_IOCB	14
 -#define SRB_CT_PTHRU_CMD 15
 -#define SRB_NACK_PLOGI	16
 -#define SRB_NACK_PRLI	17
 -#define SRB_NACK_LOGO	18
 +
  
+ enum {
+ 	TYPE_SRB,
+ 	TYPE_TGT_CMD,
+ };
+ 
  typedef struct srb {
+ 	/*
+ 	 * Do not move cmd_type field, it needs to
+ 	 * line up with qla_tgt_cmd->cmd_type
+ 	 */
+ 	uint8_t cmd_type;
+ 	uint8_t pad[3];
  	atomic_t ref_count;
  	struct fc_port *fcport;
 -	struct scsi_qla_host *vha;
  	uint32_t handle;
  	uint16_t flags;
  	uint16_t type;
@@@ -2950,15 -3297,8 +2961,18 @@@ struct qlt_hw_data 
  	uint32_t __iomem *atio_q_in;
  	uint32_t __iomem *atio_q_out;
  
 +	void *target_lport_ptr;
  	struct qla_tgt_func_tmpl *tgt_ops;
++<<<<<<< HEAD
 +	struct qla_tgt *qla_tgt;
 +	struct qla_tgt_cmd *cmds[DEFAULT_OUTSTANDING_COMMANDS];
 +	uint16_t current_handle;
 +
++=======
++>>>>>>> c5419e2618b9 (scsi: qla2xxx: Combine Active command arrays.)
  	struct qla_tgt_vp_map *tgt_vp_map;
 +	struct mutex tgt_mutex;
 +	struct mutex tgt_host_action_mutex;
  
  	int saved_set;
  	uint16_t saved_exchange_count;
diff --cc drivers/scsi/qla2xxx/qla_gbl.h
index c4f068539cd6,63355f40ff2f..000000000000
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@@ -781,5 -834,26 +781,29 @@@ extern irqreturn_t qla8044_intr_handler
  extern void qla82xx_mbx_completion(scsi_qla_host_t *, uint16_t);
  extern int qla8044_abort_isp(scsi_qla_host_t *);
  extern int qla8044_check_fw_alive(struct scsi_qla_host *);
++<<<<<<< HEAD
++=======
+ extern int qla_get_exlogin_status(scsi_qla_host_t *, uint16_t *,
+ 	uint16_t *);
+ extern int qla_set_exlogin_mem_cfg(scsi_qla_host_t *vha, dma_addr_t phys_addr);
+ extern int qla_get_exchoffld_status(scsi_qla_host_t *, uint16_t *, uint16_t *);
+ extern int qla_set_exchoffld_mem_cfg(scsi_qla_host_t *);
+ extern void qlt_handle_abts_recv(struct scsi_qla_host *, response_t *);
+ 
+ int qla24xx_async_notify_ack(scsi_qla_host_t *, fc_port_t *,
+ 	struct imm_ntfy_from_isp *, int);
+ void qla24xx_do_nack_work(struct scsi_qla_host *, struct qla_work_evt *);
+ void qlt_plogi_ack_link(struct scsi_qla_host *, struct qlt_plogi_ack_t *,
+ 	struct fc_port *, enum qlt_plogi_link_t);
+ void qlt_plogi_ack_unref(struct scsi_qla_host *, struct qlt_plogi_ack_t *);
+ extern void qlt_schedule_sess_for_deletion(struct fc_port *, bool);
+ extern void qlt_schedule_sess_for_deletion_lock(struct fc_port *);
+ extern struct fc_port *qlt_find_sess_invalidate_other(scsi_qla_host_t *,
+ 	uint64_t wwn, port_id_t port_id, uint16_t loop_id, struct fc_port **);
+ void qla24xx_delete_sess_fn(struct work_struct *);
+ void qlt_unknown_atio_work_fn(struct work_struct *);
+ void qlt_update_host_map(struct scsi_qla_host *, port_id_t);
+ void qlt_remove_target_resources(struct qla_hw_data *);
++>>>>>>> c5419e2618b9 (scsi: qla2xxx: Combine Active command arrays.)
  
  #endif /* _QLA_GBL_H */
diff --cc drivers/scsi/qla2xxx/qla_isr.c
index d71223f09c1c,8aaddb75f964..000000000000
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@@ -16,12 -17,8 +16,12 @@@
  static void qla2x00_mbx_completion(scsi_qla_host_t *, uint16_t);
  static void qla2x00_status_entry(scsi_qla_host_t *, struct rsp_que *, void *);
  static void qla2x00_status_cont_entry(struct rsp_que *, sts_cont_entry_t *);
- static void qla2x00_error_entry(scsi_qla_host_t *, struct rsp_que *,
+ static int qla2x00_error_entry(scsi_qla_host_t *, struct rsp_que *,
  	sts_entry_t *);
 +static void qla_irq_affinity_notify(struct irq_affinity_notify *,
 +    const cpumask_t *);
 +static void qla_irq_affinity_release(struct kref *);
 +
  
  /**
   * qla2100_intr_handler() - Process interrupts for the ISP2100 and ISP2200.
@@@ -2485,10 -2663,30 +2494,37 @@@ qla2x00_error_entry(scsi_qla_host_t *vh
  	if (pkt->entry_status & RF_BUSY)
  		res = DID_BUS_BUSY << 16;
  
++<<<<<<< HEAD
 +	sp = qla2x00_get_sp_from_handle(vha, func, req, pkt);
 +	if (sp) {
 +		sp->done(vha, sp, res);
 +		return;
++=======
+ 	if ((pkt->handle & ~QLA_TGT_HANDLE_MASK) == QLA_TGT_SKIP_HANDLE)
+ 		return 0;
+ 
+ 	switch (pkt->entry_type) {
+ 	case NOTIFY_ACK_TYPE:
+ 	case STATUS_TYPE:
+ 	case STATUS_CONT_TYPE:
+ 	case LOGINOUT_PORT_IOCB_TYPE:
+ 	case CT_IOCB_TYPE:
+ 	case ELS_IOCB_TYPE:
+ 	case ABORT_IOCB_TYPE:
+ 	case MBX_IOCB_TYPE:
+ 		sp = qla2x00_get_sp_from_handle(vha, func, req, pkt);
+ 		if (sp) {
+ 			sp->done(sp, res);
+ 			return 0;
+ 		}
+ 		break;
+ 
+ 	case ABTS_RESP_24XX:
+ 	case CTIO_TYPE7:
+ 	case CTIO_CRC2:
+ 	default:
+ 		return 1;
++>>>>>>> c5419e2618b9 (scsi: qla2xxx: Combine Active command arrays.)
  	}
  fatal:
  	ql_log(ql_log_warn, vha, 0x5030,
@@@ -2581,9 -2772,8 +2618,14 @@@ void qla24xx_process_response_queue(str
  		}
  
  		if (pkt->entry_status != 0) {
++<<<<<<< HEAD
 +			qla2x00_error_entry(vha, rsp, (sts_entry_t *) pkt);
 +
 +			(void)qlt_24xx_process_response_error(vha, pkt);
++=======
+ 			if (qla2x00_error_entry(vha, rsp, (sts_entry_t *) pkt))
+ 				goto process_err;
++>>>>>>> c5419e2618b9 (scsi: qla2xxx: Combine Active command arrays.)
  
  			((response_t *)pkt)->signature = RESPONSE_PROCESSED;
  			wmb();
diff --cc drivers/scsi/qla2xxx/qla_os.c
index 4e0d0a2f9461,d92e65b40c44..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -1579,6 -1649,9 +1579,12 @@@ qla2x00_abort_all_cmds(scsi_qla_host_t 
  	srb_t *sp;
  	struct qla_hw_data *ha = vha->hw;
  	struct req_que *req;
++<<<<<<< HEAD
++=======
+ 	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
+ 	struct qla_tgt_cmd *cmd;
+ 	uint8_t trace = 0;
++>>>>>>> c5419e2618b9 (scsi: qla2xxx: Combine Active command arrays.)
  
  	spin_lock_irqsave(&ha->hardware_lock, flags);
  	for (que = 0; que < ha->max_req_queues; que++) {
@@@ -1590,27 -1663,57 +1596,61 @@@
  		for (cnt = 1; cnt < req->num_outstanding_cmds; cnt++) {
  			sp = req->outstanding_cmds[cnt];
  			if (sp) {
- 				/* Don't abort commands in adapter during EEH
- 				 * recovery as it's not accessible/responding.
- 				 */
- 				if (GET_CMD_SP(sp) && !ha->flags.eeh_busy &&
- 				    (sp->type == SRB_SCSI_CMD)) {
- 					/* Get a reference to the sp and drop the lock.
- 					 * The reference ensures this sp->done() call
- 					 * - and not the call in qla2xxx_eh_abort() -
- 					 * ends the SCSI command (with result 'res').
- 					 */
- 					sp_get(sp);
- 					spin_unlock_irqrestore(&ha->hardware_lock, flags);
- 					status = qla2xxx_eh_abort(GET_CMD_SP(sp));
- 					spin_lock_irqsave(&ha->hardware_lock, flags);
- 					/* Get rid of extra reference if immediate exit
- 					 * from ql2xxx_eh_abort */
- 					if (status == FAILED && (qla2x00_isp_reg_stat(ha)))
- 						atomic_dec(&sp->ref_count);
- 				}
  				req->outstanding_cmds[cnt] = NULL;
++<<<<<<< HEAD
 +				sp->done(vha, sp, res);
++=======
+ 				if (sp->cmd_type == TYPE_SRB) {
+ 					/*
+ 					 * Don't abort commands in adapter
+ 					 * during EEH recovery as it's not
+ 					 * accessible/responding.
+ 					 */
+ 					if (GET_CMD_SP(sp) &&
+ 					    !ha->flags.eeh_busy &&
+ 					    (sp->type == SRB_SCSI_CMD)) {
+ 						/*
+ 						 * Get a reference to the sp
+ 						 * and drop the lock. The
+ 						 * reference ensures this
+ 						 * sp->done() call and not the
+ 						 * call in qla2xxx_eh_abort()
+ 						 * ends the SCSI command (with
+ 						 * result 'res').
+ 						 */
+ 						sp_get(sp);
+ 						spin_unlock_irqrestore(
+ 						    &ha->hardware_lock, flags);
+ 						status = qla2xxx_eh_abort(
+ 						    GET_CMD_SP(sp));
+ 						spin_lock_irqsave(
+ 						    &ha->hardware_lock, flags);
+ 						/*
+ 						 * Get rid of extra reference
+ 						 * if immediate exit from
+ 						 * ql2xxx_eh_abort
+ 						 */
+ 						if (status == FAILED &&
+ 						    (qla2x00_isp_reg_stat(ha)))
+ 							atomic_dec(
+ 							    &sp->ref_count);
+ 					}
+ 					sp->done(sp, res);
+ 				} else {
+ 					if (!vha->hw->tgt.tgt_ops || !tgt ||
+ 					    qla_ini_mode_enabled(vha)) {
+ 						if (!trace)
+ 							ql_dbg(ql_dbg_tgt_mgt,
+ 							    vha, 0xf003,
+ 							    "HOST-ABORT-HNDLR: dpc_flags=%lx. Target mode disabled\n",
+ 							    vha->dpc_flags);
+ 						continue;
+ 					}
+ 					cmd = (struct qla_tgt_cmd *)sp;
+ 					qlt_abort_cmd_on_host_reset(cmd->vha,
+ 					    cmd);
+ 				}
++>>>>>>> c5419e2618b9 (scsi: qla2xxx: Combine Active command arrays.)
  			}
  		}
  	}
diff --cc drivers/scsi/qla2xxx/qla_target.c
index 7a27b61e2d53,a18f81046959..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -93,14 -109,28 +93,34 @@@ enum fcp_resp_rsp_codes 
   */
  /* Predefs for callbacks handed to qla2xxx LLD */
  static void qlt_24xx_atio_pkt(struct scsi_qla_host *ha,
 -	struct atio_from_isp *pkt, uint8_t);
 +	struct atio_from_isp *pkt);
  static void qlt_response_pkt(struct scsi_qla_host *ha, response_t *pkt);
 -static int qlt_issue_task_mgmt(struct fc_port *sess, u64 lun,
 +static int qlt_issue_task_mgmt(struct qla_tgt_sess *sess, uint32_t lun,
  	int fn, void *iocb, int flags);
  static void qlt_send_term_exchange(struct scsi_qla_host *ha, struct qla_tgt_cmd
++<<<<<<< HEAD
 +	*cmd, struct atio_from_isp *atio, int ha_locked);
 +static void qlt_reject_free_srr_imm(struct scsi_qla_host *ha,
 +	struct qla_tgt_srr_imm *imm, int ha_lock);
++=======
+ 	*cmd, struct atio_from_isp *atio, int ha_locked, int ul_abort);
+ static void qlt_alloc_qfull_cmd(struct scsi_qla_host *vha,
+ 	struct atio_from_isp *atio, uint16_t status, int qfull);
+ static void qlt_disable_vha(struct scsi_qla_host *vha);
+ static void qlt_clear_tgt_db(struct qla_tgt *tgt);
+ static void qlt_send_notify_ack(struct scsi_qla_host *vha,
+ 	struct imm_ntfy_from_isp *ntfy,
+ 	uint32_t add_flags, uint16_t resp_code, int resp_code_valid,
+ 	uint16_t srr_flags, uint16_t srr_reject_code, uint8_t srr_explan);
+ static void qlt_send_term_imm_notif(struct scsi_qla_host *vha,
+ 	struct imm_ntfy_from_isp *imm, int ha_locked);
+ static struct fc_port *qlt_create_sess(struct scsi_qla_host *vha,
+ 	fc_port_t *fcport, bool local);
+ void qlt_unreg_sess(struct fc_port *sess);
+ static void qlt_24xx_handle_abts(struct scsi_qla_host *,
+ 	struct abts_recv_from_24xx *);
+ 
++>>>>>>> c5419e2618b9 (scsi: qla2xxx: Combine Active command arrays.)
  /*
   * Global Variables
   */
@@@ -1542,28 -2289,35 +1562,49 @@@ static inline void *qlt_get_req_pkt(str
  /* ha->hardware_lock supposed to be held on entry */
  static inline uint32_t qlt_make_handle(struct scsi_qla_host *vha)
  {
- 	struct qla_hw_data *ha = vha->hw;
  	uint32_t h;
+ 	int index;
+ 	uint8_t found = 0;
+ 	struct req_que *req = vha->req;
  
++<<<<<<< HEAD
 +	h = ha->tgt.current_handle;
 +	/* always increment cmd handle */
 +	do {
 +		++h;
 +		if (h > DEFAULT_OUTSTANDING_COMMANDS)
 +			h = 1; /* 0 is QLA_TGT_NULL_HANDLE */
 +		if (h == ha->tgt.current_handle) {
 +			ql_dbg(ql_dbg_tgt, vha, 0xe04e,
 +			    "qla_target(%d): Ran out of "
 +			    "empty cmd slots in ha %p\n", vha->vp_idx, ha);
 +			h = QLA_TGT_NULL_HANDLE;
++=======
+ 	h = req->current_outstanding_cmd;
+ 
+ 	for (index = 1; index < req->num_outstanding_cmds; index++) {
+ 		h++;
+ 		if (h == req->num_outstanding_cmds)
+ 			h = 1;
+ 
+ 		if (h == QLA_TGT_SKIP_HANDLE)
+ 			continue;
+ 
+ 		if (!req->outstanding_cmds[h]) {
+ 			found = 1;
++>>>>>>> c5419e2618b9 (scsi: qla2xxx: Combine Active command arrays.)
  			break;
  		}
- 	} while ((h == QLA_TGT_NULL_HANDLE) ||
- 	    (h == QLA_TGT_SKIP_HANDLE) ||
- 	    (ha->tgt.cmds[h-1] != NULL));
+ 	}
  
- 	if (h != QLA_TGT_NULL_HANDLE)
- 		ha->tgt.current_handle = h;
+ 	if (found) {
+ 		req->current_outstanding_cmd = h;
+ 	} else {
+ 		ql_dbg(ql_dbg_io, vha, 0x305b,
+ 			"qla_target(%d): Ran out of empty cmd slots\n",
+ 			vha->vp_idx);
+ 		h = QLA_TGT_NULL_HANDLE;
+ 	}
  
  	return h;
  }
@@@ -1574,8 -2328,8 +1615,7 @@@ static int qlt_24xx_build_ctio_pkt(stru
  {
  	uint32_t h;
  	struct ctio7_to_24xx *pkt;
- 	struct qla_hw_data *ha = vha->hw;
  	struct atio_from_isp *atio = &prm->cmd->atio;
 -	uint16_t temp;
  
  	pkt = (struct ctio7_to_24xx *)vha->req->ring_ptr;
  	prm->pkt = pkt;
@@@ -1593,8 -2347,9 +1633,14 @@@
  		 * the session and, so, the command.
  		 */
  		return -EAGAIN;
++<<<<<<< HEAD
 +	} else
 +		ha->tgt.cmds[h-1] = prm->cmd;
++=======
+ 	} else {
+ 		vha->req->outstanding_cmds[h] = (srb_t *)prm->cmd;
+ 	}
++>>>>>>> c5419e2618b9 (scsi: qla2xxx: Combine Active command arrays.)
  
  	pkt->handle = h | CTIO_COMPLETION_HANDLE_MARK;
  	pkt->nport_handle = prm->cmd->loop_id;
@@@ -2011,6 -2661,348 +2057,351 @@@ skip_explict_conf
  	/* Sense with len > 24, is it possible ??? */
  }
  
++<<<<<<< HEAD
++=======
+ static inline int
+ qlt_hba_err_chk_enabled(struct se_cmd *se_cmd)
+ {
+ 	switch (se_cmd->prot_op) {
+ 	case TARGET_PROT_DOUT_INSERT:
+ 	case TARGET_PROT_DIN_STRIP:
+ 		if (ql2xenablehba_err_chk >= 1)
+ 			return 1;
+ 		break;
+ 	case TARGET_PROT_DOUT_PASS:
+ 	case TARGET_PROT_DIN_PASS:
+ 		if (ql2xenablehba_err_chk >= 2)
+ 			return 1;
+ 		break;
+ 	case TARGET_PROT_DIN_INSERT:
+ 	case TARGET_PROT_DOUT_STRIP:
+ 		return 1;
+ 	default:
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ static inline int
+ qla_tgt_ref_mask_check(struct se_cmd *se_cmd)
+ {
+ 	switch (se_cmd->prot_op) {
+ 	case TARGET_PROT_DIN_INSERT:
+ 	case TARGET_PROT_DOUT_INSERT:
+ 	case TARGET_PROT_DIN_STRIP:
+ 	case TARGET_PROT_DOUT_STRIP:
+ 	case TARGET_PROT_DIN_PASS:
+ 	case TARGET_PROT_DOUT_PASS:
+ 	    return 1;
+ 	default:
+ 	    return 0;
+ 	}
+ 	return 0;
+ }
+ 
+ /*
+  * qla_tgt_set_dif_tags - Extract Ref and App tags from SCSI command
+  */
+ static void
+ qla_tgt_set_dif_tags(struct qla_tgt_cmd *cmd, struct crc_context *ctx,
+     uint16_t *pfw_prot_opts)
+ {
+ 	struct se_cmd *se_cmd = &cmd->se_cmd;
+ 	uint32_t lba = 0xffffffff & se_cmd->t_task_lba;
+ 	scsi_qla_host_t *vha = cmd->tgt->vha;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	uint32_t t32 = 0;
+ 
+ 	/*
+ 	 * wait till Mode Sense/Select cmd, modepage Ah, subpage 2
+ 	 * have been immplemented by TCM, before AppTag is avail.
+ 	 * Look for modesense_handlers[]
+ 	 */
+ 	ctx->app_tag = 0;
+ 	ctx->app_tag_mask[0] = 0x0;
+ 	ctx->app_tag_mask[1] = 0x0;
+ 
+ 	if (IS_PI_UNINIT_CAPABLE(ha)) {
+ 		if ((se_cmd->prot_type == TARGET_DIF_TYPE1_PROT) ||
+ 		    (se_cmd->prot_type == TARGET_DIF_TYPE2_PROT))
+ 			*pfw_prot_opts |= PO_DIS_VALD_APP_ESC;
+ 		else if (se_cmd->prot_type == TARGET_DIF_TYPE3_PROT)
+ 			*pfw_prot_opts |= PO_DIS_VALD_APP_REF_ESC;
+ 	}
+ 
+ 	t32 = ha->tgt.tgt_ops->get_dif_tags(cmd, pfw_prot_opts);
+ 
+ 	switch (se_cmd->prot_type) {
+ 	case TARGET_DIF_TYPE0_PROT:
+ 		/*
+ 		 * No check for ql2xenablehba_err_chk, as it
+ 		 * would be an I/O error if hba tag generation
+ 		 * is not done.
+ 		 */
+ 		ctx->ref_tag = cpu_to_le32(lba);
+ 		/* enable ALL bytes of the ref tag */
+ 		ctx->ref_tag_mask[0] = 0xff;
+ 		ctx->ref_tag_mask[1] = 0xff;
+ 		ctx->ref_tag_mask[2] = 0xff;
+ 		ctx->ref_tag_mask[3] = 0xff;
+ 		break;
+ 	case TARGET_DIF_TYPE1_PROT:
+ 	    /*
+ 	     * For TYPE 1 protection: 16 bit GUARD tag, 32 bit
+ 	     * REF tag, and 16 bit app tag.
+ 	     */
+ 	    ctx->ref_tag = cpu_to_le32(lba);
+ 	    if (!qla_tgt_ref_mask_check(se_cmd) ||
+ 		!(ha->tgt.tgt_ops->chk_dif_tags(t32))) {
+ 		    *pfw_prot_opts |= PO_DIS_REF_TAG_VALD;
+ 		    break;
+ 	    }
+ 	    /* enable ALL bytes of the ref tag */
+ 	    ctx->ref_tag_mask[0] = 0xff;
+ 	    ctx->ref_tag_mask[1] = 0xff;
+ 	    ctx->ref_tag_mask[2] = 0xff;
+ 	    ctx->ref_tag_mask[3] = 0xff;
+ 	    break;
+ 	case TARGET_DIF_TYPE2_PROT:
+ 	    /*
+ 	     * For TYPE 2 protection: 16 bit GUARD + 32 bit REF
+ 	     * tag has to match LBA in CDB + N
+ 	     */
+ 	    ctx->ref_tag = cpu_to_le32(lba);
+ 	    if (!qla_tgt_ref_mask_check(se_cmd) ||
+ 		!(ha->tgt.tgt_ops->chk_dif_tags(t32))) {
+ 		    *pfw_prot_opts |= PO_DIS_REF_TAG_VALD;
+ 		    break;
+ 	    }
+ 	    /* enable ALL bytes of the ref tag */
+ 	    ctx->ref_tag_mask[0] = 0xff;
+ 	    ctx->ref_tag_mask[1] = 0xff;
+ 	    ctx->ref_tag_mask[2] = 0xff;
+ 	    ctx->ref_tag_mask[3] = 0xff;
+ 	    break;
+ 	case TARGET_DIF_TYPE3_PROT:
+ 	    /* For TYPE 3 protection: 16 bit GUARD only */
+ 	    *pfw_prot_opts |= PO_DIS_REF_TAG_VALD;
+ 	    ctx->ref_tag_mask[0] = ctx->ref_tag_mask[1] =
+ 		ctx->ref_tag_mask[2] = ctx->ref_tag_mask[3] = 0x00;
+ 	    break;
+ 	}
+ }
+ 
+ static inline int
+ qlt_build_ctio_crc2_pkt(struct qla_tgt_prm *prm, scsi_qla_host_t *vha)
+ {
+ 	uint32_t		*cur_dsd;
+ 	uint32_t		transfer_length = 0;
+ 	uint32_t		data_bytes;
+ 	uint32_t		dif_bytes;
+ 	uint8_t			bundling = 1;
+ 	uint8_t			*clr_ptr;
+ 	struct crc_context	*crc_ctx_pkt = NULL;
+ 	struct qla_hw_data	*ha;
+ 	struct ctio_crc2_to_fw	*pkt;
+ 	dma_addr_t		crc_ctx_dma;
+ 	uint16_t		fw_prot_opts = 0;
+ 	struct qla_tgt_cmd	*cmd = prm->cmd;
+ 	struct se_cmd		*se_cmd = &cmd->se_cmd;
+ 	uint32_t h;
+ 	struct atio_from_isp *atio = &prm->cmd->atio;
+ 	struct qla_tc_param	tc;
+ 	uint16_t t16;
+ 
+ 	ha = vha->hw;
+ 
+ 	pkt = (struct ctio_crc2_to_fw *)vha->req->ring_ptr;
+ 	prm->pkt = pkt;
+ 	memset(pkt, 0, sizeof(*pkt));
+ 
+ 	ql_dbg(ql_dbg_tgt, vha, 0xe071,
+ 		"qla_target(%d):%s: se_cmd[%p] CRC2 prot_op[0x%x] cmd prot sg:cnt[%p:%x] lba[%llu]\n",
+ 		vha->vp_idx, __func__, se_cmd, se_cmd->prot_op,
+ 		prm->prot_sg, prm->prot_seg_cnt, se_cmd->t_task_lba);
+ 
+ 	if ((se_cmd->prot_op == TARGET_PROT_DIN_INSERT) ||
+ 	    (se_cmd->prot_op == TARGET_PROT_DOUT_STRIP))
+ 		bundling = 0;
+ 
+ 	/* Compute dif len and adjust data len to incude protection */
+ 	data_bytes = cmd->bufflen;
+ 	dif_bytes  = (data_bytes / cmd->blk_sz) * 8;
+ 
+ 	switch (se_cmd->prot_op) {
+ 	case TARGET_PROT_DIN_INSERT:
+ 	case TARGET_PROT_DOUT_STRIP:
+ 		transfer_length = data_bytes;
+ 		if (cmd->prot_sg_cnt)
+ 			data_bytes += dif_bytes;
+ 		break;
+ 	case TARGET_PROT_DIN_STRIP:
+ 	case TARGET_PROT_DOUT_INSERT:
+ 	case TARGET_PROT_DIN_PASS:
+ 	case TARGET_PROT_DOUT_PASS:
+ 		transfer_length = data_bytes + dif_bytes;
+ 		break;
+ 	default:
+ 		BUG();
+ 		break;
+ 	}
+ 
+ 	if (!qlt_hba_err_chk_enabled(se_cmd))
+ 		fw_prot_opts |= 0x10; /* Disable Guard tag checking */
+ 	/* HBA error checking enabled */
+ 	else if (IS_PI_UNINIT_CAPABLE(ha)) {
+ 		if ((se_cmd->prot_type == TARGET_DIF_TYPE1_PROT) ||
+ 		    (se_cmd->prot_type == TARGET_DIF_TYPE2_PROT))
+ 			fw_prot_opts |= PO_DIS_VALD_APP_ESC;
+ 		else if (se_cmd->prot_type == TARGET_DIF_TYPE3_PROT)
+ 			fw_prot_opts |= PO_DIS_VALD_APP_REF_ESC;
+ 	}
+ 
+ 	switch (se_cmd->prot_op) {
+ 	case TARGET_PROT_DIN_INSERT:
+ 	case TARGET_PROT_DOUT_INSERT:
+ 		fw_prot_opts |= PO_MODE_DIF_INSERT;
+ 		break;
+ 	case TARGET_PROT_DIN_STRIP:
+ 	case TARGET_PROT_DOUT_STRIP:
+ 		fw_prot_opts |= PO_MODE_DIF_REMOVE;
+ 		break;
+ 	case TARGET_PROT_DIN_PASS:
+ 	case TARGET_PROT_DOUT_PASS:
+ 		fw_prot_opts |= PO_MODE_DIF_PASS;
+ 		/* FUTURE: does tcm require T10CRC<->IPCKSUM conversion? */
+ 		break;
+ 	default:/* Normal Request */
+ 		fw_prot_opts |= PO_MODE_DIF_PASS;
+ 		break;
+ 	}
+ 
+ 	/* ---- PKT ---- */
+ 	/* Update entry type to indicate Command Type CRC_2 IOCB */
+ 	pkt->entry_type  = CTIO_CRC2;
+ 	pkt->entry_count = 1;
+ 	pkt->vp_index = vha->vp_idx;
+ 
+ 	h = qlt_make_handle(vha);
+ 	if (unlikely(h == QLA_TGT_NULL_HANDLE)) {
+ 		/*
+ 		 * CTIO type 7 from the firmware doesn't provide a way to
+ 		 * know the initiator's LOOP ID, hence we can't find
+ 		 * the session and, so, the command.
+ 		 */
+ 		return -EAGAIN;
+ 	} else
+ 		vha->req->outstanding_cmds[h] = (srb_t *)prm->cmd;
+ 
+ 	pkt->handle  = h | CTIO_COMPLETION_HANDLE_MARK;
+ 	pkt->nport_handle = cpu_to_le16(prm->cmd->loop_id);
+ 	pkt->timeout = cpu_to_le16(QLA_TGT_TIMEOUT);
+ 	pkt->initiator_id[0] = atio->u.isp24.fcp_hdr.s_id[2];
+ 	pkt->initiator_id[1] = atio->u.isp24.fcp_hdr.s_id[1];
+ 	pkt->initiator_id[2] = atio->u.isp24.fcp_hdr.s_id[0];
+ 	pkt->exchange_addr   = atio->u.isp24.exchange_addr;
+ 
+ 	/* silence compile warning */
+ 	t16 = be16_to_cpu(atio->u.isp24.fcp_hdr.ox_id);
+ 	pkt->ox_id  = cpu_to_le16(t16);
+ 
+ 	t16 = (atio->u.isp24.attr << 9);
+ 	pkt->flags |= cpu_to_le16(t16);
+ 	pkt->relative_offset = cpu_to_le32(prm->cmd->offset);
+ 
+ 	/* Set transfer direction */
+ 	if (cmd->dma_data_direction == DMA_TO_DEVICE)
+ 		pkt->flags = cpu_to_le16(CTIO7_FLAGS_DATA_IN);
+ 	else if (cmd->dma_data_direction == DMA_FROM_DEVICE)
+ 		pkt->flags = cpu_to_le16(CTIO7_FLAGS_DATA_OUT);
+ 
+ 	pkt->dseg_count = prm->tot_dsds;
+ 	/* Fibre channel byte count */
+ 	pkt->transfer_length = cpu_to_le32(transfer_length);
+ 
+ 	/* ----- CRC context -------- */
+ 
+ 	/* Allocate CRC context from global pool */
+ 	crc_ctx_pkt = cmd->ctx =
+ 	    dma_pool_alloc(ha->dl_dma_pool, GFP_ATOMIC, &crc_ctx_dma);
+ 
+ 	if (!crc_ctx_pkt)
+ 		goto crc_queuing_error;
+ 
+ 	/* Zero out CTX area. */
+ 	clr_ptr = (uint8_t *)crc_ctx_pkt;
+ 	memset(clr_ptr, 0, sizeof(*crc_ctx_pkt));
+ 
+ 	crc_ctx_pkt->crc_ctx_dma = crc_ctx_dma;
+ 	INIT_LIST_HEAD(&crc_ctx_pkt->dsd_list);
+ 
+ 	/* Set handle */
+ 	crc_ctx_pkt->handle = pkt->handle;
+ 
+ 	qla_tgt_set_dif_tags(cmd, crc_ctx_pkt, &fw_prot_opts);
+ 
+ 	pkt->crc_context_address[0] = cpu_to_le32(LSD(crc_ctx_dma));
+ 	pkt->crc_context_address[1] = cpu_to_le32(MSD(crc_ctx_dma));
+ 	pkt->crc_context_len = CRC_CONTEXT_LEN_FW;
+ 
+ 	if (!bundling) {
+ 		cur_dsd = (uint32_t *) &crc_ctx_pkt->u.nobundling.data_address;
+ 	} else {
+ 		/*
+ 		 * Configure Bundling if we need to fetch interlaving
+ 		 * protection PCI accesses
+ 		 */
+ 		fw_prot_opts |= PO_ENABLE_DIF_BUNDLING;
+ 		crc_ctx_pkt->u.bundling.dif_byte_count = cpu_to_le32(dif_bytes);
+ 		crc_ctx_pkt->u.bundling.dseg_count =
+ 			cpu_to_le16(prm->tot_dsds - prm->prot_seg_cnt);
+ 		cur_dsd = (uint32_t *) &crc_ctx_pkt->u.bundling.data_address;
+ 	}
+ 
+ 	/* Finish the common fields of CRC pkt */
+ 	crc_ctx_pkt->blk_size   = cpu_to_le16(cmd->blk_sz);
+ 	crc_ctx_pkt->prot_opts  = cpu_to_le16(fw_prot_opts);
+ 	crc_ctx_pkt->byte_count = cpu_to_le32(data_bytes);
+ 	crc_ctx_pkt->guard_seed = cpu_to_le16(0);
+ 
+ 	memset((uint8_t *)&tc, 0 , sizeof(tc));
+ 	tc.vha = vha;
+ 	tc.blk_sz = cmd->blk_sz;
+ 	tc.bufflen = cmd->bufflen;
+ 	tc.sg = cmd->sg;
+ 	tc.prot_sg = cmd->prot_sg;
+ 	tc.ctx = crc_ctx_pkt;
+ 	tc.ctx_dsd_alloced = &cmd->ctx_dsd_alloced;
+ 
+ 	/* Walks data segments */
+ 	pkt->flags |= cpu_to_le16(CTIO7_FLAGS_DSD_PTR);
+ 
+ 	if (!bundling && prm->prot_seg_cnt) {
+ 		if (qla24xx_walk_and_build_sglist_no_difb(ha, NULL, cur_dsd,
+ 			prm->tot_dsds, &tc))
+ 			goto crc_queuing_error;
+ 	} else if (qla24xx_walk_and_build_sglist(ha, NULL, cur_dsd,
+ 		(prm->tot_dsds - prm->prot_seg_cnt), &tc))
+ 		goto crc_queuing_error;
+ 
+ 	if (bundling && prm->prot_seg_cnt) {
+ 		/* Walks dif segments */
+ 		pkt->add_flags |= CTIO_CRC2_AF_DIF_DSD_ENA;
+ 
+ 		cur_dsd = (uint32_t *) &crc_ctx_pkt->u.bundling.dif_address;
+ 		if (qla24xx_walk_and_build_prot_sglist(ha, NULL, cur_dsd,
+ 			prm->prot_seg_cnt, &tc))
+ 			goto crc_queuing_error;
+ 	}
+ 	return QLA_SUCCESS;
+ 
+ crc_queuing_error:
+ 	/* Cleanup will be performed by the caller */
+ 	vha->req->outstanding_cmds[h] = NULL;
+ 
+ 	return QLA_FUNCTION_FAILED;
+ }
++>>>>>>> c5419e2618b9 (scsi: qla2xxx: Combine Active command arrays.)
  
  /*
   * Callback to setup response of xmit_type of QLA_TGT_XMIT_DATA and *
@@@ -2427,19 -3687,18 +2804,26 @@@ static struct qla_tgt_cmd *qlt_ctio_to_
  	uint32_t handle, void *ctio)
  {
  	struct qla_tgt_cmd *cmd = NULL;
+ 	struct req_que *req = vha->req;
  
  	/* Clear out internal marks */
- 	handle &= ~(CTIO_COMPLETION_HANDLE_MARK |
- 	    CTIO_INTERMEDIATE_HANDLE_MARK);
+ 	handle &= ~QLA_TGT_HANDLE_MASK;
  
  	if (handle != QLA_TGT_NULL_HANDLE) {
 -		if (unlikely(handle == QLA_TGT_SKIP_HANDLE))
 +		if (unlikely(handle == QLA_TGT_SKIP_HANDLE)) {
 +			ql_dbg(ql_dbg_tgt, vha, 0xe01d, "%s",
 +			    "SKIP_HANDLE CTIO\n");
  			return NULL;
++<<<<<<< HEAD
 +		}
 +		/* handle-1 is actually used */
 +		if (unlikely(handle > DEFAULT_OUTSTANDING_COMMANDS)) {
++=======
+ 
+ 		handle &= QLA_CMD_HANDLE_MASK;
+ 
+ 		if (unlikely(handle > req->num_outstanding_cmds)) {
++>>>>>>> c5419e2618b9 (scsi: qla2xxx: Combine Active command arrays.)
  			ql_dbg(ql_dbg_tgt, vha, 0xe052,
  			    "qla_target(%d): Wrong handle %x received\n",
  			    vha->vp_idx, handle);
@@@ -2464,6 -3724,42 +2849,45 @@@
  	return cmd;
  }
  
++<<<<<<< HEAD
++=======
+ /* hardware_lock should be held by caller. */
+ void
+ qlt_abort_cmd_on_host_reset(struct scsi_qla_host *vha, struct qla_tgt_cmd *cmd)
+ {
+ 	struct qla_hw_data *ha = vha->hw;
+ 	uint32_t handle;
+ 
+ 	if (cmd->sg_mapped)
+ 		qlt_unmap_sg(vha, cmd);
+ 
+ 	handle = qlt_make_handle(vha);
+ 
+ 	/* TODO: fix debug message type and ids. */
+ 	if (cmd->state == QLA_TGT_STATE_PROCESSED) {
+ 		ql_dbg(ql_dbg_io, vha, 0xff00,
+ 		    "HOST-ABORT: handle=%d, state=PROCESSED.\n", handle);
+ 	} else if (cmd->state == QLA_TGT_STATE_NEED_DATA) {
+ 		cmd->write_data_transferred = 0;
+ 		cmd->state = QLA_TGT_STATE_DATA_IN;
+ 
+ 		ql_dbg(ql_dbg_io, vha, 0xff01,
+ 		    "HOST-ABORT: handle=%d, state=DATA_IN.\n", handle);
+ 
+ 		ha->tgt.tgt_ops->handle_data(cmd);
+ 		return;
+ 	} else {
+ 		ql_dbg(ql_dbg_io, vha, 0xff03,
+ 		    "HOST-ABORT: handle=%d, state=BAD(%d).\n", handle,
+ 		    cmd->state);
+ 		dump_stack();
+ 	}
+ 
+ 	cmd->trc_flags |= TRC_FLUSH;
+ 	ha->tgt.tgt_ops->free_cmd(cmd);
+ }
+ 
++>>>>>>> c5419e2618b9 (scsi: qla2xxx: Combine Active command arrays.)
  /*
   * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire
   */
@@@ -2715,12 -4001,133 +3139,117 @@@ out_term
  	 * cmd has not sent to target yet, so pass NULL as the second
  	 * argument to qlt_send_term_exchange() and free the memory here.
  	 */
 -	cmd->trc_flags |= TRC_DO_WORK_ERR;
  	spin_lock_irqsave(&ha->hardware_lock, flags);
 -	qlt_send_term_exchange(vha, NULL, &cmd->atio, 1, 0);
 -
 -	qlt_decr_num_pend_cmds(vha);
 -	percpu_ida_free(&sess->se_sess->sess_tag_pool, cmd->se_cmd.map_tag);
 +	qlt_send_term_exchange(vha, NULL, &cmd->atio, 1);
 +	kmem_cache_free(qla_tgt_cmd_cachep, cmd);
  	spin_unlock_irqrestore(&ha->hardware_lock, flags);
++<<<<<<< HEAD
 +	if (sess)
++=======
+ 
+ 	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
+ 	ha->tgt.tgt_ops->put_sess(sess);
+ 	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ }
+ 
+ static void qlt_do_work(struct work_struct *work)
+ {
+ 	struct qla_tgt_cmd *cmd = container_of(work, struct qla_tgt_cmd, work);
+ 	scsi_qla_host_t *vha = cmd->vha;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&vha->cmd_list_lock, flags);
+ 	list_del(&cmd->cmd_list);
+ 	spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
+ 
+ 	__qlt_do_work(cmd);
+ }
+ 
+ static struct qla_tgt_cmd *qlt_get_tag(scsi_qla_host_t *vha,
+ 				       struct fc_port *sess,
+ 				       struct atio_from_isp *atio)
+ {
+ 	struct se_session *se_sess = sess->se_sess;
+ 	struct qla_tgt_cmd *cmd;
+ 	int tag;
+ 
+ 	tag = percpu_ida_alloc(&se_sess->sess_tag_pool, TASK_RUNNING);
+ 	if (tag < 0)
+ 		return NULL;
+ 
+ 	cmd = &((struct qla_tgt_cmd *)se_sess->sess_cmd_map)[tag];
+ 	memset(cmd, 0, sizeof(struct qla_tgt_cmd));
+ 	cmd->cmd_type = TYPE_TGT_CMD;
+ 	memcpy(&cmd->atio, atio, sizeof(*atio));
+ 	cmd->state = QLA_TGT_STATE_NEW;
+ 	cmd->tgt = vha->vha_tgt.qla_tgt;
+ 	qlt_incr_num_pend_cmds(vha);
+ 	cmd->vha = vha;
+ 	cmd->se_cmd.map_tag = tag;
+ 	cmd->sess = sess;
+ 	cmd->loop_id = sess->loop_id;
+ 	cmd->conf_compl_supported = sess->conf_compl_supported;
+ 
+ 	cmd->trc_flags = 0;
+ 	cmd->jiffies_at_alloc = get_jiffies_64();
+ 
+ 	cmd->reset_count = vha->hw->chip_reset;
+ 
+ 	return cmd;
+ }
+ 
+ static void qlt_send_busy(struct scsi_qla_host *, struct atio_from_isp *,
+ 			  uint16_t);
+ 
+ static void qlt_create_sess_from_atio(struct work_struct *work)
+ {
+ 	struct qla_tgt_sess_op *op = container_of(work,
+ 					struct qla_tgt_sess_op, work);
+ 	scsi_qla_host_t *vha = op->vha;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct fc_port *sess;
+ 	struct qla_tgt_cmd *cmd;
+ 	unsigned long flags;
+ 	uint8_t *s_id = op->atio.u.isp24.fcp_hdr.s_id;
+ 
+ 	spin_lock_irqsave(&vha->cmd_list_lock, flags);
+ 	list_del(&op->cmd_list);
+ 	spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
+ 
+ 	if (op->aborted) {
+ 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf083,
+ 		    "sess_op with tag %u is aborted\n",
+ 		    op->atio.u.isp24.exchange_addr);
+ 		goto out_term;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf022,
+ 	    "qla_target(%d): Unable to find wwn login"
+ 	    " (s_id %x:%x:%x), trying to create it manually\n",
+ 	    vha->vp_idx, s_id[0], s_id[1], s_id[2]);
+ 
+ 	if (op->atio.u.raw.entry_count > 1) {
+ 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf023,
+ 		    "Dropping multy entry atio %p\n", &op->atio);
+ 		goto out_term;
+ 	}
+ 
+ 	sess = qlt_make_local_sess(vha, s_id);
+ 	/* sess has an extra creation ref. */
+ 
+ 	if (!sess)
+ 		goto out_term;
+ 	/*
+ 	 * Now obtain a pre-allocated session tag using the original op->atio
+ 	 * packet header, and dispatch into __qlt_do_work() using the existing
+ 	 * process context.
+ 	 */
+ 	cmd = qlt_get_tag(vha, sess, &op->atio);
+ 	if (!cmd) {
+ 		spin_lock_irqsave(&ha->hardware_lock, flags);
+ 		qlt_send_busy(vha, &op->atio, SAM_STAT_BUSY);
++>>>>>>> c5419e2618b9 (scsi: qla2xxx: Combine Active command arrays.)
  		ha->tgt.tgt_ops->put_sess(sess);
 -		spin_unlock_irqrestore(&ha->hardware_lock, flags);
 -		kfree(op);
 -		return;
 -	}
 -
 -	/*
 -	 * __qlt_do_work() will call qlt_put_sess() to release
 -	 * the extra reference taken above by qlt_make_local_sess()
 -	 */
 -	__qlt_do_work(cmd);
 -	kfree(op);
 -	return;
 -out_term:
 -	spin_lock_irqsave(&ha->hardware_lock, flags);
 -	qlt_send_term_exchange(vha, NULL, &op->atio, 1, 0);
 -	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 -	kfree(op);
  }
  
  /* ha->hardware_lock supposed to be held on entry */
@@@ -4890,20 -6589,6 +5419,23 @@@ qlt_83xx_iospace_config(struct qla_hw_d
  	ha->msix_count += 1; /* For ATIO Q */
  }
  
++<<<<<<< HEAD
 +int
 +qlt_24xx_process_response_error(struct scsi_qla_host *vha,
 +	struct sts_entry_24xx *pkt)
 +{
 +	switch (pkt->entry_type) {
 +	case ABTS_RECV_24XX:
 +	case ABTS_RESP_24XX:
 +	case CTIO_TYPE7:
 +	case NOTIFY_ACK_TYPE:
 +		return 1;
 +	default:
 +		return 0;
 +	}
 +}
++=======
++>>>>>>> c5419e2618b9 (scsi: qla2xxx: Combine Active command arrays.)
  
  void
  qlt_modify_vp_config(struct scsi_qla_host *vha,
diff --cc drivers/scsi/qla2xxx/qla_target.h
index b33e411f28a0,2120456c4709..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.h
+++ b/drivers/scsi/qla2xxx/qla_target.h
@@@ -629,7 -673,8 +639,12 @@@ struct abts_resp_from_24xx_fw 
  \********************************************************************/
  
  struct qla_tgt_mgmt_cmd;
++<<<<<<< HEAD
 +struct qla_tgt_sess;
++=======
+ struct fc_port;
+ struct qla_tgt_cmd;
++>>>>>>> c5419e2618b9 (scsi: qla2xxx: Combine Active command arrays.)
  
  /*
   * This structure provides a template of function calls that the
@@@ -704,11 -754,6 +719,14 @@@ int qla2x00_wait_for_hba_online(struct 
  #define QLA_TGT_STATE_NEED_DATA		1 /* target needs data to continue */
  #define QLA_TGT_STATE_DATA_IN		2 /* Data arrived + target processing */
  #define QLA_TGT_STATE_PROCESSED		3 /* target done processing */
++<<<<<<< HEAD
 +#define QLA_TGT_STATE_ABORTED		4 /* Command aborted */
 +
 +/* Special handles */
 +#define QLA_TGT_NULL_HANDLE	0
 +#define QLA_TGT_SKIP_HANDLE	(0xFFFFFFFF & ~CTIO_COMPLETION_HANDLE_MARK)
++=======
++>>>>>>> c5419e2618b9 (scsi: qla2xxx: Combine Active command arrays.)
  
  /* ATIO task_codes field */
  #define ATIO_SIMPLE_QUEUE           0
@@@ -829,10 -864,14 +847,20 @@@ struct qla_tgt_sess 
  };
  
  struct qla_tgt_cmd {
++<<<<<<< HEAD
 +	struct qla_tgt_sess *sess;
++=======
+ 	/*
+ 	 * Do not move cmd_type field. it needs to line up with srb->cmd_type
+ 	 */
+ 	uint8_t cmd_type;
+ 	uint8_t pad[7];
+ 	struct se_cmd se_cmd;
+ 	struct fc_port *sess;
++>>>>>>> c5419e2618b9 (scsi: qla2xxx: Combine Active command arrays.)
  	int state;
 +	struct se_cmd se_cmd;
 +	struct work_struct free_work;
  	struct work_struct work;
  	/* Sense buffer that will be mapped into outgoing status */
  	unsigned char sense_buffer[TRANSPORT_SENSE_BUFFER];
@@@ -1006,5 -1082,13 +1034,16 @@@ extern void qlt_stop_phase1(struct qla_
  extern void qlt_stop_phase2(struct qla_tgt *);
  extern irqreturn_t qla83xx_msix_atio_q(int, void *);
  extern void qlt_83xx_iospace_config(struct qla_hw_data *);
++<<<<<<< HEAD
++=======
+ extern int qlt_free_qfull_cmds(struct scsi_qla_host *);
+ extern void qlt_logo_completion_handler(fc_port_t *, int);
+ extern void qlt_do_generation_tick(struct scsi_qla_host *, int *);
+ 
+ void qlt_send_resp_ctio(scsi_qla_host_t *, struct qla_tgt_cmd *, uint8_t,
+     uint8_t, uint8_t, uint8_t);
+ extern void qlt_abort_cmd_on_host_reset(struct scsi_qla_host *,
+     struct qla_tgt_cmd *);
++>>>>>>> c5419e2618b9 (scsi: qla2xxx: Combine Active command arrays.)
  
  #endif /* __QLA_TARGET_H */
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
* Unmerged path drivers/scsi/qla2xxx/qla_gbl.h
diff --git a/drivers/scsi/qla2xxx/qla_inline.h b/drivers/scsi/qla2xxx/qla_inline.h
index 0ac13772fc47..80f805a7c137 100644
--- a/drivers/scsi/qla2xxx/qla_inline.h
+++ b/drivers/scsi/qla2xxx/qla_inline.h
@@ -253,6 +253,7 @@ qla2x00_get_sp(scsi_qla_host_t *vha, fc_port_t *fcport, gfp_t flag)
 
 	memset(sp, 0, sizeof(*sp));
 	sp->fcport = fcport;
+	sp->cmd_type = TYPE_SRB;
 	sp->iocbs = 1;
 done:
 	if (!sp)
* Unmerged path drivers/scsi/qla2xxx/qla_isr.c
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.h
