nfp: double free on error in probe

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Dan Carpenter <dan.carpenter@oracle.com>
commit e7562597b46d099a78d45c781ee8d1a7a93c53f1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e7562597.failed

Both the nfp_net_pf_app_start() and the nfp_net_pci_probe() functions
call nfp_net_pf_app_stop_ctrl(pf) so there is a double free.  The free
should be done from the probe function because it's allocated there so
I have removed the call from nfp_net_pf_app_start().

Fixes: 02082701b974 ("nfp: create control vNICs and wire up rx/tx")
	Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
	Acked-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e7562597b46d099a78d45c781ee8d1a7a93c53f1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net_main.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_main.c
index 092c7d18f2ec,34b985384d26..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
@@@ -435,15 -361,192 +435,173 @@@ nfp_net_pf_spawn_netdevs(struct nfp_pf 
  	return 0;
  
  err_prev_deinit:
 -	list_for_each_entry_continue_reverse(nn, &pf->vnics, vnic_list)
 -		if (nfp_net_is_data_vnic(nn))
 -			nfp_net_pf_clean_vnic(pf, nn);
 -	return err;
 -}
 -
 -static int
 -nfp_net_pf_app_init(struct nfp_pf *pf, u8 __iomem *qc_bar, unsigned int stride)
 -{
 -	u8 __iomem *ctrl_bar;
 -	int err;
 -
 -	pf->app = nfp_app_alloc(pf, nfp_net_pf_get_app_id(pf));
 -	if (IS_ERR(pf->app))
 -		return PTR_ERR(pf->app);
 -
 -	err = nfp_app_init(pf->app);
 -	if (err)
 -		goto err_free;
 -
 -	if (!nfp_app_needs_ctrl_vnic(pf->app))
 -		return 0;
 -
 -	ctrl_bar = nfp_net_pf_map_rtsym(pf, "net.ctrl", "_pf%u_net_ctrl_bar",
 -					NFP_PF_CSR_SLICE_SIZE,
 -					&pf->ctrl_vnic_bar);
 -	if (IS_ERR(ctrl_bar)) {
 -		nfp_err(pf->cpp, "Failed to find data vNIC memory symbol\n");
 -		err = PTR_ERR(ctrl_bar);
 -		goto err_app_clean;
 +	list_for_each_entry_continue_reverse(nn, &pf->ports, port_list) {
 +		nfp_net_debugfs_dir_clean(&nn->debugfs_dir);
 +		nfp_net_netdev_clean(nn->netdev);
  	}
++<<<<<<< HEAD
 +	nfp_net_irqs_disable(pf->pdev);
 +err_vec_free:
 +	kfree(pf->irq_entries);
 +err_nn_free:
 +	nfp_net_pf_free_netdevs(pf);
++=======
+ 
+ 	pf->ctrl_vnic =	nfp_net_pf_alloc_vnic(pf, false, ctrl_bar, qc_bar,
+ 					      stride, 0);
+ 	if (IS_ERR(pf->ctrl_vnic)) {
+ 		err = PTR_ERR(pf->ctrl_vnic);
+ 		goto err_unmap;
+ 	}
+ 
+ 	return 0;
+ 
+ err_unmap:
+ 	nfp_cpp_area_release_free(pf->ctrl_vnic_bar);
+ err_app_clean:
+ 	nfp_app_clean(pf->app);
+ err_free:
+ 	nfp_app_free(pf->app);
+ 	pf->app = NULL;
+ 	return err;
+ }
+ 
+ static void nfp_net_pf_app_clean(struct nfp_pf *pf)
+ {
+ 	if (pf->ctrl_vnic) {
+ 		nfp_net_pf_free_vnic(pf, pf->ctrl_vnic);
+ 		nfp_cpp_area_release_free(pf->ctrl_vnic_bar);
+ 	}
+ 	nfp_app_clean(pf->app);
+ 	nfp_app_free(pf->app);
+ 	pf->app = NULL;
+ }
+ 
+ static int nfp_net_pf_app_start_ctrl(struct nfp_pf *pf)
+ {
+ 	int err;
+ 
+ 	if (!pf->ctrl_vnic)
+ 		return 0;
+ 	err = nfp_net_pf_init_vnic(pf, pf->ctrl_vnic, 0);
+ 	if (err)
+ 		return err;
+ 
+ 	err = nfp_ctrl_open(pf->ctrl_vnic);
+ 	if (err)
+ 		goto err_clean_ctrl;
+ 
+ 	return 0;
+ 
+ err_clean_ctrl:
+ 	nfp_net_pf_clean_vnic(pf, pf->ctrl_vnic);
+ 	return err;
+ }
+ 
+ static void nfp_net_pf_app_stop_ctrl(struct nfp_pf *pf)
+ {
+ 	if (!pf->ctrl_vnic)
+ 		return;
+ 	nfp_ctrl_close(pf->ctrl_vnic);
+ 	nfp_net_pf_clean_vnic(pf, pf->ctrl_vnic);
+ }
+ 
+ static int nfp_net_pf_app_start(struct nfp_pf *pf)
+ {
+ 	int err;
+ 
+ 	err = nfp_app_start(pf->app, pf->ctrl_vnic);
+ 	if (err)
+ 		return err;
+ 
+ 	if (pf->num_vfs) {
+ 		err = nfp_app_sriov_enable(pf->app, pf->num_vfs);
+ 		if (err)
+ 			goto err_app_stop;
+ 	}
+ 
+ 	return 0;
+ 
+ err_app_stop:
+ 	nfp_app_stop(pf->app);
+ 	return err;
+ }
+ 
+ static void nfp_net_pf_app_stop(struct nfp_pf *pf)
+ {
+ 	if (pf->num_vfs)
+ 		nfp_app_sriov_disable(pf->app);
+ 	nfp_app_stop(pf->app);
+ }
+ 
+ static void nfp_net_pci_unmap_mem(struct nfp_pf *pf)
+ {
+ 	if (pf->vf_cfg_bar)
+ 		nfp_cpp_area_release_free(pf->vf_cfg_bar);
+ 	if (pf->mac_stats_bar)
+ 		nfp_cpp_area_release_free(pf->mac_stats_bar);
+ 	nfp_cpp_area_release_free(pf->qc_area);
+ 	nfp_cpp_area_release_free(pf->data_vnic_bar);
+ }
+ 
+ static int nfp_net_pci_map_mem(struct nfp_pf *pf)
+ {
+ 	u8 __iomem *mem;
+ 	u32 min_size;
+ 	int err;
+ 
+ 	min_size = pf->max_data_vnics * NFP_PF_CSR_SLICE_SIZE;
+ 	mem = nfp_net_pf_map_rtsym(pf, "net.ctrl", "_pf%d_net_bar0",
+ 				   min_size, &pf->data_vnic_bar);
+ 	if (IS_ERR(mem)) {
+ 		nfp_err(pf->cpp, "Failed to find data vNIC memory symbol\n");
+ 		return PTR_ERR(mem);
+ 	}
+ 
+ 	min_size =  NFP_MAC_STATS_SIZE * (pf->eth_tbl->max_index + 1);
+ 	pf->mac_stats_mem = nfp_rtsym_map(pf->rtbl, "_mac_stats",
+ 					  "net.macstats", min_size,
+ 					  &pf->mac_stats_bar);
+ 	if (IS_ERR(pf->mac_stats_mem)) {
+ 		if (PTR_ERR(pf->mac_stats_mem) != -ENOENT) {
+ 			err = PTR_ERR(pf->mac_stats_mem);
+ 			goto err_unmap_ctrl;
+ 		}
+ 		pf->mac_stats_mem = NULL;
+ 	}
+ 
+ 	pf->vf_cfg_mem = nfp_net_pf_map_rtsym(pf, "net.vfcfg",
+ 					      "_pf%d_net_vf_bar",
+ 					      NFP_NET_CFG_BAR_SZ *
+ 					      pf->limit_vfs, &pf->vf_cfg_bar);
+ 	if (IS_ERR(pf->vf_cfg_mem)) {
+ 		if (PTR_ERR(pf->vf_cfg_mem) != -ENOENT) {
+ 			err = PTR_ERR(pf->vf_cfg_mem);
+ 			goto err_unmap_mac_stats;
+ 		}
+ 		pf->vf_cfg_mem = NULL;
+ 	}
+ 
+ 	mem = nfp_cpp_map_area(pf->cpp, "net.qc", 0, 0,
+ 			       NFP_PCIE_QUEUE(0), NFP_QCP_QUEUE_AREA_SZ,
+ 			       &pf->qc_area);
+ 	if (IS_ERR(mem)) {
+ 		nfp_err(pf->cpp, "Failed to map Queue Controller area.\n");
+ 		err = PTR_ERR(mem);
+ 		goto err_unmap_vf_cfg;
+ 	}
+ 
+ 	return 0;
+ 
+ err_unmap_vf_cfg:
+ 	if (pf->vf_cfg_bar)
+ 		nfp_cpp_area_release_free(pf->vf_cfg_bar);
+ err_unmap_mac_stats:
+ 	if (pf->mac_stats_bar)
+ 		nfp_cpp_area_release_free(pf->mac_stats_bar);
+ err_unmap_ctrl:
+ 	nfp_cpp_area_release_free(pf->data_vnic_bar);
++>>>>>>> e7562597b46d (nfp: double free on error in probe)
  	return err;
  }
  
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_main.c
