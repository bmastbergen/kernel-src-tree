rtnelink: Move link dump consistency check out of the loop

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Sitnicki <jkbs@redhat.com>
commit d0225784be6c9bdfb05149ebc30bf9fc1fdbce3a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d0225784.failed

Calls to rtnl_dump_ifinfo() are protected by RTNL lock. So are the
{list,unlist}_netdevice() calls where we bump the net->dev_base_seq
number.

For this reason net->dev_base_seq can't change under out feet while
we're looping over links in rtnl_dump_ifinfo(). So move the check for
net->dev_base_seq change (since the last time we were called) out of the
loop.

This way we avoid giving a wrong impression that there are concurrent
updates to the link list going on while we're iterating over them.

	Signed-off-by: Jakub Sitnicki <jkbs@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d0225784be6c9bdfb05149ebc30bf9fc1fdbce3a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/rtnetlink.c
diff --cc net/core/rtnetlink.c
index 1df92b36501c,a78fd61da0ec..000000000000
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@@ -1489,31 -1657,34 +1487,42 @@@ static int rtnl_dump_ifinfo(struct sk_b
  			err = rtnl_fill_ifinfo(skb, dev, RTM_NEWLINK,
  					       NETLINK_CB(cb->skb).portid,
  					       cb->nlh->nlmsg_seq, 0,
 -					       flags,
 -					       ext_filter_mask, 0);
 +					       NLM_F_MULTI,
 +					       ext_filter_mask);
 +			/* If we ran out of room on the first message,
 +			 * we're in trouble
 +			 */
 +			WARN_ON((err == -EMSGSIZE) && (skb->len == 0));
 +
++<<<<<<< HEAD
 +			if (err < 0)
 +				goto out;
  
 +			nl_dump_check_consistent(cb, nlmsg_hdr(skb));
++=======
+ 			if (err < 0) {
+ 				if (likely(skb->len))
+ 					goto out;
+ 
+ 				goto out_err;
+ 			}
++>>>>>>> d0225784be6c (rtnelink: Move link dump consistency check out of the loop)
  cont:
  			idx++;
  		}
  	}
  out:
 -	err = skb->len;
 -out_err:
  	cb->args[1] = idx;
  	cb->args[0] = h;
+ 	cb->seq = net->dev_base_seq;
+ 	nl_dump_check_consistent(cb, nlmsg_hdr(skb));
  
 -	return err;
 +	return skb->len;
  }
  
 -int rtnl_nla_parse_ifla(struct nlattr **tb, const struct nlattr *head, int len,
 -			struct netlink_ext_ack *exterr)
 +int rtnl_nla_parse_ifla(struct nlattr **tb, const struct nlattr *head, int len)
  {
 -	return nla_parse(tb, IFLA_MAX, head, len, ifla_policy, exterr);
 +	return nla_parse(tb, IFLA_MAX, head, len, ifla_policy);
  }
  EXPORT_SYMBOL(rtnl_nla_parse_ifla);
  
* Unmerged path net/core/rtnetlink.c
