target: Fix race with SCF_SEND_DELAYED_TAS handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [target] Fix race with SCF_SEND_DELAYED_TAS handling (Maurizio Lombardi) [1366062]
Rebuild_FUZZ: 91.49%
commit-author Nicholas Bellinger <nab@linux-iscsi.org>
commit 310d3d314be7f0a84011ebdc4bdccbcae9755a87
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/310d3d31.failed

This patch fixes a race between setting of SCF_SEND_DELAYED_TAS
in transport_send_task_abort(), and check of the same bit in
transport_check_aborted_status().

It adds a __transport_check_aborted_status() version that is
used by target_execute_cmd() when se_cmd->t_state_lock is
held, and a transport_check_aborted_status() wrapper for
all other existing callers.

Also, it handles the case where the check happens before
transport_send_task_abort() gets called.  For this, go
ahead and set SCF_SEND_DELAYED_TAS early when necessary,
and have transport_send_task_abort() send the abort.

	Cc: Quinn Tran <quinn.tran@qlogic.com>
	Cc: Himanshu Madhani <himanshu.madhani@qlogic.com>
	Cc: Sagi Grimberg <sagig@mellanox.com>
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: Hannes Reinecke <hare@suse.de>
	Cc: Andy Grover <agrover@redhat.com>
	Cc: Mike Christie <mchristi@redhat.com>
	Cc: stable@vger.kernel.org # 3.10+
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 310d3d314be7f0a84011ebdc4bdccbcae9755a87)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_transport.c
diff --cc drivers/target/target_core_transport.c
index 68bc47c2e404,2e0b23a3d5c4..000000000000
--- a/drivers/target/target_core_transport.c
+++ b/drivers/target/target_core_transport.c
@@@ -1844,18 -1865,17 +1846,18 @@@ void target_execute_cmd(struct se_cmd *
  	/*
  	 * Determine if frontend context caller is requesting the stopping of
  	 * this command for frontend exceptions.
+ 	 *
+ 	 * If the received CDB has aleady been aborted stop processing it here.
  	 */
  	spin_lock_irq(&cmd->t_state_lock);
+ 	if (__transport_check_aborted_status(cmd, 1)) {
+ 		spin_unlock_irq(&cmd->t_state_lock);
+ 		return;
+ 	}
  	if (cmd->transport_state & CMD_T_STOP) {
 -		pr_debug("%s:%d CMD_T_STOP for ITT: 0x%08llx\n",
 -			__func__, __LINE__, cmd->tag);
 +		pr_debug("%s:%d CMD_T_STOP for ITT: 0x%08x\n",
 +			__func__, __LINE__,
 +			cmd->se_tfo->get_task_tag(cmd));
  
  		spin_unlock_irq(&cmd->t_state_lock);
  		complete_all(&cmd->t_transport_stop_comp);
@@@ -2907,11 -2926,14 +2913,19 @@@ static int __transport_check_aborted_st
  	 * If cmd has been aborted but either no status is to be sent or it has
  	 * already been sent, just return
  	 */
- 	if (!send_status || !(cmd->se_cmd_flags & SCF_SEND_DELAYED_TAS))
+ 	if (!send_status || !(cmd->se_cmd_flags & SCF_SEND_DELAYED_TAS)) {
+ 		if (send_status)
+ 			cmd->se_cmd_flags |= SCF_SEND_DELAYED_TAS;
  		return 1;
+ 	}
  
++<<<<<<< HEAD
 +	pr_debug("Sending delayed SAM_STAT_TASK_ABORTED status for CDB: 0x%02x ITT: 0x%08x\n",
 +		 cmd->t_task_cdb[0], cmd->se_tfo->get_task_tag(cmd));
++=======
+ 	pr_debug("Sending delayed SAM_STAT_TASK_ABORTED status for CDB:"
+ 		" 0x%02x ITT: 0x%08llx\n", cmd->t_task_cdb[0], cmd->tag);
++>>>>>>> 310d3d314be7 (target: Fix race with SCF_SEND_DELAYED_TAS handling)
  
  	cmd->se_cmd_flags &= ~SCF_SEND_DELAYED_TAS;
  	cmd->scsi_status = SAM_STAT_TASK_ABORTED;
* Unmerged path drivers/target/target_core_transport.c
