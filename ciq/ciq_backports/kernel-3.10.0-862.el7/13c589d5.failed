sysfs: use seq_file when reading regular files

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Tejun Heo <tj@kernel.org>
commit 13c589d5b0ac654d9da7e490a2dd548e6b86b4a5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/13c589d5.failed

sysfs read path implements its own buffering scheme between userland
and kernel callbacks, which essentially is a degenerate duplicate of
seq_file.  This patch replaces the custom read buffering
implementation in sysfs with seq_file.

While the amount of code reduction is small, this reduces low level
hairiness and enables future development of a new versatile API based
on seq_file so that sysfs features can be shared with other
subsystems.

As write path was already converted to not use sysfs_open_file->page,
this patch makes ->page and ->count unused and removes them.

Userland behavior remains the same except for some extreme corner
cases - e.g. sysfs will now regenerate the content each time a file is
read after a non-contiguous seek whereas the original code would keep
using the same content.  While this is a userland visible behavior
change, it is extremely unlikely to be noticeable and brings sysfs
behavior closer to that of procfs.

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Cc: Kay Sievers <kay@vrfy.org>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 13c589d5b0ac654d9da7e490a2dd548e6b86b4a5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/sysfs/file.c
diff --cc fs/sysfs/file.c
index d8887c896abc,4921bda3a37a..000000000000
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@@ -31,8 -32,9 +32,14 @@@
   * sysfs_dirent->s_attr.open points to sysfs_open_dirent.  s_attr.open is
   * protected by sysfs_open_dirent_lock.
   *
++<<<<<<< HEAD
 + * filp->private_data points to sysfs_buffer which is chained at
 + * sysfs_open_dirent->buffers, which is protected by sysfs_open_file_mutex.
++=======
+  * filp->private_data points to seq_file whose ->private points to
+  * sysfs_open_file.  sysfs_open_files are chained at
+  * sysfs_open_dirent->files, which is protected by sysfs_open_file_mutex.
++>>>>>>> 13c589d5b0ac (sysfs: use seq_file when reading regular files)
   */
  static DEFINE_SPINLOCK(sysfs_open_dirent_lock);
  static DEFINE_MUTEX(sysfs_open_file_mutex);
@@@ -41,52 -43,82 +48,122 @@@ struct sysfs_open_dirent 
  	atomic_t		refcnt;
  	atomic_t		event;
  	wait_queue_head_t	poll;
 -	struct list_head	files; /* goes through sysfs_open_file.list */
 +	struct list_head	buffers; /* goes through sysfs_buffer.list */
  };
  
++<<<<<<< HEAD
 +struct sysfs_buffer {
 +	size_t			count;
 +	loff_t			pos;
 +	char			* page;
 +	const struct sysfs_ops	* ops;
++=======
+ struct sysfs_open_file {
+ 	struct sysfs_dirent	*sd;
+ 	struct file		*file;
++>>>>>>> 13c589d5b0ac (sysfs: use seq_file when reading regular files)
  	struct mutex		mutex;
 +	int			needs_read_fill;
  	int			event;
  	struct list_head	list;
  };
  
++<<<<<<< HEAD
 +/**
 + *	fill_read_buffer - allocate and fill buffer from object.
 + *	@dentry:	dentry pointer.
 + *	@buffer:	data buffer for file.
 + *
 + *	Allocate @buffer->page, if it hasn't been already, then call the
 + *	kobject's show() method to fill the buffer with this attribute's
 + *	data.
 + *	This is called only once, on the file's first read unless an error
 + *	is returned.
 + */
 +static int fill_read_buffer(struct dentry * dentry, struct sysfs_buffer * buffer)
 +{
 +	struct sysfs_dirent *attr_sd = dentry->d_fsdata;
 +	struct kobject *kobj = attr_sd->s_parent->s_dir.kobj;
 +	const struct sysfs_ops * ops = buffer->ops;
 +	int ret = 0;
 +	ssize_t count;
 +
 +	if (!buffer->page)
 +		buffer->page = (char *) get_zeroed_page(GFP_KERNEL);
 +	if (!buffer->page)
 +		return -ENOMEM;
++=======
+ static struct sysfs_open_file *sysfs_of(struct file *file)
+ {
+ 	return ((struct seq_file *)file->private_data)->private;
+ }
  
- 	/* need attr_sd for attr and ops, its parent for kobj */
- 	if (!sysfs_get_active(attr_sd))
+ /*
+  * Determine ktype->sysfs_ops for the given sysfs_dirent.  This function
+  * must be called while holding an active reference.
+  */
+ static const struct sysfs_ops *sysfs_file_ops(struct sysfs_dirent *sd)
+ {
+ 	struct kobject *kobj = sd->s_parent->s_dir.kobj;
+ 
+ 	lockdep_assert_held(sd);
+ 	return kobj->ktype ? kobj->ktype->sysfs_ops : NULL;
+ }
+ 
+ /*
+  * Reads on sysfs are handled through seq_file, which takes care of hairy
+  * details like buffering and seeking.  The following function pipes
+  * sysfs_ops->show() result through seq_file.
+  */
+ static int sysfs_seq_show(struct seq_file *sf, void *v)
+ {
+ 	struct sysfs_open_file *of = sf->private;
+ 	struct kobject *kobj = of->sd->s_parent->s_dir.kobj;
+ 	const struct sysfs_ops *ops;
+ 	char *buf;
+ 	ssize_t count;
+ 
+ 	/* acquire buffer and ensure that it's >= PAGE_SIZE */
+ 	count = seq_get_buf(sf, &buf);
+ 	if (count < PAGE_SIZE) {
+ 		seq_commit(sf, -1);
+ 		return 0;
+ 	}
++>>>>>>> 13c589d5b0ac (sysfs: use seq_file when reading regular files)
+ 
+ 	/*
+ 	 * Need @of->sd for attr and ops, its parent for kobj.  @of->mutex
+ 	 * nests outside active ref and is just to ensure that the ops
+ 	 * aren't called concurrently for the same open file.
+ 	 */
+ 	mutex_lock(&of->mutex);
+ 	if (!sysfs_get_active(of->sd)) {
+ 		mutex_unlock(&of->mutex);
  		return -ENODEV;
+ 	}
  
++<<<<<<< HEAD
 +	buffer->event = atomic_read(&attr_sd->s_attr.open->event);
 +	count = ops->show(kobj, attr_sd->s_attr.attr, buffer->page);
++=======
+ 	of->event = atomic_read(&of->sd->s_attr.open->event);
  
- 	sysfs_put_active(attr_sd);
+ 	/*
+ 	 * Lookup @ops and invoke show().  Control may reach here via seq
+ 	 * file lseek even if @ops->show() isn't implemented.
+ 	 */
+ 	ops = sysfs_file_ops(of->sd);
+ 	if (ops->show)
+ 		count = ops->show(kobj, of->sd->s_attr.attr, buf);
+ 	else
+ 		count = 0;
++>>>>>>> 13c589d5b0ac (sysfs: use seq_file when reading regular files)
+ 
+ 	sysfs_put_active(of->sd);
+ 	mutex_unlock(&of->mutex);
+ 
+ 	if (count < 0)
+ 		return count;
  
  	/*
  	 * The code works fine with PAGE_SIZE return but it's likely to
@@@ -98,53 -130,8 +175,58 @@@
  		/* Try to struggle along */
  		count = PAGE_SIZE - 1;
  	}
++<<<<<<< HEAD
 +	if (count >= 0) {
 +		buffer->needs_read_fill = 0;
 +		buffer->count = count;
 +	} else {
 +		ret = count;
 +	}
 +	return ret;
 +}
 +
 +/**
 + *	sysfs_read_file - read an attribute.
 + *	@file:	file pointer.
 + *	@buf:	buffer to fill.
 + *	@count:	number of bytes to read.
 + *	@ppos:	starting offset in file.
 + *
 + *	Userspace wants to read an attribute file. The attribute descriptor
 + *	is in the file's ->d_fsdata. The target object is in the directory's
 + *	->d_fsdata.
 + *
 + *	We call fill_read_buffer() to allocate and fill the buffer from the
 + *	object's show() method exactly once (if the read is happening from
 + *	the beginning of the file). That should fill the entire buffer with
 + *	all the data the object has to offer for that attribute.
 + *	We then call flush_read_buffer() to copy the buffer to userspace
 + *	in the increments specified.
 + */
 +
 +static ssize_t
 +sysfs_read_file(struct file *file, char __user *buf, size_t count, loff_t *ppos)
 +{
 +	struct sysfs_buffer * buffer = file->private_data;
 +	ssize_t retval = 0;
 +
 +	mutex_lock(&buffer->mutex);
 +	if (buffer->needs_read_fill || *ppos == 0) {
 +		retval = fill_read_buffer(file->f_path.dentry,buffer);
 +		if (retval)
 +			goto out;
 +	}
 +	pr_debug("%s: count = %zd, ppos = %lld, buf = %s\n",
 +		 __func__, count, *ppos, buffer->page);
 +	retval = simple_read_from_buffer(buf, count, ppos, buffer->page,
 +					 buffer->count);
 +out:
 +	mutex_unlock(&buffer->mutex);
 +	return retval;
++=======
+ 	seq_commit(sf, count);
+ 	return 0;
++>>>>>>> 13c589d5b0ac (sysfs: use seq_file when reading regular files)
  }
  
  /**
@@@ -206,37 -170,47 +288,43 @@@ flush_write_buffer(struct dentry * dent
  	return rc;
  }
  
 +
  /**
 - * sysfs_write_file - write an attribute
 - * @file: file pointer
 - * @user_buf: data to write
 - * @count: number of bytes
 - * @ppos: starting offset
 + *	sysfs_write_file - write an attribute.
 + *	@file:	file pointer
 + *	@buf:	data to write
 + *	@count:	number of bytes
 + *	@ppos:	starting offset
   *
 - * Copy data in from userland and pass it to the matching
 - * sysfs_ops->store() by invoking flush_write_buffer().
 - *
 - * There is no easy way for us to know if userspace is only doing a partial
 - * write, so we don't support them. We expect the entire buffer to come on
 - * the first write.  Hint: if you're writing a value, first read the file,
 - * modify only the the value you're changing, then write entire buffer
 - * back.
 + *	Similar to sysfs_read_file(), though working in the opposite direction.
 + *	We allocate and fill the data from the user in fill_write_buffer(),
 + *	then push it to the kobject in flush_write_buffer().
 + *	There is no easy way for us to know if userspace is only doing a partial
 + *	write, so we don't support them. We expect the entire buffer to come
 + *	on the first write.
 + *	Hint: if you're writing a value, first read the file, modify only the
 + *	the value you're changing, then write entire buffer back.
   */
 -static ssize_t sysfs_write_file(struct file *file, const char __user *user_buf,
 -				size_t count, loff_t *ppos)
 +
 +static ssize_t
 +sysfs_write_file(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
  {
++<<<<<<< HEAD
 +	struct sysfs_buffer * buffer = file->private_data;
 +	ssize_t len;
++=======
+ 	struct sysfs_open_file *of = sysfs_of(file);
+ 	ssize_t len = min_t(size_t, count, PAGE_SIZE - 1);
+ 	char *buf;
++>>>>>>> 13c589d5b0ac (sysfs: use seq_file when reading regular files)
  
 -	if (!len)
 -		return 0;
 -
 -	buf = kmalloc(len + 1, GFP_KERNEL);
 -	if (!buf)
 -		return -ENOMEM;
 -
 -	if (copy_from_user(buf, user_buf, len)) {
 -		len = -EFAULT;
 -		goto out_free;
 -	}
 -	buf[len] = '\0';	/* guarantee string termination */
 -
 -	len = flush_write_buffer(of, buf, len);
 +	mutex_lock(&buffer->mutex);
 +	len = fill_write_buffer(buffer, buf, count);
 +	if (len > 0)
 +		len = flush_write_buffer(file->f_path.dentry, buffer, len);
  	if (len > 0)
  		*ppos += len;
 -out_free:
 -	kfree(buf);
 +	mutex_unlock(&buffer->mutex);
  	return len;
  }
  
@@@ -367,31 -337,43 +455,62 @@@ static int sysfs_open_file(struct inod
  			goto err_out;
  	}
  
++<<<<<<< HEAD
 +	/* No error? Great, allocate a buffer for the file, and store it
 +	 * it in file->private_data for easy access.
 +	 */
++=======
+ 	/* allocate a sysfs_open_file for the file */
++>>>>>>> 13c589d5b0ac (sysfs: use seq_file when reading regular files)
  	error = -ENOMEM;
 -	of = kzalloc(sizeof(struct sysfs_open_file), GFP_KERNEL);
 -	if (!of)
 +	buffer = kzalloc(sizeof(struct sysfs_buffer), GFP_KERNEL);
 +	if (!buffer)
  		goto err_out;
  
++<<<<<<< HEAD
 +	mutex_init(&buffer->mutex);
 +	buffer->needs_read_fill = 1;
 +	buffer->ops = ops;
 +	file->private_data = buffer;
++=======
+ 	mutex_init(&of->mutex);
+ 	of->sd = attr_sd;
+ 	of->file = file;
+ 
+ 	/*
+ 	 * Always instantiate seq_file even if read access is not
+ 	 * implemented or requested.  This unifies private data access and
+ 	 * most files are readable anyway.
+ 	 */
+ 	error = single_open(file, sysfs_seq_show, of);
+ 	if (error)
+ 		goto err_free;
+ 
+ 	/* seq_file clears PWRITE unconditionally, restore it if WRITE */
+ 	if (file->f_mode & FMODE_WRITE)
+ 		file->f_mode |= FMODE_PWRITE;
++>>>>>>> 13c589d5b0ac (sysfs: use seq_file when reading regular files)
  
  	/* make sure we have open dirent struct */
 -	error = sysfs_get_open_dirent(attr_sd, of);
 +	error = sysfs_get_open_dirent(attr_sd, buffer);
  	if (error)
- 		goto err_free;
+ 		goto err_close;
  
  	/* open succeeded, put active references */
  	sysfs_put_active(attr_sd);
  	return 0;
  
++<<<<<<< HEAD
 + err_free:
 +	kfree(buffer);
 + err_out:
++=======
+ err_close:
+ 	single_release(inode, file);
+ err_free:
+ 	kfree(of);
+ err_out:
++>>>>>>> 13c589d5b0ac (sysfs: use seq_file when reading regular files)
  	sysfs_put_active(attr_sd);
  	return error;
  }
@@@ -399,13 -381,11 +518,21 @@@
  static int sysfs_release(struct inode *inode, struct file *filp)
  {
  	struct sysfs_dirent *sd = filp->f_path.dentry->d_fsdata;
++<<<<<<< HEAD
 +	struct sysfs_buffer *buffer = filp->private_data;
 +
 +	sysfs_put_open_dirent(sd, buffer);
 +
 +	if (buffer->page)
 +		free_page((unsigned long)buffer->page);
 +	kfree(buffer);
++=======
+ 	struct sysfs_open_file *of = sysfs_of(filp);
+ 
+ 	sysfs_put_open_dirent(sd, of);
+ 	single_release(inode, filp);
+ 	kfree(of);
++>>>>>>> 13c589d5b0ac (sysfs: use seq_file when reading regular files)
  
  	return 0;
  }
@@@ -425,7 -405,7 +552,11 @@@
   */
  static unsigned int sysfs_poll(struct file *filp, poll_table *wait)
  {
++<<<<<<< HEAD
 +	struct sysfs_buffer * buffer = filp->private_data;
++=======
+ 	struct sysfs_open_file *of = sysfs_of(filp);
++>>>>>>> 13c589d5b0ac (sysfs: use seq_file when reading regular files)
  	struct sysfs_dirent *attr_sd = filp->f_path.dentry->d_fsdata;
  	struct sysfs_open_dirent *od = attr_sd->s_attr.open;
  
* Unmerged path fs/sysfs/file.c
