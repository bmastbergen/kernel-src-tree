drm/i915/cnl: don't hardcode DPCLKA_CFGCR0_DDI_CLK_SEL_SHIFT

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Paulo Zanoni <paulo.r.zanoni@intel.com>
commit dfbd4508326218d63e75715217a495adc0b4a454
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/dfbd4508.failed

We have the macro, use it. Makes the code a little easier to
understand.

	Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
	Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
	Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20170825194004.26571-1-paulo.r.zanoni@intel.com
(cherry picked from commit dfbd4508326218d63e75715217a495adc0b4a454)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_display.c
diff --cc drivers/gpu/drm/i915/intel_display.c
index 5dd07ce861be,7cd392f2cd94..000000000000
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@@ -10078,447 -8109,512 +10078,466 @@@ static void hsw_disable_lcpll(struct dr
  }
  
  /*
 - * Initialize reference clocks when the driver loads
 + * Fully restores LCPLL, disallowing power down and switching back to LCPLL
 + * source.
   */
 -void intel_init_pch_refclk(struct drm_i915_private *dev_priv)
 -{
 -	if (HAS_PCH_IBX(dev_priv) || HAS_PCH_CPT(dev_priv))
 -		ironlake_init_pch_refclk(dev_priv);
 -	else if (HAS_PCH_LPT(dev_priv))
 -		lpt_init_pch_refclk(dev_priv);
 -}
 -
 -static void ironlake_set_pipeconf(struct drm_crtc *crtc)
 +static void hsw_restore_lcpll(struct drm_i915_private *dev_priv)
  {
 -	struct drm_i915_private *dev_priv = to_i915(crtc->dev);
 -	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
 -	int pipe = intel_crtc->pipe;
  	uint32_t val;
  
 -	val = 0;
 +	val = I915_READ(LCPLL_CTL);
  
 -	switch (intel_crtc->config->pipe_bpp) {
 -	case 18:
 -		val |= PIPECONF_6BPC;
 -		break;
 -	case 24:
 -		val |= PIPECONF_8BPC;
 -		break;
 -	case 30:
 -		val |= PIPECONF_10BPC;
 -		break;
 -	case 36:
 -		val |= PIPECONF_12BPC;
 -		break;
 -	default:
 -		/* Case prevented by intel_choose_pipe_bpp_dither. */
 -		BUG();
 -	}
 +	if ((val & (LCPLL_PLL_LOCK | LCPLL_PLL_DISABLE | LCPLL_CD_SOURCE_FCLK |
 +		    LCPLL_POWER_DOWN_ALLOW)) == LCPLL_PLL_LOCK)
 +		return;
  
 -	if (intel_crtc->config->dither)
 -		val |= (PIPECONF_DITHER_EN | PIPECONF_DITHER_TYPE_SP);
 +	/*
 +	 * Make sure we're not on PC8 state before disabling PC8, otherwise
 +	 * we'll hang the machine. To prevent PC8 state, just enable force_wake.
 +	 */
 +	intel_uncore_forcewake_get(dev_priv, FORCEWAKE_ALL);
  
 -	if (intel_crtc->config->base.adjusted_mode.flags & DRM_MODE_FLAG_INTERLACE)
 -		val |= PIPECONF_INTERLACED_ILK;
 -	else
 -		val |= PIPECONF_PROGRESSIVE;
 +	if (val & LCPLL_POWER_DOWN_ALLOW) {
 +		val &= ~LCPLL_POWER_DOWN_ALLOW;
 +		I915_WRITE(LCPLL_CTL, val);
 +		POSTING_READ(LCPLL_CTL);
 +	}
  
 -	if (intel_crtc->config->limited_color_range)
 -		val |= PIPECONF_COLOR_RANGE_SELECT;
 +	val = hsw_read_dcomp(dev_priv);
 +	val |= D_COMP_COMP_FORCE;
 +	val &= ~D_COMP_COMP_DISABLE;
 +	hsw_write_dcomp(dev_priv, val);
  
 -	I915_WRITE(PIPECONF(pipe), val);
 -	POSTING_READ(PIPECONF(pipe));
 -}
 +	val = I915_READ(LCPLL_CTL);
 +	val &= ~LCPLL_PLL_DISABLE;
 +	I915_WRITE(LCPLL_CTL, val);
  
 -static void haswell_set_pipeconf(struct drm_crtc *crtc)
 -{
 -	struct drm_i915_private *dev_priv = to_i915(crtc->dev);
 -	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
 -	enum transcoder cpu_transcoder = intel_crtc->config->cpu_transcoder;
 -	u32 val = 0;
 +	if (intel_wait_for_register(dev_priv,
 +				    LCPLL_CTL, LCPLL_PLL_LOCK, LCPLL_PLL_LOCK,
 +				    5))
 +		DRM_ERROR("LCPLL not locked yet\n");
  
 -	if (IS_HASWELL(dev_priv) && intel_crtc->config->dither)
 -		val |= (PIPECONF_DITHER_EN | PIPECONF_DITHER_TYPE_SP);
 +	if (val & LCPLL_CD_SOURCE_FCLK) {
 +		val = I915_READ(LCPLL_CTL);
 +		val &= ~LCPLL_CD_SOURCE_FCLK;
 +		I915_WRITE(LCPLL_CTL, val);
  
 -	if (intel_crtc->config->base.adjusted_mode.flags & DRM_MODE_FLAG_INTERLACE)
 -		val |= PIPECONF_INTERLACED_ILK;
 -	else
 -		val |= PIPECONF_PROGRESSIVE;
 +		if (wait_for_us((I915_READ(LCPLL_CTL) &
 +				 LCPLL_CD_SOURCE_FCLK_DONE) == 0, 1))
 +			DRM_ERROR("Switching back to LCPLL failed\n");
 +	}
  
 -	I915_WRITE(PIPECONF(cpu_transcoder), val);
 -	POSTING_READ(PIPECONF(cpu_transcoder));
 +	intel_uncore_forcewake_put(dev_priv, FORCEWAKE_ALL);
 +	intel_update_cdclk(dev_priv);
  }
  
 -static void haswell_set_pipemisc(struct drm_crtc *crtc)
 -{
 -	struct drm_i915_private *dev_priv = to_i915(crtc->dev);
 -	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
 -	struct intel_crtc_state *config = intel_crtc->config;
 -
 -	if (IS_BROADWELL(dev_priv) || INTEL_INFO(dev_priv)->gen >= 9) {
 -		u32 val = 0;
 -
 -		switch (intel_crtc->config->pipe_bpp) {
 -		case 18:
 -			val |= PIPEMISC_DITHER_6_BPC;
 -			break;
 -		case 24:
 -			val |= PIPEMISC_DITHER_8_BPC;
 -			break;
 -		case 30:
 -			val |= PIPEMISC_DITHER_10_BPC;
 -			break;
 -		case 36:
 -			val |= PIPEMISC_DITHER_12_BPC;
 -			break;
 -		default:
 -			/* Case prevented by pipe_config_set_bpp. */
 -			BUG();
 -		}
 -
 -		if (intel_crtc->config->dither)
 -			val |= PIPEMISC_DITHER_ENABLE | PIPEMISC_DITHER_TYPE_SP;
 +/*
 + * Package states C8 and deeper are really deep PC states that can only be
 + * reached when all the devices on the system allow it, so even if the graphics
 + * device allows PC8+, it doesn't mean the system will actually get to these
 + * states. Our driver only allows PC8+ when going into runtime PM.
 + *
 + * The requirements for PC8+ are that all the outputs are disabled, the power
 + * well is disabled and most interrupts are disabled, and these are also
 + * requirements for runtime PM. When these conditions are met, we manually do
 + * the other conditions: disable the interrupts, clocks and switch LCPLL refclk
 + * to Fclk. If we're in PC8+ and we get an non-hotplug interrupt, we can hard
 + * hang the machine.
 + *
 + * When we really reach PC8 or deeper states (not just when we allow it) we lose
 + * the state of some registers, so when we come back from PC8+ we need to
 + * restore this state. We don't get into PC8+ if we're not in RC6, so we don't
 + * need to take care of the registers kept by RC6. Notice that this happens even
 + * if we don't put the device in PCI D3 state (which is what currently happens
 + * because of the runtime PM support).
 + *
 + * For more, read "Display Sequences for Package C8" on the hardware
 + * documentation.
 + */
 +void hsw_enable_pc8(struct drm_i915_private *dev_priv)
 +{
 +	struct drm_device *dev = &dev_priv->drm;
 +	uint32_t val;
  
 -		if (config->ycbcr420) {
 -			val |= PIPEMISC_OUTPUT_COLORSPACE_YUV |
 -				PIPEMISC_YUV420_ENABLE |
 -				PIPEMISC_YUV420_MODE_FULL_BLEND;
 -		}
 +	DRM_DEBUG_KMS("Enabling package C8+\n");
  
 -		I915_WRITE(PIPEMISC(intel_crtc->pipe), val);
 +	if (HAS_PCH_LPT_LP(dev_priv)) {
 +		val = I915_READ(SOUTH_DSPCLK_GATE_D);
 +		val &= ~PCH_LP_PARTITION_LEVEL_DISABLE;
 +		I915_WRITE(SOUTH_DSPCLK_GATE_D, val);
  	}
 -}
  
 -int ironlake_get_lanes_required(int target_clock, int link_bw, int bpp)
 -{
 -	/*
 -	 * Account for spread spectrum to avoid
 -	 * oversubscribing the link. Max center spread
 -	 * is 2.5%; use 5% for safety's sake.
 -	 */
 -	u32 bps = target_clock * bpp * 21 / 20;
 -	return DIV_ROUND_UP(bps, link_bw * 8);
 -}
 -
 -static bool ironlake_needs_fb_cb_tune(struct dpll *dpll, int factor)
 -{
 -	return i9xx_dpll_compute_m(dpll) < factor * dpll->n;
 +	lpt_disable_clkout_dp(dev);
 +	hsw_disable_lcpll(dev_priv, true, true);
  }
  
 -static void ironlake_compute_dpll(struct intel_crtc *intel_crtc,
 -				  struct intel_crtc_state *crtc_state,
 -				  struct dpll *reduced_clock)
 +void hsw_disable_pc8(struct drm_i915_private *dev_priv)
  {
 -	struct drm_crtc *crtc = &intel_crtc->base;
 -	struct drm_device *dev = crtc->dev;
 -	struct drm_i915_private *dev_priv = to_i915(dev);
 -	u32 dpll, fp, fp2;
 -	int factor;
 -
 -	/* Enable autotuning of the PLL clock (if permissible) */
 -	factor = 21;
 -	if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS)) {
 -		if ((intel_panel_use_ssc(dev_priv) &&
 -		     dev_priv->vbt.lvds_ssc_freq == 100000) ||
 -		    (HAS_PCH_IBX(dev_priv) && intel_is_dual_link_lvds(dev)))
 -			factor = 25;
 -	} else if (crtc_state->sdvo_tv_clock)
 -		factor = 20;
 -
 -	fp = i9xx_dpll_compute_fp(&crtc_state->dpll);
 +	struct drm_device *dev = &dev_priv->drm;
 +	uint32_t val;
  
 -	if (ironlake_needs_fb_cb_tune(&crtc_state->dpll, factor))
 -		fp |= FP_CB_TUNE;
 +	DRM_DEBUG_KMS("Disabling package C8+\n");
  
 -	if (reduced_clock) {
 -		fp2 = i9xx_dpll_compute_fp(reduced_clock);
 +	hsw_restore_lcpll(dev_priv);
 +	lpt_init_pch_refclk(dev);
  
 -		if (reduced_clock->m < factor * reduced_clock->n)
 -			fp2 |= FP_CB_TUNE;
 -	} else {
 -		fp2 = fp;
 +	if (HAS_PCH_LPT_LP(dev_priv)) {
 +		val = I915_READ(SOUTH_DSPCLK_GATE_D);
 +		val |= PCH_LP_PARTITION_LEVEL_DISABLE;
 +		I915_WRITE(SOUTH_DSPCLK_GATE_D, val);
  	}
 +}
  
 -	dpll = 0;
 -
 -	if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS))
 -		dpll |= DPLLB_MODE_LVDS;
 -	else
 -		dpll |= DPLLB_MODE_DAC_SERIAL;
 +static void bxt_modeset_commit_cdclk(struct drm_atomic_state *old_state)
 +{
 +	struct drm_device *dev = old_state->dev;
 +	struct intel_atomic_state *old_intel_state =
 +		to_intel_atomic_state(old_state);
 +	unsigned int req_cdclk = old_intel_state->dev_cdclk;
  
 -	dpll |= (crtc_state->pixel_multiplier - 1)
 -		<< PLL_REF_SDVO_HDMI_MULTIPLIER_SHIFT;
 +	bxt_set_cdclk(to_i915(dev), req_cdclk);
 +}
  
 -	if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_SDVO) ||
 -	    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))
 -		dpll |= DPLL_SDVO_HIGH_SPEED;
 +static int bdw_adjust_min_pipe_pixel_rate(struct intel_crtc_state *crtc_state,
 +					  int pixel_rate)
 +{
 +	struct drm_i915_private *dev_priv = to_i915(crtc_state->base.crtc->dev);
  
 -	if (intel_crtc_has_dp_encoder(crtc_state))
 -		dpll |= DPLL_SDVO_HIGH_SPEED;
 +	/* pixel rate mustn't exceed 95% of cdclk with IPS on BDW */
 +	if (IS_BROADWELL(dev_priv) && crtc_state->ips_enabled)
 +		pixel_rate = DIV_ROUND_UP(pixel_rate * 100, 95);
  
 -	/*
 -	 * The high speed IO clock is only really required for
 -	 * SDVO/HDMI/DP, but we also enable it for CRT to make it
 -	 * possible to share the DPLL between CRT and HDMI. Enabling
 -	 * the clock needlessly does no real harm, except use up a
 -	 * bit of power potentially.
 -	 *
 -	 * We'll limit this to IVB with 3 pipes, since it has only two
 -	 * DPLLs and so DPLL sharing is the only way to get three pipes
 -	 * driving PCH ports at the same time. On SNB we could do this,
 -	 * and potentially avoid enabling the second DPLL, but it's not
 -	 * clear if it''s a win or loss power wise. No point in doing
 -	 * this on ILK at all since it has a fixed DPLL<->pipe mapping.
 +	/* BSpec says "Do not use DisplayPort with CDCLK less than
 +	 * 432 MHz, audio enabled, port width x4, and link rate
 +	 * HBR2 (5.4 GHz), or else there may be audio corruption or
 +	 * screen corruption."
  	 */
 -	if (INTEL_INFO(dev_priv)->num_pipes == 3 &&
 -	    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_ANALOG))
 -		dpll |= DPLL_SDVO_HIGH_SPEED;
 -
 -	/* compute bitmask from p1 value */
 -	dpll |= (1 << (crtc_state->dpll.p1 - 1)) << DPLL_FPA01_P1_POST_DIV_SHIFT;
 -	/* also FPA1 */
 -	dpll |= (1 << (crtc_state->dpll.p1 - 1)) << DPLL_FPA1_P1_POST_DIV_SHIFT;
 -
 -	switch (crtc_state->dpll.p2) {
 -	case 5:
 -		dpll |= DPLL_DAC_SERIAL_P2_CLOCK_DIV_5;
 -		break;
 -	case 7:
 -		dpll |= DPLLB_LVDS_P2_CLOCK_DIV_7;
 -		break;
 -	case 10:
 -		dpll |= DPLL_DAC_SERIAL_P2_CLOCK_DIV_10;
 -		break;
 -	case 14:
 -		dpll |= DPLLB_LVDS_P2_CLOCK_DIV_14;
 -		break;
 -	}
 -
 -	if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS) &&
 -	    intel_panel_use_ssc(dev_priv))
 -		dpll |= PLLB_REF_INPUT_SPREADSPECTRUMIN;
 -	else
 -		dpll |= PLL_REF_INPUT_DREFCLK;
 -
 -	dpll |= DPLL_VCO_ENABLE;
 +	if (intel_crtc_has_dp_encoder(crtc_state) &&
 +	    crtc_state->has_audio &&
 +	    crtc_state->port_clock >= 540000 &&
 +	    crtc_state->lane_count == 4)
 +		pixel_rate = max(432000, pixel_rate);
  
 -	crtc_state->dpll_hw_state.dpll = dpll;
 -	crtc_state->dpll_hw_state.fp0 = fp;
 -	crtc_state->dpll_hw_state.fp1 = fp2;
 +	return pixel_rate;
  }
  
 -static int ironlake_crtc_compute_clock(struct intel_crtc *crtc,
 -				       struct intel_crtc_state *crtc_state)
 +/* compute the max rate for new configuration */
 +static int ilk_max_pixel_rate(struct drm_atomic_state *state)
  {
 -	struct drm_device *dev = crtc->base.dev;
 -	struct drm_i915_private *dev_priv = to_i915(dev);
 -	const struct intel_limit *limit;
 -	int refclk = 120000;
 -
 -	memset(&crtc_state->dpll_hw_state, 0,
 -	       sizeof(crtc_state->dpll_hw_state));
 -
 -	crtc->lowfreq_avail = false;
 +	struct intel_atomic_state *intel_state = to_intel_atomic_state(state);
 +	struct drm_i915_private *dev_priv = to_i915(state->dev);
 +	struct drm_crtc *crtc;
 +	struct drm_crtc_state *cstate;
 +	struct intel_crtc_state *crtc_state;
 +	unsigned max_pixel_rate = 0, i;
 +	enum pipe pipe;
  
 -	/* CPU eDP is the only output that doesn't need a PCH PLL of its own. */
 -	if (!crtc_state->has_pch_encoder)
 -		return 0;
 +	memcpy(intel_state->min_pixclk, dev_priv->min_pixclk,
 +	       sizeof(intel_state->min_pixclk));
  
 -	if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_LVDS)) {
 -		if (intel_panel_use_ssc(dev_priv)) {
 -			DRM_DEBUG_KMS("using SSC reference clock of %d kHz\n",
 -				      dev_priv->vbt.lvds_ssc_freq);
 -			refclk = dev_priv->vbt.lvds_ssc_freq;
 -		}
 +	for_each_crtc_in_state(state, crtc, cstate, i) {
 +		int pixel_rate;
  
 -		if (intel_is_dual_link_lvds(dev)) {
 -			if (refclk == 100000)
 -				limit = &intel_limits_ironlake_dual_lvds_100m;
 -			else
 -				limit = &intel_limits_ironlake_dual_lvds;
 -		} else {
 -			if (refclk == 100000)
 -				limit = &intel_limits_ironlake_single_lvds_100m;
 -			else
 -				limit = &intel_limits_ironlake_single_lvds;
 +		crtc_state = to_intel_crtc_state(cstate);
 +		if (!crtc_state->base.enable) {
 +			intel_state->min_pixclk[i] = 0;
 +			continue;
  		}
 -	} else {
 -		limit = &intel_limits_ironlake_dac;
 -	}
  
 -	if (!crtc_state->clock_set &&
 -	    !g4x_find_best_dpll(limit, crtc_state, crtc_state->port_clock,
 -				refclk, NULL, &crtc_state->dpll)) {
 -		DRM_ERROR("Couldn't find PLL settings for mode!\n");
 -		return -EINVAL;
 -	}
 +		pixel_rate = ilk_pipe_pixel_rate(crtc_state);
  
 -	ironlake_compute_dpll(crtc, crtc_state, NULL);
 +		if (IS_BROADWELL(dev_priv) || IS_GEN9(dev_priv))
 +			pixel_rate = bdw_adjust_min_pipe_pixel_rate(crtc_state,
 +								    pixel_rate);
  
 -	if (!intel_get_shared_dpll(crtc, crtc_state, NULL)) {
 -		DRM_DEBUG_DRIVER("failed to find PLL for pipe %c\n",
 -				 pipe_name(crtc->pipe));
 -		return -EINVAL;
 +		intel_state->min_pixclk[i] = pixel_rate;
  	}
  
 -	return 0;
 +	for_each_pipe(dev_priv, pipe)
 +		max_pixel_rate = max(intel_state->min_pixclk[pipe], max_pixel_rate);
 +
 +	return max_pixel_rate;
  }
  
 -static void intel_pch_transcoder_get_m_n(struct intel_crtc *crtc,
 -					 struct intel_link_m_n *m_n)
 +static void broadwell_set_cdclk(struct drm_device *dev, int cdclk)
  {
 -	struct drm_device *dev = crtc->base.dev;
  	struct drm_i915_private *dev_priv = to_i915(dev);
 -	enum pipe pipe = crtc->pipe;
 +	uint32_t val, data;
 +	int ret;
  
 -	m_n->link_m = I915_READ(PCH_TRANS_LINK_M1(pipe));
 -	m_n->link_n = I915_READ(PCH_TRANS_LINK_N1(pipe));
 -	m_n->gmch_m = I915_READ(PCH_TRANS_DATA_M1(pipe))
 -		& ~TU_SIZE_MASK;
 -	m_n->gmch_n = I915_READ(PCH_TRANS_DATA_N1(pipe));
 -	m_n->tu = ((I915_READ(PCH_TRANS_DATA_M1(pipe))
 -		    & TU_SIZE_MASK) >> TU_SIZE_SHIFT) + 1;
 -}
 +	if (WARN((I915_READ(LCPLL_CTL) &
 +		  (LCPLL_PLL_DISABLE | LCPLL_PLL_LOCK |
 +		   LCPLL_CD_CLOCK_DISABLE | LCPLL_ROOT_CD_CLOCK_DISABLE |
 +		   LCPLL_CD2X_CLOCK_DISABLE | LCPLL_POWER_DOWN_ALLOW |
 +		   LCPLL_CD_SOURCE_FCLK)) != LCPLL_PLL_LOCK,
 +		 "trying to change cdclk frequency with cdclk not enabled\n"))
 +		return;
  
 -static void intel_cpu_transcoder_get_m_n(struct intel_crtc *crtc,
 -					 enum transcoder transcoder,
 -					 struct intel_link_m_n *m_n,
 -					 struct intel_link_m_n *m2_n2)
 -{
 -	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
 -	enum pipe pipe = crtc->pipe;
 +	mutex_lock(&dev_priv->rps.hw_lock);
 +	ret = sandybridge_pcode_write(dev_priv,
 +				      BDW_PCODE_DISPLAY_FREQ_CHANGE_REQ, 0x0);
 +	mutex_unlock(&dev_priv->rps.hw_lock);
 +	if (ret) {
 +		DRM_ERROR("failed to inform pcode about cdclk change\n");
 +		return;
 +	}
  
 -	if (INTEL_GEN(dev_priv) >= 5) {
 -		m_n->link_m = I915_READ(PIPE_LINK_M1(transcoder));
 -		m_n->link_n = I915_READ(PIPE_LINK_N1(transcoder));
 -		m_n->gmch_m = I915_READ(PIPE_DATA_M1(transcoder))
 -			& ~TU_SIZE_MASK;
 -		m_n->gmch_n = I915_READ(PIPE_DATA_N1(transcoder));
 -		m_n->tu = ((I915_READ(PIPE_DATA_M1(transcoder))
 -			    & TU_SIZE_MASK) >> TU_SIZE_SHIFT) + 1;
 -		/* Read M2_N2 registers only for gen < 8 (M2_N2 available for
 -		 * gen < 8) and if DRRS is supported (to make sure the
 -		 * registers are not unnecessarily read).
 -		 */
 -		if (m2_n2 && INTEL_GEN(dev_priv) < 8 &&
 -			crtc->config->has_drrs) {
 -			m2_n2->link_m = I915_READ(PIPE_LINK_M2(transcoder));
 -			m2_n2->link_n =	I915_READ(PIPE_LINK_N2(transcoder));
 -			m2_n2->gmch_m =	I915_READ(PIPE_DATA_M2(transcoder))
 -					& ~TU_SIZE_MASK;
 -			m2_n2->gmch_n =	I915_READ(PIPE_DATA_N2(transcoder));
 -			m2_n2->tu = ((I915_READ(PIPE_DATA_M2(transcoder))
 -					& TU_SIZE_MASK) >> TU_SIZE_SHIFT) + 1;
 -		}
 -	} else {
 -		m_n->link_m = I915_READ(PIPE_LINK_M_G4X(pipe));
 -		m_n->link_n = I915_READ(PIPE_LINK_N_G4X(pipe));
 -		m_n->gmch_m = I915_READ(PIPE_DATA_M_G4X(pipe))
 -			& ~TU_SIZE_MASK;
 -		m_n->gmch_n = I915_READ(PIPE_DATA_N_G4X(pipe));
 -		m_n->tu = ((I915_READ(PIPE_DATA_M_G4X(pipe))
 -			    & TU_SIZE_MASK) >> TU_SIZE_SHIFT) + 1;
 +	val = I915_READ(LCPLL_CTL);
 +	val |= LCPLL_CD_SOURCE_FCLK;
 +	I915_WRITE(LCPLL_CTL, val);
 +
 +	if (wait_for_us(I915_READ(LCPLL_CTL) &
 +			LCPLL_CD_SOURCE_FCLK_DONE, 1))
 +		DRM_ERROR("Switching to FCLK failed\n");
 +
 +	val = I915_READ(LCPLL_CTL);
 +	val &= ~LCPLL_CLK_FREQ_MASK;
 +
 +	switch (cdclk) {
 +	case 450000:
 +		val |= LCPLL_CLK_FREQ_450;
 +		data = 0;
 +		break;
 +	case 540000:
 +		val |= LCPLL_CLK_FREQ_54O_BDW;
 +		data = 1;
 +		break;
 +	case 337500:
 +		val |= LCPLL_CLK_FREQ_337_5_BDW;
 +		data = 2;
 +		break;
 +	case 675000:
 +		val |= LCPLL_CLK_FREQ_675_BDW;
 +		data = 3;
 +		break;
 +	default:
 +		WARN(1, "invalid cdclk frequency\n");
 +		return;
  	}
 +
 +	I915_WRITE(LCPLL_CTL, val);
 +
 +	val = I915_READ(LCPLL_CTL);
 +	val &= ~LCPLL_CD_SOURCE_FCLK;
 +	I915_WRITE(LCPLL_CTL, val);
 +
 +	if (wait_for_us((I915_READ(LCPLL_CTL) &
 +			LCPLL_CD_SOURCE_FCLK_DONE) == 0, 1))
 +		DRM_ERROR("Switching back to LCPLL failed\n");
 +
 +	mutex_lock(&dev_priv->rps.hw_lock);
 +	sandybridge_pcode_write(dev_priv, HSW_PCODE_DE_WRITE_FREQ_REQ, data);
 +	mutex_unlock(&dev_priv->rps.hw_lock);
 +
 +	I915_WRITE(CDCLK_FREQ, DIV_ROUND_CLOSEST(cdclk, 1000) - 1);
 +
 +	intel_update_cdclk(dev_priv);
 +
 +	WARN(cdclk != dev_priv->cdclk_freq,
 +	     "cdclk requested %d kHz but got %d kHz\n",
 +	     cdclk, dev_priv->cdclk_freq);
  }
  
 -void intel_dp_get_m_n(struct intel_crtc *crtc,
 -		      struct intel_crtc_state *pipe_config)
 +static int broadwell_calc_cdclk(int max_pixclk)
  {
 -	if (pipe_config->has_pch_encoder)
 -		intel_pch_transcoder_get_m_n(crtc, &pipe_config->dp_m_n);
 +	if (max_pixclk > 540000)
 +		return 675000;
 +	else if (max_pixclk > 450000)
 +		return 540000;
 +	else if (max_pixclk > 337500)
 +		return 450000;
  	else
 -		intel_cpu_transcoder_get_m_n(crtc, pipe_config->cpu_transcoder,
 -					     &pipe_config->dp_m_n,
 -					     &pipe_config->dp_m2_n2);
 +		return 337500;
  }
  
 -static void ironlake_get_fdi_m_n_config(struct intel_crtc *crtc,
 -					struct intel_crtc_state *pipe_config)
 +static int broadwell_modeset_calc_cdclk(struct drm_atomic_state *state)
  {
 -	intel_cpu_transcoder_get_m_n(crtc, pipe_config->cpu_transcoder,
 -				     &pipe_config->fdi_m_n, NULL);
 -}
 +	struct drm_i915_private *dev_priv = to_i915(state->dev);
 +	struct intel_atomic_state *intel_state = to_intel_atomic_state(state);
 +	int max_pixclk = ilk_max_pixel_rate(state);
 +	int cdclk;
  
 -static void skylake_get_pfit_config(struct intel_crtc *crtc,
 -				    struct intel_crtc_state *pipe_config)
 -{
 -	struct drm_device *dev = crtc->base.dev;
 -	struct drm_i915_private *dev_priv = to_i915(dev);
 -	struct intel_crtc_scaler_state *scaler_state = &pipe_config->scaler_state;
 -	uint32_t ps_ctrl = 0;
 -	int id = -1;
 -	int i;
 +	/*
 +	 * FIXME should also account for plane ratio
 +	 * once 64bpp pixel formats are supported.
 +	 */
 +	cdclk = broadwell_calc_cdclk(max_pixclk);
  
 -	/* find scaler attached to this pipe */
 -	for (i = 0; i < crtc->num_scalers; i++) {
 -		ps_ctrl = I915_READ(SKL_PS_CTRL(crtc->pipe, i));
 -		if (ps_ctrl & PS_SCALER_EN && !(ps_ctrl & PS_PLANE_SEL_MASK)) {
 -			id = i;
 -			pipe_config->pch_pfit.enabled = true;
 -			pipe_config->pch_pfit.pos = I915_READ(SKL_PS_WIN_POS(crtc->pipe, i));
 -			pipe_config->pch_pfit.size = I915_READ(SKL_PS_WIN_SZ(crtc->pipe, i));
 -			break;
 -		}
 +	if (cdclk > dev_priv->max_cdclk_freq) {
 +		DRM_DEBUG_KMS("requested cdclk (%d kHz) exceeds max (%d kHz)\n",
 +			      cdclk, dev_priv->max_cdclk_freq);
 +		return -EINVAL;
  	}
  
 -	scaler_state->scaler_id = id;
 -	if (id >= 0) {
 -		scaler_state->scaler_users |= (1 << SKL_CRTC_INDEX);
 -	} else {
 -		scaler_state->scaler_users &= ~(1 << SKL_CRTC_INDEX);
 -	}
 +	intel_state->cdclk = intel_state->dev_cdclk = cdclk;
 +	if (!intel_state->active_crtcs)
 +		intel_state->dev_cdclk = broadwell_calc_cdclk(0);
 +
 +	return 0;
  }
  
 -static void
 -skylake_get_initial_plane_config(struct intel_crtc *crtc,
 -				 struct intel_initial_plane_config *plane_config)
 +static void broadwell_modeset_commit_cdclk(struct drm_atomic_state *old_state)
  {
 -	struct drm_device *dev = crtc->base.dev;
 -	struct drm_i915_private *dev_priv = to_i915(dev);
 -	u32 val, base, offset, stride_mult, tiling;
 -	int pipe = crtc->pipe;
 -	int fourcc, pixel_format;
 -	unsigned int aligned_height;
 -	struct drm_framebuffer *fb;
 -	struct intel_framebuffer *intel_fb;
 +	struct drm_device *dev = old_state->dev;
 +	struct intel_atomic_state *old_intel_state =
 +		to_intel_atomic_state(old_state);
 +	unsigned req_cdclk = old_intel_state->dev_cdclk;
  
 -	intel_fb = kzalloc(sizeof(*intel_fb), GFP_KERNEL);
 -	if (!intel_fb) {
 -		DRM_DEBUG_KMS("failed to alloc fb\n");
 -		return;
 +	broadwell_set_cdclk(dev, req_cdclk);
 +}
 +
 +static int skl_modeset_calc_cdclk(struct drm_atomic_state *state)
 +{
 +	struct intel_atomic_state *intel_state = to_intel_atomic_state(state);
 +	struct drm_i915_private *dev_priv = to_i915(state->dev);
 +	const int max_pixclk = ilk_max_pixel_rate(state);
 +	int vco = intel_state->cdclk_pll_vco;
 +	int cdclk;
 +
 +	/*
 +	 * FIXME should also account for plane ratio
 +	 * once 64bpp pixel formats are supported.
 +	 */
 +	cdclk = skl_calc_cdclk(max_pixclk, vco);
 +
 +	/*
 +	 * FIXME move the cdclk caclulation to
 +	 * compute_config() so we can fail gracegully.
 +	 */
 +	if (cdclk > dev_priv->max_cdclk_freq) {
 +		DRM_ERROR("requested cdclk (%d kHz) exceeds max (%d kHz)\n",
 +			  cdclk, dev_priv->max_cdclk_freq);
 +		cdclk = dev_priv->max_cdclk_freq;
  	}
  
 -	fb = &intel_fb->base;
 +	intel_state->cdclk = intel_state->dev_cdclk = cdclk;
 +	if (!intel_state->active_crtcs)
 +		intel_state->dev_cdclk = skl_calc_cdclk(0, vco);
  
 -	fb->dev = dev;
 +	return 0;
 +}
  
 -	val = I915_READ(PLANE_CTL(pipe, 0));
 -	if (!(val & PLANE_CTL_ENABLE))
 -		goto error;
 +static void skl_modeset_commit_cdclk(struct drm_atomic_state *old_state)
 +{
 +	struct drm_i915_private *dev_priv = to_i915(old_state->dev);
 +	struct intel_atomic_state *intel_state = to_intel_atomic_state(old_state);
 +	unsigned int req_cdclk = intel_state->dev_cdclk;
 +	unsigned int req_vco = intel_state->cdclk_pll_vco;
  
 -	pixel_format = val & PLANE_CTL_FORMAT_MASK;
 -	fourcc = skl_format_to_fourcc(pixel_format,
 -				      val & PLANE_CTL_ORDER_RGBX,
 -				      val & PLANE_CTL_ALPHA_MASK);
 -	fb->format = drm_format_info(fourcc);
 +	skl_set_cdclk(dev_priv, req_cdclk, req_vco);
 +}
  
 -	tiling = val & PLANE_CTL_TILED_MASK;
 -	switch (tiling) {
 -	case PLANE_CTL_TILED_LINEAR:
 -		fb->modifier = DRM_FORMAT_MOD_LINEAR;
 -		break;
 -	case PLANE_CTL_TILED_X:
 -		plane_config->tiling = I915_TILING_X;
 -		fb->modifier = I915_FORMAT_MOD_X_TILED;
 -		break;
 -	case PLANE_CTL_TILED_Y:
 -		if (val & PLANE_CTL_DECOMPRESSION_ENABLE)
 -			fb->modifier = I915_FORMAT_MOD_Y_TILED_CCS;
 -		else
 -			fb->modifier = I915_FORMAT_MOD_Y_TILED;
 -		break;
 -	case PLANE_CTL_TILED_YF:
 -		if (val & PLANE_CTL_DECOMPRESSION_ENABLE)
 -			fb->modifier = I915_FORMAT_MOD_Yf_TILED_CCS;
 -		else
 -			fb->modifier = I915_FORMAT_MOD_Yf_TILED;
 -		break;
 -	default:
 -		MISSING_CASE(tiling);
 -		goto error;
 +static int haswell_crtc_compute_clock(struct intel_crtc *crtc,
 +				      struct intel_crtc_state *crtc_state)
 +{
 +	if (!intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DSI)) {
 +		if (!intel_ddi_pll_select(crtc, crtc_state))
 +			return -EINVAL;
  	}
  
 -	base = I915_READ(PLANE_SURF(pipe, 0)) & 0xfffff000;
 -	plane_config->base = base;
 +	crtc->lowfreq_avail = false;
  
 -	offset = I915_READ(PLANE_OFFSET(pipe, 0));
 +	return 0;
 +}
  
 -	val = I915_READ(PLANE_SIZE(pipe, 0));
 -	fb->height = ((val >> 16) & 0xfff) + 1;
 -	fb->width = ((val >> 0) & 0x1fff) + 1;
++<<<<<<< HEAD
++=======
++static void cannonlake_get_ddi_pll(struct drm_i915_private *dev_priv,
++				   enum port port,
++				   struct intel_crtc_state *pipe_config)
++{
++	enum intel_dpll_id id;
++	u32 temp;
+ 
 -	val = I915_READ(PLANE_STRIDE(pipe, 0));
 -	stride_mult = intel_fb_stride_alignment(fb, 0);
 -	fb->pitches[0] = (val & 0x3ff) * stride_mult;
++	temp = I915_READ(DPCLKA_CFGCR0) & DPCLKA_CFGCR0_DDI_CLK_SEL_MASK(port);
++	id = temp >> DPCLKA_CFGCR0_DDI_CLK_SEL_SHIFT(port);
+ 
 -	aligned_height = intel_fb_align_height(fb, 0, fb->height);
++	if (WARN_ON(id < SKL_DPLL0 || id > SKL_DPLL2))
++		return;
+ 
 -	plane_config->size = fb->pitches[0] * aligned_height;
++	pipe_config->shared_dpll = intel_get_shared_dpll_by_id(dev_priv, id);
++}
+ 
 -	DRM_DEBUG_KMS("pipe %c with fb: size=%dx%d@%d, offset=%x, pitch %d, size 0x%x\n",
 -		      pipe_name(pipe), fb->width, fb->height,
 -		      fb->format->cpp[0] * 8, base, fb->pitches[0],
 -		      plane_config->size);
++>>>>>>> dfbd45083262 (drm/i915/cnl: don't hardcode DPCLKA_CFGCR0_DDI_CLK_SEL_SHIFT)
 +static void bxt_get_ddi_pll(struct drm_i915_private *dev_priv,
 +				enum port port,
 +				struct intel_crtc_state *pipe_config)
 +{
 +	enum intel_dpll_id id;
  
 -	plane_config->fb = intel_fb;
 -	return;
 +	switch (port) {
 +	case PORT_A:
 +		id = DPLL_ID_SKL_DPLL0;
 +		break;
 +	case PORT_B:
 +		id = DPLL_ID_SKL_DPLL1;
 +		break;
 +	case PORT_C:
 +		id = DPLL_ID_SKL_DPLL2;
 +		break;
 +	default:
 +		DRM_ERROR("Incorrect port type\n");
 +		return;
 +	}
  
 -error:
 -	kfree(intel_fb);
 +	pipe_config->shared_dpll = intel_get_shared_dpll_by_id(dev_priv, id);
  }
  
 -static void ironlake_get_pfit_config(struct intel_crtc *crtc,
 -				     struct intel_crtc_state *pipe_config)
 +static void skylake_get_ddi_pll(struct drm_i915_private *dev_priv,
 +				enum port port,
 +				struct intel_crtc_state *pipe_config)
  {
 -	struct drm_device *dev = crtc->base.dev;
 -	struct drm_i915_private *dev_priv = to_i915(dev);
 -	uint32_t tmp;
 +	enum intel_dpll_id id;
 +	u32 temp;
  
 -	tmp = I915_READ(PF_CTL(crtc->pipe));
 +	temp = I915_READ(DPLL_CTRL2) & DPLL_CTRL2_DDI_CLK_SEL_MASK(port);
 +	id = temp >> (port * 3 + 1);
  
 -	if (tmp & PF_ENABLE) {
 -		pipe_config->pch_pfit.enabled = true;
 -		pipe_config->pch_pfit.pos = I915_READ(PF_WIN_POS(crtc->pipe));
 -		pipe_config->pch_pfit.size = I915_READ(PF_WIN_SZ(crtc->pipe));
 +	if (WARN_ON(id < SKL_DPLL0 || id > SKL_DPLL3))
 +		return;
  
 -		/* We currently do not free assignements of panel fitters on
 -		 * ivb/hsw (since we don't use the higher upscaling modes which
 -		 * differentiates them) so just WARN about this case for now. */
 -		if (IS_GEN7(dev_priv)) {
 -			WARN_ON((tmp & PF_PIPE_SEL_MASK_IVB) !=
 -				PF_PIPE_SEL_IVB(crtc->pipe));
 -		}
 +	pipe_config->shared_dpll = intel_get_shared_dpll_by_id(dev_priv, id);
 +}
 +
 +static void haswell_get_ddi_pll(struct drm_i915_private *dev_priv,
 +				enum port port,
 +				struct intel_crtc_state *pipe_config)
 +{
 +	enum intel_dpll_id id;
 +	uint32_t ddi_pll_sel = I915_READ(PORT_CLK_SEL(port));
 +
 +	switch (ddi_pll_sel) {
 +	case PORT_CLK_SEL_WRPLL1:
 +		id = DPLL_ID_WRPLL1;
 +		break;
 +	case PORT_CLK_SEL_WRPLL2:
 +		id = DPLL_ID_WRPLL2;
 +		break;
 +	case PORT_CLK_SEL_SPLL:
 +		id = DPLL_ID_SPLL;
 +		break;
 +	case PORT_CLK_SEL_LCPLL_810:
 +		id = DPLL_ID_LCPLL_810;
 +		break;
 +	case PORT_CLK_SEL_LCPLL_1350:
 +		id = DPLL_ID_LCPLL_1350;
 +		break;
 +	case PORT_CLK_SEL_LCPLL_2700:
 +		id = DPLL_ID_LCPLL_2700;
 +		break;
 +	default:
 +		MISSING_CASE(ddi_pll_sel);
 +		/* fall through */
 +	case PORT_CLK_SEL_NONE:
 +		return;
  	}
 +
 +	pipe_config->shared_dpll = intel_get_shared_dpll_by_id(dev_priv, id);
  }
  
 -static void
 -ironlake_get_initial_plane_config(struct intel_crtc *crtc,
 -				  struct intel_initial_plane_config *plane_config)
 +static bool hsw_get_transcoder_state(struct intel_crtc *crtc,
 +				     struct intel_crtc_state *pipe_config,
 +				     unsigned long *power_domain_mask)
  {
  	struct drm_device *dev = crtc->base.dev;
  	struct drm_i915_private *dev_priv = to_i915(dev);
* Unmerged path drivers/gpu/drm/i915/intel_display.c
