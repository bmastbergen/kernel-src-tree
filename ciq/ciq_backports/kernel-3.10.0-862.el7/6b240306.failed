selinux: Perform both commoncap and selinux xattr checks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit 6b240306ee1631587a87845127824df54a0a5abe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/6b240306.failed

When selinux is loaded the relax permission checks for writing
security.capable are not honored.  Which keeps file capabilities
from being used in user namespaces.

Stephen Smalley <sds@tycho.nsa.gov> writes:
> Originally SELinux called the cap functions directly since there was no
> stacking support in the infrastructure and one had to manually stack a
> secondary module internally.  inode_setxattr and inode_removexattr
> however were special cases because the cap functions would check
> CAP_SYS_ADMIN for any non-capability attributes in the security.*
> namespace, and we don't want to impose that requirement on setting
> security.selinux.  Thus, we inlined the capabilities logic into the
> selinux hook functions and adapted it appropriately.

Now that the permission checks in commoncap have evolved this
inlining of their contents has become a problem.  So restructure
selinux_inode_removexattr, and selinux_inode_setxattr to call
both the corresponding cap_inode_ function and dentry_has_perm
when the attribute is not a selinux security xattr.   This ensures
the policies of both commoncap and selinux are enforced.

This results in smack and selinux having the same basic structure
for setxattr and removexattr.  Performing their own special permission
checks when it is their modules xattr being written to, and deferring
to commoncap when that is not the case.  Then finally performing their
generic module policy on all xattr writes.

This structure is fine when you only consider stacking with the
commoncap lsm, but it becomes a problem if two lsms that don't want
the commoncap security checks on their own attributes need to be
stack.  This means there will need to be updates in the future as lsm
stacking is improved, but at least now the structure between smack and
selinux is common making the code easier to refactor.

This change also has the effect that selinux_linux_setotherxattr becomes
unnecessary so it is removed.

Fixes: 8db6c34f1dbc ("Introduce v3 namespaced file capabilities")
Fixes: 7bbf0e052b76 ("[PATCH] selinux merge")
Historical Tree: https://git.kernel.org/pub/scm/linux/kernel/git/tglx/history.git
	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
	Reviewed-by: Serge Hallyn <serge@hallyn.com>
	Acked-by: Stephen Smalley <sds@tycho.nsa.gov>
	Signed-off-by: Paul Moore <paul@paul-moore.com>
(cherry picked from commit 6b240306ee1631587a87845127824df54a0a5abe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/selinux/hooks.c
diff --cc security/selinux/hooks.c
index 7c150cbbfbc6,c78dbec627f6..000000000000
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@@ -2995,36 -3119,21 +2995,49 @@@ static int selinux_inode_setattr(struc
  	return dentry_has_perm(cred, dentry, av);
  }
  
 -static int selinux_inode_getattr(const struct path *path)
 +static int selinux_inode_getattr(struct vfsmount *mnt, struct dentry *dentry)
  {
 -	return path_has_perm(current_cred(), path, FILE__GETATTR);
 +	const struct cred *cred = current_cred();
 +	struct path path;
 +
 +	path.dentry = dentry;
 +	path.mnt = mnt;
 +
 +	return path_has_perm(cred, &path, FILE__GETATTR);
  }
  
++<<<<<<< HEAD
 +static int selinux_inode_setotherxattr(struct dentry *dentry, const char *name)
 +{
 +	const struct cred *cred = current_cred();
 +
 +	if (!strncmp(name, XATTR_SECURITY_PREFIX,
 +		     sizeof XATTR_SECURITY_PREFIX - 1)) {
 +		if (!strcmp(name, XATTR_NAME_CAPS)) {
 +			if (!capable(CAP_SETFCAP))
 +				return -EPERM;
 +		} else if (!capable(CAP_SYS_ADMIN)) {
 +			/* A different attribute in the security namespace.
 +			   Restrict to administrator. */
 +			return -EPERM;
 +		}
 +	}
 +
 +	/* Not an attribute we recognize, so just check the
 +	   ordinary setattr permission. */
 +	return dentry_has_perm(cred, dentry, FILE__SETATTR);
++=======
+ static bool has_cap_mac_admin(bool audit)
+ {
+ 	const struct cred *cred = current_cred();
+ 	int cap_audit = audit ? SECURITY_CAP_AUDIT : SECURITY_CAP_NOAUDIT;
+ 
+ 	if (cap_capable(cred, &init_user_ns, CAP_MAC_ADMIN, cap_audit))
+ 		return false;
+ 	if (cred_has_capability(cred, CAP_MAC_ADMIN, cap_audit, true))
+ 		return false;
+ 	return true;
++>>>>>>> 6b240306ee16 (selinux: Perform both commoncap and selinux xattr checks)
  }
  
  static int selinux_inode_setxattr(struct dentry *dentry, const char *name,
@@@ -3037,11 -3146,18 +3050,18 @@@
  	u32 newsid, sid = current_sid();
  	int rc = 0;
  
- 	if (strcmp(name, XATTR_NAME_SELINUX))
- 		return selinux_inode_setotherxattr(dentry, name);
+ 	if (strcmp(name, XATTR_NAME_SELINUX)) {
+ 		rc = cap_inode_setxattr(dentry, name, value, size, flags);
+ 		if (rc)
+ 			return rc;
+ 
+ 		/* Not an attribute we recognize, so just check the
+ 		   ordinary setattr permission. */
+ 		return dentry_has_perm(current_cred(), dentry, FILE__SETATTR);
+ 	}
  
  	sbsec = inode->i_sb->s_security;
 -	if (!(sbsec->flags & SBLABEL_MNT))
 +	if (!(sbsec->flags & SE_SBLABELSUPP))
  		return -EOPNOTSUPP;
  
  	if (!inode_owner_or_capable(inode))
* Unmerged path security/selinux/hooks.c
