x86/cpu/AMD: Add the Secure Memory Encryption CPU feature

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] cpu/amd: Add the Secure Memory Encryption CPU feature (Suravee Suthikulpanit) [1361287]
Rebuild_FUZZ: 96.36%
commit-author Tom Lendacky <thomas.lendacky@amd.com>
commit 872cbefd2d9c52bd0b1e2c7942c4369e98a5a5ae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/872cbefd.failed

Update the CPU features to include identifying and reporting on the
Secure Memory Encryption (SME) feature.  SME is identified by CPUID
0x8000001f, but requires BIOS support to enable it (set bit 23 of
MSR_K8_SYSCFG).  Only show the SME feature as available if reported by
CPUID, enabled by BIOS and not configured as CONFIG_X86_32=y.

	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
	Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: Alexander Potapenko <glider@google.com>
	Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Arnd Bergmann <arnd@arndb.de>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brijesh Singh <brijesh.singh@amd.com>
	Cc: Dave Young <dyoung@redhat.com>
	Cc: Dmitry Vyukov <dvyukov@google.com>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
	Cc: Larry Woodman <lwoodman@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Matt Fleming <matt@codeblueprint.co.uk>
	Cc: Michael S. Tsirkin <mst@redhat.com>
	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Radim Krčmář <rkrcmar@redhat.com>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Toshimitsu Kani <toshi.kani@hpe.com>
	Cc: kasan-dev@googlegroups.com
	Cc: kvm@vger.kernel.org
	Cc: linux-arch@vger.kernel.org
	Cc: linux-doc@vger.kernel.org
	Cc: linux-efi@vger.kernel.org
	Cc: linux-mm@kvack.org
Link: http://lkml.kernel.org/r/85c17ff450721abccddc95e611ae8df3f4d9718b.1500319216.git.thomas.lendacky@amd.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 872cbefd2d9c52bd0b1e2c7942c4369e98a5a5ae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/cpufeatures.h
#	arch/x86/kernel/cpu/amd.c
#	arch/x86/kernel/cpu/scattered.c
diff --cc arch/x86/kernel/cpu/amd.c
index 485733876ab9,5ccc7b2e63bb..000000000000
--- a/arch/x86/kernel/cpu/amd.c
+++ b/arch/x86/kernel/cpu/amd.c
@@@ -545,26 -578,85 +545,68 @@@ static void early_init_amd(struct cpuin
  	 * can safely set X86_FEATURE_EXTD_APICID unconditionally for families
  	 * after 16h.
  	 */
 -	if (boot_cpu_has(X86_FEATURE_APIC)) {
 -		if (c->x86 > 0x16)
 +	if (cpu_has_apic && c->x86 > 0x16) {
 +		set_cpu_cap(c, X86_FEATURE_EXTD_APICID);
 +	} else if (cpu_has_apic && c->x86 >= 0xf) {
 +		/* check CPU config space for extended APIC ID */
 +		unsigned int val;
 +		val = read_pci_config(0, 24, 0, 0x68);
 +		if ((val & ((1 << 17) | (1 << 18))) == ((1 << 17) | (1 << 18)))
  			set_cpu_cap(c, X86_FEATURE_EXTD_APICID);
 -		else if (c->x86 >= 0xf) {
 -			/* check CPU config space for extended APIC ID */
 -			unsigned int val;
 -
 -			val = read_pci_config(0, 24, 0, 0x68);
 -			if ((val >> 17 & 0x3) == 0x3)
 -				set_cpu_cap(c, X86_FEATURE_EXTD_APICID);
 -		}
  	}
  #endif
++<<<<<<< HEAD
++=======
+ 
+ 	/*
+ 	 * This is only needed to tell the kernel whether to use VMCALL
+ 	 * and VMMCALL.  VMMCALL is never executed except under virt, so
+ 	 * we can set it unconditionally.
+ 	 */
+ 	set_cpu_cap(c, X86_FEATURE_VMMCALL);
+ 
+ 	/* F16h erratum 793, CVE-2013-6885 */
+ 	if (c->x86 == 0x16 && c->x86_model <= 0xf)
+ 		msr_set_bit(MSR_AMD64_LS_CFG, 15);
+ 
+ 	/*
+ 	 * Check whether the machine is affected by erratum 400. This is
+ 	 * used to select the proper idle routine and to enable the check
+ 	 * whether the machine is affected in arch_post_acpi_init(), which
+ 	 * sets the X86_BUG_AMD_APIC_C1E bug depending on the MSR check.
+ 	 */
+ 	if (cpu_has_amd_erratum(c, amd_erratum_400))
+ 		set_cpu_bug(c, X86_BUG_AMD_E400);
+ 
+ 	/*
+ 	 * BIOS support is required for SME. If BIOS has not enabled SME
+ 	 * then don't advertise the feature (set in scattered.c). Also,
+ 	 * since the SME support requires long mode, don't advertise the
+ 	 * feature under CONFIG_X86_32.
+ 	 */
+ 	if (cpu_has(c, X86_FEATURE_SME)) {
+ 		if (IS_ENABLED(CONFIG_X86_32)) {
+ 			clear_cpu_cap(c, X86_FEATURE_SME);
+ 		} else {
+ 			u64 msr;
+ 
+ 			/* Check if SME is enabled */
+ 			rdmsrl(MSR_K8_SYSCFG, msr);
+ 			if (!(msr & MSR_K8_SYSCFG_MEM_ENCRYPT))
+ 				clear_cpu_cap(c, X86_FEATURE_SME);
+ 		}
+ 	}
++>>>>>>> 872cbefd2d9c (x86/cpu/AMD: Add the Secure Memory Encryption CPU feature)
  }
  
 -static void init_amd_k8(struct cpuinfo_x86 *c)
 -{
 -	u32 level;
 -	u64 value;
 -
 -	/* On C+ stepping K8 rep microcode works well for copy/memset */
 -	level = cpuid_eax(1);
 -	if ((level >= 0x0f48 && level < 0x0f50) || level >= 0x0f58)
 -		set_cpu_cap(c, X86_FEATURE_REP_GOOD);
 -
 -	/*
 -	 * Some BIOSes incorrectly force this feature, but only K8 revision D
 -	 * (model = 0x14) and later actually support it.
 -	 * (AMD Erratum #110, docId: 25759).
 -	 */
 -	if (c->x86_model < 0x14 && cpu_has(c, X86_FEATURE_LAHF_LM)) {
 -		clear_cpu_cap(c, X86_FEATURE_LAHF_LM);
 -		if (!rdmsrl_amd_safe(0xc001100d, &value)) {
 -			value &= ~BIT_64(32);
 -			wrmsrl_amd_safe(0xc001100d, value);
 -		}
 -	}
 +static const int amd_erratum_383[];
 +static const int amd_erratum_400[];
 +static bool cpu_has_amd_erratum(struct cpuinfo_x86 *cpu, const int *erratum);
  
 -	if (!c->x86_model_id[0])
 -		strcpy(c->x86_model_id, "Hammer");
 +static void init_amd(struct cpuinfo_x86 *c)
 +{
 +	u32 dummy;
 +	unsigned long long value;
  
  #ifdef CONFIG_SMP
  	/*
diff --cc arch/x86/kernel/cpu/scattered.c
index 1f6b3fec429c,05459ad3db46..000000000000
--- a/arch/x86/kernel/cpu/scattered.c
+++ b/arch/x86/kernel/cpu/scattered.c
@@@ -19,22 -19,22 +19,39 @@@ struct cpuid_bit 
  
  /* Please keep the leaf sorted by cpuid_bit.level for faster search. */
  static const struct cpuid_bit cpuid_bits[] = {
++<<<<<<< HEAD
 +	{ X86_FEATURE_INTEL_PT,		CPUID_EBX,25, 0x00000007, 0 },
 +	{ X86_FEATURE_AVX512_4VNNIW,	CPUID_EDX, 2, 0x00000007, 0 },
 +	{ X86_FEATURE_AVX512_4FMAPS,	CPUID_EDX, 3, 0x00000007, 0 },
 +	{ X86_FEATURE_APERFMPERF,	CPUID_ECX, 0, 0x00000006, 0 },
 +	{ X86_FEATURE_EPB,		CPUID_ECX, 3, 0x00000006, 0 },
 +	{ X86_FEATURE_CAT_L3,		CPUID_EBX, 1, 0x00000010, 0 },
 +	{ X86_FEATURE_CAT_L2,		CPUID_EBX, 2, 0x00000010, 0 },
 +	{ X86_FEATURE_CDP_L3,		CPUID_ECX, 2, 0x00000010, 1 },
 +	{ X86_FEATURE_HW_PSTATE,	CPUID_EDX, 7, 0x80000007, 0 },
 +	{ X86_FEATURE_CPB,		CPUID_EDX, 9, 0x80000007, 0 },
 +	{ X86_FEATURE_PROC_FEEDBACK,	CPUID_EDX,11, 0x80000007, 0 },
 +	{ X86_FEATURE_AVIC,       	CPUID_EDX,13, 0x8000000a, 0 },
 +	{ 0, 0, 0, 0 }
++=======
+ 	{ X86_FEATURE_APERFMPERF,       CPUID_ECX,  0, 0x00000006, 0 },
+ 	{ X86_FEATURE_EPB,		CPUID_ECX,  3, 0x00000006, 0 },
+ 	{ X86_FEATURE_INTEL_PT,		CPUID_EBX, 25, 0x00000007, 0 },
+ 	{ X86_FEATURE_AVX512_4VNNIW,    CPUID_EDX,  2, 0x00000007, 0 },
+ 	{ X86_FEATURE_AVX512_4FMAPS,    CPUID_EDX,  3, 0x00000007, 0 },
+ 	{ X86_FEATURE_CAT_L3,		CPUID_EBX,  1, 0x00000010, 0 },
+ 	{ X86_FEATURE_CAT_L2,		CPUID_EBX,  2, 0x00000010, 0 },
+ 	{ X86_FEATURE_CDP_L3,		CPUID_ECX,  2, 0x00000010, 1 },
+ 	{ X86_FEATURE_MBA,		CPUID_EBX,  3, 0x00000010, 0 },
+ 	{ X86_FEATURE_HW_PSTATE,	CPUID_EDX,  7, 0x80000007, 0 },
+ 	{ X86_FEATURE_CPB,		CPUID_EDX,  9, 0x80000007, 0 },
+ 	{ X86_FEATURE_PROC_FEEDBACK,    CPUID_EDX, 11, 0x80000007, 0 },
+ 	{ X86_FEATURE_SME,		CPUID_EAX,  0, 0x8000001f, 0 },
+ 	{ 0, 0, 0, 0, 0 }
++>>>>>>> 872cbefd2d9c (x86/cpu/AMD: Add the Secure Memory Encryption CPU feature)
  };
  
 +
  void init_scattered_cpuid_features(struct cpuinfo_x86 *c)
  {
  	u32 max_level;
* Unmerged path arch/x86/include/asm/cpufeatures.h
* Unmerged path arch/x86/include/asm/cpufeatures.h
diff --git a/arch/x86/include/asm/msr-index.h b/arch/x86/include/asm/msr-index.h
index 300680defb07..a1be3d9fa800 100644
--- a/arch/x86/include/asm/msr-index.h
+++ b/arch/x86/include/asm/msr-index.h
@@ -337,6 +337,8 @@
 #define MSR_K8_TOP_MEM1			0xc001001a
 #define MSR_K8_TOP_MEM2			0xc001001d
 #define MSR_K8_SYSCFG			0xc0010010
+#define MSR_K8_SYSCFG_MEM_ENCRYPT_BIT	23
+#define MSR_K8_SYSCFG_MEM_ENCRYPT	BIT_ULL(MSR_K8_SYSCFG_MEM_ENCRYPT_BIT)
 #define MSR_K8_INT_PENDING_MSG		0xc0010055
 /* C1E active bits in int pending message */
 #define K8_INTP_C1E_ACTIVE_MASK		0x18000000
* Unmerged path arch/x86/kernel/cpu/amd.c
* Unmerged path arch/x86/kernel/cpu/scattered.c
