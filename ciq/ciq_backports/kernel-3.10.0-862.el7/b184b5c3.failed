NFS: remove l_pid field from nfs_lockowner

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author NeilBrown <neilb@suse.com>
commit b184b5c38e4640585126e44ef84f2dbdd0d23d5a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b184b5c3.failed

this field is not used in any important way and probably should
have been removed by

Commit: 8003d3c4aaa5 ("nfs4: treat lock owners as opaque values")

which removed the pid argument from nfs4_get_lock_state.

Except in unusual and uninteresting cases, two threads with the same
->tgid will have the same ->files pointer, so keeping them both
for comparison brings no benefit.

	Acked-by: Jeff Layton <jlayton@redhat.com>
	Signed-off-by: NeilBrown <neilb@suse.com>
	Reviewed-by: Jeff Layton <jlayton@redhat.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit b184b5c38e4640585126e44ef84f2dbdd0d23d5a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/write.c
diff --cc fs/nfs/write.c
index eaf2c888228d,4d5897e6d6cb..000000000000
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@@ -1159,9 -1148,10 +1159,16 @@@ int nfs_flush_incompatible(struct file 
  			!nfs_match_open_context(req->wb_context, ctx);
  		/* for now, flush if more than 1 request in page_group */
  		do_flush |= req->wb_this_page != req;
++<<<<<<< HEAD
 +		if (l_ctx && ctx->dentry->d_inode->i_flock != NULL) {
 +			do_flush |= l_ctx->lockowner.l_owner != current->files
 +				|| l_ctx->lockowner.l_pid != current->tgid;
++=======
+ 		if (l_ctx && flctx &&
+ 		    !(list_empty_careful(&flctx->flc_posix) &&
+ 		      list_empty_careful(&flctx->flc_flock))) {
+ 			do_flush |= l_ctx->lockowner.l_owner != current->files;
++>>>>>>> b184b5c38e46 (NFS: remove l_pid field from nfs_lockowner)
  		}
  		nfs_release_request(req);
  		if (!do_flush)
diff --git a/fs/nfs/inode.c b/fs/nfs/inode.c
index b119f0855a0c..2a8b69ec310e 100644
--- a/fs/nfs/inode.c
+++ b/fs/nfs/inode.c
@@ -718,7 +718,6 @@ static void nfs_init_lock_context(struct nfs_lock_context *l_ctx)
 {
 	atomic_set(&l_ctx->count, 1);
 	l_ctx->lockowner.l_owner = current->files;
-	l_ctx->lockowner.l_pid = current->tgid;
 	INIT_LIST_HEAD(&l_ctx->list);
 	atomic_set(&l_ctx->io_count, 0);
 }
@@ -731,8 +730,6 @@ static struct nfs_lock_context *__nfs_find_lock_context(struct nfs_open_context
 	do {
 		if (pos->lockowner.l_owner != current->files)
 			continue;
-		if (pos->lockowner.l_pid != current->tgid)
-			continue;
 		atomic_inc(&pos->count);
 		return pos;
 	} while ((pos = list_entry(pos->list.next, typeof(*pos), list)) != head);
diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index b211a49fc834..824947cac862 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -2914,7 +2914,6 @@ static int _nfs4_do_setattr(struct inode *inode,
 	} else if (truncate && state != NULL) {
 		struct nfs_lockowner lockowner = {
 			.l_owner = current->files,
-			.l_pid = current->tgid,
 		};
 		if (!nfs4_valid_open_stateid(state))
 			return -EBADF;
diff --git a/fs/nfs/pagelist.c b/fs/nfs/pagelist.c
index 6d9352499b7b..f836331a943f 100644
--- a/fs/nfs/pagelist.c
+++ b/fs/nfs/pagelist.c
@@ -899,8 +899,7 @@ static void nfs_pageio_cleanup_mirroring(struct nfs_pageio_descriptor *pgio)
 static bool nfs_match_lock_context(const struct nfs_lock_context *l1,
 		const struct nfs_lock_context *l2)
 {
-	return l1->lockowner.l_owner == l2->lockowner.l_owner
-		&& l1->lockowner.l_pid == l2->lockowner.l_pid;
+	return l1->lockowner.l_owner == l2->lockowner.l_owner;
 }
 
 /**
* Unmerged path fs/nfs/write.c
diff --git a/include/linux/nfs_fs.h b/include/linux/nfs_fs.h
index e7af49321e86..57a5cc14cfe1 100644
--- a/include/linux/nfs_fs.h
+++ b/include/linux/nfs_fs.h
@@ -57,7 +57,6 @@ struct nfs_access_entry {
 
 struct nfs_lockowner {
 	fl_owner_t l_owner;
-	pid_t l_pid;
 };
 
 struct nfs_lock_context {
