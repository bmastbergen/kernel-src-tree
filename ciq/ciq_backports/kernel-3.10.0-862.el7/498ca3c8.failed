IB/core: Avoid accessing non-allocated memory when inferring port type

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Noa Osherovich <noaos@mellanox.com>
commit 498ca3c82a7b11e152a46c253f6b2087c929ce00
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/498ca3c8.failed

Commit 44c58487d51a ("IB/core: Define 'ib' and 'roce' rdma_ah_attr types")
introduced the concept of type in ah_attr:
 * During ib_register_device, each port is checked for its type which
   is stored in ib_device's port_immutable array.
 * During uverbs' modify_qp, the type is inferred using the port number
   in ib_uverbs_qp_dest struct (address vector) by accessing the
   relevant port_immutable array and the type is passed on to
   providers.

IB spec (version 1.3) enforces a valid port value only in Reset to
Init. During Init to RTR, the address vector must be valid but port
number is not mentioned as a field in the address vector, so its
value is not validated, which leads to accesses to a non-allocated
memory when inferring the port type.

Save the real port number in ib_qp during modify to Init (when the
comp_mask indicates that the port number is valid) and use this value
to infer the port type.

Avoid copying the address vector fields if the matching bit is not set
in the attr_mask. Address vector can't be modified before the port, so
no valid flow is affected.

Fixes: 44c58487d51a ('IB/core: Define 'ib' and 'roce' rdma_ah_attr types')
	Signed-off-by: Noa Osherovich <noaos@mellanox.com>
	Reviewed-by: Yishai Hadas <yishaih@mellanox.com>
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 498ca3c82a7b11e152a46c253f6b2087c929ce00)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_cmd.c
#	drivers/infiniband/core/verbs.c
#	include/rdma/ib_verbs.h
diff --cc drivers/infiniband/core/uverbs_cmd.c
index 13d0ebb47014,739bd69ef1d4..000000000000
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@@ -2380,62 -1963,57 +2381,74 @@@ static int modify_qp(struct ib_uverbs_f
  	attr->alt_timeout	  = cmd->base.alt_timeout;
  	attr->rate_limit	  = cmd->rate_limit;
  
++<<<<<<< HEAD
++=======
+ 	if (cmd->base.attr_mask & IB_QP_AV)
+ 		attr->ah_attr.type = rdma_ah_find_type(qp->device,
+ 						       cmd->base.dest.port_num);
++>>>>>>> 498ca3c82a7b (IB/core: Avoid accessing non-allocated memory when inferring port type)
  	if (cmd->base.dest.is_global) {
 -		rdma_ah_set_grh(&attr->ah_attr, NULL,
 -				cmd->base.dest.flow_label,
 -				cmd->base.dest.sgid_index,
 -				cmd->base.dest.hop_limit,
 -				cmd->base.dest.traffic_class);
 -		rdma_ah_set_dgid_raw(&attr->ah_attr, cmd->base.dest.dgid);
 +		memcpy(attr->ah_attr.grh.dgid.raw, cmd->base.dest.dgid, 16);
 +		attr->ah_attr.grh.flow_label	= cmd->base.dest.flow_label;
 +		attr->ah_attr.grh.sgid_index	= cmd->base.dest.sgid_index;
 +		attr->ah_attr.grh.hop_limit	= cmd->base.dest.hop_limit;
 +		attr->ah_attr.grh.traffic_class	= cmd->base.dest.traffic_class;
 +		attr->ah_attr.ah_flags		= IB_AH_GRH;
  	} else {
 -		rdma_ah_set_ah_flags(&attr->ah_attr, 0);
 +		attr->ah_attr.ah_flags = 0;
  	}
 -	rdma_ah_set_dlid(&attr->ah_attr, cmd->base.dest.dlid);
 -	rdma_ah_set_sl(&attr->ah_attr, cmd->base.dest.sl);
 -	rdma_ah_set_path_bits(&attr->ah_attr, cmd->base.dest.src_path_bits);
 -	rdma_ah_set_static_rate(&attr->ah_attr, cmd->base.dest.static_rate);
 -	rdma_ah_set_port_num(&attr->ah_attr,
 -			     cmd->base.dest.port_num);
 -
 +	attr->ah_attr.dlid		= cmd->base.dest.dlid;
 +	attr->ah_attr.sl		= cmd->base.dest.sl;
 +	attr->ah_attr.src_path_bits	= cmd->base.dest.src_path_bits;
 +	attr->ah_attr.static_rate	= cmd->base.dest.static_rate;
 +	attr->ah_attr.port_num		= cmd->base.dest.port_num;
 +
++<<<<<<< HEAD
++=======
+ 	if (cmd->base.attr_mask & IB_QP_ALT_PATH)
+ 		attr->alt_ah_attr.type =
+ 			rdma_ah_find_type(qp->device, cmd->base.dest.port_num);
++>>>>>>> 498ca3c82a7b (IB/core: Avoid accessing non-allocated memory when inferring port type)
  	if (cmd->base.alt_dest.is_global) {
 -		rdma_ah_set_grh(&attr->alt_ah_attr, NULL,
 -				cmd->base.alt_dest.flow_label,
 -				cmd->base.alt_dest.sgid_index,
 -				cmd->base.alt_dest.hop_limit,
 -				cmd->base.alt_dest.traffic_class);
 -		rdma_ah_set_dgid_raw(&attr->alt_ah_attr,
 -				     cmd->base.alt_dest.dgid);
 +		memcpy(attr->alt_ah_attr.grh.dgid.raw,
 +		       cmd->base.alt_dest.dgid, 16);
 +		attr->alt_ah_attr.grh.flow_label =
 +				cmd->base.alt_dest.flow_label;
 +		attr->alt_ah_attr.grh.sgid_index =
 +				cmd->base.alt_dest.sgid_index;
 +		attr->alt_ah_attr.grh.hop_limit =
 +				cmd->base.alt_dest.hop_limit;
 +		attr->alt_ah_attr.grh.traffic_class =
 +				cmd->base.alt_dest.traffic_class;
 +		attr->alt_ah_attr.ah_flags = IB_AH_GRH;
  	} else {
 -		rdma_ah_set_ah_flags(&attr->alt_ah_attr, 0);
 +		attr->alt_ah_attr.ah_flags = 0;
 +	}
 +	attr->alt_ah_attr.dlid		    = cmd->base.alt_dest.dlid;
 +	attr->alt_ah_attr.sl		    = cmd->base.alt_dest.sl;
 +	attr->alt_ah_attr.src_path_bits	    = cmd->base.alt_dest.src_path_bits;
 +	attr->alt_ah_attr.static_rate	    = cmd->base.alt_dest.static_rate;
 +	attr->alt_ah_attr.port_num	    = cmd->base.alt_dest.port_num;
 +
 +	if (qp->real_qp == qp) {
 +		if (cmd->base.attr_mask & IB_QP_AV) {
 +			ret = ib_resolve_eth_dmac(qp->device, &attr->ah_attr);
 +			if (ret)
 +				goto release_qp;
 +		}
 +		ret = qp->device->modify_qp(qp, attr,
 +					    modify_qp_mask(qp->qp_type,
 +							   cmd->base.attr_mask),
 +					    udata);
 +	} else {
 +		ret = ib_modify_qp(qp, attr,
 +				   modify_qp_mask(qp->qp_type,
 +						  cmd->base.attr_mask));
  	}
 -
 -	rdma_ah_set_dlid(&attr->alt_ah_attr, cmd->base.alt_dest.dlid);
 -	rdma_ah_set_sl(&attr->alt_ah_attr, cmd->base.alt_dest.sl);
 -	rdma_ah_set_path_bits(&attr->alt_ah_attr,
 -			      cmd->base.alt_dest.src_path_bits);
 -	rdma_ah_set_static_rate(&attr->alt_ah_attr,
 -				cmd->base.alt_dest.static_rate);
 -	rdma_ah_set_port_num(&attr->alt_ah_attr,
 -			     cmd->base.alt_dest.port_num);
 -
 -	ret = ib_modify_qp_with_udata(qp, attr,
 -				      modify_qp_mask(qp->qp_type,
 -						     cmd->base.attr_mask),
 -				      udata);
  
  release_qp:
 -	uobj_put_obj_read(qp);
 +	put_qp_read(qp);
 +
  out:
  	kfree(attr);
  
diff --cc drivers/infiniband/core/verbs.c
index 7333fc0ff1bc,b456e3ca1876..000000000000
--- a/drivers/infiniband/core/verbs.c
+++ b/drivers/infiniband/core/verbs.c
@@@ -1260,6 -1277,35 +1261,38 @@@ out
  }
  EXPORT_SYMBOL(ib_resolve_eth_dmac);
  
++<<<<<<< HEAD
++=======
+ /**
+  * ib_modify_qp_with_udata - Modifies the attributes for the specified QP.
+  * @qp: The QP to modify.
+  * @attr: On input, specifies the QP attributes to modify.  On output,
+  *   the current values of selected QP attributes are returned.
+  * @attr_mask: A bit-mask used to specify which attributes of the QP
+  *   are being modified.
+  * @udata: pointer to user's input output buffer information
+  *   are being modified.
+  * It returns 0 on success and returns appropriate error code on error.
+  */
+ int ib_modify_qp_with_udata(struct ib_qp *qp, struct ib_qp_attr *attr,
+ 			    int attr_mask, struct ib_udata *udata)
+ {
+ 	int ret;
+ 
+ 	if (attr_mask & IB_QP_AV) {
+ 		ret = ib_resolve_eth_dmac(qp->device, &attr->ah_attr);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 	ret = ib_security_modify_qp(qp, attr, attr_mask, udata);
+ 	if (!ret && (attr_mask & IB_QP_PORT))
+ 		qp->port = attr->port_num;
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL(ib_modify_qp_with_udata);
+ 
++>>>>>>> 498ca3c82a7b (IB/core: Avoid accessing non-allocated memory when inferring port type)
  int ib_modify_qp(struct ib_qp *qp,
  		 struct ib_qp_attr *qp_attr,
  		 int qp_attr_mask)
diff --cc include/rdma/ib_verbs.h
index b24c95ce461c,88c32aba32f7..000000000000
--- a/include/rdma/ib_verbs.h
+++ b/include/rdma/ib_verbs.h
@@@ -1592,6 -1682,8 +1592,11 @@@ struct ib_qp 
  	u32			max_read_sge;
  	enum ib_qp_type		qp_type;
  	struct ib_rwq_ind_table *rwq_ind_tbl;
++<<<<<<< HEAD
++=======
+ 	struct ib_qp_security  *qp_sec;
+ 	u8			port;
++>>>>>>> 498ca3c82a7b (IB/core: Avoid accessing non-allocated memory when inferring port type)
  };
  
  struct ib_mr {
* Unmerged path drivers/infiniband/core/uverbs_cmd.c
* Unmerged path drivers/infiniband/core/verbs.c
* Unmerged path include/rdma/ib_verbs.h
