sched/x86: Change CONFIG_SCHED_ITMT to CONFIG_SCHED_MC_PRIO

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Tim Chen <tim.c.chen@linux.intel.com>
commit de966cf4a4fa8d4e0357b08204bc791f34deb3fb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/de966cf4.failed

Rename CONFIG_SCHED_ITMT for Intel Turbo Boost Max Technology 3.0
to CONFIG_SCHED_MC_PRIO.  This makes the configuration extensible
in future to other architectures that wish to similarly establish
CPU core priorities support in the scheduler.

The description in Kconfig is updated to reflect this change with
added details for better clarity.  The configuration is explicitly
default-y, to enable the feature on CPUs that have this feature.

It has no effect on non-TBM3 CPUs.

	Signed-off-by: Tim Chen <tim.c.chen@linux.intel.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: bp@suse.de
	Cc: jolsa@redhat.com
	Cc: linux-acpi@vger.kernel.org
	Cc: linux-pm@vger.kernel.org
	Cc: rjw@rjwysocki.net
Link: http://lkml.kernel.org/r/2b2ee29d93e3f162922d72d0165a1405864fbb23.1480444902.git.tim.c.chen@linux.intel.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit de966cf4a4fa8d4e0357b08204bc791f34deb3fb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/Kconfig
#	arch/x86/include/asm/topology.h
#	arch/x86/kernel/Makefile
#	drivers/acpi/bus.c
#	drivers/cpufreq/Kconfig.x86
diff --cc arch/x86/Kconfig
index c83b7a921031,715c1f3664c4..000000000000
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@@ -904,10 -939,34 +904,32 @@@ config SCHED_M
  	  making when dealing with multi-core CPU chips at a cost of slightly
  	  increased overhead in some places. If unsure say N here.
  
++<<<<<<< HEAD
++=======
+ config SCHED_MC_PRIO
+ 	bool "CPU core priorities scheduler support"
+ 	depends on SCHED_MC && CPU_SUP_INTEL && X86_INTEL_PSTATE
+ 	default y
+ 	---help---
+ 	   Intel Turbo Boost Max Technology 3.0 enabled CPUs have a
+ 	   core ordering determined at manufacturing time, which allows
+ 	   certain cores to reach higher turbo frequencies (when running
+ 	   single threaded workloads) than others.
+ 
+ 	   Enabling this kernel feature teaches the scheduler about
+ 	   the TBM3 (aka ITMT) priority order of the CPU cores and adjusts the
+ 	   scheduler's CPU selection logic accordingly, so that higher
+ 	   overall system performance can be achieved.
+ 
+ 	   This feature will have no effect on CPUs without this feature.
+ 
+ 	   If unsure say Y here.
+ 
++>>>>>>> de966cf4a4fa (sched/x86: Change CONFIG_SCHED_ITMT to CONFIG_SCHED_MC_PRIO)
  source "kernel/Kconfig.preempt"
  
 -config UP_LATE_INIT
 -       def_bool y
 -       depends on !SMP && X86_LOCAL_APIC
 -
  config X86_UP_APIC
 -	bool "Local APIC support on uniprocessors" if !PCI_MSI
 -	default PCI_MSI
 +	bool "Local APIC support on uniprocessors"
  	depends on X86_32 && !SMP && !X86_32_NON_STANDARD
  	---help---
  	  A local APIC (Advanced Programmable Interrupt Controller) is an
diff --cc arch/x86/include/asm/topology.h
index 93b2cb826344,6358a85e2270..000000000000
--- a/arch/x86/include/asm/topology.h
+++ b/arch/x86/include/asm/topology.h
@@@ -148,10 -146,36 +148,44 @@@ struct pci_bus
  int x86_pci_root_bus_node(int bus);
  void x86_pci_root_bus_resources(int bus, struct list_head *resources);
  
++<<<<<<< HEAD
 +#ifdef CONFIG_SMP
 +#define mc_capable()	((boot_cpu_data.x86_max_cores > 1) && \
 +			(cpumask_weight(cpu_core_mask(0)) != nr_cpu_ids))
 +#define smt_capable()			(smp_num_siblings > 1)
 +#endif
++=======
+ extern bool x86_topology_update;
+ 
+ #ifdef CONFIG_SCHED_MC_PRIO
+ #include <asm/percpu.h>
+ 
+ DECLARE_PER_CPU_READ_MOSTLY(int, sched_core_priority);
+ extern unsigned int __read_mostly sysctl_sched_itmt_enabled;
+ 
+ /* Interface to set priority of a cpu */
+ void sched_set_itmt_core_prio(int prio, int core_cpu);
+ 
+ /* Interface to notify scheduler that system supports ITMT */
+ int sched_set_itmt_support(void);
+ 
+ /* Interface to notify scheduler that system revokes ITMT support */
+ void sched_clear_itmt_support(void);
+ 
+ #else /* CONFIG_SCHED_MC_PRIO */
+ 
+ #define sysctl_sched_itmt_enabled	0
+ static inline void sched_set_itmt_core_prio(int prio, int core_cpu)
+ {
+ }
+ static inline int sched_set_itmt_support(void)
+ {
+ 	return 0;
+ }
+ static inline void sched_clear_itmt_support(void)
+ {
+ }
+ #endif /* CONFIG_SCHED_MC_PRIO */
++>>>>>>> de966cf4a4fa (sched/x86: Change CONFIG_SCHED_ITMT to CONFIG_SCHED_MC_PRIO)
  
  #endif /* _ASM_X86_TOPOLOGY_H */
diff --cc arch/x86/kernel/Makefile
index b45aefa28c40,05110c1097ae..000000000000
--- a/arch/x86/kernel/Makefile
+++ b/arch/x86/kernel/Makefile
@@@ -107,7 -120,16 +107,17 @@@ obj-$(CONFIG_UPROBES)			+= uprobes.
  
  obj-$(CONFIG_PERF_EVENTS)		+= perf_regs.o
  obj-$(CONFIG_TRACING)			+= tracepoint.o
++<<<<<<< HEAD
 +obj-$(CONFIG_IOSF_MBI)			+= iosf_mbi.o
++=======
+ obj-$(CONFIG_SCHED_MC_PRIO)		+= itmt.o
+ 
+ ifdef CONFIG_FRAME_POINTER
+ obj-y					+= unwind_frame.o
+ else
+ obj-y					+= unwind_guess.o
+ endif
++>>>>>>> de966cf4a4fa (sched/x86: Change CONFIG_SCHED_ITMT to CONFIG_SCHED_MC_PRIO)
  
  ###
  # 64 bit specific files
diff --cc drivers/acpi/bus.c
index 01b7641ae954,5cbefd7621f0..000000000000
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@@ -307,6 -338,9 +307,12 @@@ static void acpi_bus_osc_support(void
  	}
  #endif
  
++<<<<<<< HEAD
++=======
+ 	if (IS_ENABLED(CONFIG_SCHED_MC_PRIO))
+ 		capbuf[OSC_SUPPORT_DWORD] |= OSC_SB_CPC_DIVERSE_HIGH_SUPPORT;
+ 
++>>>>>>> de966cf4a4fa (sched/x86: Change CONFIG_SCHED_ITMT to CONFIG_SCHED_MC_PRIO)
  	if (!ghes_disable)
  		capbuf[OSC_SUPPORT_DWORD] |= OSC_SB_APEI_SUPPORT;
  	if (ACPI_FAILURE(acpi_get_handle(NULL, "\\_SB", &handle)))
diff --cc drivers/cpufreq/Kconfig.x86
index 89ae88f91895,35f71825b7f3..000000000000
--- a/drivers/cpufreq/Kconfig.x86
+++ b/drivers/cpufreq/Kconfig.x86
@@@ -5,6 -5,8 +5,11 @@@
  config X86_INTEL_PSTATE
         bool "Intel P state control"
         depends on X86
++<<<<<<< HEAD
++=======
+        select ACPI_PROCESSOR if ACPI
+        select ACPI_CPPC_LIB if X86_64 && ACPI && SCHED_MC_PRIO
++>>>>>>> de966cf4a4fa (sched/x86: Change CONFIG_SCHED_ITMT to CONFIG_SCHED_MC_PRIO)
         help
            This driver provides a P state for Intel core processors.
  	  The driver implements an internal governor and will become
* Unmerged path arch/x86/Kconfig
* Unmerged path arch/x86/include/asm/topology.h
* Unmerged path arch/x86/kernel/Makefile
* Unmerged path drivers/acpi/bus.c
* Unmerged path drivers/cpufreq/Kconfig.x86
