fs: Limit file caps to the user namespace of the super block

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [fs] Limit file caps to the user namespace of the super block ("Eric W. Biederman") [1487751]
Rebuild_FUZZ: 96.55%
commit-author Seth Forshee <seth.forshee@canonical.com>
commit d07b846f6200454c50d791796edb82660192513d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d07b846f.failed

Capability sets attached to files must be ignored except in the
user namespaces where the mounter is privileged, i.e. s_user_ns
and its descendants. Otherwise a vector exists for gaining
privileges in namespaces where a user is not already privileged.

Add a new helper function, current_in_user_ns(), to test whether a user
namespace is the same as or a descendant of another namespace.
Use this helper to determine whether a file's capability set
should be applied to the caps constructed during exec.

--EWB Replaced in_userns with the simpler current_in_userns.

	Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
	Signed-off-by: Seth Forshee <seth.forshee@canonical.com>
	Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
(cherry picked from commit d07b846f6200454c50d791796edb82660192513d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/user_namespace.c
diff --cc kernel/user_namespace.c
index f698a257e27c,68f594212759..000000000000
--- a/kernel/user_namespace.c
+++ b/kernel/user_namespace.c
@@@ -996,7 -938,26 +996,30 @@@ bool userns_may_setgroups(const struct 
  	return allowed;
  }
  
++<<<<<<< HEAD
 +static void *userns_get(struct task_struct *task)
++=======
+ /*
+  * Returns true if @ns is the same namespace as or a descendant of
+  * @target_ns.
+  */
+ bool current_in_userns(const struct user_namespace *target_ns)
+ {
+ 	struct user_namespace *ns;
+ 	for (ns = current_user_ns(); ns; ns = ns->parent) {
+ 		if (ns == target_ns)
+ 			return true;
+ 	}
+ 	return false;
+ }
+ 
+ static inline struct user_namespace *to_user_ns(struct ns_common *ns)
+ {
+ 	return container_of(ns, struct user_namespace, ns);
+ }
+ 
+ static struct ns_common *userns_get(struct task_struct *task)
++>>>>>>> d07b846f6200 (fs: Limit file caps to the user namespace of the super block)
  {
  	struct user_namespace *user_ns;
  
diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 9cca1de7ecaf..98cee13d5705 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -114,6 +114,7 @@ extern ssize_t proc_projid_map_write(struct file *, const char __user *, size_t,
 extern ssize_t proc_setgroups_write(struct file *, const char __user *, size_t, loff_t *);
 extern int proc_setgroups_show(struct seq_file *m, void *v);
 extern bool userns_may_setgroups(const struct user_namespace *ns);
+extern bool current_in_userns(const struct user_namespace *target_ns);
 #else
 
 static inline struct user_namespace *get_user_ns(struct user_namespace *ns)
@@ -142,6 +143,11 @@ static inline bool userns_may_setgroups(const struct user_namespace *ns)
 {
 	return true;
 }
+
+static inline bool current_in_userns(const struct user_namespace *target_ns)
+{
+	return true;
+}
 #endif
 
 void update_mnt_policy(struct user_namespace *userns);
* Unmerged path kernel/user_namespace.c
diff --git a/security/commoncap.c b/security/commoncap.c
index 9fb6de81bb8f..55053ff00f13 100644
--- a/security/commoncap.c
+++ b/security/commoncap.c
@@ -456,6 +456,8 @@ static int get_file_caps(struct linux_binprm *bprm, bool *effective, bool *has_c
 
 	if (bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID)
 		return 0;
+	if (!current_in_userns(bprm->file->f_path.mnt->mnt_sb->s_user_ns))
+		return 0;
 
 	dentry = dget(bprm->file->f_dentry);
 
