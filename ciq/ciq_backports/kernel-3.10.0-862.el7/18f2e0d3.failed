fsnotify: Rename fsnotify_clear_marks_by_group_flags()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jan Kara <jack@suse.cz>
commit 18f2e0d3a43641889ac2ba9d7508d47359eec063
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/18f2e0d3.failed

The _flags() suffix in the function name was more confusing than
explaining so just remove it. Also rename the argument from 'flags' to
'type' to better explain what the function expects.

	Reviewed-by: Miklos Szeredi <mszeredi@redhat.com>
	Suggested-by: Amir Goldstein <amir73il@gmail.com>
	Reviewed-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
(cherry picked from commit 18f2e0d3a43641889ac2ba9d7508d47359eec063)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/notify/mark.c
#	include/linux/fsnotify_backend.h
diff --cc fs/notify/mark.c
index 4fae28e73aa3,89656abbf4f8..000000000000
--- a/fs/notify/mark.c
+++ b/fs/notify/mark.c
@@@ -436,7 -663,7 +434,11 @@@ void fsnotify_clear_marks_by_group(stru
  	 */
  	mutex_lock_nested(&group->mark_mutex, SINGLE_DEPTH_NESTING);
  	list_for_each_entry_safe(mark, lmark, &group->marks_list, g_list) {
++<<<<<<< HEAD
 +		if (mark->flags & flags)
++=======
+ 		if (mark->connector->flags & type)
++>>>>>>> 18f2e0d3a436 (fsnotify: Rename fsnotify_clear_marks_by_group_flags())
  			list_move(&mark->g_list, &to_free);
  	}
  	mutex_unlock(&group->mark_mutex);
diff --cc include/linux/fsnotify_backend.h
index 0256909191e5,d6bbd5acdac1..000000000000
--- a/include/linux/fsnotify_backend.h
+++ b/include/linux/fsnotify_backend.h
@@@ -356,15 -355,23 +356,30 @@@ extern void fsnotify_destroy_mark(struc
  extern void fsnotify_detach_mark(struct fsnotify_mark *mark);
  /* free mark */
  extern void fsnotify_free_mark(struct fsnotify_mark *mark);
++<<<<<<< HEAD
 +/* run all the marks in a group, and clear all of the vfsmount marks */
 +extern void fsnotify_clear_vfsmount_marks_by_group(struct fsnotify_group *group);
 +/* run all the marks in a group, and clear all of the inode marks */
 +extern void fsnotify_clear_inode_marks_by_group(struct fsnotify_group *group);
 +/* run all the marks in a group, and clear all of the marks where mark->flags & flags is true*/
 +extern void fsnotify_clear_marks_by_group_flags(struct fsnotify_group *group, unsigned int flags);
++=======
+ /* run all the marks in a group, and clear all of the marks attached to given object type */
+ extern void fsnotify_clear_marks_by_group(struct fsnotify_group *group, unsigned int type);
+ /* run all the marks in a group, and clear all of the vfsmount marks */
+ static inline void fsnotify_clear_vfsmount_marks_by_group(struct fsnotify_group *group)
+ {
+ 	fsnotify_clear_marks_by_group(group, FSNOTIFY_OBJ_TYPE_VFSMOUNT);
+ }
+ /* run all the marks in a group, and clear all of the inode marks */
+ static inline void fsnotify_clear_inode_marks_by_group(struct fsnotify_group *group)
+ {
+ 	fsnotify_clear_marks_by_group(group, FSNOTIFY_OBJ_TYPE_INODE);
+ }
++>>>>>>> 18f2e0d3a436 (fsnotify: Rename fsnotify_clear_marks_by_group_flags())
  extern void fsnotify_get_mark(struct fsnotify_mark *mark);
  extern void fsnotify_put_mark(struct fsnotify_mark *mark);
 -extern void fsnotify_unmount_inodes(struct super_block *sb);
 -extern void fsnotify_finish_user_wait(struct fsnotify_iter_info *iter_info);
 -extern bool fsnotify_prepare_user_wait(struct fsnotify_iter_info *iter_info);
 +extern void fsnotify_unmount_inodes(struct list_head *list);
  
  /* put here because inotify does some weird stuff when destroying watches */
  extern void fsnotify_init_event(struct fsnotify_event *event,
* Unmerged path fs/notify/mark.c
* Unmerged path include/linux/fsnotify_backend.h
