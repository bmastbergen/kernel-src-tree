net_sched: reorder pernet ops and act ops registrations

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author WANG Cong <xiyou.wangcong@gmail.com>
commit ab102b80cef28c20b3ef7794806c3a982c6444fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ab102b80.failed

Krister reported a kernel NULL pointer dereference after
tcf_action_init_1() invokes a_o->init(), it is a race condition
where one thread calling tcf_register_action() to initialize
the netns data after putting act ops in the global list and
the other thread searching the list and then calling
a_o->init(net, ...).

Fix this by moving the pernet ops registration before making
the action ops visible. This is fine because: a) we don't
rely on act_base in pernet ops->init(), b) in the worst case we
have a fully initialized netns but ops is still not ready so
new actions still can't be created.

	Reported-by: Krister Johansen <kjlx@templeofstupid.com>
	Tested-by: Krister Johansen <kjlx@templeofstupid.com>
	Cc: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
	Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ab102b80cef28c20b3ef7794806c3a982c6444fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/act_api.c
diff --cc net/sched/act_api.c
index 6d9fec09e3bf,a512b18c0088..000000000000
--- a/net/sched/act_api.c
+++ b/net/sched/act_api.c
@@@ -339,41 -332,34 +339,59 @@@ static void tcf_hashinfo_destroy(const 
  static LIST_HEAD(act_base);
  static DEFINE_RWLOCK(act_mod_lock);
  
 -int tcf_register_action(struct tc_action_ops *act,
 -			struct pernet_operations *ops)
 +int tcf_register_action(struct tc_action_ops *act, unsigned int mask)
  {
  	struct tc_action_ops *a;
 -	int ret;
 +	int err;
  
 -	if (!act->act || !act->dump || !act->init || !act->walk || !act->lookup)
 +	/* Must supply act, dump and init */
 +	if (!act->act || !act->dump || !act->init)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	/* Supply defaults */
 +	if (!act->lookup)
 +		act->lookup = tcf_hash_search;
 +	if (!act->walk)
 +		act->walk = tcf_generic_walker;
 +
 +	act->hinfo = kmalloc(sizeof(struct tcf_hashinfo), GFP_KERNEL);
 +	if (!act->hinfo)
 +		return -ENOMEM;
 +	err = tcf_hashinfo_init(act->hinfo, mask);
 +	if (err) {
 +		kfree(act->hinfo);
 +		return err;
 +	}
++=======
+ 	/* We have to register pernet ops before making the action ops visible,
+ 	 * otherwise tcf_action_init_1() could get a partially initialized
+ 	 * netns.
+ 	 */
+ 	ret = register_pernet_subsys(ops);
+ 	if (ret)
+ 		return ret;
++>>>>>>> ab102b80cef2 (net_sched: reorder pernet ops and act ops registrations)
  
  	write_lock(&act_mod_lock);
  	list_for_each_entry(a, &act_base, head) {
  		if (act->type == a->type || (strcmp(act->kind, a->kind) == 0)) {
  			write_unlock(&act_mod_lock);
++<<<<<<< HEAD
 +			tcf_hashinfo_destroy(act);
 +			kfree(act->hinfo);
++=======
+ 			unregister_pernet_subsys(ops);
++>>>>>>> ab102b80cef2 (net_sched: reorder pernet ops and act ops registrations)
  			return -EEXIST;
  		}
  	}
  	list_add_tail(&act->head, &act_base);
  	write_unlock(&act_mod_lock);
++<<<<<<< HEAD
++=======
+ 
++>>>>>>> ab102b80cef2 (net_sched: reorder pernet ops and act ops registrations)
  	return 0;
  }
  EXPORT_SYMBOL(tcf_register_action);
* Unmerged path net/sched/act_api.c
