ovl: copy up regular file using O_TMPFILE

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit d8514d8edb5b045cf7f708e14f888ce760d60f0b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d8514d8e.failed

In preparation for concurrent copy up, implement copy up
of regular file as O_TMPFILE that is linked to upperdir
instead of a file in workdir that is moved to upperdir.

	Suggested-by: Al Viro <viro@zeniv.linux.org.uk>
	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit d8514d8edb5b045cf7f708e14f888ce760d60f0b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/copy_up.c
diff --cc fs/overlayfs/copy_up.c
index 6e96b99a973d,6e39e90b5605..000000000000
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@@ -266,7 -233,8 +267,12 @@@ int ovl_set_attr(struct dentry *upperde
  
  static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,
  			      struct dentry *dentry, struct path *lowerpath,
++<<<<<<< HEAD
 +			      struct kstat *stat, const char *link)
++=======
+ 			      struct kstat *stat, const char *link,
+ 			      struct kstat *pstat, bool tmpfile)
++>>>>>>> d8514d8edb5b (ovl: copy up regular file using O_TMPFILE)
  {
  	struct inode *wdir = workdir->d_inode;
  	struct inode *udir = upperdir->d_inode;
@@@ -295,10 -264,17 +301,24 @@@
  	if (new_creds)
  		old_creds = override_creds(new_creds);
  
++<<<<<<< HEAD
 +	/* Can't properly set mode on creation because of the umask */
 +	stat->mode &= S_IFMT;
 +	err = ovl_create_real(wdir, newdentry, stat, link, NULL, true);
 +	stat->mode = mode;
++=======
+ 	if (tmpfile)
+ 		temp = ovl_do_tmpfile(upperdir, stat->mode);
+ 	else
+ 		temp = ovl_lookup_temp(workdir, dentry);
+ 	err = PTR_ERR(temp);
+ 	if (IS_ERR(temp))
+ 		goto out1;
+ 
+ 	err = 0;
+ 	if (!tmpfile)
+ 		err = ovl_create_real(wdir, temp, &cattr, NULL, true);
++>>>>>>> d8514d8edb5b (ovl: copy up regular file using O_TMPFILE)
  
  	if (new_creds) {
  		revert_creds(old_creds);
@@@ -330,28 -300,35 +350,44 @@@
  	if (err)
  		goto out_cleanup;
  
 -	inode_lock(temp->d_inode);
 -	err = ovl_set_attr(temp, stat);
 -	inode_unlock(temp->d_inode);
++<<<<<<< HEAD
 +	err = ovl_do_rename(wdir, newdentry, udir, upper, 0);
  	if (err)
  		goto out_cleanup;
  
++=======
+ 	if (tmpfile)
+ 		err = ovl_do_link(temp, udir, upper, true);
+ 	else
+ 		err = ovl_do_rename(wdir, temp, udir, upper, 0);
+ 	if (err)
+ 		goto out_cleanup;
+ 
+ 	newdentry = dget(tmpfile ? upper : temp);
++>>>>>>> d8514d8edb5b (ovl: copy up regular file using O_TMPFILE)
  	ovl_dentry_update(dentry, newdentry);
  	ovl_inode_update(d_inode(dentry), d_inode(newdentry));
 +	newdentry = NULL;
  
 -	/* Restore timestamps on parent (best effort) */
 -	ovl_set_timestamps(upperdir, pstat);
 +	/*
 +	 * Non-directores become opaque when copied up.
 +	 */
 +	if (!S_ISDIR(stat->mode))
 +		ovl_dentry_set_opaque(dentry, true);
  out2:
 -	dput(temp);
 -out1:
  	dput(upper);
 +out1:
 +	dput(newdentry);
  out:
  	return err;
  
  out_cleanup:
++<<<<<<< HEAD
 +	ovl_cleanup(wdir, newdentry);
++=======
+ 	if (!tmpfile)
+ 		ovl_cleanup(wdir, temp);
++>>>>>>> d8514d8edb5b (ovl: copy up regular file using O_TMPFILE)
  	goto out2;
  }
  
@@@ -377,9 -349,12 +413,16 @@@ static int ovl_copy_up_one(struct dentr
  	int err;
  	struct kstat pstat;
  	struct path parentpath;
 -	struct dentry *lowerdentry = lowerpath->dentry;
  	struct dentry *upperdir;
++<<<<<<< HEAD
 +	struct dentry *upperdentry;
 +	char *link = NULL;
++=======
+ 	const char *link = NULL;
+ 	struct ovl_fs *ofs = dentry->d_sb->s_fs_info;
+ 	/* Should we copyup with O_TMPFILE or with workdir? */
+ 	bool tmpfile = S_ISREG(stat->mode) && ofs->tmpfile;
++>>>>>>> d8514d8edb5b (ovl: copy up regular file using O_TMPFILE)
  
  	if (WARN_ON(!workdir))
  		return -EROFS;
@@@ -412,16 -386,10 +455,20 @@@
  	}
  
  	err = ovl_copy_up_locked(workdir, upperdir, dentry, lowerpath,
++<<<<<<< HEAD
 +				 stat, link);
 +	if (!err) {
 +		/* Restore timestamps on parent (best effort) */
 +		ovl_set_timestamps(upperdir, &pstat);
 +	}
++=======
+ 				 stat, link, &pstat, tmpfile);
++>>>>>>> d8514d8edb5b (ovl: copy up regular file using O_TMPFILE)
  out_unlock:
  	unlock_rename(workdir, upperdir);
 -	do_delayed_call(&done);
 +
 +	if (link)
 +		free_page((unsigned long) link);
  
  	return err;
  }
* Unmerged path fs/overlayfs/copy_up.c
