ovl: create directories inside merged parent opaque

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 97c684cc911060ba7f97c0925eaf842f159a39e8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/97c684cc.failed

The benefit of making directories opaque on creation is that lookups can
stop short when they reach the original created directory, instead of
continue lookup the entire depth of parent directory stack.

The best case is overlay with N layers, performing lookup for first level
directory, which exists only in upper.  In that case, there will be only
one lookup instead of N.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 97c684cc911060ba7f97c0925eaf842f159a39e8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/dir.c
diff --cc fs/overlayfs/dir.c
index c82fdefe6d3b,3cc65e60df02..000000000000
--- a/fs/overlayfs/dir.c
+++ b/fs/overlayfs/dir.c
@@@ -954,18 -1012,22 +964,35 @@@ static int ovl_rename(struct inode *old
  	if (WARN_ON(olddentry->d_inode == newdentry->d_inode))
  		goto out_dput;
  
++<<<<<<< HEAD
 +	if (is_dir && !old_opaque && ovl_lower_positive(new)) {
 +		err = ovl_set_opaque(olddentry);
++=======
+ 	err = 0;
+ 	if (is_dir) {
+ 		if (ovl_type_merge_or_lower(old))
+ 			err = ovl_set_redirect(old, samedir);
+ 		else if (!old_opaque && ovl_type_merge(new->d_parent))
+ 			err = ovl_set_opaque(old, olddentry);
++>>>>>>> 97c684cc9110 (ovl: create directories inside merged parent opaque)
  		if (err)
  			goto out_dput;
 +		ovl_dentry_set_opaque(old, true);
  	}
++<<<<<<< HEAD
 +	if (!overwrite &&
 +	    new_is_dir && !new_opaque && ovl_lower_positive(old)) {
 +		err = ovl_set_opaque(newdentry);
++=======
+ 	if (!overwrite && new_is_dir) {
+ 		if (ovl_type_merge_or_lower(new))
+ 			err = ovl_set_redirect(new, samedir);
+ 		else if (!new_opaque && ovl_type_merge(old->d_parent))
+ 			err = ovl_set_opaque(new, newdentry);
++>>>>>>> 97c684cc9110 (ovl: create directories inside merged parent opaque)
  		if (err)
  			goto out_dput;
 +		ovl_dentry_set_opaque(new, true);
  	}
  
  	err = ovl_do_rename(old_upperdir->d_inode, olddentry,
* Unmerged path fs/overlayfs/dir.c
