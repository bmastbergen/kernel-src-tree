mm: filemap: fix mapping->nrpages double accounting in fuse

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [mm] filemap: fix mapping->nrpages double accounting in fuse (Waiman Long) [1493455]
Rebuild_FUZZ: 96.49%
commit-author Johannes Weiner <hannes@cmpxchg.org>
commit 3ddf40e8c31964b744ff10abb48c8e36a83ec6e7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/3ddf40e8.failed

Commit 22f2ac51b6d6 ("mm: workingset: fix crash in shadow node shrinker
caused by replace_page_cache_page()") switched replace_page_cache() from
raw radix tree operations to page_cache_tree_insert() but didn't take
into account that the latter function, unlike the raw radix tree op,
handles mapping->nrpages.  As a result, that counter is bumped for each
page replacement rather than balanced out even.

The mapping->nrpages counter is used to skip needless radix tree walks
when invalidating, truncating, syncing inodes without pages, as well as
statistics for userspace.  Since the error is positive, we'll do more
page cache tree walks than necessary; we won't miss a necessary one.
And we'll report more buffer pages to userspace than there are.  The
error is limited to fuse inodes.

Fixes: 22f2ac51b6d6 ("mm: workingset: fix crash in shadow node shrinker caused by replace_page_cache_page()")
	Signed-off-by: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Miklos Szeredi <miklos@szeredi.hu>
	Cc: stable@vger.kernel.org
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 3ddf40e8c31964b744ff10abb48c8e36a83ec6e7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/filemap.c
diff --cc mm/filemap.c
index 7ea4d73bda16,4bad32dd4b3b..000000000000
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@@ -507,17 -629,20 +507,26 @@@ int replace_page_cache_page(struct pag
  		new->mapping = mapping;
  		new->index = offset;
  
 -		spin_lock_irqsave(&mapping->tree_lock, flags);
 +		spin_lock_irq(&mapping->tree_lock);
  		__delete_from_page_cache(old, NULL);
 -		error = page_cache_tree_insert(mapping, new, NULL);
 +		error = radix_tree_insert(&mapping->page_tree, offset, new);
  		BUG_ON(error);
++<<<<<<< HEAD
 +		mapping->nrpages++;
 +		__inc_zone_page_state(new, NR_FILE_PAGES);
++=======
+ 
+ 		/*
+ 		 * hugetlb pages do not participate in page cache accounting.
+ 		 */
+ 		if (!PageHuge(new))
+ 			__inc_node_page_state(new, NR_FILE_PAGES);
++>>>>>>> 3ddf40e8c319 (mm: filemap: fix mapping->nrpages double accounting in fuse)
  		if (PageSwapBacked(new))
 -			__inc_node_page_state(new, NR_SHMEM);
 -		spin_unlock_irqrestore(&mapping->tree_lock, flags);
 -		mem_cgroup_migrate(old, new);
 +			__inc_zone_page_state(new, NR_SHMEM);
 +		spin_unlock_irq(&mapping->tree_lock);
 +		/* mem_cgroup codes must not be called under tree_lock */
 +		mem_cgroup_replace_page_cache(old, new);
  		radix_tree_preload_end();
  		if (freepage)
  			freepage(old);
* Unmerged path mm/filemap.c
