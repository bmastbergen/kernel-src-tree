scsi_dh_alua: move optimize_stpg evaluation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Hannes Reinecke <hare@suse.de>
commit aa90f49036a6a9dd917c5f571497a28e6a6e5bcc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/aa90f490.failed

When the optimize_stpg module option is set we should just set it
once during port_group allocation. Doing so allows us to override
it later with device specific settings.

	Reviewed-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit aa90f49036a6a9dd917c5f571497a28e6a6e5bcc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/device_handler/scsi_dh_alua.c
diff --cc drivers/scsi/device_handler/scsi_dh_alua.c
index 9c9d9c3d8e9b,d02894dd027d..000000000000
--- a/drivers/scsi/device_handler/scsi_dh_alua.c
+++ b/drivers/scsi/device_handler/scsi_dh_alua.c
@@@ -64,10 -64,19 +64,25 @@@
  #define ALUA_OPTIMIZE_STPG		1
  #define ALUA_RTPG_EXT_HDR_UNSUPP	2
  
++<<<<<<< HEAD
 +struct alua_dh_data {
 +	struct scsi_dh_data	dh_data;
++=======
+ static uint optimize_stpg;
+ module_param(optimize_stpg, uint, S_IRUGO|S_IWUSR);
+ MODULE_PARM_DESC(optimize_stpg, "Allow use of a non-optimized path, rather than sending a STPG, when implicit TPGS is supported (0=No,1=Yes). Default is 0.");
+ 
+ static LIST_HEAD(port_group_list);
+ static DEFINE_SPINLOCK(port_group_lock);
+ 
+ struct alua_port_group {
+ 	struct kref		kref;
+ 	struct list_head	node;
+ 	unsigned char		device_id_str[256];
+ 	int			device_id_len;
++>>>>>>> aa90f49036a6 (scsi_dh_alua: move optimize_stpg evaluation)
  	int			group_id;
 +	int			rel_port;
  	int			tpgs;
  	int			state;
  	int			pref;
@@@ -165,6 -169,79 +180,82 @@@ static int submit_stpg(struct scsi_devi
  				      ALUA_FAILOVER_RETRIES, NULL, req_flags);
  }
  
++<<<<<<< HEAD
++=======
+ struct alua_port_group *alua_find_get_pg(char *id_str, size_t id_size,
+ 					 int group_id)
+ {
+ 	struct alua_port_group *pg;
+ 
+ 	list_for_each_entry(pg, &port_group_list, node) {
+ 		if (pg->group_id != group_id)
+ 			continue;
+ 		if (pg->device_id_len != id_size)
+ 			continue;
+ 		if (strncmp(pg->device_id_str, id_str, id_size))
+ 			continue;
+ 		if (!kref_get_unless_zero(&pg->kref))
+ 			continue;
+ 		return pg;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ /*
+  * alua_alloc_pg - Allocate a new port_group structure
+  * @sdev: scsi device
+  * @h: alua device_handler data
+  * @group_id: port group id
+  *
+  * Allocate a new port_group structure for a given
+  * device.
+  */
+ struct alua_port_group *alua_alloc_pg(struct scsi_device *sdev,
+ 				      int group_id, int tpgs)
+ {
+ 	struct alua_port_group *pg, *tmp_pg;
+ 
+ 	pg = kzalloc(sizeof(struct alua_port_group), GFP_KERNEL);
+ 	if (!pg)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	pg->device_id_len = scsi_vpd_lun_id(sdev, pg->device_id_str,
+ 					    sizeof(pg->device_id_str));
+ 	if (pg->device_id_len <= 0) {
+ 		/*
+ 		 * Internal error: TPGS supported but no device
+ 		 * identifcation found. Disable ALUA support.
+ 		 */
+ 		kfree(pg);
+ 		sdev_printk(KERN_INFO, sdev,
+ 			    "%s: No device descriptors found\n",
+ 			    ALUA_DH_NAME);
+ 		return ERR_PTR(-ENXIO);
+ 	}
+ 	pg->group_id = group_id;
+ 	pg->tpgs = tpgs;
+ 	pg->state = TPGS_STATE_OPTIMIZED;
+ 	if (optimize_stpg)
+ 		pg->flags |= ALUA_OPTIMIZE_STPG;
+ 	kref_init(&pg->kref);
+ 
+ 	spin_lock(&port_group_lock);
+ 	tmp_pg = alua_find_get_pg(pg->device_id_str, pg->device_id_len,
+ 				  group_id);
+ 	if (tmp_pg) {
+ 		spin_unlock(&port_group_lock);
+ 		kfree(pg);
+ 		return tmp_pg;
+ 	}
+ 
+ 	list_add(&pg->node, &port_group_list);
+ 	spin_unlock(&port_group_lock);
+ 
+ 	return pg;
+ }
+ 
++>>>>>>> aa90f49036a6 (scsi_dh_alua: move optimize_stpg evaluation)
  /*
   * alua_check_tpgs - Evaluate TPGS setting
   * @sdev: device to be checked
@@@ -616,19 -697,23 +703,30 @@@ static int alua_set_params(struct scsi_
  static int alua_activate(struct scsi_device *sdev,
  			activate_complete fn, void *data)
  {
 -	struct alua_dh_data *h = sdev->handler_data;
 +	struct alua_dh_data *h = get_alua_data(sdev);
  	int err = SCSI_DH_OK;
  
 -	if (!h->pg)
 +	err = alua_rtpg(sdev, h, 1);
 +	if (err != SCSI_DH_OK)
  		goto out;
  
++<<<<<<< HEAD
 +	if (optimize_stpg)
 +		h->flags |= ALUA_OPTIMIZE_STPG;
 +
 +	err = alua_stpg(sdev, h);
++=======
+ 	kref_get(&h->pg->kref);
+ 
+ 	err = alua_rtpg(sdev, h->pg);
+ 	if (err != SCSI_DH_OK) {
+ 		kref_put(&h->pg->kref, release_port_group);
+ 		goto out;
+ 	}
+ 	err = alua_stpg(sdev, h->pg);
++>>>>>>> aa90f49036a6 (scsi_dh_alua: move optimize_stpg evaluation)
  	if (err == SCSI_DH_RETRY)
 -		err = alua_rtpg(sdev, h->pg);
 -	kref_put(&h->pg->kref, release_port_group);
 +		err = alua_rtpg(sdev, h, 1);
  out:
  	if (fn)
  		fn(data, err);
* Unmerged path drivers/scsi/device_handler/scsi_dh_alua.c
