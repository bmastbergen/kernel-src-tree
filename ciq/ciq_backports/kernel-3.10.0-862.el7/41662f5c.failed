sysctl: enable strict writes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Kees Cook <keescook@chromium.org>
commit 41662f5cc55335807d39404371cfcbb1909304c4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/41662f5c.failed

SYSCTL_WRITES_WARN was added in commit f4aacea2f5d1 ("sysctl: allow for
strict write position handling"), and released in v3.16 in August of
2014.  Since then I can find only 1 instance of non-zero offset
writing[1], and it was fixed immediately in CRIU[2].  As such, it
appears safe to flip this to the strict state now.

[1] https://www.google.com/search?q="when%20file%20position%20was%20not%200"
[2] http://lists.openvz.org/pipermail/criu/2015-April/019819.html

	Signed-off-by: Kees Cook <keescook@chromium.org>
	Cc: "Eric W. Biederman" <ebiederm@xmission.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 41662f5cc55335807d39404371cfcbb1909304c4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/sysctl/kernel.txt
#	kernel/sysctl.c
diff --cc Documentation/sysctl/kernel.txt
index 50713c8133e8,a93b414672a7..000000000000
--- a/Documentation/sysctl/kernel.txt
+++ b/Documentation/sysctl/kernel.txt
@@@ -835,12 -816,22 +835,29 @@@ without users and with a dead originati
  
  ==============================================================
  
 -sysctl_writes_strict:
 +softlockup_thresh:
  
++<<<<<<< HEAD
 +This value can be used to lower the softlockup tolerance threshold.  The
 +default threshold is 60 seconds.  If a cpu is locked up for 60 seconds,
 +the kernel complains.  Valid values are 1-60 seconds.  Setting this
 +tunable to zero will disable the softlockup detection altogether.
++=======
+ Control how file position affects the behavior of updating sysctl values
+ via the /proc/sys interface:
+ 
+   -1 - Legacy per-write sysctl value handling, with no printk warnings.
+        Each write syscall must fully contain the sysctl value to be
+        written, and multiple writes on the same sysctl file descriptor
+        will rewrite the sysctl value, regardless of file position.
+    0 - Same behavior as above, but warn about processes that perform writes
+        to a sysctl file descriptor when the file position is not 0.
+    1 - (default) Respect file position when writing sysctl strings. Multiple
+        writes will append to the sysctl value buffer. Anything past the max
+        length of the sysctl value buffer will be ignored. Writes to numeric
+        sysctl entries must always be at file position 0 and the value must
+        be fully contained in the buffer sent in the write syscall.
++>>>>>>> 41662f5cc553 (sysctl: enable strict writes)
  
  ==============================================================
  
diff --cc kernel/sysctl.c
index 7842d59f10b8,91420362e0b3..000000000000
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@@ -172,6 -168,13 +172,16 @@@ extern int no_unaligned_warning
  #endif
  
  #ifdef CONFIG_PROC_SYSCTL
++<<<<<<< HEAD
++=======
+ 
+ #define SYSCTL_WRITES_LEGACY	-1
+ #define SYSCTL_WRITES_WARN	 0
+ #define SYSCTL_WRITES_STRICT	 1
+ 
+ static int sysctl_writes_strict = SYSCTL_WRITES_STRICT;
+ 
++>>>>>>> 41662f5cc553 (sysctl: enable strict writes)
  static int proc_do_cad_pid(struct ctl_table *table, int write,
  		  void __user *buffer, size_t *lenp, loff_t *ppos);
  static int proc_taint(struct ctl_table *table, int write,
* Unmerged path Documentation/sysctl/kernel.txt
* Unmerged path kernel/sysctl.c
