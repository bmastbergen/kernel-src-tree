mlxsw: spectrum_router: Ignore address families other than IPv4

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ido Schimmel <idosch@mellanox.com>
commit 64e5e8252d69c68ae76258328ac7e5d2e5e923b0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/64e5e825.failed

We're about to add IPv6 notifications in the FIB notification chain, but
the driver currently doesn't support these, so ignore them.

	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 64e5e8252d69c68ae76258328ac7e5d2e5e923b0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index 2e656326922f,78c19512250d..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -2439,6 -3029,124 +2439,127 @@@ static void mlxsw_sp_router_fib4_abort(
  		dev_warn(mlxsw_sp->bus_info->dev, "Failed to set abort trap.\n");
  }
  
++<<<<<<< HEAD
++=======
+ struct mlxsw_sp_fib_event_work {
+ 	struct work_struct work;
+ 	union {
+ 		struct fib_entry_notifier_info fen_info;
+ 		struct fib_rule_notifier_info fr_info;
+ 		struct fib_nh_notifier_info fnh_info;
+ 	};
+ 	struct mlxsw_sp *mlxsw_sp;
+ 	unsigned long event;
+ };
+ 
+ static void mlxsw_sp_router_fib_event_work(struct work_struct *work)
+ {
+ 	struct mlxsw_sp_fib_event_work *fib_work =
+ 		container_of(work, struct mlxsw_sp_fib_event_work, work);
+ 	struct mlxsw_sp *mlxsw_sp = fib_work->mlxsw_sp;
+ 	struct fib_rule *rule;
+ 	bool replace, append;
+ 	int err;
+ 
+ 	/* Protect internal structures from changes */
+ 	rtnl_lock();
+ 	switch (fib_work->event) {
+ 	case FIB_EVENT_ENTRY_REPLACE: /* fall through */
+ 	case FIB_EVENT_ENTRY_APPEND: /* fall through */
+ 	case FIB_EVENT_ENTRY_ADD:
+ 		replace = fib_work->event == FIB_EVENT_ENTRY_REPLACE;
+ 		append = fib_work->event == FIB_EVENT_ENTRY_APPEND;
+ 		err = mlxsw_sp_router_fib4_add(mlxsw_sp, &fib_work->fen_info,
+ 					       replace, append);
+ 		if (err)
+ 			mlxsw_sp_router_fib_abort(mlxsw_sp);
+ 		fib_info_put(fib_work->fen_info.fi);
+ 		break;
+ 	case FIB_EVENT_ENTRY_DEL:
+ 		mlxsw_sp_router_fib4_del(mlxsw_sp, &fib_work->fen_info);
+ 		fib_info_put(fib_work->fen_info.fi);
+ 		break;
+ 	case FIB_EVENT_RULE_ADD: /* fall through */
+ 	case FIB_EVENT_RULE_DEL:
+ 		rule = fib_work->fr_info.rule;
+ 		if (!fib4_rule_default(rule) && !rule->l3mdev)
+ 			mlxsw_sp_router_fib_abort(mlxsw_sp);
+ 		fib_rule_put(rule);
+ 		break;
+ 	case FIB_EVENT_NH_ADD: /* fall through */
+ 	case FIB_EVENT_NH_DEL:
+ 		mlxsw_sp_nexthop4_event(mlxsw_sp, fib_work->event,
+ 					fib_work->fnh_info.fib_nh);
+ 		fib_info_put(fib_work->fnh_info.fib_nh->nh_parent);
+ 		break;
+ 	}
+ 	rtnl_unlock();
+ 	kfree(fib_work);
+ }
+ 
+ /* Called with rcu_read_lock() */
+ static int mlxsw_sp_router_fib_event(struct notifier_block *nb,
+ 				     unsigned long event, void *ptr)
+ {
+ 	struct mlxsw_sp_fib_event_work *fib_work;
+ 	struct fib_notifier_info *info = ptr;
+ 	struct mlxsw_sp_router *router;
+ 
+ 	if (!net_eq(info->net, &init_net) || info->family != AF_INET)
+ 		return NOTIFY_DONE;
+ 
+ 	fib_work = kzalloc(sizeof(*fib_work), GFP_ATOMIC);
+ 	if (WARN_ON(!fib_work))
+ 		return NOTIFY_BAD;
+ 
+ 	INIT_WORK(&fib_work->work, mlxsw_sp_router_fib_event_work);
+ 	router = container_of(nb, struct mlxsw_sp_router, fib_nb);
+ 	fib_work->mlxsw_sp = router->mlxsw_sp;
+ 	fib_work->event = event;
+ 
+ 	switch (event) {
+ 	case FIB_EVENT_ENTRY_REPLACE: /* fall through */
+ 	case FIB_EVENT_ENTRY_APPEND: /* fall through */
+ 	case FIB_EVENT_ENTRY_ADD: /* fall through */
+ 	case FIB_EVENT_ENTRY_DEL:
+ 		memcpy(&fib_work->fen_info, ptr, sizeof(fib_work->fen_info));
+ 		/* Take referece on fib_info to prevent it from being
+ 		 * freed while work is queued. Release it afterwards.
+ 		 */
+ 		fib_info_hold(fib_work->fen_info.fi);
+ 		break;
+ 	case FIB_EVENT_RULE_ADD: /* fall through */
+ 	case FIB_EVENT_RULE_DEL:
+ 		memcpy(&fib_work->fr_info, ptr, sizeof(fib_work->fr_info));
+ 		fib_rule_get(fib_work->fr_info.rule);
+ 		break;
+ 	case FIB_EVENT_NH_ADD: /* fall through */
+ 	case FIB_EVENT_NH_DEL:
+ 		memcpy(&fib_work->fnh_info, ptr, sizeof(fib_work->fnh_info));
+ 		fib_info_hold(fib_work->fnh_info.fib_nh->nh_parent);
+ 		break;
+ 	}
+ 
+ 	mlxsw_core_schedule_work(&fib_work->work);
+ 
+ 	return NOTIFY_DONE;
+ }
+ 
+ static struct mlxsw_sp_rif *
+ mlxsw_sp_rif_find_by_dev(const struct mlxsw_sp *mlxsw_sp,
+ 			 const struct net_device *dev)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS); i++)
+ 		if (mlxsw_sp->router->rifs[i] &&
+ 		    mlxsw_sp->router->rifs[i]->dev == dev)
+ 			return mlxsw_sp->router->rifs[i];
+ 
+ 	return NULL;
+ }
+ 
++>>>>>>> 64e5e8252d69 (mlxsw: spectrum_router: Ignore address families other than IPv4)
  static int mlxsw_sp_router_rif_disable(struct mlxsw_sp *mlxsw_sp, u16 rif)
  {
  	char ritr_pl[MLXSW_REG_RITR_LEN];
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
