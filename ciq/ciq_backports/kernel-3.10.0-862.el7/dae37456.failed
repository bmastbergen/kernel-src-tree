net/mlx5: Support for attaching multiple underlay QPs to root flow table

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Support for attaching multiple underlay QPs to root flow table (Kamal Heib) [1517570 1456694]
Rebuild_FUZZ: 97.14%
commit-author Alex Vesker <valex@mellanox.com>
commit dae37456c8ac3afe8d5f306717f2b75ed5ca38d9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/dae37456.failed

Previous support allowed connecting only a single QPN to the FT.
Now using a linked list multiple QPNs can be attached to the same FT.

Supporting attaching multiple underlay QPs is required for PKEY
support in which child and parent share the same FT.

The actual attaching/detaching FW commands will be called inside the
function symmetrically.

This change requires a change in IPoIB open and close functions, the
attaching/detaching to/from the FT is done each time we open/close.

	Signed-off-by: Alex Vesker <valex@mellanox.com>
	Reviewed-by: Maor Gottlieb <maorg@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
(cherry picked from commit dae37456c8ac3afe8d5f306717f2b75ed5ca38d9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
#	drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.h
#	drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
#	drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
#	drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
index 0c27f482f5f9,881e2e55840c..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
@@@ -40,7 -40,8 +40,12 @@@
  #include "eswitch.h"
  
  int mlx5_cmd_update_root_ft(struct mlx5_core_dev *dev,
++<<<<<<< HEAD
 +			    struct mlx5_flow_table *ft)
++=======
+ 			    struct mlx5_flow_table *ft, u32 underlay_qpn,
+ 			    bool disconnect)
++>>>>>>> dae37456c8ac (net/mlx5: Support for attaching multiple underlay QPs to root flow table)
  {
  	u32 in[MLX5_ST_SZ_DW(set_flow_table_root_in)]   = {0};
  	u32 out[MLX5_ST_SZ_DW(set_flow_table_root_out)] = {0};
@@@ -52,7 -53,16 +57,20 @@@
  	MLX5_SET(set_flow_table_root_in, in, opcode,
  		 MLX5_CMD_OP_SET_FLOW_TABLE_ROOT);
  	MLX5_SET(set_flow_table_root_in, in, table_type, ft->type);
++<<<<<<< HEAD
 +	MLX5_SET(set_flow_table_root_in, in, table_id, ft->id);
++=======
+ 
+ 	if (disconnect) {
+ 		MLX5_SET(set_flow_table_root_in, in, op_mod, 1);
+ 		MLX5_SET(set_flow_table_root_in, in, table_id, 0);
+ 	} else {
+ 		MLX5_SET(set_flow_table_root_in, in, op_mod, 0);
+ 		MLX5_SET(set_flow_table_root_in, in, table_id, ft->id);
+ 	}
+ 
+ 	MLX5_SET(set_flow_table_root_in, in, underlay_qpn, underlay_qpn);
++>>>>>>> dae37456c8ac (net/mlx5: Support for attaching multiple underlay QPs to root flow table)
  	if (ft->vport) {
  		MLX5_SET(set_flow_table_root_in, in, vport_number, ft->vport);
  		MLX5_SET(set_flow_table_root_in, in, other_vport, 1);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.h
index 939d039f0c14,71e2d0f37ad9..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.h
@@@ -71,7 -71,8 +71,12 @@@ int mlx5_cmd_delete_fte(struct mlx5_cor
  			unsigned int index);
  
  int mlx5_cmd_update_root_ft(struct mlx5_core_dev *dev,
++<<<<<<< HEAD
 +			    struct mlx5_flow_table *ft);
++=======
+ 			    struct mlx5_flow_table *ft, u32 underlay_qpn,
+ 			    bool disconnect);
++>>>>>>> dae37456c8ac (net/mlx5: Support for attaching multiple underlay QPs to root flow table)
  
  int mlx5_cmd_fc_alloc(struct mlx5_core_dev *dev, u32 *id);
  int mlx5_cmd_fc_free(struct mlx5_core_dev *dev, u32 id);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
index f60baa93f1dc,8a1a7ba9fe53..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
@@@ -650,10 -704,24 +652,28 @@@ static int update_root_ft_create(struc
  	if (ft->level >= min_level)
  		return 0;
  
++<<<<<<< HEAD
 +	err = mlx5_cmd_update_root_ft(root->dev, ft);
++=======
+ 	if (list_empty(&root->underlay_qpns)) {
+ 		/* Don't set any QPN (zero) in case QPN list is empty */
+ 		qpn = 0;
+ 		err = mlx5_cmd_update_root_ft(root->dev, ft, qpn, false);
+ 	} else {
+ 		list_for_each_entry(uqp, &root->underlay_qpns, list) {
+ 			qpn = uqp->qpn;
+ 			err = mlx5_cmd_update_root_ft(root->dev, ft, qpn,
+ 						      false);
+ 			if (err)
+ 				break;
+ 		}
+ 	}
+ 
++>>>>>>> dae37456c8ac (net/mlx5: Support for attaching multiple underlay QPs to root flow table)
  	if (err)
- 		mlx5_core_warn(root->dev, "Update root flow table of id=%u failed\n",
- 			       ft->id);
+ 		mlx5_core_warn(root->dev,
+ 			       "Update root flow table of id(%u) qpn(%d) failed\n",
+ 			       ft->id, qpn);
  	else
  		root->root_ft = ft;
  
@@@ -1488,16 -1686,34 +1511,39 @@@ static int update_root_ft_destroy(struc
  		return 0;
  
  	new_root_ft = find_next_ft(ft);
++<<<<<<< HEAD
 +	if (new_root_ft) {
 +		int err = mlx5_cmd_update_root_ft(root->dev, new_root_ft);
++=======
++>>>>>>> dae37456c8ac (net/mlx5: Support for attaching multiple underlay QPs to root flow table)
  
- 		if (err) {
- 			mlx5_core_warn(root->dev, "Update root flow table of id=%u failed\n",
- 				       ft->id);
- 			return err;
+ 	if (!new_root_ft) {
+ 		root->root_ft = NULL;
+ 		return 0;
+ 	}
+ 
+ 	if (list_empty(&root->underlay_qpns)) {
+ 		/* Don't set any QPN (zero) in case QPN list is empty */
+ 		qpn = 0;
+ 		err = mlx5_cmd_update_root_ft(root->dev, new_root_ft, qpn,
+ 					      false);
+ 	} else {
+ 		list_for_each_entry(uqp, &root->underlay_qpns, list) {
+ 			qpn = uqp->qpn;
+ 			err = mlx5_cmd_update_root_ft(root->dev, new_root_ft,
+ 						      qpn, false);
+ 			if (err)
+ 				break;
  		}
  	}
- 	root->root_ft = new_root_ft;
+ 
+ 	if (err)
+ 		mlx5_core_warn(root->dev,
+ 			       "Update root flow table of id(%u) qpn(%d) failed\n",
+ 			       ft->id, qpn);
+ 	else
+ 		root->root_ft = new_root_ft;
+ 
  	return 0;
  }
  
@@@ -2064,3 -2279,80 +2112,83 @@@ err
  	mlx5_cleanup_fs(dev);
  	return err;
  }
++<<<<<<< HEAD
++=======
+ 
+ int mlx5_fs_add_rx_underlay_qpn(struct mlx5_core_dev *dev, u32 underlay_qpn)
+ {
+ 	struct mlx5_flow_root_namespace *root = dev->priv.steering->root_ns;
+ 	struct mlx5_ft_underlay_qp *new_uqp;
+ 	int err = 0;
+ 
+ 	new_uqp = kzalloc(sizeof(*new_uqp), GFP_KERNEL);
+ 	if (!new_uqp)
+ 		return -ENOMEM;
+ 
+ 	mutex_lock(&root->chain_lock);
+ 
+ 	if (!root->root_ft) {
+ 		err = -EINVAL;
+ 		goto update_ft_fail;
+ 	}
+ 
+ 	err = mlx5_cmd_update_root_ft(dev, root->root_ft, underlay_qpn, false);
+ 	if (err) {
+ 		mlx5_core_warn(dev, "Failed adding underlay QPN (%u) to root FT err(%d)\n",
+ 			       underlay_qpn, err);
+ 		goto update_ft_fail;
+ 	}
+ 
+ 	new_uqp->qpn = underlay_qpn;
+ 	list_add_tail(&new_uqp->list, &root->underlay_qpns);
+ 
+ 	mutex_unlock(&root->chain_lock);
+ 
+ 	return 0;
+ 
+ update_ft_fail:
+ 	mutex_unlock(&root->chain_lock);
+ 	kfree(new_uqp);
+ 	return err;
+ }
+ EXPORT_SYMBOL(mlx5_fs_add_rx_underlay_qpn);
+ 
+ int mlx5_fs_remove_rx_underlay_qpn(struct mlx5_core_dev *dev, u32 underlay_qpn)
+ {
+ 	struct mlx5_flow_root_namespace *root = dev->priv.steering->root_ns;
+ 	struct mlx5_ft_underlay_qp *uqp;
+ 	bool found = false;
+ 	int err = 0;
+ 
+ 	mutex_lock(&root->chain_lock);
+ 	list_for_each_entry(uqp, &root->underlay_qpns, list) {
+ 		if (uqp->qpn == underlay_qpn) {
+ 			found = true;
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (!found) {
+ 		mlx5_core_warn(dev, "Failed finding underlay qp (%u) in qpn list\n",
+ 			       underlay_qpn);
+ 		err = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	err = mlx5_cmd_update_root_ft(dev, root->root_ft, underlay_qpn, true);
+ 	if (err)
+ 		mlx5_core_warn(dev, "Failed removing underlay QPN (%u) from root FT err(%d)\n",
+ 			       underlay_qpn, err);
+ 
+ 	list_del(&uqp->list);
+ 	mutex_unlock(&root->chain_lock);
+ 	kfree(uqp);
+ 
+ 	return 0;
+ 
+ out:
+ 	mutex_unlock(&root->chain_lock);
+ 	return err;
+ }
+ EXPORT_SYMBOL(mlx5_fs_remove_rx_underlay_qpn);
++>>>>>>> dae37456c8ac (net/mlx5: Support for attaching multiple underlay QPs to root flow table)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
index c840ec9c1fc4,9bc048a89bc0..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
@@@ -145,6 -147,23 +145,26 @@@ struct mlx5_fc 
  	struct mlx5_fc_cache cache ____cacheline_aligned_in_smp;
  };
  
++<<<<<<< HEAD
++=======
+ struct mlx5_ft_underlay_qp {
+ 	struct list_head list;
+ 	u32 qpn;
+ };
+ 
+ #define MLX5_FTE_MATCH_PARAM_RESERVED	reserved_at_600
+ /* Calculate the fte_match_param length and without the reserved length.
+  * Make sure the reserved field is the last.
+  */
+ #define MLX5_ST_SZ_DW_MATCH_PARAM					    \
+ 	((MLX5_BYTE_OFF(fte_match_param, MLX5_FTE_MATCH_PARAM_RESERVED) / sizeof(u32)) + \
+ 	 BUILD_BUG_ON_ZERO(MLX5_ST_SZ_BYTES(fte_match_param) !=		     \
+ 			   MLX5_FLD_SZ_BYTES(fte_match_param,		     \
+ 					     MLX5_FTE_MATCH_PARAM_RESERVED) +\
+ 			   MLX5_BYTE_OFF(fte_match_param,		     \
+ 					 MLX5_FTE_MATCH_PARAM_RESERVED)))
+ 
++>>>>>>> dae37456c8ac (net/mlx5: Support for attaching multiple underlay QPs to root flow table)
  /* Type of children is mlx5_flow_rule */
  struct fs_fte {
  	struct fs_node			node;
@@@ -196,6 -217,7 +216,10 @@@ struct mlx5_flow_root_namespace 
  	struct mlx5_flow_table		*root_ft;
  	/* Should be held when chaining flow tables */
  	struct mutex			chain_lock;
++<<<<<<< HEAD
++=======
+ 	struct list_head		underlay_qpns;
++>>>>>>> dae37456c8ac (net/mlx5: Support for attaching multiple underlay QPs to root flow table)
  };
  
  int mlx5_init_fc_stats(struct mlx5_core_dev *dev);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
