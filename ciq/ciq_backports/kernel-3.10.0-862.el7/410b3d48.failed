bridge: fdb: add proper lock checks in searching functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
commit 410b3d48f5111a28bb8d4c3d3dc5984c1baf7fc9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/410b3d48.failed

In order to avoid new errors add checks to br_fdb_find and fdb_find_rcu
functions. The first requires hash_lock, the second obviously RCU.

	Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 410b3d48f5111a28bb8d4c3d3dc5984c1baf7fc9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_fdb.c
diff --cc net/bridge/br_fdb.c
index 9836c1e87ee0,da5ed7d0a3c8..000000000000
--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@@ -86,6 -83,47 +86,50 @@@ static void fdb_rcu_free(struct rcu_hea
  	kmem_cache_free(br_fdb_cache, ent);
  }
  
++<<<<<<< HEAD
++=======
+ static struct net_bridge_fdb_entry *fdb_find_rcu(struct hlist_head *head,
+ 						 const unsigned char *addr,
+ 						 __u16 vid)
+ {
+ 	struct net_bridge_fdb_entry *f;
+ 
+ 	WARN_ON_ONCE(!rcu_read_lock_held());
+ 
+ 	hlist_for_each_entry_rcu(f, head, hlist)
+ 		if (ether_addr_equal(f->addr.addr, addr) && f->vlan_id == vid)
+ 			break;
+ 
+ 	return f;
+ }
+ 
+ /* requires bridge hash_lock */
+ static struct net_bridge_fdb_entry *br_fdb_find(struct net_bridge *br,
+ 						const unsigned char *addr,
+ 						__u16 vid)
+ {
+ 	struct hlist_head *head = &br->hash[br_mac_hash(addr, vid)];
+ 	struct net_bridge_fdb_entry *fdb;
+ 
+ 	WARN_ON_ONCE(!br_hash_lock_held(br));
+ 
+ 	rcu_read_lock();
+ 	fdb = fdb_find_rcu(head, addr, vid);
+ 	rcu_read_unlock();
+ 
+ 	return fdb;
+ }
+ 
+ struct net_bridge_fdb_entry *br_fdb_find_rcu(struct net_bridge *br,
+ 					     const unsigned char *addr,
+ 					     __u16 vid)
+ {
+ 	struct hlist_head *head = &br->hash[br_mac_hash(addr, vid)];
+ 
+ 	return fdb_find_rcu(head, addr, vid);
+ }
+ 
++>>>>>>> 410b3d48f511 (bridge: fdb: add proper lock checks in searching functions)
  /* When a static FDB entry is added, the mac address from the entry is
   * added to the bridge private HW address list and all required ports
   * are then updated with the new information.
* Unmerged path net/bridge/br_fdb.c
diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 14d36b8b30c9..e39bb0b50f3f 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -533,6 +533,15 @@ int br_fdb_external_learn_add(struct net_bridge *br, struct net_bridge_port *p,
 int br_fdb_external_learn_del(struct net_bridge *br, struct net_bridge_port *p,
 			      const unsigned char *addr, u16 vid);
 
+static inline bool br_hash_lock_held(struct net_bridge *br)
+{
+#ifdef CONFIG_LOCKDEP
+	return lockdep_is_held(&br->hash_lock);
+#else
+	return true;
+#endif
+}
+
 /* br_forward.c */
 enum br_pkt_type {
 	BR_PKT_UNICAST,
