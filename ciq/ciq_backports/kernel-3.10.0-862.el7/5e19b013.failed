lib: bitmap: add alignment offset for bitmap_find_next_zero_area()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [lib] bitmap: add alignment offset for bitmap_find_next_zero_area() (Rob Clark) [1470097]
Rebuild_FUZZ: 96.06%
commit-author Michal Nazarewicz <mina86@mina86.com>
commit 5e19b013f55a884c59a14391b22138899d1cc4cc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5e19b013.failed

Add a bitmap_find_next_zero_area_off() function which works like
bitmap_find_next_zero_area() function except it allows an offset to be
specified when alignment is checked.  This lets caller request a bit such
that its number plus the offset is aligned according to the mask.

[gregory.0xf0@gmail.com: Retrieved from https://patchwork.linuxtv.org/patch/6254/ and updated documentation]
	Signed-off-by: Michal Nazarewicz <mina86@mina86.com>
	Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
	Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
	Signed-off-by: Gregory Fong <gregory.0xf0@gmail.com>
	Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
	Cc: Kukjin Kim <kgene.kim@samsung.com>
	Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
	Cc: Laura Abbott <lauraa@codeaurora.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 5e19b013f55a884c59a14391b22138899d1cc4cc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/bitmap.h
diff --cc include/linux/bitmap.h
index 251c8b2528e3,34e020c23644..000000000000
--- a/include/linux/bitmap.h
+++ b/include/linux/bitmap.h
@@@ -102,26 -100,51 +103,61 @@@ extern void __bitmap_shift_right(unsign
  extern void __bitmap_shift_left(unsigned long *dst,
                          const unsigned long *src, int shift, int bits);
  extern int __bitmap_and(unsigned long *dst, const unsigned long *bitmap1,
 -			const unsigned long *bitmap2, unsigned int nbits);
 +			const unsigned long *bitmap2, int bits);
  extern void __bitmap_or(unsigned long *dst, const unsigned long *bitmap1,
 -			const unsigned long *bitmap2, unsigned int nbits);
 +			const unsigned long *bitmap2, int bits);
  extern void __bitmap_xor(unsigned long *dst, const unsigned long *bitmap1,
 -			const unsigned long *bitmap2, unsigned int nbits);
 +			const unsigned long *bitmap2, int bits);
  extern int __bitmap_andnot(unsigned long *dst, const unsigned long *bitmap1,
 -			const unsigned long *bitmap2, unsigned int nbits);
 +			const unsigned long *bitmap2, int bits);
  extern int __bitmap_intersects(const unsigned long *bitmap1,
 -			const unsigned long *bitmap2, unsigned int nbits);
 +			const unsigned long *bitmap2, int bits);
  extern int __bitmap_subset(const unsigned long *bitmap1,
 -			const unsigned long *bitmap2, unsigned int nbits);
 -extern int __bitmap_weight(const unsigned long *bitmap, unsigned int nbits);
 -
 +			const unsigned long *bitmap2, int bits);
 +extern int __bitmap_weight(const unsigned long *bitmap, int bits);
 +
++<<<<<<< HEAD
 +extern void bitmap_set(unsigned long *map, int i, int len);
 +extern void bitmap_clear(unsigned long *map, int start, int nr);
 +extern unsigned long bitmap_find_next_zero_area(unsigned long *map,
 +					 unsigned long size,
 +					 unsigned long start,
 +					 unsigned int nr,
 +					 unsigned long align_mask);
++=======
+ extern void bitmap_set(unsigned long *map, unsigned int start, int len);
+ extern void bitmap_clear(unsigned long *map, unsigned int start, int len);
+ 
+ extern unsigned long bitmap_find_next_zero_area_off(unsigned long *map,
+ 						    unsigned long size,
+ 						    unsigned long start,
+ 						    unsigned int nr,
+ 						    unsigned long align_mask,
+ 						    unsigned long align_offset);
+ 
+ /**
+  * bitmap_find_next_zero_area - find a contiguous aligned zero area
+  * @map: The address to base the search on
+  * @size: The bitmap size in bits
+  * @start: The bitnumber to start searching at
+  * @nr: The number of zeroed bits we're looking for
+  * @align_mask: Alignment mask for zero area
+  *
+  * The @align_mask should be one less than a power of 2; the effect is that
+  * the bit offset of all zero areas this function finds is multiples of that
+  * power of 2. A @align_mask of 0 means no alignment is required.
+  */
+ static inline unsigned long
+ bitmap_find_next_zero_area(unsigned long *map,
+ 			   unsigned long size,
+ 			   unsigned long start,
+ 			   unsigned int nr,
+ 			   unsigned long align_mask)
+ {
+ 	return bitmap_find_next_zero_area_off(map, size, start, nr,
+ 					      align_mask, 0);
+ }
++>>>>>>> 5e19b013f55a (lib: bitmap: add alignment offset for bitmap_find_next_zero_area())
  
  extern int bitmap_scnprintf(char *buf, unsigned int len,
  			const unsigned long *src, int nbits);
* Unmerged path include/linux/bitmap.h
diff --git a/lib/bitmap.c b/lib/bitmap.c
index 343245aa3887..49b6de9d3ab0 100644
--- a/lib/bitmap.c
+++ b/lib/bitmap.c
@@ -319,30 +319,32 @@ void bitmap_clear(unsigned long *map, int start, int nr)
 }
 EXPORT_SYMBOL(bitmap_clear);
 
-/*
- * bitmap_find_next_zero_area - find a contiguous aligned zero area
+/**
+ * bitmap_find_next_zero_area_off - find a contiguous aligned zero area
  * @map: The address to base the search on
  * @size: The bitmap size in bits
  * @start: The bitnumber to start searching at
  * @nr: The number of zeroed bits we're looking for
  * @align_mask: Alignment mask for zero area
+ * @align_offset: Alignment offset for zero area.
  *
  * The @align_mask should be one less than a power of 2; the effect is that
- * the bit offset of all zero areas this function finds is multiples of that
- * power of 2. A @align_mask of 0 means no alignment is required.
+ * the bit offset of all zero areas this function finds plus @align_offset
+ * is multiple of that power of 2.
  */
-unsigned long bitmap_find_next_zero_area(unsigned long *map,
-					 unsigned long size,
-					 unsigned long start,
-					 unsigned int nr,
-					 unsigned long align_mask)
+unsigned long bitmap_find_next_zero_area_off(unsigned long *map,
+					     unsigned long size,
+					     unsigned long start,
+					     unsigned int nr,
+					     unsigned long align_mask,
+					     unsigned long align_offset)
 {
 	unsigned long index, end, i;
 again:
 	index = find_next_zero_bit(map, size, start);
 
 	/* Align allocation */
-	index = __ALIGN_MASK(index, align_mask);
+	index = __ALIGN_MASK(index + align_offset, align_mask) - align_offset;
 
 	end = index + nr;
 	if (end > size)
@@ -354,7 +356,7 @@ again:
 	}
 	return index;
 }
-EXPORT_SYMBOL(bitmap_find_next_zero_area);
+EXPORT_SYMBOL(bitmap_find_next_zero_area_off);
 
 /*
  * Bitmap printing & parsing functions: first version by Nadia Yvette Chambers,
