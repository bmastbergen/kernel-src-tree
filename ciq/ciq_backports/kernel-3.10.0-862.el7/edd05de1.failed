scsi: qla2xxx: Changes to support N2N logins

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Changes to support N2N logins (Chad Dupuis) [1316281]
Rebuild_FUZZ: 92.68%
commit-author Duane Grigsby <duane.grigsby@cavium.com>
commit edd05de1975927b51b4e8e1135ef4d6130dfd17c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/edd05de1.failed

If we discovered a topology that is N2N then we will issue a login to
the target. If our WWPN is bigger than the target's WWPN then we will
initiate login, otherwise we will just wait for the target to initiate
login.

[mkp: many whitespace errors]

	Signed-off-by: Duane Grigsby <duane.grigsby@cavium.com>
	Signed-off-by: Michael Hernandez <michael.hernandez@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Tested-by: Ewan D. Milne <emilne@redhat.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit edd05de1975927b51b4e8e1135ef4d6130dfd17c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_gbl.h
#	drivers/scsi/qla2xxx/qla_init.c
#	drivers/scsi/qla2xxx/qla_iocb.c
#	drivers/scsi/qla2xxx/qla_isr.c
diff --cc drivers/scsi/qla2xxx/qla_def.h
index 3f28536dc812,01a9b8971e88..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -309,6 -315,31 +309,34 @@@ struct srb_cmd 
  /* To identify if a srb is of T10-CRC type. @sp => srb_t pointer */
  #define IS_PROT_IO(sp)	(sp->flags & SRB_CRC_CTX_DSD_VALID)
  
++<<<<<<< HEAD
++=======
+ struct els_logo_payload {
+ 	uint8_t opcode;
+ 	uint8_t rsvd[3];
+ 	uint8_t s_id[3];
+ 	uint8_t rsvd1[1];
+ 	uint8_t wwpn[WWN_SIZE];
+ };
+ 
+ struct els_plogi_payload {
+ 	uint8_t opcode;
+ 	uint8_t rsvd[3];
+ 	uint8_t data[112];
+ };
+ 
+ struct ct_arg {
+ 	void		*iocb;
+ 	u16		nport_handle;
+ 	dma_addr_t	req_dma;
+ 	dma_addr_t	rsp_dma;
+ 	u32		req_size;
+ 	u32		rsp_size;
+ 	void		*req;
+ 	void		*rsp;
+ };
+ 
++>>>>>>> edd05de19759 (scsi: qla2xxx: Changes to support N2N logins)
  /*
   * SRB extensions.
   */
@@@ -319,9 -350,33 +347,34 @@@ struct srb_iocb 
  #define SRB_LOGIN_RETRIED	BIT_0
  #define SRB_LOGIN_COND_PLOGI	BIT_1
  #define SRB_LOGIN_SKIP_PRLI	BIT_2
 -#define SRB_LOGIN_NVME_PRLI	BIT_3
  			uint16_t data[2];
 -			u32 iop[2];
  		} logio;
  		struct {
++<<<<<<< HEAD
++=======
+ #define ELS_DCMD_TIMEOUT 20
+ #define ELS_DCMD_LOGO 0x5
+ 			uint32_t flags;
+ 			uint32_t els_cmd;
+ 			struct completion comp;
+ 			struct els_logo_payload *els_logo_pyld;
+ 			dma_addr_t els_logo_pyld_dma;
+ 		} els_logo;
+ 		struct {
+ #define ELS_DCMD_PLOGI 0x3
+ 			uint32_t flags;
+ 			uint32_t els_cmd;
+ 			struct completion comp;
+ 			struct els_plogi_payload *els_plogi_pyld;
+ 			struct els_plogi_payload *els_resp_pyld;
+ 			dma_addr_t els_plogi_pyld_dma;
+ 			dma_addr_t els_resp_pyld_dma;
+ 			uint32_t	fw_status[3];
+ 			__le16	comp_status;
+ 			__le16	len;
+ 		} els_plogi;
+ 		struct {
++>>>>>>> edd05de19759 (scsi: qla2xxx: Changes to support N2N logins)
  			/*
  			 * Values for flags field below are as
  			 * defined in tsk_mgmt_entry struct
@@@ -2046,16 -2366,48 +2099,35 @@@ typedef struct fc_port 
  	u32 supported_classes;
  
  	uint8_t fc4_type;
 -	uint8_t	fc4f_nvme;
  	uint8_t scan_state;
+ 	uint8_t n2n_flag;
  
  	unsigned long last_queue_full;
  	unsigned long last_ramp_up;
  
  	uint16_t port_id;
  
 -	struct nvme_fc_remote_port *nvme_remote_port;
 -
  	unsigned long retry_delay_timestamp;
++<<<<<<< HEAD
++=======
+ 	struct qla_tgt_sess *tgt_session;
+ 	struct ct_sns_desc ct_desc;
+ 	enum discovery_state disc_state;
+ 	enum login_state fw_login_state;
+ 	unsigned long plogi_nack_done_deadline;
+ 
+ 	u32 login_gen, last_login_gen;
+ 	u32 rscn_gen, last_rscn_gen;
+ 	u32 chip_reset;
+ 	struct list_head gnl_entry;
+ 	struct work_struct del_work;
+ 	u8 iocb[IOCB_SIZE];
+ 	u8 current_login_state;
+ 	u8 last_login_state;
+ 	struct completion n2n_done;
++>>>>>>> edd05de19759 (scsi: qla2xxx: Changes to support N2N logins)
  } fc_port_t;
  
 -#define QLA_FCPORT_SCAN		1
 -#define QLA_FCPORT_FOUND	2
 -
 -struct event_arg {
 -	enum fcport_mgt_event	event;
 -	fc_port_t		*fcport;
 -	srb_t			*sp;
 -	port_id_t		id;
 -	u16			data[2], rc;
 -	u8			port_name[WWN_SIZE];
 -	u32			iop[2];
 -};
 -
  #include "qla_mr.h"
  
  /*
@@@ -3698,7 -4243,15 +3770,14 @@@ typedef struct scsi_qla_host 
  	atomic_t	vref_count;
  	struct qla8044_reset_template reset_tmplt;
  	uint16_t	bbcr;
 -	struct name_list_extended gnl;
 -	/* Count of active session/fcport */
 -	int fcport_count;
 -	wait_queue_head_t fcport_waitQ;
  	wait_queue_head_t vref_waitq;
++<<<<<<< HEAD
++=======
+ 	uint8_t min_link_speed_feat;
+ 	uint8_t n2n_node_name[WWN_SIZE];
+ 	uint8_t n2n_port_name[WWN_SIZE];
+ 	uint16_t	n2n_id;
++>>>>>>> edd05de19759 (scsi: qla2xxx: Changes to support N2N logins)
  } scsi_qla_host_t;
  
  struct qla27xx_image_status {
diff --cc drivers/scsi/qla2xxx/qla_gbl.h
index c4f068539cd6,0a23af5aa479..000000000000
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@@ -44,6 -44,10 +44,13 @@@ extern int qla2x00_find_new_loop_id(scs
  extern int qla2x00_fabric_login(scsi_qla_host_t *, fc_port_t *, uint16_t *);
  extern int qla2x00_local_device_login(scsi_qla_host_t *, fc_port_t *);
  
++<<<<<<< HEAD
++=======
+ extern int qla24xx_els_dcmd_iocb(scsi_qla_host_t *, int, port_id_t);
+ extern int qla24xx_els_dcmd2_iocb(scsi_qla_host_t *, int, fc_port_t *,
+ 				  port_id_t);
+ 
++>>>>>>> edd05de19759 (scsi: qla2xxx: Changes to support N2N logins)
  extern void qla2x00_update_fcports(scsi_qla_host_t *);
  
  extern int qla2x00_abort_isp(scsi_qla_host_t *);
@@@ -448,6 -483,18 +455,21 @@@ qla2x00_dump_mctp_data(scsi_qla_host_t 
  extern int
  qla26xx_dport_diagnostics(scsi_qla_host_t *, void *, uint, uint);
  
++<<<<<<< HEAD
++=======
+ int qla24xx_send_mb_cmd(struct scsi_qla_host *, mbx_cmd_t *);
+ int qla24xx_gpdb_wait(struct scsi_qla_host *, fc_port_t *, u8);
+ int qla24xx_gidlist_wait(struct scsi_qla_host *, void *, dma_addr_t,
+     uint16_t *);
+ int __qla24xx_parse_gpdb(struct scsi_qla_host *, fc_port_t *,
+ 	struct port_database_24xx *);
+ int qla24xx_get_port_login_templ(scsi_qla_host_t *, dma_addr_t,
+ 				 void *, uint16_t);
+ 
+ extern int qla27xx_get_zio_threshold(scsi_qla_host_t *, uint16_t *);
+ extern int qla27xx_set_zio_threshold(scsi_qla_host_t *, uint16_t);
+ 
++>>>>>>> edd05de19759 (scsi: qla2xxx: Changes to support N2N logins)
  /*
   * Global Function Prototypes in qla_isr.c source file.
   */
diff --cc drivers/scsi/qla2xxx/qla_init.c
index 998b579c233c,1c53c0774e24..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -439,13 -1419,41 +439,42 @@@ qla24xx_async_abort_command(srb_t *sp
  	return qla24xx_async_abort_cmd(sp);
  }
  
 -static void
 -qla24xx_handle_prli_done_event(struct scsi_qla_host *vha, struct event_arg *ea)
 +void
 +qla2x00_async_login_done(struct scsi_qla_host *vha, fc_port_t *fcport,
 +    uint16_t *data)
  {
 -	switch (ea->data[0]) {
 -	case MBS_COMMAND_COMPLETE:
 -		ql_dbg(ql_dbg_disc, vha, 0x2118,
 -		    "%s %d %8phC post gpdb\n",
 -		    __func__, __LINE__, ea->fcport->port_name);
 +	int rval;
  
++<<<<<<< HEAD
 +	switch (data[0]) {
++=======
+ 		ea->fcport->chip_reset = vha->hw->base_qpair->chip_reset;
+ 		ea->fcport->logout_on_delete = 1;
+ 		qla24xx_post_gpdb_work(vha, ea->fcport, 0);
+ 		break;
+ 	default:
+ 		if (ea->fcport->n2n_flag) {
+ 			ql_dbg(ql_dbg_disc, vha, 0x2118,
+ 				"%s %d %8phC post fc4 prli\n",
+ 				__func__, __LINE__, ea->fcport->port_name);
+ 			ea->fcport->fc4f_nvme = 0;
+ 			ea->fcport->n2n_flag = 0;
+ 			qla24xx_post_prli_work(vha, ea->fcport);
+ 		}
+ 		ql_dbg(ql_dbg_disc, vha, 0x2119,
+ 		    "%s %d %8phC unhandle event of %x\n",
+ 		    __func__, __LINE__, ea->fcport->port_name, ea->data[0]);
+ 		break;
+ 	}
+ }
+ 
+ static void
+ qla24xx_handle_plogi_done_event(struct scsi_qla_host *vha, struct event_arg *ea)
+ {
+ 	port_id_t cid;	/* conflict Nport id */
+ 
+ 	switch (ea->data[0]) {
++>>>>>>> edd05de19759 (scsi: qla2xxx: Changes to support N2N logins)
  	case MBS_COMMAND_COMPLETE:
  		/*
  		 * Driver must validate login state - If PRLI not complete,
@@@ -3226,12 -4596,16 +3365,22 @@@ qla2x00_configure_local_loop(scsi_qla_h
  			    "Failed to retrieve fcport information "
  			    "-- get_port_database=%x, loop_id=0x%04x.\n",
  			    rval2, new_fcport->loop_id);
++<<<<<<< HEAD
 +			ql_dbg(ql_dbg_disc, vha, 0x201b,
 +			    "Scheduling resync.\n");
 +			set_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);
 +			continue;
++=======
+ 			/* Skip retry if N2N */
+ 			if (ha->current_topology != ISP_CFG_N) {
+ 				ql_dbg(ql_dbg_disc, vha, 0x2105,
+ 				    "Scheduling resync.\n");
+ 				set_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);
+ 				continue;
+ 			}
++>>>>>>> edd05de19759 (scsi: qla2xxx: Changes to support N2N logins)
  		}
  
 -		spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
  		/* Check for matching device in port list. */
  		found = 0;
  		fcport = NULL;
@@@ -6292,6 -7671,16 +6441,19 @@@ qla81xx_nvram_config(scsi_qla_host_t *v
  		vha->flags.process_response_queue = 1;
  	}
  
++<<<<<<< HEAD
++=======
+ 	 /* enable RIDA Format2 */
+ 	if (qla_tgt_mode_enabled(vha) || qla_dual_mode_enabled(vha))
+ 		icb->firmware_options_3 |= BIT_0;
+ 
+ 	if (IS_QLA27XX(ha)) {
+ 		icb->firmware_options_3 |= BIT_8;
+ 		ql_dbg(ql_log_info, vha, 0x0075,
+ 		    "Enabling direct connection.\n");
+ 	}
+ 
++>>>>>>> edd05de19759 (scsi: qla2xxx: Changes to support N2N logins)
  	if (rval) {
  		ql_log(ql_log_warn, vha, 0x0076,
  		    "NVRAM configuration failed.\n");
diff --cc drivers/scsi/qla2xxx/qla_iocb.c
index ff2ecaf39d3d,d810a447cb4a..000000000000
--- a/drivers/scsi/qla2xxx/qla_iocb.c
+++ b/drivers/scsi/qla2xxx/qla_iocb.c
@@@ -2306,9 -2370,367 +2306,369 @@@ qla24xx_tm_iocb(srb_t *sp, struct tsk_m
  }
  
  static void
++<<<<<<< HEAD
++=======
+ qla2x00_els_dcmd_sp_free(void *data)
+ {
+ 	srb_t *sp = data;
+ 	struct srb_iocb *elsio = &sp->u.iocb_cmd;
+ 
+ 	kfree(sp->fcport);
+ 
+ 	if (elsio->u.els_logo.els_logo_pyld)
+ 		dma_free_coherent(&sp->vha->hw->pdev->dev, DMA_POOL_SIZE,
+ 		    elsio->u.els_logo.els_logo_pyld,
+ 		    elsio->u.els_logo.els_logo_pyld_dma);
+ 
+ 	del_timer(&elsio->timer);
+ 	qla2x00_rel_sp(sp);
+ }
+ 
+ static void
+ qla2x00_els_dcmd_iocb_timeout(void *data)
+ {
+ 	srb_t *sp = data;
+ 	fc_port_t *fcport = sp->fcport;
+ 	struct scsi_qla_host *vha = sp->vha;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct srb_iocb *lio = &sp->u.iocb_cmd;
+ 	unsigned long flags = 0;
+ 
+ 	ql_dbg(ql_dbg_io, vha, 0x3069,
+ 	    "%s Timeout, hdl=%x, portid=%02x%02x%02x\n",
+ 	    sp->name, sp->handle, fcport->d_id.b.domain, fcport->d_id.b.area,
+ 	    fcport->d_id.b.al_pa);
+ 
+ 	/* Abort the exchange */
+ 	spin_lock_irqsave(&ha->hardware_lock, flags);
+ 	if (ha->isp_ops->abort_command(sp)) {
+ 		ql_dbg(ql_dbg_io, vha, 0x3070,
+ 		    "mbx abort_command failed.\n");
+ 	} else {
+ 		ql_dbg(ql_dbg_io, vha, 0x3071,
+ 		    "mbx abort_command success.\n");
+ 	}
+ 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+ 
+ 	complete(&lio->u.els_logo.comp);
+ }
+ 
+ static void
+ qla2x00_els_dcmd_sp_done(void *ptr, int res)
+ {
+ 	srb_t *sp = ptr;
+ 	fc_port_t *fcport = sp->fcport;
+ 	struct srb_iocb *lio = &sp->u.iocb_cmd;
+ 	struct scsi_qla_host *vha = sp->vha;
+ 
+ 	ql_dbg(ql_dbg_io, vha, 0x3072,
+ 	    "%s hdl=%x, portid=%02x%02x%02x done\n",
+ 	    sp->name, sp->handle, fcport->d_id.b.domain,
+ 	    fcport->d_id.b.area, fcport->d_id.b.al_pa);
+ 
+ 	complete(&lio->u.els_logo.comp);
+ }
+ 
+ int
+ qla24xx_els_dcmd_iocb(scsi_qla_host_t *vha, int els_opcode,
+     port_id_t remote_did)
+ {
+ 	srb_t *sp;
+ 	fc_port_t *fcport = NULL;
+ 	struct srb_iocb *elsio = NULL;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct els_logo_payload logo_pyld;
+ 	int rval = QLA_SUCCESS;
+ 
+ 	fcport = qla2x00_alloc_fcport(vha, GFP_KERNEL);
+ 	if (!fcport) {
+ 	       ql_log(ql_log_info, vha, 0x70e5, "fcport allocation failed\n");
+ 	       return -ENOMEM;
+ 	}
+ 
+ 	/* Alloc SRB structure */
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);
+ 	if (!sp) {
+ 		kfree(fcport);
+ 		ql_log(ql_log_info, vha, 0x70e6,
+ 		 "SRB allocation failed\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	elsio = &sp->u.iocb_cmd;
+ 	fcport->loop_id = 0xFFFF;
+ 	fcport->d_id.b.domain = remote_did.b.domain;
+ 	fcport->d_id.b.area = remote_did.b.area;
+ 	fcport->d_id.b.al_pa = remote_did.b.al_pa;
+ 
+ 	ql_dbg(ql_dbg_io, vha, 0x3073, "portid=%02x%02x%02x done\n",
+ 	    fcport->d_id.b.domain, fcport->d_id.b.area, fcport->d_id.b.al_pa);
+ 
+ 	sp->type = SRB_ELS_DCMD;
+ 	sp->name = "ELS_DCMD";
+ 	sp->fcport = fcport;
+ 	qla2x00_init_timer(sp, ELS_DCMD_TIMEOUT);
+ 	elsio->timeout = qla2x00_els_dcmd_iocb_timeout;
+ 	sp->done = qla2x00_els_dcmd_sp_done;
+ 	sp->free = qla2x00_els_dcmd_sp_free;
+ 
+ 	elsio->u.els_logo.els_logo_pyld = dma_alloc_coherent(&ha->pdev->dev,
+ 			    DMA_POOL_SIZE, &elsio->u.els_logo.els_logo_pyld_dma,
+ 			    GFP_KERNEL);
+ 
+ 	if (!elsio->u.els_logo.els_logo_pyld) {
+ 		sp->free(sp);
+ 		return QLA_FUNCTION_FAILED;
+ 	}
+ 
+ 	memset(&logo_pyld, 0, sizeof(struct els_logo_payload));
+ 
+ 	elsio->u.els_logo.els_cmd = els_opcode;
+ 	logo_pyld.opcode = els_opcode;
+ 	logo_pyld.s_id[0] = vha->d_id.b.al_pa;
+ 	logo_pyld.s_id[1] = vha->d_id.b.area;
+ 	logo_pyld.s_id[2] = vha->d_id.b.domain;
+ 	host_to_fcp_swap(logo_pyld.s_id, sizeof(uint32_t));
+ 	memcpy(&logo_pyld.wwpn, vha->port_name, WWN_SIZE);
+ 
+ 	memcpy(elsio->u.els_logo.els_logo_pyld, &logo_pyld,
+ 	    sizeof(struct els_logo_payload));
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS) {
+ 		sp->free(sp);
+ 		return QLA_FUNCTION_FAILED;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_io, vha, 0x3074,
+ 	    "%s LOGO sent, hdl=%x, loopid=%x, portid=%02x%02x%02x.\n",
+ 	    sp->name, sp->handle, fcport->loop_id, fcport->d_id.b.domain,
+ 	    fcport->d_id.b.area, fcport->d_id.b.al_pa);
+ 
+ 	wait_for_completion(&elsio->u.els_logo.comp);
+ 
+ 	sp->free(sp);
+ 	return rval;
+ }
+ 
+ static void
+ qla24xx_els_logo_iocb(srb_t *sp, struct els_entry_24xx *els_iocb)
+ {
+ 	scsi_qla_host_t *vha = sp->vha;
+ 	struct srb_iocb *elsio = &sp->u.iocb_cmd;
+ 	uint32_t	dsd_len = 24;
+ 
+ 	els_iocb->entry_type = ELS_IOCB_TYPE;
+ 	els_iocb->entry_count = 1;
+ 	els_iocb->sys_define = 0;
+ 	els_iocb->entry_status = 0;
+ 	els_iocb->handle = sp->handle;
+ 	els_iocb->nport_handle = cpu_to_le16(sp->fcport->loop_id);
+ 	els_iocb->tx_dsd_count = 1;
+ 	els_iocb->vp_index = vha->vp_idx;
+ 	els_iocb->sof_type = EST_SOFI3;
+ 	els_iocb->rx_dsd_count = 0;
+ 	els_iocb->opcode = elsio->u.els_logo.els_cmd;
+ 
+ 	els_iocb->port_id[0] = sp->fcport->d_id.b.al_pa;
+ 	els_iocb->port_id[1] = sp->fcport->d_id.b.area;
+ 	els_iocb->port_id[2] = sp->fcport->d_id.b.domain;
+ 	els_iocb->s_id[0] = vha->d_id.b.al_pa;
+ 	els_iocb->s_id[1] = vha->d_id.b.area;
+ 	els_iocb->s_id[2] = vha->d_id.b.domain;
+ 	els_iocb->control_flags = 0;
+ 
+ 	if (elsio->u.els_logo.els_cmd == ELS_DCMD_PLOGI) {
+ 		els_iocb->tx_byte_count = sizeof(struct els_plogi_payload);
+ 		els_iocb->tx_address[0] =
+ 			cpu_to_le32(LSD(elsio->u.els_plogi.els_plogi_pyld_dma));
+ 		els_iocb->tx_address[1] =
+ 			cpu_to_le32(MSD(elsio->u.els_plogi.els_plogi_pyld_dma));
+ 		els_iocb->tx_len = dsd_len;
+ 
+ 		els_iocb->rx_dsd_count = 1;
+ 		els_iocb->rx_byte_count = sizeof(struct els_plogi_payload);
+ 		els_iocb->rx_address[0] =
+ 			cpu_to_le32(LSD(elsio->u.els_plogi.els_resp_pyld_dma));
+ 		els_iocb->rx_address[1] =
+ 			cpu_to_le32(MSD(elsio->u.els_plogi.els_resp_pyld_dma));
+ 		els_iocb->rx_len = dsd_len;
+ 		ql_dbg(ql_dbg_io + ql_dbg_buffer, vha, 0x3073,
+ 		    "PLOGI ELS IOCB:\n");
+ 		ql_dump_buffer(ql_log_info, vha, 0x0109,
+ 		    (uint8_t *)els_iocb, 0x70);
+ 	} else {
+ 		els_iocb->tx_byte_count = sizeof(struct els_logo_payload);
+ 		els_iocb->tx_address[0] =
+ 		    cpu_to_le32(LSD(elsio->u.els_logo.els_logo_pyld_dma));
+ 		els_iocb->tx_address[1] =
+ 		    cpu_to_le32(MSD(elsio->u.els_logo.els_logo_pyld_dma));
+ 		els_iocb->tx_len = cpu_to_le32(sizeof(struct els_logo_payload));
+ 
+ 		els_iocb->rx_byte_count = 0;
+ 		els_iocb->rx_address[0] = 0;
+ 		els_iocb->rx_address[1] = 0;
+ 		els_iocb->rx_len = 0;
+ 	}
+ 
+ 	sp->vha->qla_stats.control_requests++;
+ }
+ 
+ static void
+ qla2x00_els_dcmd2_sp_free(void *data)
+ {
+ 	srb_t *sp = data;
+ 	struct srb_iocb *elsio = &sp->u.iocb_cmd;
+ 
+ 	if (elsio->u.els_plogi.els_plogi_pyld)
+ 		dma_free_coherent(&sp->vha->hw->pdev->dev, DMA_POOL_SIZE,
+ 		    elsio->u.els_plogi.els_plogi_pyld,
+ 		    elsio->u.els_plogi.els_plogi_pyld_dma);
+ 
+ 	if (elsio->u.els_plogi.els_resp_pyld)
+ 		dma_free_coherent(&sp->vha->hw->pdev->dev, DMA_POOL_SIZE,
+ 		    elsio->u.els_plogi.els_resp_pyld,
+ 		    elsio->u.els_plogi.els_resp_pyld_dma);
+ 
+ 	del_timer(&elsio->timer);
+ 	qla2x00_rel_sp(sp);
+ }
+ 
+ static void
+ qla2x00_els_dcmd2_iocb_timeout(void *data)
+ {
+ 	srb_t *sp = data;
+ 	fc_port_t *fcport = sp->fcport;
+ 	struct scsi_qla_host *vha = sp->vha;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct srb_iocb *lio = &sp->u.iocb_cmd;
+ 	unsigned long flags = 0;
+ 	int res;
+ 
+ 	ql_dbg(ql_dbg_io + ql_dbg_disc, vha, 0x3069,
+ 	    "%s hdl=%x ELS Timeout, %8phC portid=%06x\n",
+ 	    sp->name, sp->handle, fcport->port_name, fcport->d_id.b24);
+ 
+ 	/* Abort the exchange */
+ 	spin_lock_irqsave(&ha->hardware_lock, flags);
+ 	res = ha->isp_ops->abort_command(sp);
+ 	ql_dbg(ql_dbg_io, vha, 0x3070,
+ 	    "mbx abort_command %s\n",
+ 	    (res == QLA_SUCCESS) ? "successful" : "failed");
+ 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+ 
+ 	complete(&lio->u.els_plogi.comp);
+ }
+ 
+ static void
+ qla2x00_els_dcmd2_sp_done(void *ptr, int res)
+ {
+ 	srb_t *sp = ptr;
+ 	fc_port_t *fcport = sp->fcport;
+ 	struct srb_iocb *lio = &sp->u.iocb_cmd;
+ 	struct scsi_qla_host *vha = sp->vha;
+ 
+ 	ql_dbg(ql_dbg_io + ql_dbg_disc, vha, 0x3072,
+ 	    "%s ELS hdl=%x, portid=%06x done %8pC\n",
+ 	    sp->name, sp->handle, fcport->d_id.b24, fcport->port_name);
+ 
+ 	complete(&lio->u.els_plogi.comp);
+ }
+ 
+ int
+ qla24xx_els_dcmd2_iocb(scsi_qla_host_t *vha, int els_opcode,
+ 		       fc_port_t *fcport, port_id_t remote_did)
+ {
+ 	srb_t *sp;
+ 	struct srb_iocb *elsio = NULL;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	int rval = QLA_SUCCESS;
+ 	void	*ptr, *resp_ptr;
+ 	dma_addr_t ptr_dma;
+ 
+ 	/* Alloc SRB structure */
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);
+ 	if (!sp) {
+ 		ql_log(ql_log_info, vha, 0x70e6,
+ 		 "SRB allocation failed\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	elsio = &sp->u.iocb_cmd;
+ 	fcport->d_id.b.domain = remote_did.b.domain;
+ 	fcport->d_id.b.area = remote_did.b.area;
+ 	fcport->d_id.b.al_pa = remote_did.b.al_pa;
+ 
+ 	ql_dbg(ql_dbg_io, vha, 0x3073,
+ 	    "Enter: PLOGI portid=%06x\n", fcport->d_id.b24);
+ 
+ 	sp->type = SRB_ELS_DCMD;
+ 	sp->name = "ELS_DCMD";
+ 	sp->fcport = fcport;
+ 	qla2x00_init_timer(sp, ELS_DCMD_TIMEOUT);
+ 	elsio->timeout = qla2x00_els_dcmd2_iocb_timeout;
+ 	sp->done = qla2x00_els_dcmd2_sp_done;
+ 	sp->free = qla2x00_els_dcmd2_sp_free;
+ 
+ 	ptr = elsio->u.els_plogi.els_plogi_pyld =
+ 	    dma_alloc_coherent(&ha->pdev->dev, DMA_POOL_SIZE,
+ 		&elsio->u.els_plogi.els_plogi_pyld_dma, GFP_KERNEL);
+ 	ptr_dma = elsio->u.els_plogi.els_plogi_pyld_dma;
+ 
+ 	if (!elsio->u.els_plogi.els_plogi_pyld) {
+ 		rval = QLA_FUNCTION_FAILED;
+ 		goto out;
+ 	}
+ 
+ 	resp_ptr = elsio->u.els_plogi.els_resp_pyld =
+ 	    dma_alloc_coherent(&ha->pdev->dev, DMA_POOL_SIZE,
+ 		&elsio->u.els_plogi.els_resp_pyld_dma, GFP_KERNEL);
+ 
+ 	if (!elsio->u.els_plogi.els_resp_pyld) {
+ 		rval = QLA_FUNCTION_FAILED;
+ 		goto out;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_io, vha, 0x3073, "PLOGI %p %p\n", ptr, resp_ptr);
+ 
+ 	memset(ptr, 0, sizeof(struct els_plogi_payload));
+ 	memset(resp_ptr, 0, sizeof(struct els_plogi_payload));
+ 	elsio->u.els_plogi.els_cmd = els_opcode;
+ 	elsio->u.els_plogi.els_plogi_pyld->opcode = els_opcode;
+ 	qla24xx_get_port_login_templ(vha, ptr_dma + 4,
+ 		&elsio->u.els_plogi.els_plogi_pyld->data[0],
+ 		sizeof(struct els_plogi_payload));
+ 
+ 	ql_dbg(ql_dbg_io + ql_dbg_buffer, vha, 0x3073, "PLOGI buffer:\n");
+ 	ql_dump_buffer(ql_dbg_io + ql_dbg_buffer, vha, 0x0109,
+ 	    (uint8_t *)elsio->u.els_plogi.els_plogi_pyld, 0x70);
+ 
+ 	init_completion(&elsio->u.els_plogi.comp);
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS) {
+ 		rval = QLA_FUNCTION_FAILED;
+ 		goto out;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_io, vha, 0x3074,
+ 	    "%s PLOGI sent, hdl=%x, loopid=%x, portid=%06x\n",
+ 	    sp->name, sp->handle, fcport->loop_id, fcport->d_id.b24);
+ 
+ 	wait_for_completion(&elsio->u.els_plogi.comp);
+ 
+ 	if (elsio->u.els_plogi.comp_status != CS_COMPLETE)
+ 		rval = QLA_FUNCTION_FAILED;
+ 
+ out:
+ 	sp->free(sp);
+ 	return rval;
+ }
+ 
+ static void
++>>>>>>> edd05de19759 (scsi: qla2xxx: Changes to support N2N logins)
  qla24xx_els_iocb(srb_t *sp, struct els_entry_24xx *els_iocb)
  {
 -	struct bsg_job *bsg_job = sp->u.bsg_job;
 -	struct fc_bsg_request *bsg_request = bsg_job->request;
 +	struct fc_bsg_job *bsg_job = sp->u.bsg_job;
  
          els_iocb->entry_type = ELS_IOCB_TYPE;
          els_iocb->entry_count = 1;
diff --cc drivers/scsi/qla2xxx/qla_isr.c
index 3d56972c1852,c7878be9dd5f..000000000000
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@@ -1439,6 -1561,25 +1441,28 @@@ qla24xx_els_ct_entry(scsi_qla_host_t *v
  	case SRB_CT_CMD:
  		type = "ct pass-through";
  		break;
++<<<<<<< HEAD
++=======
+ 	case SRB_ELS_DCMD:
+ 		type = "Driver ELS logo";
+ 		if (iocb_type != ELS_IOCB_TYPE) {
+ 			ql_dbg(ql_dbg_user, vha, 0x5047,
+ 			    "Completing %s: (%p) type=%d.\n",
+ 			    type, sp, sp->type);
+ 			sp->done(sp, 0);
+ 			return;
+ 		}
+ 		break;
+ 	case SRB_CT_PTHRU_CMD:
+ 		/* borrowing sts_entry_24xx.comp_status.
+ 		   same location as ct_entry_24xx.comp_status
+ 		 */
+ 		res = qla2x00_chk_ms_status(vha, (ms_iocb_entry_t *)pkt,
+ 			(struct ct_sns_rsp *)sp->u.iocb_cmd.u.ctarg.rsp,
+ 			sp->name);
+ 		sp->done(sp, res);
+ 		return;
++>>>>>>> edd05de19759 (scsi: qla2xxx: Changes to support N2N logins)
  	default:
  		ql_dbg(ql_dbg_user, vha, 0x503e,
  		    "Unrecognized SRB: (%p) type=%d.\n", sp, sp->type);
@@@ -1489,11 -1661,12 +1540,12 @@@
  	}
  	else {
  		res =  DID_OK << 16;
 -		bsg_reply->reply_payload_rcv_len = bsg_job->reply_payload.payload_len;
 +		bsg_job->reply->reply_payload_rcv_len = bsg_job->reply_payload.payload_len;
  		bsg_job->reply_len = 0;
  	}
+ els_ct_done:
  
 -	sp->done(sp, res);
 +	sp->done(vha, sp, res);
  }
  
  static void
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
diff --git a/drivers/scsi/qla2xxx/qla_fw.h b/drivers/scsi/qla2xxx/qla_fw.h
index 8a2368b32dec..e6b0a3e94e96 100644
--- a/drivers/scsi/qla2xxx/qla_fw.h
+++ b/drivers/scsi/qla2xxx/qla_fw.h
@@ -696,9 +696,7 @@ struct els_entry_24xx {
 	uint8_t reserved_2;
 
 	uint8_t port_id[3];
-	uint8_t reserved_3;
-
-	uint16_t reserved_4;
+	uint8_t s_id[3];
 
 	uint16_t control_flags;		/* Control flags. */
 #define ECF_PAYLOAD_DESCR_MASK	(BIT_15|BIT_14|BIT_13)
* Unmerged path drivers/scsi/qla2xxx/qla_gbl.h
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
* Unmerged path drivers/scsi/qla2xxx/qla_iocb.c
* Unmerged path drivers/scsi/qla2xxx/qla_isr.c
diff --git a/drivers/scsi/qla2xxx/qla_mbx.c b/drivers/scsi/qla2xxx/qla_mbx.c
index 11982e7bd50f..44d6fcc92c2d 100644
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@ -1531,6 +1531,7 @@ qla2x00_get_port_database(scsi_qla_host_t *vha, fc_port_t *fcport, uint8_t opt)
 	if (pd  == NULL) {
 		ql_log(ql_log_warn, vha, 0x1050,
 		    "Failed to allocate port database structure.\n");
+		fcport->query = 0;
 		return QLA_MEMORY_ALLOC_FAILED;
 	}
 	memset(pd, 0, max(PORT_DATABASE_SIZE, PORT_DATABASE_24XX_SIZE));
@@ -1657,6 +1658,7 @@ qla2x00_get_port_database(scsi_qla_host_t *vha, fc_port_t *fcport, uint8_t opt)
 
 gpd_error_out:
 	dma_pool_free(ha->s_dma_pool, pd, pd_dma);
+	fcport->query = 0;
 
 	if (rval != QLA_SUCCESS) {
 		ql_dbg(ql_dbg_mbx, vha, 0x1052,
@@ -3502,6 +3504,38 @@ qla24xx_report_id_acquisition(scsi_qla_host_t *vha,
 		    "port id %02x%02x%02x.\n", vp_idx, MSB(stat),
 		    rptid_entry->port_id[2], rptid_entry->port_id[1],
 		    rptid_entry->port_id[0]);
+		ql_dbg(ql_dbg_async, vha, 0x5075,
+		   "Format 1: Remote WWPN %8phC.\n",
+		   rptid_entry->u.f1.port_name);
+
+		ql_dbg(ql_dbg_async, vha, 0x5075,
+		   "Format 1: WWPN %8phC.\n",
+		   vha->port_name);
+
+		/* N2N.  direct connect */
+		if (IS_QLA27XX(ha) &&
+		    ((rptid_entry->u.f1.flags>>1) & 0x7) == 2) {
+			/* if our portname is higher then initiate N2N login */
+			if (wwn_to_u64(vha->port_name) >
+			    wwn_to_u64(rptid_entry->u.f1.port_name)) {
+				// ??? qlt_update_host_map(vha, id);
+				vha->n2n_id = 0x1;
+				ql_dbg(ql_dbg_async, vha, 0x5075,
+				    "Format 1: Setting n2n_update_needed for id %d\n",
+				    vha->n2n_id);
+			} else {
+				ql_dbg(ql_dbg_async, vha, 0x5075,
+				    "Format 1: Remote login - Waiting for WWPN %8phC.\n",
+				    rptid_entry->u.f1.port_name);
+			}
+
+			memcpy(vha->n2n_port_name, rptid_entry->u.f1.port_name,
+			    WWN_SIZE);
+			set_bit(N2N_LOGIN_NEEDED, &vha->dpc_flags);
+			set_bit(REGISTER_FC4_NEEDED, &vha->dpc_flags);
+			set_bit(REGISTER_FDMI_NEEDED, &vha->dpc_flags);
+			return;
+		}
 
 		/* buffer to buffer credit flag */
 		vha->flags.bbcr_enable = (rptid_entry->bbcr & 0xf) != 0;
@@ -4326,6 +4360,48 @@ qla25xx_set_driver_version(scsi_qla_host_t *vha, char *version)
 	return rval;
 }
 
+int
+qla24xx_get_port_login_templ(scsi_qla_host_t *vha, dma_addr_t buf_dma,
+			     void *buf, uint16_t bufsiz)
+{
+	int rval, i;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+	uint32_t	*bp;
+
+	if (!IS_FWI2_CAPABLE(vha->hw))
+		return QLA_FUNCTION_FAILED;
+
+	ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1159,
+	    "Entered %s.\n", __func__);
+
+	mcp->mb[0] = MBC_GET_RNID_PARAMS;
+	mcp->mb[1] = RNID_TYPE_PORT_LOGIN << 8;
+	mcp->mb[2] = MSW(buf_dma);
+	mcp->mb[3] = LSW(buf_dma);
+	mcp->mb[6] = MSW(MSD(buf_dma));
+	mcp->mb[7] = LSW(MSD(buf_dma));
+	mcp->mb[8] = bufsiz/4;
+	mcp->out_mb = MBX_8|MBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;
+	mcp->in_mb = MBX_1|MBX_0;
+	mcp->tov = MBX_TOV_SECONDS;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(vha, mcp);
+
+	if (rval != QLA_SUCCESS) {
+		ql_dbg(ql_dbg_mbx, vha, 0x115a,
+		    "Failed=%x mb[0]=%x,%x.\n", rval, mcp->mb[0], mcp->mb[1]);
+	} else {
+		ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x115b,
+		    "Done %s.\n", __func__);
+		bp = (uint32_t *) buf;
+		for (i = 0; i < (bufsiz-4)/4; i++, bp++)
+			*bp = cpu_to_be32(*bp);
+	}
+
+	return rval;
+}
+
 static int
 qla2x00_read_asic_temperature(scsi_qla_host_t *vha, uint16_t *temp)
 {
