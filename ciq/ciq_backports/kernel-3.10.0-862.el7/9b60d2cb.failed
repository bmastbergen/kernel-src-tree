IB/hfi1: Clean up context initialization

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Michael J. Ruhl <michael.j.ruhl@intel.com>
commit 9b60d2cbe07486658a32d4ed2fff7085c44bae7a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9b60d2cb.failed

Context initialization mixes base context init with sub context init.
This is bad because contexts can be reused, and on reuse, reinit things
that should not re-initialized.

Normalize comments and function names to refer to base context and
sub context (not main, shared or slaves).

Separate the base context initialization from sub context initialization.

hfi1_init_ctxt() cannot return an error so changed to a void and remove
error message.

	Reviewed-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Signed-off-by: Michael J. Ruhl <michael.j.ruhl@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 9b60d2cbe07486658a32d4ed2fff7085c44bae7a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/file_ops.c
#	drivers/infiniband/hw/hfi1/user_exp_rcv.h
diff --cc drivers/infiniband/hw/hfi1/file_ops.c
index 32dd4a920494,467f876551ba..000000000000
--- a/drivers/infiniband/hw/hfi1/file_ops.c
+++ b/drivers/infiniband/hw/hfi1/file_ops.c
@@@ -70,31 -70,38 +70,60 @@@
  /*
   * File operation functions
   */
 -static int hfi1_file_open(struct inode *inode, struct file *fp);
 -static int hfi1_file_close(struct inode *inode, struct file *fp);
 -static ssize_t hfi1_write_iter(struct kiocb *kiocb, struct iov_iter *from);
 -static unsigned int hfi1_poll(struct file *fp, struct poll_table_struct *pt);
 -static int hfi1_file_mmap(struct file *fp, struct vm_area_struct *vma);
 -
 +static int hfi1_file_open(struct inode *, struct file *);
 +static int hfi1_file_close(struct inode *, struct file *);
 +static ssize_t hfi1_aio_write(struct kiocb *, const struct iovec *,
 +			      unsigned long, loff_t);
 +static unsigned int hfi1_poll(struct file *, struct poll_table_struct *);
 +static int hfi1_file_mmap(struct file *, struct vm_area_struct *);
 +
++<<<<<<< HEAD
 +static u64 kvirt_to_phys(void *);
 +static int assign_ctxt(struct file *, struct hfi1_user_info *);
 +static int init_subctxts(struct hfi1_ctxtdata *, const struct hfi1_user_info *);
 +static int user_init(struct file *);
 +static int get_ctxt_info(struct file *, void __user *, __u32);
 +static int get_base_info(struct file *, void __user *, __u32);
 +static int setup_ctxt(struct file *);
 +static int setup_subctxt(struct hfi1_ctxtdata *);
 +static int get_user_context(struct file *, struct hfi1_user_info *, int);
 +static int find_shared_ctxt(struct file *, const struct hfi1_user_info *);
 +static int allocate_ctxt(struct file *, struct hfi1_devdata *,
 +			 struct hfi1_user_info *);
 +static unsigned int poll_urgent(struct file *, struct poll_table_struct *);
 +static unsigned int poll_next(struct file *, struct poll_table_struct *);
 +static int user_event_ack(struct hfi1_ctxtdata *, int, unsigned long);
 +static int set_ctxt_pkey(struct hfi1_ctxtdata *, unsigned, u16);
 +static int manage_rcvq(struct hfi1_ctxtdata *, unsigned, int);
 +static int vma_fault(struct vm_area_struct *, struct vm_fault *);
++=======
+ static u64 kvirt_to_phys(void *addr);
+ static int assign_ctxt(struct hfi1_filedata *fd, struct hfi1_user_info *uinfo);
+ static int init_subctxts(struct hfi1_ctxtdata *uctxt,
+ 			 const struct hfi1_user_info *uinfo);
+ static int init_user_ctxt(struct hfi1_filedata *fd);
+ static int user_init(struct hfi1_ctxtdata *uctxt);
+ static int get_ctxt_info(struct hfi1_filedata *fd, void __user *ubase,
+ 			 __u32 len);
+ static int get_base_info(struct hfi1_filedata *fd, void __user *ubase,
+ 			 __u32 len);
+ static int setup_base_ctxt(struct hfi1_filedata *fd);
+ static int setup_subctxt(struct hfi1_ctxtdata *uctxt);
+ 
+ static int find_sub_ctxt(struct hfi1_filedata *fd,
+ 			 const struct hfi1_user_info *uinfo);
+ static int allocate_ctxt(struct hfi1_filedata *fd, struct hfi1_devdata *dd,
+ 			 struct hfi1_user_info *uinfo);
+ static unsigned int poll_urgent(struct file *fp, struct poll_table_struct *pt);
+ static unsigned int poll_next(struct file *fp, struct poll_table_struct *pt);
+ static int user_event_ack(struct hfi1_ctxtdata *uctxt, int subctxt,
+ 			  unsigned long events);
+ static int set_ctxt_pkey(struct hfi1_ctxtdata *uctxt, unsigned subctxt,
+ 			 u16 pkey);
+ static int manage_rcvq(struct hfi1_ctxtdata *uctxt, unsigned subctxt,
+ 		       int start_stop);
+ static int vma_fault(struct vm_fault *vmf);
++>>>>>>> 9b60d2cbe074 (IB/hfi1: Clean up context initialization)
  static long hfi1_file_ioctl(struct file *fp, unsigned int cmd,
  			    unsigned long arg);
  
@@@ -230,16 -241,10 +259,20 @@@ static long hfi1_file_ioctl(struct fil
  				   sizeof(uinfo)))
  			return -EFAULT;
  
++<<<<<<< HEAD
 +		ret = assign_ctxt(fp, &uinfo);
 +		if (ret < 0)
 +			return ret;
 +		ret = setup_ctxt(fp);
 +		if (ret)
 +			return ret;
 +		ret = user_init(fp);
++=======
+ 		ret = assign_ctxt(fd, &uinfo);
++>>>>>>> 9b60d2cbe074 (IB/hfi1: Clean up context initialization)
  		break;
  	case HFI1_IOCTL_CTXT_INFO:
 -		ret = get_ctxt_info(fd, (void __user *)(unsigned long)arg,
 +		ret = get_ctxt_info(fp, (void __user *)(unsigned long)arg,
  				    sizeof(struct hfi1_ctxt_info));
  		break;
  	case HFI1_IOCTL_USER_INFO:
@@@ -854,113 -857,98 +885,156 @@@ static int assign_ctxt(struct file *fp
  	swminor = uinfo->userversion & 0xffff;
  
  	mutex_lock(&hfi1_mutex);
- 	/* First, lets check if we need to setup a shared context? */
+ 	/* First, lets check if we need to get a sub context? */
  	if (uinfo->subctxt_cnt) {
++<<<<<<< HEAD
 +		struct hfi1_filedata *fd = fp->private_data;
 +
 +		ret = find_shared_ctxt(fp, uinfo);
 +		if (ret < 0)
 +			goto done_unlock;
 +		if (ret) {
++=======
+ 		/* < 0 error, 0 no context, 1 sub-context found */
+ 		ret = find_sub_ctxt(fd, uinfo);
+ 		if (ret > 0) {
++>>>>>>> 9b60d2cbe074 (IB/hfi1: Clean up context initialization)
  			fd->rec_cpu_num =
  				hfi1_get_proc_affinity(fd->uctxt->numa_id);
  		}
  	}
  
  	/*
- 	 * We execute the following block if we couldn't find a
- 	 * shared context or if context sharing is not required.
+ 	 * Allocate a base context f context sharing is not required or we
+ 	 * couldn't find a sub context.
  	 */
++<<<<<<< HEAD
 +	if (!ret) {
 +		i_minor = iminor(file_inode(fp)) - HFI1_USER_MINOR_BASE;
 +		ret = get_user_context(fp, uinfo, i_minor);
 +	}
 +done_unlock:
++=======
+ 	if (!ret)
+ 		ret = allocate_ctxt(fd, fd->dd, uinfo);
+ 
++>>>>>>> 9b60d2cbe074 (IB/hfi1: Clean up context initialization)
  	mutex_unlock(&hfi1_mutex);
- done:
+ 
+ 	/* Depending on the context type, do the appropriate init */
+ 	if (ret > 0) {
+ 		/*
+ 		 * sub-context info can only be set up after the base
+ 		 * context has been completed.
+ 		 */
+ 		ret = wait_event_interruptible(fd->uctxt->wait, !test_bit(
+ 					       HFI1_CTXT_BASE_UNINIT,
+ 					       &fd->uctxt->event_flags));
+ 		/* The only thing a sub context needs is the user_xxx stuff */
+ 		if (!ret)
+ 			init_user_ctxt(fd);
+ 	} else if (!ret) {
+ 		ret = setup_base_ctxt(fd);
+ 
+ 		/*
+ 		 * Base context is done, notify anybody using a sub-context
+ 		 * that is waiting for this completion
+ 		 */
+ 		if (!ret && fd->uctxt->subctxt_cnt) {
+ 			clear_bit(HFI1_CTXT_BASE_UNINIT,
+ 				  &fd->uctxt->event_flags);
+ 			wake_up(&fd->uctxt->wait);
+ 		}
+ 	}
+ 
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int get_user_context(struct file *fp, struct hfi1_user_info *uinfo,
 +			    int devno)
++=======
+ static int find_sub_ctxt(struct hfi1_filedata *fd,
+ 			 const struct hfi1_user_info *uinfo)
++>>>>>>> 9b60d2cbe074 (IB/hfi1: Clean up context initialization)
  {
 -	int i;
 -	struct hfi1_devdata *dd = fd->dd;
 +	struct hfi1_devdata *dd = NULL;
 +	int devmax, npresent, nup;
  
 -	for (i = dd->first_dyn_alloc_ctxt; i < dd->num_rcv_contexts; i++) {
 -		struct hfi1_ctxtdata *uctxt = dd->rcd[i];
 +	devmax = hfi1_count_units(&npresent, &nup);
 +	if (!npresent)
 +		return -ENXIO;
  
 -		/* Skip ctxts which are not yet open */
 -		if (!uctxt || !uctxt->cnt)
 -			continue;
 +	if (!nup)
 +		return -ENETDOWN;
  
 -		/* Skip dynamically allocted kernel contexts */
 -		if (uctxt->sc && (uctxt->sc->type == SC_KERNEL))
 -			continue;
 +	dd = hfi1_lookup(devno);
 +	if (!dd)
 +		return -ENODEV;
 +	else if (!dd->freectxts)
 +		return -EBUSY;
  
 -		/* Skip ctxt if it doesn't match the requested one */
 -		if (memcmp(uctxt->uuid, uinfo->uuid,
 -			   sizeof(uctxt->uuid)) ||
 -		    uctxt->jkey != generate_jkey(current_uid()) ||
 -		    uctxt->subctxt_id != uinfo->subctxt_id ||
 -		    uctxt->subctxt_cnt != uinfo->subctxt_cnt)
 -			continue;
 +	return allocate_ctxt(fp, dd, uinfo);
 +}
  
 -		/* Verify the sharing process matches the master */
 -		if (uctxt->userversion != uinfo->userversion ||
 -		    uctxt->cnt >= uctxt->subctxt_cnt) {
 -			return -EINVAL;
 +static int find_shared_ctxt(struct file *fp,
 +			    const struct hfi1_user_info *uinfo)
 +{
 +	int devmax, ndev, i;
 +	int ret = 0;
 +	struct hfi1_filedata *fd = fp->private_data;
 +
 +	devmax = hfi1_count_units(NULL, NULL);
 +
 +	for (ndev = 0; ndev < devmax; ndev++) {
 +		struct hfi1_devdata *dd = hfi1_lookup(ndev);
 +
 +		if (!(dd && (dd->flags & HFI1_PRESENT) && dd->kregbase))
 +			continue;
 +		for (i = dd->first_dyn_alloc_ctxt;
 +		     i < dd->num_rcv_contexts; i++) {
 +			struct hfi1_ctxtdata *uctxt = dd->rcd[i];
 +
 +			/* Skip ctxts which are not yet open */
 +			if (!uctxt || !uctxt->cnt)
 +				continue;
 +
 +			/* Skip dynamically allocted kernel contexts */
 +			if (uctxt->sc && (uctxt->sc->type == SC_KERNEL))
 +				continue;
 +
 +			/* Skip ctxt if it doesn't match the requested one */
 +			if (memcmp(uctxt->uuid, uinfo->uuid,
 +				   sizeof(uctxt->uuid)) ||
 +			    uctxt->jkey != generate_jkey(current_uid()) ||
 +			    uctxt->subctxt_id != uinfo->subctxt_id ||
 +			    uctxt->subctxt_cnt != uinfo->subctxt_cnt)
 +				continue;
 +
 +			/* Verify the sharing process matches the master */
 +			if (uctxt->userversion != uinfo->userversion ||
 +			    uctxt->cnt >= uctxt->subctxt_cnt) {
 +				ret = -EINVAL;
 +				goto done;
 +			}
 +			fd->uctxt = uctxt;
 +			fd->subctxt  = uctxt->cnt++;
 +			uctxt->active_slaves |= 1 << fd->subctxt;
 +			ret = 1;
 +			goto done;
  		}
 -		fd->uctxt = uctxt;
 -		fd->subctxt  = uctxt->cnt++;
 -		uctxt->active_slaves |= 1 << fd->subctxt;
 -		return 1;
  	}
  
 -	return 0;
 +done:
 +	return ret;
  }
  
 -static int allocate_ctxt(struct hfi1_filedata *fd, struct hfi1_devdata *dd,
 +static int allocate_ctxt(struct file *fp, struct hfi1_devdata *dd,
  			 struct hfi1_user_info *uinfo)
  {
 +	struct hfi1_filedata *fd = fp->private_data;
  	struct hfi1_ctxtdata *uctxt;
 -	unsigned int ctxt;
 +	unsigned ctxt;
  	int ret, numa;
  
  	if (dd->flags & HFI1_FROZEN) {
@@@ -1108,15 -1106,9 +1184,21 @@@ bail_ureg
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int user_init(struct file *fp)
 +{
 +	unsigned int rcvctrl_ops = 0;
 +	struct hfi1_filedata *fd = fp->private_data;
 +	struct hfi1_ctxtdata *uctxt = fd->uctxt;
 +
 +	/* make sure that the context has already been setup */
 +	if (!test_bit(HFI1_CTXT_SETUP_DONE, &uctxt->event_flags))
 +		return -EFAULT;
++=======
+ static int user_init(struct hfi1_ctxtdata *uctxt)
+ {
+ 	unsigned int rcvctrl_ops = 0;
++>>>>>>> 9b60d2cbe074 (IB/hfi1: Clean up context initialization)
  
  	/* initialize poll variables... */
  	uctxt->urgent = 0;
@@@ -1215,56 -1201,48 +1291,89 @@@ static int get_ctxt_info(struct file *f
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int setup_ctxt(struct file *fp)
++=======
+ static int init_user_ctxt(struct hfi1_filedata *fd)
+ {
+ 	struct hfi1_ctxtdata *uctxt = fd->uctxt;
+ 	int ret;
+ 
+ 	ret = hfi1_user_sdma_alloc_queues(uctxt, fd);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = hfi1_user_exp_rcv_init(fd);
+ 
+ 	return ret;
+ }
+ 
+ static int setup_base_ctxt(struct hfi1_filedata *fd)
++>>>>>>> 9b60d2cbe074 (IB/hfi1: Clean up context initialization)
  {
 +	struct hfi1_filedata *fd = fp->private_data;
  	struct hfi1_ctxtdata *uctxt = fd->uctxt;
  	struct hfi1_devdata *dd = uctxt->dd;
  	int ret = 0;
  
- 	/*
- 	 * Context should be set up only once, including allocation and
- 	 * programming of eager buffers. This is done if context sharing
- 	 * is not requested or by the master process.
- 	 */
- 	if (!uctxt->subctxt_cnt || !fd->subctxt) {
- 		ret = hfi1_init_ctxt(uctxt->sc);
- 		if (ret)
- 			goto done;
+ 	hfi1_init_ctxt(uctxt->sc);
  
++<<<<<<< HEAD
 +		/* Now allocate the RcvHdr queue and eager buffers. */
 +		ret = hfi1_create_rcvhdrq(dd, uctxt);
 +		if (ret)
 +			goto done;
 +		ret = hfi1_setup_eagerbufs(uctxt);
 +		if (ret)
 +			goto done;
 +		if (uctxt->subctxt_cnt && !fd->subctxt) {
 +			ret = setup_subctxt(uctxt);
 +			if (ret)
 +				goto done;
 +		}
 +	} else {
 +		ret = wait_event_interruptible(uctxt->wait, !test_bit(
 +					       HFI1_CTXT_MASTER_UNINIT,
 +					       &uctxt->event_flags));
 +		if (ret)
 +			goto done;
 +	}
 +
 +	ret = hfi1_user_sdma_alloc_queues(uctxt, fp);
 +	if (ret)
 +		goto done;
 +	/*
 +	 * Expected receive has to be setup for all processes (including
 +	 * shared contexts). However, it has to be done after the master
 +	 * context has been fully configured as it depends on the
 +	 * eager/expected split of the RcvArray entries.
 +	 * Setting it up here ensures that the subcontexts will be waiting
 +	 * (due to the above wait_event_interruptible() until the master
 +	 * is setup.
 +	 */
 +	ret = hfi1_user_exp_rcv_init(fp);
++=======
+ 	/* Now allocate the RcvHdr queue and eager buffers. */
+ 	ret = hfi1_create_rcvhdrq(dd, uctxt);
++>>>>>>> 9b60d2cbe074 (IB/hfi1: Clean up context initialization)
+ 	if (ret)
+ 		goto done;
+ 
+ 	ret = hfi1_setup_eagerbufs(uctxt);
+ 	if (ret)
+ 		goto done;
+ 
+ 	/* If sub-contexts are enabled, do the appropriate setup */
+ 	if (uctxt->subctxt_cnt)
+ 		ret = setup_subctxt(uctxt);
+ 	if (ret)
+ 		goto done;
+ 
+ 	ret = hfi1_user_exp_rcv_grp_init(fd);
+ 	if (ret)
+ 		goto done;
+ 
+ 	ret = init_user_ctxt(fd);
  	if (ret)
  		goto done;
  
diff --cc drivers/infiniband/hw/hfi1/user_exp_rcv.h
index d1d7d3d3bd44,5250c897298d..000000000000
--- a/drivers/infiniband/hw/hfi1/user_exp_rcv.h
+++ b/drivers/infiniband/hw/hfi1/user_exp_rcv.h
@@@ -71,10 -71,14 +71,22 @@@
  	} while (0)
  
  void hfi1_user_exp_rcv_grp_free(struct hfi1_ctxtdata *uctxt);
++<<<<<<< HEAD
 +int hfi1_user_exp_rcv_init(struct file *);
 +int hfi1_user_exp_rcv_free(struct hfi1_filedata *);
 +int hfi1_user_exp_rcv_setup(struct file *, struct hfi1_tid_info *);
 +int hfi1_user_exp_rcv_clear(struct file *, struct hfi1_tid_info *);
 +int hfi1_user_exp_rcv_invalid(struct file *, struct hfi1_tid_info *);
++=======
+ int hfi1_user_exp_rcv_grp_init(struct hfi1_filedata *fd);
+ int hfi1_user_exp_rcv_init(struct hfi1_filedata *fd);
+ void hfi1_user_exp_rcv_free(struct hfi1_filedata *fd);
+ int hfi1_user_exp_rcv_setup(struct hfi1_filedata *fd,
+ 			    struct hfi1_tid_info *tinfo);
+ int hfi1_user_exp_rcv_clear(struct hfi1_filedata *fd,
+ 			    struct hfi1_tid_info *tinfo);
+ int hfi1_user_exp_rcv_invalid(struct hfi1_filedata *fd,
+ 			      struct hfi1_tid_info *tinfo);
++>>>>>>> 9b60d2cbe074 (IB/hfi1: Clean up context initialization)
  
  #endif /* _HFI1_USER_EXP_RCV_H */
diff --git a/drivers/infiniband/hw/hfi1/chip.c b/drivers/infiniband/hw/hfi1/chip.c
index ebe3e29140f9..90a2727a94a0 100644
--- a/drivers/infiniband/hw/hfi1/chip.c
+++ b/drivers/infiniband/hw/hfi1/chip.c
@@ -12695,7 +12695,7 @@ u8 hfi1_ibphys_portstate(struct hfi1_pportdata *ppd)
 #define SET_STATIC_RATE_CONTROL_SMASK(r) \
 (r |= SEND_CTXT_CHECK_ENABLE_DISALLOW_PBC_STATIC_RATE_CONTROL_SMASK)
 
-int hfi1_init_ctxt(struct send_context *sc)
+void hfi1_init_ctxt(struct send_context *sc)
 {
 	if (sc) {
 		struct hfi1_devdata *dd = sc->dd;
@@ -12712,7 +12712,6 @@ int hfi1_init_ctxt(struct send_context *sc)
 		write_kctxt_csr(dd, sc->hw_context,
 				SEND_CTXT_CHECK_ENABLE, reg);
 	}
-	return 0;
 }
 
 int hfi1_tempsense_rd(struct hfi1_devdata *dd, struct hfi1_temp *temp)
diff --git a/drivers/infiniband/hw/hfi1/chip.h b/drivers/infiniband/hw/hfi1/chip.h
index 8a7b218d745f..82d7a12b4dbd 100644
--- a/drivers/infiniband/hw/hfi1/chip.h
+++ b/drivers/infiniband/hw/hfi1/chip.h
@@ -1347,7 +1347,7 @@ void hfi1_start_cleanup(struct hfi1_devdata *dd);
 void hfi1_clear_tids(struct hfi1_ctxtdata *rcd);
 struct ib_header *hfi1_get_msgheader(
 				struct hfi1_devdata *dd, __le32 *rhf_addr);
-int hfi1_init_ctxt(struct send_context *sc);
+void hfi1_init_ctxt(struct send_context *sc);
 void hfi1_put_tid(struct hfi1_devdata *dd, u32 index,
 		  u32 type, unsigned long pa, u16 order);
 void hfi1_quiet_serdes(struct hfi1_pportdata *ppd);
* Unmerged path drivers/infiniband/hw/hfi1/file_ops.c
diff --git a/drivers/infiniband/hw/hfi1/hfi.h b/drivers/infiniband/hw/hfi1/hfi.h
index b1aefd5ddffe..a7d0c107df6e 100644
--- a/drivers/infiniband/hw/hfi1/hfi.h
+++ b/drivers/infiniband/hw/hfi1/hfi.h
@@ -224,13 +224,12 @@ struct hfi1_ctxtdata {
 	 * (ignoring forks, dup, etc. for now)
 	 */
 	int cnt;
+	/* Device context index */
+	unsigned ctxt;
 	/*
-	 * how much space to leave at start of eager TID entries for
-	 * protocol use, on each TID
+	 * non-zero if ctxt can be shared, and defines the maximum number of
+	 * sub contexts allowed.
 	 */
-	/* instead of calculating it */
-	unsigned ctxt;
-	/* non-zero if ctxt is being shared. */
 	u16 subctxt_cnt;
 	/* non-zero if ctxt is being shared. */
 	u16 subctxt_id;
@@ -1733,12 +1732,10 @@ struct cc_state *get_cc_state_protected(struct hfi1_pportdata *ppd)
 #define HFI1_PBC_LENGTH_MASK                     ((1 << 11) - 1)
 
 /* ctxt_flag bit offsets */
-		/* context has been setup */
-#define HFI1_CTXT_SETUP_DONE 1
 		/* waiting for a packet to arrive */
 #define HFI1_CTXT_WAITING_RCV   2
 		/* master has not finished initializing */
-#define HFI1_CTXT_MASTER_UNINIT 4
+#define HFI1_CTXT_BASE_UNINIT 4
 		/* waiting for an urgent packet to arrive */
 #define HFI1_CTXT_WAITING_URG 5
 
diff --git a/drivers/infiniband/hw/hfi1/init.c b/drivers/infiniband/hw/hfi1/init.c
index d1e1227c533d..1119691cc74a 100644
--- a/drivers/infiniband/hw/hfi1/init.c
+++ b/drivers/infiniband/hw/hfi1/init.c
@@ -176,13 +176,7 @@ int hfi1_create_ctxts(struct hfi1_devdata *dd)
 			goto nomem;
 		}
 
-		ret = hfi1_init_ctxt(rcd->sc);
-		if (ret < 0) {
-			dd_dev_err(dd,
-				   "Failed to setup kernel receive context, failing\n");
-			ret = -EFAULT;
-			goto bail;
-		}
+		hfi1_init_ctxt(rcd->sc);
 	}
 
 	/*
@@ -194,7 +188,7 @@ int hfi1_create_ctxts(struct hfi1_devdata *dd)
 	return 0;
 nomem:
 	ret = -ENOMEM;
-bail:
+
 	if (dd->rcd) {
 		for (i = 0; i < dd->num_rcv_contexts; ++i)
 			hfi1_free_ctxtdata(dd, dd->rcd[i]);
diff --git a/drivers/infiniband/hw/hfi1/trace_ctxts.h b/drivers/infiniband/hw/hfi1/trace_ctxts.h
index 26ae789e47cf..4eb4cc798035 100644
--- a/drivers/infiniband/hw/hfi1/trace_ctxts.h
+++ b/drivers/infiniband/hw/hfi1/trace_ctxts.h
@@ -57,12 +57,14 @@
 
 #define UCTXT_FMT \
 	"cred:%u, credaddr:0x%llx, piobase:0x%p, rcvhdr_cnt:%u, "	\
-	"rcvbase:0x%llx, rcvegrc:%u, rcvegrb:0x%llx"
+	"rcvbase:0x%llx, rcvegrc:%u, rcvegrb:0x%llx, subctxt_cnt:%u"
 TRACE_EVENT(hfi1_uctxtdata,
-	    TP_PROTO(struct hfi1_devdata *dd, struct hfi1_ctxtdata *uctxt),
-	    TP_ARGS(dd, uctxt),
+	    TP_PROTO(struct hfi1_devdata *dd, struct hfi1_ctxtdata *uctxt,
+		     unsigned int subctxt),
+	    TP_ARGS(dd, uctxt, subctxt),
 	    TP_STRUCT__entry(DD_DEV_ENTRY(dd)
 			     __field(unsigned int, ctxt)
+			     __field(unsigned int, subctxt)
 			     __field(u32, credits)
 			     __field(u64, hw_free)
 			     __field(void __iomem *, piobase)
@@ -70,9 +72,11 @@ TRACE_EVENT(hfi1_uctxtdata,
 			     __field(u64, rcvhdrq_dma)
 			     __field(u32, eager_cnt)
 			     __field(u64, rcvegr_dma)
+			     __field(unsigned int, subctxt_cnt)
 			     ),
 	    TP_fast_assign(DD_DEV_ASSIGN(dd);
 			   __entry->ctxt = uctxt->ctxt;
+			   __entry->subctxt = subctxt;
 			   __entry->credits = uctxt->sc->credits;
 			   __entry->hw_free = le64_to_cpu(*uctxt->sc->hw_free);
 			   __entry->piobase = uctxt->sc->base_addr;
@@ -80,17 +84,20 @@ TRACE_EVENT(hfi1_uctxtdata,
 			   __entry->rcvhdrq_dma = uctxt->rcvhdrq_dma;
 			   __entry->eager_cnt = uctxt->egrbufs.alloced;
 			   __entry->rcvegr_dma = uctxt->egrbufs.rcvtids[0].dma;
+			   __entry->subctxt_cnt = uctxt->subctxt_cnt;
 			   ),
-	    TP_printk("[%s] ctxt %u " UCTXT_FMT,
+	    TP_printk("[%s] ctxt %u:%u " UCTXT_FMT,
 		      __get_str(dev),
 		      __entry->ctxt,
+		      __entry->subctxt,
 		      __entry->credits,
 		      __entry->hw_free,
 		      __entry->piobase,
 		      __entry->rcvhdrq_cnt,
 		      __entry->rcvhdrq_dma,
 		      __entry->eager_cnt,
-		      __entry->rcvegr_dma
+		      __entry->rcvegr_dma,
+		      __entry->subctxt_cnt
 		      )
 );
 
diff --git a/drivers/infiniband/hw/hfi1/user_exp_rcv.c b/drivers/infiniband/hw/hfi1/user_exp_rcv.c
index c7f13df471c4..eaeef6282c0e 100644
--- a/drivers/infiniband/hw/hfi1/user_exp_rcv.c
+++ b/drivers/infiniband/hw/hfi1/user_exp_rcv.c
@@ -53,7 +53,7 @@
 
 struct tid_group {
 	struct list_head list;
-	unsigned base;
+	u32 base;
 	u8 size;
 	u8 used;
 	u8 map;
@@ -149,6 +149,40 @@ static inline void tid_group_move(struct tid_group *group,
 	tid_group_add_tail(group, s2);
 }
 
+int hfi1_user_exp_rcv_grp_init(struct hfi1_filedata *fd)
+{
+	struct hfi1_ctxtdata *uctxt = fd->uctxt;
+	struct hfi1_devdata *dd = fd->dd;
+	u32 tidbase;
+	u32 i;
+
+	exp_tid_group_init(&uctxt->tid_group_list);
+	exp_tid_group_init(&uctxt->tid_used_list);
+	exp_tid_group_init(&uctxt->tid_full_list);
+
+	tidbase = uctxt->expected_base;
+	for (i = 0; i < uctxt->expected_count /
+		     dd->rcv_entries.group_size; i++) {
+		struct tid_group *grp;
+
+		grp = kzalloc(sizeof(*grp), GFP_KERNEL);
+		if (!grp) {
+			/*
+			 * If we fail here, the groups already
+			 * allocated will be freed by the close
+			 * call.
+			 */
+			return -ENOMEM;
+		}
+		grp->size = dd->rcv_entries.group_size;
+		grp->base = tidbase;
+		tid_group_add_tail(grp, &uctxt->tid_group_list);
+		tidbase += dd->rcv_entries.group_size;
+	}
+
+	return 0;
+}
+
 /*
  * Initialize context and file private data needed for Expected
  * receive caching. This needs to be done after the context has
@@ -159,42 +193,14 @@ int hfi1_user_exp_rcv_init(struct file *fp)
 	struct hfi1_filedata *fd = fp->private_data;
 	struct hfi1_ctxtdata *uctxt = fd->uctxt;
 	struct hfi1_devdata *dd = uctxt->dd;
-	unsigned tidbase;
-	int i, ret = 0;
+	int ret = 0;
 
 	spin_lock_init(&fd->tid_lock);
 	spin_lock_init(&fd->invalid_lock);
 
-	if (!uctxt->subctxt_cnt || !fd->subctxt) {
-		exp_tid_group_init(&uctxt->tid_group_list);
-		exp_tid_group_init(&uctxt->tid_used_list);
-		exp_tid_group_init(&uctxt->tid_full_list);
-
-		tidbase = uctxt->expected_base;
-		for (i = 0; i < uctxt->expected_count /
-			     dd->rcv_entries.group_size; i++) {
-			struct tid_group *grp;
-
-			grp = kzalloc(sizeof(*grp), GFP_KERNEL);
-			if (!grp) {
-				/*
-				 * If we fail here, the groups already
-				 * allocated will be freed by the close
-				 * call.
-				 */
-				ret = -ENOMEM;
-				goto done;
-			}
-			grp->size = dd->rcv_entries.group_size;
-			grp->base = tidbase;
-			tid_group_add_tail(grp, &uctxt->tid_group_list);
-			tidbase += dd->rcv_entries.group_size;
-		}
-	}
-
 	fd->entry_to_rb = kcalloc(uctxt->expected_count,
-				     sizeof(struct rb_node *),
-				     GFP_KERNEL);
+				  sizeof(struct rb_node *),
+				  GFP_KERNEL);
 	if (!fd->entry_to_rb)
 		return -ENOMEM;
 
@@ -203,10 +209,11 @@ int hfi1_user_exp_rcv_init(struct file *fp)
 		fd->invalid_tids = kcalloc(uctxt->expected_count,
 					   sizeof(*fd->invalid_tids),
 					   GFP_KERNEL);
-		if (!fd->invalid_tids) {
-			ret = -ENOMEM;
-			goto done;
-		}
+		/*
+		 * NOTE: If this is an error, shouldn't we cleanup enry_to_rb?
+		 */
+		if (!fd->invalid_tids)
+			return -ENOMEM;
 
 		/*
 		 * Register MMU notifier callbacks. If the registration
@@ -248,7 +255,7 @@ int hfi1_user_exp_rcv_init(struct file *fp)
 		fd->tid_limit = uctxt->expected_count;
 	}
 	spin_unlock(&fd->tid_lock);
-done:
+
 	return ret;
 }
 
@@ -264,7 +271,7 @@ void hfi1_user_exp_rcv_grp_free(struct hfi1_ctxtdata *uctxt)
 	hfi1_clear_tids(uctxt);
 }
 
-int hfi1_user_exp_rcv_free(struct hfi1_filedata *fd)
+void hfi1_user_exp_rcv_free(struct hfi1_filedata *fd)
 {
 	struct hfi1_ctxtdata *uctxt = fd->uctxt;
 
@@ -286,7 +293,6 @@ int hfi1_user_exp_rcv_free(struct hfi1_filedata *fd)
 
 	kfree(fd->entry_to_rb);
 	fd->entry_to_rb = NULL;
-	return 0;
 }
 
 /*
* Unmerged path drivers/infiniband/hw/hfi1/user_exp_rcv.h
diff --git a/drivers/infiniband/hw/hfi1/vnic_main.c b/drivers/infiniband/hw/hfi1/vnic_main.c
index b1572c795c35..b601c2929f8f 100644
--- a/drivers/infiniband/hw/hfi1/vnic_main.c
+++ b/drivers/infiniband/hw/hfi1/vnic_main.c
@@ -67,9 +67,7 @@ static int setup_vnic_ctxt(struct hfi1_devdata *dd, struct hfi1_ctxtdata *uctxt)
 	unsigned int rcvctrl_ops = 0;
 	int ret;
 
-	ret = hfi1_init_ctxt(uctxt->sc);
-	if (ret)
-		goto done;
+	hfi1_init_ctxt(uctxt->sc);
 
 	uctxt->do_interrupt = &handle_receive_interrupt;
 
@@ -82,8 +80,6 @@ static int setup_vnic_ctxt(struct hfi1_devdata *dd, struct hfi1_ctxtdata *uctxt)
 	if (ret)
 		goto done;
 
-	set_bit(HFI1_CTXT_SETUP_DONE, &uctxt->event_flags);
-
 	if (uctxt->rcvhdrtail_kvaddr)
 		clear_rcvhdrtail(uctxt);
 
