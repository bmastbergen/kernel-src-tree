qla2xxx: Use d_id instead of s_id for more clarity

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Quinn Tran <quinn.tran@cavium.com>
commit 37cacc0a13012eee9fa0b07563eb149ec9244b1e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/37cacc0a.failed

Updated code with d_id from s_id for better readability and
clarity.

	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
[ bvanassche: fixed spelling of patch description ]
	Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>

	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 37cacc0a13012eee9fa0b07563eb149ec9244b1e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_dfs.c
#	drivers/scsi/qla2xxx/qla_target.c
#	drivers/scsi/qla2xxx/tcm_qla2xxx.c
diff --cc drivers/scsi/qla2xxx/qla_dfs.c
index 2ca39b8e7166,98550c9b6161..000000000000
--- a/drivers/scsi/qla2xxx/qla_dfs.c
+++ b/drivers/scsi/qla2xxx/qla_dfs.c
@@@ -13,6 -13,125 +13,128 @@@ static struct dentry *qla2x00_dfs_root
  static atomic_t qla2x00_dfs_root_count;
  
  static int
++<<<<<<< HEAD
++=======
+ qla2x00_dfs_tgt_sess_show(struct seq_file *s, void *unused)
+ {
+ 	scsi_qla_host_t *vha = s->private;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	unsigned long flags;
+ 	struct qla_tgt_sess *sess = NULL;
+ 	struct qla_tgt *tgt= vha->vha_tgt.qla_tgt;
+ 
+ 	seq_printf(s, "%s\n",vha->host_str);
+ 	if (tgt) {
+ 		seq_printf(s, "Port ID   Port Name                Handle\n");
+ 
+ 		spin_lock_irqsave(&ha->tgt.sess_lock, flags);
+ 		list_for_each_entry(sess, &tgt->sess_list, sess_list_entry)
+ 			seq_printf(s, "%02x:%02x:%02x  %8phC  %d\n",
+ 			    sess->d_id.b.domain, sess->d_id.b.area,
+ 			    sess->d_id.b.al_pa, sess->port_name,
+ 			    sess->loop_id);
+ 		spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int
+ qla2x00_dfs_tgt_sess_open(struct inode *inode, struct file *file)
+ {
+ 	scsi_qla_host_t *vha = inode->i_private;
+ 	return single_open(file, qla2x00_dfs_tgt_sess_show, vha);
+ }
+ 
+ 
+ static const struct file_operations dfs_tgt_sess_ops = {
+ 	.open		= qla2x00_dfs_tgt_sess_open,
+ 	.read		= seq_read,
+ 	.llseek		= seq_lseek,
+ 	.release	= single_release,
+ };
+ 
+ static int
+ qla_dfs_fw_resource_cnt_show(struct seq_file *s, void *unused)
+ {
+ 	struct scsi_qla_host *vha = s->private;
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	seq_puts(s, "FW Resource count\n\n");
+ 	seq_printf(s, "Original TGT exchg count[%d]\n",
+ 	    ha->orig_fw_tgt_xcb_count);
+ 	seq_printf(s, "current TGT exchg count[%d]\n",
+ 	    ha->cur_fw_tgt_xcb_count);
+ 	seq_printf(s, "original Initiator Exchange count[%d]\n",
+ 	    ha->orig_fw_xcb_count);
+ 	seq_printf(s, "Current Initiator Exchange count[%d]\n",
+ 	    ha->cur_fw_xcb_count);
+ 	seq_printf(s, "Original IOCB count[%d]\n", ha->orig_fw_iocb_count);
+ 	seq_printf(s, "Current IOCB count[%d]\n", ha->cur_fw_iocb_count);
+ 	seq_printf(s, "MAX VP count[%d]\n", ha->max_npiv_vports);
+ 	seq_printf(s, "MAX FCF count[%d]\n", ha->fw_max_fcf_count);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ qla_dfs_fw_resource_cnt_open(struct inode *inode, struct file *file)
+ {
+ 	struct scsi_qla_host *vha = inode->i_private;
+ 	return single_open(file, qla_dfs_fw_resource_cnt_show, vha);
+ }
+ 
+ static const struct file_operations dfs_fw_resource_cnt_ops = {
+ 	.open           = qla_dfs_fw_resource_cnt_open,
+ 	.read           = seq_read,
+ 	.llseek         = seq_lseek,
+ 	.release        = single_release,
+ };
+ 
+ static int
+ qla_dfs_tgt_counters_show(struct seq_file *s, void *unused)
+ {
+ 	struct scsi_qla_host *vha = s->private;
+ 
+ 	seq_puts(s, "Target Counters\n");
+ 	seq_printf(s, "qla_core_sbt_cmd = %lld\n",
+ 		vha->tgt_counters.qla_core_sbt_cmd);
+ 	seq_printf(s, "qla_core_ret_sta_ctio = %lld\n",
+ 		vha->tgt_counters.qla_core_ret_sta_ctio);
+ 	seq_printf(s, "qla_core_ret_ctio = %lld\n",
+ 		vha->tgt_counters.qla_core_ret_ctio);
+ 	seq_printf(s, "core_qla_que_buf = %lld\n",
+ 		vha->tgt_counters.core_qla_que_buf);
+ 	seq_printf(s, "core_qla_snd_status = %lld\n",
+ 		vha->tgt_counters.core_qla_snd_status);
+ 	seq_printf(s, "core_qla_free_cmd = %lld\n",
+ 		vha->tgt_counters.core_qla_free_cmd);
+ 	seq_printf(s, "num alloc iocb failed = %lld\n",
+ 		vha->tgt_counters.num_alloc_iocb_failed);
+ 	seq_printf(s, "num term exchange sent = %lld\n",
+ 		vha->tgt_counters.num_term_xchg_sent);
+ 	seq_printf(s, "num Q full sent = %lld\n",
+ 		vha->tgt_counters.num_q_full_sent);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ qla_dfs_tgt_counters_open(struct inode *inode, struct file *file)
+ {
+ 	struct scsi_qla_host *vha = inode->i_private;
+ 	return single_open(file, qla_dfs_tgt_counters_show, vha);
+ }
+ 
+ static const struct file_operations dfs_tgt_counters_ops = {
+ 	.open           = qla_dfs_tgt_counters_open,
+ 	.read           = seq_read,
+ 	.llseek         = seq_lseek,
+ 	.release        = single_release,
+ };
+ 
+ static int
++>>>>>>> 37cacc0a1301 (qla2xxx: Use d_id instead of s_id for more clarity)
  qla2x00_dfs_fce_show(struct seq_file *s, void *unused)
  {
  	scsi_qla_host_t *vha = s->private;
diff --cc drivers/scsi/qla2xxx/qla_target.c
index f10c075d97ef,671875a50951..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -340,8 -522,46 +340,51 @@@ static void qlt_free_session_done(struc
  	struct qla_tgt *tgt = sess->tgt;
  	struct scsi_qla_host *vha = sess->vha;
  	struct qla_hw_data *ha = vha->hw;
++<<<<<<< HEAD
 +
 +	BUG_ON(!tgt);
++=======
+ 	unsigned long flags;
+ 	bool logout_started = false;
+ 	fc_port_t fcport;
+ 
+ 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf084,
+ 		"%s: se_sess %p / sess %p from port %8phC loop_id %#04x"
+ 		" s_id %02x:%02x:%02x logout %d keep %d els_logo %d\n",
+ 		__func__, sess->se_sess, sess, sess->port_name, sess->loop_id,
+ 		sess->d_id.b.domain, sess->d_id.b.area, sess->d_id.b.al_pa,
+ 		sess->logout_on_delete, sess->keep_nport_handle,
+ 		sess->send_els_logo);
+ 
+ 	BUG_ON(!tgt);
+ 
+ 	if (sess->send_els_logo) {
+ 		qlt_port_logo_t logo;
+ 		logo.id = sess->d_id;
+ 		logo.cmd_count = 0;
+ 		qlt_send_first_logo(vha, &logo);
+ 	}
+ 
+ 	if (sess->logout_on_delete) {
+ 		int rc;
+ 
+ 		memset(&fcport, 0, sizeof(fcport));
+ 		fcport.loop_id = sess->loop_id;
+ 		fcport.d_id = sess->d_id;
+ 		memcpy(fcport.port_name, sess->port_name, WWN_SIZE);
+ 		fcport.vha = vha;
+ 		fcport.tgt_session = sess;
+ 
+ 		rc = qla2x00_post_async_logout_work(vha, &fcport, NULL);
+ 		if (rc != QLA_SUCCESS)
+ 			ql_log(ql_log_warn, vha, 0xf085,
+ 			       "Schedule logo failed sess %p rc %d\n",
+ 			       sess, rc);
+ 		else
+ 			logout_started = true;
+ 	}
+ 
++>>>>>>> 37cacc0a1301 (qla2xxx: Use d_id instead of s_id for more clarity)
  	/*
  	 * Release the target session for FC Nexus from fabric module code.
  	 */
@@@ -462,20 -754,22 +505,29 @@@ static void qlt_schedule_sess_for_delet
  	sess->expires = jiffies + dev_loss_tmo * HZ;
  
  	ql_dbg(ql_dbg_tgt, sess->vha, 0xe048,
++<<<<<<< HEAD
 +	    "qla_target(%d): session for port %8phC (loop ID %d) scheduled for "
 +	    "deletion in %u secs (expires: %lu) immed: %d\n",
 +	    sess->vha->vp_idx, sess->port_name, sess->loop_id, dev_loss_tmo,
 +	    sess->expires, immediate);
++=======
+ 	    "qla_target(%d): session for port %8phC (loop ID %d s_id %02x:%02x:%02x)"
+ 	    " scheduled for deletion in %u secs (expires: %lu) immed: %d, logout: %d, gen: %#x\n",
+ 	    sess->vha->vp_idx, sess->port_name, sess->loop_id,
+ 	    sess->d_id.b.domain, sess->d_id.b.area, sess->d_id.b.al_pa,
+ 	    dev_loss_tmo, sess->expires, immediate, sess->logout_on_delete,
+ 	    sess->generation);
++>>>>>>> 37cacc0a1301 (qla2xxx: Use d_id instead of s_id for more clarity)
  
  	if (immediate)
 -		mod_delayed_work(system_wq, &tgt->sess_del_work, 0);
 +		schedule_delayed_work(&tgt->sess_del_work, 0);
  	else
  		schedule_delayed_work(&tgt->sess_del_work,
 -		    sess->expires - jiffies);
 +		    jiffies - sess->expires);
  }
  
 -/* ha->tgt.sess_lock supposed to be held on entry */
 -static void qlt_clear_tgt_db(struct qla_tgt *tgt)
 +/* ha->hardware_lock supposed to be held on entry */
 +static void qlt_clear_tgt_db(struct qla_tgt *tgt, bool local_only)
  {
  	struct qla_tgt_sess *sess;
  
@@@ -752,11 -941,20 +804,11 @@@ static struct qla_tgt_sess *qlt_create_
  
  		return NULL;
  	}
 -	sess->tgt = vha->vha_tgt.qla_tgt;
 +	sess->tgt = ha->tgt.qla_tgt;
  	sess->vha = vha;
- 	sess->s_id = fcport->d_id;
+ 	sess->d_id = fcport->d_id;
  	sess->loop_id = fcport->loop_id;
  	sess->local = local;
 -	kref_init(&sess->sess_kref);
 -	INIT_LIST_HEAD(&sess->del_list_entry);
 -
 -	/* Under normal circumstances we want to logout from firmware when
 -	 * session eventually ends and release corresponding nport handle.
 -	 * In the exception cases (e.g. when new PLOGI is waiting) corresponding
 -	 * code will adjust these flags as necessary. */
 -	sess->logout_on_delete = 1;
 -	sess->keep_nport_handle = 0;
  
  	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf006,
  	    "Adding sess %p to tgt %p via ->check_initiator_node_acl()\n",
@@@ -795,9 -974,26 +847,9 @@@
  	    "qla_target(%d): %ssession for wwn %8phC (loop_id %d, "
  	    "s_id %x:%x:%x, confirmed completion %ssupported) added\n",
  	    vha->vp_idx, local ?  "local " : "", fcport->port_name,
- 	    fcport->loop_id, sess->s_id.b.domain, sess->s_id.b.area,
- 	    sess->s_id.b.al_pa, sess->conf_compl_supported ?  "" : "not ");
+ 	    fcport->loop_id, sess->d_id.b.domain, sess->d_id.b.area,
+ 	    sess->d_id.b.al_pa, sess->conf_compl_supported ?  "" : "not ");
  
 -	/*
 -	 * Determine if this fc_port->port_name is allowed to access
 -	 * target mode using explict NodeACLs+MappedLUNs, or using
 -	 * TPG demo mode.  If this is successful a target mode FC nexus
 -	 * is created.
 -	 */
 -	if (ha->tgt.tgt_ops->check_initiator_node_acl(vha,
 -	    &fcport->port_name[0], sess) < 0) {
 -		return NULL;
 -	} else {
 -		/*
 -		 * Take an extra reference to ->sess_kref here to handle qla_tgt_sess
 -		 * access across ->tgt.sess_lock reaquire.
 -		 */
 -		kref_get(&sess->sess_kref);
 -	}
 -
  	return sess;
  }
  
@@@ -2955,6 -4008,126 +3007,129 @@@ static int qlt_abort_task(struct scsi_q
  	return __qlt_abort_task(vha, iocb, sess);
  }
  
++<<<<<<< HEAD
++=======
+ void qlt_logo_completion_handler(fc_port_t *fcport, int rc)
+ {
+ 	if (fcport->tgt_session) {
+ 		if (rc != MBS_COMMAND_COMPLETE) {
+ 			ql_dbg(ql_dbg_tgt_mgt, fcport->vha, 0xf093,
+ 				"%s: se_sess %p / sess %p from"
+ 				" port %8phC loop_id %#04x s_id %02x:%02x:%02x"
+ 				" LOGO failed: %#x\n",
+ 				__func__,
+ 				fcport->tgt_session->se_sess,
+ 				fcport->tgt_session,
+ 				fcport->port_name, fcport->loop_id,
+ 				fcport->d_id.b.domain, fcport->d_id.b.area,
+ 				fcport->d_id.b.al_pa, rc);
+ 		}
+ 
+ 		fcport->tgt_session->logout_completed = 1;
+ 	}
+ }
+ 
+ /*
+ * ha->hardware_lock supposed to be held on entry (to protect tgt->sess_list)
+ *
+ * Schedules sessions with matching port_id/loop_id but different wwn for
+ * deletion. Returns existing session with matching wwn if present.
+ * Null otherwise.
+ */
+ static struct qla_tgt_sess *
+ qlt_find_sess_invalidate_other(struct qla_tgt *tgt, uint64_t wwn,
+     port_id_t port_id, uint16_t loop_id, struct qla_tgt_sess **conflict_sess)
+ {
+ 	struct qla_tgt_sess *sess = NULL, *other_sess;
+ 	uint64_t other_wwn;
+ 
+ 	*conflict_sess = NULL;
+ 
+ 	list_for_each_entry(other_sess, &tgt->sess_list, sess_list_entry) {
+ 
+ 		other_wwn = wwn_to_u64(other_sess->port_name);
+ 
+ 		if (wwn == other_wwn) {
+ 			WARN_ON(sess);
+ 			sess = other_sess;
+ 			continue;
+ 		}
+ 
+ 		/* find other sess with nport_id collision */
+ 		if (port_id.b24 == other_sess->d_id.b24) {
+ 			if (loop_id != other_sess->loop_id) {
+ 				ql_dbg(ql_dbg_tgt_tmr, tgt->vha, 0x1000c,
+ 				    "Invalidating sess %p loop_id %d wwn %llx.\n",
+ 				    other_sess, other_sess->loop_id, other_wwn);
+ 
+ 				/*
+ 				 * logout_on_delete is set by default, but another
+ 				 * session that has the same s_id/loop_id combo
+ 				 * might have cleared it when requested this session
+ 				 * deletion, so don't touch it
+ 				 */
+ 				qlt_schedule_sess_for_deletion(other_sess, true);
+ 			} else {
+ 				/*
+ 				 * Another wwn used to have our s_id/loop_id
+ 				 * kill the session, but don't free the loop_id
+ 				 */
+ 				other_sess->keep_nport_handle = 1;
+ 				*conflict_sess = other_sess;
+ 				qlt_schedule_sess_for_deletion(other_sess,
+ 				    true);
+ 			}
+ 			continue;
+ 		}
+ 
+ 		/* find other sess with nport handle collision */
+ 		if (loop_id == other_sess->loop_id) {
+ 			ql_dbg(ql_dbg_tgt_tmr, tgt->vha, 0x1000d,
+ 			       "Invalidating sess %p loop_id %d wwn %llx.\n",
+ 			       other_sess, other_sess->loop_id, other_wwn);
+ 
+ 			/* Same loop_id but different s_id
+ 			 * Ok to kill and logout */
+ 			qlt_schedule_sess_for_deletion(other_sess, true);
+ 		}
+ 	}
+ 
+ 	return sess;
+ }
+ 
+ /* Abort any commands for this s_id waiting on qla_tgt_wq workqueue */
+ static int abort_cmds_for_s_id(struct scsi_qla_host *vha, port_id_t *s_id)
+ {
+ 	struct qla_tgt_sess_op *op;
+ 	struct qla_tgt_cmd *cmd;
+ 	uint32_t key;
+ 	int count = 0;
+ 
+ 	key = (((u32)s_id->b.domain << 16) |
+ 	       ((u32)s_id->b.area   <<  8) |
+ 	       ((u32)s_id->b.al_pa));
+ 
+ 	spin_lock(&vha->cmd_list_lock);
+ 	list_for_each_entry(op, &vha->qla_sess_op_cmd_list, cmd_list) {
+ 		uint32_t op_key = sid_to_key(op->atio.u.isp24.fcp_hdr.s_id);
+ 		if (op_key == key) {
+ 			op->aborted = true;
+ 			count++;
+ 		}
+ 	}
+ 	list_for_each_entry(cmd, &vha->qla_cmd_list, cmd_list) {
+ 		uint32_t cmd_key = sid_to_key(cmd->atio.u.isp24.fcp_hdr.s_id);
+ 		if (cmd_key == key) {
+ 			cmd->aborted = 1;
+ 			count++;
+ 		}
+ 	}
+ 	spin_unlock(&vha->cmd_list_lock);
+ 
+ 	return count;
+ }
+ 
++>>>>>>> 37cacc0a1301 (qla2xxx: Use d_id instead of s_id for more clarity)
  /*
   * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire
   */
@@@ -2968,10 -4158,132 +3143,134 @@@ static int qlt_24xx_handle_els(struct s
  	    "qla_target(%d): Port ID: 0x%3phC ELS opcode: 0x%02x\n",
  	    vha->vp_idx, iocb->u.isp24.port_id, iocb->u.isp24.status_subcode);
  
 -	/* res = 1 means ack at the end of thread
 -	 * res = 0 means ack async/later.
 -	 */
  	switch (iocb->u.isp24.status_subcode) {
  	case ELS_PLOGI:
++<<<<<<< HEAD
 +	case ELS_FLOGI:
 +	case ELS_PRLI:
++=======
+ 
+ 		/* Mark all stale commands in qla_tgt_wq for deletion */
+ 		abort_cmds_for_s_id(vha, &port_id);
+ 
+ 		if (wwn) {
+ 			spin_lock_irqsave(&tgt->ha->tgt.sess_lock, flags);
+ 			sess = qlt_find_sess_invalidate_other(tgt, wwn,
+ 			    port_id, loop_id, &conflict_sess);
+ 			spin_unlock_irqrestore(&tgt->ha->tgt.sess_lock, flags);
+ 		}
+ 
+ 		if (IS_SW_RESV_ADDR(port_id) || (!sess && !conflict_sess)) {
+ 			res = 1;
+ 			break;
+ 		}
+ 
+ 		pla = qlt_plogi_ack_find_add(vha, &port_id, iocb);
+ 		if (!pla) {
+ 			qlt_send_term_imm_notif(vha, iocb, 1);
+ 
+ 			res = 0;
+ 			break;
+ 		}
+ 
+ 		res = 0;
+ 
+ 		if (conflict_sess)
+ 			qlt_plogi_ack_link(vha, pla, conflict_sess,
+ 			    QLT_PLOGI_LINK_CONFLICT);
+ 
+ 		if (!sess)
+ 			break;
+ 
+ 		qlt_plogi_ack_link(vha, pla, sess, QLT_PLOGI_LINK_SAME_WWN);
+ 		 /*
+ 		  * Under normal circumstances we want to release nport handle
+ 		  * during LOGO process to avoid nport handle leaks inside FW.
+ 		  * The exception is when LOGO is done while another PLOGI with
+ 		  * the same nport handle is waiting as might be the case here.
+ 		  * Note: there is always a possibily of a race where session
+ 		  * deletion has already started for other reasons (e.g. ACL
+ 		  * removal) and now PLOGI arrives:
+ 		  * 1. if PLOGI arrived in FW after nport handle has been freed,
+ 		  *    FW must have assigned this PLOGI a new/same handle and we
+ 		  *    can proceed ACK'ing it as usual when session deletion
+ 		  *    completes.
+ 		  * 2. if PLOGI arrived in FW before LOGO with LCF_FREE_NPORT
+ 		  *    bit reached it, the handle has now been released. We'll
+ 		  *    get an error when we ACK this PLOGI. Nothing will be sent
+ 		  *    back to initiator. Initiator should eventually retry
+ 		  *    PLOGI and situation will correct itself.
+ 		  */
+ 		sess->keep_nport_handle = ((sess->loop_id == loop_id) &&
+ 					   (sess->d_id.b24 == port_id.b24));
+ 		qlt_schedule_sess_for_deletion(sess, true);
+ 		break;
+ 
+ 	case ELS_PRLI:
+ 		wd3_lo = le16_to_cpu(iocb->u.isp24.u.prli.wd3_lo);
+ 
+ 		if (wwn) {
+ 			spin_lock_irqsave(&tgt->ha->tgt.sess_lock, flags);
+ 			sess = qlt_find_sess_invalidate_other(tgt, wwn, port_id,
+ 			    loop_id, &conflict_sess);
+ 			spin_unlock_irqrestore(&tgt->ha->tgt.sess_lock, flags);
+ 		}
+ 
+ 		if (conflict_sess) {
+ 			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf09b,
+ 			    "PRLI with conflicting sess %p port %8phC\n",
+ 			    conflict_sess, conflict_sess->port_name);
+ 			qlt_send_term_imm_notif(vha, iocb, 1);
+ 			res = 0;
+ 			break;
+ 		}
+ 
+ 		if (sess != NULL) {
+ 			if (sess->deleted) {
+ 				/*
+ 				 * Impatient initiator sent PRLI before last
+ 				 * PLOGI could finish. Will force him to re-try,
+ 				 * while last one finishes.
+ 				 */
+ 				ql_log(ql_log_warn, sess->vha, 0xf095,
+ 				    "sess %p PRLI received, before plogi ack.\n",
+ 				    sess);
+ 				qlt_send_term_imm_notif(vha, iocb, 1);
+ 				res = 0;
+ 				break;
+ 			}
+ 
+ 			/*
+ 			 * This shouldn't happen under normal circumstances,
+ 			 * since we have deleted the old session during PLOGI
+ 			 */
+ 			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf096,
+ 			    "PRLI (loop_id %#04x) for existing sess %p (loop_id %#04x)\n",
+ 			    sess->loop_id, sess, iocb->u.isp24.nport_handle);
+ 
+ 			sess->local = 0;
+ 			sess->loop_id = loop_id;
+ 			sess->d_id = port_id;
+ 
+ 			if (wd3_lo & BIT_7)
+ 				sess->conf_compl_supported = 1;
+ 
+ 		}
+ 		res = 1; /* send notify ack */
+ 
+ 		/* Make session global (not used in fabric mode) */
+ 		if (ha->current_topology != ISP_CFG_F) {
+ 			set_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);
+ 			set_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);
+ 			qla2xxx_wake_dpc(vha);
+ 		} else {
+ 			/* todo: else - create sess here. */
+ 			res = 1; /* send notify ack */
+ 		}
+ 
+ 		break;
+ 
++>>>>>>> 37cacc0a1301 (qla2xxx: Use d_id instead of s_id for more clarity)
  	case ELS_LOGO:
  	case ELS_PRLO:
  		res = qlt_reset(vha, iocb, QLA_TGT_NEXUS_LOSS_SESS);
diff --cc drivers/scsi/qla2xxx/tcm_qla2xxx.c
index 45ec37d3095c,c96de1cfbd85..000000000000
--- a/drivers/scsi/qla2xxx/tcm_qla2xxx.c
+++ b/drivers/scsi/qla2xxx/tcm_qla2xxx.c
@@@ -1380,6 -1427,39 +1380,42 @@@ static void tcm_qla2xxx_free_session(st
  	transport_deregister_session(sess->se_sess);
  }
  
++<<<<<<< HEAD
++=======
+ static int tcm_qla2xxx_session_cb(struct se_portal_group *se_tpg,
+ 				  struct se_session *se_sess, void *p)
+ {
+ 	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
+ 				struct tcm_qla2xxx_tpg, se_tpg);
+ 	struct tcm_qla2xxx_lport *lport = tpg->lport;
+ 	struct qla_hw_data *ha = lport->qla_vha->hw;
+ 	struct se_node_acl *se_nacl = se_sess->se_node_acl;
+ 	struct tcm_qla2xxx_nacl *nacl = container_of(se_nacl,
+ 				struct tcm_qla2xxx_nacl, se_node_acl);
+ 	struct qla_tgt_sess *qlat_sess = p;
+ 	uint16_t loop_id = qlat_sess->loop_id;
+ 	unsigned long flags;
+ 	unsigned char be_sid[3];
+ 
+ 	be_sid[0] = qlat_sess->d_id.b.domain;
+ 	be_sid[1] = qlat_sess->d_id.b.area;
+ 	be_sid[2] = qlat_sess->d_id.b.al_pa;
+ 
+ 	/*
+ 	 * And now setup se_nacl and session pointers into HW lport internal
+ 	 * mappings for fabric S_ID and LOOP_ID.
+ 	 */
+ 	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
+ 	tcm_qla2xxx_set_sess_by_s_id(lport, se_nacl, nacl,
+ 				     se_sess, qlat_sess, be_sid);
+ 	tcm_qla2xxx_set_sess_by_loop_id(lport, se_nacl, nacl,
+ 					se_sess, qlat_sess, loop_id);
+ 	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 37cacc0a1301 (qla2xxx: Use d_id instead of s_id for more clarity)
  /*
   * Called via qlt_create_sess():ha->qla2x_tmpl->check_initiator_node_acl()
   * to locate struct se_node_acl
* Unmerged path drivers/scsi/qla2xxx/qla_dfs.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
diff --git a/drivers/scsi/qla2xxx/qla_target.h b/drivers/scsi/qla2xxx/qla_target.h
index b33e411f28a0..c0fe908b992b 100644
--- a/drivers/scsi/qla2xxx/qla_target.h
+++ b/drivers/scsi/qla2xxx/qla_target.h
@@ -810,7 +810,7 @@ struct qla_tgt {
  */
 struct qla_tgt_sess {
 	uint16_t loop_id;
-	port_id_t s_id;
+	port_id_t d_id;
 
 	unsigned int conf_compl_supported:1;
 	unsigned int deleted:1;
* Unmerged path drivers/scsi/qla2xxx/tcm_qla2xxx.c
