scsi: cxlflash: Cleanup send_tmf()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] cxlflash: Cleanup send_tmf() (Gustavo Duarte) [1456494]
Rebuild_FUZZ: 90.32%
commit-author Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
commit d4ace35166e55e73afe72a05d166342996063d35
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d4ace351.failed

The send_tmf() routine includes some copy/paste cruft that can be
removed as well as the setting of an AFU command-specific while
holding the tmf_slock. While not a bug, it is out of place and
should be shifted down alongside the other command initialization
statements for clarity.

	Signed-off-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
	Acked-by: Uma Krishnan <ukrishn@linux.vnet.ibm.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit d4ace35166e55e73afe72a05d166342996063d35)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/cxlflash/main.c
diff --cc drivers/scsi/cxlflash/main.c
index d8aaf45b8306,b7636993a097..000000000000
--- a/drivers/scsi/cxlflash/main.c
+++ b/drivers/scsi/cxlflash/main.c
@@@ -366,12 -299,10 +366,15 @@@ static void wait_resp(struct afu *afu, 
   */
  static int send_tmf(struct afu *afu, struct scsi_cmnd *scp, u64 tmfcmd)
  {
++<<<<<<< HEAD
 +	struct afu_cmd *cmd;
 +
++=======
++>>>>>>> d4ace35166e5 (scsi: cxlflash: Cleanup send_tmf())
  	u32 port_sel = scp->device->channel + 1;
- 	short lflag = 0;
  	struct Scsi_Host *host = scp->device->host;
  	struct cxlflash_cfg *cfg = (struct cxlflash_cfg *)host->hostdata;
+ 	struct afu_cmd *cmd = sc_to_afucz(scp);
  	struct device *dev = &cfg->dev->dev;
  	ulong lock_flags;
  	int rc = 0;
@@@ -391,28 -315,23 +394,32 @@@
  						  !cfg->tmf_active,
  						  cfg->tmf_slock);
  	cfg->tmf_active = true;
- 	cmd->cmd_tmf = true;
  	spin_unlock_irqrestore(&cfg->tmf_slock, lock_flags);
  
+ 	cmd->rcb.scp = scp;
+ 	cmd->parent = afu;
+ 	cmd->cmd_tmf = true;
+ 
  	cmd->rcb.ctx_id = afu->ctx_hndl;
 -	cmd->rcb.msi = SISL_MSI_RRQ_UPDATED;
  	cmd->rcb.port_sel = port_sel;
  	cmd->rcb.lun_id = lun_to_lunid(scp->device->lun);
- 
- 	lflag = SISL_REQ_FLAGS_TMF_CMD;
- 
  	cmd->rcb.req_flags = (SISL_REQ_FLAGS_PORT_LUN_ID |
++<<<<<<< HEAD
 +			      SISL_REQ_FLAGS_SUP_UNDERRUN | lflag);
 +
 +	/* Stash the scp in the reserved field, for reuse during interrupt */
 +	cmd->rcb.scp = scp;
 +
 +	/* Copy the CDB from the cmd passed in */
++=======
+ 			      SISL_REQ_FLAGS_SUP_UNDERRUN |
+ 			      SISL_REQ_FLAGS_TMF_CMD);
++>>>>>>> d4ace35166e5 (scsi: cxlflash: Cleanup send_tmf())
  	memcpy(cmd->rcb.cdb, &tmfcmd, sizeof(tmfcmd));
  
- 	/* Send the command */
  	rc = send_cmd(afu, cmd);
  	if (unlikely(rc)) {
 +		cmd_checkin(cmd);
  		spin_lock_irqsave(&cfg->tmf_slock, lock_flags);
  		cfg->tmf_active = false;
  		spin_unlock_irqrestore(&cfg->tmf_slock, lock_flags);
* Unmerged path drivers/scsi/cxlflash/main.c
