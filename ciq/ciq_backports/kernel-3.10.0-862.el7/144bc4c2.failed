target: move node ACL allocation to core code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [target] move node ACL allocation to core code (Maurizio Lombardi) [1366062]
Rebuild_FUZZ: 90.24%
commit-author Christoph Hellwig <hch@lst.de>
commit 144bc4c2a42a0f42a32c106d53f5bf2724fbf098
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/144bc4c2.failed

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 144bc4c2a42a0f42a32c106d53f5bf2724fbf098)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/srpt/ib_srpt.c
#	drivers/scsi/qla2xxx/tcm_qla2xxx.c
#	drivers/target/iscsi/iscsi_target_configfs.c
#	drivers/target/loopback/tcm_loop.c
#	drivers/target/sbp/sbp_target.c
#	drivers/target/target_core_tpg.c
#	drivers/target/tcm_fc/tfc_conf.c
#	drivers/usb/gadget/tcm_usb_gadget.c
#	drivers/vhost/scsi.c
#	drivers/xen/xen-scsiback.c
#	include/target/target_core_fabric.h
diff --cc drivers/infiniband/ulp/srpt/ib_srpt.c
index 72146d165e84,38e51f4a17de..000000000000
--- a/drivers/infiniband/ulp/srpt/ib_srpt.c
+++ b/drivers/infiniband/ulp/srpt/ib_srpt.c
@@@ -3219,7 -3858,10 +3197,14 @@@ static struct configfs_attribute *srpt_
  	NULL,
  };
  
++<<<<<<< HEAD
 +static struct target_core_fabric_ops srpt_template = {
++=======
+ static const struct target_core_fabric_ops srpt_template = {
+ 	.module				= THIS_MODULE,
+ 	.name				= "srpt",
+ 	.node_acl_size			= sizeof(struct srpt_node_acl),
++>>>>>>> 144bc4c2a42a (target: move node ACL allocation to core code)
  	.get_fabric_name		= srpt_get_fabric_name,
  	.get_fabric_proto_ident		= srpt_get_fabric_proto_ident,
  	.tpg_get_wwn			= srpt_get_fabric_wwn,
diff --cc drivers/scsi/qla2xxx/tcm_qla2xxx.c
index 14250fcfe054,cb376e5198d0..000000000000
--- a/drivers/scsi/qla2xxx/tcm_qla2xxx.c
+++ b/drivers/scsi/qla2xxx/tcm_qla2xxx.c
@@@ -349,27 -330,12 +349,36 @@@ static int tcm_qla2xxx_check_demo_mode_
  	return tpg->tpg_attrib.demo_mode_login_only;
  }
  
++<<<<<<< HEAD
 +static struct se_node_acl *tcm_qla2xxx_alloc_fabric_acl(
 +	struct se_portal_group *se_tpg)
 +{
 +	struct tcm_qla2xxx_nacl *nacl;
 +
 +	nacl = kzalloc(sizeof(struct tcm_qla2xxx_nacl), GFP_KERNEL);
 +	if (!nacl) {
 +		pr_err("Unable to allocate struct tcm_qla2xxx_nacl\n");
 +		return NULL;
 +	}
 +
 +	return &nacl->se_node_acl;
 +}
 +
 +static void tcm_qla2xxx_release_fabric_acl(
 +	struct se_portal_group *se_tpg,
 +	struct se_node_acl *se_nacl)
 +{
 +	struct tcm_qla2xxx_nacl *nacl = container_of(se_nacl,
 +			struct tcm_qla2xxx_nacl, se_node_acl);
 +	kfree(nacl);
++=======
+ static int tcm_qla2xxx_check_prot_fabric_only(struct se_portal_group *se_tpg)
+ {
+ 	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
+ 				struct tcm_qla2xxx_tpg, se_tpg);
+ 
+ 	return tpg->tpg_attrib.fabric_prot_type;
++>>>>>>> 144bc4c2a42a (target: move node ACL allocation to core code)
  }
  
  static u32 tcm_qla2xxx_tpg_get_inst_index(struct se_portal_group *se_tpg)
@@@ -1732,7 -1923,10 +1741,14 @@@ static struct configfs_attribute *tcm_q
  	NULL,
  };
  
++<<<<<<< HEAD
 +static struct target_core_fabric_ops tcm_qla2xxx_ops = {
++=======
+ static const struct target_core_fabric_ops tcm_qla2xxx_ops = {
+ 	.module				= THIS_MODULE,
+ 	.name				= "qla2xxx",
+ 	.node_acl_size			= sizeof(struct tcm_qla2xxx_nacl),
++>>>>>>> 144bc4c2a42a (target: move node ACL allocation to core code)
  	.get_fabric_name		= tcm_qla2xxx_get_fabric_name,
  	.get_fabric_proto_ident		= tcm_qla2xxx_get_fabric_proto_ident,
  	.tpg_get_wwn			= tcm_qla2xxx_get_fabric_wwn,
@@@ -1747,9 -1940,8 +1763,7 @@@
  					tcm_qla2xxx_check_demo_write_protect,
  	.tpg_check_prod_mode_write_protect =
  					tcm_qla2xxx_check_prod_write_protect,
 -	.tpg_check_prot_fabric_only	= tcm_qla2xxx_check_prot_fabric_only,
  	.tpg_check_demo_mode_login_only = tcm_qla2xxx_check_demo_mode_login_only,
- 	.tpg_alloc_fabric_acl		= tcm_qla2xxx_alloc_fabric_acl,
- 	.tpg_release_fabric_acl		= tcm_qla2xxx_release_fabric_acl,
  	.tpg_get_inst_index		= tcm_qla2xxx_tpg_get_inst_index,
  	.check_stop_free		= tcm_qla2xxx_check_stop_free,
  	.release_cmd			= tcm_qla2xxx_release_cmd,
@@@ -1774,15 -1967,17 +1788,22 @@@
  	.fabric_drop_wwn		= tcm_qla2xxx_drop_lport,
  	.fabric_make_tpg		= tcm_qla2xxx_make_tpg,
  	.fabric_drop_tpg		= tcm_qla2xxx_drop_tpg,
 -	.fabric_init_nodeacl		= tcm_qla2xxx_init_nodeacl,
 -
 -	.tfc_wwn_attrs			= tcm_qla2xxx_wwn_attrs,
 -	.tfc_tpg_base_attrs		= tcm_qla2xxx_tpg_attrs,
 -	.tfc_tpg_attrib_attrs		= tcm_qla2xxx_tpg_attrib_attrs,
 +	.fabric_post_link		= NULL,
 +	.fabric_pre_unlink		= NULL,
 +	.fabric_make_np			= NULL,
 +	.fabric_drop_np			= NULL,
 +	.fabric_make_nodeacl		= tcm_qla2xxx_make_nodeacl,
 +	.fabric_drop_nodeacl		= tcm_qla2xxx_drop_nodeacl,
  };
  
++<<<<<<< HEAD
 +static struct target_core_fabric_ops tcm_qla2xxx_npiv_ops = {
++=======
+ static const struct target_core_fabric_ops tcm_qla2xxx_npiv_ops = {
+ 	.module				= THIS_MODULE,
+ 	.name				= "qla2xxx_npiv",
+ 	.node_acl_size			= sizeof(struct tcm_qla2xxx_nacl),
++>>>>>>> 144bc4c2a42a (target: move node ACL allocation to core code)
  	.get_fabric_name		= tcm_qla2xxx_npiv_get_fabric_name,
  	.get_fabric_proto_ident		= tcm_qla2xxx_get_fabric_proto_ident,
  	.tpg_get_wwn			= tcm_qla2xxx_get_fabric_wwn,
@@@ -1791,14 -1985,14 +1812,12 @@@
  	.tpg_get_pr_transport_id	= tcm_qla2xxx_get_pr_transport_id,
  	.tpg_get_pr_transport_id_len	= tcm_qla2xxx_get_pr_transport_id_len,
  	.tpg_parse_pr_out_transport_id	= tcm_qla2xxx_parse_pr_out_transport_id,
 -	.tpg_check_demo_mode		= tcm_qla2xxx_check_demo_mode,
 -	.tpg_check_demo_mode_cache	= tcm_qla2xxx_check_demo_mode_cache,
 -	.tpg_check_demo_mode_write_protect = tcm_qla2xxx_check_demo_mode,
 -	.tpg_check_prod_mode_write_protect =
 -	    tcm_qla2xxx_check_prod_write_protect,
 +	.tpg_check_demo_mode		= tcm_qla2xxx_check_false,
 +	.tpg_check_demo_mode_cache	= tcm_qla2xxx_check_true,
 +	.tpg_check_demo_mode_write_protect = tcm_qla2xxx_check_true,
 +	.tpg_check_prod_mode_write_protect = tcm_qla2xxx_check_false,
  	.tpg_check_demo_mode_login_only	= tcm_qla2xxx_check_demo_mode_login_only,
- 	.tpg_alloc_fabric_acl		= tcm_qla2xxx_alloc_fabric_acl,
- 	.tpg_release_fabric_acl		= tcm_qla2xxx_release_fabric_acl,
  	.tpg_get_inst_index		= tcm_qla2xxx_tpg_get_inst_index,
 -	.check_stop_free                = tcm_qla2xxx_check_stop_free,
  	.release_cmd			= tcm_qla2xxx_release_cmd,
  	.put_session			= tcm_qla2xxx_put_session,
  	.shutdown_session		= tcm_qla2xxx_shutdown_session,
diff --cc drivers/target/iscsi/iscsi_target_configfs.c
index e02616d0c024,643024c1ee8d..000000000000
--- a/drivers/target/iscsi/iscsi_target_configfs.c
+++ b/drivers/target/iscsi/iscsi_target_configfs.c
@@@ -948,48 -860,12 +948,53 @@@ static struct configfs_attribute *lio_t
  	NULL,
  };
  
++<<<<<<< HEAD
 +static struct se_node_acl *lio_tpg_alloc_fabric_acl(
 +	struct se_portal_group *se_tpg)
 +{
 +	struct iscsi_node_acl *acl;
 +
 +	acl = kzalloc(sizeof(struct iscsi_node_acl), GFP_KERNEL);
 +	if (!acl) {
 +		pr_err("Unable to allocate memory for struct iscsi_node_acl\n");
 +		return NULL;
 +	}
 +
 +	return &acl->se_node_acl;
 +}
 +
 +static struct se_node_acl *lio_target_make_nodeacl(
 +	struct se_portal_group *se_tpg,
 +	struct config_group *group,
 +	const char *name)
++=======
+ static int lio_target_init_nodeacl(struct se_node_acl *se_nacl,
+ 		const char *name)
++>>>>>>> 144bc4c2a42a (target: move node ACL allocation to core code)
  {
 -	struct iscsi_node_acl *acl =
 -		container_of(se_nacl, struct iscsi_node_acl, se_node_acl);
 -	struct config_group *stats_cg = &se_nacl->acl_fabric_stat_group;
 +	struct config_group *stats_cg;
 +	struct iscsi_node_acl *acl;
 +	struct se_node_acl *se_nacl_new, *se_nacl;
 +	struct iscsi_portal_group *tpg = container_of(se_tpg,
 +			struct iscsi_portal_group, tpg_se_tpg);
 +	u32 cmdsn_depth;
 +
 +	se_nacl_new = lio_tpg_alloc_fabric_acl(se_tpg);
 +	if (!se_nacl_new)
 +		return ERR_PTR(-ENOMEM);
 +
 +	cmdsn_depth = tpg->tpg_attrib.default_cmdsn_depth;
 +	/*
 +	 * se_nacl_new may be released by core_tpg_add_initiator_node_acl()
 +	 * when converting a NdoeACL from demo mode -> explict
 +	 */
 +	se_nacl = core_tpg_add_initiator_node_acl(se_tpg, se_nacl_new,
 +				name, cmdsn_depth);
 +	if (IS_ERR(se_nacl))
 +		return se_nacl;
 +
 +	acl = container_of(se_nacl, struct iscsi_node_acl, se_node_acl);
 +	stats_cg = &se_nacl->acl_fabric_stat_group;
  
  	stats_cg->default_groups = kmalloc(sizeof(struct config_group *) * 2,
  				GFP_KERNEL);
@@@ -1970,13 -1840,18 +1975,28 @@@ static int lio_tpg_check_prod_mode_writ
  	return tpg->tpg_attrib.prod_mode_write_protect;
  }
  
++<<<<<<< HEAD
 +static void lio_tpg_release_fabric_acl(
 +	struct se_portal_group *se_tpg,
 +	struct se_node_acl *se_acl)
 +{
 +	struct iscsi_node_acl *acl = container_of(se_acl,
 +				struct iscsi_node_acl, se_node_acl);
 +	kfree(acl);
++=======
+ static int lio_tpg_check_prot_fabric_only(
+ 	struct se_portal_group *se_tpg)
+ {
+ 	struct iscsi_portal_group *tpg = se_tpg->se_tpg_fabric_ptr;
+ 	/*
+ 	 * Only report fabric_prot_type if t10_pi has also been enabled
+ 	 * for incoming ib_isert sessions.
+ 	 */
+ 	if (!tpg->tpg_attrib.t10_pi)
+ 		return 0;
+ 
+ 	return tpg->tpg_attrib.fabric_prot_type;
++>>>>>>> 144bc4c2a42a (target: move node ACL allocation to core code)
  }
  
  /*
@@@ -2051,115 -1926,59 +2071,161 @@@ static void lio_release_cmd(struct se_c
  	iscsit_release_cmd(cmd);
  }
  
++<<<<<<< HEAD
 +/* End functions for target_core_fabric_ops */
++=======
+ const struct target_core_fabric_ops iscsi_ops = {
+ 	.module				= THIS_MODULE,
+ 	.name				= "iscsi",
+ 	.node_acl_size			= sizeof(struct iscsi_node_acl),
+ 	.get_fabric_name		= iscsi_get_fabric_name,
+ 	.get_fabric_proto_ident		= iscsi_get_fabric_proto_ident,
+ 	.tpg_get_wwn			= lio_tpg_get_endpoint_wwn,
+ 	.tpg_get_tag			= lio_tpg_get_tag,
+ 	.tpg_get_default_depth		= lio_tpg_get_default_depth,
+ 	.tpg_get_pr_transport_id	= iscsi_get_pr_transport_id,
+ 	.tpg_get_pr_transport_id_len	= iscsi_get_pr_transport_id_len,
+ 	.tpg_parse_pr_out_transport_id	= iscsi_parse_pr_out_transport_id,
+ 	.tpg_check_demo_mode		= lio_tpg_check_demo_mode,
+ 	.tpg_check_demo_mode_cache	= lio_tpg_check_demo_mode_cache,
+ 	.tpg_check_demo_mode_write_protect =
+ 			lio_tpg_check_demo_mode_write_protect,
+ 	.tpg_check_prod_mode_write_protect =
+ 			lio_tpg_check_prod_mode_write_protect,
+ 	.tpg_check_prot_fabric_only	= &lio_tpg_check_prot_fabric_only,
+ 	.tpg_get_inst_index		= lio_tpg_get_inst_index,
+ 	.check_stop_free		= lio_check_stop_free,
+ 	.release_cmd			= lio_release_cmd,
+ 	.shutdown_session		= lio_tpg_shutdown_session,
+ 	.close_session			= lio_tpg_close_session,
+ 	.sess_get_index			= lio_sess_get_index,
+ 	.sess_get_initiator_sid		= lio_sess_get_initiator_sid,
+ 	.write_pending			= lio_write_pending,
+ 	.write_pending_status		= lio_write_pending_status,
+ 	.set_default_node_attributes	= lio_set_default_node_attributes,
+ 	.get_task_tag			= iscsi_get_task_tag,
+ 	.get_cmd_state			= iscsi_get_cmd_state,
+ 	.queue_data_in			= lio_queue_data_in,
+ 	.queue_status			= lio_queue_status,
+ 	.queue_tm_rsp			= lio_queue_tm_rsp,
+ 	.aborted_task			= lio_aborted_task,
+ 	.fabric_make_wwn		= lio_target_call_coreaddtiqn,
+ 	.fabric_drop_wwn		= lio_target_call_coredeltiqn,
+ 	.fabric_make_tpg		= lio_target_tiqn_addtpg,
+ 	.fabric_drop_tpg		= lio_target_tiqn_deltpg,
+ 	.fabric_make_np			= lio_target_call_addnptotpg,
+ 	.fabric_drop_np			= lio_target_call_delnpfromtpg,
+ 	.fabric_init_nodeacl		= lio_target_init_nodeacl,
+ 	.fabric_cleanup_nodeacl		= lio_target_cleanup_nodeacl,
++>>>>>>> 144bc4c2a42a (target: move node ACL allocation to core code)
  
 -	.tfc_discovery_attrs		= lio_target_discovery_auth_attrs,
 -	.tfc_wwn_attrs			= lio_target_wwn_attrs,
 -	.tfc_tpg_base_attrs		= lio_target_tpg_attrs,
 -	.tfc_tpg_attrib_attrs		= lio_target_tpg_attrib_attrs,
 -	.tfc_tpg_auth_attrs		= lio_target_tpg_auth_attrs,
 -	.tfc_tpg_param_attrs		= lio_target_tpg_param_attrs,
 -	.tfc_tpg_np_base_attrs		= lio_target_portal_attrs,
 -	.tfc_tpg_nacl_base_attrs	= lio_target_initiator_attrs,
 -	.tfc_tpg_nacl_attrib_attrs	= lio_target_nacl_attrib_attrs,
 -	.tfc_tpg_nacl_auth_attrs	= lio_target_nacl_auth_attrs,
 -	.tfc_tpg_nacl_param_attrs	= lio_target_nacl_param_attrs,
 -};
 +int iscsi_target_register_configfs(void)
 +{
 +	struct target_fabric_configfs *fabric;
 +	int ret;
 +
 +	lio_target_fabric_configfs = NULL;
 +	fabric = target_fabric_configfs_init(THIS_MODULE, "iscsi");
 +	if (IS_ERR(fabric)) {
 +		pr_err("target_fabric_configfs_init() for"
 +				" LIO-Target failed!\n");
 +		return PTR_ERR(fabric);
 +	}
 +	/*
 +	 * Setup the fabric API of function pointers used by target_core_mod..
 +	 */
 +	fabric->tf_ops.get_fabric_name = &iscsi_get_fabric_name;
 +	fabric->tf_ops.get_fabric_proto_ident = &iscsi_get_fabric_proto_ident;
 +	fabric->tf_ops.tpg_get_wwn = &lio_tpg_get_endpoint_wwn;
 +	fabric->tf_ops.tpg_get_tag = &lio_tpg_get_tag;
 +	fabric->tf_ops.tpg_get_default_depth = &lio_tpg_get_default_depth;
 +	fabric->tf_ops.tpg_get_pr_transport_id = &iscsi_get_pr_transport_id;
 +	fabric->tf_ops.tpg_get_pr_transport_id_len =
 +				&iscsi_get_pr_transport_id_len;
 +	fabric->tf_ops.tpg_parse_pr_out_transport_id =
 +				&iscsi_parse_pr_out_transport_id;
 +	fabric->tf_ops.tpg_check_demo_mode = &lio_tpg_check_demo_mode;
 +	fabric->tf_ops.tpg_check_demo_mode_cache =
 +				&lio_tpg_check_demo_mode_cache;
 +	fabric->tf_ops.tpg_check_demo_mode_write_protect =
 +				&lio_tpg_check_demo_mode_write_protect;
 +	fabric->tf_ops.tpg_check_prod_mode_write_protect =
 +				&lio_tpg_check_prod_mode_write_protect;
 +	fabric->tf_ops.tpg_alloc_fabric_acl = &lio_tpg_alloc_fabric_acl;
 +	fabric->tf_ops.tpg_release_fabric_acl = &lio_tpg_release_fabric_acl;
 +	fabric->tf_ops.tpg_get_inst_index = &lio_tpg_get_inst_index;
 +	fabric->tf_ops.check_stop_free = &lio_check_stop_free,
 +	fabric->tf_ops.release_cmd = &lio_release_cmd;
 +	fabric->tf_ops.shutdown_session = &lio_tpg_shutdown_session;
 +	fabric->tf_ops.close_session = &lio_tpg_close_session;
 +	fabric->tf_ops.sess_get_index = &lio_sess_get_index;
 +	fabric->tf_ops.sess_get_initiator_sid = &lio_sess_get_initiator_sid;
 +	fabric->tf_ops.write_pending = &lio_write_pending;
 +	fabric->tf_ops.write_pending_status = &lio_write_pending_status;
 +	fabric->tf_ops.set_default_node_attributes =
 +				&lio_set_default_node_attributes;
 +	fabric->tf_ops.get_task_tag = &iscsi_get_task_tag;
 +	fabric->tf_ops.get_cmd_state = &iscsi_get_cmd_state;
 +	fabric->tf_ops.queue_data_in = &lio_queue_data_in;
 +	fabric->tf_ops.queue_status = &lio_queue_status;
 +	fabric->tf_ops.queue_tm_rsp = &lio_queue_tm_rsp;
 +	fabric->tf_ops.aborted_task = &lio_aborted_task;
 +	/*
 +	 * Setup function pointers for generic logic in target_core_fabric_configfs.c
 +	 */
 +	fabric->tf_ops.fabric_make_wwn = &lio_target_call_coreaddtiqn;
 +	fabric->tf_ops.fabric_drop_wwn = &lio_target_call_coredeltiqn;
 +	fabric->tf_ops.fabric_make_tpg = &lio_target_tiqn_addtpg;
 +	fabric->tf_ops.fabric_drop_tpg = &lio_target_tiqn_deltpg;
 +	fabric->tf_ops.fabric_post_link	= NULL;
 +	fabric->tf_ops.fabric_pre_unlink = NULL;
 +	fabric->tf_ops.fabric_make_np = &lio_target_call_addnptotpg;
 +	fabric->tf_ops.fabric_drop_np = &lio_target_call_delnpfromtpg;
 +	fabric->tf_ops.fabric_make_nodeacl = &lio_target_make_nodeacl;
 +	fabric->tf_ops.fabric_drop_nodeacl = &lio_target_drop_nodeacl;
 +	/*
 +	 * Setup default attribute lists for various fabric->tf_cit_tmpl
 +	 * sturct config_item_type's
 +	 */
 +	fabric->tf_cit_tmpl.tfc_discovery_cit.ct_attrs = lio_target_discovery_auth_attrs;
 +	fabric->tf_cit_tmpl.tfc_wwn_cit.ct_attrs = lio_target_wwn_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_base_cit.ct_attrs = lio_target_tpg_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_attrib_cit.ct_attrs = lio_target_tpg_attrib_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_auth_cit.ct_attrs = lio_target_tpg_auth_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_param_cit.ct_attrs = lio_target_tpg_param_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_np_base_cit.ct_attrs = lio_target_portal_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_nacl_base_cit.ct_attrs = lio_target_initiator_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_nacl_attrib_cit.ct_attrs = lio_target_nacl_attrib_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_nacl_auth_cit.ct_attrs = lio_target_nacl_auth_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_nacl_param_cit.ct_attrs = lio_target_nacl_param_attrs;
 +
 +	ret = target_fabric_configfs_register(fabric);
 +	if (ret < 0) {
 +		pr_err("target_fabric_configfs_register() for"
 +				" LIO-Target failed!\n");
 +		target_fabric_configfs_free(fabric);
 +		return ret;
 +	}
 +
 +	lio_target_fabric_configfs = fabric;
 +	pr_debug("LIO_TARGET[0] - Set fabric ->"
 +			" lio_target_fabric_configfs\n");
 +	return 0;
 +}
 +
 +
 +void iscsi_target_deregister_configfs(void)
 +{
 +	if (!lio_target_fabric_configfs)
 +		return;
 +	/*
 +	 * Shutdown discovery sessions and disable discovery TPG
 +	 */
 +	if (iscsit_global->discovery_tpg)
 +		iscsit_tpg_disable_portal_group(iscsit_global->discovery_tpg, 1);
 +
 +	target_fabric_configfs_deregister(lio_target_fabric_configfs);
 +	lio_target_fabric_configfs = NULL;
 +	pr_debug("LIO_TARGET[0] - Cleared"
 +				" lio_target_fabric_configfs\n");
 +}
diff --cc drivers/target/loopback/tcm_loop.c
index cd26fc3abc10,5a71c9f2ee66..000000000000
--- a/drivers/target/loopback/tcm_loop.c
+++ b/drivers/target/loopback/tcm_loop.c
@@@ -1412,129 -1353,48 +1399,174 @@@ static struct configfs_attribute *tcm_l
  
  /* End items for tcm_loop_cit */
  
++<<<<<<< HEAD
 +static int tcm_loop_register_configfs(void)
 +{
 +	struct target_fabric_configfs *fabric;
 +	int ret;
 +	/*
 +	 * Set the TCM Loop HBA counter to zero
 +	 */
 +	tcm_loop_hba_no_cnt = 0;
 +	/*
 +	 * Register the top level struct config_item_type with TCM core
 +	 */
 +	fabric = target_fabric_configfs_init(THIS_MODULE, "loopback");
 +	if (IS_ERR(fabric)) {
 +		pr_err("tcm_loop_register_configfs() failed!\n");
 +		return PTR_ERR(fabric);
 +	}
 +	/*
 +	 * Setup the fabric API of function pointers used by target_core_mod
 +	 */
 +	fabric->tf_ops.get_fabric_name = &tcm_loop_get_fabric_name;
 +	fabric->tf_ops.get_fabric_proto_ident = &tcm_loop_get_fabric_proto_ident;
 +	fabric->tf_ops.tpg_get_wwn = &tcm_loop_get_endpoint_wwn;
 +	fabric->tf_ops.tpg_get_tag = &tcm_loop_get_tag;
 +	fabric->tf_ops.tpg_get_default_depth = &tcm_loop_get_default_depth;
 +	fabric->tf_ops.tpg_get_pr_transport_id = &tcm_loop_get_pr_transport_id;
 +	fabric->tf_ops.tpg_get_pr_transport_id_len =
 +					&tcm_loop_get_pr_transport_id_len;
 +	fabric->tf_ops.tpg_parse_pr_out_transport_id =
 +					&tcm_loop_parse_pr_out_transport_id;
 +	fabric->tf_ops.tpg_check_demo_mode = &tcm_loop_check_demo_mode;
 +	fabric->tf_ops.tpg_check_demo_mode_cache =
 +					&tcm_loop_check_demo_mode_cache;
 +	fabric->tf_ops.tpg_check_demo_mode_write_protect =
 +					&tcm_loop_check_demo_mode_write_protect;
 +	fabric->tf_ops.tpg_check_prod_mode_write_protect =
 +					&tcm_loop_check_prod_mode_write_protect;
 +	fabric->tf_ops.tpg_check_prot_fabric_only =
 +					&tcm_loop_check_prot_fabric_only;
 +	/*
 +	 * The TCM loopback fabric module runs in demo-mode to a local
 +	 * virtual SCSI device, so fabric dependent initator ACLs are
 +	 * not required.
 +	 */
 +	fabric->tf_ops.tpg_alloc_fabric_acl = &tcm_loop_tpg_alloc_fabric_acl;
 +	fabric->tf_ops.tpg_release_fabric_acl =
 +					&tcm_loop_tpg_release_fabric_acl;
 +	fabric->tf_ops.tpg_get_inst_index = &tcm_loop_get_inst_index;
 +	/*
 +	 * Used for setting up remaining TCM resources in process context
 +	 */
 +	fabric->tf_ops.check_stop_free = &tcm_loop_check_stop_free;
 +	fabric->tf_ops.release_cmd = &tcm_loop_release_cmd;
 +	fabric->tf_ops.shutdown_session = &tcm_loop_shutdown_session;
 +	fabric->tf_ops.close_session = &tcm_loop_close_session;
 +	fabric->tf_ops.sess_get_index = &tcm_loop_sess_get_index;
 +	fabric->tf_ops.sess_get_initiator_sid = NULL;
 +	fabric->tf_ops.write_pending = &tcm_loop_write_pending;
 +	fabric->tf_ops.write_pending_status = &tcm_loop_write_pending_status;
 +	/*
 +	 * Not used for TCM loopback
 +	 */
 +	fabric->tf_ops.set_default_node_attributes =
 +					&tcm_loop_set_default_node_attributes;
 +	fabric->tf_ops.get_task_tag = &tcm_loop_get_task_tag;
 +	fabric->tf_ops.get_cmd_state = &tcm_loop_get_cmd_state;
 +	fabric->tf_ops.queue_data_in = &tcm_loop_queue_data_in;
 +	fabric->tf_ops.queue_status = &tcm_loop_queue_status;
 +	fabric->tf_ops.queue_tm_rsp = &tcm_loop_queue_tm_rsp;
 +	fabric->tf_ops.aborted_task = &tcm_loop_aborted_task;
 +
 +	/*
 +	 * Setup function pointers for generic logic in target_core_fabric_configfs.c
 +	 */
 +	fabric->tf_ops.fabric_make_wwn = &tcm_loop_make_scsi_hba;
 +	fabric->tf_ops.fabric_drop_wwn = &tcm_loop_drop_scsi_hba;
 +	fabric->tf_ops.fabric_make_tpg = &tcm_loop_make_naa_tpg;
 +	fabric->tf_ops.fabric_drop_tpg = &tcm_loop_drop_naa_tpg;
 +	/*
 +	 * fabric_post_link() and fabric_pre_unlink() are used for
 +	 * registration and release of TCM Loop Virtual SCSI LUNs.
 +	 */
 +	fabric->tf_ops.fabric_post_link = &tcm_loop_port_link;
 +	fabric->tf_ops.fabric_pre_unlink = &tcm_loop_port_unlink;
 +	fabric->tf_ops.fabric_make_np = NULL;
 +	fabric->tf_ops.fabric_drop_np = NULL;
 +	/*
 +	 * Setup default attribute lists for various fabric->tf_cit_tmpl
 +	 */
 +	fabric->tf_cit_tmpl.tfc_wwn_cit.ct_attrs = tcm_loop_wwn_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_base_cit.ct_attrs = tcm_loop_tpg_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_attrib_cit.ct_attrs = tcm_loop_tpg_attrib_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_param_cit.ct_attrs = NULL;
 +	fabric->tf_cit_tmpl.tfc_tpg_np_base_cit.ct_attrs = NULL;
 +	/*
 +	 * Once fabric->tf_ops has been setup, now register the fabric for
 +	 * use within TCM
 +	 */
 +	ret = target_fabric_configfs_register(fabric);
 +	if (ret < 0) {
 +		pr_err("target_fabric_configfs_register() for"
 +				" TCM_Loop failed!\n");
 +		target_fabric_configfs_free(fabric);
 +		return -1;
 +	}
 +	/*
 +	 * Setup our local pointer to *fabric.
 +	 */
 +	tcm_loop_fabric_configfs = fabric;
 +	pr_debug("TCM_LOOP[0] - Set fabric ->"
 +			" tcm_loop_fabric_configfs\n");
 +	return 0;
 +}
 +
 +static void tcm_loop_deregister_configfs(void)
 +{
 +	if (!tcm_loop_fabric_configfs)
 +		return;
 +
 +	target_fabric_configfs_deregister(tcm_loop_fabric_configfs);
 +	tcm_loop_fabric_configfs = NULL;
 +	pr_debug("TCM_LOOP[0] - Cleared"
 +				" tcm_loop_fabric_configfs\n");
 +}
++=======
+ static const struct target_core_fabric_ops loop_ops = {
+ 	.module				= THIS_MODULE,
+ 	.name				= "loopback",
+ 	.get_fabric_name		= tcm_loop_get_fabric_name,
+ 	.get_fabric_proto_ident		= tcm_loop_get_fabric_proto_ident,
+ 	.tpg_get_wwn			= tcm_loop_get_endpoint_wwn,
+ 	.tpg_get_tag			= tcm_loop_get_tag,
+ 	.tpg_get_pr_transport_id	= tcm_loop_get_pr_transport_id,
+ 	.tpg_get_pr_transport_id_len	= tcm_loop_get_pr_transport_id_len,
+ 	.tpg_parse_pr_out_transport_id	= tcm_loop_parse_pr_out_transport_id,
+ 	.tpg_check_demo_mode		= tcm_loop_check_demo_mode,
+ 	.tpg_check_demo_mode_cache	= tcm_loop_check_demo_mode_cache,
+ 	.tpg_check_demo_mode_write_protect =
+ 				tcm_loop_check_demo_mode_write_protect,
+ 	.tpg_check_prod_mode_write_protect =
+ 				tcm_loop_check_prod_mode_write_protect,
+ 	.tpg_check_prot_fabric_only	= tcm_loop_check_prot_fabric_only,
+ 	.tpg_get_inst_index		= tcm_loop_get_inst_index,
+ 	.check_stop_free		= tcm_loop_check_stop_free,
+ 	.release_cmd			= tcm_loop_release_cmd,
+ 	.shutdown_session		= tcm_loop_shutdown_session,
+ 	.close_session			= tcm_loop_close_session,
+ 	.sess_get_index			= tcm_loop_sess_get_index,
+ 	.write_pending			= tcm_loop_write_pending,
+ 	.write_pending_status		= tcm_loop_write_pending_status,
+ 	.set_default_node_attributes	= tcm_loop_set_default_node_attributes,
+ 	.get_task_tag			= tcm_loop_get_task_tag,
+ 	.get_cmd_state			= tcm_loop_get_cmd_state,
+ 	.queue_data_in			= tcm_loop_queue_data_in,
+ 	.queue_status			= tcm_loop_queue_status,
+ 	.queue_tm_rsp			= tcm_loop_queue_tm_rsp,
+ 	.aborted_task			= tcm_loop_aborted_task,
+ 	.fabric_make_wwn		= tcm_loop_make_scsi_hba,
+ 	.fabric_drop_wwn		= tcm_loop_drop_scsi_hba,
+ 	.fabric_make_tpg		= tcm_loop_make_naa_tpg,
+ 	.fabric_drop_tpg		= tcm_loop_drop_naa_tpg,
+ 	.fabric_post_link		= tcm_loop_port_link,
+ 	.fabric_pre_unlink		= tcm_loop_port_unlink,
+ 	.tfc_wwn_attrs			= tcm_loop_wwn_attrs,
+ 	.tfc_tpg_base_attrs		= tcm_loop_tpg_attrs,
+ 	.tfc_tpg_attrib_attrs		= tcm_loop_tpg_attrib_attrs,
+ };
++>>>>>>> 144bc4c2a42a (target: move node ACL allocation to core code)
  
  static int __init tcm_loop_fabric_init(void)
  {
diff --cc drivers/target/sbp/sbp_target.c
index b33c121ab56c,5df2a61714fb..000000000000
--- a/drivers/target/sbp/sbp_target.c
+++ b/drivers/target/sbp/sbp_target.c
@@@ -1708,23 -1707,6 +1708,26 @@@ static u16 sbp_get_tag(struct se_portal
  	return tpg->tport_tpgt;
  }
  
++<<<<<<< HEAD
 +static u32 sbp_get_default_depth(struct se_portal_group *se_tpg)
 +{
 +	return 1;
 +}
 +
 +static struct se_node_acl *sbp_alloc_fabric_acl(struct se_portal_group *se_tpg)
 +{
 +	return kzalloc(sizeof(struct se_node_acl), GFP_KERNEL);
 +}
 +
 +static void sbp_release_fabric_acl(
 +	struct se_portal_group *se_tpg,
 +	struct se_node_acl *se_nacl)
 +{
 +	kfree(se_nacl);
 +}
 +
++=======
++>>>>>>> 144bc4c2a42a (target: move node ACL allocation to core code)
  static u32 sbp_tpg_get_inst_index(struct se_portal_group *se_tpg)
  {
  	return 1;
diff --cc drivers/target/target_core_tpg.c
index 0696de9553d3,42f3bd9561c8..000000000000
--- a/drivers/target/target_core_tpg.c
+++ b/drivers/target/target_core_tpg.c
@@@ -254,10 -254,66 +254,73 @@@ static int core_create_device_list_for_
  	return 0;
  }
  
++<<<<<<< HEAD
 +/*	core_tpg_check_initiator_node_acl()
 + *
 + *
 + */
++=======
+ static struct se_node_acl *target_alloc_node_acl(struct se_portal_group *tpg,
+ 		const unsigned char *initiatorname)
+ {
+ 	struct se_node_acl *acl;
+ 
+ 	acl = kzalloc(max(sizeof(*acl), tpg->se_tpg_tfo->node_acl_size),
+ 			GFP_KERNEL);
+ 	if (!acl)
+ 		return NULL;
+ 
+ 	INIT_LIST_HEAD(&acl->acl_list);
+ 	INIT_LIST_HEAD(&acl->acl_sess_list);
+ 	kref_init(&acl->acl_kref);
+ 	init_completion(&acl->acl_free_comp);
+ 	spin_lock_init(&acl->device_list_lock);
+ 	spin_lock_init(&acl->nacl_sess_lock);
+ 	atomic_set(&acl->acl_pr_ref_count, 0);
+ 	if (tpg->se_tpg_tfo->tpg_get_default_depth)
+ 		acl->queue_depth = tpg->se_tpg_tfo->tpg_get_default_depth(tpg);
+ 	else
+ 		acl->queue_depth = 1;
+ 	snprintf(acl->initiatorname, TRANSPORT_IQN_LEN, "%s", initiatorname);
+ 	acl->se_tpg = tpg;
+ 	acl->acl_index = scsi_get_new_index(SCSI_AUTH_INTR_INDEX);
+ 
+ 	tpg->se_tpg_tfo->set_default_node_attributes(acl);
+ 
+ 	if (core_create_device_list_for_node(acl) < 0)
+ 		goto out_free_acl;
+ 	if (core_set_queue_depth_for_node(tpg, acl) < 0)
+ 		goto out_free_device_list;
+ 
+ 	return acl;
+ 
+ out_free_device_list:
+ 	core_free_device_list_for_node(acl, tpg);
+ out_free_acl:
+ 	kfree(acl);
+ 	return NULL;
+ }
+ 
+ static void target_add_node_acl(struct se_node_acl *acl)
+ {
+ 	struct se_portal_group *tpg = acl->se_tpg;
+ 
+ 	spin_lock_irq(&tpg->acl_node_lock);
+ 	list_add_tail(&acl->acl_list, &tpg->acl_node_list);
+ 	tpg->num_node_acls++;
+ 	spin_unlock_irq(&tpg->acl_node_lock);
+ 
+ 	pr_debug("%s_TPG[%hu] - Added %s ACL with TCQ Depth: %d for %s"
+ 		" Initiator Node: %s\n",
+ 		tpg->se_tpg_tfo->get_fabric_name(),
+ 		tpg->se_tpg_tfo->tpg_get_tag(tpg),
+ 		acl->dynamic_node_acl ? "DYNAMIC" : "",
+ 		acl->queue_depth,
+ 		tpg->se_tpg_tfo->get_fabric_name(),
+ 		acl->initiatorname);
+ }
+ 
++>>>>>>> 144bc4c2a42a (target: move node ACL allocation to core code)
  struct se_node_acl *core_tpg_check_initiator_node_acl(
  	struct se_portal_group *tpg,
  	unsigned char *initiatorname)
@@@ -502,9 -462,8 +565,13 @@@ int core_tpg_del_initiator_node_acl
  		tpg->se_tpg_tfo->tpg_get_tag(tpg), acl->queue_depth,
  		tpg->se_tpg_tfo->get_fabric_name(), acl->initiatorname);
  
++<<<<<<< HEAD
 +	return 0;
++=======
+ 	kfree(acl);
++>>>>>>> 144bc4c2a42a (target: move node ACL allocation to core code)
  }
 +EXPORT_SYMBOL(core_tpg_del_initiator_node_acl);
  
  /*	core_tpg_set_initiator_node_queue_depth():
   *
diff --cc drivers/target/tcm_fc/tfc_conf.c
index efdcb9663a1a,8da159352315..000000000000
--- a/drivers/target/tcm_fc/tfc_conf.c
+++ b/drivers/target/tcm_fc/tfc_conf.c
@@@ -507,7 -448,10 +484,14 @@@ static u32 ft_tpg_get_inst_index(struc
  	return tpg->index;
  }
  
++<<<<<<< HEAD
 +static struct target_core_fabric_ops ft_fabric_ops = {
++=======
+ static const struct target_core_fabric_ops ft_fabric_ops = {
+ 	.module =			THIS_MODULE,
+ 	.name =				"fc",
+ 	.node_acl_size =		sizeof(struct ft_node_acl),
++>>>>>>> 144bc4c2a42a (target: move node ACL allocation to core code)
  	.get_fabric_name =		ft_get_fabric_name,
  	.get_fabric_proto_ident =	fc_get_fabric_proto_ident,
  	.tpg_get_wwn =			ft_get_fabric_wwn,
diff --cc drivers/usb/gadget/tcm_usb_gadget.c
index 7cacd6ae818e,82f4da8bfe41..000000000000
--- a/drivers/usb/gadget/tcm_usb_gadget.c
+++ b/drivers/usb/gadget/tcm_usb_gadget.c
@@@ -1378,28 -1373,6 +1378,31 @@@ static char *usbg_parse_pr_out_transpor
  	return tid;
  }
  
++<<<<<<< HEAD:drivers/usb/gadget/tcm_usb_gadget.c
 +static struct se_node_acl *usbg_alloc_fabric_acl(struct se_portal_group *se_tpg)
 +{
 +	struct usbg_nacl *nacl;
 +
 +	nacl = kzalloc(sizeof(struct usbg_nacl), GFP_KERNEL);
 +	if (!nacl) {
 +		printk(KERN_ERR "Unable to allocate struct usbg_nacl\n");
 +		return NULL;
 +	}
 +
 +	return &nacl->se_node_acl;
 +}
 +
 +static void usbg_release_fabric_acl(
 +	struct se_portal_group *se_tpg,
 +	struct se_node_acl *se_nacl)
 +{
 +	struct usbg_nacl *nacl = container_of(se_nacl,
 +			struct usbg_nacl, se_node_acl);
 +	kfree(nacl);
 +}
 +
++=======
++>>>>>>> 144bc4c2a42a (target: move node ACL allocation to core code):drivers/usb/gadget/legacy/tcm_usb_gadget.c
  static u32 usbg_tpg_get_inst_index(struct se_portal_group *se_tpg)
  {
  	return 1;
diff --cc drivers/vhost/scsi.c
index 65142d377371,b93c03935964..000000000000
--- a/drivers/vhost/scsi.c
+++ b/drivers/vhost/scsi.c
@@@ -416,29 -417,15 +416,33 @@@ static char *tcm_vhost_parse_pr_out_tra
  			port_nexus_ptr);
  }
  
 -static int vhost_scsi_check_prot_fabric_only(struct se_portal_group *se_tpg)
 +static struct se_node_acl *tcm_vhost_alloc_fabric_acl(
 +	struct se_portal_group *se_tpg)
  {
 -	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
 -				struct vhost_scsi_tpg, se_tpg);
 +	struct tcm_vhost_nacl *nacl;
 +
 +	nacl = kzalloc(sizeof(struct tcm_vhost_nacl), GFP_KERNEL);
 +	if (!nacl) {
 +		pr_err("Unable to allocate struct tcm_vhost_nacl\n");
 +		return NULL;
 +	}
 +
 +	return &nacl->se_node_acl;
 +}
  
 -	return tpg->tv_fabric_prot_type;
++<<<<<<< HEAD
 +static void tcm_vhost_release_fabric_acl(struct se_portal_group *se_tpg,
 +	struct se_node_acl *se_nacl)
 +{
 +	struct tcm_vhost_nacl *nacl = container_of(se_nacl,
 +			struct tcm_vhost_nacl, se_node_acl);
 +	kfree(nacl);
  }
  
 +static u32 tcm_vhost_tpg_get_inst_index(struct se_portal_group *se_tpg)
++=======
+ static u32 vhost_scsi_tpg_get_inst_index(struct se_portal_group *se_tpg)
++>>>>>>> 144bc4c2a42a (target: move node ACL allocation to core code)
  {
  	return 1;
  }
@@@ -1989,35 -2240,37 +1993,59 @@@ static struct configfs_attribute *tcm_v
  	NULL,
  };
  
++<<<<<<< HEAD
 +static struct target_core_fabric_ops tcm_vhost_ops = {
 +	.get_fabric_name		= tcm_vhost_get_fabric_name,
 +	.get_fabric_proto_ident		= tcm_vhost_get_fabric_proto_ident,
 +	.tpg_get_wwn			= tcm_vhost_get_fabric_wwn,
 +	.tpg_get_tag			= tcm_vhost_get_tag,
 +	.tpg_get_default_depth		= tcm_vhost_get_default_depth,
 +	.tpg_get_pr_transport_id	= tcm_vhost_get_pr_transport_id,
 +	.tpg_get_pr_transport_id_len	= tcm_vhost_get_pr_transport_id_len,
 +	.tpg_parse_pr_out_transport_id	= tcm_vhost_parse_pr_out_transport_id,
 +	.tpg_check_demo_mode		= tcm_vhost_check_true,
 +	.tpg_check_demo_mode_cache	= tcm_vhost_check_true,
 +	.tpg_check_demo_mode_write_protect = tcm_vhost_check_false,
 +	.tpg_check_prod_mode_write_protect = tcm_vhost_check_false,
 +	.tpg_alloc_fabric_acl		= tcm_vhost_alloc_fabric_acl,
 +	.tpg_release_fabric_acl		= tcm_vhost_release_fabric_acl,
 +	.tpg_get_inst_index		= tcm_vhost_tpg_get_inst_index,
 +	.release_cmd			= tcm_vhost_release_cmd,
 +	.shutdown_session		= tcm_vhost_shutdown_session,
 +	.close_session			= tcm_vhost_close_session,
 +	.sess_get_index			= tcm_vhost_sess_get_index,
++=======
+ static struct target_core_fabric_ops vhost_scsi_ops = {
+ 	.module				= THIS_MODULE,
+ 	.name				= "vhost",
+ 	.get_fabric_name		= vhost_scsi_get_fabric_name,
+ 	.get_fabric_proto_ident		= vhost_scsi_get_fabric_proto_ident,
+ 	.tpg_get_wwn			= vhost_scsi_get_fabric_wwn,
+ 	.tpg_get_tag			= vhost_scsi_get_tpgt,
+ 	.tpg_get_pr_transport_id	= vhost_scsi_get_pr_transport_id,
+ 	.tpg_get_pr_transport_id_len	= vhost_scsi_get_pr_transport_id_len,
+ 	.tpg_parse_pr_out_transport_id	= vhost_scsi_parse_pr_out_transport_id,
+ 	.tpg_check_demo_mode		= vhost_scsi_check_true,
+ 	.tpg_check_demo_mode_cache	= vhost_scsi_check_true,
+ 	.tpg_check_demo_mode_write_protect = vhost_scsi_check_false,
+ 	.tpg_check_prod_mode_write_protect = vhost_scsi_check_false,
+ 	.tpg_check_prot_fabric_only	= vhost_scsi_check_prot_fabric_only,
+ 	.tpg_get_inst_index		= vhost_scsi_tpg_get_inst_index,
+ 	.release_cmd			= vhost_scsi_release_cmd,
+ 	.check_stop_free		= vhost_scsi_check_stop_free,
+ 	.shutdown_session		= vhost_scsi_shutdown_session,
+ 	.close_session			= vhost_scsi_close_session,
+ 	.sess_get_index			= vhost_scsi_sess_get_index,
++>>>>>>> 144bc4c2a42a (target: move node ACL allocation to core code)
  	.sess_get_initiator_sid		= NULL,
 -	.write_pending			= vhost_scsi_write_pending,
 -	.write_pending_status		= vhost_scsi_write_pending_status,
 -	.set_default_node_attributes	= vhost_scsi_set_default_node_attrs,
 -	.get_task_tag			= vhost_scsi_get_task_tag,
 -	.get_cmd_state			= vhost_scsi_get_cmd_state,
 -	.queue_data_in			= vhost_scsi_queue_data_in,
 -	.queue_status			= vhost_scsi_queue_status,
 -	.queue_tm_rsp			= vhost_scsi_queue_tm_rsp,
 -	.aborted_task			= vhost_scsi_aborted_task,
 +	.write_pending			= tcm_vhost_write_pending,
 +	.write_pending_status		= tcm_vhost_write_pending_status,
 +	.set_default_node_attributes	= tcm_vhost_set_default_node_attrs,
 +	.get_task_tag			= tcm_vhost_get_task_tag,
 +	.get_cmd_state			= tcm_vhost_get_cmd_state,
 +	.queue_data_in			= tcm_vhost_queue_data_in,
 +	.queue_status			= tcm_vhost_queue_status,
 +	.queue_tm_rsp			= tcm_vhost_queue_tm_rsp,
  	/*
  	 * Setup callers for generic logic in target_core_fabric_configfs.c
  	 */
diff --cc include/target/target_core_fabric.h
index c9a57a197803,e5414744bf2d..000000000000
--- a/include/target/target_core_fabric.h
+++ b/include/target/target_core_fabric.h
@@@ -2,7 -2,9 +2,13 @@@
  #define TARGET_CORE_FABRIC_H
  
  struct target_core_fabric_ops {
++<<<<<<< HEAD
 +	struct configfs_subsystem *tf_subsys;
++=======
+ 	struct module *module;
+ 	const char *name;
+ 	size_t node_acl_size;
++>>>>>>> 144bc4c2a42a (target: move node ACL allocation to core code)
  	char *(*get_fabric_name)(void);
  	u8 (*get_fabric_proto_ident)(struct se_portal_group *);
  	char *(*tpg_get_wwn)(struct se_portal_group *);
* Unmerged path drivers/xen/xen-scsiback.c
diff --git a/Documentation/target/tcm_mod_builder.py b/Documentation/target/tcm_mod_builder.py
index 3fe0d812dcec..cf56885e2f3c 100755
--- a/Documentation/target/tcm_mod_builder.py
+++ b/Documentation/target/tcm_mod_builder.py
@@ -383,8 +383,6 @@ def tcm_mod_build_configfs(proto_ident, fabric_mod_dir_var, fabric_mod_name):
 	buf += "	.tpg_check_demo_mode_cache	= " + fabric_mod_name + "_check_true,\n"
 	buf += "	.tpg_check_demo_mode_write_protect = " + fabric_mod_name + "_check_true,\n"
 	buf += "	.tpg_check_prod_mode_write_protect = " + fabric_mod_name + "_check_false,\n"
-	buf += "	.tpg_alloc_fabric_acl		= " + fabric_mod_name + "_alloc_fabric_acl,\n"
-	buf += "	.tpg_release_fabric_acl		= " + fabric_mod_name + "_release_fabric_acl,\n"
 	buf += "	.tpg_get_inst_index		= " + fabric_mod_name + "_tpg_get_inst_index,\n"
 	buf += "	.release_cmd			= " + fabric_mod_name + "_release_cmd,\n"
 	buf += "	.shutdown_session		= " + fabric_mod_name + "_shutdown_session,\n"
@@ -767,31 +765,6 @@ def tcm_mod_dump_fabric_ops(proto_ident, fabric_mod_dir_var, fabric_mod_name):
 			bufi += "char *" + fabric_mod_name + "_parse_pr_out_transport_id(struct se_portal_group *,\n"
 			bufi +=	"			const char *, u32 *, char **);\n"
 
-		if re.search('alloc_fabric_acl\)\(', fo):
-			buf += "struct se_node_acl *" + fabric_mod_name + "_alloc_fabric_acl(struct se_portal_group *se_tpg)\n"
-			buf += "{\n"
-			buf += "	struct " + fabric_mod_name + "_nacl *nacl;\n\n"
-			buf += "	nacl = kzalloc(sizeof(struct " + fabric_mod_name + "_nacl), GFP_KERNEL);\n"
-			buf += "	if (!nacl) {\n"
-			buf += "		printk(KERN_ERR \"Unable to allocate struct " + fabric_mod_name + "_nacl\\n\");\n"
-			buf += "		return NULL;\n"
-			buf += "	}\n\n"
-			buf += "	return &nacl->se_node_acl;\n"
-			buf += "}\n\n"
-			bufi += "struct se_node_acl *" + fabric_mod_name + "_alloc_fabric_acl(struct se_portal_group *);\n"
-
-		if re.search('release_fabric_acl\)\(', fo):
-			buf += "void " + fabric_mod_name + "_release_fabric_acl(\n"
-			buf += "	struct se_portal_group *se_tpg,\n"
-			buf += "	struct se_node_acl *se_nacl)\n"
-			buf += "{\n"
-			buf += "	struct " + fabric_mod_name + "_nacl *nacl = container_of(se_nacl,\n"
-			buf += "			struct " + fabric_mod_name + "_nacl, se_node_acl);\n"
-			buf += "	kfree(nacl);\n"
-			buf += "}\n\n"
-			bufi += "void " + fabric_mod_name + "_release_fabric_acl(struct se_portal_group *,\n"
-			bufi +=	"			struct se_node_acl *);\n"
-
 		if re.search('tpg_get_inst_index\)\(', fo):
 			buf += "u32 " + fabric_mod_name + "_tpg_get_inst_index(struct se_portal_group *se_tpg)\n"
 			buf += "{\n"
* Unmerged path drivers/infiniband/ulp/srpt/ib_srpt.c
diff --git a/drivers/infiniband/ulp/srpt/ib_srpt.h b/drivers/infiniband/ulp/srpt/ib_srpt.h
index 9077ca1e51ce..85361e84cdd6 100644
--- a/drivers/infiniband/ulp/srpt/ib_srpt.h
+++ b/drivers/infiniband/ulp/srpt/ib_srpt.h
@@ -367,15 +367,15 @@ struct srpt_device {
 
 /**
  * struct srpt_node_acl - Per-initiator ACL data (managed via configfs).
+ * @nacl:      Target core node ACL information.
  * @i_port_id: 128-bit SRP initiator port ID.
  * @sport:     port information.
- * @nacl:      Target core node ACL information.
  * @list:      Element of the per-HCA ACL list.
  */
 struct srpt_node_acl {
+	struct se_node_acl	nacl;
 	u8			i_port_id[16];
 	struct srpt_port	*sport;
-	struct se_node_acl	nacl;
 	struct list_head	list;
 };
 
* Unmerged path drivers/scsi/qla2xxx/tcm_qla2xxx.c
diff --git a/drivers/scsi/qla2xxx/tcm_qla2xxx.h b/drivers/scsi/qla2xxx/tcm_qla2xxx.h
index fe758517da6d..ace6d4a20449 100644
--- a/drivers/scsi/qla2xxx/tcm_qla2xxx.h
+++ b/drivers/scsi/qla2xxx/tcm_qla2xxx.h
@@ -7,6 +7,8 @@
 #include "qla_target.h"
 
 struct tcm_qla2xxx_nacl {
+	struct se_node_acl se_node_acl;
+
 	/* From libfc struct fc_rport->port_id */
 	u32 nport_id;
 	/* Binary World Wide unique Node Name for remote FC Initiator Nport */
@@ -17,8 +19,6 @@ struct tcm_qla2xxx_nacl {
 	struct qla_tgt_sess *qla_tgt_sess;
 	/* Pointer to TCM FC nexus */
 	struct se_session *nport_nexus;
-	/* Returned by tcm_qla2xxx_make_nodeacl() */
-	struct se_node_acl se_node_acl;
 };
 
 struct tcm_qla2xxx_tpg_attrib {
* Unmerged path drivers/target/iscsi/iscsi_target_configfs.c
* Unmerged path drivers/target/loopback/tcm_loop.c
* Unmerged path drivers/target/sbp/sbp_target.c
diff --git a/drivers/target/target_core_configfs.c b/drivers/target/target_core_configfs.c
index 372df6e87bcb..5ee15c1cb75d 100644
--- a/drivers/target/target_core_configfs.c
+++ b/drivers/target/target_core_configfs.c
@@ -419,14 +419,6 @@ static int target_fabric_tf_ops_check(
 		pr_err("Missing tfo->tpg_check_prod_mode_write_protect()\n");
 		return -EINVAL;
 	}
-	if (!tfo->tpg_alloc_fabric_acl) {
-		pr_err("Missing tfo->tpg_alloc_fabric_acl()\n");
-		return -EINVAL;
-	}
-	if (!tfo->tpg_release_fabric_acl) {
-		pr_err("Missing tfo->tpg_release_fabric_acl()\n");
-		return -EINVAL;
-	}
 	if (!tfo->tpg_get_inst_index) {
 		pr_err("Missing tfo->tpg_get_inst_index()\n");
 		return -EINVAL;
* Unmerged path drivers/target/target_core_tpg.c
diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c
index 9cc3afa0ef11..34c41fddca37 100644
--- a/drivers/target/target_core_transport.c
+++ b/drivers/target/target_core_transport.c
@@ -527,7 +527,7 @@ void transport_deregister_session(struct se_session *se_sess)
 			spin_unlock_irqrestore(&se_tpg->acl_node_lock, flags);
 			core_tpg_wait_for_nacl_pr_ref(se_nacl);
 			core_free_device_list_for_node(se_nacl, se_tpg);
-			se_tfo->tpg_release_fabric_acl(se_tpg, se_nacl);
+			kfree(se_nacl);
 
 			comp_nacl = false;
 			spin_lock_irqsave(&se_tpg->acl_node_lock, flags);
diff --git a/drivers/target/tcm_fc/tcm_fc.h b/drivers/target/tcm_fc/tcm_fc.h
index a0bcfd3e7e7d..7ea45cc76984 100644
--- a/drivers/target/tcm_fc/tcm_fc.h
+++ b/drivers/target/tcm_fc/tcm_fc.h
@@ -80,8 +80,8 @@ struct ft_node_auth {
  * Node ACL for FC remote port session.
  */
 struct ft_node_acl {
-	struct ft_node_auth node_auth;
 	struct se_node_acl se_node_acl;
+	struct ft_node_auth node_auth;
 };
 
 struct ft_lun {
* Unmerged path drivers/target/tcm_fc/tfc_conf.c
* Unmerged path drivers/usb/gadget/tcm_usb_gadget.c
* Unmerged path drivers/vhost/scsi.c
* Unmerged path drivers/xen/xen-scsiback.c
diff --git a/include/target/iscsi/iscsi_target_core.h b/include/target/iscsi/iscsi_target_core.h
index 85a93f1e5dc5..2df3a444019e 100644
--- a/include/target/iscsi/iscsi_target_core.h
+++ b/include/target/iscsi/iscsi_target_core.h
@@ -756,10 +756,10 @@ struct iscsi_node_stat_grps {
 };
 
 struct iscsi_node_acl {
+	struct se_node_acl	se_node_acl;
 	struct iscsi_node_attrib node_attrib;
 	struct iscsi_node_auth	node_auth;
 	struct iscsi_node_stat_grps node_stat_grps;
-	struct se_node_acl	se_node_acl;
 };
 
 struct iscsi_tpg_attrib {
* Unmerged path include/target/target_core_fabric.h
