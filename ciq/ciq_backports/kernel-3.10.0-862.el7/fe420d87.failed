net/core: remove explicit do_softirq() from busy_poll_stop()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] remove explicit do_softirq() from busy_poll_stop() (Ivan Vecera) [1489406]
Rebuild_FUZZ: 90.91%
commit-author Sebastian Siewior <bigeasy@linutronix.de>
commit fe420d87bbc234015b4195dd239b7d3052b140ea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/fe420d87.failed

Since commit 217f69743681 ("net: busy-poll: allow preemption in
sk_busy_loop()") there is an explicit do_softirq() invocation after
local_bh_enable() has been invoked.
I don't understand why we need this because local_bh_enable() will
invoke do_softirq() once the softirq counter reached zero and we have
softirq-related work pending.

	Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fe420d87bbc234015b4195dd239b7d3052b140ea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/dev.c
diff --cc net/core/dev.c
index a40c9678b9f6,7243421c9783..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -4792,13 -5177,48 +4792,49 @@@ static struct napi_struct *napi_by_id(u
  }
  
  #if defined(CONFIG_NET_RX_BUSY_POLL)
 -
  #define BUSY_POLL_BUDGET 8
 -
 -static void busy_poll_stop(struct napi_struct *napi, void *have_poll_lock)
 +bool sk_busy_loop(struct sock *sk, int nonblock)
  {
++<<<<<<< HEAD
 +	unsigned long end_time = !nonblock ? sk_busy_loop_end_time(sk) : 0;
 +	int (*busy_poll)(struct napi_struct *dev);
++=======
+ 	int rc;
+ 
+ 	/* Busy polling means there is a high chance device driver hard irq
+ 	 * could not grab NAPI_STATE_SCHED, and that NAPI_STATE_MISSED was
+ 	 * set in napi_schedule_prep().
+ 	 * Since we are about to call napi->poll() once more, we can safely
+ 	 * clear NAPI_STATE_MISSED.
+ 	 *
+ 	 * Note: x86 could use a single "lock and ..." instruction
+ 	 * to perform these two clear_bit()
+ 	 */
+ 	clear_bit(NAPI_STATE_MISSED, &napi->state);
+ 	clear_bit(NAPI_STATE_IN_BUSY_POLL, &napi->state);
+ 
+ 	local_bh_disable();
+ 
+ 	/* All we really want here is to re-enable device interrupts.
+ 	 * Ideally, a new ndo_busy_poll_stop() could avoid another round.
+ 	 */
+ 	rc = napi->poll(napi, BUSY_POLL_BUDGET);
+ 	netpoll_poll_unlock(have_poll_lock);
+ 	if (rc == BUSY_POLL_BUDGET)
+ 		__napi_schedule(napi);
+ 	local_bh_enable();
+ }
+ 
+ void napi_busy_loop(unsigned int napi_id,
+ 		    bool (*loop_end)(void *, unsigned long),
+ 		    void *loop_end_arg)
+ {
+ 	unsigned long start_time = loop_end ? busy_loop_current_time() : 0;
+ 	int (*napi_poll)(struct napi_struct *napi, int budget);
+ 	void *have_poll_lock = NULL;
++>>>>>>> fe420d87bbc2 (net/core: remove explicit do_softirq() from busy_poll_stop())
  	struct napi_struct *napi;
 -
 -restart:
 -	napi_poll = NULL;
 +	int rc = false;
  
  	rcu_read_lock();
  
* Unmerged path net/core/dev.c
