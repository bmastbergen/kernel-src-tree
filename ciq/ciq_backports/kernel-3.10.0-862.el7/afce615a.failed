ipv6: Don't increase IPSTATS_MIB_FRAGFAILS twice in ip6_fragment()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Stefano Brivio <sbrivio@redhat.com>
commit afce615aaabfbaad02550e75c0bec106dafa1adf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/afce615a.failed

RFC 2465 defines ipv6IfStatsOutFragFails as:

	"The number of IPv6 datagrams that have been discarded
	 because they needed to be fragmented at this output
	 interface but could not be."

The existing implementation, instead, would increase the counter
twice in case we fail to allocate room for single fragments:
once for the fragment, once for the datagram.

This didn't look intentional though. In one of the two affected
affected failure paths, the double increase was simply a result
of a new 'goto fail' statement, introduced to avoid a skb leak.
The other path appears to be affected since at least 2.6.12-rc2.

	Reported-by: Sabrina Dubroca <sdubroca@redhat.com>
Fixes: 1d325d217c7f ("ipv6: ip6_fragment: fix headroom tests and skb leak")
	Signed-off-by: Stefano Brivio <sbrivio@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit afce615aaabfbaad02550e75c0bec106dafa1adf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_output.c
diff --cc net/ipv6/ip6_output.c
index e14ce8c9f4a2,162efba0d0cd..000000000000
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@@ -611,13 -673,14 +611,18 @@@ int ip6_fragment(struct sock *sk, struc
  		*prevhdr = NEXTHDR_FRAGMENT;
  		tmp_hdr = kmemdup(skb_network_header(skb), hlen, GFP_ATOMIC);
  		if (!tmp_hdr) {
++<<<<<<< HEAD
 +			IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),
 +				      IPSTATS_MIB_FRAGFAILS);
 +			return -ENOMEM;
++=======
+ 			err = -ENOMEM;
+ 			goto fail;
++>>>>>>> afce615aaabf (ipv6: Don't increase IPSTATS_MIB_FRAGFAILS twice in ip6_fragment())
  		}
 -		frag = skb_shinfo(skb)->frag_list;
 -		skb_frag_list_init(skb);
  
  		__skb_pull(skb, hlen);
 -		fh = __skb_push(skb, sizeof(struct frag_hdr));
 +		fh = (struct frag_hdr*)__skb_push(skb, sizeof(struct frag_hdr));
  		__skb_push(skb, hlen);
  		skb_reset_network_header(skb);
  		memcpy(skb_network_header(skb), tmp_hdr, hlen);
@@@ -728,15 -782,11 +733,22 @@@ slow_path
  		if (len < left)	{
  			len &= ~7;
  		}
 +		/*
 +		 *	Allocate buffer.
 +		 */
  
++<<<<<<< HEAD
 +		if ((frag = alloc_skb(len + hlen + sizeof(struct frag_hdr) +
 +				      hroom + troom, GFP_ATOMIC)) == NULL) {
 +			NETDEBUG(KERN_INFO "IPv6: frag: no memory for new fragment!\n");
 +			IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),
 +				      IPSTATS_MIB_FRAGFAILS);
++=======
+ 		/* Allocate buffer */
+ 		frag = alloc_skb(len + hlen + sizeof(struct frag_hdr) +
+ 				 hroom + troom, GFP_ATOMIC);
+ 		if (!frag) {
++>>>>>>> afce615aaabf (ipv6: Don't increase IPSTATS_MIB_FRAGFAILS twice in ip6_fragment())
  			err = -ENOMEM;
  			goto fail;
  		}
* Unmerged path net/ipv6/ip6_output.c
