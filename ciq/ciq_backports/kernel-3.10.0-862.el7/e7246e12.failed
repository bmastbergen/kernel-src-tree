net-tc: extract skip classify bit from tc_verd

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] tc: extract skip classify bit from tc_verd (Ivan Vecera) [1445420]
Rebuild_FUZZ: 95.45%
commit-author Willem de Bruijn <willemb@google.com>
commit e7246e122aaa99ebbb8ad7da80f35a20577bd8af
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e7246e12.failed

Packets sent by the IFB device skip subsequent tc classification.
A single bit governs this state. Move it out of tc_verd in
anticipation of removing that __u16 completely.

The new bitfield tc_skip_classify temporarily uses one bit of a
hole, until tc_verd is removed completely in a follow-up patch.

Remove the bit hole comment. It could be 2, 3, 4 or 5 bits long.
With that many options, little value in documenting it.

Introduce a helper function to deduplicate the logic in the two
sites that check this bit.

The field tc_skip_classify is set only in IFB on skbs cloned in
act_mirred, so original packet sources do not have to clear the
bit when reusing packets (notably, pktgen and octeon).

	Signed-off-by: Willem de Bruijn <willemb@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e7246e122aaa99ebbb8ad7da80f35a20577bd8af)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
#	include/uapi/linux/pkt_cls.h
#	net/sched/act_api.c
diff --cc include/linux/skbuff.h
index 7b6fa7405c56,570f60ec6cb4..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -694,6 -678,89 +695,92 @@@ struct sk_buff 
  				data_len;
  	__u16			mac_len,
  				hdr_len;
++<<<<<<< HEAD
++=======
+ 
+ 	/* Following fields are _not_ copied in __copy_skb_header()
+ 	 * Note that queue_mapping is here mostly to fill a hole.
+ 	 */
+ 	kmemcheck_bitfield_begin(flags1);
+ 	__u16			queue_mapping;
+ 
+ /* if you move cloned around you also must adapt those constants */
+ #ifdef __BIG_ENDIAN_BITFIELD
+ #define CLONED_MASK	(1 << 7)
+ #else
+ #define CLONED_MASK	1
+ #endif
+ #define CLONED_OFFSET()		offsetof(struct sk_buff, __cloned_offset)
+ 
+ 	__u8			__cloned_offset[0];
+ 	__u8			cloned:1,
+ 				nohdr:1,
+ 				fclone:2,
+ 				peeked:1,
+ 				head_frag:1,
+ 				xmit_more:1,
+ 				__unused:1; /* one bit hole */
+ 	kmemcheck_bitfield_end(flags1);
+ 
+ 	/* fields enclosed in headers_start/headers_end are copied
+ 	 * using a single memcpy() in __copy_skb_header()
+ 	 */
+ 	/* private: */
+ 	__u32			headers_start[0];
+ 	/* public: */
+ 
+ /* if you move pkt_type around you also must adapt those constants */
+ #ifdef __BIG_ENDIAN_BITFIELD
+ #define PKT_TYPE_MAX	(7 << 5)
+ #else
+ #define PKT_TYPE_MAX	7
+ #endif
+ #define PKT_TYPE_OFFSET()	offsetof(struct sk_buff, __pkt_type_offset)
+ 
+ 	__u8			__pkt_type_offset[0];
+ 	__u8			pkt_type:3;
+ 	__u8			pfmemalloc:1;
+ 	__u8			ignore_df:1;
+ 	__u8			nfctinfo:3;
+ 
+ 	__u8			nf_trace:1;
+ 	__u8			ip_summed:2;
+ 	__u8			ooo_okay:1;
+ 	__u8			l4_hash:1;
+ 	__u8			sw_hash:1;
+ 	__u8			wifi_acked_valid:1;
+ 	__u8			wifi_acked:1;
+ 
+ 	__u8			no_fcs:1;
+ 	/* Indicates the inner headers are valid in the skbuff. */
+ 	__u8			encapsulation:1;
+ 	__u8			encap_hdr_csum:1;
+ 	__u8			csum_valid:1;
+ 	__u8			csum_complete_sw:1;
+ 	__u8			csum_level:2;
+ 	__u8			csum_bad:1;
+ 
+ #ifdef CONFIG_IPV6_NDISC_NODETYPE
+ 	__u8			ndisc_nodetype:2;
+ #endif
+ 	__u8			ipvs_property:1;
+ 	__u8			inner_protocol_type:1;
+ 	__u8			remcsum_offload:1;
+ #ifdef CONFIG_NET_SWITCHDEV
+ 	__u8			offload_fwd_mark:1;
+ #endif
+ #ifdef CONFIG_NET_CLS_ACT
+ 	__u8			tc_skip_classify:1;
+ #endif
+ 
+ #ifdef CONFIG_NET_SCHED
+ 	__u16			tc_index;	/* traffic control index */
+ #ifdef CONFIG_NET_CLS_ACT
+ 	__u16			tc_verd;	/* traffic control verdict */
+ #endif
+ #endif
+ 
++>>>>>>> e7246e122aaa (net-tc: extract skip classify bit from tc_verd)
  	union {
  		__wsum		csum;
  		struct {
diff --cc include/uapi/linux/pkt_cls.h
index 0d022fe21c56,1eed5d7509bc..000000000000
--- a/include/uapi/linux/pkt_cls.h
+++ b/include/uapi/linux/pkt_cls.h
@@@ -28,10 -22,6 +28,13 @@@ bit 6,7: Where this packet was last see
  1: on the Ingress
  2: on the Egress
  
++<<<<<<< HEAD
 +bit 8: when set --> Request not to classify on ingress. 
 +
 +bits 9,10,11: redirect counter -  redirect TTL. Loop avoidance
 +
++=======
++>>>>>>> e7246e122aaa (net-tc: extract skip classify bit from tc_verd)
   *
   * */
  
@@@ -61,18 -34,6 +64,21 @@@
  #define AT_INGRESS	0x1
  #define AT_EGRESS	0x2
  
++<<<<<<< HEAD
 +#define TC_NCLS          _TC_MAKEMASK1(8)
 +#define SET_TC_NCLS(v)   ( TC_NCLS | (v & ~TC_NCLS))
 +#define CLR_TC_NCLS(v)   ( v & ~TC_NCLS)
 +
 +#ifndef __KERNEL__
 +#define S_TC_RTTL          _TC_MAKE32(9)
 +#define M_TC_RTTL          _TC_MAKEMASK(3,S_TC_RTTL)
 +#define G_TC_RTTL(x)       _TC_GETVALUE(x,S_TC_RTTL,M_TC_RTTL)
 +#define V_TC_RTTL(x)       _TC_MAKEVALUE(x,S_TC_RTTL)
 +#define SET_TC_RTTL(v,n)   ((V_TC_RTTL(n)) | (v & ~M_TC_RTTL))
 +#endif
 +
++=======
++>>>>>>> e7246e122aaa (net-tc: extract skip classify bit from tc_verd)
  #define S_TC_AT          _TC_MAKE32(12)
  #define M_TC_AT          _TC_MAKEMASK(2,S_TC_AT)
  #define G_TC_AT(x)       _TC_GETVALUE(x,S_TC_AT,M_TC_AT)
diff --cc net/sched/act_api.c
index 2bcb695c3da5,f04715a57300..000000000000
--- a/net/sched/act_api.c
+++ b/net/sched/act_api.c
@@@ -436,18 -421,17 +436,27 @@@ static struct tc_action_ops *tc_lookup_
  	return res;
  }
  
 -int tcf_action_exec(struct sk_buff *skb, struct tc_action **actions,
 -		    int nr_actions, struct tcf_result *res)
 +int tcf_action_exec(struct sk_buff *skb, const struct list_head *actions,
 +		    struct tcf_result *res)
  {
 -	int ret = -1, i;
 -
 +	const struct tc_action *a;
 +	int ret = -1;
 +
++<<<<<<< HEAD
 +	if (skb->tc_verd & TC_NCLS) {
 +		skb->tc_verd = CLR_TC_NCLS(skb->tc_verd);
 +		ret = TC_ACT_OK;
 +		goto exec_done;
 +	}
 +	list_for_each_entry(a, actions, list) {
++=======
+ 	if (skb_skip_tc_classify(skb))
+ 		return TC_ACT_OK;
+ 
+ 	for (i = 0; i < nr_actions; i++) {
+ 		const struct tc_action *a = actions[i];
+ 
++>>>>>>> e7246e122aaa (net-tc: extract skip classify bit from tc_verd)
  repeat:
  		ret = a->ops->act(skb, a, res);
  		if (ret == TC_ACT_REPEAT)
diff --git a/drivers/net/ifb.c b/drivers/net/ifb.c
index c69ebf414c33..02ece9c4fc0d 100644
--- a/drivers/net/ifb.c
+++ b/drivers/net/ifb.c
@@ -82,7 +82,7 @@ static void ri_tasklet(unsigned long dev)
 		u32 from = G_TC_FROM(skb->tc_verd);
 
 		skb->tc_verd = 0;
-		skb->tc_verd = SET_TC_NCLS(skb->tc_verd);
+		skb->tc_skip_classify = 1;
 
 		u64_stats_update_begin(&dp->tsync);
 		dp->tx_packets++;
* Unmerged path include/linux/skbuff.h
diff --git a/include/net/sch_generic.h b/include/net/sch_generic.h
index e957def28d63..db35e04de4b1 100644
--- a/include/net/sch_generic.h
+++ b/include/net/sch_generic.h
@@ -411,6 +411,17 @@ void __qdisc_calculate_pkt_len(struct sk_buff *skb,
 bool tcf_destroy(struct tcf_proto *tp, bool force);
 void tcf_destroy_chain(struct tcf_proto __rcu **fl);
 
+static inline bool skb_skip_tc_classify(struct sk_buff *skb)
+{
+#ifdef CONFIG_NET_CLS_ACT
+	if (skb->tc_skip_classify) {
+		skb->tc_skip_classify = 0;
+		return true;
+	}
+#endif
+	return false;
+}
+
 /* Reset all TX qdiscs greater then index of a device.  */
 static inline void qdisc_reset_all_tx_gt(struct net_device *dev, unsigned int i)
 {
* Unmerged path include/uapi/linux/pkt_cls.h
diff --git a/net/core/dev.c b/net/core/dev.c
index 54ad82302512..30870cd0e593 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -3955,12 +3955,8 @@ another_round:
 			goto out;
 	}
 
-#ifdef CONFIG_NET_CLS_ACT
-	if (skb->tc_verd & TC_NCLS) {
-		skb->tc_verd = CLR_TC_NCLS(skb->tc_verd);
-		goto ncls;
-	}
-#endif
+	if (skb_skip_tc_classify(skb))
+		goto skip_classify;
 
 	if (pfmemalloc)
 		goto skip_taps;
@@ -3983,8 +3979,8 @@ skip_taps:
 #endif
 #ifdef CONFIG_NET_CLS_ACT
 	skb->tc_verd = 0;
-ncls:
 #endif
+skip_classify:
 	if (pfmemalloc && !skb_pfmemalloc_protocol(skb))
 		goto drop;
 
* Unmerged path net/sched/act_api.c
