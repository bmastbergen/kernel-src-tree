GFS2: Add calls to gfs2_holder_uninit in two error handlers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Daniel DeFreez <dcdefreez@ucdavis.edu>
commit 9c7fe83530a351845719acf1dda0587e8c743588
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9c7fe835.failed

This patch fixes two locations that do not call gfs2_holder_uninit
if gfs2_glock_nq returns an error.

	Signed-off-by: Daniel DeFreez <dcdefreez@ucdavis.edu>
	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit 9c7fe83530a351845719acf1dda0587e8c743588)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/aops.c
diff --cc fs/gfs2/aops.c
index 7cfe371218e7,58dd0061134b..000000000000
--- a/fs/gfs2/aops.c
+++ b/fs/gfs2/aops.c
@@@ -1114,8 -1063,8 +1114,13 @@@ static ssize_t gfs2_direct_IO(int rw, s
  	gfs2_holder_init(ip->i_gl, LM_ST_DEFERRED, 0, &gh);
  	rv = gfs2_glock_nq(&gh);
  	if (rv)
++<<<<<<< HEAD
 +		return rv;
 +	rv = gfs2_ok_for_dio(ip, rw, offset);
++=======
+ 		goto out_uninit;
+ 	rv = gfs2_ok_for_dio(ip, offset);
++>>>>>>> 9c7fe83530a3 (GFS2: Add calls to gfs2_holder_uninit in two error handlers)
  	if (rv != 1)
  		goto out; /* dio not valid, fall back to buffered i/o */
  
@@@ -1149,11 -1098,11 +1154,12 @@@
  			truncate_inode_pages_range(mapping, lstart, end);
  	}
  
 -	rv = __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev, iter,
 -				  offset, gfs2_get_block_direct, NULL, NULL, 0);
 +	rv = __blockdev_direct_IO(rw, iocb, inode, inode->i_sb->s_bdev, iov,
 +				  offset, nr_segs, gfs2_get_block_direct,
 +				  NULL, NULL, 0);
  out:
  	gfs2_glock_dq(&gh);
+ out_uninit:
  	gfs2_holder_uninit(&gh);
  	return rv;
  }
* Unmerged path fs/gfs2/aops.c
diff --git a/fs/gfs2/file.c b/fs/gfs2/file.c
index ed359e65da2d..b086f5899378 100644
--- a/fs/gfs2/file.c
+++ b/fs/gfs2/file.c
@@ -179,7 +179,7 @@ static int gfs2_get_flags(struct file *filp, u32 __user *ptr)
 	gfs2_holder_init(ip->i_gl, LM_ST_SHARED, 0, &gh);
 	error = gfs2_glock_nq(&gh);
 	if (error)
-		return error;
+		goto out_uninit;
 
 	fsflags = fsflags_cvt(gfs2_to_fsflags, ip->i_diskflags);
 	if (!S_ISDIR(inode->i_mode) && ip->i_diskflags & GFS2_DIF_JDATA)
@@ -188,6 +188,7 @@ static int gfs2_get_flags(struct file *filp, u32 __user *ptr)
 		error = -EFAULT;
 
 	gfs2_glock_dq(&gh);
+out_uninit:
 	gfs2_holder_uninit(&gh);
 	return error;
 }
