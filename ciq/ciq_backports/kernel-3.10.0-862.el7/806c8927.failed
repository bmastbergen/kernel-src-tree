x86/hyper-v: Implement rep hypercalls

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] hyper-v: Implement rep hypercalls (Vitaly Kuznetsov) [1465471]
Rebuild_FUZZ: 94.29%
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 806c89273bab0c8af0202a6fb6279f36042cb2e6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/806c8927.failed

Rep hypercalls are normal hypercalls which perform multiple actions at
once. Hyper-V guarantees to return exectution to the caller in not more
than 50us and the caller needs to use hypercall continuation. Touch NMI
watchdog between hypercall invocations.

This is going to be used for HvFlushVirtualAddressList hypercall for
remote TLB flushing.

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
	Reviewed-by: Stephen Hemminger <sthemmin@microsoft.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Haiyang Zhang <haiyangz@microsoft.com>
	Cc: Jork Loeser <Jork.Loeser@microsoft.com>
	Cc: K. Y. Srinivasan <kys@microsoft.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Simon Xiao <sixiao@microsoft.com>
	Cc: Steven Rostedt <rostedt@goodmis.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: devel@linuxdriverproject.org
Link: http://lkml.kernel.org/r/20170802160921.21791-6-vkuznets@redhat.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 806c89273bab0c8af0202a6fb6279f36042cb2e6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/mshyperv.h
diff --cc arch/x86/include/asm/mshyperv.h
index c86331fdc4b0,efa1860276b5..000000000000
--- a/arch/x86/include/asm/mshyperv.h
+++ b/arch/x86/include/asm/mshyperv.h
@@@ -3,8 -3,29 +3,13 @@@
  
  #include <linux/types.h>
  #include <linux/atomic.h>
++<<<<<<< HEAD
++=======
+ #include <linux/nmi.h>
+ #include <asm/io.h>
++>>>>>>> 806c89273bab (x86/hyper-v: Implement rep hypercalls)
  #include <asm/hyperv.h>
  
 -/*
 - * The below CPUID leaves are present if VersionAndFeatures.HypervisorPresent
 - * is set by CPUID(HVCPUID_VERSION_FEATURES).
 - */
 -enum hv_cpuid_function {
 -	HVCPUID_VERSION_FEATURES		= 0x00000001,
 -	HVCPUID_VENDOR_MAXFUNCTION		= 0x40000000,
 -	HVCPUID_INTERFACE			= 0x40000001,
 -
 -	/*
 -	 * The remaining functions depend on the value of
 -	 * HVCPUID_INTERFACE
 -	 */
 -	HVCPUID_VERSION				= 0x40000002,
 -	HVCPUID_FEATURES			= 0x40000003,
 -	HVCPUID_ENLIGHTENMENT_INFO		= 0x40000004,
 -	HVCPUID_IMPLEMENTATION_LIMITS		= 0x40000005,
 -};
 -
  struct ms_hyperv_info {
  	u32 features;
  	u32 misc_features;
@@@ -83,6 -169,181 +88,122 @@@ void hv_setup_crash_handler(void (*hand
  void hv_remove_crash_handler(void);
  
  #if IS_ENABLED(CONFIG_HYPERV)
++<<<<<<< HEAD
++=======
+ extern struct clocksource *hyperv_cs;
+ extern void *hv_hypercall_pg;
+ 
+ static inline u64 hv_do_hypercall(u64 control, void *input, void *output)
+ {
+ 	u64 input_address = input ? virt_to_phys(input) : 0;
+ 	u64 output_address = output ? virt_to_phys(output) : 0;
+ 	u64 hv_status;
+ 	register void *__sp asm(_ASM_SP);
+ 
+ #ifdef CONFIG_X86_64
+ 	if (!hv_hypercall_pg)
+ 		return U64_MAX;
+ 
+ 	__asm__ __volatile__("mov %4, %%r8\n"
+ 			     "call *%5"
+ 			     : "=a" (hv_status), "+r" (__sp),
+ 			       "+c" (control), "+d" (input_address)
+ 			     :  "r" (output_address), "m" (hv_hypercall_pg)
+ 			     : "cc", "memory", "r8", "r9", "r10", "r11");
+ #else
+ 	u32 input_address_hi = upper_32_bits(input_address);
+ 	u32 input_address_lo = lower_32_bits(input_address);
+ 	u32 output_address_hi = upper_32_bits(output_address);
+ 	u32 output_address_lo = lower_32_bits(output_address);
+ 
+ 	if (!hv_hypercall_pg)
+ 		return U64_MAX;
+ 
+ 	__asm__ __volatile__("call *%7"
+ 			     : "=A" (hv_status),
+ 			       "+c" (input_address_lo), "+r" (__sp)
+ 			     : "A" (control),
+ 			       "b" (input_address_hi),
+ 			       "D"(output_address_hi), "S"(output_address_lo),
+ 			       "m" (hv_hypercall_pg)
+ 			     : "cc", "memory");
+ #endif /* !x86_64 */
+ 	return hv_status;
+ }
+ 
+ #define HV_HYPERCALL_RESULT_MASK	GENMASK_ULL(15, 0)
+ #define HV_HYPERCALL_FAST_BIT		BIT(16)
+ #define HV_HYPERCALL_VARHEAD_OFFSET	17
+ #define HV_HYPERCALL_REP_COMP_OFFSET	32
+ #define HV_HYPERCALL_REP_COMP_MASK	GENMASK_ULL(43, 32)
+ #define HV_HYPERCALL_REP_START_OFFSET	48
+ #define HV_HYPERCALL_REP_START_MASK	GENMASK_ULL(59, 48)
+ 
+ /* Fast hypercall with 8 bytes of input and no output */
+ static inline u64 hv_do_fast_hypercall8(u16 code, u64 input1)
+ {
+ 	u64 hv_status, control = (u64)code | HV_HYPERCALL_FAST_BIT;
+ 	register void *__sp asm(_ASM_SP);
+ 
+ #ifdef CONFIG_X86_64
+ 	{
+ 		__asm__ __volatile__("call *%4"
+ 				     : "=a" (hv_status), "+r" (__sp),
+ 				       "+c" (control), "+d" (input1)
+ 				     : "m" (hv_hypercall_pg)
+ 				     : "cc", "r8", "r9", "r10", "r11");
+ 	}
+ #else
+ 	{
+ 		u32 input1_hi = upper_32_bits(input1);
+ 		u32 input1_lo = lower_32_bits(input1);
+ 
+ 		__asm__ __volatile__ ("call *%5"
+ 				      : "=A"(hv_status),
+ 					"+c"(input1_lo),
+ 					"+r"(__sp)
+ 				      :	"A" (control),
+ 					"b" (input1_hi),
+ 					"m" (hv_hypercall_pg)
+ 				      : "cc", "edi", "esi");
+ 	}
+ #endif
+ 		return hv_status;
+ }
+ 
+ /*
+  * Rep hypercalls. Callers of this functions are supposed to ensure that
+  * rep_count and varhead_size comply with Hyper-V hypercall definition.
+  */
+ static inline u64 hv_do_rep_hypercall(u16 code, u16 rep_count, u16 varhead_size,
+ 				      void *input, void *output)
+ {
+ 	u64 control = code;
+ 	u64 status;
+ 	u16 rep_comp;
+ 
+ 	control |= (u64)varhead_size << HV_HYPERCALL_VARHEAD_OFFSET;
+ 	control |= (u64)rep_count << HV_HYPERCALL_REP_COMP_OFFSET;
+ 
+ 	do {
+ 		status = hv_do_hypercall(control, input, output);
+ 		if ((status & HV_HYPERCALL_RESULT_MASK) != HV_STATUS_SUCCESS)
+ 			return status;
+ 
+ 		/* Bits 32-43 of status have 'Reps completed' data. */
+ 		rep_comp = (status & HV_HYPERCALL_REP_COMP_MASK) >>
+ 			HV_HYPERCALL_REP_COMP_OFFSET;
+ 
+ 		control &= ~HV_HYPERCALL_REP_START_MASK;
+ 		control |= (u64)rep_comp << HV_HYPERCALL_REP_START_OFFSET;
+ 
+ 		touch_nmi_watchdog();
+ 	} while (rep_comp < rep_count);
+ 
+ 	return status;
+ }
+ 
++>>>>>>> 806c89273bab (x86/hyper-v: Implement rep hypercalls)
  void hyperv_init(void);
 -void hyperv_report_panic(struct pt_regs *regs);
 -bool hv_is_hypercall_page_setup(void);
 -void hyperv_cleanup(void);
 -#else /* CONFIG_HYPERV */
 -static inline void hyperv_init(void) {}
 -static inline bool hv_is_hypercall_page_setup(void) { return false; }
 -static inline void hyperv_cleanup(void) {}
 -#endif /* CONFIG_HYPERV */
 -
 -#ifdef CONFIG_HYPERV_TSCPAGE
 -struct ms_hyperv_tsc_page *hv_get_tsc_page(void);
 -static inline u64 hv_read_tsc_page(const struct ms_hyperv_tsc_page *tsc_pg)
 -{
 -	u64 scale, offset, cur_tsc;
 -	u32 sequence;
 -
 -	/*
 -	 * The protocol for reading Hyper-V TSC page is specified in Hypervisor
 -	 * Top-Level Functional Specification ver. 3.0 and above. To get the
 -	 * reference time we must do the following:
 -	 * - READ ReferenceTscSequence
 -	 *   A special '0' value indicates the time source is unreliable and we
 -	 *   need to use something else. The currently published specification
 -	 *   versions (up to 4.0b) contain a mistake and wrongly claim '-1'
 -	 *   instead of '0' as the special value, see commit c35b82ef0294.
 -	 * - ReferenceTime =
 -	 *        ((RDTSC() * ReferenceTscScale) >> 64) + ReferenceTscOffset
 -	 * - READ ReferenceTscSequence again. In case its value has changed
 -	 *   since our first reading we need to discard ReferenceTime and repeat
 -	 *   the whole sequence as the hypervisor was updating the page in
 -	 *   between.
 -	 */
 -	do {
 -		sequence = READ_ONCE(tsc_pg->tsc_sequence);
 -		if (!sequence)
 -			return U64_MAX;
 -		/*
 -		 * Make sure we read sequence before we read other values from
 -		 * TSC page.
 -		 */
 -		smp_rmb();
 -
 -		scale = READ_ONCE(tsc_pg->tsc_scale);
 -		offset = READ_ONCE(tsc_pg->tsc_offset);
 -		cur_tsc = rdtsc_ordered();
 -
 -		/*
 -		 * Make sure we read sequence after we read all other values
 -		 * from TSC page.
 -		 */
 -		smp_rmb();
 -
 -	} while (READ_ONCE(tsc_pg->tsc_sequence) != sequence);
 -
 -	return mul_u64_u64_shr(cur_tsc, scale, 64) + offset;
 -}
 -
 -#else
 -static inline struct ms_hyperv_tsc_page *hv_get_tsc_page(void)
 -{
 -	return NULL;
 -}
  #endif
  #endif
* Unmerged path arch/x86/include/asm/mshyperv.h
