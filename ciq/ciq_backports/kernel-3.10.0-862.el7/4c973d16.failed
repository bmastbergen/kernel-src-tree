modules: split part of complete_formation() into prepare_coming_module()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jessica Yu <jeyu@redhat.com>
commit 4c973d1620ae08f5cbe27644c5f5b974c8f594ec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4c973d16.failed

Put all actions in complete_formation() that are performed after
module->state is set to MODULE_STATE_COMING into a separate function
prepare_coming_module(). This split prepares for the removal of the
livepatch module notifiers in favor of hard-coding function calls to
klp_module_{coming,going} in the module loader.

The complete_formation -> prepare_coming_module split will also make error
handling easier since we can jump to the appropriate error label to do any
module GOING cleanup after all the COMING-actions have completed.

	Signed-off-by: Jessica Yu <jeyu@redhat.com>
	Reviewed-by: Josh Poimboeuf <jpoimboe@redhat.com>
	Reviewed-by: Petr Mladek <pmladek@suse.cz>
	Acked-by: Rusty Russell <rusty@rustcorp.com.au>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 4c973d1620ae08f5cbe27644c5f5b974c8f594ec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/module.c
diff --cc kernel/module.c
index 65af51b1c60d,6dbfad415d51..000000000000
--- a/kernel/module.c
+++ b/kernel/module.c
@@@ -3346,8 -3392,6 +3346,11 @@@ static int complete_formation(struct mo
  	mod->state = MODULE_STATE_COMING;
  	mutex_unlock(&module_mutex);
  
++<<<<<<< HEAD
 +	blocking_notifier_call_chain(&module_notify_list,
 +				     MODULE_STATE_COMING, mod);
++=======
++>>>>>>> 4c973d1620ae (modules: split part of complete_formation() into prepare_coming_module())
  	return 0;
  
  out:
@@@ -3355,6 -3399,32 +3358,35 @@@
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int prepare_coming_module(struct module *mod)
+ {
+ 	ftrace_module_enable(mod);
+ 	blocking_notifier_call_chain(&module_notify_list,
+ 				     MODULE_STATE_COMING, mod);
+ 	return 0;
+ }
+ 
+ static int unknown_module_param_cb(char *param, char *val, const char *modname,
+ 				   void *arg)
+ {
+ 	struct module *mod = arg;
+ 	int ret;
+ 
+ 	if (strcmp(param, "async_probe") == 0) {
+ 		mod->async_probe_requested = true;
+ 		return 0;
+ 	}
+ 
+ 	/* Check for magic 'dyndbg' arg */
+ 	ret = ddebug_dyndbg_module_param_cb(param, val, modname);
+ 	if (ret != 0)
+ 		pr_warn("%s: unknown parameter '%s' ignored\n", modname, param);
+ 	return 0;
+ }
+ 
++>>>>>>> 4c973d1620ae (modules: split part of complete_formation() into prepare_coming_module())
  /* Allocate and load the module: note that size of section 0 is always
     zero, and we rely on this for optional sections. */
  static int load_module(struct load_info *info, const char __user *uargs,
@@@ -3470,16 -3521,26 +3502,33 @@@
  	if (err)
  		goto ddebug_cleanup;
  
+ 	err = prepare_coming_module(mod);
+ 	if (err)
+ 		goto bug_cleanup;
+ 
  	/* Module is ready to execute: parsing args may do that. */
++<<<<<<< HEAD
 +	err = parse_args(mod->name, mod->args, mod->kp, mod->num_kp,
 +			 -32768, 32767, &ddebug_dyndbg_module_param_cb);
 +	if (err < 0)
 +		goto bug_cleanup;
++=======
+ 	after_dashes = parse_args(mod->name, mod->args, mod->kp, mod->num_kp,
+ 				  -32768, 32767, mod,
+ 				  unknown_module_param_cb);
+ 	if (IS_ERR(after_dashes)) {
+ 		err = PTR_ERR(after_dashes);
+ 		goto coming_cleanup;
+ 	} else if (after_dashes) {
+ 		pr_warn("%s: parameters '%s' after `--' ignored\n",
+ 		       mod->name, after_dashes);
+ 	}
++>>>>>>> 4c973d1620ae (modules: split part of complete_formation() into prepare_coming_module())
  
 -	/* Link in to syfs. */
 +	/* Link in to sysfs. */
  	err = mod_sysfs_setup(mod, info, mod->kp, mod->num_kp);
  	if (err < 0)
- 		goto bug_cleanup;
+ 		goto coming_cleanup;
  
  	/* Get rid of temporary copy. */
  	free_copy(info);
@@@ -3495,13 -3560,9 +3548,16 @@@
  	module_bug_cleanup(mod);
  	mutex_unlock(&module_mutex);
  
++<<<<<<< HEAD
 +	mod->state = MODULE_STATE_GOING;
 +	blocking_notifier_call_chain(&module_notify_list,
 +				     MODULE_STATE_GOING, mod);
 +
++=======
++>>>>>>> 4c973d1620ae (modules: split part of complete_formation() into prepare_coming_module())
  	/* we can't deallocate the module until we clear memory protection */
 -	module_disable_ro(mod);
 -	module_disable_nx(mod);
 +	unset_module_init_ro_nx(mod);
 +	unset_module_core_ro_nx(mod);
  
   ddebug_cleanup:
  	dynamic_debug_remove(info->debug);
* Unmerged path kernel/module.c
