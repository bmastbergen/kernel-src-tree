drm/i915/skl+: Optimize WM calculation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Kumar, Mahesh <mahesh1.kumar@intel.com>
commit 7e452fdbfca85cd279ecb0d8e9ab6fdd1e8c97fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/7e452fdb.failed

Plane configuration parameters doesn't change for each WM-level
calculation. Currently we compute same parameters 8 times for each
wm-level.
This patch optimizes it by calculating these parameters in beginning
& reuse during each level-wm calculation.

Changes since V1:
 - rebase on top of Rodrigo's series for CNL

	Signed-off-by: Mahesh Kumar <mahesh1.kumar@intel.com>
	Acked-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
	Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
	Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20170817134529.2839-3-mahesh1.kumar@intel.com
(cherry picked from commit 7e452fdbfca85cd279ecb0d8e9ab6fdd1e8c97fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_pm.c
diff --cc drivers/gpu/drm/i915/intel_pm.c
index 52c3abe82e2f,2dd3af3debe9..000000000000
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@@ -3534,35 -4369,118 +3534,134 @@@ static uint32_t skl_adjusted_plane_pixe
  	 * Adjusted plane pixel rate is just the pipe's adjusted pixel rate
  	 * with additional adjustments for plane-specific scaling.
  	 */
 -	adjusted_pixel_rate = cstate->pixel_rate;
 -	downscale_amount = skl_plane_downscale_amount(cstate, pstate);
 +	adjusted_pixel_rate = ilk_pipe_pixel_rate(cstate);
 +	downscale_amount = skl_plane_downscale_amount(pstate);
  
 -	return mul_round_up_u32_fixed16(adjusted_pixel_rate,
 -					    downscale_amount);
 +	pixel_rate = adjusted_pixel_rate * downscale_amount >> 16;
 +	WARN_ON(pixel_rate != clamp_t(uint32_t, pixel_rate, 0, ~0));
 +
 +	return pixel_rate;
  }
  
+ static int
+ skl_compute_plane_wm_params(const struct drm_i915_private *dev_priv,
+ 			    struct intel_crtc_state *cstate,
+ 			    const struct intel_plane_state *intel_pstate,
+ 			    struct skl_wm_params *wp)
+ {
+ 	struct intel_plane *plane = to_intel_plane(intel_pstate->base.plane);
+ 	const struct drm_plane_state *pstate = &intel_pstate->base;
+ 	const struct drm_framebuffer *fb = pstate->fb;
+ 	uint32_t interm_pbpl;
+ 	struct intel_atomic_state *state =
+ 		to_intel_atomic_state(cstate->base.state);
+ 	bool apply_memory_bw_wa = skl_needs_memory_bw_wa(state);
+ 
+ 	if (!intel_wm_plane_visible(cstate, intel_pstate))
+ 		return 0;
+ 
+ 	wp->y_tiled = fb->modifier == I915_FORMAT_MOD_Y_TILED ||
+ 		      fb->modifier == I915_FORMAT_MOD_Yf_TILED ||
+ 		      fb->modifier == I915_FORMAT_MOD_Y_TILED_CCS ||
+ 		      fb->modifier == I915_FORMAT_MOD_Yf_TILED_CCS;
+ 	wp->x_tiled = fb->modifier == I915_FORMAT_MOD_X_TILED;
+ 	wp->rc_surface = fb->modifier == I915_FORMAT_MOD_Y_TILED_CCS ||
+ 			 fb->modifier == I915_FORMAT_MOD_Yf_TILED_CCS;
+ 
+ 	if (plane->id == PLANE_CURSOR) {
+ 		wp->width = intel_pstate->base.crtc_w;
+ 	} else {
+ 		/*
+ 		 * Src coordinates are already rotated by 270 degrees for
+ 		 * the 90/270 degree plane rotation cases (to match the
+ 		 * GTT mapping), hence no need to account for rotation here.
+ 		 */
+ 		wp->width = drm_rect_width(&intel_pstate->base.src) >> 16;
+ 	}
+ 
+ 	wp->cpp = (fb->format->format == DRM_FORMAT_NV12) ? fb->format->cpp[1] :
+ 							    fb->format->cpp[0];
+ 	wp->plane_pixel_rate = skl_adjusted_plane_pixel_rate(cstate,
+ 							     intel_pstate);
+ 
+ 	if (drm_rotation_90_or_270(pstate->rotation)) {
+ 
+ 		switch (wp->cpp) {
+ 		case 1:
+ 			wp->y_min_scanlines = 16;
+ 			break;
+ 		case 2:
+ 			wp->y_min_scanlines = 8;
+ 			break;
+ 		case 4:
+ 			wp->y_min_scanlines = 4;
+ 			break;
+ 		default:
+ 			MISSING_CASE(wp->cpp);
+ 			return -EINVAL;
+ 		}
+ 	} else {
+ 		wp->y_min_scanlines = 4;
+ 	}
+ 
+ 	if (apply_memory_bw_wa)
+ 		wp->y_min_scanlines *= 2;
+ 
+ 	wp->plane_bytes_per_line = wp->width * wp->cpp;
+ 	if (wp->y_tiled) {
+ 		interm_pbpl = DIV_ROUND_UP(wp->plane_bytes_per_line *
+ 					   wp->y_min_scanlines, 512);
+ 
+ 		if (INTEL_GEN(dev_priv) >= 10)
+ 			interm_pbpl++;
+ 
+ 		wp->plane_blocks_per_line = div_fixed16(interm_pbpl,
+ 							wp->y_min_scanlines);
+ 	} else if (wp->x_tiled && IS_GEN9(dev_priv)) {
+ 		interm_pbpl = DIV_ROUND_UP(wp->plane_bytes_per_line, 512);
+ 		wp->plane_blocks_per_line = u32_to_fixed16(interm_pbpl);
+ 	} else {
+ 		interm_pbpl = DIV_ROUND_UP(wp->plane_bytes_per_line, 512) + 1;
+ 		wp->plane_blocks_per_line = u32_to_fixed16(interm_pbpl);
+ 	}
+ 
+ 	wp->y_tile_minimum = mul_u32_fixed16(wp->y_min_scanlines,
+ 					     wp->plane_blocks_per_line);
+ 	wp->linetime_us = fixed16_to_u32_round_up(
+ 					intel_get_linetime_us(cstate));
+ 
+ 	return 0;
+ }
+ 
  static int skl_compute_plane_wm(const struct drm_i915_private *dev_priv,
  				struct intel_crtc_state *cstate,
 -				const struct intel_plane_state *intel_pstate,
 +				struct intel_plane_state *intel_pstate,
  				uint16_t ddb_allocation,
  				int level,
+ 				const struct skl_wm_params *wp,
  				uint16_t *out_blocks, /* out */
  				uint8_t *out_lines, /* out */
  				bool *enabled /* out */)
  {
++<<<<<<< HEAD
 +	struct drm_plane_state *pstate = &intel_pstate->base;
 +	struct drm_framebuffer *fb = pstate->fb;
 +	uint32_t latency = dev_priv->wm.skl_latency[level];
 +	uint32_t method1, method2;
 +	uint32_t plane_bytes_per_line, plane_blocks_per_line;
 +	uint32_t res_blocks, res_lines;
 +	uint32_t selected_result;
 +	uint8_t cpp;
 +	uint32_t width = 0, height = 0;
 +	uint32_t plane_pixel_rate;
 +	uint32_t y_tile_minimum, y_min_scanlines;
++=======
+ 	const struct drm_plane_state *pstate = &intel_pstate->base;
+ 	uint32_t latency = dev_priv->wm.skl_latency[level];
+ 	uint_fixed_16_16_t method1, method2;
+ 	uint_fixed_16_16_t selected_result;
+ 	uint32_t res_blocks, res_lines;
++>>>>>>> 7e452fdbfca8 (drm/i915/skl+: Optimize WM calculation)
  	struct intel_atomic_state *state =
  		to_intel_atomic_state(cstate->base.state);
  	bool apply_memory_bw_wa = skl_needs_memory_bw_wa(state);
@@@ -3572,86 -4491,50 +3671,131 @@@
  		return 0;
  	}
  
++<<<<<<< HEAD
 +	if (apply_memory_bw_wa && fb->modifier == I915_FORMAT_MOD_X_TILED)
 +		latency += 15;
 +
 +	width = drm_rect_width(&intel_pstate->base.src) >> 16;
 +	height = drm_rect_height(&intel_pstate->base.src) >> 16;
 +
 +	if (drm_rotation_90_or_270(pstate->rotation))
 +		swap(width, height);
 +
 +	cpp = drm_format_plane_cpp(fb->pixel_format, 0);
 +	plane_pixel_rate = skl_adjusted_plane_pixel_rate(cstate, intel_pstate);
 +
 +	if (drm_rotation_90_or_270(pstate->rotation)) {
 +		int cpp = (fb->pixel_format == DRM_FORMAT_NV12) ?
 +			drm_format_plane_cpp(fb->pixel_format, 1) :
 +			drm_format_plane_cpp(fb->pixel_format, 0);
 +
 +		switch (cpp) {
 +		case 1:
 +			y_min_scanlines = 16;
 +			break;
 +		case 2:
 +			y_min_scanlines = 8;
 +			break;
 +		case 4:
 +			y_min_scanlines = 4;
 +			break;
 +		default:
 +			MISSING_CASE(cpp);
 +			return -EINVAL;
 +		}
 +	} else {
 +		y_min_scanlines = 4;
 +	}
 +
 +	if (apply_memory_bw_wa)
 +		y_min_scanlines *= 2;
 +
 +	plane_bytes_per_line = width * cpp;
 +	if (fb->modifier == I915_FORMAT_MOD_Y_TILED ||
 +	    fb->modifier == I915_FORMAT_MOD_Yf_TILED) {
 +		plane_blocks_per_line =
 +		      DIV_ROUND_UP(plane_bytes_per_line * y_min_scanlines, 512);
 +		plane_blocks_per_line /= y_min_scanlines;
 +	} else if (fb->modifier == DRM_FORMAT_MOD_NONE) {
 +		plane_blocks_per_line = DIV_ROUND_UP(plane_bytes_per_line, 512)
 +					+ 1;
 +	} else {
 +		plane_blocks_per_line = DIV_ROUND_UP(plane_bytes_per_line, 512);
 +	}
 +
 +	method1 = skl_wm_method1(plane_pixel_rate, cpp, latency);
 +	method2 = skl_wm_method2(plane_pixel_rate,
++=======
+ 	/* Display WA #1141: kbl,cfl */
+ 	if ((IS_KABYLAKE(dev_priv) || IS_COFFEELAKE(dev_priv)) &&
+ 	    dev_priv->ipc_enabled)
+ 		latency += 4;
+ 
+ 	if (apply_memory_bw_wa && wp->x_tiled)
+ 		latency += 15;
+ 
+ 	method1 = skl_wm_method1(dev_priv, wp->plane_pixel_rate,
+ 				 wp->cpp, latency);
+ 	method2 = skl_wm_method2(wp->plane_pixel_rate,
++>>>>>>> 7e452fdbfca8 (drm/i915/skl+: Optimize WM calculation)
  				 cstate->base.adjusted_mode.crtc_htotal,
  				 latency,
- 				 plane_blocks_per_line);
+ 				 wp->plane_blocks_per_line);
  
++<<<<<<< HEAD
 +	y_tile_minimum = plane_blocks_per_line * y_min_scanlines;
 +
 +	if (fb->modifier == I915_FORMAT_MOD_Y_TILED ||
 +	    fb->modifier == I915_FORMAT_MOD_Yf_TILED) {
 +		selected_result = max(method2, y_tile_minimum);
 +	} else {
 +		if ((cpp * cstate->base.adjusted_mode.crtc_htotal / 512 < 1) &&
 +		    (plane_bytes_per_line / 512 < 1))
 +			selected_result = method2;
 +		else if ((ddb_allocation / plane_blocks_per_line) >= 1)
 +			selected_result = min(method1, method2);
++=======
+ 	if (wp->y_tiled) {
+ 		selected_result = max_fixed16(method2, wp->y_tile_minimum);
+ 	} else {
+ 		if ((wp->cpp * cstate->base.adjusted_mode.crtc_htotal /
+ 		     512 < 1) && (wp->plane_bytes_per_line / 512 < 1))
+ 			selected_result = method2;
+ 		else if (ddb_allocation >=
+ 			 fixed16_to_u32_round_up(wp->plane_blocks_per_line))
+ 			selected_result = min_fixed16(method1, method2);
+ 		else if (latency >= wp->linetime_us)
+ 			selected_result = min_fixed16(method1, method2);
++>>>>>>> 7e452fdbfca8 (drm/i915/skl+: Optimize WM calculation)
  		else
  			selected_result = method1;
  	}
  
++<<<<<<< HEAD
 +	res_blocks = selected_result + 1;
 +	res_lines = DIV_ROUND_UP(selected_result, plane_blocks_per_line);
 +
 +	if (level >= 1 && level <= 7) {
 +		if (fb->modifier == I915_FORMAT_MOD_Y_TILED ||
 +		    fb->modifier == I915_FORMAT_MOD_Yf_TILED) {
 +			res_blocks += y_tile_minimum;
 +			res_lines += y_min_scanlines;
++=======
+ 	res_blocks = fixed16_to_u32_round_up(selected_result) + 1;
+ 	res_lines = div_round_up_fixed16(selected_result,
+ 					 wp->plane_blocks_per_line);
+ 
+ 	/* Display WA #1125: skl,bxt,kbl,glk */
+ 	if (level == 0 && wp->rc_surface)
+ 		res_blocks += fixed16_to_u32_round_up(wp->y_tile_minimum);
+ 
+ 	/* Display WA #1126: skl,bxt,kbl,glk */
+ 	if (level >= 1 && level <= 7) {
+ 		if (wp->y_tiled) {
+ 			res_blocks += fixed16_to_u32_round_up(
+ 							wp->y_tile_minimum);
+ 			res_lines += wp->y_min_scanlines;
++>>>>>>> 7e452fdbfca8 (drm/i915/skl+: Optimize WM calculation)
  		} else {
  			res_blocks++;
  		}
@@@ -3685,55 -4568,41 +3829,79 @@@
  }
  
  static int
++<<<<<<< HEAD
 +skl_compute_wm_level(const struct drm_i915_private *dev_priv,
 +		     struct skl_ddb_allocation *ddb,
 +		     struct intel_crtc_state *cstate,
 +		     struct intel_plane *intel_plane,
 +		     int level,
 +		     struct skl_wm_level *result)
++=======
+ skl_compute_wm_levels(const struct drm_i915_private *dev_priv,
+ 		      struct skl_ddb_allocation *ddb,
+ 		      struct intel_crtc_state *cstate,
+ 		      const struct intel_plane_state *intel_pstate,
+ 		      const struct skl_wm_params *wm_params,
+ 		      struct skl_plane_wm *wm)
++>>>>>>> 7e452fdbfca8 (drm/i915/skl+: Optimize WM calculation)
  {
 +	struct drm_atomic_state *state = cstate->base.state;
  	struct intel_crtc *intel_crtc = to_intel_crtc(cstate->base.crtc);
 -	struct drm_plane *plane = intel_pstate->base.plane;
 -	struct intel_plane *intel_plane = to_intel_plane(plane);
 +	struct drm_plane *plane = &intel_plane->base;
 +	struct intel_plane_state *intel_pstate = NULL;
  	uint16_t ddb_blocks;
  	enum pipe pipe = intel_crtc->pipe;
 -	int level, max_level = ilk_wm_max_level(dev_priv);
  	int ret;
 +	int i = skl_wm_plane_id(intel_plane);
  
 -	if (WARN_ON(!intel_pstate->base.fb))
 -		return -EINVAL;
 -
 -	ddb_blocks = skl_ddb_entry_size(&ddb->plane[pipe][intel_plane->id]);
 -
 -	for (level = 0; level <= max_level; level++) {
 -		struct skl_wm_level *result = &wm->wm[level];
 +	if (state)
 +		intel_pstate =
 +			intel_atomic_get_existing_plane_state(state,
 +							      intel_plane);
  
 +	/*
 +	 * Note: If we start supporting multiple pending atomic commits against
 +	 * the same planes/CRTC's in the future, plane->state will no longer be
 +	 * the correct pre-state to use for the calculations here and we'll
 +	 * need to change where we get the 'unchanged' plane data from.
 +	 *
 +	 * For now this is fine because we only allow one queued commit against
 +	 * a CRTC.  Even if the plane isn't modified by this transaction and we
 +	 * don't have a plane lock, we still have the CRTC's lock, so we know
 +	 * that no other transactions are racing with us to update it.
 +	 */
 +	if (!intel_pstate)
 +		intel_pstate = to_intel_plane_state(plane->state);
 +
 +	WARN_ON(!intel_pstate->base.fb);
 +
++<<<<<<< HEAD
 +	ddb_blocks = skl_ddb_entry_size(&ddb->plane[pipe][i]);
 +
 +	ret = skl_compute_plane_wm(dev_priv,
 +				   cstate,
 +				   intel_pstate,
 +				   ddb_blocks,
 +				   level,
 +				   &result->plane_res_b,
 +				   &result->plane_res_l,
 +				   &result->plane_en);
 +	if (ret)
 +		return ret;
++=======
+ 		ret = skl_compute_plane_wm(dev_priv,
+ 					   cstate,
+ 					   intel_pstate,
+ 					   ddb_blocks,
+ 					   level,
+ 					   wm_params,
+ 					   &result->plane_res_b,
+ 					   &result->plane_res_l,
+ 					   &result->plane_en);
+ 		if (ret)
+ 			return ret;
+ 	}
++>>>>>>> 7e452fdbfca8 (drm/i915/skl+: Optimize WM calculation)
  
  	return 0;
  }
@@@ -3782,18 -4657,24 +3950,39 @@@ static int skl_build_pipe_wm(struct int
  	 */
  	memset(pipe_wm->planes, 0, sizeof(pipe_wm->planes));
  
++<<<<<<< HEAD
 +	for_each_intel_plane_mask(&dev_priv->drm,
 +				  intel_plane,
 +				  cstate->base.plane_mask) {
 +		wm = &pipe_wm->planes[skl_wm_plane_id(intel_plane)];
 +
 +		for (level = 0; level <= max_level; level++) {
 +			ret = skl_compute_wm_level(dev_priv, ddb, cstate,
 +						   intel_plane, level,
 +						   &wm->wm[level]);
 +			if (ret)
 +				return ret;
 +		}
++=======
+ 	drm_atomic_crtc_state_for_each_plane_state(plane, pstate, crtc_state) {
+ 		const struct intel_plane_state *intel_pstate =
+ 						to_intel_plane_state(pstate);
+ 		enum plane_id plane_id = to_intel_plane(plane)->id;
+ 		struct skl_wm_params wm_params;
+ 
+ 		wm = &pipe_wm->planes[plane_id];
+ 		memset(&wm_params, 0, sizeof(struct skl_wm_params));
+ 
+ 		ret = skl_compute_plane_wm_params(dev_priv, cstate,
+ 						  intel_pstate, &wm_params);
+ 		if (ret)
+ 			return ret;
+ 
+ 		ret = skl_compute_wm_levels(dev_priv, ddb, cstate,
+ 					    intel_pstate, &wm_params, wm);
+ 		if (ret)
+ 			return ret;
++>>>>>>> 7e452fdbfca8 (drm/i915/skl+: Optimize WM calculation)
  		skl_compute_transition_wm(cstate, &wm->trans_wm);
  	}
  	pipe_wm->linetime = skl_compute_linetime_wm(cstate);
diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index c383dcb3961f..0d7255cb0979 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -1693,6 +1693,20 @@ struct skl_wm_level {
 	uint8_t plane_res_l;
 };
 
+/* Stores plane specific WM parameters */
+struct skl_wm_params {
+	bool x_tiled, y_tiled;
+	bool rc_surface;
+	uint32_t width;
+	uint8_t cpp;
+	uint32_t plane_pixel_rate;
+	uint32_t y_min_scanlines;
+	uint32_t plane_bytes_per_line;
+	uint_fixed_16_16_t plane_blocks_per_line;
+	uint_fixed_16_16_t y_tile_minimum;
+	uint32_t linetime_us;
+};
+
 /*
  * This struct helps tracking the state needed for runtime PM, which puts the
  * device in PCI D3 state. Notice that when this happens, nothing on the
* Unmerged path drivers/gpu/drm/i915/intel_pm.c
