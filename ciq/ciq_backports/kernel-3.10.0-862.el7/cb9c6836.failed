skbuff: add and use skb_nfct helper

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Florian Westphal <fw@strlen.de>
commit cb9c68363efb6d1f950ec55fb06e031ee70db5fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/cb9c6836.failed

Followup patch renames skb->nfct and changes its type so add a helper to
avoid intrusive rename change later.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit cb9c68363efb6d1f950ec55fb06e031ee70db5fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
#	net/ipv4/netfilter/ipt_SYNPROXY.c
#	net/ipv4/netfilter/nf_defrag_ipv4.c
#	net/ipv6/netfilter/ip6t_SYNPROXY.c
#	net/sched/cls_flow.c
diff --cc include/linux/skbuff.h
index e4d3174e2416,276431e047af..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -3582,6 -3655,17 +3591,20 @@@ static inline void skb_init_secmark(str
  { }
  #endif
  
++<<<<<<< HEAD
++=======
+ static inline bool skb_irq_freeable(const struct sk_buff *skb)
+ {
+ 	return !skb->destructor &&
+ #if IS_ENABLED(CONFIG_XFRM)
+ 		!skb->sp &&
+ #endif
+ 		!skb_nfct(skb) &&
+ 		!skb->_skb_refdst &&
+ 		!skb_has_frag_list(skb);
+ }
+ 
++>>>>>>> cb9c68363efb (skbuff: add and use skb_nfct helper)
  static inline void skb_set_queue_mapping(struct sk_buff *skb, u16 queue_mapping)
  {
  	skb->queue_mapping = queue_mapping;
diff --cc net/ipv4/netfilter/ipt_SYNPROXY.c
index f28cd9397584,a12d4f0aa674..000000000000
--- a/net/ipv4/netfilter/ipt_SYNPROXY.c
+++ b/net/ipv4/netfilter/ipt_SYNPROXY.c
@@@ -104,8 -107,8 +104,13 @@@ synproxy_send_client_synack(const struc
  
  	synproxy_build_options(nth, opts);
  
++<<<<<<< HEAD
 +	synproxy_send_tcp(skb, nskb, skb->nfct, IP_CT_ESTABLISHED_REPLY,
 +			  niph, nth, tcp_hdr_size);
++=======
+ 	synproxy_send_tcp(net, skb, nskb, skb_nfct(skb),
+ 			  IP_CT_ESTABLISHED_REPLY, niph, nth, tcp_hdr_size);
++>>>>>>> cb9c68363efb (skbuff: add and use skb_nfct helper)
  }
  
  static void
@@@ -226,8 -230,8 +231,13 @@@ synproxy_send_client_ack(const struct s
  
  	synproxy_build_options(nth, opts);
  
++<<<<<<< HEAD
 +	synproxy_send_tcp(skb, nskb, skb->nfct, IP_CT_ESTABLISHED_REPLY,
 +	                  niph, nth, tcp_hdr_size);
++=======
+ 	synproxy_send_tcp(net, skb, nskb, skb_nfct(skb),
+ 			  IP_CT_ESTABLISHED_REPLY, niph, nth, tcp_hdr_size);
++>>>>>>> cb9c68363efb (skbuff: add and use skb_nfct helper)
  }
  
  static bool
diff --cc net/ipv4/netfilter/nf_defrag_ipv4.c
index fd5dc65d49d5,346bf7ccac08..000000000000
--- a/net/ipv4/netfilter/nf_defrag_ipv4.c
+++ b/net/ipv4/netfilter/nf_defrag_ipv4.c
@@@ -42,8 -44,8 +42,13 @@@ static enum ip_defrag_users nf_ct_defra
  					      struct sk_buff *skb)
  {
  	u16 zone_id = NF_CT_DEFAULT_ZONE_ID;
++<<<<<<< HEAD
 +#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
 +	if (skb->nfct) {
++=======
+ #if IS_ENABLED(CONFIG_NF_CONNTRACK)
+ 	if (skb_nfct(skb)) {
++>>>>>>> cb9c68363efb (skbuff: add and use skb_nfct helper)
  		enum ip_conntrack_info ctinfo;
  		const struct nf_conn *ct = nf_ct_get(skb, &ctinfo);
  
@@@ -66,17 -66,16 +71,17 @@@ static unsigned int ipv4_conntrack_defr
  					  const struct nf_hook_state *state)
  {
  	struct sock *sk = skb->sk;
 +	struct inet_sock *inet = inet_sk(skb->sk);
  
 -	if (sk && sk_fullsock(sk) && (sk->sk_family == PF_INET) &&
 -	    inet_sk(sk)->nodefrag)
 +	if (sk && (sk->sk_family == PF_INET) &&
 +	    inet->nodefrag)
  		return NF_ACCEPT;
  
 -#if IS_ENABLED(CONFIG_NF_CONNTRACK)
 -#if !IS_ENABLED(CONFIG_NF_NAT)
 +#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
 +#if !defined(CONFIG_NF_NAT) && !defined(CONFIG_NF_NAT_MODULE)
  	/* Previously seen (loopback)?  Ignore.  Do this before
  	   fragment check. */
- 	if (skb->nfct && !nf_ct_is_template((struct nf_conn *)skb->nfct))
+ 	if (skb_nfct(skb) && !nf_ct_is_template((struct nf_conn *)skb_nfct(skb)))
  		return NF_ACCEPT;
  #endif
  #endif
diff --cc net/ipv6/netfilter/ip6t_SYNPROXY.c
index 6f67cb544298,2dc01d2c6ec0..000000000000
--- a/net/ipv6/netfilter/ip6t_SYNPROXY.c
+++ b/net/ipv6/netfilter/ip6t_SYNPROXY.c
@@@ -121,8 -121,8 +121,13 @@@ synproxy_send_client_synack(const struc
  
  	synproxy_build_options(nth, opts);
  
++<<<<<<< HEAD
 +	synproxy_send_tcp(snet, skb, nskb, skb->nfct, IP_CT_ESTABLISHED_REPLY,
 +			  niph, nth, tcp_hdr_size);
++=======
+ 	synproxy_send_tcp(net, skb, nskb, skb_nfct(skb),
+ 			  IP_CT_ESTABLISHED_REPLY, niph, nth, tcp_hdr_size);
++>>>>>>> cb9c68363efb (skbuff: add and use skb_nfct helper)
  }
  
  static void
@@@ -243,8 -244,8 +248,13 @@@ synproxy_send_client_ack(const struct s
  
  	synproxy_build_options(nth, opts);
  
++<<<<<<< HEAD
 +	synproxy_send_tcp(snet, skb, nskb, skb->nfct, IP_CT_ESTABLISHED_REPLY,
 +			  niph, nth, tcp_hdr_size);
++=======
+ 	synproxy_send_tcp(net, skb, nskb, skb_nfct(skb),
+ 			  IP_CT_ESTABLISHED_REPLY, niph, nth, tcp_hdr_size);
++>>>>>>> cb9c68363efb (skbuff: add and use skb_nfct helper)
  }
  
  static bool
diff --cc net/sched/cls_flow.c
index cc72c460caa1,3d6b9286c203..000000000000
--- a/net/sched/cls_flow.c
+++ b/net/sched/cls_flow.c
@@@ -127,8 -128,8 +127,13 @@@ static u32 flow_get_mark(const struct s
  
  static u32 flow_get_nfct(const struct sk_buff *skb)
  {
++<<<<<<< HEAD
 +#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
 +	return addr_fold(skb->nfct);
++=======
+ #if IS_ENABLED(CONFIG_NF_CONNTRACK)
+ 	return addr_fold(skb_nfct(skb));
++>>>>>>> cb9c68363efb (skbuff: add and use skb_nfct helper)
  #else
  	return 0;
  #endif
* Unmerged path include/linux/skbuff.h
diff --git a/include/net/netfilter/nf_conntrack_core.h b/include/net/netfilter/nf_conntrack_core.h
index 879b7ab34d59..443c13417c36 100644
--- a/include/net/netfilter/nf_conntrack_core.h
+++ b/include/net/netfilter/nf_conntrack_core.h
@@ -61,7 +61,7 @@ int __nf_conntrack_confirm(struct sk_buff *skb);
 /* Confirm a connection: returns NF_DROP if packet must be dropped. */
 static inline int nf_conntrack_confirm(struct sk_buff *skb)
 {
-	struct nf_conn *ct = (struct nf_conn *)skb->nfct;
+	struct nf_conn *ct = (struct nf_conn *)skb_nfct(skb);
 	int ret = NF_ACCEPT;
 
 	if (ct && !nf_ct_is_untracked(ct)) {
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index 659f0366ff26..d143d3aa4be7 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -668,7 +668,7 @@ static void skb_release_head_state(struct sk_buff *skb)
 		skb->destructor(skb);
 	}
 #if IS_ENABLED(CONFIG_NF_CONNTRACK)
-	nf_conntrack_put(skb->nfct);
+	nf_conntrack_put(skb_nfct(skb));
 #endif
 #if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
 	nf_bridge_put(skb->nf_bridge);
* Unmerged path net/ipv4/netfilter/ipt_SYNPROXY.c
diff --git a/net/ipv4/netfilter/nf_conntrack_proto_icmp.c b/net/ipv4/netfilter/nf_conntrack_proto_icmp.c
index 6f5057af5367..616e2326e621 100644
--- a/net/ipv4/netfilter/nf_conntrack_proto_icmp.c
+++ b/net/ipv4/netfilter/nf_conntrack_proto_icmp.c
@@ -137,7 +137,7 @@ icmp_error_message(struct net *net, struct nf_conn *tmpl, struct sk_buff *skb,
 	enum ip_conntrack_info ctinfo;
 	struct nf_conntrack_zone tmp;
 
-	NF_CT_ASSERT(skb->nfct == NULL);
+	NF_CT_ASSERT(!skb_nfct(skb));
 	zone = nf_ct_zone_tmpl(tmpl, skb, &tmp);
 
 	/* Are they talking about one of our connections? */
* Unmerged path net/ipv4/netfilter/nf_defrag_ipv4.c
diff --git a/net/ipv4/netfilter/nf_dup_ipv4.c b/net/ipv4/netfilter/nf_dup_ipv4.c
index 347de4ddfbff..bc457de5b41e 100644
--- a/net/ipv4/netfilter/nf_dup_ipv4.c
+++ b/net/ipv4/netfilter/nf_dup_ipv4.c
@@ -86,7 +86,7 @@ void nf_dup_ipv4(struct sk_buff *skb, unsigned int hooknum,
 	nf_reset(skb);
 	skb->nfct     = &nf_ct_untracked_get()->ct_general;
 	skb->nfctinfo = IP_CT_NEW;
-	nf_conntrack_get(skb->nfct);
+	nf_conntrack_get(skb_nfct(skb));
 #endif
 	/*
 	 * If we are in PREROUTING/INPUT, the checksum must be recalculated
* Unmerged path net/ipv6/netfilter/ip6t_SYNPROXY.c
diff --git a/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c b/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
index 5b83d2de0e4a..d1a7b10517e7 100644
--- a/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
+++ b/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
@@ -152,7 +152,7 @@ icmpv6_error_message(struct net *net, struct nf_conn *tmpl,
 	enum ip_conntrack_info ctinfo;
 	struct nf_conntrack_zone tmp;
 
-	NF_CT_ASSERT(skb->nfct == NULL);
+	NF_CT_ASSERT(!skb_nfct(skb));
 
 	/* Are they talking about one of our connections? */
 	if (!nf_ct_get_tuplepr(skb,
@@ -223,7 +223,7 @@ icmpv6_error(struct net *net, struct nf_conn *tmpl,
 	    noct_valid_new[type]) {
 		skb->nfct = &nf_ct_untracked_get()->ct_general;
 		skb->nfctinfo = IP_CT_NEW;
-		nf_conntrack_get(skb->nfct);
+		nf_conntrack_get(skb_nfct(skb));
 		return NF_ACCEPT;
 	}
 
diff --git a/net/ipv6/netfilter/nf_defrag_ipv6_hooks.c b/net/ipv6/netfilter/nf_defrag_ipv6_hooks.c
index 425076cbd263..64f5d0114049 100644
--- a/net/ipv6/netfilter/nf_defrag_ipv6_hooks.c
+++ b/net/ipv6/netfilter/nf_defrag_ipv6_hooks.c
@@ -35,7 +35,7 @@ static enum ip6_defrag_users nf_ct6_defrag_user(unsigned int hooknum,
 {
 	u16 zone_id = NF_CT_DEFAULT_ZONE_ID;
 #if IS_ENABLED(CONFIG_NF_CONNTRACK)
-	if (skb->nfct) {
+	if (skb_nfct(skb)) {
 		enum ip_conntrack_info ctinfo;
 		const struct nf_conn *ct = nf_ct_get(skb, &ctinfo);
 
@@ -62,7 +62,7 @@ static unsigned int ipv6_defrag(const struct nf_hook_ops *ops,
 
 #if IS_ENABLED(CONFIG_NF_CONNTRACK)
 	/* Previously seen (loopback)?	*/
-	if (skb->nfct && !nf_ct_is_template((struct nf_conn *)skb->nfct))
+	if (skb_nfct(skb) && !nf_ct_is_template((struct nf_conn *)skb_nfct(skb)))
 		return NF_ACCEPT;
 #endif
 
diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c
index 5140736f7cea..908b72584f1a 100644
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@ -1188,7 +1188,7 @@ nf_conntrack_in(struct net *net, u_int8_t pf, unsigned int hooknum,
 		goto out;
 	}
 
-	NF_CT_ASSERT(skb->nfct);
+	NF_CT_ASSERT(skb_nfct(skb));
 
 	/* Decide what timeout policy we want to apply to this flow. */
 	timeouts = nf_ct_timeout_lookup(net, ct, l4proto);
@@ -1398,7 +1398,7 @@ static void nf_conntrack_attach(struct sk_buff *nskb, const struct sk_buff *skb)
 	/* Attach to new skbuff, and increment count */
 	nskb->nfct = &ct->ct_general;
 	nskb->nfctinfo = ctinfo;
-	nf_conntrack_get(nskb->nfct);
+	nf_conntrack_get(skb_nfct(nskb));
 }
 
 /* Bring out ya dead! */
diff --git a/net/netfilter/nf_nat_helper.c b/net/netfilter/nf_nat_helper.c
index 2840abb5bb99..211661cb2c90 100644
--- a/net/netfilter/nf_nat_helper.c
+++ b/net/netfilter/nf_nat_helper.c
@@ -60,7 +60,7 @@ static void mangle_contents(struct sk_buff *skb,
 		__skb_trim(skb, skb->len + rep_len - match_len);
 	}
 
-	if (nf_ct_l3num((struct nf_conn *)skb->nfct) == NFPROTO_IPV4) {
+	if (nf_ct_l3num((struct nf_conn *)skb_nfct(skb)) == NFPROTO_IPV4) {
 		/* fix IP hdr checksum information */
 		ip_hdr(skb)->tot_len = htons(skb->len);
 		ip_send_check(ip_hdr(skb));
diff --git a/net/netfilter/xt_CT.c b/net/netfilter/xt_CT.c
index 06a694fb8d39..f58c7eac857a 100644
--- a/net/netfilter/xt_CT.c
+++ b/net/netfilter/xt_CT.c
@@ -407,7 +407,7 @@ notrack_tg(struct sk_buff *skb, const struct xt_action_param *par)
 
 	skb->nfct = &nf_ct_untracked_get()->ct_general;
 	skb->nfctinfo = IP_CT_NEW;
-	nf_conntrack_get(skb->nfct);
+	nf_conntrack_get(skb_nfct(skb));
 
 	return XT_CONTINUE;
 }
diff --git a/net/openvswitch/conntrack.c b/net/openvswitch/conntrack.c
index 0eec48a6f4bc..3836ee4da85d 100644
--- a/net/openvswitch/conntrack.c
+++ b/net/openvswitch/conntrack.c
@@ -734,8 +734,8 @@ static int __ovs_ct_lookup(struct net *net, struct sw_flow_key *key,
 
 		/* Associate skb with specified zone. */
 		if (tmpl) {
-			if (skb->nfct)
-				nf_conntrack_put(skb->nfct);
+			if (skb_nfct(skb))
+				nf_conntrack_put(skb_nfct(skb));
 			nf_conntrack_get(&tmpl->ct_general);
 			skb->nfct = &tmpl->ct_general;
 			skb->nfctinfo = IP_CT_NEW;
@@ -836,7 +836,7 @@ static int ovs_ct_lookup(struct net *net, struct sw_flow_key *key,
 		if (err)
 			return err;
 
-		ct = (struct nf_conn *)skb->nfct;
+		ct = (struct nf_conn *)skb_nfct(skb);
 		if (ct)
 			nf_ct_deliver_cached_events(ct);
 	}
* Unmerged path net/sched/cls_flow.c
