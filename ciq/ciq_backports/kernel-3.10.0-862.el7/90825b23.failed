net sched actions: dump more than TCA_ACT_MAX_PRIO actions per batch

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] sched: actions: dump more than TCA_ACT_MAX_PRIO actions per batch (Ivan Vecera) [1445420]
Rebuild_FUZZ: 96.24%
commit-author Jamal Hadi Salim <jhs@mojatatu.com>
commit 90825b23a887f06f6c05bdde77b200c5fe9b6217
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/90825b23.failed

When you dump hundreds of thousands of actions, getting only 32 per
dump batch even when the socket buffer and memory allocations allow
is inefficient.

With this change, the user will get as many as possibly fitting
within the given constraints available to the kernel.

The top level action TLV space is extended. An attribute
TCA_ROOT_FLAGS is used to carry flags; flag TCA_FLAG_LARGE_DUMP_ON
is set by the user indicating the user is capable of processing
these large dumps. Older user space which doesnt set this flag
doesnt get the large (than 32) batches.
The kernel uses the TCA_ROOT_COUNT attribute to tell the user how many
actions are put in a single batch. As such user space app knows how long
to iterate (independent of the type of action being dumped)
instead of hardcoded maximum of 32 thus maintaining backward compat.

Some results dumping 1.5M actions below:
first an unpatched tc which doesnt understand these features...

prompt$ time -p tc actions ls action gact | grep index | wc -l
1500000
real 1388.43
user 2.07
sys 1386.79

Now lets see a patched tc which sets the correct flags when requesting
a dump:

prompt$ time -p updatedtc actions ls action gact | grep index | wc -l
1500000
real 178.13
user 2.02
sys 176.96

That is about 8x performance improvement for tc app which sets its
receive buffer to about 32K.

	Signed-off-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Reviewed-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 90825b23a887f06f6c05bdde77b200c5fe9b6217)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/act_api.c
diff --cc net/sched/act_api.c
index f6d266c05d33,d53653a73c4f..000000000000
--- a/net/sched/act_api.c
+++ b/net/sched/act_api.c
@@@ -84,13 -106,11 +84,14 @@@ int __tcf_hash_release(struct tc_actio
  }
  EXPORT_SYMBOL(__tcf_hash_release);
  
 -static int tcf_dump_walker(struct tcf_hashinfo *hinfo, struct sk_buff *skb,
 -			   struct netlink_callback *cb)
 +static int tcf_dump_walker(struct sk_buff *skb, struct netlink_callback *cb,
 +			   struct tc_action *a)
  {
 +	struct tcf_hashinfo *hinfo = a->ops->hinfo;
 +	struct hlist_head *head;
 +	struct tcf_common *p;
  	int err = 0, index = -1, i = 0, s_i = 0, n_i = 0;
+ 	u32 act_flags = cb->args[2];
  	struct nlattr *nest;
  
  	spin_lock_bh(&hinfo->lock);
@@@ -1056,10 -1073,17 +1061,24 @@@ static int tcf_action_add(struct net *n
  	return tcf_add_notify(net, n, &actions, portid);
  }
  
++<<<<<<< HEAD
 +static int tc_ctl_action(struct sk_buff *skb, struct nlmsghdr *n)
 +{
 +	struct net *net = sock_net(skb->sk);
 +	struct nlattr *tca[TCA_ACT_MAX + 1];
++=======
+ static u32 tcaa_root_flags_allowed = TCA_FLAG_LARGE_DUMP_ON;
+ static const struct nla_policy tcaa_policy[TCA_ROOT_MAX + 1] = {
+ 	[TCA_ROOT_FLAGS] = { .type = NLA_BITFIELD32,
+ 			     .validation_data = &tcaa_root_flags_allowed },
+ };
+ 
+ static int tc_ctl_action(struct sk_buff *skb, struct nlmsghdr *n,
+ 			 struct netlink_ext_ack *extack)
+ {
+ 	struct net *net = sock_net(skb->sk);
+ 	struct nlattr *tca[TCA_ROOT_MAX + 1];
++>>>>>>> 90825b23a887 (net sched actions: dump more than TCA_ACT_MAX_PRIO actions per batch)
  	u32 portid = skb ? NETLINK_CB(skb).portid : 0;
  	int ret = 0, ovr = 0;
  
@@@ -1067,7 -1091,8 +1086,12 @@@
  	    !netlink_capable(skb, CAP_NET_ADMIN))
  		return -EPERM;
  
++<<<<<<< HEAD
 +	ret = nlmsg_parse(n, sizeof(struct tcamsg), tca, TCA_ACT_MAX, NULL);
++=======
+ 	ret = nlmsg_parse(n, sizeof(struct tcamsg), tca, TCA_ROOT_MAX, NULL,
+ 			  extack);
++>>>>>>> 90825b23a887 (net sched actions: dump more than TCA_ACT_MAX_PRIO actions per batch)
  	if (ret < 0)
  		return ret;
  
@@@ -1111,11 -1136,8 +1135,13 @@@ static struct nlattr *find_dump_kind(st
  {
  	struct nlattr *tb1, *tb2[TCA_ACT_MAX + 1];
  	struct nlattr *tb[TCA_ACT_MAX_PRIO + 1];
- 	struct nlattr *nla[TCAA_MAX + 1];
  	struct nlattr *kind;
  
++<<<<<<< HEAD
 +	if (nlmsg_parse(n, sizeof(struct tcamsg), nla, TCAA_MAX, NULL) < 0)
 +		return NULL;
++=======
++>>>>>>> 90825b23a887 (net sched actions: dump more than TCA_ACT_MAX_PRIO actions per batch)
  	tb1 = nla[TCA_ACT_TAB];
  	if (tb1 == NULL)
  		return NULL;
@@@ -1139,11 -1162,20 +1165,21 @@@ static int tc_dump_action(struct sk_buf
  	unsigned char *b = skb_tail_pointer(skb);
  	struct nlattr *nest;
  	struct tc_action_ops *a_o;
 +	struct tc_action a;
  	int ret = 0;
  	struct tcamsg *t = (struct tcamsg *) nlmsg_data(cb->nlh);
- 	struct nlattr *kind = find_dump_kind(cb->nlh);
+ 	struct nlattr *tb[TCA_ROOT_MAX + 1];
+ 	struct nlattr *count_attr = NULL;
+ 	struct nlattr *kind = NULL;
+ 	struct nla_bitfield32 bf;
+ 	u32 act_count = 0;
+ 
+ 	ret = nlmsg_parse(cb->nlh, sizeof(struct tcamsg), tb, TCA_ROOT_MAX,
+ 			  tcaa_policy, NULL);
+ 	if (ret < 0)
+ 		return ret;
  
+ 	kind = find_dump_kind(tb);
  	if (kind == NULL) {
  		pr_info("tc_dump_action: action bad kind\n");
  		return 0;
@@@ -1153,8 -1185,11 +1189,16 @@@
  	if (a_o == NULL)
  		return 0;
  
++<<<<<<< HEAD
 +	memset(&a, 0, sizeof(struct tc_action));
 +	a.ops = a_o;
++=======
+ 	cb->args[2] = 0;
+ 	if (tb[TCA_ROOT_FLAGS]) {
+ 		bf = nla_get_bitfield32(tb[TCA_ROOT_FLAGS]);
+ 		cb->args[2] = bf.value;
+ 	}
++>>>>>>> 90825b23a887 (net sched actions: dump more than TCA_ACT_MAX_PRIO actions per batch)
  
  	nlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,
  			cb->nlh->nlmsg_type, sizeof(*t), 0);
diff --git a/include/uapi/linux/rtnetlink.h b/include/uapi/linux/rtnetlink.h
index d8701000036f..d2bd69a214d7 100644
--- a/include/uapi/linux/rtnetlink.h
+++ b/include/uapi/linux/rtnetlink.h
@@ -661,10 +661,28 @@ struct tcamsg {
 	unsigned char	tca__pad1;
 	unsigned short	tca__pad2;
 };
+
+enum {
+	TCA_ROOT_UNSPEC,
+	TCA_ROOT_TAB,
+#define TCA_ACT_TAB TCA_ROOT_TAB
+#define TCAA_MAX TCA_ROOT_TAB
+	TCA_ROOT_FLAGS,
+	TCA_ROOT_COUNT,
+	__TCA_ROOT_MAX,
+#define	TCA_ROOT_MAX (__TCA_ROOT_MAX - 1)
+};
+
 #define TA_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct tcamsg))))
 #define TA_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct tcamsg))
-#define TCA_ACT_TAB 1 /* attr type must be >=1 */	
-#define TCAA_MAX 1
+/* tcamsg flags stored in attribute TCA_ROOT_FLAGS
+ *
+ * TCA_FLAG_LARGE_DUMP_ON user->kernel to request for larger than TCA_ACT_MAX_PRIO
+ * actions in a dump. All dump responses will contain the number of actions
+ * being dumped stored in for user app's consumption in TCA_ROOT_COUNT
+ *
+ */
+#define TCA_FLAG_LARGE_DUMP_ON		(1 << 0)
 
 /* New extended info filters for IFLA_EXT_MASK */
 #define RTEXT_FILTER_VF		(1 << 0)
* Unmerged path net/sched/act_api.c
