x86/tsc: Add option that TSC on Socket 0 being non-zero is valid

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] tsc: Add option that TSC on Socket 0 being non-zero is valid (Frank Ramsay) [1526066]
Rebuild_FUZZ: 96.77%
commit-author mike.travis@hpe.com <mike.travis@hpe.com>
commit 341102c3ef29c33611586072363cf9982a8bdb77
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/341102c3.failed

Add a flag to indicate and process that TSC counters are on chassis
that reset at different times during system startup.  Therefore which
TSC ADJUST values should be zero is not predictable.

	Signed-off-by: Mike Travis <mike.travis@hpe.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Dimitri Sivanich <dimitri.sivanich@hpe.com>
	Reviewed-by: Russ Anderson <russ.anderson@hpe.com>
	Reviewed-by: Andrew Banman <andrew.abanman@hpe.com>
	Reviewed-by: Peter Zijlstra <peterz@infradead.org>
	Cc: Prarit Bhargava <prarit@redhat.com>
	Cc: Andrew Banman <andrew.banman@hpe.com>
	Cc: Bin Gao <bin.gao@linux.intel.com>
Link: https://lkml.kernel.org/r/20171012163201.944370012@stormcage.americas.sgi.com

(cherry picked from commit 341102c3ef29c33611586072363cf9982a8bdb77)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/tsc.h
#	arch/x86/kernel/tsc_sync.c
diff --cc arch/x86/include/asm/tsc.h
index 43f6163d09b9,79125f3609c4..000000000000
--- a/arch/x86/include/asm/tsc.h
+++ b/arch/x86/include/asm/tsc.h
@@@ -35,7 -36,7 +35,11 @@@ extern void tsc_init(void)
  extern void mark_tsc_unstable(char *reason);
  extern int unsynchronized_tsc(void);
  extern int check_tsc_unstable(void);
++<<<<<<< HEAD
 +extern int check_tsc_disabled(void);
++=======
+ extern void mark_tsc_async_resets(char *reason);
++>>>>>>> 341102c3ef29 (x86/tsc: Add option that TSC on Socket 0 being non-zero is valid)
  extern unsigned long native_calibrate_cpu(void);
  extern unsigned long native_calibrate_tsc(void);
  extern unsigned long long native_sched_clock_from_tsc(u64 tsc);
diff --cc arch/x86/kernel/tsc_sync.c
index 68270eb35526,3873dcdc7d7b..000000000000
--- a/arch/x86/kernel/tsc_sync.c
+++ b/arch/x86/kernel/tsc_sync.c
@@@ -30,7 -30,21 +30,25 @@@ struct tsc_adjust 
  
  static DEFINE_PER_CPU(struct tsc_adjust, tsc_adjust);
  
++<<<<<<< HEAD
 +void tsc_verify_tsc_adjust(void)
++=======
+ /*
+  * TSC's on different sockets may be reset asynchronously.
+  * This may cause the TSC ADJUST value on socket 0 to be NOT 0.
+  */
+ bool __read_mostly tsc_async_resets;
+ 
+ void mark_tsc_async_resets(char *reason)
+ {
+ 	if (tsc_async_resets)
+ 		return;
+ 	tsc_async_resets = true;
+ 	pr_info("tsc: Marking TSC async resets true due to %s\n", reason);
+ }
+ 
+ void tsc_verify_tsc_adjust(bool resume)
++>>>>>>> 341102c3ef29 (x86/tsc: Add option that TSC on Socket 0 being non-zero is valid)
  {
  	struct tsc_adjust *adj = this_cpu_ptr(&tsc_adjust);
  	s64 curval;
@@@ -58,10 -72,43 +76,46 @@@
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void tsc_sanitize_first_cpu(struct tsc_adjust *cur, s64 bootval,
+ 				   unsigned int cpu, bool bootcpu)
+ {
+ 	/*
+ 	 * First online CPU in a package stores the boot value in the
+ 	 * adjustment value. This value might change later via the sync
+ 	 * mechanism. If that fails we still can yell about boot values not
+ 	 * being consistent.
+ 	 *
+ 	 * On the boot cpu we just force set the ADJUST value to 0 if it's
+ 	 * non zero. We don't do that on non boot cpus because physical
+ 	 * hotplug should have set the ADJUST register to a value > 0 so
+ 	 * the TSC is in sync with the already running cpus.
+ 	 *
+ 	 * Also don't force the ADJUST value to zero if that is a valid value
+ 	 * for socket 0 as determined by the system arch.  This is required
+ 	 * when multiple sockets are reset asynchronously with each other
+ 	 * and socket 0 may not have an TSC ADJUST value of 0.
+ 	 */
+ 	if (bootcpu && bootval != 0) {
+ 		if (likely(!tsc_async_resets)) {
+ 			pr_warn(FW_BUG "TSC ADJUST: CPU%u: %lld force to 0\n",
+ 				cpu, bootval);
+ 			wrmsrl(MSR_IA32_TSC_ADJUST, 0);
+ 			bootval = 0;
+ 		} else {
+ 			pr_info("TSC ADJUST: CPU%u: %lld NOT forced to 0\n",
+ 				cpu, bootval);
+ 		}
+ 	}
+ 	cur->adjusted = bootval;
+ }
+ 
++>>>>>>> 341102c3ef29 (x86/tsc: Add option that TSC on Socket 0 being non-zero is valid)
  #ifndef CONFIG_SMP
 -bool __init tsc_store_and_check_tsc_adjust(bool bootcpu)
 +bool __init tsc_store_and_check_tsc_adjust(void)
  {
 -	struct tsc_adjust *cur = this_cpu_ptr(&tsc_adjust);
 +	struct tsc_adjust *ref, *cur = this_cpu_ptr(&tsc_adjust);
  	s64 bootval;
  
  	if (!boot_cpu_has(X86_FEATURE_TSC_ADJUST))
* Unmerged path arch/x86/include/asm/tsc.h
* Unmerged path arch/x86/kernel/tsc_sync.c
