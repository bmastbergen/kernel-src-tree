allow build_open_flags() to return an error

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit f9652e10c12b43d9bb957269745cf2fa5682fa92
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f9652e10.failed

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit f9652e10c12b43d9bb957269745cf2fa5682fa92)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/exec.c
#	fs/namei.c
diff --cc fs/exec.c
index 9ca6d51722de,0f6c96c57b2f..000000000000
--- a/fs/exec.c
+++ b/fs/exec.c
@@@ -756,10 -756,12 +757,15 @@@ static struct file *do_open_exec(struc
  	static const struct open_flags open_exec_flags = {
  		.open_flag = O_LARGEFILE | O_RDONLY | __FMODE_EXEC,
  		.acc_mode = MAY_EXEC | MAY_OPEN,
- 		.intent = LOOKUP_OPEN
+ 		.intent = LOOKUP_OPEN,
+ 		.lookup_flags = LOOKUP_FOLLOW,
  	};
  
++<<<<<<< HEAD
 +	file = do_filp_open(AT_FDCWD, name, &open_exec_flags, LOOKUP_FOLLOW);
++=======
+ 	file = do_filp_open(AT_FDCWD, &tmp, &open_exec_flags);
++>>>>>>> f9652e10c12b (allow build_open_flags() to return an error)
  	if (IS_ERR(file))
  		goto out;
  
diff --cc fs/namei.c
index 01f0ff2e2d1f,402eda351d07..000000000000
--- a/fs/namei.c
+++ b/fs/namei.c
@@@ -3325,26 -2988,20 +3326,35 @@@ struct file *do_file_open_root(struct d
  {
  	struct nameidata nd;
  	struct file *file;
++<<<<<<< HEAD
 +	struct filename *filename;
++=======
+ 	struct filename filename = { .name = name };
+ 	int flags = op->lookup_flags | LOOKUP_ROOT;
++>>>>>>> f9652e10c12b (allow build_open_flags() to return an error)
  
  	nd.root.mnt = mnt;
  	nd.root.dentry = dentry;
  
++<<<<<<< HEAD
 +	flags |= LOOKUP_ROOT;
 +
 +	if (d_is_symlink(dentry) && op->intent & LOOKUP_OPEN)
++=======
+ 	if (dentry->d_inode->i_op->follow_link && op->intent & LOOKUP_OPEN)
++>>>>>>> f9652e10c12b (allow build_open_flags() to return an error)
  		return ERR_PTR(-ELOOP);
  
 -	file = path_openat(-1, &filename, &nd, op, flags | LOOKUP_RCU);
 +	filename = getname_kernel(name);
 +	if (unlikely(IS_ERR(filename)))
 +		return ERR_CAST(filename);
 +
 +	file = path_openat(-1, filename, &nd, op, flags | LOOKUP_RCU);
  	if (unlikely(file == ERR_PTR(-ECHILD)))
 -		file = path_openat(-1, &filename, &nd, op, flags);
 +		file = path_openat(-1, filename, &nd, op, flags);
  	if (unlikely(file == ERR_PTR(-ESTALE)))
 -		file = path_openat(-1, &filename, &nd, op, flags | LOOKUP_REVAL);
 +		file = path_openat(-1, filename, &nd, op, flags | LOOKUP_REVAL);
 +	putname(filename);
  	return file;
  }
  
* Unmerged path fs/exec.c
diff --git a/fs/internal.h b/fs/internal.h
index c58979ac0a78..088aeebfd7cd 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -101,11 +101,12 @@ struct open_flags {
 	umode_t mode;
 	int acc_mode;
 	int intent;
+	int lookup_flags;
 };
 extern struct file *do_filp_open(int dfd, struct filename *pathname,
-		const struct open_flags *op, int flags);
+		const struct open_flags *op);
 extern struct file *do_file_open_root(struct dentry *, struct vfsmount *,
-		const char *, const struct open_flags *, int lookup_flags);
+		const char *, const struct open_flags *);
 
 extern long do_handle_open(int mountdirfd,
 			   struct file_handle __user *ufh, int open_flag);
* Unmerged path fs/namei.c
diff --git a/fs/open.c b/fs/open.c
index d92e96ba4ff5..fa31a2b3c70f 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -966,7 +966,8 @@ static inline int build_open_flags(int flags, umode_t mode, struct open_flags *o
 		lookup_flags |= LOOKUP_DIRECTORY;
 	if (!(flags & O_NOFOLLOW))
 		lookup_flags |= LOOKUP_FOLLOW;
-	return lookup_flags;
+	op->lookup_flags = lookup_flags;
+	return 0;
 }
 
 /**
@@ -983,8 +984,8 @@ static inline int build_open_flags(int flags, umode_t mode, struct open_flags *o
 struct file *file_open_name(struct filename *name, int flags, umode_t mode)
 {
 	struct open_flags op;
-	int lookup = build_open_flags(flags, mode, &op);
-	return do_filp_open(AT_FDCWD, name, &op, lookup);
+	int err = build_open_flags(flags, mode, &op);
+	return err ? ERR_PTR(err) : do_filp_open(AT_FDCWD, name, &op);
 }
 
 /**
@@ -1015,37 +1016,43 @@ struct file *file_open_root(struct dentry *dentry, struct vfsmount *mnt,
 			    const char *filename, int flags)
 {
 	struct open_flags op;
-	int lookup = build_open_flags(flags, 0, &op);
+	int err = build_open_flags(flags, 0, &op);
+	if (err)
+		return ERR_PTR(err);
 	if (flags & O_CREAT)
 		return ERR_PTR(-EINVAL);
 	if (!filename && (flags & O_DIRECTORY))
 		if (!dentry->d_inode->i_op->lookup)
 			return ERR_PTR(-ENOTDIR);
-	return do_file_open_root(dentry, mnt, filename, &op, lookup);
+	return do_file_open_root(dentry, mnt, filename, &op);
 }
 EXPORT_SYMBOL(file_open_root);
 
 long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)
 {
 	struct open_flags op;
-	int lookup = build_open_flags(flags, mode, &op);
-	struct filename *tmp = getname(filename);
-	int fd = PTR_ERR(tmp);
-
-	if (!IS_ERR(tmp)) {
-		fd = get_unused_fd_flags(flags);
-		if (fd >= 0) {
-			struct file *f = do_filp_open(dfd, tmp, &op, lookup);
-			if (IS_ERR(f)) {
-				put_unused_fd(fd);
-				fd = PTR_ERR(f);
-			} else {
-				fsnotify_open(f);
-				fd_install(fd, f);
-			}
+	int fd = build_open_flags(flags, mode, &op);
+	struct filename *tmp;
+
+	if (fd)
+		return fd;
+
+	tmp = getname(filename);
+	if (IS_ERR(tmp))
+		return PTR_ERR(tmp);
+
+	fd = get_unused_fd_flags(flags);
+	if (fd >= 0) {
+		struct file *f = do_filp_open(dfd, tmp, &op);
+		if (IS_ERR(f)) {
+			put_unused_fd(fd);
+			fd = PTR_ERR(f);
+		} else {
+			fsnotify_open(f);
+			fd_install(fd, f);
 		}
-		putname(tmp);
 	}
+	putname(tmp);
 	return fd;
 }
 
