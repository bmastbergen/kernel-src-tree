PCI: Add Intel Thunderbolt device IDs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Lukas Wunner <lukas@wunner.de>
commit 1d111406c6d91f4d7f6cc69a43e59546e8010aae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1d111406.failed

Intel Gen 1 and 2 chips use the same ID for NHI, bridges and switch.  Gen 3
chips and onward use a distinct ID for the NHI.

No functional change intended.

	Signed-off-by: Lukas Wunner <lukas@wunner.de>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Acked-by: Andreas Noever <andreas.noever@gmail.com>
(cherry picked from commit 1d111406c6d91f4d7f6cc69a43e59546e8010aae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/quirks.c
#	drivers/thunderbolt/nhi.c
#	drivers/thunderbolt/switch.c
diff --cc drivers/pci/quirks.c
index 7908058abb14,b584ddf83555..000000000000
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@@ -3298,24 -3185,106 +3298,80 @@@ static void quirk_no_pm_reset(struct pc
  DECLARE_PCI_FIXUP_CLASS_HEADER(PCI_VENDOR_ID_ATI, PCI_ANY_ID,
  			       PCI_CLASS_DISPLAY_VGA, 8, quirk_no_pm_reset);
  
 -#ifdef CONFIG_ACPI
 -/*
 - * Apple: Shutdown Cactus Ridge Thunderbolt controller.
 - *
 - * On Apple hardware the Cactus Ridge Thunderbolt controller needs to be
 - * shutdown before suspend. Otherwise the native host interface (NHI) will not
 - * be present after resume if a device was plugged in before suspend.
 - *
 - * The thunderbolt controller consists of a pcie switch with downstream
 - * bridges leading to the NHI and to the tunnel pci bridges.
 - *
 - * This quirk cuts power to the whole chip. Therefore we have to apply it
 - * during suspend_noirq of the upstream bridge.
 - *
 - * Power is automagically restored before resume. No action is needed.
 - */
 -static void quirk_apple_poweroff_thunderbolt(struct pci_dev *dev)
 -{
 -	acpi_handle bridge, SXIO, SXFP, SXLV;
 -
 -	if (!dmi_match(DMI_BOARD_VENDOR, "Apple Inc."))
 -		return;
 -	if (pci_pcie_type(dev) != PCI_EXP_TYPE_UPSTREAM)
 -		return;
 -	bridge = ACPI_HANDLE(&dev->dev);
 -	if (!bridge)
 -		return;
 -	/*
 -	 * SXIO and SXLV are present only on machines requiring this quirk.
 -	 * TB bridges in external devices might have the same device id as those
 -	 * on the host, but they will not have the associated ACPI methods. This
 -	 * implicitly checks that we are at the right bridge.
 -	 */
 -	if (ACPI_FAILURE(acpi_get_handle(bridge, "DSB0.NHI0.SXIO", &SXIO))
 -	    || ACPI_FAILURE(acpi_get_handle(bridge, "DSB0.NHI0.SXFP", &SXFP))
 -	    || ACPI_FAILURE(acpi_get_handle(bridge, "DSB0.NHI0.SXLV", &SXLV)))
 -		return;
 -	dev_info(&dev->dev, "quirk: cutting power to thunderbolt controller...\n");
 -
 -	/* magic sequence */
 -	acpi_execute_simple_method(SXIO, NULL, 1);
 -	acpi_execute_simple_method(SXFP, NULL, 0);
 -	msleep(300);
 -	acpi_execute_simple_method(SXLV, NULL, 0);
 -	acpi_execute_simple_method(SXIO, NULL, 0);
 -	acpi_execute_simple_method(SXLV, NULL, 0);
 -}
 +static void quirk_chelsio_extend_vpd(struct pci_dev *dev)
 +{
 +	pci_set_vpd_size(dev, 8192);
 +}
++<<<<<<< HEAD
 +
 +DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x20, quirk_chelsio_extend_vpd);
 +DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x21, quirk_chelsio_extend_vpd);
 +DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x22, quirk_chelsio_extend_vpd);
 +DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x23, quirk_chelsio_extend_vpd);
 +DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x24, quirk_chelsio_extend_vpd);
 +DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x25, quirk_chelsio_extend_vpd);
 +DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x26, quirk_chelsio_extend_vpd);
 +DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x30, quirk_chelsio_extend_vpd);
 +DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x31, quirk_chelsio_extend_vpd);
 +DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x32, quirk_chelsio_extend_vpd);
 +DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x35, quirk_chelsio_extend_vpd);
 +DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x36, quirk_chelsio_extend_vpd);
 +DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x37, quirk_chelsio_extend_vpd);
++=======
+ DECLARE_PCI_FIXUP_SUSPEND_LATE(PCI_VENDOR_ID_INTEL,
+ 			       PCI_DEVICE_ID_INTEL_CACTUS_RIDGE_4C,
+ 			       quirk_apple_poweroff_thunderbolt);
+ 
+ /*
+  * Apple: Wait for the thunderbolt controller to reestablish pci tunnels.
+  *
+  * During suspend the thunderbolt controller is reset and all pci
+  * tunnels are lost. The NHI driver will try to reestablish all tunnels
+  * during resume. We have to manually wait for the NHI since there is
+  * no parent child relationship between the NHI and the tunneled
+  * bridges.
+  */
+ static void quirk_apple_wait_for_thunderbolt(struct pci_dev *dev)
+ {
+ 	struct pci_dev *sibling = NULL;
+ 	struct pci_dev *nhi = NULL;
+ 
+ 	if (!dmi_match(DMI_BOARD_VENDOR, "Apple Inc."))
+ 		return;
+ 	if (pci_pcie_type(dev) != PCI_EXP_TYPE_DOWNSTREAM)
+ 		return;
+ 	/*
+ 	 * Find the NHI and confirm that we are a bridge on the tb host
+ 	 * controller and not on a tb endpoint.
+ 	 */
+ 	sibling = pci_get_slot(dev->bus, 0x0);
+ 	if (sibling == dev)
+ 		goto out; /* we are the downstream bridge to the NHI */
+ 	if (!sibling || !sibling->subordinate)
+ 		goto out;
+ 	nhi = pci_get_slot(sibling->subordinate, 0x0);
+ 	if (!nhi)
+ 		goto out;
+ 	if (nhi->vendor != PCI_VENDOR_ID_INTEL
+ 		    || (nhi->device != PCI_DEVICE_ID_INTEL_CACTUS_RIDGE_4C &&
+ 			nhi->device != PCI_DEVICE_ID_INTEL_FALCON_RIDGE_4C_NHI)
+ 		    || nhi->subsystem_vendor != 0x2222
+ 		    || nhi->subsystem_device != 0x1111)
+ 		goto out;
+ 	dev_info(&dev->dev, "quirk: waiting for thunderbolt to reestablish PCI tunnels...\n");
+ 	device_pm_wait_for_dev(&dev->dev, &nhi->dev);
+ out:
+ 	pci_dev_put(nhi);
+ 	pci_dev_put(sibling);
+ }
+ DECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_INTEL,
+ 			       PCI_DEVICE_ID_INTEL_CACTUS_RIDGE_4C,
+ 			       quirk_apple_wait_for_thunderbolt);
+ DECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_INTEL,
+ 			       PCI_DEVICE_ID_INTEL_FALCON_RIDGE_4C_BRIDGE,
+ 			       quirk_apple_wait_for_thunderbolt);
+ #endif
++>>>>>>> 1d111406c6d9 (PCI: Add Intel Thunderbolt device IDs)
  
  static void pci_do_fixups(struct pci_dev *dev, struct pci_fixup *f,
  			  struct pci_fixup *end)
* Unmerged path drivers/thunderbolt/nhi.c
* Unmerged path drivers/thunderbolt/switch.c
* Unmerged path drivers/pci/quirks.c
* Unmerged path drivers/thunderbolt/nhi.c
* Unmerged path drivers/thunderbolt/switch.c
diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h
index 525373074111..d040f457dc0e 100644
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -2610,6 +2610,24 @@
 #define PCI_DEVICE_ID_INTEL_82441	0x1237
 #define PCI_DEVICE_ID_INTEL_82380FB	0x124b
 #define PCI_DEVICE_ID_INTEL_82439	0x1250
+#define PCI_DEVICE_ID_INTEL_LIGHT_RIDGE             0x1513 /* Tbt 1 Gen 1 */
+#define PCI_DEVICE_ID_INTEL_EAGLE_RIDGE             0x151a
+#define PCI_DEVICE_ID_INTEL_LIGHT_PEAK              0x151b
+#define PCI_DEVICE_ID_INTEL_CACTUS_RIDGE_4C         0x1547 /* Tbt 1 Gen 2 */
+#define PCI_DEVICE_ID_INTEL_CACTUS_RIDGE_2C         0x1548
+#define PCI_DEVICE_ID_INTEL_PORT_RIDGE              0x1549
+#define PCI_DEVICE_ID_INTEL_REDWOOD_RIDGE_2C_NHI    0x1566 /* Tbt 1 Gen 3 */
+#define PCI_DEVICE_ID_INTEL_REDWOOD_RIDGE_2C_BRIDGE 0x1567
+#define PCI_DEVICE_ID_INTEL_REDWOOD_RIDGE_4C_NHI    0x1568
+#define PCI_DEVICE_ID_INTEL_REDWOOD_RIDGE_4C_BRIDGE 0x1569
+#define PCI_DEVICE_ID_INTEL_FALCON_RIDGE_2C_NHI     0x156a /* Thunderbolt 2 */
+#define PCI_DEVICE_ID_INTEL_FALCON_RIDGE_2C_BRIDGE  0x156b
+#define PCI_DEVICE_ID_INTEL_FALCON_RIDGE_4C_NHI     0x156c
+#define PCI_DEVICE_ID_INTEL_FALCON_RIDGE_4C_BRIDGE  0x156d
+#define PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_2C_NHI     0x1575 /* Thunderbolt 3 */
+#define PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_2C_BRIDGE  0x1576
+#define PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_4C_NHI     0x1577
+#define PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_4C_BRIDGE  0x1578
 #define PCI_DEVICE_ID_INTEL_80960_RP	0x1960
 #define PCI_DEVICE_ID_INTEL_82840_HB	0x1a21
 #define PCI_DEVICE_ID_INTEL_82845_HB	0x1a30
