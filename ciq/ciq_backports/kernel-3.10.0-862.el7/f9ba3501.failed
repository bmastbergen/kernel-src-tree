sctp: change to save MSG_MORE flag into assoc

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Xin Long <lucien.xin@gmail.com>
commit f9ba3501d50317697811ff3c48f623f08d616fc8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f9ba3501.failed

David Laight noticed the support for MSG_MORE with datamsg->force_delay
didn't really work as we expected, as the first msg with MSG_MORE set
would always block the following chunks' dequeuing.

This Patch is to rewrite it by saving the MSG_MORE flag into assoc as
David Laight suggested.

asoc->force_delay is used to save MSG_MORE flag before a msg is sent.
All chunks in queue would not be sent out if asoc->force_delay is set
by the msg with MSG_MORE flag, until a new msg without MSG_MORE flag
clears asoc->force_delay.

Note that this change would not affect the flush is generated by other
triggers, like asoc->state != ESTABLISHED, queue size > pmtu etc.

v1->v2:
  Not clear asoc->force_delay after sending the msg with MSG_MORE flag.

Fixes: 4ea0c32f5f42 ("sctp: add support for MSG_MORE")
	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Acked-by: David Laight <david.laight@aculab.com>
	Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f9ba3501d50317697811ff3c48f623f08d616fc8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/sctp/structs.h
diff --cc include/net/sctp/structs.h
index 13ec29baff97,8caa5ee9e290..000000000000
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@@ -1891,7 -1877,17 +1890,21 @@@ struct sctp_association 
  
  	__u8 need_ecne:1,	/* Need to send an ECNE Chunk? */
  	     temp:1,		/* Is it a temporary association? */
++<<<<<<< HEAD
 +	     prsctp_enable:1;
++=======
+ 	     force_delay:1,
+ 	     prsctp_enable:1,
+ 	     reconf_enable:1;
+ 
+ 	__u8 strreset_enable;
+ 	__u8 strreset_outstanding; /* request param count on the fly */
+ 
+ 	__u32 strreset_outseq; /* Update after receiving response */
+ 	__u32 strreset_inseq; /* Update after receiving request */
+ 
+ 	struct sctp_chunk *strreset_chunk; /* save request chunk */
++>>>>>>> f9ba3501d503 (sctp: change to save MSG_MORE flag into assoc)
  
  	struct sctp_priv_assoc_stats stats;
  
* Unmerged path include/net/sctp/structs.h
diff --git a/net/sctp/output.c b/net/sctp/output.c
index 16f21de6025f..e272471d0b84 100644
--- a/net/sctp/output.c
+++ b/net/sctp/output.c
@@ -834,7 +834,7 @@ static sctp_xmit_t sctp_packet_can_append_data(struct sctp_packet *packet,
 	 */
 
 	if ((sctp_sk(asoc->base.sk)->nodelay || inflight == 0) &&
-	    !chunk->msg->force_delay)
+	    !asoc->force_delay)
 		/* Nothing unacked */
 		return SCTP_XMIT_OK;
 
diff --git a/net/sctp/socket.c b/net/sctp/socket.c
index b99c2d63b533..daad6564ef73 100644
--- a/net/sctp/socket.c
+++ b/net/sctp/socket.c
@@ -1973,7 +1973,7 @@ static int sctp_sendmsg(struct kiocb *iocb, struct sock *sk,
 		err = PTR_ERR(datamsg);
 		goto out_free;
 	}
-	datamsg->force_delay = !!(msg->msg_flags & MSG_MORE);
+	asoc->force_delay = !!(msg->msg_flags & MSG_MORE);
 
 	/* Now send the (possibly) fragmented message. */
 	list_for_each_entry(chunk, &datamsg->chunks, frag_list) {
