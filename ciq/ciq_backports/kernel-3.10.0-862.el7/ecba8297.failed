KVM: PPC: Book3S HV: Always flush TLB in kvmppc_alloc_reset_hpt()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [powerpc] kvm: book3s hv: Always flush TLB in kvmppc_alloc_reset_hpt() (David Gibson) [1528958]
Rebuild_FUZZ: 96.00%
commit-author David Gibson <david@gibson.dropbear.id.au>
commit ecba8297aafd50db6ae867e90844eead1611ef1c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ecba8297.failed

The KVM_PPC_ALLOCATE_HTAB ioctl(), implemented by kvmppc_alloc_reset_hpt()
is supposed to completely clear and reset a guest's Hashed Page Table (HPT)
allocating or re-allocating it if necessary.

In the case where an HPT of the right size already exists and it just
zeroes it, it forces a TLB flush on all guest CPUs, to remove any stale TLB
entries loaded from the old HPT.

However, that situation can arise when the HPT is resizing as well - or
even when switching from an RPT to HPT - so those cases need a TLB flush as
well.

So, move the TLB flush to trigger in all cases except for errors.

	Cc: stable@vger.kernel.org # v4.10+
Fixes: f98a8bf9ee20 ("KVM: PPC: Book3S HV: Allow KVM_PPC_ALLOCATE_HTAB ioctl() to change HPT size")
	Signed-off-by: David Gibson <david@gibson.dropbear.id.au>
	Signed-off-by: Paul Mackerras <paulus@ozlabs.org>
(cherry picked from commit ecba8297aafd50db6ae867e90844eead1611ef1c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kvm/book3s_64_mmu_hv.c
diff --cc arch/powerpc/kvm/book3s_64_mmu_hv.c
index 283e37e10f56,b73dbc9e797d..000000000000
--- a/arch/powerpc/kvm/book3s_64_mmu_hv.c
+++ b/arch/powerpc/kvm/book3s_64_mmu_hv.c
@@@ -136,15 -165,25 +136,37 @@@ long kvmppc_alloc_reset_hpt(struct kvm 
  		 * Reset all the reverse-mapping chains for all memslots
  		 */
  		kvmppc_rmap_reset(kvm);
++<<<<<<< HEAD
 +		/* Ensure that each vcpu will flush its TLB on next entry. */
 +		cpumask_setall(&kvm->arch.need_tlb_flush);
 +		*htab_orderp = order;
++=======
++>>>>>>> ecba8297aafd (KVM: PPC: Book3S HV: Always flush TLB in kvmppc_alloc_reset_hpt())
  		err = 0;
 -		goto out;
 +	} else {
 +		err = kvmppc_alloc_hpt(kvm, htab_orderp);
 +		order = *htab_orderp;
  	}
++<<<<<<< HEAD
 + out:
++=======
+ 
+ 	if (kvm->arch.hpt.virt) {
+ 		kvmppc_free_hpt(&kvm->arch.hpt);
+ 		kvmppc_rmap_reset(kvm);
+ 	}
+ 
+ 	err = kvmppc_allocate_hpt(&info, order);
+ 	if (err < 0)
+ 		goto out;
+ 	kvmppc_set_hpt(kvm, &info);
+ 
+ out:
+ 	if (err == 0)
+ 		/* Ensure that each vcpu will flush its TLB on next entry. */
+ 		cpumask_setall(&kvm->arch.need_tlb_flush);
+ 
++>>>>>>> ecba8297aafd (KVM: PPC: Book3S HV: Always flush TLB in kvmppc_alloc_reset_hpt())
  	mutex_unlock(&kvm->lock);
  	return err;
  }
* Unmerged path arch/powerpc/kvm/book3s_64_mmu_hv.c
