qla2xxx: Fix sess_lock & hardware_lock lock order problem.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Fix sess_lock & hardware_lock lock order problem (Himanshu Madhani) [1460030]
Rebuild_FUZZ: 99.13%
commit-author Quinn Tran <quinn.tran@cavium.com>
commit f159b3c7cd45c550d0f73806451a10b6b6bc08ae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f159b3c7.failed

The main lock that needs to be held for CMD or TMR submission
to upper layer is the sess_lock. The sess_lock is used to
serialize cmd submission and session deletion. The addition
of hardware_lock being held is not necessary. This patch removes
hardware_lock dependency from CMD/TMR submission.

Use hardware_lock only for error response in this case.

Path1
       CPU0                    CPU1
       ----                    ----
  lock(&(&ha->tgt.sess_lock)->rlock);
                               lock(&(&ha->hardware_lock)->rlock);
                               lock(&(&ha->tgt.sess_lock)->rlock);
  lock(&(&ha->hardware_lock)->rlock);

Path2/deadlock
*** DEADLOCK ***
Call Trace:
dump_stack+0x85/0xc2
print_circular_bug+0x1e3/0x250
__lock_acquire+0x1425/0x1620
lock_acquire+0xbf/0x210
_raw_spin_lock_irqsave+0x53/0x70
qlt_sess_work_fn+0x21d/0x480 [qla2xxx]
process_one_work+0x1f4/0x6e0

	Cc: <stable@vger.kernel.org>
	Cc: Bart Van Assche <Bart.VanAssche@sandisk.com>
	Reported-by: Bart Van Assche <Bart.VanAssche@sandisk.com>
	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit f159b3c7cd45c550d0f73806451a10b6b6bc08ae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_target.c
diff --cc drivers/scsi/qla2xxx/qla_target.c
index f10c075d97ef,989f931af156..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -4150,36 -5704,46 +4150,56 @@@ static void qlt_abort_work(struct qla_t
  	sess = ha->tgt.tgt_ops->find_sess_by_s_id(vha,
  	    (unsigned char *)&be_s_id);
  	if (!sess) {
 -		spin_unlock_irqrestore(&ha->tgt.sess_lock, flags2);
 +		spin_unlock_irqrestore(&ha->hardware_lock, flags);
  
 +		mutex_lock(&ha->tgt.tgt_mutex);
  		sess = qlt_make_local_sess(vha, s_id);
  		/* sess has got an extra creation ref */
 +		mutex_unlock(&ha->tgt.tgt_mutex);
  
 -		spin_lock_irqsave(&ha->tgt.sess_lock, flags2);
 +		spin_lock_irqsave(&ha->hardware_lock, flags);
  		if (!sess)
 -			goto out_term2;
 +			goto out_term;
  	} else {
 -		if (sess->deleted) {
 -			sess = NULL;
 -			goto out_term2;
 -		}
 -
 -		if (!kref_get_unless_zero(&sess->sess_kref)) {
 -			ql_dbg(ql_dbg_tgt_tmr, vha, 0xffff,
 -			    "%s: kref_get fail %8phC \n",
 -			     __func__, sess->port_name);
 -			sess = NULL;
 -			goto out_term2;
 -		}
 +		kref_get(&sess->se_sess->sess_kref);
  	}
  
++<<<<<<< HEAD
 +	if (tgt->tgt_stop)
 +		goto out_term;
 +
++=======
++>>>>>>> f159b3c7cd45 (qla2xxx: Fix sess_lock & hardware_lock lock order problem.)
  	rc = __qlt_24xx_handle_abts(vha, &prm->abts, sess);
+ 	ha->tgt.tgt_ops->put_sess(sess);
+ 	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags2);
+ 
  	if (rc != 0)
  		goto out_term;
++<<<<<<< HEAD
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +
 +	ha->tgt.tgt_ops->put_sess(sess);
 +	return;
 +
 +out_term:
 +	qlt_24xx_send_abts_resp(vha, &prm->abts, FCP_TMF_REJECTED, false);
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +	if (sess)
 +		ha->tgt.tgt_ops->put_sess(sess);
++=======
+ 	return;
+ 
+ out_term2:
+ 	if (sess)
+ 		ha->tgt.tgt_ops->put_sess(sess);
+ 	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags2);
+ 
+ out_term:
+ 	spin_lock_irqsave(&ha->hardware_lock, flags);
+ 	qlt_24xx_send_abts_resp(vha, &prm->abts, FCP_TMF_REJECTED, false);
+ 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
++>>>>>>> f159b3c7cd45 (qla2xxx: Fix sess_lock & hardware_lock lock order problem.)
  }
  
  static void qlt_tmr_work(struct qla_tgt *tgt,
@@@ -4196,26 -5760,35 +4216,41 @@@
  	int fn;
  	void *iocb;
  
 -	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
 +	spin_lock_irqsave(&ha->hardware_lock, flags);
  
  	if (tgt->tgt_stop)
- 		goto out_term;
+ 		goto out_term2;
  
  	s_id = prm->tm_iocb2.u.isp24.fcp_hdr.s_id;
  	sess = ha->tgt.tgt_ops->find_sess_by_s_id(vha, s_id);
  	if (!sess) {
 -		spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
 +		spin_unlock_irqrestore(&ha->hardware_lock, flags);
  
 +		mutex_lock(&ha->tgt.tgt_mutex);
  		sess = qlt_make_local_sess(vha, s_id);
  		/* sess has got an extra creation ref */
 +		mutex_unlock(&ha->tgt.tgt_mutex);
  
 -		spin_lock_irqsave(&ha->tgt.sess_lock, flags);
 +		spin_lock_irqsave(&ha->hardware_lock, flags);
  		if (!sess)
- 			goto out_term;
+ 			goto out_term2;
  	} else {
++<<<<<<< HEAD
 +		kref_get(&sess->se_sess->sess_kref);
++=======
+ 		if (sess->deleted) {
+ 			sess = NULL;
+ 			goto out_term2;
+ 		}
+ 
+ 		if (!kref_get_unless_zero(&sess->sess_kref)) {
+ 			ql_dbg(ql_dbg_tgt_tmr, vha, 0xffff,
+ 			    "%s: kref_get fail %8phC\n",
+ 			     __func__, sess->port_name);
+ 			sess = NULL;
+ 			goto out_term2;
+ 		}
++>>>>>>> f159b3c7cd45 (qla2xxx: Fix sess_lock & hardware_lock lock order problem.)
  	}
  
  	iocb = a;
@@@ -4224,18 -5797,19 +4259,32 @@@
  	unpacked_lun = scsilun_to_int((struct scsi_lun *)&lun);
  
  	rc = qlt_issue_task_mgmt(sess, unpacked_lun, fn, iocb, 0);
+ 	ha->tgt.tgt_ops->put_sess(sess);
+ 	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ 
  	if (rc != 0)
  		goto out_term;
++<<<<<<< HEAD
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +
 +	ha->tgt.tgt_ops->put_sess(sess);
++=======
++>>>>>>> f159b3c7cd45 (qla2xxx: Fix sess_lock & hardware_lock lock order problem.)
  	return;
  
+ out_term2:
+ 	if (sess)
+ 		ha->tgt.tgt_ops->put_sess(sess);
+ 	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
  out_term:
++<<<<<<< HEAD
 +	qlt_send_term_exchange(vha, NULL, &prm->tm_iocb2, 1);
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +	if (sess)
 +		ha->tgt.tgt_ops->put_sess(sess);
++=======
+ 	qlt_send_term_exchange(vha, NULL, &prm->tm_iocb2, 1, 0);
++>>>>>>> f159b3c7cd45 (qla2xxx: Fix sess_lock & hardware_lock lock order problem.)
  }
  
  static void qlt_sess_work_fn(struct work_struct *work)
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
