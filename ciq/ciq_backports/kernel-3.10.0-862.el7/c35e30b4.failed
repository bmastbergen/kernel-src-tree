nvme: Add nvme_core.force_apst to ignore the NO_APST quirk

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [nvme] Add nvme_core.force_apst to ignore the NO_APST quirk (David Milburn) [1389600]
Rebuild_FUZZ: 94.55%
commit-author Andy Lutomirski <luto@kernel.org>
commit c35e30b4727b390ce7a6dd7ead31335320c2b83e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c35e30b4.failed

We're probably going to be stuck quirking APST off on an over-broad
range of devices for 4.11.  Let's make it easy to override the quirk
for testing.

	Signed-off-by: Andy Lutomirski <luto@kernel.org>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit c35e30b4727b390ce7a6dd7ead31335320c2b83e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
diff --cc drivers/nvme/host/core.c
index bd223cb63595,d5e0906262ea..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -56,6 -56,15 +56,18 @@@ EXPORT_SYMBOL_GPL(nvme_max_retries)
  static int nvme_char_major;
  module_param(nvme_char_major, int, 0);
  
++<<<<<<< HEAD
++=======
+ static unsigned long default_ps_max_latency_us = 25000;
+ module_param(default_ps_max_latency_us, ulong, 0644);
+ MODULE_PARM_DESC(default_ps_max_latency_us,
+ 		 "max power saving latency for new devices; use PM QOS to change per device");
+ 
+ static bool force_apst;
+ module_param(force_apst, bool, 0644);
+ MODULE_PARM_DESC(force_apst, "allow APST for newly enumerated devices even if quirked off");
+ 
++>>>>>>> c35e30b4727b (nvme: Add nvme_core.force_apst to ignore the NO_APST quirk)
  static LIST_HEAD(nvme_ctrl_list);
  static DEFINE_SPINLOCK(dev_list_lock);
  
@@@ -1201,6 -1548,30 +1213,33 @@@ int nvme_init_identify(struct nvme_ctr
  		return -EIO;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (!ctrl->identified) {
+ 		/*
+ 		 * Check for quirks.  Quirk can depend on firmware version,
+ 		 * so, in principle, the set of quirks present can change
+ 		 * across a reset.  As a possible future enhancement, we
+ 		 * could re-scan for quirks every time we reinitialize
+ 		 * the device, but we'd have to make sure that the driver
+ 		 * behaves intelligently if the quirks change.
+ 		 */
+ 
+ 		int i;
+ 
+ 		for (i = 0; i < ARRAY_SIZE(core_quirks); i++) {
+ 			if (quirk_matches(id, &core_quirks[i]))
+ 				ctrl->quirks |= core_quirks[i].quirks;
+ 		}
+ 	}
+ 
+ 	if (force_apst && (ctrl->quirks & NVME_QUIRK_NO_DEEPEST_PS)) {
+ 		dev_warn(ctrl->dev, "forcibly allowing all power states due to nvme_core.force_apst -- use at your own risk\n");
+ 		ctrl->quirks &= ~NVME_QUIRK_NO_DEEPEST_PS;
+ 	}
+ 
+ 	ctrl->oacs = le16_to_cpu(id->oacs);
++>>>>>>> c35e30b4727b (nvme: Add nvme_core.force_apst to ignore the NO_APST quirk)
  	ctrl->vid = le16_to_cpu(id->vid);
  	ctrl->oncs = le16_to_cpup(&id->oncs);
  	atomic_set(&ctrl->abort_limit, id->acl + 1);
@@@ -1220,6 -1591,20 +1259,23 @@@
  	ctrl->sgls = le32_to_cpu(id->sgls);
  	ctrl->kas = le16_to_cpu(id->kas);
  
++<<<<<<< HEAD
++=======
+ 	ctrl->npss = id->npss;
+ 	prev_apsta = ctrl->apsta;
+ 	if (ctrl->quirks & NVME_QUIRK_NO_APST) {
+ 		if (force_apst && id->apsta) {
+ 			dev_warn(ctrl->dev, "forcibly allowing APST due to nvme_core.force_apst -- use at your own risk\n");
+ 			ctrl->apsta = 1;
+ 		} else {
+ 			ctrl->apsta = 0;
+ 		}
+ 	} else {
+ 		ctrl->apsta = id->apsta;
+ 	}
+ 	memcpy(ctrl->psd, id->psd, sizeof(ctrl->psd));
+ 
++>>>>>>> c35e30b4727b (nvme: Add nvme_core.force_apst to ignore the NO_APST quirk)
  	if (ctrl->ops->is_fabrics) {
  		ctrl->icdoff = le16_to_cpu(id->icdoff);
  		ctrl->ioccsz = le32_to_cpu(id->ioccsz);
* Unmerged path drivers/nvme/host/core.c
