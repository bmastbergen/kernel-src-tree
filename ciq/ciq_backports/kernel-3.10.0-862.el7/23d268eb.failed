arp: honour gratuitous ARP _replies_

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ihar Hrachyshka <ihrachys@redhat.com>
commit 23d268eb240954e6e78f7cfab04f2b1e79f84489
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/23d268eb.failed

When arp_accept is 1, gratuitous ARPs are supposed to override matching
entries irrespective of whether they arrive during locktime. This was
implemented in commit 56022a8fdd87 ("ipv4: arp: update neighbour address
when a gratuitous arp is received and arp_accept is set")

There is a glitch in the patch though. RFC 2002, section 4.6, "ARP,
Proxy ARP, and Gratuitous ARP", defines gratuitous ARPs so that they can
be either of Request or Reply type. Those Reply gratuitous ARPs can be
triggered with standard tooling, for example, arping -A option does just
that.

This patch fixes the glitch, making both Request and Reply flavours of
gratuitous ARPs to behave identically.

As per RFC, if gratuitous ARPs are of Reply type, their Target Hardware
Address field should also be set to the link-layer address to which this
cache entry should be updated. The field is present in ARP over Ethernet
but not in IEEE 1394. In this patch, I don't consider any broadcasted
ARP replies as gratuitous if the field is not present, to conform the
standard. It's not clear whether there is such a thing for IEEE 1394 as
a gratuitous ARP reply; until it's cleared up, we will ignore such
broadcasts. Note that they will still update existing ARP cache entries,
assuming they arrive out of locktime time interval.

	Signed-off-by: Ihar Hrachyshka <ihrachys@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 23d268eb240954e6e78f7cfab04f2b1e79f84489)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/arp.c
diff --cc net/ipv4/arp.c
index 98def2add661,d54345a06f72..000000000000
--- a/net/ipv4/arp.c
+++ b/net/ipv4/arp.c
@@@ -919,10 -844,22 +921,29 @@@ static int arp_process(struct sock *sk
  		   It is possible, that this option should be enabled for some
  		   devices (strip is candidate)
  		 */
++<<<<<<< HEAD
 +		if (n == NULL &&
 +		    (arp->ar_op == htons(ARPOP_REPLY) ||
 +		     (arp->ar_op == htons(ARPOP_REQUEST) && tip == sip)) &&
 +		    inet_addr_type(net, sip) == RTN_UNICAST)
++=======
+ 		is_garp = tip == sip && addr_type == RTN_UNICAST;
+ 
+ 		/* Unsolicited ARP _replies_ also require target hwaddr to be
+ 		 * the same as source.
+ 		 */
+ 		if (is_garp && arp->ar_op == htons(ARPOP_REPLY))
+ 			is_garp =
+ 				/* IPv4 over IEEE 1394 doesn't provide target
+ 				 * hardware address field in its ARP payload.
+ 				 */
+ 				tha &&
+ 				!memcmp(tha, sha, dev->addr_len);
+ 
+ 		if (!n &&
+ 		    ((arp->ar_op == htons(ARPOP_REPLY)  &&
+ 				addr_type == RTN_UNICAST) || is_garp))
++>>>>>>> 23d268eb2409 (arp: honour gratuitous ARP _replies_)
  			n = __neigh_lookup(&arp_tbl, &sip, dev, 1);
  	}
  
* Unmerged path net/ipv4/arp.c
