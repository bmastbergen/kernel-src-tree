x86/platform/UV: Add check of TSC state set by UV BIOS

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] platform/uv: Add check of TSC state set by UV BIOS (Frank Ramsay) [1526066]
Rebuild_FUZZ: 96.15%
commit-author mike.travis@hpe.com <mike.travis@hpe.com>
commit 97d21003df3e7504c899b1701546f18ff475966f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/97d21003.failed

Insert a check early in UV system startup that checks whether BIOS was
able to obtain satisfactory TSC Sync stability.  If not, it usually
is caused by an error in the external TSC clock generation source.
In this case the best fallback is to use the builtin hardware RTC
as the kernel will not be able to set an accurate TSC sync either.

	Signed-off-by: Mike Travis <mike.travis@hpe.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Dimitri Sivanich <dimitri.sivanich@hpe.com>
	Reviewed-by: Russ Anderson <russ.anderson@hpe.com>
	Reviewed-by: Andrew Banman <andrew.abanman@hpe.com>
	Cc: Prarit Bhargava <prarit@redhat.com>
	Cc: Andrew Banman <andrew.banman@hpe.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Bin Gao <bin.gao@linux.intel.com>
Link: https://lkml.kernel.org/r/20171012163202.406294490@stormcage.americas.sgi.com

(cherry picked from commit 97d21003df3e7504c899b1701546f18ff475966f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/apic/x2apic_uv_x.c
diff --cc arch/x86/kernel/apic/x2apic_uv_x.c
index dd27b8dad976,440825478bbd..000000000000
--- a/arch/x86/kernel/apic/x2apic_uv_x.c
+++ b/arch/x86/kernel/apic/x2apic_uv_x.c
@@@ -152,11 -154,54 +152,62 @@@ static int __init early_get_pnodeid(voi
  	return pnode;
  }
  
++<<<<<<< HEAD
 +/* [copied from arch/x86/kernel/cpu/topology.c:detect_extended_topology()] */
 +#define SMT_LEVEL	0	/* leaf 0xb SMT level */
 +#define INVALID_TYPE	0	/* leaf 0xb sub-leaf types */
 +#define SMT_TYPE	1
 +#define CORE_TYPE	2
++=======
+ static void uv_tsc_check_sync(void)
+ {
+ 	u64 mmr;
+ 	int sync_state;
+ 	int mmr_shift;
+ 	char *state;
+ 	bool valid;
+ 
+ 	/* Accommodate different UV arch BIOSes */
+ 	mmr = uv_early_read_mmr(UVH_TSC_SYNC_MMR);
+ 	mmr_shift =
+ 		is_uv1_hub() ? 0 :
+ 		is_uv2_hub() ? UVH_TSC_SYNC_SHIFT_UV2K : UVH_TSC_SYNC_SHIFT;
+ 	if (mmr_shift)
+ 		sync_state = (mmr >> mmr_shift) & UVH_TSC_SYNC_MASK;
+ 	else
+ 		sync_state = 0;
+ 
+ 	switch (sync_state) {
+ 	case UVH_TSC_SYNC_VALID:
+ 		state = "in sync";
+ 		valid = true;
+ 		break;
+ 
+ 	case UVH_TSC_SYNC_INVALID:
+ 		state = "unstable";
+ 		valid = false;
+ 		break;
+ 	default:
+ 		state = "unknown: assuming valid";
+ 		valid = true;
+ 		break;
+ 	}
+ 	pr_info("UV: TSC sync state from BIOS:0%d(%s)\n", sync_state, state);
+ 
+ 	/* Mark flag that says TSC != 0 is valid for socket 0 */
+ 	if (valid)
+ 		mark_tsc_async_resets("UV BIOS");
+ 	else
+ 		mark_tsc_unstable("UV BIOS");
+ }
+ 
+ /* [Copied from arch/x86/kernel/cpu/topology.c:detect_extended_topology()] */
+ 
+ #define SMT_LEVEL			0	/* Leaf 0xb SMT level */
+ #define INVALID_TYPE			0	/* Leaf 0xb sub-leaf types */
+ #define SMT_TYPE			1
+ #define CORE_TYPE			2
++>>>>>>> 97d21003df3e (x86/platform/UV: Add check of TSC state set by UV BIOS)
  #define LEAFB_SUBTYPE(ecx)		(((ecx) >> 8) & 0xff)
  #define BITS_SHIFT_NEXT_LEVEL(eax)	((eax) & 0x1f)
  
@@@ -282,9 -329,8 +333,14 @@@ static int __init uv_acpi_madt_oem_chec
  		goto badbios;
  	}
  
++<<<<<<< HEAD
 +	pr_info("UV: OEM IDs %s/%s, System/HUB Types %d/%d, uv_apic %d\n",
 +		oem_id, oem_table_id, uv_system_type,
 +		uv_min_hub_revision_id, uv_apic);
++=======
+ 	pr_info("UV: OEM IDs %s/%s, System/HUB Types %d/%d, uv_apic %d\n", oem_id, oem_table_id, uv_system_type, uv_min_hub_revision_id, uv_apic);
+ 	uv_tsc_check_sync();
++>>>>>>> 97d21003df3e (x86/platform/UV: Add check of TSC state set by UV BIOS)
  
  	return uv_apic;
  
diff --git a/arch/x86/include/asm/uv/uv_hub.h b/arch/x86/include/asm/uv/uv_hub.h
index 513b51c83e40..bd959b4918ca 100644
--- a/arch/x86/include/asm/uv/uv_hub.h
+++ b/arch/x86/include/asm/uv/uv_hub.h
@@ -790,23 +790,36 @@ static inline int uv_num_possible_blades(void)
 extern void uv_nmi_setup(void);
 extern void uv_nmi_setup_hubless(void);
 
+/* BIOS/Kernel flags exchange MMR */
+#define UVH_BIOS_KERNEL_MMR		UVH_SCRATCH5
+#define UVH_BIOS_KERNEL_MMR_ALIAS	UVH_SCRATCH5_ALIAS
+#define UVH_BIOS_KERNEL_MMR_ALIAS_2	UVH_SCRATCH5_ALIAS_2
+
+/* TSC sync valid, set by BIOS */
+#define UVH_TSC_SYNC_MMR	UVH_BIOS_KERNEL_MMR
+#define UVH_TSC_SYNC_SHIFT	10
+#define UVH_TSC_SYNC_SHIFT_UV2K	16	/* UV2/3k have different bits */
+#define UVH_TSC_SYNC_MASK	3	/* 0011 */
+#define UVH_TSC_SYNC_VALID	3	/* 0011 */
+#define UVH_TSC_SYNC_INVALID	2	/* 0010 */
+
 /* BMC sets a bit this MMR non-zero before sending an NMI */
-#define UVH_NMI_MMR		UVH_SCRATCH5
-#define UVH_NMI_MMR_CLEAR	UVH_SCRATCH5_ALIAS
+#define UVH_NMI_MMR		UVH_BIOS_KERNEL_MMR
+#define UVH_NMI_MMR_CLEAR	UVH_BIOS_KERNEL_MMR_ALIAS
 #define UVH_NMI_MMR_SHIFT	63
-#define	UVH_NMI_MMR_TYPE	"SCRATCH5"
+#define UVH_NMI_MMR_TYPE	"SCRATCH5"
 
 /* Newer SMM NMI handler, not present in all systems */
 #define UVH_NMI_MMRX		UVH_EVENT_OCCURRED0
 #define UVH_NMI_MMRX_CLEAR	UVH_EVENT_OCCURRED0_ALIAS
 #define UVH_NMI_MMRX_SHIFT	UVH_EVENT_OCCURRED0_EXTIO_INT0_SHFT
-#define	UVH_NMI_MMRX_TYPE	"EXTIO_INT0"
+#define UVH_NMI_MMRX_TYPE	"EXTIO_INT0"
 
 /* Non-zero indicates newer SMM NMI handler present */
 #define UVH_NMI_MMRX_SUPPORTED	UVH_EXTIO_INT0_BROADCAST
 
 /* Indicates to BIOS that we want to use the newer SMM NMI handler */
-#define UVH_NMI_MMRX_REQ	UVH_SCRATCH5_ALIAS_2
+#define UVH_NMI_MMRX_REQ	UVH_BIOS_KERNEL_MMR_ALIAS_2
 #define UVH_NMI_MMRX_REQ_SHIFT	62
 
 struct uv_hub_nmi_s {
* Unmerged path arch/x86/kernel/apic/x2apic_uv_x.c
