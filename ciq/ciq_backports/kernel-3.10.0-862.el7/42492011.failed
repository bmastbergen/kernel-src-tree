IB/hfi1: Assign context does not clean up file descriptor correctly on error

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Michael J. Ruhl <michael.j.ruhl@intel.com>
commit 42492011ab23f44c63dad0c7096492313dc207e3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/42492011.failed

In the error path for context allocation, the file descriptor pointer
should not point to a context when an error occurs.

Clean up the appropriate references on error.

Fixes: Commit 62239fc6e5545b2e59f83dfbc5db231a81f37a45 ("IB/hfi1: Clean up on context initialization failure")
	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Signed-off-by: Michael J. Ruhl <michael.j.ruhl@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 42492011ab23f44c63dad0c7096492313dc207e3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/file_ops.c
diff --cc drivers/infiniband/hw/hfi1/file_ops.c
index 32dd4a920494,d36e17722e6d..000000000000
--- a/drivers/infiniband/hw/hfi1/file_ops.c
+++ b/drivers/infiniband/hw/hfi1/file_ops.c
@@@ -70,31 -71,38 +70,60 @@@
  /*
   * File operation functions
   */
 -static int hfi1_file_open(struct inode *inode, struct file *fp);
 -static int hfi1_file_close(struct inode *inode, struct file *fp);
 -static ssize_t hfi1_write_iter(struct kiocb *kiocb, struct iov_iter *from);
 -static unsigned int hfi1_poll(struct file *fp, struct poll_table_struct *pt);
 -static int hfi1_file_mmap(struct file *fp, struct vm_area_struct *vma);
 -
 +static int hfi1_file_open(struct inode *, struct file *);
 +static int hfi1_file_close(struct inode *, struct file *);
 +static ssize_t hfi1_aio_write(struct kiocb *, const struct iovec *,
 +			      unsigned long, loff_t);
 +static unsigned int hfi1_poll(struct file *, struct poll_table_struct *);
 +static int hfi1_file_mmap(struct file *, struct vm_area_struct *);
 +
++<<<<<<< HEAD
 +static u64 kvirt_to_phys(void *);
 +static int assign_ctxt(struct file *, struct hfi1_user_info *);
 +static int init_subctxts(struct hfi1_ctxtdata *, const struct hfi1_user_info *);
 +static int user_init(struct file *);
 +static int get_ctxt_info(struct file *, void __user *, __u32);
 +static int get_base_info(struct file *, void __user *, __u32);
 +static int setup_ctxt(struct file *);
 +static int setup_subctxt(struct hfi1_ctxtdata *);
 +static int get_user_context(struct file *, struct hfi1_user_info *, int);
 +static int find_shared_ctxt(struct file *, const struct hfi1_user_info *);
 +static int allocate_ctxt(struct file *, struct hfi1_devdata *,
 +			 struct hfi1_user_info *);
 +static unsigned int poll_urgent(struct file *, struct poll_table_struct *);
 +static unsigned int poll_next(struct file *, struct poll_table_struct *);
 +static int user_event_ack(struct hfi1_ctxtdata *, int, unsigned long);
 +static int set_ctxt_pkey(struct hfi1_ctxtdata *, unsigned, u16);
 +static int manage_rcvq(struct hfi1_ctxtdata *, unsigned, int);
 +static int vma_fault(struct vm_area_struct *, struct vm_fault *);
++=======
+ static u64 kvirt_to_phys(void *addr);
+ static int assign_ctxt(struct hfi1_filedata *fd, struct hfi1_user_info *uinfo);
+ static int init_subctxts(struct hfi1_ctxtdata *uctxt,
+ 			 const struct hfi1_user_info *uinfo);
+ static int init_user_ctxt(struct hfi1_filedata *fd);
+ static void user_init(struct hfi1_ctxtdata *uctxt);
+ static int get_ctxt_info(struct hfi1_filedata *fd, void __user *ubase,
+ 			 __u32 len);
+ static int get_base_info(struct hfi1_filedata *fd, void __user *ubase,
+ 			 __u32 len);
+ static int setup_base_ctxt(struct hfi1_filedata *fd);
+ static int setup_subctxt(struct hfi1_ctxtdata *uctxt);
+ 
+ static int find_sub_ctxt(struct hfi1_filedata *fd,
+ 			 const struct hfi1_user_info *uinfo);
+ static int allocate_ctxt(struct hfi1_filedata *fd, struct hfi1_devdata *dd,
+ 			 struct hfi1_user_info *uinfo);
+ static void deallocate_ctxt(struct hfi1_ctxtdata *uctxt);
+ static unsigned int poll_urgent(struct file *fp, struct poll_table_struct *pt);
+ static unsigned int poll_next(struct file *fp, struct poll_table_struct *pt);
+ static int user_event_ack(struct hfi1_ctxtdata *uctxt, u16 subctxt,
+ 			  unsigned long events);
+ static int set_ctxt_pkey(struct hfi1_ctxtdata *uctxt, u16 subctxt, u16 pkey);
+ static int manage_rcvq(struct hfi1_ctxtdata *uctxt, u16 subctxt,
+ 		       int start_stop);
+ static int vma_fault(struct vm_fault *vmf);
++>>>>>>> 42492011ab23 (IB/hfi1: Assign context does not clean up file descriptor correctly on error)
  static long hfi1_file_ioctl(struct file *fp, unsigned int cmd,
  			    unsigned long arg);
  
@@@ -807,12 -814,9 +836,18 @@@ static int hfi1_file_close(struct inod
  	uctxt->rcvnowait = 0;
  	uctxt->pionowait = 0;
  	uctxt->event_flags = 0;
++<<<<<<< HEAD
 +
 +	hfi1_stats.sps_ctxts--;
 +	if (++dd->freectxts == dd->num_user_contexts)
 +		aspm_enable_all(dd);
 +	mutex_unlock(&hfi1_mutex);
 +	hfi1_free_ctxtdata(dd, uctxt);
++=======
+ 	mutex_unlock(&hfi1_mutex);
+ 
+ 	deallocate_ctxt(uctxt);
++>>>>>>> 42492011ab23 (IB/hfi1: Assign context does not clean up file descriptor correctly on error)
  done:
  	mmdrop(fdata->mm);
  	kobject_put(&dd->kobj);
@@@ -868,16 -869,58 +903,66 @@@ static int assign_ctxt(struct file *fp
  	}
  
  	/*
 -	 * Allocate a base context if context sharing is not required or we
 -	 * couldn't find a sub context.
 +	 * We execute the following block if we couldn't find a
 +	 * shared context or if context sharing is not required.
  	 */
++<<<<<<< HEAD
 +	if (!ret) {
 +		i_minor = iminor(file_inode(fp)) - HFI1_USER_MINOR_BASE;
 +		ret = get_user_context(fp, uinfo, i_minor);
++=======
+ 	if (!ret)
+ 		ret = allocate_ctxt(fd, fd->dd, uinfo);
+ 
+ 	mutex_unlock(&hfi1_mutex);
+ 
+ 	/* Depending on the context type, do the appropriate init */
+ 	if (ret > 0) {
+ 		/*
+ 		 * sub-context info can only be set up after the base
+ 		 * context has been completed.
+ 		 */
+ 		ret = wait_event_interruptible(fd->uctxt->wait, !test_bit(
+ 					       HFI1_CTXT_BASE_UNINIT,
+ 					       &fd->uctxt->event_flags));
+ 		if (test_bit(HFI1_CTXT_BASE_FAILED, &fd->uctxt->event_flags))
+ 			ret = -ENOMEM;
+ 
+ 		/* The only thing a sub context needs is the user_xxx stuff */
+ 		if (!ret)
+ 			ret = init_user_ctxt(fd);
+ 
+ 		if (ret)
+ 			clear_bit(fd->subctxt, fd->uctxt->in_use_ctxts);
+ 
+ 	} else if (!ret) {
+ 		ret = setup_base_ctxt(fd);
+ 		if (fd->uctxt->subctxt_cnt) {
+ 			/* If there is an error, set the failed bit. */
+ 			if (ret)
+ 				set_bit(HFI1_CTXT_BASE_FAILED,
+ 					&fd->uctxt->event_flags);
+ 			/*
+ 			 * Base context is done, notify anybody using a
+ 			 * sub-context that is waiting for this completion
+ 			 */
+ 			clear_bit(HFI1_CTXT_BASE_UNINIT,
+ 				  &fd->uctxt->event_flags);
+ 			wake_up(&fd->uctxt->wait);
+ 		}
+ 		if (ret)
+ 			deallocate_ctxt(fd->uctxt);
+ 	}
+ 
+ 	/* If an error occurred, clear the reference */
+ 	if (ret && fd->uctxt) {
+ 		hfi1_rcd_put(fd->uctxt);
+ 		fd->uctxt = NULL;
++>>>>>>> 42492011ab23 (IB/hfi1: Assign context does not clean up file descriptor correctly on error)
  	}
 -
 +done_unlock:
 +	mutex_unlock(&hfi1_mutex);
 +done:
  	return ret;
  }
  
* Unmerged path drivers/infiniband/hw/hfi1/file_ops.c
