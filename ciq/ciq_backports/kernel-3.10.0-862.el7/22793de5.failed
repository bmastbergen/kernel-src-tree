target: Convert core_tpg_deregister to use list splice

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [target] Convert core_tpg_deregister to use list splice (Maurizio Lombardi) [1366062]
Rebuild_FUZZ: 92.00%
commit-author Nicholas Bellinger <nab@linux-iscsi.org>
commit 22793de590ca23a1e49b0ce5353911121fcc32be
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/22793de5.failed

This patch converts core_tpg_deregister() to perform a list splice
for any remaining dynamically generated se_node_acls attached to
se_tpg, before calling kfree(nacl) to free memory.

	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 22793de590ca23a1e49b0ce5353911121fcc32be)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_tpg.c
diff --cc drivers/target/target_core_tpg.c
index 0696de9553d3,e7745d21075b..000000000000
--- a/drivers/target/target_core_tpg.c
+++ b/drivers/target/target_core_tpg.c
@@@ -738,14 -545,14 +738,15 @@@ EXPORT_SYMBOL(core_tpg_register)
  
  int core_tpg_deregister(struct se_portal_group *se_tpg)
  {
 -	const struct target_core_fabric_ops *tfo = se_tpg->se_tpg_tfo;
  	struct se_node_acl *nacl, *nacl_tmp;
+ 	LIST_HEAD(node_list);
  
 -	pr_debug("TARGET_CORE[%s]: Deallocating portal_group for endpoint: %s, "
 -		 "Proto: %d, Portal Tag: %u\n", tfo->get_fabric_name(),
 -		tfo->tpg_get_wwn(se_tpg) ? tfo->tpg_get_wwn(se_tpg) : NULL,
 -		se_tpg->proto_id, tfo->tpg_get_tag(se_tpg));
 +	pr_debug("TARGET_CORE[%s]: Deallocating %s struct se_portal_group"
 +		" for endpoint: %s Portal Tag %u\n",
 +		(se_tpg->se_tpg_type == TRANSPORT_TPG_TYPE_NORMAL) ?
 +		"Normal" : "Discovery", se_tpg->se_tpg_tfo->get_fabric_name(),
 +		se_tpg->se_tpg_tfo->tpg_get_wwn(se_tpg),
 +		se_tpg->se_tpg_tfo->tpg_get_tag(se_tpg));
  
  	spin_lock_bh(&tpg_lock);
  	list_del(&se_tpg->se_tpg_node);
@@@ -753,31 -560,27 +754,49 @@@
  
  	while (atomic_read(&se_tpg->tpg_pr_ref_count) != 0)
  		cpu_relax();
++<<<<<<< HEAD
++=======
+ 
+ 	mutex_lock(&se_tpg->acl_node_mutex);
+ 	list_splice_init(&se_tpg->acl_node_list, &node_list);
+ 	mutex_unlock(&se_tpg->acl_node_mutex);
++>>>>>>> 22793de590ca (target: Convert core_tpg_deregister to use list splice)
  	/*
  	 * Release any remaining demo-mode generated se_node_acl that have
  	 * not been released because of TFO->tpg_check_demo_mode_cache() == 1
  	 * in transport_deregister_session().
  	 */
++<<<<<<< HEAD
 +	spin_lock_irq(&se_tpg->acl_node_lock);
 +	list_for_each_entry_safe(nacl, nacl_tmp, &se_tpg->acl_node_list,
 +			acl_list) {
 +		list_del(&nacl->acl_list);
 +		se_tpg->num_node_acls--;
 +		spin_unlock_irq(&se_tpg->acl_node_lock);
 +
 +		core_tpg_wait_for_nacl_pr_ref(nacl);
 +		core_free_device_list_for_node(nacl, se_tpg);
 +		se_tpg->se_tpg_tfo->tpg_release_fabric_acl(se_tpg, nacl);
 +
 +		spin_lock_irq(&se_tpg->acl_node_lock);
 +	}
 +	spin_unlock_irq(&se_tpg->acl_node_lock);
++=======
+ 	list_for_each_entry_safe(nacl, nacl_tmp, &node_list, acl_list) {
+ 		list_del(&nacl->acl_list);
+ 		se_tpg->num_node_acls--;
+ 
+ 		core_tpg_wait_for_nacl_pr_ref(nacl);
+ 		core_free_device_list_for_node(nacl, se_tpg);
+ 		kfree(nacl);
+ 	}
++>>>>>>> 22793de590ca (target: Convert core_tpg_deregister to use list splice)
  
 -	if (se_tpg->proto_id >= 0)
 +	if (se_tpg->se_tpg_type == TRANSPORT_TPG_TYPE_NORMAL)
  		core_tpg_remove_lun(se_tpg, &se_tpg->tpg_virt_lun0);
  
 +	se_tpg->se_tpg_fabric_ptr = NULL;
 +	array_free(se_tpg->tpg_lun_list, TRANSPORT_MAX_LUNS_PER_TPG);
  	return 0;
  }
  EXPORT_SYMBOL(core_tpg_deregister);
* Unmerged path drivers/target/target_core_tpg.c
