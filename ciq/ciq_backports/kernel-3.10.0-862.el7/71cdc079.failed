qla2xxx: Delete session if initiator is gone from FW

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Alexei Potashnik <alexei@purestorage.com>
commit 71cdc07964651db51ddeea05245ac899357f0e71
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/71cdc079.failed

1. Initiator A is logged in with fc_id(1)/loop_id(1)
2. Initiator A re-logs in with fc_id(2)/loop_id(2)
3. Part of old session deletion async logoout for 1/1 is queued
4. Initiator B logs in with fc_id(1)/loop_id(1), starts
   passing data and creates session.
5. Async logo from 3 is processed by DPC and sent to FW

Now initiator B has the session but is logged out from FW.

This condition is detected first with CTIO error 29 at which
point we should delete current session. During session
deletion we will send LOGO to initiator to force re-login.

Under rare circumstances initiator might be logged out of FW,
not have driver session, but still think it's logged in.
E.g. the above sequence plus session deletion due to re-config.
Incoming commands will fail to create local session because
initiator is not found in FW. In this case we also issue LOGO
to initiator to force him re-login.

Finally this patch fixes exchange leak when commands where
received in logged out state. In this case loop_id must be
set to FFFF when corresponding exchange is terminated. The
patch modifies exchange termination to always use FFFF,
since in certain scenarios it's impossible to tell whether
command was received in logged in or logged out state.

	Signed-off-by: Alexei Potashnik <alexei@purestorage.com>
	Acked-by: Quinn Tran <quinn.tran@qlogic.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@qlogic.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 71cdc07964651db51ddeea05245ac899357f0e71)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_os.c
#	drivers/scsi/qla2xxx/qla_target.c
#	drivers/scsi/qla2xxx/qla_target.h
diff --cc drivers/scsi/qla2xxx/qla_def.h
index 9cf0dee11112,495a0aa26757..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -3656,7 -3643,17 +3656,21 @@@ typedef struct scsi_qla_host 
  	uint16_t	fcoe_fcf_idx;
  	uint8_t		fcoe_vn_port_mac[6];
  
++<<<<<<< HEAD
 +	struct list_head	qp_list;
++=======
+ 	/* list of commands waiting on workqueue */
+ 	struct list_head	qla_cmd_list;
+ 	struct list_head	qla_sess_op_cmd_list;
+ 	spinlock_t		cmd_list_lock;
+ 
+ 	/* Counter to detect races between ELS and RSCN events */
+ 	atomic_t		generation_tick;
+ 	/* Time when global fcport update has been scheduled */
+ 	int			total_fcport_update_gen;
+ 	/* List of pending LOGOs, protected by tgt_mutex */
+ 	struct list_head	logo_list;
++>>>>>>> 71cdc0796465 (qla2xxx: Delete session if initiator is gone from FW)
  
  	uint32_t	vp_abort_cnt;
  
diff --cc drivers/scsi/qla2xxx/qla_os.c
index c679c5766696,cb0784a8705e..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -4121,10 -3918,12 +4121,16 @@@ struct scsi_qla_host *qla2x00_create_ho
  	INIT_LIST_HEAD(&vha->vp_fcports);
  	INIT_LIST_HEAD(&vha->work_list);
  	INIT_LIST_HEAD(&vha->list);
++<<<<<<< HEAD
 +	INIT_LIST_HEAD(&vha->qp_list);
++=======
+ 	INIT_LIST_HEAD(&vha->qla_cmd_list);
+ 	INIT_LIST_HEAD(&vha->qla_sess_op_cmd_list);
+ 	INIT_LIST_HEAD(&vha->logo_list);
++>>>>>>> 71cdc0796465 (qla2xxx: Delete session if initiator is gone from FW)
  
  	spin_lock_init(&vha->work_lock);
 -	spin_lock_init(&vha->cmd_list_lock);
 +	init_waitqueue_head(&vha->vref_waitq);
  
  	sprintf(vha->host_str, "%s_%ld", QLA2XXX_DRIVER_NAME, vha->host_no);
  	ql_dbg(ql_dbg_init, vha, 0x0041,
diff --cc drivers/scsi/qla2xxx/qla_target.c
index 4e0d4c3c5146,5ef9d4c21e38..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -340,8 -442,46 +386,51 @@@ static void qlt_free_session_done(struc
  	struct qla_tgt *tgt = sess->tgt;
  	struct scsi_qla_host *vha = sess->vha;
  	struct qla_hw_data *ha = vha->hw;
++<<<<<<< HEAD
++
++	BUG_ON(!tgt);
++=======
+ 	unsigned long flags;
+ 	bool logout_started = false;
+ 	fc_port_t fcport;
+ 
+ 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf084,
+ 		"%s: se_sess %p / sess %p from port %8phC loop_id %#04x"
+ 		" s_id %02x:%02x:%02x logout %d keep %d plogi %d els_logo %d\n",
+ 		__func__, sess->se_sess, sess, sess->port_name, sess->loop_id,
+ 		sess->s_id.b.domain, sess->s_id.b.area, sess->s_id.b.al_pa,
+ 		sess->logout_on_delete, sess->keep_nport_handle,
+ 		sess->plogi_ack_needed, sess->send_els_logo);
  
  	BUG_ON(!tgt);
+ 
+ 	if (sess->send_els_logo) {
+ 		qlt_port_logo_t logo;
+ 		logo.id = sess->s_id;
+ 		logo.cmd_count = 0;
+ 		qlt_send_first_logo(vha, &logo);
+ 	}
+ 
+ 	if (sess->logout_on_delete) {
+ 		int rc;
+ 
+ 		memset(&fcport, 0, sizeof(fcport));
+ 		fcport.loop_id = sess->loop_id;
+ 		fcport.d_id = sess->s_id;
+ 		memcpy(fcport.port_name, sess->port_name, WWN_SIZE);
+ 		fcport.vha = vha;
+ 		fcport.tgt_session = sess;
+ 
+ 		rc = qla2x00_post_async_logout_work(vha, &fcport, NULL);
+ 		if (rc != QLA_SUCCESS)
+ 			ql_log(ql_log_warn, vha, 0xf085,
+ 			       "Schedule logo failed sess %p rc %d\n",
+ 			       sess, rc);
+ 		else
+ 			logout_started = true;
+ 	}
+ 
++>>>>>>> 71cdc0796465 (qla2xxx: Delete session if initiator is gone from FW)
  	/*
  	 * Release the target session for FC Nexus from fabric module code.
  	 */
@@@ -2715,12 -3672,131 +2817,113 @@@ out_term
  	 * cmd has not sent to target yet, so pass NULL as the second
  	 * argument to qlt_send_term_exchange() and free the memory here.
  	 */
 -	cmd->cmd_flags |= BIT_2;
  	spin_lock_irqsave(&ha->hardware_lock, flags);
  	qlt_send_term_exchange(vha, NULL, &cmd->atio, 1);
 -
 -	qlt_decr_num_pend_cmds(vha);
 -	percpu_ida_free(&sess->se_sess->sess_tag_pool, cmd->se_cmd.map_tag);
 -	ha->tgt.tgt_ops->put_sess(sess);
 +	kmem_cache_free(qla_tgt_cmd_cachep, cmd);
  	spin_unlock_irqrestore(&ha->hardware_lock, flags);
++<<<<<<< HEAD
 +	if (sess)
++=======
+ }
+ 
+ static void qlt_do_work(struct work_struct *work)
+ {
+ 	struct qla_tgt_cmd *cmd = container_of(work, struct qla_tgt_cmd, work);
+ 	scsi_qla_host_t *vha = cmd->vha;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&vha->cmd_list_lock, flags);
+ 	list_del(&cmd->cmd_list);
+ 	spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
+ 
+ 	__qlt_do_work(cmd);
+ }
+ 
+ static struct qla_tgt_cmd *qlt_get_tag(scsi_qla_host_t *vha,
+ 				       struct qla_tgt_sess *sess,
+ 				       struct atio_from_isp *atio)
+ {
+ 	struct se_session *se_sess = sess->se_sess;
+ 	struct qla_tgt_cmd *cmd;
+ 	int tag;
+ 
+ 	tag = percpu_ida_alloc(&se_sess->sess_tag_pool, TASK_RUNNING);
+ 	if (tag < 0)
+ 		return NULL;
+ 
+ 	cmd = &((struct qla_tgt_cmd *)se_sess->sess_cmd_map)[tag];
+ 	memset(cmd, 0, sizeof(struct qla_tgt_cmd));
+ 
+ 	memcpy(&cmd->atio, atio, sizeof(*atio));
+ 	cmd->state = QLA_TGT_STATE_NEW;
+ 	cmd->tgt = vha->vha_tgt.qla_tgt;
+ 	qlt_incr_num_pend_cmds(vha);
+ 	cmd->vha = vha;
+ 	cmd->se_cmd.map_tag = tag;
+ 	cmd->sess = sess;
+ 	cmd->loop_id = sess->loop_id;
+ 	cmd->conf_compl_supported = sess->conf_compl_supported;
+ 
+ 	cmd->cmd_flags = 0;
+ 	cmd->jiffies_at_alloc = get_jiffies_64();
+ 
+ 	cmd->reset_count = vha->hw->chip_reset;
+ 
+ 	return cmd;
+ }
+ 
+ static void qlt_send_busy(struct scsi_qla_host *, struct atio_from_isp *,
+ 			  uint16_t);
+ 
+ static void qlt_create_sess_from_atio(struct work_struct *work)
+ {
+ 	struct qla_tgt_sess_op *op = container_of(work,
+ 					struct qla_tgt_sess_op, work);
+ 	scsi_qla_host_t *vha = op->vha;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct qla_tgt_sess *sess;
+ 	struct qla_tgt_cmd *cmd;
+ 	unsigned long flags;
+ 	uint8_t *s_id = op->atio.u.isp24.fcp_hdr.s_id;
+ 
+ 	spin_lock_irqsave(&vha->cmd_list_lock, flags);
+ 	list_del(&op->cmd_list);
+ 	spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
+ 
+ 	if (op->aborted) {
+ 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf083,
+ 		    "sess_op with tag %u is aborted\n",
+ 		    op->atio.u.isp24.exchange_addr);
+ 		goto out_term;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf022,
+ 	    "qla_target(%d): Unable to find wwn login"
+ 	    " (s_id %x:%x:%x), trying to create it manually\n",
+ 	    vha->vp_idx, s_id[0], s_id[1], s_id[2]);
+ 
+ 	if (op->atio.u.raw.entry_count > 1) {
+ 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf023,
+ 		    "Dropping multy entry atio %p\n", &op->atio);
+ 		goto out_term;
+ 	}
+ 
+ 	sess = qlt_make_local_sess(vha, s_id);
+ 	/* sess has an extra creation ref. */
+ 
+ 	if (!sess)
+ 		goto out_term;
+ 	/*
+ 	 * Now obtain a pre-allocated session tag using the original op->atio
+ 	 * packet header, and dispatch into __qlt_do_work() using the existing
+ 	 * process context.
+ 	 */
+ 	cmd = qlt_get_tag(vha, sess, &op->atio);
+ 	if (!cmd) {
+ 		spin_lock_irqsave(&ha->hardware_lock, flags);
+ 		qlt_send_busy(vha, &op->atio, SAM_STAT_BUSY);
++>>>>>>> 71cdc0796465 (qla2xxx: Delete session if initiator is gone from FW)
  		ha->tgt.tgt_ops->put_sess(sess);
 -		spin_unlock_irqrestore(&ha->hardware_lock, flags);
 -		kfree(op);
 -		return;
 -	}
 -	/*
 -	 * __qlt_do_work() will call ha->tgt.tgt_ops->put_sess() to release
 -	 * the extra reference taken above by qlt_make_local_sess()
 -	 */
 -	__qlt_do_work(cmd);
 -	kfree(op);
 -	return;
 -
 -out_term:
 -	spin_lock_irqsave(&ha->hardware_lock, flags);
 -	qlt_send_term_exchange(vha, NULL, &op->atio, 1);
 -	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 -	kfree(op);
 -
  }
  
  /* ha->hardware_lock supposed to be held on entry */
@@@ -4084,8 -5605,11 +4287,10 @@@ static struct qla_tgt_sess *qlt_make_lo
  	int rc, global_resets;
  	uint16_t loop_id = 0;
  
+ 	mutex_lock(&vha->vha_tgt.tgt_mutex);
+ 
  retry:
 -	global_resets =
 -	    atomic_read(&vha->vha_tgt.qla_tgt->tgt_global_resets_count);
 +	global_resets = atomic_read(&ha->tgt.qla_tgt->tgt_global_resets_count);
  
  	rc = qla24xx_get_loop_id(vha, s_id, &loop_id);
  	if (rc != 0) {
@@@ -4108,11 -5642,13 +4323,13 @@@
  	}
  
  	fcport = qlt_get_port_database(vha, loop_id);
- 	if (!fcport)
+ 	if (!fcport) {
+ 		mutex_unlock(&vha->vha_tgt.tgt_mutex);
  		return NULL;
+ 	}
  
  	if (global_resets !=
 -	    atomic_read(&vha->vha_tgt.qla_tgt->tgt_global_resets_count)) {
 +	    atomic_read(&ha->tgt.qla_tgt->tgt_global_resets_count)) {
  		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf043,
  		    "qla_target(%d): global reset during session discovery "
  		    "(counter was %d, new %d), retrying", vha->vp_idx,
@@@ -4152,10 -5691,8 +4371,15 @@@ static void qlt_abort_work(struct qla_t
  	if (!sess) {
  		spin_unlock_irqrestore(&ha->hardware_lock, flags);
  
++<<<<<<< HEAD
 +		mutex_lock(&ha->tgt.tgt_mutex);
 +		sess = qlt_make_local_sess(vha, s_id);
 +		/* sess has got an extra creation ref */
 +		mutex_unlock(&ha->tgt.tgt_mutex);
++=======
+ 		sess = qlt_make_local_sess(vha, s_id);
+ 		/* sess has got an extra creation ref */
++>>>>>>> 71cdc0796465 (qla2xxx: Delete session if initiator is gone from FW)
  
  		spin_lock_irqsave(&ha->hardware_lock, flags);
  		if (!sess)
@@@ -4206,10 -5748,8 +4430,15 @@@ static void qlt_tmr_work(struct qla_tg
  	if (!sess) {
  		spin_unlock_irqrestore(&ha->hardware_lock, flags);
  
++<<<<<<< HEAD
 +		mutex_lock(&ha->tgt.tgt_mutex);
  		sess = qlt_make_local_sess(vha, s_id);
  		/* sess has got an extra creation ref */
 +		mutex_unlock(&ha->tgt.tgt_mutex);
++=======
++		sess = qlt_make_local_sess(vha, s_id);
++		/* sess has got an extra creation ref */
++>>>>>>> 71cdc0796465 (qla2xxx: Delete session if initiator is gone from FW)
  
  		spin_lock_irqsave(&ha->hardware_lock, flags);
  		if (!sess)
diff --cc drivers/scsi/qla2xxx/qla_target.h
index b33e411f28a0,e316d42b46fa..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.h
+++ b/drivers/scsi/qla2xxx/qla_target.h
@@@ -813,8 -904,16 +813,19 @@@ struct qla_tgt_sess 
  	port_id_t s_id;
  
  	unsigned int conf_compl_supported:1;
 -	unsigned int deleted:2;
 +	unsigned int deleted:1;
  	unsigned int local:1;
++<<<<<<< HEAD
++=======
+ 	unsigned int logout_on_delete:1;
+ 	unsigned int plogi_ack_needed:1;
+ 	unsigned int keep_nport_handle:1;
+ 	unsigned int send_els_logo:1;
+ 
+ 	unsigned char logout_completed;
+ 
+ 	int generation;
++>>>>>>> 71cdc0796465 (qla2xxx: Delete session if initiator is gone from FW)
  
  	struct se_session *se_sess;
  	struct scsi_qla_host *vha;
@@@ -969,6 -1111,24 +980,27 @@@ static inline void qla_reverse_ini_mode
  		ha->host->active_mode |= MODE_INITIATOR;
  }
  
++<<<<<<< HEAD
++=======
+ static inline uint32_t sid_to_key(const uint8_t *s_id)
+ {
+ 	uint32_t key;
+ 
+ 	key = (((unsigned long)s_id[0] << 16) |
+ 	       ((unsigned long)s_id[1] << 8) |
+ 	       (unsigned long)s_id[2]);
+ 	return key;
+ }
+ 
+ static inline void sid_to_portid(const uint8_t *s_id, port_id_t *p)
+ {
+ 	memset(p, 0, sizeof(*p));
+ 	p->b.domain = s_id[0];
+ 	p->b.area = s_id[1];
+ 	p->b.al_pa = s_id[2];
+ }
+ 
++>>>>>>> 71cdc0796465 (qla2xxx: Delete session if initiator is gone from FW)
  /*
   * Exported symbols from qla_target.c LLD logic used by qla2xxx code..
   */
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.h
