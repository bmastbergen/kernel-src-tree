radix-tree: tidy up next_chunk

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Matthew Wilcox <willy@linux.intel.com>
commit 8c1244de00ef98f73e21eecc42d84b2742fbb4f9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8c1244de.failed

Convert radix_tree_next_chunk to use 'child' instead of 'slot' as the
name of the child node.  Also use node_maxindex() where it makes sense.

The 'rnode' variable was unnecessary; it doesn't overlap in usage with
'node', so we can just use 'node' the whole way through the function.

Improve the testcase to start the walk from every index in the carefully
constructed tree, and to accept any index within the range covered by
the entry.

	Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
	Cc: Konstantin Khlebnikov <koct9i@gmail.com>
	Cc: Kirill Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Jan Kara <jack@suse.com>
	Cc: Neil Brown <neilb@suse.de>
	Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 8c1244de00ef98f73e21eecc42d84b2742fbb4f9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/radix-tree.c
#	tools/testing/radix-tree/multiorder.c
diff --cc lib/radix-tree.c
index 467d6e0a3a58,c42867a1769a..000000000000
--- a/lib/radix-tree.c
+++ b/lib/radix-tree.c
@@@ -863,8 -876,8 +863,13 @@@ void **radix_tree_next_chunk(struct rad
  			     struct radix_tree_iter *iter, unsigned flags)
  {
  	unsigned shift, tag = flags & RADIX_TREE_ITER_TAG_MASK;
++<<<<<<< HEAD
 +	struct radix_tree_node *rnode, *node;
 +	unsigned long index, offset, height;
++=======
+ 	struct radix_tree_node *node, *child;
+ 	unsigned long index, offset, maxindex;
++>>>>>>> 8c1244de00ef (radix-tree: tidy up next_chunk)
  
  	if ((flags & RADIX_TREE_ITER_TAGGED) && !root_tag_get(root, tag))
  		return NULL;
@@@ -882,33 -895,30 +887,58 @@@
  	if (!index && iter->index)
  		return NULL;
  
++<<<<<<< HEAD
 +	rnode = rcu_dereference_raw(root->rnode);
 +	if (radix_tree_is_indirect_ptr(rnode)) {
 +		rnode = indirect_to_ptr(rnode);
 +	} else if (rnode && !index) {
++=======
+  restart:
+ 	shift = radix_tree_load_root(root, &child, &maxindex);
+ 	if (index > maxindex)
+ 		return NULL;
+ 	if (!child)
+ 		return NULL;
+ 
+ 	if (!radix_tree_is_internal_node(child)) {
++>>>>>>> 8c1244de00ef (radix-tree: tidy up next_chunk)
  		/* Single-slot tree */
 -		iter->index = index;
 -		iter->next_index = maxindex + 1;
 +		iter->index = 0;
 +		iter->next_index = 1;
  		iter->tags = 1;
++<<<<<<< HEAD
++=======
+ 		__set_iter_shift(iter, 0);
++>>>>>>> 8c1244de00ef (radix-tree: tidy up next_chunk)
  		return (void **)&root->rnode;
- 	} else
- 		return NULL;
+ 	}
  
++<<<<<<< HEAD
 +restart:
 +	height = rnode->path & RADIX_TREE_HEIGHT_MASK;
 +	shift = (height - 1) * RADIX_TREE_MAP_SHIFT;
 +	offset = index >> shift;
 +
 +	/* Index outside of the tree */
 +	if (offset >= RADIX_TREE_MAP_SIZE)
 +		return NULL;
 +
 +	node = rnode;
 +	while (1) {
 +		struct radix_tree_node *slot;
 +		if ((flags & RADIX_TREE_ITER_TAGGED) ?
 +				!test_bit(offset, node->tags[tag]) :
 +				!node->slots[offset]) {
++=======
+ 	do {
+ 		node = entry_to_node(child);
+ 		shift -= RADIX_TREE_MAP_SHIFT;
+ 		offset = (index >> shift) & RADIX_TREE_MAP_MASK;
+ 		offset = radix_tree_descend(node, &child, offset);
+ 
+ 		if ((flags & RADIX_TREE_ITER_TAGGED) ?
+ 				!tag_get(node, tag, offset) : !child) {
++>>>>>>> 8c1244de00ef (radix-tree: tidy up next_chunk)
  			/* Hole detected */
  			if (flags & RADIX_TREE_ITER_CONTIG)
  				return NULL;
@@@ -920,35 -930,30 +950,49 @@@
  						offset + 1);
  			else
  				while (++offset	< RADIX_TREE_MAP_SIZE) {
 -					void *slot = node->slots[offset];
 -					if (is_sibling_entry(node, slot))
 -						continue;
 -					if (slot)
 +					if (node->slots[offset])
  						break;
  				}
- 			index &= ~((RADIX_TREE_MAP_SIZE << shift) - 1);
+ 			index &= ~node_maxindex(node);
  			index += offset << shift;
  			/* Overflow after ~0UL */
  			if (!index)
  				return NULL;
  			if (offset == RADIX_TREE_MAP_SIZE)
  				goto restart;
++<<<<<<< HEAD
 +		}
 +
 +		/* This is leaf-node */
 +		if (!shift)
 +			break;
 +
 +		slot = rcu_dereference_raw(node->slots[offset]);
 +		if (slot == NULL)
 +			goto restart;
 +		if (!radix_tree_is_indirect_ptr(slot))
 +			break;
 +		node = indirect_to_ptr(slot);
 +		shift -= RADIX_TREE_MAP_SHIFT;
 +		offset = (index >> shift) & RADIX_TREE_MAP_MASK;
 +	}
 +
 +	/* Update the iterator state */
 +	iter->index = index;
 +	iter->next_index = (index | RADIX_TREE_MAP_MASK) + 1;
++=======
+ 			child = rcu_dereference_raw(node->slots[offset]);
+ 		}
+ 
+ 		if ((child == NULL) || (child == RADIX_TREE_RETRY))
+ 			goto restart;
+ 	} while (radix_tree_is_internal_node(child));
+ 
+ 	/* Update the iterator state */
+ 	iter->index = (index &~ node_maxindex(node)) | (offset << node->shift);
+ 	iter->next_index = (index | node_maxindex(node)) + 1;
+ 	__set_iter_shift(iter, shift);
++>>>>>>> 8c1244de00ef (radix-tree: tidy up next_chunk)
  
  	/* Construct iter->tags bit-mask from node->tags[tag] array */
  	if (flags & RADIX_TREE_ITER_TAGGED) {
* Unmerged path tools/testing/radix-tree/multiorder.c
* Unmerged path lib/radix-tree.c
* Unmerged path tools/testing/radix-tree/multiorder.c
