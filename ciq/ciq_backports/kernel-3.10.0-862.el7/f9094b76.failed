geneve: only configure or fill UDP_ZERO_CSUM6_RX/TX info when CONFIG_IPV6

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Hangbin Liu <liuhangbin@gmail.com>
commit f9094b7603c011d27db7ba109e69881c72fa611d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f9094b76.failed

Stefano pointed that configure or show UDP_ZERO_CSUM6_RX/TX info doesn't
make sense if we haven't enabled CONFIG_IPV6. Fix it by adding
if IS_ENABLED(CONFIG_IPV6) check.

Fixes: abe492b4f50c ("geneve: UDP checksum configuration via netlink")
Fixes: fd7eafd02121 ("geneve: fix fill_info when link down")
	Signed-off-by: Hangbin Liu <liuhangbin@gmail.com>
	Reviewed-by: Stefano Brivio <sbrivio@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f9094b7603c011d27db7ba109e69881c72fa611d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/geneve.c
diff --cc drivers/net/geneve.c
index 311107458453,b718a02a6bb6..000000000000
--- a/drivers/net/geneve.c
+++ b/drivers/net/geneve.c
@@@ -1352,53 -1241,238 +1352,85 @@@ static int geneve_newlink(struct net *n
  	}
  
  	if (data[IFLA_GENEVE_REMOTE6]) {
 - #if IS_ENABLED(CONFIG_IPV6)
 -		if (changelink && (ip_tunnel_info_af(info) == AF_INET)) {
 -			attrtype = IFLA_GENEVE_REMOTE6;
 -			goto change_notsup;
 -		}
 +		if (!IS_ENABLED(CONFIG_IPV6))
 +			return -EPFNOSUPPORT;
  
 -		info->mode = IP_TUNNEL_INFO_IPV6;
 -		info->key.u.ipv6.dst =
 +		remote.sa.sa_family = AF_INET6;
 +		remote.sin6.sin6_addr =
  			nla_get_in6_addr(data[IFLA_GENEVE_REMOTE6]);
  
 -		if (ipv6_addr_type(&info->key.u.ipv6.dst) &
 +		if (ipv6_addr_type(&remote.sin6.sin6_addr) &
  		    IPV6_ADDR_LINKLOCAL) {
 -			NL_SET_ERR_MSG_ATTR(extack, data[IFLA_GENEVE_REMOTE6],
 -					    "Remote IPv6 address cannot be link-local");
 -			return -EINVAL;
 -		}
 -		if (ipv6_addr_is_multicast(&info->key.u.ipv6.dst)) {
 -			NL_SET_ERR_MSG_ATTR(extack, data[IFLA_GENEVE_REMOTE6],
 -					    "Remote IPv6 address cannot be Multicast");
 +			netdev_dbg(dev, "link-local remote is unsupported\n");
  			return -EINVAL;
  		}
 -		info->key.tun_flags |= TUNNEL_CSUM;
 -		*use_udp6_rx_checksums = true;
 -#else
 -		NL_SET_ERR_MSG_ATTR(extack, data[IFLA_GENEVE_REMOTE6],
 -				    "IPv6 support not enabled in the kernel");
 -		return -EPFNOSUPPORT;
 -#endif
  	}
  
 -	if (data[IFLA_GENEVE_ID]) {
 -		__u32 vni;
 -		__u8 tvni[3];
 -		__be64 tunid;
 -
 +	if (data[IFLA_GENEVE_ID])
  		vni = nla_get_u32(data[IFLA_GENEVE_ID]);
 -		tvni[0] = (vni & 0x00ff0000) >> 16;
 -		tvni[1] = (vni & 0x0000ff00) >> 8;
 -		tvni[2] =  vni & 0x000000ff;
 -
 -		tunid = vni_to_tunnel_id(tvni);
 -		if (changelink && (tunid != info->key.tun_id)) {
 -			attrtype = IFLA_GENEVE_ID;
 -			goto change_notsup;
 -		}
 -		info->key.tun_id = tunid;
 -	}
  
  	if (data[IFLA_GENEVE_TTL])
 -		info->key.ttl = nla_get_u8(data[IFLA_GENEVE_TTL]);
 +		ttl = nla_get_u8(data[IFLA_GENEVE_TTL]);
  
  	if (data[IFLA_GENEVE_TOS])
 -		info->key.tos = nla_get_u8(data[IFLA_GENEVE_TOS]);
 -
 -	if (data[IFLA_GENEVE_LABEL]) {
 -		info->key.label = nla_get_be32(data[IFLA_GENEVE_LABEL]) &
 -				  IPV6_FLOWLABEL_MASK;
 -		if (info->key.label && (!(info->mode & IP_TUNNEL_INFO_IPV6))) {
 -			NL_SET_ERR_MSG_ATTR(extack, data[IFLA_GENEVE_LABEL],
 -					    "Label attribute only applies for IPv6 Geneve devices");
 -			return -EINVAL;
 -		}
 -	}
 +		tos = nla_get_u8(data[IFLA_GENEVE_TOS]);
  
 -	if (data[IFLA_GENEVE_PORT]) {
 -		if (changelink) {
 -			attrtype = IFLA_GENEVE_PORT;
 -			goto change_notsup;
 -		}
 -		info->key.tp_dst = nla_get_be16(data[IFLA_GENEVE_PORT]);
 -	}
 +	if (data[IFLA_GENEVE_LABEL])
 +		label = nla_get_be32(data[IFLA_GENEVE_LABEL]) &
 +			IPV6_FLOWLABEL_MASK;
  
 -	if (data[IFLA_GENEVE_COLLECT_METADATA]) {
 -		if (changelink) {
 -			attrtype = IFLA_GENEVE_COLLECT_METADATA;
 -			goto change_notsup;
 -		}
 -		*metadata = true;
 -	}
 +	if (data[IFLA_GENEVE_PORT])
 +		dst_port = nla_get_be16(data[IFLA_GENEVE_PORT]);
  
 -	if (data[IFLA_GENEVE_UDP_CSUM]) {
 -		if (changelink) {
 -			attrtype = IFLA_GENEVE_UDP_CSUM;
 -			goto change_notsup;
 -		}
 -		if (nla_get_u8(data[IFLA_GENEVE_UDP_CSUM]))
 -			info->key.tun_flags |= TUNNEL_CSUM;
 -	}
 +	if (data[IFLA_GENEVE_COLLECT_METADATA])
 +		metadata = true;
 +
 +	if (data[IFLA_GENEVE_UDP_CSUM] &&
 +	    !nla_get_u8(data[IFLA_GENEVE_UDP_CSUM]))
 +		flags |= GENEVE_F_UDP_ZERO_CSUM_TX;
 +
++<<<<<<< HEAD
 +	if (data[IFLA_GENEVE_UDP_ZERO_CSUM6_TX] &&
 +	    nla_get_u8(data[IFLA_GENEVE_UDP_ZERO_CSUM6_TX]))
 +		flags |= GENEVE_F_UDP_ZERO_CSUM6_TX;
  
 +	if (data[IFLA_GENEVE_UDP_ZERO_CSUM6_RX] &&
 +	    nla_get_u8(data[IFLA_GENEVE_UDP_ZERO_CSUM6_RX]))
 +		flags |= GENEVE_F_UDP_ZERO_CSUM6_RX;
++=======
+ 	if (data[IFLA_GENEVE_UDP_ZERO_CSUM6_TX]) {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 		if (changelink) {
+ 			attrtype = IFLA_GENEVE_UDP_ZERO_CSUM6_TX;
+ 			goto change_notsup;
+ 		}
+ 		if (nla_get_u8(data[IFLA_GENEVE_UDP_ZERO_CSUM6_TX]))
+ 			info->key.tun_flags &= ~TUNNEL_CSUM;
+ #else
+ 		NL_SET_ERR_MSG_ATTR(extack, data[IFLA_GENEVE_UDP_ZERO_CSUM6_TX],
+ 				    "IPv6 support not enabled in the kernel");
+ 		return -EPFNOSUPPORT;
+ #endif
+ 	}
+ 
+ 	if (data[IFLA_GENEVE_UDP_ZERO_CSUM6_RX]) {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 		if (changelink) {
+ 			attrtype = IFLA_GENEVE_UDP_ZERO_CSUM6_RX;
+ 			goto change_notsup;
+ 		}
+ 		if (nla_get_u8(data[IFLA_GENEVE_UDP_ZERO_CSUM6_RX]))
+ 			*use_udp6_rx_checksums = false;
+ #else
+ 		NL_SET_ERR_MSG_ATTR(extack, data[IFLA_GENEVE_UDP_ZERO_CSUM6_RX],
+ 				    "IPv6 support not enabled in the kernel");
+ 		return -EPFNOSUPPORT;
+ #endif
+ 	}
++>>>>>>> f9094b7603c0 (geneve: only configure or fill UDP_ZERO_CSUM6_RX/TX info when CONFIG_IPV6)
  
 -	return 0;
 -change_notsup:
 -	NL_SET_ERR_MSG_ATTR(extack, data[attrtype],
 -			    "Changing VNI, Port, endpoint IP address family, external, and UDP checksum attributes are not supported");
 -	return -EOPNOTSUPP;
 -}
 -
 -static int geneve_newlink(struct net *net, struct net_device *dev,
 -			  struct nlattr *tb[], struct nlattr *data[],
 -			  struct netlink_ext_ack *extack)
 -{
 -	bool use_udp6_rx_checksums = false;
 -	struct ip_tunnel_info info;
 -	bool metadata = false;
 -	int err;
 -
 -	init_tnl_info(&info, GENEVE_UDP_PORT);
 -	err = geneve_nl2info(tb, data, extack, &info, &metadata,
 -			     &use_udp6_rx_checksums, false);
 -	if (err)
 -		return err;
 -
 -	return geneve_configure(net, dev, extack, &info, metadata,
 -				use_udp6_rx_checksums);
 -}
 -
 -/* Quiesces the geneve device data path for both TX and RX.
 - *
 - * On transmit geneve checks for non-NULL geneve_sock before it proceeds.
 - * So, if we set that socket to NULL under RCU and wait for synchronize_net()
 - * to complete for the existing set of in-flight packets to be transmitted,
 - * then we would have quiesced the transmit data path. All the future packets
 - * will get dropped until we unquiesce the data path.
 - *
 - * On receive geneve dereference the geneve_sock stashed in the socket. So,
 - * if we set that to NULL under RCU and wait for synchronize_net() to
 - * complete, then we would have quiesced the receive data path.
 - */
 -static void geneve_quiesce(struct geneve_dev *geneve, struct geneve_sock **gs4,
 -			   struct geneve_sock **gs6)
 -{
 -	*gs4 = rtnl_dereference(geneve->sock4);
 -	rcu_assign_pointer(geneve->sock4, NULL);
 -	if (*gs4)
 -		rcu_assign_sk_user_data((*gs4)->sock->sk, NULL);
 -#if IS_ENABLED(CONFIG_IPV6)
 -	*gs6 = rtnl_dereference(geneve->sock6);
 -	rcu_assign_pointer(geneve->sock6, NULL);
 -	if (*gs6)
 -		rcu_assign_sk_user_data((*gs6)->sock->sk, NULL);
 -#else
 -	*gs6 = NULL;
 -#endif
 -	synchronize_net();
 -}
 -
 -/* Resumes the geneve device data path for both TX and RX. */
 -static void geneve_unquiesce(struct geneve_dev *geneve, struct geneve_sock *gs4,
 -			     struct geneve_sock __maybe_unused *gs6)
 -{
 -	rcu_assign_pointer(geneve->sock4, gs4);
 -	if (gs4)
 -		rcu_assign_sk_user_data(gs4->sock->sk, gs4);
 -#if IS_ENABLED(CONFIG_IPV6)
 -	rcu_assign_pointer(geneve->sock6, gs6);
 -	if (gs6)
 -		rcu_assign_sk_user_data(gs6->sock->sk, gs6);
 -#endif
 -	synchronize_net();
 -}
 -
 -static int geneve_changelink(struct net_device *dev, struct nlattr *tb[],
 -			     struct nlattr *data[],
 -			     struct netlink_ext_ack *extack)
 -{
 -	struct geneve_dev *geneve = netdev_priv(dev);
 -	struct geneve_sock *gs4, *gs6;
 -	struct ip_tunnel_info info;
 -	bool metadata;
 -	bool use_udp6_rx_checksums;
 -	int err;
 -
 -	/* If the geneve device is configured for metadata (or externally
 -	 * controlled, for example, OVS), then nothing can be changed.
 -	 */
 -	if (geneve->collect_md)
 -		return -EOPNOTSUPP;
 -
 -	/* Start with the existing info. */
 -	memcpy(&info, &geneve->info, sizeof(info));
 -	metadata = geneve->collect_md;
 -	use_udp6_rx_checksums = geneve->use_udp6_rx_checksums;
 -	err = geneve_nl2info(tb, data, extack, &info, &metadata,
 -			     &use_udp6_rx_checksums, true);
 -	if (err)
 -		return err;
 -
 -	if (!geneve_dst_addr_equal(&geneve->info, &info))
 -		dst_cache_reset(&info.dst_cache);
 -
 -	geneve_quiesce(geneve, &gs4, &gs6);
 -	geneve->info = info;
 -	geneve->collect_md = metadata;
 -	geneve->use_udp6_rx_checksums = use_udp6_rx_checksums;
 -	geneve_unquiesce(geneve, gs4, gs6);
 -
 -	return 0;
 +	return geneve_configure(net, dev, &remote, vni, ttl, tos, label,
 +				dst_port, metadata, flags);
  }
  
  static void geneve_dellink(struct net_device *dev, struct list_head *head)
@@@ -1445,27 -1530,23 +1477,37 @@@ static int geneve_fill_info(struct sk_b
  #endif
  	}
  
 -	if (nla_put_u8(skb, IFLA_GENEVE_TTL, info->key.ttl) ||
 -	    nla_put_u8(skb, IFLA_GENEVE_TOS, info->key.tos) ||
 -	    nla_put_be32(skb, IFLA_GENEVE_LABEL, info->key.label))
 +	if (nla_put_u8(skb, IFLA_GENEVE_TTL, geneve->ttl) ||
 +	    nla_put_u8(skb, IFLA_GENEVE_TOS, geneve->tos) ||
 +	    nla_put_be32(skb, IFLA_GENEVE_LABEL, geneve->label))
  		goto nla_put_failure;
  
 -	if (nla_put_be16(skb, IFLA_GENEVE_PORT, info->key.tp_dst))
 +	if (nla_put_be16(skb, IFLA_GENEVE_PORT, geneve->dst_port))
  		goto nla_put_failure;
  
++<<<<<<< HEAD
 +	if (geneve->collect_md) {
 +		if (nla_put_flag(skb, IFLA_GENEVE_COLLECT_METADATA))
 +			goto nla_put_failure;
 +	}
 +
 +	if (nla_put_u8(skb, IFLA_GENEVE_UDP_CSUM,
 +		       !(geneve->flags & GENEVE_F_UDP_ZERO_CSUM_TX)) ||
 +	    nla_put_u8(skb, IFLA_GENEVE_UDP_ZERO_CSUM6_TX,
 +		       !!(geneve->flags & GENEVE_F_UDP_ZERO_CSUM6_TX)) ||
 +	    nla_put_u8(skb, IFLA_GENEVE_UDP_ZERO_CSUM6_RX,
 +		       !!(geneve->flags & GENEVE_F_UDP_ZERO_CSUM6_RX)))
++=======
+ 	if (metadata && nla_put_flag(skb, IFLA_GENEVE_COLLECT_METADATA))
  		goto nla_put_failure;
  
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	if (nla_put_u8(skb, IFLA_GENEVE_UDP_ZERO_CSUM6_RX,
+ 		       !geneve->use_udp6_rx_checksums))
++>>>>>>> f9094b7603c0 (geneve: only configure or fill UDP_ZERO_CSUM6_RX/TX info when CONFIG_IPV6)
+ 		goto nla_put_failure;
+ #endif
+ 
  	return 0;
  
  nla_put_failure:
* Unmerged path drivers/net/geneve.c
