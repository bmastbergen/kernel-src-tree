proc: Allow creating permanently empty directories that serve as mount points

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit eb6d38d5427b3ad42f5268da0f1dd31bb0af1264
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/eb6d38d5.failed

Add a new function proc_create_mount_point that when used to creates a
directory that can not be added to.

Add a new function is_empty_pde to test if a function is a mount
point.

Update the code to use make_empty_dir_inode when reporting
a permanently empty directory to the vfs.

Update the code to not allow adding to permanently empty directories.

Update /proc/openprom and /proc/fs/nfsd to be permanently empty directories.

	Cc: stable@vger.kernel.org
	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
(cherry picked from commit eb6d38d5427b3ad42f5268da0f1dd31bb0af1264)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/proc/generic.c
#	fs/proc/internal.h
diff --cc fs/proc/generic.c
index ae73c569138f,e5dee5c3188e..000000000000
--- a/fs/proc/generic.c
+++ b/fs/proc/generic.c
@@@ -421,14 -363,22 +421,31 @@@ static struct proc_dir_entry *__proc_cr
  
  	if (xlate_proc_name(name, parent, &fn) != 0)
  		goto out;
++<<<<<<< HEAD
++=======
+ 	qstr.name = fn;
+ 	qstr.len = strlen(fn);
+ 	if (qstr.len == 0 || qstr.len >= 256) {
+ 		WARN(1, "name len %u\n", qstr.len);
+ 		return NULL;
+ 	}
+ 	if (*parent == &proc_root && name_to_int(&qstr) != ~0U) {
+ 		WARN(1, "create '/proc/%s' by hand\n", qstr.name);
+ 		return NULL;
+ 	}
+ 	if (is_empty_pde(*parent)) {
+ 		WARN(1, "attempt to add to permanently empty directory");
+ 		return NULL;
+ 	}
++>>>>>>> eb6d38d5427b (proc: Allow creating permanently empty directories that serve as mount points)
 +
 +	/* At this point there must not be any '/' characters beyond *fn */
 +	if (strchr(fn, '/'))
 +		goto out;
 +
 +	len = strlen(fn);
  
 -	ent = kzalloc(sizeof(struct proc_dir_entry) + qstr.len + 1, GFP_KERNEL);
 +	ent = kzalloc(sizeof(struct proc_dir_entry) + len + 1, GFP_KERNEL);
  	if (!ent)
  		goto out;
  
diff --cc fs/proc/internal.h
index b3afe6cc8f18,aa2781095bd1..000000000000
--- a/fs/proc/internal.h
+++ b/fs/proc/internal.h
@@@ -205,12 -191,11 +205,20 @@@ static inline struct proc_dir_entry *pd
  }
  extern void pde_put(struct proc_dir_entry *);
  
++<<<<<<< HEAD
 +extern struct proc_dir_entry *pde_subdir_first(struct proc_dir_entry *dir);
 +extern struct proc_dir_entry *pde_subdir_next(struct proc_dir_entry *dir);
 +extern struct proc_dir_entry *pde_subdir_find(struct proc_dir_entry *dir,
 +					      const char *name, unsigned int len);
 +extern bool pde_subdir_insert (struct proc_dir_entry *dir,
 +			       struct proc_dir_entry *de);
++=======
+ static inline bool is_empty_pde(const struct proc_dir_entry *pde)
+ {
+ 	return S_ISDIR(pde->mode) && !pde->proc_iops;
+ }
+ struct proc_dir_entry *proc_create_mount_point(const char *name);
++>>>>>>> eb6d38d5427b (proc: Allow creating permanently empty directories that serve as mount points)
  
  /*
   * inode.c
* Unmerged path fs/proc/generic.c
diff --git a/fs/proc/inode.c b/fs/proc/inode.c
index 8d35dac92daf..4fdddaae7078 100644
--- a/fs/proc/inode.c
+++ b/fs/proc/inode.c
@@ -382,6 +382,10 @@ struct inode *proc_get_inode(struct super_block *sb, struct proc_dir_entry *de)
 		inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
 		PROC_I(inode)->pde = de;
 
+		if (is_empty_pde(de)) {
+			make_empty_dir_inode(inode);
+			return inode;
+		}
 		if (de->mode) {
 			inode->i_mode = de->mode;
 			inode->i_uid = de->uid;
* Unmerged path fs/proc/internal.h
diff --git a/fs/proc/root.c b/fs/proc/root.c
index 3a48c1b05b1a..f851604d95ee 100644
--- a/fs/proc/root.c
+++ b/fs/proc/root.c
@@ -174,10 +174,10 @@ void __init proc_root_init(void)
 #endif
 	proc_mkdir("fs", NULL);
 	proc_mkdir("driver", NULL);
-	proc_mkdir("fs/nfsd", NULL); /* somewhere for the nfsd filesystem to be mounted */
+	proc_create_mount_point("fs/nfsd"); /* somewhere for the nfsd filesystem to be mounted */
 #if defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE)
 	/* just give it a mountpoint */
-	proc_mkdir("openprom", NULL);
+	proc_create_mount_point("openprom");
 #endif
 	proc_tty_init();
 #ifdef CONFIG_PROC_DEVICETREE
