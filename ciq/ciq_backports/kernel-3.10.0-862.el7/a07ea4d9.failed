genetlink: no longer support using static family IDs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Johannes Berg <johannes.berg@intel.com>
commit a07ea4d9941af5a0c6f0be2a71b51ac9c083c5e5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a07ea4d9.failed

Static family IDs have never really been used, the only
use case was the workaround I introduced for those users
that assumed their family ID was also their multicast
group ID.

Additionally, because static family IDs would never be
reserved by the generic netlink code, using a relatively
low ID would only work for built-in families that can be
registered immediately after generic netlink is started,
which is basically only the control family (apart from
the workaround code, which I also had to add code for so
it would reserve those IDs)

Thus, anything other than GENL_ID_GENERATE is flawed and
luckily not used except in the cases I mentioned. Move
those workarounds into a few lines of code, and then get
rid of GENL_ID_GENERATE entirely, making it more robust.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a07ea4d9941af5a0c6f0be2a71b51ac9c083c5e5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/gtp.c
#	net/batman-adv/netlink.c
#	net/hsr/hsr_netlink.c
#	net/ipv6/ila/ila_xlat.c
#	net/netlabel/netlabel_calipso.c
#	net/tipc/netlink.c
#	net/tipc/netlink_compat.c
#	net/wireless/nl80211.c
diff --cc net/tipc/netlink.c
index 1e6081fb6078,383b8fedabc7..000000000000
--- a/net/tipc/netlink.c
+++ b/net/tipc/netlink.c
@@@ -35,54 -35,239 +35,271 @@@
   */
  
  #include "core.h"
 -#include "socket.h"
 -#include "name_table.h"
 -#include "bearer.h"
 -#include "link.h"
 -#include "node.h"
 -#include "net.h"
 -#include "udp_media.h"
 +#include "config.h"
  #include <net/genetlink.h>
  
++<<<<<<< HEAD
 +static int handle_cmd(struct sk_buff *skb, struct genl_info *info)
++=======
+ static const struct nla_policy tipc_nl_policy[TIPC_NLA_MAX + 1] = {
+ 	[TIPC_NLA_UNSPEC]	= { .type = NLA_UNSPEC, },
+ 	[TIPC_NLA_BEARER]	= { .type = NLA_NESTED, },
+ 	[TIPC_NLA_SOCK]		= { .type = NLA_NESTED, },
+ 	[TIPC_NLA_PUBL]		= { .type = NLA_NESTED, },
+ 	[TIPC_NLA_LINK]		= { .type = NLA_NESTED, },
+ 	[TIPC_NLA_MEDIA]	= { .type = NLA_NESTED, },
+ 	[TIPC_NLA_NODE]		= { .type = NLA_NESTED, },
+ 	[TIPC_NLA_NET]		= { .type = NLA_NESTED, },
+ 	[TIPC_NLA_NAME_TABLE]	= { .type = NLA_NESTED, },
+ 	[TIPC_NLA_MON]		= { .type = NLA_NESTED, },
+ };
+ 
+ const struct nla_policy
+ tipc_nl_name_table_policy[TIPC_NLA_NAME_TABLE_MAX + 1] = {
+ 	[TIPC_NLA_NAME_TABLE_UNSPEC]	= { .type = NLA_UNSPEC },
+ 	[TIPC_NLA_NAME_TABLE_PUBL]	= { .type = NLA_NESTED }
+ };
+ 
+ const struct nla_policy tipc_nl_monitor_policy[TIPC_NLA_MON_MAX + 1] = {
+ 	[TIPC_NLA_MON_UNSPEC]			= { .type = NLA_UNSPEC },
+ 	[TIPC_NLA_MON_REF]			= { .type = NLA_U32 },
+ 	[TIPC_NLA_MON_ACTIVATION_THRESHOLD]	= { .type = NLA_U32 },
+ };
+ 
+ const struct nla_policy tipc_nl_sock_policy[TIPC_NLA_SOCK_MAX + 1] = {
+ 	[TIPC_NLA_SOCK_UNSPEC]		= { .type = NLA_UNSPEC },
+ 	[TIPC_NLA_SOCK_ADDR]		= { .type = NLA_U32 },
+ 	[TIPC_NLA_SOCK_REF]		= { .type = NLA_U32 },
+ 	[TIPC_NLA_SOCK_CON]		= { .type = NLA_NESTED },
+ 	[TIPC_NLA_SOCK_HAS_PUBL]	= { .type = NLA_FLAG }
+ };
+ 
+ const struct nla_policy tipc_nl_net_policy[TIPC_NLA_NET_MAX + 1] = {
+ 	[TIPC_NLA_NET_UNSPEC]		= { .type = NLA_UNSPEC },
+ 	[TIPC_NLA_NET_ID]		= { .type = NLA_U32 }
+ };
+ 
+ const struct nla_policy tipc_nl_link_policy[TIPC_NLA_LINK_MAX + 1] = {
+ 	[TIPC_NLA_LINK_UNSPEC]		= { .type = NLA_UNSPEC },
+ 	[TIPC_NLA_LINK_NAME]		= { .type = NLA_STRING,
+ 					    .len = TIPC_MAX_LINK_NAME },
+ 	[TIPC_NLA_LINK_MTU]		= { .type = NLA_U32 },
+ 	[TIPC_NLA_LINK_BROADCAST]	= { .type = NLA_FLAG },
+ 	[TIPC_NLA_LINK_UP]		= { .type = NLA_FLAG },
+ 	[TIPC_NLA_LINK_ACTIVE]		= { .type = NLA_FLAG },
+ 	[TIPC_NLA_LINK_PROP]		= { .type = NLA_NESTED },
+ 	[TIPC_NLA_LINK_STATS]		= { .type = NLA_NESTED },
+ 	[TIPC_NLA_LINK_RX]		= { .type = NLA_U32 },
+ 	[TIPC_NLA_LINK_TX]		= { .type = NLA_U32 }
+ };
+ 
+ const struct nla_policy tipc_nl_node_policy[TIPC_NLA_NODE_MAX + 1] = {
+ 	[TIPC_NLA_NODE_UNSPEC]		= { .type = NLA_UNSPEC },
+ 	[TIPC_NLA_NODE_ADDR]		= { .type = NLA_U32 },
+ 	[TIPC_NLA_NODE_UP]		= { .type = NLA_FLAG }
+ };
+ 
+ /* Properties valid for media, bearer and link */
+ const struct nla_policy tipc_nl_prop_policy[TIPC_NLA_PROP_MAX + 1] = {
+ 	[TIPC_NLA_PROP_UNSPEC]		= { .type = NLA_UNSPEC },
+ 	[TIPC_NLA_PROP_PRIO]		= { .type = NLA_U32 },
+ 	[TIPC_NLA_PROP_TOL]		= { .type = NLA_U32 },
+ 	[TIPC_NLA_PROP_WIN]		= { .type = NLA_U32 }
+ };
+ 
+ const struct nla_policy tipc_nl_bearer_policy[TIPC_NLA_BEARER_MAX + 1]	= {
+ 	[TIPC_NLA_BEARER_UNSPEC]	= { .type = NLA_UNSPEC },
+ 	[TIPC_NLA_BEARER_NAME]		= { .type = NLA_STRING,
+ 					    .len = TIPC_MAX_BEARER_NAME },
+ 	[TIPC_NLA_BEARER_PROP]		= { .type = NLA_NESTED },
+ 	[TIPC_NLA_BEARER_DOMAIN]	= { .type = NLA_U32 }
+ };
+ 
+ const struct nla_policy tipc_nl_media_policy[TIPC_NLA_MEDIA_MAX + 1] = {
+ 	[TIPC_NLA_MEDIA_UNSPEC]		= { .type = NLA_UNSPEC },
+ 	[TIPC_NLA_MEDIA_NAME]		= { .type = NLA_STRING },
+ 	[TIPC_NLA_MEDIA_PROP]		= { .type = NLA_NESTED }
+ };
+ 
+ const struct nla_policy tipc_nl_udp_policy[TIPC_NLA_UDP_MAX + 1] = {
+ 	[TIPC_NLA_UDP_UNSPEC]	= {.type = NLA_UNSPEC},
+ 	[TIPC_NLA_UDP_LOCAL]	= {.type = NLA_BINARY,
+ 				   .len = sizeof(struct sockaddr_storage)},
+ 	[TIPC_NLA_UDP_REMOTE]	= {.type = NLA_BINARY,
+ 				   .len = sizeof(struct sockaddr_storage)},
+ };
+ 
+ /* Users of the legacy API (tipc-config) can't handle that we add operations,
+  * so we have a separate genl handling for the new API.
+  */
+ struct genl_family tipc_genl_family = {
+ 	.name		= TIPC_GENL_V2_NAME,
+ 	.version	= TIPC_GENL_V2_VERSION,
+ 	.hdrsize	= 0,
+ 	.maxattr	= TIPC_NLA_MAX,
+ 	.netnsok	= true,
+ };
+ 
+ static const struct genl_ops tipc_genl_v2_ops[] = {
+ 	{
+ 		.cmd	= TIPC_NL_BEARER_DISABLE,
+ 		.doit	= tipc_nl_bearer_disable,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_BEARER_ENABLE,
+ 		.doit	= tipc_nl_bearer_enable,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_BEARER_GET,
+ 		.doit	= tipc_nl_bearer_get,
+ 		.dumpit	= tipc_nl_bearer_dump,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_BEARER_ADD,
+ 		.doit	= tipc_nl_bearer_add,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_BEARER_SET,
+ 		.doit	= tipc_nl_bearer_set,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_SOCK_GET,
+ 		.dumpit	= tipc_nl_sk_dump,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_PUBL_GET,
+ 		.dumpit	= tipc_nl_publ_dump,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_LINK_GET,
+ 		.doit   = tipc_nl_node_get_link,
+ 		.dumpit	= tipc_nl_node_dump_link,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_LINK_SET,
+ 		.doit	= tipc_nl_node_set_link,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_LINK_RESET_STATS,
+ 		.doit   = tipc_nl_node_reset_link_stats,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_MEDIA_GET,
+ 		.doit	= tipc_nl_media_get,
+ 		.dumpit	= tipc_nl_media_dump,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_MEDIA_SET,
+ 		.doit	= tipc_nl_media_set,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_NODE_GET,
+ 		.dumpit	= tipc_nl_node_dump,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_NET_GET,
+ 		.dumpit	= tipc_nl_net_dump,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_NET_SET,
+ 		.doit	= tipc_nl_net_set,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_NAME_TABLE_GET,
+ 		.dumpit	= tipc_nl_name_table_dump,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_MON_SET,
+ 		.doit	= tipc_nl_node_set_monitor,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_MON_GET,
+ 		.doit	= tipc_nl_node_get_monitor,
+ 		.dumpit	= tipc_nl_node_dump_monitor,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_MON_PEER_GET,
+ 		.dumpit	= tipc_nl_node_dump_monitor_peer,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_PEER_REMOVE,
+ 		.doit	= tipc_nl_peer_rm,
+ 		.policy = tipc_nl_policy,
+ 	},
+ #ifdef CONFIG_TIPC_MEDIA_UDP
+ 	{
+ 		.cmd	= TIPC_NL_UDP_GET_REMOTEIP,
+ 		.dumpit	= tipc_udp_nl_dump_remoteip,
+ 		.policy = tipc_nl_policy,
+ 	},
+ #endif
+ };
+ 
+ int tipc_nlmsg_parse(const struct nlmsghdr *nlh, struct nlattr ***attr)
++>>>>>>> a07ea4d9941a (genetlink: no longer support using static family IDs)
  {
 -	u32 maxattr = tipc_genl_family.maxattr;
 +	struct sk_buff *rep_buf;
 +	struct nlmsghdr *rep_nlh;
 +	struct nlmsghdr *req_nlh = info->nlhdr;
 +	struct tipc_genlmsghdr *req_userhdr = info->userhdr;
 +	int hdr_space = nlmsg_total_size(GENL_HDRLEN + TIPC_GENL_HDRLEN);
 +	u16 cmd;
  
 -	*attr = genl_family_attrbuf(&tipc_genl_family);
 -	if (!*attr)
 -		return -EOPNOTSUPP;
 +	if ((req_userhdr->cmd & 0xC000) && (!netlink_capable(skb, CAP_NET_ADMIN)))
 +		cmd = TIPC_CMD_NOT_NET_ADMIN;
 +	else
 +		cmd = req_userhdr->cmd;
  
 -	return nlmsg_parse(nlh, GENL_HDRLEN, *attr, maxattr, tipc_nl_policy);
 +	rep_buf = tipc_cfg_do_cmd(req_userhdr->dest, cmd,
 +			nlmsg_data(req_nlh) + GENL_HDRLEN + TIPC_GENL_HDRLEN,
 +			nlmsg_attrlen(req_nlh, GENL_HDRLEN + TIPC_GENL_HDRLEN),
 +			hdr_space);
 +
 +	if (rep_buf) {
 +		skb_push(rep_buf, hdr_space);
 +		rep_nlh = nlmsg_hdr(rep_buf);
 +		memcpy(rep_nlh, req_nlh, hdr_space);
 +		rep_nlh->nlmsg_len = rep_buf->len;
 +		genlmsg_unicast(&init_net, rep_buf, NETLINK_CB(skb).portid);
 +	}
 +
 +	return 0;
  }
  
 +static struct genl_family tipc_genl_family = {
 +	.id		= GENL_ID_GENERATE,
 +	.name		= TIPC_GENL_NAME,
 +	.version	= TIPC_GENL_VERSION,
 +	.hdrsize	= TIPC_GENL_HDRLEN,
 +	.maxattr	= 0,
 +};
 +
 +static struct genl_ops tipc_genl_ops = {
 +	.cmd		= TIPC_GENL_CMD,
 +	.doit		= handle_cmd,
 +};
 +
 +static int tipc_genl_family_registered;
 +
  int tipc_netlink_start(void)
  {
  	int res;
diff --cc net/wireless/nl80211.c
index aea6305a7568,714beafe05e0..000000000000
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@@ -32,8 -32,21 +32,20 @@@ static int nl80211_crypto_settings(stru
  				   struct cfg80211_crypto_settings *settings,
  				   int cipher_limit);
  
 -static int nl80211_pre_doit(const struct genl_ops *ops, struct sk_buff *skb,
 -			    struct genl_info *info);
 -static void nl80211_post_doit(const struct genl_ops *ops, struct sk_buff *skb,
 -			      struct genl_info *info);
 -
  /* the netlink family */
++<<<<<<< HEAD
 +static struct genl_family nl80211_fam;
++=======
+ static struct genl_family nl80211_fam = {
+ 	.name = NL80211_GENL_NAME,	/* have users key off the name instead */
+ 	.hdrsize = 0,			/* no private header */
+ 	.version = 1,			/* no particular meaning now */
+ 	.maxattr = NL80211_ATTR_MAX,
+ 	.netnsok = true,
+ 	.pre_doit = nl80211_pre_doit,
+ 	.post_doit = nl80211_post_doit,
+ };
++>>>>>>> a07ea4d9941a (genetlink: no longer support using static family IDs)
  
  /* multicast groups */
  enum nl80211_multicast_groups {
* Unmerged path drivers/net/gtp.c
* Unmerged path net/batman-adv/netlink.c
* Unmerged path net/hsr/hsr_netlink.c
* Unmerged path net/ipv6/ila/ila_xlat.c
* Unmerged path net/netlabel/netlabel_calipso.c
* Unmerged path net/tipc/netlink_compat.c
diff --git a/drivers/acpi/event.c b/drivers/acpi/event.c
index 9d55d079b7c4..1acfdb0b3c5a 100644
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@ -177,7 +177,6 @@ static const struct genl_multicast_group acpi_event_mcgrps[] = {
 };
 
 static struct genl_family acpi_event_genl_family = {
-	.id = GENL_ID_GENERATE,
 	.name = ACPI_GENL_FAMILY_NAME,
 	.version = ACPI_GENL_VERSION,
 	.maxattr = ACPI_GENL_ATTR_MAX,
* Unmerged path drivers/net/gtp.c
diff --git a/drivers/net/macsec.c b/drivers/net/macsec.c
index d1090584a65a..7668ac626da7 100644
--- a/drivers/net/macsec.c
+++ b/drivers/net/macsec.c
@@ -1466,7 +1466,6 @@ static void clear_tx_sa(struct macsec_tx_sa *tx_sa)
 }
 
 static struct genl_family macsec_fam = {
-	.id		= GENL_ID_GENERATE,
 	.name		= MACSEC_GENL_NAME,
 	.hdrsize	= 0,
 	.version	= MACSEC_GENL_VERSION,
diff --git a/drivers/net/team/team.c b/drivers/net/team/team.c
index 93f6926b4b66..4cbc18a337c4 100644
--- a/drivers/net/team/team.c
+++ b/drivers/net/team/team.c
@@ -2154,7 +2154,6 @@ static struct rtnl_link_ops team_link_ops __read_mostly = {
  ***********************************/
 
 static struct genl_family team_nl_family = {
-	.id		= GENL_ID_GENERATE,
 	.name		= TEAM_GENL_NAME,
 	.version	= TEAM_GENL_VERSION,
 	.maxattr	= TEAM_ATTR_MAX,
diff --git a/drivers/net/wireless/mac80211_hwsim.c b/drivers/net/wireless/mac80211_hwsim.c
index cb34c7895f2a..17ecb5e8e72f 100644
--- a/drivers/net/wireless/mac80211_hwsim.c
+++ b/drivers/net/wireless/mac80211_hwsim.c
@@ -384,7 +384,6 @@ struct hwsim_radiotap_hdr {
 
 /* MAC80211_HWSIM netlinf family */
 static struct genl_family hwsim_genl_family = {
-	.id = GENL_ID_GENERATE,
 	.hdrsize = 0,
 	.name = "MAC80211_HWSIM",
 	.version = 1,
diff --git a/drivers/scsi/pmcraid.c b/drivers/scsi/pmcraid.c
index 90ece0e487a0..22857db99b6d 100644
--- a/drivers/scsi/pmcraid.c
+++ b/drivers/scsi/pmcraid.c
@@ -1409,12 +1409,6 @@ static struct genl_multicast_group pmcraid_mcgrps[] = {
 };
 
 static struct genl_family pmcraid_event_family = {
-	/*
-	 * Due to prior multicast group abuse (the code having assumed that
-	 * the family ID can be used as a multicast group ID) we need to
-	 * statically allocate a family (and thus group) ID.
-	 */
-	.id = GENL_ID_PMCRAID,
 	.name = "pmcraid",
 	.version = 1,
 	.maxattr = PMCRAID_AEN_ATTR_MAX,
diff --git a/drivers/target/target_core_user.c b/drivers/target/target_core_user.c
index 7dc2f05f8e5e..3c83294e8737 100644
--- a/drivers/target/target_core_user.c
+++ b/drivers/target/target_core_user.c
@@ -276,7 +276,6 @@ static const struct genl_ops tcmu_genl_ops[] = {
 
 /* Our generic netlink family */
 static struct genl_family tcmu_genl_family = {
-	.id = GENL_ID_GENERATE,
 	.hdrsize = 0,
 	.name = "TCM-USER",
 	.version = 2,
diff --git a/drivers/thermal/thermal_core.c b/drivers/thermal/thermal_core.c
index 0dce5095a6a1..0ec6647c079b 100644
--- a/drivers/thermal/thermal_core.c
+++ b/drivers/thermal/thermal_core.c
@@ -1846,7 +1846,6 @@ static const struct genl_multicast_group thermal_event_mcgrps[] = {
 };
 
 static struct genl_family thermal_event_genl_family = {
-	.id = GENL_ID_GENERATE,
 	.name = THERMAL_GENL_FAMILY_NAME,
 	.version = THERMAL_GENL_VERSION,
 	.maxattr = THERMAL_GENL_ATTR_MAX,
diff --git a/fs/dlm/netlink.c b/fs/dlm/netlink.c
index 1e6e227134d7..00d226956264 100644
--- a/fs/dlm/netlink.c
+++ b/fs/dlm/netlink.c
@@ -17,7 +17,6 @@ static uint32_t dlm_nl_seqnum;
 static uint32_t listener_nlportid;
 
 static struct genl_family family = {
-	.id		= GENL_ID_GENERATE,
 	.name		= DLM_GENL_NAME,
 	.version	= DLM_GENL_VERSION,
 };
diff --git a/fs/quota/netlink.c b/fs/quota/netlink.c
index 1117f2b7a126..5237445590c7 100644
--- a/fs/quota/netlink.c
+++ b/fs/quota/netlink.c
@@ -15,13 +15,6 @@ static const struct genl_multicast_group quota_mcgrps[] = {
 
 /* Netlink family structure for quota */
 static struct genl_family quota_genl_family = {
-	/*
-	 * Needed due to multicast group ID abuse - old code assumed
-	 * the family ID was also a valid multicast group ID (which
-	 * isn't true) and userspace might thus rely on it. Assign a
-	 * static ID for this group to make dealing with that easier.
-	 */
-	.id = GENL_ID_VFS_DQUOT,
 	.hdrsize = 0,
 	.name = "VFS_DQUOT",
 	.version = 1,
diff --git a/include/linux/genl_magic_func.h b/include/linux/genl_magic_func.h
index c0894dd8827b..8b2bda5f4fd8 100644
--- a/include/linux/genl_magic_func.h
+++ b/include/linux/genl_magic_func.h
@@ -260,7 +260,6 @@ static struct genl_ops ZZZ_genl_ops[] __read_mostly = {
  */
 #define ZZZ_genl_family		CONCAT_(GENL_MAGIC_FAMILY, _genl_family)
 static struct genl_family ZZZ_genl_family __read_mostly = {
-	.id = GENL_ID_GENERATE,
 	.name = __stringify(GENL_MAGIC_FAMILY),
 	.version = GENL_MAGIC_VERSION,
 #ifdef GENL_MAGIC_FAMILY_HDRSZ
diff --git a/include/net/genetlink.h b/include/net/genetlink.h
index f37e06abcb6d..6afe6f6996c8 100644
--- a/include/net/genetlink.h
+++ b/include/net/genetlink.h
@@ -22,7 +22,7 @@ struct genl_info;
 
 /**
  * struct genl_family - generic netlink family
- * @id: protocol family idenfitier
+ * @id: protocol family identifier (private)
  * @hdrsize: length of user specific header in bytes
  * @name: name of family
  * @version: protocol version
@@ -44,7 +44,7 @@ struct genl_info;
  * @n_ops: number of operations supported by this family (private)
  */
 struct genl_family {
-	unsigned int		id;
+	unsigned int		id;		/* private */
 	unsigned int		hdrsize;
 	char			name[GENL_NAMSIZ];
 	unsigned int		version;
@@ -148,9 +148,6 @@ static inline int genl_register_family(struct genl_family *family)
  * Registers the specified family and operations from the specified table.
  * Only one family may be registered with the same family name or identifier.
  *
- * The family id may equal GENL_ID_GENERATE causing an unique id to
- * be automatically generated and assigned.
- *
  * Either a doit or dumpit callback must be specified for every registered
  * operation or the function will fail. Only one operation structure per
  * command identifier may be registered.
diff --git a/include/uapi/linux/genetlink.h b/include/uapi/linux/genetlink.h
index 5512c90af7e3..d9b2db4a29c6 100644
--- a/include/uapi/linux/genetlink.h
+++ b/include/uapi/linux/genetlink.h
@@ -26,7 +26,6 @@ struct genlmsghdr {
 /*
  * List of reserved static generic netlink identifiers:
  */
-#define GENL_ID_GENERATE	0
 #define GENL_ID_CTRL		NLMSG_MIN_TYPE
 #define GENL_ID_VFS_DQUOT	(NLMSG_MIN_TYPE + 1)
 #define GENL_ID_PMCRAID		(NLMSG_MIN_TYPE + 2)
diff --git a/kernel/taskstats.c b/kernel/taskstats.c
index cc164a5485ab..d012b5e9aede 100644
--- a/kernel/taskstats.c
+++ b/kernel/taskstats.c
@@ -42,7 +42,6 @@ static int family_registered;
 struct kmem_cache *taskstats_cache;
 
 static struct genl_family family = {
-	.id		= GENL_ID_GENERATE,
 	.name		= TASKSTATS_GENL_NAME,
 	.version	= TASKSTATS_GENL_VERSION,
 	.maxattr	= TASKSTATS_CMD_ATTR_MAX,
* Unmerged path net/batman-adv/netlink.c
diff --git a/net/core/devlink.c b/net/core/devlink.c
index df45d8e125ae..3269244ba73e 100644
--- a/net/core/devlink.c
+++ b/net/core/devlink.c
@@ -342,7 +342,6 @@ static void devlink_nl_post_doit(const struct genl_ops *ops,
 }
 
 static struct genl_family devlink_nl_family = {
-	.id		= GENL_ID_GENERATE,
 	.name		= DEVLINK_GENL_NAME,
 	.version	= DEVLINK_GENL_VERSION,
 	.maxattr	= DEVLINK_ATTR_MAX,
diff --git a/net/core/drop_monitor.c b/net/core/drop_monitor.c
index 78701cd2296b..ea1a1e486e57 100644
--- a/net/core/drop_monitor.c
+++ b/net/core/drop_monitor.c
@@ -60,7 +60,6 @@ struct dm_hw_stat_delta {
 };
 
 static struct genl_family net_drop_monitor_family = {
-	.id             = GENL_ID_GENERATE,
 	.hdrsize        = 0,
 	.name           = "NET_DM",
 	.version        = 2,
* Unmerged path net/hsr/hsr_netlink.c
diff --git a/net/ieee802154/netlink.c b/net/ieee802154/netlink.c
index c8133c07ceee..19144158b696 100644
--- a/net/ieee802154/netlink.c
+++ b/net/ieee802154/netlink.c
@@ -29,7 +29,6 @@ static unsigned int ieee802154_seq_num;
 static DEFINE_SPINLOCK(ieee802154_seq_lock);
 
 struct genl_family nl802154_family = {
-	.id		= GENL_ID_GENERATE,
 	.hdrsize	= 0,
 	.name		= IEEE802154_NL_NAME,
 	.version	= 1,
diff --git a/net/ieee802154/nl802154.c b/net/ieee802154/nl802154.c
index 0a289ced1d31..2584de6821e8 100644
--- a/net/ieee802154/nl802154.c
+++ b/net/ieee802154/nl802154.c
@@ -34,7 +34,6 @@ static void nl802154_post_doit(const struct genl_ops *ops, struct sk_buff *skb,
 
 /* the netlink family */
 static struct genl_family nl802154_fam = {
-	.id = GENL_ID_GENERATE,		/* don't bother with a hardcoded ID */
 	.name = NL802154_GENL_NAME,	/* have users key off the name instead */
 	.hdrsize = 0,			/* no private header */
 	.version = 1,			/* no particular meaning now */
diff --git a/net/ipv4/fou.c b/net/ipv4/fou.c
index f471d6929968..47455d3878e0 100644
--- a/net/ipv4/fou.c
+++ b/net/ipv4/fou.c
@@ -546,7 +546,6 @@ static int fou_destroy(struct net *net, struct fou_cfg *cfg)
 }
 
 static struct genl_family fou_nl_family = {
-	.id		= GENL_ID_GENERATE,
 	.hdrsize	= 0,
 	.name		= FOU_GENL_NAME,
 	.version	= FOU_GENL_VERSION,
diff --git a/net/ipv4/tcp_metrics.c b/net/ipv4/tcp_metrics.c
index af7c5919cddc..d51a694ae569 100644
--- a/net/ipv4/tcp_metrics.c
+++ b/net/ipv4/tcp_metrics.c
@@ -736,7 +736,6 @@ void tcp_fastopen_cache_set(struct sock *sk, u16 mss,
 }
 
 static struct genl_family tcp_metrics_nl_family = {
-	.id		= GENL_ID_GENERATE,
 	.hdrsize	= 0,
 	.name		= TCP_METRICS_GENL_NAME,
 	.version	= TCP_METRICS_GENL_VERSION,
* Unmerged path net/ipv6/ila/ila_xlat.c
diff --git a/net/irda/irnetlink.c b/net/irda/irnetlink.c
index c32971269280..81519cd0213f 100644
--- a/net/irda/irnetlink.c
+++ b/net/irda/irnetlink.c
@@ -25,7 +25,6 @@
 
 
 static struct genl_family irda_nl_family = {
-	.id = GENL_ID_GENERATE,
 	.name = IRDA_NL_NAME,
 	.hdrsize = 0,
 	.version = IRDA_NL_VERSION,
diff --git a/net/l2tp/l2tp_netlink.c b/net/l2tp/l2tp_netlink.c
index 4d89df5b3f9c..658d32097691 100644
--- a/net/l2tp/l2tp_netlink.c
+++ b/net/l2tp/l2tp_netlink.c
@@ -32,7 +32,6 @@
 
 
 static struct genl_family l2tp_nl_family = {
-	.id		= GENL_ID_GENERATE,
 	.name		= L2TP_GENL_NAME,
 	.version	= L2TP_GENL_VERSION,
 	.hdrsize	= 0,
diff --git a/net/netfilter/ipvs/ip_vs_ctl.c b/net/netfilter/ipvs/ip_vs_ctl.c
index 95b70320d2ed..1ccb78430fe6 100644
--- a/net/netfilter/ipvs/ip_vs_ctl.c
+++ b/net/netfilter/ipvs/ip_vs_ctl.c
@@ -2813,7 +2813,6 @@ static struct nf_sockopt_ops ip_vs_sockopts = {
 
 /* IPVS genetlink family */
 static struct genl_family ip_vs_genl_family = {
-	.id		= GENL_ID_GENERATE,
 	.hdrsize	= 0,
 	.name		= IPVS_GENL_NAME,
 	.version	= IPVS_GENL_VERSION,
* Unmerged path net/netlabel/netlabel_calipso.c
diff --git a/net/netlabel/netlabel_cipso_v4.c b/net/netlabel/netlabel_cipso_v4.c
index 59738ffdc1d9..a0c9eacf0f66 100644
--- a/net/netlabel/netlabel_cipso_v4.c
+++ b/net/netlabel/netlabel_cipso_v4.c
@@ -61,7 +61,6 @@ struct netlbl_domhsh_walk_arg {
 
 /* NetLabel Generic NETLINK CIPSOv4 family */
 static struct genl_family netlbl_cipsov4_gnl_family = {
-	.id = GENL_ID_GENERATE,
 	.hdrsize = 0,
 	.name = NETLBL_NLTYPE_CIPSOV4_NAME,
 	.version = NETLBL_PROTO_VERSION,
diff --git a/net/netlabel/netlabel_mgmt.c b/net/netlabel/netlabel_mgmt.c
index 2ea2a40e0cdc..c8f46fb6fbf4 100644
--- a/net/netlabel/netlabel_mgmt.c
+++ b/net/netlabel/netlabel_mgmt.c
@@ -60,7 +60,6 @@ struct netlbl_domhsh_walk_arg {
 
 /* NetLabel Generic NETLINK CIPSOv4 family */
 static struct genl_family netlbl_mgmt_gnl_family = {
-	.id = GENL_ID_GENERATE,
 	.hdrsize = 0,
 	.name = NETLBL_NLTYPE_MGMT_NAME,
 	.version = NETLBL_PROTO_VERSION,
diff --git a/net/netlabel/netlabel_unlabeled.c b/net/netlabel/netlabel_unlabeled.c
index 8600bdf8edfd..82f50dfafb34 100644
--- a/net/netlabel/netlabel_unlabeled.c
+++ b/net/netlabel/netlabel_unlabeled.c
@@ -125,7 +125,6 @@ static u8 netlabel_unlabel_acceptflg = 0;
 
 /* NetLabel Generic NETLINK unlabeled family */
 static struct genl_family netlbl_unlabel_gnl_family = {
-	.id = GENL_ID_GENERATE,
 	.hdrsize = 0,
 	.name = NETLBL_NLTYPE_UNLABELED_NAME,
 	.version = NETLBL_PROTO_VERSION,
diff --git a/net/netlink/genetlink.c b/net/netlink/genetlink.c
index a93aabe188f7..d725bbbda2f1 100644
--- a/net/netlink/genetlink.c
+++ b/net/netlink/genetlink.c
@@ -346,8 +346,6 @@ static int genl_validate_ops(const struct genl_family *family)
  *
  * Registers the specified family after validating it first. Only one
  * family may be registered with the same family name or identifier.
- * The family id may equal GENL_ID_GENERATE causing an unique id to
- * be automatically generated and assigned.
  *
  * The family's ops array must already be assigned, you can use the
  * genl_register_family_with_ops() helper function.
@@ -356,13 +354,7 @@ static int genl_validate_ops(const struct genl_family *family)
  */
 int __genl_register_family(struct genl_family *family)
 {
-	int err = -EINVAL, i;
-
-	if (family->id && family->id < GENL_MIN_ID)
-		goto errout;
-
-	if (family->id > GENL_MAX_ID)
-		goto errout;
+	int err, i;
 
 	err = genl_validate_ops(family);
 	if (err)
@@ -375,8 +367,27 @@ int __genl_register_family(struct genl_family *family)
 		goto errout_locked;
 	}
 
-	if (family->id == GENL_ID_GENERATE) {
-		u16 newid = genl_generate_id();
+	if (family == &genl_ctrl) {
+		family->id = GENL_ID_CTRL;
+	} else {
+		u16 newid;
+
+		/* this should be left zero in the struct */
+		WARN_ON(family->id);
+
+		/*
+		 * Sadly, a few cases need to be special-cased
+		 * due to them having previously abused the API
+		 * and having used their family ID also as their
+		 * multicast group ID, so we use reserved IDs
+		 * for both to be sure we can do that mapping.
+		 */
+		if (strcmp(family->name, "pmcraid") == 0)
+			newid = GENL_ID_PMCRAID;
+		else if (strcmp(family->name, "VFS_DQUOT") == 0)
+			newid = GENL_ID_VFS_DQUOT;
+		else
+			newid = genl_generate_id();
 
 		if (!newid) {
 			err = -ENOMEM;
@@ -384,9 +395,6 @@ int __genl_register_family(struct genl_family *family)
 		}
 
 		family->id = newid;
-	} else if (genl_family_find_byid(family->id)) {
-		err = -EEXIST;
-		goto errout_locked;
 	}
 
 	if (family->maxattr && !family->parallel_ops) {
@@ -416,7 +424,6 @@ int __genl_register_family(struct genl_family *family)
 
 errout_locked:
 	genl_unlock_all();
-errout:
 	return err;
 }
 EXPORT_SYMBOL(__genl_register_family);
diff --git a/net/nfc/netlink.c b/net/nfc/netlink.c
index 851f6e469c68..2c854370dd85 100644
--- a/net/nfc/netlink.c
+++ b/net/nfc/netlink.c
@@ -35,7 +35,6 @@ static struct genl_multicast_group nfc_genl_event_mcgrp = {
 };
 
 static struct genl_family nfc_genl_family = {
-	.id = GENL_ID_GENERATE,
 	.hdrsize = 0,
 	.name = NFC_GENL_NAME,
 	.version = NFC_GENL_VERSION,
diff --git a/net/openvswitch/datapath.c b/net/openvswitch/datapath.c
index 538ce415ba26..aaa3a5997088 100644
--- a/net/openvswitch/datapath.c
+++ b/net/openvswitch/datapath.c
@@ -658,7 +658,6 @@ static const struct genl_ops dp_packet_genl_ops[] = {
 };
 
 static struct genl_family dp_packet_genl_family = {
-	.id = GENL_ID_GENERATE,
 	.hdrsize = sizeof(struct ovs_header),
 	.name = OVS_PACKET_FAMILY,
 	.version = OVS_PACKET_VERSION,
@@ -1423,7 +1422,6 @@ static const struct genl_ops dp_flow_genl_ops[] = {
 };
 
 static struct genl_family dp_flow_genl_family = {
-	.id = GENL_ID_GENERATE,
 	.hdrsize = sizeof(struct ovs_header),
 	.name = OVS_FLOW_FAMILY,
 	.version = OVS_FLOW_VERSION,
@@ -1809,7 +1807,6 @@ static const struct genl_ops dp_datapath_genl_ops[] = {
 };
 
 static struct genl_family dp_datapath_genl_family = {
-	.id = GENL_ID_GENERATE,
 	.hdrsize = sizeof(struct ovs_header),
 	.name = OVS_DATAPATH_FAMILY,
 	.version = OVS_DATAPATH_VERSION,
@@ -2231,7 +2228,6 @@ static const struct genl_ops dp_vport_genl_ops[] = {
 };
 
 struct genl_family dp_vport_genl_family = {
-	.id = GENL_ID_GENERATE,
 	.hdrsize = sizeof(struct ovs_header),
 	.name = OVS_VPORT_FAMILY,
 	.version = OVS_VPORT_VERSION,
* Unmerged path net/tipc/netlink.c
* Unmerged path net/tipc/netlink_compat.c
diff --git a/net/wimax/stack.c b/net/wimax/stack.c
index a6470ac39498..9d6b821955b7 100644
--- a/net/wimax/stack.c
+++ b/net/wimax/stack.c
@@ -550,7 +550,6 @@ size_t D_LEVEL_SIZE = ARRAY_SIZE(D_LEVEL);
 
 
 struct genl_family wimax_gnl_family = {
-	.id = GENL_ID_GENERATE,
 	.name = "WiMAX",
 	.version = WIMAX_GNL_VERSION,
 	.hdrsize = 0,
* Unmerged path net/wireless/nl80211.c
