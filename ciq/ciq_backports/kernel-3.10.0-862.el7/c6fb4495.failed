sysfs, kernfs: prepare open, release, poll paths for kernfs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Tejun Heo <tj@kernel.org>
commit c6fb449515f23edea828fb90a460d3622e261dba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c6fb4495.failed

We're in the process of separating out core sysfs functionality into
kernfs which will deal with sysfs_dirents directly.  This patch
prepares the rest - open, release and poll.  There isn't much to do.
Just renaming is enough.  As sysfs_file_operations and
sysfs_bin_operations are identical now, use the same file_operations
for both - kernfs_file_operations.

This patch doesn't introduce any behavior changes.

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit c6fb449515f23edea828fb90a460d3622e261dba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/sysfs/file.c
#	fs/sysfs/inode.c
#	fs/sysfs/sysfs.h
diff --cc fs/sysfs/file.c
index d8887c896abc,a43df04c81f9..000000000000
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@@ -327,12 -668,12 +327,12 @@@ static void sysfs_put_open_dirent(struc
  	kfree(od);
  }
  
- static int sysfs_open_file(struct inode *inode, struct file *file)
+ static int kernfs_file_open(struct inode *inode, struct file *file)
  {
  	struct sysfs_dirent *attr_sd = file->f_path.dentry->d_fsdata;
 -	struct kobject *kobj = attr_sd->s_parent->priv;
 -	struct sysfs_open_file *of;
 -	bool has_read, has_write, has_mmap;
 +	struct kobject *kobj = attr_sd->s_parent->s_dir.kobj;
 +	struct sysfs_buffer *buffer;
 +	const struct sysfs_ops *ops;
  	int error = -EACCES;
  
  	/* need attr_sd for attr and ops, its parent for kobj */
@@@ -396,18 -771,42 +396,18 @@@
  	return error;
  }
  
- static int sysfs_release(struct inode *inode, struct file *filp)
+ static int kernfs_file_release(struct inode *inode, struct file *filp)
  {
  	struct sysfs_dirent *sd = filp->f_path.dentry->d_fsdata;
 -	struct sysfs_open_file *of = sysfs_of(filp);
 -
 -	sysfs_put_open_dirent(sd, of);
 -	seq_release(inode, filp);
 -	kfree(of);
 +	struct sysfs_buffer *buffer = filp->private_data;
  
 -	return 0;
 -}
 +	sysfs_put_open_dirent(sd, buffer);
  
 -void sysfs_unmap_bin_file(struct sysfs_dirent *sd)
 -{
 -	struct sysfs_open_dirent *od;
 -	struct sysfs_open_file *of;
 -
 -	if (!sysfs_is_bin(sd))
 -		return;
 +	if (buffer->page)
 +		free_page((unsigned long)buffer->page);
 +	kfree(buffer);
  
 -	spin_lock_irq(&sysfs_open_dirent_lock);
 -	od = sd->s_attr.open;
 -	if (od)
 -		atomic_inc(&od->refcnt);
 -	spin_unlock_irq(&sysfs_open_dirent_lock);
 -	if (!od)
 -		return;
 -
 -	mutex_lock(&sysfs_open_file_mutex);
 -	list_for_each_entry(of, &od->files, list) {
 -		struct inode *inode = file_inode(of->file);
 -		unmap_mapping_range(inode->i_mapping, 0, 0, 1);
 -	}
 -	mutex_unlock(&sysfs_open_file_mutex);
 -
 -	sysfs_put_open_dirent(sd, NULL);
 +	return 0;
  }
  
  /* Sysfs attribute files are pollable.  The idea is that you read
@@@ -423,9 -822,9 +423,9 @@@
   * to see if it supports poll (Neither 'poll' nor 'select' return
   * an appropriate error code).  When in doubt, set a suitable timeout value.
   */
- static unsigned int sysfs_poll(struct file *filp, poll_table *wait)
+ static unsigned int kernfs_file_poll(struct file *filp, poll_table *wait)
  {
 -	struct sysfs_open_file *of = sysfs_of(filp);
 +	struct sysfs_buffer * buffer = filp->private_data;
  	struct sysfs_dirent *attr_sd = filp->f_path.dentry->d_fsdata;
  	struct sysfs_open_dirent *od = attr_sd->s_attr.open;
  
@@@ -483,56 -881,19 +483,68 @@@ void sysfs_notify(struct kobject *k, co
  }
  EXPORT_SYMBOL_GPL(sysfs_notify);
  
++<<<<<<< HEAD
 +const struct file_operations sysfs_file_operations = {
 +	.read		= sysfs_read_file,
 +	.write		= sysfs_write_file,
 +	.llseek		= generic_file_llseek,
 +	.open		= sysfs_open_file,
 +	.release	= sysfs_release,
 +	.poll		= sysfs_poll,
 +};
 +
 +static int sysfs_attr_ns(struct kobject *kobj, const struct attribute *attr,
 +			 const void **pns)
 +{
 +	struct sysfs_dirent *dir_sd = kobj->sd;
 +	const struct sysfs_ops *ops;
 +	const void *ns = NULL;
 +	int err;
++=======
+ const struct file_operations kernfs_file_operations = {
+ 	.read		= kernfs_file_read,
+ 	.write		= kernfs_file_write,
+ 	.llseek		= generic_file_llseek,
+ 	.mmap		= kernfs_file_mmap,
+ 	.open		= kernfs_file_open,
+ 	.release	= kernfs_file_release,
+ 	.poll		= kernfs_file_poll,
+ };
++>>>>>>> c6fb449515f2 (sysfs, kernfs: prepare open, release, poll paths for kernfs)
 +
 +	if (!dir_sd) {
 +		WARN(1, KERN_ERR "sysfs: kobject %s without dirent\n",
 +			kobject_name(kobj));
 +		return -ENOENT;
 +	}
  
 -int sysfs_add_file_mode_ns(struct sysfs_dirent *dir_sd,
 -			   const struct attribute *attr, int type,
 -			   umode_t amode, const void *ns)
 +	err = 0;
 +	if (!sysfs_ns_type(dir_sd))
 +		goto out;
 +
 +	err = -EINVAL;
 +	if (!kobj->ktype)
 +		goto out;
 +	ops = kobj->ktype->sysfs_ops;
 +	if (!ops)
 +		goto out;
 +	if (!ops->namespace)
 +		goto out;
 +
 +	err = 0;
 +	ns = ops->namespace(kobj, attr);
 +out:
 +	if (err) {
 +		WARN(1, KERN_ERR
 +		     "missing sysfs namespace attribute operation for kobject: %s\n",
 +		     kobject_name(kobj));
 +	}
 +	*pns = ns;
 +	return err;
 +}
 +
 +int sysfs_add_file_mode(struct sysfs_dirent *dir_sd,
 +			const struct attribute *attr, int type, umode_t amode)
  {
  	umode_t mode = (amode & S_IALLUGO) | S_IFREG;
  	struct sysfs_addrm_cxt acxt;
diff --cc fs/sysfs/inode.c
index 15a606d56f5d,4c463dabfc6a..000000000000
--- a/fs/sysfs/inode.c
+++ b/fs/sysfs/inode.c
@@@ -253,12 -272,12 +253,16 @@@ static void sysfs_init_inode(struct sys
  		break;
  	case SYSFS_KOBJ_ATTR:
  		inode->i_size = PAGE_SIZE;
- 		inode->i_fop = &sysfs_file_operations;
+ 		inode->i_fop = &kernfs_file_operations;
  		break;
  	case SYSFS_KOBJ_BIN_ATTR:
 -		bin_attr = sd->priv;
 +		bin_attr = sd->s_bin_attr.bin_attr;
  		inode->i_size = bin_attr->size;
++<<<<<<< HEAD
 +		inode->i_fop = &bin_fops;
++=======
+ 		inode->i_fop = &kernfs_file_operations;
++>>>>>>> c6fb449515f2 (sysfs, kernfs: prepare open, release, poll paths for kernfs)
  		break;
  	case SYSFS_KOBJ_LINK:
  		inode->i_op = &sysfs_symlink_inode_operations;
diff --cc fs/sysfs/sysfs.h
index e18c3f38727c,619250d2d7c1..000000000000
--- a/fs/sysfs/sysfs.h
+++ b/fs/sysfs/sysfs.h
@@@ -224,7 -212,7 +224,11 @@@ int sysfs_inode_init(void)
  /*
   * file.c
   */
++<<<<<<< HEAD
 +extern const struct file_operations sysfs_file_operations;
++=======
+ extern const struct file_operations kernfs_file_operations;
++>>>>>>> c6fb449515f2 (sysfs, kernfs: prepare open, release, poll paths for kernfs)
  
  int sysfs_add_file(struct sysfs_dirent *dir_sd,
  		   const struct attribute *attr, int type);
* Unmerged path fs/sysfs/file.c
* Unmerged path fs/sysfs/inode.c
* Unmerged path fs/sysfs/sysfs.h
