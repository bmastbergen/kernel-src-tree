DLM: Fix saving of NULL callbacks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Bob Peterson <rpeterso@redhat.com>
commit cc661fc934a004526a714a7b804ee3f119d27093
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/cc661fc9.failed

In a previous patch I noted that accept() often copies the struct
sock (sk) which overwrites the sock callbacks. However, in testing
we discovered that the dlm connection structures (con) are sometimes
deleted and recreated as connections come and go, and since they're
zeroed out by kmem_cache_zalloc, the saved callback pointers are
also initialized to zero. But with today's DLM code, the callbacks
are only saved when a socket is added.

During recovery testing, we discovered a common situation in which
the new con is initialized to zero, then a socket is added after
accept(). In this case, the sock's saved values are all NULL, but
the saved values are wiped out, due to accept(). Therefore, we
don't have a known good copy of the callbacks from which we can
restore.

Since the struct sock callbacks are always good after listen(),
this patch saves the known good values after listen(). These good
values are then used for subsequent restores.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
	Reviewed-by: Tadashi Miyauchi <miyauchi@toshiba-tops.co.jp>
	Signed-off-by: David Teigland <teigland@redhat.com>
(cherry picked from commit cc661fc934a004526a714a7b804ee3f119d27093)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dlm/lowcomms.c
diff --cc fs/dlm/lowcomms.c
index b5e7293f2f80,32b534f4a9b6..000000000000
--- a/fs/dlm/lowcomms.c
+++ b/fs/dlm/lowcomms.c
@@@ -124,10 -122,6 +124,13 @@@ struct connection 
  	struct connection *othercon;
  	struct work_struct rwork; /* Receive workqueue */
  	struct work_struct swork; /* Send workqueue */
++<<<<<<< HEAD
 +	void (*orig_error_report)(struct sock *);
 +	void (*orig_data_ready)(struct sock *, int);
 +	void (*orig_state_change)(struct sock *);
 +	void (*orig_write_space)(struct sock *);
++=======
++>>>>>>> cc661fc934a0 (DLM: Fix saving of NULL callbacks)
  };
  #define sock2con(x) ((struct connection *)(x)->sk_user_data)
  
@@@ -545,8 -549,6 +559,11 @@@ static void add_sock(struct socket *soc
  	con->sock = sock;
  
  	sk->sk_user_data = con;
++<<<<<<< HEAD
 +	if (!test_bit(CF_IS_OTHERCON, &con->flags))
 +		save_callbacks(con, sk);
++=======
++>>>>>>> cc661fc934a0 (DLM: Fix saving of NULL callbacks)
  	/* Install a data_ready callback */
  	sk->sk_data_ready = lowcomms_data_ready;
  	sk->sk_write_space = lowcomms_write_space;
* Unmerged path fs/dlm/lowcomms.c
