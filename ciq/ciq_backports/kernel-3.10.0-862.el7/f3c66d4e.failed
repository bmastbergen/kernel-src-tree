l2tp: prevent creation of sessions on terminated tunnels

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Guillaume Nault <g.nault@alphalink.fr>
commit f3c66d4e144a0904ea9b95d23ed9f8eb38c11bfb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f3c66d4e.failed

l2tp_tunnel_destruct() sets tunnel->sock to NULL, then removes the
tunnel from the pernet list and finally closes all its sessions.
Therefore, it's possible to add a session to a tunnel that is still
reachable, but for which tunnel->sock has already been reset. This can
make l2tp_session_create() dereference a NULL pointer when calling
sock_hold(tunnel->sock).

This patch adds the .acpt_newsess field to struct l2tp_tunnel, which is
used by l2tp_tunnel_closeall() to prevent addition of new sessions to
tunnels. Resetting tunnel->sock is done after l2tp_tunnel_closeall()
returned, so that l2tp_session_add_to_tunnel() can safely take a
reference on it when .acpt_newsess is true.

The .acpt_newsess field is modified in l2tp_tunnel_closeall(), rather
than in l2tp_tunnel_destruct(), so that it benefits all tunnel removal
mechanisms. E.g. on UDP tunnels, a session could be added to a tunnel
after l2tp_udp_encap_destroy() proceeded. This would prevent the tunnel
from being removed because of the references held by this new session
on the tunnel and its socket. Even though the session could be removed
manually later on, this defeats the purpose of
commit 9980d001cec8 ("l2tp: add udp encap socket destroy handler").

Fixes: fd558d186df2 ("l2tp: Split pppol2tp patch into separate l2tp and ppp parts")
	Signed-off-by: Guillaume Nault <g.nault@alphalink.fr>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f3c66d4e144a0904ea9b95d23ed9f8eb38c11bfb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/l2tp/l2tp_core.c
diff --cc net/l2tp/l2tp_core.c
index 0968b39152ba,ee485df73ccd..000000000000
--- a/net/l2tp/l2tp_core.c
+++ b/net/l2tp/l2tp_core.c
@@@ -1840,15 -1849,6 +1860,18 @@@ struct l2tp_session *l2tp_session_creat
  			return ERR_PTR(err);
  		}
  
++<<<<<<< HEAD
 +		/* Bump the reference count. The session context is deleted
 +		 * only when this drops to zero.
 +		 */
 +		l2tp_session_inc_refcount(session);
 +		l2tp_tunnel_inc_refcount(tunnel);
 +
 +		/* Ensure tunnel socket isn't deleted */
 +		sock_hold(tunnel->sock);
 +
++=======
++>>>>>>> f3c66d4e144a (l2tp: prevent creation of sessions on terminated tunnels)
  		/* Ignore management session in session count value */
  		if (session->session_id != 0)
  			atomic_inc(&l2tp_session_count);
* Unmerged path net/l2tp/l2tp_core.c
diff --git a/net/l2tp/l2tp_core.h b/net/l2tp/l2tp_core.h
index 0733c826b163..5bf8dfa89090 100644
--- a/net/l2tp/l2tp_core.h
+++ b/net/l2tp/l2tp_core.h
@@ -166,6 +166,10 @@ struct l2tp_tunnel {
 	int			magic;		/* Should be L2TP_TUNNEL_MAGIC */
 	struct rcu_head rcu;
 	rwlock_t		hlist_lock;	/* protect session_hlist */
+	bool			acpt_newsess;	/* Indicates whether this
+						 * tunnel accepts new sessions.
+						 * Protected by hlist_lock.
+						 */
 	struct hlist_head	session_hlist[L2TP_HASH_SIZE];
 						/* hashed list of sessions,
 						 * hashed by id */
