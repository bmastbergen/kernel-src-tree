RDMA/core: Add and expose static device index

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [infiniband] core: Add and expose static device index (Don Dutile) [1499364]
Rebuild_FUZZ: 94.12%
commit-author Leon Romanovsky <leonro@mellanox.com>
commit ecc82c53f9a4ce08ba7df626a4262c86841ced8f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ecc82c53.failed

This patch adds static device index in similar fashion to
already available in netdev world (struct net->ifindex).

In downstream patches, the RDMA nelink will use this idx-to-ib_device
conversion, so as part of this commit, we are exposing the translation
function to be visible for IB/core users.

	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
(cherry picked from commit ecc82c53f9a4ce08ba7df626a4262c86841ced8f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/core_priv.h
#	include/rdma/ib_verbs.h
diff --cc drivers/infiniband/core/core_priv.h
index fb6b0ab22857,cbdcc81e1df8..000000000000
--- a/drivers/infiniband/core/core_priv.h
+++ b/drivers/infiniband/core/core_priv.h
@@@ -167,4 -207,111 +167,114 @@@ int ib_nl_handle_ip_res_resp(struct sk_
  int ib_get_cached_subnet_prefix(struct ib_device *device,
  				u8                port_num,
  				u64              *sn_pfx);
++<<<<<<< HEAD
++=======
+ 
+ #ifdef CONFIG_SECURITY_INFINIBAND
+ int ib_security_pkey_access(struct ib_device *dev,
+ 			    u8 port_num,
+ 			    u16 pkey_index,
+ 			    void *sec);
+ 
+ void ib_security_destroy_port_pkey_list(struct ib_device *device);
+ 
+ void ib_security_cache_change(struct ib_device *device,
+ 			      u8 port_num,
+ 			      u64 subnet_prefix);
+ 
+ int ib_security_modify_qp(struct ib_qp *qp,
+ 			  struct ib_qp_attr *qp_attr,
+ 			  int qp_attr_mask,
+ 			  struct ib_udata *udata);
+ 
+ int ib_create_qp_security(struct ib_qp *qp, struct ib_device *dev);
+ void ib_destroy_qp_security_begin(struct ib_qp_security *sec);
+ void ib_destroy_qp_security_abort(struct ib_qp_security *sec);
+ void ib_destroy_qp_security_end(struct ib_qp_security *sec);
+ int ib_open_shared_qp_security(struct ib_qp *qp, struct ib_device *dev);
+ void ib_close_shared_qp_security(struct ib_qp_security *sec);
+ int ib_mad_agent_security_setup(struct ib_mad_agent *agent,
+ 				enum ib_qp_type qp_type);
+ void ib_mad_agent_security_cleanup(struct ib_mad_agent *agent);
+ int ib_mad_enforce_security(struct ib_mad_agent_private *map, u16 pkey_index);
+ #else
+ static inline int ib_security_pkey_access(struct ib_device *dev,
+ 					  u8 port_num,
+ 					  u16 pkey_index,
+ 					  void *sec)
+ {
+ 	return 0;
+ }
+ 
+ static inline void ib_security_destroy_port_pkey_list(struct ib_device *device)
+ {
+ }
+ 
+ static inline void ib_security_cache_change(struct ib_device *device,
+ 					    u8 port_num,
+ 					    u64 subnet_prefix)
+ {
+ }
+ 
+ static inline int ib_security_modify_qp(struct ib_qp *qp,
+ 					struct ib_qp_attr *qp_attr,
+ 					int qp_attr_mask,
+ 					struct ib_udata *udata)
+ {
+ 	return qp->device->modify_qp(qp->real_qp,
+ 				     qp_attr,
+ 				     qp_attr_mask,
+ 				     udata);
+ }
+ 
+ static inline int ib_create_qp_security(struct ib_qp *qp,
+ 					struct ib_device *dev)
+ {
+ 	return 0;
+ }
+ 
+ static inline void ib_destroy_qp_security_begin(struct ib_qp_security *sec)
+ {
+ }
+ 
+ static inline void ib_destroy_qp_security_abort(struct ib_qp_security *sec)
+ {
+ }
+ 
+ static inline void ib_destroy_qp_security_end(struct ib_qp_security *sec)
+ {
+ }
+ 
+ static inline int ib_open_shared_qp_security(struct ib_qp *qp,
+ 					     struct ib_device *dev)
+ {
+ 	return 0;
+ }
+ 
+ static inline void ib_close_shared_qp_security(struct ib_qp_security *sec)
+ {
+ }
+ 
+ static inline int ib_mad_agent_security_setup(struct ib_mad_agent *agent,
+ 					      enum ib_qp_type qp_type)
+ {
+ 	return 0;
+ }
+ 
+ static inline void ib_mad_agent_security_cleanup(struct ib_mad_agent *agent)
+ {
+ }
+ 
+ static inline int ib_mad_enforce_security(struct ib_mad_agent_private *map,
+ 					  u16 pkey_index)
+ {
+ 	return 0;
+ }
+ #endif
+ 
+ struct ib_device *__ib_device_get_by_index(u32 ifindex);
+ /* RDMA device netlink */
+ void nldev_init(void);
+ void nldev_exit(void);
++>>>>>>> ecc82c53f9a4 (RDMA/core: Add and expose static device index)
  #endif /* _CORE_PRIV_H */
diff --cc include/rdma/ib_verbs.h
index 9d98b1e7b1da,3391df5fdc9c..000000000000
--- a/include/rdma/ib_verbs.h
+++ b/include/rdma/ib_verbs.h
@@@ -2199,6 -2294,12 +2199,15 @@@ struct ib_device 
  	struct attribute_group	     *hw_stats_ag;
  	struct rdma_hw_stats         *hw_stats;
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_CGROUP_RDMA
+ 	struct rdmacg_device         cg_device;
+ #endif
+ 
+ 	u32                          index;
+ 
++>>>>>>> ecc82c53f9a4 (RDMA/core: Add and expose static device index)
  	/**
  	 * The following mandatory functions are used only at device
  	 * registration.  Keep functions such as these at the end of this
* Unmerged path drivers/infiniband/core/core_priv.h
diff --git a/drivers/infiniband/core/device.c b/drivers/infiniband/core/device.c
index a4559eda966e..a04b09ba39e0 100644
--- a/drivers/infiniband/core/device.c
+++ b/drivers/infiniband/core/device.c
@@ -124,6 +124,17 @@ static int ib_device_check_mandatory(struct ib_device *device)
 	return 0;
 }
 
+struct ib_device *__ib_device_get_by_index(u32 index)
+{
+	struct ib_device *device;
+
+	list_for_each_entry(device, &device_list, core_list)
+		if (device->index == index)
+			return device;
+
+	return NULL;
+}
+
 static struct ib_device *__ib_device_get_by_name(const char *name)
 {
 	struct ib_device *device;
@@ -135,7 +146,6 @@ static struct ib_device *__ib_device_get_by_name(const char *name)
 	return NULL;
 }
 
-
 static int alloc_name(char *name)
 {
 	unsigned long *inuse;
@@ -317,6 +327,30 @@ void ib_get_device_fw_str(struct ib_device *dev, char *str, size_t str_len)
 }
 EXPORT_SYMBOL(ib_get_device_fw_str);
 
+/**
+ *	__dev_new_index	-	allocate an device index
+ *
+ *	Returns a suitable unique value for a new device interface
+ *	number.  It assumes that there are less than 2^32-1 ib devices
+ *	will be present in the system.
+ */
+static u32 __dev_new_index(void)
+{
+	/*
+	 * The device index to allow stable naming.
+	 * Similar to struct net -> ifindex.
+	 */
+	static u32 index;
+
+	for (;;) {
+		if (!(++index))
+			index = 1;
+
+		if (!__ib_device_get_by_index(index))
+			return index;
+	}
+}
+
 /**
  * ib_register_device - Register an IB device with IB core
  * @device:Device to register
@@ -390,6 +424,7 @@ int ib_register_device(struct ib_device *device,
 		if (client->add && !add_client_context(device, client))
 			client->add(device);
 
+	device->index = __dev_new_index();
 	down_write(&lists_rwsem);
 	list_add_tail(&device->core_list, &device_list);
 	up_write(&lists_rwsem);
* Unmerged path include/rdma/ib_verbs.h
