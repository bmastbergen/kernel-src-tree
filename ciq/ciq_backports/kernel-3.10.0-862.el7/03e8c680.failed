qla2xxx: Add FW resource count in DebugFS.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Add FW resource count in DebugFS (Himanshu Madhani) [1327621]
Rebuild_FUZZ: 98.80%
commit-author Quinn Tran <quinn.tran@qlogic.com>
commit 03e8c680d9b3b68ddae648a6e2c91c381e90066f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/03e8c680.failed

DebugFS now will show fw_resource_count node.

FW Resource count

Original TGT exchg count[0]
current TGT exchg count[0]
original Initiator Exchange count[2048]
Current Initiator Exchange count[2048]
Original IOCB count[2078]
Current IOCB count[2067]
MAX VP count[254]
MAX FCF count[0]

	Signed-off-by: Quinn Tran <quinn.tran@qlogic.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@qlogic.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 03e8c680d9b3b68ddae648a6e2c91c381e90066f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_dfs.c
#	drivers/scsi/qla2xxx/qla_init.c
#	drivers/scsi/qla2xxx/qla_target.c
#	drivers/scsi/qla2xxx/tcm_qla2xxx.c
diff --cc drivers/scsi/qla2xxx/qla_def.h
index 9cf0dee11112,8e89848131b4..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -2967,9 -2905,22 +2967,19 @@@ struct qlt_hw_data 
  	uint8_t saved_add_firmware_options[2];
  
  	uint8_t tgt_node_name[WWN_SIZE];
 -
 -	struct list_head q_full_list;
 -	uint32_t num_pend_cmds;
 -	uint32_t num_qfull_cmds_alloc;
 -	uint32_t num_qfull_cmds_dropped;
 -	spinlock_t q_full_lock;
 -	uint32_t leak_exchg_thresh_hold;
 +	int rspq_vector_cpuid;
  };
  
++<<<<<<< HEAD
++=======
+ #define MAX_QFULL_CMDS_ALLOC	8192
+ #define Q_FULL_THRESH_HOLD_PERCENT 90
+ #define Q_FULL_THRESH_HOLD(ha) \
+ 	((ha->cur_fw_xcb_count/100) * Q_FULL_THRESH_HOLD_PERCENT)
+ 
+ #define LEAK_EXCHG_THRESH_HOLD_PERCENT 75	/* 75 percent */
+ 
++>>>>>>> 03e8c680d9b3 (qla2xxx: Add FW resource count in DebugFS.)
  /*
   * Qlogic host adapter specific data structure.
  */
@@@ -3384,6 -3348,9 +3400,12 @@@ struct qla_hw_data 
  	uint32_t	chain_offset;
  	struct dentry *dfs_dir;
  	struct dentry *dfs_fce;
++<<<<<<< HEAD
++=======
+ 	struct dentry *dfs_tgt_counters;
+ 	struct dentry *dfs_fw_resource_cnt;
+ 
++>>>>>>> 03e8c680d9b3 (qla2xxx: Add FW resource count in DebugFS.)
  	dma_addr_t	fce_dma;
  	void		*fce;
  	uint32_t	fce_bufs;
diff --cc drivers/scsi/qla2xxx/qla_dfs.c
index 2ca39b8e7166,cd8b96a4b0dd..000000000000
--- a/drivers/scsi/qla2xxx/qla_dfs.c
+++ b/drivers/scsi/qla2xxx/qla_dfs.c
@@@ -13,6 -13,85 +13,88 @@@ static struct dentry *qla2x00_dfs_root
  static atomic_t qla2x00_dfs_root_count;
  
  static int
++<<<<<<< HEAD
++=======
+ qla_dfs_fw_resource_cnt_show(struct seq_file *s, void *unused)
+ {
+ 	struct scsi_qla_host *vha = s->private;
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	seq_puts(s, "FW Resource count\n\n");
+ 	seq_printf(s, "Original TGT exchg count[%d]\n",
+ 	    ha->orig_fw_tgt_xcb_count);
+ 	seq_printf(s, "current TGT exchg count[%d]\n",
+ 	    ha->cur_fw_tgt_xcb_count);
+ 	seq_printf(s, "original Initiator Exchange count[%d]\n",
+ 	    ha->orig_fw_xcb_count);
+ 	seq_printf(s, "Current Initiator Exchange count[%d]\n",
+ 	    ha->cur_fw_xcb_count);
+ 	seq_printf(s, "Original IOCB count[%d]\n", ha->orig_fw_iocb_count);
+ 	seq_printf(s, "Current IOCB count[%d]\n", ha->cur_fw_iocb_count);
+ 	seq_printf(s, "MAX VP count[%d]\n", ha->max_npiv_vports);
+ 	seq_printf(s, "MAX FCF count[%d]\n", ha->fw_max_fcf_count);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ qla_dfs_fw_resource_cnt_open(struct inode *inode, struct file *file)
+ {
+ 	struct scsi_qla_host *vha = inode->i_private;
+ 	return single_open(file, qla_dfs_fw_resource_cnt_show, vha);
+ }
+ 
+ static const struct file_operations dfs_fw_resource_cnt_ops = {
+ 	.open           = qla_dfs_fw_resource_cnt_open,
+ 	.read           = seq_read,
+ 	.llseek         = seq_lseek,
+ 	.release        = single_release,
+ };
+ 
+ static int
+ qla_dfs_tgt_counters_show(struct seq_file *s, void *unused)
+ {
+ 	struct scsi_qla_host *vha = s->private;
+ 
+ 	seq_puts(s, "Target Counters\n");
+ 	seq_printf(s, "qla_core_sbt_cmd = %lld\n",
+ 		vha->tgt_counters.qla_core_sbt_cmd);
+ 	seq_printf(s, "qla_core_ret_sta_ctio = %lld\n",
+ 		vha->tgt_counters.qla_core_ret_sta_ctio);
+ 	seq_printf(s, "qla_core_ret_ctio = %lld\n",
+ 		vha->tgt_counters.qla_core_ret_ctio);
+ 	seq_printf(s, "core_qla_que_buf = %lld\n",
+ 		vha->tgt_counters.core_qla_que_buf);
+ 	seq_printf(s, "core_qla_snd_status = %lld\n",
+ 		vha->tgt_counters.core_qla_snd_status);
+ 	seq_printf(s, "core_qla_free_cmd = %lld\n",
+ 		vha->tgt_counters.core_qla_free_cmd);
+ 	seq_printf(s, "num alloc iocb failed = %lld\n",
+ 		vha->tgt_counters.num_alloc_iocb_failed);
+ 	seq_printf(s, "num term exchange sent = %lld\n",
+ 		vha->tgt_counters.num_term_xchg_sent);
+ 	seq_printf(s, "num Q full sent = %lld\n",
+ 		vha->tgt_counters.num_q_full_sent);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ qla_dfs_tgt_counters_open(struct inode *inode, struct file *file)
+ {
+ 	struct scsi_qla_host *vha = inode->i_private;
+ 	return single_open(file, qla_dfs_tgt_counters_show, vha);
+ }
+ 
+ static const struct file_operations dfs_tgt_counters_ops = {
+ 	.open           = qla_dfs_tgt_counters_open,
+ 	.read           = seq_read,
+ 	.llseek         = seq_lseek,
+ 	.release        = single_release,
+ };
+ 
+ static int
++>>>>>>> 03e8c680d9b3 (qla2xxx: Add FW resource count in DebugFS.)
  qla2x00_dfs_fce_show(struct seq_file *s, void *unused)
  {
  	scsi_qla_host_t *vha = s->private;
@@@ -146,6 -225,22 +228,25 @@@ create_dir
  	atomic_inc(&qla2x00_dfs_root_count);
  
  create_nodes:
++<<<<<<< HEAD
++=======
+ 	ha->dfs_fw_resource_cnt = debugfs_create_file("fw_resource_count",
+ 	    S_IRUSR, ha->dfs_dir, vha, &dfs_fw_resource_cnt_ops);
+ 	if (!ha->dfs_fw_resource_cnt) {
+ 		ql_log(ql_log_warn, vha, 0x00fd,
+ 		    "Unable to create debugFS fw_resource_count node.\n");
+ 		goto out;
+ 	}
+ 
+ 	ha->dfs_tgt_counters = debugfs_create_file("tgt_counters", S_IRUSR,
+ 	    ha->dfs_dir, vha, &dfs_tgt_counters_ops);
+ 	if (!ha->dfs_tgt_counters) {
+ 		ql_log(ql_log_warn, vha, 0xd301,
+ 		    "Unable to create debugFS tgt_counters node.\n");
+ 		goto out;
+ 	}
+ 
++>>>>>>> 03e8c680d9b3 (qla2xxx: Add FW resource count in DebugFS.)
  	ha->dfs_fce = debugfs_create_file("fce", S_IRUSR, ha->dfs_dir, vha,
  	    &dfs_fce_ops);
  	if (!ha->dfs_fce) {
@@@ -161,6 -256,17 +262,20 @@@ in
  qla2x00_dfs_remove(scsi_qla_host_t *vha)
  {
  	struct qla_hw_data *ha = vha->hw;
++<<<<<<< HEAD
++=======
+ 
+ 	if (ha->dfs_fw_resource_cnt) {
+ 		debugfs_remove(ha->dfs_fw_resource_cnt);
+ 		ha->dfs_fw_resource_cnt = NULL;
+ 	}
+ 
+ 	if (ha->dfs_tgt_counters) {
+ 		debugfs_remove(ha->dfs_tgt_counters);
+ 		ha->dfs_tgt_counters = NULL;
+ 	}
+ 
++>>>>>>> 03e8c680d9b3 (qla2xxx: Add FW resource count in DebugFS.)
  	if (ha->dfs_fce) {
  		debugfs_remove(ha->dfs_fce);
  		ha->dfs_fce = NULL;
diff --cc drivers/scsi/qla2xxx/qla_init.c
index ea8080a1a353,35d1ea8a58d1..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -1761,13 -1762,14 +1761,13 @@@ qla2x00_alloc_outstanding_cmds(struct q
  	if (req->outstanding_cmds)
  		return QLA_SUCCESS;
  
 -	if (!IS_FWI2_CAPABLE(ha) || (ha->mqiobase &&
 -	    (ql2xmultique_tag || ql2xmaxqueues > 1)))
 +	if (!IS_FWI2_CAPABLE(ha))
  		req->num_outstanding_cmds = DEFAULT_OUTSTANDING_COMMANDS;
  	else {
- 		if (ha->fw_xcb_count <= ha->fw_iocb_count)
- 			req->num_outstanding_cmds = ha->fw_xcb_count;
+ 		if (ha->cur_fw_xcb_count <= ha->cur_fw_iocb_count)
+ 			req->num_outstanding_cmds = ha->cur_fw_xcb_count;
  		else
- 			req->num_outstanding_cmds = ha->fw_iocb_count;
+ 			req->num_outstanding_cmds = ha->cur_fw_iocb_count;
  	}
  
  	req->outstanding_cmds = kzalloc(sizeof(srb_t *) *
@@@ -2282,14 -2260,14 +2280,23 @@@ qla2x00_init_rings(scsi_qla_host_t *vha
  	if (IS_FWI2_CAPABLE(ha)) {
  		mid_init_cb->options = cpu_to_le16(BIT_1);
  		mid_init_cb->init_cb.execution_throttle =
++<<<<<<< HEAD
 +		    cpu_to_le16(ha->fw_xcb_count);
 +		ha->flags.dport_enabled =
 +		    (mid_init_cb->init_cb.firmware_options_1 & BIT_7) != 0;
 +		ql_dbg(ql_dbg_init, vha, 0x0191, "DPORT Support: %s.\n",
 +		    (ha->flags.dport_enabled) ? "enabled" : "disabled");
 +		/* FA-WWPN Status */
++=======
+ 		    cpu_to_le16(ha->cur_fw_xcb_count);
+ 		/* D-Port Status */
+ 		if (IS_DPORT_CAPABLE(ha))
+ 			mid_init_cb->init_cb.firmware_options_1 |=
+ 			    cpu_to_le16(BIT_7);
+ 		/* Enable FA-WWPN */
++>>>>>>> 03e8c680d9b3 (qla2xxx: Add FW resource count in DebugFS.)
  		ha->flags.fawwpn_enabled =
 -		    (mid_init_cb->init_cb.firmware_options_1 & BIT_6) ? 1 : 0;
 +		    (mid_init_cb->init_cb.firmware_options_1 & BIT_6) != 0;
  		ql_dbg(ql_dbg_init, vha, 0x0141, "FA-WWPN Support: %s.\n",
  		    (ha->flags.fawwpn_enabled) ? "enabled" : "disabled");
  	}
diff --cc drivers/scsi/qla2xxx/qla_target.c
index 4e0d4c3c5146,661124afae90..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -2292,13 -3024,100 +2292,81 @@@ done
  	return;
  }
  
++<<<<<<< HEAD
++=======
+ static void qlt_init_term_exchange(struct scsi_qla_host *vha)
+ {
+ 	struct list_head free_list;
+ 	struct qla_tgt_cmd *cmd, *tcmd;
+ 
+ 	vha->hw->tgt.leak_exchg_thresh_hold =
+ 	    (vha->hw->cur_fw_xcb_count/100) * LEAK_EXCHG_THRESH_HOLD_PERCENT;
+ 
+ 	cmd = tcmd = NULL;
+ 	if (!list_empty(&vha->hw->tgt.q_full_list)) {
+ 		INIT_LIST_HEAD(&free_list);
+ 		list_splice_init(&vha->hw->tgt.q_full_list, &free_list);
+ 
+ 		list_for_each_entry_safe(cmd, tcmd, &free_list, cmd_list) {
+ 			list_del(&cmd->cmd_list);
+ 			/* This cmd was never sent to TCM.  There is no need
+ 			 * to schedule free or call free_cmd
+ 			 */
+ 			qlt_free_cmd(cmd);
+ 			vha->hw->tgt.num_qfull_cmds_alloc--;
+ 		}
+ 	}
+ 	vha->hw->tgt.num_qfull_cmds_dropped = 0;
+ }
+ 
+ static void qlt_chk_exch_leak_thresh_hold(struct scsi_qla_host *vha)
+ {
+ 	uint32_t total_leaked;
+ 
+ 	total_leaked = vha->hw->tgt.num_qfull_cmds_dropped;
+ 
+ 	if (vha->hw->tgt.leak_exchg_thresh_hold &&
+ 	    (total_leaked > vha->hw->tgt.leak_exchg_thresh_hold)) {
+ 
+ 		ql_dbg(ql_dbg_tgt, vha, 0xe079,
+ 		    "Chip reset due to exchange starvation: %d/%d.\n",
+ 		    total_leaked, vha->hw->cur_fw_xcb_count);
+ 
+ 		if (IS_P3P_TYPE(vha->hw))
+ 			set_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags);
+ 		else
+ 			set_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);
+ 		qla2xxx_wake_dpc(vha);
+ 	}
+ 
+ }
+ 
+ void qlt_abort_cmd(struct qla_tgt_cmd *cmd)
+ {
+ 	struct qla_tgt *tgt = cmd->tgt;
+ 	struct scsi_qla_host *vha = tgt->vha;
+ 	struct se_cmd *se_cmd = &cmd->se_cmd;
+ 
+ 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf014,
+ 	    "qla_target(%d): terminating exchange for aborted cmd=%p "
+ 	    "(se_cmd=%p, tag=%llu)", vha->vp_idx, cmd, &cmd->se_cmd,
+ 	    se_cmd->tag);
+ 
+ 	cmd->state = QLA_TGT_STATE_ABORTED;
+ 	cmd->cmd_flags |= BIT_6;
+ 
+ 	qlt_send_term_exchange(vha, cmd, &cmd->atio, 0);
+ }
+ EXPORT_SYMBOL(qlt_abort_cmd);
+ 
++>>>>>>> 03e8c680d9b3 (qla2xxx: Add FW resource count in DebugFS.)
  void qlt_free_cmd(struct qla_tgt_cmd *cmd)
  {
 -	struct qla_tgt_sess *sess = cmd->sess;
 -
 -	ql_dbg(ql_dbg_tgt, cmd->vha, 0xe074,
 -	    "%s: se_cmd[%p] ox_id %04x\n",
 -	    __func__, &cmd->se_cmd,
 -	    be16_to_cpu(cmd->atio.u.isp24.fcp_hdr.ox_id));
 -
 -	BUG_ON(cmd->cmd_in_wq);
 -
 -	if (!cmd->q_full)
 -		qlt_decr_num_pend_cmds(cmd->vha);
 -
  	BUG_ON(cmd->sg_mapped);
 -	cmd->jiffies_at_free = get_jiffies_64();
 +
  	if (unlikely(cmd->free_sg))
  		kfree(cmd->sg);
 -
 -	if (!sess || !sess->se_sess) {
 -		WARN_ON(1);
 -		return;
 -	}
 -	cmd->jiffies_at_free = get_jiffies_64();
 -	percpu_ida_free(&sess->se_sess->sess_tag_pool, cmd->se_cmd.map_tag);
 +	kmem_cache_free(qla_tgt_cmd_cachep, cmd);
  }
  EXPORT_SYMBOL(qlt_free_cmd);
  
diff --cc drivers/scsi/qla2xxx/tcm_qla2xxx.c
index 8e939971fec1,cdd53c652b05..000000000000
--- a/drivers/scsi/qla2xxx/tcm_qla2xxx.c
+++ b/drivers/scsi/qla2xxx/tcm_qla2xxx.c
@@@ -1401,8 -1357,10 +1401,13 @@@ static int tcm_qla2xxx_check_initiator_
  	struct qla_tgt_sess *sess = qla_tgt_sess;
  	unsigned char port_name[36];
  	unsigned long flags;
++<<<<<<< HEAD
++=======
+ 	int num_tags = (ha->cur_fw_xcb_count) ? ha->cur_fw_xcb_count :
+ 		       TCM_QLA2XXX_DEFAULT_TAGS;
++>>>>>>> 03e8c680d9b3 (qla2xxx: Add FW resource count in DebugFS.)
  
 -	lport = vha->vha_tgt.target_lport_ptr;
 +	lport = ha->tgt.target_lport_ptr;
  	if (!lport) {
  		pr_err("Unable to locate struct tcm_qla2xxx_lport\n");
  		dump_stack();
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
* Unmerged path drivers/scsi/qla2xxx/qla_dfs.c
diff --git a/drivers/scsi/qla2xxx/qla_gbl.h b/drivers/scsi/qla2xxx/qla_gbl.h
index c4f068539cd6..51547aff566c 100644
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@ -332,8 +332,7 @@ extern int
 qla2x00_get_id_list(scsi_qla_host_t *, void *, dma_addr_t, uint16_t *);
 
 extern int
-qla2x00_get_resource_cnts(scsi_qla_host_t *, uint16_t *, uint16_t *,
-    uint16_t *, uint16_t *, uint16_t *, uint16_t *);
+qla2x00_get_resource_cnts(scsi_qla_host_t *);
 
 extern int
 qla2x00_get_fcal_position_map(scsi_qla_host_t *ha, char *pos_map);
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
diff --git a/drivers/scsi/qla2xxx/qla_mbx.c b/drivers/scsi/qla2xxx/qla_mbx.c
index c2f973957a16..13817553b9d7 100644
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@ -2418,10 +2418,9 @@ qla2x00_get_id_list(scsi_qla_host_t *vha, void *id_list, dma_addr_t id_list_dma,
  *	Kernel context.
  */
 int
-qla2x00_get_resource_cnts(scsi_qla_host_t *vha, uint16_t *cur_xchg_cnt,
-    uint16_t *orig_xchg_cnt, uint16_t *cur_iocb_cnt,
-    uint16_t *orig_iocb_cnt, uint16_t *max_npiv_vports, uint16_t *max_fcfs)
+qla2x00_get_resource_cnts(scsi_qla_host_t *vha)
 {
+	struct qla_hw_data *ha = vha->hw;
 	int rval;
 	mbx_cmd_t mc;
 	mbx_cmd_t *mcp = &mc;
@@ -2449,19 +2448,16 @@ qla2x00_get_resource_cnts(scsi_qla_host_t *vha, uint16_t *cur_xchg_cnt,
 		    mcp->mb[3], mcp->mb[6], mcp->mb[7], mcp->mb[10],
 		    mcp->mb[11], mcp->mb[12]);
 
-		if (cur_xchg_cnt)
-			*cur_xchg_cnt = mcp->mb[3];
-		if (orig_xchg_cnt)
-			*orig_xchg_cnt = mcp->mb[6];
-		if (cur_iocb_cnt)
-			*cur_iocb_cnt = mcp->mb[7];
-		if (orig_iocb_cnt)
-			*orig_iocb_cnt = mcp->mb[10];
-		if (vha->hw->flags.npiv_supported && max_npiv_vports)
-			*max_npiv_vports = mcp->mb[11];
-		if ((IS_QLA81XX(vha->hw) || IS_QLA83XX(vha->hw) ||
-		    IS_QLA27XX(vha->hw)) && max_fcfs)
-			*max_fcfs = mcp->mb[12];
+		ha->orig_fw_tgt_xcb_count =  mcp->mb[1];
+		ha->cur_fw_tgt_xcb_count = mcp->mb[2];
+		ha->cur_fw_xcb_count = mcp->mb[3];
+		ha->orig_fw_xcb_count = mcp->mb[6];
+		ha->cur_fw_iocb_count = mcp->mb[7];
+		ha->orig_fw_iocb_count = mcp->mb[10];
+		if (ha->flags.npiv_supported)
+			ha->max_npiv_vports = mcp->mb[11];
+		if (IS_QLA81XX(ha) || IS_QLA83XX(ha) || IS_QLA27XX(ha))
+			ha->fw_max_fcf_count = mcp->mb[12];
 	}
 
 	return (rval);
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
* Unmerged path drivers/scsi/qla2xxx/tcm_qla2xxx.c
