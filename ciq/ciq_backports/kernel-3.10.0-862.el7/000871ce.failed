dma: dw: allocate memory in two stages in probe

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [sound] alsa: dma: dw: allocate memory in two stages in probe (Jaroslav Kysela) [1463624]
Rebuild_FUZZ: 94.00%
commit-author Andy Shevchenko <andriy.shevchenko@linux.intel.com>
commit 000871ce0336572f5b126a4d7f1ec13fc9adfda2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/000871ce.failed

This makes the probe() function a little bit clearer.

	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Signed-off-by: Vinod Koul <vinod.koul@intel.com>
(cherry picked from commit 000871ce0336572f5b126a4d7f1ec13fc9adfda2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dma/dw_dmac.c
diff --cc drivers/dma/dw_dmac.c
index 5d0ba000e772,cfdbb92aae1d..000000000000
--- a/drivers/dma/dw_dmac.c
+++ b/drivers/dma/dw_dmac.c
@@@ -1597,67 -1476,9 +1597,70 @@@ static void dw_dma_off(struct dw_dma *d
  		dw->chan[i].initialized = false;
  }
  
 -int dw_dma_probe(struct dw_dma_chip *chip, struct dw_dma_platform_data *pdata)
 +#ifdef CONFIG_OF
 +static struct dw_dma_platform_data *
 +dw_dma_parse_dt(struct platform_device *pdev)
 +{
 +	struct device_node *np = pdev->dev.of_node;
 +	struct dw_dma_platform_data *pdata;
 +	u32 tmp, arr[4];
 +
 +	if (!np) {
 +		dev_err(&pdev->dev, "Missing DT data\n");
 +		return NULL;
 +	}
 +
 +	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
 +	if (!pdata)
 +		return NULL;
 +
 +	if (of_property_read_u32(np, "dma-channels", &pdata->nr_channels))
 +		return NULL;
 +
 +	if (of_property_read_bool(np, "is_private"))
 +		pdata->is_private = true;
 +
 +	if (!of_property_read_u32(np, "chan_allocation_order", &tmp))
 +		pdata->chan_allocation_order = (unsigned char)tmp;
 +
 +	if (!of_property_read_u32(np, "chan_priority", &tmp))
 +		pdata->chan_priority = tmp;
 +
 +	if (!of_property_read_u32(np, "block_size", &tmp))
 +		pdata->block_size = tmp;
 +
 +	if (!of_property_read_u32(np, "dma-masters", &tmp)) {
 +		if (tmp > 4)
 +			return NULL;
 +
 +		pdata->nr_masters = tmp;
 +	}
 +
 +	if (!of_property_read_u32_array(np, "data_width", arr,
 +				pdata->nr_masters))
 +		for (tmp = 0; tmp < pdata->nr_masters; tmp++)
 +			pdata->data_width[tmp] = arr[tmp];
 +
 +	return pdata;
 +}
 +#else
 +static inline struct dw_dma_platform_data *
 +dw_dma_parse_dt(struct platform_device *pdev)
 +{
 +	return NULL;
 +}
 +#endif
 +
 +static int dw_probe(struct platform_device *pdev)
  {
 +	struct dw_dma_platform_data *pdata;
 +	struct resource		*io;
  	struct dw_dma		*dw;
++<<<<<<< HEAD:drivers/dma/dw_dmac.c
 +	size_t			size;
 +	void __iomem		*regs;
++=======
++>>>>>>> 000871ce0336 (dma: dw: allocate memory in two stages in probe):drivers/dma/dw/core.c
  	bool			autocfg;
  	unsigned int		dw_params;
  	unsigned int		nr_channels;
@@@ -1666,35 -1486,20 +1669,46 @@@
  	int			err;
  	int			i;
  
++<<<<<<< HEAD:drivers/dma/dw_dmac.c
 +	io = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 +	if (!io)
 +		return -EINVAL;
 +
 +	irq = platform_get_irq(pdev, 0);
 +	if (irq < 0)
 +		return irq;
 +
 +	regs = devm_ioremap_resource(&pdev->dev, io);
 +	if (IS_ERR(regs))
 +		return PTR_ERR(regs);
 +
 +	/* Apply default dma_mask if needed */
 +	if (!pdev->dev.dma_mask) {
 +		pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
 +		pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
 +	}
 +
 +	dw_params = dma_read_byaddr(regs, DW_PARAMS);
++=======
+ 	dw = devm_kzalloc(chip->dev, sizeof(*dw), GFP_KERNEL);
+ 	if (!dw)
+ 		return -ENOMEM;
+ 
+ 	dw->regs = chip->regs;
+ 	chip->dw = dw;
+ 
+ 	dw_params = dma_read_byaddr(chip->regs, DW_PARAMS);
++>>>>>>> 000871ce0336 (dma: dw: allocate memory in two stages in probe):drivers/dma/dw/core.c
  	autocfg = dw_params >> DW_PARAMS_EN & 0x1;
  
 -	dev_dbg(chip->dev, "DW_PARAMS: 0x%08x\n", dw_params);
 +	dev_dbg(&pdev->dev, "DW_PARAMS: 0x%08x\n", dw_params);
 +
 +	pdata = dev_get_platdata(&pdev->dev);
 +	if (!pdata)
 +		pdata = dw_dma_parse_dt(pdev);
  
  	if (!pdata && autocfg) {
 -		pdata = devm_kzalloc(chip->dev, sizeof(*pdata), GFP_KERNEL);
 +		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
  		if (!pdata)
  			return -ENOMEM;
  
@@@ -1710,18 -1515,16 +1724,27 @@@
  	else
  		nr_channels = pdata->nr_channels;
  
++<<<<<<< HEAD:drivers/dma/dw_dmac.c
 +	size = sizeof(struct dw_dma) + nr_channels * sizeof(struct dw_dma_chan);
 +	dw = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);
 +	if (!dw)
++=======
+ 	dw->chan = devm_kcalloc(chip->dev, nr_channels, sizeof(*dw->chan),
+ 				GFP_KERNEL);
+ 	if (!dw->chan)
++>>>>>>> 000871ce0336 (dma: dw: allocate memory in two stages in probe):drivers/dma/dw/core.c
  		return -ENOMEM;
  
 -	dw->clk = devm_clk_get(chip->dev, "hclk");
 +	dw->clk = devm_clk_get(&pdev->dev, "hclk");
  	if (IS_ERR(dw->clk))
  		return PTR_ERR(dw->clk);
  	clk_prepare_enable(dw->clk);
  
++<<<<<<< HEAD:drivers/dma/dw_dmac.c
 +	dw->regs = regs;
 +
++=======
++>>>>>>> 000871ce0336 (dma: dw: allocate memory in two stages in probe):drivers/dma/dw/core.c
  	/* Get hardware configuration parameters */
  	if (autocfg) {
  		max_blk_size = dma_readl(dw, MAX_BLK_SIZE);
* Unmerged path drivers/dma/dw_dmac.c
diff --git a/drivers/dma/dw_dmac_regs.h b/drivers/dma/dw_dmac_regs.h
index 9d417200bd57..56e164af052d 100644
--- a/drivers/dma/dw_dmac_regs.h
+++ b/drivers/dma/dw_dmac_regs.h
@@ -245,13 +245,13 @@ struct dw_dma {
 	struct tasklet_struct	tasklet;
 	struct clk		*clk;
 
+	/* channels */
+	struct dw_dma_chan	*chan;
 	u8			all_chan_mask;
 
 	/* hardware configuration */
 	unsigned char		nr_masters;
 	unsigned char		data_width[4];
-
-	struct dw_dma_chan	chan[0];
 };
 
 static inline struct dw_dma_regs __iomem *__dw_regs(struct dw_dma *dw)
