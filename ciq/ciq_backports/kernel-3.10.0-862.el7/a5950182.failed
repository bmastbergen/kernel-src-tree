nfp: map mac_stats and vf_cfg BARs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Simon Horman <simon.horman@netronome.com>
commit a5950182c00eb6d53a68db9f6b6c878f795657f6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a5950182.failed

If present map mac_stats and vf_cfg BARs. These will be used by
representor netdevs to read statistics for phys port and vf representors.

Also provide defines describing the layout of the mac_stats area.
Similar defines are already present for the cf_cfg area.

Based in part on work by Jakub Kicinski.

	Signed-off-by: Simon Horman <simon.horman@netronome.com>
	Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a5950182c00eb6d53a68db9f6b6c878f795657f6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_main.h
#	drivers/net/ethernet/netronome/nfp/nfp_net_main.c
#	drivers/net/ethernet/netronome/nfp/nfp_port.h
#	drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_main.h
index 1ac430fbaa18,aa69d4101eb9..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_main.h
+++ b/drivers/net/ethernet/netronome/nfp/nfp_main.h
@@@ -57,10 -64,15 +57,22 @@@ struct nfp_eth_table
   * struct nfp_pf - NFP PF-specific device structure
   * @pdev:		Backpointer to PCI device
   * @cpp:		Pointer to the CPP handle
++<<<<<<< HEAD
 + * @ctrl_area:		Pointer to the CPP area for the control BAR
 + * @tx_area:		Pointer to the CPP area for the TX queues
 + * @rx_area:		Pointer to the CPP area for the FL/RX queues
 + * @irq_entries:	Array of MSI-X entries for all ports
++=======
+  * @app:		Pointer to the APP handle
+  * @data_vnic_bar:	Pointer to the CPP area for the data vNICs' BARs
+  * @ctrl_vnic_bar:	Pointer to the CPP area for the ctrl vNIC's BAR
+  * @qc_area:		Pointer to the CPP area for the queues
+  * @mac_stats_bar:	Pointer to the CPP area for the MAC stats
+  * @mac_stats_mem:	Pointer to mapped MAC stats area
+  * @vf_cfg_bar:		Pointer to the CPP area for the VF configuration BAR
+  * @vf_cfg_mem:		Pointer to mapped VF configuration area
+  * @irq_entries:	Array of MSI-X entries for all vNICs
++>>>>>>> a5950182c00e (nfp: map mac_stats and vf_cfg BARs)
   * @limit_vfs:		Number of VFs supported by firmware (~0 for PCI limit)
   * @num_vfs:		Number of SR-IOV VFs enabled
   * @fw_loaded:		Is the firmware loaded?
@@@ -76,9 -96,15 +88,21 @@@ struct nfp_pf 
  
  	struct nfp_cpp *cpp;
  
++<<<<<<< HEAD
 +	struct nfp_cpp_area *ctrl_area;
 +	struct nfp_cpp_area *tx_area;
 +	struct nfp_cpp_area *rx_area;
++=======
+ 	struct nfp_app *app;
+ 
+ 	struct nfp_cpp_area *data_vnic_bar;
+ 	struct nfp_cpp_area *ctrl_vnic_bar;
+ 	struct nfp_cpp_area *qc_area;
+ 	struct nfp_cpp_area *mac_stats_bar;
+ 	u8 __iomem *mac_stats_mem;
+ 	struct nfp_cpp_area *vf_cfg_bar;
+ 	u8 __iomem *vf_cfg_mem;
++>>>>>>> a5950182c00e (nfp: map mac_stats and vf_cfg BARs)
  
  	struct msix_entry *irq_entries;
  
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_main.c
index 092c7d18f2ec,911b764d7641..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
@@@ -207,77 -212,63 +207,83 @@@ static unsigned int nfp_net_pf_get_num_
  	return val;
  }
  
 -static int nfp_net_pf_get_num_ports(struct nfp_pf *pf)
 +static unsigned int
 +nfp_net_pf_total_qcs(struct nfp_pf *pf, void __iomem *ctrl_bar,
 +		     unsigned int stride, u32 start_off, u32 num_off)
  {
 -	return nfp_net_pf_rtsym_read_optional(pf, "nfd_cfg_pf%u_num_ports", 1);
 -}
 +	unsigned int i, min_qc, max_qc;
  
 -static int nfp_net_pf_get_app_id(struct nfp_pf *pf)
 -{
 -	return nfp_net_pf_rtsym_read_optional(pf, "_pf%u_net_app_id",
 -					      NFP_APP_CORE_NIC);
 +	min_qc = readl(ctrl_bar + start_off);
 +	max_qc = min_qc;
 +
 +	for (i = 0; i < pf->num_ports; i++) {
 +		/* To make our lives simpler only accept configuration where
 +		 * queues are allocated to PFs in order (queues of PFn all have
 +		 * indexes lower than PFn+1).
 +		 */
 +		if (max_qc > readl(ctrl_bar + start_off))
 +			return 0;
 +
 +		max_qc = readl(ctrl_bar + start_off);
 +		max_qc += readl(ctrl_bar + num_off) * stride;
 +		ctrl_bar += NFP_PF_CSR_SLICE_SIZE;
 +	}
 +
 +	return max_qc - min_qc;
  }
  
 -static u8 __iomem *
 -nfp_net_pf_map_rtsym(struct nfp_pf *pf, const char *name, const char *sym_fmt,
 -		     unsigned int min_size, struct nfp_cpp_area **area)
 +static u8 __iomem *nfp_net_pf_map_ctrl_bar(struct nfp_pf *pf)
  {
 -	const struct nfp_rtsym *sym;
 +	const struct nfp_rtsym *ctrl_sym;
 +	u8 __iomem *ctrl_bar;
  	char pf_symbol[256];
 -	u8 __iomem *mem;
  
 -	snprintf(pf_symbol, sizeof(pf_symbol), sym_fmt,
 +	snprintf(pf_symbol, sizeof(pf_symbol), "_pf%u_net_bar0",
  		 nfp_cppcore_pcie_unit(pf->cpp));
  
++<<<<<<< HEAD
 +	ctrl_sym = nfp_rtsym_lookup(pf->cpp, pf_symbol);
 +	if (!ctrl_sym) {
 +		dev_err(&pf->pdev->dev,
 +			"Failed to find PF BAR0 symbol %s\n", pf_symbol);
 +		return NULL;
 +	}
++=======
+ 	sym = nfp_rtsym_lookup(pf->rtbl, pf_symbol);
+ 	if (!sym)
+ 		return (u8 __iomem *)ERR_PTR(-ENOENT);
++>>>>>>> a5950182c00e (nfp: map mac_stats and vf_cfg BARs)
  
 -	if (sym->size < min_size) {
 -		nfp_err(pf->cpp, "PF symbol %s too small\n", pf_symbol);
 -		return (u8 __iomem *)ERR_PTR(-EINVAL);
 +	if (ctrl_sym->size < pf->num_ports * NFP_PF_CSR_SLICE_SIZE) {
 +		dev_err(&pf->pdev->dev,
 +			"PF BAR0 too small to contain %d ports\n",
 +			pf->num_ports);
 +		return NULL;
  	}
  
 -	mem = nfp_net_map_area(pf->cpp, name, sym->domain, sym->target,
 -			       sym->addr, sym->size, area);
 -	if (IS_ERR(mem)) {
 -		nfp_err(pf->cpp, "Failed to map PF symbol %s: %ld\n",
 -			pf_symbol, PTR_ERR(mem));
 -		return mem;
 +	ctrl_bar = nfp_net_map_area(pf->cpp, "net.ctrl",
 +				    ctrl_sym->domain, ctrl_sym->target,
 +				    ctrl_sym->addr, ctrl_sym->size,
 +				    &pf->ctrl_area);
 +	if (IS_ERR(ctrl_bar)) {
 +		dev_err(&pf->pdev->dev, "Failed to map PF BAR0: %ld\n",
 +			PTR_ERR(ctrl_bar));
 +		return NULL;
  	}
  
 -	return mem;
 +	return ctrl_bar;
  }
  
 -static void nfp_net_pf_free_vnic(struct nfp_pf *pf, struct nfp_net *nn)
 +static void nfp_net_pf_free_netdevs(struct nfp_pf *pf)
  {
 -	nfp_port_free(nn->port);
 -	list_del(&nn->vnic_list);
 -	pf->num_vnics--;
 -	nfp_net_free(nn);
 -}
 +	struct nfp_net *nn;
  
 -static void nfp_net_pf_free_vnics(struct nfp_pf *pf)
 -{
 -	struct nfp_net *nn, *next;
 +	while (!list_empty(&pf->ports)) {
 +		nn = list_first_entry(&pf->ports, struct nfp_net, port_list);
 +		list_del(&nn->port_list);
  
 -	list_for_each_entry_safe(nn, next, &pf->vnics, vnic_list)
 -		if (nfp_net_is_data_vnic(nn))
 -			nfp_net_pf_free_vnic(pf, nn);
 +		nfp_net_netdev_free(nn);
 +	}
  }
  
  static struct nfp_net *
@@@ -435,91 -457,316 +441,271 @@@ nfp_net_pf_spawn_netdevs(struct nfp_pf 
  	return 0;
  
  err_prev_deinit:
++<<<<<<< HEAD
 +	list_for_each_entry_continue_reverse(nn, &pf->ports, port_list) {
 +		nfp_net_debugfs_dir_clean(&nn->debugfs_dir);
 +		nfp_net_netdev_clean(nn->netdev);
++=======
+ 	list_for_each_entry_continue_reverse(nn, &pf->vnics, vnic_list)
+ 		if (nfp_net_is_data_vnic(nn))
+ 			nfp_net_pf_clean_vnic(pf, nn);
+ 	return err;
+ }
+ 
+ static int
+ nfp_net_pf_app_init(struct nfp_pf *pf, u8 __iomem *qc_bar, unsigned int stride)
+ {
+ 	u8 __iomem *ctrl_bar;
+ 	int err;
+ 
+ 	pf->app = nfp_app_alloc(pf, nfp_net_pf_get_app_id(pf));
+ 	if (IS_ERR(pf->app))
+ 		return PTR_ERR(pf->app);
+ 
+ 	err = nfp_app_init(pf->app);
+ 	if (err)
+ 		goto err_free;
+ 
+ 	if (!nfp_app_needs_ctrl_vnic(pf->app))
+ 		return 0;
+ 
+ 	ctrl_bar = nfp_net_pf_map_rtsym(pf, "net.ctrl", "_pf%u_net_ctrl_bar",
+ 					NFP_PF_CSR_SLICE_SIZE,
+ 					&pf->ctrl_vnic_bar);
+ 	if (IS_ERR(ctrl_bar)) {
+ 		nfp_err(pf->cpp, "Failed to find data vNIC memory symbol\n");
+ 		err = PTR_ERR(ctrl_bar);
+ 		goto err_free;
++>>>>>>> a5950182c00e (nfp: map mac_stats and vf_cfg BARs)
  	}
 -
 -	pf->ctrl_vnic =	nfp_net_pf_alloc_vnic(pf, false, ctrl_bar, qc_bar,
 -					      stride, 0);
 -	if (IS_ERR(pf->ctrl_vnic)) {
 -		err = PTR_ERR(pf->ctrl_vnic);
 -		goto err_unmap;
 -	}
 -
 -	return 0;
 -
 -err_unmap:
 -	nfp_cpp_area_release_free(pf->ctrl_vnic_bar);
 -err_free:
 -	nfp_app_free(pf->app);
 +	nfp_net_irqs_disable(pf->pdev);
 +err_vec_free:
 +	kfree(pf->irq_entries);
 +err_nn_free:
 +	nfp_net_pf_free_netdevs(pf);
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static void nfp_net_pf_app_clean(struct nfp_pf *pf)
+ {
+ 	if (pf->ctrl_vnic) {
+ 		nfp_net_pf_free_vnic(pf, pf->ctrl_vnic);
+ 		nfp_cpp_area_release_free(pf->ctrl_vnic_bar);
+ 	}
+ 	nfp_app_free(pf->app);
+ 	pf->app = NULL;
+ }
+ 
+ static int nfp_net_pf_app_start_ctrl(struct nfp_pf *pf)
+ {
+ 	int err;
+ 
+ 	if (!pf->ctrl_vnic)
+ 		return 0;
+ 	err = nfp_net_pf_init_vnic(pf, pf->ctrl_vnic, 0);
+ 	if (err)
+ 		return err;
+ 
+ 	err = nfp_ctrl_open(pf->ctrl_vnic);
+ 	if (err)
+ 		goto err_clean_ctrl;
+ 
+ 	return 0;
+ 
+ err_clean_ctrl:
+ 	nfp_net_pf_clean_vnic(pf, pf->ctrl_vnic);
+ 	return err;
+ }
+ 
+ static void nfp_net_pf_app_stop_ctrl(struct nfp_pf *pf)
+ {
+ 	if (!pf->ctrl_vnic)
+ 		return;
+ 	nfp_ctrl_close(pf->ctrl_vnic);
+ 	nfp_net_pf_clean_vnic(pf, pf->ctrl_vnic);
+ }
+ 
+ static int nfp_net_pf_app_start(struct nfp_pf *pf)
+ {
+ 	int err;
+ 
+ 	err = nfp_net_pf_app_start_ctrl(pf);
+ 	if (err)
+ 		return err;
+ 
+ 	err = nfp_app_start(pf->app, pf->ctrl_vnic);
+ 	if (err)
+ 		goto err_ctrl_stop;
+ 
+ 	return 0;
+ 
+ err_ctrl_stop:
+ 	nfp_net_pf_app_stop_ctrl(pf);
+ 	return err;
+ }
+ 
+ static void nfp_net_pf_app_stop(struct nfp_pf *pf)
+ {
+ 	nfp_app_stop(pf->app);
+ 	nfp_net_pf_app_stop_ctrl(pf);
+ }
+ 
+ static void nfp_net_pci_unmap_mem(struct nfp_pf *pf)
+ {
+ 	if (pf->vf_cfg_bar)
+ 		nfp_cpp_area_release_free(pf->vf_cfg_bar);
+ 	if (pf->mac_stats_bar)
+ 		nfp_cpp_area_release_free(pf->mac_stats_bar);
+ 	nfp_cpp_area_release_free(pf->qc_area);
+ 	nfp_cpp_area_release_free(pf->data_vnic_bar);
+ }
+ 
+ static int nfp_net_pci_map_mem(struct nfp_pf *pf)
+ {
+ 	u32 ctrl_bar_sz;
+ 	u8 __iomem *mem;
+ 	int err;
+ 
+ 	ctrl_bar_sz = pf->max_data_vnics * NFP_PF_CSR_SLICE_SIZE;
+ 	mem = nfp_net_pf_map_rtsym(pf, "net.ctrl", "_pf%d_net_bar0",
+ 				   ctrl_bar_sz, &pf->data_vnic_bar);
+ 	if (IS_ERR(mem)) {
+ 		nfp_err(pf->cpp, "Failed to find data vNIC memory symbol\n");
+ 		err = PTR_ERR(mem);
+ 		if (!pf->fw_loaded && err == -ENOENT)
+ 			err = -EPROBE_DEFER;
+ 		return err;
+ 	}
+ 
+ 	pf->mac_stats_mem = nfp_net_pf_map_rtsym(pf, "net.macstats",
+ 						 "_mac_stats",
+ 						 NFP_MAC_STATS_SIZE *
+ 						 (pf->eth_tbl->max_index + 1),
+ 						 &pf->mac_stats_bar);
+ 	if (IS_ERR(pf->mac_stats_mem)) {
+ 		if (PTR_ERR(pf->mac_stats_mem) != -ENOENT) {
+ 			err = PTR_ERR(pf->mac_stats_mem);
+ 			goto err_unmap_ctrl;
+ 		}
+ 		pf->mac_stats_mem = NULL;
+ 	}
+ 
+ 	pf->vf_cfg_mem = nfp_net_pf_map_rtsym(pf, "net.vfcfg",
+ 					      "_pf%d_net_vf_bar",
+ 					      NFP_NET_CFG_BAR_SZ *
+ 					      pf->limit_vfs, &pf->vf_cfg_bar);
+ 	if (IS_ERR(pf->vf_cfg_mem)) {
+ 		if (PTR_ERR(pf->vf_cfg_mem) != -ENOENT) {
+ 			err = PTR_ERR(pf->vf_cfg_mem);
+ 			goto err_unmap_mac_stats;
+ 		}
+ 		pf->vf_cfg_mem = NULL;
+ 	}
+ 
+ 	mem = nfp_net_map_area(pf->cpp, "net.qc", 0, 0,
+ 			       NFP_PCIE_QUEUE(0), NFP_QCP_QUEUE_AREA_SZ,
+ 			       &pf->qc_area);
+ 	if (IS_ERR(mem)) {
+ 		nfp_err(pf->cpp, "Failed to map Queue Controller area.\n");
+ 		err = PTR_ERR(mem);
+ 		goto err_unmap_vf_cfg;
+ 	}
+ 
+ 	return 0;
+ 
+ err_unmap_vf_cfg:
+ 	if (pf->vf_cfg_bar)
+ 		nfp_cpp_area_release_free(pf->vf_cfg_bar);
+ err_unmap_mac_stats:
+ 	if (pf->mac_stats_bar)
+ 		nfp_cpp_area_release_free(pf->mac_stats_bar);
+ err_unmap_ctrl:
+ 	nfp_cpp_area_release_free(pf->data_vnic_bar);
+ 	return err;
+ }
+ 
++>>>>>>> a5950182c00e (nfp: map mac_stats and vf_cfg BARs)
  static void nfp_net_pci_remove_finish(struct nfp_pf *pf)
  {
 -	nfp_net_pf_app_stop(pf);
 -	/* stop app first, to avoid double free of ctrl vNIC's ddir */
  	nfp_net_debugfs_dir_clean(&pf->ddir);
  
++<<<<<<< HEAD
 +	nfp_net_irqs_disable(pf->pdev);
 +	kfree(pf->irq_entries);
 +
 +	nfp_cpp_area_release_free(pf->rx_area);
 +	nfp_cpp_area_release_free(pf->tx_area);
 +	nfp_cpp_area_release_free(pf->ctrl_area);
++=======
+ 	nfp_net_pf_free_irqs(pf);
+ 	nfp_net_pf_app_clean(pf);
+ 	nfp_net_pci_unmap_mem(pf);
++>>>>>>> a5950182c00e (nfp: map mac_stats and vf_cfg BARs)
  }
  
 -static int
 -nfp_net_eth_port_update(struct nfp_cpp *cpp, struct nfp_port *port,
 -			struct nfp_eth_table *eth_table)
 +static void nfp_net_refresh_netdevs(struct work_struct *work)
  {
 -	struct nfp_eth_table_port *eth_port;
 -
 -	ASSERT_RTNL();
 -
 -	eth_port = nfp_net_find_port(eth_table, port->eth_id);
 -	if (!eth_port) {
 -		set_bit(NFP_PORT_CHANGED, &port->flags);
 -		nfp_warn(cpp, "Warning: port #%d not present after reconfig\n",
 -			 port->eth_id);
 -		return -EIO;
 -	}
 -	if (eth_port->override_changed) {
 -		nfp_warn(cpp, "Port #%d config changed, unregistering. Reboot required before port will be operational again.\n", port->eth_id);
 -		port->type = NFP_PORT_INVALID;
 -	}
 -
 -	memcpy(port->eth_port, eth_port, sizeof(*eth_port));
 -
 -	return 0;
 -}
 -
 -int nfp_net_refresh_port_table_sync(struct nfp_pf *pf)
 -{
 -	struct nfp_eth_table *eth_table;
 +	struct nfp_pf *pf = container_of(work, struct nfp_pf,
 +					 port_refresh_work);
  	struct nfp_net *nn, *next;
 -	struct nfp_port *port;
  
 -	lockdep_assert_held(&pf->lock);
 +	mutex_lock(&pf->port_lock);
  
  	/* Check for nfp_net_pci_remove() racing against us */
 -	if (list_empty(&pf->vnics))
 -		return 0;
 +	if (list_empty(&pf->ports))
 +		goto out;
  
 -	/* Update state of all ports */
 -	rtnl_lock();
 -	list_for_each_entry(port, &pf->ports, port_list)
 -		clear_bit(NFP_PORT_CHANGED, &port->flags);
 -
 -	eth_table = nfp_eth_read_ports(pf->cpp);
 -	if (!eth_table) {
 -		list_for_each_entry(port, &pf->ports, port_list)
 -			if (__nfp_port_get_eth_port(port))
 -				set_bit(NFP_PORT_CHANGED, &port->flags);
 -		rtnl_unlock();
 -		nfp_err(pf->cpp, "Error refreshing port config!\n");
 -		return -EIO;
 -	}
 +	list_for_each_entry_safe(nn, next, &pf->ports, port_list) {
 +		if (!nn->eth_port) {
 +			nfp_warn(pf->cpp, "Warning: port not present after reconfig\n");
 +			continue;
 +		}
 +		if (!nn->eth_port->override_changed)
 +			continue;
  
 -	list_for_each_entry(port, &pf->ports, port_list)
 -		if (__nfp_port_get_eth_port(port))
 -			nfp_net_eth_port_update(pf->cpp, port, eth_table);
 -	rtnl_unlock();
 +		nn_warn(nn, "Port config changed, unregistering. Reboot required before port will be operational again.\n");
  
 -	kfree(eth_table);
 +		nfp_net_debugfs_dir_clean(&nn->debugfs_dir);
 +		nfp_net_netdev_clean(nn->dp.netdev);
  
 -	/* Shoot off the ports which became invalid */
 -	list_for_each_entry_safe(nn, next, &pf->vnics, vnic_list) {
 -		if (!nn->port || nn->port->type != NFP_PORT_INVALID)
 -			continue;
 -
 -		nfp_net_pf_clean_vnic(pf, nn);
 -		nfp_net_pf_free_vnic(pf, nn);
 +		list_del(&nn->port_list);
 +		pf->num_netdevs--;
 +		nfp_net_netdev_free(nn);
  	}
  
 -	if (list_empty(&pf->vnics))
 +	if (list_empty(&pf->ports))
  		nfp_net_pci_remove_finish(pf);
 -
 -	return 0;
 -}
 -
 -static void nfp_net_refresh_vnics(struct work_struct *work)
 -{
 -	struct nfp_pf *pf = container_of(work, struct nfp_pf,
 -					 port_refresh_work);
 -
 -	mutex_lock(&pf->lock);
 -	nfp_net_refresh_port_table_sync(pf);
 -	mutex_unlock(&pf->lock);
 +out:
 +	mutex_unlock(&pf->port_lock);
  }
  
 -void nfp_net_refresh_port_table(struct nfp_port *port)
 +void nfp_net_refresh_port_config(struct nfp_net *nn)
  {
 -	struct nfp_pf *pf = port->app->pf;
 +	struct nfp_pf *pf = pci_get_drvdata(nn->pdev);
 +	struct nfp_eth_table *old_table;
  
 -	set_bit(NFP_PORT_CHANGED, &port->flags);
 -
 -	schedule_work(&pf->port_refresh_work);
 -}
 +	ASSERT_RTNL();
  
 -int nfp_net_refresh_eth_port(struct nfp_port *port)
 -{
 -	struct nfp_cpp *cpp = port->app->cpp;
 -	struct nfp_eth_table *eth_table;
 -	int ret;
 +	old_table = pf->eth_tbl;
  
 -	clear_bit(NFP_PORT_CHANGED, &port->flags);
 +	list_for_each_entry(nn, &pf->ports, port_list)
 +		nfp_net_link_changed_read_clear(nn);
  
 -	eth_table = nfp_eth_read_ports(cpp);
 -	if (!eth_table) {
 -		set_bit(NFP_PORT_CHANGED, &port->flags);
 -		nfp_err(cpp, "Error refreshing port state table!\n");
 -		return -EIO;
 +	pf->eth_tbl = nfp_eth_read_ports(pf->cpp);
 +	if (!pf->eth_tbl) {
 +		pf->eth_tbl = old_table;
 +		nfp_err(pf->cpp, "Error refreshing port config!\n");
 +		return;
  	}
  
 -	ret = nfp_net_eth_port_update(cpp, port, eth_table);
 +	list_for_each_entry(nn, &pf->ports, port_list)
 +		nn->eth_port = nfp_net_find_port(pf, nn->eth_port->eth_index);
  
 -	kfree(eth_table);
 +	kfree(old_table);
  
 -	return ret;
 +	schedule_work(&pf->port_refresh_work);
  }
  
  /*
@@@ -527,11 -774,8 +713,15 @@@
   */
  int nfp_net_pci_probe(struct nfp_pf *pf)
  {
 +	u8 __iomem *ctrl_bar, *tx_bar, *rx_bar;
 +	u32 total_tx_qcs, total_rx_qcs;
  	struct nfp_net_fw_version fw_ver;
++<<<<<<< HEAD
 +	u32 tx_area_sz, rx_area_sz;
 +	u32 start_q;
++=======
+ 	u8 __iomem *ctrl_bar, *qc_bar;
++>>>>>>> a5950182c00e (nfp: map mac_stats and vf_cfg BARs)
  	int stride;
  	int err;
  
@@@ -544,13 -787,22 +734,24 @@@
  		return -EINVAL;
  	}
  
 -	mutex_lock(&pf->lock);
 -	pf->max_data_vnics = nfp_net_pf_get_num_ports(pf);
 -	if ((int)pf->max_data_vnics < 0) {
 -		err = pf->max_data_vnics;
 -		goto err_unlock;
 -	}
 +	mutex_lock(&pf->port_lock);
 +	pf->num_ports = nfp_net_pf_get_num_ports(pf);
  
++<<<<<<< HEAD
 +	ctrl_bar = nfp_net_pf_map_ctrl_bar(pf);
 +	if (!ctrl_bar) {
 +		err = pf->fw_loaded ? -EINVAL : -EPROBE_DEFER;
++=======
+ 	err = nfp_net_pci_map_mem(pf);
+ 	if (err)
++>>>>>>> a5950182c00e (nfp: map mac_stats and vf_cfg BARs)
  		goto err_unlock;
+ 
+ 	ctrl_bar = nfp_cpp_area_iomem(pf->data_vnic_bar);
+ 	qc_bar = nfp_cpp_area_iomem(pf->qc_area);
+ 	if (!ctrl_bar || !qc_bar) {
+ 		err = -EIO;
+ 		goto err_unmap;
  	}
  
  	nfp_net_get_fw_version(&fw_ver, ctrl_bar);
@@@ -579,44 -831,9 +780,50 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	/* Find how many QC structs need to be mapped */
 +	total_tx_qcs = nfp_net_pf_total_qcs(pf, ctrl_bar, stride,
 +					    NFP_NET_CFG_START_TXQ,
 +					    NFP_NET_CFG_MAX_TXRINGS);
 +	total_rx_qcs = nfp_net_pf_total_qcs(pf, ctrl_bar, stride,
 +					    NFP_NET_CFG_START_RXQ,
 +					    NFP_NET_CFG_MAX_RXRINGS);
 +	if (!total_tx_qcs || !total_rx_qcs) {
 +		nfp_err(pf->cpp, "Invalid PF QC configuration [%d,%d]\n",
 +			total_tx_qcs, total_rx_qcs);
 +		err = -EINVAL;
 +		goto err_ctrl_unmap;
 +	}
 +
 +	tx_area_sz = NFP_QCP_QUEUE_ADDR_SZ * total_tx_qcs;
 +	rx_area_sz = NFP_QCP_QUEUE_ADDR_SZ * total_rx_qcs;
 +
 +	/* Map TX queues */
 +	start_q = readl(ctrl_bar + NFP_NET_CFG_START_TXQ);
 +	tx_bar = nfp_net_map_area(pf->cpp, "net.tx", 0, 0,
 +				  NFP_PCIE_QUEUE(start_q),
 +				  tx_area_sz, &pf->tx_area);
 +	if (IS_ERR(tx_bar)) {
 +		nfp_err(pf->cpp, "Failed to map TX area.\n");
 +		err = PTR_ERR(tx_bar);
 +		goto err_ctrl_unmap;
 +	}
 +
 +	/* Map RX queues */
 +	start_q = readl(ctrl_bar + NFP_NET_CFG_START_RXQ);
 +	rx_bar = nfp_net_map_area(pf->cpp, "net.rx", 0, 0,
 +				  NFP_PCIE_QUEUE(start_q),
 +				  rx_area_sz, &pf->rx_area);
 +	if (IS_ERR(rx_bar)) {
 +		nfp_err(pf->cpp, "Failed to map RX area.\n");
 +		err = PTR_ERR(rx_bar);
 +		goto err_unmap_tx;
 +	}
++=======
+ 	err = nfp_net_pf_app_init(pf, qc_bar, stride);
+ 	if (err)
+ 		goto err_unmap;
++>>>>>>> a5950182c00e (nfp: map mac_stats and vf_cfg BARs)
  
  	pf->ddir = nfp_net_debugfs_device_add(pf->pdev);
  
@@@ -629,15 -858,20 +836,21 @@@
  
  	return 0;
  
 -err_stop_app:
 -	nfp_net_pf_app_stop(pf);
 -err_free_irqs:
 -	nfp_net_pf_free_irqs(pf);
 -err_free_vnics:
 -	nfp_net_pf_free_vnics(pf);
  err_clean_ddir:
  	nfp_net_debugfs_dir_clean(&pf->ddir);
++<<<<<<< HEAD
 +	nfp_cpp_area_release_free(pf->rx_area);
 +err_unmap_tx:
 +	nfp_cpp_area_release_free(pf->tx_area);
 +err_ctrl_unmap:
 +	nfp_cpp_area_release_free(pf->ctrl_area);
++=======
+ 	nfp_net_pf_app_clean(pf);
+ err_unmap:
+ 	nfp_net_pci_unmap_mem(pf);
++>>>>>>> a5950182c00e (nfp: map mac_stats and vf_cfg BARs)
  err_unlock:
 -	mutex_unlock(&pf->lock);
 -	cancel_work_sync(&pf->port_refresh_work);
 +	mutex_unlock(&pf->port_lock);
  	return err;
  }
  
diff --cc drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.c
index f94361014b87,c2bc36e8649f..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.c
+++ b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.c
@@@ -129,14 -167,64 +129,67 @@@ nfp_eth_port_translate(const struct eth
  	dst->tx_enabled = FIELD_GET(NSP_ETH_STATE_TX_ENABLED, state);
  	dst->rx_enabled = FIELD_GET(NSP_ETH_STATE_RX_ENABLED, state);
  
 -	rate = nfp_eth_rate2speed(FIELD_GET(NSP_ETH_STATE_RATE, state));
 +	rate = nfp_eth_rate(FIELD_GET(NSP_ETH_STATE_RATE, state));
  	dst->speed = dst->lanes * rate;
  
 -	dst->interface = FIELD_GET(NSP_ETH_STATE_INTERFACE, state);
 -	dst->media = FIELD_GET(NSP_ETH_STATE_MEDIA, state);
 -
  	nfp_eth_copy_mac_reverse(dst->mac_addr, src->mac_addr);
  
++<<<<<<< HEAD
 +	snprintf(dst->label, sizeof(dst->label) - 1, "%llu.%llu",
 +		 FIELD_GET(NSP_ETH_PORT_PHYLABEL, port),
 +		 FIELD_GET(NSP_ETH_PORT_LABEL, port));
++=======
+ 	dst->label_port = FIELD_GET(NSP_ETH_PORT_PHYLABEL, port);
+ 	dst->label_subport = FIELD_GET(NSP_ETH_PORT_LABEL, port);
+ 
+ 	if (nfp_nsp_get_abi_ver_minor(nsp) < 17)
+ 		return;
+ 
+ 	dst->override_changed = FIELD_GET(NSP_ETH_STATE_OVRD_CHNG, state);
+ 	dst->aneg = FIELD_GET(NSP_ETH_STATE_ANEG, state);
+ }
+ 
+ static void
+ nfp_eth_calc_port_geometry(struct nfp_cpp *cpp, struct nfp_eth_table *table)
+ {
+ 	unsigned int i, j;
+ 
+ 	for (i = 0; i < table->count; i++) {
+ 		table->max_index = max(table->max_index, table->ports[i].index);
+ 
+ 		for (j = 0; j < table->count; j++) {
+ 			if (table->ports[i].label_port !=
+ 			    table->ports[j].label_port)
+ 				continue;
+ 			table->ports[i].port_lanes += table->ports[j].lanes;
+ 
+ 			if (i == j)
+ 				continue;
+ 			if (table->ports[i].label_subport ==
+ 			    table->ports[j].label_subport)
+ 				nfp_warn(cpp,
+ 					 "Port %d subport %d is a duplicate\n",
+ 					 table->ports[i].label_port,
+ 					 table->ports[i].label_subport);
+ 
+ 			table->ports[i].is_split = true;
+ 		}
+ 	}
+ }
+ 
+ static void
+ nfp_eth_calc_port_type(struct nfp_cpp *cpp, struct nfp_eth_table_port *entry)
+ {
+ 	if (entry->interface == NFP_INTERFACE_NONE) {
+ 		entry->port_type = PORT_NONE;
+ 		return;
+ 	}
+ 
+ 	if (entry->media == NFP_MEDIA_FIBRE)
+ 		entry->port_type = PORT_FIBRE;
+ 	else
+ 		entry->port_type = PORT_DA;
++>>>>>>> a5950182c00e (nfp: map mac_stats and vf_cfg BARs)
  }
  
  /**
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_port.h
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_main.h
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_main.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_port.h
* Unmerged path drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.c
diff --git a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.h b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.h
index 40eb6f95d0ce..ab2deb01ad49 100644
--- a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.h
+++ b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.h
@@ -40,6 +40,7 @@
 /**
  * struct nfp_eth_table - ETH table information
  * @count:	number of table entries
+ * @max_index:	max of @index fields of all @ports
  * @ports:	table of ports
  *
  * @eth_index:	port index according to legacy ethX numbering
@@ -56,6 +57,7 @@
  */
 struct nfp_eth_table {
 	unsigned int count;
+	unsigned int max_index;
 	struct nfp_eth_table_port {
 		unsigned int eth_index;
 		unsigned int index;
