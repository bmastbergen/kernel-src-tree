net/mlx5: Export building of matched flow groups list

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Export building of matched flow groups list (Kamal Heib) [1456687 1456694]
Rebuild_FUZZ: 96.08%
commit-author Maor Gottlieb <maorg@mellanox.com>
commit 46719d77d5f38b8ef04aa5a5cd91263b11d741d7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/46719d77.failed

Refactor the code and export the build of the matched flow groups
list to separate function.

	Signed-off-by: Maor Gottlieb <maorg@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 46719d77d5f38b8ef04aa5a5cd91263b11d741d7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
index f60baa93f1dc,33bcaca70a69..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
@@@ -1349,7 -1441,127 +1349,130 @@@ static bool dest_is_valid(struct mlx5_f
  	return true;
  }
  
+ struct match_list {
+ 	struct list_head	list;
+ 	struct mlx5_flow_group *g;
+ };
+ 
+ struct match_list_head {
+ 	struct list_head  list;
+ 	struct match_list first;
+ };
+ 
+ static void free_match_list(struct match_list_head *head)
+ {
+ 	if (!list_empty(&head->list)) {
+ 		struct match_list *iter, *match_tmp;
+ 
+ 		list_del(&head->first.list);
+ 		list_for_each_entry_safe(iter, match_tmp, &head->list,
+ 					 list) {
+ 			list_del(&iter->list);
+ 			kfree(iter);
+ 		}
+ 	}
+ }
+ 
+ static int build_match_list(struct match_list_head *match_head,
+ 			    struct mlx5_flow_table *ft,
+ 			    struct mlx5_flow_spec *spec)
+ {
+ 	struct rhlist_head *tmp, *list;
+ 	struct mlx5_flow_group *g;
+ 	int err = 0;
+ 
+ 	rcu_read_lock();
+ 	INIT_LIST_HEAD(&match_head->list);
+ 	/* Collect all fgs which has a matching match_criteria */
+ 	list = rhltable_lookup(&ft->fgs_hash, spec, rhash_fg);
+ 	/* RCU is atomic, we can't execute FW commands here */
+ 	rhl_for_each_entry_rcu(g, tmp, list, hash) {
+ 		struct match_list *curr_match;
+ 
+ 		if (likely(list_empty(&match_head->list))) {
+ 			match_head->first.g = g;
+ 			list_add_tail(&match_head->first.list,
+ 				      &match_head->list);
+ 			continue;
+ 		}
+ 
+ 		curr_match = kmalloc(sizeof(*curr_match), GFP_ATOMIC);
+ 		if (!curr_match) {
+ 			free_match_list(match_head);
+ 			err = -ENOMEM;
+ 			goto out;
+ 		}
+ 		curr_match->g = g;
+ 		list_add_tail(&curr_match->list, &match_head->list);
+ 	}
+ out:
+ 	rcu_read_unlock();
+ 	return err;
+ }
+ 
+ static struct mlx5_flow_handle *
++<<<<<<< HEAD
++=======
+ try_add_to_existing_fg(struct mlx5_flow_table *ft,
+ 		       struct mlx5_flow_spec *spec,
+ 		       struct mlx5_flow_act *flow_act,
+ 		       struct mlx5_flow_destination *dest,
+ 		       int dest_num)
+ {
+ 	struct mlx5_flow_group *g;
+ 	struct mlx5_flow_handle *rule;
+ 	struct match_list_head match_head;
+ 	struct match_list *iter;
+ 	int err;
+ 
+ 	/* Collect all fgs which has a matching match_criteria */
+ 	err = build_match_list(&match_head, ft, spec);
+ 	if (err)
+ 		return ERR_PTR(err);
+ 
+ 	/* Try to find a fg that already contains a matching fte */
+ 	list_for_each_entry(iter, &match_head.list, list) {
+ 		struct fs_fte *fte;
+ 
+ 		g = iter->g;
+ 		nested_lock_ref_node(&g->node, FS_MUTEX_PARENT);
+ 		fte = rhashtable_lookup_fast(&g->ftes_hash, spec->match_value,
+ 					     rhash_fte);
+ 		if (fte) {
+ 			rule = add_rule_fg(g, spec->match_value,
+ 					   flow_act, dest, dest_num, fte);
+ 			unlock_ref_node(&g->node);
+ 			goto free_list;
+ 		}
+ 		unlock_ref_node(&g->node);
+ 	}
+ 
+ 	/* No group with matching fte found. Try to add a new fte to any
+ 	 * matching fg.
+ 	 */
+ 	list_for_each_entry(iter, &match_head.list, list) {
+ 		g = iter->g;
+ 
+ 		nested_lock_ref_node(&g->node, FS_MUTEX_PARENT);
+ 		rule = add_rule_fg(g, spec->match_value,
+ 				   flow_act, dest, dest_num, NULL);
+ 		if (!IS_ERR(rule) || PTR_ERR(rule) != -ENOSPC) {
+ 			unlock_ref_node(&g->node);
+ 			goto free_list;
+ 		}
+ 		unlock_ref_node(&g->node);
+ 	}
+ 
+ 	rule = ERR_PTR(-ENOENT);
+ 
+ free_list:
+ 	free_match_list(&match_head);
+ 
+ 	return rule;
+ }
+ 
  static struct mlx5_flow_handle *
++>>>>>>> 46719d77d5f3 (net/mlx5: Export building of matched flow groups list)
  _mlx5_add_flow_rules(struct mlx5_flow_table *ft,
  		     struct mlx5_flow_spec *spec,
  		     struct mlx5_flow_act *flow_act,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
