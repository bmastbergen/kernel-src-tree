genetlink: statically initialize families

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Johannes Berg <johannes.berg@intel.com>
commit 489111e5c25b93be80340c3113d71903d7c82136
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/489111e5.failed

Instead of providing macros/inline functions to initialize
the families, make all users initialize them statically and
get rid of the macros.

This reduces the kernel code size by about 1.6k on x86-64
(with allyesconfig).

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 489111e5c25b93be80340c3113d71903d7c82136)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/event.c
#	drivers/net/gtp.c
#	drivers/net/macsec.c
#	drivers/net/team/team.c
#	drivers/net/wireless/mac80211_hwsim.c
#	drivers/scsi/pmcraid.c
#	drivers/target/target_core_user.c
#	drivers/thermal/thermal_core.c
#	fs/dlm/netlink.c
#	fs/quota/netlink.c
#	include/linux/genl_magic_func.h
#	include/net/genetlink.h
#	kernel/taskstats.c
#	net/batman-adv/netlink.c
#	net/core/devlink.c
#	net/core/drop_monitor.c
#	net/hsr/hsr_netlink.c
#	net/ieee802154/netlink.c
#	net/ieee802154/nl802154.c
#	net/ipv4/fou.c
#	net/ipv4/tcp_metrics.c
#	net/ipv6/ila/ila_xlat.c
#	net/irda/irnetlink.c
#	net/l2tp/l2tp_netlink.c
#	net/netfilter/ipvs/ip_vs_ctl.c
#	net/netlabel/netlabel_calipso.c
#	net/netlabel/netlabel_cipso_v4.c
#	net/netlabel/netlabel_mgmt.c
#	net/netlabel/netlabel_unlabeled.c
#	net/netlink/genetlink.c
#	net/nfc/netlink.c
#	net/tipc/netlink.c
#	net/tipc/netlink_compat.c
#	net/wimax/stack.c
diff --cc drivers/acpi/event.c
index 9d55d079b7c4,1ab12ad7d5ba..000000000000
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@@ -177,7 -83,7 +177,11 @@@ static const struct genl_multicast_grou
  };
  
  static struct genl_family acpi_event_genl_family = {
++<<<<<<< HEAD
 +	.id = GENL_ID_GENERATE,
++=======
+ 	.module = THIS_MODULE,
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  	.name = ACPI_GENL_FAMILY_NAME,
  	.version = ACPI_GENL_VERSION,
  	.maxattr = ACPI_GENL_ATTR_MAX,
diff --cc drivers/net/macsec.c
index d1090584a65a,63ca7a3c77cf..000000000000
--- a/drivers/net/macsec.c
+++ b/drivers/net/macsec.c
@@@ -1465,14 -1421,7 +1465,18 @@@ static void clear_tx_sa(struct macsec_t
  	macsec_txsa_put(tx_sa);
  }
  
++<<<<<<< HEAD
 +static struct genl_family macsec_fam = {
 +	.id		= GENL_ID_GENERATE,
 +	.name		= MACSEC_GENL_NAME,
 +	.hdrsize	= 0,
 +	.version	= MACSEC_GENL_VERSION,
 +	.maxattr	= MACSEC_ATTR_MAX,
 +	.netnsok	= true,
 +};
++=======
+ static struct genl_family macsec_fam;
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  
  static struct net_device *get_dev_from_nl(struct net *net,
  					  struct nlattr **attrs)
diff --cc drivers/net/team/team.c
index 93f6926b4b66,46bf7c1216c0..000000000000
--- a/drivers/net/team/team.c
+++ b/drivers/net/team/team.c
@@@ -2153,13 -2150,7 +2153,17 @@@ static struct rtnl_link_ops team_link_o
   * Generic netlink custom interface
   ***********************************/
  
++<<<<<<< HEAD
 +static struct genl_family team_nl_family = {
 +	.id		= GENL_ID_GENERATE,
 +	.name		= TEAM_GENL_NAME,
 +	.version	= TEAM_GENL_VERSION,
 +	.maxattr	= TEAM_ATTR_MAX,
 +	.netnsok	= true,
 +};
++=======
+ static struct genl_family team_nl_family;
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  
  static const struct nla_policy team_nl_policy[TEAM_ATTR_MAX + 1] = {
  	[TEAM_ATTR_UNSPEC]			= { .type = NLA_UNSPEC, },
diff --cc drivers/net/wireless/mac80211_hwsim.c
index cb34c7895f2a,5d4637e586e8..000000000000
--- a/drivers/net/wireless/mac80211_hwsim.c
+++ b/drivers/net/wireless/mac80211_hwsim.c
@@@ -382,13 -579,23 +382,33 @@@ struct hwsim_radiotap_hdr 
  	__le16 rt_chbitmask;
  } __packed;
  
++<<<<<<< HEAD
 +/* MAC80211_HWSIM netlinf family */
 +static struct genl_family hwsim_genl_family = {
 +	.id = GENL_ID_GENERATE,
 +	.hdrsize = 0,
 +	.name = "MAC80211_HWSIM",
 +	.version = 1,
 +	.maxattr = HWSIM_ATTR_MAX,
++=======
+ struct hwsim_radiotap_ack_hdr {
+ 	struct ieee80211_radiotap_header hdr;
+ 	u8 rt_flags;
+ 	u8 pad;
+ 	__le16 rt_channel;
+ 	__le16 rt_chbitmask;
+ } __packed;
+ 
+ /* MAC80211_HWSIM netlink family */
+ static struct genl_family hwsim_genl_family;
+ 
+ enum hwsim_multicast_groups {
+ 	HWSIM_MCGRP_CONFIG,
+ };
+ 
+ static const struct genl_multicast_group hwsim_mcgrps[] = {
+ 	[HWSIM_MCGRP_CONFIG] = { .name = "config", },
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  };
  
  /* MAC80211_HWSIM netlink policy */
@@@ -2092,8 -3208,61 +2112,46 @@@ static struct genl_ops hwsim_ops[] = 
  		.policy = hwsim_genl_policy,
  		.doit = hwsim_tx_info_frame_received_nl,
  	},
 -	{
 -		.cmd = HWSIM_CMD_NEW_RADIO,
 -		.policy = hwsim_genl_policy,
 -		.doit = hwsim_new_radio_nl,
 -		.flags = GENL_UNS_ADMIN_PERM,
 -	},
 -	{
 -		.cmd = HWSIM_CMD_DEL_RADIO,
 -		.policy = hwsim_genl_policy,
 -		.doit = hwsim_del_radio_nl,
 -		.flags = GENL_UNS_ADMIN_PERM,
 -	},
 -	{
 -		.cmd = HWSIM_CMD_GET_RADIO,
 -		.policy = hwsim_genl_policy,
 -		.doit = hwsim_get_radio_nl,
 -		.dumpit = hwsim_dump_radio_nl,
 -	},
  };
  
++<<<<<<< HEAD
++=======
+ static struct genl_family hwsim_genl_family = {
+ 	.name = "MAC80211_HWSIM",
+ 	.version = 1,
+ 	.maxattr = HWSIM_ATTR_MAX,
+ 	.netnsok = true,
+ 	.module = THIS_MODULE,
+ 	.ops = hwsim_ops,
+ 	.n_ops = ARRAY_SIZE(hwsim_ops),
+ 	.mcgrps = hwsim_mcgrps,
+ 	.n_mcgrps = ARRAY_SIZE(hwsim_mcgrps),
+ };
+ 
+ static void destroy_radio(struct work_struct *work)
+ {
+ 	struct mac80211_hwsim_data *data =
+ 		container_of(work, struct mac80211_hwsim_data, destroy_work);
+ 
+ 	mac80211_hwsim_del_radio(data, wiphy_name(data->hw->wiphy), NULL);
+ }
+ 
+ static void remove_user_radios(u32 portid)
+ {
+ 	struct mac80211_hwsim_data *entry, *tmp;
+ 
+ 	spin_lock_bh(&hwsim_radio_lock);
+ 	list_for_each_entry_safe(entry, tmp, &hwsim_radios, list) {
+ 		if (entry->destroy_on_close && entry->portid == portid) {
+ 			list_del(&entry->list);
+ 			INIT_WORK(&entry->destroy_work, destroy_radio);
+ 			schedule_work(&entry->destroy_work);
+ 		}
+ 	}
+ 	spin_unlock_bh(&hwsim_radio_lock);
+ }
+ 
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  static int mac80211_hwsim_netlink_notify(struct notifier_block *nb,
  					 unsigned long state,
  					 void *_notify)
@@@ -2120,14 -3291,9 +2178,18 @@@ static int hwsim_init_netlink(void
  {
  	int rc;
  
 +	/* userspace test API hasn't been adjusted for multi-channel */
 +	if (channels > 1)
 +		return 0;
 +
  	printk(KERN_INFO "mac80211_hwsim: initializing netlink\n");
  
++<<<<<<< HEAD
 +	rc = genl_register_family_with_ops(&hwsim_genl_family,
 +		hwsim_ops, ARRAY_SIZE(hwsim_ops));
++=======
+ 	rc = genl_register_family(&hwsim_genl_family);
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  	if (rc)
  		goto failure;
  
diff --cc drivers/scsi/pmcraid.c
index 90ece0e487a0,c0ab7bb8c3ce..000000000000
--- a/drivers/scsi/pmcraid.c
+++ b/drivers/scsi/pmcraid.c
@@@ -1409,12 -1369,7 +1409,16 @@@ static struct genl_multicast_group pmcr
  };
  
  static struct genl_family pmcraid_event_family = {
++<<<<<<< HEAD
 +	/*
 +	 * Due to prior multicast group abuse (the code having assumed that
 +	 * the family ID can be used as a multicast group ID) we need to
 +	 * statically allocate a family (and thus group) ID.
 +	 */
 +	.id = GENL_ID_PMCRAID,
++=======
+ 	.module = THIS_MODULE,
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  	.name = "pmcraid",
  	.version = 1,
  	.maxattr = PMCRAID_AEN_ATTR_MAX,
diff --cc drivers/target/target_core_user.c
index 7dc2f05f8e5e,3483372f5562..000000000000
--- a/drivers/target/target_core_user.c
+++ b/drivers/target/target_core_user.c
@@@ -165,121 -146,12 +165,125 @@@ static const struct genl_multicast_grou
  	[TCMU_MCGRP_CONFIG] = { .name = "config", },
  };
  
 +static struct nla_policy tcmu_attr_policy[TCMU_ATTR_MAX+1] = {
 +	[TCMU_ATTR_DEVICE]	= { .type = NLA_STRING },
 +	[TCMU_ATTR_MINOR]	= { .type = NLA_U32 },
 +	[TCMU_ATTR_CMD_STATUS]	= { .type = NLA_S32 },
 +	[TCMU_ATTR_DEVICE_ID]	= { .type = NLA_U32 },
 +	[TCMU_ATTR_SUPP_KERN_CMD_REPLY] = { .type = NLA_U8 },
 +};
 +
 +static int tcmu_genl_cmd_done(struct genl_info *info, int completed_cmd)
 +{
 +	struct se_device *dev;
 +	struct tcmu_dev *udev;
 +	struct tcmu_nl_cmd *nl_cmd;
 +	int dev_id, rc, ret = 0;
 +
 +	if (!info->attrs[TCMU_ATTR_CMD_STATUS] ||
 +	    !info->attrs[TCMU_ATTR_DEVICE_ID]) {
 +		printk(KERN_ERR "TCMU_ATTR_CMD_STATUS or TCMU_ATTR_DEVICE_ID not set, doing nothing\n");
 +		return -EINVAL;
 +	}
 +
 +	dev_id = nla_get_u32(info->attrs[TCMU_ATTR_DEVICE_ID]);
 +	rc = nla_get_s32(info->attrs[TCMU_ATTR_CMD_STATUS]);
 +
 +	mutex_lock(&device_mutex);
 +	dev = idr_find(&devices_idr, dev_id);
 +	mutex_unlock(&device_mutex);
 +	if (!dev) {
 +		printk(KERN_ERR "tcmu nl cmd %u/%u completion could not find device with dev id %u.\n",
 +		       completed_cmd, rc, dev_id);
 +		return -ENODEV;
 +	}
 +	udev = TCMU_DEV(dev);
 +
 +	spin_lock(&udev->nl_cmd_lock);
 +	nl_cmd = &udev->curr_nl_cmd;
 +
 +	pr_debug("genl cmd done got id %d curr %d done %d rc %d\n", dev_id,
 +		 nl_cmd->cmd, completed_cmd, rc);
 +
 +	if (nl_cmd->cmd != completed_cmd) {
 +		printk(KERN_ERR "Mismatched commands (Expecting reply for %d. Current %d).\n",
 +		       completed_cmd, nl_cmd->cmd);
 +		ret = -EINVAL;
 +	} else {
 +		nl_cmd->status = rc;
 +	}
 +
 +	spin_unlock(&udev->nl_cmd_lock);
 +	if (!ret)
 +		complete(&nl_cmd->complete);
 +	return ret;
 +}
 +
 +static int tcmu_genl_rm_dev_done(struct sk_buff *skb, struct genl_info *info)
 +{
 +	return tcmu_genl_cmd_done(info, TCMU_CMD_REMOVED_DEVICE);
 +}
 +
 +static int tcmu_genl_add_dev_done(struct sk_buff *skb, struct genl_info *info)
 +{
 +	return tcmu_genl_cmd_done(info, TCMU_CMD_ADDED_DEVICE);
 +}
 +
 +static int tcmu_genl_reconfig_dev_done(struct sk_buff *skb,
 +				       struct genl_info *info)
 +{
 +	return tcmu_genl_cmd_done(info, TCMU_CMD_RECONFIG_DEVICE);
 +}
 +
 +static int tcmu_genl_set_features(struct sk_buff *skb, struct genl_info *info)
 +{
 +	if (info->attrs[TCMU_ATTR_SUPP_KERN_CMD_REPLY]) {
 +		tcmu_kern_cmd_reply_supported  =
 +			nla_get_u8(info->attrs[TCMU_ATTR_SUPP_KERN_CMD_REPLY]);
 +		printk(KERN_INFO "tcmu daemon: command reply support %u.\n",
 +		       tcmu_kern_cmd_reply_supported);
 +	}
 +
 +	return 0;
 +}
 +
 +static const struct genl_ops tcmu_genl_ops[] = {
 +	{
 +		.cmd	= TCMU_CMD_SET_FEATURES,
 +		.flags	= GENL_ADMIN_PERM,
 +		.policy	= tcmu_attr_policy,
 +		.doit	= tcmu_genl_set_features,
 +	},
 +	{
 +		.cmd	= TCMU_CMD_ADDED_DEVICE_DONE,
 +		.flags	= GENL_ADMIN_PERM,
 +		.policy	= tcmu_attr_policy,
 +		.doit	= tcmu_genl_add_dev_done,
 +	},
 +	{
 +		.cmd	= TCMU_CMD_REMOVED_DEVICE_DONE,
 +		.flags	= GENL_ADMIN_PERM,
 +		.policy	= tcmu_attr_policy,
 +		.doit	= tcmu_genl_rm_dev_done,
 +	},
 +	{
 +		.cmd	= TCMU_CMD_RECONFIG_DEVICE_DONE,
 +		.flags	= GENL_ADMIN_PERM,
 +		.policy	= tcmu_attr_policy,
 +		.doit	= tcmu_genl_reconfig_dev_done,
 +	},
 +};
 +
  /* Our generic netlink family */
  static struct genl_family tcmu_genl_family = {
++<<<<<<< HEAD
 +	.id = GENL_ID_GENERATE,
++=======
+ 	.module = THIS_MODULE,
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  	.hdrsize = 0,
  	.name = "TCM-USER",
 -	.version = 1,
 +	.version = 2,
  	.maxattr = TCMU_ATTR_MAX,
  	.mcgrps = tcmu_mcgrps,
  	.n_mcgrps = ARRAY_SIZE(tcmu_mcgrps),
diff --cc drivers/thermal/thermal_core.c
index 0dce5095a6a1,93b6caab2d9f..000000000000
--- a/drivers/thermal/thermal_core.c
+++ b/drivers/thermal/thermal_core.c
@@@ -1846,7 -2164,7 +1846,11 @@@ static const struct genl_multicast_grou
  };
  
  static struct genl_family thermal_event_genl_family = {
++<<<<<<< HEAD
 +	.id = GENL_ID_GENERATE,
++=======
+ 	.module = THIS_MODULE,
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  	.name = THERMAL_GENL_FAMILY_NAME,
  	.version = THERMAL_GENL_VERSION,
  	.maxattr = THERMAL_GENL_ATTR_MAX,
diff --cc fs/dlm/netlink.c
index 1e6e227134d7,04042d69573c..000000000000
--- a/fs/dlm/netlink.c
+++ b/fs/dlm/netlink.c
@@@ -16,11 -16,7 +16,15 @@@
  static uint32_t dlm_nl_seqnum;
  static uint32_t listener_nlportid;
  
++<<<<<<< HEAD
 +static struct genl_family family = {
 +	.id		= GENL_ID_GENERATE,
 +	.name		= DLM_GENL_NAME,
 +	.version	= DLM_GENL_VERSION,
 +};
++=======
+ static struct genl_family family;
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  
  static int prepare_data(u8 cmd, struct sk_buff **skbp, size_t size)
  {
diff --cc fs/quota/netlink.c
index 1117f2b7a126,9457c7b0dfa2..000000000000
--- a/fs/quota/netlink.c
+++ b/fs/quota/netlink.c
@@@ -15,13 -13,7 +15,17 @@@ static const struct genl_multicast_grou
  
  /* Netlink family structure for quota */
  static struct genl_family quota_genl_family = {
++<<<<<<< HEAD
 +	/*
 +	 * Needed due to multicast group ID abuse - old code assumed
 +	 * the family ID was also a valid multicast group ID (which
 +	 * isn't true) and userspace might thus rely on it. Assign a
 +	 * static ID for this group to make dealing with that easier.
 +	 */
 +	.id = GENL_ID_VFS_DQUOT,
++=======
+ 	.module = THIS_MODULE,
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  	.hdrsize = 0,
  	.name = "VFS_DQUOT",
  	.version = 1,
diff --cc include/linux/genl_magic_func.h
index c0894dd8827b,40c2e39362c8..000000000000
--- a/include/linux/genl_magic_func.h
+++ b/include/linux/genl_magic_func.h
@@@ -259,16 -259,7 +259,20 @@@ static struct genl_ops ZZZ_genl_ops[] _
   *									{{{2
   */
  #define ZZZ_genl_family		CONCAT_(GENL_MAGIC_FAMILY, _genl_family)
++<<<<<<< HEAD
 +static struct genl_family ZZZ_genl_family __read_mostly = {
 +	.id = GENL_ID_GENERATE,
 +	.name = __stringify(GENL_MAGIC_FAMILY),
 +	.version = GENL_MAGIC_VERSION,
 +#ifdef GENL_MAGIC_FAMILY_HDRSZ
 +	.hdrsize = NLA_ALIGN(GENL_MAGIC_FAMILY_HDRSZ),
 +#endif
 +	.maxattr = ARRAY_SIZE(drbd_tla_nl_policy)-1,
 +};
 +
++=======
+ static struct genl_family ZZZ_genl_family;
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  /*
   * Magic: define multicast groups
   * Magic: define multicast group registration helper
diff --cc include/net/genetlink.h
index f37e06abcb6d,2298b50cee34..000000000000
--- a/include/net/genetlink.h
+++ b/include/net/genetlink.h
@@@ -35,16 -33,23 +35,30 @@@ struct genl_info
   *	do additional, common, filtering and return an error
   * @post_doit: called after an operation's doit callback, it may
   *	undo operations done by pre_doit, for example release locks
++<<<<<<< HEAD
 + * @attrbuf: buffer to store parsed attributes
 + * @family_list: family list
 + * @mcgrps: multicast groups used by this family (private)
 + * @n_mcgrps: number of multicast groups (private)
++=======
+  * @mcast_bind: a socket bound to the given multicast group (which
+  *	is given as the offset into the groups array)
+  * @mcast_unbind: a socket was unbound from the given multicast group.
+  *	Note that unbind() will not be called symmetrically if the
+  *	generic netlink family is removed while there are still open
+  *	sockets.
+  * @attrbuf: buffer to store parsed attributes (private)
+  * @family_list: family list (private)
+  * @mcgrps: multicast groups used by this family
+  * @n_mcgrps: number of multicast groups
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
   * @mcgrp_offset: starting number of multicast group IDs in this family
-  * @ops: the operations supported by this family (private)
-  * @n_ops: number of operations supported by this family (private)
+  *	(private)
+  * @ops: the operations supported by this family
+  * @n_ops: number of operations supported by this family
   */
  struct genl_family {
 -	unsigned int		id;		/* private */
 +	unsigned int		id;
  	unsigned int		hdrsize;
  	char			name[GENL_NAMSIZ];
  	unsigned int		version;
@@@ -57,11 -62,13 +71,11 @@@
  	void			(*post_doit)(const struct genl_ops *ops,
  					     struct sk_buff *skb,
  					     struct genl_info *info);
 -	int			(*mcast_bind)(struct net *net, int group);
 -	void			(*mcast_unbind)(struct net *net, int group);
  	struct nlattr **	attrbuf;	/* private */
- 	const struct genl_ops *	ops;		/* private */
- 	const struct genl_multicast_group *mcgrps; /* private */
- 	unsigned int		n_ops;		/* private */
- 	unsigned int		n_mcgrps;	/* private */
+ 	const struct genl_ops *	ops;
+ 	const struct genl_multicast_group *mcgrps;
+ 	unsigned int		n_ops;
+ 	unsigned int		n_mcgrps;
  	unsigned int		mcgrp_offset;	/* private */
  	struct list_head	family_list;	/* private */
  	struct module		*module;
@@@ -131,65 -133,11 +145,69 @@@ struct genl_ops 
  	u8			flags;
  };
  
++<<<<<<< HEAD
 +int __genl_register_family(struct genl_family *family);
 +
 +static inline int genl_register_family(struct genl_family *family)
 +{
 +	family->module = THIS_MODULE;
 +	return __genl_register_family(family);
 +}
 +
 +/**
 + * genl_register_family_with_ops - register a generic netlink family with ops
 + * @family: generic netlink family
 + * @ops: operations to be registered
 + * @n_ops: number of elements to register
 + *
 + * Registers the specified family and operations from the specified table.
 + * Only one family may be registered with the same family name or identifier.
 + *
 + * The family id may equal GENL_ID_GENERATE causing an unique id to
 + * be automatically generated and assigned.
 + *
 + * Either a doit or dumpit callback must be specified for every registered
 + * operation or the function will fail. Only one operation structure per
 + * command identifier may be registered.
 + *
 + * See include/net/genetlink.h for more documenation on the operations
 + * structure.
 + *
 + * Return 0 on success or a negative error code.
 + */
 +static inline int
 +_genl_register_family_with_ops_grps(struct genl_family *family,
 +				    const struct genl_ops *ops, size_t n_ops,
 +				    const struct genl_multicast_group *mcgrps,
 +				    size_t n_mcgrps)
 +{
 +	family->module = THIS_MODULE;
 +	family->ops = ops;
 +	family->n_ops = n_ops;
 +	family->mcgrps = mcgrps;
 +	family->n_mcgrps = n_mcgrps;
 +	return __genl_register_family(family);
 +}
 +
 +#define genl_register_family_with_ops(family, ops)			\
 +	_genl_register_family_with_ops_grps((family),			\
 +					    (ops), ARRAY_SIZE(ops),	\
 +					    NULL, 0)
 +#define genl_register_family_with_ops_groups(family, ops, grps)	\
 +	_genl_register_family_with_ops_grps((family),			\
 +					    (ops), ARRAY_SIZE(ops),	\
 +					    (grps), ARRAY_SIZE(grps))
 +
++=======
+ int genl_register_family(struct genl_family *family);
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  int genl_unregister_family(struct genl_family *family);
 -void genl_notify(struct genl_family *family, struct sk_buff *skb,
 -		 struct genl_info *info, u32 group, gfp_t flags);
 +void genl_notify(struct genl_family *family,
 +		 struct sk_buff *skb, struct net *net, u32 portid,
 +		 u32 group, struct nlmsghdr *nlh, gfp_t flags);
  
 +struct sk_buff *genlmsg_new_unicast(size_t payload, struct genl_info *info,
 +				    gfp_t flags);
  void *genlmsg_put(struct sk_buff *skb, u32 portid, u32 seq,
  		  struct genl_family *family, int flags, u8 cmd);
  
diff --cc kernel/taskstats.c
index cc164a5485ab,4075ece592f2..000000000000
--- a/kernel/taskstats.c
+++ b/kernel/taskstats.c
@@@ -41,12 -41,7 +41,16 @@@ static DEFINE_PER_CPU(__u32, taskstats_
  static int family_registered;
  struct kmem_cache *taskstats_cache;
  
++<<<<<<< HEAD
 +static struct genl_family family = {
 +	.id		= GENL_ID_GENERATE,
 +	.name		= TASKSTATS_GENL_NAME,
 +	.version	= TASKSTATS_GENL_VERSION,
 +	.maxattr	= TASKSTATS_CMD_ATTR_MAX,
 +};
++=======
+ static struct genl_family family;
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  
  static const struct nla_policy taskstats_cmd_get_policy[TASKSTATS_CMD_ATTR_MAX+1] = {
  	[TASKSTATS_CMD_ATTR_PID]  = { .type = NLA_U32 },
diff --cc net/core/devlink.c
index df45d8e125ae,063da8091aef..000000000000
--- a/net/core/devlink.c
+++ b/net/core/devlink.c
@@@ -341,15 -341,7 +341,19 @@@ static void devlink_nl_post_doit(const 
  	mutex_unlock(&devlink_mutex);
  }
  
++<<<<<<< HEAD
 +static struct genl_family devlink_nl_family = {
 +	.id		= GENL_ID_GENERATE,
 +	.name		= DEVLINK_GENL_NAME,
 +	.version	= DEVLINK_GENL_VERSION,
 +	.maxattr	= DEVLINK_ATTR_MAX,
 +	.netnsok	= true,
 +	.pre_doit	= devlink_nl_pre_doit,
 +	.post_doit	= devlink_nl_post_doit,
 +};
++=======
+ static struct genl_family devlink_nl_family;
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  
  enum devlink_multicast_groups {
  	DEVLINK_MCGRP_CONFIG,
@@@ -1650,8 -1596,36 +1654,22 @@@ static const struct genl_ops devlink_nl
  				  DEVLINK_NL_FLAG_NEED_SB |
  				  DEVLINK_NL_FLAG_LOCK_PORTS,
  	},
 -	{
 -		.cmd = DEVLINK_CMD_ESWITCH_MODE_GET,
 -		.doit = devlink_nl_cmd_eswitch_mode_get_doit,
 -		.policy = devlink_nl_policy,
 -		.flags = GENL_ADMIN_PERM,
 -		.internal_flags = DEVLINK_NL_FLAG_NEED_DEVLINK,
 -	},
 -	{
 -		.cmd = DEVLINK_CMD_ESWITCH_MODE_SET,
 -		.doit = devlink_nl_cmd_eswitch_mode_set_doit,
 -		.policy = devlink_nl_policy,
 -		.flags = GENL_ADMIN_PERM,
 -		.internal_flags = DEVLINK_NL_FLAG_NEED_DEVLINK,
 -	},
  };
  
+ static struct genl_family devlink_nl_family = {
+ 	.name		= DEVLINK_GENL_NAME,
+ 	.version	= DEVLINK_GENL_VERSION,
+ 	.maxattr	= DEVLINK_ATTR_MAX,
+ 	.netnsok	= true,
+ 	.pre_doit	= devlink_nl_pre_doit,
+ 	.post_doit	= devlink_nl_post_doit,
+ 	.module		= THIS_MODULE,
+ 	.ops		= devlink_nl_ops,
+ 	.n_ops		= ARRAY_SIZE(devlink_nl_ops),
+ 	.mcgrps		= devlink_nl_mcgrps,
+ 	.n_mcgrps	= ARRAY_SIZE(devlink_nl_mcgrps),
+ };
+ 
  /**
   *	devlink_alloc - Allocate new devlink instance resources
   *
diff --cc net/core/drop_monitor.c
index 8c83f0174ad1,80c002794ff6..000000000000
--- a/net/core/drop_monitor.c
+++ b/net/core/drop_monitor.c
@@@ -59,12 -59,7 +59,16 @@@ struct dm_hw_stat_delta 
  	unsigned long last_drop_val;
  };
  
++<<<<<<< HEAD
 +static struct genl_family net_drop_monitor_family = {
 +	.id             = GENL_ID_GENERATE,
 +	.hdrsize        = 0,
 +	.name           = "NET_DM",
 +	.version        = 2,
 +};
++=======
+ static struct genl_family net_drop_monitor_family;
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  
  static DEFINE_PER_CPU(struct per_cpu_dm_data, dm_cpu_data);
  
diff --cc net/ieee802154/netlink.c
index c8133c07ceee,08e62470bac2..000000000000
--- a/net/ieee802154/netlink.c
+++ b/net/ieee802154/netlink.c
@@@ -28,14 -28,6 +28,17 @@@
  static unsigned int ieee802154_seq_num;
  static DEFINE_SPINLOCK(ieee802154_seq_lock);
  
++<<<<<<< HEAD
 +struct genl_family nl802154_family = {
 +	.id		= GENL_ID_GENERATE,
 +	.hdrsize	= 0,
 +	.name		= IEEE802154_NL_NAME,
 +	.version	= 1,
 +	.maxattr	= IEEE802154_ATTR_MAX,
 +};
 +
++=======
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  /* Requests to userspace */
  struct sk_buff *ieee802154_nl_create(int flags, u8 req)
  {
diff --cc net/ieee802154/nl802154.c
index 0a289ced1d31,f7e75578aedd..000000000000
--- a/net/ieee802154/nl802154.c
+++ b/net/ieee802154/nl802154.c
@@@ -26,23 -26,8 +26,21 @@@
  #include "rdev-ops.h"
  #include "core.h"
  
- static int nl802154_pre_doit(const struct genl_ops *ops, struct sk_buff *skb,
- 			     struct genl_info *info);
- 
- static void nl802154_post_doit(const struct genl_ops *ops, struct sk_buff *skb,
- 			       struct genl_info *info);
- 
  /* the netlink family */
++<<<<<<< HEAD
 +static struct genl_family nl802154_fam = {
 +	.id = GENL_ID_GENERATE,		/* don't bother with a hardcoded ID */
 +	.name = NL802154_GENL_NAME,	/* have users key off the name instead */
 +	.hdrsize = 0,			/* no private header */
 +	.version = 1,			/* no particular meaning now */
 +	.maxattr = NL802154_ATTR_MAX,
 +	.netnsok = true,
 +	.pre_doit = nl802154_pre_doit,
 +	.post_doit = nl802154_post_doit,
 +};
++=======
+ static struct genl_family nl802154_fam;
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  
  /* multicast groups */
  enum nl802154_multicast_groups {
diff --cc net/ipv4/fou.c
index f471d6929968,5b5226a2434f..000000000000
--- a/net/ipv4/fou.c
+++ b/net/ipv4/fou.c
@@@ -545,16 -622,9 +545,20 @@@ static int fou_destroy(struct net *net
  	return err;
  }
  
++<<<<<<< HEAD
 +static struct genl_family fou_nl_family = {
 +	.id		= GENL_ID_GENERATE,
 +	.hdrsize	= 0,
 +	.name		= FOU_GENL_NAME,
 +	.version	= FOU_GENL_VERSION,
 +	.maxattr	= FOU_ATTR_MAX,
 +	.netnsok	= true,
 +};
++=======
+ static struct genl_family fou_nl_family;
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  
 -static const struct nla_policy fou_nl_policy[FOU_ATTR_MAX + 1] = {
 +static struct nla_policy fou_nl_policy[FOU_ATTR_MAX + 1] = {
  	[FOU_ATTR_PORT] = { .type = NLA_U16, },
  	[FOU_ATTR_AF] = { .type = NLA_U8, },
  	[FOU_ATTR_IPPROTO] = { .type = NLA_U8, },
@@@ -630,8 -816,25 +634,19 @@@ static const struct genl_ops fou_nl_ops
  		.policy = fou_nl_policy,
  		.flags = GENL_ADMIN_PERM,
  	},
 -	{
 -		.cmd = FOU_CMD_GET,
 -		.doit = fou_nl_cmd_get_port,
 -		.dumpit = fou_nl_dump,
 -		.policy = fou_nl_policy,
 -	},
  };
  
+ static struct genl_family fou_nl_family = {
+ 	.hdrsize	= 0,
+ 	.name		= FOU_GENL_NAME,
+ 	.version	= FOU_GENL_VERSION,
+ 	.maxattr	= FOU_ATTR_MAX,
+ 	.netnsok	= true,
+ 	.module		= THIS_MODULE,
+ 	.ops		= fou_nl_ops,
+ 	.n_ops		= ARRAY_SIZE(fou_nl_ops),
+ };
+ 
  size_t fou_encap_hlen(struct ip_tunnel_encap *e)
  {
  	return sizeof(struct udphdr);
@@@ -830,16 -1086,21 +845,24 @@@ static int __init fou_init(void
  {
  	int ret;
  
++<<<<<<< HEAD
 +	ret = genl_register_family_with_ops(&fou_nl_family,
 +					    fou_nl_ops);
 +
++=======
+ 	ret = register_pernet_device(&fou_net_ops);
+ 	if (ret)
+ 		goto exit;
+ 
+ 	ret = genl_register_family(&fou_nl_family);
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  	if (ret < 0)
 -		goto unregister;
 +		goto exit;
  
  	ret = ip_tunnel_encap_add_fou_ops();
 -	if (ret == 0)
 -		return 0;
 +	if (ret < 0)
 +		genl_unregister_family(&fou_nl_family);
  
 -	genl_unregister_family(&fou_nl_family);
 -unregister:
 -	unregister_pernet_device(&fou_net_ops);
  exit:
  	return ret;
  }
diff --cc net/ipv4/tcp_metrics.c
index af7c5919cddc,bba3c72c4a39..000000000000
--- a/net/ipv4/tcp_metrics.c
+++ b/net/ipv4/tcp_metrics.c
@@@ -735,16 -742,9 +735,20 @@@ void tcp_fastopen_cache_set(struct soc
  	rcu_read_unlock();
  }
  
++<<<<<<< HEAD
 +static struct genl_family tcp_metrics_nl_family = {
 +	.id		= GENL_ID_GENERATE,
 +	.hdrsize	= 0,
 +	.name		= TCP_METRICS_GENL_NAME,
 +	.version	= TCP_METRICS_GENL_VERSION,
 +	.maxattr	= TCP_METRICS_ATTR_MAX,
 +	.netnsok	= true,
 +};
++=======
+ static struct genl_family tcp_metrics_nl_family;
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  
 -static const struct nla_policy tcp_metrics_nl_policy[TCP_METRICS_ATTR_MAX + 1] = {
 +static struct nla_policy tcp_metrics_nl_policy[TCP_METRICS_ATTR_MAX + 1] = {
  	[TCP_METRICS_ATTR_ADDR_IPV4]	= { .type = NLA_U32, },
  	[TCP_METRICS_ATTR_ADDR_IPV6]	= { .type = NLA_BINARY,
  					    .len = sizeof(struct in6_addr), },
@@@ -1181,16 -1181,9 +1196,22 @@@ void __init tcp_metrics_init(void
  
  	ret = register_pernet_subsys(&tcp_net_metrics_ops);
  	if (ret < 0)
++<<<<<<< HEAD
 +		goto cleanup;
 +	ret = genl_register_family_with_ops(&tcp_metrics_nl_family,
 +					    tcp_metrics_nl_ops);
++=======
+ 		panic("Could not allocate the tcp_metrics hash table\n");
+ 
+ 	ret = genl_register_family(&tcp_metrics_nl_family);
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  	if (ret < 0)
 -		panic("Could not register tcp_metrics generic netlink\n");
 +		goto cleanup_subsys;
 +	return;
 +
 +cleanup_subsys:
 +	unregister_pernet_subsys(&tcp_net_metrics_ops);
 +
 +cleanup:
 +	return;
  }
diff --cc net/irda/irnetlink.c
index c32971269280,07877347c2f7..000000000000
--- a/net/irda/irnetlink.c
+++ b/net/irda/irnetlink.c
@@@ -24,13 -24,7 +24,17 @@@
  
  
  
++<<<<<<< HEAD
 +static struct genl_family irda_nl_family = {
 +	.id = GENL_ID_GENERATE,
 +	.name = IRDA_NL_NAME,
 +	.hdrsize = 0,
 +	.version = IRDA_NL_VERSION,
 +	.maxattr = IRDA_NL_CMD_MAX,
 +};
++=======
+ static struct genl_family irda_nl_family;
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  
  static struct net_device * ifname_to_netdev(struct net *net, struct genl_info *info)
  {
@@@ -147,10 -141,19 +151,24 @@@ static struct genl_ops irda_nl_ops[] = 
  
  };
  
+ static struct genl_family irda_nl_family = {
+ 	.name = IRDA_NL_NAME,
+ 	.hdrsize = 0,
+ 	.version = IRDA_NL_VERSION,
+ 	.maxattr = IRDA_NL_CMD_MAX,
+ 	.module = THIS_MODULE,
+ 	.ops = irda_nl_ops,
+ 	.n_ops = ARRAY_SIZE(irda_nl_ops),
+ };
+ 
  int irda_nl_register(void)
  {
++<<<<<<< HEAD
 +	return genl_register_family_with_ops(&irda_nl_family,
 +		irda_nl_ops, ARRAY_SIZE(irda_nl_ops));
++=======
+ 	return genl_register_family(&irda_nl_family);
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  }
  
  void irda_nl_unregister(void)
diff --cc net/l2tp/l2tp_netlink.c
index 4d89df5b3f9c,e4e8c0769a6b..000000000000
--- a/net/l2tp/l2tp_netlink.c
+++ b/net/l2tp/l2tp_netlink.c
@@@ -31,14 -31,19 +31,18 @@@
  #include "l2tp_core.h"
  
  
 -static struct genl_family l2tp_nl_family;
 -
 -static const struct genl_multicast_group l2tp_multicast_group[] = {
 -	{
 -		.name = L2TP_GENL_MCGROUP,
 -	},
++<<<<<<< HEAD
 +static struct genl_family l2tp_nl_family = {
 +	.id		= GENL_ID_GENERATE,
 +	.name		= L2TP_GENL_NAME,
 +	.version	= L2TP_GENL_VERSION,
 +	.hdrsize	= 0,
 +	.maxattr	= L2TP_ATTR_MAX,
 +	.netnsok	= true,
  };
 -
 -static int l2tp_nl_tunnel_send(struct sk_buff *skb, u32 portid, u32 seq,
 -			       int flags, struct l2tp_tunnel *tunnel, u8 cmd);
 -static int l2tp_nl_session_send(struct sk_buff *skb, u32 portid, u32 seq,
 -				int flags, struct l2tp_session *session,
 -				u8 cmd);
++=======
++static struct genl_family l2tp_nl_family;
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  
  /* Accessed under genl lock */
  static const struct l2tp_nl_cmd_ops *l2tp_nl_cmd_ops[__L2TP_PWTYPE_MAX];
@@@ -915,7 -1019,7 +932,11 @@@ EXPORT_SYMBOL_GPL(l2tp_nl_unregister_op
  static int l2tp_nl_init(void)
  {
  	pr_info("L2TP netlink interface\n");
++<<<<<<< HEAD
 +	return genl_register_family_with_ops(&l2tp_nl_family, l2tp_nl_ops);
++=======
+ 	return genl_register_family(&l2tp_nl_family);
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  }
  
  static void l2tp_nl_cleanup(void)
diff --cc net/netfilter/ipvs/ip_vs_ctl.c
index 95b70320d2ed,ea3e8aed063f..000000000000
--- a/net/netfilter/ipvs/ip_vs_ctl.c
+++ b/net/netfilter/ipvs/ip_vs_ctl.c
@@@ -2812,14 -2840,7 +2812,18 @@@ static struct nf_sockopt_ops ip_vs_sock
   */
  
  /* IPVS genetlink family */
++<<<<<<< HEAD
 +static struct genl_family ip_vs_genl_family = {
 +	.id		= GENL_ID_GENERATE,
 +	.hdrsize	= 0,
 +	.name		= IPVS_GENL_NAME,
 +	.version	= IPVS_GENL_VERSION,
 +	.maxattr	= IPVS_CMD_MAX,
 +	.netnsok        = true,         /* Make ipvsadm to work on netns */
 +};
++=======
+ static struct genl_family ip_vs_genl_family;
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  
  /* Policy used for first-level command attributes */
  static const struct nla_policy ip_vs_cmd_policy[IPVS_CMD_ATTR_MAX + 1] = {
diff --cc net/netlabel/netlabel_cipso_v4.c
index 59738ffdc1d9,a665eae91245..000000000000
--- a/net/netlabel/netlabel_cipso_v4.c
+++ b/net/netlabel/netlabel_cipso_v4.c
@@@ -60,14 -59,7 +60,18 @@@ struct netlbl_domhsh_walk_arg 
  };
  
  /* NetLabel Generic NETLINK CIPSOv4 family */
++<<<<<<< HEAD
 +static struct genl_family netlbl_cipsov4_gnl_family = {
 +	.id = GENL_ID_GENERATE,
 +	.hdrsize = 0,
 +	.name = NETLBL_NLTYPE_CIPSOV4_NAME,
 +	.version = NETLBL_PROTO_VERSION,
 +	.maxattr = NLBL_CIPSOV4_A_MAX,
 +};
 +
++=======
+ static struct genl_family netlbl_cipsov4_gnl_family;
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  /* NetLabel Netlink attribute policy */
  static const struct nla_policy netlbl_cipsov4_genl_policy[NLBL_CIPSOV4_A_MAX + 1] = {
  	[NLBL_CIPSOV4_A_DOI] = { .type = NLA_U32 },
diff --cc net/netlabel/netlabel_mgmt.c
index 2ea2a40e0cdc,ecfe8eb149db..000000000000
--- a/net/netlabel/netlabel_mgmt.c
+++ b/net/netlabel/netlabel_mgmt.c
@@@ -59,13 -60,7 +59,17 @@@ struct netlbl_domhsh_walk_arg 
  };
  
  /* NetLabel Generic NETLINK CIPSOv4 family */
++<<<<<<< HEAD
 +static struct genl_family netlbl_mgmt_gnl_family = {
 +	.id = GENL_ID_GENERATE,
 +	.hdrsize = 0,
 +	.name = NETLBL_NLTYPE_MGMT_NAME,
 +	.version = NETLBL_PROTO_VERSION,
 +	.maxattr = NLBL_MGMT_A_MAX,
 +};
++=======
+ static struct genl_family netlbl_mgmt_gnl_family;
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  
  /* NetLabel Netlink attribute policy */
  static const struct nla_policy netlbl_mgmt_genl_policy[NLBL_MGMT_A_MAX + 1] = {
diff --cc net/netlabel/netlabel_unlabeled.c
index 8600bdf8edfd,5dbbad41114f..000000000000
--- a/net/netlabel/netlabel_unlabeled.c
+++ b/net/netlabel/netlabel_unlabeled.c
@@@ -117,20 -116,14 +117,24 @@@ struct netlbl_unlhsh_walk_arg 
  static DEFINE_SPINLOCK(netlbl_unlhsh_lock);
  #define netlbl_unlhsh_rcu_deref(p) \
  	rcu_dereference_check(p, lockdep_is_held(&netlbl_unlhsh_lock))
 -static struct netlbl_unlhsh_tbl __rcu *netlbl_unlhsh;
 -static struct netlbl_unlhsh_iface __rcu *netlbl_unlhsh_def;
 +static struct netlbl_unlhsh_tbl *netlbl_unlhsh = NULL;
 +static struct netlbl_unlhsh_iface *netlbl_unlhsh_def = NULL;
  
  /* Accept unlabeled packets flag */
 -static u8 netlabel_unlabel_acceptflg;
 +static u8 netlabel_unlabel_acceptflg = 0;
  
  /* NetLabel Generic NETLINK unlabeled family */
++<<<<<<< HEAD
 +static struct genl_family netlbl_unlabel_gnl_family = {
 +	.id = GENL_ID_GENERATE,
 +	.hdrsize = 0,
 +	.name = NETLBL_NLTYPE_UNLABELED_NAME,
 +	.version = NETLBL_PROTO_VERSION,
 +	.maxattr = NLBL_UNLABEL_A_MAX,
 +};
++=======
+ static struct genl_family netlbl_unlabel_gnl_family;
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  
  /* NetLabel Netlink attribute policy */
  static const struct nla_policy netlbl_unlabel_genl_policy[NLBL_UNLABEL_A_MAX + 1] = {
diff --cc net/netlink/genetlink.c
index a93aabe188f7,ca582ee4ae05..000000000000
--- a/net/netlink/genetlink.c
+++ b/net/netlink/genetlink.c
@@@ -346,23 -349,15 +346,23 @@@ static int genl_validate_ops(const stru
   *
   * Registers the specified family after validating it first. Only one
   * family may be registered with the same family name or identifier.
 + * The family id may equal GENL_ID_GENERATE causing an unique id to
 + * be automatically generated and assigned.
   *
-  * The family's ops array must already be assigned, you can use the
-  * genl_register_family_with_ops() helper function.
+  * The family's ops, multicast groups and module pointer must already
+  * be assigned.
   *
   * Return 0 on success or a negative error code.
   */
- int __genl_register_family(struct genl_family *family)
+ int genl_register_family(struct genl_family *family)
  {
 -	int err, i;
 +	int err = -EINVAL, i;
 +
 +	if (family->id && family->id < GENL_MIN_ID)
 +		goto errout;
 +
 +	if (family->id > GENL_MAX_ID)
 +		goto errout;
  
  	err = genl_validate_ops(family);
  	if (err)
@@@ -416,10 -427,9 +416,10 @@@
  
  errout_locked:
  	genl_unlock_all();
 +errout:
  	return err;
  }
- EXPORT_SYMBOL(__genl_register_family);
+ EXPORT_SYMBOL(genl_register_family);
  
  /**
   * genl_unregister_family - unregister generic netlink family
@@@ -441,9 -449,13 +441,16 @@@ int genl_unregister_family(struct genl_
  		if (family->id != rc->id || strcmp(rc->name, family->name))
  			continue;
  
 -		genl_unregister_mc_groups(family);
 -
  		list_del(&rc->family_list);
++<<<<<<< HEAD
 +		family->n_ops = 0;
 +		genl_unlock_all();
++=======
+ 		up_write(&cb_lock);
+ 		wait_event(genl_sk_destructing_waitq,
+ 			   atomic_read(&genl_sk_destructing_cnt) == 0);
+ 		genl_unlock();
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  
  		kfree(family->attrbuf);
  		genl_ctrl_event(CTRL_CMD_DELFAMILY, family, NULL, 0);
@@@ -989,6 -990,69 +990,72 @@@ static struct genl_multicast_group genl
  	{ .name = "notify", },
  };
  
++<<<<<<< HEAD
++=======
+ static struct genl_family genl_ctrl = {
+ 	.module = THIS_MODULE,
+ 	.ops = genl_ctrl_ops,
+ 	.n_ops = ARRAY_SIZE(genl_ctrl_ops),
+ 	.mcgrps = genl_ctrl_groups,
+ 	.n_mcgrps = ARRAY_SIZE(genl_ctrl_groups),
+ 	.id = GENL_ID_CTRL,
+ 	.name = "nlctrl",
+ 	.version = 0x2,
+ 	.maxattr = CTRL_ATTR_MAX,
+ 	.netnsok = true,
+ };
+ 
+ static int genl_bind(struct net *net, int group)
+ {
+ 	int i, err = -ENOENT;
+ 
+ 	down_read(&cb_lock);
+ 	for (i = 0; i < GENL_FAM_TAB_SIZE; i++) {
+ 		struct genl_family *f;
+ 
+ 		list_for_each_entry(f, genl_family_chain(i), family_list) {
+ 			if (group >= f->mcgrp_offset &&
+ 			    group < f->mcgrp_offset + f->n_mcgrps) {
+ 				int fam_grp = group - f->mcgrp_offset;
+ 
+ 				if (!f->netnsok && net != &init_net)
+ 					err = -ENOENT;
+ 				else if (f->mcast_bind)
+ 					err = f->mcast_bind(net, fam_grp);
+ 				else
+ 					err = 0;
+ 				break;
+ 			}
+ 		}
+ 	}
+ 	up_read(&cb_lock);
+ 
+ 	return err;
+ }
+ 
+ static void genl_unbind(struct net *net, int group)
+ {
+ 	int i;
+ 
+ 	down_read(&cb_lock);
+ 	for (i = 0; i < GENL_FAM_TAB_SIZE; i++) {
+ 		struct genl_family *f;
+ 
+ 		list_for_each_entry(f, genl_family_chain(i), family_list) {
+ 			if (group >= f->mcgrp_offset &&
+ 			    group < f->mcgrp_offset + f->n_mcgrps) {
+ 				int fam_grp = group - f->mcgrp_offset;
+ 
+ 				if (f->mcast_unbind)
+ 					f->mcast_unbind(net, fam_grp);
+ 				break;
+ 			}
+ 		}
+ 	}
+ 	up_read(&cb_lock);
+ }
+ 
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  static int __net_init genl_pernet_init(struct net *net)
  {
  	struct netlink_kernel_cfg cfg = {
diff --cc net/nfc/netlink.c
index 851f6e469c68,450b1e5144cc..000000000000
--- a/net/nfc/netlink.c
+++ b/net/nfc/netlink.c
@@@ -30,18 -34,11 +30,22 @@@
  #include "nfc.h"
  #include "llcp.h"
  
 -static const struct genl_multicast_group nfc_genl_mcgrps[] = {
 -	{ .name = NFC_GENL_MCAST_EVENT_NAME, },
 +static struct genl_multicast_group nfc_genl_event_mcgrp = {
 +	.name = NFC_GENL_MCAST_EVENT_NAME,
 +};
 +
++<<<<<<< HEAD
 +static struct genl_family nfc_genl_family = {
 +	.id = GENL_ID_GENERATE,
 +	.hdrsize = 0,
 +	.name = NFC_GENL_NAME,
 +	.version = NFC_GENL_VERSION,
 +	.maxattr = NFC_ATTR_MAX,
  };
  
++=======
+ static struct genl_family nfc_genl_family;
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  static const struct nla_policy nfc_genl_policy[NFC_ATTR_MAX + 1] = {
  	[NFC_ATTR_DEVICE_INDEX] = { .type = NLA_U32 },
  	[NFC_ATTR_DEVICE_NAME] = { .type = NLA_STRING,
@@@ -1087,8 -1708,56 +1091,20 @@@ static struct genl_ops nfc_genl_ops[] 
  		.doit = nfc_genl_llc_sdreq,
  		.policy = nfc_genl_policy,
  	},
 -	{
 -		.cmd = NFC_CMD_FW_DOWNLOAD,
 -		.doit = nfc_genl_fw_download,
 -		.policy = nfc_genl_policy,
 -	},
 -	{
 -		.cmd = NFC_CMD_ENABLE_SE,
 -		.doit = nfc_genl_enable_se,
 -		.policy = nfc_genl_policy,
 -	},
 -	{
 -		.cmd = NFC_CMD_DISABLE_SE,
 -		.doit = nfc_genl_disable_se,
 -		.policy = nfc_genl_policy,
 -	},
 -	{
 -		.cmd = NFC_CMD_GET_SE,
 -		.dumpit = nfc_genl_dump_ses,
 -		.done = nfc_genl_dump_ses_done,
 -		.policy = nfc_genl_policy,
 -	},
 -	{
 -		.cmd = NFC_CMD_SE_IO,
 -		.doit = nfc_genl_se_io,
 -		.policy = nfc_genl_policy,
 -	},
 -	{
 -		.cmd = NFC_CMD_ACTIVATE_TARGET,
 -		.doit = nfc_genl_activate_target,
 -		.policy = nfc_genl_policy,
 -	},
 -	{
 -		.cmd = NFC_CMD_VENDOR,
 -		.doit = nfc_genl_vendor_cmd,
 -		.policy = nfc_genl_policy,
 -	},
  };
  
+ static struct genl_family nfc_genl_family = {
+ 	.hdrsize = 0,
+ 	.name = NFC_GENL_NAME,
+ 	.version = NFC_GENL_VERSION,
+ 	.maxattr = NFC_ATTR_MAX,
+ 	.module = THIS_MODULE,
+ 	.ops = nfc_genl_ops,
+ 	.n_ops = ARRAY_SIZE(nfc_genl_ops),
+ 	.mcgrps = nfc_genl_mcgrps,
+ 	.n_mcgrps = ARRAY_SIZE(nfc_genl_mcgrps),
+ };
+ 
  
  struct urelease_work {
  	struct	work_struct w;
@@@ -1174,8 -1843,7 +1190,12 @@@ int __init nfc_genl_init(void
  {
  	int rc;
  
++<<<<<<< HEAD
 +	rc = genl_register_family_with_ops(&nfc_genl_family, nfc_genl_ops,
 +					   ARRAY_SIZE(nfc_genl_ops));
++=======
+ 	rc = genl_register_family(&nfc_genl_family);
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  	if (rc)
  		return rc;
  
diff --cc net/tipc/netlink.c
index 1e6081fb6078,74a405bf107b..000000000000
--- a/net/tipc/netlink.c
+++ b/net/tipc/netlink.c
@@@ -35,60 -35,247 +35,284 @@@
   */
  
  #include "core.h"
 -#include "socket.h"
 -#include "name_table.h"
 -#include "bearer.h"
 -#include "link.h"
 -#include "node.h"
 -#include "net.h"
 -#include "udp_media.h"
 +#include "config.h"
  #include <net/genetlink.h>
  
++<<<<<<< HEAD
 +static int handle_cmd(struct sk_buff *skb, struct genl_info *info)
++=======
+ static const struct nla_policy tipc_nl_policy[TIPC_NLA_MAX + 1] = {
+ 	[TIPC_NLA_UNSPEC]	= { .type = NLA_UNSPEC, },
+ 	[TIPC_NLA_BEARER]	= { .type = NLA_NESTED, },
+ 	[TIPC_NLA_SOCK]		= { .type = NLA_NESTED, },
+ 	[TIPC_NLA_PUBL]		= { .type = NLA_NESTED, },
+ 	[TIPC_NLA_LINK]		= { .type = NLA_NESTED, },
+ 	[TIPC_NLA_MEDIA]	= { .type = NLA_NESTED, },
+ 	[TIPC_NLA_NODE]		= { .type = NLA_NESTED, },
+ 	[TIPC_NLA_NET]		= { .type = NLA_NESTED, },
+ 	[TIPC_NLA_NAME_TABLE]	= { .type = NLA_NESTED, },
+ 	[TIPC_NLA_MON]		= { .type = NLA_NESTED, },
+ };
+ 
+ const struct nla_policy
+ tipc_nl_name_table_policy[TIPC_NLA_NAME_TABLE_MAX + 1] = {
+ 	[TIPC_NLA_NAME_TABLE_UNSPEC]	= { .type = NLA_UNSPEC },
+ 	[TIPC_NLA_NAME_TABLE_PUBL]	= { .type = NLA_NESTED }
+ };
+ 
+ const struct nla_policy tipc_nl_monitor_policy[TIPC_NLA_MON_MAX + 1] = {
+ 	[TIPC_NLA_MON_UNSPEC]			= { .type = NLA_UNSPEC },
+ 	[TIPC_NLA_MON_REF]			= { .type = NLA_U32 },
+ 	[TIPC_NLA_MON_ACTIVATION_THRESHOLD]	= { .type = NLA_U32 },
+ };
+ 
+ const struct nla_policy tipc_nl_sock_policy[TIPC_NLA_SOCK_MAX + 1] = {
+ 	[TIPC_NLA_SOCK_UNSPEC]		= { .type = NLA_UNSPEC },
+ 	[TIPC_NLA_SOCK_ADDR]		= { .type = NLA_U32 },
+ 	[TIPC_NLA_SOCK_REF]		= { .type = NLA_U32 },
+ 	[TIPC_NLA_SOCK_CON]		= { .type = NLA_NESTED },
+ 	[TIPC_NLA_SOCK_HAS_PUBL]	= { .type = NLA_FLAG }
+ };
+ 
+ const struct nla_policy tipc_nl_net_policy[TIPC_NLA_NET_MAX + 1] = {
+ 	[TIPC_NLA_NET_UNSPEC]		= { .type = NLA_UNSPEC },
+ 	[TIPC_NLA_NET_ID]		= { .type = NLA_U32 }
+ };
+ 
+ const struct nla_policy tipc_nl_link_policy[TIPC_NLA_LINK_MAX + 1] = {
+ 	[TIPC_NLA_LINK_UNSPEC]		= { .type = NLA_UNSPEC },
+ 	[TIPC_NLA_LINK_NAME]		= { .type = NLA_STRING,
+ 					    .len = TIPC_MAX_LINK_NAME },
+ 	[TIPC_NLA_LINK_MTU]		= { .type = NLA_U32 },
+ 	[TIPC_NLA_LINK_BROADCAST]	= { .type = NLA_FLAG },
+ 	[TIPC_NLA_LINK_UP]		= { .type = NLA_FLAG },
+ 	[TIPC_NLA_LINK_ACTIVE]		= { .type = NLA_FLAG },
+ 	[TIPC_NLA_LINK_PROP]		= { .type = NLA_NESTED },
+ 	[TIPC_NLA_LINK_STATS]		= { .type = NLA_NESTED },
+ 	[TIPC_NLA_LINK_RX]		= { .type = NLA_U32 },
+ 	[TIPC_NLA_LINK_TX]		= { .type = NLA_U32 }
+ };
+ 
+ const struct nla_policy tipc_nl_node_policy[TIPC_NLA_NODE_MAX + 1] = {
+ 	[TIPC_NLA_NODE_UNSPEC]		= { .type = NLA_UNSPEC },
+ 	[TIPC_NLA_NODE_ADDR]		= { .type = NLA_U32 },
+ 	[TIPC_NLA_NODE_UP]		= { .type = NLA_FLAG }
+ };
+ 
+ /* Properties valid for media, bearer and link */
+ const struct nla_policy tipc_nl_prop_policy[TIPC_NLA_PROP_MAX + 1] = {
+ 	[TIPC_NLA_PROP_UNSPEC]		= { .type = NLA_UNSPEC },
+ 	[TIPC_NLA_PROP_PRIO]		= { .type = NLA_U32 },
+ 	[TIPC_NLA_PROP_TOL]		= { .type = NLA_U32 },
+ 	[TIPC_NLA_PROP_WIN]		= { .type = NLA_U32 }
+ };
+ 
+ const struct nla_policy tipc_nl_bearer_policy[TIPC_NLA_BEARER_MAX + 1]	= {
+ 	[TIPC_NLA_BEARER_UNSPEC]	= { .type = NLA_UNSPEC },
+ 	[TIPC_NLA_BEARER_NAME]		= { .type = NLA_STRING,
+ 					    .len = TIPC_MAX_BEARER_NAME },
+ 	[TIPC_NLA_BEARER_PROP]		= { .type = NLA_NESTED },
+ 	[TIPC_NLA_BEARER_DOMAIN]	= { .type = NLA_U32 }
+ };
+ 
+ const struct nla_policy tipc_nl_media_policy[TIPC_NLA_MEDIA_MAX + 1] = {
+ 	[TIPC_NLA_MEDIA_UNSPEC]		= { .type = NLA_UNSPEC },
+ 	[TIPC_NLA_MEDIA_NAME]		= { .type = NLA_STRING },
+ 	[TIPC_NLA_MEDIA_PROP]		= { .type = NLA_NESTED }
+ };
+ 
+ const struct nla_policy tipc_nl_udp_policy[TIPC_NLA_UDP_MAX + 1] = {
+ 	[TIPC_NLA_UDP_UNSPEC]	= {.type = NLA_UNSPEC},
+ 	[TIPC_NLA_UDP_LOCAL]	= {.type = NLA_BINARY,
+ 				   .len = sizeof(struct sockaddr_storage)},
+ 	[TIPC_NLA_UDP_REMOTE]	= {.type = NLA_BINARY,
+ 				   .len = sizeof(struct sockaddr_storage)},
+ };
+ 
+ /* Users of the legacy API (tipc-config) can't handle that we add operations,
+  * so we have a separate genl handling for the new API.
+  */
+ static const struct genl_ops tipc_genl_v2_ops[] = {
+ 	{
+ 		.cmd	= TIPC_NL_BEARER_DISABLE,
+ 		.doit	= tipc_nl_bearer_disable,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_BEARER_ENABLE,
+ 		.doit	= tipc_nl_bearer_enable,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_BEARER_GET,
+ 		.doit	= tipc_nl_bearer_get,
+ 		.dumpit	= tipc_nl_bearer_dump,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_BEARER_ADD,
+ 		.doit	= tipc_nl_bearer_add,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_BEARER_SET,
+ 		.doit	= tipc_nl_bearer_set,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_SOCK_GET,
+ 		.dumpit	= tipc_nl_sk_dump,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_PUBL_GET,
+ 		.dumpit	= tipc_nl_publ_dump,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_LINK_GET,
+ 		.doit   = tipc_nl_node_get_link,
+ 		.dumpit	= tipc_nl_node_dump_link,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_LINK_SET,
+ 		.doit	= tipc_nl_node_set_link,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_LINK_RESET_STATS,
+ 		.doit   = tipc_nl_node_reset_link_stats,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_MEDIA_GET,
+ 		.doit	= tipc_nl_media_get,
+ 		.dumpit	= tipc_nl_media_dump,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_MEDIA_SET,
+ 		.doit	= tipc_nl_media_set,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_NODE_GET,
+ 		.dumpit	= tipc_nl_node_dump,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_NET_GET,
+ 		.dumpit	= tipc_nl_net_dump,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_NET_SET,
+ 		.doit	= tipc_nl_net_set,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_NAME_TABLE_GET,
+ 		.dumpit	= tipc_nl_name_table_dump,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_MON_SET,
+ 		.doit	= tipc_nl_node_set_monitor,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_MON_GET,
+ 		.doit	= tipc_nl_node_get_monitor,
+ 		.dumpit	= tipc_nl_node_dump_monitor,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_MON_PEER_GET,
+ 		.dumpit	= tipc_nl_node_dump_monitor_peer,
+ 		.policy = tipc_nl_policy,
+ 	},
+ 	{
+ 		.cmd	= TIPC_NL_PEER_REMOVE,
+ 		.doit	= tipc_nl_peer_rm,
+ 		.policy = tipc_nl_policy,
+ 	},
+ #ifdef CONFIG_TIPC_MEDIA_UDP
+ 	{
+ 		.cmd	= TIPC_NL_UDP_GET_REMOTEIP,
+ 		.dumpit	= tipc_udp_nl_dump_remoteip,
+ 		.policy = tipc_nl_policy,
+ 	},
+ #endif
+ };
+ 
+ struct genl_family tipc_genl_family = {
+ 	.name		= TIPC_GENL_V2_NAME,
+ 	.version	= TIPC_GENL_V2_VERSION,
+ 	.hdrsize	= 0,
+ 	.maxattr	= TIPC_NLA_MAX,
+ 	.netnsok	= true,
+ 	.module		= THIS_MODULE,
+ 	.ops		= tipc_genl_v2_ops,
+ 	.n_ops		= ARRAY_SIZE(tipc_genl_v2_ops),
+ };
+ 
+ int tipc_nlmsg_parse(const struct nlmsghdr *nlh, struct nlattr ***attr)
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  {
 -	u32 maxattr = tipc_genl_family.maxattr;
 +	struct sk_buff *rep_buf;
 +	struct nlmsghdr *rep_nlh;
 +	struct nlmsghdr *req_nlh = info->nlhdr;
 +	struct tipc_genlmsghdr *req_userhdr = info->userhdr;
 +	int hdr_space = nlmsg_total_size(GENL_HDRLEN + TIPC_GENL_HDRLEN);
 +	u16 cmd;
  
 -	*attr = genl_family_attrbuf(&tipc_genl_family);
 -	if (!*attr)
 -		return -EOPNOTSUPP;
 +	if ((req_userhdr->cmd & 0xC000) && (!netlink_capable(skb, CAP_NET_ADMIN)))
 +		cmd = TIPC_CMD_NOT_NET_ADMIN;
 +	else
 +		cmd = req_userhdr->cmd;
  
 -	return nlmsg_parse(nlh, GENL_HDRLEN, *attr, maxattr, tipc_nl_policy);
 +	rep_buf = tipc_cfg_do_cmd(req_userhdr->dest, cmd,
 +			nlmsg_data(req_nlh) + GENL_HDRLEN + TIPC_GENL_HDRLEN,
 +			nlmsg_attrlen(req_nlh, GENL_HDRLEN + TIPC_GENL_HDRLEN),
 +			hdr_space);
 +
 +	if (rep_buf) {
 +		skb_push(rep_buf, hdr_space);
 +		rep_nlh = nlmsg_hdr(rep_buf);
 +		memcpy(rep_nlh, req_nlh, hdr_space);
 +		rep_nlh->nlmsg_len = rep_buf->len;
 +		genlmsg_unicast(&init_net, rep_buf, NETLINK_CB(skb).portid);
 +	}
 +
 +	return 0;
  }
  
 +static struct genl_family tipc_genl_family = {
 +	.id		= GENL_ID_GENERATE,
 +	.name		= TIPC_GENL_NAME,
 +	.version	= TIPC_GENL_VERSION,
 +	.hdrsize	= TIPC_GENL_HDRLEN,
 +	.maxattr	= 0,
 +};
 +
 +static struct genl_ops tipc_genl_ops = {
 +	.cmd		= TIPC_GENL_CMD,
 +	.doit		= handle_cmd,
 +};
 +
 +static int tipc_genl_family_registered;
 +
  int tipc_netlink_start(void)
  {
  	int res;
  
++<<<<<<< HEAD
 +	res = genl_register_family_with_ops(&tipc_genl_family,
 +		&tipc_genl_ops, 1);
++=======
+ 	res = genl_register_family(&tipc_genl_family);
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  	if (res) {
  		pr_err("Failed to register netlink interface\n");
  		return res;
diff --cc net/wimax/stack.c
index a6470ac39498,587e1627681f..000000000000
--- a/net/wimax/stack.c
+++ b/net/wimax/stack.c
@@@ -549,16 -572,20 +549,28 @@@ struct d_level D_LEVEL[] = 
  size_t D_LEVEL_SIZE = ARRAY_SIZE(D_LEVEL);
  
  
+ static const struct genl_multicast_group wimax_gnl_mcgrps[] = {
+ 	{ .name = "msg", },
+ };
+ 
  struct genl_family wimax_gnl_family = {
 +	.id = GENL_ID_GENERATE,
  	.name = "WiMAX",
  	.version = WIMAX_GNL_VERSION,
  	.hdrsize = 0,
  	.maxattr = WIMAX_GNL_ATTR_MAX,
++<<<<<<< HEAD
 +};
 +
 +struct genl_multicast_group wimax_gnl_mcg = {
 +	.name = "msg",
++=======
+ 	.module = THIS_MODULE,
+ 	.ops = wimax_gnl_ops,
+ 	.n_ops = ARRAY_SIZE(wimax_gnl_ops),
+ 	.mcgrps = wimax_gnl_mcgrps,
+ 	.n_mcgrps = ARRAY_SIZE(wimax_gnl_mcgrps),
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  };
  
  
@@@ -573,12 -600,9 +585,15 @@@ int __init wimax_subsys_init(void
  	d_parse_params(D_LEVEL, D_LEVEL_SIZE, wimax_debug_params,
  		       "wimax.debug");
  
++<<<<<<< HEAD
 +	snprintf(wimax_gnl_family.name, sizeof(wimax_gnl_family.name),
 +		 "WiMAX");
++=======
++>>>>>>> 489111e5c25b (genetlink: statically initialize families)
  	result = genl_register_family(&wimax_gnl_family);
  	if (unlikely(result < 0)) {
 -		pr_err("cannot register generic netlink family: %d\n", result);
 +		printk(KERN_ERR "cannot register generic netlink family: %d\n",
 +		       result);
  		goto error_register_family;
  	}
  
* Unmerged path drivers/net/gtp.c
* Unmerged path net/batman-adv/netlink.c
* Unmerged path net/hsr/hsr_netlink.c
* Unmerged path net/ipv6/ila/ila_xlat.c
* Unmerged path net/netlabel/netlabel_calipso.c
* Unmerged path net/tipc/netlink_compat.c
* Unmerged path drivers/acpi/event.c
* Unmerged path drivers/net/gtp.c
* Unmerged path drivers/net/macsec.c
* Unmerged path drivers/net/team/team.c
* Unmerged path drivers/net/wireless/mac80211_hwsim.c
* Unmerged path drivers/scsi/pmcraid.c
* Unmerged path drivers/target/target_core_user.c
* Unmerged path drivers/thermal/thermal_core.c
* Unmerged path fs/dlm/netlink.c
* Unmerged path fs/quota/netlink.c
diff --git a/include/linux/drbd_genl.h b/include/linux/drbd_genl.h
index d0d8fac8a6e4..63d1f98e78e4 100644
--- a/include/linux/drbd_genl.h
+++ b/include/linux/drbd_genl.h
@@ -67,7 +67,7 @@
  *	genl_magic_func.h
  *		generates an entry in the static genl_ops array,
  *		and static register/unregister functions to
- *		genl_register_family_with_ops().
+ *		genl_register_family().
  *
  *	flags and handler:
  *		GENL_op_init( .doit = x, .dumpit = y, .flags = something)
* Unmerged path include/linux/genl_magic_func.h
* Unmerged path include/net/genetlink.h
* Unmerged path kernel/taskstats.c
* Unmerged path net/batman-adv/netlink.c
* Unmerged path net/core/devlink.c
* Unmerged path net/core/drop_monitor.c
* Unmerged path net/hsr/hsr_netlink.c
* Unmerged path net/ieee802154/netlink.c
* Unmerged path net/ieee802154/nl802154.c
* Unmerged path net/ipv4/fou.c
* Unmerged path net/ipv4/tcp_metrics.c
* Unmerged path net/ipv6/ila/ila_xlat.c
* Unmerged path net/irda/irnetlink.c
* Unmerged path net/l2tp/l2tp_netlink.c
* Unmerged path net/netfilter/ipvs/ip_vs_ctl.c
* Unmerged path net/netlabel/netlabel_calipso.c
* Unmerged path net/netlabel/netlabel_cipso_v4.c
* Unmerged path net/netlabel/netlabel_mgmt.c
* Unmerged path net/netlabel/netlabel_unlabeled.c
* Unmerged path net/netlink/genetlink.c
* Unmerged path net/nfc/netlink.c
diff --git a/net/openvswitch/datapath.c b/net/openvswitch/datapath.c
index 538ce415ba26..148fa9611be9 100644
--- a/net/openvswitch/datapath.c
+++ b/net/openvswitch/datapath.c
@@ -667,6 +667,7 @@ static struct genl_family dp_packet_genl_family = {
 	.parallel_ops = true,
 	.ops = dp_packet_genl_ops,
 	.n_ops = ARRAY_SIZE(dp_packet_genl_ops),
+	.module = THIS_MODULE,
 };
 
 static void get_dp_stats(const struct datapath *dp, struct ovs_dp_stats *stats,
@@ -1434,6 +1435,7 @@ static struct genl_family dp_flow_genl_family = {
 	.n_ops = ARRAY_SIZE(dp_flow_genl_ops),
 	.mcgrps = &ovs_dp_flow_multicast_group,
 	.n_mcgrps = 1,
+	.module = THIS_MODULE,
 };
 
 static size_t ovs_dp_cmd_msg_size(void)
@@ -1820,6 +1822,7 @@ static struct genl_family dp_datapath_genl_family = {
 	.n_ops = ARRAY_SIZE(dp_datapath_genl_ops),
 	.mcgrps = &ovs_dp_datapath_multicast_group,
 	.n_mcgrps = 1,
+	.module = THIS_MODULE,
 };
 
 /* Called with ovs_mutex or RCU read lock. */
@@ -2242,6 +2245,7 @@ struct genl_family dp_vport_genl_family = {
 	.n_ops = ARRAY_SIZE(dp_vport_genl_ops),
 	.mcgrps = &ovs_dp_vport_multicast_group,
 	.n_mcgrps = 1,
+	.module = THIS_MODULE,
 };
 
 static struct genl_family * const dp_genl_families[] = {
* Unmerged path net/tipc/netlink.c
* Unmerged path net/tipc/netlink_compat.c
* Unmerged path net/wimax/stack.c
diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index aea6305a7568..7d1a6e15440d 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -12850,6 +12850,21 @@ static struct genl_family nl80211_fam = {
 	.n_mcgrps = ARRAY_SIZE(nl80211_mcgrps),
 };
 
+static struct genl_family nl80211_fam = {
+	.name = NL80211_GENL_NAME,	/* have users key off the name instead */
+	.hdrsize = 0,			/* no private header */
+	.version = 1,			/* no particular meaning now */
+	.maxattr = NL80211_ATTR_MAX,
+	.netnsok = true,
+	.pre_doit = nl80211_pre_doit,
+	.post_doit = nl80211_post_doit,
+	.module = THIS_MODULE,
+	.ops = nl80211_ops,
+	.n_ops = ARRAY_SIZE(nl80211_ops),
+	.mcgrps = nl80211_mcgrps,
+	.n_mcgrps = ARRAY_SIZE(nl80211_mcgrps),
+};
+
 /* notification functions */
 
 void nl80211_notify_wiphy(struct cfg80211_registered_device *rdev,
