nfp: separate app vNIC init/clean from alloc/free

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit c496291c5a414bd55bae76880137947d2e8decbe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c496291c.failed

We currently only have one app callback for vNIC creation
and destruction.  This is insufficient, because some actions
have to be taken before netdev is registered, after it's
registered and after it's unregistered.  Old callbacks
were really corresponding to alloc/free actions.  Rename
them and add proper init/clean.  Apps using representors
will be able to use new callbacks to manage lifetime of
upper devices.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Simon Horman <simon.horman@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c496291c5a414bd55bae76880137947d2e8decbe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/bpf/main.c
#	drivers/net/ethernet/netronome/nfp/flower/cmsg.c
#	drivers/net/ethernet/netronome/nfp/flower/main.c
#	drivers/net/ethernet/netronome/nfp/flower/main.h
#	drivers/net/ethernet/netronome/nfp/nfp_app.c
#	drivers/net/ethernet/netronome/nfp/nfp_app.h
#	drivers/net/ethernet/netronome/nfp/nfp_app_nic.c
#	drivers/net/ethernet/netronome/nfp/nfp_net_main.c
#	drivers/net/ethernet/netronome/nfp/nic/main.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_main.c
index 092c7d18f2ec,f2a1a4e2ce8b..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
@@@ -207,77 -136,46 +207,87 @@@ static unsigned int nfp_net_pf_get_num_
  	return val;
  }
  
 -static int nfp_net_pf_get_num_ports(struct nfp_pf *pf)
 +static unsigned int
 +nfp_net_pf_total_qcs(struct nfp_pf *pf, void __iomem *ctrl_bar,
 +		     unsigned int stride, u32 start_off, u32 num_off)
  {
 -	return nfp_net_pf_rtsym_read_optional(pf, "nfd_cfg_pf%u_num_ports", 1);
 -}
 +	unsigned int i, min_qc, max_qc;
  
 -static int nfp_net_pf_get_app_id(struct nfp_pf *pf)
 -{
 -	return nfp_net_pf_rtsym_read_optional(pf, "_pf%u_net_app_id",
 -					      NFP_APP_CORE_NIC);
 +	min_qc = readl(ctrl_bar + start_off);
 +	max_qc = min_qc;
 +
 +	for (i = 0; i < pf->num_ports; i++) {
 +		/* To make our lives simpler only accept configuration where
 +		 * queues are allocated to PFs in order (queues of PFn all have
 +		 * indexes lower than PFn+1).
 +		 */
 +		if (max_qc > readl(ctrl_bar + start_off))
 +			return 0;
 +
 +		max_qc = readl(ctrl_bar + start_off);
 +		max_qc += readl(ctrl_bar + num_off) * stride;
 +		ctrl_bar += NFP_PF_CSR_SLICE_SIZE;
 +	}
 +
 +	return max_qc - min_qc;
  }
  
 -static u8 __iomem *
 -nfp_net_pf_map_rtsym(struct nfp_pf *pf, const char *name, const char *sym_fmt,
 -		     unsigned int min_size, struct nfp_cpp_area **area)
 +static u8 __iomem *nfp_net_pf_map_ctrl_bar(struct nfp_pf *pf)
  {
 +	const struct nfp_rtsym *ctrl_sym;
 +	u8 __iomem *ctrl_bar;
  	char pf_symbol[256];
  
 -	snprintf(pf_symbol, sizeof(pf_symbol), sym_fmt,
 +	snprintf(pf_symbol, sizeof(pf_symbol), "_pf%u_net_bar0",
  		 nfp_cppcore_pcie_unit(pf->cpp));
  
 -	return nfp_rtsym_map(pf->rtbl, pf_symbol, name, min_size, area);
 +	ctrl_sym = nfp_rtsym_lookup(pf->cpp, pf_symbol);
 +	if (!ctrl_sym) {
 +		dev_err(&pf->pdev->dev,
 +			"Failed to find PF BAR0 symbol %s\n", pf_symbol);
 +		return NULL;
 +	}
 +
 +	if (ctrl_sym->size < pf->num_ports * NFP_PF_CSR_SLICE_SIZE) {
 +		dev_err(&pf->pdev->dev,
 +			"PF BAR0 too small to contain %d ports\n",
 +			pf->num_ports);
 +		return NULL;
 +	}
 +
 +	ctrl_bar = nfp_net_map_area(pf->cpp, "net.ctrl",
 +				    ctrl_sym->domain, ctrl_sym->target,
 +				    ctrl_sym->addr, ctrl_sym->size,
 +				    &pf->ctrl_area);
 +	if (IS_ERR(ctrl_bar)) {
 +		dev_err(&pf->pdev->dev, "Failed to map PF BAR0: %ld\n",
 +			PTR_ERR(ctrl_bar));
 +		return NULL;
 +	}
 +
 +	return ctrl_bar;
  }
  
 -static void nfp_net_pf_free_vnic(struct nfp_pf *pf, struct nfp_net *nn)
 +static void nfp_net_pf_free_netdevs(struct nfp_pf *pf)
  {
++<<<<<<< HEAD
 +	struct nfp_net *nn;
++=======
+ 	if (nfp_net_is_data_vnic(nn))
+ 		nfp_app_vnic_free(pf->app, nn);
+ 	nfp_port_free(nn->port);
+ 	list_del(&nn->vnic_list);
+ 	pf->num_vnics--;
+ 	nfp_net_free(nn);
+ }
++>>>>>>> c496291c5a41 (nfp: separate app vNIC init/clean from alloc/free)
  
 -static void nfp_net_pf_free_vnics(struct nfp_pf *pf)
 -{
 -	struct nfp_net *nn, *next;
 +	while (!list_empty(&pf->ports)) {
 +		nn = list_first_entry(&pf->ports, struct nfp_net, port_list);
 +		list_del(&nn->port_list);
  
 -	list_for_each_entry_safe(nn, next, &pf->vnics, vnic_list)
 -		if (nfp_net_is_data_vnic(nn))
 -			nfp_net_pf_free_vnic(pf, nn);
 +		nfp_net_netdev_free(nn);
 +	}
  }
  
  static struct nfp_net *
@@@ -305,6 -206,17 +315,20 @@@ nfp_net_pf_alloc_port_netdev(struct nfp
  	nn->stride_rx = stride;
  	nn->stride_tx = stride;
  
++<<<<<<< HEAD
++=======
+ 	if (needs_netdev) {
+ 		err = nfp_app_vnic_alloc(pf->app, nn, id);
+ 		if (err) {
+ 			nfp_net_free(nn);
+ 			return ERR_PTR(err);
+ 		}
+ 	}
+ 
+ 	pf->num_vnics++;
+ 	list_add_tail(&nn->vnic_list, &pf->vnics);
+ 
++>>>>>>> c496291c5a41 (nfp: separate app vNIC init/clean from alloc/free)
  	return nn;
  }
  
@@@ -331,7 -245,21 +355,24 @@@ nfp_net_pf_init_port_netdev(struct nfp_
  
  	nfp_net_info(nn);
  
+ 	if (nfp_net_is_data_vnic(nn)) {
+ 		err = nfp_app_vnic_init(pf->app, nn);
+ 		if (err)
+ 			goto err_devlink_port_clean;
+ 	}
+ 
  	return 0;
++<<<<<<< HEAD
++=======
+ 
+ err_devlink_port_clean:
+ 	if (nn->port)
+ 		nfp_devlink_port_unregister(nn->port);
+ err_dfs_clean:
+ 	nfp_net_debugfs_dir_clean(&nn->debugfs_dir);
+ 	nfp_net_clean(nn);
+ 	return err;
++>>>>>>> c496291c5a41 (nfp: separate app vNIC init/clean from alloc/free)
  }
  
  static int
@@@ -373,21 -297,20 +414,35 @@@ err_free_prev
  	return err;
  }
  
 -static void nfp_net_pf_clean_vnic(struct nfp_pf *pf, struct nfp_net *nn)
 -{
 +static int
 +nfp_net_pf_spawn_netdevs(struct nfp_pf *pf,
 +			 void __iomem *ctrl_bar, void __iomem *tx_bar,
 +			 void __iomem *rx_bar, int stride,
 +			 struct nfp_net_fw_version *fw_ver)
 +{
++<<<<<<< HEAD
 +	unsigned int id, wanted_irqs, num_irqs, ports_left, irqs_left;
++=======
+ 	if (nfp_net_is_data_vnic(nn))
+ 		nfp_app_vnic_clean(pf->app, nn);
+ 	if (nn->port)
+ 		nfp_devlink_port_unregister(nn->port);
+ 	nfp_net_debugfs_dir_clean(&nn->debugfs_dir);
+ 	nfp_net_clean(nn);
+ }
+ 
+ static int nfp_net_pf_alloc_irqs(struct nfp_pf *pf)
+ {
+ 	unsigned int wanted_irqs, num_irqs, vnics_left, irqs_left;
++>>>>>>> c496291c5a41 (nfp: separate app vNIC init/clean from alloc/free)
  	struct nfp_net *nn;
 +	int err;
 +
 +	/* Allocate the netdevs and do basic init */
 +	err = nfp_net_pf_alloc_netdevs(pf, ctrl_bar, tx_bar, rx_bar,
 +				       stride, fw_ver);
 +	if (err)
 +		return err;
  
  	/* Get MSI-X vectors */
  	wanted_irqs = 0;
* Unmerged path drivers/net/ethernet/netronome/nfp/bpf/main.c
* Unmerged path drivers/net/ethernet/netronome/nfp/flower/cmsg.c
* Unmerged path drivers/net/ethernet/netronome/nfp/flower/main.c
* Unmerged path drivers/net/ethernet/netronome/nfp/flower/main.h
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_app.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_app.h
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_app_nic.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nic/main.c
* Unmerged path drivers/net/ethernet/netronome/nfp/bpf/main.c
* Unmerged path drivers/net/ethernet/netronome/nfp/flower/cmsg.c
* Unmerged path drivers/net/ethernet/netronome/nfp/flower/main.c
* Unmerged path drivers/net/ethernet/netronome/nfp/flower/main.h
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_app.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_app.h
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_app_nic.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_main.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nic/main.c
