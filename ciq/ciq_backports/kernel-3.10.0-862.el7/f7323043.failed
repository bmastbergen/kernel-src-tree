cxgb4: push cls_u32 setup_tc processing into a separate function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jiri Pirko <jiri@mellanox.com>
commit f73230430ac295b14cd1ee162dbf7ccfd90cbf6b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f7323043.failed

Let cxgb_setup_tc be a splitter for specific setup_tc types and push out
cls_u32 specific code into a separate function.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f73230430ac295b14cd1ee162dbf7ccfd90cbf6b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
index 7eb2bfa69942,651229070113..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@@ -2749,7 -2889,28 +2749,32 @@@ static int cxgb_set_tx_maxrate(struct n
  	return err;
  }
  
++<<<<<<< HEAD
 +static int cxgb_setup_tc(struct net_device *dev, u32 handle, __be16 proto,
++=======
+ static int cxgb_setup_tc_cls_u32(struct net_device *dev,
+ 				 enum tc_setup_type type,
+ 				 u32 handle, u32 chain_index, __be16 proto,
+ 				 struct tc_cls_u32_offload *cls_u32)
+ {
+ 	if (TC_H_MAJ(handle) != TC_H_MAJ(TC_H_INGRESS) ||
+ 	    chain_index)
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (cls_u32->command) {
+ 	case TC_CLSU32_NEW_KNODE:
+ 	case TC_CLSU32_REPLACE_KNODE:
+ 		return cxgb4_config_knode(dev, proto, cls_u32);
+ 	case TC_CLSU32_DELETE_KNODE:
+ 		return cxgb4_delete_knode(dev, proto, cls_u32);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static int cxgb_setup_tc(struct net_device *dev, enum tc_setup_type type,
+ 			 u32 handle, u32 chain_index, __be16 proto,
++>>>>>>> f73230430ac2 (cxgb4: push cls_u32 setup_tc processing into a separate function)
  			 struct tc_to_netdev *tc)
  {
  	struct port_info *pi = netdev2pinfo(dev);
@@@ -2762,20 -2923,13 +2787,27 @@@
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	if (TC_H_MAJ(handle) == TC_H_MAJ(TC_H_INGRESS) &&
 +	    tc->type == TC_SETUP_CLSU32) {
 +		switch (tc->cls_u32->command) {
 +		case TC_CLSU32_NEW_KNODE:
 +		case TC_CLSU32_REPLACE_KNODE:
 +			return cxgb4_config_knode(dev, proto, tc->cls_u32);
 +		case TC_CLSU32_DELETE_KNODE:
 +			return cxgb4_delete_knode(dev, proto, tc->cls_u32);
 +		default:
 +			return -EOPNOTSUPP;
 +		}
++=======
+ 	switch (type) {
+ 	case TC_SETUP_CLSU32:
+ 		return cxgb_setup_tc_cls_u32(dev, type, handle, chain_index,
+ 					     proto, tc->cls_u32);
+ 	default:
+ 		return -EOPNOTSUPP;
++>>>>>>> f73230430ac2 (cxgb4: push cls_u32 setup_tc processing into a separate function)
  	}
- 
- 	return -EOPNOTSUPP;
  }
  
  static netdev_features_t cxgb_fix_features(struct net_device *dev,
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
