audit: ensure that 'audit=1' actually enables audit for PID 1

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Paul Moore <paul@paul-moore.com>
commit 173743dd99a49c956b124a74c8aacb0384739a4c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/173743dd.failed

Prior to this patch we enabled audit in audit_init(), which is too
late for PID 1 as the standard initcalls are run after the PID 1 task
is forked.  This means that we never allocate an audit_context (see
audit_alloc()) for PID 1 and therefore miss a lot of audit events
generated by PID 1.

This patch enables audit as early as possible to help ensure that when
PID 1 is forked it can allocate an audit_context if required.

	Reviewed-by: Richard Guy Briggs <rgb@redhat.com>
	Signed-off-by: Paul Moore <paul@paul-moore.com>
(cherry picked from commit 173743dd99a49c956b124a74c8aacb0384739a4c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/audit.c
diff --cc kernel/audit.c
index 510dbb0b54ee,ec3d0802734d..000000000000
--- a/kernel/audit.c
+++ b/kernel/audit.c
@@@ -76,24 -85,46 +76,33 @@@ static int	audit_initialized
  #define AUDIT_OFF	0
  #define AUDIT_ON	1
  #define AUDIT_LOCKED	2
++<<<<<<< HEAD
 +int		audit_enabled;
 +int		audit_ever_enabled;
++=======
+ u32		audit_enabled = AUDIT_OFF;
+ u32		audit_ever_enabled = !!AUDIT_OFF;
++>>>>>>> 173743dd99a4 (audit: ensure that 'audit=1' actually enables audit for PID 1)
  
  EXPORT_SYMBOL_GPL(audit_enabled);
  
  /* Default state when kernel boots without any parameters. */
++<<<<<<< HEAD
 +static int	audit_default;
++=======
+ static u32	audit_default = AUDIT_OFF;
++>>>>>>> 173743dd99a4 (audit: ensure that 'audit=1' actually enables audit for PID 1)
  
  /* If auditing cannot proceed, audit_failure selects what happens. */
 -static u32	audit_failure = AUDIT_FAIL_PRINTK;
 -
 -/* private audit network namespace index */
 -static unsigned int audit_net_id;
 -
 -/**
 - * struct audit_net - audit private network namespace data
 - * @sk: communication socket
 - */
 -struct audit_net {
 -	struct sock *sk;
 -};
 +static int	audit_failure = AUDIT_FAIL_PRINTK;
  
 -/**
 - * struct auditd_connection - kernel/auditd connection state
 - * @pid: auditd PID
 - * @portid: netlink portid
 - * @net: the associated network namespace
 - * @rcu: RCU head
 - *
 - * Description:
 - * This struct is RCU protected; you must either hold the RCU lock for reading
 - * or the associated spinlock for writing.
 +/*
 + * If audit records are to be written to the netlink socket, audit_pid
 + * contains the pid of the auditd process and audit_nlk_portid contains
 + * the portid to use to send netlink messages to that process.
   */
 -static struct auditd_connection {
 -	struct pid *pid;
 -	u32 portid;
 -	struct net *net;
 -	struct rcu_head rcu;
 -} *auditd_conn = NULL;
 -static DEFINE_SPINLOCK(auditd_conn_lock);
 +int		audit_pid;
 +static __u32	audit_nlk_portid;
  
  /* If audit_rate_limit is non-zero, limit the rate of sending audit records
   * to that number per second.  This prevents DoS attacks, but results in
@@@ -1084,24 -1533,32 +1093,22 @@@ static int __init audit_init(void
  	if (audit_initialized == AUDIT_DISABLED)
  		return 0;
  
 -	audit_buffer_cache = kmem_cache_create("audit_buffer",
 -					       sizeof(struct audit_buffer),
 -					       0, SLAB_PANIC, NULL);
 -
 -	skb_queue_head_init(&audit_queue);
 -	skb_queue_head_init(&audit_retry_queue);
 -	skb_queue_head_init(&audit_hold_queue);
 -
 -	for (i = 0; i < AUDIT_INODE_BUCKETS; i++)
 -		INIT_LIST_HEAD(&audit_inode_hash[i]);
 -
 -	pr_info("initializing netlink subsys (%s)\n",
 -		audit_default ? "enabled" : "disabled");
 -	register_pernet_subsys(&audit_net_ops);
 +	printk(KERN_INFO "audit: initializing netlink socket (%s)\n",
 +	       audit_default ? "enabled" : "disabled");
 +	audit_sock = netlink_kernel_create(&init_net, NETLINK_AUDIT, &cfg);
 +	if (!audit_sock)
 +		audit_panic("cannot initialize netlink socket");
 +	else
 +		audit_sock->sk_sndtimeo = MAX_SCHEDULE_TIMEOUT;
  
 +	skb_queue_head_init(&audit_skb_queue);
 +	skb_queue_head_init(&audit_skb_hold_queue);
  	audit_initialized = AUDIT_INITIALIZED;
- 	audit_enabled = audit_default;
- 	audit_ever_enabled |= !!audit_default;
  
 -	kauditd_task = kthread_run(kauditd_thread, NULL, "kauditd");
 -	if (IS_ERR(kauditd_task)) {
 -		int err = PTR_ERR(kauditd_task);
 -		panic("audit: failed to start the kauditd thread (%d)\n", err);
 -	}
 +	audit_log(NULL, GFP_KERNEL, AUDIT_KERNEL, "initialized");
  
 -	audit_log(NULL, GFP_KERNEL, AUDIT_KERNEL,
 -		"state=initialized audit_enabled=%u res=1",
 -		 audit_enabled);
 +	for (i = 0; i < AUDIT_INODE_BUCKETS; i++)
 +		INIT_LIST_HEAD(&audit_inode_hash[i]);
  
  	return 0;
  }
@@@ -1113,18 -1570,31 +1120,20 @@@ static int __init audit_enable(char *st
  	audit_default = !!simple_strtol(str, NULL, 0);
  	if (!audit_default)
  		audit_initialized = AUDIT_DISABLED;
+ 	audit_enabled = audit_default;
+ 	audit_ever_enabled = !!audit_enabled;
  
 -	pr_info("%s\n", audit_default ?
 -		"enabled (after initialization)" : "disabled (until reboot)");
 +	printk(KERN_INFO "audit: %s", audit_default ? "enabled" : "disabled");
  
 -	return 1;
 -}
 -__setup("audit=", audit_enable);
 -
 -/* Process kernel command-line parameter at boot time.
 - * audit_backlog_limit=<n> */
 -static int __init audit_backlog_limit_set(char *str)
 -{
 -	u32 audit_backlog_limit_arg;
 -
 -	pr_info("audit_backlog_limit: ");
 -	if (kstrtouint(str, 0, &audit_backlog_limit_arg)) {
 -		pr_cont("using default of %u, unable to parse %s\n",
 -			audit_backlog_limit, str);
 -		return 1;
 +	if (audit_initialized == AUDIT_INITIALIZED) {
 +		audit_enabled = audit_default;
 +		audit_ever_enabled |= !!audit_default;
 +	} else if (audit_initialized == AUDIT_UNINITIALIZED) {
 +		printk(" (after initialization)");
 +	} else {
 +		printk(" (until reboot)");
  	}
 -
 -	audit_backlog_limit = audit_backlog_limit_arg;
 -	pr_cont("%d\n", audit_backlog_limit);
 +	printk("\n");
  
  	return 1;
  }
* Unmerged path kernel/audit.c
