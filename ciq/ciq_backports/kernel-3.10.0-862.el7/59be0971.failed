ovl: implement index dir copy up

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 59be09712ab98a3060f13e31343c7abb9bc4583d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/59be0971.failed

Implement a copy up method for non-dir objects using index dir to
prevent breaking lower hardlinks on copy up.

This method requires that the inodes index dir feature was enabled and
that all underlying fs support file handle encoding/decoding.

On the first lower hardlink copy up, upper file is created in index dir,
named after the hex representation of the lower origin inode file handle.
On the second lower hardlink copy up, upper file is found in index dir,
by the same lower handle key.
On either case, the upper indexed inode is then linked to the copy up
upper path.

The index entry remains linked for future lower hardlink copy up and for
lower to upper inode map, that is needed for exporting overlayfs to NFS.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 59be09712ab98a3060f13e31343c7abb9bc4583d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/copy_up.c
#	fs/overlayfs/util.c
diff --cc fs/overlayfs/copy_up.c
index 6e96b99a973d,9f5a47338e59..000000000000
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@@ -264,34 -233,166 +264,123 @@@ int ovl_set_attr(struct dentry *upperde
  	return err;
  }
  
 -struct ovl_fh *ovl_encode_fh(struct dentry *lower, bool is_upper)
 +static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,
 +			      struct dentry *dentry, struct path *lowerpath,
 +			      struct kstat *stat, const char *link)
  {
 -	struct ovl_fh *fh;
 -	int fh_type, fh_len, dwords;
 -	void *buf;
 -	int buflen = MAX_HANDLE_SZ;
 -	uuid_t *uuid = &lower->d_sb->s_uuid;
 -
 -	buf = kmalloc(buflen, GFP_TEMPORARY);
 -	if (!buf)
 -		return ERR_PTR(-ENOMEM);
 -
 -	/*
 -	 * We encode a non-connectable file handle for non-dir, because we
 -	 * only need to find the lower inode number and we don't want to pay
 -	 * the price or reconnecting the dentry.
 -	 */
 -	dwords = buflen >> 2;
 -	fh_type = exportfs_encode_fh(lower, buf, &dwords, 0);
 -	buflen = (dwords << 2);
 -
 -	fh = ERR_PTR(-EIO);
 -	if (WARN_ON(fh_type < 0) ||
 -	    WARN_ON(buflen > MAX_HANDLE_SZ) ||
 -	    WARN_ON(fh_type == FILEID_INVALID))
 -		goto out;
 -
 -	BUILD_BUG_ON(MAX_HANDLE_SZ + offsetof(struct ovl_fh, fid) > 255);
 -	fh_len = offsetof(struct ovl_fh, fid) + buflen;
 -	fh = kmalloc(fh_len, GFP_KERNEL);
 -	if (!fh) {
 -		fh = ERR_PTR(-ENOMEM);
 -		goto out;
 -	}
 -
 -	fh->version = OVL_FH_VERSION;
 -	fh->magic = OVL_FH_MAGIC;
 -	fh->type = fh_type;
 -	fh->flags = OVL_FH_FLAG_CPU_ENDIAN;
 -	/*
 -	 * When we will want to decode an overlay dentry from this handle
 -	 * and all layers are on the same fs, if we get a disconncted real
 -	 * dentry when we decode fid, the only way to tell if we should assign
 -	 * it to upperdentry or to lowerstack is by checking this flag.
 -	 */
 -	if (is_upper)
 -		fh->flags |= OVL_FH_FLAG_PATH_UPPER;
 -	fh->len = fh_len;
 -	fh->uuid = *uuid;
 -	memcpy(fh->fid, buf, buflen);
 -
 -out:
 -	kfree(buf);
 -	return fh;
 -}
 -
 -static int ovl_set_origin(struct dentry *dentry, struct dentry *lower,
 -			  struct dentry *upper)
 -{
 -	const struct ovl_fh *fh = NULL;
 +	struct inode *wdir = workdir->d_inode;
 +	struct inode *udir = upperdir->d_inode;
 +	struct dentry *newdentry = NULL;
 +	struct dentry *upper = NULL;
 +	umode_t mode = stat->mode;
  	int err;
++<<<<<<< HEAD
++=======
+ 
+ 	/*
+ 	 * When lower layer doesn't support export operations store a 'null' fh,
+ 	 * so we can use the overlay.origin xattr to distignuish between a copy
+ 	 * up and a pure upper inode.
+ 	 */
+ 	if (ovl_can_decode_fh(lower->d_sb)) {
+ 		fh = ovl_encode_fh(lower, false);
+ 		if (IS_ERR(fh))
+ 			return PTR_ERR(fh);
+ 	}
+ 
+ 	/*
+ 	 * Do not fail when upper doesn't support xattrs.
+ 	 */
+ 	err = ovl_check_setxattr(dentry, upper, OVL_XATTR_ORIGIN, fh,
+ 				 fh ? fh->len : 0, 0);
+ 	kfree(fh);
+ 
+ 	return err;
+ }
+ 
+ static int ovl_link_up(struct dentry *parent, struct dentry *dentry)
+ {
+ 	int err;
+ 	struct dentry *upper;
+ 	struct dentry *upperdir = ovl_dentry_upper(parent);
+ 	struct inode *udir = d_inode(upperdir);
+ 
+ 	inode_lock_nested(udir, I_MUTEX_PARENT);
+ 	upper = lookup_one_len(dentry->d_name.name, upperdir,
+ 			       dentry->d_name.len);
+ 	err = PTR_ERR(upper);
+ 	if (!IS_ERR(upper)) {
+ 		err = ovl_do_link(ovl_dentry_upper(dentry), udir, upper, true);
+ 		dput(upper);
+ 
+ 		if (!err)
+ 			ovl_dentry_set_upper_alias(dentry);
+ 	}
+ 	inode_unlock(udir);
+ 
+ 	return err;
+ }
+ 
+ struct ovl_copy_up_ctx {
+ 	struct dentry *parent;
+ 	struct dentry *dentry;
+ 	struct path lowerpath;
+ 	struct kstat stat;
+ 	struct kstat pstat;
+ 	const char *link;
+ 	struct dentry *destdir;
+ 	struct qstr destname;
+ 	struct dentry *workdir;
+ 	bool tmpfile;
+ 	bool origin;
+ };
+ 
+ static int ovl_install_temp(struct ovl_copy_up_ctx *c, struct dentry *temp,
+ 			    struct dentry **newdentry)
+ {
+ 	int err;
+ 	struct dentry *upper;
+ 	struct inode *udir = d_inode(c->destdir);
+ 
+ 	upper = lookup_one_len(c->destname.name, c->destdir, c->destname.len);
+ 	if (IS_ERR(upper))
+ 		return PTR_ERR(upper);
+ 
+ 	if (c->tmpfile)
+ 		err = ovl_do_link(temp, udir, upper, true);
+ 	else
+ 		err = ovl_do_rename(d_inode(c->workdir), temp, udir, upper, 0);
+ 
+ 	if (!err)
+ 		*newdentry = dget(c->tmpfile ? upper : temp);
+ 	dput(upper);
+ 
+ 	return err;
+ }
+ 
+ static int ovl_get_tmpfile(struct ovl_copy_up_ctx *c, struct dentry **tempp)
+ {
+ 	int err;
+ 	struct dentry *temp;
++>>>>>>> 59be09712ab9 (ovl: implement index dir copy up)
  	const struct cred *old_creds = NULL;
  	struct cred *new_creds = NULL;
 -	struct cattr cattr = {
 -		/* Can't properly set mode on creation because of the umask */
 -		.mode = c->stat.mode & S_IFMT,
 -		.rdev = c->stat.rdev,
 -		.link = c->link
 -	};
  
 -	err = security_inode_copy_up(c->dentry, &new_creds);
 -	if (err < 0)
 +	newdentry = ovl_lookup_temp(workdir, dentry);
 +	err = PTR_ERR(newdentry);
 +	if (IS_ERR(newdentry))
  		goto out;
  
 +	upper = lookup_one_len(dentry->d_name.name, upperdir,
 +			       dentry->d_name.len);
 +	err = PTR_ERR(upper);
 +	if (IS_ERR(upper))
 +		goto out1;
 +
 +	err = security_inode_copy_up(dentry, &new_creds);
 +	if (err < 0)
 +		goto out2;
 +
  	if (new_creds)
  		old_creds = override_creds(new_creds);
  
@@@ -305,49 -420,83 +394,87 @@@
  		put_cred(new_creds);
  	}
  
 -	return err;
 -
 -temp_err:
 -	err = PTR_ERR(temp);
 -	goto out;
 -}
 -
 -static int ovl_copy_up_inode(struct ovl_copy_up_ctx *c, struct dentry *temp)
 -{
 -	int err;
 +	if (err)
 +		goto out2;
  
 -	if (S_ISREG(c->stat.mode)) {
 +	if (S_ISREG(stat->mode)) {
  		struct path upperpath;
  
 -		ovl_path_upper(c->dentry, &upperpath);
 +		ovl_path_upper(dentry, &upperpath);
  		BUG_ON(upperpath.dentry != NULL);
 -		upperpath.dentry = temp;
 +		upperpath.dentry = newdentry;
  
 -		err = ovl_copy_up_data(&c->lowerpath, &upperpath, c->stat.size);
 +		err = ovl_copy_up_data(lowerpath, &upperpath, stat->size);
  		if (err)
 -			return err;
 +			goto out_cleanup;
  	}
  
 -	err = ovl_copy_xattr(c->lowerpath.dentry, temp);
 +	err = ovl_copy_xattr(lowerpath->dentry, newdentry);
  	if (err)
 -		return err;
 +		goto out_cleanup;
  
 -	inode_lock(temp->d_inode);
 -	err = ovl_set_attr(temp, &c->stat);
 -	inode_unlock(temp->d_inode);
 +	mutex_lock(&newdentry->d_inode->i_mutex);
 +	err = ovl_set_attr(newdentry, stat);
 +	mutex_unlock(&newdentry->d_inode->i_mutex);
  	if (err)
 -		return err;
 +		goto out_cleanup;
 +
 +	err = ovl_do_rename(wdir, newdentry, udir, upper, 0);
 +	if (err)
 +		goto out_cleanup;
 +
 +	ovl_dentry_update(dentry, newdentry);
 +	ovl_inode_update(d_inode(dentry), d_inode(newdentry));
 +	newdentry = NULL;
  
  	/*
 -	 * Store identifier of lower inode in upper inode xattr to
 -	 * allow lookup of the copy up origin inode.
 -	 *
 -	 * Don't set origin when we are breaking the association with a lower
 -	 * hard link.
 +	 * Non-directores become opaque when copied up.
  	 */
++<<<<<<< HEAD
 +	if (!S_ISDIR(stat->mode))
 +		ovl_dentry_set_opaque(dentry, true);
 +out2:
 +	dput(upper);
 +out1:
 +	dput(newdentry);
++=======
+ 	if (c->origin) {
+ 		err = ovl_set_origin(c->dentry, c->lowerpath.dentry, temp);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int ovl_copy_up_locked(struct ovl_copy_up_ctx *c)
+ {
+ 	struct inode *udir = c->destdir->d_inode;
+ 	struct dentry *newdentry = NULL;
+ 	struct dentry *temp = NULL;
+ 	int err;
+ 
+ 	err = ovl_get_tmpfile(c, &temp);
+ 	if (err)
+ 		goto out;
+ 
+ 	err = ovl_copy_up_inode(c, temp);
+ 	if (err)
+ 		goto out_cleanup;
+ 
+ 	if (c->tmpfile) {
+ 		inode_lock_nested(udir, I_MUTEX_PARENT);
+ 		err = ovl_install_temp(c, temp, &newdentry);
+ 		inode_unlock(udir);
+ 	} else {
+ 		err = ovl_install_temp(c, temp, &newdentry);
+ 	}
+ 	if (err)
+ 		goto out_cleanup;
+ 
+ 	ovl_inode_update(d_inode(c->dentry), newdentry);
++>>>>>>> 59be09712ab9 (ovl: implement index dir copy up)
  out:
 -	dput(temp);
  	return err;
  
  out_cleanup:
@@@ -358,70 -508,126 +485,184 @@@
  /*
   * Copy up a single dentry
   *
 - * All renames start with copy up of source if necessary.  The actual
 - * rename will only proceed once the copy up was successful.  Copy up uses
 - * upper parent i_mutex for exclusion.  Since rename can change d_parent it
 - * is possible that the copy up will lock the old parent.  At that point
 - * the file will have already been copied up anyway.
 + * Directory renames only allowed on "pure upper" (already created on
 + * upper filesystem, never copied up).  Directories which are on lower or
 + * are merged may not be renamed.  For these -EXDEV is returned and
 + * userspace has to deal with it.  This means, when copying up a
 + * directory we can rely on it and ancestors being stable.
 + *
 + * Non-directory renames start with copy up of source if necessary.  The
 + * actual rename will only proceed once the copy up was successful.  Copy
 + * up uses upper parent i_mutex for exclusion.  Since rename can change
 + * d_parent it is possible that the copy up will lock the old parent.  At
 + * that point the file will have already been copied up anyway.
   */
 -static int ovl_do_copy_up(struct ovl_copy_up_ctx *c)
 +static int ovl_copy_up_one(struct dentry *parent, struct dentry *dentry,
 +			   struct path *lowerpath, struct kstat *stat)
  {
 +	struct dentry *workdir = ovl_workdir(dentry);
  	int err;
++<<<<<<< HEAD
 +	struct kstat pstat;
 +	struct path parentpath;
 +	struct dentry *upperdir;
 +	struct dentry *upperdentry;
 +	char *link = NULL;
 +
 +	if (WARN_ON(!workdir))
 +		return -EROFS;
 +
 +	ovl_do_check_copy_up(lowerpath->dentry);
 +
 +	ovl_path_upper(parent, &parentpath);
 +	upperdir = parentpath.dentry;
 +
 +	err = vfs_getattr(&parentpath, &pstat);
 +	if (err)
 +		return err;
 +
 +	if (S_ISLNK(stat->mode)) {
 +		link = ovl_read_symlink(lowerpath->dentry);
 +		if (IS_ERR(link))
 +			return PTR_ERR(link);
 +	}
 +
 +	err = -EIO;
 +	if (lock_rename(workdir, upperdir) != NULL) {
 +		pr_err("overlayfs: failed to lock workdir+upperdir\n");
 +		goto out_unlock;
 +	}
 +	upperdentry = ovl_dentry_upper(dentry);
 +	if (upperdentry) {
 +		/* Raced with another copy-up?  Nothing to do, then... */
 +		err = 0;
 +		goto out_unlock;
 +	}
 +
 +	err = ovl_copy_up_locked(workdir, upperdir, dentry, lowerpath,
 +				 stat, link);
 +	if (!err) {
 +		/* Restore timestamps on parent (best effort) */
 +		ovl_set_timestamps(upperdir, &pstat);
++=======
+ 	struct ovl_fs *ofs = c->dentry->d_sb->s_fs_info;
+ 	bool indexed = false;
+ 
+ 	if (ovl_indexdir(c->dentry->d_sb) && !S_ISDIR(c->stat.mode) &&
+ 	    c->stat.nlink > 1)
+ 		indexed = true;
+ 
+ 	if (S_ISDIR(c->stat.mode) || c->stat.nlink == 1 || indexed)
+ 		c->origin = true;
+ 
+ 	if (indexed) {
+ 		c->destdir = ovl_indexdir(c->dentry->d_sb);
+ 		err = ovl_get_index_name(c->lowerpath.dentry, &c->destname);
+ 		if (err)
+ 			return err;
+ 	} else {
+ 		/*
+ 		 * Mark parent "impure" because it may now contain non-pure
+ 		 * upper
+ 		 */
+ 		err = ovl_set_impure(c->parent, c->destdir);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	/* Should we copyup with O_TMPFILE or with workdir? */
+ 	if (S_ISREG(c->stat.mode) && ofs->tmpfile) {
+ 		c->tmpfile = true;
+ 		err = ovl_copy_up_locked(c);
+ 	} else {
+ 		err = -EIO;
+ 		if (lock_rename(c->workdir, c->destdir) != NULL) {
+ 			pr_err("overlayfs: failed to lock workdir+upperdir\n");
+ 		} else {
+ 			err = ovl_copy_up_locked(c);
+ 			unlock_rename(c->workdir, c->destdir);
+ 		}
+ 	}
+ 
+ 	if (indexed) {
+ 		if (!err)
+ 			ovl_set_flag(OVL_INDEX, d_inode(c->dentry));
+ 		kfree(c->destname.name);
+ 	} else if (!err) {
+ 		struct inode *udir = d_inode(c->destdir);
+ 
+ 		/* Restore timestamps on parent (best effort) */
+ 		inode_lock(udir);
+ 		ovl_set_timestamps(c->destdir, &c->pstat);
+ 		inode_unlock(udir);
+ 
+ 		ovl_dentry_set_upper_alias(c->dentry);
+ 	}
+ 
+ 	return err;
+ }
+ 
+ static int ovl_copy_up_one(struct dentry *parent, struct dentry *dentry,
+ 			   int flags)
+ {
+ 	int err;
+ 	DEFINE_DELAYED_CALL(done);
+ 	struct path parentpath;
+ 	struct ovl_copy_up_ctx ctx = {
+ 		.parent = parent,
+ 		.dentry = dentry,
+ 		.workdir = ovl_workdir(dentry),
+ 	};
+ 
+ 	if (WARN_ON(!ctx.workdir))
+ 		return -EROFS;
+ 
+ 	ovl_path_lower(dentry, &ctx.lowerpath);
+ 	err = vfs_getattr(&ctx.lowerpath, &ctx.stat,
+ 			  STATX_BASIC_STATS, AT_STATX_SYNC_AS_STAT);
+ 	if (err)
+ 		return err;
+ 
+ 	ovl_path_upper(parent, &parentpath);
+ 	ctx.destdir = parentpath.dentry;
+ 	ctx.destname = dentry->d_name;
+ 
+ 	err = vfs_getattr(&parentpath, &ctx.pstat,
+ 			  STATX_ATIME | STATX_MTIME, AT_STATX_SYNC_AS_STAT);
+ 	if (err)
+ 		return err;
+ 
+ 	/* maybe truncate regular file. this has no effect on dirs */
+ 	if (flags & O_TRUNC)
+ 		ctx.stat.size = 0;
+ 
+ 	if (S_ISLNK(ctx.stat.mode)) {
+ 		ctx.link = vfs_get_link(ctx.lowerpath.dentry, &done);
+ 		if (IS_ERR(ctx.link))
+ 			return PTR_ERR(ctx.link);
++>>>>>>> 59be09712ab9 (ovl: implement index dir copy up)
  	}
 -	ovl_do_check_copy_up(ctx.lowerpath.dentry);
 +out_unlock:
 +	unlock_rename(workdir, upperdir);
  
++<<<<<<< HEAD
 +	if (link)
 +		free_page((unsigned long) link);
++=======
+ 	err = ovl_copy_up_start(dentry);
+ 	/* err < 0: interrupted, err > 0: raced with another copy-up */
+ 	if (unlikely(err)) {
+ 		if (err > 0)
+ 			err = 0;
+ 	} else {
+ 		if (!ovl_dentry_upper(dentry))
+ 			err = ovl_do_copy_up(&ctx);
+ 		if (!err && !ovl_dentry_has_upper_alias(dentry))
+ 			err = ovl_link_up(parent, dentry);
+ 		ovl_copy_up_end(dentry);
+ 	}
+ 	do_delayed_call(&done);
++>>>>>>> 59be09712ab9 (ovl: implement index dir copy up)
  
  	return err;
  }
@@@ -434,11 -640,22 +675,28 @@@ int ovl_copy_up_flags(struct dentry *de
  	while (!err) {
  		struct dentry *next;
  		struct dentry *parent;
++<<<<<<< HEAD
 +		struct path lowerpath;
 +		struct kstat stat;
 +		enum ovl_path_type type = ovl_path_type(dentry);
- 
- 		if (OVL_TYPE_UPPER(type))
++=======
++>>>>>>> 59be09712ab9 (ovl: implement index dir copy up)
+ 
+ 		/*
+ 		 * Check if copy-up has happened as well as for upper alias (in
+ 		 * case of hard links) is there.
+ 		 *
+ 		 * Both checks are lockless:
+ 		 *  - false negatives: will recheck under oi->lock
+ 		 *  - false positives:
+ 		 *    + ovl_dentry_upper() uses memory barriers to ensure the
+ 		 *      upper dentry is up-to-date
+ 		 *    + ovl_dentry_has_upper_alias() relies on locking of
+ 		 *      upper parent i_rwsem to prevent reordering copy-up
+ 		 *      with rename.
+ 		 */
+ 		if (ovl_dentry_upper(dentry) &&
+ 		    ovl_dentry_has_upper_alias(dentry))
  			break;
  
  		next = dget(dentry);
* Unmerged path fs/overlayfs/util.c
* Unmerged path fs/overlayfs/copy_up.c
diff --git a/fs/overlayfs/inode.c b/fs/overlayfs/inode.c
index e60c6d748742..c3e6ae786e53 100644
--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@ -298,13 +298,13 @@ struct posix_acl *ovl_get_acl(struct inode *inode, int type)
 	return acl;
 }
 
-static bool ovl_open_need_copy_up(int flags, enum ovl_path_type type,
-				  struct dentry *realdentry)
+static bool ovl_open_need_copy_up(struct dentry *dentry, int flags)
 {
-	if (OVL_TYPE_UPPER(type))
+	if (ovl_dentry_upper(dentry) &&
+	    ovl_dentry_has_upper_alias(dentry))
 		return false;
 
-	if (special_file(realdentry->d_inode->i_mode))
+	if (special_file(d_inode(dentry)->i_mode))
 		return false;
 
 	if (!(OPEN_FMODE(flags) & FMODE_WRITE) && !(flags & O_TRUNC))
@@ -316,11 +316,8 @@ static bool ovl_open_need_copy_up(int flags, enum ovl_path_type type,
 int ovl_open_maybe_copy_up(struct dentry *dentry, unsigned int file_flags)
 {
 	int err = 0;
-	struct path realpath;
-	enum ovl_path_type type;
 
-	type = ovl_path_real(dentry, &realpath);
-	if (ovl_open_need_copy_up(file_flags, type, realpath.dentry)) {
+	if (ovl_open_need_copy_up(dentry, file_flags)) {
 		err = ovl_want_write(dentry);
 		if (!err) {
 			err = ovl_copy_up_flags(dentry, file_flags);
* Unmerged path fs/overlayfs/util.c
