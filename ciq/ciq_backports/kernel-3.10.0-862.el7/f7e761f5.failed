scsi: qla2xxx: Turn on FW option for exchange check

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Turn on FW option for exchange check (Himanshu Madhani) [1460030]
Rebuild_FUZZ: 93.75%
commit-author Quinn Tran <quinn.tran@cavium.com>
commit f7e761f56c711907ccf342532120f826d5ccff3f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f7e761f5.failed

Tell FW to track exchange/cmd state to prevent driver from using stale
exchange or exchange that is not meant for this command.

	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit f7e761f56c711907ccf342532120f826d5ccff3f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_init.c
#	drivers/scsi/qla2xxx/qla_target.c
diff --cc drivers/scsi/qla2xxx/qla_init.c
index b9189cae77e5,f92e74639bb1..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -2076,14 -2959,36 +2076,37 @@@ qla24xx_update_fw_options(scsi_qla_host
  			__func__, ha->fw_options[2]);
  	}
  
 -	/* Move PUREX, ABTS RX & RIDA to ATIOQ */
 -	if (ql2xmvasynctoatio &&
 -	    (IS_QLA83XX(ha) || IS_QLA27XX(ha))) {
 -		if (qla_tgt_mode_enabled(vha) ||
 -		    qla_dual_mode_enabled(vha))
 -			ha->fw_options[2] |= BIT_11;
 -		else
 -			ha->fw_options[2] &= ~BIT_11;
 +	/* Set Retry FLOGI in case of P2P connection */
 +	if (ha->operating_mode == P2P) {
 +		ha->fw_options[2] |= BIT_3;
 +		ql_dbg(ql_dbg_disc, vha, 0x2101,
 +		    "(%s): Setting FLOGI retry BIT in fw_options[2]: 0x%x\n",
 +			__func__, ha->fw_options[2]);
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (IS_QLA25XX(ha) || IS_QLA83XX(ha) || IS_QLA27XX(ha)) {
+ 		/*
+ 		 * Tell FW to track each exchange to prevent
+ 		 * driver from using stale exchange.
+ 		 */
+ 		if (qla_tgt_mode_enabled(vha) ||
+ 		    qla_dual_mode_enabled(vha))
+ 			ha->fw_options[2] |= BIT_4;
+ 		else
+ 			ha->fw_options[2] &= ~BIT_4;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_init, vha, 0x00e8,
+ 	    "%s, add FW options 1-3 = 0x%04x 0x%04x 0x%04x mode %x\n",
+ 	    __func__, ha->fw_options[1], ha->fw_options[2],
+ 	    ha->fw_options[3], vha->host->active_mode);
+ 
+ 	if (ha->fw_options[1] || ha->fw_options[2] || ha->fw_options[3])
+ 		qla2x00_set_fw_options(vha, ha->fw_options);
+ 
++>>>>>>> f7e761f56c71 (scsi: qla2xxx: Turn on FW option for exchange check)
  	/* Update Serial Link options. */
  	if ((le16_to_cpu(ha->fw_seriallink_options24[0]) & BIT_0) == 0)
  		return;
@@@ -6416,21 -7364,32 +6439,40 @@@ qla81xx_update_fw_options(scsi_qla_host
  			__func__, ha->fw_options[2]);
  	}
  
 -	/* Move PUREX, ABTS RX & RIDA to ATIOQ */
 -	if (ql2xmvasynctoatio) {
 -		if (qla_tgt_mode_enabled(vha) ||
 -		    qla_dual_mode_enabled(vha))
 -			ha->fw_options[2] |= BIT_11;
 -		else
 -			ha->fw_options[2] &= ~BIT_11;
 +	/* Set Retry FLOGI in case of P2P connection */
 +	if (ha->operating_mode == P2P) {
 +		ha->fw_options[2] |= BIT_3;
 +		ql_dbg(ql_dbg_disc, vha, 0x2103,
 +		    "(%s): Setting FLOGI retry BIT in fw_options[2]: 0x%x\n",
 +			__func__, ha->fw_options[2]);
  	}
  
++<<<<<<< HEAD
 +	if (!ql2xetsenable)
 +		goto out;
++=======
+ 	if (qla_tgt_mode_enabled(vha) ||
+ 	    qla_dual_mode_enabled(vha))
+ 		ha->fw_options[2] |= BIT_4;
+ 	else
+ 		ha->fw_options[2] &= ~BIT_4;
+ 
+ 	if (ql2xetsenable) {
+ 		/* Enable ETS Burst. */
+ 		memset(ha->fw_options, 0, sizeof(ha->fw_options));
+ 		ha->fw_options[2] |= BIT_9;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_init, vha, 0x00e9,
+ 	    "%s, add FW options 1-3 = 0x%04x 0x%04x 0x%04x mode %x\n",
+ 	    __func__, ha->fw_options[1], ha->fw_options[2],
+ 	    ha->fw_options[3], vha->host->active_mode);
++>>>>>>> f7e761f56c71 (scsi: qla2xxx: Turn on FW option for exchange check)
  
 +	/* Enable ETS Burst. */
 +	memset(ha->fw_options, 0, sizeof(ha->fw_options));
 +	ha->fw_options[2] |= BIT_9;
 +out:
  	qla2x00_set_fw_options(vha, ha->fw_options);
  }
  
diff --cc drivers/scsi/qla2xxx/qla_target.c
index f10c075d97ef,3cdffdd90279..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -1392,9 -2016,11 +1392,17 @@@ static void qlt_24xx_send_task_mgmt_cti
  	ctio->initiator_id[1] = atio->u.isp24.fcp_hdr.s_id[1];
  	ctio->initiator_id[2] = atio->u.isp24.fcp_hdr.s_id[0];
  	ctio->exchange_addr = atio->u.isp24.exchange_addr;
++<<<<<<< HEAD
 +	ctio->u.status1.flags = (atio->u.isp24.attr << 9) |
 +	    cpu_to_le16(CTIO7_FLAGS_STATUS_MODE_1 | CTIO7_FLAGS_SEND_STATUS);
 +	ctio->u.status1.ox_id = cpu_to_le16(atio->u.isp24.fcp_hdr.ox_id);
++=======
+ 	temp = (atio->u.isp24.attr << 9)|
+ 		CTIO7_FLAGS_STATUS_MODE_1 | CTIO7_FLAGS_SEND_STATUS;
+ 	ctio->u.status1.flags = cpu_to_le16(temp);
+ 	temp = be16_to_cpu(atio->u.isp24.fcp_hdr.ox_id);
+ 	ctio->u.status1.ox_id = cpu_to_le16(temp);
++>>>>>>> f7e761f56c71 (scsi: qla2xxx: Turn on FW option for exchange check)
  	ctio->u.status1.scsi_status =
  	    cpu_to_le16(SS_RESPONSE_INFO_LEN_VALID);
  	ctio->u.status1.response_len = cpu_to_le16(8);
@@@ -1411,6 -2037,71 +1419,74 @@@ void qlt_free_mcmd(struct qla_tgt_mgmt_
  }
  EXPORT_SYMBOL(qlt_free_mcmd);
  
++<<<<<<< HEAD
++=======
+ /*
+  * ha->hardware_lock supposed to be held on entry. Might drop it, then
+  * reacquire
+  */
+ void qlt_send_resp_ctio(scsi_qla_host_t *vha, struct qla_tgt_cmd *cmd,
+     uint8_t scsi_status, uint8_t sense_key, uint8_t asc, uint8_t ascq)
+ {
+ 	struct atio_from_isp *atio = &cmd->atio;
+ 	struct ctio7_to_24xx *ctio;
+ 	uint16_t temp;
+ 
+ 	ql_dbg(ql_dbg_tgt_dif, vha, 0x3066,
+ 	    "Sending response CTIO7 (vha=%p, atio=%p, scsi_status=%02x, "
+ 	    "sense_key=%02x, asc=%02x, ascq=%02x",
+ 	    vha, atio, scsi_status, sense_key, asc, ascq);
+ 
+ 	ctio = (struct ctio7_to_24xx *)qla2x00_alloc_iocbs(vha, NULL);
+ 	if (!ctio) {
+ 		ql_dbg(ql_dbg_async, vha, 0x3067,
+ 		    "qla2x00t(%ld): %s failed: unable to allocate request packet",
+ 		    vha->host_no, __func__);
+ 		goto out;
+ 	}
+ 
+ 	ctio->entry_type = CTIO_TYPE7;
+ 	ctio->entry_count = 1;
+ 	ctio->handle = QLA_TGT_SKIP_HANDLE;
+ 	ctio->nport_handle = cmd->sess->loop_id;
+ 	ctio->timeout = cpu_to_le16(QLA_TGT_TIMEOUT);
+ 	ctio->vp_index = vha->vp_idx;
+ 	ctio->initiator_id[0] = atio->u.isp24.fcp_hdr.s_id[2];
+ 	ctio->initiator_id[1] = atio->u.isp24.fcp_hdr.s_id[1];
+ 	ctio->initiator_id[2] = atio->u.isp24.fcp_hdr.s_id[0];
+ 	ctio->exchange_addr = atio->u.isp24.exchange_addr;
+ 	temp = (atio->u.isp24.attr << 9) |
+ 	    CTIO7_FLAGS_STATUS_MODE_1 | CTIO7_FLAGS_SEND_STATUS;
+ 	ctio->u.status1.flags = cpu_to_le16(temp);
+ 	temp = be16_to_cpu(atio->u.isp24.fcp_hdr.ox_id);
+ 	ctio->u.status1.ox_id = cpu_to_le16(temp);
+ 	ctio->u.status1.scsi_status =
+ 	    cpu_to_le16(SS_RESPONSE_INFO_LEN_VALID | scsi_status);
+ 	ctio->u.status1.response_len = cpu_to_le16(18);
+ 	ctio->u.status1.residual = cpu_to_le32(get_datalen_for_atio(atio));
+ 
+ 	if (ctio->u.status1.residual != 0)
+ 		ctio->u.status1.scsi_status |=
+ 		    cpu_to_le16(SS_RESIDUAL_UNDER);
+ 
+ 	/* Response code and sense key */
+ 	put_unaligned_le32(((0x70 << 24) | (sense_key << 8)),
+ 	    (&ctio->u.status1.sense_data)[0]);
+ 	/* Additional sense length */
+ 	put_unaligned_le32(0x0a, (&ctio->u.status1.sense_data)[1]);
+ 	/* ASC and ASCQ */
+ 	put_unaligned_le32(((asc << 24) | (ascq << 16)),
+ 	    (&ctio->u.status1.sense_data)[3]);
+ 
+ 	/* Memory Barrier */
+ 	wmb();
+ 
+ 	qla2x00_start_iocbs(vha, vha->req);
+ out:
+ 	return;
+ }
+ 
++>>>>>>> f7e761f56c71 (scsi: qla2xxx: Turn on FW option for exchange check)
  /* callback from target fabric module code */
  void qlt_xmit_tm_rsp(struct qla_tgt_mgmt_cmd *mcmd)
  {
@@@ -1603,14 -2361,12 +1679,21 @@@ static int qlt_24xx_build_ctio_pkt(stru
  	pkt->initiator_id[1] = atio->u.isp24.fcp_hdr.s_id[1];
  	pkt->initiator_id[2] = atio->u.isp24.fcp_hdr.s_id[0];
  	pkt->exchange_addr = atio->u.isp24.exchange_addr;
++<<<<<<< HEAD
 +	pkt->u.status0.flags |= (atio->u.isp24.attr << 9);
 +	pkt->u.status0.ox_id = swab16(atio->u.isp24.fcp_hdr.ox_id);
++=======
+ 	temp = atio->u.isp24.attr << 9;
+ 	pkt->u.status0.flags |= cpu_to_le16(temp);
+ 	temp = be16_to_cpu(atio->u.isp24.fcp_hdr.ox_id);
+ 	pkt->u.status0.ox_id = cpu_to_le16(temp);
++>>>>>>> f7e761f56c71 (scsi: qla2xxx: Turn on FW option for exchange check)
  	pkt->u.status0.relative_offset = cpu_to_le32(prm->cmd->offset);
  
 +	ql_dbg(ql_dbg_tgt, vha, 0xe00c,
 +	    "qla_target(%d): handle(cmd) -> %08x, timeout %d, ox_id %#x\n",
 +	    vha->vp_idx, pkt->handle, QLA_TGT_TIMEOUT,
 +	    le16_to_cpu(pkt->u.status0.ox_id));
  	return 0;
  }
  
@@@ -2237,10 -3487,11 +2320,18 @@@ static int __qlt_send_term_exchange(str
  	ctio24->initiator_id[1] = atio->u.isp24.fcp_hdr.s_id[1];
  	ctio24->initiator_id[2] = atio->u.isp24.fcp_hdr.s_id[0];
  	ctio24->exchange_addr = atio->u.isp24.exchange_addr;
++<<<<<<< HEAD
 +	ctio24->u.status1.flags = (atio->u.isp24.attr << 9) |
 +	    cpu_to_le16(CTIO7_FLAGS_STATUS_MODE_1 |
 +		CTIO7_FLAGS_TERMINATE);
 +	ctio24->u.status1.ox_id = swab16(atio->u.isp24.fcp_hdr.ox_id);
++=======
+ 	temp = (atio->u.isp24.attr << 9) | CTIO7_FLAGS_STATUS_MODE_1 |
+ 		CTIO7_FLAGS_TERMINATE;
+ 	ctio24->u.status1.flags = cpu_to_le16(temp);
+ 	temp = be16_to_cpu(atio->u.isp24.fcp_hdr.ox_id);
+ 	ctio24->u.status1.ox_id = cpu_to_le16(temp);
++>>>>>>> f7e761f56c71 (scsi: qla2xxx: Turn on FW option for exchange check)
  
  	/* Most likely, it isn't needed */
  	ctio24->u.status1.residual = get_unaligned((uint32_t *)
@@@ -3592,13 -4979,17 +3683,19 @@@ static void qlt_send_busy(struct scsi_q
  	struct ctio7_to_24xx *ctio24;
  	struct qla_hw_data *ha = vha->hw;
  	request_t *pkt;
++<<<<<<< HEAD
 +	struct qla_tgt_sess *sess = NULL;
++=======
+ 	struct fc_port *sess = NULL;
+ 	unsigned long flags;
+ 	u16 temp;
++>>>>>>> f7e761f56c71 (scsi: qla2xxx: Turn on FW option for exchange check)
  
 -	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
  	sess = ha->tgt.tgt_ops->find_sess_by_s_id(vha,
  	    atio->u.isp24.fcp_hdr.s_id);
 -	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
  	if (!sess) {
 -		qlt_send_term_exchange(vha, NULL, atio, 1, 0);
 -		return 0;
 +		qlt_send_term_exchange(vha, NULL, atio, 1);
 +		return;
  	}
  	/* Sending marker isn't necessary, since we called from ISR */
  
@@@ -3610,31 -5001,221 +3707,31 @@@
  		return;
  	}
  
 -	memset(cmd, 0, sizeof(struct qla_tgt_cmd));
 -
 -	qlt_incr_num_pend_cmds(vha);
 -	INIT_LIST_HEAD(&cmd->cmd_list);
 -	memcpy(&cmd->atio, atio, sizeof(*atio));
 -
 -	cmd->tgt = vha->vha_tgt.qla_tgt;
 -	cmd->vha = vha;
 -	cmd->reset_count = vha->hw->chip_reset;
 -	cmd->q_full = 1;
 -
 -	if (qfull) {
 -		cmd->q_full = 1;
 -		/* NOTE: borrowing the state field to carry the status */
 -		cmd->state = status;
 -	} else
 -		cmd->term_exchg = 1;
 -
 -	list_add_tail(&cmd->cmd_list, &vha->hw->tgt.q_full_list);
 -
 -	vha->hw->tgt.num_qfull_cmds_alloc++;
 -	if (vha->hw->tgt.num_qfull_cmds_alloc >
 -		vha->qla_stats.stat_max_qfull_cmds_alloc)
 -		vha->qla_stats.stat_max_qfull_cmds_alloc =
 -			vha->hw->tgt.num_qfull_cmds_alloc;
 -}
 -
 -int
 -qlt_free_qfull_cmds(struct scsi_qla_host *vha)
 -{
 -	struct qla_hw_data *ha = vha->hw;
 -	unsigned long flags;
 -	struct qla_tgt_cmd *cmd, *tcmd;
 -	struct list_head free_list;
 -	int rc = 0;
 -
 -	if (list_empty(&ha->tgt.q_full_list))
 -		return 0;
 -
 -	INIT_LIST_HEAD(&free_list);
 -
 -	spin_lock_irqsave(&vha->hw->hardware_lock, flags);
 -
 -	if (list_empty(&ha->tgt.q_full_list)) {
 -		spin_unlock_irqrestore(&vha->hw->hardware_lock, flags);
 -		return 0;
 -	}
 -
 -	list_for_each_entry_safe(cmd, tcmd, &ha->tgt.q_full_list, cmd_list) {
 -		if (cmd->q_full)
 -			/* cmd->state is a borrowed field to hold status */
 -			rc = __qlt_send_busy(vha, &cmd->atio, cmd->state);
 -		else if (cmd->term_exchg)
 -			rc = __qlt_send_term_exchange(vha, NULL, &cmd->atio);
 -
 -		if (rc == -ENOMEM)
 -			break;
 -
 -		if (cmd->q_full)
 -			ql_dbg(ql_dbg_io, vha, 0x3006,
 -			    "%s: busy sent for ox_id[%04x]\n", __func__,
 -			    be16_to_cpu(cmd->atio.u.isp24.fcp_hdr.ox_id));
 -		else if (cmd->term_exchg)
 -			ql_dbg(ql_dbg_io, vha, 0x3007,
 -			    "%s: Term exchg sent for ox_id[%04x]\n", __func__,
 -			    be16_to_cpu(cmd->atio.u.isp24.fcp_hdr.ox_id));
 -		else
 -			ql_dbg(ql_dbg_io, vha, 0x3008,
 -			    "%s: Unexpected cmd in QFull list %p\n", __func__,
 -			    cmd);
 -
 -		list_del(&cmd->cmd_list);
 -		list_add_tail(&cmd->cmd_list, &free_list);
 -
 -		/* piggy back on hardware_lock for protection */
 -		vha->hw->tgt.num_qfull_cmds_alloc--;
 -	}
 -	spin_unlock_irqrestore(&vha->hw->hardware_lock, flags);
 -
 -	cmd = NULL;
 -
 -	list_for_each_entry_safe(cmd, tcmd, &free_list, cmd_list) {
 -		list_del(&cmd->cmd_list);
 -		/* This cmd was never sent to TCM.  There is no need
 -		 * to schedule free or call free_cmd
 -		 */
 -		qlt_free_cmd(cmd);
 -	}
 -	return rc;
 -}
 -
 -static void
 -qlt_send_busy(struct scsi_qla_host *vha,
 -	struct atio_from_isp *atio, uint16_t status)
 -{
 -	int rc = 0;
 -
 -	rc = __qlt_send_busy(vha, atio, status);
 -	if (rc == -ENOMEM)
 -		qlt_alloc_qfull_cmd(vha, atio, status, 1);
 -}
 -
 -static int
 -qlt_chk_qfull_thresh_hold(struct scsi_qla_host *vha,
 -	struct atio_from_isp *atio, bool ha_locked)
 -{
 -	struct qla_hw_data *ha = vha->hw;
 -	uint16_t status;
 -	unsigned long flags;
 -
 -	if (ha->tgt.num_pend_cmds < Q_FULL_THRESH_HOLD(ha))
 -		return 0;
 -
 -	if (!ha_locked)
 -		spin_lock_irqsave(&ha->hardware_lock, flags);
 -	status = temp_sam_status;
 -	qlt_send_busy(vha, atio, status);
 -	if (!ha_locked)
 -		spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +	pkt->entry_count = 1;
 +	pkt->handle = QLA_TGT_SKIP_HANDLE | CTIO_COMPLETION_HANDLE_MARK;
  
 -	return 1;
 +	ctio24 = (struct ctio7_to_24xx *)pkt;
 +	ctio24->entry_type = CTIO_TYPE7;
 +	ctio24->nport_handle = sess->loop_id;
 +	ctio24->timeout = cpu_to_le16(QLA_TGT_TIMEOUT);
 +	ctio24->vp_index = vha->vp_idx;
 +	ctio24->initiator_id[0] = atio->u.isp24.fcp_hdr.s_id[2];
 +	ctio24->initiator_id[1] = atio->u.isp24.fcp_hdr.s_id[1];
 +	ctio24->initiator_id[2] = atio->u.isp24.fcp_hdr.s_id[0];
 +	ctio24->exchange_addr = atio->u.isp24.exchange_addr;
- 	ctio24->u.status1.flags = (atio->u.isp24.attr << 9) |
- 	    cpu_to_le16(
++	temp = (atio->u.isp24.attr << 9) |
 +		CTIO7_FLAGS_STATUS_MODE_1 | CTIO7_FLAGS_SEND_STATUS |
- 		CTIO7_FLAGS_DONT_RET_CTIO);
++		CTIO7_FLAGS_DONT_RET_CTIO;
++	ctio24->u.status1.flags = cpu_to_le16(temp);
 +	/*
 +	 * CTIO from fw w/o se_cmd doesn't provide enough info to retry it,
 +	 * if the explicit conformation is used.
 +	 */
 +	ctio24->u.status1.ox_id = swab16(atio->u.isp24.fcp_hdr.ox_id);
 +	ctio24->u.status1.scsi_status = cpu_to_le16(status);
 +	/* Memory Barrier */
 +	wmb();
 +	qla2x00_start_iocbs(vha, vha->req);
  }
  
  /* ha->hardware_lock supposed to be held on entry */
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
diff --git a/drivers/scsi/qla2xxx/qla_target.h b/drivers/scsi/qla2xxx/qla_target.h
index b33e411f28a0..afe602720669 100644
--- a/drivers/scsi/qla2xxx/qla_target.h
+++ b/drivers/scsi/qla2xxx/qla_target.h
@@ -455,7 +455,7 @@ struct ctio7_to_24xx {
 		} status0;
 		struct {
 			uint16_t sense_length;
-			uint16_t flags;
+			__le16 flags;
 			uint32_t residual;
 			uint16_t ox_id;
 			uint16_t scsi_status;
