device-dax, tools/testing/nvdimm: enable device-dax with mock resources

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Dave Jiang <dave.jiang@intel.com>
commit efebc711180f7fed701f6e23f23814fcfda7fbfc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/efebc711.failed

Provide a replacement pgoff_to_phys() that translates an nfit_test
resource (allocated by vmalloc()) to a pfn.

	Signed-off-by: Dave Jiang <dave.jiang@intel.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit efebc711180f7fed701f6e23f23814fcfda7fbfc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dax/dax.c
diff --cc drivers/dax/dax.c
index 5e37741e7a4f,ef93aa84622b..000000000000
--- a/drivers/dax/dax.c
+++ b/drivers/dax/dax.c
@@@ -22,8 -22,7 +22,12 @@@
  #include <linux/dax.h>
  #include <linux/fs.h>
  #include <linux/mm.h>
++<<<<<<< HEAD
 +#include <linux/idr.h>
 +#include <linux/magic.h>
++=======
+ #include "dax-private.h"
++>>>>>>> efebc711180f (device-dax, tools/testing/nvdimm: enable device-dax with mock resources)
  #include "dax.h"
  
  static dev_t dax_devt;
@@@ -36,48 -36,6 +40,51 @@@ static struct kmem_cache *dax_cache __r
  static struct super_block *dax_superblock __read_mostly;
  MODULE_PARM_DESC(nr_dax, "max number of device-dax instances");
  
++<<<<<<< HEAD
 +/**
 + * struct dax_region - mapping infrastructure for dax devices
 + * @id: kernel-wide unique region for a memory range
 + * @base: linear address corresponding to @res
 + * @kref: to pin while other agents have a need to do lookups
 + * @dev: parent device backing this region
 + * @align: allocation and mapping alignment for child dax devices
 + * @res: physical address range of the region
 + * @pfn_flags: identify whether the pfns are paged back or not
 + */
 +struct dax_region {
 +	int id;
 +	struct ida ida;
 +	void *base;
 +	struct kref kref;
 +	struct device *dev;
 +	unsigned int align;
 +	struct resource res;
 +	unsigned long pfn_flags;
 +};
 +
 +/**
 + * struct dax_dev - subdivision of a dax region
 + * @region - parent region
 + * @dev - device backing the character device
 + * @cdev - core chardev data
 + * @alive - !alive + rcu grace period == no new mappings can be established
 + * @id - child id in the region
 + * @num_resources - number of physical address extents in this device
 + * @res - array of physical address ranges
 + */
 +struct dax_dev {
 +	struct dax_region *region;
 +	struct inode *inode;
 +	struct device dev;
 +	struct cdev cdev;
 +	bool alive;
 +	int id;
 +	int num_resources;
 +	struct resource res[0];
 +};
 +
++=======
++>>>>>>> efebc711180f (device-dax, tools/testing/nvdimm: enable device-dax with mock resources)
  static ssize_t id_show(struct device *dev,
  		struct device_attribute *attr, char *buf)
  {
@@@ -519,12 -452,12 +527,17 @@@ static int __dax_dev_pmd_fault(struct d
  		return VM_FAULT_FALLBACK;
  
  	/* if we are outside of the VMA */
 -	if (pmd_addr < vmf->vma->vm_start ||
 -			(pmd_addr + PMD_SIZE) > vmf->vma->vm_end)
 +	if (pmd_addr < vma->vm_start ||
 +			(pmd_addr + PMD_SIZE) > vma->vm_end)
  		return VM_FAULT_SIGBUS;
  
++<<<<<<< HEAD
 +	pgoff = linear_page_index(vma, pmd_addr);
 +	phys = pgoff_to_phys(dax_dev, pgoff, PMD_SIZE);
++=======
+ 	pgoff = linear_page_index(vmf->vma, pmd_addr);
+ 	phys = dax_pgoff_to_phys(dax_dev, pgoff, PMD_SIZE);
++>>>>>>> efebc711180f (device-dax, tools/testing/nvdimm: enable device-dax with mock resources)
  	if (phys == -1) {
  		dev_dbg(dev, "%s: pgoff_to_phys(%#lx) failed\n", __func__,
  				pgoff);
@@@ -533,15 -466,72 +546,77 @@@
  
  	pfn = phys_to_pfn_t(phys, dax_region->pfn_flags);
  
 -	return vmf_insert_pfn_pmd(vmf->vma, vmf->address, vmf->pmd, pfn,
 -			vmf->flags & FAULT_FLAG_WRITE);
 +	return vmf_insert_pfn_pmd(vma, addr, pmd, pfn,
 +			flags & FAULT_FLAG_WRITE);
  }
  
 -#ifdef CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD
 -static int __dax_dev_pud_fault(struct dax_dev *dax_dev, struct vm_fault *vmf)
 +static int dax_dev_pmd_fault(struct vm_area_struct *vma, unsigned long addr,
 +		pmd_t *pmd, unsigned int flags)
  {
++<<<<<<< HEAD
 +	int rc;
 +	struct file *filp = vma->vm_file;
++=======
+ 	unsigned long pud_addr = vmf->address & PUD_MASK;
+ 	struct device *dev = &dax_dev->dev;
+ 	struct dax_region *dax_region;
+ 	phys_addr_t phys;
+ 	pgoff_t pgoff;
+ 	pfn_t pfn;
+ 	unsigned int fault_size = PUD_SIZE;
+ 
+ 
+ 	if (check_vma(dax_dev, vmf->vma, __func__))
+ 		return VM_FAULT_SIGBUS;
+ 
+ 	dax_region = dax_dev->region;
+ 	if (dax_region->align > PUD_SIZE) {
+ 		dev_dbg(dev, "%s: alignment > fault size\n", __func__);
+ 		return VM_FAULT_SIGBUS;
+ 	}
+ 
+ 	/* dax pud mappings require pfn_t_devmap() */
+ 	if ((dax_region->pfn_flags & (PFN_DEV|PFN_MAP)) != (PFN_DEV|PFN_MAP)) {
+ 		dev_dbg(dev, "%s: alignment > fault size\n", __func__);
+ 		return VM_FAULT_SIGBUS;
+ 	}
+ 
+ 	if (fault_size < dax_region->align)
+ 		return VM_FAULT_SIGBUS;
+ 	else if (fault_size > dax_region->align)
+ 		return VM_FAULT_FALLBACK;
+ 
+ 	/* if we are outside of the VMA */
+ 	if (pud_addr < vmf->vma->vm_start ||
+ 			(pud_addr + PUD_SIZE) > vmf->vma->vm_end)
+ 		return VM_FAULT_SIGBUS;
+ 
+ 	pgoff = linear_page_index(vmf->vma, pud_addr);
+ 	phys = dax_pgoff_to_phys(dax_dev, pgoff, PUD_SIZE);
+ 	if (phys == -1) {
+ 		dev_dbg(dev, "%s: pgoff_to_phys(%#lx) failed\n", __func__,
+ 				pgoff);
+ 		return VM_FAULT_SIGBUS;
+ 	}
+ 
+ 	pfn = phys_to_pfn_t(phys, dax_region->pfn_flags);
+ 
+ 	return vmf_insert_pfn_pud(vmf->vma, vmf->address, vmf->pud, pfn,
+ 			vmf->flags & FAULT_FLAG_WRITE);
+ }
+ #else
+ static int __dax_dev_pud_fault(struct dax_dev *dax_dev, struct vm_fault *vmf)
+ {
+ 	return VM_FAULT_FALLBACK;
+ }
+ #endif /* !CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD */
+ 
+ static int dax_dev_huge_fault(struct vm_fault *vmf,
+ 		enum page_entry_size pe_size)
+ {
+ 	int rc, id;
+ 	struct file *filp = vmf->vma->vm_file;
++>>>>>>> efebc711180f (device-dax, tools/testing/nvdimm: enable device-dax with mock resources)
  	struct dax_dev *dax_dev = filp->private_data;
  
  	dev_dbg(&dax_dev->dev, "%s: %s: %s (%#lx - %#lx)\n", __func__,
diff --git a/drivers/dax/dax-private.h b/drivers/dax/dax-private.h
new file mode 100644
index 000000000000..b1cd7a8e5ab9
--- /dev/null
+++ b/drivers/dax/dax-private.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+#ifndef __DAX_PRIVATE_H__
+#define __DAX_PRIVATE_H__
+
+#include <linux/device.h>
+#include <linux/cdev.h>
+
+/**
+ * struct dax_region - mapping infrastructure for dax devices
+ * @id: kernel-wide unique region for a memory range
+ * @base: linear address corresponding to @res
+ * @kref: to pin while other agents have a need to do lookups
+ * @dev: parent device backing this region
+ * @align: allocation and mapping alignment for child dax devices
+ * @res: physical address range of the region
+ * @pfn_flags: identify whether the pfns are paged back or not
+ */
+struct dax_region {
+	int id;
+	struct ida ida;
+	void *base;
+	struct kref kref;
+	struct device *dev;
+	unsigned int align;
+	struct resource res;
+	unsigned long pfn_flags;
+};
+
+/**
+ * struct dax_dev - subdivision of a dax region
+ * @region - parent region
+ * @inode - inode
+ * @dev - device backing the character device
+ * @cdev - core chardev data
+ * @alive - !alive + srcu grace period == no new mappings can be established
+ * @id - child id in the region
+ * @num_resources - number of physical address extents in this device
+ * @res - array of physical address ranges
+ */
+struct dax_dev {
+	struct dax_region *region;
+	struct inode *inode;
+	struct device dev;
+	struct cdev cdev;
+	bool alive;
+	int id;
+	int num_resources;
+	struct resource res[0];
+};
+#endif
* Unmerged path drivers/dax/dax.c
diff --git a/tools/testing/nvdimm/Kbuild b/tools/testing/nvdimm/Kbuild
index 405212be044a..6dcb3c4d53be 100644
--- a/tools/testing/nvdimm/Kbuild
+++ b/tools/testing/nvdimm/Kbuild
@@ -28,7 +28,7 @@ obj-$(CONFIG_ND_BTT) += nd_btt.o
 obj-$(CONFIG_ND_BLK) += nd_blk.o
 obj-$(CONFIG_X86_PMEM_LEGACY) += nd_e820.o
 obj-$(CONFIG_ACPI_NFIT) += nfit.o
-obj-$(CONFIG_DEV_DAX) += dax.o
+obj-$(CONFIG_DEV_DAX) += dax.o dax-dev.o
 obj-$(CONFIG_DEV_DAX_PMEM) += dax_pmem.o
 
 nfit-y := $(ACPI_SRC)/core.o
@@ -49,6 +49,7 @@ nd_e820-y := $(NVDIMM_SRC)/e820.o
 nd_e820-y += config_check.o
 
 dax-y := $(DAX_SRC)/dax.o
+dax-y += dax-dev.o
 dax-y += config_check.o
 
 dax_pmem-y := $(DAX_SRC)/pmem.o
diff --git a/tools/testing/nvdimm/dax-dev.c b/tools/testing/nvdimm/dax-dev.c
new file mode 100644
index 000000000000..e89721d8924c
--- /dev/null
+++ b/tools/testing/nvdimm/dax-dev.c
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2016, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+#include "test/nfit_test.h"
+#include <linux/mm.h>
+#include "../../../drivers/dax/dax-private.h"
+
+phys_addr_t dax_pgoff_to_phys(struct dax_dev *dax_dev, pgoff_t pgoff,
+		unsigned long size)
+{
+	struct resource *res;
+	phys_addr_t addr;
+	int i;
+
+	for (i = 0; i < dax_dev->num_resources; i++) {
+		res = &dax_dev->res[i];
+		addr = pgoff * PAGE_SIZE + res->start;
+		if (addr >= res->start && addr <= res->end)
+			break;
+		pgoff -= PHYS_PFN(resource_size(res));
+	}
+
+	if (i < dax_dev->num_resources) {
+		res = &dax_dev->res[i];
+		if (addr + size - 1 <= res->end) {
+			if (get_nfit_res(addr)) {
+				struct page *page;
+
+				if (dax_dev->region->align > PAGE_SIZE)
+					return -1;
+
+				page = vmalloc_to_page((void *)addr);
+				return PFN_PHYS(page_to_pfn(page));
+			} else
+				return addr;
+		}
+	}
+
+	return -1;
+}
