l2tp: fix race condition in l2tp_tunnel_delete

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Sabrina Dubroca <sd@queasysnail.net>
commit 62b982eeb4589b2e6d7c01a90590e3a4c2b2ca19
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/62b982ee.failed

If we try to delete the same tunnel twice, the first delete operation
does a lookup (l2tp_tunnel_get), finds the tunnel, calls
l2tp_tunnel_delete, which queues it for deletion by
l2tp_tunnel_del_work.

The second delete operation also finds the tunnel and calls
l2tp_tunnel_delete. If the workqueue has already fired and started
running l2tp_tunnel_del_work, then l2tp_tunnel_delete will queue the
same tunnel a second time, and try to free the socket again.

Add a dead flag to prevent firing the workqueue twice. Then we can
remove the check of queue_work's result that was meant to prevent that
race but doesn't.

Reproducer:

    ip l2tp add tunnel tunnel_id 3000 peer_tunnel_id 4000 local 192.168.0.2 remote 192.168.0.1 encap udp udp_sport 5000 udp_dport 6000
    ip l2tp add session name l2tp1 tunnel_id 3000 session_id 1000 peer_session_id 2000
    ip link set l2tp1 up
    ip l2tp del tunnel tunnel_id 3000
    ip l2tp del tunnel tunnel_id 3000

Fixes: f8ccac0e4493 ("l2tp: put tunnel socket release on a workqueue")
	Reported-by: Jianlin Shi <jishi@redhat.com>
	Signed-off-by: Sabrina Dubroca <sd@queasysnail.net>
	Acked-by: Guillaume Nault <g.nault@alphalink.fr>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 62b982eeb4589b2e6d7c01a90590e3a4c2b2ca19)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/l2tp/l2tp_core.h
diff --cc net/l2tp/l2tp_core.h
index 0733c826b163,67c79d9b5c6c..000000000000
--- a/net/l2tp/l2tp_core.h
+++ b/net/l2tp/l2tp_core.h
@@@ -164,8 -161,15 +164,11 @@@ struct l2tp_tunnel_cfg 
  
  struct l2tp_tunnel {
  	int			magic;		/* Should be L2TP_TUNNEL_MAGIC */
+ 
+ 	unsigned long		dead;
+ 
  	struct rcu_head rcu;
  	rwlock_t		hlist_lock;	/* protect session_hlist */
 -	bool			acpt_newsess;	/* Indicates whether this
 -						 * tunnel accepts new sessions.
 -						 * Protected by hlist_lock.
 -						 */
  	struct hlist_head	session_hlist[L2TP_HASH_SIZE];
  						/* hashed list of sessions,
  						 * hashed by id */
@@@ -235,31 -241,57 +238,52 @@@ out
  	return tunnel;
  }
  
 -struct l2tp_tunnel *l2tp_tunnel_get(const struct net *net, u32 tunnel_id);
 -
 -struct l2tp_session *l2tp_session_get(const struct net *net,
 -				      struct l2tp_tunnel *tunnel,
 -				      u32 session_id, bool do_ref);
 -struct l2tp_session *l2tp_session_get_nth(struct l2tp_tunnel *tunnel, int nth,
 -					  bool do_ref);
 -struct l2tp_session *l2tp_session_get_by_ifname(const struct net *net,
 -						const char *ifname,
 -						bool do_ref);
 -struct l2tp_tunnel *l2tp_tunnel_find(const struct net *net, u32 tunnel_id);
 -struct l2tp_tunnel *l2tp_tunnel_find_nth(const struct net *net, int nth);
 -
 +extern struct sock *l2tp_tunnel_sock_lookup(struct l2tp_tunnel *tunnel);
 +extern void l2tp_tunnel_sock_put(struct sock *sk);
 +extern struct l2tp_session *l2tp_session_find(struct net *net, struct l2tp_tunnel *tunnel, u32 session_id);
 +extern struct l2tp_session *l2tp_session_find_nth(struct l2tp_tunnel *tunnel, int nth);
 +extern struct l2tp_session *l2tp_session_find_by_ifname(struct net *net, char *ifname);
 +extern struct l2tp_tunnel *l2tp_tunnel_find(struct net *net, u32 tunnel_id);
 +extern struct l2tp_tunnel *l2tp_tunnel_find_nth(struct net *net, int nth);
 +
 +extern int l2tp_tunnel_create(struct net *net, int fd, int version, u32 tunnel_id, u32 peer_tunnel_id, struct l2tp_tunnel_cfg *cfg, struct l2tp_tunnel **tunnelp);
 +extern void l2tp_tunnel_closeall(struct l2tp_tunnel *tunnel);
 +extern int l2tp_tunnel_delete(struct l2tp_tunnel *tunnel);
 +extern struct l2tp_session *l2tp_session_create(int priv_size, struct l2tp_tunnel *tunnel, u32 session_id, u32 peer_session_id, struct l2tp_session_cfg *cfg);
 +extern void __l2tp_session_unhash(struct l2tp_session *session);
 +extern int l2tp_session_delete(struct l2tp_session *session);
 +extern void l2tp_session_free(struct l2tp_session *session);
 +extern void l2tp_recv_common(struct l2tp_session *session, struct sk_buff *skb, unsigned char *ptr, unsigned char *optr, u16 hdrflags, int length, int (*payload_hook)(struct sk_buff *skb));
 +extern int l2tp_session_queue_purge(struct l2tp_session *session);
 +extern int l2tp_udp_encap_recv(struct sock *sk, struct sk_buff *skb);
 +
++<<<<<<< HEAD
 +extern int l2tp_xmit_skb(struct l2tp_session *session, struct sk_buff *skb, int hdr_len);
++=======
+ int l2tp_tunnel_create(struct net *net, int fd, int version, u32 tunnel_id,
+ 		       u32 peer_tunnel_id, struct l2tp_tunnel_cfg *cfg,
+ 		       struct l2tp_tunnel **tunnelp);
+ void l2tp_tunnel_closeall(struct l2tp_tunnel *tunnel);
+ void l2tp_tunnel_delete(struct l2tp_tunnel *tunnel);
+ struct l2tp_session *l2tp_session_create(int priv_size,
+ 					 struct l2tp_tunnel *tunnel,
+ 					 u32 session_id, u32 peer_session_id,
+ 					 struct l2tp_session_cfg *cfg);
+ void __l2tp_session_unhash(struct l2tp_session *session);
+ int l2tp_session_delete(struct l2tp_session *session);
+ void l2tp_session_free(struct l2tp_session *session);
+ void l2tp_recv_common(struct l2tp_session *session, struct sk_buff *skb,
+ 		      unsigned char *ptr, unsigned char *optr, u16 hdrflags,
+ 		      int length, int (*payload_hook)(struct sk_buff *skb));
+ int l2tp_session_queue_purge(struct l2tp_session *session);
+ int l2tp_udp_encap_recv(struct sock *sk, struct sk_buff *skb);
+ void l2tp_session_set_header_len(struct l2tp_session *session, int version);
++>>>>>>> 62b982eeb458 (l2tp: fix race condition in l2tp_tunnel_delete)
  
 -int l2tp_xmit_skb(struct l2tp_session *session, struct sk_buff *skb,
 -		  int hdr_len);
 -
 -int l2tp_nl_register_ops(enum l2tp_pwtype pw_type,
 -			 const struct l2tp_nl_cmd_ops *ops);
 -void l2tp_nl_unregister_ops(enum l2tp_pwtype pw_type);
 +extern int l2tp_nl_register_ops(enum l2tp_pwtype pw_type, const struct l2tp_nl_cmd_ops *ops);
 +extern void l2tp_nl_unregister_ops(enum l2tp_pwtype pw_type);
  int l2tp_ioctl(struct sock *sk, int cmd, unsigned long arg);
  
 -static inline void l2tp_tunnel_inc_refcount(struct l2tp_tunnel *tunnel)
 -{
 -	refcount_inc(&tunnel->ref_count);
 -}
 -
 -static inline void l2tp_tunnel_dec_refcount(struct l2tp_tunnel *tunnel)
 -{
 -	if (refcount_dec_and_test(&tunnel->ref_count))
 -		kfree_rcu(tunnel, rcu);
 -}
 -
  /* Session reference counts. Incremented when code obtains a reference
   * to a session.
   */
diff --git a/net/l2tp/l2tp_core.c b/net/l2tp/l2tp_core.c
index 0968b39152ba..b00199da67bb 100644
--- a/net/l2tp/l2tp_core.c
+++ b/net/l2tp/l2tp_core.c
@@ -1686,14 +1686,12 @@ EXPORT_SYMBOL_GPL(l2tp_tunnel_create);
 
 /* This function is used by the netlink TUNNEL_DELETE command.
  */
-int l2tp_tunnel_delete(struct l2tp_tunnel *tunnel)
+void l2tp_tunnel_delete(struct l2tp_tunnel *tunnel)
 {
-	l2tp_tunnel_inc_refcount(tunnel);
-	if (false == queue_work(l2tp_wq, &tunnel->del_work)) {
-		l2tp_tunnel_dec_refcount(tunnel);
-		return 1;
+	if (!test_and_set_bit(0, &tunnel->dead)) {
+		l2tp_tunnel_inc_refcount(tunnel);
+		queue_work(l2tp_wq, &tunnel->del_work);
 	}
-	return 0;
 }
 EXPORT_SYMBOL_GPL(l2tp_tunnel_delete);
 
* Unmerged path net/l2tp/l2tp_core.h
