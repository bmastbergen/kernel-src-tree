xfs: split xfs_free_file_space in manageable pieces

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Christoph Hellwig <hch@lst.de>
commit bdb0d04fa66d8d02219ca7c027adf810dd75e9e4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/bdb0d04f.failed

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>


(cherry picked from commit bdb0d04fa66d8d02219ca7c027adf810dd75e9e4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_bmap_util.c
diff --cc fs/xfs/xfs_bmap_util.c
index ca1e394cb781,e36664fc5715..000000000000
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@@ -1207,60 -1317,30 +1309,45 @@@ xfs_free_file_space
  	if (error)
  		return error;
  
- 	error = 0;
  	if (len <= 0)	/* if nothing being freed */
+ 		return 0;
+ 
+ 	error = xfs_flush_unmap_range(ip, offset, len);
+ 	if (error)
  		return error;
- 	rt = XFS_IS_REALTIME_INODE(ip);
- 	startoffset_fsb	= XFS_B_TO_FSB(mp, offset);
+ 
+ 	startoffset_fsb = XFS_B_TO_FSB(mp, offset);
  	endoffset_fsb = XFS_B_TO_FSBT(mp, offset + len);
  
++<<<<<<< HEAD
 +	/* wait for the completion of any pending DIOs */
 +	inode_dio_wait(VFS_I(ip));
 +
 +	rounding = max_t(xfs_off_t, 1 << mp->m_sb.sb_blocklog, PAGE_CACHE_SIZE);
 +	ioffset = round_down(offset, rounding);
 +	iendoffset = round_up(offset + len, rounding) - 1;
 +	error = filemap_write_and_wait_range(VFS_I(ip)->i_mapping, ioffset,
 +					     iendoffset);
 +	if (error)
 +		goto out;
 +	truncate_pagecache_range(VFS_I(ip), ioffset, iendoffset);
 +
++=======
++>>>>>>> bdb0d04fa66d (xfs: split xfs_free_file_space in manageable pieces)
  	/*
- 	 * Need to zero the stuff we're not freeing, on disk.
- 	 * If it's a realtime file & can't use unwritten extents then we
- 	 * actually need to zero the extent edges.  Otherwise xfs_bunmapi
- 	 * will take care of it for us.
+ 	 * Need to zero the stuff we're not freeing, on disk.  If it's a RT file
+ 	 * and we can't use unwritten extents then we actually need to ensure
+ 	 * to zero the whole extent, otherwise we just need to take of block
+ 	 * boundaries, and xfs_bunmapi will handle the rest.
  	 */
- 	if (rt && !xfs_sb_version_hasextflgbit(&mp->m_sb)) {
- 		nimap = 1;
- 		error = xfs_bmapi_read(ip, startoffset_fsb, 1,
- 					&imap, &nimap, 0);
+ 	if (XFS_IS_REALTIME_INODE(ip) &&
+ 	    !xfs_sb_version_hasextflgbit(&mp->m_sb)) {
+ 		error = xfs_adjust_extent_unmap_boundaries(ip, &startoffset_fsb,
+ 				&endoffset_fsb);
  		if (error)
- 			goto out;
- 		ASSERT(nimap == 0 || nimap == 1);
- 		if (nimap && imap.br_startblock != HOLESTARTBLOCK) {
- 			xfs_daddr_t	block;
- 
- 			ASSERT(imap.br_startblock != DELAYSTARTBLOCK);
- 			block = imap.br_startblock;
- 			mod = do_div(block, mp->m_sb.sb_rextsize);
- 			if (mod)
- 				startoffset_fsb += mp->m_sb.sb_rextsize - mod;
- 		}
- 		nimap = 1;
- 		error = xfs_bmapi_read(ip, endoffset_fsb - 1, 1,
- 					&imap, &nimap, 0);
- 		if (error)
- 			goto out;
- 		ASSERT(nimap == 0 || nimap == 1);
- 		if (nimap && imap.br_startblock != HOLESTARTBLOCK) {
- 			ASSERT(imap.br_startblock != DELAYSTARTBLOCK);
- 			mod++;
- 			if (mod && (mod != mp->m_sb.sb_rextsize))
- 				endoffset_fsb -= mod;
- 		}
+ 			return error;
  	}
+ 
  	if ((done = (endoffset_fsb <= startoffset_fsb)))
  		/*
  		 * One contiguous piece to clear
* Unmerged path fs/xfs/xfs_bmap_util.c
