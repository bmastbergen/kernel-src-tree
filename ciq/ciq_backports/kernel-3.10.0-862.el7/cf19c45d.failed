scsi: qla2xxx: Add command completion for error path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Add command completion for error path (Himanshu Madhani) [1316281]
Rebuild_FUZZ: 93.88%
commit-author Duane Grigsby <duane.grigsby@cavium.com>
commit cf19c45dba19757e5016cb1acc5ef1529005f8c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/cf19c45d.failed

The driver held spinlocks during callbacks for NVME errors which
resulted in a deadlock because recovery LS cmds needed the same lock.

	Signed-off-by: Duane Grigsby <duane.grigsby@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit cf19c45dba19757e5016cb1acc5ef1529005f8c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_init.c
#	drivers/scsi/qla2xxx/qla_nvme.c
#	drivers/scsi/qla2xxx/qla_os.c
diff --cc drivers/scsi/qla2xxx/qla_def.h
index 3f28536dc812,e3b225cc83f2..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -363,6 -399,36 +363,39 @@@ struct srb_iocb 
  			__le16 comp_status;
  			struct completion comp;
  		} abt;
++<<<<<<< HEAD
++=======
+ 		struct ct_arg ctarg;
+ #define MAX_IOCB_MB_REG 28
+ #define SIZEOF_IOCB_MB_REG (MAX_IOCB_MB_REG * sizeof(uint16_t))
+ 		struct {
+ 			__le16 in_mb[MAX_IOCB_MB_REG];	/* from FW */
+ 			__le16 out_mb[MAX_IOCB_MB_REG];	/* to FW */
+ 			void *out, *in;
+ 			dma_addr_t out_dma, in_dma;
+ 			struct completion comp;
+ 			int rc;
+ 		} mbx;
+ 		struct {
+ 			struct imm_ntfy_from_isp *ntfy;
+ 		} nack;
+ 		struct {
+ 			__le16 comp_status;
+ 			uint16_t rsp_pyld_len;
+ 			uint8_t	aen_op;
+ 			void *desc;
+ 
+ 			/* These are only used with ls4 requests */
+ 			int cmd_len;
+ 			int rsp_len;
+ 			dma_addr_t cmd_dma;
+ 			dma_addr_t rsp_dma;
+ 			enum nvmefc_fcp_datadir dir;
+ 			uint32_t dl;
+ 			uint32_t timeout_sec;
+ 			struct	list_head   entry;
+ 		} nvme;
++>>>>>>> cf19c45dba19 (scsi: qla2xxx: Add command completion for error path)
  	} u;
  
  	struct timer_list timer;
@@@ -2919,13 -3338,10 +2952,20 @@@ struct qla_qpair 
  	struct qla_hw_data *hw;
  	struct work_struct q_work;
  	struct list_head qp_list_elem; /* vha->qp_list */
++<<<<<<< HEAD
 +};
 +
 +struct qla_percpu_qp_hint {
 +	int change_in_progress;
 +	struct qla_qpair *qp;
 +	int redirect_to_cpuid;
 +	struct qla_qpair *alternate_qp;
++=======
+ 	struct list_head hints_list;
+ 	struct list_head nvme_done_list;
+ 	uint16_t cpuid;
+ 	struct qla_tgt_counters tgt_counters;
++>>>>>>> cf19c45dba19 (scsi: qla2xxx: Add command completion for error path)
  };
  
  /* Place holder for FW buffer parameters */
diff --cc drivers/scsi/qla2xxx/qla_init.c
index 998b579c233c,988fb5d0f9e7..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -6667,6 -7804,13 +6667,16 @@@ struct qla_qpair *qla2xxx_create_qpair(
  		ha->queue_pair_map[qpair_id] = qpair;
  		qpair->id = qpair_id;
  		qpair->vp_idx = vp_idx;
++<<<<<<< HEAD
++=======
+ 		qpair->fw_started = ha->flags.fw_started;
+ 		INIT_LIST_HEAD(&qpair->hints_list);
+ 		INIT_LIST_HEAD(&qpair->nvme_done_list);
+ 		qpair->chip_reset = ha->base_qpair->chip_reset;
+ 		qpair->enable_class_2 = ha->base_qpair->enable_class_2;
+ 		qpair->enable_explicit_conf =
+ 		    ha->base_qpair->enable_explicit_conf;
++>>>>>>> cf19c45dba19 (scsi: qla2xxx: Add command completion for error path)
  
  		for (i = 0; i < ha->msix_count; i++) {
  			msix = &ha->msix_entries[i];
diff --cc drivers/scsi/qla2xxx/qla_os.c
index c724f888aca6,b43520ca6645..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -327,6 -366,29 +327,32 @@@ int qla2xxx_mqueuecommand(struct Scsi_H
  	struct qla_qpair *qpair);
  
  /* -------------------------------------------------------------------------- */
++<<<<<<< HEAD
++=======
+ static void qla_init_base_qpair(struct scsi_qla_host *vha, struct req_que *req,
+     struct rsp_que *rsp)
+ {
+ 	struct qla_hw_data *ha = vha->hw;
+ 	rsp->qpair = ha->base_qpair;
+ 	rsp->req = req;
+ 	ha->base_qpair->req = req;
+ 	ha->base_qpair->rsp = rsp;
+ 	ha->base_qpair->vha = vha;
+ 	ha->base_qpair->qp_lock_ptr = &ha->hardware_lock;
+ 	ha->base_qpair->use_shadow_reg = IS_SHADOW_REG_CAPABLE(ha) ? 1 : 0;
+ 	ha->base_qpair->msix = &ha->msix_entries[QLA_MSIX_RSP_Q];
+ 	INIT_LIST_HEAD(&ha->base_qpair->hints_list);
+ 	INIT_LIST_HEAD(&ha->base_qpair->nvme_done_list);
+ 	ha->base_qpair->enable_class_2 = ql2xenableclass2;
+ 	/* init qpair to this cpu. Will adjust at run time. */
+ 	qla_cpu_update(rsp->qpair, smp_processor_id());
+ 	ha->base_qpair->pdev = ha->pdev;
+ 
+ 	if (IS_QLA27XX(ha) || IS_QLA83XX(ha))
+ 		ha->base_qpair->reqq_start_iocbs = qla_83xx_start_iocbs;
+ }
+ 
++>>>>>>> cf19c45dba19 (scsi: qla2xxx: Add command completion for error path)
  static int qla2x00_alloc_queues(struct qla_hw_data *ha, struct req_que *req,
  				struct rsp_que *rsp)
  {
* Unmerged path drivers/scsi/qla2xxx/qla_nvme.c
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
diff --git a/drivers/scsi/qla2xxx/qla_gbl.h b/drivers/scsi/qla2xxx/qla_gbl.h
index c4f068539cd6..4733f7e2bc8f 100644
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@ -782,4 +782,6 @@ extern void qla82xx_mbx_completion(scsi_qla_host_t *, uint16_t);
 extern int qla8044_abort_isp(scsi_qla_host_t *);
 extern int qla8044_check_fw_alive(struct scsi_qla_host *);
 
+void qla_nvme_cmpl_io(struct srb_iocb *);
+
 #endif /* _QLA_GBL_H */
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
diff --git a/drivers/scsi/qla2xxx/qla_mid.c b/drivers/scsi/qla2xxx/qla_mid.c
index 51bc5f02bfb6..1e82fb6b6f69 100644
--- a/drivers/scsi/qla2xxx/qla_mid.c
+++ b/drivers/scsi/qla2xxx/qla_mid.c
@@ -759,11 +759,18 @@ static void qla_do_work(struct work_struct *work)
 	struct qla_qpair *qpair = container_of(work, struct qla_qpair, q_work);
 	struct scsi_qla_host *vha;
 	struct qla_hw_data *ha = qpair->hw;
+	struct srb_iocb	*nvme, *nxt_nvme;
 
 	spin_lock_irqsave(&qpair->qp_lock, flags);
 	vha = pci_get_drvdata(ha->pdev);
 	qla24xx_process_response_queue(vha, qpair->rsp);
 	spin_unlock_irqrestore(&qpair->qp_lock, flags);
+
+	list_for_each_entry_safe(nvme, nxt_nvme, &qpair->nvme_done_list,
+		    u.nvme.entry) {
+		list_del_init(&nvme->u.nvme.entry);
+		qla_nvme_cmpl_io(nvme);
+	}
 }
 
 /* create response queue */
* Unmerged path drivers/scsi/qla2xxx/qla_nvme.c
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
