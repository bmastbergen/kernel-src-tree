md: fix test in md_write_start()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [md] fix test in md_write_start() (Nigel Croxon) [1506338]
Rebuild_FUZZ: 93.33%
commit-author NeilBrown <neilb@suse.com>
commit 81fe48e9aa00bdd509bd3c37a76d1132da6b9f09
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/81fe48e9.failed

md_write_start() needs to clear the in_sync flag is it is set, or if
there might be a race with set_in_sync() such that the later will
set it very soon.  In the later case it is sufficient to take the
spinlock to synchronize with set_in_sync(), and then set the flag
if needed.

The current test is incorrect.
It should be:
  if "flag is set" or "race is possible"

"flag is set" is trivially "mddev->in_sync".
"race is possible" should be tested by "mddev->sync_checkers".

If sync_checkers is 0, then there can be no race.  set_in_sync() will
wait in percpu_ref_switch_to_atomic_sync() for an RCU grace period,
and as md_write_start() holds the rcu_read_lock(), set_in_sync() will
be sure ot see the update to writes_pending.

If sync_checkers is > 0, there could be race.  If md_write_start()
happened entirely between
		if (!mddev->in_sync &&
		    percpu_ref_is_zero(&mddev->writes_pending)) {
and
			mddev->in_sync = 1;
in set_in_sync(), then it would not see that is_sync had been set,
and set_in_sync() would not see that writes_pending had been
incremented.

This bug means that in_sync is sometimes not set when it should be.
Consequently there is a small chance that the array will be marked as
"clean" when in fact it is inconsistent.

Fixes: 4ad23a976413 ("MD: use per-cpu counter for writes_pending")
cc: stable@vger.kernel.org (v4.12+)
	Signed-off-by: NeilBrown <neilb@suse.com>
	Signed-off-by: Shaohua Li <shli@fb.com>
(cherry picked from commit 81fe48e9aa00bdd509bd3c37a76d1132da6b9f09)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/md.c
diff --cc drivers/md/md.c
index 4c75b0e4a2a4,e4ba95f6cd59..000000000000
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@@ -7692,10 -7990,13 +7692,15 @@@ bool md_write_start(struct mddev *mddev
  		md_wakeup_thread(mddev->sync_thread);
  		did_change = 1;
  	}
 -	rcu_read_lock();
 -	percpu_ref_get(&mddev->writes_pending);
 -	smp_mb(); /* Match smp_mb in set_in_sync() */
 +	atomic_inc(&mddev->writes_pending);
  	if (mddev->safemode == 1)
  		mddev->safemode = 0;
++<<<<<<< HEAD
 +	if (mddev->in_sync) {
++=======
+ 	/* sync_checkers is always 0 when writes_pending is in per-cpu mode */
+ 	if (mddev->in_sync || mddev->sync_checkers) {
++>>>>>>> 81fe48e9aa00 (md: fix test in md_write_start())
  		spin_lock(&mddev->lock);
  		if (mddev->in_sync) {
  			mddev->in_sync = 0;
* Unmerged path drivers/md/md.c
