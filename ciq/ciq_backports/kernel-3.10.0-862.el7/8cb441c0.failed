libceph: MOSDOp v8 encoding (actual spgid + full hash)

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ilya Dryomov <idryomov@gmail.com>
commit 8cb441c0545dfd4dafeedc1e2d7157e1072413ac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8cb441c0.failed

	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit 8cb441c0545dfd4dafeedc1e2d7157e1072413ac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ceph/osd_client.c
diff --cc net/ceph/osd_client.c
index b6711b267e1a,eaaf17e7c37b..000000000000
--- a/net/ceph/osd_client.c
+++ b/net/ceph/osd_client.c
@@@ -545,12 -553,18 +546,24 @@@ int ceph_osdc_alloc_messages(struct cep
  	int msg_size;
  
  	WARN_ON(ceph_oid_empty(&req->r_base_oid));
 -	WARN_ON(ceph_oloc_empty(&req->r_base_oloc));
  
  	/* create request message */
++<<<<<<< HEAD
 +	msg_size = 4 + 4 + 4; /* client_inc, osdmap_epoch, flags */
 +	msg_size += 4 + 4 + 4 + 8; /* mtime, reassert_version */
 +	msg_size += 2 + 4 + 8 + 4 + 4; /* oloc */
 +	msg_size += 1 + 8 + 4 + 4; /* pgid */
++=======
+ 	msg_size = CEPH_ENCODING_START_BLK_LEN +
+ 			CEPH_PGID_ENCODING_LEN + 1; /* spgid */
+ 	msg_size += 4 + 4 + 4; /* hash, osdmap_epoch, flags */
+ 	msg_size += CEPH_ENCODING_START_BLK_LEN +
+ 			sizeof(struct ceph_osd_reqid); /* reqid */
+ 	msg_size += sizeof(struct ceph_blkin_trace_info); /* trace */
+ 	msg_size += 4 + sizeof(struct ceph_timespec); /* client_inc, mtime */
+ 	msg_size += CEPH_ENCODING_START_BLK_LEN +
+ 			ceph_oloc_encoding_size(&req->r_base_oloc); /* oloc */
++>>>>>>> 8cb441c0545d (libceph: MOSDOp v8 encoding (actual spgid + full hash))
  	msg_size += 4 + req->r_base_oid.name_len; /* oid */
  	msg_size += 2 + req->r_num_ops * sizeof(struct ceph_osd_op);
  	msg_size += 8; /* snapid */
@@@ -1475,7 -1490,37 +1488,41 @@@ static void setup_request_data(struct c
  	WARN_ON(data_len != msg->data_length);
  }
  
++<<<<<<< HEAD
 +static void encode_request(struct ceph_osd_request *req, struct ceph_msg *msg)
++=======
+ static void encode_pgid(void **p, const struct ceph_pg *pgid)
+ {
+ 	ceph_encode_8(p, 1);
+ 	ceph_encode_64(p, pgid->pool);
+ 	ceph_encode_32(p, pgid->seed);
+ 	ceph_encode_32(p, -1); /* preferred */
+ }
+ 
+ static void encode_spgid(void **p, const struct ceph_spg *spgid)
+ {
+ 	ceph_start_encoding(p, 1, 1, CEPH_PGID_ENCODING_LEN + 1);
+ 	encode_pgid(p, &spgid->pgid);
+ 	ceph_encode_8(p, spgid->shard);
+ }
+ 
+ static void encode_oloc(void **p, void *end,
+ 			const struct ceph_object_locator *oloc)
+ {
+ 	ceph_start_encoding(p, 5, 4, ceph_oloc_encoding_size(oloc));
+ 	ceph_encode_64(p, oloc->pool);
+ 	ceph_encode_32(p, -1); /* preferred */
+ 	ceph_encode_32(p, 0);  /* key len */
+ 	if (oloc->pool_ns)
+ 		ceph_encode_string(p, end, oloc->pool_ns->str,
+ 				   oloc->pool_ns->len);
+ 	else
+ 		ceph_encode_32(p, 0);
+ }
+ 
+ static void encode_request_partial(struct ceph_osd_request *req,
+ 				   struct ceph_msg *msg)
++>>>>>>> 8cb441c0545d (libceph: MOSDOp v8 encoding (actual spgid + full hash))
  {
  	void *p = msg->front.iov_base;
  	void *const end = p + msg->front_alloc_len;
@@@ -1498,28 -1555,9 +1557,34 @@@
  	ceph_encode_timespec(p, &req->r_mtime);
  	p += sizeof(struct ceph_timespec);
  
++<<<<<<< HEAD
 +	/* reassert_version */
 +	memset(p, 0, sizeof(struct ceph_eversion));
 +	p += sizeof(struct ceph_eversion);
 +
 +	/* oloc */
 +	ceph_encode_8(&p, 4);
 +	ceph_encode_8(&p, 4);
 +	ceph_encode_32(&p, 8 + 4 + 4);
 +	ceph_encode_64(&p, req->r_t.target_oloc.pool);
 +	ceph_encode_32(&p, -1); /* preferred */
 +	ceph_encode_32(&p, 0); /* key len */
 +
 +	/* pgid */
 +	ceph_encode_8(&p, 1);
 +	ceph_encode_64(&p, req->r_t.pgid.pool);
 +	ceph_encode_32(&p, req->r_t.pgid.seed);
 +	ceph_encode_32(&p, -1); /* preferred */
 +
 +	/* oid */
 +	ceph_encode_32(&p, req->r_t.target_oid.name_len);
 +	memcpy(p, req->r_t.target_oid.name, req->r_t.target_oid.name_len);
 +	p += req->r_t.target_oid.name_len;
++=======
+ 	encode_oloc(&p, end, &req->r_t.target_oloc);
+ 	ceph_encode_string(&p, end, req->r_t.target_oid.name,
+ 			   req->r_t.target_oid.name_len);
++>>>>>>> 8cb441c0545d (libceph: MOSDOp v8 encoding (actual spgid + full hash))
  
  	/* ops, can imply data */
  	ceph_encode_16(&p, req->r_num_ops);
diff --git a/include/linux/ceph/osd_client.h b/include/linux/ceph/osd_client.h
index f2edb240e885..bccbb5614bdb 100644
--- a/include/linux/ceph/osd_client.h
+++ b/include/linux/ceph/osd_client.h
@@ -204,6 +204,23 @@ struct ceph_request_redirect {
 	struct ceph_object_locator oloc;
 };
 
+/*
+ * osd request identifier
+ *
+ * caller name + incarnation# + tid to unique identify this request
+ */
+struct ceph_osd_reqid {
+	struct ceph_entity_name name;
+	__le64 tid;
+	__le32 inc;
+} __packed;
+
+struct ceph_blkin_trace_info {
+	__le64 trace_id;
+	__le64 span_id;
+	__le64 parent_span_id;
+} __packed;
+
 typedef void (*rados_watchcb2_t)(void *arg, u64 notify_id, u64 cookie,
 				 u64 notifier_id, void *data, size_t data_len);
 typedef void (*rados_watcherrcb_t)(void *arg, u64 cookie, int err);
diff --git a/include/linux/ceph/osdmap.h b/include/linux/ceph/osdmap.h
index 5a79a7caf5db..39510f581b07 100644
--- a/include/linux/ceph/osdmap.h
+++ b/include/linux/ceph/osdmap.h
@@ -212,11 +212,13 @@ static inline struct ceph_entity_addr *ceph_osd_addr(struct ceph_osdmap *map,
 	return &map->osd_addr[osd];
 }
 
+#define CEPH_PGID_ENCODING_LEN		(1 + 8 + 4 + 4)
+
 static inline int ceph_decode_pgid(void **p, void *end, struct ceph_pg *pgid)
 {
 	__u8 version;
 
-	if (!ceph_has_room(p, end, 1 + 8 + 4 + 4)) {
+	if (!ceph_has_room(p, end, CEPH_PGID_ENCODING_LEN)) {
 		pr_warn("incomplete pg encoding\n");
 		return -EINVAL;
 	}
* Unmerged path net/ceph/osd_client.c
