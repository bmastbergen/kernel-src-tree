ovl: get exclusive ownership on upper/work dirs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 2cac0c00a6cdcc9121de150ed531f652396d1544
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2cac0c00.failed

Bad things can happen if several concurrent overlay mounts try to
use the same upperdir/workdir path.

Try to get the 'inuse' advisory lock on upperdir and workdir.
Fail mount if another overlay mount instance or another user
holds the 'inuse' lock on these directories.

Note that this provides no protection for concurrent overlay
mount that use overlapping (i.e. descendant) upper/work dirs.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 2cac0c00a6cdcc9121de150ed531f652396d1544)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/ovl_entry.h
#	fs/overlayfs/super.c
diff --cc fs/overlayfs/super.c
index aaf06952d88f,b31637727021..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -1302,10 -821,20 +1306,23 @@@ static int ovl_fill_super(struct super_
  			goto out_put_upperpath;
  		}
  
- 		err = ovl_mount_dir(ufs->config.workdir, &workpath);
++<<<<<<< HEAD
++=======
+ 		err = ovl_check_namelen(&upperpath, ufs, ufs->config.upperdir);
  		if (err)
  			goto out_put_upperpath;
  
+ 		err = -EBUSY;
+ 		if (!ovl_inuse_trylock(upperpath.dentry)) {
+ 			pr_err("overlayfs: upperdir is in-use by another mount\n");
+ 			goto out_put_upperpath;
+ 		}
+ 
++>>>>>>> 2cac0c00a6cd (ovl: get exclusive ownership on upper/work dirs)
+ 		err = ovl_mount_dir(ufs->config.workdir, &workpath);
+ 		if (err)
+ 			goto out_unlock_upperdentry;
+ 
  		err = -EINVAL;
  		if (upperpath.mnt != workpath.mnt) {
  			pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
@@@ -1316,16 -845,15 +1333,27 @@@
  			goto out_put_workpath;
  		}
  
++<<<<<<< HEAD
 +		upper_stack_depth = get_s_stack_depth(upperpath.mnt->mnt_sb);
 +		err = -EOPNOTSUPP;
 +		if (!upper_stack_depth) {
 +			pr_err("overlayfs: superblock missing extension wrapper (old kernel?)\n");
 +			goto out_put_workpath;
 +		}
 +
 +		*overlay_stack_depth = *upper_stack_depth;
++=======
+ 		err = -EBUSY;
+ 		if (!ovl_inuse_trylock(workpath.dentry)) {
+ 			pr_err("overlayfs: workdir is in-use by another mount\n");
+ 			goto out_put_workpath;
+ 		}
+ 
+ 		ufs->workbasedir = workpath.dentry;
+ 		sb->s_stack_depth = upperpath.mnt->mnt_sb->s_stack_depth;
++>>>>>>> 2cac0c00a6cd (ovl: get exclusive ownership on upper/work dirs)
  	}
 +
  	err = -ENOMEM;
  	lowertmp = kstrdup(ufs->config.lowerdir, GFP_KERNEL);
  	if (!lowertmp)
@@@ -1465,10 -1023,13 +1494,10 @@@
  	mntput(upperpath.mnt);
  	for (i = 0; i < numlower; i++)
  		mntput(stack[i].mnt);
- 	path_put(&workpath);
+ 	mntput(workpath.mnt);
  	kfree(lowertmp);
  
 -	if (upperpath.dentry) {
 -		if (ovl_is_impuredir(upperpath.dentry))
 -			ovl_set_flag(OVL_IMPURE, d_inode(root_dentry));
 -	}
 +	oe->__upperdentry = upperpath.dentry;
  	for (i = 0; i < numlower; i++) {
  		oe->lowerstack[i].dentry = stack[i].dentry;
  		oe->lowerstack[i].mnt = ufs->lower_mnt[i];
* Unmerged path fs/overlayfs/ovl_entry.h
* Unmerged path fs/overlayfs/ovl_entry.h
* Unmerged path fs/overlayfs/super.c
