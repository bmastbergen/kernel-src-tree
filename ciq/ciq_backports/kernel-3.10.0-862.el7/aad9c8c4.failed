net: add new control message for incoming HW-timestamped packets

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] add new control message for incoming HW-timestamped packets (Hangbin Liu) [1421164]
Rebuild_FUZZ: 95.93%
commit-author Miroslav Lichvar <mlichvar@redhat.com>
commit aad9c8c470f2a8321a99eb053630ce0e199558d6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/aad9c8c4.failed

Add SOF_TIMESTAMPING_OPT_PKTINFO option to request a new control message
for incoming packets with hardware timestamps. It contains the index of
the real interface which received the packet and the length of the
packet at layer 2.

The index is useful with bonding, bridges and other interfaces, where
IP_PKTINFO doesn't allow applications to determine which PHC made the
timestamp. With the L2 length (and link speed) it is possible to
transpose preamble timestamps to trailer timestamps, which are used in
the NTP protocol.

While this information could be provided by two new socket options
independently from timestamping, it doesn't look like they would be very
useful. With this option any performance impact is limited to hardware
timestamping.

Use dev_get_by_napi_id() to get the device and its index. On kernels
with disabled CONFIG_NET_RX_BUSY_POLL or drivers not using NAPI, a zero
index will be returned in the control message.

CC: Richard Cochran <richardcochran@gmail.com>
	Acked-by: Willem de Bruijn <willemb@google.com>
	Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit aad9c8c470f2a8321a99eb053630ce0e199558d6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/networking/timestamping.txt
#	include/uapi/asm-generic/socket.h
#	include/uapi/linux/net_tstamp.h
#	net/socket.c
diff --cc Documentation/networking/timestamping.txt
index 250384075a10,ce11e3a08c0d..000000000000
--- a/Documentation/networking/timestamping.txt
+++ b/Documentation/networking/timestamping.txt
@@@ -52,61 -173,235 +52,205 @@@ SOF_TIMESTAMPING_OPT_CMSG
    option IP_PKTINFO simultaneously.
  
  
 -SOF_TIMESTAMPING_OPT_TSONLY:
 +It is worth noting that timestamps may be collected for reasons other
 +than being requested by a particular socket with
 +SOF_TIMESTAMPING_[TR]X_(HARD|SOFT)WARE.  For example, most drivers that
 +can generate hardware receive timestamps ignore
 +SOF_TIMESTAMPING_RX_HARDWARE.  It is still a good idea to set that flag
 +in case future drivers pay attention.
  
++<<<<<<< HEAD
 +If timestamps are reported, they will appear in a control message with
 +cmsg_level==SOL_SOCKET, cmsg_type==SO_TIMESTAMPING, and a payload like
 +this:
++=======
+   Applies to transmit timestamps only. Makes the kernel return the
+   timestamp as a cmsg alongside an empty packet, as opposed to
+   alongside the original packet. This reduces the amount of memory
+   charged to the socket's receive budget (SO_RCVBUF) and delivers
+   the timestamp even if sysctl net.core.tstamp_allow_data is 0.
+   This option disables SOF_TIMESTAMPING_OPT_CMSG.
+ 
+ SOF_TIMESTAMPING_OPT_STATS:
+ 
+   Optional stats that are obtained along with the transmit timestamps.
+   It must be used together with SOF_TIMESTAMPING_OPT_TSONLY. When the
+   transmit timestamp is available, the stats are available in a
+   separate control message of type SCM_TIMESTAMPING_OPT_STATS, as a
+   list of TLVs (struct nlattr) of types. These stats allow the
+   application to associate various transport layer stats with
+   the transmit timestamps, such as how long a certain block of
+   data was limited by peer's receiver window.
+ 
+ SOF_TIMESTAMPING_OPT_PKTINFO:
+ 
+   Enable the SCM_TIMESTAMPING_PKTINFO control message for incoming
+   packets with hardware timestamps. The message contains struct
+   scm_ts_pktinfo, which supplies the index of the real interface which
+   received the packet and its length at layer 2. A valid (non-zero)
+   interface index will be returned only if CONFIG_NET_RX_BUSY_POLL is
+   enabled and the driver is using NAPI. The struct contains also two
+   other fields, but they are reserved and undefined.
+ 
+ New applications are encouraged to pass SOF_TIMESTAMPING_OPT_ID to
+ disambiguate timestamps and SOF_TIMESTAMPING_OPT_TSONLY to operate
+ regardless of the setting of sysctl net.core.tstamp_allow_data.
+ 
+ An exception is when a process needs additional cmsg data, for
+ instance SOL_IP/IP_PKTINFO to detect the egress network interface.
+ Then pass option SOF_TIMESTAMPING_OPT_CMSG. This option depends on
+ having access to the contents of the original packet, so cannot be
+ combined with SOF_TIMESTAMPING_OPT_TSONLY.
+ 
+ 
+ 1.3.4. Enabling timestamps via control messages
+ 
+ In addition to socket options, timestamp generation can be requested
+ per write via cmsg, only for SOF_TIMESTAMPING_TX_* (see Section 1.3.1).
+ Using this feature, applications can sample timestamps per sendmsg()
+ without paying the overhead of enabling and disabling timestamps via
+ setsockopt:
+ 
+   struct msghdr *msg;
+   ...
+   cmsg			       = CMSG_FIRSTHDR(msg);
+   cmsg->cmsg_level	       = SOL_SOCKET;
+   cmsg->cmsg_type	       = SO_TIMESTAMPING;
+   cmsg->cmsg_len	       = CMSG_LEN(sizeof(__u32));
+   *((__u32 *) CMSG_DATA(cmsg)) = SOF_TIMESTAMPING_TX_SCHED |
+ 				 SOF_TIMESTAMPING_TX_SOFTWARE |
+ 				 SOF_TIMESTAMPING_TX_ACK;
+   err = sendmsg(fd, msg, 0);
+ 
+ The SOF_TIMESTAMPING_TX_* flags set via cmsg will override
+ the SOF_TIMESTAMPING_TX_* flags set via setsockopt.
+ 
+ Moreover, applications must still enable timestamp reporting via
+ setsockopt to receive timestamps:
+ 
+   __u32 val = SOF_TIMESTAMPING_SOFTWARE |
+ 	      SOF_TIMESTAMPING_OPT_ID /* or any other flag */;
+   err = setsockopt(fd, SOL_SOCKET, SO_TIMESTAMPING, (void *) val,
+                    sizeof(val));
+ 
+ 
+ 1.4 Bytestream Timestamps
+ 
+ The SO_TIMESTAMPING interface supports timestamping of bytes in a
+ bytestream. Each request is interpreted as a request for when the
+ entire contents of the buffer has passed a timestamping point. That
+ is, for streams option SOF_TIMESTAMPING_TX_SOFTWARE will record
+ when all bytes have reached the device driver, regardless of how
+ many packets the data has been converted into.
+ 
+ In general, bytestreams have no natural delimiters and therefore
+ correlating a timestamp with data is non-trivial. A range of bytes
+ may be split across segments, any segments may be merged (possibly
+ coalescing sections of previously segmented buffers associated with
+ independent send() calls). Segments can be reordered and the same
+ byte range can coexist in multiple segments for protocols that
+ implement retransmissions.
+ 
+ It is essential that all timestamps implement the same semantics,
+ regardless of these possible transformations, as otherwise they are
+ incomparable. Handling "rare" corner cases differently from the
+ simple case (a 1:1 mapping from buffer to skb) is insufficient
+ because performance debugging often needs to focus on such outliers.
+ 
+ In practice, timestamps can be correlated with segments of a
+ bytestream consistently, if both semantics of the timestamp and the
+ timing of measurement are chosen correctly. This challenge is no
+ different from deciding on a strategy for IP fragmentation. There, the
+ definition is that only the first fragment is timestamped. For
+ bytestreams, we chose that a timestamp is generated only when all
+ bytes have passed a point. SOF_TIMESTAMPING_TX_ACK as defined is easy to
+ implement and reason about. An implementation that has to take into
+ account SACK would be more complex due to possible transmission holes
+ and out of order arrival.
+ 
+ On the host, TCP can also break the simple 1:1 mapping from buffer to
+ skbuff as a result of Nagle, cork, autocork, segmentation and GSO. The
+ implementation ensures correctness in all cases by tracking the
+ individual last byte passed to send(), even if it is no longer the
+ last byte after an skbuff extend or merge operation. It stores the
+ relevant sequence number in skb_shinfo(skb)->tskey. Because an skbuff
+ has only one such field, only one timestamp can be generated.
+ 
+ In rare cases, a timestamp request can be missed if two requests are
+ collapsed onto the same skb. A process can detect this situation by
+ enabling SOF_TIMESTAMPING_OPT_ID and comparing the byte offset at
+ send time with the value returned for each timestamp. It can prevent
+ the situation by always flushing the TCP stack in between requests,
+ for instance by enabling TCP_NODELAY and disabling TCP_CORK and
+ autocork.
+ 
+ These precautions ensure that the timestamp is generated only when all
+ bytes have passed a timestamp point, assuming that the network stack
+ itself does not reorder the segments. The stack indeed tries to avoid
+ reordering. The one exception is under administrator control: it is
+ possible to construct a packet scheduler configuration that delays
+ segments from the same stream differently. Such a setup would be
+ unusual.
+ 
+ 
+ 2 Data Interfaces
+ 
+ Timestamps are read using the ancillary data feature of recvmsg().
+ See `man 3 cmsg` for details of this interface. The socket manual
+ page (`man 7 socket`) describes how timestamps generated with
+ SO_TIMESTAMP and SO_TIMESTAMPNS records can be retrieved.
+ 
+ 
+ 2.1 SCM_TIMESTAMPING records
+ 
+ These timestamps are returned in a control message with cmsg_level
+ SOL_SOCKET, cmsg_type SCM_TIMESTAMPING, and payload of type
++>>>>>>> aad9c8c470f2 (net: add new control message for incoming HW-timestamped packets)
  
  struct scm_timestamping {
 -	struct timespec ts[3];
 +	struct timespec systime;
 +	struct timespec hwtimetrans;
 +	struct timespec hwtimeraw;
  };
  
 -The structure can return up to three timestamps. This is a legacy
 -feature. Only one field is non-zero at any time. Most timestamps
 -are passed in ts[0]. Hardware timestamps are passed in ts[2].
 -
 -ts[1] used to hold hardware timestamps converted to system time.
 -Instead, expose the hardware clock device on the NIC directly as
 -a HW PTP clock source, to allow time conversion in userspace and
 -optionally synchronize system time with a userspace PTP stack such
 -as linuxptp. For the PTP clock API, see Documentation/ptp/ptp.txt.
 -
 -2.1.1 Transmit timestamps with MSG_ERRQUEUE
 -
 -For transmit timestamps the outgoing packet is looped back to the
 -socket's error queue with the send timestamp(s) attached. A process
 -receives the timestamps by calling recvmsg() with flag MSG_ERRQUEUE
 -set and with a msg_control buffer sufficiently large to receive the
 -relevant metadata structures. The recvmsg call returns the original
 -outgoing data packet with two ancillary messages attached.
 -
 -A message of cm_level SOL_IP(V6) and cm_type IP(V6)_RECVERR
 -embeds a struct sock_extended_err. This defines the error type. For
 -timestamps, the ee_errno field is ENOMSG. The other ancillary message
 -will have cm_level SOL_SOCKET and cm_type SCM_TIMESTAMPING. This
 -embeds the struct scm_timestamping.
 -
 -
 -2.1.1.2 Timestamp types
 -
 -The semantics of the three struct timespec are defined by field
 -ee_info in the extended error structure. It contains a value of
 -type SCM_TSTAMP_* to define the actual timestamp passed in
 -scm_timestamping.
 -
 -The SCM_TSTAMP_* types are 1:1 matches to the SOF_TIMESTAMPING_*
 -control fields discussed previously, with one exception. For legacy
 -reasons, SCM_TSTAMP_SND is equal to zero and can be set for both
 -SOF_TIMESTAMPING_TX_HARDWARE and SOF_TIMESTAMPING_TX_SOFTWARE. It
 -is the first if ts[2] is non-zero, the second otherwise, in which
 -case the timestamp is stored in ts[0].
 -
 -
 -2.1.1.3 Fragmentation
 -
 -Fragmentation of outgoing datagrams is rare, but is possible, e.g., by
 -explicitly disabling PMTU discovery. If an outgoing packet is fragmented,
 -then only the first fragment is timestamped and returned to the sending
 -socket.
 -
 -
 -2.1.1.4 Packet Payload
 -
 -The calling application is often not interested in receiving the whole
 -packet payload that it passed to the stack originally: the socket
 -error queue mechanism is just a method to piggyback the timestamp on.
 -In this case, the application can choose to read datagrams with a
 -smaller buffer, possibly even of length 0. The payload is truncated
 -accordingly. Until the process calls recvmsg() on the error queue,
 -however, the full packet is queued, taking up budget from SO_RCVBUF.
 -
 -
 -2.1.1.5 Blocking Read
 -
 -Reading from the error queue is always a non-blocking operation. To
 -block waiting on a timestamp, use poll or select. poll() will return
 -POLLERR in pollfd.revents if any data is ready on the error queue.
 -There is no need to pass this flag in pollfd.events. This flag is
 -ignored on request. See also `man 2 poll`.
 -
 -
 -2.1.2 Receive timestamps
 -
 -On reception, there is no reason to read from the socket error queue.
 -The SCM_TIMESTAMPING ancillary data is sent along with the packet data
 -on a normal recvmsg(). Since this is not a socket error, it is not
 -accompanied by a message SOL_IP(V6)/IP(V6)_RECVERROR. In this case,
 -the meaning of the three fields in struct scm_timestamping is
 -implicitly defined. ts[0] holds a software timestamp if set, ts[1]
 -is again deprecated and ts[2] holds a hardware timestamp if set.
 -
 -
 -3. Hardware Timestamping configuration: SIOCSHWTSTAMP and SIOCGHWTSTAMP
 +recvmsg() can be used to get this control message for regular incoming
 +packets. For send time stamps the outgoing packet is looped back to
 +the socket's error queue with the send time stamp(s) attached. It can
 +be received with recvmsg(flags=MSG_ERRQUEUE). The call returns the
 +original outgoing packet data including all headers preprended down to
 +and including the link layer, the scm_timestamping control message and
 +a sock_extended_err control message with ee_errno==ENOMSG and
 +ee_origin==SO_EE_ORIGIN_TIMESTAMPING. A socket with such a pending
 +bounced packet is ready for reading as far as select() is concerned.
 +If the outgoing packet has to be fragmented, then only the first
 +fragment is time stamped and returned to the sending socket.
 +
 +All three values correspond to the same event in time, but were
 +generated in different ways. Each of these values may be empty (= all
 +zero), in which case no such value was available. If the application
 +is not interested in some of these values, they can be left blank to
 +avoid the potential overhead of calculating them.
 +
 +systime is the value of the system time at that moment. This
 +corresponds to the value also returned via SO_TIMESTAMP[NS]. If the
 +time stamp was generated by hardware, then this field is
 +empty. Otherwise it is filled in if SOF_TIMESTAMPING_SOFTWARE is
 +set.
 +
 +hwtimeraw is the original hardware time stamp. Filled in if
 +SOF_TIMESTAMPING_RAW_HARDWARE is set. No assumptions about its
 +relation to system time should be made.
 +
 +hwtimetrans is the hardware time stamp transformed so that it
 +corresponds as good as possible to system time. This correlation is
 +not perfect; as a consequence, sorting packets received via different
 +NICs by their hwtimetrans may differ from the order in which they were
 +received. hwtimetrans may be non-monotonic even for the same NIC.
 +Filled in if SOF_TIMESTAMPING_SYS_HARDWARE is set. Requires support
 +by the network device and will be empty without that support.
 +
 +
 +SIOCSHWTSTAMP, SIOCGHWTSTAMP:
  
  Hardware time stamping must also be initialized for each device driver
  that is expected to do hardware time stamping. The parameter is defined in
diff --cc include/uapi/asm-generic/socket.h
index ea0796bdcf88,a5f6e819fafd..000000000000
--- a/include/uapi/asm-generic/socket.h
+++ b/include/uapi/asm-generic/socket.h
@@@ -82,4 -82,24 +82,27 @@@
  
  #define SO_BPF_EXTENSIONS	48
  
++<<<<<<< HEAD
++=======
+ #define SO_INCOMING_CPU		49
+ 
+ #define SO_ATTACH_BPF		50
+ #define SO_DETACH_BPF		SO_DETACH_FILTER
+ 
+ #define SO_ATTACH_REUSEPORT_CBPF	51
+ #define SO_ATTACH_REUSEPORT_EBPF	52
+ 
+ #define SO_CNX_ADVICE		53
+ 
+ #define SCM_TIMESTAMPING_OPT_STATS	54
+ 
+ #define SO_MEMINFO		55
+ 
+ #define SO_INCOMING_NAPI_ID	56
+ 
+ #define SO_COOKIE		57
+ 
+ #define SCM_TIMESTAMPING_PKTINFO	58
+ 
++>>>>>>> aad9c8c470f2 (net: add new control message for incoming HW-timestamped packets)
  #endif /* __ASM_GENERIC_SOCKET_H */
diff --cc include/uapi/linux/net_tstamp.h
index ea05ed4641e5,dee74d39da94..000000000000
--- a/include/uapi/linux/net_tstamp.h
+++ b/include/uapi/linux/net_tstamp.h
@@@ -20,15 -21,15 +21,23 @@@ enum 
  	SOF_TIMESTAMPING_SOFTWARE = (1<<4),
  	SOF_TIMESTAMPING_SYS_HARDWARE = (1<<5),
  	SOF_TIMESTAMPING_RAW_HARDWARE = (1<<6),
 -	SOF_TIMESTAMPING_OPT_ID = (1<<7),
 -	SOF_TIMESTAMPING_TX_SCHED = (1<<8),
 -	SOF_TIMESTAMPING_TX_ACK = (1<<9),
 +	/* RH: remember to update the check in sock_setsockopt()
 +	 * if these values become used.
 +	 */
 +	__RH_RESERVED_SOF_TIMESTAMPING_OPT_ID = (1<<7),
 +	__RH_RESERVED_SOF_TIMESTAMPING_TX_SCHED = (1<<8),
 +	__RH_RESERVED_SOF_TIMESTAMPING_TX_ACK = (1<<9),
  	SOF_TIMESTAMPING_OPT_CMSG = (1<<10),
++<<<<<<< HEAD
 +
 +	SOF_TIMESTAMPING_LAST = SOF_TIMESTAMPING_OPT_CMSG,
++=======
+ 	SOF_TIMESTAMPING_OPT_TSONLY = (1<<11),
+ 	SOF_TIMESTAMPING_OPT_STATS = (1<<12),
+ 	SOF_TIMESTAMPING_OPT_PKTINFO = (1<<13),
+ 
+ 	SOF_TIMESTAMPING_LAST = SOF_TIMESTAMPING_OPT_PKTINFO,
++>>>>>>> aad9c8c470f2 (net: add new control message for incoming HW-timestamped packets)
  	SOF_TIMESTAMPING_MASK = (SOF_TIMESTAMPING_LAST - 1) |
  				 SOF_TIMESTAMPING_LAST
  };
diff --cc net/socket.c
index 88dae07181b5,67db7d8a3b81..000000000000
--- a/net/socket.c
+++ b/net/socket.c
@@@ -669,6 -652,37 +669,40 @@@ int kernel_sendmsg(struct socket *sock
  }
  EXPORT_SYMBOL(kernel_sendmsg);
  
++<<<<<<< HEAD
++=======
+ static bool skb_is_err_queue(const struct sk_buff *skb)
+ {
+ 	/* pkt_type of skbs enqueued on the error queue are set to
+ 	 * PACKET_OUTGOING in skb_set_err_queue(). This is only safe to do
+ 	 * in recvmsg, since skbs received on a local socket will never
+ 	 * have a pkt_type of PACKET_OUTGOING.
+ 	 */
+ 	return skb->pkt_type == PACKET_OUTGOING;
+ }
+ 
+ static void put_ts_pktinfo(struct msghdr *msg, struct sk_buff *skb)
+ {
+ 	struct scm_ts_pktinfo ts_pktinfo;
+ 	struct net_device *orig_dev;
+ 
+ 	if (!skb_mac_header_was_set(skb))
+ 		return;
+ 
+ 	memset(&ts_pktinfo, 0, sizeof(ts_pktinfo));
+ 
+ 	rcu_read_lock();
+ 	orig_dev = dev_get_by_napi_id(skb_napi_id(skb));
+ 	if (orig_dev)
+ 		ts_pktinfo.if_index = orig_dev->ifindex;
+ 	rcu_read_unlock();
+ 
+ 	ts_pktinfo.pkt_length = skb->len - skb_mac_offset(skb);
+ 	put_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPING_PKTINFO,
+ 		 sizeof(ts_pktinfo), &ts_pktinfo);
+ }
+ 
++>>>>>>> aad9c8c470f2 (net: add new control message for incoming HW-timestamped packets)
  /*
   * called from sock_recv_timestamp() if sock_flag(sk, SOCK_RCVTSTAMP)
   */
@@@ -704,17 -718,23 +738,29 @@@ void __sock_recv_timestamp(struct msghd
  	if ((sk->sk_tsflags & SOF_TIMESTAMPING_SOFTWARE) &&
  	    ktime_to_timespec_cond(skb->tstamp, tss.ts + 0))
  		empty = 0;
++<<<<<<< HEAD
 +	if (shhwtstamps) {
 +		if ((sk->sk_tsflags & SOF_TIMESTAMPING_SYS_HARDWARE) &&
 +		    ktime_to_timespec_cond(shhwtstamps->syststamp, tss.ts + 1))
 +			empty = 0;
 +		if ((sk->sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE) &&
 +		    ktime_to_timespec_cond(shhwtstamps->hwtstamp, tss.ts + 2))
 +			empty = 0;
 +	}
 +	if (!empty)
++=======
+ 	if (shhwtstamps &&
+ 	    (sk->sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE) &&
+ 	    ktime_to_timespec_cond(shhwtstamps->hwtstamp, tss.ts + 2)) {
+ 		empty = 0;
+ 		if ((sk->sk_tsflags & SOF_TIMESTAMPING_OPT_PKTINFO) &&
+ 		    !skb_is_err_queue(skb))
+ 			put_ts_pktinfo(msg, skb);
+ 	}
+ 	if (!empty) {
++>>>>>>> aad9c8c470f2 (net: add new control message for incoming HW-timestamped packets)
  		put_cmsg(msg, SOL_SOCKET,
  			 SCM_TIMESTAMPING, sizeof(tss), &tss);
 -
 -		if (skb_is_err_queue(skb) && skb->len &&
 -		    SKB_EXT_ERR(skb)->opt_stats)
 -			put_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPING_OPT_STATS,
 -				 skb->len, skb->data);
 -	}
  }
  EXPORT_SYMBOL_GPL(__sock_recv_timestamp);
  
* Unmerged path Documentation/networking/timestamping.txt
* Unmerged path include/uapi/asm-generic/socket.h
* Unmerged path include/uapi/linux/net_tstamp.h
* Unmerged path net/socket.c
