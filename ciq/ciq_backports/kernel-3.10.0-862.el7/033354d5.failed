net/mlx5e: Read neigh parameters with proper locking

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Read neigh parameters with proper locking (Don Dutile) [1456687 1499362]
Rebuild_FUZZ: 96.00%
commit-author Hadar Hen Zion <hadarh@mellanox.com>
commit 033354d501862ca1f58caa1e5c5775712e1bff17
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/033354d5.failed

The nud_state and hardware address fields are protected by the neighbour
lock, we should acquire it before accessing those parameters.

Use this lock to avoid inconsistency between the neighbour validity state
and it's hardware address.

	Signed-off-by: Hadar Hen Zion <hadarh@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 033354d501862ca1f58caa1e5c5775712e1bff17)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index d3c637b0294b,ae07fe6473bb..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -893,12 -1221,17 +893,17 @@@ static int mlx5e_create_encap_header_ip
  	struct neighbour *n = NULL;
  	struct flowi4 fl4 = {};
  	char *encap_header;
++<<<<<<< HEAD
 +	int encap_size;
 +	__be32 saddr;
 +	int ttl;
 +	int err;
++=======
+ 	int ttl, err;
+ 	u8 nud_state;
++>>>>>>> 033354d50186 (net/mlx5e: Read neigh parameters with proper locking)
  
 -	if (max_encap_size < ipv4_encap_size) {
 -		mlx5_core_warn(priv->mdev, "encap size %d too big, max supported is %d\n",
 -			       ipv4_encap_size, max_encap_size);
 -		return -EOPNOTSUPP;
 -	}
 -
 -	encap_header = kzalloc(ipv4_encap_size, GFP_KERNEL);
 +	encap_header = kzalloc(max_encap_size, GFP_KERNEL);
  	if (!encap_header)
  		return -ENOMEM;
  
@@@ -918,16 -1253,19 +923,30 @@@
  	if (err)
  		goto out;
  
++<<<<<<< HEAD
 +	e->n = n;
 +	e->out_dev = *out_dev;
 +
 +	if (!(n->nud_state & NUD_VALID)) {
++=======
+ 	read_lock_bh(&n->lock);
+ 	nud_state = n->nud_state;
+ 	ether_addr_copy(e->h_dest, n->ha);
+ 	read_unlock_bh(&n->lock);
+ 
+ 	if (!(nud_state & NUD_VALID)) {
++>>>>>>> 033354d50186 (net/mlx5e: Read neigh parameters with proper locking)
  		pr_warn("%s: can't offload, neighbour to %pI4 invalid\n", __func__, &fl4.daddr);
  		err = -EOPNOTSUPP;
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	neigh_ha_snapshot(e->h_dest, n, *out_dev);
++=======
+ 	e->n = n;
+ 	e->out_dev = out_dev;
++>>>>>>> 033354d50186 (net/mlx5e: Read neigh parameters with proper locking)
  
  	switch (e->tunnel_type) {
  	case MLX5_HEADER_TYPE_VXLAN:
@@@ -1001,13 -1344,11 +1026,16 @@@ static int mlx5e_create_encap_header_ip
  	}
  
  	e->n = n;
 -	e->out_dev = out_dev;
 +	e->out_dev = *out_dev;
  
++<<<<<<< HEAD
 +	neigh_ha_snapshot(e->h_dest, n, *out_dev);
 +
++=======
++>>>>>>> 033354d50186 (net/mlx5e: Read neigh parameters with proper locking)
  	switch (e->tunnel_type) {
  	case MLX5_HEADER_TYPE_VXLAN:
 -		gen_vxlan_header_ipv6(out_dev, encap_header,
 +		gen_vxlan_header_ipv6(*out_dev, encap_header,
  				      ipv6_encap_size, e->h_dest, ttl,
  				      &fl6.daddr,
  				      &fl6.saddr, tun_key->tp_dst,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
