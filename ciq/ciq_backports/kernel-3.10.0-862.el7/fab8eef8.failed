xfs: sanity check inode mode when creating new dentry

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit fab8eef86c814c3dd46bc5d760b6e4a53d5fc5a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/fab8eef8.failed

The helper xfs_dentry_to_name() is used by 2 different
classes of callers: Callers that pass zero mode and don't care
about the returned name.type field and Callers that pass
non zero mode and do care about the name.type field.

Change xfs_dentry_to_name() to not take the mode argument and
change the call sites of the first class to not pass the mode
argument.

Create a new helper xfs_dentry_mode_to_name() which does pass
the mode argument and returns -EFSCORRUPTED if mode is invalid.
Callers that translate non zero mode to on-disk file type now
check the return value and will export the error to user instead
of staging an invalid file type to be written to directory entry.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit fab8eef86c814c3dd46bc5d760b6e4a53d5fc5a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_iops.c
diff --cc fs/xfs/xfs_iops.c
index 49b570287277,22c16155f1b4..000000000000
--- a/fs/xfs/xfs_iops.c
+++ b/fs/xfs/xfs_iops.c
@@@ -118,10 -134,9 +133,10 @@@ xfs_cleanup_inode
  	 * xfs_init_security we must back out.
  	 * ENOSPC can hit here, among other things.
  	 */
- 	xfs_dentry_to_name(&teardown, dentry, 0);
+ 	xfs_dentry_to_name(&teardown, dentry);
  
  	xfs_remove(XFS_I(dir), &teardown, XFS_I(inode));
 +	iput(inode);
  }
  
  STATIC int
@@@ -149,17 -165,20 +164,29 @@@ xfs_vn_mknod
  		rdev = 0;
  	}
  
 -	error = posix_acl_create(dir, &mode, &default_acl, &acl);
 -	if (error)
 -		return error;
 +	if (IS_POSIXACL(dir)) {
 +		default_acl = xfs_get_acl(dir, ACL_TYPE_DEFAULT);
 +		if (IS_ERR(default_acl))
 +			return PTR_ERR(default_acl);
  
++<<<<<<< HEAD
 +		if (!default_acl)
 +			mode &= ~current_umask();
++=======
+ 	/* Verify mode is valid also for tmpfile case */
+ 	error = xfs_dentry_mode_to_name(&name, dentry, mode);
+ 	if (unlikely(error))
+ 		goto out_free_acl;
+ 
+ 	if (!tmpfile) {
+ 		error = xfs_create(XFS_I(dir), &name, mode, rdev, &ip);
+ 	} else {
+ 		error = xfs_create_tmpfile(XFS_I(dir), dentry, mode, &ip);
++>>>>>>> fab8eef86c81 (xfs: sanity check inode mode when creating new dentry)
  	}
 +
 +	xfs_dentry_to_name(&name, dentry, mode);
 +	error = xfs_create(XFS_I(dir), &name, mode, rdev, &ip);
  	if (unlikely(error))
  		goto out_free_acl;
  
@@@ -303,9 -350,9 +332,9 @@@ xfs_vn_unlink
  	struct xfs_name	name;
  	int		error;
  
- 	xfs_dentry_to_name(&name, dentry, 0);
+ 	xfs_dentry_to_name(&name, dentry);
  
 -	error = xfs_remove(XFS_I(dir), &name, XFS_I(d_inode(dentry)));
 +	error = xfs_remove(XFS_I(dir), &name, XFS_I(dentry->d_inode));
  	if (error)
  		return error;
  
@@@ -366,8 -416,9 +397,9 @@@ xfs_vn_rename
  	struct dentry	*ndentry,
  	unsigned int	flags)
  {
 -	struct inode	*new_inode = d_inode(ndentry);
 +	struct inode	*new_inode = ndentry->d_inode;
  	int		omode = 0;
+ 	int		error;
  	struct xfs_name	oname;
  	struct xfs_name	nname;
  
@@@ -376,12 -427,18 +408,23 @@@
  
  	/* if we are exchanging files, we need to set i_mode of both files */
  	if (flags & RENAME_EXCHANGE)
 -		omode = d_inode(ndentry)->i_mode;
 +		omode = ndentry->d_inode->i_mode;
  
++<<<<<<< HEAD
 +	xfs_dentry_to_name(&oname, odentry, omode);
 +	xfs_dentry_to_name(&nname, ndentry, odentry->d_inode->i_mode);
++=======
+ 	error = xfs_dentry_mode_to_name(&oname, odentry, omode);
+ 	if (omode && unlikely(error))
+ 		return error;
+ 
+ 	error = xfs_dentry_mode_to_name(&nname, ndentry,
+ 					d_inode(odentry)->i_mode);
+ 	if (unlikely(error))
+ 		return error;
++>>>>>>> fab8eef86c81 (xfs: sanity check inode mode when creating new dentry)
  
 -	return xfs_rename(XFS_I(odir), &oname, XFS_I(d_inode(odentry)),
 +	return xfs_rename(XFS_I(odir), &oname, XFS_I(odentry->d_inode),
  			  XFS_I(ndir), &nname,
  			  new_inode ? XFS_I(new_inode) : NULL, flags);
  }
* Unmerged path fs/xfs/xfs_iops.c
