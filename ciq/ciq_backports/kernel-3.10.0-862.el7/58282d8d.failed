sysfs: rename sysfs_buffer to sysfs_open_file

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Tejun Heo <tj@kernel.org>
commit 58282d8dc2e7cf2b87c8fee94d7138ed08e0a2e5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/58282d8d.failed

sysfs read path will be converted to use seq_file which will handle
buffering making sysfs_buffer a misnomer.  Rename sysfs_buffer to
sysfs_open_file, and sysfs_open_dirent->buffers to ->files.

This path is pure rename.

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 58282d8dc2e7cf2b87c8fee94d7138ed08e0a2e5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/sysfs/file.c
diff --cc fs/sysfs/file.c
index d8887c896abc,4b55bcf4422e..000000000000
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@@ -41,16 -41,13 +41,16 @@@ struct sysfs_open_dirent 
  	atomic_t		refcnt;
  	atomic_t		event;
  	wait_queue_head_t	poll;
- 	struct list_head	buffers; /* goes through sysfs_buffer.list */
+ 	struct list_head	files; /* goes through sysfs_open_file.list */
  };
  
- struct sysfs_buffer {
+ struct sysfs_open_file {
  	size_t			count;
 -	char			*page;
 +	loff_t			pos;
 +	char			* page;
 +	const struct sysfs_ops	* ops;
  	struct mutex		mutex;
 +	int			needs_read_fill;
  	int			event;
  	struct list_head	list;
  };
@@@ -66,7 -75,7 +66,11 @@@
   *	This is called only once, on the file's first read unless an error
   *	is returned.
   */
++<<<<<<< HEAD
 +static int fill_read_buffer(struct dentry * dentry, struct sysfs_buffer * buffer)
++=======
+ static int fill_read_buffer(struct dentry *dentry, struct sysfs_open_file *of)
++>>>>>>> 58282d8dc2e7 (sysfs: rename sysfs_buffer to sysfs_open_file)
  {
  	struct sysfs_dirent *attr_sd = dentry->d_fsdata;
  	struct kobject *kobj = attr_sd->s_parent->s_dir.kobj;
@@@ -83,8 -92,10 +87,15 @@@
  	if (!sysfs_get_active(attr_sd))
  		return -ENODEV;
  
++<<<<<<< HEAD
 +	buffer->event = atomic_read(&attr_sd->s_attr.open->event);
 +	count = ops->show(kobj, attr_sd->s_attr.attr, buffer->page);
++=======
+ 	of->event = atomic_read(&attr_sd->s_attr.open->event);
+ 
+ 	ops = sysfs_file_ops(attr_sd);
+ 	count = ops->show(kobj, attr_sd->s_attr.attr, of->page);
++>>>>>>> 58282d8dc2e7 (sysfs: rename sysfs_buffer to sysfs_open_file)
  
  	sysfs_put_active(attr_sd);
  
@@@ -98,12 -109,10 +109,18 @@@
  		/* Try to struggle along */
  		count = PAGE_SIZE - 1;
  	}
++<<<<<<< HEAD
 +	if (count >= 0) {
 +		buffer->needs_read_fill = 0;
 +		buffer->count = count;
 +	} else {
++=======
+ 	if (count >= 0)
+ 		of->count = count;
+ 	else
++>>>>>>> 58282d8dc2e7 (sysfs: rename sysfs_buffer to sysfs_open_file)
  		ret = count;
 +	}
  	return ret;
  }
  
@@@ -129,12 -138,16 +146,25 @@@
  static ssize_t
  sysfs_read_file(struct file *file, char __user *buf, size_t count, loff_t *ppos)
  {
++<<<<<<< HEAD
 +	struct sysfs_buffer * buffer = file->private_data;
 +	ssize_t retval = 0;
 +
 +	mutex_lock(&buffer->mutex);
 +	if (buffer->needs_read_fill || *ppos == 0) {
 +		retval = fill_read_buffer(file->f_path.dentry,buffer);
++=======
+ 	struct sysfs_open_file *of = file->private_data;
+ 	ssize_t retval = 0;
+ 
+ 	mutex_lock(&of->mutex);
+ 	/*
+ 	 * Fill on zero offset and the first read so that silly things like
+ 	 * "dd bs=1 skip=N" can work on sysfs files.
+ 	 */
+ 	if (*ppos == 0 || !of->page) {
+ 		retval = fill_read_buffer(file->f_path.dentry, of);
++>>>>>>> 58282d8dc2e7 (sysfs: rename sysfs_buffer to sysfs_open_file)
  		if (retval)
  			goto out;
  	}
@@@ -153,11 -165,11 +182,16 @@@ out
   *	@buf:		data from user.
   *	@count:		number of bytes in @userbuf.
   *
-  *	Allocate @buffer->page if it hasn't been already, then
-  *	copy the user-supplied buffer into it.
+  *	Allocate @of->page if it hasn't been already, then copy the
+  *	user-supplied buffer into it.
   */
++<<<<<<< HEAD
 +static int fill_write_buffer(struct sysfs_buffer * buffer,
 +			     const char __user * buf, size_t count)
++=======
+ static int fill_write_buffer(struct sysfs_open_file *of,
+ 			     const char __user *buf, size_t count)
++>>>>>>> 58282d8dc2e7 (sysfs: rename sysfs_buffer to sysfs_open_file)
  {
  	int error;
  
@@@ -168,11 -180,13 +202,21 @@@
  
  	if (count >= PAGE_SIZE)
  		count = PAGE_SIZE - 1;
++<<<<<<< HEAD
 +	error = copy_from_user(buffer->page,buf,count);
 +	buffer->needs_read_fill = 1;
 +	/* if buf is assumed to contain a string, terminate it by \0,
 +	   so e.g. sscanf() can scan the string easily */
 +	buffer->page[count] = 0;
++=======
+ 	error = copy_from_user(of->page, buf, count);
+ 
+ 	/*
+ 	 * If buf is assumed to contain a string, terminate it by \0, so
+ 	 * e.g. sscanf() can scan the string easily.
+ 	 */
+ 	of->page[count] = 0;
++>>>>>>> 58282d8dc2e7 (sysfs: rename sysfs_buffer to sysfs_open_file)
  	return error ? -EFAULT : count;
  }
  
@@@ -187,8 -200,8 +231,13 @@@
   *	dealing with, then call the store() method for the attribute,
   *	passing the buffer that we acquired in fill_write_buffer().
   */
++<<<<<<< HEAD
 +static int
 +flush_write_buffer(struct dentry * dentry, struct sysfs_buffer * buffer, size_t count)
++=======
+ static int flush_write_buffer(struct dentry *dentry,
+ 			      struct sysfs_open_file *of, size_t count)
++>>>>>>> 58282d8dc2e7 (sysfs: rename sysfs_buffer to sysfs_open_file)
  {
  	struct sysfs_dirent *attr_sd = dentry->d_fsdata;
  	struct kobject *kobj = attr_sd->s_parent->s_dir.kobj;
@@@ -199,7 -212,8 +248,12 @@@
  	if (!sysfs_get_active(attr_sd))
  		return -ENODEV;
  
++<<<<<<< HEAD
 +	rc = ops->store(kobj, attr_sd->s_attr.attr, buffer->page, count);
++=======
+ 	ops = sysfs_file_ops(attr_sd);
+ 	rc = ops->store(kobj, attr_sd->s_attr.attr, of->page, count);
++>>>>>>> 58282d8dc2e7 (sysfs: rename sysfs_buffer to sysfs_open_file)
  
  	sysfs_put_active(attr_sd);
  
@@@ -223,20 -236,19 +277,24 @@@
   *	Hint: if you're writing a value, first read the file, modify only the
   *	the value you're changing, then write entire buffer back.
   */
 -static ssize_t sysfs_write_file(struct file *file, const char __user *buf,
 -				size_t count, loff_t *ppos)
 +
 +static ssize_t
 +sysfs_write_file(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
  {
++<<<<<<< HEAD
 +	struct sysfs_buffer * buffer = file->private_data;
++=======
+ 	struct sysfs_open_file *of = file->private_data;
++>>>>>>> 58282d8dc2e7 (sysfs: rename sysfs_buffer to sysfs_open_file)
  	ssize_t len;
  
- 	mutex_lock(&buffer->mutex);
- 	len = fill_write_buffer(buffer, buf, count);
+ 	mutex_lock(&of->mutex);
+ 	len = fill_write_buffer(of, buf, count);
  	if (len > 0)
- 		len = flush_write_buffer(file->f_path.dentry, buffer, len);
+ 		len = flush_write_buffer(file->f_path.dentry, of, len);
  	if (len > 0)
  		*ppos += len;
- 	mutex_unlock(&buffer->mutex);
+ 	mutex_unlock(&of->mutex);
  	return len;
  }
  
@@@ -367,21 -375,20 +424,27 @@@ static int sysfs_open_file(struct inod
  			goto err_out;
  	}
  
- 	/* No error? Great, allocate a buffer for the file, and store it
- 	 * it in file->private_data for easy access.
+ 	/*
+ 	 * No error? Great, allocate a sysfs_open_file for the file, and
+ 	 * store it it in file->private_data for easy access.
  	 */
  	error = -ENOMEM;
- 	buffer = kzalloc(sizeof(struct sysfs_buffer), GFP_KERNEL);
- 	if (!buffer)
+ 	of = kzalloc(sizeof(struct sysfs_open_file), GFP_KERNEL);
+ 	if (!of)
  		goto err_out;
  
++<<<<<<< HEAD
 +	mutex_init(&buffer->mutex);
 +	buffer->needs_read_fill = 1;
 +	buffer->ops = ops;
 +	file->private_data = buffer;
++=======
+ 	mutex_init(&of->mutex);
+ 	file->private_data = of;
++>>>>>>> 58282d8dc2e7 (sysfs: rename sysfs_buffer to sysfs_open_file)
  
  	/* make sure we have open dirent struct */
- 	error = sysfs_get_open_dirent(attr_sd, buffer);
+ 	error = sysfs_get_open_dirent(attr_sd, of);
  	if (error)
  		goto err_free;
  
@@@ -425,7 -432,7 +488,11 @@@ static int sysfs_release(struct inode *
   */
  static unsigned int sysfs_poll(struct file *filp, poll_table *wait)
  {
++<<<<<<< HEAD
 +	struct sysfs_buffer * buffer = filp->private_data;
++=======
+ 	struct sysfs_open_file *of = filp->private_data;
++>>>>>>> 58282d8dc2e7 (sysfs: rename sysfs_buffer to sysfs_open_file)
  	struct sysfs_dirent *attr_sd = filp->f_path.dentry->d_fsdata;
  	struct sysfs_open_dirent *od = attr_sd->s_attr.open;
  
* Unmerged path fs/sysfs/file.c
