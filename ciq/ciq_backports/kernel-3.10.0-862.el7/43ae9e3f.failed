ext[34]: fix double put in tmpfile

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Miklos Szeredi <mszeredi@suse.cz>
commit 43ae9e3fc70ca0057ae0a24ef5eedff05e3fae06
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/43ae9e3f.failed

d_tmpfile() already swallowed the inode ref.

	Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
	Cc: stable@vger.kernel.org
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 43ae9e3fc70ca0057ae0a24ef5eedff05e3fae06)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext3/namei.c
#	fs/ext4/namei.c
diff --cc fs/ext3/namei.c
index cea8ecf3e76e,f8cde46de9cd..000000000000
--- a/fs/ext3/namei.c
+++ b/fs/ext3/namei.c
@@@ -1759,6 -1759,44 +1759,47 @@@ retry
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int ext3_tmpfile(struct inode *dir, struct dentry *dentry, umode_t mode)
+ {
+ 	handle_t *handle;
+ 	struct inode *inode;
+ 	int err, retries = 0;
+ 
+ 	dquot_initialize(dir);
+ 
+ retry:
+ 	handle = ext3_journal_start(dir, EXT3_MAXQUOTAS_INIT_BLOCKS(dir->i_sb) +
+ 			  4 + EXT3_XATTR_TRANS_BLOCKS);
+ 
+ 	if (IS_ERR(handle))
+ 		return PTR_ERR(handle);
+ 
+ 	inode = ext3_new_inode (handle, dir, NULL, mode);
+ 	err = PTR_ERR(inode);
+ 	if (!IS_ERR(inode)) {
+ 		inode->i_op = &ext3_file_inode_operations;
+ 		inode->i_fop = &ext3_file_operations;
+ 		ext3_set_aops(inode);
+ 		d_tmpfile(dentry, inode);
+ 		err = ext3_orphan_add(handle, inode);
+ 		if (err)
+ 			goto err_unlock_inode;
+ 		mark_inode_dirty(inode);
+ 		unlock_new_inode(inode);
+ 	}
+ 	ext3_journal_stop(handle);
+ 	if (err == -ENOSPC && ext3_should_retry_alloc(dir->i_sb, &retries))
+ 		goto retry;
+ 	return err;
+ err_unlock_inode:
+ 	ext3_journal_stop(handle);
+ 	unlock_new_inode(inode);
+ 	return err;
+ }
+ 
++>>>>>>> 43ae9e3fc70c (ext[34]: fix double put in tmpfile)
  static int ext3_mkdir(struct inode * dir, struct dentry * dentry, umode_t mode)
  {
  	handle_t *handle;
diff --cc fs/ext4/namei.c
index ffabd6128552,5a0408d7b114..000000000000
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@@ -2305,6 -2296,44 +2305,47 @@@ retry
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int ext4_tmpfile(struct inode *dir, struct dentry *dentry, umode_t mode)
+ {
+ 	handle_t *handle;
+ 	struct inode *inode;
+ 	int err, retries = 0;
+ 
+ 	dquot_initialize(dir);
+ 
+ retry:
+ 	inode = ext4_new_inode_start_handle(dir, mode,
+ 					    NULL, 0, NULL,
+ 					    EXT4_HT_DIR,
+ 			EXT4_MAXQUOTAS_INIT_BLOCKS(dir->i_sb) +
+ 			  4 + EXT4_XATTR_TRANS_BLOCKS);
+ 	handle = ext4_journal_current_handle();
+ 	err = PTR_ERR(inode);
+ 	if (!IS_ERR(inode)) {
+ 		inode->i_op = &ext4_file_inode_operations;
+ 		inode->i_fop = &ext4_file_operations;
+ 		ext4_set_aops(inode);
+ 		d_tmpfile(dentry, inode);
+ 		err = ext4_orphan_add(handle, inode);
+ 		if (err)
+ 			goto err_unlock_inode;
+ 		mark_inode_dirty(inode);
+ 		unlock_new_inode(inode);
+ 	}
+ 	if (handle)
+ 		ext4_journal_stop(handle);
+ 	if (err == -ENOSPC && ext4_should_retry_alloc(dir->i_sb, &retries))
+ 		goto retry;
+ 	return err;
+ err_unlock_inode:
+ 	ext4_journal_stop(handle);
+ 	unlock_new_inode(inode);
+ 	return err;
+ }
+ 
++>>>>>>> 43ae9e3fc70c (ext[34]: fix double put in tmpfile)
  struct ext4_dir_entry_2 *ext4_init_dot_dotdot(struct inode *inode,
  			  struct ext4_dir_entry_2 *de,
  			  int blocksize, int csum_size,
* Unmerged path fs/ext3/namei.c
* Unmerged path fs/ext4/namei.c
