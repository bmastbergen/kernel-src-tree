s390/cpcmd,vmcp: avoid GFP_DMA allocations

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [s390] cpcmd, vmcp: avoid GFP_DMA allocations (Hendrik Brueckner) [1496111]
Rebuild_FUZZ: 92.50%
commit-author Heiko Carstens <heiko.carstens@de.ibm.com>
commit cd4386a931b6310b05559d2e28efda04d30ab593
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/cd4386a9.failed

According to the CP Programming Services manual Diagnose Code 8
"Virtual Console Function" can be used in all addressing modes. Also
the input and output buffers do not have a limitation which specifies
they need to be below the 2GB line.

This is true at least since z/VM 5.4.

Therefore remove the sam31/64 instructions and allow for simple
GFP_KERNEL allocations. This makes it easier to allocate a 1MB page
if the user requested such a large return buffer.

	Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit cd4386a931b6310b05559d2e28efda04d30ab593)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/kernel/cpcmd.c
#	drivers/s390/char/vmcp.c
diff --cc arch/s390/kernel/cpcmd.c
index d7b0c4d27880,63bc6603e0ed..000000000000
--- a/arch/s390/kernel/cpcmd.c
+++ b/arch/s390/kernel/cpcmd.c
@@@ -14,6 -14,8 +14,11 @@@
  #include <linux/spinlock.h>
  #include <linux/stddef.h>
  #include <linux/string.h>
++<<<<<<< HEAD
++=======
+ #include <linux/mm.h>
+ #include <asm/diag.h>
++>>>>>>> cd4386a931b6 (s390/cpcmd,vmcp: avoid GFP_DMA allocations)
  #include <asm/ebcdic.h>
  #include <asm/cpcmd.h>
  #include <asm/io.h>
@@@ -27,13 -29,7 +32,17 @@@ static int diag8_noresponse(int cmdlen
  	register unsigned long reg3 asm ("3") = cmdlen;
  
  	asm volatile(
++<<<<<<< HEAD
 +#ifndef CONFIG_64BIT
  		"	diag	%1,%0,0x8\n"
 +#else /* CONFIG_64BIT */
 +		"	sam31\n"
 +		"	diag	%1,%0,0x8\n"
 +		"	sam64\n"
 +#endif /* CONFIG_64BIT */
++=======
++		"	diag	%1,%0,0x8\n"
++>>>>>>> cd4386a931b6 (s390/cpcmd,vmcp: avoid GFP_DMA allocations)
  		: "+d" (reg3) : "d" (reg2) : "cc");
  	return reg3;
  }
@@@ -46,17 -42,9 +55,19 @@@ static int diag8_response(int cmdlen, c
  	register unsigned long reg5 asm ("5") = *rlen;
  
  	asm volatile(
++<<<<<<< HEAD
 +#ifndef CONFIG_64BIT
 +		"	diag	%2,%0,0x8\n"
 +		"	brc	8,1f\n"
 +		"	ar	%1,%4\n"
 +#else /* CONFIG_64BIT */
 +		"	sam31\n"
++=======
++>>>>>>> cd4386a931b6 (s390/cpcmd,vmcp: avoid GFP_DMA allocations)
  		"	diag	%2,%0,0x8\n"
- 		"	sam64\n"
  		"	brc	8,1f\n"
  		"	agr	%1,%4\n"
 +#endif /* CONFIG_64BIT */
  		"1:\n"
  		: "+d" (reg4), "+d" (reg5)
  		: "d" (reg2), "d" (reg3), "d" (*rlen) : "cc");
@@@ -96,16 -84,14 +106,15 @@@ EXPORT_SYMBOL(__cpcmd)
  
  int cpcmd(const char *cmd, char *response, int rlen, int *response_code)
  {
+ 	unsigned long flags;
  	char *lowbuf;
  	int len;
- 	unsigned long flags;
  
- 	if ((virt_to_phys(response) != (unsigned long) response) ||
- 			(((unsigned long)response + rlen) >> 31)) {
- 		lowbuf = kmalloc(rlen, GFP_KERNEL | GFP_DMA);
+ 	if (is_vmalloc_or_module_addr(response)) {
+ 		lowbuf = kmalloc(rlen, GFP_KERNEL);
  		if (!lowbuf) {
 -			pr_warn("The cpcmd kernel function failed to allocate a response buffer\n");
 +			pr_warning("The cpcmd kernel function failed to "
 +				   "allocate a response buffer\n");
  			return -ENOMEM;
  		}
  		spin_lock_irqsave(&cpcmd_lock, flags);
diff --cc drivers/s390/char/vmcp.c
index 0fdedadff7bc,b5e3a49745f9..000000000000
--- a/drivers/s390/char/vmcp.c
+++ b/drivers/s390/char/vmcp.c
@@@ -103,7 -98,7 +103,11 @@@ vmcp_write(struct file *file, const cha
  	}
  	if (!session->response)
  		session->response = (char *)__get_free_pages(GFP_KERNEL
++<<<<<<< HEAD
 +						| __GFP_REPEAT | GFP_DMA,
++=======
+ 						| __GFP_RETRY_MAYFAIL,
++>>>>>>> cd4386a931b6 (s390/cpcmd,vmcp: avoid GFP_DMA allocations)
  						get_order(session->bufsize));
  	if (!session->response) {
  		mutex_unlock(&session->mutex);
diff --git a/arch/s390/include/asm/cpcmd.h b/arch/s390/include/asm/cpcmd.h
index 3dfadb5d648f..ca2b0624ad46 100644
--- a/arch/s390/include/asm/cpcmd.h
+++ b/arch/s390/include/asm/cpcmd.h
@@ -10,9 +10,8 @@
 
 /*
  * the lowlevel function for cpcmd
- * the caller of __cpcmd has to ensure that the response buffer is below 2 GB
  */
-extern int __cpcmd(const char *cmd, char *response, int rlen, int *response_code);
+int __cpcmd(const char *cmd, char *response, int rlen, int *response_code);
 
 /*
  * cpcmd is the in-kernel interface for issuing CP commands
@@ -25,8 +24,8 @@ extern int __cpcmd(const char *cmd, char *response, int rlen, int *response_code
  * response_code: return pointer for VM's error code
  * return value: the size of the response. The caller can check if the buffer
  *		was large enough by comparing the return value and rlen
- * NOTE: If the response buffer is not below 2 GB, cpcmd can sleep
+ * NOTE: If the response buffer is not in real storage, cpcmd can sleep
  */
-extern int cpcmd(const char *cmd, char *response, int rlen, int *response_code);
+int cpcmd(const char *cmd, char *response, int rlen, int *response_code);
 
 #endif /* _ASM_S390_CPCMD_H */
* Unmerged path arch/s390/kernel/cpcmd.c
* Unmerged path drivers/s390/char/vmcp.c
