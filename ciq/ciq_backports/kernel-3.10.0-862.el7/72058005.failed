dax: add a facility to lookup a dax device by 'host' device name

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit 72058005411ffddcae6c06f7b691d635489132af
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/72058005.failed

For the current block_device based filesystem-dax path, we need a way
for it to lookup the dax_device associated with a block_device. Add a
'host' property of a dax_device that can be used for this purpose. It is
a free form string, but for a dax_device associated with a block device
it is the bdev name.

This is a stop-gap until filesystems are able to mount on a dax-inode
directly.

	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 72058005411ffddcae6c06f7b691d635489132af)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dax/dax.c
#	drivers/dax/dax.h
#	drivers/dax/super.c
#	include/linux/dax.h
diff --cc drivers/dax/dax.c
index 5e37741e7a4f,db68f4fa8ce0..000000000000
--- a/drivers/dax/dax.c
+++ b/drivers/dax/dax.c
@@@ -714,24 -645,16 +714,30 @@@ struct dax_dev *devm_create_dax_dev(str
  		goto err_id;
  	}
  
++<<<<<<< HEAD:drivers/dax/dax.c
 +	minor = ida_simple_get(&dax_minor_ida, 0, 0, GFP_KERNEL);
 +	if (minor < 0) {
 +		rc = minor;
 +		goto err_minor;
 +	}
 +
 +	dev_t = MKDEV(MAJOR(dax_devt), minor);
 +	dev = &dax_dev->dev;
 +	dax_dev->inode = dax_inode_get(&dax_dev->cdev, dev_t);
 +	if (!dax_dev->inode) {
 +		rc = -ENOMEM;
 +		goto err_inode;
 +	}
++=======
+ 	dax_dev = alloc_dax(dev_dax, NULL);
+ 	if (!dax_dev)
+ 		goto err_dax;
++>>>>>>> 72058005411f (dax: add a facility to lookup a dax device by 'host' device name):drivers/dax/device.c
  
  	/* from here on we're committed to teardown via dax_dev_release() */
 -	dev = &dev_dax->dev;
  	device_initialize(dev);
  
 -	inode = dax_inode(dax_dev);
 -	cdev = inode->i_cdev;
 +	cdev = &dax_dev->cdev;
  	cdev_init(cdev, &dax_fops);
  	cdev->owner = parent->driver->owner;
  
diff --cc drivers/dax/dax.h
index ddd829ab58c0,246a24d68d4c..000000000000
--- a/drivers/dax/dax.h
+++ b/drivers/dax/dax.h
@@@ -12,14 -12,12 +12,25 @@@
   */
  #ifndef __DAX_H__
  #define __DAX_H__
++<<<<<<< HEAD
 +struct device;
 +struct dax_dev;
 +struct resource;
 +struct dax_region;
 +void dax_region_put(struct dax_region *dax_region);
 +struct dax_region *alloc_dax_region(struct device *parent,
 +		int region_id, struct resource *res, unsigned int align,
 +		void *addr, unsigned long flags);
 +struct dax_dev *devm_create_dax_dev(struct dax_region *dax_region,
 +		struct resource *res, int count);
++=======
+ struct dax_device;
+ struct dax_device *alloc_dax(void *private, const char *host);
+ void put_dax(struct dax_device *dax_dev);
+ bool dax_alive(struct dax_device *dax_dev);
+ void kill_dax(struct dax_device *dax_dev);
+ struct dax_device *inode_dax(struct inode *inode);
+ struct inode *dax_inode(struct dax_device *dax_dev);
+ void *dax_get_private(struct dax_device *dax_dev);
++>>>>>>> 72058005411f (dax: add a facility to lookup a dax device by 'host' device name)
  #endif /* __DAX_H__ */
diff --cc include/linux/dax.h
index 8937c7aed5cb,9b2d5ba10d7d..000000000000
--- a/include/linux/dax.h
+++ b/include/linux/dax.h
@@@ -6,29 -6,48 +6,38 @@@
  #include <linux/radix-tree.h>
  #include <asm/pgtable.h>
  
++<<<<<<< HEAD
++=======
+ struct iomap_ops;
+ 
+ int dax_read_lock(void);
+ void dax_read_unlock(int id);
+ struct dax_device *dax_get_by_host(const char *host);
+ 
++>>>>>>> 72058005411f (dax: add a facility to lookup a dax device by 'host' device name)
  /*
 - * We use lowest available bit in exceptional entry for locking, one bit for
 - * the entry size (PMD) and two more to tell us if the entry is a huge zero
 - * page (HZP) or an empty entry that is just used for locking.  In total four
 - * special bits.
 - *
 - * If the PMD bit isn't set the entry has size PAGE_SIZE, and if the HZP and
 - * EMPTY bits aren't set the entry is a normal DAX entry with a filesystem
 - * block allocation.
 + * We use lowest available bit in exceptional entry for locking, other two
 + * bits to determine entry type. In total 3 special bits.
   */
 -#define RADIX_DAX_SHIFT	(RADIX_TREE_EXCEPTIONAL_SHIFT + 4)
 +#define RADIX_DAX_SHIFT	(RADIX_TREE_EXCEPTIONAL_SHIFT + 3)
  #define RADIX_DAX_ENTRY_LOCK (1 << RADIX_TREE_EXCEPTIONAL_SHIFT)
 -#define RADIX_DAX_PMD (1 << (RADIX_TREE_EXCEPTIONAL_SHIFT + 1))
 -#define RADIX_DAX_HZP (1 << (RADIX_TREE_EXCEPTIONAL_SHIFT + 2))
 -#define RADIX_DAX_EMPTY (1 << (RADIX_TREE_EXCEPTIONAL_SHIFT + 3))
 +#define RADIX_DAX_PTE (1 << (RADIX_TREE_EXCEPTIONAL_SHIFT + 1))
 +#define RADIX_DAX_PMD (1 << (RADIX_TREE_EXCEPTIONAL_SHIFT + 2))
 +#define RADIX_DAX_TYPE_MASK (RADIX_DAX_PTE | RADIX_DAX_PMD)
 +#define RADIX_DAX_TYPE(entry) ((unsigned long)entry & RADIX_DAX_TYPE_MASK)
 +#define RADIX_DAX_SECTOR(entry) (((unsigned long)entry >> RADIX_DAX_SHIFT))
 +#define RADIX_DAX_ENTRY(sector, pmd) ((void *)((unsigned long)sector << \
 +		RADIX_DAX_SHIFT | (pmd ? RADIX_DAX_PMD : RADIX_DAX_PTE) | \
 +		RADIX_TREE_EXCEPTIONAL_ENTRY))
  
 -static inline unsigned long dax_radix_sector(void *entry)
 -{
 -	return (unsigned long)entry >> RADIX_DAX_SHIFT;
 -}
 -
 -static inline void *dax_radix_locked_entry(sector_t sector, unsigned long flags)
 -{
 -	return (void *)(RADIX_TREE_EXCEPTIONAL_ENTRY | flags |
 -			((unsigned long)sector << RADIX_DAX_SHIFT) |
 -			RADIX_DAX_ENTRY_LOCK);
 -}
  
 -ssize_t dax_iomap_rw(struct kiocb *iocb, struct iov_iter *iter,
 -		const struct iomap_ops *ops);
 -int dax_iomap_fault(struct vm_fault *vmf, enum page_entry_size pe_size,
 -		    const struct iomap_ops *ops);
 +ssize_t dax_do_io(int rw, struct kiocb *iocb, struct inode *inode,
 +                  const struct iovec *iov, loff_t pos, unsigned long nr_segs,
 +                  get_block_t get_block, dio_iodone_t end_io, int flags);
 +int dax_zero_page_range(struct inode *, loff_t from, unsigned len, get_block_t);
 +int dax_truncate_page(struct inode *, loff_t from, get_block_t);
 +int dax_fault(struct vm_area_struct *, struct vm_fault *, get_block_t);
  int dax_delete_mapping_entry(struct address_space *mapping, pgoff_t index);
 -int dax_invalidate_mapping_entry(struct address_space *mapping, pgoff_t index);
 -int dax_invalidate_mapping_entry_sync(struct address_space *mapping,
 -				      pgoff_t index);
  void dax_wake_mapping_entry_waiter(struct address_space *mapping,
  		pgoff_t index, void *entry, bool wake_all);
  
* Unmerged path drivers/dax/super.c
* Unmerged path drivers/dax/dax.c
* Unmerged path drivers/dax/dax.h
* Unmerged path drivers/dax/super.c
* Unmerged path include/linux/dax.h
