of: Add of_graph_get_port_by_id function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [sound] alsa: of: Add of_graph_get_port_by_id function (Jaroslav Kysela) [1463624]
Rebuild_FUZZ: 93.02%
commit-author Philipp Zabel <p.zabel@pengutronix.de>
commit bfe446e37c4efd8ade454911e8f80414bcbfc10d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/bfe446e3.failed

This patch adds a function to get a port device tree node by port id,
or reg property value.

	Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
	Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
(cherry picked from commit bfe446e37c4efd8ade454911e8f80414bcbfc10d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/of/base.c
#	include/linux/of_graph.h
diff --cc drivers/of/base.c
index b23e1a2e663d,6398b9ca9157..000000000000
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@@ -1922,3 -1998,229 +1922,232 @@@ const char *of_prop_next_string(struct 
  	return curv;
  }
  EXPORT_SYMBOL_GPL(of_prop_next_string);
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * of_console_check() - Test and setup console for DT setup
+  * @dn - Pointer to device node
+  * @name - Name to use for preferred console without index. ex. "ttyS"
+  * @index - Index to use for preferred console.
+  *
+  * Check if the given device node matches the stdout-path property in the
+  * /chosen node. If it does then register it as the preferred console and return
+  * TRUE. Otherwise return FALSE.
+  */
+ bool of_console_check(struct device_node *dn, char *name, int index)
+ {
+ 	if (!dn || dn != of_stdout || console_set_on_cmdline)
+ 		return false;
+ 	return !add_preferred_console(name, index,
+ 				      kstrdup(of_stdout_options, GFP_KERNEL));
+ }
+ EXPORT_SYMBOL_GPL(of_console_check);
+ 
+ /**
+  *	of_find_next_cache_node - Find a node's subsidiary cache
+  *	@np:	node of type "cpu" or "cache"
+  *
+  *	Returns a node pointer with refcount incremented, use
+  *	of_node_put() on it when done.  Caller should hold a reference
+  *	to np.
+  */
+ struct device_node *of_find_next_cache_node(const struct device_node *np)
+ {
+ 	struct device_node *child;
+ 	const phandle *handle;
+ 
+ 	handle = of_get_property(np, "l2-cache", NULL);
+ 	if (!handle)
+ 		handle = of_get_property(np, "next-level-cache", NULL);
+ 
+ 	if (handle)
+ 		return of_find_node_by_phandle(be32_to_cpup(handle));
+ 
+ 	/* OF on pmac has nodes instead of properties named "l2-cache"
+ 	 * beneath CPU nodes.
+ 	 */
+ 	if (!strcmp(np->type, "cpu"))
+ 		for_each_child_of_node(np, child)
+ 			if (!strcmp(child->type, "cache"))
+ 				return child;
+ 
+ 	return NULL;
+ }
+ 
+ /**
+  * of_graph_parse_endpoint() - parse common endpoint node properties
+  * @node: pointer to endpoint device_node
+  * @endpoint: pointer to the OF endpoint data structure
+  *
+  * The caller should hold a reference to @node.
+  */
+ int of_graph_parse_endpoint(const struct device_node *node,
+ 			    struct of_endpoint *endpoint)
+ {
+ 	struct device_node *port_node = of_get_parent(node);
+ 
+ 	WARN_ONCE(!port_node, "%s(): endpoint %s has no parent node\n",
+ 		  __func__, node->full_name);
+ 
+ 	memset(endpoint, 0, sizeof(*endpoint));
+ 
+ 	endpoint->local_node = node;
+ 	/*
+ 	 * It doesn't matter whether the two calls below succeed.
+ 	 * If they don't then the default value 0 is used.
+ 	 */
+ 	of_property_read_u32(port_node, "reg", &endpoint->port);
+ 	of_property_read_u32(node, "reg", &endpoint->id);
+ 
+ 	of_node_put(port_node);
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(of_graph_parse_endpoint);
+ 
+ /**
+  * of_graph_get_port_by_id() - get the port matching a given id
+  * @parent: pointer to the parent device node
+  * @id: id of the port
+  *
+  * Return: A 'port' node pointer with refcount incremented. The caller
+  * has to use of_node_put() on it when done.
+  */
+ struct device_node *of_graph_get_port_by_id(struct device_node *parent, u32 id)
+ {
+ 	struct device_node *node, *port;
+ 
+ 	node = of_get_child_by_name(parent, "ports");
+ 	if (node)
+ 		parent = node;
+ 
+ 	for_each_child_of_node(parent, port) {
+ 		u32 port_id = 0;
+ 
+ 		if (of_node_cmp(port->name, "port") != 0)
+ 			continue;
+ 		of_property_read_u32(port, "reg", &port_id);
+ 		if (id == port_id)
+ 			break;
+ 	}
+ 
+ 	of_node_put(node);
+ 
+ 	return port;
+ }
+ EXPORT_SYMBOL(of_graph_get_port_by_id);
+ 
+ /**
+  * of_graph_get_next_endpoint() - get next endpoint node
+  * @parent: pointer to the parent device node
+  * @prev: previous endpoint node, or NULL to get first
+  *
+  * Return: An 'endpoint' node pointer with refcount incremented. Refcount
+  * of the passed @prev node is decremented.
+  */
+ struct device_node *of_graph_get_next_endpoint(const struct device_node *parent,
+ 					struct device_node *prev)
+ {
+ 	struct device_node *endpoint;
+ 	struct device_node *port;
+ 
+ 	if (!parent)
+ 		return NULL;
+ 
+ 	/*
+ 	 * Start by locating the port node. If no previous endpoint is specified
+ 	 * search for the first port node, otherwise get the previous endpoint
+ 	 * parent port node.
+ 	 */
+ 	if (!prev) {
+ 		struct device_node *node;
+ 
+ 		node = of_get_child_by_name(parent, "ports");
+ 		if (node)
+ 			parent = node;
+ 
+ 		port = of_get_child_by_name(parent, "port");
+ 		of_node_put(node);
+ 
+ 		if (!port) {
+ 			pr_err("%s(): no port node found in %s\n",
+ 			       __func__, parent->full_name);
+ 			return NULL;
+ 		}
+ 	} else {
+ 		port = of_get_parent(prev);
+ 		if (WARN_ONCE(!port, "%s(): endpoint %s has no parent node\n",
+ 			      __func__, prev->full_name))
+ 			return NULL;
+ 	}
+ 
+ 	while (1) {
+ 		/*
+ 		 * Now that we have a port node, get the next endpoint by
+ 		 * getting the next child. If the previous endpoint is NULL this
+ 		 * will return the first child.
+ 		 */
+ 		endpoint = of_get_next_child(port, prev);
+ 		if (endpoint) {
+ 			of_node_put(port);
+ 			return endpoint;
+ 		}
+ 
+ 		/* No more endpoints under this port, try the next one. */
+ 		prev = NULL;
+ 
+ 		do {
+ 			port = of_get_next_child(parent, port);
+ 			if (!port)
+ 				return NULL;
+ 		} while (of_node_cmp(port->name, "port"));
+ 	}
+ }
+ EXPORT_SYMBOL(of_graph_get_next_endpoint);
+ 
+ /**
+  * of_graph_get_remote_port_parent() - get remote port's parent node
+  * @node: pointer to a local endpoint device_node
+  *
+  * Return: Remote device node associated with remote endpoint node linked
+  *	   to @node. Use of_node_put() on it when done.
+  */
+ struct device_node *of_graph_get_remote_port_parent(
+ 			       const struct device_node *node)
+ {
+ 	struct device_node *np;
+ 	unsigned int depth;
+ 
+ 	/* Get remote endpoint node. */
+ 	np = of_parse_phandle(node, "remote-endpoint", 0);
+ 
+ 	/* Walk 3 levels up only if there is 'ports' node. */
+ 	for (depth = 3; depth && np; depth--) {
+ 		np = of_get_next_parent(np);
+ 		if (depth == 2 && of_node_cmp(np->name, "ports"))
+ 			break;
+ 	}
+ 	return np;
+ }
+ EXPORT_SYMBOL(of_graph_get_remote_port_parent);
+ 
+ /**
+  * of_graph_get_remote_port() - get remote port node
+  * @node: pointer to a local endpoint device_node
+  *
+  * Return: Remote port node associated with remote endpoint node linked
+  *	   to @node. Use of_node_put() on it when done.
+  */
+ struct device_node *of_graph_get_remote_port(const struct device_node *node)
+ {
+ 	struct device_node *np;
+ 
+ 	/* Get remote endpoint node. */
+ 	np = of_parse_phandle(node, "remote-endpoint", 0);
+ 	if (!np)
+ 		return NULL;
+ 	return of_get_next_parent(np);
+ }
+ EXPORT_SYMBOL(of_graph_get_remote_port);
++>>>>>>> bfe446e37c4e (of: Add of_graph_get_port_by_id function)
* Unmerged path include/linux/of_graph.h
* Unmerged path drivers/of/base.c
* Unmerged path include/linux/of_graph.h
