nfp: remove automatic caching of HWInfo

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 9baa48859bd31f06b9170e86afd92585ff0bbb1f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9baa4885.failed

Make callers take care of managing life time of HWInfo.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9baa48859bd31f06b9170e86afd92585ff0bbb1f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_app_nic.c
#	drivers/net/ethernet/netronome/nfp/nfp_main.c
#	drivers/net/ethernet/netronome/nfp/nfp_main.h
#	drivers/net/ethernet/netronome/nfp/nfp_net_main.c
#	drivers/net/ethernet/netronome/nfp/nfpcore/nfp_cpp.h
#	drivers/net/ethernet/netronome/nfp/nfpcore/nfp_cppcore.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_main.c
index 813e29b99369,94211e245257..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_main.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_main.c
@@@ -353,16 -358,24 +353,25 @@@ static int nfp_pci_probe(struct pci_de
  		goto err_disable_msix;
  	}
  
+ 	pf->hwinfo = nfp_hwinfo_read(pf->cpp);
+ 
  	dev_info(&pdev->dev, "Assembly: %s%s%s-%s CPLD: %s\n",
- 		 nfp_hwinfo_lookup(pf->cpp, "assembly.vendor"),
- 		 nfp_hwinfo_lookup(pf->cpp, "assembly.partno"),
- 		 nfp_hwinfo_lookup(pf->cpp, "assembly.serial"),
- 		 nfp_hwinfo_lookup(pf->cpp, "assembly.revision"),
- 		 nfp_hwinfo_lookup(pf->cpp, "cpld.version"));
+ 		 nfp_hwinfo_lookup(pf->hwinfo, "assembly.vendor"),
+ 		 nfp_hwinfo_lookup(pf->hwinfo, "assembly.partno"),
+ 		 nfp_hwinfo_lookup(pf->hwinfo, "assembly.serial"),
+ 		 nfp_hwinfo_lookup(pf->hwinfo, "assembly.revision"),
+ 		 nfp_hwinfo_lookup(pf->hwinfo, "cpld.version"));
+ 
++<<<<<<< HEAD
++=======
+ 	err = devlink_register(devlink, &pdev->dev);
+ 	if (err)
+ 		goto err_hwinfo_free;
  
++>>>>>>> 9baa48859bd3 (nfp: remove automatic caching of HWInfo)
  	err = nfp_nsp_init(pdev, pf);
  	if (err)
 -		goto err_devlink_unreg;
 -
 -	pf->rtbl = nfp_rtsym_table_read(pf->cpp);
 +		goto err_cpp_free;
  
  	err = nfp_pcie_sriov_read_nfd_limit(pf);
  	if (err)
@@@ -380,7 -401,12 +389,15 @@@ err_fw_unload
  	if (pf->fw_loaded)
  		nfp_fw_unload(pf);
  	kfree(pf->eth_tbl);
++<<<<<<< HEAD
 +err_cpp_free:
++=======
+ 	kfree(pf->nspi);
+ err_devlink_unreg:
+ 	devlink_unregister(devlink);
+ err_hwinfo_free:
+ 	kfree(pf->hwinfo);
++>>>>>>> 9baa48859bd3 (nfp: remove automatic caching of HWInfo)
  	nfp_cpp_free(pf->cpp);
  err_disable_msix:
  	pci_set_drvdata(pdev, NULL);
diff --cc drivers/net/ethernet/netronome/nfp/nfp_main.h
index 1ac430fbaa18,041643807f7e..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_main.h
+++ b/drivers/net/ethernet/netronome/nfp/nfp_main.h
@@@ -52,6 -54,10 +52,13 @@@ struct pci_dev
  struct nfp_cpp;
  struct nfp_cpp_area;
  struct nfp_eth_table;
++<<<<<<< HEAD
++=======
+ struct nfp_hwinfo;
+ struct nfp_net;
+ struct nfp_nsp_identify;
+ struct nfp_rtsym_table;
++>>>>>>> 9baa48859bd3 (nfp: remove automatic caching of HWInfo)
  
  /**
   * struct nfp_pf - NFP PF-specific device structure
@@@ -64,12 -71,19 +71,18 @@@
   * @limit_vfs:		Number of VFs supported by firmware (~0 for PCI limit)
   * @num_vfs:		Number of SR-IOV VFs enabled
   * @fw_loaded:		Is the firmware loaded?
++<<<<<<< HEAD
++=======
+  * @ctrl_vnic:		Pointer to the control vNIC if available
+  * @rtbl:		RTsym table
+  * @hwinfo:		HWInfo table
++>>>>>>> 9baa48859bd3 (nfp: remove automatic caching of HWInfo)
   * @eth_tbl:		NSP ETH table
 - * @nspi:		NSP identification info
 - * @hwmon_dev:		pointer to hwmon device
   * @ddir:		Per-device debugfs directory
 - * @max_data_vnics:	Number of data vNICs app firmware supports
 - * @num_vnics:		Number of vNICs spawned
 - * @vnics:		Linked list of vNIC structures (struct nfp_net)
 - * @ports:		Linked list of port structures (struct nfp_port)
 + * @num_ports:		Number of adapter ports
 + * @ports:		Linked list of port structures (struct nfp_net)
 + * @port_lock:		Protects @ports, @num_ports, @num_netdevs
   * @port_refresh_work:	Work entry for taking netdevs out
 - * @lock:		Protects all fields which may change after probe
   */
  struct nfp_pf {
  	struct pci_dev *pdev;
@@@ -87,7 -103,14 +100,14 @@@
  
  	bool fw_loaded;
  
++<<<<<<< HEAD
++=======
+ 	struct nfp_net *ctrl_vnic;
+ 
+ 	struct nfp_rtsym_table *rtbl;
+ 	struct nfp_hwinfo *hwinfo;
++>>>>>>> 9baa48859bd3 (nfp: remove automatic caching of HWInfo)
  	struct nfp_eth_table *eth_tbl;
 -	struct nfp_nsp_identify *nspi;
 -
 -	struct device *hwmon_dev;
  
  	struct dentry *ddir;
  
@@@ -102,4 -128,16 +122,17 @@@ extern struct pci_driver nfp_netvf_pci_
  int nfp_net_pci_probe(struct nfp_pf *pf);
  void nfp_net_pci_remove(struct nfp_pf *pf);
  
++<<<<<<< HEAD
++=======
+ int nfp_hwmon_register(struct nfp_pf *pf);
+ void nfp_hwmon_unregister(struct nfp_pf *pf);
+ 
+ struct nfp_eth_table_port *
+ nfp_net_find_port(struct nfp_eth_table *eth_tbl, unsigned int id);
+ void
+ nfp_net_get_mac_addr(struct nfp_pf *pf, struct nfp_net *nn, unsigned int id);
+ 
+ bool nfp_ctrl_tx(struct nfp_net *nn, struct sk_buff *skb);
+ 
++>>>>>>> 9baa48859bd3 (nfp: remove automatic caching of HWInfo)
  #endif /* NFP_MAIN_H */
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_main.c
index 092c7d18f2ec,bc2bc0886176..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
@@@ -130,21 -132,37 +130,35 @@@ err_area
  	return (u8 __iomem *)ERR_PTR(err);
  }
  
++<<<<<<< HEAD
 +static void
 +nfp_net_get_mac_addr_hwinfo(struct nfp_net *nn, struct nfp_cpp *cpp,
 +			    unsigned int id)
++=======
+ /**
+  * nfp_net_get_mac_addr() - Get the MAC address.
+  * @pf:       NFP PF handle
+  * @nn:       NFP Network structure
+  * @id:	      NFP port id
+  *
+  * First try to get the MAC address from NSP ETH table. If that
+  * fails try HWInfo.  As a last resort generate a random address.
+  */
+ void
+ nfp_net_get_mac_addr(struct nfp_pf *pf, struct nfp_net *nn, unsigned int id)
++>>>>>>> 9baa48859bd3 (nfp: remove automatic caching of HWInfo)
  {
 -	struct nfp_eth_table_port *eth_port;
 -	struct nfp_net_dp *dp = &nn->dp;
  	u8 mac_addr[ETH_ALEN];
  	const char *mac_str;
  	char name[32];
  
 -	eth_port = __nfp_port_get_eth_port(nn->port);
 -	if (eth_port) {
 -		ether_addr_copy(dp->netdev->dev_addr, eth_port->mac_addr);
 -		ether_addr_copy(dp->netdev->perm_addr, eth_port->mac_addr);
 -		return;
 -	}
 -
  	snprintf(name, sizeof(name), "eth%d.mac", id);
  
- 	mac_str = nfp_hwinfo_lookup(cpp, name);
+ 	mac_str = nfp_hwinfo_lookup(pf->hwinfo, name);
  	if (!mac_str) {
 -		dev_warn(dp->dev, "Can't lookup MAC address. Generate\n");
 -		eth_hw_addr_random(dp->netdev);
 +		dev_warn(&nn->pdev->dev,
 +			 "Can't lookup MAC address. Generate\n");
 +		eth_hw_addr_random(nn->netdev);
  		return;
  	}
  
@@@ -535,11 -710,10 +549,11 @@@ int nfp_net_pci_probe(struct nfp_pf *pf
  	int stride;
  	int err;
  
 -	INIT_WORK(&pf->port_refresh_work, nfp_net_refresh_vnics);
 +	INIT_WORK(&pf->port_refresh_work, nfp_net_refresh_netdevs);
 +	mutex_init(&pf->port_lock);
  
  	/* Verify that the board has completed initialization */
- 	if (!nfp_is_ready(pf->cpp)) {
+ 	if (!nfp_is_ready(pf)) {
  		nfp_err(pf->cpp, "NFP is not ready for NIC operation.\n");
  		return -EINVAL;
  	}
diff --cc drivers/net/ethernet/netronome/nfp/nfpcore/nfp_cpp.h
index 2aa8e5566012,25a967158ce9..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_cpp.h
+++ b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_cpp.h
@@@ -220,13 -222,6 +220,16 @@@ u32 nfp_cpp_model(struct nfp_cpp *cpp)
  u16 nfp_cpp_interface(struct nfp_cpp *cpp);
  int nfp_cpp_serial(struct nfp_cpp *cpp, const u8 **serial);
  
++<<<<<<< HEAD
 +void *nfp_hwinfo_cache(struct nfp_cpp *cpp);
 +void nfp_hwinfo_cache_set(struct nfp_cpp *cpp, void *val);
 +void *nfp_rtsym_cache(struct nfp_cpp *cpp);
 +void nfp_rtsym_cache_set(struct nfp_cpp *cpp, void *val);
 +
 +void nfp_nffw_cache_flush(struct nfp_cpp *cpp);
 +
++=======
++>>>>>>> 9baa48859bd3 (nfp: remove automatic caching of HWInfo)
  struct nfp_cpp_area *nfp_cpp_area_alloc_with_name(struct nfp_cpp *cpp,
  						  u32 cpp_id,
  						  const char *name,
diff --cc drivers/net/ethernet/netronome/nfp/nfpcore/nfp_cppcore.c
index d56f0eb94c21,9b69dcf87be9..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_cppcore.c
+++ b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_cppcore.c
@@@ -77,10 -76,6 +77,13 @@@ struct nfp_cpp_resource 
   * @serial:		chip serial number
   * @imb_cat_table:	CPP Mapping Table
   *
++<<<<<<< HEAD
 + * Following fields can be used only in probe() or with rtnl held:
 + * @hwinfo:		HWInfo database fetched from the device
 + * @rtsym:		firmware run time symbols
 + *
++=======
++>>>>>>> 9baa48859bd3 (nfp: remove automatic caching of HWInfo)
   * Following fields use explicit locking:
   * @resource_list:	NFP CPP resource list
   * @resource_lock:	protects @resource_list
@@@ -108,9 -103,6 +111,12 @@@ struct nfp_cpp 
  
  	struct mutex area_cache_mutex;
  	struct list_head area_cache_list;
++<<<<<<< HEAD
 +
 +	void *hwinfo;
 +	void *rtsym;
++=======
++>>>>>>> 9baa48859bd3 (nfp: remove automatic caching of HWInfo)
  };
  
  /* Element of the area_cache_list */
@@@ -234,9 -226,6 +240,12 @@@ void nfp_cpp_free(struct nfp_cpp *cpp
  	if (cpp->op->free)
  		cpp->op->free(cpp);
  
++<<<<<<< HEAD
 +	kfree(cpp->hwinfo);
 +	kfree(cpp->rtsym);
 +
++=======
++>>>>>>> 9baa48859bd3 (nfp: remove automatic caching of HWInfo)
  	device_unregister(&cpp->dev);
  
  	kfree(cpp);
@@@ -277,39 -266,6 +286,42 @@@ int nfp_cpp_serial(struct nfp_cpp *cpp
  	return sizeof(cpp->serial);
  }
  
++<<<<<<< HEAD
 +void *nfp_hwinfo_cache(struct nfp_cpp *cpp)
 +{
 +	return cpp->hwinfo;
 +}
 +
 +void nfp_hwinfo_cache_set(struct nfp_cpp *cpp, void *val)
 +{
 +	cpp->hwinfo = val;
 +}
 +
 +void *nfp_rtsym_cache(struct nfp_cpp *cpp)
 +{
 +	return cpp->rtsym;
 +}
 +
 +void nfp_rtsym_cache_set(struct nfp_cpp *cpp, void *val)
 +{
 +	cpp->rtsym = val;
 +}
 +
 +/**
 + * nfp_nffw_cache_flush() - Flush cached firmware information
 + * @cpp:	NFP CPP handle
 + *
 + * Flush cached firmware information.  This function should be called
 + * every time firmware is loaded on unloaded.
 + */
 +void nfp_nffw_cache_flush(struct nfp_cpp *cpp)
 +{
 +	kfree(nfp_rtsym_cache(cpp));
 +	nfp_rtsym_cache_set(cpp, NULL);
 +}
 +
++=======
++>>>>>>> 9baa48859bd3 (nfp: remove automatic caching of HWInfo)
  /**
   * nfp_cpp_area_alloc_with_name() - allocate a new CPP area
   * @cpp:	CPP device handle
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_app_nic.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_app_nic.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_main.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_main.h
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_main.c
diff --git a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp.h b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp.h
index e0224cb05236..368d755a08ba 100644
--- a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp.h
+++ b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp.h
@@ -46,7 +46,9 @@
 
 /* Implemented in nfp_hwinfo.c */
 
-const char *nfp_hwinfo_lookup(struct nfp_cpp *cpp, const char *lookup);
+struct nfp_hwinfo;
+struct nfp_hwinfo *nfp_hwinfo_read(struct nfp_cpp *cpp);
+const char *nfp_hwinfo_lookup(struct nfp_hwinfo *hwinfo, const char *lookup);
 
 /* Implemented in nfp_nsp.c */
 
* Unmerged path drivers/net/ethernet/netronome/nfp/nfpcore/nfp_cpp.h
* Unmerged path drivers/net/ethernet/netronome/nfp/nfpcore/nfp_cppcore.c
diff --git a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_hwinfo.c b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_hwinfo.c
index 8d8f311ffa6e..4f24aff1e772 100644
--- a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_hwinfo.c
+++ b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_hwinfo.c
@@ -178,7 +178,8 @@ hwinfo_db_validate(struct nfp_cpp *cpp, struct nfp_hwinfo *db, u32 len)
 	return hwinfo_db_walk(cpp, db, size);
 }
 
-static int hwinfo_try_fetch(struct nfp_cpp *cpp, size_t *cpp_size)
+static struct nfp_hwinfo *
+hwinfo_try_fetch(struct nfp_cpp *cpp, size_t *cpp_size)
 {
 	struct nfp_hwinfo *header;
 	struct nfp_resource *res;
@@ -196,7 +197,7 @@ static int hwinfo_try_fetch(struct nfp_cpp *cpp, size_t *cpp_size)
 		nfp_resource_release(res);
 
 		if (*cpp_size < HWINFO_SIZE_MIN)
-			return -ENOENT;
+			return NULL;
 	} else if (PTR_ERR(res) == -ENOENT) {
 		/* Try getting the HWInfo table from the 'classic' location */
 		cpp_id = NFP_CPP_ISLAND_ID(NFP_CPP_TARGET_MU,
@@ -204,101 +205,86 @@ static int hwinfo_try_fetch(struct nfp_cpp *cpp, size_t *cpp_size)
 		cpp_addr = 0x30000;
 		*cpp_size = 0x0e000;
 	} else {
-		return PTR_ERR(res);
+		return NULL;
 	}
 
 	db = kmalloc(*cpp_size + 1, GFP_KERNEL);
 	if (!db)
-		return -ENOMEM;
+		return NULL;
 
 	err = nfp_cpp_read(cpp, cpp_id, cpp_addr, db, *cpp_size);
-	if (err != *cpp_size) {
-		kfree(db);
-		return err < 0 ? err : -EIO;
-	}
+	if (err != *cpp_size)
+		goto exit_free;
 
 	header = (void *)db;
-	if (nfp_hwinfo_is_updating(header)) {
-		kfree(db);
-		return -EBUSY;
-	}
+	if (nfp_hwinfo_is_updating(header))
+		goto exit_free;
 
 	if (le32_to_cpu(header->version) != NFP_HWINFO_VERSION_2) {
 		nfp_err(cpp, "Unknown HWInfo version: 0x%08x\n",
 			le32_to_cpu(header->version));
-		kfree(db);
-		return -EINVAL;
+		goto exit_free;
 	}
 
 	/* NULL-terminate for safety */
 	db[*cpp_size] = '\0';
 
-	nfp_hwinfo_cache_set(cpp, db);
-
-	return 0;
+	return (void *)db;
+exit_free:
+	kfree(db);
+	return NULL;
 }
 
-static int hwinfo_fetch(struct nfp_cpp *cpp, size_t *hwdb_size)
+static struct nfp_hwinfo *hwinfo_fetch(struct nfp_cpp *cpp, size_t *hwdb_size)
 {
 	const unsigned long wait_until = jiffies + HWINFO_WAIT * HZ;
+	struct nfp_hwinfo *db;
 	int err;
 
 	for (;;) {
 		const unsigned long start_time = jiffies;
 
-		err = hwinfo_try_fetch(cpp, hwdb_size);
-		if (!err)
-			return 0;
+		db = hwinfo_try_fetch(cpp, hwdb_size);
+		if (db)
+			return db;
 
 		err = msleep_interruptible(100);
 		if (err || time_after(start_time, wait_until)) {
 			nfp_err(cpp, "NFP access error\n");
-			return -EIO;
+			return NULL;
 		}
 	}
 }
 
-static int nfp_hwinfo_load(struct nfp_cpp *cpp)
+struct nfp_hwinfo *nfp_hwinfo_read(struct nfp_cpp *cpp)
 {
 	struct nfp_hwinfo *db;
 	size_t hwdb_size = 0;
 	int err;
 
-	err = hwinfo_fetch(cpp, &hwdb_size);
-	if (err)
-		return err;
+	db = hwinfo_fetch(cpp, &hwdb_size);
+	if (!db)
+		return NULL;
 
-	db = nfp_hwinfo_cache(cpp);
 	err = hwinfo_db_validate(cpp, db, hwdb_size);
 	if (err) {
 		kfree(db);
-		nfp_hwinfo_cache_set(cpp, NULL);
-		return err;
+		return NULL;
 	}
 
-	return 0;
+	return db;
 }
 
 /**
  * nfp_hwinfo_lookup() - Find a value in the HWInfo table by name
- * @cpp:	NFP CPP handle
+ * @hwinfo:	NFP HWinfo table
  * @lookup:	HWInfo name to search for
  *
  * Return: Value of the HWInfo name, or NULL
  */
-const char *nfp_hwinfo_lookup(struct nfp_cpp *cpp, const char *lookup)
+const char *nfp_hwinfo_lookup(struct nfp_hwinfo *hwinfo, const char *lookup)
 {
 	const char *key, *val, *end;
-	struct nfp_hwinfo *hwinfo;
-	int err;
-
-	hwinfo = nfp_hwinfo_cache(cpp);
-	if (!hwinfo) {
-		err = nfp_hwinfo_load(cpp);
-		if (err)
-			return NULL;
-		hwinfo = nfp_hwinfo_cache(cpp);
-	}
 
 	if (!hwinfo || !lookup)
 		return NULL;
