qla2xxx: Fix request queue corruption.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Fix request queue corruption (Himanshu Madhani) [1460030]
Rebuild_FUZZ: 98.67%
commit-author Quinn Tran <quinn.tran@cavium.com>
commit 8b666809e10cda9814af3e8be339d35b83909056
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8b666809.failed

When FW notify driver or driver detects low FW resource,
driver tries to send out Busy SCSI Status to tell Initiator
side to back off. During the send process, the lock was not held.

	Cc: <stable@vger.kernel.org>
	Signed-off-by: Quinn Tran <quinn.tran@qlogic.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 8b666809e10cda9814af3e8be339d35b83909056)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_target.c
diff --cc drivers/scsi/qla2xxx/qla_target.c
index f10c075d97ef,a463bcc57902..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -3635,6 -4907,195 +3635,198 @@@ static void qlt_send_busy(struct scsi_q
  	/* Memory Barrier */
  	wmb();
  	qla2x00_start_iocbs(vha, vha->req);
++<<<<<<< HEAD
++=======
+ 	return 0;
+ }
+ 
+ /*
+  * This routine is used to allocate a command for either a QFull condition
+  * (ie reply SAM_STAT_BUSY) or to terminate an exchange that did not go
+  * out previously.
+  */
+ static void
+ qlt_alloc_qfull_cmd(struct scsi_qla_host *vha,
+ 	struct atio_from_isp *atio, uint16_t status, int qfull)
+ {
+ 	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct fc_port *sess;
+ 	struct se_session *se_sess;
+ 	struct qla_tgt_cmd *cmd;
+ 	int tag;
+ 
+ 	if (unlikely(tgt->tgt_stop)) {
+ 		ql_dbg(ql_dbg_io, vha, 0x300a,
+ 			"New command while device %p is shutting down\n", tgt);
+ 		return;
+ 	}
+ 
+ 	if ((vha->hw->tgt.num_qfull_cmds_alloc + 1) > MAX_QFULL_CMDS_ALLOC) {
+ 		vha->hw->tgt.num_qfull_cmds_dropped++;
+ 		if (vha->hw->tgt.num_qfull_cmds_dropped >
+ 			vha->qla_stats.stat_max_qfull_cmds_dropped)
+ 			vha->qla_stats.stat_max_qfull_cmds_dropped =
+ 				vha->hw->tgt.num_qfull_cmds_dropped;
+ 
+ 		ql_dbg(ql_dbg_io, vha, 0x3068,
+ 			"qla_target(%d): %s: QFull CMD dropped[%d]\n",
+ 			vha->vp_idx, __func__,
+ 			vha->hw->tgt.num_qfull_cmds_dropped);
+ 
+ 		qlt_chk_exch_leak_thresh_hold(vha);
+ 		return;
+ 	}
+ 
+ 	sess = ha->tgt.tgt_ops->find_sess_by_s_id
+ 		(vha, atio->u.isp24.fcp_hdr.s_id);
+ 	if (!sess)
+ 		return;
+ 
+ 	se_sess = sess->se_sess;
+ 
+ 	tag = percpu_ida_alloc(&se_sess->sess_tag_pool, TASK_RUNNING);
+ 	if (tag < 0)
+ 		return;
+ 
+ 	cmd = &((struct qla_tgt_cmd *)se_sess->sess_cmd_map)[tag];
+ 	if (!cmd) {
+ 		ql_dbg(ql_dbg_io, vha, 0x3009,
+ 			"qla_target(%d): %s: Allocation of cmd failed\n",
+ 			vha->vp_idx, __func__);
+ 
+ 		vha->hw->tgt.num_qfull_cmds_dropped++;
+ 		if (vha->hw->tgt.num_qfull_cmds_dropped >
+ 			vha->qla_stats.stat_max_qfull_cmds_dropped)
+ 			vha->qla_stats.stat_max_qfull_cmds_dropped =
+ 				vha->hw->tgt.num_qfull_cmds_dropped;
+ 
+ 		qlt_chk_exch_leak_thresh_hold(vha);
+ 		return;
+ 	}
+ 
+ 	memset(cmd, 0, sizeof(struct qla_tgt_cmd));
+ 
+ 	qlt_incr_num_pend_cmds(vha);
+ 	INIT_LIST_HEAD(&cmd->cmd_list);
+ 	memcpy(&cmd->atio, atio, sizeof(*atio));
+ 
+ 	cmd->tgt = vha->vha_tgt.qla_tgt;
+ 	cmd->vha = vha;
+ 	cmd->reset_count = vha->hw->chip_reset;
+ 	cmd->q_full = 1;
+ 
+ 	if (qfull) {
+ 		cmd->q_full = 1;
+ 		/* NOTE: borrowing the state field to carry the status */
+ 		cmd->state = status;
+ 	} else
+ 		cmd->term_exchg = 1;
+ 
+ 	list_add_tail(&cmd->cmd_list, &vha->hw->tgt.q_full_list);
+ 
+ 	vha->hw->tgt.num_qfull_cmds_alloc++;
+ 	if (vha->hw->tgt.num_qfull_cmds_alloc >
+ 		vha->qla_stats.stat_max_qfull_cmds_alloc)
+ 		vha->qla_stats.stat_max_qfull_cmds_alloc =
+ 			vha->hw->tgt.num_qfull_cmds_alloc;
+ }
+ 
+ int
+ qlt_free_qfull_cmds(struct scsi_qla_host *vha)
+ {
+ 	struct qla_hw_data *ha = vha->hw;
+ 	unsigned long flags;
+ 	struct qla_tgt_cmd *cmd, *tcmd;
+ 	struct list_head free_list;
+ 	int rc = 0;
+ 
+ 	if (list_empty(&ha->tgt.q_full_list))
+ 		return 0;
+ 
+ 	INIT_LIST_HEAD(&free_list);
+ 
+ 	spin_lock_irqsave(&vha->hw->hardware_lock, flags);
+ 
+ 	if (list_empty(&ha->tgt.q_full_list)) {
+ 		spin_unlock_irqrestore(&vha->hw->hardware_lock, flags);
+ 		return 0;
+ 	}
+ 
+ 	list_for_each_entry_safe(cmd, tcmd, &ha->tgt.q_full_list, cmd_list) {
+ 		if (cmd->q_full)
+ 			/* cmd->state is a borrowed field to hold status */
+ 			rc = __qlt_send_busy(vha, &cmd->atio, cmd->state);
+ 		else if (cmd->term_exchg)
+ 			rc = __qlt_send_term_exchange(vha, NULL, &cmd->atio);
+ 
+ 		if (rc == -ENOMEM)
+ 			break;
+ 
+ 		if (cmd->q_full)
+ 			ql_dbg(ql_dbg_io, vha, 0x3006,
+ 			    "%s: busy sent for ox_id[%04x]\n", __func__,
+ 			    be16_to_cpu(cmd->atio.u.isp24.fcp_hdr.ox_id));
+ 		else if (cmd->term_exchg)
+ 			ql_dbg(ql_dbg_io, vha, 0x3007,
+ 			    "%s: Term exchg sent for ox_id[%04x]\n", __func__,
+ 			    be16_to_cpu(cmd->atio.u.isp24.fcp_hdr.ox_id));
+ 		else
+ 			ql_dbg(ql_dbg_io, vha, 0x3008,
+ 			    "%s: Unexpected cmd in QFull list %p\n", __func__,
+ 			    cmd);
+ 
+ 		list_del(&cmd->cmd_list);
+ 		list_add_tail(&cmd->cmd_list, &free_list);
+ 
+ 		/* piggy back on hardware_lock for protection */
+ 		vha->hw->tgt.num_qfull_cmds_alloc--;
+ 	}
+ 	spin_unlock_irqrestore(&vha->hw->hardware_lock, flags);
+ 
+ 	cmd = NULL;
+ 
+ 	list_for_each_entry_safe(cmd, tcmd, &free_list, cmd_list) {
+ 		list_del(&cmd->cmd_list);
+ 		/* This cmd was never sent to TCM.  There is no need
+ 		 * to schedule free or call free_cmd
+ 		 */
+ 		qlt_free_cmd(cmd);
+ 	}
+ 	return rc;
+ }
+ 
+ static void
+ qlt_send_busy(struct scsi_qla_host *vha,
+ 	struct atio_from_isp *atio, uint16_t status)
+ {
+ 	int rc = 0;
+ 
+ 	rc = __qlt_send_busy(vha, atio, status);
+ 	if (rc == -ENOMEM)
+ 		qlt_alloc_qfull_cmd(vha, atio, status, 1);
+ }
+ 
+ static int
+ qlt_chk_qfull_thresh_hold(struct scsi_qla_host *vha,
+ 	struct atio_from_isp *atio, bool ha_locked)
+ {
+ 	struct qla_hw_data *ha = vha->hw;
+ 	uint16_t status;
+ 	unsigned long flags;
+ 
+ 	if (ha->tgt.num_pend_cmds < Q_FULL_THRESH_HOLD(ha))
+ 		return 0;
+ 
+ 	if (!ha_locked)
+ 		spin_lock_irqsave(&ha->hardware_lock, flags);
+ 	status = temp_sam_status;
+ 	qlt_send_busy(vha, atio, status);
+ 	if (!ha_locked)
+ 		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+ 
+ 	return 1;
++>>>>>>> 8b666809e10c (qla2xxx: Fix request queue corruption.)
  }
  
  /* ha->hardware_lock supposed to be held on entry */
@@@ -3684,15 -5128,32 +3876,27 @@@ static void qlt_24xx_atio_pkt(struct sc
  			    "qla_target(%d): ATIO_TYPE7 "
  			    "received with UNKNOWN exchange address, "
  			    "sending QUEUE_FULL\n", vha->vp_idx);
 -			if (!ha_locked)
 -				spin_lock_irqsave(&ha->hardware_lock, flags);
  			qlt_send_busy(vha, atio, SAM_STAT_TASK_SET_FULL);
 -			if (!ha_locked)
 -				spin_unlock_irqrestore(&ha->hardware_lock, flags);
  			break;
  		}
++<<<<<<< HEAD
 +		if (likely(atio->u.isp24.fcp_cmnd.task_mgmt_flags == 0))
++=======
+ 
+ 
+ 
+ 		if (likely(atio->u.isp24.fcp_cmnd.task_mgmt_flags == 0)) {
+ 			rc = qlt_chk_qfull_thresh_hold(vha, atio, ha_locked);
+ 			if (rc != 0) {
+ 				tgt->atio_irq_cmd_count--;
+ 				return;
+ 			}
++>>>>>>> 8b666809e10c (qla2xxx: Fix request queue corruption.)
  			rc = qlt_handle_cmd_for_atio(vha, atio);
 -		} else {
 +		else
  			rc = qlt_handle_task_mgmt(vha, atio);
 -		}
  		if (unlikely(rc != 0)) {
  			if (rc == -ESRCH) {
 -				if (!ha_locked)
 -					spin_lock_irqsave
 -						(&ha->hardware_lock, flags);
 -
  #if 1 /* With TERM EXCHANGE some FC cards refuse to boot */
  				qlt_send_busy(vha, atio, SAM_STAT_BUSY);
  #else
@@@ -3799,10 -5261,12 +4003,19 @@@ static void qlt_response_pkt(struct scs
  			    le16_to_cpu(atio->u.isp2x.status));
  			break;
  		}
++<<<<<<< HEAD
 +		ql_dbg(ql_dbg_tgt, vha, 0xe032,
 +		    "FCP CDB: 0x%02x, sizeof(cdb): %lu",
 +		    atio->u.isp2x.cdb[0], (unsigned long
 +		    int)sizeof(atio->u.isp2x.cdb));
++=======
+ 
+ 		rc = qlt_chk_qfull_thresh_hold(vha, atio, true);
+ 		if (rc != 0) {
+ 			tgt->irq_cmd_count--;
+ 			return;
+ 		}
++>>>>>>> 8b666809e10c (qla2xxx: Fix request queue corruption.)
  
  		rc = qlt_handle_cmd_for_atio(vha, atio);
  		if (unlikely(rc != 0)) {
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
