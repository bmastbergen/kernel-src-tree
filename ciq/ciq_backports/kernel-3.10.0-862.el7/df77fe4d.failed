ipv6: fib: Add in-kernel notifications for route add / delete

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ido Schimmel <idosch@mellanox.com>
commit df77fe4d9865c6354372876632bcbceeda84f6c8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/df77fe4d.failed

As with IPv4, allow listeners of the FIB notification chain to receive
notifications whenever a route is added, replaced or deleted. This is
done by placing calls to the FIB notification chain in the two lowest
level functions that end up performing these operations - namely,
fib6_add_rt2node() and fib6_del_route().

Unlike IPv4, APPEND notifications aren't sent as the kernel doesn't
distinguish between "append" (NLM_F_CREATE|NLM_F_APPEND) and "prepend"
(NLM_F_CREATE). If NLM_F_EXCL isn't set, duplicate routes are always
added after the existing duplicate routes.

	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit df77fe4d9865c6354372876632bcbceeda84f6c8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_fib.c
diff --cc net/ipv6/ip6_fib.c
index 2dd41679dc89,595a57cbbc7b..000000000000
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@@ -859,7 -891,10 +871,14 @@@ add
  		*ins = rt;
  		rt->rt6i_node = fn;
  		atomic_inc(&rt->rt6i_ref);
++<<<<<<< HEAD
 +		inet6_rt_notify(RTM_NEWROUTE, rt, info);
++=======
+ 		call_fib6_entry_notifiers(info->nl_net, FIB_EVENT_ENTRY_ADD,
+ 					  rt);
+ 		if (!info->skip_notify)
+ 			inet6_rt_notify(RTM_NEWROUTE, rt, info, nlflags);
++>>>>>>> df77fe4d9865 (ipv6: fib: Add in-kernel notifications for route add / delete)
  		info->nl_net->ipv6.rt6_stats->fib_rt_entries++;
  
  		if (!(fn->fn_flags & RTN_RTINFO)) {
@@@ -885,7 -920,10 +904,14 @@@
  		rt->rt6i_node = fn;
  		rt->dst.rt6_next = iter->dst.rt6_next;
  		atomic_inc(&rt->rt6i_ref);
++<<<<<<< HEAD
 +		inet6_rt_notify(RTM_NEWROUTE, rt, info);
++=======
+ 		call_fib6_entry_notifiers(info->nl_net, FIB_EVENT_ENTRY_REPLACE,
+ 					  rt);
+ 		if (!info->skip_notify)
+ 			inet6_rt_notify(RTM_NEWROUTE, rt, info, NLM_F_REPLACE);
++>>>>>>> df77fe4d9865 (ipv6: fib: Add in-kernel notifications for route add / delete)
  		if (!(fn->fn_flags & RTN_RTINFO)) {
  			info->nl_net->ipv6.rt6_stats->fib_route_nodes++;
  			fn->fn_flags |= RTN_RTINFO;
@@@ -1427,7 -1475,9 +1453,13 @@@ static void fib6_del_route(struct fib6_
  
  	fib6_purge_rt(rt, fn, net);
  
++<<<<<<< HEAD
 +	inet6_rt_notify(RTM_DELROUTE, rt, info);
++=======
+ 	call_fib6_entry_notifiers(net, FIB_EVENT_ENTRY_DEL, rt);
+ 	if (!info->skip_notify)
+ 		inet6_rt_notify(RTM_DELROUTE, rt, info, 0);
++>>>>>>> df77fe4d9865 (ipv6: fib: Add in-kernel notifications for route add / delete)
  	rt6_release(rt);
  }
  
diff --git a/include/net/ip6_fib.h b/include/net/ip6_fib.h
index 2ee17a3a8c5d..c30ab1401971 100644
--- a/include/net/ip6_fib.h
+++ b/include/net/ip6_fib.h
@@ -259,6 +259,11 @@ typedef struct rt6_info *(*pol_lookup_t)(struct net *,
 					 struct fib6_table *,
 					 struct flowi6 *, int);
 
+struct fib6_entry_notifier_info {
+	struct fib_notifier_info info; /* must be first */
+	struct rt6_info *rt;
+};
+
 /*
  *	exported functions
  */
* Unmerged path net/ipv6/ip6_fib.c
