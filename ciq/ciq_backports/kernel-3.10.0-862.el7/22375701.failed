block_dev: remove DAX leftovers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 223757016837d5bc8546c5683e13fbafe6cb374d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/22375701.failed

DAX support for block devices was removed in commits 03cdad
("block: disable block device DAX by default") and 99a01cd
("block: remove BLK_DEV_DAX config option"), but we still kept a call to
dax_do_io and some uneeded i_flags manipulations introduced in commit
bbab37 ("block: Add support for DAX reads/writes to block devices").

Remove those leftovers.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Acked-by: Dan Williams <dan.j.williams@intel.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 223757016837d5bc8546c5683e13fbafe6cb374d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/block_dev.c
diff --cc fs/block_dev.c
index ed7207dfa086,a516568f63b6..000000000000
--- a/fs/block_dev.c
+++ b/fs/block_dev.c
@@@ -187,11 -180,8 +187,16 @@@ blkdev_direct_IO(int rw, struct kiocb *
  	struct file *file = iocb->ki_filp;
  	struct inode *inode = bdev_file_inode(file);
  
++<<<<<<< HEAD
 +	if (IS_DAX(inode))
 +		return dax_do_io(rw, iocb, inode, iov, offset, nr_segs,
 +				 blkdev_get_block, NULL, DIO_SKIP_DIO_COUNT);
 +	return __blockdev_direct_IO(rw, iocb, inode, I_BDEV(inode), iov, offset,
 +				    nr_segs, blkdev_get_block, NULL, NULL,
++=======
+ 	return __blockdev_direct_IO(iocb, inode, I_BDEV(inode), iter,
+ 				    blkdev_get_block, NULL, NULL,
++>>>>>>> 223757016837 (block_dev: remove DAX leftovers)
  				    DIO_SKIP_DIO_COUNT);
  }
  
@@@ -1289,11 -1272,8 +1294,10 @@@ static int __blkdev_get(struct block_de
  		bdev->bd_disk = disk;
  		bdev->bd_queue = disk->queue;
  		bdev->bd_contains = bdev;
- 		bdev->bd_inode->i_flags = 0;
  
  		if (!partno) {
 +			struct backing_dev_info *bdi;
 +
  			ret = -ENXIO;
  			bdev->bd_part = disk_get_part(disk, partno);
  			if (!bdev->bd_part)
@@@ -1319,11 -1299,8 +1323,14 @@@
  				}
  			}
  
- 			if (!ret) {
+ 			if (!ret)
  				bd_set_size(bdev,(loff_t)get_capacity(disk)<<9);
++<<<<<<< HEAD
 +				bdi = blk_get_backing_dev_info(bdev);
 +				bdev_inode_switch_bdi(bdev->bd_inode, bdi);
 +			}
++=======
++>>>>>>> 223757016837 (block_dev: remove DAX leftovers)
  
  			/*
  			 * If the device is invalidated, rescan partition
* Unmerged path fs/block_dev.c
