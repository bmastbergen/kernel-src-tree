KVM: x86: Fix CPUID function for word 6 (80000001_ECX)

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] KVM: Fix CPUID function for word 6 (80000001_ECX) (Wei Huang) [1533358]
Rebuild_FUZZ: 95.15%
commit-author Janakarajan Natarajan <Janakarajan.Natarajan@amd.com>
commit 50a671d4d15b859f447fa527191073019b6ce9cb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/50a671d4.failed

The function for CPUID 80000001 ECX is set to 0xc0000001. Set it to
0x80000001.

	Signed-off-by: Janakarajan Natarajan <Janakarajan.Natarajan@amd.com>
	Reviewed-by: Jim Mattson <jmattson@google.com>
	Reviewed-by: Krish Sadhukhan <krish.sadhukhan@oracle.com>
	Reviewed-by: Borislav Petkov <bp@suse.de>
Fixes: d6321d493319 ("KVM: x86: generalize guest_cpuid_has_ helpers")
	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
(cherry picked from commit 50a671d4d15b859f447fa527191073019b6ce9cb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/cpuid.h
diff --cc arch/x86/kvm/cpuid.h
index df84d0fbb2f9,c2cea6651279..000000000000
--- a/arch/x86/kvm/cpuid.h
+++ b/arch/x86/kvm/cpuid.h
@@@ -28,58 -32,89 +28,86 @@@ static inline int cpuid_maxphyaddr(stru
  	return vcpu->arch.maxphyaddr;
  }
  
++<<<<<<< HEAD
 +static inline bool guest_cpuid_has_xsave(struct kvm_vcpu *vcpu)
++=======
+ struct cpuid_reg {
+ 	u32 function;
+ 	u32 index;
+ 	int reg;
+ };
+ 
+ static const struct cpuid_reg reverse_cpuid[] = {
+ 	[CPUID_1_EDX]         = {         1, 0, CPUID_EDX},
+ 	[CPUID_8000_0001_EDX] = {0x80000001, 0, CPUID_EDX},
+ 	[CPUID_8086_0001_EDX] = {0x80860001, 0, CPUID_EDX},
+ 	[CPUID_1_ECX]         = {         1, 0, CPUID_ECX},
+ 	[CPUID_C000_0001_EDX] = {0xc0000001, 0, CPUID_EDX},
+ 	[CPUID_8000_0001_ECX] = {0x80000001, 0, CPUID_ECX},
+ 	[CPUID_7_0_EBX]       = {         7, 0, CPUID_EBX},
+ 	[CPUID_D_1_EAX]       = {       0xd, 1, CPUID_EAX},
+ 	[CPUID_F_0_EDX]       = {       0xf, 0, CPUID_EDX},
+ 	[CPUID_F_1_EDX]       = {       0xf, 1, CPUID_EDX},
+ 	[CPUID_8000_0008_EBX] = {0x80000008, 0, CPUID_EBX},
+ 	[CPUID_6_EAX]         = {         6, 0, CPUID_EAX},
+ 	[CPUID_8000_000A_EDX] = {0x8000000a, 0, CPUID_EDX},
+ 	[CPUID_7_ECX]         = {         7, 0, CPUID_ECX},
+ 	[CPUID_8000_0007_EBX] = {0x80000007, 0, CPUID_EBX},
+ };
+ 
+ static __always_inline struct cpuid_reg x86_feature_cpuid(unsigned x86_feature)
++>>>>>>> 50a671d4d15b (KVM: x86: Fix CPUID function for word 6 (80000001_ECX))
  {
 -	unsigned x86_leaf = x86_feature / 32;
 +	struct kvm_cpuid_entry2 *best;
  
 -	BUILD_BUG_ON(x86_leaf >= ARRAY_SIZE(reverse_cpuid));
 -	BUILD_BUG_ON(reverse_cpuid[x86_leaf].function == 0);
 +	if (!static_cpu_has(X86_FEATURE_XSAVE))
 +		return false;
  
 -	return reverse_cpuid[x86_leaf];
 +	best = kvm_find_cpuid_entry(vcpu, 1, 0);
 +	return best && (best->ecx & bit(X86_FEATURE_XSAVE));
  }
  
 -static __always_inline int *guest_cpuid_get_register(struct kvm_vcpu *vcpu, unsigned x86_feature)
 +static inline bool guest_cpuid_has_mtrr(struct kvm_vcpu *vcpu)
  {
 -	struct kvm_cpuid_entry2 *entry;
 -	const struct cpuid_reg cpuid = x86_feature_cpuid(x86_feature);
 +	struct kvm_cpuid_entry2 *best;
  
 -	entry = kvm_find_cpuid_entry(vcpu, cpuid.function, cpuid.index);
 -	if (!entry)
 -		return NULL;
 +	best = kvm_find_cpuid_entry(vcpu, 1, 0);
 +	return best && (best->edx & bit(X86_FEATURE_MTRR));
 +}
  
 -	switch (cpuid.reg) {
 -	case CPUID_EAX:
 -		return &entry->eax;
 -	case CPUID_EBX:
 -		return &entry->ebx;
 -	case CPUID_ECX:
 -		return &entry->ecx;
 -	case CPUID_EDX:
 -		return &entry->edx;
 -	default:
 -		BUILD_BUG();
 -		return NULL;
 -	}
 +static inline bool guest_cpuid_has_tsc_adjust(struct kvm_vcpu *vcpu)
 +{
 +	struct kvm_cpuid_entry2 *best;
 +
 +	best = kvm_find_cpuid_entry(vcpu, 7, 0);
 +	return best && (best->ebx & bit(X86_FEATURE_TSC_ADJUST));
  }
  
 -static __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu, unsigned x86_feature)
 +static inline bool guest_cpuid_has_smep(struct kvm_vcpu *vcpu)
  {
 -	int *reg;
 +	struct kvm_cpuid_entry2 *best;
  
 -	if (x86_feature == X86_FEATURE_XSAVE &&
 -			!static_cpu_has(X86_FEATURE_XSAVE))
 -		return false;
 +	best = kvm_find_cpuid_entry(vcpu, 7, 0);
 +	return best && (best->ebx & bit(X86_FEATURE_SMEP));
 +}
  
 -	reg = guest_cpuid_get_register(vcpu, x86_feature);
 -	if (!reg)
 -		return false;
 +static inline bool guest_cpuid_has_smap(struct kvm_vcpu *vcpu)
 +{
 +	struct kvm_cpuid_entry2 *best;
  
 -	return *reg & bit(x86_feature);
 +	best = kvm_find_cpuid_entry(vcpu, 7, 0);
 +	return best && (best->ebx & bit(X86_FEATURE_SMAP));
  }
  
 -static __always_inline void guest_cpuid_clear(struct kvm_vcpu *vcpu, unsigned x86_feature)
 +static inline bool guest_cpuid_has_fsgsbase(struct kvm_vcpu *vcpu)
  {
 -	int *reg;
 +	struct kvm_cpuid_entry2 *best;
  
 -	reg = guest_cpuid_get_register(vcpu, x86_feature);
 -	if (reg)
 -		*reg &= ~bit(x86_feature);
 +	best = kvm_find_cpuid_entry(vcpu, 7, 0);
 +	return best && (best->ebx & bit(X86_FEATURE_FSGSBASE));
  }
  
 -static inline bool guest_cpuid_is_amd(struct kvm_vcpu *vcpu)
 +static inline bool guest_cpuid_has_longmode(struct kvm_vcpu *vcpu)
  {
  	struct kvm_cpuid_entry2 *best;
  
* Unmerged path arch/x86/kvm/cpuid.h
