scsi_dh_alua: use unique device id

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Hannes Reinecke <hare@suse.de>
commit 0047220c6c3641eeaf0460fb1cc8bbb7f81bd47e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0047220c.failed

Use scsi_vpd_lun_id() to assign a unique device identification
to the alua port group structure.

	Reviewed-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 0047220c6c3641eeaf0460fb1cc8bbb7f81bd47e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/device_handler/scsi_dh_alua.c
diff --cc drivers/scsi/device_handler/scsi_dh_alua.c
index 9c9d9c3d8e9b,0bcd901a6435..000000000000
--- a/drivers/scsi/device_handler/scsi_dh_alua.c
+++ b/drivers/scsi/device_handler/scsi_dh_alua.c
@@@ -64,10 -64,15 +64,21 @@@
  #define ALUA_OPTIMIZE_STPG		1
  #define ALUA_RTPG_EXT_HDR_UNSUPP	2
  
++<<<<<<< HEAD
 +struct alua_dh_data {
 +	struct scsi_dh_data	dh_data;
++=======
+ static LIST_HEAD(port_group_list);
+ static DEFINE_SPINLOCK(port_group_lock);
+ 
+ struct alua_port_group {
+ 	struct kref		kref;
+ 	struct list_head	node;
+ 	unsigned char		device_id_str[256];
+ 	int			device_id_len;
++>>>>>>> 0047220c6c36 (scsi_dh_alua: use unique device id)
  	int			group_id;
 +	int			rel_port;
  	int			tpgs;
  	int			state;
  	int			pref;
@@@ -165,7 -164,78 +176,81 @@@ static int submit_stpg(struct scsi_devi
  				      ALUA_FAILOVER_RETRIES, NULL, req_flags);
  }
  
+ struct alua_port_group *alua_find_get_pg(char *id_str, size_t id_size,
+ 					 int group_id)
+ {
+ 	struct alua_port_group *pg;
+ 
+ 	list_for_each_entry(pg, &port_group_list, node) {
+ 		if (pg->group_id != group_id)
+ 			continue;
+ 		if (pg->device_id_len != id_size)
+ 			continue;
+ 		if (strncmp(pg->device_id_str, id_str, id_size))
+ 			continue;
+ 		if (!kref_get_unless_zero(&pg->kref))
+ 			continue;
+ 		return pg;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ /*
++<<<<<<< HEAD
++=======
+  * alua_alloc_pg - Allocate a new port_group structure
+  * @sdev: scsi device
+  * @h: alua device_handler data
+  * @group_id: port group id
+  *
+  * Allocate a new port_group structure for a given
+  * device.
+  */
+ struct alua_port_group *alua_alloc_pg(struct scsi_device *sdev,
+ 				      int group_id, int tpgs)
+ {
+ 	struct alua_port_group *pg, *tmp_pg;
+ 
+ 	pg = kzalloc(sizeof(struct alua_port_group), GFP_KERNEL);
+ 	if (!pg)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	pg->device_id_len = scsi_vpd_lun_id(sdev, pg->device_id_str,
+ 					    sizeof(pg->device_id_str));
+ 	if (pg->device_id_len <= 0) {
+ 		/*
+ 		 * Internal error: TPGS supported but no device
+ 		 * identifcation found. Disable ALUA support.
+ 		 */
+ 		kfree(pg);
+ 		sdev_printk(KERN_INFO, sdev,
+ 			    "%s: No device descriptors found\n",
+ 			    ALUA_DH_NAME);
+ 		return ERR_PTR(-ENXIO);
+ 	}
+ 	pg->group_id = group_id;
+ 	pg->tpgs = tpgs;
+ 	pg->state = TPGS_STATE_OPTIMIZED;
+ 	kref_init(&pg->kref);
+ 
+ 	spin_lock(&port_group_lock);
+ 	tmp_pg = alua_find_get_pg(pg->device_id_str, pg->device_id_len,
+ 				  group_id);
+ 	if (tmp_pg) {
+ 		spin_unlock(&port_group_lock);
+ 		kfree(pg);
+ 		return tmp_pg;
+ 	}
+ 
+ 	list_add(&pg->node, &port_group_list);
+ 	spin_unlock(&port_group_lock);
+ 
+ 	return pg;
+ }
+ 
  /*
++>>>>>>> 0047220c6c36 (scsi_dh_alua: use unique device id)
   * alua_check_tpgs - Evaluate TPGS setting
   * @sdev: device to be checked
   *
@@@ -560,10 -640,15 +645,17 @@@ static int alua_initialize(struct scsi_
  	if (err != SCSI_DH_OK)
  		goto out;
  
++<<<<<<< HEAD
 +	err = alua_rtpg(sdev, h, 0);
 +	if (err != SCSI_DH_OK)
++=======
+ 	h->pg = alua_alloc_pg(sdev, h->group_id, tpgs);
+ 	if (IS_ERR(h->pg)) {
+ 		if (PTR_ERR(h->pg) == -ENOMEM)
+ 			err = SCSI_DH_NOMEM;
++>>>>>>> 0047220c6c36 (scsi_dh_alua: use unique device id)
  		goto out;
 -	}
 -	kref_get(&h->pg->kref);
 -	err = alua_rtpg(sdev, h->pg, 0);
 -	kref_put(&h->pg->kref, release_port_group);
 +
  out:
  	return err;
  }
* Unmerged path drivers/scsi/device_handler/scsi_dh_alua.c
