i40e: allow XPS with QoS enabled

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit 6f853d4f8e93eeace504b021e05dfdbeb4d3b40f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/6f853d4f.failed

Recently, the kernel gained support for enabling XPS and QoS at the
same time. Thus, we no longer need to worry about the number of
traffic classes when enabling XPS.

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 6f853d4f8e93eeace504b021e05dfdbeb4d3b40f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_main.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_main.c
index 374ba7377bef,b26f615bed5a..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@@ -2955,22 -2879,18 +2955,31 @@@ static void i40e_vsi_free_rx_resources(
   **/
  static void i40e_config_xps_tx_ring(struct i40e_ring *ring)
  {
++<<<<<<< HEAD
 +	struct i40e_vsi *vsi = ring->vsi;
++=======
+ 	int cpu;
++>>>>>>> 6f853d4f8e93 (i40e: allow XPS with QoS enabled)
  
  	if (!ring->q_vector || !ring->netdev)
  		return;
  
++<<<<<<< HEAD
 +	if ((vsi->tc_config.numtc <= 1) &&
 +	    !test_and_set_bit(__I40E_TX_XPS_INIT_DONE, &ring->state)) {
 +		netif_set_xps_queue(ring->netdev,
 +				    &ring->q_vector->affinity_mask,
 +				    ring->queue_index);
 +	}
++=======
+ 	/* We only initialize XPS once, so as not to overwrite user settings */
+ 	if (test_and_set_bit(__I40E_TX_XPS_INIT_DONE, ring->state))
+ 		return;
++>>>>>>> 6f853d4f8e93 (i40e: allow XPS with QoS enabled)
  
- 	/* schedule our worker thread which will take care of
- 	 * applying the new filter changes
- 	 */
- 	i40e_service_event_schedule(vsi->back);
+ 	cpu = cpumask_local_spread(ring->q_vector->v_idx, -1);
+ 	netif_set_xps_queue(ring->netdev, get_cpu_mask(cpu),
+ 			    ring->queue_index);
  }
  
  /**
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_main.c
