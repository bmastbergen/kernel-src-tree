mm/swap: skip readahead only when swap slot cache is enabled

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [mm] swap: skip readahead only when swap slot cache is enabled (Jerome Marchand) [1400689]
Rebuild_FUZZ: 97.44%
commit-author Huang Ying <ying.huang@intel.com>
commit ba81f83842549871cbd7226fc11530dc464500bb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ba81f838.failed

Because during swap off, a swap entry may have swap_map[] ==
SWAP_HAS_CACHE (for example, just allocated).  If we return NULL in
__read_swap_cache_async(), the swap off will abort.  So when swap slot
cache is disabled, (for swap off), we will wait for page to be put into
swap cache in such race condition.  This should not be a problem for swap
slot cache, because swap slot cache should be drained after clearing
swap_slot_cache_enabled.

[ying.huang@intel.com: fix memory leak in __read_swap_cache_async()]
  Link: http://lkml.kernel.org/r/874lzt6znd.fsf@yhuang-dev.intel.com
Link: http://lkml.kernel.org/r/5e2c5f6abe8e6eb0797408897b1bba80938e9b9d.1484082593.git.tim.c.chen@linux.intel.com
	Signed-off-by: "Huang, Ying" <ying.huang@intel.com>
	Signed-off-by: Tim Chen <tim.c.chen@linux.intel.com>
	Cc: Aaron Lu <aaron.lu@intel.com>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: Andrea Arcangeli <aarcange@redhat.com>
	Cc: Christian Borntraeger <borntraeger@de.ibm.com>
	Cc: Dave Hansen <dave.hansen@intel.com>
	Cc: Hillf Danton <hillf.zj@alibaba-inc.com>
	Cc: Huang Ying <ying.huang@intel.com>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Jonathan Corbet <corbet@lwn.net> escreveu:
	Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Michal Hocko <mhocko@kernel.org>
	Cc: Minchan Kim <minchan@kernel.org>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Shaohua Li <shli@kernel.org>
	Cc: Vladimir Davydov <vdavydov.dev@gmail.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit ba81f83842549871cbd7226fc11530dc464500bb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/swap_slots.h
#	mm/swap_slots.c
#	mm/swap_state.c
diff --cc mm/swap_state.c
index 8ead62769c81,473b71e052a8..000000000000
--- a/mm/swap_state.c
+++ b/mm/swap_state.c
@@@ -329,6 -324,17 +329,20 @@@ struct page *read_swap_cache_async(swp_
  		if (found_page)
  			break;
  
++<<<<<<< HEAD
++=======
+ 		/*
+ 		 * Just skip read ahead for unused swap slot.
+ 		 * During swap_off when swap_slot_cache is disabled,
+ 		 * we have to handle the race between putting
+ 		 * swap entry in swap cache and marking swap slot
+ 		 * as SWAP_HAS_CACHE.  That's done in later part of code or
+ 		 * else swap_off will be aborted if we return NULL.
+ 		 */
+ 		if (!__swp_swapcount(entry) && swap_slot_cache_enabled)
+ 			break;
+ 
++>>>>>>> ba81f8384254 (mm/swap: skip readahead only when swap slot cache is enabled)
  		/*
  		 * Get a new page to read into from swap.
  		 */
* Unmerged path include/linux/swap_slots.h
* Unmerged path mm/swap_slots.c
* Unmerged path include/linux/swap_slots.h
* Unmerged path mm/swap_slots.c
* Unmerged path mm/swap_state.c
