nfp: add set_mac_address support while the interface is up

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Pablo Cascón <pablo.cascon@netronome.com>
commit 9d3727595b11ab8f2837b54922efd2998f2cade5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9d372759.failed

Expose FW app ability to change MAC address at runtime.  Make sure
we only depend on it if FW app advertised the right capability.

	Signed-off-by: Pablo Cascón <pablo.cascon@netronome.com>
	Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9d3727595b11ab8f2837b54922efd2998f2cade5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net_common.c
#	drivers/net/ethernet/netronome/nfp/nfp_net_ctrl.h
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index 5094c56dbda7,9312a737fbc9..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@@ -1853,12 -2129,10 +1854,17 @@@ void nfp_net_coalesce_write_cfg(struct 
   * perform the required reconfig.  We do a bit of byte swapping dance because
   * firmware is LE.
   */
- static void nfp_net_write_mac_addr(struct nfp_net *nn)
+ static void nfp_net_write_mac_addr(struct nfp_net *nn, const u8 *addr)
  {
++<<<<<<< HEAD
 +	nn_writel(nn, NFP_NET_CFG_MACADDR + 0,
 +		  get_unaligned_be32(nn->netdev->dev_addr));
 +	nn_writew(nn, NFP_NET_CFG_MACADDR + 6,
 +		  get_unaligned_be16(nn->netdev->dev_addr + 4));
++=======
+ 	nn_writel(nn, NFP_NET_CFG_MACADDR + 0, get_unaligned_be32(addr));
+ 	nn_writew(nn, NFP_NET_CFG_MACADDR + 6, get_unaligned_be16(addr + 4));
++>>>>>>> 9d3727595b11 (nfp: add set_mac_address support while the interface is up)
  }
  
  static void nfp_net_vec_clear_ring_data(struct nfp_net *nn, unsigned int idx)
@@@ -1952,22 -2226,23 +1958,22 @@@ static int nfp_net_set_config_and_enabl
  		update |= NFP_NET_CFG_UPDATE_IRQMOD;
  	}
  
 -	for (r = 0; r < nn->dp.num_tx_rings; r++)
 -		nfp_net_tx_ring_hw_cfg_write(nn, &nn->dp.tx_rings[r], r);
 -	for (r = 0; r < nn->dp.num_rx_rings; r++)
 -		nfp_net_rx_ring_hw_cfg_write(nn, &nn->dp.rx_rings[r], r);
 +	for (r = 0; r < nn->num_tx_rings; r++)
 +		nfp_net_tx_ring_hw_cfg_write(nn, &nn->tx_rings[r], r);
 +	for (r = 0; r < nn->num_rx_rings; r++)
 +		nfp_net_rx_ring_hw_cfg_write(nn, &nn->rx_rings[r], r);
  
 -	nn_writeq(nn, NFP_NET_CFG_TXRS_ENABLE, nn->dp.num_tx_rings == 64 ?
 -		  0xffffffffffffffffULL : ((u64)1 << nn->dp.num_tx_rings) - 1);
 +	nn_writeq(nn, NFP_NET_CFG_TXRS_ENABLE, nn->num_tx_rings == 64 ?
 +		  0xffffffffffffffffULL : ((u64)1 << nn->num_tx_rings) - 1);
  
 -	nn_writeq(nn, NFP_NET_CFG_RXRS_ENABLE, nn->dp.num_rx_rings == 64 ?
 -		  0xffffffffffffffffULL : ((u64)1 << nn->dp.num_rx_rings) - 1);
 +	nn_writeq(nn, NFP_NET_CFG_RXRS_ENABLE, nn->num_rx_rings == 64 ?
 +		  0xffffffffffffffffULL : ((u64)1 << nn->num_rx_rings) - 1);
  
- 	nfp_net_write_mac_addr(nn);
+ 	nfp_net_write_mac_addr(nn, nn->dp.netdev->dev_addr);
  
 -	nn_writel(nn, NFP_NET_CFG_MTU, nn->dp.netdev->mtu);
 -
 -	bufsz = nn->dp.fl_bufsz - nn->dp.rx_dma_off - NFP_NET_RX_BUF_NON_DATA;
 -	nn_writel(nn, NFP_NET_CFG_FLBUFSZ, bufsz);
 +	nn_writel(nn, NFP_NET_CFG_MTU, nn->netdev->mtu);
 +	nn_writel(nn, NFP_NET_CFG_FLBUFSZ,
 +		  nn->fl_bufsz - NFP_NET_RX_BUF_NON_DATA);
  
  	/* Enable device */
  	new_ctrl |= NFP_NET_CFG_CTRL_ENABLE;
@@@ -2600,8 -2915,109 +2606,114 @@@ static void nfp_net_del_vxlan_port(stru
  		nfp_net_set_vxlan_port(nn, idx, 0);
  }
  
++<<<<<<< HEAD
 +static const struct net_device_ops nfp_net_netdev_ops = {
 +	.ndo_size		= sizeof(struct net_device_ops),
++=======
+ static int nfp_net_xdp_offload(struct nfp_net *nn, struct bpf_prog *prog)
+ {
+ 	struct tc_cls_bpf_offload cmd = {
+ 		.prog = prog,
+ 	};
+ 	int ret;
+ 
+ 	if (!nfp_net_ebpf_capable(nn))
+ 		return -EINVAL;
+ 
+ 	if (nn->dp.ctrl & NFP_NET_CFG_CTRL_BPF) {
+ 		if (!nn->dp.bpf_offload_xdp)
+ 			return prog ? -EBUSY : 0;
+ 		cmd.command = prog ? TC_CLSBPF_REPLACE : TC_CLSBPF_DESTROY;
+ 	} else {
+ 		if (!prog)
+ 			return 0;
+ 		cmd.command = TC_CLSBPF_ADD;
+ 	}
+ 
+ 	ret = nfp_net_bpf_offload(nn, &cmd);
+ 	/* Stop offload if replace not possible */
+ 	if (ret && cmd.command == TC_CLSBPF_REPLACE)
+ 		nfp_net_xdp_offload(nn, NULL);
+ 	nn->dp.bpf_offload_xdp = prog && !ret;
+ 	return ret;
+ }
+ 
+ static int nfp_net_xdp_setup(struct nfp_net *nn, struct netdev_xdp *xdp)
+ {
+ 	struct bpf_prog *old_prog = nn->dp.xdp_prog;
+ 	struct bpf_prog *prog = xdp->prog;
+ 	struct nfp_net_dp *dp;
+ 	int err;
+ 
+ 	if (!prog && !nn->dp.xdp_prog)
+ 		return 0;
+ 	if (prog && nn->dp.xdp_prog) {
+ 		prog = xchg(&nn->dp.xdp_prog, prog);
+ 		bpf_prog_put(prog);
+ 		nfp_net_xdp_offload(nn, nn->dp.xdp_prog);
+ 		return 0;
+ 	}
+ 
+ 	dp = nfp_net_clone_dp(nn);
+ 	if (!dp)
+ 		return -ENOMEM;
+ 
+ 	dp->xdp_prog = prog;
+ 	dp->num_tx_rings += prog ? nn->dp.num_rx_rings : -nn->dp.num_rx_rings;
+ 	dp->rx_dma_dir = prog ? DMA_BIDIRECTIONAL : DMA_FROM_DEVICE;
+ 	dp->rx_dma_off = prog ? XDP_PACKET_HEADROOM - nn->dp.rx_offset : 0;
+ 
+ 	/* We need RX reconfig to remap the buffers (BIDIR vs FROM_DEV) */
+ 	err = nfp_net_ring_reconfig(nn, dp, xdp->extack);
+ 	if (err)
+ 		return err;
+ 
+ 	if (old_prog)
+ 		bpf_prog_put(old_prog);
+ 
+ 	nfp_net_xdp_offload(nn, nn->dp.xdp_prog);
+ 
+ 	return 0;
+ }
+ 
+ static int nfp_net_xdp(struct net_device *netdev, struct netdev_xdp *xdp)
+ {
+ 	struct nfp_net *nn = netdev_priv(netdev);
+ 
+ 	switch (xdp->command) {
+ 	case XDP_SETUP_PROG:
+ 		return nfp_net_xdp_setup(nn, xdp);
+ 	case XDP_QUERY_PROG:
+ 		xdp->prog_attached = !!nn->dp.xdp_prog;
+ 		return 0;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ }
+ 
+ static int nfp_net_set_mac_address(struct net_device *netdev, void *addr)
+ {
+ 	struct nfp_net *nn = netdev_priv(netdev);
+ 	struct sockaddr *saddr = addr;
+ 	int err;
+ 
+ 	err = eth_prepare_mac_addr_change(netdev, addr);
+ 	if (err)
+ 		return err;
+ 
+ 	nfp_net_write_mac_addr(nn, saddr->sa_data);
+ 
+ 	err = nfp_net_reconfig(nn, NFP_NET_CFG_UPDATE_MACADDR);
+ 	if (err)
+ 		return err;
+ 
+ 	eth_commit_mac_addr_change(netdev, addr);
+ 
+ 	return 0;
+ }
+ 
+ const struct net_device_ops nfp_net_netdev_ops = {
++>>>>>>> 9d3727595b11 (nfp: add set_mac_address support while the interface is up)
  	.ndo_open		= nfp_net_netdev_open,
  	.ndo_stop		= nfp_net_netdev_close,
  	.ndo_start_xmit		= nfp_net_tx,
@@@ -2609,11 -3025,14 +2721,11 @@@
  	.ndo_tx_timeout		= nfp_net_tx_timeout,
  	.ndo_set_rx_mode	= nfp_net_set_rx_mode,
  	.ndo_change_mtu		= nfp_net_change_mtu,
- 	.ndo_set_mac_address	= eth_mac_addr,
+ 	.ndo_set_mac_address	= nfp_net_set_mac_address,
  	.ndo_set_features	= nfp_net_set_features,
  	.ndo_features_check	= nfp_net_features_check,
 -	.ndo_get_phys_port_name	= nfp_port_get_phys_port_name,
 -	.ndo_udp_tunnel_add	= nfp_net_add_vxlan_port,
 -	.ndo_udp_tunnel_del	= nfp_net_del_vxlan_port,
 -	.ndo_xdp		= nfp_net_xdp,
 +	.extended.ndo_udp_tunnel_add	= nfp_net_add_vxlan_port,
 +	.extended.ndo_udp_tunnel_del	= nfp_net_del_vxlan_port,
  };
  
  /**
@@@ -2630,7 -3049,7 +2742,11 @@@ void nfp_net_info(struct nfp_net *nn
  		nn->fw_ver.resv, nn->fw_ver.class,
  		nn->fw_ver.major, nn->fw_ver.minor,
  		nn->max_mtu);
++<<<<<<< HEAD
 +	nn_info(nn, "CAP: %#x %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n",
++=======
+ 	nn_info(nn, "CAP: %#x %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n",
++>>>>>>> 9d3727595b11 (nfp: add set_mac_address support while the interface is up)
  		nn->cap,
  		nn->cap & NFP_NET_CFG_CTRL_PROMISC  ? "PROMISC "  : "",
  		nn->cap & NFP_NET_CFG_CTRL_L2BC     ? "L2BCFILT " : "",
@@@ -2647,7 -3068,11 +2763,15 @@@
  		nn->cap & NFP_NET_CFG_CTRL_MSIXAUTO ? "AUTOMASK " : "",
  		nn->cap & NFP_NET_CFG_CTRL_IRQMOD   ? "IRQMOD "   : "",
  		nn->cap & NFP_NET_CFG_CTRL_VXLAN    ? "VXLAN "    : "",
++<<<<<<< HEAD
 +		nn->cap & NFP_NET_CFG_CTRL_NVGRE    ? "NVGRE "	  : "");
++=======
+ 		nn->cap & NFP_NET_CFG_CTRL_NVGRE    ? "NVGRE "	  : "",
+ 		nfp_net_ebpf_capable(nn)            ? "BPF "	  : "",
+ 		nn->cap & NFP_NET_CFG_CTRL_CSUM_COMPLETE ?
+ 						      "RXCSUM_COMPLETE " : "",
+ 		nn->cap & NFP_NET_CFG_CTRL_LIVE_ADDR ? "LIVE_ADDR " : "");
++>>>>>>> 9d3727595b11 (nfp: add set_mac_address support while the interface is up)
  }
  
  /**
@@@ -2754,13 -3226,27 +2878,23 @@@ int nfp_net_netdev_init(struct net_devi
  	nn->cap = nn_readl(nn, NFP_NET_CFG_CAP);
  	nn->max_mtu = nn_readl(nn, NFP_NET_CFG_MAX_MTU);
  
++<<<<<<< HEAD
 +	nfp_net_write_mac_addr(nn);
++=======
+ 	/* Chained metadata is signalled by capabilities except in version 4 */
+ 	nn->dp.chained_metadata_format = nn->fw_ver.major == 4 ||
+ 					 nn->cap & NFP_NET_CFG_CTRL_CHAIN_META;
+ 	if (nn->dp.chained_metadata_format && nn->fw_ver.major != 4)
+ 		nn->cap &= ~NFP_NET_CFG_CTRL_RSS;
+ 
+ 	nfp_net_write_mac_addr(nn, nn->dp.netdev->dev_addr);
++>>>>>>> 9d3727595b11 (nfp: add set_mac_address support while the interface is up)
  
  	/* Determine RX packet/metadata boundary offset */
 -	if (nn->fw_ver.major >= 2) {
 -		u32 reg;
 -
 -		reg = nn_readl(nn, NFP_NET_CFG_RX_OFFSET);
 -		if (reg > NFP_NET_MAX_PREPEND) {
 -			nn_err(nn, "Invalid rx offset: %d\n", reg);
 -			return -EINVAL;
 -		}
 -		nn->dp.rx_offset = reg;
 -	} else {
 -		nn->dp.rx_offset = NFP_NET_RX_OFFSET;
 -	}
 +	if (nn->fw_ver.major >= 2)
 +		nn->rx_offset = nn_readl(nn, NFP_NET_CFG_RX_OFFSET);
 +	else
 +		nn->rx_offset = NFP_NET_RX_OFFSET;
  
  	/* Set default MTU and Freelist buffer size */
  	if (nn->max_mtu < NFP_NET_DEFAULT_MTU)
@@@ -2775,10 -3262,13 +2909,13 @@@
  	 * and netdev->hw_features advertises which features are
  	 * supported.  By default we enable most features.
  	 */
+ 	if (nn->cap & NFP_NET_CFG_CTRL_LIVE_ADDR)
+ 		netdev->priv_flags |= IFF_LIVE_ADDR_CHANGE;
+ 
  	netdev->hw_features = NETIF_F_HIGHDMA;
 -	if (nn->cap & NFP_NET_CFG_CTRL_RXCSUM_ANY) {
 +	if (nn->cap & NFP_NET_CFG_CTRL_RXCSUM) {
  		netdev->hw_features |= NETIF_F_RXCSUM;
 -		nn->dp.ctrl |= nn->cap & NFP_NET_CFG_CTRL_RXCSUM_ANY;
 +		nn->ctrl |= NFP_NET_CFG_CTRL_RXCSUM;
  	}
  	if (nn->cap & NFP_NET_CFG_CTRL_TXCSUM) {
  		netdev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_ctrl.h
index 92d76a860c19,c8208bf370e0..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_ctrl.h
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_ctrl.h
@@@ -123,6 -131,21 +123,24 @@@
  #define   NFP_NET_CFG_CTRL_L2SWITCH_LOCAL (0x1 << 23) /* Switch to local */
  #define   NFP_NET_CFG_CTRL_VXLAN	  (0x1 << 24) /* VXLAN tunnel support */
  #define   NFP_NET_CFG_CTRL_NVGRE	  (0x1 << 25) /* NVGRE tunnel support */
++<<<<<<< HEAD
++=======
+ #define   NFP_NET_CFG_CTRL_BPF		  (0x1 << 27) /* BPF offload capable */
+ #define   NFP_NET_CFG_CTRL_LSO2		  (0x1 << 28) /* LSO/TSO (version 2) */
+ #define   NFP_NET_CFG_CTRL_RSS2		  (0x1 << 29) /* RSS (version 2) */
+ #define   NFP_NET_CFG_CTRL_CSUM_COMPLETE  (0x1 << 30) /* Checksum complete */
+ #define   NFP_NET_CFG_CTRL_LIVE_ADDR	  (0x1 << 31) /* live MAC addr change */
+ 
+ #define NFP_NET_CFG_CTRL_LSO_ANY	(NFP_NET_CFG_CTRL_LSO | \
+ 					 NFP_NET_CFG_CTRL_LSO2)
+ #define NFP_NET_CFG_CTRL_RSS_ANY	(NFP_NET_CFG_CTRL_RSS | \
+ 					 NFP_NET_CFG_CTRL_RSS2)
+ #define NFP_NET_CFG_CTRL_RXCSUM_ANY	(NFP_NET_CFG_CTRL_RXCSUM | \
+ 					 NFP_NET_CFG_CTRL_CSUM_COMPLETE)
+ #define NFP_NET_CFG_CTRL_CHAIN_META	(NFP_NET_CFG_CTRL_RSS2 | \
+ 					 NFP_NET_CFG_CTRL_CSUM_COMPLETE)
+ 
++>>>>>>> 9d3727595b11 (nfp: add set_mac_address support while the interface is up)
  #define NFP_NET_CFG_UPDATE              0x0004
  #define   NFP_NET_CFG_UPDATE_GEN          (0x1 <<  0) /* General update */
  #define   NFP_NET_CFG_UPDATE_RING         (0x1 <<  1) /* Ring config change */
@@@ -134,6 -157,8 +152,11 @@@
  #define   NFP_NET_CFG_UPDATE_RESET        (0x1 <<  7) /* Update due to FLR */
  #define   NFP_NET_CFG_UPDATE_IRQMOD       (0x1 <<  8) /* IRQ mod change */
  #define   NFP_NET_CFG_UPDATE_VXLAN	  (0x1 <<  9) /* VXLAN port change */
++<<<<<<< HEAD
++=======
+ #define   NFP_NET_CFG_UPDATE_BPF	  (0x1 << 10) /* BPF program load */
+ #define   NFP_NET_CFG_UPDATE_MACADDR	  (0x1 << 11) /* MAC address change */
++>>>>>>> 9d3727595b11 (nfp: add set_mac_address support while the interface is up)
  #define   NFP_NET_CFG_UPDATE_ERR          (0x1 << 31) /* A error occurred */
  #define NFP_NET_CFG_TXRS_ENABLE         0x0008
  #define NFP_NET_CFG_RXRS_ENABLE         0x0010
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_common.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_ctrl.h
