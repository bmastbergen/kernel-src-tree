locks: rename file-private locks to "open file description locks"

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jeff Layton <jlayton@redhat.com>
commit 0d3f7a2dd2f5cf9642982515e020c1aee2cf7af6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0d3f7a2d.failed

File-private locks have been merged into Linux for v3.15, and *now*
people are commenting that the name and macro definitions for the new
file-private locks suck.

...and I can't even disagree. The names and command macros do suck.

We're going to have to live with these for a long time, so it's
important that we be happy with the names before we're stuck with them.
The consensus on the lists so far is that they should be rechristened as
"open file description locks".

The name isn't a big deal for the kernel, but the command macros are not
visually distinct enough from the traditional POSIX lock macros. The
glibc and documentation folks are recommending that we change them to
look like F_OFD_{GETLK|SETLK|SETLKW}. That lessens the chance that a
programmer will typo one of the commands wrong, and also makes it easier
to spot this difference when reading code.

This patch makes the following changes that I think are necessary before
v3.15 ships:

1) rename the command macros to their new names. These end up in the uapi
   headers and so are part of the external-facing API. It turns out that
   glibc doesn't actually use the fcntl.h uapi header, but it's hard to
   be sure that something else won't. Changing it now is safest.

2) make the the /proc/locks output display these as type "OFDLCK"

	Cc: Michael Kerrisk <mtk.manpages@gmail.com>
	Cc: Christoph Hellwig <hch@infradead.org>
	Cc: Carlos O'Donell <carlos@redhat.com>
	Cc: Stefan Metzmacher <metze@samba.org>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Frank Filz <ffilzlnx@mindspring.com>
	Cc: Theodore Ts'o <tytso@mit.edu>
	Signed-off-by: Jeff Layton <jlayton@redhat.com>
(cherry picked from commit 0d3f7a2dd2f5cf9642982515e020c1aee2cf7af6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm/kernel/sys_oabi-compat.c
#	fs/compat.c
#	fs/fcntl.c
#	fs/locks.c
#	include/uapi/asm-generic/fcntl.h
#	security/selinux/hooks.c
diff --cc arch/arm/kernel/sys_oabi-compat.c
index 3e94811690ce,e90a3148f385..000000000000
--- a/arch/arm/kernel/sys_oabi-compat.c
+++ b/arch/arm/kernel/sys_oabi-compat.c
@@@ -203,6 -203,9 +203,12 @@@ asmlinkage long sys_oabi_fcntl64(unsign
  	int ret;
  
  	switch (cmd) {
++<<<<<<< HEAD
++=======
+ 	case F_OFD_GETLK:
+ 	case F_OFD_SETLK:
+ 	case F_OFD_SETLKW:
++>>>>>>> 0d3f7a2dd2f5 (locks: rename file-private locks to "open file description locks")
  	case F_GETLK64:
  	case F_SETLK64:
  	case F_SETLKW64:
diff --cc fs/compat.c
index ce28ea16eb65,66d3d3c6b4b2..000000000000
--- a/fs/compat.c
+++ b/fs/compat.c
@@@ -441,16 -457,18 +441,26 @@@ asmlinkage long compat_sys_fcntl64(unsi
  	case F_GETLK64:
  	case F_SETLK64:
  	case F_SETLKW64:
++<<<<<<< HEAD
++=======
+ 	case F_OFD_GETLK:
+ 	case F_OFD_SETLK:
+ 	case F_OFD_SETLKW:
++>>>>>>> 0d3f7a2dd2f5 (locks: rename file-private locks to "open file description locks")
  		ret = get_compat_flock64(&f, compat_ptr(arg));
  		if (ret != 0)
  			break;
  		old_fs = get_fs();
  		set_fs(KERNEL_DS);
 -		conv_cmd = convert_fcntl_cmd(cmd);
 -		ret = sys_fcntl(fd, conv_cmd, (unsigned long)&f);
 +		ret = sys_fcntl(fd, (cmd == F_GETLK64) ? F_GETLK :
 +				((cmd == F_SETLK64) ? F_SETLK : F_SETLKW),
 +				(unsigned long)&f);
  		set_fs(old_fs);
++<<<<<<< HEAD
 +		if (cmd == F_GETLK64 && ret == 0) {
++=======
+ 		if ((conv_cmd == F_GETLK || conv_cmd == F_OFD_GETLK) && ret == 0) {
++>>>>>>> 0d3f7a2dd2f5 (locks: rename file-private locks to "open file description locks")
  			/* need to return lock information - see above for commentary */
  			if (f.l_start > COMPAT_LOFF_T_MAX)
  				ret = -EOVERFLOW;
@@@ -468,11 -486,18 +478,21 @@@
  	return ret;
  }
  
 -COMPAT_SYSCALL_DEFINE3(fcntl, unsigned int, fd, unsigned int, cmd,
 -		       compat_ulong_t, arg)
 +asmlinkage long compat_sys_fcntl(unsigned int fd, unsigned int cmd,
 +		unsigned long arg)
  {
++<<<<<<< HEAD
 +	if ((cmd == F_GETLK64) || (cmd == F_SETLK64) || (cmd == F_SETLKW64))
++=======
+ 	switch (cmd) {
+ 	case F_GETLK64:
+ 	case F_SETLK64:
+ 	case F_SETLKW64:
+ 	case F_OFD_GETLK:
+ 	case F_OFD_SETLK:
+ 	case F_OFD_SETLKW:
++>>>>>>> 0d3f7a2dd2f5 (locks: rename file-private locks to "open file description locks")
  		return -EINVAL;
 -	}
  	return compat_sys_fcntl64(fd, cmd, arg);
  }
  
diff --cc fs/fcntl.c
index 7ce6511af2e5,72c82f69b01b..000000000000
--- a/fs/fcntl.c
+++ b/fs/fcntl.c
@@@ -274,9 -272,19 +274,25 @@@ static long do_fcntl(int fd, unsigned i
  	case F_SETFL:
  		err = setfl(fd, filp, arg);
  		break;
++<<<<<<< HEAD
 +	case F_GETLK:
 +		err = fcntl_getlk(filp, cmd, (struct flock __user *) arg);
 +		break;
++=======
+ #if BITS_PER_LONG != 32
+ 	/* 32-bit arches must use fcntl64() */
+ 	case F_OFD_GETLK:
+ #endif
+ 	case F_GETLK:
+ 		err = fcntl_getlk(filp, cmd, (struct flock __user *) arg);
+ 		break;
+ #if BITS_PER_LONG != 32
+ 	/* 32-bit arches must use fcntl64() */
+ 	case F_OFD_SETLK:
+ 	case F_OFD_SETLKW:
+ #endif
+ 		/* Fallthrough */
++>>>>>>> 0d3f7a2dd2f5 (locks: rename file-private locks to "open file description locks")
  	case F_SETLK:
  	case F_SETLKW:
  		err = fcntl_setlk(fd, filp, cmd, (struct flock __user *) arg);
@@@ -394,17 -398,20 +410,34 @@@ SYSCALL_DEFINE3(fcntl64, unsigned int, 
  		goto out1;
  	
  	switch (cmd) {
++<<<<<<< HEAD
 +		case F_GETLK64:
 +			err = fcntl_getlk64(f.file, cmd, (struct flock64 __user *) arg);
 +			break;
 +		case F_SETLK64:
 +		case F_SETLKW64:
 +			err = fcntl_setlk64(fd, f.file, cmd,
 +					(struct flock64 __user *) arg);
 +			break;
 +		default:
 +			err = do_fcntl(fd, cmd, arg, f.file);
 +			break;
++=======
+ 	case F_GETLK64:
+ 	case F_OFD_GETLK:
+ 		err = fcntl_getlk64(f.file, cmd, (struct flock64 __user *) arg);
+ 		break;
+ 	case F_SETLK64:
+ 	case F_SETLKW64:
+ 	case F_OFD_SETLK:
+ 	case F_OFD_SETLKW:
+ 		err = fcntl_setlk64(fd, f.file, cmd,
+ 				(struct flock64 __user *) arg);
+ 		break;
+ 	default:
+ 		err = do_fcntl(fd, cmd, arg, f.file);
+ 		break;
++>>>>>>> 0d3f7a2dd2f5 (locks: rename file-private locks to "open file description locks")
  	}
  out1:
  	fdput(f);
diff --cc fs/locks.c
index 20dcff562a1d,e1023b504279..000000000000
--- a/fs/locks.c
+++ b/fs/locks.c
@@@ -2009,6 -1941,16 +2009,19 @@@ int fcntl_getlk(struct file *filp, unsi
  	if (error)
  		goto out;
  
++<<<<<<< HEAD
++=======
+ 	if (cmd == F_OFD_GETLK) {
+ 		error = -EINVAL;
+ 		if (flock.l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_GETLK;
+ 		file_lock.fl_flags |= FL_FILE_PVT;
+ 		file_lock.fl_owner = (fl_owner_t)filp;
+ 	}
+ 
++>>>>>>> 0d3f7a2dd2f5 (locks: rename file-private locks to "open file description locks")
  	error = vfs_test_lock(filp, &file_lock);
  	if (error)
  		goto out;
@@@ -2130,10 -2070,34 +2143,38 @@@ again
  	error = flock_to_posix_lock(filp, file_lock, &flock);
  	if (error)
  		goto out;
++<<<<<<< HEAD
 +	if (cmd == F_SETLKW) {
++=======
+ 
+ 	/*
+ 	 * If the cmd is requesting file-private locks, then set the
+ 	 * FL_FILE_PVT flag and override the owner.
+ 	 */
+ 	switch (cmd) {
+ 	case F_OFD_SETLK:
+ 		error = -EINVAL;
+ 		if (flock.l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_SETLK;
+ 		file_lock->fl_flags |= FL_FILE_PVT;
+ 		file_lock->fl_owner = (fl_owner_t)filp;
+ 		break;
+ 	case F_OFD_SETLKW:
+ 		error = -EINVAL;
+ 		if (flock.l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_SETLKW;
+ 		file_lock->fl_flags |= FL_FILE_PVT;
+ 		file_lock->fl_owner = (fl_owner_t)filp;
+ 		/* Fallthrough */
+ 	case F_SETLKW:
++>>>>>>> 0d3f7a2dd2f5 (locks: rename file-private locks to "open file description locks")
  		file_lock->fl_flags |= FL_SLEEP;
  	}
 -
 +	
  	error = do_lock_file_wait(filp, cmd, file_lock);
  
  	/*
@@@ -2179,6 -2143,16 +2220,19 @@@ int fcntl_getlk64(struct file *filp, un
  	if (error)
  		goto out;
  
++<<<<<<< HEAD
++=======
+ 	if (cmd == F_OFD_GETLK) {
+ 		error = -EINVAL;
+ 		if (flock.l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_GETLK64;
+ 		file_lock.fl_flags |= FL_FILE_PVT;
+ 		file_lock.fl_owner = (fl_owner_t)filp;
+ 	}
+ 
++>>>>>>> 0d3f7a2dd2f5 (locks: rename file-private locks to "open file description locks")
  	error = vfs_test_lock(filp, &file_lock);
  	if (error)
  		goto out;
@@@ -2232,10 -2205,34 +2286,38 @@@ again
  	error = flock64_to_posix_lock(filp, file_lock, &flock);
  	if (error)
  		goto out;
++<<<<<<< HEAD
 +	if (cmd == F_SETLKW64) {
++=======
+ 
+ 	/*
+ 	 * If the cmd is requesting file-private locks, then set the
+ 	 * FL_FILE_PVT flag and override the owner.
+ 	 */
+ 	switch (cmd) {
+ 	case F_OFD_SETLK:
+ 		error = -EINVAL;
+ 		if (flock.l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_SETLK64;
+ 		file_lock->fl_flags |= FL_FILE_PVT;
+ 		file_lock->fl_owner = (fl_owner_t)filp;
+ 		break;
+ 	case F_OFD_SETLKW:
+ 		error = -EINVAL;
+ 		if (flock.l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_SETLKW64;
+ 		file_lock->fl_flags |= FL_FILE_PVT;
+ 		file_lock->fl_owner = (fl_owner_t)filp;
+ 		/* Fallthrough */
+ 	case F_SETLKW64:
++>>>>>>> 0d3f7a2dd2f5 (locks: rename file-private locks to "open file description locks")
  		file_lock->fl_flags |= FL_SLEEP;
  	}
 -
 +	
  	error = do_lock_file_wait(filp, cmd, file_lock);
  
  	/*
@@@ -2413,8 -2410,14 +2495,19 @@@ static void lock_get_status(struct seq_
  
  	seq_printf(f, "%lld:%s ", id, pfx);
  	if (IS_POSIX(fl)) {
++<<<<<<< HEAD
 +		seq_printf(f, "%6s %s ",
 +			     (fl->fl_flags & FL_ACCESS) ? "ACCESS" : "POSIX ",
++=======
+ 		if (fl->fl_flags & FL_ACCESS)
+ 			seq_printf(f, "ACCESS");
+ 		else if (IS_FILE_PVT(fl))
+ 			seq_printf(f, "OFDLCK");
+ 		else
+ 			seq_printf(f, "POSIX ");
+ 
+ 		seq_printf(f, " %s ",
++>>>>>>> 0d3f7a2dd2f5 (locks: rename file-private locks to "open file description locks")
  			     (inode == NULL) ? "*NOINODE*" :
  			     mandatory_lock(inode) ? "MANDATORY" : "ADVISORY ");
  	} else if (IS_FLOCK(fl)) {
diff --cc include/uapi/asm-generic/fcntl.h
index 729af84a016e,7543b3e51331..000000000000
--- a/include/uapi/asm-generic/fcntl.h
+++ b/include/uapi/asm-generic/fcntl.h
@@@ -124,6 -132,22 +124,25 @@@
  #define F_GETOWNER_UIDS	17
  #endif
  
++<<<<<<< HEAD
++=======
+ /*
+  * Open File Description Locks
+  *
+  * Usually record locks held by a process are released on *any* close and are
+  * not inherited across a fork().
+  *
+  * These cmd values will set locks that conflict with process-associated
+  * record  locks, but are "owned" by the open file description, not the
+  * process. This means that they are inherited across fork() like BSD (flock)
+  * locks, and they are only released automatically when the last reference to
+  * the the open file against which they were acquired is put.
+  */
+ #define F_OFD_GETLK	36
+ #define F_OFD_SETLK	37
+ #define F_OFD_SETLKW	38
+ 
++>>>>>>> 0d3f7a2dd2f5 (locks: rename file-private locks to "open file description locks")
  #define F_OWNER_TID	0
  #define F_OWNER_PID	1
  #define F_OWNER_PGRP	2
diff --cc security/selinux/hooks.c
index 7c150cbbfbc6,2c7341dbc5d6..000000000000
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@@ -3501,6 -3317,9 +3501,12 @@@ static int selinux_file_fcntl(struct fi
  	case F_GETLK:
  	case F_SETLK:
  	case F_SETLKW:
++<<<<<<< HEAD
++=======
+ 	case F_OFD_GETLK:
+ 	case F_OFD_SETLK:
+ 	case F_OFD_SETLKW:
++>>>>>>> 0d3f7a2dd2f5 (locks: rename file-private locks to "open file description locks")
  #if BITS_PER_LONG == 32
  	case F_GETLK64:
  	case F_SETLK64:
* Unmerged path arch/arm/kernel/sys_oabi-compat.c
* Unmerged path fs/compat.c
* Unmerged path fs/fcntl.c
* Unmerged path fs/locks.c
* Unmerged path include/uapi/asm-generic/fcntl.h
* Unmerged path security/selinux/hooks.c
