netfilter: nf_tables: set pktinfo->thoff at AH header if found

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 568af6de058cb2b0c5b98d98ffcf37cdc6bc38a7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/568af6de.failed

Phil Sutter reports that IPv6 AH header matching is broken. From
userspace, nft generates bytecode that expects to find the AH header at
NFT_PAYLOAD_TRANSPORT_HEADER both for IPv4 and IPv6. However,
pktinfo->thoff is set to the inner header after the AH header in IPv6,
while in IPv4 pktinfo->thoff points to the AH header indeed. This
behaviour is inconsistent. This patch fixes this problem by updating
ipv6_find_hdr() to get the IP6_FH_F_AUTH flag so this function stops at
the AH header, so both IPv4 and IPv6 pktinfo->thoff point to the AH
header.

This is also inconsistent when trying to match encapsulated headers:

1) A packet that looks like IPv4 + AH + TCP dport 22 will *not* match.
2) A packet that looks like IPv6 + AH + TCP dport 22 will match.

	Reported-by: Phil Sutter <phil@nwl.cc>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 568af6de058cb2b0c5b98d98ffcf37cdc6bc38a7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_tables_ipv6.h
diff --cc include/net/netfilter/nf_tables_ipv6.h
index 8ad39a6a5fe1,97983d1c05e4..000000000000
--- a/include/net/netfilter/nf_tables_ipv6.h
+++ b/include/net/netfilter/nf_tables_ipv6.h
@@@ -14,8 -15,44 +15,49 @@@ nft_set_pktinfo_ipv6(struct nft_pktinf
  
  	nft_set_pktinfo(pkt, skb, state);
  
++<<<<<<< HEAD
 +	protohdr = ipv6_find_hdr(pkt->skb, &thoff, -1, &frag_off, NULL);
 +	/* If malformed, drop it */
++=======
+ 	protohdr = ipv6_find_hdr(pkt->skb, &thoff, -1, &frag_off, &flags);
+ 	if (protohdr < 0) {
+ 		nft_set_pktinfo_proto_unspec(pkt, skb);
+ 		return;
+ 	}
+ 
+ 	pkt->tprot_set = true;
+ 	pkt->tprot = protohdr;
+ 	pkt->xt.thoff = thoff;
+ 	pkt->xt.fragoff = frag_off;
+ }
+ 
+ static inline int
+ __nft_set_pktinfo_ipv6_validate(struct nft_pktinfo *pkt,
+ 				struct sk_buff *skb,
+ 				const struct nf_hook_state *state)
+ {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	unsigned int flags = IP6_FH_F_AUTH;
+ 	struct ipv6hdr *ip6h, _ip6h;
+ 	unsigned int thoff = 0;
+ 	unsigned short frag_off;
+ 	int protohdr;
+ 	u32 pkt_len;
+ 
+ 	ip6h = skb_header_pointer(skb, skb_network_offset(skb), sizeof(*ip6h),
+ 				  &_ip6h);
+ 	if (!ip6h)
+ 		return -1;
+ 
+ 	if (ip6h->version != 6)
+ 		return -1;
+ 
+ 	pkt_len = ntohs(ip6h->payload_len);
+ 	if (pkt_len + sizeof(*ip6h) > skb->len)
+ 		return -1;
+ 
+ 	protohdr = ipv6_find_hdr(pkt->skb, &thoff, -1, &frag_off, &flags);
++>>>>>>> 568af6de058c (netfilter: nf_tables: set pktinfo->thoff at AH header if found)
  	if (protohdr < 0)
  		return -1;
  
* Unmerged path include/net/netfilter/nf_tables_ipv6.h
