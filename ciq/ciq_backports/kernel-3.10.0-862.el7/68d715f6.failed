netvsc: check error return when restoring channels and mtu

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author stephen hemminger <stephen@networkplumber.org>
commit 68d715f68541d58033199eea80991394a6886eb7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/68d715f6.failed

If setting new values fails, and the attempt to restore original
settings fails. Then log an error and leave device down.
This should never happen, but if it does don't go down in flames.

	Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 68d715f68541d58033199eea80991394a6886eb7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/netvsc_drv.c
diff --cc drivers/net/hyperv/netvsc_drv.c
index d4dc9c189b85,c7391889938b..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -741,84 -804,59 +741,116 @@@ static int netvsc_set_channels(struct n
  {
  	struct net_device_context *net_device_ctx = netdev_priv(net);
  	struct hv_device *dev = net_device_ctx->device_ctx;
 -	struct netvsc_device *nvdev = rtnl_dereference(net_device_ctx->nvdev);
 -	unsigned int orig, count = channels->combined_count;
 +	struct netvsc_device *nvdev = net_device_ctx->nvdev;
  	struct netvsc_device_info device_info;
 -	bool was_opened;
 +	u32 num_chn;
 +	u32 max_chn;
  	int ret = 0;
 +	bool recovering = false;
  
 -	/* We do not support separate count for rx, tx, or other */
 -	if (count == 0 ||
 -	    channels->rx_count || channels->tx_count || channels->other_count)
 -		return -EINVAL;
 -
 -	if (count > net->num_tx_queues || count > VRSS_CHANNEL_MAX)
 -		return -EINVAL;
 -
 -	if (!nvdev || nvdev->destroy)
 +	if (net_device_ctx->start_remove || !nvdev || nvdev->destroy)
  		return -ENODEV;
  
 -	if (nvdev->nvsp_version < NVSP_PROTOCOL_VERSION_5)
 +	num_chn = nvdev->num_chn;
 +	max_chn = min_t(u32, nvdev->max_chn, num_online_cpus());
 +
 +	if (nvdev->nvsp_version < NVSP_PROTOCOL_VERSION_5) {
 +		pr_info("vRSS unsupported before NVSP Version 5\n");
  		return -EINVAL;
++<<<<<<< HEAD
++=======
+ 
+ 	if (count > nvdev->max_chn)
+ 		return -EINVAL;
+ 
+ 	orig = nvdev->num_chn;
+ 	was_opened = rndis_filter_opened(nvdev);
+ 	if (was_opened)
+ 		rndis_filter_close(nvdev);
+ 
+ 	rndis_filter_device_remove(dev, nvdev);
+ 
+ 	memset(&device_info, 0, sizeof(device_info));
+ 	device_info.num_chn = count;
+ 	device_info.ring_size = ring_size;
+ 
+ 	nvdev = rndis_filter_device_add(dev, &device_info);
+ 	if (!IS_ERR(nvdev)) {
+ 		netif_set_real_num_tx_queues(net, nvdev->num_chn);
+ 		netif_set_real_num_rx_queues(net, nvdev->num_chn);
+ 	} else {
+ 		ret = PTR_ERR(nvdev);
+ 		device_info.num_chn = orig;
+ 		nvdev = rndis_filter_device_add(dev, &device_info);
+ 
+ 		if (IS_ERR(nvdev)) {
+ 			netdev_err(net, "restoring channel setting failed: %ld\n",
+ 				   PTR_ERR(nvdev));
+ 			return ret;
+ 		}
++>>>>>>> 68d715f68541 (netvsc: check error return when restoring channels and mtu)
  	}
  
 -	if (was_opened)
 -		rndis_filter_open(nvdev);
 +	/* We do not support rx, tx, or other */
 +	if (!channels ||
 +	    channels->rx_count ||
 +	    channels->tx_count ||
 +	    channels->other_count ||
 +	    (channels->combined_count < 1))
 +		return -EINVAL;
 +
 +	if (channels->combined_count > max_chn) {
 +		pr_info("combined channels too high, using %d\n", max_chn);
 +		channels->combined_count = max_chn;
 +	}
 +
 +	ret = netvsc_close(net);
 +	if (ret)
 +		goto out;
 +
 + do_set:
 +	net_device_ctx->start_remove = true;
 +	rndis_filter_device_remove(dev);
 +
 +	nvdev->num_chn = channels->combined_count;
 +
 +	memset(&device_info, 0, sizeof(device_info));
 +	device_info.num_chn = nvdev->num_chn; /* passed to RNDIS */
 +	device_info.ring_size = ring_size;
 +	device_info.max_num_vrss_chns = max_num_vrss_chns;
 +
 +	ret = rndis_filter_device_add(dev, &device_info);
 +	if (ret) {
 +		if (recovering) {
 +			netdev_err(net, "unable to add netvsc device (ret %d)\n", ret);
 +			return ret;
 +		}
 +		goto recover;
 +	}
 +
 +	nvdev = net_device_ctx->nvdev;
 +
 +	ret = netif_set_real_num_tx_queues(net, nvdev->num_chn);
 +	if (ret) {
 +		if (recovering) {
 +			netdev_err(net, "could not set tx queue count (ret %d)\n", ret);
 +			return ret;
 +		}
 +		goto recover;
 +	}
 +
 +	ret = netif_set_real_num_rx_queues(net, nvdev->num_chn);
 +	if (ret) {
 +		if (recovering) {
 +			netdev_err(net, "could not set rx queue count (ret %d)\n", ret);
 +			return ret;
 +		}
 +		goto recover;
 +	}
  
 + out:
 +	netvsc_open(net);
 +	net_device_ctx->start_remove = false;
  	/* We may have missed link change notifications */
  	net_device_ctx->last_reconfig = 0;
  	schedule_delayed_work(&net_device_ctx->dwork, 0);
@@@ -893,42 -922,59 +925,63 @@@ static int netvsc_set_link_ksettings(st
  static int netvsc_change_mtu(struct net_device *ndev, int mtu)
  {
  	struct net_device_context *ndevctx = netdev_priv(ndev);
 -	struct net_device *vf_netdev = rtnl_dereference(ndevctx->vf_netdev);
 -	struct netvsc_device *nvdev = rtnl_dereference(ndevctx->nvdev);
 +	struct netvsc_device *nvdev = ndevctx->nvdev;
  	struct hv_device *hdev = ndevctx->device_ctx;
 -	int orig_mtu = ndev->mtu;
  	struct netvsc_device_info device_info;
 -	bool was_opened;
 +	int limit = ETH_DATA_LEN;
 +	u32 num_chn;
  	int ret = 0;
  
 -	if (!nvdev || nvdev->destroy)
 +	if (ndevctx->start_remove || !nvdev || nvdev->destroy)
  		return -ENODEV;
  
 -	/* Change MTU of underlying VF netdev first. */
 -	if (vf_netdev) {
 -		ret = dev_set_mtu(vf_netdev, mtu);
 -		if (ret)
 -			return ret;
 -	}
 +	if (nvdev->nvsp_version >= NVSP_PROTOCOL_VERSION_2)
 +		limit = NETVSC_MTU - ETH_HLEN;
  
 -	netif_device_detach(ndev);
 -	was_opened = rndis_filter_opened(nvdev);
 -	if (was_opened)
 -		rndis_filter_close(nvdev);
 +	if (mtu < NETVSC_MTU_MIN || mtu > limit)
 +		return -EINVAL;
  
 -	memset(&device_info, 0, sizeof(device_info));
 -	device_info.ring_size = ring_size;
 -	device_info.num_chn = nvdev->num_chn;
 +	ret = netvsc_close(ndev);
 +	if (ret)
 +		goto out;
  
 -	rndis_filter_device_remove(hdev, nvdev);
 +	num_chn = nvdev->num_chn;
  
 -	ndev->mtu = mtu;
 +	ndevctx->start_remove = true;
 +	rndis_filter_device_remove(hdev);
  
 -	nvdev = rndis_filter_device_add(hdev, &device_info);
 -	if (IS_ERR(nvdev)) {
 -		ret = PTR_ERR(nvdev);
 +	ndev->mtu = mtu;
  
 +	memset(&device_info, 0, sizeof(device_info));
 +	device_info.ring_size = ring_size;
 +	device_info.num_chn = num_chn;
 +	device_info.max_num_vrss_chns = max_num_vrss_chns;
 +	rndis_filter_device_add(hdev, &device_info);
 +
++<<<<<<< HEAD
 +out:
 +	netvsc_open(ndev);
 +	ndevctx->start_remove = false;
++=======
+ 		/* Attempt rollback to original MTU */
+ 		ndev->mtu = orig_mtu;
+ 		nvdev = rndis_filter_device_add(hdev, &device_info);
+ 
+ 		if (vf_netdev)
+ 			dev_set_mtu(vf_netdev, orig_mtu);
+ 
+ 		if (IS_ERR(nvdev)) {
+ 			netdev_err(ndev, "restoring mtu failed: %ld\n",
+ 				   PTR_ERR(nvdev));
+ 			return ret;
+ 		}
+ 	}
+ 
+ 	if (was_opened)
+ 		rndis_filter_open(nvdev);
+ 
+ 	netif_device_attach(ndev);
++>>>>>>> 68d715f68541 (netvsc: check error return when restoring channels and mtu)
  
  	/* We may have missed link change notifications */
  	schedule_delayed_work(&ndevctx->dwork, 0);
* Unmerged path drivers/net/hyperv/netvsc_drv.c
