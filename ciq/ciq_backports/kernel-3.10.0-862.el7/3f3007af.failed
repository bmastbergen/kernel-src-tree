s390/zcrypt: introduce state machine for the AP bus

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [s390] zcrypt: introduce state machine for the AP bus (Hendrik Brueckner) [1380349]
Rebuild_FUZZ: 94.85%
commit-author Martin Schwidefsky <schwidefsky@de.ibm.com>
commit 3f3007afda8bb731a3422430752ca91ddc102e4d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/3f3007af.failed

Replace the two fields 'unregistered' and 'reset' with a device
state with 5 possible values. Introduce two events for the AP devices,
device poll and device timeout. With the state machine it is easier
to deal with device initialization and suspend/resume. Device polling
is simpler as well, the arkane 'flags' passing is gone.

Reviewd-by: Ingo Tuchscherer <ingo.tuchscherer@linux.vnet.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 3f3007afda8bb731a3422430752ca91ddc102e4d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/ap_bus.c
diff --cc drivers/s390/crypto/ap_bus.c
index 5386d81f8cd3,92d3b67b3839..000000000000
--- a/drivers/s390/crypto/ap_bus.c
+++ b/drivers/s390/crypto/ap_bus.c
@@@ -48,23 -49,6 +48,26 @@@
  
  #include "ap_bus.h"
  
++<<<<<<< HEAD
 +/* Some prototypes. */
 +static void ap_scan_bus(struct work_struct *);
 +static void ap_poll_all(unsigned long);
 +static enum hrtimer_restart ap_poll_timeout(struct hrtimer *);
 +static int ap_poll_thread_start(void);
 +static void ap_poll_thread_stop(void);
 +static void ap_request_timeout(unsigned long);
 +static inline void ap_schedule_poll_timer(void);
 +static int __ap_poll_device(struct ap_device *ap_dev, unsigned long *flags);
 +static int ap_device_remove(struct device *dev);
 +static int ap_device_probe(struct device *dev);
 +static void ap_interrupt_handler(struct airq_struct *airq);
 +static void ap_reset(struct ap_device *ap_dev, unsigned long *flags);
 +static void ap_config_timeout(unsigned long ptr);
 +static int ap_select_domain(void);
 +static void ap_query_configuration(void);
 +
++=======
++>>>>>>> 3f3007afda8b (s390/zcrypt: introduce state machine for the AP bus)
  /*
   * Module description.
   */
@@@ -609,28 -745,278 +780,281 @@@ static enum ap_wait ap_sm_reset_wait(st
  }
  
  /**
-  * ap_decrease_queue_count(): Decrease queue count.
-  * @ap_dev: Pointer to an AP device.
+  * ap_sm_setirq_wait(): Test queue for completion of the irq enablement
+  * @ap_dev: pointer to the AP device
   *
-  * If AP device is still alive, re-schedule request timeout if there are still
-  * pending requests.
+  * Returns AP_POLL_IMMEDIATELY, AP_POLL_AFTER_TIMEROUT or 0.
   */
- static void ap_decrease_queue_count(struct ap_device *ap_dev)
+ static enum ap_wait ap_sm_setirq_wait(struct ap_device *ap_dev)
  {
- 	int timeout = ap_dev->drv->request_timeout;
+ 	struct ap_queue_status status;
+ 	unsigned long info;
  
- 	ap_dev->queue_count--;
  	if (ap_dev->queue_count > 0)
- 		mod_timer(&ap_dev->timeout, jiffies + timeout);
+ 		/* Try to read a completed message and get the status */
+ 		status = ap_sm_recv(ap_dev);
  	else
- 		/*
- 		 * The timeout timer should to be disabled now - since
- 		 * del_timer_sync() is very expensive, we just tell via the
- 		 * reset flag to ignore the pending timeout timer.
- 		 */
- 		ap_dev->reset = AP_RESET_IGNORE;
+ 		/* Get the status with TAPQ */
+ 		status = ap_test_queue(ap_dev->qid, &info);
+ 
+ 	if (status.int_enabled == 1) {
+ 		/* Irqs are now enabled */
+ 		ap_dev->interrupt = AP_INTR_ENABLED;
+ 		ap_dev->state = (ap_dev->queue_count > 0) ?
+ 			AP_STATE_WORKING : AP_STATE_IDLE;
+ 	}
+ 
+ 	switch (status.response_code) {
+ 	case AP_RESPONSE_NORMAL:
+ 		if (ap_dev->queue_count > 0)
+ 			return AP_WAIT_AGAIN;
+ 		/* fallthrough */
+ 	case AP_RESPONSE_NO_PENDING_REPLY:
+ 		return AP_WAIT_TIMEOUT;
+ 	default:
+ 		ap_dev->state = AP_STATE_BORKED;
+ 		return AP_WAIT_NONE;
+ 	}
  }
  
+ /*
+  * AP state machine jump table
+  */
+ ap_func_t *ap_jumptable[NR_AP_STATES][NR_AP_EVENTS] = {
+ 	[AP_STATE_RESET_START] = {
+ 		[AP_EVENT_POLL] = ap_sm_reset,
+ 		[AP_EVENT_TIMEOUT] = ap_sm_nop,
+ 	},
+ 	[AP_STATE_RESET_WAIT] = {
+ 		[AP_EVENT_POLL] = ap_sm_reset_wait,
+ 		[AP_EVENT_TIMEOUT] = ap_sm_nop,
+ 	},
+ 	[AP_STATE_SETIRQ_WAIT] = {
+ 		[AP_EVENT_POLL] = ap_sm_setirq_wait,
+ 		[AP_EVENT_TIMEOUT] = ap_sm_nop,
+ 	},
+ 	[AP_STATE_IDLE] = {
+ 		[AP_EVENT_POLL] = ap_sm_write,
+ 		[AP_EVENT_TIMEOUT] = ap_sm_nop,
+ 	},
+ 	[AP_STATE_WORKING] = {
+ 		[AP_EVENT_POLL] = ap_sm_read_write,
+ 		[AP_EVENT_TIMEOUT] = ap_sm_reset,
+ 	},
+ 	[AP_STATE_QUEUE_FULL] = {
+ 		[AP_EVENT_POLL] = ap_sm_read,
+ 		[AP_EVENT_TIMEOUT] = ap_sm_reset,
+ 	},
+ 	[AP_STATE_SUSPEND_WAIT] = {
+ 		[AP_EVENT_POLL] = ap_sm_read,
+ 		[AP_EVENT_TIMEOUT] = ap_sm_nop,
+ 	},
+ 	[AP_STATE_BORKED] = {
+ 		[AP_EVENT_POLL] = ap_sm_nop,
+ 		[AP_EVENT_TIMEOUT] = ap_sm_nop,
+ 	},
+ };
+ 
+ static inline enum ap_wait ap_sm_event(struct ap_device *ap_dev,
+ 				       enum ap_event event)
+ {
+ 	return ap_jumptable[ap_dev->state][event](ap_dev);
+ }
+ 
+ static inline enum ap_wait ap_sm_event_loop(struct ap_device *ap_dev,
+ 					    enum ap_event event)
+ {
+ 	enum ap_wait wait;
+ 
+ 	while ((wait = ap_sm_event(ap_dev, event)) == AP_WAIT_AGAIN)
+ 		;
+ 	return wait;
+ }
+ 
+ /**
+  * ap_request_timeout(): Handling of request timeouts
+  * @data: Holds the AP device.
+  *
+  * Handles request timeouts.
+  */
+ static void ap_request_timeout(unsigned long data)
+ {
+ 	struct ap_device *ap_dev = (struct ap_device *) data;
+ 
+ 	if (ap_suspend_flag)
+ 		return;
+ 	spin_lock_bh(&ap_dev->lock);
+ 	ap_sm_wait(ap_sm_event(ap_dev, AP_EVENT_TIMEOUT));
+ 	spin_unlock_bh(&ap_dev->lock);
+ }
+ 
+ /**
+  * ap_poll_timeout(): AP receive polling for finished AP requests.
+  * @unused: Unused pointer.
+  *
+  * Schedules the AP tasklet using a high resolution timer.
+  */
+ static enum hrtimer_restart ap_poll_timeout(struct hrtimer *unused)
+ {
+ 	if (!ap_suspend_flag)
+ 		tasklet_schedule(&ap_tasklet);
+ 	return HRTIMER_NORESTART;
+ }
+ 
+ /**
+  * ap_interrupt_handler() - Schedule ap_tasklet on interrupt
+  * @airq: pointer to adapter interrupt descriptor
+  */
+ static void ap_interrupt_handler(struct airq_struct *airq)
+ {
+ 	inc_irq_stat(IRQIO_APB);
+ 	if (!ap_suspend_flag)
+ 		tasklet_schedule(&ap_tasklet);
+ }
+ 
+ /**
+  * ap_tasklet_fn(): Tasklet to poll all AP devices.
+  * @dummy: Unused variable
+  *
+  * Poll all AP devices on the bus.
+  */
+ static void ap_tasklet_fn(unsigned long dummy)
+ {
+ 	struct ap_device *ap_dev;
+ 	enum ap_wait wait = AP_WAIT_NONE;
+ 
+ 	/* Reset the indicator if interrupts are used. Thus new interrupts can
+ 	 * be received. Doing it in the beginning of the tasklet is therefor
+ 	 * important that no requests on any AP get lost.
+ 	 */
+ 	if (ap_using_interrupts())
+ 		xchg(ap_airq.lsi_ptr, 0);
+ 
+ 	spin_lock(&ap_device_list_lock);
+ 	list_for_each_entry(ap_dev, &ap_device_list, list) {
+ 		spin_lock_bh(&ap_dev->lock);
+ 		wait = min(wait, ap_sm_event_loop(ap_dev, AP_EVENT_POLL));
+ 		spin_unlock_bh(&ap_dev->lock);
+ 	}
+ 	spin_unlock(&ap_device_list_lock);
+ 	ap_sm_wait(wait);
+ }
+ 
++<<<<<<< HEAD
++=======
+ /**
+  * ap_poll_thread(): Thread that polls for finished requests.
+  * @data: Unused pointer
+  *
+  * AP bus poll thread. The purpose of this thread is to poll for
+  * finished requests in a loop if there is a "free" cpu - that is
+  * a cpu that doesn't have anything better to do. The polling stops
+  * as soon as there is another task or if all messages have been
+  * delivered.
+  */
+ static int ap_poll_thread(void *data)
+ {
+ 	DECLARE_WAITQUEUE(wait, current);
+ 
+ 	set_user_nice(current, MAX_NICE);
+ 	set_freezable();
+ 	while (!kthread_should_stop()) {
+ 		add_wait_queue(&ap_poll_wait, &wait);
+ 		set_current_state(TASK_INTERRUPTIBLE);
+ 		if (ap_suspend_flag ||
+ 		    atomic_read(&ap_poll_requests) <= 0) {
+ 			schedule();
+ 			try_to_freeze();
+ 		}
+ 		set_current_state(TASK_RUNNING);
+ 		remove_wait_queue(&ap_poll_wait, &wait);
+ 		if (need_resched()) {
+ 			schedule();
+ 			try_to_freeze();
+ 			continue;
+ 		}
+ 		ap_tasklet_fn(0);
+ 	} while (!kthread_should_stop());
+ 	return 0;
+ }
+ 
+ static int ap_poll_thread_start(void)
+ {
+ 	int rc;
+ 
+ 	if (ap_using_interrupts() || ap_poll_kthread)
+ 		return 0;
+ 	mutex_lock(&ap_poll_thread_mutex);
+ 	ap_poll_kthread = kthread_run(ap_poll_thread, NULL, "appoll");
+ 	rc = PTR_RET(ap_poll_kthread);
+ 	if (rc)
+ 		ap_poll_kthread = NULL;
+ 	mutex_unlock(&ap_poll_thread_mutex);
+ 	return rc;
+ }
+ 
+ static void ap_poll_thread_stop(void)
+ {
+ 	if (!ap_poll_kthread)
+ 		return;
+ 	mutex_lock(&ap_poll_thread_mutex);
+ 	kthread_stop(ap_poll_kthread);
+ 	ap_poll_kthread = NULL;
+ 	mutex_unlock(&ap_poll_thread_mutex);
+ }
+ 
+ /**
+  * ap_queue_message(): Queue a request to an AP device.
+  * @ap_dev: The AP device to queue the message to
+  * @ap_msg: The message that is to be added
+  */
+ void ap_queue_message(struct ap_device *ap_dev, struct ap_message *ap_msg)
+ {
+ 	/* For asynchronous message handling a valid receive-callback
+ 	 * is required. */
+ 	BUG_ON(!ap_msg->receive);
+ 
+ 	spin_lock_bh(&ap_dev->lock);
+ 	/* Queue the message. */
+ 	list_add_tail(&ap_msg->list, &ap_dev->requestq);
+ 	ap_dev->requestq_count++;
+ 	ap_dev->total_request_count++;
+ 	/* Send/receive as many request from the queue as possible. */
+ 	ap_sm_wait(ap_sm_event_loop(ap_dev, AP_EVENT_POLL));
+ 	spin_unlock_bh(&ap_dev->lock);
+ }
+ EXPORT_SYMBOL(ap_queue_message);
+ 
+ /**
+  * ap_cancel_message(): Cancel a crypto request.
+  * @ap_dev: The AP device that has the message queued
+  * @ap_msg: The message that is to be removed
+  *
+  * Cancel a crypto request. This is done by removing the request
+  * from the device pending or request queue. Note that the
+  * request stays on the AP queue. When it finishes the message
+  * reply will be discarded because the psmid can't be found.
+  */
+ void ap_cancel_message(struct ap_device *ap_dev, struct ap_message *ap_msg)
+ {
+ 	struct ap_message *tmp;
+ 
+ 	spin_lock_bh(&ap_dev->lock);
+ 	if (!list_empty(&ap_msg->list)) {
+ 		list_for_each_entry(tmp, &ap_dev->pendingq, list)
+ 			if (tmp->psmid == ap_msg->psmid) {
+ 				ap_dev->pendingq_count--;
+ 				goto found;
+ 			}
+ 		ap_dev->requestq_count--;
+ found:
+ 		list_del_init(&ap_msg->list);
+ 	}
+ 	spin_unlock_bh(&ap_dev->lock);
+ }
+ EXPORT_SYMBOL(ap_cancel_message);
+ 
++>>>>>>> 3f3007afda8b (s390/zcrypt: introduce state machine for the AP bus)
  /*
   * AP device related attributes.
   */
@@@ -844,92 -1221,88 +1259,104 @@@ static int ap_uevent (struct device *de
  	return retval;
  }
  
 -static int ap_dev_suspend(struct device *dev, pm_message_t state)
 +static int ap_bus_suspend(struct device *dev, pm_message_t state)
  {
  	struct ap_device *ap_dev = to_ap_dev(dev);
- 	unsigned long flags;
  
 +	if (!ap_suspend_flag) {
 +		ap_suspend_flag = 1;
 +
 +		/* Disable scanning for devices, thus we do not want to scan
 +		 * for them after removing.
 +		 */
 +		del_timer_sync(&ap_config_timer);
 +		if (ap_work_queue != NULL) {
 +			destroy_workqueue(ap_work_queue);
 +			ap_work_queue = NULL;
 +		}
 +
 +		tasklet_disable(&ap_tasklet);
 +	}
  	/* Poll on the device until all requests are finished. */
++<<<<<<< HEAD
 +	do {
 +		flags = 0;
 +		spin_lock_bh(&ap_dev->lock);
 +		__ap_poll_device(ap_dev, &flags);
 +		spin_unlock_bh(&ap_dev->lock);
 +	} while ((flags & 1) || (flags & 2));
 +
 +	spin_lock_bh(&ap_dev->lock);
 +	ap_dev->unregistered = AP_DEV_UNREGISTERED;
 +	spin_unlock_bh(&ap_dev->lock);
 +
++=======
+ 	spin_lock_bh(&ap_dev->lock);
+ 	ap_dev->state = AP_STATE_SUSPEND_WAIT;
+ 	while (ap_sm_event(ap_dev, AP_EVENT_POLL) != AP_WAIT_NONE)
+ 		;
+ 	ap_dev->state = AP_STATE_BORKED;
+ 	spin_unlock_bh(&ap_dev->lock);
++>>>>>>> 3f3007afda8b (s390/zcrypt: introduce state machine for the AP bus)
  	return 0;
  }
  
 -static int ap_dev_resume(struct device *dev)
 -{
 -	return 0;
 -}
 -
 -static void ap_bus_suspend(void)
 -{
 -	ap_suspend_flag = 1;
 -	/*
 -	 * Disable scanning for devices, thus we do not want to scan
 -	 * for them after removing.
 -	 */
 -	flush_workqueue(ap_work_queue);
 -	tasklet_disable(&ap_tasklet);
 -}
 -
 -static int __ap_devices_unregister(struct device *dev, void *dummy)
 -{
 -	device_unregister(dev);
 -	return 0;
 -}
 -
 -static void ap_bus_resume(void)
 +static int ap_bus_resume(struct device *dev)
  {
 +	struct ap_device *ap_dev = to_ap_dev(dev);
  	int rc;
  
 -	/* Unconditionally remove all AP devices */
 -	bus_for_each_dev(&ap_bus_type, NULL, NULL, __ap_devices_unregister);
 -	/* Reset thin interrupt setting */
 -	if (ap_interrupts_available() && !ap_using_interrupts()) {
 -		rc = register_adapter_interrupt(&ap_airq);
 -		ap_airq_flag = (rc == 0);
 -	}
 -	if (!ap_interrupts_available() && ap_using_interrupts()) {
 -		unregister_adapter_interrupt(&ap_airq);
 -		ap_airq_flag = 0;
 +	if (ap_suspend_flag) {
 +		ap_suspend_flag = 0;
 +		if (ap_interrupts_available()) {
 +			if (!ap_using_interrupts()) {
 +				rc = register_adapter_interrupt(&ap_airq);
 +				ap_airq_flag = (rc == 0);
 +			}
 +		} else {
 +			if (ap_using_interrupts()) {
 +				unregister_adapter_interrupt(&ap_airq);
 +				ap_airq_flag = 0;
 +			}
 +		}
 +		ap_query_configuration();
 +		if (!user_set_domain) {
 +			ap_domain_index = -1;
 +			ap_select_domain();
 +		}
 +		init_timer(&ap_config_timer);
 +		ap_config_timer.function = ap_config_timeout;
 +		ap_config_timer.data = 0;
 +		ap_config_timer.expires = jiffies + ap_config_time * HZ;
 +		add_timer(&ap_config_timer);
 +		ap_work_queue = create_singlethread_workqueue("kapwork");
 +		if (!ap_work_queue)
 +			return -ENOMEM;
 +		tasklet_enable(&ap_tasklet);
 +		if (!ap_using_interrupts())
 +			ap_schedule_poll_timer();
 +		else
 +			tasklet_schedule(&ap_tasklet);
 +		if (ap_thread_flag)
 +			rc = ap_poll_thread_start();
 +		else
 +			rc = 0;
 +	} else
 +		rc = 0;
 +	if (AP_QID_QUEUE(ap_dev->qid) != ap_domain_index) {
 +		spin_lock_bh(&ap_dev->lock);
 +		ap_dev->qid = AP_MKQID(AP_QID_DEVICE(ap_dev->qid),
 +				       ap_domain_index);
 +		spin_unlock_bh(&ap_dev->lock);
  	}
 -	/* Reset domain */
 -	if (!user_set_domain)
 -		ap_domain_index = -1;
 -	/* Get things going again */
 -	ap_suspend_flag = 0;
 -	if (ap_airq_flag)
 -		xchg(ap_airq.lsi_ptr, 0);
 -	tasklet_enable(&ap_tasklet);
  	queue_work(ap_work_queue, &ap_config_work);
++<<<<<<< HEAD
++=======
+ }
++>>>>>>> 3f3007afda8b (s390/zcrypt: introduce state machine for the AP bus)
  
 -static int ap_power_event(struct notifier_block *this, unsigned long event,
 -			  void *ptr)
 -{
 -	switch (event) {
 -	case PM_HIBERNATION_PREPARE:
 -	case PM_SUSPEND_PREPARE:
 -		ap_bus_suspend();
 -		break;
 -	case PM_POST_HIBERNATION:
 -	case PM_POST_SUSPEND:
 -		ap_bus_resume();
 -		break;
 -	default:
 -		break;
 -	}
 -	return NOTIFY_DONE;
 +	return rc;
  }
 -static struct notifier_block ap_power_notifier = {
 -	.notifier_call = ap_power_event,
 -};
  
  static struct bus_type ap_bus_type = {
  	.name = "ap",
@@@ -1418,12 -1687,6 +1838,15 @@@ out
  	return rc;
  }
  
++<<<<<<< HEAD
 +static void ap_interrupt_handler(struct airq_struct *airq)
 +{
 +	inc_irq_stat(IRQIO_APB);
 +	tasklet_schedule(&ap_tasklet);
 +}
 +
++=======
++>>>>>>> 3f3007afda8b (s390/zcrypt: introduce state machine for the AP bus)
  /**
   * __ap_scan_bus(): Scan the AP bus.
   * @dev: Pointer to device
@@@ -1449,13 -1705,13 +1865,13 @@@ static void ap_scan_bus(struct work_str
  	struct device *dev;
  	ap_qid_t qid;
  	int queue_depth = 0, device_type = 0;
- 	unsigned int device_functions;
- 	int rc, i;
+ 	unsigned int device_functions = 0;
+ 	int rc, i, borked;
  
  	ap_query_configuration();
 -	if (ap_select_domain() != 0)
 -		goto out;
 -
 +	if (ap_select_domain() != 0) {
 +		return;
 +	}
  	for (i = 0; i < AP_DEVICES; i++) {
  		qid = AP_MKQID(i, ap_domain_index);
  		dev = bus_find_device(&ap_bus_type, NULL,
@@@ -1468,18 -1722,15 +1884,27 @@@
  		if (dev) {
  			ap_dev = to_ap_dev(dev);
  			spin_lock_bh(&ap_dev->lock);
++<<<<<<< HEAD
 +			if (rc == -ENODEV ||
 +			    ap_dev->unregistered == AP_DEV_UNREGISTERED) {
 +				spin_unlock_bh(&ap_dev->lock);
 +				if (ap_dev->unregistered == AP_DEV_UNREGISTERED)
 +					i--;
 +				device_unregister(dev);
 +				put_device(dev);
 +				continue;
 +			}
++=======
+ 			if (rc == -ENODEV)
+ 				ap_dev->state = AP_STATE_BORKED;
+ 			borked = ap_dev->state == AP_STATE_BORKED;
++>>>>>>> 3f3007afda8b (s390/zcrypt: introduce state machine for the AP bus)
  			spin_unlock_bh(&ap_dev->lock);
+ 			if (borked)	/* Remove broken device */
+ 				device_unregister(dev);
  			put_device(dev);
- 			continue;
+ 			if (!borked)
+ 				continue;
  		}
  		if (rc)
  			continue;
@@@ -1487,13 -1738,12 +1912,16 @@@
  		if (!ap_dev)
  			break;
  		ap_dev->qid = qid;
- 		rc = ap_init_queue(ap_dev);
- 		if ((rc != 0) && (rc != -EBUSY)) {
- 			kfree(ap_dev);
- 			continue;
- 		}
+ 		ap_dev->state = AP_STATE_RESET_START;
+ 		ap_dev->interrupt = AP_INTR_DISABLED;
  		ap_dev->queue_depth = queue_depth;
++<<<<<<< HEAD
 +		ap_dev->unregistered = AP_DEV_REGIST_IN_PROGRESS;
++=======
+ 		ap_dev->raw_hwtype = device_type;
+ 		ap_dev->device_type = device_type;
+ 		ap_dev->functions = device_functions;
++>>>>>>> 3f3007afda8b (s390/zcrypt: introduce state machine for the AP bus)
  		spin_lock_init(&ap_dev->lock);
  		INIT_LIST_HEAD(&ap_dev->pendingq);
  		INIT_LIST_HEAD(&ap_dev->requestq);
@@@ -1538,478 -1786,22 +1979,487 @@@
  		/* Add device attributes. */
  		rc = sysfs_create_group(&ap_dev->device.kobj,
  					&ap_dev_attr_group);
++<<<<<<< HEAD
 +		if (!rc) {
 +			spin_lock_bh(&ap_dev->lock);
 +			ap_dev->unregistered = AP_DEV_REGISTERED;
 +			spin_unlock_bh(&ap_dev->lock);
 +		}
 +		else
++=======
+ 		if (rc) {
++>>>>>>> 3f3007afda8b (s390/zcrypt: introduce state machine for the AP bus)
  			device_unregister(&ap_dev->device);
+ 			continue;
+ 		}
  	}
 -out:
 -	mod_timer(&ap_config_timer, jiffies + ap_config_time * HZ);
  }
  
 -static void ap_config_timeout(unsigned long ptr)
 +static void
 +ap_config_timeout(unsigned long ptr)
  {
 -	if (ap_suspend_flag)
 -		return;
  	queue_work(ap_work_queue, &ap_config_work);
 +	ap_config_timer.expires = jiffies + ap_config_time * HZ;
 +	add_timer(&ap_config_timer);
 +}
 +
++<<<<<<< HEAD
 +/**
 + * ap_poll_read(): Receive pending reply messages from an AP device.
 + * @ap_dev: pointer to the AP device
 + * @flags: pointer to control flags, bit 2^0 is set if another poll is
 + *	   required, bit 2^1 is set if the poll timer needs to get armed
 + *
 + * Returns 0 if the device is still present, -ENODEV if not.
 + */
 +static int ap_poll_read(struct ap_device *ap_dev, unsigned long *flags)
 +{
 +	struct ap_queue_status status;
 +	struct ap_message *ap_msg;
 +
 +	if (ap_dev->queue_count <= 0)
 +		return 0;
 +	status = __ap_recv(ap_dev->qid, &ap_dev->reply->psmid,
 +			   ap_dev->reply->message, ap_dev->reply->length);
 +	switch (status.response_code) {
 +	case AP_RESPONSE_NORMAL:
 +		ap_dev->interrupt = status.int_enabled;
 +		atomic_dec(&ap_poll_requests);
 +		ap_decrease_queue_count(ap_dev);
 +		list_for_each_entry(ap_msg, &ap_dev->pendingq, list) {
 +			if (ap_msg->psmid != ap_dev->reply->psmid)
 +				continue;
 +			list_del_init(&ap_msg->list);
 +			ap_dev->pendingq_count--;
 +			ap_msg->receive(ap_dev, ap_msg, ap_dev->reply);
 +			break;
 +		}
 +		if (ap_dev->queue_count > 0)
 +			*flags |= 1;
 +		break;
 +	case AP_RESPONSE_NO_PENDING_REPLY:
 +		ap_dev->interrupt = status.int_enabled;
 +		if (status.queue_empty) {
 +			/* The card shouldn't forget requests but who knows. */
 +			atomic_sub(ap_dev->queue_count, &ap_poll_requests);
 +			ap_dev->queue_count = 0;
 +			list_splice_init(&ap_dev->pendingq, &ap_dev->requestq);
 +			ap_dev->requestq_count += ap_dev->pendingq_count;
 +			ap_dev->pendingq_count = 0;
 +		} else
 +			*flags |= 2;
 +		break;
 +	default:
 +		return -ENODEV;
 +	}
 +	return 0;
 +}
 +
 +/**
 + * ap_poll_write(): Send messages from the request queue to an AP device.
 + * @ap_dev: pointer to the AP device
 + * @flags: pointer to control flags, bit 2^0 is set if another poll is
 + *	   required, bit 2^1 is set if the poll timer needs to get armed
 + *
 + * Returns 0 if the device is still present, -ENODEV if not.
 + */
 +static int ap_poll_write(struct ap_device *ap_dev, unsigned long *flags)
 +{
 +	struct ap_queue_status status;
 +	struct ap_message *ap_msg;
 +
 +	if (ap_dev->requestq_count <= 0 ||
 +	    (ap_dev->queue_count >= ap_dev->queue_depth) ||
 +	    (ap_dev->reset == AP_RESET_IN_PROGRESS))
 +		return 0;
 +	/* Start the next request on the queue. */
 +	ap_msg = list_entry(ap_dev->requestq.next, struct ap_message, list);
 +	status = __ap_send(ap_dev->qid, ap_msg->psmid,
 +			   ap_msg->message, ap_msg->length, ap_msg->special);
 +	switch (status.response_code) {
 +	case AP_RESPONSE_NORMAL:
 +		atomic_inc(&ap_poll_requests);
 +		ap_increase_queue_count(ap_dev);
 +		list_move_tail(&ap_msg->list, &ap_dev->pendingq);
 +		ap_dev->requestq_count--;
 +		ap_dev->pendingq_count++;
 +		if (ap_dev->queue_count < ap_dev->queue_depth &&
 +		    ap_dev->requestq_count > 0)
 +			*flags |= 1;
 +		*flags |= 2;
 +		break;
 +	case AP_RESPONSE_RESET_IN_PROGRESS:
 +		__ap_schedule_poll_timer();
 +	case AP_RESPONSE_Q_FULL:
 +		*flags |= 2;
 +		break;
 +	case AP_RESPONSE_MESSAGE_TOO_BIG:
 +	case AP_RESPONSE_REQ_FAC_NOT_INST:
 +		return -EINVAL;
 +	default:
 +		return -ENODEV;
 +	}
 +	return 0;
 +}
 +
 +/**
 + * ap_poll_queue(): Poll AP device for pending replies and send new messages.
 + * Check if the queue has a pending reset. In case it's done re-enable
 + * interrupts, otherwise reschedule the poll_timer for another attempt.
 + * @ap_dev: pointer to the bus device
 + * @flags: pointer to control flags, bit 2^0 is set if another poll is
 + *	   required, bit 2^1 is set if the poll timer needs to get armed
 + *
 + * Poll AP device for pending replies and send new messages. If either
 + * ap_poll_read or ap_poll_write returns -ENODEV unregister the device.
 + * Returns 0.
 + */
 +static inline int ap_poll_queue(struct ap_device *ap_dev, unsigned long *flags)
 +{
 +	int rc, depth, type;
 +	struct ap_queue_status status;
 +
 +
 +	if (ap_dev->reset == AP_RESET_IN_PROGRESS) {
 +		status = ap_test_queue(ap_dev->qid, &depth, &type);
 +		switch (status.response_code) {
 +		case AP_RESPONSE_NORMAL:
 +			ap_dev->reset = AP_RESET_IGNORE;
 +			if (ap_using_interrupts()) {
 +				rc = ap_queue_enable_interruption(
 +					ap_dev, ap_airq.lsi_ptr);
 +				if (!rc)
 +					ap_dev->interrupt = AP_INTR_IN_PROGRESS;
 +				else if (rc == -ENODEV) {
 +					pr_err("Registering adapter interrupts for "
 +					"AP %d failed\n", AP_QID_DEVICE(ap_dev->qid));
 +					return rc;
 +				}
 +			}
 +			/* fall through */
 +		case AP_RESPONSE_BUSY:
 +		case AP_RESPONSE_RESET_IN_PROGRESS:
 +			*flags |= AP_POLL_AFTER_TIMEOUT;
 +			break;
 +		case AP_RESPONSE_Q_NOT_AVAIL:
 +		case AP_RESPONSE_DECONFIGURED:
 +		case AP_RESPONSE_CHECKSTOPPED:
 +			return -ENODEV;
 +		default:
 +			break;
 +		}
 +	}
 +
 +	if ((ap_dev->reset != AP_RESET_IN_PROGRESS) &&
 +		(ap_dev->interrupt == AP_INTR_IN_PROGRESS)) {
 +		status = ap_test_queue(ap_dev->qid, &depth, &type);
 +		if (ap_using_interrupts()) {
 +			if (status.int_enabled == 1)
 +				ap_dev->interrupt = AP_INTR_ENABLED;
 +			else
 +				*flags |= AP_POLL_AFTER_TIMEOUT;
 +		} else
 +			ap_dev->interrupt = AP_INTR_DISABLED;
 +	}
 +
 +	rc = ap_poll_read(ap_dev, flags);
 +	if (rc)
 +		return rc;
 +	return ap_poll_write(ap_dev, flags);
 +}
 +
 +/**
 + * __ap_queue_message(): Queue a message to a device.
 + * @ap_dev: pointer to the AP device
 + * @ap_msg: the message to be queued
 + *
 + * Queue a message to a device. Returns 0 if successful.
 + */
 +static int __ap_queue_message(struct ap_device *ap_dev, struct ap_message *ap_msg)
 +{
 +	struct ap_queue_status status;
 +
 +	if (list_empty(&ap_dev->requestq) &&
 +	    (ap_dev->queue_count < ap_dev->queue_depth) &&
 +	    (ap_dev->reset != AP_RESET_IN_PROGRESS)) {
 +		status = __ap_send(ap_dev->qid, ap_msg->psmid,
 +				   ap_msg->message, ap_msg->length,
 +				   ap_msg->special);
 +		switch (status.response_code) {
 +		case AP_RESPONSE_NORMAL:
 +			list_add_tail(&ap_msg->list, &ap_dev->pendingq);
 +			atomic_inc(&ap_poll_requests);
 +			ap_dev->pendingq_count++;
 +			ap_increase_queue_count(ap_dev);
 +			ap_dev->total_request_count++;
 +			break;
 +		case AP_RESPONSE_Q_FULL:
 +		case AP_RESPONSE_RESET_IN_PROGRESS:
 +			list_add_tail(&ap_msg->list, &ap_dev->requestq);
 +			ap_dev->requestq_count++;
 +			ap_dev->total_request_count++;
 +			return -EBUSY;
 +		case AP_RESPONSE_REQ_FAC_NOT_INST:
 +		case AP_RESPONSE_MESSAGE_TOO_BIG:
 +			ap_msg->receive(ap_dev, ap_msg, ERR_PTR(-EINVAL));
 +			return -EINVAL;
 +		default:	/* Device is gone. */
 +			ap_msg->receive(ap_dev, ap_msg, ERR_PTR(-ENODEV));
 +			return -ENODEV;
 +		}
 +	} else {
 +		list_add_tail(&ap_msg->list, &ap_dev->requestq);
 +		ap_dev->requestq_count++;
 +		ap_dev->total_request_count++;
 +		return -EBUSY;
 +	}
 +	ap_schedule_poll_timer();
 +	return 0;
 +}
 +
 +void ap_queue_message(struct ap_device *ap_dev, struct ap_message *ap_msg)
 +{
 +	unsigned long flags;
 +	int rc;
 +
 +	/* For asynchronous message handling a valid receive-callback
 +	 * is required. */
 +	BUG_ON(!ap_msg->receive);
 +
 +	spin_lock_bh(&ap_dev->lock);
 +	if (!ap_dev->unregistered) {
 +		/* Make room on the queue by polling for finished requests. */
 +		rc = ap_poll_queue(ap_dev, &flags);
 +		if (!rc)
 +			rc = __ap_queue_message(ap_dev, ap_msg);
 +		if (!rc)
 +			wake_up(&ap_poll_wait);
 +		if (rc == -ENODEV) {
 +			ap_dev->unregistered = AP_DEV_UNREGISTERED;
 +			ap_msg->receive(ap_dev, ap_msg, ERR_PTR(-ENODEV));
 +		}
 +	} else if (ap_dev->unregistered == AP_DEV_UNREGISTERED) {
 +		ap_msg->receive(ap_dev, ap_msg, ERR_PTR(-ENODEV));
 +		rc = -ENODEV;
 +	} else { /* device registration in progress */
 +		ap_msg->receive(ap_dev, ap_msg, ERR_PTR(-EBUSY));
 +		rc = -EBUSY;
 +	}
 +	spin_unlock_bh(&ap_dev->lock);
 +
 +	/* no device_unregister(), let ap_scan_bus() do the job */
 +}
 +EXPORT_SYMBOL(ap_queue_message);
 +
 +/**
 + * ap_cancel_message(): Cancel a crypto request.
 + * @ap_dev: The AP device that has the message queued
 + * @ap_msg: The message that is to be removed
 + *
 + * Cancel a crypto request. This is done by removing the request
 + * from the device pending or request queue. Note that the
 + * request stays on the AP queue. When it finishes the message
 + * reply will be discarded because the psmid can't be found.
 + */
 +void ap_cancel_message(struct ap_device *ap_dev, struct ap_message *ap_msg)
 +{
 +	struct ap_message *tmp;
 +
 +	spin_lock_bh(&ap_dev->lock);
 +	if (!list_empty(&ap_msg->list)) {
 +		list_for_each_entry(tmp, &ap_dev->pendingq, list)
 +			if (tmp->psmid == ap_msg->psmid) {
 +				ap_dev->pendingq_count--;
 +				goto found;
 +			}
 +		ap_dev->requestq_count--;
 +	found:
 +		list_del_init(&ap_msg->list);
 +	}
 +	spin_unlock_bh(&ap_dev->lock);
 +}
 +EXPORT_SYMBOL(ap_cancel_message);
 +
 +/**
 + * ap_poll_timeout(): AP receive polling for finished AP requests.
 + * @unused: Unused pointer.
 + *
 + * Schedules the AP tasklet using a high resolution timer.
 + */
 +static enum hrtimer_restart ap_poll_timeout(struct hrtimer *unused)
 +{
 +	tasklet_schedule(&ap_tasklet);
 +	return HRTIMER_NORESTART;
 +}
 +
 +/**
 + * ap_reset(): Reset a not responding AP device.
 + * @ap_dev: Pointer to the AP device
 + *
 + * Reset a not responding AP device and move all requests from the
 + * pending queue to the request queue.
 + */
 +static void ap_reset(struct ap_device *ap_dev, unsigned long *flags)
 +{
 +	int rc;
 +
 +	atomic_sub(ap_dev->queue_count, &ap_poll_requests);
 +	ap_dev->queue_count = 0;
 +	list_splice_init(&ap_dev->pendingq, &ap_dev->requestq);
 +	ap_dev->requestq_count += ap_dev->pendingq_count;
 +	ap_dev->pendingq_count = 0;
 +	rc = ap_init_queue(ap_dev);
 +	if (rc == -ENODEV)
 +		ap_dev->unregistered = AP_DEV_UNREGISTERED;
 +	else
 +		*flags |= AP_POLL_AFTER_TIMEOUT;
 +}
 +
 +static int __ap_poll_device(struct ap_device *ap_dev, unsigned long *flags)
 +{
 +	int rc;
 +
 +	if (!ap_dev->unregistered) {
 +		rc = ap_poll_queue(ap_dev, flags);
 +		if (rc == -ENODEV)
 +			ap_dev->unregistered = AP_DEV_UNREGISTERED;
 +		if (ap_dev->reset == AP_RESET_DO)
 +			ap_reset(ap_dev, flags);
 +	}
 +	return 0;
 +}
 +
 +/**
 + * ap_poll_all(): Poll all AP devices.
 + * @dummy: Unused variable
 + *
 + * Poll all AP devices on the bus in a round robin fashion. Continue
 + * polling until bit 2^0 of the control flags is not set. If bit 2^1
 + * of the control flags has been set arm the poll timer.
 + */
 +static void ap_poll_all(unsigned long dummy)
 +{
 +	unsigned long flags;
 +	struct ap_device *ap_dev;
 +
 +	/* Reset the indicator if interrupts are used. Thus new interrupts can
 +	 * be received. Doing it in the beginning of the tasklet is therefor
 +	 * important that no requests on any AP get lost.
 +	 */
 +	if (ap_using_interrupts())
 +		xchg(ap_airq.lsi_ptr, 0);
 +	do {
 +		flags = 0;
 +		spin_lock(&ap_device_list_lock);
 +		list_for_each_entry(ap_dev, &ap_device_list, list) {
 +			spin_lock(&ap_dev->lock);
 +			__ap_poll_device(ap_dev, &flags);
 +			spin_unlock(&ap_dev->lock);
 +		}
 +		spin_unlock(&ap_device_list_lock);
 +	} while (flags & AP_POLL_IMMEDIATELY);
 +	if (flags & AP_POLL_AFTER_TIMEOUT)
 +		__ap_schedule_poll_timer();
 +}
 +
 +/**
 + * ap_poll_thread(): Thread that polls for finished requests.
 + * @data: Unused pointer
 + *
 + * AP bus poll thread. The purpose of this thread is to poll for
 + * finished requests in a loop if there is a "free" cpu - that is
 + * a cpu that doesn't have anything better to do. The polling stops
 + * as soon as there is another task or if all messages have been
 + * delivered.
 + */
 +static int ap_poll_thread(void *data)
 +{
 +	DECLARE_WAITQUEUE(wait, current);
 +	unsigned long flags;
 +	int requests;
 +	struct ap_device *ap_dev;
 +
 +	set_user_nice(current, 19);
 +	while (1) {
 +		if (ap_suspend_flag)
 +			return 0;
 +		if (need_resched()) {
 +			schedule();
 +			continue;
 +		}
 +		add_wait_queue(&ap_poll_wait, &wait);
 +		set_current_state(TASK_INTERRUPTIBLE);
 +		if (kthread_should_stop())
 +			break;
 +		requests = atomic_read(&ap_poll_requests);
 +		if (requests <= 0)
 +			schedule();
 +		set_current_state(TASK_RUNNING);
 +		remove_wait_queue(&ap_poll_wait, &wait);
 +
 +		flags = 0;
 +		spin_lock_bh(&ap_device_list_lock);
 +		list_for_each_entry(ap_dev, &ap_device_list, list) {
 +			spin_lock(&ap_dev->lock);
 +			__ap_poll_device(ap_dev, &flags);
 +			spin_unlock(&ap_dev->lock);
 +		}
 +		spin_unlock_bh(&ap_device_list_lock);
 +	}
 +	set_current_state(TASK_RUNNING);
 +	remove_wait_queue(&ap_poll_wait, &wait);
 +	return 0;
 +}
 +
 +static int ap_poll_thread_start(void)
 +{
 +	int rc;
 +
 +	if (ap_using_interrupts() || ap_suspend_flag)
 +		return 0;
 +	mutex_lock(&ap_poll_thread_mutex);
 +	if (!ap_poll_kthread) {
 +		ap_poll_kthread = kthread_run(ap_poll_thread, NULL, "appoll");
 +		rc = IS_ERR(ap_poll_kthread) ? PTR_ERR(ap_poll_kthread) : 0;
 +		if (rc)
 +			ap_poll_kthread = NULL;
 +	}
 +	else
 +		rc = 0;
 +	mutex_unlock(&ap_poll_thread_mutex);
 +	return rc;
 +}
 +
 +static void ap_poll_thread_stop(void)
 +{
 +	mutex_lock(&ap_poll_thread_mutex);
 +	if (ap_poll_kthread) {
 +		kthread_stop(ap_poll_kthread);
 +		ap_poll_kthread = NULL;
 +	}
 +	mutex_unlock(&ap_poll_thread_mutex);
 +}
 +
 +/**
 + * ap_request_timeout(): Handling of request timeouts
 + * @data: Holds the AP device.
 + *
 + * Handles request timeouts.
 + */
 +static void ap_request_timeout(unsigned long data)
 +{
 +	struct ap_device *ap_dev = (struct ap_device *) data;
 +
 +	if (ap_dev->reset == AP_RESET_ARMED) {
 +		ap_dev->reset = AP_RESET_DO;
 +
 +		if (ap_using_interrupts())
 +			tasklet_schedule(&ap_tasklet);
 +	}
  }
  
++=======
++>>>>>>> 3f3007afda8b (s390/zcrypt: introduce state machine for the AP bus)
  static void ap_reset_domain(void)
  {
  	int i;
@@@ -2092,18 -1893,11 +2542,24 @@@ int __init ap_module_init(void
  		goto out_root;
  	}
  
++<<<<<<< HEAD
 +	ap_query_configuration();
 +	if (ap_select_domain() == 0)
 +		ap_scan_bus(NULL);
 +
 +	/* Setup the AP bus rescan timer. */
 +	init_timer(&ap_config_timer);
 +	ap_config_timer.function = ap_config_timeout;
 +	ap_config_timer.data = 0;
 +	ap_config_timer.expires = jiffies + ap_config_time * HZ;
 +	add_timer(&ap_config_timer);
++=======
+ 	/* Setup the AP bus rescan timer. */
+ 	setup_timer(&ap_config_timer, ap_config_timeout, 0);
++>>>>>>> 3f3007afda8b (s390/zcrypt: introduce state machine for the AP bus)
  
- 	/* Setup the high resultion poll timer.
+ 	/*
+ 	 * Setup the high resultion poll timer.
  	 * If we are running under z/VM adjust polling to z/VM polling rate.
  	 */
  	if (MACHINE_IS_VM)
@@@ -2119,10 -1913,17 +2575,18 @@@
  			goto out_work;
  	}
  
++<<<<<<< HEAD
++=======
+ 	rc = register_pm_notifier(&ap_power_notifier);
+ 	if (rc)
+ 		goto out_pm;
+ 
+ 	queue_work(ap_work_queue, &ap_config_work);
+ 
++>>>>>>> 3f3007afda8b (s390/zcrypt: introduce state machine for the AP bus)
  	return 0;
  
 -out_pm:
 -	ap_poll_thread_stop();
  out_work:
- 	del_timer_sync(&ap_config_timer);
  	hrtimer_cancel(&ap_poll_timer);
  	destroy_workqueue(ap_work_queue);
  out_root:
* Unmerged path drivers/s390/crypto/ap_bus.c
diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 2da8ecdc7a5f..86e6ff367374 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -36,9 +36,6 @@
 #define AP_CONFIG_TIME 30	/* Time in seconds between AP bus rescans. */
 #define AP_POLL_TIME 1		/* Time in ticks between receive polls. */
 
-#define AP_POLL_IMMEDIATELY	1 /* continue running poll tasklet */
-#define AP_POLL_AFTER_TIMEOUT	2 /* run poll tasklet again after timout */
-
 extern int ap_domain_index;
 extern int ap_hwrng_seed;
 
@@ -133,20 +130,46 @@ static inline int ap_test_bit(unsigned int *ptr, unsigned int nr)
 #define AP_FUNC_EP11  5
 #define AP_FUNC_APXA  6
 
-/*
- * AP reset flag states
- */
-#define AP_RESET_IGNORE	0	/* request timeout will be ignored */
-#define AP_RESET_ARMED	1	/* request timeout timer is active */
-#define AP_RESET_DO	2	/* AP reset required */
-#define AP_RESET_IN_PROGRESS	3	/* AP reset in progress */
-
 /*
  * AP interrupt states
  */
 #define AP_INTR_DISABLED	0	/* AP interrupt disabled */
 #define AP_INTR_ENABLED		1	/* AP interrupt enabled */
-#define AP_INTR_IN_PROGRESS	3	/* AP interrupt in progress */
+
+/*
+ * AP device states
+ */
+enum ap_state {
+	AP_STATE_RESET_START,
+	AP_STATE_RESET_WAIT,
+	AP_STATE_SETIRQ_WAIT,
+	AP_STATE_IDLE,
+	AP_STATE_WORKING,
+	AP_STATE_QUEUE_FULL,
+	AP_STATE_SUSPEND_WAIT,
+	AP_STATE_BORKED,
+	NR_AP_STATES
+};
+
+/*
+ * AP device events
+ */
+enum ap_event {
+	AP_EVENT_POLL,
+	AP_EVENT_TIMEOUT,
+	NR_AP_EVENTS
+};
+
+/*
+ * AP wait behaviour
+ */
+enum ap_wait {
+	AP_WAIT_AGAIN,		/* retry immediately */
+	AP_WAIT_TIMEOUT,	/* wait for timeout */
+	AP_WAIT_INTERRUPT,	/* wait for thin interrupt (if available) */
+	AP_WAIT_NONE,		/* no wait */
+	NR_AP_WAIT
+};
 
 /*
  * AP device registration states
@@ -172,20 +195,22 @@ struct ap_driver {
 int ap_driver_register(struct ap_driver *, struct module *, char *);
 void ap_driver_unregister(struct ap_driver *);
 
+typedef enum ap_wait (ap_func_t)(struct ap_device *ap_dev);
+
 struct ap_device {
 	struct device device;
 	struct ap_driver *drv;		/* Pointer to AP device driver. */
 	spinlock_t lock;		/* Per device lock. */
 	struct list_head list;		/* private list of all AP devices. */
 
+	enum ap_state state;		/* State of the AP device. */
+
 	ap_qid_t qid;			/* AP queue id. */
 	int queue_depth;		/* AP queue depth.*/
 	int device_type;		/* AP device type. */
 	int raw_hwtype;			/* AP raw hardware type. */
 	unsigned int functions;		/* AP device function bitfield. */
-	int unregistered;		/* marks AP device as unregistered */
 	struct timer_list timeout;	/* Timer for request timeouts. */
-	int reset;			/* Reset required after req. timeout. */
 
 	int interrupt;			/* indicate if interrupts are enabled */
 	int queue_count;		/* # messages currently on AP queue. */
