bridge: fdb: converge fdb searching functions into one

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
commit bfd0aeac52f74bfb44c0974131e44abb33a13e78
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/bfd0aeac.failed

Before this patch we had 3 different fdb searching functions which was
confusing. This patch reduces all of them to one - fdb_find_rcu(), and
two flavors: br_fdb_find() which requires hash_lock and br_fdb_find_rcu
which requires RCU. This makes it clear what needs to be used, we also
remove two abusers of __br_fdb_get which called it under hash_lock and
replace them with br_fdb_find().

	Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bfd0aeac52f74bfb44c0974131e44abb33a13e78)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_fdb.c
#	net/bridge/br_private.h
diff --cc net/bridge/br_fdb.c
index 9836c1e87ee0,04a53a0b733d..000000000000
--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@@ -371,26 -413,6 +404,29 @@@ void br_fdb_delete_by_port(struct net_b
  	spin_unlock_bh(&br->hash_lock);
  }
  
++<<<<<<< HEAD
 +/* No locking or refcounting, assumes caller has rcu_read_lock */
 +struct net_bridge_fdb_entry *__br_fdb_get(struct net_bridge *br,
 +					  const unsigned char *addr,
 +					  __u16 vid)
 +{
 +	struct net_bridge_fdb_entry *fdb;
 +
 +	hlist_for_each_entry_rcu(fdb,
 +				&br->hash[br_mac_hash(addr, vid)], hlist) {
 +		if (ether_addr_equal(fdb->addr.addr, addr) &&
 +		    fdb->vlan_id == vid) {
 +			if (unlikely(has_expired(br, fdb)))
 +				break;
 +			return fdb;
 +		}
 +	}
 +
 +	return NULL;
 +}
 +
++=======
++>>>>>>> bfd0aeac52f7 (bridge: fdb: converge fdb searching functions into one)
  #if IS_ENABLED(CONFIG_ATM_LANE)
  /* Interface used by ATM LANE hook to test
   * if an addr is on some other bridge port */
diff --cc net/bridge/br_private.h
index 14d36b8b30c9,61368186edea..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -506,15 -504,15 +506,21 @@@ void br_fdb_find_delete_local(struct ne
  			      const unsigned char *addr, u16 vid);
  void br_fdb_changeaddr(struct net_bridge_port *p, const unsigned char *newaddr);
  void br_fdb_change_mac_address(struct net_bridge *br, const u8 *newaddr);
 -void br_fdb_cleanup(struct work_struct *work);
 +void br_fdb_cleanup(unsigned long arg);
  void br_fdb_delete_by_port(struct net_bridge *br,
  			   const struct net_bridge_port *p, u16 vid, int do_all);
++<<<<<<< HEAD
 +struct net_bridge_fdb_entry *__br_fdb_get(struct net_bridge *br,
 +					  const unsigned char *addr,
 +					  __u16 vid);
++=======
+ struct net_bridge_fdb_entry *br_fdb_find_rcu(struct net_bridge *br,
+ 					     const unsigned char *addr,
+ 					     __u16 vid);
++>>>>>>> bfd0aeac52f7 (bridge: fdb: converge fdb searching functions into one)
  int br_fdb_test_addr(struct net_device *dev, unsigned char *addr);
 -int br_fdb_fillbuf(struct net_bridge *br, void *buf, unsigned long count,
 -		   unsigned long off);
 +int br_fdb_fillbuf(struct net_bridge *br, void *buf,
 +		   unsigned long count, unsigned long off);
  int br_fdb_insert(struct net_bridge *br, struct net_bridge_port *source,
  		  const unsigned char *addr, u16 vid);
  void br_fdb_update(struct net_bridge *br, struct net_bridge_port *source,
diff --git a/net/bridge/br_device.c b/net/bridge/br_device.c
index f29f37ba5a74..8ee983946620 100644
--- a/net/bridge/br_device.c
+++ b/net/bridge/br_device.c
@@ -79,7 +79,7 @@ netdev_tx_t br_dev_xmit(struct sk_buff *skb, struct net_device *dev)
 			br_multicast_flood(mdst, skb, false, true);
 		else
 			br_flood(br, skb, BR_PKT_MULTICAST, false, true);
-	} else if ((dst = __br_fdb_get(br, dest, vid)) != NULL) {
+	} else if ((dst = br_fdb_find_rcu(br, dest, vid)) != NULL) {
 		br_forward(dst->dst, skb, false, true);
 	} else {
 		br_flood(br, skb, BR_PKT_UNICAST, false, true);
* Unmerged path net/bridge/br_fdb.c
diff --git a/net/bridge/br_input.c b/net/bridge/br_input.c
index 258d4cc758f9..8792ad943c32 100644
--- a/net/bridge/br_input.c
+++ b/net/bridge/br_input.c
@@ -114,7 +114,7 @@ static void br_do_proxy_arp(struct sk_buff *skb, struct net_bridge *br,
 			return;
 		}
 
-		f = __br_fdb_get(br, n->ha, vid);
+		f = br_fdb_find_rcu(br, n->ha, vid);
 		if (f && ((p->flags & BR_PROXYARP) ||
 			  (f->dst && (f->dst->flags & BR_PROXYARP_WIFI)))) {
 			arp_send(ARPOP_REPLY, ETH_P_ARP, sip, skb->dev, tip,
@@ -189,7 +189,7 @@ int br_handle_frame_finish(struct sock *sk, struct sk_buff *skb)
 		}
 		break;
 	case BR_PKT_UNICAST:
-		dst = __br_fdb_get(br, dest, vid);
+		dst = br_fdb_find_rcu(br, dest, vid);
 	default:
 		break;
 	}
* Unmerged path net/bridge/br_private.h
