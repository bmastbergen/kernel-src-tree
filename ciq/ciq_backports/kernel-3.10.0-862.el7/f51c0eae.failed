procfs: treat parked tasks as sleeping for task state

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Chris Metcalf <cmetcalf@ezchip.com>
commit f51c0eaee39e306458d2bf8a30e010615fa451cc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f51c0eae.failed

Allowing watchdog threads to be parked means that we now have the
opportunity of actually seeing persistent parked threads in the output
of /proc/<pid>/stat and /proc/<pid>/status.  The existing code reported
such threads as "Running", which is kind-of true if you think of the
case where we park them as part of taking cpus offline.  But if we allow
parking them indefinitely, "Running" is pretty misleading, so we report
them as "Sleeping" instead.

We could simply report them with a new string, "Parked", but it feels
like it's a bit risky for userspace to see unexpected new values; the
output is already documented in Documentation/filesystems/proc.txt, and
it seems like a mistake to change that lightly.

The scheduler does report parked tasks with a "P" in debugging output
from sched_show_task() or dump_cpu_task(), but that's a different API.
Similarly, the trace_ctxwake_* routines report a "P" for parked tasks,
but again, different API.

This change seemed slightly cleaner than updating the task_state_array
to have additional rows.  TASK_DEAD should be subsumed by the exit_state
bits; TASK_WAKEKILL is just a modifier; and TASK_WAKING can very
reasonably be reported as "Running" (as it is now).  Only TASK_PARKED
shows up with unreasonable output here.

	Signed-off-by: Chris Metcalf <cmetcalf@ezchip.com>
	Cc: Don Zickus <dzickus@redhat.com>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: Ulrich Obergfell <uobergfe@redhat.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit f51c0eaee39e306458d2bf8a30e010615fa451cc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/proc/array.c
diff --cc fs/proc/array.c
index e72efe817a60,3f57dac31ba6..000000000000
--- a/fs/proc/array.c
+++ b/fs/proc/array.c
@@@ -149,29 -124,19 +149,41 @@@ static const char * const task_state_ar
  
  static inline const char *get_task_state(struct task_struct *tsk)
  {
 -	unsigned int state = (tsk->state | tsk->exit_state) & TASK_REPORT;
 +	unsigned int state = (tsk->state & TASK_REPORT) | tsk->exit_state;
 +	const char * const *p = &task_state_array[0];
  
++<<<<<<< HEAD
 +	BUILD_BUG_ON(1 + ilog2(TASK_STATE_MAX) != ARRAY_SIZE(task_state_array));
++=======
+ 	/*
+ 	 * Parked tasks do not run; they sit in __kthread_parkme().
+ 	 * Without this check, we would report them as running, which is
+ 	 * clearly wrong, so we report them as sleeping instead.
+ 	 */
+ 	if (tsk->state == TASK_PARKED)
+ 		state = TASK_INTERRUPTIBLE;
+ 
+ 	BUILD_BUG_ON(1 + ilog2(TASK_REPORT) != ARRAY_SIZE(task_state_array)-1);
++>>>>>>> f51c0eaee39e (procfs: treat parked tasks as sleeping for task state)
  
 -	return task_state_array[fls(state)];
 +	while (state) {
 +		p++;
 +		state >>= 1;
 +	}
 +	return *p;
 +}
 +
 +static inline int get_task_umask(struct task_struct *tsk)
 +{
 +	struct fs_struct *fs;
 +	int umask = -ENOENT;
 +
 +	task_lock(tsk);
 +	fs = tsk->fs;
 +	if (fs)
 +		umask = fs->umask;
 +	task_unlock(tsk);
 +	return umask;
  }
  
  static inline void task_state(struct seq_file *m, struct pid_namespace *ns,
* Unmerged path fs/proc/array.c
