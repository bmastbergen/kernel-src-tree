ALSA: x86: Remove superfluous check at resume

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Takashi Iwai <tiwai@suse.de>
commit caa2a61a702a2a391b2fb695fc245ca5b8a4ffd8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/caa2a61a.failed

The had_get_hwstate() is identical with drv_status==DISCONECTED, which
was already checked before the call.  And, returning an error at
resume is simply bad.  That is, we should just kill this check.

Also, spewing an error at resume for drv_status!=SUSPENDED is also
annoying, as this is the normal case when the suspend was called
without the monitor connection.  Make it debug, too.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit caa2a61a702a2a391b2fb695fc245ca5b8a4ffd8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/x86/intel_hdmi_audio.c
diff --cc sound/x86/intel_hdmi_audio.c
index f2f54691cb43,835e0f2c4f0b..000000000000
--- a/sound/x86/intel_hdmi_audio.c
+++ b/sound/x86/intel_hdmi_audio.c
@@@ -1461,8 -1430,349 +1461,354 @@@ out
  	return retval;
  }
  
++<<<<<<< HEAD
 +/*PCM operations structure and the calls back for the same */
 +struct snd_pcm_ops snd_intelhad_playback_ops = {
++=======
+ /*
+  * hdmi_lpe_audio_suspend - power management suspend function
+  *
+  * @pdev: platform device
+  *
+  * This function is called by client driver to suspend the
+  * hdmi audio.
+  */
+ static int hdmi_lpe_audio_suspend(struct platform_device *pdev,
+ 				  pm_message_t state)
+ {
+ 	struct had_stream_data *had_stream;
+ 	unsigned long flag_irqs;
+ 	struct snd_pcm_substream *substream;
+ 	struct snd_intelhad *intelhaddata = platform_get_drvdata(pdev);
+ 
+ 	had_stream = &intelhaddata->stream_data;
+ 	substream = intelhaddata->stream_info.had_substream;
+ 
+ 	if (!pm_runtime_status_suspended(intelhaddata->dev)) {
+ 		dev_err(intelhaddata->dev, "audio stream is active\n");
+ 		return -EAGAIN;
+ 	}
+ 
+ 	spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
+ 	if (intelhaddata->drv_status == HAD_DRV_DISCONNECTED) {
+ 		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 		dev_dbg(intelhaddata->dev, "had not connected\n");
+ 		return 0;
+ 	}
+ 
+ 	if (intelhaddata->drv_status == HAD_DRV_SUSPENDED) {
+ 		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 		dev_dbg(intelhaddata->dev, "had already suspended\n");
+ 		return 0;
+ 	}
+ 
+ 	intelhaddata->drv_status = HAD_DRV_SUSPENDED;
+ 	dev_dbg(intelhaddata->dev,
+ 		"%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_SUSPENDED\n",
+ 			__func__, __LINE__);
+ 
+ 	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 	snd_intelhad_enable_audio_int(intelhaddata, false);
+ 	return 0;
+ }
+ 
+ /*
+  * hdmi_lpe_audio_resume - power management resume function
+  *
+  *@pdev: platform device
+  *
+  * This function is called by client driver to resume the
+  * hdmi audio.
+  */
+ static int hdmi_lpe_audio_resume(struct platform_device *pdev)
+ {
+ 	struct snd_intelhad *intelhaddata = platform_get_drvdata(pdev);
+ 	unsigned long flag_irqs;
+ 
+ 	spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
+ 	if (intelhaddata->drv_status == HAD_DRV_DISCONNECTED) {
+ 		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 		dev_dbg(intelhaddata->dev, "had not connected\n");
+ 		return 0;
+ 	}
+ 
+ 	if (intelhaddata->drv_status != HAD_DRV_SUSPENDED) {
+ 		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 		dev_dbg(intelhaddata->dev, "had is not in suspended state\n");
+ 		return 0;
+ 	}
+ 
+ 	intelhaddata->drv_status = HAD_DRV_CONNECTED;
+ 	dev_dbg(intelhaddata->dev,
+ 		"%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_DISCONNECTED\n",
+ 			__func__, __LINE__);
+ 	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 	snd_intelhad_enable_audio_int(intelhaddata, true);
+ 	return 0;
+ }
+ 
+ static inline int had_chk_intrmiss(struct snd_intelhad *intelhaddata,
+ 		enum intel_had_aud_buf_type buf_id)
+ {
+ 	int i, intr_count = 0;
+ 	enum intel_had_aud_buf_type buff_done;
+ 	u32 buf_size, buf_addr;
+ 	struct had_stream_data *had_stream;
+ 	unsigned long flag_irqs;
+ 
+ 	had_stream = &intelhaddata->stream_data;
+ 
+ 	buff_done = buf_id;
+ 
+ 	intr_count = snd_intelhad_read_len(intelhaddata);
+ 	if (intr_count > 1) {
+ 		/* In case of active playback */
+ 		dev_err(intelhaddata->dev,
+ 			"Driver detected %d missed buffer done interrupt(s)\n",
+ 			(intr_count - 1));
+ 		if (intr_count > 3)
+ 			return intr_count;
+ 
+ 		buf_id += (intr_count - 1);
+ 		/* Reprogram registers*/
+ 		for (i = buff_done; i < buf_id; i++) {
+ 			int j = i % 4;
+ 
+ 			buf_size = intelhaddata->buf_info[j].buf_size;
+ 			buf_addr = intelhaddata->buf_info[j].buf_addr;
+ 			had_write_register(intelhaddata,
+ 					   AUD_BUF_A_LENGTH +
+ 					   (j * HAD_REG_WIDTH), buf_size);
+ 			had_write_register(intelhaddata,
+ 					   AUD_BUF_A_ADDR+(j * HAD_REG_WIDTH),
+ 					   (buf_addr | BIT(0) | BIT(1)));
+ 		}
+ 		buf_id = buf_id % 4;
+ 		spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
+ 		intelhaddata->buff_done = buf_id;
+ 		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 	}
+ 
+ 	return intr_count;
+ }
+ 
+ static int had_process_buffer_done(struct snd_intelhad *intelhaddata)
+ {
+ 	u32 len = 1;
+ 	enum intel_had_aud_buf_type buf_id;
+ 	enum intel_had_aud_buf_type buff_done;
+ 	struct pcm_stream_info *stream;
+ 	u32 buf_size;
+ 	struct had_stream_data *had_stream;
+ 	int intr_count;
+ 	enum had_status_stream		stream_type;
+ 	unsigned long flag_irqs;
+ 
+ 	had_stream = &intelhaddata->stream_data;
+ 	stream = &intelhaddata->stream_info;
+ 	intr_count = 1;
+ 
+ 	spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
+ 	if (intelhaddata->drv_status == HAD_DRV_DISCONNECTED) {
+ 		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 		dev_dbg(intelhaddata->dev,
+ 			"%s:Device already disconnected\n", __func__);
+ 		return 0;
+ 	}
+ 	buf_id = intelhaddata->curr_buf;
+ 	intelhaddata->buff_done = buf_id;
+ 	buff_done = intelhaddata->buff_done;
+ 	buf_size = intelhaddata->buf_info[buf_id].buf_size;
+ 	stream_type = had_stream->stream_type;
+ 
+ 	/* Every debug statement has an implication
+ 	 * of ~5msec. Thus, avoid having >3 debug statements
+ 	 * for each buffer_done handling.
+ 	 */
+ 
+ 	/* Check for any intr_miss in case of active playback */
+ 	if (had_stream->stream_type == HAD_RUNNING_STREAM) {
+ 		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 		intr_count = had_chk_intrmiss(intelhaddata, buf_id);
+ 		if (!intr_count || (intr_count > 3)) {
+ 			dev_err(intelhaddata->dev,
+ 				"HAD SW state in non-recoverable mode\n");
+ 			return 0;
+ 		}
+ 		buf_id += (intr_count - 1);
+ 		buf_id = buf_id % 4;
+ 		spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
+ 	}
+ 
+ 	intelhaddata->buf_info[buf_id].is_valid = true;
+ 	if (intelhaddata->valid_buf_cnt-1 == buf_id) {
+ 		if (had_stream->stream_type >= HAD_RUNNING_STREAM)
+ 			intelhaddata->curr_buf = HAD_BUF_TYPE_A;
+ 	} else
+ 		intelhaddata->curr_buf = buf_id + 1;
+ 
+ 	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 
+ 	if (had_get_hwstate(intelhaddata)) {
+ 		dev_dbg(intelhaddata->dev, "HDMI cable plugged-out\n");
+ 		return 0;
+ 	}
+ 
+ 	/*Reprogram the registers with addr and length*/
+ 	had_write_register(intelhaddata,
+ 			   AUD_BUF_A_LENGTH + (buf_id * HAD_REG_WIDTH),
+ 			   buf_size);
+ 	had_write_register(intelhaddata,
+ 			   AUD_BUF_A_ADDR + (buf_id * HAD_REG_WIDTH),
+ 			   intelhaddata->buf_info[buf_id].buf_addr |
+ 			   BIT(0) | BIT(1));
+ 
+ 	had_read_register(intelhaddata,
+ 			  AUD_BUF_A_LENGTH + (buf_id * HAD_REG_WIDTH),
+ 			  &len);
+ 	dev_dbg(intelhaddata->dev, "%s:Enabled buf[%d]\n", __func__, buf_id);
+ 
+ 	/* In case of actual data,
+ 	 * report buffer_done to above ALSA layer
+ 	 */
+ 	buf_size = intelhaddata->buf_info[buf_id].buf_size;
+ 	if (stream_type >= HAD_RUNNING_STREAM) {
+ 		intelhaddata->stream_info.buffer_rendered +=
+ 			(intr_count * buf_size);
+ 		had_period_elapsed(stream->had_substream);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int had_process_buffer_underrun(struct snd_intelhad *intelhaddata)
+ {
+ 	enum intel_had_aud_buf_type buf_id;
+ 	struct pcm_stream_info *stream;
+ 	struct had_stream_data *had_stream;
+ 	enum had_status_stream stream_type;
+ 	unsigned long flag_irqs;
+ 	int drv_status;
+ 
+ 	had_stream = &intelhaddata->stream_data;
+ 	stream = &intelhaddata->stream_info;
+ 
+ 	spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
+ 	buf_id = intelhaddata->curr_buf;
+ 	stream_type = had_stream->stream_type;
+ 	intelhaddata->buff_done = buf_id;
+ 	drv_status = intelhaddata->drv_status;
+ 	if (stream_type == HAD_RUNNING_STREAM)
+ 		intelhaddata->curr_buf = HAD_BUF_TYPE_A;
+ 
+ 	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 
+ 	dev_dbg(intelhaddata->dev, "Enter:%s buf_id=%d, stream_type=%d\n",
+ 			__func__, buf_id, stream_type);
+ 
+ 	snd_intelhad_handle_underrun(intelhaddata);
+ 
+ 	if (drv_status == HAD_DRV_DISCONNECTED) {
+ 		dev_dbg(intelhaddata->dev,
+ 			"%s:Device already disconnected\n", __func__);
+ 		return 0;
+ 	}
+ 
+ 	if (stream_type == HAD_RUNNING_STREAM) {
+ 		/* Report UNDERRUN error to above layers */
+ 		intelhaddata->flag_underrun = true;
+ 		had_period_elapsed(stream->had_substream);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int had_process_hot_plug(struct snd_intelhad *intelhaddata)
+ {
+ 	enum intel_had_aud_buf_type buf_id;
+ 	struct snd_pcm_substream *substream;
+ 	struct had_stream_data *had_stream;
+ 	unsigned long flag_irqs;
+ 
+ 	substream = intelhaddata->stream_info.had_substream;
+ 	had_stream = &intelhaddata->stream_data;
+ 
+ 	spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
+ 	if (intelhaddata->drv_status == HAD_DRV_CONNECTED) {
+ 		dev_dbg(intelhaddata->dev, "Device already connected\n");
+ 		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 		return 0;
+ 	}
+ 	buf_id = intelhaddata->curr_buf;
+ 	intelhaddata->buff_done = buf_id;
+ 	intelhaddata->drv_status = HAD_DRV_CONNECTED;
+ 	dev_dbg(intelhaddata->dev,
+ 		"%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_CONNECTED\n",
+ 			__func__, __LINE__);
+ 	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 
+ 	dev_dbg(intelhaddata->dev, "Processing HOT_PLUG, buf_id = %d\n",
+ 		buf_id);
+ 
+ 	/* Safety check */
+ 	if (substream) {
+ 		dev_dbg(intelhaddata->dev,
+ 			"Force to stop the active stream by disconnection\n");
+ 		/* Set runtime->state to hw_params done */
+ 		snd_pcm_stop(substream, SNDRV_PCM_STATE_SETUP);
+ 	}
+ 
+ 	had_build_channel_allocation_map(intelhaddata);
+ 
+ 	return 0;
+ }
+ 
+ static int had_process_hot_unplug(struct snd_intelhad *intelhaddata)
+ {
+ 	enum intel_had_aud_buf_type buf_id;
+ 	struct had_stream_data *had_stream;
+ 	unsigned long flag_irqs;
+ 
+ 	had_stream = &intelhaddata->stream_data;
+ 	buf_id = intelhaddata->curr_buf;
+ 
+ 	spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
+ 
+ 	if (intelhaddata->drv_status == HAD_DRV_DISCONNECTED) {
+ 		dev_dbg(intelhaddata->dev, "Device already disconnected\n");
+ 		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 		return 0;
+ 
+ 	} else {
+ 		/* Disable Audio */
+ 		snd_intelhad_enable_audio_int(intelhaddata, false);
+ 		snd_intelhad_enable_audio(intelhaddata, false);
+ 	}
+ 
+ 	intelhaddata->drv_status = HAD_DRV_DISCONNECTED;
+ 	dev_dbg(intelhaddata->dev,
+ 		"%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_DISCONNECTED\n",
+ 			__func__, __LINE__);
+ 
+ 	/* Report to above ALSA layer */
+ 	if (intelhaddata->stream_info.had_substream != NULL) {
+ 		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 		snd_pcm_stop(intelhaddata->stream_info.had_substream,
+ 				SNDRV_PCM_STATE_SETUP);
+ 		spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
+ 	}
+ 
+ 	had_stream->stream_type = HAD_INIT;
+ 	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 	kfree(intelhaddata->chmap->chmap);
+ 	intelhaddata->chmap->chmap = NULL;
+ 
+ 	return 0;
+ }
+ 
+ /* PCM operations structure and the calls back for the same */
+ static struct snd_pcm_ops snd_intelhad_playback_ops = {
++>>>>>>> caa2a61a702a (ALSA: x86: Remove superfluous check at resume)
  	.open =		snd_intelhad_open,
  	.close =	snd_intelhad_close,
  	.ioctl =	snd_pcm_lib_ioctl,
* Unmerged path sound/x86/intel_hdmi_audio.c
