netvsc: allow driver to be removed even if VF is present

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Stephen Hemminger <stephen@networkplumber.org>
commit ec158f77def2df084d9f62565357e3037b04bd3f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ec158f77.failed

If VF is attached then can still allow netvsc driver module to
be removed. Just have to make sure and do the cleanup.

Also, avoid extra rtnl round trip when calling unregister.

	Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ec158f77def2df084d9f62565357e3037b04bd3f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/netvsc_drv.c
diff --cc drivers/net/hyperv/netvsc_drv.c
index 5103dca8a92e,3aee4b68ff13..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -1378,11 -1834,10 +1378,14 @@@ static int netvsc_register_vf(struct ne
  	if (!netvsc_dev || rtnl_dereference(net_device_ctx->vf_netdev))
  		return NOTIFY_DONE;
  
 -	if (netvsc_vf_join(vf_netdev, ndev) != 0)
 -		return NOTIFY_DONE;
 -
  	netdev_info(ndev, "VF registering: %s\n", vf_netdev->name);
++<<<<<<< HEAD
 +	/*
 +	 * Take a reference on the module.
 +	 */
 +	try_module_get(THIS_MODULE);
++=======
++>>>>>>> ec158f77def2 (netvsc: allow driver to be removed even if VF is present)
  
  	dev_hold(vf_netdev);
  	rcu_assign_pointer(net_device_ctx->vf_netdev, vf_netdev);
@@@ -1461,9 -1881,12 +1464,14 @@@ static int netvsc_unregister_vf(struct 
  
  	netdev_info(ndev, "VF unregistering: %s\n", vf_netdev->name);
  
++<<<<<<< HEAD
++=======
+ 	netdev_rx_handler_unregister(vf_netdev);
+ 	netdev_upper_dev_unlink(vf_netdev, ndev);
++>>>>>>> ec158f77def2 (netvsc: allow driver to be removed even if VF is present)
  	RCU_INIT_POINTER(net_device_ctx->vf_netdev, NULL);
  	dev_put(vf_netdev);
- 	module_put(THIS_MODULE);
+ 
  	return NOTIFY_OK;
  }
  
@@@ -1567,30 -2002,28 +1575,42 @@@ static int netvsc_remove(struct hv_devi
  
  	ndev_ctx = netdev_priv(net);
  
 -	netif_device_detach(net);
 +	/* Avoid racing with netvsc_change_mtu()/netvsc_set_channels()
 +	 * removing the device.
 +	 */
 +	rtnl_lock();
++<<<<<<< HEAD
 +	ndev_ctx->start_remove = true;
 +	rtnl_unlock();
  
  	cancel_delayed_work_sync(&ndev_ctx->dwork);
 +	cancel_work_sync(&ndev_ctx->work);
 +
 +	/* Stop outbound asap */
 +	netif_tx_disable(net);
 +
 +	unregister_netdev(net);
  
  	/*
  	 * Call to the vsc driver to let it know that the device is being
 -	 * removed. Also blocks mtu and channel changes.
 +	 * removed
  	 */
 -	rtnl_lock();
 +	rndis_filter_device_remove(dev);
 +
++=======
+ 	vf_netdev = rtnl_dereference(ndev_ctx->vf_netdev);
+ 	if (vf_netdev)
+ 		netvsc_unregister_vf(vf_netdev);
+ 
+ 	rndis_filter_device_remove(dev,
+ 				   rtnl_dereference(ndev_ctx->nvdev));
+ 	unregister_netdevice(net);
+ 	rtnl_unlock();
+ 
++>>>>>>> ec158f77def2 (netvsc: allow driver to be removed even if VF is present)
  	hv_set_drvdata(dev, NULL);
  
 -	free_percpu(ndev_ctx->vf_stats);
 -	free_netdev(net);
 +	netvsc_free_netdev(net);
  	return 0;
  }
  
* Unmerged path drivers/net/hyperv/netvsc_drv.c
