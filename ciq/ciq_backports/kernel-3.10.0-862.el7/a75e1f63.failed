x86: also use debug_pagealloc_enabled() for free_init_pages

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Christian Borntraeger <borntraeger@de.ibm.com>
commit a75e1f637cf137f82cf025321e7a53adeeed7029
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a75e1f63.failed

we want to couple all debugging features with debug_pagealloc_enabled()
and not with the config option CONFIG_DEBUG_PAGEALLOC.

	Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>
	Suggested-by: David Rientjes <rientjes@google.com>
	Acked-by: David Rientjes <rientjes@google.com>
	Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: Laura Abbott <labbott@fedoraproject.org>
	Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
	Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit a75e1f637cf137f82cf025321e7a53adeeed7029)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/mm/init.c
diff --cc arch/x86/mm/init.c
index 5223743762dc,9d56f271d519..000000000000
--- a/arch/x86/mm/init.c
+++ b/arch/x86/mm/init.c
@@@ -682,26 -667,22 +682,32 @@@ void free_init_pages(char *what, unsign
  	 * mark them not present - any buggy init-section access will
  	 * create a kernel page fault:
  	 */
- #ifdef CONFIG_DEBUG_PAGEALLOC
- 	printk(KERN_INFO "debug: unmapping init [mem %#010lx-%#010lx]\n",
- 		begin, end - 1);
- 	set_memory_np(begin, (end - begin) >> PAGE_SHIFT);
- #else
- 	/*
- 	 * We just marked the kernel text read only above, now that
- 	 * we are going to free part of that, we need to make that
- 	 * writeable and non-executable first.
- 	 */
- 	set_memory_nx(begin, (end - begin) >> PAGE_SHIFT);
- 	set_memory_rw(begin, (end - begin) >> PAGE_SHIFT);
+ 	if (debug_pagealloc_enabled()) {
+ 		pr_info("debug: unmapping init [mem %#010lx-%#010lx]\n",
+ 			begin, end - 1);
+ 		set_memory_np(begin, (end - begin) >> PAGE_SHIFT);
+ 	} else {
+ 		/*
+ 		 * We just marked the kernel text read only above, now that
+ 		 * we are going to free part of that, we need to make that
+ 		 * writeable and non-executable first.
+ 		 */
+ 		set_memory_nx(begin, (end - begin) >> PAGE_SHIFT);
+ 		set_memory_rw(begin, (end - begin) >> PAGE_SHIFT);
  
++<<<<<<< HEAD
 +	printk(KERN_INFO "Freeing %s: %luk freed\n", what, (end - begin) >> 10);
 +
 +	for (; addr < end; addr += PAGE_SIZE) {
 +		memset((void *)addr, POISON_FREE_INITMEM, PAGE_SIZE);
 +		free_reserved_page(virt_to_page(addr));
 +	}
 +#endif
++=======
+ 		free_reserved_area((void *)begin, (void *)end,
+ 				   POISON_FREE_INITMEM, what);
+ 	}
++>>>>>>> a75e1f637cf1 (x86: also use debug_pagealloc_enabled() for free_init_pages)
  }
  
  void free_initmem(void)
* Unmerged path arch/x86/mm/init.c
