net: bridge: Add support for calling FDB external learning under rcu

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] bridge: Add support for calling FDB external learning under rcu (Ivan Vecera) [1500896]
Rebuild_FUZZ: 96.18%
commit-author Arkadi Sharshevsky <arkadis@mellanox.com>
commit 0baa10fff2c8a8a0e3bca8fb43112ed93c179c38
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0baa10ff.failed

This is done as a preparation to moving the switchdev notifier chain
to be atomic. The FDB external learning should be called under rtnl
or rcu.

	Signed-off-by: Arkadi Sharshevsky <arkadis@mellanox.com>
	Reviewed-by: Ido Schimmel <idosch@mellanox.com>
	Reviewed-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0baa10fff2c8a8a0e3bca8fb43112ed93c179c38)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_private.h
diff --cc net/bridge/br_private.h
index 8fb47feaf09a,a122684b6a41..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -285,14 -284,27 +285,24 @@@ static inline struct net_bridge_port *b
  		rtnl_dereference(dev->rx_handler_data) : NULL;
  }
  
++<<<<<<< HEAD
 +struct net_bridge
 +{
++=======
+ static inline struct net_bridge_port *br_port_get_rtnl_rcu(const struct net_device *dev)
+ {
+ 	return br_port_exists(dev) ?
+ 		rcu_dereference_rtnl(dev->rx_handler_data) : NULL;
+ }
+ 
+ struct net_bridge {
++>>>>>>> 0baa10fff2c8 (net: bridge: Add support for calling FDB external learning under rcu)
  	spinlock_t			lock;
 -	spinlock_t			hash_lock;
  	struct list_head		port_list;
  	struct net_device		*dev;
 -	struct pcpu_sw_netstats		__percpu *stats;
 -	/* These fields are accessed on each packet */
 -#ifdef CONFIG_BRIDGE_VLAN_FILTERING
 -	u8				vlan_enabled;
 -	u8				vlan_stats_enabled;
 -	__be16				vlan_proto;
 -	u16				default_pvid;
 -	struct net_bridge_vlan_group	__rcu *vlgrp;
 -#endif
  
 +	RH_KABI_REPLACE(struct br_cpu_netstats __percpu *stats, struct pcpu_sw_netstats		__percpu *stats)
 +	spinlock_t			hash_lock;
  	struct hlist_head		hash[BR_HASH_SIZE];
  #if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
  	union {
diff --git a/net/bridge/br.c b/net/bridge/br.c
index 41f5f99612de..d27dbc625597 100644
--- a/net/bridge/br.c
+++ b/net/bridge/br.c
@@ -121,7 +121,7 @@ static struct notifier_block br_device_notifier = {
 	.notifier_call = br_device_event
 };
 
-/* called with RTNL */
+/* called with RTNL or RCU */
 static int br_switchdev_event(struct notifier_block *unused,
 			      unsigned long event, void *ptr)
 {
@@ -131,7 +131,7 @@ static int br_switchdev_event(struct notifier_block *unused,
 	struct switchdev_notifier_fdb_info *fdb_info;
 	int err = NOTIFY_DONE;
 
-	p = br_port_get_rtnl(dev);
+	p = br_port_get_rtnl_rcu(dev);
 	if (!p)
 		goto out;
 
diff --git a/net/bridge/br_fdb.c b/net/bridge/br_fdb.c
index 62cb7bb1ffcf..00df2e3b83d8 100644
--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@ -1111,7 +1111,6 @@ int br_fdb_external_learn_add(struct net_bridge *br, struct net_bridge_port *p,
 	struct net_bridge_fdb_entry *fdb;
 	int err = 0;
 
-	ASSERT_RTNL();
 	spin_lock_bh(&br->hash_lock);
 
 	head = &br->hash[br_mac_hash(addr, vid)];
@@ -1147,7 +1146,6 @@ int br_fdb_external_learn_del(struct net_bridge *br, struct net_bridge_port *p,
 	struct net_bridge_fdb_entry *fdb;
 	int err = 0;
 
-	ASSERT_RTNL();
 	spin_lock_bh(&br->hash_lock);
 
 	head = &br->hash[br_mac_hash(addr, vid)];
* Unmerged path net/bridge/br_private.h
