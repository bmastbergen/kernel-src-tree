arm64: move ELF_ET_DYN_BASE to 4GB / 4MB

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [powerpc] move ELF_ET_DYN_BASE to 4GB / 4MB (Bhupesh Sharma) [1432288]
Rebuild_FUZZ: 90.41%
commit-author Kees Cook <keescook@chromium.org>
commit 02445990a96e60a67526510d8b00f7e3d14101c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/02445990.failed

Now that explicitly executed loaders are loaded in the mmap region, we
have more freedom to decide where we position PIE binaries in the
address space to avoid possible collisions with mmap or stack regions.

For 64-bit, align to 4GB to allow runtimes to use the entire 32-bit
address space for 32-bit pointers.  On 32-bit use 4MB, to match ARM.
This could be 0x8000, the standard ET_EXEC load address, but that is
needlessly close to the NULL address, and anyone running arm compat PIE
will have an MMU, so the tight mapping is not needed.

Link: http://lkml.kernel.org/r/1498251600-132458-4-git-send-email-keescook@chromium.org
	Signed-off-by: Kees Cook <keescook@chromium.org>
	Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Mark Rutland <mark.rutland@arm.com>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 02445990a96e60a67526510d8b00f7e3d14101c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/asm/elf.h
diff --cc arch/arm64/include/asm/elf.h
index fe32c0e4ac01,acae781f7359..000000000000
--- a/arch/arm64/include/asm/elf.h
+++ b/arch/arm64/include/asm/elf.h
@@@ -109,13 -113,22 +109,27 @@@ typedef struct user_fpsimd_state elf_fp
  #define ELF_EXEC_PAGESIZE	PAGE_SIZE
  
  /*
-  * This is the location that an ET_DYN program is loaded if exec'ed.  Typical
-  * use of this is to invoke "./ld.so someprog" to test out a new version of
-  * the loader.  We need to make sure that it is out of the way of the program
-  * that it will "exec", and that there is sufficient room for the brk.
+  * This is the base location for PIE (ET_DYN with INTERP) loads. On
+  * 64-bit, this is raised to 4GB to leave the entire 32-bit address
+  * space open for things that want to use the area for 32-bit pointers.
   */
++<<<<<<< HEAD
 +extern unsigned long randomize_et_dyn(unsigned long base);
 +#define ELF_ET_DYN_BASE	(randomize_et_dyn(2 * TASK_SIZE_64 / 3))
++=======
+ #define ELF_ET_DYN_BASE		0x100000000UL
+ 
+ #ifndef __ASSEMBLY__
+ 
+ typedef unsigned long elf_greg_t;
+ 
+ #define ELF_NGREG (sizeof(struct user_pt_regs) / sizeof(elf_greg_t))
+ #define ELF_CORE_COPY_REGS(dest, regs)	\
+ 	*(struct user_pt_regs *)&(dest) = (regs)->user_regs;
+ 
+ typedef elf_greg_t elf_gregset_t[ELF_NGREG];
+ typedef struct user_fpsimd_state elf_fpregset_t;
++>>>>>>> 02445990a96e (arm64: move ELF_ET_DYN_BASE to 4GB / 4MB)
  
  /*
   * When the program starts, a1 contains a pointer to a function to be
@@@ -146,15 -165,16 +160,20 @@@ extern int arch_setup_additional_pages(
  #define STACK_RND_MASK			(0x3ffff >> (PAGE_SHIFT - 12))
  #endif
  
 -#ifdef __AARCH64EB__
 -#define COMPAT_ELF_PLATFORM		("v8b")
 -#else
 -#define COMPAT_ELF_PLATFORM		("v8l")
 -#endif
 +struct mm_struct;
 +extern unsigned long arch_randomize_brk(struct mm_struct *mm);
 +#define arch_randomize_brk arch_randomize_brk
  
  #ifdef CONFIG_COMPAT
 +#define EM_ARM				40
 +#define COMPAT_ELF_PLATFORM		("v8l")
  
++<<<<<<< HEAD
 +#define COMPAT_ELF_ET_DYN_BASE		(randomize_et_dyn(2 * TASK_SIZE_32 / 3))
++=======
+ /* PIE load location for compat arm. Must match ARM ELF_ET_DYN_BASE. */
+ #define COMPAT_ELF_ET_DYN_BASE		0x000400000UL
++>>>>>>> 02445990a96e (arm64: move ELF_ET_DYN_BASE to 4GB / 4MB)
  
  /* AArch32 registers. */
  #define COMPAT_ELF_NGREG		18
* Unmerged path arch/arm64/include/asm/elf.h
