ALSA: x86: Drop had_get_hwstate()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Takashi Iwai <tiwai@suse.de>
commit 79f439ea4007b94beeb8ba1e00e71f9d128b0f90
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/79f439ea.failed

The helper function isn't clearer than the plain condition check
"if (drv_status == HDA_DRV_DISCONNECTED)".  By expanding this, the
compiler could even catch the possible uninitialized cases, so we
could fix them, too.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 79f439ea4007b94beeb8ba1e00e71f9d128b0f90)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/x86/intel_hdmi_audio.c
diff --cc sound/x86/intel_hdmi_audio.c
index f2f54691cb43,7c6549a10c1c..000000000000
--- a/sound/x86/intel_hdmi_audio.c
+++ b/sound/x86/intel_hdmi_audio.c
@@@ -155,80 -155,69 +155,123 @@@ static const struct snd_pcm_hardware sn
  };
  
  /* Register access functions */
++<<<<<<< HEAD
 +
 +int had_get_hwstate(struct snd_intelhad *intelhaddata)
 +{
 +	/* Check for device presence -SW state */
 +	if (intelhaddata->drv_status == HAD_DRV_DISCONNECTED) {
 +		pr_debug("%s:Device not connected:%d\n", __func__,
 +				intelhaddata->drv_status);
 +		return -ENODEV;
++=======
+ static inline void
+ mid_hdmi_audio_read(struct snd_intelhad *ctx, u32 reg, u32 *val)
+ {
+ 	*val = ioread32(ctx->mmio_start + ctx->had_config_offset + reg);
+ }
+ 
+ static inline void
+ mid_hdmi_audio_write(struct snd_intelhad *ctx, u32 reg, u32 val)
+ {
+ 	iowrite32(val, ctx->mmio_start + ctx->had_config_offset + reg);
+ }
+ 
+ static int had_read_register(struct snd_intelhad *intelhaddata,
+ 			     u32 offset, u32 *data)
+ {
+ 	if (intelhaddata->drv_status == HAD_DRV_DISCONNECTED)
+ 		return -ENODEV;
+ 
+ 	mid_hdmi_audio_read(intelhaddata, offset, data);
+ 	return 0;
+ }
+ 
+ static void fixup_dp_config(struct snd_intelhad *intelhaddata,
+ 			    u32 offset, u32 *data)
+ {
+ 	if (intelhaddata->dp_output) {
+ 		if (offset == AUD_CONFIG && (*data & AUD_CONFIG_VALID_BIT))
+ 			*data |= AUD_CONFIG_DP_MODE | AUD_CONFIG_BLOCK_BIT;
++>>>>>>> 79f439ea4007 (ALSA: x86: Drop had_get_hwstate())
  	}
 +
 +	return 0;
  }
  
 -static int had_write_register(struct snd_intelhad *intelhaddata,
 -			      u32 offset, u32 data)
 +int had_get_caps(struct snd_intelhad *intelhaddata,
 +		 enum had_caps_list query, void *caps)
  {
++<<<<<<< HEAD
 +	int retval;
 +
 +	retval = had_get_hwstate(intelhaddata);
 +	if (!retval)
 +		retval = mid_hdmi_audio_get_caps(query, caps);
++=======
+ 	if (intelhaddata->drv_status == HAD_DRV_DISCONNECTED)
+ 		return -ENODEV;
++>>>>>>> 79f439ea4007 (ALSA: x86: Drop had_get_hwstate())
  
 -	fixup_dp_config(intelhaddata, offset, &data);
 -	mid_hdmi_audio_write(intelhaddata, offset, data);
 -	return 0;
 +	return retval;
  }
  
 -static int had_read_modify(struct snd_intelhad *intelhaddata, u32 offset,
 -			   u32 data, u32 mask)
 +int had_set_caps(struct snd_intelhad *intelhaddata,
 +		 enum had_caps_list set_element, void *caps)
  {
++<<<<<<< HEAD
 +	int retval;
 +
 +	retval = had_get_hwstate(intelhaddata);
 +	if (!retval)
 +		retval = mid_hdmi_audio_set_caps(set_element, caps);
++=======
+ 	u32 val_tmp;
+ 
+ 	if (intelhaddata->drv_status == HAD_DRV_DISCONNECTED)
+ 		return -ENODEV;
++>>>>>>> 79f439ea4007 (ALSA: x86: Drop had_get_hwstate())
  
 -	mid_hdmi_audio_read(intelhaddata, offset, &val_tmp);
 -	val_tmp &= ~mask;
 -	val_tmp |= (data & mask);
 +	return retval;
 +}
  
 -	fixup_dp_config(intelhaddata, offset, &val_tmp);
 -	mid_hdmi_audio_write(intelhaddata, offset, val_tmp);
 -	return 0;
 +int had_read_register(struct snd_intelhad *intelhaddata, u32 offset, u32 *data)
 +{
 +	int retval;
 +
 +	retval = had_get_hwstate(intelhaddata);
 +	if (!retval)
 +		retval = mid_hdmi_audio_read(offset, data);
 +
 +	return retval;
  }
  
 -/*
 - * function to read-modify AUD_CONFIG register on VLV2.
 - * The had_read_modify() function should not directly be used on VLV2 for
 - * updating AUD_CONFIG register.
 +int had_write_register(struct snd_intelhad *intelhaddata, u32 offset, u32 data)
 +{
 +	int retval;
 +
 +	retval = had_get_hwstate(intelhaddata);
 +	if (!retval)
 +		retval = mid_hdmi_audio_write(offset, data);
 +
 +	return retval;
 +}
 +
 +int had_read_modify(struct snd_intelhad *intelhaddata, u32 offset,
 +		    u32 data, u32 mask)
 +{
 +	int retval;
 +
 +	retval = had_get_hwstate(intelhaddata);
 +	if (!retval)
 +		retval = mid_hdmi_audio_rmw(offset, data, mask);
 +
 +	return retval;
 +}
 +/**
 + * function to read-modify
 + * AUD_CONFIG register on VLV2.The had_read_modify() function should not
 + * directly be used on VLV2 for updating AUD_CONFIG register.
   * This is because:
   * Bit6 of AUD_CONFIG register is writeonly due to a silicon bug on VLV2
   * HDMI IP. As a result a read-modify of AUD_CONFIG regiter will always
@@@ -917,9 -911,9 +960,9 @@@ static int snd_intelhad_prog_n(u32 aud_
  	return 0;
  }
  
 -static void snd_intelhad_handle_underrun(struct snd_intelhad *intelhaddata)
 +void snd_intelhad_handle_underrun(struct snd_intelhad *intelhaddata)
  {
- 	u32 hdmi_status, i = 0;
+ 	u32 hdmi_status = 0, i = 0;
  
  	/* Handle Underrun interrupt within Audio Unit */
  	had_write_register(intelhaddata, AUD_CONFIG, 0);
@@@ -967,8 -960,9 +1010,14 @@@ static int snd_intelhad_open(struct snd
  
  	pm_runtime_get(intelhaddata->dev);
  
++<<<<<<< HEAD
 +	if (had_get_hwstate(intelhaddata)) {
 +		pr_err("%s: HDMI cable plugged-out\n", __func__);
++=======
+ 	if (intelhaddata->drv_status == HAD_DRV_DISCONNECTED) {
+ 		dev_dbg(intelhaddata->dev, "%s: HDMI cable plugged-out\n",
+ 			__func__);
++>>>>>>> 79f439ea4007 (ALSA: x86: Drop had_get_hwstate())
  		retval = -ENODEV;
  		goto exit_put_handle;
  	}
@@@ -1185,11 -1167,10 +1234,17 @@@ static int snd_intelhad_pcm_trigger(str
  
  	switch (cmd) {
  	case SNDRV_PCM_TRIGGER_START:
 +		pr_debug("Trigger Start\n");
 +
  		/* Disable local INTRs till register prgmng is done */
++<<<<<<< HEAD
 +		if (had_get_hwstate(intelhaddata)) {
 +			pr_err("_START: HDMI cable plugged-out\n");
++=======
+ 		if (intelhaddata->drv_status == HAD_DRV_DISCONNECTED) {
+ 			dev_dbg(intelhaddata->dev,
+ 				"_START: HDMI cable plugged-out\n");
++>>>>>>> 79f439ea4007 (ALSA: x86: Drop had_get_hwstate())
  			retval = -ENODEV;
  			break;
  		}
@@@ -1263,10 -1226,11 +1318,16 @@@ static int snd_intelhad_pcm_prepare(str
  
  	intelhaddata = snd_pcm_substream_chip(substream);
  	runtime = substream->runtime;
 -	had_stream = &intelhaddata->stream_data;
 +	had_stream = intelhaddata->private_data;
  
++<<<<<<< HEAD
 +	if (had_get_hwstate(intelhaddata)) {
 +		pr_err("%s: HDMI cable plugged-out\n", __func__);
++=======
+ 	if (intelhaddata->drv_status == HAD_DRV_DISCONNECTED) {
+ 		dev_dbg(intelhaddata->dev, "%s: HDMI cable plugged-out\n",
+ 			__func__);
++>>>>>>> 79f439ea4007 (ALSA: x86: Drop had_get_hwstate())
  		retval = -ENODEV;
  		goto prep_end;
  	}
@@@ -1352,12 -1310,13 +1413,15 @@@ static snd_pcm_uframes_t snd_intelhad_p
  	u32 t;
  	int buf_id;
  
 +	/* pr_debug("snd_intelhad_pcm_pointer called\n"); */
 +
  	intelhaddata = snd_pcm_substream_chip(substream);
  
+ 	if (intelhaddata->drv_status == HAD_DRV_DISCONNECTED)
+ 		return SNDRV_PCM_POS_XRUN;
+ 
  	if (intelhaddata->flag_underrun) {
 -		intelhaddata->flag_underrun = false;
 +		intelhaddata->flag_underrun = 0;
  		return SNDRV_PCM_POS_XRUN;
  	}
  
@@@ -1461,8 -1416,349 +1525,354 @@@ out
  	return retval;
  }
  
++<<<<<<< HEAD
 +/*PCM operations structure and the calls back for the same */
 +struct snd_pcm_ops snd_intelhad_playback_ops = {
++=======
+ /*
+  * hdmi_lpe_audio_suspend - power management suspend function
+  *
+  * @pdev: platform device
+  *
+  * This function is called by client driver to suspend the
+  * hdmi audio.
+  */
+ static int hdmi_lpe_audio_suspend(struct platform_device *pdev,
+ 				  pm_message_t state)
+ {
+ 	struct had_stream_data *had_stream;
+ 	unsigned long flag_irqs;
+ 	struct snd_pcm_substream *substream;
+ 	struct snd_intelhad *intelhaddata = platform_get_drvdata(pdev);
+ 
+ 	had_stream = &intelhaddata->stream_data;
+ 	substream = intelhaddata->stream_info.had_substream;
+ 
+ 	if (!pm_runtime_status_suspended(intelhaddata->dev)) {
+ 		dev_err(intelhaddata->dev, "audio stream is active\n");
+ 		return -EAGAIN;
+ 	}
+ 
+ 	spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
+ 	if (intelhaddata->drv_status == HAD_DRV_DISCONNECTED) {
+ 		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 		dev_dbg(intelhaddata->dev, "had not connected\n");
+ 		return 0;
+ 	}
+ 
+ 	if (intelhaddata->drv_status == HAD_DRV_SUSPENDED) {
+ 		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 		dev_dbg(intelhaddata->dev, "had already suspended\n");
+ 		return 0;
+ 	}
+ 
+ 	intelhaddata->drv_status = HAD_DRV_SUSPENDED;
+ 	dev_dbg(intelhaddata->dev,
+ 		"%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_SUSPENDED\n",
+ 			__func__, __LINE__);
+ 
+ 	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 	snd_intelhad_enable_audio_int(intelhaddata, false);
+ 	return 0;
+ }
+ 
+ /*
+  * hdmi_lpe_audio_resume - power management resume function
+  *
+  *@pdev: platform device
+  *
+  * This function is called by client driver to resume the
+  * hdmi audio.
+  */
+ static int hdmi_lpe_audio_resume(struct platform_device *pdev)
+ {
+ 	struct snd_intelhad *intelhaddata = platform_get_drvdata(pdev);
+ 	unsigned long flag_irqs;
+ 
+ 	spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
+ 	if (intelhaddata->drv_status == HAD_DRV_DISCONNECTED) {
+ 		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 		dev_dbg(intelhaddata->dev, "had not connected\n");
+ 		return 0;
+ 	}
+ 
+ 	if (intelhaddata->drv_status != HAD_DRV_SUSPENDED) {
+ 		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 		dev_dbg(intelhaddata->dev, "had is not in suspended state\n");
+ 		return 0;
+ 	}
+ 
+ 	intelhaddata->drv_status = HAD_DRV_CONNECTED;
+ 	dev_dbg(intelhaddata->dev,
+ 		"%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_DISCONNECTED\n",
+ 			__func__, __LINE__);
+ 	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 	snd_intelhad_enable_audio_int(intelhaddata, true);
+ 	return 0;
+ }
+ 
+ static inline int had_chk_intrmiss(struct snd_intelhad *intelhaddata,
+ 		enum intel_had_aud_buf_type buf_id)
+ {
+ 	int i, intr_count = 0;
+ 	enum intel_had_aud_buf_type buff_done;
+ 	u32 buf_size, buf_addr;
+ 	struct had_stream_data *had_stream;
+ 	unsigned long flag_irqs;
+ 
+ 	had_stream = &intelhaddata->stream_data;
+ 
+ 	buff_done = buf_id;
+ 
+ 	intr_count = snd_intelhad_read_len(intelhaddata);
+ 	if (intr_count > 1) {
+ 		/* In case of active playback */
+ 		dev_err(intelhaddata->dev,
+ 			"Driver detected %d missed buffer done interrupt(s)\n",
+ 			(intr_count - 1));
+ 		if (intr_count > 3)
+ 			return intr_count;
+ 
+ 		buf_id += (intr_count - 1);
+ 		/* Reprogram registers*/
+ 		for (i = buff_done; i < buf_id; i++) {
+ 			int j = i % 4;
+ 
+ 			buf_size = intelhaddata->buf_info[j].buf_size;
+ 			buf_addr = intelhaddata->buf_info[j].buf_addr;
+ 			had_write_register(intelhaddata,
+ 					   AUD_BUF_A_LENGTH +
+ 					   (j * HAD_REG_WIDTH), buf_size);
+ 			had_write_register(intelhaddata,
+ 					   AUD_BUF_A_ADDR+(j * HAD_REG_WIDTH),
+ 					   (buf_addr | BIT(0) | BIT(1)));
+ 		}
+ 		buf_id = buf_id % 4;
+ 		spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
+ 		intelhaddata->buff_done = buf_id;
+ 		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 	}
+ 
+ 	return intr_count;
+ }
+ 
+ static int had_process_buffer_done(struct snd_intelhad *intelhaddata)
+ {
+ 	u32 len = 1;
+ 	enum intel_had_aud_buf_type buf_id;
+ 	enum intel_had_aud_buf_type buff_done;
+ 	struct pcm_stream_info *stream;
+ 	u32 buf_size;
+ 	struct had_stream_data *had_stream;
+ 	int intr_count;
+ 	enum had_status_stream		stream_type;
+ 	unsigned long flag_irqs;
+ 
+ 	had_stream = &intelhaddata->stream_data;
+ 	stream = &intelhaddata->stream_info;
+ 	intr_count = 1;
+ 
+ 	spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
+ 	if (intelhaddata->drv_status == HAD_DRV_DISCONNECTED) {
+ 		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 		dev_dbg(intelhaddata->dev,
+ 			"%s:Device already disconnected\n", __func__);
+ 		return 0;
+ 	}
+ 	buf_id = intelhaddata->curr_buf;
+ 	intelhaddata->buff_done = buf_id;
+ 	buff_done = intelhaddata->buff_done;
+ 	buf_size = intelhaddata->buf_info[buf_id].buf_size;
+ 	stream_type = had_stream->stream_type;
+ 
+ 	/* Every debug statement has an implication
+ 	 * of ~5msec. Thus, avoid having >3 debug statements
+ 	 * for each buffer_done handling.
+ 	 */
+ 
+ 	/* Check for any intr_miss in case of active playback */
+ 	if (had_stream->stream_type == HAD_RUNNING_STREAM) {
+ 		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 		intr_count = had_chk_intrmiss(intelhaddata, buf_id);
+ 		if (!intr_count || (intr_count > 3)) {
+ 			dev_err(intelhaddata->dev,
+ 				"HAD SW state in non-recoverable mode\n");
+ 			return 0;
+ 		}
+ 		buf_id += (intr_count - 1);
+ 		buf_id = buf_id % 4;
+ 		spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
+ 	}
+ 
+ 	intelhaddata->buf_info[buf_id].is_valid = true;
+ 	if (intelhaddata->valid_buf_cnt-1 == buf_id) {
+ 		if (had_stream->stream_type >= HAD_RUNNING_STREAM)
+ 			intelhaddata->curr_buf = HAD_BUF_TYPE_A;
+ 	} else
+ 		intelhaddata->curr_buf = buf_id + 1;
+ 
+ 	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 
+ 	if (intelhaddata->drv_status == HAD_DRV_DISCONNECTED) {
+ 		dev_dbg(intelhaddata->dev, "HDMI cable plugged-out\n");
+ 		return 0;
+ 	}
+ 
+ 	/*Reprogram the registers with addr and length*/
+ 	had_write_register(intelhaddata,
+ 			   AUD_BUF_A_LENGTH + (buf_id * HAD_REG_WIDTH),
+ 			   buf_size);
+ 	had_write_register(intelhaddata,
+ 			   AUD_BUF_A_ADDR + (buf_id * HAD_REG_WIDTH),
+ 			   intelhaddata->buf_info[buf_id].buf_addr |
+ 			   BIT(0) | BIT(1));
+ 
+ 	had_read_register(intelhaddata,
+ 			  AUD_BUF_A_LENGTH + (buf_id * HAD_REG_WIDTH),
+ 			  &len);
+ 	dev_dbg(intelhaddata->dev, "%s:Enabled buf[%d]\n", __func__, buf_id);
+ 
+ 	/* In case of actual data,
+ 	 * report buffer_done to above ALSA layer
+ 	 */
+ 	buf_size = intelhaddata->buf_info[buf_id].buf_size;
+ 	if (stream_type >= HAD_RUNNING_STREAM) {
+ 		intelhaddata->stream_info.buffer_rendered +=
+ 			(intr_count * buf_size);
+ 		had_period_elapsed(stream->had_substream);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int had_process_buffer_underrun(struct snd_intelhad *intelhaddata)
+ {
+ 	enum intel_had_aud_buf_type buf_id;
+ 	struct pcm_stream_info *stream;
+ 	struct had_stream_data *had_stream;
+ 	enum had_status_stream stream_type;
+ 	unsigned long flag_irqs;
+ 	int drv_status;
+ 
+ 	had_stream = &intelhaddata->stream_data;
+ 	stream = &intelhaddata->stream_info;
+ 
+ 	spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
+ 	buf_id = intelhaddata->curr_buf;
+ 	stream_type = had_stream->stream_type;
+ 	intelhaddata->buff_done = buf_id;
+ 	drv_status = intelhaddata->drv_status;
+ 	if (stream_type == HAD_RUNNING_STREAM)
+ 		intelhaddata->curr_buf = HAD_BUF_TYPE_A;
+ 
+ 	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 
+ 	dev_dbg(intelhaddata->dev, "Enter:%s buf_id=%d, stream_type=%d\n",
+ 			__func__, buf_id, stream_type);
+ 
+ 	snd_intelhad_handle_underrun(intelhaddata);
+ 
+ 	if (drv_status == HAD_DRV_DISCONNECTED) {
+ 		dev_dbg(intelhaddata->dev,
+ 			"%s:Device already disconnected\n", __func__);
+ 		return 0;
+ 	}
+ 
+ 	if (stream_type == HAD_RUNNING_STREAM) {
+ 		/* Report UNDERRUN error to above layers */
+ 		intelhaddata->flag_underrun = true;
+ 		had_period_elapsed(stream->had_substream);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int had_process_hot_plug(struct snd_intelhad *intelhaddata)
+ {
+ 	enum intel_had_aud_buf_type buf_id;
+ 	struct snd_pcm_substream *substream;
+ 	struct had_stream_data *had_stream;
+ 	unsigned long flag_irqs;
+ 
+ 	substream = intelhaddata->stream_info.had_substream;
+ 	had_stream = &intelhaddata->stream_data;
+ 
+ 	spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
+ 	if (intelhaddata->drv_status == HAD_DRV_CONNECTED) {
+ 		dev_dbg(intelhaddata->dev, "Device already connected\n");
+ 		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 		return 0;
+ 	}
+ 	buf_id = intelhaddata->curr_buf;
+ 	intelhaddata->buff_done = buf_id;
+ 	intelhaddata->drv_status = HAD_DRV_CONNECTED;
+ 	dev_dbg(intelhaddata->dev,
+ 		"%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_CONNECTED\n",
+ 			__func__, __LINE__);
+ 	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 
+ 	dev_dbg(intelhaddata->dev, "Processing HOT_PLUG, buf_id = %d\n",
+ 		buf_id);
+ 
+ 	/* Safety check */
+ 	if (substream) {
+ 		dev_dbg(intelhaddata->dev,
+ 			"Force to stop the active stream by disconnection\n");
+ 		/* Set runtime->state to hw_params done */
+ 		snd_pcm_stop(substream, SNDRV_PCM_STATE_SETUP);
+ 	}
+ 
+ 	had_build_channel_allocation_map(intelhaddata);
+ 
+ 	return 0;
+ }
+ 
+ static int had_process_hot_unplug(struct snd_intelhad *intelhaddata)
+ {
+ 	enum intel_had_aud_buf_type buf_id;
+ 	struct had_stream_data *had_stream;
+ 	unsigned long flag_irqs;
+ 
+ 	had_stream = &intelhaddata->stream_data;
+ 	buf_id = intelhaddata->curr_buf;
+ 
+ 	spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
+ 
+ 	if (intelhaddata->drv_status == HAD_DRV_DISCONNECTED) {
+ 		dev_dbg(intelhaddata->dev, "Device already disconnected\n");
+ 		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 		return 0;
+ 
+ 	} else {
+ 		/* Disable Audio */
+ 		snd_intelhad_enable_audio_int(intelhaddata, false);
+ 		snd_intelhad_enable_audio(intelhaddata, false);
+ 	}
+ 
+ 	intelhaddata->drv_status = HAD_DRV_DISCONNECTED;
+ 	dev_dbg(intelhaddata->dev,
+ 		"%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_DISCONNECTED\n",
+ 			__func__, __LINE__);
+ 
+ 	/* Report to above ALSA layer */
+ 	if (intelhaddata->stream_info.had_substream != NULL) {
+ 		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 		snd_pcm_stop(intelhaddata->stream_info.had_substream,
+ 				SNDRV_PCM_STATE_SETUP);
+ 		spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
+ 	}
+ 
+ 	had_stream->stream_type = HAD_INIT;
+ 	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
+ 	kfree(intelhaddata->chmap->chmap);
+ 	intelhaddata->chmap->chmap = NULL;
+ 
+ 	return 0;
+ }
+ 
+ /* PCM operations structure and the calls back for the same */
+ static struct snd_pcm_ops snd_intelhad_playback_ops = {
++>>>>>>> 79f439ea4007 (ALSA: x86: Drop had_get_hwstate())
  	.open =		snd_intelhad_open,
  	.close =	snd_intelhad_close,
  	.ioctl =	snd_pcm_lib_ioctl,
* Unmerged path sound/x86/intel_hdmi_audio.c
