KVM: lapic: do not scan IRR when delivering an interrupt

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 4d82d12b39132e820b9ac4aa058ccc733db98917
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4d82d12b.failed

On interrupt delivery the PPR can only grow (except for auto-EOI),
so it is impossible that non-auto-EOI interrupt delivery results
in KVM_REQ_EVENT.  We can therefore use __apic_update_ppr.

	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 4d82d12b39132e820b9ac4aa058ccc733db98917)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/lapic.c
diff --cc arch/x86/kvm/lapic.c
index ee470f01f5dc,10a745faa659..000000000000
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@@ -1982,9 -2127,25 +1983,28 @@@ int kvm_get_apic_interrupt(struct kvm_v
  	 * because the process would deliver it through the IDT.
  	 */
  
- 	apic_set_isr(vector, apic);
- 	apic_update_ppr(apic);
  	apic_clear_irr(vector, apic);
++<<<<<<< HEAD
++=======
+ 	if (test_bit(vector, vcpu_to_synic(vcpu)->auto_eoi_bitmap)) {
+ 		/*
+ 		 * For auto-EOI interrupts, there might be another pending
+ 		 * interrupt above PPR, so check whether to raise another
+ 		 * KVM_REQ_EVENT.
+ 		 */
+ 		apic_update_ppr(apic);
+ 	} else {
+ 		/*
+ 		 * For normal interrupts, PPR has been raised and there cannot
+ 		 * be a higher-priority pending interrupt---except if there was
+ 		 * a concurrent interrupt injection, but that would have
+ 		 * triggered KVM_REQ_EVENT already.
+ 		 */
+ 		apic_set_isr(vector, apic);
+ 		__apic_update_ppr(apic, &ppr);
+ 	}
+ 
++>>>>>>> 4d82d12b3913 (KVM: lapic: do not scan IRR when delivering an interrupt)
  	return vector;
  }
  
* Unmerged path arch/x86/kvm/lapic.c
