arp: postpone addr_type calculation to as late as possible

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ihar Hrachyshka <ihrachys@redhat.com>
commit d9ef2e7bf99f59179b89d5c1c4d5b4919375daee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d9ef2e7b.failed

The addr_type retrieval can be costly, so it's worth trying to avoid its
calculation as much as possible. This patch makes it calculated only
for gratuitous ARP packets. This is especially important since later we
may want to move is_garp calculation outside of arp_accept block, at
which point the costly operation will be executed for all setups.

The patch is the result of a discussion in net-dev:
http://marc.info/?l=linux-netdev&m=149506354216994

	Suggested-by: Julian Anastasov <ja@ssi.bg>
	Signed-off-by: Ihar Hrachyshka <ihrachys@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d9ef2e7bf99f59179b89d5c1c4d5b4919375daee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/arp.c
diff --cc net/ipv4/arp.c
index 98def2add661,c22103cec823..000000000000
--- a/net/ipv4/arp.c
+++ b/net/ipv4/arp.c
@@@ -728,6 -641,32 +728,35 @@@ void arp_xmit(struct sk_buff *skb
  }
  EXPORT_SYMBOL(arp_xmit);
  
++<<<<<<< HEAD
++=======
+ static bool arp_is_garp(struct net *net, struct net_device *dev,
+ 			int *addr_type, __be16 ar_op,
+ 			__be32 sip, __be32 tip,
+ 			unsigned char *sha, unsigned char *tha)
+ {
+ 	bool is_garp = tip == sip;
+ 
+ 	/* Gratuitous ARP _replies_ also require target hwaddr to be
+ 	 * the same as source.
+ 	 */
+ 	if (is_garp && ar_op == htons(ARPOP_REPLY))
+ 		is_garp =
+ 			/* IPv4 over IEEE 1394 doesn't provide target
+ 			 * hardware address field in its ARP payload.
+ 			 */
+ 			tha &&
+ 			!memcmp(tha, sha, dev->addr_len);
+ 
+ 	if (is_garp) {
+ 		*addr_type = inet_addr_type_dev_table(net, dev, sip);
+ 		if (*addr_type != RTN_UNICAST)
+ 			is_garp = false;
+ 	}
+ 	return is_garp;
+ }
+ 
++>>>>>>> d9ef2e7bf99f (arp: postpone addr_type calculation to as late as possible)
  /*
   *	Process an arp request.
   */
@@@ -915,14 -864,23 +944,33 @@@ static int arp_process(struct sock *sk
  	n = __neigh_lookup(&arp_tbl, &sip, dev, 0);
  
  	if (IN_DEV_ARP_ACCEPT(in_dev)) {
++<<<<<<< HEAD
++=======
+ 		addr_type = -1;
+ 
++>>>>>>> d9ef2e7bf99f (arp: postpone addr_type calculation to as late as possible)
  		/* Unsolicited ARP is not accepted by default.
  		   It is possible, that this option should be enabled for some
  		   devices (strip is candidate)
  		 */
++<<<<<<< HEAD
 +		if (n == NULL &&
 +		    (arp->ar_op == htons(ARPOP_REPLY) ||
 +		     (arp->ar_op == htons(ARPOP_REQUEST) && tip == sip)) &&
 +		    inet_addr_type(net, sip) == RTN_UNICAST)
++=======
+ 		is_garp = arp_is_garp(net, dev, &addr_type, arp->ar_op,
+ 				      sip, tip, sha, tha);
+ 
+ 		if (!n &&
+ 		    (is_garp ||
+ 		     (arp->ar_op == htons(ARPOP_REPLY) &&
+ 		      (addr_type == RTN_UNICAST ||
+ 		       (addr_type < 0 &&
+ 			/* postpone calculation to as late as possible */
+ 			inet_addr_type_dev_table(net, dev, sip) ==
+ 				RTN_UNICAST)))))
++>>>>>>> d9ef2e7bf99f (arp: postpone addr_type calculation to as late as possible)
  			n = __neigh_lookup(&arp_tbl, &sip, dev, 1);
  	}
  
* Unmerged path net/ipv4/arp.c
