net: sched: set xt_tgchk_param par.net properly in ipt_init_target

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] sched: set xt_tgchk_param par.net properly in ipt_init_target (Ivan Vecera) [1445420]
Rebuild_FUZZ: 96.06%
commit-author Xin Long <lucien.xin@gmail.com>
commit ec0acb09313074ba1a4976945791d9c6815f39fb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ec0acb09.failed

Now xt_tgchk_param par in ipt_init_target is a local varibale,
par.net is not initialized there. Later when xt_check_target
calls target's checkentry in which it may access par.net, it
would cause kernel panic.

Jaroslav found this panic when running:

  # ip link add TestIface type dummy
  # tc qd add dev TestIface ingress handle ffff:
  # tc filter add dev TestIface parent ffff: u32 match u32 0 0 \
    action xt -j CONNMARK --set-mark 4

This patch is to pass net param into ipt_init_target and set
par.net with it properly in there.

v1->v2:
  As Wang Cong pointed, I missed ipt_net_id != xt_net_id, so fix
  it by also passing net_id to __tcf_ipt_init.
v2->v3:
  Missed the fixes tag, so add it.

Fixes: ecb2421b5ddf ("netfilter: add and use nf_ct_netns_get/put")
	Reported-by: Jaroslav Aster <jaster@redhat.com>
	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ec0acb09313074ba1a4976945791d9c6815f39fb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/act_ipt.c
diff --cc net/sched/act_ipt.c
index 014563af32c0,94ba5cfab860..000000000000
--- a/net/sched/act_ipt.c
+++ b/net/sched/act_ipt.c
@@@ -30,8 -30,14 +30,19 @@@
  
  #define IPT_TAB_MASK     15
  
++<<<<<<< HEAD
 +static int ipt_init_target(struct xt_entry_target *t, char *table,
 +			   unsigned int hook)
++=======
+ static unsigned int ipt_net_id;
+ static struct tc_action_ops act_ipt_ops;
+ 
+ static unsigned int xt_net_id;
+ static struct tc_action_ops act_xt_ops;
+ 
+ static int ipt_init_target(struct net *net, struct xt_entry_target *t,
+ 			   char *table, unsigned int hook)
++>>>>>>> ec0acb093130 (net: sched: set xt_tgchk_param par.net properly in ipt_init_target)
  {
  	struct xt_tgchk_param par;
  	struct xt_target *target;
@@@ -85,9 -92,11 +97,16 @@@ static const struct nla_policy ipt_poli
  	[TCA_IPT_TARG]	= { .len = sizeof(struct xt_entry_target) },
  };
  
++<<<<<<< HEAD
 +static int tcf_ipt_init(struct net *net, struct nlattr *nla, struct nlattr *est,
 +			struct tc_action *a, int ovr, int bind)
++=======
+ static int __tcf_ipt_init(struct net *net, unsigned int id, struct nlattr *nla,
+ 			  struct nlattr *est, struct tc_action **a,
+ 			  const struct tc_action_ops *ops, int ovr, int bind)
++>>>>>>> ec0acb093130 (net: sched: set xt_tgchk_param par.net properly in ipt_init_target)
  {
+ 	struct tc_action_net *tn = net_generic(net, id);
  	struct nlattr *tb[TCA_IPT_MAX + 1];
  	struct tcf_ipt *ipt;
  	struct xt_entry_target *td, *t;
@@@ -172,6 -191,22 +191,25 @@@ err1
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int tcf_ipt_init(struct net *net, struct nlattr *nla,
+ 			struct nlattr *est, struct tc_action **a, int ovr,
+ 			int bind)
+ {
+ 	return __tcf_ipt_init(net, ipt_net_id, nla, est, a, &act_ipt_ops, ovr,
+ 			      bind);
+ }
+ 
+ static int tcf_xt_init(struct net *net, struct nlattr *nla,
+ 		       struct nlattr *est, struct tc_action **a, int ovr,
+ 		       int bind)
+ {
+ 	return __tcf_ipt_init(net, xt_net_id, nla, est, a, &act_xt_ops, ovr,
+ 			      bind);
+ }
+ 
++>>>>>>> ec0acb093130 (net: sched: set xt_tgchk_param par.net properly in ipt_init_target)
  static int tcf_ipt(struct sk_buff *skb, const struct tc_action *a,
  		   struct tcf_result *res)
  {
* Unmerged path net/sched/act_ipt.c
