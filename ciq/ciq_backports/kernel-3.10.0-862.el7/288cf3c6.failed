x86: query dynamic DEBUG_PAGEALLOC setting

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Christian Borntraeger <borntraeger@de.ibm.com>
commit 288cf3c64e4522d28349de5345348574cbe9df83
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/288cf3c6.failed

We can use debug_pagealloc_enabled() to check if we can map the identity
mapping with 2MB pages.  We can also add the state into the dump_stack
output.

The patch does not touch the code for the 1GB pages, which ignored
CONFIG_DEBUG_PAGEALLOC.  Do we need to fence this as well?

	Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>
	Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
	Acked-by: David Rientjes <rientjes@google.com>
	Cc: Laura Abbott <labbott@fedoraproject.org>
	Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
	Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 288cf3c64e4522d28349de5345348574cbe9df83)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/dumpstack.c
#	arch/x86/mm/init.c
diff --cc arch/x86/kernel/dumpstack.c
index deb6421c9e69,32e5699eadfe..000000000000
--- a/arch/x86/kernel/dumpstack.c
+++ b/arch/x86/kernel/dumpstack.c
@@@ -257,8 -265,10 +257,15 @@@ int __kprobes __die(const char *str, st
  #ifdef CONFIG_SMP
  	printk("SMP ");
  #endif
++<<<<<<< HEAD
 +#ifdef CONFIG_DEBUG_PAGEALLOC
 +	printk("DEBUG_PAGEALLOC");
++=======
+ 	if (debug_pagealloc_enabled())
+ 		printk("DEBUG_PAGEALLOC ");
+ #ifdef CONFIG_KASAN
+ 	printk("KASAN");
++>>>>>>> 288cf3c64e45 (x86: query dynamic DEBUG_PAGEALLOC setting)
  #endif
  	printk("\n");
  	if (notify_die(DIE_OOPS, str, regs, err,
diff --cc arch/x86/mm/init.c
index 5223743762dc,39823fd91396..000000000000
--- a/arch/x86/mm/init.c
+++ b/arch/x86/mm/init.c
@@@ -167,17 -150,14 +167,26 @@@ static int page_size_mask
  
  static void __init probe_page_size_mask(void)
  {
++<<<<<<< HEAD
 +	init_gbpages();
 +
 +#if !defined(CONFIG_DEBUG_PAGEALLOC) && !defined(CONFIG_KMEMCHECK)
++=======
+ #if !defined(CONFIG_KMEMCHECK)
++>>>>>>> 288cf3c64e45 (x86: query dynamic DEBUG_PAGEALLOC setting)
  	/*
- 	 * For CONFIG_DEBUG_PAGEALLOC, identity mapping will use small pages.
+ 	 * For CONFIG_KMEMCHECK or pagealloc debugging, identity mapping will
+ 	 * use small pages.
  	 * This will simplify cpa(), which otherwise needs to support splitting
  	 * large pages into small in interrupt context, etc.
  	 */
++<<<<<<< HEAD
 +	if (direct_gbpages)
 +		page_size_mask |= 1 << PG_LEVEL_1G;
 +	if (cpu_has_pse)
++=======
+ 	if (cpu_has_pse && !debug_pagealloc_enabled())
++>>>>>>> 288cf3c64e45 (x86: query dynamic DEBUG_PAGEALLOC setting)
  		page_size_mask |= 1 << PG_LEVEL_2M;
  #endif
  
* Unmerged path arch/x86/kernel/dumpstack.c
* Unmerged path arch/x86/mm/init.c
diff --git a/arch/x86/mm/pageattr.c b/arch/x86/mm/pageattr.c
index 3fe832369c84..4ef9780d0f2e 100644
--- a/arch/x86/mm/pageattr.c
+++ b/arch/x86/mm/pageattr.c
@@ -109,12 +109,6 @@ static inline unsigned long highmap_end_pfn(void)
 
 #endif
 
-#ifdef CONFIG_DEBUG_PAGEALLOC
-# define debug_pagealloc 1
-#else
-# define debug_pagealloc 0
-#endif
-
 static inline int
 within(unsigned long addr, unsigned long start, unsigned long end)
 {
@@ -663,10 +657,10 @@ static int split_large_page(struct cpa_data *cpa, pte_t *kpte,
 {
 	struct page *base;
 
-	if (!debug_pagealloc)
+	if (!debug_pagealloc_enabled())
 		spin_unlock(&cpa_lock);
 	base = alloc_pages(GFP_KERNEL | __GFP_NOTRACK, 0);
-	if (!debug_pagealloc)
+	if (!debug_pagealloc_enabled())
 		spin_lock(&cpa_lock);
 	if (!base)
 		return -ENOMEM;
@@ -1280,10 +1274,10 @@ static int __change_page_attr_set_clr(struct cpa_data *cpa, int checkalias)
 		if (cpa->flags & (CPA_ARRAY | CPA_PAGES_ARRAY))
 			cpa->numpages = 1;
 
-		if (!debug_pagealloc)
+		if (!debug_pagealloc_enabled())
 			spin_lock(&cpa_lock);
 		ret = __change_page_attr(cpa, checkalias);
-		if (!debug_pagealloc)
+		if (!debug_pagealloc_enabled())
 			spin_unlock(&cpa_lock);
 		if (ret)
 			return ret;
