ovl: use struct copy_up_ctx as function argument

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 23f0ab13eaa69b4a351184cbec448be2aad3a3a9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/23f0ab13.failed

This cleans up functions with too many arguments.

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 23f0ab13eaa69b4a351184cbec448be2aad3a3a9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/copy_up.c
diff --cc fs/overlayfs/copy_up.c
index 6e96b99a973d,8f9e26e91386..000000000000
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@@ -264,164 -233,331 +264,383 @@@ int ovl_set_attr(struct dentry *upperde
  	return err;
  }
  
 -struct ovl_fh *ovl_encode_fh(struct dentry *lower, bool is_upper)
 +static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,
 +			      struct dentry *dentry, struct path *lowerpath,
 +			      struct kstat *stat, const char *link)
  {
 -	struct ovl_fh *fh;
 -	int fh_type, fh_len, dwords;
 -	void *buf;
 -	int buflen = MAX_HANDLE_SZ;
 -	uuid_t *uuid = &lower->d_sb->s_uuid;
 -
 -	buf = kmalloc(buflen, GFP_TEMPORARY);
 -	if (!buf)
 -		return ERR_PTR(-ENOMEM);
 -
 -	/*
 -	 * We encode a non-connectable file handle for non-dir, because we
 -	 * only need to find the lower inode number and we don't want to pay
 -	 * the price or reconnecting the dentry.
 -	 */
 -	dwords = buflen >> 2;
 -	fh_type = exportfs_encode_fh(lower, buf, &dwords, 0);
 -	buflen = (dwords << 2);
 -
 -	fh = ERR_PTR(-EIO);
 -	if (WARN_ON(fh_type < 0) ||
 -	    WARN_ON(buflen > MAX_HANDLE_SZ) ||
 -	    WARN_ON(fh_type == FILEID_INVALID))
 -		goto out;
 +	struct inode *wdir = workdir->d_inode;
 +	struct inode *udir = upperdir->d_inode;
 +	struct dentry *newdentry = NULL;
 +	struct dentry *upper = NULL;
 +	umode_t mode = stat->mode;
 +	int err;
 +	const struct cred *old_creds = NULL;
 +	struct cred *new_creds = NULL;
  
 -	BUILD_BUG_ON(MAX_HANDLE_SZ + offsetof(struct ovl_fh, fid) > 255);
 -	fh_len = offsetof(struct ovl_fh, fid) + buflen;
 -	fh = kmalloc(fh_len, GFP_KERNEL);
 -	if (!fh) {
 -		fh = ERR_PTR(-ENOMEM);
++<<<<<<< HEAD
 +	newdentry = ovl_lookup_temp(workdir, dentry);
 +	err = PTR_ERR(newdentry);
 +	if (IS_ERR(newdentry))
  		goto out;
 -	}
 -
 -	fh->version = OVL_FH_VERSION;
 -	fh->magic = OVL_FH_MAGIC;
 -	fh->type = fh_type;
 -	fh->flags = OVL_FH_FLAG_CPU_ENDIAN;
 -	/*
 -	 * When we will want to decode an overlay dentry from this handle
 -	 * and all layers are on the same fs, if we get a disconncted real
 -	 * dentry when we decode fid, the only way to tell if we should assign
 -	 * it to upperdentry or to lowerstack is by checking this flag.
 -	 */
 -	if (is_upper)
 -		fh->flags |= OVL_FH_FLAG_PATH_UPPER;
 -	fh->len = fh_len;
 -	fh->uuid = *uuid;
 -	memcpy(fh->fid, buf, buflen);
 -
 -out:
 -	kfree(buf);
 -	return fh;
 -}
 -
 -static int ovl_set_origin(struct dentry *dentry, struct dentry *lower,
 -			  struct dentry *upper)
 -{
 -	const struct ovl_fh *fh = NULL;
 -	int err;
  
 +	upper = lookup_one_len(dentry->d_name.name, upperdir,
 +			       dentry->d_name.len);
 +	err = PTR_ERR(upper);
 +	if (IS_ERR(upper))
 +		goto out1;
++=======
+ 	/*
+ 	 * When lower layer doesn't support export operations store a 'null' fh,
+ 	 * so we can use the overlay.origin xattr to distignuish between a copy
+ 	 * up and a pure upper inode.
+ 	 */
+ 	if (ovl_can_decode_fh(lower->d_sb)) {
+ 		fh = ovl_encode_fh(lower, false);
+ 		if (IS_ERR(fh))
+ 			return PTR_ERR(fh);
+ 	}
+ 
+ 	/*
+ 	 * Do not fail when upper doesn't support xattrs.
+ 	 */
+ 	err = ovl_check_setxattr(dentry, upper, OVL_XATTR_ORIGIN, fh,
+ 				 fh ? fh->len : 0, 0);
+ 	kfree(fh);
  
- 	err = security_inode_copy_up(dentry, &new_creds);
+ 	return err;
+ }
+ 
+ struct ovl_copy_up_ctx {
+ 	struct dentry *dentry;
+ 	struct path lowerpath;
+ 	struct kstat stat;
+ 	struct kstat pstat;
+ 	const char *link;
+ 	struct dentry *upperdir;
+ 	struct dentry *workdir;
+ 	bool tmpfile;
+ };
+ 
+ static int ovl_install_temp(struct ovl_copy_up_ctx *c, struct dentry *temp,
+ 			    struct dentry **newdentry)
+ {
+ 	int err;
+ 	struct dentry *upper;
+ 	struct inode *udir = d_inode(c->upperdir);
+ 
+ 	upper = lookup_one_len(c->dentry->d_name.name, c->upperdir,
+ 			       c->dentry->d_name.len);
+ 	if (IS_ERR(upper))
+ 		return PTR_ERR(upper);
+ 
+ 	if (c->tmpfile)
+ 		err = ovl_do_link(temp, udir, upper, true);
+ 	else
+ 		err = ovl_do_rename(d_inode(c->workdir), temp, udir, upper, 0);
+ 
+ 	/* Restore timestamps on parent (best effort) */
+ 	if (!err) {
+ 		ovl_set_timestamps(c->upperdir, &c->pstat);
+ 		*newdentry = dget(c->tmpfile ? upper : temp);
+ 	}
+ 	dput(upper);
+ 
+ 	return err;
+ }
+ 
+ static int ovl_get_tmpfile(struct ovl_copy_up_ctx *c, struct dentry **tempp)
+ {
+ 	int err;
+ 	struct dentry *temp;
+ 	const struct cred *old_creds = NULL;
+ 	struct cred *new_creds = NULL;
+ 	struct cattr cattr = {
+ 		/* Can't properly set mode on creation because of the umask */
+ 		.mode = c->stat.mode & S_IFMT,
+ 		.rdev = c->stat.rdev,
+ 		.link = c->link
+ 	};
++>>>>>>> 23f0ab13eaa6 (ovl: use struct copy_up_ctx as function argument)
+ 
+ 	err = security_inode_copy_up(c->dentry, &new_creds);
  	if (err < 0)
 -		goto out;
 +		goto out2;
  
  	if (new_creds)
  		old_creds = override_creds(new_creds);
  
++<<<<<<< HEAD
 +	/* Can't properly set mode on creation because of the umask */
 +	stat->mode &= S_IFMT;
 +	err = ovl_create_real(wdir, newdentry, stat, link, NULL, true);
 +	stat->mode = mode;
 +
++=======
+ 	if (c->tmpfile) {
+ 		temp = ovl_do_tmpfile(c->workdir, c->stat.mode);
+ 		if (IS_ERR(temp))
+ 			goto temp_err;
+ 	} else {
+ 		temp = ovl_lookup_temp(c->workdir);
+ 		if (IS_ERR(temp))
+ 			goto temp_err;
+ 
+ 		err = ovl_create_real(d_inode(c->workdir), temp, &cattr,
+ 				      NULL, true);
+ 		if (err) {
+ 			dput(temp);
+ 			goto out;
+ 		}
+ 	}
+ 	err = 0;
+ 	*tempp = temp;
+ out:
++>>>>>>> 23f0ab13eaa6 (ovl: use struct copy_up_ctx as function argument)
  	if (new_creds) {
  		revert_creds(old_creds);
  		put_cred(new_creds);
  	}
  
++<<<<<<< HEAD
 +	if (err)
 +		goto out2;
++=======
+ 	return err;
+ 
+ temp_err:
+ 	err = PTR_ERR(temp);
+ 	goto out;
+ }
  
- 	if (S_ISREG(stat->mode)) {
+ static int ovl_copy_up_inode(struct ovl_copy_up_ctx *c, struct dentry *temp)
+ {
+ 	int err;
++>>>>>>> 23f0ab13eaa6 (ovl: use struct copy_up_ctx as function argument)
+ 
+ 	if (S_ISREG(c->stat.mode)) {
  		struct path upperpath;
  
- 		ovl_path_upper(dentry, &upperpath);
+ 		ovl_path_upper(c->dentry, &upperpath);
  		BUG_ON(upperpath.dentry != NULL);
 -		upperpath.dentry = temp;
 +		upperpath.dentry = newdentry;
  
- 		err = ovl_copy_up_data(lowerpath, &upperpath, stat->size);
+ 		err = ovl_copy_up_data(&c->lowerpath, &upperpath, c->stat.size);
  		if (err)
 -			return err;
 +			goto out_cleanup;
  	}
  
++<<<<<<< HEAD
 +	err = ovl_copy_xattr(lowerpath->dentry, newdentry);
++=======
+ 	err = ovl_copy_xattr(c->lowerpath.dentry, temp);
++>>>>>>> 23f0ab13eaa6 (ovl: use struct copy_up_ctx as function argument)
  	if (err)
 -		return err;
 +		goto out_cleanup;
  
++<<<<<<< HEAD
 +	mutex_lock(&newdentry->d_inode->i_mutex);
 +	err = ovl_set_attr(newdentry, stat);
 +	mutex_unlock(&newdentry->d_inode->i_mutex);
++=======
+ 	inode_lock(temp->d_inode);
+ 	err = ovl_set_attr(temp, &c->stat);
+ 	inode_unlock(temp->d_inode);
++>>>>>>> 23f0ab13eaa6 (ovl: use struct copy_up_ctx as function argument)
  	if (err)
 -		return err;
 +		goto out_cleanup;
 +
 +	err = ovl_do_rename(wdir, newdentry, udir, upper, 0);
 +	if (err)
 +		goto out_cleanup;
 +
 +	ovl_dentry_update(dentry, newdentry);
 +	ovl_inode_update(d_inode(dentry), d_inode(newdentry));
 +	newdentry = NULL;
  
  	/*
 -	 * Store identifier of lower inode in upper inode xattr to
 -	 * allow lookup of the copy up origin inode.
 -	 *
 -	 * Don't set origin when we are breaking the association with a lower
 -	 * hard link.
 +	 * Non-directores become opaque when copied up.
  	 */
++<<<<<<< HEAD
 +	if (!S_ISDIR(stat->mode))
 +		ovl_dentry_set_opaque(dentry, true);
 +out2:
 +	dput(upper);
 +out1:
 +	dput(newdentry);
++=======
+ 	if (S_ISDIR(c->stat.mode) || c->stat.nlink == 1) {
+ 		err = ovl_set_origin(c->dentry, c->lowerpath.dentry, temp);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int ovl_copy_up_locked(struct ovl_copy_up_ctx *c)
+ {
+ 	struct inode *udir = c->upperdir->d_inode;
+ 	struct dentry *newdentry = NULL;
+ 	struct dentry *temp = NULL;
+ 	int err;
+ 
+ 	err = ovl_get_tmpfile(c, &temp);
+ 	if (err)
+ 		goto out;
+ 
+ 	err = ovl_copy_up_inode(c, temp);
+ 	if (err)
+ 		goto out_cleanup;
+ 
+ 	if (c->tmpfile) {
+ 		inode_lock_nested(udir, I_MUTEX_PARENT);
+ 		err = ovl_install_temp(c, temp, &newdentry);
+ 		inode_unlock(udir);
+ 	} else {
+ 		err = ovl_install_temp(c, temp, &newdentry);
+ 	}
+ 	if (err)
+ 		goto out_cleanup;
+ 
+ 	ovl_inode_update(d_inode(c->dentry), newdentry);
++>>>>>>> 23f0ab13eaa6 (ovl: use struct copy_up_ctx as function argument)
  out:
 -	dput(temp);
  	return err;
  
  out_cleanup:
++<<<<<<< HEAD
 +	ovl_cleanup(wdir, newdentry);
 +	goto out2;
++=======
+ 	if (!c->tmpfile)
+ 		ovl_cleanup(d_inode(c->workdir), temp);
+ 	goto out;
++>>>>>>> 23f0ab13eaa6 (ovl: use struct copy_up_ctx as function argument)
  }
  
  /*
   * Copy up a single dentry
   *
 - * All renames start with copy up of source if necessary.  The actual
 - * rename will only proceed once the copy up was successful.  Copy up uses
 - * upper parent i_mutex for exclusion.  Since rename can change d_parent it
 - * is possible that the copy up will lock the old parent.  At that point
 - * the file will have already been copied up anyway.
 + * Directory renames only allowed on "pure upper" (already created on
 + * upper filesystem, never copied up).  Directories which are on lower or
 + * are merged may not be renamed.  For these -EXDEV is returned and
 + * userspace has to deal with it.  This means, when copying up a
 + * directory we can rely on it and ancestors being stable.
 + *
 + * Non-directory renames start with copy up of source if necessary.  The
 + * actual rename will only proceed once the copy up was successful.  Copy
 + * up uses upper parent i_mutex for exclusion.  Since rename can change
 + * d_parent it is possible that the copy up will lock the old parent.  At
 + * that point the file will have already been copied up anyway.
   */
- static int ovl_copy_up_one(struct dentry *parent, struct dentry *dentry,
- 			   struct path *lowerpath, struct kstat *stat)
+ static int ovl_copy_up_one(struct dentry *parent, struct ovl_copy_up_ctx *c)
  {
++<<<<<<< HEAD
 +	struct dentry *workdir = ovl_workdir(dentry);
++=======
+ 	DEFINE_DELAYED_CALL(done);
++>>>>>>> 23f0ab13eaa6 (ovl: use struct copy_up_ctx as function argument)
  	int err;
- 	struct kstat pstat;
  	struct path parentpath;
++<<<<<<< HEAD
 +	struct dentry *upperdir;
 +	struct dentry *upperdentry;
 +	char *link = NULL;
++=======
+ 	struct dentry *lowerdentry = c->lowerpath.dentry;
+ 	struct ovl_fs *ofs = c->dentry->d_sb->s_fs_info;
++>>>>>>> 23f0ab13eaa6 (ovl: use struct copy_up_ctx as function argument)
  
- 	if (WARN_ON(!workdir))
+ 	c->workdir = ovl_workdir(c->dentry);
+ 	if (WARN_ON(!c->workdir))
  		return -EROFS;
  
 -	ovl_do_check_copy_up(lowerdentry);
 +	ovl_do_check_copy_up(lowerpath->dentry);
  
  	ovl_path_upper(parent, &parentpath);
- 	upperdir = parentpath.dentry;
+ 	c->upperdir = parentpath.dentry;
  
++<<<<<<< HEAD
 +	err = vfs_getattr(&parentpath, &pstat);
 +	if (err)
 +		return err;
 +
 +	if (S_ISLNK(stat->mode)) {
 +		link = ovl_read_symlink(lowerpath->dentry);
 +		if (IS_ERR(link))
 +			return PTR_ERR(link);
 +	}
 +
++=======
+ 	/* Mark parent "impure" because it may now contain non-pure upper */
+ 	err = ovl_set_impure(parent, c->upperdir);
+ 	if (err)
+ 		return err;
+ 
+ 	err = vfs_getattr(&parentpath, &c->pstat,
+ 			  STATX_ATIME | STATX_MTIME, AT_STATX_SYNC_AS_STAT);
+ 	if (err)
+ 		return err;
+ 
+ 	if (S_ISLNK(c->stat.mode)) {
+ 		c->link = vfs_get_link(lowerdentry, &done);
+ 		if (IS_ERR(c->link))
+ 			return PTR_ERR(c->link);
+ 	}
+ 
+ 	/* Should we copyup with O_TMPFILE or with workdir? */
+ 	if (S_ISREG(c->stat.mode) && ofs->tmpfile) {
+ 		err = ovl_copy_up_start(c->dentry);
+ 		/* err < 0: interrupted, err > 0: raced with another copy-up */
+ 		if (unlikely(err)) {
+ 			pr_debug("ovl_copy_up_start(%pd2) = %i\n", c->dentry,
+ 				 err);
+ 			if (err > 0)
+ 				err = 0;
+ 			goto out_done;
+ 		}
+ 		c->tmpfile = true;
+ 		err = ovl_copy_up_locked(c);
+ 		ovl_copy_up_end(c->dentry);
+ 		goto out_done;
+ 	}
+ 
++>>>>>>> 23f0ab13eaa6 (ovl: use struct copy_up_ctx as function argument)
  	err = -EIO;
- 	if (lock_rename(workdir, upperdir) != NULL) {
+ 	if (lock_rename(c->workdir, c->upperdir) != NULL) {
  		pr_err("overlayfs: failed to lock workdir+upperdir\n");
  		goto out_unlock;
  	}
++<<<<<<< HEAD
 +	upperdentry = ovl_dentry_upper(dentry);
 +	if (upperdentry) {
++=======
+ 	if (ovl_dentry_upper(c->dentry)) {
++>>>>>>> 23f0ab13eaa6 (ovl: use struct copy_up_ctx as function argument)
  		/* Raced with another copy-up?  Nothing to do, then... */
  		err = 0;
  		goto out_unlock;
  	}
  
++<<<<<<< HEAD
 +	err = ovl_copy_up_locked(workdir, upperdir, dentry, lowerpath,
 +				 stat, link);
 +	if (!err) {
 +		/* Restore timestamps on parent (best effort) */
 +		ovl_set_timestamps(upperdir, &pstat);
 +	}
 +out_unlock:
 +	unlock_rename(workdir, upperdir);
 +
 +	if (link)
 +		free_page((unsigned long) link);
++=======
+ 	err = ovl_copy_up_locked(c);
+ out_unlock:
+ 	unlock_rename(c->workdir, c->upperdir);
+ out_done:
+ 	do_delayed_call(&done);
++>>>>>>> 23f0ab13eaa6 (ovl: use struct copy_up_ctx as function argument)
  
  	return err;
  }
@@@ -454,13 -589,16 +672,21 @@@ int ovl_copy_up_flags(struct dentry *de
  			next = parent;
  		}
  
++<<<<<<< HEAD
 +		ovl_path_lower(next, &lowerpath);
 +		err = vfs_getattr(&lowerpath, &stat);
++=======
+ 		ovl_path_lower(next, &ctx.lowerpath);
+ 		err = vfs_getattr(&ctx.lowerpath, &ctx.stat,
+ 				  STATX_BASIC_STATS, AT_STATX_SYNC_AS_STAT);
++>>>>>>> 23f0ab13eaa6 (ovl: use struct copy_up_ctx as function argument)
  		/* maybe truncate regular file. this has no effect on dirs */
  		if (flags & O_TRUNC)
- 			stat.size = 0;
- 		if (!err)
- 			err = ovl_copy_up_one(parent, next, &lowerpath, &stat);
+ 			ctx.stat.size = 0;
+ 		if (!err) {
+ 			ctx.dentry = next;
+ 			err = ovl_copy_up_one(parent, &ctx);
+ 		}
  
  		dput(parent);
  		dput(next);
* Unmerged path fs/overlayfs/copy_up.c
