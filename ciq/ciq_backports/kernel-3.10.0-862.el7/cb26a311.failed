sysfs: drop kobj_ns_type handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Tejun Heo <tj@kernel.org>
commit cb26a311578e67769e92a39a0a63476533cb7e12
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/cb26a311.failed

The way namespace tags are implemented in sysfs is more complicated
than necessary.  As each tag is a pointer value and required to be
non-NULL under a namespace enabled parent, there's no need to record
separately what type each tag is or where namespace is enabled.

If multiple namespace types are needed, which currently aren't, we can
simply compare the tag to a set of allowed tags in the superblock
assuming that the tags, being pointers, won't have the same value
across multiple types.  Also, whether to filter by namespace tag or
not can be trivially determined by whether the node has any tagged
children or not.

This patch rips out kobj_ns_type handling from sysfs.  sysfs no longer
cares whether specific type of namespace is enabled or not.  If a
sysfs_dirent has a non-NULL tag, the parent is marked as needing
namespace filtering and the value is tested against the allowed set of
tags for the superblock (currently only one but increasing this number
isn't difficult) and the sysfs_dirent is ignored if it doesn't match.

This removes most kobject namespace knowledge from sysfs proper which
will enable proper separation and layering of sysfs.  The namespace
sanity checks in fs/sysfs/dir.c are replaced by the new sanity check
in kobject_namespace().  As this is the only place ktype->namespace()
is called for sysfs, this doesn't weaken the sanity check
significantly.  I omitted converting the sanity check in
sysfs_do_create_link_sd().  While the check can be shifted to upper
layer, mistakes there are well contained and should be easily visible
anyway.

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Cc: Eric W. Biederman <ebiederm@xmission.com>
	Cc: Kay Sievers <kay@vrfy.org>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit cb26a311578e67769e92a39a0a63476533cb7e12)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/sysfs/dir.c
#	fs/sysfs/mount.c
#	fs/sysfs/symlink.c
#	lib/kobject.c
diff --cc fs/sysfs/dir.c
index fd502d3fc9fc,1dfb4aaf9446..000000000000
--- a/fs/sysfs/dir.c
+++ b/fs/sysfs/dir.c
@@@ -318,15 -329,11 +329,10 @@@ static int sysfs_dentry_revalidate(stru
  		goto out_bad;
  
  	/* The sysfs dirent has been moved to a different namespace */
- 	type = KOBJ_NS_TYPE_NONE;
- 	if (sd->s_parent) {
- 		type = sysfs_ns_type(sd->s_parent);
- 		if (type != KOBJ_NS_TYPE_NONE &&
- 				sysfs_info(dentry->d_sb)->ns[type] != sd->s_ns)
- 			goto out_bad;
- 	}
+ 	if (sd->s_ns && sd->s_ns != sysfs_info(dentry->d_sb)->ns)
+ 		goto out_bad;
  
  	mutex_unlock(&sysfs_mutex);
 -out_valid:
  	return 1;
  out_bad:
  	/* Remove the dentry from the dcache hashes.
@@@ -437,13 -451,6 +443,16 @@@ int __sysfs_add_one(struct sysfs_addrm_
  	struct sysfs_inode_attrs *ps_iattr;
  	int ret;
  
++<<<<<<< HEAD
 +	if (!!sysfs_ns_type(acxt->parent_sd) != !!sd->s_ns) {
 +		WARN(1, KERN_WARNING "sysfs: ns %s in '%s' for '%s'\n",
 +			sysfs_ns_type(acxt->parent_sd)? "required": "invalid",
 +			acxt->parent_sd->s_name, sd->s_name);
 +		return -EINVAL;
 +	}
 +
++=======
++>>>>>>> cb26a311578e (sysfs: drop kobj_ns_type handling)
  	sd->s_hash = sysfs_name_hash(sd->s_ns, sd->s_name);
  	sd->s_parent = sysfs_get(acxt->parent_sd);
  
@@@ -610,13 -612,6 +619,16 @@@ struct sysfs_dirent *sysfs_find_dirent(
  	struct rb_node *node = parent_sd->s_dir.children.rb_node;
  	unsigned int hash;
  
++<<<<<<< HEAD
 +	if (!!sysfs_ns_type(parent_sd) != !!ns) {
 +		WARN(1, KERN_WARNING "sysfs: ns %s in '%s' for '%s'\n",
 +			sysfs_ns_type(parent_sd)? "required": "invalid",
 +			parent_sd->s_name, name);
 +		return NULL;
 +	}
 +
++=======
++>>>>>>> cb26a311578e (sysfs: drop kobj_ns_type handling)
  	hash = sysfs_name_hash(ns, name);
  	while (node) {
  		struct sysfs_dirent *sd;
@@@ -664,10 -659,9 +676,9 @@@ struct sysfs_dirent *sysfs_get_dirent(s
  EXPORT_SYMBOL_GPL(sysfs_get_dirent);
  
  static int create_dir(struct kobject *kobj, struct sysfs_dirent *parent_sd,
- 	enum kobj_ns_type type, const void *ns, const char *name,
- 	struct sysfs_dirent **p_sd)
+ 	const void *ns, const char *name, struct sysfs_dirent **p_sd)
  {
 -	umode_t mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;
 +	umode_t mode = S_IFDIR| S_IRWXU | S_IRUGO | S_IXUGO;
  	struct sysfs_addrm_cxt acxt;
  	struct sysfs_dirent *sd;
  	int rc;
@@@ -727,14 -694,13 +711,13 @@@ int sysfs_create_subdir(struct kobject 
  }
  
  /**
 - * sysfs_create_dir_ns - create a directory for an object with a namespace tag
 - * @kobj: object we're creating directory for
 - * @ns: the namespace tag to use
 + *	sysfs_create_dir - create a directory for an object.
 + *	@kobj:		object we're creating directory for.
   */
 -int sysfs_create_dir_ns(struct kobject *kobj, const void *ns)
 +int sysfs_create_dir(struct kobject * kobj)
  {
- 	enum kobj_ns_type type;
  	struct sysfs_dirent *parent_sd, *sd;
 +	const void *ns = NULL;
  	int error = 0;
  
  	BUG_ON(!kobj);
@@@ -747,11 -713,7 +730,15 @@@
  	if (!parent_sd)
  		return -ENOENT;
  
++<<<<<<< HEAD
 +	if (sysfs_ns_type(parent_sd))
 +		ns = kobj->ktype->namespace(kobj);
 +	type = sysfs_read_ns_type(kobj);
 +
 +	error = create_dir(kobj, parent_sd, type, ns, kobject_name(kobj), &sd);
++=======
+ 	error = create_dir(kobj, parent_sd, ns, kobject_name(kobj), &sd);
++>>>>>>> cb26a311578e (sysfs: drop kobj_ns_type handling)
  	if (!error)
  		kobj->sd = sd;
  	return error;
@@@ -992,68 -950,38 +978,83 @@@ static struct sysfs_dirent *sysfs_dir_n
  	return pos;
  }
  
 -static int sysfs_readdir(struct file *file, struct dir_context *ctx)
 +static int sysfs_readdir(struct file * filp, void * dirent, filldir_t filldir)
  {
++<<<<<<< HEAD
 +	struct dentry *dentry = filp->f_path.dentry;
 +	struct sysfs_dirent * parent_sd = dentry->d_fsdata;
 +	struct sysfs_dirent *pos = filp->private_data;
 +	enum kobj_ns_type type;
 +	const void *ns;
 +	ino_t ino;
 +	loff_t off;
 +
 +	type = sysfs_ns_type(parent_sd);
 +	ns = sysfs_info(dentry->d_sb)->ns[type];
++=======
+ 	struct dentry *dentry = file->f_path.dentry;
+ 	struct sysfs_dirent *parent_sd = dentry->d_fsdata;
+ 	struct sysfs_dirent *pos = file->private_data;
+ 	const void *ns = NULL;
++>>>>>>> cb26a311578e (sysfs: drop kobj_ns_type handling)
  
 -	if (!dir_emit_dots(file, ctx))
 -		return 0;
 +	if (filp->f_pos == 0) {
 +		ino = parent_sd->s_ino;
 +		if (filldir(dirent, ".", 1, filp->f_pos, ino, DT_DIR) == 0)
 +			filp->f_pos++;
 +		else
 +			return 0;
 +	}
 +	if (filp->f_pos == 1) {
 +		if (parent_sd->s_parent)
 +			ino = parent_sd->s_parent->s_ino;
 +		else
 +			ino = parent_sd->s_ino;
 +		if (filldir(dirent, "..", 2, filp->f_pos, ino, DT_DIR) == 0)
 +			filp->f_pos++;
 +		else
 +			return 0;
 +	}
  	mutex_lock(&sysfs_mutex);
++<<<<<<< HEAD
 +	off = filp->f_pos;
 +	for (pos = sysfs_dir_pos(ns, parent_sd, filp->f_pos, pos);
++=======
+ 
+ 	if (parent_sd->s_flags & SYSFS_FLAG_HAS_NS)
+ 		ns = sysfs_info(dentry->d_sb)->ns;
+ 
+ 	for (pos = sysfs_dir_pos(ns, parent_sd, ctx->pos, pos);
++>>>>>>> cb26a311578e (sysfs: drop kobj_ns_type handling)
  	     pos;
 -	     pos = sysfs_dir_next_pos(ns, parent_sd, ctx->pos, pos)) {
 -		const char *name = pos->s_name;
 -		unsigned int type = dt_type(pos);
 -		int len = strlen(name);
 -		ino_t ino = pos->s_ino;
 -		ctx->pos = pos->s_hash;
 -		file->private_data = sysfs_get(pos);
 +	     pos = sysfs_dir_next_pos(ns, parent_sd, filp->f_pos, pos)) {
 +		const char * name;
 +		unsigned int type;
 +		int len, ret;
 +
 +		name = pos->s_name;
 +		len = strlen(name);
 +		ino = pos->s_ino;
 +		type = dt_type(pos);
 +		off = filp->f_pos = pos->s_hash;
 +		filp->private_data = sysfs_get(pos);
  
  		mutex_unlock(&sysfs_mutex);
 -		if (!dir_emit(ctx, name, len, ino, type))
 -			return 0;
 +		ret = filldir(dirent, name, len, off, ino, type);
  		mutex_lock(&sysfs_mutex);
 +		if (ret < 0)
 +			break;
  	}
  	mutex_unlock(&sysfs_mutex);
 -	file->private_data = NULL;
 -	ctx->pos = INT_MAX;
 +
 +	/* don't reference last entry if its refcount is dropped */
 +	if (!pos) {
 +		filp->private_data = NULL;
 +
 +		/* EOF and not changed as 0 or 1 in read/write path */
 +		if (off == filp->f_pos && off > 1)
 +			filp->f_pos = INT_MAX;
 +	}
  	return 0;
  }
  
diff --cc fs/sysfs/mount.c
index afd83273e6ce,8c24bce2f4ae..000000000000
--- a/fs/sysfs/mount.c
+++ b/fs/sysfs/mount.c
@@@ -111,9 -103,13 +103,18 @@@ static struct dentry *sysfs_mount(struc
  	struct super_block *sb;
  	int error;
  
++<<<<<<< HEAD
 +	if (!(flags & MS_KERNMOUNT) && !current_user_ns()->may_mount_sysfs)
 +		return ERR_PTR(-EPERM);
++=======
+ 	if (!(flags & MS_KERNMOUNT)) {
+ 		if (!capable(CAP_SYS_ADMIN) && !fs_fully_visible(fs_type))
+ 			return ERR_PTR(-EPERM);
+ 
+ 		if (!kobj_ns_current_may_mount(KOBJ_NS_TYPE_NET))
+ 			return ERR_PTR(-EPERM);
+ 	}
++>>>>>>> cb26a311578e (sysfs: drop kobj_ns_type handling)
  
  	info = kzalloc(sizeof(*info), GFP_KERNEL);
  	if (!info)
diff --cc fs/sysfs/symlink.c
index 9fab2e7f7357,7d981ce2e87f..000000000000
--- a/fs/sysfs/symlink.c
+++ b/fs/sysfs/symlink.c
@@@ -50,9 -49,7 +49,13 @@@ static int sysfs_do_create_link_sd(stru
  	if (!sd)
  		goto out_put;
  
++<<<<<<< HEAD
 +	ns_type = sysfs_ns_type(parent_sd);
 +	if (ns_type)
 +		sd->s_ns = target->ktype->namespace(target);
++=======
+ 	sd->s_ns = target_sd->s_ns;
++>>>>>>> cb26a311578e (sysfs: drop kobj_ns_type handling)
  	sd->s_symlink.target_sd = target_sd;
  	target_sd = NULL;	/* reference is now owned by the symlink */
  
diff --cc lib/kobject.c
index b201420a4a54,e769ee3c2fb9..000000000000
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@@ -18,6 -18,27 +18,30 @@@
  #include <linux/stat.h>
  #include <linux/slab.h>
  
++<<<<<<< HEAD
++=======
+ /**
+  * kobject_namespace - return @kobj's namespace tag
+  * @kobj: kobject in question
+  *
+  * Returns namespace tag of @kobj if its parent has namespace ops enabled
+  * and thus @kobj should have a namespace tag associated with it.  Returns
+  * %NULL otherwise.
+  */
+ const void *kobject_namespace(struct kobject *kobj)
+ {
+ 	const struct kobj_ns_type_operations *ns_ops = kobj_ns_ops(kobj);
+ 	const void *ns;
+ 
+ 	if (!ns_ops || ns_ops->type == KOBJ_NS_TYPE_NONE)
+ 		return NULL;
+ 
+ 	ns = kobj->ktype->namespace(kobj);
+ 	WARN_ON(!ns);	/* @kobj in a namespace is required to have !NULL tag */
+ 	return ns;
+ }
+ 
++>>>>>>> cb26a311578e (sysfs: drop kobj_ns_type handling)
  /*
   * populate_dir - populate directory with attributes.
   * @kobj: object we're working on.
* Unmerged path fs/sysfs/dir.c
* Unmerged path fs/sysfs/mount.c
* Unmerged path fs/sysfs/symlink.c
diff --git a/fs/sysfs/sysfs.h b/fs/sysfs/sysfs.h
index b6deca3e301d..b87bcd21cb8b 100644
--- a/fs/sysfs/sysfs.h
+++ b/fs/sysfs/sysfs.h
@@ -93,11 +93,8 @@ struct sysfs_dirent {
 #define SYSFS_COPY_NAME			(SYSFS_DIR | SYSFS_KOBJ_LINK)
 #define SYSFS_ACTIVE_REF		(SYSFS_KOBJ_ATTR | SYSFS_KOBJ_BIN_ATTR)
 
-/* identify any namespace tag on sysfs_dirents */
-#define SYSFS_NS_TYPE_MASK		0xf00
-#define SYSFS_NS_TYPE_SHIFT		8
-
-#define SYSFS_FLAG_MASK			~(SYSFS_NS_TYPE_MASK|SYSFS_TYPE_MASK)
+#define SYSFS_FLAG_MASK			~SYSFS_TYPE_MASK
+#define SYSFS_FLAG_HAS_NS		0x01000
 #define SYSFS_FLAG_REMOVED		0x02000
 
 static inline unsigned int sysfs_type(struct sysfs_dirent *sd)
@@ -105,15 +102,6 @@ static inline unsigned int sysfs_type(struct sysfs_dirent *sd)
 	return sd->s_flags & SYSFS_TYPE_MASK;
 }
 
-/*
- * Return any namespace tags on this dirent.
- * enum kobj_ns_type is defined in linux/kobject.h
- */
-static inline enum kobj_ns_type sysfs_ns_type(struct sysfs_dirent *sd)
-{
-	return (sd->s_flags & SYSFS_NS_TYPE_MASK) >> SYSFS_NS_TYPE_SHIFT;
-}
-
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 #define sysfs_dirent_init_lockdep(sd)				\
 do {								\
@@ -141,12 +129,13 @@ struct sysfs_addrm_cxt {
  */
 
 /*
- * Each sb is associated with a set of namespace tags (i.e.
- * the network namespace of the task which mounted this sysfs
- * instance).
+ * Each sb is associated with one namespace tag, currently the network
+ * namespace of the task which mounted this sysfs instance.  If multiple
+ * tags become necessary, make the following an array and compare
+ * sysfs_dirent tag against every entry.
  */
 struct sysfs_super_info {
-	void *ns[KOBJ_NS_TYPES];
+	void *ns;
 };
 #define sysfs_info(SB) ((struct sysfs_super_info *)(SB->s_fs_info))
 extern struct sysfs_dirent sysfs_root;
* Unmerged path lib/kobject.c
