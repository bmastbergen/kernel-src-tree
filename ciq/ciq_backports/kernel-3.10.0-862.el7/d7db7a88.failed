crypto: acomp - update testmgr with support for acomp

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [crypto] acomp - update testmgr with support for acomp (Neil Horman) [1475478]
Rebuild_FUZZ: 91.84%
commit-author Giovanni Cabiddu <giovanni.cabiddu@intel.com>
commit d7db7a882debaffc78f91aabedee973aa1f73390
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d7db7a88.failed

Add tests to the test manager for algorithms exposed through acomp.

	Signed-off-by: Giovanni Cabiddu <giovanni.cabiddu@intel.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit d7db7a882debaffc78f91aabedee973aa1f73390)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	crypto/testmgr.c
diff --cc crypto/testmgr.c
index 756940dfe87a,ded50b67c757..000000000000
--- a/crypto/testmgr.c
+++ b/crypto/testmgr.c
@@@ -1164,206 -1420,144 +1165,324 @@@ static int test_comp(struct crypto_com
  			goto out;
  		}
  
 -		if (dlen != dtemplate[i].outlen) {
 -			printk(KERN_ERR "alg: comp: Decompression test %d "
 -			       "failed for %s: output len = %d\n", i + 1, algo,
 -			       dlen);
 -			ret = -EINVAL;
 -			goto out;
 +		if (dlen != dtemplate[i].outlen) {
 +			printk(KERN_ERR "alg: comp: Decompression test %d "
 +			       "failed for %s: output len = %d\n", i + 1, algo,
 +			       dlen);
 +			ret = -EINVAL;
 +			goto out;
 +		}
 +
 +		if (memcmp(result, dtemplate[i].output, dlen)) {
 +			printk(KERN_ERR "alg: comp: Decompression test %d "
 +			       "failed for %s\n", i + 1, algo);
 +			hexdump(result, dlen);
 +			ret = -EINVAL;
 +			goto out;
 +		}
 +	}
 +
 +	ret = 0;
 +
 +out:
 +	return ret;
 +}
 +
++<<<<<<< HEAD
 +static int test_pcomp(struct crypto_pcomp *tfm,
 +		      struct pcomp_testvec *ctemplate,
 +		      struct pcomp_testvec *dtemplate, int ctcount,
 +		      int dtcount)
 +{
 +	const char *algo = crypto_tfm_alg_driver_name(crypto_pcomp_tfm(tfm));
 +	unsigned int i;
 +	char result[COMP_BUF_SIZE];
 +	int res;
 +
 +	for (i = 0; i < ctcount; i++) {
 +		struct comp_request req;
 +		unsigned int produced = 0;
 +
 +		res = crypto_compress_setup(tfm, ctemplate[i].params,
 +					    ctemplate[i].paramsize);
 +		if (res) {
 +			pr_err("alg: pcomp: compression setup failed on test "
 +			       "%d for %s: error=%d\n", i + 1, algo, res);
 +			return res;
 +		}
 +
 +		res = crypto_compress_init(tfm);
 +		if (res) {
 +			pr_err("alg: pcomp: compression init failed on test "
 +			       "%d for %s: error=%d\n", i + 1, algo, res);
 +			return res;
 +		}
 +
 +		memset(result, 0, sizeof(result));
 +
 +		req.next_in = ctemplate[i].input;
 +		req.avail_in = ctemplate[i].inlen / 2;
 +		req.next_out = result;
 +		req.avail_out = ctemplate[i].outlen / 2;
 +
 +		res = crypto_compress_update(tfm, &req);
 +		if (res < 0 && (res != -EAGAIN || req.avail_in)) {
 +			pr_err("alg: pcomp: compression update failed on test "
 +			       "%d for %s: error=%d\n", i + 1, algo, res);
 +			return res;
 +		}
 +		if (res > 0)
 +			produced += res;
 +
 +		/* Add remaining input data */
 +		req.avail_in += (ctemplate[i].inlen + 1) / 2;
 +
 +		res = crypto_compress_update(tfm, &req);
 +		if (res < 0 && (res != -EAGAIN || req.avail_in)) {
 +			pr_err("alg: pcomp: compression update failed on test "
 +			       "%d for %s: error=%d\n", i + 1, algo, res);
 +			return res;
 +		}
 +		if (res > 0)
 +			produced += res;
 +
 +		/* Provide remaining output space */
 +		req.avail_out += COMP_BUF_SIZE - ctemplate[i].outlen / 2;
 +
 +		res = crypto_compress_final(tfm, &req);
 +		if (res < 0) {
 +			pr_err("alg: pcomp: compression final failed on test "
 +			       "%d for %s: error=%d\n", i + 1, algo, res);
 +			return res;
 +		}
 +		produced += res;
 +
 +		if (COMP_BUF_SIZE - req.avail_out != ctemplate[i].outlen) {
 +			pr_err("alg: comp: Compression test %d failed for %s: "
 +			       "output len = %d (expected %d)\n", i + 1, algo,
 +			       COMP_BUF_SIZE - req.avail_out,
 +			       ctemplate[i].outlen);
 +			return -EINVAL;
 +		}
 +
 +		if (produced != ctemplate[i].outlen) {
 +			pr_err("alg: comp: Compression test %d failed for %s: "
 +			       "returned len = %u (expected %d)\n", i + 1,
 +			       algo, produced, ctemplate[i].outlen);
 +			return -EINVAL;
 +		}
 +
 +		if (memcmp(result, ctemplate[i].output, ctemplate[i].outlen)) {
 +			pr_err("alg: pcomp: Compression test %d failed for "
 +			       "%s\n", i + 1, algo);
 +			hexdump(result, ctemplate[i].outlen);
 +			return -EINVAL;
 +		}
 +	}
 +
 +	for (i = 0; i < dtcount; i++) {
 +		struct comp_request req;
 +		unsigned int produced = 0;
 +
 +		res = crypto_decompress_setup(tfm, dtemplate[i].params,
 +					      dtemplate[i].paramsize);
 +		if (res) {
 +			pr_err("alg: pcomp: decompression setup failed on "
 +			       "test %d for %s: error=%d\n", i + 1, algo, res);
 +			return res;
 +		}
 +
 +		res = crypto_decompress_init(tfm);
 +		if (res) {
 +			pr_err("alg: pcomp: decompression init failed on test "
 +			       "%d for %s: error=%d\n", i + 1, algo, res);
 +			return res;
 +		}
 +
 +		memset(result, 0, sizeof(result));
 +
 +		req.next_in = dtemplate[i].input;
 +		req.avail_in = dtemplate[i].inlen / 2;
 +		req.next_out = result;
 +		req.avail_out = dtemplate[i].outlen / 2;
 +
 +		res = crypto_decompress_update(tfm, &req);
 +		if (res < 0 && (res != -EAGAIN || req.avail_in)) {
 +			pr_err("alg: pcomp: decompression update failed on "
 +			       "test %d for %s: error=%d\n", i + 1, algo, res);
 +			return res;
 +		}
 +		if (res > 0)
 +			produced += res;
 +
 +		/* Add remaining input data */
 +		req.avail_in += (dtemplate[i].inlen + 1) / 2;
 +
 +		res = crypto_decompress_update(tfm, &req);
 +		if (res < 0 && (res != -EAGAIN || req.avail_in)) {
 +			pr_err("alg: pcomp: decompression update failed on "
 +			       "test %d for %s: error=%d\n", i + 1, algo, res);
 +			return res;
 +		}
 +		if (res > 0)
 +			produced += res;
 +
 +		/* Provide remaining output space */
 +		req.avail_out += COMP_BUF_SIZE - dtemplate[i].outlen / 2;
 +
 +		res = crypto_decompress_final(tfm, &req);
 +		if (res < 0 && (res != -EAGAIN || req.avail_in)) {
 +			pr_err("alg: pcomp: decompression final failed on "
 +			       "test %d for %s: error=%d\n", i + 1, algo, res);
 +			return res;
  		}
 +		if (res > 0)
 +			produced += res;
  
 -		if (memcmp(result, dtemplate[i].output, dlen)) {
 -			printk(KERN_ERR "alg: comp: Decompression test %d "
 -			       "failed for %s\n", i + 1, algo);
 -			hexdump(result, dlen);
 -			ret = -EINVAL;
 -			goto out;
 +		if (COMP_BUF_SIZE - req.avail_out != dtemplate[i].outlen) {
 +			pr_err("alg: comp: Decompression test %d failed for "
 +			       "%s: output len = %d (expected %d)\n", i + 1,
 +			       algo, COMP_BUF_SIZE - req.avail_out,
 +			       dtemplate[i].outlen);
 +			return -EINVAL;
  		}
 -	}
  
 -	ret = 0;
 +		if (produced != dtemplate[i].outlen) {
 +			pr_err("alg: comp: Decompression test %d failed for "
 +			       "%s: returned len = %u (expected %d)\n", i + 1,
 +			       algo, produced, dtemplate[i].outlen);
 +			return -EINVAL;
 +		}
  
 -out:
 -	return ret;
 +		if (memcmp(result, dtemplate[i].output, dtemplate[i].outlen)) {
 +			pr_err("alg: pcomp: Decompression test %d failed for "
 +			       "%s\n", i + 1, algo);
 +			hexdump(result, dtemplate[i].outlen);
 +			return -EINVAL;
 +		}
 +	}
 +
 +	return 0;
  }
  
 +
++=======
+ static int test_acomp(struct crypto_acomp *tfm, struct comp_testvec *ctemplate,
+ 		      struct comp_testvec *dtemplate, int ctcount, int dtcount)
+ {
+ 	const char *algo = crypto_tfm_alg_driver_name(crypto_acomp_tfm(tfm));
+ 	unsigned int i;
+ 	char output[COMP_BUF_SIZE];
+ 	int ret;
+ 	struct scatterlist src, dst;
+ 	struct acomp_req *req;
+ 	struct tcrypt_result result;
+ 
+ 	for (i = 0; i < ctcount; i++) {
+ 		unsigned int dlen = COMP_BUF_SIZE;
+ 		int ilen = ctemplate[i].inlen;
+ 
+ 		memset(output, 0, sizeof(output));
+ 		init_completion(&result.completion);
+ 		sg_init_one(&src, ctemplate[i].input, ilen);
+ 		sg_init_one(&dst, output, dlen);
+ 
+ 		req = acomp_request_alloc(tfm);
+ 		if (!req) {
+ 			pr_err("alg: acomp: request alloc failed for %s\n",
+ 			       algo);
+ 			ret = -ENOMEM;
+ 			goto out;
+ 		}
+ 
+ 		acomp_request_set_params(req, &src, &dst, ilen, dlen);
+ 		acomp_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+ 					   tcrypt_complete, &result);
+ 
+ 		ret = wait_async_op(&result, crypto_acomp_compress(req));
+ 		if (ret) {
+ 			pr_err("alg: acomp: compression failed on test %d for %s: ret=%d\n",
+ 			       i + 1, algo, -ret);
+ 			acomp_request_free(req);
+ 			goto out;
+ 		}
+ 
+ 		if (req->dlen != ctemplate[i].outlen) {
+ 			pr_err("alg: acomp: Compression test %d failed for %s: output len = %d\n",
+ 			       i + 1, algo, req->dlen);
+ 			ret = -EINVAL;
+ 			acomp_request_free(req);
+ 			goto out;
+ 		}
+ 
+ 		if (memcmp(output, ctemplate[i].output, req->dlen)) {
+ 			pr_err("alg: acomp: Compression test %d failed for %s\n",
+ 			       i + 1, algo);
+ 			hexdump(output, req->dlen);
+ 			ret = -EINVAL;
+ 			acomp_request_free(req);
+ 			goto out;
+ 		}
+ 
+ 		acomp_request_free(req);
+ 	}
+ 
+ 	for (i = 0; i < dtcount; i++) {
+ 		unsigned int dlen = COMP_BUF_SIZE;
+ 		int ilen = dtemplate[i].inlen;
+ 
+ 		memset(output, 0, sizeof(output));
+ 		init_completion(&result.completion);
+ 		sg_init_one(&src, dtemplate[i].input, ilen);
+ 		sg_init_one(&dst, output, dlen);
+ 
+ 		req = acomp_request_alloc(tfm);
+ 		if (!req) {
+ 			pr_err("alg: acomp: request alloc failed for %s\n",
+ 			       algo);
+ 			ret = -ENOMEM;
+ 			goto out;
+ 		}
+ 
+ 		acomp_request_set_params(req, &src, &dst, ilen, dlen);
+ 		acomp_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+ 					   tcrypt_complete, &result);
+ 
+ 		ret = wait_async_op(&result, crypto_acomp_decompress(req));
+ 		if (ret) {
+ 			pr_err("alg: acomp: decompression failed on test %d for %s: ret=%d\n",
+ 			       i + 1, algo, -ret);
+ 			acomp_request_free(req);
+ 			goto out;
+ 		}
+ 
+ 		if (req->dlen != dtemplate[i].outlen) {
+ 			pr_err("alg: acomp: Decompression test %d failed for %s: output len = %d\n",
+ 			       i + 1, algo, req->dlen);
+ 			ret = -EINVAL;
+ 			acomp_request_free(req);
+ 			goto out;
+ 		}
+ 
+ 		if (memcmp(output, dtemplate[i].output, req->dlen)) {
+ 			pr_err("alg: acomp: Decompression test %d failed for %s\n",
+ 			       i + 1, algo);
+ 			hexdump(output, req->dlen);
+ 			ret = -EINVAL;
+ 			acomp_request_free(req);
+ 			goto out;
+ 		}
+ 
+ 		acomp_request_free(req);
+ 	}
+ 
+ 	ret = 0;
+ 
+ out:
+ 	return ret;
+ }
+ 
++>>>>>>> d7db7a882deb (crypto: acomp - update testmgr with support for acomp)
  static int test_cprng(struct crypto_rng *tfm, struct cprng_testvec *template,
  		      unsigned int tcount)
  {
* Unmerged path crypto/testmgr.c
