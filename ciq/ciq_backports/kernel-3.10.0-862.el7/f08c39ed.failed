net/mlx5e: Schedule overflow check work to mlx5e workqueue

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Schedule overflow check work to mlx5e workqueue (Kamal Heib) [1456694]
Rebuild_FUZZ: 96.43%
commit-author Eugenia Emantayev <eugenia@mellanox.com>
commit f08c39ed0bfb503c7b3e013cd40d036ce6a0941a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f08c39ed.failed

This is done in order to ensure that work will not run after the cleanup.

Fixes: ef9814deafd0 ('net/mlx5e: Add HW timestamping (TS) support')
	Signed-off-by: Eugenia Emantayev <eugenia@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit f08c39ed0bfb503c7b3e013cd40d036ce6a0941a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_clock.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_clock.c
index 59f20ba95c86,84dd63e74041..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_clock.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_clock.c
@@@ -83,14 -120,14 +84,14 @@@ static void mlx5e_timestamp_overflow(st
  	write_lock_irqsave(&tstamp->lock, flags);
  	timecounter_read(&tstamp->clock);
  	write_unlock_irqrestore(&tstamp->lock, flags);
- 	schedule_delayed_work(&tstamp->overflow_work,
- 			      msecs_to_jiffies(tstamp->overflow_period * 1000));
+ 	queue_delayed_work(priv->wq, &tstamp->overflow_work,
+ 			   msecs_to_jiffies(tstamp->overflow_period * 1000));
  }
  
 -int mlx5e_hwstamp_set(struct mlx5e_priv *priv, struct ifreq *ifr)
 +int mlx5e_hwstamp_set(struct net_device *dev, struct ifreq *ifr)
  {
 +	struct mlx5e_priv *priv = netdev_priv(dev);
  	struct hwtstamp_config config;
 -	int err;
  
  	if (!MLX5_CAP_GEN(priv->mdev, device_frequency_khz))
  		return -EOPNOTSUPP;
@@@ -469,9 -575,10 +470,9 @@@ void mlx5e_timestamp_init(struct mlx5e_
  	do_div(ns, NSEC_PER_SEC / 2 / HZ);
  	tstamp->overflow_period = ns;
  
 -	INIT_WORK(&tstamp->pps_info.out_work, mlx5e_pps_out);
  	INIT_DELAYED_WORK(&tstamp->overflow_work, mlx5e_timestamp_overflow);
  	if (tstamp->overflow_period)
- 		schedule_delayed_work(&tstamp->overflow_work, 0);
+ 		queue_delayed_work(priv->wq, &tstamp->overflow_work, 0);
  	else
  		mlx5_core_warn(priv->mdev, "invalid overflow period, overflow_work is not scheduled\n");
  
@@@ -512,8 -613,7 +513,13 @@@ void mlx5e_timestamp_cleanup(struct mlx
  		priv->tstamp.ptp = NULL;
  	}
  
++<<<<<<< HEAD
 +	kfree(tstamp->pps_pin_caps);
 +	kfree(tstamp->ptp_info.pin_config);
 +
++=======
+ 	cancel_work_sync(&tstamp->pps_info.out_work);
++>>>>>>> f08c39ed0bfb (net/mlx5e: Schedule overflow check work to mlx5e workqueue)
  	cancel_delayed_work_sync(&tstamp->overflow_work);
+ 	kfree(tstamp->ptp_info.pin_config);
  }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_clock.c
