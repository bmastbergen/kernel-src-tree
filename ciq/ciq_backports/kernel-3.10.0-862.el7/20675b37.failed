qed: Support NVM-image reading API

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Mintz, Yuval <Yuval.Mintz@cavium.com>
commit 20675b37ee76d11430fd3d4da0851fc6a4e36abc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/20675b37.failed

Storage drivers require images from the nvram in boot-from-SAN
scenarios. This provides the necessary API between qed and the
protocol drivers to perform such reads.

	Signed-off-by: Yuval Mintz <Yuval.Mintz@cavium.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 20675b37ee76d11430fd3d4da0851fc6a4e36abc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qed/qed_mcp.c
diff --cc drivers/net/ethernet/qlogic/qed/qed_mcp.c
index 8f3f22c23d15,9da91045d167..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_mcp.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_mcp.c
@@@ -1713,7 -2310,148 +1713,152 @@@ int qed_mcp_bist_nvm_test_get_image_att
  	return rc;
  }
  
++<<<<<<< HEAD
 +#define QED_RESC_ALLOC_VERSION_MAJOR    1
++=======
+ static int
+ qed_mcp_get_nvm_image_att(struct qed_hwfn *p_hwfn,
+ 			  struct qed_ptt *p_ptt,
+ 			  enum qed_nvm_images image_id,
+ 			  struct qed_nvm_image_att *p_image_att)
+ {
+ 	struct bist_nvm_image_att mfw_image_att;
+ 	enum nvm_image_type type;
+ 	u32 num_images, i;
+ 	int rc;
+ 
+ 	/* Translate image_id into MFW definitions */
+ 	switch (image_id) {
+ 	case QED_NVM_IMAGE_ISCSI_CFG:
+ 		type = NVM_TYPE_ISCSI_CFG;
+ 		break;
+ 	case QED_NVM_IMAGE_FCOE_CFG:
+ 		type = NVM_TYPE_FCOE_CFG;
+ 		break;
+ 	default:
+ 		DP_NOTICE(p_hwfn, "Unknown request of image_id %08x\n",
+ 			  image_id);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* Learn number of images, then traverse and see if one fits */
+ 	rc = qed_mcp_bist_nvm_test_get_num_images(p_hwfn, p_ptt, &num_images);
+ 	if (rc || !num_images)
+ 		return -EINVAL;
+ 
+ 	for (i = 0; i < num_images; i++) {
+ 		rc = qed_mcp_bist_nvm_test_get_image_att(p_hwfn, p_ptt,
+ 							 &mfw_image_att, i);
+ 		if (rc)
+ 			return rc;
+ 
+ 		if (type == mfw_image_att.image_type)
+ 			break;
+ 	}
+ 	if (i == num_images) {
+ 		DP_VERBOSE(p_hwfn, QED_MSG_STORAGE,
+ 			   "Failed to find nvram image of type %08x\n",
+ 			   image_id);
+ 		return -EINVAL;
+ 	}
+ 
+ 	p_image_att->start_addr = mfw_image_att.nvm_start_addr;
+ 	p_image_att->length = mfw_image_att.len;
+ 
+ 	return 0;
+ }
+ 
+ int qed_mcp_get_nvm_image(struct qed_hwfn *p_hwfn,
+ 			  struct qed_ptt *p_ptt,
+ 			  enum qed_nvm_images image_id,
+ 			  u8 *p_buffer, u32 buffer_len)
+ {
+ 	struct qed_nvm_image_att image_att;
+ 	int rc;
+ 
+ 	memset(p_buffer, 0, buffer_len);
+ 
+ 	rc = qed_mcp_get_nvm_image_att(p_hwfn, p_ptt, image_id, &image_att);
+ 	if (rc)
+ 		return rc;
+ 
+ 	/* Validate sizes - both the image's and the supplied buffer's */
+ 	if (image_att.length <= 4) {
+ 		DP_VERBOSE(p_hwfn, QED_MSG_STORAGE,
+ 			   "Image [%d] is too small - only %d bytes\n",
+ 			   image_id, image_att.length);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* Each NVM image is suffixed by CRC; Upper-layer has no need for it */
+ 	image_att.length -= 4;
+ 
+ 	if (image_att.length > buffer_len) {
+ 		DP_VERBOSE(p_hwfn,
+ 			   QED_MSG_STORAGE,
+ 			   "Image [%d] is too big - %08x bytes where only %08x are available\n",
+ 			   image_id, image_att.length, buffer_len);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	return qed_mcp_nvm_read(p_hwfn->cdev, image_att.start_addr,
+ 				p_buffer, image_att.length);
+ }
+ 
+ static enum resource_id_enum qed_mcp_get_mfw_res_id(enum qed_resources res_id)
+ {
+ 	enum resource_id_enum mfw_res_id = RESOURCE_NUM_INVALID;
+ 
+ 	switch (res_id) {
+ 	case QED_SB:
+ 		mfw_res_id = RESOURCE_NUM_SB_E;
+ 		break;
+ 	case QED_L2_QUEUE:
+ 		mfw_res_id = RESOURCE_NUM_L2_QUEUE_E;
+ 		break;
+ 	case QED_VPORT:
+ 		mfw_res_id = RESOURCE_NUM_VPORT_E;
+ 		break;
+ 	case QED_RSS_ENG:
+ 		mfw_res_id = RESOURCE_NUM_RSS_ENGINES_E;
+ 		break;
+ 	case QED_PQ:
+ 		mfw_res_id = RESOURCE_NUM_PQ_E;
+ 		break;
+ 	case QED_RL:
+ 		mfw_res_id = RESOURCE_NUM_RL_E;
+ 		break;
+ 	case QED_MAC:
+ 	case QED_VLAN:
+ 		/* Each VFC resource can accommodate both a MAC and a VLAN */
+ 		mfw_res_id = RESOURCE_VFC_FILTER_E;
+ 		break;
+ 	case QED_ILT:
+ 		mfw_res_id = RESOURCE_ILT_E;
+ 		break;
+ 	case QED_LL2_QUEUE:
+ 		mfw_res_id = RESOURCE_LL2_QUEUE_E;
+ 		break;
+ 	case QED_RDMA_CNQ_RAM:
+ 	case QED_CMDQS_CQS:
+ 		/* CNQ/CMDQS are the same resource */
+ 		mfw_res_id = RESOURCE_CQS_E;
+ 		break;
+ 	case QED_RDMA_STATS_QUEUE:
+ 		mfw_res_id = RESOURCE_RDMA_STATS_QUEUE_E;
+ 		break;
+ 	case QED_BDQ:
+ 		mfw_res_id = RESOURCE_BDQ_E;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return mfw_res_id;
+ }
+ 
+ #define QED_RESC_ALLOC_VERSION_MAJOR    2
++>>>>>>> 20675b37ee76 (qed: Support NVM-image reading API)
  #define QED_RESC_ALLOC_VERSION_MINOR    0
  #define QED_RESC_ALLOC_VERSION				     \
  	((QED_RESC_ALLOC_VERSION_MAJOR <<		     \
diff --git a/drivers/net/ethernet/qlogic/qed/qed_main.c b/drivers/net/ethernet/qlogic/qed/qed_main.c
index b513e0230d27..e029bc74725e 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_main.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_main.c
@@ -1426,6 +1426,21 @@ static int qed_drain(struct qed_dev *cdev)
 	return 0;
 }
 
+static int qed_nvm_get_image(struct qed_dev *cdev, enum qed_nvm_images type,
+			     u8 *buf, u16 len)
+{
+	struct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);
+	struct qed_ptt *ptt = qed_ptt_acquire(hwfn);
+	int rc;
+
+	if (!ptt)
+		return -EAGAIN;
+
+	rc = qed_mcp_get_nvm_image(hwfn, ptt, type, buf, len);
+	qed_ptt_release(hwfn, ptt);
+	return rc;
+}
+
 static void qed_get_coalesce(struct qed_dev *cdev, u16 *rx_coal, u16 *tx_coal)
 {
 	*rx_coal = cdev->rx_coalesce_usecs;
@@ -1603,6 +1618,7 @@ const struct qed_common_ops qed_common_ops_pass = {
 	.dbg_all_data_size = &qed_dbg_all_data_size,
 	.chain_alloc = &qed_chain_alloc,
 	.chain_free = &qed_chain_free,
+	.nvm_get_image = &qed_nvm_get_image,
 	.get_coalesce = &qed_get_coalesce,
 	.set_coalesce = &qed_set_coalesce,
 	.set_led = &qed_set_led,
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_mcp.c
diff --git a/drivers/net/ethernet/qlogic/qed/qed_mcp.h b/drivers/net/ethernet/qlogic/qed/qed_mcp.h
index f2623df65ec2..fa3cf0b1ceab 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_mcp.h
+++ b/drivers/net/ethernet/qlogic/qed/qed_mcp.h
@@ -416,6 +416,27 @@ int qed_mcp_set_led(struct qed_hwfn *p_hwfn,
  */
 int qed_mcp_nvm_read(struct qed_dev *cdev, u32 addr, u8 *p_buf, u32 len);
 
+struct qed_nvm_image_att {
+	u32 start_addr;
+	u32 length;
+};
+
+/**
+ * @brief Allows reading a whole nvram image
+ *
+ * @param p_hwfn
+ * @param p_ptt
+ * @param image_id - image requested for reading
+ * @param p_buffer - allocated buffer into which to fill data
+ * @param buffer_len - length of the allocated buffer.
+ *
+ * @return 0 iff p_buffer now contains the nvram image.
+ */
+int qed_mcp_get_nvm_image(struct qed_hwfn *p_hwfn,
+			  struct qed_ptt *p_ptt,
+			  enum qed_nvm_images image_id,
+			  u8 *p_buffer, u32 buffer_len);
+
 /**
  * @brief Bist register test
  *
diff --git a/include/linux/qed/qed_if.h b/include/linux/qed/qed_if.h
index 8e0065c52857..57ba7cbae930 100644
--- a/include/linux/qed/qed_if.h
+++ b/include/linux/qed/qed_if.h
@@ -155,6 +155,11 @@ struct qed_dcbx_get {
 	struct qed_dcbx_admin_params local;
 };
 
+enum qed_nvm_images {
+	QED_NVM_IMAGE_ISCSI_CFG,
+	QED_NVM_IMAGE_FCOE_CFG,
+};
+
 enum qed_led_mode {
 	QED_LED_MODE_OFF,
 	QED_LED_MODE_ON,
@@ -601,6 +606,19 @@ struct qed_common_ops {
 	void		(*chain_free)(struct qed_dev *cdev,
 				      struct qed_chain *p_chain);
 
+/**
+ * @brief nvm_get_image - reads an entire image from nvram
+ *
+ * @param cdev
+ * @param type - type of the request nvram image
+ * @param buf - preallocated buffer to fill with the image
+ * @param len - length of the allocated buffer
+ *
+ * @return 0 on success, error otherwise
+ */
+	int (*nvm_get_image)(struct qed_dev *cdev,
+			     enum qed_nvm_images type, u8 *buf, u16 len);
+
 /**
  * @brief get_coalesce - Get coalesce parameters in usec
  *
