nfp: version independent support for chained RSS metadata

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Edwin Peer <edwin.peer@netronome.com>
commit 611bdd4928b0af3906510bb10fc609de1e48d959
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/611bdd49.failed

ABI version 4 introduced metadata chaining. Using the ABI version to signal
metadata chaining precludes firmware that advertises new capabilities which
rely on prepended metadata from working on older kernels.

Capability bits are thus better suited to signalling the chained metadata
format. A new version of the RSS capability is introduced to distinguish
between the differing metadata formats for ABI versions other than 4.

	Signed-off-by: Edwin Peer <edwin.peer@netronome.com>
	Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Simon Horman <simon.horman@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 611bdd4928b0af3906510bb10fc609de1e48d959)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net_common.c
#	drivers/net/ethernet/netronome/nfp/nfp_net_ctrl.h
#	drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index 5094c56dbda7,cc5a2eaef156..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@@ -1938,9 -2199,9 +1938,9 @@@ static int nfp_net_set_config_and_enabl
  	unsigned int r;
  	int err;
  
 -	new_ctrl = nn->dp.ctrl;
 +	new_ctrl = nn->ctrl;
  
- 	if (nn->dp.ctrl & NFP_NET_CFG_CTRL_RSS) {
+ 	if (nn->dp.ctrl & NFP_NET_CFG_CTRL_RSS_ANY) {
  		nfp_net_rss_write_key(nn);
  		nfp_net_rss_write_itbl(nn);
  		nn_writel(nn, NFP_NET_CFG_RSS_CTRL, nn->rss_cfg);
@@@ -2630,7 -3035,7 +2630,11 @@@ void nfp_net_info(struct nfp_net *nn
  		nn->fw_ver.resv, nn->fw_ver.class,
  		nn->fw_ver.major, nn->fw_ver.minor,
  		nn->max_mtu);
++<<<<<<< HEAD
 +	nn_info(nn, "CAP: %#x %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n",
++=======
+ 	nn_info(nn, "CAP: %#x %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n",
++>>>>>>> 611bdd4928b0 (nfp: version independent support for chained RSS metadata)
  		nn->cap,
  		nn->cap & NFP_NET_CFG_CTRL_PROMISC  ? "PROMISC "  : "",
  		nn->cap & NFP_NET_CFG_CTRL_L2BC     ? "L2BCFILT " : "",
@@@ -2641,8 -3046,10 +2645,15 @@@
  		nn->cap & NFP_NET_CFG_CTRL_TXVLAN   ? "TXVLAN "   : "",
  		nn->cap & NFP_NET_CFG_CTRL_SCATTER  ? "SCATTER "  : "",
  		nn->cap & NFP_NET_CFG_CTRL_GATHER   ? "GATHER "   : "",
++<<<<<<< HEAD
 +		nn->cap & NFP_NET_CFG_CTRL_LSO      ? "TSO "      : "",
 +		nn->cap & NFP_NET_CFG_CTRL_RSS      ? "RSS "      : "",
++=======
+ 		nn->cap & NFP_NET_CFG_CTRL_LSO      ? "TSO1 "     : "",
+ 		nn->cap & NFP_NET_CFG_CTRL_LSO2     ? "TSO2 "     : "",
+ 		nn->cap & NFP_NET_CFG_CTRL_RSS      ? "RSS1 "     : "",
+ 		nn->cap & NFP_NET_CFG_CTRL_RSS2     ? "RSS2 "     : "",
++>>>>>>> 611bdd4928b0 (nfp: version independent support for chained RSS metadata)
  		nn->cap & NFP_NET_CFG_CTRL_L2SWITCH ? "L2SWITCH " : "",
  		nn->cap & NFP_NET_CFG_CTRL_MSIXAUTO ? "AUTOMASK " : "",
  		nn->cap & NFP_NET_CFG_CTRL_IRQMOD   ? "IRQMOD "   : "",
@@@ -2750,6 -3203,8 +2761,11 @@@ int nfp_net_netdev_init(struct net_devi
  	struct nfp_net *nn = netdev_priv(netdev);
  	int err;
  
++<<<<<<< HEAD
++=======
+ 	nn->dp.rx_dma_dir = DMA_FROM_DEVICE;
+ 
++>>>>>>> 611bdd4928b0 (nfp: version independent support for chained RSS metadata)
  	/* Get some of the read-only fields from the BAR */
  	nn->cap = nn_readl(nn, NFP_NET_CFG_CAP);
  	nn->max_mtu = nn_readl(nn, NFP_NET_CFG_MAX_MTU);
@@@ -2786,16 -3256,19 +2808,21 @@@
  	}
  	if (nn->cap & NFP_NET_CFG_CTRL_GATHER) {
  		netdev->hw_features |= NETIF_F_SG;
 -		nn->dp.ctrl |= NFP_NET_CFG_CTRL_GATHER;
 +		nn->ctrl |= NFP_NET_CFG_CTRL_GATHER;
  	}
 -	if ((nn->cap & NFP_NET_CFG_CTRL_LSO && nn->fw_ver.major > 2) ||
 -	    nn->cap & NFP_NET_CFG_CTRL_LSO2) {
 +	if ((nn->cap & NFP_NET_CFG_CTRL_LSO) && nn->fw_ver.major > 2) {
  		netdev->hw_features |= NETIF_F_TSO | NETIF_F_TSO6;
 -		nn->dp.ctrl |= nn->cap & NFP_NET_CFG_CTRL_LSO2 ?:
 -					 NFP_NET_CFG_CTRL_LSO;
 +		nn->ctrl |= NFP_NET_CFG_CTRL_LSO;
  	}
- 	if (nn->cap & NFP_NET_CFG_CTRL_RSS) {
+ 	if (nn->cap & NFP_NET_CFG_CTRL_RSS_ANY) {
  		netdev->hw_features |= NETIF_F_RXHASH;
  		nfp_net_rss_init(nn);
++<<<<<<< HEAD
 +		nn->ctrl |= NFP_NET_CFG_CTRL_RSS;
++=======
+ 		nn->dp.ctrl |= nn->cap & NFP_NET_CFG_CTRL_RSS2 ?:
+ 					 NFP_NET_CFG_CTRL_RSS;
++>>>>>>> 611bdd4928b0 (nfp: version independent support for chained RSS metadata)
  	}
  	if (nn->cap & NFP_NET_CFG_CTRL_VXLAN &&
  	    nn->cap & NFP_NET_CFG_CTRL_NVGRE) {
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_ctrl.h
index 92d76a860c19,a049c5d6839d..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_ctrl.h
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_ctrl.h
@@@ -112,9 -119,9 +112,9 @@@
  #define   NFP_NET_CFG_CTRL_TXVLAN         (0x1 <<  7) /* Enable VLAN insert */
  #define   NFP_NET_CFG_CTRL_SCATTER        (0x1 <<  8) /* Scatter DMA */
  #define   NFP_NET_CFG_CTRL_GATHER         (0x1 <<  9) /* Gather DMA */
 -#define   NFP_NET_CFG_CTRL_LSO            (0x1 << 10) /* LSO/TSO (version 1) */
 +#define   NFP_NET_CFG_CTRL_LSO            (0x1 << 10) /* LSO/TSO */
  #define   NFP_NET_CFG_CTRL_RINGCFG        (0x1 << 16) /* Ring runtime changes */
- #define   NFP_NET_CFG_CTRL_RSS            (0x1 << 17) /* RSS */
+ #define   NFP_NET_CFG_CTRL_RSS		  (0x1 << 17) /* RSS (version 1) */
  #define   NFP_NET_CFG_CTRL_IRQMOD         (0x1 << 18) /* Interrupt moderation */
  #define   NFP_NET_CFG_CTRL_RINGPRIO       (0x1 << 19) /* Ring priorities */
  #define   NFP_NET_CFG_CTRL_MSIXAUTO       (0x1 << 20) /* MSI-X auto-masking */
@@@ -123,6 -130,16 +123,19 @@@
  #define   NFP_NET_CFG_CTRL_L2SWITCH_LOCAL (0x1 << 23) /* Switch to local */
  #define   NFP_NET_CFG_CTRL_VXLAN	  (0x1 << 24) /* VXLAN tunnel support */
  #define   NFP_NET_CFG_CTRL_NVGRE	  (0x1 << 25) /* NVGRE tunnel support */
++<<<<<<< HEAD
++=======
+ #define   NFP_NET_CFG_CTRL_BPF		  (0x1 << 27) /* BPF offload capable */
+ #define   NFP_NET_CFG_CTRL_LSO2		  (0x1 << 28) /* LSO/TSO (version 2) */
+ #define   NFP_NET_CFG_CTRL_RSS2		  (0x1 << 29) /* RSS (version 2) */
+ 
+ #define NFP_NET_CFG_CTRL_LSO_ANY	(NFP_NET_CFG_CTRL_LSO | \
+ 					 NFP_NET_CFG_CTRL_LSO2)
+ #define NFP_NET_CFG_CTRL_RSS_ANY	(NFP_NET_CFG_CTRL_RSS | \
+ 					 NFP_NET_CFG_CTRL_RSS2)
+ #define NFP_NET_CFG_CTRL_CHAIN_META	NFP_NET_CFG_CTRL_RSS2
+ 
++>>>>>>> 611bdd4928b0 (nfp: version independent support for chained RSS metadata)
  #define NFP_NET_CFG_UPDATE              0x0004
  #define   NFP_NET_CFG_UPDATE_GEN          (0x1 <<  0) /* General update */
  #define   NFP_NET_CFG_UPDATE_RING         (0x1 <<  1) /* Ring config change */
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
index 69f458e0de89,70bb0a0152b9..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
@@@ -587,7 -603,12 +587,16 @@@ static u32 nfp_net_get_rxfh_indir_size(
  
  static u32 nfp_net_get_rxfh_key_size(struct net_device *netdev)
  {
++<<<<<<< HEAD
 +	return NFP_NET_CFG_RSS_KEY_SZ;
++=======
+ 	struct nfp_net *nn = netdev_priv(netdev);
+ 
+ 	if (!(nn->cap & NFP_NET_CFG_CTRL_RSS_ANY))
+ 		return -EOPNOTSUPP;
+ 
+ 	return nfp_net_rss_key_sz(nn);
++>>>>>>> 611bdd4928b0 (nfp: version independent support for chained RSS metadata)
  }
  
  static int nfp_net_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,
@@@ -617,8 -641,8 +626,13 @@@ static int nfp_net_set_rxfh(struct net_
  	struct nfp_net *nn = netdev_priv(netdev);
  	int i;
  
++<<<<<<< HEAD
 +	if (!(nn->cap & NFP_NET_CFG_CTRL_RSS) ||
 +	    !(hfunc == ETH_RSS_HASH_NO_CHANGE || hfunc == ETH_RSS_HASH_TOP))
++=======
+ 	if (!(nn->cap & NFP_NET_CFG_CTRL_RSS_ANY) ||
+ 	    !(hfunc == ETH_RSS_HASH_NO_CHANGE || hfunc == nn->rss_hfunc))
++>>>>>>> 611bdd4928b0 (nfp: version independent support for chained RSS metadata)
  		return -EOPNOTSUPP;
  
  	if (!key && !indir)
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_common.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_ctrl.h
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
