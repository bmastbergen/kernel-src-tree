Kconfig: Introduce the "imply" keyword

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Nicolas Pitre <nicolas.pitre@linaro.org>
commit 237e3ad0f195d8fd34f1299e45f04793832a16fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/237e3ad0.failed

The "imply" keyword is a weak version of "select" where the target
config symbol can still be turned off, avoiding those pitfalls that come
with the "select" keyword.

This is useful e.g. with multiple drivers that want to indicate their
ability to hook into a secondary subsystem while allowing the user to
configure that subsystem out without also having to unset these drivers.

Currently, the same effect can almost be achieved with:

config DRIVER_A
	tristate

config DRIVER_B
	tristate

config DRIVER_C
	tristate

config DRIVER_D
	tristate

[...]

config SUBSYSTEM_X
	tristate
	default DRIVER_A || DRIVER_B || DRIVER_C || DRIVER_D || [...]

This is unwieldy to maintain especially with a large number of drivers.
Furthermore, there is no easy way to restrict the choice for SUBSYSTEM_X
to y or n, excluding m, when some drivers are built-in. The "select"
keyword allows for excluding m, but it excludes n as well. Hence
this "imply" keyword.  The above becomes:

config DRIVER_A
	tristate
	imply SUBSYSTEM_X

config DRIVER_B
	tristate
	imply SUBSYSTEM_X

[...]

config SUBSYSTEM_X
	tristate

This is much cleaner, and way more flexible than "select". SUBSYSTEM_X
can still be configured out, and it can be set as a module when none of
the drivers are configured in or all of them are modular.

	Signed-off-by: Nicolas Pitre <nico@linaro.org>
	Acked-by: Richard Cochran <richardcochran@gmail.com>
	Acked-by: Thomas Gleixner <tglx@linutronix.de>
	Acked-by: John Stultz <john.stultz@linaro.org>
	Reviewed-by: Josh Triplett <josh@joshtriplett.org>
	Cc: Paul Bolle <pebolle@tiscali.nl>
	Cc: linux-kbuild@vger.kernel.org
	Cc: netdev@vger.kernel.org
	Cc: Michal Marek <mmarek@suse.com>
	Cc: Edward Cree <ecree@solarflare.com>
Link: http://lkml.kernel.org/r/1478841010-28605-2-git-send-email-nicolas.pitre@linaro.org
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit 237e3ad0f195d8fd34f1299e45f04793832a16fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/kbuild/kconfig-language.txt
diff --cc Documentation/kbuild/kconfig-language.txt
index c858f8419eba,262722d8867b..000000000000
--- a/Documentation/kbuild/kconfig-language.txt
+++ b/Documentation/kbuild/kconfig-language.txt
@@@ -388,3 -462,165 +416,168 @@@ config FO
  	depends on BAR && m
  
  limits FOO to module (=m) or disabled (=n).
++<<<<<<< HEAD
++=======
+ 
+ Kconfig recursive dependency limitations
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ 
+ If you've hit the Kconfig error: "recursive dependency detected" you've run
+ into a recursive dependency issue with Kconfig, a recursive dependency can be
+ summarized as a circular dependency. The kconfig tools need to ensure that
+ Kconfig files comply with specified configuration requirements. In order to do
+ that kconfig must determine the values that are possible for all Kconfig
+ symbols, this is currently not possible if there is a circular relation
+ between two or more Kconfig symbols. For more details refer to the "Simple
+ Kconfig recursive issue" subsection below. Kconfig does not do recursive
+ dependency resolution; this has a few implications for Kconfig file writers.
+ We'll first explain why this issues exists and then provide an example
+ technical limitation which this brings upon Kconfig developers. Eager
+ developers wishing to try to address this limitation should read the next
+ subsections.
+ 
+ Simple Kconfig recursive issue
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ 
+ Read: Documentation/kbuild/Kconfig.recursion-issue-01
+ 
+ Test with:
+ 
+ make KBUILD_KCONFIG=Documentation/kbuild/Kconfig.recursion-issue-01 allnoconfig
+ 
+ Cumulative Kconfig recursive issue
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ 
+ Read: Documentation/kbuild/Kconfig.recursion-issue-02
+ 
+ Test with:
+ 
+ make KBUILD_KCONFIG=Documentation/kbuild/Kconfig.recursion-issue-02 allnoconfig
+ 
+ Practical solutions to kconfig recursive issue
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ 
+ Developers who run into the recursive Kconfig issue have three options
+ at their disposal. We document them below and also provide a list of
+ historical issues resolved through these different solutions.
+ 
+   a) Remove any superfluous "select FOO" or "depends on FOO"
+   b) Match dependency semantics:
+ 	b1) Swap all "select FOO" to "depends on FOO" or,
+ 	b2) Swap all "depends on FOO" to "select FOO"
+   c) Consider the use of "imply" instead of "select"
+ 
+ The resolution to a) can be tested with the sample Kconfig file
+ Documentation/kbuild/Kconfig.recursion-issue-01 through the removal
+ of the "select CORE" from CORE_BELL_A_ADVANCED as that is implicit already
+ since CORE_BELL_A depends on CORE. At times it may not be possible to remove
+ some dependency criteria, for such cases you can work with solution b).
+ 
+ The two different resolutions for b) can be tested in the sample Kconfig file
+ Documentation/kbuild/Kconfig.recursion-issue-02.
+ 
+ Below is a list of examples of prior fixes for these types of recursive issues;
+ all errors appear to involve one or more select's and one or more "depends on".
+ 
+ commit          fix
+ ======          ===
+ 06b718c01208    select A -> depends on A
+ c22eacfe82f9    depends on A -> depends on B
+ 6a91e854442c    select A -> depends on A
+ 118c565a8f2e    select A -> select B
+ f004e5594705    select A -> depends on A
+ c7861f37b4c6    depends on A -> (null)
+ 80c69915e5fb    select A -> (null)              (1)
+ c2218e26c0d0    select A -> depends on A        (1)
+ d6ae99d04e1c    select A -> depends on A
+ 95ca19cf8cbf    select A -> depends on A
+ 8f057d7bca54    depends on A -> (null)
+ 8f057d7bca54    depends on A -> select A
+ a0701f04846e    select A -> depends on A
+ 0c8b92f7f259    depends on A -> (null)
+ e4e9e0540928    select A -> depends on A        (2)
+ 7453ea886e87    depends on A > (null)           (1)
+ 7b1fff7e4fdf    select A -> depends on A
+ 86c747d2a4f0    select A -> depends on A
+ d9f9ab51e55e    select A -> depends on A
+ 0c51a4d8abd6    depends on A -> select A        (3)
+ e98062ed6dc4    select A -> depends on A        (3)
+ 91e5d284a7f1    select A -> (null)
+ 
+ (1) Partial (or no) quote of error.
+ (2) That seems to be the gist of that fix.
+ (3) Same error.
+ 
+ Future kconfig work
+ ~~~~~~~~~~~~~~~~~~~
+ 
+ Work on kconfig is welcomed on both areas of clarifying semantics and on
+ evaluating the use of a full SAT solver for it. A full SAT solver can be
+ desirable to enable more complex dependency mappings and / or queries,
+ for instance on possible use case for a SAT solver could be that of handling
+ the current known recursive dependency issues. It is not known if this would
+ address such issues but such evaluation is desirable. If support for a full SAT
+ solver proves too complex or that it cannot address recursive dependency issues
+ Kconfig should have at least clear and well defined semantics which also
+ addresses and documents limitations or requirements such as the ones dealing
+ with recursive dependencies.
+ 
+ Further work on both of these areas is welcomed on Kconfig. We elaborate
+ on both of these in the next two subsections.
+ 
+ Semantics of Kconfig
+ ~~~~~~~~~~~~~~~~~~~~
+ 
+ The use of Kconfig is broad, Linux is now only one of Kconfig's users:
+ one study has completed a broad analysis of Kconfig use in 12 projects [0].
+ Despite its widespread use, and although this document does a reasonable job
+ in documenting basic Kconfig syntax a more precise definition of Kconfig
+ semantics is welcomed. One project deduced Kconfig semantics through
+ the use of the xconfig configurator [1]. Work should be done to confirm if
+ the deduced semantics matches our intended Kconfig design goals.
+ 
+ Having well defined semantics can be useful for tools for practical
+ evaluation of depenencies, for instance one such use known case was work to
+ express in boolean abstraction of the inferred semantics of Kconfig to
+ translate Kconfig logic into boolean formulas and run a SAT solver on this to
+ find dead code / features (always inactive), 114 dead features were found in
+ Linux using this methodology [1] (Section 8: Threats to validity).
+ 
+ Confirming this could prove useful as Kconfig stands as one of the the leading
+ industrial variability modeling languages [1] [2]. Its study would help
+ evaluate practical uses of such languages, their use was only theoretical
+ and real world requirements were not well understood. As it stands though
+ only reverse engineering techniques have been used to deduce semantics from
+ variability modeling languages such as Kconfig [3].
+ 
+ [0] http://www.eng.uwaterloo.ca/~shshe/kconfig_semantics.pdf
+ [1] http://gsd.uwaterloo.ca/sites/default/files/vm-2013-berger.pdf
+ [2] http://gsd.uwaterloo.ca/sites/default/files/ase241-berger_0.pdf
+ [3] http://gsd.uwaterloo.ca/sites/default/files/icse2011.pdf
+ 
+ Full SAT solver for Kconfig
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ 
+ Although SAT solvers [0] haven't yet been used by Kconfig directly, as noted in
+ the previous subsection, work has been done however to express in boolean
+ abstraction the inferred semantics of Kconfig to translate Kconfig logic into
+ boolean formulas and run a SAT solver on it [1]. Another known related project
+ is CADOS [2] (former VAMOS [3]) and the tools, mainly undertaker [4], which has
+ been introduced first with [5].  The basic concept of undertaker is to exract
+ variability models from Kconfig, and put them together with a propositional
+ formula extracted from CPP #ifdefs and build-rules into a SAT solver in order
+ to find dead code, dead files, and dead symbols. If using a SAT solver is
+ desirable on Kconfig one approach would be to evaluate repurposing such efforts
+ somehow on Kconfig. There is enough interest from mentors of existing projects
+ to not only help advise how to integrate this work upstream but also help
+ maintain it long term. Interested developers should visit:
+ 
+ http://kernelnewbies.org/KernelProjects/kconfig-sat
+ 
+ [0] http://www.cs.cornell.edu/~sabhar/chapters/SATSolvers-KR-Handbook.pdf
+ [1] http://gsd.uwaterloo.ca/sites/default/files/vm-2013-berger.pdf
+ [2] https://cados.cs.fau.de
+ [3] https://vamos.cs.fau.de
+ [4] https://undertaker.cs.fau.de
+ [5] https://www4.cs.fau.de/Publications/2011/tartler_11_eurosys.pdf
++>>>>>>> 237e3ad0f195 (Kconfig: Introduce the "imply" keyword)
* Unmerged path Documentation/kbuild/kconfig-language.txt
diff --git a/scripts/kconfig/expr.h b/scripts/kconfig/expr.h
index 8fb302c03785..b2add71762d2 100644
--- a/scripts/kconfig/expr.h
+++ b/scripts/kconfig/expr.h
@@ -85,6 +85,7 @@ struct symbol {
 	struct property *prop;
 	struct expr_value dir_dep;
 	struct expr_value rev_dep;
+	struct expr_value implied;
 };
 
 #define for_all_symbols(i, sym) for (i = 0; i < SYMBOL_HASHSIZE; i++) for (sym = symbol_hash[i]; sym; sym = sym->next) if (sym->type != S_OTHER)
@@ -130,6 +131,7 @@ enum prop_type {
 	P_DEFAULT,  /* default y */
 	P_CHOICE,   /* choice value */
 	P_SELECT,   /* select BAR */
+	P_IMPLY,    /* imply BAR */
 	P_RANGE,    /* range 7..100 (for a symbol) */
 	P_ENV,      /* value from environment variable */
 	P_SYMBOL,   /* where a symbol is defined */
diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 160c4236bc67..a146e3e3304f 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -223,6 +223,8 @@ static void sym_check_prop(struct symbol *sym)
 {
 	struct property *prop;
 	struct symbol *sym2;
+	char *use;
+
 	for (prop = sym->prop; prop; prop = prop->next) {
 		switch (prop->type) {
 		case P_DEFAULT:
@@ -242,18 +244,20 @@ static void sym_check_prop(struct symbol *sym)
 			}
 			break;
 		case P_SELECT:
+		case P_IMPLY:
+			use = prop->type == P_SELECT ? "select" : "imply";
 			sym2 = prop_get_symbol(prop);
 			if (sym->type != S_BOOLEAN && sym->type != S_TRISTATE)
 				prop_warn(prop,
-				    "config symbol '%s' uses select, but is "
-				    "not boolean or tristate", sym->name);
+				    "config symbol '%s' uses %s, but is "
+				    "not boolean or tristate", sym->name, use);
 			else if (sym2->type != S_UNKNOWN &&
 			         sym2->type != S_BOOLEAN &&
 			         sym2->type != S_TRISTATE)
 				prop_warn(prop,
-				    "'%s' has wrong type. 'select' only "
+				    "'%s' has wrong type. '%s' only "
 				    "accept arguments of boolean and "
-				    "tristate type", sym2->name);
+				    "tristate type", sym2->name, use);
 			break;
 		case P_RANGE:
 			if (sym->type != S_INT && sym->type != S_HEX)
@@ -323,6 +327,10 @@ void menu_finalize(struct menu *parent)
 					struct symbol *es = prop_get_symbol(prop);
 					es->rev_dep.expr = expr_alloc_or(es->rev_dep.expr,
 							expr_alloc_and(expr_alloc_symbol(menu->sym), expr_copy(dep)));
+				} else if (prop->type == P_IMPLY) {
+					struct symbol *es = prop_get_symbol(prop);
+					es->implied.expr = expr_alloc_or(es->implied.expr,
+							expr_alloc_and(expr_alloc_symbol(menu->sym), expr_copy(dep)));
 				}
 			}
 		}
@@ -586,13 +594,30 @@ static struct property *get_symbol_prop(struct symbol *sym)
 	return prop;
 }
 
+static void get_symbol_props_str(struct gstr *r, struct symbol *sym,
+				 enum prop_type tok, const char *prefix)
+{
+	bool hit = false;
+	struct property *prop;
+
+	for_all_properties(sym, prop, tok) {
+		if (!hit) {
+			str_append(r, prefix);
+			hit = true;
+		} else
+			str_printf(r, " && ");
+		expr_gstr_print(prop->expr, r);
+	}
+	if (hit)
+		str_append(r, "\n");
+}
+
 /*
  * head is optional and may be NULL
  */
 void get_symbol_str(struct gstr *r, struct symbol *sym,
 		    struct list_head *head)
 {
-	bool hit;
 	struct property *prop;
 
 	if (sym && sym->name) {
@@ -622,22 +647,20 @@ void get_symbol_str(struct gstr *r, struct symbol *sym,
 		}
 	}
 
-	hit = false;
-	for_all_properties(sym, prop, P_SELECT) {
-		if (!hit) {
-			str_append(r, "  Selects: ");
-			hit = true;
-		} else
-			str_printf(r, " && ");
-		expr_gstr_print(prop->expr, r);
-	}
-	if (hit)
-		str_append(r, "\n");
+	get_symbol_props_str(r, sym, P_SELECT, _("  Selects: "));
 	if (sym->rev_dep.expr) {
 		str_append(r, _("  Selected by: "));
 		expr_gstr_print(sym->rev_dep.expr, r);
 		str_append(r, "\n");
 	}
+
+	get_symbol_props_str(r, sym, P_IMPLY, _("  Implies: "));
+	if (sym->implied.expr) {
+		str_append(r, _("  Implied by: "));
+		expr_gstr_print(sym->implied.expr, r);
+		str_append(r, "\n");
+	}
+
 	str_append(r, "\n\n");
 }
 
diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index a02ee7cb5c4a..b34718cfd3b2 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -223,6 +223,15 @@ static void sym_calc_visibility(struct symbol *sym)
 		sym->rev_dep.tri = tri;
 		sym_set_changed(sym);
 	}
+	tri = no;
+	if (sym->implied.expr && sym->dir_dep.tri != no)
+		tri = expr_calc_value(sym->implied.expr);
+	if (tri == mod && sym_get_type(sym) == S_BOOLEAN)
+		tri = yes;
+	if (sym->implied.tri != tri) {
+		sym->implied.tri = tri;
+		sym_set_changed(sym);
+	}
 }
 
 /*
@@ -354,6 +363,10 @@ void sym_calc_value(struct symbol *sym)
 					newval.tri = EXPR_AND(expr_calc_value(prop->expr),
 							      prop->visible.tri);
 				}
+				if (sym->implied.tri != no) {
+					sym->flags |= SYMBOL_WRITE;
+					newval.tri = EXPR_OR(newval.tri, sym->implied.tri);
+				}
 			}
 		calc_newval:
 			if (sym->dir_dep.tri == no && sym->rev_dep.tri != no) {
@@ -370,7 +383,8 @@ void sym_calc_value(struct symbol *sym)
 			}
 			newval.tri = EXPR_OR(newval.tri, sym->rev_dep.tri);
 		}
-		if (newval.tri == mod && sym_get_type(sym) == S_BOOLEAN)
+		if (newval.tri == mod &&
+		    (sym_get_type(sym) == S_BOOLEAN || sym->implied.tri == yes))
 			newval.tri = yes;
 		break;
 	case S_STRING:
@@ -473,6 +487,8 @@ bool sym_tristate_within_range(struct symbol *sym, tristate val)
 		return false;
 	if (sym->visible <= sym->rev_dep.tri)
 		return false;
+	if (sym->implied.tri == yes && val == mod)
+		return false;
 	if (sym_is_choice_value(sym) && sym->visible == yes)
 		return val == yes;
 	return val >= sym->rev_dep.tri && val <= sym->visible;
@@ -725,6 +741,10 @@ const char *sym_get_string_default(struct symbol *sym)
 	if (sym->type == S_BOOLEAN && val == mod)
 		val = yes;
 
+	/* adjust the default value if this symbol is implied by another */
+	if (val < sym->implied.tri)
+		val = sym->implied.tri;
+
 	switch (sym->type) {
 	case S_BOOLEAN:
 	case S_TRISTATE:
@@ -1274,6 +1294,8 @@ const char *prop_get_type_name(enum prop_type type)
 		return "choice";
 	case P_SELECT:
 		return "select";
+	case P_IMPLY:
+		return "imply";
 	case P_RANGE:
 		return "range";
 	case P_SYMBOL:
diff --git a/scripts/kconfig/zconf.gperf b/scripts/kconfig/zconf.gperf
index ef091df0ad4b..3db8977fe449 100644
--- a/scripts/kconfig/zconf.gperf
+++ b/scripts/kconfig/zconf.gperf
@@ -38,6 +38,7 @@ int,		T_TYPE,		TF_COMMAND, S_INT
 hex,		T_TYPE,		TF_COMMAND, S_HEX
 string,		T_TYPE,		TF_COMMAND, S_STRING
 select,		T_SELECT,	TF_COMMAND
+imply,		T_IMPLY,	TF_COMMAND
 range,		T_RANGE,	TF_COMMAND
 visible,	T_VISIBLE,	TF_COMMAND
 option,		T_OPTION,	TF_COMMAND
diff --git a/scripts/kconfig/zconf.y b/scripts/kconfig/zconf.y
index a841de222a6a..5e99b79cce21 100644
--- a/scripts/kconfig/zconf.y
+++ b/scripts/kconfig/zconf.y
@@ -31,7 +31,7 @@ struct symbol *symbol_hash[SYMBOL_HASHSIZE];
 static struct menu *current_menu, *current_entry;
 
 %}
-%expect 30
+%expect 32
 
 %union
 {
@@ -62,6 +62,7 @@ static struct menu *current_menu, *current_entry;
 %token <id>T_TYPE
 %token <id>T_DEFAULT
 %token <id>T_SELECT
+%token <id>T_IMPLY
 %token <id>T_RANGE
 %token <id>T_VISIBLE
 %token <id>T_OPTION
@@ -124,7 +125,7 @@ stmt_list:
 ;
 
 option_name:
-	T_DEPENDS | T_PROMPT | T_TYPE | T_SELECT | T_OPTIONAL | T_RANGE | T_DEFAULT | T_VISIBLE
+	T_DEPENDS | T_PROMPT | T_TYPE | T_SELECT | T_IMPLY | T_OPTIONAL | T_RANGE | T_DEFAULT | T_VISIBLE
 ;
 
 common_stmt:
@@ -216,6 +217,12 @@ config_option: T_SELECT T_WORD if_expr T_EOL
 	printd(DEBUG_PARSE, "%s:%d:select\n", zconf_curname(), zconf_lineno());
 };
 
+config_option: T_IMPLY T_WORD if_expr T_EOL
+{
+	menu_add_symbol(P_IMPLY, sym_lookup($2, 0), $3);
+	printd(DEBUG_PARSE, "%s:%d:imply\n", zconf_curname(), zconf_lineno());
+};
+
 config_option: T_RANGE symbol symbol if_expr T_EOL
 {
 	menu_add_expr(P_RANGE, expr_alloc_comp(E_RANGE,$2, $3), $4);
@@ -664,6 +671,11 @@ static void print_symbol(FILE *out, struct menu *menu)
 			expr_fprint(prop->expr, out);
 			fputc('\n', out);
 			break;
+		case P_IMPLY:
+			fputs( "  imply ", out);
+			expr_fprint(prop->expr, out);
+			fputc('\n', out);
+			break;
 		case P_RANGE:
 			fputs( "  range ", out);
 			expr_fprint(prop->expr, out);
