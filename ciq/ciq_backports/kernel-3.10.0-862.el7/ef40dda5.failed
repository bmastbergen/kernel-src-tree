uuid: hoist uuid_is_null() helper from libnvdimm

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Christoph Hellwig <hch@lst.de>
commit ef40dda5bbc310f6517082c0ff002913104358cd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ef40dda5.failed

Hoist the libnvdimm helper as an inline helper to linux/uuid.h
using an auxiliary const variable uuid_null in lib/uuid.c.

[hch: also add the guid variant.  Both do the same but I'd like
to keep casts to a minimum]

The common helper uses the new abstract type uuid_t * instead of
u8 *.

	Suggested-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
[hch: added guid_is_null]
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Acked-by: Dan Williams <dan.j.williams@intel.com>
	Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
(cherry picked from commit ef40dda5bbc310f6517082c0ff002913104358cd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/uuid.h
#	lib/uuid.c
diff --cc include/linux/uuid.h
index c057ef20cfda,75f7182d5360..000000000000
--- a/include/linux/uuid.h
+++ b/include/linux/uuid.h
@@@ -43,14 -35,37 +43,45 @@@ typedef struct 
   */
  #define	UUID_STRING_LEN		36
  
++<<<<<<< HEAD
 +static inline int uuid_le_cmp(const uuid_le u1, const uuid_le u2)
++=======
+ extern const guid_t guid_null;
+ extern const uuid_t uuid_null;
+ 
+ static inline bool guid_equal(const guid_t *u1, const guid_t *u2)
++>>>>>>> ef40dda5bbc3 (uuid: hoist uuid_is_null() helper from libnvdimm)
  {
 -	return memcmp(u1, u2, sizeof(guid_t)) == 0;
 +	return memcmp(&u1, &u2, sizeof(uuid_le));
  }
  
 -static inline void guid_copy(guid_t *dst, const guid_t *src)
 +static inline int uuid_be_cmp(const uuid_be u1, const uuid_be u2)
  {
++<<<<<<< HEAD
 +	return memcmp(&u1, &u2, sizeof(uuid_be));
++=======
+ 	memcpy(dst, src, sizeof(guid_t));
+ }
+ 
+ static inline bool guid_is_null(guid_t *guid)
+ {
+ 	return guid_equal(guid, &guid_null);
+ }
+ 
+ static inline bool uuid_equal(const uuid_t *u1, const uuid_t *u2)
+ {
+ 	return memcmp(u1, u2, sizeof(uuid_t)) == 0;
+ }
+ 
+ static inline void uuid_copy(uuid_t *dst, const uuid_t *src)
+ {
+ 	memcpy(dst, src, sizeof(uuid_t));
++>>>>>>> ef40dda5bbc3 (uuid: hoist uuid_is_null() helper from libnvdimm)
+ }
+ 
+ static inline bool uuid_is_null(uuid_t *uuid)
+ {
+ 	return uuid_equal(uuid, &uuid_null);
  }
  
  void generate_random_uuid(unsigned char uuid[16]);
diff --cc lib/uuid.c
index fd324f438ef9,680b9fb9ba09..000000000000
--- a/lib/uuid.c
+++ b/lib/uuid.c
@@@ -25,10 -21,13 +25,20 @@@
  #include <linux/uuid.h>
  #include <linux/random.h>
  
++<<<<<<< HEAD
 +const u8 uuid_le_index[16] = {3,2,1,0,5,4,7,6,8,9,10,11,12,13,14,15};
 +EXPORT_SYMBOL(uuid_le_index);
 +const u8 uuid_be_index[16] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
 +EXPORT_SYMBOL(uuid_be_index);
++=======
+ const guid_t guid_null;
+ EXPORT_SYMBOL(guid_null);
+ const uuid_t uuid_null;
+ EXPORT_SYMBOL(uuid_null);
+ 
+ const u8 guid_index[16] = {3,2,1,0,5,4,7,6,8,9,10,11,12,13,14,15};
+ const u8 uuid_index[16] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
++>>>>>>> ef40dda5bbc3 (uuid: hoist uuid_is_null() helper from libnvdimm)
  
  /***************************************************************
   * Random UUID interface
diff --git a/drivers/nvdimm/btt_devs.c b/drivers/nvdimm/btt_devs.c
index 4b76af2b8715..734290d30557 100644
--- a/drivers/nvdimm/btt_devs.c
+++ b/drivers/nvdimm/btt_devs.c
@@ -222,13 +222,6 @@ struct device *nd_btt_create(struct nd_region *nd_region)
 	return dev;
 }
 
-static bool uuid_is_null(u8 *uuid)
-{
-	static const u8 null_uuid[16];
-
-	return (memcmp(uuid, null_uuid, 16) == 0);
-}
-
 /**
  * nd_btt_arena_is_valid - check if the metadata layout is valid
  * @nd_btt:	device with BTT geometry and backing device info
@@ -249,7 +242,7 @@ bool nd_btt_arena_is_valid(struct nd_btt *nd_btt, struct btt_sb *super)
 	if (memcmp(super->signature, BTT_SIG, BTT_SIG_LEN) != 0)
 		return false;
 
-	if (!uuid_is_null(super->parent_uuid))
+	if (!guid_is_null((guid_t *)&super->parent_uuid))
 		if (memcmp(super->parent_uuid, parent_uuid, 16) != 0)
 			return false;
 
* Unmerged path include/linux/uuid.h
* Unmerged path lib/uuid.c
