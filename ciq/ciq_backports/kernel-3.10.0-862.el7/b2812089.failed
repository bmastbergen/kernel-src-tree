net/mlx5e: Check encap entry state when offloading tunneled flows

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Check encap entry state when offloading tunneled flows (Kamal Heib) [1456694]
Rebuild_FUZZ: 96.83%
commit-author Vlad Buslov <vladbu@mellanox.com>
commit b281208911a549e391d92ee6cb680dcd3d71783b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b2812089.failed

Encap entries cached by the driver could be invalidated due to
tunnel destination neighbour state changes.
When attempting to offload a flow that uses a cached encap entry,
we must check the entry validity and defer the offloading
if the entry exists but not valid.

When EAGAIN is returned, the flow offloading to hardware takes place
by the neigh update code when the tunnel destination neighbour
becomes connected.

Fixes: 232c001398ae ("net/mlx5e: Add support to neighbour update flow")
	Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit b281208911a549e391d92ee6cb680dcd3d71783b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 2a258dca3413,1aa2028ed995..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -1537,10 -1859,9 +1537,16 @@@ vxlan_encap_offload_err
  		}
  	}
  
++<<<<<<< HEAD
 +	if (found) {
 +		attr->encap = e;
 +		return 0;
 +	}
++=======
+ 	/* must verify if encap is valid or not */
+ 	if (found)
+ 		goto attach_flow;
++>>>>>>> b281208911a5 (net/mlx5e: Check encap entry state when offloading tunneled flows)
  
  	e = kzalloc(sizeof(*e), GFP_KERNEL);
  	if (!e)
@@@ -1551,16 -1872,23 +1557,27 @@@
  	INIT_LIST_HEAD(&e->flows);
  
  	if (family == AF_INET)
 -		err = mlx5e_create_encap_header_ipv4(priv, mirred_dev, e);
 +		err = mlx5e_create_encap_header_ipv4(priv, mirred_dev, e, &out_dev);
  	else if (family == AF_INET6)
 -		err = mlx5e_create_encap_header_ipv6(priv, mirred_dev, e);
 +		err = mlx5e_create_encap_header_ipv6(priv, mirred_dev, e, &out_dev);
  
 -	if (err && err != -EAGAIN)
 +	if (err)
  		goto out_err;
  
 +	attr->encap = e;
  	hash_add_rcu(esw->offloads.encap_tbl, &e->encap_hlist, hash_key);
  
++<<<<<<< HEAD
++=======
+ attach_flow:
+ 	list_add(&flow->encap, &e->flows);
+ 	*encap_dev = e->out_dev;
+ 	if (e->flags & MLX5_ENCAP_ENTRY_VALID)
+ 		attr->encap_id = e->encap_id;
+ 	else
+ 		err = -EAGAIN;
+ 
++>>>>>>> b281208911a5 (net/mlx5e: Check encap entry state when offloading tunneled flows)
  	return err;
  
  out_err:
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
