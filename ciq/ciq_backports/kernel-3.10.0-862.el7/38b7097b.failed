ipv6: use TOS marks from sockets for routing decision

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Hannes Frederic Sowa <hannes@stressinduktion.org>
commit 38b7097b55b6cf30adc5ac07cb1055683224393e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/38b7097b.failed

In IPv6 the ToS values are part of the flowlabel in flowi6 and get
extracted during fib rule lookup, but we forgot to correctly initialize
the flowlabel before the routing lookup.

	Reported-by: <liam.mcbirnie@boeing.com>
	Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 38b7097b55b6cf30adc5ac07cb1055683224393e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/icmp.c
#	net/ipv6/ping.c
#	net/ipv6/raw.c
#	net/ipv6/udp.c
#	net/l2tp/l2tp_ip6.c
diff --cc net/ipv6/icmp.c
index 156d311c5418,40454bfb534e..000000000000
--- a/net/ipv6/icmp.c
+++ b/net/ipv6/icmp.c
@@@ -508,12 -509,9 +511,18 @@@ static void icmp6_send(struct sk_buff *
  	if (IS_ERR(dst))
  		goto out;
  
++<<<<<<< HEAD
 +	if (ipv6_addr_is_multicast(&fl6.daddr))
 +		hlimit = np->mcast_hops;
 +	else
 +		hlimit = np->hop_limit;
 +	if (hlimit < 0)
 +		hlimit = ip6_dst_hoplimit(dst);
++=======
+ 	ipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);
+ 	ipc6.dontfrag = np->dontfrag;
+ 	ipc6.opt = NULL;
++>>>>>>> 38b7097b55b6 (ipv6: use TOS marks from sockets for routing decision)
  
  	msg.skb = skb;
  	msg.offset = skb_network_offset(skb);
diff --cc net/ipv6/raw.c
index c5057d832708,590dd1f7746f..000000000000
--- a/net/ipv6/raw.c
+++ b/net/ipv6/raw.c
@@@ -871,20 -888,11 +876,25 @@@ static int rawv6_sendmsg(struct kiocb *
  		err = PTR_ERR(dst);
  		goto out;
  	}
 -	if (ipc6.hlimit < 0)
 -		ipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);
 +	if (hlimit < 0) {
 +		if (ipv6_addr_is_multicast(&fl6.daddr))
 +			hlimit = np->mcast_hops;
 +		else
 +			hlimit = np->hop_limit;
 +		if (hlimit < 0)
 +			hlimit = ip6_dst_hoplimit(dst);
 +	}
 +
++<<<<<<< HEAD
 +	if (tclass < 0)
 +		tclass = np->tclass;
  
 +	if (dontfrag < 0)
 +		dontfrag = np->dontfrag;
++=======
+ 	if (ipc6.dontfrag < 0)
+ 		ipc6.dontfrag = np->dontfrag;
++>>>>>>> 38b7097b55b6 (ipv6: use TOS marks from sockets for routing decision)
  
  	if (msg->msg_flags&MSG_CONFIRM)
  		goto do_confirm;
diff --cc net/ipv6/udp.c
index 200e54f08465,4bb5c13777f1..000000000000
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@@ -1286,18 -1258,9 +1291,21 @@@ do_udp_sendmsg
  		goto out;
  	}
  
 -	if (ipc6.hlimit < 0)
 -		ipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);
 +	if (hlimit < 0) {
 +		if (ipv6_addr_is_multicast(&fl6.daddr))
 +			hlimit = np->mcast_hops;
 +		else
 +			hlimit = np->hop_limit;
 +		if (hlimit < 0)
 +			hlimit = ip6_dst_hoplimit(dst);
 +	}
 +
++<<<<<<< HEAD
 +	if (tclass < 0)
 +		tclass = np->tclass;
  
++=======
++>>>>>>> 38b7097b55b6 (ipv6: use TOS marks from sockets for routing decision)
  	if (msg->msg_flags&MSG_CONFIRM)
  		goto do_confirm;
  back_from_confirm:
diff --cc net/l2tp/l2tp_ip6.c
index 636e3095420e,ea2ae6664cc8..000000000000
--- a/net/l2tp/l2tp_ip6.c
+++ b/net/l2tp/l2tp_ip6.c
@@@ -608,20 -622,11 +613,25 @@@ static int l2tp_ip6_sendmsg(struct kioc
  		goto out;
  	}
  
 -	if (ipc6.hlimit < 0)
 -		ipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);
 +	if (hlimit < 0) {
 +		if (ipv6_addr_is_multicast(&fl6.daddr))
 +			hlimit = np->mcast_hops;
 +		else
 +			hlimit = np->hop_limit;
 +		if (hlimit < 0)
 +			hlimit = ip6_dst_hoplimit(dst);
 +	}
 +
++<<<<<<< HEAD
 +	if (tclass < 0)
 +		tclass = np->tclass;
  
 +	if (dontfrag < 0)
 +		dontfrag = np->dontfrag;
++=======
+ 	if (ipc6.dontfrag < 0)
+ 		ipc6.dontfrag = np->dontfrag;
++>>>>>>> 38b7097b55b6 (ipv6: use TOS marks from sockets for routing decision)
  
  	if (msg->msg_flags & MSG_CONFIRM)
  		goto do_confirm;
* Unmerged path net/ipv6/ping.c
* Unmerged path net/ipv6/icmp.c
* Unmerged path net/ipv6/ping.c
* Unmerged path net/ipv6/raw.c
diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index c96e425ebc8d..f46c58d5a86c 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -3275,6 +3275,8 @@ static int inet6_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr* nlh)
 
 	err = -EINVAL;
 	memset(&fl6, 0, sizeof(fl6));
+	rtm = nlmsg_data(nlh);
+	fl6.flowlabel = ip6_make_flowinfo(rtm->rtm_tos, 0);
 
 	if (tb[RTA_SRC]) {
 		if (nla_len(tb[RTA_SRC]) < sizeof(struct in6_addr))
* Unmerged path net/ipv6/udp.c
* Unmerged path net/l2tp/l2tp_ip6.c
