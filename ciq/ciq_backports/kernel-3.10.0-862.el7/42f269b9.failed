ovl: rearrange code in ovl_copy_up_locked()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 42f269b925405d9dd45014823e5057786d6ca452
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/42f269b9.failed

As preparation to implementing copy up with O_TMPFILE,
name the variable for dentry before final rename 'temp' and
assign it to 'newdentry' only after rename.

Also lookup upper dentry before looking up temp dentry and
move ovl_set_timestamps() into ovl_copy_up_locked(), because
that is going to be more convenient for upcoming change.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 42f269b925405d9dd45014823e5057786d6ca452)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/copy_up.c
diff --cc fs/overlayfs/copy_up.c
index 6e96b99a973d,01e332725e94..000000000000
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@@ -272,16 -239,17 +273,15 @@@ static int ovl_copy_up_locked(struct de
  	struct inode *udir = upperdir->d_inode;
  	struct dentry *newdentry = NULL;
  	struct dentry *upper = NULL;
++<<<<<<< HEAD
 +	umode_t mode = stat->mode;
++=======
+ 	struct dentry *temp = NULL;
++>>>>>>> 42f269b92540 (ovl: rearrange code in ovl_copy_up_locked())
  	int err;
  	const struct cred *old_creds = NULL;
  	struct cred *new_creds = NULL;
 -	struct cattr cattr = {
 -		/* Can't properly set mode on creation because of the umask */
 -		.mode = stat->mode & S_IFMT,
 -		.rdev = stat->rdev,
 -		.link = link
 -	};
  
- 	newdentry = ovl_lookup_temp(workdir, dentry);
- 	err = PTR_ERR(newdentry);
- 	if (IS_ERR(newdentry))
- 		goto out;
- 
  	upper = lookup_one_len(dentry->d_name.name, upperdir,
  			       dentry->d_name.len);
  	err = PTR_ERR(upper);
@@@ -295,10 -263,12 +295,19 @@@
  	if (new_creds)
  		old_creds = override_creds(new_creds);
  
++<<<<<<< HEAD
 +	/* Can't properly set mode on creation because of the umask */
 +	stat->mode &= S_IFMT;
 +	err = ovl_create_real(wdir, newdentry, stat, link, NULL, true);
 +	stat->mode = mode;
++=======
+ 	temp = ovl_lookup_temp(workdir, dentry);
+ 	err = PTR_ERR(temp);
+ 	if (IS_ERR(temp))
+ 		goto out1;
+ 
+ 	err = ovl_create_real(wdir, temp, &cattr, NULL, true);
++>>>>>>> 42f269b92540 (ovl: rearrange code in ovl_copy_up_locked())
  
  	if (new_creds) {
  		revert_creds(old_creds);
@@@ -324,9 -294,9 +333,15 @@@
  	if (err)
  		goto out_cleanup;
  
++<<<<<<< HEAD
 +	mutex_lock(&newdentry->d_inode->i_mutex);
 +	err = ovl_set_attr(newdentry, stat);
 +	mutex_unlock(&newdentry->d_inode->i_mutex);
++=======
+ 	inode_lock(temp->d_inode);
+ 	err = ovl_set_attr(temp, stat);
+ 	inode_unlock(temp->d_inode);
++>>>>>>> 42f269b92540 (ovl: rearrange code in ovl_copy_up_locked())
  	if (err)
  		goto out_cleanup;
  
@@@ -334,19 -304,16 +349,26 @@@
  	if (err)
  		goto out_cleanup;
  
+ 	newdentry = dget(temp);
  	ovl_dentry_update(dentry, newdentry);
  	ovl_inode_update(d_inode(dentry), d_inode(newdentry));
++<<<<<<< HEAD
 +	newdentry = NULL;
 +
 +	/*
 +	 * Non-directores become opaque when copied up.
 +	 */
 +	if (!S_ISDIR(stat->mode))
 +		ovl_dentry_set_opaque(dentry, true);
++=======
+ 
+ 	/* Restore timestamps on parent (best effort) */
+ 	ovl_set_timestamps(upperdir, pstat);
++>>>>>>> 42f269b92540 (ovl: rearrange code in ovl_copy_up_locked())
  out2:
- 	dput(upper);
+ 	dput(temp);
  out1:
- 	dput(newdentry);
+ 	dput(upper);
  out:
  	return err;
  
@@@ -412,16 -373,10 +434,12 @@@ static int ovl_copy_up_one(struct dentr
  	}
  
  	err = ovl_copy_up_locked(workdir, upperdir, dentry, lowerpath,
- 				 stat, link);
- 	if (!err) {
- 		/* Restore timestamps on parent (best effort) */
- 		ovl_set_timestamps(upperdir, &pstat);
- 	}
+ 				 stat, link, &pstat);
  out_unlock:
  	unlock_rename(workdir, upperdir);
 -	do_delayed_call(&done);
 +
 +	if (link)
 +		free_page((unsigned long) link);
  
  	return err;
  }
* Unmerged path fs/overlayfs/copy_up.c
