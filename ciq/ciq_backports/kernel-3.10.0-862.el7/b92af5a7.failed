net/mlx5: Fix creating a new FTE when an existing but full FTE exists

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Fix creating a new FTE when an existing but full FTE exists (Kamal Heib) [1456687 1456694]
Rebuild_FUZZ: 97.01%
commit-author Matan Barak <matanb@mellanox.com>
commit b92af5a72ca982f0aa3df22f57a178aa5b0f4357
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b92af5a7.failed

Currently, when a flow steering rule is added, we look for a FTE with
an identical value. If we find a match, we try to merge the required
destinations with the existing ones. In a case where the existing
destination list is full, the code should return an error to its
consumer. However, the current code just tries to create another FTE.
Fixing that by returning an error in this special scenario.

Fixes: f478be79a22e ("net/mlx5: Add hash table for flow groups in flow table")
	Signed-off-by: Matan Barak <matanb@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit b92af5a72ca982f0aa3df22f57a178aa5b0f4357)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
index bdd564dcef53,6ffe9251bf62..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
@@@ -1350,6 -1442,98 +1350,101 @@@ static bool dest_is_valid(struct mlx5_f
  }
  
  static struct mlx5_flow_handle *
++<<<<<<< HEAD
++=======
+ try_add_to_existing_fg(struct mlx5_flow_table *ft,
+ 		       struct mlx5_flow_spec *spec,
+ 		       struct mlx5_flow_act *flow_act,
+ 		       struct mlx5_flow_destination *dest,
+ 		       int dest_num)
+ {
+ 	struct mlx5_flow_group *g;
+ 	struct mlx5_flow_handle *rule;
+ 	struct rhlist_head *tmp, *list;
+ 	struct match_list {
+ 		struct list_head	list;
+ 		struct mlx5_flow_group *g;
+ 	} match_list, *iter;
+ 	LIST_HEAD(match_head);
+ 
+ 	rcu_read_lock();
+ 	/* Collect all fgs which has a matching match_criteria */
+ 	list = rhltable_lookup(&ft->fgs_hash, spec, rhash_fg);
+ 	rhl_for_each_entry_rcu(g, tmp, list, hash) {
+ 		struct match_list *curr_match;
+ 
+ 		if (likely(list_empty(&match_head))) {
+ 			match_list.g = g;
+ 			list_add_tail(&match_list.list, &match_head);
+ 			continue;
+ 		}
+ 		curr_match = kmalloc(sizeof(*curr_match), GFP_ATOMIC);
+ 
+ 		if (!curr_match) {
+ 			rcu_read_unlock();
+ 			rule = ERR_PTR(-ENOMEM);
+ 			goto free_list;
+ 		}
+ 		curr_match->g = g;
+ 		list_add_tail(&curr_match->list, &match_head);
+ 	}
+ 	rcu_read_unlock();
+ 
+ 	/* Try to find a fg that already contains a matching fte */
+ 	list_for_each_entry(iter, &match_head, list) {
+ 		struct fs_fte *fte;
+ 
+ 		g = iter->g;
+ 		nested_lock_ref_node(&g->node, FS_MUTEX_PARENT);
+ 		fte = rhashtable_lookup_fast(&g->ftes_hash, spec->match_value,
+ 					     rhash_fte);
+ 		if (fte) {
+ 			rule = add_rule_fg(g, spec->match_value,
+ 					   flow_act, dest, dest_num, fte);
+ 			unlock_ref_node(&g->node);
+ 			goto free_list;
+ 		}
+ 		unlock_ref_node(&g->node);
+ 	}
+ 
+ 	/* No group with matching fte found. Try to add a new fte to any
+ 	 * matching fg.
+ 	 */
+ 	list_for_each_entry(iter, &match_head, list) {
+ 		g = iter->g;
+ 
+ 		nested_lock_ref_node(&g->node, FS_MUTEX_PARENT);
+ 		rule = add_rule_fg(g, spec->match_value,
+ 				   flow_act, dest, dest_num, NULL);
+ 		if (!IS_ERR(rule) || PTR_ERR(rule) != -ENOSPC) {
+ 			unlock_ref_node(&g->node);
+ 			goto free_list;
+ 		}
+ 		unlock_ref_node(&g->node);
+ 	}
+ 
+ 	rule = ERR_PTR(-ENOENT);
+ 
+ free_list:
+ 	if (!list_empty(&match_head)) {
+ 		struct match_list *match_tmp;
+ 
+ 		/* The most common case is having one FG. Since we want to
+ 		 * optimize this case, we save the first on the stack.
+ 		 * Therefore, no need to free it.
+ 		 */
+ 		list_del(&list_first_entry(&match_head, typeof(*iter), list)->list);
+ 		list_for_each_entry_safe(iter, match_tmp, &match_head, list) {
+ 			list_del(&iter->list);
+ 			kfree(iter);
+ 		}
+ 	}
+ 
+ 	return rule;
+ }
+ 
+ static struct mlx5_flow_handle *
++>>>>>>> b92af5a72ca9 (net/mlx5: Fix creating a new FTE when an existing but full FTE exists)
  _mlx5_add_flow_rules(struct mlx5_flow_table *ft,
  		     struct mlx5_flow_spec *spec,
  		     struct mlx5_flow_act *flow_act,
@@@ -1367,16 -1554,9 +1462,22 @@@
  	}
  
  	nested_lock_ref_node(&ft->node, FS_MUTEX_GRANDPARENT);
++<<<<<<< HEAD
 +	fs_for_each_fg(g, ft)
 +		if (compare_match_criteria(g->mask.match_criteria_enable,
 +					   spec->match_criteria_enable,
 +					   g->mask.match_criteria,
 +					   spec->match_criteria)) {
 +			rule = add_rule_fg(g, spec->match_value,
 +					   flow_act, dest, dest_num);
 +			if (!IS_ERR(rule) || PTR_ERR(rule) != -ENOSPC)
 +				goto unlock;
 +		}
++=======
+ 	rule = try_add_to_existing_fg(ft, spec, flow_act, dest, dest_num);
+ 	if (!IS_ERR(rule) || PTR_ERR(rule) != -ENOENT)
+ 		goto unlock;
++>>>>>>> b92af5a72ca9 (net/mlx5: Fix creating a new FTE when an existing but full FTE exists)
  
  	g = create_autogroup(ft, spec->match_criteria_enable,
  			     spec->match_criteria);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
