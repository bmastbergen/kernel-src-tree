tpm: infrastructure for TPM spaces

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
commit 745b361e989af21ad40811c2586b60229f870a68
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/745b361e.failed

Added an ability to virtualize TPM commands into an isolated context
that we call a TPM space because the word context is already heavily
used in the TPM specification. Both the handle areas and bodies (where
necessary) are virtualized.

The mechanism works by adding a new parameter struct tpm_space to the
tpm_transmit() function. This new structure contains the list of virtual
handles and a buffer of page size (currently) for backing storage.

When tpm_transmit() is called with a struct tpm_space instance it will
execute the following sequence:

1. Take locks.
2. Load transient objects from the backing storage by using ContextLoad
   and map virtual handles to physical handles.
3. Perform the transaction.
4. Save transient objects to backing storage by using ContextSave and
   map resulting physical handle to virtual handle if there is such.

This commit does not implement virtualization support for hmac and
policy sessions.

	Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Tested-by: James Bottomley <James.Bottomley@HansenPartnership.com>
	Reviewed-by: James Bottomley <James.Bottomley@HansenPartnership.com>
(cherry picked from commit 745b361e989af21ad40811c2586b60229f870a68)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/tpm/tpm-chip.c
#	drivers/char/tpm/tpm-interface.c
#	drivers/char/tpm/tpm.h
#	drivers/char/tpm/tpm2-cmd.c
diff --cc drivers/char/tpm/tpm-chip.c
index d2e9a9450e38,993b9ae42876..000000000000
--- a/drivers/char/tpm/tpm-chip.c
+++ b/drivers/char/tpm/tpm-chip.c
@@@ -189,7 -190,12 +190,16 @@@ struct tpm_chip *tpm_chip_alloc(struct 
  	chip->cdev.owner = THIS_MODULE;
  	chip->cdev.kobj.parent = &chip->dev.kobj;
  
++<<<<<<< HEAD
 +	chip->locality = -1;
++=======
+ 	chip->work_space.context_buf = kzalloc(PAGE_SIZE, GFP_KERNEL);
+ 	if (!chip->work_space.context_buf) {
+ 		rc = -ENOMEM;
+ 		goto out;
+ 	}
+ 
++>>>>>>> 745b361e989a (tpm: infrastructure for TPM spaces)
  	return chip;
  
  out:
diff --cc drivers/char/tpm/tpm-interface.c
index c404cae70910,d09cf26365c3..000000000000
--- a/drivers/char/tpm/tpm-interface.c
+++ b/drivers/char/tpm/tpm-interface.c
@@@ -328,6 -328,47 +328,50 @@@ unsigned long tpm_calc_ordinal_duration
  }
  EXPORT_SYMBOL_GPL(tpm_calc_ordinal_duration);
  
++<<<<<<< HEAD
++=======
+ static bool tpm_validate_command(struct tpm_chip *chip,
+ 				 struct tpm_space *space,
+ 				 const u8 *cmd,
+ 				 size_t len)
+ {
+ 	const struct tpm_input_header *header = (const void *)cmd;
+ 	int i;
+ 	u32 cc;
+ 	u32 attrs;
+ 	unsigned int nr_handles;
+ 
+ 	if (len < TPM_HEADER_SIZE)
+ 		return false;
+ 
+ 	if (!space)
+ 		return true;
+ 
+ 	if (chip->flags & TPM_CHIP_FLAG_TPM2 && chip->nr_commands) {
+ 		cc = be32_to_cpu(header->ordinal);
+ 
+ 		i = tpm2_find_cc(chip, cc);
+ 		if (i < 0) {
+ 			dev_dbg(&chip->dev, "0x%04X is an invalid command\n",
+ 				cc);
+ 			return false;
+ 		}
+ 
+ 		attrs = chip->cc_attrs_tbl[i];
+ 		nr_handles =
+ 			4 * ((attrs >> TPM2_CC_ATTR_CHANDLES) & GENMASK(2, 0));
+ 		if (len < TPM_HEADER_SIZE + 4 * nr_handles)
+ 			goto err_len;
+ 	}
+ 
+ 	return true;
+ err_len:
+ 	dev_dbg(&chip->dev,
+ 		"%s: insufficient command length %zu", __func__, len);
+ 	return false;
+ }
+ 
++>>>>>>> 745b361e989a (tpm: infrastructure for TPM spaces)
  /**
   * tmp_transmit - Internal kernel interface to transmit TPM commands.
   *
@@@ -340,16 -381,16 +384,21 @@@
   *     0 when the operation is successful.
   *     A negative number for system errors (errno).
   */
- ssize_t tpm_transmit(struct tpm_chip *chip, const u8 *buf, size_t bufsiz,
- 		     unsigned int flags)
+ ssize_t tpm_transmit(struct tpm_chip *chip, struct tpm_space *space,
+ 		     u8 *buf, size_t bufsiz, unsigned int flags)
  {
- 	const struct tpm_output_header *header = (void *)buf;
- 	ssize_t rc;
+ 	struct tpm_output_header *header = (void *)buf;
+ 	int rc;
+ 	ssize_t len = 0;
  	u32 count, ordinal;
  	unsigned long stop;
 +	bool need_locality;
  
++<<<<<<< HEAD
 +	if (bufsiz < TPM_HEADER_SIZE)
++=======
+ 	if (!tpm_validate_command(chip, space, buf, bufsiz))
++>>>>>>> 745b361e989a (tpm: infrastructure for TPM spaces)
  		return -EINVAL;
  
  	if (bufsiz > TPM_BUFSIZE)
@@@ -371,15 -412,9 +420,21 @@@
  	if (chip->dev.parent)
  		pm_runtime_get_sync(chip->dev.parent);
  
++<<<<<<< HEAD
 +	/* Store the decision as chip->locality will be changed. */
 +	need_locality = chip->locality == -1;
 +
 +	if (need_locality && chip->ops->request_locality)  {
 +		rc = chip->ops->request_locality(chip, 0);
 +		if (rc < 0)
 +			goto out_no_locality;
 +		chip->locality = rc;
 +	}
++=======
+ 	rc = tpm2_prepare_space(chip, space, ordinal, buf);
+ 	if (rc)
+ 		goto out;
++>>>>>>> 745b361e989a (tpm: infrastructure for TPM spaces)
  
  	rc = chip->ops->send(chip, (u8 *) buf, count);
  	if (rc < 0) {
@@@ -427,15 -463,14 +483,19 @@@ out_recv
  		goto out;
  	}
  
- 	if (rc != be32_to_cpu(header->length))
+ 	if (len != be32_to_cpu(header->length)) {
+ 		rc = -EFAULT;
  		goto out;
+ 	}
+ 
+ 	rc = tpm2_commit_space(chip, space, ordinal, buf, &len);
  
  out:
 +	if (need_locality && chip->ops->relinquish_locality) {
 +		chip->ops->relinquish_locality(chip, chip->locality);
 +		chip->locality = -1;
 +	}
 +out_no_locality:
  	if (chip->dev.parent)
  		pm_runtime_put_sync(chip->dev.parent);
  
diff --cc drivers/char/tpm/tpm.h
index c039c6d97636,023fc02ad0f6..000000000000
--- a/drivers/char/tpm/tpm.h
+++ b/drivers/char/tpm/tpm.h
@@@ -114,6 -117,8 +117,11 @@@ enum tpm2_command_codes 
  	TPM2_CC_CREATE		= 0x0153,
  	TPM2_CC_LOAD		= 0x0157,
  	TPM2_CC_UNSEAL		= 0x015E,
++<<<<<<< HEAD
++=======
+ 	TPM2_CC_CONTEXT_LOAD	= 0x0161,
+ 	TPM2_CC_CONTEXT_SAVE	= 0x0162,
++>>>>>>> 745b361e989a (tpm: infrastructure for TPM spaces)
  	TPM2_CC_FLUSH_CONTEXT	= 0x0165,
  	TPM2_CC_GET_CAPABILITY	= 0x017A,
  	TPM2_CC_GET_RANDOM	= 0x017B,
@@@ -127,6 -132,8 +135,11 @@@ enum tpm2_permanent_handles 
  };
  
  enum tpm2_capabilities {
++<<<<<<< HEAD
++=======
+ 	TPM2_CAP_HANDLES	= 1,
+ 	TPM2_CAP_COMMANDS	= 2,
++>>>>>>> 745b361e989a (tpm: infrastructure for TPM spaces)
  	TPM2_CAP_PCRS		= 5,
  	TPM2_CAP_TPM_PROPERTIES = 6,
  };
@@@ -200,8 -221,9 +218,14 @@@ struct tpm_chip 
  	char ppi_version[TPM_PPI_VERSION_LEN + 1];
  #endif /* CONFIG_ACPI */
  
++<<<<<<< HEAD
 +	/* active locality */
 +	int locality;
++=======
+ 	struct tpm_space work_space;
+ 	u32 nr_commands;
+ 	u32 *cc_attrs_tbl;
++>>>>>>> 745b361e989a (tpm: infrastructure for TPM spaces)
  };
  
  #define to_tpm_chip(d) container_of(d, struct tpm_chip, dev)
@@@ -553,5 -582,11 +578,15 @@@ int tpm2_auto_startup(struct tpm_chip *
  void tpm2_shutdown(struct tpm_chip *chip, u16 shutdown_type);
  unsigned long tpm2_calc_ordinal_duration(struct tpm_chip *chip, u32 ordinal);
  int tpm2_probe(struct tpm_chip *chip);
++<<<<<<< HEAD
 +ssize_t tpm2_get_pcr_allocation(struct tpm_chip *chip);
++=======
+ int tpm2_find_cc(struct tpm_chip *chip, u32 cc);
+ int tpm2_init_space(struct tpm_space *space);
+ void tpm2_del_space(struct tpm_space *space);
+ int tpm2_prepare_space(struct tpm_chip *chip, struct tpm_space *space, u32 cc,
+ 		       u8 *cmd);
+ int tpm2_commit_space(struct tpm_chip *chip, struct tpm_space *space,
+ 		      u32 cc, u8 *buf, size_t *bufsiz);
++>>>>>>> 745b361e989a (tpm: infrastructure for TPM spaces)
  #endif
diff --cc drivers/char/tpm/tpm2-cmd.c
index bab83b23d39b,3ee6883f26c1..000000000000
--- a/drivers/char/tpm/tpm2-cmd.c
+++ b/drivers/char/tpm/tpm2-cmd.c
@@@ -313,27 -294,50 +313,58 @@@ static const struct tpm_input_header tp
   *
   * Return: Same as with tpm_transmit_cmd.
   */
 -int tpm2_pcr_extend(struct tpm_chip *chip, int pcr_idx, u32 count,
 -		    struct tpm2_digest *digests)
 +int tpm2_pcr_extend(struct tpm_chip *chip, int pcr_idx, const u8 *hash)
  {
 -	struct tpm_buf buf;
 -	struct tpm2_null_auth_area auth_area;
 +	struct tpm2_cmd cmd;
  	int rc;
 -	int i;
 -	int j;
 -
 -	if (count > ARRAY_SIZE(chip->active_banks))
 -		return -EINVAL;
  
 +	cmd.header.in = tpm2_pcrextend_header;
 +	cmd.params.pcrextend_in.pcr_idx = cpu_to_be32(pcr_idx);
 +	cmd.params.pcrextend_in.auth_area_size =
 +		cpu_to_be32(sizeof(struct tpm2_null_auth_area));
 +	cmd.params.pcrextend_in.auth_area.handle =
 +		cpu_to_be32(TPM2_RS_PW);
 +	cmd.params.pcrextend_in.auth_area.nonce_size = 0;
 +	cmd.params.pcrextend_in.auth_area.attributes = 0;
 +	cmd.params.pcrextend_in.auth_area.auth_size = 0;
 +	cmd.params.pcrextend_in.digest_cnt = cpu_to_be32(1);
 +	cmd.params.pcrextend_in.hash_alg = cpu_to_be16(TPM2_ALG_SHA1);
 +	memcpy(cmd.params.pcrextend_in.digest, hash, TPM_DIGEST_SIZE);
 +
++<<<<<<< HEAD
 +	rc = tpm_transmit_cmd(chip, &cmd, sizeof(cmd), 0, 0,
++=======
+ 	rc = tpm_buf_init(&buf, TPM2_ST_SESSIONS, TPM2_CC_PCR_EXTEND);
+ 	if (rc)
+ 		return rc;
+ 
+ 	tpm_buf_append_u32(&buf, pcr_idx);
+ 
+ 	auth_area.handle = cpu_to_be32(TPM2_RS_PW);
+ 	auth_area.nonce_size = 0;
+ 	auth_area.attributes = 0;
+ 	auth_area.auth_size = 0;
+ 
+ 	tpm_buf_append_u32(&buf, sizeof(struct tpm2_null_auth_area));
+ 	tpm_buf_append(&buf, (const unsigned char *)&auth_area,
+ 		       sizeof(auth_area));
+ 	tpm_buf_append_u32(&buf, count);
+ 
+ 	for (i = 0; i < count; i++) {
+ 		for (j = 0; j < ARRAY_SIZE(tpm2_hash_map); j++) {
+ 			if (digests[i].alg_id != tpm2_hash_map[j].tpm_id)
+ 				continue;
+ 			tpm_buf_append_u16(&buf, digests[i].alg_id);
+ 			tpm_buf_append(&buf, (const unsigned char
+ 					      *)&digests[i].digest,
+ 			       hash_digest_size[tpm2_hash_map[j].crypto_id]);
+ 		}
+ 	}
+ 
+ 	rc = tpm_transmit_cmd(chip, NULL, buf.data, PAGE_SIZE, 0, 0,
++>>>>>>> 745b361e989a (tpm: infrastructure for TPM spaces)
  			      "attempting extend a PCR value");
  
 -	tpm_buf_destroy(&buf);
 -
  	return rc;
  }
  
@@@ -1103,3 -1063,123 +1135,126 @@@ out
  
  	return rc;
  }
++<<<<<<< HEAD
++=======
+ 
+ static int tpm2_get_cc_attrs_tbl(struct tpm_chip *chip)
+ {
+ 	struct tpm_buf buf;
+ 	u32 nr_commands;
+ 	u32 *attrs;
+ 	u32 cc;
+ 	int i;
+ 	int rc;
+ 
+ 	rc = tpm2_get_tpm_pt(chip, TPM_PT_TOTAL_COMMANDS, &nr_commands, NULL);
+ 	if (rc)
+ 		goto out;
+ 
+ 	if (nr_commands > 0xFFFFF) {
+ 		rc = -EFAULT;
+ 		goto out;
+ 	}
+ 
+ 	chip->cc_attrs_tbl = devm_kzalloc(&chip->dev, 4 * nr_commands,
+ 					  GFP_KERNEL);
+ 
+ 	rc = tpm_buf_init(&buf, TPM2_ST_NO_SESSIONS, TPM2_CC_GET_CAPABILITY);
+ 	if (rc)
+ 		goto out;
+ 
+ 	tpm_buf_append_u32(&buf, TPM2_CAP_COMMANDS);
+ 	tpm_buf_append_u32(&buf, TPM2_CC_FIRST);
+ 	tpm_buf_append_u32(&buf, nr_commands);
+ 
+ 	rc = tpm_transmit_cmd(chip, NULL, buf.data, PAGE_SIZE,
+ 			      9 + 4 * nr_commands, 0, NULL);
+ 	if (rc) {
+ 		tpm_buf_destroy(&buf);
+ 		goto out;
+ 	}
+ 
+ 	if (nr_commands !=
+ 	    be32_to_cpup((__be32 *)&buf.data[TPM_HEADER_SIZE + 5])) {
+ 		tpm_buf_destroy(&buf);
+ 		goto out;
+ 	}
+ 
+ 	chip->nr_commands = nr_commands;
+ 
+ 	attrs = (u32 *)&buf.data[TPM_HEADER_SIZE + 9];
+ 	for (i = 0; i < nr_commands; i++, attrs++) {
+ 		chip->cc_attrs_tbl[i] = be32_to_cpup(attrs);
+ 		cc = chip->cc_attrs_tbl[i] & 0xFFFF;
+ 
+ 		if (cc == TPM2_CC_CONTEXT_SAVE || cc == TPM2_CC_FLUSH_CONTEXT) {
+ 			chip->cc_attrs_tbl[i] &=
+ 				~(GENMASK(2, 0) << TPM2_CC_ATTR_CHANDLES);
+ 			chip->cc_attrs_tbl[i] |= 1 << TPM2_CC_ATTR_CHANDLES;
+ 		}
+ 	}
+ 
+ 	tpm_buf_destroy(&buf);
+ 
+ out:
+ 	if (rc > 0)
+ 		rc = -ENODEV;
+ 	return rc;
+ }
+ 
+ /**
+  * tpm2_auto_startup - Perform the standard automatic TPM initialization
+  *                     sequence
+  * @chip: TPM chip to use
+  *
+  * Returns 0 on success, < 0 in case of fatal error.
+  */
+ int tpm2_auto_startup(struct tpm_chip *chip)
+ {
+ 	int rc;
+ 
+ 	rc = tpm_get_timeouts(chip);
+ 	if (rc)
+ 		goto out;
+ 
+ 	rc = tpm2_do_selftest(chip);
+ 	if (rc != 0 && rc != TPM2_RC_INITIALIZE) {
+ 		dev_err(&chip->dev, "TPM self test failed\n");
+ 		goto out;
+ 	}
+ 
+ 	if (rc == TPM2_RC_INITIALIZE) {
+ 		rc = tpm2_startup(chip, TPM2_SU_CLEAR);
+ 		if (rc)
+ 			goto out;
+ 
+ 		rc = tpm2_do_selftest(chip);
+ 		if (rc) {
+ 			dev_err(&chip->dev, "TPM self test failed\n");
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	rc = tpm2_get_pcr_allocation(chip);
+ 	if (rc)
+ 		goto out;
+ 
+ 	rc = tpm2_get_cc_attrs_tbl(chip);
+ 
+ out:
+ 	if (rc > 0)
+ 		rc = -ENODEV;
+ 	return rc;
+ }
+ 
+ int tpm2_find_cc(struct tpm_chip *chip, u32 cc)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < chip->nr_commands; i++)
+ 		if (cc == (chip->cc_attrs_tbl[i] & GENMASK(15, 0)))
+ 			return i;
+ 
+ 	return -1;
+ }
++>>>>>>> 745b361e989a (tpm: infrastructure for TPM spaces)
diff --git a/drivers/char/tpm/Makefile b/drivers/char/tpm/Makefile
index 3d386a8c579f..8f07fcfbcdfb 100644
--- a/drivers/char/tpm/Makefile
+++ b/drivers/char/tpm/Makefile
@@ -3,7 +3,7 @@
 #
 obj-$(CONFIG_TCG_TPM) += tpm.o
 tpm-y := tpm-interface.o tpm-dev.o tpm-sysfs.o tpm-chip.o tpm2-cmd.o \
-		tpm1_eventlog.o tpm2_eventlog.o
+	 tpm1_eventlog.o tpm2_eventlog.o tpm2-space.o
 tpm-$(CONFIG_ACPI) += tpm_ppi.o tpm_acpi.o
 tpm-$(CONFIG_OF) += tpm_of.o
 obj-$(CONFIG_TCG_TIS_CORE) += tpm_tis_core.o
* Unmerged path drivers/char/tpm/tpm-chip.c
diff --git a/drivers/char/tpm/tpm-dev.c b/drivers/char/tpm/tpm-dev.c
index 02a8850d3a69..414553bc115b 100644
--- a/drivers/char/tpm/tpm-dev.c
+++ b/drivers/char/tpm/tpm-dev.c
@@ -147,7 +147,7 @@ static ssize_t tpm_write(struct file *file, const char __user *buf,
 		mutex_unlock(&priv->buffer_mutex);
 		return -EPIPE;
 	}
-	out_size = tpm_transmit(priv->chip, priv->data_buffer,
+	out_size = tpm_transmit(priv->chip, NULL, priv->data_buffer,
 				sizeof(priv->data_buffer), 0);
 
 	tpm_put_ops(priv->chip);
* Unmerged path drivers/char/tpm/tpm-interface.c
diff --git a/drivers/char/tpm/tpm-sysfs.c b/drivers/char/tpm/tpm-sysfs.c
index 2f596d74f80c..55405dbe43fa 100644
--- a/drivers/char/tpm/tpm-sysfs.c
+++ b/drivers/char/tpm/tpm-sysfs.c
@@ -40,7 +40,7 @@ static ssize_t pubek_show(struct device *dev, struct device_attribute *attr,
 	struct tpm_chip *chip = to_tpm_chip(dev);
 
 	tpm_cmd.header.in = tpm_readpubek_header;
-	err = tpm_transmit_cmd(chip, &tpm_cmd, READ_PUBEK_RESULT_SIZE,
+	err = tpm_transmit_cmd(chip, NULL, &tpm_cmd, READ_PUBEK_RESULT_SIZE,
 			       READ_PUBEK_RESULT_MIN_BODY_SIZE, 0,
 			       "attempting to read the PUBEK");
 	if (err)
* Unmerged path drivers/char/tpm/tpm.h
* Unmerged path drivers/char/tpm/tpm2-cmd.c
diff --git a/drivers/char/tpm/tpm2-space.c b/drivers/char/tpm/tpm2-space.c
new file mode 100644
index 000000000000..e955548dbeed
--- /dev/null
+++ b/drivers/char/tpm/tpm2-space.c
@@ -0,0 +1,431 @@
+/*
+ * Copyright (C) 2016 Intel Corporation
+ *
+ * Authors:
+ * Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
+ *
+ * Maintained by: <tpmdd-devel@lists.sourceforge.net>
+ *
+ * This file contains TPM2 protocol implementations of the commands
+ * used by the kernel internally.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#include <linux/gfp.h>
+#include <asm/unaligned.h>
+#include "tpm.h"
+
+enum tpm2_handle_types {
+	TPM2_HT_HMAC_SESSION	= 0x02000000,
+	TPM2_HT_POLICY_SESSION	= 0x03000000,
+	TPM2_HT_TRANSIENT	= 0x80000000,
+};
+
+struct tpm2_context {
+	__be64 sequence;
+	__be32 saved_handle;
+	__be32 hierarchy;
+	__be16 blob_size;
+} __packed;
+
+int tpm2_init_space(struct tpm_space *space)
+{
+	space->context_buf = kzalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!space->context_buf)
+		return -ENOMEM;
+
+	return 0;
+}
+
+void tpm2_del_space(struct tpm_space *space)
+{
+	kfree(space->context_buf);
+}
+
+static int tpm2_load_context(struct tpm_chip *chip, u8 *buf,
+			     unsigned int *offset, u32 *handle)
+{
+	struct tpm_buf tbuf;
+	struct tpm2_context *ctx;
+	unsigned int body_size;
+	int rc;
+
+	rc = tpm_buf_init(&tbuf, TPM2_ST_NO_SESSIONS, TPM2_CC_CONTEXT_LOAD);
+	if (rc)
+		return rc;
+
+	ctx = (struct tpm2_context *)&buf[*offset];
+	body_size = sizeof(*ctx) + be16_to_cpu(ctx->blob_size);
+	tpm_buf_append(&tbuf, &buf[*offset], body_size);
+
+	rc = tpm_transmit_cmd(chip, NULL, tbuf.data, PAGE_SIZE, 4,
+			      TPM_TRANSMIT_UNLOCKED, NULL);
+	if (rc < 0) {
+		dev_warn(&chip->dev, "%s: failed with a system error %d\n",
+			 __func__, rc);
+		tpm_buf_destroy(&tbuf);
+		return -EFAULT;
+	} else if (rc > 0) {
+		dev_warn(&chip->dev, "%s: failed with a TPM error 0x%04X\n",
+			 __func__, rc);
+		tpm_buf_destroy(&tbuf);
+		return -EFAULT;
+	}
+
+	*handle = be32_to_cpup((__be32 *)&tbuf.data[TPM_HEADER_SIZE]);
+	*offset += body_size;
+
+	tpm_buf_destroy(&tbuf);
+	return 0;
+}
+
+static int tpm2_save_context(struct tpm_chip *chip, u32 handle, u8 *buf,
+			     unsigned int buf_size, unsigned int *offset)
+{
+	struct tpm_buf tbuf;
+	unsigned int body_size;
+	int rc;
+
+	rc = tpm_buf_init(&tbuf, TPM2_ST_NO_SESSIONS, TPM2_CC_CONTEXT_SAVE);
+	if (rc)
+		return rc;
+
+	tpm_buf_append_u32(&tbuf, handle);
+
+	rc = tpm_transmit_cmd(chip, NULL, tbuf.data, PAGE_SIZE, 0,
+			      TPM_TRANSMIT_UNLOCKED, NULL);
+	if (rc < 0) {
+		dev_warn(&chip->dev, "%s: failed with a system error %d\n",
+			 __func__, rc);
+		tpm_buf_destroy(&tbuf);
+		return -EFAULT;
+	} else if (tpm2_rc_value(rc) == TPM2_RC_REFERENCE_H0) {
+		tpm_buf_destroy(&tbuf);
+		return -ENOENT;
+	} else if (rc) {
+		dev_warn(&chip->dev, "%s: failed with a TPM error 0x%04X\n",
+			 __func__, rc);
+		tpm_buf_destroy(&tbuf);
+		return -EFAULT;
+	}
+
+	body_size = tpm_buf_length(&tbuf) - TPM_HEADER_SIZE;
+	if ((*offset + body_size) > buf_size) {
+		dev_warn(&chip->dev, "%s: out of backing storage\n", __func__);
+		tpm_buf_destroy(&tbuf);
+		return -ENOMEM;
+	}
+
+	memcpy(&buf[*offset], &tbuf.data[TPM_HEADER_SIZE], body_size);
+	tpm2_flush_context_cmd(chip, handle, TPM_TRANSMIT_UNLOCKED);
+	*offset += body_size;
+	tpm_buf_destroy(&tbuf);
+	return 0;
+}
+
+static void tpm2_flush_space(struct tpm_chip *chip)
+{
+	struct tpm_space *space = &chip->work_space;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(space->context_tbl); i++)
+		if (space->context_tbl[i] && ~space->context_tbl[i])
+			tpm2_flush_context_cmd(chip, space->context_tbl[i],
+					       TPM_TRANSMIT_UNLOCKED);
+}
+
+static int tpm2_load_space(struct tpm_chip *chip)
+{
+	struct tpm_space *space = &chip->work_space;
+	unsigned int offset;
+	int i;
+	int rc;
+
+	for (i = 0, offset = 0; i < ARRAY_SIZE(space->context_tbl); i++) {
+		if (!space->context_tbl[i])
+			continue;
+
+		/* sanity check, should never happen */
+		if (~space->context_tbl[i]) {
+			dev_err(&chip->dev, "context table is inconsistent");
+			return -EFAULT;
+		}
+
+		rc = tpm2_load_context(chip, space->context_buf, &offset,
+				       &space->context_tbl[i]);
+		if (rc)
+			return rc;
+	}
+
+	return 0;
+}
+
+static bool tpm2_map_to_phandle(struct tpm_space *space, void *handle)
+{
+	u32 vhandle = be32_to_cpup((__be32 *)handle);
+	u32 phandle;
+	int i;
+
+	i = 0xFFFFFF - (vhandle & 0xFFFFFF);
+	if (i > ARRAY_SIZE(space->context_tbl) || !space->context_tbl[i])
+		return false;
+
+	phandle = space->context_tbl[i];
+	*((__be32 *)handle) = cpu_to_be32(phandle);
+	return true;
+}
+
+static int tpm2_map_command(struct tpm_chip *chip, u32 cc, u8 *cmd)
+{
+	struct tpm_space *space = &chip->work_space;
+	unsigned int nr_handles;
+	u32 attrs;
+	u32 *handle;
+	int i;
+
+	i = tpm2_find_cc(chip, cc);
+	if (i < 0)
+		return -EINVAL;
+
+	attrs = chip->cc_attrs_tbl[i];
+	nr_handles = (attrs >> TPM2_CC_ATTR_CHANDLES) & GENMASK(2, 0);
+
+	handle = (u32 *)&cmd[TPM_HEADER_SIZE];
+	for (i = 0; i < nr_handles; i++, handle++) {
+		if ((be32_to_cpu(*handle) & 0xFF000000) == TPM2_HT_TRANSIENT) {
+			if (!tpm2_map_to_phandle(space, handle))
+				return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+int tpm2_prepare_space(struct tpm_chip *chip, struct tpm_space *space, u32 cc,
+		       u8 *cmd)
+{
+	int rc;
+
+	if (!space)
+		return 0;
+
+	memcpy(&chip->work_space.context_tbl, &space->context_tbl,
+	       sizeof(space->context_tbl));
+	memcpy(chip->work_space.context_buf, space->context_buf, PAGE_SIZE);
+
+	rc = tpm2_load_space(chip);
+	if (rc) {
+		tpm2_flush_space(chip);
+		return rc;
+	}
+
+	rc = tpm2_map_command(chip, cc, cmd);
+	if (rc) {
+		tpm2_flush_space(chip);
+		return rc;
+	}
+
+	return 0;
+}
+
+static u32 tpm2_map_to_vhandle(struct tpm_space *space, u32 phandle, bool alloc)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(space->context_tbl); i++) {
+		if (alloc) {
+			if (!space->context_tbl[i]) {
+				space->context_tbl[i] = phandle;
+				break;
+			}
+		} else if (space->context_tbl[i] == phandle)
+			break;
+	}
+
+	if (i == ARRAY_SIZE(space->context_tbl))
+		return 0;
+
+	return TPM2_HT_TRANSIENT | (0xFFFFFF - i);
+}
+
+static int tpm2_map_response_header(struct tpm_chip *chip, u32 cc, u8 *rsp,
+				    size_t len)
+{
+	struct tpm_space *space = &chip->work_space;
+	struct tpm_output_header *header = (void *)rsp;
+	u32 phandle;
+	u32 phandle_type;
+	u32 vhandle;
+	u32 attrs;
+	int i;
+
+	if (be32_to_cpu(header->return_code) != TPM2_RC_SUCCESS)
+		return 0;
+
+	i = tpm2_find_cc(chip, cc);
+	/* sanity check, should never happen */
+	if (i < 0)
+		return -EFAULT;
+
+	attrs = chip->cc_attrs_tbl[i];
+	if (!((attrs >> TPM2_CC_ATTR_RHANDLE) & 1))
+		return 0;
+
+	phandle = be32_to_cpup((__be32 *)&rsp[TPM_HEADER_SIZE]);
+	phandle_type = phandle & 0xFF000000;
+
+	switch (phandle_type) {
+	case TPM2_HT_TRANSIENT:
+		vhandle = tpm2_map_to_vhandle(space, phandle, true);
+		if (!vhandle)
+			goto out_no_slots;
+
+		*(__be32 *)&rsp[TPM_HEADER_SIZE] = cpu_to_be32(vhandle);
+		break;
+	case TPM2_HT_HMAC_SESSION:
+	case TPM2_HT_POLICY_SESSION:
+		break;
+	default:
+		dev_err(&chip->dev, "%s: unknown handle 0x%08X\n",
+			__func__, phandle);
+		break;
+	};
+
+	return 0;
+out_no_slots:
+	tpm2_flush_context_cmd(chip, phandle, TPM_TRANSMIT_UNLOCKED);
+	dev_warn(&chip->dev, "%s: out of slots for 0x%08X\n", __func__,
+		 phandle);
+	return -ENOMEM;
+}
+
+struct tpm2_cap_handles {
+	u8 more_data;
+	__be32 capability;
+	__be32 count;
+	__be32 handles[];
+} __packed;
+
+static int tpm2_map_response_body(struct tpm_chip *chip, u32 cc, u8 *rsp,
+				  size_t len)
+{
+	struct tpm_space *space = &chip->work_space;
+	struct tpm_output_header *header = (void *)rsp;
+	struct tpm2_cap_handles *data;
+	u32 phandle;
+	u32 phandle_type;
+	u32 vhandle;
+	int i;
+	int j;
+
+	if (cc != TPM2_CC_GET_CAPABILITY ||
+	    be32_to_cpu(header->return_code) != TPM2_RC_SUCCESS) {
+		return 0;
+	}
+
+	if (len < TPM_HEADER_SIZE + 9)
+		return -EFAULT;
+
+	data = (void *)&rsp[TPM_HEADER_SIZE];
+	if (be32_to_cpu(data->capability) != TPM2_CAP_HANDLES)
+		return 0;
+
+	if (len != TPM_HEADER_SIZE + 9 + 4 * be32_to_cpu(data->count))
+		return -EFAULT;
+
+	for (i = 0, j = 0; i < be32_to_cpu(data->count); i++) {
+		phandle = be32_to_cpup((__be32 *)&data->handles[i]);
+		phandle_type = phandle & 0xFF000000;
+
+		switch (phandle_type) {
+		case TPM2_HT_TRANSIENT:
+			vhandle = tpm2_map_to_vhandle(space, phandle, false);
+			if (!vhandle)
+				break;
+
+			data->handles[j] = cpu_to_be32(vhandle);
+			j++;
+			break;
+		case TPM2_HT_HMAC_SESSION:
+		case TPM2_HT_POLICY_SESSION:
+			data->handles[j] = cpu_to_be32(phandle);
+			j++;
+			break;
+		default:
+			dev_err(&chip->dev, "%s: unknown handle 0x%08X\n",
+				__func__, phandle);
+			break;
+		}
+
+	}
+
+	header->length = cpu_to_be32(TPM_HEADER_SIZE + 9 + 4 * j);
+	data->count = cpu_to_be32(j);
+	return 0;
+}
+
+static int tpm2_save_space(struct tpm_chip *chip)
+{
+	struct tpm_space *space = &chip->work_space;
+	unsigned int offset;
+	int i;
+	int rc;
+
+	for (i = 0, offset = 0; i < ARRAY_SIZE(space->context_tbl); i++) {
+		if (!(space->context_tbl[i] && ~space->context_tbl[i]))
+			continue;
+
+		rc = tpm2_save_context(chip, space->context_tbl[i],
+				       space->context_buf, PAGE_SIZE,
+				       &offset);
+		if (rc == -ENOENT) {
+			space->context_tbl[i] = 0;
+			continue;
+		} else if (rc)
+			return rc;
+
+		space->context_tbl[i] = ~0;
+	}
+
+	return 0;
+}
+
+int tpm2_commit_space(struct tpm_chip *chip, struct tpm_space *space,
+		      u32 cc, u8 *buf, size_t *bufsiz)
+{
+	struct tpm_output_header *header = (void *)buf;
+	int rc;
+
+	if (!space)
+		return 0;
+
+	rc = tpm2_map_response_header(chip, cc, buf, *bufsiz);
+	if (rc) {
+		tpm2_flush_space(chip);
+		return rc;
+	}
+
+	rc = tpm2_map_response_body(chip, cc, buf, *bufsiz);
+	if (rc) {
+		tpm2_flush_space(chip);
+		return rc;
+	}
+
+	rc = tpm2_save_space(chip);
+	if (rc) {
+		tpm2_flush_space(chip);
+		return rc;
+	}
+
+	*bufsiz = be32_to_cpu(header->length);
+
+	memcpy(&space->context_tbl, &chip->work_space.context_tbl,
+	       sizeof(space->context_tbl));
+	memcpy(space->context_buf, chip->work_space.context_buf, PAGE_SIZE);
+
+	return 0;
+}
