skbedit: allow the user to specify bitmask for mark

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Antonio Quartulli <a@unstable.cc>
commit 4fe77d82ef80c77031c9c6f8554cd0dee2aa423a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4fe77d82.failed

The user may want to use only some bits of the skb mark in
his skbedit rules because the remaining part might be used by
something else.

Introduce the "mask" parameter to the skbedit actor in order
to implement such functionality.

When the mask is specified, only those bits selected by the
latter are altered really changed by the actor, while the
rest is left untouched.

	Signed-off-by: Antonio Quartulli <antonio@open-mesh.com>
	Signed-off-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4fe77d82ef80c77031c9c6f8554cd0dee2aa423a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/tc_act/tc_skbedit.h
#	include/uapi/linux/tc_act/tc_skbedit.h
#	net/sched/act_skbedit.c
diff --cc include/net/tc_act/tc_skbedit.h
index b496d5ad7d42,19cd3d345804..000000000000
--- a/include/net/tc_act/tc_skbedit.h
+++ b/include/net/tc_act/tc_skbedit.h
@@@ -23,15 -23,15 +23,25 @@@
  #include <linux/tc_act/tc_skbedit.h>
  
  struct tcf_skbedit {
++<<<<<<< HEAD
 +	struct tcf_common	common;
 +	u32			flags;
 +	u32     		priority;
 +	u32     		mark;
 +	u16			queue_mapping;
 +	/* XXX: 16-bit pad here? */
++=======
+ 	struct tc_action	common;
+ 	u32		flags;
+ 	u32		priority;
+ 	u32		mark;
+ 	u32		mask;
+ 	u16		queue_mapping;
+ 	u16		ptype;
++>>>>>>> 4fe77d82ef80 (skbedit: allow the user to specify bitmask for mark)
  };
 -#define to_skbedit(a) ((struct tcf_skbedit *)a)
 +#define to_skbedit(a) \
 +	container_of(a->priv, struct tcf_skbedit, common)
  
  /* Return true iff action is mark */
  static inline bool is_tcf_skbedit_mark(const struct tc_action *a)
diff --cc include/uapi/linux/tc_act/tc_skbedit.h
index fecb5cc48c40,2884425738ce..000000000000
--- a/include/uapi/linux/tc_act/tc_skbedit.h
+++ b/include/uapi/linux/tc_act/tc_skbedit.h
@@@ -27,6 -27,8 +27,11 @@@
  #define SKBEDIT_F_PRIORITY		0x1
  #define SKBEDIT_F_QUEUE_MAPPING		0x2
  #define SKBEDIT_F_MARK			0x4
++<<<<<<< HEAD
++=======
+ #define SKBEDIT_F_PTYPE			0x8
+ #define SKBEDIT_F_MASK			0x10
++>>>>>>> 4fe77d82ef80 (skbedit: allow the user to specify bitmask for mark)
  
  struct tc_skbedit {
  	tc_gen;
@@@ -40,6 -42,8 +45,11 @@@ enum 
  	TCA_SKBEDIT_QUEUE_MAPPING,
  	TCA_SKBEDIT_MARK,
  	TCA_SKBEDIT_PAD,
++<<<<<<< HEAD
++=======
+ 	TCA_SKBEDIT_PTYPE,
+ 	TCA_SKBEDIT_MASK,
++>>>>>>> 4fe77d82ef80 (skbedit: allow the user to specify bitmask for mark)
  	__TCA_SKBEDIT_MAX
  };
  #define TCA_SKBEDIT_MAX (__TCA_SKBEDIT_MAX - 1)
diff --cc net/sched/act_skbedit.c
index 173bfd2bb060,024f3a3afeff..000000000000
--- a/net/sched/act_skbedit.c
+++ b/net/sched/act_skbedit.c
@@@ -44,8 -46,12 +44,17 @@@ static int tcf_skbedit(struct sk_buff *
  	if (d->flags & SKBEDIT_F_QUEUE_MAPPING &&
  	    skb->dev->real_num_tx_queues > d->queue_mapping)
  		skb_set_queue_mapping(skb, d->queue_mapping);
++<<<<<<< HEAD
 +	if (d->flags & SKBEDIT_F_MARK)
 +		skb->mark = d->mark;
++=======
+ 	if (d->flags & SKBEDIT_F_MARK) {
+ 		skb->mark &= ~d->mask;
+ 		skb->mark |= d->mark & d->mask;
+ 	}
+ 	if (d->flags & SKBEDIT_F_PTYPE)
+ 		skb->pkt_type = d->ptype;
++>>>>>>> 4fe77d82ef80 (skbedit: allow the user to specify bitmask for mark)
  
  	spin_unlock(&d->tcf_lock);
  	return d->tcf_action;
@@@ -56,6 -62,8 +65,11 @@@ static const struct nla_policy skbedit_
  	[TCA_SKBEDIT_PRIORITY]		= { .len = sizeof(u32) },
  	[TCA_SKBEDIT_QUEUE_MAPPING]	= { .len = sizeof(u16) },
  	[TCA_SKBEDIT_MARK]		= { .len = sizeof(u32) },
++<<<<<<< HEAD
++=======
+ 	[TCA_SKBEDIT_PTYPE]		= { .len = sizeof(u16) },
+ 	[TCA_SKBEDIT_MASK]		= { .len = sizeof(u32) },
++>>>>>>> 4fe77d82ef80 (skbedit: allow the user to specify bitmask for mark)
  };
  
  static int tcf_skbedit_init(struct net *net, struct nlattr *nla,
@@@ -65,8 -73,10 +79,14 @@@
  	struct nlattr *tb[TCA_SKBEDIT_MAX + 1];
  	struct tc_skbedit *parm;
  	struct tcf_skbedit *d;
++<<<<<<< HEAD
 +	u32 flags = 0, *priority = NULL, *mark = NULL;
 +	u16 *queue_mapping = NULL;
++=======
+ 	u32 flags = 0, *priority = NULL, *mark = NULL, *mask = NULL;
+ 	u16 *queue_mapping = NULL, *ptype = NULL;
+ 	bool exists = false;
++>>>>>>> 4fe77d82ef80 (skbedit: allow the user to specify bitmask for mark)
  	int ret = 0, err;
  
  	if (nla == NULL)
@@@ -94,8 -111,10 +114,15 @@@
  		mark = nla_data(tb[TCA_SKBEDIT_MARK]);
  	}
  
++<<<<<<< HEAD
 +	if (!flags)
 +		return -EINVAL;
++=======
+ 	if (tb[TCA_SKBEDIT_MASK] != NULL) {
+ 		flags |= SKBEDIT_F_MASK;
+ 		mask = nla_data(tb[TCA_SKBEDIT_MASK]);
+ 	}
++>>>>>>> 4fe77d82ef80 (skbedit: allow the user to specify bitmask for mark)
  
  	parm = nla_data(tb[TCA_SKBEDIT_PARMS]);
  
@@@ -125,6 -151,12 +152,15 @@@
  		d->queue_mapping = *queue_mapping;
  	if (flags & SKBEDIT_F_MARK)
  		d->mark = *mark;
++<<<<<<< HEAD
++=======
+ 	if (flags & SKBEDIT_F_PTYPE)
+ 		d->ptype = *ptype;
+ 	/* default behaviour is to use all the bits */
+ 	d->mask = 0xffffffff;
+ 	if (flags & SKBEDIT_F_MASK)
+ 		d->mask = *mask;
++>>>>>>> 4fe77d82ef80 (skbedit: allow the user to specify bitmask for mark)
  
  	d->tcf_action = parm->action;
  
@@@ -151,17 -183,20 +187,20 @@@ static int tcf_skbedit_dump(struct sk_b
  	if (nla_put(skb, TCA_SKBEDIT_PARMS, sizeof(opt), &opt))
  		goto nla_put_failure;
  	if ((d->flags & SKBEDIT_F_PRIORITY) &&
 -	    nla_put_u32(skb, TCA_SKBEDIT_PRIORITY, d->priority))
 +	    nla_put(skb, TCA_SKBEDIT_PRIORITY, sizeof(d->priority),
 +		    &d->priority))
  		goto nla_put_failure;
  	if ((d->flags & SKBEDIT_F_QUEUE_MAPPING) &&
 -	    nla_put_u16(skb, TCA_SKBEDIT_QUEUE_MAPPING, d->queue_mapping))
 +	    nla_put(skb, TCA_SKBEDIT_QUEUE_MAPPING,
 +		    sizeof(d->queue_mapping), &d->queue_mapping))
  		goto nla_put_failure;
  	if ((d->flags & SKBEDIT_F_MARK) &&
 -	    nla_put_u32(skb, TCA_SKBEDIT_MARK, d->mark))
 -		goto nla_put_failure;
 -	if ((d->flags & SKBEDIT_F_PTYPE) &&
 -	    nla_put_u16(skb, TCA_SKBEDIT_PTYPE, d->ptype))
 +	    nla_put(skb, TCA_SKBEDIT_MARK, sizeof(d->mark),
 +		    &d->mark))
  		goto nla_put_failure;
+ 	if ((d->flags & SKBEDIT_F_MASK) &&
+ 	    nla_put_u32(skb, TCA_SKBEDIT_MASK, d->mask))
+ 		goto nla_put_failure;
  
  	tcf_tm_dump(&t, &d->tcf_tm);
  	if (nla_put_64bit(skb, TCA_SKBEDIT_TM, sizeof(t), &t, TCA_SKBEDIT_PAD))
* Unmerged path include/net/tc_act/tc_skbedit.h
* Unmerged path include/uapi/linux/tc_act/tc_skbedit.h
* Unmerged path net/sched/act_skbedit.c
