net: ena: fix bug that might cause hang after consecutive open/close interface.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] ena: fix bug that might cause hang after consecutive open/close interface (John Linville) [1478896]
Rebuild_FUZZ: 96.05%
commit-author Netanel Belgazal <netanel@amazon.com>
commit 418df30f7e9e8f4795fb2f3abf9744e5886df5ca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/418df30f.failed

Fixing a bug that the driver does not unmask the IO interrupts
in ndo_open():
occasionally, the MSI-X interrupt (for one or more IO queues)
can be masked when ndo_close() was called.
If that is followed by ndo open(),
then the MSI-X will be still masked so no interrupt
will be received by the driver.

Fixes: 1738cd3ed342 ("Add a driver for Amazon Elastic Network Adapters (ENA)")
	Signed-off-by: Netanel Belgazal <netanel@amazon.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 418df30f7e9e8f4795fb2f3abf9744e5886df5ca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/amazon/ena/ena_netdev.c
diff --cc drivers/net/ethernet/amazon/ena/ena_netdev.c
index a5df5ec54986,0e3c60c7eccf..000000000000
--- a/drivers/net/ethernet/amazon/ena/ena_netdev.c
+++ b/drivers/net/ethernet/amazon/ena/ena_netdev.c
@@@ -1137,27 -1149,28 +1156,38 @@@ static int ena_io_poll(struct napi_stru
  	tx_work_done = ena_clean_tx_irq(tx_ring, tx_budget);
  	rx_work_done = ena_clean_rx_irq(rx_ring, napi, budget);
  
 -	/* If the device is about to reset or down, avoid unmask
 -	 * the interrupt and return 0 so NAPI won't reschedule
 -	 */
 -	if (unlikely(!test_bit(ENA_FLAG_DEV_UP, &tx_ring->adapter->flags) ||
 -		     test_bit(ENA_FLAG_TRIGGER_RESET, &tx_ring->adapter->flags))) {
 -		napi_complete_done(napi, 0);
 -		ret = 0;
 +	if ((budget > rx_work_done) && (tx_budget > tx_work_done)) {
 +		napi_complete_done(napi, rx_work_done);
  
 -	} else if ((budget > rx_work_done) && (tx_budget > tx_work_done)) {
  		napi_comp_call = 1;
 +		/* Tx and Rx share the same interrupt vector */
 +		if (ena_com_get_adaptive_moderation_enabled(rx_ring->ena_dev))
 +			ena_adjust_intr_moderation(rx_ring, tx_ring);
  
 -		/* Update numa and unmask the interrupt only when schedule
 -		 * from the interrupt context (vs from sk_busy_loop)
 +		/* Update intr register: rx intr delay, tx intr delay and
 +		 * interrupt unmask
  		 */
++<<<<<<< HEAD
 +		ena_com_update_intr_reg(&intr_reg,
 +					rx_ring->smoothed_interval,
 +					tx_ring->smoothed_interval,
 +					true);
 +
 +		/* It is a shared MSI-X. Tx and Rx CQ have pointer to it.
 +		 * So we use one of them to reach the intr reg
 +		 */
 +		ena_com_unmask_intr(rx_ring->ena_com_io_cq, &intr_reg);
 +
++=======
+ 		if (napi_complete_done(napi, rx_work_done)) {
+ 			/* Tx and Rx share the same interrupt vector */
+ 			if (ena_com_get_adaptive_moderation_enabled(rx_ring->ena_dev))
+ 				ena_adjust_intr_moderation(rx_ring, tx_ring);
+ 
+ 			ena_unmask_interrupt(tx_ring, rx_ring);
+ 		}
+ 
++>>>>>>> 418df30f7e9e (net: ena: fix bug that might cause hang after consecutive open/close interface.)
  		ena_update_ring_numa_node(tx_ring, rx_ring);
  
  		ret = rx_work_done;
* Unmerged path drivers/net/ethernet/amazon/ena/ena_netdev.c
