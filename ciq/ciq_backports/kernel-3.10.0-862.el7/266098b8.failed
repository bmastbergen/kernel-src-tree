IB/core: Fix sparse warnings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Matan Barak <matanb@mellanox.com>
commit 266098b841d48f7f0db40424bdbc072e4db14e9b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/266098b8.failed

Delete unused variables to prevent sparse warnings.

Fixes: db1b5ddd5336 ("IB/core: Rename uverbs event file structure")
Fixes: fd3c7904db6e ("IB/core: Change idr objects to use the new schema")

	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 266098b841d48f7f0db40424bdbc072e4db14e9b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_cmd.c
diff --cc drivers/infiniband/core/uverbs_cmd.c
index e8bf8301dd79,71451eae42de..000000000000
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@@ -1710,37 -1296,32 +1710,43 @@@ ssize_t ib_uverbs_destroy_cq(struct ib_
  	struct ib_uobject		*uobj;
  	struct ib_cq               	*cq;
  	struct ib_ucq_object        	*obj;
++<<<<<<< HEAD
 +	struct ib_uverbs_event_file	*ev_file;
++=======
++>>>>>>> 266098b841d4 (IB/core: Fix sparse warnings)
  	int                        	 ret = -EINVAL;
  
  	if (copy_from_user(&cmd, buf, sizeof cmd))
  		return -EFAULT;
  
 -	uobj  = uobj_get_write(uobj_get_type(cq), cmd.cq_handle,
 -			       file->ucontext);
 -	if (IS_ERR(uobj))
 -		return PTR_ERR(uobj);
 -
 -	/*
 -	 * Make sure we don't free the memory in remove_commit as we still
 -	 * needs the uobject memory to create the response.
 -	 */
 -	uverbs_uobject_get(uobj);
 +	uobj = idr_write_uobj(&ib_uverbs_cq_idr, cmd.cq_handle, file->ucontext);
 +	if (!uobj)
 +		return -EINVAL;
  	cq      = uobj->object;
++<<<<<<< HEAD
 +	ev_file = cq->cq_context;
++=======
++>>>>>>> 266098b841d4 (IB/core: Fix sparse warnings)
  	obj     = container_of(cq->uobject, struct ib_ucq_object, uobject);
  
 -	memset(&resp, 0, sizeof(resp));
 +	ret = ib_destroy_cq(cq);
 +	if (!ret)
 +		uobj->live = 0;
 +
 +	put_uobj_write(uobj);
  
 -	ret = uobj_remove_commit(uobj);
 -	if (ret) {
 -		uverbs_uobject_put(uobj);
 +	if (ret)
  		return ret;
 -	}
  
 +	idr_remove_uobj(&ib_uverbs_cq_idr, uobj);
 +
 +	mutex_lock(&file->mutex);
 +	list_del(&uobj->list);
 +	mutex_unlock(&file->mutex);
 +
 +	ib_uverbs_release_ucq(file, ev_file, obj);
 +
 +	memset(&resp, 0, sizeof resp);
  	resp.comp_events_reported  = obj->comp_events_reported;
  	resp.async_events_reported = obj->async_events_reported;
  
@@@ -2520,40 -2094,26 +2525,48 @@@ ssize_t ib_uverbs_destroy_qp(struct ib_
  
  	memset(&resp, 0, sizeof resp);
  
++<<<<<<< HEAD
 +	uobj = idr_write_uobj(&ib_uverbs_qp_idr, cmd.qp_handle, file->ucontext);
 +	if (!uobj)
 +		return -EINVAL;
 +	qp  = uobj->object;
++=======
+ 	uobj  = uobj_get_write(uobj_get_type(qp), cmd.qp_handle,
+ 			       file->ucontext);
+ 	if (IS_ERR(uobj))
+ 		return PTR_ERR(uobj);
+ 
++>>>>>>> 266098b841d4 (IB/core: Fix sparse warnings)
  	obj = container_of(uobj, struct ib_uqp_object, uevent.uobject);
 -	/*
 -	 * Make sure we don't free the memory in remove_commit as we still
 -	 * needs the uobject memory to create the response.
 -	 */
 -	uverbs_uobject_get(uobj);
  
 -	ret = uobj_remove_commit(uobj);
 -	if (ret) {
 -		uverbs_uobject_put(uobj);
 -		return ret;
 +	if (!list_empty(&obj->mcast_list)) {
 +		put_uobj_write(uobj);
 +		return -EBUSY;
  	}
  
 +	ret = ib_destroy_qp(qp);
 +	if (!ret)
 +		uobj->live = 0;
 +
 +	put_uobj_write(uobj);
 +
 +	if (ret)
 +		return ret;
 +
 +	if (obj->uxrcd)
 +		atomic_dec(&obj->uxrcd->refcnt);
 +
 +	idr_remove_uobj(&ib_uverbs_qp_idr, uobj);
 +
 +	mutex_lock(&file->mutex);
 +	list_del(&uobj->list);
 +	mutex_unlock(&file->mutex);
 +
 +	ib_uverbs_release_uevent(file, &obj->uevent);
 +
  	resp.events_reported = obj->uevent.events_reported;
 -	uverbs_uobject_put(uobj);
 +
 +	put_uobj(uobj);
  
  	if (copy_to_user((void __user *) (unsigned long) cmd.response,
  			 &resp, sizeof resp))
@@@ -3491,32 -3028,21 +3503,31 @@@ int ib_uverbs_ex_destroy_wq(struct ib_u
  		return -EOPNOTSUPP;
  
  	resp.response_length = required_resp_len;
 -	uobj  = uobj_get_write(uobj_get_type(wq), cmd.wq_handle,
 -			       file->ucontext);
 -	if (IS_ERR(uobj))
 -		return PTR_ERR(uobj);
 +	uobj = idr_write_uobj(&ib_uverbs_wq_idr, cmd.wq_handle,
 +			      file->ucontext);
 +	if (!uobj)
 +		return -EINVAL;
  
- 	wq = uobj->object;
  	obj = container_of(uobj, struct ib_uwq_object, uevent.uobject);
 -	/*
 -	 * Make sure we don't free the memory in remove_commit as we still
 -	 * needs the uobject memory to create the response.
 -	 */
 -	uverbs_uobject_get(uobj);
 +	ret = ib_destroy_wq(wq);
 +	if (!ret)
 +		uobj->live = 0;
 +
 +	put_uobj_write(uobj);
 +	if (ret)
 +		return ret;
 +
 +	idr_remove_uobj(&ib_uverbs_wq_idr, uobj);
 +
 +	mutex_lock(&file->mutex);
 +	list_del(&uobj->list);
 +	mutex_unlock(&file->mutex);
  
 -	ret = uobj_remove_commit(uobj);
 +	ib_uverbs_release_uevent(file, &obj->uevent);
  	resp.events_reported = obj->uevent.events_reported;
 -	uverbs_uobject_put(uobj);
 +	put_uobj(uobj);
 +
 +	ret = ib_copy_to_udata(ucore, &resp, resp.response_length);
  	if (ret)
  		return ret;
  
@@@ -4265,54 -3722,38 +4276,70 @@@ ssize_t ib_uverbs_destroy_srq(struct ib
  	struct ib_uverbs_destroy_srq      cmd;
  	struct ib_uverbs_destroy_srq_resp resp;
  	struct ib_uobject		 *uobj;
- 	struct ib_srq               	 *srq;
  	struct ib_uevent_object        	 *obj;
  	int                         	  ret = -EINVAL;
++<<<<<<< HEAD
 +	struct ib_usrq_object		 *us;
 +	enum ib_srq_type		  srq_type;
++=======
++>>>>>>> 266098b841d4 (IB/core: Fix sparse warnings)
  
  	if (copy_from_user(&cmd, buf, sizeof cmd))
  		return -EFAULT;
  
++<<<<<<< HEAD
 +	uobj = idr_write_uobj(&ib_uverbs_srq_idr, cmd.srq_handle, file->ucontext);
 +	if (!uobj)
 +		return -EINVAL;
 +	srq = uobj->object;
 +	obj = container_of(uobj, struct ib_uevent_object, uobject);
 +	srq_type = srq->srq_type;
++=======
+ 	uobj  = uobj_get_write(uobj_get_type(srq), cmd.srq_handle,
+ 			       file->ucontext);
+ 	if (IS_ERR(uobj))
+ 		return PTR_ERR(uobj);
+ 
+ 	obj = container_of(uobj, struct ib_uevent_object, uobject);
+ 	/*
+ 	 * Make sure we don't free the memory in remove_commit as we still
+ 	 * needs the uobject memory to create the response.
+ 	 */
+ 	uverbs_uobject_get(uobj);
++>>>>>>> 266098b841d4 (IB/core: Fix sparse warnings)
  
 -	memset(&resp, 0, sizeof(resp));
 +	ret = ib_destroy_srq(srq);
 +	if (!ret)
 +		uobj->live = 0;
  
 -	ret = uobj_remove_commit(uobj);
 -	if (ret) {
 -		uverbs_uobject_put(uobj);
 +	put_uobj_write(uobj);
 +
 +	if (ret)
  		return ret;
 +
 +	if (srq_type == IB_SRQT_XRC) {
 +		us = container_of(obj, struct ib_usrq_object, uevent);
 +		atomic_dec(&us->uxrcd->refcnt);
  	}
 +
 +	idr_remove_uobj(&ib_uverbs_srq_idr, uobj);
 +
 +	mutex_lock(&file->mutex);
 +	list_del(&uobj->list);
 +	mutex_unlock(&file->mutex);
 +
 +	ib_uverbs_release_uevent(file, obj);
 +
 +	memset(&resp, 0, sizeof resp);
  	resp.events_reported = obj->events_reported;
 -	uverbs_uobject_put(uobj);
 -	if (copy_to_user((void __user *)(unsigned long)cmd.response,
 -			 &resp, sizeof(resp)))
 -		return -EFAULT;
  
 -	return in_len;
 +	put_uobj(uobj);
 +
 +	if (copy_to_user((void __user *) (unsigned long) cmd.response,
 +			 &resp, sizeof resp))
 +		ret = -EFAULT;
 +
 +	return ret ? ret : in_len;
  }
  
  int ib_uverbs_ex_query_device(struct ib_uverbs_file *file,
* Unmerged path drivers/infiniband/core/uverbs_cmd.c
