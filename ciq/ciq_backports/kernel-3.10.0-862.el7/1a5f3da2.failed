net: ethtool: add support for forward error correction modes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] ethtool: add support for forward error correction modes (Ivan Vecera) [1530634]
Rebuild_FUZZ: 95.65%
commit-author Vidya Sagar Ravipati <vidya.chowdary@gmail.com>
commit 1a5f3da20bd966220931239fbd31e6ac6ff42251
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1a5f3da2.failed

Forward Error Correction (FEC) modes i.e Base-R
and Reed-Solomon modes are introduced in 25G/40G/100G standards
for providing good BER at high speeds. Various networking devices
which support 25G/40G/100G provides ability to manage supported FEC
modes and the lack of FEC encoding control and reporting today is a
source for interoperability issues for many vendors.
FEC capability as well as specific FEC mode i.e. Base-R
or RS modes can be requested or advertised through bits D44:47 of
base link codeword.

This patch set intends to provide option under ethtool to manage
and report FEC encoding settings for networking devices as per
IEEE 802.3 bj, bm and by specs.

set-fec/show-fec option(s) are designed to provide control and
report the FEC encoding on the link.

SET FEC option:
root@tor: ethtool --set-fec  swp1 encoding [off | RS | BaseR | auto]

Encoding: Types of encoding
Off    :  Turning off any encoding
RS     :  enforcing RS-FEC encoding on supported speeds
BaseR  :  enforcing Base R encoding on supported speeds
Auto   :  IEEE defaults for the speed/medium combination

Here are a few examples of what we would expect if encoding=auto:
- if autoneg is on, we are  expecting FEC to be negotiated as on or off
  as long as protocol supports it
- if the hardware is capable of detecting the FEC encoding on it's
      receiver it will reconfigure its encoder to match
- in absence of the above, the configuration would be set to IEEE
  defaults.

>From our  understanding , this is essentially what most hardware/driver
combinations are doing today in the absence of a way for users to
control the behavior.

SHOW FEC option:
root@tor: ethtool --show-fec  swp1
FEC parameters for swp1:
Active FEC encodings: RS
Configured FEC encodings:  RS | BaseR

ETHTOOL DEVNAME output modification:

ethtool devname output:
root@tor:~# ethtool swp1
Settings for swp1:
root@hpe-7712-03:~# ethtool swp18
Settings for swp18:
    Supported ports: [ FIBRE ]
    Supported link modes:   40000baseCR4/Full
                            40000baseSR4/Full
                            40000baseLR4/Full
                            100000baseSR4/Full
                            100000baseCR4/Full
                            100000baseLR4_ER4/Full
    Supported pause frame use: No
    Supports auto-negotiation: Yes
    Supported FEC modes: [RS | BaseR | None | Not reported]
    Advertised link modes:  Not reported
    Advertised pause frame use: No
    Advertised auto-negotiation: No
    Advertised FEC modes: [RS | BaseR | None | Not reported]
<<<< One or more FEC modes
    Speed: 100000Mb/s
    Duplex: Full
    Port: FIBRE
    PHYAD: 106
    Transceiver: internal
    Auto-negotiation: off
    Link detected: yes

This patch includes following changes
a) New ETHTOOL_SFECPARAM/SFECPARAM API, handled by
  the new get_fecparam/set_fecparam callbacks, provides support
  for configuration of forward error correction modes.
b) Link mode bits for FEC modes i.e. None (No FEC mode), RS, BaseR/FC
  are defined so that users can configure these fec modes for supported
  and advertising fields as part of link autonegotiation.

	Signed-off-by: Vidya Sagar Ravipati <vidya.chowdary@gmail.com>
	Signed-off-by: Dustin Byford <dustin@cumulusnetworks.com>
	Signed-off-by: Roopa Prabhu <roopa@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1a5f3da20bd966220931239fbd31e6ac6ff42251)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/ethtool.h
#	include/uapi/linux/ethtool.h
#	net/core/ethtool.c
diff --cc include/linux/ethtool.h
index d063b8be1fdc,afdbb701fdb4..000000000000
--- a/include/linux/ethtool.h
+++ b/include/linux/ethtool.h
@@@ -364,42 -362,21 +364,61 @@@ struct ethtool_ops 
  				     struct ethtool_eeprom *, u8 *);
  	int	(*get_eee)(struct net_device *, struct ethtool_eee *);
  	int	(*set_eee)(struct net_device *, struct ethtool_eee *);
++<<<<<<< HEAD
 +
 +	/* RHEL SPECIFIC
 +	 *
 +	 * The following padding has been inserted before ABI freeze to
 +	 * allow extending the structure while preserve ABI. Feel free
 +	 * to replace reserved slots with required structure field
 +	 * additions of your backport.
 +	 */
 +	RH_KABI_USE_P(1, u32	(*get_rxfh_key_size)(struct net_device *))
 +	RH_KABI_USE_P(2, int	(*get_rxfh)(struct net_device *, u32 *indir,
 +					    u8 *key, u8 *hfunc))
 +	RH_KABI_USE_P(3, int	(*set_rxfh)(struct net_device *,
 +					    const u32 *indir, const u8 *key,
 +					    const u8 hfunc))
 +	RH_KABI_USE_P(4, int	(*get_tunable)(struct net_device *,
 +					       const struct ethtool_tunable *,
 +					       void *))
 +	RH_KABI_USE_P(5, int	(*set_tunable)(struct net_device *,
 +					       const struct ethtool_tunable *,
 +					       const void *))
 +	RH_KABI_USE_P(6, int	(*get_per_queue_coalesce)(struct net_device *,
 +							  u32,
 +							  struct ethtool_coalesce *))
 +	RH_KABI_USE_P(7, int	(*set_per_queue_coalesce)(struct net_device *,
 +							  u32,
 +							  struct ethtool_coalesce *))
 +	RH_KABI_USE_P(8, int	(*get_link_ksettings)(struct net_device *,
 +					      struct ethtool_link_ksettings *))
 +	RH_KABI_USE_P(9, int	(*set_link_ksettings)(struct net_device *,
 +				      const struct ethtool_link_ksettings *))
 +	RH_KABI_RESERVE_P(10)
 +	RH_KABI_RESERVE_P(11)
 +	RH_KABI_RESERVE_P(12)
 +	RH_KABI_RESERVE_P(13)
 +	RH_KABI_RESERVE_P(14)
 +	RH_KABI_RESERVE_P(15)
 +	RH_KABI_RESERVE_P(16)
++=======
+ 	int	(*get_tunable)(struct net_device *,
+ 			       const struct ethtool_tunable *, void *);
+ 	int	(*set_tunable)(struct net_device *,
+ 			       const struct ethtool_tunable *, const void *);
+ 	int	(*get_per_queue_coalesce)(struct net_device *, u32,
+ 					  struct ethtool_coalesce *);
+ 	int	(*set_per_queue_coalesce)(struct net_device *, u32,
+ 					  struct ethtool_coalesce *);
+ 	int	(*get_link_ksettings)(struct net_device *,
+ 				      struct ethtool_link_ksettings *);
+ 	int	(*set_link_ksettings)(struct net_device *,
+ 				      const struct ethtool_link_ksettings *);
+ 	int	(*get_fecparam)(struct net_device *,
+ 				      struct ethtool_fecparam *);
+ 	int	(*set_fecparam)(struct net_device *,
+ 				      struct ethtool_fecparam *);
++>>>>>>> 1a5f3da20bd9 (net: ethtool: add support for forward error correction modes)
  };
  #endif /* _LINUX_ETHTOOL_H */
diff --cc include/uapi/linux/ethtool.h
index 2fbc2b3a3c26,9c041dae8e2c..000000000000
--- a/include/uapi/linux/ethtool.h
+++ b/include/uapi/linux/ethtool.h
@@@ -1311,7 -1369,10 +1352,14 @@@ enum ethtool_fec_config_bits 
  
  #define ETHTOOL_GLINKSETTINGS	0x0000004c /* Get ethtool_link_settings */
  #define ETHTOOL_SLINKSETTINGS	0x0000004d /* Set ethtool_link_settings */
++<<<<<<< HEAD
 +
++=======
+ #define ETHTOOL_PHY_GTUNABLE	0x0000004e /* Get PHY tunable configuration */
+ #define ETHTOOL_PHY_STUNABLE	0x0000004f /* Set PHY tunable configuration */
+ #define ETHTOOL_GFECPARAM	0x00000050 /* Get FEC settings */
+ #define ETHTOOL_SFECPARAM	0x00000051 /* Set FEC settings */
++>>>>>>> 1a5f3da20bd9 (net: ethtool: add support for forward error correction modes)
  
  /* compatibility with older code */
  #define SPARC_ETH_GSET		ETHTOOL_GSET
diff --cc net/core/ethtool.c
index b69d0a7f5626,6a582ae4c5d9..000000000000
--- a/net/core/ethtool.c
+++ b/net/core/ethtool.c
@@@ -2365,6 -2437,108 +2365,111 @@@ static int ethtool_set_per_queue(struc
  	};
  }
  
++<<<<<<< HEAD
++=======
+ static int ethtool_phy_tunable_valid(const struct ethtool_tunable *tuna)
+ {
+ 	switch (tuna->id) {
+ 	case ETHTOOL_PHY_DOWNSHIFT:
+ 		if (tuna->len != sizeof(u8) ||
+ 		    tuna->type_id != ETHTOOL_TUNABLE_U8)
+ 			return -EINVAL;
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int get_phy_tunable(struct net_device *dev, void __user *useraddr)
+ {
+ 	int ret;
+ 	struct ethtool_tunable tuna;
+ 	struct phy_device *phydev = dev->phydev;
+ 	void *data;
+ 
+ 	if (!(phydev && phydev->drv && phydev->drv->get_tunable))
+ 		return -EOPNOTSUPP;
+ 
+ 	if (copy_from_user(&tuna, useraddr, sizeof(tuna)))
+ 		return -EFAULT;
+ 	ret = ethtool_phy_tunable_valid(&tuna);
+ 	if (ret)
+ 		return ret;
+ 	data = kmalloc(tuna.len, GFP_USER);
+ 	if (!data)
+ 		return -ENOMEM;
+ 	mutex_lock(&phydev->lock);
+ 	ret = phydev->drv->get_tunable(phydev, &tuna, data);
+ 	mutex_unlock(&phydev->lock);
+ 	if (ret)
+ 		goto out;
+ 	useraddr += sizeof(tuna);
+ 	ret = -EFAULT;
+ 	if (copy_to_user(useraddr, data, tuna.len))
+ 		goto out;
+ 	ret = 0;
+ 
+ out:
+ 	kfree(data);
+ 	return ret;
+ }
+ 
+ static int set_phy_tunable(struct net_device *dev, void __user *useraddr)
+ {
+ 	int ret;
+ 	struct ethtool_tunable tuna;
+ 	struct phy_device *phydev = dev->phydev;
+ 	void *data;
+ 
+ 	if (!(phydev && phydev->drv && phydev->drv->set_tunable))
+ 		return -EOPNOTSUPP;
+ 	if (copy_from_user(&tuna, useraddr, sizeof(tuna)))
+ 		return -EFAULT;
+ 	ret = ethtool_phy_tunable_valid(&tuna);
+ 	if (ret)
+ 		return ret;
+ 	useraddr += sizeof(tuna);
+ 	data = memdup_user(useraddr, tuna.len);
+ 	if (IS_ERR(data))
+ 		return PTR_ERR(data);
+ 	mutex_lock(&phydev->lock);
+ 	ret = phydev->drv->set_tunable(phydev, &tuna, data);
+ 	mutex_unlock(&phydev->lock);
+ 
+ 	kfree(data);
+ 	return ret;
+ }
+ 
+ static int ethtool_get_fecparam(struct net_device *dev, void __user *useraddr)
+ {
+ 	struct ethtool_fecparam fecparam = { ETHTOOL_GFECPARAM };
+ 
+ 	if (!dev->ethtool_ops->get_fecparam)
+ 		return -EOPNOTSUPP;
+ 
+ 	dev->ethtool_ops->get_fecparam(dev, &fecparam);
+ 
+ 	if (copy_to_user(useraddr, &fecparam, sizeof(fecparam)))
+ 		return -EFAULT;
+ 	return 0;
+ }
+ 
+ static int ethtool_set_fecparam(struct net_device *dev, void __user *useraddr)
+ {
+ 	struct ethtool_fecparam fecparam;
+ 
+ 	if (!dev->ethtool_ops->set_fecparam)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (copy_from_user(&fecparam, useraddr, sizeof(fecparam)))
+ 		return -EFAULT;
+ 
+ 	return dev->ethtool_ops->set_fecparam(dev, &fecparam);
+ }
+ 
++>>>>>>> 1a5f3da20bd9 (net: ethtool: add support for forward error correction modes)
  /* The main entry point in this file.  Called from net/core/dev_ioctl.c */
  
  int dev_ethtool(struct net *net, struct ifreq *ifr)
@@@ -2421,6 -2595,9 +2526,12 @@@
  	case ETHTOOL_GET_TS_INFO:
  	case ETHTOOL_GEEE:
  	case ETHTOOL_GTUNABLE:
++<<<<<<< HEAD
++=======
+ 	case ETHTOOL_PHY_GTUNABLE:
+ 	case ETHTOOL_GLINKSETTINGS:
+ 	case ETHTOOL_GFECPARAM:
++>>>>>>> 1a5f3da20bd9 (net: ethtool: add support for forward error correction modes)
  		break;
  	default:
  		if (!ns_capable(net->user_ns, CAP_NET_ADMIN))
@@@ -2623,6 -2801,18 +2734,21 @@@
  	case ETHTOOL_SLINKSETTINGS:
  		rc = ethtool_set_link_ksettings(dev, useraddr);
  		break;
++<<<<<<< HEAD
++=======
+ 	case ETHTOOL_PHY_GTUNABLE:
+ 		rc = get_phy_tunable(dev, useraddr);
+ 		break;
+ 	case ETHTOOL_PHY_STUNABLE:
+ 		rc = set_phy_tunable(dev, useraddr);
+ 		break;
+ 	case ETHTOOL_GFECPARAM:
+ 		rc = ethtool_get_fecparam(dev, useraddr);
+ 		break;
+ 	case ETHTOOL_SFECPARAM:
+ 		rc = ethtool_set_fecparam(dev, useraddr);
+ 		break;
++>>>>>>> 1a5f3da20bd9 (net: ethtool: add support for forward error correction modes)
  	default:
  		rc = -EOPNOTSUPP;
  	}
* Unmerged path include/linux/ethtool.h
* Unmerged path include/uapi/linux/ethtool.h
* Unmerged path net/core/ethtool.c
