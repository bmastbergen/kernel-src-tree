sysfs: use a separate locking class for open files depending on mmap

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Tejun Heo <tj@kernel.org>
commit 027a485d12e089314360d459b8d847104dd28702
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/027a485d.failed

The following two commits implemented mmap support in the regular file
path and merged bin file support into the regular path.

 73d9714627ad ("sysfs: copy bin mmap support from fs/sysfs/bin.c to fs/sysfs/file.c")
 3124eb1679b2 ("sysfs: merge regular and bin file handling")

After the merge, the following commands trigger a spurious lockdep
warning.  "test-mmap-read" simply mmaps the file and dumps the
content.

  $ cat /sys/block/sda/trace/act_mask
  $ test-mmap-read /sys/devices/pci0000\:00/0000\:00\:03.0/resource0 4096

  ======================================================
  [ INFO: possible circular locking dependency detected ]
  3.12.0-work+ #378 Not tainted
  -------------------------------------------------------
  test-mmap-read/567 is trying to acquire lock:
   (&of->mutex){+.+.+.}, at: [<ffffffff8120a8df>] sysfs_bin_mmap+0x4f/0x120

  but task is already holding lock:
   (&mm->mmap_sem){++++++}, at: [<ffffffff8114b399>] vm_mmap_pgoff+0x49/0xa0

  which lock already depends on the new lock.

  the existing dependency chain (in reverse order) is:

  -> #3 (&mm->mmap_sem){++++++}:
  ...
  -> #2 (sr_mutex){+.+.+.}:
  ...
  -> #1 (&bdev->bd_mutex){+.+.+.}:
  ...
  -> #0 (&of->mutex){+.+.+.}:
  ...

  other info that might help us debug this:

  Chain exists of:
   &of->mutex --> sr_mutex --> &mm->mmap_sem

   Possible unsafe locking scenario:

	 CPU0                    CPU1
	 ----                    ----
    lock(&mm->mmap_sem);
				 lock(sr_mutex);
				 lock(&mm->mmap_sem);
    lock(&of->mutex);

   *** DEADLOCK ***

  1 lock held by test-mmap-read/567:
   #0:  (&mm->mmap_sem){++++++}, at: [<ffffffff8114b399>] vm_mmap_pgoff+0x49/0xa0

  stack backtrace:
  CPU: 3 PID: 567 Comm: test-mmap-read Not tainted 3.12.0-work+ #378
  Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011
   ffffffff81ed41a0 ffff880009441bc8 ffffffff81611ad2 ffffffff81eccb80
   ffff880009441c08 ffffffff8160f215 ffff880009441c60 ffff880009c75208
   0000000000000000 ffff880009c751e0 ffff880009c75208 ffff880009c74ac0
  Call Trace:
   [<ffffffff81611ad2>] dump_stack+0x4e/0x7a
   [<ffffffff8160f215>] print_circular_bug+0x2b0/0x2bf
   [<ffffffff8109ca0a>] __lock_acquire+0x1a3a/0x1e60
   [<ffffffff8109d6ba>] lock_acquire+0x9a/0x1d0
   [<ffffffff81615547>] mutex_lock_nested+0x67/0x3f0
   [<ffffffff8120a8df>] sysfs_bin_mmap+0x4f/0x120
   [<ffffffff8115d363>] mmap_region+0x3b3/0x5b0
   [<ffffffff8115d8ae>] do_mmap_pgoff+0x34e/0x3d0
   [<ffffffff8114b3ba>] vm_mmap_pgoff+0x6a/0xa0
   [<ffffffff8115be3e>] SyS_mmap_pgoff+0xbe/0x250
   [<ffffffff81008282>] SyS_mmap+0x22/0x30
   [<ffffffff8161a4d2>] system_call_fastpath+0x16/0x1b

This happens because one file nests sr_mutex, which nests mm->mmap_sem
under it, under of->mutex while mmap implementation naturally nests
of->mutex under mm->mmap_sem.  The warning is false positive as
of->mutex is per open-file and the two paths belong to two different
files.  This warning didn't trigger before regular and bin file
supports were merged because only bin file supported mmap and the
other side of locking happened only on regular files which used
equivalent but separate locking.

It'd be best if we give separate locking classes per file but we can't
easily do that.  Let's differentiate on ->mmap() for now.  Later we'll
add explicit file operations struct and can add per-ops lockdep key
there.

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Reported-by: Dave Jones <davej@redhat.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 027a485d12e089314360d459b8d847104dd28702)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/sysfs/file.c
diff --cc fs/sysfs/file.c
index d8887c896abc,b94f93685093..000000000000
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@@ -331,59 -608,89 +331,126 @@@ static int sysfs_open_file(struct inod
  {
  	struct sysfs_dirent *attr_sd = file->f_path.dentry->d_fsdata;
  	struct kobject *kobj = attr_sd->s_parent->s_dir.kobj;
++<<<<<<< HEAD
 +	struct sysfs_buffer *buffer;
 +	const struct sysfs_ops *ops;
++=======
+ 	struct sysfs_open_file *of;
+ 	bool has_read, has_write, has_mmap;
++>>>>>>> 027a485d12e0 (sysfs: use a separate locking class for open files depending on mmap)
  	int error = -EACCES;
  
  	/* need attr_sd for attr and ops, its parent for kobj */
  	if (!sysfs_get_active(attr_sd))
  		return -ENODEV;
  
++<<<<<<< HEAD
 +	/* every kobject with an attribute needs a ktype assigned */
 +	if (kobj->ktype && kobj->ktype->sysfs_ops)
 +		ops = kobj->ktype->sysfs_ops;
 +	else {
 +		WARN(1, KERN_ERR
 +		     "missing sysfs attribute operations for kobject: %s\n",
 +		     kobject_name(kobj));
 +		goto err_out;
 +	}
 +
 +	/* File needs write support.
 +	 * The inode's perms must say it's ok,
 +	 * and we must have a store method.
++=======
+ 	if (sysfs_is_bin(attr_sd)) {
+ 		struct bin_attribute *battr = attr_sd->s_attr.bin_attr;
+ 
+ 		has_read = battr->read || battr->mmap;
+ 		has_write = battr->write || battr->mmap;
+ 		has_mmap = battr->mmap;
+ 	} else {
+ 		const struct sysfs_ops *ops = sysfs_file_ops(attr_sd);
+ 
+ 		/* every kobject with an attribute needs a ktype assigned */
+ 		if (WARN(!ops, KERN_ERR
+ 			 "missing sysfs attribute operations for kobject: %s\n",
+ 			 kobject_name(kobj)))
+ 			goto err_out;
+ 
+ 		has_read = ops->show;
+ 		has_write = ops->store;
+ 		has_mmap = false;
+ 	}
+ 
+ 	/* check perms and supported operations */
+ 	if ((file->f_mode & FMODE_WRITE) &&
+ 	    (!(inode->i_mode & S_IWUGO) || !has_write))
+ 		goto err_out;
+ 
+ 	if ((file->f_mode & FMODE_READ) &&
+ 	    (!(inode->i_mode & S_IRUGO) || !has_read))
+ 		goto err_out;
+ 
+ 	/* allocate a sysfs_open_file for the file */
+ 	error = -ENOMEM;
+ 	of = kzalloc(sizeof(struct sysfs_open_file), GFP_KERNEL);
+ 	if (!of)
+ 		goto err_out;
+ 
+ 	/*
+ 	 * The following is done to give a different lockdep key to
+ 	 * @of->mutex for files which implement mmap.  This is a rather
+ 	 * crude way to avoid false positive lockdep warning around
+ 	 * mm->mmap_sem - mmap nests @of->mutex under mm->mmap_sem and
+ 	 * reading /sys/block/sda/trace/act_mask grabs sr_mutex, under
+ 	 * which mm->mmap_sem nests, while holding @of->mutex.  As each
+ 	 * open file has a separate mutex, it's okay as long as those don't
+ 	 * happen on the same file.  At this point, we can't easily give
+ 	 * each file a separate locking class.  Let's differentiate on
+ 	 * whether the file has mmap or not for now.
+ 	 */
+ 	if (has_mmap)
+ 		mutex_init(&of->mutex);
+ 	else
+ 		mutex_init(&of->mutex);
+ 
+ 	of->sd = attr_sd;
+ 	of->file = file;
+ 
+ 	/*
+ 	 * Always instantiate seq_file even if read access doesn't use
+ 	 * seq_file or is not requested.  This unifies private data access
+ 	 * and readable regular files are the vast majority anyway.
++>>>>>>> 027a485d12e0 (sysfs: use a separate locking class for open files depending on mmap)
  	 */
 -	if (sysfs_is_bin(attr_sd))
 -		error = single_open(file, NULL, of);
 -	else
 -		error = single_open(file, sysfs_seq_show, of);
 -	if (error)
 -		goto err_free;
 +	if (file->f_mode & FMODE_WRITE) {
 +		if (!(inode->i_mode & S_IWUGO) || !ops->store)
 +			goto err_out;
 +	}
  
 -	/* seq_file clears PWRITE unconditionally, restore it if WRITE */
 -	if (file->f_mode & FMODE_WRITE)
 -		file->f_mode |= FMODE_PWRITE;
 +	/* File needs read support.
 +	 * The inode's perms must say it's ok, and we there
 +	 * must be a show method for it.
 +	 */
 +	if (file->f_mode & FMODE_READ) {
 +		if (!(inode->i_mode & S_IRUGO) || !ops->show)
 +			goto err_out;
 +	}
 +
 +	/* No error? Great, allocate a buffer for the file, and store it
 +	 * it in file->private_data for easy access.
 +	 */
 +	error = -ENOMEM;
 +	buffer = kzalloc(sizeof(struct sysfs_buffer), GFP_KERNEL);
 +	if (!buffer)
 +		goto err_out;
 +
 +	mutex_init(&buffer->mutex);
 +	buffer->needs_read_fill = 1;
 +	buffer->ops = ops;
 +	file->private_data = buffer;
  
  	/* make sure we have open dirent struct */
 -	error = sysfs_get_open_dirent(attr_sd, of);
 +	error = sysfs_get_open_dirent(attr_sd, buffer);
  	if (error)
 -		goto err_close;
 +		goto err_free;
  
  	/* open succeeded, put active references */
  	sysfs_put_active(attr_sd);
* Unmerged path fs/sysfs/file.c
