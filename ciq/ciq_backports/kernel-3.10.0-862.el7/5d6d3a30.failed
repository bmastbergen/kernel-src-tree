fuse: allow server to run in different pid_ns

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 5d6d3a301c4e749e04be6fcdcf4cb1ffa8bae524
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5d6d3a30.failed

Commit 0b6e9ea041e6 ("fuse: Add support for pid namespaces") broke
Sandstorm.io development tools, which have been sending FUSE file
descriptors across PID namespace boundaries since early 2014.

The above patch added a check that prevented I/O on the fuse device file
descriptor if the pid namespace of the reader/writer was different from the
pid namespace of the mounter.  With this change passing the device file
descriptor to a different pid namespace simply doesn't work.  The check was
added because pids are transferred to/from the fuse userspace server in the
namespace registered at mount time.

To fix this regression, remove the checks and do the following:

1) the pid in the request header (the pid of the task that initiated the
filesystem operation) is translated to the reader's pid namespace.  If a
mapping doesn't exist for this pid, then a zero pid is used.  Note: even if
a mapping would exist between the initiator task's pid namespace and the
reader's pid namespace the pid will be zero if either mapping from
initator's to mounter's namespace or mapping from mounter's to reader's
namespace doesn't exist.

2) The lk.pid value in setlk/setlkw requests and getlk reply is left alone.
Userspace should not interpret this value anyway.  Also allow the
setlk/setlkw operations if the pid of the task cannot be represented in the
mounter's namespace (pid being zero in that case).

	Reported-by: Kenton Varda <kenton@sandstorm.io>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Fixes: 0b6e9ea041e6 ("fuse: Add support for pid namespaces")
	Cc: <stable@vger.kernel.org> # v4.12+
	Cc: Eric W. Biederman <ebiederm@xmission.com>
	Cc: Seth Forshee <seth.forshee@canonical.com>
(cherry picked from commit 5d6d3a301c4e749e04be6fcdcf4cb1ffa8bae524)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/file.c
diff --cc fs/fuse/file.c
index bd73f4f40c3a,6d8e65cec01a..000000000000
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@@ -1744,13 -2181,9 +1744,18 @@@ static int fuse_setlk(struct file *file
  	if ((fl->fl_flags & FL_CLOSE_POSIX) == FL_CLOSE_POSIX)
  		return 0;
  
++<<<<<<< HEAD
 +	req = fuse_get_req_nopages(fc);
 +	if (IS_ERR(req))
 +		return PTR_ERR(req);
++=======
+ 	fuse_lk_fill(&args, file, fl, opcode, pid_nr, flock, &inarg);
+ 	err = fuse_simple_request(fc, &args);
++>>>>>>> 5d6d3a301c4e (fuse: allow server to run in different pid_ns)
  
 +	fuse_lk_fill(req, file, fl, opcode, pid, flock);
 +	fuse_request_send(fc, req);
 +	err = req->out.h.error;
  	/* locking is restartable */
  	if (err == -EINTR)
  		err = -ERESTARTSYS;
diff --git a/fs/fuse/dev.c b/fs/fuse/dev.c
index e5326f13da17..97f01787d553 100644
--- a/fs/fuse/dev.c
+++ b/fs/fuse/dev.c
@@ -1239,6 +1239,13 @@ static ssize_t fuse_dev_do_read(struct fuse_conn *fc, struct file *file,
 
 	in = &req->in;
 	reqsize = in->h.len;
+
+	if (task_active_pid_ns(current) != fc->pid_ns) {
+		rcu_read_lock();
+		in->h.pid = pid_vnr(find_pid_ns(in->h.pid, fc->pid_ns));
+		rcu_read_unlock();
+	}
+
 	/* If request is too large, reply with an error and restart the read */
 	if (nbytes < reqsize) {
 		req->out.h.error = -EIO;
* Unmerged path fs/fuse/file.c
