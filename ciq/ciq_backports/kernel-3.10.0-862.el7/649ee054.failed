target: Move task tag into struct se_cmd + support 64-bit tags

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [target] Move task tag into struct se_cmd + support 64-bit tags (Maurizio Lombardi) [1366062]
Rebuild_FUZZ: 93.10%
commit-author Bart Van Assche <bart.vanassche@sandisk.com>
commit 649ee05499d1257a3af0e10d961a1c52d9ef95b7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/649ee054.failed

Simplify target core and target drivers by storing the task tag
a.k.a. command identifier inside struct se_cmd.

For several transports (e.g. SRP) tags are 64 bits wide.
Hence add support for 64-bit tags.

(Fix core_tmr_abort_task conversion spec warnings - nab)
(Fix up usb-gadget to use 16-bit tags - HCH + bart)

	Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: Andy Grover <agrover@redhat.com>
	Cc: Sagi Grimberg <sagig@mellanox.com>
	Cc: <qla2xxx-upstream@qlogic.com>
	Cc: Felipe Balbi <balbi@ti.com>
	Cc: Michael S. Tsirkin <mst@redhat.com>
	Cc: Juergen Gross <jgross@suse.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 649ee05499d1257a3af0e10d961a1c52d9ef95b7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/srpt/ib_srpt.c
#	drivers/infiniband/ulp/srpt/ib_srpt.h
#	drivers/scsi/qla2xxx/qla_target.c
#	drivers/scsi/qla2xxx/tcm_qla2xxx.c
#	drivers/target/iscsi/iscsi_target_configfs.c
#	drivers/target/loopback/tcm_loop.c
#	drivers/vhost/scsi.c
#	drivers/xen/xen-scsiback.c
diff --cc drivers/infiniband/ulp/srpt/ib_srpt.c
index 72146d165e84,56df5cd918c5..000000000000
--- a/drivers/infiniband/ulp/srpt/ib_srpt.c
+++ b/drivers/infiniband/ulp/srpt/ib_srpt.c
@@@ -1152,8 -1329,17 +1152,8 @@@ static int srpt_abort_cmd(struct srpt_s
  	}
  	spin_unlock_irqrestore(&ioctx->spinlock, flags);
  
 -	if (state == SRPT_STATE_DONE) {
 -		struct srpt_rdma_ch *ch = ioctx->ch;
 -
 -		BUG_ON(ch->sess == NULL);
 -
 -		target_put_sess_cmd(&ioctx->cmd);
 -		goto out;
 -	}
 -
  	pr_debug("Aborting cmd with state %d and tag %lld\n", state,
- 		 ioctx->tag);
+ 		 ioctx->cmd.tag);
  
  	switch (state) {
  	case SRPT_STATE_NEW:
@@@ -1364,31 -1719,68 +1364,92 @@@ static void srpt_handle_cmd(struct srpt
  		break;
  	}
  
++<<<<<<< HEAD
 +	rc = srpt_get_desc_tbl(send_ioctx, srp_cmd, &dir, &sg, &sg_cnt,
 +			&data_len);
 +	if (rc) {
 +		if (rc != -EAGAIN) {
 +			pr_err("0x%llx: parsing SRP descriptor table failed.\n",
 +			       srp_cmd->tag);
++=======
+ 	if (srpt_get_desc_tbl(send_ioctx, srp_cmd, &dir, &data_len)) {
+ 		pr_err("0x%llx: parsing SRP descriptor table failed.\n",
+ 		       srp_cmd->tag);
+ 		ret = TCM_INVALID_CDB_FIELD;
+ 		goto send_sense;
+ 	}
+ 
+ 	unpacked_lun = srpt_unpack_lun((uint8_t *)&srp_cmd->lun,
+ 				       sizeof(srp_cmd->lun));
+ 	rc = target_submit_cmd(cmd, ch->sess, srp_cmd->cdb,
+ 			&send_ioctx->sense_data[0], unpacked_lun, data_len,
+ 			TCM_SIMPLE_TAG, dir, TARGET_SCF_ACK_KREF);
+ 	if (rc != 0) {
+ 		ret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
+ 		goto send_sense;
+ 	}
+ 	return 0;
+ 
+ send_sense:
+ 	transport_send_check_condition_and_sense(cmd, ret, 0);
+ 	return -1;
+ }
+ 
+ /**
+  * srpt_rx_mgmt_fn_tag() - Process a task management function by tag.
+  * @ch: RDMA channel of the task management request.
+  * @fn: Task management function to perform.
+  * @req_tag: Tag of the SRP task management request.
+  * @mgmt_ioctx: I/O context of the task management request.
+  *
+  * Returns zero if the target core will process the task management
+  * request asynchronously.
+  *
+  * Note: It is assumed that the initiator serializes tag-based task management
+  * requests.
+  */
+ static int srpt_rx_mgmt_fn_tag(struct srpt_send_ioctx *ioctx, u64 tag)
+ {
+ 	struct srpt_device *sdev;
+ 	struct srpt_rdma_ch *ch;
+ 	struct srpt_send_ioctx *target;
+ 	int ret, i;
+ 
+ 	ret = -EINVAL;
+ 	ch = ioctx->ch;
+ 	BUG_ON(!ch);
+ 	BUG_ON(!ch->sport);
+ 	sdev = ch->sport->sdev;
+ 	BUG_ON(!sdev);
+ 	spin_lock_irq(&sdev->spinlock);
+ 	for (i = 0; i < ch->rq_size; ++i) {
+ 		target = ch->ioctx_ring[i];
+ 		if (target->cmd.se_lun == ioctx->cmd.se_lun &&
+ 		    target->cmd.tag == tag &&
+ 		    srpt_get_cmd_state(target) != SRPT_STATE_DONE) {
+ 			ret = 0;
+ 			/* now let the target core abort &target->cmd; */
+ 			break;
++>>>>>>> 649ee05499d1 (target: Move task tag into struct se_cmd + support 64-bit tags)
  		}
 +		goto release_ioctx;
  	}
 -	spin_unlock_irq(&sdev->spinlock);
 -	return ret;
 +
 +	rc = target_submit_cmd_map_sgls(cmd, ch->sess, srp_cmd->cdb,
 +			       &send_ioctx->sense_data[0],
 +			       scsilun_to_int(&srp_cmd->lun), data_len,
 +			       TCM_SIMPLE_TAG, dir, TARGET_SCF_ACK_KREF,
 +			       sg, sg_cnt, NULL, 0, NULL, 0);
 +	if (rc != 0) {
 +		pr_debug("target_submit_cmd() returned %d for tag %#llx\n", rc,
 +			 srp_cmd->tag);
 +		goto release_ioctx;
 +	}
 +	return;
 +
 +release_ioctx:
 +	send_ioctx->state = SRPT_STATE_DONE;
 +	srpt_release_cmd(cmd);
  }
  
  static int srp_tmr_to_tcm(int fn)
@@@ -1437,12 -1831,28 +1498,12 @@@ static void srpt_handle_tsk_mgmt(struc
  		 srp_tsk->task_tag, srp_tsk->tag, ch->cm_id, ch->sess);
  
  	srpt_set_cmd_state(send_ioctx, SRPT_STATE_MGMT);
- 	send_ioctx->tag = srp_tsk->tag;
+ 	send_ioctx->cmd.tag = srp_tsk->tag;
  	tcm_tmr = srp_tmr_to_tcm(srp_tsk->tsk_mgmt_func);
 -	if (tcm_tmr < 0) {
 -		send_ioctx->cmd.se_tmr_req->response =
 -			TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED;
 -		goto fail;
 -	}
 -	unpacked_lun = srpt_unpack_lun((uint8_t *)&srp_tsk->lun,
 -				       sizeof(srp_tsk->lun));
 -
 -	if (srp_tsk->tsk_mgmt_func == SRP_TSK_ABORT_TASK) {
 -		rc = srpt_rx_mgmt_fn_tag(send_ioctx, srp_tsk->task_tag);
 -		if (rc < 0) {
 -			send_ioctx->cmd.se_tmr_req->response =
 -					TMR_TASK_DOES_NOT_EXIST;
 -			goto fail;
 -		}
 -		tag = srp_tsk->task_tag;
 -	}
 -	rc = target_submit_tmr(&send_ioctx->cmd, sess, NULL, unpacked_lun,
 -				srp_tsk, tcm_tmr, GFP_KERNEL, tag,
 -				TARGET_SCF_ACK_KREF);
 +	rc = target_submit_tmr(&send_ioctx->cmd, sess, NULL,
 +			       scsilun_to_int(&srp_tsk->lun), srp_tsk, tcm_tmr,
 +			       GFP_KERNEL, srp_tsk->task_tag,
 +			       TARGET_SCF_ACK_KREF);
  	if (rc != 0) {
  		send_ioctx->cmd.se_tmr_req->response = TMR_FUNCTION_REJECTED;
  		goto fail;
@@@ -2249,34 -2964,29 +2310,53 @@@ static int srpt_write_pending(struct se
  	new_state = srpt_set_cmd_state(ioctx, SRPT_STATE_NEED_DATA);
  	WARN_ON(new_state == SRPT_STATE_DONE);
  
 -	ch = ioctx->ch;
 -	BUG_ON(!ch);
  
++<<<<<<< HEAD
 +	if (atomic_sub_return(ioctx->n_rdma, &ch->sq_wr_avail) < 0) {
 +		pr_warn("%s: IB send queue full (needed %d)\n",
 +				__func__, ioctx->n_rdma);
 +		ret = -ENOMEM;
 +		goto out_undo;
++=======
+ 	ch_state = srpt_get_ch_state(ch);
+ 	switch (ch_state) {
+ 	case CH_CONNECTING:
+ 		WARN(true, "unexpected channel state %d\n", ch_state);
+ 		ret = -EINVAL;
+ 		goto out;
+ 	case CH_LIVE:
+ 		break;
+ 	case CH_DISCONNECTING:
+ 	case CH_DRAINING:
+ 	case CH_RELEASING:
+ 		pr_debug("cmd with tag %lld: channel disconnecting\n",
+ 			 ioctx->cmd.tag);
+ 		srpt_set_cmd_state(ioctx, SRPT_STATE_DATA_IN);
+ 		ret = -EINVAL;
+ 		goto out;
++>>>>>>> 649ee05499d1 (target: Move task tag into struct se_cmd + support 64-bit tags)
  	}
 -	ret = srpt_xfer_data(ch, ioctx);
  
 -out:
 +	cqe->done = srpt_rdma_read_done;
 +	for (i = ioctx->n_rw_ctx - 1; i >= 0; i--) {
 +		struct srpt_rw_ctx *ctx = &ioctx->rw_ctxs[i];
 +
 +		first_wr = rdma_rw_ctx_wrs(&ctx->rw, ch->qp, ch->sport->port,
 +				cqe, first_wr);
 +		cqe = NULL;
 +	}
 +
 +	ret = ib_post_send(ch->qp, first_wr, &bad_wr);
 +	if (ret) {
 +		pr_err("%s: ib_post_send() returned %d for %d (avail: %d)\n",
 +			 __func__, ret, ioctx->n_rdma,
 +			 atomic_read(&ch->sq_wr_avail));
 +		goto out_undo;
 +	}
 +
 +	return 0;
 +out_undo:
 +	atomic_add(ioctx->n_rdma, &ch->sq_wr_avail);
  	return ret;
  }
  
@@@ -2336,15 -3046,16 +2416,23 @@@ static void srpt_queue_response(struct 
  		return;
  	}
  
 -	dir = ioctx->cmd.data_direction;
 -
  	/* For read commands, transfer the data to the initiator. */
 -	if (dir == DMA_FROM_DEVICE && ioctx->cmd.data_length &&
 +	if (ioctx->cmd.data_direction == DMA_FROM_DEVICE &&
 +	    ioctx->cmd.data_length &&
  	    !ioctx->queue_status_only) {
++<<<<<<< HEAD
 +		for (i = ioctx->n_rw_ctx - 1; i >= 0; i--) {
 +			struct srpt_rw_ctx *ctx = &ioctx->rw_ctxs[i];
 +
 +			first_wr = rdma_rw_ctx_wrs(&ctx->rw, ch->qp,
 +					ch->sport->port, NULL, first_wr);
++=======
+ 		ret = srpt_xfer_data(ch, ioctx);
+ 		if (ret) {
+ 			pr_err("xfer_data failed for tag %llu\n",
+ 			       ioctx->cmd.tag);
+ 			return;
++>>>>>>> 649ee05499d1 (target: Move task tag into struct se_cmd + support 64-bit tags)
  		}
  	}
  
@@@ -2355,48 -3066,16 +2443,58 @@@
  		srp_tm_status
  			= tcm_to_srp_tsk_mgmt_status(cmd->se_tmr_req->response);
  		resp_len = srpt_build_tskmgmt_rsp(ch, ioctx, srp_tm_status,
- 						 ioctx->tag);
+ 						 ioctx->cmd.tag);
  	}
++<<<<<<< HEAD
 +
 +	atomic_inc(&ch->req_lim);
 +
 +	if (unlikely(atomic_sub_return(1 + ioctx->n_rdma,
 +			&ch->sq_wr_avail) < 0)) {
 +		pr_warn("%s: IB send queue full (needed %d)\n",
 +				__func__, ioctx->n_rdma);
 +		ret = -ENOMEM;
 +		goto out;
++=======
+ 	ret = srpt_post_send(ch, ioctx, resp_len);
+ 	if (ret) {
+ 		pr_err("sending cmd response failed for tag %llu\n",
+ 		       ioctx->cmd.tag);
+ 		srpt_unmap_sg_to_ib_sge(ch, ioctx);
+ 		srpt_set_cmd_state(ioctx, SRPT_STATE_DONE);
+ 		target_put_sess_cmd(&ioctx->cmd);
++>>>>>>> 649ee05499d1 (target: Move task tag into struct se_cmd + support 64-bit tags)
 +	}
 +
 +	ib_dma_sync_single_for_device(sdev->device, ioctx->ioctx.dma, resp_len,
 +				      DMA_TO_DEVICE);
 +
 +	sge.addr = ioctx->ioctx.dma;
 +	sge.length = resp_len;
 +	sge.lkey = sdev->pd->local_dma_lkey;
 +
 +	ioctx->ioctx.cqe.done = srpt_send_done;
 +	send_wr.next = NULL;
 +	send_wr.wr_cqe = &ioctx->ioctx.cqe;
 +	send_wr.sg_list = &sge;
 +	send_wr.num_sge = 1;
 +	send_wr.opcode = IB_WR_SEND;
 +	send_wr.send_flags = IB_SEND_SIGNALED;
 +
 +	ret = ib_post_send(ch->qp, first_wr, &bad_wr);
 +	if (ret < 0) {
 +		pr_err("%s: sending cmd response failed for tag %llu (%d)\n",
 +			__func__, ioctx->tag, ret);
 +		goto out;
  	}
 +
 +	return;
 +
 +out:
 +	atomic_add(1 + ioctx->n_rdma, &ch->sq_wr_avail);
 +	atomic_dec(&ch->req_lim);
 +	srpt_set_cmd_state(ioctx, SRPT_STATE_DONE);
 +	target_put_sess_cmd(&ioctx->cmd);
  }
  
  static int srpt_queue_data_in(struct se_cmd *cmd)
diff --cc drivers/infiniband/ulp/srpt/ib_srpt.h
index 9077ca1e51ce,6fec740742bd..000000000000
--- a/drivers/infiniband/ulp/srpt/ib_srpt.h
+++ b/drivers/infiniband/ulp/srpt/ib_srpt.h
@@@ -206,11 -235,14 +206,17 @@@ struct srpt_send_ioctx 
  	struct list_head	free_list;
  	spinlock_t		spinlock;
  	enum srpt_command_state	state;
 -	bool			rdma_aborted;
  	struct se_cmd		cmd;
  	struct completion	tx_done;
++<<<<<<< HEAD
 +	u64			tag;
++=======
+ 	int			sg_cnt;
+ 	int			mapped_sg_count;
+ 	u16			n_rdma_ius;
++>>>>>>> 649ee05499d1 (target: Move task tag into struct se_cmd + support 64-bit tags)
  	u8			n_rdma;
 -	u8			n_rbuf;
 +	u8			n_rw_ctx;
  	bool			queue_status_only;
  	u8			sense_data[SCSI_SENSE_BUFFERSIZE];
  };
diff --cc drivers/scsi/qla2xxx/qla_target.c
index 4244f37d5d93,e7515069e1ce..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -1763,11 -1728,11 +1763,10 @@@ static int qlt_pre_xmit_response(struc
  
  	if (unlikely(cmd->aborted)) {
  		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf014,
- 		    "qla_target(%d): terminating exchange "
- 		    "for aborted cmd=%p (se_cmd=%p, tag=%d)", vha->vp_idx, cmd,
- 		    se_cmd, cmd->tag);
+ 		       "qla_target(%d): terminating exchange for aborted cmd=%p (se_cmd=%p, tag=%lld)",
+ 		       vha->vp_idx, cmd, se_cmd, se_cmd->tag);
  
  		cmd->state = QLA_TGT_STATE_ABORTED;
 -		cmd->cmd_flags |= BIT_6;
  
  		qlt_send_term_exchange(vha, cmd, &cmd->atio, 0);
  
@@@ -1806,19 -1763,18 +1805,34 @@@
  
  	if (se_cmd->se_cmd_flags & SCF_UNDERFLOW_BIT) {
  		prm->residual = se_cmd->residual_count;
++<<<<<<< HEAD
 +		ql_dbg(ql_dbg_tgt, vha, 0xe014,
 +		    "Residual underflow: %d (tag %d, "
 +		    "op %x, bufflen %d, rq_result %x)\n", prm->residual,
 +		    cmd->tag, se_cmd->t_task_cdb ? se_cmd->t_task_cdb[0] : 0,
 +		    cmd->bufflen, prm->rq_result);
 +		prm->rq_result |= SS_RESIDUAL_UNDER;
 +	} else if (se_cmd->se_cmd_flags & SCF_OVERFLOW_BIT) {
 +		prm->residual = se_cmd->residual_count;
 +		ql_dbg(ql_dbg_tgt, vha, 0xe015,
 +		    "Residual overflow: %d (tag %d, "
 +		    "op %x, bufflen %d, rq_result %x)\n", prm->residual,
 +		    cmd->tag, se_cmd->t_task_cdb ? se_cmd->t_task_cdb[0] : 0,
 +		    cmd->bufflen, prm->rq_result);
++=======
+ 		ql_dbg(ql_dbg_io + ql_dbg_verbose, vha, 0x305c,
+ 		    "Residual underflow: %d (tag %lld, op %x, bufflen %d, rq_result %x)\n",
+ 		       prm->residual, se_cmd->tag,
+ 		       se_cmd->t_task_cdb ? se_cmd->t_task_cdb[0] : 0,
+ 		       cmd->bufflen, prm->rq_result);
+ 		prm->rq_result |= SS_RESIDUAL_UNDER;
+ 	} else if (se_cmd->se_cmd_flags & SCF_OVERFLOW_BIT) {
+ 		prm->residual = se_cmd->residual_count;
+ 		ql_dbg(ql_dbg_io, vha, 0x305d,
+ 		    "Residual overflow: %d (tag %lld, op %x, bufflen %d, rq_result %x)\n",
+ 		       prm->residual, se_cmd->tag, se_cmd->t_task_cdb ?
+ 		       se_cmd->t_task_cdb[0] : 0, cmd->bufflen, prm->rq_result);
++>>>>>>> 649ee05499d1 (target: Move task tag into struct se_cmd + support 64-bit tags)
  		prm->rq_result |= SS_RESIDUAL_OVER;
  	}
  
@@@ -2638,43 -3261,10 +2652,43 @@@ static void qlt_do_work(struct work_str
  	if (tgt->tgt_stop)
  		goto out_term;
  
 +	spin_lock_irqsave(&ha->hardware_lock, flags);
 +	sess = ha->tgt.tgt_ops->find_sess_by_s_id(vha,
 +	    atio->u.isp24.fcp_hdr.s_id);
 +	/* Do kref_get() before dropping qla_hw_data->hardware_lock. */
 +	if (sess)
 +		kref_get(&sess->se_sess->sess_kref);
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +
 +	if (unlikely(!sess)) {
 +		uint8_t *s_id =	atio->u.isp24.fcp_hdr.s_id;
 +
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf022,
 +			"qla_target(%d): Unable to find wwn login"
 +			" (s_id %x:%x:%x), trying to create it manually\n",
 +			vha->vp_idx, s_id[0], s_id[1], s_id[2]);
 +
 +		if (atio->u.raw.entry_count > 1) {
 +			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf023,
 +				"Dropping multy entry cmd %p\n", cmd);
 +			goto out_term;
 +		}
 +
 +		mutex_lock(&ha->tgt.tgt_mutex);
 +		sess = qlt_make_local_sess(vha, s_id);
 +		/* sess has an extra creation ref. */
 +		mutex_unlock(&ha->tgt.tgt_mutex);
 +
 +		if (!sess)
 +			goto out_term;
 +	}
 +
 +	cmd->sess = sess;
 +	cmd->loop_id = sess->loop_id;
 +	cmd->conf_compl_supported = sess->conf_compl_supported;
 +
  	cdb = &atio->u.isp24.fcp_cmnd.cdb[0];
- 	cmd->tag = atio->u.isp24.exchange_addr;
+ 	cmd->se_cmd.tag = atio->u.isp24.exchange_addr;
  	cmd->unpacked_lun = scsilun_to_int(
  	    (struct scsi_lun *)&atio->u.isp24.fcp_cmnd.lun);
  
@@@ -3213,14 -3918,14 +3226,12 @@@ static void qlt_handle_srr(struct scsi_
  			qlt_send_notify_ack(vha, ntfy,
  			    0, 0, 0, NOTIFY_ACK_SRR_FLAGS_ACCEPT, 0, 0);
  			spin_unlock_irqrestore(&ha->hardware_lock, flags);
 -			if (xmit_type & QLA_TGT_XMIT_DATA) {
 -				cmd->cmd_flags |= BIT_8;
 +			if (xmit_type & QLA_TGT_XMIT_DATA)
  				qlt_rdy_to_xfer(cmd);
 -			}
  		} else {
  			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf066,
- 			    "qla_target(%d): SRR for out data for cmd "
- 			    "without them (tag %d, SCSI status %d), "
- 			    "reject", vha->vp_idx, cmd->tag,
- 			    cmd->se_cmd.scsi_status);
+ 			    "qla_target(%d): SRR for out data for cmd without them (tag %lld, SCSI status %d), reject",
+ 			       vha->vp_idx, se_cmd->tag, cmd->se_cmd.scsi_status);
  			goto out_reject;
  		}
  		break;
diff --cc drivers/scsi/qla2xxx/tcm_qla2xxx.c
index 14250fcfe054,8e331220adda..000000000000
--- a/drivers/scsi/qla2xxx/tcm_qla2xxx.c
+++ b/drivers/scsi/qla2xxx/tcm_qla2xxx.c
@@@ -546,22 -421,8 +546,25 @@@ static void tcm_qla2xxx_set_default_nod
  	return;
  }
  
++<<<<<<< HEAD
 +static u32 tcm_qla2xxx_get_task_tag(struct se_cmd *se_cmd)
 +{
 +	struct qla_tgt_cmd *cmd = container_of(se_cmd,
 +				struct qla_tgt_cmd, se_cmd);
 +
 +	return cmd->tag;
 +}
 +
++=======
++>>>>>>> 649ee05499d1 (target: Move task tag into struct se_cmd + support 64-bit tags)
  static int tcm_qla2xxx_get_cmd_state(struct se_cmd *se_cmd)
  {
 +	if (!(se_cmd->se_cmd_flags & SCF_SCSI_TMR_CDB)) {
 +		struct qla_tgt_cmd *cmd = container_of(se_cmd,
 +				struct qla_tgt_cmd, se_cmd);
 +		return cmd->state;
 +	}
 +
  	return 0;
  }
  
diff --cc drivers/target/iscsi/iscsi_target_configfs.c
index e02616d0c024,aa4fc4d8e176..000000000000
--- a/drivers/target/iscsi/iscsi_target_configfs.c
+++ b/drivers/target/iscsi/iscsi_target_configfs.c
@@@ -2051,115 -1905,54 +2043,156 @@@ static void lio_release_cmd(struct se_c
  	iscsit_release_cmd(cmd);
  }
  
++<<<<<<< HEAD
 +/* End functions for target_core_fabric_ops */
++=======
+ const struct target_core_fabric_ops iscsi_ops = {
+ 	.module				= THIS_MODULE,
+ 	.name				= "iscsi",
+ 	.node_acl_size			= sizeof(struct iscsi_node_acl),
+ 	.get_fabric_name		= iscsi_get_fabric_name,
+ 	.tpg_get_wwn			= lio_tpg_get_endpoint_wwn,
+ 	.tpg_get_tag			= lio_tpg_get_tag,
+ 	.tpg_get_default_depth		= lio_tpg_get_default_depth,
+ 	.tpg_check_demo_mode		= lio_tpg_check_demo_mode,
+ 	.tpg_check_demo_mode_cache	= lio_tpg_check_demo_mode_cache,
+ 	.tpg_check_demo_mode_write_protect =
+ 			lio_tpg_check_demo_mode_write_protect,
+ 	.tpg_check_prod_mode_write_protect =
+ 			lio_tpg_check_prod_mode_write_protect,
+ 	.tpg_check_prot_fabric_only	= &lio_tpg_check_prot_fabric_only,
+ 	.tpg_get_inst_index		= lio_tpg_get_inst_index,
+ 	.check_stop_free		= lio_check_stop_free,
+ 	.release_cmd			= lio_release_cmd,
+ 	.shutdown_session		= lio_tpg_shutdown_session,
+ 	.close_session			= lio_tpg_close_session,
+ 	.sess_get_index			= lio_sess_get_index,
+ 	.sess_get_initiator_sid		= lio_sess_get_initiator_sid,
+ 	.write_pending			= lio_write_pending,
+ 	.write_pending_status		= lio_write_pending_status,
+ 	.set_default_node_attributes	= lio_set_default_node_attributes,
+ 	.get_cmd_state			= iscsi_get_cmd_state,
+ 	.queue_data_in			= lio_queue_data_in,
+ 	.queue_status			= lio_queue_status,
+ 	.queue_tm_rsp			= lio_queue_tm_rsp,
+ 	.aborted_task			= lio_aborted_task,
+ 	.fabric_make_wwn		= lio_target_call_coreaddtiqn,
+ 	.fabric_drop_wwn		= lio_target_call_coredeltiqn,
+ 	.fabric_make_tpg		= lio_target_tiqn_addtpg,
+ 	.fabric_drop_tpg		= lio_target_tiqn_deltpg,
+ 	.fabric_make_np			= lio_target_call_addnptotpg,
+ 	.fabric_drop_np			= lio_target_call_delnpfromtpg,
+ 	.fabric_init_nodeacl		= lio_target_init_nodeacl,
+ 	.fabric_cleanup_nodeacl		= lio_target_cleanup_nodeacl,
++>>>>>>> 649ee05499d1 (target: Move task tag into struct se_cmd + support 64-bit tags)
  
 -	.tfc_discovery_attrs		= lio_target_discovery_auth_attrs,
 -	.tfc_wwn_attrs			= lio_target_wwn_attrs,
 -	.tfc_tpg_base_attrs		= lio_target_tpg_attrs,
 -	.tfc_tpg_attrib_attrs		= lio_target_tpg_attrib_attrs,
 -	.tfc_tpg_auth_attrs		= lio_target_tpg_auth_attrs,
 -	.tfc_tpg_param_attrs		= lio_target_tpg_param_attrs,
 -	.tfc_tpg_np_base_attrs		= lio_target_portal_attrs,
 -	.tfc_tpg_nacl_base_attrs	= lio_target_initiator_attrs,
 -	.tfc_tpg_nacl_attrib_attrs	= lio_target_nacl_attrib_attrs,
 -	.tfc_tpg_nacl_auth_attrs	= lio_target_nacl_auth_attrs,
 -	.tfc_tpg_nacl_param_attrs	= lio_target_nacl_param_attrs,
 -};
 +int iscsi_target_register_configfs(void)
 +{
 +	struct target_fabric_configfs *fabric;
 +	int ret;
 +
 +	lio_target_fabric_configfs = NULL;
 +	fabric = target_fabric_configfs_init(THIS_MODULE, "iscsi");
 +	if (IS_ERR(fabric)) {
 +		pr_err("target_fabric_configfs_init() for"
 +				" LIO-Target failed!\n");
 +		return PTR_ERR(fabric);
 +	}
 +	/*
 +	 * Setup the fabric API of function pointers used by target_core_mod..
 +	 */
 +	fabric->tf_ops.get_fabric_name = &iscsi_get_fabric_name;
 +	fabric->tf_ops.get_fabric_proto_ident = &iscsi_get_fabric_proto_ident;
 +	fabric->tf_ops.tpg_get_wwn = &lio_tpg_get_endpoint_wwn;
 +	fabric->tf_ops.tpg_get_tag = &lio_tpg_get_tag;
 +	fabric->tf_ops.tpg_get_default_depth = &lio_tpg_get_default_depth;
 +	fabric->tf_ops.tpg_get_pr_transport_id = &iscsi_get_pr_transport_id;
 +	fabric->tf_ops.tpg_get_pr_transport_id_len =
 +				&iscsi_get_pr_transport_id_len;
 +	fabric->tf_ops.tpg_parse_pr_out_transport_id =
 +				&iscsi_parse_pr_out_transport_id;
 +	fabric->tf_ops.tpg_check_demo_mode = &lio_tpg_check_demo_mode;
 +	fabric->tf_ops.tpg_check_demo_mode_cache =
 +				&lio_tpg_check_demo_mode_cache;
 +	fabric->tf_ops.tpg_check_demo_mode_write_protect =
 +				&lio_tpg_check_demo_mode_write_protect;
 +	fabric->tf_ops.tpg_check_prod_mode_write_protect =
 +				&lio_tpg_check_prod_mode_write_protect;
 +	fabric->tf_ops.tpg_alloc_fabric_acl = &lio_tpg_alloc_fabric_acl;
 +	fabric->tf_ops.tpg_release_fabric_acl = &lio_tpg_release_fabric_acl;
 +	fabric->tf_ops.tpg_get_inst_index = &lio_tpg_get_inst_index;
 +	fabric->tf_ops.check_stop_free = &lio_check_stop_free,
 +	fabric->tf_ops.release_cmd = &lio_release_cmd;
 +	fabric->tf_ops.shutdown_session = &lio_tpg_shutdown_session;
 +	fabric->tf_ops.close_session = &lio_tpg_close_session;
 +	fabric->tf_ops.sess_get_index = &lio_sess_get_index;
 +	fabric->tf_ops.sess_get_initiator_sid = &lio_sess_get_initiator_sid;
 +	fabric->tf_ops.write_pending = &lio_write_pending;
 +	fabric->tf_ops.write_pending_status = &lio_write_pending_status;
 +	fabric->tf_ops.set_default_node_attributes =
 +				&lio_set_default_node_attributes;
 +	fabric->tf_ops.get_task_tag = &iscsi_get_task_tag;
 +	fabric->tf_ops.get_cmd_state = &iscsi_get_cmd_state;
 +	fabric->tf_ops.queue_data_in = &lio_queue_data_in;
 +	fabric->tf_ops.queue_status = &lio_queue_status;
 +	fabric->tf_ops.queue_tm_rsp = &lio_queue_tm_rsp;
 +	fabric->tf_ops.aborted_task = &lio_aborted_task;
 +	/*
 +	 * Setup function pointers for generic logic in target_core_fabric_configfs.c
 +	 */
 +	fabric->tf_ops.fabric_make_wwn = &lio_target_call_coreaddtiqn;
 +	fabric->tf_ops.fabric_drop_wwn = &lio_target_call_coredeltiqn;
 +	fabric->tf_ops.fabric_make_tpg = &lio_target_tiqn_addtpg;
 +	fabric->tf_ops.fabric_drop_tpg = &lio_target_tiqn_deltpg;
 +	fabric->tf_ops.fabric_post_link	= NULL;
 +	fabric->tf_ops.fabric_pre_unlink = NULL;
 +	fabric->tf_ops.fabric_make_np = &lio_target_call_addnptotpg;
 +	fabric->tf_ops.fabric_drop_np = &lio_target_call_delnpfromtpg;
 +	fabric->tf_ops.fabric_make_nodeacl = &lio_target_make_nodeacl;
 +	fabric->tf_ops.fabric_drop_nodeacl = &lio_target_drop_nodeacl;
 +	/*
 +	 * Setup default attribute lists for various fabric->tf_cit_tmpl
 +	 * sturct config_item_type's
 +	 */
 +	fabric->tf_cit_tmpl.tfc_discovery_cit.ct_attrs = lio_target_discovery_auth_attrs;
 +	fabric->tf_cit_tmpl.tfc_wwn_cit.ct_attrs = lio_target_wwn_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_base_cit.ct_attrs = lio_target_tpg_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_attrib_cit.ct_attrs = lio_target_tpg_attrib_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_auth_cit.ct_attrs = lio_target_tpg_auth_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_param_cit.ct_attrs = lio_target_tpg_param_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_np_base_cit.ct_attrs = lio_target_portal_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_nacl_base_cit.ct_attrs = lio_target_initiator_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_nacl_attrib_cit.ct_attrs = lio_target_nacl_attrib_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_nacl_auth_cit.ct_attrs = lio_target_nacl_auth_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_nacl_param_cit.ct_attrs = lio_target_nacl_param_attrs;
 +
 +	ret = target_fabric_configfs_register(fabric);
 +	if (ret < 0) {
 +		pr_err("target_fabric_configfs_register() for"
 +				" LIO-Target failed!\n");
 +		target_fabric_configfs_free(fabric);
 +		return ret;
 +	}
 +
 +	lio_target_fabric_configfs = fabric;
 +	pr_debug("LIO_TARGET[0] - Set fabric ->"
 +			" lio_target_fabric_configfs\n");
 +	return 0;
 +}
 +
 +
 +void iscsi_target_deregister_configfs(void)
 +{
 +	if (!lio_target_fabric_configfs)
 +		return;
 +	/*
 +	 * Shutdown discovery sessions and disable discovery TPG
 +	 */
 +	if (iscsit_global->discovery_tpg)
 +		iscsit_tpg_disable_portal_group(iscsit_global->discovery_tpg, 1);
 +
 +	target_fabric_configfs_deregister(lio_target_fabric_configfs);
 +	lio_target_fabric_configfs = NULL;
 +	pr_debug("LIO_TARGET[0] - Cleared"
 +				" lio_target_fabric_configfs\n");
 +}
diff --cc drivers/target/loopback/tcm_loop.c
index d49ba0b7387a,07d3b52c88eb..000000000000
--- a/drivers/target/loopback/tcm_loop.c
+++ b/drivers/target/loopback/tcm_loop.c
@@@ -1411,129 -1230,43 +1404,169 @@@ static struct configfs_attribute *tcm_l
  
  /* End items for tcm_loop_cit */
  
++<<<<<<< HEAD
 +static int tcm_loop_register_configfs(void)
 +{
 +	struct target_fabric_configfs *fabric;
 +	int ret;
 +	/*
 +	 * Set the TCM Loop HBA counter to zero
 +	 */
 +	tcm_loop_hba_no_cnt = 0;
 +	/*
 +	 * Register the top level struct config_item_type with TCM core
 +	 */
 +	fabric = target_fabric_configfs_init(THIS_MODULE, "loopback");
 +	if (IS_ERR(fabric)) {
 +		pr_err("tcm_loop_register_configfs() failed!\n");
 +		return PTR_ERR(fabric);
 +	}
 +	/*
 +	 * Setup the fabric API of function pointers used by target_core_mod
 +	 */
 +	fabric->tf_ops.get_fabric_name = &tcm_loop_get_fabric_name;
 +	fabric->tf_ops.get_fabric_proto_ident = &tcm_loop_get_fabric_proto_ident;
 +	fabric->tf_ops.tpg_get_wwn = &tcm_loop_get_endpoint_wwn;
 +	fabric->tf_ops.tpg_get_tag = &tcm_loop_get_tag;
 +	fabric->tf_ops.tpg_get_default_depth = &tcm_loop_get_default_depth;
 +	fabric->tf_ops.tpg_get_pr_transport_id = &tcm_loop_get_pr_transport_id;
 +	fabric->tf_ops.tpg_get_pr_transport_id_len =
 +					&tcm_loop_get_pr_transport_id_len;
 +	fabric->tf_ops.tpg_parse_pr_out_transport_id =
 +					&tcm_loop_parse_pr_out_transport_id;
 +	fabric->tf_ops.tpg_check_demo_mode = &tcm_loop_check_demo_mode;
 +	fabric->tf_ops.tpg_check_demo_mode_cache =
 +					&tcm_loop_check_demo_mode_cache;
 +	fabric->tf_ops.tpg_check_demo_mode_write_protect =
 +					&tcm_loop_check_demo_mode_write_protect;
 +	fabric->tf_ops.tpg_check_prod_mode_write_protect =
 +					&tcm_loop_check_prod_mode_write_protect;
 +	fabric->tf_ops.tpg_check_prot_fabric_only =
 +					&tcm_loop_check_prot_fabric_only;
 +	/*
 +	 * The TCM loopback fabric module runs in demo-mode to a local
 +	 * virtual SCSI device, so fabric dependent initator ACLs are
 +	 * not required.
 +	 */
 +	fabric->tf_ops.tpg_alloc_fabric_acl = &tcm_loop_tpg_alloc_fabric_acl;
 +	fabric->tf_ops.tpg_release_fabric_acl =
 +					&tcm_loop_tpg_release_fabric_acl;
 +	fabric->tf_ops.tpg_get_inst_index = &tcm_loop_get_inst_index;
 +	/*
 +	 * Used for setting up remaining TCM resources in process context
 +	 */
 +	fabric->tf_ops.check_stop_free = &tcm_loop_check_stop_free;
 +	fabric->tf_ops.release_cmd = &tcm_loop_release_cmd;
 +	fabric->tf_ops.shutdown_session = &tcm_loop_shutdown_session;
 +	fabric->tf_ops.close_session = &tcm_loop_close_session;
 +	fabric->tf_ops.sess_get_index = &tcm_loop_sess_get_index;
 +	fabric->tf_ops.sess_get_initiator_sid = NULL;
 +	fabric->tf_ops.write_pending = &tcm_loop_write_pending;
 +	fabric->tf_ops.write_pending_status = &tcm_loop_write_pending_status;
 +	/*
 +	 * Not used for TCM loopback
 +	 */
 +	fabric->tf_ops.set_default_node_attributes =
 +					&tcm_loop_set_default_node_attributes;
 +	fabric->tf_ops.get_task_tag = &tcm_loop_get_task_tag;
 +	fabric->tf_ops.get_cmd_state = &tcm_loop_get_cmd_state;
 +	fabric->tf_ops.queue_data_in = &tcm_loop_queue_data_in;
 +	fabric->tf_ops.queue_status = &tcm_loop_queue_status;
 +	fabric->tf_ops.queue_tm_rsp = &tcm_loop_queue_tm_rsp;
 +	fabric->tf_ops.aborted_task = &tcm_loop_aborted_task;
 +
 +	/*
 +	 * Setup function pointers for generic logic in target_core_fabric_configfs.c
 +	 */
 +	fabric->tf_ops.fabric_make_wwn = &tcm_loop_make_scsi_hba;
 +	fabric->tf_ops.fabric_drop_wwn = &tcm_loop_drop_scsi_hba;
 +	fabric->tf_ops.fabric_make_tpg = &tcm_loop_make_naa_tpg;
 +	fabric->tf_ops.fabric_drop_tpg = &tcm_loop_drop_naa_tpg;
 +	/*
 +	 * fabric_post_link() and fabric_pre_unlink() are used for
 +	 * registration and release of TCM Loop Virtual SCSI LUNs.
 +	 */
 +	fabric->tf_ops.fabric_post_link = &tcm_loop_port_link;
 +	fabric->tf_ops.fabric_pre_unlink = &tcm_loop_port_unlink;
 +	fabric->tf_ops.fabric_make_np = NULL;
 +	fabric->tf_ops.fabric_drop_np = NULL;
 +	/*
 +	 * Setup default attribute lists for various fabric->tf_cit_tmpl
 +	 */
 +	fabric->tf_cit_tmpl.tfc_wwn_cit.ct_attrs = tcm_loop_wwn_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_base_cit.ct_attrs = tcm_loop_tpg_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_attrib_cit.ct_attrs = tcm_loop_tpg_attrib_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_param_cit.ct_attrs = NULL;
 +	fabric->tf_cit_tmpl.tfc_tpg_np_base_cit.ct_attrs = NULL;
 +	/*
 +	 * Once fabric->tf_ops has been setup, now register the fabric for
 +	 * use within TCM
 +	 */
 +	ret = target_fabric_configfs_register(fabric);
 +	if (ret < 0) {
 +		pr_err("target_fabric_configfs_register() for"
 +				" TCM_Loop failed!\n");
 +		target_fabric_configfs_free(fabric);
 +		return -1;
 +	}
 +	/*
 +	 * Setup our local pointer to *fabric.
 +	 */
 +	tcm_loop_fabric_configfs = fabric;
 +	pr_debug("TCM_LOOP[0] - Set fabric ->"
 +			" tcm_loop_fabric_configfs\n");
 +	return 0;
 +}
 +
 +static void tcm_loop_deregister_configfs(void)
 +{
 +	if (!tcm_loop_fabric_configfs)
 +		return;
 +
 +	target_fabric_configfs_deregister(tcm_loop_fabric_configfs);
 +	tcm_loop_fabric_configfs = NULL;
 +	pr_debug("TCM_LOOP[0] - Cleared"
 +				" tcm_loop_fabric_configfs\n");
 +}
++=======
+ static const struct target_core_fabric_ops loop_ops = {
+ 	.module				= THIS_MODULE,
+ 	.name				= "loopback",
+ 	.get_fabric_name		= tcm_loop_get_fabric_name,
+ 	.tpg_get_wwn			= tcm_loop_get_endpoint_wwn,
+ 	.tpg_get_tag			= tcm_loop_get_tag,
+ 	.tpg_check_demo_mode		= tcm_loop_check_demo_mode,
+ 	.tpg_check_demo_mode_cache	= tcm_loop_check_demo_mode_cache,
+ 	.tpg_check_demo_mode_write_protect =
+ 				tcm_loop_check_demo_mode_write_protect,
+ 	.tpg_check_prod_mode_write_protect =
+ 				tcm_loop_check_prod_mode_write_protect,
+ 	.tpg_check_prot_fabric_only	= tcm_loop_check_prot_fabric_only,
+ 	.tpg_get_inst_index		= tcm_loop_get_inst_index,
+ 	.check_stop_free		= tcm_loop_check_stop_free,
+ 	.release_cmd			= tcm_loop_release_cmd,
+ 	.shutdown_session		= tcm_loop_shutdown_session,
+ 	.close_session			= tcm_loop_close_session,
+ 	.sess_get_index			= tcm_loop_sess_get_index,
+ 	.write_pending			= tcm_loop_write_pending,
+ 	.write_pending_status		= tcm_loop_write_pending_status,
+ 	.set_default_node_attributes	= tcm_loop_set_default_node_attributes,
+ 	.get_cmd_state			= tcm_loop_get_cmd_state,
+ 	.queue_data_in			= tcm_loop_queue_data_in,
+ 	.queue_status			= tcm_loop_queue_status,
+ 	.queue_tm_rsp			= tcm_loop_queue_tm_rsp,
+ 	.aborted_task			= tcm_loop_aborted_task,
+ 	.fabric_make_wwn		= tcm_loop_make_scsi_hba,
+ 	.fabric_drop_wwn		= tcm_loop_drop_scsi_hba,
+ 	.fabric_make_tpg		= tcm_loop_make_naa_tpg,
+ 	.fabric_drop_tpg		= tcm_loop_drop_naa_tpg,
+ 	.fabric_post_link		= tcm_loop_port_link,
+ 	.fabric_pre_unlink		= tcm_loop_port_unlink,
+ 	.tfc_wwn_attrs			= tcm_loop_wwn_attrs,
+ 	.tfc_tpg_base_attrs		= tcm_loop_tpg_attrs,
+ 	.tfc_tpg_attrib_attrs		= tcm_loop_tpg_attrib_attrs,
+ };
++>>>>>>> 649ee05499d1 (target: Move task tag into struct se_cmd + support 64-bit tags)
  
  static int __init tcm_loop_fabric_init(void)
  {
diff --cc drivers/vhost/scsi.c
index 65142d377371,4a003948b07f..000000000000
--- a/drivers/vhost/scsi.c
+++ b/drivers/vhost/scsi.c
@@@ -480,12 -369,7 +480,16 @@@ static void tcm_vhost_set_default_node_
  	return;
  }
  
++<<<<<<< HEAD
 +static u32 tcm_vhost_get_task_tag(struct se_cmd *se_cmd)
 +{
 +	return 0;
 +}
 +
 +static int tcm_vhost_get_cmd_state(struct se_cmd *se_cmd)
++=======
+ static int vhost_scsi_get_cmd_state(struct se_cmd *se_cmd)
++>>>>>>> 649ee05499d1 (target: Move task tag into struct se_cmd + support 64-bit tags)
  {
  	return 0;
  }
@@@ -840,14 -811,16 +844,15 @@@ static void tcm_vhost_submission_work(s
  	} else {
  		sg_ptr = NULL;
  	}
 -	tv_nexus = cmd->tvc_nexus;
 +	tv_nexus = tv_cmd->tvc_nexus;
  
+ 	se_cmd->tag = 0;
  	rc = target_submit_cmd_map_sgls(se_cmd, tv_nexus->tvn_se_sess,
 -			cmd->tvc_cdb, &cmd->tvc_sense_buf[0],
 -			cmd->tvc_lun, cmd->tvc_exp_data_len,
 -			vhost_scsi_to_tcm_attr(cmd->tvc_task_attr),
 -			cmd->tvc_data_direction, TARGET_SCF_ACK_KREF,
 -			sg_ptr, cmd->tvc_sgl_count, NULL, 0, sg_prot_ptr,
 -			cmd->tvc_prot_sgl_count);
 +			tv_cmd->tvc_cdb, &tv_cmd->tvc_sense_buf[0],
 +			tv_cmd->tvc_lun, tv_cmd->tvc_exp_data_len,
 +			tv_cmd->tvc_task_attr, tv_cmd->tvc_data_direction,
 +			0, sg_ptr, tv_cmd->tvc_sgl_count,
 +			sg_bidi_ptr, sg_no_bidi);
  	if (rc < 0) {
  		transport_send_check_condition_and_sense(se_cmd,
  				TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE, 0);
@@@ -1989,35 -2123,32 +1994,46 @@@ static struct configfs_attribute *tcm_v
  	NULL,
  };
  
 -static struct target_core_fabric_ops vhost_scsi_ops = {
 -	.module				= THIS_MODULE,
 -	.name				= "vhost",
 -	.get_fabric_name		= vhost_scsi_get_fabric_name,
 -	.tpg_get_wwn			= vhost_scsi_get_fabric_wwn,
 -	.tpg_get_tag			= vhost_scsi_get_tpgt,
 -	.tpg_check_demo_mode		= vhost_scsi_check_true,
 -	.tpg_check_demo_mode_cache	= vhost_scsi_check_true,
 -	.tpg_check_demo_mode_write_protect = vhost_scsi_check_false,
 -	.tpg_check_prod_mode_write_protect = vhost_scsi_check_false,
 -	.tpg_check_prot_fabric_only	= vhost_scsi_check_prot_fabric_only,
 -	.tpg_get_inst_index		= vhost_scsi_tpg_get_inst_index,
 -	.release_cmd			= vhost_scsi_release_cmd,
 -	.check_stop_free		= vhost_scsi_check_stop_free,
 -	.shutdown_session		= vhost_scsi_shutdown_session,
 -	.close_session			= vhost_scsi_close_session,
 -	.sess_get_index			= vhost_scsi_sess_get_index,
 +static struct target_core_fabric_ops tcm_vhost_ops = {
 +	.get_fabric_name		= tcm_vhost_get_fabric_name,
 +	.get_fabric_proto_ident		= tcm_vhost_get_fabric_proto_ident,
 +	.tpg_get_wwn			= tcm_vhost_get_fabric_wwn,
 +	.tpg_get_tag			= tcm_vhost_get_tag,
 +	.tpg_get_default_depth		= tcm_vhost_get_default_depth,
 +	.tpg_get_pr_transport_id	= tcm_vhost_get_pr_transport_id,
 +	.tpg_get_pr_transport_id_len	= tcm_vhost_get_pr_transport_id_len,
 +	.tpg_parse_pr_out_transport_id	= tcm_vhost_parse_pr_out_transport_id,
 +	.tpg_check_demo_mode		= tcm_vhost_check_true,
 +	.tpg_check_demo_mode_cache	= tcm_vhost_check_true,
 +	.tpg_check_demo_mode_write_protect = tcm_vhost_check_false,
 +	.tpg_check_prod_mode_write_protect = tcm_vhost_check_false,
 +	.tpg_alloc_fabric_acl		= tcm_vhost_alloc_fabric_acl,
 +	.tpg_release_fabric_acl		= tcm_vhost_release_fabric_acl,
 +	.tpg_get_inst_index		= tcm_vhost_tpg_get_inst_index,
 +	.release_cmd			= tcm_vhost_release_cmd,
 +	.shutdown_session		= tcm_vhost_shutdown_session,
 +	.close_session			= tcm_vhost_close_session,
 +	.sess_get_index			= tcm_vhost_sess_get_index,
  	.sess_get_initiator_sid		= NULL,
++<<<<<<< HEAD
 +	.write_pending			= tcm_vhost_write_pending,
 +	.write_pending_status		= tcm_vhost_write_pending_status,
 +	.set_default_node_attributes	= tcm_vhost_set_default_node_attrs,
 +	.get_task_tag			= tcm_vhost_get_task_tag,
 +	.get_cmd_state			= tcm_vhost_get_cmd_state,
 +	.queue_data_in			= tcm_vhost_queue_data_in,
 +	.queue_status			= tcm_vhost_queue_status,
 +	.queue_tm_rsp			= tcm_vhost_queue_tm_rsp,
++=======
+ 	.write_pending			= vhost_scsi_write_pending,
+ 	.write_pending_status		= vhost_scsi_write_pending_status,
+ 	.set_default_node_attributes	= vhost_scsi_set_default_node_attrs,
+ 	.get_cmd_state			= vhost_scsi_get_cmd_state,
+ 	.queue_data_in			= vhost_scsi_queue_data_in,
+ 	.queue_status			= vhost_scsi_queue_status,
+ 	.queue_tm_rsp			= vhost_scsi_queue_tm_rsp,
+ 	.aborted_task			= vhost_scsi_aborted_task,
++>>>>>>> 649ee05499d1 (target: Move task tag into struct se_cmd + support 64-bit tags)
  	/*
  	 * Setup callers for generic logic in target_core_fabric_configfs.c
  	 */
* Unmerged path drivers/xen/xen-scsiback.c
diff --git a/Documentation/target/tcm_mod_builder.py b/Documentation/target/tcm_mod_builder.py
index 3fe0d812dcec..392a33d1ae3c 100755
--- a/Documentation/target/tcm_mod_builder.py
+++ b/Documentation/target/tcm_mod_builder.py
@@ -397,7 +397,6 @@ def tcm_mod_build_configfs(proto_ident, fabric_mod_dir_var, fabric_mod_name):
 	buf += "	.write_pending			= " + fabric_mod_name + "_write_pending,\n"
 	buf += "	.write_pending_status		= " + fabric_mod_name + "_write_pending_status,\n"
 	buf += "	.set_default_node_attributes	= " + fabric_mod_name + "_set_default_node_attrs,\n"
-	buf += "	.get_task_tag			= " + fabric_mod_name + "_get_task_tag,\n"
 	buf += "	.get_cmd_state			= " + fabric_mod_name + "_get_cmd_state,\n"
 	buf += "	.queue_data_in			= " + fabric_mod_name + "_queue_data_in,\n"
 	buf += "	.queue_status			= " + fabric_mod_name + "_queue_status,\n"
@@ -869,13 +868,6 @@ def tcm_mod_dump_fabric_ops(proto_ident, fabric_mod_dir_var, fabric_mod_name):
 			buf += "}\n\n"
 			bufi += "void " + fabric_mod_name + "_set_default_node_attrs(struct se_node_acl *);\n"
 
-		if re.search('get_task_tag\)\(', fo):
-			buf += "u32 " + fabric_mod_name + "_get_task_tag(struct se_cmd *se_cmd)\n"
-			buf += "{\n"
-			buf += "	return 0;\n"
-			buf += "}\n\n"
-			bufi += "u32 " + fabric_mod_name + "_get_task_tag(struct se_cmd *);\n"
-
 		if re.search('get_cmd_state\)\(', fo):
 			buf += "int " + fabric_mod_name + "_get_cmd_state(struct se_cmd *se_cmd)\n"
 			buf += "{\n"
* Unmerged path drivers/infiniband/ulp/srpt/ib_srpt.c
* Unmerged path drivers/infiniband/ulp/srpt/ib_srpt.h
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
diff --git a/drivers/scsi/qla2xxx/qla_target.h b/drivers/scsi/qla2xxx/qla_target.h
index b33e411f28a0..f1195ba71f64 100644
--- a/drivers/scsi/qla2xxx/qla_target.h
+++ b/drivers/scsi/qla2xxx/qla_target.h
@@ -848,7 +848,6 @@ struct qla_tgt_cmd {
 	int sg_cnt;		/* SG segments count */
 	int bufflen;		/* cmd buffer length */
 	int offset;
-	uint32_t tag;
 	uint32_t unpacked_lun;
 	enum dma_data_direction dma_data_direction;
 
* Unmerged path drivers/scsi/qla2xxx/tcm_qla2xxx.c
diff --git a/drivers/target/iscsi/iscsi_target.c b/drivers/target/iscsi/iscsi_target.c
index 656b0401c6e2..878e43fe2a3f 100644
--- a/drivers/target/iscsi/iscsi_target.c
+++ b/drivers/target/iscsi/iscsi_target.c
@@ -1156,6 +1156,8 @@ int iscsit_setup_scsi_cmd(struct iscsi_conn *conn, struct iscsi_cmd *cmd,
 	if (cmd->sense_reason)
 		goto attach_cmd;
 
+	/* only used for printks or comparing with ->ref_task_tag */
+	cmd->se_cmd.tag = (__force u32)cmd->init_task_tag;
 	cmd->sense_reason = target_setup_cmd_from_cdb(&cmd->se_cmd, hdr->cdb);
 	if (cmd->sense_reason) {
 		if (cmd->sense_reason == TCM_OUT_OF_RESOURCES) {
* Unmerged path drivers/target/iscsi/iscsi_target_configfs.c
* Unmerged path drivers/target/loopback/tcm_loop.c
diff --git a/drivers/target/sbp/sbp_target.c b/drivers/target/sbp/sbp_target.c
index b33c121ab56c..1ad3142e6621 100644
--- a/drivers/target/sbp/sbp_target.c
+++ b/drivers/target/sbp/sbp_target.c
@@ -1235,6 +1235,8 @@ static void sbp_handle_command(struct sbp_target_request *req)
 	pr_debug("sbp_handle_command ORB:0x%llx unpacked_lun:%d data_len:%d data_dir:%d\n",
 			req->orb_pointer, unpacked_lun, data_length, data_dir);
 
+	/* only used for printk until we do TMRs */
+	req->se_cmd.tag = req->orb_pointer;
 	if (target_submit_cmd(&req->se_cmd, sess->se_sess, req->cmd_buf,
 			      req->sense_buf, unpacked_lun, data_length,
 			      TCM_SIMPLE_TAG, data_dir, 0))
@@ -1786,15 +1788,6 @@ static void sbp_set_default_node_attrs(struct se_node_acl *nacl)
 	return;
 }
 
-static u32 sbp_get_task_tag(struct se_cmd *se_cmd)
-{
-	struct sbp_target_request *req = container_of(se_cmd,
-			struct sbp_target_request, se_cmd);
-
-	/* only used for printk until we do TMRs */
-	return (u32)req->orb_pointer;
-}
-
 static int sbp_get_cmd_state(struct se_cmd *se_cmd)
 {
 	return 0;
@@ -2508,7 +2501,6 @@ static struct target_core_fabric_ops sbp_ops = {
 	.write_pending			= sbp_write_pending,
 	.write_pending_status		= sbp_write_pending_status,
 	.set_default_node_attributes	= sbp_set_default_node_attrs,
-	.get_task_tag			= sbp_get_task_tag,
 	.get_cmd_state			= sbp_get_cmd_state,
 	.queue_data_in			= sbp_queue_data_in,
 	.queue_status			= sbp_queue_status,
diff --git a/drivers/target/target_core_configfs.c b/drivers/target/target_core_configfs.c
index 372df6e87bcb..9b3c70fe79cf 100644
--- a/drivers/target/target_core_configfs.c
+++ b/drivers/target/target_core_configfs.c
@@ -459,10 +459,6 @@ static int target_fabric_tf_ops_check(
 		pr_err("Missing tfo->set_default_node_attributes()\n");
 		return -EINVAL;
 	}
-	if (!tfo->get_task_tag) {
-		pr_err("Missing tfo->get_task_tag()\n");
-		return -EINVAL;
-	}
 	if (!tfo->get_cmd_state) {
 		pr_err("Missing tfo->get_cmd_state()\n");
 		return -EINVAL;
diff --git a/drivers/target/target_core_tmr.c b/drivers/target/target_core_tmr.c
index b2e169fba3c6..393aca8bb3eb 100644
--- a/drivers/target/target_core_tmr.c
+++ b/drivers/target/target_core_tmr.c
@@ -117,7 +117,7 @@ void core_tmr_abort_task(
 {
 	struct se_cmd *se_cmd;
 	unsigned long flags;
-	int ref_tag;
+	u64 ref_tag;
 
 	spin_lock_irqsave(&se_sess->sess_cmd_lock, flags);
 	list_for_each_entry(se_cmd, &se_sess->sess_cmd_list, se_cmd_list) {
@@ -129,16 +129,17 @@ void core_tmr_abort_task(
 		if (se_cmd->se_cmd_flags & SCF_SCSI_TMR_CDB)
 			continue;
 
-		ref_tag = se_cmd->se_tfo->get_task_tag(se_cmd);
+		ref_tag = se_cmd->tag;
 		if (tmr->ref_task_tag != ref_tag)
 			continue;
 
-		printk("ABORT_TASK: Found referenced %s task_tag: %u\n",
+		printk("ABORT_TASK: Found referenced %s task_tag: %llu\n",
 			se_cmd->se_tfo->get_fabric_name(), ref_tag);
 
 		spin_lock(&se_cmd->t_state_lock);
 		if (se_cmd->transport_state & CMD_T_COMPLETE) {
-			printk("ABORT_TASK: ref_tag: %u already complete, skipping\n", ref_tag);
+			printk("ABORT_TASK: ref_tag: %llu already complete,"
+			       " skipping\n", ref_tag);
 			spin_unlock(&se_cmd->t_state_lock);
 			spin_unlock_irqrestore(&se_sess->sess_cmd_lock, flags);
 			goto out;
@@ -157,14 +158,14 @@ void core_tmr_abort_task(
 		transport_cmd_finish_abort(se_cmd, true);
 
 		printk("ABORT_TASK: Sending TMR_FUNCTION_COMPLETE for"
-				" ref_tag: %d\n", ref_tag);
+				" ref_tag: %llu\n", ref_tag);
 		tmr->response = TMR_FUNCTION_COMPLETE;
 		return;
 	}
 	spin_unlock_irqrestore(&se_sess->sess_cmd_lock, flags);
 
 out:
-	printk("ABORT_TASK: Sending TMR_TASK_DOES_NOT_EXIST for ref_tag: %d\n",
+	printk("ABORT_TASK: Sending TMR_TASK_DOES_NOT_EXIST for ref_tag: %lld\n",
 			tmr->ref_task_tag);
 	tmr->response = TMR_TASK_DOES_NOT_EXIST;
 }
@@ -289,16 +290,16 @@ static void core_tmr_drain_state_list(
 		list_del(&cmd->state_list);
 
 		pr_debug("LUN_RESET: %s cmd: %p"
-			" ITT/CmdSN: 0x%08x/0x%08x, i_state: %d, t_state: %d"
+			" ITT/CmdSN: 0x%08llx/0x%08x, i_state: %d, t_state: %d"
 			"cdb: 0x%02x\n",
 			(preempt_and_abort_list) ? "Preempt" : "", cmd,
-			cmd->se_tfo->get_task_tag(cmd), 0,
+			cmd->tag, 0,
 			cmd->se_tfo->get_cmd_state(cmd), cmd->t_state,
 			cmd->t_task_cdb[0]);
-		pr_debug("LUN_RESET: ITT[0x%08x] - pr_res_key: 0x%016Lx"
+		pr_debug("LUN_RESET: ITT[0x%08llx] - pr_res_key: 0x%016Lx"
 			" -- CMD_T_ACTIVE: %d"
 			" CMD_T_STOP: %d CMD_T_SENT: %d\n",
-			cmd->se_tfo->get_task_tag(cmd), cmd->pr_res_key,
+			cmd->tag, cmd->pr_res_key,
 			(cmd->transport_state & CMD_T_ACTIVE) != 0,
 			(cmd->transport_state & CMD_T_STOP) != 0,
 			(cmd->transport_state & CMD_T_SENT) != 0);
diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c
index 9cc3afa0ef11..2f180a71e4ce 100644
--- a/drivers/target/target_core_transport.c
+++ b/drivers/target/target_core_transport.c
@@ -594,9 +594,8 @@ static int transport_cmd_check_stop(struct se_cmd *cmd, bool remove_from_lists,
 	 * this command for frontend exceptions.
 	 */
 	if (cmd->transport_state & CMD_T_STOP) {
-		pr_debug("%s:%d CMD_T_STOP for ITT: 0x%08x\n",
-			__func__, __LINE__,
-			cmd->se_tfo->get_task_tag(cmd));
+		pr_debug("%s:%d CMD_T_STOP for ITT: 0x%08llx\n",
+			__func__, __LINE__, cmd->tag);
 
 		spin_unlock_irqrestore(&cmd->t_state_lock, flags);
 
@@ -1168,6 +1167,8 @@ target_cmd_size_check(struct se_cmd *cmd, unsigned int size)
 /*
  * Used by fabric modules containing a local struct se_cmd within their
  * fabric dependent per I/O descriptor.
+ *
+ * Preserves the value of @cmd->tag.
  */
 void transport_init_se_cmd(
 	struct se_cmd *cmd,
@@ -1393,6 +1394,8 @@ transport_generic_map_mem_to_cmd(struct se_cmd *cmd, struct scatterlist *sgl,
  * @sgl_prot: struct scatterlist memory protection information
  * @sgl_prot_count: scatterlist count for protection information
  *
+ * Task tags are supported if the caller has set @se_cmd->tag.
+ *
  * Returns non zero to signal active I/O shutdown failure.  All other
  * setup exceptions will be returned as a SCSI CHECK_CONDITION response,
  * but still return zero here.
@@ -1525,6 +1528,8 @@ EXPORT_SYMBOL(target_submit_cmd_map_sgls);
  * @data_dir: DMA data direction
  * @flags: flags for command submission from target_sc_flags_tables
  *
+ * Task tags are supported if the caller has set @se_cmd->tag.
+ *
  * Returns non zero to signal active I/O shutdown failure.  All other
  * setup exceptions will be returned as a SCSI CHECK_CONDITION response,
  * but still return zero here.
@@ -1650,9 +1655,8 @@ void transport_generic_request_failure(struct se_cmd *cmd,
 {
 	int ret = 0;
 
-	pr_debug("-----[ Storage Engine Exception for cmd: %p ITT: 0x%08x"
-		" CDB: 0x%02x\n", cmd, cmd->se_tfo->get_task_tag(cmd),
-		cmd->t_task_cdb[0]);
+	pr_debug("-----[ Storage Engine Exception for cmd: %p ITT: 0x%08llx"
+		" CDB: 0x%02x\n", cmd, cmd->tag, cmd->t_task_cdb[0]);
 	pr_debug("-----[ i_state: %d t_state: %d sense_reason: %d\n",
 		cmd->se_tfo->get_cmd_state(cmd),
 		cmd->t_state, sense_reason);
@@ -1859,9 +1863,8 @@ void target_execute_cmd(struct se_cmd *cmd)
 	 */
 	spin_lock_irq(&cmd->t_state_lock);
 	if (cmd->transport_state & CMD_T_STOP) {
-		pr_debug("%s:%d CMD_T_STOP for ITT: 0x%08x\n",
-			__func__, __LINE__,
-			cmd->se_tfo->get_task_tag(cmd));
+		pr_debug("%s:%d CMD_T_STOP for ITT: 0x%08llx\n",
+			__func__, __LINE__, cmd->tag);
 
 		spin_unlock_irq(&cmd->t_state_lock);
 		complete_all(&cmd->t_transport_stop_comp);
@@ -2699,10 +2702,8 @@ bool transport_wait_for_tasks(struct se_cmd *cmd)
 
 	cmd->transport_state |= CMD_T_STOP;
 
-	pr_debug("wait_for_tasks: Stopping %p ITT: 0x%08x"
-		" i_state: %d, t_state: %d, CMD_T_STOP\n",
-		cmd, cmd->se_tfo->get_task_tag(cmd),
-		cmd->se_tfo->get_cmd_state(cmd), cmd->t_state);
+	pr_debug("wait_for_tasks: Stopping %p ITT: 0x%08llx i_state: %d, t_state: %d, CMD_T_STOP\n",
+		cmd, cmd->tag, cmd->se_tfo->get_cmd_state(cmd), cmd->t_state);
 
 	spin_unlock_irqrestore(&cmd->t_state_lock, flags);
 
@@ -2711,9 +2712,8 @@ bool transport_wait_for_tasks(struct se_cmd *cmd)
 	spin_lock_irqsave(&cmd->t_state_lock, flags);
 	cmd->transport_state &= ~(CMD_T_ACTIVE | CMD_T_STOP);
 
-	pr_debug("wait_for_tasks: Stopped wait_for_completion("
-		"&cmd->t_transport_stop_comp) for ITT: 0x%08x\n",
-		cmd->se_tfo->get_task_tag(cmd));
+	pr_debug("wait_for_tasks: Stopped wait_for_completion(&cmd->t_transport_stop_comp) for ITT: 0x%08llx\n",
+		cmd->tag);
 
 	spin_unlock_irqrestore(&cmd->t_state_lock, flags);
 
@@ -3015,8 +3015,8 @@ int transport_check_aborted_status(struct se_cmd *cmd, int send_status)
 	if (!send_status || !(cmd->se_cmd_flags & SCF_SEND_DELAYED_TAS))
 		return 1;
 
-	pr_debug("Sending delayed SAM_STAT_TASK_ABORTED status for CDB: 0x%02x ITT: 0x%08x\n",
-		 cmd->t_task_cdb[0], cmd->se_tfo->get_task_tag(cmd));
+	pr_debug("Sending delayed SAM_STAT_TASK_ABORTED status for CDB: 0x%02x ITT: 0x%08llx\n",
+		 cmd->t_task_cdb[0], cmd->tag);
 
 	cmd->se_cmd_flags &= ~SCF_SEND_DELAYED_TAS;
 	cmd->scsi_status = SAM_STAT_TASK_ABORTED;
@@ -3056,9 +3056,8 @@ void transport_send_task_abort(struct se_cmd *cmd)
 
 	transport_lun_remove_cmd(cmd);
 
-	pr_debug("Setting SAM_STAT_TASK_ABORTED status for CDB: 0x%02x,"
-		" ITT: 0x%08x\n", cmd->t_task_cdb[0],
-		cmd->se_tfo->get_task_tag(cmd));
+	pr_debug("Setting SAM_STAT_TASK_ABORTED status for CDB: 0x%02x, ITT: 0x%08llx\n",
+		 cmd->t_task_cdb[0], cmd->tag);
 
 	trace_target_cmd_complete(cmd);
 	ret = cmd->se_tfo->queue_status(cmd);
diff --git a/drivers/target/target_core_xcopy.c b/drivers/target/target_core_xcopy.c
index 32a82dc5ac30..49c8b86ef558 100644
--- a/drivers/target/target_core_xcopy.c
+++ b/drivers/target/target_core_xcopy.c
@@ -361,11 +361,6 @@ static char *xcopy_pt_get_fabric_name(void)
         return "xcopy-pt";
 }
 
-static u32 xcopy_pt_get_tag(struct se_cmd *se_cmd)
-{
-        return 0;
-}
-
 static int xcopy_pt_get_cmd_state(struct se_cmd *se_cmd)
 {
         return 0;
@@ -427,7 +422,6 @@ static int xcopy_pt_queue_status(struct se_cmd *se_cmd)
 
 static struct target_core_fabric_ops xcopy_pt_tfo = {
 	.get_fabric_name	= xcopy_pt_get_fabric_name,
-	.get_task_tag		= xcopy_pt_get_tag,
 	.get_cmd_state		= xcopy_pt_get_cmd_state,
 	.release_cmd		= xcopy_pt_release_cmd,
 	.check_stop_free	= xcopy_pt_check_stop_free,
@@ -592,6 +586,7 @@ static int target_xcopy_setup_pt_cmd(
 	xpt_cmd->xcopy_op = xop;
 	target_xcopy_setup_pt_port(xpt_cmd, xop, remote_port);
 
+	cmd->tag = 0;
 	sense_rc = target_setup_cmd_from_cdb(cmd, cdb);
 	if (sense_rc) {
 		ret = -EINVAL;
diff --git a/drivers/target/tcm_fc/tcm_fc.h b/drivers/target/tcm_fc/tcm_fc.h
index a0bcfd3e7e7d..bfd108222a76 100644
--- a/drivers/target/tcm_fc/tcm_fc.h
+++ b/drivers/target/tcm_fc/tcm_fc.h
@@ -158,7 +158,6 @@ int ft_queue_status(struct se_cmd *);
 int ft_queue_data_in(struct se_cmd *);
 int ft_write_pending(struct se_cmd *);
 int ft_write_pending_status(struct se_cmd *);
-u32 ft_get_task_tag(struct se_cmd *);
 int ft_get_cmd_state(struct se_cmd *);
 void ft_queue_tm_resp(struct se_cmd *);
 void ft_aborted_task(struct se_cmd *);
diff --git a/drivers/target/tcm_fc/tfc_cmd.c b/drivers/target/tcm_fc/tfc_cmd.c
index edcafa4490c0..a8fe6ed5262f 100644
--- a/drivers/target/tcm_fc/tfc_cmd.c
+++ b/drivers/target/tcm_fc/tfc_cmd.c
@@ -247,15 +247,6 @@ int ft_write_pending(struct se_cmd *se_cmd)
 	return 0;
 }
 
-u32 ft_get_task_tag(struct se_cmd *se_cmd)
-{
-	struct ft_cmd *cmd = container_of(se_cmd, struct ft_cmd, se_cmd);
-
-	if (cmd->aborted)
-		return ~0;
-	return fc_seq_exch(cmd->seq)->rxid;
-}
-
 int ft_get_cmd_state(struct se_cmd *se_cmd)
 {
 	return 0;
@@ -568,6 +559,7 @@ static void ft_send_work(struct work_struct *work)
 	}
 
 	fc_seq_exch(cmd->seq)->lp->tt.seq_set_resp(cmd->seq, ft_recv_seq, cmd);
+	cmd->se_cmd.tag = fc_seq_exch(cmd->seq)->rxid;
 	/*
 	 * Use a single se_cmd->cmd_kref as we expect to release se_cmd
 	 * directly from ft_check_stop_free callback in response path.
diff --git a/drivers/target/tcm_fc/tfc_conf.c b/drivers/target/tcm_fc/tfc_conf.c
index 8f5b91a74d09..f482c3c6088a 100644
--- a/drivers/target/tcm_fc/tfc_conf.c
+++ b/drivers/target/tcm_fc/tfc_conf.c
@@ -531,7 +531,6 @@ static struct target_core_fabric_ops ft_fabric_ops = {
 	.write_pending =		ft_write_pending,
 	.write_pending_status =		ft_write_pending_status,
 	.set_default_node_attributes =	ft_set_default_node_attr,
-	.get_task_tag =			ft_get_task_tag,
 	.get_cmd_state =		ft_get_cmd_state,
 	.queue_data_in =		ft_queue_data_in,
 	.queue_status =			ft_queue_status,
diff --git a/drivers/usb/gadget/tcm_usb_gadget.c b/drivers/usb/gadget/tcm_usb_gadget.c
index 7cacd6ae818e..ccfc4a41e0b6 100644
--- a/drivers/usb/gadget/tcm_usb_gadget.c
+++ b/drivers/usb/gadget/tcm_usb_gadget.c
@@ -1112,6 +1112,7 @@ static int usbg_submit_command(struct f_uas *fu,
 	memcpy(cmd->cmd_buf, cmd_iu->cdb, cmd_len);
 
 	cmd->tag = be16_to_cpup(&cmd_iu->tag);
+	cmd->se_cmd.tag = cmd->tag;
 	if (fu->flags & USBG_USE_STREAMS) {
 		if (cmd->tag > UASP_SS_EP_COMP_NUM_STREAMS)
 			goto err;
@@ -1245,6 +1246,7 @@ static int bot_submit_command(struct f_uas *fu,
 	cmd->unpacked_lun = cbw->Lun;
 	cmd->is_read = cbw->Flags & US_BULK_FLAG_IN ? 1 : 0;
 	cmd->data_len = le32_to_cpu(cbw->DataTransferLength);
+	cmd->se_cmd.tag = le32_to_cpu(cmd->bot_tag);
 
 	INIT_WORK(&cmd->work, bot_cmd_work);
 	ret = queue_work(tpg->workqueue, &cmd->work);
@@ -1450,18 +1452,6 @@ static void usbg_set_default_node_attrs(struct se_node_acl *nacl)
 	return;
 }
 
-static u32 usbg_get_task_tag(struct se_cmd *se_cmd)
-{
-	struct usbg_cmd *cmd = container_of(se_cmd, struct usbg_cmd,
-			se_cmd);
-	struct f_uas *fu = cmd->fu;
-
-	if (fu->flags & USBG_IS_BOT)
-		return le32_to_cpu(cmd->bot_tag);
-	else
-		return cmd->tag;
-}
-
 static int usbg_get_cmd_state(struct se_cmd *se_cmd)
 {
 	return 0;
@@ -1893,7 +1883,6 @@ static struct target_core_fabric_ops usbg_ops = {
 	.write_pending			= usbg_send_write_request,
 	.write_pending_status		= usbg_write_pending_status,
 	.set_default_node_attributes	= usbg_set_default_node_attrs,
-	.get_task_tag			= usbg_get_task_tag,
 	.get_cmd_state			= usbg_get_cmd_state,
 	.queue_data_in			= usbg_send_read_response,
 	.queue_status			= usbg_send_status_response,
* Unmerged path drivers/vhost/scsi.c
* Unmerged path drivers/xen/xen-scsiback.c
diff --git a/include/target/target_core_base.h b/include/target/target_core_base.h
index 7bcf92529421..7bd622d4f6bf 100644
--- a/include/target/target_core_base.h
+++ b/include/target/target_core_base.h
@@ -430,7 +430,7 @@ struct se_tmr_req {
 	u8			response;
 	int			call_transport;
 	/* Reference to ITT that Task Mgmt should be performed */
-	u32			ref_task_tag;
+	u64			ref_task_tag;
 	void 			*fabric_tmr_ptr;
 	struct se_cmd		*task_cmd;
 	struct se_device	*tmr_dev;
@@ -483,6 +483,7 @@ struct se_cmd {
 	u8			scsi_asc;
 	u8			scsi_ascq;
 	u16			scsi_sense_length;
+	u64			tag; /* SAM command identifier aka task tag */
 	/* Delay for ALUA Active/NonOptimized state access in milliseconds */
 	int			alua_nonop_delay;
 	/* See include/linux/dma-mapping.h */
diff --git a/include/target/target_core_fabric.h b/include/target/target_core_fabric.h
index c9a57a197803..59e06b8a1968 100644
--- a/include/target/target_core_fabric.h
+++ b/include/target/target_core_fabric.h
@@ -65,7 +65,6 @@ struct target_core_fabric_ops {
 	int (*write_pending)(struct se_cmd *);
 	int (*write_pending_status)(struct se_cmd *);
 	void (*set_default_node_attributes)(struct se_node_acl *);
-	u32 (*get_task_tag)(struct se_cmd *);
 	int (*get_cmd_state)(struct se_cmd *);
 	int (*queue_data_in)(struct se_cmd *);
 	int (*queue_status)(struct se_cmd *);
