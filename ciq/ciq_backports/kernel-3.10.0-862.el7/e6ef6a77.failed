scsi: lpfc: prevent potential null pointer dereference

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] lpfc: prevent potential null pointer dereference (Dick Kennedy) [1385844 1461977 1387768]
Rebuild_FUZZ: 94.12%
commit-author Gustavo A. R. Silva <garsilva@embeddedor.com>
commit e6ef6a77f51e403a1400241b9d029ecaba45a834
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e6ef6a77.failed

Null check at line 966: if (ndlp) {, implies that ndlp might be NULL.
Functions lpfc_nlp_set_state() and lpfc_issue_els_prli() dereference
pointer ndlp. Include these function calls inside the IF block that
tests pointer ndlp.

Addresses-Coverity-ID: 1401856
	Signed-off-by: Gustavo A. R. Silva <garsilva@embeddedor.com>
	Acked-by: James Smart <james.smart@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit e6ef6a77f51e403a1400241b9d029ecaba45a834)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_ct.c
diff --cc drivers/scsi/lpfc/lpfc_ct.c
index 17226d4467be,24ce96dcc94d..000000000000
--- a/drivers/scsi/lpfc/lpfc_ct.c
+++ b/drivers/scsi/lpfc/lpfc_ct.c
@@@ -881,6 -933,61 +881,64 @@@ out
  	return;
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ lpfc_cmpl_ct_cmd_gft_id(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,
+ 				struct lpfc_iocbq *rspiocb)
+ {
+ 	struct lpfc_vport *vport = cmdiocb->vport;
+ 	IOCB_t *irsp = &rspiocb->iocb;
+ 	struct lpfc_dmabuf *inp = (struct lpfc_dmabuf *)cmdiocb->context1;
+ 	struct lpfc_dmabuf *outp = (struct lpfc_dmabuf *)cmdiocb->context2;
+ 	struct lpfc_sli_ct_request *CTrsp;
+ 	int did;
+ 	struct lpfc_nodelist *ndlp;
+ 	uint32_t fc4_data_0, fc4_data_1;
+ 
+ 	did = ((struct lpfc_sli_ct_request *)inp->virt)->un.gft.PortId;
+ 	did = be32_to_cpu(did);
+ 
+ 	lpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,
+ 			      "GFT_ID cmpl: status:x%x/x%x did:x%x",
+ 			      irsp->ulpStatus, irsp->un.ulpWord[4], did);
+ 
+ 	if (irsp->ulpStatus == IOSTAT_SUCCESS) {
+ 		/* Good status, continue checking */
+ 		CTrsp = (struct lpfc_sli_ct_request *)outp->virt;
+ 		fc4_data_0 = be32_to_cpu(CTrsp->un.gft_acc.fc4_types[0]);
+ 		fc4_data_1 = be32_to_cpu(CTrsp->un.gft_acc.fc4_types[1]);
+ 		lpfc_printf_vlog(vport, KERN_ERR, LOG_DISCOVERY,
+ 				 "3062 DID x%06x GFT Wd0 x%08x Wd1 x%08x\n",
+ 				 did, fc4_data_0, fc4_data_1);
+ 
+ 		ndlp = lpfc_findnode_did(vport, did);
+ 		if (ndlp) {
+ 			/* The bitmask value for FCP and NVME FCP types is
+ 			 * the same because they are 32 bits distant from
+ 			 * each other in word0 and word0.
+ 			 */
+ 			if (fc4_data_0 & LPFC_FC4_TYPE_BITMASK)
+ 				ndlp->nlp_fc4_type |= NLP_FC4_FCP;
+ 			if (fc4_data_1 &  LPFC_FC4_TYPE_BITMASK)
+ 				ndlp->nlp_fc4_type |= NLP_FC4_NVME;
+ 			lpfc_printf_vlog(vport, KERN_ERR, LOG_DISCOVERY,
+ 					 "3064 Setting ndlp %p, DID x%06x with "
+ 					 "FC4 x%08x, Data: x%08x x%08x\n",
+ 					 ndlp, did, ndlp->nlp_fc4_type,
+ 					 FC_TYPE_FCP, FC_TYPE_NVME);
+ 			ndlp->nlp_prev_state = NLP_STE_REG_LOGIN_ISSUE;
+ 
+ 			lpfc_nlp_set_state(vport, ndlp, NLP_STE_PRLI_ISSUE);
+ 			lpfc_issue_els_prli(vport, ndlp, 0);
+ 		}
+ 	} else
+ 		lpfc_printf_vlog(vport, KERN_ERR, LOG_DISCOVERY,
+ 				 "3065 GFT_ID failed x%08x\n", irsp->ulpStatus);
+ 
+ 	lpfc_ct_free_iocb(phba, cmdiocb);
+ }
++>>>>>>> e6ef6a77f51e (scsi: lpfc: prevent potential null pointer dereference)
  
  static void
  lpfc_cmpl_ct(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,
* Unmerged path drivers/scsi/lpfc/lpfc_ct.c
