ceph: record 'offset' for each entry of readdir result

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Yan, Zheng <zyan@redhat.com>
commit 8974eebd38737c9534d81c4131c5fdb1fe24d3e9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8974eebd.failed

This is preparation for using hash value as dentry 'offset'

	Signed-off-by: Yan, Zheng <zyan@redhat.com>
(cherry picked from commit 8974eebd38737c9534d81c4131c5fdb1fe24d3e9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/dir.c
#	fs/ceph/mds_client.h
diff --cc fs/ceph/dir.c
index f5abab663b08,6ae635605be5..000000000000
--- a/fs/ceph/dir.c
+++ b/fs/ceph/dir.c
@@@ -243,35 -276,33 +243,52 @@@ static int ceph_readdir(struct file *fi
  	struct ceph_inode_info *ci = ceph_inode(inode);
  	struct ceph_fs_client *fsc = ceph_inode_to_client(inode);
  	struct ceph_mds_client *mdsc = fsc->mdsc;
++<<<<<<< HEAD
 +	unsigned frag = fpos_frag(filp->f_pos);
 +	int off = fpos_off(filp->f_pos);
++=======
+ 	unsigned frag = fpos_frag(ctx->pos);
+ 	int i;
++>>>>>>> 8974eebd3873 (ceph: record 'offset' for each entry of readdir result)
  	int err;
  	u32 ftype;
  	struct ceph_mds_reply_info_parsed *rinfo;
  
++<<<<<<< HEAD
 +	dout("readdir %p filp %p frag %u off %u\n", inode, filp, frag, off);
++=======
+ 	dout("readdir %p file %p pos %llx\n", inode, file, ctx->pos);
++>>>>>>> 8974eebd3873 (ceph: record 'offset' for each entry of readdir result)
  	if (fi->flags & CEPH_F_ATEND)
  		return 0;
  
  	/* always start with . and .. */
 -	if (ctx->pos == 0) {
 +	if (filp->f_pos == 0) {
  		dout("readdir off 0 -> '.'\n");
 -		if (!dir_emit(ctx, ".", 1, 
 +		if (filldir(dirent, ".", 1, ceph_make_fpos(0, 0),
  			    ceph_translate_ino(inode->i_sb, inode->i_ino),
 -			    inode->i_mode >> 12))
 +			    inode->i_mode >> 12) < 0)
  			return 0;
++<<<<<<< HEAD
 +		filp->f_pos = 1;
 +		off = 1;
++=======
+ 		ctx->pos = 1;
++>>>>>>> 8974eebd3873 (ceph: record 'offset' for each entry of readdir result)
  	}
 -	if (ctx->pos == 1) {
 -		ino_t ino = parent_ino(file->f_path.dentry);
 +	if (filp->f_pos == 1) {
 +		ino_t ino = parent_ino(filp->f_dentry);
  		dout("readdir off 1 -> '..'\n");
 -		if (!dir_emit(ctx, "..", 2,
 +		if (filldir(dirent, "..", 2, ceph_make_fpos(0, 1),
  			    ceph_translate_ino(inode->i_sb, ino),
 -			    inode->i_mode >> 12))
 +			    inode->i_mode >> 12) < 0)
  			return 0;
++<<<<<<< HEAD
 +		filp->f_pos = 2;
 +		off = 2;
++=======
+ 		ctx->pos = 2;
++>>>>>>> 8974eebd3873 (ceph: record 'offset' for each entry of readdir result)
  	}
  
  	/* can we use the dcache? */
@@@ -283,11 -314,10 +300,15 @@@
  	    __ceph_caps_issued_mask(ci, CEPH_CAP_FILE_SHARED, 1)) {
  		u32 shared_gen = ci->i_shared_gen;
  		spin_unlock(&ci->i_ceph_lock);
 -		err = __dcache_readdir(file, ctx, shared_gen);
 +		err = __dcache_readdir(filp, dirent, filldir, shared_gen);
  		if (err != -EAGAIN)
  			return err;
++<<<<<<< HEAD
 +		frag = fpos_frag(filp->f_pos);
 +		off = fpos_off(filp->f_pos);
++=======
+ 		frag = fpos_frag(ctx->pos);
++>>>>>>> 8974eebd3873 (ceph: record 'offset' for each entry of readdir result)
  	} else {
  		spin_unlock(&ci->i_ceph_lock);
  	}
@@@ -381,49 -414,60 +403,101 @@@ more
  		if (req->r_reply_info.dir_end) {
  			kfree(fi->last_name);
  			fi->last_name = NULL;
 -			fi->next_offset = 2;
 +			if (ceph_frag_is_rightmost(frag))
 +				fi->next_offset = 2;
 +			else
 +				fi->next_offset = 0;
  		} else {
++<<<<<<< HEAD
 +			err = note_last_dentry(fi,
 +					rinfo->dir_dname[rinfo->dir_nr-1],
 +					rinfo->dir_dname_len[rinfo->dir_nr-1],
 +					fi->next_offset + rinfo->dir_nr);
++=======
+ 			struct ceph_mds_reply_dir_entry *rde =
+ 					rinfo->dir_entries + (rinfo->dir_nr-1);
+ 			err = note_last_dentry(fi, rde->name, rde->name_len,
+ 					       fpos_off(rde->offset) + 1);
++>>>>>>> 8974eebd3873 (ceph: record 'offset' for each entry of readdir result)
  			if (err)
  				return err;
  		}
  	}
  
  	rinfo = &fi->last_readdir->r_reply_info;
++<<<<<<< HEAD
 +	dout("readdir frag %x num %d off %d chunkoff %d\n", frag,
 +	     rinfo->dir_nr, off, fi->offset);
 +	while (off >= fi->offset && off - fi->offset < rinfo->dir_nr) {
 +		u64 pos = ceph_make_fpos(frag, off);
 +		struct ceph_mds_reply_inode *in =
 +			rinfo->dir_in[off - fi->offset].in;
 +		struct ceph_vino vino;
 +		ino_t ino;
 +
 +		dout("readdir off %d (%d/%d) -> %lld '%.*s' %p\n",
 +		     off, off - fi->offset, rinfo->dir_nr, pos,
 +		     rinfo->dir_dname_len[off - fi->offset],
 +		     rinfo->dir_dname[off - fi->offset], in);
 +		BUG_ON(!in);
 +		ftype = le32_to_cpu(in->mode) >> 12;
 +		vino.ino = le64_to_cpu(in->ino);
 +		vino.snap = le64_to_cpu(in->snapid);
 +		ino = ceph_vino_to_ino(vino);
 +		if (filldir(dirent,
 +			    rinfo->dir_dname[off - fi->offset],
 +			    rinfo->dir_dname_len[off - fi->offset],
 +			    pos,
 +			    ceph_translate_ino(inode->i_sb, ino), ftype) < 0) {
 +			dout("filldir stopping us...\n");
 +			return 0;
 +		}
 +		off++;
 +		filp->f_pos = pos + 1;
++=======
+ 	dout("readdir frag %x num %d pos %llx chunk first %llx\n",
+ 	     frag, rinfo->dir_nr, ctx->pos,
+ 	     rinfo->dir_nr ? rinfo->dir_entries[0].offset : 0LL);
+ 
+ 	i = 0;
+ 	/* search start position */
+ 	if (rinfo->dir_nr > 0) {
+ 		int step, nr = rinfo->dir_nr;
+ 		while (nr > 0) {
+ 			step = nr >> 1;
+ 			if (rinfo->dir_entries[i + step].offset < ctx->pos) {
+ 				i +=  step + 1;
+ 				nr -= step + 1;
+ 			} else {
+ 				nr = step;
+ 			}
+ 		}
+ 	}
+ 	for (; i < rinfo->dir_nr; i++) {
+ 		struct ceph_mds_reply_dir_entry *rde = rinfo->dir_entries + i;
+ 		struct ceph_vino vino;
+ 		ino_t ino;
+ 
+ 		BUG_ON(rde->offset < ctx->pos);
+ 
+ 		ctx->pos = rde->offset;
+ 		dout("readdir (%d/%d) -> %llx '%.*s' %p\n",
+ 		     i, rinfo->dir_nr, ctx->pos,
+ 		     rde->name_len, rde->name, &rde->inode.in);
+ 
+ 		BUG_ON(!rde->inode.in);
+ 		ftype = le32_to_cpu(rde->inode.in->mode) >> 12;
+ 		vino.ino = le64_to_cpu(rde->inode.in->ino);
+ 		vino.snap = le64_to_cpu(rde->inode.in->snapid);
+ 		ino = ceph_vino_to_ino(vino);
+ 
+ 		if (!dir_emit(ctx, rde->name, rde->name_len,
+ 			      ceph_translate_ino(inode->i_sb, ino), ftype)) {
+ 			dout("filldir stopping us...\n");
+ 			return 0;
+ 		}
+ 		ctx->pos++;
++>>>>>>> 8974eebd3873 (ceph: record 'offset' for each entry of readdir result)
  	}
  
  	if (fi->last_name) {
@@@ -435,8 -479,7 +509,12 @@@
  	/* more frags? */
  	if (!ceph_frag_is_rightmost(frag)) {
  		frag = ceph_frag_next(frag);
++<<<<<<< HEAD
 +		off = 0;
 +		filp->f_pos = ceph_make_fpos(frag, off);
++=======
+ 		ctx->pos = ceph_make_fpos(frag, 2);
++>>>>>>> 8974eebd3873 (ceph: record 'offset' for each entry of readdir result)
  		dout("readdir next frag is %x\n", frag);
  		goto more;
  	}
diff --cc fs/ceph/mds_client.h
index 37712ccffcc6,4ce19d852657..000000000000
--- a/fs/ceph/mds_client.h
+++ b/fs/ceph/mds_client.h
@@@ -47,6 -47,14 +47,17 @@@ struct ceph_mds_reply_info_in 
  	u32 pool_ns_len;
  };
  
++<<<<<<< HEAD
++=======
+ struct ceph_mds_reply_dir_entry {
+ 	char                          *name;
+ 	u32                           name_len;
+ 	struct ceph_mds_reply_lease   *lease;
+ 	struct ceph_mds_reply_info_in inode;
+ 	loff_t			      offset;
+ };
+ 
++>>>>>>> 8974eebd3873 (ceph: record 'offset' for each entry of readdir result)
  /*
   * parsed info about an mds reply, including information about
   * either: 1) the target inode and/or its parent directory and dentry,
* Unmerged path fs/ceph/dir.c
diff --git a/fs/ceph/inode.c b/fs/ceph/inode.c
index 6c32293bcdc3..0f713fff41da 100644
--- a/fs/ceph/inode.c
+++ b/fs/ceph/inode.c
@@ -1535,6 +1535,7 @@ retry_lookup:
 
 		di = dn->d_fsdata;
 		di->offset = ceph_make_fpos(frag, i + req->r_readdir_offset);
+		rde->offset = di->offset;
 
 		update_dentry_lease(dn, rinfo->dir_dlease[i],
 				    req->r_session,
diff --git a/fs/ceph/mds_client.c b/fs/ceph/mds_client.c
index ac3236e332ae..57ca75ff2721 100644
--- a/fs/ceph/mds_client.c
+++ b/fs/ceph/mds_client.c
@@ -214,6 +214,8 @@ static int parse_reply_info_dir(void **p, void *end,
 		err = parse_reply_info_in(p, end, &info->dir_in[i], features);
 		if (err < 0)
 			goto out_bad;
+		/* ceph_readdir_prepopulate() will update it */
+		rde->offset = 0;
 		i++;
 		num--;
 	}
* Unmerged path fs/ceph/mds_client.h
diff --git a/fs/ceph/super.h b/fs/ceph/super.h
index 04548903b610..f41f0b9810cc 100644
--- a/fs/ceph/super.h
+++ b/fs/ceph/super.h
@@ -620,7 +620,6 @@ struct ceph_file_info {
 	struct ceph_mds_request *last_readdir;
 
 	/* readdir: position within a frag */
-	unsigned offset;       /* offset of last chunk, adjusted for . and .. */
 	unsigned next_offset;  /* offset of next chunk (last_name's + 1) */
 	char *last_name;       /* last entry in previous chunk */
 	long long dir_release_count;
