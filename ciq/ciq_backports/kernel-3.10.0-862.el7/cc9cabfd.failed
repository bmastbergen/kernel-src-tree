drm/i915/cnl: Move voltage check into ddi buf trans functions.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [gpu] drm/i915/cnl: Move voltage check into ddi buf trans functions (Rob Clark) [1520639]
Rebuild_FUZZ: 99.19%
commit-author Rodrigo Vivi <rodrigo.vivi@intel.com>
commit cc9cabfdec38d09e6f6a7f750b67043fbfa2eb31
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/cc9cabfd.failed

Let's start converging CNL buf translations to same style
used on previous platforms. So first thing is to use the
standard signature so we don't need to propagate the voltage
check into other parts of the code, but only on the parts
that it is really useful.

	Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
	Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20170829232230.23051-5-rodrigo.vivi@intel.com
(cherry picked from commit cc9cabfdec38d09e6f6a7f750b67043fbfa2eb31)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_ddi.c
diff --cc drivers/gpu/drm/i915/intel_ddi.c
index d42007e133bd,7b547a7f6c2b..000000000000
--- a/drivers/gpu/drm/i915/intel_ddi.c
+++ b/drivers/gpu/drm/i915/intel_ddi.c
@@@ -1582,50 -1810,236 +1582,270 @@@ static void bxt_ddi_vswing_sequence(str
  				     ddi_translations[level].deemphasis);
  }
  
++<<<<<<< HEAD
++=======
+ u8 intel_ddi_dp_voltage_max(struct intel_encoder *encoder)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
+ 	int n_entries;
+ 
+ 	if (encoder->type == INTEL_OUTPUT_EDP)
+ 		intel_ddi_get_buf_trans_edp(dev_priv, &n_entries);
+ 	else
+ 		intel_ddi_get_buf_trans_dp(dev_priv, &n_entries);
+ 
+ 	if (WARN_ON(n_entries < 1))
+ 		n_entries = 1;
+ 	if (WARN_ON(n_entries > ARRAY_SIZE(index_to_dp_signal_levels)))
+ 		n_entries = ARRAY_SIZE(index_to_dp_signal_levels);
+ 
+ 	return index_to_dp_signal_levels[n_entries - 1] &
+ 		DP_TRAIN_VOLTAGE_SWING_MASK;
+ }
+ 
+ static const struct cnl_ddi_buf_trans *
+ cnl_get_buf_trans_hdmi(struct drm_i915_private *dev_priv, int *n_entries)
+ {
+ 	u32 voltage = I915_READ(CNL_PORT_COMP_DW3) & VOLTAGE_INFO_MASK;
+ 
+ 	if (voltage == VOLTAGE_INFO_0_85V) {
+ 		*n_entries = ARRAY_SIZE(cnl_ddi_translations_hdmi_0_85V);
+ 		return cnl_ddi_translations_hdmi_0_85V;
+ 	} else if (voltage == VOLTAGE_INFO_0_95V) {
+ 		*n_entries = ARRAY_SIZE(cnl_ddi_translations_hdmi_0_95V);
+ 		return cnl_ddi_translations_hdmi_0_95V;
+ 	} else if (voltage == VOLTAGE_INFO_1_05V) {
+ 		*n_entries = ARRAY_SIZE(cnl_ddi_translations_hdmi_1_05V);
+ 		return cnl_ddi_translations_hdmi_1_05V;
+ 	} else
+ 		MISSING_CASE(voltage);
+ 	return NULL;
+ }
+ 
+ static const struct cnl_ddi_buf_trans *
+ cnl_get_buf_trans_dp(struct drm_i915_private *dev_priv, int *n_entries)
+ {
+ 	u32 voltage = I915_READ(CNL_PORT_COMP_DW3) & VOLTAGE_INFO_MASK;
+ 
+ 	if (voltage == VOLTAGE_INFO_0_85V) {
+ 		*n_entries = ARRAY_SIZE(cnl_ddi_translations_dp_0_85V);
+ 		return cnl_ddi_translations_dp_0_85V;
+ 	} else if (voltage == VOLTAGE_INFO_0_95V) {
+ 		*n_entries = ARRAY_SIZE(cnl_ddi_translations_dp_0_95V);
+ 		return cnl_ddi_translations_dp_0_95V;
+ 	} else if (voltage == VOLTAGE_INFO_1_05V) {
+ 		*n_entries = ARRAY_SIZE(cnl_ddi_translations_dp_1_05V);
+ 		return cnl_ddi_translations_dp_1_05V;
+ 	} else
+ 		MISSING_CASE(voltage);
+ 	return NULL;
+ }
+ 
+ static const struct cnl_ddi_buf_trans *
+ cnl_get_buf_trans_edp(struct drm_i915_private *dev_priv, int *n_entries)
+ {
+ 	u32 voltage = I915_READ(CNL_PORT_COMP_DW3) & VOLTAGE_INFO_MASK;
+ 
+ 	if (dev_priv->vbt.edp.low_vswing) {
+ 		if (voltage == VOLTAGE_INFO_0_85V) {
+ 			*n_entries = ARRAY_SIZE(cnl_ddi_translations_edp_0_85V);
+ 			return cnl_ddi_translations_edp_0_85V;
+ 		} else if (voltage == VOLTAGE_INFO_0_95V) {
+ 			*n_entries = ARRAY_SIZE(cnl_ddi_translations_edp_0_95V);
+ 			return cnl_ddi_translations_edp_0_95V;
+ 		} else if (voltage == VOLTAGE_INFO_1_05V) {
+ 			*n_entries = ARRAY_SIZE(cnl_ddi_translations_edp_1_05V);
+ 			return cnl_ddi_translations_edp_1_05V;
+ 		} else
+ 			MISSING_CASE(voltage);
+ 		return NULL;
+ 	} else {
+ 		return cnl_get_buf_trans_dp(dev_priv, n_entries);
+ 	}
+ }
+ 
+ static void cnl_ddi_vswing_program(struct drm_i915_private *dev_priv,
+ 				    u32 level, enum port port, int type)
+ {
+ 	const struct cnl_ddi_buf_trans *ddi_translations = NULL;
+ 	u32 n_entries, val;
+ 	int ln;
+ 
+ 	if (type == INTEL_OUTPUT_HDMI) {
+ 		ddi_translations = cnl_get_buf_trans_hdmi(dev_priv, &n_entries);
+ 	} else if (type == INTEL_OUTPUT_DP) {
+ 		ddi_translations = cnl_get_buf_trans_dp(dev_priv, &n_entries);
+ 	} else if (type == INTEL_OUTPUT_EDP) {
+ 		ddi_translations = cnl_get_buf_trans_edp(dev_priv, &n_entries);
+ 	}
+ 
+ 	if (WARN_ON(ddi_translations == NULL))
+ 		return;
+ 
+ 	if (level >= n_entries) {
+ 		DRM_DEBUG_KMS("DDI translation not found for level %d. Using %d instead.", level, n_entries - 1);
+ 		level = n_entries - 1;
+ 	}
+ 
+ 	/* Set PORT_TX_DW5 Scaling Mode Sel to 010b. */
+ 	val = I915_READ(CNL_PORT_TX_DW5_LN0(port));
+ 	val &= ~SCALING_MODE_SEL_MASK;
+ 	val |= SCALING_MODE_SEL(2);
+ 	I915_WRITE(CNL_PORT_TX_DW5_GRP(port), val);
+ 
+ 	/* Program PORT_TX_DW2 */
+ 	val = I915_READ(CNL_PORT_TX_DW2_LN0(port));
+ 	val &= ~(SWING_SEL_LOWER_MASK | SWING_SEL_UPPER_MASK |
+ 		 RCOMP_SCALAR_MASK);
+ 	val |= SWING_SEL_UPPER(ddi_translations[level].dw2_swing_sel);
+ 	val |= SWING_SEL_LOWER(ddi_translations[level].dw2_swing_sel);
+ 	/* Rcomp scalar is fixed as 0x98 for every table entry */
+ 	val |= RCOMP_SCALAR(0x98);
+ 	I915_WRITE(CNL_PORT_TX_DW2_GRP(port), val);
+ 
+         /* Program PORT_TX_DW4 */
+ 	/* We cannot write to GRP. It would overrite individual loadgen */
+ 	for (ln = 0; ln < 4; ln++) {
+ 		val = I915_READ(CNL_PORT_TX_DW4_LN(port, ln));
+ 		val &= ~(POST_CURSOR_1_MASK | POST_CURSOR_2_MASK |
+ 			 CURSOR_COEFF_MASK);
+ 		val |= POST_CURSOR_1(ddi_translations[level].dw4_post_cursor_1);
+ 		val |= POST_CURSOR_2(ddi_translations[level].dw4_post_cursor_2);
+ 		val |= CURSOR_COEFF(ddi_translations[level].dw4_cursor_coeff);
+ 		I915_WRITE(CNL_PORT_TX_DW4_LN(port, ln), val);
+ 	}
+ 
+         /* Program PORT_TX_DW5 */
+ 	/* All DW5 values are fixed for every table entry */
+ 	val = I915_READ(CNL_PORT_TX_DW5_LN0(port));
+ 	val &= ~RTERM_SELECT_MASK;
+ 	val |= RTERM_SELECT(6);
+ 	val |= TAP3_DISABLE;
+ 	I915_WRITE(CNL_PORT_TX_DW5_GRP(port), val);
+ 
+         /* Program PORT_TX_DW7 */
+ 	val = I915_READ(CNL_PORT_TX_DW7_LN0(port));
+ 	val &= ~N_SCALAR_MASK;
+ 	val |= N_SCALAR(ddi_translations[level].dw7_n_scalar);
+ 	I915_WRITE(CNL_PORT_TX_DW7_GRP(port), val);
+ }
+ 
+ static void cnl_ddi_vswing_sequence(struct intel_encoder *encoder, u32 level)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
+ 	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);
+ 	enum port port = intel_ddi_get_encoder_port(encoder);
+ 	int type = encoder->type;
+ 	int width = 0;
+ 	int rate = 0;
+ 	u32 val;
+ 	int ln = 0;
+ 
+ 	if ((intel_dp) && (type == INTEL_OUTPUT_EDP || type == INTEL_OUTPUT_DP)) {
+ 		width = intel_dp->lane_count;
+ 		rate = intel_dp->link_rate;
+ 	} else if (type == INTEL_OUTPUT_HDMI) {
+ 		width = 4;
+ 		/* Rate is always < than 6GHz for HDMI */
+ 	} else {
+ 		MISSING_CASE(type);
+ 		return;
+ 	}
+ 
+ 	/*
+ 	 * 1. If port type is eDP or DP,
+ 	 * set PORT_PCS_DW1 cmnkeeper_enable to 1b,
+ 	 * else clear to 0b.
+ 	 */
+ 	val = I915_READ(CNL_PORT_PCS_DW1_LN0(port));
+ 	if (type == INTEL_OUTPUT_EDP || type == INTEL_OUTPUT_DP)
+ 		val |= COMMON_KEEPER_EN;
+ 	else
+ 		val &= ~COMMON_KEEPER_EN;
+ 	I915_WRITE(CNL_PORT_PCS_DW1_GRP(port), val);
+ 
+ 	/* 2. Program loadgen select */
+ 	/*
+ 	 * Program PORT_TX_DW4_LN depending on Bit rate and used lanes
+ 	 * <= 6 GHz and 4 lanes (LN0=0, LN1=1, LN2=1, LN3=1)
+ 	 * <= 6 GHz and 1,2 lanes (LN0=0, LN1=1, LN2=1, LN3=0)
+ 	 * > 6 GHz (LN0=0, LN1=0, LN2=0, LN3=0)
+ 	 */
+ 	for (ln = 0; ln <= 3; ln++) {
+ 		val = I915_READ(CNL_PORT_TX_DW4_LN(port, ln));
+ 		val &= ~LOADGEN_SELECT;
+ 
+ 		if ((rate <= 600000 && width == 4 && ln >= 1)  ||
+ 		    (rate <= 600000 && width < 4 && (ln == 1 || ln == 2))) {
+ 			val |= LOADGEN_SELECT;
+ 		}
+ 		I915_WRITE(CNL_PORT_TX_DW4_LN(port, ln), val);
+ 	}
+ 
+ 	/* 3. Set PORT_CL_DW5 SUS Clock Config to 11b */
+ 	val = I915_READ(CNL_PORT_CL1CM_DW5);
+ 	val |= SUS_CLOCK_CONFIG;
+ 	I915_WRITE(CNL_PORT_CL1CM_DW5, val);
+ 
+ 	/* 4. Clear training enable to change swing values */
+ 	val = I915_READ(CNL_PORT_TX_DW5_LN0(port));
+ 	val &= ~TX_TRAINING_EN;
+ 	I915_WRITE(CNL_PORT_TX_DW5_GRP(port), val);
+ 
+ 	/* 5. Program swing and de-emphasis */
+ 	cnl_ddi_vswing_program(dev_priv, level, port, type);
+ 
+ 	/* 6. Set training enable to trigger update */
+ 	val = I915_READ(CNL_PORT_TX_DW5_LN0(port));
+ 	val |= TX_TRAINING_EN;
+ 	I915_WRITE(CNL_PORT_TX_DW5_GRP(port), val);
+ }
+ 
++>>>>>>> cc9cabfdec38 (drm/i915/cnl: Move voltage check into ddi buf trans functions.)
  static uint32_t translate_signal_level(int signal_levels)
  {
 -	int i;
 +	uint32_t level;
  
 -	for (i = 0; i < ARRAY_SIZE(index_to_dp_signal_levels); i++) {
 -		if (index_to_dp_signal_levels[i] == signal_levels)
 -			return i;
 -	}
 +	switch (signal_levels) {
 +	default:
 +		DRM_DEBUG_KMS("Unsupported voltage swing/pre-emphasis level: 0x%x\n",
 +			      signal_levels);
 +	case DP_TRAIN_VOLTAGE_SWING_LEVEL_0 | DP_TRAIN_PRE_EMPH_LEVEL_0:
 +		level = 0;
 +		break;
 +	case DP_TRAIN_VOLTAGE_SWING_LEVEL_0 | DP_TRAIN_PRE_EMPH_LEVEL_1:
 +		level = 1;
 +		break;
 +	case DP_TRAIN_VOLTAGE_SWING_LEVEL_0 | DP_TRAIN_PRE_EMPH_LEVEL_2:
 +		level = 2;
 +		break;
 +	case DP_TRAIN_VOLTAGE_SWING_LEVEL_0 | DP_TRAIN_PRE_EMPH_LEVEL_3:
 +		level = 3;
 +		break;
 +
 +	case DP_TRAIN_VOLTAGE_SWING_LEVEL_1 | DP_TRAIN_PRE_EMPH_LEVEL_0:
 +		level = 4;
 +		break;
 +	case DP_TRAIN_VOLTAGE_SWING_LEVEL_1 | DP_TRAIN_PRE_EMPH_LEVEL_1:
 +		level = 5;
 +		break;
 +	case DP_TRAIN_VOLTAGE_SWING_LEVEL_1 | DP_TRAIN_PRE_EMPH_LEVEL_2:
 +		level = 6;
 +		break;
 +
 +	case DP_TRAIN_VOLTAGE_SWING_LEVEL_2 | DP_TRAIN_PRE_EMPH_LEVEL_0:
 +		level = 7;
 +		break;
 +	case DP_TRAIN_VOLTAGE_SWING_LEVEL_2 | DP_TRAIN_PRE_EMPH_LEVEL_1:
 +		level = 8;
 +		break;
  
 -	WARN(1, "Unsupported voltage swing/pre-emphasis level: 0x%x\n",
 -	     signal_levels);
 +	case DP_TRAIN_VOLTAGE_SWING_LEVEL_3 | DP_TRAIN_PRE_EMPH_LEVEL_0:
 +		level = 9;
 +		break;
 +	}
  
 -	return 0;
 +	return level;
  }
  
  static uint32_t intel_ddi_dp_level(struct intel_dp *intel_dp)
* Unmerged path drivers/gpu/drm/i915/intel_ddi.c
