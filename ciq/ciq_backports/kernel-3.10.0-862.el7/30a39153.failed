cpufreq: intel_pstate: fix inconsistency in setting policy limits

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [cpufreq] intel_pstate: fix inconsistency in setting policy limits (Prarit Bhargava) [1465349]
Rebuild_FUZZ: 92.56%
commit-author Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
commit 30a3915385f124a6e3c81df4070f531d4f84299b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/30a39153.failed

When user sets performance policy using cpufreq interface, it is possible
that because of policy->max limits, the actual performance is still
limited. But the current implementation will silently switch the
policy to powersave and start using powersave limits. If user modifies
any limits using intel_pstate sysfs, this is actually changing powersave
limits.

The current implementation tracks limits under powersave and performance
policy using two different variables. When policy->max is less than
policy->cpuinfo.max_freq, only powersave limit variable is used.

This fix causes the performance limits variable to be used always when
the policy is performance.

	Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 30a3915385f124a6e3c81df4070f531d4f84299b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/intel_pstate.c
diff --cc drivers/cpufreq/intel_pstate.c
index 5e3c944b968b,c6c169a1b2fc..000000000000
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@@ -1127,28 -1123,57 +1127,49 @@@ static unsigned int intel_pstate_get(un
  	if (!cpu)
  		return 0;
  	sample = &cpu->sample;
 -	return get_avg_frequency(cpu);
 -}
 -
 -static void intel_pstate_set_update_util_hook(unsigned int cpu_num)
 -{
 -	struct cpudata *cpu = all_cpu_data[cpu_num];
 -
 -	/* Prevent intel_pstate_update_util() from using stale data. */
 -	cpu->sample.time = 0;
 -	cpufreq_set_update_util_data(cpu_num, &cpu->update_util);
 -}
 -
 -static void intel_pstate_clear_update_util_hook(unsigned int cpu)
 -{
 -	cpufreq_set_update_util_data(cpu, NULL);
 -	synchronize_sched();
 +	return sample->freq;
  }
  
+ static void intel_pstate_set_performance_limits(struct perf_limits *limits)
+ {
+ 	limits->no_turbo = 0;
+ 	limits->turbo_disabled = 0;
+ 	limits->max_perf_pct = 100;
+ 	limits->max_perf = int_tofp(1);
+ 	limits->min_perf_pct = 100;
+ 	limits->min_perf = int_tofp(1);
+ 	limits->max_policy_pct = 100;
+ 	limits->max_sysfs_pct = 100;
+ 	limits->min_policy_pct = 0;
+ 	limits->min_sysfs_pct = 0;
+ }
+ 
  static int intel_pstate_set_policy(struct cpufreq_policy *policy)
  {
  	if (!policy->cpuinfo.max_freq)
  		return -ENODEV;
  
 -	intel_pstate_clear_update_util_hook(policy->cpu);
 +	pr_debug("set_policy cpuinfo.max %u policy->max %u\n",
 +		 policy->cpuinfo.max_freq, policy->max);
  
- 	if (policy->policy == CPUFREQ_POLICY_PERFORMANCE &&
- 	    policy->max >= policy->cpuinfo.max_freq) {
- 		pr_debug("intel_pstate: set performance\n");
+ 	if (policy->policy == CPUFREQ_POLICY_PERFORMANCE) {
  		limits = &performance_limits;
++<<<<<<< HEAD
 +		if (hwp_active)
 +			intel_pstate_hwp_set(policy->cpus);
 +		return 0;
++=======
+ 		if (policy->max >= policy->cpuinfo.max_freq) {
+ 			pr_debug("intel_pstate: set performance\n");
+ 			intel_pstate_set_performance_limits(limits);
+ 			goto out;
+ 		}
+ 	} else {
+ 		pr_debug("intel_pstate: set powersave\n");
+ 		limits = &powersave_limits;
++>>>>>>> 30a3915385f1 (cpufreq: intel_pstate: fix inconsistency in setting policy limits)
  	}
  
- 	pr_debug("intel_pstate: set powersave\n");
- 	limits = &powersave_limits;
  	limits->min_policy_pct = (policy->min * 100) / policy->cpuinfo.max_freq;
  	limits->min_policy_pct = clamp_t(int, limits->min_policy_pct, 0 , 100);
  	limits->max_policy_pct = DIV_ROUND_UP(policy->max * 100,
* Unmerged path drivers/cpufreq/intel_pstate.c
