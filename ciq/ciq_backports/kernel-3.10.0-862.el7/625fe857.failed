scsi: scsi_dh_alua: Check scsi_device_get() return value

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] scsi_dh_alua: Check scsi_device_get() return value (Mike Snitzer) [1499107]
Rebuild_FUZZ: 94.34%
commit-author Bart Van Assche <bart.vanassche@sandisk.com>
commit 625fe857e4fac6518716f3c0ff5e5deb8ec6d238
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/625fe857.failed

Do not queue ALUA work nor call scsi_device_put() if the
scsi_device_get() call fails. This patch fixes the following crash:

general protection fault: 0000 [#1] SMP
RIP: 0010:scsi_device_put+0xb/0x30
Call Trace:
 scsi_disk_put+0x2d/0x40
 sd_release+0x3d/0xb0
 __blkdev_put+0x29e/0x360
 blkdev_put+0x49/0x170
 dm_put_table_device+0x58/0xc0 [dm_mod]
 dm_put_device+0x70/0xc0 [dm_mod]
 free_priority_group+0x92/0xc0 [dm_multipath]
 free_multipath+0x70/0xc0 [dm_multipath]
 multipath_dtr+0x19/0x20 [dm_multipath]
 dm_table_destroy+0x67/0x120 [dm_mod]
 dev_suspend+0xde/0x240 [dm_mod]
 ctl_ioctl+0x1f5/0x520 [dm_mod]
 dm_ctl_ioctl+0xe/0x20 [dm_mod]
 do_vfs_ioctl+0x8f/0x700
 SyS_ioctl+0x3c/0x70
 entry_SYSCALL_64_fastpath+0x18/0xad

Fixes: commit 03197b61c5ec ("scsi_dh_alua: Use workqueue for RTPG")
	Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Cc: Hannes Reinecke <hare@suse.de>
	Cc: Tang Junhui <tang.junhui@zte.com.cn>
	Cc: <stable@vger.kernel.org>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 625fe857e4fac6518716f3c0ff5e5deb8ec6d238)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/device_handler/scsi_dh_alua.c
diff --cc drivers/scsi/device_handler/scsi_dh_alua.c
index 2f054f24112a,e0b15f3dd303..000000000000
--- a/drivers/scsi/device_handler/scsi_dh_alua.c
+++ b/drivers/scsi/device_handler/scsi_dh_alua.c
@@@ -541,6 -776,139 +541,142 @@@ static unsigned alua_stpg(struct scsi_d
  	return SCSI_DH_RETRY;
  }
  
++<<<<<<< HEAD
++=======
+ static void alua_rtpg_work(struct work_struct *work)
+ {
+ 	struct alua_port_group *pg =
+ 		container_of(work, struct alua_port_group, rtpg_work.work);
+ 	struct scsi_device *sdev;
+ 	LIST_HEAD(qdata_list);
+ 	int err = SCSI_DH_OK;
+ 	struct alua_queue_data *qdata, *tmp;
+ 	unsigned long flags;
+ 	struct workqueue_struct *alua_wq = kaluad_wq;
+ 
+ 	spin_lock_irqsave(&pg->lock, flags);
+ 	sdev = pg->rtpg_sdev;
+ 	if (!sdev) {
+ 		WARN_ON(pg->flags & ALUA_PG_RUN_RTPG);
+ 		WARN_ON(pg->flags & ALUA_PG_RUN_STPG);
+ 		spin_unlock_irqrestore(&pg->lock, flags);
+ 		kref_put(&pg->kref, release_port_group);
+ 		return;
+ 	}
+ 	if (pg->flags & ALUA_SYNC_STPG)
+ 		alua_wq = kaluad_sync_wq;
+ 	pg->flags |= ALUA_PG_RUNNING;
+ 	if (pg->flags & ALUA_PG_RUN_RTPG) {
+ 		int state = pg->state;
+ 
+ 		pg->flags &= ~ALUA_PG_RUN_RTPG;
+ 		spin_unlock_irqrestore(&pg->lock, flags);
+ 		if (state == SCSI_ACCESS_STATE_TRANSITIONING) {
+ 			if (alua_tur(sdev) == SCSI_DH_RETRY) {
+ 				spin_lock_irqsave(&pg->lock, flags);
+ 				pg->flags &= ~ALUA_PG_RUNNING;
+ 				pg->flags |= ALUA_PG_RUN_RTPG;
+ 				spin_unlock_irqrestore(&pg->lock, flags);
+ 				queue_delayed_work(alua_wq, &pg->rtpg_work,
+ 						   pg->interval * HZ);
+ 				return;
+ 			}
+ 			/* Send RTPG on failure or if TUR indicates SUCCESS */
+ 		}
+ 		err = alua_rtpg(sdev, pg);
+ 		spin_lock_irqsave(&pg->lock, flags);
+ 		if (err == SCSI_DH_RETRY || pg->flags & ALUA_PG_RUN_RTPG) {
+ 			pg->flags &= ~ALUA_PG_RUNNING;
+ 			pg->flags |= ALUA_PG_RUN_RTPG;
+ 			spin_unlock_irqrestore(&pg->lock, flags);
+ 			queue_delayed_work(alua_wq, &pg->rtpg_work,
+ 					   pg->interval * HZ);
+ 			return;
+ 		}
+ 		if (err != SCSI_DH_OK)
+ 			pg->flags &= ~ALUA_PG_RUN_STPG;
+ 	}
+ 	if (pg->flags & ALUA_PG_RUN_STPG) {
+ 		pg->flags &= ~ALUA_PG_RUN_STPG;
+ 		spin_unlock_irqrestore(&pg->lock, flags);
+ 		err = alua_stpg(sdev, pg);
+ 		spin_lock_irqsave(&pg->lock, flags);
+ 		if (err == SCSI_DH_RETRY || pg->flags & ALUA_PG_RUN_RTPG) {
+ 			pg->flags |= ALUA_PG_RUN_RTPG;
+ 			pg->interval = 0;
+ 			pg->flags &= ~ALUA_PG_RUNNING;
+ 			spin_unlock_irqrestore(&pg->lock, flags);
+ 			queue_delayed_work(alua_wq, &pg->rtpg_work,
+ 					   pg->interval * HZ);
+ 			return;
+ 		}
+ 	}
+ 
+ 	list_splice_init(&pg->rtpg_list, &qdata_list);
+ 	pg->rtpg_sdev = NULL;
+ 	spin_unlock_irqrestore(&pg->lock, flags);
+ 
+ 	list_for_each_entry_safe(qdata, tmp, &qdata_list, entry) {
+ 		list_del(&qdata->entry);
+ 		if (qdata->callback_fn)
+ 			qdata->callback_fn(qdata->callback_data, err);
+ 		kfree(qdata);
+ 	}
+ 	spin_lock_irqsave(&pg->lock, flags);
+ 	pg->flags &= ~ALUA_PG_RUNNING;
+ 	spin_unlock_irqrestore(&pg->lock, flags);
+ 	scsi_device_put(sdev);
+ 	kref_put(&pg->kref, release_port_group);
+ }
+ 
+ static void alua_rtpg_queue(struct alua_port_group *pg,
+ 			    struct scsi_device *sdev,
+ 			    struct alua_queue_data *qdata, bool force)
+ {
+ 	int start_queue = 0;
+ 	unsigned long flags;
+ 	struct workqueue_struct *alua_wq = kaluad_wq;
+ 
+ 	if (!pg || scsi_device_get(sdev))
+ 		return;
+ 
+ 	spin_lock_irqsave(&pg->lock, flags);
+ 	if (qdata) {
+ 		list_add_tail(&qdata->entry, &pg->rtpg_list);
+ 		pg->flags |= ALUA_PG_RUN_STPG;
+ 		force = true;
+ 	}
+ 	if (pg->rtpg_sdev == NULL) {
+ 		pg->interval = 0;
+ 		pg->flags |= ALUA_PG_RUN_RTPG;
+ 		kref_get(&pg->kref);
+ 		pg->rtpg_sdev = sdev;
+ 		start_queue = 1;
+ 	} else if (!(pg->flags & ALUA_PG_RUN_RTPG) && force) {
+ 		pg->flags |= ALUA_PG_RUN_RTPG;
+ 		/* Do not queue if the worker is already running */
+ 		if (!(pg->flags & ALUA_PG_RUNNING)) {
+ 			kref_get(&pg->kref);
+ 			start_queue = 1;
+ 		}
+ 	}
+ 
+ 	if (pg->flags & ALUA_SYNC_STPG)
+ 		alua_wq = kaluad_sync_wq;
+ 	spin_unlock_irqrestore(&pg->lock, flags);
+ 
+ 	if (start_queue) {
+ 		if (queue_delayed_work(alua_wq, &pg->rtpg_work,
+ 				msecs_to_jiffies(ALUA_RTPG_DELAY_MSECS)))
+ 			sdev = NULL;
+ 		else
+ 			kref_put(&pg->kref, release_port_group);
+ 	}
+ 	if (sdev)
+ 		scsi_device_put(sdev);
+ }
+ 
++>>>>>>> 625fe857e4fa (scsi: scsi_dh_alua: Check scsi_device_get() return value)
  /*
   * alua_initialize - Initialize ALUA state
   * @sdev: the device to be initialized
* Unmerged path drivers/scsi/device_handler/scsi_dh_alua.c
