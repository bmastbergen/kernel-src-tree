power_supply: Move run-time configuration to separate structure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Krzysztof Kozlowski <k.kozlowski@samsung.com>
commit 2dc9215d7c94f7f9f34ccf8b1710ad73d82f6216
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2dc9215d.failed

Add new structure 'power_supply_config' for holding run-time
initialization data like of_node, supplies and private driver data.

The power_supply_register() function is changed so all power supply
drivers need updating.

When registering the power supply this new 'power_supply_config' should be
used instead of directly initializing 'struct power_supply'. This allows
changing the ownership of power_supply structure from driver to the
power supply core in next patches.

When a driver does not use of_node or supplies then it should use NULL
as config. If driver uses of_node or supplies then it should allocate
config on stack and initialize it with proper values.

	Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
	Reviewed-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
	Acked-by: Pavel Machek <pavel@ucw.cz>

[for the nvec part]
	Reviewed-by: Marc Dietrich <marvin24@gmx.de>

[for drivers/platform/x86/compal-laptop.c]
	Reviewed-by: Darren Hart <dvhart@linux.intel.com>

[for drivers/hid/*]
	Reviewed-by: Jiri Kosina <jkosina@suse.cz>

	Signed-off-by: Sebastian Reichel <sre@kernel.org>
(cherry picked from commit 2dc9215d7c94f7f9f34ccf8b1710ad73d82f6216)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/battery.c
#	drivers/hid/hid-sony.c
#	drivers/hid/hid-wiimote-modules.c
#	drivers/hid/wacom_sys.c
#	drivers/platform/x86/compal-laptop.c
#	drivers/power/axp288_fuel_gauge.c
#	drivers/power/bq24190_charger.c
#	drivers/power/bq24735-charger.c
#	drivers/power/bq27x00_battery.c
#	drivers/power/da9150-charger.c
#	drivers/power/gpio-charger.c
#	drivers/power/ipaq_micro_battery.c
#	drivers/power/lp8788-charger.c
#	drivers/power/ltc2941-battery-gauge.c
#	drivers/power/max14577_charger.c
#	drivers/power/max77693_charger.c
#	drivers/power/power_supply_core.c
#	drivers/power/rt5033_battery.c
#	drivers/power/rx51_battery.c
#	drivers/power/sbs-battery.c
#	drivers/power/test_power.c
#	drivers/power/tps65090-charger.c
#	drivers/power/twl4030_madc_battery.c
diff --cc drivers/acpi/battery.c
index 32ab08a3c680,fd8c06f492a1..000000000000
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@@ -602,7 -624,9 +602,13 @@@ static int sysfs_add_battery(struct acp
  	battery->bat.type = POWER_SUPPLY_TYPE_BATTERY;
  	battery->bat.get_property = acpi_battery_get_property;
  
++<<<<<<< HEAD
 +	result = power_supply_register(&battery->device->dev, &battery->bat);
++=======
+ 	result = power_supply_register_no_ws(&battery->device->dev,
+ 			&battery->bat, NULL);
+ 
++>>>>>>> 2dc9215d7c94 (power_supply: Move run-time configuration to separate structure)
  	if (result)
  		return result;
  	return device_create_file(battery->bat.dev, &alarm_attr);
diff --cc drivers/hid/hid-sony.c
index 6b28b4814cad,16fc6a17ac63..000000000000
--- a/drivers/hid/hid-sony.c
+++ b/drivers/hid/hid-sony.c
@@@ -149,9 -1149,786 +149,782 @@@ static int sixaxis_set_operational_usb(
  
  static int sixaxis_set_operational_bt(struct hid_device *hdev)
  {
 -	static const __u8 report[] = { 0xf4, 0x42, 0x03, 0x00, 0x00 };
 -	__u8 *buf;
 -	int ret;
 -
 -	buf = kmemdup(report, sizeof(report), GFP_KERNEL);
 -	if (!buf)
 -		return -ENOMEM;
 -
 -	ret = hid_hw_raw_request(hdev, buf[0], buf, sizeof(report),
 +	unsigned char buf[] = { 0xf4,  0x42, 0x03, 0x00, 0x00 };
 +	return hid_hw_raw_request(hdev, buf[0], buf, sizeof(buf),
  				  HID_FEATURE_REPORT, HID_REQ_SET_REPORT);
++<<<<<<< HEAD
++=======
+ 
+ 	kfree(buf);
+ 
+ 	return ret;
+ }
+ 
+ /*
+  * Requesting feature report 0x02 in Bluetooth mode changes the state of the
+  * controller so that it sends full input reports of type 0x11.
+  */
+ static int dualshock4_set_operational_bt(struct hid_device *hdev)
+ {
+ 	__u8 *buf;
+ 	int ret;
+ 
+ 	buf = kmalloc(DS4_REPORT_0x02_SIZE, GFP_KERNEL);
+ 	if (!buf)
+ 		return -ENOMEM;
+ 
+ 	ret = hid_hw_raw_request(hdev, 0x02, buf, DS4_REPORT_0x02_SIZE,
+ 				HID_FEATURE_REPORT, HID_REQ_GET_REPORT);
+ 
+ 	kfree(buf);
+ 
+ 	return ret;
+ }
+ 
+ static void sixaxis_set_leds_from_id(int id, __u8 values[MAX_LEDS])
+ {
+ 	static const __u8 sixaxis_leds[10][4] = {
+ 				{ 0x01, 0x00, 0x00, 0x00 },
+ 				{ 0x00, 0x01, 0x00, 0x00 },
+ 				{ 0x00, 0x00, 0x01, 0x00 },
+ 				{ 0x00, 0x00, 0x00, 0x01 },
+ 				{ 0x01, 0x00, 0x00, 0x01 },
+ 				{ 0x00, 0x01, 0x00, 0x01 },
+ 				{ 0x00, 0x00, 0x01, 0x01 },
+ 				{ 0x01, 0x00, 0x01, 0x01 },
+ 				{ 0x00, 0x01, 0x01, 0x01 },
+ 				{ 0x01, 0x01, 0x01, 0x01 }
+ 	};
+ 
+ 	BUG_ON(MAX_LEDS < ARRAY_SIZE(sixaxis_leds[0]));
+ 
+ 	if (id < 0)
+ 		return;
+ 
+ 	id %= 10;
+ 	memcpy(values, sixaxis_leds[id], sizeof(sixaxis_leds[id]));
+ }
+ 
+ static void dualshock4_set_leds_from_id(int id, __u8 values[MAX_LEDS])
+ {
+ 	/* The first 4 color/index entries match what the PS4 assigns */
+ 	static const __u8 color_code[7][3] = {
+ 			/* Blue   */	{ 0x00, 0x00, 0x01 },
+ 			/* Red	  */	{ 0x01, 0x00, 0x00 },
+ 			/* Green  */	{ 0x00, 0x01, 0x00 },
+ 			/* Pink   */	{ 0x02, 0x00, 0x01 },
+ 			/* Orange */	{ 0x02, 0x01, 0x00 },
+ 			/* Teal   */	{ 0x00, 0x01, 0x01 },
+ 			/* White  */	{ 0x01, 0x01, 0x01 }
+ 	};
+ 
+ 	BUG_ON(MAX_LEDS < ARRAY_SIZE(color_code[0]));
+ 
+ 	if (id < 0)
+ 		return;
+ 
+ 	id %= 7;
+ 	memcpy(values, color_code[id], sizeof(color_code[id]));
+ }
+ 
+ static void buzz_set_leds(struct hid_device *hdev, const __u8 *leds)
+ {
+ 	struct list_head *report_list =
+ 		&hdev->report_enum[HID_OUTPUT_REPORT].report_list;
+ 	struct hid_report *report = list_entry(report_list->next,
+ 		struct hid_report, list);
+ 	__s32 *value = report->field[0]->value;
+ 
+ 	value[0] = 0x00;
+ 	value[1] = leds[0] ? 0xff : 0x00;
+ 	value[2] = leds[1] ? 0xff : 0x00;
+ 	value[3] = leds[2] ? 0xff : 0x00;
+ 	value[4] = leds[3] ? 0xff : 0x00;
+ 	value[5] = 0x00;
+ 	value[6] = 0x00;
+ 	hid_hw_request(hdev, report, HID_REQ_SET_REPORT);
+ }
+ 
+ static void sony_set_leds(struct sony_sc *sc, const __u8 *leds, int count)
+ {
+ 	int n;
+ 
+ 	BUG_ON(count > MAX_LEDS);
+ 
+ 	if (sc->quirks & BUZZ_CONTROLLER && count == 4) {
+ 		buzz_set_leds(sc->hdev, leds);
+ 	} else {
+ 		for (n = 0; n < count; n++)
+ 			sc->led_state[n] = leds[n];
+ 		schedule_work(&sc->state_worker);
+ 	}
+ }
+ 
+ static void sony_led_set_brightness(struct led_classdev *led,
+ 				    enum led_brightness value)
+ {
+ 	struct device *dev = led->dev->parent;
+ 	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+ 	struct sony_sc *drv_data;
+ 
+ 	int n;
+ 	int force_update;
+ 
+ 	drv_data = hid_get_drvdata(hdev);
+ 	if (!drv_data) {
+ 		hid_err(hdev, "No device data\n");
+ 		return;
+ 	}
+ 
+ 	/*
+ 	 * The Sixaxis on USB will override any LED settings sent to it
+ 	 * and keep flashing all of the LEDs until the PS button is pressed.
+ 	 * Updates, even if redundant, must be always be sent to the
+ 	 * controller to avoid having to toggle the state of an LED just to
+ 	 * stop the flashing later on.
+ 	 */
+ 	force_update = !!(drv_data->quirks & SIXAXIS_CONTROLLER_USB);
+ 
+ 	for (n = 0; n < drv_data->led_count; n++) {
+ 		if (led == drv_data->leds[n] && (force_update ||
+ 			(value != drv_data->led_state[n] ||
+ 			drv_data->led_delay_on[n] ||
+ 			drv_data->led_delay_off[n]))) {
+ 
+ 			drv_data->led_state[n] = value;
+ 
+ 			/* Setting the brightness stops the blinking */
+ 			drv_data->led_delay_on[n] = 0;
+ 			drv_data->led_delay_off[n] = 0;
+ 
+ 			sony_set_leds(drv_data, drv_data->led_state,
+ 					drv_data->led_count);
+ 			break;
+ 		}
+ 	}
+ }
+ 
+ static enum led_brightness sony_led_get_brightness(struct led_classdev *led)
+ {
+ 	struct device *dev = led->dev->parent;
+ 	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+ 	struct sony_sc *drv_data;
+ 
+ 	int n;
+ 
+ 	drv_data = hid_get_drvdata(hdev);
+ 	if (!drv_data) {
+ 		hid_err(hdev, "No device data\n");
+ 		return LED_OFF;
+ 	}
+ 
+ 	for (n = 0; n < drv_data->led_count; n++) {
+ 		if (led == drv_data->leds[n])
+ 			return drv_data->led_state[n];
+ 	}
+ 
+ 	return LED_OFF;
+ }
+ 
+ static int sony_led_blink_set(struct led_classdev *led, unsigned long *delay_on,
+ 				unsigned long *delay_off)
+ {
+ 	struct device *dev = led->dev->parent;
+ 	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+ 	struct sony_sc *drv_data = hid_get_drvdata(hdev);
+ 	int n;
+ 	__u8 new_on, new_off;
+ 
+ 	if (!drv_data) {
+ 		hid_err(hdev, "No device data\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* Max delay is 255 deciseconds or 2550 milliseconds */
+ 	if (*delay_on > 2550)
+ 		*delay_on = 2550;
+ 	if (*delay_off > 2550)
+ 		*delay_off = 2550;
+ 
+ 	/* Blink at 1 Hz if both values are zero */
+ 	if (!*delay_on && !*delay_off)
+ 		*delay_on = *delay_off = 500;
+ 
+ 	new_on = *delay_on / 10;
+ 	new_off = *delay_off / 10;
+ 
+ 	for (n = 0; n < drv_data->led_count; n++) {
+ 		if (led == drv_data->leds[n])
+ 			break;
+ 	}
+ 
+ 	/* This LED is not registered on this device */
+ 	if (n >= drv_data->led_count)
+ 		return -EINVAL;
+ 
+ 	/* Don't schedule work if the values didn't change */
+ 	if (new_on != drv_data->led_delay_on[n] ||
+ 		new_off != drv_data->led_delay_off[n]) {
+ 		drv_data->led_delay_on[n] = new_on;
+ 		drv_data->led_delay_off[n] = new_off;
+ 		schedule_work(&drv_data->state_worker);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void sony_leds_remove(struct sony_sc *sc)
+ {
+ 	struct led_classdev *led;
+ 	int n;
+ 
+ 	BUG_ON(!(sc->quirks & SONY_LED_SUPPORT));
+ 
+ 	for (n = 0; n < sc->led_count; n++) {
+ 		led = sc->leds[n];
+ 		sc->leds[n] = NULL;
+ 		if (!led)
+ 			continue;
+ 		led_classdev_unregister(led);
+ 		kfree(led);
+ 	}
+ 
+ 	sc->led_count = 0;
+ }
+ 
+ static int sony_leds_init(struct sony_sc *sc)
+ {
+ 	struct hid_device *hdev = sc->hdev;
+ 	int n, ret = 0;
+ 	int use_ds4_names;
+ 	struct led_classdev *led;
+ 	size_t name_sz;
+ 	char *name;
+ 	size_t name_len;
+ 	const char *name_fmt;
+ 	static const char * const ds4_name_str[] = { "red", "green", "blue",
+ 						  "global" };
+ 	__u8 initial_values[MAX_LEDS] = { 0 };
+ 	__u8 max_brightness[MAX_LEDS] = { [0 ... (MAX_LEDS - 1)] = 1 };
+ 	__u8 use_hw_blink[MAX_LEDS] = { 0 };
+ 
+ 	BUG_ON(!(sc->quirks & SONY_LED_SUPPORT));
+ 
+ 	if (sc->quirks & BUZZ_CONTROLLER) {
+ 		sc->led_count = 4;
+ 		use_ds4_names = 0;
+ 		name_len = strlen("::buzz#");
+ 		name_fmt = "%s::buzz%d";
+ 		/* Validate expected report characteristics. */
+ 		if (!hid_validate_values(hdev, HID_OUTPUT_REPORT, 0, 0, 7))
+ 			return -ENODEV;
+ 	} else if (sc->quirks & DUALSHOCK4_CONTROLLER) {
+ 		dualshock4_set_leds_from_id(sc->device_id, initial_values);
+ 		initial_values[3] = 1;
+ 		sc->led_count = 4;
+ 		memset(max_brightness, 255, 3);
+ 		use_hw_blink[3] = 1;
+ 		use_ds4_names = 1;
+ 		name_len = 0;
+ 		name_fmt = "%s:%s";
+ 	} else {
+ 		sixaxis_set_leds_from_id(sc->device_id, initial_values);
+ 		sc->led_count = 4;
+ 		memset(use_hw_blink, 1, 4);
+ 		use_ds4_names = 0;
+ 		name_len = strlen("::sony#");
+ 		name_fmt = "%s::sony%d";
+ 	}
+ 
+ 	/*
+ 	 * Clear LEDs as we have no way of reading their initial state. This is
+ 	 * only relevant if the driver is loaded after somebody actively set the
+ 	 * LEDs to on
+ 	 */
+ 	sony_set_leds(sc, initial_values, sc->led_count);
+ 
+ 	name_sz = strlen(dev_name(&hdev->dev)) + name_len + 1;
+ 
+ 	for (n = 0; n < sc->led_count; n++) {
+ 
+ 		if (use_ds4_names)
+ 			name_sz = strlen(dev_name(&hdev->dev)) + strlen(ds4_name_str[n]) + 2;
+ 
+ 		led = kzalloc(sizeof(struct led_classdev) + name_sz, GFP_KERNEL);
+ 		if (!led) {
+ 			hid_err(hdev, "Couldn't allocate memory for LED %d\n", n);
+ 			ret = -ENOMEM;
+ 			goto error_leds;
+ 		}
+ 
+ 		name = (void *)(&led[1]);
+ 		if (use_ds4_names)
+ 			snprintf(name, name_sz, name_fmt, dev_name(&hdev->dev),
+ 			ds4_name_str[n]);
+ 		else
+ 			snprintf(name, name_sz, name_fmt, dev_name(&hdev->dev), n + 1);
+ 		led->name = name;
+ 		led->brightness = initial_values[n];
+ 		led->max_brightness = max_brightness[n];
+ 		led->brightness_get = sony_led_get_brightness;
+ 		led->brightness_set = sony_led_set_brightness;
+ 
+ 		if (use_hw_blink[n])
+ 			led->blink_set = sony_led_blink_set;
+ 
+ 		sc->leds[n] = led;
+ 
+ 		ret = led_classdev_register(&hdev->dev, led);
+ 		if (ret) {
+ 			hid_err(hdev, "Failed to register LED %d\n", n);
+ 			sc->leds[n] = NULL;
+ 			kfree(led);
+ 			goto error_leds;
+ 		}
+ 	}
+ 
+ 	return ret;
+ 
+ error_leds:
+ 	sony_leds_remove(sc);
+ 
+ 	return ret;
+ }
+ 
+ static void sixaxis_state_worker(struct work_struct *work)
+ {
+ 	static const union sixaxis_output_report_01 default_report = {
+ 		.buf = {
+ 			0x01,
+ 			0x00, 0xff, 0x00, 0xff, 0x00,
+ 			0x00, 0x00, 0x00, 0x00, 0x00,
+ 			0xff, 0x27, 0x10, 0x00, 0x32,
+ 			0xff, 0x27, 0x10, 0x00, 0x32,
+ 			0xff, 0x27, 0x10, 0x00, 0x32,
+ 			0xff, 0x27, 0x10, 0x00, 0x32,
+ 			0x00, 0x00, 0x00, 0x00, 0x00
+ 		}
+ 	};
+ 	struct sony_sc *sc = container_of(work, struct sony_sc, state_worker);
+ 	struct sixaxis_output_report *report =
+ 		(struct sixaxis_output_report *)sc->output_report_dmabuf;
+ 	int n;
+ 
+ 	/* Initialize the report with default values */
+ 	memcpy(report, &default_report, sizeof(struct sixaxis_output_report));
+ 
+ #ifdef CONFIG_SONY_FF
+ 	report->rumble.right_motor_on = sc->right ? 1 : 0;
+ 	report->rumble.left_motor_force = sc->left;
+ #endif
+ 
+ 	report->leds_bitmap |= sc->led_state[0] << 1;
+ 	report->leds_bitmap |= sc->led_state[1] << 2;
+ 	report->leds_bitmap |= sc->led_state[2] << 3;
+ 	report->leds_bitmap |= sc->led_state[3] << 4;
+ 
+ 	/* Set flag for all leds off, required for 3rd party INTEC controller */
+ 	if ((report->leds_bitmap & 0x1E) == 0)
+ 		report->leds_bitmap |= 0x20;
+ 
+ 	/*
+ 	 * The LEDs in the report are indexed in reverse order to their
+ 	 * corresponding light on the controller.
+ 	 * Index 0 = LED 4, index 1 = LED 3, etc...
+ 	 *
+ 	 * In the case of both delay values being zero (blinking disabled) the
+ 	 * default report values should be used or the controller LED will be
+ 	 * always off.
+ 	 */
+ 	for (n = 0; n < 4; n++) {
+ 		if (sc->led_delay_on[n] || sc->led_delay_off[n]) {
+ 			report->led[3 - n].duty_off = sc->led_delay_off[n];
+ 			report->led[3 - n].duty_on = sc->led_delay_on[n];
+ 		}
+ 	}
+ 
+ 	hid_hw_raw_request(sc->hdev, report->report_id, (__u8 *)report,
+ 			sizeof(struct sixaxis_output_report),
+ 			HID_OUTPUT_REPORT, HID_REQ_SET_REPORT);
+ }
+ 
+ static void dualshock4_state_worker(struct work_struct *work)
+ {
+ 	struct sony_sc *sc = container_of(work, struct sony_sc, state_worker);
+ 	struct hid_device *hdev = sc->hdev;
+ 	__u8 *buf = sc->output_report_dmabuf;
+ 	int offset;
+ 
+ 	if (sc->quirks & DUALSHOCK4_CONTROLLER_USB) {
+ 		memset(buf, 0, DS4_REPORT_0x05_SIZE);
+ 		buf[0] = 0x05;
+ 		buf[1] = 0xFF;
+ 		offset = 4;
+ 	} else {
+ 		memset(buf, 0, DS4_REPORT_0x11_SIZE);
+ 		buf[0] = 0x11;
+ 		buf[1] = 0xB0;
+ 		buf[3] = 0x0F;
+ 		offset = 6;
+ 	}
+ 
+ #ifdef CONFIG_SONY_FF
+ 	buf[offset++] = sc->right;
+ 	buf[offset++] = sc->left;
+ #else
+ 	offset += 2;
+ #endif
+ 
+ 	/* LED 3 is the global control */
+ 	if (sc->led_state[3]) {
+ 		buf[offset++] = sc->led_state[0];
+ 		buf[offset++] = sc->led_state[1];
+ 		buf[offset++] = sc->led_state[2];
+ 	} else {
+ 		offset += 3;
+ 	}
+ 
+ 	/* If both delay values are zero the DualShock 4 disables blinking. */
+ 	buf[offset++] = sc->led_delay_on[3];
+ 	buf[offset++] = sc->led_delay_off[3];
+ 
+ 	if (sc->quirks & DUALSHOCK4_CONTROLLER_USB)
+ 		hid_hw_output_report(hdev, buf, DS4_REPORT_0x05_SIZE);
+ 	else
+ 		hid_hw_raw_request(hdev, 0x11, buf, DS4_REPORT_0x11_SIZE,
+ 				HID_OUTPUT_REPORT, HID_REQ_SET_REPORT);
+ }
+ 
+ static int sony_allocate_output_report(struct sony_sc *sc)
+ {
+ 	if (sc->quirks & SIXAXIS_CONTROLLER)
+ 		sc->output_report_dmabuf =
+ 			kmalloc(sizeof(union sixaxis_output_report_01),
+ 				GFP_KERNEL);
+ 	else if (sc->quirks & DUALSHOCK4_CONTROLLER_BT)
+ 		sc->output_report_dmabuf = kmalloc(DS4_REPORT_0x11_SIZE,
+ 						GFP_KERNEL);
+ 	else if (sc->quirks & DUALSHOCK4_CONTROLLER_USB)
+ 		sc->output_report_dmabuf = kmalloc(DS4_REPORT_0x05_SIZE,
+ 						GFP_KERNEL);
+ 	else
+ 		return 0;
+ 
+ 	if (!sc->output_report_dmabuf)
+ 		return -ENOMEM;
+ 
+ 	return 0;
+ }
+ 
+ #ifdef CONFIG_SONY_FF
+ static int sony_play_effect(struct input_dev *dev, void *data,
+ 			    struct ff_effect *effect)
+ {
+ 	struct hid_device *hid = input_get_drvdata(dev);
+ 	struct sony_sc *sc = hid_get_drvdata(hid);
+ 
+ 	if (effect->type != FF_RUMBLE)
+ 		return 0;
+ 
+ 	sc->left = effect->u.rumble.strong_magnitude / 256;
+ 	sc->right = effect->u.rumble.weak_magnitude / 256;
+ 
+ 	schedule_work(&sc->state_worker);
+ 	return 0;
+ }
+ 
+ static int sony_init_ff(struct sony_sc *sc)
+ {
+ 	struct hid_input *hidinput = list_entry(sc->hdev->inputs.next,
+ 						struct hid_input, list);
+ 	struct input_dev *input_dev = hidinput->input;
+ 
+ 	input_set_capability(input_dev, EV_FF, FF_RUMBLE);
+ 	return input_ff_create_memless(input_dev, NULL, sony_play_effect);
+ }
+ 
+ #else
+ static int sony_init_ff(struct sony_sc *sc)
+ {
+ 	return 0;
+ }
+ 
+ #endif
+ 
+ static int sony_battery_get_property(struct power_supply *psy,
+ 				     enum power_supply_property psp,
+ 				     union power_supply_propval *val)
+ {
+ 	struct sony_sc *sc = container_of(psy, struct sony_sc, battery);
+ 	unsigned long flags;
+ 	int ret = 0;
+ 	u8 battery_charging, battery_capacity, cable_state;
+ 
+ 	spin_lock_irqsave(&sc->lock, flags);
+ 	battery_charging = sc->battery_charging;
+ 	battery_capacity = sc->battery_capacity;
+ 	cable_state = sc->cable_state;
+ 	spin_unlock_irqrestore(&sc->lock, flags);
+ 
+ 	switch (psp) {
+ 	case POWER_SUPPLY_PROP_PRESENT:
+ 		val->intval = 1;
+ 		break;
+ 	case POWER_SUPPLY_PROP_SCOPE:
+ 		val->intval = POWER_SUPPLY_SCOPE_DEVICE;
+ 		break;
+ 	case POWER_SUPPLY_PROP_CAPACITY:
+ 		val->intval = battery_capacity;
+ 		break;
+ 	case POWER_SUPPLY_PROP_STATUS:
+ 		if (battery_charging)
+ 			val->intval = POWER_SUPPLY_STATUS_CHARGING;
+ 		else
+ 			if (battery_capacity == 100 && cable_state)
+ 				val->intval = POWER_SUPPLY_STATUS_FULL;
+ 			else
+ 				val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+ 		break;
+ 	default:
+ 		ret = -EINVAL;
+ 		break;
+ 	}
+ 	return ret;
+ }
+ 
+ static int sony_battery_probe(struct sony_sc *sc)
+ {
+ 	struct hid_device *hdev = sc->hdev;
+ 	int ret;
+ 
+ 	/*
+ 	 * Set the default battery level to 100% to avoid low battery warnings
+ 	 * if the battery is polled before the first device report is received.
+ 	 */
+ 	sc->battery_capacity = 100;
+ 
+ 	sc->battery.properties = sony_battery_props;
+ 	sc->battery.num_properties = ARRAY_SIZE(sony_battery_props);
+ 	sc->battery.get_property = sony_battery_get_property;
+ 	sc->battery.type = POWER_SUPPLY_TYPE_BATTERY;
+ 	sc->battery.use_for_apm = 0;
+ 	sc->battery.name = kasprintf(GFP_KERNEL, "sony_controller_battery_%pMR",
+ 				     sc->mac_address);
+ 	if (!sc->battery.name)
+ 		return -ENOMEM;
+ 
+ 	ret = power_supply_register(&hdev->dev, &sc->battery, NULL);
+ 	if (ret) {
+ 		hid_err(hdev, "Unable to register battery device\n");
+ 		goto err_free;
+ 	}
+ 
+ 	power_supply_powers(&sc->battery, &hdev->dev);
+ 	return 0;
+ 
+ err_free:
+ 	kfree(sc->battery.name);
+ 	sc->battery.name = NULL;
+ 	return ret;
+ }
+ 
+ static void sony_battery_remove(struct sony_sc *sc)
+ {
+ 	if (!sc->battery.name)
+ 		return;
+ 
+ 	power_supply_unregister(&sc->battery);
+ 	kfree(sc->battery.name);
+ 	sc->battery.name = NULL;
+ }
+ 
+ /*
+  * If a controller is plugged in via USB while already connected via Bluetooth
+  * it will show up as two devices. A global list of connected controllers and
+  * their MAC addresses is maintained to ensure that a device is only connected
+  * once.
+  */
+ static int sony_check_add_dev_list(struct sony_sc *sc)
+ {
+ 	struct sony_sc *entry;
+ 	unsigned long flags;
+ 	int ret;
+ 
+ 	spin_lock_irqsave(&sony_dev_list_lock, flags);
+ 
+ 	list_for_each_entry(entry, &sony_device_list, list_node) {
+ 		ret = memcmp(sc->mac_address, entry->mac_address,
+ 				sizeof(sc->mac_address));
+ 		if (!ret) {
+ 			ret = -EEXIST;
+ 			hid_info(sc->hdev, "controller with MAC address %pMR already connected\n",
+ 				sc->mac_address);
+ 			goto unlock;
+ 		}
+ 	}
+ 
+ 	ret = 0;
+ 	list_add(&(sc->list_node), &sony_device_list);
+ 
+ unlock:
+ 	spin_unlock_irqrestore(&sony_dev_list_lock, flags);
+ 	return ret;
+ }
+ 
+ static void sony_remove_dev_list(struct sony_sc *sc)
+ {
+ 	unsigned long flags;
+ 
+ 	if (sc->list_node.next) {
+ 		spin_lock_irqsave(&sony_dev_list_lock, flags);
+ 		list_del(&(sc->list_node));
+ 		spin_unlock_irqrestore(&sony_dev_list_lock, flags);
+ 	}
+ }
+ 
+ static int sony_get_bt_devaddr(struct sony_sc *sc)
+ {
+ 	int ret;
+ 
+ 	/* HIDP stores the device MAC address as a string in the uniq field. */
+ 	ret = strlen(sc->hdev->uniq);
+ 	if (ret != 17)
+ 		return -EINVAL;
+ 
+ 	ret = sscanf(sc->hdev->uniq,
+ 		"%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+ 		&sc->mac_address[5], &sc->mac_address[4], &sc->mac_address[3],
+ 		&sc->mac_address[2], &sc->mac_address[1], &sc->mac_address[0]);
+ 
+ 	if (ret != 6)
+ 		return -EINVAL;
+ 
+ 	return 0;
+ }
+ 
+ static int sony_check_add(struct sony_sc *sc)
+ {
+ 	__u8 *buf = NULL;
+ 	int n, ret;
+ 
+ 	if ((sc->quirks & DUALSHOCK4_CONTROLLER_BT) ||
+ 	    (sc->quirks & SIXAXIS_CONTROLLER_BT)) {
+ 		/*
+ 		 * sony_get_bt_devaddr() attempts to parse the Bluetooth MAC
+ 		 * address from the uniq string where HIDP stores it.
+ 		 * As uniq cannot be guaranteed to be a MAC address in all cases
+ 		 * a failure of this function should not prevent the connection.
+ 		 */
+ 		if (sony_get_bt_devaddr(sc) < 0) {
+ 			hid_warn(sc->hdev, "UNIQ does not contain a MAC address; duplicate check skipped\n");
+ 			return 0;
+ 		}
+ 	} else if (sc->quirks & DUALSHOCK4_CONTROLLER_USB) {
+ 		buf = kmalloc(DS4_REPORT_0x81_SIZE, GFP_KERNEL);
+ 		if (!buf)
+ 			return -ENOMEM;
+ 
+ 		/*
+ 		 * The MAC address of a DS4 controller connected via USB can be
+ 		 * retrieved with feature report 0x81. The address begins at
+ 		 * offset 1.
+ 		 */
+ 		ret = hid_hw_raw_request(sc->hdev, 0x81, buf,
+ 				DS4_REPORT_0x81_SIZE, HID_FEATURE_REPORT,
+ 				HID_REQ_GET_REPORT);
+ 
+ 		if (ret != DS4_REPORT_0x81_SIZE) {
+ 			hid_err(sc->hdev, "failed to retrieve feature report 0x81 with the DualShock 4 MAC address\n");
+ 			ret = ret < 0 ? ret : -EINVAL;
+ 			goto out_free;
+ 		}
+ 
+ 		memcpy(sc->mac_address, &buf[1], sizeof(sc->mac_address));
+ 	} else if (sc->quirks & SIXAXIS_CONTROLLER_USB) {
+ 		buf = kmalloc(SIXAXIS_REPORT_0xF2_SIZE, GFP_KERNEL);
+ 		if (!buf)
+ 			return -ENOMEM;
+ 
+ 		/*
+ 		 * The MAC address of a Sixaxis controller connected via USB can
+ 		 * be retrieved with feature report 0xf2. The address begins at
+ 		 * offset 4.
+ 		 */
+ 		ret = hid_hw_raw_request(sc->hdev, 0xf2, buf,
+ 				SIXAXIS_REPORT_0xF2_SIZE, HID_FEATURE_REPORT,
+ 				HID_REQ_GET_REPORT);
+ 
+ 		if (ret != SIXAXIS_REPORT_0xF2_SIZE) {
+ 			hid_err(sc->hdev, "failed to retrieve feature report 0xf2 with the Sixaxis MAC address\n");
+ 			ret = ret < 0 ? ret : -EINVAL;
+ 			goto out_free;
+ 		}
+ 
+ 		/*
+ 		 * The Sixaxis device MAC in the report is big-endian and must
+ 		 * be byte-swapped.
+ 		 */
+ 		for (n = 0; n < 6; n++)
+ 			sc->mac_address[5-n] = buf[4+n];
+ 	} else {
+ 		return 0;
+ 	}
+ 
+ 	ret = sony_check_add_dev_list(sc);
+ 
+ out_free:
+ 
+ 	kfree(buf);
+ 
+ 	return ret;
+ }
+ 
+ static int sony_set_device_id(struct sony_sc *sc)
+ {
+ 	int ret;
+ 
+ 	/*
+ 	 * Only DualShock 4 or Sixaxis controllers get an id.
+ 	 * All others are set to -1.
+ 	 */
+ 	if ((sc->quirks & SIXAXIS_CONTROLLER) ||
+ 	    (sc->quirks & DUALSHOCK4_CONTROLLER)) {
+ 		ret = ida_simple_get(&sony_device_id_allocator, 0, 0,
+ 					GFP_KERNEL);
+ 		if (ret < 0) {
+ 			sc->device_id = -1;
+ 			return ret;
+ 		}
+ 		sc->device_id = ret;
+ 	} else {
+ 		sc->device_id = -1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void sony_release_device_id(struct sony_sc *sc)
+ {
+ 	if (sc->device_id >= 0) {
+ 		ida_simple_remove(&sony_device_id_allocator, sc->device_id);
+ 		sc->device_id = -1;
+ 	}
+ }
+ 
+ static inline void sony_init_work(struct sony_sc *sc,
+ 					void (*worker)(struct work_struct *))
+ {
+ 	if (!sc->worker_initialized)
+ 		INIT_WORK(&sc->state_worker, worker);
+ 
+ 	sc->worker_initialized = 1;
+ }
+ 
+ static inline void sony_cancel_work_sync(struct sony_sc *sc)
+ {
+ 	if (sc->worker_initialized)
+ 		cancel_work_sync(&sc->state_worker);
++>>>>>>> 2dc9215d7c94 (power_supply: Move run-time configuration to separate structure)
  }
  
  static int sony_probe(struct hid_device *hdev, const struct hid_device_id *id)
diff --cc drivers/hid/wacom_sys.c
index dd37aa8d4f5d,148949c0e039..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -1238,8 -997,45 +1238,50 @@@ err
  
  static int wacom_initialize_battery(struct wacom *wacom)
  {
++<<<<<<< HEAD
 +	if (wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY)
 +		return __wacom_initialize_battery(wacom, &wacom->battery);
++=======
+ 	static atomic_t battery_no = ATOMIC_INIT(0);
+ 	int error;
+ 	unsigned long n;
+ 
+ 	if (wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY) {
+ 		n = atomic_inc_return(&battery_no) - 1;
+ 
+ 		wacom->battery.properties = wacom_battery_props;
+ 		wacom->battery.num_properties = ARRAY_SIZE(wacom_battery_props);
+ 		wacom->battery.get_property = wacom_battery_get_property;
+ 		sprintf(wacom->wacom_wac.bat_name, "wacom_battery_%ld", n);
+ 		wacom->battery.name = wacom->wacom_wac.bat_name;
+ 		wacom->battery.type = POWER_SUPPLY_TYPE_BATTERY;
+ 		wacom->battery.use_for_apm = 0;
+ 
+ 		wacom->ac.properties = wacom_ac_props;
+ 		wacom->ac.num_properties = ARRAY_SIZE(wacom_ac_props);
+ 		wacom->ac.get_property = wacom_ac_get_property;
+ 		sprintf(wacom->wacom_wac.ac_name, "wacom_ac_%ld", n);
+ 		wacom->ac.name = wacom->wacom_wac.ac_name;
+ 		wacom->ac.type = POWER_SUPPLY_TYPE_MAINS;
+ 		wacom->ac.use_for_apm = 0;
+ 
+ 		error = power_supply_register(&wacom->hdev->dev,
+ 					      &wacom->battery, NULL);
+ 		if (error)
+ 			return error;
+ 
+ 		power_supply_powers(&wacom->battery, &wacom->hdev->dev);
+ 
+ 		error = power_supply_register(&wacom->hdev->dev, &wacom->ac,
+ 					      NULL);
+ 		if (error) {
+ 			power_supply_unregister(&wacom->battery);
+ 			return error;
+ 		}
+ 
+ 		power_supply_powers(&wacom->ac, &wacom->hdev->dev);
+ 	}
++>>>>>>> 2dc9215d7c94 (power_supply: Move run-time configuration to separate structure)
  
  	return 0;
  }
diff --cc drivers/platform/x86/compal-laptop.c
index 475cc5242511,041a592fe753..000000000000
--- a/drivers/platform/x86/compal-laptop.c
+++ b/drivers/platform/x86/compal-laptop.c
@@@ -1047,7 -1036,9 +1047,13 @@@ static int compal_probe(struct platform
  
  	/* Power supply */
  	initialize_power_supply_data(data);
++<<<<<<< HEAD
 +	power_supply_register(&compal_device->dev, &data->psy);
++=======
+ 	err = power_supply_register(&compal_device->dev, &data->psy, NULL);
+ 	if (err < 0)
+ 		goto remove;
++>>>>>>> 2dc9215d7c94 (power_supply: Move run-time configuration to separate structure)
  
  	platform_set_drvdata(pdev, data);
  
diff --cc drivers/power/bq27x00_battery.c
index 26037ca7efb4,a992e43908a2..000000000000
--- a/drivers/power/bq27x00_battery.c
+++ b/drivers/power/bq27x00_battery.c
@@@ -708,7 -791,7 +708,11 @@@ static int bq27x00_powersupply_init(str
  	INIT_DELAYED_WORK(&di->work, bq27x00_battery_poll);
  	mutex_init(&di->lock);
  
++<<<<<<< HEAD
 +	ret = power_supply_register(di->dev, &di->bat);
++=======
+ 	ret = power_supply_register_no_ws(di->dev, &di->bat, NULL);
++>>>>>>> 2dc9215d7c94 (power_supply: Move run-time configuration to separate structure)
  	if (ret) {
  		dev_err(di->dev, "failed to register battery: %d\n", ret);
  		return ret;
diff --cc drivers/power/gpio-charger.c
index e9883eeeee76,47a9e2bd94d9..000000000000
--- a/drivers/power/gpio-charger.c
+++ b/drivers/power/gpio-charger.c
@@@ -100,8 -162,10 +101,15 @@@ static int gpio_charger_probe(struct pl
  	charger->properties = gpio_charger_properties;
  	charger->num_properties = ARRAY_SIZE(gpio_charger_properties);
  	charger->get_property = gpio_charger_get_property;
++<<<<<<< HEAD
 +	charger->supplied_to = pdata->supplied_to;
 +	charger->num_supplicants = pdata->num_supplicants;
++=======
+ 
+ 	psy_cfg.supplied_to = pdata->supplied_to;
+ 	psy_cfg.num_supplicants = pdata->num_supplicants;
+ 	psy_cfg.of_node = pdev->dev.of_node;
++>>>>>>> 2dc9215d7c94 (power_supply: Move run-time configuration to separate structure)
  
  	ret = gpio_request(pdata->gpio, dev_name(&pdev->dev));
  	if (ret) {
diff --cc drivers/power/lp8788-charger.c
index ed49b50b220b,8e4d228519c1..000000000000
--- a/drivers/power/lp8788-charger.c
+++ b/drivers/power/lp8788-charger.c
@@@ -417,8 -420,10 +420,13 @@@ static int lp8788_psy_register(struct p
  	pchg->battery.num_properties = ARRAY_SIZE(lp8788_battery_prop);
  	pchg->battery.get_property = lp8788_battery_get_property;
  
++<<<<<<< HEAD
 +	if (power_supply_register(&pdev->dev, &pchg->battery))
++=======
+ 	if (power_supply_register(&pdev->dev, &pchg->battery, NULL)) {
+ 		power_supply_unregister(&pchg->charger);
++>>>>>>> 2dc9215d7c94 (power_supply: Move run-time configuration to separate structure)
  		return -EPERM;
 -	}
  
  	return 0;
  }
diff --cc drivers/power/power_supply_core.c
index 0d8164e2f763,a21e36ed8d41..000000000000
--- a/drivers/power/power_supply_core.c
+++ b/drivers/power/power_supply_core.c
@@@ -489,7 -535,10 +489,14 @@@ static void psy_unregister_cooler(struc
  }
  #endif
  
++<<<<<<< HEAD
 +int __power_supply_register(struct device *parent, struct power_supply *psy, bool ws)
++=======
+ static int __power_supply_register(struct device *parent,
+ 				   struct power_supply *psy,
+ 				   const struct power_supply_config *cfg,
+ 				   bool ws)
++>>>>>>> 2dc9215d7c94 (power_supply: Move run-time configuration to separate structure)
  {
  	struct device *dev;
  	int rc;
@@@ -506,7 -555,17 +513,13 @@@
  	dev->release = power_supply_dev_release;
  	dev_set_drvdata(dev, psy);
  	psy->dev = dev;
+ 	if (cfg) {
+ 		psy->drv_data = cfg->drv_data;
+ 		psy->of_node = cfg->of_node;
+ 		psy->supplied_to = cfg->supplied_to;
+ 		psy->num_supplicants = cfg->num_supplicants;
+ 	}
  
 -	rc = dev_set_name(dev, "%s", psy->name);
 -	if (rc)
 -		goto dev_set_name_failed;
 -
  	INIT_WORK(&psy->changed_work, power_supply_changed_work);
  
  	rc = power_supply_check_supplies(psy);
diff --cc drivers/power/rx51_battery.c
index cbde1d6d3228,804f60c7b715..000000000000
--- a/drivers/power/rx51_battery.c
+++ b/drivers/power/rx51_battery.c
@@@ -215,13 -220,39 +215,37 @@@ static int rx51_battery_probe(struct pl
  	di->bat.num_properties = ARRAY_SIZE(rx51_battery_props);
  	di->bat.get_property = rx51_battery_get_property;
  
++<<<<<<< HEAD
 +	ret = power_supply_register(di->dev, &di->bat);
 +	if (ret) {
 +		platform_set_drvdata(pdev, NULL);
 +		return ret;
 +	}
++=======
+ 	di->channel_temp = iio_channel_get(di->dev, "temp");
+ 	if (IS_ERR(di->channel_temp)) {
+ 		ret = PTR_ERR(di->channel_temp);
+ 		goto error;
+ 	}
+ 
+ 	di->channel_bsi  = iio_channel_get(di->dev, "bsi");
+ 	if (IS_ERR(di->channel_bsi)) {
+ 		ret = PTR_ERR(di->channel_bsi);
+ 		goto error_channel_temp;
+ 	}
+ 
+ 	di->channel_vbat = iio_channel_get(di->dev, "vbat");
+ 	if (IS_ERR(di->channel_vbat)) {
+ 		ret = PTR_ERR(di->channel_vbat);
+ 		goto error_channel_bsi;
+ 	}
+ 
+ 	ret = power_supply_register(di->dev, &di->bat, NULL);
+ 	if (ret)
+ 		goto error_channel_vbat;
++>>>>>>> 2dc9215d7c94 (power_supply: Move run-time configuration to separate structure)
  
  	return 0;
 -
 -error_channel_vbat:
 -	iio_channel_release(di->channel_vbat);
 -error_channel_bsi:
 -	iio_channel_release(di->channel_bsi);
 -error_channel_temp:
 -	iio_channel_release(di->channel_temp);
 -error:
 -
 -	return ret;
  }
  
  static int rx51_battery_remove(struct platform_device *pdev)
diff --cc drivers/power/sbs-battery.c
index c8c78a74e75a,879f1448fc4a..000000000000
--- a/drivers/power/sbs-battery.c
+++ b/drivers/power/sbs-battery.c
@@@ -704,6 -826,7 +705,10 @@@ static int sbs_probe(struct i2c_client 
  	chip->power_supply.properties = sbs_properties;
  	chip->power_supply.num_properties = ARRAY_SIZE(sbs_properties);
  	chip->power_supply.get_property = sbs_get_property;
++<<<<<<< HEAD
++=======
+ 	psy_cfg.of_node = client->dev.of_node;
++>>>>>>> 2dc9215d7c94 (power_supply: Move run-time configuration to separate structure)
  	/* ignore first notification of external change, it is generated
  	 * from the power_supply_register call back
  	 */
diff --cc drivers/power/test_power.c
index 0152f35dca5c,f6c92d1d7811..000000000000
--- a/drivers/power/test_power.c
+++ b/drivers/power/test_power.c
@@@ -147,11 -154,9 +147,9 @@@ static char *test_power_ac_supplied_to[
  };
  
  static struct power_supply test_power_supplies[] = {
 -	[TEST_AC] = {
 +	{
  		.name = "test_ac",
  		.type = POWER_SUPPLY_TYPE_MAINS,
- 		.supplied_to = test_power_ac_supplied_to,
- 		.num_supplicants = ARRAY_SIZE(test_power_ac_supplied_to),
  		.properties = test_power_ac_props,
  		.num_properties = ARRAY_SIZE(test_power_ac_props),
  		.get_property = test_power_get_ac_property,
@@@ -161,11 -167,10 +159,9 @@@
  		.properties = test_power_battery_props,
  		.num_properties = ARRAY_SIZE(test_power_battery_props),
  		.get_property = test_power_get_battery_property,
 -	},
 -	[TEST_USB] = {
 +	}, {
  		.name = "test_usb",
  		.type = POWER_SUPPLY_TYPE_USB,
- 		.supplied_to = test_power_ac_supplied_to,
- 		.num_supplicants = ARRAY_SIZE(test_power_ac_supplied_to),
  		.properties = test_power_ac_props,
  		.num_properties = ARRAY_SIZE(test_power_ac_props),
  		.get_property = test_power_get_usb_property,
@@@ -178,8 -196,12 +187,15 @@@ static int __init test_power_init(void
  	int i;
  	int ret;
  
++<<<<<<< HEAD
++=======
+ 	BUILD_BUG_ON(TEST_POWER_NUM != ARRAY_SIZE(test_power_supplies));
+ 	BUILD_BUG_ON(TEST_POWER_NUM != ARRAY_SIZE(test_power_configs));
+ 
++>>>>>>> 2dc9215d7c94 (power_supply: Move run-time configuration to separate structure)
  	for (i = 0; i < ARRAY_SIZE(test_power_supplies); i++) {
- 		ret = power_supply_register(NULL, &test_power_supplies[i]);
+ 		ret = power_supply_register(NULL, &test_power_supplies[i],
+ 						&test_power_configs[i]);
  		if (ret) {
  			pr_err("%s: failed to register %s\n", __func__,
  				test_power_supplies[i].name);
diff --cc drivers/power/tps65090-charger.c
index 9fbca310a2ad,9872c901bd70..000000000000
--- a/drivers/power/tps65090-charger.c
+++ b/drivers/power/tps65090-charger.c
@@@ -228,10 -265,12 +229,17 @@@ static int tps65090_charger_probe(struc
  	cdata->ac.get_property		= tps65090_ac_get_property;
  	cdata->ac.properties		= tps65090_ac_props;
  	cdata->ac.num_properties	= ARRAY_SIZE(tps65090_ac_props);
++<<<<<<< HEAD
 +	cdata->ac.supplied_to		= pdata->supplied_to;
 +	cdata->ac.num_supplicants	= pdata->num_supplicants;
++=======
++>>>>>>> 2dc9215d7c94 (power_supply: Move run-time configuration to separate structure)
  
- 	ret = power_supply_register(&pdev->dev, &cdata->ac);
+ 	psy_cfg.supplied_to		= pdata->supplied_to;
+ 	psy_cfg.num_supplicants		= pdata->num_supplicants;
+ 	psy_cfg.of_node			= pdev->dev.of_node;
+ 
+ 	ret = power_supply_register(&pdev->dev, &cdata->ac, &psy_cfg);
  	if (ret) {
  		dev_err(&pdev->dev, "failed: power supply register\n");
  		return ret;
* Unmerged path drivers/hid/hid-wiimote-modules.c
* Unmerged path drivers/power/axp288_fuel_gauge.c
* Unmerged path drivers/power/bq24190_charger.c
* Unmerged path drivers/power/bq24735-charger.c
* Unmerged path drivers/power/da9150-charger.c
* Unmerged path drivers/power/ipaq_micro_battery.c
* Unmerged path drivers/power/ltc2941-battery-gauge.c
* Unmerged path drivers/power/max14577_charger.c
* Unmerged path drivers/power/max77693_charger.c
* Unmerged path drivers/power/rt5033_battery.c
* Unmerged path drivers/power/twl4030_madc_battery.c
diff --git a/drivers/acpi/ac.c b/drivers/acpi/ac.c
index 4f4e741d34b2..2f963051f494 100644
--- a/drivers/acpi/ac.c
+++ b/drivers/acpi/ac.c
@@ -328,7 +328,7 @@ static int acpi_ac_add(struct acpi_device *device)
 	ac->charger.properties = ac_props;
 	ac->charger.num_properties = ARRAY_SIZE(ac_props);
 	ac->charger.get_property = get_ac_property;
-	result = power_supply_register(&ac->device->dev, &ac->charger);
+	result = power_supply_register(&ac->device->dev, &ac->charger, NULL);
 	if (result)
 		goto end;
 
* Unmerged path drivers/acpi/battery.c
diff --git a/drivers/acpi/sbs.c b/drivers/acpi/sbs.c
index b6241eeb1132..6f79262fe95b 100644
--- a/drivers/acpi/sbs.c
+++ b/drivers/acpi/sbs.c
@@ -799,7 +799,7 @@ static int acpi_battery_add(struct acpi_sbs *sbs, int id)
 		    ARRAY_SIZE(sbs_energy_battery_props);
 	}
 	battery->bat.get_property = acpi_sbs_battery_get_property;
-	result = power_supply_register(&sbs->device->dev, &battery->bat);
+	result = power_supply_register(&sbs->device->dev, &battery->bat, NULL);
 	if (result)
 		goto end;
 	result = device_create_file(battery->bat.dev, &alarm_attr);
@@ -847,7 +847,7 @@ static int acpi_charger_add(struct acpi_sbs *sbs)
 	sbs->charger.properties = sbs_ac_props;
 	sbs->charger.num_properties = ARRAY_SIZE(sbs_ac_props);
 	sbs->charger.get_property = sbs_get_ac_property;
-	power_supply_register(&sbs->device->dev, &sbs->charger);
+	power_supply_register(&sbs->device->dev, &sbs->charger, NULL);
 	printk(KERN_INFO PREFIX "%s [%s]: AC Adapter [%s] (%s)\n",
 	       ACPI_SBS_DEVICE_NAME, acpi_device_bid(sbs->device),
 	       ACPI_AC_DIR_NAME, sbs->charger_present ? "on-line" : "off-line");
diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index e2633c085b36..bde47cde5902 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -433,7 +433,7 @@ static bool hidinput_setup_battery(struct hid_device *dev, unsigned report_type,
 	dev->battery_report_type = report_type;
 	dev->battery_report_id = field->report->id;
 
-	ret = power_supply_register(&dev->dev, battery);
+	ret = power_supply_register(&dev->dev, battery, NULL);
 	if (ret != 0) {
 		hid_warn(dev, "can't register power supply: %d\n", ret);
 		kfree(battery->name);
* Unmerged path drivers/hid/hid-sony.c
* Unmerged path drivers/hid/hid-wiimote-modules.c
* Unmerged path drivers/hid/wacom_sys.c
* Unmerged path drivers/platform/x86/compal-laptop.c
diff --git a/drivers/power/88pm860x_battery.c b/drivers/power/88pm860x_battery.c
index d338c1c4e8c8..209a43b3fd2b 100644
--- a/drivers/power/88pm860x_battery.c
+++ b/drivers/power/88pm860x_battery.c
@@ -953,7 +953,7 @@ static int pm860x_battery_probe(struct platform_device *pdev)
 	else
 		info->resistor = 300;	/* set default internal resistor */
 
-	ret = power_supply_register(&pdev->dev, &info->battery);
+	ret = power_supply_register(&pdev->dev, &info->battery, NULL);
 	if (ret)
 		return ret;
 	info->battery.dev->parent = &pdev->dev;
diff --git a/drivers/power/88pm860x_charger.c b/drivers/power/88pm860x_charger.c
index 36fb4b5a4b0d..ba28d8e3aaca 100644
--- a/drivers/power/88pm860x_charger.c
+++ b/drivers/power/88pm860x_charger.c
@@ -648,6 +648,7 @@ static struct pm860x_irq_desc {
 static int pm860x_charger_probe(struct platform_device *pdev)
 {
 	struct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);
+	struct power_supply_config psy_cfg = {};
 	struct pm860x_charger_info *info;
 	int ret;
 	int count;
@@ -687,12 +688,12 @@ static int pm860x_charger_probe(struct platform_device *pdev)
 
 	info->usb.name = "usb";
 	info->usb.type = POWER_SUPPLY_TYPE_USB;
-	info->usb.supplied_to = pm860x_supplied_to;
-	info->usb.num_supplicants = ARRAY_SIZE(pm860x_supplied_to);
 	info->usb.properties = pm860x_usb_props;
 	info->usb.num_properties = ARRAY_SIZE(pm860x_usb_props);
 	info->usb.get_property = pm860x_usb_get_prop;
-	ret = power_supply_register(&pdev->dev, &info->usb);
+	psy_cfg.supplied_to = pm860x_supplied_to;
+	psy_cfg.num_supplicants = ARRAY_SIZE(pm860x_supplied_to);
+	ret = power_supply_register(&pdev->dev, &info->usb, &psy_cfg);
 	if (ret)
 		goto out;
 
diff --git a/drivers/power/ab8500_btemp.c b/drivers/power/ab8500_btemp.c
index d412d34bf3df..38b008ce1edb 100644
--- a/drivers/power/ab8500_btemp.c
+++ b/drivers/power/ab8500_btemp.c
@@ -1059,6 +1059,7 @@ static int ab8500_btemp_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
 	struct abx500_bm_data *plat = pdev->dev.platform_data;
+	struct power_supply_config psy_cfg = {};
 	struct ab8500_btemp *di;
 	int irq, i, ret = 0;
 	u8 val;
@@ -1096,11 +1097,11 @@ static int ab8500_btemp_probe(struct platform_device *pdev)
 	di->btemp_psy.properties = ab8500_btemp_props;
 	di->btemp_psy.num_properties = ARRAY_SIZE(ab8500_btemp_props);
 	di->btemp_psy.get_property = ab8500_btemp_get_property;
-	di->btemp_psy.supplied_to = supply_interface;
-	di->btemp_psy.num_supplicants = ARRAY_SIZE(supply_interface);
 	di->btemp_psy.external_power_changed =
 		ab8500_btemp_external_power_changed;
 
+	psy_cfg.supplied_to = supply_interface;
+	psy_cfg.num_supplicants = ARRAY_SIZE(supply_interface);
 
 	/* Create a work queue for the btemp */
 	di->btemp_wq =
@@ -1141,7 +1142,7 @@ static int ab8500_btemp_probe(struct platform_device *pdev)
 	}
 
 	/* Register BTEMP power supply class */
-	ret = power_supply_register(di->dev, &di->btemp_psy);
+	ret = power_supply_register(di->dev, &di->btemp_psy, &psy_cfg);
 	if (ret) {
 		dev_err(di->dev, "failed to register BTEMP psy\n");
 		goto free_btemp_wq;
diff --git a/drivers/power/ab8500_charger.c b/drivers/power/ab8500_charger.c
index a558318b169c..34e2a3abbcee 100644
--- a/drivers/power/ab8500_charger.c
+++ b/drivers/power/ab8500_charger.c
@@ -3440,6 +3440,7 @@ static int ab8500_charger_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
 	struct abx500_bm_data *plat = pdev->dev.platform_data;
+	struct power_supply_config psy_cfg = {};
 	struct ab8500_charger *di;
 	int irq, i, charger_status, ret = 0, ch_stat;
 
@@ -3477,6 +3478,10 @@ static int ab8500_charger_probe(struct platform_device *pdev)
 	di->autopower = false;
 	di->invalid_charger_detect_state = 0;
 
+	/* AC and USB supply config */
+	psy_cfg.supplied_to = supply_interface;
+	psy_cfg.num_supplicants = ARRAY_SIZE(supply_interface);
+
 	/* AC supply */
 	/* power_supply base class */
 	di->ac_chg.psy.name = "ab8500_ac";
@@ -3484,8 +3489,6 @@ static int ab8500_charger_probe(struct platform_device *pdev)
 	di->ac_chg.psy.properties = ab8500_charger_ac_props;
 	di->ac_chg.psy.num_properties = ARRAY_SIZE(ab8500_charger_ac_props);
 	di->ac_chg.psy.get_property = ab8500_charger_ac_get_property;
-	di->ac_chg.psy.supplied_to = supply_interface;
-	di->ac_chg.psy.num_supplicants = ARRAY_SIZE(supply_interface),
 	/* ux500_charger sub-class */
 	di->ac_chg.ops.enable = &ab8500_charger_ac_en;
 	di->ac_chg.ops.check_enable = &ab8500_charger_ac_check_enable;
@@ -3511,8 +3514,6 @@ static int ab8500_charger_probe(struct platform_device *pdev)
 	di->usb_chg.psy.properties = ab8500_charger_usb_props;
 	di->usb_chg.psy.num_properties = ARRAY_SIZE(ab8500_charger_usb_props);
 	di->usb_chg.psy.get_property = ab8500_charger_usb_get_property;
-	di->usb_chg.psy.supplied_to = supply_interface;
-	di->usb_chg.psy.num_supplicants = ARRAY_SIZE(supply_interface),
 	/* ux500_charger sub-class */
 	di->usb_chg.ops.enable = &ab8500_charger_usb_en;
 	di->usb_chg.ops.check_enable = &ab8500_charger_usb_check_enable;
@@ -3610,7 +3611,8 @@ static int ab8500_charger_probe(struct platform_device *pdev)
 
 	/* Register AC charger class */
 	if (di->ac_chg.enabled) {
-		ret = power_supply_register(di->dev, &di->ac_chg.psy);
+		ret = power_supply_register(di->dev, &di->ac_chg.psy,
+						&psy_cfg);
 		if (ret) {
 			dev_err(di->dev, "failed to register AC charger\n");
 			goto free_charger_wq;
@@ -3619,7 +3621,8 @@ static int ab8500_charger_probe(struct platform_device *pdev)
 
 	/* Register USB charger class */
 	if (di->usb_chg.enabled) {
-		ret = power_supply_register(di->dev, &di->usb_chg.psy);
+		ret = power_supply_register(di->dev, &di->usb_chg.psy,
+						&psy_cfg);
 		if (ret) {
 			dev_err(di->dev, "failed to register USB charger\n");
 			goto free_ac;
diff --git a/drivers/power/ab8500_fg.c b/drivers/power/ab8500_fg.c
index c5391f5c372d..4144d4bd23a6 100644
--- a/drivers/power/ab8500_fg.c
+++ b/drivers/power/ab8500_fg.c
@@ -3092,6 +3092,7 @@ static int ab8500_fg_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
 	struct abx500_bm_data *plat = pdev->dev.platform_data;
+	struct power_supply_config psy_cfg = {};
 	struct ab8500_fg *di;
 	int i, irq;
 	int ret = 0;
@@ -3128,10 +3129,11 @@ static int ab8500_fg_probe(struct platform_device *pdev)
 	di->fg_psy.properties = ab8500_fg_props;
 	di->fg_psy.num_properties = ARRAY_SIZE(ab8500_fg_props);
 	di->fg_psy.get_property = ab8500_fg_get_property;
-	di->fg_psy.supplied_to = supply_interface;
-	di->fg_psy.num_supplicants = ARRAY_SIZE(supply_interface),
 	di->fg_psy.external_power_changed = ab8500_fg_external_power_changed;
 
+	psy_cfg.supplied_to = supply_interface;
+	psy_cfg.num_supplicants = ARRAY_SIZE(supply_interface);
+
 	di->bat_cap.max_mah_design = MILLI_TO_MICRO *
 		di->bm->bat_type[di->bm->batt_id].charge_full_design;
 
@@ -3191,7 +3193,7 @@ static int ab8500_fg_probe(struct platform_device *pdev)
 	di->flags.batt_id_received = false;
 
 	/* Register FG power supply class */
-	ret = power_supply_register(di->dev, &di->fg_psy);
+	ret = power_supply_register(di->dev, &di->fg_psy, &psy_cfg);
 	if (ret) {
 		dev_err(di->dev, "failed to register FG psy\n");
 		goto free_inst_curr_wq;
diff --git a/drivers/power/abx500_chargalg.c b/drivers/power/abx500_chargalg.c
index 9863e423602c..0aa635fb7746 100644
--- a/drivers/power/abx500_chargalg.c
+++ b/drivers/power/abx500_chargalg.c
@@ -2048,6 +2048,7 @@ static int abx500_chargalg_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
 	struct abx500_bm_data *plat = pdev->dev.platform_data;
+	struct power_supply_config psy_cfg = {};
 	struct abx500_chargalg *di;
 	int ret = 0;
 
@@ -2081,11 +2082,12 @@ static int abx500_chargalg_probe(struct platform_device *pdev)
 	di->chargalg_psy.properties = abx500_chargalg_props;
 	di->chargalg_psy.num_properties = ARRAY_SIZE(abx500_chargalg_props);
 	di->chargalg_psy.get_property = abx500_chargalg_get_property;
-	di->chargalg_psy.supplied_to = supply_interface;
-	di->chargalg_psy.num_supplicants = ARRAY_SIZE(supply_interface),
 	di->chargalg_psy.external_power_changed =
 		abx500_chargalg_external_power_changed;
 
+	psy_cfg.supplied_to = supply_interface;
+	psy_cfg.num_supplicants = ARRAY_SIZE(supply_interface);
+
 	/* Initilialize safety timer */
 	hrtimer_init(&di->safety_timer, CLOCK_REALTIME, HRTIMER_MODE_ABS);
 	di->safety_timer.function = abx500_chargalg_safety_timer_expired;
@@ -2116,7 +2118,7 @@ static int abx500_chargalg_probe(struct platform_device *pdev)
 	di->chg_info.prev_conn_chg = -1;
 
 	/* Register chargalg power supply class */
-	ret = power_supply_register(di->dev, &di->chargalg_psy);
+	ret = power_supply_register(di->dev, &di->chargalg_psy, &psy_cfg);
 	if (ret) {
 		dev_err(di->dev, "failed to register chargalg psy\n");
 		goto free_chargalg_wq;
* Unmerged path drivers/power/axp288_fuel_gauge.c
diff --git a/drivers/power/bq2415x_charger.c b/drivers/power/bq2415x_charger.c
index 0727f9256138..7030d15b40ab 100644
--- a/drivers/power/bq2415x_charger.c
+++ b/drivers/power/bq2415x_charger.c
@@ -1019,7 +1019,7 @@ static int bq2415x_power_supply_init(struct bq2415x_device *bq)
 		return -ENOMEM;
 	}
 
-	ret = power_supply_register(bq->dev, &bq->charger);
+	ret = power_supply_register(bq->dev, &bq->charger, NULL);
 	if (ret) {
 		kfree(bq->model);
 		return ret;
* Unmerged path drivers/power/bq24190_charger.c
* Unmerged path drivers/power/bq24735-charger.c
* Unmerged path drivers/power/bq27x00_battery.c
diff --git a/drivers/power/charger-manager.c b/drivers/power/charger-manager.c
index 98de1ddce458..da6973d105ec 100644
--- a/drivers/power/charger-manager.c
+++ b/drivers/power/charger-manager.c
@@ -1634,7 +1634,7 @@ static int charger_manager_probe(struct platform_device *pdev)
 
 	INIT_DELAYED_WORK(&cm->fullbatt_vchk_work, fullbatt_vchk);
 
-	ret = power_supply_register(NULL, &cm->charger_psy);
+	ret = power_supply_register(NULL, &cm->charger_psy, NULL);
 	if (ret) {
 		dev_err(&pdev->dev, "Cannot register charger-manager with"
 				" name \"%s\".\n", cm->charger_psy.name);
diff --git a/drivers/power/collie_battery.c b/drivers/power/collie_battery.c
index c58d0e31bdef..c8b99fa19edc 100644
--- a/drivers/power/collie_battery.c
+++ b/drivers/power/collie_battery.c
@@ -323,10 +323,10 @@ static int collie_bat_probe(struct ucb1x00_dev *dev)
 
 	INIT_WORK(&bat_work, collie_bat_work);
 
-	ret = power_supply_register(&dev->ucb->dev, &collie_bat_main.psy);
+	ret = power_supply_register(&dev->ucb->dev, &collie_bat_main.psy, NULL);
 	if (ret)
 		goto err_psy_reg_main;
-	ret = power_supply_register(&dev->ucb->dev, &collie_bat_bu.psy);
+	ret = power_supply_register(&dev->ucb->dev, &collie_bat_bu.psy, NULL);
 	if (ret)
 		goto err_psy_reg_bu;
 
diff --git a/drivers/power/da9030_battery.c b/drivers/power/da9030_battery.c
index ae6c41835ee6..df03f30cd11a 100644
--- a/drivers/power/da9030_battery.c
+++ b/drivers/power/da9030_battery.c
@@ -541,7 +541,7 @@ static int da9030_battery_probe(struct platform_device *pdev)
 		goto err_notifier;
 
 	da9030_battery_setup_psy(charger);
-	ret = power_supply_register(&pdev->dev, &charger->psy);
+	ret = power_supply_register(&pdev->dev, &charger->psy, NULL);
 	if (ret)
 		goto err_ps_register;
 
diff --git a/drivers/power/da9052-battery.c b/drivers/power/da9052-battery.c
index f8f4c0f7c17d..4cd679c100d0 100644
--- a/drivers/power/da9052-battery.c
+++ b/drivers/power/da9052-battery.c
@@ -625,7 +625,7 @@ static s32 da9052_bat_probe(struct platform_device *pdev)
 		}
 	}
 
-	ret = power_supply_register(&pdev->dev, &bat->psy);
+	ret = power_supply_register(&pdev->dev, &bat->psy, NULL);
 	 if (ret)
 		goto err;
 
* Unmerged path drivers/power/da9150-charger.c
diff --git a/drivers/power/ds2760_battery.c b/drivers/power/ds2760_battery.c
index 85b4e6eca0b1..e82dff0bbb20 100644
--- a/drivers/power/ds2760_battery.c
+++ b/drivers/power/ds2760_battery.c
@@ -555,7 +555,7 @@ static int ds2760_battery_probe(struct platform_device *pdev)
 	if (current_accum)
 		ds2760_battery_set_current_accum(di, current_accum);
 
-	retval = power_supply_register(&pdev->dev, &di->bat);
+	retval = power_supply_register(&pdev->dev, &di->bat, NULL);
 	if (retval) {
 		dev_err(di->dev, "failed to register battery\n");
 		goto batt_failed;
diff --git a/drivers/power/ds2780_battery.c b/drivers/power/ds2780_battery.c
index 9f418fa879e5..b1d3570ea730 100644
--- a/drivers/power/ds2780_battery.c
+++ b/drivers/power/ds2780_battery.c
@@ -776,7 +776,7 @@ static int ds2780_battery_probe(struct platform_device *pdev)
 	dev_info->bat.num_properties	= ARRAY_SIZE(ds2780_battery_props);
 	dev_info->bat.get_property	= ds2780_battery_get_property;
 
-	ret = power_supply_register(&pdev->dev, &dev_info->bat);
+	ret = power_supply_register(&pdev->dev, &dev_info->bat, NULL);
 	if (ret) {
 		dev_err(dev_info->dev, "failed to register battery\n");
 		goto fail;
diff --git a/drivers/power/ds2781_battery.c b/drivers/power/ds2781_battery.c
index 0a5acc6fc6f0..50686dc59711 100644
--- a/drivers/power/ds2781_battery.c
+++ b/drivers/power/ds2781_battery.c
@@ -769,7 +769,7 @@ static int ds2781_battery_probe(struct platform_device *pdev)
 	dev_info->bat.num_properties	= ARRAY_SIZE(ds2781_battery_props);
 	dev_info->bat.get_property	= ds2781_battery_get_property;
 
-	ret = power_supply_register(&pdev->dev, &dev_info->bat);
+	ret = power_supply_register(&pdev->dev, &dev_info->bat, NULL);
 	if (ret) {
 		dev_err(dev_info->dev, "failed to register battery\n");
 		goto fail;
diff --git a/drivers/power/ds2782_battery.c b/drivers/power/ds2782_battery.c
index 563174891c90..7502e9d289cb 100644
--- a/drivers/power/ds2782_battery.c
+++ b/drivers/power/ds2782_battery.c
@@ -428,7 +428,7 @@ static int ds278x_battery_probe(struct i2c_client *client,
 
 	INIT_DELAYED_WORK(&info->bat_work, ds278x_bat_work);
 
-	ret = power_supply_register(&client->dev, &info->battery);
+	ret = power_supply_register(&client->dev, &info->battery, NULL);
 	if (ret) {
 		dev_err(&client->dev, "failed to register battery\n");
 		goto fail_register;
diff --git a/drivers/power/generic-adc-battery.c b/drivers/power/generic-adc-battery.c
index 8cb5d7f67ace..dc7a7df2c0b7 100644
--- a/drivers/power/generic-adc-battery.c
+++ b/drivers/power/generic-adc-battery.c
@@ -310,7 +310,7 @@ static int gab_probe(struct platform_device *pdev)
 	 */
 	psy->num_properties = ARRAY_SIZE(gab_props) + index;
 
-	ret = power_supply_register(&pdev->dev, psy);
+	ret = power_supply_register(&pdev->dev, psy, NULL);
 	if (ret)
 		goto err_reg_fail;
 
diff --git a/drivers/power/goldfish_battery.c b/drivers/power/goldfish_battery.c
index 29eba88a2963..61d437f8cf76 100644
--- a/drivers/power/goldfish_battery.c
+++ b/drivers/power/goldfish_battery.c
@@ -195,11 +195,11 @@ static int goldfish_battery_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	ret = power_supply_register(&pdev->dev, &data->ac);
+	ret = power_supply_register(&pdev->dev, &data->ac, NULL);
 	if (ret)
 		return ret;
 
-	ret = power_supply_register(&pdev->dev, &data->battery);
+	ret = power_supply_register(&pdev->dev, &data->battery, NULL);
 	if (ret) {
 		power_supply_unregister(&data->ac);
 		return ret;
* Unmerged path drivers/power/gpio-charger.c
diff --git a/drivers/power/intel_mid_battery.c b/drivers/power/intel_mid_battery.c
index 18d136b443ee..52573c13e75a 100644
--- a/drivers/power/intel_mid_battery.c
+++ b/drivers/power/intel_mid_battery.c
@@ -692,7 +692,7 @@ static int probe(int irq, struct device *dev)
 	pbi->batt.properties = pmic_battery_props;
 	pbi->batt.num_properties = ARRAY_SIZE(pmic_battery_props);
 	pbi->batt.get_property = pmic_battery_get_property;
-	retval = power_supply_register(dev, &pbi->batt);
+	retval = power_supply_register(dev, &pbi->batt, NULL);
 	if (retval) {
 		dev_err(dev,
 			"%s(): failed to register pmic battery device with power supply subsystem\n",
@@ -712,7 +712,7 @@ static int probe(int irq, struct device *dev)
 	pbi->usb.properties = pmic_usb_props;
 	pbi->usb.num_properties = ARRAY_SIZE(pmic_usb_props);
 	pbi->usb.get_property = pmic_usb_get_property;
-	retval = power_supply_register(dev, &pbi->usb);
+	retval = power_supply_register(dev, &pbi->usb, NULL);
 	if (retval) {
 		dev_err(dev,
 			"%s(): failed to register pmic usb device with power supply subsystem\n",
* Unmerged path drivers/power/ipaq_micro_battery.c
diff --git a/drivers/power/isp1704_charger.c b/drivers/power/isp1704_charger.c
index fc04d191579b..2008d6ac0637 100644
--- a/drivers/power/isp1704_charger.c
+++ b/drivers/power/isp1704_charger.c
@@ -434,7 +434,7 @@ static int isp1704_charger_probe(struct platform_device *pdev)
 	isp->psy.num_properties	= ARRAY_SIZE(power_props);
 	isp->psy.get_property	= isp1704_charger_get_property;
 
-	ret = power_supply_register(isp->dev, &isp->psy);
+	ret = power_supply_register(isp->dev, &isp->psy, NULL);
 	if (ret)
 		goto fail1;
 
diff --git a/drivers/power/jz4740-battery.c b/drivers/power/jz4740-battery.c
index c675553d4647..d8c1e4a39e2c 100644
--- a/drivers/power/jz4740-battery.c
+++ b/drivers/power/jz4740-battery.c
@@ -330,7 +330,7 @@ static int jz_battery_probe(struct platform_device *pdev)
 	else
 		jz4740_adc_set_config(pdev->dev.parent, JZ_ADC_CONFIG_BAT_MB, 0);
 
-	ret = power_supply_register(&pdev->dev, &jz_battery->battery);
+	ret = power_supply_register(&pdev->dev, &jz_battery->battery, NULL);
 	if (ret) {
 		dev_err(&pdev->dev, "power supply battery register failed.\n");
 		goto err_free_charge_irq;
diff --git a/drivers/power/lp8727_charger.c b/drivers/power/lp8727_charger.c
index 5ef41b819172..6f5e14b1bfde 100644
--- a/drivers/power/lp8727_charger.c
+++ b/drivers/power/lp8727_charger.c
@@ -419,6 +419,7 @@ static void lp8727_charger_changed(struct power_supply *psy)
 
 static int lp8727_register_psy(struct lp8727_chg *pchg)
 {
+	struct power_supply_config psy_cfg = {}; /* Only for ac and usb */
 	struct lp8727_psy *psy;
 
 	psy = devm_kzalloc(pchg->dev, sizeof(*psy), GFP_KERNEL);
@@ -427,15 +428,16 @@ static int lp8727_register_psy(struct lp8727_chg *pchg)
 
 	pchg->psy = psy;
 
+	psy_cfg.supplied_to = battery_supplied_to;
+	psy_cfg.num_supplicants = ARRAY_SIZE(battery_supplied_to);
+
 	psy->ac.name = "ac";
 	psy->ac.type = POWER_SUPPLY_TYPE_MAINS;
 	psy->ac.properties = lp8727_charger_prop;
 	psy->ac.num_properties = ARRAY_SIZE(lp8727_charger_prop);
 	psy->ac.get_property = lp8727_charger_get_property;
-	psy->ac.supplied_to = battery_supplied_to;
-	psy->ac.num_supplicants = ARRAY_SIZE(battery_supplied_to);
 
-	if (power_supply_register(pchg->dev, &psy->ac))
+	if (power_supply_register(pchg->dev, &psy->ac, &psy_cfg))
 		goto err_psy_ac;
 
 	psy->usb.name = "usb";
@@ -443,10 +445,8 @@ static int lp8727_register_psy(struct lp8727_chg *pchg)
 	psy->usb.properties = lp8727_charger_prop;
 	psy->usb.num_properties = ARRAY_SIZE(lp8727_charger_prop);
 	psy->usb.get_property = lp8727_charger_get_property;
-	psy->usb.supplied_to = battery_supplied_to;
-	psy->usb.num_supplicants = ARRAY_SIZE(battery_supplied_to);
 
-	if (power_supply_register(pchg->dev, &psy->usb))
+	if (power_supply_register(pchg->dev, &psy->usb, &psy_cfg))
 		goto err_psy_usb;
 
 	psy->batt.name = "main_batt";
@@ -456,7 +456,7 @@ static int lp8727_register_psy(struct lp8727_chg *pchg)
 	psy->batt.get_property = lp8727_battery_get_property;
 	psy->batt.external_power_changed = lp8727_charger_changed;
 
-	if (power_supply_register(pchg->dev, &psy->batt))
+	if (power_supply_register(pchg->dev, &psy->batt, NULL))
 		goto err_psy_batt;
 
 	return 0;
* Unmerged path drivers/power/lp8788-charger.c
* Unmerged path drivers/power/ltc2941-battery-gauge.c
* Unmerged path drivers/power/max14577_charger.c
diff --git a/drivers/power/max17040_battery.c b/drivers/power/max17040_battery.c
index c7ff6d67f158..c50c4bb9e34c 100644
--- a/drivers/power/max17040_battery.c
+++ b/drivers/power/max17040_battery.c
@@ -222,7 +222,7 @@ static int max17040_probe(struct i2c_client *client,
 	chip->battery.properties	= max17040_battery_props;
 	chip->battery.num_properties	= ARRAY_SIZE(max17040_battery_props);
 
-	ret = power_supply_register(&client->dev, &chip->battery);
+	ret = power_supply_register(&client->dev, &chip->battery, NULL);
 	if (ret) {
 		dev_err(&client->dev, "failed: power supply register\n");
 		return ret;
diff --git a/drivers/power/max17042_battery.c b/drivers/power/max17042_battery.c
index d664ef58afa7..8bd2b5e87e26 100644
--- a/drivers/power/max17042_battery.c
+++ b/drivers/power/max17042_battery.c
@@ -742,7 +742,7 @@ static int max17042_probe(struct i2c_client *client,
 		max17042_write_reg(client, MAX17042_LearnCFG, 0x0007);
 	}
 
-	ret = power_supply_register(&client->dev, &chip->battery);
+	ret = power_supply_register(&client->dev, &chip->battery, NULL);
 	if (ret) {
 		dev_err(&client->dev, "failed: power supply register\n");
 		return ret;
* Unmerged path drivers/power/max77693_charger.c
diff --git a/drivers/power/max8903_charger.c b/drivers/power/max8903_charger.c
index 08f0d7909b6b..114dc20b2736 100644
--- a/drivers/power/max8903_charger.c
+++ b/drivers/power/max8903_charger.c
@@ -288,7 +288,7 @@ static int max8903_probe(struct platform_device *pdev)
 	data->psy.properties = max8903_charger_props;
 	data->psy.num_properties = ARRAY_SIZE(max8903_charger_props);
 
-	ret = power_supply_register(dev, &data->psy);
+	ret = power_supply_register(dev, &data->psy, NULL);
 	if (ret) {
 		dev_err(dev, "failed: power supply register.\n");
 		goto err;
diff --git a/drivers/power/max8925_power.c b/drivers/power/max8925_power.c
index 0ee1e14f76e9..2d7572ecd9c2 100644
--- a/drivers/power/max8925_power.c
+++ b/drivers/power/max8925_power.c
@@ -478,6 +478,7 @@ max8925_power_dt_init(struct platform_device *pdev)
 static int max8925_power_probe(struct platform_device *pdev)
 {
 	struct max8925_chip *chip = dev_get_drvdata(pdev->dev.parent);
+	struct power_supply_config psy_cfg = {}; /* Only for ac and usb */
 	struct max8925_power_pdata *pdata = NULL;
 	struct max8925_power_info *info;
 	int ret;
@@ -498,14 +499,15 @@ static int max8925_power_probe(struct platform_device *pdev)
 	info->adc = chip->adc;
 	platform_set_drvdata(pdev, info);
 
+	psy_cfg.supplied_to = pdata->supplied_to;
+	psy_cfg.num_supplicants = pdata->num_supplicants;
+
 	info->ac.name = "max8925-ac";
 	info->ac.type = POWER_SUPPLY_TYPE_MAINS;
 	info->ac.properties = max8925_ac_props;
 	info->ac.num_properties = ARRAY_SIZE(max8925_ac_props);
 	info->ac.get_property = max8925_ac_get_prop;
-	info->ac.supplied_to = pdata->supplied_to;
-	info->ac.num_supplicants = pdata->num_supplicants;
-	ret = power_supply_register(&pdev->dev, &info->ac);
+	ret = power_supply_register(&pdev->dev, &info->ac, &psy_cfg);
 	if (ret)
 		goto out;
 	info->ac.dev->parent = &pdev->dev;
@@ -515,10 +517,8 @@ static int max8925_power_probe(struct platform_device *pdev)
 	info->usb.properties = max8925_usb_props;
 	info->usb.num_properties = ARRAY_SIZE(max8925_usb_props);
 	info->usb.get_property = max8925_usb_get_prop;
-	info->usb.supplied_to = pdata->supplied_to;
-	info->usb.num_supplicants = pdata->num_supplicants;
 
-	ret = power_supply_register(&pdev->dev, &info->usb);
+	ret = power_supply_register(&pdev->dev, &info->usb, &psy_cfg);
 	if (ret)
 		goto out_usb;
 	info->usb.dev->parent = &pdev->dev;
@@ -528,7 +528,7 @@ static int max8925_power_probe(struct platform_device *pdev)
 	info->battery.properties = max8925_battery_props;
 	info->battery.num_properties = ARRAY_SIZE(max8925_battery_props);
 	info->battery.get_property = max8925_bat_get_prop;
-	ret = power_supply_register(&pdev->dev, &info->battery);
+	ret = power_supply_register(&pdev->dev, &info->battery, NULL);
 	if (ret)
 		goto out_battery;
 	info->battery.dev->parent = &pdev->dev;
diff --git a/drivers/power/max8997_charger.c b/drivers/power/max8997_charger.c
index 4bdedfed936d..68b858849eb0 100644
--- a/drivers/power/max8997_charger.c
+++ b/drivers/power/max8997_charger.c
@@ -156,7 +156,7 @@ static int max8997_battery_probe(struct platform_device *pdev)
 	charger->dev = &pdev->dev;
 	charger->iodev = iodev;
 
-	ret = power_supply_register(&pdev->dev, &charger->battery);
+	ret = power_supply_register(&pdev->dev, &charger->battery, NULL);
 	if (ret) {
 		dev_err(&pdev->dev, "failed: power supply register\n");
 		return ret;
diff --git a/drivers/power/max8998_charger.c b/drivers/power/max8998_charger.c
index 5017470c2fc9..b1eeeae6e159 100644
--- a/drivers/power/max8998_charger.c
+++ b/drivers/power/max8998_charger.c
@@ -167,7 +167,7 @@ static int max8998_battery_probe(struct platform_device *pdev)
 	max8998->battery.properties = max8998_battery_props;
 	max8998->battery.num_properties = ARRAY_SIZE(max8998_battery_props);
 
-	ret = power_supply_register(max8998->dev, &max8998->battery);
+	ret = power_supply_register(max8998->dev, &max8998->battery, NULL);
 	if (ret) {
 		dev_err(max8998->dev, "failed: power supply register\n");
 		goto err;
diff --git a/drivers/power/olpc_battery.c b/drivers/power/olpc_battery.c
index 1ec810ada5ed..7f080ce8ba08 100644
--- a/drivers/power/olpc_battery.c
+++ b/drivers/power/olpc_battery.c
@@ -619,7 +619,7 @@ static int olpc_battery_probe(struct platform_device *pdev)
 
 	/* Ignore the status. It doesn't actually matter */
 
-	ret = power_supply_register(&pdev->dev, &olpc_ac);
+	ret = power_supply_register(&pdev->dev, &olpc_ac, NULL);
 	if (ret)
 		return ret;
 
@@ -631,7 +631,7 @@ static int olpc_battery_probe(struct platform_device *pdev)
 		olpc_bat.num_properties = ARRAY_SIZE(olpc_xo1_bat_props);
 	}
 
-	ret = power_supply_register(&pdev->dev, &olpc_bat);
+	ret = power_supply_register(&pdev->dev, &olpc_bat, NULL);
 	if (ret)
 		goto battery_failed;
 
diff --git a/drivers/power/pcf50633-charger.c b/drivers/power/pcf50633-charger.c
index 17fd77f24b2a..cbd666431bed 100644
--- a/drivers/power/pcf50633-charger.c
+++ b/drivers/power/pcf50633-charger.c
@@ -368,6 +368,7 @@ static const u8 mbc_irq_handlers[] = {
 
 static int pcf50633_mbc_probe(struct platform_device *pdev)
 {
+	struct power_supply_config psy_cfg = {};
 	struct pcf50633_mbc *mbc;
 	int ret;
 	int i;
@@ -385,45 +386,42 @@ static int pcf50633_mbc_probe(struct platform_device *pdev)
 		pcf50633_register_irq(mbc->pcf, mbc_irq_handlers[i],
 					pcf50633_mbc_irq_handler, mbc);
 
+	psy_cfg.supplied_to		= mbc->pcf->pdata->batteries;
+	psy_cfg.num_supplicants		= mbc->pcf->pdata->num_batteries;
+
 	/* Create power supplies */
 	mbc->adapter.name		= "adapter";
 	mbc->adapter.type		= POWER_SUPPLY_TYPE_MAINS;
 	mbc->adapter.properties		= power_props;
 	mbc->adapter.num_properties	= ARRAY_SIZE(power_props);
 	mbc->adapter.get_property	= &adapter_get_property;
-	mbc->adapter.supplied_to	= mbc->pcf->pdata->batteries;
-	mbc->adapter.num_supplicants	= mbc->pcf->pdata->num_batteries;
 
 	mbc->usb.name			= "usb";
 	mbc->usb.type			= POWER_SUPPLY_TYPE_USB;
 	mbc->usb.properties		= power_props;
 	mbc->usb.num_properties		= ARRAY_SIZE(power_props);
 	mbc->usb.get_property		= usb_get_property;
-	mbc->usb.supplied_to		= mbc->pcf->pdata->batteries;
-	mbc->usb.num_supplicants	= mbc->pcf->pdata->num_batteries;
 
 	mbc->ac.name			= "ac";
 	mbc->ac.type			= POWER_SUPPLY_TYPE_MAINS;
 	mbc->ac.properties		= power_props;
 	mbc->ac.num_properties		= ARRAY_SIZE(power_props);
 	mbc->ac.get_property		= ac_get_property;
-	mbc->ac.supplied_to		= mbc->pcf->pdata->batteries;
-	mbc->ac.num_supplicants		= mbc->pcf->pdata->num_batteries;
 
-	ret = power_supply_register(&pdev->dev, &mbc->adapter);
+	ret = power_supply_register(&pdev->dev, &mbc->adapter, &psy_cfg);
 	if (ret) {
 		dev_err(mbc->pcf->dev, "failed to register adapter\n");
 		return ret;
 	}
 
-	ret = power_supply_register(&pdev->dev, &mbc->usb);
+	ret = power_supply_register(&pdev->dev, &mbc->usb, &psy_cfg);
 	if (ret) {
 		dev_err(mbc->pcf->dev, "failed to register usb\n");
 		power_supply_unregister(&mbc->adapter);
 		return ret;
 	}
 
-	ret = power_supply_register(&pdev->dev, &mbc->ac);
+	ret = power_supply_register(&pdev->dev, &mbc->ac, &psy_cfg);
 	if (ret) {
 		dev_err(mbc->pcf->dev, "failed to register ac\n");
 		power_supply_unregister(&mbc->adapter);
diff --git a/drivers/power/pda_power.c b/drivers/power/pda_power.c
index 0c52e2a0d90c..fd55fad1d0db 100644
--- a/drivers/power/pda_power.c
+++ b/drivers/power/pda_power.c
@@ -83,8 +83,6 @@ static char *pda_power_supplied_to[] = {
 static struct power_supply pda_psy_ac = {
 	.name = "ac",
 	.type = POWER_SUPPLY_TYPE_MAINS,
-	.supplied_to = pda_power_supplied_to,
-	.num_supplicants = ARRAY_SIZE(pda_power_supplied_to),
 	.properties = pda_power_props,
 	.num_properties = ARRAY_SIZE(pda_power_props),
 	.get_property = pda_power_get_property,
@@ -93,8 +91,6 @@ static struct power_supply pda_psy_ac = {
 static struct power_supply pda_psy_usb = {
 	.name = "usb",
 	.type = POWER_SUPPLY_TYPE_USB,
-	.supplied_to = pda_power_supplied_to,
-	.num_supplicants = ARRAY_SIZE(pda_power_supplied_to),
 	.properties = pda_power_props,
 	.num_properties = ARRAY_SIZE(pda_power_props),
 	.get_property = pda_power_get_property,
@@ -262,6 +258,7 @@ static int otg_handle_notification(struct notifier_block *nb,
 
 static int pda_power_probe(struct platform_device *pdev)
 {
+	struct power_supply_config psy_cfg = {};
 	int ret = 0;
 
 	dev = &pdev->dev;
@@ -309,10 +306,11 @@ static int pda_power_probe(struct platform_device *pdev)
 	usb_irq = platform_get_resource_byname(pdev, IORESOURCE_IRQ, "usb");
 
 	if (pdata->supplied_to) {
-		pda_psy_ac.supplied_to = pdata->supplied_to;
-		pda_psy_ac.num_supplicants = pdata->num_supplicants;
-		pda_psy_usb.supplied_to = pdata->supplied_to;
-		pda_psy_usb.num_supplicants = pdata->num_supplicants;
+		psy_cfg.supplied_to = pdata->supplied_to;
+		psy_cfg.num_supplicants = pdata->num_supplicants;
+	} else {
+		psy_cfg.supplied_to = pda_power_supplied_to;
+		psy_cfg.num_supplicants = ARRAY_SIZE(pda_power_supplied_to);
 	}
 
 #if IS_ENABLED(CONFIG_USB_PHY)
@@ -326,7 +324,7 @@ static int pda_power_probe(struct platform_device *pdev)
 #endif
 
 	if (pdata->is_ac_online) {
-		ret = power_supply_register(&pdev->dev, &pda_psy_ac);
+		ret = power_supply_register(&pdev->dev, &pda_psy_ac, &psy_cfg);
 		if (ret) {
 			dev_err(dev, "failed to register %s power supply\n",
 				pda_psy_ac.name);
@@ -347,7 +345,7 @@ static int pda_power_probe(struct platform_device *pdev)
 	}
 
 	if (pdata->is_usb_online) {
-		ret = power_supply_register(&pdev->dev, &pda_psy_usb);
+		ret = power_supply_register(&pdev->dev, &pda_psy_usb, &psy_cfg);
 		if (ret) {
 			dev_err(dev, "failed to register %s power supply\n",
 				pda_psy_usb.name);
diff --git a/drivers/power/pm2301_charger.c b/drivers/power/pm2301_charger.c
index fef56e2041b3..8b3565f86ce3 100644
--- a/drivers/power/pm2301_charger.c
+++ b/drivers/power/pm2301_charger.c
@@ -1002,6 +1002,7 @@ static int pm2xxx_wall_charger_probe(struct i2c_client *i2c_client,
 		const struct i2c_device_id *id)
 {
 	struct pm2xxx_platform_data *pl_data = i2c_client->dev.platform_data;
+	struct power_supply_config psy_cfg = {};
 	struct pm2xxx_charger *pm2;
 	int ret = 0;
 	u8 val;
@@ -1055,8 +1056,9 @@ static int pm2xxx_wall_charger_probe(struct i2c_client *i2c_client,
 	pm2->ac_chg.psy.properties = pm2xxx_charger_ac_props;
 	pm2->ac_chg.psy.num_properties = ARRAY_SIZE(pm2xxx_charger_ac_props);
 	pm2->ac_chg.psy.get_property = pm2xxx_charger_ac_get_property;
-	pm2->ac_chg.psy.supplied_to = pm2->pdata->supplied_to;
-	pm2->ac_chg.psy.num_supplicants = pm2->pdata->num_supplicants;
+
+	psy_cfg.supplied_to = pm2->pdata->supplied_to;
+	psy_cfg.num_supplicants = pm2->pdata->num_supplicants;
 	/* pm2xxx_charger sub-class */
 	pm2->ac_chg.ops.enable = &pm2xxx_charger_ac_en;
 	pm2->ac_chg.ops.kick_wd = &pm2xxx_charger_watchdog_kick;
@@ -1101,7 +1103,7 @@ static int pm2xxx_wall_charger_probe(struct i2c_client *i2c_client,
 	}
 
 	/* Register AC charger class */
-	ret = power_supply_register(pm2->dev, &pm2->ac_chg.psy);
+	ret = power_supply_register(pm2->dev, &pm2->ac_chg.psy, &psy_cfg);
 	if (ret) {
 		dev_err(pm2->dev, "failed to register AC charger\n");
 		goto free_regulator;
diff --git a/drivers/power/pmu_battery.c b/drivers/power/pmu_battery.c
index 023d24993b87..fb026f19aa4a 100644
--- a/drivers/power/pmu_battery.c
+++ b/drivers/power/pmu_battery.c
@@ -152,7 +152,7 @@ static int __init pmu_bat_init(void)
 		goto pdev_register_failed;
 	}
 
-	ret = power_supply_register(&bat_pdev->dev, &pmu_ac);
+	ret = power_supply_register(&bat_pdev->dev, &pmu_ac, NULL);
 	if (ret)
 		goto ac_register_failed;
 
@@ -169,7 +169,7 @@ static int __init pmu_bat_init(void)
 		pbat->bat.get_property = pmu_bat_get_property;
 		pbat->pbi = &pmu_batteries[i];
 
-		ret = power_supply_register(&bat_pdev->dev, &pbat->bat);
+		ret = power_supply_register(&bat_pdev->dev, &pbat->bat, NULL);
 		if (ret) {
 			kfree(pbat);
 			goto battery_register_failed;
* Unmerged path drivers/power/power_supply_core.c
* Unmerged path drivers/power/rt5033_battery.c
* Unmerged path drivers/power/rx51_battery.c
diff --git a/drivers/power/s3c_adc_battery.c b/drivers/power/s3c_adc_battery.c
index 5948ce058bdd..b6ff213373dd 100644
--- a/drivers/power/s3c_adc_battery.c
+++ b/drivers/power/s3c_adc_battery.c
@@ -310,14 +310,14 @@ static int s3c_adc_bat_probe(struct platform_device *pdev)
 	main_bat.cable_plugged = 0;
 	main_bat.status = POWER_SUPPLY_STATUS_DISCHARGING;
 
-	ret = power_supply_register(&pdev->dev, &main_bat.psy);
+	ret = power_supply_register(&pdev->dev, &main_bat.psy, NULL);
 	if (ret)
 		goto err_reg_main;
 	if (pdata->backup_volt_mult) {
 		backup_bat.client = client;
 		backup_bat.pdata = pdev->dev.platform_data;
 		backup_bat.volt_value = -1;
-		ret = power_supply_register(&pdev->dev, &backup_bat.psy);
+		ret = power_supply_register(&pdev->dev, &backup_bat.psy, NULL);
 		if (ret)
 			goto err_reg_backup;
 	}
* Unmerged path drivers/power/sbs-battery.c
diff --git a/drivers/power/smb347-charger.c b/drivers/power/smb347-charger.c
index acf84e80fe98..5999e1b85983 100644
--- a/drivers/power/smb347-charger.c
+++ b/drivers/power/smb347-charger.c
@@ -1193,6 +1193,7 @@ static int smb347_probe(struct i2c_client *client,
 {
 	static char *battery[] = { "smb347-battery" };
 	const struct smb347_charger_platform_data *pdata;
+	struct power_supply_config psy_cfg = {}; /* Only for mains and usb */
 	struct device *dev = &client->dev;
 	struct smb347_charger *smb;
 	int ret;
@@ -1222,15 +1223,15 @@ static int smb347_probe(struct i2c_client *client,
 	if (ret < 0)
 		return ret;
 
+	psy_cfg.supplied_to = battery;
+	psy_cfg.num_supplicants = ARRAY_SIZE(battery);
 	if (smb->pdata->use_mains) {
 		smb->mains.name = "smb347-mains";
 		smb->mains.type = POWER_SUPPLY_TYPE_MAINS;
 		smb->mains.get_property = smb347_mains_get_property;
 		smb->mains.properties = smb347_mains_properties;
 		smb->mains.num_properties = ARRAY_SIZE(smb347_mains_properties);
-		smb->mains.supplied_to = battery;
-		smb->mains.num_supplicants = ARRAY_SIZE(battery);
-		ret = power_supply_register(dev, &smb->mains);
+		ret = power_supply_register(dev, &smb->mains, &psy_cfg);
 		if (ret < 0)
 			return ret;
 	}
@@ -1241,9 +1242,7 @@ static int smb347_probe(struct i2c_client *client,
 		smb->usb.get_property = smb347_usb_get_property;
 		smb->usb.properties = smb347_usb_properties;
 		smb->usb.num_properties = ARRAY_SIZE(smb347_usb_properties);
-		smb->usb.supplied_to = battery;
-		smb->usb.num_supplicants = ARRAY_SIZE(battery);
-		ret = power_supply_register(dev, &smb->usb);
+		ret = power_supply_register(dev, &smb->usb, &psy_cfg);
 		if (ret < 0) {
 			if (smb->pdata->use_mains)
 				power_supply_unregister(&smb->mains);
@@ -1258,7 +1257,7 @@ static int smb347_probe(struct i2c_client *client,
 	smb->battery.num_properties = ARRAY_SIZE(smb347_battery_properties);
 
 
-	ret = power_supply_register(dev, &smb->battery);
+	ret = power_supply_register(dev, &smb->battery, NULL);
 	if (ret < 0) {
 		if (smb->pdata->use_usb)
 			power_supply_unregister(&smb->usb);
* Unmerged path drivers/power/test_power.c
diff --git a/drivers/power/tosa_battery.c b/drivers/power/tosa_battery.c
index 0224de50c540..835bef0df2fd 100644
--- a/drivers/power/tosa_battery.c
+++ b/drivers/power/tosa_battery.c
@@ -358,13 +358,13 @@ static int tosa_bat_probe(struct platform_device *dev)
 
 	INIT_WORK(&bat_work, tosa_bat_work);
 
-	ret = power_supply_register(&dev->dev, &tosa_bat_main.psy);
+	ret = power_supply_register(&dev->dev, &tosa_bat_main.psy, NULL);
 	if (ret)
 		goto err_psy_reg_main;
-	ret = power_supply_register(&dev->dev, &tosa_bat_jacket.psy);
+	ret = power_supply_register(&dev->dev, &tosa_bat_jacket.psy, NULL);
 	if (ret)
 		goto err_psy_reg_jacket;
-	ret = power_supply_register(&dev->dev, &tosa_bat_bu.psy);
+	ret = power_supply_register(&dev->dev, &tosa_bat_bu.psy, NULL);
 	if (ret)
 		goto err_psy_reg_bu;
 
* Unmerged path drivers/power/tps65090-charger.c
diff --git a/drivers/power/twl4030_charger.c b/drivers/power/twl4030_charger.c
index bed458172dd2..62fee6890185 100644
--- a/drivers/power/twl4030_charger.c
+++ b/drivers/power/twl4030_charger.c
@@ -513,7 +513,7 @@ static int __init twl4030_bci_probe(struct platform_device *pdev)
 	bci->ac.num_properties = ARRAY_SIZE(twl4030_charger_props);
 	bci->ac.get_property = twl4030_bci_get_property;
 
-	ret = power_supply_register(&pdev->dev, &bci->ac);
+	ret = power_supply_register(&pdev->dev, &bci->ac, NULL);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to register ac: %d\n", ret);
 		goto fail_register_ac;
@@ -527,7 +527,7 @@ static int __init twl4030_bci_probe(struct platform_device *pdev)
 
 	bci->usb_reg = regulator_get(bci->dev, "bci3v1");
 
-	ret = power_supply_register(&pdev->dev, &bci->usb);
+	ret = power_supply_register(&pdev->dev, &bci->usb, NULL);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to register usb: %d\n", ret);
 		goto fail_register_usb;
* Unmerged path drivers/power/twl4030_madc_battery.c
diff --git a/drivers/power/wm831x_backup.c b/drivers/power/wm831x_backup.c
index 56fb509f4be0..60ae871148b0 100644
--- a/drivers/power/wm831x_backup.c
+++ b/drivers/power/wm831x_backup.c
@@ -197,7 +197,7 @@ static int wm831x_backup_probe(struct platform_device *pdev)
 	backup->properties = wm831x_backup_props;
 	backup->num_properties = ARRAY_SIZE(wm831x_backup_props);
 	backup->get_property = wm831x_backup_get_prop;
-	ret = power_supply_register(&pdev->dev, backup);
+	ret = power_supply_register(&pdev->dev, backup, NULL);
 
 	return ret;
 }
diff --git a/drivers/power/wm831x_power.c b/drivers/power/wm831x_power.c
index 3bed2f55cf7d..a132aae6225d 100644
--- a/drivers/power/wm831x_power.c
+++ b/drivers/power/wm831x_power.c
@@ -536,7 +536,7 @@ static int wm831x_power_probe(struct platform_device *pdev)
 	wall->properties = wm831x_wall_props;
 	wall->num_properties = ARRAY_SIZE(wm831x_wall_props);
 	wall->get_property = wm831x_wall_get_prop;
-	ret = power_supply_register(&pdev->dev, wall);
+	ret = power_supply_register(&pdev->dev, wall, NULL);
 	if (ret)
 		goto err_kmalloc;
 
@@ -545,7 +545,7 @@ static int wm831x_power_probe(struct platform_device *pdev)
 	usb->properties = wm831x_usb_props;
 	usb->num_properties = ARRAY_SIZE(wm831x_usb_props);
 	usb->get_property = wm831x_usb_get_prop;
-	ret = power_supply_register(&pdev->dev, usb);
+	ret = power_supply_register(&pdev->dev, usb, NULL);
 	if (ret)
 		goto err_wall;
 
@@ -560,7 +560,7 @@ static int wm831x_power_probe(struct platform_device *pdev)
 		    battery->num_properties = ARRAY_SIZE(wm831x_bat_props);
 		    battery->get_property = wm831x_bat_get_prop;
 		    battery->use_for_apm = 1;
-		    ret = power_supply_register(&pdev->dev, battery);
+		    ret = power_supply_register(&pdev->dev, battery, NULL);
 		    if (ret)
 			    goto err_usb;
 	}
diff --git a/drivers/power/wm8350_power.c b/drivers/power/wm8350_power.c
index b3607e2906d2..261ceca561d5 100644
--- a/drivers/power/wm8350_power.c
+++ b/drivers/power/wm8350_power.c
@@ -457,7 +457,7 @@ static int wm8350_power_probe(struct platform_device *pdev)
 	ac->properties = wm8350_ac_props;
 	ac->num_properties = ARRAY_SIZE(wm8350_ac_props);
 	ac->get_property = wm8350_ac_get_prop;
-	ret = power_supply_register(&pdev->dev, ac);
+	ret = power_supply_register(&pdev->dev, ac, NULL);
 	if (ret)
 		return ret;
 
@@ -466,7 +466,7 @@ static int wm8350_power_probe(struct platform_device *pdev)
 	battery->num_properties = ARRAY_SIZE(wm8350_bat_props);
 	battery->get_property = wm8350_bat_get_property;
 	battery->use_for_apm = 1;
-	ret = power_supply_register(&pdev->dev, battery);
+	ret = power_supply_register(&pdev->dev, battery, NULL);
 	if (ret)
 		goto battery_failed;
 
@@ -475,7 +475,7 @@ static int wm8350_power_probe(struct platform_device *pdev)
 	usb->properties = wm8350_usb_props;
 	usb->num_properties = ARRAY_SIZE(wm8350_usb_props);
 	usb->get_property = wm8350_usb_get_prop;
-	ret = power_supply_register(&pdev->dev, usb);
+	ret = power_supply_register(&pdev->dev, usb, NULL);
 	if (ret)
 		goto usb_failed;
 
diff --git a/drivers/power/wm97xx_battery.c b/drivers/power/wm97xx_battery.c
index 58f7348e6c22..accca81e065e 100644
--- a/drivers/power/wm97xx_battery.c
+++ b/drivers/power/wm97xx_battery.c
@@ -244,7 +244,7 @@ static int wm97xx_bat_probe(struct platform_device *dev)
 	bat_ps.properties = prop;
 	bat_ps.num_properties = props;
 
-	ret = power_supply_register(&dev->dev, &bat_ps);
+	ret = power_supply_register(&dev->dev, &bat_ps, NULL);
 	if (!ret)
 		schedule_work(&bat_work);
 	else
diff --git a/drivers/power/z2_battery.c b/drivers/power/z2_battery.c
index 814d2e31f0c9..df22364212dd 100644
--- a/drivers/power/z2_battery.c
+++ b/drivers/power/z2_battery.c
@@ -230,7 +230,7 @@ static int z2_batt_probe(struct i2c_client *client,
 
 	INIT_WORK(&charger->bat_work, z2_batt_work);
 
-	ret = power_supply_register(&client->dev, &charger->batt_ps);
+	ret = power_supply_register(&client->dev, &charger->batt_ps, NULL);
 	if (ret)
 		goto err4;
 
diff --git a/drivers/staging/nvec/nvec_power.c b/drivers/staging/nvec/nvec_power.c
index aacfcd6954a3..3f7c83ea8050 100644
--- a/drivers/staging/nvec/nvec_power.c
+++ b/drivers/staging/nvec/nvec_power.c
@@ -333,8 +333,6 @@ static struct power_supply nvec_bat_psy = {
 static struct power_supply nvec_psy = {
 	.name = "ac",
 	.type = POWER_SUPPLY_TYPE_MAINS,
-	.supplied_to = nvec_power_supplied_to,
-	.num_supplicants = ARRAY_SIZE(nvec_power_supplied_to),
 	.properties = nvec_power_props,
 	.num_properties = ARRAY_SIZE(nvec_power_props),
 	.get_property = nvec_power_get_property,
@@ -375,6 +373,7 @@ static int nvec_power_probe(struct platform_device *pdev)
 	struct power_supply *psy;
 	struct nvec_power *power;
 	struct nvec_chip *nvec = dev_get_drvdata(pdev->dev.parent);
+	struct power_supply_config psy_cfg = {};
 
 	power = devm_kzalloc(&pdev->dev, sizeof(struct nvec_power), GFP_NOWAIT);
 	if (power == NULL)
@@ -386,6 +385,8 @@ static int nvec_power_probe(struct platform_device *pdev)
 	switch (pdev->id) {
 	case AC:
 		psy = &nvec_psy;
+		psy_cfg.supplied_to = nvec_power_supplied_to;
+		psy_cfg.num_supplicants = ARRAY_SIZE(nvec_power_supplied_to);
 
 		power->notifier.notifier_call = nvec_power_notifier;
 
@@ -406,7 +407,7 @@ static int nvec_power_probe(struct platform_device *pdev)
 	if (pdev->id == BAT)
 		get_bat_mfg_data(power);
 
-	return power_supply_register(&pdev->dev, psy);
+	return power_supply_register(&pdev->dev, psy, &psy_cfg);
 }
 
 static int nvec_power_remove(struct platform_device *pdev)
diff --git a/include/linux/power_supply.h b/include/linux/power_supply.h
index b5a0d5291835..c7cfb9125405 100644
--- a/include/linux/power_supply.h
+++ b/include/linux/power_supply.h
@@ -165,6 +165,16 @@ union power_supply_propval {
 
 struct device_node;
 
+/* Power supply instance specific configuration */
+struct power_supply_config {
+	struct device_node *of_node;
+	/* Driver private data */
+	void *drv_data;
+
+	char **supplied_to;
+	size_t num_supplicants;
+};
+
 struct power_supply {
 	const char *name;
 	enum power_supply_type type;
@@ -250,13 +260,17 @@ static inline int power_supply_is_system_supplied(void) { return -ENOSYS; }
 #endif
 
 extern int power_supply_register(struct device *parent,
-				 struct power_supply *psy);
+				 struct power_supply *psy,
+				 const struct power_supply_config *cfg);
 extern int power_supply_register_no_ws(struct device *parent,
-				 struct power_supply *psy);
+				 struct power_supply *psy,
+				 const struct power_supply_config *cfg);
 extern int devm_power_supply_register(struct device *parent,
-				 struct power_supply *psy);
+				 struct power_supply *psy,
+				 const struct power_supply_config *cfg);
 extern int devm_power_supply_register_no_ws(struct device *parent,
-				 struct power_supply *psy);
+				 struct power_supply *psy,
+				 const struct power_supply_config *cfg);
 extern void power_supply_unregister(struct power_supply *psy);
 extern int power_supply_powers(struct power_supply *psy, struct device *dev);
 
