ipmi_si: use smi_num for init_name

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Tony Camuso <tcamuso@redhat.com>
commit 3f724c408a7bcf25609f6a0102b835d5970cadd3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/3f724c40.failed

Commit 1abf71e moved the creation of new_smi->dev to earlier in the init
sequence in order to provide infrastructure for log printing.

However, the init_name was created with a hard-coded value of zero. This
presents a problem in systems with more than one interface, producing a
call trace in dmesg.

To correct the problem, simply use smi_num instead of the hard-coded
value of zero.

Tested on a lenovo x3950.

	Signed-off-by: Tony Camuso <tcamuso@redhat.com>

There was actually a more general problem, the platform device wasn't
being set correctly, either, and there was a possible (though extremely
unlikely) race on smi_num.  Add locks to clean up the race and use the
proper value for the platform device, too.

Tested on qemu in various configurations.

	Signed-off-by: Corey Minyard <cminyard@mvista.com>
(cherry picked from commit 3f724c408a7bcf25609f6a0102b835d5970cadd3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/ipmi/ipmi_si_intf.c
diff --cc drivers/char/ipmi/ipmi_si_intf.c
index 625025a66dc5,b2b618f066e0..000000000000
--- a/drivers/char/ipmi/ipmi_si_intf.c
+++ b/drivers/char/ipmi/ipmi_si_intf.c
@@@ -3509,6 -3533,29 +3518,32 @@@ static int try_smi_init(struct smi_inf
  		goto out_err;
  	}
  
++<<<<<<< HEAD
++=======
+ 	new_smi->intf_num = smi_num;
+ 
+ 	/* Do this early so it's available for logs. */
+ 	if (!new_smi->dev) {
+ 		init_name = kasprintf(GFP_KERNEL, "ipmi_si.%d",
+ 				      new_smi->intf_num);
+ 
+ 		/*
+ 		 * If we don't already have a device from something
+ 		 * else (like PCI), then register a new one.
+ 		 */
+ 		new_smi->pdev = platform_device_alloc("ipmi_si",
+ 						      new_smi->intf_num);
+ 		if (!new_smi->pdev) {
+ 			pr_err(PFX "Unable to allocate platform device\n");
+ 			goto out_err;
+ 		}
+ 		new_smi->dev = &new_smi->pdev->dev;
+ 		new_smi->dev->driver = &ipmi_driver.driver;
+ 		/* Nulled by device_add() */
+ 		new_smi->dev->init_name = init_name;
+ 	}
+ 
++>>>>>>> 3f724c408a7b (ipmi_si: use smi_num for init_name)
  	/* Allocate the state machine's data and initialize it. */
  	new_smi->si_sm = kmalloc(new_smi->handlers->size(), GFP_KERNEL);
  	if (!new_smi->si_sm) {
* Unmerged path drivers/char/ipmi/ipmi_si_intf.c
