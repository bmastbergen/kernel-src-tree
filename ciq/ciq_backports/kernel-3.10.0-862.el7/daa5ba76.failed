mm/rmap.c: cleanup ttu_flags

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [mm] rmap: cleanup ttu_flags (Andrea Arcangeli) [1450367]
Rebuild_FUZZ: 90.20%
commit-author Konstantin Khlebnikov <koct9i@gmail.com>
commit daa5ba768b9e15da8867824d2f1e8d455f1acac2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/daa5ba76.failed

Transform action part of ttu_flags into individiual bits.  These flags
aren't part of any uses-space visible api or even trace events.

	Signed-off-by: Konstantin Khlebnikov <koct9i@gmail.com>
	Cc: Rik van Riel <riel@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit daa5ba768b9e15da8867824d2f1e8d455f1acac2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/rmap.c
diff --cc mm/rmap.c
index bab4f8a26c59,ea8e20d75b29..000000000000
--- a/mm/rmap.c
+++ b/mm/rmap.c
@@@ -1845,16 -1521,29 +1845,33 @@@ out
  int try_to_unmap(struct page *page, enum ttu_flags flags)
  {
  	int ret;
 -	struct rmap_walk_control rwc = {
 -		.rmap_one = try_to_unmap_one,
 -		.arg = (void *)flags,
 -		.done = page_not_mapped,
 -		.file_nonlinear = try_to_unmap_nonlinear,
 -		.anon_lock = page_lock_anon_vma_read,
 -	};
  
++<<<<<<< HEAD
 +	BUG_ON(!PageLocked(page));
 +	VM_BUG_ON(!PageHuge(page) && PageTransHuge(page));
++=======
+ 	VM_BUG_ON_PAGE(!PageHuge(page) && PageTransHuge(page), page);
+ 
+ 	/*
+ 	 * During exec, a temporary VMA is setup and later moved.
+ 	 * The VMA is moved under the anon_vma lock but not the
+ 	 * page tables leading to a race where migration cannot
+ 	 * find the migration ptes. Rather than increasing the
+ 	 * locking requirements of exec(), migration skips
+ 	 * temporary VMAs until after exec() completes.
+ 	 */
+ 	if ((flags & TTU_MIGRATION) && !PageKsm(page) && PageAnon(page))
+ 		rwc.invalid_vma = invalid_migration_vma;
+ 
+ 	ret = rmap_walk(page, &rwc);
++>>>>>>> daa5ba768b9e (mm/rmap.c: cleanup ttu_flags)
  
 +	if (unlikely(PageKsm(page)))
 +		ret = try_to_unmap_ksm(page, flags);
 +	else if (PageAnon(page))
 +		ret = try_to_unmap_anon(page, flags);
 +	else
 +		ret = try_to_unmap_file(page, flags);
  	if (ret != SWAP_MLOCK && !page_mapped(page))
  		ret = SWAP_SUCCESS;
  	return ret;
diff --git a/include/linux/rmap.h b/include/linux/rmap.h
index cddfd6d80ec6..be51d2aefb12 100644
--- a/include/linux/rmap.h
+++ b/include/linux/rmap.h
@@ -82,10 +82,9 @@ struct anon_vma_chain {
 };
 
 enum ttu_flags {
-	TTU_UNMAP = 0,			/* unmap mode */
-	TTU_MIGRATION = 1,		/* migration mode */
-	TTU_MUNLOCK = 2,		/* munlock mode */
-	TTU_ACTION_MASK = 0xff,
+	TTU_UNMAP = 1,			/* unmap mode */
+	TTU_MIGRATION = 2,		/* migration mode */
+	TTU_MUNLOCK = 4,		/* munlock mode */
 
 	TTU_IGNORE_MLOCK = (1 << 8),	/* ignore mlock */
 	TTU_IGNORE_ACCESS = (1 << 9),	/* don't age */
* Unmerged path mm/rmap.c
