iw_cxgb4: Fix possible circular dependency locking warning

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Bharat Potnuri <bharat@chelsio.com>
commit 1c8f1da5d851b92aeb81dbbb9ebd516f6e2588f5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1c8f1da5.failed

Locking sequence of iw_cxgb4 and RoCE drivers in ib_register_device() is
slightly different and this leads to possible circular dependency locking
warning when both the devices are brought up.

Here is the locking sequence upto ib_register_device():
iw_cxgb4: rtnl_mutex(net stack) --> uld_mutex --> device_mutex
RoCE drivers: device_mutex --> rtnl_mutex

Here is the possibility of cross locking:

	CPU #0 (iw_cxgb4) 		     CPU #1 (RoCE drivers)

-> on interface up cxgb4_up()
executed with rtnl_mutex held
-> hold uld_mutex and try
registering ib device
					-> In ib_register_device() hold
					   device_mutex
-> hold device mutex in
ib_register_device
					-> try acquiring rtnl_mutex in
					   ib_enum_roce_netdev()

Current patch schedules the ib_register_device() functionality of
iw_cxgb4 to a workqueue to prevent the possible cross-locking.
Also rename the labels in c4iw_reister_device().

	Signed-off-by: Potnuri Bharat Teja <bharat@chelsio.com>
	Reviewed-by: Steve Wise <swise@opengridcomputing.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 1c8f1da5d851b92aeb81dbbb9ebd516f6e2588f5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/cxgb4/device.c
diff --cc drivers/infiniband/hw/cxgb4/device.c
index 76898729e469,af77d128d242..000000000000
--- a/drivers/infiniband/hw/cxgb4/device.c
+++ b/drivers/infiniband/hw/cxgb4/device.c
@@@ -1223,29 -1198,22 +1218,33 @@@ static int c4iw_uld_state_change(void *
  {
  	struct uld_ctx *ctx = handle;
  
 -	pr_debug("new_state %u\n", new_state);
 +	PDBG("%s new_state %u\n", __func__, new_state);
  	switch (new_state) {
  	case CXGB4_STATE_UP:
 -		pr_info("%s: Up\n", pci_name(ctx->lldi.pdev));
 +		printk(KERN_INFO MOD "%s: Up\n", pci_name(ctx->lldi.pdev));
  		if (!ctx->dev) {
- 			int ret;
- 
  			ctx->dev = c4iw_alloc(&ctx->lldi);
  			if (IS_ERR(ctx->dev)) {
 -				pr_err("%s: initialization failed: %ld\n",
 +				printk(KERN_ERR MOD
 +				       "%s: initialization failed: %ld\n",
  				       pci_name(ctx->lldi.pdev),
  				       PTR_ERR(ctx->dev));
  				ctx->dev = NULL;
  				break;
  			}
++<<<<<<< HEAD
 +			ret = c4iw_register_device(ctx->dev);
 +			if (ret) {
 +				printk(KERN_ERR MOD
 +				       "%s: RDMA registration failed: %d\n",
 +				       pci_name(ctx->lldi.pdev), ret);
 +				c4iw_dealloc(ctx);
 +			}
++=======
+ 
+ 			INIT_WORK(&ctx->reg_work, c4iw_register_device);
+ 			queue_work(reg_workq, &ctx->reg_work);
++>>>>>>> 1c8f1da5d851 (iw_cxgb4: Fix possible circular dependency locking warning)
  		}
  		break;
  	case CXGB4_STATE_DOWN:
@@@ -1557,9 -1539,14 +1556,15 @@@ static int __init c4iw_init_module(void
  
  	c4iw_debugfs_root = debugfs_create_dir(DRV_NAME, NULL);
  	if (!c4iw_debugfs_root)
 -		pr_warn("could not create debugfs entry, continuing\n");
 +		printk(KERN_WARNING MOD
 +		       "could not create debugfs entry, continuing\n");
  
+ 	reg_workq = create_singlethread_workqueue("Register_iWARP_device");
+ 	if (!reg_workq) {
+ 		pr_err("Failed creating workqueue to register iwarp device\n");
+ 		return -ENOMEM;
+ 	}
+ 
  	cxgb4_register_uld(CXGB4_ULD_RDMA, &c4iw_uld_info);
  
  	return 0;
* Unmerged path drivers/infiniband/hw/cxgb4/device.c
diff --git a/drivers/infiniband/hw/cxgb4/iw_cxgb4.h b/drivers/infiniband/hw/cxgb4/iw_cxgb4.h
index 9da4fb4991be..b297dddea141 100644
--- a/drivers/infiniband/hw/cxgb4/iw_cxgb4.h
+++ b/drivers/infiniband/hw/cxgb4/iw_cxgb4.h
@@ -269,6 +269,13 @@ struct c4iw_dev {
 	wait_queue_head_t wait;
 };
 
+struct uld_ctx {
+	struct list_head entry;
+	struct cxgb4_lld_info lldi;
+	struct c4iw_dev *dev;
+	struct work_struct reg_work;
+};
+
 static inline struct c4iw_dev *to_c4iw_dev(struct ib_device *ibdev)
 {
 	return container_of(ibdev, struct c4iw_dev, ibdev);
@@ -935,7 +942,7 @@ void c4iw_rqtpool_destroy(struct c4iw_rdev *rdev);
 void c4iw_ocqp_pool_destroy(struct c4iw_rdev *rdev);
 void c4iw_destroy_resource(struct c4iw_resource *rscp);
 int c4iw_destroy_ctrl_qp(struct c4iw_rdev *rdev);
-int c4iw_register_device(struct c4iw_dev *dev);
+void c4iw_register_device(struct work_struct *work);
 void c4iw_unregister_device(struct c4iw_dev *dev);
 int __init c4iw_cm_init(void);
 void c4iw_cm_term(void);
@@ -961,6 +968,7 @@ struct ib_mr *c4iw_alloc_mr(struct ib_pd *pd,
 int c4iw_map_mr_sg(struct ib_mr *ibmr, struct scatterlist *sg, int sg_nents,
 		   unsigned int *sg_offset);
 int c4iw_dealloc_mw(struct ib_mw *mw);
+void c4iw_dealloc(struct uld_ctx *ctx);
 struct ib_mw *c4iw_alloc_mw(struct ib_pd *pd, enum ib_mw_type type,
 			    struct ib_udata *udata);
 struct ib_mr *c4iw_reg_user_mr(struct ib_pd *pd, u64 start,
diff --git a/drivers/infiniband/hw/cxgb4/provider.c b/drivers/infiniband/hw/cxgb4/provider.c
index 26ed2e0446bd..081b1295e8ef 100644
--- a/drivers/infiniband/hw/cxgb4/provider.c
+++ b/drivers/infiniband/hw/cxgb4/provider.c
@@ -533,10 +533,12 @@ static void get_dev_fw_str(struct ib_device *dev, char *str,
 		 FW_HDR_FW_VER_BUILD_G(c4iw_dev->rdev.lldi.fw_vers));
 }
 
-int c4iw_register_device(struct c4iw_dev *dev)
+void c4iw_register_device(struct work_struct *work)
 {
 	int ret;
 	int i;
+	struct uld_ctx *ctx = container_of(work, struct uld_ctx, reg_work);
+	struct c4iw_dev *dev = ctx->dev;
 
 	PDBG("%s c4iw_dev %p\n", __func__, dev);
 	BUG_ON(!dev->rdev.lldi.ports[0]);
@@ -612,8 +614,10 @@ int c4iw_register_device(struct c4iw_dev *dev)
 	dev->ibdev.get_dev_fw_str = get_dev_fw_str;
 
 	dev->ibdev.iwcm = kmalloc(sizeof(struct iw_cm_verbs), GFP_KERNEL);
-	if (!dev->ibdev.iwcm)
-		return -ENOMEM;
+	if (!dev->ibdev.iwcm) {
+		ret = -ENOMEM;
+		goto err_dealloc_ctx;
+	}
 
 	dev->ibdev.iwcm->connect = c4iw_connect;
 	dev->ibdev.iwcm->accept = c4iw_accept_cr;
@@ -628,20 +632,24 @@ int c4iw_register_device(struct c4iw_dev *dev)
 
 	ret = ib_register_device(&dev->ibdev, NULL);
 	if (ret)
-		goto bail1;
+		goto err_kfree_iwcm;
 
 	for (i = 0; i < ARRAY_SIZE(c4iw_class_attributes); ++i) {
 		ret = device_create_file(&dev->ibdev.dev,
 					 c4iw_class_attributes[i]);
 		if (ret)
-			goto bail2;
+			goto err_unregister_device;
 	}
-	return 0;
-bail2:
+	return;
+err_unregister_device:
 	ib_unregister_device(&dev->ibdev);
-bail1:
+err_kfree_iwcm:
 	kfree(dev->ibdev.iwcm);
-	return ret;
+err_dealloc_ctx:
+	pr_err("%s - Failed registering iwarp device: %d\n",
+	       pci_name(ctx->lldi.pdev), ret);
+	c4iw_dealloc(ctx);
+	return;
 }
 
 void c4iw_unregister_device(struct c4iw_dev *dev)
