IB/hfi1: Race condition between user notification and driver state

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Michael J. Ruhl <michael.j.ruhl@intel.com>
commit 4061f3a4da4574b8c9f11a82c767aaaed3ef2aa9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4061f3a4.failed

The handler for link init state (HLS_UP_INIT) notifies userspace
(update_statusp()) before enabling the device
(RCV_CTRL_RCV_PORT_ENABLE_SMASK) or setting the device state
(ppd->host_link_state).  This causes a race condition where the
userspace thinks the interface is in the INIT state before the driver
has set that state.

Rework the code path to eliminate the race.

Delay setting the init state until after a HW settling period.

	Reviewed-by: Sebastian Sanchez <sebastian.sanchez@intel.com>
	Signed-off-by: Michael J. Ruhl <michael.j.ruhl@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 4061f3a4da4574b8c9f11a82c767aaaed3ef2aa9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/chip.c
diff --cc drivers/infiniband/hw/hfi1/chip.c
index 5021a888d4a0,8dd0a4ded67b..000000000000
--- a/drivers/infiniband/hw/hfi1/chip.c
+++ b/drivers/infiniband/hw/hfi1/chip.c
@@@ -10245,8 -10316,7 +10245,12 @@@ static void force_logical_link_state_do
  	write_csr(dd, DC_LCB_CFG_ALLOW_LINK_UP, 0);
  	write_csr(dd, DC_LCB_CFG_IGNORE_LOST_RCLK, 0);
  
++<<<<<<< HEAD
 +	/* call again to adjust ppd->statusp, if needed */
 +	get_logical_state(ppd);
++=======
+ 	dd_dev_info(ppd->dd, "logical state forced to LINK_DOWN\n");
++>>>>>>> 4061f3a4da45 (IB/hfi1: Race condition between user notification and driver state)
  }
  
  /*
@@@ -10317,23 -10397,8 +10321,24 @@@ static int goto_offline(struct hfi1_ppo
  		force_logical_link_state_down(ppd);
  
  	ppd->host_link_state = HLS_LINK_COOLDOWN; /* LCB access allowed */
+ 	update_statusp(ppd, IB_PORT_DOWN);
  
 +	if (ppd->port_type == PORT_TYPE_QSFP &&
 +	    ppd->qsfp_info.limiting_active &&
 +	    qsfp_mod_present(ppd)) {
 +		int ret;
 +
 +		ret = acquire_chip_resource(dd, qsfp_resource(dd), QSFP_WAIT);
 +		if (ret == 0) {
 +			set_qsfp_tx(ppd, 0);
 +			release_chip_resource(dd, qsfp_resource(dd));
 +		} else {
 +			/* not fatal, but should warn */
 +			dd_dev_err(dd,
 +				   "Unable to acquire lock to turn off QSFP TX\n");
 +		}
 +	}
 +
  	/*
  	 * The LNI has a mandatory wait time after the physical state
  	 * moves to Offline.Quiet.  The wait time may be different
@@@ -12627,20 -12718,19 +12635,35 @@@ const char *opa_pstate_name(u32 pstate
  	return "unknown";
  }
  
++<<<<<<< HEAD
 +/*
 + * Read the hardware link state and set the driver's cached value of it.
 + * Return the (new) current value.
 + */
 +u32 get_logical_state(struct hfi1_pportdata *ppd)
++=======
+ /**
+  * update_statusp - Update userspace status flag
+  * @ppd: Port data structure
+  * @state: port state information
+  *
+  * Actual port status is determined by the host_link_state value
+  * in the ppd.
+  *
+  * host_link_state MUST be updated before updating the user space
+  * statusp.
+  */
+ static void update_statusp(struct hfi1_pportdata *ppd, u32 state)
++>>>>>>> 4061f3a4da45 (IB/hfi1: Race condition between user notification and driver state)
  {
 +	u32 new_state;
 +
 +	new_state = chip_to_opa_lstate(ppd->dd, read_logical_state(ppd->dd));
 +	if (new_state != ppd->lstate) {
 +		dd_dev_info(ppd->dd, "logical state changed to %s (0x%x)\n",
 +			    opa_lstate_name(new_state), new_state);
 +		ppd->lstate = new_state;
 +	}
  	/*
  	 * Set port status flags in the page mapped into userspace
  	 * memory. Do it here to ensure a reliable state - this is
@@@ -12664,7 -12754,8 +12687,12 @@@
  			break;
  		}
  	}
++<<<<<<< HEAD
 +	return ppd->lstate;
++=======
+ 	dd_dev_info(ppd->dd, "logical state changed to %s (0x%x)\n",
+ 		    opa_lstate_name(state), state);
++>>>>>>> 4061f3a4da45 (IB/hfi1: Race condition between user notification and driver state)
  }
  
  /**
@@@ -12684,32 -12775,113 +12712,36 @@@ static int wait_logical_linkstate(struc
  
  	timeout = jiffies + msecs_to_jiffies(msecs);
  	while (1) {
 -		new_state = chip_to_opa_lstate(ppd->dd,
 -					       read_logical_state(ppd->dd));
 -		if (new_state == state)
 +		if (get_logical_state(ppd) == state)
 +			return 0;
 +		if (time_after(jiffies, timeout))
  			break;
 -		if (time_after(jiffies, timeout)) {
 -			dd_dev_err(ppd->dd,
 -				   "timeout waiting for link state 0x%x\n",
 -				   state);
 -			return -ETIMEDOUT;
 -		}
  		msleep(20);
  	}
 +	dd_dev_err(ppd->dd, "timeout waiting for link state 0x%x\n", state);
  
++<<<<<<< HEAD
 +	return -ETIMEDOUT;
++=======
+ 	return 0;
++>>>>>>> 4061f3a4da45 (IB/hfi1: Race condition between user notification and driver state)
  }
  
 -static void log_state_transition(struct hfi1_pportdata *ppd, u32 state)
 +u8 hfi1_ibphys_portstate(struct hfi1_pportdata *ppd)
  {
 -	u32 ib_pstate = chip_to_opa_pstate(ppd->dd, state);
 +	u32 pstate;
 +	u32 ib_pstate;
  
 -	dd_dev_info(ppd->dd,
 -		    "physical state changed to %s (0x%x), phy 0x%x\n",
 -		    opa_pstate_name(ib_pstate), ib_pstate, state);
 -}
 -
 -/*
 - * Read the physical hardware link state and check if it matches host
 - * drivers anticipated state.
 - */
 -static void log_physical_state(struct hfi1_pportdata *ppd, u32 state)
 -{
 -	u32 read_state = read_physical_state(ppd->dd);
 -
 -	if (read_state == state) {
 -		log_state_transition(ppd, state);
 -	} else {
 -		dd_dev_err(ppd->dd,
 -			   "anticipated phy link state 0x%x, read 0x%x\n",
 -			   state, read_state);
 -	}
 -}
 -
 -/*
 - * wait_physical_linkstate - wait for an physical link state change to occur
 - * @ppd: port device
 - * @state: the state to wait for
 - * @msecs: the number of milliseconds to wait
 - *
 - * Wait up to msecs milliseconds for physical link state change to occur.
 - * Returns 0 if state reached, otherwise -ETIMEDOUT.
 - */
 -static int wait_physical_linkstate(struct hfi1_pportdata *ppd, u32 state,
 -				   int msecs)
 -{
 -	u32 read_state;
 -	unsigned long timeout;
 -
 -	timeout = jiffies + msecs_to_jiffies(msecs);
 -	while (1) {
 -		read_state = read_physical_state(ppd->dd);
 -		if (read_state == state)
 -			break;
 -		if (time_after(jiffies, timeout)) {
 -			dd_dev_err(ppd->dd,
 -				   "timeout waiting for phy link state 0x%x\n",
 -				   state);
 -			return -ETIMEDOUT;
 -		}
 -		usleep_range(1950, 2050); /* sleep 2ms-ish */
 -	}
 -
 -	log_state_transition(ppd, state);
 -	return 0;
 -}
 -
 -/*
 - * wait_phys_link_offline_quiet_substates - wait for any offline substate
 - * @ppd: port device
 - * @msecs: the number of milliseconds to wait
 - *
 - * Wait up to msecs milliseconds for any offline physical link
 - * state change to occur.
 - * Returns 0 if at least one state is reached, otherwise -ETIMEDOUT.
 - */
 -static int wait_phys_link_offline_substates(struct hfi1_pportdata *ppd,
 -					    int msecs)
 -{
 -	u32 read_state;
 -	unsigned long timeout;
 -
 -	timeout = jiffies + msecs_to_jiffies(msecs);
 -	while (1) {
 -		read_state = read_physical_state(ppd->dd);
 -		if ((read_state & 0xF0) == PLS_OFFLINE)
 -			break;
 -		if (time_after(jiffies, timeout)) {
 -			dd_dev_err(ppd->dd,
 -				   "timeout waiting for phy link offline.quiet substates. Read state 0x%x, %dms\n",
 -				   read_state, msecs);
 -			return -ETIMEDOUT;
 -		}
 -		usleep_range(1950, 2050); /* sleep 2ms-ish */
 +	pstate = read_physical_state(ppd->dd);
 +	ib_pstate = chip_to_opa_pstate(ppd->dd, pstate);
 +	if (ppd->last_pstate != ib_pstate) {
 +		dd_dev_info(ppd->dd,
 +			    "%s: physical state changed to %s (0x%x), phy 0x%x\n",
 +			    __func__, opa_pstate_name(ib_pstate), ib_pstate,
 +			    pstate);
 +		ppd->last_pstate = ib_pstate;
  	}
 -
 -	log_state_transition(ppd, read_state);
 -	return read_state;
 +	return ib_pstate;
  }
  
  #define CLEAR_STATIC_RATE_CONTROL_SMASK(r) \
* Unmerged path drivers/infiniband/hw/hfi1/chip.c
diff --git a/drivers/infiniband/hw/hfi1/intr.c b/drivers/infiniband/hw/hfi1/intr.c
index 7f9af9c3d9e6..c495b7b28182 100644
--- a/drivers/infiniband/hw/hfi1/intr.c
+++ b/drivers/infiniband/hw/hfi1/intr.c
@@ -52,6 +52,8 @@
 #include "common.h"
 #include "sdma.h"
 
+#define LINK_UP_DELAY  500  /* in microseconds */
+
 /**
  * format_hwmsg - format a single hwerror message
  * @msg message buffer
@@ -101,9 +103,16 @@ static void signal_ib_event(struct hfi1_pportdata *ppd, enum ib_event_type ev)
 	ib_dispatch_event(&event);
 }
 
-/*
+/**
+ * handle_linkup_change - finish linkup/down state changes
+ * @dd: valid device
+ * @linkup: link state information
+ *
  * Handle a linkup or link down notification.
+ * The HW needs time to finish its link up state change. Give it that chance.
+ *
  * This is called outside an interrupt.
+ *
  */
 void handle_linkup_change(struct hfi1_devdata *dd, u32 linkup)
 {
@@ -150,6 +159,9 @@ void handle_linkup_change(struct hfi1_devdata *dd, u32 linkup)
 			    ppd->neighbor_guid, ppd->neighbor_type,
 			    ppd->neighbor_port_number);
 
+		/* HW needs LINK_UP_DELAY to settle, give it that chance */
+		udelay(LINK_UP_DELAY);
+
 		/* physical link went up */
 		ppd->linkup = 1;
 		ppd->offline_disabled_reason =
