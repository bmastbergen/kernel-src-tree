IB/mlx5: Fix retrieval of index to first hi class bfreg

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Eli Cohen <eli@mellanox.com>
commit 0b80c14f009758cefeed0edff4f9141957964211
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0b80c14f.failed

First the function retrieving the index of the first hi latency class
blue flame register. High latency class bfregs are located right above
medium latency class bfregs.

Fixes: c1be5232d21d ('IB/mlx5: Fix micro UAR allocator')
	Signed-off-by: Eli Cohen <eli@mellanox.com>
	Reviewed-by: Matan Barak <matanb@mellanox.com>
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 0b80c14f009758cefeed0edff4f9141957964211)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/qp.c
diff --cc drivers/infiniband/hw/mlx5/qp.c
index 65e5d668d1be,240fbb0c63ba..000000000000
--- a/drivers/infiniband/hw/mlx5/qp.c
+++ b/drivers/infiniband/hw/mlx5/qp.c
@@@ -490,38 -490,39 +490,59 @@@ static int next_uuar(int n
  	return n;
  }
  
++<<<<<<< HEAD
 +static int num_med_uuar(struct mlx5_uuar_info *uuari)
 +{
 +	int n;
 +
 +	n = uuari->num_uars * MLX5_NON_FP_BF_REGS_PER_PAGE -
 +		uuari->num_low_latency_uuars - 1;
++=======
+ enum {
+ 	/* this is the first blue flame register in the array of bfregs assigned
+ 	 * to a processes. Since we do not use it for blue flame but rather
+ 	 * regular 64 bit doorbells, we do not need a lock for maintaiing
+ 	 * "odd/even" order
+ 	 */
+ 	NUM_NON_BLUE_FLAME_BFREGS = 1,
+ };
+ 
+ static int num_med_bfreg(struct mlx5_bfreg_info *bfregi)
+ {
+ 	int n;
+ 
+ 	n = bfregi->num_uars * MLX5_NON_FP_BFREGS_PER_UAR -
+ 		bfregi->num_low_latency_bfregs - NUM_NON_BLUE_FLAME_BFREGS;
++>>>>>>> 0b80c14f0097 (IB/mlx5: Fix retrieval of index to first hi class bfreg)
  
  	return n >= 0 ? n : 0;
  }
  
 -static int max_bfregi(struct mlx5_bfreg_info *bfregi)
 +static int max_uuari(struct mlx5_uuar_info *uuari)
  {
 -	return bfregi->num_uars * 4;
 +	return uuari->num_uars * 4;
  }
  
 -static int first_hi_bfreg(struct mlx5_bfreg_info *bfregi)
 +static int first_hi_uuar(struct mlx5_uuar_info *uuari)
  {
  	int med;
- 	int i;
- 	int t;
  
++<<<<<<< HEAD
 +	med = num_med_uuar(uuari);
 +	for (t = 0, i = first_med_uuar();; i = next_uuar(i)) {
 +		t++;
 +		if (t == med)
 +			return next_uuar(i);
 +	}
 +
 +	return 0;
++=======
+ 	med = num_med_bfreg(bfregi);
+ 	return next_bfreg(med);
++>>>>>>> 0b80c14f0097 (IB/mlx5: Fix retrieval of index to first hi class bfreg)
  }
  
 -static int alloc_high_class_bfreg(struct mlx5_bfreg_info *bfregi)
 +static int alloc_high_class_uuar(struct mlx5_uuar_info *uuari)
  {
  	int i;
  
@@@ -536,30 -537,33 +557,38 @@@
  	return -ENOMEM;
  }
  
 -static int alloc_med_class_bfreg(struct mlx5_bfreg_info *bfregi)
 +static int alloc_med_class_uuar(struct mlx5_uuar_info *uuari)
  {
 -	int minidx = first_med_bfreg();
 +	int minidx = first_med_uuar();
  	int i;
  
 -	for (i = first_med_bfreg(); i < first_hi_bfreg(bfregi); i = next_bfreg(i)) {
 -		if (bfregi->count[i] < bfregi->count[minidx])
 +	for (i = first_med_uuar(); i < first_hi_uuar(uuari); i = next_uuar(i)) {
 +		if (uuari->count[i] < uuari->count[minidx])
  			minidx = i;
+ 		if (!bfregi->count[minidx])
+ 			break;
  	}
  
 -	bfregi->count[minidx]++;
 +	uuari->count[minidx]++;
  	return minidx;
  }
  
 -static int alloc_bfreg(struct mlx5_bfreg_info *bfregi,
 -		       enum mlx5_ib_latency_class lat)
 +static int alloc_uuar(struct mlx5_uuar_info *uuari,
 +		      enum mlx5_ib_latency_class lat)
  {
 -	int bfregn = -EINVAL;
 +	int uuarn = -EINVAL;
  
 -	mutex_lock(&bfregi->lock);
 +	mutex_lock(&uuari->lock);
  	switch (lat) {
  	case MLX5_IB_LATENCY_CLASS_LOW:
++<<<<<<< HEAD
 +		uuarn = 0;
 +		uuari->count[uuarn]++;
++=======
+ 		BUILD_BUG_ON(NUM_NON_BLUE_FLAME_BFREGS != 1);
+ 		bfregn = 0;
+ 		bfregi->count[bfregn]++;
++>>>>>>> 0b80c14f0097 (IB/mlx5: Fix retrieval of index to first hi class bfreg)
  		break;
  
  	case MLX5_IB_LATENCY_CLASS_MEDIUM:
* Unmerged path drivers/infiniband/hw/mlx5/qp.c
