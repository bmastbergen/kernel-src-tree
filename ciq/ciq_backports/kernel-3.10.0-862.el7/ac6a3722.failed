flow dissector: correct size of storage for ARP

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] flow_dissector: correct size of storage for ARP (Jonathan Toppins) [1497129]
Rebuild_FUZZ: 97.87%
commit-author Simon Horman <simon.horman@netronome.com>
commit ac6a3722fed67c658a435187d0254ae119d845d3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ac6a3722.failed

The last argument to __skb_header_pointer() should be a buffer large
enough to store struct arphdr. This can be a pointer to a struct arphdr
structure. The code was previously using a pointer to a pointer to
struct arphdr.

By my counting the storage available both before and after is 8 bytes on
x86_64.

Fixes: 55733350e5e8 ("flow disector: ARP support")
	Reported-by: Nicolas Iooss <nicolas.iooss_linux@m4x.org>
	Signed-off-by: Simon Horman <simon.horman@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ac6a3722fed67c658a435187d0254ae119d845d3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/flow_dissector.c
diff --cc net/core/flow_dissector.c
index 3c259b954123,d98d4998213d..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -578,16 -382,60 +578,32 @@@ mpls
  		goto out_good;
  
  	case htons(ETH_P_ARP):
++<<<<<<< HEAD
 +	case htons(ETH_P_RARP):
 +		switch (__skb_flow_dissect_arp(skb, flow_dissector,
 +					       target_container, data,
 +					       nhoff, hlen)) {
 +		case FLOW_DISSECT_RET_OUT_GOOD:
 +			goto out_good;
 +		case FLOW_DISSECT_RET_OUT_BAD:
 +		default:
++=======
+ 	case htons(ETH_P_RARP): {
+ 		struct {
+ 			unsigned char ar_sha[ETH_ALEN];
+ 			unsigned char ar_sip[4];
+ 			unsigned char ar_tha[ETH_ALEN];
+ 			unsigned char ar_tip[4];
+ 		} *arp_eth, _arp_eth;
+ 		const struct arphdr *arp;
+ 		struct arphdr _arp;
+ 
+ 		arp = __skb_header_pointer(skb, nhoff, sizeof(_arp), data,
+ 					   hlen, &_arp);
+ 		if (!arp)
++>>>>>>> ac6a3722fed6 (flow dissector: correct size of storage for ARP)
  			goto out_bad;
 -
 -		if (arp->ar_hrd != htons(ARPHRD_ETHER) ||
 -		    arp->ar_pro != htons(ETH_P_IP) ||
 -		    arp->ar_hln != ETH_ALEN ||
 -		    arp->ar_pln != 4 ||
 -		    (arp->ar_op != htons(ARPOP_REPLY) &&
 -		     arp->ar_op != htons(ARPOP_REQUEST)))
 -			goto out_bad;
 -
 -		arp_eth = __skb_header_pointer(skb, nhoff + sizeof(_arp),
 -					       sizeof(_arp_eth), data,
 -					       hlen,
 -					       &_arp_eth);
 -		if (!arp_eth)
 -			goto out_bad;
 -
 -		if (dissector_uses_key(flow_dissector,
 -				       FLOW_DISSECTOR_KEY_ARP)) {
 -
 -			key_arp = skb_flow_dissector_target(flow_dissector,
 -							    FLOW_DISSECTOR_KEY_ARP,
 -							    target_container);
 -
 -			memcpy(&key_arp->sip, arp_eth->ar_sip,
 -			       sizeof(key_arp->sip));
 -			memcpy(&key_arp->tip, arp_eth->ar_tip,
 -			       sizeof(key_arp->tip));
 -
 -			/* Only store the lower byte of the opcode;
 -			 * this covers ARPOP_REPLY and ARPOP_REQUEST.
 -			 */
 -			key_arp->op = ntohs(arp->ar_op) & 0xff;
 -
 -			ether_addr_copy(key_arp->sha, arp_eth->ar_sha);
 -			ether_addr_copy(key_arp->tha, arp_eth->ar_tha);
  		}
 -
 -		goto out_good;
 -	}
 -
  	default:
  		goto out_bad;
  	}
* Unmerged path net/core/flow_dissector.c
