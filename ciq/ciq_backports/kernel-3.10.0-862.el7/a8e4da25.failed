radix-tree: tidy up range_tag_if_tagged

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Matthew Wilcox <willy@linux.intel.com>
commit a8e4da25d3c573a0c3cf2fb33e91ec5cad8d7f16
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a8e4da25.failed

Convert radix_tree_range_tag_if_tagged to name the nodes parent, node
and child instead of node & slot.

Use parent->offset instead of playing games with 'upindex'.

	Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
	Cc: Konstantin Khlebnikov <koct9i@gmail.com>
	Cc: Kirill Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Jan Kara <jack@suse.com>
	Cc: Neil Brown <neilb@suse.de>
	Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit a8e4da25d3c573a0c3cf2fb33e91ec5cad8d7f16)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/radix-tree.c
diff --cc lib/radix-tree.c
index 467d6e0a3a58,1a82066165db..000000000000
--- a/lib/radix-tree.c
+++ b/lib/radix-tree.c
@@@ -1004,10 -1009,9 +1004,16 @@@ unsigned long radix_tree_range_tag_if_t
  		unsigned long nr_to_tag,
  		unsigned int iftag, unsigned int settag)
  {
++<<<<<<< HEAD
 +	unsigned int height = root->height;
 +	struct radix_tree_node *node = NULL;
 +	struct radix_tree_node *slot;
 +	unsigned int shift;
++=======
+ 	struct radix_tree_node *parent, *node, *child;
+ 	unsigned long maxindex;
+ 	unsigned int shift = radix_tree_load_root(root, &child, &maxindex);
++>>>>>>> a8e4da25d3c5 (radix-tree: tidy up range_tag_if_tagged)
  	unsigned long tagged = 0;
  	unsigned long index = *first_indexp;
  
@@@ -1020,64 -1024,46 +1026,101 @@@
  		*first_indexp = last_index + 1;
  		return 0;
  	}
++<<<<<<< HEAD
 +	if (height == 0) {
++=======
+ 	if (!radix_tree_is_internal_node(child)) {
++>>>>>>> a8e4da25d3c5 (radix-tree: tidy up range_tag_if_tagged)
  		*first_indexp = last_index + 1;
  		root_tag_set(root, settag);
  		return 1;
  	}
  
++<<<<<<< HEAD
 +	shift = (height - 1) * RADIX_TREE_MAP_SHIFT;
 +	slot = indirect_to_ptr(root->rnode);
 +
 +	for (;;) {
 +		unsigned long upindex;
 +		int offset;
 +
 +		offset = (index >> shift) & RADIX_TREE_MAP_MASK;
 +		if (!slot->slots[offset])
++=======
+ 	node = entry_to_node(child);
+ 	shift -= RADIX_TREE_MAP_SHIFT;
+ 
+ 	for (;;) {
+ 		unsigned offset = (index >> shift) & RADIX_TREE_MAP_MASK;
+ 		offset = radix_tree_descend(node, &child, offset);
+ 		if (!child)
++>>>>>>> a8e4da25d3c5 (radix-tree: tidy up range_tag_if_tagged)
  			goto next;
 -		if (!tag_get(node, iftag, offset))
 +		if (!tag_get(slot, iftag, offset))
  			goto next;
++<<<<<<< HEAD
 +		if (shift) {
 +			node = slot;
 +			slot = slot->slots[offset];
 +			if (radix_tree_is_indirect_ptr(slot)) {
 +				slot = indirect_to_ptr(slot);
 +				shift -= RADIX_TREE_MAP_SHIFT;
 +				continue;
 +			} else {
 +				slot = node;
 +				node = node->parent;
 +			}
++=======
+ 		/* Sibling slots never have tags set on them */
+ 		if (radix_tree_is_internal_node(child)) {
+ 			node = entry_to_node(child);
+ 			shift -= RADIX_TREE_MAP_SHIFT;
+ 			continue;
++>>>>>>> a8e4da25d3c5 (radix-tree: tidy up range_tag_if_tagged)
  		}
  
  		/* tag the leaf */
 -		tagged++;
 -		tag_set(node, settag, offset);
 +		tagged += 1 << shift;
 +		tag_set(slot, settag, offset);
  
  		/* walk back up the path tagging interior nodes */
++<<<<<<< HEAD
 +		upindex = index;
 +		while (node) {
 +			upindex >>= RADIX_TREE_MAP_SHIFT;
 +			offset = upindex & RADIX_TREE_MAP_MASK;
 +
 +			/* stop if we find a node with the tag already set */
 +			if (tag_get(node, settag, offset))
 +				break;
 +			tag_set(node, settag, offset);
 +			node = node->parent;
 +		}
 +
 +		/*
 +		 * Small optimization: now clear that node pointer.
 +		 * Since all of this slot's ancestors now have the tag set
 +		 * from setting it above, we have no further need to walk
 +		 * back up the tree setting tags, until we update slot to
 +		 * point to another radix_tree_node.
 +		 */
 +		node = NULL;
 +
 +next:
++=======
+ 		parent = node;
+ 		for (;;) {
+ 			offset = parent->offset;
+ 			parent = parent->parent;
+ 			if (!parent)
+ 				break;
+ 			/* stop if we find a node with the tag already set */
+ 			if (tag_get(parent, settag, offset))
+ 				break;
+ 			tag_set(parent, settag, offset);
+ 		}
+  next:
++>>>>>>> a8e4da25d3c5 (radix-tree: tidy up range_tag_if_tagged)
  		/* Go to next item at level determined by 'shift' */
  		index = ((index >> shift) + 1) << shift;
  		/* Overflow can happen when last_index is ~0UL... */
* Unmerged path lib/radix-tree.c
