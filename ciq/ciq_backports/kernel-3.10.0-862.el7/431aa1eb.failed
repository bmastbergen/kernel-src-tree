bnxt_en: Get firmware package version one time.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] bnxt_en: Get firmware package version one time (Jonathan Toppins) [1459659]
Rebuild_FUZZ: 98.92%
commit-author Michael Chan <michael.chan@broadcom.com>
commit 431aa1eb20d8ae2674723292adb832b968da868e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/431aa1eb.failed

The current code retrieves the firmware package version from firmware
everytime ethtool -i is run.  There is no reason to do that as the
firmware will not change while the driver is loaded.  Get the version
once at init time.

Also, display the full 4-part firmware version string and remove the
less useful interface spec version.

	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 431aa1eb20d8ae2674723292adb832b968da868e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
index ff5dc5caec1a,fe93625e0539..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
@@@ -824,23 -820,13 +822,13 @@@ static void bnxt_get_drvinfo(struct net
  			     struct ethtool_drvinfo *info)
  {
  	struct bnxt *bp = netdev_priv(dev);
- 	char *pkglog;
- 	char *pkgver = NULL;
  
- 	pkglog = kmalloc(BNX_PKG_LOG_MAX_LENGTH, GFP_KERNEL);
- 	if (pkglog)
- 		pkgver = bnxt_get_pkgver(dev, pkglog, BNX_PKG_LOG_MAX_LENGTH);
  	strlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));
  	strlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));
- 	if (pkgver && *pkgver != 0 && isdigit(*pkgver))
- 		snprintf(info->fw_version, sizeof(info->fw_version) - 1,
- 			 "%s pkg %s", bp->fw_ver_str, pkgver);
- 	else
- 		strlcpy(info->fw_version, bp->fw_ver_str,
- 			sizeof(info->fw_version));
+ 	strlcpy(info->fw_version, bp->fw_ver_str, sizeof(info->fw_version));
  	strlcpy(info->bus_info, pci_name(bp->pdev), sizeof(info->bus_info));
 -	info->n_stats = bnxt_get_num_stats(bp);
 -	info->testinfo_len = bp->num_tests;
 +	info->n_stats = BNXT_NUM_STATS * bp->cp_nr_rings;
 +	info->testinfo_len = BNXT_NUM_TESTS(bp);
  	/* TODO CHIMP_FW: eeprom dump details */
  	info->eedump_len = 0;
  	/* TODO CHIMP FW: reg dump details */
@@@ -2204,6 -2189,378 +2191,381 @@@ static int bnxt_set_phys_id(struct net_
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ static int bnxt_hwrm_selftest_irq(struct bnxt *bp, u16 cmpl_ring)
+ {
+ 	struct hwrm_selftest_irq_input req = {0};
+ 
+ 	bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_SELFTEST_IRQ, cmpl_ring, -1);
+ 	return hwrm_send_message(bp, &req, sizeof(req), HWRM_CMD_TIMEOUT);
+ }
+ 
+ static int bnxt_test_irq(struct bnxt *bp)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < bp->cp_nr_rings; i++) {
+ 		u16 cmpl_ring = bp->grp_info[i].cp_fw_ring_id;
+ 		int rc;
+ 
+ 		rc = bnxt_hwrm_selftest_irq(bp, cmpl_ring);
+ 		if (rc)
+ 			return rc;
+ 	}
+ 	return 0;
+ }
+ 
+ static int bnxt_hwrm_mac_loopback(struct bnxt *bp, bool enable)
+ {
+ 	struct hwrm_port_mac_cfg_input req = {0};
+ 
+ 	bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_PORT_MAC_CFG, -1, -1);
+ 
+ 	req.enables = cpu_to_le32(PORT_MAC_CFG_REQ_ENABLES_LPBK);
+ 	if (enable)
+ 		req.lpbk = PORT_MAC_CFG_REQ_LPBK_LOCAL;
+ 	else
+ 		req.lpbk = PORT_MAC_CFG_REQ_LPBK_NONE;
+ 	return hwrm_send_message(bp, &req, sizeof(req), HWRM_CMD_TIMEOUT);
+ }
+ 
+ static int bnxt_disable_an_for_lpbk(struct bnxt *bp,
+ 				    struct hwrm_port_phy_cfg_input *req)
+ {
+ 	struct bnxt_link_info *link_info = &bp->link_info;
+ 	u16 fw_advertising = link_info->advertising;
+ 	u16 fw_speed;
+ 	int rc;
+ 
+ 	if (!link_info->autoneg)
+ 		return 0;
+ 
+ 	fw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_1GB;
+ 	if (netif_carrier_ok(bp->dev))
+ 		fw_speed = bp->link_info.link_speed;
+ 	else if (fw_advertising & BNXT_LINK_SPEED_MSK_10GB)
+ 		fw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_10GB;
+ 	else if (fw_advertising & BNXT_LINK_SPEED_MSK_25GB)
+ 		fw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_25GB;
+ 	else if (fw_advertising & BNXT_LINK_SPEED_MSK_40GB)
+ 		fw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_40GB;
+ 	else if (fw_advertising & BNXT_LINK_SPEED_MSK_50GB)
+ 		fw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_50GB;
+ 
+ 	req->force_link_speed = cpu_to_le16(fw_speed);
+ 	req->flags |= cpu_to_le32(PORT_PHY_CFG_REQ_FLAGS_FORCE |
+ 				  PORT_PHY_CFG_REQ_FLAGS_RESET_PHY);
+ 	rc = hwrm_send_message(bp, req, sizeof(*req), HWRM_CMD_TIMEOUT);
+ 	req->flags = 0;
+ 	req->force_link_speed = cpu_to_le16(0);
+ 	return rc;
+ }
+ 
+ static int bnxt_hwrm_phy_loopback(struct bnxt *bp, bool enable)
+ {
+ 	struct hwrm_port_phy_cfg_input req = {0};
+ 
+ 	bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_PORT_PHY_CFG, -1, -1);
+ 
+ 	if (enable) {
+ 		bnxt_disable_an_for_lpbk(bp, &req);
+ 		req.lpbk = PORT_PHY_CFG_REQ_LPBK_LOCAL;
+ 	} else {
+ 		req.lpbk = PORT_PHY_CFG_REQ_LPBK_NONE;
+ 	}
+ 	req.enables = cpu_to_le32(PORT_PHY_CFG_REQ_ENABLES_LPBK);
+ 	return hwrm_send_message(bp, &req, sizeof(req), HWRM_CMD_TIMEOUT);
+ }
+ 
+ static int bnxt_rx_loopback(struct bnxt *bp, struct bnxt_napi *bnapi,
+ 			    u32 raw_cons, int pkt_size)
+ {
+ 	struct bnxt_cp_ring_info *cpr = &bnapi->cp_ring;
+ 	struct bnxt_rx_ring_info *rxr = bnapi->rx_ring;
+ 	struct bnxt_sw_rx_bd *rx_buf;
+ 	struct rx_cmp *rxcmp;
+ 	u16 cp_cons, cons;
+ 	u8 *data;
+ 	u32 len;
+ 	int i;
+ 
+ 	cp_cons = RING_CMP(raw_cons);
+ 	rxcmp = (struct rx_cmp *)
+ 		&cpr->cp_desc_ring[CP_RING(cp_cons)][CP_IDX(cp_cons)];
+ 	cons = rxcmp->rx_cmp_opaque;
+ 	rx_buf = &rxr->rx_buf_ring[cons];
+ 	data = rx_buf->data_ptr;
+ 	len = le32_to_cpu(rxcmp->rx_cmp_len_flags_type) >> RX_CMP_LEN_SHIFT;
+ 	if (len != pkt_size)
+ 		return -EIO;
+ 	i = ETH_ALEN;
+ 	if (!ether_addr_equal(data + i, bnapi->bp->dev->dev_addr))
+ 		return -EIO;
+ 	i += ETH_ALEN;
+ 	for (  ; i < pkt_size; i++) {
+ 		if (data[i] != (u8)(i & 0xff))
+ 			return -EIO;
+ 	}
+ 	return 0;
+ }
+ 
+ static int bnxt_poll_loopback(struct bnxt *bp, int pkt_size)
+ {
+ 	struct bnxt_napi *bnapi = bp->bnapi[0];
+ 	struct bnxt_cp_ring_info *cpr;
+ 	struct tx_cmp *txcmp;
+ 	int rc = -EIO;
+ 	u32 raw_cons;
+ 	u32 cons;
+ 	int i;
+ 
+ 	cpr = &bnapi->cp_ring;
+ 	raw_cons = cpr->cp_raw_cons;
+ 	for (i = 0; i < 200; i++) {
+ 		cons = RING_CMP(raw_cons);
+ 		txcmp = &cpr->cp_desc_ring[CP_RING(cons)][CP_IDX(cons)];
+ 
+ 		if (!TX_CMP_VALID(txcmp, raw_cons)) {
+ 			udelay(5);
+ 			continue;
+ 		}
+ 
+ 		/* The valid test of the entry must be done first before
+ 		 * reading any further.
+ 		 */
+ 		dma_rmb();
+ 		if (TX_CMP_TYPE(txcmp) == CMP_TYPE_RX_L2_CMP) {
+ 			rc = bnxt_rx_loopback(bp, bnapi, raw_cons, pkt_size);
+ 			raw_cons = NEXT_RAW_CMP(raw_cons);
+ 			raw_cons = NEXT_RAW_CMP(raw_cons);
+ 			break;
+ 		}
+ 		raw_cons = NEXT_RAW_CMP(raw_cons);
+ 	}
+ 	cpr->cp_raw_cons = raw_cons;
+ 	return rc;
+ }
+ 
+ static int bnxt_run_loopback(struct bnxt *bp)
+ {
+ 	struct bnxt_tx_ring_info *txr = &bp->tx_ring[0];
+ 	int pkt_size, i = 0;
+ 	struct sk_buff *skb;
+ 	dma_addr_t map;
+ 	u8 *data;
+ 	int rc;
+ 
+ 	pkt_size = min(bp->dev->mtu + ETH_HLEN, bp->rx_copy_thresh);
+ 	skb = netdev_alloc_skb(bp->dev, pkt_size);
+ 	if (!skb)
+ 		return -ENOMEM;
+ 	data = skb_put(skb, pkt_size);
+ 	eth_broadcast_addr(data);
+ 	i += ETH_ALEN;
+ 	ether_addr_copy(&data[i], bp->dev->dev_addr);
+ 	i += ETH_ALEN;
+ 	for ( ; i < pkt_size; i++)
+ 		data[i] = (u8)(i & 0xff);
+ 
+ 	map = dma_map_single(&bp->pdev->dev, skb->data, pkt_size,
+ 			     PCI_DMA_TODEVICE);
+ 	if (dma_mapping_error(&bp->pdev->dev, map)) {
+ 		dev_kfree_skb(skb);
+ 		return -EIO;
+ 	}
+ 	bnxt_xmit_xdp(bp, txr, map, pkt_size, 0);
+ 
+ 	/* Sync BD data before updating doorbell */
+ 	wmb();
+ 
+ 	bnxt_db_write(bp, txr->tx_doorbell, DB_KEY_TX | txr->tx_prod);
+ 	rc = bnxt_poll_loopback(bp, pkt_size);
+ 
+ 	dma_unmap_single(&bp->pdev->dev, map, pkt_size, PCI_DMA_TODEVICE);
+ 	dev_kfree_skb(skb);
+ 	return rc;
+ }
+ 
+ static int bnxt_run_fw_tests(struct bnxt *bp, u8 test_mask, u8 *test_results)
+ {
+ 	struct hwrm_selftest_exec_output *resp = bp->hwrm_cmd_resp_addr;
+ 	struct hwrm_selftest_exec_input req = {0};
+ 	int rc;
+ 
+ 	bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_SELFTEST_EXEC, -1, -1);
+ 	mutex_lock(&bp->hwrm_cmd_lock);
+ 	resp->test_success = 0;
+ 	req.flags = test_mask;
+ 	rc = _hwrm_send_message(bp, &req, sizeof(req), bp->test_info->timeout);
+ 	*test_results = resp->test_success;
+ 	mutex_unlock(&bp->hwrm_cmd_lock);
+ 	return rc;
+ }
+ 
+ #define BNXT_DRV_TESTS			3
+ #define BNXT_MACLPBK_TEST_IDX		(bp->num_tests - BNXT_DRV_TESTS)
+ #define BNXT_PHYLPBK_TEST_IDX		(BNXT_MACLPBK_TEST_IDX + 1)
+ #define BNXT_IRQ_TEST_IDX		(BNXT_MACLPBK_TEST_IDX + 2)
+ 
+ static void bnxt_self_test(struct net_device *dev, struct ethtool_test *etest,
+ 			   u64 *buf)
+ {
+ 	struct bnxt *bp = netdev_priv(dev);
+ 	bool offline = false;
+ 	u8 test_results = 0;
+ 	u8 test_mask = 0;
+ 	int rc, i;
+ 
+ 	if (!bp->num_tests || !BNXT_SINGLE_PF(bp))
+ 		return;
+ 	memset(buf, 0, sizeof(u64) * bp->num_tests);
+ 	if (!netif_running(dev)) {
+ 		etest->flags |= ETH_TEST_FL_FAILED;
+ 		return;
+ 	}
+ 
+ 	if (etest->flags & ETH_TEST_FL_OFFLINE) {
+ 		if (bp->pf.active_vfs) {
+ 			etest->flags |= ETH_TEST_FL_FAILED;
+ 			netdev_warn(dev, "Offline tests cannot be run with active VFs\n");
+ 			return;
+ 		}
+ 		offline = true;
+ 	}
+ 
+ 	for (i = 0; i < bp->num_tests - BNXT_DRV_TESTS; i++) {
+ 		u8 bit_val = 1 << i;
+ 
+ 		if (!(bp->test_info->offline_mask & bit_val))
+ 			test_mask |= bit_val;
+ 		else if (offline)
+ 			test_mask |= bit_val;
+ 	}
+ 	if (!offline) {
+ 		bnxt_run_fw_tests(bp, test_mask, &test_results);
+ 	} else {
+ 		rc = bnxt_close_nic(bp, false, false);
+ 		if (rc)
+ 			return;
+ 		bnxt_run_fw_tests(bp, test_mask, &test_results);
+ 
+ 		buf[BNXT_MACLPBK_TEST_IDX] = 1;
+ 		bnxt_hwrm_mac_loopback(bp, true);
+ 		msleep(250);
+ 		rc = bnxt_half_open_nic(bp);
+ 		if (rc) {
+ 			bnxt_hwrm_mac_loopback(bp, false);
+ 			etest->flags |= ETH_TEST_FL_FAILED;
+ 			return;
+ 		}
+ 		if (bnxt_run_loopback(bp))
+ 			etest->flags |= ETH_TEST_FL_FAILED;
+ 		else
+ 			buf[BNXT_MACLPBK_TEST_IDX] = 0;
+ 
+ 		bnxt_hwrm_mac_loopback(bp, false);
+ 		bnxt_hwrm_phy_loopback(bp, true);
+ 		msleep(1000);
+ 		if (bnxt_run_loopback(bp)) {
+ 			buf[BNXT_PHYLPBK_TEST_IDX] = 1;
+ 			etest->flags |= ETH_TEST_FL_FAILED;
+ 		}
+ 		bnxt_hwrm_phy_loopback(bp, false);
+ 		bnxt_half_close_nic(bp);
+ 		bnxt_open_nic(bp, false, true);
+ 	}
+ 	if (bnxt_test_irq(bp)) {
+ 		buf[BNXT_IRQ_TEST_IDX] = 1;
+ 		etest->flags |= ETH_TEST_FL_FAILED;
+ 	}
+ 	for (i = 0; i < bp->num_tests - BNXT_DRV_TESTS; i++) {
+ 		u8 bit_val = 1 << i;
+ 
+ 		if ((test_mask & bit_val) && !(test_results & bit_val)) {
+ 			buf[i] = 1;
+ 			etest->flags |= ETH_TEST_FL_FAILED;
+ 		}
+ 	}
+ }
+ 
+ void bnxt_ethtool_init(struct bnxt *bp)
+ {
+ 	struct hwrm_selftest_qlist_output *resp = bp->hwrm_cmd_resp_addr;
+ 	struct hwrm_selftest_qlist_input req = {0};
+ 	struct bnxt_test_info *test_info;
+ 	struct net_device *dev = bp->dev;
+ 	char *pkglog;
+ 	int i, rc;
+ 
+ 	pkglog = kzalloc(BNX_PKG_LOG_MAX_LENGTH, GFP_KERNEL);
+ 	if (pkglog) {
+ 		char *pkgver;
+ 		int len;
+ 
+ 		pkgver = bnxt_get_pkgver(dev, pkglog, BNX_PKG_LOG_MAX_LENGTH);
+ 		if (pkgver && *pkgver != 0 && isdigit(*pkgver)) {
+ 			len = strlen(bp->fw_ver_str);
+ 			snprintf(bp->fw_ver_str + len, FW_VER_STR_LEN - len - 1,
+ 				 "/pkg %s", pkgver);
+ 		}
+ 		kfree(pkglog);
+ 	}
+ 	if (bp->hwrm_spec_code < 0x10704 || !BNXT_SINGLE_PF(bp))
+ 		return;
+ 
+ 	bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_SELFTEST_QLIST, -1, -1);
+ 	mutex_lock(&bp->hwrm_cmd_lock);
+ 	rc = _hwrm_send_message(bp, &req, sizeof(req), HWRM_CMD_TIMEOUT);
+ 	if (rc)
+ 		goto ethtool_init_exit;
+ 
+ 	test_info = kzalloc(sizeof(*bp->test_info), GFP_KERNEL);
+ 	if (!test_info)
+ 		goto ethtool_init_exit;
+ 
+ 	bp->test_info = test_info;
+ 	bp->num_tests = resp->num_tests + BNXT_DRV_TESTS;
+ 	if (bp->num_tests > BNXT_MAX_TEST)
+ 		bp->num_tests = BNXT_MAX_TEST;
+ 
+ 	test_info->offline_mask = resp->offline_tests;
+ 	test_info->timeout = le16_to_cpu(resp->test_timeout);
+ 	if (!test_info->timeout)
+ 		test_info->timeout = HWRM_CMD_TIMEOUT;
+ 	for (i = 0; i < bp->num_tests; i++) {
+ 		char *str = test_info->string[i];
+ 		char *fw_str = resp->test0_name + i * 32;
+ 
+ 		if (i == BNXT_MACLPBK_TEST_IDX) {
+ 			strcpy(str, "Mac loopback test (offline)");
+ 		} else if (i == BNXT_PHYLPBK_TEST_IDX) {
+ 			strcpy(str, "Phy loopback test (offline)");
+ 		} else if (i == BNXT_IRQ_TEST_IDX) {
+ 			strcpy(str, "Interrupt_test (offline)");
+ 		} else {
+ 			strlcpy(str, fw_str, ETH_GSTRING_LEN);
+ 			strncat(str, " test", ETH_GSTRING_LEN - strlen(str));
+ 			if (test_info->offline_mask & (1 << i))
+ 				strncat(str, " (offline)",
+ 					ETH_GSTRING_LEN - strlen(str));
+ 			else
+ 				strncat(str, " (online)",
+ 					ETH_GSTRING_LEN - strlen(str));
+ 		}
+ 	}
+ 
+ ethtool_init_exit:
+ 	mutex_unlock(&bp->hwrm_cmd_lock);
+ }
+ 
+ void bnxt_ethtool_free(struct bnxt *bp)
+ {
+ 	kfree(bp->test_info);
+ 	bp->test_info = NULL;
+ }
+ 
++>>>>>>> 431aa1eb20d8 (bnxt_en: Get firmware package version one time.)
  const struct ethtool_ops bnxt_ethtool_ops = {
  	.get_link_ksettings	= bnxt_get_link_ksettings,
  	.set_link_ksettings	= bnxt_set_link_ksettings,
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt.c b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
index 619fb6934a3c..6001d7d8f936 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@ -4597,9 +4597,9 @@ static int bnxt_hwrm_ver_get(struct bnxt *bp)
 			    resp->hwrm_intf_upd);
 		netdev_warn(bp->dev, "Please update firmware with HWRM interface 1.0.0 or newer.\n");
 	}
-	snprintf(bp->fw_ver_str, BC_HWRM_STR_LEN, "%d.%d.%d/%d.%d.%d",
+	snprintf(bp->fw_ver_str, BC_HWRM_STR_LEN, "%d.%d.%d.%d",
 		 resp->hwrm_fw_maj, resp->hwrm_fw_min, resp->hwrm_fw_bld,
-		 resp->hwrm_intf_maj, resp->hwrm_intf_min, resp->hwrm_intf_upd);
+		 resp->hwrm_fw_rsvd);
 
 	bp->hwrm_cmd_timeout = le16_to_cpu(resp->def_req_timeout);
 	if (!bp->hwrm_cmd_timeout)
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
