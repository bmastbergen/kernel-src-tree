nfp: wait for board state before talking to the NSP

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 4cbe94f2af25bf8f4d5dea56c770937d896342bf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4cbe94f2.failed

Board state informs us which low-level initialization stages the card
has completed.  We should wait for the card to be fully initialized
before trying to communicate with it, not only before we configure
passing traffic.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4cbe94f2af25bf8f4d5dea56c770937d896342bf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_main.c
#	drivers/net/ethernet/netronome/nfp/nfp_net_main.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_main.c
index 21abad2c51cc,424707d41fbd..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_main.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_main.c
@@@ -69,7 -72,47 +69,46 @@@ static const struct pci_device_id nfp_p
  	},
  	{ 0, } /* Required last entry. */
  };
 -MODULE_DEVICE_TABLE(pci, nfp_pci_device_ids);
  
+ static bool nfp_board_ready(struct nfp_pf *pf)
+ {
+ 	const char *cp;
+ 	long state;
+ 	int err;
+ 
+ 	cp = nfp_hwinfo_lookup(pf->hwinfo, "board.state");
+ 	if (!cp)
+ 		return false;
+ 
+ 	err = kstrtol(cp, 0, &state);
+ 	if (err < 0)
+ 		return false;
+ 
+ 	return state == 15;
+ }
+ 
+ static int nfp_pf_board_state_wait(struct nfp_pf *pf)
+ {
+ 	const unsigned long wait_until = jiffies + 10 * HZ;
+ 
+ 	while (!nfp_board_ready(pf)) {
+ 		if (time_is_before_eq_jiffies(wait_until)) {
+ 			nfp_err(pf->cpp, "NFP board initialization timeout\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		nfp_info(pf->cpp, "waiting for board initialization\n");
+ 		if (msleep_interruptible(500))
+ 			return -ERESTARTSYS;
+ 
+ 		/* Refresh cached information */
+ 		kfree(pf->hwinfo);
+ 		pf->hwinfo = nfp_hwinfo_read(pf->cpp);
+ 	}
+ 
+ 	return 0;
+ }
+ 
  static int nfp_pcie_sriov_read_nfd_limit(struct nfp_pf *pf)
  {
  	int err;
@@@ -381,12 -455,22 +420,28 @@@ static int nfp_pci_probe(struct pci_de
  		goto err_disable_msix;
  	}
  
 -	pf->hwinfo = nfp_hwinfo_read(pf->cpp);
 -
  	dev_info(&pdev->dev, "Assembly: %s%s%s-%s CPLD: %s\n",
++<<<<<<< HEAD
 +		 nfp_hwinfo_lookup(pf->cpp, "assembly.vendor"),
 +		 nfp_hwinfo_lookup(pf->cpp, "assembly.partno"),
 +		 nfp_hwinfo_lookup(pf->cpp, "assembly.serial"),
 +		 nfp_hwinfo_lookup(pf->cpp, "assembly.revision"),
 +		 nfp_hwinfo_lookup(pf->cpp, "cpld.version"));
++=======
+ 		 nfp_hwinfo_lookup(pf->hwinfo, "assembly.vendor"),
+ 		 nfp_hwinfo_lookup(pf->hwinfo, "assembly.partno"),
+ 		 nfp_hwinfo_lookup(pf->hwinfo, "assembly.serial"),
+ 		 nfp_hwinfo_lookup(pf->hwinfo, "assembly.revision"),
+ 		 nfp_hwinfo_lookup(pf->hwinfo, "cpld.version"));
+ 
+ 	err = nfp_pf_board_state_wait(pf);
+ 	if (err)
+ 		goto err_hwinfo_free;
+ 
+ 	err = devlink_register(devlink, &pdev->dev);
+ 	if (err)
+ 		goto err_hwinfo_free;
++>>>>>>> 4cbe94f2af25 (nfp: wait for board state before talking to the NSP)
  
  	err = nfp_nsp_init(pdev, pf);
  	if (err)
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_main.c
index 092c7d18f2ec,ff373acd28f3..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
@@@ -61,90 -63,22 +61,93 @@@
  
  #define NFP_PF_CSR_SLICE_SIZE	(32 * 1024)
  
++<<<<<<< HEAD
 +static int nfp_is_ready(struct nfp_cpp *cpp)
 +{
 +	const char *cp;
 +	long state;
 +	int err;
 +
 +	cp = nfp_hwinfo_lookup(cpp, "board.state");
 +	if (!cp)
 +		return 0;
 +
 +	err = kstrtol(cp, 0, &state);
 +	if (err < 0)
 +		return 0;
 +
 +	return state == 15;
 +}
 +
++=======
++>>>>>>> 4cbe94f2af25 (nfp: wait for board state before talking to the NSP)
  /**
 - * nfp_net_get_mac_addr() - Get the MAC address.
 - * @pf:       NFP PF handle
 - * @port:     NFP port structure
 + * nfp_net_map_area() - Help function to map an area
 + * @cpp:    NFP CPP handler
 + * @name:   Name for the area
 + * @target: CPP target
 + * @addr:   CPP address
 + * @size:   Size of the area
 + * @area:   Area handle (returned).
   *
 - * First try to get the MAC address from NSP ETH table. If that
 - * fails generate a random address.
 + * This function is primarily to simplify the code in the main probe
 + * function. To undo the effect of this functions call
 + * @nfp_cpp_area_release_free(*area);
 + *
 + * Return: Pointer to memory mapped area or ERR_PTR
   */
 -void nfp_net_get_mac_addr(struct nfp_pf *pf, struct nfp_port *port)
 +static u8 __iomem *nfp_net_map_area(struct nfp_cpp *cpp,
 +				    const char *name, int isl, int target,
 +				    unsigned long long addr, unsigned long size,
 +				    struct nfp_cpp_area **area)
 +{
 +	u8 __iomem *res;
 +	u32 dest;
 +	int err;
 +
 +	dest = NFP_CPP_ISLAND_ID(target, NFP_CPP_ACTION_RW, 0, isl);
 +
 +	*area = nfp_cpp_area_alloc_with_name(cpp, dest, name, addr, size);
 +	if (!*area) {
 +		err = -EIO;
 +		goto err_area;
 +	}
 +
 +	err = nfp_cpp_area_acquire(*area);
 +	if (err < 0)
 +		goto err_acquire;
 +
 +	res = nfp_cpp_area_iomem(*area);
 +	if (!res) {
 +		err = -EIO;
 +		goto err_map;
 +	}
 +
 +	return res;
 +
 +err_map:
 +	nfp_cpp_area_release(*area);
 +err_acquire:
 +	nfp_cpp_area_free(*area);
 +err_area:
 +	return (u8 __iomem *)ERR_PTR(err);
 +}
 +
 +static void
 +nfp_net_get_mac_addr_hwinfo(struct nfp_net *nn, struct nfp_cpp *cpp,
 +			    unsigned int id)
  {
 -	struct nfp_eth_table_port *eth_port;
 +	u8 mac_addr[ETH_ALEN];
 +	const char *mac_str;
 +	char name[32];
 +
 +	snprintf(name, sizeof(name), "eth%d.mac", id);
  
 -	eth_port = __nfp_port_get_eth_port(port);
 -	if (!eth_port) {
 -		eth_hw_addr_random(port->netdev);
 +	mac_str = nfp_hwinfo_lookup(cpp, name);
 +	if (!mac_str) {
 +		dev_warn(&nn->pdev->dev,
 +			 "Can't lookup MAC address. Generate\n");
 +		eth_hw_addr_random(nn->netdev);
  		return;
  	}
  
@@@ -535,22 -706,30 +538,30 @@@ int nfp_net_pci_probe(struct nfp_pf *pf
  	int stride;
  	int err;
  
 -	INIT_WORK(&pf->port_refresh_work, nfp_net_refresh_vnics);
 +	INIT_WORK(&pf->port_refresh_work, nfp_net_refresh_netdevs);
 +	mutex_init(&pf->port_lock);
 +
++<<<<<<< HEAD
 +	/* Verify that the board has completed initialization */
 +	if (!nfp_is_ready(pf->cpp)) {
 +		nfp_err(pf->cpp, "NFP is not ready for NIC operation.\n");
 +		return -EINVAL;
 +	}
  
 +	mutex_lock(&pf->port_lock);
 +	pf->num_ports = nfp_net_pf_get_num_ports(pf);
++=======
+ 	if (!pf->rtbl) {
+ 		nfp_err(pf->cpp, "No %s, giving up.\n",
+ 			pf->fw_loaded ? "symbol table" : "firmware found");
+ 		return -EINVAL;
+ 	}
++>>>>>>> 4cbe94f2af25 (nfp: wait for board state before talking to the NSP)
  
 -	mutex_lock(&pf->lock);
 -	pf->max_data_vnics = nfp_net_pf_get_num_ports(pf);
 -	if ((int)pf->max_data_vnics < 0) {
 -		err = pf->max_data_vnics;
 -		goto err_unlock;
 -	}
 -
 -	err = nfp_net_pci_map_mem(pf);
 -	if (err)
 +	ctrl_bar = nfp_net_pf_map_ctrl_bar(pf);
 +	if (!ctrl_bar) {
 +		err = pf->fw_loaded ? -EINVAL : -EPROBE_DEFER;
  		goto err_unlock;
 -
 -	ctrl_bar = nfp_cpp_area_iomem(pf->data_vnic_bar);
 -	qc_bar = nfp_cpp_area_iomem(pf->qc_area);
 -	if (!ctrl_bar || !qc_bar) {
 -		err = -EIO;
 -		goto err_unmap;
  	}
  
  	nfp_net_get_fw_version(&fw_ver, ctrl_bar);
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_main.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_main.c
