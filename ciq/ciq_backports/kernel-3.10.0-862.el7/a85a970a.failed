net_sched: move tc_action into tcf_common

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author WANG Cong <xiyou.wangcong@gmail.com>
commit a85a970af265f156740977168b542234511b28a8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a85a970a.failed

struct tc_action is confusing, currently we use it for two purposes:
1) Pass in arguments and carry out results from helper functions
2) A generic representation for tc actions

The first one is error-prone, since we need to make sure we don't
miss anything. This patch aims to get rid of this use, by moving
tc_action into tcf_common, so that they are allocated together
in hashtable and can be cast'ed easily.

And together with the following patch, we could really make
tc_action a generic representation for all tc actions and each
type of action can inherit from it.

	Cc: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a85a970af265f156740977168b542234511b28a8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/act_api.h
#	include/net/tc_act/tc_bpf.h
#	include/net/tc_act/tc_connmark.h
#	include/net/tc_act/tc_ife.h
#	net/sched/act_api.c
#	net/sched/act_bpf.c
#	net/sched/act_connmark.c
#	net/sched/act_csum.c
#	net/sched/act_gact.c
#	net/sched/act_ife.c
#	net/sched/act_ipt.c
#	net/sched/act_mirred.c
#	net/sched/act_nat.c
#	net/sched/act_pedit.c
#	net/sched/act_police.c
#	net/sched/act_simple.c
#	net/sched/act_skbedit.c
#	net/sched/act_vlan.c
diff --cc include/net/act_api.h
index 7eba1aba336b,8b199095ea51..000000000000
--- a/include/net/act_api.h
+++ b/include/net/act_api.h
@@@ -7,8 -7,29 +7,27 @@@
  
  #include <net/sch_generic.h>
  #include <net/pkt_sched.h>
 -#include <net/net_namespace.h>
 -#include <net/netns/generic.h>
  
+ 
+ struct tcf_hashinfo {
+ 	struct hlist_head	*htab;
+ 	unsigned int		hmask;
+ 	spinlock_t		lock;
+ 	u32			index;
+ };
+ 
+ struct tc_action_ops;
+ 
+ struct tc_action {
+ 	const struct tc_action_ops	*ops;
+ 	__u32			type; /* for backward compat(TCA_OLD_COMPAT) */
+ 	__u32			order;
+ 	struct list_head	list;
+ 	struct tcf_hashinfo	*hinfo;
+ };
+ 
  struct tcf_common {
+ 	struct tc_action		tcfc_act;
  	struct hlist_node		tcfc_head;
  	u32				tcfc_index;
  	int				tcfc_refcnt;
@@@ -23,8 -44,8 +42,9 @@@
  	struct rcu_head			tcfc_rcu;
  	struct gnet_stats_basic_cpu __percpu *cpu_bstats;
  	struct gnet_stats_queue __percpu *cpu_qstats;
 +	struct tc_cookie	*act_cookie;
  };
+ #define tcf_act		common.tcfc_act
  #define tcf_head	common.tcfc_head
  #define tcf_index	common.tcfc_index
  #define tcf_refcnt	common.tcfc_refcnt
@@@ -87,14 -101,6 +100,17 @@@ static inline void tcf_tm_dump(struct t
  	dtm->expires = jiffies_to_clock_t(stm->expires);
  }
  
++<<<<<<< HEAD
 +struct tc_action {
 +	void			*priv;
 +	const struct tc_action_ops	*ops;
 +	__u32			type; /* for backward compat(TCA_OLD_COMPAT) */
 +	__u32			order;
 +	struct list_head	list;
 +};
 +
++=======
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  #ifdef CONFIG_NET_CLS_ACT
  
  #define ACT_P_CREATED 1
@@@ -102,31 -108,65 +118,84 @@@
  
  struct tc_action_ops {
  	struct list_head head;
 +	struct tcf_hashinfo *hinfo;
  	char    kind[IFNAMSIZ];
  	__u32   type; /* TBD to match kind */
+ 	size_t	size;
  	struct module		*owner;
  	int     (*act)(struct sk_buff *, const struct tc_action *,
  		       struct tcf_result *);
  	int     (*dump)(struct sk_buff *, struct tc_action *, int, int);
  	void	(*cleanup)(struct tc_action *, int bind);
++<<<<<<< HEAD
 +	int     (*lookup)(struct tc_action *, u32);
++=======
+ 	int     (*lookup)(struct net *, struct tc_action **, u32);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  	int     (*init)(struct net *net, struct nlattr *nla,
- 			struct nlattr *est, struct tc_action *act, int ovr,
+ 			struct nlattr *est, struct tc_action **act, int ovr,
  			int bind);
++<<<<<<< HEAD
 +	int     (*walk)(struct sk_buff *, struct netlink_callback *, int, struct tc_action *);
++=======
+ 	int     (*walk)(struct net *, struct sk_buff *,
+ 			struct netlink_callback *, int, const struct tc_action_ops *);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  	void	(*stats_update)(struct tc_action *, u64, u32, u64);
 +	int	(*get_dev)(const struct tc_action *a, struct net *net,
 +			   struct net_device **mirred_dev);
  };
  
++<<<<<<< HEAD
 +int tcf_hash_search(struct tc_action *a, u32 index);
 +u32 tcf_hash_new_index(struct tcf_hashinfo *hinfo);
 +int tcf_hash_check(u32 index, struct tc_action *a, int bind);
 +int tcf_hash_create(u32 index, struct nlattr *est, struct tc_action *a,
 +		    int size, int bind, bool cpustats);
++=======
+ struct tc_action_net {
+ 	struct tcf_hashinfo *hinfo;
+ 	const struct tc_action_ops *ops;
+ };
+ 
+ static inline
+ int tc_action_net_init(struct tc_action_net *tn,
+ 		       const struct tc_action_ops *ops, unsigned int mask)
+ {
+ 	int err = 0;
+ 
+ 	tn->hinfo = kmalloc(sizeof(*tn->hinfo), GFP_KERNEL);
+ 	if (!tn->hinfo)
+ 		return -ENOMEM;
+ 	tn->ops = ops;
+ 	err = tcf_hashinfo_init(tn->hinfo, mask);
+ 	if (err)
+ 		kfree(tn->hinfo);
+ 	return err;
+ }
+ 
+ void tcf_hashinfo_destroy(const struct tc_action_ops *ops,
+ 			  struct tcf_hashinfo *hinfo);
+ 
+ static inline void tc_action_net_exit(struct tc_action_net *tn)
+ {
+ 	tcf_hashinfo_destroy(tn->ops, tn->hinfo);
+ 	kfree(tn->hinfo);
+ }
+ 
+ int tcf_generic_walker(struct tc_action_net *tn, struct sk_buff *skb,
+ 		       struct netlink_callback *cb, int type,
+ 		       const struct tc_action_ops *ops);
+ int tcf_hash_search(struct tc_action_net *tn, struct tc_action **a, u32 index);
+ u32 tcf_hash_new_index(struct tc_action_net *tn);
+ bool tcf_hash_check(struct tc_action_net *tn, u32 index, struct tc_action **a,
+ 		    int bind);
+ int tcf_hash_create(struct tc_action_net *tn, u32 index, struct nlattr *est,
+ 		    struct tc_action **a, const struct tc_action_ops *ops, int bind,
+ 		    bool cpustats);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  void tcf_hash_cleanup(struct tc_action *a, struct nlattr *est);
 -void tcf_hash_insert(struct tc_action_net *tn, struct tc_action *a);
 +void tcf_hash_insert(struct tc_action *a);
  
  int __tcf_hash_release(struct tc_action *a, bool bind, bool strict);
  
diff --cc net/sched/act_api.c
index ea1d31e140f8,d97419f35e7e..000000000000
--- a/net/sched/act_api.c
+++ b/net/sched/act_api.c
@@@ -43,10 -36,9 +43,14 @@@ static void free_tcf(struct rcu_head *h
  	kfree(p);
  }
  
 -static void tcf_hash_destroy(struct tcf_hashinfo *hinfo, struct tc_action *a)
 +static void tcf_hash_destroy(struct tc_action *a)
  {
++<<<<<<< HEAD
 +	struct tcf_common *p = a->priv;
 +	struct tcf_hashinfo *hinfo = a->ops->hinfo;
++=======
+ 	struct tcf_common *p = (struct tcf_common *)a;
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  
  	spin_lock_bh(&hinfo->lock);
  	hlist_del(&p->tcfc_head);
@@@ -75,7 -67,8 +79,12 @@@ int __tcf_hash_release(struct tc_actio
  		if (p->tcfc_bindcnt <= 0 && p->tcfc_refcnt <= 0) {
  			if (a->ops->cleanup)
  				a->ops->cleanup(a, bind);
++<<<<<<< HEAD
 +			tcf_hash_destroy(a);
++=======
+ 			list_del(&a->list);
+ 			tcf_hash_destroy(a->hinfo, a);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  			ret = ACT_P_DELETED;
  		}
  	}
@@@ -84,12 -77,9 +93,18 @@@
  }
  EXPORT_SYMBOL(__tcf_hash_release);
  
++<<<<<<< HEAD
 +static int tcf_dump_walker(struct sk_buff *skb, struct netlink_callback *cb,
 +			   struct tc_action *a)
 +{
 +	struct tcf_hashinfo *hinfo = a->ops->hinfo;
 +	struct hlist_head *head;
 +	struct tcf_common *p;
++=======
+ static int tcf_dump_walker(struct tcf_hashinfo *hinfo, struct sk_buff *skb,
+ 			   struct netlink_callback *cb)
+ {
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  	int err = 0, index = -1, i = 0, s_i = 0, n_i = 0;
  	struct nlattr *nest;
  
@@@ -133,12 -124,9 +149,18 @@@ nla_put_failure
  	goto done;
  }
  
++<<<<<<< HEAD
 +static int tcf_del_walker(struct sk_buff *skb, struct tc_action *a)
 +{
 +	struct tcf_hashinfo *hinfo = a->ops->hinfo;
 +	struct hlist_head *head;
 +	struct hlist_node *n;
 +	struct tcf_common *p;
++=======
+ static int tcf_del_walker(struct tcf_hashinfo *hinfo, struct sk_buff *skb,
+ 			  const struct tc_action_ops *ops)
+ {
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  	struct nlattr *nest;
  	int i = 0, n_i = 0;
  	int ret = -EINVAL;
@@@ -170,13 -161,16 +195,26 @@@ nla_put_failure
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int tcf_generic_walker(struct sk_buff *skb, struct netlink_callback *cb,
 +			      int type, struct tc_action *a)
 +{
 +	if (type == RTM_DELACTION) {
 +		return tcf_del_walker(skb, a);
 +	} else if (type == RTM_GETACTION) {
 +		return tcf_dump_walker(skb, cb, a);
++=======
+ int tcf_generic_walker(struct tc_action_net *tn, struct sk_buff *skb,
+ 		       struct netlink_callback *cb, int type,
+ 		       const struct tc_action_ops *ops)
+ {
+ 	struct tcf_hashinfo *hinfo = tn->hinfo;
+ 
+ 	if (type == RTM_DELACTION) {
+ 		return tcf_del_walker(hinfo, skb, ops);
+ 	} else if (type == RTM_GETACTION) {
+ 		return tcf_dump_walker(hinfo, skb, cb);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  	} else {
  		WARN(1, "tcf_generic_walker: unknown action %d\n", type);
  		return -EINVAL;
@@@ -212,31 -208,32 +250,49 @@@ u32 tcf_hash_new_index(struct tcf_hashi
  }
  EXPORT_SYMBOL(tcf_hash_new_index);
  
++<<<<<<< HEAD
 +int tcf_hash_search(struct tc_action *a, u32 index)
++=======
+ int tcf_hash_search(struct tc_action_net *tn, struct tc_action **a, u32 index)
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  {
 -	struct tcf_hashinfo *hinfo = tn->hinfo;
 +	struct tcf_hashinfo *hinfo = a->ops->hinfo;
  	struct tcf_common *p = tcf_hash_lookup(index, hinfo);
  
  	if (p) {
++<<<<<<< HEAD
 +		a->priv = p;
++=======
+ 		*a = &p->tcfc_act;
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  		return 1;
  	}
  	return 0;
  }
  EXPORT_SYMBOL(tcf_hash_search);
  
++<<<<<<< HEAD
 +int tcf_hash_check(u32 index, struct tc_action *a, int bind)
++=======
+ bool tcf_hash_check(struct tc_action_net *tn, u32 index, struct tc_action **a,
+ 		    int bind)
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  {
 -	struct tcf_hashinfo *hinfo = tn->hinfo;
 +	struct tcf_hashinfo *hinfo = a->ops->hinfo;
  	struct tcf_common *p = NULL;
  	if (index && (p = tcf_hash_lookup(index, hinfo)) != NULL) {
  		if (bind)
  			p->tcfc_bindcnt++;
  		p->tcfc_refcnt++;
++<<<<<<< HEAD
 +		a->priv = p;
 +		return 1;
++=======
+ 		*a = &p->tcfc_act;
+ 		return true;
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  	}
 -	return false;
 +	return 0;
  }
  EXPORT_SYMBOL(tcf_hash_check);
  
@@@ -250,11 -247,12 +306,20 @@@ void tcf_hash_cleanup(struct tc_action 
  }
  EXPORT_SYMBOL(tcf_hash_cleanup);
  
++<<<<<<< HEAD
 +int tcf_hash_create(u32 index, struct nlattr *est, struct tc_action *a,
 +		    int size, int bind, bool cpustats)
 +{
 +	struct tcf_hashinfo *hinfo = a->ops->hinfo;
 +	struct tcf_common *p = kzalloc(size, GFP_KERNEL);
++=======
+ int tcf_hash_create(struct tc_action_net *tn, u32 index, struct nlattr *est,
+ 		    struct tc_action **a, const struct tc_action_ops *ops,
+ 		    int bind, bool cpustats)
+ {
+ 	struct tcf_common *p = kzalloc(ops->size, GFP_KERNEL);
+ 	struct tcf_hashinfo *hinfo = tn->hinfo;
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  	int err = -ENOMEM;
  
  	if (unlikely(!p))
@@@ -293,15 -291,18 +358,27 @@@ err2
  		}
  	}
  
++<<<<<<< HEAD
 +	a->priv = (void *) p;
++=======
+ 	p->tcfc_act.hinfo = hinfo;
+ 	p->tcfc_act.ops = ops;
+ 	INIT_LIST_HEAD(&p->tcfc_act.list);
+ 	*a = &p->tcfc_act;
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  	return 0;
  }
  EXPORT_SYMBOL(tcf_hash_create);
  
 -void tcf_hash_insert(struct tc_action_net *tn, struct tc_action *a)
 +void tcf_hash_insert(struct tc_action *a)
  {
++<<<<<<< HEAD
 +	struct tcf_common *p = a->priv;
 +	struct tcf_hashinfo *hinfo = a->ops->hinfo;
++=======
+ 	struct tcf_common *p = (struct tcf_common *)a;
+ 	struct tcf_hashinfo *hinfo = tn->hinfo;
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  	unsigned int h = tcf_hash(p->tcfc_index, hinfo->hmask);
  
  	spin_lock_bh(&hinfo->lock);
@@@ -310,12 -311,9 +387,15 @@@
  }
  EXPORT_SYMBOL(tcf_hash_insert);
  
 -void tcf_hashinfo_destroy(const struct tc_action_ops *ops,
 -			  struct tcf_hashinfo *hinfo)
 +static void tcf_hashinfo_destroy(const struct tc_action_ops *ops)
  {
++<<<<<<< HEAD
 +	struct tcf_hashinfo *hinfo = ops->hinfo;
 +	struct tc_action a = {
 +		.ops = ops,
 +	};
++=======
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  	int i;
  
  	for (i = 0; i < hinfo->hmask + 1; i++) {
@@@ -625,31 -573,14 +702,24 @@@ struct tc_action *tcf_action_init_1(str
  		goto err_out;
  	}
  
- 	err = -ENOMEM;
- 	a = kzalloc(sizeof(*a), GFP_KERNEL);
- 	if (a == NULL)
- 		goto err_mod;
- 
- 	a->ops = a_o;
- 	INIT_LIST_HEAD(&a->list);
  	/* backward compatibility for policer */
  	if (name == NULL)
- 		err = a_o->init(net, tb[TCA_ACT_OPTIONS], est, a, ovr, bind);
+ 		err = a_o->init(net, tb[TCA_ACT_OPTIONS], est, &a, ovr, bind);
  	else
- 		err = a_o->init(net, nla, est, a, ovr, bind);
+ 		err = a_o->init(net, nla, est, &a, ovr, bind);
  	if (err < 0)
- 		goto err_free;
+ 		goto err_mod;
  
 +	if (name == NULL && tb[TCA_ACT_COOKIE]) {
 +		struct tcf_common *p = a->priv;
 +
 +		if (p->act_cookie) {
 +			kfree(p->act_cookie->data);
 +			kfree(p->act_cookie);
 +		}
 +		p->act_cookie = cookie;
 +	}
 +
  	/* module count goes up only when brand new policy is created
  	 * if it exists and is only bound to in a_o->init() then
  	 * ACT_P_CREATED is not returned (a zero is).
@@@ -797,24 -723,11 +865,30 @@@ act_get_notify(struct net *net, u32 por
  	return rtnl_unicast(skb, net, portid);
  }
  
++<<<<<<< HEAD
 +static struct tc_action *create_a(int i)
 +{
 +	struct tc_action *act;
 +
 +	act = kzalloc(sizeof(*act), GFP_KERNEL);
 +	if (act == NULL) {
 +		pr_debug("create_a: failed to alloc!\n");
 +		return NULL;
 +	}
 +	act->order = i;
 +	INIT_LIST_HEAD(&act->list);
 +	return act;
 +}
 +
 +static struct tc_action *
 +tcf_action_get_1(struct nlattr *nla, struct nlmsghdr *n, u32 portid)
++=======
+ static struct tc_action *tcf_action_get_1(struct net *net, struct nlattr *nla,
+ 					  struct nlmsghdr *n, u32 portid)
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  {
  	struct nlattr *tb[TCA_ACT_MAX + 1];
+ 	const struct tc_action_ops *ops;
  	struct tc_action *a;
  	int index;
  	int err;
@@@ -829,20 -742,15 +903,19 @@@
  		goto err_out;
  	index = nla_get_u32(tb[TCA_ACT_INDEX]);
  
- 	err = -ENOMEM;
- 	a = create_a(0);
- 	if (a == NULL)
- 		goto err_out;
- 
  	err = -EINVAL;
- 	a->ops = tc_lookup_action(tb[TCA_ACT_KIND]);
- 	if (a->ops == NULL) /* could happen in batch of actions */
- 		goto err_free;
+ 	ops = tc_lookup_action(tb[TCA_ACT_KIND]);
+ 	if (!ops) /* could happen in batch of actions */
+ 		goto err_out;
  	err = -ENOENT;
++<<<<<<< HEAD
 +	if (a->ops->lookup(a, index) == 0)
++=======
+ 	if (ops->lookup(net, &a, index) == 0)
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  		goto err_mod;
  
- 	module_put(a->ops->owner);
+ 	module_put(ops->owner);
  	return a;
  
  err_mod:
@@@ -910,7 -814,7 +979,11 @@@ static int tca_action_flush(struct net 
  	if (nest == NULL)
  		goto out_module_put;
  
++<<<<<<< HEAD
 +	err = a.ops->walk(skb, &dcb, RTM_DELACTION, &a);
++=======
+ 	err = ops->walk(net, skb, &dcb, RTM_DELACTION, ops);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  	if (err < 0)
  		goto out_module_put;
  	if (err == 0)
@@@ -1167,7 -1071,7 +1236,11 @@@ static int tc_dump_action(struct sk_buf
  	if (nest == NULL)
  		goto out_module_put;
  
++<<<<<<< HEAD
 +	ret = a_o->walk(skb, cb, RTM_GETACTION, &a);
++=======
+ 	ret = a_o->walk(net, skb, cb, RTM_GETACTION, a_o);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  	if (ret < 0)
  		goto out_module_put;
  
diff --cc net/sched/act_csum.c
index 673fbbada19b,b5dbf633a863..000000000000
--- a/net/sched/act_csum.c
+++ b/net/sched/act_csum.c
@@@ -42,9 -42,14 +42,18 @@@ static const struct nla_policy csum_pol
  	[TCA_CSUM_PARMS] = { .len = sizeof(struct tc_csum), },
  };
  
++<<<<<<< HEAD
 +static int tcf_csum_init(struct net *n, struct nlattr *nla, struct nlattr *est,
 +			 struct tc_action *a, int ovr, int bind)
++=======
+ static int csum_net_id;
+ static struct tc_action_ops act_csum_ops;
+ 
+ static int tcf_csum_init(struct net *net, struct nlattr *nla,
+ 			 struct nlattr *est, struct tc_action **a, int ovr,
+ 			 int bind)
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  {
 -	struct tc_action_net *tn = net_generic(net, csum_net_id);
  	struct nlattr *tb[TCA_CSUM_MAX + 1];
  	struct tc_csum *parm;
  	struct tcf_csum *p;
@@@ -61,9 -66,9 +70,15 @@@
  		return -EINVAL;
  	parm = nla_data(tb[TCA_CSUM_PARMS]);
  
++<<<<<<< HEAD
 +	if (!tcf_hash_check(parm->index, a, bind)) {
 +		ret = tcf_hash_create(parm->index, est, a, sizeof(*p),
 +				      bind, false);
++=======
+ 	if (!tcf_hash_check(tn, parm->index, a, bind)) {
+ 		ret = tcf_hash_create(tn, parm->index, est, a,
+ 				      &act_csum_ops, bind, false);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  		if (ret)
  			return ret;
  		ret = ACT_P_CREATED;
@@@ -82,7 -87,7 +97,11 @@@
  	spin_unlock_bh(&p->tcf_lock);
  
  	if (ret == ACT_P_CREATED)
++<<<<<<< HEAD
 +		tcf_hash_insert(a);
++=======
+ 		tcf_hash_insert(tn, *a);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  
  	return ret;
  }
@@@ -493,10 -494,10 +512,10 @@@ fail
  	return 0;
  }
  
 -static int tcf_csum(struct sk_buff *skb,
 -		    const struct tc_action *a, struct tcf_result *res)
 +static int tcf_csum(struct sk_buff *skb, const struct tc_action *a,
 +		    struct tcf_result *res)
  {
- 	struct tcf_csum *p = a->priv;
+ 	struct tcf_csum *p = to_tcf_csum(a);
  	int action;
  	u32 update_flags;
  
@@@ -530,11 -531,11 +549,11 @@@ drop
  	return TC_ACT_SHOT;
  }
  
 -static int tcf_csum_dump(struct sk_buff *skb,
 -			 struct tc_action *a, int bind, int ref)
 +static int tcf_csum_dump(struct sk_buff *skb, struct tc_action *a, int bind,
 +			 int ref)
  {
  	unsigned char *b = skb_tail_pointer(skb);
- 	struct tcf_csum *p = a->priv;
+ 	struct tcf_csum *p = to_tcf_csum(a);
  	struct tc_csum opt = {
  		.update_flags = p->update_flags,
  		.index   = p->tcf_index,
@@@ -558,6 -559,22 +577,25 @@@ nla_put_failure
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ static int tcf_csum_walker(struct net *net, struct sk_buff *skb,
+ 			   struct netlink_callback *cb, int type,
+ 			   const struct tc_action_ops *ops)
+ {
+ 	struct tc_action_net *tn = net_generic(net, csum_net_id);
+ 
+ 	return tcf_generic_walker(tn, skb, cb, type, ops);
+ }
+ 
+ static int tcf_csum_search(struct net *net, struct tc_action **a, u32 index)
+ {
+ 	struct tc_action_net *tn = net_generic(net, csum_net_id);
+ 
+ 	return tcf_hash_search(tn, a, index);
+ }
+ 
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  static struct tc_action_ops act_csum_ops = {
  	.kind		= "csum",
  	.type		= TCA_ACT_CSUM,
@@@ -565,6 -582,30 +603,33 @@@
  	.act		= tcf_csum,
  	.dump		= tcf_csum_dump,
  	.init		= tcf_csum_init,
++<<<<<<< HEAD
++=======
+ 	.walk		= tcf_csum_walker,
+ 	.lookup		= tcf_csum_search,
+ 	.size		= sizeof(struct tcf_csum),
+ };
+ 
+ static __net_init int csum_init_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, csum_net_id);
+ 
+ 	return tc_action_net_init(tn, &act_csum_ops, CSUM_TAB_MASK);
+ }
+ 
+ static void __net_exit csum_exit_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, csum_net_id);
+ 
+ 	tc_action_net_exit(tn);
+ }
+ 
+ static struct pernet_operations csum_net_ops = {
+ 	.init = csum_init_net,
+ 	.exit = csum_exit_net,
+ 	.id   = &csum_net_id,
+ 	.size = sizeof(struct tc_action_net),
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  };
  
  MODULE_DESCRIPTION("Checksum updating actions");
diff --cc net/sched/act_gact.c
index 8f8ca0c64f9d,e24a4093d6f6..000000000000
--- a/net/sched/act_gact.c
+++ b/net/sched/act_gact.c
@@@ -25,6 -25,9 +25,12 @@@
  
  #define GACT_TAB_MASK	15
  
++<<<<<<< HEAD
++=======
+ static int gact_net_id;
+ static struct tc_action_ops act_gact_ops;
+ 
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  #ifdef CONFIG_GACT_PROB
  static int gact_net_rand(struct tcf_gact *gact)
  {
@@@ -54,9 -57,10 +60,9 @@@ static const struct nla_policy gact_pol
  };
  
  static int tcf_gact_init(struct net *net, struct nlattr *nla,
- 			 struct nlattr *est, struct tc_action *a,
+ 			 struct nlattr *est, struct tc_action **a,
  			 int ovr, int bind)
  {
 -	struct tc_action_net *tn = net_generic(net, gact_net_id);
  	struct nlattr *tb[TCA_GACT_MAX + 1];
  	struct tc_gact *parm;
  	struct tcf_gact *gact;
@@@ -88,9 -92,9 +94,15 @@@
  	}
  #endif
  
++<<<<<<< HEAD
 +	if (!tcf_hash_check(parm->index, a, bind)) {
 +		ret = tcf_hash_create(parm->index, est, a, sizeof(*gact),
 +				      bind, true);
++=======
+ 	if (!tcf_hash_check(tn, parm->index, a, bind)) {
+ 		ret = tcf_hash_create(tn, parm->index, est, a,
+ 				      &act_gact_ops, bind, true);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  		if (ret)
  			return ret;
  		ret = ACT_P_CREATED;
@@@ -118,7 -122,7 +130,11 @@@
  	}
  #endif
  	if (ret == ACT_P_CREATED)
++<<<<<<< HEAD
 +		tcf_hash_insert(a);
++=======
+ 		tcf_hash_insert(tn, *a);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  	return ret;
  }
  
@@@ -197,6 -200,22 +213,25 @@@ nla_put_failure
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ static int tcf_gact_walker(struct net *net, struct sk_buff *skb,
+ 			   struct netlink_callback *cb, int type,
+ 			   const struct tc_action_ops *ops)
+ {
+ 	struct tc_action_net *tn = net_generic(net, gact_net_id);
+ 
+ 	return tcf_generic_walker(tn, skb, cb, type, ops);
+ }
+ 
+ static int tcf_gact_search(struct net *net, struct tc_action **a, u32 index)
+ {
+ 	struct tc_action_net *tn = net_generic(net, gact_net_id);
+ 
+ 	return tcf_hash_search(tn, a, index);
+ }
+ 
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  static struct tc_action_ops act_gact_ops = {
  	.kind		=	"gact",
  	.type		=	TCA_ACT_GACT,
@@@ -205,6 -224,30 +240,33 @@@
  	.stats_update	=	tcf_gact_stats_update,
  	.dump		=	tcf_gact_dump,
  	.init		=	tcf_gact_init,
++<<<<<<< HEAD
++=======
+ 	.walk		=	tcf_gact_walker,
+ 	.lookup		=	tcf_gact_search,
+ 	.size		=	sizeof(struct tcf_gact),
+ };
+ 
+ static __net_init int gact_init_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, gact_net_id);
+ 
+ 	return tc_action_net_init(tn, &act_gact_ops, GACT_TAB_MASK);
+ }
+ 
+ static void __net_exit gact_exit_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, gact_net_id);
+ 
+ 	tc_action_net_exit(tn);
+ }
+ 
+ static struct pernet_operations gact_net_ops = {
+ 	.init = gact_init_net,
+ 	.exit = gact_exit_net,
+ 	.id   = &gact_net_id,
+ 	.size = sizeof(struct tc_action_net),
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  };
  
  MODULE_AUTHOR("Jamal Hadi Salim(2002-4)");
diff --cc net/sched/act_ipt.c
index 014563af32c0,378c1c976058..000000000000
--- a/net/sched/act_ipt.c
+++ b/net/sched/act_ipt.c
@@@ -30,6 -30,12 +30,15 @@@
  
  #define IPT_TAB_MASK     15
  
++<<<<<<< HEAD
++=======
+ static int ipt_net_id;
+ static struct tc_action_ops act_ipt_ops;
+ 
+ static int xt_net_id;
+ static struct tc_action_ops act_xt_ops;
+ 
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  static int ipt_init_target(struct xt_entry_target *t, char *table,
  			   unsigned int hook)
  {
@@@ -85,8 -91,9 +94,14 @@@ static const struct nla_policy ipt_poli
  	[TCA_IPT_TARG]	= { .len = sizeof(struct xt_entry_target) },
  };
  
++<<<<<<< HEAD
 +static int tcf_ipt_init(struct net *net, struct nlattr *nla, struct nlattr *est,
 +			struct tc_action *a, int ovr, int bind)
++=======
+ static int __tcf_ipt_init(struct tc_action_net *tn, struct nlattr *nla,
+ 			  struct nlattr *est, struct tc_action **a,
+ 			  const struct tc_action_ops *ops, int ovr, int bind)
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  {
  	struct nlattr *tb[TCA_IPT_MAX + 1];
  	struct tcf_ipt *ipt;
@@@ -115,8 -114,26 +130,31 @@@
  	if (tb[TCA_IPT_INDEX] != NULL)
  		index = nla_get_u32(tb[TCA_IPT_INDEX]);
  
++<<<<<<< HEAD
 +	if (!tcf_hash_check(index, a, bind) ) {
 +		ret = tcf_hash_create(index, est, a, sizeof(*ipt), bind, false);
++=======
+ 	exists = tcf_hash_check(tn, index, a, bind);
+ 	if (exists && bind)
+ 		return 0;
+ 
+ 	if (tb[TCA_IPT_HOOK] == NULL || tb[TCA_IPT_TARG] == NULL) {
+ 		if (exists)
+ 			tcf_hash_release(*a, bind);
+ 		return -EINVAL;
+ 	}
+ 
+ 	td = (struct xt_entry_target *)nla_data(tb[TCA_IPT_TARG]);
+ 	if (nla_len(tb[TCA_IPT_TARG]) < td->u.target_size) {
+ 		if (exists)
+ 			tcf_hash_release(*a, bind);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!exists) {
+ 		ret = tcf_hash_create(tn, index, est, a, ops, bind,
+ 				      false);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  		if (ret)
  			return ret;
  		ret = ACT_P_CREATED;
@@@ -159,7 -176,7 +197,11 @@@
  	ipt->tcfi_hook  = hook;
  	spin_unlock_bh(&ipt->tcf_lock);
  	if (ret == ACT_P_CREATED)
++<<<<<<< HEAD
 +		tcf_hash_insert(a);
++=======
+ 		tcf_hash_insert(tn, *a);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  	return ret;
  
  err3:
@@@ -172,6 -189,24 +214,27 @@@ err1
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int tcf_ipt_init(struct net *net, struct nlattr *nla,
+ 			struct nlattr *est, struct tc_action **a, int ovr,
+ 			int bind)
+ {
+ 	struct tc_action_net *tn = net_generic(net, ipt_net_id);
+ 
+ 	return __tcf_ipt_init(tn, nla, est, a, &act_ipt_ops, ovr, bind);
+ }
+ 
+ static int tcf_xt_init(struct net *net, struct nlattr *nla,
+ 		       struct nlattr *est, struct tc_action **a, int ovr,
+ 		       int bind)
+ {
+ 	struct tc_action_net *tn = net_generic(net, xt_net_id);
+ 
+ 	return __tcf_ipt_init(tn, nla, est, a, &act_xt_ops, ovr, bind);
+ }
+ 
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  static int tcf_ipt(struct sk_buff *skb, const struct tc_action *a,
  		   struct tcf_result *res)
  {
@@@ -263,6 -299,22 +326,25 @@@ nla_put_failure
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ static int tcf_ipt_walker(struct net *net, struct sk_buff *skb,
+ 			  struct netlink_callback *cb, int type,
+ 			  const struct tc_action_ops *ops)
+ {
+ 	struct tc_action_net *tn = net_generic(net, ipt_net_id);
+ 
+ 	return tcf_generic_walker(tn, skb, cb, type, ops);
+ }
+ 
+ static int tcf_ipt_search(struct net *net, struct tc_action **a, u32 index)
+ {
+ 	struct tc_action_net *tn = net_generic(net, ipt_net_id);
+ 
+ 	return tcf_hash_search(tn, a, index);
+ }
+ 
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  static struct tc_action_ops act_ipt_ops = {
  	.kind		=	"ipt",
  	.type		=	TCA_ACT_IPT,
@@@ -271,16 -323,80 +353,89 @@@
  	.dump		=	tcf_ipt_dump,
  	.cleanup	=	tcf_ipt_release,
  	.init		=	tcf_ipt_init,
++<<<<<<< HEAD
 +};
 +
++=======
+ 	.walk		=	tcf_ipt_walker,
+ 	.lookup		=	tcf_ipt_search,
+ 	.size		=	sizeof(struct tcf_ipt),
+ };
+ 
+ static __net_init int ipt_init_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, ipt_net_id);
+ 
+ 	return tc_action_net_init(tn, &act_ipt_ops, IPT_TAB_MASK);
+ }
+ 
+ static void __net_exit ipt_exit_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, ipt_net_id);
+ 
+ 	tc_action_net_exit(tn);
+ }
+ 
+ static struct pernet_operations ipt_net_ops = {
+ 	.init = ipt_init_net,
+ 	.exit = ipt_exit_net,
+ 	.id   = &ipt_net_id,
+ 	.size = sizeof(struct tc_action_net),
+ };
+ 
+ static int tcf_xt_walker(struct net *net, struct sk_buff *skb,
+ 			 struct netlink_callback *cb, int type,
+ 			 const struct tc_action_ops *ops)
+ {
+ 	struct tc_action_net *tn = net_generic(net, xt_net_id);
+ 
+ 	return tcf_generic_walker(tn, skb, cb, type, ops);
+ }
+ 
+ static int tcf_xt_search(struct net *net, struct tc_action **a, u32 index)
+ {
+ 	struct tc_action_net *tn = net_generic(net, xt_net_id);
+ 
+ 	return tcf_hash_search(tn, a, index);
+ }
+ 
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  static struct tc_action_ops act_xt_ops = {
  	.kind		=	"xt",
 -	.type		=	TCA_ACT_XT,
 +	.type		=	TCA_ACT_IPT,
  	.owner		=	THIS_MODULE,
  	.act		=	tcf_ipt,
  	.dump		=	tcf_ipt_dump,
  	.cleanup	=	tcf_ipt_release,
++<<<<<<< HEAD
 +	.init		=	tcf_ipt_init,
++=======
+ 	.init		=	tcf_xt_init,
+ 	.walk		=	tcf_xt_walker,
+ 	.lookup		=	tcf_xt_search,
+ 	.size		=	sizeof(struct tcf_ipt),
+ };
+ 
+ static __net_init int xt_init_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, xt_net_id);
+ 
+ 	return tc_action_net_init(tn, &act_xt_ops, IPT_TAB_MASK);
+ }
+ 
+ static void __net_exit xt_exit_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, xt_net_id);
+ 
+ 	tc_action_net_exit(tn);
+ }
+ 
+ static struct pernet_operations xt_net_ops = {
+ 	.init = xt_init_net,
+ 	.exit = xt_exit_net,
+ 	.id   = &xt_net_id,
+ 	.size = sizeof(struct tc_action_net),
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  };
  
  MODULE_AUTHOR("Jamal Hadi Salim(2002-13)");
diff --cc net/sched/act_mirred.c
index 80554d23769d,6038c85d92f5..000000000000
--- a/net/sched/act_mirred.c
+++ b/net/sched/act_mirred.c
@@@ -51,10 -51,14 +51,16 @@@ static const struct nla_policy mirred_p
  	[TCA_MIRRED_PARMS]	= { .len = sizeof(struct tc_mirred) },
  };
  
++<<<<<<< HEAD
++=======
+ static int mirred_net_id;
+ static struct tc_action_ops act_mirred_ops;
+ 
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  static int tcf_mirred_init(struct net *net, struct nlattr *nla,
- 			   struct nlattr *est, struct tc_action *a, int ovr,
+ 			   struct nlattr *est, struct tc_action **a, int ovr,
  			   int bind)
  {
 -	struct tc_action_net *tn = net_generic(net, mirred_net_id);
  	struct nlattr *tb[TCA_MIRRED_MAX + 1];
  	struct tc_mirred *parm;
  	struct tcf_mirred *m;
@@@ -74,12 -84,17 +80,23 @@@
  	case TCA_EGRESS_REDIR:
  		break;
  	default:
++<<<<<<< HEAD
++=======
+ 		if (exists)
+ 			tcf_hash_release(*a, bind);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  		return -EINVAL;
  	}
  	if (parm->ifindex) {
  		dev = __dev_get_by_index(net, parm->ifindex);
++<<<<<<< HEAD
 +		if (dev == NULL)
++=======
+ 		if (dev == NULL) {
+ 			if (exists)
+ 				tcf_hash_release(*a, bind);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  			return -ENODEV;
 -		}
  		switch (dev->type) {
  		case ARPHRD_TUNNEL:
  		case ARPHRD_TUNNEL6:
@@@ -97,19 -112,16 +114,28 @@@
  		dev = NULL;
  	}
  
 -	if (!exists) {
 +	if (!tcf_hash_check(parm->index, a, bind)) {
  		if (dev == NULL)
  			return -EINVAL;
++<<<<<<< HEAD
 +		ret = tcf_hash_create(parm->index, est, a, sizeof(*m),
 +				      bind, true);
++=======
+ 		ret = tcf_hash_create(tn, parm->index, est, a,
+ 				      &act_mirred_ops, bind, true);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  		if (ret)
  			return ret;
  		ret = ACT_P_CREATED;
  	} else {
++<<<<<<< HEAD
 +		if (bind)
 +			return 0;
 +
 +		tcf_hash_release(a, bind);
++=======
+ 		tcf_hash_release(*a, bind);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  		if (!ovr)
  			return -EEXIST;
  	}
@@@ -131,7 -143,7 +157,11 @@@
  		spin_lock_bh(&mirred_list_lock);
  		list_add(&m->tcfm_list, &mirred_list);
  		spin_unlock_bh(&mirred_list_lock);
++<<<<<<< HEAD
 +		tcf_hash_insert(a);
++=======
+ 		tcf_hash_insert(tn, *a);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  	}
  
  	return ret;
@@@ -192,21 -204,10 +222,21 @@@ out
  	return retval;
  }
  
 -static int tcf_mirred_dump(struct sk_buff *skb, struct tc_action *a, int bind, int ref)
 +static void tcf_stats_update(struct tc_action *a, u64 bytes, u32 packets,
 +			     u64 lastuse)
 +{
 +	struct tcf_mirred *m = to_mirred(a);
 +	struct tcf_t *tm = &m->tcf_tm;
 +
 +	_bstats_cpu_update(this_cpu_ptr(m->common.cpu_bstats), bytes, packets);
 +	tm->lastuse = lastuse;
 +}
 +
 +static int tcf_mirred_dump(struct sk_buff *skb, struct tc_action *a, int bind,
 +			   int ref)
  {
  	unsigned char *b = skb_tail_pointer(skb);
- 	struct tcf_mirred *m = a->priv;
+ 	struct tcf_mirred *m = to_mirred(a);
  	struct tc_mirred opt = {
  		.index   = m->tcf_index,
  		.action  = m->tcf_action,
@@@ -230,6 -231,22 +260,25 @@@ nla_put_failure
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ static int tcf_mirred_walker(struct net *net, struct sk_buff *skb,
+ 			     struct netlink_callback *cb, int type,
+ 			     const struct tc_action_ops *ops)
+ {
+ 	struct tc_action_net *tn = net_generic(net, mirred_net_id);
+ 
+ 	return tcf_generic_walker(tn, skb, cb, type, ops);
+ }
+ 
+ static int tcf_mirred_search(struct net *net, struct tc_action **a, u32 index)
+ {
+ 	struct tc_action_net *tn = net_generic(net, mirred_net_id);
+ 
+ 	return tcf_hash_search(tn, a, index);
+ }
+ 
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  static int mirred_device_event(struct notifier_block *unused,
  			       unsigned long event, void *ptr)
  {
@@@ -278,7 -283,30 +327,34 @@@ static struct tc_action_ops act_mirred_
  	.dump		=	tcf_mirred_dump,
  	.cleanup	=	tcf_mirred_release,
  	.init		=	tcf_mirred_init,
++<<<<<<< HEAD
 +	.get_dev	=	tcf_mirred_device,
++=======
+ 	.walk		=	tcf_mirred_walker,
+ 	.lookup		=	tcf_mirred_search,
+ 	.size		=	sizeof(struct tcf_mirred),
+ };
+ 
+ static __net_init int mirred_init_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, mirred_net_id);
+ 
+ 	return tc_action_net_init(tn, &act_mirred_ops, MIRRED_TAB_MASK);
+ }
+ 
+ static void __net_exit mirred_exit_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, mirred_net_id);
+ 
+ 	tc_action_net_exit(tn);
+ }
+ 
+ static struct pernet_operations mirred_net_ops = {
+ 	.init = mirred_init_net,
+ 	.exit = mirred_exit_net,
+ 	.id   = &mirred_net_id,
+ 	.size = sizeof(struct tc_action_net),
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  };
  
  MODULE_AUTHOR("Jamal Hadi Salim(2002)");
diff --cc net/sched/act_nat.c
index 5ddce5b1ccf3,8e8b0cc30704..000000000000
--- a/net/sched/act_nat.c
+++ b/net/sched/act_nat.c
@@@ -31,13 -31,17 +31,19 @@@
  
  #define NAT_TAB_MASK	15
  
++<<<<<<< HEAD
++=======
+ static int nat_net_id;
+ static struct tc_action_ops act_nat_ops;
+ 
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  static const struct nla_policy nat_policy[TCA_NAT_MAX + 1] = {
  	[TCA_NAT_PARMS]	= { .len = sizeof(struct tc_nat) },
  };
  
  static int tcf_nat_init(struct net *net, struct nlattr *nla, struct nlattr *est,
- 			struct tc_action *a, int ovr, int bind)
+ 			struct tc_action **a, int ovr, int bind)
  {
 -	struct tc_action_net *tn = net_generic(net, nat_net_id);
  	struct nlattr *tb[TCA_NAT_MAX + 1];
  	struct tc_nat *parm;
  	int ret = 0, err;
@@@ -54,9 -58,9 +60,15 @@@
  		return -EINVAL;
  	parm = nla_data(tb[TCA_NAT_PARMS]);
  
++<<<<<<< HEAD
 +	if (!tcf_hash_check(parm->index, a, bind)) {
 +		ret = tcf_hash_create(parm->index, est, a, sizeof(*p),
 +				      bind, false);
++=======
+ 	if (!tcf_hash_check(tn, parm->index, a, bind)) {
+ 		ret = tcf_hash_create(tn, parm->index, est, a,
+ 				      &act_nat_ops, bind, false);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  		if (ret)
  			return ret;
  		ret = ACT_P_CREATED;
@@@ -79,7 -83,7 +91,11 @@@
  	spin_unlock_bh(&p->tcf_lock);
  
  	if (ret == ACT_P_CREATED)
++<<<<<<< HEAD
 +		tcf_hash_insert(a);
++=======
+ 		tcf_hash_insert(tn, *a);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  
  	return ret;
  }
@@@ -280,6 -277,22 +296,25 @@@ nla_put_failure
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ static int tcf_nat_walker(struct net *net, struct sk_buff *skb,
+ 			  struct netlink_callback *cb, int type,
+ 			  const struct tc_action_ops *ops)
+ {
+ 	struct tc_action_net *tn = net_generic(net, nat_net_id);
+ 
+ 	return tcf_generic_walker(tn, skb, cb, type, ops);
+ }
+ 
+ static int tcf_nat_search(struct net *net, struct tc_action **a, u32 index)
+ {
+ 	struct tc_action_net *tn = net_generic(net, nat_net_id);
+ 
+ 	return tcf_hash_search(tn, a, index);
+ }
+ 
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  static struct tc_action_ops act_nat_ops = {
  	.kind		=	"nat",
  	.type		=	TCA_ACT_NAT,
@@@ -287,6 -300,30 +322,33 @@@
  	.act		=	tcf_nat,
  	.dump		=	tcf_nat_dump,
  	.init		=	tcf_nat_init,
++<<<<<<< HEAD
++=======
+ 	.walk		=	tcf_nat_walker,
+ 	.lookup		=	tcf_nat_search,
+ 	.size		=	sizeof(struct tcf_nat),
+ };
+ 
+ static __net_init int nat_init_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, nat_net_id);
+ 
+ 	return tc_action_net_init(tn, &act_nat_ops, NAT_TAB_MASK);
+ }
+ 
+ static void __net_exit nat_exit_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, nat_net_id);
+ 
+ 	tc_action_net_exit(tn);
+ }
+ 
+ static struct pernet_operations nat_net_ops = {
+ 	.init = nat_init_net,
+ 	.exit = nat_exit_net,
+ 	.id   = &nat_net_id,
+ 	.size = sizeof(struct tc_action_net),
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  };
  
  MODULE_DESCRIPTION("Stateless NAT actions");
diff --cc net/sched/act_pedit.c
index a1ad5b3f443d,b54d56d4959b..000000000000
--- a/net/sched/act_pedit.c
+++ b/net/sched/act_pedit.c
@@@ -25,14 -25,18 +25,20 @@@
  
  #define PEDIT_TAB_MASK	15
  
++<<<<<<< HEAD
++=======
+ static int pedit_net_id;
+ static struct tc_action_ops act_pedit_ops;
+ 
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  static const struct nla_policy pedit_policy[TCA_PEDIT_MAX + 1] = {
  	[TCA_PEDIT_PARMS]	= { .len = sizeof(struct tc_pedit) },
  };
  
  static int tcf_pedit_init(struct net *net, struct nlattr *nla,
- 			  struct nlattr *est, struct tc_action *a,
+ 			  struct nlattr *est, struct tc_action **a,
  			  int ovr, int bind)
  {
 -	struct tc_action_net *tn = net_generic(net, pedit_net_id);
  	struct nlattr *tb[TCA_PEDIT_MAX + 1];
  	struct tc_pedit *parm;
  	int ret = 0, err;
@@@ -54,17 -58,17 +60,22 @@@
  	if (nla_len(tb[TCA_PEDIT_PARMS]) < sizeof(*parm) + ksize)
  		return -EINVAL;
  
 -	if (!tcf_hash_check(tn, parm->index, a, bind)) {
 +	if (!tcf_hash_check(parm->index, a, bind)) {
  		if (!parm->nkeys)
  			return -EINVAL;
++<<<<<<< HEAD
 +		ret = tcf_hash_create(parm->index, est, a, sizeof(*p),
 +				      bind, false);
++=======
+ 		ret = tcf_hash_create(tn, parm->index, est, a,
+ 				      &act_pedit_ops, bind, false);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  		if (ret)
  			return ret;
- 		p = to_pedit(a);
+ 		p = to_pedit(*a);
  		keys = kmalloc(ksize, GFP_KERNEL);
  		if (keys == NULL) {
- 			tcf_hash_cleanup(a, est);
+ 			tcf_hash_cleanup(*a, est);
  			return -ENOMEM;
  		}
  		ret = ACT_P_CREATED;
@@@ -93,7 -97,7 +104,11 @@@
  	memcpy(p->tcfp_keys, parm->keys, ksize);
  	spin_unlock_bh(&p->tcf_lock);
  	if (ret == ACT_P_CREATED)
++<<<<<<< HEAD
 +		tcf_hash_insert(a);
++=======
+ 		tcf_hash_insert(tn, *a);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  	return ret;
  }
  
@@@ -211,6 -215,22 +226,25 @@@ nla_put_failure
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ static int tcf_pedit_walker(struct net *net, struct sk_buff *skb,
+ 			    struct netlink_callback *cb, int type,
+ 			    const struct tc_action_ops *ops)
+ {
+ 	struct tc_action_net *tn = net_generic(net, pedit_net_id);
+ 
+ 	return tcf_generic_walker(tn, skb, cb, type, ops);
+ }
+ 
+ static int tcf_pedit_search(struct net *net, struct tc_action **a, u32 index)
+ {
+ 	struct tc_action_net *tn = net_generic(net, pedit_net_id);
+ 
+ 	return tcf_hash_search(tn, a, index);
+ }
+ 
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  static struct tc_action_ops act_pedit_ops = {
  	.kind		=	"pedit",
  	.type		=	TCA_ACT_PEDIT,
@@@ -219,6 -239,30 +253,33 @@@
  	.dump		=	tcf_pedit_dump,
  	.cleanup	=	tcf_pedit_cleanup,
  	.init		=	tcf_pedit_init,
++<<<<<<< HEAD
++=======
+ 	.walk		=	tcf_pedit_walker,
+ 	.lookup		=	tcf_pedit_search,
+ 	.size		=	sizeof(struct tcf_pedit),
+ };
+ 
+ static __net_init int pedit_init_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, pedit_net_id);
+ 
+ 	return tc_action_net_init(tn, &act_pedit_ops, PEDIT_TAB_MASK);
+ }
+ 
+ static void __net_exit pedit_exit_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, pedit_net_id);
+ 
+ 	tc_action_net_exit(tn);
+ }
+ 
+ static struct pernet_operations pedit_net_ops = {
+ 	.init = pedit_init_net,
+ 	.exit = pedit_exit_net,
+ 	.id   = &pedit_net_id,
+ 	.size = sizeof(struct tc_action_net),
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  };
  
  MODULE_AUTHOR("Jamal Hadi Salim(2002-4)");
diff --cc net/sched/act_police.c
index 8a7c279e7b2c,123794af55c3..000000000000
--- a/net/sched/act_police.c
+++ b/net/sched/act_police.c
@@@ -37,8 -37,8 +37,13 @@@ struct tcf_police 
  	struct psched_ratecfg	peak;
  	bool			peak_present;
  };
++<<<<<<< HEAD
 +#define to_police(pc)	\
 +	container_of(pc, struct tcf_police, common)
++=======
+ 
+ #define to_police(pc) ((struct tcf_police *)pc)
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  
  #define POL_TAB_MASK     15
  
@@@ -55,12 -55,15 +60,24 @@@ struct tc_police_compat 
  
  /* Each policer is serialized by its individual spinlock */
  
++<<<<<<< HEAD
 +static int tcf_act_police_walker(struct sk_buff *skb, struct netlink_callback *cb,
 +			      int type, struct tc_action *a)
 +{
 +	struct tcf_hashinfo *hinfo = a->ops->hinfo;
 +	struct hlist_head *head;
 +	struct tcf_common *p;
++=======
+ static int police_net_id;
+ static struct tc_action_ops act_police_ops;
+ 
+ static int tcf_act_police_walker(struct net *net, struct sk_buff *skb,
+ 				 struct netlink_callback *cb, int type,
+ 				 const struct tc_action_ops *ops)
+ {
+ 	struct tc_action_net *tn = net_generic(net, police_net_id);
+ 	struct tcf_hashinfo *hinfo = tn->hinfo;
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  	int err = 0, index = -1, i = 0, s_i = 0, n_i = 0;
  	struct nlattr *nest;
  
@@@ -111,11 -115,10 +129,17 @@@ static const struct nla_policy police_p
  	[TCA_POLICE_RESULT]	= { .type = NLA_U32 },
  };
  
++<<<<<<< HEAD
 +static int tcf_act_police_locate(struct net *net, struct nlattr *nla,
 +				 struct nlattr *est, struct tc_action *a,
 +				 int ovr, int bind)
++=======
+ static int tcf_act_police_init(struct net *net, struct nlattr *nla,
+ 			       struct nlattr *est, struct tc_action **a,
+ 			       int ovr, int bind)
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  {
 +	unsigned int h;
  	int ret = 0, err;
  	struct nlattr *tb[TCA_POLICE_MAX + 1];
  	struct tc_police *parm;
@@@ -139,29 -142,22 +163,45 @@@
  	parm = nla_data(tb[TCA_POLICE_TBF]);
  
  	if (parm->index) {
++<<<<<<< HEAD
 +		if (tcf_hash_search(a, parm->index)) {
 +			police = to_police(a->priv);
 +			if (bind) {
 +				police->tcf_bindcnt += 1;
 +				police->tcf_refcnt += 1;
 +				return 0;
 +			}
++=======
+ 		if (tcf_hash_check(tn, parm->index, a, bind)) {
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  			if (ovr)
  				goto override;
  			/* not replacing */
  			return -EEXIST;
  		}
++<<<<<<< HEAD
 +	}
 +
 +	police = kzalloc(sizeof(*police), GFP_KERNEL);
 +	if (police == NULL)
 +		return -ENOMEM;
 +	ret = ACT_P_CREATED;
 +	police->tcf_refcnt = 1;
 +	spin_lock_init(&police->tcf_lock);
 +	if (bind)
 +		police->tcf_bindcnt = 1;
++=======
+ 	} else {
+ 		ret = tcf_hash_create(tn, parm->index, NULL, a,
+ 				      &act_police_ops, bind, false);
+ 		if (ret)
+ 			return ret;
+ 		ret = ACT_P_CREATED;
+ 	}
+ 
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  override:
+ 	police = to_police(*a);
  	if (parm->rate.rate) {
  		err = -ENOMEM;
  		R_tab = qdisc_get_rtab(&parm->rate, tb[TCA_POLICE_RATE]);
@@@ -233,17 -229,8 +273,21 @@@
  		return ret;
  
  	police->tcfp_t_c = ktime_get_ns();
++<<<<<<< HEAD
 +	police->tcf_index = parm->index ? parm->index :
 +		tcf_hash_new_index(hinfo);
 +	police->tcf_tm.install = jiffies;
 +	police->tcf_tm.lastuse = jiffies;
 +	police->tcf_tm.firstuse = 0;
 +	h = tcf_hash(police->tcf_index, POL_TAB_MASK);
 +	spin_lock_bh(&hinfo->lock);
 +	hlist_add_head(&police->tcf_head, &hinfo->htab[h]);
 +	spin_unlock_bh(&hinfo->lock);
++=======
+ 	tcf_hash_insert(tn, *a);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  
 +	a->priv = police;
  	return ret;
  
  failure_unlock:
@@@ -252,7 -239,7 +296,11 @@@ failure
  	qdisc_put_rtab(P_tab);
  	qdisc_put_rtab(R_tab);
  	if (ret == ACT_P_CREATED)
++<<<<<<< HEAD
 +		kfree(police);
++=======
+ 		tcf_hash_cleanup(*a, est);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  	return err;
  }
  
@@@ -314,11 -301,11 +362,11 @@@ static int tcf_act_police(struct sk_buf
  	return police->tcf_action;
  }
  
 -static int
 -tcf_act_police_dump(struct sk_buff *skb, struct tc_action *a, int bind, int ref)
 +static int tcf_act_police_dump(struct sk_buff *skb, struct tc_action *a,
 +			       int bind, int ref)
  {
  	unsigned char *b = skb_tail_pointer(skb);
- 	struct tcf_police *police = a->priv;
+ 	struct tcf_police *police = to_police(a);
  	struct tc_police opt = {
  		.index = police->tcf_index,
  		.action = police->tcf_action,
@@@ -356,6 -343,13 +404,16 @@@ nla_put_failure
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ static int tcf_police_search(struct net *net, struct tc_action **a, u32 index)
+ {
+ 	struct tc_action_net *tn = net_generic(net, police_net_id);
+ 
+ 	return tcf_hash_search(tn, a, index);
+ }
+ 
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  MODULE_AUTHOR("Alexey Kuznetsov");
  MODULE_DESCRIPTION("Policing actions");
  MODULE_LICENSE("GPL");
@@@ -366,18 -360,43 +424,25 @@@ static struct tc_action_ops act_police_
  	.owner		=	THIS_MODULE,
  	.act		=	tcf_act_police,
  	.dump		=	tcf_act_police_dump,
++<<<<<<< HEAD
 +	.init		=	tcf_act_police_locate,
 +	.walk		=	tcf_act_police_walker
++=======
+ 	.init		=	tcf_act_police_init,
+ 	.walk		=	tcf_act_police_walker,
+ 	.lookup		=	tcf_police_search,
+ 	.size		=	sizeof(struct tcf_police),
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  };
  
 -static __net_init int police_init_net(struct net *net)
 -{
 -	struct tc_action_net *tn = net_generic(net, police_net_id);
 -
 -	return tc_action_net_init(tn, &act_police_ops, POL_TAB_MASK);
 -}
 -
 -static void __net_exit police_exit_net(struct net *net)
 -{
 -	struct tc_action_net *tn = net_generic(net, police_net_id);
 -
 -	tc_action_net_exit(tn);
 -}
 -
 -static struct pernet_operations police_net_ops = {
 -	.init = police_init_net,
 -	.exit = police_exit_net,
 -	.id   = &police_net_id,
 -	.size = sizeof(struct tc_action_net),
 -};
 -
 -static int __init
 -police_init_module(void)
 +static int __init police_init_module(void)
  {
 -	return tcf_register_action(&act_police_ops, &police_net_ops);
 +	return tcf_register_action(&act_police_ops, POL_TAB_MASK);
  }
  
 -static void __exit
 -police_cleanup_module(void)
 +static void __exit police_cleanup_module(void)
  {
 -	tcf_unregister_action(&act_police_ops, &police_net_ops);
 +	tcf_unregister_action(&act_police_ops);
  }
  
  module_init(police_init_module);
diff --cc net/sched/act_simple.c
index 4876cc19a2ed,289af6f9bb3b..000000000000
--- a/net/sched/act_simple.c
+++ b/net/sched/act_simple.c
@@@ -26,6 -26,9 +26,12 @@@
  
  #define SIMP_TAB_MASK     7
  
++<<<<<<< HEAD
++=======
+ static int simp_net_id;
+ static struct tc_action_ops act_simp_ops;
+ 
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  #define SIMP_MAX_DATA	32
  static int tcf_simp(struct sk_buff *skb, const struct tc_action *a,
  		    struct tcf_result *res)
@@@ -77,9 -80,10 +83,9 @@@ static const struct nla_policy simple_p
  };
  
  static int tcf_simp_init(struct net *net, struct nlattr *nla,
- 			 struct nlattr *est, struct tc_action *a,
+ 			 struct nlattr *est, struct tc_action **a,
  			 int ovr, int bind)
  {
 -	struct tc_action_net *tn = net_generic(net, simp_net_id);
  	struct nlattr *tb[TCA_DEF_MAX + 1];
  	struct tc_defact *parm;
  	struct tcf_defact *d;
@@@ -96,15 -101,22 +102,34 @@@
  	if (tb[TCA_DEF_PARMS] == NULL)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	if (tb[TCA_DEF_DATA] == NULL)
 +		return -EINVAL;
 +
 +	parm = nla_data(tb[TCA_DEF_PARMS]);
 +	defdata = nla_data(tb[TCA_DEF_DATA]);
 +
 +	if (!tcf_hash_check(parm->index, a, bind)) {
 +		ret = tcf_hash_create(parm->index, est, a, sizeof(*d),
 +				      bind, false);
++=======
+ 	parm = nla_data(tb[TCA_DEF_PARMS]);
+ 	exists = tcf_hash_check(tn, parm->index, a, bind);
+ 	if (exists && bind)
+ 		return 0;
+ 
+ 	if (tb[TCA_DEF_DATA] == NULL) {
+ 		if (exists)
+ 			tcf_hash_release(*a, bind);
+ 		return -EINVAL;
+ 	}
+ 
+ 	defdata = nla_data(tb[TCA_DEF_DATA]);
+ 
+ 	if (!exists) {
+ 		ret = tcf_hash_create(tn, parm->index, est, a,
+ 				      &act_simp_ops, bind, false);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  		if (ret)
  			return ret;
  
@@@ -117,11 -129,9 +142,15 @@@
  		d->tcf_action = parm->action;
  		ret = ACT_P_CREATED;
  	} else {
- 		d = to_defact(a);
+ 		d = to_defact(*a);
  
++<<<<<<< HEAD
 +		if (bind)
 +			return 0;
 +		tcf_hash_release(a, bind);
++=======
+ 		tcf_hash_release(*a, bind);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  		if (!ovr)
  			return -EEXIST;
  
@@@ -129,7 -139,7 +158,11 @@@
  	}
  
  	if (ret == ACT_P_CREATED)
++<<<<<<< HEAD
 +		tcf_hash_insert(a);
++=======
+ 		tcf_hash_insert(tn, *a);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  	return ret;
  }
  
@@@ -160,6 -170,22 +193,25 @@@ nla_put_failure
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ static int tcf_simp_walker(struct net *net, struct sk_buff *skb,
+ 			   struct netlink_callback *cb, int type,
+ 			   const struct tc_action_ops *ops)
+ {
+ 	struct tc_action_net *tn = net_generic(net, simp_net_id);
+ 
+ 	return tcf_generic_walker(tn, skb, cb, type, ops);
+ }
+ 
+ static int tcf_simp_search(struct net *net, struct tc_action **a, u32 index)
+ {
+ 	struct tc_action_net *tn = net_generic(net, simp_net_id);
+ 
+ 	return tcf_hash_search(tn, a, index);
+ }
+ 
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  static struct tc_action_ops act_simp_ops = {
  	.kind		=	"simple",
  	.type		=	TCA_ACT_SIMP,
@@@ -168,6 -194,30 +220,33 @@@
  	.dump		=	tcf_simp_dump,
  	.cleanup	=	tcf_simp_release,
  	.init		=	tcf_simp_init,
++<<<<<<< HEAD
++=======
+ 	.walk		=	tcf_simp_walker,
+ 	.lookup		=	tcf_simp_search,
+ 	.size		=	sizeof(struct tcf_defact),
+ };
+ 
+ static __net_init int simp_init_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, simp_net_id);
+ 
+ 	return tc_action_net_init(tn, &act_simp_ops, SIMP_TAB_MASK);
+ }
+ 
+ static void __net_exit simp_exit_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, simp_net_id);
+ 
+ 	tc_action_net_exit(tn);
+ }
+ 
+ static struct pernet_operations simp_net_ops = {
+ 	.init = simp_init_net,
+ 	.exit = simp_exit_net,
+ 	.id   = &simp_net_id,
+ 	.size = sizeof(struct tc_action_net),
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  };
  
  MODULE_AUTHOR("Jamal Hadi Salim(2005)");
diff --cc net/sched/act_skbedit.c
index 173bfd2bb060,a133dcb82132..000000000000
--- a/net/sched/act_skbedit.c
+++ b/net/sched/act_skbedit.c
@@@ -30,6 -29,9 +30,12 @@@
  
  #define SKBEDIT_TAB_MASK     15
  
++<<<<<<< HEAD
++=======
+ static int skbedit_net_id;
+ static struct tc_action_ops act_skbedit_ops;
+ 
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  static int tcf_skbedit(struct sk_buff *skb, const struct tc_action *a,
  		       struct tcf_result *res)
  {
@@@ -59,9 -63,11 +65,9 @@@ static const struct nla_policy skbedit_
  };
  
  static int tcf_skbedit_init(struct net *net, struct nlattr *nla,
- 			    struct nlattr *est, struct tc_action *a,
+ 			    struct nlattr *est, struct tc_action **a,
  			    int ovr, int bind)
  {
 -	struct tc_action_net *tn = net_generic(net, skbedit_net_id);
  	struct nlattr *tb[TCA_SKBEDIT_MAX + 1];
  	struct tc_skbedit *parm;
  	struct tcf_skbedit *d;
@@@ -94,24 -108,28 +100,44 @@@
  		mark = nla_data(tb[TCA_SKBEDIT_MARK]);
  	}
  
 +	if (!flags)
 +		return -EINVAL;
 +
  	parm = nla_data(tb[TCA_SKBEDIT_PARMS]);
  
++<<<<<<< HEAD
 +	if (!tcf_hash_check(parm->index, a, bind)) {
 +		ret = tcf_hash_create(parm->index, est, a, sizeof(*d),
 +				      bind, false);
++=======
+ 	exists = tcf_hash_check(tn, parm->index, a, bind);
+ 	if (exists && bind)
+ 		return 0;
+ 
+ 	if (!flags) {
+ 		tcf_hash_release(*a, bind);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!exists) {
+ 		ret = tcf_hash_create(tn, parm->index, est, a,
+ 				      &act_skbedit_ops, bind, false);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  		if (ret)
  			return ret;
  
- 		d = to_skbedit(a);
+ 		d = to_skbedit(*a);
  		ret = ACT_P_CREATED;
  	} else {
++<<<<<<< HEAD
 +		d = to_skbedit(a);
 +		if (bind)
 +			return 0;
 +		tcf_hash_release(a, bind);
++=======
+ 		d = to_skbedit(*a);
+ 		tcf_hash_release(*a, bind);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  		if (!ovr)
  			return -EEXIST;
  	}
@@@ -131,7 -151,7 +157,11 @@@
  	spin_unlock_bh(&d->tcf_lock);
  
  	if (ret == ACT_P_CREATED)
++<<<<<<< HEAD
 +		tcf_hash_insert(a);
++=======
+ 		tcf_hash_insert(tn, *a);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  	return ret;
  }
  
@@@ -173,6 -193,22 +203,25 @@@ nla_put_failure
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ static int tcf_skbedit_walker(struct net *net, struct sk_buff *skb,
+ 			      struct netlink_callback *cb, int type,
+ 			      const struct tc_action_ops *ops)
+ {
+ 	struct tc_action_net *tn = net_generic(net, skbedit_net_id);
+ 
+ 	return tcf_generic_walker(tn, skb, cb, type, ops);
+ }
+ 
+ static int tcf_skbedit_search(struct net *net, struct tc_action **a, u32 index)
+ {
+ 	struct tc_action_net *tn = net_generic(net, skbedit_net_id);
+ 
+ 	return tcf_hash_search(tn, a, index);
+ }
+ 
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  static struct tc_action_ops act_skbedit_ops = {
  	.kind		=	"skbedit",
  	.type		=	TCA_ACT_SKBEDIT,
@@@ -180,6 -216,30 +229,33 @@@
  	.act		=	tcf_skbedit,
  	.dump		=	tcf_skbedit_dump,
  	.init		=	tcf_skbedit_init,
++<<<<<<< HEAD
++=======
+ 	.walk		=	tcf_skbedit_walker,
+ 	.lookup		=	tcf_skbedit_search,
+ 	.size		=	sizeof(struct tcf_skbedit),
+ };
+ 
+ static __net_init int skbedit_init_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, skbedit_net_id);
+ 
+ 	return tc_action_net_init(tn, &act_skbedit_ops, SKBEDIT_TAB_MASK);
+ }
+ 
+ static void __net_exit skbedit_exit_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, skbedit_net_id);
+ 
+ 	tc_action_net_exit(tn);
+ }
+ 
+ static struct pernet_operations skbedit_net_ops = {
+ 	.init = skbedit_init_net,
+ 	.exit = skbedit_exit_net,
+ 	.id   = &skbedit_net_id,
+ 	.size = sizeof(struct tc_action_net),
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  };
  
  MODULE_AUTHOR("Alexander Duyck, <alexander.h.duyck@intel.com>");
diff --cc net/sched/act_vlan.c
index 2ca3e6093ca9,691409de3e1a..000000000000
--- a/net/sched/act_vlan.c
+++ b/net/sched/act_vlan.c
@@@ -21,6 -21,9 +21,12 @@@
  
  #define VLAN_TAB_MASK     15
  
++<<<<<<< HEAD
++=======
+ static int vlan_net_id;
+ static struct tc_action_ops act_vlan_ops;
+ 
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  static int tcf_vlan(struct sk_buff *skb, const struct tc_action *a,
  		    struct tcf_result *res)
  {
@@@ -67,9 -68,10 +73,9 @@@ static const struct nla_policy vlan_pol
  };
  
  static int tcf_vlan_init(struct net *net, struct nlattr *nla,
- 			 struct nlattr *est, struct tc_action *a,
+ 			 struct nlattr *est, struct tc_action **a,
  			 int ovr, int bind)
  {
 -	struct tc_action_net *tn = net_generic(net, vlan_net_id);
  	struct nlattr *tb[TCA_VLAN_MAX + 1];
  	struct tc_vlan *parm;
  	struct tcf_vlan *v;
@@@ -94,11 -99,17 +100,23 @@@
  	case TCA_VLAN_ACT_POP:
  		break;
  	case TCA_VLAN_ACT_PUSH:
++<<<<<<< HEAD
 +		if (!tb[TCA_VLAN_PUSH_VLAN_ID])
++=======
+ 		if (!tb[TCA_VLAN_PUSH_VLAN_ID]) {
+ 			if (exists)
+ 				tcf_hash_release(*a, bind);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  			return -EINVAL;
 -		}
  		push_vid = nla_get_u16(tb[TCA_VLAN_PUSH_VLAN_ID]);
++<<<<<<< HEAD
 +		if (push_vid >= VLAN_VID_MASK)
++=======
+ 		if (push_vid >= VLAN_VID_MASK) {
+ 			if (exists)
+ 				tcf_hash_release(*a, bind);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  			return -ERANGE;
 -		}
  
  		if (tb[TCA_VLAN_PUSH_VLAN_PROTOCOL]) {
  			push_proto = nla_get_be16(tb[TCA_VLAN_PUSH_VLAN_PROTOCOL]);
@@@ -112,26 -123,23 +130,41 @@@
  		} else {
  			push_proto = htons(ETH_P_8021Q);
  		}
 +
 +		if (tb[TCA_VLAN_PUSH_VLAN_PRIORITY])
 +			push_prio = nla_get_u8(tb[TCA_VLAN_PUSH_VLAN_PRIORITY]);
  		break;
  	default:
++<<<<<<< HEAD
++=======
+ 		if (exists)
+ 			tcf_hash_release(*a, bind);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  		return -EINVAL;
  	}
  	action = parm->v_action;
  
++<<<<<<< HEAD
 +	if (!tcf_hash_check(parm->index, a, bind)) {
 +		ret = tcf_hash_create(parm->index, est, a, sizeof(*v),
 +				      bind, false);
++=======
+ 	if (!exists) {
+ 		ret = tcf_hash_create(tn, parm->index, est, a,
+ 				      &act_vlan_ops, bind, false);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  		if (ret)
  			return ret;
  
  		ret = ACT_P_CREATED;
  	} else {
++<<<<<<< HEAD
 +		if (bind)
 +			return 0;
 +		tcf_hash_release(a, bind);
++=======
+ 		tcf_hash_release(*a, bind);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  		if (!ovr)
  			return -EEXIST;
  	}
@@@ -150,7 -157,7 +183,11 @@@
  	spin_unlock_bh(&v->tcf_lock);
  
  	if (ret == ACT_P_CREATED)
++<<<<<<< HEAD
 +		tcf_hash_insert(a);
++=======
+ 		tcf_hash_insert(tn, *a);
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  	return ret;
  }
  
@@@ -189,6 -194,22 +226,25 @@@ nla_put_failure
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ static int tcf_vlan_walker(struct net *net, struct sk_buff *skb,
+ 			   struct netlink_callback *cb, int type,
+ 			   const struct tc_action_ops *ops)
+ {
+ 	struct tc_action_net *tn = net_generic(net, vlan_net_id);
+ 
+ 	return tcf_generic_walker(tn, skb, cb, type, ops);
+ }
+ 
+ static int tcf_vlan_search(struct net *net, struct tc_action **a, u32 index)
+ {
+ 	struct tc_action_net *tn = net_generic(net, vlan_net_id);
+ 
+ 	return tcf_hash_search(tn, a, index);
+ }
+ 
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  static struct tc_action_ops act_vlan_ops = {
  	.kind		=	"vlan",
  	.type		=	TCA_ACT_VLAN,
@@@ -196,6 -217,30 +252,33 @@@
  	.act		=	tcf_vlan,
  	.dump		=	tcf_vlan_dump,
  	.init		=	tcf_vlan_init,
++<<<<<<< HEAD
++=======
+ 	.walk		=	tcf_vlan_walker,
+ 	.lookup		=	tcf_vlan_search,
+ 	.size		=	sizeof(struct tcf_vlan),
+ };
+ 
+ static __net_init int vlan_init_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, vlan_net_id);
+ 
+ 	return tc_action_net_init(tn, &act_vlan_ops, VLAN_TAB_MASK);
+ }
+ 
+ static void __net_exit vlan_exit_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, vlan_net_id);
+ 
+ 	tc_action_net_exit(tn);
+ }
+ 
+ static struct pernet_operations vlan_net_ops = {
+ 	.init = vlan_init_net,
+ 	.exit = vlan_exit_net,
+ 	.id   = &vlan_net_id,
+ 	.size = sizeof(struct tc_action_net),
++>>>>>>> a85a970af265 (net_sched: move tc_action into tcf_common)
  };
  
  static int __init vlan_init_module(void)
* Unmerged path include/net/tc_act/tc_bpf.h
* Unmerged path include/net/tc_act/tc_connmark.h
* Unmerged path include/net/tc_act/tc_ife.h
* Unmerged path net/sched/act_bpf.c
* Unmerged path net/sched/act_connmark.c
* Unmerged path net/sched/act_ife.c
* Unmerged path include/net/act_api.h
* Unmerged path include/net/tc_act/tc_bpf.h
* Unmerged path include/net/tc_act/tc_connmark.h
diff --git a/include/net/tc_act/tc_csum.h b/include/net/tc_act/tc_csum.h
index fa8f5fac65e9..1a9ef15d573b 100644
--- a/include/net/tc_act/tc_csum.h
+++ b/include/net/tc_act/tc_csum.h
@@ -9,7 +9,6 @@ struct tcf_csum {
 
 	u32 update_flags;
 };
-#define to_tcf_csum(a) \
-	container_of(a->priv,struct tcf_csum,common)
+#define to_tcf_csum(a) ((struct tcf_csum *)a)
 
 #endif /* __NET_TC_CSUM_H */
diff --git a/include/net/tc_act/tc_defact.h b/include/net/tc_act/tc_defact.h
index ab9b5d6be67b..e25b4eb4fc66 100644
--- a/include/net/tc_act/tc_defact.h
+++ b/include/net/tc_act/tc_defact.h
@@ -8,7 +8,6 @@ struct tcf_defact {
 	u32		tcfd_datalen;
 	void		*tcfd_defdata;
 };
-#define to_defact(a) \
-	container_of(a->priv, struct tcf_defact, common)
+#define to_defact(a) ((struct tcf_defact *)a)
 
 #endif /* __NET_TC_DEF_H */
diff --git a/include/net/tc_act/tc_gact.h b/include/net/tc_act/tc_gact.h
index 93c520b83d10..119cdb418c23 100644
--- a/include/net/tc_act/tc_gact.h
+++ b/include/net/tc_act/tc_gact.h
@@ -13,8 +13,7 @@ struct tcf_gact {
 	atomic_t		packets;
 #endif
 };
-#define to_gact(a) \
-	container_of(a->priv, struct tcf_gact, common)
+#define to_gact(a) ((struct tcf_gact *)a)
 
 static inline bool is_tcf_gact_shot(const struct tc_action *a)
 {
@@ -24,7 +23,7 @@ static inline bool is_tcf_gact_shot(const struct tc_action *a)
 	if (a->ops && a->ops->type != TCA_ACT_GACT)
 		return false;
 
-	gact = a->priv;
+	gact = to_gact(a);
 	if (gact->tcf_action == TC_ACT_SHOT)
 		return true;
 
* Unmerged path include/net/tc_act/tc_ife.h
diff --git a/include/net/tc_act/tc_ipt.h b/include/net/tc_act/tc_ipt.h
index c0f4193f432c..c22ae7ab66ed 100644
--- a/include/net/tc_act/tc_ipt.h
+++ b/include/net/tc_act/tc_ipt.h
@@ -11,7 +11,6 @@ struct tcf_ipt {
 	char			*tcfi_tname;
 	struct xt_entry_target	*tcfi_t;
 };
-#define to_ipt(a) \
-	container_of(a->priv, struct tcf_ipt, common)
+#define to_ipt(a) ((struct tcf_ipt *)a)
 
 #endif /* __NET_TC_IPT_H */
diff --git a/include/net/tc_act/tc_mirred.h b/include/net/tc_act/tc_mirred.h
index 9ea601b2d0be..100e0eeef602 100644
--- a/include/net/tc_act/tc_mirred.h
+++ b/include/net/tc_act/tc_mirred.h
@@ -12,8 +12,7 @@ struct tcf_mirred {
 	struct net_device __rcu	*tcfm_dev;
 	struct list_head	tcfm_list;
 };
-#define to_mirred(a) \
-	container_of(a->priv, struct tcf_mirred, common)
+#define to_mirred(a) ((struct tcf_mirred *)a)
 
 static inline bool is_tcf_mirred_egress_redirect(const struct tc_action *a)
 {
diff --git a/include/net/tc_act/tc_nat.h b/include/net/tc_act/tc_nat.h
index 63d8e9ca9d99..a91ad3ad565e 100644
--- a/include/net/tc_act/tc_nat.h
+++ b/include/net/tc_act/tc_nat.h
@@ -13,9 +13,6 @@ struct tcf_nat {
 	u32 flags;
 };
 
-static inline struct tcf_nat *to_tcf_nat(struct tc_action *a)
-{
-	return container_of(a->priv, struct tcf_nat, common);
-}
+#define to_tcf_nat(a) ((struct tcf_nat *)a)
 
 #endif /* __NET_TC_NAT_H */
diff --git a/include/net/tc_act/tc_pedit.h b/include/net/tc_act/tc_pedit.h
index 5b80998879c7..2cccfbaae800 100644
--- a/include/net/tc_act/tc_pedit.h
+++ b/include/net/tc_act/tc_pedit.h
@@ -9,7 +9,6 @@ struct tcf_pedit {
 	unsigned char		tcfp_flags;
 	struct tc_pedit_key	*tcfp_keys;
 };
-#define to_pedit(a) \
-	container_of(a->priv, struct tcf_pedit, common)
+#define to_pedit(a) ((struct tcf_pedit *)a)
 
 #endif /* __NET_TC_PED_H */
diff --git a/include/net/tc_act/tc_skbedit.h b/include/net/tc_act/tc_skbedit.h
index b496d5ad7d42..a1957aac653a 100644
--- a/include/net/tc_act/tc_skbedit.h
+++ b/include/net/tc_act/tc_skbedit.h
@@ -30,8 +30,7 @@ struct tcf_skbedit {
 	u16			queue_mapping;
 	/* XXX: 16-bit pad here? */
 };
-#define to_skbedit(a) \
-	container_of(a->priv, struct tcf_skbedit, common)
+#define to_skbedit(a) ((struct tcf_skbedit *)a)
 
 /* Return true iff action is mark */
 static inline bool is_tcf_skbedit_mark(const struct tc_action *a)
diff --git a/include/net/tc_act/tc_vlan.h b/include/net/tc_act/tc_vlan.h
index daed22bd4926..d56a84bb8405 100644
--- a/include/net/tc_act/tc_vlan.h
+++ b/include/net/tc_act/tc_vlan.h
@@ -23,8 +23,7 @@ struct tcf_vlan {
 	__be16			tcfv_push_proto;
 	u8			tcfv_push_prio;
 };
-#define to_vlan(a) \
-	container_of(a->priv, struct tcf_vlan, common)
+#define to_vlan(a) ((struct tcf_vlan *)a)
 
 static inline bool is_tcf_vlan(const struct tc_action *a)
 {
* Unmerged path net/sched/act_api.c
* Unmerged path net/sched/act_bpf.c
* Unmerged path net/sched/act_connmark.c
* Unmerged path net/sched/act_csum.c
* Unmerged path net/sched/act_gact.c
* Unmerged path net/sched/act_ife.c
* Unmerged path net/sched/act_ipt.c
* Unmerged path net/sched/act_mirred.c
* Unmerged path net/sched/act_nat.c
* Unmerged path net/sched/act_pedit.c
* Unmerged path net/sched/act_police.c
* Unmerged path net/sched/act_simple.c
* Unmerged path net/sched/act_skbedit.c
* Unmerged path net/sched/act_vlan.c
