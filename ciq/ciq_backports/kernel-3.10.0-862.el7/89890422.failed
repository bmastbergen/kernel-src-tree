net_sched: reset pointers to tcf blocks in classful qdiscs' destructors

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
commit 898904226b5a6dee657f23cf51e385f50da22596
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/89890422.failed

Traffic filters could keep direct pointers to classes in classful qdisc,
thus qdisc destruction first removes all filters before freeing classes.
Class destruction methods also tries to free attached filters but now
this isn't safe because tcf_block_put() unlike to tcf_destroy_chain()
cannot be called second time.

This patch set class->block to NULL after first tcf_block_put() and
turn second call into no-op.

Fixes: 6529eaba33f0 ("net: sched: introduce tcf block infractructure")
	Signed-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 898904226b5a6dee657f23cf51e385f50da22596)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/sch_atm.c
#	net/sched/sch_cbq.c
#	net/sched/sch_hfsc.c
#	net/sched/sch_htb.c
diff --cc net/sched/sch_atm.c
index 98f2f1641245,c403c87aff7a..000000000000
--- a/net/sched/sch_atm.c
+++ b/net/sched/sch_atm.c
@@@ -572,8 -572,10 +572,15 @@@ static void atm_tc_destroy(struct Qdis
  	struct atm_flow_data *flow, *tmp;
  
  	pr_debug("atm_tc_destroy(sch %p,[qdisc %p])\n", sch, p);
++<<<<<<< HEAD
 +	list_for_each_entry(flow, &p->flows, list)
 +		tcf_destroy_chain(&flow->filter_list);
++=======
+ 	list_for_each_entry(flow, &p->flows, list) {
+ 		tcf_block_put(flow->block);
+ 		flow->block = NULL;
+ 	}
++>>>>>>> 898904226b5a (net_sched: reset pointers to tcf blocks in classful qdiscs' destructors)
  
  	list_for_each_entry_safe(flow, tmp, &p->flows, list) {
  		if (flow->ref > 1)
diff --cc net/sched/sch_cbq.c
index 24f30ccfced6,780db43300b1..000000000000
--- a/net/sched/sch_cbq.c
+++ b/net/sched/sch_cbq.c
@@@ -1450,8 -1431,10 +1450,15 @@@ static void cbq_destroy(struct Qdisc *s
  	 * be bound to classes which have been destroyed already. --TGR '04
  	 */
  	for (h = 0; h < q->clhash.hashsize; h++) {
++<<<<<<< HEAD
 +		hlist_for_each_entry(cl, &q->clhash.hash[h], common.hnode)
 +			tcf_destroy_chain(&cl->filter_list);
++=======
+ 		hlist_for_each_entry(cl, &q->clhash.hash[h], common.hnode) {
+ 			tcf_block_put(cl->block);
+ 			cl->block = NULL;
+ 		}
++>>>>>>> 898904226b5a (net_sched: reset pointers to tcf blocks in classful qdiscs' destructors)
  	}
  	for (h = 0; h < q->clhash.hashsize; h++) {
  		hlist_for_each_entry_safe(cl, next, &q->clhash.hash[h],
diff --cc net/sched/sch_hfsc.c
index 76a930b0658e,fd15200f8627..000000000000
--- a/net/sched/sch_hfsc.c
+++ b/net/sched/sch_hfsc.c
@@@ -1518,8 -1530,10 +1518,15 @@@ hfsc_destroy_qdisc(struct Qdisc *sch
  	unsigned int i;
  
  	for (i = 0; i < q->clhash.hashsize; i++) {
++<<<<<<< HEAD
 +		hlist_for_each_entry(cl, &q->clhash.hash[i], cl_common.hnode)
 +			tcf_destroy_chain(&cl->filter_list);
++=======
+ 		hlist_for_each_entry(cl, &q->clhash.hash[i], cl_common.hnode) {
+ 			tcf_block_put(cl->block);
+ 			cl->block = NULL;
+ 		}
++>>>>>>> 898904226b5a (net_sched: reset pointers to tcf blocks in classful qdiscs' destructors)
  	}
  	for (i = 0; i < q->clhash.hashsize; i++) {
  		hlist_for_each_entry_safe(cl, next, &q->clhash.hash[i],
diff --cc net/sched/sch_htb.c
index 2abcfb74a823,5d65ec5207e9..000000000000
--- a/net/sched/sch_htb.c
+++ b/net/sched/sch_htb.c
@@@ -1252,11 -1255,13 +1252,18 @@@ static void htb_destroy(struct Qdisc *s
  	 * because filter need its target class alive to be able to call
  	 * unbind_filter on it (without Oops).
  	 */
 -	tcf_block_put(q->block);
 +	tcf_destroy_chain(&q->filter_list);
  
  	for (i = 0; i < q->clhash.hashsize; i++) {
++<<<<<<< HEAD
 +		hlist_for_each_entry(cl, &q->clhash.hash[i], common.hnode)
 +			tcf_destroy_chain(&cl->filter_list);
++=======
+ 		hlist_for_each_entry(cl, &q->clhash.hash[i], common.hnode) {
+ 			tcf_block_put(cl->block);
+ 			cl->block = NULL;
+ 		}
++>>>>>>> 898904226b5a (net_sched: reset pointers to tcf blocks in classful qdiscs' destructors)
  	}
  	for (i = 0; i < q->clhash.hashsize; i++) {
  		hlist_for_each_entry_safe(cl, next, &q->clhash.hash[i],
* Unmerged path net/sched/sch_atm.c
* Unmerged path net/sched/sch_cbq.c
* Unmerged path net/sched/sch_hfsc.c
* Unmerged path net/sched/sch_htb.c
