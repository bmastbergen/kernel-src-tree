scsi: lpfc: Fix transition nvme-i rport handling to nport only.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] lpfc: Fix transition nvme-i rport handling to nport only (Dick Kennedy) [1385844 1461977 1387768]
Rebuild_FUZZ: 94.12%
commit-author James Smart <jsmart2021@gmail.com>
commit 80cc004393619a1b3a17aaf4a9e55c5b9f4fc3c1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/80cc0043.failed

As the devloss API was implemented in the nvmei driver, an evaluation of
the nvme transport and the lpfc driver showed dual management of the
rports.  This creates a bug possibility when the thread count and SAN
size increases.

The nvmei driver code was based on a very early transport and was not
revisited until the devloss API was introduced.

Remove the listhead in the driver's rport data structure and the
listhead in the driver's lport data structure.  Remove all rport_list
traversal.  Convert the driver to use the nrport (nvme rport) pointer
that is now NULL or nonNULL depending on a devloss action.  Convert
debugfs and nvme_info in sysfs to use the fc_nodes list in the vport.

	Signed-off-by: Dick Kennedy <dick.kennedy@broadcom.com>
	Signed-off-by: James Smart <james.smart@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 80cc004393619a1b3a17aaf4a9e55c5b9f4fc3c1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_attr.c
#	drivers/scsi/lpfc/lpfc_debugfs.c
#	drivers/scsi/lpfc/lpfc_nvme.c
#	drivers/scsi/lpfc/lpfc_nvme.h
diff --cc drivers/scsi/lpfc/lpfc_attr.c
index b0e0bd1cf345,6d9b83cd82a2..000000000000
--- a/drivers/scsi/lpfc/lpfc_attr.c
+++ b/drivers/scsi/lpfc/lpfc_attr.c
@@@ -130,6 -140,222 +130,225 @@@ lpfc_enable_fip_show(struct device *dev
  }
  
  static ssize_t
++<<<<<<< HEAD
++=======
+ lpfc_nvme_info_show(struct device *dev, struct device_attribute *attr,
+ 		    char *buf)
+ {
+ 	struct Scsi_Host *shost = class_to_shost(dev);
+ 	struct lpfc_vport *vport = shost_priv(shost);
+ 	struct lpfc_hba   *phba = vport->phba;
+ 	struct lpfc_nvmet_tgtport *tgtp;
+ 	struct nvme_fc_local_port *localport;
+ 	struct lpfc_nodelist *ndlp;
+ 	struct nvme_fc_remote_port *nrport;
+ 	char *statep;
+ 	int len = 0;
+ 
+ 	if (!(phba->cfg_enable_fc4_type & LPFC_ENABLE_NVME)) {
+ 		len += snprintf(buf, PAGE_SIZE, "NVME Disabled\n");
+ 		return len;
+ 	}
+ 	if (phba->nvmet_support) {
+ 		if (!phba->targetport) {
+ 			len = snprintf(buf, PAGE_SIZE,
+ 					"NVME Target: x%llx is not allocated\n",
+ 					wwn_to_u64(vport->fc_portname.u.wwn));
+ 			return len;
+ 		}
+ 		/* Port state is only one of two values for now. */
+ 		if (phba->targetport->port_id)
+ 			statep = "REGISTERED";
+ 		else
+ 			statep = "INIT";
+ 		len += snprintf(buf + len, PAGE_SIZE - len,
+ 				"NVME Target: Enabled  State %s\n",
+ 				statep);
+ 		len += snprintf(buf + len, PAGE_SIZE - len,
+ 				"%s%d WWPN x%llx WWNN x%llx DID x%06x\n",
+ 				"NVME Target: lpfc",
+ 				phba->brd_no,
+ 				wwn_to_u64(vport->fc_portname.u.wwn),
+ 				wwn_to_u64(vport->fc_nodename.u.wwn),
+ 				phba->targetport->port_id);
+ 
+ 		len += snprintf(buf + len, PAGE_SIZE - len,
+ 				"\nNVME Target: Statistics\n");
+ 		tgtp = (struct lpfc_nvmet_tgtport *)phba->targetport->private;
+ 		len += snprintf(buf+len, PAGE_SIZE-len,
+ 				"LS: Rcv %08x Drop %08x Abort %08x\n",
+ 				atomic_read(&tgtp->rcv_ls_req_in),
+ 				atomic_read(&tgtp->rcv_ls_req_drop),
+ 				atomic_read(&tgtp->xmt_ls_abort));
+ 		if (atomic_read(&tgtp->rcv_ls_req_in) !=
+ 		    atomic_read(&tgtp->rcv_ls_req_out)) {
+ 			len += snprintf(buf+len, PAGE_SIZE-len,
+ 					"Rcv LS: in %08x != out %08x\n",
+ 					atomic_read(&tgtp->rcv_ls_req_in),
+ 					atomic_read(&tgtp->rcv_ls_req_out));
+ 		}
+ 
+ 		len += snprintf(buf+len, PAGE_SIZE-len,
+ 				"LS: Xmt %08x Drop %08x Cmpl %08x Err %08x\n",
+ 				atomic_read(&tgtp->xmt_ls_rsp),
+ 				atomic_read(&tgtp->xmt_ls_drop),
+ 				atomic_read(&tgtp->xmt_ls_rsp_cmpl),
+ 				atomic_read(&tgtp->xmt_ls_rsp_error));
+ 
+ 		len += snprintf(buf+len, PAGE_SIZE-len,
+ 				"FCP: Rcv %08x Release %08x Drop %08x\n",
+ 				atomic_read(&tgtp->rcv_fcp_cmd_in),
+ 				atomic_read(&tgtp->xmt_fcp_release),
+ 				atomic_read(&tgtp->rcv_fcp_cmd_drop));
+ 
+ 		if (atomic_read(&tgtp->rcv_fcp_cmd_in) !=
+ 		    atomic_read(&tgtp->rcv_fcp_cmd_out)) {
+ 			len += snprintf(buf+len, PAGE_SIZE-len,
+ 					"Rcv FCP: in %08x != out %08x\n",
+ 					atomic_read(&tgtp->rcv_fcp_cmd_in),
+ 					atomic_read(&tgtp->rcv_fcp_cmd_out));
+ 		}
+ 
+ 		len += snprintf(buf+len, PAGE_SIZE-len,
+ 				"FCP Rsp: RD %08x rsp %08x WR %08x rsp %08x "
+ 				"drop %08x\n",
+ 				atomic_read(&tgtp->xmt_fcp_read),
+ 				atomic_read(&tgtp->xmt_fcp_read_rsp),
+ 				atomic_read(&tgtp->xmt_fcp_write),
+ 				atomic_read(&tgtp->xmt_fcp_rsp),
+ 				atomic_read(&tgtp->xmt_fcp_drop));
+ 
+ 		len += snprintf(buf+len, PAGE_SIZE-len,
+ 				"FCP Rsp Cmpl: %08x err %08x drop %08x\n",
+ 				atomic_read(&tgtp->xmt_fcp_rsp_cmpl),
+ 				atomic_read(&tgtp->xmt_fcp_rsp_error),
+ 				atomic_read(&tgtp->xmt_fcp_rsp_drop));
+ 
+ 		len += snprintf(buf+len, PAGE_SIZE-len,
+ 				"ABORT: Xmt %08x Cmpl %08x\n",
+ 				atomic_read(&tgtp->xmt_fcp_abort),
+ 				atomic_read(&tgtp->xmt_fcp_abort_cmpl));
+ 
+ 		len += snprintf(buf + len, PAGE_SIZE - len,
+ 				"ABORT: Sol %08x  Usol %08x Err %08x Cmpl %08x",
+ 				atomic_read(&tgtp->xmt_abort_sol),
+ 				atomic_read(&tgtp->xmt_abort_unsol),
+ 				atomic_read(&tgtp->xmt_abort_rsp),
+ 				atomic_read(&tgtp->xmt_abort_rsp_error));
+ 
+ 		len += snprintf(buf + len, PAGE_SIZE - len,
+ 				"IO_CTX: %08x outstanding %08x total %x",
+ 				phba->sli4_hba.nvmet_ctx_cnt,
+ 				phba->sli4_hba.nvmet_io_wait_cnt,
+ 				phba->sli4_hba.nvmet_io_wait_total);
+ 
+ 		len +=  snprintf(buf+len, PAGE_SIZE-len, "\n");
+ 		return len;
+ 	}
+ 
+ 	localport = vport->localport;
+ 	if (!localport) {
+ 		len = snprintf(buf, PAGE_SIZE,
+ 				"NVME Initiator x%llx is not allocated\n",
+ 				wwn_to_u64(vport->fc_portname.u.wwn));
+ 		return len;
+ 	}
+ 	len = snprintf(buf, PAGE_SIZE, "NVME Initiator Enabled\n");
+ 
+ 	spin_lock_irq(shost->host_lock);
+ 
+ 	/* Port state is only one of two values for now. */
+ 	if (localport->port_id)
+ 		statep = "ONLINE";
+ 	else
+ 		statep = "UNKNOWN ";
+ 
+ 	len += snprintf(buf + len, PAGE_SIZE - len,
+ 			"%s%d WWPN x%llx WWNN x%llx DID x%06x %s\n",
+ 			"NVME LPORT lpfc",
+ 			phba->brd_no,
+ 			wwn_to_u64(vport->fc_portname.u.wwn),
+ 			wwn_to_u64(vport->fc_nodename.u.wwn),
+ 			localport->port_id, statep);
+ 
+ 	list_for_each_entry(ndlp, &vport->fc_nodes, nlp_listp) {
+ 		if (!ndlp->nrport)
+ 			continue;
+ 
+ 		/* local short-hand pointer. */
+ 		nrport = ndlp->nrport->remoteport;
+ 
+ 		/* Port state is only one of two values for now. */
+ 		switch (nrport->port_state) {
+ 		case FC_OBJSTATE_ONLINE:
+ 			statep = "ONLINE";
+ 			break;
+ 		case FC_OBJSTATE_UNKNOWN:
+ 			statep = "UNKNOWN ";
+ 			break;
+ 		default:
+ 			statep = "UNSUPPORTED";
+ 			break;
+ 		}
+ 
+ 		/* Tab in to show lport ownership. */
+ 		len += snprintf(buf + len, PAGE_SIZE - len,
+ 				"NVME RPORT       ");
+ 		if (phba->brd_no >= 10)
+ 			len += snprintf(buf + len, PAGE_SIZE - len, " ");
+ 
+ 		len += snprintf(buf + len, PAGE_SIZE - len, "WWPN x%llx ",
+ 				nrport->port_name);
+ 		len += snprintf(buf + len, PAGE_SIZE - len, "WWNN x%llx ",
+ 				nrport->node_name);
+ 		len += snprintf(buf + len, PAGE_SIZE - len, "DID x%06x ",
+ 				nrport->port_id);
+ 
+ 		switch (nrport->port_role) {
+ 		case FC_PORT_ROLE_NVME_INITIATOR:
+ 			len +=  snprintf(buf + len, PAGE_SIZE - len,
+ 					 "INITIATOR ");
+ 			break;
+ 		case FC_PORT_ROLE_NVME_TARGET:
+ 			len +=  snprintf(buf + len, PAGE_SIZE - len,
+ 					 "TARGET ");
+ 			break;
+ 		case FC_PORT_ROLE_NVME_DISCOVERY:
+ 			len +=  snprintf(buf + len, PAGE_SIZE - len,
+ 					 "DISCOVERY ");
+ 			break;
+ 		default:
+ 			len +=  snprintf(buf + len, PAGE_SIZE - len,
+ 					 "UNKNOWN_ROLE x%x",
+ 					 nrport->port_role);
+ 			break;
+ 		}
+ 		len +=  snprintf(buf + len, PAGE_SIZE - len, "%s  ", statep);
+ 		/* Terminate the string. */
+ 		len +=  snprintf(buf + len, PAGE_SIZE - len, "\n");
+ 	}
+ 	spin_unlock_irq(shost->host_lock);
+ 
+ 	len += snprintf(buf + len, PAGE_SIZE - len, "\nNVME Statistics\n");
+ 	len += snprintf(buf+len, PAGE_SIZE-len,
+ 			"LS: Xmt %016llx Cmpl %016llx\n",
+ 			phba->fc4NvmeLsRequests,
+ 			phba->fc4NvmeLsCmpls);
+ 
+ 	len += snprintf(buf+len, PAGE_SIZE-len,
+ 			"FCP: Rd %016llx Wr %016llx IO %016llx\n",
+ 			phba->fc4NvmeInputRequests,
+ 			phba->fc4NvmeOutputRequests,
+ 			phba->fc4NvmeControlRequests);
+ 
+ 	len += snprintf(buf+len, PAGE_SIZE-len,
+ 			"    Cmpl %016llx\n", phba->fc4NvmeIoCmpls);
+ 
+ 	return len;
+ }
+ 
+ static ssize_t
++>>>>>>> 80cc00439361 (scsi: lpfc: Fix transition nvme-i rport handling to nport only.)
  lpfc_bg_info_show(struct device *dev, struct device_attribute *attr,
  		  char *buf)
  {
diff --cc drivers/scsi/lpfc/lpfc_debugfs.c
index 389b2bc6c406,e288e59c967f..000000000000
--- a/drivers/scsi/lpfc/lpfc_debugfs.c
+++ b/drivers/scsi/lpfc/lpfc_debugfs.c
@@@ -530,8 -546,12 +530,15 @@@ lpfc_debugfs_nodelist_data(struct lpfc_
  	int len = 0;
  	int cnt;
  	struct Scsi_Host *shost = lpfc_shost_from_vport(vport);
 -	struct lpfc_hba  *phba = vport->phba;
  	struct lpfc_nodelist *ndlp;
++<<<<<<< HEAD
 +	unsigned char *statep, *name;
++=======
+ 	unsigned char *statep;
+ 	struct nvme_fc_local_port *localport;
+ 	struct lpfc_nvmet_tgtport *tgtp;
+ 	struct nvme_fc_remote_port *nrport;
++>>>>>>> 80cc00439361 (scsi: lpfc: Fix transition nvme-i rport handling to nport only.)
  
  	cnt = (LPFC_NODELIST_SIZE / LPFC_NODELIST_ENTRY_SIZE);
  
@@@ -611,8 -628,630 +618,107 @@@
  		len +=  snprintf(buf+len, size-len, "\n");
  	}
  	spin_unlock_irq(shost->host_lock);
++<<<<<<< HEAD
++=======
+ 
+ 	if (phba->nvmet_support && phba->targetport && (vport == phba->pport)) {
+ 		tgtp = (struct lpfc_nvmet_tgtport *)phba->targetport->private;
+ 		len += snprintf(buf + len, size - len,
+ 				"\nNVME Targetport Entry ...\n");
+ 
+ 		/* Port state is only one of two values for now. */
+ 		if (phba->targetport->port_id)
+ 			statep = "REGISTERED";
+ 		else
+ 			statep = "INIT";
+ 		len += snprintf(buf + len, size - len,
+ 				"TGT WWNN x%llx WWPN x%llx State %s\n",
+ 				wwn_to_u64(vport->fc_nodename.u.wwn),
+ 				wwn_to_u64(vport->fc_portname.u.wwn),
+ 				statep);
+ 		len += snprintf(buf + len, size - len,
+ 				"    Targetport DID x%06x\n",
+ 				phba->targetport->port_id);
+ 		goto out_exit;
+ 	}
+ 
+ 	len += snprintf(buf + len, size - len,
+ 				"\nNVME Lport/Rport Entries ...\n");
+ 
+ 	localport = vport->localport;
+ 	if (!localport)
+ 		goto out_exit;
+ 
+ 	spin_lock_irq(shost->host_lock);
+ 
+ 	/* Port state is only one of two values for now. */
+ 	if (localport->port_id)
+ 		statep = "ONLINE";
+ 	else
+ 		statep = "UNKNOWN ";
+ 
+ 	len += snprintf(buf + len, size - len,
+ 			"Lport DID x%06x PortState %s\n",
+ 			localport->port_id, statep);
+ 
+ 	len += snprintf(buf + len, size - len, "\tRport List:\n");
+ 	list_for_each_entry(ndlp, &vport->fc_nodes, nlp_listp) {
+ 		/* local short-hand pointer. */
+ 		if (!ndlp->nrport)
+ 			continue;
+ 
+ 		nrport = ndlp->nrport->remoteport;
+ 
+ 		/* Port state is only one of two values for now. */
+ 		switch (nrport->port_state) {
+ 		case FC_OBJSTATE_ONLINE:
+ 			statep = "ONLINE";
+ 			break;
+ 		case FC_OBJSTATE_UNKNOWN:
+ 			statep = "UNKNOWN ";
+ 			break;
+ 		default:
+ 			statep = "UNSUPPORTED";
+ 			break;
+ 		}
+ 
+ 		/* Tab in to show lport ownership. */
+ 		len += snprintf(buf + len, size - len,
+ 				"\t%s Port ID:x%06x ",
+ 				statep, nrport->port_id);
+ 		len += snprintf(buf + len, size - len, "WWPN x%llx ",
+ 				nrport->port_name);
+ 		len += snprintf(buf + len, size - len, "WWNN x%llx ",
+ 				nrport->node_name);
+ 		switch (nrport->port_role) {
+ 		case FC_PORT_ROLE_NVME_INITIATOR:
+ 			len +=  snprintf(buf + len, size - len,
+ 					 "NVME INITIATOR ");
+ 			break;
+ 		case FC_PORT_ROLE_NVME_TARGET:
+ 			len +=  snprintf(buf + len, size - len,
+ 					 "NVME TARGET ");
+ 			break;
+ 		case FC_PORT_ROLE_NVME_DISCOVERY:
+ 			len +=  snprintf(buf + len, size - len,
+ 					 "NVME DISCOVERY ");
+ 			break;
+ 		default:
+ 			len +=  snprintf(buf + len, size - len,
+ 					 "UNKNOWN ROLE x%x",
+ 					 nrport->port_role);
+ 			break;
+ 		}
+ 
+ 		/* Terminate the string. */
+ 		len +=  snprintf(buf + len, size - len, "\n");
+ 	}
+ 
+ 	spin_unlock_irq(shost->host_lock);
+  out_exit:
++>>>>>>> 80cc00439361 (scsi: lpfc: Fix transition nvme-i rport handling to nport only.)
  	return len;
  }
 -
 -/**
 - * lpfc_debugfs_nvmestat_data - Dump target node list to a buffer
 - * @vport: The vport to gather target node info from.
 - * @buf: The buffer to dump log into.
 - * @size: The maximum amount of data to process.
 - *
 - * Description:
 - * This routine dumps the NVME statistics associated with @vport
 - *
 - * Return Value:
 - * This routine returns the amount of bytes that were dumped into @buf and will
 - * not exceed @size.
 - **/
 -static int
 -lpfc_debugfs_nvmestat_data(struct lpfc_vport *vport, char *buf, int size)
 -{
 -	struct lpfc_hba   *phba = vport->phba;
 -	struct lpfc_nvmet_tgtport *tgtp;
 -	struct lpfc_nvmet_rcv_ctx *ctxp, *next_ctxp;
 -	int len = 0;
 -	int cnt;
 -
 -	if (phba->nvmet_support) {
 -		if (!phba->targetport)
 -			return len;
 -		tgtp = (struct lpfc_nvmet_tgtport *)phba->targetport->private;
 -		len += snprintf(buf + len, size - len,
 -				"\nNVME Targetport Statistics\n");
 -
 -		len += snprintf(buf + len, size - len,
 -				"LS: Rcv %08x Drop %08x Abort %08x\n",
 -				atomic_read(&tgtp->rcv_ls_req_in),
 -				atomic_read(&tgtp->rcv_ls_req_drop),
 -				atomic_read(&tgtp->xmt_ls_abort));
 -		if (atomic_read(&tgtp->rcv_ls_req_in) !=
 -		    atomic_read(&tgtp->rcv_ls_req_out)) {
 -			len += snprintf(buf + len, size - len,
 -					"Rcv LS: in %08x != out %08x\n",
 -					atomic_read(&tgtp->rcv_ls_req_in),
 -					atomic_read(&tgtp->rcv_ls_req_out));
 -		}
 -
 -		len += snprintf(buf + len, size - len,
 -				"LS: Xmt %08x Drop %08x Cmpl %08x Err %08x\n",
 -				atomic_read(&tgtp->xmt_ls_rsp),
 -				atomic_read(&tgtp->xmt_ls_drop),
 -				atomic_read(&tgtp->xmt_ls_rsp_cmpl),
 -				atomic_read(&tgtp->xmt_ls_rsp_error));
 -
 -		len += snprintf(buf + len, size - len,
 -				"FCP: Rcv %08x Drop %08x\n",
 -				atomic_read(&tgtp->rcv_fcp_cmd_in),
 -				atomic_read(&tgtp->rcv_fcp_cmd_drop));
 -
 -		if (atomic_read(&tgtp->rcv_fcp_cmd_in) !=
 -		    atomic_read(&tgtp->rcv_fcp_cmd_out)) {
 -			len += snprintf(buf + len, size - len,
 -					"Rcv FCP: in %08x != out %08x\n",
 -					atomic_read(&tgtp->rcv_fcp_cmd_in),
 -					atomic_read(&tgtp->rcv_fcp_cmd_out));
 -		}
 -
 -		len += snprintf(buf + len, size - len,
 -				"FCP Rsp: read %08x readrsp %08x "
 -				"write %08x rsp %08x\n",
 -				atomic_read(&tgtp->xmt_fcp_read),
 -				atomic_read(&tgtp->xmt_fcp_read_rsp),
 -				atomic_read(&tgtp->xmt_fcp_write),
 -				atomic_read(&tgtp->xmt_fcp_rsp));
 -
 -		len += snprintf(buf + len, size - len,
 -				"FCP Rsp Cmpl: %08x err %08x drop %08x\n",
 -				atomic_read(&tgtp->xmt_fcp_rsp_cmpl),
 -				atomic_read(&tgtp->xmt_fcp_rsp_error),
 -				atomic_read(&tgtp->xmt_fcp_rsp_drop));
 -
 -		len += snprintf(buf + len, size - len,
 -				"ABORT: Xmt %08x Cmpl %08x\n",
 -				atomic_read(&tgtp->xmt_fcp_abort),
 -				atomic_read(&tgtp->xmt_fcp_abort_cmpl));
 -
 -		len += snprintf(buf + len, size - len,
 -				"ABORT: Sol %08x  Usol %08x Err %08x Cmpl %08x",
 -				atomic_read(&tgtp->xmt_abort_sol),
 -				atomic_read(&tgtp->xmt_abort_unsol),
 -				atomic_read(&tgtp->xmt_abort_rsp),
 -				atomic_read(&tgtp->xmt_abort_rsp_error));
 -
 -		len +=  snprintf(buf + len, size - len, "\n");
 -
 -		cnt = 0;
 -		spin_lock(&phba->sli4_hba.abts_nvme_buf_list_lock);
 -		list_for_each_entry_safe(ctxp, next_ctxp,
 -				&phba->sli4_hba.lpfc_abts_nvmet_ctx_list,
 -				list) {
 -			cnt++;
 -		}
 -		spin_unlock(&phba->sli4_hba.abts_nvme_buf_list_lock);
 -		if (cnt) {
 -			len += snprintf(buf + len, size - len,
 -					"ABORT: %d ctx entries\n", cnt);
 -			spin_lock(&phba->sli4_hba.abts_nvme_buf_list_lock);
 -			list_for_each_entry_safe(ctxp, next_ctxp,
 -				    &phba->sli4_hba.lpfc_abts_nvmet_ctx_list,
 -				    list) {
 -				if (len >= (size - LPFC_DEBUG_OUT_LINE_SZ))
 -					break;
 -				len += snprintf(buf + len, size - len,
 -						"Entry: oxid %x state %x "
 -						"flag %x\n",
 -						ctxp->oxid, ctxp->state,
 -						ctxp->flag);
 -			}
 -			spin_unlock(&phba->sli4_hba.abts_nvme_buf_list_lock);
 -		}
 -
 -		len += snprintf(buf + len, size - len,
 -				"IO_CTX: %08x  outstanding %08x total %08x\n",
 -				phba->sli4_hba.nvmet_ctx_cnt,
 -				phba->sli4_hba.nvmet_io_wait_cnt,
 -				phba->sli4_hba.nvmet_io_wait_total);
 -	} else {
 -		if (!(phba->cfg_enable_fc4_type & LPFC_ENABLE_NVME))
 -			return len;
 -
 -		len += snprintf(buf + len, size - len,
 -				"\nNVME Lport Statistics\n");
 -
 -		len += snprintf(buf + len, size - len,
 -				"LS: Xmt %016llx Cmpl %016llx\n",
 -				phba->fc4NvmeLsRequests,
 -				phba->fc4NvmeLsCmpls);
 -
 -		len += snprintf(buf + len, size - len,
 -				"FCP: Rd %016llx Wr %016llx IO %016llx\n",
 -				phba->fc4NvmeInputRequests,
 -				phba->fc4NvmeOutputRequests,
 -				phba->fc4NvmeControlRequests);
 -
 -		len += snprintf(buf + len, size - len,
 -				"    Cmpl %016llx\n", phba->fc4NvmeIoCmpls);
 -	}
 -
 -	return len;
 -}
 -
 -
 -/**
 - * lpfc_debugfs_nvmektime_data - Dump target node list to a buffer
 - * @vport: The vport to gather target node info from.
 - * @buf: The buffer to dump log into.
 - * @size: The maximum amount of data to process.
 - *
 - * Description:
 - * This routine dumps the NVME statistics associated with @vport
 - *
 - * Return Value:
 - * This routine returns the amount of bytes that were dumped into @buf and will
 - * not exceed @size.
 - **/
 -static int
 -lpfc_debugfs_nvmektime_data(struct lpfc_vport *vport, char *buf, int size)
 -{
 -	struct lpfc_hba   *phba = vport->phba;
 -	int len = 0;
 -
 -	if (phba->nvmet_support == 0) {
 -		/* NVME Initiator */
 -		len += snprintf(buf + len, PAGE_SIZE - len,
 -				"ktime %s: Total Samples: %lld\n",
 -				(phba->ktime_on ?  "Enabled" : "Disabled"),
 -				phba->ktime_data_samples);
 -		if (phba->ktime_data_samples == 0)
 -			return len;
 -
 -		len += snprintf(
 -			buf + len, PAGE_SIZE - len,
 -			"Segment 1: Last NVME Cmd cmpl "
 -			"done -to- Start of next NVME cnd (in driver)\n");
 -		len += snprintf(
 -			buf + len, PAGE_SIZE - len,
 -			"avg:%08lld min:%08lld max %08lld\n",
 -			div_u64(phba->ktime_seg1_total,
 -				phba->ktime_data_samples),
 -			phba->ktime_seg1_min,
 -			phba->ktime_seg1_max);
 -		len += snprintf(
 -			buf + len, PAGE_SIZE - len,
 -			"Segment 2: Driver start of NVME cmd "
 -			"-to- Firmware WQ doorbell\n");
 -		len += snprintf(
 -			buf + len, PAGE_SIZE - len,
 -			"avg:%08lld min:%08lld max %08lld\n",
 -			div_u64(phba->ktime_seg2_total,
 -				phba->ktime_data_samples),
 -			phba->ktime_seg2_min,
 -			phba->ktime_seg2_max);
 -		len += snprintf(
 -			buf + len, PAGE_SIZE - len,
 -			"Segment 3: Firmware WQ doorbell -to- "
 -			"MSI-X ISR cmpl\n");
 -		len += snprintf(
 -			buf + len, PAGE_SIZE - len,
 -			"avg:%08lld min:%08lld max %08lld\n",
 -			div_u64(phba->ktime_seg3_total,
 -				phba->ktime_data_samples),
 -			phba->ktime_seg3_min,
 -			phba->ktime_seg3_max);
 -		len += snprintf(
 -			buf + len, PAGE_SIZE - len,
 -			"Segment 4: MSI-X ISR cmpl -to- "
 -			"NVME cmpl done\n");
 -		len += snprintf(
 -			buf + len, PAGE_SIZE - len,
 -			"avg:%08lld min:%08lld max %08lld\n",
 -			div_u64(phba->ktime_seg4_total,
 -				phba->ktime_data_samples),
 -			phba->ktime_seg4_min,
 -			phba->ktime_seg4_max);
 -		len += snprintf(
 -			buf + len, PAGE_SIZE - len,
 -			"Total IO avg time: %08lld\n",
 -			div_u64(phba->ktime_seg1_total +
 -			phba->ktime_seg2_total  +
 -			phba->ktime_seg3_total +
 -			phba->ktime_seg4_total,
 -			phba->ktime_data_samples));
 -		return len;
 -	}
 -
 -	/* NVME Target */
 -	len += snprintf(buf + len, PAGE_SIZE-len,
 -			"ktime %s: Total Samples: %lld %lld\n",
 -			(phba->ktime_on ? "Enabled" : "Disabled"),
 -			phba->ktime_data_samples,
 -			phba->ktime_status_samples);
 -	if (phba->ktime_data_samples == 0)
 -		return len;
 -
 -	len += snprintf(buf + len, PAGE_SIZE-len,
 -			"Segment 1: MSI-X ISR Rcv cmd -to- "
 -			"cmd pass to NVME Layer\n");
 -	len += snprintf(buf + len, PAGE_SIZE-len,
 -			"avg:%08lld min:%08lld max %08lld\n",
 -			div_u64(phba->ktime_seg1_total,
 -				phba->ktime_data_samples),
 -			phba->ktime_seg1_min,
 -			phba->ktime_seg1_max);
 -	len += snprintf(buf + len, PAGE_SIZE-len,
 -			"Segment 2: cmd pass to NVME Layer- "
 -			"-to- Driver rcv cmd OP (action)\n");
 -	len += snprintf(buf + len, PAGE_SIZE-len,
 -			"avg:%08lld min:%08lld max %08lld\n",
 -			div_u64(phba->ktime_seg2_total,
 -				phba->ktime_data_samples),
 -			phba->ktime_seg2_min,
 -			phba->ktime_seg2_max);
 -	len += snprintf(buf + len, PAGE_SIZE-len,
 -			"Segment 3: Driver rcv cmd OP -to- "
 -			"Firmware WQ doorbell: cmd\n");
 -	len += snprintf(buf + len, PAGE_SIZE-len,
 -			"avg:%08lld min:%08lld max %08lld\n",
 -			div_u64(phba->ktime_seg3_total,
 -				phba->ktime_data_samples),
 -			phba->ktime_seg3_min,
 -			phba->ktime_seg3_max);
 -	len += snprintf(buf + len, PAGE_SIZE-len,
 -			"Segment 4: Firmware WQ doorbell: cmd "
 -			"-to- MSI-X ISR for cmd cmpl\n");
 -	len += snprintf(buf + len, PAGE_SIZE-len,
 -			"avg:%08lld min:%08lld max %08lld\n",
 -			div_u64(phba->ktime_seg4_total,
 -				phba->ktime_data_samples),
 -			phba->ktime_seg4_min,
 -			phba->ktime_seg4_max);
 -	len += snprintf(buf + len, PAGE_SIZE-len,
 -			"Segment 5: MSI-X ISR for cmd cmpl "
 -			"-to- NVME layer passed cmd done\n");
 -	len += snprintf(buf + len, PAGE_SIZE-len,
 -			"avg:%08lld min:%08lld max %08lld\n",
 -			div_u64(phba->ktime_seg5_total,
 -				phba->ktime_data_samples),
 -			phba->ktime_seg5_min,
 -			phba->ktime_seg5_max);
 -
 -	if (phba->ktime_status_samples == 0) {
 -		len += snprintf(buf + len, PAGE_SIZE-len,
 -				"Total: cmd received by MSI-X ISR "
 -				"-to- cmd completed on wire\n");
 -		len += snprintf(buf + len, PAGE_SIZE-len,
 -				"avg:%08lld min:%08lld "
 -				"max %08lld\n",
 -				div_u64(phba->ktime_seg10_total,
 -					phba->ktime_data_samples),
 -				phba->ktime_seg10_min,
 -				phba->ktime_seg10_max);
 -		return len;
 -	}
 -
 -	len += snprintf(buf + len, PAGE_SIZE-len,
 -			"Segment 6: NVME layer passed cmd done "
 -			"-to- Driver rcv rsp status OP\n");
 -	len += snprintf(buf + len, PAGE_SIZE-len,
 -			"avg:%08lld min:%08lld max %08lld\n",
 -			div_u64(phba->ktime_seg6_total,
 -				phba->ktime_status_samples),
 -			phba->ktime_seg6_min,
 -			phba->ktime_seg6_max);
 -	len += snprintf(buf + len, PAGE_SIZE-len,
 -			"Segment 7: Driver rcv rsp status OP "
 -			"-to- Firmware WQ doorbell: status\n");
 -	len += snprintf(buf + len, PAGE_SIZE-len,
 -			"avg:%08lld min:%08lld max %08lld\n",
 -			div_u64(phba->ktime_seg7_total,
 -				phba->ktime_status_samples),
 -			phba->ktime_seg7_min,
 -			phba->ktime_seg7_max);
 -	len += snprintf(buf + len, PAGE_SIZE-len,
 -			"Segment 8: Firmware WQ doorbell: status"
 -			" -to- MSI-X ISR for status cmpl\n");
 -	len += snprintf(buf + len, PAGE_SIZE-len,
 -			"avg:%08lld min:%08lld max %08lld\n",
 -			div_u64(phba->ktime_seg8_total,
 -				phba->ktime_status_samples),
 -			phba->ktime_seg8_min,
 -			phba->ktime_seg8_max);
 -	len += snprintf(buf + len, PAGE_SIZE-len,
 -			"Segment 9: MSI-X ISR for status cmpl  "
 -			"-to- NVME layer passed status done\n");
 -	len += snprintf(buf + len, PAGE_SIZE-len,
 -			"avg:%08lld min:%08lld max %08lld\n",
 -			div_u64(phba->ktime_seg9_total,
 -				phba->ktime_status_samples),
 -			phba->ktime_seg9_min,
 -			phba->ktime_seg9_max);
 -	len += snprintf(buf + len, PAGE_SIZE-len,
 -			"Total: cmd received by MSI-X ISR -to- "
 -			"cmd completed on wire\n");
 -	len += snprintf(buf + len, PAGE_SIZE-len,
 -			"avg:%08lld min:%08lld max %08lld\n",
 -			div_u64(phba->ktime_seg10_total,
 -				phba->ktime_status_samples),
 -			phba->ktime_seg10_min,
 -			phba->ktime_seg10_max);
 -	return len;
 -}
 -
 -/**
 - * lpfc_debugfs_nvmeio_trc_data - Dump NVME IO trace list to a buffer
 - * @phba: The phba to gather target node info from.
 - * @buf: The buffer to dump log into.
 - * @size: The maximum amount of data to process.
 - *
 - * Description:
 - * This routine dumps the NVME IO trace associated with @phba
 - *
 - * Return Value:
 - * This routine returns the amount of bytes that were dumped into @buf and will
 - * not exceed @size.
 - **/
 -static int
 -lpfc_debugfs_nvmeio_trc_data(struct lpfc_hba *phba, char *buf, int size)
 -{
 -	struct lpfc_debugfs_nvmeio_trc *dtp;
 -	int i, state, index, skip;
 -	int len = 0;
 -
 -	state = phba->nvmeio_trc_on;
 -
 -	index = (atomic_read(&phba->nvmeio_trc_cnt) + 1) &
 -		(phba->nvmeio_trc_size - 1);
 -	skip = phba->nvmeio_trc_output_idx;
 -
 -	len += snprintf(buf + len, size - len,
 -			"%s IO Trace %s: next_idx %d skip %d size %d\n",
 -			(phba->nvmet_support ? "NVME" : "NVMET"),
 -			(state ? "Enabled" : "Disabled"),
 -			index, skip, phba->nvmeio_trc_size);
 -
 -	if (!phba->nvmeio_trc || state)
 -		return len;
 -
 -	/* trace MUST bhe off to continue */
 -
 -	for (i = index; i < phba->nvmeio_trc_size; i++) {
 -		if (skip) {
 -			skip--;
 -			continue;
 -		}
 -		dtp = phba->nvmeio_trc + i;
 -		phba->nvmeio_trc_output_idx++;
 -
 -		if (!dtp->fmt)
 -			continue;
 -
 -		len +=  snprintf(buf + len, size - len, dtp->fmt,
 -			dtp->data1, dtp->data2, dtp->data3);
 -
 -		if (phba->nvmeio_trc_output_idx >= phba->nvmeio_trc_size) {
 -			phba->nvmeio_trc_output_idx = 0;
 -			len += snprintf(buf + len, size - len,
 -					"Trace Complete\n");
 -			goto out;
 -		}
 -
 -		if (len >= (size - LPFC_DEBUG_OUT_LINE_SZ)) {
 -			len += snprintf(buf + len, size - len,
 -					"Trace Continue (%d of %d)\n",
 -					phba->nvmeio_trc_output_idx,
 -					phba->nvmeio_trc_size);
 -			goto out;
 -		}
 -	}
 -	for (i = 0; i < index; i++) {
 -		if (skip) {
 -			skip--;
 -			continue;
 -		}
 -		dtp = phba->nvmeio_trc + i;
 -		phba->nvmeio_trc_output_idx++;
 -
 -		if (!dtp->fmt)
 -			continue;
 -
 -		len +=  snprintf(buf + len, size - len, dtp->fmt,
 -			dtp->data1, dtp->data2, dtp->data3);
 -
 -		if (phba->nvmeio_trc_output_idx >= phba->nvmeio_trc_size) {
 -			phba->nvmeio_trc_output_idx = 0;
 -			len += snprintf(buf + len, size - len,
 -					"Trace Complete\n");
 -			goto out;
 -		}
 -
 -		if (len >= (size - LPFC_DEBUG_OUT_LINE_SZ)) {
 -			len += snprintf(buf + len, size - len,
 -					"Trace Continue (%d of %d)\n",
 -					phba->nvmeio_trc_output_idx,
 -					phba->nvmeio_trc_size);
 -			goto out;
 -		}
 -	}
 -
 -	len += snprintf(buf + len, size - len,
 -			"Trace Done\n");
 -out:
 -	return len;
 -}
 -
 -/**
 - * lpfc_debugfs_cpucheck_data - Dump target node list to a buffer
 - * @vport: The vport to gather target node info from.
 - * @buf: The buffer to dump log into.
 - * @size: The maximum amount of data to process.
 - *
 - * Description:
 - * This routine dumps the NVME statistics associated with @vport
 - *
 - * Return Value:
 - * This routine returns the amount of bytes that were dumped into @buf and will
 - * not exceed @size.
 - **/
 -static int
 -lpfc_debugfs_cpucheck_data(struct lpfc_vport *vport, char *buf, int size)
 -{
 -	struct lpfc_hba   *phba = vport->phba;
 -	int i;
 -	int len = 0;
 -	uint32_t tot_xmt = 0;
 -	uint32_t tot_rcv = 0;
 -	uint32_t tot_cmpl = 0;
 -	uint32_t tot_ccmpl = 0;
 -
 -	if (phba->nvmet_support == 0) {
 -		/* NVME Initiator */
 -		len += snprintf(buf + len, PAGE_SIZE - len,
 -				"CPUcheck %s\n",
 -				(phba->cpucheck_on & LPFC_CHECK_NVME_IO ?
 -					"Enabled" : "Disabled"));
 -		for (i = 0; i < phba->sli4_hba.num_present_cpu; i++) {
 -			if (i >= LPFC_CHECK_CPU_CNT)
 -				break;
 -			len += snprintf(buf + len, PAGE_SIZE - len,
 -					"%02d: xmit x%08x cmpl x%08x\n",
 -					i, phba->cpucheck_xmt_io[i],
 -					phba->cpucheck_cmpl_io[i]);
 -			tot_xmt += phba->cpucheck_xmt_io[i];
 -			tot_cmpl += phba->cpucheck_cmpl_io[i];
 -		}
 -		len += snprintf(buf + len, PAGE_SIZE - len,
 -				"tot:xmit x%08x cmpl x%08x\n",
 -				tot_xmt, tot_cmpl);
 -		return len;
 -	}
 -
 -	/* NVME Target */
 -	len += snprintf(buf + len, PAGE_SIZE - len,
 -			"CPUcheck %s ",
 -			(phba->cpucheck_on & LPFC_CHECK_NVMET_IO ?
 -				"IO Enabled - " : "IO Disabled - "));
 -	len += snprintf(buf + len, PAGE_SIZE - len,
 -			"%s\n",
 -			(phba->cpucheck_on & LPFC_CHECK_NVMET_RCV ?
 -				"Rcv Enabled\n" : "Rcv Disabled\n"));
 -	for (i = 0; i < phba->sli4_hba.num_present_cpu; i++) {
 -		if (i >= LPFC_CHECK_CPU_CNT)
 -			break;
 -		len += snprintf(buf + len, PAGE_SIZE - len,
 -				"%02d: xmit x%08x ccmpl x%08x "
 -				"cmpl x%08x rcv x%08x\n",
 -				i, phba->cpucheck_xmt_io[i],
 -				phba->cpucheck_ccmpl_io[i],
 -				phba->cpucheck_cmpl_io[i],
 -				phba->cpucheck_rcv_io[i]);
 -		tot_xmt += phba->cpucheck_xmt_io[i];
 -		tot_rcv += phba->cpucheck_rcv_io[i];
 -		tot_cmpl += phba->cpucheck_cmpl_io[i];
 -		tot_ccmpl += phba->cpucheck_ccmpl_io[i];
 -	}
 -	len += snprintf(buf + len, PAGE_SIZE - len,
 -			"tot:xmit x%08x ccmpl x%08x cmpl x%08x rcv x%08x\n",
 -			tot_xmt, tot_ccmpl, tot_cmpl, tot_rcv);
 -	return len;
 -}
 -
  #endif
  
  /**
* Unmerged path drivers/scsi/lpfc/lpfc_nvme.c
* Unmerged path drivers/scsi/lpfc/lpfc_nvme.h
* Unmerged path drivers/scsi/lpfc/lpfc_attr.c
* Unmerged path drivers/scsi/lpfc/lpfc_debugfs.c
* Unmerged path drivers/scsi/lpfc/lpfc_nvme.c
* Unmerged path drivers/scsi/lpfc/lpfc_nvme.h
