scsi: qla2xxx: Convert 32-bit LUN usage to 64-bit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Convert 32-bit LUN usage to 64-bit (Himanshu Madhani) [1460030]
Rebuild_FUZZ: 93.48%
commit-author Quinn Tran <quinn.tran@cavium.com>
commit f775bd14e44d23b1761ecdac637164654680111e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f775bd14.failed

	Acked-by: Nicholas Bellinger <nab@linux-iscsi.org>
	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Reviewed-by: Bart Van Assche <Bart.VanAssche@sandisk.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit f775bd14e44d23b1761ecdac637164654680111e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_target.c
#	drivers/scsi/qla2xxx/qla_target.h
#	drivers/scsi/qla2xxx/tcm_qla2xxx.c
diff --cc drivers/scsi/qla2xxx/qla_target.c
index f10c075d97ef,a1f33b06019d..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -1238,24 -1758,107 +1238,116 @@@ static void qlt_24xx_retry_term_exchang
  	    FCP_TMF_CMPL, true);
  }
  
++<<<<<<< HEAD
++=======
+ static int abort_cmd_for_tag(struct scsi_qla_host *vha, uint32_t tag)
+ {
+ 	struct qla_tgt_sess_op *op;
+ 	struct qla_tgt_cmd *cmd;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&vha->cmd_list_lock, flags);
+ 	list_for_each_entry(op, &vha->qla_sess_op_cmd_list, cmd_list) {
+ 		if (tag == op->atio.u.isp24.exchange_addr) {
+ 			op->aborted = true;
+ 			spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
+ 			return 1;
+ 		}
+ 	}
+ 
+ 	list_for_each_entry(op, &vha->unknown_atio_list, cmd_list) {
+ 		if (tag == op->atio.u.isp24.exchange_addr) {
+ 			op->aborted = true;
+ 			spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
+ 			return 1;
+ 		}
+ 	}
+ 
+ 	list_for_each_entry(cmd, &vha->qla_cmd_list, cmd_list) {
+ 		if (tag == cmd->atio.u.isp24.exchange_addr) {
+ 			cmd->aborted = 1;
+ 			spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
+ 			return 1;
+ 		}
+ 	}
+ 	spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
+ 
+ 	return 0;
+ }
+ 
+ /* drop cmds for the given lun
+  * XXX only looks for cmds on the port through which lun reset was recieved
+  * XXX does not go through the list of other port (which may have cmds
+  *     for the same lun)
+  */
+ static void abort_cmds_for_lun(struct scsi_qla_host *vha,
+ 			        u64 lun, uint8_t *s_id)
+ {
+ 	struct qla_tgt_sess_op *op;
+ 	struct qla_tgt_cmd *cmd;
+ 	uint32_t key;
+ 	unsigned long flags;
+ 
+ 	key = sid_to_key(s_id);
+ 	spin_lock_irqsave(&vha->cmd_list_lock, flags);
+ 	list_for_each_entry(op, &vha->qla_sess_op_cmd_list, cmd_list) {
+ 		uint32_t op_key;
+ 		u64 op_lun;
+ 
+ 		op_key = sid_to_key(op->atio.u.isp24.fcp_hdr.s_id);
+ 		op_lun = scsilun_to_int(
+ 			(struct scsi_lun *)&op->atio.u.isp24.fcp_cmnd.lun);
+ 		if (op_key == key && op_lun == lun)
+ 			op->aborted = true;
+ 	}
+ 
+ 	list_for_each_entry(op, &vha->unknown_atio_list, cmd_list) {
+ 		uint32_t op_key;
+ 		u64 op_lun;
+ 
+ 		op_key = sid_to_key(op->atio.u.isp24.fcp_hdr.s_id);
+ 		op_lun = scsilun_to_int(
+ 			(struct scsi_lun *)&op->atio.u.isp24.fcp_cmnd.lun);
+ 		if (op_key == key && op_lun == lun)
+ 			op->aborted = true;
+ 	}
+ 
+ 	list_for_each_entry(cmd, &vha->qla_cmd_list, cmd_list) {
+ 		uint32_t cmd_key;
+ 		u64 cmd_lun;
+ 
+ 		cmd_key = sid_to_key(cmd->atio.u.isp24.fcp_hdr.s_id);
+ 		cmd_lun = scsilun_to_int(
+ 			(struct scsi_lun *)&cmd->atio.u.isp24.fcp_cmnd.lun);
+ 		if (cmd_key == key && cmd_lun == lun)
+ 			cmd->aborted = 1;
+ 	}
+ 	spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
+ }
+ 
++>>>>>>> f775bd14e44d (scsi: qla2xxx: Convert 32-bit LUN usage to 64-bit)
  /* ha->hardware_lock supposed to be held on entry */
  static int __qlt_24xx_handle_abts(struct scsi_qla_host *vha,
 -	struct abts_recv_from_24xx *abts, struct fc_port *sess)
 +	struct abts_recv_from_24xx *abts, struct qla_tgt_sess *sess)
  {
  	struct qla_hw_data *ha = vha->hw;
  	struct se_session *se_sess = sess->se_sess;
  	struct qla_tgt_mgmt_cmd *mcmd;
+ 	struct qla_tgt_cmd *cmd;
  	struct se_cmd *se_cmd;
- 	u32 lun = 0;
  	int rc;
  	bool found_lun = false;
 -	unsigned long flags;
  
 -	spin_lock_irqsave(&se_sess->sess_cmd_lock, flags);
 +	spin_lock(&se_sess->sess_cmd_lock);
  	list_for_each_entry(se_cmd, &se_sess->sess_cmd_list, se_cmd_list) {
++<<<<<<< HEAD
 +		struct qla_tgt_cmd *cmd =
 +			container_of(se_cmd, struct qla_tgt_cmd, se_cmd);
 +		if (cmd->tag == abts->exchange_addr_to_abort) {
 +			lun = cmd->unpacked_lun;
++=======
+ 		if (se_cmd->tag == abts->exchange_addr_to_abort) {
++>>>>>>> f775bd14e44d (scsi: qla2xxx: Convert 32-bit LUN usage to 64-bit)
  			found_lun = true;
  			break;
  		}
@@@ -1281,8 -1896,9 +1374,12 @@@
  	mcmd->sess = sess;
  	memcpy(&mcmd->orig_iocb.abts, abts, sizeof(mcmd->orig_iocb.abts));
  	mcmd->reset_count = vha->hw->chip_reset;
 -	mcmd->tmr_func = QLA_TGT_ABTS;
  
++<<<<<<< HEAD
 +	rc = ha->tgt.tgt_ops->handle_tmr(mcmd, lun, TMR_ABORT_TASK,
++=======
+ 	rc = ha->tgt.tgt_ops->handle_tmr(mcmd, cmd->unpacked_lun, mcmd->tmr_func,
++>>>>>>> f775bd14e44d (scsi: qla2xxx: Convert 32-bit LUN usage to 64-bit)
  	    abts->exchange_addr_to_abort);
  	if (rc != 0) {
  		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf052,
@@@ -2870,17 -4331,22 +2967,28 @@@ static int qlt_handle_task_mgmt(struct 
  	struct atio_from_isp *a = (struct atio_from_isp *)iocb;
  	struct qla_hw_data *ha = vha->hw;
  	struct qla_tgt *tgt;
++<<<<<<< HEAD
 +	struct qla_tgt_sess *sess;
 +	uint32_t lun, unpacked_lun;
++=======
+ 	struct fc_port *sess;
+ 	u64 unpacked_lun;
++>>>>>>> f775bd14e44d (scsi: qla2xxx: Convert 32-bit LUN usage to 64-bit)
  	int fn;
 -	unsigned long flags;
  
 -	tgt = vha->vha_tgt.qla_tgt;
 +	tgt = ha->tgt.qla_tgt;
  
- 	lun = a->u.isp24.fcp_cmnd.lun;
  	fn = a->u.isp24.fcp_cmnd.task_mgmt_flags;
 -
 -	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
  	sess = ha->tgt.tgt_ops->find_sess_by_s_id(vha,
  	    a->u.isp24.fcp_hdr.s_id);
++<<<<<<< HEAD
 +	unpacked_lun = scsilun_to_int((struct scsi_lun *)&lun);
++=======
+ 	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ 
+ 	unpacked_lun =
+ 	    scsilun_to_int((struct scsi_lun *)&a->u.isp24.fcp_cmnd.lun);
++>>>>>>> f775bd14e44d (scsi: qla2xxx: Convert 32-bit LUN usage to 64-bit)
  
  	if (!sess) {
  		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf024,
@@@ -2916,11 -4385,12 +3024,11 @@@ static int __qlt_abort_task(struct scsi
  	memcpy(&mcmd->orig_iocb.imm_ntfy, iocb,
  	    sizeof(mcmd->orig_iocb.imm_ntfy));
  
- 	lun = a->u.isp24.fcp_cmnd.lun;
- 	unpacked_lun = scsilun_to_int((struct scsi_lun *)&lun);
+ 	unpacked_lun =
+ 	    scsilun_to_int((struct scsi_lun *)&a->u.isp24.fcp_cmnd.lun);
  	mcmd->reset_count = vha->hw->chip_reset;
 -	mcmd->tmr_func = QLA_TGT_2G_ABORT_TASK;
  
 -	rc = ha->tgt.tgt_ops->handle_tmr(mcmd, unpacked_lun, mcmd->tmr_func,
 +	rc = ha->tgt.tgt_ops->handle_tmr(mcmd, unpacked_lun, TMR_ABORT_TASK,
  	    le16_to_cpu(iocb->u.isp2x.seq_id));
  	if (rc != 0) {
  		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf060,
@@@ -4219,23 -5911,24 +4327,23 @@@ static void qlt_tmr_work(struct qla_tg
  	}
  
  	iocb = a;
- 	lun = a->u.isp24.fcp_cmnd.lun;
  	fn = a->u.isp24.fcp_cmnd.task_mgmt_flags;
- 	unpacked_lun = scsilun_to_int((struct scsi_lun *)&lun);
+ 	unpacked_lun =
+ 	    scsilun_to_int((struct scsi_lun *)&a->u.isp24.fcp_cmnd.lun);
  
  	rc = qlt_issue_task_mgmt(sess, unpacked_lun, fn, iocb, 0);
 -	ha->tgt.tgt_ops->put_sess(sess);
 -	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
 -
  	if (rc != 0)
  		goto out_term;
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +
 +	ha->tgt.tgt_ops->put_sess(sess);
  	return;
  
 -out_term2:
 +out_term:
 +	qlt_send_term_exchange(vha, NULL, &prm->tm_iocb2, 1);
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
  	if (sess)
  		ha->tgt.tgt_ops->put_sess(sess);
 -	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
 -out_term:
 -	qlt_send_term_exchange(vha, NULL, &prm->tm_iocb2, 1, 0);
  }
  
  static void qlt_sess_work_fn(struct work_struct *work)
diff --cc drivers/scsi/qla2xxx/qla_target.h
index b33e411f28a0,25ea90b8f6c9..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.h
+++ b/drivers/scsi/qla2xxx/qla_target.h
@@@ -641,7 -675,7 +641,11 @@@ struct qla_tgt_func_tmpl 
  	int (*handle_cmd)(struct scsi_qla_host *, struct qla_tgt_cmd *,
  			unsigned char *, uint32_t, int, int, int);
  	void (*handle_data)(struct qla_tgt_cmd *);
++<<<<<<< HEAD
 +	int (*handle_tmr)(struct qla_tgt_mgmt_cmd *, uint32_t, uint8_t,
++=======
+ 	int (*handle_tmr)(struct qla_tgt_mgmt_cmd *, u64, uint16_t,
++>>>>>>> f775bd14e44d (scsi: qla2xxx: Convert 32-bit LUN usage to 64-bit)
  			uint32_t);
  	void (*free_cmd)(struct qla_tgt_cmd *);
  	void (*free_mcmd)(struct qla_tgt_mgmt_cmd *);
@@@ -848,9 -884,9 +852,13 @@@ struct qla_tgt_cmd 
  	int sg_cnt;		/* SG segments count */
  	int bufflen;		/* cmd buffer length */
  	int offset;
++<<<<<<< HEAD
 +	uint32_t tag;
 +	uint32_t unpacked_lun;
++=======
+ 	u64 unpacked_lun;
++>>>>>>> f775bd14e44d (scsi: qla2xxx: Convert 32-bit LUN usage to 64-bit)
  	enum dma_data_direction dma_data_direction;
 -	uint32_t reset_count;
  
  	uint16_t loop_id;	/* to save extra sess dereferences */
  	struct qla_tgt *tgt;	/* to save extra sess dereferences */
diff --cc drivers/scsi/qla2xxx/tcm_qla2xxx.c
index 14250fcfe054,238abad4b481..000000000000
--- a/drivers/scsi/qla2xxx/tcm_qla2xxx.c
+++ b/drivers/scsi/qla2xxx/tcm_qla2xxx.c
@@@ -635,14 -595,50 +635,19 @@@ static void tcm_qla2xxx_handle_data(str
  /*
   * Called from qla_target.c:qlt_issue_task_mgmt()
   */
++<<<<<<< HEAD
 +static int tcm_qla2xxx_handle_tmr(struct qla_tgt_mgmt_cmd *mcmd, uint32_t lun,
 +	uint8_t tmr_func, uint32_t tag)
++=======
+ static int tcm_qla2xxx_handle_tmr(struct qla_tgt_mgmt_cmd *mcmd, u64 lun,
+ 	uint16_t tmr_func, uint32_t tag)
++>>>>>>> f775bd14e44d (scsi: qla2xxx: Convert 32-bit LUN usage to 64-bit)
  {
 -	struct fc_port *sess = mcmd->sess;
 +	struct qla_tgt_sess *sess = mcmd->sess;
  	struct se_cmd *se_cmd = &mcmd->se_cmd;
 -	int transl_tmr_func = 0;
 -
 -	switch (tmr_func) {
 -	case QLA_TGT_ABTS:
 -		pr_debug("%ld: ABTS received\n", sess->vha->host_no);
 -		transl_tmr_func = TMR_ABORT_TASK;
 -		break;
 -	case QLA_TGT_2G_ABORT_TASK:
 -		pr_debug("%ld: 2G Abort Task received\n", sess->vha->host_no);
 -		transl_tmr_func = TMR_ABORT_TASK;
 -		break;
 -	case QLA_TGT_CLEAR_ACA:
 -		pr_debug("%ld: CLEAR_ACA received\n", sess->vha->host_no);
 -		transl_tmr_func = TMR_CLEAR_ACA;
 -		break;
 -	case QLA_TGT_TARGET_RESET:
 -		pr_debug("%ld: TARGET_RESET received\n", sess->vha->host_no);
 -		transl_tmr_func = TMR_TARGET_WARM_RESET;
 -		break;
 -	case QLA_TGT_LUN_RESET:
 -		pr_debug("%ld: LUN_RESET received\n", sess->vha->host_no);
 -		transl_tmr_func = TMR_LUN_RESET;
 -		break;
 -	case QLA_TGT_CLEAR_TS:
 -		pr_debug("%ld: CLEAR_TS received\n", sess->vha->host_no);
 -		transl_tmr_func = TMR_CLEAR_TASK_SET;
 -		break;
 -	case QLA_TGT_ABORT_TS:
 -		pr_debug("%ld: ABORT_TS received\n", sess->vha->host_no);
 -		transl_tmr_func = TMR_ABORT_TASK_SET;
 -		break;
 -	default:
 -		pr_debug("%ld: Unknown task mgmt fn 0x%x\n",
 -		    sess->vha->host_no, tmr_func);
 -		return -ENOSYS;
 -	}
  
  	return target_submit_tmr(se_cmd, sess->se_sess, NULL, lun, mcmd,
 -	    transl_tmr_func, GFP_ATOMIC, tag, TARGET_SCF_ACK_KREF);
 +			tmr_func, GFP_ATOMIC, tag, TARGET_SCF_ACK_KREF);
  }
  
  static int tcm_qla2xxx_queue_data_in(struct se_cmd *se_cmd)
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.h
* Unmerged path drivers/scsi/qla2xxx/tcm_qla2xxx.c
