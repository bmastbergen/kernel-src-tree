net/mlx5: FPGA, Add SBU bypass and reset flows

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5: FPGA, Add SBU bypass and reset flows (Kamal Heib) [1456677 1456694]
Rebuild_FUZZ: 95.45%
commit-author Ilan Tayari <ilant@mellanox.com>
commit c43051d72a8dc4a00d49db27292a76d26e8df7af
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c43051d7.failed

The Innova FPGA includes shell hardware and Sandbox-Unit (SBU) hardware.
The shell hardware is handled by mlx5_core itself, while the SBU is
handled by a client driver.

Reset the SBU to a well-known initial state when initializing a new
device, and set the FPGA to bypass mode when uninitializing a device.
This allows the client driver to assume that its device has been
reset when a new device is detected.

During SBU reset, the FPGA is put into SBU-bypass mode. In this mode
packets do not pass through the SBU, so it cannot affect the network
data stream at all.

A factory-image does not have an SBU, so skip these flows.

	Signed-off-by: Ilan Tayari <ilant@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit c43051d72a8dc4a00d49db27292a76d26e8df7af)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/amso1100/c2_user.h
#	drivers/net/ethernet/mellanox/mlx5/core/fpga/cmd.c
#	drivers/net/ethernet/mellanox/mlx5/core/fpga/core.c
#	include/linux/mlx5/mlx5_ifc_fpga.h
diff --cc drivers/infiniband/hw/amso1100/c2_user.h
index 7e9e7ad65467,8943056163f3..000000000000
--- a/drivers/infiniband/hw/amso1100/c2_user.h
+++ b/drivers/infiniband/hw/amso1100/c2_user.h
@@@ -30,53 -28,54 +30,70 @@@
   * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
   * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
 + *
   */
  
 -#ifndef __MLX5_FPGA_H__
 -#define __MLX5_FPGA_H__
 +#ifndef C2_USER_H
 +#define C2_USER_H
 +
 +#include <linux/types.h>
  
 -#include <linux/mlx5/driver.h>
 +/*
 + * Make sure that all structs defined in this file remain laid out so
 + * that they pack the same way on 32-bit and 64-bit architectures (to
 + * avoid incompatibility between 32-bit userspace and 64-bit kernels).
 + * In particular do not use pointer types -- pass pointers in __u64
 + * instead.
 + */
  
 -enum mlx5_fpga_image {
 -	MLX5_FPGA_IMAGE_USER = 0,
 -	MLX5_FPGA_IMAGE_FACTORY,
 +struct c2_alloc_ucontext_resp {
 +	__u32 qp_tab_size;
 +	__u32 uarc_size;
  };
  
 -enum mlx5_fpga_status {
 -	MLX5_FPGA_STATUS_SUCCESS = 0,
 -	MLX5_FPGA_STATUS_FAILURE = 1,
 -	MLX5_FPGA_STATUS_IN_PROGRESS = 2,
 -	MLX5_FPGA_STATUS_NONE = 0xFFFF,
 +struct c2_alloc_pd_resp {
 +	__u32 pdn;
 +	__u32 reserved;
  };
  
 -struct mlx5_fpga_query {
 -	enum mlx5_fpga_image admin_image;
 -	enum mlx5_fpga_image oper_image;
 -	enum mlx5_fpga_status status;
 +struct c2_create_cq {
 +	__u32 lkey;
 +	__u32 pdn;
 +	__u64 arm_db_page;
 +	__u64 set_db_page;
 +	__u32 arm_db_index;
 +	__u32 set_db_index;
  };
  
 -enum mlx5_fpga_qpc_field_select {
 -	MLX5_FPGA_QPC_STATE = BIT(0),
 +struct c2_create_cq_resp {
 +	__u32 cqn;
 +	__u32 reserved;
  };
  
 -struct mlx5_fpga_qp_counters {
 -	u64 rx_ack_packets;
 -	u64 rx_send_packets;
 -	u64 tx_ack_packets;
 -	u64 tx_send_packets;
 -	u64 rx_total_drop;
 +struct c2_create_qp {
 +	__u32 lkey;
 +	__u32 reserved;
 +	__u64 sq_db_page;
 +	__u64 rq_db_page;
 +	__u32 sq_db_index;
 +	__u32 rq_db_index;
  };
  
++<<<<<<< HEAD:drivers/infiniband/hw/amso1100/c2_user.h
 +#endif				/* C2_USER_H */
++=======
+ int mlx5_fpga_caps(struct mlx5_core_dev *dev, u32 *caps);
+ int mlx5_fpga_query(struct mlx5_core_dev *dev, struct mlx5_fpga_query *query);
+ int mlx5_fpga_ctrl_op(struct mlx5_core_dev *dev, u8 op);
+ 
+ int mlx5_fpga_create_qp(struct mlx5_core_dev *dev, void *fpga_qpc,
+ 			u32 *fpga_qpn);
+ int mlx5_fpga_modify_qp(struct mlx5_core_dev *dev, u32 fpga_qpn,
+ 			enum mlx5_fpga_qpc_field_select fields, void *fpga_qpc);
+ int mlx5_fpga_query_qp(struct mlx5_core_dev *dev, u32 fpga_qpn, void *fpga_qpc);
+ int mlx5_fpga_query_qp_counters(struct mlx5_core_dev *dev, u32 fpga_qpn,
+ 				bool clear, struct mlx5_fpga_qp_counters *data);
+ int mlx5_fpga_destroy_qp(struct mlx5_core_dev *dev, u32 fpga_qpn);
+ 
+ #endif /* __MLX5_FPGA_H__ */
++>>>>>>> c43051d72a8d (net/mlx5: FPGA, Add SBU bypass and reset flows):drivers/net/ethernet/mellanox/mlx5/core/fpga/cmd.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fpga/cmd.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fpga/core.c
* Unmerged path include/linux/mlx5/mlx5_ifc_fpga.h
* Unmerged path drivers/infiniband/hw/amso1100/c2_user.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fpga/cmd.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fpga/core.c
* Unmerged path include/linux/mlx5/mlx5_ifc_fpga.h
