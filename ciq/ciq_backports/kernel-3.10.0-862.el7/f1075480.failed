ceph: tidy some white space in get_nonsnap_parent()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Dan Carpenter <dan.carpenter@oracle.com>
commit f107548039807eb890e65ce5cd29d6ac52562f09
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f1075480.failed

The white space here seems slightly messed up.

	Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit f107548039807eb890e65ce5cd29d6ac52562f09)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/mds_client.c
diff --cc fs/ceph/mds_client.c
index 698578eace16,c681762d76e6..000000000000
--- a/fs/ceph/mds_client.c
+++ b/fs/ceph/mds_client.c
@@@ -667,6 -673,28 +667,31 @@@ static void __unregister_request(struc
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Walk back up the dentry tree until we hit a dentry representing a
+  * non-snapshot inode. We do this using the rcu_read_lock (which must be held
+  * when calling this) to ensure that the objects won't disappear while we're
+  * working with them. Once we hit a candidate dentry, we attempt to take a
+  * reference to it, and return that as the result.
+  */
+ static struct inode *get_nonsnap_parent(struct dentry *dentry)
+ {
+ 	struct inode *inode = NULL;
+ 
+ 	while (dentry && !IS_ROOT(dentry)) {
+ 		inode = d_inode_rcu(dentry);
+ 		if (!inode || ceph_snap(inode) == CEPH_NOSNAP)
+ 			break;
+ 		dentry = dentry->d_parent;
+ 	}
+ 	if (inode)
+ 		inode = igrab(inode);
+ 	return inode;
+ }
+ 
+ /*
++>>>>>>> f10754803980 (ceph: tidy some white space in get_nonsnap_parent())
   * Choose mds to send request to next.  If there is a hint set in the
   * request (e.g., due to a prior forward hint from the mds), use that.
   * Otherwise, consult frag tree and/or caps to identify the
* Unmerged path fs/ceph/mds_client.c
