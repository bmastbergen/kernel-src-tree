KVM: nVMX: keep preemption timer enabled during L2 execution

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 9314006db8b781715658cd6a28994d84ccce5dee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9314006d.failed

Because the vmcs12 preemption timer is emulated through a separate hrtimer,
we can keep on using the preemption timer in the vmcs02 to emulare L1's
TSC deadline timer.

However, the corresponding bit in the pin-based execution control field
must be kept consistent between vmcs01 and vmcs02.  On vmentry we copy
it into the vmcs02; on vmexit the preemption timer must be disabled in
the vmcs01 if a preemption timer vmexit happened while in guest mode.

The preemption timer value in the vmcs02 is set by vmx_vcpu_run, so it
need not be considered in prepare_vmcs02.

	Cc: Yunhong Jiang <yunhong.jiang@intel.com>
	Cc: Haozhong Zhang <haozhong.zhang@intel.com>
	Tested-by: Wanpeng Li <kernellwp@gmail.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 9314006db8b781715658cd6a28994d84ccce5dee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index d3a1e70f1485,8cda4449a60e..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -10577,17 -10732,14 +10582,28 @@@ static void nested_vmx_vmexit(struct kv
  
  	load_vmcs12_host_state(vcpu, vmcs12);
  
++<<<<<<< HEAD
 +	/* Update TSC_OFFSET if TSC was changed while L2 ran */
 +	vmcs_write64(TSC_OFFSET, vcpu->arch.tsc_offset);
 +
 +	if (kvm_has_tsc_control)
 +		decache_tsc_multiplier(vmx);
 +
 +	if (vmx->nested.change_vmcs01_virtual_x2apic_mode) {
 +		vmx->nested.change_vmcs01_virtual_x2apic_mode = false;
 +		vmx_set_virtual_x2apic_mode(vcpu,
 +				vcpu->arch.apic_base & X2APIC_ENABLE);
 +	}
++=======
+ 	/* Update any VMCS fields that might have changed while L2 ran */
+ 	vmcs_write64(TSC_OFFSET, vmx->nested.vmcs01_tsc_offset);
+ 	if (vmx->hv_deadline_tsc == -1)
+ 		vmcs_clear_bits(PIN_BASED_VM_EXEC_CONTROL,
+ 				PIN_BASED_VMX_PREEMPTION_TIMER);
+ 	else
+ 		vmcs_set_bits(PIN_BASED_VM_EXEC_CONTROL,
+ 			      PIN_BASED_VMX_PREEMPTION_TIMER);
++>>>>>>> 9314006db8b7 (KVM: nVMX: keep preemption timer enabled during L2 execution)
  
  	/* This is needed for same reason as it was needed in prepare_vmcs02 */
  	vmx->host_rsp = 0;
* Unmerged path arch/x86/kvm/vmx.c
