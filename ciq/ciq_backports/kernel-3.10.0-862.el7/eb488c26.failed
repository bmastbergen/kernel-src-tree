nfp: introduce nfp_port

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit eb488c26d713b2a9ebba6c12bbefd04e01197693
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/eb488c26.failed

Encapsulate port information into struct nfp_port.  nfp_port will
soon be extended to contain devlink_port information.  It also makes
it easier to reuse port-related code between vNICs and representors.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Simon Horman <simon.horman@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit eb488c26d713b2a9ebba6c12bbefd04e01197693)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net.h
#	drivers/net/ethernet/netronome/nfp/nfp_net_common.c
#	drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
#	drivers/net/ethernet/netronome/nfp/nfp_net_main.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net.h
index 600c79f39fe0,8132dd31a6dd..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net.h
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net.h
@@@ -109,9 -113,14 +109,10 @@@
  
  /* Forward declarations */
  struct nfp_cpp;
 -struct nfp_eth_table_port;
  struct nfp_net;
  struct nfp_net_r_vector;
+ struct nfp_port;
  
 -/* Convenience macro for wrapping descriptor index on ring size */
 -#define D_IDX(ring, idx)	((idx) & ((ring)->cnt - 1))
 -
  /* Convenience macro for writing dma address into RX/TX descriptors */
  #define nfp_desc_set_dma_addr(desc, dma_addr)				\
  	do {								\
@@@ -471,25 -556,16 +472,32 @@@ static inline bool nfp_net_fw_ver_eq(st
   * @rx_bar:             Pointer to mapped FL/RX queues
   * @debugfs_dir:	Device directory in debugfs
   * @ethtool_dump_flag:	Ethtool dump flag
++<<<<<<< HEAD
 + * @port_list:		Entry on device port list
 + * @cpp:		CPP device handle if available
++=======
+  * @vnic_list:		Entry on device vNIC list
+  * @pdev:		Backpointer to PCI device
+  * @app:		APP handle if available
+  * @port:		Pointer to nfp_port structure if vNIC is a port
++>>>>>>> eb488c26d713 (nfp: introduce nfp_port)
   */
  struct nfp_net {
 -	struct nfp_net_dp dp;
 +	struct pci_dev *pdev;
 +	struct net_device *netdev;
  
 -	struct nfp_net_fw_version fw_ver;
 +	unsigned is_vf:1;
 +	unsigned fw_loaded:1;
 +
 +	u32 ctrl;
 +	u32 fl_bufsz;
 +
 +	u32 rx_offset;
  
 +	struct nfp_net_tx_ring *tx_rings;
 +	struct nfp_net_rx_ring *rx_rings;
 +
 +	struct nfp_net_fw_version fw_ver;
  	u32 cap;
  	u32 max_mtu;
  
@@@ -552,16 -626,12 +560,20 @@@
  	struct dentry *debugfs_dir;
  	u32 ethtool_dump_flag;
  
 -	struct list_head vnic_list;
 +	struct list_head port_list;
  
 -	struct pci_dev *pdev;
 -	struct nfp_app *app;
 +	struct nfp_cpp *cpp;
 +};
  
++<<<<<<< HEAD
 +struct nfp_net_ring_set {
 +	unsigned int n_rings;
 +	unsigned int mtu;
 +	unsigned int dcnt;
 +	void *rings;
++=======
+ 	struct nfp_port *port;
++>>>>>>> eb488c26d713 (nfp: introduce nfp_port)
  };
  
  /* Functions to read/write from/to a BAR
@@@ -757,12 -837,12 +776,15 @@@ void nfp_net_irqs_disable(struct pci_de
  void
  nfp_net_irqs_assign(struct nfp_net *nn, struct msix_entry *irq_entries,
  		    unsigned int n);
 -
 -struct nfp_net_dp *nfp_net_clone_dp(struct nfp_net *nn);
 -int nfp_net_ring_reconfig(struct nfp_net *nn, struct nfp_net_dp *new,
 -			  struct netlink_ext_ack *extack);
 +int
 +nfp_net_ring_reconfig(struct nfp_net *nn, struct nfp_net_ring_set *rx,
 +		      struct nfp_net_ring_set *tx);
  
  bool nfp_net_link_changed_read_clear(struct nfp_net *nn);
++<<<<<<< HEAD
 +void nfp_net_refresh_port_config(struct nfp_net *nn);
++=======
++>>>>>>> eb488c26d713 (nfp: introduce nfp_port)
  
  #ifdef CONFIG_NFP_DEBUG
  void nfp_net_debugfs_create(void);
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index 5094c56dbda7,15ef45a05c1e..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@@ -61,10 -64,13 +61,11 @@@
  
  #include <linux/ktime.h>
  
 -#include <net/pkt_cls.h>
  #include <net/vxlan.h>
  
 -#include "nfpcore/nfp_nsp.h"
  #include "nfp_net_ctrl.h"
  #include "nfp_net.h"
+ #include "nfp_port.h"
  
  /**
   * nfp_net_get_fw_version() - Read and parse the FW version
@@@ -2600,8 -2928,88 +2601,93 @@@ static void nfp_net_del_vxlan_port(stru
  		nfp_net_set_vxlan_port(nn, idx, 0);
  }
  
++<<<<<<< HEAD
 +static const struct net_device_ops nfp_net_netdev_ops = {
 +	.ndo_size		= sizeof(struct net_device_ops),
++=======
+ static int nfp_net_xdp_offload(struct nfp_net *nn, struct bpf_prog *prog)
+ {
+ 	struct tc_cls_bpf_offload cmd = {
+ 		.prog = prog,
+ 	};
+ 	int ret;
+ 
+ 	if (!nfp_net_ebpf_capable(nn))
+ 		return -EINVAL;
+ 
+ 	if (nn->dp.ctrl & NFP_NET_CFG_CTRL_BPF) {
+ 		if (!nn->dp.bpf_offload_xdp)
+ 			return prog ? -EBUSY : 0;
+ 		cmd.command = prog ? TC_CLSBPF_REPLACE : TC_CLSBPF_DESTROY;
+ 	} else {
+ 		if (!prog)
+ 			return 0;
+ 		cmd.command = TC_CLSBPF_ADD;
+ 	}
+ 
+ 	ret = nfp_net_bpf_offload(nn, &cmd);
+ 	/* Stop offload if replace not possible */
+ 	if (ret && cmd.command == TC_CLSBPF_REPLACE)
+ 		nfp_net_xdp_offload(nn, NULL);
+ 	nn->dp.bpf_offload_xdp = prog && !ret;
+ 	return ret;
+ }
+ 
+ static int nfp_net_xdp_setup(struct nfp_net *nn, struct netdev_xdp *xdp)
+ {
+ 	struct bpf_prog *old_prog = nn->dp.xdp_prog;
+ 	struct bpf_prog *prog = xdp->prog;
+ 	struct nfp_net_dp *dp;
+ 	int err;
+ 
+ 	if (!prog && !nn->dp.xdp_prog)
+ 		return 0;
+ 	if (prog && nn->dp.xdp_prog) {
+ 		prog = xchg(&nn->dp.xdp_prog, prog);
+ 		bpf_prog_put(prog);
+ 		nfp_net_xdp_offload(nn, nn->dp.xdp_prog);
+ 		return 0;
+ 	}
+ 
+ 	dp = nfp_net_clone_dp(nn);
+ 	if (!dp)
+ 		return -ENOMEM;
+ 
+ 	dp->xdp_prog = prog;
+ 	dp->num_tx_rings += prog ? nn->dp.num_rx_rings : -nn->dp.num_rx_rings;
+ 	dp->rx_dma_dir = prog ? DMA_BIDIRECTIONAL : DMA_FROM_DEVICE;
+ 	dp->rx_dma_off = prog ? XDP_PACKET_HEADROOM - nn->dp.rx_offset : 0;
+ 
+ 	/* We need RX reconfig to remap the buffers (BIDIR vs FROM_DEV) */
+ 	err = nfp_net_ring_reconfig(nn, dp, xdp->extack);
+ 	if (err)
+ 		return err;
+ 
+ 	if (old_prog)
+ 		bpf_prog_put(old_prog);
+ 
+ 	nfp_net_xdp_offload(nn, nn->dp.xdp_prog);
+ 
+ 	return 0;
+ }
+ 
+ static int nfp_net_xdp(struct net_device *netdev, struct netdev_xdp *xdp)
+ {
+ 	struct nfp_net *nn = netdev_priv(netdev);
+ 
+ 	switch (xdp->command) {
+ 	case XDP_SETUP_PROG:
+ 		return nfp_net_xdp_setup(nn, xdp);
+ 	case XDP_QUERY_PROG:
+ 		xdp->prog_attached = !!nn->dp.xdp_prog;
+ 		return 0;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ }
+ 
+ const struct net_device_ops nfp_net_netdev_ops = {
++>>>>>>> eb488c26d713 (nfp: introduce nfp_port)
  	.ndo_open		= nfp_net_netdev_open,
  	.ndo_stop		= nfp_net_netdev_close,
  	.ndo_start_xmit		= nfp_net_tx,
@@@ -2612,8 -3021,10 +2698,15 @@@
  	.ndo_set_mac_address	= eth_mac_addr,
  	.ndo_set_features	= nfp_net_set_features,
  	.ndo_features_check	= nfp_net_features_check,
++<<<<<<< HEAD
 +	.extended.ndo_udp_tunnel_add	= nfp_net_add_vxlan_port,
 +	.extended.ndo_udp_tunnel_del	= nfp_net_del_vxlan_port,
++=======
+ 	.ndo_get_phys_port_name	= nfp_port_get_phys_port_name,
+ 	.ndo_udp_tunnel_add	= nfp_net_add_vxlan_port,
+ 	.ndo_udp_tunnel_del	= nfp_net_del_vxlan_port,
+ 	.ndo_xdp		= nfp_net_xdp,
++>>>>>>> eb488c26d713 (nfp: introduce nfp_port)
  };
  
  /**
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
index 69f458e0de89,334020347ff2..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
@@@ -48,9 -49,11 +48,10 @@@
  #include <linux/ethtool.h>
  
  #include "nfpcore/nfp.h"
 -#include "nfpcore/nfp_nsp.h"
 -#include "nfp_app.h"
 +#include "nfpcore/nfp_nsp_eth.h"
  #include "nfp_net_ctrl.h"
  #include "nfp_net.h"
+ #include "nfp_port.h"
  
  enum nfp_dump_diag {
  	NFP_DUMP_NSP_DIAG = 0,
@@@ -190,15 -208,31 +194,42 @@@ nfp_net_get_link_ksettings(struct net_d
  	cmd->base.speed = SPEED_UNKNOWN;
  	cmd->base.duplex = DUPLEX_UNKNOWN;
  
++<<<<<<< HEAD
++=======
+ 	port = nfp_port_from_netdev(netdev);
+ 	eth_port = __nfp_port_get_eth_port(port);
+ 	if (eth_port)
+ 		cmd->base.autoneg = eth_port->aneg != NFP_ANEG_DISABLED ?
+ 			AUTONEG_ENABLE : AUTONEG_DISABLE;
+ 
++>>>>>>> eb488c26d713 (nfp: introduce nfp_port)
  	if (!netif_carrier_ok(netdev))
  		return 0;
  
+ 	if (!nfp_netdev_is_nfp_net(netdev))
+ 		return -EOPNOTSUPP;
+ 	nn = netdev_priv(netdev);
+ 
  	/* Use link speed from ETH table if available, otherwise try the BAR */
++<<<<<<< HEAD
 +	if (nn->eth_port && nfp_net_link_changed_read_clear(nn))
 +		nfp_net_refresh_port_config(nn);
 +	/* Separate if - on FW error the port could've disappeared from table */
 +	if (nn->eth_port) {
 +		cmd->base.speed = nn->eth_port->speed;
++=======
+ 	if (eth_port) {
+ 		int err;
+ 
+ 		if (nfp_net_link_changed_read_clear(nn)) {
+ 			err = nfp_net_refresh_eth_port(port);
+ 			if (err)
+ 				return err;
+ 		}
+ 
+ 		cmd->base.port = eth_port->port_type;
+ 		cmd->base.speed = eth_port->speed;
++>>>>>>> eb488c26d713 (nfp: introduce nfp_port)
  		cmd->base.duplex = DUPLEX_FULL;
  		return 0;
  	}
@@@ -235,7 -272,7 +269,11 @@@ nfp_net_set_link_ksettings(struct net_d
  		return -EBUSY;
  	}
  
++<<<<<<< HEAD
 +	nsp = nfp_eth_config_start(nn->cpp, nn->eth_port->index);
++=======
+ 	nsp = nfp_eth_config_start(port->app->cpp, eth_port->index);
++>>>>>>> eb488c26d713 (nfp: introduce nfp_port)
  	if (IS_ERR(nsp))
  		return PTR_ERR(nsp);
  
@@@ -255,7 -292,7 +293,11 @@@
  	if (err > 0)
  		return 0; /* no change */
  
++<<<<<<< HEAD
 +	nfp_net_refresh_port_config(nn);
++=======
+ 	nfp_net_refresh_port_table(port);
++>>>>>>> eb488c26d713 (nfp: introduce nfp_port)
  
  	return err;
  
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_main.c
index acc8cfe284f3,8e1e55187262..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
@@@ -130,14 -131,31 +131,29 @@@ err_area
  	return (u8 __iomem *)ERR_PTR(err);
  }
  
 -/**
 - * nfp_net_get_mac_addr() - Get the MAC address.
 - * @nn:       NFP Network structure
 - * @cpp:      NFP CPP handle
 - * @id:	      NFP port id
 - *
 - * First try to get the MAC address from NSP ETH table. If that
 - * fails try HWInfo.  As a last resort generate a random address.
 - */
  static void
 -nfp_net_get_mac_addr(struct nfp_net *nn, struct nfp_cpp *cpp, unsigned int id)
 +nfp_net_get_mac_addr_hwinfo(struct nfp_net *nn, struct nfp_cpp *cpp,
 +			    unsigned int id)
  {
++<<<<<<< HEAD
++=======
+ 	struct nfp_eth_table_port *eth_port;
+ 	struct nfp_net_dp *dp = &nn->dp;
++>>>>>>> eb488c26d713 (nfp: introduce nfp_port)
  	u8 mac_addr[ETH_ALEN];
  	const char *mac_str;
  	char name[32];
  
++<<<<<<< HEAD
++=======
+ 	eth_port = __nfp_port_get_eth_port(nn->port);
+ 	if (eth_port) {
+ 		ether_addr_copy(dp->netdev->dev_addr, eth_port->mac_addr);
+ 		ether_addr_copy(dp->netdev->perm_addr, eth_port->mac_addr);
+ 		return;
+ 	}
+ 
++>>>>>>> eb488c26d713 (nfp: introduce nfp_port)
  	snprintf(name, sizeof(name), "eth%d.mac", id);
  
  	mac_str = nfp_hwinfo_lookup(cpp, name);
@@@ -268,7 -271,15 +284,19 @@@ static u8 __iomem *nfp_net_pf_map_ctrl_
  	return ctrl_bar;
  }
  
++<<<<<<< HEAD
 +static void nfp_net_pf_free_netdevs(struct nfp_pf *pf)
++=======
+ static void nfp_net_pf_free_vnic(struct nfp_pf *pf, struct nfp_net *nn)
+ {
+ 	nfp_port_free(nn->port);
+ 	list_del(&nn->vnic_list);
+ 	pf->num_vnics--;
+ 	nfp_net_free(nn);
+ }
+ 
+ static void nfp_net_pf_free_vnics(struct nfp_pf *pf)
++>>>>>>> eb488c26d713 (nfp: introduce nfp_port)
  {
  	struct nfp_net *nn;
  
@@@ -281,10 -290,12 +309,11 @@@
  }
  
  static struct nfp_net *
 -nfp_net_pf_alloc_vnic(struct nfp_pf *pf, void __iomem *ctrl_bar,
 -		      void __iomem *tx_bar, void __iomem *rx_bar,
 -		      int stride, struct nfp_net_fw_version *fw_ver,
 -		      unsigned int eth_id)
 +nfp_net_pf_alloc_port_netdev(struct nfp_pf *pf, void __iomem *ctrl_bar,
 +			     void __iomem *tx_bar, void __iomem *rx_bar,
 +			     int stride, struct nfp_net_fw_version *fw_ver)
  {
+ 	struct nfp_eth_table_port *eth_port;
  	u32 n_tx_rings, n_rx_rings;
  	struct nfp_net *nn;
  
@@@ -296,14 -307,29 +325,32 @@@
  	if (IS_ERR(nn))
  		return nn;
  
 -	nn->app = pf->app;
 +	nn->cpp = pf->cpp;
  	nn->fw_ver = *fw_ver;
 -	nn->dp.ctrl_bar = ctrl_bar;
 +	nn->ctrl_bar = ctrl_bar;
  	nn->tx_bar = tx_bar;
  	nn->rx_bar = rx_bar;
 -	nn->dp.is_vf = 0;
 +	nn->is_vf = 0;
  	nn->stride_rx = stride;
  	nn->stride_tx = stride;
++<<<<<<< HEAD
++=======
+ 
+ 	eth_port = nfp_net_find_port(pf->eth_tbl, eth_id);
+ 	if (eth_port) {
+ 		nn->port = nfp_port_alloc(pf->app, NFP_PORT_PHYS_PORT,
+ 					  nn->dp.netdev);
+ 		if (IS_ERR(nn->port)) {
+ 			nfp_net_free(nn);
+ 			return ERR_CAST(nn->port);
+ 		}
+ 		nn->port->eth_id = eth_id;
+ 		nn->port->eth_port = eth_port;
+ 	}
+ 
+ 	pf->num_vnics++;
+ 	list_add_tail(&nn->vnic_list, &pf->vnics);
++>>>>>>> eb488c26d713 (nfp: introduce nfp_port)
  
  	return nn;
  }
@@@ -361,11 -392,25 +408,26 @@@ nfp_net_pf_alloc_netdevs(struct nfp_pf 
  			err = PTR_ERR(nn);
  			goto err_free_prev;
  		}
 +		list_add_tail(&nn->port_list, &pf->ports);
  
  		ctrl_bar += NFP_PF_CSR_SLICE_SIZE;
++<<<<<<< HEAD
++=======
+ 
+ 		/* Check if vNIC has external port associated and cfg is OK */
+ 		if (pf->eth_tbl && !nn->port) {
+ 			nfp_err(pf->cpp, "NSP port entries don't match vNICs (no entry for port #%d)\n", i);
+ 			err = -EINVAL;
+ 			goto err_free_prev;
+ 		}
+ 		if (nn->port && nn->port->eth_port->override_changed) {
+ 			nfp_warn(pf->cpp, "Config changed for port #%d, reboot required before port will be operational\n", i);
+ 			nfp_net_pf_free_vnic(pf, nn);
+ 			continue;
+ 		}
++>>>>>>> eb488c26d713 (nfp: introduce nfp_port)
  	}
  
 -	if (list_empty(&pf->vnics))
 -		return -ENODEV;
 -
  	return 0;
  
  err_free_prev:
@@@ -463,65 -522,95 +525,134 @@@ static void nfp_net_refresh_netdevs(str
  {
  	struct nfp_pf *pf = container_of(work, struct nfp_pf,
  					 port_refresh_work);
 -	struct nfp_eth_table *eth_table;
  	struct nfp_net *nn, *next;
  
 -	mutex_lock(&pf->lock);
 +	mutex_lock(&pf->port_lock);
  
  	/* Check for nfp_net_pci_remove() racing against us */
 -	if (list_empty(&pf->vnics))
 +	if (list_empty(&pf->ports))
  		goto out;
  
++<<<<<<< HEAD
 +	list_for_each_entry_safe(nn, next, &pf->ports, port_list) {
 +		if (!nn->eth_port) {
 +			nfp_warn(pf->cpp, "Warning: port not present after reconfig\n");
 +			continue;
 +		}
 +		if (!nn->eth_port->override_changed)
++=======
+ 	list_for_each_entry(nn, &pf->vnics, vnic_list)
+ 		nfp_net_link_changed_read_clear(nn);
+ 
+ 	eth_table = nfp_eth_read_ports(pf->cpp);
+ 	if (!eth_table) {
+ 		nfp_err(pf->cpp, "Error refreshing port config!\n");
+ 		goto out;
+ 	}
+ 
+ 	rtnl_lock();
+ 	list_for_each_entry(nn, &pf->vnics, vnic_list) {
+ 		if (!__nfp_port_get_eth_port(nn->port))
+ 			continue;
+ 		nn->port->eth_port = nfp_net_find_port(eth_table,
+ 						       nn->port->eth_id);
+ 		if (!nn->port->eth_port) {
+ 			nfp_warn(pf->cpp, "Warning: port #%d not present after reconfig\n",
+ 				 nn->port->eth_id);
  			continue;
+ 		}
+ 		if (nn->port->eth_port->override_changed) {
+ 			nfp_warn(pf->cpp, "Port config changed, unregistering. Reboot required before port will be operational again.\n");
+ 			nn->port->type = NFP_PORT_INVALID;
+ 			continue;
+ 		}
+ 	}
+ 	rtnl_unlock();
+ 
+ 	kfree(pf->eth_tbl);
+ 	pf->eth_tbl = eth_table;
  
- 		nn_warn(nn, "Port config changed, unregistering. Reboot required before port will be operational again.\n");
+ 	list_for_each_entry_safe(nn, next, &pf->vnics, vnic_list) {
+ 		if (!nn->port || nn->port->type != NFP_PORT_INVALID)
++>>>>>>> eb488c26d713 (nfp: introduce nfp_port)
+ 			continue;
  
  		nfp_net_debugfs_dir_clean(&nn->debugfs_dir);
 -		nfp_net_clean(nn);
 +		nfp_net_netdev_clean(nn->dp.netdev);
  
 -		nfp_net_pf_free_vnic(pf, nn);
 +		list_del(&nn->port_list);
 +		pf->num_netdevs--;
 +		nfp_net_netdev_free(nn);
  	}
  
 -	if (list_empty(&pf->vnics))
 +	if (list_empty(&pf->ports))
  		nfp_net_pci_remove_finish(pf);
  out:
 -	mutex_unlock(&pf->lock);
 +	mutex_unlock(&pf->port_lock);
  }
  
++<<<<<<< HEAD
 +void nfp_net_refresh_port_config(struct nfp_net *nn)
 +{
 +	struct nfp_pf *pf = pci_get_drvdata(nn->pdev);
 +	struct nfp_eth_table *old_table;
 +
 +	ASSERT_RTNL();
 +
 +	old_table = pf->eth_tbl;
 +
 +	list_for_each_entry(nn, &pf->ports, port_list)
 +		nfp_net_link_changed_read_clear(nn);
 +
 +	pf->eth_tbl = nfp_eth_read_ports(pf->cpp);
 +	if (!pf->eth_tbl) {
 +		pf->eth_tbl = old_table;
 +		nfp_err(pf->cpp, "Error refreshing port config!\n");
 +		return;
 +	}
 +
 +	list_for_each_entry(nn, &pf->ports, port_list)
 +		nn->eth_port = nfp_net_find_port(pf, nn->eth_port->eth_index);
 +
 +	kfree(old_table);
++=======
+ void nfp_net_refresh_port_table(struct nfp_port *port)
+ {
+ 	struct nfp_pf *pf = port->app->pf;
++>>>>>>> eb488c26d713 (nfp: introduce nfp_port)
  
  	schedule_work(&pf->port_refresh_work);
  }
  
++<<<<<<< HEAD
++=======
+ int nfp_net_refresh_eth_port(struct nfp_port *port)
+ {
+ 	struct nfp_cpp *cpp = port->app->cpp;
+ 	struct nfp_eth_table_port *eth_port;
+ 	struct nfp_eth_table *eth_table;
+ 
+ 	eth_table = nfp_eth_read_ports(cpp);
+ 	if (!eth_table) {
+ 		nfp_err(cpp, "Error refreshing port state table!\n");
+ 		return -EIO;
+ 	}
+ 
+ 	eth_port = nfp_net_find_port(eth_table, port->eth_id);
+ 	if (!eth_port) {
+ 		nfp_err(cpp, "Error finding state of the port!\n");
+ 		kfree(eth_table);
+ 		return -EIO;
+ 	}
+ 
+ 	memcpy(port->eth_port, eth_port, sizeof(*eth_port));
+ 
+ 	kfree(eth_table);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> eb488c26d713 (nfp: introduce nfp_port)
  /*
   * PCI device functions
   */
diff --git a/drivers/net/ethernet/netronome/nfp/Makefile b/drivers/net/ethernet/netronome/nfp/Makefile
index a30f2e651180..f706e0ade627 100644
--- a/drivers/net/ethernet/netronome/nfp/Makefile
+++ b/drivers/net/ethernet/netronome/nfp/Makefile
@@ -18,6 +18,7 @@ nfp-objs := \
 	    nfp_net_common.o \
 	    nfp_net_ethtool.o \
 	    nfp_net_main.o \
-	    nfp_netvf_main.o
+	    nfp_netvf_main.o \
+	    nfp_port.o
 
 nfp-$(CONFIG_NFP_DEBUG) += nfp_net_debugfs.o
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net.h
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_common.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_main.c
diff --git a/drivers/net/ethernet/netronome/nfp/nfp_port.c b/drivers/net/ethernet/netronome/nfp/nfp_port.c
new file mode 100644
index 000000000000..95726e01592d
--- /dev/null
+++ b/drivers/net/ethernet/netronome/nfp/nfp_port.c
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2017 Netronome Systems, Inc.
+ *
+ * This software is dual licensed under the GNU General License Version 2,
+ * June 1991 as shown in the file COPYING in the top-level directory of this
+ * source tree or the BSD 2-Clause License provided below.  You have the
+ * option to license this software under the complete terms of either license.
+ *
+ * The BSD 2-Clause License:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      1. Redistributions of source code must retain the above
+ *         copyright notice, this list of conditions and the following
+ *         disclaimer.
+ *
+ *      2. Redistributions in binary form must reproduce the above
+ *         copyright notice, this list of conditions and the following
+ *         disclaimer in the documentation and/or other materials
+ *         provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#include "nfpcore/nfp_nsp.h"
+#include "nfp_app.h"
+#include "nfp_main.h"
+#include "nfp_net.h"
+#include "nfp_port.h"
+
+struct nfp_port *nfp_port_from_netdev(struct net_device *netdev)
+{
+	struct nfp_net *nn;
+
+	if (WARN_ON(!nfp_netdev_is_nfp_net(netdev)))
+		return NULL;
+	nn = netdev_priv(netdev);
+
+	return nn->port;
+}
+
+struct nfp_eth_table_port *__nfp_port_get_eth_port(struct nfp_port *port)
+{
+	if (!port)
+		return NULL;
+	if (port->type != NFP_PORT_PHYS_PORT)
+		return NULL;
+
+	return port->eth_port;
+}
+
+int
+nfp_port_get_phys_port_name(struct net_device *netdev, char *name, size_t len)
+{
+	struct nfp_eth_table_port *eth_port;
+	struct nfp_port *port;
+	int n;
+
+	port = nfp_port_from_netdev(netdev);
+	eth_port = __nfp_port_get_eth_port(port);
+	if (!eth_port)
+		return -EOPNOTSUPP;
+
+	if (!eth_port->is_split)
+		n = snprintf(name, len, "p%d", eth_port->label_port);
+	else
+		n = snprintf(name, len, "p%ds%d", eth_port->label_port,
+			     eth_port->label_subport);
+	if (n >= len)
+		return -EINVAL;
+
+	return 0;
+}
+
+struct nfp_port *
+nfp_port_alloc(struct nfp_app *app, enum nfp_port_type type,
+	       struct net_device *netdev)
+{
+	struct nfp_port *port;
+
+	port = kzalloc(sizeof(*port), GFP_KERNEL);
+	if (!port)
+		return ERR_PTR(-ENOMEM);
+
+	port->netdev = netdev;
+	port->type = type;
+	port->app = app;
+
+	return port;
+}
+
+void nfp_port_free(struct nfp_port *port)
+{
+	kfree(port);
+}
diff --git a/drivers/net/ethernet/netronome/nfp/nfp_port.h b/drivers/net/ethernet/netronome/nfp/nfp_port.h
new file mode 100644
index 000000000000..341e7e128233
--- /dev/null
+++ b/drivers/net/ethernet/netronome/nfp/nfp_port.h
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2017 Netronome Systems, Inc.
+ *
+ * This software is dual licensed under the GNU General License Version 2,
+ * June 1991 as shown in the file COPYING in the top-level directory of this
+ * source tree or the BSD 2-Clause License provided below.  You have the
+ * option to license this software under the complete terms of either license.
+ *
+ * The BSD 2-Clause License:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      1. Redistributions of source code must retain the above
+ *         copyright notice, this list of conditions and the following
+ *         disclaimer.
+ *
+ *      2. Redistributions in binary form must reproduce the above
+ *         copyright notice, this list of conditions and the following
+ *         disclaimer in the documentation and/or other materials
+ *         provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#ifndef _NFP_PORT_H_
+#define _NFP_PORT_H_
+
+struct net_device;
+struct nfp_app;
+struct nfp_port;
+
+/**
+ * enum nfp_port_type - type of port NFP can switch traffic to
+ * @NFP_PORT_INVALID:	port is invalid, %NFP_PORT_PHYS_PORT transitions to this
+ *			state when port disappears because of FW fault or config
+ *			change
+ * @NFP_PORT_PHYS_PORT:	external NIC port
+ */
+enum nfp_port_type {
+	NFP_PORT_INVALID,
+	NFP_PORT_PHYS_PORT,
+};
+
+/**
+ * struct nfp_port - structure representing NFP port
+ * @netdev:	backpointer to associated netdev
+ * @type:	what port type does the entity represent
+ * @app:	backpointer to the app structure
+ * @eth_id:	for %NFP_PORT_PHYS_PORT port ID in NFP enumeration scheme
+ * @eth_port:	for %NFP_PORT_PHYS_PORT translated ETH Table port entry
+ */
+struct nfp_port {
+	struct net_device *netdev;
+	enum nfp_port_type type;
+
+	struct nfp_app *app;
+
+	unsigned int eth_id;
+	struct nfp_eth_table_port *eth_port;
+};
+
+struct nfp_port *nfp_port_from_netdev(struct net_device *netdev);
+struct nfp_eth_table_port *__nfp_port_get_eth_port(struct nfp_port *port);
+
+int
+nfp_port_get_phys_port_name(struct net_device *netdev, char *name, size_t len);
+
+struct nfp_port *
+nfp_port_alloc(struct nfp_app *app, enum nfp_port_type type,
+	       struct net_device *netdev);
+void nfp_port_free(struct nfp_port *port);
+
+int nfp_net_refresh_eth_port(struct nfp_port *port);
+void nfp_net_refresh_port_table(struct nfp_port *port);
+
+#endif
