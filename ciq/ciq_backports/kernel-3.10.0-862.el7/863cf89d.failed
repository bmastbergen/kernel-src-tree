IB/hfi1: Add 16B trace support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Don Hiatt <don.hiatt@intel.com>
commit 863cf89d472fe7a61305b06de84b9ed2dea02611
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/863cf89d.failed

Add trace support to 16B bypass packets during send and
receive.

Sample input header trace:
<idle>-0     [000] d.h. 271742.509477: input_ibhdr: [0000:05:00.0] (16B)
len:24 sc:0 dlid:0xf0000b slid:0x10002 age:0 becn:0 fecn:0 l4:10 rc:0
sc:0 pkey:0x8001 entropy:0x0000 op:0x65,UD_SEND_ONLY_WITH_IMMEDIATE se:0
m:1 pad:3 tver:0 qpn:0xffffff a:0 psn:0x00000001 hlen:248 deth qkey
0x01234567 sqpn 0x000004

	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Don Hiatt <don.hiatt@intel.com>
	Signed-off-by: Dasaratharaman Chandramouli <dasaratharaman.chandramouli@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 863cf89d472fe7a61305b06de84b9ed2dea02611)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/hfi.h
#	drivers/infiniband/hw/hfi1/trace_ibhdrs.h
diff --cc drivers/infiniband/hw/hfi1/hfi.h
index 9719cf207532,b07f42cfa5bf..000000000000
--- a/drivers/infiniband/hw/hfi1/hfi.h
+++ b/drivers/infiniband/hw/hfi1/hfi.h
@@@ -372,10 -344,131 +372,128 @@@ struct hfi1_packet 
  	u8 numpkt;
  	u8 rsize;
  	u8 updegr;
 +	u8 rcv_flags;
  	u8 etype;
 -	u8 extra_byte;
 -	u8 pad;
 -	u8 sc;
 -	u8 sl;
 -	u8 opcode;
 -	bool becn;
 -	bool fecn;
  };
  
++<<<<<<< HEAD
++=======
+ /* Packet types */
+ #define HFI1_PKT_TYPE_9B  0
+ #define HFI1_PKT_TYPE_16B 1
+ 
+ /*
+  * OPA 16B Header
+  */
+ #define OPA_16B_L4_MASK		0xFFull
+ #define OPA_16B_SC_MASK		0x1F00000ull
+ #define OPA_16B_SC_SHIFT	20
+ #define OPA_16B_LID_MASK	0xFFFFFull
+ #define OPA_16B_DLID_MASK	0xF000ull
+ #define OPA_16B_DLID_SHIFT	20
+ #define OPA_16B_DLID_HIGH_SHIFT	12
+ #define OPA_16B_SLID_MASK	0xF00ull
+ #define OPA_16B_SLID_SHIFT	20
+ #define OPA_16B_SLID_HIGH_SHIFT	8
+ #define OPA_16B_BECN_MASK       0x80000000ull
+ #define OPA_16B_BECN_SHIFT      31
+ #define OPA_16B_FECN_MASK       0x10000000ull
+ #define OPA_16B_FECN_SHIFT      28
+ #define OPA_16B_L2_MASK		0x60000000ull
+ #define OPA_16B_L2_SHIFT	29
+ #define OPA_16B_PKEY_MASK	0xFFFF0000ull
+ #define OPA_16B_PKEY_SHIFT	16
+ #define OPA_16B_LEN_MASK	0x7FF00000ull
+ #define OPA_16B_LEN_SHIFT	20
+ #define OPA_16B_RC_MASK		0xE000000ull
+ #define OPA_16B_RC_SHIFT	25
+ #define OPA_16B_AGE_MASK	0xFF0000ull
+ #define OPA_16B_AGE_SHIFT	16
+ #define OPA_16B_ENTROPY_MASK	0xFFFFull
+ 
+ /*
+  * OPA 16B L2/L4 Encodings
+  */
+ #define OPA_16B_L2_TYPE		0x02
+ #define OPA_16B_L4_IB_LOCAL	0x09
+ #define OPA_16B_L4_IB_GLOBAL	0x0A
+ #define OPA_16B_L4_ETHR		OPA_VNIC_L4_ETHR
+ 
+ static inline u8 hfi1_16B_get_l4(struct hfi1_16b_header *hdr)
+ {
+ 	return (u8)(hdr->lrh[2] & OPA_16B_L4_MASK);
+ }
+ 
+ static inline u8 hfi1_16B_get_sc(struct hfi1_16b_header *hdr)
+ {
+ 	return (u8)((hdr->lrh[1] & OPA_16B_SC_MASK) >> OPA_16B_SC_SHIFT);
+ }
+ 
+ static inline u32 hfi1_16B_get_dlid(struct hfi1_16b_header *hdr)
+ {
+ 	return (u32)((hdr->lrh[1] & OPA_16B_LID_MASK) |
+ 		     (((hdr->lrh[2] & OPA_16B_DLID_MASK) >>
+ 		     OPA_16B_DLID_HIGH_SHIFT) << OPA_16B_DLID_SHIFT));
+ }
+ 
+ static inline u32 hfi1_16B_get_slid(struct hfi1_16b_header *hdr)
+ {
+ 	return (u32)((hdr->lrh[0] & OPA_16B_LID_MASK) |
+ 		     (((hdr->lrh[2] & OPA_16B_SLID_MASK) >>
+ 		     OPA_16B_SLID_HIGH_SHIFT) << OPA_16B_SLID_SHIFT));
+ }
+ 
+ static inline u8 hfi1_16B_get_becn(struct hfi1_16b_header *hdr)
+ {
+ 	return (u8)((hdr->lrh[0] & OPA_16B_BECN_MASK) >> OPA_16B_BECN_SHIFT);
+ }
+ 
+ static inline u8 hfi1_16B_get_fecn(struct hfi1_16b_header *hdr)
+ {
+ 	return (u8)((hdr->lrh[1] & OPA_16B_FECN_MASK) >> OPA_16B_FECN_SHIFT);
+ }
+ 
+ static inline u8 hfi1_16B_get_l2(struct hfi1_16b_header *hdr)
+ {
+ 	return (u8)((hdr->lrh[1] & OPA_16B_L2_MASK) >> OPA_16B_L2_SHIFT);
+ }
+ 
+ static inline u16 hfi1_16B_get_pkey(struct hfi1_16b_header *hdr)
+ {
+ 	return (u16)((hdr->lrh[2] & OPA_16B_PKEY_MASK) >> OPA_16B_PKEY_SHIFT);
+ }
+ 
+ static inline u8 hfi1_16B_get_rc(struct hfi1_16b_header *hdr)
+ {
+ 	return (u8)((hdr->lrh[1] & OPA_16B_RC_MASK) >> OPA_16B_RC_SHIFT);
+ }
+ 
+ static inline u8 hfi1_16B_get_age(struct hfi1_16b_header *hdr)
+ {
+ 	return (u8)((hdr->lrh[3] & OPA_16B_AGE_MASK) >> OPA_16B_AGE_SHIFT);
+ }
+ 
+ static inline u16 hfi1_16B_get_len(struct hfi1_16b_header *hdr)
+ {
+ 	return (u16)((hdr->lrh[0] & OPA_16B_LEN_MASK) >> OPA_16B_LEN_SHIFT);
+ }
+ 
+ static inline u16 hfi1_16B_get_entropy(struct hfi1_16b_header *hdr)
+ {
+ 	return (u16)(hdr->lrh[3] & OPA_16B_ENTROPY_MASK);
+ }
+ 
+ /*
+  * BTH
+  */
+ #define OPA_16B_BTH_PAD_MASK	7
+ static inline u8 hfi1_16B_bth_get_pad(struct ib_other_headers *ohdr)
+ {
+ 	return (u8)((be32_to_cpu(ohdr->bth[0]) >> IB_BTH_PAD_SHIFT) &
+ 		   OPA_16B_BTH_PAD_MASK);
+ }
+ 
++>>>>>>> 863cf89d472f (IB/hfi1: Add 16B trace support)
  struct rvt_sge_state;
  
  /*
diff --cc drivers/infiniband/hw/hfi1/trace_ibhdrs.h
index 0f2d2da057ec,6721f84dafa5..000000000000
--- a/drivers/infiniband/hw/hfi1/trace_ibhdrs.h
+++ b/drivers/infiniband/hw/hfi1/trace_ibhdrs.h
@@@ -213,32 -280,36 +280,46 @@@ DEFINE_EVENT(hfi1_input_ibhdr_template
  
  DECLARE_EVENT_CLASS(hfi1_output_ibhdr_template,
  		    TP_PROTO(struct hfi1_devdata *dd,
++<<<<<<< HEAD
 +			     struct ib_header *hdr,
 +			     bool sc5),
 +		    TP_ARGS(dd, hdr, sc5),
++=======
+ 			     struct hfi1_opa_header *opah, bool sc5),
+ 		    TP_ARGS(dd, opah, sc5),
++>>>>>>> 863cf89d472f (IB/hfi1: Add 16B trace support)
  		    TP_STRUCT__entry(
  			DD_DEV_ENTRY(dd)
+ 			__field(bool, bypass)
+ 			__field(u8, ack)
+ 			__field(u8, age)
+ 			__field(u8, becn)
+ 			__field(u8, fecn)
+ 			__field(u8, l4)
  			__field(u8, lnh)
  			__field(u8, lver)
- 			__field(u8, sl)
- 			__field(u16, len)
- 			__field(u32, dlid)
- 			__field(u8, sc)
- 			__field(u32, slid)
- 			__field(u8, opcode)
- 			__field(u8, se)
  			__field(u8, mig)
+ 			__field(u8, opcode)
  			__field(u8, pad)
+ 			__field(u8, rc)
+ 			__field(u8, sc)
+ 			__field(u8, se)
+ 			__field(u8, sl)
  			__field(u8, tver)
+ 			__field(u16, entropy)
+ 			__field(u16, len)
  			__field(u16, pkey)
- 			__field(u8, fecn)
- 			__field(u8, becn)
- 			__field(u32, qpn)
- 			__field(u8, ack)
+ 			__field(u32, dlid)
  			__field(u32, psn)
+ 			__field(u32, qpn)
+ 			__field(u32, slid)
  			/* extended headers */
  			__dynamic_array(u8, ehdrs,
++<<<<<<< HEAD
 +					hfi1_trace_ib_hdr_len(hdr))
++=======
+ 					hfi1_trace_opa_hdr_len(opah))
++>>>>>>> 863cf89d472f (IB/hfi1: Add 16B trace support)
  			),
  		    TP_fast_assign(
  			struct ib_other_headers *ohdr;
* Unmerged path drivers/infiniband/hw/hfi1/hfi.h
diff --git a/drivers/infiniband/hw/hfi1/trace.c b/drivers/infiniband/hw/hfi1/trace.c
index b80b74d0c252..9938bb983ce6 100644
--- a/drivers/infiniband/hw/hfi1/trace.c
+++ b/drivers/infiniband/hw/hfi1/trace.c
@@ -47,7 +47,7 @@
 #define CREATE_TRACE_POINTS
 #include "trace.h"
 
-u8 hfi1_trace_ib_hdr_len(struct ib_header *hdr)
+static u8 __get_ib_hdr_len(struct ib_header *hdr)
 {
 	struct ib_other_headers *ohdr;
 	u8 opcode;
@@ -61,9 +61,60 @@ u8 hfi1_trace_ib_hdr_len(struct ib_header *hdr)
 	       0 : hdr_len_by_opcode[opcode] - (12 + 8);
 }
 
+static u8 __get_16b_hdr_len(struct hfi1_16b_header *hdr)
+{
+	struct ib_other_headers *ohdr;
+	u8 opcode;
+
+	if (hfi1_16B_get_l4(hdr) == OPA_16B_L4_IB_LOCAL)
+		ohdr = &hdr->u.oth;
+	else
+		ohdr = &hdr->u.l.oth;
+	opcode = ib_bth_get_opcode(ohdr);
+	return hdr_len_by_opcode[opcode] == 0 ?
+	       0 : hdr_len_by_opcode[opcode] - (12 + 8 + 8);
+}
+
+u8 hfi1_trace_packet_hdr_len(struct hfi1_packet *packet)
+{
+	if (packet->etype != RHF_RCV_TYPE_BYPASS)
+		return __get_ib_hdr_len(packet->hdr);
+	else
+		return __get_16b_hdr_len(packet->hdr);
+}
+
+u8 hfi1_trace_opa_hdr_len(struct hfi1_opa_header *opa_hdr)
+{
+	if (!opa_hdr->hdr_type)
+		return __get_ib_hdr_len(&opa_hdr->ibh);
+	else
+		return __get_16b_hdr_len(&opa_hdr->opah);
+}
+
 const char *hfi1_trace_get_packet_str(struct hfi1_packet *packet)
 {
-	return "IB";
+	if (packet->etype != RHF_RCV_TYPE_BYPASS)
+		return "IB";
+
+	switch (hfi1_16B_get_l2(packet->hdr)) {
+	case 0:
+		return "0";
+	case 1:
+		return "1";
+	case 2:
+		return "16B";
+	case 3:
+		return "9B";
+	}
+	return "";
+}
+
+const char *hfi1_trace_get_packet_type_str(u8 l4)
+{
+	if (l4)
+		return "16B";
+	else
+		return "9B";
 }
 
 #define IMM_PRN  "imm:%d"
@@ -89,10 +140,10 @@ static const char *parse_syndrome(u8 syndrome)
 	return "";
 }
 
-void hfi1_trace_parse_bth(struct ib_other_headers *ohdr,
-			  u8 *ack, u8 *becn, u8 *fecn, u8 *mig,
-			  u8 *se, u8 *pad, u8 *opcode, u8 *tver,
-			  u16 *pkey, u32 *psn, u32 *qpn)
+void hfi1_trace_parse_9b_bth(struct ib_other_headers *ohdr,
+			     u8 *ack, u8 *becn, u8 *fecn, u8 *mig,
+			     u8 *se, u8 *pad, u8 *opcode, u8 *tver,
+			     u16 *pkey, u32 *psn, u32 *qpn)
 {
 	*ack = ib_bth_get_ackreq(ohdr);
 	*becn = ib_bth_get_becn(ohdr);
@@ -107,8 +158,22 @@ void hfi1_trace_parse_bth(struct ib_other_headers *ohdr,
 	*qpn = ib_bth_get_qpn(ohdr);
 }
 
+void hfi1_trace_parse_16b_bth(struct ib_other_headers *ohdr,
+			      u8 *ack, u8 *mig, u8 *opcode,
+			      u8 *pad, u8 *se, u8 *tver,
+			      u32 *psn, u32 *qpn)
+{
+	*ack = ib_bth_get_ackreq(ohdr);
+	*mig = ib_bth_get_migreq(ohdr);
+	*opcode = ib_bth_get_opcode(ohdr);
+	*pad = ib_bth_get_pad(ohdr);
+	*se = ib_bth_get_se(ohdr);
+	*tver = ib_bth_get_tver(ohdr);
+	*psn = ib_bth_get_psn(ohdr);
+	*qpn = ib_bth_get_qpn(ohdr);
+}
+
 void hfi1_trace_parse_9b_hdr(struct ib_header *hdr, bool sc5,
-			     struct ib_other_headers **ohdr,
 			     u8 *lnh, u8 *lver, u8 *sl, u8 *sc,
 			     u16 *len, u32 *dlid, u32 *slid)
 {
@@ -119,11 +184,79 @@ void hfi1_trace_parse_9b_hdr(struct ib_header *hdr, bool sc5,
 	*len = ib_get_len(hdr);
 	*dlid = ib_get_dlid(hdr);
 	*slid = ib_get_slid(hdr);
+}
+
+void hfi1_trace_parse_16b_hdr(struct hfi1_16b_header *hdr,
+			      u8 *age, u8 *becn, u8 *fecn,
+			      u8 *l4, u8 *rc, u8 *sc,
+			      u16 *entropy, u16 *len, u16 *pkey,
+			      u32 *dlid, u32 *slid)
+{
+	*age = hfi1_16B_get_age(hdr);
+	*becn = hfi1_16B_get_becn(hdr);
+	*fecn = hfi1_16B_get_fecn(hdr);
+	*l4 = hfi1_16B_get_l4(hdr);
+	*rc = hfi1_16B_get_rc(hdr);
+	*sc = hfi1_16B_get_sc(hdr);
+	*entropy = hfi1_16B_get_entropy(hdr);
+	*len = hfi1_16B_get_len(hdr);
+	*pkey = hfi1_16B_get_pkey(hdr);
+	*dlid = hfi1_16B_get_dlid(hdr);
+	*slid = hfi1_16B_get_slid(hdr);
+}
+
+#define LRH_PRN "len:%d sc:%d dlid:0x%.4x slid:0x%.4x "
+#define LRH_9B_PRN "lnh:%d,%s lver:%d sl:%d"
+#define LRH_16B_PRN "age:%d becn:%d fecn:%d l4:%d " \
+		    "rc:%d sc:%d pkey:0x%.4x entropy:0x%.4x"
+const char *hfi1_trace_fmt_lrh(struct trace_seq *p, bool bypass,
+			       u8 age, u8 becn, u8 fecn, u8 l4,
+			       u8 lnh, const char *lnh_name, u8 lver,
+			       u8 rc, u8 sc, u8 sl, u16 entropy,
+			       u16 len, u16 pkey, u32 dlid, u32 slid)
+{
+	const char *ret = trace_seq_buffer_ptr(p);
+
+	trace_seq_printf(p, LRH_PRN, len, sc, dlid, slid);
+
+	if (bypass)
+		trace_seq_printf(p, LRH_16B_PRN,
+				 age, becn, fecn, l4, rc, sc, pkey, entropy);
 
-	if (*lnh == HFI1_LRH_BTH)
-		*ohdr = &hdr->u.oth;
 	else
-		*ohdr = &hdr->u.l.oth;
+		trace_seq_printf(p, LRH_9B_PRN,
+				 lnh, lnh_name, lver, sl);
+	trace_seq_putc(p, 0);
+
+	return ret;
+}
+
+#define BTH_9B_PRN \
+	"op:0x%.2x,%s se:%d m:%d pad:%d tver:%d pkey:0x%.4x " \
+	"f:%d b:%d qpn:0x%.6x a:%d psn:0x%.8x"
+#define BTH_16B_PRN \
+	"op:0x%.2x,%s se:%d m:%d pad:%d tver:%d " \
+	"qpn:0x%.6x a:%d psn:0x%.8x"
+const char *hfi1_trace_fmt_bth(struct trace_seq *p, bool bypass,
+			       u8 ack, u8 becn, u8 fecn, u8 mig,
+			       u8 se, u8 pad, u8 opcode, const char *opname,
+			       u8 tver, u16 pkey, u32 psn, u32 qpn)
+{
+	const char *ret = trace_seq_buffer_ptr(p);
+
+	if (bypass)
+		trace_seq_printf(p, BTH_16B_PRN,
+				 opcode, opname,
+				 se, mig, pad, tver, qpn, ack, psn);
+
+	else
+		trace_seq_printf(p, BTH_9B_PRN,
+				 opcode, opname,
+				 se, mig, pad, tver, pkey, fecn, becn,
+				 qpn, ack, psn);
+	trace_seq_putc(p, 0);
+
+	return ret;
 }
 
 const char *parse_everbs_hdrs(
* Unmerged path drivers/infiniband/hw/hfi1/trace_ibhdrs.h
