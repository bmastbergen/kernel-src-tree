nvmet-fc: remove target cpu scheduling flag

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [nvme] fc: remove target cpu scheduling flag (David Milburn) [1457880 1456486 1454365]
Rebuild_FUZZ: 92.50%
commit-author James Smart <jsmart2021@gmail.com>
commit 4b8ba5fa525bc8bdaaed2a5c5433f0f2008d7bc5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4b8ba5fa.failed

Remove NVMET_FCTGTFEAT_NEEDS_CMD_CPUSCHED. It's unnecessary.

	Signed-off-by: James Smart <james.smart@broadcom.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 4b8ba5fa525bc8bdaaed2a5c5433f0f2008d7bc5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/target/fcloop.c
#	drivers/scsi/lpfc/lpfc_nvmet.c
#	include/linux/nvme-fc-driver.h
diff --cc drivers/nvme/target/fcloop.c
index c6eb89ba0ebf,294a6611fb24..000000000000
--- a/drivers/nvme/target/fcloop.c
+++ b/drivers/nvme/target/fcloop.c
@@@ -575,8 -697,8 +575,13 @@@ static struct nvmet_fc_target_template 
  	.max_dif_sgl_segments	= FCLOOP_SGL_SEGS,
  	.dma_boundary		= FCLOOP_DMABOUND_4G,
  	/* optional features */
++<<<<<<< HEAD
 +	.target_features	= NVMET_FCTGTFEAT_READDATA_RSP |
 +				  NVMET_FCTGTFEAT_NEEDS_CMD_CPUSCHED,
++=======
+ 	.target_features	= NVMET_FCTGTFEAT_CMD_IN_ISR |
+ 				  NVMET_FCTGTFEAT_OPDONE_IN_ISR,
++>>>>>>> 4b8ba5fa525b (nvmet-fc: remove target cpu scheduling flag)
  	/* sizes of additional private data for data structures */
  	.target_priv_sz		= sizeof(struct fcloop_tport),
  };
diff --cc include/linux/nvme-fc-driver.h
index 977e25414837,6c8c5d8041b7..000000000000
--- a/include/linux/nvme-fc-driver.h
+++ b/include/linux/nvme-fc-driver.h
@@@ -647,13 -642,21 +647,31 @@@ enum 
  		 * sequence in one LLDD operation. Errors during Data
  		 * sequence transmit must not allow RSP sequence to be sent.
  		 */
++<<<<<<< HEAD
 +	NVMET_FCTGTFEAT_NEEDS_CMD_CPUSCHED = (1 << 1),
 +		/* Bit 1: When 0, the LLDD will deliver FCP CMD
 +		 * on the CPU it should be affinitized to. Thus work will
 +		 * be scheduled on the cpu received on. When 1, the LLDD
 +		 * may not deliver the CMD on the CPU it should be worked
 +		 * on. The transport should pick a cpu to schedule the work
 +		 * on.
++=======
+ 	NVMET_FCTGTFEAT_CMD_IN_ISR = (1 << 1),
+ 		/* Bit 2: When 0, the LLDD is calling the cmd rcv handler
+ 		 * in a non-isr context, allowing the transport to finish
+ 		 * op completion in the calling context. When 1, the LLDD
+ 		 * is calling the cmd rcv handler in an ISR context,
+ 		 * requiring the transport to transition to a workqueue
+ 		 * for op completion.
+ 		 */
+ 	NVMET_FCTGTFEAT_OPDONE_IN_ISR = (1 << 2),
+ 		/* Bit 3: When 0, the LLDD is calling the op done handler
+ 		 * in a non-isr context, allowing the transport to finish
+ 		 * op completion in the calling context. When 1, the LLDD
+ 		 * is calling the op done handler in an ISR context,
+ 		 * requiring the transport to transition to a workqueue
+ 		 * for op completion.
++>>>>>>> 4b8ba5fa525b (nvmet-fc: remove target cpu scheduling flag)
  		 */
  };
  
* Unmerged path drivers/scsi/lpfc/lpfc_nvmet.c
diff --git a/drivers/nvme/target/fc.c b/drivers/nvme/target/fc.c
index 58773994b97a..2454b17f3a9e 100644
--- a/drivers/nvme/target/fc.c
+++ b/drivers/nvme/target/fc.c
@@ -497,9 +497,7 @@ nvmet_fc_queue_to_cpu(struct nvmet_fc_tgtport *tgtport, int qid)
 {
 	int cpu, idx, cnt;
 
-	if (!(tgtport->ops->target_features &
-			NVMET_FCTGTFEAT_NEEDS_CMD_CPUSCHED) ||
-	    tgtport->ops->max_hw_queues == 1)
+	if (tgtport->ops->max_hw_queues == 1)
 		return WORK_CPU_UNBOUND;
 
 	/* Simple cpu selection based on qid modulo active cpu count */
* Unmerged path drivers/nvme/target/fcloop.c
* Unmerged path drivers/scsi/lpfc/lpfc_nvmet.c
* Unmerged path include/linux/nvme-fc-driver.h
