KVM/x86: Update the reverse_cpuid list to include CPUID_7_EDX

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] kvm: Update the reverse_cpuid list to include CPUID_7_EDX (Paolo Bonzini) [1537379]
Rebuild_FUZZ: 96.61%
commit-author KarimAllah Ahmed <karahmed@amazon.de>
commit b7b27aa011a1df42728d1768fc181d9ce69e6911
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b7b27aa0.failed

[dwmw2: Stop using KF() for bits in it, too]
	Signed-off-by: KarimAllah Ahmed <karahmed@amazon.de>
	Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Paolo Bonzini <pbonzini@redhat.com>
	Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
	Reviewed-by: Jim Mattson <jmattson@google.com>
	Cc: kvm@vger.kernel.org
	Cc: Radim Krčmář <rkrcmar@redhat.com>
Link: https://lkml.kernel.org/r/1517522386-18410-2-git-send-email-karahmed@amazon.de

(cherry picked from commit b7b27aa011a1df42728d1768fc181d9ce69e6911)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/cpuid.h
diff --cc arch/x86/kvm/cpuid.h
index df84d0fbb2f9,9a327d5b6d1f..000000000000
--- a/arch/x86/kvm/cpuid.h
+++ b/arch/x86/kvm/cpuid.h
@@@ -28,58 -32,90 +28,87 @@@ static inline int cpuid_maxphyaddr(stru
  	return vcpu->arch.maxphyaddr;
  }
  
++<<<<<<< HEAD
 +static inline bool guest_cpuid_has_xsave(struct kvm_vcpu *vcpu)
++=======
+ struct cpuid_reg {
+ 	u32 function;
+ 	u32 index;
+ 	int reg;
+ };
+ 
+ static const struct cpuid_reg reverse_cpuid[] = {
+ 	[CPUID_1_EDX]         = {         1, 0, CPUID_EDX},
+ 	[CPUID_8000_0001_EDX] = {0x80000001, 0, CPUID_EDX},
+ 	[CPUID_8086_0001_EDX] = {0x80860001, 0, CPUID_EDX},
+ 	[CPUID_1_ECX]         = {         1, 0, CPUID_ECX},
+ 	[CPUID_C000_0001_EDX] = {0xc0000001, 0, CPUID_EDX},
+ 	[CPUID_8000_0001_ECX] = {0x80000001, 0, CPUID_ECX},
+ 	[CPUID_7_0_EBX]       = {         7, 0, CPUID_EBX},
+ 	[CPUID_D_1_EAX]       = {       0xd, 1, CPUID_EAX},
+ 	[CPUID_F_0_EDX]       = {       0xf, 0, CPUID_EDX},
+ 	[CPUID_F_1_EDX]       = {       0xf, 1, CPUID_EDX},
+ 	[CPUID_8000_0008_EBX] = {0x80000008, 0, CPUID_EBX},
+ 	[CPUID_6_EAX]         = {         6, 0, CPUID_EAX},
+ 	[CPUID_8000_000A_EDX] = {0x8000000a, 0, CPUID_EDX},
+ 	[CPUID_7_ECX]         = {         7, 0, CPUID_ECX},
+ 	[CPUID_8000_0007_EBX] = {0x80000007, 0, CPUID_EBX},
+ 	[CPUID_7_EDX]         = {         7, 0, CPUID_EDX},
+ };
+ 
+ static __always_inline struct cpuid_reg x86_feature_cpuid(unsigned x86_feature)
++>>>>>>> b7b27aa011a1 (KVM/x86: Update the reverse_cpuid list to include CPUID_7_EDX)
  {
 -	unsigned x86_leaf = x86_feature / 32;
 +	struct kvm_cpuid_entry2 *best;
  
 -	BUILD_BUG_ON(x86_leaf >= ARRAY_SIZE(reverse_cpuid));
 -	BUILD_BUG_ON(reverse_cpuid[x86_leaf].function == 0);
 +	if (!static_cpu_has(X86_FEATURE_XSAVE))
 +		return false;
  
 -	return reverse_cpuid[x86_leaf];
 +	best = kvm_find_cpuid_entry(vcpu, 1, 0);
 +	return best && (best->ecx & bit(X86_FEATURE_XSAVE));
  }
  
 -static __always_inline int *guest_cpuid_get_register(struct kvm_vcpu *vcpu, unsigned x86_feature)
 +static inline bool guest_cpuid_has_mtrr(struct kvm_vcpu *vcpu)
  {
 -	struct kvm_cpuid_entry2 *entry;
 -	const struct cpuid_reg cpuid = x86_feature_cpuid(x86_feature);
 +	struct kvm_cpuid_entry2 *best;
  
 -	entry = kvm_find_cpuid_entry(vcpu, cpuid.function, cpuid.index);
 -	if (!entry)
 -		return NULL;
 +	best = kvm_find_cpuid_entry(vcpu, 1, 0);
 +	return best && (best->edx & bit(X86_FEATURE_MTRR));
 +}
  
 -	switch (cpuid.reg) {
 -	case CPUID_EAX:
 -		return &entry->eax;
 -	case CPUID_EBX:
 -		return &entry->ebx;
 -	case CPUID_ECX:
 -		return &entry->ecx;
 -	case CPUID_EDX:
 -		return &entry->edx;
 -	default:
 -		BUILD_BUG();
 -		return NULL;
 -	}
 +static inline bool guest_cpuid_has_tsc_adjust(struct kvm_vcpu *vcpu)
 +{
 +	struct kvm_cpuid_entry2 *best;
 +
 +	best = kvm_find_cpuid_entry(vcpu, 7, 0);
 +	return best && (best->ebx & bit(X86_FEATURE_TSC_ADJUST));
  }
  
 -static __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu, unsigned x86_feature)
 +static inline bool guest_cpuid_has_smep(struct kvm_vcpu *vcpu)
  {
 -	int *reg;
 +	struct kvm_cpuid_entry2 *best;
  
 -	if (x86_feature == X86_FEATURE_XSAVE &&
 -			!static_cpu_has(X86_FEATURE_XSAVE))
 -		return false;
 +	best = kvm_find_cpuid_entry(vcpu, 7, 0);
 +	return best && (best->ebx & bit(X86_FEATURE_SMEP));
 +}
  
 -	reg = guest_cpuid_get_register(vcpu, x86_feature);
 -	if (!reg)
 -		return false;
 +static inline bool guest_cpuid_has_smap(struct kvm_vcpu *vcpu)
 +{
 +	struct kvm_cpuid_entry2 *best;
  
 -	return *reg & bit(x86_feature);
 +	best = kvm_find_cpuid_entry(vcpu, 7, 0);
 +	return best && (best->ebx & bit(X86_FEATURE_SMAP));
  }
  
 -static __always_inline void guest_cpuid_clear(struct kvm_vcpu *vcpu, unsigned x86_feature)
 +static inline bool guest_cpuid_has_fsgsbase(struct kvm_vcpu *vcpu)
  {
 -	int *reg;
 +	struct kvm_cpuid_entry2 *best;
  
 -	reg = guest_cpuid_get_register(vcpu, x86_feature);
 -	if (reg)
 -		*reg &= ~bit(x86_feature);
 +	best = kvm_find_cpuid_entry(vcpu, 7, 0);
 +	return best && (best->ebx & bit(X86_FEATURE_FSGSBASE));
  }
  
 -static inline bool guest_cpuid_is_amd(struct kvm_vcpu *vcpu)
 +static inline bool guest_cpuid_has_longmode(struct kvm_vcpu *vcpu)
  {
  	struct kvm_cpuid_entry2 *best;
  
diff --git a/arch/x86/kvm/cpuid.c b/arch/x86/kvm/cpuid.c
index 1e22c91417fc..2d14e02b5531 100644
--- a/arch/x86/kvm/cpuid.c
+++ b/arch/x86/kvm/cpuid.c
@@ -67,9 +67,7 @@ u64 kvm_supported_xcr0(void)
 
 #define F(x) bit(X86_FEATURE_##x)
 
-/* These are scattered features in cpufeatures.h. */
-#define KVM_CPUID_BIT_AVX512_4VNNIW     2
-#define KVM_CPUID_BIT_AVX512_4FMAPS     3
+/* For scattered features from cpufeatures.h; we currently expose none */
 #define KF(x) bit(KVM_CPUID_BIT_##x)
 
 int kvm_update_cpuid(struct kvm_vcpu *vcpu)
@@ -375,7 +373,7 @@ static inline int __do_cpuid_ent(struct kvm_cpuid_entry2 *entry, u32 function,
 
 	/* cpuid 7.0.edx*/
 	const u32 kvm_cpuid_7_0_edx_x86_features =
-		KF(AVX512_4VNNIW) | KF(AVX512_4FMAPS);
+		F(AVX512_4VNNIW) | F(AVX512_4FMAPS);
 
 	/* all calls to cpuid_count() should be made on the same cpu */
 	get_cpu();
@@ -457,7 +455,7 @@ static inline int __do_cpuid_ent(struct kvm_cpuid_entry2 *entry, u32 function,
 			entry->ecx &= kvm_cpuid_7_0_ecx_x86_features;
 			cpuid_mask(&entry->ecx, CPUID_7_ECX);
 			entry->edx &= kvm_cpuid_7_0_edx_x86_features;
-			entry->edx &= get_scattered_cpuid_leaf(7, 0, CPUID_EDX);
+			cpuid_mask(&entry->edx, CPUID_7_EDX);
 		} else {
 			entry->ebx = 0;
 			entry->ecx = 0;
* Unmerged path arch/x86/kvm/cpuid.h
