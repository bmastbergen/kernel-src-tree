i40e: use DECLARE_BITMAP for state fields

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit 0da36b9774cc24bac4bff446edf49f31aa98a282
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0da36b97.failed

Instead of assuming our flags fit within an unsigned long, use
DECLARE_BITMAP which will ensure that we always allocate enough space.
Additionally, use __I40E_STATE_SIZE__ markers as the last element of the
enumeration so that the size of the BITMAP is compile-time assigned
rather than programmer-time assigned. This ensures that potential future
flag additions do not actually overrun the array. This is especially
important as 32bit systems would only have 32bit longs instead of 64bit
longs as we generally have assumed in the prior code.

This change also removes a dereference of the state fields throughout
the code, so it does have a bit of code churn. The conversions were
automated using sed replacements with an alternation

  s/&(vsi->back|vsi|pf)->state/\1->state/
  s/&adapter->vsi.state/adapter->vsi.state/

For debugfs, we modify the printing so that we can display chunks of the
state value on new lines. This ensures that we can print the entire set
of state values. Additionally, we now print them as 08lx to ensure that
they display nicely.

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 0da36b9774cc24bac4bff446edf49f31aa98a282)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e.h
#	drivers/net/ethernet/intel/i40e/i40e_client.c
#	drivers/net/ethernet/intel/i40e/i40e_debugfs.c
#	drivers/net/ethernet/intel/i40e/i40e_ethtool.c
#	drivers/net/ethernet/intel/i40e/i40e_main.c
#	drivers/net/ethernet/intel/i40e/i40e_txrx.c
#	drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
#	drivers/net/ethernet/intel/i40evf/i40e_txrx.c
#	drivers/net/ethernet/intel/i40evf/i40evf.h
#	drivers/net/ethernet/intel/i40evf/i40evf_main.c
diff --cc drivers/net/ethernet/intel/i40e/i40e.h
index ba3546c697e9,6eb21abdc60e..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e.h
+++ b/drivers/net/ethernet/intel/i40e/i40e.h
@@@ -154,8 -145,22 +154,25 @@@ enum i40e_state_t 
  	__I40E_RESET_FAILED,
  	__I40E_PORT_SUSPENDED,
  	__I40E_VF_DISABLE,
+ 	/* This must be last as it determines the size of the BITMAP */
+ 	__I40E_STATE_SIZE__,
  };
  
++<<<<<<< HEAD
++=======
+ /* VSI state flags */
+ enum i40e_vsi_state_t {
+ 	__I40E_VSI_DOWN,
+ 	__I40E_VSI_NEEDS_RESTART,
+ 	__I40E_VSI_SYNCING_FILTERS,
+ 	__I40E_VSI_OVERFLOW_PROMISC,
+ 	__I40E_VSI_REINIT_REQUESTED,
+ 	__I40E_VSI_DOWN_REQUESTED,
+ 	/* This must be last as it determines the size of the BITMAP */
+ 	__I40E_VSI_STATE_SIZE__,
+ };
+ 
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  enum i40e_interrupt_policy {
  	I40E_INTERRUPT_BEST_CASE,
  	I40E_INTERRUPT_MEDIUM,
diff --cc drivers/net/ethernet/intel/i40e/i40e_client.c
index 5115ed5f2149,c3b81a97558e..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_client.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_client.c
@@@ -382,7 -382,7 +382,11 @@@ void i40e_client_subtask(struct i40e_p
  	 * the netdev is up, then open the client.
  	 */
  	if (!test_bit(__I40E_CLIENT_INSTANCE_OPENED, &cdev->state)) {
++<<<<<<< HEAD
 +		if (!test_bit(__I40E_DOWN, &vsi->state) &&
++=======
+ 		if (!test_bit(__I40E_VSI_DOWN, vsi->state) &&
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  		    client->ops && client->ops->open) {
  			set_bit(__I40E_CLIENT_INSTANCE_OPENED, &cdev->state);
  			ret = client->ops->open(&cdev->lan_info, client);
@@@ -397,7 -397,7 +401,11 @@@
  	/* Likewise for client close. If the client is up, but the netdev
  	 * is down, then close the client.
  	 */
++<<<<<<< HEAD
 +		if (test_bit(__I40E_DOWN, &vsi->state) &&
++=======
+ 		if (test_bit(__I40E_VSI_DOWN, vsi->state) &&
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  		    client->ops && client->ops->close) {
  			clear_bit(__I40E_CLIENT_INSTANCE_OPENED, &cdev->state);
  			client->ops->close(&cdev->lan_info, client, false);
diff --cc drivers/net/ethernet/intel/i40e/i40e_debugfs.c
index c6b6e55b9a84,8f326f87a815..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_debugfs.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_debugfs.c
@@@ -174,7 -177,7 +177,11 @@@ static void i40e_dbg_dump_vsi_seid(stru
  	}
  	dev_info(&pf->pdev->dev, "    active_filters %u, promisc_threshold %u, overflow promisc %s\n",
  		 vsi->active_filters, vsi->promisc_threshold,
++<<<<<<< HEAD
 +		 (test_bit(__I40E_FILTER_OVERFLOW_PROMISC, &vsi->state) ?
++=======
+ 		 (test_bit(__I40E_VSI_OVERFLOW_PROMISC, vsi->state) ?
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  		  "ON" : "OFF"));
  	nstat = i40e_get_vsi_stats_struct(vsi);
  	dev_info(&pf->pdev->dev,
@@@ -1725,7 -1709,7 +1732,11 @@@ static ssize_t i40e_dbg_netdev_ops_writ
  		} else if (!vsi->netdev) {
  			dev_info(&pf->pdev->dev, "tx_timeout: no netdev for VSI %d\n",
  				 vsi_seid);
++<<<<<<< HEAD
 +		} else if (test_bit(__I40E_DOWN, &vsi->state)) {
++=======
+ 		} else if (test_bit(__I40E_VSI_DOWN, vsi->state)) {
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  			dev_info(&pf->pdev->dev, "tx_timeout: VSI %d not UP\n",
  				 vsi_seid);
  		} else if (rtnl_trylock()) {
diff --cc drivers/net/ethernet/intel/i40e/i40e_ethtool.c
index 8d394f03b50c,b1064c6468c2..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
@@@ -1922,8 -1886,8 +1922,13 @@@ static void i40e_diag_test(struct net_d
  		if (i40e_reg_test(netdev, &data[I40E_ETH_TEST_REG]))
  			eth_test->flags |= ETH_TEST_FL_FAILED;
  
++<<<<<<< HEAD
 +		clear_bit(__I40E_TESTING, &pf->state);
 +		i40e_do_reset(pf, BIT(__I40E_PF_RESET_REQUESTED));
++=======
+ 		clear_bit(__I40E_TESTING, pf->state);
+ 		i40e_do_reset(pf, BIT(__I40E_PF_RESET_REQUESTED), true);
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  
  		if (if_running)
  			i40e_open(netdev);
diff --cc drivers/net/ethernet/intel/i40e/i40e_main.c
index 89a1a0cd5195,38772e49bb84..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@@ -430,11 -422,11 +430,16 @@@ static struct rtnl_link_stats64 *i40e_g
  	struct rtnl_link_stats64 *vsi_stats = i40e_get_vsi_stats_struct(vsi);
  	int i;
  
++<<<<<<< HEAD
 +	if (test_bit(__I40E_DOWN, &vsi->state))
 +		return stats;
++=======
+ 	if (test_bit(__I40E_VSI_DOWN, vsi->state))
+ 		return;
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  
  	if (!vsi->tx_rings)
 -		return;
 +		return stats;
  
  	rcu_read_lock();
  	for (i = 0; i < vsi->num_queue_pairs; i++) {
@@@ -826,8 -753,8 +831,13 @@@ static void i40e_update_vsi_stats(struc
  	u64 tx_p, tx_b;
  	u16 q;
  
++<<<<<<< HEAD
 +	if (test_bit(__I40E_DOWN, &vsi->state) ||
 +	    test_bit(__I40E_CONFIG_BUSY, &pf->state))
++=======
+ 	if (test_bit(__I40E_VSI_DOWN, vsi->state) ||
+ 	    test_bit(__I40E_CONFIG_BUSY, pf->state))
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  		return;
  
  	ns = i40e_get_vsi_stats_struct(vsi);
@@@ -1419,7 -1346,7 +1429,11 @@@ struct i40e_mac_filter *i40e_add_filter
  		 * to failed, so we don't bother to try sending the filter
  		 * to the hardware.
  		 */
++<<<<<<< HEAD
 +		if (test_bit(__I40E_FILTER_OVERFLOW_PROMISC, &vsi->state))
++=======
+ 		if (test_bit(__I40E_VSI_OVERFLOW_PROMISC, vsi->state))
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  			f->state = I40E_FILTER_FAILED;
  		else
  			f->state = I40E_FILTER_NEW;
@@@ -1602,8 -1525,8 +1616,13 @@@ static int i40e_set_mac(struct net_devi
  		return 0;
  	}
  
++<<<<<<< HEAD
 +	if (test_bit(__I40E_DOWN, &vsi->back->state) ||
 +	    test_bit(__I40E_RESET_RECOVERY_PENDING, &vsi->back->state))
++=======
+ 	if (test_bit(__I40E_VSI_DOWN, vsi->back->state) ||
+ 	    test_bit(__I40E_RESET_RECOVERY_PENDING, vsi->back->state))
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  		return -EADDRNOTAVAIL;
  
  	if (ether_addr_equal(hw->mac.addr, addr->sa_data))
@@@ -2008,7 -1920,7 +2027,11 @@@ void i40e_aqc_add_filters(struct i40e_v
  
  	if (fcnt != num_add) {
  		*promisc_changed = true;
++<<<<<<< HEAD
 +		set_bit(__I40E_FILTER_OVERFLOW_PROMISC, &vsi->state);
++=======
+ 		set_bit(__I40E_VSI_OVERFLOW_PROMISC, vsi->state);
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  		dev_warn(&vsi->back->pdev->dev,
  			 "Error %s adding RX filters on %s, promiscuous mode forced on\n",
  			 i40e_aq_str(hw, aq_err),
@@@ -2091,7 -2003,7 +2114,11 @@@ int i40e_sync_vsi_filters(struct i40e_v
  	struct i40e_aqc_add_macvlan_element_data *add_list;
  	struct i40e_aqc_remove_macvlan_element_data *del_list;
  
++<<<<<<< HEAD
 +	while (test_and_set_bit(__I40E_CONFIG_BUSY, &vsi->state))
++=======
+ 	while (test_and_set_bit(__I40E_VSI_SYNCING_FILTERS, vsi->state))
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  		usleep_range(1000, 2000);
  	pf = vsi->back;
  
@@@ -2227,8 -2139,8 +2254,13 @@@
  
  		num_add = 0;
  		hlist_for_each_entry_safe(new, h, &tmp_add_list, hlist) {
++<<<<<<< HEAD
 +			if (test_bit(__I40E_FILTER_OVERFLOW_PROMISC,
 +				     &vsi->state)) {
++=======
+ 			if (test_bit(__I40E_VSI_OVERFLOW_PROMISC,
+ 				     vsi->state)) {
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  				new->state = I40E_FILTER_FAILED;
  				continue;
  			}
@@@ -2315,20 -2227,20 +2347,32 @@@
  	 * safely exit if we didn't just enter, we no longer have any failed
  	 * filters, and we have reduced filters below the threshold value.
  	 */
++<<<<<<< HEAD
 +	if (test_bit(__I40E_FILTER_OVERFLOW_PROMISC, &vsi->state) &&
++=======
+ 	if (test_bit(__I40E_VSI_OVERFLOW_PROMISC, vsi->state) &&
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  	    !promisc_changed && !failed_filters &&
  	    (vsi->active_filters < vsi->promisc_threshold)) {
  		dev_info(&pf->pdev->dev,
  			 "filter logjam cleared on %s, leaving overflow promiscuous mode\n",
  			 vsi_name);
++<<<<<<< HEAD
 +		clear_bit(__I40E_FILTER_OVERFLOW_PROMISC, &vsi->state);
++=======
+ 		clear_bit(__I40E_VSI_OVERFLOW_PROMISC, vsi->state);
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  		promisc_changed = true;
  		vsi->promisc_threshold = 0;
  	}
  
  	/* if the VF is not trusted do not do promisc */
  	if ((vsi->type == I40E_VSI_SRIOV) && !pf->vf[vsi->vf_id].trusted) {
++<<<<<<< HEAD
 +		clear_bit(__I40E_FILTER_OVERFLOW_PROMISC, &vsi->state);
++=======
+ 		clear_bit(__I40E_VSI_OVERFLOW_PROMISC, vsi->state);
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  		goto out;
  	}
  
@@@ -2353,12 -2265,12 +2397,21 @@@
  	}
  	if ((changed_flags & IFF_PROMISC) ||
  	    (promisc_changed &&
++<<<<<<< HEAD
 +	     test_bit(__I40E_FILTER_OVERFLOW_PROMISC, &vsi->state))) {
 +		bool cur_promisc;
 +
 +		cur_promisc = (!!(vsi->current_netdev_flags & IFF_PROMISC) ||
 +			       test_bit(__I40E_FILTER_OVERFLOW_PROMISC,
 +					&vsi->state));
++=======
+ 	     test_bit(__I40E_VSI_OVERFLOW_PROMISC, vsi->state))) {
+ 		bool cur_promisc;
+ 
+ 		cur_promisc = (!!(vsi->current_netdev_flags & IFF_PROMISC) ||
+ 			       test_bit(__I40E_VSI_OVERFLOW_PROMISC,
+ 					vsi->state));
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  		if ((vsi->type == I40E_VSI_MAIN) &&
  		    (pf->lan_veb != I40E_NO_VEB) &&
  		    !(pf->flags & I40E_FLAG_MFP_ENABLED)) {
@@@ -2429,7 -2353,7 +2482,11 @@@ out
  	if (retval)
  		vsi->flags |= I40E_VSI_FLAG_FILTER_CHANGED;
  
++<<<<<<< HEAD
 +	clear_bit(__I40E_CONFIG_BUSY, &vsi->state);
++=======
+ 	clear_bit(__I40E_VSI_SYNCING_FILTERS, vsi->state);
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  	return retval;
  
  err_no_memory:
@@@ -2441,7 -2365,7 +2498,11 @@@ err_no_memory_locked
  	spin_unlock_bh(&vsi->mac_filter_hash_lock);
  
  	vsi->flags |= I40E_VSI_FLAG_FILTER_CHANGED;
++<<<<<<< HEAD
 +	clear_bit(__I40E_CONFIG_BUSY, &vsi->state);
++=======
+ 	clear_bit(__I40E_VSI_SYNCING_FILTERS, vsi->state);
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  	return -ENOMEM;
  }
  
@@@ -4009,7 -3907,7 +4070,11 @@@ static void i40e_netpoll(struct net_dev
  	int i;
  
  	/* if interface is down do nothing */
++<<<<<<< HEAD
 +	if (test_bit(__I40E_DOWN, &vsi->state))
++=======
+ 	if (test_bit(__I40E_VSI_DOWN, vsi->state))
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  		return;
  
  	if (pf->flags & I40E_FLAG_MSIX_ENABLED) {
@@@ -4515,7 -4436,7 +4580,11 @@@ static void i40e_napi_disable_all(struc
  static void i40e_vsi_close(struct i40e_vsi *vsi)
  {
  	struct i40e_pf *pf = vsi->back;
++<<<<<<< HEAD
 +	if (!test_and_set_bit(__I40E_DOWN, &vsi->state))
++=======
+ 	if (!test_and_set_bit(__I40E_VSI_DOWN, vsi->state))
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  		i40e_down(vsi);
  	i40e_vsi_free_irq(vsi);
  	i40e_vsi_free_tx_resources(vsi);
@@@ -4532,18 -4453,10 +4601,25 @@@
   **/
  static void i40e_quiesce_vsi(struct i40e_vsi *vsi)
  {
++<<<<<<< HEAD
 +	if (test_bit(__I40E_DOWN, &vsi->state))
 +		return;
 +
 +	/* No need to disable FCoE VSI when Tx suspended */
 +	if ((test_bit(__I40E_PORT_TX_SUSPENDED, &vsi->back->state)) &&
 +	    vsi->type == I40E_VSI_FCOE) {
 +		dev_dbg(&vsi->back->pdev->dev,
 +			 "VSI seid %d skipping FCoE VSI disable\n", vsi->seid);
 +		return;
 +	}
 +
 +	set_bit(__I40E_NEEDS_RESTART, &vsi->state);
++=======
+ 	if (test_bit(__I40E_VSI_DOWN, vsi->state))
+ 		return;
+ 
+ 	set_bit(__I40E_VSI_NEEDS_RESTART, vsi->state);
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  	if (vsi->netdev && netif_running(vsi->netdev))
  		vsi->netdev->netdev_ops->ndo_stop(vsi->netdev);
  	else
@@@ -4556,10 -4469,9 +4632,14 @@@
   **/
  static void i40e_unquiesce_vsi(struct i40e_vsi *vsi)
  {
++<<<<<<< HEAD
 +	if (!test_bit(__I40E_NEEDS_RESTART, &vsi->state))
++=======
+ 	if (!test_and_clear_bit(__I40E_VSI_NEEDS_RESTART, vsi->state))
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  		return;
  
 +	clear_bit(__I40E_NEEDS_RESTART, &vsi->state);
  	if (vsi->netdev && netif_running(vsi->netdev))
  		vsi->netdev->netdev_ops->ndo_open(vsi->netdev);
  	else
@@@ -4726,8 -4637,8 +4806,13 @@@ static void i40e_detect_recover_hung(st
  		return;
  
  	/* Make sure, VSI state is not DOWN/RECOVERY_PENDING */
++<<<<<<< HEAD
 +	if (test_bit(__I40E_DOWN, &vsi->back->state) ||
 +	    test_bit(__I40E_RESET_RECOVERY_PENDING, &vsi->back->state))
++=======
+ 	if (test_bit(__I40E_VSI_DOWN, vsi->back->state) ||
+ 	    test_bit(__I40E_RESET_RECOVERY_PENDING, vsi->back->state))
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  		return;
  
  	/* Make sure type is MAIN VSI */
@@@ -5465,7 -5353,7 +5550,11 @@@ static int i40e_up_complete(struct i40e
  	if (err)
  		return err;
  
++<<<<<<< HEAD
 +	clear_bit(__I40E_DOWN, &vsi->state);
++=======
+ 	clear_bit(__I40E_VSI_DOWN, vsi->state);
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  	i40e_napi_enable_all(vsi);
  	i40e_vsi_enable_irq(vsi);
  
@@@ -5887,10 -5786,9 +5976,15 @@@ void i40e_do_reset(struct i40e_pf *pf, 
  			struct i40e_vsi *vsi = pf->vsi[v];
  
  			if (vsi != NULL &&
++<<<<<<< HEAD
 +			    test_bit(__I40E_REINIT_REQUESTED, &vsi->state)) {
++=======
+ 			    test_and_clear_bit(__I40E_VSI_REINIT_REQUESTED,
+ 					       vsi->state))
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  				i40e_vsi_reinit_locked(pf->vsi[v]);
 +				clear_bit(__I40E_REINIT_REQUESTED, &vsi->state);
 +			}
  		}
  	} else if (reset_flags & BIT_ULL(__I40E_DOWN_REQUESTED)) {
  		int v;
@@@ -5901,10 -5799,10 +5995,16 @@@
  			struct i40e_vsi *vsi = pf->vsi[v];
  
  			if (vsi != NULL &&
++<<<<<<< HEAD
 +			    test_bit(__I40E_DOWN_REQUESTED, &vsi->state)) {
 +				set_bit(__I40E_DOWN, &vsi->state);
++=======
+ 			    test_and_clear_bit(__I40E_VSI_DOWN_REQUESTED,
+ 					       vsi->state)) {
+ 				set_bit(__I40E_VSI_DOWN, vsi->state);
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  				i40e_down(vsi);
 +				clear_bit(__I40E_DOWN_REQUESTED, &vsi->state);
  			}
  		}
  	} else {
@@@ -6324,7 -6221,7 +6424,11 @@@ static void i40e_fdir_reinit_subtask(st
   **/
  static void i40e_vsi_link_event(struct i40e_vsi *vsi, bool link_up)
  {
++<<<<<<< HEAD
 +	if (!vsi || test_bit(__I40E_DOWN, &vsi->state))
++=======
+ 	if (!vsi || test_bit(__I40E_VSI_DOWN, vsi->state))
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  		return;
  
  	switch (vsi->type) {
@@@ -6420,11 -6314,11 +6524,19 @@@ static void i40e_link_event(struct i40e
  
  	if (new_link == old_link &&
  	    new_link_speed == old_link_speed &&
++<<<<<<< HEAD
 +	    (test_bit(__I40E_DOWN, &vsi->state) ||
 +	     new_link == netif_carrier_ok(vsi->netdev)))
 +		return;
 +
 +	if (!test_bit(__I40E_DOWN, &vsi->state))
++=======
+ 	    (test_bit(__I40E_VSI_DOWN, vsi->state) ||
+ 	     new_link == netif_carrier_ok(vsi->netdev)))
+ 		return;
+ 
+ 	if (!test_bit(__I40E_VSI_DOWN, vsi->state))
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  		i40e_print_link_message(vsi, new_link);
  
  	/* Notify the base of the switch tree connected to
@@@ -6491,44 -6384,44 +6603,64 @@@ static void i40e_reset_subtask(struct i
  {
  	u32 reset_flags = 0;
  
++<<<<<<< HEAD
 +	rtnl_lock();
 +	if (test_bit(__I40E_REINIT_REQUESTED, &pf->state)) {
++=======
+ 	if (test_bit(__I40E_REINIT_REQUESTED, pf->state)) {
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  		reset_flags |= BIT(__I40E_REINIT_REQUESTED);
- 		clear_bit(__I40E_REINIT_REQUESTED, &pf->state);
+ 		clear_bit(__I40E_REINIT_REQUESTED, pf->state);
  	}
- 	if (test_bit(__I40E_PF_RESET_REQUESTED, &pf->state)) {
+ 	if (test_bit(__I40E_PF_RESET_REQUESTED, pf->state)) {
  		reset_flags |= BIT(__I40E_PF_RESET_REQUESTED);
- 		clear_bit(__I40E_PF_RESET_REQUESTED, &pf->state);
+ 		clear_bit(__I40E_PF_RESET_REQUESTED, pf->state);
  	}
- 	if (test_bit(__I40E_CORE_RESET_REQUESTED, &pf->state)) {
+ 	if (test_bit(__I40E_CORE_RESET_REQUESTED, pf->state)) {
  		reset_flags |= BIT(__I40E_CORE_RESET_REQUESTED);
- 		clear_bit(__I40E_CORE_RESET_REQUESTED, &pf->state);
+ 		clear_bit(__I40E_CORE_RESET_REQUESTED, pf->state);
  	}
- 	if (test_bit(__I40E_GLOBAL_RESET_REQUESTED, &pf->state)) {
+ 	if (test_bit(__I40E_GLOBAL_RESET_REQUESTED, pf->state)) {
  		reset_flags |= BIT(__I40E_GLOBAL_RESET_REQUESTED);
- 		clear_bit(__I40E_GLOBAL_RESET_REQUESTED, &pf->state);
+ 		clear_bit(__I40E_GLOBAL_RESET_REQUESTED, pf->state);
  	}
- 	if (test_bit(__I40E_DOWN_REQUESTED, &pf->state)) {
- 		reset_flags |= BIT(__I40E_DOWN_REQUESTED);
- 		clear_bit(__I40E_DOWN_REQUESTED, &pf->state);
+ 	if (test_bit(__I40E_VSI_DOWN_REQUESTED, pf->state)) {
+ 		reset_flags |= BIT(__I40E_VSI_DOWN_REQUESTED);
+ 		clear_bit(__I40E_VSI_DOWN_REQUESTED, pf->state);
  	}
  
  	/* If there's a recovery already waiting, it takes
  	 * precedence before starting a new reset sequence.
  	 */
++<<<<<<< HEAD
 +	if (test_bit(__I40E_RESET_INTR_RECEIVED, &pf->state)) {
 +		i40e_handle_reset_warning(pf);
 +		goto unlock;
++=======
+ 	if (test_bit(__I40E_RESET_INTR_RECEIVED, pf->state)) {
+ 		i40e_prep_for_reset(pf, false);
+ 		i40e_reset(pf);
+ 		i40e_rebuild(pf, false, false);
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  	}
  
  	/* If we're already down or resetting, just bail */
  	if (reset_flags &&
++<<<<<<< HEAD
 +	    !test_bit(__I40E_DOWN, &pf->state) &&
 +	    !test_bit(__I40E_CONFIG_BUSY, &pf->state))
 +		i40e_do_reset(pf, reset_flags);
 +
 +unlock:
 +	rtnl_unlock();
++=======
+ 	    !test_bit(__I40E_VSI_DOWN, pf->state) &&
+ 	    !test_bit(__I40E_CONFIG_BUSY, pf->state)) {
+ 		rtnl_lock();
+ 		i40e_do_reset(pf, reset_flags, true);
+ 		rtnl_unlock();
+ 	}
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  }
  
  /**
@@@ -7069,31 -6969,41 +7201,55 @@@ static void i40e_send_version(struct i4
  }
  
  /**
++<<<<<<< HEAD
 + * i40e_reset_and_rebuild - reset and rebuild using a saved config
++=======
+  * i40e_reset - wait for core reset to finish reset, reset pf if corer not seen
+  * @pf: board private structure
+  **/
+ static int i40e_reset(struct i40e_pf *pf)
+ {
+ 	struct i40e_hw *hw = &pf->hw;
+ 	i40e_status ret;
+ 
+ 	ret = i40e_pf_reset(hw);
+ 	if (ret) {
+ 		dev_info(&pf->pdev->dev, "PF reset failed, %d\n", ret);
+ 		set_bit(__I40E_RESET_FAILED, pf->state);
+ 		clear_bit(__I40E_RESET_RECOVERY_PENDING, pf->state);
+ 	} else {
+ 		pf->pfr_count++;
+ 	}
+ 	return ret;
+ }
+ 
+ /**
+  * i40e_rebuild - rebuild using a saved config
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
   * @pf: board private structure
   * @reinit: if the Main VSI needs to re-initialized.
 - * @lock_acquired: indicates whether or not the lock has been acquired
 - * before this function was called.
   **/
 -static void i40e_rebuild(struct i40e_pf *pf, bool reinit, bool lock_acquired)
 +static void i40e_reset_and_rebuild(struct i40e_pf *pf, bool reinit)
  {
  	struct i40e_hw *hw = &pf->hw;
  	u8 set_fc_aq_fail = 0;
  	i40e_status ret;
  	u32 val;
 -	int v;
 +	u32 v;
 +
 +	/* Now we wait for GRST to settle out.
 +	 * We don't have to delete the VEBs or VSIs from the hw switch
 +	 * because the reset will make them disappear.
 +	 */
 +	ret = i40e_pf_reset(hw);
 +	if (ret) {
 +		dev_info(&pf->pdev->dev, "PF reset failed, %d\n", ret);
 +		set_bit(__I40E_RESET_FAILED, &pf->state);
 +		goto clear_recovery;
 +	}
 +	pf->pfr_count++;
  
- 	if (test_bit(__I40E_DOWN, &pf->state))
+ 	if (test_bit(__I40E_VSI_DOWN, pf->state))
  		goto clear_recovery;
  	dev_dbg(&pf->pdev->dev, "Rebuilding internal switch\n");
  
@@@ -7265,12 -7173,38 +7421,12 @@@
  	/* tell the firmware that we're starting */
  	i40e_send_version(pf);
  
 -	/* We've already released the lock, so don't do it again */
 -	goto end_core_reset;
 -
 -end_unlock:
 -	if (!lock_acquired)
 -		rtnl_unlock();
  end_core_reset:
- 	clear_bit(__I40E_RESET_FAILED, &pf->state);
+ 	clear_bit(__I40E_RESET_FAILED, pf->state);
  clear_recovery:
- 	clear_bit(__I40E_RESET_RECOVERY_PENDING, &pf->state);
+ 	clear_bit(__I40E_RESET_RECOVERY_PENDING, pf->state);
  }
  
 -/**
 - * i40e_reset_and_rebuild - reset and rebuild using a saved config
 - * @pf: board private structure
 - * @reinit: if the Main VSI needs to re-initialized.
 - * @lock_acquired: indicates whether or not the lock has been acquired
 - * before this function was called.
 - **/
 -static void i40e_reset_and_rebuild(struct i40e_pf *pf, bool reinit,
 -				   bool lock_acquired)
 -{
 -	int ret;
 -	/* Now we wait for GRST to settle out.
 -	 * We don't have to delete the VEBs or VSIs from the hw switch
 -	 * because the reset will make them disappear.
 -	 */
 -	ret = i40e_reset(pf);
 -	if (!ret)
 -		i40e_rebuild(pf, reinit, lock_acquired);
 -}
 -
  /**
   * i40e_handle_reset_warning - prep for the PF to reset, reset and rebuild
   * @pf: board private structure
@@@ -7674,7 -7588,7 +7829,11 @@@ static int i40e_vsi_mem_alloc(struct i4
  	}
  	vsi->type = type;
  	vsi->back = pf;
++<<<<<<< HEAD
 +	set_bit(__I40E_DOWN, &vsi->state);
++=======
+ 	set_bit(__I40E_VSI_DOWN, vsi->state);
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  	vsi->flags = 0;
  	vsi->idx = vsi_idx;
  	vsi->int_rate_limit = 0;
@@@ -9866,7 -9715,7 +10025,11 @@@ static int i40e_add_vsi(struct i40e_vs
  	}
  
  	vsi->active_filters = 0;
++<<<<<<< HEAD
 +	clear_bit(__I40E_FILTER_OVERFLOW_PROMISC, &vsi->state);
++=======
+ 	clear_bit(__I40E_VSI_OVERFLOW_PROMISC, vsi->state);
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  	spin_lock_bh(&vsi->mac_filter_hash_lock);
  	/* If macvlan filters already exist, force them to get loaded */
  	hash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist) {
@@@ -11813,9 -11609,9 +11976,9 @@@ static pci_ers_result_t i40e_pci_error_
  	}
  
  	/* shutdown all operations */
- 	if (!test_bit(__I40E_SUSPENDED, &pf->state)) {
+ 	if (!test_bit(__I40E_SUSPENDED, pf->state)) {
  		rtnl_lock();
 -		i40e_prep_for_reset(pf, true);
 +		i40e_prep_for_reset(pf);
  		rtnl_unlock();
  	}
  
@@@ -11966,10 -11740,10 +12129,10 @@@ static void i40e_shutdown(struct pci_de
  	struct i40e_pf *pf = pci_get_drvdata(pdev);
  	struct i40e_hw *hw = &pf->hw;
  
- 	set_bit(__I40E_SUSPENDED, &pf->state);
- 	set_bit(__I40E_DOWN, &pf->state);
+ 	set_bit(__I40E_SUSPENDED, pf->state);
+ 	set_bit(__I40E_VSI_DOWN, pf->state);
  	rtnl_lock();
 -	i40e_prep_for_reset(pf, true);
 +	i40e_prep_for_reset(pf);
  	rtnl_unlock();
  
  	wr32(hw, I40E_PFPM_APM, (pf->wol_en ? I40E_PFPM_APM_APME_MASK : 0));
@@@ -12006,17 -11780,17 +12169,17 @@@
  
  #ifdef CONFIG_PM
  /**
 - * i40e_suspend - PCI callback for moving to D3
 - * @pdev: PCI device information struct
 + * i40e_suspend - PM callback for moving to D3
 + * @dev: generic device information structure
   **/
 -static int i40e_suspend(struct pci_dev *pdev, pm_message_t state)
 +static int i40e_suspend(struct device *dev)
  {
 +	struct pci_dev *pdev = to_pci_dev(dev);
  	struct i40e_pf *pf = pci_get_drvdata(pdev);
  	struct i40e_hw *hw = &pf->hw;
 -	int retval = 0;
  
- 	set_bit(__I40E_SUSPENDED, &pf->state);
- 	set_bit(__I40E_DOWN, &pf->state);
+ 	set_bit(__I40E_SUSPENDED, pf->state);
+ 	set_bit(__I40E_VSI_DOWN, pf->state);
  
  	if (pf->wol_en && (pf->flags & I40E_FLAG_WOL_MC_MAGIC_PKT_WAKE))
  		i40e_enable_mc_magic_wake(pf);
@@@ -12034,19 -11815,36 +12197,19 @@@
  }
  
  /**
 - * i40e_resume - PCI callback for waking up from D3
 - * @pdev: PCI device information struct
 + * i40e_resume - PM callback for waking up from D3
 + * @dev: generic device information structure
   **/
 -static int i40e_resume(struct pci_dev *pdev)
 +static int i40e_resume(struct device *dev)
  {
 +	struct pci_dev *pdev = to_pci_dev(dev);
  	struct i40e_pf *pf = pci_get_drvdata(pdev);
 -	u32 err;
 -
 -	pci_set_power_state(pdev, PCI_D0);
 -	pci_restore_state(pdev);
 -	/* pci_restore_state() clears dev->state_saves, so
 -	 * call pci_save_state() again to restore it.
 -	 */
 -	pci_save_state(pdev);
 -
 -	err = pci_enable_device_mem(pdev);
 -	if (err) {
 -		dev_err(&pdev->dev, "Cannot enable PCI device from suspend\n");
 -		return err;
 -	}
 -	pci_set_master(pdev);
 -
 -	/* no wakeup events while running */
 -	pci_wake_from_d3(pdev, false);
  
  	/* handling the reset will rebuild the device state */
- 	if (test_and_clear_bit(__I40E_SUSPENDED, &pf->state)) {
- 		clear_bit(__I40E_DOWN, &pf->state);
+ 	if (test_and_clear_bit(__I40E_SUSPENDED, pf->state)) {
+ 		clear_bit(__I40E_VSI_DOWN, pf->state);
  		rtnl_lock();
 -		i40e_reset_and_rebuild(pf, false, true);
 +		i40e_reset_and_rebuild(pf, false);
  		rtnl_unlock();
  	}
  
diff --cc drivers/net/ethernet/intel/i40e/i40e_txrx.c
index 5e0c988a8b2a,6e677a235fe4..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
@@@ -850,7 -850,7 +850,11 @@@ static bool i40e_clean_tx_irq(struct i4
  
  		if (budget &&
  		    ((j / WB_STRIDE) == 0) && (j > 0) &&
++<<<<<<< HEAD
 +		    !test_bit(__I40E_DOWN, &vsi->state) &&
++=======
+ 		    !test_bit(__I40E_VSI_DOWN, vsi->state) &&
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  		    (I40E_DESC_UNUSED(tx_ring) != tx_ring->count))
  			tx_ring->arm_wb = true;
  	}
@@@ -868,7 -868,7 +872,11 @@@
  		smp_mb();
  		if (__netif_subqueue_stopped(tx_ring->netdev,
  					     tx_ring->queue_index) &&
++<<<<<<< HEAD
 +		   !test_bit(__I40E_DOWN, &vsi->state)) {
++=======
+ 		   !test_bit(__I40E_VSI_DOWN, vsi->state)) {
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  			netif_wake_subqueue(tx_ring->netdev,
  					    tx_ring->queue_index);
  			++tx_ring->tx_stats.restart_queue;
@@@ -2189,7 -2179,7 +2197,11 @@@ static inline void i40e_update_enable_i
  	}
  
  enable_int:
++<<<<<<< HEAD
 +	if (!test_bit(__I40E_DOWN, &vsi->state))
++=======
+ 	if (!test_bit(__I40E_VSI_DOWN, vsi->state))
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  		wr32(hw, INTREG(vector - 1), txval);
  
  	if (q_vector->itr_countdown)
@@@ -2218,7 -2208,7 +2230,11 @@@ int i40e_napi_poll(struct napi_struct *
  	int budget_per_ring;
  	int work_done = 0;
  
++<<<<<<< HEAD
 +	if (test_bit(__I40E_DOWN, &vsi->state)) {
++=======
+ 	if (test_bit(__I40E_VSI_DOWN, vsi->state)) {
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  		napi_complete(napi);
  		return 0;
  	}
@@@ -2654,12 -2634,10 +2670,12 @@@ static int i40e_tsyn(struct i40e_ring *
  		return 0;
  
  	if (pf->ptp_tx &&
- 	    !test_and_set_bit_lock(__I40E_PTP_TX_IN_PROGRESS, &pf->state)) {
+ 	    !test_and_set_bit_lock(__I40E_PTP_TX_IN_PROGRESS, pf->state)) {
  		skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
 +		pf->ptp_tx_start = jiffies;
  		pf->ptp_tx_skb = skb_get(skb);
  	} else {
 +		pf->tx_hwtstamp_skipped++;
  		return 0;
  	}
  
diff --cc drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
index f469a3d68beb,95c23fbaa211..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
@@@ -1078,6 -1077,106 +1078,109 @@@ void i40e_reset_vf(struct i40e_vf *vf, 
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * i40e_reset_all_vfs
+  * @pf: pointer to the PF structure
+  * @flr: VFLR was issued or not
+  *
+  * Reset all allocated VFs in one go. First, tell the hardware to reset each
+  * VF, then do all the waiting in one chunk, and finally finish restoring each
+  * VF after the wait. This is useful during PF routines which need to reset
+  * all VFs, as otherwise it must perform these resets in a serialized fashion.
+  **/
+ void i40e_reset_all_vfs(struct i40e_pf *pf, bool flr)
+ {
+ 	struct i40e_hw *hw = &pf->hw;
+ 	struct i40e_vf *vf;
+ 	int i, v;
+ 	u32 reg;
+ 
+ 	/* If we don't have any VFs, then there is nothing to reset */
+ 	if (!pf->num_alloc_vfs)
+ 		return;
+ 
+ 	/* If VFs have been disabled, there is no need to reset */
+ 	if (test_and_set_bit(__I40E_VF_DISABLE, pf->state))
+ 		return;
+ 
+ 	/* Begin reset on all VFs at once */
+ 	for (v = 0; v < pf->num_alloc_vfs; v++)
+ 		i40e_trigger_vf_reset(&pf->vf[v], flr);
+ 
+ 	/* HW requires some time to make sure it can flush the FIFO for a VF
+ 	 * when it resets it. Poll the VPGEN_VFRSTAT register for each VF in
+ 	 * sequence to make sure that it has completed. We'll keep track of
+ 	 * the VFs using a simple iterator that increments once that VF has
+ 	 * finished resetting.
+ 	 */
+ 	for (i = 0, v = 0; i < 10 && v < pf->num_alloc_vfs; i++) {
+ 		usleep_range(10000, 20000);
+ 
+ 		/* Check each VF in sequence, beginning with the VF to fail
+ 		 * the previous check.
+ 		 */
+ 		while (v < pf->num_alloc_vfs) {
+ 			vf = &pf->vf[v];
+ 			reg = rd32(hw, I40E_VPGEN_VFRSTAT(vf->vf_id));
+ 			if (!(reg & I40E_VPGEN_VFRSTAT_VFRD_MASK))
+ 				break;
+ 
+ 			/* If the current VF has finished resetting, move on
+ 			 * to the next VF in sequence.
+ 			 */
+ 			v++;
+ 		}
+ 	}
+ 
+ 	if (flr)
+ 		usleep_range(10000, 20000);
+ 
+ 	/* Display a warning if at least one VF didn't manage to reset in
+ 	 * time, but continue on with the operation.
+ 	 */
+ 	if (v < pf->num_alloc_vfs)
+ 		dev_err(&pf->pdev->dev, "VF reset check timeout on VF %d\n",
+ 			pf->vf[v].vf_id);
+ 	usleep_range(10000, 20000);
+ 
+ 	/* Begin disabling all the rings associated with VFs, but do not wait
+ 	 * between each VF.
+ 	 */
+ 	for (v = 0; v < pf->num_alloc_vfs; v++) {
+ 		/* On initial reset, we don't have any queues to disable */
+ 		if (pf->vf[v].lan_vsi_idx == 0)
+ 			continue;
+ 
+ 		i40e_vsi_stop_rings_no_wait(pf->vsi[pf->vf[v].lan_vsi_idx]);
+ 	}
+ 
+ 	/* Now that we've notified HW to disable all of the VF rings, wait
+ 	 * until they finish.
+ 	 */
+ 	for (v = 0; v < pf->num_alloc_vfs; v++) {
+ 		/* On initial reset, we don't have any queues to disable */
+ 		if (pf->vf[v].lan_vsi_idx == 0)
+ 			continue;
+ 
+ 		i40e_vsi_wait_queues_disabled(pf->vsi[pf->vf[v].lan_vsi_idx]);
+ 	}
+ 
+ 	/* Hw may need up to 50ms to finish disabling the RX queues. We
+ 	 * minimize the wait by delaying only once for all VFs.
+ 	 */
+ 	mdelay(50);
+ 
+ 	/* Finish the reset on each VF */
+ 	for (v = 0; v < pf->num_alloc_vfs; v++)
+ 		i40e_cleanup_reset_vf(&pf->vf[v]);
+ 
+ 	i40e_flush(hw);
+ 	clear_bit(__I40E_VF_DISABLE, pf->state);
+ }
+ 
+ /**
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
   * i40e_free_vfs
   * @pf: pointer to the PF structure
   *
diff --cc drivers/net/ethernet/intel/i40evf/i40e_txrx.c
index 233018459571,dfe241a12ad0..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
@@@ -266,7 -266,7 +266,11 @@@ static bool i40e_clean_tx_irq(struct i4
  
  		if (budget &&
  		    ((j / WB_STRIDE) == 0) && (j > 0) &&
++<<<<<<< HEAD
 +		    !test_bit(__I40E_DOWN, &vsi->state) &&
++=======
+ 		    !test_bit(__I40E_VSI_DOWN, vsi->state) &&
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  		    (I40E_DESC_UNUSED(tx_ring) != tx_ring->count))
  			tx_ring->arm_wb = true;
  	}
@@@ -284,7 -284,7 +288,11 @@@
  		smp_mb();
  		if (__netif_subqueue_stopped(tx_ring->netdev,
  					     tx_ring->queue_index) &&
++<<<<<<< HEAD
 +		   !test_bit(__I40E_DOWN, &vsi->state)) {
++=======
+ 		   !test_bit(__I40E_VSI_DOWN, vsi->state)) {
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  			netif_wake_subqueue(tx_ring->netdev,
  					    tx_ring->queue_index);
  			++tx_ring->tx_stats.restart_queue;
@@@ -1496,7 -1508,7 +1504,11 @@@ static inline void i40e_update_enable_i
  	}
  
  enable_int:
++<<<<<<< HEAD
 +	if (!test_bit(__I40E_DOWN, &vsi->state))
++=======
+ 	if (!test_bit(__I40E_VSI_DOWN, vsi->state))
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  		wr32(hw, INTREG(vector - 1), txval);
  
  	if (q_vector->itr_countdown)
@@@ -1525,7 -1537,7 +1537,11 @@@ int i40evf_napi_poll(struct napi_struc
  	int budget_per_ring;
  	int work_done = 0;
  
++<<<<<<< HEAD
 +	if (test_bit(__I40E_DOWN, &vsi->state)) {
++=======
+ 	if (test_bit(__I40E_VSI_DOWN, vsi->state)) {
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  		napi_complete(napi);
  		return 0;
  	}
diff --cc drivers/net/ethernet/intel/i40evf/i40evf.h
index ed7a5b569aba,4681c63ee7e3..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40evf.h
+++ b/drivers/net/ethernet/intel/i40evf/i40evf.h
@@@ -49,6 -49,13 +49,16 @@@
  #define DEFAULT_DEBUG_LEVEL_SHIFT 3
  #define PFX "i40evf: "
  
++<<<<<<< HEAD
++=======
+ /* VSI state flags shared with common code */
+ enum i40evf_vsi_state_t {
+ 	__I40E_VSI_DOWN,
+ 	/* This must be last as it determines the size of the BITMAP */
+ 	__I40E_VSI_STATE_SIZE__,
+ };
+ 
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  /* dummy struct to make common code less painful */
  struct i40e_vsi {
  	struct i40evf_adapter *back;
diff --cc drivers/net/ethernet/intel/i40evf/i40evf_main.c
index cbf404c7e769,8e6276d864e6..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40evf_main.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_main.c
@@@ -497,7 -497,7 +497,11 @@@ static void i40evf_netpoll(struct net_d
  	int i;
  
  	/* if interface is down do nothing */
++<<<<<<< HEAD
 +	if (test_bit(__I40E_DOWN, &adapter->vsi.state))
++=======
+ 	if (test_bit(__I40E_VSI_DOWN, adapter->vsi.state))
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  		return;
  
  	for (i = 0; i < q_vectors; i++)
@@@ -1061,7 -1087,7 +1065,11 @@@ static void i40evf_configure(struct i40
  static void i40evf_up_complete(struct i40evf_adapter *adapter)
  {
  	adapter->state = __I40EVF_RUNNING;
++<<<<<<< HEAD
 +	clear_bit(__I40E_DOWN, &adapter->vsi.state);
++=======
+ 	clear_bit(__I40E_VSI_DOWN, adapter->vsi.state);
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  
  	i40evf_napi_enable_all(adapter);
  
@@@ -1727,7 -1753,7 +1735,11 @@@ static void i40evf_disable_vf(struct i4
  	adapter->flags |= I40EVF_FLAG_PF_COMMS_FAILED;
  
  	if (netif_running(adapter->netdev)) {
++<<<<<<< HEAD
 +		set_bit(__I40E_DOWN, &adapter->vsi.state);
++=======
+ 		set_bit(__I40E_VSI_DOWN, adapter->vsi.state);
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  		netif_carrier_off(adapter->netdev);
  		netif_tx_disable(adapter->netdev);
  		adapter->link_up = false;
@@@ -2207,7 -2233,7 +2219,11 @@@ static int i40evf_close(struct net_devi
  		return 0;
  
  
++<<<<<<< HEAD
 +	set_bit(__I40E_DOWN, &adapter->vsi.state);
++=======
+ 	set_bit(__I40E_VSI_DOWN, adapter->vsi.state);
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  	if (CLIENT_ENABLED(adapter))
  		adapter->flags |= I40EVF_FLAG_CLIENT_NEEDS_CLOSE;
  
@@@ -2643,7 -2674,7 +2659,11 @@@ static void i40evf_init_task(struct wor
  		dev_info(&pdev->dev, "GRO is enabled\n");
  
  	adapter->state = __I40EVF_DOWN;
++<<<<<<< HEAD
 +	set_bit(__I40E_DOWN, &adapter->vsi.state);
++=======
+ 	set_bit(__I40E_VSI_DOWN, adapter->vsi.state);
++>>>>>>> 0da36b9774cc (i40e: use DECLARE_BITMAP for state fields)
  	i40evf_misc_irq_enable(adapter);
  
  	adapter->rss_key = kzalloc(adapter->rss_key_size, GFP_KERNEL);
* Unmerged path drivers/net/ethernet/intel/i40e/i40e.h
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_client.c
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_debugfs.c
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_ethtool.c
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_main.c
diff --git a/drivers/net/ethernet/intel/i40e/i40e_ptp.c b/drivers/net/ethernet/intel/i40e/i40e_ptp.c
index db534713497b..294d2f44ca6e 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_ptp.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_ptp.c
@@ -387,7 +387,7 @@ void i40e_ptp_tx_hwtstamp(struct i40e_pf *pf)
 	skb_tstamp_tx(pf->ptp_tx_skb, &shhwtstamps);
 	dev_kfree_skb_any(pf->ptp_tx_skb);
 	pf->ptp_tx_skb = NULL;
-	clear_bit_unlock(__I40E_PTP_TX_IN_PROGRESS, &pf->state);
+	clear_bit_unlock(__I40E_PTP_TX_IN_PROGRESS, pf->state);
 }
 
 /**
@@ -797,7 +797,7 @@ void i40e_ptp_stop(struct i40e_pf *pf)
 	if (pf->ptp_tx_skb) {
 		dev_kfree_skb_any(pf->ptp_tx_skb);
 		pf->ptp_tx_skb = NULL;
-		clear_bit_unlock(__I40E_PTP_TX_IN_PROGRESS, &pf->state);
+		clear_bit_unlock(__I40E_PTP_TX_IN_PROGRESS, pf->state);
 	}
 
 	if (pf->ptp_clock) {
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_txrx.c
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
* Unmerged path drivers/net/ethernet/intel/i40evf/i40e_txrx.c
* Unmerged path drivers/net/ethernet/intel/i40evf/i40evf.h
* Unmerged path drivers/net/ethernet/intel/i40evf/i40evf_main.c
