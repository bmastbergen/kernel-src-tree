tpm: enhance read_log_of() to support Physical TPM event log

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Nayna Jain <nayna@linux.vnet.ibm.com>
commit e46e22f12b19f0068b02afcf6edb716b4f49934f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e46e22f1.failed

Physical TPMs use Open Firmware Device Tree bindings that are similar
to the IBM Power virtual TPM to support event log. However, these
properties store the values in different endianness for Physical
and Virtual TPM.

This patch fixes the endianness issue by doing appropriate conversion
based on Physical or Virtual TPM.

	Signed-off-by: Nayna Jain <nayna@linux.vnet.ibm.com>
	Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Tested-by: Kenneth Goldman <kgold@linux.vnet.ibm.com>
	Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
(cherry picked from commit e46e22f12b19f0068b02afcf6edb716b4f49934f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/tpm/tpm_of.c
diff --cc drivers/char/tpm/tpm_of.c
index 12a86dda3b69,de57d4ac8901..000000000000
--- a/drivers/char/tpm/tpm_of.c
+++ b/drivers/char/tpm/tpm_of.c
@@@ -27,44 -27,51 +27,79 @@@ int tpm_read_log_of(struct tpm_chip *ch
  	const u32 *sizep;
  	const u64 *basep;
  	struct tpm_bios_log *log;
+ 	u32 size;
+ 	u64 base;
  
  	log = &chip->log;
 -	if (chip->dev.parent && chip->dev.parent->of_node)
 +	if (chip->dev.parent->of_node)
  		np = chip->dev.parent->of_node;
 -	else
 +	if (!np) {
 +		pr_err("%s: ERROR - IBMVTPM not supported\n", __func__);
  		return -ENODEV;
 +	}
  
  	sizep = of_get_property(np, "linux,sml-size", NULL);
++<<<<<<< HEAD
 +	if (sizep == NULL) {
 +		pr_err("%s: ERROR - SML size not found\n", __func__);
 +		goto cleanup_eio;
 +	}
 +	if (*sizep == 0) {
 +		pr_err("%s: ERROR - event log area empty\n", __func__);
 +		goto cleanup_eio;
 +	}
 +
 +	basep = of_get_property(np, "linux,sml-base", NULL);
 +	if (basep == NULL) {
 +		pr_err("%s: ERROR - SML not found\n", __func__);
 +		goto cleanup_eio;
 +	}
 +
 +	log->bios_event_log = kmalloc(*sizep, GFP_KERNEL);
 +	if (!log->bios_event_log) {
 +		pr_err("%s: ERROR - Not enough memory for BIOS measurements\n",
 +		       __func__);
++=======
+ 	basep = of_get_property(np, "linux,sml-base", NULL);
+ 	if (sizep == NULL && basep == NULL)
+ 		return -ENODEV;
+ 	if (sizep == NULL || basep == NULL)
+ 		return -EIO;
+ 
+ 	/*
+ 	 * For both vtpm/tpm, firmware has log addr and log size in big
+ 	 * endian format. But in case of vtpm, there is a method called
+ 	 * sml-handover which is run during kernel init even before
+ 	 * device tree is setup. This sml-handover function takes care
+ 	 * of endianness and writes to sml-base and sml-size in little
+ 	 * endian format. For this reason, vtpm doesn't need conversion
+ 	 * but physical tpm needs the conversion.
+ 	 */
+ 	if (of_property_match_string(np, "compatible", "IBM,vtpm") < 0) {
+ 		size = be32_to_cpup(sizep);
+ 		base = be64_to_cpup(basep);
+ 	} else {
+ 		size = *sizep;
+ 		base = *basep;
+ 	}
+ 
+ 	if (size == 0) {
+ 		dev_warn(&chip->dev, "%s: Event log area empty\n", __func__);
+ 		return -EIO;
+ 	}
+ 
+ 	log->bios_event_log = kmalloc(size, GFP_KERNEL);
+ 	if (!log->bios_event_log)
++>>>>>>> e46e22f12b19 (tpm: enhance read_log_of() to support Physical TPM event log)
  		return -ENOMEM;
 +	}
  
- 	log->bios_event_log_end = log->bios_event_log + *sizep;
+ 	log->bios_event_log_end = log->bios_event_log + size;
  
- 	memcpy(log->bios_event_log, __va(*basep), *sizep);
+ 	memcpy(log->bios_event_log, __va(base), size);
  
  	return 0;
 +
 +cleanup_eio:
 +	return -EIO;
  }
* Unmerged path drivers/char/tpm/tpm_of.c
