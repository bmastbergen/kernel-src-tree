IB/SA: Add OPA path record type

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Dasaratharaman Chandramouli <dasaratharaman.chandramouli@intel.com>
commit 57520751445b837c20a8e658e3dae3a7e7ddf45c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/57520751.failed

Add opa_sa_path_rec to sa_path_rec data structure.
The 'type' field in sa_path_rec identifies the
type of the path record.

	Reviewed-by: Don Hiatt <don.hiatt@intel.com>
	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Signed-off-by: Dasaratharaman Chandramouli <dasaratharaman.chandramouli@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 57520751445b837c20a8e658e3dae3a7e7ddf45c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/cm.c
#	drivers/infiniband/core/sa_query.c
#	drivers/infiniband/core/uverbs_marshall.c
#	drivers/infiniband/ulp/ipoib/ipoib_fs.c
#	drivers/infiniband/ulp/ipoib/ipoib_main.c
#	drivers/infiniband/ulp/srp/ib_srp.c
#	include/rdma/ib_sa.h
diff --cc drivers/infiniband/core/cm.c
index 70c24aef631d,1844770f3ae8..000000000000
--- a/drivers/infiniband/core/cm.c
+++ b/drivers/infiniband/core/cm.c
@@@ -1202,8 -1203,10 +1202,15 @@@ static void cm_format_req(struct cm_req
  	}
  
  	if (pri_path->hop_limit <= 1) {
++<<<<<<< HEAD
 +		req_msg->primary_local_lid = pri_path->slid;
 +		req_msg->primary_remote_lid = pri_path->dlid;
++=======
+ 		req_msg->primary_local_lid =
+ 			htons(ntohl(sa_path_get_slid(pri_path)));
+ 		req_msg->primary_remote_lid =
+ 			htons(ntohl(sa_path_get_dlid(pri_path)));
++>>>>>>> 57520751445b (IB/SA: Add OPA path record type)
  	} else {
  		/* Work-around until there's a way to obtain remote LID info */
  		req_msg->primary_local_lid = IB_LID_PERMISSIVE;
@@@ -1223,8 -1226,10 +1230,15 @@@
  
  	if (alt_path) {
  		if (alt_path->hop_limit <= 1) {
++<<<<<<< HEAD
 +			req_msg->alt_local_lid = alt_path->slid;
 +			req_msg->alt_remote_lid = alt_path->dlid;
++=======
+ 			req_msg->alt_local_lid =
+ 				htons(ntohl(sa_path_get_slid(alt_path)));
+ 			req_msg->alt_remote_lid =
+ 				htons(ntohl(sa_path_get_dlid(alt_path)));
++>>>>>>> 57520751445b (IB/SA: Add OPA path record type)
  		} else {
  			req_msg->alt_local_lid = IB_LID_PERMISSIVE;
  			req_msg->alt_remote_lid = IB_LID_PERMISSIVE;
@@@ -1401,14 -1406,15 +1415,21 @@@ static inline int cm_is_active_peer(__b
  }
  
  static void cm_format_paths_from_req(struct cm_req_msg *req_msg,
 -				     struct sa_path_rec *primary_path,
 -				     struct sa_path_rec *alt_path)
 +					    struct ib_sa_path_rec *primary_path,
 +					    struct ib_sa_path_rec *alt_path)
  {
 +	memset(primary_path, 0, sizeof(*primary_path));
  	primary_path->dgid = req_msg->primary_local_gid;
  	primary_path->sgid = req_msg->primary_remote_gid;
++<<<<<<< HEAD
 +	primary_path->dlid = req_msg->primary_local_lid;
 +	primary_path->slid = req_msg->primary_remote_lid;
++=======
+ 	sa_path_set_dlid(primary_path,
+ 			 htonl(ntohs(req_msg->primary_local_lid)));
+ 	sa_path_set_slid(primary_path,
+ 			 htonl(ntohs(req_msg->primary_remote_lid)));
++>>>>>>> 57520751445b (IB/SA: Add OPA path record type)
  	primary_path->flow_label = cm_req_get_primary_flow_label(req_msg);
  	primary_path->hop_limit = req_msg->primary_hop_limit;
  	primary_path->traffic_class = req_msg->primary_traffic_class;
@@@ -1423,14 -1429,15 +1444,21 @@@
  	primary_path->packet_life_time =
  		cm_req_get_primary_local_ack_timeout(req_msg);
  	primary_path->packet_life_time -= (primary_path->packet_life_time > 0);
 -	sa_path_set_service_id(primary_path, req_msg->service_id);
 +	primary_path->service_id = req_msg->service_id;
  
  	if (req_msg->alt_local_lid) {
 +		memset(alt_path, 0, sizeof(*alt_path));
  		alt_path->dgid = req_msg->alt_local_gid;
  		alt_path->sgid = req_msg->alt_remote_gid;
++<<<<<<< HEAD
 +		alt_path->dlid = req_msg->alt_local_lid;
 +		alt_path->slid = req_msg->alt_remote_lid;
++=======
+ 		sa_path_set_dlid(alt_path,
+ 				 htonl(ntohs(req_msg->alt_local_lid)));
+ 		sa_path_set_slid(alt_path,
+ 				 htonl(ntohs(req_msg->alt_remote_lid)));
++>>>>>>> 57520751445b (IB/SA: Add OPA path record type)
  		alt_path->flow_label = cm_req_get_alt_flow_label(req_msg);
  		alt_path->hop_limit = req_msg->alt_hop_limit;
  		alt_path->traffic_class = req_msg->alt_traffic_class;
@@@ -2822,8 -2850,10 +2850,15 @@@ static void cm_format_lap(struct cm_lap
  	cm_lap_set_remote_qpn(lap_msg, cm_id_priv->remote_qpn);
  	/* todo: need remote CM response timeout */
  	cm_lap_set_remote_resp_timeout(lap_msg, 0x1F);
++<<<<<<< HEAD
 +	lap_msg->alt_local_lid = alternate_path->slid;
 +	lap_msg->alt_remote_lid = alternate_path->dlid;
++=======
+ 	lap_msg->alt_local_lid =
+ 		htons(ntohl(sa_path_get_slid(alternate_path)));
+ 	lap_msg->alt_remote_lid =
+ 		htons(ntohl(sa_path_get_dlid(alternate_path)));
++>>>>>>> 57520751445b (IB/SA: Add OPA path record type)
  	lap_msg->alt_local_gid = alternate_path->sgid;
  	lap_msg->alt_remote_gid = alternate_path->dgid;
  	cm_lap_set_flow_label(lap_msg, alternate_path->flow_label);
@@@ -2899,10 -2929,11 +2934,15 @@@ static void cm_format_path_from_lap(str
  				    struct cm_lap_msg *lap_msg)
  {
  	memset(path, 0, sizeof *path);
 -	path->rec_type = SA_PATH_REC_TYPE_IB;
  	path->dgid = lap_msg->alt_local_gid;
  	path->sgid = lap_msg->alt_remote_gid;
++<<<<<<< HEAD
 +	path->dlid = lap_msg->alt_local_lid;
 +	path->slid = lap_msg->alt_remote_lid;
++=======
+ 	sa_path_set_dlid(path, htonl(ntohs(lap_msg->alt_local_lid)));
+ 	sa_path_set_slid(path, htonl(ntohs(lap_msg->alt_remote_lid)));
++>>>>>>> 57520751445b (IB/SA: Add OPA path record type)
  	path->flow_label = cm_lap_get_flow_label(lap_msg);
  	path->hop_limit = lap_msg->alt_hop_limit;
  	path->traffic_class = cm_lap_get_traffic_class(lap_msg);
diff --cc drivers/infiniband/core/sa_query.c
index 17b24d8a34e1,249247609b60..000000000000
--- a/drivers/infiniband/core/sa_query.c
+++ b/drivers/infiniband/core/sa_query.c
@@@ -1007,13 -1108,14 +1007,22 @@@ int ib_init_ah_from_path(struct ib_devi
  	struct net_device *ndev = NULL;
  
  	memset(ah_attr, 0, sizeof *ah_attr);
 -	ah_attr->type = rdma_ah_find_type(device, port_num);
 -
 +	ah_attr->dlid = be16_to_cpu(rec->dlid);
 +	ah_attr->sl = rec->sl;
 +	ah_attr->src_path_bits = be16_to_cpu(rec->slid) &
 +				 get_src_path_mask(device, port_num);
 +	ah_attr->port_num = port_num;
 +	ah_attr->static_rate = rec->rate;
 +
++<<<<<<< HEAD
++=======
+ 	rdma_ah_set_dlid(ah_attr, be32_to_cpu(sa_path_get_dlid(rec)));
+ 	rdma_ah_set_sl(ah_attr, rec->sl);
+ 	rdma_ah_set_path_bits(ah_attr, be32_to_cpu(sa_path_get_slid(rec)) &
+ 			      get_src_path_mask(device, port_num));
+ 	rdma_ah_set_port_num(ah_attr, port_num);
+ 	rdma_ah_set_static_rate(ah_attr, rec->rate);
++>>>>>>> 57520751445b (IB/SA: Add OPA path record type)
  	use_roce = rdma_cap_eth_ah(device, port_num);
  
  	if (use_roce) {
diff --cc drivers/infiniband/core/uverbs_marshall.c
index a9739f334562,8b9587fe2303..000000000000
--- a/drivers/infiniband/core/uverbs_marshall.c
+++ b/drivers/infiniband/core/uverbs_marshall.c
@@@ -93,15 -96,15 +93,26 @@@ void ib_copy_qp_attr_to_user(struct ib_
  }
  EXPORT_SYMBOL(ib_copy_qp_attr_to_user);
  
++<<<<<<< HEAD
 +void ib_copy_path_rec_to_user(struct ib_user_path_rec *dst,
 +			      struct ib_sa_path_rec *src)
++=======
+ void __ib_copy_path_rec_to_user(struct ib_user_path_rec *dst,
+ 				struct sa_path_rec *src)
++>>>>>>> 57520751445b (IB/SA: Add OPA path record type)
  {
  	memcpy(dst->dgid, src->dgid.raw, sizeof src->dgid);
  	memcpy(dst->sgid, src->sgid.raw, sizeof src->sgid);
  
++<<<<<<< HEAD
 +	dst->dlid		= src->dlid;
 +	dst->slid		= src->slid;
 +	dst->raw_traffic	= src->raw_traffic;
++=======
+ 	dst->dlid		= htons(ntohl(sa_path_get_dlid(src)));
+ 	dst->slid		= htons(ntohl(sa_path_get_slid(src)));
+ 	dst->raw_traffic	= sa_path_get_raw_traffic(src);
++>>>>>>> 57520751445b (IB/SA: Add OPA path record type)
  	dst->flow_label		= src->flow_label;
  	dst->hop_limit		= src->hop_limit;
  	dst->traffic_class	= src->traffic_class;
@@@ -117,17 -120,43 +128,49 @@@
  	dst->preference		= src->preference;
  	dst->packet_life_time_selector = src->packet_life_time_selector;
  }
+ 
+ void ib_copy_path_rec_to_user(struct ib_user_path_rec *dst,
+ 			      struct sa_path_rec *src)
+ {
+ 	struct sa_path_rec rec;
+ 
+ 	if (src->rec_type == SA_PATH_REC_TYPE_OPA) {
+ 		sa_convert_path_opa_to_ib(&rec, src);
+ 		__ib_copy_path_rec_to_user(dst, &rec);
+ 		return;
+ 	}
+ 	__ib_copy_path_rec_to_user(dst, src);
+ }
  EXPORT_SYMBOL(ib_copy_path_rec_to_user);
  
 -void ib_copy_path_rec_from_user(struct sa_path_rec *dst,
 +void ib_copy_path_rec_from_user(struct ib_sa_path_rec *dst,
  				struct ib_user_path_rec *src)
  {
+ 	__be32 slid, dlid;
+ 
+ 	memset(dst, 0, sizeof(*dst));
+ 	if ((ib_is_opa_gid((union ib_gid *)src->sgid)) ||
+ 	    (ib_is_opa_gid((union ib_gid *)src->dgid))) {
+ 		dst->rec_type = SA_PATH_REC_TYPE_OPA;
+ 		slid = htonl(opa_get_lid_from_gid((union ib_gid *)src->sgid));
+ 		dlid = htonl(opa_get_lid_from_gid((union ib_gid *)src->dgid));
+ 	} else {
+ 		dst->rec_type = SA_PATH_REC_TYPE_IB;
+ 		slid = htonl(ntohs(src->slid));
+ 		dlid = htonl(ntohs(src->dlid));
+ 	}
  	memcpy(dst->dgid.raw, src->dgid, sizeof dst->dgid);
  	memcpy(dst->sgid.raw, src->sgid, sizeof dst->sgid);
  
++<<<<<<< HEAD
 +	dst->dlid		= src->dlid;
 +	dst->slid		= src->slid;
 +	dst->raw_traffic	= src->raw_traffic;
++=======
+ 	sa_path_set_dlid(dst, dlid);
+ 	sa_path_set_slid(dst, slid);
+ 	sa_path_set_raw_traffic(dst, src->raw_traffic);
++>>>>>>> 57520751445b (IB/SA: Add OPA path record type)
  	dst->flow_label		= src->flow_label;
  	dst->hop_limit		= src->hop_limit;
  	dst->traffic_class	= src->traffic_class;
@@@ -143,9 -172,9 +186,16 @@@
  	dst->preference		= src->preference;
  	dst->packet_life_time_selector = src->packet_life_time_selector;
  
++<<<<<<< HEAD
 +	memset(dst->dmac, 0, sizeof(dst->dmac));
 +	dst->net = NULL;
 +	dst->ifindex = 0;
 +	dst->gid_type = IB_GID_TYPE_IB;
++=======
+ 	/* TODO: No need to set this */
+ 	sa_path_set_dmac_zero(dst);
+ 	sa_path_set_ndev(dst, NULL);
+ 	sa_path_set_ifindex(dst, 0);
++>>>>>>> 57520751445b (IB/SA: Add OPA path record type)
  }
  EXPORT_SYMBOL(ib_copy_path_rec_from_user);
diff --cc drivers/infiniband/ulp/ipoib/ipoib_fs.c
index a15664b880ed,11f74cbe6660..000000000000
--- a/drivers/infiniband/ulp/ipoib/ipoib_fs.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_fs.c
@@@ -219,7 -219,7 +219,11 @@@ static int ipoib_path_seq_show(struct s
  			   "  DLID:     0x%04x\n"
  			   "  SL: %12d\n"
  			   "  rate: %8d.%d Gb/sec\n",
++<<<<<<< HEAD
 +			   be16_to_cpu(path.pathrec.dlid),
++=======
+ 			   be32_to_cpu(sa_path_get_dlid(&path.pathrec)),
++>>>>>>> 57520751445b (IB/SA: Add OPA path record type)
  			   path.pathrec.sl,
  			   rate / 1000, rate % 1000);
  	}
diff --cc drivers/infiniband/ulp/ipoib/ipoib_main.c
index 91ce500f1b9b,2aab637f9d0a..000000000000
--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c
@@@ -668,9 -668,9 +668,15 @@@ void ipoib_mark_paths_invalid(struct ne
  	spin_lock_irq(&priv->lock);
  
  	list_for_each_entry_safe(path, tp, &priv->path_list, list) {
++<<<<<<< HEAD
 +		ipoib_dbg(priv, "mark path LID 0x%04x GID %pI6 invalid\n",
 +			be16_to_cpu(path->pathrec.dlid),
 +			path->pathrec.dgid.raw);
++=======
+ 		ipoib_dbg(priv, "mark path LID 0x%08x GID %pI6 invalid\n",
+ 			  be32_to_cpu(sa_path_get_dlid(&path->pathrec)),
+ 			  path->pathrec.dgid.raw);
++>>>>>>> 57520751445b (IB/SA: Add OPA path record type)
  		path->valid =  0;
  	}
  
@@@ -802,7 -731,8 +808,12 @@@ static void path_rec_completion(int sta
  
  	if (!status)
  		ipoib_dbg(priv, "PathRec LID 0x%04x for GID %pI6\n",
++<<<<<<< HEAD
 +			  be16_to_cpu(pathrec->dlid), pathrec->dgid.raw);
++=======
+ 			  be32_to_cpu(sa_path_get_dlid(pathrec)),
+ 			  pathrec->dgid.raw);
++>>>>>>> 57520751445b (IB/SA: Add OPA path record type)
  	else
  		ipoib_dbg(priv, "PathRec status %d for GID %pI6\n",
  			  status, path->pathrec.dgid.raw);
@@@ -825,7 -755,8 +836,12 @@@
  		path->ah = ah;
  
  		ipoib_dbg(priv, "created address handle %p for LID 0x%04x, SL %d\n",
++<<<<<<< HEAD
 +			  ah, be16_to_cpu(pathrec->dlid), pathrec->sl);
++=======
+ 			  ah, be32_to_cpu(sa_path_get_dlid(pathrec)),
+ 			  pathrec->sl);
++>>>>>>> 57520751445b (IB/SA: Add OPA path record type)
  
  		while ((skb = __skb_dequeue(&path->queue)))
  			__skb_queue_tail(&skqueue, skb);
@@@ -1065,11 -1000,12 +1081,16 @@@ static void unicast_arp_send(struct sk_
  	}
  
  	if (path->ah) {
++<<<<<<< HEAD
 +		ipoib_dbg(priv, "Send unicast ARP to %04x\n",
 +			  be16_to_cpu(path->pathrec.dlid));
++=======
+ 		ipoib_dbg(priv, "Send unicast ARP to %08x\n",
+ 			  be32_to_cpu(sa_path_get_dlid(&path->pathrec)));
++>>>>>>> 57520751445b (IB/SA: Add OPA path record type)
  
  		spin_unlock_irqrestore(&priv->lock, flags);
 -		path->ah->last_send = rn->send(dev, skb, path->ah->ah,
 -					       IPOIB_QPN(phdr->hwaddr));
 +		ipoib_send(dev, skb, path->ah, IPOIB_QPN(phdr->hwaddr));
  		return;
  	} else if ((path->query || !path_rec_start(dev, path)) &&
  		   skb_queue_len(&path->queue) < IPOIB_MAX_PATH_REC_QUEUE) {
diff --cc drivers/infiniband/ulp/srp/ib_srp.c
index a2ef4228ad02,07877a88475d..000000000000
--- a/drivers/infiniband/ulp/srp/ib_srp.c
+++ b/drivers/infiniband/ulp/srp/ib_srp.c
@@@ -2402,7 -2400,7 +2402,11 @@@ static void srp_cm_rej_handler(struct i
  	switch (event->param.rej_rcvd.reason) {
  	case IB_CM_REJ_PORT_CM_REDIRECT:
  		cpi = event->param.rej_rcvd.ari;
++<<<<<<< HEAD
 +		ch->path.dlid = cpi->redirect_lid;
++=======
+ 		sa_path_set_dlid(&ch->path, htonl(ntohs(cpi->redirect_lid)));
++>>>>>>> 57520751445b (IB/SA: Add OPA path record type)
  		ch->path.pkey = cpi->redirect_pkey;
  		cm_id->remote_cm_qpn = be32_to_cpu(cpi->redirect_qp) & 0x00ffffff;
  		memcpy(ch->path.dgid.raw, cpi->redirect_gid, 16);
diff --cc include/rdma/ib_sa.h
index fd0e53219f93,f5f70e345318..000000000000
--- a/include/rdma/ib_sa.h
+++ b/include/rdma/ib_sa.h
@@@ -43,6 -43,8 +43,11 @@@
  
  #include <rdma/ib_verbs.h>
  #include <rdma/ib_mad.h>
++<<<<<<< HEAD
++=======
+ #include <rdma/ib_addr.h>
+ #include <rdma/opa_addr.h>
++>>>>>>> 57520751445b (IB/SA: Add OPA path record type)
  
  enum {
  	IB_SA_CLASS_VERSION		= 2,	/* IB spec version 1.1/1.2 */
@@@ -147,13 -150,45 +152,54 @@@ enum ib_sa_mc_join_states 
  #define IB_SA_PATH_REC_PACKET_LIFE_TIME			IB_SA_COMP_MASK(21)
  #define IB_SA_PATH_REC_PREFERENCE			IB_SA_COMP_MASK(22)
  
++<<<<<<< HEAD
 +struct ib_sa_path_rec {
++=======
+ enum sa_path_rec_type {
+ 	SA_PATH_REC_TYPE_IB,
+ 	SA_PATH_REC_TYPE_ROCE_V1,
+ 	SA_PATH_REC_TYPE_ROCE_V2,
+ 	SA_PATH_REC_TYPE_OPA
+ };
+ 
+ struct sa_path_rec_ib {
++>>>>>>> 57520751445b (IB/SA: Add OPA path record type)
  	__be64       service_id;
 +	union ib_gid dgid;
 +	union ib_gid sgid;
  	__be16       dlid;
  	__be16       slid;
  	u8           raw_traffic;
++<<<<<<< HEAD
++=======
+ };
+ 
+ struct sa_path_rec_roce {
+ 	u8           dmac[ETH_ALEN];
+ 	/* ignored in IB */
+ 	int	     ifindex;
+ 	/* ignored in IB */
+ 	struct net  *net;
+ 
+ };
+ 
+ struct sa_path_rec_opa {
+ 	__be64       service_id;
+ 	__be32       dlid;
+ 	__be32       slid;
+ 	u8           raw_traffic;
+ 	u8	     l2_8B;
+ 	u8	     l2_10B;
+ 	u8	     l2_9B;
+ 	u8	     l2_16B;
+ 	u8	     qos_type;
+ 	u8	     qos_priority;
+ };
+ 
+ struct sa_path_rec {
+ 	union ib_gid dgid;
+ 	union ib_gid sgid;
++>>>>>>> 57520751445b (IB/SA: Add OPA path record type)
  	/* reserved */
  	__be32       flow_label;
  	u8           hop_limit;
@@@ -170,19 -205,111 +216,99 @@@
  	u8           packet_life_time_selector;
  	u8           packet_life_time;
  	u8           preference;
++<<<<<<< HEAD
 +	u8           dmac[ETH_ALEN];
 +	/* ignored in IB */
 +	int	     ifindex;
 +	/* ignored in IB */
 +	struct net  *net;
 +	enum ib_gid_type gid_type;
++=======
+ 	union {
+ 		struct sa_path_rec_ib ib;
+ 		struct sa_path_rec_roce roce;
+ 		struct sa_path_rec_opa opa;
+ 	};
+ 	enum sa_path_rec_type rec_type;
++>>>>>>> 57520751445b (IB/SA: Add OPA path record type)
  };
  
 -static inline enum ib_gid_type
 -		sa_conv_pathrec_to_gid_type(struct sa_path_rec *rec)
 -{
 -	switch (rec->rec_type) {
 -	case SA_PATH_REC_TYPE_ROCE_V1:
 -		return IB_GID_TYPE_ROCE;
 -	case SA_PATH_REC_TYPE_ROCE_V2:
 -		return IB_GID_TYPE_ROCE_UDP_ENCAP;
 -	default:
 -		return IB_GID_TYPE_IB;
 -	}
 -}
 -
 -static inline enum sa_path_rec_type
 -		sa_conv_gid_to_pathrec_type(enum ib_gid_type type)
 +static inline struct net_device *ib_get_ndev_from_path(struct ib_sa_path_rec *rec)
  {
 -	switch (type) {
 -	case IB_GID_TYPE_ROCE:
 -		return SA_PATH_REC_TYPE_ROCE_V1;
 -	case IB_GID_TYPE_ROCE_UDP_ENCAP:
 -		return SA_PATH_REC_TYPE_ROCE_V2;
 -	default:
 -		return SA_PATH_REC_TYPE_IB;
 -	}
 +	return rec->net ? dev_get_by_index(rec->net, rec->ifindex) : NULL;
  }
  
+ static inline void path_conv_opa_to_ib(struct sa_path_rec *ib,
+ 				       struct sa_path_rec *opa)
+ {
+ 	if ((be32_to_cpu(opa->opa.dlid) >=
+ 	     be16_to_cpu(IB_MULTICAST_LID_BASE)) ||
+ 	    (be32_to_cpu(opa->opa.slid) >=
+ 	     be16_to_cpu(IB_MULTICAST_LID_BASE))) {
+ 		/* Create OPA GID and zero out the LID */
+ 		ib->dgid.global.interface_id
+ 				= OPA_MAKE_ID(be32_to_cpu(opa->opa.dlid));
+ 		ib->dgid.global.subnet_prefix
+ 				= opa->dgid.global.subnet_prefix;
+ 		ib->sgid.global.interface_id
+ 				= OPA_MAKE_ID(be32_to_cpu(opa->opa.slid));
+ 		ib->dgid.global.subnet_prefix
+ 				= opa->dgid.global.subnet_prefix;
+ 		ib->ib.dlid	= 0;
+ 
+ 		ib->ib.slid	= 0;
+ 	} else {
+ 		ib->ib.dlid	= htons(ntohl(opa->opa.dlid));
+ 		ib->ib.slid	= htons(ntohl(opa->opa.slid));
+ 	}
+ 	ib->ib.service_id	= opa->opa.service_id;
+ 	ib->ib.raw_traffic	= opa->opa.raw_traffic;
+ }
+ 
+ static inline void path_conv_ib_to_opa(struct sa_path_rec *opa,
+ 				       struct sa_path_rec *ib)
+ {
+ 	__be32 slid, dlid;
+ 
+ 	if ((ib_is_opa_gid(&ib->sgid)) ||
+ 	    (ib_is_opa_gid(&ib->dgid))) {
+ 		slid = htonl(opa_get_lid_from_gid(&ib->sgid));
+ 		dlid = htonl(opa_get_lid_from_gid(&ib->dgid));
+ 	} else {
+ 		slid = htonl(ntohs(ib->ib.slid));
+ 		dlid = htonl(ntohs(ib->ib.dlid));
+ 	}
+ 	opa->opa.slid		= slid;
+ 	opa->opa.dlid		= dlid;
+ 	opa->opa.service_id	= ib->ib.service_id;
+ 	opa->opa.raw_traffic	= ib->ib.raw_traffic;
+ }
+ 
+ /* Convert from OPA to IB path record */
+ static inline void sa_convert_path_opa_to_ib(struct sa_path_rec *dest,
+ 					     struct sa_path_rec *src)
+ {
+ 	if (src->rec_type != SA_PATH_REC_TYPE_OPA)
+ 		return;
+ 
+ 	*dest = *src;
+ 	dest->rec_type = SA_PATH_REC_TYPE_IB;
+ 	path_conv_opa_to_ib(dest, src);
+ }
+ 
+ /* Convert from IB to OPA path record */
+ static inline void sa_convert_path_ib_to_opa(struct sa_path_rec *dest,
+ 					     struct sa_path_rec *src)
+ {
+ 	if (src->rec_type != SA_PATH_REC_TYPE_IB)
+ 		return;
+ 
+ 	/* Do a structure copy and overwrite the relevant fields */
+ 	*dest = *src;
+ 	dest->rec_type = SA_PATH_REC_TYPE_OPA;
+ 	path_conv_ib_to_opa(dest, src);
+ }
+ 
  #define IB_SA_MCMEMBER_REC_MGID				IB_SA_COMP_MASK( 0)
  #define IB_SA_MCMEMBER_REC_PORT_GID			IB_SA_COMP_MASK( 1)
  #define IB_SA_MCMEMBER_REC_QKEY				IB_SA_COMP_MASK( 2)
@@@ -454,14 -581,137 +580,149 @@@ int ib_sa_guid_info_rec_query(struct ib
  			      void *context,
  			      struct ib_sa_query **sa_query);
  
++<<<<<<< HEAD
 +/* Support get SA ClassPortInfo */
 +int ib_sa_classport_info_rec_query(struct ib_sa_client *client,
 +				   struct ib_device *device, u8 port_num,
 +				   int timeout_ms, gfp_t gfp_mask,
 +				   void (*callback)(int status,
 +						    struct ib_class_port_info *resp,
 +						    void *context),
 +				   void *context,
 +				   struct ib_sa_query **sa_query);
++=======
+ bool ib_sa_sendonly_fullmem_support(struct ib_sa_client *client,
+ 				    struct ib_device *device,
+ 				    u8 port_num);
+ 
+ static inline bool sa_path_is_roce(struct sa_path_rec *rec)
+ {
+ 	return ((rec->rec_type == SA_PATH_REC_TYPE_ROCE_V1) ||
+ 		(rec->rec_type == SA_PATH_REC_TYPE_ROCE_V2));
+ }
+ 
+ static inline void sa_path_set_service_id(struct sa_path_rec *rec,
+ 					  __be64 service_id)
+ {
+ 	if (rec->rec_type == SA_PATH_REC_TYPE_IB)
+ 		rec->ib.service_id = service_id;
+ 	else if (rec->rec_type == SA_PATH_REC_TYPE_OPA)
+ 		rec->opa.service_id = service_id;
+ }
+ 
+ static inline void sa_path_set_slid(struct sa_path_rec *rec, __be32 slid)
+ {
+ 	if (rec->rec_type == SA_PATH_REC_TYPE_IB)
+ 		rec->ib.slid = htons(ntohl(slid));
+ 	else if (rec->rec_type == SA_PATH_REC_TYPE_OPA)
+ 		rec->opa.slid = slid;
+ }
+ 
+ static inline void sa_path_set_dlid(struct sa_path_rec *rec, __be32 dlid)
+ {
+ 	if (rec->rec_type == SA_PATH_REC_TYPE_IB)
+ 		rec->ib.dlid = htons(ntohl(dlid));
+ 	else if (rec->rec_type == SA_PATH_REC_TYPE_OPA)
+ 		rec->opa.dlid = dlid;
+ }
+ 
+ static inline void sa_path_set_raw_traffic(struct sa_path_rec *rec,
+ 					   u8 raw_traffic)
+ {
+ 	if (rec->rec_type == SA_PATH_REC_TYPE_IB)
+ 		rec->ib.raw_traffic = raw_traffic;
+ 	else if (rec->rec_type == SA_PATH_REC_TYPE_OPA)
+ 		rec->opa.raw_traffic = raw_traffic;
+ }
+ 
+ static inline __be64 sa_path_get_service_id(struct sa_path_rec *rec)
+ {
+ 	if (rec->rec_type == SA_PATH_REC_TYPE_IB)
+ 		return rec->ib.service_id;
+ 	else if (rec->rec_type == SA_PATH_REC_TYPE_OPA)
+ 		return rec->opa.service_id;
+ 	return 0;
+ }
+ 
+ static inline __be32 sa_path_get_slid(struct sa_path_rec *rec)
+ {
+ 	if (rec->rec_type == SA_PATH_REC_TYPE_IB)
+ 		return htonl(ntohs(rec->ib.slid));
+ 	else if (rec->rec_type == SA_PATH_REC_TYPE_OPA)
+ 		return rec->opa.slid;
+ 	return 0;
+ }
+ 
+ static inline __be32 sa_path_get_dlid(struct sa_path_rec *rec)
+ {
+ 	if (rec->rec_type == SA_PATH_REC_TYPE_IB)
+ 		return htonl(ntohs(rec->ib.dlid));
+ 	else if (rec->rec_type == SA_PATH_REC_TYPE_OPA)
+ 		return rec->opa.dlid;
+ 	return 0;
+ }
+ 
+ static inline u8 sa_path_get_raw_traffic(struct sa_path_rec *rec)
+ {
+ 	if (rec->rec_type == SA_PATH_REC_TYPE_IB)
+ 		return rec->ib.raw_traffic;
+ 	else if (rec->rec_type == SA_PATH_REC_TYPE_OPA)
+ 		return rec->opa.raw_traffic;
+ 	return 0;
+ }
+ 
+ static inline void sa_path_set_dmac(struct sa_path_rec *rec, u8 *dmac)
+ {
+ 	if (sa_path_is_roce(rec))
+ 		memcpy(rec->roce.dmac, dmac, ETH_ALEN);
+ }
+ 
+ static inline void sa_path_set_dmac_zero(struct sa_path_rec *rec)
+ {
+ 	if (sa_path_is_roce(rec))
+ 		eth_zero_addr(rec->roce.dmac);
+ }
+ 
+ static inline void sa_path_set_ifindex(struct sa_path_rec *rec, int ifindex)
+ {
+ 	if (sa_path_is_roce(rec))
+ 		rec->roce.ifindex = ifindex;
+ }
+ 
+ static inline void sa_path_set_ndev(struct sa_path_rec *rec, struct net *net)
+ {
+ 	if (sa_path_is_roce(rec))
+ 		rec->roce.net = net;
+ }
+ 
+ static inline u8 *sa_path_get_dmac(struct sa_path_rec *rec)
+ {
+ 	if (sa_path_is_roce(rec))
+ 		return rec->roce.dmac;
+ 	return NULL;
+ }
+ 
+ static inline int sa_path_get_ifindex(struct sa_path_rec *rec)
+ {
+ 	if (sa_path_is_roce(rec))
+ 		return rec->roce.ifindex;
+ 	return 0;
+ }
+ 
+ static inline struct net *sa_path_get_ndev(struct sa_path_rec *rec)
+ {
+ 	if (sa_path_is_roce(rec))
+ 		return rec->roce.net;
+ 	return NULL;
+ }
+ 
+ static inline struct net_device *ib_get_ndev_from_path(struct sa_path_rec *rec)
+ {
+ 	return sa_path_get_ndev(rec) ?
+ 		dev_get_by_index(sa_path_get_ndev(rec),
+ 				 sa_path_get_ifindex(rec))
+ 		: NULL;
+ }
++>>>>>>> 57520751445b (IB/SA: Add OPA path record type)
  
  #endif /* IB_SA_H */
* Unmerged path drivers/infiniband/core/cm.c
* Unmerged path drivers/infiniband/core/sa_query.c
diff --git a/drivers/infiniband/core/ucma.c b/drivers/infiniband/core/ucma.c
index e12f8faf8c23..5332e11a709b 100644
--- a/drivers/infiniband/core/ucma.c
+++ b/drivers/infiniband/core/ucma.c
@@ -898,11 +898,18 @@ static ssize_t ucma_query_path(struct ucma_context *ctx,
 	for (i = 0, out_len -= sizeof(*resp);
 	     i < resp->num_paths && out_len > sizeof(struct ib_path_rec_data);
 	     i++, out_len -= sizeof(struct ib_path_rec_data)) {
+		struct sa_path_rec *rec = &ctx->cm_id->route.path_rec[i];
 
 		resp->path_data[i].flags = IB_PATH_GMP | IB_PATH_PRIMARY |
 					   IB_PATH_BIDIRECTIONAL;
-		ib_sa_pack_path(&ctx->cm_id->route.path_rec[i],
-				&resp->path_data[i].path_rec);
+		if (rec->rec_type == SA_PATH_REC_TYPE_IB) {
+			ib_sa_pack_path(rec, &resp->path_data[i].path_rec);
+		} else {
+			struct sa_path_rec ib;
+
+			sa_convert_path_opa_to_ib(&ib, rec);
+			ib_sa_pack_path(&ib, &resp->path_data[i].path_rec);
+		}
 	}
 
 	if (copy_to_user(response, resp,
@@ -1215,8 +1222,17 @@ static int ucma_set_ib_path(struct ucma_context *ctx,
 
 	memset(&sa_path, 0, sizeof(sa_path));
 
+	sa_path.rec_type = SA_PATH_REC_TYPE_IB;
 	ib_sa_unpack_path(path_data->path_rec, &sa_path);
-	ret = rdma_set_ib_paths(ctx->cm_id, &sa_path, 1);
+
+	if (rdma_cap_opa_ah(ctx->cm_id->device, ctx->cm_id->port_num)) {
+		struct sa_path_rec opa;
+
+		sa_convert_path_ib_to_opa(&opa, &sa_path);
+		ret = rdma_set_ib_paths(ctx->cm_id, &opa, 1);
+	} else {
+		ret = rdma_set_ib_paths(ctx->cm_id, &sa_path, 1);
+	}
 	if (ret)
 		return ret;
 
* Unmerged path drivers/infiniband/core/uverbs_marshall.c
* Unmerged path drivers/infiniband/ulp/ipoib/ipoib_fs.c
* Unmerged path drivers/infiniband/ulp/ipoib/ipoib_main.c
* Unmerged path drivers/infiniband/ulp/srp/ib_srp.c
* Unmerged path include/rdma/ib_sa.h
