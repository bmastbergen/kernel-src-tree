scsi: lpfc: avoid false-positive gcc-8 warning

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] lpfc: avoid false-positive gcc-8 warning (Dick Kennedy) [1385844 1461977 1387768]
Rebuild_FUZZ: 93.02%
commit-author Arnd Bergmann <arnd@arndb.de>
commit 5fe5a6c9acc03bcd98e0d1611b6a0fe17149c6cc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5fe5a6c9.failed

This is an interesting regression with gcc-8, showing a harmless warning
for correct code:

In file included from include/linux/kernel.h:13:0,
                 ...
                 from drivers/scsi/lpfc/lpfc_debugfs.c:23:
include/linux/printk.h:301:2: error: 'eq' may be used uninitialized in this function [-Werror=maybe-uninitialized]
  printk(KERN_ERR pr_fmt(fmt), ##__VA_ARGS__)
  ^~~~~~
In file included from drivers/scsi/lpfc/lpfc_debugfs.c:58:0:
drivers/scsi/lpfc/lpfc_debugfs.h:451:31: note: 'eq' was declared here

I managed to reduce the warning into a small test case for gcc-8 that I
reported in the gcc bugzilla[1].

As a workaround, this changes the logic to move the two assignments of
'eq' out of the conditions and instead make the index conditional.  This
works for all configurations I tried and avoids adding a bogus
initialization.

	Acked-by: James Smart <james.smart@broadcom.com>
Link: [1] https://gcc.gnu.org/bugzilla/show_bug.cgi?id=81958
	Signed-off-by: Arnd Bergmann <arnd@arndb.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 5fe5a6c9acc03bcd98e0d1611b6a0fe17149c6cc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_debugfs.h
diff --cc drivers/scsi/lpfc/lpfc_debugfs.h
index 8b2b6a3bfc25,c4edd87bfc65..000000000000
--- a/drivers/scsi/lpfc/lpfc_debugfs.h
+++ b/drivers/scsi/lpfc/lpfc_debugfs.h
@@@ -378,38 -437,69 +378,64 @@@ lpfc_debug_dump_fcp_wq(struct lpfc_hba 
  }
  
  /**
 - * lpfc_debug_dump_cq - dump all entries from a fcp or nvme work queue's
 - * cmpl queue
 + * lpfc_debug_dump_fcp_cq - dump all entries from a fcp work queue's cmpl queue
   * @phba: Pointer to HBA context object.
 - * @wqidx: Index to a FCP work queue.
 + * @fcp_wqidx: Index to a FCP work queue.
   *
 - * This function dumps all entries from a FCP or NVME completion queue
 - * which is associated to the work queue specified by the @wqidx.
 + * This function dumps all entries from a FCP complete queue which is
 + * associated to the FCP work queue specified by the @fcp_wqidx.
   **/
  static inline void
 -lpfc_debug_dump_cq(struct lpfc_hba *phba, int qtype, int wqidx)
 +lpfc_debug_dump_fcp_cq(struct lpfc_hba *phba, int fcp_wqidx)
  {
 -	struct lpfc_queue *wq, *cq, *eq;
 -	char *qtypestr;
 -	int eqidx;
 -
 -	/* fcp/nvme wq and cq are 1:1, thus same indexes */
 -
 -	if (qtype == DUMP_FCP) {
 -		wq = phba->sli4_hba.fcp_wq[wqidx];
 -		cq = phba->sli4_hba.fcp_cq[wqidx];
 -		qtypestr = "FCP";
 -	} else if (qtype == DUMP_NVME) {
 -		wq = phba->sli4_hba.nvme_wq[wqidx];
 -		cq = phba->sli4_hba.nvme_cq[wqidx];
 -		qtypestr = "NVME";
 -	} else if (qtype == DUMP_MBX) {
 -		wq = phba->sli4_hba.mbx_wq;
 -		cq = phba->sli4_hba.mbx_cq;
 -		qtypestr = "MBX";
 -	} else if (qtype == DUMP_ELS) {
 -		wq = phba->sli4_hba.els_wq;
 -		cq = phba->sli4_hba.els_cq;
 -		qtypestr = "ELS";
 -	} else if (qtype == DUMP_NVMELS) {
 -		wq = phba->sli4_hba.nvmels_wq;
 -		cq = phba->sli4_hba.nvmels_cq;
 -		qtypestr = "NVMELS";
 -	} else
 +	int fcp_cqidx, fcp_cqid;
 +
 +	/* sanity check */
 +	if (fcp_wqidx >= phba->cfg_fcp_io_channel)
  		return;
  
++<<<<<<< HEAD
 +	fcp_cqid = phba->sli4_hba.fcp_wq[fcp_wqidx]->assoc_qid;
 +	for (fcp_cqidx = 0; fcp_cqidx < phba->cfg_fcp_io_channel; fcp_cqidx++)
 +		if (phba->sli4_hba.fcp_cq[fcp_cqidx]->queue_id == fcp_cqid)
 +			break;
 +	if (phba->intr_type == MSIX) {
 +		if (fcp_cqidx >= phba->cfg_fcp_io_channel)
 +			return;
 +	} else {
 +		if (fcp_cqidx > 0)
 +			return;
 +	}
 +
 +	printk(KERN_ERR "FCP CQ: WQ[Idx:%d|Qid%d]->CQ[Idx%d|Qid%d]:\n",
 +		fcp_wqidx, phba->sli4_hba.fcp_wq[fcp_wqidx]->queue_id,
 +		fcp_cqidx, fcp_cqid);
 +	lpfc_debug_dump_q(phba->sli4_hba.fcp_cq[fcp_cqidx]);
++=======
+ 	for (eqidx = 0; eqidx < phba->io_channel_irqs; eqidx++) {
+ 		if (cq->assoc_qid == phba->sli4_hba.hba_eq[eqidx]->queue_id)
+ 			break;
+ 	}
+ 	if (eqidx == phba->io_channel_irqs) {
+ 		pr_err("Couldn't find EQ for CQ. Using EQ[0]\n");
+ 		eqidx = 0;
+ 	}
+ 
+ 	eq = phba->sli4_hba.hba_eq[eqidx];
+ 
+ 	if (qtype == DUMP_FCP || qtype == DUMP_NVME)
+ 		pr_err("%s CQ: WQ[Idx:%d|Qid%d]->CQ[Idx%d|Qid%d]"
+ 			"->EQ[Idx:%d|Qid:%d]:\n",
+ 			qtypestr, wqidx, wq->queue_id, wqidx, cq->queue_id,
+ 			eqidx, eq->queue_id);
+ 	else
+ 		pr_err("%s CQ: WQ[Qid:%d]->CQ[Qid:%d]"
+ 			"->EQ[Idx:%d|Qid:%d]:\n",
+ 			qtypestr, wq->queue_id, cq->queue_id,
+ 			eqidx, eq->queue_id);
+ 
+ 	lpfc_debug_dump_q(cq);
++>>>>>>> 5fe5a6c9acc0 (scsi: lpfc: avoid false-positive gcc-8 warning)
  }
  
  /**
* Unmerged path drivers/scsi/lpfc/lpfc_debugfs.h
