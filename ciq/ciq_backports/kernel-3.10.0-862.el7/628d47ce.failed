thp: skip file huge pmd on copy_huge_pmd()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
commit 628d47ce98d50860d4fc1eef250126dd50622a89
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/628d47ce.failed

copy_page_range() has a check for "Don't copy ptes where a page fault
will fill them correctly." It works on VMA level.  We still copy all
page table entries from private mappings, even if they map page cache.

We can simplify copy_huge_pmd() a bit by skipping file PMDs.

We don't map file private pages with PMDs, so they only can map page
cache.  It's safe to skip them as they can be re-faulted later.

Link: http://lkml.kernel.org/r/1466021202-61880-17-git-send-email-kirill.shutemov@linux.intel.com
	Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 628d47ce98d50860d4fc1eef250126dd50622a89)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/huge_memory.c
diff --cc mm/huge_memory.c
index 329799c812d7,c11cfce4d9d9..000000000000
--- a/mm/huge_memory.c
+++ b/mm/huge_memory.c
@@@ -905,10 -1097,13 +905,20 @@@ int copy_huge_pmd(struct mm_struct *dst
  	spinlock_t *dst_ptl, *src_ptl;
  	struct page *src_page;
  	pmd_t pmd;
++<<<<<<< HEAD
 +	pgtable_t pgtable;
 +	int ret;
 +
 +	ret = -ENOMEM;
++=======
+ 	pgtable_t pgtable = NULL;
+ 	int ret = -ENOMEM;
+ 
+ 	/* Skip if can be re-fill on fault */
+ 	if (!vma_is_anonymous(vma))
+ 		return 0;
+ 
++>>>>>>> 628d47ce98d5 (thp: skip file huge pmd on copy_huge_pmd())
  	pgtable = pte_alloc_one(dst_mm, addr);
  	if (unlikely(!pgtable))
  		goto out;
@@@ -942,20 -1137,13 +952,30 @@@
  		goto out_unlock;
  	}
  
++<<<<<<< HEAD
 +	if (unlikely(pmd_trans_splitting(pmd))) {
 +		/* split huge page running from under us */
 +		spin_unlock(src_ptl);
 +		spin_unlock(dst_ptl);
 +		pte_free(dst_mm, pgtable);
 +
 +		wait_split_huge_page(vma->anon_vma, src_pmd); /* src_vma */
 +		goto out;
 +	}
 +	src_page = pmd_page(pmd);
 +	VM_BUG_ON_PAGE(!PageHead(src_page), src_page);
 +	get_page(src_page);
 +	page_dup_rmap(src_page);
 +	add_mm_counter(dst_mm, MM_ANONPAGES, HPAGE_PMD_NR);
++=======
+ 	src_page = pmd_page(pmd);
+ 	VM_BUG_ON_PAGE(!PageHead(src_page), src_page);
+ 	get_page(src_page);
+ 	page_dup_rmap(src_page, true);
+ 	add_mm_counter(dst_mm, MM_ANONPAGES, HPAGE_PMD_NR);
+ 	atomic_long_inc(&dst_mm->nr_ptes);
+ 	pgtable_trans_huge_deposit(dst_mm, dst_pmd, pgtable);
++>>>>>>> 628d47ce98d5 (thp: skip file huge pmd on copy_huge_pmd())
  
  	pmdp_set_wrprotect(src_mm, addr, src_pmd);
  	pmd = pmd_mkold(pmd_wrprotect(pmd));
* Unmerged path mm/huge_memory.c
