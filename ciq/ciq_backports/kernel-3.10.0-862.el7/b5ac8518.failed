net_sched: allow flushing tc police actions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Roman Mashak <mrv@mojatatu.com>
commit b5ac851885accffe0485aea2805df8f2d49c95a8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b5ac8518.failed

The act_police uses its own code to walk the
action hashtable, which leads to that we could
not flush standalone tc police actions, so just
switch to tcf_generic_walker() like other actions.

(Joint work from Roman and Cong.)

	Signed-off-by: Roman Mashak <mrv@mojatatu.com>
	Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
	Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b5ac851885accffe0485aea2805df8f2d49c95a8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/act_police.c
diff --cc net/sched/act_police.c
index 8a7c279e7b2c,8a3be1d99775..000000000000
--- a/net/sched/act_police.c
+++ b/net/sched/act_police.c
@@@ -55,53 -55,16 +55,59 @@@ struct tc_police_compat 
  
  /* Each policer is serialized by its individual spinlock */
  
 -static int police_net_id;
 -static struct tc_action_ops act_police_ops;
 -
 -static int tcf_act_police_walker(struct net *net, struct sk_buff *skb,
 -				 struct netlink_callback *cb, int type,
 -				 const struct tc_action_ops *ops)
 +static int tcf_act_police_walker(struct sk_buff *skb, struct netlink_callback *cb,
 +			      int type, struct tc_action *a)
  {
++<<<<<<< HEAD
 +	struct tcf_hashinfo *hinfo = a->ops->hinfo;
 +	struct hlist_head *head;
 +	struct tcf_common *p;
 +	int err = 0, index = -1, i = 0, s_i = 0, n_i = 0;
 +	struct nlattr *nest;
 +
 +	spin_lock_bh(&hinfo->lock);
 +
 +	s_i = cb->args[0];
 +
 +	for (i = 0; i < (POL_TAB_MASK + 1); i++) {
 +		head = &hinfo->htab[tcf_hash(i, POL_TAB_MASK)];
 +
 +		hlist_for_each_entry_rcu(p, head, tcfc_head) {
 +			index++;
 +			if (index < s_i)
 +				continue;
 +			a->priv = p;
 +			a->order = index;
 +			nest = nla_nest_start(skb, a->order);
 +			if (nest == NULL)
 +				goto nla_put_failure;
 +			if (type == RTM_DELACTION)
 +				err = tcf_action_dump_1(skb, a, 0, 1);
 +			else
 +				err = tcf_action_dump_1(skb, a, 0, 0);
 +			if (err < 0) {
 +				index--;
 +				nla_nest_cancel(skb, nest);
 +				goto done;
 +			}
 +			nla_nest_end(skb, nest);
 +			n_i++;
 +		}
 +	}
 +done:
 +	spin_unlock_bh(&hinfo->lock);
 +	if (n_i)
 +		cb->args[0] += n_i;
 +	return n_i;
 +
 +nla_put_failure:
 +	nla_nest_cancel(skb, nest);
 +	goto done;
++=======
+ 	struct tc_action_net *tn = net_generic(net, police_net_id);
+ 
+ 	return tcf_generic_walker(tn, skb, cb, type, ops);
++>>>>>>> b5ac851885ac (net_sched: allow flushing tc police actions)
  }
  
  static const struct nla_policy police_policy[TCA_POLICE_MAX + 1] = {
* Unmerged path net/sched/act_police.c
