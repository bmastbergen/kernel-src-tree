bnxt_en: add support for port_attr_get and and get_phys_port_name

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Sathya Perla <sathya.perla@broadcom.com>
commit c124a62ff2dde9eaa9e8083de8206a142535c04e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c124a62f.failed

This patch adds support for the switchdev_port_attr_get() and
ndo_get_phys_port_name() methods for the PF and the VF-reps.
Using this support a user application can deduce that the PF
(when in the ESWITCH_SWDEV mode) and it's VF-reps form a switch.

	Signed-off-by: Sathya Perla <sathya.perla@broadcom.com>
	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c124a62ff2dde9eaa9e8083de8206a142535c04e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
#	drivers/net/ethernet/broadcom/bnxt/bnxt.h
#	drivers/net/ethernet/broadcom/bnxt/bnxt_vfr.c
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.c
index 3556457e8605,82cbe1804821..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@@ -7170,8 -7501,107 +7170,111 @@@ static void bnxt_udp_tunnel_del(struct 
  	schedule_work(&bp->sp_task);
  }
  
++<<<<<<< HEAD
++=======
+ static int bnxt_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq,
+ 			       struct net_device *dev, u32 filter_mask,
+ 			       int nlflags)
+ {
+ 	struct bnxt *bp = netdev_priv(dev);
+ 
+ 	return ndo_dflt_bridge_getlink(skb, pid, seq, dev, bp->br_mode, 0, 0,
+ 				       nlflags, filter_mask, NULL);
+ }
+ 
+ static int bnxt_bridge_setlink(struct net_device *dev, struct nlmsghdr *nlh,
+ 			       u16 flags)
+ {
+ 	struct bnxt *bp = netdev_priv(dev);
+ 	struct nlattr *attr, *br_spec;
+ 	int rem, rc = 0;
+ 
+ 	if (bp->hwrm_spec_code < 0x10708 || !BNXT_SINGLE_PF(bp))
+ 		return -EOPNOTSUPP;
+ 
+ 	br_spec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);
+ 	if (!br_spec)
+ 		return -EINVAL;
+ 
+ 	nla_for_each_nested(attr, br_spec, rem) {
+ 		u16 mode;
+ 
+ 		if (nla_type(attr) != IFLA_BRIDGE_MODE)
+ 			continue;
+ 
+ 		if (nla_len(attr) < sizeof(mode))
+ 			return -EINVAL;
+ 
+ 		mode = nla_get_u16(attr);
+ 		if (mode == bp->br_mode)
+ 			break;
+ 
+ 		rc = bnxt_hwrm_set_br_mode(bp, mode);
+ 		if (!rc)
+ 			bp->br_mode = mode;
+ 		break;
+ 	}
+ 	return rc;
+ }
+ 
+ static int bnxt_get_phys_port_name(struct net_device *dev, char *buf,
+ 				   size_t len)
+ {
+ 	struct bnxt *bp = netdev_priv(dev);
+ 	int rc;
+ 
+ 	/* The PF and it's VF-reps only support the switchdev framework */
+ 	if (!BNXT_PF(bp))
+ 		return -EOPNOTSUPP;
+ 
+ 	/* The switch-id that the pf belongs to is exported by
+ 	 * the switchdev ndo. This name is just to distinguish from the
+ 	 * vf-rep ports.
+ 	 */
+ 	rc = snprintf(buf, len, "pf%d", bp->pf.port_id);
+ 
+ 	if (rc >= len)
+ 		return -EOPNOTSUPP;
+ 	return 0;
+ }
+ 
+ int bnxt_port_attr_get(struct bnxt *bp, struct switchdev_attr *attr)
+ {
+ 	if (bp->eswitch_mode != DEVLINK_ESWITCH_MODE_SWITCHDEV)
+ 		return -EOPNOTSUPP;
+ 
+ 	/* The PF and it's VF-reps only support the switchdev framework */
+ 	if (!BNXT_PF(bp))
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (attr->id) {
+ 	case SWITCHDEV_ATTR_ID_PORT_PARENT_ID:
+ 		/* In SRIOV each PF-pool (PF + child VFs) serves as a
+ 		 * switching domain, the PF's perm mac-addr can be used
+ 		 * as the unique parent-id
+ 		 */
+ 		attr->u.ppid.id_len = ETH_ALEN;
+ 		ether_addr_copy(attr->u.ppid.id, bp->pf.mac_addr);
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 	return 0;
+ }
+ 
+ static int bnxt_swdev_port_attr_get(struct net_device *dev,
+ 				    struct switchdev_attr *attr)
+ {
+ 	return bnxt_port_attr_get(netdev_priv(dev), attr);
+ }
+ 
+ static const struct switchdev_ops bnxt_switchdev_ops = {
+ 	.switchdev_port_attr_get	= bnxt_swdev_port_attr_get
+ };
+ 
++>>>>>>> c124a62ff2dd (bnxt_en: add support for port_attr_get and and get_phys_port_name)
  static const struct net_device_ops bnxt_netdev_ops = {
 +	.ndo_size		= sizeof(struct net_device_ops),
  	.ndo_open		= bnxt_open,
  	.ndo_start_xmit		= bnxt_start_xmit,
  	.ndo_stop		= bnxt_close,
@@@ -7199,8 -7629,12 +7302,17 @@@
  #ifdef CONFIG_RFS_ACCEL
  	.ndo_rx_flow_steer	= bnxt_rx_flow_steer,
  #endif
++<<<<<<< HEAD
 +	.extended.ndo_udp_tunnel_add	= bnxt_udp_tunnel_add,
 +	.extended.ndo_udp_tunnel_del	= bnxt_udp_tunnel_del,
++=======
+ 	.ndo_udp_tunnel_add	= bnxt_udp_tunnel_add,
+ 	.ndo_udp_tunnel_del	= bnxt_udp_tunnel_del,
+ 	.ndo_xdp		= bnxt_xdp,
+ 	.ndo_bridge_getlink	= bnxt_bridge_getlink,
+ 	.ndo_bridge_setlink	= bnxt_bridge_setlink,
+ 	.ndo_get_phys_port_name = bnxt_get_phys_port_name
++>>>>>>> c124a62ff2dd (bnxt_en: add support for port_attr_get and and get_phys_port_name)
  };
  
  static void bnxt_remove_one(struct pci_dev *pdev)
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.h
index 93218af865c8,2d84d5719b70..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.h
@@@ -18,6 -18,11 +18,14 @@@
  #define DRV_VER_MIN	8
  #define DRV_VER_UPD	0
  
++<<<<<<< HEAD
++=======
+ #include <linux/interrupt.h>
+ #include <net/devlink.h>
+ #include <net/dst_metadata.h>
+ #include <net/switchdev.h>
+ 
++>>>>>>> c124a62ff2dd (bnxt_en: add support for port_attr_get and and get_phys_port_name)
  struct tx_bd {
  	__le32 tx_bd_len_flags_type;
  	#define TX_BD_TYPE					(0x3f << 0)
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_vfr.c
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.h
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_vfr.c
