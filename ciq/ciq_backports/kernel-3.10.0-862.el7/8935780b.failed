IB/hfi1: Initialize bth1 in 16B rc ack builder

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Dennis Dalessandro <dennis.dalessandro@intel.com>
commit 8935780b9f7bbad0f2eb5dd43f61ba7b509a1575
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8935780b.failed

It is possible the bth1 variable could be used uninitialized so going
ahead and giving it a default value.

Otherwise we leak stack memory to the network.

Fixes: 5b6cabb0db77 ("IB/hfi1: Add 16B RC/UC support")
	Reviewed-by: Don Hiatt <don.hiatt@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 8935780b9f7bbad0f2eb5dd43f61ba7b509a1575)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/rc.c
diff --cc drivers/infiniband/hw/hfi1/rc.c
index bc6bfb74bac7,af5f7936f7e5..000000000000
--- a/drivers/infiniband/hw/hfi1/rc.c
+++ b/drivers/infiniband/hw/hfi1/rc.c
@@@ -821,6 -757,188 +821,191 @@@ unlock
  	spin_unlock_irqrestore(&qp->s_lock, flags);
  }
  
++<<<<<<< HEAD
++=======
+ static inline void hfi1_make_rc_ack_9B(struct rvt_qp *qp,
+ 				       struct hfi1_opa_header *opa_hdr,
+ 				       u8 sc5, bool is_fecn,
+ 				       u64 *pbc_flags, u32 *hwords,
+ 				       u32 *nwords)
+ {
+ 	struct hfi1_ibport *ibp = to_iport(qp->ibqp.device, qp->port_num);
+ 	struct hfi1_pportdata *ppd = ppd_from_ibp(ibp);
+ 	struct ib_header *hdr = &opa_hdr->ibh;
+ 	struct ib_other_headers *ohdr;
+ 	u16 lrh0 = HFI1_LRH_BTH;
+ 	u16 pkey;
+ 	u32 bth0, bth1;
+ 
+ 	opa_hdr->hdr_type = HFI1_PKT_TYPE_9B;
+ 	ohdr = &hdr->u.oth;
+ 	/* header size in 32-bit words LRH+BTH+AETH = (8+12+4)/4 */
+ 	*hwords = 6;
+ 
+ 	if (unlikely(rdma_ah_get_ah_flags(&qp->remote_ah_attr) & IB_AH_GRH)) {
+ 		*hwords += hfi1_make_grh(ibp, &hdr->u.l.grh,
+ 					 rdma_ah_read_grh(&qp->remote_ah_attr),
+ 					 *hwords - 2, SIZE_OF_CRC);
+ 		ohdr = &hdr->u.l.oth;
+ 		lrh0 = HFI1_LRH_GRH;
+ 	}
+ 	/* set PBC_DC_INFO bit (aka SC[4]) in pbc_flags */
+ 	*pbc_flags |= ((!!(sc5 & 0x10)) << PBC_DC_INFO_SHIFT);
+ 
+ 	/* read pkey_index w/o lock (its atomic) */
+ 	pkey = hfi1_get_pkey(ibp, qp->s_pkey_index);
+ 
+ 	lrh0 |= (sc5 & IB_SC_MASK) << IB_SC_SHIFT |
+ 		(rdma_ah_get_sl(&qp->remote_ah_attr) & IB_SL_MASK) <<
+ 			IB_SL_SHIFT;
+ 
+ 	hfi1_make_ib_hdr(hdr, lrh0, *hwords + SIZE_OF_CRC,
+ 			 opa_get_lid(rdma_ah_get_dlid(&qp->remote_ah_attr), 9B),
+ 			 ppd->lid | rdma_ah_get_path_bits(&qp->remote_ah_attr));
+ 
+ 	bth0 = pkey | (OP(ACKNOWLEDGE) << 24);
+ 	if (qp->s_mig_state == IB_MIG_MIGRATED)
+ 		bth0 |= IB_BTH_MIG_REQ;
+ 	bth1 = (!!is_fecn) << IB_BECN_SHIFT;
+ 	hfi1_make_bth_aeth(qp, ohdr, bth0, bth1);
+ }
+ 
+ static inline void hfi1_make_rc_ack_16B(struct rvt_qp *qp,
+ 					struct hfi1_opa_header *opa_hdr,
+ 					u8 sc5, bool is_fecn,
+ 					u64 *pbc_flags, u32 *hwords,
+ 					u32 *nwords)
+ {
+ 	struct hfi1_ibport *ibp = to_iport(qp->ibqp.device, qp->port_num);
+ 	struct hfi1_pportdata *ppd = ppd_from_ibp(ibp);
+ 	struct hfi1_16b_header *hdr = &opa_hdr->opah;
+ 	struct ib_other_headers *ohdr;
+ 	u32 bth0, bth1 = 0;
+ 	u16 len, pkey;
+ 	u8 becn = !!is_fecn;
+ 	u8 l4 = OPA_16B_L4_IB_LOCAL;
+ 	u8 extra_bytes;
+ 
+ 	opa_hdr->hdr_type = HFI1_PKT_TYPE_16B;
+ 	ohdr = &hdr->u.oth;
+ 	/* header size in 32-bit words 16B LRH+BTH+AETH = (16+12+4)/4 */
+ 	*hwords = 8;
+ 	extra_bytes = hfi1_get_16b_padding(*hwords << 2, 0);
+ 	*nwords = SIZE_OF_CRC + ((extra_bytes + SIZE_OF_LT) >> 2);
+ 
+ 	if (unlikely(rdma_ah_get_ah_flags(&qp->remote_ah_attr) & IB_AH_GRH) &&
+ 	    hfi1_check_mcast(rdma_ah_get_dlid(&qp->remote_ah_attr))) {
+ 		*hwords += hfi1_make_grh(ibp, &hdr->u.l.grh,
+ 					 rdma_ah_read_grh(&qp->remote_ah_attr),
+ 					 *hwords - 4, *nwords);
+ 		ohdr = &hdr->u.l.oth;
+ 		l4 = OPA_16B_L4_IB_GLOBAL;
+ 	}
+ 	*pbc_flags |= PBC_PACKET_BYPASS | PBC_INSERT_BYPASS_ICRC;
+ 
+ 	/* read pkey_index w/o lock (its atomic) */
+ 	pkey = hfi1_get_pkey(ibp, qp->s_pkey_index);
+ 
+ 	/* Convert dwords to flits */
+ 	len = (*hwords + *nwords) >> 1;
+ 
+ 	hfi1_make_16b_hdr(hdr,
+ 			  ppd->lid | rdma_ah_get_path_bits(&qp->remote_ah_attr),
+ 			  opa_get_lid(rdma_ah_get_dlid(&qp->remote_ah_attr),
+ 				      16B),
+ 			  len, pkey, becn, 0, l4, sc5);
+ 
+ 	bth0 = pkey | (OP(ACKNOWLEDGE) << 24);
+ 	bth0 |= extra_bytes << 20;
+ 	if (qp->s_mig_state == IB_MIG_MIGRATED)
+ 		bth1 = OPA_BTH_MIG_REQ;
+ 	hfi1_make_bth_aeth(qp, ohdr, bth0, bth1);
+ }
+ 
+ typedef void (*hfi1_make_rc_ack)(struct rvt_qp *qp,
+ 				 struct hfi1_opa_header *opa_hdr,
+ 				 u8 sc5, bool is_fecn,
+ 				 u64 *pbc_flags, u32 *hwords,
+ 				 u32 *nwords);
+ 
+ /* We support only two types - 9B and 16B for now */
+ static const hfi1_make_rc_ack hfi1_make_rc_ack_tbl[2] = {
+ 	[HFI1_PKT_TYPE_9B] = &hfi1_make_rc_ack_9B,
+ 	[HFI1_PKT_TYPE_16B] = &hfi1_make_rc_ack_16B
+ };
+ 
+ /**
+  * hfi1_send_rc_ack - Construct an ACK packet and send it
+  * @qp: a pointer to the QP
+  *
+  * This is called from hfi1_rc_rcv() and handle_receive_interrupt().
+  * Note that RDMA reads and atomics are handled in the
+  * send side QP state and send engine.
+  */
+ void hfi1_send_rc_ack(struct hfi1_ctxtdata *rcd,
+ 		      struct rvt_qp *qp, bool is_fecn)
+ {
+ 	struct hfi1_ibport *ibp = rcd_to_iport(rcd);
+ 	struct hfi1_qp_priv *priv = qp->priv;
+ 	struct hfi1_pportdata *ppd = ppd_from_ibp(ibp);
+ 	u8 sc5 = ibp->sl_to_sc[rdma_ah_get_sl(&qp->remote_ah_attr)];
+ 	u64 pbc, pbc_flags = 0;
+ 	u32 hwords = 0;
+ 	u32 nwords = 0;
+ 	u32 plen;
+ 	struct pio_buf *pbuf;
+ 	struct hfi1_opa_header opa_hdr;
+ 
+ 	/* clear the defer count */
+ 	qp->r_adefered = 0;
+ 
+ 	/* Don't send ACK or NAK if a RDMA read or atomic is pending. */
+ 	if (qp->s_flags & RVT_S_RESP_PENDING) {
+ 		hfi1_queue_rc_ack(qp, is_fecn);
+ 		return;
+ 	}
+ 
+ 	/* Ensure s_rdma_ack_cnt changes are committed */
+ 	smp_read_barrier_depends();
+ 	if (qp->s_rdma_ack_cnt) {
+ 		hfi1_queue_rc_ack(qp, is_fecn);
+ 		return;
+ 	}
+ 
+ 	/* Don't try to send ACKs if the link isn't ACTIVE */
+ 	if (driver_lstate(ppd) != IB_PORT_ACTIVE)
+ 		return;
+ 
+ 	/* Make the appropriate header */
+ 	hfi1_make_rc_ack_tbl[priv->hdr_type](qp, &opa_hdr, sc5, is_fecn,
+ 					     &pbc_flags, &hwords, &nwords);
+ 
+ 	plen = 2 /* PBC */ + hwords + nwords;
+ 	pbc = create_pbc(ppd, pbc_flags, qp->srate_mbps,
+ 			 sc_to_vlt(ppd->dd, sc5), plen);
+ 	pbuf = sc_buffer_alloc(rcd->sc, plen, NULL, NULL);
+ 	if (!pbuf) {
+ 		/*
+ 		 * We have no room to send at the moment.  Pass
+ 		 * responsibility for sending the ACK to the send engine
+ 		 * so that when enough buffer space becomes available,
+ 		 * the ACK is sent ahead of other outgoing packets.
+ 		 */
+ 		hfi1_queue_rc_ack(qp, is_fecn);
+ 		return;
+ 	}
+ 	trace_ack_output_ibhdr(dd_from_ibdev(qp->ibqp.device),
+ 			       &opa_hdr, ib_is_sc5(sc5));
+ 
+ 	/* write the pbc and data */
+ 	ppd->dd->pio_inline_send(ppd->dd, pbuf, pbc,
+ 				 (priv->hdr_type == HFI1_PKT_TYPE_9B ?
+ 				 (void *)&opa_hdr.ibh :
+ 				 (void *)&opa_hdr.opah), hwords);
+ 	return;
+ }
+ 
++>>>>>>> 8935780b9f7b (IB/hfi1: Initialize bth1 in 16B rc ack builder)
  /**
   * reset_psn - reset the QP state to send starting from PSN
   * @qp: the QP
* Unmerged path drivers/infiniband/hw/hfi1/rc.c
