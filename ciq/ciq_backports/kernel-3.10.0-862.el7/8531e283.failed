PCI: Recognize Thunderbolt devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Lukas Wunner <lukas@wunner.de>
commit 8531e283bee66050734fb0e89d53e85fd5ce24a4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8531e283.failed

Detect on probe whether a PCI device is part of a Thunderbolt controller.
Intel uses a Vendor-Specific Extended Capability (VSEC) with ID 0x1234
on such devices.  Detect presence of this VSEC and cache it in a newly
added is_thunderbolt bit in struct pci_dev.

Also, add a helper to check whether a given PCI device is situated on a
Thunderbolt daisy chain (i.e., below a PCI device with is_thunderbolt
set).

The necessity arises from the following:

* If an external Thunderbolt GPU is connected to a dual GPU laptop,
  that GPU is currently registered with vga_switcheroo even though it
  can neither drive the laptop's panel nor be powered off by the
  platform.  To vga_switcheroo it will appear as if two discrete
  GPUs are present.  As a result, when the external GPU is runtime
  suspended, vga_switcheroo will cut power to the internal discrete GPU
  which may not be runtime suspended at all at this moment.  The
  solution is to not register external GPUs with vga_switcheroo, which
  necessitates a way to recognize if they're on a Thunderbolt daisy
  chain.

* Dual GPU MacBook Pros introduced 2011+ can no longer switch external
  DisplayPort ports between GPUs.  (They're no longer just used for DP
  but have become combined DP/Thunderbolt ports.)  The driver to switch
  the ports, drivers/platform/x86/apple-gmux.c, needs to detect presence
  of a Thunderbolt controller and, if found, keep external ports
  permanently switched to the discrete GPU.

v2: Make kerneldoc for pci_is_thunderbolt_attached() more precise,
    drop portion of commit message pertaining to separate series.
    (Bjorn Helgaas)

	Cc: Andreas Noever <andreas.noever@gmail.com>
	Cc: Michael Jamet <michael.jamet@intel.com>
	Cc: Tomas Winkler <tomas.winkler@intel.com>
	Cc: Amir Levy <amir.jer.levy@intel.com>
	Acked-by: Bjorn Helgaas <bhelgaas@google.com>
	Signed-off-by: Lukas Wunner <lukas@wunner.de>
Link: http://patchwork.freedesktop.org/patch/msgid/0ab165a4a35c0b60f29d4c306c653ead14fcd8f9.1489145162.git.lukas@wunner.de
(cherry picked from commit 8531e283bee66050734fb0e89d53e85fd5ce24a4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/pci.h
diff --cc include/linux/pci.h
index 20e2942c01d7,5948cfdc984e..000000000000
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@@ -2033,4 -2160,30 +2034,33 @@@ static inline bool pci_ari_enabled(stru
  {
  	return bus->self && bus->self->ari_enabled;
  }
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * pci_is_thunderbolt_attached - whether device is on a Thunderbolt daisy chain
+  * @pdev: PCI device to check
+  *
+  * Walk upwards from @pdev and check for each encountered bridge if it's part
+  * of a Thunderbolt controller.  Reaching the host bridge means @pdev is not
+  * Thunderbolt-attached.  (But rather soldered to the mainboard usually.)
+  */
+ static inline bool pci_is_thunderbolt_attached(struct pci_dev *pdev)
+ {
+ 	struct pci_dev *parent = pdev;
+ 
+ 	if (pdev->is_thunderbolt)
+ 		return true;
+ 
+ 	while ((parent = pci_upstream_bridge(parent)))
+ 		if (parent->is_thunderbolt)
+ 			return true;
+ 
+ 	return false;
+ }
+ 
+ /* provide the legacy pci_dma_* API */
+ #include <linux/pci-dma-compat.h>
+ 
++>>>>>>> 8531e283bee6 (PCI: Recognize Thunderbolt devices)
  #endif /* LINUX_PCI_H */
diff --git a/drivers/pci/pci.h b/drivers/pci/pci.h
index 159afd8e23df..f97ee549369d 100644
--- a/drivers/pci/pci.h
+++ b/drivers/pci/pci.h
@@ -6,6 +6,8 @@
 
 #define PCI_FIND_CAP_TTL	48
 
+#define PCI_VSEC_ID_INTEL_TBT	0x1234	/* Thunderbolt */
+
 extern const unsigned char pcie_link_speed[];
 
 bool pcie_cap_has_lnkctl(const struct pci_dev *dev);
diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 6d2c60881fef..ba72539e65ec 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1076,6 +1076,24 @@ void set_pcie_hotplug_bridge(struct pci_dev *pdev)
 		pdev->is_hotplug_bridge = 1;
 }
 
+static void set_pcie_thunderbolt(struct pci_dev *dev)
+{
+	int vsec = 0;
+	u32 header;
+
+	while ((vsec = pci_find_next_ext_capability(dev, vsec,
+						    PCI_EXT_CAP_ID_VNDR))) {
+		pci_read_config_dword(dev, vsec + PCI_VNDR_HEADER, &header);
+
+		/* Is the device part of a Thunderbolt controller? */
+		if (dev->vendor == PCI_VENDOR_ID_INTEL &&
+		    PCI_VNDR_HEADER_ID(header) == PCI_VSEC_ID_INTEL_TBT) {
+			dev->is_thunderbolt = 1;
+			return;
+		}
+	}
+}
+
 /**
  * pci_ext_cfg_is_aliased - is ext config space just an alias of std config?
  * @dev: PCI device
@@ -1228,6 +1246,9 @@ int pci_setup_device(struct pci_dev *dev)
 	/* need to have dev->class ready */
 	dev->cfg_size = pci_cfg_space_size(dev);
 
+	/* need to have dev->cfg_size ready */
+	set_pcie_thunderbolt(dev);
+
 	/* "Unknown power state" */
 	dev->current_state = PCI_UNKNOWN;
 
* Unmerged path include/linux/pci.h
