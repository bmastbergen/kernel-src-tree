nvme: Use CNS as 8-bit field and avoid endianness conversion

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [nvme] Use CNS as 8-bit field and avoid endianness conversion (David Milburn) [1457880 1456486 1454365]
Rebuild_FUZZ: 94.74%
commit-author Parav Pandit <parav@mellanox.com>
commit 986994a27587efd8ce4c595cab89b570f7475359
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/986994a2.failed

This patch defines CNS field as 8-bit field and avoids cpu_to/from_le
conversions.
Also initialize nvme_command cns value explicitly to NVME_ID_CNS_NS
for readability (don't rely on the fact that NVME_ID_CNS_NS = 0).

	Reviewed-by: Max Gurtovoy <maxg@mellanox.com>
	Signed-off-by: Parav Pandit <parav@mellanox.com>
	Reviewed-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 986994a27587efd8ce4c595cab89b570f7475359)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
diff --cc drivers/nvme/host/core.c
index bd223cb63595,8b1be128b66e..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -534,12 -555,13 +534,19 @@@ EXPORT_SYMBOL_GPL(nvme_stop_keep_alive)
  
  int nvme_identify_ctrl(struct nvme_ctrl *dev, struct nvme_id_ctrl **id)
  {
 -	struct nvme_command c = { };
 +	struct nvme_command c = {
 +		.identify.opcode = nvme_admin_identify,
 +		.identify.cns = cpu_to_le32(NVME_ID_CNS_CTRL),
 +	};
  	int error;
  
++<<<<<<< HEAD
++=======
+ 	/* gcc-4.4.4 (at least) has issues with initializers and anon unions */
+ 	c.identify.opcode = nvme_admin_identify;
+ 	c.identify.cns = NVME_ID_CNS_CTRL;
+ 
++>>>>>>> 986994a27587 (nvme: Use CNS as 8-bit field and avoid endianness conversion)
  	*id = kmalloc(sizeof(struct nvme_id_ctrl), GFP_KERNEL);
  	if (!*id)
  		return -ENOMEM;
@@@ -564,12 -586,14 +571,20 @@@ static int nvme_identify_ns_list(struc
  int nvme_identify_ns(struct nvme_ctrl *dev, unsigned nsid,
  		struct nvme_id_ns **id)
  {
 -	struct nvme_command c = { };
 +	struct nvme_command c = {
 +		.identify.opcode = nvme_admin_identify,
 +		.identify.nsid = cpu_to_le32(nsid),
 +	};
  	int error;
  
++<<<<<<< HEAD
++=======
+ 	/* gcc-4.4.4 (at least) has issues with initializers and anon unions */
+ 	c.identify.opcode = nvme_admin_identify;
+ 	c.identify.nsid = cpu_to_le32(nsid);
+ 	c.identify.cns = NVME_ID_CNS_NS;
+ 
++>>>>>>> 986994a27587 (nvme: Use CNS as 8-bit field and avoid endianness conversion)
  	*id = kmalloc(sizeof(struct nvme_id_ns), GFP_KERNEL);
  	if (!*id)
  		return -ENOMEM;
* Unmerged path drivers/nvme/host/core.c
diff --git a/drivers/nvme/target/admin-cmd.c b/drivers/nvme/target/admin-cmd.c
index 32d2bf6aabe3..1f3235dfdcf4 100644
--- a/drivers/nvme/target/admin-cmd.c
+++ b/drivers/nvme/target/admin-cmd.c
@@ -508,7 +508,7 @@ int nvmet_parse_admin_cmd(struct nvmet_req *req)
 		break;
 	case nvme_admin_identify:
 		req->data_len = 4096;
-		switch (le32_to_cpu(cmd->identify.cns)) {
+		switch (cmd->identify.cns) {
 		case NVME_ID_CNS_NS:
 			req->execute = nvmet_execute_identify_ns;
 			return 0;
diff --git a/drivers/nvme/target/discovery.c b/drivers/nvme/target/discovery.c
index 12f39eea569f..af8aabf05335 100644
--- a/drivers/nvme/target/discovery.c
+++ b/drivers/nvme/target/discovery.c
@@ -186,14 +186,14 @@ int nvmet_parse_discovery_cmd(struct nvmet_req *req)
 		}
 	case nvme_admin_identify:
 		req->data_len = 4096;
-		switch (le32_to_cpu(cmd->identify.cns)) {
+		switch (cmd->identify.cns) {
 		case NVME_ID_CNS_CTRL:
 			req->execute =
 				nvmet_execute_identify_disc_ctrl;
 			return 0;
 		default:
 			pr_err("nvmet: unsupported identify cns %d\n",
-				le32_to_cpu(cmd->identify.cns));
+				cmd->identify.cns);
 			return NVME_SC_INVALID_OPCODE | NVME_SC_DNR;
 		}
 	default:
diff --git a/include/linux/nvme.h b/include/linux/nvme.h
index 46a43b805258..83396dcb5186 100644
--- a/include/linux/nvme.h
+++ b/include/linux/nvme.h
@@ -624,7 +624,9 @@ struct nvme_identify {
 	__le32			nsid;
 	__u64			rsvd2[2];
 	union nvme_data_ptr	dptr;
-	__le32			cns;
+	__u8			cns;
+	__u8			rsvd3;
+	__le16			ctrlid;
 	__u32			rsvd11[5];
 };
 
