dm raid: fix deadlock caused by premature md_stop_writes()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Heinz Mauelshagen <heinzm@redhat.com>
commit 1af2048a3e87b4e982c53ad8cfb0c75d1a9c0a73
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1af2048a.failed

md_stop_writes() is called in raid_presuspend() causing deadlocks on
bios submitted afterwards -- which happens on loaded raid sets with
conversion requests.

Fix by moving md_stop_writes() to raid_postsuspend().  NOTE: when the
recovery's frozen (MD_RECOVERY_FROZEN), writes haven't been started (or
are already stopped) so don't stop them again.

Also remove superfluous readonly setting.

	Signed-off-by: Heinz Mauelshagen <heinzm@redhat.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 1af2048a3e87b4e982c53ad8cfb0c75d1a9c0a73)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-raid.c
diff --cc drivers/md/dm-raid.c
index 0f9829c0b282,398314b6c31a..000000000000
--- a/drivers/md/dm-raid.c
+++ b/drivers/md/dm-raid.c
@@@ -3549,10 -3617,15 +3542,22 @@@ static void raid_postsuspend(struct dm_
  {
  	struct raid_set *rs = ti->private;
  
++<<<<<<< HEAD
 +	if (!test_and_set_bit(RT_FLAG_RS_SUSPENDED, &rs->runtime_flags))
 +		mddev_suspend(&rs->md);
 +
 +	rs->md.ro = 1;
++=======
+ 	if (!test_and_set_bit(RT_FLAG_RS_SUSPENDED, &rs->runtime_flags)) {
+ 		/* Writes have to be stopped before suspending to avoid deadlocks. */
+ 		if (!test_bit(MD_RECOVERY_FROZEN, &rs->md.recovery))
+ 			md_stop_writes(&rs->md);
+ 
+ 		mddev_lock_nointr(&rs->md);
+ 		mddev_suspend(&rs->md);
+ 		mddev_unlock(&rs->md);
+ 	}
++>>>>>>> 1af2048a3e87 (dm raid: fix deadlock caused by premature md_stop_writes())
  }
  
  static void attempt_restore_of_faulty_devices(struct raid_set *rs)
* Unmerged path drivers/md/dm-raid.c
