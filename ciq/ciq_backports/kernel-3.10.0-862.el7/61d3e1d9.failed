ibmvnic: Remove netdev notify for failover resets

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Nathan Fontenot <nfont@linux.vnet.ibm.com>
commit 61d3e1d9bc2a1910d773cbf4ed6f587a7a6166b5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/61d3e1d9.failed

When handling a driver reset due to a failover of the backing
server on the vios, doing the netdev_notify_peers() can cause
network traffic to stall or halt. Remove the netdev notify call
for failover resets.

	Signed-off-by: Nathan Fontenot <nfont@linux.vnet.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 61d3e1d9bc2a1910d773cbf4ed6f587a7a6166b5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/ibm/ibmvnic.c
diff --cc drivers/net/ethernet/ibm/ibmvnic.c
index e51abefcc89d,59ea7a5ae776..000000000000
--- a/drivers/net/ethernet/ibm/ibmvnic.c
+++ b/drivers/net/ethernet/ibm/ibmvnic.c
@@@ -971,14 -1291,82 +971,80 @@@ static int ibmvnic_set_mac(struct net_d
  	return 0;
  }
  
 -/**
 - * do_reset returns zero if we are able to keep processing reset events, or
 - * non-zero if we hit a fatal error and must halt.
 - */
 -static int do_reset(struct ibmvnic_adapter *adapter,
 -		    struct ibmvnic_rwi *rwi, u32 reset_state)
 +static int ibmvnic_change_mtu(struct net_device *netdev, int new_mtu)
  {
 -	struct net_device *netdev = adapter->netdev;
 -	int i, rc;
 +	struct ibmvnic_adapter *adapter = netdev_priv(netdev);
  
 -	netif_carrier_off(netdev);
 -	adapter->reset_reason = rwi->reset_reason;
 +	if (new_mtu > adapter->req_mtu || new_mtu < adapter->min_mtu)
 +		return -EINVAL;
  
++<<<<<<< HEAD
 +	netdev->mtu = new_mtu;
++=======
+ 	if (rwi->reset_reason == VNIC_RESET_MOBILITY) {
+ 		rc = ibmvnic_reenable_crq_queue(adapter);
+ 		if (rc)
+ 			return 0;
+ 	}
+ 
+ 	rc = __ibmvnic_close(netdev);
+ 	if (rc)
+ 		return rc;
+ 
+ 	if (adapter->reset_reason != VNIC_RESET_NON_FATAL) {
+ 		/* remove the closed state so when we call open it appears
+ 		 * we are coming from the probed state.
+ 		 */
+ 		adapter->state = VNIC_PROBED;
+ 
+ 		rc = ibmvnic_init(adapter);
+ 		if (rc)
+ 			return 0;
+ 
+ 		/* If the adapter was in PROBE state prior to the reset,
+ 		 * exit here.
+ 		 */
+ 		if (reset_state == VNIC_PROBED)
+ 			return 0;
+ 
+ 		rc = ibmvnic_login(netdev);
+ 		if (rc) {
+ 			adapter->state = VNIC_PROBED;
+ 			return 0;
+ 		}
+ 
+ 		rc = reset_tx_pools(adapter);
+ 		if (rc)
+ 			return rc;
+ 
+ 		rc = reset_rx_pools(adapter);
+ 		if (rc)
+ 			return rc;
+ 
+ 		if (reset_state == VNIC_CLOSED)
+ 			return 0;
+ 	}
+ 
+ 	rc = __ibmvnic_open(netdev);
+ 	if (rc) {
+ 		if (list_empty(&adapter->rwi_list))
+ 			adapter->state = VNIC_CLOSED;
+ 		else
+ 			adapter->state = reset_state;
+ 
+ 		return 0;
+ 	}
+ 
+ 	netif_carrier_on(netdev);
+ 
+ 	/* kick napi */
+ 	for (i = 0; i < adapter->req_rx_queues; i++)
+ 		napi_schedule(&adapter->napi[i]);
+ 
+ 	if (adapter->reset_reason != VNIC_RESET_FAILOVER)
+ 		netdev_notify_peers(netdev);
+ 
++>>>>>>> 61d3e1d9bc2a (ibmvnic: Remove netdev notify for failover resets)
  	return 0;
  }
  
* Unmerged path drivers/net/ethernet/ibm/ibmvnic.c
