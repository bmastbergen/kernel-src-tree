vxlan: fix the issue that neigh proxy blocks all icmpv6 packets

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Xin Long <lucien.xin@gmail.com>
commit 8bff3685a4bbf175a96bc6a528f13455d8d38244
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8bff3685.failed

Commit f1fb08f6337c ("vxlan: fix ND proxy when skb doesn't have transport
header offset") removed icmp6_code and icmp6_type check before calling
neigh_reduce when doing neigh proxy.

It means all icmpv6 packets would be blocked by this, not only ns packet.
In Jianlin's env, even ping6 couldn't work through it.

This patch is to bring the icmp6_code and icmp6_type check back and also
removed the same check from neigh_reduce().

Fixes: f1fb08f6337c ("vxlan: fix ND proxy when skb doesn't have transport header offset")
	Reported-by: Jianlin Shi <jishi@redhat.com>
	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Reviewed-by: Vincent Bernat <vincent@bernat.im>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8bff3685a4bbf175a96bc6a528f13455d8d38244)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index 946830c7f53c,c437707a8549..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1543,14 -1620,14 +1543,14 @@@ static struct sk_buff *vxlan_na_create(
  	return reply;
  }
  
 -static int neigh_reduce(struct net_device *dev, struct sk_buff *skb, __be32 vni)
 +static int neigh_reduce(struct net_device *dev, struct sk_buff *skb)
  {
  	struct vxlan_dev *vxlan = netdev_priv(dev);
- 	struct nd_msg *msg;
- 	const struct ipv6hdr *iphdr;
  	const struct in6_addr *daddr;
- 	struct neighbour *n;
+ 	const struct ipv6hdr *iphdr;
  	struct inet6_dev *in6_dev;
+ 	struct neighbour *n;
+ 	struct nd_msg *msg;
  
  	in6_dev = __in6_dev_get(dev);
  	if (!in6_dev)
@@@ -1558,11 -1635,7 +1558,15 @@@
  
  	iphdr = ipv6_hdr(skb);
  	daddr = &iphdr->daddr;
++<<<<<<< HEAD
 +
 +	msg = (struct nd_msg *)skb_transport_header(skb);
 +	if (msg->icmph.icmp6_code != 0 ||
 +	    msg->icmph.icmp6_type != NDISC_NEIGHBOUR_SOLICITATION)
 +		goto out;
++=======
+ 	msg = (struct nd_msg *)(iphdr + 1);
++>>>>>>> 8bff3685a4bb (vxlan: fix the issue that neigh proxy blocks all icmpv6 packets)
  
  	if (ipv6_addr_loopback(daddr) ||
  	    ipv6_addr_is_multicast(&msg->target))
@@@ -2115,39 -2233,44 +2119,54 @@@ tx_free
  static netdev_tx_t vxlan_xmit(struct sk_buff *skb, struct net_device *dev)
  {
  	struct vxlan_dev *vxlan = netdev_priv(dev);
+ 	struct vxlan_rdst *rdst, *fdst = NULL;
  	const struct ip_tunnel_info *info;
- 	struct ethhdr *eth;
  	bool did_rsc = false;
- 	struct vxlan_rdst *rdst, *fdst = NULL;
  	struct vxlan_fdb *f;
++<<<<<<< HEAD
++=======
+ 	struct ethhdr *eth;
+ 	__be32 vni = 0;
++>>>>>>> 8bff3685a4bb (vxlan: fix the issue that neigh proxy blocks all icmpv6 packets)
  
  	info = skb_tunnel_info(skb);
  
  	skb_reset_mac_header(skb);
  
 -	if (vxlan->cfg.flags & VXLAN_F_COLLECT_METADATA) {
 -		if (info && info->mode & IP_TUNNEL_INFO_BRIDGE &&
 -		    info->mode & IP_TUNNEL_INFO_TX) {
 -			vni = tunnel_id_to_key32(info->key.tun_id);
 -		} else {
 -			if (info && info->mode & IP_TUNNEL_INFO_TX)
 -				vxlan_xmit_one(skb, dev, vni, NULL, false);
 -			else
 -				kfree_skb(skb);
 -			return NETDEV_TX_OK;
 -		}
 +	if (vxlan->flags & VXLAN_F_COLLECT_METADATA) {
 +		if (info && info->mode & IP_TUNNEL_INFO_TX)
 +			vxlan_xmit_one(skb, dev, NULL, false);
 +		else
 +			kfree_skb(skb);
 +		return NETDEV_TX_OK;
  	}
  
 -	if (vxlan->cfg.flags & VXLAN_F_PROXY) {
 +	if (vxlan->flags & VXLAN_F_PROXY) {
  		eth = eth_hdr(skb);
  		if (ntohs(eth->h_proto) == ETH_P_ARP)
 -			return arp_reduce(dev, skb, vni);
 +			return arp_reduce(dev, skb);
  #if IS_ENABLED(CONFIG_IPV6)
  		else if (ntohs(eth->h_proto) == ETH_P_IPV6 &&
++<<<<<<< HEAD
 +			 pskb_may_pull(skb, sizeof(struct ipv6hdr)
 +				       + sizeof(struct nd_msg)) &&
 +			 ipv6_hdr(skb)->nexthdr == IPPROTO_ICMPV6) {
 +				struct nd_msg *msg;
 +
 +				msg = (struct nd_msg *)skb_transport_header(skb);
 +				if (msg->icmph.icmp6_code == 0 &&
 +				    msg->icmph.icmp6_type == NDISC_NEIGHBOUR_SOLICITATION)
 +					return neigh_reduce(dev, skb);
++=======
+ 			 pskb_may_pull(skb, sizeof(struct ipv6hdr) +
+ 					    sizeof(struct nd_msg)) &&
+ 			 ipv6_hdr(skb)->nexthdr == IPPROTO_ICMPV6) {
+ 			struct nd_msg *m = (struct nd_msg *)(ipv6_hdr(skb) + 1);
+ 
+ 			if (m->icmph.icmp6_code == 0 &&
+ 			    m->icmph.icmp6_type == NDISC_NEIGHBOUR_SOLICITATION)
+ 				return neigh_reduce(dev, skb, vni);
++>>>>>>> 8bff3685a4bb (vxlan: fix the issue that neigh proxy blocks all icmpv6 packets)
  		}
  #endif
  	}
* Unmerged path drivers/net/vxlan.c
