fsnotify: Inline fsnotify_clear_{inode|vfsmount}_mark_group()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jan Kara <jack@suse.cz>
commit 416bcdbcbbb4800f11f03e8baf570f9996219f67
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/416bcdbc.failed

Inline these helpers as they are very thin. We still keep them as we
don't want to expose details about how list type is determined.

	Reviewed-by: Miklos Szeredi <mszeredi@redhat.com>
	Reviewed-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
(cherry picked from commit 416bcdbcbbb4800f11f03e8baf570f9996219f67)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/notify/inode_mark.c
#	fs/notify/vfsmount_mark.c
#	include/linux/fsnotify_backend.h
diff --cc fs/notify/inode_mark.c
index 1168d71dbf85,bdc15f736082..000000000000
--- a/fs/notify/inode_mark.c
+++ b/fs/notify/inode_mark.c
@@@ -31,48 -31,6 +31,51 @@@
  #include "../internal.h"
  
  /*
++<<<<<<< HEAD
 + * Recalculate the inode->i_fsnotify_mask, or the mask of all FS_* event types
 + * any notifier is interested in hearing for this inode.
 + */
 +void fsnotify_recalc_inode_mask(struct inode *inode)
 +{
 +	spin_lock(&inode->i_lock);
 +	inode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);
 +	spin_unlock(&inode->i_lock);
 +
 +	__fsnotify_update_child_dentry_flags(inode);
 +}
 +
 +void fsnotify_destroy_inode_mark(struct fsnotify_mark *mark)
 +{
 +	struct inode *inode = mark->inode;
 +
 +	BUG_ON(!mutex_is_locked(&mark->group->mark_mutex));
 +	assert_spin_locked(&mark->lock);
 +
 +	spin_lock(&inode->i_lock);
 +
 +	hlist_del_init_rcu(&mark->obj_list);
 +	mark->inode = NULL;
 +
 +	/*
 +	 * this mark is now off the inode->i_fsnotify_marks list and we
 +	 * hold the inode->i_lock, so this is the perfect time to update the
 +	 * inode->i_fsnotify_mask
 +	 */
 +	inode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);
 +	spin_unlock(&inode->i_lock);
 +}
 +
 +/*
 + * Given a group clear all of the inode marks associated with that group.
 + */
 +void fsnotify_clear_inode_marks_by_group(struct fsnotify_group *group)
 +{
 +	fsnotify_clear_marks_by_group_flags(group, FSNOTIFY_MARK_FLAG_INODE);
 +}
 +
 +/*
++=======
++>>>>>>> 416bcdbcbbb4 (fsnotify: Inline fsnotify_clear_{inode|vfsmount}_mark_group())
   * given a group and inode, find the mark associated with that combination.
   * if found take a reference to that mark and return it, else return NULL
   */
diff --cc fs/notify/vfsmount_mark.c
index a8fcab68faef,1e692c56deec..000000000000
--- a/fs/notify/vfsmount_mark.c
+++ b/fs/notify/vfsmount_mark.c
@@@ -29,41 -29,6 +29,44 @@@
  #include <linux/fsnotify_backend.h>
  #include "fsnotify.h"
  
++<<<<<<< HEAD
 +void fsnotify_clear_vfsmount_marks_by_group(struct fsnotify_group *group)
 +{
 +	fsnotify_clear_marks_by_group_flags(group, FSNOTIFY_MARK_FLAG_VFSMOUNT);
 +}
 +
 +/*
 + * Recalculate the mnt->mnt_fsnotify_mask, or the mask of all FS_* event types
 + * any notifier is interested in hearing for this mount point
 + */
 +void fsnotify_recalc_vfsmount_mask(struct vfsmount *mnt)
 +{
 +	struct mount *m = real_mount(mnt);
 +
 +	spin_lock(&mnt->mnt_root->d_lock);
 +	m->mnt_fsnotify_mask = fsnotify_recalc_mask(&m->mnt_fsnotify_marks);
 +	spin_unlock(&mnt->mnt_root->d_lock);
 +}
 +
 +void fsnotify_destroy_vfsmount_mark(struct fsnotify_mark *mark)
 +{
 +	struct vfsmount *mnt = mark->mnt;
 +	struct mount *m = real_mount(mnt);
 +
 +	BUG_ON(!mutex_is_locked(&mark->group->mark_mutex));
 +	assert_spin_locked(&mark->lock);
 +
 +	spin_lock(&mnt->mnt_root->d_lock);
 +
 +	hlist_del_init_rcu(&mark->obj_list);
 +	mark->mnt = NULL;
 +
 +	m->mnt_fsnotify_mask = fsnotify_recalc_mask(&m->mnt_fsnotify_marks);
 +	spin_unlock(&mnt->mnt_root->d_lock);
 +}
 +
++=======
++>>>>>>> 416bcdbcbbb4 (fsnotify: Inline fsnotify_clear_{inode|vfsmount}_mark_group())
  /*
   * given a group and vfsmount, find the mark associated with that combination.
   * if found take a reference to that mark and return it, else return NULL
diff --cc include/linux/fsnotify_backend.h
index 0256909191e5,700b4fa991d4..000000000000
--- a/include/linux/fsnotify_backend.h
+++ b/include/linux/fsnotify_backend.h
@@@ -356,15 -355,23 +356,29 @@@ extern void fsnotify_destroy_mark(struc
  extern void fsnotify_detach_mark(struct fsnotify_mark *mark);
  /* free mark */
  extern void fsnotify_free_mark(struct fsnotify_mark *mark);
++<<<<<<< HEAD
 +/* run all the marks in a group, and clear all of the vfsmount marks */
 +extern void fsnotify_clear_vfsmount_marks_by_group(struct fsnotify_group *group);
 +/* run all the marks in a group, and clear all of the inode marks */
 +extern void fsnotify_clear_inode_marks_by_group(struct fsnotify_group *group);
 +/* run all the marks in a group, and clear all of the marks where mark->flags & flags is true*/
++=======
+ /* run all the marks in a group, and clear all of the marks attached to given object type */
++>>>>>>> 416bcdbcbbb4 (fsnotify: Inline fsnotify_clear_{inode|vfsmount}_mark_group())
  extern void fsnotify_clear_marks_by_group_flags(struct fsnotify_group *group, unsigned int flags);
+ /* run all the marks in a group, and clear all of the vfsmount marks */
+ static inline void fsnotify_clear_vfsmount_marks_by_group(struct fsnotify_group *group)
+ {
+ 	fsnotify_clear_marks_by_group_flags(group, FSNOTIFY_OBJ_TYPE_VFSMOUNT);
+ }
+ /* run all the marks in a group, and clear all of the inode marks */
+ static inline void fsnotify_clear_inode_marks_by_group(struct fsnotify_group *group)
+ {
+ 	fsnotify_clear_marks_by_group_flags(group, FSNOTIFY_OBJ_TYPE_INODE);
+ }
  extern void fsnotify_get_mark(struct fsnotify_mark *mark);
  extern void fsnotify_put_mark(struct fsnotify_mark *mark);
 -extern void fsnotify_unmount_inodes(struct super_block *sb);
 -extern void fsnotify_finish_user_wait(struct fsnotify_iter_info *iter_info);
 -extern bool fsnotify_prepare_user_wait(struct fsnotify_iter_info *iter_info);
 +extern void fsnotify_unmount_inodes(struct list_head *list);
  
  /* put here because inotify does some weird stuff when destroying watches */
  extern void fsnotify_init_event(struct fsnotify_event *event,
* Unmerged path fs/notify/inode_mark.c
* Unmerged path fs/notify/vfsmount_mark.c
* Unmerged path include/linux/fsnotify_backend.h
