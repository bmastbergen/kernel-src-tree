qed: Correct endian order of MAC passed to MFW

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Mintz, Yuval <Yuval.Mintz@cavium.com>
commit 179910020759bffe8d75f0b69e6307c25e4d660d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/17991002.failed

The management firmware is running on a Big Endian processor,
and when running on LE platform HW is configured to swap access
to memory shared between management firmware and driver on
32-bit granulariy.

As a result, for matters of simplicity most of the APIs between
driver and management firmware are based on 32-bit variables.
MAC settings are one exception, as driver needs to fill a byte
array when indicating to management firmware that primary MAC
has changed.
Due to the swap, driver must make sure that the mac that was
provided in byte-order would be translated into native order,
otherwise after the swap the management firmware would read
it swapped.

	Signed-off-by: Yuval Mintz <Yuval.Mintz@cavium.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 179910020759bffe8d75f0b69e6307c25e4d660d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qed/qed_mcp.c
diff --cc drivers/net/ethernet/qlogic/qed/qed_mcp.c
index 1cc3e9b6cf0b,d1fcd874ce9a..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_mcp.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_mcp.c
@@@ -1440,7 -1600,7 +1440,11 @@@ int qed_mcp_ov_update_mac(struct qed_hw
  			  struct qed_ptt *p_ptt, u8 *mac)
  {
  	struct qed_mcp_mb_params mb_params;
++<<<<<<< HEAD
 +	union drv_union_data union_data;
++=======
+ 	u32 mfw_mac[2];
++>>>>>>> 179910020759 (qed: Correct endian order of MAC passed to MFW)
  	int rc;
  
  	memset(&mb_params, 0, sizeof(mb_params));
@@@ -1448,8 -1608,17 +1452,22 @@@
  	mb_params.param = DRV_MSG_CODE_VMAC_TYPE_MAC <<
  			  DRV_MSG_CODE_VMAC_TYPE_SHIFT;
  	mb_params.param |= MCP_PF_ID(p_hwfn);
++<<<<<<< HEAD
 +	ether_addr_copy(&union_data.raw_data[0], mac);
 +	mb_params.p_data_src = &union_data;
++=======
+ 
+ 	/* MCP is BE, and on LE platforms PCI would swap access to SHMEM
+ 	 * in 32-bit granularity.
+ 	 * So the MAC has to be set in native order [and not byte order],
+ 	 * otherwise it would be read incorrectly by MFW after swap.
+ 	 */
+ 	mfw_mac[0] = mac[0] << 24 | mac[1] << 16 | mac[2] << 8 | mac[3];
+ 	mfw_mac[1] = mac[4] << 24 | mac[5] << 16;
+ 
+ 	mb_params.p_data_src = (u8 *)mfw_mac;
+ 	mb_params.data_src_size = 8;
++>>>>>>> 179910020759 (qed: Correct endian order of MAC passed to MFW)
  	rc = qed_mcp_cmd_and_union(p_hwfn, p_ptt, &mb_params);
  	if (rc)
  		DP_ERR(p_hwfn, "Failed to send mac address, rc = %d\n", rc);
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_mcp.c
