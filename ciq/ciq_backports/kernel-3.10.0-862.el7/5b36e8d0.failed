i40evf: Enable VF to request an alternate queue allocation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Alan Brady <alan.brady@intel.com>
commit 5b36e8d04b4439c9ceb814bfdfe1284737f9c632
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5b36e8d0.failed

Currently the VF gets a default number of allocated queues from HW on
init and it could choose to enable or disable those allocated queues.
This makes it such that the VF can request more or less underlying
allocated queues from the PF.

First the VF negotiates the number of queues it wants that can be
supported by the PF and if successful asks for a reset.  During reset
the PF will reallocate the HW queues for the VF and will then remap the
new queues.

	Signed-off-by: Alan Brady <alan.brady@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 5b36e8d04b4439c9ceb814bfdfe1284737f9c632)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40evf/i40evf_main.c
#	drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
diff --cc drivers/net/ethernet/intel/i40evf/i40evf_main.c
index b5b622d89241,8c513ce84345..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40evf_main.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_main.c
@@@ -2372,10 -2497,12 +2439,19 @@@ static int i40evf_check_reset_complete(
   **/
  int i40evf_process_config(struct i40evf_adapter *adapter)
  {
++<<<<<<< HEAD
 +	struct i40e_virtchnl_vf_resource *vfres = adapter->vf_res;
 +	struct net_device *netdev = adapter->netdev;
 +	struct i40e_vsi *vsi = &adapter->vsi;
 +	int i;
++=======
+ 	struct virtchnl_vf_resource *vfres = adapter->vf_res;
+ 	int i, num_req_queues = adapter->num_req_queues;
+ 	struct net_device *netdev = adapter->netdev;
+ 	struct i40e_vsi *vsi = &adapter->vsi;
+ 	netdev_features_t hw_enc_features;
+ 	netdev_features_t hw_features;
++>>>>>>> 5b36e8d04b44 (i40evf: Enable VF to request an alternate queue allocation)
  
  	/* got VF config message back from PF, now we can parse it */
  	for (i = 0; i < vfres->num_vsis; i++) {
@@@ -2387,46 -2514,69 +2463,84 @@@
  		return -ENODEV;
  	}
  
++<<<<<<< HEAD
 +	netdev->hw_enc_features |= NETIF_F_SG			|
 +				   NETIF_F_IP_CSUM		|
 +				   NETIF_F_IPV6_CSUM		|
 +				   NETIF_F_HIGHDMA		|
 +				   NETIF_F_SOFT_FEATURES	|
 +				   NETIF_F_TSO			|
 +				   NETIF_F_TSO_ECN		|
 +				   NETIF_F_TSO6			|
++=======
+ 	if (num_req_queues &&
+ 	    num_req_queues != adapter->vsi_res->num_queue_pairs) {
+ 		/* Problem.  The PF gave us fewer queues than what we had
+ 		 * negotiated in our request.  Need a reset to see if we can't
+ 		 * get back to a working state.
+ 		 */
+ 		dev_err(&adapter->pdev->dev,
+ 			"Requested %d queues, but PF only gave us %d.\n",
+ 			num_req_queues,
+ 			adapter->vsi_res->num_queue_pairs);
+ 		adapter->flags |= I40EVF_FLAG_REINIT_ITR_NEEDED;
+ 		adapter->num_req_queues = adapter->vsi_res->num_queue_pairs;
+ 		i40evf_schedule_reset(adapter);
+ 		return -ENODEV;
+ 	}
+ 	adapter->num_req_queues = 0;
+ 
+ 	hw_enc_features = NETIF_F_SG			|
+ 			  NETIF_F_IP_CSUM		|
+ 			  NETIF_F_IPV6_CSUM		|
+ 			  NETIF_F_HIGHDMA		|
+ 			  NETIF_F_SOFT_FEATURES	|
+ 			  NETIF_F_TSO			|
+ 			  NETIF_F_TSO_ECN		|
+ 			  NETIF_F_TSO6			|
+ 			  NETIF_F_SCTP_CRC		|
+ 			  NETIF_F_RXHASH		|
+ 			  NETIF_F_RXCSUM		|
+ 			  0;
+ 
+ 	/* advertise to stack only if offloads for encapsulated packets is
+ 	 * supported
+ 	 */
+ 	if (vfres->vf_cap_flags & VIRTCHNL_VF_OFFLOAD_ENCAP) {
+ 		hw_enc_features |= NETIF_F_GSO_UDP_TUNNEL	|
++>>>>>>> 5b36e8d04b44 (i40evf: Enable VF to request an alternate queue allocation)
  				   NETIF_F_GSO_GRE		|
  				   NETIF_F_GSO_GRE_CSUM		|
 -				   NETIF_F_GSO_IPXIP4		|
 -				   NETIF_F_GSO_IPXIP6		|
 +				   NETIF_F_GSO_IPIP		|
 +				   NETIF_F_GSO_SIT		|
 +				   NETIF_F_GSO_UDP_TUNNEL	|
  				   NETIF_F_GSO_UDP_TUNNEL_CSUM	|
  				   NETIF_F_GSO_PARTIAL		|
 +				   NETIF_F_SCTP_CRC		|
 +				   NETIF_F_RXHASH		|
 +				   NETIF_F_RXCSUM		|
  				   0;
  
 -		if (!(vfres->vf_cap_flags &
 -		      VIRTCHNL_VF_OFFLOAD_ENCAP_CSUM))
 -			netdev->gso_partial_features |=
 -				NETIF_F_GSO_UDP_TUNNEL_CSUM;
 +	if (!(adapter->flags & I40EVF_FLAG_OUTER_UDP_CSUM_CAPABLE))
 +		netdev->gso_partial_features |= NETIF_F_GSO_UDP_TUNNEL_CSUM;
 +
 +	netdev->gso_partial_features |= NETIF_F_GSO_GRE_CSUM;
  
 -		netdev->gso_partial_features |= NETIF_F_GSO_GRE_CSUM;
 -		netdev->hw_enc_features |= NETIF_F_TSO_MANGLEID;
 -		netdev->hw_enc_features |= hw_enc_features;
 -	}
  	/* record features VLANs can make use of */
 -	netdev->vlan_features |= hw_enc_features | NETIF_F_TSO_MANGLEID;
 +	netdev->vlan_features |= netdev->hw_enc_features |
 +				 NETIF_F_TSO_MANGLEID;
  
  	/* Write features and hw_features separately to avoid polluting
 -	 * with, or dropping, features that are set when we registered.
 +	 * with, or dropping, features that are set when we registgered.
  	 */
 -	hw_features = hw_enc_features;
 +	netdev->hw_features |= netdev->hw_enc_features;
  
 -	netdev->hw_features |= hw_features;
 +	netdev->features |= netdev->hw_enc_features | I40EVF_VLAN_FEATURES;
 +	netdev->hw_enc_features |= NETIF_F_TSO_MANGLEID;
  
 -	netdev->features |= hw_features | I40EVF_VLAN_FEATURES;
 +	/* disable VLAN features if not supported */
 +	if (!(vfres->vf_offload_flags & I40E_VIRTCHNL_VF_OFFLOAD_VLAN))
 +		netdev->features ^= I40EVF_VLAN_FEATURES;
  
  	adapter->vsi.id = adapter->vsi_res->vsi_id;
  
diff --cc drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
index 478c3f9a718f,2bb81c39d85f..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
@@@ -152,15 -152,18 +152,28 @@@ int i40evf_send_vf_config_msg(struct i4
  {
  	u32 caps;
  
++<<<<<<< HEAD
 +	caps = I40E_VIRTCHNL_VF_OFFLOAD_L2 |
 +	       I40E_VIRTCHNL_VF_OFFLOAD_RSS_PF |
 +	       I40E_VIRTCHNL_VF_OFFLOAD_RSS_AQ |
 +	       I40E_VIRTCHNL_VF_OFFLOAD_RSS_REG |
 +	       I40E_VIRTCHNL_VF_OFFLOAD_VLAN |
 +	       I40E_VIRTCHNL_VF_OFFLOAD_WB_ON_ITR |
 +	       I40E_VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2;
++=======
+ 	caps = VIRTCHNL_VF_OFFLOAD_L2 |
+ 	       VIRTCHNL_VF_OFFLOAD_RSS_PF |
+ 	       VIRTCHNL_VF_OFFLOAD_RSS_AQ |
+ 	       VIRTCHNL_VF_OFFLOAD_RSS_REG |
+ 	       VIRTCHNL_VF_OFFLOAD_VLAN |
+ 	       VIRTCHNL_VF_OFFLOAD_WB_ON_ITR |
+ 	       VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2 |
+ 	       VIRTCHNL_VF_OFFLOAD_ENCAP |
+ 	       VIRTCHNL_VF_OFFLOAD_ENCAP_CSUM |
+ 	       VIRTCHNL_VF_OFFLOAD_REQ_QUEUES;
++>>>>>>> 5b36e8d04b44 (i40evf: Enable VF to request an alternate queue allocation)
  
 -	adapter->current_op = VIRTCHNL_OP_GET_VF_RESOURCES;
 +	adapter->current_op = I40E_VIRTCHNL_OP_GET_VF_RESOURCES;
  	adapter->aq_required &= ~I40EVF_FLAG_AQ_GET_CONFIG;
  	if (PF_IS_V11(adapter))
  		return i40evf_send_pf_msg(adapter,
diff --git a/drivers/net/ethernet/intel/i40evf/i40evf.h b/drivers/net/ethernet/intel/i40evf/i40evf.h
index 9b6fa8fbd0a9..61d45d9d69c5 100644
--- a/drivers/net/ethernet/intel/i40evf/i40evf.h
+++ b/drivers/net/ethernet/intel/i40evf/i40evf.h
@@ -99,6 +99,7 @@ struct i40e_vsi {
 #define I40E_TX_CTXTDESC(R, i) \
 	(&(((struct i40e_tx_context_desc *)((R)->desc))[i]))
 #define MAX_QUEUES 16
+#define I40EVF_MAX_REQ_QUEUES 4
 
 #define I40EVF_HKEY_ARRAY_SIZE ((I40E_VFQF_HKEY_MAX_INDEX + 1) * 4)
 #define I40EVF_HLUT_ARRAY_SIZE ((I40E_VFQF_HLUT_MAX_INDEX + 1) * 4)
@@ -199,6 +200,7 @@ struct i40evf_adapter {
 	struct list_head vlan_filter_list;
 	char misc_vector_name[IFNAMSIZ + 9];
 	int num_active_queues;
+	int num_req_queues;
 
 	/* TX */
 	struct i40e_ring *tx_rings;
@@ -234,6 +236,7 @@ struct i40evf_adapter {
 #define I40EVF_FLAG_PROMISC_ON			BIT(18)
 #define I40EVF_FLAG_ALLMULTI_ON			BIT(19)
 #define I40EVF_FLAG_LEGACY_RX			BIT(20)
+#define I40EVF_FLAG_REINIT_ITR_NEEDED		BIT(21)
 /* duplicates for common code */
 #define I40E_FLAG_DCB_ENABLED			0
 #define I40E_FLAG_RX_CSUM_ENABLED		I40EVF_FLAG_RX_CSUM_ENABLED
@@ -348,6 +351,7 @@ void i40evf_deconfigure_queues(struct i40evf_adapter *adapter);
 void i40evf_enable_queues(struct i40evf_adapter *adapter);
 void i40evf_disable_queues(struct i40evf_adapter *adapter);
 void i40evf_map_queues(struct i40evf_adapter *adapter);
+int i40evf_request_queues(struct i40evf_adapter *adapter, int num);
 void i40evf_add_ether_addrs(struct i40evf_adapter *adapter);
 void i40evf_del_ether_addrs(struct i40evf_adapter *adapter);
 void i40evf_add_vlans(struct i40evf_adapter *adapter);
diff --git a/drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c b/drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
index 76fd89c1dbb2..a71a5bb0bd5a 100644
--- a/drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
@@ -648,7 +648,7 @@ static void i40evf_get_channels(struct net_device *netdev,
 	struct i40evf_adapter *adapter = netdev_priv(netdev);
 
 	/* Report maximum channels */
-	ch->max_combined = adapter->num_active_queues;
+	ch->max_combined = I40EVF_MAX_REQ_QUEUES;
 
 	ch->max_other = NONQ_VECS;
 	ch->other_count = NONQ_VECS;
@@ -656,6 +656,41 @@ static void i40evf_get_channels(struct net_device *netdev,
 	ch->combined_count = adapter->num_active_queues;
 }
 
+/**
+ * i40evf_set_channels: set the new channel count
+ * @netdev: network interface device structure
+ * @ch: channel information structure
+ *
+ * Negotiate a new number of channels with the PF then do a reset.  During
+ * reset we'll realloc queues and fix the RSS table.  Returns 0 on success,
+ * negative on failure.
+ **/
+static int i40evf_set_channels(struct net_device *netdev,
+			       struct ethtool_channels *ch)
+{
+	struct i40evf_adapter *adapter = netdev_priv(netdev);
+	int num_req = ch->combined_count;
+
+	if (num_req != adapter->num_active_queues &&
+	    !(adapter->vf_res->vf_cap_flags &
+	      VIRTCHNL_VF_OFFLOAD_REQ_QUEUES)) {
+		dev_info(&adapter->pdev->dev, "PF is not capable of queue negotiation.\n");
+		return -EINVAL;
+	}
+
+	/* All of these should have already been checked by ethtool before this
+	 * even gets to us, but just to be sure.
+	 */
+	if (num_req <= 0 || num_req > I40EVF_MAX_REQ_QUEUES)
+		return -EINVAL;
+
+	if (ch->rx_count || ch->tx_count || ch->other_count != NONQ_VECS)
+		return -EINVAL;
+
+	adapter->num_req_queues = num_req;
+	return i40evf_request_queues(adapter, num_req);
+}
+
 /**
  * i40evf_get_rxfh_key_size - get the RSS hash key size
  * @netdev: network interface device structure
@@ -764,6 +799,7 @@ static const struct ethtool_ops i40evf_ethtool_ops = {
 	.get_rxfh		= i40evf_get_rxfh,
 	.set_rxfh		= i40evf_set_rxfh,
 	.get_channels		= i40evf_get_channels,
+	.set_channels		= i40evf_set_channels,
 	.get_rxfh_key_size	= i40evf_get_rxfh_key_size,
 	.get_link_ksettings	= i40evf_get_link_ksettings,
 };
* Unmerged path drivers/net/ethernet/intel/i40evf/i40evf_main.c
* Unmerged path drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
