ceph: clean up unsafe d_parent accesses in build_dentry_path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jeff Layton <jlayton@redhat.com>
commit c6b0b656ca24ede6657abb4a2cd910fa9c1879ba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c6b0b656.failed

While we hold a reference to the dentry when build_dentry_path is
called, we could end up racing with a rename that changes d_parent.
Handle that situation correctly, by using the rcu_read_lock to
ensure that the parent dentry and inode stick around long enough
to safely check ceph_snap and ceph_ino.

Link: http://tracker.ceph.com/issues/18148
	Signed-off-by: Jeff Layton <jlayton@redhat.com>
	Reviewed-by: Yan, Zheng <zyan@redhat.com>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit c6b0b656ca24ede6657abb4a2cd910fa9c1879ba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/mds_client.c
diff --cc fs/ceph/mds_client.c
index 33c790140222,7c2eb28c24f6..000000000000
--- a/fs/ceph/mds_client.c
+++ b/fs/ceph/mds_client.c
@@@ -1775,9 -1800,13 +1775,18 @@@ static int build_dentry_path(struct den
  			     int *pfreepath)
  {
  	char *path;
+ 	struct inode *dir;
  
++<<<<<<< HEAD
 +	if (ceph_snap(dentry->d_parent->d_inode) == CEPH_NOSNAP) {
 +		*pino = ceph_ino(dentry->d_parent->d_inode);
++=======
+ 	rcu_read_lock();
+ 	dir = d_inode_rcu(dentry->d_parent);
+ 	if (dir && ceph_snap(dir) == CEPH_NOSNAP) {
+ 		*pino = ceph_ino(dir);
+ 		rcu_read_unlock();
++>>>>>>> c6b0b656ca24 (ceph: clean up unsafe d_parent accesses in build_dentry_path)
  		*ppath = dentry->d_name.name;
  		*ppathlen = dentry->d_name.len;
  		return 0;
* Unmerged path fs/ceph/mds_client.c
