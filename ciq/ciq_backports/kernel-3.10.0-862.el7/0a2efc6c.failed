radix-tree: rewrite radix_tree_locate_item

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Matthew Wilcox <willy@linux.intel.com>
commit 0a2efc6c809b01872321d9c7e7d82d59ac6fde10
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0a2efc6c.failed

Use the new multi-order support functions to rewrite
radix_tree_locate_item().  Modify the locate tests to test multiorder
entries too.

[hughd@google.com: radix_tree_locate_item() is often returning the wrong index]
  Link: http://lkml.kernel.org/r/alpine.LSU.2.11.1605012108490.1166@eggly.anvils
	Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
	Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
	Cc: Konstantin Khlebnikov <koct9i@gmail.com>
	Cc: Kirill Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Jan Kara <jack@suse.com>
	Cc: Neil Brown <neilb@suse.de>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 0a2efc6c809b01872321d9c7e7d82d59ac6fde10)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/radix-tree.c
#	tools/testing/radix-tree/main.c
diff --cc lib/radix-tree.c
index b74b37798d79,8329a2e950eb..000000000000
--- a/lib/radix-tree.c
+++ b/lib/radix-tree.c
@@@ -1344,17 -1384,19 +1343,24 @@@ unsigned long radix_tree_locate_item(st
  		}
  
  		node = indirect_to_ptr(node);
++<<<<<<< HEAD
 +		max_index = radix_tree_maxindex(node->path &
 +						RADIX_TREE_HEIGHT_MASK);
 +		if (cur_index > max_index)
++=======
+ 
+ 		max_index = node_maxindex(node);
+ 		if (cur_index > max_index) {
+ 			rcu_read_unlock();
++>>>>>>> 0a2efc6c809b (radix-tree: rewrite radix_tree_locate_item)
  			break;
 -		}
  
- 		cur_index = __locate(node, item, cur_index, &found_index);
+ 		cur_index = __locate(node, item, cur_index, &info);
  		rcu_read_unlock();
  		cond_resched();
- 	} while (cur_index != 0 && cur_index <= max_index);
+ 	} while (!info.stop && cur_index <= max_index);
  
- 	return found_index;
+ 	return info.found_index;
  }
  #else
  unsigned long radix_tree_locate_item(struct radix_tree_root *root, void *item)
diff --cc tools/testing/radix-tree/main.c
index 0e83cad27a9f,65231e9ba3e8..000000000000
--- a/tools/testing/radix-tree/main.c
+++ b/tools/testing/radix-tree/main.c
@@@ -232,7 -232,51 +232,55 @@@ void copy_tag_check(void
  	item_kill_tree(&tree);
  }
  
++<<<<<<< HEAD
 +static void single_thread_tests(void)
++=======
+ void __locate_check(struct radix_tree_root *tree, unsigned long index,
+ 			unsigned order)
+ {
+ 	struct item *item;
+ 	unsigned long index2;
+ 
+ 	item_insert_order(tree, index, order);
+ 	item = item_lookup(tree, index);
+ 	index2 = radix_tree_locate_item(tree, item);
+ 	if (index != index2) {
+ 		printf("index %ld order %d inserted; found %ld\n",
+ 			index, order, index2);
+ 		abort();
+ 	}
+ }
+ 
+ static void locate_check(void)
+ {
+ 	RADIX_TREE(tree, GFP_KERNEL);
+ 	unsigned order;
+ 	unsigned long offset, index;
+ 
+ 	for (order = 0; order < 20; order++) {
+ 		for (offset = 0; offset < (1 << (order + 3));
+ 		     offset += (1UL << order)) {
+ 			for (index = 0; index < (1UL << (order + 5));
+ 			     index += (1UL << order)) {
+ 				__locate_check(&tree, index + offset, order);
+ 			}
+ 			if (radix_tree_locate_item(&tree, &tree) != -1)
+ 				abort();
+ 
+ 			item_kill_tree(&tree);
+ 		}
+ 	}
+ 
+ 	if (radix_tree_locate_item(&tree, &tree) != -1)
+ 		abort();
+ 	__locate_check(&tree, -1, 0);
+ 	if (radix_tree_locate_item(&tree, &tree) != -1)
+ 		abort();
+ 	item_kill_tree(&tree);
+ }
+ 
+ static void single_thread_tests(bool long_run)
++>>>>>>> 0a2efc6c809b (radix-tree: rewrite radix_tree_locate_item)
  {
  	int i;
  
* Unmerged path lib/radix-tree.c
* Unmerged path tools/testing/radix-tree/main.c
