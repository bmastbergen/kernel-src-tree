x86/intel_rdt/cqm: Add mon_data

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] intel_rdt/cqm: Add mon_data (Jiri Olsa) [1457533]
Rebuild_FUZZ: 93.10%
commit-author Vikas Shivappa <vikas.shivappa@linux.intel.com>
commit d89b7379015fc561060a4094676d143e6ed264e7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d89b7379.failed

Add a mon_data directory for the root rdtgroup and all other rdtgroups.
The directory holds all of the monitored data for all domains and events
of all resources being monitored.

The mon_data itself has a list of directories in the format
mon_<domain_name>_<domain_id>. Each of these subdirectories contain one
file per event in the mode "0444". Reading the file displays a snapshot
of the monitored data for the event the file represents.

For ex, on a 2 socket Broadwell with llc_occupancy being
monitored the mon_data contents look as below:

$ ls /sys/fs/resctrl/p1/mon_data/
mon_L3_00
mon_L3_01

Each domain directory has one file per event:
$ ls /sys/fs/resctrl/p1/mon_data/mon_L3_00/
llc_occupancy

To read current llc_occupancy of ctrl_mon group p1
$ cat /sys/fs/resctrl/p1/mon_data/mon_L3_00/llc_occupancy
33789096

[This patch idea is based on Tony's sample patches to organise data in a
per domain directory and have one file per event (and use the fp->priv to
store mon data bits)]

	Signed-off-by: Vikas Shivappa <vikas.shivappa@linux.intel.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: ravi.v.shankar@intel.com
	Cc: tony.luck@intel.com
	Cc: fenghua.yu@intel.com
	Cc: peterz@infradead.org
	Cc: eranian@google.com
	Cc: vikas.shivappa@intel.com
	Cc: ak@linux.intel.com
	Cc: davidcc@google.com
	Cc: reinette.chatre@intel.com
Link: http://lkml.kernel.org/r/1501017287-28083-20-git-send-email-vikas.shivappa@linux.intel.com

(cherry picked from commit d89b7379015fc561060a4094676d143e6ed264e7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/intel_rdt.c
#	arch/x86/kernel/cpu/intel_rdt.h
#	arch/x86/kernel/cpu/intel_rdt_monitor.c
#	arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
diff --cc arch/x86/kernel/cpu/intel_rdt.c
index ad087dd4421e,050ea15259ea..000000000000
--- a/arch/x86/kernel/cpu/intel_rdt.c
+++ b/arch/x86/kernel/cpu/intel_rdt.c
@@@ -45,42 -55,99 +45,122 @@@ DEFINE_PER_CPU_READ_MOSTLY(int, cpu_clo
   */
  int max_name_width, max_data_width;
  
 -/*
 - * Global boolean for rdt_alloc which is true if any
 - * resource allocation is enabled.
 - */
 -bool rdt_alloc_capable;
 -
 -static void
 -mba_wrmsr(struct rdt_domain *d, struct msr_param *m, struct rdt_resource *r);
 -static void
 -cat_wrmsr(struct rdt_domain *d, struct msr_param *m, struct rdt_resource *r);
 -
 -#define domain_init(id) LIST_HEAD_INIT(rdt_resources_all[id].domains)
 -
  struct rdt_resource rdt_resources_all[] = {
 -	[RDT_RESOURCE_L3] =
  	{
++<<<<<<< HEAD
 +		.name		= "L3",
 +		.domains	= domain_init(RDT_RESOURCE_L3),
 +		.msr_base	= IA32_L3_CBM_BASE,
 +		.min_cbm_bits	= 1,
 +		.cache_level	= 3,
 +		.cbm_idx_multi	= 1,
 +		.cbm_idx_offset	= 0
++=======
+ 		.rid			= RDT_RESOURCE_L3,
+ 		.name			= "L3",
+ 		.domains		= domain_init(RDT_RESOURCE_L3),
+ 		.msr_base		= IA32_L3_CBM_BASE,
+ 		.msr_update		= cat_wrmsr,
+ 		.cache_level		= 3,
+ 		.cache = {
+ 			.min_cbm_bits	= 1,
+ 			.cbm_idx_mult	= 1,
+ 			.cbm_idx_offset	= 0,
+ 		},
+ 		.parse_ctrlval		= parse_cbm,
+ 		.format_str		= "%d=%0*x",
+ 		.fflags			= RFTYPE_RES_CACHE,
++>>>>>>> d89b7379015f (x86/intel_rdt/cqm: Add mon_data)
  	},
 -	[RDT_RESOURCE_L3DATA] =
  	{
++<<<<<<< HEAD
 +		.name		= "L3DATA",
 +		.domains	= domain_init(RDT_RESOURCE_L3DATA),
 +		.msr_base	= IA32_L3_CBM_BASE,
 +		.min_cbm_bits	= 1,
 +		.cache_level	= 3,
 +		.cbm_idx_multi	= 2,
 +		.cbm_idx_offset	= 0
++=======
+ 		.rid			= RDT_RESOURCE_L3DATA,
+ 		.name			= "L3DATA",
+ 		.domains		= domain_init(RDT_RESOURCE_L3DATA),
+ 		.msr_base		= IA32_L3_CBM_BASE,
+ 		.msr_update		= cat_wrmsr,
+ 		.cache_level		= 3,
+ 		.cache = {
+ 			.min_cbm_bits	= 1,
+ 			.cbm_idx_mult	= 2,
+ 			.cbm_idx_offset	= 0,
+ 		},
+ 		.parse_ctrlval		= parse_cbm,
+ 		.format_str		= "%d=%0*x",
+ 		.fflags			= RFTYPE_RES_CACHE,
++>>>>>>> d89b7379015f (x86/intel_rdt/cqm: Add mon_data)
  	},
 -	[RDT_RESOURCE_L3CODE] =
  	{
++<<<<<<< HEAD
 +		.name		= "L3CODE",
 +		.domains	= domain_init(RDT_RESOURCE_L3CODE),
 +		.msr_base	= IA32_L3_CBM_BASE,
 +		.min_cbm_bits	= 1,
 +		.cache_level	= 3,
 +		.cbm_idx_multi	= 2,
 +		.cbm_idx_offset	= 1
++=======
+ 		.rid			= RDT_RESOURCE_L3CODE,
+ 		.name			= "L3CODE",
+ 		.domains		= domain_init(RDT_RESOURCE_L3CODE),
+ 		.msr_base		= IA32_L3_CBM_BASE,
+ 		.msr_update		= cat_wrmsr,
+ 		.cache_level		= 3,
+ 		.cache = {
+ 			.min_cbm_bits	= 1,
+ 			.cbm_idx_mult	= 2,
+ 			.cbm_idx_offset	= 1,
+ 		},
+ 		.parse_ctrlval		= parse_cbm,
+ 		.format_str		= "%d=%0*x",
+ 		.fflags			= RFTYPE_RES_CACHE,
++>>>>>>> d89b7379015f (x86/intel_rdt/cqm: Add mon_data)
  	},
 -	[RDT_RESOURCE_L2] =
  	{
++<<<<<<< HEAD
 +		.name		= "L2",
 +		.domains	= domain_init(RDT_RESOURCE_L2),
 +		.msr_base	= IA32_L2_CBM_BASE,
 +		.min_cbm_bits	= 1,
 +		.cache_level	= 2,
 +		.cbm_idx_multi	= 1,
 +		.cbm_idx_offset	= 0
++=======
+ 		.rid			= RDT_RESOURCE_L2,
+ 		.name			= "L2",
+ 		.domains		= domain_init(RDT_RESOURCE_L2),
+ 		.msr_base		= IA32_L2_CBM_BASE,
+ 		.msr_update		= cat_wrmsr,
+ 		.cache_level		= 2,
+ 		.cache = {
+ 			.min_cbm_bits	= 1,
+ 			.cbm_idx_mult	= 1,
+ 			.cbm_idx_offset	= 0,
+ 		},
+ 		.parse_ctrlval		= parse_cbm,
+ 		.format_str		= "%d=%0*x",
+ 		.fflags			= RFTYPE_RES_CACHE,
+ 	},
+ 	[RDT_RESOURCE_MBA] =
+ 	{
+ 		.rid			= RDT_RESOURCE_MBA,
+ 		.name			= "MB",
+ 		.domains		= domain_init(RDT_RESOURCE_MBA),
+ 		.msr_base		= IA32_MBA_THRTL_BASE,
+ 		.msr_update		= mba_wrmsr,
+ 		.cache_level		= 3,
+ 		.parse_ctrlval		= parse_bw,
+ 		.format_str		= "%d=%*d",
+ 		.fflags			= RFTYPE_RES_MB,
++>>>>>>> d89b7379015f (x86/intel_rdt/cqm: Add mon_data)
  	},
  };
  
diff --cc arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
index 1c3603d97e9d,59de36dd534f..000000000000
--- a/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
+++ b/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
@@@ -932,23 -1222,152 +937,164 @@@ static struct file_system_type rdt_fs_t
  	.kill_sb = rdt_kill_sb,
  };
  
++<<<<<<< HEAD
 +static int rdtgroup_mkdir(struct kernfs_node *parent_kn, const char *name,
 +			  umode_t mode)
++=======
+ static int mon_addfile(struct kernfs_node *parent_kn, const char *name,
+ 		       void *priv)
+ {
+ 	struct kernfs_node *kn;
+ 	int ret = 0;
+ 
+ 	kn = __kernfs_create_file(parent_kn, name, 0444, 0,
+ 				  &kf_mondata_ops, priv, NULL, NULL);
+ 	if (IS_ERR(kn))
+ 		return PTR_ERR(kn);
+ 
+ 	ret = rdtgroup_kn_set_ugid(kn);
+ 	if (ret) {
+ 		kernfs_remove(kn);
+ 		return ret;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int mkdir_mondata_subdir(struct kernfs_node *parent_kn,
+ 				struct rdt_domain *d,
+ 				struct rdt_resource *r, struct rdtgroup *prgrp)
+ {
+ 	union mon_data_bits priv;
+ 	struct kernfs_node *kn;
+ 	struct mon_evt *mevt;
+ 	char name[32];
+ 	int ret;
+ 
+ 	sprintf(name, "mon_%s_%02d", r->name, d->id);
+ 	/* create the directory */
+ 	kn = kernfs_create_dir(parent_kn, name, parent_kn->mode, prgrp);
+ 	if (IS_ERR(kn))
+ 		return PTR_ERR(kn);
+ 
+ 	/*
+ 	 * This extra ref will be put in kernfs_remove() and guarantees
+ 	 * that kn is always accessible.
+ 	 */
+ 	kernfs_get(kn);
+ 	ret = rdtgroup_kn_set_ugid(kn);
+ 	if (ret)
+ 		goto out_destroy;
+ 
+ 	if (WARN_ON(list_empty(&r->evt_list))) {
+ 		ret = -EPERM;
+ 		goto out_destroy;
+ 	}
+ 
+ 	priv.u.rid = r->rid;
+ 	priv.u.domid = d->id;
+ 	list_for_each_entry(mevt, &r->evt_list, list) {
+ 		priv.u.evtid = mevt->evtid;
+ 		ret = mon_addfile(kn, mevt->name, priv.priv);
+ 		if (ret)
+ 			goto out_destroy;
+ 	}
+ 	kernfs_activate(kn);
+ 	return 0;
+ 
+ out_destroy:
+ 	kernfs_remove(kn);
+ 	return ret;
+ }
+ 
+ static int mkdir_mondata_subdir_alldom(struct kernfs_node *parent_kn,
+ 				       struct rdt_resource *r,
+ 				       struct rdtgroup *prgrp)
+ {
+ 	struct rdt_domain *dom;
+ 	int ret;
+ 
+ 	list_for_each_entry(dom, &r->domains, list) {
+ 		ret = mkdir_mondata_subdir(parent_kn, dom, r, prgrp);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * This creates a directory mon_data which contains the monitored data.
+  *
+  * mon_data has one directory for each domain whic are named
+  * in the format mon_<domain_name>_<domain_id>. For ex: A mon_data
+  * with L3 domain looks as below:
+  * ./mon_data:
+  * mon_L3_00
+  * mon_L3_01
+  * mon_L3_02
+  * ...
+  *
+  * Each domain directory has one file per event:
+  * ./mon_L3_00/:
+  * llc_occupancy
+  *
+  */
+ static int mkdir_mondata_all(struct kernfs_node *parent_kn,
+ 			     struct rdtgroup *prgrp,
+ 			     struct kernfs_node **dest_kn)
+ {
+ 	struct rdt_resource *r;
+ 	struct kernfs_node *kn;
+ 	int ret;
+ 
+ 	/*
+ 	 * Create the mon_data directory first.
+ 	 */
+ 	ret = mongroup_create_dir(parent_kn, NULL, "mon_data", &kn);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (dest_kn)
+ 		*dest_kn = kn;
+ 
+ 	/*
+ 	 * Create the subdirectories for each domain. Note that all events
+ 	 * in a domain like L3 are grouped into a resource whose domain is L3
+ 	 */
+ 	for_each_mon_enabled_rdt_resource(r) {
+ 		ret = mkdir_mondata_subdir_alldom(kn, r, prgrp);
+ 		if (ret)
+ 			goto out_destroy;
+ 	}
+ 
+ 	return 0;
+ 
+ out_destroy:
+ 	kernfs_remove(kn);
+ 	return ret;
+ }
+ 
+ static int mkdir_rdt_prepare(struct kernfs_node *parent_kn,
+ 			     struct kernfs_node *prgrp_kn,
+ 			     const char *name, umode_t mode,
+ 			     enum rdt_group_type rtype, struct rdtgroup **r)
++>>>>>>> d89b7379015f (x86/intel_rdt/cqm: Add mon_data)
  {
 -	struct rdtgroup *prdtgrp, *rdtgrp;
 +	struct rdtgroup *parent, *rdtgrp;
  	struct kernfs_node *kn;
 -	uint files = 0;
 -	int ret;
 +	int ret, closid;
  
 -	prdtgrp = rdtgroup_kn_lock_live(prgrp_kn);
 -	if (!prdtgrp) {
 +	/* Only allow mkdir in the root directory */
 +	if (parent_kn != rdtgroup_default.kn)
 +		return -EPERM;
 +
 +	/* Do not accept '\n' to avoid unparsable situation. */
 +	if (strchr(name, '\n'))
 +		return -EINVAL;
 +
 +	parent = rdtgroup_kn_lock_live(parent_kn);
 +	if (!parent) {
  		ret = -ENODEV;
  		goto out_unlock;
  	}
@@@ -992,20 -1409,118 +1138,35 @@@
  	if (ret)
  		goto out_destroy;
  
++<<<<<<< HEAD
++=======
+ 	if (rdt_mon_capable) {
+ 		ret = alloc_rmid();
+ 		if (ret < 0)
+ 			goto out_destroy;
+ 		rdtgrp->mon.rmid = ret;
+ 
+ 		ret = mkdir_mondata_all(kn, rdtgrp, &rdtgrp->mon.mon_data_kn);
+ 		if (ret)
+ 			goto out_idfree;
+ 	}
++>>>>>>> d89b7379015f (x86/intel_rdt/cqm: Add mon_data)
  	kernfs_activate(kn);
  
 -	/*
 -	 * The caller unlocks the prgrp_kn upon success.
 -	 */
 -	return 0;
 +	ret = 0;
 +	goto out_unlock;
  
+ out_idfree:
+ 	free_rmid(rdtgrp->mon.rmid);
  out_destroy:
  	kernfs_remove(rdtgrp->kn);
 -out_free_rgrp:
 +out_cancel_ref:
 +	list_del(&rdtgrp->rdtgroup_list);
  	kfree(rdtgrp);
 -out_unlock:
 -	rdtgroup_kn_unlock(prgrp_kn);
 -	return ret;
 -}
 -
 -static void mkdir_rdt_prepare_clean(struct rdtgroup *rgrp)
 -{
 -	kernfs_remove(rgrp->kn);
 -	free_rmid(rgrp->mon.rmid);
 -	kfree(rgrp);
 -}
 -
 -/*
 - * Create a monitor group under "mon_groups" directory of a control
 - * and monitor group(ctrl_mon). This is a resource group
 - * to monitor a subset of tasks and cpus in its parent ctrl_mon group.
 - */
 -static int rdtgroup_mkdir_mon(struct kernfs_node *parent_kn,
 -			      struct kernfs_node *prgrp_kn,
 -			      const char *name,
 -			      umode_t mode)
 -{
 -	struct rdtgroup *rdtgrp, *prgrp;
 -	int ret;
 -
 -	ret = mkdir_rdt_prepare(parent_kn, prgrp_kn, name, mode, RDTMON_GROUP,
 -				&rdtgrp);
 -	if (ret)
 -		return ret;
 -
 -	prgrp = rdtgrp->mon.parent;
 -	rdtgrp->closid = prgrp->closid;
 -
 -	/*
 -	 * Add the rdtgrp to the list of rdtgrps the parent
 -	 * ctrl_mon group has to track.
 -	 */
 -	list_add_tail(&rdtgrp->mon.crdtgrp_list, &prgrp->mon.crdtgrp_list);
 -
 -	rdtgroup_kn_unlock(prgrp_kn);
 -	return ret;
 -}
 -
 -/*
 - * These are rdtgroups created under the root directory. Can be used
 - * to allocate and monitor resources.
 - */
 -static int rdtgroup_mkdir_ctrl_mon(struct kernfs_node *parent_kn,
 -				   struct kernfs_node *prgrp_kn,
 -				   const char *name, umode_t mode)
 -{
 -	struct rdtgroup *rdtgrp;
 -	struct kernfs_node *kn;
 -	u32 closid;
 -	int ret;
 -
 -	ret = mkdir_rdt_prepare(parent_kn, prgrp_kn, name, mode, RDTCTRL_GROUP,
 -				&rdtgrp);
 -	if (ret)
 -		return ret;
 -
 -	kn = rdtgrp->kn;
 -	ret = closid_alloc();
 -	if (ret < 0)
 -		goto out_common_fail;
 -	closid = ret;
 -
 -	rdtgrp->closid = closid;
 -	list_add(&rdtgrp->rdtgroup_list, &rdt_all_groups);
 -
 -	if (rdt_mon_capable) {
 -		/*
 -		 * Create an empty mon_groups directory to hold the subset
 -		 * of tasks and cpus to monitor.
 -		 */
 -		ret = mongroup_create_dir(kn, NULL, "mon_groups", NULL);
 -		if (ret)
 -			goto out_id_free;
 -	}
 -
 -	goto out_unlock;
 -
 -out_id_free:
 +out_closid_free:
  	closid_free(closid);
 -	list_del(&rdtgrp->rdtgroup_list);
 -out_common_fail:
 -	mkdir_rdt_prepare_clean(rdtgrp);
  out_unlock:
 -	rdtgroup_kn_unlock(prgrp_kn);
 +	rdtgroup_kn_unlock(parent_kn);
  	return ret;
  }
  
* Unmerged path arch/x86/kernel/cpu/intel_rdt.h
* Unmerged path arch/x86/kernel/cpu/intel_rdt_monitor.c
* Unmerged path arch/x86/kernel/cpu/intel_rdt.c
* Unmerged path arch/x86/kernel/cpu/intel_rdt.h
* Unmerged path arch/x86/kernel/cpu/intel_rdt_monitor.c
* Unmerged path arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
diff --git a/arch/x86/kernel/cpu/intel_rdt_schemata.c b/arch/x86/kernel/cpu/intel_rdt_schemata.c
index 6efa856bc635..86f0c5985905 100644
--- a/arch/x86/kernel/cpu/intel_rdt_schemata.c
+++ b/arch/x86/kernel/cpu/intel_rdt_schemata.c
@@ -220,7 +220,8 @@ int rdtgroup_schemata_show(struct kernfs_open_file *of,
 {
 	struct rdtgroup *rdtgrp;
 	struct rdt_resource *r;
-	int closid, ret = 0;
+	int ret = 0;
+	u32 closid;
 
 	rdtgrp = rdtgroup_kn_lock_live(of->kn);
 	if (rdtgrp) {
@@ -235,3 +236,55 @@ int rdtgroup_schemata_show(struct kernfs_open_file *of,
 	rdtgroup_kn_unlock(of->kn);
 	return ret;
 }
+
+void mon_event_read(struct rmid_read *rr, struct rdt_domain *d,
+		    struct rdtgroup *rdtgrp, int evtid)
+{
+	/*
+	 * setup the parameters to send to the IPI to read the data.
+	 */
+	rr->rgrp = rdtgrp;
+	rr->evtid = evtid;
+	rr->val = 0;
+
+	smp_call_function_any(&d->cpu_mask, mon_event_count, rr, 1);
+}
+
+int rdtgroup_mondata_show(struct seq_file *m, void *arg)
+{
+	struct kernfs_open_file *of = m->private;
+	u32 resid, evtid, domid;
+	struct rdtgroup *rdtgrp;
+	struct rdt_resource *r;
+	union mon_data_bits md;
+	struct rdt_domain *d;
+	struct rmid_read rr;
+	int ret = 0;
+
+	rdtgrp = rdtgroup_kn_lock_live(of->kn);
+
+	md.priv = of->kn->priv;
+	resid = md.u.rid;
+	domid = md.u.domid;
+	evtid = md.u.evtid;
+
+	r = &rdt_resources_all[resid];
+	d = rdt_find_domain(r, domid, NULL);
+	if (!d) {
+		ret = -ENOENT;
+		goto out;
+	}
+
+	mon_event_read(&rr, d, rdtgrp, evtid);
+
+	if (rr.val & RMID_VAL_ERROR)
+		seq_puts(m, "Error\n");
+	else if (rr.val & RMID_VAL_UNAVAIL)
+		seq_puts(m, "Unavailable\n");
+	else
+		seq_printf(m, "%llu\n", rr.val * r->mon_scale);
+
+out:
+	rdtgroup_kn_unlock(of->kn);
+	return ret;
+}
