block: drain queue before waiting for q_usage_counter becoming zero

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [block] drain queue before waiting for q_usage_counter becoming zero (Ming Lei) [1523022]
Rebuild_FUZZ: 94.49%
commit-author Ming Lei <ming.lei@redhat.com>
commit 454be724f6f99cc7e7bbf15067128be9868186c6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/454be724.failed

Now we track legacy requests with .q_usage_counter in commit 055f6e18e08f
("block: Make q_usage_counter also track legacy requests"), but that
commit never runs and drains legacy queue before waiting for this counter
becoming zero, then IO hang is caused in the test of pulling disk during IO.

This patch fixes the issue by draining requests before waiting for
q_usage_counter becoming zero, both Mauricio and chenxiang reported this
issue, and observed that it can be fixed by this patch.

Link: https://marc.info/?l=linux-block&m=151192424731797&w=2
Fixes: 055f6e18e08f("block: Make q_usage_counter also track legacy requests")
	Cc: Wen Xiong <wenxiong@us.ibm.com>
	Tested-by: "chenxiang (M)" <chenxiang66@hisilicon.com>
	Tested-by: Mauricio Faria de Oliveira <mauricfo@linux.vnet.ibm.com>
	Signed-off-by: Ming Lei <ming.lei@redhat.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 454be724f6f99cc7e7bbf15067128be9868186c6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-core.c
diff --cc block/blk-core.c
index 97f3c8ba20e7,3ba4326a63b5..000000000000
--- a/block/blk-core.c
+++ b/block/blk-core.c
@@@ -541,13 -695,7 +548,17 @@@ void blk_cleanup_queue(struct request_q
  	 * prevent that q->request_fn() gets invoked after draining finished.
  	 */
  	blk_freeze_queue(q);
++<<<<<<< HEAD
 +	if (!q->mq_ops) {
 +		spin_lock_irq(lock);
 +		__blk_drain_queue(q, true);
 +	} else {
 +		blk_mq_debugfs_unregister_mq(q);
 +		spin_lock_irq(lock);
 +	}
++=======
+ 	spin_lock_irq(lock);
++>>>>>>> 454be724f6f9 (block: drain queue before waiting for q_usage_counter becoming zero)
  	queue_flag_set(QUEUE_FLAG_DEAD, q);
  	spin_unlock_irq(lock);
  
* Unmerged path block/blk-core.c
diff --git a/block/blk-mq.c b/block/blk-mq.c
index d9bfe0c6bc0e..79dc921735ae 100644
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@ -119,6 +119,8 @@ void blk_freeze_queue(struct request_queue *q)
 	 * exported to drivers as the only user for unfreeze is blk_mq.
 	 */
 	blk_freeze_queue_start(q);
+	if (!q->mq_ops)
+		blk_drain_queue(q);
 	blk_mq_freeze_queue_wait(q);
 }
 
diff --git a/block/blk.h b/block/blk.h
index 4d1760d40372..5a561a99c4e3 100644
--- a/block/blk.h
+++ b/block/blk.h
@@ -310,4 +310,6 @@ static inline int blk_throtl_init(struct request_queue *q) { return 0; }
 static inline void blk_throtl_exit(struct request_queue *q) { }
 #endif /* CONFIG_BLK_DEV_THROTTLING */
 
+extern void blk_drain_queue(struct request_queue *q);
+
 #endif /* BLK_INTERNAL_H */
