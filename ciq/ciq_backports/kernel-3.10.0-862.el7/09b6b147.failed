qed: Provide auxiliary for getting free VF SB

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Mintz, Yuval <Yuval.Mintz@cavium.com>
commit 09b6b14749523e3660b72be2ed91b3c0b852f58f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/09b6b147.failed

IOV code is very intrusive in its manipulation of the status block
database.
Add a new auxiliary function to allow the PF to find an available unused
status block to configure for a specific VF's MSI-x vector.

	Signed-off-by: Yuval Mintz <Yuval.Mintz@cavium.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 09b6b14749523e3660b72be2ed91b3c0b852f58f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qed/qed_sriov.c
diff --cc drivers/net/ethernet/qlogic/qed/qed_sriov.c
index c231e788de76,cb9123b8c8fc..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_sriov.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_sriov.c
@@@ -868,15 -868,14 +868,22 @@@ static u8 qed_iov_alloc_vf_igu_sbs(stru
  				   struct qed_ptt *p_ptt,
  				   struct qed_vf_info *vf, u16 num_rx_queues)
  {
- 	struct qed_igu_block *igu_blocks;
- 	int qid = 0, igu_id = 0;
+ 	struct qed_igu_block *p_block;
+ 	struct cau_sb_entry sb_entry;
+ 	int qid = 0;
  	u32 val = 0;
  
++<<<<<<< HEAD
 +	igu_blocks = p_hwfn->hw_info.p_igu_info->igu_map.igu_blocks;
 +
 +	if (num_rx_queues > p_hwfn->hw_info.p_igu_info->free_blks)
 +		num_rx_queues = p_hwfn->hw_info.p_igu_info->free_blks;
 +	p_hwfn->hw_info.p_igu_info->free_blks -= num_rx_queues;
++=======
+ 	if (num_rx_queues > p_hwfn->hw_info.p_igu_info->usage.free_cnt_iov)
+ 		num_rx_queues = p_hwfn->hw_info.p_igu_info->usage.free_cnt_iov;
+ 	p_hwfn->hw_info.p_igu_info->usage.free_cnt_iov -= num_rx_queues;
++>>>>>>> 09b6b1474952 (qed: Provide auxiliary for getting free VF SB)
  
  	SET_FIELD(val, IGU_MAPPING_LINE_FUNCTION_NUMBER, vf->abs_vf_id);
  	SET_FIELD(val, IGU_MAPPING_LINE_VALID, 1);
diff --git a/drivers/net/ethernet/qlogic/qed/qed_int.c b/drivers/net/ethernet/qlogic/qed/qed_int.c
index 37b56d7fa1f8..232e222a49f4 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_int.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_int.c
@@ -2674,6 +2674,26 @@ void qed_int_sb_setup(struct qed_hwfn *p_hwfn,
 				    sb_info->igu_sb_id, 0, 0);
 }
 
+struct qed_igu_block *qed_get_igu_free_sb(struct qed_hwfn *p_hwfn, bool b_is_pf)
+{
+	struct qed_igu_block *p_block;
+	u16 igu_id;
+
+	for (igu_id = 0; igu_id < QED_MAPPING_MEMORY_SIZE(p_hwfn->cdev);
+	     igu_id++) {
+		p_block = &p_hwfn->hw_info.p_igu_info->entry[igu_id];
+
+		if (!(p_block->status & QED_IGU_STATUS_VALID) ||
+		    !(p_block->status & QED_IGU_STATUS_FREE))
+			continue;
+
+		if (!!(p_block->status & QED_IGU_STATUS_PF) == b_is_pf)
+			return p_block;
+	}
+
+	return NULL;
+}
+
 static u16 qed_get_pf_igu_sb_id(struct qed_hwfn *p_hwfn, u16 vector_id)
 {
 	struct qed_igu_block *p_block;
diff --git a/drivers/net/ethernet/qlogic/qed/qed_int.h b/drivers/net/ethernet/qlogic/qed/qed_int.h
index a8e48e14efef..173e8c705f76 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_int.h
+++ b/drivers/net/ethernet/qlogic/qed/qed_int.h
@@ -225,6 +225,17 @@ struct qed_igu_info {
 };
 
 /* TODO Names of function may change... */
+/**
+ * @brief return a pointer to an unused valid SB
+ *
+ * @param p_hwfn
+ * @param b_is_pf - true iff we want a SB belonging to a PF
+ *
+ * @return point to an igu_block, NULL if none is available
+ */
+struct qed_igu_block *qed_get_igu_free_sb(struct qed_hwfn *p_hwfn,
+					  bool b_is_pf);
+
 void qed_int_igu_init_pure_rt(struct qed_hwfn *p_hwfn,
 			      struct qed_ptt *p_ptt,
 			      bool b_set,
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_sriov.c
