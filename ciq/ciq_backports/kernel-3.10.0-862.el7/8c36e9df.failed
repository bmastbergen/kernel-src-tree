cifs: avoid unused variable and label

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Arnd Bergmann <arnd@arndb.de>
commit 8c36e9dfe7527665e286c3ac970c3fb327e6ab24
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8c36e9df.failed

The newly introduced cifs_clone_file_range() function produces
two harmless compile-time warnings:

cifsfs.c: In function 'cifs_clone_file_range':
cifsfs.c:963:1: warning: label 'out_unlock' defined but not used [-Wunused-label]
cifsfs.c:924:20: warning: unused variable 'src_tcon' [-Wunused-variable]

In both cases, removing the extraneous line avoids the warning.

	Signed-off-by: Arnd Bergmann <arnd@arndb.de>
Fixes: c6f2a1e2e5f8 ("vfs: pull btrfs clone API to vfs layer")
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 8c36e9dfe7527665e286c3ac970c3fb327e6ab24)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/cifsfs.c
diff --cc fs/cifs/cifsfs.c
index 5b65d4fc9e5d,fd3643451dd5..000000000000
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@@ -944,11 -914,62 +944,67 @@@ const struct inode_operations cifs_syml
  #endif
  };
  
++<<<<<<< HEAD
++=======
+ static int cifs_clone_file_range(struct file *src_file, loff_t off,
+ 		struct file *dst_file, loff_t destoff, u64 len)
+ {
+ 	struct inode *src_inode = file_inode(src_file);
+ 	struct inode *target_inode = file_inode(dst_file);
+ 	struct cifsFileInfo *smb_file_src = src_file->private_data;
+ 	struct cifsFileInfo *smb_file_target = dst_file->private_data;
+ 	struct cifs_tcon *target_tcon = tlink_tcon(smb_file_target->tlink);
+ 	unsigned int xid;
+ 	int rc;
+ 
+ 	cifs_dbg(FYI, "clone range\n");
+ 
+ 	xid = get_xid();
+ 
+ 	if (!src_file->private_data || !dst_file->private_data) {
+ 		rc = -EBADF;
+ 		cifs_dbg(VFS, "missing cifsFileInfo on copy range src file\n");
+ 		goto out;
+ 	}
+ 
+ 	/*
+ 	 * Note: cifs case is easier than btrfs since server responsible for
+ 	 * checks for proper open modes and file type and if it wants
+ 	 * server could even support copy of range where source = target
+ 	 */
+ 	lock_two_nondirectories(target_inode, src_inode);
+ 
+ 	if (len == 0)
+ 		len = src_inode->i_size - off;
+ 
+ 	cifs_dbg(FYI, "about to flush pages\n");
+ 	/* should we flush first and last page first */
+ 	truncate_inode_pages_range(&target_inode->i_data, destoff,
+ 				   PAGE_CACHE_ALIGN(destoff + len)-1);
+ 
+ 	if (target_tcon->ses->server->ops->duplicate_extents)
+ 		rc = target_tcon->ses->server->ops->duplicate_extents(xid,
+ 			smb_file_src, smb_file_target, off, len, destoff);
+ 	else
+ 		rc = -EOPNOTSUPP;
+ 
+ 	/* force revalidate of size and timestamps of target file now
+ 	   that target is updated on the server */
+ 	CIFS_I(target_inode)->time = 0;
+ 	/* although unlocking in the reverse order from locking is not
+ 	   strictly necessary here it is a little cleaner to be consistent */
+ 	unlock_two_nondirectories(src_inode, target_inode);
+ out:
+ 	free_xid(xid);
+ 	return rc;
+ }
+ 
++>>>>>>> 8c36e9dfe752 (cifs: avoid unused variable and label)
  const struct file_operations cifs_file_ops = {
 -	.read_iter = cifs_loose_read_iter,
 -	.write_iter = cifs_file_write_iter,
 +	.read = do_sync_read,
 +	.write = do_sync_write,
 +	.aio_read = cifs_loose_read,
 +	.aio_write = cifs_file_aio_write,
  	.open = cifs_open,
  	.release = cifs_close,
  	.lock = cifs_lock,
* Unmerged path fs/cifs/cifsfs.c
