xfs: collapse single use static functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit 51ce9d000c0a80bddf9a93a4232283cc9a4564c0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/51ce9d00.failed

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit 51ce9d000c0a80bddf9a93a4232283cc9a4564c0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_trans_extfree.c
#	fs/xfs/xfs_trans_rmap.c
diff --cc fs/xfs/xfs_trans_extfree.c
index a9f34ee52ab4,7d1e84c1b848..000000000000
--- a/fs/xfs/xfs_trans_extfree.c
+++ b/fs/xfs/xfs_trans_extfree.c
@@@ -30,61 -30,6 +30,64 @@@
  #include "xfs_bmap.h"
  
  /*
++<<<<<<< HEAD
 + * This routine is called to allocate an "extent free intention"
 + * log item that will hold nextents worth of extents.  The
 + * caller must use all nextents extents, because we are not
 + * flexible about this at all.
 + */
 +struct xfs_efi_log_item *
 +xfs_trans_get_efi(struct xfs_trans	*tp,
 +		  uint			nextents)
 +{
 +	struct xfs_efi_log_item		*efip;
 +
 +	ASSERT(tp != NULL);
 +	ASSERT(nextents > 0);
 +
 +	efip = xfs_efi_init(tp->t_mountp, nextents);
 +	ASSERT(efip != NULL);
 +
 +	/*
 +	 * Get a log_item_desc to point at the new item.
 +	 */
 +	xfs_trans_add_item(tp, &efip->efi_item);
 +	return efip;
 +}
 +
 +/*
 + * This routine is called to indicate that the described
 + * extent is to be logged as needing to be freed.  It should
 + * be called once for each extent to be freed.
 + */
 +void
 +xfs_trans_log_efi_extent(struct xfs_trans		*tp,
 +			 struct xfs_efi_log_item	*efip,
 +			 xfs_fsblock_t			start_block,
 +			 xfs_extlen_t			ext_len)
 +{
 +	uint						next_extent;
 +	struct xfs_extent				*extp;
 +
 +	tp->t_flags |= XFS_TRANS_DIRTY;
 +	efip->efi_item.li_desc->lid_flags |= XFS_LID_DIRTY;
 +
 +	/*
 +	 * atomic_inc_return gives us the value after the increment;
 +	 * we want to use it as an array index so we need to subtract 1 from
 +	 * it.
 +	 */
 +	next_extent = atomic_inc_return(&efip->efi_next_extent) - 1;
 +	ASSERT(next_extent < efip->efi_format.efi_nextents);
 +	extp = &(efip->efi_format.efi_extents[next_extent]);
 +	extp->ext_start = start_block;
 +	extp->ext_len = ext_len;
 +}
 +
 +
 +/*
++=======
++>>>>>>> 51ce9d000c0a (xfs: collapse single use static functions)
   * This routine is called to allocate an "extent free done"
   * log item that will hold nextents worth of extents.  The
   * caller must use all nextents extents, because we are not
@@@ -181,11 -139,26 +196,34 @@@ xfs_extent_free_log_item
  	void				*intent,
  	struct list_head		*item)
  {
++<<<<<<< HEAD
 +	struct xfs_bmap_free_item	*free;
 +
 +	free = container_of(item, struct xfs_bmap_free_item, xbfi_list);
 +	xfs_trans_log_efi_extent(tp, intent, free->xbfi_startblock,
 +			free->xbfi_blockcount);
++=======
+ 	struct xfs_efi_log_item		*efip = intent;
+ 	struct xfs_extent_free_item	*free;
+ 	uint				next_extent;
+ 	struct xfs_extent		*extp;
+ 
+ 	free = container_of(item, struct xfs_extent_free_item, xefi_list);
+ 
+ 	tp->t_flags |= XFS_TRANS_DIRTY;
+ 	efip->efi_item.li_desc->lid_flags |= XFS_LID_DIRTY;
+ 
+ 	/*
+ 	 * atomic_inc_return gives us the value after the increment;
+ 	 * we want to use it as an array index so we need to subtract 1 from
+ 	 * it.
+ 	 */
+ 	next_extent = atomic_inc_return(&efip->efi_next_extent) - 1;
+ 	ASSERT(next_extent < efip->efi_format.efi_nextents);
+ 	extp = &efip->efi_format.efi_extents[next_extent];
+ 	extp->ext_start = free->xefi_startblock;
+ 	extp->ext_len = free->xefi_blockcount;
++>>>>>>> 51ce9d000c0a (xfs: collapse single use static functions)
  }
  
  /* Get an EFD so we can process all the free extents. */
* Unmerged path fs/xfs/xfs_trans_rmap.c
* Unmerged path fs/xfs/xfs_trans_extfree.c
* Unmerged path fs/xfs/xfs_trans_rmap.c
