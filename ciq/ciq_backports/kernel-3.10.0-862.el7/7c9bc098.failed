ima: check signature enforcement against cmdline param instead of CONFIG

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Bruno E. O. Meneguele <brdeoliv@redhat.com>
commit 7c9bc0983f890ed9782e755a0e070930cd979333
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/7c9bc098.failed

When the user requests MODULE_CHECK policy and its kernel is compiled
with CONFIG_MODULE_SIG_FORCE not set, all modules would not load, just
those loaded in initram time. One option the user would have would be
set a kernel cmdline param (module.sig_enforce) to true, but the IMA
module check code doesn't rely on this value, it checks just
CONFIG_MODULE_SIG_FORCE.

This patch solves this problem checking for the exported value of
module.sig_enforce cmdline param intead of CONFIG_MODULE_SIG_FORCE,
which holds the effective value (CONFIG || param).

	Signed-off-by: Bruno E. O. Meneguele <brdeoliv@redhat.com>
	Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
(cherry picked from commit 7c9bc0983f890ed9782e755a0e070930cd979333)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/integrity/ima/ima_main.c
diff --cc security/integrity/ima/ima_main.c
index fef94c88960b,770654694efc..000000000000
--- a/security/integrity/ima/ima_main.c
+++ b/security/integrity/ima/ima_main.c
@@@ -271,25 -328,99 +271,57 @@@ int ima_file_check(struct file *file, i
  EXPORT_SYMBOL_GPL(ima_file_check);
  
  /**
 - * ima_post_path_mknod - mark as a new inode
 - * @dentry: newly created dentry
 + * ima_module_check - based on policy, collect/store/appraise measurement.
 + * @file: pointer to the file to be measured/appraised
 + *
 + * Measure/appraise kernel modules based on policy.
   *
 - * Mark files created via the mknodat syscall as new, so that the
 - * file data can be written later.
 + * On success return 0.  On integrity appraisal error, assuming the file
 + * is in policy and IMA-appraisal is in enforcing mode, return -EACCES.
   */
 -void ima_post_path_mknod(struct dentry *dentry)
 +int ima_module_check(struct file *file)
  {
++<<<<<<< HEAD
 +	if (!file) {
 +#ifndef CONFIG_MODULE_SIG_FORCE
 +		if ((ima_appraise & IMA_APPRAISE_MODULES) &&
++=======
+ 	struct integrity_iint_cache *iint;
+ 	struct inode *inode = dentry->d_inode;
+ 	int must_appraise;
+ 
+ 	must_appraise = ima_must_appraise(inode, MAY_ACCESS, FILE_CHECK);
+ 	if (!must_appraise)
+ 		return;
+ 
+ 	iint = integrity_inode_get(inode);
+ 	if (iint)
+ 		iint->flags |= IMA_NEW_FILE;
+ }
+ 
+ /**
+  * ima_read_file - pre-measure/appraise hook decision based on policy
+  * @file: pointer to the file to be measured/appraised/audit
+  * @read_id: caller identifier
+  *
+  * Permit reading a file based on policy. The policy rules are written
+  * in terms of the policy identifier.  Appraising the integrity of
+  * a file requires a file descriptor.
+  *
+  * For permission return 0, otherwise return -EACCES.
+  */
+ int ima_read_file(struct file *file, enum kernel_read_file_id read_id)
+ {
+ 	bool sig_enforce = is_module_sig_enforced();
+ 
+ 	if (!file && read_id == READING_MODULE) {
+ 		if (!sig_enforce && (ima_appraise & IMA_APPRAISE_MODULES) &&
++>>>>>>> 7c9bc0983f89 (ima: check signature enforcement against cmdline param instead of CONFIG)
  		    (ima_appraise & IMA_APPRAISE_ENFORCE))
  			return -EACCES;	/* INTEGRITY_UNKNOWN */
- #endif
  		return 0;	/* We rely on module signature checking */
  	}
 -	return 0;
 -}
 -
 -static int read_idmap[READING_MAX_ID] = {
 -	[READING_FIRMWARE] = FIRMWARE_CHECK,
 -	[READING_MODULE] = MODULE_CHECK,
 -	[READING_KEXEC_IMAGE] = KEXEC_KERNEL_CHECK,
 -	[READING_KEXEC_INITRAMFS] = KEXEC_INITRAMFS_CHECK,
 -	[READING_POLICY] = POLICY_CHECK
 -};
 -
 -/**
 - * ima_post_read_file - in memory collect/appraise/audit measurement
 - * @file: pointer to the file to be measured/appraised/audit
 - * @buf: pointer to in memory file contents
 - * @size: size of in memory file contents
 - * @read_id: caller identifier
 - *
 - * Measure/appraise/audit in memory file based on policy.  Policy rules
 - * are written in terms of a policy identifier.
 - *
 - * On success return 0.  On integrity appraisal error, assuming the file
 - * is in policy and IMA-appraisal is in enforcing mode, return -EACCES.
 - */
 -int ima_post_read_file(struct file *file, void *buf, loff_t size,
 -		       enum kernel_read_file_id read_id)
 -{
 -	enum ima_hooks func;
 -
 -	if (!file && read_id == READING_FIRMWARE) {
 -		if ((ima_appraise & IMA_APPRAISE_FIRMWARE) &&
 -		    (ima_appraise & IMA_APPRAISE_ENFORCE))
 -			return -EACCES;	/* INTEGRITY_UNKNOWN */
 -		return 0;
 -	}
 -
 -	if (!file && read_id == READING_MODULE) /* MODULE_SIG_FORCE enabled */
 -		return 0;
 -
 -	/* permit signed certs */
 -	if (!file && read_id == READING_X509_CERTIFICATE)
 -		return 0;
 -
 -	if (!file || !buf || size == 0) { /* should never happen */
 -		if (ima_appraise & IMA_APPRAISE_ENFORCE)
 -			return -EACCES;
 -		return 0;
 -	}
 -
 -	func = read_idmap[read_id] ?: FILE_CHECK;
 -	return process_measurement(file, buf, size, MAY_READ, func, 0);
 +	return process_measurement(file, NULL, MAY_EXEC, MODULE_CHECK);
  }
  
  static int __init init_ima(void)
* Unmerged path security/integrity/ima/ima_main.c
