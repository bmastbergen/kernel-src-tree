qed: No need to reset SBs on IOV init

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Mintz, Yuval <Yuval.Mintz@cavium.com>
commit 1ee240e31d4c0a5fd37ebaf064ca1f6cb6adcb6f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1ee240e3.failed

Since we're resetting the IGU CAM each time we initialize the PF
device, there's no need to reset the VF SBs again when initializing
IOV.

	Signed-off-by: Yuval Mintz <Yuval.Mintz@cavium.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1ee240e31d4c0a5fd37ebaf064ca1f6cb6adcb6f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qed/qed_sriov.c
diff --cc drivers/net/ethernet/qlogic/qed/qed_sriov.c
index c231e788de76,5ae8827534f8..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_sriov.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_sriov.c
@@@ -378,33 -378,6 +378,36 @@@ static int qed_iov_pci_cfg_info(struct 
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void qed_iov_clear_vf_igu_blocks(struct qed_hwfn *p_hwfn,
 +					struct qed_ptt *p_ptt)
 +{
 +	struct qed_igu_block *p_sb;
 +	u16 sb_id;
 +	u32 val;
 +
 +	if (!p_hwfn->hw_info.p_igu_info) {
 +		DP_ERR(p_hwfn,
 +		       "qed_iov_clear_vf_igu_blocks IGU Info not initialized\n");
 +		return;
 +	}
 +
 +	for (sb_id = 0; sb_id < QED_MAPPING_MEMORY_SIZE(p_hwfn->cdev);
 +	     sb_id++) {
 +		p_sb = &p_hwfn->hw_info.p_igu_info->igu_map.igu_blocks[sb_id];
 +		if ((p_sb->status & QED_IGU_STATUS_FREE) &&
 +		    !(p_sb->status & QED_IGU_STATUS_PF)) {
 +			val = qed_rd(p_hwfn, p_ptt,
 +				     IGU_REG_MAPPING_MEMORY + sb_id * 4);
 +			SET_FIELD(val, IGU_MAPPING_LINE_VALID, 0);
 +			qed_wr(p_hwfn, p_ptt,
 +			       IGU_REG_MAPPING_MEMORY + 4 * sb_id, val);
 +		}
 +	}
 +}
 +
++=======
++>>>>>>> 1ee240e31d4c (qed: No need to reset SBs on IOV init)
  static void qed_iov_setup_vfdb(struct qed_hwfn *p_hwfn)
  {
  	struct qed_hw_sriov_info *p_iov = p_hwfn->cdev->p_iov_info;
diff --git a/drivers/net/ethernet/qlogic/qed/qed_dev.c b/drivers/net/ethernet/qlogic/qed/qed_dev.c
index 1b5a3d62b9f3..aad59b770d62 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_dev.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_dev.c
@@ -1030,7 +1030,7 @@ void qed_resc_setup(struct qed_dev *cdev)
 
 		qed_int_setup(p_hwfn, p_hwfn->p_main_ptt);
 
-		qed_iov_setup(p_hwfn, p_hwfn->p_main_ptt);
+		qed_iov_setup(p_hwfn);
 #ifdef CONFIG_QED_LL2
 		if (p_hwfn->using_ll2)
 			qed_ll2_setup(p_hwfn);
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_sriov.c
diff --git a/drivers/net/ethernet/qlogic/qed/qed_sriov.h b/drivers/net/ethernet/qlogic/qed/qed_sriov.h
index bcff13a4692b..ba67f6a8b1e4 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_sriov.h
+++ b/drivers/net/ethernet/qlogic/qed/qed_sriov.h
@@ -303,9 +303,8 @@ int qed_iov_alloc(struct qed_hwfn *p_hwfn);
  * @brief qed_iov_setup - setup sriov related resources
  *
  * @param p_hwfn
- * @param p_ptt
  */
-void qed_iov_setup(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt);
+void qed_iov_setup(struct qed_hwfn *p_hwfn);
 
 /**
  * @brief qed_iov_free - free sriov related resources
@@ -378,7 +377,7 @@ static inline int qed_iov_alloc(struct qed_hwfn *p_hwfn)
 	return 0;
 }
 
-static inline void qed_iov_setup(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)
+static inline void qed_iov_setup(struct qed_hwfn *p_hwfn)
 {
 }
 
