net_sched: acquire RTNL in tc_action_net_exit()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Cong Wang <xiyou.wangcong@gmail.com>
commit a159d3c4b8291998c018f0dbddd4678315264a1e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a159d3c4.failed

I forgot to acquire RTNL in tc_action_net_exit()
which leads that action ops->cleanup() is not always
called with RTNL. This usually is not a big deal because
this function is called after all netns refcnt are gone,
but given RTNL protects more than just actions, add it
for safety and consistency.

Also add an assertion to catch other potential bugs.

Fixes: ddf97ccdd7cb ("net_sched: add network namespace support for tc actions")
	Reported-by: Lucas Bates <lucasb@mojatatu.com>
	Tested-by: Lucas Bates <lucasb@mojatatu.com>
	Cc: Jamal Hadi Salim <jhs@mojatatu.com>
	Cc: Jiri Pirko <jiri@resnulli.us>
	Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a159d3c4b8291998c018f0dbddd4678315264a1e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/act_api.h
diff --cc include/net/act_api.h
index 7eba1aba336b,5072446d5f06..000000000000
--- a/include/net/act_api.h
+++ b/include/net/act_api.h
@@@ -120,32 -97,68 +120,68 @@@ struct tc_action_ops 
  			   struct net_device **mirred_dev);
  };
  
 -struct tc_action_net {
 -	struct tcf_idrinfo *idrinfo;
 -	const struct tc_action_ops *ops;
 -};
 +int tcf_hash_search(struct tc_action *a, u32 index);
 +u32 tcf_hash_new_index(struct tcf_hashinfo *hinfo);
 +int tcf_hash_check(u32 index, struct tc_action *a, int bind);
 +int tcf_hash_create(u32 index, struct nlattr *est, struct tc_action *a,
 +		    int size, int bind, bool cpustats);
 +void tcf_hash_cleanup(struct tc_action *a, struct nlattr *est);
 +void tcf_hash_insert(struct tc_action *a);
  
 -static inline
 -int tc_action_net_init(struct tc_action_net *tn,
 -		       const struct tc_action_ops *ops)
 -{
 -	int err = 0;
 +int __tcf_hash_release(struct tc_action *a, bool bind, bool strict);
  
 -	tn->idrinfo = kmalloc(sizeof(*tn->idrinfo), GFP_KERNEL);
 -	if (!tn->idrinfo)
 -		return -ENOMEM;
 -	tn->ops = ops;
 -	spin_lock_init(&tn->idrinfo->lock);
 -	idr_init(&tn->idrinfo->action_idr);
 -	return err;
 +static inline int tcf_hash_release(struct tc_action *a, bool bind)
 +{
 +	return __tcf_hash_release(a, bind, false);
  }
  
++<<<<<<< HEAD
 +int tcf_register_action(struct tc_action_ops *a, unsigned int mask);
 +int tcf_unregister_action(struct tc_action_ops *a);
++=======
+ void tcf_idrinfo_destroy(const struct tc_action_ops *ops,
+ 			 struct tcf_idrinfo *idrinfo);
+ 
+ static inline void tc_action_net_exit(struct tc_action_net *tn)
+ {
+ 	rtnl_lock();
+ 	tcf_idrinfo_destroy(tn->ops, tn->idrinfo);
+ 	rtnl_unlock();
+ 	kfree(tn->idrinfo);
+ }
+ 
+ int tcf_generic_walker(struct tc_action_net *tn, struct sk_buff *skb,
+ 		       struct netlink_callback *cb, int type,
+ 		       const struct tc_action_ops *ops);
+ int tcf_idr_search(struct tc_action_net *tn, struct tc_action **a, u32 index);
+ bool tcf_idr_check(struct tc_action_net *tn, u32 index, struct tc_action **a,
+ 		    int bind);
+ int tcf_idr_create(struct tc_action_net *tn, u32 index, struct nlattr *est,
+ 		   struct tc_action **a, const struct tc_action_ops *ops,
+ 		   int bind, bool cpustats);
+ void tcf_idr_cleanup(struct tc_action *a, struct nlattr *est);
+ void tcf_idr_insert(struct tc_action_net *tn, struct tc_action *a);
+ 
+ int __tcf_idr_release(struct tc_action *a, bool bind, bool strict);
+ 
+ static inline int tcf_idr_release(struct tc_action *a, bool bind)
+ {
+ 	return __tcf_idr_release(a, bind, false);
+ }
+ 
+ int tcf_register_action(struct tc_action_ops *a, struct pernet_operations *ops);
+ int tcf_unregister_action(struct tc_action_ops *a,
+ 			  struct pernet_operations *ops);
++>>>>>>> a159d3c4b829 (net_sched: acquire RTNL in tc_action_net_exit())
  int tcf_action_destroy(struct list_head *actions, int bind);
 -int tcf_action_exec(struct sk_buff *skb, struct tc_action **actions,
 -		    int nr_actions, struct tcf_result *res);
 -int tcf_action_init(struct net *net, struct tcf_proto *tp, struct nlattr *nla,
 -		    struct nlattr *est, char *name, int ovr, int bind,
 -		    struct list_head *actions);
 -struct tc_action *tcf_action_init_1(struct net *net, struct tcf_proto *tp,
 -				    struct nlattr *nla, struct nlattr *est,
 -				    char *name, int ovr, int bind);
 +int tcf_action_exec(struct sk_buff *skb, const struct list_head *actions,
 +		    struct tcf_result *res);
 +int tcf_action_init(struct net *net, struct nlattr *nla,
 +				  struct nlattr *est, char *n, int ovr,
 +				  int bind, struct list_head *);
 +struct tc_action *tcf_action_init_1(struct net *net, struct nlattr *nla,
 +				    struct nlattr *est, char *n, int ovr,
 +				    int bind);
  int tcf_action_dump(struct sk_buff *skb, struct list_head *, int, int);
  int tcf_action_dump_old(struct sk_buff *skb, struct tc_action *a, int, int);
  int tcf_action_dump_1(struct sk_buff *skb, struct tc_action *a, int, int);
* Unmerged path include/net/act_api.h
diff --git a/net/sched/act_api.c b/net/sched/act_api.c
index f6d266c05d33..5d75af417614 100644
--- a/net/sched/act_api.c
+++ b/net/sched/act_api.c
@@ -65,6 +65,8 @@ int __tcf_hash_release(struct tc_action *a, bool bind, bool strict)
 	struct tcf_common *p = a->priv;
 	int ret = 0;
 
+	ASSERT_RTNL();
+
 	if (p) {
 		if (bind)
 			p->tcfc_bindcnt--;
