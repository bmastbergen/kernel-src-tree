ACPI / osi: Collect _OSI handling into one single file

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Lv Zheng <lv.zheng@intel.com>
commit e5f660ebef68e3ed1a988ad06ba23562153cee5c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e5f660eb.failed

_OSI handling code grows giant and it's time to move them into one file.

This patch collects all _OSI handling code into one single file.
So that we only have the following functions to be used externally:

 early_acpi_osi_init(): Used by DMI detections;
 acpi_osi_init(): Used to initialize OSI command line settings and install
                  Linux specific _OSI handler;
 acpi_osi_setup(): The API that should be used by the external quirks.
 acpi_osi_is_win8(): The API is used by the external drivers to determine
                     if BIOS supports Win8.

CONFIG_DMI is not useful as stub dmi_check_system() can make everything
stub because of strip.

No functional changes.

	Tested-by: Lukas Wunner <lukas@wunner.de>
	Tested-by: Chen Yu <yu.c.chen@intel.com>
	Signed-off-by: Lv Zheng <lv.zheng@intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit e5f660ebef68e3ed1a988ad06ba23562153cee5c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/blacklist.c
#	drivers/acpi/internal.h
#	drivers/acpi/osl.c
#	include/linux/acpi.h
diff --cc drivers/acpi/blacklist.c
index 67d8ac3b362a,bdc67bad61a7..000000000000
--- a/drivers/acpi/blacklist.c
+++ b/drivers/acpi/blacklist.c
@@@ -138,200 -134,33 +139,230 @@@ int __init acpi_blacklisted(void
  	return blacklisted;
  }
  #ifdef CONFIG_DMI
++<<<<<<< HEAD
 +static int __init dmi_enable_osi_linux(const struct dmi_system_id *d)
 +{
 +	acpi_dmi_osi_linux(1, d);	/* enable */
 +	return 0;
 +}
 +static int __init dmi_disable_osi_vista(const struct dmi_system_id *d)
 +{
 +	printk(KERN_NOTICE PREFIX "DMI detected: %s\n", d->ident);
 +	acpi_osi_setup("!Windows 2006");
 +	acpi_osi_setup("!Windows 2006 SP1");
 +	acpi_osi_setup("!Windows 2006 SP2");
 +	return 0;
 +}
 +static int __init dmi_disable_osi_win7(const struct dmi_system_id *d)
 +{
 +	printk(KERN_NOTICE PREFIX "DMI detected: %s\n", d->ident);
 +	acpi_osi_setup("!Windows 2009");
 +	return 0;
 +}
 +static int __init dmi_disable_osi_win8(const struct dmi_system_id *d)
 +{
 +	printk(KERN_NOTICE PREFIX "DMI detected: %s\n", d->ident);
 +	acpi_osi_setup("!Windows 2012");
 +	return 0;
 +}
 +
 +static struct dmi_system_id acpi_osi_dmi_table[] __initdata = {
 +	{
 +	.callback = dmi_disable_osi_vista,
 +	.ident = "Fujitsu Siemens",
 +	.matches = {
 +		     DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU SIEMENS"),
 +		     DMI_MATCH(DMI_PRODUCT_NAME, "ESPRIMO Mobile V5505"),
 +		},
 +	},
 +	{
 +	/*
 +	 * There have a NVIF method in MSI GX723 DSDT need call by Nvidia
 +	 * driver (e.g. nouveau) when user press brightness hotkey.
 +	 * Currently, nouveau driver didn't do the job and it causes there
 +	 * have a infinite while loop in DSDT when user press hotkey.
 +	 * We add MSI GX723's dmi information to this table for workaround
 +	 * this issue.
 +	 * Will remove MSI GX723 from the table after nouveau grows support.
 +	 */
 +	.callback = dmi_disable_osi_vista,
 +	.ident = "MSI GX723",
 +	.matches = {
 +		     DMI_MATCH(DMI_SYS_VENDOR, "Micro-Star International"),
 +		     DMI_MATCH(DMI_PRODUCT_NAME, "GX723"),
 +		},
 +	},
 +	{
 +	.callback = dmi_disable_osi_vista,
 +	.ident = "Sony VGN-NS10J_S",
 +	.matches = {
 +		     DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
 +		     DMI_MATCH(DMI_PRODUCT_NAME, "VGN-NS10J_S"),
 +		},
 +	},
 +	{
 +	.callback = dmi_disable_osi_vista,
 +	.ident = "Sony VGN-SR290J",
 +	.matches = {
 +		     DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
 +		     DMI_MATCH(DMI_PRODUCT_NAME, "VGN-SR290J"),
 +		},
 +	},
 +	{
 +	.callback = dmi_disable_osi_vista,
 +	.ident = "VGN-NS50B_L",
 +	.matches = {
 +		     DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
 +		     DMI_MATCH(DMI_PRODUCT_NAME, "VGN-NS50B_L"),
 +		},
 +	},
 +	{
 +	.callback = dmi_disable_osi_vista,
 +	.ident = "Toshiba Satellite L355",
 +	.matches = {
 +		     DMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),
 +		     DMI_MATCH(DMI_PRODUCT_VERSION, "Satellite L355"),
 +		},
 +	},
 +	{
 +	.callback = dmi_disable_osi_win7,
 +	.ident = "ASUS K50IJ",
 +	.matches = {
 +		     DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK Computer Inc."),
 +		     DMI_MATCH(DMI_PRODUCT_NAME, "K50IJ"),
 +		},
 +	},
 +	{
 +	.callback = dmi_disable_osi_vista,
 +	.ident = "Toshiba P305D",
 +	.matches = {
 +		     DMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),
 +		     DMI_MATCH(DMI_PRODUCT_NAME, "Satellite P305D"),
 +		},
 +	},
 +	{
 +	.callback = dmi_disable_osi_vista,
 +	.ident = "Toshiba NB100",
 +	.matches = {
 +		     DMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),
 +		     DMI_MATCH(DMI_PRODUCT_NAME, "NB100"),
 +		},
 +	},
 +
 +	/*
 +	 * These machines will power on immediately after shutdown when
 +	 * reporting the Windows 2012 OSI.
 +	 */
 +	{
 +	.callback = dmi_disable_osi_win8,
 +	.ident = "Dell Inspiron 7737",
 +	.matches = {
 +		    DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 +		    DMI_MATCH(DMI_PRODUCT_NAME, "Inspiron 7737"),
 +		},
 +	},
 +
 +	/*
 +	 * BIOS invocation of _OSI(Linux) is almost always a BIOS bug.
 +	 * Linux ignores it, except for the machines enumerated below.
 +	 */
 +
 +	/*
 +	 * Lenovo has a mix of systems OSI(Linux) situations
 +	 * and thus we can not wildcard the vendor.
 +	 *
 +	 * _OSI(Linux) helps sound
 +	 * DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad R61"),
 +	 * DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad T61"),
 +	 * T400, T500
 +	 * _OSI(Linux) has Linux specific hooks
 +	 * DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad X61"),
 +	 * _OSI(Linux) is a NOP:
 +	 * DMI_MATCH(DMI_PRODUCT_VERSION, "3000 N100"),
 +	 * DMI_MATCH(DMI_PRODUCT_VERSION, "LENOVO3000 V100"),
 +	 */
 +	{
 +	.callback = dmi_enable_osi_linux,
 +	.ident = "Lenovo ThinkPad R61",
 +	.matches = {
 +		     DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
 +		     DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad R61"),
 +		},
 +	},
 +	{
 +	.callback = dmi_enable_osi_linux,
 +	.ident = "Lenovo ThinkPad T61",
 +	.matches = {
 +		     DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
 +		     DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad T61"),
 +		},
 +	},
 +	{
 +	.callback = dmi_enable_osi_linux,
 +	.ident = "Lenovo ThinkPad X61",
 +	.matches = {
 +		     DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
 +		     DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad X61"),
 +		},
 +	},
 +	{
 +	.callback = dmi_enable_osi_linux,
 +	.ident = "Lenovo ThinkPad T400",
 +	.matches = {
 +		     DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
 +		     DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad T400"),
 +		},
 +	},
 +	{
 +	.callback = dmi_enable_osi_linux,
 +	.ident = "Lenovo ThinkPad T500",
 +	.matches = {
 +		     DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
 +		     DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad T500"),
 +		},
 +	},
 +	/*
 +	 * Without this this EEEpc exports a non working WMI interface, with
 +	 * this it exports a working "good old" eeepc_laptop interface, fixing
 +	 * both brightness control, and rfkill not working.
 +	 */
 +	{
 +	.callback = dmi_enable_osi_linux,
 +	.ident = "Asus EEE PC 1015PX",
 +	.matches = {
 +		     DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK Computer INC."),
 +		     DMI_MATCH(DMI_PRODUCT_NAME, "1015PX"),
 +		},
 +	},
++=======
+ #ifdef CONFIG_ACPI_REV_OVERRIDE_POSSIBLE
+ static int __init dmi_enable_rev_override(const struct dmi_system_id *d)
+ {
+ 	printk(KERN_NOTICE PREFIX "DMI detected: %s (force ACPI _REV to 5)\n",
+ 	       d->ident);
+ 	acpi_rev_override_setup(NULL);
+ 	return 0;
+ }
+ #endif
+ 
+ static struct dmi_system_id acpi_rev_dmi_table[] __initdata = {
+ #ifdef CONFIG_ACPI_REV_OVERRIDE_POSSIBLE
+ 	/*
+ 	 * DELL XPS 13 (2015) switches sound between HDA and I2S
+ 	 * depending on the ACPI _REV callback. If userspace supports
+ 	 * I2S sufficiently (or if you do not care about sound), you
+ 	 * can safely disable this quirk.
+ 	 */
+ 	{
+ 	 .callback = dmi_enable_rev_override,
+ 	 .ident = "DELL XPS 13 (2015)",
+ 	 .matches = {
+ 		      DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
+ 		      DMI_MATCH(DMI_PRODUCT_NAME, "XPS 13 9343"),
+ 		},
+ 	},
+ #endif
++>>>>>>> e5f660ebef68 (ACPI / osi: Collect _OSI handling into one single file)
  	{}
  };
  
diff --cc drivers/acpi/internal.h
index 89492f3bf8ce,a8780a2e1975..000000000000
--- a/drivers/acpi/internal.h
+++ b/drivers/acpi/internal.h
@@@ -23,8 -20,11 +23,14 @@@
  
  #define PREFIX "ACPI: "
  
++<<<<<<< HEAD
++=======
+ int early_acpi_osi_init(void);
+ int acpi_osi_init(void);
+ void acpi_initrd_initialize_tables(void);
++>>>>>>> e5f660ebef68 (ACPI / osi: Collect _OSI handling into one single file)
  acpi_status acpi_os_initialize1(void);
 -void init_acpi_device_notify(void);
 +int init_acpi_device_notify(void);
  int acpi_scan_init(void);
  void acpi_pci_root_init(void);
  void acpi_pci_link_init(void);
diff --cc drivers/acpi/osl.c
index 167afd5f464f,29af6b40c93f..000000000000
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@@ -104,61 -96,6 +104,64 @@@ struct acpi_ioremap 
  static LIST_HEAD(acpi_ioremaps);
  static DEFINE_MUTEX(acpi_ioremap_lock);
  
++<<<<<<< HEAD
 +static void __init acpi_osi_setup_late(void);
 +
 +/*
 + * The story of _OSI(Linux)
 + *
 + * From pre-history through Linux-2.6.22,
 + * Linux responded TRUE upon a BIOS OSI(Linux) query.
 + *
 + * Unfortunately, reference BIOS writers got wind of this
 + * and put OSI(Linux) in their example code, quickly exposing
 + * this string as ill-conceived and opening the door to
 + * an un-bounded number of BIOS incompatibilities.
 + *
 + * For example, OSI(Linux) was used on resume to re-POST a
 + * video card on one system, because Linux at that time
 + * could not do a speedy restore in its native driver.
 + * But then upon gaining quick native restore capability,
 + * Linux has no way to tell the BIOS to skip the time-consuming
 + * POST -- putting Linux at a permanent performance disadvantage.
 + * On another system, the BIOS writer used OSI(Linux)
 + * to infer native OS support for IPMI!  On other systems,
 + * OSI(Linux) simply got in the way of Linux claiming to
 + * be compatible with other operating systems, exposing
 + * BIOS issues such as skipped device initialization.
 + *
 + * So "Linux" turned out to be a really poor chose of
 + * OSI string, and from Linux-2.6.23 onward we respond FALSE.
 + *
 + * BIOS writers should NOT query _OSI(Linux) on future systems.
 + * Linux will complain on the console when it sees it, and return FALSE.
 + * To get Linux to return TRUE for your system  will require
 + * a kernel source update to add a DMI entry,
 + * or boot with "acpi_osi=Linux"
 + */
 +
 +static struct osi_linux {
 +	unsigned int	enable:1;
 +	unsigned int	dmi:1;
 +	unsigned int	cmdline:1;
 +} osi_linux = {0, 0, 0};
 +
 +static u32 acpi_osi_handler(acpi_string interface, u32 supported)
 +{
 +	if (!strcmp("Linux", interface)) {
 +
 +		printk_once(KERN_NOTICE FW_BUG PREFIX
 +			"BIOS _OSI(Linux) query %s%s\n",
 +			osi_linux.enable ? "honored" : "ignored",
 +			osi_linux.cmdline ? " via cmdline" :
 +			osi_linux.dmi ? " via DMI" : "");
 +	}
 +
 +	return supported;
 +}
 +
++=======
++>>>>>>> e5f660ebef68 (ACPI / osi: Collect _OSI handling into one single file)
  static void __init acpi_request_region (struct acpi_generic_address *gas,
  	unsigned int length, char *desc)
  {
@@@ -1373,144 -1651,16 +1376,154 @@@ static int __init acpi_os_name_setup(ch
  
  __setup("acpi_os_name=", acpi_os_name_setup);
  
++<<<<<<< HEAD
 +#define	OSI_STRING_LENGTH_MAX 64	/* arbitrary */
 +#define	OSI_STRING_ENTRIES_MAX 16	/* arbitrary */
 +
 +struct osi_setup_entry {
 +	char string[OSI_STRING_LENGTH_MAX];
 +	bool enable;
 +};
 +
 +static struct osi_setup_entry __initdata
 +		osi_setup_entries[OSI_STRING_ENTRIES_MAX] = {
 +	{"Module Device", true},
 +	{"Processor Device", true},
 +	{"3.0 _SCP Extensions", true},
 +	{"Processor Aggregator Device", true},
 +};
 +
 +void __init acpi_osi_setup(char *str)
 +{
 +	struct osi_setup_entry *osi;
 +	bool enable = true;
 +	int i;
 +
 +	if (!acpi_gbl_create_osi_method)
 +		return;
 +
 +	if (str == NULL || *str == '\0') {
 +		printk(KERN_INFO PREFIX "_OSI method disabled\n");
 +		acpi_gbl_create_osi_method = FALSE;
 +		return;
 +	}
 +
 +	if (*str == '!') {
 +		str++;
 +		enable = false;
 +	}
 +
 +	for (i = 0; i < OSI_STRING_ENTRIES_MAX; i++) {
 +		osi = &osi_setup_entries[i];
 +		if (!strcmp(osi->string, str)) {
 +			osi->enable = enable;
 +			break;
 +		} else if (osi->string[0] == '\0') {
 +			osi->enable = enable;
 +			strncpy(osi->string, str, OSI_STRING_LENGTH_MAX);
 +			break;
 +		}
 +	}
 +}
 +
 +static void __init set_osi_linux(unsigned int enable)
 +{
 +	if (osi_linux.enable != enable)
 +		osi_linux.enable = enable;
 +
 +	if (osi_linux.enable)
 +		acpi_osi_setup("Linux");
 +	else
 +		acpi_osi_setup("!Linux");
 +
 +	return;
 +}
 +
 +static void __init acpi_cmdline_osi_linux(unsigned int enable)
 +{
 +	osi_linux.cmdline = 1;	/* cmdline set the default and override DMI */
 +	osi_linux.dmi = 0;
 +	set_osi_linux(enable);
 +
 +	return;
 +}
 +
 +void __init acpi_dmi_osi_linux(int enable, const struct dmi_system_id *d)
 +{
 +	printk(KERN_NOTICE PREFIX "DMI detected: %s\n", d->ident);
 +
 +	if (enable == -1)
 +		return;
 +
 +	osi_linux.dmi = 1;	/* DMI knows that this box asks OSI(Linux) */
 +	set_osi_linux(enable);
 +
 +	return;
 +}
 +
 +/*
 + * Modify the list of "OS Interfaces" reported to BIOS via _OSI
 + *
 + * empty string disables _OSI
 + * string starting with '!' disables that string
 + * otherwise string is added to list, augmenting built-in strings
 + */
 +static void __init acpi_osi_setup_late(void)
 +{
 +	struct osi_setup_entry *osi;
 +	char *str;
 +	int i;
 +	acpi_status status;
 +
 +	for (i = 0; i < OSI_STRING_ENTRIES_MAX; i++) {
 +		osi = &osi_setup_entries[i];
 +		str = osi->string;
 +
 +		if (*str == '\0')
 +			break;
 +		if (osi->enable) {
 +			status = acpi_install_interface(str);
 +
 +			if (ACPI_SUCCESS(status))
 +				printk(KERN_INFO PREFIX "Added _OSI(%s)\n", str);
 +		} else {
 +			status = acpi_remove_interface(str);
 +
 +			if (ACPI_SUCCESS(status))
 +				printk(KERN_INFO PREFIX "Deleted _OSI(%s)\n", str);
 +		}
 +	}
 +}
 +
 +static int __init osi_setup(char *str)
 +{
 +	if (str && !strcmp("Linux", str))
 +		acpi_cmdline_osi_linux(1);
 +	else if (str && !strcmp("!Linux", str))
 +		acpi_cmdline_osi_linux(0);
 +	else
 +		acpi_osi_setup(str);
 +
 +	return 1;
 +}
 +
 +__setup("acpi_osi=", osi_setup);
 +
 +/* enable serialization to combat AE_ALREADY_EXISTS errors */
 +static int __init acpi_serialize_setup(char *str)
++=======
+ /*
+  * Disable the auto-serialization of named objects creation methods.
+  *
+  * This feature is enabled by default.  It marks the AML control methods
+  * that contain the opcodes to create named objects as "Serialized".
+  */
+ static int __init acpi_no_auto_serialize_setup(char *str)
++>>>>>>> e5f660ebef68 (ACPI / osi: Collect _OSI handling into one single file)
  {
 -	acpi_gbl_auto_serialize_methods = FALSE;
 -	pr_info("ACPI: auto-serialization disabled\n");
 +	printk(KERN_INFO PREFIX "serialize enabled\n");
 +
 +	acpi_gbl_all_methods_serialized = TRUE;
  
  	return 1;
  }
diff --cc include/linux/acpi.h
index 0ab4b0e3a549,58f707a399c2..000000000000
--- a/include/linux/acpi.h
+++ b/include/linux/acpi.h
@@@ -240,50 -356,11 +240,53 @@@ extern bool wmi_has_guid(const char *gu
  #define ACPI_VIDEO_OUTPUT_SWITCHING_DMI_VENDOR		0x0400
  #define ACPI_VIDEO_OUTPUT_SWITCHING_DMI_VIDEO		0x0800
  
 -extern char acpi_video_backlight_string[];
 +#if defined(CONFIG_ACPI_VIDEO) || defined(CONFIG_ACPI_VIDEO_MODULE)
 +
 +extern long acpi_video_get_capabilities(acpi_handle graphics_dev_handle);
  extern long acpi_is_video_device(acpi_handle handle);
 +extern void acpi_video_dmi_promote_vendor(void);
 +extern void acpi_video_dmi_demote_vendor(void);
 +extern int acpi_video_backlight_support(void);
 +extern int acpi_video_display_switch_support(void);
 +
 +#else
 +
 +static inline long acpi_video_get_capabilities(acpi_handle graphics_dev_handle)
 +{
 +	return 0;
 +}
 +
 +static inline long acpi_is_video_device(acpi_handle handle)
 +{
 +	return 0;
 +}
 +
 +static inline void acpi_video_dmi_promote_vendor(void)
 +{
 +}
 +
 +static inline void acpi_video_dmi_demote_vendor(void)
 +{
 +}
 +
 +static inline int acpi_video_backlight_support(void)
 +{
 +	return 0;
 +}
 +
 +static inline int acpi_video_display_switch_support(void)
 +{
 +	return 0;
 +}
 +
 +#endif /* defined(CONFIG_ACPI_VIDEO) || defined(CONFIG_ACPI_VIDEO_MODULE) */
 +
  extern int acpi_blacklisted(void);
++<<<<<<< HEAD
 +extern void acpi_dmi_osi_linux(int enable, const struct dmi_system_id *d);
++=======
++>>>>>>> e5f660ebef68 (ACPI / osi: Collect _OSI handling into one single file)
  extern void acpi_osi_setup(char *str);
 -extern bool acpi_osi_is_win8(void);
  
  #ifdef CONFIG_ACPI_NUMA
  int acpi_map_pxm_to_online_node(int pxm);
diff --git a/drivers/acpi/Makefile b/drivers/acpi/Makefile
index a19b51ba2075..3261930c21a1 100644
--- a/drivers/acpi/Makefile
+++ b/drivers/acpi/Makefile
@@ -18,7 +18,7 @@ obj-y				+= acpi.o \
 					acpica/
 
 # All the builtin files are in the "acpi." module_param namespace.
-acpi-y				+= osl.o utils.o reboot.o
+acpi-y				+= osi.o osl.o utils.o reboot.o
 acpi-y				+= nvs.o
 
 # Power management related files
* Unmerged path drivers/acpi/blacklist.c
* Unmerged path drivers/acpi/internal.h
diff --git a/drivers/acpi/osi.c b/drivers/acpi/osi.c
new file mode 100644
index 000000000000..849f9d2245ca
--- /dev/null
+++ b/drivers/acpi/osi.c
@@ -0,0 +1,522 @@
+/*
+ *  osi.c - _OSI implementation
+ *
+ *  Copyright (C) 2016 Intel Corporation
+ *    Author: Lv Zheng <lv.zheng@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+/* Uncomment next line to get verbose printout */
+/* #define DEBUG */
+#define pr_fmt(fmt) "ACPI: " fmt
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/acpi.h>
+#include <linux/dmi.h>
+
+#include "internal.h"
+
+
+#define OSI_STRING_LENGTH_MAX	64
+#define OSI_STRING_ENTRIES_MAX	16
+
+struct acpi_osi_entry {
+	char string[OSI_STRING_LENGTH_MAX];
+	bool enable;
+};
+
+static struct acpi_osi_config {
+	u8		default_disabling;
+	unsigned int	linux_enable:1;
+	unsigned int	linux_dmi:1;
+	unsigned int	linux_cmdline:1;
+	unsigned int	darwin_enable:1;
+	unsigned int	darwin_dmi:1;
+	unsigned int	darwin_cmdline:1;
+} osi_config;
+
+static struct acpi_osi_config osi_config;
+static struct acpi_osi_entry
+osi_setup_entries[OSI_STRING_ENTRIES_MAX] __initdata = {
+	{"Module Device", true},
+	{"Processor Device", true},
+	{"3.0 _SCP Extensions", true},
+	{"Processor Aggregator Device", true},
+};
+
+static u32 acpi_osi_handler(acpi_string interface, u32 supported)
+{
+	if (!strcmp("Linux", interface)) {
+		pr_notice_once(FW_BUG
+			"BIOS _OSI(Linux) query %s%s\n",
+			osi_config.linux_enable ? "honored" : "ignored",
+			osi_config.linux_cmdline ? " via cmdline" :
+			osi_config.linux_dmi ? " via DMI" : "");
+	}
+	if (!strcmp("Darwin", interface)) {
+		pr_notice_once(
+			"BIOS _OSI(Darwin) query %s%s\n",
+			osi_config.darwin_enable ? "honored" : "ignored",
+			osi_config.darwin_cmdline ? " via cmdline" :
+			osi_config.darwin_dmi ? " via DMI" : "");
+	}
+
+	return supported;
+}
+
+void __init acpi_osi_setup(char *str)
+{
+	struct acpi_osi_entry *osi;
+	bool enable = true;
+	int i;
+
+	if (!acpi_gbl_create_osi_method)
+		return;
+
+	if (str == NULL || *str == '\0') {
+		pr_info("_OSI method disabled\n");
+		acpi_gbl_create_osi_method = FALSE;
+		return;
+	}
+
+	if (*str == '!') {
+		str++;
+		if (*str == '\0') {
+			/* Do not override acpi_osi=!* */
+			if (!osi_config.default_disabling)
+				osi_config.default_disabling =
+					ACPI_DISABLE_ALL_VENDOR_STRINGS;
+			return;
+		} else if (*str == '*') {
+			osi_config.default_disabling = ACPI_DISABLE_ALL_STRINGS;
+			for (i = 0; i < OSI_STRING_ENTRIES_MAX; i++) {
+				osi = &osi_setup_entries[i];
+				osi->enable = false;
+			}
+			return;
+		} else if (*str == '!') {
+			osi_config.default_disabling = 0;
+			return;
+		}
+		enable = false;
+	}
+
+	for (i = 0; i < OSI_STRING_ENTRIES_MAX; i++) {
+		osi = &osi_setup_entries[i];
+		if (!strcmp(osi->string, str)) {
+			osi->enable = enable;
+			break;
+		} else if (osi->string[0] == '\0') {
+			osi->enable = enable;
+			strncpy(osi->string, str, OSI_STRING_LENGTH_MAX);
+			break;
+		}
+	}
+}
+
+static void __init __acpi_osi_setup_darwin(bool enable)
+{
+	osi_config.darwin_enable = !!enable;
+	if (enable) {
+		acpi_osi_setup("!");
+		acpi_osi_setup("Darwin");
+	} else {
+		acpi_osi_setup("!!");
+		acpi_osi_setup("!Darwin");
+	}
+}
+
+static void __init acpi_osi_setup_darwin(bool enable)
+{
+	/* Override acpi_osi_dmi_blacklisted() */
+	osi_config.darwin_dmi = 0;
+	osi_config.darwin_cmdline = 1;
+	__acpi_osi_setup_darwin(enable);
+}
+
+/*
+ * The story of _OSI(Linux)
+ *
+ * From pre-history through Linux-2.6.22, Linux responded TRUE upon a BIOS
+ * OSI(Linux) query.
+ *
+ * Unfortunately, reference BIOS writers got wind of this and put
+ * OSI(Linux) in their example code, quickly exposing this string as
+ * ill-conceived and opening the door to an un-bounded number of BIOS
+ * incompatibilities.
+ *
+ * For example, OSI(Linux) was used on resume to re-POST a video card on
+ * one system, because Linux at that time could not do a speedy restore in
+ * its native driver. But then upon gaining quick native restore
+ * capability, Linux has no way to tell the BIOS to skip the time-consuming
+ * POST -- putting Linux at a permanent performance disadvantage. On
+ * another system, the BIOS writer used OSI(Linux) to infer native OS
+ * support for IPMI!  On other systems, OSI(Linux) simply got in the way of
+ * Linux claiming to be compatible with other operating systems, exposing
+ * BIOS issues such as skipped device initialization.
+ *
+ * So "Linux" turned out to be a really poor chose of OSI string, and from
+ * Linux-2.6.23 onward we respond FALSE.
+ *
+ * BIOS writers should NOT query _OSI(Linux) on future systems. Linux will
+ * complain on the console when it sees it, and return FALSE. To get Linux
+ * to return TRUE for your system  will require a kernel source update to
+ * add a DMI entry, or boot with "acpi_osi=Linux"
+ */
+static void __init __acpi_osi_setup_linux(bool enable)
+{
+	osi_config.linux_enable = !!enable;
+	if (enable)
+		acpi_osi_setup("Linux");
+	else
+		acpi_osi_setup("!Linux");
+}
+
+static void __init acpi_osi_setup_linux(bool enable)
+{
+	/* Override acpi_osi_dmi_blacklisted() */
+	osi_config.linux_dmi = 0;
+	osi_config.linux_cmdline = 1;
+	__acpi_osi_setup_linux(enable);
+}
+
+/*
+ * Modify the list of "OS Interfaces" reported to BIOS via _OSI
+ *
+ * empty string disables _OSI
+ * string starting with '!' disables that string
+ * otherwise string is added to list, augmenting built-in strings
+ */
+static void __init acpi_osi_setup_late(void)
+{
+	struct acpi_osi_entry *osi;
+	char *str;
+	int i;
+	acpi_status status;
+
+	if (osi_config.default_disabling) {
+		status = acpi_update_interfaces(osi_config.default_disabling);
+		if (ACPI_SUCCESS(status))
+			pr_info("Disabled all _OSI OS vendors%s\n",
+				osi_config.default_disabling ==
+				ACPI_DISABLE_ALL_STRINGS ?
+				" and feature groups" : "");
+	}
+
+	for (i = 0; i < OSI_STRING_ENTRIES_MAX; i++) {
+		osi = &osi_setup_entries[i];
+		str = osi->string;
+		if (*str == '\0')
+			break;
+		if (osi->enable) {
+			status = acpi_install_interface(str);
+			if (ACPI_SUCCESS(status))
+				pr_info("Added _OSI(%s)\n", str);
+		} else {
+			status = acpi_remove_interface(str);
+			if (ACPI_SUCCESS(status))
+				pr_info("Deleted _OSI(%s)\n", str);
+		}
+	}
+}
+
+static int __init osi_setup(char *str)
+{
+	if (str && !strcmp("Linux", str))
+		acpi_osi_setup_linux(true);
+	else if (str && !strcmp("!Linux", str))
+		acpi_osi_setup_linux(false);
+	else if (str && !strcmp("Darwin", str))
+		acpi_osi_setup_darwin(true);
+	else if (str && !strcmp("!Darwin", str))
+		acpi_osi_setup_darwin(false);
+	else
+		acpi_osi_setup(str);
+
+	return 1;
+}
+__setup("acpi_osi=", osi_setup);
+
+bool acpi_osi_is_win8(void)
+{
+	return acpi_gbl_osi_data >= ACPI_OSI_WIN_8;
+}
+EXPORT_SYMBOL(acpi_osi_is_win8);
+
+static void __init acpi_osi_dmi_darwin(bool enable,
+				       const struct dmi_system_id *d)
+{
+	pr_notice("DMI detected to setup _OSI(\"Darwin\"): %s\n", d->ident);
+	osi_config.darwin_dmi = 1;
+	__acpi_osi_setup_darwin(enable);
+}
+
+void __init acpi_osi_dmi_linux(bool enable, const struct dmi_system_id *d)
+{
+	pr_notice("DMI detected to setup _OSI(\"Linux\"): %s\n", d->ident);
+	osi_config.linux_dmi = 1;
+	__acpi_osi_setup_linux(enable);
+}
+
+static int __init dmi_enable_osi_darwin(const struct dmi_system_id *d)
+{
+	acpi_osi_dmi_darwin(true, d);
+
+	return 0;
+}
+
+static int __init dmi_enable_osi_linux(const struct dmi_system_id *d)
+{
+	acpi_osi_dmi_linux(true, d);
+
+	return 0;
+}
+
+static int __init dmi_disable_osi_vista(const struct dmi_system_id *d)
+{
+	pr_notice("DMI detected: %s\n", d->ident);
+	acpi_osi_setup("!Windows 2006");
+	acpi_osi_setup("!Windows 2006 SP1");
+	acpi_osi_setup("!Windows 2006 SP2");
+
+	return 0;
+}
+
+static int __init dmi_disable_osi_win7(const struct dmi_system_id *d)
+{
+	pr_notice("DMI detected: %s\n", d->ident);
+	acpi_osi_setup("!Windows 2009");
+
+	return 0;
+}
+
+static int __init dmi_disable_osi_win8(const struct dmi_system_id *d)
+{
+	pr_notice("DMI detected: %s\n", d->ident);
+	acpi_osi_setup("!Windows 2012");
+
+	return 0;
+}
+
+/*
+ * Linux default _OSI response behavior is determined by this DMI table.
+ *
+ * Note that _OSI("Linux")/_OSI("Darwin") determined here can be overridden
+ * by acpi_osi=!Linux/acpi_osi=!Darwin command line options.
+ */
+static struct dmi_system_id acpi_osi_dmi_table[] __initdata = {
+	{
+	.callback = dmi_disable_osi_vista,
+	.ident = "Fujitsu Siemens",
+	.matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU SIEMENS"),
+		     DMI_MATCH(DMI_PRODUCT_NAME, "ESPRIMO Mobile V5505"),
+		},
+	},
+	{
+	/*
+	 * There have a NVIF method in MSI GX723 DSDT need call by Nvidia
+	 * driver (e.g. nouveau) when user press brightness hotkey.
+	 * Currently, nouveau driver didn't do the job and it causes there
+	 * have a infinite while loop in DSDT when user press hotkey.
+	 * We add MSI GX723's dmi information to this table for workaround
+	 * this issue.
+	 * Will remove MSI GX723 from the table after nouveau grows support.
+	 */
+	.callback = dmi_disable_osi_vista,
+	.ident = "MSI GX723",
+	.matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "Micro-Star International"),
+		     DMI_MATCH(DMI_PRODUCT_NAME, "GX723"),
+		},
+	},
+	{
+	.callback = dmi_disable_osi_vista,
+	.ident = "Sony VGN-NS10J_S",
+	.matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
+		     DMI_MATCH(DMI_PRODUCT_NAME, "VGN-NS10J_S"),
+		},
+	},
+	{
+	.callback = dmi_disable_osi_vista,
+	.ident = "Sony VGN-SR290J",
+	.matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
+		     DMI_MATCH(DMI_PRODUCT_NAME, "VGN-SR290J"),
+		},
+	},
+	{
+	.callback = dmi_disable_osi_vista,
+	.ident = "VGN-NS50B_L",
+	.matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
+		     DMI_MATCH(DMI_PRODUCT_NAME, "VGN-NS50B_L"),
+		},
+	},
+	{
+	.callback = dmi_disable_osi_vista,
+	.ident = "VGN-SR19XN",
+	.matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
+		     DMI_MATCH(DMI_PRODUCT_NAME, "VGN-SR19XN"),
+		},
+	},
+	{
+	.callback = dmi_disable_osi_vista,
+	.ident = "Toshiba Satellite L355",
+	.matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),
+		     DMI_MATCH(DMI_PRODUCT_VERSION, "Satellite L355"),
+		},
+	},
+	{
+	.callback = dmi_disable_osi_win7,
+	.ident = "ASUS K50IJ",
+	.matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK Computer Inc."),
+		     DMI_MATCH(DMI_PRODUCT_NAME, "K50IJ"),
+		},
+	},
+	{
+	.callback = dmi_disable_osi_vista,
+	.ident = "Toshiba P305D",
+	.matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),
+		     DMI_MATCH(DMI_PRODUCT_NAME, "Satellite P305D"),
+		},
+	},
+	{
+	.callback = dmi_disable_osi_vista,
+	.ident = "Toshiba NB100",
+	.matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),
+		     DMI_MATCH(DMI_PRODUCT_NAME, "NB100"),
+		},
+	},
+
+	/*
+	 * The wireless hotkey does not work on those machines when
+	 * returning true for _OSI("Windows 2012")
+	 */
+	{
+	.callback = dmi_disable_osi_win8,
+	.ident = "Dell Inspiron 7737",
+	.matches = {
+		    DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
+		    DMI_MATCH(DMI_PRODUCT_NAME, "Inspiron 7737"),
+		},
+	},
+	{
+	.callback = dmi_disable_osi_win8,
+	.ident = "Dell Inspiron 7537",
+	.matches = {
+		    DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
+		    DMI_MATCH(DMI_PRODUCT_NAME, "Inspiron 7537"),
+		},
+	},
+	{
+	.callback = dmi_disable_osi_win8,
+	.ident = "Dell Inspiron 5437",
+	.matches = {
+		    DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
+		    DMI_MATCH(DMI_PRODUCT_NAME, "Inspiron 5437"),
+		},
+	},
+	{
+	.callback = dmi_disable_osi_win8,
+	.ident = "Dell Inspiron 3437",
+	.matches = {
+		    DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
+		    DMI_MATCH(DMI_PRODUCT_NAME, "Inspiron 3437"),
+		},
+	},
+	{
+	.callback = dmi_disable_osi_win8,
+	.ident = "Dell Vostro 3446",
+	.matches = {
+		    DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
+		    DMI_MATCH(DMI_PRODUCT_NAME, "Vostro 3446"),
+		},
+	},
+	{
+	.callback = dmi_disable_osi_win8,
+	.ident = "Dell Vostro 3546",
+	.matches = {
+		    DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
+		    DMI_MATCH(DMI_PRODUCT_NAME, "Vostro 3546"),
+		},
+	},
+
+	/*
+	 * BIOS invocation of _OSI(Linux) is almost always a BIOS bug.
+	 * Linux ignores it, except for the machines enumerated below.
+	 */
+
+	/*
+	 * Without this this EEEpc exports a non working WMI interface, with
+	 * this it exports a working "good old" eeepc_laptop interface, fixing
+	 * both brightness control, and rfkill not working.
+	 */
+	{
+	.callback = dmi_enable_osi_linux,
+	.ident = "Asus EEE PC 1015PX",
+	.matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK Computer INC."),
+		     DMI_MATCH(DMI_PRODUCT_NAME, "1015PX"),
+		},
+	},
+
+	/*
+	 * Enable _OSI("Darwin") for all apple platforms.
+	 */
+	{
+	.callback = dmi_enable_osi_darwin,
+	.ident = "Apple hardware",
+	.matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "Apple Inc."),
+		},
+	},
+	{
+	.callback = dmi_enable_osi_darwin,
+	.ident = "Apple hardware",
+	.matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "Apple Computer, Inc."),
+		},
+	},
+	{}
+};
+
+static __init void acpi_osi_dmi_blacklisted(void)
+{
+	dmi_check_system(acpi_osi_dmi_table);
+}
+
+int __init early_acpi_osi_init(void)
+{
+	acpi_osi_dmi_blacklisted();
+
+	return 0;
+}
+
+int __init acpi_osi_init(void)
+{
+	acpi_install_interface_handler(acpi_osi_handler);
+	acpi_osi_setup_late();
+
+	return 0;
+}
* Unmerged path drivers/acpi/osl.c
* Unmerged path include/linux/acpi.h
