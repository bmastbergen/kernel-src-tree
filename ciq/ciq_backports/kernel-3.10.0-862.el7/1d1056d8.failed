mlxsw: spectrum_router: Export IPv6 link local address check helper

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Arkadi Sharshevsky <arkadis@mellanox.com>
commit 1d1056d80b8e44efcc05298bfa85fa5ec0998bc9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1d1056d8.failed

Neighbors with link local addresses are not offloaded to the host table,
yet, the are maintained in the driver for adjacency table usage. When
dumping the IPv6 host neighbors this link local neighbors should be
ignored. This patch exports this helper for dpipe usage.

	Signed-off-by: Arkadi Sharshevsky <arkadis@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1d1056d80b8e44efcc05298bfa85fa5ec0998bc9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.h
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index 6908726c154c,1f41bcdf04ca..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -978,6 -1380,37 +978,40 @@@ mlxsw_sp_router_neigh_entry_op4(struct 
  }
  
  static void
++<<<<<<< HEAD
++=======
+ mlxsw_sp_router_neigh_entry_op6(struct mlxsw_sp *mlxsw_sp,
+ 				struct mlxsw_sp_neigh_entry *neigh_entry,
+ 				enum mlxsw_reg_rauht_op op)
+ {
+ 	struct neighbour *n = neigh_entry->key.n;
+ 	char rauht_pl[MLXSW_REG_RAUHT_LEN];
+ 	const char *dip = n->primary_key;
+ 
+ 	mlxsw_reg_rauht_pack6(rauht_pl, op, neigh_entry->rif, neigh_entry->ha,
+ 			      dip);
+ 	if (neigh_entry->counter_valid)
+ 		mlxsw_reg_rauht_pack_counter(rauht_pl,
+ 					     neigh_entry->counter_index);
+ 	mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(rauht), rauht_pl);
+ }
+ 
+ bool mlxsw_sp_neigh_ipv6_ignore(struct mlxsw_sp_neigh_entry *neigh_entry)
+ {
+ 	struct neighbour *n = neigh_entry->key.n;
+ 
+ 	/* Packets with a link-local destination address are trapped
+ 	 * after LPM lookup and never reach the neighbour table, so
+ 	 * there is no need to program such neighbours to the device.
+ 	 */
+ 	if (ipv6_addr_type((struct in6_addr *) &n->primary_key) &
+ 	    IPV6_ADDR_LINKLOCAL)
+ 		return true;
+ 	return false;
+ }
+ 
+ static void
++>>>>>>> 1d1056d80b8e (mlxsw: spectrum_router: Export IPv6 link local address check helper)
  mlxsw_sp_neigh_entry_update(struct mlxsw_sp *mlxsw_sp,
  			    struct mlxsw_sp_neigh_entry *neigh_entry,
  			    bool adding)
@@@ -985,11 -1418,29 +1019,31 @@@
  	if (!adding && !neigh_entry->connected)
  		return;
  	neigh_entry->connected = adding;
 -	if (neigh_entry->key.n->tbl->family == AF_INET) {
 +	if (neigh_entry->key.n->tbl == &arp_tbl)
  		mlxsw_sp_router_neigh_entry_op4(mlxsw_sp, neigh_entry,
  						mlxsw_sp_rauht_op(adding));
++<<<<<<< HEAD
++=======
+ 	} else if (neigh_entry->key.n->tbl->family == AF_INET6) {
+ 		if (mlxsw_sp_neigh_ipv6_ignore(neigh_entry))
+ 			return;
+ 		mlxsw_sp_router_neigh_entry_op6(mlxsw_sp, neigh_entry,
+ 						mlxsw_sp_rauht_op(adding));
+ 	} else {
+ 		WARN_ON_ONCE(1);
+ 	}
+ }
+ 
+ void
+ mlxsw_sp_neigh_entry_counter_update(struct mlxsw_sp *mlxsw_sp,
+ 				    struct mlxsw_sp_neigh_entry *neigh_entry,
+ 				    bool adding)
+ {
+ 	if (adding)
+ 		mlxsw_sp_neigh_counter_alloc(mlxsw_sp, neigh_entry);
++>>>>>>> 1d1056d80b8e (mlxsw: spectrum_router: Export IPv6 link local address check helper)
  	else
 -		mlxsw_sp_neigh_counter_free(mlxsw_sp, neigh_entry);
 -	mlxsw_sp_neigh_entry_update(mlxsw_sp, neigh_entry, true);
 +		WARN_ON_ONCE(1);
  }
  
  struct mlxsw_sp_neigh_event_work {
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.h
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.h
