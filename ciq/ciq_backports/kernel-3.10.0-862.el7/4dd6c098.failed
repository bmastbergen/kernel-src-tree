radix-tree: rename indirect_to_ptr() to entry_to_node()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Matthew Wilcox <willy@linux.intel.com>
commit 4dd6c0987ca43d6544f4f0a3f86f6ea3bfc60fc1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4dd6c098.failed

Mirrors the earlier commit introducing node_to_entry().

Also change the type returned to be a struct radix_tree_node pointer.
That lets us simplify a couple of places in the radix tree shrink &
extend paths where we could convert an entry into a pointer, modify the
node, then convert the pointer back into an entry.

	Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
	Cc: Konstantin Khlebnikov <koct9i@gmail.com>
	Cc: Kirill Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Jan Kara <jack@suse.com>
	Cc: Neil Brown <neilb@suse.de>
	Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 4dd6c0987ca43d6544f4f0a3f86f6ea3bfc60fc1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/radix-tree.h
#	lib/radix-tree.c
diff --cc include/linux/radix-tree.h
index f94b73d0f147,b94aa198dd6b..000000000000
--- a/include/linux/radix-tree.h
+++ b/include/linux/radix-tree.h
@@@ -418,7 -439,12 +418,16 @@@ void **radix_tree_iter_next(struct radi
  static __always_inline long
  radix_tree_chunk_size(struct radix_tree_iter *iter)
  {
++<<<<<<< HEAD
 +	return iter->next_index - iter->index;
++=======
+ 	return (iter->next_index - iter->index) >> iter_shift(iter);
+ }
+ 
+ static inline struct radix_tree_node *entry_to_node(void *ptr)
+ {
+ 	return (void *)((unsigned long)ptr & ~RADIX_TREE_INTERNAL_NODE);
++>>>>>>> 4dd6c0987ca4 (radix-tree: rename indirect_to_ptr() to entry_to_node())
  }
  
  /**
@@@ -444,12 -462,27 +453,28 @@@ static __always_inline void *
  radix_tree_next_slot(void **slot, struct radix_tree_iter *iter, unsigned flags)
  {
  	if (flags & RADIX_TREE_ITER_TAGGED) {
 -		void *canon = slot;
 -
  		iter->tags >>= 1;
++<<<<<<< HEAD
++=======
+ 		if (unlikely(!iter->tags))
+ 			return NULL;
+ 		while (IS_ENABLED(CONFIG_RADIX_TREE_MULTIORDER) &&
+ 					radix_tree_is_indirect_ptr(slot[1])) {
+ 			if (entry_to_node(slot[1]) == canon) {
+ 				iter->tags >>= 1;
+ 				iter->index = __radix_tree_iter_add(iter, 1);
+ 				slot++;
+ 				continue;
+ 			}
+ 			iter->next_index = __radix_tree_iter_add(iter, 1);
+ 			return NULL;
+ 		}
++>>>>>>> 4dd6c0987ca4 (radix-tree: rename indirect_to_ptr() to entry_to_node())
  		if (likely(iter->tags & 1ul)) {
 -			iter->index = __radix_tree_iter_add(iter, 1);
 +			iter->index++;
  			return slot + 1;
  		}
 -		if (!(flags & RADIX_TREE_ITER_CONTIG)) {
 +		if (!(flags & RADIX_TREE_ITER_CONTIG) && likely(iter->tags)) {
  			unsigned offset = __ffs(iter->tags);
  
  			iter->tags >>= offset;
@@@ -457,11 -490,21 +482,24 @@@
  			return slot + offset + 1;
  		}
  	} else {
 -		long count = radix_tree_chunk_size(iter);
 -		void *canon = slot;
 +		long size = radix_tree_chunk_size(iter);
  
 -		while (--count > 0) {
 +		while (--size > 0) {
  			slot++;
++<<<<<<< HEAD
 +			iter->index++;
++=======
+ 			iter->index = __radix_tree_iter_add(iter, 1);
+ 
+ 			if (IS_ENABLED(CONFIG_RADIX_TREE_MULTIORDER) &&
+ 			    radix_tree_is_indirect_ptr(*slot)) {
+ 				if (entry_to_node(*slot) == canon)
+ 					continue;
+ 				iter->next_index = iter->index;
+ 				break;
+ 			}
+ 
++>>>>>>> 4dd6c0987ca4 (radix-tree: rename indirect_to_ptr() to entry_to_node())
  			if (likely(*slot))
  				return slot;
  			if (flags & RADIX_TREE_ITER_CONTIG) {
diff --cc lib/radix-tree.c
index 467d6e0a3a58,3c3fdd9c5bb3..000000000000
--- a/lib/radix-tree.c
+++ b/lib/radix-tree.c
@@@ -239,8 -236,7 +239,12 @@@ static void dump_node(struct radix_tree
  			pr_debug("radix entry %p offset %ld indices %ld-%ld\n",
  					entry, i, first, last);
  		} else {
++<<<<<<< HEAD
 +			dump_node(indirect_to_ptr(entry), i,
 +					shift - RADIX_TREE_MAP_SHIFT, first);
++=======
+ 			dump_node(entry_to_node(entry), first);
++>>>>>>> 4dd6c0987ca4 (radix-tree: rename indirect_to_ptr() to entry_to_node())
  		}
  	}
  }
@@@ -253,8 -249,7 +257,12 @@@ static void radix_tree_dump(struct radi
  			root->gfp_mask >> __GFP_BITS_SHIFT);
  	if (!radix_tree_is_indirect_ptr(root->rnode))
  		return;
++<<<<<<< HEAD
 +	dump_node(indirect_to_ptr(root->rnode), 0,
 +				(root->height - 1) * RADIX_TREE_MAP_SHIFT, 0);
++=======
+ 	dump_node(entry_to_node(root->rnode), 0);
++>>>>>>> 4dd6c0987ca4 (radix-tree: rename indirect_to_ptr() to entry_to_node())
  }
  #endif
  
@@@ -409,10 -422,9 +417,10 @@@ static unsigned radix_tree_load_root(st
  	*nodep = node;
  
  	if (likely(radix_tree_is_indirect_ptr(node))) {
- 		node = indirect_to_ptr(node);
+ 		node = entry_to_node(node);
  		*maxindex = node_maxindex(node);
 -		return node->shift + RADIX_TREE_MAP_SHIFT;
 +		return (node->path & RADIX_TREE_HEIGHT_MASK) *
 +			RADIX_TREE_MAP_SHIFT;
  	}
  
  	*maxindex = 0;
@@@ -451,25 -462,20 +459,30 @@@ static int radix_tree_extend(struct rad
  				tag_set(node, tag, 0);
  		}
  
 -		BUG_ON(shift > BITS_PER_LONG);
 -		node->shift = shift;
 -		node->offset = 0;
 +		/* Increase the height.  */
 +		newheight = root->height+1;
 +		BUG_ON(newheight & ~RADIX_TREE_HEIGHT_MASK);
 +		node->path = newheight;
  		node->count = 1;
  		node->parent = NULL;
++<<<<<<< HEAD
 +		slot = root->rnode;
 +		if (radix_tree_is_indirect_ptr(slot)) {
 +			slot = indirect_to_ptr(slot);
 +			slot->parent = node;
 +			slot = ptr_to_indirect(slot);
 +		}
++=======
+ 		if (radix_tree_is_indirect_ptr(slot))
+ 			entry_to_node(slot)->parent = node;
++>>>>>>> 4dd6c0987ca4 (radix-tree: rename indirect_to_ptr() to entry_to_node())
  		node->slots[0] = slot;
 -		slot = node_to_entry(node);
 -		rcu_assign_pointer(root->rnode, slot);
 -		shift += RADIX_TREE_MAP_SHIFT;
 -	} while (shift <= maxshift);
 +		node = ptr_to_indirect(node);
 +		rcu_assign_pointer(root->rnode, node);
 +		root->height = newheight;
 +	} while (height > root->height);
  out:
 -	return maxshift + RADIX_TREE_MAP_SHIFT;
 +	return height * RADIX_TREE_MAP_SHIFT;
  }
  
  /**
@@@ -535,13 -539,12 +548,17 @@@ int __radix_tree_create(struct radix_tr
  			break;
  
  		/* Go a level down */
++<<<<<<< HEAD
 +		height--;
 +		shift -= RADIX_TREE_MAP_SHIFT;
++=======
+ 		node = entry_to_node(slot);
++>>>>>>> 4dd6c0987ca4 (radix-tree: rename indirect_to_ptr() to entry_to_node())
  		offset = (index >> shift) & RADIX_TREE_MAP_MASK;
 -		offset = radix_tree_descend(node, &slot, offset);
 +		node = indirect_to_ptr(slot);
 +		slot = node->slots[offset];
  	}
  
 -#ifdef CONFIG_RADIX_TREE_MULTIORDER
  	/* Insert pointers to the canonical entry */
  	if (order > shift) {
  		int i, n = 1 << (order - shift);
@@@ -882,14 -895,19 +899,19 @@@ void **radix_tree_next_chunk(struct rad
  	if (!index && iter->index)
  		return NULL;
  
 - restart:
 -	shift = radix_tree_load_root(root, &rnode, &maxindex);
 -	if (index > maxindex)
 -		return NULL;
 -
 +	rnode = rcu_dereference_raw(root->rnode);
  	if (radix_tree_is_indirect_ptr(rnode)) {
++<<<<<<< HEAD
 +		rnode = indirect_to_ptr(rnode);
 +	} else if (rnode && !index) {
++=======
+ 		rnode = entry_to_node(rnode);
+ 	} else if (rnode) {
++>>>>>>> 4dd6c0987ca4 (radix-tree: rename indirect_to_ptr() to entry_to_node())
  		/* Single-slot tree */
 -		iter->index = index;
 -		iter->next_index = maxindex + 1;
 +		iter->index = 0;
 +		iter->next_index = 1;
  		iter->tags = 1;
 -		__set_iter_shift(iter, shift);
  		return (void **)&root->rnode;
  	} else
  		return NULL;
@@@ -941,7 -959,8 +963,12 @@@ restart
  			goto restart;
  		if (!radix_tree_is_indirect_ptr(slot))
  			break;
++<<<<<<< HEAD
 +		node = indirect_to_ptr(slot);
++=======
+ 
+ 		node = entry_to_node(slot);
++>>>>>>> 4dd6c0987ca4 (radix-tree: rename indirect_to_ptr() to entry_to_node())
  		shift -= RADIX_TREE_MAP_SHIFT;
  		offset = (index >> shift) & RADIX_TREE_MAP_MASK;
  	}
@@@ -1026,29 -1045,24 +1053,42 @@@ unsigned long radix_tree_range_tag_if_t
  		return 1;
  	}
  
++<<<<<<< HEAD
 +	shift = (height - 1) * RADIX_TREE_MAP_SHIFT;
 +	slot = indirect_to_ptr(root->rnode);
++=======
+ 	node = entry_to_node(slot);
+ 	shift -= RADIX_TREE_MAP_SHIFT;
++>>>>>>> 4dd6c0987ca4 (radix-tree: rename indirect_to_ptr() to entry_to_node())
  
  	for (;;) {
  		unsigned long upindex;
 -		unsigned offset;
 +		int offset;
  
  		offset = (index >> shift) & RADIX_TREE_MAP_MASK;
 -		offset = radix_tree_descend(node, &slot, offset);
 -		if (!slot)
 +		if (!slot->slots[offset])
  			goto next;
 -		if (!tag_get(node, iftag, offset))
 +		if (!tag_get(slot, iftag, offset))
  			goto next;
++<<<<<<< HEAD
 +		if (shift) {
 +			node = slot;
 +			slot = slot->slots[offset];
 +			if (radix_tree_is_indirect_ptr(slot)) {
 +				slot = indirect_to_ptr(slot);
 +				shift -= RADIX_TREE_MAP_SHIFT;
 +				continue;
 +			} else {
 +				slot = node;
 +				node = node->parent;
 +			}
++=======
+ 		/* Sibling slots never have tags set on them */
+ 		if (radix_tree_is_indirect_ptr(slot)) {
+ 			node = entry_to_node(slot);
+ 			shift -= RADIX_TREE_MAP_SHIFT;
+ 			continue;
++>>>>>>> 4dd6c0987ca4 (radix-tree: rename indirect_to_ptr() to entry_to_node())
  		}
  
  		/* tag the leaf */
@@@ -1278,54 -1294,44 +1318,70 @@@ EXPORT_SYMBOL(radix_tree_gang_lookup_ta
   * This linear search is at present only useful to shmem_unuse_inode().
   */
  static unsigned long __locate(struct radix_tree_node *slot, void *item,
 -			      unsigned long index, struct locate_info *info)
 +			      unsigned long index, unsigned long *found_index)
  {
 -	unsigned int shift;
 +	unsigned int shift, height;
  	unsigned long i;
  
 -	shift = slot->shift + RADIX_TREE_MAP_SHIFT;
 -
 -	do {
 -		shift -= RADIX_TREE_MAP_SHIFT;
 +	height = slot->path & RADIX_TREE_HEIGHT_MASK;
 +	shift = (height-1) * RADIX_TREE_MAP_SHIFT;
  
 -		for (i = (index >> shift) & RADIX_TREE_MAP_MASK;
 -		     i < RADIX_TREE_MAP_SIZE;
 -		     i++, index += (1UL << shift)) {
 -			struct radix_tree_node *node =
 -					rcu_dereference_raw(slot->slots[i]);
 -			if (node == RADIX_TREE_RETRY)
 +	for ( ; height > 1; height--) {
 +		i = (index >> shift) & RADIX_TREE_MAP_MASK;
 +		for (;;) {
 +			if (slot->slots[i] != NULL)
 +				break;
 +			index &= ~((1UL << shift) - 1);
 +			index += 1UL << shift;
 +			if (index == 0)
 +				goto out;	/* 32-bit wraparound */
 +			i++;
 +			if (i == RADIX_TREE_MAP_SIZE)
  				goto out;
++<<<<<<< HEAD
++=======
+ 			if (!radix_tree_is_indirect_ptr(node)) {
+ 				if (node == item) {
+ 					info->found_index = index;
+ 					info->stop = true;
+ 					goto out;
+ 				}
+ 				continue;
+ 			}
+ 			node = entry_to_node(node);
+ 			if (is_sibling_entry(slot, node))
+ 				continue;
+ 			slot = node;
+ 			break;
++>>>>>>> 4dd6c0987ca4 (radix-tree: rename indirect_to_ptr() to entry_to_node())
  		}
 -		if (i == RADIX_TREE_MAP_SIZE)
 -			break;
 -	} while (shift);
  
 +		slot = rcu_dereference_raw(slot->slots[i]);
 +		if (slot == NULL)
 +			goto out;
 +		if (!radix_tree_is_indirect_ptr(slot)) {
 +			if (slot == item) {
 +				*found_index = index + i;
 +				index = 0;
 +			} else {
 +				index += shift;
 +			}
 +			goto out;
 +		}
 +		slot = indirect_to_ptr(slot);
 +		shift -= RADIX_TREE_MAP_SHIFT;
 +	}
 +
 +	/* Bottom level: check items */
 +	for (i = 0; i < RADIX_TREE_MAP_SIZE; i++) {
 +		if (slot->slots[i] == item) {
 +			*found_index = index + i;
 +			index = 0;
 +			goto out;
 +		}
 +	}
 +	index += RADIX_TREE_MAP_SIZE;
  out:
 -	if ((index == 0) && (i == RADIX_TREE_MAP_SIZE))
 -		info->stop = true;
  	return index;
  }
  
@@@ -1355,18 -1364,20 +1411,26 @@@ unsigned long radix_tree_locate_item(st
  			break;
  		}
  
++<<<<<<< HEAD
 +		node = indirect_to_ptr(node);
 +		max_index = radix_tree_maxindex(node->path &
 +						RADIX_TREE_HEIGHT_MASK);
 +		if (cur_index > max_index)
++=======
+ 		node = entry_to_node(node);
+ 
+ 		max_index = node_maxindex(node);
+ 		if (cur_index > max_index) {
+ 			rcu_read_unlock();
++>>>>>>> 4dd6c0987ca4 (radix-tree: rename indirect_to_ptr() to entry_to_node())
  			break;
 -		}
  
 -		cur_index = __locate(node, item, cur_index, &info);
 +		cur_index = __locate(node, item, cur_index, &found_index);
  		rcu_read_unlock();
  		cond_resched();
 -	} while (!info.stop && cur_index <= max_index);
 +	} while (cur_index != 0 && cur_index <= max_index);
  
 -	return info.found_index;
 +	return found_index;
  }
  #else
  unsigned long radix_tree_locate_item(struct radix_tree_root *root, void *item)
@@@ -1388,8 -1398,9 +1452,14 @@@ static inline bool radix_tree_shrink(st
  		struct radix_tree_node *to_free = root->rnode;
  		struct radix_tree_node *slot;
  
++<<<<<<< HEAD
 +		BUG_ON(!radix_tree_is_indirect_ptr(to_free));
 +		to_free = indirect_to_ptr(to_free);
++=======
+ 		if (!radix_tree_is_indirect_ptr(to_free))
+ 			break;
+ 		to_free = entry_to_node(to_free);
++>>>>>>> 4dd6c0987ca4 (radix-tree: rename indirect_to_ptr() to entry_to_node())
  
  		/*
  		 * The candidate node has more than one child, or its child
@@@ -1401,6 -1412,11 +1471,14 @@@
  		slot = to_free->slots[0];
  		if (!slot)
  			break;
++<<<<<<< HEAD
++=======
+ 		if (!radix_tree_is_indirect_ptr(slot) && to_free->shift)
+ 			break;
+ 
+ 		if (radix_tree_is_indirect_ptr(slot))
+ 			entry_to_node(slot)->parent = NULL;
++>>>>>>> 4dd6c0987ca4 (radix-tree: rename indirect_to_ptr() to entry_to_node())
  
  		/*
  		 * We don't need rcu_assign_pointer(), since we are simply
* Unmerged path include/linux/radix-tree.h
* Unmerged path lib/radix-tree.c
diff --git a/tools/testing/radix-tree/test.c b/tools/testing/radix-tree/test.c
index eefa9383f83f..0690c4dfc5e6 100644
--- a/tools/testing/radix-tree/test.c
+++ b/tools/testing/radix-tree/test.c
@@ -142,7 +142,7 @@ static int verify_node(struct radix_tree_node *slot, unsigned int tag,
 	int i;
 	int j;
 
-	slot = indirect_to_ptr(slot);
+	slot = entry_to_node(slot);
 
 	/* Verify consistency at this level */
 	for (i = 0; i < RADIX_TREE_TAG_LONGS; i++) {
@@ -220,7 +220,7 @@ void tree_verify_min_height(struct radix_tree_root *root, int maxindex)
 		return;
 	}
 
-	node = indirect_to_ptr(node);
+	node = entry_to_node(node);
 	assert(maxindex <= node_maxindex(node));
 
 	shift = node->shift;
diff --git a/tools/testing/radix-tree/test.h b/tools/testing/radix-tree/test.h
index 76ceeec79350..7d710637814b 100644
--- a/tools/testing/radix-tree/test.h
+++ b/tools/testing/radix-tree/test.h
@@ -35,7 +35,6 @@ void verify_tag_consistency(struct radix_tree_root *root, unsigned int tag);
 extern int nr_allocated;
 
 /* Normally private parts of lib/radix-tree.c */
-void *indirect_to_ptr(void *ptr);
 void radix_tree_dump(struct radix_tree_root *root);
 int root_tag_get(struct radix_tree_root *root, unsigned int tag);
 unsigned long node_maxindex(struct radix_tree_node *);
