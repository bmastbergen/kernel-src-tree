IB/cm: Fix memory corruption in handling CM request

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Parav Pandit <parav@mellanox.com>
commit 5a3dc32372439eb9a0d6027c54cbfff64803fce5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5a3dc323.failed

In recent code, two path record entries are alwasy cleared while
allocated could be either one or two path record entries.
This leads to zero out of unallocated memory.

This fix initializes alternative path record only when alternative path
is set.

While we are at it, path record allocation doesn't check for OPA
alternative path, but rest of the code checks for OPA alternative path.
Path record allocation code doesn't check for OPA alternative LID.
This can further lead to memory corruption when only one path record is
allocated, but there is actually alternative OPA path record present in CM
request.

	Cc: <stable@vger.kernel.org> # v4.12+
Fixes: 9fdca4da4d8c ("IB/SA: Split struct sa_path_rec based on IB and ROCE specific fields")
	Signed-off-by: Parav Pandit <parav@mellanox.com>
	Reviewed-by: Moni Shoua <monis@mellanox.com>
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 5a3dc32372439eb9a0d6027c54cbfff64803fce5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/cm.c
diff --cc drivers/infiniband/core/cm.c
index ea27dc1ae666,f6b159d79977..000000000000
--- a/drivers/infiniband/core/cm.c
+++ b/drivers/infiniband/core/cm.c
@@@ -1758,13 -1852,14 +1758,20 @@@ static int cm_req_handler(struct cm_wor
  	cm_id_priv->id.service_mask = ~cpu_to_be64(0);
  
  	cm_process_routed_req(req_msg, work->mad_recv_wc->wc);
 +	cm_format_paths_from_req(req_msg, &work->path[0], &work->path[1]);
  
++<<<<<<< HEAD
 +	memcpy(work->path[0].dmac, cm_id_priv->av.ah_attr.dmac, ETH_ALEN);
 +	work->path[0].hop_limit = cm_id_priv->av.ah_attr.grh.hop_limit;
++=======
+ 	memset(&work->path[0], 0, sizeof(work->path[0]));
+ 	if (cm_req_has_alt_path(req_msg))
+ 		memset(&work->path[1], 0, sizeof(work->path[1]));
+ 	grh = rdma_ah_read_grh(&cm_id_priv->av.ah_attr);
++>>>>>>> 5a3dc3237243 (IB/cm: Fix memory corruption in handling CM request)
  	ret = ib_get_cached_gid(work->port->cm_dev->ib_device,
  				work->port->port_num,
 -				grh->sgid_index,
 +				cm_id_priv->av.ah_attr.grh.sgid_index,
  				&gid, &gid_attr);
  	if (!ret) {
  		if (gid_attr.ndev) {
* Unmerged path drivers/infiniband/core/cm.c
