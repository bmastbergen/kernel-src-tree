mlxsw: spectrum: Remove support for bypass bridge port attributes/vlan set

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Arkadi Sharshevsky <arkadis@mellanox.com>
commit 10e23eb299fa39c6f343bffc9e3d77c7d9f0492f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/10e23eb2.failed

The bridge port attributes/vlan for mlxsw devices should be set only
from bridge code. The vlans are synced totally with the bridge so
there is no need to special dump support.

	Signed-off-by: Arkadi Sharshevsky <arkadis@mellanox.com>
	Reviewed-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 10e23eb299fa39c6f343bffc9e3d77c7d9f0492f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum.c
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum.c
index 4d14e78f2e24,db7127abce44..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
@@@ -1761,11 -1758,8 +1761,16 @@@ static const struct net_device_ops mlxs
  	.ndo_vlan_rx_kill_vid	= mlxsw_sp_port_kill_vid,
  	.ndo_fdb_add		= switchdev_port_fdb_add,
  	.ndo_fdb_del		= switchdev_port_fdb_del,
++<<<<<<< HEAD
 +	.extended.ndo_fdb_dump	= switchdev_port_fdb_dump,
 +	.ndo_bridge_setlink	= switchdev_port_bridge_setlink,
 +	.ndo_bridge_getlink	= switchdev_port_bridge_getlink,
 +	.ndo_bridge_dellink	= switchdev_port_bridge_dellink,
 +	.extended.ndo_get_phys_port_name	= mlxsw_sp_port_get_phys_port_name,
++=======
+ 	.ndo_fdb_dump		= switchdev_port_fdb_dump,
+ 	.ndo_get_phys_port_name	= mlxsw_sp_port_get_phys_port_name,
++>>>>>>> 10e23eb299fa (mlxsw: spectrum: Remove support for bypass bridge port attributes/vlan set)
  };
  
  static void mlxsw_sp_port_get_drvinfo(struct net_device *dev,
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
index a7736231096b,6257b0b8c8d1..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
@@@ -52,48 -52,390 +52,52 @@@
  #include "core.h"
  #include "reg.h"
  
 -struct mlxsw_sp_bridge_ops;
 -
 -struct mlxsw_sp_bridge {
 -	struct mlxsw_sp *mlxsw_sp;
 -	struct {
 -		struct delayed_work dw;
 -#define MLXSW_SP_DEFAULT_LEARNING_INTERVAL 100
 -		unsigned int interval; /* ms */
 -	} fdb_notify;
 -#define MLXSW_SP_MIN_AGEING_TIME 10
 -#define MLXSW_SP_MAX_AGEING_TIME 1000000
 -#define MLXSW_SP_DEFAULT_AGEING_TIME 300
 -	u32 ageing_time;
 -	bool vlan_enabled_exists;
 -	struct list_head bridges_list;
 -	struct list_head mids_list;
 -	DECLARE_BITMAP(mids_bitmap, MLXSW_SP_MID_MAX);
 -	const struct mlxsw_sp_bridge_ops *bridge_8021q_ops;
 -	const struct mlxsw_sp_bridge_ops *bridge_8021d_ops;
 -};
 -
 -struct mlxsw_sp_bridge_device {
 -	struct net_device *dev;
 -	struct list_head list;
 -	struct list_head ports_list;
 -	u8 vlan_enabled:1,
 -	   multicast_enabled:1;
 -	const struct mlxsw_sp_bridge_ops *ops;
 -};
 -
 -struct mlxsw_sp_bridge_port {
 -	struct net_device *dev;
 -	struct mlxsw_sp_bridge_device *bridge_device;
 -	struct list_head list;
 -	struct list_head vlans_list;
 -	unsigned int ref_count;
 -	u8 stp_state;
 -	unsigned long flags;
 -	bool mrouter;
 -	bool lagged;
 -	union {
 -		u16 lag_id;
 -		u16 system_port;
 -	};
 -};
 -
 -struct mlxsw_sp_bridge_vlan {
 -	struct list_head list;
 -	struct list_head port_vlan_list;
 -	u16 vid;
 -};
 -
 -struct mlxsw_sp_bridge_ops {
 -	int (*port_join)(struct mlxsw_sp_bridge_device *bridge_device,
 -			 struct mlxsw_sp_bridge_port *bridge_port,
 -			 struct mlxsw_sp_port *mlxsw_sp_port);
 -	void (*port_leave)(struct mlxsw_sp_bridge_device *bridge_device,
 -			   struct mlxsw_sp_bridge_port *bridge_port,
 -			   struct mlxsw_sp_port *mlxsw_sp_port);
 -	struct mlxsw_sp_fid *
 -		(*fid_get)(struct mlxsw_sp_bridge_device *bridge_device,
 -			   u16 vid);
 -};
 -
 -static int
 -mlxsw_sp_bridge_port_fdb_flush(struct mlxsw_sp *mlxsw_sp,
 -			       struct mlxsw_sp_bridge_port *bridge_port,
 -			       u16 fid_index);
 -
 -static struct mlxsw_sp_bridge_device *
 -mlxsw_sp_bridge_device_find(const struct mlxsw_sp_bridge *bridge,
 -			    const struct net_device *br_dev)
 +static u16 mlxsw_sp_port_vid_to_fid_get(struct mlxsw_sp_port *mlxsw_sp_port,
 +					u16 vid)
  {
 -	struct mlxsw_sp_bridge_device *bridge_device;
 +	struct mlxsw_sp_fid *f = mlxsw_sp_vport_fid_get(mlxsw_sp_port);
 +	u16 fid = vid;
  
 -	list_for_each_entry(bridge_device, &bridge->bridges_list, list)
 -		if (bridge_device->dev == br_dev)
 -			return bridge_device;
 +	fid = f ? f->fid : fid;
  
 -	return NULL;
 -}
 +	if (!fid)
 +		fid = mlxsw_sp_port->pvid;
  
 -static struct mlxsw_sp_bridge_device *
 -mlxsw_sp_bridge_device_create(struct mlxsw_sp_bridge *bridge,
 -			      struct net_device *br_dev)
 -{
 -	struct device *dev = bridge->mlxsw_sp->bus_info->dev;
 -	struct mlxsw_sp_bridge_device *bridge_device;
 -	bool vlan_enabled = br_vlan_enabled(br_dev);
 -
 -	if (vlan_enabled && bridge->vlan_enabled_exists) {
 -		dev_err(dev, "Only one VLAN-aware bridge is supported\n");
 -		return ERR_PTR(-EINVAL);
 -	}
 -
 -	bridge_device = kzalloc(sizeof(*bridge_device), GFP_KERNEL);
 -	if (!bridge_device)
 -		return ERR_PTR(-ENOMEM);
 -
 -	bridge_device->dev = br_dev;
 -	bridge_device->vlan_enabled = vlan_enabled;
 -	bridge_device->multicast_enabled = br_multicast_enabled(br_dev);
 -	INIT_LIST_HEAD(&bridge_device->ports_list);
 -	if (vlan_enabled) {
 -		bridge->vlan_enabled_exists = true;
 -		bridge_device->ops = bridge->bridge_8021q_ops;
 -	} else {
 -		bridge_device->ops = bridge->bridge_8021d_ops;
 -	}
 -	list_add(&bridge_device->list, &bridge->bridges_list);
 -
 -	return bridge_device;
 +	return fid;
  }
  
 -static void
 -mlxsw_sp_bridge_device_destroy(struct mlxsw_sp_bridge *bridge,
 -			       struct mlxsw_sp_bridge_device *bridge_device)
 +static struct mlxsw_sp_port *
 +mlxsw_sp_port_orig_get(struct net_device *dev,
 +		       struct mlxsw_sp_port *mlxsw_sp_port)
  {
 -	list_del(&bridge_device->list);
 -	if (bridge_device->vlan_enabled)
 -		bridge->vlan_enabled_exists = false;
 -	WARN_ON(!list_empty(&bridge_device->ports_list));
 -	kfree(bridge_device);
 -}
 -
 -static struct mlxsw_sp_bridge_device *
 -mlxsw_sp_bridge_device_get(struct mlxsw_sp_bridge *bridge,
 -			   struct net_device *br_dev)
 -{
 -	struct mlxsw_sp_bridge_device *bridge_device;
 -
 -	bridge_device = mlxsw_sp_bridge_device_find(bridge, br_dev);
 -	if (bridge_device)
 -		return bridge_device;
 -
 -	return mlxsw_sp_bridge_device_create(bridge, br_dev);
 -}
 -
 -static void
 -mlxsw_sp_bridge_device_put(struct mlxsw_sp_bridge *bridge,
 -			   struct mlxsw_sp_bridge_device *bridge_device)
 -{
 -	if (list_empty(&bridge_device->ports_list))
 -		mlxsw_sp_bridge_device_destroy(bridge, bridge_device);
 -}
 -
 -static struct mlxsw_sp_bridge_port *
 -__mlxsw_sp_bridge_port_find(const struct mlxsw_sp_bridge_device *bridge_device,
 -			    const struct net_device *brport_dev)
 -{
 -	struct mlxsw_sp_bridge_port *bridge_port;
 -
 -	list_for_each_entry(bridge_port, &bridge_device->ports_list, list) {
 -		if (bridge_port->dev == brport_dev)
 -			return bridge_port;
 -	}
 -
 -	return NULL;
 -}
 -
 -static struct mlxsw_sp_bridge_port *
 -mlxsw_sp_bridge_port_find(struct mlxsw_sp_bridge *bridge,
 -			  struct net_device *brport_dev)
 -{
 -	struct net_device *br_dev = netdev_master_upper_dev_get(brport_dev);
 -	struct mlxsw_sp_bridge_device *bridge_device;
 -
 -	if (!br_dev)
 -		return NULL;
 -
 -	bridge_device = mlxsw_sp_bridge_device_find(bridge, br_dev);
 -	if (!bridge_device)
 -		return NULL;
 -
 -	return __mlxsw_sp_bridge_port_find(bridge_device, brport_dev);
 -}
 -
 -static struct mlxsw_sp_bridge_port *
 -mlxsw_sp_bridge_port_create(struct mlxsw_sp_bridge_device *bridge_device,
 -			    struct net_device *brport_dev)
 -{
 -	struct mlxsw_sp_bridge_port *bridge_port;
 -	struct mlxsw_sp_port *mlxsw_sp_port;
 -
 -	bridge_port = kzalloc(sizeof(*bridge_port), GFP_KERNEL);
 -	if (!bridge_port)
 -		return NULL;
 -
 -	mlxsw_sp_port = mlxsw_sp_port_dev_lower_find(brport_dev);
 -	bridge_port->lagged = mlxsw_sp_port->lagged;
 -	if (bridge_port->lagged)
 -		bridge_port->lag_id = mlxsw_sp_port->lag_id;
 -	else
 -		bridge_port->system_port = mlxsw_sp_port->local_port;
 -	bridge_port->dev = brport_dev;
 -	bridge_port->bridge_device = bridge_device;
 -	bridge_port->stp_state = BR_STATE_DISABLED;
 -	bridge_port->flags = BR_LEARNING | BR_FLOOD | BR_LEARNING_SYNC;
 -	INIT_LIST_HEAD(&bridge_port->vlans_list);
 -	list_add(&bridge_port->list, &bridge_device->ports_list);
 -	bridge_port->ref_count = 1;
 -
 -	return bridge_port;
 -}
 -
 -static void
 -mlxsw_sp_bridge_port_destroy(struct mlxsw_sp_bridge_port *bridge_port)
 -{
 -	list_del(&bridge_port->list);
 -	WARN_ON(!list_empty(&bridge_port->vlans_list));
 -	kfree(bridge_port);
 -}
 -
 -static bool
 -mlxsw_sp_bridge_port_should_destroy(const struct mlxsw_sp_bridge_port *
 -				    bridge_port)
 -{
 -	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_lower_get(bridge_port->dev);
 -
 -	/* In case ports were pulled from out of a bridged LAG, then
 -	 * it's possible the reference count isn't zero, yet the bridge
 -	 * port should be destroyed, as it's no longer an upper of ours.
 -	 */
 -	if (!mlxsw_sp && list_empty(&bridge_port->vlans_list))
 -		return true;
 -	else if (bridge_port->ref_count == 0)
 -		return true;
 -	else
 -		return false;
 -}
 -
 -static struct mlxsw_sp_bridge_port *
 -mlxsw_sp_bridge_port_get(struct mlxsw_sp_bridge *bridge,
 -			 struct net_device *brport_dev)
 -{
 -	struct net_device *br_dev = netdev_master_upper_dev_get(brport_dev);
 -	struct mlxsw_sp_bridge_device *bridge_device;
 -	struct mlxsw_sp_bridge_port *bridge_port;
 -	int err;
 -
 -	bridge_port = mlxsw_sp_bridge_port_find(bridge, brport_dev);
 -	if (bridge_port) {
 -		bridge_port->ref_count++;
 -		return bridge_port;
 -	}
 -
 -	bridge_device = mlxsw_sp_bridge_device_get(bridge, br_dev);
 -	if (IS_ERR(bridge_device))
 -		return ERR_CAST(bridge_device);
 -
 -	bridge_port = mlxsw_sp_bridge_port_create(bridge_device, brport_dev);
 -	if (!bridge_port) {
 -		err = -ENOMEM;
 -		goto err_bridge_port_create;
 -	}
 -
 -	return bridge_port;
 -
 -err_bridge_port_create:
 -	mlxsw_sp_bridge_device_put(bridge, bridge_device);
 -	return ERR_PTR(err);
 -}
 -
 -static void mlxsw_sp_bridge_port_put(struct mlxsw_sp_bridge *bridge,
 -				     struct mlxsw_sp_bridge_port *bridge_port)
 -{
 -	struct mlxsw_sp_bridge_device *bridge_device;
 -
 -	bridge_port->ref_count--;
 -	if (!mlxsw_sp_bridge_port_should_destroy(bridge_port))
 -		return;
 -	bridge_device = bridge_port->bridge_device;
 -	mlxsw_sp_bridge_port_destroy(bridge_port);
 -	mlxsw_sp_bridge_device_put(bridge, bridge_device);
 -}
 -
 -static struct mlxsw_sp_port_vlan *
 -mlxsw_sp_port_vlan_find_by_bridge(struct mlxsw_sp_port *mlxsw_sp_port,
 -				  const struct mlxsw_sp_bridge_device *
 -				  bridge_device,
 -				  u16 vid)
 -{
 -	struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;
 -
 -	list_for_each_entry(mlxsw_sp_port_vlan, &mlxsw_sp_port->vlans_list,
 -			    list) {
 -		if (!mlxsw_sp_port_vlan->bridge_port)
 -			continue;
 -		if (mlxsw_sp_port_vlan->bridge_port->bridge_device !=
 -		    bridge_device)
 -			continue;
 -		if (bridge_device->vlan_enabled &&
 -		    mlxsw_sp_port_vlan->vid != vid)
 -			continue;
 -		return mlxsw_sp_port_vlan;
 -	}
 -
 -	return NULL;
 -}
 -
 -static struct mlxsw_sp_port_vlan*
 -mlxsw_sp_port_vlan_find_by_fid(struct mlxsw_sp_port *mlxsw_sp_port,
 -			       u16 fid_index)
 -{
 -	struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;
 -
 -	list_for_each_entry(mlxsw_sp_port_vlan, &mlxsw_sp_port->vlans_list,
 -			    list) {
 -		struct mlxsw_sp_fid *fid = mlxsw_sp_port_vlan->fid;
 -
 -		if (fid && mlxsw_sp_fid_index(fid) == fid_index)
 -			return mlxsw_sp_port_vlan;
 -	}
 -
 -	return NULL;
 -}
 -
 -static struct mlxsw_sp_bridge_vlan *
 -mlxsw_sp_bridge_vlan_find(const struct mlxsw_sp_bridge_port *bridge_port,
 -			  u16 vid)
 -{
 -	struct mlxsw_sp_bridge_vlan *bridge_vlan;
 -
 -	list_for_each_entry(bridge_vlan, &bridge_port->vlans_list, list) {
 -		if (bridge_vlan->vid == vid)
 -			return bridge_vlan;
 +	struct mlxsw_sp_port *mlxsw_sp_vport;
 +	struct mlxsw_sp_fid *fid;
 +	u16 vid;
++<<<<<<< HEAD
++=======
++};
++>>>>>>> 10e23eb299fa (mlxsw: spectrum: Remove support for bypass bridge port attributes/vlan set)
 +
 +	if (netif_is_bridge_master(dev)) {
 +		fid = mlxsw_sp_vfid_find(mlxsw_sp_port->mlxsw_sp,
 +					 dev);
 +		if (fid) {
 +			mlxsw_sp_vport =
 +				mlxsw_sp_port_vport_find_by_fid(mlxsw_sp_port,
 +								fid->fid);
 +			WARN_ON(!mlxsw_sp_vport);
 +			return mlxsw_sp_vport;
 +		}
  	}
  
 -	return NULL;
 -}
 -
 -static struct mlxsw_sp_bridge_vlan *
 -mlxsw_sp_bridge_vlan_create(struct mlxsw_sp_bridge_port *bridge_port, u16 vid)
 -{
 -	struct mlxsw_sp_bridge_vlan *bridge_vlan;
 -
 -	bridge_vlan = kzalloc(sizeof(*bridge_vlan), GFP_KERNEL);
 -	if (!bridge_vlan)
 -		return NULL;
 -
 -	INIT_LIST_HEAD(&bridge_vlan->port_vlan_list);
 -	bridge_vlan->vid = vid;
 -	list_add(&bridge_vlan->list, &bridge_port->vlans_list);
 -
 -	return bridge_vlan;
 -}
 -
 -static void
 -mlxsw_sp_bridge_vlan_destroy(struct mlxsw_sp_bridge_vlan *bridge_vlan)
 -{
 -	list_del(&bridge_vlan->list);
 -	WARN_ON(!list_empty(&bridge_vlan->port_vlan_list));
 -	kfree(bridge_vlan);
 -}
 -
 -static struct mlxsw_sp_bridge_vlan *
 -mlxsw_sp_bridge_vlan_get(struct mlxsw_sp_bridge_port *bridge_port, u16 vid)
 -{
 -	struct mlxsw_sp_bridge_vlan *bridge_vlan;
 -
 -	bridge_vlan = mlxsw_sp_bridge_vlan_find(bridge_port, vid);
 -	if (bridge_vlan)
 -		return bridge_vlan;
 -
 -	return mlxsw_sp_bridge_vlan_create(bridge_port, vid);
 -}
 -
 -static void mlxsw_sp_bridge_vlan_put(struct mlxsw_sp_bridge_vlan *bridge_vlan)
 -{
 -	if (list_empty(&bridge_vlan->port_vlan_list))
 -		mlxsw_sp_bridge_vlan_destroy(bridge_vlan);
 -}
 -
 -static void mlxsw_sp_port_bridge_flags_get(struct mlxsw_sp_bridge *bridge,
 -					   struct net_device *dev,
 -					   unsigned long *brport_flags)
 -{
 -	struct mlxsw_sp_bridge_port *bridge_port;
 +	if (!is_vlan_dev(dev))
 +		return mlxsw_sp_port;
  
 -	bridge_port = mlxsw_sp_bridge_port_find(bridge, dev);
 -	if (WARN_ON(!bridge_port))
 -		return;
 +	vid = vlan_dev_vlan_id(dev);
 +	mlxsw_sp_vport = mlxsw_sp_port_vport_find(mlxsw_sp_port, vid);
 +	WARN_ON(!mlxsw_sp_vport);
  
 -	memcpy(brport_flags, &bridge_port->flags, sizeof(*brport_flags));
 +	return mlxsw_sp_vport;
  }
  
  static int mlxsw_sp_port_attr_get(struct net_device *dev,
@@@ -676,21 -996,11 +680,25 @@@ static int mlxsw_sp_port_vlan_add(struc
  	if (err)
  		goto err_port_pvid_set;
  
 -	err = mlxsw_sp_port_vlan_bridge_join(mlxsw_sp_port_vlan, bridge_port);
 +	err = mlxsw_sp_port_vid_learning_set(mlxsw_sp_port, vid,
 +					     mlxsw_sp_port->learning);
 +	if (err)
 +		goto err_port_vid_learning_set;
 +
++<<<<<<< HEAD
 +	err = mlxsw_sp_port_vid_stp_set(mlxsw_sp_port, vid,
 +					mlxsw_sp_port->stp_state);
  	if (err)
 -		goto err_port_vlan_bridge_join;
 +		goto err_port_vid_stp_set;
  
 +	if (is_untagged)
 +		__set_bit(vid, mlxsw_sp_port->untagged_vlans);
 +	else
 +		__clear_bit(vid, mlxsw_sp_port->untagged_vlans);
 +	__set_bit(vid, mlxsw_sp_port->active_vlans);
++=======
+ 	bridge_vlan = mlxsw_sp_bridge_vlan_find(bridge_port, vid);
++>>>>>>> 10e23eb299fa (mlxsw: spectrum: Remove support for bypass bridge port attributes/vlan set)
  
  	return 0;
  
@@@ -1231,35 -1625,6 +1239,38 @@@ out
  	return stored_err ? stored_err : err;
  }
  
++<<<<<<< HEAD
 +static int mlxsw_sp_port_vlan_dump(struct mlxsw_sp_port *mlxsw_sp_port,
 +				   struct switchdev_obj_port_vlan *vlan,
 +				   switchdev_obj_dump_cb_t *cb)
 +{
 +	u16 vid;
 +	int err = 0;
 +
 +	if (mlxsw_sp_port_is_vport(mlxsw_sp_port)) {
 +		vlan->flags = 0;
 +		vlan->vid_begin = mlxsw_sp_vport_vid_get(mlxsw_sp_port);
 +		vlan->vid_end = mlxsw_sp_vport_vid_get(mlxsw_sp_port);
 +		return cb(&vlan->obj);
 +	}
 +
 +	for_each_set_bit(vid, mlxsw_sp_port->active_vlans, VLAN_N_VID) {
 +		vlan->flags = 0;
 +		if (vid == mlxsw_sp_port->pvid)
 +			vlan->flags |= BRIDGE_VLAN_INFO_PVID;
 +		if (test_bit(vid, mlxsw_sp_port->untagged_vlans))
 +			vlan->flags |= BRIDGE_VLAN_INFO_UNTAGGED;
 +		vlan->vid_begin = vid;
 +		vlan->vid_end = vid;
 +		err = cb(&vlan->obj);
 +		if (err)
 +			break;
 +	}
 +	return err;
 +}
 +
++=======
++>>>>>>> 10e23eb299fa (mlxsw: spectrum: Remove support for bypass bridge port attributes/vlan set)
  static int mlxsw_sp_port_obj_dump(struct net_device *dev,
  				  struct switchdev_obj *obj,
  				  switchdev_obj_dump_cb_t *cb)
@@@ -1267,19 -1632,10 +1278,15 @@@
  	struct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);
  	int err = 0;
  
 +	mlxsw_sp_port = mlxsw_sp_port_orig_get(obj->orig_dev, mlxsw_sp_port);
 +	if (!mlxsw_sp_port)
 +		return -EINVAL;
 +
  	switch (obj->id) {
- 	case SWITCHDEV_OBJ_ID_PORT_VLAN:
- 		err = mlxsw_sp_port_vlan_dump(mlxsw_sp_port,
- 					      SWITCHDEV_OBJ_PORT_VLAN(obj), cb);
- 		break;
  	case SWITCHDEV_OBJ_ID_PORT_FDB:
  		err = mlxsw_sp_port_fdb_dump(mlxsw_sp_port,
 -					     SWITCHDEV_OBJ_PORT_FDB(obj), cb);
 +					     SWITCHDEV_OBJ_PORT_FDB(obj), cb,
 +					     obj->orig_dev);
  		break;
  	default:
  		err = -EOPNOTSUPP;
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum.c
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
