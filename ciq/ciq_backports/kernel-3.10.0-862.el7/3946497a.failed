qed: Pass vf_params when creating a queue-cid

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Mintz, Yuval <Yuval.Mintz@cavium.com>
commit 3946497aff655b9bb1807ef7e2ecbe799e6d832a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/3946497a.failed

We're going to need additional information for queue-cids
that a PF creates for its VFs, so start by refactoring existing
logic used for initializing said struct into receiving a structure
encapsulating the VF-specific information that needs to be provided.

This also introduces QED_QUEUE_CID_SELF - each queue-cid would hold
an indication to whether it belongs to the hw-function holding it
[whether that's a PF or a VF], or else what's the VF id it belongs
to.

	Signed-off-by: Yuval Mintz <Yuval.Mintz@cavium.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3946497aff655b9bb1807ef7e2ecbe799e6d832a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qed/qed_l2.c
#	drivers/net/ethernet/qlogic/qed/qed_l2.h
#	drivers/net/ethernet/qlogic/qed/qed_sriov.c
diff --cc drivers/net/ethernet/qlogic/qed/qed_l2.c
index f852981b5922,150a8e9354b7..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_l2.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_l2.c
@@@ -95,10 -181,24 +95,31 @@@ _qed_eth_queue_to_cid(struct qed_hwfn *
  
  	p_cid->opaque_fid = opaque_fid;
  	p_cid->cid = cid;
++<<<<<<< HEAD
 +	p_cid->vf_qid = vf_qid;
 +	p_cid->rel = *p_params;
 +	p_cid->p_owner = p_hwfn;
 +
++=======
+ 	p_cid->p_owner = p_hwfn;
+ 
+ 	/* Fill in parameters */
+ 	p_cid->rel.vport_id = p_params->vport_id;
+ 	p_cid->rel.queue_id = p_params->queue_id;
+ 	p_cid->rel.stats_id = p_params->stats_id;
+ 	p_cid->sb_igu_id = p_params->p_sb->igu_sb_id;
+ 	p_cid->sb_idx = p_params->sb_idx;
+ 
+ 	/* Fill-in bits related to VFs' queues if information was provided */
+ 	if (p_vf_params) {
+ 		p_cid->vfid = p_vf_params->vfid;
+ 		p_cid->vf_qid = p_vf_params->vf_qid;
+ 		p_cid->b_legacy_vf = p_vf_params->vf_legacy;
+ 	} else {
+ 		p_cid->vfid = QED_QUEUE_CID_SELF;
+ 	}
+ 
++>>>>>>> 3946497aff65 (qed: Pass vf_params when creating a queue-cid)
  	/* Don't try calculating the absolute indices for VFs */
  	if (IS_VF(p_hwfn->cdev)) {
  		p_cid->abs = p_cid->rel;
@@@ -129,15 -229,6 +150,18 @@@
  		p_cid->abs.stats_id = p_cid->rel.stats_id;
  	}
  
++<<<<<<< HEAD
 +	/* SBs relevant information was already provided as absolute */
 +	p_cid->abs.sb = p_cid->rel.sb;
 +	p_cid->abs.sb_idx = p_cid->rel.sb_idx;
 +
 +	/* This is tricky - we're actually interested in whehter this is a PF
 +	 * entry meant for the VF.
 +	 */
 +	if (!b_is_same)
 +		p_cid->is_vf = true;
++=======
++>>>>>>> 3946497aff65 (qed: Pass vf_params when creating a queue-cid)
  out:
  	DP_VERBOSE(p_hwfn,
  		   QED_MSG_SP,
diff --cc drivers/net/ethernet/qlogic/qed/qed_l2.h
index 93cb932ef663,43aeaa882828..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_l2.h
+++ b/drivers/net/ethernet/qlogic/qed/qed_l2.h
@@@ -268,14 -277,46 +268,48 @@@ void qed_get_vport_stats(struct qed_de
  
  void qed_reset_vport_stats(struct qed_dev *cdev);
  
++<<<<<<< HEAD
++=======
+ #define MAX_QUEUES_PER_QZONE    (sizeof(unsigned long) * 8)
+ #define QED_QUEUE_CID_SELF	(0xff)
+ 
+ /* Almost identical to the qed_queue_start_common_params,
+  * but here we maintain the SB index in IGU CAM.
+  */
+ struct qed_queue_cid_params {
+ 	u8 vport_id;
+ 	u16 queue_id;
+ 	u8 stats_id;
+ };
+ 
+ /* Additional parameters required for initialization of the queue_cid
+  * and are relevant only for a PF initializing one for its VFs.
+  */
+ struct qed_queue_cid_vf_params {
+ 	/* Should match the VF's relative index */
+ 	u8 vfid;
+ 
+ 	/* 0-based queue index. Should reflect the relative qzone the
+ 	 * VF thinks is associated with it [in its range].
+ 	 */
+ 	u8 vf_qid;
+ 
+ 	/* Indicates a VF is legacy, making it differ in:
+ 	 *  - Producers would be placed in a different place.
+ 	 */
+ 	bool vf_legacy;
+ 
+ };
+ 
++>>>>>>> 3946497aff65 (qed: Pass vf_params when creating a queue-cid)
  struct qed_queue_cid {
 -	/* For stats-id, the `rel' is actually absolute as well */
 -	struct qed_queue_cid_params rel;
 -	struct qed_queue_cid_params abs;
 -
 -	/* These have no 'relative' meaning */
 -	u16 sb_igu_id;
 -	u8 sb_idx;
 -
 +	/* 'Relative' is a relative term ;-). Usually the indices [not counting
 +	 * SBs] would be PF-relative, but there are some cases where that isn't
 +	 * the case - specifically for a PF configuring its VF indices it's
 +	 * possible some fields [E.g., stats-id] in 'rel' would already be abs.
 +	 */
 +	struct qed_queue_start_common_params rel;
 +	struct qed_queue_start_common_params abs;
  	u32 cid;
  	u16 opaque_fid;
  
diff --cc drivers/net/ethernet/qlogic/qed/qed_sriov.c
index c231e788de76,7ea00bf3e9b8..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_sriov.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_sriov.c
@@@ -2004,13 -1974,18 +2009,15 @@@ static void qed_iov_vf_mbx_start_rxq(st
  	params.queue_id = p_queue->fw_rx_qid;
  	params.vport_id = vf->vport_id;
  	params.stats_id = vf->abs_vf_id + 0x10;
 -	/* Since IGU index is passed via sb_info, construct a dummy one */
 -	memset(&sb_dummy, 0, sizeof(sb_dummy));
 -	sb_dummy.igu_sb_id = req->hw_sb;
 -	params.p_sb = &sb_dummy;
 +	params.sb = req->hw_sb;
  	params.sb_idx = req->sb_index;
  
- 	p_queue->p_rx_cid = _qed_eth_queue_to_cid(p_hwfn,
- 						  vf->opaque_fid,
- 						  p_queue->fw_cid,
- 						  req->rx_qid, &params);
+ 	memset(&vf_params, 0, sizeof(vf_params));
+ 	vf_params.vfid = vf->relative_vf_id;
+ 	vf_params.vf_qid = (u8)req->rx_qid;
+ 	vf_params.vf_legacy = b_legacy_vf;
+ 	p_queue->p_rx_cid = qed_eth_queue_to_cid(p_hwfn, vf->opaque_fid,
+ 						 &params, &vf_params);
  	if (!p_queue->p_rx_cid)
  		goto out;
  
@@@ -2095,6 -2280,8 +2098,11 @@@ static void qed_iov_vf_mbx_start_txq(st
  	u8 status = PFVF_STATUS_NO_RESOURCE;
  	struct vfpf_start_txq_tlv *req;
  	struct qed_vf_q_info *p_queue;
++<<<<<<< HEAD
++=======
+ 	struct qed_sb_info sb_dummy;
+ 	bool b_vf_legacy = false;
++>>>>>>> 3946497aff65 (qed: Pass vf_params when creating a queue-cid)
  	int rc;
  	u16 pq;
  
@@@ -2112,13 -2303,21 +2124,17 @@@
  	params.queue_id = p_queue->fw_tx_qid;
  	params.vport_id = vf->vport_id;
  	params.stats_id = vf->abs_vf_id + 0x10;
 -
 -	/* Since IGU index is passed via sb_info, construct a dummy one */
 -	memset(&sb_dummy, 0, sizeof(sb_dummy));
 -	sb_dummy.igu_sb_id = req->hw_sb;
 -	params.p_sb = &sb_dummy;
 +	params.sb = req->hw_sb;
  	params.sb_idx = req->sb_index;
  
- 	p_queue->p_tx_cid = _qed_eth_queue_to_cid(p_hwfn,
- 						  vf->opaque_fid,
- 						  p_queue->fw_cid,
- 						  req->tx_qid, &params);
+ 	memset(&vf_params, 0, sizeof(vf_params));
+ 	vf_params.vfid = vf->relative_vf_id;
+ 	vf_params.vf_qid = (u8)req->tx_qid;
+ 	vf_params.vf_legacy = b_vf_legacy;
+ 
+ 	p_queue->p_tx_cid = qed_eth_queue_to_cid(p_hwfn,
+ 						 vf->opaque_fid,
+ 						 &params, &vf_params);
  	if (!p_queue->p_tx_cid)
  		goto out;
  
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_l2.c
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_l2.h
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_sriov.c
