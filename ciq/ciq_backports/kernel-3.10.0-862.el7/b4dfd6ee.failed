nvme_fc: fix double calls to nvme_cleanup_cmd()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [nvme] fc: fix double calls to nvme_cleanup_cmd() (David Milburn) [1457880 1456486 1454365]
Rebuild_FUZZ: 94.38%
commit-author James Smart <jsmart2021@gmail.com>
commit b4dfd6ee997d6d5d30b8ace5593ad1a9134418d6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b4dfd6ee.failed

Current fc transport code, on io termination, is calling
nvme_cleanup_cmd() followed by the transport dma unmap routine
which also calls nvme_cleanup_cmd(). Which means two kfrees occur
on the same address, raising havoc. This resulted in odd data errors,
effectively corruption..

Fix by removing the extraneous double calls. Call now occurs only in
teardown paths and as part of dma unmap routine.

	Signed-off-by: James Smart <james.smart@broadcom.com>
	Reviewed-by: Ewan D. Milne <emilne@redhat.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit b4dfd6ee997d6d5d30b8ace5593ad1a9134418d6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/fc.c
diff --cc drivers/nvme/host/fc.c
index bff7f964238e,fe6f5b71979c..000000000000
--- a/drivers/nvme/host/fc.c
+++ b/drivers/nvme/host/fc.c
@@@ -1811,13 -1957,8 +1811,15 @@@ nvme_fc_start_fcp_op(struct nvme_fc_ctr
  					queue->lldd_handle, &op->fcp_req);
  
  	if (ret) {
++<<<<<<< HEAD
 +		dev_err(ctrl->dev,
 +			"Send nvme command failed - lldd returned %d.\n", ret);
 +
 +		if (op->rq) {			/* normal request */
++=======
+ 		if (op->rq)			/* normal request */
++>>>>>>> b4dfd6ee997d (nvme_fc: fix double calls to nvme_cleanup_cmd())
  			nvme_fc_unmap_data(ctrl, op->rq, op);
- 			nvme_cleanup_cmd(op->rq);
- 		}
  		/* else - aen. no cleanup needed */
  
  		nvme_fc_ctrl_put(ctrl);
@@@ -1884,6 -2067,22 +1886,25 @@@ nvme_fc_submit_async_event(struct nvme_
  }
  
  static void
++<<<<<<< HEAD
++=======
+ __nvme_fc_final_op_cleanup(struct request *rq)
+ {
+ 	struct nvme_fc_fcp_op *op = blk_mq_rq_to_pdu(rq);
+ 	struct nvme_fc_ctrl *ctrl = op->ctrl;
+ 
+ 	atomic_set(&op->state, FCPOP_STATE_IDLE);
+ 	op->flags &= ~(FCOP_FLAGS_TERMIO | FCOP_FLAGS_RELEASED |
+ 			FCOP_FLAGS_COMPLETE);
+ 
+ 	nvme_fc_unmap_data(ctrl, rq, op);
+ 	nvme_complete_rq(rq);
+ 	nvme_fc_ctrl_put(ctrl);
+ 
+ }
+ 
+ static void
++>>>>>>> b4dfd6ee997d (nvme_fc: fix double calls to nvme_cleanup_cmd())
  nvme_fc_complete_rq(struct request *rq)
  {
  	struct nvme_fc_fcp_op *op = blk_mq_rq_to_pdu(rq);
* Unmerged path drivers/nvme/host/fc.c
