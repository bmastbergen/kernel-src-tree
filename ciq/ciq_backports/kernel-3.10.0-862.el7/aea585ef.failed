sysfs: remove sysfs_buffer->needs_read_fill

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Tejun Heo <tj@kernel.org>
commit aea585ef8fa6516395022e9d2fed6ec5014128bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/aea585ef.failed

->needs_read_fill is used to implement the following behaviors.

1. Ensure buffer filling on the first read.
2. Force buffer filling after a write.
3. Force buffer filling after a successful poll.

However, #2 and #3 don't really work as sysfs doesn't reset file
position.  While the read buffer would be refilled, the next read
would continue from the position after the last read or write,
requiring an explicit seek to the start for it to be useful, which
makes ->needs_read_fill superflous as read buffer is always refilled
if f_pos == 0.

Update sysfs_read_file() to test buffer->page for #1 instead and
remove ->needs_read_fill.  While this changes behavior in extreme
corner cases - e.g. re-reading a sysfs file after seeking to non-zero
position after a write or poll, it's highly unlikely to lead to actual
breakage.  This change is to prepare for using seq_file in the read
path.

While at it, reformat a comment in fill_write_buffer().

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Cc: Kay Sievers <kay@vrfy.org>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit aea585ef8fa6516395022e9d2fed6ec5014128bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/sysfs/file.c
diff --cc fs/sysfs/file.c
index 3de7949b1b72,e2fafc0a9b36..000000000000
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@@ -44,11 -44,9 +44,10 @@@ struct sysfs_open_dirent 
  
  struct sysfs_buffer {
  	size_t			count;
 -	char			*page;
 -	const struct sysfs_ops	*ops;
 +	loff_t			pos;
 +	char			* page;
 +	const struct sysfs_ops	* ops;
  	struct mutex		mutex;
- 	int			needs_read_fill;
  	int			event;
  	struct list_head	list;
  };
@@@ -131,8 -127,12 +128,17 @@@ sysfs_read_file(struct file *file, cha
  	ssize_t retval = 0;
  
  	mutex_lock(&buffer->mutex);
++<<<<<<< HEAD
 +	if (buffer->needs_read_fill || *ppos == 0) {
 +		retval = fill_read_buffer(file->f_path.dentry,buffer);
++=======
+ 	/*
+ 	 * Fill on zero offset and the first read so that silly things like
+ 	 * "dd bs=1 skip=N" can work on sysfs files.
+ 	 */
+ 	if (*ppos == 0 || !buffer->page) {
+ 		retval = fill_read_buffer(file->f_path.dentry, buffer);
++>>>>>>> aea585ef8fa6 (sysfs: remove sysfs_buffer->needs_read_fill)
  		if (retval)
  			goto out;
  	}
@@@ -166,10 -166,12 +172,19 @@@ static int fill_write_buffer(struct sys
  
  	if (count >= PAGE_SIZE)
  		count = PAGE_SIZE - 1;
++<<<<<<< HEAD
 +	error = copy_from_user(buffer->page,buf,count);
 +	buffer->needs_read_fill = 1;
 +	/* if buf is assumed to contain a string, terminate it by \0,
 +	   so e.g. sscanf() can scan the string easily */
++=======
+ 	error = copy_from_user(buffer->page, buf, count);
+ 
+ 	/*
+ 	 * If buf is assumed to contain a string, terminate it by \0, so
+ 	 * e.g. sscanf() can scan the string easily.
+ 	 */
++>>>>>>> aea585ef8fa6 (sysfs: remove sysfs_buffer->needs_read_fill)
  	buffer->page[count] = 0;
  	return error ? -EFAULT : count;
  }
* Unmerged path fs/sysfs/file.c
