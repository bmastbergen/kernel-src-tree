mlxsw: spectrum_router: Support FID-less RIFs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Petr Machata <petrm@mellanox.com>
commit 010cadf916a5112a2de1642301917f4139104d46
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/010cadf9.failed

Loopback RIFs, which will be introduced in a follow-up patch, differ
from other RIFs in that they do not have a FID associated with them.

To support this, demote FID allocation from mlxsw_sp_rif_create to
configure op of the existing RIF types, and likewise the FID release
from mlxsw_sp_rif_destroy to deconfigure op.

	Signed-off-by: Petr Machata <petrm@mellanox.com>
	Reviewed-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 010cadf916a5112a2de1642301917f4139104d46)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index 2055c8543e7b,38477c5f7d4d..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -2888,174 -4368,159 +2888,229 @@@ static bool mlxsw_sp_rif_should_config(
  	return false;
  }
  
 -static enum mlxsw_sp_rif_type
 -mlxsw_sp_dev_rif_type(const struct mlxsw_sp *mlxsw_sp,
 -		      const struct net_device *dev)
 +#define MLXSW_SP_INVALID_RIF 0xffff
 +static int mlxsw_sp_avail_rif_get(struct mlxsw_sp *mlxsw_sp)
  {
 -	enum mlxsw_sp_fid_type type;
 +	int i;
  
 -	/* RIF type is derived from the type of the underlying FID */
 -	if (is_vlan_dev(dev) && netif_is_bridge_master(vlan_dev_real_dev(dev)))
 -		type = MLXSW_SP_FID_TYPE_8021Q;
 -	else if (netif_is_bridge_master(dev) && br_vlan_enabled(dev))
 -		type = MLXSW_SP_FID_TYPE_8021Q;
 -	else if (netif_is_bridge_master(dev))
 -		type = MLXSW_SP_FID_TYPE_8021D;
 -	else
 -		type = MLXSW_SP_FID_TYPE_RFID;
 +	for (i = 0; i < MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS); i++)
 +		if (!mlxsw_sp->rifs[i])
 +			return i;
  
 -	return mlxsw_sp_fid_type_rif_type(mlxsw_sp, type);
 +	return MLXSW_SP_INVALID_RIF;
  }
  
 -static int mlxsw_sp_rif_index_alloc(struct mlxsw_sp *mlxsw_sp, u16 *p_rif_index)
 +static void mlxsw_sp_vport_rif_sp_attr_get(struct mlxsw_sp_port *mlxsw_sp_vport,
 +					   bool *p_lagged, u16 *p_system_port)
  {
 -	int i;
 -
 -	for (i = 0; i < MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS); i++) {
 -		if (!mlxsw_sp->router->rifs[i]) {
 -			*p_rif_index = i;
 -			return 0;
 -		}
 -	}
 +	u8 local_port = mlxsw_sp_vport->local_port;
  
 -	return -ENOBUFS;
 +	*p_lagged = mlxsw_sp_vport->lagged;
 +	*p_system_port = *p_lagged ? mlxsw_sp_vport->lag_id : local_port;
  }
  
 -static struct mlxsw_sp_rif *mlxsw_sp_rif_alloc(size_t rif_size, u16 rif_index,
 -					       u16 vr_id,
 -					       struct net_device *l3_dev)
 +static int mlxsw_sp_vport_rif_sp_op(struct mlxsw_sp_port *mlxsw_sp_vport,
 +				    u16 vr_id, struct net_device *l3_dev,
 +				    u16 rif, bool create)
  {
 -	struct mlxsw_sp_rif *rif;
 +	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_vport->mlxsw_sp;
 +	bool lagged = mlxsw_sp_vport->lagged;
 +	char ritr_pl[MLXSW_REG_RITR_LEN];
 +	u16 system_port;
  
 -	rif = kzalloc(rif_size, GFP_KERNEL);
 -	if (!rif)
 -		return NULL;
 +	mlxsw_reg_ritr_pack(ritr_pl, create, MLXSW_REG_RITR_SP_IF, rif, vr_id,
 +			    l3_dev->mtu, l3_dev->dev_addr);
  
 -	INIT_LIST_HEAD(&rif->nexthop_list);
 -	INIT_LIST_HEAD(&rif->neigh_list);
 -	ether_addr_copy(rif->addr, l3_dev->dev_addr);
 -	rif->mtu = l3_dev->mtu;
 -	rif->vr_id = vr_id;
 -	rif->dev = l3_dev;
 -	rif->rif_index = rif_index;
 +	mlxsw_sp_vport_rif_sp_attr_get(mlxsw_sp_vport, &lagged, &system_port);
 +	mlxsw_reg_ritr_sp_if_pack(ritr_pl, lagged, system_port,
 +				  mlxsw_sp_vport_vid_get(mlxsw_sp_vport));
  
 -	return rif;
 +	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);
  }
  
 -struct mlxsw_sp_rif *mlxsw_sp_rif_by_index(const struct mlxsw_sp *mlxsw_sp,
 -					   u16 rif_index)
 +static void mlxsw_sp_vport_rif_sp_leave(struct mlxsw_sp_port *mlxsw_sp_vport);
 +
 +static u16 mlxsw_sp_rif_sp_to_fid(u16 rif)
  {
 -	return mlxsw_sp->router->rifs[rif_index];
 +	return MLXSW_SP_RFID_BASE + rif;
  }
  
 -u16 mlxsw_sp_rif_index(const struct mlxsw_sp_rif *rif)
 +static struct mlxsw_sp_fid *
 +mlxsw_sp_rfid_alloc(u16 fid, struct net_device *l3_dev)
  {
 -	return rif->rif_index;
 +	struct mlxsw_sp_fid *f;
 +
 +	f = kzalloc(sizeof(*f), GFP_KERNEL);
 +	if (!f)
 +		return NULL;
 +
 +	f->leave = mlxsw_sp_vport_rif_sp_leave;
 +	f->ref_count = 0;
 +	f->dev = l3_dev;
 +	f->fid = fid;
 +
 +	return f;
  }
  
 -int mlxsw_sp_rif_dev_ifindex(const struct mlxsw_sp_rif *rif)
 +static struct mlxsw_sp_rif *
 +mlxsw_sp_rif_alloc(u16 rif, u16 vr_id, struct net_device *l3_dev,
 +		   struct mlxsw_sp_fid *f)
  {
 -	return rif->dev->ifindex;
++<<<<<<< HEAD
 +	struct mlxsw_sp_rif *r;
 +
 +	r = kzalloc(sizeof(*r), GFP_KERNEL);
 +	if (!r)
 +		return NULL;
 +
 +	INIT_LIST_HEAD(&r->nexthop_list);
 +	INIT_LIST_HEAD(&r->neigh_list);
 +	ether_addr_copy(r->addr, l3_dev->dev_addr);
 +	r->mtu = l3_dev->mtu;
 +	r->vr_id = vr_id;
 +	r->dev = l3_dev;
 +	r->rif = rif;
 +	r->f = f;
 +
 +	return r;
  }
  
  static struct mlxsw_sp_rif *
 -mlxsw_sp_rif_create(struct mlxsw_sp *mlxsw_sp,
 -		    const struct mlxsw_sp_rif_params *params)
 +mlxsw_sp_vport_rif_sp_create(struct mlxsw_sp_port *mlxsw_sp_vport,
 +			     struct net_device *l3_dev)
  {
 +	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_vport->mlxsw_sp;
++=======
+ 	u32 tb_id = l3mdev_fib_table(params->dev);
+ 	const struct mlxsw_sp_rif_ops *ops;
+ 	struct mlxsw_sp_fid *fid = NULL;
+ 	enum mlxsw_sp_rif_type type;
+ 	struct mlxsw_sp_rif *rif;
++>>>>>>> 010cadf916a5 (mlxsw: spectrum_router: Support FID-less RIFs)
  	struct mlxsw_sp_vr *vr;
 -	u16 rif_index;
 +	struct mlxsw_sp_fid *f;
 +	struct mlxsw_sp_rif *r;
 +	u16 fid, rif;
  	int err;
  
 -	type = mlxsw_sp_dev_rif_type(mlxsw_sp, params->dev);
 -	ops = mlxsw_sp->router->rif_ops_arr[type];
 +	rif = mlxsw_sp_avail_rif_get(mlxsw_sp);
 +	if (rif == MLXSW_SP_INVALID_RIF)
 +		return ERR_PTR(-ERANGE);
  
 -	vr = mlxsw_sp_vr_get(mlxsw_sp, tb_id ? : RT_TABLE_MAIN);
 +	vr = mlxsw_sp_vr_get(mlxsw_sp, RT_TABLE_MAIN);
  	if (IS_ERR(vr))
  		return ERR_CAST(vr);
  
 -	err = mlxsw_sp_rif_index_alloc(mlxsw_sp, &rif_index);
 +	err = mlxsw_sp_vport_rif_sp_op(mlxsw_sp_vport, vr->id, l3_dev, rif,
 +				       true);
 +	if (err)
 +		goto err_vport_rif_sp_op;
 +
++<<<<<<< HEAD
 +	fid = mlxsw_sp_rif_sp_to_fid(rif);
 +	err = mlxsw_sp_rif_fdb_op(mlxsw_sp, l3_dev->dev_addr, fid, true);
  	if (err)
 -		goto err_rif_index_alloc;
 +		goto err_rif_fdb_op;
 +
 +	f = mlxsw_sp_rfid_alloc(fid, l3_dev);
 +	if (!f) {
 +		err = -ENOMEM;
 +		goto err_rfid_alloc;
 +	}
 +
 +	r = mlxsw_sp_rif_alloc(rif, vr->id, l3_dev, f);
 +	if (!r) {
 +		err = -ENOMEM;
 +		goto err_rif_alloc;
 +	}
  
 +	f->r = r;
 +	mlxsw_sp->rifs[rif] = r;
++=======
+ 	rif = mlxsw_sp_rif_alloc(ops->rif_size, rif_index, vr->id, params->dev);
+ 	if (!rif) {
+ 		err = -ENOMEM;
+ 		goto err_rif_alloc;
+ 	}
+ 	rif->mlxsw_sp = mlxsw_sp;
+ 	rif->ops = ops;
+ 
+ 	if (ops->fid_get) {
+ 		fid = ops->fid_get(rif);
+ 		if (IS_ERR(fid)) {
+ 			err = PTR_ERR(fid);
+ 			goto err_fid_get;
+ 		}
+ 		rif->fid = fid;
+ 	}
+ 
+ 	if (ops->setup)
+ 		ops->setup(rif, params);
+ 
+ 	err = ops->configure(rif);
+ 	if (err)
+ 		goto err_configure;
+ 
+ 	mlxsw_sp_rif_counters_alloc(rif);
+ 	mlxsw_sp->router->rifs[rif_index] = rif;
++>>>>>>> 010cadf916a5 (mlxsw: spectrum_router: Support FID-less RIFs)
  	vr->rif_count++;
  
 -	return rif;
 +	return r;
  
++<<<<<<< HEAD
++=======
+ err_configure:
+ 	if (fid)
+ 		mlxsw_sp_fid_put(fid);
+ err_fid_get:
+ 	kfree(rif);
++>>>>>>> 010cadf916a5 (mlxsw: spectrum_router: Support FID-less RIFs)
  err_rif_alloc:
 -err_rif_index_alloc:
 +	kfree(f);
 +err_rfid_alloc:
 +	mlxsw_sp_rif_fdb_op(mlxsw_sp, l3_dev->dev_addr, fid, false);
 +err_rif_fdb_op:
 +	mlxsw_sp_vport_rif_sp_op(mlxsw_sp_vport, vr->id, l3_dev, rif, false);
 +err_vport_rif_sp_op:
  	mlxsw_sp_vr_put(vr);
  	return ERR_PTR(err);
  }
  
 -void mlxsw_sp_rif_destroy(struct mlxsw_sp_rif *rif)
 +static void mlxsw_sp_vport_rif_sp_destroy(struct mlxsw_sp_port *mlxsw_sp_vport,
 +					  struct mlxsw_sp_rif *r)
  {
 -	const struct mlxsw_sp_rif_ops *ops = rif->ops;
 -	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
 -	struct mlxsw_sp_fid *fid = rif->fid;
 -	struct mlxsw_sp_vr *vr;
 +	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_vport->mlxsw_sp;
 +	struct mlxsw_sp_vr *vr = &mlxsw_sp->router.vrs[r->vr_id];
 +	struct net_device *l3_dev = r->dev;
 +	struct mlxsw_sp_fid *f = r->f;
 +	u16 fid = f->fid;
 +	u16 rif = r->rif;
  
 -	mlxsw_sp_router_rif_gone_sync(mlxsw_sp, rif);
 -	vr = &mlxsw_sp->router->vrs[rif->vr_id];
 +	mlxsw_sp_router_rif_gone_sync(mlxsw_sp, r);
  
  	vr->rif_count--;
++<<<<<<< HEAD
 +	mlxsw_sp->rifs[rif] = NULL;
 +	f->r = NULL;
 +
 +	kfree(r);
 +
 +	kfree(f);
 +
 +	mlxsw_sp_rif_fdb_op(mlxsw_sp, l3_dev->dev_addr, fid, false);
 +
 +	mlxsw_sp_vport_rif_sp_op(mlxsw_sp_vport, vr->id, l3_dev, rif, false);
 +
++=======
+ 	mlxsw_sp->router->rifs[rif->rif_index] = NULL;
+ 	mlxsw_sp_rif_counters_free(rif);
+ 	ops->deconfigure(rif);
+ 	if (fid)
+ 		/* Loopback RIFs are not associated with a FID. */
+ 		mlxsw_sp_fid_put(fid);
+ 	kfree(rif);
++>>>>>>> 010cadf916a5 (mlxsw: spectrum_router: Support FID-less RIFs)
  	mlxsw_sp_vr_put(vr);
  }
  
@@@ -3450,71 -4870,339 +3505,352 @@@ err_rif_edit
  	return err;
  }
  
 -static int mlxsw_sp_port_vrf_join(struct mlxsw_sp *mlxsw_sp,
 -				  struct net_device *l3_dev)
 +int mlxsw_sp_vport_vrf_join(struct mlxsw_sp_port *mlxsw_sp_vport)
  {
 -	struct mlxsw_sp_rif *rif;
 +	struct mlxsw_sp_fid *f = mlxsw_sp_vport_fid_get(mlxsw_sp_vport);
 +	struct net_device *dev = mlxsw_sp_vport->dev;
  
 -	/* If netdev is already associated with a RIF, then we need to
 -	 * destroy it and create a new one with the new virtual router ID.
 +	/* In case vPort already has a RIF, then we need to drop it.
 +	 * A new one will be created using the VRF's VR.
  	 */
 -	rif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, l3_dev);
 -	if (rif)
 -		__mlxsw_sp_inetaddr_event(l3_dev, NETDEV_DOWN);
 +	if (f && f->r)
 +		mlxsw_sp_vport_rif_sp_leave(mlxsw_sp_vport);
  
 -	return __mlxsw_sp_inetaddr_event(l3_dev, NETDEV_UP);
 +	return mlxsw_sp_vport_rif_sp_join(mlxsw_sp_vport, dev);
  }
  
 -static void mlxsw_sp_port_vrf_leave(struct mlxsw_sp *mlxsw_sp,
 -				    struct net_device *l3_dev)
 +void mlxsw_sp_vport_vrf_leave(struct mlxsw_sp_port *mlxsw_sp_vport)
  {
 -	struct mlxsw_sp_rif *rif;
 +	mlxsw_sp_vport_rif_sp_leave(mlxsw_sp_vport);
 +}
 +
 +int mlxsw_sp_port_vrf_join(struct mlxsw_sp_port *mlxsw_sp_port)
 +{
 +	struct mlxsw_sp_port *mlxsw_sp_vport;
 +
 +	mlxsw_sp_vport = mlxsw_sp_port_vport_find(mlxsw_sp_port, 1);
 +	if (WARN_ON(!mlxsw_sp_vport))
 +		return -EINVAL;
 +
 +	return mlxsw_sp_vport_vrf_join(mlxsw_sp_vport);
 +}
 +
 +void mlxsw_sp_port_vrf_leave(struct mlxsw_sp_port *mlxsw_sp_port)
 +{
 +	struct mlxsw_sp_port *mlxsw_sp_vport;
  
 -	rif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, l3_dev);
 -	if (!rif)
 +	mlxsw_sp_vport = mlxsw_sp_port_vport_find(mlxsw_sp_port, 1);
 +	if (WARN_ON(!mlxsw_sp_vport))
  		return;
 -	__mlxsw_sp_inetaddr_event(l3_dev, NETDEV_DOWN);
 +
 +	mlxsw_sp_vport_vrf_leave(mlxsw_sp_vport);
  }
  
 -int mlxsw_sp_netdevice_vrf_event(struct net_device *l3_dev, unsigned long event,
 -				 struct netdev_notifier_changeupper_info *info)
 +int mlxsw_sp_bridge_vrf_join(struct mlxsw_sp *mlxsw_sp,
 +			     struct net_device *l3_dev)
  {
 -	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_lower_get(l3_dev);
 -	int err = 0;
 +	struct mlxsw_sp_fid *f;
  
 -	if (!mlxsw_sp)
 -		return 0;
 +	f = mlxsw_sp_bridge_fid_get(mlxsw_sp, l3_dev);
 +	if (WARN_ON(!f))
 +		return -EINVAL;
  
 -	switch (event) {
 -	case NETDEV_PRECHANGEUPPER:
 -		return 0;
 -	case NETDEV_CHANGEUPPER:
 -		if (info->linking)
 -			err = mlxsw_sp_port_vrf_join(mlxsw_sp, l3_dev);
 -		else
 -			mlxsw_sp_port_vrf_leave(mlxsw_sp, l3_dev);
 -		break;
 -	}
 +	if (f->r)
 +		mlxsw_sp_rif_bridge_destroy(mlxsw_sp, f->r);
  
 -	return err;
 +	return mlxsw_sp_rif_bridge_create(mlxsw_sp, l3_dev, f);
  }
  
 -static struct mlxsw_sp_rif_subport *
 -mlxsw_sp_rif_subport_rif(const struct mlxsw_sp_rif *rif)
 +void mlxsw_sp_bridge_vrf_leave(struct mlxsw_sp *mlxsw_sp,
 +			       struct net_device *l3_dev)
  {
 -	return container_of(rif, struct mlxsw_sp_rif_subport, common);
 -}
 +	struct mlxsw_sp_fid *f;
  
++<<<<<<< HEAD
 +	f = mlxsw_sp_bridge_fid_get(mlxsw_sp, l3_dev);
 +	if (WARN_ON(!f))
 +		return;
 +	mlxsw_sp_rif_bridge_destroy(mlxsw_sp, f->r);
++=======
+ static void mlxsw_sp_rif_subport_setup(struct mlxsw_sp_rif *rif,
+ 				       const struct mlxsw_sp_rif_params *params)
+ {
+ 	struct mlxsw_sp_rif_subport *rif_subport;
+ 
+ 	rif_subport = mlxsw_sp_rif_subport_rif(rif);
+ 	rif_subport->vid = params->vid;
+ 	rif_subport->lag = params->lag;
+ 	if (params->lag)
+ 		rif_subport->lag_id = params->lag_id;
+ 	else
+ 		rif_subport->system_port = params->system_port;
+ }
+ 
+ static int mlxsw_sp_rif_subport_op(struct mlxsw_sp_rif *rif, bool enable)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	struct mlxsw_sp_rif_subport *rif_subport;
+ 	char ritr_pl[MLXSW_REG_RITR_LEN];
+ 
+ 	rif_subport = mlxsw_sp_rif_subport_rif(rif);
+ 	mlxsw_reg_ritr_pack(ritr_pl, enable, MLXSW_REG_RITR_SP_IF,
+ 			    rif->rif_index, rif->vr_id, rif->dev->mtu);
+ 	mlxsw_reg_ritr_mac_pack(ritr_pl, rif->dev->dev_addr);
+ 	mlxsw_reg_ritr_sp_if_pack(ritr_pl, rif_subport->lag,
+ 				  rif_subport->lag ? rif_subport->lag_id :
+ 						     rif_subport->system_port,
+ 				  rif_subport->vid);
+ 
+ 	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);
+ }
+ 
+ static int mlxsw_sp_rif_subport_configure(struct mlxsw_sp_rif *rif)
+ {
+ 	int err;
+ 
+ 	err = mlxsw_sp_rif_subport_op(rif, true);
+ 	if (err)
+ 		return err;
+ 
+ 	err = mlxsw_sp_rif_fdb_op(rif->mlxsw_sp, rif->dev->dev_addr,
+ 				  mlxsw_sp_fid_index(rif->fid), true);
+ 	if (err)
+ 		goto err_rif_fdb_op;
+ 
+ 	mlxsw_sp_fid_rif_set(rif->fid, rif);
+ 	return 0;
+ 
+ err_rif_fdb_op:
+ 	mlxsw_sp_rif_subport_op(rif, false);
+ 	return err;
+ }
+ 
+ static void mlxsw_sp_rif_subport_deconfigure(struct mlxsw_sp_rif *rif)
+ {
+ 	struct mlxsw_sp_fid *fid = rif->fid;
+ 
+ 	mlxsw_sp_fid_rif_set(fid, NULL);
+ 	mlxsw_sp_rif_fdb_op(rif->mlxsw_sp, rif->dev->dev_addr,
+ 			    mlxsw_sp_fid_index(fid), false);
+ 	mlxsw_sp_rif_subport_op(rif, false);
+ }
+ 
+ static struct mlxsw_sp_fid *
+ mlxsw_sp_rif_subport_fid_get(struct mlxsw_sp_rif *rif)
+ {
+ 	return mlxsw_sp_fid_rfid_get(rif->mlxsw_sp, rif->rif_index);
+ }
+ 
+ static const struct mlxsw_sp_rif_ops mlxsw_sp_rif_subport_ops = {
+ 	.type			= MLXSW_SP_RIF_TYPE_SUBPORT,
+ 	.rif_size		= sizeof(struct mlxsw_sp_rif_subport),
+ 	.setup			= mlxsw_sp_rif_subport_setup,
+ 	.configure		= mlxsw_sp_rif_subport_configure,
+ 	.deconfigure		= mlxsw_sp_rif_subport_deconfigure,
+ 	.fid_get		= mlxsw_sp_rif_subport_fid_get,
+ };
+ 
+ static int mlxsw_sp_rif_vlan_fid_op(struct mlxsw_sp_rif *rif,
+ 				    enum mlxsw_reg_ritr_if_type type,
+ 				    u16 vid_fid, bool enable)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	char ritr_pl[MLXSW_REG_RITR_LEN];
+ 
+ 	mlxsw_reg_ritr_pack(ritr_pl, enable, type, rif->rif_index, rif->vr_id,
+ 			    rif->dev->mtu);
+ 	mlxsw_reg_ritr_mac_pack(ritr_pl, rif->dev->dev_addr);
+ 	mlxsw_reg_ritr_fid_set(ritr_pl, type, vid_fid);
+ 
+ 	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);
+ }
+ 
+ static u8 mlxsw_sp_router_port(const struct mlxsw_sp *mlxsw_sp)
+ {
+ 	return mlxsw_core_max_ports(mlxsw_sp->core) + 1;
+ }
+ 
+ static int mlxsw_sp_rif_vlan_configure(struct mlxsw_sp_rif *rif)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	u16 vid = mlxsw_sp_fid_8021q_vid(rif->fid);
+ 	int err;
+ 
+ 	err = mlxsw_sp_rif_vlan_fid_op(rif, MLXSW_REG_RITR_VLAN_IF, vid, true);
+ 	if (err)
+ 		return err;
+ 
+ 	err = mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_MC,
+ 				     mlxsw_sp_router_port(mlxsw_sp), true);
+ 	if (err)
+ 		goto err_fid_mc_flood_set;
+ 
+ 	err = mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_BC,
+ 				     mlxsw_sp_router_port(mlxsw_sp), true);
+ 	if (err)
+ 		goto err_fid_bc_flood_set;
+ 
+ 	err = mlxsw_sp_rif_fdb_op(rif->mlxsw_sp, rif->dev->dev_addr,
+ 				  mlxsw_sp_fid_index(rif->fid), true);
+ 	if (err)
+ 		goto err_rif_fdb_op;
+ 
+ 	mlxsw_sp_fid_rif_set(rif->fid, rif);
+ 	return 0;
+ 
+ err_rif_fdb_op:
+ 	mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_BC,
+ 			       mlxsw_sp_router_port(mlxsw_sp), false);
+ err_fid_bc_flood_set:
+ 	mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_MC,
+ 			       mlxsw_sp_router_port(mlxsw_sp), false);
+ err_fid_mc_flood_set:
+ 	mlxsw_sp_rif_vlan_fid_op(rif, MLXSW_REG_RITR_VLAN_IF, vid, false);
+ 	return err;
+ }
+ 
+ static void mlxsw_sp_rif_vlan_deconfigure(struct mlxsw_sp_rif *rif)
+ {
+ 	u16 vid = mlxsw_sp_fid_8021q_vid(rif->fid);
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	struct mlxsw_sp_fid *fid = rif->fid;
+ 
+ 	mlxsw_sp_fid_rif_set(fid, NULL);
+ 	mlxsw_sp_rif_fdb_op(rif->mlxsw_sp, rif->dev->dev_addr,
+ 			    mlxsw_sp_fid_index(fid), false);
+ 	mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_BC,
+ 			       mlxsw_sp_router_port(mlxsw_sp), false);
+ 	mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_MC,
+ 			       mlxsw_sp_router_port(mlxsw_sp), false);
+ 	mlxsw_sp_rif_vlan_fid_op(rif, MLXSW_REG_RITR_VLAN_IF, vid, false);
+ }
+ 
+ static struct mlxsw_sp_fid *
+ mlxsw_sp_rif_vlan_fid_get(struct mlxsw_sp_rif *rif)
+ {
+ 	u16 vid = is_vlan_dev(rif->dev) ? vlan_dev_vlan_id(rif->dev) : 1;
+ 
+ 	return mlxsw_sp_fid_8021q_get(rif->mlxsw_sp, vid);
+ }
+ 
+ static const struct mlxsw_sp_rif_ops mlxsw_sp_rif_vlan_ops = {
+ 	.type			= MLXSW_SP_RIF_TYPE_VLAN,
+ 	.rif_size		= sizeof(struct mlxsw_sp_rif),
+ 	.configure		= mlxsw_sp_rif_vlan_configure,
+ 	.deconfigure		= mlxsw_sp_rif_vlan_deconfigure,
+ 	.fid_get		= mlxsw_sp_rif_vlan_fid_get,
+ };
+ 
+ static int mlxsw_sp_rif_fid_configure(struct mlxsw_sp_rif *rif)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	u16 fid_index = mlxsw_sp_fid_index(rif->fid);
+ 	int err;
+ 
+ 	err = mlxsw_sp_rif_vlan_fid_op(rif, MLXSW_REG_RITR_FID_IF, fid_index,
+ 				       true);
+ 	if (err)
+ 		return err;
+ 
+ 	err = mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_MC,
+ 				     mlxsw_sp_router_port(mlxsw_sp), true);
+ 	if (err)
+ 		goto err_fid_mc_flood_set;
+ 
+ 	err = mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_BC,
+ 				     mlxsw_sp_router_port(mlxsw_sp), true);
+ 	if (err)
+ 		goto err_fid_bc_flood_set;
+ 
+ 	err = mlxsw_sp_rif_fdb_op(rif->mlxsw_sp, rif->dev->dev_addr,
+ 				  mlxsw_sp_fid_index(rif->fid), true);
+ 	if (err)
+ 		goto err_rif_fdb_op;
+ 
+ 	mlxsw_sp_fid_rif_set(rif->fid, rif);
+ 	return 0;
+ 
+ err_rif_fdb_op:
+ 	mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_BC,
+ 			       mlxsw_sp_router_port(mlxsw_sp), false);
+ err_fid_bc_flood_set:
+ 	mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_MC,
+ 			       mlxsw_sp_router_port(mlxsw_sp), false);
+ err_fid_mc_flood_set:
+ 	mlxsw_sp_rif_vlan_fid_op(rif, MLXSW_REG_RITR_FID_IF, fid_index, false);
+ 	return err;
+ }
+ 
+ static void mlxsw_sp_rif_fid_deconfigure(struct mlxsw_sp_rif *rif)
+ {
+ 	u16 fid_index = mlxsw_sp_fid_index(rif->fid);
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	struct mlxsw_sp_fid *fid = rif->fid;
+ 
+ 	mlxsw_sp_fid_rif_set(fid, NULL);
+ 	mlxsw_sp_rif_fdb_op(rif->mlxsw_sp, rif->dev->dev_addr,
+ 			    mlxsw_sp_fid_index(fid), false);
+ 	mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_BC,
+ 			       mlxsw_sp_router_port(mlxsw_sp), false);
+ 	mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_MC,
+ 			       mlxsw_sp_router_port(mlxsw_sp), false);
+ 	mlxsw_sp_rif_vlan_fid_op(rif, MLXSW_REG_RITR_FID_IF, fid_index, false);
+ }
+ 
+ static struct mlxsw_sp_fid *
+ mlxsw_sp_rif_fid_fid_get(struct mlxsw_sp_rif *rif)
+ {
+ 	return mlxsw_sp_fid_8021d_get(rif->mlxsw_sp, rif->dev->ifindex);
+ }
+ 
+ static const struct mlxsw_sp_rif_ops mlxsw_sp_rif_fid_ops = {
+ 	.type			= MLXSW_SP_RIF_TYPE_FID,
+ 	.rif_size		= sizeof(struct mlxsw_sp_rif),
+ 	.configure		= mlxsw_sp_rif_fid_configure,
+ 	.deconfigure		= mlxsw_sp_rif_fid_deconfigure,
+ 	.fid_get		= mlxsw_sp_rif_fid_fid_get,
+ };
+ 
+ static const struct mlxsw_sp_rif_ops *mlxsw_sp_rif_ops_arr[] = {
+ 	[MLXSW_SP_RIF_TYPE_SUBPORT]	= &mlxsw_sp_rif_subport_ops,
+ 	[MLXSW_SP_RIF_TYPE_VLAN]	= &mlxsw_sp_rif_vlan_ops,
+ 	[MLXSW_SP_RIF_TYPE_FID]		= &mlxsw_sp_rif_fid_ops,
+ };
+ 
+ static int mlxsw_sp_rifs_init(struct mlxsw_sp *mlxsw_sp)
+ {
+ 	u64 max_rifs = MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS);
+ 
+ 	mlxsw_sp->router->rifs = kcalloc(max_rifs,
+ 					 sizeof(struct mlxsw_sp_rif *),
+ 					 GFP_KERNEL);
+ 	if (!mlxsw_sp->router->rifs)
+ 		return -ENOMEM;
+ 
+ 	mlxsw_sp->router->rif_ops_arr = mlxsw_sp_rif_ops_arr;
+ 
+ 	return 0;
+ }
+ 
+ static void mlxsw_sp_rifs_fini(struct mlxsw_sp *mlxsw_sp)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS); i++)
+ 		WARN_ON_ONCE(mlxsw_sp->router->rifs[i]);
+ 
+ 	kfree(mlxsw_sp->router->rifs);
+ }
+ 
+ static int mlxsw_sp_ipips_init(struct mlxsw_sp *mlxsw_sp)
+ {
+ 	mlxsw_sp->router->ipip_ops_arr = mlxsw_sp_ipip_ops_arr;
+ 	return 0;
+ }
+ 
+ static void mlxsw_sp_ipips_fini(struct mlxsw_sp *mlxsw_sp)
+ {
++>>>>>>> 010cadf916a5 (mlxsw: spectrum_router: Support FID-less RIFs)
  }
  
  static void mlxsw_sp_router_fib_dump_flush(struct notifier_block *nb)
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
