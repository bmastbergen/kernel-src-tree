xen/vcpu: Handle xen_vcpu_setup() failure in hotplug

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ankur Arora <ankur.a.arora@oracle.com>
commit c9b5d98b25161a7ebee6ea59d6424dd9f33c1b99
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c9b5d98b.failed

The hypercall VCPUOP_register_vcpu_info can fail. This failure is
handled by making per_cpu(xen_vcpu, cpu) point to its shared_info
slot and those without one (cpu >= MAX_VIRT_CPUS) be NULL.

For PVH/PVHVM, this is not enough, because we also need to pull
these VCPUs out of circulation.

Fix for PVH/PVHVM: on registration failure in the cpuhp prepare
callback (xen_cpu_up_prepare_hvm()), return an error to the cpuhp
state-machine so it can fail the CPU init.

Fix for PV: the registration happens before smp_init(), so, in the
failure case we clamp setup_max_cpus and limit the number of VCPUs
that smp_init() will bring-up to MAX_VIRT_CPUS.
This is functionally correct but it makes the code a bit simpler
if we get rid of this explicit clamping: for VCPUs that don't have
valid xen_vcpu, fail the CPU init in the cpuhp prepare callback
(xen_cpu_up_prepare_pv()).

	Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
	Signed-off-by: Ankur Arora <ankur.a.arora@oracle.com>
	Signed-off-by: Juergen Gross <jgross@suse.com>
(cherry picked from commit c9b5d98b25161a7ebee6ea59d6424dd9f33c1b99)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/xen/enlighten.c
#	arch/x86/xen/enlighten_hvm.c
#	arch/x86/xen/enlighten_pv.c
#	arch/x86/xen/xen-ops.h
diff --cc arch/x86/xen/enlighten.c
index 5df0cb46e645,0e7ef69e8531..000000000000
--- a/arch/x86/xen/enlighten.c
+++ b/arch/x86/xen/enlighten.c
@@@ -158,88 -79,50 +158,119 @@@ struct shared_info *HYPERVISOR_shared_i
   *
   * 0: not available, 1: available
   */
 -int xen_have_vcpu_info_placement = 1;
 +static int have_vcpu_info_placement = 1;
 +
 +struct tls_descs {
 +	struct desc_struct desc[3];
 +};
 +
 +/*
 + * Updating the 3 TLS descriptors in the GDT on every task switch is
 + * surprisingly expensive so we avoid updating them if they haven't
 + * changed.  Since Xen writes different descriptors than the one
 + * passed in the update_descriptor hypercall we keep shadow copies to
 + * compare against.
 + */
 +static DEFINE_PER_CPU(struct tls_descs, shadow_tls_desc);
 +
 +#define XEN_HVM_CPUID_VCPU_ID_PRESENT  (1u << 3)
  
 -static int xen_cpu_up_online(unsigned int cpu)
 +static void clamp_max_cpus(void)
  {
 -	xen_init_lock_cpu(cpu);
 -	return 0;
 +#ifdef CONFIG_SMP
 +	if (setup_max_cpus > MAX_VIRT_CPUS)
 +		setup_max_cpus = MAX_VIRT_CPUS;
 +#endif
  }
  
 -int xen_cpuhp_setup(int (*cpu_up_prepare_cb)(unsigned int),
 -		    int (*cpu_dead_cb)(unsigned int))
 +void xen_vcpu_setup(int cpu)
  {
 -	int rc;
 +	struct vcpu_register_vcpu_info info;
 +	int err;
 +	struct vcpu_info *vcpup;
  
++<<<<<<< HEAD
 +	BUG_ON(HYPERVISOR_shared_info == &xen_dummy_shared_info);
++=======
+ 	rc = cpuhp_setup_state_nocalls(CPUHP_XEN_PREPARE,
+ 				       "x86/xen/hvm_guest:prepare",
+ 				       cpu_up_prepare_cb, cpu_dead_cb);
+ 	if (rc >= 0) {
+ 		rc = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,
+ 					       "x86/xen/hvm_guest:online",
+ 					       xen_cpu_up_online, NULL);
+ 		if (rc < 0)
+ 			cpuhp_remove_state_nocalls(CPUHP_XEN_PREPARE);
+ 	}
+ 
+ 	return rc >= 0 ? 0 : rc;
+ }
+ 
+ static int xen_vcpu_setup_restore(int cpu)
+ {
+ 	int rc = 0;
+ 
+ 	/* Any per_cpu(xen_vcpu) is stale, so reset it */
+ 	xen_vcpu_info_reset(cpu);
++>>>>>>> c9b5d98b2516 (xen/vcpu: Handle xen_vcpu_setup() failure in hotplug)
  
  	/*
 -	 * For PVH and PVHVM, setup online VCPUs only. The rest will
 -	 * be handled by hotplug.
 +	 * This path is called twice on PVHVM - first during bootup via
 +	 * smp_init -> xen_hvm_cpu_notify, and then if the VCPU is being
 +	 * hotplugged: cpu_up -> xen_hvm_cpu_notify.
 +	 * As we can only do the VCPUOP_register_vcpu_info once lets
 +	 * not over-write its result.
 +	 *
 +	 * For PV it is called during restore (xen_vcpu_restore) and bootup
 +	 * (xen_setup_vcpu_info_placement). The hotplug mechanism does not
 +	 * use this function.
 +	 */
++<<<<<<< HEAD
 +	if (xen_hvm_domain()) {
 +		if (per_cpu(xen_vcpu, cpu) == &per_cpu(xen_vcpu_info, cpu))
 +			return;
 +	}
 +	if (xen_vcpu_nr(cpu) < MAX_VIRT_CPUS)
 +		per_cpu(xen_vcpu, cpu) =
 +			&HYPERVISOR_shared_info->vcpu_info[xen_vcpu_nr(cpu)];
 +
 +	if (!have_vcpu_info_placement) {
 +		if (cpu >= MAX_VIRT_CPUS)
 +			clamp_max_cpus();
 +		return;
 +	}
 +
 +	vcpup = &per_cpu(xen_vcpu_info, cpu);
 +	info.mfn = arbitrary_virt_to_mfn(vcpup);
 +	info.offset = offset_in_page(vcpup);
 +
 +	/* Check to see if the hypervisor will put the vcpu_info
 +	   structure where we want it, which allows direct access via
 +	   a percpu-variable.
 +	   N.B. This hypercall can _only_ be called once per CPU. Subsequent
 +	   calls will error out with -EINVAL. This is due to the fact that
 +	   hypervisor has no unregister variant and this hypercall does not
 +	   allow to over-write info.mfn and info.offset.
  	 */
 +	err = HYPERVISOR_vcpu_op(VCPUOP_register_vcpu_info, xen_vcpu_nr(cpu),
 +				 &info);
 +
 +	if (err) {
 +		printk(KERN_DEBUG "register_vcpu_info failed: err=%d\n", err);
 +		have_vcpu_info_placement = 0;
 +		clamp_max_cpus();
 +	} else {
 +		/* This cpu is using the registered vcpu info, even if
 +		   later ones fail to. */
 +		per_cpu(xen_vcpu, cpu) = vcpup;
++=======
+ 	if (xen_pv_domain() ||
+ 	    (xen_hvm_domain() && cpu_online(cpu))) {
+ 		rc = xen_vcpu_setup(cpu);
++>>>>>>> c9b5d98b2516 (xen/vcpu: Handle xen_vcpu_setup() failure in hotplug)
  	}
+ 
+ 	return rc;
  }
  
  /*
@@@ -260,1563 -149,185 +291,1644 @@@ void xen_vcpu_restore(void
  		    HYPERVISOR_vcpu_op(VCPUOP_down, xen_vcpu_nr(cpu), NULL))
  			BUG();
  
 -		if (xen_pv_domain() || xen_feature(XENFEAT_hvm_safe_pvclock))
 -			xen_setup_runstate_info(cpu);
 +		xen_setup_runstate_info(cpu);
 +
++<<<<<<< HEAD
 +		if (have_vcpu_info_placement)
 +			xen_vcpu_setup(cpu);
  
 +		if (other_cpu && is_up &&
++=======
+ 		rc = xen_vcpu_setup_restore(cpu);
+ 		if (rc)
+ 			pr_emerg_once("vcpu restore failed for cpu=%d err=%d. "
+ 					"System will hang.\n", cpu, rc);
+ 		/*
+ 		 * In case xen_vcpu_setup_restore() fails, do not bring up the
+ 		 * VCPU. This helps us avoid the resulting OOPS when the VCPU
+ 		 * accesses pvclock_vcpu_time via xen_vcpu (which is NULL.)
+ 		 * Note that this does not improve the situation much -- now the
+ 		 * VM hangs instead of OOPSing -- with the VCPUs that did not
+ 		 * fail, spinning in stop_machine(), waiting for the failed
+ 		 * VCPUs to come up.
+ 		 */
+ 		if (other_cpu && is_up && (rc == 0) &&
++>>>>>>> c9b5d98b2516 (xen/vcpu: Handle xen_vcpu_setup() failure in hotplug)
  		    HYPERVISOR_vcpu_op(VCPUOP_up, xen_vcpu_nr(cpu), NULL))
  			BUG();
  	}
  }
  
 -void xen_vcpu_info_reset(int cpu)
++<<<<<<< HEAD
 +static void __init xen_banner(void)
  {
 -	if (xen_vcpu_nr(cpu) < MAX_VIRT_CPUS) {
 -		per_cpu(xen_vcpu, cpu) =
 -			&HYPERVISOR_shared_info->vcpu_info[xen_vcpu_nr(cpu)];
 -	} else {
 -		/* Set to NULL so that if somebody accesses it we get an OOPS */
 -		per_cpu(xen_vcpu, cpu) = NULL;
 +	unsigned version = HYPERVISOR_xen_version(XENVER_version, NULL);
 +	struct xen_extraversion extra;
 +	HYPERVISOR_xen_version(XENVER_extraversion, &extra);
 +
 +	printk(KERN_INFO "Booting paravirtualized kernel on %s\n",
 +	       pv_info.name);
 +	printk(KERN_INFO "Xen version: %d.%d%s%s\n",
 +	       version >> 16, version & 0xffff, extra.extraversion,
 +	       xen_feature(XENFEAT_mmu_pt_update_preserve_ad) ? " (preserve-AD)" : "");
 +}
 +/* Check if running on Xen version (major, minor) or later */
 +bool
 +xen_running_on_version_or_later(unsigned int major, unsigned int minor)
 +{
 +	unsigned int version;
 +
 +	if (!xen_domain())
 +		return false;
 +
 +	version = HYPERVISOR_xen_version(XENVER_version, NULL);
 +	if ((((version >> 16) == major) && ((version & 0xffff) >= minor)) ||
 +		((version >> 16) > major))
 +		return true;
 +	return false;
 +}
 +
 +#define CPUID_THERM_POWER_LEAF 6
 +#define APERFMPERF_PRESENT 0
 +
 +static __read_mostly unsigned int cpuid_leaf1_edx_mask = ~0;
 +static __read_mostly unsigned int cpuid_leaf1_ecx_mask = ~0;
 +
 +static __read_mostly unsigned int cpuid_leaf1_ecx_set_mask;
 +static __read_mostly unsigned int cpuid_leaf5_ecx_val;
 +static __read_mostly unsigned int cpuid_leaf5_edx_val;
 +
 +static void xen_cpuid(unsigned int *ax, unsigned int *bx,
 +		      unsigned int *cx, unsigned int *dx)
 +{
 +	unsigned maskebx = ~0;
 +	unsigned maskecx = ~0;
 +	unsigned maskedx = ~0;
 +	unsigned setecx = 0;
 +	/*
 +	 * Mask out inconvenient features, to try and disable as many
 +	 * unsupported kernel subsystems as possible.
 +	 */
 +	switch (*ax) {
 +	case 1:
 +		maskecx = cpuid_leaf1_ecx_mask;
 +		setecx = cpuid_leaf1_ecx_set_mask;
 +		maskedx = cpuid_leaf1_edx_mask;
 +		break;
 +
 +	case CPUID_MWAIT_LEAF:
 +		/* Synthesize the values.. */
 +		*ax = 0;
 +		*bx = 0;
 +		*cx = cpuid_leaf5_ecx_val;
 +		*dx = cpuid_leaf5_edx_val;
 +		return;
 +
 +	case CPUID_THERM_POWER_LEAF:
 +		/* Disabling APERFMPERF for kernel usage */
 +		maskecx = ~(1 << APERFMPERF_PRESENT);
 +		break;
 +
 +	case 0xb:
 +		/* Suppress extended topology stuff */
 +		maskebx = 0;
 +		break;
  	}
 +
 +	asm(XEN_EMULATE_PREFIX "cpuid"
 +		: "=a" (*ax),
 +		  "=b" (*bx),
 +		  "=c" (*cx),
 +		  "=d" (*dx)
 +		: "0" (*ax), "2" (*cx));
 +
 +	*bx &= maskebx;
 +	*cx &= maskecx;
 +	*cx |= setecx;
 +	*dx &= maskedx;
  }
 +STACK_FRAME_NON_STANDARD(xen_cpuid); /* XEN_EMULATE_PREFIX */
  
 -int xen_vcpu_setup(int cpu)
 +static bool __init xen_check_mwait(void)
  {
 -	struct vcpu_register_vcpu_info info;
 -	int err;
 -	struct vcpu_info *vcpup;
 +#ifdef CONFIG_ACPI
 +	struct xen_platform_op op = {
 +		.cmd			= XENPF_set_processor_pminfo,
 +		.u.set_pminfo.id	= -1,
 +		.u.set_pminfo.type	= XEN_PM_PDC,
 +	};
 +	uint32_t buf[3];
 +	unsigned int ax, bx, cx, dx;
 +	unsigned int mwait_mask;
  
 -	BUG_ON(HYPERVISOR_shared_info == &xen_dummy_shared_info);
 +	/* We need to determine whether it is OK to expose the MWAIT
 +	 * capability to the kernel to harvest deeper than C3 states from ACPI
 +	 * _CST using the processor_harvest_xen.c module. For this to work, we
 +	 * need to gather the MWAIT_LEAF values (which the cstate.c code
 +	 * checks against). The hypervisor won't expose the MWAIT flag because
 +	 * it would break backwards compatibility; so we will find out directly
 +	 * from the hardware and hypercall.
 +	 */
 +	if (!xen_initial_domain())
 +		return false;
  
  	/*
 -	 * This path is called on PVHVM at bootup (xen_hvm_smp_prepare_boot_cpu)
 -	 * and at restore (xen_vcpu_restore). Also called for hotplugged
 -	 * VCPUs (cpu_init -> xen_hvm_cpu_prepare_hvm).
 -	 * However, the hypercall can only be done once (see below) so if a VCPU
 -	 * is offlined and comes back online then let's not redo the hypercall.
 -	 *
 -	 * For PV it is called during restore (xen_vcpu_restore) and bootup
 -	 * (xen_setup_vcpu_info_placement). The hotplug mechanism does not
 -	 * use this function.
 +	 * When running under platform earlier than Xen4.2, do not expose
 +	 * mwait, to avoid the risk of loading native acpi pad driver
  	 */
 -	if (xen_hvm_domain()) {
 -		if (per_cpu(xen_vcpu, cpu) == &per_cpu(xen_vcpu_info, cpu))
 -			return 0;
 -	}
 +	if (!xen_running_on_version_or_later(4, 2))
 +		return false;
  
 -	if (xen_have_vcpu_info_placement) {
 -		vcpup = &per_cpu(xen_vcpu_info, cpu);
 -		info.mfn = arbitrary_virt_to_mfn(vcpup);
 -		info.offset = offset_in_page(vcpup);
 +	ax = 1;
 +	cx = 0;
  
 -		/*
 -		 * Check to see if the hypervisor will put the vcpu_info
 -		 * structure where we want it, which allows direct access via
 -		 * a percpu-variable.
 -		 * N.B. This hypercall can _only_ be called once per CPU.
 -		 * Subsequent calls will error out with -EINVAL. This is due to
 -		 * the fact that hypervisor has no unregister variant and this
 -		 * hypercall does not allow to over-write info.mfn and
 -		 * info.offset.
 -		 */
 -		err = HYPERVISOR_vcpu_op(VCPUOP_register_vcpu_info,
 -					 xen_vcpu_nr(cpu), &info);
 +	native_cpuid(&ax, &bx, &cx, &dx);
  
 -		if (err) {
 -			pr_warn_once("register_vcpu_info failed: cpu=%d err=%d\n",
 -				     cpu, err);
 -			xen_have_vcpu_info_placement = 0;
 -		} else {
 -			/*
 -			 * This cpu is using the registered vcpu info, even if
 -			 * later ones fail to.
 -			 */
 -			per_cpu(xen_vcpu, cpu) = vcpup;
 -		}
 +	mwait_mask = (1 << (X86_FEATURE_EST % 32)) |
 +		     (1 << (X86_FEATURE_MWAIT % 32));
 +
 +	if ((cx & mwait_mask) != mwait_mask)
 +		return false;
 +
 +	/* We need to emulate the MWAIT_LEAF and for that we need both
 +	 * ecx and edx. The hypercall provides only partial information.
 +	 */
 +
 +	ax = CPUID_MWAIT_LEAF;
 +	bx = 0;
 +	cx = 0;
 +	dx = 0;
 +
 +	native_cpuid(&ax, &bx, &cx, &dx);
 +
 +	/* Ask the Hypervisor whether to clear ACPI_PDC_C_C2C3_FFH. If so,
 +	 * don't expose MWAIT_LEAF and let ACPI pick the IOPORT version of C3.
 +	 */
 +	buf[0] = ACPI_PDC_REVISION_ID;
 +	buf[1] = 1;
 +	buf[2] = (ACPI_PDC_C_CAPABILITY_SMP | ACPI_PDC_EST_CAPABILITY_SWSMP);
 +
 +	set_xen_guest_handle(op.u.set_pminfo.pdc, buf);
 +
 +	if ((HYPERVISOR_dom0_op(&op) == 0) &&
 +	    (buf[2] & (ACPI_PDC_C_C1_FFH | ACPI_PDC_C_C2C3_FFH))) {
 +		cpuid_leaf5_ecx_val = cx;
 +		cpuid_leaf5_edx_val = dx;
  	}
 +	return true;
 +#else
 +	return false;
 +#endif
 +}
 +static void __init xen_init_cpuid_mask(void)
 +{
 +	unsigned int ax, bx, cx, dx;
 +	unsigned int xsave_mask;
  
 -	if (!xen_have_vcpu_info_placement)
 -		xen_vcpu_info_reset(cpu);
 +	cpuid_leaf1_edx_mask =
 +		~((1 << X86_FEATURE_MTRR) |  /* disable MTRR */
 +		  (1 << X86_FEATURE_ACC));   /* thermal monitoring */
  
 -	return ((per_cpu(xen_vcpu, cpu) == NULL) ? -ENODEV : 0);
 +	if (!xen_initial_domain())
 +		cpuid_leaf1_edx_mask &=
 +			~((1 << X86_FEATURE_APIC) |  /* disable local APIC */
 +			  (1 << X86_FEATURE_ACPI));  /* disable ACPI */
 +
 +	cpuid_leaf1_ecx_mask &= ~(1 << (X86_FEATURE_X2APIC % 32));
 +
 +	ax = 1;
 +	cx = 0;
 +	xen_cpuid(&ax, &bx, &cx, &dx);
 +
 +	xsave_mask =
 +		(1 << (X86_FEATURE_XSAVE % 32)) |
 +		(1 << (X86_FEATURE_OSXSAVE % 32));
 +
 +	/* Xen will set CR4.OSXSAVE if supported and not disabled by force */
 +	if ((cx & xsave_mask) != xsave_mask)
 +		cpuid_leaf1_ecx_mask &= ~xsave_mask; /* disable XSAVE & OSXSAVE */
 +	if (xen_check_mwait())
 +		cpuid_leaf1_ecx_set_mask = (1 << (X86_FEATURE_MWAIT % 32));
  }
  
 -void xen_reboot(int reason)
 +static void xen_set_debugreg(int reg, unsigned long val)
  {
 -	struct sched_shutdown r = { .reason = reason };
 -	int cpu;
 +	HYPERVISOR_set_debugreg(reg, val);
 +}
  
 -	for_each_online_cpu(cpu)
 -		xen_pmu_finish(cpu);
 +static unsigned long xen_get_debugreg(int reg)
 +{
 +	return HYPERVISOR_get_debugreg(reg);
 +}
  
 -	if (HYPERVISOR_sched_op(SCHEDOP_shutdown, &r))
 +static void xen_end_context_switch(struct task_struct *next)
 +{
 +	xen_mc_flush();
 +	paravirt_end_context_switch(next);
 +}
 +
 +static unsigned long xen_store_tr(void)
 +{
 +	return 0;
 +}
 +
 +/*
 + * Set the page permissions for a particular virtual address.  If the
 + * address is a vmalloc mapping (or other non-linear mapping), then
 + * find the linear mapping of the page and also set its protections to
 + * match.
 + */
 +static void set_aliased_prot(void *v, pgprot_t prot)
 +{
 +	int level;
 +	pte_t *ptep;
 +	pte_t pte;
 +	unsigned long pfn;
 +	struct page *page;
 +
 +	ptep = lookup_address((unsigned long)v, &level);
 +	BUG_ON(ptep == NULL);
 +
 +	pfn = pte_pfn(*ptep);
 +	page = pfn_to_page(pfn);
 +
 +	pte = pfn_pte(pfn, prot);
 +
 +	if (HYPERVISOR_update_va_mapping((unsigned long)v, pte, 0))
  		BUG();
 +
 +	if (!PageHighMem(page)) {
 +		void *av = __va(PFN_PHYS(pfn));
 +
 +		if (av != v)
 +			if (HYPERVISOR_update_va_mapping((unsigned long)av, pte, 0))
 +				BUG();
 +	} else
 +		kmap_flush_unused();
  }
  
 -void xen_emergency_restart(void)
 +static void xen_alloc_ldt(struct desc_struct *ldt, unsigned entries)
  {
 -	xen_reboot(SHUTDOWN_reboot);
 +	const unsigned entries_per_page = PAGE_SIZE / LDT_ENTRY_SIZE;
 +	int i;
 +
 +	for(i = 0; i < entries; i += entries_per_page)
 +		set_aliased_prot(ldt + i, PAGE_KERNEL_RO);
  }
  
 -static int
 -xen_panic_event(struct notifier_block *this, unsigned long event, void *ptr)
 +static void xen_free_ldt(struct desc_struct *ldt, unsigned entries)
  {
 -	if (!kexec_crash_loaded())
 -		xen_reboot(SHUTDOWN_crash);
 -	return NOTIFY_DONE;
 +	const unsigned entries_per_page = PAGE_SIZE / LDT_ENTRY_SIZE;
 +	int i;
 +
 +	for(i = 0; i < entries; i += entries_per_page)
 +		set_aliased_prot(ldt + i, PAGE_KERNEL);
  }
  
 -static struct notifier_block xen_panic_block = {
 -	.notifier_call = xen_panic_event,
 -	.priority = INT_MIN
 -};
 +static void xen_set_ldt(const void *addr, unsigned entries)
 +{
 +	struct mmuext_op *op;
 +	struct multicall_space mcs = xen_mc_entry(sizeof(*op));
  
 -int xen_panic_handler_init(void)
 +	trace_xen_cpu_set_ldt(addr, entries);
 +
 +	op = mcs.args;
 +	op->cmd = MMUEXT_SET_LDT;
 +	op->arg1.linear_addr = (unsigned long)addr;
 +	op->arg2.nr_ents = entries;
 +
 +	MULTI_mmuext_op(mcs.mc, op, 1, NULL, DOMID_SELF);
 +
 +	xen_mc_issue(PARAVIRT_LAZY_CPU);
 +}
 +
 +static void xen_load_gdt(const struct desc_ptr *dtr)
  {
 -	atomic_notifier_chain_register(&panic_notifier_list, &xen_panic_block);
 -	return 0;
 +	unsigned long va = dtr->address;
 +	unsigned int size = dtr->size + 1;
 +	unsigned pages = (size + PAGE_SIZE - 1) / PAGE_SIZE;
 +	unsigned long frames[pages];
 +	int f;
 +
 +	/*
 +	 * A GDT can be up to 64k in size, which corresponds to 8192
 +	 * 8-byte entries, or 16 4k pages..
 +	 */
 +
 +	BUG_ON(size > 65536);
 +	BUG_ON(va & ~PAGE_MASK);
 +
 +	for (f = 0; va < dtr->address + size; va += PAGE_SIZE, f++) {
 +		int level;
 +		pte_t *ptep;
 +		unsigned long pfn, mfn;
 +		void *virt;
 +
 +		/*
 +		 * The GDT is per-cpu and is in the percpu data area.
 +		 * That can be virtually mapped, so we need to do a
 +		 * page-walk to get the underlying MFN for the
 +		 * hypercall.  The page can also be in the kernel's
 +		 * linear range, so we need to RO that mapping too.
 +		 */
 +		ptep = lookup_address(va, &level);
 +		BUG_ON(ptep == NULL);
 +
 +		pfn = pte_pfn(*ptep);
 +		mfn = pfn_to_mfn(pfn);
 +		virt = __va(PFN_PHYS(pfn));
 +
 +		frames[f] = mfn;
 +
 +		make_lowmem_page_readonly((void *)va);
 +		make_lowmem_page_readonly(virt);
 +	}
 +
 +	if (HYPERVISOR_set_gdt(frames, size / sizeof(struct desc_struct)))
 +		BUG();
  }
  
 -void xen_pin_vcpu(int cpu)
 +/*
 + * load_gdt for early boot, when the gdt is only mapped once
 + */
 +static void __init xen_load_gdt_boot(const struct desc_ptr *dtr)
  {
 -	static bool disable_pinning;
 -	struct sched_pin_override pin_override;
 -	int ret;
 +	unsigned long va = dtr->address;
 +	unsigned int size = dtr->size + 1;
 +	unsigned pages = (size + PAGE_SIZE - 1) / PAGE_SIZE;
 +	unsigned long frames[pages];
 +	int f;
  
 -	if (disable_pinning)
 -		return;
 +	/*
 +	 * A GDT can be up to 64k in size, which corresponds to 8192
 +	 * 8-byte entries, or 16 4k pages..
 +	 */
 +
 +	BUG_ON(size > 65536);
 +	BUG_ON(va & ~PAGE_MASK);
 +
 +	for (f = 0; va < dtr->address + size; va += PAGE_SIZE, f++) {
 +		pte_t pte;
 +		unsigned long pfn, mfn;
 +
 +		pfn = virt_to_pfn(va);
 +		mfn = pfn_to_mfn(pfn);
 +
 +		pte = pfn_pte(pfn, PAGE_KERNEL_RO);
 +
 +		if (HYPERVISOR_update_va_mapping((unsigned long)va, pte, 0))
 +			BUG();
 +
 +		frames[f] = mfn;
 +	}
 +
 +	if (HYPERVISOR_set_gdt(frames, size / sizeof(struct desc_struct)))
 +		BUG();
 +}
 +
 +static inline bool desc_equal(const struct desc_struct *d1,
 +			      const struct desc_struct *d2)
 +{
 +	return d1->a == d2->a && d1->b == d2->b;
 +}
  
 -	pin_override.pcpu = cpu;
 -	ret = HYPERVISOR_sched_op(SCHEDOP_pin_override, &pin_override);
 +static void load_TLS_descriptor(struct thread_struct *t,
 +				unsigned int cpu, unsigned int i)
 +{
 +	struct desc_struct *shadow = &per_cpu(shadow_tls_desc, cpu).desc[i];
 +	struct desc_struct *gdt;
 +	xmaddr_t maddr;
 +	struct multicall_space mc;
  
 -	/* Ignore errors when removing override. */
 -	if (cpu < 0)
 +	if (desc_equal(shadow, &t->tls_array[i]))
  		return;
  
 -	switch (ret) {
 -	case -ENOSYS:
 -		pr_warn("Unable to pin on physical cpu %d. In case of problems consider vcpu pinning.\n",
 -			cpu);
 -		disable_pinning = true;
 -		break;
 -	case -EPERM:
 -		WARN(1, "Trying to pin vcpu without having privilege to do so\n");
 -		disable_pinning = true;
 -		break;
 -	case -EINVAL:
 -	case -EBUSY:
 -		pr_warn("Physical cpu %d not available for pinning. Check Xen cpu configuration.\n",
 -			cpu);
 -		break;
 -	case 0:
 -		break;
 -	default:
 -		WARN(1, "rc %d while trying to pin vcpu\n", ret);
 -		disable_pinning = true;
 +	*shadow = t->tls_array[i];
 +
 +	gdt = get_cpu_gdt_table(cpu);
 +	maddr = arbitrary_virt_to_machine(&gdt[GDT_ENTRY_TLS_MIN+i]);
 +	mc = __xen_mc_entry(0);
 +
 +	MULTI_update_descriptor(mc.mc, maddr.maddr, t->tls_array[i]);
 +}
 +
 +static void xen_load_tls(struct thread_struct *t, unsigned int cpu)
 +{
 +	/*
 +	 * XXX sleazy hack: If we're being called in a lazy-cpu zone
 +	 * and lazy gs handling is enabled, it means we're in a
 +	 * context switch, and %gs has just been saved.  This means we
 +	 * can zero it out to prevent faults on exit from the
 +	 * hypervisor if the next process has no %gs.  Either way, it
 +	 * has been saved, and the new value will get loaded properly.
 +	 * This will go away as soon as Xen has been modified to not
 +	 * save/restore %gs for normal hypercalls.
 +	 *
 +	 * On x86_64, this hack is not used for %gs, because gs points
 +	 * to KERNEL_GS_BASE (and uses it for PDA references), so we
 +	 * must not zero %gs on x86_64
 +	 *
 +	 * For x86_64, we need to zero %fs, otherwise we may get an
 +	 * exception between the new %fs descriptor being loaded and
 +	 * %fs being effectively cleared at __switch_to().
 +	 */
 +	if (paravirt_get_lazy_mode() == PARAVIRT_LAZY_CPU) {
 +#ifdef CONFIG_X86_32
 +		lazy_load_gs(0);
 +#else
 +		loadsegment(fs, 0);
 +#endif
  	}
 +
 +	xen_mc_batch();
 +
 +	load_TLS_descriptor(t, cpu, 0);
 +	load_TLS_descriptor(t, cpu, 1);
 +	load_TLS_descriptor(t, cpu, 2);
 +
 +	xen_mc_issue(PARAVIRT_LAZY_CPU);
 +}
 +
 +#ifdef CONFIG_X86_64
 +static void xen_load_gs_index(unsigned int idx)
 +{
 +	if (HYPERVISOR_set_segment_base(SEGBASE_GS_USER_SEL, idx))
 +		BUG();
  }
 +#endif
  
 -#ifdef CONFIG_HOTPLUG_CPU
 -void xen_arch_register_cpu(int num)
 +static void xen_write_ldt_entry(struct desc_struct *dt, int entrynum,
 +				const void *ptr)
  {
 -	arch_register_cpu(num);
 +	xmaddr_t mach_lp = arbitrary_virt_to_machine(&dt[entrynum]);
 +	u64 entry = *(u64 *)ptr;
 +
 +	trace_xen_cpu_write_ldt_entry(dt, entrynum, entry);
 +
 +	preempt_disable();
 +
 +	xen_mc_flush();
 +	if (HYPERVISOR_update_descriptor(mach_lp.maddr, entry))
 +		BUG();
 +
 +	preempt_enable();
  }
 -EXPORT_SYMBOL(xen_arch_register_cpu);
  
 -void xen_arch_unregister_cpu(int num)
 +static int cvt_gate_to_trap(int vector, const gate_desc *val,
 +			    struct trap_info *info)
  {
 -	arch_unregister_cpu(num);
 +	unsigned long addr;
 +
 +	if (val->type != GATE_TRAP && val->type != GATE_INTERRUPT)
 +		return 0;
 +
 +	info->vector = vector;
 +
 +	addr = gate_offset(*val);
 +#ifdef CONFIG_X86_64
 +	/*
 +	 * Look for known traps using IST, and substitute them
 +	 * appropriately.  The debugger ones are the only ones we care
 +	 * about.  Xen will handle faults like double_fault,
 +	 * so we should never see them.  Warn if
 +	 * there's an unexpected IST-using fault handler.
 +	 */
 +	if (addr == (unsigned long)debug)
 +		addr = (unsigned long)xen_debug;
 +	else if (addr == (unsigned long)int3)
 +		addr = (unsigned long)xen_int3;
 +	else if (addr == (unsigned long)stack_segment)
 +		addr = (unsigned long)xen_stack_segment;
 +	else if (addr == (unsigned long)double_fault ||
 +		 addr == (unsigned long)nmi) {
 +		/* Don't need to handle these */
 +		return 0;
 +#ifdef CONFIG_X86_MCE
 +	} else if (addr == (unsigned long)machine_check) {
 +		/*
 +		 * when xen hypervisor inject vMCE to guest,
 +		 * use native mce handler to handle it
 +		 */
 +		;
 +#endif
 +	} else {
 +		/* Some other trap using IST? */
 +		if (WARN_ON(val->ist != 0))
 +			return 0;
 +	}
 +#endif	/* CONFIG_X86_64 */
 +	info->address = addr;
 +
 +	info->cs = gate_segment(*val);
 +	info->flags = val->dpl;
 +	/* interrupt gates clear IF */
 +	if (val->type == GATE_INTERRUPT)
 +		info->flags |= 1 << 2;
 +
 +	return 1;
  }
 -EXPORT_SYMBOL(xen_arch_unregister_cpu);
 +
 +/* Locations of each CPU's IDT */
 +static DEFINE_PER_CPU(struct desc_ptr, idt_desc);
 +
 +/* Set an IDT entry.  If the entry is part of the current IDT, then
 +   also update Xen. */
 +static void xen_write_idt_entry(gate_desc *dt, int entrynum, const gate_desc *g)
 +{
 +	unsigned long p = (unsigned long)&dt[entrynum];
 +	unsigned long start, end;
 +
 +	trace_xen_cpu_write_idt_entry(dt, entrynum, g);
 +
 +	preempt_disable();
 +
 +	start = __this_cpu_read(idt_desc.address);
 +	end = start + __this_cpu_read(idt_desc.size) + 1;
 +
 +	xen_mc_flush();
 +
 +	native_write_idt_entry(dt, entrynum, g);
 +
 +	if (p >= start && (p + 8) <= end) {
 +		struct trap_info info[2];
 +
 +		info[1].address = 0;
 +
 +		if (cvt_gate_to_trap(entrynum, g, &info[0]))
 +			if (HYPERVISOR_set_trap_table(info))
 +				BUG();
 +	}
 +
 +	preempt_enable();
 +}
 +
 +static void xen_convert_trap_info(const struct desc_ptr *desc,
 +				  struct trap_info *traps)
 +{
 +	unsigned in, out, count;
 +
 +	count = (desc->size+1) / sizeof(gate_desc);
 +	BUG_ON(count > 256);
 +
 +	for (in = out = 0; in < count; in++) {
 +		gate_desc *entry = (gate_desc*)(desc->address) + in;
 +
 +		if (cvt_gate_to_trap(in, entry, &traps[out]))
 +			out++;
 +	}
 +	traps[out].address = 0;
 +}
 +
 +void xen_copy_trap_info(struct trap_info *traps)
 +{
 +	const struct desc_ptr *desc = &__get_cpu_var(idt_desc);
 +
 +	xen_convert_trap_info(desc, traps);
 +}
 +
 +/* Load a new IDT into Xen.  In principle this can be per-CPU, so we
 +   hold a spinlock to protect the static traps[] array (static because
 +   it avoids allocation, and saves stack space). */
 +static void xen_load_idt(const struct desc_ptr *desc)
 +{
 +	static DEFINE_SPINLOCK(lock);
 +	static struct trap_info traps[257];
 +
 +	trace_xen_cpu_load_idt(desc);
 +
 +	spin_lock(&lock);
 +
 +	__get_cpu_var(idt_desc) = *desc;
 +
 +	xen_convert_trap_info(desc, traps);
 +
 +	xen_mc_flush();
 +	if (HYPERVISOR_set_trap_table(traps))
 +		BUG();
 +
 +	spin_unlock(&lock);
 +}
 +
 +/* Write a GDT descriptor entry.  Ignore LDT descriptors, since
 +   they're handled differently. */
 +static void xen_write_gdt_entry(struct desc_struct *dt, int entry,
 +				const void *desc, int type)
 +{
 +	trace_xen_cpu_write_gdt_entry(dt, entry, desc, type);
 +
 +	preempt_disable();
 +
 +	switch (type) {
 +	case DESC_LDT:
 +	case DESC_TSS:
 +		/* ignore */
 +		break;
 +
 +	default: {
 +		xmaddr_t maddr = arbitrary_virt_to_machine(&dt[entry]);
 +
 +		xen_mc_flush();
 +		if (HYPERVISOR_update_descriptor(maddr.maddr, *(u64 *)desc))
 +			BUG();
 +	}
 +
 +	}
 +
 +	preempt_enable();
 +}
 +
 +/*
 + * Version of write_gdt_entry for use at early boot-time needed to
 + * update an entry as simply as possible.
 + */
 +static void __init xen_write_gdt_entry_boot(struct desc_struct *dt, int entry,
 +					    const void *desc, int type)
 +{
 +	trace_xen_cpu_write_gdt_entry(dt, entry, desc, type);
 +
 +	switch (type) {
 +	case DESC_LDT:
 +	case DESC_TSS:
 +		/* ignore */
 +		break;
 +
 +	default: {
 +		xmaddr_t maddr = virt_to_machine(&dt[entry]);
 +
 +		if (HYPERVISOR_update_descriptor(maddr.maddr, *(u64 *)desc))
 +			dt[entry] = *(struct desc_struct *)desc;
 +	}
 +
 +	}
 +}
 +
 +static void xen_load_sp0(struct tss_struct *tss,
 +			 struct thread_struct *thread)
 +{
 +	struct multicall_space mcs;
 +
 +	mcs = xen_mc_entry(0);
 +	MULTI_stack_switch(mcs.mc, __KERNEL_DS, thread->sp0);
 +	xen_mc_issue(PARAVIRT_LAZY_CPU);
 +}
 +
 +static void xen_set_iopl_mask(unsigned mask)
 +{
 +	struct physdev_set_iopl set_iopl;
 +
 +	/* Force the change at ring 0. */
 +	set_iopl.iopl = (mask == 0) ? 1 : (mask >> 12) & 3;
 +	HYPERVISOR_physdev_op(PHYSDEVOP_set_iopl, &set_iopl);
 +}
 +
 +static void xen_io_delay(void)
 +{
 +}
 +
 +#ifdef CONFIG_X86_LOCAL_APIC
 +static unsigned long xen_set_apic_id(unsigned int x)
 +{
 +	WARN_ON(1);
 +	return x;
 +}
 +static unsigned int xen_get_apic_id(unsigned long x)
 +{
 +	return ((x)>>24) & 0xFFu;
 +}
 +static u32 xen_apic_read(u32 reg)
 +{
 +	struct xen_platform_op op = {
 +		.cmd = XENPF_get_cpuinfo,
 +		.interface_version = XENPF_INTERFACE_VERSION,
 +		.u.pcpu_info.xen_cpuid = 0,
 +	};
 +	int ret = 0;
 +
 +	/* Shouldn't need this as APIC is turned off for PV, and we only
 +	 * get called on the bootup processor. But just in case. */
 +	if (!xen_initial_domain() || smp_processor_id())
 +		return 0;
 +
 +	if (reg == APIC_LVR)
 +		return 0x10;
 +
 +	if (reg != APIC_ID)
 +		return 0;
 +
 +	ret = HYPERVISOR_dom0_op(&op);
 +	if (ret)
 +		return 0;
 +
 +	return op.u.pcpu_info.apic_id << 24;
 +}
 +
 +static void xen_apic_write(u32 reg, u32 val)
 +{
 +	/* Warn to see if there's any stray references */
 +	WARN_ON(1);
 +}
 +
 +static u64 xen_apic_icr_read(void)
 +{
 +	return 0;
 +}
 +
 +static void xen_apic_icr_write(u32 low, u32 id)
 +{
 +	/* Warn to see if there's any stray references */
 +	WARN_ON(1);
 +}
 +
 +static void xen_apic_wait_icr_idle(void)
 +{
 +        return;
 +}
 +
 +static u32 xen_safe_apic_wait_icr_idle(void)
 +{
 +        return 0;
 +}
 +
 +static void set_xen_basic_apic_ops(void)
 +{
 +	apic->read = xen_apic_read;
 +	apic->write = xen_apic_write;
 +	apic->icr_read = xen_apic_icr_read;
 +	apic->icr_write = xen_apic_icr_write;
 +	apic->wait_icr_idle = xen_apic_wait_icr_idle;
 +	apic->safe_wait_icr_idle = xen_safe_apic_wait_icr_idle;
 +	apic->set_apic_id = xen_set_apic_id;
 +	apic->get_apic_id = xen_get_apic_id;
 +
 +#ifdef CONFIG_SMP
 +	apic->send_IPI_allbutself = xen_send_IPI_allbutself;
 +	apic->send_IPI_mask_allbutself = xen_send_IPI_mask_allbutself;
 +	apic->send_IPI_mask = xen_send_IPI_mask;
 +	apic->send_IPI_all = xen_send_IPI_all;
 +	apic->send_IPI_self = xen_send_IPI_self;
 +#endif
 +}
 +
 +#endif
 +
 +static void xen_clts(void)
++=======
++void xen_vcpu_info_reset(int cpu)
++>>>>>>> c9b5d98b2516 (xen/vcpu: Handle xen_vcpu_setup() failure in hotplug)
 +{
 +	struct multicall_space mcs;
 +
 +	mcs = xen_mc_entry(0);
 +
 +	MULTI_fpu_taskswitch(mcs.mc, 0);
 +
 +	xen_mc_issue(PARAVIRT_LAZY_CPU);
 +}
 +
++<<<<<<< HEAD
 +static DEFINE_PER_CPU(unsigned long, xen_cr0_value);
 +
 +static unsigned long xen_read_cr0(void)
++=======
++int xen_vcpu_setup(int cpu)
++>>>>>>> c9b5d98b2516 (xen/vcpu: Handle xen_vcpu_setup() failure in hotplug)
 +{
 +	unsigned long cr0 = this_cpu_read(xen_cr0_value);
 +
++<<<<<<< HEAD
 +	if (unlikely(cr0 == 0)) {
 +		cr0 = native_read_cr0();
 +		this_cpu_write(xen_cr0_value, cr0);
 +	}
 +
 +	return cr0;
++=======
++	BUG_ON(HYPERVISOR_shared_info == &xen_dummy_shared_info);
++
++	/*
++	 * This path is called on PVHVM at bootup (xen_hvm_smp_prepare_boot_cpu)
++	 * and at restore (xen_vcpu_restore). Also called for hotplugged
++	 * VCPUs (cpu_init -> xen_hvm_cpu_prepare_hvm).
++	 * However, the hypercall can only be done once (see below) so if a VCPU
++	 * is offlined and comes back online then let's not redo the hypercall.
++	 *
++	 * For PV it is called during restore (xen_vcpu_restore) and bootup
++	 * (xen_setup_vcpu_info_placement). The hotplug mechanism does not
++	 * use this function.
++	 */
++	if (xen_hvm_domain()) {
++		if (per_cpu(xen_vcpu, cpu) == &per_cpu(xen_vcpu_info, cpu))
++			return 0;
++	}
++
++	if (xen_have_vcpu_info_placement) {
++		vcpup = &per_cpu(xen_vcpu_info, cpu);
++		info.mfn = arbitrary_virt_to_mfn(vcpup);
++		info.offset = offset_in_page(vcpup);
++
++		/*
++		 * Check to see if the hypervisor will put the vcpu_info
++		 * structure where we want it, which allows direct access via
++		 * a percpu-variable.
++		 * N.B. This hypercall can _only_ be called once per CPU.
++		 * Subsequent calls will error out with -EINVAL. This is due to
++		 * the fact that hypervisor has no unregister variant and this
++		 * hypercall does not allow to over-write info.mfn and
++		 * info.offset.
++		 */
++		err = HYPERVISOR_vcpu_op(VCPUOP_register_vcpu_info,
++					 xen_vcpu_nr(cpu), &info);
++
++		if (err) {
++			pr_warn_once("register_vcpu_info failed: cpu=%d err=%d\n",
++				     cpu, err);
++			xen_have_vcpu_info_placement = 0;
++		} else {
++			/*
++			 * This cpu is using the registered vcpu info, even if
++			 * later ones fail to.
++			 */
++			per_cpu(xen_vcpu, cpu) = vcpup;
++		}
++	}
++
++	if (!xen_have_vcpu_info_placement)
++		xen_vcpu_info_reset(cpu);
++
++	return ((per_cpu(xen_vcpu, cpu) == NULL) ? -ENODEV : 0);
++>>>>>>> c9b5d98b2516 (xen/vcpu: Handle xen_vcpu_setup() failure in hotplug)
 +}
 +
 +static void xen_write_cr0(unsigned long cr0)
 +{
 +	struct multicall_space mcs;
 +
 +	this_cpu_write(xen_cr0_value, cr0);
 +
 +	/* Only pay attention to cr0.TS; everything else is
 +	   ignored. */
 +	mcs = xen_mc_entry(0);
 +
 +	MULTI_fpu_taskswitch(mcs.mc, (cr0 & X86_CR0_TS) != 0);
 +
 +	xen_mc_issue(PARAVIRT_LAZY_CPU);
 +}
 +
 +static void xen_write_cr4(unsigned long cr4)
 +{
 +	cr4 &= ~X86_CR4_PGE;
 +	cr4 &= ~X86_CR4_PSE;
 +
 +	native_write_cr4(cr4);
 +}
 +#ifdef CONFIG_X86_64
 +static inline unsigned long xen_read_cr8(void)
 +{
 +	return 0;
 +}
 +static inline void xen_write_cr8(unsigned long val)
 +{
 +	BUG_ON(val);
 +}
 +#endif
 +static int xen_write_msr_safe(unsigned int msr, unsigned low, unsigned high)
 +{
 +	int ret;
 +
 +	ret = 0;
 +
 +	switch (msr) {
 +#ifdef CONFIG_X86_64
 +		unsigned which;
 +		u64 base;
 +
 +	case MSR_FS_BASE:		which = SEGBASE_FS; goto set;
 +	case MSR_KERNEL_GS_BASE:	which = SEGBASE_GS_USER; goto set;
 +	case MSR_GS_BASE:		which = SEGBASE_GS_KERNEL; goto set;
 +
 +	set:
 +		base = ((u64)high << 32) | low;
 +		if (HYPERVISOR_set_segment_base(which, base) != 0)
 +			ret = -EIO;
 +		break;
 +#endif
 +
 +	case MSR_STAR:
 +	case MSR_CSTAR:
 +	case MSR_LSTAR:
 +	case MSR_SYSCALL_MASK:
 +	case MSR_IA32_SYSENTER_CS:
 +	case MSR_IA32_SYSENTER_ESP:
 +	case MSR_IA32_SYSENTER_EIP:
 +		/* Fast syscall setup is all done in hypercalls, so
 +		   these are all ignored.  Stub them out here to stop
 +		   Xen console noise. */
 +		break;
 +
 +	case MSR_IA32_CR_PAT:
 +		if (smp_processor_id() == 0)
 +			xen_set_pat(((u64)high << 32) | low);
 +		break;
 +
 +	default:
 +		ret = native_write_msr_safe(msr, low, high);
 +	}
 +
 +	return ret;
 +}
 +
 +void xen_setup_shared_info(void)
 +{
 +	if (!xen_feature(XENFEAT_auto_translated_physmap)) {
 +		set_fixmap(FIX_PARAVIRT_BOOTMAP,
 +			   xen_start_info->shared_info);
 +
 +		HYPERVISOR_shared_info =
 +			(struct shared_info *)fix_to_virt(FIX_PARAVIRT_BOOTMAP);
 +	} else
 +		HYPERVISOR_shared_info =
 +			(struct shared_info *)__va(xen_start_info->shared_info);
 +
 +#ifndef CONFIG_SMP
 +	/* In UP this is as good a place as any to set up shared info */
 +	xen_setup_vcpu_info_placement();
 +#endif
 +
 +	xen_setup_mfn_list_list();
 +}
 +
 +/* This is called once we have the cpu_possible_mask */
 +void xen_setup_vcpu_info_placement(void)
 +{
 +	int cpu;
 +
 +	for_each_possible_cpu(cpu) {
 +		/* Set up direct vCPU id mapping for PV guests. */
 +		per_cpu(xen_vcpu_id, cpu) = cpu;
 +		xen_vcpu_setup(cpu);
 +	}
 +
 +	/* xen_vcpu_setup managed to place the vcpu_info within the
 +	   percpu area for all cpus, so make use of it */
 +	if (have_vcpu_info_placement) {
 +		pv_irq_ops.save_fl = __PV_IS_CALLEE_SAVE(xen_save_fl_direct);
 +		pv_irq_ops.restore_fl = __PV_IS_CALLEE_SAVE(xen_restore_fl_direct);
 +		pv_irq_ops.irq_disable = __PV_IS_CALLEE_SAVE(xen_irq_disable_direct);
 +		pv_irq_ops.irq_enable = __PV_IS_CALLEE_SAVE(xen_irq_enable_direct);
 +		pv_mmu_ops.read_cr2 = xen_read_cr2_direct;
 +	}
 +}
 +
 +static unsigned xen_patch(u8 type, u16 clobbers, void *insnbuf,
 +			  unsigned long addr, unsigned len)
 +{
 +	char *start, *end, *reloc;
 +	unsigned ret;
 +
 +	start = end = reloc = NULL;
 +
 +#define SITE(op, x)							\
 +	case PARAVIRT_PATCH(op.x):					\
 +	if (have_vcpu_info_placement) {					\
 +		start = (char *)xen_##x##_direct;			\
 +		end = xen_##x##_direct_end;				\
 +		reloc = xen_##x##_direct_reloc;				\
 +	}								\
 +	goto patch_site
 +
 +	switch (type) {
 +		SITE(pv_irq_ops, irq_enable);
 +		SITE(pv_irq_ops, irq_disable);
 +		SITE(pv_irq_ops, save_fl);
 +		SITE(pv_irq_ops, restore_fl);
 +#undef SITE
 +
 +	patch_site:
 +		if (start == NULL || (end-start) > len)
 +			goto default_patch;
 +
 +		ret = paravirt_patch_insns(insnbuf, len, start, end);
 +
 +		/* Note: because reloc is assigned from something that
 +		   appears to be an array, gcc assumes it's non-null,
 +		   but doesn't know its relationship with start and
 +		   end. */
 +		if (reloc > start && reloc < end) {
 +			int reloc_off = reloc - start;
 +			long *relocp = (long *)(insnbuf + reloc_off);
 +			long delta = start - (char *)addr;
 +
 +			*relocp += delta;
 +		}
 +		break;
 +
 +	default_patch:
 +	default:
 +		ret = paravirt_patch_default(type, clobbers, insnbuf,
 +					     addr, len);
 +		break;
 +	}
 +
 +	return ret;
 +}
 +
 +static const struct pv_info xen_info __initconst = {
 +	.paravirt_enabled = 1,
 +	.shared_kernel_pmd = 0,
 +
 +#ifdef CONFIG_X86_64
 +	.extra_user_64bit_cs = FLAT_USER_CS64,
 +#endif
 +
 +	.name = "Xen",
 +};
 +
 +static const struct pv_init_ops xen_init_ops __initconst = {
 +	.patch = xen_patch,
 +};
 +
 +static const struct pv_cpu_ops xen_cpu_ops __initconst = {
 +	.cpuid = xen_cpuid,
 +
 +	.set_debugreg = xen_set_debugreg,
 +	.get_debugreg = xen_get_debugreg,
 +
 +	.clts = xen_clts,
 +
 +	.read_cr0 = xen_read_cr0,
 +	.write_cr0 = xen_write_cr0,
 +
 +	.read_cr4 = native_read_cr4,
 +	.read_cr4_safe = native_read_cr4_safe,
 +	.write_cr4 = xen_write_cr4,
 +
 +#ifdef CONFIG_X86_64
 +	.read_cr8 = xen_read_cr8,
 +	.write_cr8 = xen_write_cr8,
 +#endif
 +
 +	.wbinvd = native_wbinvd,
 +
 +	.read_msr = native_read_msr_safe,
 +	.write_msr = xen_write_msr_safe,
 +
 +	.read_pmc = native_read_pmc,
 +
 +	.iret = xen_iret,
 +	.irq_enable_sysexit = xen_sysexit,
 +#ifdef CONFIG_X86_64
 +	.usergs_sysret32 = xen_sysret32,
 +	.usergs_sysret64 = xen_sysret64,
 +#endif
 +
 +	.load_tr_desc = paravirt_nop,
 +	.set_ldt = xen_set_ldt,
 +	.load_gdt = xen_load_gdt,
 +	.load_idt = xen_load_idt,
 +	.load_tls = xen_load_tls,
 +#ifdef CONFIG_X86_64
 +	.load_gs_index = xen_load_gs_index,
 +#endif
 +
 +	.alloc_ldt = xen_alloc_ldt,
 +	.free_ldt = xen_free_ldt,
 +
 +	.store_idt = native_store_idt,
 +	.store_tr = xen_store_tr,
 +
 +	.write_ldt_entry = xen_write_ldt_entry,
 +	.write_gdt_entry = xen_write_gdt_entry,
 +	.write_idt_entry = xen_write_idt_entry,
 +	.load_sp0 = xen_load_sp0,
 +
 +	.set_iopl_mask = xen_set_iopl_mask,
 +	.io_delay = xen_io_delay,
 +
 +	/* Xen takes care of %gs when switching to usermode for us */
 +	.swapgs = paravirt_nop,
 +
 +	.start_context_switch = paravirt_start_context_switch,
 +	.end_context_switch = xen_end_context_switch,
 +};
 +
 +static const struct pv_apic_ops xen_apic_ops __initconst = {
 +#ifdef CONFIG_X86_LOCAL_APIC
 +	.startup_ipi_hook = paravirt_nop,
 +#endif
 +};
 +
 +static void xen_reboot(int reason)
 +{
 +	struct sched_shutdown r = { .reason = reason };
 +
 +	if (HYPERVISOR_sched_op(SCHEDOP_shutdown, &r))
 +		BUG();
 +}
 +
 +static void xen_restart(char *msg)
 +{
 +	xen_reboot(SHUTDOWN_reboot);
 +}
 +
 +static void xen_emergency_restart(void)
 +{
 +	xen_reboot(SHUTDOWN_reboot);
 +}
 +
 +static void xen_machine_halt(void)
 +{
 +	xen_reboot(SHUTDOWN_poweroff);
 +}
 +
 +static void xen_machine_power_off(void)
 +{
 +	if (pm_power_off)
 +		pm_power_off();
 +	xen_reboot(SHUTDOWN_poweroff);
 +}
 +
 +static void xen_crash_shutdown(struct pt_regs *regs)
 +{
 +	xen_reboot(SHUTDOWN_crash);
 +}
 +
 +static int
 +xen_panic_event(struct notifier_block *this, unsigned long event, void *ptr)
 +{
 +	xen_reboot(SHUTDOWN_crash);
 +	return NOTIFY_DONE;
 +}
 +
 +static struct notifier_block xen_panic_block = {
 +	.notifier_call= xen_panic_event,
 +};
 +
 +int xen_panic_handler_init(void)
 +{
 +	atomic_notifier_chain_register(&panic_notifier_list, &xen_panic_block);
 +	return 0;
 +}
 +
 +static const struct machine_ops xen_machine_ops __initconst = {
 +	.restart = xen_restart,
 +	.halt = xen_machine_halt,
 +	.power_off = xen_machine_power_off,
 +	.shutdown = xen_machine_halt,
 +	.crash_shutdown = xen_crash_shutdown,
 +	.emergency_restart = xen_emergency_restart,
 +};
 +
 +static void __init xen_boot_params_init_edd(void)
 +{
 +#if IS_ENABLED(CONFIG_EDD)
 +	struct xen_platform_op op;
 +	struct edd_info *edd_info;
 +	u32 *mbr_signature;
 +	unsigned nr;
 +	int ret;
 +
 +	edd_info = boot_params.eddbuf;
 +	mbr_signature = boot_params.edd_mbr_sig_buffer;
 +
 +	op.cmd = XENPF_firmware_info;
 +
 +	op.u.firmware_info.type = XEN_FW_DISK_INFO;
 +	for (nr = 0; nr < EDDMAXNR; nr++) {
 +		struct edd_info *info = edd_info + nr;
 +
 +		op.u.firmware_info.index = nr;
 +		info->params.length = sizeof(info->params);
 +		set_xen_guest_handle(op.u.firmware_info.u.disk_info.edd_params,
 +				     &info->params);
 +		ret = HYPERVISOR_dom0_op(&op);
 +		if (ret)
 +			break;
 +
 +#define C(x) info->x = op.u.firmware_info.u.disk_info.x
 +		C(device);
 +		C(version);
 +		C(interface_support);
 +		C(legacy_max_cylinder);
 +		C(legacy_max_head);
 +		C(legacy_sectors_per_track);
 +#undef C
 +	}
 +	boot_params.eddbuf_entries = nr;
 +
 +	op.u.firmware_info.type = XEN_FW_DISK_MBR_SIGNATURE;
 +	for (nr = 0; nr < EDD_MBR_SIG_MAX; nr++) {
 +		op.u.firmware_info.index = nr;
 +		ret = HYPERVISOR_dom0_op(&op);
 +		if (ret)
 +			break;
 +		mbr_signature[nr] = op.u.firmware_info.u.disk_mbr_signature.mbr_signature;
 +	}
 +	boot_params.edd_mbr_sig_buf_entries = nr;
 +#endif
 +}
 +
 +/*
 + * Set up the GDT and segment registers for -fstack-protector.  Until
 + * we do this, we have to be careful not to call any stack-protected
 + * function, which is most of the kernel.
 + */
 +static void __init xen_setup_stackprotector(void)
 +{
 +	pv_cpu_ops.write_gdt_entry = xen_write_gdt_entry_boot;
 +	pv_cpu_ops.load_gdt = xen_load_gdt_boot;
 +
 +	setup_stack_canary_segment(0);
 +	switch_to_new_gdt(0);
 +
 +	pv_cpu_ops.write_gdt_entry = xen_write_gdt_entry;
 +	pv_cpu_ops.load_gdt = xen_load_gdt;
 +}
 +
 +/* First C function to be called on Xen boot */
 +asmlinkage void __init xen_start_kernel(void)
 +{
 +	struct physdev_set_iopl set_iopl;
 +	int rc;
 +
 +	if (!xen_start_info)
 +		return;
 +
 +	xen_domain_type = XEN_PV_DOMAIN;
 +
 +	xen_setup_machphys_mapping();
 +
 +	/* Install Xen paravirt ops */
 +	pv_info = xen_info;
 +	pv_init_ops = xen_init_ops;
 +	pv_cpu_ops = xen_cpu_ops;
 +	pv_apic_ops = xen_apic_ops;
 +
 +	x86_init.resources.memory_setup = xen_memory_setup;
 +	x86_init.oem.arch_setup = xen_arch_setup;
 +	x86_init.oem.banner = xen_banner;
 +
 +	xen_init_time_ops();
 +
 +	/*
 +	 * Set up some pagetable state before starting to set any ptes.
 +	 */
 +
 +	xen_init_mmu_ops();
 +
 +	/* Prevent unwanted bits from being set in PTEs. */
 +	__supported_pte_mask &= ~_PAGE_GLOBAL;
 +#if 0
 +	if (!xen_initial_domain())
 +#endif
 +		__supported_pte_mask &= ~(_PAGE_PWT | _PAGE_PCD);
 +
 +	__supported_pte_mask |= _PAGE_IOMAP;
 +
 +	/*
 +	 * Prevent page tables from being allocated in highmem, even
 +	 * if CONFIG_HIGHPTE is enabled.
 +	 */
 +	__userpte_alloc_gfp &= ~__GFP_HIGHMEM;
 +
 +	/* Work out if we support NX */
 +	x86_configure_nx();
 +
 +	xen_setup_features();
 +
 +	/* Get mfn list */
 +	if (!xen_feature(XENFEAT_auto_translated_physmap))
 +		xen_build_dynamic_phys_to_machine();
 +
 +	/*
 +	 * Set up kernel GDT and segment registers, mainly so that
 +	 * -fstack-protector code can be executed.
 +	 */
 +	xen_setup_stackprotector();
 +
 +	xen_init_irq_ops();
 +	xen_init_cpuid_mask();
 +
 +#ifdef CONFIG_X86_LOCAL_APIC
 +	/*
 +	 * set up the basic apic ops.
 +	 */
 +	set_xen_basic_apic_ops();
 +#endif
 +
 +	if (xen_feature(XENFEAT_mmu_pt_update_preserve_ad)) {
 +		pv_mmu_ops.ptep_modify_prot_start = xen_ptep_modify_prot_start;
 +		pv_mmu_ops.ptep_modify_prot_commit = xen_ptep_modify_prot_commit;
 +	}
 +
 +	machine_ops = xen_machine_ops;
 +
 +	/*
 +	 * The only reliable way to retain the initial address of the
 +	 * percpu gdt_page is to remember it here, so we can go and
 +	 * mark it RW later, when the initial percpu area is freed.
 +	 */
 +	xen_initial_gdt = &per_cpu(gdt_page, 0);
 +
 +	xen_smp_init();
 +
 +#ifdef CONFIG_ACPI_NUMA
 +	/*
 +	 * The pages we from Xen are not related to machine pages, so
 +	 * any NUMA information the kernel tries to get from ACPI will
 +	 * be meaningless.  Prevent it from trying.
 +	 */
 +	acpi_numa = -1;
 +#endif
 +#ifdef CONFIG_X86_PAT
 +	/*
 +	 * For right now disable the PAT. We should remove this once
 +	 * git commit 8eaffa67b43e99ae581622c5133e20b0f48bcef1
 +	 * (xen/pat: Disable PAT support for now) is reverted.
 +	 */
 +	pat_enabled = 0;
 +#endif
 +	/* Don't do the full vcpu_info placement stuff until we have a
 +	   possible map and a non-dummy shared_info. */
 +	per_cpu(xen_vcpu, 0) = &HYPERVISOR_shared_info->vcpu_info[0];
 +
 +	local_irq_disable();
 +	early_boot_irqs_disabled = true;
 +
 +	xen_raw_console_write("mapping kernel into physical memory\n");
 +	xen_setup_kernel_pagetable((pgd_t *)xen_start_info->pt_base, xen_start_info->nr_pages);
 +
 +	/* Allocate and initialize top and mid mfn levels for p2m structure */
 +	xen_build_mfn_list_list();
 +
 +	/* keep using Xen gdt for now; no urgent need to change it */
 +
 +#ifdef CONFIG_X86_32
 +	pv_info.kernel_rpl = 1;
 +	if (xen_feature(XENFEAT_supervisor_mode_kernel))
 +		pv_info.kernel_rpl = 0;
 +#else
 +	pv_info.kernel_rpl = 0;
 +#endif
 +	/* set the limit of our address space */
 +	xen_reserve_top();
 +
 +	/* We used to do this in xen_arch_setup, but that is too late on AMD
 +	 * were early_cpu_init (run before ->arch_setup()) calls early_amd_init
 +	 * which pokes 0xcf8 port.
 +	 */
 +	set_iopl.iopl = 1;
 +	rc = HYPERVISOR_physdev_op(PHYSDEVOP_set_iopl, &set_iopl);
 +	if (rc != 0)
 +		xen_raw_printk("physdev_op failed %d\n", rc);
 +
 +#ifdef CONFIG_X86_32
 +	/* set up basic CPUID stuff */
 +	cpu_detect(&new_cpu_data);
 +	new_cpu_data.hard_math = 1;
 +	new_cpu_data.wp_works_ok = 1;
 +	new_cpu_data.x86_capability[0] = cpuid_edx(1);
 +#endif
 +
 +	/* Poke various useful things into boot_params */
 +	boot_params.hdr.type_of_loader = (9 << 4) | 0;
 +	boot_params.hdr.ramdisk_image = xen_start_info->mod_start
 +		? __pa(xen_start_info->mod_start) : 0;
 +	boot_params.hdr.ramdisk_size = xen_start_info->mod_len;
 +	boot_params.hdr.cmd_line_ptr = __pa(xen_start_info->cmd_line);
 +
 +	if (!xen_initial_domain()) {
 +		add_preferred_console("xenboot", 0, NULL);
 +		add_preferred_console("tty", 0, NULL);
 +		add_preferred_console("hvc", 0, NULL);
 +		if (pci_xen)
 +			x86_init.pci.arch_init = pci_xen_init;
 +	} else {
 +		const struct dom0_vga_console_info *info =
 +			(void *)((char *)xen_start_info +
 +				 xen_start_info->console.dom0.info_off);
 +		struct xen_platform_op op = {
 +			.cmd = XENPF_firmware_info,
 +			.interface_version = XENPF_INTERFACE_VERSION,
 +			.u.firmware_info.type = XEN_FW_KBD_SHIFT_FLAGS,
 +		};
 +
 +		xen_init_vga(info, xen_start_info->console.dom0.info_size);
 +		xen_start_info->console.domU.mfn = 0;
 +		xen_start_info->console.domU.evtchn = 0;
 +
 +		if (HYPERVISOR_dom0_op(&op) == 0)
 +			boot_params.kbd_status = op.u.firmware_info.u.kbd_shift_flags;
 +
 +		xen_init_apic();
 +
 +		/* Make sure ACS will be enabled */
 +		pci_request_acs();
 +
 +		xen_acpi_sleep_register();
 +
 +		/* Avoid searching for BIOS MP tables */
 +		x86_init.mpparse.find_smp_config = x86_init_noop;
 +		x86_init.mpparse.get_smp_config = x86_init_uint_noop;
 +
 +		xen_boot_params_init_edd();
 +	}
 +#ifdef CONFIG_PCI
 +	/* PCI BIOS service won't work from a PV guest. */
 +	pci_probe &= ~PCI_PROBE_BIOS;
 +#endif
 +	xen_raw_console_write("about to get started...\n");
 +
 +	/* Let's presume PV guests always boot on vCPU with id 0. */
 +	per_cpu(xen_vcpu_id, 0) = 0;
 +
 +	xen_setup_runstate_info(0);
 +
 +	/* Start the world */
 +#ifdef CONFIG_X86_32
 +	i386_start_kernel();
 +#else
 +	x86_64_start_reservations((char *)__pa_symbol(&boot_params));
 +#endif
 +}
 +
 +void __ref xen_hvm_init_shared_info(void)
 +{
 +	int cpu;
 +	struct xen_add_to_physmap xatp;
 +	static struct shared_info *shared_info_page = 0;
 +
 +	if (!shared_info_page)
 +		shared_info_page = (struct shared_info *)
 +			extend_brk(PAGE_SIZE, PAGE_SIZE);
 +	xatp.domid = DOMID_SELF;
 +	xatp.idx = 0;
 +	xatp.space = XENMAPSPACE_shared_info;
 +	xatp.gpfn = __pa(shared_info_page) >> PAGE_SHIFT;
 +	if (HYPERVISOR_memory_op(XENMEM_add_to_physmap, &xatp))
 +		BUG();
 +
 +	HYPERVISOR_shared_info = (struct shared_info *)shared_info_page;
 +
 +	/* xen_vcpu is a pointer to the vcpu_info struct in the shared_info
 +	 * page, we use it in the event channel upcall and in some pvclock
 +	 * related functions. We don't need the vcpu_info placement
 +	 * optimizations because we don't use any pv_mmu or pv_irq op on
 +	 * HVM.
 +	 * When xen_hvm_init_shared_info is run at boot time only vcpu 0 is
 +	 * online but xen_hvm_init_shared_info is run at resume time too and
 +	 * in that case multiple vcpus might be online. */
 +	for_each_online_cpu(cpu) {
 +		/* Leave it to be NULL. */
 +		if (xen_vcpu_nr(cpu) >= MAX_VIRT_CPUS)
 +			continue;
 +		per_cpu(xen_vcpu, cpu) =
 +			&HYPERVISOR_shared_info->vcpu_info[xen_vcpu_nr(cpu)];
 +	}
 +}
 +
 +#ifdef CONFIG_XEN_PVHVM
 +static void __init init_hvm_pv_info(void)
 +{
 +	int major, minor;
 +	uint32_t eax, ebx, ecx, edx, pages, msr, base;
 +	u64 pfn;
 +
 +	base = xen_cpuid_base();
 +	cpuid(base + 1, &eax, &ebx, &ecx, &edx);
 +
 +	major = eax >> 16;
 +	minor = eax & 0xffff;
 +	printk(KERN_INFO "Xen version %d.%d.\n", major, minor);
 +
 +	cpuid(base + 2, &pages, &msr, &ecx, &edx);
 +
 +	pfn = __pa(hypercall_page);
 +	wrmsr_safe(msr, (u32)pfn, (u32)(pfn >> 32));
 +
 +	xen_setup_features();
 +
 +	cpuid(base + 4, &eax, &ebx, &ecx, &edx);
 +	if (eax & XEN_HVM_CPUID_VCPU_ID_PRESENT)
 +		this_cpu_write(xen_vcpu_id, ebx);
 +	else
 +		this_cpu_write(xen_vcpu_id, smp_processor_id());
 +
 +	pv_info.name = "Xen HVM";
 +
 +	xen_domain_type = XEN_HVM_DOMAIN;
 +}
 +
 +static int xen_hvm_cpu_notify(struct notifier_block *self, unsigned long action,
 +			      void *hcpu)
 +{
 +	int cpu = (long)hcpu;
 +	switch (action) {
 +	case CPU_UP_PREPARE:
 +		if (cpu_acpi_id(cpu) != U32_MAX)
 +			per_cpu(xen_vcpu_id, cpu) = cpu_acpi_id(cpu);
 +		else
 +			per_cpu(xen_vcpu_id, cpu) = cpu;
 +		xen_vcpu_setup(cpu);
 +		if (xen_have_vector_callback) {
 +			if (xen_feature(XENFEAT_hvm_safe_pvclock))
 +				xen_setup_timer(cpu);
 +		}
 +		break;
 +	default:
 +		break;
 +	}
 +	return NOTIFY_OK;
 +}
 +
 +static struct notifier_block xen_hvm_cpu_notifier = {
 +	.notifier_call	= xen_hvm_cpu_notify,
 +};
 +
 +#ifdef CONFIG_KEXEC_CORE
 +static void xen_hvm_shutdown(void)
 +{
 +	native_machine_shutdown();
 +	if (kexec_in_progress)
 +		xen_reboot(SHUTDOWN_soft_reset);
 +}
 +
 +static void xen_hvm_crash_shutdown(struct pt_regs *regs)
 +{
 +	native_machine_crash_shutdown(regs);
 +	xen_reboot(SHUTDOWN_soft_reset);
 +}
 +#endif
 +
 +static void __init xen_hvm_guest_init(void)
 +{
 +	init_hvm_pv_info();
 +
 +	xen_hvm_init_shared_info();
 +
 +	xen_panic_handler_init();
 +
 +	if (xen_feature(XENFEAT_hvm_callback_vector))
 +		xen_have_vector_callback = 1;
 +	xen_hvm_smp_init();
 +	register_cpu_notifier(&xen_hvm_cpu_notifier);
 +	xen_unplug_emulated_devices();
 +	x86_init.irqs.intr_init = xen_init_IRQ;
 +	xen_hvm_init_time_ops();
 +	xen_hvm_init_mmu_ops();
 +#ifdef CONFIG_KEXEC_CORE
 +	if (xen_running_on_version_or_later(3, 2)) {
 +		machine_ops.shutdown = xen_hvm_shutdown;
 +		machine_ops.crash_shutdown = xen_hvm_crash_shutdown;
 +	}
 +#endif
 +}
 +
 +static uint32_t __init xen_hvm_platform(void)
 +{
 +	uint32_t eax, ebx, ecx, edx, base;
 +	int major, minor;
 +
 +	if (xen_pv_domain())
 +		return 0;
 +
 +	/*
 +	 * RHEL-only: old Xen versions (e.g. RHEL5 Xen) allow booting pure HVM
 +	 * kernel after kdump but for newer versions this trick won't work and
 +	 * we must reestablish PV interfaces if we ever used them. We hope that
 +	 * crashing kernel did SHUTDOWN_soft_reset call and that this call is
 +	 * supported by the hypervisor.
 +	 */
 +
 +	base = xen_cpuid_base();
 +
 +	if (base && is_kdump_kernel()) {
 +		cpuid(base + 1, &eax, &ebx, &ecx, &edx);
 +		major = eax >> 16;
 +		minor = eax & 0xffff;
 +		if (major == 3 && minor < 2)
 +			return 0;
 +	}
 +
 +	return base;
 +}
 +
 +bool xen_hvm_need_lapic(void)
 +{
 +	if (xen_pv_domain())
 +		return false;
 +	if (!xen_hvm_domain())
 +		return false;
 +	if (xen_feature(XENFEAT_hvm_pirqs) && xen_have_vector_callback)
 +		return false;
 +	return true;
 +}
 +EXPORT_SYMBOL_GPL(xen_hvm_need_lapic);
 +
 +const struct hypervisor_x86 x86_hyper_xen_hvm __refconst = {
 +	.name			= "Xen HVM",
 +	.detect			= xen_hvm_platform,
 +	.init_platform		= xen_hvm_guest_init,
 +	.x2apic_available	= xen_x2apic_para_available,
 +};
 +EXPORT_SYMBOL(x86_hyper_xen_hvm);
  #endif
diff --cc arch/x86/xen/xen-ops.h
index 774e39171c8c,0d5004477db6..000000000000
--- a/arch/x86/xen/xen-ops.h
+++ b/arch/x86/xen/xen-ops.h
@@@ -59,7 -76,10 +59,14 @@@ irqreturn_t xen_debug_interrupt(int irq
  
  bool xen_vcpu_stolen(int vcpu);
  
++<<<<<<< HEAD
 +void xen_vcpu_setup(int cpu);
++=======
+ extern int xen_have_vcpu_info_placement;
+ 
+ int xen_vcpu_setup(int cpu);
+ void xen_vcpu_info_reset(int cpu);
++>>>>>>> c9b5d98b2516 (xen/vcpu: Handle xen_vcpu_setup() failure in hotplug)
  void xen_setup_vcpu_info_placement(void);
  
  #ifdef CONFIG_SMP
* Unmerged path arch/x86/xen/enlighten_hvm.c
* Unmerged path arch/x86/xen/enlighten_pv.c
* Unmerged path arch/x86/xen/enlighten.c
* Unmerged path arch/x86/xen/enlighten_hvm.c
* Unmerged path arch/x86/xen/enlighten_pv.c
* Unmerged path arch/x86/xen/xen-ops.h
