Bluetooth: Prevent stack info leak from the EFS element.

jira LE-1907
cve CVE-2017-1000410
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] bluetooth: Prevent stack info leak from the EFS element (Gopal Tiwari) [1519633] {CVE-2017-1000410}
Rebuild_FUZZ: 99.10%
commit-author Ben Seri <ben@armis.com>
commit 06e7e776ca4d36547e503279aeff996cbb292c16
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/06e7e776.failed

In the function l2cap_parse_conf_rsp and in the function
l2cap_parse_conf_req the following variable is declared without
initialization:

struct l2cap_conf_efs efs;

In addition, when parsing input configuration parameters in both of
these functions, the switch case for handling EFS elements may skip the
memcpy call that will write to the efs variable:

...
case L2CAP_CONF_EFS:
if (olen == sizeof(efs))
memcpy(&efs, (void *)val, olen);
...

The olen in the above if is attacker controlled, and regardless of that
if, in both of these functions the efs variable would eventually be
added to the outgoing configuration request that is being built:

l2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS, sizeof(efs), (unsigned long) &efs);

So by sending a configuration request, or response, that contains an
L2CAP_CONF_EFS element, but with an element length that is not
sizeof(efs) - the memcpy to the uninitialized efs variable can be
avoided, and the uninitialized variable would be returned to the
attacker (16 bytes).

This issue has been assigned CVE-2017-1000410

	Cc: Marcel Holtmann <marcel@holtmann.org>
	Cc: Gustavo Padovan <gustavo@padovan.org>
	Cc: Johan Hedberg <johan.hedberg@gmail.com>
	Cc: stable <stable@vger.kernel.org>
	Signed-off-by: Ben Seri <ben@armis.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 06e7e776ca4d36547e503279aeff996cbb292c16)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bluetooth/l2cap_core.c
diff --cc net/bluetooth/l2cap_core.c
index cc955a240861,fc6615d59165..000000000000
--- a/net/bluetooth/l2cap_core.c
+++ b/net/bluetooth/l2cap_core.c
@@@ -3569,16 -3585,17 +3570,22 @@@ static int l2cap_parse_conf_rsp(struct 
  			break;
  
  		case L2CAP_CONF_EFS:
- 			if (olen == sizeof(efs))
+ 			if (olen == sizeof(efs)) {
  				memcpy(&efs, (void *)val, olen);
  
- 			if (chan->local_stype != L2CAP_SERV_NOTRAFIC &&
- 			    efs.stype != L2CAP_SERV_NOTRAFIC &&
- 			    efs.stype != chan->local_stype)
- 				return -ECONNREFUSED;
+ 				if (chan->local_stype != L2CAP_SERV_NOTRAFIC &&
+ 				    efs.stype != L2CAP_SERV_NOTRAFIC &&
+ 				    efs.stype != chan->local_stype)
+ 					return -ECONNREFUSED;
  
++<<<<<<< HEAD
 +			l2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS, sizeof(efs),
 +					   (unsigned long) &efs);
++=======
+ 				l2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS, sizeof(efs),
+ 						   (unsigned long) &efs, endptr - ptr);
+ 			}
++>>>>>>> 06e7e776ca4d (Bluetooth: Prevent stack info leak from the EFS element.)
  			break;
  
  		case L2CAP_CONF_FCS:
* Unmerged path net/bluetooth/l2cap_core.c
