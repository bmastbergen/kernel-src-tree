ALSA: x86: Support S16 format

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Takashi Iwai <tiwai@suse.de>
commit 3fe2cf7eb21ada0a9683b26c1ae309e7f5e90131
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/3fe2cf7e.failed

Now we support S16 PCM format in addition.  For this, we need to set
packet_mode=1 in AUD_CONFIG register.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 3fe2cf7eb21ada0a9683b26c1ae309e7f5e90131)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/x86/intel_hdmi_audio.c
diff --cc sound/x86/intel_hdmi_audio.c
index 3dd33e089501,c0a080e5d1f4..000000000000
--- a/sound/x86/intel_hdmi_audio.c
+++ b/sound/x86/intel_hdmi_audio.c
@@@ -127,11 -130,14 +127,19 @@@ static const struct channel_map_table m
  };
  
  /* hardware capability structure */
 -static const struct snd_pcm_hardware had_pcm_hardware = {
 +static const struct snd_pcm_hardware snd_intel_hadstream = {
  	.info =	(SNDRV_PCM_INFO_INTERLEAVED |
  		SNDRV_PCM_INFO_MMAP |
++<<<<<<< HEAD
 +		SNDRV_PCM_INFO_MMAP_VALID),
 +	.formats = SNDRV_PCM_FMTBIT_S24,
++=======
+ 		SNDRV_PCM_INFO_MMAP_VALID |
+ 		SNDRV_PCM_INFO_NO_PERIOD_WAKEUP),
+ 	.formats = (SNDRV_PCM_FMTBIT_S16_LE |
+ 		    SNDRV_PCM_FMTBIT_S24_LE |
+ 		    SNDRV_PCM_FMTBIT_S32_LE),
++>>>>>>> 3fe2cf7eb21a (ALSA: x86: Support S16 format)
  	.rates = SNDRV_PCM_RATE_32000 |
  		SNDRV_PCM_RATE_44100 |
  		SNDRV_PCM_RATE_48000 |
@@@ -324,26 -285,27 +332,41 @@@ static int had_prog_status_reg(struct s
  	default:
  		/* control should never come here */
  		return -EINVAL;
 -	}
 +	break;
  
 +	}
  	had_write_register(intelhaddata,
 -			   AUD_CH_STATUS_0, ch_stat0.regval);
 +			   AUD_CH_STATUS_0, ch_stat0.status_0_regval);
 +
++<<<<<<< HEAD
 +	format = substream->runtime->format;
  
 +	if (format == SNDRV_PCM_FORMAT_S16_LE) {
 +		ch_stat1.status_1_regx.max_wrd_len = MAX_SMPL_WIDTH_20;
 +		ch_stat1.status_1_regx.wrd_len = SMPL_WIDTH_16BITS;
 +	} else if (format == SNDRV_PCM_FORMAT_S24_LE) {
 +		ch_stat1.status_1_regx.max_wrd_len = MAX_SMPL_WIDTH_24;
 +		ch_stat1.status_1_regx.wrd_len = SMPL_WIDTH_24BITS;
 +	} else {
 +		ch_stat1.status_1_regx.max_wrd_len = 0;
 +		ch_stat1.status_1_regx.wrd_len = 0;
++=======
+ 	switch (substream->runtime->format) {
+ 	case SNDRV_PCM_FORMAT_S16_LE:
+ 		ch_stat1.regx.max_wrd_len = MAX_SMPL_WIDTH_20;
+ 		ch_stat1.regx.wrd_len = SMPL_WIDTH_16BITS;
+ 		break;
+ 	case SNDRV_PCM_FORMAT_S24_LE:
+ 	case SNDRV_PCM_FORMAT_S32_LE:
+ 		ch_stat1.regx.max_wrd_len = MAX_SMPL_WIDTH_24;
+ 		ch_stat1.regx.wrd_len = SMPL_WIDTH_24BITS;
+ 		break;
+ 	default:
+ 		return -EINVAL;
++>>>>>>> 3fe2cf7eb21a (ALSA: x86: Support S16 format)
  	}
 -
  	had_write_register(intelhaddata,
 -			   AUD_CH_STATUS_1, ch_stat1.regval);
 +			   AUD_CH_STATUS_1, ch_stat1.status_1_regval);
  	return 0;
  }
  
@@@ -361,20 -323,34 +384,39 @@@ static int snd_intelhad_audio_ctrl(stru
  
  	had_prog_status_reg(substream, intelhaddata);
  
 -	buf_cfg.regx.audio_fifo_watermark = FIFO_THRESHOLD;
 -	buf_cfg.regx.dma_fifo_watermark = DMA_FIFO_THRESHOLD;
 -	buf_cfg.regx.aud_delay = 0;
 -	had_write_register(intelhaddata, AUD_BUF_CONFIG, buf_cfg.regval);
 +	buf_cfg.buf_cfg_regx_v2.audio_fifo_watermark = FIFO_THRESHOLD;
 +	buf_cfg.buf_cfg_regx_v2.dma_fifo_watermark = DMA_FIFO_THRESHOLD;
 +	buf_cfg.buf_cfg_regx_v2.aud_delay = 0;
 +	had_write_register(intelhaddata, AUD_BUF_CONFIG, buf_cfg.buf_cfgval);
  
  	channels = substream->runtime->channels;
 -	cfg_val.regx.num_ch = channels - 2;
 +	cfg_val.cfg_regx_v2.num_ch = channels - 2;
  	if (channels <= 2)
 -		cfg_val.regx.layout = LAYOUT0;
 +		cfg_val.cfg_regx_v2.layout = LAYOUT0;
  	else
 -		cfg_val.regx.layout = LAYOUT1;
 +		cfg_val.cfg_regx_v2.layout = LAYOUT1;
  
++<<<<<<< HEAD
 +	cfg_val.cfg_regx_v2.val_bit = 1;
 +	had_write_register(intelhaddata, AUD_CONFIG, cfg_val.cfg_regval);
++=======
+ 	if (substream->runtime->format == SNDRV_PCM_FORMAT_S16_LE)
+ 		cfg_val.regx.packet_mode = 1;
+ 
+ 	if (substream->runtime->format == SNDRV_PCM_FORMAT_S32_LE)
+ 		cfg_val.regx.left_align = 1;
+ 
+ 	cfg_val.regx.val_bit = 1;
+ 
+ 	/* fix up the DP bits */
+ 	if (intelhaddata->dp_output) {
+ 		cfg_val.regx.dp_modei = 1;
+ 		cfg_val.regx.set = 1;
+ 	}
+ 
+ 	had_write_register(intelhaddata, AUD_CONFIG, cfg_val.regval);
+ 	intelhaddata->aud_config = cfg_val;
++>>>>>>> 3fe2cf7eb21a (ALSA: x86: Support S16 format)
  	return 0;
  }
  
* Unmerged path sound/x86/intel_hdmi_audio.c
