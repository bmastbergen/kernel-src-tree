acpi, x86/mm: Remove encryption mask from ACPI page protection type

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Tom Lendacky <thomas.lendacky@amd.com>
commit 57bd1905b228f2a14d7506b0302f69f425131e57
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/57bd1905.failed

The arch_apei_get_mem_attributes() function is used to set the page
protection type for ACPI physical addresses. When SME is active, the
associated protection type cannot have the encryption mask set since the
ACPI tables live in un-encrypted memory - the kernel will see corrupted
data.

To fix this, create a new protection type, PAGE_KERNEL_NOENC, that is a
'no encryption' version of PAGE_KERNEL, and return that from
arch_apei_get_mem_attributes().

	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brijesh Singh <brijesh.singh@amd.com>
	Cc: Dave Young <dyoung@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/e1cb9395b2f061cd96f1e59c3cbbe5ff5d4ec26e.1501186516.git.thomas.lendacky@amd.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 57bd1905b228f2a14d7506b0302f69f425131e57)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/acpi.h
#	arch/x86/include/asm/pgtable_types.h
diff --cc arch/x86/include/asm/acpi.h
index db784f089a60,72d867f6b518..000000000000
--- a/arch/x86/include/asm/acpi.h
+++ b/arch/x86/include/asm/acpi.h
@@@ -138,6 -150,26 +138,30 @@@ extern int acpi_numa
  extern int x86_acpi_numa_init(void);
  #endif /* CONFIG_ACPI_NUMA */
  
++<<<<<<< HEAD
 +#define acpi_unlazy_tlb(x)	leave_mm(x)
++=======
+ #ifdef CONFIG_ACPI_APEI
+ static inline pgprot_t arch_apei_get_mem_attribute(phys_addr_t addr)
+ {
+ 	/*
+ 	 * We currently have no way to look up the EFI memory map
+ 	 * attributes for a region in a consistent way, because the
+ 	 * memmap is discarded after efi_free_boot_services(). So if
+ 	 * you call efi_mem_attributes() during boot and at runtime,
+ 	 * you could theoretically see different attributes.
+ 	 *
+ 	 * We are yet to see any x86 platforms that require anything
+ 	 * other than PAGE_KERNEL (some ARM64 platforms require the
+ 	 * equivalent of PAGE_KERNEL_NOCACHE). Additionally, if SME
+ 	 * is active, the ACPI information will not be encrypted,
+ 	 * so return PAGE_KERNEL_NOENC until we know differently.
+ 	 */
+ 	return PAGE_KERNEL_NOENC;
+ }
+ #endif
+ 
+ #define ACPI_TABLE_UPGRADE_MAX_PHYS (max_low_pfn_mapped << PAGE_SHIFT)
++>>>>>>> 57bd1905b228 (acpi, x86/mm: Remove encryption mask from ACPI page protection type)
  
  #endif /* _ASM_X86_ACPI_H */
diff --cc arch/x86/include/asm/pgtable_types.h
index 5e5b6dc9e568,399261ce904c..000000000000
--- a/arch/x86/include/asm/pgtable_types.h
+++ b/arch/x86/include/asm/pgtable_types.h
@@@ -220,41 -185,47 +220,73 @@@ enum page_cache_mode 
  
  #define __PAGE_KERNEL_RO		(__PAGE_KERNEL & ~_PAGE_RW)
  #define __PAGE_KERNEL_RX		(__PAGE_KERNEL_EXEC & ~_PAGE_RW)
 -#define __PAGE_KERNEL_NOCACHE		(__PAGE_KERNEL | _PAGE_NOCACHE)
 +#define __PAGE_KERNEL_EXEC_NOCACHE	(__PAGE_KERNEL_EXEC | _PAGE_PCD | _PAGE_PWT)
 +#define __PAGE_KERNEL_WC		(__PAGE_KERNEL | _PAGE_CACHE_WC)
 +#define __PAGE_KERNEL_NOCACHE		(__PAGE_KERNEL | _PAGE_PCD | _PAGE_PWT)
 +#define __PAGE_KERNEL_UC_MINUS		(__PAGE_KERNEL | _PAGE_PCD)
  #define __PAGE_KERNEL_VSYSCALL		(__PAGE_KERNEL_RX | _PAGE_USER)
  #define __PAGE_KERNEL_VVAR		(__PAGE_KERNEL_RO | _PAGE_USER)
 +#define __PAGE_KERNEL_VVAR_NOCACHE	(__PAGE_KERNEL_VVAR | _PAGE_PCD | _PAGE_PWT)
  #define __PAGE_KERNEL_LARGE		(__PAGE_KERNEL | _PAGE_PSE)
 +#define __PAGE_KERNEL_LARGE_NOCACHE	(__PAGE_KERNEL | _PAGE_CACHE_UC | _PAGE_PSE)
  #define __PAGE_KERNEL_LARGE_EXEC	(__PAGE_KERNEL_EXEC | _PAGE_PSE)
 -#define __PAGE_KERNEL_WP		(__PAGE_KERNEL | _PAGE_CACHE_WP)
 -
 -#define __PAGE_KERNEL_IO		(__PAGE_KERNEL)
 -#define __PAGE_KERNEL_IO_NOCACHE	(__PAGE_KERNEL_NOCACHE)
 -
 -#ifndef __ASSEMBLY__
  
 +#define __PAGE_KERNEL_IO		(__PAGE_KERNEL | _PAGE_IOMAP)
 +#define __PAGE_KERNEL_IO_NOCACHE	(__PAGE_KERNEL_NOCACHE | _PAGE_IOMAP)
 +#define __PAGE_KERNEL_IO_UC_MINUS	(__PAGE_KERNEL_UC_MINUS | _PAGE_IOMAP)
 +#define __PAGE_KERNEL_IO_WC		(__PAGE_KERNEL_WC | _PAGE_IOMAP)
 +
 +#define PAGE_KERNEL			__pgprot(__PAGE_KERNEL)
 +#define PAGE_KERNEL_RO			__pgprot(__PAGE_KERNEL_RO)
 +#define PAGE_KERNEL_EXEC		__pgprot(__PAGE_KERNEL_EXEC)
 +#define PAGE_KERNEL_RX			__pgprot(__PAGE_KERNEL_RX)
 +#define PAGE_KERNEL_WC			__pgprot(__PAGE_KERNEL_WC)
 +#define PAGE_KERNEL_NOCACHE		__pgprot(__PAGE_KERNEL_NOCACHE)
 +#define PAGE_KERNEL_UC_MINUS		__pgprot(__PAGE_KERNEL_UC_MINUS)
 +#define PAGE_KERNEL_EXEC_NOCACHE	__pgprot(__PAGE_KERNEL_EXEC_NOCACHE)
 +#define PAGE_KERNEL_LARGE		__pgprot(__PAGE_KERNEL_LARGE)
 +#define PAGE_KERNEL_LARGE_NOCACHE	__pgprot(__PAGE_KERNEL_LARGE_NOCACHE)
 +#define PAGE_KERNEL_LARGE_EXEC		__pgprot(__PAGE_KERNEL_LARGE_EXEC)
 +#define PAGE_KERNEL_VSYSCALL		__pgprot(__PAGE_KERNEL_VSYSCALL)
 +#define PAGE_KERNEL_VVAR		__pgprot(__PAGE_KERNEL_VVAR)
 +#define PAGE_KERNEL_VVAR_NOCACHE	__pgprot(__PAGE_KERNEL_VVAR_NOCACHE)
 +
++<<<<<<< HEAD
 +#define PAGE_KERNEL_IO			__pgprot(__PAGE_KERNEL_IO)
 +#define PAGE_KERNEL_IO_NOCACHE		__pgprot(__PAGE_KERNEL_IO_NOCACHE)
 +#define PAGE_KERNEL_IO_UC_MINUS		__pgprot(__PAGE_KERNEL_IO_UC_MINUS)
 +#define PAGE_KERNEL_IO_WC		__pgprot(__PAGE_KERNEL_IO_WC)
++=======
+ #define _PAGE_ENC	(_AT(pteval_t, sme_me_mask))
+ 
+ #define _PAGE_TABLE	(_PAGE_PRESENT | _PAGE_RW | _PAGE_USER |	\
+ 			 _PAGE_ACCESSED | _PAGE_DIRTY | _PAGE_ENC)
+ #define _KERNPG_TABLE	(_PAGE_PRESENT | _PAGE_RW | _PAGE_ACCESSED |	\
+ 			 _PAGE_DIRTY | _PAGE_ENC)
+ 
+ #define __PAGE_KERNEL_ENC	(__PAGE_KERNEL | _PAGE_ENC)
+ #define __PAGE_KERNEL_ENC_WP	(__PAGE_KERNEL_WP | _PAGE_ENC)
+ 
+ #define __PAGE_KERNEL_NOENC	(__PAGE_KERNEL)
+ #define __PAGE_KERNEL_NOENC_WP	(__PAGE_KERNEL_WP)
+ 
+ #define PAGE_KERNEL		__pgprot(__PAGE_KERNEL | _PAGE_ENC)
+ #define PAGE_KERNEL_NOENC	__pgprot(__PAGE_KERNEL)
+ #define PAGE_KERNEL_RO		__pgprot(__PAGE_KERNEL_RO | _PAGE_ENC)
+ #define PAGE_KERNEL_EXEC	__pgprot(__PAGE_KERNEL_EXEC | _PAGE_ENC)
+ #define PAGE_KERNEL_EXEC_NOENC	__pgprot(__PAGE_KERNEL_EXEC)
+ #define PAGE_KERNEL_RX		__pgprot(__PAGE_KERNEL_RX | _PAGE_ENC)
+ #define PAGE_KERNEL_NOCACHE	__pgprot(__PAGE_KERNEL_NOCACHE | _PAGE_ENC)
+ #define PAGE_KERNEL_LARGE	__pgprot(__PAGE_KERNEL_LARGE | _PAGE_ENC)
+ #define PAGE_KERNEL_LARGE_EXEC	__pgprot(__PAGE_KERNEL_LARGE_EXEC | _PAGE_ENC)
+ #define PAGE_KERNEL_VSYSCALL	__pgprot(__PAGE_KERNEL_VSYSCALL | _PAGE_ENC)
+ #define PAGE_KERNEL_VVAR	__pgprot(__PAGE_KERNEL_VVAR | _PAGE_ENC)
+ 
+ #define PAGE_KERNEL_IO		__pgprot(__PAGE_KERNEL_IO)
+ #define PAGE_KERNEL_IO_NOCACHE	__pgprot(__PAGE_KERNEL_IO_NOCACHE)
+ 
+ #endif	/* __ASSEMBLY__ */
++>>>>>>> 57bd1905b228 (acpi, x86/mm: Remove encryption mask from ACPI page protection type)
  
  /*         xwr */
  #define __P000	PAGE_NONE
* Unmerged path arch/x86/include/asm/acpi.h
* Unmerged path arch/x86/include/asm/pgtable_types.h
