x86/spectre: Add boot time option to select Spectre v2 mitigation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] spectre: Add boot time option to select Spectre v2 mitigation (Josh Poimboeuf) [1535644]
Rebuild_FUZZ: 96.83%
commit-author David Woodhouse <dwmw@amazon.co.uk>
commit da285121560e769cc31797bba6422eea71d473e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/da285121.failed

Add a spectre_v2= option to select the mitigation used for the indirect
branch speculation vulnerability.

Currently, the only option available is retpoline, in its various forms.
This will be expanded to cover the new IBRS/IBPB microcode features.

The RETPOLINE_AMD feature relies on a serializing LFENCE for speculation
control. For AMD hardware, only set RETPOLINE_AMD if LFENCE is a
serializing instruction, which is indicated by the LFENCE_RDTSC feature.

[ tglx: Folded back the LFENCE/AMD fixes and reworked it so IBRS
  	integration becomes simple ]

	Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: gnomes@lxorguk.ukuu.org.uk
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: Josh Poimboeuf <jpoimboe@redhat.com>
	Cc: thomas.lendacky@amd.com
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Jiri Kosina <jikos@kernel.org>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Dave Hansen <dave.hansen@intel.com>
	Cc: Kees Cook <keescook@google.com>
	Cc: Tim Chen <tim.c.chen@linux.intel.com>
	Cc: Greg Kroah-Hartman <gregkh@linux-foundation.org>
	Cc: Paul Turner <pjt@google.com>
Link: https://lkml.kernel.org/r/1515707194-20531-5-git-send-email-dwmw@amazon.co.uk

(cherry picked from commit da285121560e769cc31797bba6422eea71d473e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/kernel-parameters.txt
#	arch/x86/include/asm/nospec-branch.h
#	arch/x86/kernel/cpu/bugs.c
#	arch/x86/kernel/cpu/common.c
diff --cc Documentation/kernel-parameters.txt
index f004a8ce83ef,8122b5f98ea1..000000000000
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@@ -2148,6 -2596,14 +2148,17 @@@ bytes respectively. Such letter suffixe
  
  	nohugeiomap	[KNL,x86] Disable kernel huge I/O mappings.
  
++<<<<<<< HEAD:Documentation/kernel-parameters.txt
++=======
+ 	nosmt		[KNL,S390] Disable symmetric multithreading (SMT).
+ 			Equivalent to smt=1.
+ 
+ 	nospectre_v2	[X86] Disable all mitigations for the Spectre variant 2
+ 			(indirect branch prediction) vulnerability. System may
+ 			allow data leaks with this option, which is equivalent
+ 			to spectre_v2=off.
+ 
++>>>>>>> da285121560e (x86/spectre: Add boot time option to select Spectre v2 mitigation):Documentation/admin-guide/kernel-parameters.txt
  	noxsave		[BUGS=X86] Disables x86 extended register state save
  			and restore using xsave. The kernel will fallback to
  			enabling legacy floating-point and sse state.
@@@ -3135,8 -3913,28 +3146,33 @@@
  	sonypi.*=	[HW] Sony Programmable I/O Control Device driver
  			See Documentation/laptops/sonypi.txt
  
++<<<<<<< HEAD:Documentation/kernel-parameters.txt
 +	specialix=	[HW,SERIAL] Specialix multi-serial port adapter
 +			See Documentation/serial/specialix.txt.
++=======
+ 	spectre_v2=	[X86] Control mitigation of Spectre variant 2
+ 			(indirect branch speculation) vulnerability.
+ 
+ 			on   - unconditionally enable
+ 			off  - unconditionally disable
+ 			auto - kernel detects whether your CPU model is
+ 			       vulnerable
+ 
+ 			Selecting 'on' will, and 'auto' may, choose a
+ 			mitigation method at run time according to the
+ 			CPU, the available microcode, the setting of the
+ 			CONFIG_RETPOLINE configuration option, and the
+ 			compiler with which the kernel was built.
+ 
+ 			Specific mitigations can also be selected manually:
+ 
+ 			retpoline	  - replace indirect branches
+ 			retpoline,generic - google's original retpoline
+ 			retpoline,amd     - AMD-specific minimal thunk
+ 
+ 			Not specifying this option is equivalent to
+ 			spectre_v2=auto.
++>>>>>>> da285121560e (x86/spectre: Add boot time option to select Spectre v2 mitigation):Documentation/admin-guide/kernel-parameters.txt
  
  	spia_io_base=	[HW,MTD]
  	spia_fio_base=
diff --cc arch/x86/kernel/cpu/bugs.c
index 4112be9a4659,e4dc26185aa7..000000000000
--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@@ -9,6 -10,10 +9,13 @@@
   */
  #include <linux/init.h>
  #include <linux/utsname.h>
++<<<<<<< HEAD
++=======
+ #include <linux/cpu.h>
+ 
+ #include <asm/nospec-branch.h>
+ #include <asm/cmdline.h>
++>>>>>>> da285121560e (x86/spectre: Add boot time option to select Spectre v2 mitigation)
  #include <asm/bugs.h>
  #include <asm/processor.h>
  #include <asm/processor-flags.h>
@@@ -16,79 -21,24 +23,93 @@@
  #include <asm/msr.h>
  #include <asm/paravirt.h>
  #include <asm/alternative.h>
 -#include <asm/pgtable.h>
 -#include <asm/set_memory.h>
 +
 +static int __init no_387(char *s)
 +{
 +	boot_cpu_data.hard_math = 0;
 +	write_cr0(X86_CR0_TS | X86_CR0_EM | X86_CR0_MP | read_cr0());
 +	return 1;
 +}
 +
 +__setup("no387", no_387);
 +
 +static double __initdata x = 4195835.0;
 +static double __initdata y = 3145727.0;
 +
 +/*
 + * This used to check for exceptions..
 + * However, it turns out that to support that,
 + * the XMM trap handlers basically had to
 + * be buggy. So let's have a correct XMM trap
 + * handler, and forget about printing out
 + * some status at boot.
 + *
 + * We should really only care about bugs here
 + * anyway. Not features.
 + */
 +static void __init check_fpu(void)
 +{
 +	s32 fdiv_bug;
 +
 +	if (!boot_cpu_data.hard_math) {
 +#ifndef CONFIG_MATH_EMULATION
 +		pr_emerg("No coprocessor found and no math emulation present\n");
 +		pr_emerg("Giving up\n");
 +		for (;;) ;
 +#endif
 +		return;
 +	}
 +
 +	kernel_fpu_begin();
 +
 +	/*
 +	 * trap_init() enabled FXSR and company _before_ testing for FP
 +	 * problems here.
 +	 *
 +	 * Test for the divl bug: http://en.wikipedia.org/wiki/Fdiv_bug
 +	 */
 +	__asm__("fninit\n\t"
 +		"fldl %1\n\t"
 +		"fdivl %2\n\t"
 +		"fmull %2\n\t"
 +		"fldl %1\n\t"
 +		"fsubp %%st,%%st(1)\n\t"
 +		"fistpl %0\n\t"
 +		"fwait\n\t"
 +		"fninit"
 +		: "=m" (*&fdiv_bug)
 +		: "m" (*&x), "m" (*&y));
 +
 +	kernel_fpu_end();
 +
 +	if (fdiv_bug) {
 +		set_cpu_bug(&boot_cpu_data, X86_BUG_FDIV);
 +		pr_warn("Hmm, FPU with FDIV bug\n");
 +	}
 +}
  
+ static void __init spectre_v2_select_mitigation(void);
+ 
  void __init check_bugs(void)
  {
  	identify_boot_cpu();
 +#ifndef CONFIG_SMP
 +	pr_info("CPU: ");
 +	print_cpu_info(&boot_cpu_data);
 +#endif
  
++<<<<<<< HEAD
++=======
+ 	if (!IS_ENABLED(CONFIG_SMP)) {
+ 		pr_info("CPU: ");
+ 		print_cpu_info(&boot_cpu_data);
+ 	}
+ 
+ 	/* Select the proper spectre mitigation before patching alternatives */
+ 	spectre_v2_select_mitigation();
+ 
+ #ifdef CONFIG_X86_32
++>>>>>>> da285121560e (x86/spectre: Add boot time option to select Spectre v2 mitigation)
  	/*
  	 * Check whether we are able to run this kernel safely on SMP.
  	 *
@@@ -103,9 -53,195 +124,188 @@@
  		'0' + (boot_cpu_data.x86 > 6 ? 6 : boot_cpu_data.x86);
  	alternative_instructions();
  
 -	fpu__init_check_bugs();
 -#else /* CONFIG_X86_64 */
 -	alternative_instructions();
 -
  	/*
 -	 * Make sure the first 2MB area is not mapped by huge pages
 -	 * There are typically fixed size MTRRs in there and overlapping
 -	 * MTRRs into large pages causes slow downs.
 -	 *
 -	 * Right now we don't do that with gbpages because there seems
 -	 * very little benefit for that case.
 +	 * kernel_fpu_begin/end() in check_fpu() relies on the patched
 +	 * alternative instructions.
  	 */
 -	if (!direct_gbpages)
 -		set_memory_4k((unsigned long)__va(0), 1);
 -#endif
 +	check_fpu();
  }
++<<<<<<< HEAD
++=======
+ 
+ /* The kernel command line selection */
+ enum spectre_v2_mitigation_cmd {
+ 	SPECTRE_V2_CMD_NONE,
+ 	SPECTRE_V2_CMD_AUTO,
+ 	SPECTRE_V2_CMD_FORCE,
+ 	SPECTRE_V2_CMD_RETPOLINE,
+ 	SPECTRE_V2_CMD_RETPOLINE_GENERIC,
+ 	SPECTRE_V2_CMD_RETPOLINE_AMD,
+ };
+ 
+ static const char *spectre_v2_strings[] = {
+ 	[SPECTRE_V2_NONE]			= "Vulnerable",
+ 	[SPECTRE_V2_RETPOLINE_MINIMAL]		= "Vulnerable: Minimal generic ASM retpoline",
+ 	[SPECTRE_V2_RETPOLINE_MINIMAL_AMD]	= "Vulnerable: Minimal AMD ASM retpoline",
+ 	[SPECTRE_V2_RETPOLINE_GENERIC]		= "Mitigation: Full generic retpoline",
+ 	[SPECTRE_V2_RETPOLINE_AMD]		= "Mitigation: Full AMD retpoline",
+ };
+ 
+ #undef pr_fmt
+ #define pr_fmt(fmt)     "Spectre V2 mitigation: " fmt
+ 
+ static enum spectre_v2_mitigation spectre_v2_enabled = SPECTRE_V2_NONE;
+ 
+ static void __init spec2_print_if_insecure(const char *reason)
+ {
+ 	if (boot_cpu_has_bug(X86_BUG_SPECTRE_V2))
+ 		pr_info("%s\n", reason);
+ }
+ 
+ static void __init spec2_print_if_secure(const char *reason)
+ {
+ 	if (!boot_cpu_has_bug(X86_BUG_SPECTRE_V2))
+ 		pr_info("%s\n", reason);
+ }
+ 
+ static inline bool retp_compiler(void)
+ {
+ 	return __is_defined(RETPOLINE);
+ }
+ 
+ static inline bool match_option(const char *arg, int arglen, const char *opt)
+ {
+ 	int len = strlen(opt);
+ 
+ 	return len == arglen && !strncmp(arg, opt, len);
+ }
+ 
+ static enum spectre_v2_mitigation_cmd __init spectre_v2_parse_cmdline(void)
+ {
+ 	char arg[20];
+ 	int ret;
+ 
+ 	ret = cmdline_find_option(boot_command_line, "spectre_v2", arg,
+ 				  sizeof(arg));
+ 	if (ret > 0)  {
+ 		if (match_option(arg, ret, "off")) {
+ 			goto disable;
+ 		} else if (match_option(arg, ret, "on")) {
+ 			spec2_print_if_secure("force enabled on command line.");
+ 			return SPECTRE_V2_CMD_FORCE;
+ 		} else if (match_option(arg, ret, "retpoline")) {
+ 			spec2_print_if_insecure("retpoline selected on command line.");
+ 			return SPECTRE_V2_CMD_RETPOLINE;
+ 		} else if (match_option(arg, ret, "retpoline,amd")) {
+ 			if (boot_cpu_data.x86_vendor != X86_VENDOR_AMD) {
+ 				pr_err("retpoline,amd selected but CPU is not AMD. Switching to AUTO select\n");
+ 				return SPECTRE_V2_CMD_AUTO;
+ 			}
+ 			spec2_print_if_insecure("AMD retpoline selected on command line.");
+ 			return SPECTRE_V2_CMD_RETPOLINE_AMD;
+ 		} else if (match_option(arg, ret, "retpoline,generic")) {
+ 			spec2_print_if_insecure("generic retpoline selected on command line.");
+ 			return SPECTRE_V2_CMD_RETPOLINE_GENERIC;
+ 		} else if (match_option(arg, ret, "auto")) {
+ 			return SPECTRE_V2_CMD_AUTO;
+ 		}
+ 	}
+ 
+ 	if (!cmdline_find_option_bool(boot_command_line, "nospectre_v2"))
+ 		return SPECTRE_V2_CMD_AUTO;
+ disable:
+ 	spec2_print_if_insecure("disabled on command line.");
+ 	return SPECTRE_V2_CMD_NONE;
+ }
+ 
+ static void __init spectre_v2_select_mitigation(void)
+ {
+ 	enum spectre_v2_mitigation_cmd cmd = spectre_v2_parse_cmdline();
+ 	enum spectre_v2_mitigation mode = SPECTRE_V2_NONE;
+ 
+ 	/*
+ 	 * If the CPU is not affected and the command line mode is NONE or AUTO
+ 	 * then nothing to do.
+ 	 */
+ 	if (!boot_cpu_has_bug(X86_BUG_SPECTRE_V2) &&
+ 	    (cmd == SPECTRE_V2_CMD_NONE || cmd == SPECTRE_V2_CMD_AUTO))
+ 		return;
+ 
+ 	switch (cmd) {
+ 	case SPECTRE_V2_CMD_NONE:
+ 		return;
+ 
+ 	case SPECTRE_V2_CMD_FORCE:
+ 		/* FALLTRHU */
+ 	case SPECTRE_V2_CMD_AUTO:
+ 		goto retpoline_auto;
+ 
+ 	case SPECTRE_V2_CMD_RETPOLINE_AMD:
+ 		if (IS_ENABLED(CONFIG_RETPOLINE))
+ 			goto retpoline_amd;
+ 		break;
+ 	case SPECTRE_V2_CMD_RETPOLINE_GENERIC:
+ 		if (IS_ENABLED(CONFIG_RETPOLINE))
+ 			goto retpoline_generic;
+ 		break;
+ 	case SPECTRE_V2_CMD_RETPOLINE:
+ 		if (IS_ENABLED(CONFIG_RETPOLINE))
+ 			goto retpoline_auto;
+ 		break;
+ 	}
+ 	pr_err("kernel not compiled with retpoline; no mitigation available!");
+ 	return;
+ 
+ retpoline_auto:
+ 	if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD) {
+ 	retpoline_amd:
+ 		if (!boot_cpu_has(X86_FEATURE_LFENCE_RDTSC)) {
+ 			pr_err("LFENCE not serializing. Switching to generic retpoline\n");
+ 			goto retpoline_generic;
+ 		}
+ 		mode = retp_compiler() ? SPECTRE_V2_RETPOLINE_AMD :
+ 					 SPECTRE_V2_RETPOLINE_MINIMAL_AMD;
+ 		setup_force_cpu_cap(X86_FEATURE_RETPOLINE_AMD);
+ 		setup_force_cpu_cap(X86_FEATURE_RETPOLINE);
+ 	} else {
+ 	retpoline_generic:
+ 		mode = retp_compiler() ? SPECTRE_V2_RETPOLINE_GENERIC :
+ 					 SPECTRE_V2_RETPOLINE_MINIMAL;
+ 		setup_force_cpu_cap(X86_FEATURE_RETPOLINE);
+ 	}
+ 
+ 	spectre_v2_enabled = mode;
+ 	pr_info("%s\n", spectre_v2_strings[mode]);
+ }
+ 
+ #undef pr_fmt
+ 
+ #ifdef CONFIG_SYSFS
+ ssize_t cpu_show_meltdown(struct device *dev,
+ 			  struct device_attribute *attr, char *buf)
+ {
+ 	if (!boot_cpu_has_bug(X86_BUG_CPU_MELTDOWN))
+ 		return sprintf(buf, "Not affected\n");
+ 	if (boot_cpu_has(X86_FEATURE_PTI))
+ 		return sprintf(buf, "Mitigation: PTI\n");
+ 	return sprintf(buf, "Vulnerable\n");
+ }
+ 
+ ssize_t cpu_show_spectre_v1(struct device *dev,
+ 			    struct device_attribute *attr, char *buf)
+ {
+ 	if (!boot_cpu_has_bug(X86_BUG_SPECTRE_V1))
+ 		return sprintf(buf, "Not affected\n");
+ 	return sprintf(buf, "Vulnerable\n");
+ }
+ 
+ ssize_t cpu_show_spectre_v2(struct device *dev,
+ 			    struct device_attribute *attr, char *buf)
+ {
+ 	if (!boot_cpu_has_bug(X86_BUG_SPECTRE_V2))
+ 		return sprintf(buf, "Not affected\n");
+ 
+ 	return sprintf(buf, "%s\n", spectre_v2_strings[spectre_v2_enabled]);
+ }
+ #endif
++>>>>>>> da285121560e (x86/spectre: Add boot time option to select Spectre v2 mitigation)
diff --cc arch/x86/kernel/cpu/common.c
index 3eec1147ce1e,372ba3fb400f..000000000000
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@@ -808,29 -877,43 +808,33 @@@ static void __init early_identify_cpu(s
  	memset(&c->x86_capability, 0, sizeof c->x86_capability);
  	c->extended_cpuid_level = 0;
  
 -	/* cyrix could have cpuid enabled via c_identify()*/
 -	if (have_cpuid_p()) {
 -		cpu_detect(c);
 -		get_cpu_vendor(c);
 -		get_cpu_cap(c);
 -		setup_force_cpu_cap(X86_FEATURE_CPUID);
 +	if (!have_cpuid_p())
 +		identify_cpu_without_cpuid(c);
  
 -		if (this_cpu->c_early_init)
 -			this_cpu->c_early_init(c);
 +	/* cyrix could have cpuid enabled via c_identify()*/
 +	if (!have_cpuid_p())
 +		return;
  
 -		c->cpu_index = 0;
 -		filter_cpuid_features(c, false);
 +	cpu_detect(c);
  
 -		if (this_cpu->c_bsp_init)
 -			this_cpu->c_bsp_init(c);
 -	} else {
 -		identify_cpu_without_cpuid(c);
 -		setup_clear_cpu_cap(X86_FEATURE_CPUID);
 -	}
 +	get_cpu_vendor(c);
  
 -	setup_force_cpu_cap(X86_FEATURE_ALWAYS);
++<<<<<<< HEAD
 +	get_cpu_cap(c);
  
 -	if (c->x86_vendor != X86_VENDOR_AMD)
 -		setup_force_cpu_bug(X86_BUG_CPU_MELTDOWN);
 +	get_model_name(c); /* RHEL7: get default name for unsupported check */
++=======
++	fpu__init_system(c);
++>>>>>>> da285121560e (x86/spectre: Add boot time option to select Spectre v2 mitigation)
  
 -	setup_force_cpu_bug(X86_BUG_SPECTRE_V1);
 -	setup_force_cpu_bug(X86_BUG_SPECTRE_V2);
 +	if (this_cpu->c_early_init)
 +		this_cpu->c_early_init(c);
  
 -	fpu__init_system(c);
 +	c->cpu_index = 0;
 +	filter_cpuid_features(c, false);
  
 -#ifdef CONFIG_X86_32
 -	/*
 -	 * Regardless of whether PCID is enumerated, the SDM says
 -	 * that it can't be enabled in 32-bit mode.
 -	 */
 -	setup_clear_cpu_cap(X86_FEATURE_PCID);
 -#endif
 +	if (this_cpu->c_bsp_init)
 +		this_cpu->c_bsp_init(c);
  }
  
  void __init early_cpu_init(void)
* Unmerged path arch/x86/include/asm/nospec-branch.h
* Unmerged path Documentation/kernel-parameters.txt
* Unmerged path arch/x86/include/asm/nospec-branch.h
* Unmerged path arch/x86/kernel/cpu/bugs.c
* Unmerged path arch/x86/kernel/cpu/common.c
