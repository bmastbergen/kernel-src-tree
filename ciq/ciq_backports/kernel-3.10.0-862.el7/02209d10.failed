ovl: factor out ovl_copy_up_inode() helper

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 02209d10709c18d552c2494df74117db09a18e05
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/02209d10.failed

Factor out helper for copying lower inode data and metadata to temp
upper inode, that is common to copy up using O_TMPFILE and workdir.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 02209d10709c18d552c2494df74117db09a18e05)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/copy_up.c
diff --cc fs/overlayfs/copy_up.c
index 6e96b99a973d,81b9a44916a0..000000000000
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@@ -305,49 -392,91 +305,135 @@@ static int ovl_copy_up_locked(struct de
  		put_cred(new_creds);
  	}
  
++<<<<<<< HEAD
++=======
+ 	return err;
+ 
+ temp_err:
+ 	err = PTR_ERR(temp);
+ 	goto out;
+ }
+ 
+ static int ovl_copy_up_inode(struct dentry *dentry, struct dentry *temp,
+ 			     struct path *lowerpath, struct kstat *stat)
+ {
+ 	int err;
+ 
+ 	if (S_ISREG(stat->mode)) {
+ 		struct path upperpath;
+ 
+ 		ovl_path_upper(dentry, &upperpath);
+ 		BUG_ON(upperpath.dentry != NULL);
+ 		upperpath.dentry = temp;
+ 
+ 		err = ovl_copy_up_data(lowerpath, &upperpath, stat->size);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	err = ovl_copy_xattr(lowerpath->dentry, temp);
+ 	if (err)
+ 		return err;
+ 
+ 	inode_lock(temp->d_inode);
+ 	err = ovl_set_attr(temp, stat);
+ 	inode_unlock(temp->d_inode);
+ 	if (err)
+ 		return err;
+ 
+ 	/*
+ 	 * Store identifier of lower inode in upper inode xattr to
+ 	 * allow lookup of the copy up origin inode.
+ 	 *
+ 	 * Don't set origin when we are breaking the association with a lower
+ 	 * hard link.
+ 	 */
+ 	if (S_ISDIR(stat->mode) || stat->nlink == 1) {
+ 		err = ovl_set_origin(dentry, lowerpath->dentry, temp);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,
+ 			      struct dentry *dentry, struct path *lowerpath,
+ 			      struct kstat *stat, const char *link,
+ 			      struct kstat *pstat, bool tmpfile)
+ {
+ 	struct inode *wdir = workdir->d_inode;
+ 	struct inode *udir = upperdir->d_inode;
+ 	struct dentry *newdentry = NULL;
+ 	struct dentry *temp = NULL;
+ 	int err;
+ 
+ 	err = ovl_get_tmpfile(workdir, upperdir, dentry, stat, link, tmpfile,
+ 			      &temp);
++>>>>>>> 02209d10709c (ovl: factor out ovl_copy_up_inode() helper)
  	if (err)
 -		goto out;
 +		goto out2;
 +
++<<<<<<< HEAD
 +	if (S_ISREG(stat->mode)) {
 +		struct path upperpath;
 +
 +		ovl_path_upper(dentry, &upperpath);
 +		BUG_ON(upperpath.dentry != NULL);
 +		upperpath.dentry = newdentry;
 +
 +		err = ovl_copy_up_data(lowerpath, &upperpath, stat->size);
 +		if (err)
 +			goto out_cleanup;
 +	}
 +
 +	err = ovl_copy_xattr(lowerpath->dentry, newdentry);
 +	if (err)
 +		goto out_cleanup;
 +
 +	mutex_lock(&newdentry->d_inode->i_mutex);
 +	err = ovl_set_attr(newdentry, stat);
 +	mutex_unlock(&newdentry->d_inode->i_mutex);
 +	if (err)
 +		goto out_cleanup;
  
 +	err = ovl_do_rename(wdir, newdentry, udir, upper, 0);
 +	if (err)
 +		goto out_cleanup;
 +
 +	ovl_dentry_update(dentry, newdentry);
 +	ovl_inode_update(d_inode(dentry), d_inode(newdentry));
 +	newdentry = NULL;
 +
 +	/*
 +	 * Non-directores become opaque when copied up.
 +	 */
 +	if (!S_ISDIR(stat->mode))
 +		ovl_dentry_set_opaque(dentry, true);
 +out2:
 +	dput(upper);
 +out1:
 +	dput(newdentry);
++=======
+ 	err = ovl_copy_up_inode(dentry, temp, lowerpath, stat);
+ 	if (err)
+ 		goto out_cleanup;
+ 
+ 	if (tmpfile) {
+ 		inode_lock_nested(udir, I_MUTEX_PARENT);
+ 		err = ovl_install_temp(workdir, upperdir, dentry, temp, pstat,
+ 				       tmpfile, &newdentry);
+ 		inode_unlock(udir);
+ 	} else {
+ 		err = ovl_install_temp(workdir, upperdir, dentry, temp, pstat,
+ 				       tmpfile, &newdentry);
+ 	}
+ 	if (err)
+ 		goto out_cleanup;
+ 
+ 	ovl_inode_update(d_inode(dentry), newdentry);
++>>>>>>> 02209d10709c (ovl: factor out ovl_copy_up_inode() helper)
  out:
 -	dput(temp);
  	return err;
  
  out_cleanup:
* Unmerged path fs/overlayfs/copy_up.c
