scsi: qla2xxx: Add FC-NVMe port discovery and PRLI handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Add FC-NVMe port discovery and PRLI handling (Himanshu Madhani) [1316281]
Rebuild_FUZZ: 94.64%
commit-author Duane Grigsby <duane.grigsby@cavium.com>
commit a5d42f4cffa58d0e80d92dd11c810a22f14d41b3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a5d42f4c.failed

Added logic to change the login process into an optional PRIL step for
FC-NVMe ports as a separate operation, such that we can change type to
0x28 (NVMe).

Currently, the driver performs the PLOGI/PRLI together as one operation,
but if the discovered port is an NVMe port then we first issue the PLOGI
and then we issue the PRLI. Also, the fabric discovery logic was changed
to mark each discovered FC NVMe port, so that we can register them with
the FC-NVMe transport later.

	Signed-off-by: Darren Trapp <darren.trapp@cavium.com>
	Signed-off-by: Duane Grigsby <duane.grigsby@cavium.com>
	Signed-off-by: Anil Gurumurthy <anil.gurumurhty@cavium.com>
	Signed-off-by: Giridhar Malavali <giridhar.malavali@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit a5d42f4cffa58d0e80d92dd11c810a22f14d41b3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_dbg.c
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_gbl.h
#	drivers/scsi/qla2xxx/qla_init.c
#	drivers/scsi/qla2xxx/qla_mbx.c
#	drivers/scsi/qla2xxx/qla_os.c
#	drivers/scsi/qla2xxx/qla_target.c
diff --cc drivers/scsi/qla2xxx/qla_dbg.c
index d4184772f017,c8057c798125..000000000000
--- a/drivers/scsi/qla2xxx/qla_dbg.c
+++ b/drivers/scsi/qla2xxx/qla_dbg.c
@@@ -12,16 -12,14 +12,27 @@@
   * |             Level            |   Last Value Used  |     Holes	|
   * ----------------------------------------------------------------------
   * | Module Init and Probe        |       0x0193       | 0x0146         |
++<<<<<<< HEAD
 + * | Mailbox commands             |       0x1199       | 0x111a-0x111b  |
 + * |                              |                    | 0x1155-0x1158  |
 + * |                              |                    | 0x1018-0x1019  |
 + * |                              |                    | 0x1115-0x1116  |
 + * |                              |                    | 0x10ca,0x1193  |
 + * | Device Discovery             |       0x2095       | 0x2016         |
 + * |                              |                    | 0x2020-0x2022, |
 + * |                              |                    | 0x2011-0x2012, |
 + * |                              |                    | 0x2099-0x20a4  |
 + * | Queue Command and IO tracing |       0x3075       | 0x300b         |
++=======
+  * |                              |                    | 0x015b-0x0160	|
+  * |                              |                    | 0x016e		|
+  * | Mailbox commands             |       0x1199       | 0x1193		|
+  * | Device Discovery             |       0x2131       | 0x210e-0x2116  |
+  * |				  | 		       | 0x211a         |
+  * |                              |                    | 0x211c-0x2128  |
+  * |                              |                    | 0x212a-0x2130  |
+  * | Queue Command and IO tracing |       0x3074       | 0x300b         |
++>>>>>>> a5d42f4cffa5 (scsi: qla2xxx: Add FC-NVMe port discovery and PRLI handling)
   * |                              |                    | 0x3027-0x3028  |
   * |                              |                    | 0x303d-0x3041  |
   * |                              |                    | 0x302d,0x3033  |
@@@ -62,17 -60,13 +73,21 @@@
   * |                              |                    | 0xb13c-0xb140  |
   * |                              |                    | 0xb149		|
   * | MultiQ                       |       0xc010       |		|
++<<<<<<< HEAD
 + * | Misc                         |       0xd300       | 0xd016-0xd017	|
 + * |                              |                    | 0xd021,0xd024	|
 + * |                              |                    | 0xd025,0xd029	|
 + * |                              |                    | 0xd02a,0xd02e	|
 + * |                              |                    | 0xd031-0xd0ff	|
++=======
+  * | Misc                         |       0xd302       | 0xd031-0xd0ff	|
++>>>>>>> a5d42f4cffa5 (scsi: qla2xxx: Add FC-NVMe port discovery and PRLI handling)
   * |                              |                    | 0xd101-0xd1fe	|
 - * |                              |                    | 0xd214-0xd2fe	|
 - * | Target Mode		  |	  0xe081       |		|
 - * | Target Mode Management	  |	  0xf09b       | 0xf002		|
 + * |                              |                    | 0xd213-0xd2fe	|
 + * | Target Mode		  |	  0xe070       | 0xe021		|
 + * | Target Mode Management	  |	  0xf072       | 0xf002-0xf003	|
   * |                              |                    | 0xf046-0xf049  |
 - * | Target Mode Task Management  |	  0x1000d      |		|
 + * | Target Mode Task Management  |	  0x1000b      |		|
   * ----------------------------------------------------------------------
   */
  
diff --cc drivers/scsi/qla2xxx/qla_def.h
index 3f28536dc812,6f8df9cea8ff..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -319,9 -343,20 +319,10 @@@ struct srb_iocb 
  #define SRB_LOGIN_RETRIED	BIT_0
  #define SRB_LOGIN_COND_PLOGI	BIT_1
  #define SRB_LOGIN_SKIP_PRLI	BIT_2
+ #define SRB_LOGIN_NVME_PRLI	BIT_3
  			uint16_t data[2];
 -			u32 iop[2];
  		} logio;
  		struct {
 -#define ELS_DCMD_TIMEOUT 20
 -#define ELS_DCMD_LOGO 0x5
 -			uint32_t flags;
 -			uint32_t els_cmd;
 -			struct completion comp;
 -			struct els_logo_payload *els_logo_pyld;
 -			dma_addr_t els_logo_pyld_dma;
 -		} els_logo;
 -		struct {
  			/*
  			 * Values for flags field below are as
  			 * defined in tsk_mgmt_entry struct
@@@ -382,11 -431,29 +383,21 @@@
  #define SRB_FXIOCB_DCMD	10
  #define SRB_FXIOCB_BCMD	11
  #define SRB_ABT_CMD	12
++<<<<<<< HEAD
++=======
+ #define SRB_ELS_DCMD	13
+ #define SRB_MB_IOCB	14
+ #define SRB_CT_PTHRU_CMD 15
+ #define SRB_NACK_PLOGI	16
+ #define SRB_NACK_PRLI	17
+ #define SRB_NACK_LOGO	18
+ #define SRB_PRLI_CMD	21
++>>>>>>> a5d42f4cffa5 (scsi: qla2xxx: Add FC-NVMe port discovery and PRLI handling)
  
 -enum {
 -	TYPE_SRB,
 -	TYPE_TGT_CMD,
 -};
  
  typedef struct srb {
 -	/*
 -	 * Do not move cmd_type field, it needs to
 -	 * line up with qla_tgt_cmd->cmd_type
 -	 */
 -	uint8_t cmd_type;
 -	uint8_t pad[3];
  	atomic_t ref_count;
  	struct fc_port *fcport;
 -	struct scsi_qla_host *vha;
  	uint32_t handle;
  	uint16_t flags;
  	uint16_t type;
@@@ -2011,9 -2184,80 +2024,83 @@@ typedef struct 
  	FCT_SWITCH,
  	FCT_BROADCAST,
  	FCT_INITIATOR,
- 	FCT_TARGET
+ 	FCT_TARGET,
+ 	FCT_NVME
  } fc_port_type_t;
  
++<<<<<<< HEAD
++=======
+ enum qla_sess_deletion {
+ 	QLA_SESS_DELETION_NONE		= 0,
+ 	QLA_SESS_DELETION_IN_PROGRESS,
+ 	QLA_SESS_DELETED,
+ };
+ 
+ enum qlt_plogi_link_t {
+ 	QLT_PLOGI_LINK_SAME_WWN,
+ 	QLT_PLOGI_LINK_CONFLICT,
+ 	QLT_PLOGI_LINK_MAX
+ };
+ 
+ struct qlt_plogi_ack_t {
+ 	struct list_head	list;
+ 	struct imm_ntfy_from_isp iocb;
+ 	port_id_t	id;
+ 	int		ref_count;
+ 	void		*fcport;
+ };
+ 
+ struct ct_sns_desc {
+ 	struct ct_sns_pkt	*ct_sns;
+ 	dma_addr_t		ct_sns_dma;
+ };
+ 
+ enum discovery_state {
+ 	DSC_DELETED,
+ 	DSC_GID_PN,
+ 	DSC_GNL,
+ 	DSC_LOGIN_PEND,
+ 	DSC_LOGIN_FAILED,
+ 	DSC_GPDB,
+ 	DSC_GPSC,
+ 	DSC_UPD_FCPORT,
+ 	DSC_LOGIN_COMPLETE,
+ 	DSC_DELETE_PEND,
+ };
+ 
+ enum login_state {	/* FW control Target side */
+ 	DSC_LS_LLIOCB_SENT = 2,
+ 	DSC_LS_PLOGI_PEND,
+ 	DSC_LS_PLOGI_COMP,
+ 	DSC_LS_PRLI_PEND,
+ 	DSC_LS_PRLI_COMP,
+ 	DSC_LS_PORT_UNAVAIL,
+ 	DSC_LS_PRLO_PEND = 9,
+ 	DSC_LS_LOGO_PEND,
+ };
+ 
+ enum fcport_mgt_event {
+ 	FCME_RELOGIN = 1,
+ 	FCME_RSCN,
+ 	FCME_GIDPN_DONE,
+ 	FCME_PLOGI_DONE,	/* Initiator side sent LLIOCB */
+ 	FCME_PRLI_DONE,
+ 	FCME_GNL_DONE,
+ 	FCME_GPSC_DONE,
+ 	FCME_GPDB_DONE,
+ 	FCME_GPNID_DONE,
+ 	FCME_GFFID_DONE,
+ 	FCME_DELETE_DONE,
+ };
+ 
+ enum rscn_addr_format {
+ 	RSCN_PORT_ADDR,
+ 	RSCN_AREA_ADDR,
+ 	RSCN_DOM_ADDR,
+ 	RSCN_FAB_ADDR,
+ };
+ 
++>>>>>>> a5d42f4cffa5 (scsi: qla2xxx: Add FC-NVMe port discovery and PRLI handling)
  /*
   * Fibre channel port structure.
   */
@@@ -2027,6 -2271,39 +2114,42 @@@ typedef struct fc_port 
  	uint16_t loop_id;
  	uint16_t old_loop_id;
  
++<<<<<<< HEAD
++=======
+ 	unsigned int conf_compl_supported:1;
+ 	unsigned int deleted:2;
+ 	unsigned int local:1;
+ 	unsigned int logout_on_delete:1;
+ 	unsigned int logo_ack_needed:1;
+ 	unsigned int keep_nport_handle:1;
+ 	unsigned int send_els_logo:1;
+ 	unsigned int login_pause:1;
+ 	unsigned int login_succ:1;
+ 
+ 	struct work_struct nvme_del_work;
+ 	atomic_t nvme_ref_count;
+ 	uint32_t nvme_prli_service_param;
+ #define NVME_PRLI_SP_CONF       BIT_7
+ #define NVME_PRLI_SP_INITIATOR  BIT_5
+ #define NVME_PRLI_SP_TARGET     BIT_4
+ #define NVME_PRLI_SP_DISCOVERY  BIT_3
+ 	uint8_t nvme_flag;
+ #define NVME_FLAG_REGISTERED 4
+ 
+ 	struct fc_port *conflict;
+ 	unsigned char logout_completed;
+ 	int generation;
+ 
+ 	struct se_session *se_sess;
+ 	struct kref sess_kref;
+ 	struct qla_tgt *tgt;
+ 	unsigned long expires;
+ 	struct list_head del_list_entry;
+ 	struct work_struct free_work;
+ 
+ 	struct qlt_plogi_ack_t *plogi_link[QLT_PLOGI_LINK_MAX];
+ 
++>>>>>>> a5d42f4cffa5 (scsi: qla2xxx: Add FC-NVMe port discovery and PRLI handling)
  	uint16_t tgt_id;
  	uint16_t old_tgt_id;
  
@@@ -2053,9 -2331,36 +2177,11 @@@
  
  	uint16_t port_id;
  
+ 	struct nvme_fc_remote_port *nvme_remote_port;
+ 
  	unsigned long retry_delay_timestamp;
 -	struct qla_tgt_sess *tgt_session;
 -	struct ct_sns_desc ct_desc;
 -	enum discovery_state disc_state;
 -	enum login_state fw_login_state;
 -	unsigned long plogi_nack_done_deadline;
 -
 -	u32 login_gen, last_login_gen;
 -	u32 rscn_gen, last_rscn_gen;
 -	u32 chip_reset;
 -	struct list_head gnl_entry;
 -	struct work_struct del_work;
 -	u8 iocb[IOCB_SIZE];
  } fc_port_t;
  
 -#define QLA_FCPORT_SCAN		1
 -#define QLA_FCPORT_FOUND	2
 -
 -struct event_arg {
 -	enum fcport_mgt_event	event;
 -	fc_port_t		*fcport;
 -	srb_t			*sp;
 -	port_id_t		id;
 -	u16			data[2], rc;
 -	u8			port_name[WWN_SIZE];
 -	u32			iop[2];
 -};
 -
  #include "qla_mr.h"
  
  /*
@@@ -2456,8 -2765,12 +2582,8 @@@ struct ct_sns_req 
  
  		struct {
  			uint8_t reserved;
- 			uint8_t port_name[3];
+ 			uint8_t port_id[3];
  		} gff_id;
 -
 -		struct {
 -			uint8_t port_name[8];
 -		} gid_pn;
  	} req;
  };
  
@@@ -2751,6 -3067,16 +2877,19 @@@ enum qla_work_type 
  	QLA_EVT_ASYNC_ADISC_DONE,
  	QLA_EVT_UEVENT,
  	QLA_EVT_AENFX,
++<<<<<<< HEAD
++=======
+ 	QLA_EVT_GIDPN,
+ 	QLA_EVT_GPNID,
+ 	QLA_EVT_GPNID_DONE,
+ 	QLA_EVT_NEW_SESS,
+ 	QLA_EVT_GPDB,
+ 	QLA_EVT_PRLI,
+ 	QLA_EVT_GPSC,
+ 	QLA_EVT_UPD_FCPORT,
+ 	QLA_EVT_GNL,
+ 	QLA_EVT_NACK,
++>>>>>>> a5d42f4cffa5 (scsi: qla2xxx: Add FC-NVMe port discovery and PRLI handling)
  };
  
  
@@@ -3575,6 -4026,9 +3714,12 @@@ typedef struct scsi_qla_host 
  		uint32_t	fw_tgt_reported:1;
  		uint32_t	bbcr_enable:1;
  		uint32_t	qpairs_available:1;
++<<<<<<< HEAD
++=======
+ 		uint32_t	qpairs_req_created:1;
+ 		uint32_t	qpairs_rsp_created:1;
+ 		uint32_t	nvme_enabled:1;
++>>>>>>> a5d42f4cffa5 (scsi: qla2xxx: Add FC-NVMe port discovery and PRLI handling)
  	} flags;
  
  	atomic_t	loop_state;
diff --cc drivers/scsi/qla2xxx/qla_gbl.h
index c4f068539cd6,6fbee11c1a18..000000000000
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@@ -89,8 -95,16 +89,19 @@@ qla2x00_alloc_outstanding_cmds(struct q
  extern int qla2x00_init_rings(scsi_qla_host_t *);
  extern uint8_t qla27xx_find_valid_image(struct scsi_qla_host *);
  extern struct qla_qpair *qla2xxx_create_qpair(struct scsi_qla_host *,
 -	int, int, bool);
 +	cpumask_var_t, int, int);
  extern int qla2xxx_delete_qpair(struct scsi_qla_host *, struct qla_qpair *);
++<<<<<<< HEAD
++=======
+ void qla2x00_fcport_event_handler(scsi_qla_host_t *, struct event_arg *);
+ int qla24xx_async_gpdb(struct scsi_qla_host *, fc_port_t *, u8);
+ int qla24xx_async_prli(struct scsi_qla_host *, fc_port_t *);
+ int qla24xx_async_notify_ack(scsi_qla_host_t *, fc_port_t *,
+ 	struct imm_ntfy_from_isp *, int);
+ int qla24xx_post_newsess_work(struct scsi_qla_host *, port_id_t *, u8 *,
+     void *);
+ int qla24xx_fcport_handle_login(struct scsi_qla_host *, fc_port_t *);
++>>>>>>> a5d42f4cffa5 (scsi: qla2xxx: Add FC-NVMe port discovery and PRLI handling)
  
  /*
   * Global Data in qla_os.c source file.
diff --cc drivers/scsi/qla2xxx/qla_init.c
index 998b579c233c,ed898b7a32c8..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -39,6 -36,12 +39,15 @@@ static int qla2x00_restart_isp(scsi_qla
  static struct qla_chip_state_84xx *qla84xx_get_chip(struct scsi_qla_host *);
  static int qla84xx_init_chip(scsi_qla_host_t *);
  static int qla25xx_init_queues(struct qla_hw_data *);
++<<<<<<< HEAD
++=======
+ static int qla24xx_post_gpdb_work(struct scsi_qla_host *, fc_port_t *, u8);
+ static int qla24xx_post_prli_work(struct scsi_qla_host*, fc_port_t *);
+ static void qla24xx_handle_plogi_done_event(struct scsi_qla_host *,
+     struct event_arg *);
+ static void qla24xx_handle_prli_done_event(struct scsi_qla_host *,
+     struct event_arg *);
++>>>>>>> a5d42f4cffa5 (scsi: qla2xxx: Add FC-NVMe port discovery and PRLI handling)
  
  /* SRB Extensions ---------------------------------------------------------- */
  
@@@ -274,6 -325,934 +287,936 @@@ done
  	return rval;
  }
  
++<<<<<<< HEAD
++=======
+ static void qla24xx_handle_gnl_done_event(scsi_qla_host_t *vha,
+ 	struct event_arg *ea)
+ {
+ 	fc_port_t *fcport, *conflict_fcport;
+ 	struct get_name_list_extended *e;
+ 	u16 i, n, found = 0, loop_id;
+ 	port_id_t id;
+ 	u64 wwn;
+ 	u8 opt = 0, current_login_state;
+ 
+ 	fcport = ea->fcport;
+ 
+ 	if (ea->rc) { /* rval */
+ 		if (fcport->login_retry == 0) {
+ 			fcport->login_retry = vha->hw->login_retry_count;
+ 			ql_dbg(ql_dbg_disc, vha, 0x20de,
+ 			    "GNL failed Port login retry %8phN, retry cnt=%d.\n",
+ 			    fcport->port_name, fcport->login_retry);
+ 		}
+ 		return;
+ 	}
+ 
+ 	if (fcport->last_rscn_gen != fcport->rscn_gen) {
+ 		ql_dbg(ql_dbg_disc, vha, 0x20df,
+ 		    "%s %8phC rscn gen changed rscn %d|%d \n",
+ 		    __func__, fcport->port_name,
+ 		    fcport->last_rscn_gen, fcport->rscn_gen);
+ 		qla24xx_post_gidpn_work(vha, fcport);
+ 		return;
+ 	} else if (fcport->last_login_gen != fcport->login_gen) {
+ 		ql_dbg(ql_dbg_disc, vha, 0x20e0,
+ 		    "%s %8phC login gen changed login %d|%d\n",
+ 		    __func__, fcport->port_name,
+ 		    fcport->last_login_gen, fcport->login_gen);
+ 		return;
+ 	}
+ 
+ 	n = ea->data[0] / sizeof(struct get_name_list_extended);
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0x20e1,
+ 	    "%s %d %8phC n %d %02x%02x%02x lid %d \n",
+ 	    __func__, __LINE__, fcport->port_name, n,
+ 	    fcport->d_id.b.domain, fcport->d_id.b.area,
+ 	    fcport->d_id.b.al_pa, fcport->loop_id);
+ 
+ 	for (i = 0; i < n; i++) {
+ 		e = &vha->gnl.l[i];
+ 		wwn = wwn_to_u64(e->port_name);
+ 
+ 		if (memcmp((u8 *)&wwn, fcport->port_name, WWN_SIZE))
+ 			continue;
+ 
+ 		found = 1;
+ 		id.b.domain = e->port_id[2];
+ 		id.b.area = e->port_id[1];
+ 		id.b.al_pa = e->port_id[0];
+ 		id.b.rsvd_1 = 0;
+ 
+ 		loop_id = le16_to_cpu(e->nport_handle);
+ 		loop_id = (loop_id & 0x7fff);
+ 
+ 		ql_dbg(ql_dbg_disc, vha, 0x20e2,
+ 		    "%s found %8phC CLS [%d|%d] ID[%02x%02x%02x|%02x%02x%02x] lid[%d|%d]\n",
+ 		    __func__, fcport->port_name,
+ 		    e->current_login_state, fcport->fw_login_state,
+ 		    id.b.domain, id.b.area, id.b.al_pa,
+ 		    fcport->d_id.b.domain, fcport->d_id.b.area,
+ 		    fcport->d_id.b.al_pa, loop_id, fcport->loop_id);
+ 
+ 		if ((id.b24 != fcport->d_id.b24) ||
+ 		    ((fcport->loop_id != FC_NO_LOOP_ID) &&
+ 			(fcport->loop_id != loop_id))) {
+ 			ql_dbg(ql_dbg_disc, vha, 0x20e3,
+ 			    "%s %d %8phC post del sess\n",
+ 			    __func__, __LINE__, fcport->port_name);
+ 			qlt_schedule_sess_for_deletion(fcport, 1);
+ 			return;
+ 		}
+ 
+ 		fcport->loop_id = loop_id;
+ 
+ 		wwn = wwn_to_u64(fcport->port_name);
+ 		qlt_find_sess_invalidate_other(vha, wwn,
+ 			id, loop_id, &conflict_fcport);
+ 
+ 		if (conflict_fcport) {
+ 			/*
+ 			 * Another share fcport share the same loop_id &
+ 			 * nport id. Conflict fcport needs to finish
+ 			 * cleanup before this fcport can proceed to login.
+ 			 */
+ 			conflict_fcport->conflict = fcport;
+ 			fcport->login_pause = 1;
+ 		}
+ 
+ 		if  (fcport->fc4f_nvme)
+ 			current_login_state = e->current_login_state >> 4;
+ 		else
+ 			current_login_state = e->current_login_state & 0xf;
+ 
+ 		switch (current_login_state) {
+ 		case DSC_LS_PRLI_COMP:
+ 			ql_dbg(ql_dbg_disc, vha, 0x20e4,
+ 			    "%s %d %8phC post gpdb\n",
+ 			    __func__, __LINE__, fcport->port_name);
+ 			opt = PDO_FORCE_ADISC;
+ 			qla24xx_post_gpdb_work(vha, fcport, opt);
+ 			break;
+ 		case DSC_LS_PORT_UNAVAIL:
+ 		default:
+ 			if (fcport->loop_id == FC_NO_LOOP_ID) {
+ 				qla2x00_find_new_loop_id(vha, fcport);
+ 				fcport->fw_login_state = DSC_LS_PORT_UNAVAIL;
+ 			}
+ 			ql_dbg(ql_dbg_disc, vha, 0x20e5,
+ 			    "%s %d %8phC\n",
+ 			    __func__, __LINE__, fcport->port_name);
+ 			qla24xx_fcport_handle_login(vha, fcport);
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (!found) {
+ 		/* fw has no record of this port */
+ 		if (fcport->loop_id == FC_NO_LOOP_ID) {
+ 			qla2x00_find_new_loop_id(vha, fcport);
+ 			fcport->fw_login_state = DSC_LS_PORT_UNAVAIL;
+ 		} else {
+ 			for (i = 0; i < n; i++) {
+ 				e = &vha->gnl.l[i];
+ 				id.b.domain = e->port_id[0];
+ 				id.b.area = e->port_id[1];
+ 				id.b.al_pa = e->port_id[2];
+ 				id.b.rsvd_1 = 0;
+ 				loop_id = le16_to_cpu(e->nport_handle);
+ 
+ 				if (fcport->d_id.b24 == id.b24) {
+ 					conflict_fcport =
+ 					    qla2x00_find_fcport_by_wwpn(vha,
+ 						e->port_name, 0);
+ 
+ 					ql_dbg(ql_dbg_disc, vha, 0x20e6,
+ 					    "%s %d %8phC post del sess\n",
+ 					    __func__, __LINE__,
+ 					    conflict_fcport->port_name);
+ 					qlt_schedule_sess_for_deletion
+ 						(conflict_fcport, 1);
+ 				}
+ 
+ 				if (fcport->loop_id == loop_id) {
+ 					/* FW already picked this loop id for another fcport */
+ 					qla2x00_find_new_loop_id(vha, fcport);
+ 				}
+ 			}
+ 		}
+ 		qla24xx_fcport_handle_login(vha, fcport);
+ 	}
+ } /* gnl_event */
+ 
+ static void
+ qla24xx_async_gnl_sp_done(void *s, int res)
+ {
+ 	struct srb *sp = s;
+ 	struct scsi_qla_host *vha = sp->vha;
+ 	unsigned long flags;
+ 	struct fc_port *fcport = NULL, *tf;
+ 	u16 i, n = 0, loop_id;
+ 	struct event_arg ea;
+ 	struct get_name_list_extended *e;
+ 	u64 wwn;
+ 	struct list_head h;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0x20e7,
+ 	    "Async done-%s res %x mb[1]=%x mb[2]=%x \n",
+ 	    sp->name, res, sp->u.iocb_cmd.u.mbx.in_mb[1],
+ 	    sp->u.iocb_cmd.u.mbx.in_mb[2]);
+ 
+ 	memset(&ea, 0, sizeof(ea));
+ 	ea.sp = sp;
+ 	ea.rc = res;
+ 	ea.event = FCME_GNL_DONE;
+ 
+ 	if (sp->u.iocb_cmd.u.mbx.in_mb[1] >=
+ 	    sizeof(struct get_name_list_extended)) {
+ 		n = sp->u.iocb_cmd.u.mbx.in_mb[1] /
+ 		    sizeof(struct get_name_list_extended);
+ 		ea.data[0] = sp->u.iocb_cmd.u.mbx.in_mb[1]; /* amnt xfered */
+ 	}
+ 
+ 	for (i = 0; i < n; i++) {
+ 		e = &vha->gnl.l[i];
+ 		loop_id = le16_to_cpu(e->nport_handle);
+ 		/* mask out reserve bit */
+ 		loop_id = (loop_id & 0x7fff);
+ 		set_bit(loop_id, vha->hw->loop_id_map);
+ 		wwn = wwn_to_u64(e->port_name);
+ 
+ 		ql_dbg(ql_dbg_disc + ql_dbg_verbose, vha, 0x20e8,
+ 		    "%s %8phC %02x:%02x:%02x state %d/%d lid %x \n",
+ 		    __func__, (void *)&wwn, e->port_id[2], e->port_id[1],
+ 		    e->port_id[0], e->current_login_state, e->last_login_state,
+ 		    (loop_id & 0x7fff));
+ 	}
+ 
+ 	spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
+ 	vha->gnl.sent = 0;
+ 
+ 	INIT_LIST_HEAD(&h);
+ 	fcport = tf = NULL;
+ 	if (!list_empty(&vha->gnl.fcports))
+ 		list_splice_init(&vha->gnl.fcports, &h);
+ 
+ 	list_for_each_entry_safe(fcport, tf, &h, gnl_entry) {
+ 		list_del_init(&fcport->gnl_entry);
+ 		fcport->flags &= ~FCF_ASYNC_SENT;
+ 		ea.fcport = fcport;
+ 
+ 		qla2x00_fcport_event_handler(vha, &ea);
+ 	}
+ 
+ 	spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ 
+ 	sp->free(sp);
+ }
+ 
+ int qla24xx_async_gnl(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	srb_t *sp;
+ 	struct srb_iocb *mbx;
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	unsigned long flags;
+ 	u16 *mb;
+ 
+ 	if (!vha->flags.online)
+ 		goto done;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0x20d9,
+ 	    "Async-gnlist WWPN %8phC \n", fcport->port_name);
+ 
+ 	spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
+ 	fcport->flags |= FCF_ASYNC_SENT;
+ 	fcport->disc_state = DSC_GNL;
+ 	fcport->last_rscn_gen = fcport->rscn_gen;
+ 	fcport->last_login_gen = fcport->login_gen;
+ 
+ 	list_add_tail(&fcport->gnl_entry, &vha->gnl.fcports);
+ 	if (vha->gnl.sent) {
+ 		spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ 		rval = QLA_SUCCESS;
+ 		goto done;
+ 	}
+ 	vha->gnl.sent = 1;
+ 	spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ 
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);
+ 	if (!sp)
+ 		goto done;
+ 	sp->type = SRB_MB_IOCB;
+ 	sp->name = "gnlist";
+ 	sp->gen1 = fcport->rscn_gen;
+ 	sp->gen2 = fcport->login_gen;
+ 
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha)+2);
+ 
+ 	mb = sp->u.iocb_cmd.u.mbx.out_mb;
+ 	mb[0] = MBC_PORT_NODE_NAME_LIST;
+ 	mb[1] = BIT_2 | BIT_3;
+ 	mb[2] = MSW(vha->gnl.ldma);
+ 	mb[3] = LSW(vha->gnl.ldma);
+ 	mb[6] = MSW(MSD(vha->gnl.ldma));
+ 	mb[7] = LSW(MSD(vha->gnl.ldma));
+ 	mb[8] = vha->gnl.size;
+ 	mb[9] = vha->vp_idx;
+ 
+ 	mbx = &sp->u.iocb_cmd;
+ 	mbx->timeout = qla2x00_async_iocb_timeout;
+ 
+ 	sp->done = qla24xx_async_gnl_sp_done;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS)
+ 		goto done_free_sp;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0x20da,
+ 	    "Async-%s - OUT WWPN %8phC hndl %x\n",
+ 	    sp->name, fcport->port_name, sp->handle);
+ 
+ 	return rval;
+ 
+ done_free_sp:
+ 	sp->free(sp);
+ done:
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 	return rval;
+ }
+ 
+ int qla24xx_post_gnl_work(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	struct qla_work_evt *e;
+ 
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_GNL);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.fcport.fcport = fcport;
+ 	return qla2x00_post_work(vha, e);
+ }
+ 
+ static
+ void qla24xx_async_gpdb_sp_done(void *s, int res)
+ {
+ 	struct srb *sp = s;
+ 	struct scsi_qla_host *vha = sp->vha;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct port_database_24xx *pd;
+ 	fc_port_t *fcport = sp->fcport;
+ 	u16 *mb = sp->u.iocb_cmd.u.mbx.in_mb;
+ 	int rval = QLA_SUCCESS;
+ 	struct event_arg ea;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0x20db,
+ 	    "Async done-%s res %x, WWPN %8phC mb[1]=%x mb[2]=%x \n",
+ 	    sp->name, res, fcport->port_name, mb[1], mb[2]);
+ 
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 
+ 	if (res) {
+ 		rval = res;
+ 		goto gpd_error_out;
+ 	}
+ 
+ 	pd = (struct port_database_24xx *)sp->u.iocb_cmd.u.mbx.in;
+ 
+ 	rval = __qla24xx_parse_gpdb(vha, fcport, pd);
+ 
+ gpd_error_out:
+ 	memset(&ea, 0, sizeof(ea));
+ 	ea.event = FCME_GPDB_DONE;
+ 	ea.rc = rval;
+ 	ea.fcport = fcport;
+ 	ea.sp = sp;
+ 
+ 	qla2x00_fcport_event_handler(vha, &ea);
+ 
+ 	dma_pool_free(ha->s_dma_pool, sp->u.iocb_cmd.u.mbx.in,
+ 		sp->u.iocb_cmd.u.mbx.in_dma);
+ 
+ 	sp->free(sp);
+ }
+ 
+ static int qla24xx_post_prli_work(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	struct qla_work_evt *e;
+ 
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_PRLI);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.fcport.fcport = fcport;
+ 
+ 	return qla2x00_post_work(vha, e);
+ }
+ 
+ static void
+ qla2x00_async_prli_sp_done(void *ptr, int res)
+ {
+ 	srb_t *sp = ptr;
+ 	struct scsi_qla_host *vha = sp->vha;
+ 	struct srb_iocb *lio = &sp->u.iocb_cmd;
+ 	struct event_arg ea;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0x2129,
+ 	    "%s %8phC res %d \n", __func__,
+ 	    sp->fcport->port_name, res);
+ 
+ 	sp->fcport->flags &= ~FCF_ASYNC_SENT;
+ 
+ 	if (!test_bit(UNLOADING, &vha->dpc_flags)) {
+ 		memset(&ea, 0, sizeof(ea));
+ 		ea.event = FCME_PRLI_DONE;
+ 		ea.fcport = sp->fcport;
+ 		ea.data[0] = lio->u.logio.data[0];
+ 		ea.data[1] = lio->u.logio.data[1];
+ 		ea.iop[0] = lio->u.logio.iop[0];
+ 		ea.iop[1] = lio->u.logio.iop[1];
+ 		ea.sp = sp;
+ 
+ 		qla2x00_fcport_event_handler(vha, &ea);
+ 	}
+ 
+ 	sp->free(sp);
+ }
+ 
+ int
+ qla24xx_async_prli(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	srb_t *sp;
+ 	struct srb_iocb *lio;
+ 	int rval = QLA_FUNCTION_FAILED;
+ 
+ 	if (!vha->flags.online)
+ 		return rval;
+ 
+ 	if (fcport->fw_login_state == DSC_LS_PLOGI_PEND ||
+ 	    fcport->fw_login_state == DSC_LS_PLOGI_COMP ||
+ 	    fcport->fw_login_state == DSC_LS_PRLI_PEND)
+ 		return rval;
+ 
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);
+ 	if (!sp)
+ 		return rval;
+ 
+ 	fcport->flags |= FCF_ASYNC_SENT;
+ 	fcport->logout_completed = 0;
+ 
+ 	sp->type = SRB_PRLI_CMD;
+ 	sp->name = "prli";
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);
+ 
+ 	lio = &sp->u.iocb_cmd;
+ 	lio->timeout = qla2x00_async_iocb_timeout;
+ 	sp->done = qla2x00_async_prli_sp_done;
+ 	lio->u.logio.flags = 0;
+ 
+ 	if  (fcport->fc4f_nvme)
+ 		lio->u.logio.flags |= SRB_LOGIN_NVME_PRLI;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS) {
+ 		fcport->flags &= ~FCF_ASYNC_SENT;
+ 		fcport->flags |= FCF_LOGIN_NEEDED;
+ 		set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
+ 		goto done_free_sp;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0x211b,
+ 	    "Async-prli - %8phC hdl=%x, loopid=%x portid=%06x retries=%d.\n",
+ 	    fcport->port_name, sp->handle, fcport->loop_id,
+ 	    fcport->d_id.b24, fcport->login_retry);
+ 
+ 	return rval;
+ 
+ done_free_sp:
+ 	sp->free(sp);
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 	return rval;
+ }
+ 
+ static int qla24xx_post_gpdb_work(struct scsi_qla_host *vha, fc_port_t *fcport,
+     u8 opt)
+ {
+ 	struct qla_work_evt *e;
+ 
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_GPDB);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.fcport.fcport = fcport;
+ 	e->u.fcport.opt = opt;
+ 	return qla2x00_post_work(vha, e);
+ }
+ 
+ int qla24xx_async_gpdb(struct scsi_qla_host *vha, fc_port_t *fcport, u8 opt)
+ {
+ 	srb_t *sp;
+ 	struct srb_iocb *mbx;
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	u16 *mb;
+ 	dma_addr_t pd_dma;
+ 	struct port_database_24xx *pd;
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	if (!vha->flags.online)
+ 		goto done;
+ 
+ 	fcport->flags |= FCF_ASYNC_SENT;
+ 	fcport->disc_state = DSC_GPDB;
+ 
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);
+ 	if (!sp)
+ 		goto done;
+ 
+ 	pd = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &pd_dma);
+ 	if (pd == NULL) {
+ 		ql_log(ql_log_warn, vha, 0xd043,
+ 		    "Failed to allocate port database structure.\n");
+ 		goto done_free_sp;
+ 	}
+ 	memset(pd, 0, max(PORT_DATABASE_SIZE, PORT_DATABASE_24XX_SIZE));
+ 
+ 	sp->type = SRB_MB_IOCB;
+ 	sp->name = "gpdb";
+ 	sp->gen1 = fcport->rscn_gen;
+ 	sp->gen2 = fcport->login_gen;
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);
+ 
+ 	mb = sp->u.iocb_cmd.u.mbx.out_mb;
+ 	mb[0] = MBC_GET_PORT_DATABASE;
+ 	mb[1] = fcport->loop_id;
+ 	mb[2] = MSW(pd_dma);
+ 	mb[3] = LSW(pd_dma);
+ 	mb[6] = MSW(MSD(pd_dma));
+ 	mb[7] = LSW(MSD(pd_dma));
+ 	mb[9] = vha->vp_idx;
+ 	mb[10] = opt;
+ 
+ 	mbx = &sp->u.iocb_cmd;
+ 	mbx->timeout = qla2x00_async_iocb_timeout;
+ 	mbx->u.mbx.in = (void *)pd;
+ 	mbx->u.mbx.in_dma = pd_dma;
+ 
+ 	sp->done = qla24xx_async_gpdb_sp_done;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS)
+ 		goto done_free_sp;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0x20dc,
+ 	    "Async-%s %8phC hndl %x opt %x\n",
+ 	    sp->name, fcport->port_name, sp->handle, opt);
+ 
+ 	return rval;
+ 
+ done_free_sp:
+ 	if (pd)
+ 		dma_pool_free(ha->s_dma_pool, pd, pd_dma);
+ 
+ 	sp->free(sp);
+ done:
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 	qla24xx_post_gpdb_work(vha, fcport, opt);
+ 	return rval;
+ }
+ 
+ static
+ void qla24xx_handle_gpdb_event(scsi_qla_host_t *vha, struct event_arg *ea)
+ {
+ 	int rval = ea->rc;
+ 	fc_port_t *fcport = ea->fcport;
+ 	unsigned long flags;
+ 
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0x20d2,
+ 	    "%s %8phC DS %d LS %d rval %d\n", __func__, fcport->port_name,
+ 	    fcport->disc_state, fcport->fw_login_state, rval);
+ 
+ 	if (ea->sp->gen2 != fcport->login_gen) {
+ 		/* target side must have changed it. */
+ 		ql_dbg(ql_dbg_disc, vha, 0x20d3,
+ 		    "%s %8phC generation changed rscn %d|%d login %d|%d \n",
+ 		    __func__, fcport->port_name, fcport->last_rscn_gen,
+ 		    fcport->rscn_gen, fcport->last_login_gen,
+ 		    fcport->login_gen);
+ 		return;
+ 	} else if (ea->sp->gen1 != fcport->rscn_gen) {
+ 		ql_dbg(ql_dbg_disc, vha, 0x20d4, "%s %d %8phC post gidpn\n",
+ 		    __func__, __LINE__, fcport->port_name);
+ 		qla24xx_post_gidpn_work(vha, fcport);
+ 		return;
+ 	}
+ 
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_dbg(ql_dbg_disc, vha, 0x20d5, "%s %d %8phC post del sess\n",
+ 		    __func__, __LINE__, fcport->port_name);
+ 		qlt_schedule_sess_for_deletion_lock(fcport);
+ 		return;
+ 	}
+ 
+ 	spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
+ 	ea->fcport->login_gen++;
+ 	ea->fcport->deleted = 0;
+ 	ea->fcport->logout_on_delete = 1;
+ 
+ 	if (!ea->fcport->login_succ && !IS_SW_RESV_ADDR(ea->fcport->d_id)) {
+ 		vha->fcport_count++;
+ 		ea->fcport->login_succ = 1;
+ 
+ 		if (!IS_IIDMA_CAPABLE(vha->hw) ||
+ 		    !vha->hw->flags.gpsc_supported) {
+ 			ql_dbg(ql_dbg_disc, vha, 0x20d6,
+ 			    "%s %d %8phC post upd_fcport fcp_cnt %d\n",
+ 			    __func__, __LINE__, fcport->port_name,
+ 			    vha->fcport_count);
+ 
+ 			qla24xx_post_upd_fcport_work(vha, fcport);
+ 		} else {
+ 			ql_dbg(ql_dbg_disc, vha, 0x20d7,
+ 			    "%s %d %8phC post gpsc fcp_cnt %d\n",
+ 			    __func__, __LINE__, fcport->port_name,
+ 			    vha->fcport_count);
+ 
+ 			qla24xx_post_gpsc_work(vha, fcport);
+ 		}
+ 	}
+ 	spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ } /* gpdb event */
+ 
+ int qla24xx_fcport_handle_login(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	if (fcport->login_retry == 0)
+ 		return 0;
+ 
+ 	if (fcport->scan_state != QLA_FCPORT_FOUND)
+ 		return 0;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0x20d8,
+ 	    "%s %8phC DS %d LS %d P %d fl %x confl %p rscn %d|%d login %d|%d retry %d lid %d\n",
+ 	    __func__, fcport->port_name, fcport->disc_state,
+ 	    fcport->fw_login_state, fcport->login_pause, fcport->flags,
+ 	    fcport->conflict, fcport->last_rscn_gen, fcport->rscn_gen,
+ 	    fcport->last_login_gen, fcport->login_gen, fcport->login_retry,
+ 	    fcport->loop_id);
+ 
+ 	fcport->login_retry--;
+ 
+ 	if ((fcport->fw_login_state == DSC_LS_PLOGI_PEND) ||
+ 	    (fcport->fw_login_state == DSC_LS_PRLI_PEND))
+ 		return 0;
+ 
+ 	if (fcport->fw_login_state == DSC_LS_PLOGI_COMP) {
+ 		if (time_before_eq(jiffies, fcport->plogi_nack_done_deadline))
+ 			return 0;
+ 	}
+ 
+ 	/* for pure Target Mode. Login will not be initiated */
+ 	if (vha->host->active_mode == MODE_TARGET)
+ 		return 0;
+ 
+ 	if (fcport->flags & FCF_ASYNC_SENT) {
+ 		set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
+ 		return 0;
+ 	}
+ 
+ 	switch (fcport->disc_state) {
+ 	case DSC_DELETED:
+ 		if (fcport->loop_id == FC_NO_LOOP_ID) {
+ 			ql_dbg(ql_dbg_disc, vha, 0x20bd,
+ 			    "%s %d %8phC post gnl\n",
+ 			    __func__, __LINE__, fcport->port_name);
+ 			qla24xx_async_gnl(vha, fcport);
+ 		} else {
+ 			ql_dbg(ql_dbg_disc, vha, 0x20bf,
+ 			    "%s %d %8phC post login\n",
+ 			    __func__, __LINE__, fcport->port_name);
+ 			fcport->disc_state = DSC_LOGIN_PEND;
+ 			qla2x00_post_async_login_work(vha, fcport, NULL);
+ 		}
+ 		break;
+ 
+ 	case DSC_GNL:
+ 		if (fcport->login_pause) {
+ 			fcport->last_rscn_gen = fcport->rscn_gen;
+ 			fcport->last_login_gen = fcport->login_gen;
+ 			set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
+ 			break;
+ 		}
+ 
+ 		if (fcport->flags & FCF_FCP2_DEVICE) {
+ 			u8 opt = PDO_FORCE_ADISC;
+ 
+ 			ql_dbg(ql_dbg_disc, vha, 0x20c9,
+ 			    "%s %d %8phC post gpdb\n",
+ 			    __func__, __LINE__, fcport->port_name);
+ 
+ 			fcport->disc_state = DSC_GPDB;
+ 			qla24xx_post_gpdb_work(vha, fcport, opt);
+ 		} else {
+ 			ql_dbg(ql_dbg_disc, vha, 0x20cf,
+ 			    "%s %d %8phC post login\n",
+ 			    __func__, __LINE__, fcport->port_name);
+ 			fcport->disc_state = DSC_LOGIN_PEND;
+ 			qla2x00_post_async_login_work(vha, fcport, NULL);
+ 		}
+ 
+ 		break;
+ 
+ 	case DSC_LOGIN_FAILED:
+ 		ql_dbg(ql_dbg_disc, vha, 0x20d0,
+ 		    "%s %d %8phC post gidpn\n",
+ 		    __func__, __LINE__, fcport->port_name);
+ 
+ 		qla24xx_post_gidpn_work(vha, fcport);
+ 		break;
+ 
+ 	case DSC_LOGIN_COMPLETE:
+ 		/* recheck login state */
+ 		ql_dbg(ql_dbg_disc, vha, 0x20d1,
+ 		    "%s %d %8phC post gpdb\n",
+ 		    __func__, __LINE__, fcport->port_name);
+ 
+ 		qla24xx_post_gpdb_work(vha, fcport, PDO_FORCE_ADISC);
+ 		break;
+ 
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static
+ void qla24xx_handle_rscn_event(fc_port_t *fcport, struct event_arg *ea)
+ {
+ 	fcport->rscn_gen++;
+ 
+ 	ql_dbg(ql_dbg_disc, fcport->vha, 0x210c,
+ 	    "%s %8phC DS %d LS %d\n",
+ 	    __func__, fcport->port_name, fcport->disc_state,
+ 	    fcport->fw_login_state);
+ 
+ 	if (fcport->flags & FCF_ASYNC_SENT)
+ 		return;
+ 
+ 	switch (fcport->disc_state) {
+ 	case DSC_DELETED:
+ 	case DSC_LOGIN_COMPLETE:
+ 		qla24xx_post_gidpn_work(fcport->vha, fcport);
+ 		break;
+ 
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ int qla24xx_post_newsess_work(struct scsi_qla_host *vha, port_id_t *id,
+ 	u8 *port_name, void *pla)
+ {
+ 	struct qla_work_evt *e;
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_NEW_SESS);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.new_sess.id = *id;
+ 	e->u.new_sess.pla = pla;
+ 	memcpy(e->u.new_sess.port_name, port_name, WWN_SIZE);
+ 
+ 	return qla2x00_post_work(vha, e);
+ }
+ 
+ static
+ int qla24xx_handle_delete_done_event(scsi_qla_host_t *vha,
+ 	struct event_arg *ea)
+ {
+ 	fc_port_t *fcport = ea->fcport;
+ 
+ 	if (test_bit(UNLOADING, &vha->dpc_flags))
+ 		return 0;
+ 
+ 	switch (vha->host->active_mode) {
+ 	case MODE_INITIATOR:
+ 	case MODE_DUAL:
+ 		if (fcport->scan_state == QLA_FCPORT_FOUND)
+ 			qla24xx_fcport_handle_login(vha, fcport);
+ 		break;
+ 
+ 	case MODE_TARGET:
+ 	default:
+ 		/* no-op */
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static
+ void qla24xx_handle_relogin_event(scsi_qla_host_t *vha,
+ 	struct event_arg *ea)
+ {
+ 	fc_port_t *fcport = ea->fcport;
+ 
+ 	if (fcport->scan_state != QLA_FCPORT_FOUND) {
+ 		fcport->login_retry++;
+ 		return;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0x2102,
+ 	    "%s %8phC DS %d LS %d P %d del %d cnfl %p rscn %d|%d login %d|%d fl %x\n",
+ 	    __func__, fcport->port_name, fcport->disc_state,
+ 	    fcport->fw_login_state, fcport->login_pause,
+ 	    fcport->deleted, fcport->conflict,
+ 	    fcport->last_rscn_gen, fcport->rscn_gen,
+ 	    fcport->last_login_gen, fcport->login_gen,
+ 	    fcport->flags);
+ 
+ 	if ((fcport->fw_login_state == DSC_LS_PLOGI_PEND) ||
+ 	    (fcport->fw_login_state == DSC_LS_PRLI_PEND))
+ 		return;
+ 
+ 	if (fcport->fw_login_state == DSC_LS_PLOGI_COMP) {
+ 		if (time_before_eq(jiffies, fcport->plogi_nack_done_deadline))
+ 			return;
+ 	}
+ 
+ 	if (fcport->flags & FCF_ASYNC_SENT) {
+ 		fcport->login_retry++;
+ 		set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
+ 		return;
+ 	}
+ 
+ 	if (fcport->disc_state == DSC_DELETE_PEND) {
+ 		fcport->login_retry++;
+ 		return;
+ 	}
+ 
+ 	if (fcport->last_rscn_gen != fcport->rscn_gen) {
+ 		ql_dbg(ql_dbg_disc, vha, 0x20e9, "%s %d %8phC post gidpn\n",
+ 		    __func__, __LINE__, fcport->port_name);
+ 
+ 		qla24xx_async_gidpn(vha, fcport);
+ 		return;
+ 	}
+ 
+ 	qla24xx_fcport_handle_login(vha, fcport);
+ }
+ 
+ void qla2x00_fcport_event_handler(scsi_qla_host_t *vha, struct event_arg *ea)
+ {
+ 	fc_port_t *fcport, *f, *tf;
+ 	uint32_t id = 0, mask, rid;
+ 	int rc;
+ 
+ 	switch (ea->event) {
+ 	case FCME_RELOGIN:
+ 	case FCME_RSCN:
+ 	case FCME_GIDPN_DONE:
+ 	case FCME_GPSC_DONE:
+ 	case FCME_GPNID_DONE:
+ 		if (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags) ||
+ 		    test_bit(LOOP_RESYNC_ACTIVE, &vha->dpc_flags))
+ 			return;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	switch (ea->event) {
+ 	case FCME_RELOGIN:
+ 		if (test_bit(UNLOADING, &vha->dpc_flags))
+ 			return;
+ 
+ 		qla24xx_handle_relogin_event(vha, ea);
+ 		break;
+ 	case FCME_RSCN:
+ 		if (test_bit(UNLOADING, &vha->dpc_flags))
+ 			return;
+ 		switch (ea->id.b.rsvd_1) {
+ 		case RSCN_PORT_ADDR:
+ 			fcport = qla2x00_find_fcport_by_nportid(vha, &ea->id, 1);
+ 			if (!fcport) {
+ 				/* cable moved */
+ 				rc = qla24xx_post_gpnid_work(vha, &ea->id);
+ 				if (rc) {
+ 					ql_log(ql_log_warn, vha, 0xd044,
+ 					    "RSCN GPNID work failed %02x%02x%02x\n",
+ 					    ea->id.b.domain, ea->id.b.area,
+ 					    ea->id.b.al_pa);
+ 				}
+ 			} else {
+ 				ea->fcport = fcport;
+ 				qla24xx_handle_rscn_event(fcport, ea);
+ 			}
+ 			break;
+ 		case RSCN_AREA_ADDR:
+ 		case RSCN_DOM_ADDR:
+ 			if (ea->id.b.rsvd_1 == RSCN_AREA_ADDR) {
+ 				mask = 0xffff00;
+ 				ql_dbg(ql_dbg_async, vha, 0x5044,
+ 				    "RSCN: Area 0x%06x was affected\n",
+ 				    ea->id.b24);
+ 			} else {
+ 				mask = 0xff0000;
+ 				ql_dbg(ql_dbg_async, vha, 0x507a,
+ 				    "RSCN: Domain 0x%06x was affected\n",
+ 				    ea->id.b24);
+ 			}
+ 
+ 			rid = ea->id.b24 & mask;
+ 			list_for_each_entry_safe(f, tf, &vha->vp_fcports,
+ 			    list) {
+ 				id = f->d_id.b24 & mask;
+ 				if (rid == id) {
+ 					ea->fcport = f;
+ 					qla24xx_handle_rscn_event(f, ea);
+ 				}
+ 			}
+ 			break;
+ 		case RSCN_FAB_ADDR:
+ 		default:
+ 			ql_log(ql_log_warn, vha, 0xd045,
+ 			    "RSCN: Fabric was affected. Addr format %d\n",
+ 			    ea->id.b.rsvd_1);
+ 			qla2x00_mark_all_devices_lost(vha, 1);
+ 			set_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);
+ 			set_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);
+ 		}
+ 		break;
+ 	case FCME_GIDPN_DONE:
+ 		qla24xx_handle_gidpn_event(vha, ea);
+ 		break;
+ 	case FCME_GNL_DONE:
+ 		qla24xx_handle_gnl_done_event(vha, ea);
+ 		break;
+ 	case FCME_GPSC_DONE:
+ 		qla24xx_post_upd_fcport_work(vha, ea->fcport);
+ 		break;
+ 	case FCME_PLOGI_DONE:	/* Initiator side sent LLIOCB */
+ 		qla24xx_handle_plogi_done_event(vha, ea);
+ 		break;
+ 	case FCME_PRLI_DONE:
+ 		qla24xx_handle_prli_done_event(vha, ea);
+ 		break;
+ 	case FCME_GPDB_DONE:
+ 		qla24xx_handle_gpdb_event(vha, ea);
+ 		break;
+ 	case FCME_GPNID_DONE:
+ 		qla24xx_handle_gpnid_event(vha, ea);
+ 		break;
+ 	case FCME_DELETE_DONE:
+ 		qla24xx_handle_delete_done_event(vha, ea);
+ 		break;
+ 	default:
+ 		BUG_ON(1);
+ 		break;
+ 	}
+ }
+ 
++>>>>>>> a5d42f4cffa5 (scsi: qla2xxx: Add FC-NVMe port discovery and PRLI handling)
  static void
  qla2x00_tmf_iocb_timeout(void *data)
  {
@@@ -439,59 -1419,93 +1382,101 @@@ qla24xx_async_abort_command(srb_t *sp
  	return qla24xx_async_abort_cmd(sp);
  }
  
++<<<<<<< HEAD
 +void
 +qla2x00_async_login_done(struct scsi_qla_host *vha, fc_port_t *fcport,
 +    uint16_t *data)
++=======
+ static void
+ qla24xx_handle_prli_done_event(struct scsi_qla_host *vha, struct event_arg *ea)
+ {
+ 	switch (ea->data[0]) {
+ 	case MBS_COMMAND_COMPLETE:
+ 		ql_dbg(ql_dbg_disc, vha, 0x2118,
+ 		    "%s %d %8phC post gpdb\n",
+ 		    __func__, __LINE__, ea->fcport->port_name);
+ 
+ 		ea->fcport->chip_reset = vha->hw->base_qpair->chip_reset;
+ 		ea->fcport->logout_on_delete = 1;
+ 		qla24xx_post_gpdb_work(vha, ea->fcport, 0);
+ 		break;
+ 	default:
+ 		ql_dbg(ql_dbg_disc, vha, 0x2119,
+ 		    "%s %d %8phC unhandle event of %x\n",
+ 		    __func__, __LINE__, ea->fcport->port_name, ea->data[0]);
+ 		break;
+ 	}
+ }
+ 
+ static void
+ qla24xx_handle_plogi_done_event(struct scsi_qla_host *vha, struct event_arg *ea)
++>>>>>>> a5d42f4cffa5 (scsi: qla2xxx: Add FC-NVMe port discovery and PRLI handling)
  {
 -	port_id_t cid;	/* conflict Nport id */
 +	int rval;
  
 -	switch (ea->data[0]) {
 +	switch (data[0]) {
  	case MBS_COMMAND_COMPLETE:
  		/*
  		 * Driver must validate login state - If PRLI not complete,
  		 * force a relogin attempt via implicit LOGO, PLOGI, and PRLI
  		 * requests.
  		 */
++<<<<<<< HEAD
 +		rval = qla2x00_get_port_database(vha, fcport, 0);
 +		if (rval == QLA_NOT_LOGGED_IN) {
 +			fcport->flags &= ~FCF_ASYNC_SENT;
 +			fcport->flags |= FCF_LOGIN_NEEDED;
 +			set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
 +			break;
 +		}
 +
 +		if (rval != QLA_SUCCESS) {
 +			qla2x00_post_async_logout_work(vha, fcport, NULL);
 +			qla2x00_post_async_login_work(vha, fcport, NULL);
 +			break;
 +		}
 +		if (fcport->flags & FCF_FCP2_DEVICE) {
 +			qla2x00_post_async_adisc_work(vha, fcport, data);
 +			break;
 +		}
 +		qla2x00_update_fcport(vha, fcport);
++=======
+ 		if (ea->fcport->fc4f_nvme) {
+ 			ql_dbg(ql_dbg_disc, vha, 0x2117,
+ 				"%s %d %8phC post prli\n",
+ 				__func__, __LINE__, ea->fcport->port_name);
+ 			qla24xx_post_prli_work(vha, ea->fcport);
+ 		} else {
+ 			ql_dbg(ql_dbg_disc, vha, 0x20ea,
+ 				"%s %d %8phC post gpdb\n",
+ 				__func__, __LINE__, ea->fcport->port_name);
+ 			ea->fcport->chip_reset = vha->hw->base_qpair->chip_reset;
+ 			ea->fcport->logout_on_delete = 1;
+ 			qla24xx_post_gpdb_work(vha, ea->fcport, 0);
+ 		}
++>>>>>>> a5d42f4cffa5 (scsi: qla2xxx: Add FC-NVMe port discovery and PRLI handling)
  		break;
  	case MBS_COMMAND_ERROR:
 -		ql_dbg(ql_dbg_disc, vha, 0x20eb, "%s %d %8phC cmd error %x\n",
 -		    __func__, __LINE__, ea->fcport->port_name, ea->data[1]);
 -
 -		ea->fcport->flags &= ~FCF_ASYNC_SENT;
 -		ea->fcport->disc_state = DSC_LOGIN_FAILED;
 -		if (ea->data[1] & QLA_LOGIO_LOGIN_RETRIED)
 +		fcport->flags &= ~FCF_ASYNC_SENT;
 +		if (data[1] & QLA_LOGIO_LOGIN_RETRIED)
  			set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
  		else
 -			qla2x00_mark_device_lost(vha, ea->fcport, 1, 0);
 +			qla2x00_mark_device_lost(vha, fcport, 1, 0);
 +		break;
 +	case MBS_PORT_ID_USED:
 +		fcport->loop_id = data[1];
 +		qla2x00_post_async_logout_work(vha, fcport, NULL);
 +		qla2x00_post_async_login_work(vha, fcport, NULL);
  		break;
  	case MBS_LOOP_ID_USED:
 -		/* data[1] = IO PARAM 1 = nport ID  */
 -		cid.b.domain = (ea->iop[1] >> 16) & 0xff;
 -		cid.b.area   = (ea->iop[1] >>  8) & 0xff;
 -		cid.b.al_pa  = ea->iop[1] & 0xff;
 -		cid.b.rsvd_1 = 0;
 -
 -		ql_dbg(ql_dbg_disc, vha, 0x20ec,
 -		    "%s %d %8phC LoopID 0x%x in use post gnl\n",
 -		    __func__, __LINE__, ea->fcport->port_name,
 -		    ea->fcport->loop_id);
 -
 -		if (IS_SW_RESV_ADDR(cid)) {
 -			set_bit(ea->fcport->loop_id, vha->hw->loop_id_map);
 -			ea->fcport->loop_id = FC_NO_LOOP_ID;
 -		} else {
 -			qla2x00_clear_loop_id(ea->fcport);
 +		fcport->loop_id++;
 +		rval = qla2x00_find_new_loop_id(vha, fcport);
 +		if (rval != QLA_SUCCESS) {
 +			fcport->flags &= ~FCF_ASYNC_SENT;
 +			qla2x00_mark_device_lost(vha, fcport, 1, 0);
 +			break;
  		}
 -		qla24xx_post_gnl_work(vha, ea->fcport);
 -		break;
 -	case MBS_PORT_ID_USED:
 -		ql_dbg(ql_dbg_disc, vha, 0x20ed,
 -		    "%s %d %8phC NPortId %02x%02x%02x inuse post gidpn\n",
 -		    __func__, __LINE__, ea->fcport->port_name,
 -		    ea->fcport->d_id.b.domain, ea->fcport->d_id.b.area,
 -		    ea->fcport->d_id.b.al_pa);
 -
 -		qla2x00_clear_loop_id(ea->fcport);
 -		qla24xx_post_gidpn_work(vha, ea->fcport);
 +		qla2x00_post_async_login_work(vha, fcport, NULL);
  		break;
  	}
  	return;
diff --cc drivers/scsi/qla2xxx/qla_mbx.c
index 11982e7bd50f,1eac67e8fdfd..000000000000
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@@ -5658,3 -5829,238 +5658,241 @@@ qla26xx_dport_diagnostics(scsi_qla_host
  
  	return rval;
  }
++<<<<<<< HEAD
++=======
+ 
+ static void qla2x00_async_mb_sp_done(void *s, int res)
+ {
+ 	struct srb *sp = s;
+ 
+ 	sp->u.iocb_cmd.u.mbx.rc = res;
+ 
+ 	complete(&sp->u.iocb_cmd.u.mbx.comp);
+ 	/* don't free sp here. Let the caller do the free */
+ }
+ 
+ /*
+  * This mailbox uses the iocb interface to send MB command.
+  * This allows non-critial (non chip setup) command to go
+  * out in parrallel.
+  */
+ int qla24xx_send_mb_cmd(struct scsi_qla_host *vha, mbx_cmd_t *mcp)
+ {
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	srb_t *sp;
+ 	struct srb_iocb *c;
+ 
+ 	if (!vha->hw->flags.fw_started)
+ 		goto done;
+ 
+ 	sp = qla2x00_get_sp(vha, NULL, GFP_KERNEL);
+ 	if (!sp)
+ 		goto done;
+ 
+ 	sp->type = SRB_MB_IOCB;
+ 	sp->name = mb_to_str(mcp->mb[0]);
+ 
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);
+ 
+ 	memcpy(sp->u.iocb_cmd.u.mbx.out_mb, mcp->mb, SIZEOF_IOCB_MB_REG);
+ 
+ 	c = &sp->u.iocb_cmd;
+ 	c->timeout = qla2x00_async_iocb_timeout;
+ 	init_completion(&c->u.mbx.comp);
+ 
+ 	sp->done = qla2x00_async_mb_sp_done;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_dbg(ql_dbg_mbx, vha, 0x1018,
+ 		    "%s: %s Failed submission. %x.\n",
+ 		    __func__, sp->name, rval);
+ 		goto done_free_sp;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_mbx, vha, 0x113f, "MB:%s hndl %x submitted\n",
+ 	    sp->name, sp->handle);
+ 
+ 	wait_for_completion(&c->u.mbx.comp);
+ 	memcpy(mcp->mb, sp->u.iocb_cmd.u.mbx.in_mb, SIZEOF_IOCB_MB_REG);
+ 
+ 	rval = c->u.mbx.rc;
+ 	switch (rval) {
+ 	case QLA_FUNCTION_TIMEOUT:
+ 		ql_dbg(ql_dbg_mbx, vha, 0x1140, "%s: %s Timeout. %x.\n",
+ 		    __func__, sp->name, rval);
+ 		break;
+ 	case  QLA_SUCCESS:
+ 		ql_dbg(ql_dbg_mbx, vha, 0x119d, "%s: %s done.\n",
+ 		    __func__, sp->name);
+ 		sp->free(sp);
+ 		break;
+ 	default:
+ 		ql_dbg(ql_dbg_mbx, vha, 0x119e, "%s: %s Failed. %x.\n",
+ 		    __func__, sp->name, rval);
+ 		sp->free(sp);
+ 		break;
+ 	}
+ 
+ 	return rval;
+ 
+ done_free_sp:
+ 	sp->free(sp);
+ done:
+ 	return rval;
+ }
+ 
+ /*
+  * qla24xx_gpdb_wait
+  * NOTE: Do not call this routine from DPC thread
+  */
+ int qla24xx_gpdb_wait(struct scsi_qla_host *vha, fc_port_t *fcport, u8 opt)
+ {
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	dma_addr_t pd_dma;
+ 	struct port_database_24xx *pd;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	mbx_cmd_t mc;
+ 
+ 	if (!vha->hw->flags.fw_started)
+ 		goto done;
+ 
+ 	pd = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &pd_dma);
+ 	if (pd  == NULL) {
+ 		ql_log(ql_log_warn, vha, 0xd047,
+ 		    "Failed to allocate port database structure.\n");
+ 		goto done_free_sp;
+ 	}
+ 	memset(pd, 0, max(PORT_DATABASE_SIZE, PORT_DATABASE_24XX_SIZE));
+ 
+ 	memset(&mc, 0, sizeof(mc));
+ 	mc.mb[0] = MBC_GET_PORT_DATABASE;
+ 	mc.mb[1] = cpu_to_le16(fcport->loop_id);
+ 	mc.mb[2] = MSW(pd_dma);
+ 	mc.mb[3] = LSW(pd_dma);
+ 	mc.mb[6] = MSW(MSD(pd_dma));
+ 	mc.mb[7] = LSW(MSD(pd_dma));
+ 	mc.mb[9] = cpu_to_le16(vha->vp_idx);
+ 	mc.mb[10] = cpu_to_le16((uint16_t)opt);
+ 
+ 	rval = qla24xx_send_mb_cmd(vha, &mc);
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_dbg(ql_dbg_mbx, vha, 0x1193,
+ 		    "%s: %8phC fail\n", __func__, fcport->port_name);
+ 		goto done_free_sp;
+ 	}
+ 
+ 	rval = __qla24xx_parse_gpdb(vha, fcport, pd);
+ 
+ 	ql_dbg(ql_dbg_mbx, vha, 0x1197, "%s: %8phC done\n",
+ 	    __func__, fcport->port_name);
+ 
+ done_free_sp:
+ 	if (pd)
+ 		dma_pool_free(ha->s_dma_pool, pd, pd_dma);
+ done:
+ 	return rval;
+ }
+ 
+ int __qla24xx_parse_gpdb(struct scsi_qla_host *vha, fc_port_t *fcport,
+     struct port_database_24xx *pd)
+ {
+ 	int rval = QLA_SUCCESS;
+ 	uint64_t zero = 0;
+ 	u8 current_login_state, last_login_state;
+ 
+ 	if (fcport->fc4f_nvme) {
+ 		current_login_state = pd->current_login_state >> 4;
+ 		last_login_state = pd->last_login_state >> 4;
+ 	} else {
+ 		current_login_state = pd->current_login_state & 0xf;
+ 		last_login_state = pd->last_login_state & 0xf;
+ 	}
+ 
+ 	/* Check for logged in state. */
+ 	if (current_login_state != PDS_PRLI_COMPLETE &&
+ 	    last_login_state != PDS_PRLI_COMPLETE) {
+ 		ql_dbg(ql_dbg_mbx, vha, 0x119a,
+ 		    "Unable to verify login-state (%x/%x) for loop_id %x.\n",
+ 		    current_login_state, last_login_state, fcport->loop_id);
+ 		rval = QLA_FUNCTION_FAILED;
+ 		goto gpd_error_out;
+ 	}
+ 
+ 	if (fcport->loop_id == FC_NO_LOOP_ID ||
+ 	    (memcmp(fcport->port_name, (uint8_t *)&zero, 8) &&
+ 	     memcmp(fcport->port_name, pd->port_name, 8))) {
+ 		/* We lost the device mid way. */
+ 		rval = QLA_NOT_LOGGED_IN;
+ 		goto gpd_error_out;
+ 	}
+ 
+ 	/* Names are little-endian. */
+ 	memcpy(fcport->node_name, pd->node_name, WWN_SIZE);
+ 	memcpy(fcport->port_name, pd->port_name, WWN_SIZE);
+ 
+ 	/* Get port_id of device. */
+ 	fcport->d_id.b.domain = pd->port_id[0];
+ 	fcport->d_id.b.area = pd->port_id[1];
+ 	fcport->d_id.b.al_pa = pd->port_id[2];
+ 	fcport->d_id.b.rsvd_1 = 0;
+ 
+ 	if (fcport->fc4f_nvme) {
+ 		fcport->nvme_prli_service_param =
+ 		    pd->prli_nvme_svc_param_word_3;
+ 		fcport->port_type = FCT_NVME;
+ 	} else {
+ 		/* If not target must be initiator or unknown type. */
+ 		if ((pd->prli_svc_param_word_3[0] & BIT_4) == 0)
+ 			fcport->port_type = FCT_INITIATOR;
+ 		else
+ 			fcport->port_type = FCT_TARGET;
+ 	}
+ 	/* Passback COS information. */
+ 	fcport->supported_classes = (pd->flags & PDF_CLASS_2) ?
+ 		FC_COS_CLASS2 : FC_COS_CLASS3;
+ 
+ 	if (pd->prli_svc_param_word_3[0] & BIT_7) {
+ 		fcport->flags |= FCF_CONF_COMP_SUPPORTED;
+ 		fcport->conf_compl_supported = 1;
+ 	}
+ 
+ gpd_error_out:
+ 	return rval;
+ }
+ 
+ /*
+  * qla24xx_gidlist__wait
+  * NOTE: don't call this routine from DPC thread.
+  */
+ int qla24xx_gidlist_wait(struct scsi_qla_host *vha,
+ 	void *id_list, dma_addr_t id_list_dma, uint16_t *entries)
+ {
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	mbx_cmd_t mc;
+ 
+ 	if (!vha->hw->flags.fw_started)
+ 		goto done;
+ 
+ 	memset(&mc, 0, sizeof(mc));
+ 	mc.mb[0] = MBC_GET_ID_LIST;
+ 	mc.mb[2] = MSW(id_list_dma);
+ 	mc.mb[3] = LSW(id_list_dma);
+ 	mc.mb[6] = MSW(MSD(id_list_dma));
+ 	mc.mb[7] = LSW(MSD(id_list_dma));
+ 	mc.mb[8] = 0;
+ 	mc.mb[9] = cpu_to_le16(vha->vp_idx);
+ 
+ 	rval = qla24xx_send_mb_cmd(vha, &mc);
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_dbg(ql_dbg_mbx, vha, 0x119b,
+ 		    "%s:  fail\n", __func__);
+ 	} else {
+ 		*entries = mc.mb[1];
+ 		ql_dbg(ql_dbg_mbx, vha, 0x119c,
+ 		    "%s:  done\n", __func__);
+ 	}
+ done:
+ 	return rval;
+ }
++>>>>>>> a5d42f4cffa5 (scsi: qla2xxx: Add FC-NVMe port discovery and PRLI handling)
diff --cc drivers/scsi/qla2xxx/qla_os.c
index c724f888aca6,aee884d63e55..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -4124,11 -4422,30 +4124,16 @@@ struct scsi_qla_host *qla2x00_create_ho
  	INIT_LIST_HEAD(&vha->vp_fcports);
  	INIT_LIST_HEAD(&vha->work_list);
  	INIT_LIST_HEAD(&vha->list);
 -	INIT_LIST_HEAD(&vha->qla_cmd_list);
 -	INIT_LIST_HEAD(&vha->qla_sess_op_cmd_list);
 -	INIT_LIST_HEAD(&vha->logo_list);
 -	INIT_LIST_HEAD(&vha->plogi_ack_list);
  	INIT_LIST_HEAD(&vha->qp_list);
++<<<<<<< HEAD
++=======
+ 	INIT_LIST_HEAD(&vha->gnl.fcports);
+ 	INIT_LIST_HEAD(&vha->nvme_rport_list);
++>>>>>>> a5d42f4cffa5 (scsi: qla2xxx: Add FC-NVMe port discovery and PRLI handling)
  
  	spin_lock_init(&vha->work_lock);
 -	spin_lock_init(&vha->cmd_list_lock);
 -	init_waitqueue_head(&vha->fcport_waitQ);
  	init_waitqueue_head(&vha->vref_waitq);
  
 -	vha->gnl.size = sizeof(struct get_name_list_extended) *
 -			(ha->max_loop_id + 1);
 -	vha->gnl.l = dma_alloc_coherent(&ha->pdev->dev,
 -	    vha->gnl.size, &vha->gnl.ldma, GFP_KERNEL);
 -	if (!vha->gnl.l) {
 -		ql_log(ql_log_fatal, vha, 0xd04a,
 -		    "Alloc failed for name list.\n");
 -		scsi_remove_host(vha->host);
 -		return NULL;
 -	}
 -
  	sprintf(vha->host_str, "%s_%ld", QLA2XXX_DRIVER_NAME, vha->host_no);
  	ql_dbg(ql_dbg_init, vha, 0x0041,
  	    "Allocated the host=%p hw=%p vha=%p dev_name=%s",
@@@ -4328,6 -4702,37 +4333,40 @@@ qla2x00_do_work(struct scsi_qla_host *v
  		case QLA_EVT_AENFX:
  			qlafx00_process_aen(vha, e);
  			break;
++<<<<<<< HEAD
++=======
+ 		case QLA_EVT_GIDPN:
+ 			qla24xx_async_gidpn(vha, e->u.fcport.fcport);
+ 			break;
+ 		case QLA_EVT_GPNID:
+ 			qla24xx_async_gpnid(vha, &e->u.gpnid.id);
+ 			break;
+ 		case QLA_EVT_GPNID_DONE:
+ 			qla24xx_async_gpnid_done(vha, e->u.iosb.sp);
+ 			break;
+ 		case QLA_EVT_NEW_SESS:
+ 			qla24xx_create_new_sess(vha, e);
+ 			break;
+ 		case QLA_EVT_GPDB:
+ 			qla24xx_async_gpdb(vha, e->u.fcport.fcport,
+ 			    e->u.fcport.opt);
+ 			break;
+ 		case QLA_EVT_PRLI:
+ 			qla24xx_async_prli(vha, e->u.fcport.fcport);
+ 			break;
+ 		case QLA_EVT_GPSC:
+ 			qla24xx_async_gpsc(vha, e->u.fcport.fcport);
+ 			break;
+ 		case QLA_EVT_UPD_FCPORT:
+ 			qla2x00_update_fcport(vha, e->u.fcport.fcport);
+ 			break;
+ 		case QLA_EVT_GNL:
+ 			qla24xx_async_gnl(vha, e->u.fcport.fcport);
+ 			break;
+ 		case QLA_EVT_NACK:
+ 			qla24xx_do_nack_work(vha, e);
+ 			break;
++>>>>>>> a5d42f4cffa5 (scsi: qla2xxx: Add FC-NVMe port discovery and PRLI handling)
  		}
  		if (e->flags & QLA_EVT_FLAG_FREE)
  			kfree(e);
diff --cc drivers/scsi/qla2xxx/qla_target.c
index 4244f37d5d93,2a0173e5d10e..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -340,38 -950,176 +340,78 @@@ static void qlt_free_session_done(struc
  	struct qla_tgt *tgt = sess->tgt;
  	struct scsi_qla_host *vha = sess->vha;
  	struct qla_hw_data *ha = vha->hw;
++<<<<<<< HEAD
++=======
+ 	unsigned long flags;
+ 	bool logout_started = false;
+ 	struct event_arg ea;
+ 	scsi_qla_host_t *base_vha;
+ 
+ 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf084,
+ 		"%s: se_sess %p / sess %p from port %8phC loop_id %#04x"
+ 		" s_id %02x:%02x:%02x logout %d keep %d els_logo %d\n",
+ 		__func__, sess->se_sess, sess, sess->port_name, sess->loop_id,
+ 		sess->d_id.b.domain, sess->d_id.b.area, sess->d_id.b.al_pa,
+ 		sess->logout_on_delete, sess->keep_nport_handle,
+ 		sess->send_els_logo);
+ 
+ 	if (!IS_SW_RESV_ADDR(sess->d_id)) {
+ 		if (sess->send_els_logo) {
+ 			qlt_port_logo_t logo;
+ 
+ 			logo.id = sess->d_id;
+ 			logo.cmd_count = 0;
+ 			qlt_send_first_logo(vha, &logo);
+ 		}
+ 
+ 		if (sess->logout_on_delete) {
+ 			int rc;
+ 
+ 			rc = qla2x00_post_async_logout_work(vha, sess, NULL);
+ 			if (rc != QLA_SUCCESS)
+ 				ql_log(ql_log_warn, vha, 0xf085,
+ 				    "Schedule logo failed sess %p rc %d\n",
+ 				    sess, rc);
+ 			else
+ 				logout_started = true;
+ 		}
+ 	}
++>>>>>>> a5d42f4cffa5 (scsi: qla2xxx: Add FC-NVMe port discovery and PRLI handling)
  
 +	BUG_ON(!tgt);
  	/*
  	 * Release the target session for FC Nexus from fabric module code.
  	 */
  	if (sess->se_sess != NULL)
  		ha->tgt.tgt_ops->free_session(sess);
  
 -	if (logout_started) {
 -		bool traced = false;
 +	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf001,
 +	    "Unregistration of sess %p finished\n", sess);
  
 -		while (!ACCESS_ONCE(sess->logout_completed)) {
 -			if (!traced) {
 -				ql_dbg(ql_dbg_tgt_mgt, vha, 0xf086,
 -					"%s: waiting for sess %p logout\n",
 -					__func__, sess);
 -				traced = true;
 -			}
 -			msleep(100);
 -		}
 +	kfree(sess);
 +	/*
 +	 * We need to protect against race, when tgt is freed before or
 +	 * inside wake_up()
 +	 */
 +	tgt->sess_count--;
 +	if (tgt->sess_count == 0)
 +		wake_up_all(&tgt->waitQ);
 +}
  
 -		ql_dbg(ql_dbg_disc, vha, 0xf087,
 -		    "%s: sess %p logout completed\n",__func__, sess);
 -	}
 +/* ha->hardware_lock supposed to be held on entry */
 +void qlt_unreg_sess(struct qla_tgt_sess *sess)
 +{
 +	struct scsi_qla_host *vha = sess->vha;
  
 -	if (sess->logo_ack_needed) {
 -		sess->logo_ack_needed = 0;
 -		qla24xx_async_notify_ack(vha, sess,
 -			(struct imm_ntfy_from_isp *)sess->iocb, SRB_NACK_LOGO);
 -	}
 +	vha->hw->tgt.tgt_ops->clear_nacl_from_fcport_map(sess);
  
 -	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
 -	if (sess->se_sess) {
 -		sess->se_sess = NULL;
 -		if (tgt && !IS_SW_RESV_ADDR(sess->d_id))
 -			tgt->sess_count--;
 -	}
 -
 -	sess->disc_state = DSC_DELETED;
 -	sess->fw_login_state = DSC_LS_PORT_UNAVAIL;
 -	sess->deleted = QLA_SESS_DELETED;
 -	sess->login_retry = vha->hw->login_retry_count;
 -
 -	if (sess->login_succ && !IS_SW_RESV_ADDR(sess->d_id)) {
 -		vha->fcport_count--;
 -		sess->login_succ = 0;
 -	}
 -
 -	if (sess->chip_reset != ha->base_qpair->chip_reset)
 -		qla2x00_clear_loop_id(sess);
 -
 -	if (sess->conflict) {
 -		sess->conflict->login_pause = 0;
 -		sess->conflict = NULL;
 -		if (!test_bit(UNLOADING, &vha->dpc_flags))
 -			set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
 -	}
 -
 -	{
 -		struct qlt_plogi_ack_t *own =
 -		    sess->plogi_link[QLT_PLOGI_LINK_SAME_WWN];
 -		struct qlt_plogi_ack_t *con =
 -		    sess->plogi_link[QLT_PLOGI_LINK_CONFLICT];
 -		struct imm_ntfy_from_isp *iocb;
 -
 -		if (con) {
 -			iocb = &con->iocb;
 -			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf099,
 -				 "se_sess %p / sess %p port %8phC is gone,"
 -				 " %s (ref=%d), releasing PLOGI for %8phC (ref=%d)\n",
 -				 sess->se_sess, sess, sess->port_name,
 -				 own ? "releasing own PLOGI" : "no own PLOGI pending",
 -				 own ? own->ref_count : -1,
 -				 iocb->u.isp24.port_name, con->ref_count);
 -			qlt_plogi_ack_unref(vha, con);
 -			sess->plogi_link[QLT_PLOGI_LINK_CONFLICT] = NULL;
 -		} else {
 -			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf09a,
 -			    "se_sess %p / sess %p port %8phC is gone, %s (ref=%d)\n",
 -			    sess->se_sess, sess, sess->port_name,
 -			    own ? "releasing own PLOGI" :
 -			    "no own PLOGI pending",
 -			    own ? own->ref_count : -1);
 -		}
 -
 -		if (own) {
 -			sess->fw_login_state = DSC_LS_PLOGI_PEND;
 -			qlt_plogi_ack_unref(vha, own);
 -			sess->plogi_link[QLT_PLOGI_LINK_SAME_WWN] = NULL;
 -		}
 -	}
 -	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
 -
 -	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf001,
 -	    "Unregistration of sess %p %8phC finished fcp_cnt %d\n",
 -		sess, sess->port_name, vha->fcport_count);
 -
 -	if (tgt && (tgt->sess_count == 0))
 -		wake_up_all(&tgt->waitQ);
 -
 -	if (vha->fcport_count == 0)
 -		wake_up_all(&vha->fcport_waitQ);
 -
 -	base_vha = pci_get_drvdata(ha->pdev);
 -	if (test_bit(PFLG_DRIVER_REMOVING, &base_vha->pci_flags))
 -		return;
 -
 -	if (!tgt || !tgt->tgt_stop) {
 -		memset(&ea, 0, sizeof(ea));
 -		ea.event = FCME_DELETE_DONE;
 -		ea.fcport = sess;
 -		qla2x00_fcport_event_handler(vha, &ea);
 -	}
 -}
 -
 -/* ha->tgt.sess_lock supposed to be held on entry */
 -void qlt_unreg_sess(struct fc_port *sess)
 -{
 -	struct scsi_qla_host *vha = sess->vha;
 -
 -	ql_dbg(ql_dbg_disc, sess->vha, 0x210a,
 -	    "%s sess %p for deletion %8phC\n",
 -	    __func__, sess, sess->port_name);
 -
 -	if (sess->se_sess)
 -		vha->hw->tgt.tgt_ops->clear_nacl_from_fcport_map(sess);
 -
 -	qla2x00_mark_device_lost(vha, sess, 1, 1);
 -
 -	sess->deleted = QLA_SESS_DELETION_IN_PROGRESS;
 -	sess->disc_state = DSC_DELETE_PEND;
 -	sess->last_rscn_gen = sess->rscn_gen;
 -	sess->last_login_gen = sess->login_gen;
 +	list_del(&sess->sess_list_entry);
 +	if (sess->deleted)
 +		list_del(&sess->del_list_entry);
  
+ 	if (sess->nvme_flag & NVME_FLAG_REGISTERED)
+ 		schedule_work(&sess->nvme_del_work);
+ 
  	INIT_WORK(&sess->free_work, qlt_free_session_done);
  	schedule_work(&sess->free_work);
  }
* Unmerged path drivers/scsi/qla2xxx/qla_dbg.c
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
diff --git a/drivers/scsi/qla2xxx/qla_fw.h b/drivers/scsi/qla2xxx/qla_fw.h
index 8a2368b32dec..a661b8d12553 100644
--- a/drivers/scsi/qla2xxx/qla_fw.h
+++ b/drivers/scsi/qla2xxx/qla_fw.h
@@ -37,6 +37,12 @@ struct port_database_24xx {
 #define PDF_CLASS_2		BIT_4
 #define PDF_HARD_ADDR		BIT_1
 
+	/*
+	 * for NVMe, the login_state field has been
+	 * split into nibbles.
+	 * The lower nibble is for FCP.
+	 * The upper nibble is for NVMe.
+	 */
 	uint8_t current_login_state;
 	uint8_t last_login_state;
 #define PDS_PLOGI_PENDING	0x03
@@ -69,7 +75,11 @@ struct port_database_24xx {
 	uint8_t port_name[WWN_SIZE];
 	uint8_t node_name[WWN_SIZE];
 
-	uint8_t reserved_3[24];
+	uint8_t reserved_3[4];
+	uint16_t prli_nvme_svc_param_word_0;	/* Bits 15-0 of word 0 */
+	uint16_t prli_nvme_svc_param_word_3;	/* Bits 15-0 of word 3 */
+	uint16_t nvme_first_burst_size;
+	uint8_t reserved_4[14];
 };
 
 struct vp_database_24xx {
@@ -788,6 +798,7 @@ struct logio_entry_24xx {
 #define LCF_CLASS_2		BIT_8	/* Enable class 2 during PLOGI. */
 #define LCF_FREE_NPORT		BIT_7	/* Release NPORT handle after LOGO. */
 #define LCF_EXPL_LOGO		BIT_6	/* Perform an explicit LOGO. */
+#define LCF_NVME_PRLI		BIT_6   /* Perform NVME FC4 PRLI */
 #define LCF_SKIP_PRLI		BIT_5	/* Skip PRLI after PLOGI. */
 #define LCF_IMPL_LOGO_ALL	BIT_5	/* Implicit LOGO to all ports. */
 #define LCF_COND_PLOGI		BIT_4	/* PLOGI only if not logged-in. */
* Unmerged path drivers/scsi/qla2xxx/qla_gbl.h
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
diff --git a/drivers/scsi/qla2xxx/qla_iocb.c b/drivers/scsi/qla2xxx/qla_iocb.c
index ff2ecaf39d3d..2b23cef215b5 100644
--- a/drivers/scsi/qla2xxx/qla_iocb.c
+++ b/drivers/scsi/qla2xxx/qla_iocb.c
@@ -2170,6 +2170,23 @@ queuing_error:
 	return pkt;
 }
 
+static void
+qla24xx_prli_iocb(srb_t *sp, struct logio_entry_24xx *logio)
+{
+	struct srb_iocb *lio = &sp->u.iocb_cmd;
+
+	logio->entry_type = LOGINOUT_PORT_IOCB_TYPE;
+	logio->control_flags = cpu_to_le16(LCF_COMMAND_PRLI);
+	if (lio->u.logio.flags & SRB_LOGIN_NVME_PRLI)
+		logio->control_flags |= LCF_NVME_PRLI;
+
+	logio->nport_handle = cpu_to_le16(sp->fcport->loop_id);
+	logio->port_id[0] = sp->fcport->d_id.b.al_pa;
+	logio->port_id[1] = sp->fcport->d_id.b.area;
+	logio->port_id[2] = sp->fcport->d_id.b.domain;
+	logio->vp_index = sp->vha->vp_idx;
+}
+
 static void
 qla24xx_login_iocb(srb_t *sp, struct logio_entry_24xx *logio)
 {
@@ -2177,6 +2194,7 @@ qla24xx_login_iocb(srb_t *sp, struct logio_entry_24xx *logio)
 
 	logio->entry_type = LOGINOUT_PORT_IOCB_TYPE;
 	logio->control_flags = cpu_to_le16(LCF_COMMAND_PLOGI);
+
 	if (lio->u.logio.flags & SRB_LOGIN_COND_PLOGI)
 		logio->control_flags |= cpu_to_le16(LCF_COND_PLOGI);
 	if (lio->u.logio.flags & SRB_LOGIN_SKIP_PRLI)
@@ -2917,6 +2935,9 @@ qla2x00_start_sp(srb_t *sp)
 		    qla24xx_login_iocb(sp, pkt) :
 		    qla2x00_login_iocb(sp, pkt);
 		break;
+	case SRB_PRLI_CMD:
+		qla24xx_prli_iocb(sp, pkt);
+		break;
 	case SRB_LOGOUT_CMD:
 		IS_FWI2_CAPABLE(ha) ?
 		    qla24xx_logout_iocb(sp, pkt) :
* Unmerged path drivers/scsi/qla2xxx/qla_mbx.c
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
