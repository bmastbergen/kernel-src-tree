nvme: Adjust the Samsung APST quirk

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [nvme] Adjust the Samsung APST quirk (David Milburn) [1389600]
Rebuild_FUZZ: 90.62%
commit-author Andy Lutomirski <luto@kernel.org>
commit ff5350a86b20de23991e474e006e2ff2732b218e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ff5350a8.failed

I got a couple more reports: the Samsung APST issues appears to
affect multiple 950-series devices in Dell XPS 15 9550 and Precision
5510 laptops.  Change the quirk: rather than blacklisting the
firmware on the first problematic SSD that was reported, disable
APST on all 144d:a802 devices if they're installed in the two
affected Dell models.  While we're at it, disable only the deepest
sleep state instead of all of them -- the reporters say that this is
sufficient to fix the problem.

(I have a device that appears to be entirely identical to one of the
affected devices, but I have a different Dell laptop, so it's not
the case that all Samsung devices with firmware BXW75D0Q are broken
under all circumstances.)

Samsung engineers have an affected system, and hopefully they'll
give us a better workaround some time soon.  In the mean time, this
should minimize regressions.

See https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1678184

	Cc: Kai-Heng Feng <kai.heng.feng@canonical.com>
	Signed-off-by: Andy Lutomirski <luto@kernel.org>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit ff5350a86b20de23991e474e006e2ff2732b218e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
#	drivers/nvme/host/nvme.h
diff --cc drivers/nvme/host/core.c
index bd223cb63595,00b2818dac31..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -1162,9 -1252,178 +1162,182 @@@ static void nvme_set_queue_limits(struc
  	}
  	if (ctrl->quirks & NVME_QUIRK_STRIPE_SIZE)
  		blk_queue_chunk_sectors(q, ctrl->max_hw_sectors);
 -	blk_queue_virt_boundary(q, ctrl->page_size - 1);
  	if (ctrl->vwc & NVME_CTRL_VWC_PRESENT)
++<<<<<<< HEAD
 +		blk_queue_flush(q, REQ_FLUSH | REQ_FUA);
 +	blk_queue_virt_boundary(q, ctrl->page_size - 1);
++=======
+ 		vwc = true;
+ 	blk_queue_write_cache(q, vwc, vwc);
+ }
+ 
+ static void nvme_configure_apst(struct nvme_ctrl *ctrl)
+ {
+ 	/*
+ 	 * APST (Autonomous Power State Transition) lets us program a
+ 	 * table of power state transitions that the controller will
+ 	 * perform automatically.  We configure it with a simple
+ 	 * heuristic: we are willing to spend at most 2% of the time
+ 	 * transitioning between power states.  Therefore, when running
+ 	 * in any given state, we will enter the next lower-power
+ 	 * non-operational state after waiting 100 * (enlat + exlat)
+ 	 * microseconds, as long as that state's total latency is under
+ 	 * the requested maximum latency.
+ 	 *
+ 	 * We will not autonomously enter any non-operational state for
+ 	 * which the total latency exceeds ps_max_latency_us.  Users
+ 	 * can set ps_max_latency_us to zero to turn off APST.
+ 	 */
+ 
+ 	unsigned apste;
+ 	struct nvme_feat_auto_pst *table;
+ 	int ret;
+ 
+ 	/*
+ 	 * If APST isn't supported or if we haven't been initialized yet,
+ 	 * then don't do anything.
+ 	 */
+ 	if (!ctrl->apsta)
+ 		return;
+ 
+ 	if (ctrl->npss > 31) {
+ 		dev_warn(ctrl->device, "NPSS is invalid; not using APST\n");
+ 		return;
+ 	}
+ 
+ 	table = kzalloc(sizeof(*table), GFP_KERNEL);
+ 	if (!table)
+ 		return;
+ 
+ 	if (ctrl->ps_max_latency_us == 0) {
+ 		/* Turn off APST. */
+ 		apste = 0;
+ 	} else {
+ 		__le64 target = cpu_to_le64(0);
+ 		int state;
+ 
+ 		/*
+ 		 * Walk through all states from lowest- to highest-power.
+ 		 * According to the spec, lower-numbered states use more
+ 		 * power.  NPSS, despite the name, is the index of the
+ 		 * lowest-power state, not the number of states.
+ 		 */
+ 		for (state = (int)ctrl->npss; state >= 0; state--) {
+ 			u64 total_latency_us, transition_ms;
+ 
+ 			if (target)
+ 				table->entries[state] = target;
+ 
+ 			/*
+ 			 * Don't allow transitions to the deepest state
+ 			 * if it's quirked off.
+ 			 */
+ 			if (state == ctrl->npss &&
+ 			    (ctrl->quirks & NVME_QUIRK_NO_DEEPEST_PS))
+ 				continue;
+ 
+ 			/*
+ 			 * Is this state a useful non-operational state for
+ 			 * higher-power states to autonomously transition to?
+ 			 */
+ 			if (!(ctrl->psd[state].flags &
+ 			      NVME_PS_FLAGS_NON_OP_STATE))
+ 				continue;
+ 
+ 			total_latency_us =
+ 				(u64)le32_to_cpu(ctrl->psd[state].entry_lat) +
+ 				+ le32_to_cpu(ctrl->psd[state].exit_lat);
+ 			if (total_latency_us > ctrl->ps_max_latency_us)
+ 				continue;
+ 
+ 			/*
+ 			 * This state is good.  Use it as the APST idle
+ 			 * target for higher power states.
+ 			 */
+ 			transition_ms = total_latency_us + 19;
+ 			do_div(transition_ms, 20);
+ 			if (transition_ms > (1 << 24) - 1)
+ 				transition_ms = (1 << 24) - 1;
+ 
+ 			target = cpu_to_le64((state << 3) |
+ 					     (transition_ms << 8));
+ 		}
+ 
+ 		apste = 1;
+ 	}
+ 
+ 	ret = nvme_set_features(ctrl, NVME_FEAT_AUTO_PST, apste,
+ 				table, sizeof(*table), NULL);
+ 	if (ret)
+ 		dev_err(ctrl->device, "failed to set APST feature (%d)\n", ret);
+ 
+ 	kfree(table);
+ }
+ 
+ static void nvme_set_latency_tolerance(struct device *dev, s32 val)
+ {
+ 	struct nvme_ctrl *ctrl = dev_get_drvdata(dev);
+ 	u64 latency;
+ 
+ 	switch (val) {
+ 	case PM_QOS_LATENCY_TOLERANCE_NO_CONSTRAINT:
+ 	case PM_QOS_LATENCY_ANY:
+ 		latency = U64_MAX;
+ 		break;
+ 
+ 	default:
+ 		latency = val;
+ 	}
+ 
+ 	if (ctrl->ps_max_latency_us != latency) {
+ 		ctrl->ps_max_latency_us = latency;
+ 		nvme_configure_apst(ctrl);
+ 	}
+ }
+ 
+ struct nvme_core_quirk_entry {
+ 	/*
+ 	 * NVMe model and firmware strings are padded with spaces.  For
+ 	 * simplicity, strings in the quirk table are padded with NULLs
+ 	 * instead.
+ 	 */
+ 	u16 vid;
+ 	const char *mn;
+ 	const char *fr;
+ 	unsigned long quirks;
+ };
+ 
+ static const struct nvme_core_quirk_entry core_quirks[] = {
+ };
+ 
+ /* match is null-terminated but idstr is space-padded. */
+ static bool string_matches(const char *idstr, const char *match, size_t len)
+ {
+ 	size_t matchlen;
+ 
+ 	if (!match)
+ 		return true;
+ 
+ 	matchlen = strlen(match);
+ 	WARN_ON_ONCE(matchlen > len);
+ 
+ 	if (memcmp(idstr, match, matchlen))
+ 		return false;
+ 
+ 	for (; matchlen < len; matchlen++)
+ 		if (idstr[matchlen] != ' ')
+ 			return false;
+ 
+ 	return true;
+ }
+ 
+ static bool quirk_matches(const struct nvme_id_ctrl *id,
+ 			  const struct nvme_core_quirk_entry *q)
+ {
+ 	return q->vid == le16_to_cpu(id->vid) &&
+ 		string_matches(id->mn, q->mn, sizeof(id->mn)) &&
+ 		string_matches(id->fr, q->fr, sizeof(id->fr));
++>>>>>>> ff5350a86b20 (nvme: Adjust the Samsung APST quirk)
  }
  
  /*
diff --cc drivers/nvme/host/nvme.h
index edb3488b21b7,ab2d6ec7eb5c..000000000000
--- a/drivers/nvme/host/nvme.h
+++ b/drivers/nvme/host/nvme.h
@@@ -72,6 -78,16 +72,19 @@@ enum nvme_quirks 
  	 * readiness, which is done by reading the NVME_CSTS_RDY bit.
  	 */
  	NVME_QUIRK_DELAY_BEFORE_CHK_RDY		= (1 << 3),
++<<<<<<< HEAD
++=======
+ 
+ 	/*
+ 	 * APST should not be used.
+ 	 */
+ 	NVME_QUIRK_NO_APST			= (1 << 4),
+ 
+ 	/*
+ 	 * The deepest sleep state should not be used.
+ 	 */
+ 	NVME_QUIRK_NO_DEEPEST_PS		= (1 << 5),
++>>>>>>> ff5350a86b20 (nvme: Adjust the Samsung APST quirk)
  };
  
  /*
* Unmerged path drivers/nvme/host/core.c
* Unmerged path drivers/nvme/host/nvme.h
diff --git a/drivers/nvme/host/pci.c b/drivers/nvme/host/pci.c
index 20d5219150f0..29b3f4278497 100644
--- a/drivers/nvme/host/pci.c
+++ b/drivers/nvme/host/pci.c
@@ -19,6 +19,7 @@
 #include <linux/blk-mq-pci.h>
 #include <linux/cpu.h>
 #include <linux/delay.h>
+#include <linux/dmi.h>
 #include <linux/errno.h>
 #include <linux/fs.h>
 #include <linux/genhd.h>
@@ -1830,10 +1831,31 @@ static int nvme_dev_map(struct nvme_dev *dev)
        return -ENODEV;
 }
 
+static unsigned long check_dell_samsung_bug(struct pci_dev *pdev)
+{
+	if (pdev->vendor == 0x144d && pdev->device == 0xa802) {
+		/*
+		 * Several Samsung devices seem to drop off the PCIe bus
+		 * randomly when APST is on and uses the deepest sleep state.
+		 * This has been observed on a Samsung "SM951 NVMe SAMSUNG
+		 * 256GB", a "PM951 NVMe SAMSUNG 512GB", and a "Samsung SSD
+		 * 950 PRO 256GB", but it seems to be restricted to two Dell
+		 * laptops.
+		 */
+		if (dmi_match(DMI_SYS_VENDOR, "Dell Inc.") &&
+		    (dmi_match(DMI_PRODUCT_NAME, "XPS 15 9550") ||
+		     dmi_match(DMI_PRODUCT_NAME, "Precision 5510")))
+			return NVME_QUIRK_NO_DEEPEST_PS;
+	}
+
+	return 0;
+}
+
 static int nvme_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 {
 	int node, result = -ENOMEM;
 	struct nvme_dev *dev;
+	unsigned long quirks = id->driver_data;
 
 	node = dev_to_node(&pdev->dev);
 	if (node == NUMA_NO_NODE)
@@ -1865,8 +1887,10 @@ static int nvme_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	if (result)
 		goto put_pci;
 
+	quirks |= check_dell_samsung_bug(pdev);
+
 	result = nvme_init_ctrl(&dev->ctrl, &pdev->dev, &nvme_pci_ctrl_ops,
-			id->driver_data);
+			quirks);
 	if (result)
 		goto release_pools;
 
