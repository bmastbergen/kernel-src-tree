netfilter: reduce direct skb->nfct usage

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Florian Westphal <fw@strlen.de>
commit 97a6ad13decc16c5adbf181283932daba7e17faf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/97a6ad13.failed

Next patch makes direct skb->nfct access illegal, reduce noise
in next patch by using accessors we already have.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 97a6ad13decc16c5adbf181283932daba7e17faf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_conntrack_core.c
diff --cc net/netfilter/nf_conntrack_core.c
index 5140736f7cea,adb7af3a4c4c..000000000000
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@@ -614,6 -641,66 +614,69 @@@ out
  }
  EXPORT_SYMBOL_GPL(nf_conntrack_hash_check_insert);
  
++<<<<<<< HEAD
++=======
+ static inline void nf_ct_acct_update(struct nf_conn *ct,
+ 				     enum ip_conntrack_info ctinfo,
+ 				     unsigned int len)
+ {
+ 	struct nf_conn_acct *acct;
+ 
+ 	acct = nf_conn_acct_find(ct);
+ 	if (acct) {
+ 		struct nf_conn_counter *counter = acct->counter;
+ 
+ 		atomic64_inc(&counter[CTINFO2DIR(ctinfo)].packets);
+ 		atomic64_add(len, &counter[CTINFO2DIR(ctinfo)].bytes);
+ 	}
+ }
+ 
+ static void nf_ct_acct_merge(struct nf_conn *ct, enum ip_conntrack_info ctinfo,
+ 			     const struct nf_conn *loser_ct)
+ {
+ 	struct nf_conn_acct *acct;
+ 
+ 	acct = nf_conn_acct_find(loser_ct);
+ 	if (acct) {
+ 		struct nf_conn_counter *counter = acct->counter;
+ 		unsigned int bytes;
+ 
+ 		/* u32 should be fine since we must have seen one packet. */
+ 		bytes = atomic64_read(&counter[CTINFO2DIR(ctinfo)].bytes);
+ 		nf_ct_acct_update(ct, ctinfo, bytes);
+ 	}
+ }
+ 
+ /* Resolve race on insertion if this protocol allows this. */
+ static int nf_ct_resolve_clash(struct net *net, struct sk_buff *skb,
+ 			       enum ip_conntrack_info ctinfo,
+ 			       struct nf_conntrack_tuple_hash *h)
+ {
+ 	/* This is the conntrack entry already in hashes that won race. */
+ 	struct nf_conn *ct = nf_ct_tuplehash_to_ctrack(h);
+ 	struct nf_conntrack_l4proto *l4proto;
+ 
+ 	l4proto = __nf_ct_l4proto_find(nf_ct_l3num(ct), nf_ct_protonum(ct));
+ 	if (l4proto->allow_clash &&
+ 	    !nfct_nat(ct) &&
+ 	    !nf_ct_is_dying(ct) &&
+ 	    atomic_inc_not_zero(&ct->ct_general.use)) {
+ 		enum ip_conntrack_info oldinfo;
+ 		struct nf_conn *loser_ct = nf_ct_get(skb, &oldinfo);
+ 
+ 		nf_ct_acct_merge(ct, ctinfo, loser_ct);
+ 		nf_conntrack_put(&loser_ct->ct_general);
+ 		/* Assign conntrack already in hashes to this skbuff. Don't
+ 		 * modify skb->nfctinfo to ensure consistent stateful filtering.
+ 		 */
+ 		skb->nfct = &ct->ct_general;
+ 		return NF_ACCEPT;
+ 	}
+ 	NF_CT_STAT_INC(net, drop);
+ 	return NF_DROP;
+ }
+ 
++>>>>>>> 97a6ad13decc (netfilter: reduce direct skb->nfct usage)
  /* Confirm a connection given skb; places it in hash table */
  int
  __nf_conntrack_confirm(struct sk_buff *skb)
diff --git a/include/net/ip_vs.h b/include/net/ip_vs.h
index e1599adc052f..9b92ee442f57 100644
--- a/include/net/ip_vs.h
+++ b/include/net/ip_vs.h
@@ -1539,10 +1539,13 @@ static inline void ip_vs_notrack(struct sk_buff *skb)
 	struct nf_conn *ct = nf_ct_get(skb, &ctinfo);
 
 	if (!ct || !nf_ct_is_untracked(ct)) {
-		nf_conntrack_put(skb->nfct);
-		skb->nfct = &nf_ct_untracked_get()->ct_general;
+		struct nf_conn *untracked;
+
+		nf_conntrack_put(&ct->ct_general);
+		untracked = nf_ct_untracked_get();
+		nf_conntrack_get(&untracked->ct_general);
+		skb->nfct = &untracked->ct_general;
 		skb->nfctinfo = IP_CT_NEW;
-		nf_conntrack_get(skb->nfct);
 	}
 #endif
 }
* Unmerged path net/netfilter/nf_conntrack_core.c
