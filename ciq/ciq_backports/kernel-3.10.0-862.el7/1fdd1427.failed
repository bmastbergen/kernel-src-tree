scsi: scsi_dh_alua: fix missing kref_put() in alua_rtpg_work()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] scsi_dh_alua: fix missing kref_put() in alua_rtpg_work() (Mike Snitzer) [1499107]
Rebuild_FUZZ: 94.92%
commit-author tang.junhui <tang.junhui@zte.com.cn>
commit 1fdd14279eab2e9f79745631379f0c53cb8f9a5a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1fdd1427.failed

Reference count of pg leaks in alua_rtpg_work() since kref_put() is not
called to decrease the reference count of pg when the condition
pg->rtpg_sdev==NULL satisfied (actually it is easy to satisfy), it would
cause memory of pg leakage.

	Signed-off-by: tang.junhui <tang.junhui@zte.com.cn>
	Cc: <stable@vger.kernel.org>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 1fdd14279eab2e9f79745631379f0c53cb8f9a5a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/device_handler/scsi_dh_alua.c
diff --cc drivers/scsi/device_handler/scsi_dh_alua.c
index 2f054f24112a,f375167f16ea..000000000000
--- a/drivers/scsi/device_handler/scsi_dh_alua.c
+++ b/drivers/scsi/device_handler/scsi_dh_alua.c
@@@ -541,6 -776,137 +541,140 @@@ static unsigned alua_stpg(struct scsi_d
  	return SCSI_DH_RETRY;
  }
  
++<<<<<<< HEAD
++=======
+ static void alua_rtpg_work(struct work_struct *work)
+ {
+ 	struct alua_port_group *pg =
+ 		container_of(work, struct alua_port_group, rtpg_work.work);
+ 	struct scsi_device *sdev;
+ 	LIST_HEAD(qdata_list);
+ 	int err = SCSI_DH_OK;
+ 	struct alua_queue_data *qdata, *tmp;
+ 	unsigned long flags;
+ 	struct workqueue_struct *alua_wq = kaluad_wq;
+ 
+ 	spin_lock_irqsave(&pg->lock, flags);
+ 	sdev = pg->rtpg_sdev;
+ 	if (!sdev) {
+ 		WARN_ON(pg->flags & ALUA_PG_RUN_RTPG);
+ 		WARN_ON(pg->flags & ALUA_PG_RUN_STPG);
+ 		spin_unlock_irqrestore(&pg->lock, flags);
+ 		kref_put(&pg->kref, release_port_group);
+ 		return;
+ 	}
+ 	if (pg->flags & ALUA_SYNC_STPG)
+ 		alua_wq = kaluad_sync_wq;
+ 	pg->flags |= ALUA_PG_RUNNING;
+ 	if (pg->flags & ALUA_PG_RUN_RTPG) {
+ 		int state = pg->state;
+ 
+ 		pg->flags &= ~ALUA_PG_RUN_RTPG;
+ 		spin_unlock_irqrestore(&pg->lock, flags);
+ 		if (state == SCSI_ACCESS_STATE_TRANSITIONING) {
+ 			if (alua_tur(sdev) == SCSI_DH_RETRY) {
+ 				spin_lock_irqsave(&pg->lock, flags);
+ 				pg->flags &= ~ALUA_PG_RUNNING;
+ 				pg->flags |= ALUA_PG_RUN_RTPG;
+ 				spin_unlock_irqrestore(&pg->lock, flags);
+ 				queue_delayed_work(alua_wq, &pg->rtpg_work,
+ 						   pg->interval * HZ);
+ 				return;
+ 			}
+ 			/* Send RTPG on failure or if TUR indicates SUCCESS */
+ 		}
+ 		err = alua_rtpg(sdev, pg);
+ 		spin_lock_irqsave(&pg->lock, flags);
+ 		if (err == SCSI_DH_RETRY || pg->flags & ALUA_PG_RUN_RTPG) {
+ 			pg->flags &= ~ALUA_PG_RUNNING;
+ 			pg->flags |= ALUA_PG_RUN_RTPG;
+ 			spin_unlock_irqrestore(&pg->lock, flags);
+ 			queue_delayed_work(alua_wq, &pg->rtpg_work,
+ 					   pg->interval * HZ);
+ 			return;
+ 		}
+ 		if (err != SCSI_DH_OK)
+ 			pg->flags &= ~ALUA_PG_RUN_STPG;
+ 	}
+ 	if (pg->flags & ALUA_PG_RUN_STPG) {
+ 		pg->flags &= ~ALUA_PG_RUN_STPG;
+ 		spin_unlock_irqrestore(&pg->lock, flags);
+ 		err = alua_stpg(sdev, pg);
+ 		spin_lock_irqsave(&pg->lock, flags);
+ 		if (err == SCSI_DH_RETRY || pg->flags & ALUA_PG_RUN_RTPG) {
+ 			pg->flags |= ALUA_PG_RUN_RTPG;
+ 			pg->interval = 0;
+ 			pg->flags &= ~ALUA_PG_RUNNING;
+ 			spin_unlock_irqrestore(&pg->lock, flags);
+ 			queue_delayed_work(alua_wq, &pg->rtpg_work,
+ 					   pg->interval * HZ);
+ 			return;
+ 		}
+ 	}
+ 
+ 	list_splice_init(&pg->rtpg_list, &qdata_list);
+ 	pg->rtpg_sdev = NULL;
+ 	spin_unlock_irqrestore(&pg->lock, flags);
+ 
+ 	list_for_each_entry_safe(qdata, tmp, &qdata_list, entry) {
+ 		list_del(&qdata->entry);
+ 		if (qdata->callback_fn)
+ 			qdata->callback_fn(qdata->callback_data, err);
+ 		kfree(qdata);
+ 	}
+ 	spin_lock_irqsave(&pg->lock, flags);
+ 	pg->flags &= ~ALUA_PG_RUNNING;
+ 	spin_unlock_irqrestore(&pg->lock, flags);
+ 	scsi_device_put(sdev);
+ 	kref_put(&pg->kref, release_port_group);
+ }
+ 
+ static void alua_rtpg_queue(struct alua_port_group *pg,
+ 			    struct scsi_device *sdev,
+ 			    struct alua_queue_data *qdata, bool force)
+ {
+ 	int start_queue = 0;
+ 	unsigned long flags;
+ 	struct workqueue_struct *alua_wq = kaluad_wq;
+ 
+ 	if (!pg)
+ 		return;
+ 
+ 	spin_lock_irqsave(&pg->lock, flags);
+ 	if (qdata) {
+ 		list_add_tail(&qdata->entry, &pg->rtpg_list);
+ 		pg->flags |= ALUA_PG_RUN_STPG;
+ 		force = true;
+ 	}
+ 	if (pg->rtpg_sdev == NULL) {
+ 		pg->interval = 0;
+ 		pg->flags |= ALUA_PG_RUN_RTPG;
+ 		kref_get(&pg->kref);
+ 		pg->rtpg_sdev = sdev;
+ 		scsi_device_get(sdev);
+ 		start_queue = 1;
+ 	} else if (!(pg->flags & ALUA_PG_RUN_RTPG) && force) {
+ 		pg->flags |= ALUA_PG_RUN_RTPG;
+ 		/* Do not queue if the worker is already running */
+ 		if (!(pg->flags & ALUA_PG_RUNNING)) {
+ 			kref_get(&pg->kref);
+ 			start_queue = 1;
+ 		}
+ 	}
+ 
+ 	if (pg->flags & ALUA_SYNC_STPG)
+ 		alua_wq = kaluad_sync_wq;
+ 	spin_unlock_irqrestore(&pg->lock, flags);
+ 
+ 	if (start_queue &&
+ 	    !queue_delayed_work(alua_wq, &pg->rtpg_work,
+ 				msecs_to_jiffies(ALUA_RTPG_DELAY_MSECS))) {
+ 		scsi_device_put(sdev);
+ 		kref_put(&pg->kref, release_port_group);
+ 	}
+ }
+ 
++>>>>>>> 1fdd14279eab (scsi: scsi_dh_alua: fix missing kref_put() in alua_rtpg_work())
  /*
   * alua_initialize - Initialize ALUA state
   * @sdev: the device to be initialized
* Unmerged path drivers/scsi/device_handler/scsi_dh_alua.c
