sbitmap: push alloc policy into sbitmap_queue

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Omar Sandoval <osandov@fb.com>
commit f4a644db86669d938c71f19560aebf69d4720d63
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f4a644db.failed

Again, there's no point in passing this in every time. Make it part of
struct sbitmap_queue and clean up the API.

	Signed-off-by: Omar Sandoval <osandov@fb.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit f4a644db86669d938c71f19560aebf69d4720d63)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq-tag.c
#	include/linux/sbitmap.h
#	lib/sbitmap.c
diff --cc block/blk-mq-tag.c
index 7e6885bccaac,e1c2bedb0bf9..000000000000
--- a/block/blk-mq-tag.c
+++ b/block/blk-mq-tag.c
@@@ -144,134 -91,32 +144,150 @@@ static inline bool hctx_may_queue(struc
  	return atomic_read(&hctx->nr_active) < depth;
  }
  
++<<<<<<< HEAD
 +static int __bt_get_word(struct blk_align_bitmap *bm, unsigned int last_tag)
 +{
 +	int tag, org_last_tag = last_tag;
 +
 +	while (1) {
 +		tag = find_next_zero_bit(&bm->word, bm->depth, last_tag);
 +		if (unlikely(tag >= bm->depth)) {
 +			/*
 +			 * We started with an offset, and we didn't reset the
 +			 * offset to 0 in a failure case, so start from 0 to
 +			 * exhaust the map.
 +			 */
 +			if (org_last_tag && last_tag) {
 +				last_tag = org_last_tag = 0;
 +				continue;
 +			}
 +			return -1;
 +		}
 +
 +		if (!test_and_set_bit(tag, &bm->word))
 +			break;
 +
 +		last_tag = tag + 1;
 +		if (last_tag >= bm->depth - 1)
 +			last_tag = 0;
 +	}
 +
 +	return tag;
++=======
+ static int __bt_get(struct blk_mq_hw_ctx *hctx, struct sbitmap_queue *bt)
+ {
+ 	if (!hctx_may_queue(hctx, bt))
+ 		return -1;
+ 	return __sbitmap_queue_get(bt);
++>>>>>>> f4a644db8666 (sbitmap: push alloc policy into sbitmap_queue)
 +}
 +
 +/*
 + * Straight forward bitmap tag implementation, where each bit is a tag
 + * (cleared == free, and set == busy). The small twist is using per-cpu
 + * last_tag caches, which blk-mq stores in the blk_mq_ctx software queue
 + * contexts. This enables us to drastically limit the space searched,
 + * without dirtying an extra shared cacheline like we would if we stored
 + * the cache value inside the shared blk_mq_bitmap_tags structure. On top
 + * of that, each word of tags is in a separate cacheline. This means that
 + * multiple users will tend to stick to different cachelines, at least
 + * until the map is exhausted.
 + */
 +static int __bt_get(struct blk_mq_hw_ctx *hctx, struct blk_mq_bitmap_tags *bt,
 +		    unsigned int *tag_cache)
 +{
 +	unsigned int last_tag, org_last_tag;
 +	int index, i, tag;
 +
 +	if (!hctx_may_queue(hctx, bt))
 +		return -1;
 +
 +	last_tag = org_last_tag = *tag_cache;
 +	index = TAG_TO_INDEX(bt, last_tag);
 +
 +	for (i = 0; i < bt->map_nr; i++) {
 +		tag = __bt_get_word(&bt->map[index], TAG_TO_BIT(bt, last_tag));
 +		if (tag != -1) {
 +			tag += (index << bt->bits_per_word);
 +			goto done;
 +		}
 +
 +		/*
 +		 * Jump to next index, and reset the last tag to be the
 +		 * first tag of that index
 +		 */
 +		index++;
 +		last_tag = (index << bt->bits_per_word);
 +
 +		if (index >= bt->map_nr) {
 +			index = 0;
 +			last_tag = 0;
 +		}
 +	}
 +
 +	*tag_cache = 0;
 +	return -1;
 +
 +	/*
 +	 * Only update the cache from the allocation path, if we ended
 +	 * up using the specific cached tag.
 +	 */
 +done:
 +	if (tag == org_last_tag) {
 +		last_tag = tag + 1;
 +		if (last_tag >= bt->depth - 1)
 +			last_tag = 0;
 +
 +		*tag_cache = last_tag;
 +	}
 +
 +	return tag;
  }
  
 -static int bt_get(struct blk_mq_alloc_data *data, struct sbitmap_queue *bt,
 -		  struct blk_mq_hw_ctx *hctx, struct blk_mq_tags *tags)
 +static struct bt_wait_state *bt_wait_ptr(struct blk_mq_bitmap_tags *bt,
 +					 struct blk_mq_hw_ctx *hctx)
  {
 -	struct sbq_wait_state *ws;
 +	struct bt_wait_state *bs;
 +	int wait_index;
 +
 +	if (!hctx)
 +		return &bt->bs[0];
 +
 +	wait_index = atomic_read(&hctx->wait_index);
 +	bs = &bt->bs[wait_index];
 +	bt_index_atomic_inc(&hctx->wait_index);
 +	return bs;
 +}
 +
 +static int bt_get(struct blk_mq_alloc_data *data,
 +		struct blk_mq_bitmap_tags *bt,
 +		struct blk_mq_hw_ctx *hctx,
 +		unsigned int *last_tag)
 +{
 +	struct bt_wait_state *bs;
  	DEFINE_WAIT(wait);
  	int tag;
  
++<<<<<<< HEAD
 +	tag = __bt_get(hctx, bt, last_tag);
++=======
+ 	tag = __bt_get(hctx, bt);
++>>>>>>> f4a644db8666 (sbitmap: push alloc policy into sbitmap_queue)
  	if (tag != -1)
  		return tag;
  
  	if (data->flags & BLK_MQ_REQ_NOWAIT)
  		return -1;
  
 -	ws = bt_wait_ptr(bt, hctx);
 +	bs = bt_wait_ptr(bt, hctx);
  	do {
 -		prepare_to_wait(&ws->wait, &wait, TASK_UNINTERRUPTIBLE);
 +		prepare_to_wait(&bs->wait, &wait, TASK_UNINTERRUPTIBLE);
  
++<<<<<<< HEAD
 +		tag = __bt_get(hctx, bt, last_tag);
++=======
+ 		tag = __bt_get(hctx, bt);
++>>>>>>> f4a644db8666 (sbitmap: push alloc policy into sbitmap_queue)
  		if (tag != -1)
  			break;
  
@@@ -288,7 -133,7 +304,11 @@@
  		 * Retry tag allocation after running the hardware queue,
  		 * as running the queue may also have found completions.
  		 */
++<<<<<<< HEAD
 +		tag = __bt_get(hctx, bt, last_tag);
++=======
+ 		tag = __bt_get(hctx, bt);
++>>>>>>> f4a644db8666 (sbitmap: push alloc policy into sbitmap_queue)
  		if (tag != -1)
  			break;
  
@@@ -405,11 -203,10 +425,18 @@@ void blk_mq_put_tag(struct blk_mq_hw_ct
  		const int real_tag = tag - tags->nr_reserved_tags;
  
  		BUG_ON(real_tag >= tags->nr_tags);
++<<<<<<< HEAD
 +		bt_clear_tag(&tags->bitmap_tags, real_tag);
 +		*last_tag = real_tag;
 +	} else {
 +		BUG_ON(tag >= tags->nr_reserved_tags);
 +		bt_clear_tag(&tags->breserved_tags, tag);
++=======
+ 		sbitmap_queue_clear(&tags->bitmap_tags, real_tag, ctx->cpu);
+ 	} else {
+ 		BUG_ON(tag >= tags->nr_reserved_tags);
+ 		sbitmap_queue_clear(&tags->breserved_tags, tag, ctx->cpu);
++>>>>>>> f4a644db8666 (sbitmap: push alloc policy into sbitmap_queue)
  	}
  }
  
@@@ -526,122 -347,40 +553,139 @@@ void blk_mq_queue_tag_busy_iter(struct 
  			continue;
  
  		if (tags->nr_reserved_tags)
 -			bt_for_each(hctx, &tags->breserved_tags, fn, priv, true);
 -		bt_for_each(hctx, &tags->bitmap_tags, fn, priv, false);
 +			bt_for_each(hctx, &tags->breserved_tags, 0, fn, priv, true);
 +		bt_for_each(hctx, &tags->bitmap_tags, tags->nr_reserved_tags, fn, priv,
 +		      false);
 +	}
 +
 +}
 +
 +static unsigned int bt_unused_tags(struct blk_mq_bitmap_tags *bt)
 +{
 +	unsigned int i, used;
 +
 +	for (i = 0, used = 0; i < bt->map_nr; i++) {
 +		struct blk_align_bitmap *bm = &bt->map[i];
 +
 +		used += bitmap_weight(&bm->word, bm->depth);
 +	}
 +
 +	return bt->depth - used;
 +}
 +
++<<<<<<< HEAD
 +static void bt_update_count(struct blk_mq_bitmap_tags *bt,
 +			    unsigned int depth)
 +{
 +	unsigned int tags_per_word = 1U << bt->bits_per_word;
 +	unsigned int map_depth = depth;
 +
 +	if (depth) {
 +		int i;
 +
 +		for (i = 0; i < bt->map_nr; i++) {
 +			bt->map[i].depth = min(map_depth, tags_per_word);
 +			map_depth -= bt->map[i].depth;
 +		}
  	}
  
 +	bt->wake_cnt = BT_WAIT_BATCH;
 +	if (bt->wake_cnt > depth / BT_WAIT_QUEUES)
 +		bt->wake_cnt = max(1U, depth / BT_WAIT_QUEUES);
 +
 +	bt->depth = depth;
  }
  
 -static unsigned int bt_unused_tags(const struct sbitmap_queue *bt)
 +static int bt_alloc(struct blk_mq_bitmap_tags *bt, unsigned int depth,
 +			int node, bool reserved)
  {
 -	return bt->sb.depth - sbitmap_weight(&bt->sb);
 +	int i;
 +
 +	bt->bits_per_word = ilog2(BITS_PER_LONG);
 +
 +	/*
 +	 * Depth can be zero for reserved tags, that's not a failure
 +	 * condition.
 +	 */
 +	if (depth) {
 +		unsigned int nr, tags_per_word;
 +
 +		tags_per_word = (1 << bt->bits_per_word);
 +
 +		/*
 +		 * If the tag space is small, shrink the number of tags
 +		 * per word so we spread over a few cachelines, at least.
 +		 * If less than 4 tags, just forget about it, it's not
 +		 * going to work optimally anyway.
 +		 */
 +		if (depth >= 4) {
 +			while (tags_per_word * 4 > depth) {
 +				bt->bits_per_word--;
 +				tags_per_word = (1 << bt->bits_per_word);
 +			}
 +		}
 +
 +		nr = ALIGN(depth, tags_per_word) / tags_per_word;
 +		bt->map = kzalloc_node(nr * sizeof(struct blk_align_bitmap),
 +						GFP_KERNEL, node);
 +		if (!bt->map)
 +			return -ENOMEM;
 +
 +		bt->map_nr = nr;
 +	}
 +
 +	bt->bs = kzalloc(BT_WAIT_QUEUES * sizeof(*bt->bs), GFP_KERNEL);
 +	if (!bt->bs) {
 +		kfree(bt->map);
 +		bt->map = NULL;
 +		return -ENOMEM;
 +	}
 +
 +	bt_update_count(bt, depth);
 +
 +	for (i = 0; i < BT_WAIT_QUEUES; i++) {
 +		init_waitqueue_head(&bt->bs[i].wait);
 +		atomic_set(&bt->bs[i].wait_cnt, bt->wake_cnt);
 +	}
 +
 +	return 0;
  }
  
 +static void bt_free(struct blk_mq_bitmap_tags *bt)
 +{
 +	kfree(bt->map);
 +	kfree(bt->bs);
++=======
+ static int bt_alloc(struct sbitmap_queue *bt, unsigned int depth,
+ 		    bool round_robin, int node)
+ {
+ 	return sbitmap_queue_init_node(bt, depth, -1, round_robin, GFP_KERNEL,
+ 				       node);
++>>>>>>> f4a644db8666 (sbitmap: push alloc policy into sbitmap_queue)
  }
  
  static struct blk_mq_tags *blk_mq_init_bitmap_tags(struct blk_mq_tags *tags,
 -						   int node, int alloc_policy)
 +						   int node)
  {
  	unsigned int depth = tags->nr_tags - tags->nr_reserved_tags;
+ 	bool round_robin = alloc_policy == BLK_TAG_ALLOC_RR;
  
++<<<<<<< HEAD
 +	if (bt_alloc(&tags->bitmap_tags, depth, node, false))
 +		goto enomem;
 +	if (bt_alloc(&tags->breserved_tags, tags->nr_reserved_tags, node, true))
 +		goto enomem;
++=======
+ 	if (bt_alloc(&tags->bitmap_tags, depth, round_robin, node))
+ 		goto free_tags;
+ 	if (bt_alloc(&tags->breserved_tags, tags->nr_reserved_tags, round_robin,
+ 		     node))
+ 		goto free_bitmap_tags;
++>>>>>>> f4a644db8666 (sbitmap: push alloc policy into sbitmap_queue)
  
  	return tags;
 -free_bitmap_tags:
 -	sbitmap_queue_free(&tags->bitmap_tags);
 -free_tags:
 +enomem:
 +	bt_free(&tags->bitmap_tags);
  	kfree(tags);
  	return NULL;
  }
* Unmerged path include/linux/sbitmap.h
* Unmerged path lib/sbitmap.c
* Unmerged path block/blk-mq-tag.c
* Unmerged path include/linux/sbitmap.h
* Unmerged path lib/sbitmap.c
