nfp: don't clutter init code passing fw_ver around

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 21537bc7019a4dfd5c6f615a235e0b171ef3dda8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/21537bc7.failed

Reading fw version from the BAR is trivial.  Don't pass it around
through layers of init functions, simply read it again where needed.

This commit has the side effect of each vNIC having the exact NFD
version from its own control memory, rather than all data vNICs
assuming the version of the first one.  This should not result in
user-visible changes, though.  Capabilities of data vNICs of trival
apps are identical.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 21537bc7019a4dfd5c6f615a235e0b171ef3dda8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net_main.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_main.c
index acc8cfe284f3,82172665e023..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
@@@ -281,13 -275,16 +281,19 @@@ static void nfp_net_pf_free_netdevs(str
  }
  
  static struct nfp_net *
++<<<<<<< HEAD
 +nfp_net_pf_alloc_port_netdev(struct nfp_pf *pf, void __iomem *ctrl_bar,
 +			     void __iomem *tx_bar, void __iomem *rx_bar,
 +			     int stride, struct nfp_net_fw_version *fw_ver)
++=======
+ nfp_net_pf_alloc_vnic(struct nfp_pf *pf, bool needs_netdev,
+ 		      void __iomem *ctrl_bar, void __iomem *qc_bar,
+ 		      int stride, unsigned int eth_id)
++>>>>>>> 21537bc7019a (nfp: don't clutter init code passing fw_ver around)
  {
 -	u32 tx_base, rx_base, n_tx_rings, n_rx_rings;
 +	u32 n_tx_rings, n_rx_rings;
  	struct nfp_net *nn;
 -	int err;
  
 -	tx_base = readl(ctrl_bar + NFP_NET_CFG_START_TXQ);
 -	rx_base = readl(ctrl_bar + NFP_NET_CFG_START_RXQ);
  	n_tx_rings = readl(ctrl_bar + NFP_NET_CFG_MAX_TXRINGS);
  	n_rx_rings = readl(ctrl_bar + NFP_NET_CFG_MAX_RXRINGS);
  
@@@ -296,12 -293,12 +302,21 @@@
  	if (IS_ERR(nn))
  		return nn;
  
++<<<<<<< HEAD
 +	nn->cpp = pf->cpp;
 +	nn->fw_ver = *fw_ver;
 +	nn->ctrl_bar = ctrl_bar;
 +	nn->tx_bar = tx_bar;
 +	nn->rx_bar = rx_bar;
 +	nn->is_vf = 0;
++=======
+ 	nn->app = pf->app;
+ 	nfp_net_get_fw_version(&nn->fw_ver, ctrl_bar);
+ 	nn->dp.ctrl_bar = ctrl_bar;
+ 	nn->tx_bar = qc_bar + tx_base * NFP_QCP_QUEUE_ADDR_SZ;
+ 	nn->rx_bar = qc_bar + rx_base * NFP_QCP_QUEUE_ADDR_SZ;
+ 	nn->dp.is_vf = 0;
++>>>>>>> 21537bc7019a (nfp: don't clutter init code passing fw_ver around)
  	nn->stride_rx = stride;
  	nn->stride_tx = stride;
  
@@@ -335,28 -343,21 +350,39 @@@ nfp_net_pf_init_port_netdev(struct nfp_
  }
  
  static int
++<<<<<<< HEAD
 +nfp_net_pf_alloc_netdevs(struct nfp_pf *pf, void __iomem *ctrl_bar,
 +			 void __iomem *tx_bar, void __iomem *rx_bar,
 +			 int stride, struct nfp_net_fw_version *fw_ver)
++=======
+ nfp_net_pf_alloc_vnics(struct nfp_pf *pf, void __iomem *ctrl_bar,
+ 		       void __iomem *qc_bar, int stride)
++>>>>>>> 21537bc7019a (nfp: don't clutter init code passing fw_ver around)
  {
 +	u32 prev_tx_base, prev_rx_base, tgt_tx_base, tgt_rx_base;
  	struct nfp_net *nn;
  	unsigned int i;
  	int err;
  
++<<<<<<< HEAD
 +	prev_tx_base = readl(ctrl_bar + NFP_NET_CFG_START_TXQ);
 +	prev_rx_base = readl(ctrl_bar + NFP_NET_CFG_START_RXQ);
 +
 +	for (i = 0; i < pf->num_ports; i++) {
 +		tgt_tx_base = readl(ctrl_bar + NFP_NET_CFG_START_TXQ);
 +		tgt_rx_base = readl(ctrl_bar + NFP_NET_CFG_START_RXQ);
 +		tx_bar += (tgt_tx_base - prev_tx_base) * NFP_QCP_QUEUE_ADDR_SZ;
 +		rx_bar += (tgt_rx_base - prev_rx_base) * NFP_QCP_QUEUE_ADDR_SZ;
 +		prev_tx_base = tgt_tx_base;
 +		prev_rx_base = tgt_rx_base;
 +
 +		nn = nfp_net_pf_alloc_port_netdev(pf, ctrl_bar, tx_bar, rx_bar,
 +						  stride, fw_ver);
++=======
+ 	for (i = 0; i < pf->max_data_vnics; i++) {
+ 		nn = nfp_net_pf_alloc_vnic(pf, true, ctrl_bar, qc_bar,
+ 					   stride, i);
++>>>>>>> 21537bc7019a (nfp: don't clutter init code passing fw_ver around)
  		if (IS_ERR(nn)) {
  			err = PTR_ERR(nn);
  			goto err_free_prev;
@@@ -373,19 -382,25 +399,29 @@@ err_free_prev
  	return err;
  }
  
 -static void nfp_net_pf_clean_vnic(struct nfp_pf *pf, struct nfp_net *nn)
 -{
 -	if (nn->port)
 -		nfp_devlink_port_unregister(nn->port);
 -	nfp_net_debugfs_dir_clean(&nn->debugfs_dir);
 -	nfp_net_clean(nn);
 -	nfp_app_vnic_clean(pf->app, nn);
 -}
 -
  static int
++<<<<<<< HEAD
 +nfp_net_pf_spawn_netdevs(struct nfp_pf *pf,
 +			 void __iomem *ctrl_bar, void __iomem *tx_bar,
 +			 void __iomem *rx_bar, int stride,
 +			 struct nfp_net_fw_version *fw_ver)
++=======
+ nfp_net_pf_spawn_vnics(struct nfp_pf *pf,
+ 		       void __iomem *ctrl_bar, void __iomem *qc_bar, int stride)
++>>>>>>> 21537bc7019a (nfp: don't clutter init code passing fw_ver around)
  {
 -	unsigned int id, wanted_irqs, num_irqs, vnics_left, irqs_left;
 +	unsigned int id, wanted_irqs, num_irqs, ports_left, irqs_left;
  	struct nfp_net *nn;
  	int err;
  
++<<<<<<< HEAD
 +	/* Allocate the netdevs and do basic init */
 +	err = nfp_net_pf_alloc_netdevs(pf, ctrl_bar, tx_bar, rx_bar,
 +				       stride, fw_ver);
++=======
+ 	/* Allocate the vnics and do basic init */
+ 	err = nfp_net_pf_alloc_vnics(pf, ctrl_bar, qc_bar, stride);
++>>>>>>> 21537bc7019a (nfp: don't clutter init code passing fw_ver around)
  	if (err)
  		return err;
  
@@@ -620,8 -691,7 +656,12 @@@ int nfp_net_pci_probe(struct nfp_pf *pf
  
  	pf->ddir = nfp_net_debugfs_device_add(pf->pdev);
  
++<<<<<<< HEAD
 +	err = nfp_net_pf_spawn_netdevs(pf, ctrl_bar, tx_bar, rx_bar,
 +				       stride, &fw_ver);
++=======
+ 	err = nfp_net_pf_spawn_vnics(pf, ctrl_bar, qc_bar, stride);
++>>>>>>> 21537bc7019a (nfp: don't clutter init code passing fw_ver around)
  	if (err)
  		goto err_clean_ddir;
  
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_main.c
