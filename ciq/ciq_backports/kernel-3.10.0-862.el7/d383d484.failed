sysctl: fold sysctl_writes_strict checks into helper

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Luis R. Rodriguez <mcgrof@kernel.org>
commit d383d48470819e86fe30eb72f0e9494e1ee0e2af
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d383d484.failed

The mode sysctl_writes_strict positional checks keep being copy and pasted
as we add new proc handlers.  Just add a helper to avoid code duplication.

Link: http://lkml.kernel.org/r/20170519033554.18592-4-mcgrof@kernel.org
	Signed-off-by: Luis R. Rodriguez <mcgrof@kernel.org>
	Suggested-by: Kees Cook <keescook@chromium.org>
	Cc: Al Viro <viro@zeniv.linux.org.uk>
	Cc: "Eric W. Biederman" <ebiederm@xmission.com>
	Cc: Alexey Dobriyan <adobriyan@gmail.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit d383d48470819e86fe30eb72f0e9494e1ee0e2af)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sysctl.c
diff --cc kernel/sysctl.c
index a652717610c7,6f3bb1f099fa..000000000000
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@@ -1881,6 -1962,40 +1881,32 @@@ static int _proc_do_string(char *data, 
  	return 0;
  }
  
 -static void warn_sysctl_write(struct ctl_table *table)
 -{
 -	pr_warn_once("%s wrote to %s when file position was not 0!\n"
 -		"This will not be supported in the future. To silence this\n"
 -		"warning, set kernel.sysctl_writes_strict = -1\n",
 -		current->comm, table->procname);
 -}
 -
+ /**
+  * proc_first_pos_non_zero_ignore - check if firs position is allowed
+  * @ppos: file position
+  * @table: the sysctl table
+  *
+  * Returns true if the first position is non-zero and the sysctl_writes_strict
+  * mode indicates this is not allowed for numeric input types. String proc
+  * hadlers can ignore the return value.
+  */
+ static bool proc_first_pos_non_zero_ignore(loff_t *ppos,
+ 					   struct ctl_table *table)
+ {
+ 	if (!*ppos)
+ 		return false;
+ 
+ 	switch (sysctl_writes_strict) {
+ 	case SYSCTL_WRITES_STRICT:
+ 		return true;
+ 	case SYSCTL_WRITES_WARN:
+ 		warn_sysctl_write(table);
+ 		return false;
+ 	default:
+ 		return false;
+ 	}
+ }
+ 
  /**
   * proc_dostring - read a string sysctl
   * @table: the sysctl table
@@@ -1901,6 -2016,9 +1927,12 @@@
  int proc_dostring(struct ctl_table *table, int write,
  		  void __user *buffer, size_t *lenp, loff_t *ppos)
  {
++<<<<<<< HEAD
++=======
+ 	if (write)
+ 		proc_first_pos_non_zero_ignore(ppos, table);
+ 
++>>>>>>> d383d4847081 (sysctl: fold sysctl_writes_strict checks into helper)
  	return _proc_do_string((char *)(table->data), table->maxlen, write,
  			       (char __user *)buffer, lenp, ppos);
  }
@@@ -2100,17 -2219,14 +2132,23 @@@ static int __do_proc_dointvec(void *tbl
  		conv = do_proc_dointvec_conv;
  
  	if (write) {
++<<<<<<< HEAD
++=======
+ 		if (proc_first_pos_non_zero_ignore(ppos, table))
+ 			goto out;
+ 
++>>>>>>> d383d4847081 (sysctl: fold sysctl_writes_strict checks into helper)
  		if (left > PAGE_SIZE - 1)
  			left = PAGE_SIZE - 1;
 -		p = kbuf = memdup_user_nul(buffer, left);
 -		if (IS_ERR(kbuf))
 -			return PTR_ERR(kbuf);
 +		page = __get_free_page(GFP_TEMPORARY);
 +		kbuf = (char *) page;
 +		if (!kbuf)
 +			return -ENOMEM;
 +		if (copy_from_user(kbuf, buffer, left)) {
 +			err = -EFAULT;
 +			goto free;
 +		}
 +		kbuf[left] = 0;
  	}
  
  	for (; left && vleft--; i++, first=0) {
@@@ -2368,17 -2485,14 +2406,23 @@@ static int __do_proc_doulongvec_minmax(
  	left = *lenp;
  
  	if (write) {
++<<<<<<< HEAD
++=======
+ 		if (proc_first_pos_non_zero_ignore(ppos, table))
+ 			goto out;
+ 
++>>>>>>> d383d4847081 (sysctl: fold sysctl_writes_strict checks into helper)
  		if (left > PAGE_SIZE - 1)
  			left = PAGE_SIZE - 1;
 -		p = kbuf = memdup_user_nul(buffer, left);
 -		if (IS_ERR(kbuf))
 -			return PTR_ERR(kbuf);
 +		page = __get_free_page(GFP_TEMPORARY);
 +		kbuf = (char *) page;
 +		if (!kbuf)
 +			return -ENOMEM;
 +		if (copy_from_user(kbuf, buffer, left)) {
 +			err = -EFAULT;
 +			goto free;
 +		}
 +		kbuf[left] = 0;
  	}
  
  	for (; left && vleft--; i++, first = 0) {
* Unmerged path kernel/sysctl.c
