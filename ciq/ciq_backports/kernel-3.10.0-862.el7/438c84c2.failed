ovl: don't follow redirects if redirect_dir=off

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 438c84c2f0c794f75ab55ce65c505b01bfce4480
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/438c84c2.failed

Overlayfs is following redirects even when redirects are disabled. If this
is unintentional (probably the majority of cases) then this can be a
problem.  E.g. upper layer comes from untrusted USB drive, and attacker
crafts a redirect to enable read access to otherwise unreadable
directories.

If "redirect_dir=off", then turn off following as well as creation of
redirects.  If "redirect_dir=follow", then turn on following, but turn off
creation of redirects (which is what "redirect_dir=off" does now).

This is a backward incompatible change, so make it dependent on a config
option.

	Reported-by: David Howells <dhowells@redhat.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 438c84c2f0c794f75ab55ce65c505b01bfce4480)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/Kconfig
#	fs/overlayfs/namei.c
#	fs/overlayfs/ovl_entry.h
#	fs/overlayfs/super.c
diff --cc fs/overlayfs/Kconfig
index aeec86b8f671,5ac415466861..000000000000
--- a/fs/overlayfs/Kconfig
+++ b/fs/overlayfs/Kconfig
@@@ -9,3 -9,47 +9,50 @@@ config OVERLAY_F
  	  merged with the 'upper' object.
  
  	  For more information see Documentation/filesystems/overlayfs.txt
++<<<<<<< HEAD
++=======
+ 
+ config OVERLAY_FS_REDIRECT_DIR
+ 	bool "Overlayfs: turn on redirect dir feature by default"
+ 	depends on OVERLAY_FS
+ 	help
+ 	  If this config option is enabled then overlay filesystems will use
+ 	  redirects when renaming directories by default.  In this case it is
+ 	  still possible to turn off redirects globally with the
+ 	  "redirect_dir=off" module option or on a filesystem instance basis
+ 	  with the "redirect_dir=off" mount option.
+ 
+ 	  Note, that redirects are not backward compatible.  That is, mounting
+ 	  an overlay which has redirects on a kernel that doesn't support this
+ 	  feature will have unexpected results.
+ 
+ config OVERLAY_FS_REDIRECT_ALWAYS_FOLLOW
+ 	bool "Overlayfs: follow redirects even if redirects are turned off"
+ 	default y
+ 	depends on OVERLAY_FS
+ 	help
+ 	  Disable this to get a possibly more secure configuration, but that
+ 	  might not be backward compatible with previous kernels.
+ 
+ 	  For more information, see Documentation/filesystems/overlayfs.txt
+ 
+ config OVERLAY_FS_INDEX
+ 	bool "Overlayfs: turn on inodes index feature by default"
+ 	depends on OVERLAY_FS
+ 	help
+ 	  If this config option is enabled then overlay filesystems will use
+ 	  the inodes index dir to map lower inodes to upper inodes by default.
+ 	  In this case it is still possible to turn off index globally with the
+ 	  "index=off" module option or on a filesystem instance basis with the
+ 	  "index=off" mount option.
+ 
+ 	  The inodes index feature prevents breaking of lower hardlinks on copy
+ 	  up.
+ 
+ 	  Note, that the inodes index feature is read-only backward compatible.
+ 	  That is, mounting an overlay which has an index dir on a kernel that
+ 	  doesn't support this feature read-only, will not have any negative
+ 	  outcomes.  However, mounting the same overlay with an old kernel
+ 	  read-write and then mounting it again with a new kernel, will have
+ 	  unexpected results.
++>>>>>>> 438c84c2f0c7 (ovl: don't follow redirects if redirect_dir=off)
diff --cc fs/overlayfs/super.c
index 311aedaffa1b,13a8a8617e44..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -49,243 -26,31 +49,264 @@@ struct ovl_fs 
  
  struct ovl_dir_cache;
  
 +/* private information held for every overlayfs dentry */
 +struct ovl_entry {
 +	struct dentry *__upperdentry;
 +	struct ovl_dir_cache *cache;
 +	union {
 +		struct {
 +			u64 version;
 +			bool opaque;
 +		};
 +		struct rcu_head rcu;
 +	};
 +	unsigned numlower;
 +	struct path lowerstack[];
 +};
 +
  #define OVL_MAX_STACK 500
  
++<<<<<<< HEAD
 +static struct dentry *__ovl_dentry_lower(struct ovl_entry *oe)
++=======
+ static bool ovl_redirect_dir_def = IS_ENABLED(CONFIG_OVERLAY_FS_REDIRECT_DIR);
+ module_param_named(redirect_dir, ovl_redirect_dir_def, bool, 0644);
+ MODULE_PARM_DESC(ovl_redirect_dir_def,
+ 		 "Default to on or off for the redirect_dir feature");
+ 
+ static bool ovl_redirect_always_follow =
+ 	IS_ENABLED(CONFIG_OVERLAY_FS_REDIRECT_ALWAYS_FOLLOW);
+ module_param_named(redirect_always_follow, ovl_redirect_always_follow,
+ 		   bool, 0644);
+ MODULE_PARM_DESC(ovl_redirect_always_follow,
+ 		 "Follow redirects even if redirect_dir feature is turned off");
+ 
+ static bool ovl_index_def = IS_ENABLED(CONFIG_OVERLAY_FS_INDEX);
+ module_param_named(index, ovl_index_def, bool, 0644);
+ MODULE_PARM_DESC(ovl_index_def,
+ 		 "Default to on or off for the inodes index feature");
+ 
+ static void ovl_entry_stack_free(struct ovl_entry *oe)
++>>>>>>> 438c84c2f0c7 (ovl: don't follow redirects if redirect_dir=off)
  {
 -	unsigned int i;
 +	return oe->numlower ? oe->lowerstack[0].dentry : NULL;
 +}
 +
 +enum ovl_path_type ovl_path_type(struct dentry *dentry)
 +{
 +	struct ovl_entry *oe = dentry->d_fsdata;
 +	enum ovl_path_type type = 0;
 +
 +	if (oe->__upperdentry) {
 +		type = __OVL_PATH_UPPER;
 +
 +		/*
 +		 * Non-dir dentry can hold lower dentry from previous
 +		 * location.
 +		 */
 +		if (oe->numlower && d_is_dir(dentry))
 +			type |= __OVL_PATH_MERGE;
 +	} else {
 +		if (oe->numlower > 1)
 +			type |= __OVL_PATH_MERGE;
 +	}
 +	return type;
 +}
 +
 +static struct dentry *ovl_upperdentry_dereference(struct ovl_entry *oe)
 +{
 +	return lockless_dereference(oe->__upperdentry);
 +}
 +
 +void ovl_path_upper(struct dentry *dentry, struct path *path)
 +{
 +	struct ovl_fs *ofs = dentry->d_sb->s_fs_info;
 +	struct ovl_entry *oe = dentry->d_fsdata;
 +
 +	path->mnt = ofs->upper_mnt;
 +	path->dentry = ovl_upperdentry_dereference(oe);
 +}
  
 -	for (i = 0; i < oe->numlower; i++)
 -		dput(oe->lowerstack[i].dentry);
 +enum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path)
 +{
 +	enum ovl_path_type type = ovl_path_type(dentry);
 +
 +	if (!OVL_TYPE_UPPER(type))
 +		ovl_path_lower(dentry, path);
 +	else
 +		ovl_path_upper(dentry, path);
 +
 +	return type;
 +}
 +
 +struct dentry *ovl_dentry_upper(struct dentry *dentry)
 +{
 +	struct ovl_entry *oe = dentry->d_fsdata;
 +
 +	return ovl_upperdentry_dereference(oe);
 +}
 +
 +struct dentry *ovl_dentry_lower(struct dentry *dentry)
 +{
 +	struct ovl_entry *oe = dentry->d_fsdata;
 +
 +	return __ovl_dentry_lower(oe);
 +}
 +
 +struct dentry *ovl_dentry_real(struct dentry *dentry)
 +{
 +	struct ovl_entry *oe = dentry->d_fsdata;
 +	struct dentry *realdentry;
 +
 +	realdentry = ovl_upperdentry_dereference(oe);
 +	if (!realdentry)
 +		realdentry = __ovl_dentry_lower(oe);
 +
 +	return realdentry;
 +}
 +
 +static void ovl_inode_init(struct inode *inode, struct inode *realinode,
 +			   bool is_upper)
 +{
 +	WRITE_ONCE(inode->i_private, (void *) ((unsigned long) realinode |
 +		   (is_upper ? OVL_ISUPPER_MASK : 0)));
 +}
 +
 +struct vfsmount *ovl_entry_mnt_real(struct ovl_entry *oe, struct inode *inode,
 +				    bool is_upper)
 +{
 +	if (is_upper) {
 +		struct ovl_fs *ofs = inode->i_sb->s_fs_info;
 +
 +		return ofs->upper_mnt;
 +	} else {
 +		return oe->numlower ? oe->lowerstack[0].mnt : NULL;
 +	}
 +}
 +
 +struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry)
 +{
 +	struct ovl_entry *oe = dentry->d_fsdata;
 +
 +	return oe->cache;
 +}
 +
 +void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache)
 +{
 +	struct ovl_entry *oe = dentry->d_fsdata;
 +
 +	oe->cache = cache;
 +}
 +
 +void ovl_path_lower(struct dentry *dentry, struct path *path)
 +{
 +	struct ovl_entry *oe = dentry->d_fsdata;
 +
 +	*path = oe->numlower ? oe->lowerstack[0] : (struct path) { NULL, NULL };
 +}
 +
 +int ovl_want_write(struct dentry *dentry)
 +{
 +	struct ovl_fs *ofs = dentry->d_sb->s_fs_info;
 +	return mnt_want_write(ofs->upper_mnt);
 +}
 +
 +void ovl_drop_write(struct dentry *dentry)
 +{
 +	struct ovl_fs *ofs = dentry->d_sb->s_fs_info;
 +	mnt_drop_write(ofs->upper_mnt);
 +}
 +
 +struct dentry *ovl_workdir(struct dentry *dentry)
 +{
 +	struct ovl_fs *ofs = dentry->d_sb->s_fs_info;
 +	return ofs->workdir;
 +}
 +
 +bool ovl_dentry_is_opaque(struct dentry *dentry)
 +{
 +	struct ovl_entry *oe = dentry->d_fsdata;
 +	return oe->opaque;
 +}
 +
 +bool ovl_dentry_is_whiteout(struct dentry *dentry)
 +{
 +	return !dentry->d_inode && ovl_dentry_is_opaque(dentry);
 +}
 +
 +void ovl_dentry_set_opaque(struct dentry *dentry, bool opaque)
 +{
 +	struct ovl_entry *oe = dentry->d_fsdata;
 +	oe->opaque = opaque;
 +}
 +
 +void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry)
 +{
 +	struct ovl_entry *oe = dentry->d_fsdata;
 +
 +	WARN_ON(!mutex_is_locked(&upperdentry->d_parent->d_inode->i_mutex));
 +	WARN_ON(oe->__upperdentry);
 +	/*
 +	 * Make sure upperdentry is consistent before making it visible to
 +	 * ovl_upperdentry_dereference().
 +	 */
 +	smp_wmb();
 +	oe->__upperdentry = upperdentry;
 +}
 +
 +void ovl_inode_update(struct inode *inode, struct inode *upperinode)
 +{
 +	WARN_ON(!upperinode);
 +	WARN_ON(!inode_unhashed(inode));
 +	WRITE_ONCE(inode->i_private,
 +		   (void *) ((unsigned long) upperinode | OVL_ISUPPER_MASK));
 +	if (!S_ISDIR(upperinode->i_mode))
 +		__insert_inode_hash(inode, (unsigned long) upperinode);
 +}
 +
 +void ovl_dentry_version_inc(struct dentry *dentry)
 +{
 +	struct ovl_entry *oe = dentry->d_fsdata;
 +
 +	WARN_ON(!mutex_is_locked(&dentry->d_inode->i_mutex));
 +	oe->version++;
 +}
 +
 +u64 ovl_dentry_version_get(struct dentry *dentry)
 +{
 +	struct ovl_entry *oe = dentry->d_fsdata;
 +
 +	WARN_ON(!mutex_is_locked(&dentry->d_inode->i_mutex));
 +	return oe->version;
 +}
 +
 +bool ovl_is_whiteout(struct dentry *dentry)
 +{
 +	struct inode *inode = dentry->d_inode;
 +
 +	return inode && IS_WHITEOUT(inode);
 +}
 +
 +const struct cred *ovl_override_creds(struct super_block *sb)
 +{
 +	struct ovl_fs *ofs = sb->s_fs_info;
 +
 +	return override_creds(ofs->creator_cred);
 +}
 +
 +static bool ovl_is_opaquedir(struct dentry *dentry)
 +{
 +	int res;
 +	char val;
 +
 +	if (!d_is_dir(dentry))
 +		return false;
 +
 +	res = vfs_getxattr(dentry, OVL_XATTR_OPAQUE, &val, 1);
 +	if (res == 1 && val == 'y')
 +		return true;
 +
 +	return false;
  }
  
  static void ovl_dentry_release(struct dentry *dentry)
@@@ -415,282 -172,77 +436,292 @@@ static const struct dentry_operations_w
  	.d_real = ovl_d_real,
  };
  
 -static const struct dentry_operations ovl_reval_dentry_operations = {
 -	.d_release = ovl_dentry_release,
 +static const struct dentry_operations_wrapper ovl_reval_dentry_operations = {
 +	.ops = {
 +		.d_release = ovl_dentry_release,
 +		.d_revalidate = ovl_dentry_revalidate,
 +		.d_weak_revalidate = ovl_dentry_weak_revalidate,
 +	},
 +	.size = sizeof(struct dentry_operations_wrapper),
  	.d_real = ovl_d_real,
 -	.d_revalidate = ovl_dentry_revalidate,
 -	.d_weak_revalidate = ovl_dentry_weak_revalidate,
  };
  
 -static struct kmem_cache *ovl_inode_cachep;
 -
 -static struct inode *ovl_alloc_inode(struct super_block *sb)
 +static struct ovl_entry *ovl_alloc_entry(unsigned int numlower)
  {
 -	struct ovl_inode *oi = kmem_cache_alloc(ovl_inode_cachep, GFP_KERNEL);
 +	size_t size = offsetof(struct ovl_entry, lowerstack[numlower]);
 +	struct ovl_entry *oe = kzalloc(size, GFP_KERNEL);
  
 -	if (!oi)
 -		return NULL;
 +	if (oe)
 +		oe->numlower = numlower;
  
 -	oi->cache = NULL;
 -	oi->redirect = NULL;
 -	oi->version = 0;
 -	oi->flags = 0;
 -	oi->__upperdentry = NULL;
 -	oi->lower = NULL;
 -	mutex_init(&oi->lock);
 +	return oe;
 +}
  
 -	return &oi->vfs_inode;
 +static bool ovl_dentry_remote(struct dentry *dentry)
 +{
 +	return dentry->d_flags &
 +		(DCACHE_OP_REVALIDATE | DCACHE_OP_WEAK_REVALIDATE |
 +		 DCACHE_OP_REAL);
  }
  
 -static void ovl_i_callback(struct rcu_head *head)
 +static bool ovl_dentry_weird(struct dentry *dentry)
  {
 -	struct inode *inode = container_of(head, struct inode, i_rcu);
 +	return dentry->d_flags & (DCACHE_NEED_AUTOMOUNT |
 +				  DCACHE_MANAGE_TRANSIT |
 +				  DCACHE_OP_HASH |
 +				  DCACHE_OP_COMPARE);
 +}
  
 -	kmem_cache_free(ovl_inode_cachep, OVL_I(inode));
 +static inline struct dentry *ovl_lookup_real(struct dentry *dir,
 +					     const struct qstr *name)
 +{
 +	struct dentry *dentry;
 +
 +	dentry = lookup_one_len_unlocked(name->name, dir, name->len);
 +	if (IS_ERR(dentry)) {
 +		if (PTR_ERR(dentry) == -ENOENT)
 +			dentry = NULL;
 +	} else if (!dentry->d_inode) {
 +		dput(dentry);
 +		dentry = NULL;
 +	} else if (ovl_dentry_weird(dentry)) {
 +		dput(dentry);
 +		/* Don't support traversing automounts and other weirdness */
 +		dentry = ERR_PTR(-EREMOTE);
 +	}
 +	return dentry;
  }
  
 -static void ovl_destroy_inode(struct inode *inode)
++<<<<<<< HEAD
 +/*
 + * Returns next layer in stack starting from top.
 + * Returns -1 if this is the last layer.
 + */
 +int ovl_path_next(int idx, struct dentry *dentry, struct path *path)
  {
 -	struct ovl_inode *oi = OVL_I(inode);
 +	struct ovl_entry *oe = dentry->d_fsdata;
  
 -	dput(oi->__upperdentry);
 -	kfree(oi->redirect);
 -	ovl_dir_cache_free(inode);
 -	mutex_destroy(&oi->lock);
 +	BUG_ON(idx < 0);
 +	if (idx == 0) {
 +		ovl_path_upper(dentry, path);
 +		if (path->dentry)
 +			return oe->numlower ? 1 : -1;
 +		idx++;
 +	}
 +	BUG_ON(idx > oe->numlower);
 +	*path = oe->lowerstack[idx - 1];
  
 -	call_rcu(&inode->i_rcu, ovl_i_callback);
 +	return (idx < oe->numlower) ? idx + 1 : -1;
  }
  
 -static void ovl_free_fs(struct ovl_fs *ofs)
 +struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 +			  unsigned int flags)
  {
 -	unsigned i;
 +	struct ovl_entry *oe;
 +	const struct cred *old_cred;
 +	struct ovl_entry *poe = dentry->d_parent->d_fsdata;
 +	struct path *stack = NULL;
 +	struct dentry *upperdir, *upperdentry = NULL;
 +	unsigned int ctr = 0;
 +	struct inode *inode = NULL;
 +	bool upperopaque = false;
 +	bool stop = false;
 +	bool isdir = false;
 +	struct dentry *this;
 +	unsigned int i;
 +	int err;
 +
 +	old_cred = ovl_override_creds(dentry->d_sb);
 +	upperdir = ovl_upperdentry_dereference(poe);
 +	if (upperdir) {
 +		this = ovl_lookup_real(upperdir, &dentry->d_name);
 +		err = PTR_ERR(this);
 +		if (IS_ERR(this))
 +			goto out;
 +
 +		if (this) {
 +			if (unlikely(ovl_dentry_remote(this))) {
 +				dput(this);
 +				err = -EREMOTE;
 +				goto out;
 +			}
 +			if (ovl_is_whiteout(this)) {
 +				dput(this);
 +				this = NULL;
 +				stop = upperopaque = true;
 +			} else if (!d_is_dir(this)) {
 +				stop = true;
 +			} else {
 +				isdir = true;
 +				if (poe->numlower && ovl_is_opaquedir(this))
 +					stop = upperopaque = true;
 +			}
 +		}
 +		upperdentry = this;
 +	}
 +
 +	if (!stop && poe->numlower) {
 +		err = -ENOMEM;
 +		stack = kcalloc(poe->numlower, sizeof(struct path), GFP_KERNEL);
 +		if (!stack)
 +			goto out_put_upper;
 +	}
 +
 +	for (i = 0; !stop && i < poe->numlower; i++) {
 +		struct path lowerpath = poe->lowerstack[i];
 +
 +		this = ovl_lookup_real(lowerpath.dentry, &dentry->d_name);
 +		err = PTR_ERR(this);
 +		if (IS_ERR(this)) {
 +			/*
 +			 * If it's positive, then treat ENAMETOOLONG as ENOENT.
 +			 */
 +			if (err == -ENAMETOOLONG && (upperdentry || ctr))
 +				continue;
 +			goto out_put;
 +		}
 +		if (!this)
 +			continue;
 +		if (ovl_is_whiteout(this)) {
 +			dput(this);
 +			break;
 +		}
 +		/*
 +		 * If this is a non-directory then stop here.
 +		 */
 +		if (!d_is_dir(this)) {
 +			if (isdir) {
 +				dput(this);
 +				break;
 +			}
 +			stop = true;
 +		} else {
 +			/*
 +			 * Only makes sense to check opaque dir if this is not
 +			 * the lowermost layer.
 +			 */
 +			if (i < poe->numlower - 1 && ovl_is_opaquedir(this))
 +				stop = true;
 +		}
 +
 +		stack[ctr].dentry = this;
 +		stack[ctr].mnt = lowerpath.mnt;
 +		ctr++;
 +	}
  
 -	dput(ofs->indexdir);
 -	dput(ofs->workdir);
 -	if (ofs->workdir_locked)
 -		ovl_inuse_unlock(ofs->workbasedir);
 -	dput(ofs->workbasedir);
 -	if (ofs->upperdir_locked)
 -		ovl_inuse_unlock(ofs->upper_mnt->mnt_root);
 -	mntput(ofs->upper_mnt);
 -	for (i = 0; i < ofs->numlower; i++) {
 -		mntput(ofs->lower_layers[i].mnt);
 -		free_anon_bdev(ofs->lower_layers[i].pseudo_dev);
 +	oe = ovl_alloc_entry(ctr);
 +	err = -ENOMEM;
 +	if (!oe)
 +		goto out_put;
 +
 +	if (upperdentry || ctr) {
 +		struct dentry *realdentry;
 +		struct inode *realinode;
 +
 +		realdentry = upperdentry ? upperdentry : stack[0].dentry;
 +		realinode = d_inode(realdentry);
 +
 +		err = -ENOMEM;
 +		if (upperdentry && !d_is_dir(upperdentry)) {
 +			inode = ovl_get_inode(dentry->d_sb, realinode);
 +		} else {
 +			inode = ovl_new_inode(dentry->d_sb, realinode->i_mode);
 +			if (inode)
 +				ovl_inode_init(inode, realinode, !!upperdentry);
 +		}
 +		if (!inode)
 +			goto out_free_oe;
 +		ovl_copyattr(realdentry->d_inode, inode);
  	}
 -	kfree(ofs->lower_layers);
  
 +	revert_creds(old_cred);
 +	oe->opaque = upperopaque;
 +	oe->__upperdentry = upperdentry;
 +	memcpy(oe->lowerstack, stack, sizeof(struct path) * ctr);
 +	kfree(stack);
 +	dentry->d_fsdata = oe;
 +	d_add(dentry, inode);
 +
 +	return NULL;
 +
 +out_free_oe:
 +	kfree(oe);
 +out_put:
 +	for (i = 0; i < ctr; i++)
 +		dput(stack[i].dentry);
 +	kfree(stack);
 +out_put_upper:
 +	dput(upperdentry);
 +out:
 +	revert_creds(old_cred);
 +	return ERR_PTR(err);
 +}
 +
 +bool ovl_lower_positive(struct dentry *dentry)
 +{
 +	struct ovl_entry *oe = dentry->d_fsdata;
 +	struct ovl_entry *poe = dentry->d_parent->d_fsdata;
 +	const struct qstr *name = &dentry->d_name;
 +	unsigned int i;
 +	bool positive = false;
 +	bool done = false;
 +
 +	/*
 +	 * If dentry is negative, then lower is positive iff this is a
 +	 * whiteout.
 +	 */
 +	if (!dentry->d_inode)
 +		return oe->opaque;
 +
 +	/* Negative upper -> positive lower */
 +	if (!oe->__upperdentry)
 +		return true;
 +
 +	/* Positive upper -> have to look up lower to see whether it exists */
 +	for (i = 0; !done && !positive && i < poe->numlower; i++) {
 +		struct dentry *this;
 +		struct dentry *lowerdir = poe->lowerstack[i].dentry;
 +
 +		this = lookup_one_len_unlocked(name->name, lowerdir,
 +					       name->len);
 +		if (IS_ERR(this)) {
 +			switch (PTR_ERR(this)) {
 +			case -ENOENT:
 +			case -ENAMETOOLONG:
 +				break;
 +
 +			default:
 +				/*
 +				 * Assume something is there, we just couldn't
 +				 * access it.
 +				 */
 +				positive = true;
 +				break;
 +			}
 +		} else {
 +			if (this->d_inode) {
 +				positive = !ovl_is_whiteout(this);
 +				done = true;
 +			}
 +			dput(this);
 +		}
 +	}
 +
 +	return positive;
 +}
 +
 +struct file *ovl_path_open(struct path *path, int flags)
 +{
 +	return dentry_open(path, flags | O_NOATIME, current_cred());
++=======
+ 	kfree(ofs->config.lowerdir);
+ 	kfree(ofs->config.upperdir);
+ 	kfree(ofs->config.workdir);
+ 	kfree(ofs->config.redirect_mode);
+ 	if (ofs->creator_cred)
+ 		put_cred(ofs->creator_cred);
+ 	kfree(ofs);
++>>>>>>> 438c84c2f0c7 (ovl: don't follow redirects if redirect_dir=off)
  }
  
  static void ovl_put_super(struct super_block *sb)
@@@ -756,6 -297,17 +787,20 @@@ static int ovl_statfs(struct dentry *de
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ /* Will this overlay be forced to mount/remount ro? */
+ static bool ovl_force_readonly(struct ovl_fs *ofs)
+ {
+ 	return (!ofs->upper_mnt || !ofs->workdir);
+ }
+ 
+ static const char *ovl_redirect_mode_def(void)
+ {
+ 	return ovl_redirect_dir_def ? "on" : "off";
+ }
+ 
++>>>>>>> 438c84c2f0c7 (ovl: don't follow redirects if redirect_dir=off)
  /**
   * ovl_show_options
   *
@@@ -765,18 -317,19 +810,25 @@@
  static int ovl_show_options(struct seq_file *m, struct dentry *dentry)
  {
  	struct super_block *sb = dentry->d_sb;
 -	struct ovl_fs *ofs = sb->s_fs_info;
 +	struct ovl_fs *ufs = sb->s_fs_info;
  
 -	seq_show_option(m, "lowerdir", ofs->config.lowerdir);
 -	if (ofs->config.upperdir) {
 -		seq_show_option(m, "upperdir", ofs->config.upperdir);
 -		seq_show_option(m, "workdir", ofs->config.workdir);
 +	seq_show_option(m, "lowerdir", ufs->config.lowerdir);
 +	if (ufs->config.upperdir) {
 +		seq_show_option(m, "upperdir", ufs->config.upperdir);
 +		seq_show_option(m, "workdir", ufs->config.workdir);
  	}
 -	if (ofs->config.default_permissions)
 +	if (ufs->config.default_permissions)
  		seq_puts(m, ",default_permissions");
++<<<<<<< HEAD
 +	if (ufs->config.redirect_dir != ovl_redirect_dir_def)
 +		seq_printf(m, ",redirect_dir=%s",
 +			   ufs->config.redirect_dir ? "on" : "off");
++=======
+ 	if (strcmp(ofs->config.redirect_mode, ovl_redirect_mode_def()) != 0)
+ 		seq_printf(m, ",redirect_dir=%s", ofs->config.redirect_mode);
+ 	if (ofs->config.index != ovl_index_def)
+ 		seq_printf(m, ",index=%s", ofs->config.index ? "on" : "off");
++>>>>>>> 438c84c2f0c7 (ovl: don't follow redirects if redirect_dir=off)
  	return 0;
  }
  
@@@ -804,6 -359,9 +856,12 @@@ enum 
  	OPT_UPPERDIR,
  	OPT_WORKDIR,
  	OPT_DEFAULT_PERMISSIONS,
++<<<<<<< HEAD
++=======
+ 	OPT_REDIRECT_DIR,
+ 	OPT_INDEX_ON,
+ 	OPT_INDEX_OFF,
++>>>>>>> 438c84c2f0c7 (ovl: don't follow redirects if redirect_dir=off)
  	OPT_ERR,
  };
  
@@@ -812,6 -370,9 +870,12 @@@ static const match_table_t ovl_tokens 
  	{OPT_UPPERDIR,			"upperdir=%s"},
  	{OPT_WORKDIR,			"workdir=%s"},
  	{OPT_DEFAULT_PERMISSIONS,	"default_permissions"},
++<<<<<<< HEAD
++=======
+ 	{OPT_REDIRECT_DIR,		"redirect_dir=%s"},
+ 	{OPT_INDEX_ON,			"index=on"},
+ 	{OPT_INDEX_OFF,			"index=off"},
++>>>>>>> 438c84c2f0c7 (ovl: don't follow redirects if redirect_dir=off)
  	{OPT_ERR,			NULL}
  };
  
@@@ -876,6 -464,21 +967,24 @@@ static int ovl_parse_opt(char *opt, str
  			config->default_permissions = true;
  			break;
  
++<<<<<<< HEAD
++=======
+ 		case OPT_REDIRECT_DIR:
+ 			kfree(config->redirect_mode);
+ 			config->redirect_mode = match_strdup(&args[0]);
+ 			if (!config->redirect_mode)
+ 				return -ENOMEM;
+ 			break;
+ 
+ 		case OPT_INDEX_ON:
+ 			config->index = true;
+ 			break;
+ 
+ 		case OPT_INDEX_OFF:
+ 			config->index = false;
+ 			break;
+ 
++>>>>>>> 438c84c2f0c7 (ovl: don't follow redirects if redirect_dir=off)
  		default:
  			pr_err("overlayfs: unrecognized mount option \"%s\" or missing value\n", p);
  			return -EINVAL;
@@@ -1360,90 -1139,120 +1469,152 @@@ static int ovl_fill_super(struct super_
  	}
  
  	err = -EINVAL;
 -	sb->s_stack_depth++;
 -	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
 +	*overlay_stack_depth += 1;
 +	if (*overlay_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
  		pr_err("overlayfs: maximum fs stacking depth exceeded\n");
 -		goto out_err;
 +		goto out_put_lowerpath;
  	}
  
 -	err = ovl_get_lower_layers(ofs, stack, numlower);
 -	if (err)
 -		goto out_err;
 -
 -	err = -ENOMEM;
 -	oe = ovl_alloc_entry(numlower);
 -	if (!oe)
 -		goto out_err;
 -
 +	if (ufs->config.upperdir) {
 +		ufs->upper_mnt = clone_private_mount(&upperpath);
 +		err = PTR_ERR(ufs->upper_mnt);
 +		if (IS_ERR(ufs->upper_mnt)) {
 +			pr_err("overlayfs: failed to clone upperpath\n");
 +			goto out_put_lowerpath;
 +		}
 +		/* Don't inherit atime flags */
 +		ufs->upper_mnt->mnt_flags &= ~(MNT_NOATIME | MNT_NODIRATIME | MNT_RELATIME);
 +
 +		sb->s_time_gran = ufs->upper_mnt->mnt_sb->s_time_gran;
 +
++<<<<<<< HEAD
 +		ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
 +		err = PTR_ERR(ufs->workdir);
 +		if (IS_ERR(ufs->workdir)) {
 +			pr_warn("overlayfs: failed to create directory %s/%s (errno: %i); mounting read-only\n",
 +				ufs->config.workdir, OVL_WORKDIR_NAME, -err);
 +			sb->s_flags |= MS_RDONLY;
 +			ufs->workdir = NULL;
++=======
+ 	for (i = 0; i < numlower; i++) {
+ 		oe->lowerstack[i].dentry = dget(stack[i].dentry);
+ 		oe->lowerstack[i].layer = &ofs->lower_layers[i];
+ 	}
+ 
+ 	if (remote)
+ 		sb->s_d_op = &ovl_reval_dentry_operations;
+ 	else
+ 		sb->s_d_op = &ovl_dentry_operations;
+ 
+ out:
+ 	for (i = 0; i < numlower; i++)
+ 		path_put(&stack[i]);
+ 	kfree(stack);
+ 	kfree(lowertmp);
+ 
+ 	return oe;
+ 
+ out_err:
+ 	oe = ERR_PTR(err);
+ 	goto out;
+ }
+ 
+ static int ovl_fill_super(struct super_block *sb, void *data, int silent)
+ {
+ 	struct path upperpath = { };
+ 	struct dentry *root_dentry;
+ 	struct ovl_entry *oe;
+ 	struct ovl_fs *ofs;
+ 	struct cred *cred;
+ 	int err;
+ 
+ 	err = -ENOMEM;
+ 	ofs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
+ 	if (!ofs)
+ 		goto out;
+ 
+ 	ofs->creator_cred = cred = prepare_creds();
+ 	if (!cred)
+ 		goto out_err;
+ 
+ 	ofs->config.index = ovl_index_def;
+ 	err = ovl_parse_opt((char *) data, &ofs->config);
+ 	if (err)
+ 		goto out_err;
+ 
+ 	err = -EINVAL;
+ 	if (!ofs->config.lowerdir) {
+ 		if (!silent)
+ 			pr_err("overlayfs: missing 'lowerdir'\n");
+ 		goto out_err;
+ 	}
+ 
+ 	sb->s_stack_depth = 0;
+ 	sb->s_maxbytes = MAX_LFS_FILESIZE;
+ 	if (ofs->config.upperdir) {
+ 		if (!ofs->config.workdir) {
+ 			pr_err("overlayfs: missing 'workdir'\n");
+ 			goto out_err;
++>>>>>>> 438c84c2f0c7 (ovl: don't follow redirects if redirect_dir=off)
  		}
  
 -		err = ovl_get_upper(ofs, &upperpath);
 -		if (err)
 -			goto out_err;
 -
 -		err = ovl_get_workdir(ofs, &upperpath);
 -		if (err)
 -			goto out_err;
 +		/*
 +		 * Upper should support d_type, else whiteouts are visible.
 +		 * Given workdir and upper are on same fs, we can do
 +		 * iterate_dir() on workdir. This check requires successful
 +		 * creation of workdir in previous step.
 +		 */
 +		if (ufs->workdir) {
 +			err = ovl_check_d_type_supported(&workpath);
 +			if (err < 0)
 +				goto out_put_workdir;
 +
 +			/*
 +			 * Warn instead of error to avoid breaking previously
 +			 * working configurations over upgrade. If d_type
 +			 * is not supported, whiteouts will become visible
 +			 * to user space.
 +			 */
 +			if (!err)
 +				pr_warn("overlayfs: upper fs needs to support d_type. This is an invalid configuration.\n");
 +		}
 +	}
  
 -		if (!ofs->workdir)
 -			sb->s_flags |= SB_RDONLY;
 +	err = -ENOMEM;
 +	ufs->lower_mnt = kcalloc(numlower, sizeof(struct vfsmount *), GFP_KERNEL);
 +	if (ufs->lower_mnt == NULL)
 +		goto out_put_workdir;
 +	for (i = 0; i < numlower; i++) {
 +		struct vfsmount *mnt = clone_private_mount(&stack[i]);
  
 -		sb->s_stack_depth = ofs->upper_mnt->mnt_sb->s_stack_depth;
 -		sb->s_time_gran = ofs->upper_mnt->mnt_sb->s_time_gran;
 +		err = PTR_ERR(mnt);
 +		if (IS_ERR(mnt)) {
 +			pr_err("overlayfs: failed to clone lowerpath\n");
 +			goto out_put_lower_mnt;
 +		}
 +		/*
 +		 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
 +		 * will fail instead of modifying lower fs.
 +		 */
 +		mnt->mnt_flags |= MNT_READONLY | MNT_NOATIME;
  
 +		ufs->lower_mnt[ufs->numlower] = mnt;
 +		ufs->numlower++;
  	}
 -	oe = ovl_get_lowerstack(sb, ofs);
 -	err = PTR_ERR(oe);
 -	if (IS_ERR(oe))
 -		goto out_err;
  
  	/* If the upper fs is nonexistent, we mark overlayfs r/o too */
 -	if (!ofs->upper_mnt)
 -		sb->s_flags |= SB_RDONLY;
 -	else if (ofs->upper_mnt->mnt_sb != ofs->same_sb)
 -		ofs->same_sb = NULL;
 -
 -	if (!(ovl_force_readonly(ofs)) && ofs->config.index) {
 -		err = ovl_get_indexdir(ofs, oe, &upperpath);
 -		if (err)
 -			goto out_free_oe;
 +	if (!ufs->upper_mnt)
 +		sb->s_flags |= MS_RDONLY;
  
 -		if (!ofs->indexdir)
 -			sb->s_flags |= SB_RDONLY;
 -	}
 +	if (remote)
 +		sb->s_d_op = &ovl_reval_dentry_operations.ops;
 +	else
 +		sb->s_d_op = &ovl_dentry_operations.ops;
  
 -	/* Show index=off/on in /proc/mounts for any of the reasons above */
 -	if (!ofs->indexdir)
 -		ofs->config.index = false;
 +	err = -ENOMEM;
 +	ufs->creator_cred = cred = prepare_creds();
 +	if (!cred)
 +		goto out_put_lower_mnt;
  
  	/* Never override disk quota limits or use reserved space */
  	cap_lower(cred->cap_effective, CAP_SYS_RESOURCE);
* Unmerged path fs/overlayfs/namei.c
* Unmerged path fs/overlayfs/ovl_entry.h
diff --git a/Documentation/filesystems/overlayfs.txt b/Documentation/filesystems/overlayfs.txt
index a2ce5b7adee5..a1facfc3d887 100644
--- a/Documentation/filesystems/overlayfs.txt
+++ b/Documentation/filesystems/overlayfs.txt
@@ -138,6 +138,40 @@ Readdir on directories that are not merged is simply handled by the
 underlying directory (upper or lower).
 
 
+There are several ways to tune the "redirect_dir" feature.
+
+Kernel config options:
+
+- OVERLAY_FS_REDIRECT_DIR:
+    If this is enabled, then redirect_dir is turned on by  default.
+- OVERLAY_FS_REDIRECT_ALWAYS_FOLLOW:
+    If this is enabled, then redirects are always followed by default. Enabling
+    this results in a less secure configuration.  Enable this option only when
+    worried about backward compatibility with kernels that have the redirect_dir
+    feature and follow redirects even if turned off.
+
+Module options (can also be changed through /sys/module/overlay/parameters/*):
+
+- "redirect_dir=BOOL":
+    See OVERLAY_FS_REDIRECT_DIR kernel config option above.
+- "redirect_always_follow=BOOL":
+    See OVERLAY_FS_REDIRECT_ALWAYS_FOLLOW kernel config option above.
+- "redirect_max=NUM":
+    The maximum number of bytes in an absolute redirect (default is 256).
+
+Mount options:
+
+- "redirect_dir=on":
+    Redirects are enabled.
+- "redirect_dir=follow":
+    Redirects are not created, but followed.
+- "redirect_dir=off":
+    Redirects are not created and only followed if "redirect_always_follow"
+    feature is enabled in the kernel/module config.
+- "redirect_dir=nofollow":
+    Redirects are not created and not followed (equivalent to "redirect_dir=off"
+    if "redirect_always_follow" feature is not enabled).
+
 Non-directories
 ---------------
 
* Unmerged path fs/overlayfs/Kconfig
* Unmerged path fs/overlayfs/namei.c
* Unmerged path fs/overlayfs/ovl_entry.h
* Unmerged path fs/overlayfs/super.c
