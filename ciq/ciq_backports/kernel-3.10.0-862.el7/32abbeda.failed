scsi: cxlflash: Update send_tmf() parameters

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] cxlflash: Update send_tmf() parameters (Gustavo Duarte) [1456494]
Rebuild_FUZZ: 92.68%
commit-author Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
commit 32abbedaafde5a0c1edfd07369dde73a4fda2554
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/32abbeda.failed

The current send_tmf() implementation is based on the caller providing a
SCSI command reference. In reality all that is needed is a SCSI device
reference as the routine uses a private command.

Refactor send_tmf() to pass the private adapter configuration reference
and a SCSI device reference. As a nice side effect, this will ease the
burden of converting caller routines to be based solely off of a SCSI
device reference.

	Signed-off-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 32abbedaafde5a0c1edfd07369dde73a4fda2554)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/cxlflash/main.c
diff --cc drivers/scsi/cxlflash/main.c
index c68badcfa77f,7054e11f732a..000000000000
--- a/drivers/scsi/cxlflash/main.c
+++ b/drivers/scsi/cxlflash/main.c
@@@ -357,22 -459,21 +357,36 @@@ static void wait_resp(struct afu *afu, 
  
  /**
   * send_tmf() - sends a Task Management Function (TMF)
++<<<<<<< HEAD
 + * @afu:	AFU to checkout from.
 + * @scp:	SCSI command from stack.
++=======
+  * @cfg:	Internal structure associated with the host.
+  * @sdev:	SCSI device destined for TMF.
++>>>>>>> 32abbedaafde (scsi: cxlflash: Update send_tmf() parameters)
   * @tmfcmd:	TMF command to send.
   *
   * Return:
 - *	0 on success, SCSI_MLQUEUE_HOST_BUSY or -errno on failure
 + *	0 on success, SCSI_MLQUEUE_HOST_BUSY on failure
   */
- static int send_tmf(struct afu *afu, struct scsi_cmnd *scp, u64 tmfcmd)
+ static int send_tmf(struct cxlflash_cfg *cfg, struct scsi_device *sdev,
+ 		    u64 tmfcmd)
  {
++<<<<<<< HEAD
 +	struct afu_cmd *cmd;
 +
 +	u32 port_sel = scp->device->channel + 1;
 +	short lflag = 0;
 +	struct Scsi_Host *host = scp->device->host;
 +	struct cxlflash_cfg *cfg = (struct cxlflash_cfg *)host->hostdata;
 +	struct device *dev = &cfg->dev->dev;
++=======
+ 	struct afu *afu = cfg->afu;
+ 	struct afu_cmd *cmd = NULL;
+ 	struct device *dev = &cfg->dev->dev;
+ 	struct hwq *hwq = get_hwq(afu, PRIMARY_HWQ);
+ 	char *buf = NULL;
++>>>>>>> 32abbedaafde (scsi: cxlflash: Update send_tmf() parameters)
  	ulong lock_flags;
  	int rc = 0;
  	ulong to;
@@@ -391,28 -495,23 +405,39 @@@
  						  !cfg->tmf_active,
  						  cfg->tmf_slock);
  	cfg->tmf_active = true;
 +	cmd->cmd_tmf = true;
  	spin_unlock_irqrestore(&cfg->tmf_slock, lock_flags);
  
++<<<<<<< HEAD
 +	cmd->rcb.ctx_id = afu->ctx_hndl;
 +	cmd->rcb.port_sel = port_sel;
 +	cmd->rcb.lun_id = lun_to_lunid(scp->device->lun);
 +
 +	lflag = SISL_REQ_FLAGS_TMF_CMD;
 +
++=======
+ 	cmd->parent = afu;
+ 	cmd->cmd_tmf = true;
+ 	cmd->hwq_index = hwq->index;
+ 
+ 	cmd->rcb.ctx_id = hwq->ctx_hndl;
+ 	cmd->rcb.msi = SISL_MSI_RRQ_UPDATED;
+ 	cmd->rcb.port_sel = CHAN2PORTMASK(sdev->channel);
+ 	cmd->rcb.lun_id = lun_to_lunid(sdev->lun);
++>>>>>>> 32abbedaafde (scsi: cxlflash: Update send_tmf() parameters)
  	cmd->rcb.req_flags = (SISL_REQ_FLAGS_PORT_LUN_ID |
 -			      SISL_REQ_FLAGS_SUP_UNDERRUN |
 -			      SISL_REQ_FLAGS_TMF_CMD);
 +			      SISL_REQ_FLAGS_SUP_UNDERRUN | lflag);
 +
 +	/* Stash the scp in the reserved field, for reuse during interrupt */
 +	cmd->rcb.scp = scp;
 +
 +	/* Copy the CDB from the cmd passed in */
  	memcpy(cmd->rcb.cdb, &tmfcmd, sizeof(tmfcmd));
  
 -	rc = afu->send_cmd(afu, cmd);
 +	/* Send the command */
 +	rc = send_cmd(afu, cmd);
  	if (unlikely(rc)) {
 +		cmd_checkin(cmd);
  		spin_lock_irqsave(&cfg->tmf_slock, lock_flags);
  		cfg->tmf_active = false;
  		spin_unlock_irqrestore(&cfg->tmf_slock, lock_flags);
@@@ -1905,19 -2429,19 +1930,35 @@@ static void drain_ioctls(struct cxlflas
  static int cxlflash_eh_device_reset_handler(struct scsi_cmnd *scp)
  {
  	int rc = SUCCESS;
++<<<<<<< HEAD
 +	struct Scsi_Host *host = scp->device->host;
 +	struct cxlflash_cfg *cfg = (struct cxlflash_cfg *)host->hostdata;
 +	struct afu *afu = cfg->afu;
 +	int rcr = 0;
 +
 +	pr_debug("%s: (scp=%p) %d/%d/%d/%d "
 +		 "cdb=(%08X-%08X-%08X-%08X)\n", __func__, scp,
 +		 host->host_no, scp->device->channel,
 +		 scp->device->id, scp->device->lun,
 +		 get_unaligned_be32(&((u32 *)scp->cmnd)[0]),
 +		 get_unaligned_be32(&((u32 *)scp->cmnd)[1]),
 +		 get_unaligned_be32(&((u32 *)scp->cmnd)[2]),
 +		 get_unaligned_be32(&((u32 *)scp->cmnd)[3]));
++=======
+ 	struct scsi_device *sdev = scp->device;
+ 	struct Scsi_Host *host = sdev->host;
+ 	struct cxlflash_cfg *cfg = shost_priv(host);
+ 	struct device *dev = &cfg->dev->dev;
+ 	int rcr = 0;
+ 
+ 	dev_dbg(dev, "%s: (scp=%p) %d/%d/%d/%llu "
+ 		"cdb=(%08x-%08x-%08x-%08x)\n", __func__, scp, host->host_no,
+ 		sdev->channel, sdev->id, sdev->lun,
+ 		get_unaligned_be32(&((u32 *)scp->cmnd)[0]),
+ 		get_unaligned_be32(&((u32 *)scp->cmnd)[1]),
+ 		get_unaligned_be32(&((u32 *)scp->cmnd)[2]),
+ 		get_unaligned_be32(&((u32 *)scp->cmnd)[3]));
++>>>>>>> 32abbedaafde (scsi: cxlflash: Update send_tmf() parameters)
  
  retry:
  	switch (cfg->state) {
* Unmerged path drivers/scsi/cxlflash/main.c
