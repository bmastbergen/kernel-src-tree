radix-tree: change naming conventions in radix_tree_shrink

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Matthew Wilcox <willy@linux.intel.com>
commit af49a63e101eb62376cc1d6bd25b97eb8c691d54
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/af49a63e.failed

Use the more standard 'node' and 'child' instead of 'to_free' and
'slot'.

	Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
	Cc: Konstantin Khlebnikov <koct9i@gmail.com>
	Cc: Kirill Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Jan Kara <jack@suse.com>
	Cc: Neil Brown <neilb@suse.de>
	Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit af49a63e101eb62376cc1d6bd25b97eb8c691d54)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/radix-tree.c
diff --cc lib/radix-tree.c
index 467d6e0a3a58,4b4a2a20a3d1..000000000000
--- a/lib/radix-tree.c
+++ b/lib/radix-tree.c
@@@ -1383,42 -1394,38 +1383,64 @@@ static inline bool radix_tree_shrink(st
  {
  	bool shrunk = false;
  
++<<<<<<< HEAD
 +	/* try to shrink tree height */
 +	while (root->height > 0) {
 +		struct radix_tree_node *to_free = root->rnode;
 +		struct radix_tree_node *slot;
 +
 +		BUG_ON(!radix_tree_is_indirect_ptr(to_free));
 +		to_free = indirect_to_ptr(to_free);
++=======
+ 	for (;;) {
+ 		struct radix_tree_node *node = root->rnode;
+ 		struct radix_tree_node *child;
+ 
+ 		if (!radix_tree_is_internal_node(node))
+ 			break;
+ 		node = entry_to_node(node);
++>>>>>>> af49a63e101e (radix-tree: change naming conventions in radix_tree_shrink)
  
  		/*
  		 * The candidate node has more than one child, or its child
 -		 * is not at the leftmost slot, or the child is a multiorder
 -		 * entry, we cannot shrink.
 +		 * is not at the leftmost slot, or it is a multiorder entry,
 +		 * we cannot shrink.
  		 */
- 		if (to_free->count != 1)
+ 		if (node->count != 1)
  			break;
- 		slot = to_free->slots[0];
- 		if (!slot)
+ 		child = node->slots[0];
+ 		if (!child)
  			break;
++<<<<<<< HEAD
++=======
+ 		if (!radix_tree_is_internal_node(child) && node->shift)
+ 			break;
+ 
+ 		if (radix_tree_is_internal_node(child))
+ 			entry_to_node(child)->parent = NULL;
++>>>>>>> af49a63e101e (radix-tree: change naming conventions in radix_tree_shrink)
  
  		/*
  		 * We don't need rcu_assign_pointer(), since we are simply
  		 * moving the node from one part of the tree to another: if it
  		 * was safe to dereference the old pointer to it
- 		 * (to_free->slots[0]), it will be safe to dereference the new
+ 		 * (node->slots[0]), it will be safe to dereference the new
  		 * one (root->rnode) as far as dependent read barriers go.
  		 */
++<<<<<<< HEAD
 +		if (root->height > 1) {
 +			if (!radix_tree_is_indirect_ptr(slot))
 +				break;
 +
 +			slot = indirect_to_ptr(slot);
 +			slot->parent = NULL;
 +			slot = ptr_to_indirect(slot);
 +		}
 +		root->rnode = slot;
 +		root->height--;
++=======
+ 		root->rnode = child;
++>>>>>>> af49a63e101e (radix-tree: change naming conventions in radix_tree_shrink)
  
  		/*
  		 * We have a dilemma here. The node's slot[0] must not be
@@@ -1438,11 -1445,10 +1460,16 @@@
  		 * also results in a stale slot). So tag the slot as indirect
  		 * to force callers to retry.
  		 */
++<<<<<<< HEAD
 +		if (root->height == 0)
 +			*((unsigned long *)&to_free->slots[0]) |=
 +						RADIX_TREE_INDIRECT_PTR;
++=======
+ 		if (!radix_tree_is_internal_node(child))
+ 			node->slots[0] = RADIX_TREE_RETRY;
++>>>>>>> af49a63e101e (radix-tree: change naming conventions in radix_tree_shrink)
  
- 		radix_tree_node_free(to_free);
+ 		radix_tree_node_free(node);
  		shrunk = true;
  	}
  
* Unmerged path lib/radix-tree.c
