qed: iWARP CM add active side connect

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Kalderon, Michal <Michal.Kalderon@cavium.com>
commit 4b0fdd7c8b757125ac7996617d914bbdb9e0348c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4b0fdd7c.failed

This patch implements the active side connect.
Offload a connection, process MPA reply and send RTR.
In some of the common passive/active functions, the active side
will work in blocking mode.

	Signed-off-by: Michal Kalderon <Michal.Kalderon@cavium.com>
	Signed-off-by: Yuval Mintz <Yuval.Mintz@cavium.com>
	Signed-off-by: Ariel Elior <Ariel.Elior@cavium.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4b0fdd7c8b757125ac7996617d914bbdb9e0348c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qed/qed_iwarp.c
#	drivers/net/ethernet/qlogic/qed/qed_iwarp.h
#	drivers/net/ethernet/qlogic/qed/qed_rdma.c
#	include/linux/qed/qed_roce_if.h
diff --cc drivers/net/ethernet/qlogic/qed/qed_rdma.c
index 9dc41a899ef2,6fb99518a61f..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_rdma.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_rdma.c
@@@ -2796,6 -1772,12 +2796,15 @@@ static const struct qed_rdma_ops qed_rd
  	.ll2_set_fragment_of_tx_packet = &qed_ll2_set_fragment_of_tx_packet,
  	.ll2_set_mac_filter = &qed_roce_ll2_set_mac_filter,
  	.ll2_get_stats = &qed_ll2_get_stats,
++<<<<<<< HEAD
++=======
+ 	.iwarp_connect = &qed_iwarp_connect,
+ 	.iwarp_create_listen = &qed_iwarp_create_listen,
+ 	.iwarp_destroy_listen = &qed_iwarp_destroy_listen,
+ 	.iwarp_accept = &qed_iwarp_accept,
+ 	.iwarp_reject = &qed_iwarp_reject,
+ 	.iwarp_send_rtr = &qed_iwarp_send_rtr,
++>>>>>>> 4b0fdd7c8b75 (qed: iWARP CM add active side connect)
  };
  
  const struct qed_rdma_ops *qed_get_rdma_ops(void)
diff --cc include/linux/qed/qed_roce_if.h
index cbb2ff0ce4bc,e9514a69b03f..000000000000
--- a/include/linux/qed/qed_roce_if.h
+++ b/include/linux/qed/qed_roce_if.h
@@@ -472,6 -470,90 +472,93 @@@ struct qed_rdma_counters_out_params 
  #define QED_ROCE_TX_HEAD_FAILURE        (1)
  #define QED_ROCE_TX_FRAG_FAILURE        (2)
  
++<<<<<<< HEAD:include/linux/qed/qed_roce_if.h
++=======
+ enum qed_iwarp_event_type {
+ 	QED_IWARP_EVENT_MPA_REQUEST,	  /* Passive side request received */
+ 	QED_IWARP_EVENT_PASSIVE_COMPLETE, /* ack on mpa response */
+ 	QED_IWARP_EVENT_ACTIVE_COMPLETE,  /* Active side reply received */
+ 	QED_IWARP_EVENT_ACTIVE_MPA_REPLY,
+ };
+ 
+ enum qed_tcp_ip_version {
+ 	QED_TCP_IPV4,
+ 	QED_TCP_IPV6,
+ };
+ 
+ struct qed_iwarp_cm_info {
+ 	enum qed_tcp_ip_version ip_version;
+ 	u32 remote_ip[4];
+ 	u32 local_ip[4];
+ 	u16 remote_port;
+ 	u16 local_port;
+ 	u16 vlan;
+ 	u8 ord;
+ 	u8 ird;
+ 	u16 private_data_len;
+ 	const void *private_data;
+ };
+ 
+ struct qed_iwarp_cm_event_params {
+ 	enum qed_iwarp_event_type event;
+ 	const struct qed_iwarp_cm_info *cm_info;
+ 	void *ep_context;	/* To be passed to accept call */
+ 	int status;
+ };
+ 
+ typedef int (*iwarp_event_handler) (void *context,
+ 				    struct qed_iwarp_cm_event_params *event);
+ 
+ struct qed_iwarp_connect_in {
+ 	iwarp_event_handler event_cb;
+ 	void *cb_context;
+ 	struct qed_rdma_qp *qp;
+ 	struct qed_iwarp_cm_info cm_info;
+ 	u16 mss;
+ 	u8 remote_mac_addr[ETH_ALEN];
+ 	u8 local_mac_addr[ETH_ALEN];
+ };
+ 
+ struct qed_iwarp_connect_out {
+ 	void *ep_context;
+ };
+ 
+ struct qed_iwarp_listen_in {
+ 	iwarp_event_handler event_cb;
+ 	void *cb_context;	/* passed to event_cb */
+ 	u32 max_backlog;
+ 	enum qed_tcp_ip_version ip_version;
+ 	u32 ip_addr[4];
+ 	u16 port;
+ 	u16 vlan;
+ };
+ 
+ struct qed_iwarp_listen_out {
+ 	void *handle;
+ };
+ 
+ struct qed_iwarp_accept_in {
+ 	void *ep_context;
+ 	void *cb_context;
+ 	struct qed_rdma_qp *qp;
+ 	const void *private_data;
+ 	u16 private_data_len;
+ 	u8 ord;
+ 	u8 ird;
+ };
+ 
+ struct qed_iwarp_reject_in {
+ 	void *ep_context;
+ 	void *cb_context;
+ 	const void *private_data;
+ 	u16 private_data_len;
+ };
+ 
+ struct qed_iwarp_send_rtr_in {
+ 	void *ep_context;
+ };
+ 
++>>>>>>> 4b0fdd7c8b75 (qed: iWARP CM add active side connect):include/linux/qed/qed_rdma_if.h
  struct qed_roce_ll2_header {
  	void *vaddr;
  	dma_addr_t baddr;
@@@ -585,20 -633,51 +672,67 @@@ struct qed_rdma_ops 
  	int (*rdma_deregister_tid)(void *rdma_cxt, u32 itid);
  	int (*rdma_alloc_tid)(void *rdma_cxt, u32 *itid);
  	void (*rdma_free_tid)(void *rdma_cxt, u32 itid);
++<<<<<<< HEAD:include/linux/qed/qed_roce_if.h
 +	int (*roce_ll2_start)(struct qed_dev *cdev,
 +			      struct qed_roce_ll2_params *params);
 +	int (*roce_ll2_stop)(struct qed_dev *cdev);
 +	int (*roce_ll2_tx)(struct qed_dev *cdev,
 +			   struct qed_roce_ll2_packet *packet,
 +			   struct qed_roce_ll2_tx_params *params);
 +	int (*roce_ll2_post_rx_buffer)(struct qed_dev *cdev,
 +				       struct qed_roce_ll2_buffer *buf,
 +				       u64 cookie, u8 notify_fw);
 +	int (*roce_ll2_set_mac_filter)(struct qed_dev *cdev,
 +				       u8 *old_mac_address,
 +				       u8 *new_mac_address);
 +	int (*roce_ll2_stats)(struct qed_dev *cdev,
 +			      struct qed_ll2_stats *stats);
++=======
+ 
+ 	int (*ll2_acquire_connection)(void *rdma_cxt,
+ 				      struct qed_ll2_acquire_data *data);
+ 
+ 	int (*ll2_establish_connection)(void *rdma_cxt, u8 connection_handle);
+ 	int (*ll2_terminate_connection)(void *rdma_cxt, u8 connection_handle);
+ 	void (*ll2_release_connection)(void *rdma_cxt, u8 connection_handle);
+ 
+ 	int (*ll2_prepare_tx_packet)(void *rdma_cxt,
+ 				     u8 connection_handle,
+ 				     struct qed_ll2_tx_pkt_info *pkt,
+ 				     bool notify_fw);
+ 
+ 	int (*ll2_set_fragment_of_tx_packet)(void *rdma_cxt,
+ 					     u8 connection_handle,
+ 					     dma_addr_t addr,
+ 					     u16 nbytes);
+ 	int (*ll2_post_rx_buffer)(void *rdma_cxt, u8 connection_handle,
+ 				  dma_addr_t addr, u16 buf_len, void *cookie,
+ 				  u8 notify_fw);
+ 	int (*ll2_get_stats)(void *rdma_cxt,
+ 			     u8 connection_handle,
+ 			     struct qed_ll2_stats *p_stats);
+ 	int (*ll2_set_mac_filter)(struct qed_dev *cdev,
+ 				  u8 *old_mac_address, u8 *new_mac_address);
+ 
+ 	int (*iwarp_connect)(void *rdma_cxt,
+ 			     struct qed_iwarp_connect_in *iparams,
+ 			     struct qed_iwarp_connect_out *oparams);
+ 
+ 	int (*iwarp_create_listen)(void *rdma_cxt,
+ 				   struct qed_iwarp_listen_in *iparams,
+ 				   struct qed_iwarp_listen_out *oparams);
+ 
+ 	int (*iwarp_accept)(void *rdma_cxt,
+ 			    struct qed_iwarp_accept_in *iparams);
+ 
+ 	int (*iwarp_reject)(void *rdma_cxt,
+ 			    struct qed_iwarp_reject_in *iparams);
+ 
+ 	int (*iwarp_destroy_listen)(void *rdma_cxt, void *handle);
+ 
+ 	int (*iwarp_send_rtr)(void *rdma_cxt,
+ 			      struct qed_iwarp_send_rtr_in *iparams);
++>>>>>>> 4b0fdd7c8b75 (qed: iWARP CM add active side connect):include/linux/qed/qed_rdma_if.h
  };
  
  const struct qed_rdma_ops *qed_get_rdma_ops(void);
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_iwarp.c
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_iwarp.h
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_iwarp.c
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_iwarp.h
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_rdma.c
* Unmerged path include/linux/qed/qed_roce_if.h
