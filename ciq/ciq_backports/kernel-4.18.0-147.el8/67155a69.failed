drm/i915: Don't pass plane state to skl_compute_plane_wm()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit 67155a6996841b5167c441bff2724ca86fdd0a2b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/67155a69.failed

skl_compute_plane_wm() doesn't actually need the plane state. While
it would make logically sense to pass it, we shall need to reuse
skl_compute_plane_wm() to compute the minimum ddb allocation for
the cursor before the cursor may be enabled. Thus we can't rely
on the plane state. The alternative would be to duplicate a lot of
the wm calculations for the cursor ddb allocation case, which doens't
appeal to me.

	Cc: Neel Desai <neel.desai@intel.com>
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190312205844.6339-3-ville.syrjala@linux.intel.com
	Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
(cherry picked from commit 67155a6996841b5167c441bff2724ca86fdd0a2b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_pm.c
diff --cc drivers/gpu/drm/i915/intel_pm.c
index a1b763e0c3a9,971f8ab127be..000000000000
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@@ -4590,29 -4685,31 +4590,47 @@@ skl_compute_plane_wm_params(const struc
  	return 0;
  }
  
 -static bool skl_wm_has_lines(struct drm_i915_private *dev_priv, int level)
 +static int skl_compute_plane_wm(const struct drm_i915_private *dev_priv,
 +				struct intel_crtc_state *cstate,
 +				const struct intel_plane_state *intel_pstate,
 +				uint16_t ddb_allocation,
 +				int level,
 +				const struct skl_wm_params *wp,
 +				const struct skl_wm_level *result_prev,
 +				struct skl_wm_level *result /* out */)
  {
++<<<<<<< HEAD
 +	const struct drm_plane_state *pstate = &intel_pstate->base;
 +	uint32_t latency = dev_priv->wm.skl_latency[level];
++=======
+ 	if (INTEL_GEN(dev_priv) >= 10 || IS_GEMINILAKE(dev_priv))
+ 		return true;
+ 
+ 	/* The number of lines are ignored for the level 0 watermark. */
+ 	return level > 0;
+ }
+ 
+ static void skl_compute_plane_wm(const struct intel_crtc_state *cstate,
+ 				 int level,
+ 				 const struct skl_wm_params *wp,
+ 				 const struct skl_wm_level *result_prev,
+ 				 struct skl_wm_level *result /* out */)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(cstate->base.crtc->dev);
+ 	u32 latency = dev_priv->wm.skl_latency[level];
++>>>>>>> 67155a699684 (drm/i915: Don't pass plane state to skl_compute_plane_wm())
  	uint_fixed_16_16_t method1, method2;
  	uint_fixed_16_16_t selected_result;
 -	u32 res_blocks, res_lines, min_ddb_alloc = 0;
 +	uint32_t res_blocks, res_lines;
 +	struct intel_atomic_state *state =
 +		to_intel_atomic_state(cstate->base.state);
 +	bool apply_memory_bw_wa = skl_needs_memory_bw_wa(state);
 +	uint32_t min_disp_buf_needed;
  
 -	if (latency == 0) {
 -		/* reject it */
 -		result->min_ddb_alloc = U16_MAX;
 -		return;
 +	if (latency == 0 ||
 +	    !intel_wm_plane_visible(cstate, intel_pstate)) {
 +		result->plane_en = false;
 +		return 0;
  	}
  
  	/* Display WA #1141: kbl,cfl */
@@@ -4721,80 -4805,39 +4739,94 @@@
  	}
  
  	/*
 -	 * If res_lines is valid, assume we can use this watermark level
 -	 * for now.  We'll come back and disable it after we calculate the
 -	 * DDB allocation if it turns out we don't actually have enough
 -	 * blocks to satisfy it.
 +	 * Display WA #826 (SKL:ALL, BXT:ALL) & #1059 (CNL:A)
 +	 * disable wm level 1-7 on NV12 planes
  	 */
 +	if (wp->is_planar && level >= 1 &&
 +	    (IS_SKYLAKE(dev_priv) || IS_BROXTON(dev_priv) ||
 +	     IS_CNL_REVID(dev_priv, CNL_REVID_A0, CNL_REVID_A0))) {
 +		result->plane_en = false;
 +		return 0;
 +	}
 +
 +	/* The number of lines are ignored for the level 0 watermark. */
  	result->plane_res_b = res_blocks;
  	result->plane_res_l = res_lines;
 -	/* Bspec says: value >= plane ddb allocation -> invalid, hence the +1 here */
 -	result->min_ddb_alloc = max(min_ddb_alloc, res_blocks) + 1;
  	result->plane_en = true;
 +
 +	return 0;
  }
  
++<<<<<<< HEAD
 +static int
 +skl_compute_wm_levels(const struct drm_i915_private *dev_priv,
 +		      struct skl_ddb_allocation *ddb,
 +		      struct intel_crtc_state *cstate,
 +		      const struct intel_plane_state *intel_pstate,
++=======
+ static void
+ skl_compute_wm_levels(const struct intel_crtc_state *cstate,
++>>>>>>> 67155a699684 (drm/i915: Don't pass plane state to skl_compute_plane_wm())
  		      const struct skl_wm_params *wm_params,
 -		      struct skl_wm_level *levels)
 +		      struct skl_plane_wm *wm,
 +		      int plane_id)
  {
++<<<<<<< HEAD
 +	struct intel_crtc *intel_crtc = to_intel_crtc(cstate->base.crtc);
 +	struct drm_plane *plane = intel_pstate->base.plane;
 +	struct intel_plane *intel_plane = to_intel_plane(plane);
 +	uint16_t ddb_blocks;
 +	enum pipe pipe = intel_crtc->pipe;
++=======
+ 	struct drm_i915_private *dev_priv = to_i915(cstate->base.crtc->dev);
++>>>>>>> 67155a699684 (drm/i915: Don't pass plane state to skl_compute_plane_wm())
  	int level, max_level = ilk_wm_max_level(dev_priv);
 -	struct skl_wm_level *result_prev = &levels[0];
 +	enum plane_id intel_plane_id = intel_plane->id;
 +	int ret;
  
 -	for (level = 0; level <= max_level; level++) {
 -		struct skl_wm_level *result = &levels[level];
 +	if (WARN_ON(!intel_pstate->base.fb))
 +		return -EINVAL;
  
 +	ddb_blocks = plane_id ?
 +		     skl_ddb_entry_size(&ddb->uv_plane[pipe][intel_plane_id]) :
 +		     skl_ddb_entry_size(&ddb->plane[pipe][intel_plane_id]);
 +
 +	for (level = 0; level <= max_level; level++) {
 +		struct skl_wm_level *result = plane_id ? &wm->uv_wm[level] :
 +							  &wm->wm[level];
 +		struct skl_wm_level *result_prev;
 +
++<<<<<<< HEAD
 +		if (level)
 +			result_prev = plane_id ? &wm->uv_wm[level - 1] :
 +						  &wm->wm[level - 1];
 +		else
 +			result_prev = plane_id ? &wm->uv_wm[0] : &wm->wm[0];
++=======
+ 		skl_compute_plane_wm(cstate, level, wm_params,
+ 				     result_prev, result);
 -
 -		result_prev = result;
++>>>>>>> 67155a699684 (drm/i915: Don't pass plane state to skl_compute_plane_wm())
 +
 +		ret = skl_compute_plane_wm(dev_priv,
 +					   cstate,
 +					   intel_pstate,
 +					   ddb_blocks,
 +					   level,
 +					   wm_params,
 +					   result_prev,
 +					   result);
 +		if (ret)
 +			return ret;
  	}
 +
 +	if (intel_pstate->base.fb->format->format == DRM_FORMAT_NV12)
 +		wm->is_planar = true;
 +
 +	return 0;
  }
  
 -static u32
 -skl_compute_linetime_wm(const struct intel_crtc_state *cstate)
 +static uint32_t
 +skl_compute_linetime_wm(struct intel_crtc_state *cstate)
  {
  	struct drm_atomic_state *state = cstate->base.state;
  	struct drm_i915_private *dev_priv = to_i915(state->dev);
@@@ -4859,16 -4904,118 +4891,81 @@@ static void skl_compute_transition_wm(s
  
  	}
  
 -	/*
 -	 * Just assume we can enable the transition watermark.  After
 -	 * computing the DDB we'll come back and disable it if that
 -	 * assumption turns out to be false.
 -	 */
 -	wm->trans_wm.plane_res_b = res_blocks + 1;
 -	wm->trans_wm.plane_en = true;
 -}
 +	res_blocks += 1;
  
++<<<<<<< HEAD
 +	if (res_blocks < ddb_allocation) {
 +		trans_wm->plane_res_b = res_blocks;
 +		trans_wm->plane_en = true;
 +		return;
++=======
+ static int skl_build_plane_wm_single(struct intel_crtc_state *crtc_state,
+ 				     const struct intel_plane_state *plane_state,
+ 				     enum plane_id plane_id, int color_plane)
+ {
+ 	struct skl_plane_wm *wm = &crtc_state->wm.skl.optimal.planes[plane_id];
+ 	struct skl_wm_params wm_params;
+ 	int ret;
+ 
+ 	ret = skl_compute_plane_wm_params(crtc_state, plane_state,
+ 					  &wm_params, color_plane);
+ 	if (ret)
+ 		return ret;
+ 
+ 	skl_compute_wm_levels(crtc_state, &wm_params, wm->wm);
+ 	skl_compute_transition_wm(crtc_state, &wm_params, wm);
+ 
+ 	return 0;
+ }
+ 
+ static int skl_build_plane_wm_uv(struct intel_crtc_state *crtc_state,
+ 				 const struct intel_plane_state *plane_state,
+ 				 enum plane_id plane_id)
+ {
+ 	struct skl_plane_wm *wm = &crtc_state->wm.skl.optimal.planes[plane_id];
+ 	struct skl_wm_params wm_params;
+ 	int ret;
+ 
+ 	wm->is_planar = true;
+ 
+ 	/* uv plane watermarks must also be validated for NV12/Planar */
+ 	ret = skl_compute_plane_wm_params(crtc_state, plane_state,
+ 					  &wm_params, 1);
+ 	if (ret)
+ 		return ret;
+ 
+ 	skl_compute_wm_levels(crtc_state, &wm_params, wm->uv_wm);
+ 
+ 	return 0;
+ }
+ 
+ static int skl_build_plane_wm(struct skl_pipe_wm *pipe_wm,
+ 			      struct intel_crtc_state *crtc_state,
+ 			      const struct intel_plane_state *plane_state)
+ {
+ 	struct intel_plane *plane = to_intel_plane(plane_state->base.plane);
+ 	const struct drm_framebuffer *fb = plane_state->base.fb;
+ 	enum plane_id plane_id = plane->id;
+ 	int ret;
+ 
+ 	if (!intel_wm_plane_visible(crtc_state, plane_state))
+ 		return 0;
+ 
+ 	ret = skl_build_plane_wm_single(crtc_state, plane_state,
+ 					plane_id, 0);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (fb->format->is_yuv && fb->format->num_planes > 1) {
+ 		ret = skl_build_plane_wm_uv(crtc_state, plane_state,
+ 					    plane_id);
+ 		if (ret)
+ 			return ret;
++>>>>>>> 67155a699684 (drm/i915: Don't pass plane state to skl_compute_plane_wm())
  	}
  
 -	return 0;
 -}
 -
 -static int icl_build_plane_wm(struct skl_pipe_wm *pipe_wm,
 -			      struct intel_crtc_state *crtc_state,
 -			      const struct intel_plane_state *plane_state)
 -{
 -	enum plane_id plane_id = to_intel_plane(plane_state->base.plane)->id;
 -	int ret;
 -
 -	/* Watermarks calculated in master */
 -	if (plane_state->slave)
 -		return 0;
 -
 -	if (plane_state->linked_plane) {
 -		const struct drm_framebuffer *fb = plane_state->base.fb;
 -		enum plane_id y_plane_id = plane_state->linked_plane->id;
 -
 -		WARN_ON(!intel_wm_plane_visible(crtc_state, plane_state));
 -		WARN_ON(!fb->format->is_yuv ||
 -			fb->format->num_planes == 1);
 -
 -		ret = skl_build_plane_wm_single(crtc_state, plane_state,
 -						y_plane_id, 0);
 -		if (ret)
 -			return ret;
 -
 -		ret = skl_build_plane_wm_single(crtc_state, plane_state,
 -						plane_id, 1);
 -		if (ret)
 -			return ret;
 -	} else if (intel_wm_plane_visible(crtc_state, plane_state)) {
 -		ret = skl_build_plane_wm_single(crtc_state, plane_state,
 -						plane_id, 0);
 -		if (ret)
 -			return ret;
 -	}
 -
 -	return 0;
 +exit:
 +	trans_wm->plane_en = false;
  }
  
  static int skl_build_pipe_wm(struct intel_crtc_state *cstate,
* Unmerged path drivers/gpu/drm/i915/intel_pm.c
