net/ipv6: Remove ip_idx arg to in6_dump_addrs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [net] ipv6: Remove ip_idx arg to in6_dump_addrs (Petr Oros) [1700306]
Rebuild_FUZZ: 95.35%
commit-author David Ahern <dsahern@gmail.com>
commit fe884c2be0b329042eaf0371ebdbb636ba3ccc39
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/fe884c2b.failed

ip_idx is always 0 going into in6_dump_addrs; it is passed as a pointer
to save the last good index into cb. Since cb is already argument to
in6_dump_addrs, just save the value there.

	Signed-off-by: David Ahern <dsahern@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fe884c2be0b329042eaf0371ebdbb636ba3ccc39)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/addrconf.c
diff --cc net/ipv6/addrconf.c
index ff031adf9e83,6b659846ff8a..000000000000
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@@ -4943,26 -4953,21 +4943,31 @@@ static int inet6_fill_ifacaddr(struct s
  	return 0;
  }
  
 +enum addr_type_t {
 +	UNICAST_ADDR,
 +	MULTICAST_ADDR,
 +	ANYCAST_ADDR,
 +};
 +
  /* called with rcu_read_lock() */
  static int in6_dump_addrs(struct inet6_dev *idev, struct sk_buff *skb,
++<<<<<<< HEAD
 +			  struct netlink_callback *cb, enum addr_type_t type,
 +			  int s_ip_idx, int *p_ip_idx, int netnsid)
++=======
+ 			  struct netlink_callback *cb, int s_ip_idx,
+ 			  struct inet6_fill_args *fillargs)
++>>>>>>> fe884c2be0b3 (net/ipv6: Remove ip_idx arg to in6_dump_addrs)
  {
  	struct ifmcaddr6 *ifmca;
  	struct ifacaddr6 *ifaca;
+ 	int ip_idx = 0;
  	int err = 1;
- 	int ip_idx = *p_ip_idx;
  
  	read_lock_bh(&idev->lock);
 -	switch (fillargs->type) {
 +	switch (type) {
  	case UNICAST_ADDR: {
  		struct inet6_ifaddr *ifa;
 -		fillargs->event = RTM_NEWADDR;
  
  		/* unicast address incl. temp addr */
  		list_for_each_entry(ifa, &idev->addr_list, if_list) {
@@@ -5022,30 -5018,85 +5027,32 @@@ next
  static int inet6_dump_addr(struct sk_buff *skb, struct netlink_callback *cb,
  			   enum addr_type_t type)
  {
 -	const struct nlmsghdr *nlh = cb->nlh;
 -	struct inet6_fill_args fillargs = {
 -		.portid = NETLINK_CB(cb->skb).portid,
 -		.seq = cb->nlh->nlmsg_seq,
 -		.flags = NLM_F_MULTI,
 -		.netnsid = -1,
 -		.type = type,
 -	};
  	struct net *net = sock_net(skb->sk);
 +	struct nlattr *tb[IFA_MAX+1];
  	struct net *tgt_net = net;
++<<<<<<< HEAD
 +	int netnsid = -1;
++=======
+ 	int idx, s_idx, s_ip_idx;
++>>>>>>> fe884c2be0b3 (net/ipv6: Remove ip_idx arg to in6_dump_addrs)
  	int h, s_h;
- 	int idx, ip_idx;
- 	int s_idx, s_ip_idx;
  	struct net_device *dev;
  	struct inet6_dev *idev;
  	struct hlist_head *head;
  
  	s_h = cb->args[0];
  	s_idx = idx = cb->args[1];
- 	s_ip_idx = ip_idx = cb->args[2];
+ 	s_ip_idx = cb->args[2];
  
 -	if (cb->strict_check) {
 -		int err;
 +	if (nlmsg_parse(cb->nlh, sizeof(struct ifaddrmsg), tb, IFA_MAX,
 +			ifa_ipv6_policy, NULL) >= 0) {
 +		if (tb[IFA_TARGET_NETNSID]) {
 +			netnsid = nla_get_s32(tb[IFA_TARGET_NETNSID]);
  
 -		err = inet6_valid_dump_ifaddr_req(nlh, &fillargs, &tgt_net,
 -						  skb->sk, cb->extack);
 -		if (err < 0)
 -			return err;
 +			tgt_net = rtnl_get_net_ns_capable(skb->sk, netnsid);
 +			if (IS_ERR(tgt_net))
 +				return PTR_ERR(tgt_net);
 +		}
  	}
  
  	rcu_read_lock();
@@@ -5063,8 -5113,8 +5069,13 @@@
  			if (!idev)
  				goto cont;
  
++<<<<<<< HEAD
 +			if (in6_dump_addrs(idev, skb, cb, type,
 +					   s_ip_idx, &ip_idx, netnsid) < 0)
++=======
+ 			if (in6_dump_addrs(idev, skb, cb, s_ip_idx,
+ 					   &fillargs) < 0)
++>>>>>>> fe884c2be0b3 (net/ipv6: Remove ip_idx arg to in6_dump_addrs)
  				goto done;
  cont:
  			idx++;
@@@ -5074,8 -5124,7 +5085,12 @@@ done
  	rcu_read_unlock();
  	cb->args[0] = h;
  	cb->args[1] = idx;
++<<<<<<< HEAD
 +	cb->args[2] = ip_idx;
 +	if (netnsid >= 0)
++=======
+ 	if (fillargs.netnsid >= 0)
++>>>>>>> fe884c2be0b3 (net/ipv6: Remove ip_idx arg to in6_dump_addrs)
  		put_net(tgt_net);
  
  	return skb->len;
* Unmerged path net/ipv6/addrconf.c
