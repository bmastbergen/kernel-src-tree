drm/i915/selftests: Add live vma selftest

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit bb211c3d0c454a5088dfc94d3b3c3885e4d4935e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/bb211c3d.failed

Add a live selftest to excercise rotated/remapped vmas. We simply
write through the rotated/remapped vma, and confirm that the data
appears in the right page when read through the normal vma.

Not sure what the fallout of making all rotated/remapped vmas
mappable/fenceable would be, hence I just hacked it in the test.

v2: Grab rpm reference (Chris)
    GEM_BUG_ON(view.type not as expected) (Chris)
    Allow CAN_FENCE for rotated/remapped vmas (Chris)
    Update intel_plane_uses_fence() to ask for a fence
    only for normal vmas on gen4+
v3: Deal with intel_wakeref_t
v4: Rebase

	Cc: Chris Wilson <chris@chris-wilson.co.uk>
	Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190509122159.24376-4-ville.syrjala@linux.intel.com
	Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
(cherry picked from commit bb211c3d0c454a5088dfc94d3b3c3885e4d4935e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/i915_vma.c
#	drivers/gpu/drm/i915/selftests/i915_vma.c
diff --cc drivers/gpu/drm/i915/i915_vma.c
index 0531c01c3604,343736b2d602..000000000000
--- a/drivers/gpu/drm/i915/i915_vma.c
+++ b/drivers/gpu/drm/i915/i915_vma.c
@@@ -406,13 -483,6 +406,16 @@@ void __i915_vma_set_map_and_fenceable(s
  	GEM_BUG_ON(!i915_vma_is_ggtt(vma));
  	GEM_BUG_ON(!vma->fence_size);
  
++<<<<<<< HEAD
 +	/*
 +	 * Explicitly disable for rotated VMA since the display does not
 +	 * need the fence and the VMA is not accessible to other users.
 +	 */
 +	if (vma->ggtt_view.type == I915_GGTT_VIEW_ROTATED)
 +		return;
 +
++=======
++>>>>>>> bb211c3d0c45 (drm/i915/selftests: Add live vma selftest)
  	fenceable = (vma->node.size >= vma->fence_size &&
  		     IS_ALIGNED(vma->node.start, vma->fence_alignment));
  
diff --cc drivers/gpu/drm/i915/selftests/i915_vma.c
index e90f97236e50,0027c1fac336..000000000000
--- a/drivers/gpu/drm/i915/selftests/i915_vma.c
+++ b/drivers/gpu/drm/i915/selftests/i915_vma.c
@@@ -738,3 -835,144 +738,147 @@@ int i915_vma_mock_selftests(void
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int igt_vma_remapped_gtt(void *arg)
+ {
+ 	struct drm_i915_private *i915 = arg;
+ 	const struct intel_remapped_plane_info planes[] = {
+ 		{ .width = 1, .height = 1, .stride = 1 },
+ 		{ .width = 2, .height = 2, .stride = 2 },
+ 		{ .width = 4, .height = 4, .stride = 4 },
+ 		{ .width = 8, .height = 8, .stride = 8 },
+ 
+ 		{ .width = 3, .height = 5, .stride = 3 },
+ 		{ .width = 3, .height = 5, .stride = 4 },
+ 		{ .width = 3, .height = 5, .stride = 5 },
+ 
+ 		{ .width = 5, .height = 3, .stride = 5 },
+ 		{ .width = 5, .height = 3, .stride = 7 },
+ 		{ .width = 5, .height = 3, .stride = 9 },
+ 
+ 		{ .width = 4, .height = 6, .stride = 6 },
+ 		{ .width = 6, .height = 4, .stride = 6 },
+ 		{ }
+ 	}, *p;
+ 	enum i915_ggtt_view_type types[] = {
+ 		I915_GGTT_VIEW_ROTATED,
+ 		I915_GGTT_VIEW_REMAPPED,
+ 		0,
+ 	}, *t;
+ 	struct drm_i915_gem_object *obj;
+ 	intel_wakeref_t wakeref;
+ 	int err = 0;
+ 
+ 	obj = i915_gem_object_create_internal(i915, 10 * 10 * PAGE_SIZE);
+ 	if (IS_ERR(obj))
+ 		return PTR_ERR(obj);
+ 
+ 	mutex_lock(&i915->drm.struct_mutex);
+ 
+ 	wakeref = intel_runtime_pm_get(i915);
+ 
+ 	for (t = types; *t; t++) {
+ 		for (p = planes; p->width; p++) {
+ 			struct i915_ggtt_view view = {
+ 				.type = *t,
+ 				.rotated.plane[0] = *p,
+ 			};
+ 			struct i915_vma *vma;
+ 			u32 __iomem *map;
+ 			unsigned int x, y;
+ 			int err;
+ 
+ 			err = i915_gem_object_set_to_gtt_domain(obj, true);
+ 			if (err)
+ 				goto out;
+ 
+ 			vma = i915_gem_object_ggtt_pin(obj, &view, 0, 0, PIN_MAPPABLE);
+ 			if (IS_ERR(vma)) {
+ 				err = PTR_ERR(vma);
+ 				goto out;
+ 			}
+ 
+ 			GEM_BUG_ON(vma->ggtt_view.type != *t);
+ 
+ 			map = i915_vma_pin_iomap(vma);
+ 			i915_vma_unpin(vma);
+ 			if (IS_ERR(map)) {
+ 				err = PTR_ERR(map);
+ 				goto out;
+ 			}
+ 
+ 			for (y = 0 ; y < p->height; y++) {
+ 				for (x = 0 ; x < p->width; x++) {
+ 					unsigned int offset;
+ 					u32 val = y << 16 | x;
+ 
+ 					if (*t == I915_GGTT_VIEW_ROTATED)
+ 						offset = (x * p->height + y) * PAGE_SIZE;
+ 					else
+ 						offset = (y * p->width + x) * PAGE_SIZE;
+ 
+ 					iowrite32(val, &map[offset / sizeof(*map)]);
+ 				}
+ 			}
+ 
+ 			i915_vma_unpin_iomap(vma);
+ 
+ 			vma = i915_gem_object_ggtt_pin(obj, NULL, 0, 0, PIN_MAPPABLE);
+ 			if (IS_ERR(vma)) {
+ 				err = PTR_ERR(vma);
+ 				goto out;
+ 			}
+ 
+ 			GEM_BUG_ON(vma->ggtt_view.type != I915_GGTT_VIEW_NORMAL);
+ 
+ 			map = i915_vma_pin_iomap(vma);
+ 			i915_vma_unpin(vma);
+ 			if (IS_ERR(map)) {
+ 				err = PTR_ERR(map);
+ 				goto out;
+ 			}
+ 
+ 			for (y = 0 ; y < p->height; y++) {
+ 				for (x = 0 ; x < p->width; x++) {
+ 					unsigned int offset, src_idx;
+ 					u32 exp = y << 16 | x;
+ 					u32 val;
+ 
+ 					if (*t == I915_GGTT_VIEW_ROTATED)
+ 						src_idx = rotated_index(&view.rotated, 0, x, y);
+ 					else
+ 						src_idx = remapped_index(&view.remapped, 0, x, y);
+ 					offset = src_idx * PAGE_SIZE;
+ 
+ 					val = ioread32(&map[offset / sizeof(*map)]);
+ 					if (val != exp) {
+ 						pr_err("%s VMA write test failed, expected 0x%x, found 0x%x\n",
+ 						       *t == I915_GGTT_VIEW_ROTATED ? "Rotated" : "Remapped",
+ 						       val, exp);
+ 						i915_vma_unpin_iomap(vma);
+ 						goto out;
+ 					}
+ 				}
+ 			}
+ 			i915_vma_unpin_iomap(vma);
+ 		}
+ 	}
+ 
+ out:
+ 	intel_runtime_pm_put(i915, wakeref);
+ 	mutex_unlock(&i915->drm.struct_mutex);
+ 	i915_gem_object_put(obj);
+ 
+ 	return err;
+ }
+ 
+ int i915_vma_live_selftests(struct drm_i915_private *i915)
+ {
+ 	static const struct i915_subtest tests[] = {
+ 		SUBTEST(igt_vma_remapped_gtt),
+ 	};
+ 
+ 	return i915_subtests(tests, i915);
+ }
++>>>>>>> bb211c3d0c45 (drm/i915/selftests: Add live vma selftest)
* Unmerged path drivers/gpu/drm/i915/i915_vma.c
diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c
index 98867581a27e..1b9ec35aa5bb 100644
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@ -2115,7 +2115,9 @@ static bool intel_plane_uses_fence(const struct intel_plane_state *plane_state)
 	struct intel_plane *plane = to_intel_plane(plane_state->base.plane);
 	struct drm_i915_private *dev_priv = to_i915(plane->base.dev);
 
-	return INTEL_GEN(dev_priv) < 4 || plane->has_fbc;
+	return INTEL_GEN(dev_priv) < 4 ||
+		(plane->has_fbc &&
+		 plane_state->view.type == I915_GGTT_VIEW_NORMAL);
 }
 
 struct i915_vma *
diff --git a/drivers/gpu/drm/i915/selftests/i915_live_selftests.h b/drivers/gpu/drm/i915/selftests/i915_live_selftests.h
index a00e2bd08bce..5667fd908acc 100644
--- a/drivers/gpu/drm/i915/selftests/i915_live_selftests.h
+++ b/drivers/gpu/drm/i915/selftests/i915_live_selftests.h
@@ -15,6 +15,7 @@ selftest(workarounds, intel_workarounds_live_selftests)
 selftest(requests, i915_request_live_selftests)
 selftest(objects, i915_gem_object_live_selftests)
 selftest(dmabuf, i915_gem_dmabuf_live_selftests)
+selftest(vma, i915_vma_live_selftests)
 selftest(coherency, i915_gem_coherency_live_selftests)
 selftest(gtt, i915_gem_gtt_live_selftests)
 selftest(evict, i915_gem_evict_live_selftests)
* Unmerged path drivers/gpu/drm/i915/selftests/i915_vma.c
