locking/rwsem: Prevent decrement of reader count before increment

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Waiman Long <longman@redhat.com>
commit a9e9bcb45b1525ba7aea26ed9441e8632aeeda58
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/a9e9bcb4.failed

During my rwsem testing, it was found that after a down_read(), the
reader count may occasionally become 0 or even negative. Consequently,
a writer may steal the lock at that time and execute with the reader
in parallel thus breaking the mutual exclusion guarantee of the write
lock. In other words, both readers and writer can become rwsem owners
simultaneously.

The current reader wakeup code does it in one pass to clear waiter->task
and put them into wake_q before fully incrementing the reader count.
Once waiter->task is cleared, the corresponding reader may see it,
finish the critical section and do unlock to decrement the count before
the count is incremented. This is not a problem if there is only one
reader to wake up as the count has been pre-incremented by 1.  It is
a problem if there are more than one readers to be woken up and writer
can steal the lock.

The wakeup was actually done in 2 passes before the following v4.9 commit:

  70800c3c0cc5 ("locking/rwsem: Scan the wait_list for readers only once")

To fix this problem, the wakeup is now done in two passes
again. In the first pass, we collect the readers and count them.
The reader count is then fully incremented. In the second pass, the
waiter->task is then cleared and they are put into wake_q to be woken
up later.

	Signed-off-by: Waiman Long <longman@redhat.com>
	Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Davidlohr Bueso <dave@stgolabs.net>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Tim Chen <tim.c.chen@linux.intel.com>
	Cc: Will Deacon <will.deacon@arm.com>
	Cc: huang ying <huang.ying.caritas@gmail.com>
Fixes: 70800c3c0cc5 ("locking/rwsem: Scan the wait_list for readers only once")
Link: http://lkml.kernel.org/r/20190428212557.13482-2-longman@redhat.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit a9e9bcb45b1525ba7aea26ed9441e8632aeeda58)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/locking/rwsem-xadd.c
diff --cc kernel/locking/rwsem-xadd.c
index d663e90ae961,0b1f77957240..000000000000
--- a/kernel/locking/rwsem-xadd.c
+++ b/kernel/locking/rwsem-xadd.c
@@@ -211,19 -237,8 +237,22 @@@ static void __rwsem_mark_wake(struct rw
  		 * Ensure issuing the wakeup (either by us or someone else)
  		 * after setting the reader waiter to nil.
  		 */
 -		wake_q_add_safe(wake_q, tsk);
 +		wake_q_add(wake_q, tsk);
 +		/* wake_q_add() already take the task ref */
 +		put_task_struct(tsk);
  	}
++<<<<<<< HEAD
 +
 +	adjustment = woken * RWSEM_ACTIVE_READ_BIAS - adjustment;
 +	if (list_empty(&sem->wait_list)) {
 +		/* hit end of list above */
 +		adjustment -= RWSEM_WAITING_BIAS;
 +	}
 +
 +	if (adjustment)
 +		atomic_long_add(adjustment, &sem->count);
++=======
++>>>>>>> a9e9bcb45b15 (locking/rwsem: Prevent decrement of reader count before increment)
  }
  
  /*
* Unmerged path kernel/locking/rwsem-xadd.c
