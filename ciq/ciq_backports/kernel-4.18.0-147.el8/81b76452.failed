scsi: megaraid_sas: Rename scratch_pad registers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Shivasharan S <shivasharan.srikanteshwara@broadcom.com>
commit 81b7645223ea5935161c69fc022a75928a79ccd0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/81b76452.failed

Rename the scratch pad registers to match firmware headers.  No functional
change.

	Signed-off-by: Sumit Saxena <sumit.saxena@broadcom.com>
	Signed-off-by: Shivasharan S <shivasharan.srikanteshwara@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 81b7645223ea5935161c69fc022a75928a79ccd0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/megaraid/megaraid_sas_base.c
#	drivers/scsi/megaraid/megaraid_sas_fusion.c
diff --cc drivers/scsi/megaraid/megaraid_sas_base.c
index 8ebd23358c2e,3bbb07499556..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_base.c
+++ b/drivers/scsi/megaraid/megaraid_sas_base.c
@@@ -5439,10 -5394,10 +5439,17 @@@ static int megasas_init_fw(struct megas
  
  	fusion = instance->ctrl_context;
  
++<<<<<<< HEAD
 +	if (instance->adapter_type >= VENTURA_SERIES) {
 +		scratch_pad_3 =
 +			megasas_readl(&instance->reg_set->outbound_scratch_pad_3);
 +		instance->max_raid_mapsize = ((scratch_pad_3 >>
++=======
+ 	if (instance->adapter_type == VENTURA_SERIES) {
+ 		scratch_pad_2 =
+ 			readl(&instance->reg_set->outbound_scratch_pad_2);
+ 		instance->max_raid_mapsize = ((scratch_pad_2 >>
++>>>>>>> 81b7645223ea (scsi: megaraid_sas: Rename scratch_pad registers)
  			MR_MAX_RAID_MAP_SIZE_OFFSET_SHIFT) &
  			MR_MAX_RAID_MAP_SIZE_MASK);
  	}
@@@ -5453,8 -5408,8 +5460,13 @@@
  	if (msix_enable && !msix_disable) {
  		int irq_flags = PCI_IRQ_MSIX;
  
++<<<<<<< HEAD
 +		scratch_pad_2 = megasas_readl
 +			(&instance->reg_set->outbound_scratch_pad_2);
++=======
+ 		scratch_pad_1 = readl
+ 			(&instance->reg_set->outbound_scratch_pad_1);
++>>>>>>> 81b7645223ea (scsi: megaraid_sas: Rename scratch_pad registers)
  		/* Check max MSI-X vectors */
  		if (fusion) {
  			if (instance->adapter_type == THUNDERBOLT_SERIES) {
@@@ -5562,13 -5517,13 +5574,20 @@@
  	if (instance->instancet->init_adapter(instance))
  		goto fail_init_adapter;
  
++<<<<<<< HEAD
 +	if (instance->adapter_type >= VENTURA_SERIES) {
 +		scratch_pad_4 =
 +			megasas_readl(&instance->reg_set->outbound_scratch_pad_4);
 +		if ((scratch_pad_4 & MR_NVME_PAGE_SIZE_MASK) >=
++=======
+ 	if (instance->adapter_type == VENTURA_SERIES) {
+ 		scratch_pad_3 =
+ 			readl(&instance->reg_set->outbound_scratch_pad_3);
+ 		if ((scratch_pad_3 & MR_NVME_PAGE_SIZE_MASK) >=
++>>>>>>> 81b7645223ea (scsi: megaraid_sas: Rename scratch_pad registers)
  			MR_DEFAULT_NVME_PAGE_SHIFT)
  			instance->nvme_page_size =
- 				(1 << (scratch_pad_4 & MR_NVME_PAGE_SIZE_MASK));
+ 				(1 << (scratch_pad_3 & MR_NVME_PAGE_SIZE_MASK));
  
  		dev_info(&instance->pdev->dev,
  			 "NVME page size\t: (%d)\n", instance->nvme_page_size);
@@@ -6214,14 -6169,14 +6233,14 @@@ megasas_set_dma_mask(struct megasas_ins
  {
  	u64 consistent_mask;
  	struct pci_dev *pdev;
- 	u32 scratch_pad_2;
+ 	u32 scratch_pad_1;
  
  	pdev = instance->pdev;
 -	consistent_mask = (instance->adapter_type == VENTURA_SERIES) ?
 -				DMA_BIT_MASK(64) : DMA_BIT_MASK(32);
 +	consistent_mask = (instance->adapter_type >= VENTURA_SERIES) ?
 +				DMA_BIT_MASK(63) : DMA_BIT_MASK(32);
  
  	if (IS_DMA64) {
 -		if (dma_set_mask(&pdev->dev, DMA_BIT_MASK(64)) &&
 +		if (dma_set_mask(&pdev->dev, DMA_BIT_MASK(63)) &&
  		    dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32)))
  			goto fail_set_dma_mask;
  
@@@ -6232,13 -6187,13 +6251,18 @@@
  			 * If 32 bit DMA mask fails, then try for 64 bit mask
  			 * for FW capable of handling 64 bit DMA.
  			 */
++<<<<<<< HEAD
 +			scratch_pad_2 = megasas_readl
 +				(&instance->reg_set->outbound_scratch_pad_2);
++=======
+ 			scratch_pad_1 = readl
+ 				(&instance->reg_set->outbound_scratch_pad_1);
++>>>>>>> 81b7645223ea (scsi: megaraid_sas: Rename scratch_pad registers)
  
- 			if (!(scratch_pad_2 & MR_CAN_HANDLE_64_BIT_DMA_OFFSET))
+ 			if (!(scratch_pad_1 & MR_CAN_HANDLE_64_BIT_DMA_OFFSET))
  				goto fail_set_dma_mask;
  			else if (dma_set_mask_and_coherent(&pdev->dev,
 -							   DMA_BIT_MASK(64)))
 +							   DMA_BIT_MASK(63)))
  				goto fail_set_dma_mask;
  		}
  	} else if (dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32)))
diff --cc drivers/scsi/megaraid/megaraid_sas_fusion.c
index fba73bf0055e,b44a5fef5d9b..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c
+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c
@@@ -263,10 -262,10 +263,14 @@@ megasas_fusion_update_can_queue(struct 
  
  	reg_set = instance->reg_set;
  
- 	/* ventura FW does not fill outbound_scratch_pad_3 with queue depth */
+ 	/* ventura FW does not fill outbound_scratch_pad_2 with queue depth */
  	if (instance->adapter_type < VENTURA_SERIES)
  		cur_max_fw_cmds =
++<<<<<<< HEAD
 +		megasas_readl(&instance->reg_set->outbound_scratch_pad_3) & 0x00FFFF;
++=======
+ 		readl(&instance->reg_set->outbound_scratch_pad_2) & 0x00FFFF;
++>>>>>>> 81b7645223ea (scsi: megaraid_sas: Rename scratch_pad registers)
  
  	if (dual_qdepth_disable || !cur_max_fw_cmds)
  		cur_max_fw_cmds = instance->instancet->read_fw_status_reg(reg_set) & 0x00FFFF;
@@@ -986,10 -985,10 +990,15 @@@ megasas_ioc_init_fusion(struct megasas_
  
  	cmd = fusion->ioc_init_cmd;
  
++<<<<<<< HEAD
 +	scratch_pad_2 = megasas_readl
 +		(&instance->reg_set->outbound_scratch_pad_2);
++=======
+ 	scratch_pad_1 = readl
+ 		(&instance->reg_set->outbound_scratch_pad_1);
++>>>>>>> 81b7645223ea (scsi: megaraid_sas: Rename scratch_pad registers)
  
- 	cur_rdpq_mode = (scratch_pad_2 & MR_RDPQ_MODE_OFFSET) ? 1 : 0;
+ 	cur_rdpq_mode = (scratch_pad_1 & MR_RDPQ_MODE_OFFSET) ? 1 : 0;
  
  	if (instance->adapter_type == INVADER_SERIES) {
  		cur_fw_64bit_dma_capable =
@@@ -1660,8 -1659,8 +1669,13 @@@ megasas_init_adapter_fusion(struct mega
  
  	megasas_configure_queue_sizes(instance);
  
++<<<<<<< HEAD
 +	scratch_pad_2 = megasas_readl(&instance->reg_set->outbound_scratch_pad_2);
 +	/* If scratch_pad_2 & MEGASAS_MAX_CHAIN_SIZE_UNITS_MASK is set,
++=======
+ 	scratch_pad_1 = readl(&instance->reg_set->outbound_scratch_pad_1);
+ 	/* If scratch_pad_1 & MEGASAS_MAX_CHAIN_SIZE_UNITS_MASK is set,
++>>>>>>> 81b7645223ea (scsi: megaraid_sas: Rename scratch_pad registers)
  	 * Firmware support extended IO chain frame which is 4 times more than
  	 * legacy Firmware.
  	 * Legacy Firmware - Frame size is (8 * 128) = 1K
@@@ -3750,7 -3737,7 +3764,11 @@@ megasas_release_fusion(struct megasas_i
  static u32
  megasas_read_fw_status_reg_fusion(struct megasas_register_set __iomem *regs)
  {
++<<<<<<< HEAD
 +	return megasas_readl(&(regs)->outbound_scratch_pad);
++=======
+ 	return readl(&(regs)->outbound_scratch_pad_0);
++>>>>>>> 81b7645223ea (scsi: megaraid_sas: Rename scratch_pad registers)
  }
  
  /**
diff --git a/drivers/scsi/megaraid/megaraid_sas.h b/drivers/scsi/megaraid/megaraid_sas.h
index 58b34e31c497..12539f3f6ffb 100644
--- a/drivers/scsi/megaraid/megaraid_sas.h
+++ b/drivers/scsi/megaraid/megaraid_sas.h
@@ -1611,11 +1611,10 @@ struct megasas_register_set {
 
 	u32 	reserved_3[3];			/*00A4h*/
 
-	u32 	outbound_scratch_pad ;		/*00B0h*/
-	u32	outbound_scratch_pad_2;         /*00B4h*/
-	u32	outbound_scratch_pad_3;         /*00B8h*/
-	u32	outbound_scratch_pad_4;         /*00BCh*/
-
+	u32	outbound_scratch_pad_0;		/*00B0h*/
+	u32	outbound_scratch_pad_1;         /*00B4h*/
+	u32	outbound_scratch_pad_2;         /*00B8h*/
+	u32	outbound_scratch_pad_3;         /*00BCh*/
 
 	u32 	inbound_low_queue_port ;	/*00C0h*/
 
* Unmerged path drivers/scsi/megaraid/megaraid_sas_base.c
* Unmerged path drivers/scsi/megaraid/megaraid_sas_fusion.c
