x86/mm/fault: Allow stack access below %rsp

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [mm] x86/mm/fault: Allow stack access below rsp (Waiman Long) [1739341]
Rebuild_FUZZ: 98.82%
commit-author Waiman Long <longman@redhat.com>
commit 1d8ca3be86ebc6a38dad8236f45c7a9c61681e78
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/1d8ca3be.failed

The current x86 page fault handler allows stack access below the stack
pointer if it is no more than 64k+256 bytes. Any access beyond the 64k+
limit will cause a segmentation fault.

The gcc -fstack-check option generates code to probe the stack for
large stack allocation to see if the stack is accessible. The newer gcc
does that while updating the %rsp simultaneously. Older gcc's like gcc4
doesn't do that. As a result, an application compiled with an old gcc
and the -fstack-check option may fail to start at all:

  $ cat test.c
  int main() {
	char tmp[1024*128];
	printf("### ok\n");
	return 0;
  }

  $ gcc -fstack-check -g -o test test.c

  $ ./test
  Segmentation fault

The old binary was working in older kernels where expand_stack() was
somehow called before the check. But it is not working in newer kernels.
Besides, the 64k+ limit check is kind of crude and will not catch a
lot of mistakes that userspace applications may be misbehaving anyway.
I think the kernel isn't the right place for this kind of tests. We
should leave it to userspace instrumentation tools to perform them.

The 64k+ limit check is now removed to just let expand_stack() decide
if a segmentation fault should happen, when the RLIMIT_STACK limit is
exceeded, for example.

	Signed-off-by: Waiman Long <longman@redhat.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Rik van Riel <riel@surriel.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/1541535149-31963-1-git-send-email-longman@redhat.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 1d8ca3be86ebc6a38dad8236f45c7a9c61681e78)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/mm/fault.c
diff --cc arch/x86/mm/fault.c
index 47dac7a97b95,29525cf21100..000000000000
--- a/arch/x86/mm/fault.c
+++ b/arch/x86/mm/fault.c
@@@ -1308,23 -1377,11 +1308,26 @@@ retry
  	if (likely(vma->vm_start <= address))
  		goto good_area;
  	if (unlikely(!(vma->vm_flags & VM_GROWSDOWN))) {
 -		bad_area(regs, sw_error_code, address);
 +		bad_area(regs, error_code, address);
  		return;
  	}
++<<<<<<< HEAD
 +	if (error_code & X86_PF_USER) {
 +		/*
 +		 * Accessing the stack below %sp is always a bug.
 +		 * The large cushion allows instructions like enter
 +		 * and pusha to work. ("enter $65535, $31" pushes
 +		 * 32 pointers and then decrements %sp by 65535.)
 +		 */
 +		if (unlikely(address + 65536 + 32 * sizeof(unsigned long) < regs->sp)) {
 +			bad_area(regs, error_code, address);
 +			return;
 +		}
 +	}
++=======
++>>>>>>> 1d8ca3be86eb (x86/mm/fault: Allow stack access below %rsp)
  	if (unlikely(expand_stack(vma, address))) {
 -		bad_area(regs, sw_error_code, address);
 +		bad_area(regs, error_code, address);
  		return;
  	}
  
* Unmerged path arch/x86/mm/fault.c
