vxlan: vxlan_fdb_notify(): Make switchdev notification configurable

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Petr Machata <petrm@mellanox.com>
commit 0e6160f3f5a9a817c3100f02e1605c49cbb2fe78
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/0e6160f3.failed

In a following patch, vxlan is extended to allow hardware FDB learning.
For FDB entries learned this way, switchdev notifications should not be
sent again, because the driver already knows about these entries.

To that end, add an argument vxlan_fdb_notify() to determine whether
the switchdev notifications should be sent. Propagate the argument to
all call sites transitively, eventually passing true in all root calls.

	Signed-off-by: Petr Machata <petrm@mellanox.com>
	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0e6160f3f5a9a817c3100f02e1605c49cbb2fe78)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index 3e15026af84d,441290464912..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -3297,16 -3355,9 +3306,20 @@@ static int __vxlan_dev_create(struct ne
  
  	list_add(&vxlan->next, &vn->vxlan_list);
  	return 0;
 +
  errout:
 +	/* unregister_netdevice() destroys the default FDB entry with deletion
 +	 * notification. But the addition notification was not sent yet, so
 +	 * destroy the entry by hand here.
 +	 */
  	if (f)
++<<<<<<< HEAD
 +		vxlan_fdb_destroy(vxlan, f, false);
 +	if (unregister)
 +		unregister_netdevice(dev);
++=======
+ 		vxlan_fdb_destroy(vxlan, f, false, false);
++>>>>>>> 0e6160f3f5a9 (vxlan: vxlan_fdb_notify(): Make switchdev notification configurable)
  	return err;
  }
  
@@@ -3564,13 -3619,13 +3577,14 @@@ static int vxlan_changelink(struct net_
  					   vxlan->cfg.dst_port,
  					   old_dst.remote_vni,
  					   old_dst.remote_vni,
- 					   old_dst.remote_ifindex);
+ 					   old_dst.remote_ifindex,
+ 					   true);
  
  		if (!vxlan_addr_any(&dst->remote_ip)) {
 -			err = vxlan_fdb_create(vxlan, all_zeros_mac,
 +			err = vxlan_fdb_update(vxlan, all_zeros_mac,
  					       &dst->remote_ip,
  					       NUD_REACHABLE | NUD_PERMANENT,
 +					       NLM_F_APPEND | NLM_F_CREATE,
  					       vxlan->cfg.dst_port,
  					       dst->remote_vni,
  					       dst->remote_vni,
@@@ -3580,6 -3635,8 +3594,11 @@@
  				spin_unlock_bh(&vxlan->hash_lock);
  				return err;
  			}
++<<<<<<< HEAD
++=======
+ 			vxlan_fdb_notify(vxlan, f, first_remote_rtnl(f),
+ 					 RTM_NEWNEIGH, true);
++>>>>>>> 0e6160f3f5a9 (vxlan: vxlan_fdb_notify(): Make switchdev notification configurable)
  		}
  		spin_unlock_bh(&vxlan->hash_lock);
  	}
* Unmerged path drivers/net/vxlan.c
