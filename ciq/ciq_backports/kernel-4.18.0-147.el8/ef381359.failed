net/mlx5e: Replace egdev with indirect block notifications

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Oz Shlomo <ozsh@mellanox.com>
commit ef381359e3a81422cee85ddee1f7dc3ac90f3c38
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/ef381359.failed

Use TC indirect block notifications to offload filters that
are configured on higher level device interfaces (e.g. tunnel
devices). This mechanism replaces the current egdev implementation.

	Signed-off-by: Oz Shlomo <ozsh@mellanox.com>
	Reviewed-by: Eli Britstein <elibr@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit ef381359e3a81422cee85ddee1f7dc3ac90f3c38)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index 58cddf0a96a7,5cac4de435c9..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -912,32 -1027,19 +932,35 @@@ mlx5e_rep_setup_tc_cls_flower(struct ml
  {
  	switch (cls_flower->command) {
  	case TC_CLSFLOWER_REPLACE:
 -		return mlx5e_configure_flower(priv->netdev, priv, cls_flower,
 -					      flags);
 +		return mlx5e_configure_flower(priv, cls_flower, flags);
  	case TC_CLSFLOWER_DESTROY:
 -		return mlx5e_delete_flower(priv->netdev, priv, cls_flower,
 -					   flags);
 +		return mlx5e_delete_flower(priv, cls_flower, flags);
  	case TC_CLSFLOWER_STATS:
 -		return mlx5e_stats_flower(priv->netdev, priv, cls_flower,
 -					  flags);
 +		return mlx5e_stats_flower(priv, cls_flower, flags);
 +	default:
 +		return -EOPNOTSUPP;
 +	}
 +}
 +
++<<<<<<< HEAD
 +static int mlx5e_rep_setup_tc_cb_egdev(enum tc_setup_type type, void *type_data,
 +				       void *cb_priv)
 +{
 +	struct mlx5e_priv *priv = cb_priv;
 +
 +	if (!tc_cls_can_offload_and_chain0(priv->netdev, type_data))
 +		return -EOPNOTSUPP;
 +
 +	switch (type) {
 +	case TC_SETUP_CLSFLOWER:
 +		return mlx5e_rep_setup_tc_cls_flower(priv, type_data, MLX5E_TC_EGRESS);
  	default:
  		return -EOPNOTSUPP;
  	}
  }
  
++=======
++>>>>>>> ef381359e3a8 (net/mlx5e: Replace egdev with indirect block notifications)
  static int mlx5e_rep_setup_tc_cb(enum tc_setup_type type, void *type_data,
  				 void *cb_priv)
  {
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index c9ee89f4edb1..ceb89d862d08 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@ -2651,6 +2651,13 @@ static int parse_tc_fdb_actions(struct mlx5e_priv *priv, struct tcf_exts *exts,
 			struct net_device *out_dev;
 
 			out_dev = tcf_mirred_dev(a);
+			if (!out_dev) {
+				/* out_dev is NULL when filters with
+				 * non-existing mirred device are replayed to
+				 * the driver.
+				 */
+				return -EINVAL;
+			}
 
 			if (attr->out_count >= MLX5_MAX_FLOW_FWD_VPORTS) {
 				pr_err("can't support more than %d output ports, can't offload forwarding\n",
@@ -2675,6 +2682,13 @@ static int parse_tc_fdb_actions(struct mlx5e_priv *priv, struct tcf_exts *exts,
 					  MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 					  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 				/* attr->out_rep is resolved when we handle encap */
+			} else if (parse_attr->filter_dev != priv->netdev) {
+				/* All mlx5 devices are called to configure
+				 * high level device filters. Therefore, the
+				 * *attempt* to  install a filter on invalid
+				 * eswitch should not trigger an explicit error
+				 */
+				return -EINVAL;
 			} else {
 				pr_err("devices %s %s not on same switch HW, can't offload forwarding\n",
 				       priv->netdev->name, out_dev->name);
