libnvdimm/security: Require nvdimm_security_setup_events() to succeed

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Dan Williams <dan.j.williams@intel.com>
commit 1cd7386549f9b6f2f230da54aa9e7fe2d6c216d2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/1cd73865.failed

The following warning:

    ACPI0012:00: security event setup failed: -19

...is meant to capture exceptional failures of sysfs_get_dirent(),
however it will also fail in the common case when security support is
disabled. A few issues:

1/ A dev_warn() report for a common case is too chatty
2/ The setup of this notifier is generic, no need for it to be driven
   from the nfit driver, it can exist completely in the core.
3/ If it fails for any reason besides security support being disabled,
   that's fatal and should abort DIMM activation. Userspace may hang if
   it never gets overwrite notifications.
4/ The dirent needs to be released.

Move the call to the core 'dimm' driver, make it conditional on security
support being active, make it fatal for the exceptional case, add the
missing sysfs_put() at device disable time.

Fixes: 7d988097c546 ("...Add security DSM overwrite support")
	Reviewed-by: Dave Jiang <dave.jiang@intel.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 1cd7386549f9b6f2f230da54aa9e7fe2d6c216d2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvdimm/dimm_devs.c
#	drivers/nvdimm/nd.h
diff --cc drivers/nvdimm/dimm_devs.c
index 508dd405f84f,efe412a6b5b9..000000000000
--- a/drivers/nvdimm/dimm_devs.c
+++ b/drivers/nvdimm/dimm_devs.c
@@@ -419,6 -578,57 +419,60 @@@ struct nvdimm *__nvdimm_create(struct n
  }
  EXPORT_SYMBOL_GPL(__nvdimm_create);
  
++<<<<<<< HEAD
++=======
+ static void shutdown_security_notify(void *data)
+ {
+ 	struct nvdimm *nvdimm = data;
+ 
+ 	sysfs_put(nvdimm->sec.overwrite_state);
+ }
+ 
+ int nvdimm_security_setup_events(struct device *dev)
+ {
+ 	struct nvdimm *nvdimm = to_nvdimm(dev);
+ 
+ 	if (nvdimm->sec.state < 0 || !nvdimm->sec.ops
+ 			|| !nvdimm->sec.ops->overwrite)
+ 		return 0;
+ 	nvdimm->sec.overwrite_state = sysfs_get_dirent(dev->kobj.sd, "security");
+ 	if (!nvdimm->sec.overwrite_state)
+ 		return -ENOMEM;
+ 
+ 	return devm_add_action_or_reset(dev, shutdown_security_notify, nvdimm);
+ }
+ EXPORT_SYMBOL_GPL(nvdimm_security_setup_events);
+ 
+ int nvdimm_in_overwrite(struct nvdimm *nvdimm)
+ {
+ 	return test_bit(NDD_SECURITY_OVERWRITE, &nvdimm->flags);
+ }
+ EXPORT_SYMBOL_GPL(nvdimm_in_overwrite);
+ 
+ int nvdimm_security_freeze(struct nvdimm *nvdimm)
+ {
+ 	int rc;
+ 
+ 	WARN_ON_ONCE(!is_nvdimm_bus_locked(&nvdimm->dev));
+ 
+ 	if (!nvdimm->sec.ops || !nvdimm->sec.ops->freeze)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (nvdimm->sec.state < 0)
+ 		return -EIO;
+ 
+ 	if (test_bit(NDD_SECURITY_OVERWRITE, &nvdimm->flags)) {
+ 		dev_warn(&nvdimm->dev, "Overwrite operation in progress.\n");
+ 		return -EBUSY;
+ 	}
+ 
+ 	rc = nvdimm->sec.ops->freeze(nvdimm);
+ 	nvdimm->sec.state = nvdimm_security_state(nvdimm, NVDIMM_USER);
+ 
+ 	return rc;
+ }
+ 
++>>>>>>> 1cd7386549f9 (libnvdimm/security: Require nvdimm_security_setup_events() to succeed)
  int alias_dpa_busy(struct device *dev, void *data)
  {
  	resource_size_t map_end, blk_start, new;
diff --cc drivers/nvdimm/nd.h
index 4edbf9666a07,379bf4305e61..000000000000
--- a/drivers/nvdimm/nd.h
+++ b/drivers/nvdimm/nd.h
@@@ -250,6 -250,15 +250,18 @@@ long nvdimm_clear_poison(struct device 
  void nvdimm_set_aliasing(struct device *dev);
  void nvdimm_set_locked(struct device *dev);
  void nvdimm_clear_locked(struct device *dev);
++<<<<<<< HEAD
++=======
+ int nvdimm_security_setup_events(struct device *dev);
+ #if IS_ENABLED(CONFIG_NVDIMM_KEYS)
+ int nvdimm_security_unlock(struct device *dev);
+ #else
+ static inline int nvdimm_security_unlock(struct device *dev)
+ {
+ 	return 0;
+ }
+ #endif
++>>>>>>> 1cd7386549f9 (libnvdimm/security: Require nvdimm_security_setup_events() to succeed)
  struct nd_btt *to_nd_btt(struct device *dev);
  
  struct nd_gen_sb {
diff --git a/drivers/nvdimm/dimm.c b/drivers/nvdimm/dimm.c
index 1555c3d54980..faf4b80937dd 100644
--- a/drivers/nvdimm/dimm.c
+++ b/drivers/nvdimm/dimm.c
@@ -26,6 +26,12 @@ static int nvdimm_probe(struct device *dev)
 	struct nvdimm_drvdata *ndd;
 	int rc;
 
+	rc = nvdimm_security_setup_events(dev);
+	if (rc < 0) {
+		dev_err(dev, "security event setup failed: %d\n", rc);
+		return rc;
+	}
+
 	rc = nvdimm_check_config_data(dev);
 	if (rc) {
 		/* not required for non-aliased nvdimm, ex. NVDIMM-N */
* Unmerged path drivers/nvdimm/dimm_devs.c
* Unmerged path drivers/nvdimm/nd.h
