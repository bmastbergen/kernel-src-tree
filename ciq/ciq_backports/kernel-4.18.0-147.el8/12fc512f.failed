net/mlx5e: Fix use-after-free after xdp_return_frame

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Maxim Mikityanskiy <maximmi@mellanox.com>
commit 12fc512f5741443a03adde2ead20724da8ad550a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/12fc512f.failed

xdp_return_frame releases the frame. It leads to releasing the page, so
it's not allowed to access xdpi.xdpf->len after that, because xdpi.xdpf
is at xdp->data_hard_start after convert_to_xdp_frame. This patch moves
the memory access to precede the return of the frame.

Fixes: 58b99ee3e3ebe ("net/mlx5e: Add support for XDP_REDIRECT in device-out side")
	Signed-off-by: Maxim Mikityanskiy <maximmi@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 12fc512f5741443a03adde2ead20724da8ad550a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/xdp.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/xdp.c
index 60fd47414ccc,10a99cd3e598..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/xdp.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/xdp.c
@@@ -203,17 -290,28 +203,35 @@@ bool mlx5e_poll_xdpsq_cq(struct mlx5e_c
  					 get_cqe_opcode(cqe));
  
  		do {
 -			struct mlx5e_xdp_wqe_info *wi;
 -			u16 ci, j;
 +			struct mlx5e_xdp_info *xdpi;
 +			u16 ci;
  
  			last_wqe = (sqcc == wqe_counter);
 +
  			ci = mlx5_wq_cyc_ctr2ix(&sq->wq, sqcc);
 -			wi = &sq->db.wqe_info[ci];
 +			xdpi = &sq->db.xdpi[ci];
  
++<<<<<<< HEAD
 +			sqcc++;
 +			/* Recycle RX page */
 +			mlx5e_page_release(rq, &xdpi->di, true);
++=======
+ 			sqcc += wi->num_wqebbs;
+ 
+ 			for (j = 0; j < wi->num_ds; j++) {
+ 				struct mlx5e_xdp_info xdpi =
+ 					mlx5e_xdpi_fifo_pop(xdpi_fifo);
+ 
+ 				if (is_redirect) {
+ 					dma_unmap_single(sq->pdev, xdpi.dma_addr,
+ 							 xdpi.xdpf->len, DMA_TO_DEVICE);
+ 					xdp_return_frame(xdpi.xdpf);
+ 				} else {
+ 					/* Recycle RX page */
+ 					mlx5e_page_release(rq, &xdpi.di, true);
+ 				}
+ 			}
++>>>>>>> 12fc512f5741 (net/mlx5e: Fix use-after-free after xdp_return_frame)
  		} while (!last_wqe);
  	} while ((++i < MLX5E_TX_CQ_POLL_BUDGET) && (cqe = mlx5_cqwq_get_cqe(&cq->wq)));
  
@@@ -228,18 -326,33 +246,36 @@@
  	return (i == MLX5E_TX_CQ_POLL_BUDGET);
  }
  
 -void mlx5e_free_xdpsq_descs(struct mlx5e_xdpsq *sq, struct mlx5e_rq *rq)
 +void mlx5e_free_xdpsq_descs(struct mlx5e_xdpsq *sq)
  {
 -	struct mlx5e_xdp_info_fifo *xdpi_fifo = &sq->db.xdpi_fifo;
 -	bool is_redirect = !rq;
 +	struct mlx5e_rq *rq = container_of(sq, struct mlx5e_rq, xdpsq);
 +	struct mlx5e_xdp_info *xdpi;
 +	u16 ci;
  
  	while (sq->cc != sq->pc) {
 -		struct mlx5e_xdp_wqe_info *wi;
 -		u16 ci, i;
 -
  		ci = mlx5_wq_cyc_ctr2ix(&sq->wq, sq->cc);
 -		wi = &sq->db.wqe_info[ci];
 +		xdpi = &sq->db.xdpi[ci];
 +		sq->cc++;
  
++<<<<<<< HEAD
 +		mlx5e_page_release(rq, &xdpi->di, false);
++=======
+ 		sq->cc += wi->num_wqebbs;
+ 
+ 		for (i = 0; i < wi->num_ds; i++) {
+ 			struct mlx5e_xdp_info xdpi =
+ 				mlx5e_xdpi_fifo_pop(xdpi_fifo);
+ 
+ 			if (is_redirect) {
+ 				dma_unmap_single(sq->pdev, xdpi.dma_addr,
+ 						 xdpi.xdpf->len, DMA_TO_DEVICE);
+ 				xdp_return_frame(xdpi.xdpf);
+ 			} else {
+ 				/* Recycle RX page */
+ 				mlx5e_page_release(rq, &xdpi.di, false);
+ 			}
+ 		}
++>>>>>>> 12fc512f5741 (net/mlx5e: Fix use-after-free after xdp_return_frame)
  	}
  }
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/xdp.c
