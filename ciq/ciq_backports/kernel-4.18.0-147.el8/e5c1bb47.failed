IB/mlx5: Remove set but not used variable

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Kamal Heib <kamalheib1@gmail.com>
commit e5c1bb47cca679e9b9e286981d64fd08792e1e80
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/e5c1bb47.failed

Remove 'del_mkey' variable that is set but not used.

Fixes: 534fd7aac56a ("IB/mlx5: Manage indirection mkey upon DEVX flow for ODP")
	Signed-off-by: Kamal Heib <kamalheib1@gmail.com>
	Acked-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit e5c1bb47cca679e9b9e286981d64fd08792e1e80)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/devx.c
diff --cc drivers/infiniband/hw/mlx5/devx.c
index c7f8859c08ee,cd43e39ced87..000000000000
--- a/drivers/infiniband/hw/mlx5/devx.c
+++ b/drivers/infiniband/hw/mlx5/devx.c
@@@ -349,6 -1028,92 +349,95 @@@ static void devx_obj_build_destroy_cmd(
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static int devx_handle_mkey_indirect(struct devx_obj *obj,
+ 				     struct mlx5_ib_dev *dev,
+ 				     void *in, void *out)
+ {
+ 	struct mlx5_mkey_table *table = &dev->mdev->priv.mkey_table;
+ 	struct mlx5_ib_devx_mr *devx_mr = &obj->devx_mr;
+ 	unsigned long flags;
+ 	struct mlx5_core_mkey *mkey;
+ 	void *mkc;
+ 	u8 key;
+ 	int err;
+ 
+ 	mkey = &devx_mr->mmkey;
+ 	mkc = MLX5_ADDR_OF(create_mkey_in, in, memory_key_mkey_entry);
+ 	key = MLX5_GET(mkc, mkc, mkey_7_0);
+ 	mkey->key = mlx5_idx_to_mkey(
+ 			MLX5_GET(create_mkey_out, out, mkey_index)) | key;
+ 	mkey->type = MLX5_MKEY_INDIRECT_DEVX;
+ 	mkey->iova = MLX5_GET64(mkc, mkc, start_addr);
+ 	mkey->size = MLX5_GET64(mkc, mkc, len);
+ 	mkey->pd = MLX5_GET(mkc, mkc, pd);
+ 	devx_mr->ndescs = MLX5_GET(mkc, mkc, translations_octword_size);
+ 
+ 	write_lock_irqsave(&table->lock, flags);
+ 	err = radix_tree_insert(&table->tree, mlx5_base_mkey(mkey->key),
+ 				mkey);
+ 	write_unlock_irqrestore(&table->lock, flags);
+ 	return err;
+ }
+ 
+ static int devx_handle_mkey_create(struct mlx5_ib_dev *dev,
+ 				   struct devx_obj *obj,
+ 				   void *in, int in_len)
+ {
+ 	int min_len = MLX5_BYTE_OFF(create_mkey_in, memory_key_mkey_entry) +
+ 			MLX5_FLD_SZ_BYTES(create_mkey_in,
+ 			memory_key_mkey_entry);
+ 	void *mkc;
+ 	u8 access_mode;
+ 
+ 	if (in_len < min_len)
+ 		return -EINVAL;
+ 
+ 	mkc = MLX5_ADDR_OF(create_mkey_in, in, memory_key_mkey_entry);
+ 
+ 	access_mode = MLX5_GET(mkc, mkc, access_mode_1_0);
+ 	access_mode |= MLX5_GET(mkc, mkc, access_mode_4_2) << 2;
+ 
+ 	if (access_mode == MLX5_MKC_ACCESS_MODE_KLMS ||
+ 		access_mode == MLX5_MKC_ACCESS_MODE_KSM) {
+ 		if (IS_ENABLED(CONFIG_INFINIBAND_ON_DEMAND_PAGING))
+ 			obj->flags |= DEVX_OBJ_FLAGS_INDIRECT_MKEY;
+ 		return 0;
+ 	}
+ 
+ 	MLX5_SET(create_mkey_in, in, mkey_umem_valid, 1);
+ 	return 0;
+ }
+ 
+ static void devx_free_indirect_mkey(struct rcu_head *rcu)
+ {
+ 	kfree(container_of(rcu, struct devx_obj, devx_mr.rcu));
+ }
+ 
+ /* This function to delete from the radix tree needs to be called before
+  * destroying the underlying mkey. Otherwise a race might occur in case that
+  * other thread will get the same mkey before this one will be deleted,
+  * in that case it will fail via inserting to the tree its own data.
+  *
+  * Note:
+  * An error in the destroy is not expected unless there is some other indirect
+  * mkey which points to this one. In a kernel cleanup flow it will be just
+  * destroyed in the iterative destruction call. In a user flow, in case
+  * the application didn't close in the expected order it's its own problem,
+  * the mkey won't be part of the tree, in both cases the kernel is safe.
+  */
+ static void devx_cleanup_mkey(struct devx_obj *obj)
+ {
+ 	struct mlx5_mkey_table *table = &obj->mdev->priv.mkey_table;
+ 	unsigned long flags;
+ 
+ 	write_lock_irqsave(&table->lock, flags);
+ 	radix_tree_delete(&table->tree, mlx5_base_mkey(obj->devx_mr.mmkey.key));
+ 	write_unlock_irqrestore(&table->lock, flags);
+ }
+ 
++>>>>>>> e5c1bb47cca6 (IB/mlx5: Remove set but not used variable)
  static int devx_obj_cleanup(struct ib_uobject *uobject,
  			    enum rdma_remove_reason why)
  {
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
