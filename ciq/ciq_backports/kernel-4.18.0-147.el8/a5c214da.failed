KVM/VMX: Change hv flush logic when ept tables are mismatched.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Lan Tianyu <Tianyu.Lan@microsoft.com>
commit a5c214dad1985092bd21c38c2a78befed9b02294
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/a5c214da.failed

If ept table pointers are mismatched, flushing tlb for each vcpus via
hv flush interface still helps to reduce vmexits which are triggered
by IPI and INEPT emulation.

	Signed-off-by: Lan Tianyu <Tianyu.Lan@microsoft.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit a5c214dad1985092bd21c38c2a78befed9b02294)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index 7418e104ba31,a9ed7a723a0c..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -1582,18 -1580,14 +1583,25 @@@ static int vmx_hv_remote_flush_tlb(stru
  		check_ept_pointer_match(kvm);
  
  	if (to_kvm_vmx(kvm)->ept_pointers_match != EPT_POINTERS_MATCH) {
- 		ret = -ENOTSUPP;
- 		goto out;
+ 		kvm_for_each_vcpu(i, vcpu, kvm)
+ 			ret |= hyperv_flush_guest_mapping(
+ 				to_vmx(kvm_get_vcpu(kvm, i))->ept_pointer);
+ 	} else {
+ 		ret = hyperv_flush_guest_mapping(
+ 				to_vmx(kvm_get_vcpu(kvm, 0))->ept_pointer);
  	}
  
++<<<<<<< HEAD
 +	/*
 +	 * FLUSH_GUEST_PHYSICAL_ADDRESS_SPACE hypercall needs the address of the
 +	 * base of EPT PML4 table, strip off EPT configuration information.
 +	 */
 +	ret = hyperv_flush_guest_mapping(
 +			to_vmx(kvm_get_vcpu(kvm, 0))->ept_pointer & PAGE_MASK);
 +
 +out:
++=======
++>>>>>>> a5c214dad198 (KVM/VMX: Change hv flush logic when ept tables are mismatched.)
  	spin_unlock(&to_kvm_vmx(kvm)->ept_pointer_lock);
  	return ret;
  }
* Unmerged path arch/x86/kvm/vmx.c
