net/mlx5e: Set peer flow needed also for multipath

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Roi Dayan <roid@mellanox.com>
commit 10fbb1cdd0a36347106f6522c941e67cd9c3e7c1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/10fbb1cd.failed

Update the predicate that determines if to duplicate rules installed on
vport reps to account also for the multipath case.

	Signed-off-by: Roi Dayan <roid@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 10fbb1cdd0a36347106f6522c941e67cd9c3e7c1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 0898ea0b9f0c,b4967a0ff8c7..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -2767,31 -2721,36 +2767,60 @@@ static struct rhashtable *get_tc_ht(str
  		return &priv->fs.tc.ht;
  }
  
++<<<<<<< HEAD
 +int mlx5e_configure_flower(struct mlx5e_priv *priv,
 +			   struct tc_cls_flower_offload *f, int flags)
++=======
+ static bool is_peer_flow_needed(struct mlx5e_tc_flow *flow)
+ {
+ 	struct mlx5_esw_flow_attr *attr = flow->esw_attr;
+ 	bool is_rep_ingress = attr->in_rep->vport != MLX5_VPORT_UPLINK &&
+ 			      flow->flags & MLX5E_TC_FLOW_INGRESS;
+ 	bool act_is_encap = !!(attr->action &
+ 			       MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT);
+ 	bool esw_paired = mlx5_devcom_is_paired(attr->in_mdev->priv.devcom,
+ 						MLX5_DEVCOM_ESW_OFFLOADS);
+ 
+ 	if (!esw_paired)
+ 		return false;
+ 
+ 	if ((mlx5_lag_is_sriov(attr->in_mdev) ||
+ 	     mlx5_lag_is_multipath(attr->in_mdev)) &&
+ 	    (is_rep_ingress || act_is_encap))
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ static int
+ mlx5e_alloc_flow(struct mlx5e_priv *priv, int attr_size,
+ 		 struct tc_cls_flower_offload *f, u16 flow_flags,
+ 		 struct mlx5e_tc_flow_parse_attr **__parse_attr,
+ 		 struct mlx5e_tc_flow **__flow)
++>>>>>>> 10fbb1cdd0a3 (net/mlx5e: Set peer flow needed also for multipath)
  {
 +	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
  	struct mlx5e_tc_flow_parse_attr *parse_attr;
 +	struct rhashtable *tc_ht = get_tc_ht(priv);
  	struct mlx5e_tc_flow *flow;
 -	int err;
 +	int attr_size, err = 0;
 +	u8 flow_flags = 0;
 +
 +	get_flags(flags, &flow_flags);
 +
 +	flow = rhashtable_lookup_fast(tc_ht, &f->cookie, tc_ht_params);
 +	if (flow) {
 +		netdev_warn_once(priv->netdev, "flow cookie %lx already exists, ignoring\n", f->cookie);
 +		return 0;
 +	}
 +
 +	if (esw && esw->mode == SRIOV_OFFLOADS) {
 +		flow_flags |= MLX5E_TC_FLOW_ESWITCH;
 +		attr_size  = sizeof(struct mlx5_esw_flow_attr);
 +	} else {
 +		flow_flags |= MLX5E_TC_FLOW_NIC;
 +		attr_size  = sizeof(struct mlx5_nic_flow_attr);
 +	}
  
  	flow = kzalloc(sizeof(*flow) + attr_size, GFP_KERNEL);
  	parse_attr = kvzalloc(sizeof(*parse_attr), GFP_KERNEL);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
