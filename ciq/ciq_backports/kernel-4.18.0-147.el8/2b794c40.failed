tls: Return type of non-data records retrieved using MSG_PEEK in recvmsg

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Vakul Garg <vakul.garg@nxp.com>
commit 2b794c4098b525836e37d16045abee3091fdfe18
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/2b794c40.failed

The patch enables returning 'type' in msghdr for records that are
retrieved with MSG_PEEK in recvmsg. Further it prevents records peeked
from socket from getting clubbed with any other record of different
type when records are subsequently dequeued from strparser.

For each record, we now retain its type in sk_buff's control buffer
cb[]. Inside control buffer, record's full length and offset are already
stored by strparser in 'struct strp_msg'. We store record type after
'struct strp_msg' inside 'struct tls_msg'. For tls1.2, the type is
stored just after record dequeue. For tls1.3, the type is stored after
record has been decrypted.

Inside process_rx_list(), before processing a non-data record, we check
that we must be able to return back the record type to the user
application. If not, the decrypted records in tls context's rx_list is
left there without consuming any data.

Fixes: 692d7b5d1f912 ("tls: Fix recvmsg() to be able to peek across multiple records")
	Signed-off-by: Vakul Garg <vakul.garg@nxp.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2b794c4098b525836e37d16045abee3091fdfe18)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/tls/tls_sw.c
diff --cc net/tls/tls_sw.c
index 3f443983a6b3,1cc830582fa8..000000000000
--- a/net/tls/tls_sw.c
+++ b/net/tls/tls_sw.c
@@@ -1288,6 -1529,115 +1288,118 @@@ static bool tls_sw_advance_skb(struct s
  	return true;
  }
  
++<<<<<<< HEAD
++=======
+ /* This function traverses the rx_list in tls receive context to copies the
+  * decrypted records into the buffer provided by caller zero copy is not
+  * true. Further, the records are removed from the rx_list if it is not a peek
+  * case and the record has been consumed completely.
+  */
+ static int process_rx_list(struct tls_sw_context_rx *ctx,
+ 			   struct msghdr *msg,
+ 			   u8 *control,
+ 			   bool *cmsg,
+ 			   size_t skip,
+ 			   size_t len,
+ 			   bool zc,
+ 			   bool is_peek)
+ {
+ 	struct sk_buff *skb = skb_peek(&ctx->rx_list);
+ 	u8 ctrl = *control;
+ 	u8 msgc = *cmsg;
+ 	struct tls_msg *tlm;
+ 	ssize_t copied = 0;
+ 
+ 	/* Set the record type in 'control' if caller didn't pass it */
+ 	if (!ctrl && skb) {
+ 		tlm = tls_msg(skb);
+ 		ctrl = tlm->control;
+ 	}
+ 
+ 	while (skip && skb) {
+ 		struct strp_msg *rxm = strp_msg(skb);
+ 		tlm = tls_msg(skb);
+ 
+ 		/* Cannot process a record of different type */
+ 		if (ctrl != tlm->control)
+ 			return 0;
+ 
+ 		if (skip < rxm->full_len)
+ 			break;
+ 
+ 		skip = skip - rxm->full_len;
+ 		skb = skb_peek_next(skb, &ctx->rx_list);
+ 	}
+ 
+ 	while (len && skb) {
+ 		struct sk_buff *next_skb;
+ 		struct strp_msg *rxm = strp_msg(skb);
+ 		int chunk = min_t(unsigned int, rxm->full_len - skip, len);
+ 
+ 		tlm = tls_msg(skb);
+ 
+ 		/* Cannot process a record of different type */
+ 		if (ctrl != tlm->control)
+ 			return 0;
+ 
+ 		/* Set record type if not already done. For a non-data record,
+ 		 * do not proceed if record type could not be copied.
+ 		 */
+ 		if (!msgc) {
+ 			int cerr = put_cmsg(msg, SOL_TLS, TLS_GET_RECORD_TYPE,
+ 					    sizeof(ctrl), &ctrl);
+ 			msgc = true;
+ 			if (ctrl != TLS_RECORD_TYPE_DATA) {
+ 				if (cerr || msg->msg_flags & MSG_CTRUNC)
+ 					return -EIO;
+ 
+ 				*cmsg = msgc;
+ 			}
+ 		}
+ 
+ 		if (!zc || (rxm->full_len - skip) > len) {
+ 			int err = skb_copy_datagram_msg(skb, rxm->offset + skip,
+ 						    msg, chunk);
+ 			if (err < 0)
+ 				return err;
+ 		}
+ 
+ 		len = len - chunk;
+ 		copied = copied + chunk;
+ 
+ 		/* Consume the data from record if it is non-peek case*/
+ 		if (!is_peek) {
+ 			rxm->offset = rxm->offset + chunk;
+ 			rxm->full_len = rxm->full_len - chunk;
+ 
+ 			/* Return if there is unconsumed data in the record */
+ 			if (rxm->full_len - skip)
+ 				break;
+ 		}
+ 
+ 		/* The remaining skip-bytes must lie in 1st record in rx_list.
+ 		 * So from the 2nd record, 'skip' should be 0.
+ 		 */
+ 		skip = 0;
+ 
+ 		if (msg)
+ 			msg->msg_flags |= MSG_EOR;
+ 
+ 		next_skb = skb_peek_next(skb, &ctx->rx_list);
+ 
+ 		if (!is_peek) {
+ 			skb_unlink(skb, &ctx->rx_list);
+ 			kfree_skb(skb);
+ 		}
+ 
+ 		skb = next_skb;
+ 	}
+ 
+ 	*control = ctrl;
+ 	return copied;
+ }
+ 
++>>>>>>> 2b794c4098b5 (tls: Return type of non-data records retrieved using MSG_PEEK in recvmsg)
  int tls_sw_recvmsg(struct sock *sk,
  		   struct msghdr *msg,
  		   size_t len,
@@@ -1297,8 -1647,12 +1409,9 @@@
  {
  	struct tls_context *tls_ctx = tls_get_ctx(sk);
  	struct tls_sw_context_rx *ctx = tls_sw_ctx_rx(tls_ctx);
 -	struct tls_prot_info *prot = &tls_ctx->prot_info;
 -	struct sk_psock *psock;
 -	unsigned char control = 0;
 -	ssize_t decrypted = 0;
 +	unsigned char control;
  	struct strp_msg *rxm;
+ 	struct tls_msg *tlm;
  	struct sk_buff *skb;
  	ssize_t copied = 0;
  	bool cmsg = false;
@@@ -1312,21 -1667,95 +1425,93 @@@
  	if (unlikely(flags & MSG_ERRQUEUE))
  		return sock_recv_errqueue(sk, msg, len, SOL_IP, IP_RECVERR);
  
 -	psock = sk_psock_get(sk);
  	lock_sock(sk);
  
++<<<<<<< HEAD
 +	target = sock_rcvlowat(sk, flags & MSG_WAITALL, len);
 +	timeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);
++=======
+ 	/* Process pending decrypted records. It must be non-zero-copy */
+ 	err = process_rx_list(ctx, msg, &control, &cmsg, 0, len, false,
+ 			      is_peek);
+ 	if (err < 0) {
+ 		tls_err_abort(sk, err);
+ 		goto end;
+ 	} else {
+ 		copied = err;
+ 	}
+ 
+ 	len = len - copied;
+ 	if (len) {
+ 		target = sock_rcvlowat(sk, flags & MSG_WAITALL, len);
+ 		timeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);
+ 	} else {
+ 		goto recv_end;
+ 	}
+ 
++>>>>>>> 2b794c4098b5 (tls: Return type of non-data records retrieved using MSG_PEEK in recvmsg)
  	do {
 -		bool retain_skb = false;
  		bool zc = false;
 -		int to_decrypt;
 +		bool async = false;
  		int chunk = 0;
 -		bool async;
 -
 -		skb = tls_wait_data(sk, psock, flags, timeo, &err);
 -		if (!skb) {
 -			if (psock) {
 -				int ret = __tcp_bpf_recvmsg(sk, psock,
 -							    msg, len, flags);
 -
 -				if (ret > 0) {
 -					decrypted += ret;
 -					len -= ret;
 -					continue;
 -				}
 -			}
 +
 +		skb = tls_wait_data(sk, flags, timeo, &err);
 +		if (!skb)
  			goto recv_end;
++<<<<<<< HEAD
 +
 +		rxm = strp_msg(skb);
 +
++=======
+ 		} else {
+ 			tlm = tls_msg(skb);
+ 			if (prot->version == TLS_1_3_VERSION)
+ 				tlm->control = 0;
+ 			else
+ 				tlm->control = ctx->control;
+ 		}
+ 
+ 		rxm = strp_msg(skb);
+ 
+ 		to_decrypt = rxm->full_len - prot->overhead_size;
+ 
+ 		if (to_decrypt <= len && !is_kvec && !is_peek &&
+ 		    ctx->control == TLS_RECORD_TYPE_DATA &&
+ 		    prot->version != TLS_1_3_VERSION)
+ 			zc = true;
+ 
+ 		/* Do not use async mode if record is non-data */
+ 		if (ctx->control == TLS_RECORD_TYPE_DATA)
+ 			async = ctx->async_capable;
+ 		else
+ 			async = false;
+ 
+ 		err = decrypt_skb_update(sk, skb, &msg->msg_iter,
+ 					 &chunk, &zc, async);
+ 		if (err < 0 && err != -EINPROGRESS) {
+ 			tls_err_abort(sk, EBADMSG);
+ 			goto recv_end;
+ 		}
+ 
+ 		if (err == -EINPROGRESS)
+ 			num_async++;
+ 		else if (prot->version == TLS_1_3_VERSION)
+ 			tlm->control = ctx->control;
+ 
+ 		/* If the type of records being processed is not known yet,
+ 		 * set it to record type just dequeued. If it is already known,
+ 		 * but does not match the record type just dequeued, go to end.
+ 		 * We always get record type here since for tls1.2, record type
+ 		 * is known just after record is dequeued from stream parser.
+ 		 * For tls1.3, we disable async.
+ 		 */
+ 
+ 		if (!control)
+ 			control = tlm->control;
+ 		else if (control != tlm->control)
+ 			goto recv_end;
+ 
++>>>>>>> 2b794c4098b5 (tls: Return type of non-data records retrieved using MSG_PEEK in recvmsg)
  		if (!cmsg) {
  			int cerr;
  
@@@ -1340,69 -1768,52 +1524,67 @@@
  					goto recv_end;
  				}
  			}
- 		} else if (control != ctx->control) {
- 			goto recv_end;
  		}
  
 -		if (async)
 -			goto pick_next_record;
 +		if (!ctx->decrypted) {
 +			int to_copy = rxm->full_len - tls_ctx->rx.overhead_size;
  
 -		if (!zc) {
 -			if (rxm->full_len > len) {
 -				retain_skb = true;
 -				chunk = len;
 -			} else {
 -				chunk = rxm->full_len;
 -			}
 +			if (!is_kvec && to_copy <= len &&
 +			    likely(!(flags & MSG_PEEK)))
 +				zc = true;
  
 -			err = skb_copy_datagram_msg(skb, rxm->offset,
 -						    msg, chunk);
 -			if (err < 0)
 +			err = decrypt_skb_update(sk, skb, &msg->msg_iter,
 +						 &chunk, &zc);
 +			if (err < 0 && err != -EINPROGRESS) {
 +				tls_err_abort(sk, EBADMSG);
  				goto recv_end;
 +			}
  
 -			if (!is_peek) {
 -				rxm->offset = rxm->offset + chunk;
 -				rxm->full_len = rxm->full_len - chunk;
 +			if (err == -EINPROGRESS) {
 +				async = true;
 +				num_async++;
 +				goto pick_next_record;
  			}
 -		}
  
 -pick_next_record:
 -		if (chunk > len)
 -			chunk = len;
 +			ctx->decrypted = true;
 +		}
  
 -		decrypted += chunk;
 -		len -= chunk;
 +		if (!zc) {
 +			chunk = min_t(unsigned int, rxm->full_len, len);
  
 -		/* For async or peek case, queue the current skb */
 -		if (async || is_peek || retain_skb) {
 -			skb_queue_tail(&ctx->rx_list, skb);
 -			skb = NULL;
 +			err = skb_copy_datagram_msg(skb, rxm->offset, msg,
 +						    chunk);
 +			if (err < 0)
 +				goto recv_end;
  		}
  
 -		if (tls_sw_advance_skb(sk, skb, chunk)) {
 -			/* Return full control message to
 -			 * userspace before trying to parse
 -			 * another message type
 -			 */
 -			msg->msg_flags |= MSG_EOR;
 -			if (ctx->control != TLS_RECORD_TYPE_DATA)
 -				goto recv_end;
 +pick_next_record:
 +		copied += chunk;
 +		len -= chunk;
 +		if (likely(!(flags & MSG_PEEK))) {
 +			u8 control = ctx->control;
 +
 +			/* For async, drop current skb reference */
 +			if (async)
 +				skb = NULL;
 +
 +			if (tls_sw_advance_skb(sk, skb, chunk)) {
 +				/* Return full control message to
 +				 * userspace before trying to parse
 +				 * another message type
 +				 */
 +				msg->msg_flags |= MSG_EOR;
 +				if (control != TLS_RECORD_TYPE_DATA)
 +					goto recv_end;
 +			} else {
 +				break;
 +			}
  		} else {
 +			/* MSG_PEEK right now cannot look beyond current skb
 +			 * from strparser, meaning we cannot advance skb here
 +			 * and thus unpause strparser since we'd loose original
 +			 * one.
 +			 */
  			break;
  		}
  
@@@ -1426,9 -1839,27 +1608,25 @@@ recv_end
  			reinit_completion(&ctx->async_wait.completion);
  		}
  		WRITE_ONCE(ctx->async_notify, false);
++<<<<<<< HEAD
++=======
+ 
+ 		/* Drain records from the rx_list & copy if required */
+ 		if (is_peek || is_kvec)
+ 			err = process_rx_list(ctx, msg, &control, &cmsg, copied,
+ 					      decrypted, false, is_peek);
+ 		else
+ 			err = process_rx_list(ctx, msg, &control, &cmsg, 0,
+ 					      decrypted, true, is_peek);
+ 		if (err < 0) {
+ 			tls_err_abort(sk, err);
+ 			copied = 0;
+ 			goto end;
+ 		}
++>>>>>>> 2b794c4098b5 (tls: Return type of non-data records retrieved using MSG_PEEK in recvmsg)
  	}
  
 -	copied += decrypted;
 -
 -end:
  	release_sock(sk);
 -	if (psock)
 -		sk_psock_put(sk, psock);
  	return copied ? : err;
  }
  
diff --git a/include/net/tls.h b/include/net/tls.h
index d1f6db15d1de..c6f2c5d46987 100644
--- a/include/net/tls.h
+++ b/include/net/tls.h
@@ -120,6 +120,11 @@ struct tls_rec {
 	u8 aead_req_ctx[];
 };
 
+struct tls_msg {
+	struct strp_msg rxm;
+	u8 control;
+};
+
 struct tx_work {
 	struct delayed_work work;
 	struct sock *sk;
@@ -324,6 +329,11 @@ int tls_push_partial_record(struct sock *sk, struct tls_context *ctx,
 int tls_push_pending_closed_record(struct sock *sk, struct tls_context *ctx,
 				   int flags, long *timeo);
 
+static inline struct tls_msg *tls_msg(struct sk_buff *skb)
+{
+	return (struct tls_msg *)strp_msg(skb);
+}
+
 static inline bool tls_is_pending_closed_record(struct tls_context *ctx)
 {
 	return test_bit(TLS_PENDING_CLOSED_RECORD, &ctx->flags);
* Unmerged path net/tls/tls_sw.c
