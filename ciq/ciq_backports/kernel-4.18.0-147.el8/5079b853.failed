ice: Fix issue when adding more than allowed VLANs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Akeem G Abodunrin <akeem.g.abodunrin@intel.com>
commit 5079b853b221005ac06192265c917ea79c11c0e2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/5079b853.failed

This patch fixes issue with non trusted VFs being able to add more than
permitted number of VLANs by adding a check in ice_vc_process_vlan_msg.
Also don't return an error in this case as the VF does not need to know
that it is not trusted.

Also rework ice_vsi_kill_vlan to use the right types.

	Signed-off-by: Akeem G Abodunrin <akeem.g.abodunrin@intel.com>
	Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 5079b853b221005ac06192265c917ea79c11c0e2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
diff --cc drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
index 425cb2c74f8f,f52f0fc52f46..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
@@@ -2216,8 -2324,11 +2216,16 @@@ static int ice_vc_process_vlan_msg(stru
  	if (add_v && !ice_is_vf_trusted(vf) &&
  	    vf->num_vlan >= ICE_MAX_VLAN_PER_VF) {
  		dev_info(&pf->pdev->dev,
++<<<<<<< HEAD
 +			 "VF is not trusted, switch the VF to trusted mode, in order to add more VLAN addresses\n");
 +		aq_ret = ICE_ERR_PARAM;
++=======
+ 			 "VF-%d is not trusted, switch the VF to trusted mode, in order to add more VLAN addresses\n",
+ 			 vf->vf_id);
+ 		/* There is no need to let VF know about being not trusted,
+ 		 * so we can just return success message here
+ 		 */
++>>>>>>> 5079b853b221 (ice: Fix issue when adding more than allowed VLANs)
  		goto error_param;
  	}
  
@@@ -2253,15 -2369,47 +2261,34 @@@
  		for (i = 0; i < vfl->num_elements; i++) {
  			u16 vid = vfl->vlan_id[i];
  
++<<<<<<< HEAD
 +			if (!ice_vsi_add_vlan(vsi, vid)) {
 +				vf->num_vlan++;
++=======
+ 			if (!ice_is_vf_trusted(vf) &&
+ 			    vf->num_vlan >= ICE_MAX_VLAN_PER_VF) {
+ 				dev_info(&pf->pdev->dev,
+ 					 "VF-%d is not trusted, switch the VF to trusted mode, in order to add more VLAN addresses\n",
+ 					 vf->vf_id);
+ 				/* There is no need to let VF know about being
+ 				 * not trusted, so we can just return success
+ 				 * message here as well.
+ 				 */
+ 				goto error_param;
+ 			}
+ 
+ 			if (ice_vsi_add_vlan(vsi, vid)) {
+ 				v_ret = VIRTCHNL_STATUS_ERR_PARAM;
+ 				goto error_param;
+ 			}
++>>>>>>> 5079b853b221 (ice: Fix issue when adding more than allowed VLANs)
  
 -			vf->num_vlan++;
 -			/* Enable VLAN pruning when VLAN is added */
 -			if (!vlan_promisc) {
 -				status = ice_cfg_vlan_pruning(vsi, true, false);
 -				if (status) {
 -					v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -					dev_err(&pf->pdev->dev,
 -						"Enable VLAN pruning on VLAN ID: %d failed error-%d\n",
 -						vid, status);
 -					goto error_param;
 -				}
 +				/* Enable VLAN pruning when VLAN 0 is added */
 +				if (unlikely(!vid))
 +					if (ice_cfg_vlan_pruning(vsi, true))
 +						aq_ret = ICE_ERR_PARAM;
  			} else {
 -				/* Enable Ucast/Mcast VLAN promiscuous mode */
 -				promisc_m = ICE_PROMISC_VLAN_TX |
 -					    ICE_PROMISC_VLAN_RX;
 -
 -				status = ice_set_vsi_promisc(hw, vsi->idx,
 -							     promisc_m, vid);
 -				if (status) {
 -					v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -					dev_err(&pf->pdev->dev,
 -						"Enable Unicast/multicast promiscuous mode on VLAN ID:%d failed error-%d\n",
 -						vid, status);
 -				}
 +				aq_ret = ICE_ERR_PARAM;
  			}
  		}
  	} else {
diff --git a/drivers/net/ethernet/intel/ice/ice_lib.c b/drivers/net/ethernet/intel/ice/ice_lib.c
index 6fbf0ede9536..9b66d3bc88ae 100644
--- a/drivers/net/ethernet/intel/ice/ice_lib.c
+++ b/drivers/net/ethernet/intel/ice/ice_lib.c
@@ -1591,7 +1591,8 @@ int ice_vsi_kill_vlan(struct ice_vsi *vsi, u16 vid)
 	struct ice_fltr_list_entry *list;
 	struct ice_pf *pf = vsi->back;
 	LIST_HEAD(tmp_add_list);
-	int status = 0;
+	enum ice_status status;
+	int err = 0;
 
 	list = devm_kzalloc(&pf->pdev->dev, sizeof(*list), GFP_KERNEL);
 	if (!list)
@@ -1607,14 +1608,16 @@ int ice_vsi_kill_vlan(struct ice_vsi *vsi, u16 vid)
 	INIT_LIST_HEAD(&list->list_entry);
 	list_add(&list->list_entry, &tmp_add_list);
 
-	if (ice_remove_vlan(&pf->hw, &tmp_add_list)) {
-		dev_err(&pf->pdev->dev, "Error removing VLAN %d on vsi %i\n",
-			vid, vsi->vsi_num);
-		status = -EIO;
+	status = ice_remove_vlan(&pf->hw, &tmp_add_list);
+	if (status) {
+		dev_err(&pf->pdev->dev,
+			"Error removing VLAN %d on vsi %i error: %d\n",
+			vid, vsi->vsi_num, status);
+		err = -EIO;
 	}
 
 	ice_free_fltr_list(&pf->pdev->dev, &tmp_add_list);
-	return status;
+	return err;
 }
 
 /**
* Unmerged path drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
