arm64: Always enable ssb vulnerability detection

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jeremy Linton <jeremy.linton@arm.com>
commit d42281b6e49510f078ace15a8ea10f71e6262581
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/d42281b6.failed

Ensure we are always able to detect whether or not the CPU is affected
by SSB, so that we can later advertise this to userspace.

	Signed-off-by: Jeremy Linton <jeremy.linton@arm.com>
	Reviewed-by: Andre Przywara <andre.przywara@arm.com>
	Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
	Tested-by: Stefan Wahren <stefan.wahren@i2se.com>
[will: Use IS_ENABLED instead of #ifdef]
	Signed-off-by: Will Deacon <will.deacon@arm.com>
(cherry picked from commit d42281b6e49510f078ace15a8ea10f71e6262581)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kernel/cpu_errata.c
diff --cc arch/arm64/kernel/cpu_errata.c
index fde6f87a8b7e,b6132783e8cf..000000000000
--- a/arch/arm64/kernel/cpu_errata.c
+++ b/arch/arm64/kernel/cpu_errata.c
@@@ -239,13 -269,12 +239,12 @@@ enable_smccc_arch_workaround_1(const st
  	    ((midr & MIDR_CPU_MODEL_MASK) == MIDR_QCOM_FALKOR_V1))
  		cb = qcom_link_stack_sanitization;
  
 -	if (IS_ENABLED(CONFIG_HARDEN_BRANCH_PREDICTOR))
 -		install_bp_hardening_cb(cb, smccc_start, smccc_end);
 +	install_bp_hardening_cb(entry, cb, smccc_start, smccc_end);
  
 -	return 1;
 +	return;
  }
 +#endif	/* CONFIG_HARDEN_BRANCH_PREDICTOR */
  
- #ifdef CONFIG_ARM64_SSBD
  DEFINE_PER_CPU_READ_MOSTLY(u64, arm64_ssbd_callback_required);
  
  int ssbd_state __read_mostly = ARM64_SSBD_KERNEL;
@@@ -318,6 -347,19 +317,22 @@@ void __init arm64_enable_wa2_handling(s
  
  void arm64_set_ssbd_mitigation(bool state)
  {
++<<<<<<< HEAD
++=======
+ 	if (!IS_ENABLED(CONFIG_ARM64_SSBD)) {
+ 		pr_info_once("SSBD disabled by kernel configuration\n");
+ 		return;
+ 	}
+ 
+ 	if (this_cpu_has_cap(ARM64_SSBS)) {
+ 		if (state)
+ 			asm volatile(SET_PSTATE_SSBS(0));
+ 		else
+ 			asm volatile(SET_PSTATE_SSBS(1));
+ 		return;
+ 	}
+ 
++>>>>>>> d42281b6e495 (arm64: Always enable ssb vulnerability detection)
  	switch (psci_ops.conduit) {
  	case PSCI_CONDUIT_HVC:
  		arm_smccc_1_1_hvc(ARM_SMCCC_ARCH_WORKAROUND_2, state, NULL);
@@@ -413,10 -458,26 +428,9 @@@ static bool has_ssbd_mitigation(const s
  		break;
  	}
  
 -out_printmsg:
 -	switch (ssbd_state) {
 -	case ARM64_SSBD_FORCE_DISABLE:
 -		pr_info_once("%s disabled from command-line\n", entry->desc);
 -		break;
 -
 -	case ARM64_SSBD_FORCE_ENABLE:
 -		pr_info_once("%s forced from command-line\n", entry->desc);
 -		break;
 -	}
 -
  	return required;
  }
- #endif	/* CONFIG_ARM64_SSBD */
  
 -static void __maybe_unused
 -cpu_enable_cache_maint_trap(const struct arm64_cpu_capabilities *__unused)
 -{
 -	sysreg_clear_set(sctlr_el1, SCTLR_EL1_UCI, 0);
 -}
 -
  #define CAP_MIDR_RANGE(model, v_min, r_min, v_max, r_max)	\
  	.matches = is_affected_midr_range,			\
  	.midr_range = MIDR_RANGE(model, v_min, r_min, v_max, r_max)
@@@ -682,6 -768,21 +695,24 @@@ const struct arm64_cpu_capabilities arm
  		.type = ARM64_CPUCAP_LOCAL_CPU_ERRATUM,
  		.matches = has_ssbd_mitigation,
  	},
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ARM64_ERRATUM_1188873
+ 	{
+ 		/* Cortex-A76 r0p0 to r2p0 */
+ 		.desc = "ARM erratum 1188873",
+ 		.capability = ARM64_WORKAROUND_1188873,
+ 		ERRATA_MIDR_RANGE(MIDR_CORTEX_A76, 0, 0, 2, 0),
+ 	},
+ #endif
+ #ifdef CONFIG_ARM64_ERRATUM_1165522
+ 	{
+ 		/* Cortex-A76 r0p0 to r2p0 */
+ 		.desc = "ARM erratum 1165522",
+ 		.capability = ARM64_WORKAROUND_1165522,
+ 		ERRATA_MIDR_RANGE(MIDR_CORTEX_A76, 0, 0, 2, 0),
+ 	},
++>>>>>>> d42281b6e495 (arm64: Always enable ssb vulnerability detection)
  #endif
  	{
  	}
diff --git a/arch/arm64/include/asm/cpufeature.h b/arch/arm64/include/asm/cpufeature.h
index 4ea8f8589b68..f09b257f702e 100644
--- a/arch/arm64/include/asm/cpufeature.h
+++ b/arch/arm64/include/asm/cpufeature.h
@@ -578,11 +578,7 @@ static inline int arm64_get_ssbd_state(void)
 #endif
 }
 
-#ifdef CONFIG_ARM64_SSBD
 void arm64_set_ssbd_mitigation(bool state);
-#else
-static inline void arm64_set_ssbd_mitigation(bool state) {}
-#endif
 
 static inline u32 id_aa64mmfr0_parange_to_phys_shift(int parange)
 {
* Unmerged path arch/arm64/kernel/cpu_errata.c
