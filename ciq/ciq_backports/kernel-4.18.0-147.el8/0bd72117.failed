bpf: fix up uapi helper description and sync bpf header with tools

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Daniel Borkmann <daniel@iogearbox.net>
commit 0bd72117fba2dd51a65eaa7b480adc0eea9a4409
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/0bd72117.failed

Minor markup fixup from bpf-next into net-next merge in the BPF helper
description of bpf_sk_lookup_tcp() and bpf_sk_lookup_udp(). Also sync
up the copy of bpf.h from tooling infrastructure.

	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Reviewed-by: Quentin Monnet <quentin.monnet@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0bd72117fba2dd51a65eaa7b480adc0eea9a4409)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/bpf.h
#	tools/include/uapi/linux/bpf.h
diff --cc include/uapi/linux/bpf.h
index 4b63e0cf1b0e,aa582cd5bfcf..000000000000
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@@ -2126,10 -2172,153 +2126,157 @@@ union bpf_attr 
   *		running simultaneously.
   *
   *		A user should care about the synchronization by himself.
 - *		For example, by using the **BPF_STX_XADD** instruction to alter
 + *		For example, by using the BPF_STX_XADD instruction to alter
   *		the shared data.
   *	Return
++<<<<<<< HEAD
 + *		Pointer to the local storage area.
++=======
+  *		A pointer to the local storage area.
+  *
+  * int bpf_sk_select_reuseport(struct sk_reuseport_md *reuse, struct bpf_map *map, void *key, u64 flags)
+  *	Description
+  *		Select a **SO_REUSEPORT** socket from a
+  *		**BPF_MAP_TYPE_REUSEPORT_ARRAY** *map*.
+  *		It checks the selected socket is matching the incoming
+  *		request in the socket buffer.
+  *	Return
+  *		0 on success, or a negative error in case of failure.
+  *
+  * struct bpf_sock *bpf_sk_lookup_tcp(void *ctx, struct bpf_sock_tuple *tuple, u32 tuple_size, u64 netns, u64 flags)
+  *	Description
+  *		Look for TCP socket matching *tuple*, optionally in a child
+  *		network namespace *netns*. The return value must be checked,
+  *		and if non-**NULL**, released via **bpf_sk_release**\ ().
+  *
+  *		The *ctx* should point to the context of the program, such as
+  *		the skb or socket (depending on the hook in use). This is used
+  *		to determine the base network namespace for the lookup.
+  *
+  *		*tuple_size* must be one of:
+  *
+  *		**sizeof**\ (*tuple*\ **->ipv4**)
+  *			Look for an IPv4 socket.
+  *		**sizeof**\ (*tuple*\ **->ipv6**)
+  *			Look for an IPv6 socket.
+  *
+  *		If the *netns* is a negative signed 32-bit integer, then the
+  *		socket lookup table in the netns associated with the *ctx* will
+  *		will be used. For the TC hooks, this is the netns of the device
+  *		in the skb. For socket hooks, this is the netns of the socket.
+  *		If *netns* is any other signed 32-bit value greater than or
+  *		equal to zero then it specifies the ID of the netns relative to
+  *		the netns associated with the *ctx*. *netns* values beyond the
+  *		range of 32-bit integers are reserved for future use.
+  *
+  *		All values for *flags* are reserved for future usage, and must
+  *		be left at zero.
+  *
+  *		This helper is available only if the kernel was compiled with
+  *		**CONFIG_NET** configuration option.
+  *	Return
+  *		Pointer to **struct bpf_sock**, or **NULL** in case of failure.
+  *		For sockets with reuseport option, the **struct bpf_sock**
+  *		result is from **reuse->socks**\ [] using the hash of the tuple.
+  *
+  * struct bpf_sock *bpf_sk_lookup_udp(void *ctx, struct bpf_sock_tuple *tuple, u32 tuple_size, u64 netns, u64 flags)
+  *	Description
+  *		Look for UDP socket matching *tuple*, optionally in a child
+  *		network namespace *netns*. The return value must be checked,
+  *		and if non-**NULL**, released via **bpf_sk_release**\ ().
+  *
+  *		The *ctx* should point to the context of the program, such as
+  *		the skb or socket (depending on the hook in use). This is used
+  *		to determine the base network namespace for the lookup.
+  *
+  *		*tuple_size* must be one of:
+  *
+  *		**sizeof**\ (*tuple*\ **->ipv4**)
+  *			Look for an IPv4 socket.
+  *		**sizeof**\ (*tuple*\ **->ipv6**)
+  *			Look for an IPv6 socket.
+  *
+  *		If the *netns* is a negative signed 32-bit integer, then the
+  *		socket lookup table in the netns associated with the *ctx* will
+  *		will be used. For the TC hooks, this is the netns of the device
+  *		in the skb. For socket hooks, this is the netns of the socket.
+  *		If *netns* is any other signed 32-bit value greater than or
+  *		equal to zero then it specifies the ID of the netns relative to
+  *		the netns associated with the *ctx*. *netns* values beyond the
+  *		range of 32-bit integers are reserved for future use.
+  *
+  *		All values for *flags* are reserved for future usage, and must
+  *		be left at zero.
+  *
+  *		This helper is available only if the kernel was compiled with
+  *		**CONFIG_NET** configuration option.
+  *	Return
+  *		Pointer to **struct bpf_sock**, or **NULL** in case of failure.
+  *		For sockets with reuseport option, the **struct bpf_sock**
+  *		result is from **reuse->socks**\ [] using the hash of the tuple.
+  *
+  * int bpf_sk_release(struct bpf_sock *sock)
+  *	Description
+  *		Release the reference held by *sock*. *sock* must be a
+  *		non-**NULL** pointer that was returned from
+  *		**bpf_sk_lookup_xxx**\ ().
+  *	Return
+  *		0 on success, or a negative error in case of failure.
+  *
+  * int bpf_map_pop_elem(struct bpf_map *map, void *value)
+  * 	Description
+  * 		Pop an element from *map*.
+  * 	Return
+  * 		0 on success, or a negative error in case of failure.
+  *
+  * int bpf_map_peek_elem(struct bpf_map *map, void *value)
+  * 	Description
+  * 		Get an element from *map* without removing it.
+  * 	Return
+  * 		0 on success, or a negative error in case of failure.
+  *
+  * int bpf_msg_push_data(struct sk_buff *skb, u32 start, u32 len, u64 flags)
+  *	Description
+  *		For socket policies, insert *len* bytes into *msg* at offset
+  *		*start*.
+  *
+  *		If a program of type **BPF_PROG_TYPE_SK_MSG** is run on a
+  *		*msg* it may want to insert metadata or options into the *msg*.
+  *		This can later be read and used by any of the lower layer BPF
+  *		hooks.
+  *
+  *		This helper may fail if under memory pressure (a malloc
+  *		fails) in these cases BPF programs will get an appropriate
+  *		error and BPF programs will need to handle them.
+  *	Return
+  *		0 on success, or a negative error in case of failure.
+  *
+  * int bpf_msg_pop_data(struct sk_msg_buff *msg, u32 start, u32 pop, u64 flags)
+  *	Description
+  *		Will remove *pop* bytes from a *msg* starting at byte *start*.
+  *		This may result in **ENOMEM** errors under certain situations if
+  *		an allocation and copy are required due to a full ring buffer.
+  *		However, the helper will try to avoid doing the allocation
+  *		if possible. Other errors can occur if input parameters are
+  *		invalid either due to *start* byte not being valid part of *msg*
+  *		payload and/or *pop* value being to large.
+  *	Return
+  *		0 on success, or a negative error in case of failure.
+  *
+  * int bpf_rc_pointer_rel(void *ctx, s32 rel_x, s32 rel_y)
+  *	Description
+  *		This helper is used in programs implementing IR decoding, to
+  *		report a successfully decoded pointer movement.
+  *
+  *		The *ctx* should point to the lirc sample as passed into
+  *		the program.
+  *
+  *		This helper is only available is the kernel was compiled with
+  *		the **CONFIG_BPF_LIRC_MODE2** configuration option set to
+  *		"**y**".
+  *	Return
+  *		0
++>>>>>>> 0bd72117fba2 (bpf: fix up uapi helper description and sync bpf header with tools)
   */
  #define __BPF_FUNC_MAPPER(FN)		\
  	FN(unspec),			\
diff --cc tools/include/uapi/linux/bpf.h
index a7cd2d213091,aa582cd5bfcf..000000000000
--- a/tools/include/uapi/linux/bpf.h
+++ b/tools/include/uapi/linux/bpf.h
@@@ -468,6 -492,16 +468,19 @@@ union bpf_attr 
   * 	Return
   * 		0 on success, or a negative error in case of failure.
   *
++<<<<<<< HEAD
++=======
+  * int bpf_map_push_elem(struct bpf_map *map, const void *value, u64 flags)
+  * 	Description
+  * 		Push an element *value* in *map*. *flags* is one of:
+  *
+  * 		**BPF_EXIST**
+  * 		If the queue/stack is full, the oldest element is removed to
+  * 		make room for this.
+  * 	Return
+  * 		0 on success, or a negative error in case of failure.
+  *
++>>>>>>> 0bd72117fba2 (bpf: fix up uapi helper description and sync bpf header with tools)
   * int bpf_probe_read(void *dst, u32 size, const void *src)
   * 	Description
   * 		For tracing programs, safely attempt to read *size* bytes from
@@@ -2108,10 -2172,153 +2121,157 @@@
   *		running simultaneously.
   *
   *		A user should care about the synchronization by himself.
-  *		For example, by using the BPF_STX_XADD instruction to alter
+  *		For example, by using the **BPF_STX_XADD** instruction to alter
   *		the shared data.
   *	Return
++<<<<<<< HEAD
 + *		Pointer to the local storage area.
++=======
+  *		A pointer to the local storage area.
+  *
+  * int bpf_sk_select_reuseport(struct sk_reuseport_md *reuse, struct bpf_map *map, void *key, u64 flags)
+  *	Description
+  *		Select a **SO_REUSEPORT** socket from a
+  *		**BPF_MAP_TYPE_REUSEPORT_ARRAY** *map*.
+  *		It checks the selected socket is matching the incoming
+  *		request in the socket buffer.
+  *	Return
+  *		0 on success, or a negative error in case of failure.
+  *
+  * struct bpf_sock *bpf_sk_lookup_tcp(void *ctx, struct bpf_sock_tuple *tuple, u32 tuple_size, u64 netns, u64 flags)
+  *	Description
+  *		Look for TCP socket matching *tuple*, optionally in a child
+  *		network namespace *netns*. The return value must be checked,
+  *		and if non-**NULL**, released via **bpf_sk_release**\ ().
+  *
+  *		The *ctx* should point to the context of the program, such as
+  *		the skb or socket (depending on the hook in use). This is used
+  *		to determine the base network namespace for the lookup.
+  *
+  *		*tuple_size* must be one of:
+  *
+  *		**sizeof**\ (*tuple*\ **->ipv4**)
+  *			Look for an IPv4 socket.
+  *		**sizeof**\ (*tuple*\ **->ipv6**)
+  *			Look for an IPv6 socket.
+  *
+  *		If the *netns* is a negative signed 32-bit integer, then the
+  *		socket lookup table in the netns associated with the *ctx* will
+  *		will be used. For the TC hooks, this is the netns of the device
+  *		in the skb. For socket hooks, this is the netns of the socket.
+  *		If *netns* is any other signed 32-bit value greater than or
+  *		equal to zero then it specifies the ID of the netns relative to
+  *		the netns associated with the *ctx*. *netns* values beyond the
+  *		range of 32-bit integers are reserved for future use.
+  *
+  *		All values for *flags* are reserved for future usage, and must
+  *		be left at zero.
+  *
+  *		This helper is available only if the kernel was compiled with
+  *		**CONFIG_NET** configuration option.
+  *	Return
+  *		Pointer to **struct bpf_sock**, or **NULL** in case of failure.
+  *		For sockets with reuseport option, the **struct bpf_sock**
+  *		result is from **reuse->socks**\ [] using the hash of the tuple.
+  *
+  * struct bpf_sock *bpf_sk_lookup_udp(void *ctx, struct bpf_sock_tuple *tuple, u32 tuple_size, u64 netns, u64 flags)
+  *	Description
+  *		Look for UDP socket matching *tuple*, optionally in a child
+  *		network namespace *netns*. The return value must be checked,
+  *		and if non-**NULL**, released via **bpf_sk_release**\ ().
+  *
+  *		The *ctx* should point to the context of the program, such as
+  *		the skb or socket (depending on the hook in use). This is used
+  *		to determine the base network namespace for the lookup.
+  *
+  *		*tuple_size* must be one of:
+  *
+  *		**sizeof**\ (*tuple*\ **->ipv4**)
+  *			Look for an IPv4 socket.
+  *		**sizeof**\ (*tuple*\ **->ipv6**)
+  *			Look for an IPv6 socket.
+  *
+  *		If the *netns* is a negative signed 32-bit integer, then the
+  *		socket lookup table in the netns associated with the *ctx* will
+  *		will be used. For the TC hooks, this is the netns of the device
+  *		in the skb. For socket hooks, this is the netns of the socket.
+  *		If *netns* is any other signed 32-bit value greater than or
+  *		equal to zero then it specifies the ID of the netns relative to
+  *		the netns associated with the *ctx*. *netns* values beyond the
+  *		range of 32-bit integers are reserved for future use.
+  *
+  *		All values for *flags* are reserved for future usage, and must
+  *		be left at zero.
+  *
+  *		This helper is available only if the kernel was compiled with
+  *		**CONFIG_NET** configuration option.
+  *	Return
+  *		Pointer to **struct bpf_sock**, or **NULL** in case of failure.
+  *		For sockets with reuseport option, the **struct bpf_sock**
+  *		result is from **reuse->socks**\ [] using the hash of the tuple.
+  *
+  * int bpf_sk_release(struct bpf_sock *sock)
+  *	Description
+  *		Release the reference held by *sock*. *sock* must be a
+  *		non-**NULL** pointer that was returned from
+  *		**bpf_sk_lookup_xxx**\ ().
+  *	Return
+  *		0 on success, or a negative error in case of failure.
+  *
+  * int bpf_map_pop_elem(struct bpf_map *map, void *value)
+  * 	Description
+  * 		Pop an element from *map*.
+  * 	Return
+  * 		0 on success, or a negative error in case of failure.
+  *
+  * int bpf_map_peek_elem(struct bpf_map *map, void *value)
+  * 	Description
+  * 		Get an element from *map* without removing it.
+  * 	Return
+  * 		0 on success, or a negative error in case of failure.
+  *
+  * int bpf_msg_push_data(struct sk_buff *skb, u32 start, u32 len, u64 flags)
+  *	Description
+  *		For socket policies, insert *len* bytes into *msg* at offset
+  *		*start*.
+  *
+  *		If a program of type **BPF_PROG_TYPE_SK_MSG** is run on a
+  *		*msg* it may want to insert metadata or options into the *msg*.
+  *		This can later be read and used by any of the lower layer BPF
+  *		hooks.
+  *
+  *		This helper may fail if under memory pressure (a malloc
+  *		fails) in these cases BPF programs will get an appropriate
+  *		error and BPF programs will need to handle them.
+  *	Return
+  *		0 on success, or a negative error in case of failure.
+  *
+  * int bpf_msg_pop_data(struct sk_msg_buff *msg, u32 start, u32 pop, u64 flags)
+  *	Description
+  *		Will remove *pop* bytes from a *msg* starting at byte *start*.
+  *		This may result in **ENOMEM** errors under certain situations if
+  *		an allocation and copy are required due to a full ring buffer.
+  *		However, the helper will try to avoid doing the allocation
+  *		if possible. Other errors can occur if input parameters are
+  *		invalid either due to *start* byte not being valid part of *msg*
+  *		payload and/or *pop* value being to large.
+  *	Return
+  *		0 on success, or a negative error in case of failure.
+  *
+  * int bpf_rc_pointer_rel(void *ctx, s32 rel_x, s32 rel_y)
+  *	Description
+  *		This helper is used in programs implementing IR decoding, to
+  *		report a successfully decoded pointer movement.
+  *
+  *		The *ctx* should point to the lirc sample as passed into
+  *		the program.
+  *
+  *		This helper is only available is the kernel was compiled with
+  *		the **CONFIG_BPF_LIRC_MODE2** configuration option set to
+  *		"**y**".
+  *	Return
+  *		0
++>>>>>>> 0bd72117fba2 (bpf: fix up uapi helper description and sync bpf header with tools)
   */
  #define __BPF_FUNC_MAPPER(FN)		\
  	FN(unspec),			\
* Unmerged path include/uapi/linux/bpf.h
* Unmerged path tools/include/uapi/linux/bpf.h
