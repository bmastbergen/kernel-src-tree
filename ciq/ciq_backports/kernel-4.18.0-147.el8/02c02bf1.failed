xarray: Change definition of sibling entries

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Matthew Wilcox <willy@infradead.org>
commit 02c02bf12c5d838603eed44195d3e91f094e2ab2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/02c02bf1.failed

Instead of storing a pointer to the slot containing the canonical entry,
store the offset of the slot.  Produces slightly more efficient code
(~300 bytes) and simplifies the implementation.

	Signed-off-by: Matthew Wilcox <willy@infradead.org>
	Reviewed-by: Josef Bacik <jbacik@fb.com>
(cherry picked from commit 02c02bf12c5d838603eed44195d3e91f094e2ab2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/xarray.h
diff --cc include/linux/xarray.h
index 2dfc8006fe64,4d1cd7a083e8..000000000000
--- a/include/linux/xarray.h
+++ b/include/linux/xarray.h
@@@ -4,10 -4,154 +4,154 @@@
  /*
   * eXtensible Arrays
   * Copyright (c) 2017 Microsoft Corporation
 - * Author: Matthew Wilcox <willy@infradead.org>
 - *
 - * See Documentation/core-api/xarray.rst for how to use the XArray.
 + * Author: Matthew Wilcox <mawilcox@microsoft.com>
   */
  
 -#include <linux/bug.h>
  #include <linux/spinlock.h>
++<<<<<<< HEAD
++=======
+ #include <linux/types.h>
+ 
+ /*
+  * The bottom two bits of the entry determine how the XArray interprets
+  * the contents:
+  *
+  * 00: Pointer entry
+  * 10: Internal entry
+  * x1: Value entry or tagged pointer
+  *
+  * Attempting to store internal entries in the XArray is a bug.
+  *
+  * Most internal entries are pointers to the next node in the tree.
+  * The following internal entries have a special meaning:
+  *
+  * 0-62: Sibling entries
+  * 256: Retry entry
+  */
+ 
+ #define BITS_PER_XA_VALUE	(BITS_PER_LONG - 1)
+ 
+ /**
+  * xa_mk_value() - Create an XArray entry from an integer.
+  * @v: Value to store in XArray.
+  *
+  * Context: Any context.
+  * Return: An entry suitable for storing in the XArray.
+  */
+ static inline void *xa_mk_value(unsigned long v)
+ {
+ 	WARN_ON((long)v < 0);
+ 	return (void *)((v << 1) | 1);
+ }
+ 
+ /**
+  * xa_to_value() - Get value stored in an XArray entry.
+  * @entry: XArray entry.
+  *
+  * Context: Any context.
+  * Return: The value stored in the XArray entry.
+  */
+ static inline unsigned long xa_to_value(const void *entry)
+ {
+ 	return (unsigned long)entry >> 1;
+ }
+ 
+ /**
+  * xa_is_value() - Determine if an entry is a value.
+  * @entry: XArray entry.
+  *
+  * Context: Any context.
+  * Return: True if the entry is a value, false if it is a pointer.
+  */
+ static inline bool xa_is_value(const void *entry)
+ {
+ 	return (unsigned long)entry & 1;
+ }
+ 
+ /**
+  * xa_tag_pointer() - Create an XArray entry for a tagged pointer.
+  * @p: Plain pointer.
+  * @tag: Tag value (0, 1 or 3).
+  *
+  * If the user of the XArray prefers, they can tag their pointers instead
+  * of storing value entries.  Three tags are available (0, 1 and 3).
+  * These are distinct from the xa_mark_t as they are not replicated up
+  * through the array and cannot be searched for.
+  *
+  * Context: Any context.
+  * Return: An XArray entry.
+  */
+ static inline void *xa_tag_pointer(void *p, unsigned long tag)
+ {
+ 	return (void *)((unsigned long)p | tag);
+ }
+ 
+ /**
+  * xa_untag_pointer() - Turn an XArray entry into a plain pointer.
+  * @entry: XArray entry.
+  *
+  * If you have stored a tagged pointer in the XArray, call this function
+  * to get the untagged version of the pointer.
+  *
+  * Context: Any context.
+  * Return: A pointer.
+  */
+ static inline void *xa_untag_pointer(void *entry)
+ {
+ 	return (void *)((unsigned long)entry & ~3UL);
+ }
+ 
+ /**
+  * xa_pointer_tag() - Get the tag stored in an XArray entry.
+  * @entry: XArray entry.
+  *
+  * If you have stored a tagged pointer in the XArray, call this function
+  * to get the tag of that pointer.
+  *
+  * Context: Any context.
+  * Return: A tag.
+  */
+ static inline unsigned int xa_pointer_tag(void *entry)
+ {
+ 	return (unsigned long)entry & 3UL;
+ }
++>>>>>>> 02c02bf12c5d (xarray: Change definition of sibling entries)
+ 
+ /*
+  * xa_mk_internal() - Create an internal entry.
+  * @v: Value to turn into an internal entry.
+  *
+  * Context: Any context.
+  * Return: An XArray internal entry corresponding to this value.
+  */
+ static inline void *xa_mk_internal(unsigned long v)
+ {
+ 	return (void *)((v << 2) | 2);
+ }
+ 
+ /*
+  * xa_to_internal() - Extract the value from an internal entry.
+  * @entry: XArray entry.
+  *
+  * Context: Any context.
+  * Return: The value which was stored in the internal entry.
+  */
+ static inline unsigned long xa_to_internal(const void *entry)
+ {
+ 	return (unsigned long)entry >> 2;
+ }
+ 
+ /*
+  * xa_is_internal() - Is the entry an internal entry?
+  * @entry: XArray entry.
+  *
+  * Context: Any context.
+  * Return: %true if the entry is an internal entry.
+  */
+ static inline bool xa_is_internal(const void *entry)
+ {
+ 	return ((unsigned long)entry & 3) == 2;
+ }
  
  #define xa_trylock(xa)		spin_trylock(&(xa)->xa_lock)
  #define xa_lock(xa)		spin_lock(&(xa)->xa_lock)
diff --git a/include/linux/radix-tree.h b/include/linux/radix-tree.h
index 8e57792d07fb..924f727fe190 100644
--- a/include/linux/radix-tree.h
+++ b/include/linux/radix-tree.h
@@ -68,10 +68,7 @@ static inline bool radix_tree_is_internal_node(void *ptr)
 
 #define RADIX_TREE_MAX_TAGS 3
 
-#ifndef RADIX_TREE_MAP_SHIFT
-#define RADIX_TREE_MAP_SHIFT	(CONFIG_BASE_SMALL ? 4 : 6)
-#endif
-
+#define RADIX_TREE_MAP_SHIFT	XA_CHUNK_SHIFT
 #define RADIX_TREE_MAP_SIZE	(1UL << RADIX_TREE_MAP_SHIFT)
 #define RADIX_TREE_MAP_MASK	(RADIX_TREE_MAP_SIZE-1)
 
* Unmerged path include/linux/xarray.h
diff --git a/lib/Kconfig b/lib/Kconfig
index 0113dcc8e1bd..6b7a92e11657 100644
--- a/lib/Kconfig
+++ b/lib/Kconfig
@@ -400,8 +400,15 @@ config INTERVAL_TREE
 
 	  for more information.
 
+config XARRAY_MULTI
+	bool
+	help
+	  Support entries which occupy multiple consecutive indices in the
+	  XArray.
+
 config RADIX_TREE_MULTIORDER
 	bool
+	select XARRAY_MULTI
 
 config ASSOCIATIVE_ARRAY
 	bool
diff --git a/lib/radix-tree.c b/lib/radix-tree.c
index a904a8ddd174..2be1d4eba6ff 100644
--- a/lib/radix-tree.c
+++ b/lib/radix-tree.c
@@ -38,6 +38,7 @@
 #include <linux/rcupdate.h>
 #include <linux/slab.h>
 #include <linux/string.h>
+#include <linux/xarray.h>
 
 
 /* Number of nodes in fully populated tree of given height */
@@ -98,24 +99,7 @@ static inline void *node_to_entry(void *ptr)
 	return (void *)((unsigned long)ptr | RADIX_TREE_INTERNAL_NODE);
 }
 
-#define RADIX_TREE_RETRY	node_to_entry(NULL)
-
-#ifdef CONFIG_RADIX_TREE_MULTIORDER
-/* Sibling slots point directly to another slot in the same node */
-static inline
-bool is_sibling_entry(const struct radix_tree_node *parent, void *node)
-{
-	void __rcu **ptr = node;
-	return (parent->slots <= ptr) &&
-			(ptr < parent->slots + RADIX_TREE_MAP_SIZE);
-}
-#else
-static inline
-bool is_sibling_entry(const struct radix_tree_node *parent, void *node)
-{
-	return false;
-}
-#endif
+#define RADIX_TREE_RETRY	XA_RETRY_ENTRY
 
 static inline unsigned long
 get_slot_offset(const struct radix_tree_node *parent, void __rcu **slot)
@@ -129,16 +113,10 @@ static unsigned int radix_tree_descend(const struct radix_tree_node *parent,
 	unsigned int offset = (index >> parent->shift) & RADIX_TREE_MAP_MASK;
 	void __rcu **entry = rcu_dereference_raw(parent->slots[offset]);
 
-#ifdef CONFIG_RADIX_TREE_MULTIORDER
-	if (radix_tree_is_internal_node(entry)) {
-		if (is_sibling_entry(parent, entry)) {
-			void __rcu **sibentry;
-			sibentry = (void __rcu **) entry_to_node(entry);
-			offset = get_slot_offset(parent, sibentry);
-			entry = rcu_dereference_raw(*sibentry);
-		}
+	if (xa_is_sibling(entry)) {
+		offset = xa_to_sibling(entry);
+		entry = rcu_dereference_raw(parent->slots[offset]);
 	}
-#endif
 
 	*nodep = (void *)entry;
 	return offset;
@@ -300,10 +278,10 @@ static void dump_node(struct radix_tree_node *node, unsigned long index)
 		} else if (!radix_tree_is_internal_node(entry)) {
 			pr_debug("radix entry %p offset %ld indices %lu-%lu parent %p\n",
 					entry, i, first, last, node);
-		} else if (is_sibling_entry(node, entry)) {
+		} else if (xa_is_sibling(entry)) {
 			pr_debug("radix sblng %p offset %ld indices %lu-%lu parent %p val %p\n",
 					entry, i, first, last, node,
-					*(void **)entry_to_node(entry));
+					node->slots[xa_to_sibling(entry)]);
 		} else {
 			dump_node(entry_to_node(entry), first);
 		}
@@ -883,8 +861,7 @@ static void radix_tree_free_nodes(struct radix_tree_node *node)
 
 	for (;;) {
 		void *entry = rcu_dereference_raw(child->slots[offset]);
-		if (radix_tree_is_internal_node(entry) && child->shift &&
-				!is_sibling_entry(child, entry)) {
+		if (xa_is_node(entry) && child->shift) {
 			child = entry_to_node(entry);
 			offset = 0;
 			continue;
@@ -906,7 +883,7 @@ static void radix_tree_free_nodes(struct radix_tree_node *node)
 static inline int insert_entries(struct radix_tree_node *node,
 		void __rcu **slot, void *item, unsigned order, bool replace)
 {
-	struct radix_tree_node *child;
+	void *sibling;
 	unsigned i, n, tag, offset, tags = 0;
 
 	if (node) {
@@ -924,7 +901,7 @@ static inline int insert_entries(struct radix_tree_node *node,
 		offset = offset & ~(n - 1);
 		slot = &node->slots[offset];
 	}
-	child = node_to_entry(slot);
+	sibling = xa_mk_sibling(offset);
 
 	for (i = 0; i < n; i++) {
 		if (slot[i]) {
@@ -941,7 +918,7 @@ static inline int insert_entries(struct radix_tree_node *node,
 	for (i = 0; i < n; i++) {
 		struct radix_tree_node *old = rcu_dereference_raw(slot[i]);
 		if (i) {
-			rcu_assign_pointer(slot[i], child);
+			rcu_assign_pointer(slot[i], sibling);
 			for (tag = 0; tag < RADIX_TREE_MAX_TAGS; tag++)
 				if (tags & (1 << tag))
 					tag_clear(node, tag, offset + i);
@@ -951,9 +928,7 @@ static inline int insert_entries(struct radix_tree_node *node,
 				if (tags & (1 << tag))
 					tag_set(node, tag, offset);
 		}
-		if (radix_tree_is_internal_node(old) &&
-					!is_sibling_entry(node, old) &&
-					(old != RADIX_TREE_RETRY))
+		if (xa_is_node(old))
 			radix_tree_free_nodes(old);
 		if (radix_tree_exceptional_entry(old))
 			node->exceptional--;
@@ -1114,10 +1089,10 @@ static inline void replace_sibling_entries(struct radix_tree_node *node,
 				void __rcu **slot, int count, int exceptional)
 {
 #ifdef CONFIG_RADIX_TREE_MULTIORDER
-	void *ptr = node_to_entry(slot);
-	unsigned offset = get_slot_offset(node, slot) + 1;
+	unsigned offset = get_slot_offset(node, slot);
+	void *ptr = xa_mk_sibling(offset);
 
-	while (offset < RADIX_TREE_MAP_SIZE) {
+	while (++offset < RADIX_TREE_MAP_SIZE) {
 		if (rcu_dereference_raw(node->slots[offset]) != ptr)
 			break;
 		if (count < 0) {
@@ -1125,7 +1100,6 @@ static inline void replace_sibling_entries(struct radix_tree_node *node,
 			node->count--;
 		}
 		node->exceptional += exceptional;
-		offset++;
 	}
 #endif
 }
@@ -1322,8 +1296,7 @@ int radix_tree_split(struct radix_tree_root *root, unsigned long index,
 			tags |= 1 << tag;
 
 	for (end = offset + 1; end < RADIX_TREE_MAP_SIZE; end++) {
-		if (!is_sibling_entry(parent,
-				rcu_dereference_raw(parent->slots[end])))
+		if (!xa_is_sibling(rcu_dereference_raw(parent->slots[end])))
 			break;
 		for (tag = 0; tag < RADIX_TREE_MAX_TAGS; tag++)
 			if (tags & (1 << tag))
@@ -1621,7 +1594,7 @@ static void __rcu **skip_siblings(struct radix_tree_node **nodep,
 {
 	while (iter->index < iter->next_index) {
 		*nodep = rcu_dereference_raw(*slot);
-		if (*nodep && !is_sibling_entry(iter->node, *nodep))
+		if (*nodep && !xa_is_sibling(*nodep))
 			return slot;
 		slot++;
 		iter->index = __radix_tree_iter_add(iter, 1);
@@ -1772,7 +1745,7 @@ void __rcu **radix_tree_next_chunk(const struct radix_tree_root *root,
 				while (++offset	< RADIX_TREE_MAP_SIZE) {
 					void *slot = rcu_dereference_raw(
 							node->slots[offset]);
-					if (is_sibling_entry(node, slot))
+					if (xa_is_sibling(slot))
 						continue;
 					if (slot)
 						break;
@@ -2286,6 +2259,7 @@ void __init radix_tree_init(void)
 
 	BUILD_BUG_ON(RADIX_TREE_MAX_TAGS + __GFP_BITS_SHIFT > 32);
 	BUILD_BUG_ON(ROOT_IS_IDR & ~GFP_ZONEMASK);
+	BUILD_BUG_ON(XA_CHUNK_SIZE > 255);
 	radix_tree_node_cachep = kmem_cache_create("radix_tree_node",
 			sizeof(struct radix_tree_node), 0,
 			SLAB_PANIC | SLAB_RECLAIM_ACCOUNT,
diff --git a/tools/testing/radix-tree/Makefile b/tools/testing/radix-tree/Makefile
index 37baecc3766f..12adcf9ffe86 100644
--- a/tools/testing/radix-tree/Makefile
+++ b/tools/testing/radix-tree/Makefile
@@ -46,6 +46,6 @@ idr.c: ../../../lib/idr.c
 
 generated/map-shift.h:
 	@if ! grep -qws $(SHIFT) generated/map-shift.h; then		\
-		echo "#define RADIX_TREE_MAP_SHIFT $(SHIFT)" >		\
+		echo "#define XA_CHUNK_SHIFT $(SHIFT)" >		\
 				generated/map-shift.h;			\
 	fi
diff --git a/tools/testing/radix-tree/generated/autoconf.h b/tools/testing/radix-tree/generated/autoconf.h
index cf88dc5b8832..ca8e03ad19ac 100644
--- a/tools/testing/radix-tree/generated/autoconf.h
+++ b/tools/testing/radix-tree/generated/autoconf.h
@@ -1 +1,2 @@
 #define CONFIG_RADIX_TREE_MULTIORDER 1
+#define CONFIG_XARRAY_MULTI 1
