sched/fair: Fix infinite loop in update_blocked_averages() by reverting a9e7f6544b9c

jira LE-1907
cve CVE-2018-20784
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Linus Torvalds <torvalds@linux-foundation.org>
commit c40f7d74c741a907cfaeb73a7697081881c497d0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/c40f7d74.failed

Zhipeng Xie, Xie XiuQi and Sargun Dhillon reported lockups in the
scheduler under high loads, starting at around the v4.18 time frame,
and Zhipeng Xie tracked it down to bugs in the rq->leaf_cfs_rq_list
manipulation.

Do a (manual) revert of:

  a9e7f6544b9c ("sched/fair: Fix O(nr_cgroups) in load balance path")

It turns out that the list_del_leaf_cfs_rq() introduced by this commit
is a surprising property that was not considered in followup commits
such as:

  9c2791f936ef ("sched/fair: Fix hierarchical order in rq->leaf_cfs_rq_list")

As Vincent Guittot explains:

 "I think that there is a bigger problem with commit a9e7f6544b9c and
  cfs_rq throttling:

  Let take the example of the following topology TG2 --> TG1 --> root:

   1) The 1st time a task is enqueued, we will add TG2 cfs_rq then TG1
      cfs_rq to leaf_cfs_rq_list and we are sure to do the whole branch in
      one path because it has never been used and can't be throttled so
      tmp_alone_branch will point to leaf_cfs_rq_list at the end.

   2) Then TG1 is throttled

   3) and we add TG3 as a new child of TG1.

   4) The 1st enqueue of a task on TG3 will add TG3 cfs_rq just before TG1
      cfs_rq and tmp_alone_branch will stay  on rq->leaf_cfs_rq_list.

  With commit a9e7f6544b9c, we can del a cfs_rq from rq->leaf_cfs_rq_list.
  So if the load of TG1 cfs_rq becomes NULL before step 2) above, TG1
  cfs_rq is removed from the list.
  Then at step 4), TG3 cfs_rq is added at the beginning of rq->leaf_cfs_rq_list
  but tmp_alone_branch still points to TG3 cfs_rq because its throttled
  parent can't be enqueued when the lock is released.
  tmp_alone_branch doesn't point to rq->leaf_cfs_rq_list whereas it should.

  So if TG3 cfs_rq is removed or destroyed before tmp_alone_branch
  points on another TG cfs_rq, the next TG cfs_rq that will be added,
  will be linked outside rq->leaf_cfs_rq_list - which is bad.

  In addition, we can break the ordering of the cfs_rq in
  rq->leaf_cfs_rq_list but this ordering is used to update and
  propagate the update from leaf down to root."

Instead of trying to work through all these cases and trying to reproduce
the very high loads that produced the lockup to begin with, simplify
the code temporarily by reverting a9e7f6544b9c - which change was clearly
not thought through completely.

This (hopefully) gives us a kernel that doesn't lock up so people
can continue to enjoy their holidays without worrying about regressions. ;-)

[ mingo: Wrote changelog, fixed weird spelling in code comment while at it. ]

Analyzed-by: Xie XiuQi <xiexiuqi@huawei.com>
Analyzed-by: Vincent Guittot <vincent.guittot@linaro.org>
	Reported-by: Zhipeng Xie <xiezhipeng1@huawei.com>
	Reported-by: Sargun Dhillon <sargun@sargun.me>
	Reported-by: Xie XiuQi <xiexiuqi@huawei.com>
	Tested-by: Zhipeng Xie <xiezhipeng1@huawei.com>
	Tested-by: Sargun Dhillon <sargun@sargun.me>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
	Acked-by: Vincent Guittot <vincent.guittot@linaro.org>
	Cc: <stable@vger.kernel.org> # v4.13+
	Cc: Bin Li <huawei.libin@huawei.com>
	Cc: Mike Galbraith <efault@gmx.de>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Tejun Heo <tj@kernel.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Fixes: a9e7f6544b9c ("sched/fair: Fix O(nr_cgroups) in load balance path")
Link: http://lkml.kernel.org/r/1545879866-27809-1-git-send-email-xiexiuqi@huawei.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit c40f7d74c741a907cfaeb73a7697081881c497d0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/fair.c
diff --cc kernel/sched/fair.c
index 1579a63f92e5,6483834f1278..000000000000
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@@ -7626,29 -7628,29 +7625,17 @@@ static inline bool cfs_rq_has_blocked(s
  	return false;
  }
  
 -static inline bool others_have_blocked(struct rq *rq)
 -{
 -	if (READ_ONCE(rq->avg_rt.util_avg))
 -		return true;
 -
 -	if (READ_ONCE(rq->avg_dl.util_avg))
 -		return true;
 -
 -#ifdef CONFIG_HAVE_SCHED_AVG_IRQ
 -	if (READ_ONCE(rq->avg_irq.util_avg))
 -		return true;
 -#endif
 -
 -	return false;
 -}
 -
  #ifdef CONFIG_FAIR_GROUP_SCHED
  
- static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)
- {
- 	if (cfs_rq->load.weight)
- 		return false;
- 
- 	if (cfs_rq->avg.load_sum)
- 		return false;
- 
- 	if (cfs_rq->avg.util_sum)
- 		return false;
- 
- 	if (cfs_rq->avg.runnable_load_sum)
- 		return false;
- 
- 	return true;
- }
- 
  static void update_blocked_averages(int cpu)
  {
  	struct rq *rq = cpu_rq(cpu);
++<<<<<<< HEAD
 +	struct cfs_rq *cfs_rq, *pos;
++=======
+ 	struct cfs_rq *cfs_rq;
+ 	const struct sched_class *curr_class;
++>>>>>>> c40f7d74c741 (sched/fair: Fix infinite loop in update_blocked_averages() by reverting a9e7f6544b9c)
  	struct rq_flags rf;
  	bool done = true;
  
* Unmerged path kernel/sched/fair.c
