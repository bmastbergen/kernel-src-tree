net/tls: Replace kfree_skb() with consume_skb()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [net] tls: Replace kfree_skb() with consume_skb() (Sabrina Dubroca) [1711821]
Rebuild_FUZZ: 95.56%
commit-author Vakul Garg <vakul.garg@nxp.com>
commit a88c26f671b0860cc93c654d45f472e43831fb33
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/a88c26f6.failed

To free the skb in normal course of processing, consume_skb() should be
used. Only for failure paths, skb_free() is intended to be used.

https://www.kernel.org/doc/htmldocs/networking/API-consume-skb.html

	Signed-off-by: Vakul Garg <vakul.garg@nxp.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a88c26f671b0860cc93c654d45f472e43831fb33)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/tls/tls_sw.c
diff --cc net/tls/tls_sw.c
index 3f443983a6b3,4f821edeeae6..000000000000
--- a/net/tls/tls_sw.c
+++ b/net/tls/tls_sw.c
@@@ -1288,6 -1545,115 +1288,118 @@@ static bool tls_sw_advance_skb(struct s
  	return true;
  }
  
++<<<<<<< HEAD
++=======
+ /* This function traverses the rx_list in tls receive context to copies the
+  * decrypted records into the buffer provided by caller zero copy is not
+  * true. Further, the records are removed from the rx_list if it is not a peek
+  * case and the record has been consumed completely.
+  */
+ static int process_rx_list(struct tls_sw_context_rx *ctx,
+ 			   struct msghdr *msg,
+ 			   u8 *control,
+ 			   bool *cmsg,
+ 			   size_t skip,
+ 			   size_t len,
+ 			   bool zc,
+ 			   bool is_peek)
+ {
+ 	struct sk_buff *skb = skb_peek(&ctx->rx_list);
+ 	u8 ctrl = *control;
+ 	u8 msgc = *cmsg;
+ 	struct tls_msg *tlm;
+ 	ssize_t copied = 0;
+ 
+ 	/* Set the record type in 'control' if caller didn't pass it */
+ 	if (!ctrl && skb) {
+ 		tlm = tls_msg(skb);
+ 		ctrl = tlm->control;
+ 	}
+ 
+ 	while (skip && skb) {
+ 		struct strp_msg *rxm = strp_msg(skb);
+ 		tlm = tls_msg(skb);
+ 
+ 		/* Cannot process a record of different type */
+ 		if (ctrl != tlm->control)
+ 			return 0;
+ 
+ 		if (skip < rxm->full_len)
+ 			break;
+ 
+ 		skip = skip - rxm->full_len;
+ 		skb = skb_peek_next(skb, &ctx->rx_list);
+ 	}
+ 
+ 	while (len && skb) {
+ 		struct sk_buff *next_skb;
+ 		struct strp_msg *rxm = strp_msg(skb);
+ 		int chunk = min_t(unsigned int, rxm->full_len - skip, len);
+ 
+ 		tlm = tls_msg(skb);
+ 
+ 		/* Cannot process a record of different type */
+ 		if (ctrl != tlm->control)
+ 			return 0;
+ 
+ 		/* Set record type if not already done. For a non-data record,
+ 		 * do not proceed if record type could not be copied.
+ 		 */
+ 		if (!msgc) {
+ 			int cerr = put_cmsg(msg, SOL_TLS, TLS_GET_RECORD_TYPE,
+ 					    sizeof(ctrl), &ctrl);
+ 			msgc = true;
+ 			if (ctrl != TLS_RECORD_TYPE_DATA) {
+ 				if (cerr || msg->msg_flags & MSG_CTRUNC)
+ 					return -EIO;
+ 
+ 				*cmsg = msgc;
+ 			}
+ 		}
+ 
+ 		if (!zc || (rxm->full_len - skip) > len) {
+ 			int err = skb_copy_datagram_msg(skb, rxm->offset + skip,
+ 						    msg, chunk);
+ 			if (err < 0)
+ 				return err;
+ 		}
+ 
+ 		len = len - chunk;
+ 		copied = copied + chunk;
+ 
+ 		/* Consume the data from record if it is non-peek case*/
+ 		if (!is_peek) {
+ 			rxm->offset = rxm->offset + chunk;
+ 			rxm->full_len = rxm->full_len - chunk;
+ 
+ 			/* Return if there is unconsumed data in the record */
+ 			if (rxm->full_len - skip)
+ 				break;
+ 		}
+ 
+ 		/* The remaining skip-bytes must lie in 1st record in rx_list.
+ 		 * So from the 2nd record, 'skip' should be 0.
+ 		 */
+ 		skip = 0;
+ 
+ 		if (msg)
+ 			msg->msg_flags |= MSG_EOR;
+ 
+ 		next_skb = skb_peek_next(skb, &ctx->rx_list);
+ 
+ 		if (!is_peek) {
+ 			skb_unlink(skb, &ctx->rx_list);
+ 			consume_skb(skb);
+ 		}
+ 
+ 		skb = next_skb;
+ 	}
+ 
+ 	*control = ctrl;
+ 	return copied;
+ }
+ 
++>>>>>>> a88c26f671b0 (net/tls: Replace kfree_skb() with consume_skb())
  int tls_sw_recvmsg(struct sock *sk,
  		   struct msghdr *msg,
  		   size_t len,
* Unmerged path net/tls/tls_sw.c
