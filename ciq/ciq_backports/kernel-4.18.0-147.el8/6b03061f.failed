spi: add support for octal mode I/O data transfer

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Yogesh Narayan Gaur <yogeshnarayan.gaur@nxp.com>
commit 6b03061f882de49b83ccf44beb3a12c920a2da1b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/6b03061f.failed

Add flags for Octal mode I/O data transfer
Required for the SPI controller which can do the data transfer (TX/RX)
on 8 data lines e.g. NXP FlexSPI controller.
 SPI_TX_OCTAL: transmit with 8 wires
 SPI_RX_OCTAL: receive with 8 wires

	Signed-off-by: Yogesh Gaur <yogeshnarayan.gaur@nxp.com>
	Reviewed-by: Boris Brezillon <boris.brezillon@bootlin.com>
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 6b03061f882de49b83ccf44beb3a12c920a2da1b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/spi/spi.h
diff --cc include/linux/spi/spi.h
index 3ced58eebe1b,0c1ca5dedbb4..000000000000
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@@ -154,8 -154,9 +154,14 @@@ struct spi_device 
  #define	SPI_TX_QUAD	0x200			/* transmit with 4 wires */
  #define	SPI_RX_DUAL	0x400			/* receive with 2 wires */
  #define	SPI_RX_QUAD	0x800			/* receive with 4 wires */
++<<<<<<< HEAD
 +#define SPI_CS_WORD	0x1000			/* toggle cs after each word */
 +#define	SPI_3WIRE_HIZ	0x2000			/* high impedance turnaround */
++=======
+ #define	SPI_CS_WORD	0x1000			/* toggle cs after each word */
+ #define	SPI_TX_OCTAL	0x2000			/* transmit with 8 wires */
+ #define	SPI_RX_OCTAL	0x4000			/* receive with 8 wires */
++>>>>>>> 6b03061f882d (spi: add support for octal mode I/O data transfer)
  	int			irq;
  	void			*controller_state;
  	void			*controller_data;
diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index b6fd8ea8ac0d..18ebc400249c 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1633,6 +1633,9 @@ static int of_spi_parse_dt(struct spi_controller *ctlr, struct spi_device *spi,
 		case 4:
 			spi->mode |= SPI_TX_QUAD;
 			break;
+		case 8:
+			spi->mode |= SPI_TX_OCTAL;
+			break;
 		default:
 			dev_warn(&ctlr->dev,
 				"spi-tx-bus-width %d not supported\n",
@@ -1651,6 +1654,9 @@ static int of_spi_parse_dt(struct spi_controller *ctlr, struct spi_device *spi,
 		case 4:
 			spi->mode |= SPI_RX_QUAD;
 			break;
+		case 8:
+			spi->mode |= SPI_RX_OCTAL;
+			break;
 		default:
 			dev_warn(&ctlr->dev,
 				"spi-rx-bus-width %d not supported\n",
@@ -2839,7 +2845,8 @@ int spi_setup(struct spi_device *spi)
 	/* if it is SPI_3WIRE mode, DUAL and QUAD should be forbidden
 	 */
 	if ((spi->mode & SPI_3WIRE) && (spi->mode &
-		(SPI_TX_DUAL | SPI_TX_QUAD | SPI_RX_DUAL | SPI_RX_QUAD)))
+		(SPI_TX_DUAL | SPI_TX_QUAD | SPI_TX_OCTAL |
+		 SPI_RX_DUAL | SPI_RX_QUAD | SPI_RX_OCTAL)))
 		return -EINVAL;
 	/* help drivers fail *cleanly* when they need options
 	 * that aren't supported with their current controller
@@ -2848,7 +2855,8 @@ int spi_setup(struct spi_device *spi)
 	 */
 	bad_bits = spi->mode & ~(spi->controller->mode_bits | SPI_CS_WORD);
 	ugly_bits = bad_bits &
-		    (SPI_TX_DUAL | SPI_TX_QUAD | SPI_RX_DUAL | SPI_RX_QUAD);
+		    (SPI_TX_DUAL | SPI_TX_QUAD | SPI_TX_OCTAL |
+		     SPI_RX_DUAL | SPI_RX_QUAD | SPI_RX_OCTAL);
 	if (ugly_bits) {
 		dev_warn(&spi->dev,
 			 "setup: ignoring unsupported mode bits %x\n",
* Unmerged path include/linux/spi/spi.h
