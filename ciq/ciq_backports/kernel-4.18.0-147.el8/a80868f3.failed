KVM: arm/arm64: Enforce PTE mappings at stage2 when needed

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Suzuki K Poulose <suzuki.poulose@arm.com>
commit a80868f398554842b14d07060012c06efb57c456
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/a80868f3.failed

commit 6794ad5443a2118 ("KVM: arm/arm64: Fix unintended stage 2 PMD mappings")
made the checks to skip huge mappings, stricter. However it introduced
a bug where we still use huge mappings, ignoring the flag to
use PTE mappings, by not reseting the vma_pagesize to PAGE_SIZE.

Also, the checks do not cover the PUD huge pages, that was
under review during the same period. This patch fixes both
the issues.

Fixes : 6794ad5443a2118 ("KVM: arm/arm64: Fix unintended stage 2 PMD mappings")
	Reported-by: Zenghui Yu <yuzenghui@huawei.com>
	Cc: Zenghui Yu <yuzenghui@huawei.com>
	Cc: Christoffer Dall <christoffer.dall@arm.com>
	Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
	Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
(cherry picked from commit a80868f398554842b14d07060012c06efb57c456)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	virt/kvm/arm/mmu.c
diff --cc virt/kvm/arm/mmu.c
index 07ca5de32432,bcdf978c0d1d..000000000000
--- a/virt/kvm/arm/mmu.c
+++ b/virt/kvm/arm/mmu.c
@@@ -1554,10 -1686,23 +1549,30 @@@ static int user_mem_abort(struct kvm_vc
  		return -EFAULT;
  	}
  
++<<<<<<< HEAD
 +	if (vma_kernel_pagesize(vma) == PMD_SIZE && !force_pte) {
 +		hugetlb = true;
 +		gfn = (fault_ipa & PMD_MASK) >> PAGE_SHIFT;
 +	}
++=======
+ 	vma_pagesize = vma_kernel_pagesize(vma);
+ 	if (logging_active ||
+ 	    !fault_supports_stage2_huge_mapping(memslot, hva, vma_pagesize)) {
+ 		force_pte = true;
+ 		vma_pagesize = PAGE_SIZE;
+ 	}
+ 
+ 	/*
+ 	 * The stage2 has a minimum of 2 level table (For arm64 see
+ 	 * kvm_arm_setup_stage2()). Hence, we are guaranteed that we can
+ 	 * use PMD_SIZE huge mappings (even when the PMD is folded into PGD).
+ 	 * As for PUD huge maps, we must make sure that we have at least
+ 	 * 3 levels, i.e, PMD is not folded.
+ 	 */
+ 	if (vma_pagesize == PMD_SIZE ||
+ 	    (vma_pagesize == PUD_SIZE && kvm_stage2_has_pmd(kvm)))
+ 		gfn = (fault_ipa & huge_page_mask(hstate_vma(vma))) >> PAGE_SHIFT;
++>>>>>>> a80868f39855 (KVM: arm/arm64: Enforce PTE mappings at stage2 when needed)
  	up_read(&current->mm->mmap_sem);
  
  	/* We need minimum second+third level pages */
* Unmerged path virt/kvm/arm/mmu.c
