vxlan: Split vxlan_fdb_update() in two

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Petr Machata <petrm@mellanox.com>
commit a76d1ca296a7eefba5d186014fc4cd14ee98c28b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/a76d1ca2.failed

In order to make it easier to implement rollbacks after FDB update
vetoing, separate the FDB update code to two parts: one that deals with
updates of existing FDB entries, and one that creates new entries.

	Signed-off-by: Petr Machata <petrm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a76d1ca296a7eefba5d186014fc4cd14ee98c28b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index 4ecaa83ef765,aeaa429229c7..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -820,18 -826,135 +820,142 @@@ static int vxlan_fdb_create(struct vxla
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void vxlan_fdb_free(struct rcu_head *head)
+ {
+ 	struct vxlan_fdb *f = container_of(head, struct vxlan_fdb, rcu);
+ 	struct vxlan_rdst *rd, *nd;
+ 
+ 	list_for_each_entry_safe(rd, nd, &f->remotes, list) {
+ 		dst_cache_destroy(&rd->dst_cache);
+ 		kfree(rd);
+ 	}
+ 	kfree(f);
+ }
+ 
+ static void vxlan_fdb_destroy(struct vxlan_dev *vxlan, struct vxlan_fdb *f,
+ 			      bool do_notify, bool swdev_notify)
+ {
+ 	struct vxlan_rdst *rd;
+ 
+ 	netdev_dbg(vxlan->dev, "delete %pM\n", f->eth_addr);
+ 
+ 	--vxlan->addrcnt;
+ 	if (do_notify)
+ 		list_for_each_entry(rd, &f->remotes, list)
+ 			vxlan_fdb_notify(vxlan, f, rd, RTM_DELNEIGH,
+ 					 swdev_notify);
+ 
+ 	hlist_del_rcu(&f->hlist);
+ 	call_rcu(&f->rcu, vxlan_fdb_free);
+ }
+ 
+ static int vxlan_fdb_update_existing(struct vxlan_dev *vxlan,
+ 				     union vxlan_addr *ip,
+ 				     __u16 state, __u16 flags,
+ 				     __be16 port, __be32 vni,
+ 				     __u32 ifindex, __u16 ndm_flags,
+ 				     struct vxlan_fdb *f,
+ 				     bool swdev_notify)
+ {
+ 	__u16 fdb_flags = (ndm_flags & ~NTF_USE);
+ 	struct vxlan_rdst *rd = NULL;
+ 	int notify = 0;
+ 	int rc;
+ 
+ 	/* Do not allow an externally learned entry to take over an entry added
+ 	 * by the user.
+ 	 */
+ 	if (!(fdb_flags & NTF_EXT_LEARNED) ||
+ 	    !(f->flags & NTF_VXLAN_ADDED_BY_USER)) {
+ 		if (f->state != state) {
+ 			f->state = state;
+ 			f->updated = jiffies;
+ 			notify = 1;
+ 		}
+ 		if (f->flags != fdb_flags) {
+ 			f->flags = fdb_flags;
+ 			f->updated = jiffies;
+ 			notify = 1;
+ 		}
+ 	}
+ 
+ 	if ((flags & NLM_F_REPLACE)) {
+ 		/* Only change unicasts */
+ 		if (!(is_multicast_ether_addr(f->eth_addr) ||
+ 		      is_zero_ether_addr(f->eth_addr))) {
+ 			rc = vxlan_fdb_replace(f, ip, port, vni,
+ 					       ifindex);
+ 			notify |= rc;
+ 		} else {
+ 			return -EOPNOTSUPP;
+ 		}
+ 	}
+ 	if ((flags & NLM_F_APPEND) &&
+ 	    (is_multicast_ether_addr(f->eth_addr) ||
+ 	     is_zero_ether_addr(f->eth_addr))) {
+ 		rc = vxlan_fdb_append(f, ip, port, vni, ifindex, &rd);
+ 
+ 		if (rc < 0)
+ 			return rc;
+ 		notify |= rc;
+ 	}
+ 
+ 	if (ndm_flags & NTF_USE)
+ 		f->used = jiffies;
+ 
+ 	if (notify) {
+ 		if (rd == NULL)
+ 			rd = first_remote_rtnl(f);
+ 
+ 		vxlan_fdb_notify(vxlan, f, rd, RTM_NEWNEIGH, swdev_notify);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int vxlan_fdb_update_create(struct vxlan_dev *vxlan,
+ 				   const u8 *mac, union vxlan_addr *ip,
+ 				   __u16 state, __u16 flags,
+ 				   __be16 port, __be32 src_vni, __be32 vni,
+ 				   __u32 ifindex, __u16 ndm_flags,
+ 				   bool swdev_notify)
+ {
+ 	__u16 fdb_flags = (ndm_flags & ~NTF_USE);
+ 	struct vxlan_fdb *f;
+ 	int rc;
+ 
+ 	/* Disallow replace to add a multicast entry */
+ 	if ((flags & NLM_F_REPLACE) &&
+ 	    (is_multicast_ether_addr(mac) || is_zero_ether_addr(mac)))
+ 		return -EOPNOTSUPP;
+ 
+ 	netdev_dbg(vxlan->dev, "add %pM -> %pIS\n", mac, ip);
+ 	rc = vxlan_fdb_create(vxlan, mac, ip, state, port, src_vni,
+ 			      vni, ifindex, fdb_flags, &f);
+ 	if (rc < 0)
+ 		return rc;
+ 
+ 	vxlan_fdb_notify(vxlan, f, first_remote_rtnl(f), RTM_NEWNEIGH,
+ 			 swdev_notify);
+ 	return 0;
+ }
+ 
++>>>>>>> a76d1ca296a7 (vxlan: Split vxlan_fdb_update() in two)
  /* Add new entry to forwarding table -- assumes lock held */
  static int vxlan_fdb_update(struct vxlan_dev *vxlan,
  			    const u8 *mac, union vxlan_addr *ip,
  			    __u16 state, __u16 flags,
  			    __be16 port, __be32 src_vni, __be32 vni,
 -			    __u32 ifindex, __u16 ndm_flags,
 -			    bool swdev_notify)
 +			    __u32 ifindex, __u8 ndm_flags)
  {
++<<<<<<< HEAD
 +	__u8 fdb_flags = (ndm_flags & ~NTF_USE);
 +	struct vxlan_rdst *rd = NULL;
++=======
++>>>>>>> a76d1ca296a7 (vxlan: Split vxlan_fdb_update() in two)
  	struct vxlan_fdb *f;
- 	int notify = 0;
- 	int rc;
  
  	f = __vxlan_find_mac(vxlan, mac, src_vni);
  	if (f) {
@@@ -883,55 -971,10 +972,50 @@@
  		if (!(flags & NLM_F_CREATE))
  			return -ENOENT;
  
- 		/* Disallow replace to add a multicast entry */
- 		if ((flags & NLM_F_REPLACE) &&
- 		    (is_multicast_ether_addr(mac) || is_zero_ether_addr(mac)))
- 			return -EOPNOTSUPP;
- 
- 		netdev_dbg(vxlan->dev, "add %pM -> %pIS\n", mac, ip);
- 		rc = vxlan_fdb_create(vxlan, mac, ip, state, port, src_vni,
- 				      vni, ifindex, fdb_flags, &f);
- 		if (rc < 0)
- 			return rc;
- 		notify = 1;
+ 		return vxlan_fdb_update_create(vxlan, mac, ip, state, flags,
+ 					       port, src_vni, vni, ifindex,
+ 					       ndm_flags, swdev_notify);
  	}
++<<<<<<< HEAD
 +
 +	if (notify) {
 +		if (rd == NULL)
 +			rd = first_remote_rtnl(f);
 +		vxlan_fdb_notify(vxlan, f, rd, RTM_NEWNEIGH);
 +	}
 +
 +	return 0;
++=======
++>>>>>>> a76d1ca296a7 (vxlan: Split vxlan_fdb_update() in two)
 +}
 +
 +static void vxlan_fdb_free(struct rcu_head *head)
 +{
 +	struct vxlan_fdb *f = container_of(head, struct vxlan_fdb, rcu);
 +	struct vxlan_rdst *rd, *nd;
 +
 +	list_for_each_entry_safe(rd, nd, &f->remotes, list) {
 +		dst_cache_destroy(&rd->dst_cache);
 +		kfree(rd);
 +	}
 +	kfree(f);
 +}
 +
 +static void vxlan_fdb_destroy(struct vxlan_dev *vxlan, struct vxlan_fdb *f,
 +			      bool do_notify)
 +{
 +	struct vxlan_rdst *rd;
 +
 +	netdev_dbg(vxlan->dev,
 +		    "delete %pM\n", f->eth_addr);
 +
 +	--vxlan->addrcnt;
 +	if (do_notify)
 +		list_for_each_entry(rd, &f->remotes, list)
 +			vxlan_fdb_notify(vxlan, f, rd, RTM_DELNEIGH);
 +
 +	hlist_del_rcu(&f->hlist);
 +	call_rcu(&f->rcu, vxlan_fdb_free);
  }
  
  static void vxlan_dst_free(struct rcu_head *head)
* Unmerged path drivers/net/vxlan.c
