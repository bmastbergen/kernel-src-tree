KVM: nVMX: Verify eVMCS revision id match supported eVMCS version on eVMCS VMPTRLD

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Liran Alon <liran.alon@oracle.com>
commit 72aeb60c52bf74a0eeec77d6b41ce40145697d76
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/72aeb60c.failed

According to TLFS section 16.11.2 Enlightened VMCS, the first u32
field of eVMCS should specify eVMCS VersionNumber.

This version should be in the range of supported eVMCS versions exposed
to guest via CPUID.0x4000000A.EAX[0:15].
The range which KVM expose to guest in this CPUID field should be the
same as the value returned in vmcs_version by nested_enable_evmcs().

According to the above, eVMCS VMPTRLD should verify that version specified
in given eVMCS is in the supported range. However, current code
mistakenly verfies this field against VMCS12_REVISION.

One can also see that when KVM use eVMCS, it makes sure that
alloc_vmcs_cpu() sets allocated eVMCS revision_id to KVM_EVMCS_VERSION.

Obvious fix should just change eVMCS VMPTRLD to verify first u32 field
of eVMCS is equal to KVM_EVMCS_VERSION.
However, it turns out that Microsoft Hyper-V fails to comply to their
own invented interface: When Hyper-V use eVMCS, it just sets first u32
field of eVMCS to revision_id specified in MSR_IA32_VMX_BASIC (In our
case: VMCS12_REVISION). Instead of used eVMCS version number which is
one of the supported versions specified in CPUID.0x4000000A.EAX[0:15].
To overcome Hyper-V bug, we accept either a supported eVMCS version
or VMCS12_REVISION as valid values for first u32 field of eVMCS.

	Cc: Vitaly Kuznetsov <vkuznets@redhat.com>
	Reviewed-by: Nikita Leshenko <nikita.leshchenko@oracle.com>
	Reviewed-by: Mark Kanda <mark.kanda@oracle.com>
	Signed-off-by: Liran Alon <liran.alon@oracle.com>
	Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 72aeb60c52bf74a0eeec77d6b41ce40145697d76)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index 7277313a2734,0ffd8b2dbfe2..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -9308,8 -9340,94 +9308,99 @@@ static int handle_vmptrld(struct kvm_vc
  		set_current_vmptr(vmx, vmptr);
  	}
  
++<<<<<<< HEAD
 +	nested_vmx_succeed(vcpu);
 +	return kvm_skip_emulated_instruction(vcpu);
++=======
+ 	return nested_vmx_succeed(vcpu);
+ }
+ 
+ /*
+  * This is an equivalent of the nested hypervisor executing the vmptrld
+  * instruction.
+  */
+ static int nested_vmx_handle_enlightened_vmptrld(struct kvm_vcpu *vcpu,
+ 						 bool from_launch)
+ {
+ 	struct vcpu_vmx *vmx = to_vmx(vcpu);
+ 	struct hv_vp_assist_page assist_page;
+ 
+ 	if (likely(!vmx->nested.enlightened_vmcs_enabled))
+ 		return 1;
+ 
+ 	if (unlikely(!kvm_hv_get_assist_page(vcpu, &assist_page)))
+ 		return 1;
+ 
+ 	if (unlikely(!assist_page.enlighten_vmentry))
+ 		return 1;
+ 
+ 	if (unlikely(assist_page.current_nested_vmcs !=
+ 		     vmx->nested.hv_evmcs_vmptr)) {
+ 
+ 		if (!vmx->nested.hv_evmcs)
+ 			vmx->nested.current_vmptr = -1ull;
+ 
+ 		nested_release_evmcs(vcpu);
+ 
+ 		vmx->nested.hv_evmcs_page = kvm_vcpu_gpa_to_page(
+ 			vcpu, assist_page.current_nested_vmcs);
+ 
+ 		if (unlikely(is_error_page(vmx->nested.hv_evmcs_page)))
+ 			return 0;
+ 
+ 		vmx->nested.hv_evmcs = kmap(vmx->nested.hv_evmcs_page);
+ 
+ 		/*
+ 		 * Currently, KVM only supports eVMCS version 1
+ 		 * (== KVM_EVMCS_VERSION) and thus we expect guest to set this
+ 		 * value to first u32 field of eVMCS which should specify eVMCS
+ 		 * VersionNumber.
+ 		 *
+ 		 * Guest should be aware of supported eVMCS versions by host by
+ 		 * examining CPUID.0x4000000A.EAX[0:15]. Host userspace VMM is
+ 		 * expected to set this CPUID leaf according to the value
+ 		 * returned in vmcs_version from nested_enable_evmcs().
+ 		 *
+ 		 * However, it turns out that Microsoft Hyper-V fails to comply
+ 		 * to their own invented interface: When Hyper-V use eVMCS, it
+ 		 * just sets first u32 field of eVMCS to revision_id specified
+ 		 * in MSR_IA32_VMX_BASIC. Instead of used eVMCS version number
+ 		 * which is one of the supported versions specified in
+ 		 * CPUID.0x4000000A.EAX[0:15].
+ 		 *
+ 		 * To overcome Hyper-V bug, we accept here either a supported
+ 		 * eVMCS version or VMCS12 revision_id as valid values for first
+ 		 * u32 field of eVMCS.
+ 		 */
+ 		if ((vmx->nested.hv_evmcs->revision_id != KVM_EVMCS_VERSION) &&
+ 		    (vmx->nested.hv_evmcs->revision_id != VMCS12_REVISION)) {
+ 			nested_release_evmcs(vcpu);
+ 			return 0;
+ 		}
+ 
+ 		vmx->nested.dirty_vmcs12 = true;
+ 		/*
+ 		 * As we keep L2 state for one guest only 'hv_clean_fields' mask
+ 		 * can't be used when we switch between them. Reset it here for
+ 		 * simplicity.
+ 		 */
+ 		vmx->nested.hv_evmcs->hv_clean_fields &=
+ 			~HV_VMX_ENLIGHTENED_CLEAN_FIELD_ALL;
+ 		vmx->nested.hv_evmcs_vmptr = assist_page.current_nested_vmcs;
+ 
+ 		/*
+ 		 * Unlike normal vmcs12, enlightened vmcs12 is not fully
+ 		 * reloaded from guest's memory (read only fields, fields not
+ 		 * present in struct hv_enlightened_vmcs, ...). Make sure there
+ 		 * are no leftovers.
+ 		 */
+ 		if (from_launch)
+ 			memset(vmx->nested.cached_vmcs12, 0,
+ 			       sizeof(*vmx->nested.cached_vmcs12));
+ 
+ 	}
+ 	return 1;
++>>>>>>> 72aeb60c52bf (KVM: nVMX: Verify eVMCS revision id match supported eVMCS version on eVMCS VMPTRLD)
  }
  
  /* Emulate the VMPTRST instruction */
* Unmerged path arch/x86/kvm/vmx.c
