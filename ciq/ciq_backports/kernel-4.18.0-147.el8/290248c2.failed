drm/i915: Implement new w/a for underruns with wm1+ disabled

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit 290248c27c93ad70262b8112595b95ad9d867929
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/290248c2.failed

The new workaround from the hw team involves leaving WM1
still disabled but programming the blocks value
identically to WM0, and we also need to set the "ignore
lines watermark" bit for WM1.

v2: Fix commit message wording a bit

	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190213165424.22904-3-ville.syrjala@linux.intel.com
	Reviewed-by: Clint Taylor <Clinton.A.Taylor@intel.com>
(cherry picked from commit 290248c27c93ad70262b8112595b95ad9d867929)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_pm.c
diff --cc drivers/gpu/drm/i915/intel_pm.c
index 53aaaa3e6886,c7ec9b169046..000000000000
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@@ -4353,39 -4433,54 +4353,61 @@@ skl_allocate_pipe_ddb(struct intel_crtc
  		if (plane_id == PLANE_CURSOR)
  			continue;
  
 -		plane_alloc = &cstate->wm.skl.plane_ddb_y[plane_id];
 -		uv_plane_alloc = &cstate->wm.skl.plane_ddb_uv[plane_id];
 +		data_rate = plane_data_rate[plane_id];
  
 -		/* Gen11+ uses a separate plane for UV watermarks */
 -		WARN_ON(INTEL_GEN(dev_priv) >= 11 && uv_total[plane_id]);
 +		/*
 +		 * allocation for (packed formats) or (uv-plane part of planar format):
 +		 * promote the expression to 64 bits to avoid overflowing, the
 +		 * result is < available as data_rate / total_data_rate < 1
 +		 */
 +		plane_blocks = minimum[plane_id];
 +		plane_blocks += div_u64((uint64_t)alloc_size * data_rate,
 +					total_data_rate);
  
  		/* Leave disabled planes at (0,0) */
 -		if (total[plane_id]) {
 -			plane_alloc->start = start;
 -			start += total[plane_id];
 -			plane_alloc->end = start;
 +		if (data_rate) {
 +			ddb->plane[pipe][plane_id].start = start;
 +			ddb->plane[pipe][plane_id].end = start + plane_blocks;
  		}
  
 -		if (uv_total[plane_id]) {
 -			uv_plane_alloc->start = start;
 -			start += uv_total[plane_id];
 -			uv_plane_alloc->end = start;
 -		}
 -	}
 +		start += plane_blocks;
  
++<<<<<<< HEAD
 +		/* Allocate DDB for UV plane for planar format/NV12 */
 +		uv_data_rate = uv_plane_data_rate[plane_id];
++=======
+ 	/*
+ 	 * When we calculated watermark values we didn't know how high
+ 	 * of a level we'd actually be able to hit, so we just marked
+ 	 * all levels as "enabled."  Go back now and disable the ones
+ 	 * that aren't actually possible.
+ 	 */
+ 	for (level++; level <= ilk_wm_max_level(dev_priv); level++) {
+ 		for_each_plane_id_on_crtc(intel_crtc, plane_id) {
+ 			wm = &cstate->wm.skl.optimal.planes[plane_id];
+ 			memset(&wm->wm[level], 0, sizeof(wm->wm[level]));
+ 
+ 			/* W/A for underruns with WM1+ disabled */
+ 			if (IS_ICELAKE(dev_priv) &&
+ 			    level == 1 && wm->wm[0].plane_en) {
+ 				wm->wm[level].plane_res_b = wm->wm[0].plane_res_b;
+ 				wm->wm[level].ignore_lines = true;
+ 			}
+ 		}
+ 	}
++>>>>>>> 290248c27c93 (drm/i915: Implement new w/a for underruns with wm1+ disabled)
  
 -	/*
 -	 * Go back and disable the transition watermark if it turns out we
 -	 * don't have enough DDB blocks for it.
 -	 */
 -	for_each_plane_id_on_crtc(intel_crtc, plane_id) {
 -		wm = &cstate->wm.skl.optimal.planes[plane_id];
 -		if (wm->trans_wm.plane_res_b >= total[plane_id])
 -			memset(&wm->trans_wm, 0, sizeof(wm->trans_wm));
 +		uv_plane_blocks = uv_minimum[plane_id];
 +		uv_plane_blocks += div_u64((uint64_t)alloc_size * uv_data_rate,
 +					   total_data_rate);
 +
 +		if (uv_data_rate) {
 +			ddb->uv_plane[pipe][plane_id].start = start;
 +			ddb->uv_plane[pipe][plane_id].end =
 +				start + uv_plane_blocks;
 +		}
 +
 +		start += uv_plane_blocks;
  	}
  
  	return 0;
* Unmerged path drivers/gpu/drm/i915/intel_pm.c
