net/mlx5e: Unblock setting vid 0 for VFs through the uplink rep

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Or Gerlitz <ogerlitz@mellanox.com>
commit 6ce966fd2671899a48037abe7bf1df80a5adf029
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/6ce966fd.failed

It turns out that libvirt uses 0-vid as a default if no vlan was
set for the guest (which is the case for switchdev mode) and errs
if we disallow that:

error: Failed to start domain vm75
error: Cannot set interface MAC/vlanid to 6a:66:2d:48:92:c2/0 \
		for ifname enp59s0f0 vf 0: Operation not supported

So allow this in order not to break existing systems.

	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Reported-by: Maor Dickman <maord@mellanox.com>
	Reviewed-by: Gavi Teitz <gavi@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 6ce966fd2671899a48037abe7bf1df80a5adf029)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index 48489728eca3,f2573c2d2b5c..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -1082,30 -1272,93 +1082,103 @@@ mlx5e_rep_get_stats(struct net_device *
  	memcpy(stats, &priv->stats.vf_vport, sizeof(*stats));
  }
  
++<<<<<<< HEAD
++=======
+ static int mlx5e_vf_rep_change_mtu(struct net_device *netdev, int new_mtu)
+ {
+ 	return mlx5e_change_mtu(netdev, new_mtu, NULL);
+ }
+ 
+ static int mlx5e_uplink_rep_change_mtu(struct net_device *netdev, int new_mtu)
+ {
+ 	return mlx5e_change_mtu(netdev, new_mtu, mlx5e_set_dev_port_mtu);
+ }
+ 
+ static int mlx5e_uplink_rep_set_mac(struct net_device *netdev, void *addr)
+ {
+ 	struct sockaddr *saddr = addr;
+ 
+ 	if (!is_valid_ether_addr(saddr->sa_data))
+ 		return -EADDRNOTAVAIL;
+ 
+ 	ether_addr_copy(netdev->dev_addr, saddr->sa_data);
+ 	return 0;
+ }
+ 
+ static int mlx5e_uplink_rep_set_vf_vlan(struct net_device *dev, int vf, u16 vlan, u8 qos,
+ 					__be16 vlan_proto)
+ {
+ 	netdev_warn_once(dev, "legacy vf vlan setting isn't supported in switchdev mode\n");
+ 
+ 	if (vlan != 0)
+ 		return -EOPNOTSUPP;
+ 
+ 	/* allow setting 0-vid for compatibility with libvirt */
+ 	return 0;
+ }
+ 
++>>>>>>> 6ce966fd2671 (net/mlx5e: Unblock setting vid 0 for VFs through the uplink rep)
  static const struct switchdev_ops mlx5e_rep_switchdev_ops = {
  	.switchdev_port_attr_get	= mlx5e_attr_get,
  };
  
++<<<<<<< HEAD
 +static int mlx5e_change_rep_mtu(struct net_device *netdev, int new_mtu)
++=======
+ static const struct net_device_ops mlx5e_netdev_ops_vf_rep = {
+ 	.ndo_open                = mlx5e_vf_rep_open,
+ 	.ndo_stop                = mlx5e_vf_rep_close,
+ 	.ndo_start_xmit          = mlx5e_xmit,
+ 	.ndo_get_phys_port_name  = mlx5e_rep_get_phys_port_name,
+ 	.ndo_setup_tc            = mlx5e_rep_setup_tc,
+ 	.ndo_get_stats64         = mlx5e_vf_rep_get_stats,
+ 	.ndo_has_offload_stats	 = mlx5e_rep_has_offload_stats,
+ 	.ndo_get_offload_stats	 = mlx5e_rep_get_offload_stats,
+ 	.ndo_change_mtu          = mlx5e_vf_rep_change_mtu,
+ };
+ 
+ static const struct net_device_ops mlx5e_netdev_ops_uplink_rep = {
+ 	.ndo_open                = mlx5e_open,
+ 	.ndo_stop                = mlx5e_close,
+ 	.ndo_start_xmit          = mlx5e_xmit,
+ 	.ndo_set_mac_address     = mlx5e_uplink_rep_set_mac,
+ 	.ndo_get_phys_port_name  = mlx5e_rep_get_phys_port_name,
+ 	.ndo_setup_tc            = mlx5e_rep_setup_tc,
+ 	.ndo_get_stats64         = mlx5e_get_stats,
+ 	.ndo_has_offload_stats	 = mlx5e_rep_has_offload_stats,
+ 	.ndo_get_offload_stats	 = mlx5e_rep_get_offload_stats,
+ 	.ndo_change_mtu          = mlx5e_uplink_rep_change_mtu,
+ 	.ndo_udp_tunnel_add      = mlx5e_add_vxlan_port,
+ 	.ndo_udp_tunnel_del      = mlx5e_del_vxlan_port,
+ 	.ndo_features_check      = mlx5e_features_check,
+ 	.ndo_set_vf_mac          = mlx5e_set_vf_mac,
+ 	.ndo_set_vf_rate         = mlx5e_set_vf_rate,
+ 	.ndo_get_vf_config       = mlx5e_get_vf_config,
+ 	.ndo_get_vf_stats        = mlx5e_get_vf_stats,
+ 	.ndo_set_vf_vlan         = mlx5e_uplink_rep_set_vf_vlan,
+ };
+ 
+ bool mlx5e_eswitch_rep(struct net_device *netdev)
++>>>>>>> 6ce966fd2671 (net/mlx5e: Unblock setting vid 0 for VFs through the uplink rep)
  {
 -	if (netdev->netdev_ops == &mlx5e_netdev_ops_vf_rep ||
 -	    netdev->netdev_ops == &mlx5e_netdev_ops_uplink_rep)
 -		return true;
 -
 -	return false;
 +	return mlx5e_change_mtu(netdev, new_mtu, NULL);
  }
  
 -static void mlx5e_build_rep_params(struct net_device *netdev)
 -{
 -	struct mlx5e_priv *priv = netdev_priv(netdev);
 -	struct mlx5e_rep_priv *rpriv = priv->ppriv;
 -	struct mlx5_eswitch_rep *rep = rpriv->rep;
 -	struct mlx5_core_dev *mdev = priv->mdev;
 -	struct mlx5e_params *params;
 +static const struct net_device_ops mlx5e_netdev_ops_rep = {
 +	.ndo_open                = mlx5e_rep_open,
 +	.ndo_stop                = mlx5e_rep_close,
 +	.ndo_start_xmit          = mlx5e_xmit,
 +	.ndo_get_phys_port_name  = mlx5e_rep_get_phys_port_name,
 +	.ndo_setup_tc            = mlx5e_rep_setup_tc,
 +	.ndo_get_stats64         = mlx5e_rep_get_stats,
 +	.ndo_has_offload_stats	 = mlx5e_has_offload_stats,
 +	.ndo_get_offload_stats	 = mlx5e_get_offload_stats,
 +	.ndo_change_mtu          = mlx5e_change_rep_mtu,
 +};
  
 +static void mlx5e_build_rep_params(struct mlx5_core_dev *mdev,
 +				   struct mlx5e_params *params, u16 mtu)
 +{
  	u8 cq_period_mode = MLX5_CAP_GEN(mdev, cq_period_start_from_cqe) ?
  					 MLX5_CQ_PERIOD_MODE_START_FROM_CQE :
  					 MLX5_CQ_PERIOD_MODE_START_FROM_EQE;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
