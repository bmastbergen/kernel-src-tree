bpf: sockmap, support for msg_peek in sk_msg with redirect ingress

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author John Fastabend <john.fastabend@gmail.com>
commit 02c558b2d5d679fbbcaa5b9689484c7e0f8abb7b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/02c558b2.failed

This adds support for the MSG_PEEK flag when doing redirect to ingress
and receiving on the sk_msg psock queue. Previously the flag was
being ignored which could confuse applications if they expected the
flag to work as normal.

	Signed-off-by: John Fastabend <john.fastabend@gmail.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit 02c558b2d5d679fbbcaa5b9689484c7e0f8abb7b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/tcp.h
#	net/ipv4/tcp_bpf.c
#	net/tls/tls_sw.c
diff --cc include/net/tcp.h
index 422320636e29,14fdd7ce9992..000000000000
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@@ -2026,6 -2079,18 +2026,21 @@@ void tcp_cleanup_ulp(struct sock *sk)
  	__MODULE_INFO(alias, alias_userspace, name);		\
  	__MODULE_INFO(alias, alias_tcp_ulp, "tcp-ulp-" name)
  
++<<<<<<< HEAD
++=======
+ struct sk_msg;
+ struct sk_psock;
+ 
+ int tcp_bpf_init(struct sock *sk);
+ void tcp_bpf_reinit(struct sock *sk);
+ int tcp_bpf_sendmsg_redir(struct sock *sk, struct sk_msg *msg, u32 bytes,
+ 			  int flags);
+ int tcp_bpf_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,
+ 		    int nonblock, int flags, int *addr_len);
+ int __tcp_bpf_recvmsg(struct sock *sk, struct sk_psock *psock,
+ 		      struct msghdr *msg, int len, int flags);
+ 
++>>>>>>> 02c558b2d5d6 (bpf: sockmap, support for msg_peek in sk_msg with redirect ingress)
  /* Call BPF_SOCK_OPS program that returns an int. If the return value
   * is < 0, then the BPF op failed (for example if the loaded BPF
   * program does not support the chosen operation or there is no BPF
diff --cc net/tls/tls_sw.c
index 79112fc82343,5cd88ba8acd1..000000000000
--- a/net/tls/tls_sw.c
+++ b/net/tls/tls_sw.c
@@@ -1159,13 -1472,26 +1159,28 @@@ int tls_sw_recvmsg(struct sock *sk
  	timeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);
  	do {
  		bool zc = false;
 -		bool async = false;
  		int chunk = 0;
  
++<<<<<<< HEAD
 +		skb = tls_wait_data(sk, flags, timeo, &err);
 +		if (!skb)
++=======
+ 		skb = tls_wait_data(sk, psock, flags, timeo, &err);
+ 		if (!skb) {
+ 			if (psock) {
+ 				int ret = __tcp_bpf_recvmsg(sk, psock,
+ 							    msg, len, flags);
+ 
+ 				if (ret > 0) {
+ 					copied += ret;
+ 					len -= ret;
+ 					continue;
+ 				}
+ 			}
++>>>>>>> 02c558b2d5d6 (bpf: sockmap, support for msg_peek in sk_msg with redirect ingress)
  			goto recv_end;
 -		}
  
  		rxm = strp_msg(skb);
 -
  		if (!cmsg) {
  			int cerr;
  
* Unmerged path net/ipv4/tcp_bpf.c
* Unmerged path include/net/tcp.h
* Unmerged path net/ipv4/tcp_bpf.c
* Unmerged path net/tls/tls_sw.c
