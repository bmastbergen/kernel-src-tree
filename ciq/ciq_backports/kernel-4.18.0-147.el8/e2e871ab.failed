x86/kvm/hyper-v: Introduce nested_get_evmcs_version() helper

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit e2e871ab2f02dc9ca5f06065234475393dcec38b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/e2e871ab.failed

The upcoming KVM_GET_SUPPORTED_HV_CPUID ioctl will need to return
Enlightened VMCS version in HYPERV_CPUID_NESTED_FEATURES.EAX when
it was enabled.

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit e2e871ab2f02dc9ca5f06065234475393dcec38b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/kvm_host.h
#	arch/x86/kvm/svm.c
#	arch/x86/kvm/vmx/evmcs.h
#	arch/x86/kvm/vmx/nested.c
#	arch/x86/kvm/vmx/vmx_evmcs.h
diff --cc arch/x86/include/asm/kvm_host.h
index 4f4c34f2efda,f5c2ce4f01e8..000000000000
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@@ -1163,6 -1183,10 +1163,13 @@@ struct kvm_x86_ops 
  	int (*mem_enc_unreg_region)(struct kvm *kvm, struct kvm_enc_region *argp);
  
  	int (*get_msr_feature)(struct kvm_msr_entry *entry);
++<<<<<<< HEAD
++=======
+ 
+ 	int (*nested_enable_evmcs)(struct kvm_vcpu *vcpu,
+ 				   uint16_t *vmcs_version);
+ 	uint16_t (*nested_get_evmcs_version)(struct kvm_vcpu *vcpu);
++>>>>>>> e2e871ab2f02 (x86/kvm/hyper-v: Introduce nested_get_evmcs_version() helper)
  };
  
  struct kvm_arch_async_pf {
diff --cc arch/x86/kvm/svm.c
index be709a061a79,0762e81e0498..000000000000
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@@ -7054,6 -7047,19 +7054,22 @@@ failed
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static uint16_t nested_get_evmcs_version(struct kvm_vcpu *vcpu)
+ {
+ 	/* Not supported */
+ 	return 0;
+ }
+ 
+ static int nested_enable_evmcs(struct kvm_vcpu *vcpu,
+ 				   uint16_t *vmcs_version)
+ {
+ 	/* Intel-only feature */
+ 	return -ENODEV;
+ }
+ 
++>>>>>>> e2e871ab2f02 (x86/kvm/hyper-v: Introduce nested_get_evmcs_version() helper)
  static struct kvm_x86_ops svm_x86_ops __ro_after_init = {
  	.cpu_has_kvm_support = has_svm,
  	.disabled_by_bios = is_disabled,
@@@ -7183,6 -7189,9 +7199,12 @@@
  	.mem_enc_op = svm_mem_enc_op,
  	.mem_enc_reg_region = svm_register_enc_region,
  	.mem_enc_unreg_region = svm_unregister_enc_region,
++<<<<<<< HEAD
++=======
+ 
+ 	.nested_enable_evmcs = nested_enable_evmcs,
+ 	.nested_get_evmcs_version = nested_get_evmcs_version,
++>>>>>>> e2e871ab2f02 (x86/kvm/hyper-v: Introduce nested_get_evmcs_version() helper)
  };
  
  static int __init svm_init(void)
diff --cc arch/x86/kvm/vmx/vmx_evmcs.h
index 210a884090ad,95bc2247478d..000000000000
--- a/arch/x86/kvm/vmx/vmx_evmcs.h
+++ b/arch/x86/kvm/vmx/vmx_evmcs.h
@@@ -298,27 -300,53 +298,67 @@@ static const struct evmcs_field vmcs_fi
  	EVMCS1_FIELD(VIRTUAL_PROCESSOR_ID, virtual_processor_id,
  		     HV_VMX_ENLIGHTENED_CLEAN_FIELD_CONTROL_XLAT),
  };
 -const unsigned int nr_evmcs_1_fields = ARRAY_SIZE(vmcs_field_to_evmcs_1);
  
 -void evmcs_sanitize_exec_ctrls(struct vmcs_config *vmcs_conf)
 +static __always_inline int get_evmcs_offset(unsigned long field,
 +					    u16 *clean_field)
  {
 -	vmcs_conf->pin_based_exec_ctrl &= ~EVMCS1_UNSUPPORTED_PINCTRL;
 -	vmcs_conf->cpu_based_2nd_exec_ctrl &= ~EVMCS1_UNSUPPORTED_2NDEXEC;
 +	unsigned int index = ROL16(field, 6);
 +	const struct evmcs_field *evmcs_field;
 +
 +	if (unlikely(index >= ARRAY_SIZE(vmcs_field_to_evmcs_1))) {
 +		WARN_ONCE(1, "KVM: accessing unsupported EVMCS field %lx\n",
 +			  field);
 +		return -ENOENT;
 +	}
  
 -	vmcs_conf->vmexit_ctrl &= ~EVMCS1_UNSUPPORTED_VMEXIT_CTRL;
 -	vmcs_conf->vmentry_ctrl &= ~EVMCS1_UNSUPPORTED_VMENTRY_CTRL;
 +	evmcs_field = &vmcs_field_to_evmcs_1[index];
  
 +	if (clean_field)
 +		*clean_field = evmcs_field->clean_field;
 +
 +	return evmcs_field->offset;
  }
 -#endif
  
++<<<<<<< HEAD:arch/x86/kvm/vmx/vmx_evmcs.h
 +#undef ROL16
 +
 +#endif /* __KVM_X86_VMX_EVMCS_H */
++=======
+ uint16_t nested_get_evmcs_version(struct kvm_vcpu *vcpu)
+ {
+        struct vcpu_vmx *vmx = to_vmx(vcpu);
+        /*
+         * vmcs_version represents the range of supported Enlightened VMCS
+         * versions: lower 8 bits is the minimal version, higher 8 bits is the
+         * maximum supported version. KVM supports versions from 1 to
+         * KVM_EVMCS_VERSION.
+         */
+        if (vmx->nested.enlightened_vmcs_enabled)
+                return (KVM_EVMCS_VERSION << 8) | 1;
+ 
+        return 0;
+ }
+ 
+ int nested_enable_evmcs(struct kvm_vcpu *vcpu,
+ 			uint16_t *vmcs_version)
+ {
+ 	struct vcpu_vmx *vmx = to_vmx(vcpu);
+ 
+ 	if (vmcs_version)
+ 		*vmcs_version = nested_get_evmcs_version(vcpu);
+ 
+ 	/* We don't support disabling the feature for simplicity. */
+ 	if (vmx->nested.enlightened_vmcs_enabled)
+ 		return 0;
+ 
+ 	vmx->nested.enlightened_vmcs_enabled = true;
+ 
+ 	vmx->nested.msrs.pinbased_ctls_high &= ~EVMCS1_UNSUPPORTED_PINCTRL;
+ 	vmx->nested.msrs.entry_ctls_high &= ~EVMCS1_UNSUPPORTED_VMENTRY_CTRL;
+ 	vmx->nested.msrs.exit_ctls_high &= ~EVMCS1_UNSUPPORTED_VMEXIT_CTRL;
+ 	vmx->nested.msrs.secondary_ctls_high &= ~EVMCS1_UNSUPPORTED_2NDEXEC;
+ 	vmx->nested.msrs.vmfunc_controls &= ~EVMCS1_UNSUPPORTED_VMFUNC;
+ 
+ 	return 0;
+ }
++>>>>>>> e2e871ab2f02 (x86/kvm/hyper-v: Introduce nested_get_evmcs_version() helper):arch/x86/kvm/vmx/evmcs.c
* Unmerged path arch/x86/kvm/vmx/evmcs.h
* Unmerged path arch/x86/kvm/vmx/nested.c
* Unmerged path arch/x86/include/asm/kvm_host.h
* Unmerged path arch/x86/kvm/svm.c
* Unmerged path arch/x86/kvm/vmx/evmcs.h
* Unmerged path arch/x86/kvm/vmx/nested.c
* Unmerged path arch/x86/kvm/vmx/vmx_evmcs.h
