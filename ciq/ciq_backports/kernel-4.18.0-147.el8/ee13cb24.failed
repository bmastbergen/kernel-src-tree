powerpc/64s: Add support for software count cache flush

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Michael Ellerman <mpe@ellerman.id.au>
commit ee13cb249fabdff8b90aaff61add347749280087
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/ee13cb24.failed

Some CPU revisions support a mode where the count cache needs to be
flushed by software on context switch. Additionally some revisions may
have a hardware accelerated flush, in which case the software flush
sequence can be shortened.

If we detect the appropriate flag from firmware we patch a branch
into _switch() which takes us to a count cache flush sequence.

That sequence in turn may be patched to return early if we detect that
the CPU supports accelerating the flush sequence in hardware.

Add debugfs support for reporting the state of the flush, as well as
runtime disabling it.

And modify the spectre_v2 sysfs file to report the state of the
software flush.

	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit ee13cb249fabdff8b90aaff61add347749280087)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/asm-prototypes.h
#	arch/powerpc/kernel/security.c
diff --cc arch/powerpc/include/asm/asm-prototypes.h
index cd131c37e5cd,70fdc5b9b9fb..000000000000
--- a/arch/powerpc/include/asm/asm-prototypes.h
+++ b/arch/powerpc/include/asm/asm-prototypes.h
@@@ -143,25 -143,10 +143,33 @@@ struct kvm_vcpu
  void _kvmppc_restore_tm_pr(struct kvm_vcpu *vcpu, u64 guest_msr);
  void _kvmppc_save_tm_pr(struct kvm_vcpu *vcpu, u64 guest_msr);
  
++<<<<<<< HEAD
 +#ifdef CONFIG_PPC_TRANSACTIONAL_MEM
 +void kvmppc_save_tm_hv(struct kvm_vcpu *vcpu, u64 msr, bool preserve_nv);
 +void kvmppc_restore_tm_hv(struct kvm_vcpu *vcpu, u64 msr, bool preserve_nv);
 +#else
 +static inline void kvmppc_save_tm_hv(struct kvm_vcpu *vcpu, u64 msr,
 +				     bool preserve_nv) { }
 +static inline void kvmppc_restore_tm_hv(struct kvm_vcpu *vcpu, u64 msr,
 +					bool preserve_nv) { }
 +#endif /* CONFIG_PPC_TRANSACTIONAL_MEM */
 +
 +void kvmhv_save_host_pmu(void);
 +void kvmhv_load_host_pmu(void);
 +void kvmhv_save_guest_pmu(struct kvm_vcpu *vcpu, bool pmu_in_use);
 +void kvmhv_load_guest_pmu(struct kvm_vcpu *vcpu);
 +
 +int __kvmhv_vcpu_entry_p9(struct kvm_vcpu *vcpu);
 +
 +long kvmppc_h_set_dabr(struct kvm_vcpu *vcpu, unsigned long dabr);
 +long kvmppc_h_set_xdabr(struct kvm_vcpu *vcpu, unsigned long dabr,
 +			unsigned long dabrx);
++=======
+ /* Patch sites */
+ extern s32 patch__call_flush_count_cache;
+ extern s32 patch__flush_count_cache_return;
+ 
+ extern long flush_count_cache;
++>>>>>>> ee13cb249fab (powerpc/64s: Add support for software count cache flush)
  
  #endif /* _ASM_POWERPC_ASM_PROTOTYPES_H */
diff --cc arch/powerpc/kernel/security.c
index 4cb8f1f7b593,f6f469fc4073..000000000000
--- a/arch/powerpc/kernel/security.c
+++ b/arch/powerpc/kernel/security.c
@@@ -15,7 -17,15 +17,14 @@@
  
  unsigned long powerpc_security_features __read_mostly = SEC_FTR_DEFAULT;
  
+ enum count_cache_flush_type {
+ 	COUNT_CACHE_FLUSH_NONE	= 0x1,
+ 	COUNT_CACHE_FLUSH_SW	= 0x2,
+ 	COUNT_CACHE_FLUSH_HW	= 0x4,
+ };
+ static enum count_cache_flush_type count_cache_flush_type;
+ 
  bool barrier_nospec_enabled;
 -static bool no_nospec;
  
  static void enable_barrier_nospec(bool enable)
  {
@@@ -313,3 -347,71 +334,74 @@@ static __init int stf_barrier_debugfs_i
  }
  device_initcall(stf_barrier_debugfs_init);
  #endif /* CONFIG_DEBUG_FS */
++<<<<<<< HEAD
++=======
+ 
+ static void toggle_count_cache_flush(bool enable)
+ {
+ 	if (!enable || !security_ftr_enabled(SEC_FTR_FLUSH_COUNT_CACHE)) {
+ 		patch_instruction_site(&patch__call_flush_count_cache, PPC_INST_NOP);
+ 		count_cache_flush_type = COUNT_CACHE_FLUSH_NONE;
+ 		pr_info("count-cache-flush: software flush disabled.\n");
+ 		return;
+ 	}
+ 
+ 	patch_branch_site(&patch__call_flush_count_cache,
+ 			  (u64)&flush_count_cache, BRANCH_SET_LINK);
+ 
+ 	if (!security_ftr_enabled(SEC_FTR_BCCTR_FLUSH_ASSIST)) {
+ 		count_cache_flush_type = COUNT_CACHE_FLUSH_SW;
+ 		pr_info("count-cache-flush: full software flush sequence enabled.\n");
+ 		return;
+ 	}
+ 
+ 	patch_instruction_site(&patch__flush_count_cache_return, PPC_INST_BLR);
+ 	count_cache_flush_type = COUNT_CACHE_FLUSH_HW;
+ 	pr_info("count-cache-flush: hardware assisted flush sequence enabled\n");
+ }
+ 
+ void setup_count_cache_flush(void)
+ {
+ 	toggle_count_cache_flush(true);
+ }
+ 
+ #ifdef CONFIG_DEBUG_FS
+ static int count_cache_flush_set(void *data, u64 val)
+ {
+ 	bool enable;
+ 
+ 	if (val == 1)
+ 		enable = true;
+ 	else if (val == 0)
+ 		enable = false;
+ 	else
+ 		return -EINVAL;
+ 
+ 	toggle_count_cache_flush(enable);
+ 
+ 	return 0;
+ }
+ 
+ static int count_cache_flush_get(void *data, u64 *val)
+ {
+ 	if (count_cache_flush_type == COUNT_CACHE_FLUSH_NONE)
+ 		*val = 0;
+ 	else
+ 		*val = 1;
+ 
+ 	return 0;
+ }
+ 
+ DEFINE_SIMPLE_ATTRIBUTE(fops_count_cache_flush, count_cache_flush_get,
+ 			count_cache_flush_set, "%llu\n");
+ 
+ static __init int count_cache_flush_debugfs_init(void)
+ {
+ 	debugfs_create_file("count_cache_flush", 0600, powerpc_debugfs_root,
+ 			    NULL, &fops_count_cache_flush);
+ 	return 0;
+ }
+ device_initcall(count_cache_flush_debugfs_init);
+ #endif /* CONFIG_DEBUG_FS */
+ #endif /* CONFIG_PPC_BOOK3S_64 */
++>>>>>>> ee13cb249fab (powerpc/64s: Add support for software count cache flush)
* Unmerged path arch/powerpc/include/asm/asm-prototypes.h
diff --git a/arch/powerpc/include/asm/security_features.h b/arch/powerpc/include/asm/security_features.h
index a0d47bc18a5c..759597bf0fd8 100644
--- a/arch/powerpc/include/asm/security_features.h
+++ b/arch/powerpc/include/asm/security_features.h
@@ -22,6 +22,7 @@ enum stf_barrier_type {
 
 void setup_stf_barrier(void);
 void do_stf_barrier_fixups(enum stf_barrier_type types);
+void setup_count_cache_flush(void);
 
 static inline void security_ftr_set(unsigned long feature)
 {
diff --git a/arch/powerpc/kernel/entry_64.S b/arch/powerpc/kernel/entry_64.S
index 55c3850bed29..111ee1118a3b 100644
--- a/arch/powerpc/kernel/entry_64.S
+++ b/arch/powerpc/kernel/entry_64.S
@@ -25,6 +25,7 @@
 #include <asm/page.h>
 #include <asm/mmu.h>
 #include <asm/thread_info.h>
+#include <asm/code-patching-asm.h>
 #include <asm/ppc_asm.h>
 #include <asm/asm-offsets.h>
 #include <asm/cputable.h>
@@ -504,6 +505,57 @@ _GLOBAL(ret_from_kernel_thread)
 	li	r3,0
 	b	.Lsyscall_exit
 
+#ifdef CONFIG_PPC_BOOK3S_64
+
+#define FLUSH_COUNT_CACHE	\
+1:	nop;			\
+	patch_site 1b, patch__call_flush_count_cache
+
+
+#define BCCTR_FLUSH	.long 0x4c400420
+
+.macro nops number
+	.rept \number
+	nop
+	.endr
+.endm
+
+.balign 32
+.global flush_count_cache
+flush_count_cache:
+	/* Save LR into r9 */
+	mflr	r9
+
+	.rept 64
+	bl	.+4
+	.endr
+	b	1f
+	nops	6
+
+	.balign 32
+	/* Restore LR */
+1:	mtlr	r9
+	li	r9,0x7fff
+	mtctr	r9
+
+	BCCTR_FLUSH
+
+2:	nop
+	patch_site 2b patch__flush_count_cache_return
+
+	nops	3
+
+	.rept 278
+	.balign 32
+	BCCTR_FLUSH
+	nops	7
+	.endr
+
+	blr
+#else
+#define FLUSH_COUNT_CACHE
+#endif /* CONFIG_PPC_BOOK3S_64 */
+
 /*
  * This routine switches between two different tasks.  The process
  * state of one is saved on its kernel stack.  Then the state
@@ -535,6 +587,8 @@ _GLOBAL(_switch)
 	std	r23,_CCR(r1)
 	std	r1,KSP(r3)	/* Set old stack pointer */
 
+	FLUSH_COUNT_CACHE
+
 	/*
 	 * On SMP kernels, care must be taken because a task may be
 	 * scheduled off CPUx and on to CPUy. Memory ordering must be
* Unmerged path arch/powerpc/kernel/security.c
