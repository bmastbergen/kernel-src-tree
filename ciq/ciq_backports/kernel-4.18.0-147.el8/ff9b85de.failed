net/mlx5e: Add some ethtool port control entries to the uplink rep netdev

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Or Gerlitz <ogerlitz@mellanox.com>
commit ff9b85de5d5d292fa07869f194fd9e3966f1e720
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/ff9b85de.failed

Some of the ethtool entries to control the port should be supported by
the uplink rep netdev in switchdev mode, add them.

While here, add also the get/set coalesce entries for all reps.

	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit ff9b85de5d5d292fa07869f194fd9e3966f1e720)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index 58cddf0a96a7,ed1158b58798..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -190,20 -216,187 +190,196 @@@ static int mlx5e_rep_get_sset_count(str
  	}
  }
  
++<<<<<<< HEAD
 +static const struct ethtool_ops mlx5e_rep_ethtool_ops = {
++=======
+ static void mlx5e_rep_get_ringparam(struct net_device *dev,
+ 				struct ethtool_ringparam *param)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(dev);
+ 
+ 	mlx5e_ethtool_get_ringparam(priv, param);
+ }
+ 
+ static int mlx5e_rep_set_ringparam(struct net_device *dev,
+ 			       struct ethtool_ringparam *param)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(dev);
+ 
+ 	return mlx5e_ethtool_set_ringparam(priv, param);
+ }
+ 
+ static int mlx5e_replace_rep_vport_rx_rule(struct mlx5e_priv *priv,
+ 					   struct mlx5_flow_destination *dest)
+ {
+ 	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
+ 	struct mlx5e_rep_priv *rpriv = priv->ppriv;
+ 	struct mlx5_eswitch_rep *rep = rpriv->rep;
+ 	struct mlx5_flow_handle *flow_rule;
+ 
+ 	flow_rule = mlx5_eswitch_create_vport_rx_rule(esw,
+ 						      rep->vport,
+ 						      dest);
+ 	if (IS_ERR(flow_rule))
+ 		return PTR_ERR(flow_rule);
+ 
+ 	mlx5_del_flow_rules(rpriv->vport_rx_rule);
+ 	rpriv->vport_rx_rule = flow_rule;
+ 	return 0;
+ }
+ 
+ static void mlx5e_rep_get_channels(struct net_device *dev,
+ 				   struct ethtool_channels *ch)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(dev);
+ 
+ 	mlx5e_ethtool_get_channels(priv, ch);
+ }
+ 
+ static int mlx5e_rep_set_channels(struct net_device *dev,
+ 				  struct ethtool_channels *ch)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(dev);
+ 	u16 curr_channels_amount = priv->channels.params.num_channels;
+ 	u32 new_channels_amount = ch->combined_count;
+ 	struct mlx5_flow_destination new_dest;
+ 	int err = 0;
+ 
+ 	err = mlx5e_ethtool_set_channels(priv, ch);
+ 	if (err)
+ 		return err;
+ 
+ 	if (curr_channels_amount == 1 && new_channels_amount > 1) {
+ 		new_dest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
+ 		new_dest.ft = priv->fs.ttc.ft.t;
+ 	} else if (new_channels_amount == 1 && curr_channels_amount > 1) {
+ 		new_dest.type = MLX5_FLOW_DESTINATION_TYPE_TIR;
+ 		new_dest.tir_num = priv->direct_tir[0].tirn;
+ 	} else {
+ 		return 0;
+ 	}
+ 
+ 	err = mlx5e_replace_rep_vport_rx_rule(priv, &new_dest);
+ 	if (err) {
+ 		netdev_warn(priv->netdev, "Failed to update vport rx rule, when going from (%d) channels to (%d) channels\n",
+ 			    curr_channels_amount, new_channels_amount);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int mlx5e_rep_get_coalesce(struct net_device *netdev,
+ 				  struct ethtool_coalesce *coal)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 
+ 	return mlx5e_ethtool_get_coalesce(priv, coal);
+ }
+ 
+ static int mlx5e_rep_set_coalesce(struct net_device *netdev,
+ 				  struct ethtool_coalesce *coal)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 
+ 	return mlx5e_ethtool_set_coalesce(priv, coal);
+ }
+ 
+ static u32 mlx5e_rep_get_rxfh_key_size(struct net_device *netdev)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 
+ 	return mlx5e_ethtool_get_rxfh_key_size(priv);
+ }
+ 
+ static u32 mlx5e_rep_get_rxfh_indir_size(struct net_device *netdev)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 
+ 	return mlx5e_ethtool_get_rxfh_indir_size(priv);
+ }
+ 
+ static void mlx5e_uplink_rep_get_pauseparam(struct net_device *netdev,
+ 					    struct ethtool_pauseparam *pauseparam)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 
+ 	mlx5e_ethtool_get_pauseparam(priv, pauseparam);
+ }
+ 
+ static int mlx5e_uplink_rep_set_pauseparam(struct net_device *netdev,
+ 					   struct ethtool_pauseparam *pauseparam)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 
+ 	return mlx5e_ethtool_set_pauseparam(priv, pauseparam);
+ }
+ 
+ static int mlx5e_uplink_rep_get_link_ksettings(struct net_device *netdev,
+ 					       struct ethtool_link_ksettings *link_ksettings)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 
+ 	return mlx5e_ethtool_get_link_ksettings(priv, link_ksettings);
+ }
+ 
+ static int mlx5e_uplink_rep_set_link_ksettings(struct net_device *netdev,
+ 					       const struct ethtool_link_ksettings *link_ksettings)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 
+ 	return mlx5e_ethtool_set_link_ksettings(priv, link_ksettings);
+ }
+ 
+ static const struct ethtool_ops mlx5e_vf_rep_ethtool_ops = {
++>>>>>>> ff9b85de5d5d (net/mlx5e: Add some ethtool port control entries to the uplink rep netdev)
  	.get_drvinfo	   = mlx5e_rep_get_drvinfo,
  	.get_link	   = ethtool_op_get_link,
  	.get_strings       = mlx5e_rep_get_strings,
  	.get_sset_count    = mlx5e_rep_get_sset_count,
  	.get_ethtool_stats = mlx5e_rep_get_ethtool_stats,
++<<<<<<< HEAD
 +};
 +
 +int mlx5e_attr_get(struct net_device *dev, struct switchdev_attr *attr)
++=======
+ 	.get_ringparam     = mlx5e_rep_get_ringparam,
+ 	.set_ringparam     = mlx5e_rep_set_ringparam,
+ 	.get_channels      = mlx5e_rep_get_channels,
+ 	.set_channels      = mlx5e_rep_set_channels,
+ 	.get_coalesce      = mlx5e_rep_get_coalesce,
+ 	.set_coalesce      = mlx5e_rep_set_coalesce,
+ 	.get_rxfh_key_size   = mlx5e_rep_get_rxfh_key_size,
+ 	.get_rxfh_indir_size = mlx5e_rep_get_rxfh_indir_size,
+ };
+ 
+ static const struct ethtool_ops mlx5e_uplink_rep_ethtool_ops = {
+ 	.get_drvinfo	   = mlx5e_rep_get_drvinfo,
+ 	.get_link	   = ethtool_op_get_link,
+ 	.get_strings       = mlx5e_rep_get_strings,
+ 	.get_sset_count    = mlx5e_rep_get_sset_count,
+ 	.get_ethtool_stats = mlx5e_rep_get_ethtool_stats,
+ 	.get_ringparam     = mlx5e_rep_get_ringparam,
+ 	.set_ringparam     = mlx5e_rep_set_ringparam,
+ 	.get_channels      = mlx5e_rep_get_channels,
+ 	.set_channels      = mlx5e_rep_set_channels,
+ 	.get_coalesce      = mlx5e_rep_get_coalesce,
+ 	.set_coalesce      = mlx5e_rep_set_coalesce,
+ 	.get_link_ksettings = mlx5e_uplink_rep_get_link_ksettings,
+ 	.set_link_ksettings = mlx5e_uplink_rep_set_link_ksettings,
+ 	.get_rxfh_key_size   = mlx5e_rep_get_rxfh_key_size,
+ 	.get_rxfh_indir_size = mlx5e_rep_get_rxfh_indir_size,
+ 	.get_pauseparam    = mlx5e_uplink_rep_get_pauseparam,
+ 	.set_pauseparam    = mlx5e_uplink_rep_set_pauseparam,
+ };
+ 
+ static int mlx5e_attr_get(struct net_device *dev, struct switchdev_attr *attr)
++>>>>>>> ff9b85de5d5d (net/mlx5e: Add some ethtool port control entries to the uplink rep netdev)
  {
  	struct mlx5e_priv *priv = netdev_priv(dev);
 +	struct mlx5e_rep_priv *rpriv = priv->ppriv;
 +	struct mlx5_eswitch_rep *rep = rpriv->rep;
  	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
 -	struct net_device *uplink_upper = NULL;
 -	struct mlx5e_priv *uplink_priv = NULL;
 -	struct net_device *uplink_dev;
  
  	if (esw->mode == SRIOV_NONE)
  		return -EOPNOTSUPP;
@@@ -1117,10 -1356,25 +1293,28 @@@ static void mlx5e_build_rep_params(stru
  static void mlx5e_build_rep_netdev(struct net_device *netdev)
  {
  	struct mlx5e_priv *priv = netdev_priv(netdev);
 -	struct mlx5e_rep_priv *rpriv = priv->ppriv;
 -	struct mlx5_eswitch_rep *rep = rpriv->rep;
  	struct mlx5_core_dev *mdev = priv->mdev;
 +	u16 max_mtu;
  
++<<<<<<< HEAD
 +	netdev->netdev_ops = &mlx5e_netdev_ops_rep;
++=======
+ 	if (rep->vport == FDB_UPLINK_VPORT) {
+ 		SET_NETDEV_DEV(netdev, &priv->mdev->pdev->dev);
+ 		netdev->netdev_ops = &mlx5e_netdev_ops_uplink_rep;
+ 		/* we want a persistent mac for the uplink rep */
+ 		mlx5_query_nic_vport_mac_address(mdev, 0, netdev->dev_addr);
+ 		netdev->ethtool_ops = &mlx5e_uplink_rep_ethtool_ops;
+ #ifdef CONFIG_MLX5_CORE_EN_DCB
+ 		if (MLX5_CAP_GEN(mdev, qos))
+ 			netdev->dcbnl_ops = &mlx5e_dcbnl_ops;
+ #endif
+ 	} else {
+ 		netdev->netdev_ops = &mlx5e_netdev_ops_vf_rep;
+ 		eth_hw_addr_random(netdev);
+ 		netdev->ethtool_ops = &mlx5e_vf_rep_ethtool_ops;
+ 	}
++>>>>>>> ff9b85de5d5d (net/mlx5e: Add some ethtool port control entries to the uplink rep netdev)
  
  	netdev->watchdog_timeo    = 15 * HZ;
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
