list: introduce list_bulk_move_tail helper

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Christian König <christian.koenig@amd.com>
commit df2fc43d09d3ee5ede82cab9299df5e78aa427b5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/df2fc43d.failed

Move all entries between @first and including @last before @head.

This is useful for LRU lists where a whole block of entries should be
moved to the end of the list.

Used as a band aid in TTM, but better placed in the common list headers.

	Acked-by: Dave Airlie <airlied@redhat.com>
	Signed-off-by: Christian König <christian.koenig@amd.com>
	Reviewed-by: Huang Rui <ray.huang@amd.com>
	Reviewed-by: Junwei Zhang <Jerry.Zhang@amd.com>
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit df2fc43d09d3ee5ede82cab9299df5e78aa427b5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/ttm/ttm_bo.c
diff --cc drivers/gpu/drm/ttm/ttm_bo.c
index 5d8688e522d1,26b889f86670..000000000000
--- a/drivers/gpu/drm/ttm/ttm_bo.c
+++ b/drivers/gpu/drm/ttm/ttm_bo.c
@@@ -223,6 -232,71 +223,59 @@@ void ttm_bo_move_to_lru_tail(struct ttm
  }
  EXPORT_SYMBOL(ttm_bo_move_to_lru_tail);
  
++<<<<<<< HEAD
++=======
+ void ttm_bo_bulk_move_lru_tail(struct ttm_lru_bulk_move *bulk)
+ {
+ 	unsigned i;
+ 
+ 	for (i = 0; i < TTM_MAX_BO_PRIORITY; ++i) {
+ 		struct ttm_lru_bulk_move_pos *pos = &bulk->tt[i];
+ 		struct ttm_mem_type_manager *man;
+ 
+ 		if (!pos->first)
+ 			continue;
+ 
+ 		reservation_object_assert_held(pos->first->resv);
+ 		reservation_object_assert_held(pos->last->resv);
+ 
+ 		man = &pos->first->bdev->man[TTM_PL_TT];
+ 		list_bulk_move_tail(&man->lru[i], &pos->first->lru,
+ 				    &pos->last->lru);
+ 	}
+ 
+ 	for (i = 0; i < TTM_MAX_BO_PRIORITY; ++i) {
+ 		struct ttm_lru_bulk_move_pos *pos = &bulk->vram[i];
+ 		struct ttm_mem_type_manager *man;
+ 
+ 		if (!pos->first)
+ 			continue;
+ 
+ 		reservation_object_assert_held(pos->first->resv);
+ 		reservation_object_assert_held(pos->last->resv);
+ 
+ 		man = &pos->first->bdev->man[TTM_PL_VRAM];
+ 		list_bulk_move_tail(&man->lru[i], &pos->first->lru,
+ 				    &pos->last->lru);
+ 	}
+ 
+ 	for (i = 0; i < TTM_MAX_BO_PRIORITY; ++i) {
+ 		struct ttm_lru_bulk_move_pos *pos = &bulk->swap[i];
+ 		struct list_head *lru;
+ 
+ 		if (!pos->first)
+ 			continue;
+ 
+ 		reservation_object_assert_held(pos->first->resv);
+ 		reservation_object_assert_held(pos->last->resv);
+ 
+ 		lru = &pos->first->bdev->glob->swap_lru[i];
+ 		list_bulk_move_tail(lru, &pos->first->swap, &pos->last->swap);
+ 	}
+ }
+ EXPORT_SYMBOL(ttm_bo_bulk_move_lru_tail);
+ 
++>>>>>>> df2fc43d09d3 (list: introduce list_bulk_move_tail helper)
  static int ttm_bo_handle_move_mem(struct ttm_buffer_object *bo,
  				  struct ttm_mem_reg *mem, bool evict,
  				  struct ttm_operation_ctx *ctx)
* Unmerged path drivers/gpu/drm/ttm/ttm_bo.c
diff --git a/include/linux/list.h b/include/linux/list.h
index 4b129df4d46b..d8d1caef7617 100644
--- a/include/linux/list.h
+++ b/include/linux/list.h
@@ -183,6 +183,29 @@ static inline void list_move_tail(struct list_head *list,
 	list_add_tail(list, head);
 }
 
+/**
+ * list_bulk_move_tail - move a subsection of a list to its tail
+ * @head: the head that will follow our entry
+ * @first: first entry to move
+ * @last: last entry to move, can be the same as first
+ *
+ * Move all entries between @first and including @last before @head.
+ * All three entries must belong to the same linked list.
+ */
+static inline void list_bulk_move_tail(struct list_head *head,
+				       struct list_head *first,
+				       struct list_head *last)
+{
+	first->prev->next = last->next;
+	last->next->prev = first->prev;
+
+	head->prev->next = first;
+	first->prev = head->prev;
+
+	last->next = head;
+	head->prev = last;
+}
+
 /**
  * list_is_last - tests whether @list is the last entry in list @head
  * @list: the entry to test
