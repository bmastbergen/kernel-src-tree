cls_api: add translator to flow_action representation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 3a7b68617de749d930b5503c3c5f30a17524f0bd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/3a7b6861.failed

This patch implements a new function to translate from native TC action
to the new flow_action representation. Moreover, this patch also updates
cls_flower to use this new function.

	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3a7b68617de749d930b5503c3c5f30a17524f0bd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/pkt_cls.h
#	net/sched/cls_api.c
#	net/sched/cls_flower.c
diff --cc include/net/pkt_cls.h
index 222c878d3994,c470c100b926..000000000000
--- a/include/net/pkt_cls.h
+++ b/include/net/pkt_cls.h
@@@ -633,8 -620,11 +633,16 @@@ tcf_match_indev(struct sk_buff *skb, in
  }
  #endif /* CONFIG_NET_CLS_IND */
  
++<<<<<<< HEAD
 +int tc_setup_cb_call(struct tcf_block *block, struct tcf_exts *exts,
 +		     enum tc_setup_type type, void *type_data, bool err_stop);
++=======
+ int tc_setup_flow_action(struct flow_action *flow_action,
+ 			 const struct tcf_exts *exts);
+ int tc_setup_cb_call(struct tcf_block *block, enum tc_setup_type type,
+ 		     void *type_data, bool err_stop);
+ unsigned int tcf_exts_num_actions(struct tcf_exts *exts);
++>>>>>>> 3a7b68617de7 (cls_api: add translator to flow_action representation)
  
  enum tc_block_command {
  	TC_BLOCK_BIND,
diff --cc net/sched/cls_api.c
index 7787b5e79877,02cf6d2fa0e1..000000000000
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@@ -31,6 -31,14 +31,17 @@@
  #include <net/netlink.h>
  #include <net/pkt_sched.h>
  #include <net/pkt_cls.h>
++<<<<<<< HEAD
++=======
+ #include <net/tc_act/tc_pedit.h>
+ #include <net/tc_act/tc_mirred.h>
+ #include <net/tc_act/tc_vlan.h>
+ #include <net/tc_act/tc_tunnel_key.h>
+ #include <net/tc_act/tc_csum.h>
+ #include <net/tc_act/tc_gact.h>
+ #include <net/tc_act/tc_skbedit.h>
+ #include <net/tc_act/tc_mirred.h>
++>>>>>>> 3a7b68617de7 (cls_api: add translator to flow_action representation)
  
  extern const struct nla_policy rtm_tca_policy[TCA_MAX + 1];
  
@@@ -2566,6 -2523,114 +2577,117 @@@ int tc_setup_cb_call(struct tcf_block *
  }
  EXPORT_SYMBOL(tc_setup_cb_call);
  
++<<<<<<< HEAD
++=======
+ int tc_setup_flow_action(struct flow_action *flow_action,
+ 			 const struct tcf_exts *exts)
+ {
+ 	const struct tc_action *act;
+ 	int i, j, k;
+ 
+ 	if (!exts)
+ 		return 0;
+ 
+ 	j = 0;
+ 	tcf_exts_for_each_action(i, act, exts) {
+ 		struct flow_action_entry *entry;
+ 
+ 		entry = &flow_action->entries[j];
+ 		if (is_tcf_gact_ok(act)) {
+ 			entry->id = FLOW_ACTION_ACCEPT;
+ 		} else if (is_tcf_gact_shot(act)) {
+ 			entry->id = FLOW_ACTION_DROP;
+ 		} else if (is_tcf_gact_trap(act)) {
+ 			entry->id = FLOW_ACTION_TRAP;
+ 		} else if (is_tcf_gact_goto_chain(act)) {
+ 			entry->id = FLOW_ACTION_GOTO;
+ 			entry->chain_index = tcf_gact_goto_chain_index(act);
+ 		} else if (is_tcf_mirred_egress_redirect(act)) {
+ 			entry->id = FLOW_ACTION_REDIRECT;
+ 			entry->dev = tcf_mirred_dev(act);
+ 		} else if (is_tcf_mirred_egress_mirror(act)) {
+ 			entry->id = FLOW_ACTION_MIRRED;
+ 			entry->dev = tcf_mirred_dev(act);
+ 		} else if (is_tcf_vlan(act)) {
+ 			switch (tcf_vlan_action(act)) {
+ 			case TCA_VLAN_ACT_PUSH:
+ 				entry->id = FLOW_ACTION_VLAN_PUSH;
+ 				entry->vlan.vid = tcf_vlan_push_vid(act);
+ 				entry->vlan.proto = tcf_vlan_push_proto(act);
+ 				entry->vlan.prio = tcf_vlan_push_prio(act);
+ 				break;
+ 			case TCA_VLAN_ACT_POP:
+ 				entry->id = FLOW_ACTION_VLAN_POP;
+ 				break;
+ 			case TCA_VLAN_ACT_MODIFY:
+ 				entry->id = FLOW_ACTION_VLAN_MANGLE;
+ 				entry->vlan.vid = tcf_vlan_push_vid(act);
+ 				entry->vlan.proto = tcf_vlan_push_proto(act);
+ 				entry->vlan.prio = tcf_vlan_push_prio(act);
+ 				break;
+ 			default:
+ 				goto err_out;
+ 			}
+ 		} else if (is_tcf_tunnel_set(act)) {
+ 			entry->id = FLOW_ACTION_TUNNEL_ENCAP;
+ 			entry->tunnel = tcf_tunnel_info(act);
+ 		} else if (is_tcf_tunnel_release(act)) {
+ 			entry->id = FLOW_ACTION_TUNNEL_DECAP;
+ 			entry->tunnel = tcf_tunnel_info(act);
+ 		} else if (is_tcf_pedit(act)) {
+ 			for (k = 0; k < tcf_pedit_nkeys(act); k++) {
+ 				switch (tcf_pedit_cmd(act, k)) {
+ 				case TCA_PEDIT_KEY_EX_CMD_SET:
+ 					entry->id = FLOW_ACTION_MANGLE;
+ 					break;
+ 				case TCA_PEDIT_KEY_EX_CMD_ADD:
+ 					entry->id = FLOW_ACTION_ADD;
+ 					break;
+ 				default:
+ 					goto err_out;
+ 				}
+ 				entry->mangle.htype = tcf_pedit_htype(act, k);
+ 				entry->mangle.mask = tcf_pedit_mask(act, k);
+ 				entry->mangle.val = tcf_pedit_val(act, k);
+ 				entry->mangle.offset = tcf_pedit_offset(act, k);
+ 				entry = &flow_action->entries[++j];
+ 			}
+ 		} else if (is_tcf_csum(act)) {
+ 			entry->id = FLOW_ACTION_CSUM;
+ 			entry->csum_flags = tcf_csum_update_flags(act);
+ 		} else if (is_tcf_skbedit_mark(act)) {
+ 			entry->id = FLOW_ACTION_MARK;
+ 			entry->mark = tcf_skbedit_mark(act);
+ 		} else {
+ 			goto err_out;
+ 		}
+ 
+ 		if (!is_tcf_pedit(act))
+ 			j++;
+ 	}
+ 	return 0;
+ err_out:
+ 	return -EOPNOTSUPP;
+ }
+ EXPORT_SYMBOL(tc_setup_flow_action);
+ 
+ unsigned int tcf_exts_num_actions(struct tcf_exts *exts)
+ {
+ 	unsigned int num_acts = 0;
+ 	struct tc_action *act;
+ 	int i;
+ 
+ 	tcf_exts_for_each_action(i, act, exts) {
+ 		if (is_tcf_pedit(act))
+ 			num_acts += tcf_pedit_nkeys(act);
+ 		else
+ 			num_acts++;
+ 	}
+ 	return num_acts;
+ }
+ EXPORT_SYMBOL(tcf_exts_num_actions);
+ 
++>>>>>>> 3a7b68617de7 (cls_api: add translator to flow_action representation)
  static __net_init int tcf_net_init(struct net *net)
  {
  	struct tcf_net *tn = net_generic(net, tcf_net_id);
diff --cc net/sched/cls_flower.c
index d984c61e0ed5,48c54ef52a98..000000000000
--- a/net/sched/cls_flower.c
+++ b/net/sched/cls_flower.c
@@@ -312,8 -394,15 +312,20 @@@ static int fl_hw_replace_filter(struct 
  	cls_flower.exts = &f->exts;
  	cls_flower.classid = f->res.classid;
  
++<<<<<<< HEAD
 +	err = tc_setup_cb_call(block, &f->exts, TC_SETUP_CLSFLOWER,
 +			       &cls_flower, skip_sw);
++=======
+ 	err = tc_setup_flow_action(&cls_flower.rule->action, &f->exts);
+ 	if (err) {
+ 		kfree(cls_flower.rule);
+ 		return err;
+ 	}
+ 
+ 	err = tc_setup_cb_call(block, TC_SETUP_CLSFLOWER, &cls_flower, skip_sw);
+ 	kfree(cls_flower.rule);
+ 
++>>>>>>> 3a7b68617de7 (cls_api: add translator to flow_action representation)
  	if (err < 0) {
  		fl_hw_destroy_filter(tp, f, NULL);
  		return err;
@@@ -1349,10 -1485,18 +1361,18 @@@ static int fl_reoffload(struct tcf_prot
  			cls_flower.command = add ?
  				TC_CLSFLOWER_REPLACE : TC_CLSFLOWER_DESTROY;
  			cls_flower.cookie = (unsigned long)f;
 -			cls_flower.rule->match.dissector = &mask->dissector;
 -			cls_flower.rule->match.mask = &mask->key;
 -			cls_flower.rule->match.key = &f->mkey;
 +			cls_flower.dissector = &mask->dissector;
 +			cls_flower.mask = &mask->key;
 +			cls_flower.key = &f->mkey;
  			cls_flower.exts = &f->exts;
+ 
+ 			err = tc_setup_flow_action(&cls_flower.rule->action,
+ 						   &f->exts);
+ 			if (err) {
+ 				kfree(cls_flower.rule);
+ 				return err;
+ 			}
+ 
  			cls_flower.classid = f->res.classid;
  
  			err = cb(TC_SETUP_CLSFLOWER, &cls_flower, cb_priv);
* Unmerged path include/net/pkt_cls.h
* Unmerged path net/sched/cls_api.c
* Unmerged path net/sched/cls_flower.c
