drm/i915/glk: Fix degamma lut programming

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Uma Shankar <uma.shankar@intel.com>
commit 8957129cb3b0144aceb46b8002cb5d1c45326b01
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/8957129c.failed

Fixed the glk degamma lut programming which currently
was hard coding a linear lut all the time, making degamma
block of glk basically a pass through.

Currently degamma lut for glk is assigned as 0 in platform
configuration. Updated the same to 33 as per the hardware
capability. IGT tests for degamma were getting skipped due to
this, spotted by Swati.

ToDo: The current gamma/degamm lut ABI has just 16bit for each
color component. This is not enough for GLK+, since input
precision is increased to 3.16 which will need 19bit entries.

v2: Added Matt's RB.

v3: Changed uint32_t to u32.

v4: Fixed Maarten's review comment

Credits-to: Swati Sharma <swati2.sharma@intel.com>
	Signed-off-by: Uma Shankar <uma.shankar@intel.com>
	Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
	Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
	Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/1549893025-21837-2-git-send-email-uma.shankar@intel.com
(cherry picked from commit 8957129cb3b0144aceb46b8002cb5d1c45326b01)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/i915_pci.c
#	drivers/gpu/drm/i915/intel_color.c
diff --cc drivers/gpu/drm/i915/i915_pci.c
index 39ce6b3b4ae7,3c3afbd737b2..000000000000
--- a/drivers/gpu/drm/i915/i915_pci.c
+++ b/drivers/gpu/drm/i915/i915_pci.c
@@@ -56,9 -68,15 +56,16 @@@
  #define BDW_COLORS \
  	.color = { .degamma_lut_size = 512, .gamma_lut_size = 512 }
  #define CHV_COLORS \
 -	.color = { .degamma_lut_size = 65, .gamma_lut_size = 257, \
 -		   .degamma_lut_tests = DRM_COLOR_LUT_NON_DECREASING, \
 -		   .gamma_lut_tests = DRM_COLOR_LUT_NON_DECREASING, \
 -	}
 +	.color = { .degamma_lut_size = 65, .gamma_lut_size = 257 }
  #define GLK_COLORS \
++<<<<<<< HEAD
 +	.color = { .degamma_lut_size = 0, .gamma_lut_size = 1024 }
++=======
+ 	.color = { .degamma_lut_size = 33, .gamma_lut_size = 1024, \
+ 		   .degamma_lut_tests = DRM_COLOR_LUT_NON_DECREASING | \
+ 					DRM_COLOR_LUT_EQUAL_CHANNELS, \
+ 	}
++>>>>>>> 8957129cb3b0 (drm/i915/glk: Fix degamma lut programming)
  
  /* Keep in gen based order, and chronological order within a gen */
  
diff --cc drivers/gpu/drm/i915/intel_color.c
index c6a7beabd58d,e39189928e10..000000000000
--- a/drivers/gpu/drm/i915/intel_color.c
+++ b/drivers/gpu/drm/i915/intel_color.c
@@@ -466,38 -498,27 +472,58 @@@ static void bdw_load_gamma_lut(struct d
  }
  
  /* Loads the palette/gamma unit for the CRTC on Broadwell+. */
 -static void broadwell_load_luts(const struct intel_crtc_state *crtc_state)
 +static void broadwell_load_luts(struct drm_crtc_state *state)
  {
++<<<<<<< HEAD
 +	struct drm_i915_private *dev_priv = to_i915(state->crtc->dev);
 +	struct intel_crtc_state *intel_state = to_intel_crtc_state(state);
 +	enum pipe pipe = to_intel_crtc(state->crtc)->pipe;
 +
 +	if (crtc_state_is_legacy_gamma(state)) {
 +		haswell_load_luts(state);
 +		return;
++=======
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->base.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 
+ 	if (crtc_state_is_legacy_gamma(crtc_state)) {
+ 		i9xx_load_luts(crtc_state);
+ 	} else {
+ 		bdw_load_degamma_lut(crtc_state);
+ 		bdw_load_gamma_lut(crtc_state,
+ 				   INTEL_INFO(dev_priv)->color.degamma_lut_size);
++>>>>>>> 8957129cb3b0 (drm/i915/glk: Fix degamma lut programming)
  	}
 +
 +	bdw_load_degamma_lut(state);
 +	bdw_load_gamma_lut(state,
 +			   INTEL_INFO(dev_priv)->color.degamma_lut_size);
 +
 +	intel_state->gamma_mode = GAMMA_MODE_MODE_SPLIT;
 +	I915_WRITE(GAMMA_MODE(pipe), GAMMA_MODE_MODE_SPLIT);
 +	POSTING_READ(GAMMA_MODE(pipe));
 +
 +	/*
 +	 * Reset the index, otherwise it prevents the legacy palette to be
 +	 * written properly.
 +	 */
 +	I915_WRITE(PREC_PAL_INDEX(pipe), 0);
  }
  
 -static void glk_load_degamma_lut(const struct intel_crtc_state *crtc_state)
 +static void glk_load_degamma_lut(struct drm_crtc_state *state)
  {
++<<<<<<< HEAD
 +	struct drm_i915_private *dev_priv = to_i915(state->crtc->dev);
 +	enum pipe pipe = to_intel_crtc(state->crtc)->pipe;
 +	const uint32_t lut_size = 33;
 +	uint32_t i;
++=======
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->base.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	enum pipe pipe = crtc->pipe;
+ 	const u32 lut_size = INTEL_INFO(dev_priv)->color.degamma_lut_size;
+ 	u32 i;
++>>>>>>> 8957129cb3b0 (drm/i915/glk: Fix degamma lut programming)
  
  	/*
  	 * When setting the auto-increment bit, the hardware seems to
@@@ -507,14 -528,32 +533,41 @@@
  	I915_WRITE(PRE_CSC_GAMC_INDEX(pipe), 0);
  	I915_WRITE(PRE_CSC_GAMC_INDEX(pipe), PRE_CSC_GAMC_AUTO_INCREMENT);
  
++<<<<<<< HEAD
 +	/*
 +	 *  FIXME: The pipe degamma table in geminilake doesn't support
 +	 *  different values per channel, so this just loads a linear table.
 +	 */
 +	for (i = 0; i < lut_size; i++) {
 +		uint32_t v = (i * (1 << 16)) / (lut_size - 1);
++=======
+ 	if (crtc_state->base.degamma_lut) {
+ 		struct drm_color_lut *lut = crtc_state->base.degamma_lut->data;
++>>>>>>> 8957129cb3b0 (drm/i915/glk: Fix degamma lut programming)
+ 
+ 		for (i = 0; i < lut_size; i++) {
+ 			/*
+ 			 * First 33 entries represent range from 0 to 1.0
+ 			 * 34th and 35th entry will represent extended range
+ 			 * inputs 3.0 and 7.0 respectively, currently clamped
+ 			 * at 1.0. Since the precision is 16bit, the user
+ 			 * value can be directly filled to register.
+ 			 * The pipe degamma table in GLK+ onwards doesn't
+ 			 * support different values per channel, so this just
+ 			 * programs green value which will be equal to Red and
+ 			 * Blue into the lut registers.
+ 			 * ToDo: Extend to max 7.0. Enable 32 bit input value
+ 			 * as compared to just 16 to achieve this.
+ 			 */
+ 			I915_WRITE(PRE_CSC_GAMC_DATA(pipe), lut[i].green);
+ 		}
+ 	} else {
+ 		/* load a linear table. */
+ 		for (i = 0; i < lut_size; i++) {
+ 			u32 v = (i * (1 << 16)) / (lut_size - 1);
  
- 		I915_WRITE(PRE_CSC_GAMC_DATA(pipe), v);
+ 			I915_WRITE(PRE_CSC_GAMC_DATA(pipe), v);
+ 		}
  	}
  
  	/* Clamp values > 1.0. */
@@@ -522,18 -561,28 +575,41 @@@
  		I915_WRITE(PRE_CSC_GAMC_DATA(pipe), (1 << 16));
  }
  
 -static void glk_load_luts(const struct intel_crtc_state *crtc_state)
 +static void glk_load_luts(struct drm_crtc_state *state)
  {
++<<<<<<< HEAD
 +	struct drm_crtc *crtc = state->crtc;
 +	struct drm_device *dev = crtc->dev;
 +	struct drm_i915_private *dev_priv = to_i915(dev);
 +	struct intel_crtc_state *intel_state = to_intel_crtc_state(state);
 +	enum pipe pipe = to_intel_crtc(crtc)->pipe;
 +
 +	glk_load_degamma_lut(state);
 +
 +	if (crtc_state_is_legacy_gamma(state)) {
 +		haswell_load_luts(state);
++=======
+ 	glk_load_degamma_lut(crtc_state);
+ 
+ 	if (crtc_state_is_legacy_gamma(crtc_state))
+ 		i9xx_load_luts(crtc_state);
+ 	else
+ 		bdw_load_gamma_lut(crtc_state, 0);
+ }
+ 
+ static void cherryview_load_luts(const struct intel_crtc_state *crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->base.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	const struct drm_property_blob *gamma_lut = crtc_state->base.gamma_lut;
+ 	const struct drm_property_blob *degamma_lut = crtc_state->base.degamma_lut;
+ 	enum pipe pipe = crtc->pipe;
+ 
+ 	cherryview_load_csc_matrix(crtc_state);
+ 
+ 	if (crtc_state_is_legacy_gamma(crtc_state)) {
+ 		i9xx_load_luts_internal(crtc_state, gamma_lut);
++>>>>>>> 8957129cb3b0 (drm/i915/glk: Fix degamma lut programming)
  		return;
  	}
  
* Unmerged path drivers/gpu/drm/i915/i915_pci.c
* Unmerged path drivers/gpu/drm/i915/intel_color.c
