tools: bpftool: add probes for a network device

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Quentin Monnet <quentin.monnet@netronome.com>
commit f9499fedf28547b496066b65de9180eaf3a7dc50
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/f9499fed.failed

bpftool gained support for probing the current system in order to see
what program and map types, and what helpers are available on that
system. This patch adds the possibility to pass an interface index to
libbpf (and hence to the kernel) when trying to load the programs or to
create the maps, in order to see what items a given network device can
support.

A new keyword "dev <ifname>" can be used as an alternative to "kernel"
to indicate that the given device should be tested. If no target ("dev"
or "kernel") is specified bpftool defaults to probing the kernel.

Sample output:

    # bpftool -p feature probe dev lo
    {
        "syscall_config": {
            "have_bpf_syscall": true
        },
        "program_types": {
            "have_sched_cls_prog_type": false,
            "have_xdp_prog_type": false
        },
        ...
    }

As the target is a network device, /proc/ parameters and kernel
configuration are NOT dumped. Availability of the bpf() syscall is
still probed, so we can return early if that syscall is not usable
(since there is no point in attempting the remaining probes in this
case).

Among the program types, only the ones that can be offloaded are probed.
All map types are probed, as there is no specific rule telling which one
could or could not be supported by a device in the future. All helpers
are probed (but only for offload-able program types).

Caveat: as bpftool does not attempt to attach programs to the device at
the moment, probes do not entirely reflect what the device accepts:
typically, for Netronome's nfp, results will announce that TC cls
offload is available even if support has been deactivated (with e.g.
ethtool -K eth1 hw-tc-offload off).

v2:
- All helpers are probed, whereas previous version would only probe the
  ones compatible with an offload-able program type. This is because we
  do not keep a default compatible program type for each helper anymore.

	Signed-off-by: Quentin Monnet <quentin.monnet@netronome.com>
	Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Stanislav Fomichev <sdf@google.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit f9499fedf28547b496066b65de9180eaf3a7dc50)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/bpf/bpftool/Documentation/bpftool-feature.rst
#	tools/bpf/bpftool/feature.c
diff --cc tools/bpf/bpftool/Documentation/bpftool-feature.rst
index 40ac13c0b782,8d489a26e3c9..000000000000
--- a/tools/bpf/bpftool/Documentation/bpftool-feature.rst
+++ b/tools/bpf/bpftool/Documentation/bpftool-feature.rst
@@@ -19,17 -19,42 +19,51 @@@ SYNOPSI
  MAP COMMANDS
  =============
  
++<<<<<<< HEAD
 +|	**bpftool** **feature probe** [**kernel**]
++=======
+ |	**bpftool** **feature probe** [*COMPONENT*] [**macros** [**prefix** *PREFIX*]]
++>>>>>>> f9499fedf285 (tools: bpftool: add probes for a network device)
  |	**bpftool** **feature help**
+ |
+ |	*COMPONENT* := { **kernel** | **dev** *NAME* }
  
  DESCRIPTION
  ===========
 -	**bpftool feature probe** [**kernel**] [**macros** [**prefix** *PREFIX*]]
 +	**bpftool feature probe** [**kernel**]
  		  Probe the running kernel and dump a number of eBPF-related
- 		  parameters, such as availability of the **bpf()** system call.
+ 		  parameters, such as availability of the **bpf()** system call,
+ 		  JIT status, eBPF program types availability, eBPF helper
+ 		  functions availability, and more.
  
++<<<<<<< HEAD
 +		  Keyword **kernel** can be omitted.
 +
++=======
+ 		  If the **macros** keyword (but not the **-j** option) is
+ 		  passed, a subset of the output is dumped as a list of
+ 		  **#define** macros that are ready to be included in a C
+ 		  header file, for example. If, additionally, **prefix** is
+ 		  used to define a *PREFIX*, the provided string will be used
+ 		  as a prefix to the names of the macros: this can be used to
+ 		  avoid conflicts on macro names when including the output of
+ 		  this command as a header file.
+ 
+ 		  Keyword **kernel** can be omitted. If no probe target is
+ 		  specified, probing the kernel is the default behaviour.
+ 
+ 		  Note that when probed, some eBPF helpers (e.g.
+ 		  **bpf_trace_printk**\ () or **bpf_probe_write_user**\ ()) may
+ 		  print warnings to kernel logs.
+ 
+ 	**bpftool feature probe dev** *NAME* [**macros** [**prefix** *PREFIX*]]
+ 		  Probe network device for supported eBPF features and dump
+ 		  results to the console.
+ 
+ 		  The two keywords **macros** and **prefix** have the same
+ 		  role as when probing the kernel.
+ 
++>>>>>>> f9499fedf285 (tools: bpftool: add probes for a network device)
  	**bpftool feature help**
  		  Print short help message.
  
diff --cc tools/bpf/bpftool/feature.c
index 4a2867439ab7,993c6f1e5473..000000000000
--- a/tools/bpf/bpftool/feature.c
+++ b/tools/bpf/bpftool/feature.c
@@@ -21,8 -24,16 +22,9 @@@
  enum probe_component {
  	COMPONENT_UNSPEC,
  	COMPONENT_KERNEL,
+ 	COMPONENT_DEVICE,
  };
  
 -#define BPF_HELPER_MAKE_ENTRY(name)	[BPF_FUNC_ ## name] = "bpf_" # name
 -static const char * const helper_name[] = {
 -	__BPF_FUNC_MAPPER(BPF_HELPER_MAKE_ENTRY)
 -};
 -
 -#undef BPF_HELPER_MAKE_ENTRY
 -
  /* Miscellaneous utility functions */
  
  static bool check_procfs(void)
@@@ -403,9 -456,129 +405,135 @@@ static bool probe_bpf_syscall(void
  	return res;
  }
  
++<<<<<<< HEAD
 +static int do_probe(int argc, char **argv)
 +{
 +	enum probe_component target = COMPONENT_UNSPEC;
++=======
+ static void
+ probe_prog_type(enum bpf_prog_type prog_type, bool *supported_types,
+ 		const char *define_prefix, __u32 ifindex)
+ {
+ 	char feat_name[128], plain_desc[128], define_name[128];
+ 	const char *plain_comment = "eBPF program_type ";
+ 	size_t maxlen;
+ 	bool res;
+ 
+ 	if (ifindex)
+ 		/* Only test offload-able program types */
+ 		switch (prog_type) {
+ 		case BPF_PROG_TYPE_SCHED_CLS:
+ 		case BPF_PROG_TYPE_XDP:
+ 			break;
+ 		default:
+ 			return;
+ 		}
+ 
+ 	res = bpf_probe_prog_type(prog_type, ifindex);
+ 
+ 	supported_types[prog_type] |= res;
+ 
+ 	maxlen = sizeof(plain_desc) - strlen(plain_comment) - 1;
+ 	if (strlen(prog_type_name[prog_type]) > maxlen) {
+ 		p_info("program type name too long");
+ 		return;
+ 	}
+ 
+ 	sprintf(feat_name, "have_%s_prog_type", prog_type_name[prog_type]);
+ 	sprintf(define_name, "%s_prog_type", prog_type_name[prog_type]);
+ 	uppercase(define_name, sizeof(define_name));
+ 	sprintf(plain_desc, "%s%s", plain_comment, prog_type_name[prog_type]);
+ 	print_bool_feature(feat_name, plain_desc, define_name, res,
+ 			   define_prefix);
+ }
+ 
+ static void
+ probe_map_type(enum bpf_map_type map_type, const char *define_prefix,
+ 	       __u32 ifindex)
+ {
+ 	char feat_name[128], plain_desc[128], define_name[128];
+ 	const char *plain_comment = "eBPF map_type ";
+ 	size_t maxlen;
+ 	bool res;
+ 
+ 	res = bpf_probe_map_type(map_type, ifindex);
+ 
+ 	maxlen = sizeof(plain_desc) - strlen(plain_comment) - 1;
+ 	if (strlen(map_type_name[map_type]) > maxlen) {
+ 		p_info("map type name too long");
+ 		return;
+ 	}
+ 
+ 	sprintf(feat_name, "have_%s_map_type", map_type_name[map_type]);
+ 	sprintf(define_name, "%s_map_type", map_type_name[map_type]);
+ 	uppercase(define_name, sizeof(define_name));
+ 	sprintf(plain_desc, "%s%s", plain_comment, map_type_name[map_type]);
+ 	print_bool_feature(feat_name, plain_desc, define_name, res,
+ 			   define_prefix);
+ }
+ 
+ static void
+ probe_helpers_for_progtype(enum bpf_prog_type prog_type, bool supported_type,
+ 			   const char *define_prefix, __u32 ifindex)
+ {
+ 	const char *ptype_name = prog_type_name[prog_type];
+ 	char feat_name[128];
+ 	unsigned int id;
+ 	bool res;
+ 
+ 	if (ifindex)
+ 		/* Only test helpers for offload-able program types */
+ 		switch (prog_type) {
+ 		case BPF_PROG_TYPE_SCHED_CLS:
+ 		case BPF_PROG_TYPE_XDP:
+ 			break;
+ 		default:
+ 			return;
+ 		}
+ 
+ 	if (json_output) {
+ 		sprintf(feat_name, "%s_available_helpers", ptype_name);
+ 		jsonw_name(json_wtr, feat_name);
+ 		jsonw_start_array(json_wtr);
+ 	} else if (!define_prefix) {
+ 		printf("eBPF helpers supported for program type %s:",
+ 		       ptype_name);
+ 	}
+ 
+ 	for (id = 1; id < ARRAY_SIZE(helper_name); id++) {
+ 		if (!supported_type)
+ 			res = false;
+ 		else
+ 			res = bpf_probe_helper(id, prog_type, ifindex);
+ 
+ 		if (json_output) {
+ 			if (res)
+ 				jsonw_string(json_wtr, helper_name[id]);
+ 		} else if (define_prefix) {
+ 			printf("#define %sBPF__PROG_TYPE_%s__HELPER_%s %s\n",
+ 			       define_prefix, ptype_name, helper_name[id],
+ 			       res ? "1" : "0");
+ 		} else {
+ 			if (res)
+ 				printf("\n\t- %s", helper_name[id]);
+ 		}
+ 	}
+ 
+ 	if (json_output)
+ 		jsonw_end_array(json_wtr);
+ 	else if (!define_prefix)
+ 		printf("\n");
+ }
+ 
+ static int do_probe(int argc, char **argv)
+ {
+ 	enum probe_component target = COMPONENT_UNSPEC;
+ 	const char *define_prefix = NULL;
+ 	bool supported_types[128] = {};
+ 	__u32 ifindex = 0;
+ 	unsigned int i;
+ 	char *ifname;
++>>>>>>> f9499fedf285 (tools: bpftool: add probes for a network device)
  
  	/* Detection assumes user has sufficient privileges (CAP_SYS_ADMIN).
  	 * Let's approximate, and restrict usage to root user only.
@@@ -425,8 -598,43 +553,48 @@@
  			}
  			target = COMPONENT_KERNEL;
  			NEXT_ARG();
++<<<<<<< HEAD
 +		} else {
 +			p_err("expected no more arguments, 'kernel', got: '%s'?",
++=======
+ 		} else if (is_prefix(*argv, "dev")) {
+ 			NEXT_ARG();
+ 
+ 			if (target != COMPONENT_UNSPEC || ifindex) {
+ 				p_err("component to probe already specified");
+ 				return -1;
+ 			}
+ 			if (!REQ_ARGS(1))
+ 				return -1;
+ 
+ 			target = COMPONENT_DEVICE;
+ 			ifname = GET_ARG();
+ 			ifindex = if_nametoindex(ifname);
+ 			if (!ifindex) {
+ 				p_err("unrecognized netdevice '%s': %s", ifname,
+ 				      strerror(errno));
+ 				return -1;
+ 			}
+ 		} else if (is_prefix(*argv, "macros") && !define_prefix) {
+ 			define_prefix = "";
+ 			NEXT_ARG();
+ 		} else if (is_prefix(*argv, "prefix")) {
+ 			if (!define_prefix) {
+ 				p_err("'prefix' argument can only be use after 'macros'");
+ 				return -1;
+ 			}
+ 			if (strcmp(define_prefix, "")) {
+ 				p_err("'prefix' already defined");
+ 				return -1;
+ 			}
+ 			NEXT_ARG();
+ 
+ 			if (!REQ_ARGS(1))
+ 				return -1;
+ 			define_prefix = GET_ARG();
+ 		} else {
+ 			p_err("expected no more arguments, 'kernel', 'dev', 'macros' or 'prefix', got: '%s'?",
++>>>>>>> f9499fedf285 (tools: bpftool: add probes for a network device)
  			      *argv);
  			return -1;
  		}
@@@ -458,10 -675,55 +628,54 @@@
  	}
  
  	print_start_section("syscall_config",
 -			    "Scanning system call availability...",
 -			    "/*** System call availability ***/",
 -			    define_prefix);
 +			    "Scanning system call availability...");
  
 -	if (!probe_bpf_syscall(define_prefix))
 -		/* bpf() syscall unavailable, don't probe other BPF features */
 -		goto exit_close_json;
 +	probe_bpf_syscall();
  
++<<<<<<< HEAD
++=======
+ 	print_end_then_start_section("program_types",
+ 				     "Scanning eBPF program types...",
+ 				     "/*** eBPF program types ***/",
+ 				     define_prefix);
+ 
+ 	for (i = BPF_PROG_TYPE_UNSPEC + 1; i < ARRAY_SIZE(prog_type_name); i++)
+ 		probe_prog_type(i, supported_types, define_prefix, ifindex);
+ 
+ 	print_end_then_start_section("map_types",
+ 				     "Scanning eBPF map types...",
+ 				     "/*** eBPF map types ***/",
+ 				     define_prefix);
+ 
+ 	for (i = BPF_MAP_TYPE_UNSPEC + 1; i < map_type_name_size; i++)
+ 		probe_map_type(i, define_prefix, ifindex);
+ 
+ 	print_end_then_start_section("helpers",
+ 				     "Scanning eBPF helper functions...",
+ 				     "/*** eBPF helper functions ***/",
+ 				     define_prefix);
+ 
+ 	if (define_prefix)
+ 		printf("/*\n"
+ 		       " * Use %sHAVE_PROG_TYPE_HELPER(prog_type_name, helper_name)\n"
+ 		       " * to determine if <helper_name> is available for <prog_type_name>,\n"
+ 		       " * e.g.\n"
+ 		       " *	#if %sHAVE_PROG_TYPE_HELPER(xdp, bpf_redirect)\n"
+ 		       " *		// do stuff with this helper\n"
+ 		       " *	#elif\n"
+ 		       " *		// use a workaround\n"
+ 		       " *	#endif\n"
+ 		       " */\n"
+ 		       "#define %sHAVE_PROG_TYPE_HELPER(prog_type, helper)	\\\n"
+ 		       "	%sBPF__PROG_TYPE_ ## prog_type ## __HELPER_ ## helper\n",
+ 		       define_prefix, define_prefix, define_prefix,
+ 		       define_prefix);
+ 	for (i = BPF_PROG_TYPE_UNSPEC + 1; i < ARRAY_SIZE(prog_type_name); i++)
+ 		probe_helpers_for_progtype(i, supported_types[i],
+ 					   define_prefix, ifindex);
+ 
+ exit_close_json:
++>>>>>>> f9499fedf285 (tools: bpftool: add probes for a network device)
  	if (json_output) {
  		/* End current "section" of probes */
  		jsonw_end_object(json_wtr);
@@@ -480,8 -742,10 +694,14 @@@ static int do_help(int argc, char **arg
  	}
  
  	fprintf(stderr,
++<<<<<<< HEAD
 +		"Usage: %s %s probe [kernel]\n"
++=======
+ 		"Usage: %s %s probe [COMPONENT] [macros [prefix PREFIX]]\n"
++>>>>>>> f9499fedf285 (tools: bpftool: add probes for a network device)
  		"       %s %s help\n"
+ 		"\n"
+ 		"       COMPONENT := { kernel | dev NAME }\n"
  		"",
  		bin_name, argv[-2], bin_name, argv[-2]);
  
* Unmerged path tools/bpf/bpftool/Documentation/bpftool-feature.rst
* Unmerged path tools/bpf/bpftool/feature.c
