IB/mlx5: Introduce driver create and destroy flow methods

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Yishai Hadas <yishaih@mellanox.com>
commit 32269441240064c7475241ae28fee787fcdf55b9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/32269441.failed

Introduce driver create and destroy flow methods on the uverbs flow
object.

This allows the driver to get its specific device attributes to match the
underlay specification while still using the generic ib_flow object for
cleanup and code sharing.

The IB object's attributes are set via the ib_set_flow() helper function.

The specific implementation for the given specification is added in
downstream patches.

	Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 32269441240064c7475241ae28fee787fcdf55b9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/devx.c
#	drivers/infiniband/hw/mlx5/flow.c
#	drivers/infiniband/hw/mlx5/mlx5_ib.h
#	include/rdma/uverbs_named_ioctl.h
diff --cc drivers/infiniband/hw/mlx5/devx.c
index 7b7903c26e2e,270452c9e673..000000000000
--- a/drivers/infiniband/hw/mlx5/devx.c
+++ b/drivers/infiniband/hw/mlx5/devx.c
@@@ -71,6 -87,183 +71,186 @@@ void mlx5_ib_devx_destroy(struct mlx5_i
  	mlx5_cmd_exec(dev->mdev, in, sizeof(in), out, sizeof(out));
  }
  
++<<<<<<< HEAD
++=======
+ bool mlx5_ib_devx_is_flow_dest(void *obj, int *dest_id, int *dest_type)
+ {
+ 	struct devx_obj *devx_obj = obj;
+ 	u16 opcode = MLX5_GET(general_obj_in_cmd_hdr, devx_obj->dinbox, opcode);
+ 
+ 	switch (opcode) {
+ 	case MLX5_CMD_OP_DESTROY_TIR:
+ 		*dest_type = MLX5_FLOW_DESTINATION_TYPE_TIR;
+ 		*dest_id = MLX5_GET(general_obj_in_cmd_hdr, devx_obj->dinbox,
+ 				    obj_id);
+ 		return true;
+ 
+ 	case MLX5_CMD_OP_DESTROY_FLOW_TABLE:
+ 		*dest_type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
+ 		*dest_id = MLX5_GET(destroy_flow_table_in, devx_obj->dinbox,
+ 				    table_id);
+ 		return true;
+ 	default:
+ 		return false;
+ 	}
+ }
+ 
+ static int devx_is_valid_obj_id(struct devx_obj *obj, const void *in)
+ {
+ 	u16 opcode = MLX5_GET(general_obj_in_cmd_hdr, in, opcode);
+ 	u32 obj_id;
+ 
+ 	switch (opcode) {
+ 	case MLX5_CMD_OP_MODIFY_GENERAL_OBJECT:
+ 	case MLX5_CMD_OP_QUERY_GENERAL_OBJECT:
+ 		obj_id = MLX5_GET(general_obj_in_cmd_hdr, in, obj_id);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_MKEY:
+ 		obj_id = MLX5_GET(query_mkey_in, in, mkey_index);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_CQ:
+ 		obj_id = MLX5_GET(query_cq_in, in, cqn);
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_CQ:
+ 		obj_id = MLX5_GET(modify_cq_in, in, cqn);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_SQ:
+ 		obj_id = MLX5_GET(query_sq_in, in, sqn);
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_SQ:
+ 		obj_id = MLX5_GET(modify_sq_in, in, sqn);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_RQ:
+ 		obj_id = MLX5_GET(query_rq_in, in, rqn);
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_RQ:
+ 		obj_id = MLX5_GET(modify_rq_in, in, rqn);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_RMP:
+ 		obj_id = MLX5_GET(query_rmp_in, in, rmpn);
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_RMP:
+ 		obj_id = MLX5_GET(modify_rmp_in, in, rmpn);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_RQT:
+ 		obj_id = MLX5_GET(query_rqt_in, in, rqtn);
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_RQT:
+ 		obj_id = MLX5_GET(modify_rqt_in, in, rqtn);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_TIR:
+ 		obj_id = MLX5_GET(query_tir_in, in, tirn);
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_TIR:
+ 		obj_id = MLX5_GET(modify_tir_in, in, tirn);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_TIS:
+ 		obj_id = MLX5_GET(query_tis_in, in, tisn);
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_TIS:
+ 		obj_id = MLX5_GET(modify_tis_in, in, tisn);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_FLOW_TABLE:
+ 		obj_id = MLX5_GET(query_flow_table_in, in, table_id);
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_FLOW_TABLE:
+ 		obj_id = MLX5_GET(modify_flow_table_in, in, table_id);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_FLOW_GROUP:
+ 		obj_id = MLX5_GET(query_flow_group_in, in, group_id);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_FLOW_TABLE_ENTRY:
+ 		obj_id = MLX5_GET(query_fte_in, in, flow_index);
+ 		break;
+ 	case MLX5_CMD_OP_SET_FLOW_TABLE_ENTRY:
+ 		obj_id = MLX5_GET(set_fte_in, in, flow_index);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_Q_COUNTER:
+ 		obj_id = MLX5_GET(query_q_counter_in, in, counter_set_id);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_FLOW_COUNTER:
+ 		obj_id = MLX5_GET(query_flow_counter_in, in, flow_counter_id);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_MODIFY_HEADER_CONTEXT:
+ 		obj_id = MLX5_GET(general_obj_in_cmd_hdr, in, obj_id);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_SCHEDULING_ELEMENT:
+ 		obj_id = MLX5_GET(query_scheduling_element_in, in,
+ 				  scheduling_element_id);
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_SCHEDULING_ELEMENT:
+ 		obj_id = MLX5_GET(modify_scheduling_element_in, in,
+ 				  scheduling_element_id);
+ 		break;
+ 	case MLX5_CMD_OP_ADD_VXLAN_UDP_DPORT:
+ 		obj_id = MLX5_GET(add_vxlan_udp_dport_in, in, vxlan_udp_port);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_L2_TABLE_ENTRY:
+ 		obj_id = MLX5_GET(query_l2_table_entry_in, in, table_index);
+ 		break;
+ 	case MLX5_CMD_OP_SET_L2_TABLE_ENTRY:
+ 		obj_id = MLX5_GET(set_l2_table_entry_in, in, table_index);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_QP:
+ 		obj_id = MLX5_GET(query_qp_in, in, qpn);
+ 		break;
+ 	case MLX5_CMD_OP_RST2INIT_QP:
+ 		obj_id = MLX5_GET(rst2init_qp_in, in, qpn);
+ 		break;
+ 	case MLX5_CMD_OP_INIT2RTR_QP:
+ 		obj_id = MLX5_GET(init2rtr_qp_in, in, qpn);
+ 		break;
+ 	case MLX5_CMD_OP_RTR2RTS_QP:
+ 		obj_id = MLX5_GET(rtr2rts_qp_in, in, qpn);
+ 		break;
+ 	case MLX5_CMD_OP_RTS2RTS_QP:
+ 		obj_id = MLX5_GET(rts2rts_qp_in, in, qpn);
+ 		break;
+ 	case MLX5_CMD_OP_SQERR2RTS_QP:
+ 		obj_id = MLX5_GET(sqerr2rts_qp_in, in, qpn);
+ 		break;
+ 	case MLX5_CMD_OP_2ERR_QP:
+ 		obj_id = MLX5_GET(qp_2err_in, in, qpn);
+ 		break;
+ 	case MLX5_CMD_OP_2RST_QP:
+ 		obj_id = MLX5_GET(qp_2rst_in, in, qpn);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_DCT:
+ 		obj_id = MLX5_GET(query_dct_in, in, dctn);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_XRQ:
+ 		obj_id = MLX5_GET(query_xrq_in, in, xrqn);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_XRC_SRQ:
+ 		obj_id = MLX5_GET(query_xrc_srq_in, in, xrc_srqn);
+ 		break;
+ 	case MLX5_CMD_OP_ARM_XRC_SRQ:
+ 		obj_id = MLX5_GET(arm_xrc_srq_in, in, xrc_srqn);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_SRQ:
+ 		obj_id = MLX5_GET(query_srq_in, in, srqn);
+ 		break;
+ 	case MLX5_CMD_OP_ARM_RQ:
+ 		obj_id = MLX5_GET(arm_rq_in, in, srq_number);
+ 		break;
+ 	case MLX5_CMD_OP_DRAIN_DCT:
+ 	case MLX5_CMD_OP_ARM_DCT_FOR_KEY_VIOLATION:
+ 		obj_id = MLX5_GET(drain_dct_in, in, dctn);
+ 		break;
+ 	case MLX5_CMD_OP_ARM_XRQ:
+ 		obj_id = MLX5_GET(arm_xrq_in, in, xrqn);
+ 		break;
+ 	default:
+ 		return false;
+ 	}
+ 
+ 	if (obj_id == obj->obj_id)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
++>>>>>>> 322694412400 (IB/mlx5: Introduce driver create and destroy flow methods)
  static bool devx_is_obj_create_cmd(const void *in)
  {
  	u16 opcode = MLX5_GET(general_obj_in_cmd_hdr, in, opcode);
diff --cc drivers/infiniband/hw/mlx5/mlx5_ib.h
index dc133aa987e9,324f4ea5fce6..000000000000
--- a/drivers/infiniband/hw/mlx5/mlx5_ib.h
+++ b/drivers/infiniband/hw/mlx5/mlx5_ib.h
@@@ -1216,12 -1229,30 +1216,36 @@@ int mlx5_ib_devx_create(struct mlx5_ib_
  			struct mlx5_ib_ucontext *context);
  void mlx5_ib_devx_destroy(struct mlx5_ib_dev *dev,
  			  struct mlx5_ib_ucontext *context);
++<<<<<<< HEAD
++=======
+ const struct uverbs_object_tree_def *mlx5_ib_get_devx_tree(void);
+ struct mlx5_ib_flow_handler *mlx5_ib_raw_fs_rule_add(
+ 	struct mlx5_ib_dev *dev, struct mlx5_ib_flow_matcher *fs_matcher,
+ 	void *cmd_in, int inlen, int dest_id, int dest_type);
+ bool mlx5_ib_devx_is_flow_dest(void *obj, int *dest_id, int *dest_type);
++>>>>>>> 322694412400 (IB/mlx5: Introduce driver create and destroy flow methods)
  #else
  static inline int
  mlx5_ib_devx_create(struct mlx5_ib_dev *dev,
  		    struct mlx5_ib_ucontext *context) { return -EOPNOTSUPP; };
  static inline void mlx5_ib_devx_destroy(struct mlx5_ib_dev *dev,
  					struct mlx5_ib_ucontext *context) {}
++<<<<<<< HEAD
++=======
+ static inline const struct uverbs_object_tree_def *
+ mlx5_ib_get_devx_tree(void) { return NULL; }
+ static inline struct mlx5_ib_flow_handler *mlx5_ib_raw_fs_rule_add(
+ 	struct mlx5_ib_dev *dev, struct mlx5_ib_flow_matcher *fs_matcher,
+ 	void *cmd_in, int inlen, int dest_id, int dest_type)
+ {
+ 	return ERR_PTR(-EOPNOTSUPP);
+ }
+ static inline bool mlx5_ib_devx_is_flow_dest(void *obj, int *dest_id,
+ 					     int *dest_type)
+ {
+ 	return false;
+ }
++>>>>>>> 322694412400 (IB/mlx5: Introduce driver create and destroy flow methods)
  #endif
  static inline void init_query_mad(struct ib_smp *mad)
  {
diff --cc include/rdma/uverbs_named_ioctl.h
index 94863ed7644d,b3b21733cc55..000000000000
--- a/include/rdma/uverbs_named_ioctl.h
+++ b/include/rdma/uverbs_named_ioctl.h
@@@ -43,52 -43,89 +43,94 @@@
  #define _UVERBS_NAME(x, y)	_UVERBS_PASTE(x, y)
  #define UVERBS_METHOD(id)	_UVERBS_NAME(UVERBS_MODULE_NAME, _method_##id)
  #define UVERBS_HANDLER(id)	_UVERBS_NAME(UVERBS_MODULE_NAME, _handler_##id)
 -#define UVERBS_OBJECT(id)	_UVERBS_NAME(UVERBS_MOUDLE_NAME, _object_##id)
 +#define UVERBS_OBJECT(id)	_UVERBS_NAME(UVERBS_MODULE_NAME, _object_##id)
  
 -/* These are static so they do not need to be qualified */
 -#define UVERBS_METHOD_ATTRS(method_id) _method_attrs_##method_id
 -#define UVERBS_OBJECT_METHODS(object_id) _object_methods_##object_id
 +#define DECLARE_UVERBS_NAMED_METHOD(id, ...)	\
 +	DECLARE_UVERBS_METHOD(UVERBS_METHOD(id), id, UVERBS_HANDLER(id), ##__VA_ARGS__)
  
 -#define DECLARE_UVERBS_NAMED_METHOD(_method_id, ...)                           \
 -	static const struct uverbs_attr_def *const UVERBS_METHOD_ATTRS(        \
 -		_method_id)[] = { __VA_ARGS__ };                               \
 -	static const struct uverbs_method_def UVERBS_METHOD(_method_id) = {    \
 -		.id = _method_id,                                              \
 -		.handler = UVERBS_HANDLER(_method_id),                         \
 -		.num_attrs = ARRAY_SIZE(UVERBS_METHOD_ATTRS(_method_id)),      \
 -		.attrs = &UVERBS_METHOD_ATTRS(_method_id),                     \
 -	}
 +#define DECLARE_UVERBS_NAMED_METHOD_WITH_HANDLER(id, handler, ...)	\
 +	DECLARE_UVERBS_METHOD(UVERBS_METHOD(id), id, handler, ##__VA_ARGS__)
  
 -/* Create a standard destroy method using the default handler. The handle_attr
 - * argument must be the attribute specifying the handle to destroy, the
 - * default handler does not support any other attributes.
 - */
 -#define DECLARE_UVERBS_NAMED_METHOD_DESTROY(_method_id, _handle_attr)          \
 -	static const struct uverbs_attr_def *const UVERBS_METHOD_ATTRS(        \
 -		_method_id)[] = { _handle_attr };                              \
 -	static const struct uverbs_method_def UVERBS_METHOD(_method_id) = {    \
 -		.id = _method_id,                                              \
 -		.handler = uverbs_destroy_def_handler,                         \
 -		.num_attrs = ARRAY_SIZE(UVERBS_METHOD_ATTRS(_method_id)),      \
 -		.attrs = &UVERBS_METHOD_ATTRS(_method_id),                     \
 -	}
 +#define DECLARE_UVERBS_NAMED_METHOD_NO_OVERRIDE(id, handler, ...)	\
 +	DECLARE_UVERBS_METHOD(UVERBS_METHOD(id), id, NULL, ##__VA_ARGS__)
  
 -#define DECLARE_UVERBS_NAMED_OBJECT(_object_id, _type_attrs, ...)              \
 -	static const struct uverbs_method_def *const UVERBS_OBJECT_METHODS(    \
 -		_object_id)[] = { __VA_ARGS__ };                               \
 -	const struct uverbs_object_def UVERBS_OBJECT(_object_id) = {           \
 -		.id = _object_id,                                              \
 -		.type_attrs = &_type_attrs,                                    \
 -		.num_methods = ARRAY_SIZE(UVERBS_OBJECT_METHODS(_object_id)),  \
 -		.methods = &UVERBS_OBJECT_METHODS(_object_id)                  \
 -	}
 +#define DECLARE_UVERBS_NAMED_OBJECT(id, ...)	\
 +	DECLARE_UVERBS_OBJECT(UVERBS_OBJECT(id), id, ##__VA_ARGS__)
  
 -/*
 - * Declare global methods. These still have a unique object_id because we
 - * identify all uapi methods with a (object,method) tuple. However, they have
 - * no type pointer.
 +#define DECLARE_UVERBS_GLOBAL_METHODS(_name, ...)	\
 +	DECLARE_UVERBS_NAMED_OBJECT(_name, NULL, ##__VA_ARGS__)
 +
 +#define _UVERBS_COMP_NAME(x, y, z) _UVERBS_NAME(_UVERBS_NAME(x, y), z)
 +
 +#define UVERBS_NO_OVERRIDE	NULL
 +
 +/* This declares a parsing tree with one object and one method. This is usually
 + * used for merging driver attributes to the common attributes. The driver has
 + * a chance to override the handler and type attrs of the original object.
 + * The __VA_ARGS__ just contains a list of attributes.
 + */
 +#define ADD_UVERBS_ATTRIBUTES(_name, _object, _method, _type_attrs, _handler, ...) \
 +static DECLARE_UVERBS_METHOD(_UVERBS_COMP_NAME(UVERBS_MODULE_NAME,	     \
 +					       _method_, _name),	     \
 +			     _method, _handler, ##__VA_ARGS__);		     \
 +									     \
 +static DECLARE_UVERBS_OBJECT(_UVERBS_COMP_NAME(UVERBS_MODULE_NAME,	     \
 +					       _object_, _name),	     \
 +			     _object, _type_attrs,			     \
 +			     &_UVERBS_COMP_NAME(UVERBS_MODULE_NAME,	     \
 +					       _method_, _name));	     \
 +									     \
 +static DECLARE_UVERBS_OBJECT_TREE(_name,				     \
 +				  &_UVERBS_COMP_NAME(UVERBS_MODULE_NAME,     \
 +						     _object_, _name))
 +
 +/* A very common use case is that the driver doesn't override the handler and
 + * type_attrs. Therefore, we provide a simplified macro for this common case.
   */
++<<<<<<< HEAD
 +#define ADD_UVERBS_ATTRIBUTES_SIMPLE(_name, _object, _method, ...)	     \
 +	ADD_UVERBS_ATTRIBUTES(_name, _object, _method, UVERBS_NO_OVERRIDE,   \
 +			      UVERBS_NO_OVERRIDE, ##__VA_ARGS__)
++=======
+ #define DECLARE_UVERBS_GLOBAL_METHODS(_object_id, ...)	\
+ 	static const struct uverbs_method_def *const UVERBS_OBJECT_METHODS(    \
+ 		_object_id)[] = { __VA_ARGS__ };                               \
+ 	const struct uverbs_object_def UVERBS_OBJECT(_object_id) = {           \
+ 		.id = _object_id,                                              \
+ 		.num_methods = ARRAY_SIZE(UVERBS_OBJECT_METHODS(_object_id)),  \
+ 		.methods = &UVERBS_OBJECT_METHODS(_object_id)                  \
+ 	}
+ 
+ /* Used by drivers to declare a complete parsing tree for new methods
+  */
+ #define ADD_UVERBS_METHODS(_name, _object_id, ...)                             \
+ 	static const struct uverbs_method_def *const UVERBS_OBJECT_METHODS(    \
+ 		_object_id)[] = { __VA_ARGS__ };                               \
+ 	static const struct uverbs_object_def _name##_struct = {               \
+ 		.id = _object_id,                                              \
+ 		.num_methods = ARRAY_SIZE(UVERBS_OBJECT_METHODS(_object_id)),  \
+ 		.methods = &UVERBS_OBJECT_METHODS(_object_id)                  \
+ 	};                                                                     \
+ 	static const struct uverbs_object_def *const _name##_ptrs[] = {        \
+ 		&_name##_struct,                                               \
+ 	};                                                                     \
+ 	static const struct uverbs_object_tree_def _name = {                   \
+ 		.num_objects = 1,                                              \
+ 		.objects = &_name##_ptrs,                                      \
+ 	}
+ 
+ /* Used by drivers to declare a complete parsing tree for a single method that
+  * differs only in having additional driver specific attributes.
+  */
+ #define ADD_UVERBS_ATTRIBUTES_SIMPLE(_name, _object_id, _method_id, ...)       \
+ 	static const struct uverbs_attr_def *const UVERBS_METHOD_ATTRS(        \
+ 		_method_id)[] = { __VA_ARGS__ };                               \
+ 	static const struct uverbs_method_def UVERBS_METHOD(_method_id) = {    \
+ 		.id = _method_id,                                              \
+ 		.num_attrs = ARRAY_SIZE(UVERBS_METHOD_ATTRS(_method_id)),      \
+ 		.attrs = &UVERBS_METHOD_ATTRS(_method_id),                     \
+ 	};                                                                     \
+ 	ADD_UVERBS_METHODS(_name, _object_id, &UVERBS_METHOD(_method_id))
++>>>>>>> 322694412400 (IB/mlx5: Introduce driver create and destroy flow methods)
  
  #endif
* Unmerged path drivers/infiniband/hw/mlx5/flow.c
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
* Unmerged path drivers/infiniband/hw/mlx5/flow.c
diff --git a/drivers/infiniband/hw/mlx5/main.c b/drivers/infiniband/hw/mlx5/main.c
index 6d899fc16add..690ba564c254 100644
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@ -3640,6 +3640,15 @@ static struct ib_flow *mlx5_ib_create_flow(struct ib_qp *qp,
 	return ERR_PTR(err);
 }
 
+struct mlx5_ib_flow_handler *
+mlx5_ib_raw_fs_rule_add(struct mlx5_ib_dev *dev,
+			struct mlx5_ib_flow_matcher *fs_matcher,
+			void *cmd_in, int inlen, int dest_id,
+			int dest_type)
+{
+	return ERR_PTR(-EOPNOTSUPP);
+}
+
 static u32 mlx5_ib_flow_action_flags_to_accel_xfrm_flags(u32 mlx5_flags)
 {
 	u32 flags = 0;
* Unmerged path drivers/infiniband/hw/mlx5/mlx5_ib.h
diff --git a/include/rdma/ib_verbs.h b/include/rdma/ib_verbs.h
index 7d63f1ad4c1e..558439adf019 100644
--- a/include/rdma/ib_verbs.h
+++ b/include/rdma/ib_verbs.h
@@ -4418,6 +4418,20 @@ ib_get_vector_affinity(struct ib_device *device, int comp_vector)
 
 }
 
+static inline void ib_set_flow(struct ib_uobject *uobj, struct ib_flow *ibflow,
+			       struct ib_qp *qp, struct ib_device *device)
+{
+	uobj->object = ibflow;
+	ibflow->uobject = uobj;
+
+	if (qp) {
+		atomic_inc(&qp->usecnt);
+		ibflow->qp = qp;
+	}
+
+	ibflow->device = device;
+}
+
 /**
  * rdma_roce_rescan_device - Rescan all of the network devices in the system
  * and add their gids, as needed, to the relevant RoCE devices.
* Unmerged path include/rdma/uverbs_named_ioctl.h
diff --git a/include/uapi/rdma/mlx5_user_ioctl_cmds.h b/include/uapi/rdma/mlx5_user_ioctl_cmds.h
index 8d285f4555cd..24f8e6f89006 100644
--- a/include/uapi/rdma/mlx5_user_ioctl_cmds.h
+++ b/include/uapi/rdma/mlx5_user_ioctl_cmds.h
@@ -74,4 +74,21 @@ enum mlx5_ib_devx_objects {
 	MLX5_IB_OBJECT_DEVX_OBJ,
 };
 
+enum mlx5_ib_create_flow_attrs {
+	MLX5_IB_ATTR_CREATE_FLOW_HANDLE = (1U << UVERBS_ID_NS_SHIFT),
+	MLX5_IB_ATTR_CREATE_FLOW_MATCH_VALUE,
+	MLX5_IB_ATTR_CREATE_FLOW_DEST_QP,
+	MLX5_IB_ATTR_CREATE_FLOW_DEST_DEVX,
+	MLX5_IB_ATTR_CREATE_FLOW_MATCHER,
+};
+
+enum mlx5_ib_destoy_flow_attrs {
+	MLX5_IB_ATTR_DESTROY_FLOW_HANDLE = (1U << UVERBS_ID_NS_SHIFT),
+};
+
+enum mlx5_ib_flow_methods {
+	MLX5_IB_METHOD_CREATE_FLOW = (1U << UVERBS_ID_NS_SHIFT),
+	MLX5_IB_METHOD_DESTROY_FLOW,
+};
+
 #endif
