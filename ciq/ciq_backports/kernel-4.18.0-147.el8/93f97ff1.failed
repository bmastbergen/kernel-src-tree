ASoC: wcd9335: add audio routings

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [sound] ALSA: ASoC: wcd9335: add audio routings (Jaroslav Kysela) [1683051]
Rebuild_FUZZ: 91.67%
commit-author Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
commit 93f97ff1911a34e2a4662f16b6266b2c309f918b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/93f97ff1.failed

This patch adds audio routing for both playback and capture.

	Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
	Reviewed-by: Vinod Koul <vkoul@kernel.org>
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 93f97ff1911a34e2a4662f16b6266b2c309f918b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/codecs/wcd9335.c
diff --cc sound/soc/codecs/wcd9335.c
index 06c73699f16f,3878187bb512..000000000000
--- a/sound/soc/codecs/wcd9335.c
+++ b/sound/soc/codecs/wcd9335.c
@@@ -670,6 -2175,1806 +731,1809 @@@ static struct snd_soc_dai_driver wcd933
  	},
  };
  
++<<<<<<< HEAD
++=======
+ static int wcd9335_get_compander(struct snd_kcontrol *kc,
+ 			       struct snd_ctl_elem_value *ucontrol)
+ {
+ 
+ 	struct snd_soc_component *component = snd_soc_kcontrol_component(kc);
+ 	int comp = ((struct soc_mixer_control *)kc->private_value)->shift;
+ 	struct wcd9335_codec *wcd = dev_get_drvdata(component->dev);
+ 
+ 	ucontrol->value.integer.value[0] = wcd->comp_enabled[comp];
+ 	return 0;
+ }
+ 
+ static int wcd9335_set_compander(struct snd_kcontrol *kc,
+ 				 struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct snd_soc_component *component = snd_soc_kcontrol_component(kc);
+ 	struct wcd9335_codec *wcd = dev_get_drvdata(component->dev);
+ 	int comp = ((struct soc_mixer_control *) kc->private_value)->shift;
+ 	int value = ucontrol->value.integer.value[0];
+ 	int sel;
+ 
+ 	wcd->comp_enabled[comp] = value;
+ 	sel = value ? WCD9335_HPH_GAIN_SRC_SEL_COMPANDER :
+ 		WCD9335_HPH_GAIN_SRC_SEL_REGISTER;
+ 
+ 	/* Any specific register configuration for compander */
+ 	switch (comp) {
+ 	case COMPANDER_1:
+ 		/* Set Gain Source Select based on compander enable/disable */
+ 		snd_soc_component_update_bits(component, WCD9335_HPH_L_EN,
+ 				      WCD9335_HPH_GAIN_SRC_SEL_MASK, sel);
+ 		break;
+ 	case COMPANDER_2:
+ 		snd_soc_component_update_bits(component, WCD9335_HPH_R_EN,
+ 				      WCD9335_HPH_GAIN_SRC_SEL_MASK, sel);
+ 		break;
+ 	case COMPANDER_5:
+ 		snd_soc_component_update_bits(component, WCD9335_SE_LO_LO3_GAIN,
+ 				      WCD9335_HPH_GAIN_SRC_SEL_MASK, sel);
+ 		break;
+ 	case COMPANDER_6:
+ 		snd_soc_component_update_bits(component, WCD9335_SE_LO_LO4_GAIN,
+ 				      WCD9335_HPH_GAIN_SRC_SEL_MASK, sel);
+ 		break;
+ 	default:
+ 		break;
+ 	};
+ 
+ 	return 0;
+ }
+ 
+ static int wcd9335_rx_hph_mode_get(struct snd_kcontrol *kc,
+ 				 struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct snd_soc_component *component = snd_soc_kcontrol_component(kc);
+ 	struct wcd9335_codec *wcd = dev_get_drvdata(component->dev);
+ 
+ 	ucontrol->value.enumerated.item[0] = wcd->hph_mode;
+ 
+ 	return 0;
+ }
+ 
+ static int wcd9335_rx_hph_mode_put(struct snd_kcontrol *kc,
+ 				 struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct snd_soc_component *component = snd_soc_kcontrol_component(kc);
+ 	struct wcd9335_codec *wcd = dev_get_drvdata(component->dev);
+ 	u32 mode_val;
+ 
+ 	mode_val = ucontrol->value.enumerated.item[0];
+ 
+ 	if (mode_val == 0) {
+ 		dev_err(wcd->dev, "Invalid HPH Mode, default to ClSH HiFi\n");
+ 		mode_val = CLS_H_HIFI;
+ 	}
+ 	wcd->hph_mode = mode_val;
+ 
+ 	return 0;
+ }
+ 
+ static const struct snd_kcontrol_new wcd9335_snd_controls[] = {
+ 	/* -84dB min - 40dB max */
+ 	SOC_SINGLE_SX_TLV("RX0 Digital Volume", WCD9335_CDC_RX0_RX_VOL_CTL,
+ 		0, -84, 40, digital_gain),
+ 	SOC_SINGLE_SX_TLV("RX1 Digital Volume", WCD9335_CDC_RX1_RX_VOL_CTL,
+ 		0, -84, 40, digital_gain),
+ 	SOC_SINGLE_SX_TLV("RX2 Digital Volume", WCD9335_CDC_RX2_RX_VOL_CTL,
+ 		0, -84, 40, digital_gain),
+ 	SOC_SINGLE_SX_TLV("RX3 Digital Volume", WCD9335_CDC_RX3_RX_VOL_CTL,
+ 		0, -84, 40, digital_gain),
+ 	SOC_SINGLE_SX_TLV("RX4 Digital Volume", WCD9335_CDC_RX4_RX_VOL_CTL,
+ 		0, -84, 40, digital_gain),
+ 	SOC_SINGLE_SX_TLV("RX5 Digital Volume", WCD9335_CDC_RX5_RX_VOL_CTL,
+ 		0, -84, 40, digital_gain),
+ 	SOC_SINGLE_SX_TLV("RX6 Digital Volume", WCD9335_CDC_RX6_RX_VOL_CTL,
+ 		0, -84, 40, digital_gain),
+ 	SOC_SINGLE_SX_TLV("RX7 Digital Volume", WCD9335_CDC_RX7_RX_VOL_CTL,
+ 		0, -84, 40, digital_gain),
+ 	SOC_SINGLE_SX_TLV("RX8 Digital Volume", WCD9335_CDC_RX8_RX_VOL_CTL,
+ 		0, -84, 40, digital_gain),
+ 	SOC_SINGLE_SX_TLV("RX0 Mix Digital Volume",
+ 			  WCD9335_CDC_RX0_RX_VOL_MIX_CTL,
+ 			  0, -84, 40, digital_gain),
+ 	SOC_SINGLE_SX_TLV("RX1 Mix Digital Volume",
+ 			  WCD9335_CDC_RX1_RX_VOL_MIX_CTL,
+ 			  0, -84, 40, digital_gain),
+ 	SOC_SINGLE_SX_TLV("RX2 Mix Digital Volume",
+ 			  WCD9335_CDC_RX2_RX_VOL_MIX_CTL,
+ 			  0, -84, 40, digital_gain),
+ 	SOC_SINGLE_SX_TLV("RX3 Mix Digital Volume",
+ 			  WCD9335_CDC_RX3_RX_VOL_MIX_CTL,
+ 			  0, -84, 40, digital_gain),
+ 	SOC_SINGLE_SX_TLV("RX4 Mix Digital Volume",
+ 			  WCD9335_CDC_RX4_RX_VOL_MIX_CTL,
+ 			  0, -84, 40, digital_gain),
+ 	SOC_SINGLE_SX_TLV("RX5 Mix Digital Volume",
+ 			  WCD9335_CDC_RX5_RX_VOL_MIX_CTL,
+ 			  0, -84, 40, digital_gain),
+ 	SOC_SINGLE_SX_TLV("RX6 Mix Digital Volume",
+ 			  WCD9335_CDC_RX6_RX_VOL_MIX_CTL,
+ 			  0, -84, 40, digital_gain),
+ 	SOC_SINGLE_SX_TLV("RX7 Mix Digital Volume",
+ 			  WCD9335_CDC_RX7_RX_VOL_MIX_CTL,
+ 			  0, -84, 40, digital_gain),
+ 	SOC_SINGLE_SX_TLV("RX8 Mix Digital Volume",
+ 			  WCD9335_CDC_RX8_RX_VOL_MIX_CTL,
+ 			  0, -84, 40, digital_gain),
+ 	SOC_ENUM("RX INT0_1 HPF cut off", cf_int0_1_enum),
+ 	SOC_ENUM("RX INT0_2 HPF cut off", cf_int0_2_enum),
+ 	SOC_ENUM("RX INT1_1 HPF cut off", cf_int1_1_enum),
+ 	SOC_ENUM("RX INT1_2 HPF cut off", cf_int1_2_enum),
+ 	SOC_ENUM("RX INT2_1 HPF cut off", cf_int2_1_enum),
+ 	SOC_ENUM("RX INT2_2 HPF cut off", cf_int2_2_enum),
+ 	SOC_ENUM("RX INT3_1 HPF cut off", cf_int3_1_enum),
+ 	SOC_ENUM("RX INT3_2 HPF cut off", cf_int3_2_enum),
+ 	SOC_ENUM("RX INT4_1 HPF cut off", cf_int4_1_enum),
+ 	SOC_ENUM("RX INT4_2 HPF cut off", cf_int4_2_enum),
+ 	SOC_ENUM("RX INT5_1 HPF cut off", cf_int5_1_enum),
+ 	SOC_ENUM("RX INT5_2 HPF cut off", cf_int5_2_enum),
+ 	SOC_ENUM("RX INT6_1 HPF cut off", cf_int6_1_enum),
+ 	SOC_ENUM("RX INT6_2 HPF cut off", cf_int6_2_enum),
+ 	SOC_ENUM("RX INT7_1 HPF cut off", cf_int7_1_enum),
+ 	SOC_ENUM("RX INT7_2 HPF cut off", cf_int7_2_enum),
+ 	SOC_ENUM("RX INT8_1 HPF cut off", cf_int8_1_enum),
+ 	SOC_ENUM("RX INT8_2 HPF cut off", cf_int8_2_enum),
+ 	SOC_SINGLE_EXT("COMP1 Switch", SND_SOC_NOPM, COMPANDER_1, 1, 0,
+ 		       wcd9335_get_compander, wcd9335_set_compander),
+ 	SOC_SINGLE_EXT("COMP2 Switch", SND_SOC_NOPM, COMPANDER_2, 1, 0,
+ 		       wcd9335_get_compander, wcd9335_set_compander),
+ 	SOC_SINGLE_EXT("COMP3 Switch", SND_SOC_NOPM, COMPANDER_3, 1, 0,
+ 		       wcd9335_get_compander, wcd9335_set_compander),
+ 	SOC_SINGLE_EXT("COMP4 Switch", SND_SOC_NOPM, COMPANDER_4, 1, 0,
+ 		       wcd9335_get_compander, wcd9335_set_compander),
+ 	SOC_SINGLE_EXT("COMP5 Switch", SND_SOC_NOPM, COMPANDER_5, 1, 0,
+ 		       wcd9335_get_compander, wcd9335_set_compander),
+ 	SOC_SINGLE_EXT("COMP6 Switch", SND_SOC_NOPM, COMPANDER_6, 1, 0,
+ 		       wcd9335_get_compander, wcd9335_set_compander),
+ 	SOC_SINGLE_EXT("COMP7 Switch", SND_SOC_NOPM, COMPANDER_7, 1, 0,
+ 		       wcd9335_get_compander, wcd9335_set_compander),
+ 	SOC_SINGLE_EXT("COMP8 Switch", SND_SOC_NOPM, COMPANDER_8, 1, 0,
+ 		       wcd9335_get_compander, wcd9335_set_compander),
+ 	SOC_ENUM_EXT("RX HPH Mode", rx_hph_mode_mux_enum,
+ 		       wcd9335_rx_hph_mode_get, wcd9335_rx_hph_mode_put),
+ 
+ 	/* Gain Controls */
+ 	SOC_SINGLE_TLV("EAR PA Volume", WCD9335_ANA_EAR, 4, 4, 1,
+ 		ear_pa_gain),
+ 	SOC_SINGLE_TLV("HPHL Volume", WCD9335_HPH_L_EN, 0, 20, 1,
+ 		line_gain),
+ 	SOC_SINGLE_TLV("HPHR Volume", WCD9335_HPH_R_EN, 0, 20, 1,
+ 		line_gain),
+ 	SOC_SINGLE_TLV("LINEOUT1 Volume", WCD9335_DIFF_LO_LO1_COMPANDER,
+ 			3, 16, 1, line_gain),
+ 	SOC_SINGLE_TLV("LINEOUT2 Volume", WCD9335_DIFF_LO_LO2_COMPANDER,
+ 			3, 16, 1, line_gain),
+ 	SOC_SINGLE_TLV("LINEOUT3 Volume", WCD9335_SE_LO_LO3_GAIN, 0, 20, 1,
+ 			line_gain),
+ 	SOC_SINGLE_TLV("LINEOUT4 Volume", WCD9335_SE_LO_LO4_GAIN, 0, 20, 1,
+ 			line_gain),
+ 
+ 	SOC_SINGLE_TLV("ADC1 Volume", WCD9335_ANA_AMIC1, 0, 20, 0,
+ 			analog_gain),
+ 	SOC_SINGLE_TLV("ADC2 Volume", WCD9335_ANA_AMIC2, 0, 20, 0,
+ 			analog_gain),
+ 	SOC_SINGLE_TLV("ADC3 Volume", WCD9335_ANA_AMIC3, 0, 20, 0,
+ 			analog_gain),
+ 	SOC_SINGLE_TLV("ADC4 Volume", WCD9335_ANA_AMIC4, 0, 20, 0,
+ 			analog_gain),
+ 	SOC_SINGLE_TLV("ADC5 Volume", WCD9335_ANA_AMIC5, 0, 20, 0,
+ 			analog_gain),
+ 	SOC_SINGLE_TLV("ADC6 Volume", WCD9335_ANA_AMIC6, 0, 20, 0,
+ 			analog_gain),
+ 
+ 	SOC_ENUM("TX0 HPF cut off", cf_dec0_enum),
+ 	SOC_ENUM("TX1 HPF cut off", cf_dec1_enum),
+ 	SOC_ENUM("TX2 HPF cut off", cf_dec2_enum),
+ 	SOC_ENUM("TX3 HPF cut off", cf_dec3_enum),
+ 	SOC_ENUM("TX4 HPF cut off", cf_dec4_enum),
+ 	SOC_ENUM("TX5 HPF cut off", cf_dec5_enum),
+ 	SOC_ENUM("TX6 HPF cut off", cf_dec6_enum),
+ 	SOC_ENUM("TX7 HPF cut off", cf_dec7_enum),
+ 	SOC_ENUM("TX8 HPF cut off", cf_dec8_enum),
+ };
+ 
+ static const struct snd_soc_dapm_route wcd9335_audio_map[] = {
+ 	{"SLIM RX0 MUX", "AIF1_PB", "AIF1 PB"},
+ 	{"SLIM RX1 MUX", "AIF1_PB", "AIF1 PB"},
+ 	{"SLIM RX2 MUX", "AIF1_PB", "AIF1 PB"},
+ 	{"SLIM RX3 MUX", "AIF1_PB", "AIF1 PB"},
+ 	{"SLIM RX4 MUX", "AIF1_PB", "AIF1 PB"},
+ 	{"SLIM RX5 MUX", "AIF1_PB", "AIF1 PB"},
+ 	{"SLIM RX6 MUX", "AIF1_PB", "AIF1 PB"},
+ 	{"SLIM RX7 MUX", "AIF1_PB", "AIF1 PB"},
+ 
+ 	{"SLIM RX0 MUX", "AIF2_PB", "AIF2 PB"},
+ 	{"SLIM RX1 MUX", "AIF2_PB", "AIF2 PB"},
+ 	{"SLIM RX2 MUX", "AIF2_PB", "AIF2 PB"},
+ 	{"SLIM RX3 MUX", "AIF2_PB", "AIF2 PB"},
+ 	{"SLIM RX4 MUX", "AIF2_PB", "AIF2 PB"},
+ 	{"SLIM RX5 MUX", "AIF2_PB", "AIF2 PB"},
+ 	{"SLIM RX6 MUX", "AIF2_PB", "AIF2 PB"},
+ 	{"SLIM RX7 MUX", "AIF2_PB", "AIF2 PB"},
+ 
+ 	{"SLIM RX0 MUX", "AIF3_PB", "AIF3 PB"},
+ 	{"SLIM RX1 MUX", "AIF3_PB", "AIF3 PB"},
+ 	{"SLIM RX2 MUX", "AIF3_PB", "AIF3 PB"},
+ 	{"SLIM RX3 MUX", "AIF3_PB", "AIF3 PB"},
+ 	{"SLIM RX4 MUX", "AIF3_PB", "AIF3 PB"},
+ 	{"SLIM RX5 MUX", "AIF3_PB", "AIF3 PB"},
+ 	{"SLIM RX6 MUX", "AIF3_PB", "AIF3 PB"},
+ 	{"SLIM RX7 MUX", "AIF3_PB", "AIF3 PB"},
+ 
+ 	{"SLIM RX0 MUX", "AIF4_PB", "AIF4 PB"},
+ 	{"SLIM RX1 MUX", "AIF4_PB", "AIF4 PB"},
+ 	{"SLIM RX2 MUX", "AIF4_PB", "AIF4 PB"},
+ 	{"SLIM RX3 MUX", "AIF4_PB", "AIF4 PB"},
+ 	{"SLIM RX4 MUX", "AIF4_PB", "AIF4 PB"},
+ 	{"SLIM RX5 MUX", "AIF4_PB", "AIF4 PB"},
+ 	{"SLIM RX6 MUX", "AIF4_PB", "AIF4 PB"},
+ 	{"SLIM RX7 MUX", "AIF4_PB", "AIF4 PB"},
+ 
+ 	{"SLIM RX0", NULL, "SLIM RX0 MUX"},
+ 	{"SLIM RX1", NULL, "SLIM RX1 MUX"},
+ 	{"SLIM RX2", NULL, "SLIM RX2 MUX"},
+ 	{"SLIM RX3", NULL, "SLIM RX3 MUX"},
+ 	{"SLIM RX4", NULL, "SLIM RX4 MUX"},
+ 	{"SLIM RX5", NULL, "SLIM RX5 MUX"},
+ 	{"SLIM RX6", NULL, "SLIM RX6 MUX"},
+ 	{"SLIM RX7", NULL, "SLIM RX7 MUX"},
+ 
+ 	WCD9335_INTERPOLATOR_PATH(0),
+ 	WCD9335_INTERPOLATOR_PATH(1),
+ 	WCD9335_INTERPOLATOR_PATH(2),
+ 	WCD9335_INTERPOLATOR_PATH(3),
+ 	WCD9335_INTERPOLATOR_PATH(4),
+ 	WCD9335_INTERPOLATOR_PATH(5),
+ 	WCD9335_INTERPOLATOR_PATH(6),
+ 	WCD9335_INTERPOLATOR_PATH(7),
+ 	WCD9335_INTERPOLATOR_PATH(8),
+ 
+ 	/* EAR PA */
+ 	{"RX INT0 DEM MUX", "CLSH_DSM_OUT", "RX INT0 INTERP"},
+ 	{"RX INT0 DAC", NULL, "RX INT0 DEM MUX"},
+ 	{"RX INT0 DAC", NULL, "RX_BIAS"},
+ 	{"EAR PA", NULL, "RX INT0 DAC"},
+ 	{"EAR", NULL, "EAR PA"},
+ 
+ 	/* HPHL */
+ 	{"RX INT1 DEM MUX", "CLSH_DSM_OUT", "RX INT1 INTERP"},
+ 	{"RX INT1 DAC", NULL, "RX INT1 DEM MUX"},
+ 	{"RX INT1 DAC", NULL, "RX_BIAS"},
+ 	{"HPHL PA", NULL, "RX INT1 DAC"},
+ 	{"HPHL", NULL, "HPHL PA"},
+ 
+ 	/* HPHR */
+ 	{"RX INT2 DEM MUX", "CLSH_DSM_OUT", "RX INT2 INTERP"},
+ 	{"RX INT2 DAC", NULL, "RX INT2 DEM MUX"},
+ 	{"RX INT2 DAC", NULL, "RX_BIAS"},
+ 	{"HPHR PA", NULL, "RX INT2 DAC"},
+ 	{"HPHR", NULL, "HPHR PA"},
+ 
+ 	/* LINEOUT1 */
+ 	{"RX INT3 DAC", NULL, "RX INT3 INTERP"},
+ 	{"RX INT3 DAC", NULL, "RX_BIAS"},
+ 	{"LINEOUT1 PA", NULL, "RX INT3 DAC"},
+ 	{"LINEOUT1", NULL, "LINEOUT1 PA"},
+ 
+ 	/* LINEOUT2 */
+ 	{"RX INT4 DAC", NULL, "RX INT4 INTERP"},
+ 	{"RX INT4 DAC", NULL, "RX_BIAS"},
+ 	{"LINEOUT2 PA", NULL, "RX INT4 DAC"},
+ 	{"LINEOUT2", NULL, "LINEOUT2 PA"},
+ 
+ 	/* LINEOUT3 */
+ 	{"RX INT5 DAC", NULL, "RX INT5 INTERP"},
+ 	{"RX INT5 DAC", NULL, "RX_BIAS"},
+ 	{"LINEOUT3 PA", NULL, "RX INT5 DAC"},
+ 	{"LINEOUT3", NULL, "LINEOUT3 PA"},
+ 
+ 	/* LINEOUT4 */
+ 	{"RX INT6 DAC", NULL, "RX INT6 INTERP"},
+ 	{"RX INT6 DAC", NULL, "RX_BIAS"},
+ 	{"LINEOUT4 PA", NULL, "RX INT6 DAC"},
+ 	{"LINEOUT4", NULL, "LINEOUT4 PA"},
+ 
+ 	/* SLIMBUS Connections */
+ 	{"AIF1 CAP", NULL, "AIF1_CAP Mixer"},
+ 	{"AIF2 CAP", NULL, "AIF2_CAP Mixer"},
+ 	{"AIF3 CAP", NULL, "AIF3_CAP Mixer"},
+ 
+ 	/* ADC Mux */
+ 	WCD9335_ADC_MUX_PATH(0),
+ 	WCD9335_ADC_MUX_PATH(1),
+ 	WCD9335_ADC_MUX_PATH(2),
+ 	WCD9335_ADC_MUX_PATH(3),
+ 	WCD9335_ADC_MUX_PATH(4),
+ 	WCD9335_ADC_MUX_PATH(5),
+ 	WCD9335_ADC_MUX_PATH(6),
+ 	WCD9335_ADC_MUX_PATH(7),
+ 	WCD9335_ADC_MUX_PATH(8),
+ 
+ 	/* ADC Connections */
+ 	{"ADC1", NULL, "AMIC1"},
+ 	{"ADC2", NULL, "AMIC2"},
+ 	{"ADC3", NULL, "AMIC3"},
+ 	{"ADC4", NULL, "AMIC4"},
+ 	{"ADC5", NULL, "AMIC5"},
+ 	{"ADC6", NULL, "AMIC6"},
+ };
+ 
+ static int wcd9335_micbias_control(struct snd_soc_component *component,
+ 				   int micb_num, int req, bool is_dapm)
+ {
+ 	struct wcd9335_codec *wcd = snd_soc_component_get_drvdata(component);
+ 	int micb_index = micb_num - 1;
+ 	u16 micb_reg;
+ 
+ 	if ((micb_index < 0) || (micb_index > WCD9335_MAX_MICBIAS - 1)) {
+ 		dev_err(wcd->dev, "Invalid micbias index, micb_ind:%d\n",
+ 			micb_index);
+ 		return -EINVAL;
+ 	}
+ 
+ 	switch (micb_num) {
+ 	case MIC_BIAS_1:
+ 		micb_reg = WCD9335_ANA_MICB1;
+ 		break;
+ 	case MIC_BIAS_2:
+ 		micb_reg = WCD9335_ANA_MICB2;
+ 		break;
+ 	case MIC_BIAS_3:
+ 		micb_reg = WCD9335_ANA_MICB3;
+ 		break;
+ 	case MIC_BIAS_4:
+ 		micb_reg = WCD9335_ANA_MICB4;
+ 		break;
+ 	default:
+ 		dev_err(component->dev, "%s: Invalid micbias number: %d\n",
+ 			__func__, micb_num);
+ 		return -EINVAL;
+ 	}
+ 
+ 	switch (req) {
+ 	case MICB_PULLUP_ENABLE:
+ 		wcd->pullup_ref[micb_index]++;
+ 		if ((wcd->pullup_ref[micb_index] == 1) &&
+ 		    (wcd->micb_ref[micb_index] == 0))
+ 			snd_soc_component_update_bits(component, micb_reg,
+ 							0xC0, 0x80);
+ 		break;
+ 	case MICB_PULLUP_DISABLE:
+ 		wcd->pullup_ref[micb_index]--;
+ 		if ((wcd->pullup_ref[micb_index] == 0) &&
+ 		    (wcd->micb_ref[micb_index] == 0))
+ 			snd_soc_component_update_bits(component, micb_reg,
+ 							0xC0, 0x00);
+ 		break;
+ 	case MICB_ENABLE:
+ 		wcd->micb_ref[micb_index]++;
+ 		if (wcd->micb_ref[micb_index] == 1)
+ 			snd_soc_component_update_bits(component, micb_reg,
+ 							0xC0, 0x40);
+ 		break;
+ 	case MICB_DISABLE:
+ 		wcd->micb_ref[micb_index]--;
+ 		if ((wcd->micb_ref[micb_index] == 0) &&
+ 		    (wcd->pullup_ref[micb_index] > 0))
+ 			snd_soc_component_update_bits(component, micb_reg,
+ 							0xC0, 0x80);
+ 		else if ((wcd->micb_ref[micb_index] == 0) &&
+ 			 (wcd->pullup_ref[micb_index] == 0)) {
+ 			snd_soc_component_update_bits(component, micb_reg,
+ 							0xC0, 0x00);
+ 		}
+ 		break;
+ 	};
+ 
+ 	return 0;
+ }
+ 
+ static int __wcd9335_codec_enable_micbias(struct snd_soc_dapm_widget *w,
+ 					int event)
+ {
+ 	struct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);
+ 	int micb_num;
+ 
+ 	if (strnstr(w->name, "MIC BIAS1", sizeof("MIC BIAS1")))
+ 		micb_num = MIC_BIAS_1;
+ 	else if (strnstr(w->name, "MIC BIAS2", sizeof("MIC BIAS2")))
+ 		micb_num = MIC_BIAS_2;
+ 	else if (strnstr(w->name, "MIC BIAS3", sizeof("MIC BIAS3")))
+ 		micb_num = MIC_BIAS_3;
+ 	else if (strnstr(w->name, "MIC BIAS4", sizeof("MIC BIAS4")))
+ 		micb_num = MIC_BIAS_4;
+ 	else
+ 		return -EINVAL;
+ 
+ 	switch (event) {
+ 	case SND_SOC_DAPM_PRE_PMU:
+ 		/*
+ 		 * MIC BIAS can also be requested by MBHC,
+ 		 * so use ref count to handle micbias pullup
+ 		 * and enable requests
+ 		 */
+ 		wcd9335_micbias_control(comp, micb_num, MICB_ENABLE, true);
+ 		break;
+ 	case SND_SOC_DAPM_POST_PMU:
+ 		/* wait for cnp time */
+ 		usleep_range(1000, 1100);
+ 		break;
+ 	case SND_SOC_DAPM_POST_PMD:
+ 		wcd9335_micbias_control(comp, micb_num, MICB_DISABLE, true);
+ 		break;
+ 	};
+ 
+ 	return 0;
+ }
+ 
+ static int wcd9335_codec_enable_micbias(struct snd_soc_dapm_widget *w,
+ 		struct snd_kcontrol *kc, int event)
+ {
+ 	return __wcd9335_codec_enable_micbias(w, event);
+ }
+ 
+ static void wcd9335_codec_set_tx_hold(struct snd_soc_component *comp,
+ 				      u16 amic_reg, bool set)
+ {
+ 	u8 mask = 0x20;
+ 	u8 val;
+ 
+ 	if (amic_reg == WCD9335_ANA_AMIC1 || amic_reg == WCD9335_ANA_AMIC3 ||
+ 	    amic_reg == WCD9335_ANA_AMIC5)
+ 		mask = 0x40;
+ 
+ 	val = set ? mask : 0x00;
+ 
+ 	switch (amic_reg) {
+ 	case WCD9335_ANA_AMIC1:
+ 	case WCD9335_ANA_AMIC2:
+ 		snd_soc_component_update_bits(comp, WCD9335_ANA_AMIC2, mask,
+ 						val);
+ 		break;
+ 	case WCD9335_ANA_AMIC3:
+ 	case WCD9335_ANA_AMIC4:
+ 		snd_soc_component_update_bits(comp, WCD9335_ANA_AMIC4, mask,
+ 						val);
+ 		break;
+ 	case WCD9335_ANA_AMIC5:
+ 	case WCD9335_ANA_AMIC6:
+ 		snd_soc_component_update_bits(comp, WCD9335_ANA_AMIC6, mask,
+ 						val);
+ 		break;
+ 	default:
+ 		dev_err(comp->dev, "%s: invalid amic: %d\n",
+ 			__func__, amic_reg);
+ 		break;
+ 	}
+ }
+ 
+ static int wcd9335_codec_enable_adc(struct snd_soc_dapm_widget *w,
+ 		struct snd_kcontrol *kc, int event)
+ {
+ 	struct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);
+ 
+ 	switch (event) {
+ 	case SND_SOC_DAPM_PRE_PMU:
+ 		wcd9335_codec_set_tx_hold(comp, w->reg, true);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int wcd9335_codec_find_amic_input(struct snd_soc_component *comp,
+ 					 int adc_mux_n)
+ {
+ 	int mux_sel, reg, mreg;
+ 
+ 	if (adc_mux_n < 0 || adc_mux_n > WCD9335_MAX_VALID_ADC_MUX ||
+ 	    adc_mux_n == WCD9335_INVALID_ADC_MUX)
+ 		return 0;
+ 
+ 	/* Check whether adc mux input is AMIC or DMIC */
+ 	if (adc_mux_n < 4) {
+ 		reg = WCD9335_CDC_TX_INP_MUX_ADC_MUX0_CFG1 + 2 * adc_mux_n;
+ 		mreg = WCD9335_CDC_TX_INP_MUX_ADC_MUX0_CFG0 + 2 * adc_mux_n;
+ 		mux_sel = snd_soc_component_read32(comp, reg) & 0x3;
+ 	} else {
+ 		reg = WCD9335_CDC_TX_INP_MUX_ADC_MUX4_CFG0 + adc_mux_n - 4;
+ 		mreg = reg;
+ 		mux_sel = snd_soc_component_read32(comp, reg) >> 6;
+ 	}
+ 
+ 	if (mux_sel != WCD9335_CDC_TX_INP_MUX_SEL_AMIC)
+ 		return 0;
+ 
+ 	return snd_soc_component_read32(comp, mreg) & 0x07;
+ }
+ 
+ static u16 wcd9335_codec_get_amic_pwlvl_reg(struct snd_soc_component *comp,
+ 					    int amic)
+ {
+ 	u16 pwr_level_reg = 0;
+ 
+ 	switch (amic) {
+ 	case 1:
+ 	case 2:
+ 		pwr_level_reg = WCD9335_ANA_AMIC1;
+ 		break;
+ 
+ 	case 3:
+ 	case 4:
+ 		pwr_level_reg = WCD9335_ANA_AMIC3;
+ 		break;
+ 
+ 	case 5:
+ 	case 6:
+ 		pwr_level_reg = WCD9335_ANA_AMIC5;
+ 		break;
+ 	default:
+ 		dev_err(comp->dev, "invalid amic: %d\n", amic);
+ 		break;
+ 	}
+ 
+ 	return pwr_level_reg;
+ }
+ 
+ static int wcd9335_codec_enable_dec(struct snd_soc_dapm_widget *w,
+ 	struct snd_kcontrol *kc, int event)
+ {
+ 	struct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);
+ 	unsigned int decimator;
+ 	char *dec_adc_mux_name = NULL;
+ 	char *widget_name = NULL;
+ 	char *wname;
+ 	int ret = 0, amic_n;
+ 	u16 tx_vol_ctl_reg, pwr_level_reg = 0, dec_cfg_reg, hpf_gate_reg;
+ 	u16 tx_gain_ctl_reg;
+ 	char *dec;
+ 	u8 hpf_coff_freq;
+ 
+ 	widget_name = kstrndup(w->name, 15, GFP_KERNEL);
+ 	if (!widget_name)
+ 		return -ENOMEM;
+ 
+ 	wname = widget_name;
+ 	dec_adc_mux_name = strsep(&widget_name, " ");
+ 	if (!dec_adc_mux_name) {
+ 		dev_err(comp->dev, "%s: Invalid decimator = %s\n",
+ 			__func__, w->name);
+ 		ret =  -EINVAL;
+ 		goto out;
+ 	}
+ 	dec_adc_mux_name = widget_name;
+ 
+ 	dec = strpbrk(dec_adc_mux_name, "012345678");
+ 	if (!dec) {
+ 		dev_err(comp->dev, "%s: decimator index not found\n",
+ 			__func__);
+ 		ret =  -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	ret = kstrtouint(dec, 10, &decimator);
+ 	if (ret < 0) {
+ 		dev_err(comp->dev, "%s: Invalid decimator = %s\n",
+ 			__func__, wname);
+ 		ret =  -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	tx_vol_ctl_reg = WCD9335_CDC_TX0_TX_PATH_CTL + 16 * decimator;
+ 	hpf_gate_reg = WCD9335_CDC_TX0_TX_PATH_SEC2 + 16 * decimator;
+ 	dec_cfg_reg = WCD9335_CDC_TX0_TX_PATH_CFG0 + 16 * decimator;
+ 	tx_gain_ctl_reg = WCD9335_CDC_TX0_TX_VOL_CTL + 16 * decimator;
+ 
+ 	switch (event) {
+ 	case SND_SOC_DAPM_PRE_PMU:
+ 		amic_n = wcd9335_codec_find_amic_input(comp, decimator);
+ 		if (amic_n)
+ 			pwr_level_reg = wcd9335_codec_get_amic_pwlvl_reg(comp,
+ 								       amic_n);
+ 
+ 		if (pwr_level_reg) {
+ 			switch ((snd_soc_component_read32(comp, pwr_level_reg) &
+ 					      WCD9335_AMIC_PWR_LVL_MASK) >>
+ 					      WCD9335_AMIC_PWR_LVL_SHIFT) {
+ 			case WCD9335_AMIC_PWR_LEVEL_LP:
+ 				snd_soc_component_update_bits(comp, dec_cfg_reg,
+ 						    WCD9335_DEC_PWR_LVL_MASK,
+ 						    WCD9335_DEC_PWR_LVL_LP);
+ 				break;
+ 
+ 			case WCD9335_AMIC_PWR_LEVEL_HP:
+ 				snd_soc_component_update_bits(comp, dec_cfg_reg,
+ 						    WCD9335_DEC_PWR_LVL_MASK,
+ 						    WCD9335_DEC_PWR_LVL_HP);
+ 				break;
+ 			case WCD9335_AMIC_PWR_LEVEL_DEFAULT:
+ 			default:
+ 				snd_soc_component_update_bits(comp, dec_cfg_reg,
+ 						    WCD9335_DEC_PWR_LVL_MASK,
+ 						    WCD9335_DEC_PWR_LVL_DF);
+ 				break;
+ 			}
+ 		}
+ 		hpf_coff_freq = (snd_soc_component_read32(comp, dec_cfg_reg) &
+ 				   TX_HPF_CUT_OFF_FREQ_MASK) >> 5;
+ 
+ 		if (hpf_coff_freq != CF_MIN_3DB_150HZ)
+ 			snd_soc_component_update_bits(comp, dec_cfg_reg,
+ 					    TX_HPF_CUT_OFF_FREQ_MASK,
+ 					    CF_MIN_3DB_150HZ << 5);
+ 		/* Enable TX PGA Mute */
+ 		snd_soc_component_update_bits(comp, tx_vol_ctl_reg,
+ 						0x10, 0x10);
+ 		/* Enable APC */
+ 		snd_soc_component_update_bits(comp, dec_cfg_reg, 0x08, 0x08);
+ 		break;
+ 	case SND_SOC_DAPM_POST_PMU:
+ 		snd_soc_component_update_bits(comp, hpf_gate_reg, 0x01, 0x00);
+ 
+ 		if (decimator == 0) {
+ 			snd_soc_component_write(comp,
+ 					WCD9335_MBHC_ZDET_RAMP_CTL, 0x83);
+ 			snd_soc_component_write(comp,
+ 					WCD9335_MBHC_ZDET_RAMP_CTL, 0xA3);
+ 			snd_soc_component_write(comp,
+ 					WCD9335_MBHC_ZDET_RAMP_CTL, 0x83);
+ 			snd_soc_component_write(comp,
+ 					WCD9335_MBHC_ZDET_RAMP_CTL, 0x03);
+ 		}
+ 
+ 		snd_soc_component_update_bits(comp, hpf_gate_reg,
+ 						0x01, 0x01);
+ 		snd_soc_component_update_bits(comp, tx_vol_ctl_reg,
+ 						0x10, 0x00);
+ 		snd_soc_component_write(comp, tx_gain_ctl_reg,
+ 			      snd_soc_component_read32(comp, tx_gain_ctl_reg));
+ 		break;
+ 	case SND_SOC_DAPM_PRE_PMD:
+ 		hpf_coff_freq = (snd_soc_component_read32(comp, dec_cfg_reg) &
+ 				   TX_HPF_CUT_OFF_FREQ_MASK) >> 5;
+ 		snd_soc_component_update_bits(comp, tx_vol_ctl_reg, 0x10, 0x10);
+ 		snd_soc_component_update_bits(comp, dec_cfg_reg, 0x08, 0x00);
+ 			if (hpf_coff_freq != CF_MIN_3DB_150HZ) {
+ 				snd_soc_component_update_bits(comp, dec_cfg_reg,
+ 						    TX_HPF_CUT_OFF_FREQ_MASK,
+ 						    hpf_coff_freq << 5);
+ 			}
+ 		break;
+ 	case SND_SOC_DAPM_POST_PMD:
+ 		snd_soc_component_update_bits(comp, tx_vol_ctl_reg, 0x10, 0x00);
+ 		break;
+ 	};
+ out:
+ 	kfree(wname);
+ 	return ret;
+ }
+ 
+ static u8 wcd9335_get_dmic_clk_val(struct snd_soc_component *component,
+ 				 u32 mclk_rate, u32 dmic_clk_rate)
+ {
+ 	u32 div_factor;
+ 	u8 dmic_ctl_val;
+ 
+ 	dev_err(component->dev,
+ 		"%s: mclk_rate = %d, dmic_sample_rate = %d\n",
+ 		__func__, mclk_rate, dmic_clk_rate);
+ 
+ 	/* Default value to return in case of error */
+ 	if (mclk_rate == WCD9335_MCLK_CLK_9P6MHZ)
+ 		dmic_ctl_val = WCD9335_DMIC_CLK_DIV_2;
+ 	else
+ 		dmic_ctl_val = WCD9335_DMIC_CLK_DIV_3;
+ 
+ 	if (dmic_clk_rate == 0) {
+ 		dev_err(component->dev,
+ 			"%s: dmic_sample_rate cannot be 0\n",
+ 			__func__);
+ 		goto done;
+ 	}
+ 
+ 	div_factor = mclk_rate / dmic_clk_rate;
+ 	switch (div_factor) {
+ 	case 2:
+ 		dmic_ctl_val = WCD9335_DMIC_CLK_DIV_2;
+ 		break;
+ 	case 3:
+ 		dmic_ctl_val = WCD9335_DMIC_CLK_DIV_3;
+ 		break;
+ 	case 4:
+ 		dmic_ctl_val = WCD9335_DMIC_CLK_DIV_4;
+ 		break;
+ 	case 6:
+ 		dmic_ctl_val = WCD9335_DMIC_CLK_DIV_6;
+ 		break;
+ 	case 8:
+ 		dmic_ctl_val = WCD9335_DMIC_CLK_DIV_8;
+ 		break;
+ 	case 16:
+ 		dmic_ctl_val = WCD9335_DMIC_CLK_DIV_16;
+ 		break;
+ 	default:
+ 		dev_err(component->dev,
+ 			"%s: Invalid div_factor %u, clk_rate(%u), dmic_rate(%u)\n",
+ 			__func__, div_factor, mclk_rate, dmic_clk_rate);
+ 		break;
+ 	}
+ 
+ done:
+ 	return dmic_ctl_val;
+ }
+ 
+ static int wcd9335_codec_enable_dmic(struct snd_soc_dapm_widget *w,
+ 		struct snd_kcontrol *kc, int event)
+ {
+ 	struct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);
+ 	struct wcd9335_codec *wcd = snd_soc_component_get_drvdata(comp);
+ 	u8  dmic_clk_en = 0x01;
+ 	u16 dmic_clk_reg;
+ 	s32 *dmic_clk_cnt;
+ 	u8 dmic_rate_val, dmic_rate_shift = 1;
+ 	unsigned int dmic;
+ 	int ret;
+ 	char *wname;
+ 
+ 	wname = strpbrk(w->name, "012345");
+ 	if (!wname) {
+ 		dev_err(comp->dev, "%s: widget not found\n", __func__);
+ 		return -EINVAL;
+ 	}
+ 
+ 	ret = kstrtouint(wname, 10, &dmic);
+ 	if (ret < 0) {
+ 		dev_err(comp->dev, "%s: Invalid DMIC line on the codec\n",
+ 			__func__);
+ 		return -EINVAL;
+ 	}
+ 
+ 	switch (dmic) {
+ 	case 0:
+ 	case 1:
+ 		dmic_clk_cnt = &(wcd->dmic_0_1_clk_cnt);
+ 		dmic_clk_reg = WCD9335_CPE_SS_DMIC0_CTL;
+ 		break;
+ 	case 2:
+ 	case 3:
+ 		dmic_clk_cnt = &(wcd->dmic_2_3_clk_cnt);
+ 		dmic_clk_reg = WCD9335_CPE_SS_DMIC1_CTL;
+ 		break;
+ 	case 4:
+ 	case 5:
+ 		dmic_clk_cnt = &(wcd->dmic_4_5_clk_cnt);
+ 		dmic_clk_reg = WCD9335_CPE_SS_DMIC2_CTL;
+ 		break;
+ 	default:
+ 		dev_err(comp->dev, "%s: Invalid DMIC Selection\n",
+ 			__func__);
+ 		return -EINVAL;
+ 	};
+ 
+ 	switch (event) {
+ 	case SND_SOC_DAPM_PRE_PMU:
+ 		dmic_rate_val =
+ 			wcd9335_get_dmic_clk_val(comp,
+ 					wcd->mclk_rate,
+ 					wcd->dmic_sample_rate);
+ 
+ 		(*dmic_clk_cnt)++;
+ 		if (*dmic_clk_cnt == 1) {
+ 			snd_soc_component_update_bits(comp, dmic_clk_reg,
+ 				0x07 << dmic_rate_shift,
+ 				dmic_rate_val << dmic_rate_shift);
+ 			snd_soc_component_update_bits(comp, dmic_clk_reg,
+ 					dmic_clk_en, dmic_clk_en);
+ 		}
+ 
+ 		break;
+ 	case SND_SOC_DAPM_POST_PMD:
+ 		dmic_rate_val =
+ 			wcd9335_get_dmic_clk_val(comp,
+ 					wcd->mclk_rate,
+ 					wcd->mad_dmic_sample_rate);
+ 		(*dmic_clk_cnt)--;
+ 		if (*dmic_clk_cnt  == 0) {
+ 			snd_soc_component_update_bits(comp, dmic_clk_reg,
+ 					dmic_clk_en, 0);
+ 			snd_soc_component_update_bits(comp, dmic_clk_reg,
+ 				0x07 << dmic_rate_shift,
+ 				dmic_rate_val << dmic_rate_shift);
+ 		}
+ 		break;
+ 	};
+ 
+ 	return 0;
+ }
+ 
+ static void wcd9335_codec_enable_int_port(struct wcd_slim_codec_dai_data *dai,
+ 					struct snd_soc_component *component)
+ {
+ 	int port_num = 0;
+ 	unsigned short reg = 0;
+ 	unsigned int val = 0;
+ 	struct wcd9335_codec *wcd = dev_get_drvdata(component->dev);
+ 	struct wcd9335_slim_ch *ch;
+ 
+ 	list_for_each_entry(ch, &dai->slim_ch_list, list) {
+ 		if (ch->port >= WCD9335_RX_START) {
+ 			port_num = ch->port - WCD9335_RX_START;
+ 			reg = WCD9335_SLIM_PGD_PORT_INT_EN0 + (port_num / 8);
+ 		} else {
+ 			port_num = ch->port;
+ 			reg = WCD9335_SLIM_PGD_PORT_INT_TX_EN0 + (port_num / 8);
+ 		}
+ 
+ 		regmap_read(wcd->if_regmap, reg, &val);
+ 		if (!(val & BIT(port_num % 8)))
+ 			regmap_write(wcd->if_regmap, reg,
+ 					val | BIT(port_num % 8));
+ 	}
+ }
+ 
+ static int wcd9335_codec_enable_slim(struct snd_soc_dapm_widget *w,
+ 				       struct snd_kcontrol *kc,
+ 				       int event)
+ {
+ 	struct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);
+ 	struct wcd9335_codec *wcd = snd_soc_component_get_drvdata(comp);
+ 	struct wcd_slim_codec_dai_data *dai = &wcd->dai[w->shift];
+ 	int ret = 0;
+ 
+ 	switch (event) {
+ 	case SND_SOC_DAPM_POST_PMU:
+ 		wcd9335_codec_enable_int_port(dai, comp);
+ 		break;
+ 	case SND_SOC_DAPM_POST_PMD:
+ 		kfree(dai->sconfig.chs);
+ 
+ 		break;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int wcd9335_codec_enable_mix_path(struct snd_soc_dapm_widget *w,
+ 		struct snd_kcontrol *kc, int event)
+ {
+ 	struct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);
+ 	u16 gain_reg;
+ 	int offset_val = 0;
+ 	int val = 0;
+ 
+ 	switch (w->reg) {
+ 	case WCD9335_CDC_RX0_RX_PATH_MIX_CTL:
+ 		gain_reg = WCD9335_CDC_RX0_RX_VOL_MIX_CTL;
+ 		break;
+ 	case WCD9335_CDC_RX1_RX_PATH_MIX_CTL:
+ 		gain_reg = WCD9335_CDC_RX1_RX_VOL_MIX_CTL;
+ 		break;
+ 	case WCD9335_CDC_RX2_RX_PATH_MIX_CTL:
+ 		gain_reg = WCD9335_CDC_RX2_RX_VOL_MIX_CTL;
+ 		break;
+ 	case WCD9335_CDC_RX3_RX_PATH_MIX_CTL:
+ 		gain_reg = WCD9335_CDC_RX3_RX_VOL_MIX_CTL;
+ 		break;
+ 	case WCD9335_CDC_RX4_RX_PATH_MIX_CTL:
+ 		gain_reg = WCD9335_CDC_RX4_RX_VOL_MIX_CTL;
+ 		break;
+ 	case WCD9335_CDC_RX5_RX_PATH_MIX_CTL:
+ 		gain_reg = WCD9335_CDC_RX5_RX_VOL_MIX_CTL;
+ 		break;
+ 	case WCD9335_CDC_RX6_RX_PATH_MIX_CTL:
+ 		gain_reg = WCD9335_CDC_RX6_RX_VOL_MIX_CTL;
+ 		break;
+ 	case WCD9335_CDC_RX7_RX_PATH_MIX_CTL:
+ 		gain_reg = WCD9335_CDC_RX7_RX_VOL_MIX_CTL;
+ 		break;
+ 	case WCD9335_CDC_RX8_RX_PATH_MIX_CTL:
+ 		gain_reg = WCD9335_CDC_RX8_RX_VOL_MIX_CTL;
+ 		break;
+ 	default:
+ 		dev_err(comp->dev, "%s: No gain register avail for %s\n",
+ 			__func__, w->name);
+ 		return 0;
+ 	};
+ 
+ 	switch (event) {
+ 	case SND_SOC_DAPM_POST_PMU:
+ 		val = snd_soc_component_read32(comp, gain_reg);
+ 		val += offset_val;
+ 		snd_soc_component_write(comp, gain_reg, val);
+ 		break;
+ 	case SND_SOC_DAPM_POST_PMD:
+ 		break;
+ 	};
+ 
+ 	return 0;
+ }
+ 
+ static u16 wcd9335_interp_get_primary_reg(u16 reg, u16 *ind)
+ {
+ 	u16 prim_int_reg = WCD9335_CDC_RX0_RX_PATH_CTL;
+ 
+ 	switch (reg) {
+ 	case WCD9335_CDC_RX0_RX_PATH_CTL:
+ 	case WCD9335_CDC_RX0_RX_PATH_MIX_CTL:
+ 		prim_int_reg = WCD9335_CDC_RX0_RX_PATH_CTL;
+ 		*ind = 0;
+ 		break;
+ 	case WCD9335_CDC_RX1_RX_PATH_CTL:
+ 	case WCD9335_CDC_RX1_RX_PATH_MIX_CTL:
+ 		prim_int_reg = WCD9335_CDC_RX1_RX_PATH_CTL;
+ 		*ind = 1;
+ 		break;
+ 	case WCD9335_CDC_RX2_RX_PATH_CTL:
+ 	case WCD9335_CDC_RX2_RX_PATH_MIX_CTL:
+ 		prim_int_reg = WCD9335_CDC_RX2_RX_PATH_CTL;
+ 		*ind = 2;
+ 		break;
+ 	case WCD9335_CDC_RX3_RX_PATH_CTL:
+ 	case WCD9335_CDC_RX3_RX_PATH_MIX_CTL:
+ 		prim_int_reg = WCD9335_CDC_RX3_RX_PATH_CTL;
+ 		*ind = 3;
+ 		break;
+ 	case WCD9335_CDC_RX4_RX_PATH_CTL:
+ 	case WCD9335_CDC_RX4_RX_PATH_MIX_CTL:
+ 		prim_int_reg = WCD9335_CDC_RX4_RX_PATH_CTL;
+ 		*ind = 4;
+ 		break;
+ 	case WCD9335_CDC_RX5_RX_PATH_CTL:
+ 	case WCD9335_CDC_RX5_RX_PATH_MIX_CTL:
+ 		prim_int_reg = WCD9335_CDC_RX5_RX_PATH_CTL;
+ 		*ind = 5;
+ 		break;
+ 	case WCD9335_CDC_RX6_RX_PATH_CTL:
+ 	case WCD9335_CDC_RX6_RX_PATH_MIX_CTL:
+ 		prim_int_reg = WCD9335_CDC_RX6_RX_PATH_CTL;
+ 		*ind = 6;
+ 		break;
+ 	case WCD9335_CDC_RX7_RX_PATH_CTL:
+ 	case WCD9335_CDC_RX7_RX_PATH_MIX_CTL:
+ 		prim_int_reg = WCD9335_CDC_RX7_RX_PATH_CTL;
+ 		*ind = 7;
+ 		break;
+ 	case WCD9335_CDC_RX8_RX_PATH_CTL:
+ 	case WCD9335_CDC_RX8_RX_PATH_MIX_CTL:
+ 		prim_int_reg = WCD9335_CDC_RX8_RX_PATH_CTL;
+ 		*ind = 8;
+ 		break;
+ 	};
+ 
+ 	return prim_int_reg;
+ }
+ 
+ static void wcd9335_codec_hd2_control(struct snd_soc_component *component,
+ 				    u16 prim_int_reg, int event)
+ {
+ 	u16 hd2_scale_reg;
+ 	u16 hd2_enable_reg = 0;
+ 
+ 	if (prim_int_reg == WCD9335_CDC_RX1_RX_PATH_CTL) {
+ 		hd2_scale_reg = WCD9335_CDC_RX1_RX_PATH_SEC3;
+ 		hd2_enable_reg = WCD9335_CDC_RX1_RX_PATH_CFG0;
+ 	}
+ 	if (prim_int_reg == WCD9335_CDC_RX2_RX_PATH_CTL) {
+ 		hd2_scale_reg = WCD9335_CDC_RX2_RX_PATH_SEC3;
+ 		hd2_enable_reg = WCD9335_CDC_RX2_RX_PATH_CFG0;
+ 	}
+ 
+ 	if (hd2_enable_reg && SND_SOC_DAPM_EVENT_ON(event)) {
+ 		snd_soc_component_update_bits(component, hd2_scale_reg,
+ 				WCD9335_CDC_RX_PATH_SEC_HD2_ALPHA_MASK,
+ 				WCD9335_CDC_RX_PATH_SEC_HD2_ALPHA_0P2500);
+ 		snd_soc_component_update_bits(component, hd2_scale_reg,
+ 				WCD9335_CDC_RX_PATH_SEC_HD2_SCALE_MASK,
+ 				WCD9335_CDC_RX_PATH_SEC_HD2_SCALE_2);
+ 		snd_soc_component_update_bits(component, hd2_enable_reg,
+ 				WCD9335_CDC_RX_PATH_CFG_HD2_EN_MASK,
+ 				WCD9335_CDC_RX_PATH_CFG_HD2_ENABLE);
+ 	}
+ 
+ 	if (hd2_enable_reg && SND_SOC_DAPM_EVENT_OFF(event)) {
+ 		snd_soc_component_update_bits(component, hd2_enable_reg,
+ 					WCD9335_CDC_RX_PATH_CFG_HD2_EN_MASK,
+ 					WCD9335_CDC_RX_PATH_CFG_HD2_DISABLE);
+ 		snd_soc_component_update_bits(component, hd2_scale_reg,
+ 					WCD9335_CDC_RX_PATH_SEC_HD2_SCALE_MASK,
+ 					WCD9335_CDC_RX_PATH_SEC_HD2_SCALE_1);
+ 		snd_soc_component_update_bits(component, hd2_scale_reg,
+ 				WCD9335_CDC_RX_PATH_SEC_HD2_ALPHA_MASK,
+ 				WCD9335_CDC_RX_PATH_SEC_HD2_ALPHA_0P0000);
+ 	}
+ }
+ 
+ static int wcd9335_codec_enable_prim_interpolator(
+ 						struct snd_soc_component *comp,
+ 						u16 reg, int event)
+ {
+ 	struct wcd9335_codec *wcd = dev_get_drvdata(comp->dev);
+ 	u16 ind = 0;
+ 	int prim_int_reg = wcd9335_interp_get_primary_reg(reg, &ind);
+ 
+ 	switch (event) {
+ 	case SND_SOC_DAPM_PRE_PMU:
+ 		wcd->prim_int_users[ind]++;
+ 		if (wcd->prim_int_users[ind] == 1) {
+ 			snd_soc_component_update_bits(comp, prim_int_reg,
+ 					WCD9335_CDC_RX_PGA_MUTE_EN_MASK,
+ 					WCD9335_CDC_RX_PGA_MUTE_ENABLE);
+ 			wcd9335_codec_hd2_control(comp, prim_int_reg, event);
+ 			snd_soc_component_update_bits(comp, prim_int_reg,
+ 					WCD9335_CDC_RX_CLK_EN_MASK,
+ 					WCD9335_CDC_RX_CLK_ENABLE);
+ 		}
+ 
+ 		if ((reg != prim_int_reg) &&
+ 			((snd_soc_component_read32(comp, prim_int_reg)) &
+ 			 WCD9335_CDC_RX_PGA_MUTE_EN_MASK))
+ 			snd_soc_component_update_bits(comp, reg,
+ 						WCD9335_CDC_RX_PGA_MUTE_EN_MASK,
+ 						WCD9335_CDC_RX_PGA_MUTE_ENABLE);
+ 		break;
+ 	case SND_SOC_DAPM_POST_PMD:
+ 		wcd->prim_int_users[ind]--;
+ 		if (wcd->prim_int_users[ind] == 0) {
+ 			snd_soc_component_update_bits(comp, prim_int_reg,
+ 					WCD9335_CDC_RX_CLK_EN_MASK,
+ 					WCD9335_CDC_RX_CLK_DISABLE);
+ 			snd_soc_component_update_bits(comp, prim_int_reg,
+ 					WCD9335_CDC_RX_RESET_MASK,
+ 					WCD9335_CDC_RX_RESET_ENABLE);
+ 			snd_soc_component_update_bits(comp, prim_int_reg,
+ 					WCD9335_CDC_RX_RESET_MASK,
+ 					WCD9335_CDC_RX_RESET_DISABLE);
+ 			wcd9335_codec_hd2_control(comp, prim_int_reg, event);
+ 		}
+ 		break;
+ 	};
+ 
+ 	return 0;
+ }
+ 
+ static int wcd9335_config_compander(struct snd_soc_component *component,
+ 				    int interp_n, int event)
+ {
+ 	struct wcd9335_codec *wcd = dev_get_drvdata(component->dev);
+ 	int comp;
+ 	u16 comp_ctl0_reg, rx_path_cfg0_reg;
+ 
+ 	/* EAR does not have compander */
+ 	if (!interp_n)
+ 		return 0;
+ 
+ 	comp = interp_n - 1;
+ 	if (!wcd->comp_enabled[comp])
+ 		return 0;
+ 
+ 	comp_ctl0_reg = WCD9335_CDC_COMPANDER1_CTL(comp);
+ 	rx_path_cfg0_reg = WCD9335_CDC_RX1_RX_PATH_CFG(comp);
+ 
+ 	if (SND_SOC_DAPM_EVENT_ON(event)) {
+ 		/* Enable Compander Clock */
+ 		snd_soc_component_update_bits(component, comp_ctl0_reg,
+ 					WCD9335_CDC_COMPANDER_CLK_EN_MASK,
+ 					WCD9335_CDC_COMPANDER_CLK_ENABLE);
+ 		/* Reset comander */
+ 		snd_soc_component_update_bits(component, comp_ctl0_reg,
+ 					WCD9335_CDC_COMPANDER_SOFT_RST_MASK,
+ 					WCD9335_CDC_COMPANDER_SOFT_RST_ENABLE);
+ 		snd_soc_component_update_bits(component, comp_ctl0_reg,
+ 				WCD9335_CDC_COMPANDER_SOFT_RST_MASK,
+ 				WCD9335_CDC_COMPANDER_SOFT_RST_DISABLE);
+ 		/* Enables DRE in this path */
+ 		snd_soc_component_update_bits(component, rx_path_cfg0_reg,
+ 					WCD9335_CDC_RX_PATH_CFG_CMP_EN_MASK,
+ 					WCD9335_CDC_RX_PATH_CFG_CMP_ENABLE);
+ 	}
+ 
+ 	if (SND_SOC_DAPM_EVENT_OFF(event)) {
+ 		snd_soc_component_update_bits(component, comp_ctl0_reg,
+ 					WCD9335_CDC_COMPANDER_HALT_MASK,
+ 					WCD9335_CDC_COMPANDER_HALT);
+ 		snd_soc_component_update_bits(component, rx_path_cfg0_reg,
+ 					WCD9335_CDC_RX_PATH_CFG_CMP_EN_MASK,
+ 					WCD9335_CDC_RX_PATH_CFG_CMP_DISABLE);
+ 
+ 		snd_soc_component_update_bits(component, comp_ctl0_reg,
+ 					WCD9335_CDC_COMPANDER_SOFT_RST_MASK,
+ 					WCD9335_CDC_COMPANDER_SOFT_RST_ENABLE);
+ 		snd_soc_component_update_bits(component, comp_ctl0_reg,
+ 				WCD9335_CDC_COMPANDER_SOFT_RST_MASK,
+ 				WCD9335_CDC_COMPANDER_SOFT_RST_DISABLE);
+ 		snd_soc_component_update_bits(component, comp_ctl0_reg,
+ 					WCD9335_CDC_COMPANDER_CLK_EN_MASK,
+ 					WCD9335_CDC_COMPANDER_CLK_DISABLE);
+ 		snd_soc_component_update_bits(component, comp_ctl0_reg,
+ 					WCD9335_CDC_COMPANDER_HALT_MASK,
+ 					WCD9335_CDC_COMPANDER_NOHALT);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int wcd9335_codec_enable_interpolator(struct snd_soc_dapm_widget *w,
+ 		struct snd_kcontrol *kc, int event)
+ {
+ 	struct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);
+ 	u16 gain_reg;
+ 	u16 reg;
+ 	int val;
+ 	int offset_val = 0;
+ 
+ 	if (!(strcmp(w->name, "RX INT0 INTERP"))) {
+ 		reg = WCD9335_CDC_RX0_RX_PATH_CTL;
+ 		gain_reg = WCD9335_CDC_RX0_RX_VOL_CTL;
+ 	} else if (!(strcmp(w->name, "RX INT1 INTERP"))) {
+ 		reg = WCD9335_CDC_RX1_RX_PATH_CTL;
+ 		gain_reg = WCD9335_CDC_RX1_RX_VOL_CTL;
+ 	} else if (!(strcmp(w->name, "RX INT2 INTERP"))) {
+ 		reg = WCD9335_CDC_RX2_RX_PATH_CTL;
+ 		gain_reg = WCD9335_CDC_RX2_RX_VOL_CTL;
+ 	} else if (!(strcmp(w->name, "RX INT3 INTERP"))) {
+ 		reg = WCD9335_CDC_RX3_RX_PATH_CTL;
+ 		gain_reg = WCD9335_CDC_RX3_RX_VOL_CTL;
+ 	} else if (!(strcmp(w->name, "RX INT4 INTERP"))) {
+ 		reg = WCD9335_CDC_RX4_RX_PATH_CTL;
+ 		gain_reg = WCD9335_CDC_RX4_RX_VOL_CTL;
+ 	} else if (!(strcmp(w->name, "RX INT5 INTERP"))) {
+ 		reg = WCD9335_CDC_RX5_RX_PATH_CTL;
+ 		gain_reg = WCD9335_CDC_RX5_RX_VOL_CTL;
+ 	} else if (!(strcmp(w->name, "RX INT6 INTERP"))) {
+ 		reg = WCD9335_CDC_RX6_RX_PATH_CTL;
+ 		gain_reg = WCD9335_CDC_RX6_RX_VOL_CTL;
+ 	} else if (!(strcmp(w->name, "RX INT7 INTERP"))) {
+ 		reg = WCD9335_CDC_RX7_RX_PATH_CTL;
+ 		gain_reg = WCD9335_CDC_RX7_RX_VOL_CTL;
+ 	} else if (!(strcmp(w->name, "RX INT8 INTERP"))) {
+ 		reg = WCD9335_CDC_RX8_RX_PATH_CTL;
+ 		gain_reg = WCD9335_CDC_RX8_RX_VOL_CTL;
+ 	} else {
+ 		dev_err(comp->dev, "%s: Interpolator reg not found\n",
+ 			__func__);
+ 		return -EINVAL;
+ 	}
+ 
+ 	switch (event) {
+ 	case SND_SOC_DAPM_PRE_PMU:
+ 		/* Reset if needed */
+ 		wcd9335_codec_enable_prim_interpolator(comp, reg, event);
+ 		break;
+ 	case SND_SOC_DAPM_POST_PMU:
+ 		wcd9335_config_compander(comp, w->shift, event);
+ 		val = snd_soc_component_read32(comp, gain_reg);
+ 		val += offset_val;
+ 		snd_soc_component_write(comp, gain_reg, val);
+ 		break;
+ 	case SND_SOC_DAPM_POST_PMD:
+ 		wcd9335_config_compander(comp, w->shift, event);
+ 		wcd9335_codec_enable_prim_interpolator(comp, reg, event);
+ 		break;
+ 	};
+ 
+ 	return 0;
+ }
+ 
+ static void wcd9335_codec_hph_mode_gain_opt(struct snd_soc_component *component,
+ 					    u8 gain)
+ {
+ 	struct wcd9335_codec *wcd = dev_get_drvdata(component->dev);
+ 	u8 hph_l_en, hph_r_en;
+ 	u8 l_val, r_val;
+ 	u8 hph_pa_status;
+ 	bool is_hphl_pa, is_hphr_pa;
+ 
+ 	hph_pa_status = snd_soc_component_read32(component, WCD9335_ANA_HPH);
+ 	is_hphl_pa = hph_pa_status >> 7;
+ 	is_hphr_pa = (hph_pa_status & 0x40) >> 6;
+ 
+ 	hph_l_en = snd_soc_component_read32(component, WCD9335_HPH_L_EN);
+ 	hph_r_en = snd_soc_component_read32(component, WCD9335_HPH_R_EN);
+ 
+ 	l_val = (hph_l_en & 0xC0) | 0x20 | gain;
+ 	r_val = (hph_r_en & 0xC0) | 0x20 | gain;
+ 
+ 	/*
+ 	 * Set HPH_L & HPH_R gain source selection to REGISTER
+ 	 * for better click and pop only if corresponding PAs are
+ 	 * not enabled. Also cache the values of the HPHL/R
+ 	 * PA gains to be applied after PAs are enabled
+ 	 */
+ 	if ((l_val != hph_l_en) && !is_hphl_pa) {
+ 		snd_soc_component_write(component, WCD9335_HPH_L_EN, l_val);
+ 		wcd->hph_l_gain = hph_l_en & 0x1F;
+ 	}
+ 
+ 	if ((r_val != hph_r_en) && !is_hphr_pa) {
+ 		snd_soc_component_write(component, WCD9335_HPH_R_EN, r_val);
+ 		wcd->hph_r_gain = hph_r_en & 0x1F;
+ 	}
+ }
+ 
+ static void wcd9335_codec_hph_lohifi_config(struct snd_soc_component *comp,
+ 					  int event)
+ {
+ 	if (SND_SOC_DAPM_EVENT_ON(event)) {
+ 		snd_soc_component_update_bits(comp, WCD9335_RX_BIAS_HPH_PA,
+ 					WCD9335_RX_BIAS_HPH_PA_AMP_5_UA_MASK,
+ 					0x06);
+ 		snd_soc_component_update_bits(comp,
+ 					WCD9335_RX_BIAS_HPH_RDACBUFF_CNP2,
+ 					0xF0, 0x40);
+ 		snd_soc_component_update_bits(comp, WCD9335_HPH_CNP_WG_CTL,
+ 				WCD9335_HPH_CNP_WG_CTL_CURR_LDIV_MASK,
+ 				WCD9335_HPH_CNP_WG_CTL_CURR_LDIV_RATIO_1000);
+ 		snd_soc_component_update_bits(comp, WCD9335_HPH_PA_CTL2,
+ 				WCD9335_HPH_PA_CTL2_FORCE_IQCTRL_MASK,
+ 				WCD9335_HPH_PA_CTL2_FORCE_IQCTRL_ENABLE);
+ 		snd_soc_component_update_bits(comp, WCD9335_HPH_PA_CTL1,
+ 				WCD9335_HPH_PA_GM3_IB_SCALE_MASK,
+ 				0x0C);
+ 		wcd9335_codec_hph_mode_gain_opt(comp, 0x11);
+ 	}
+ 
+ 	if (SND_SOC_DAPM_EVENT_OFF(event)) {
+ 		snd_soc_component_update_bits(comp, WCD9335_HPH_PA_CTL2,
+ 			WCD9335_HPH_PA_CTL2_FORCE_IQCTRL_MASK,
+ 			WCD9335_HPH_PA_CTL2_FORCE_IQCTRL_DISABLE);
+ 		snd_soc_component_update_bits(comp, WCD9335_HPH_CNP_WG_CTL,
+ 				WCD9335_HPH_CNP_WG_CTL_CURR_LDIV_MASK,
+ 				WCD9335_HPH_CNP_WG_CTL_CURR_LDIV_RATIO_500);
+ 		snd_soc_component_write(comp, WCD9335_RX_BIAS_HPH_RDACBUFF_CNP2,
+ 					0x8A);
+ 		snd_soc_component_update_bits(comp, WCD9335_RX_BIAS_HPH_PA,
+ 					WCD9335_RX_BIAS_HPH_PA_AMP_5_UA_MASK,
+ 					0x0A);
+ 	}
+ }
+ 
+ static void wcd9335_codec_hph_lp_config(struct snd_soc_component *comp,
+ 				      int event)
+ {
+ 	if (SND_SOC_DAPM_EVENT_ON(event)) {
+ 		snd_soc_component_update_bits(comp, WCD9335_HPH_PA_CTL1,
+ 				WCD9335_HPH_PA_GM3_IB_SCALE_MASK,
+ 				0x0C);
+ 		wcd9335_codec_hph_mode_gain_opt(comp, 0x10);
+ 		snd_soc_component_update_bits(comp, WCD9335_HPH_CNP_WG_CTL,
+ 				WCD9335_HPH_CNP_WG_CTL_CURR_LDIV_MASK,
+ 				WCD9335_HPH_CNP_WG_CTL_CURR_LDIV_RATIO_1000);
+ 		snd_soc_component_update_bits(comp, WCD9335_HPH_PA_CTL2,
+ 			WCD9335_HPH_PA_CTL2_FORCE_IQCTRL_MASK,
+ 			WCD9335_HPH_PA_CTL2_FORCE_IQCTRL_ENABLE);
+ 		snd_soc_component_update_bits(comp, WCD9335_HPH_PA_CTL2,
+ 				WCD9335_HPH_PA_CTL2_FORCE_PSRREH_MASK,
+ 				WCD9335_HPH_PA_CTL2_FORCE_PSRREH_ENABLE);
+ 		snd_soc_component_update_bits(comp, WCD9335_HPH_PA_CTL2,
+ 				WCD9335_HPH_PA_CTL2_HPH_PSRR_ENH_MASK,
+ 				WCD9335_HPH_PA_CTL2_HPH_PSRR_ENABLE);
+ 		snd_soc_component_update_bits(comp, WCD9335_HPH_RDAC_LDO_CTL,
+ 				WCD9335_HPH_RDAC_N1P65_LD_OUTCTL_MASK,
+ 				WCD9335_HPH_RDAC_N1P65_LD_OUTCTL_V_N1P60);
+ 		snd_soc_component_update_bits(comp, WCD9335_HPH_RDAC_LDO_CTL,
+ 				WCD9335_HPH_RDAC_1P65_LD_OUTCTL_MASK,
+ 				WCD9335_HPH_RDAC_1P65_LD_OUTCTL_V_N1P60);
+ 		snd_soc_component_update_bits(comp,
+ 				WCD9335_RX_BIAS_HPH_RDAC_LDO, 0x0F, 0x01);
+ 		snd_soc_component_update_bits(comp,
+ 				WCD9335_RX_BIAS_HPH_RDAC_LDO, 0xF0, 0x10);
+ 	}
+ 
+ 	if (SND_SOC_DAPM_EVENT_OFF(event)) {
+ 		snd_soc_component_write(comp, WCD9335_RX_BIAS_HPH_RDAC_LDO,
+ 					0x88);
+ 		snd_soc_component_write(comp, WCD9335_HPH_RDAC_LDO_CTL,
+ 					0x33);
+ 		snd_soc_component_update_bits(comp, WCD9335_HPH_PA_CTL2,
+ 				WCD9335_HPH_PA_CTL2_HPH_PSRR_ENH_MASK,
+ 				WCD9335_HPH_PA_CTL2_HPH_PSRR_DISABLE);
+ 		snd_soc_component_update_bits(comp, WCD9335_HPH_PA_CTL2,
+ 				WCD9335_HPH_PA_CTL2_FORCE_PSRREH_MASK,
+ 				WCD9335_HPH_PA_CTL2_FORCE_PSRREH_DISABLE);
+ 		snd_soc_component_update_bits(comp, WCD9335_HPH_PA_CTL2,
+ 				WCD9335_HPH_PA_CTL2_FORCE_IQCTRL_MASK,
+ 				WCD9335_HPH_PA_CTL2_FORCE_IQCTRL_DISABLE);
+ 		snd_soc_component_update_bits(comp, WCD9335_HPH_CNP_WG_CTL,
+ 				WCD9335_HPH_CNP_WG_CTL_CURR_LDIV_MASK,
+ 				WCD9335_HPH_CNP_WG_CTL_CURR_LDIV_RATIO_500);
+ 		snd_soc_component_update_bits(comp, WCD9335_HPH_R_EN,
+ 				WCD9335_HPH_CONST_SEL_L_MASK,
+ 				WCD9335_HPH_CONST_SEL_L_HQ_PATH);
+ 		snd_soc_component_update_bits(comp, WCD9335_HPH_L_EN,
+ 				WCD9335_HPH_CONST_SEL_L_MASK,
+ 				WCD9335_HPH_CONST_SEL_L_HQ_PATH);
+ 	}
+ }
+ 
+ static void wcd9335_codec_hph_hifi_config(struct snd_soc_component *comp,
+ 					int event)
+ {
+ 	if (SND_SOC_DAPM_EVENT_ON(event)) {
+ 		snd_soc_component_update_bits(comp, WCD9335_HPH_CNP_WG_CTL,
+ 				WCD9335_HPH_CNP_WG_CTL_CURR_LDIV_MASK,
+ 				WCD9335_HPH_CNP_WG_CTL_CURR_LDIV_RATIO_1000);
+ 		snd_soc_component_update_bits(comp, WCD9335_HPH_PA_CTL2,
+ 				WCD9335_HPH_PA_CTL2_FORCE_IQCTRL_MASK,
+ 				WCD9335_HPH_PA_CTL2_FORCE_IQCTRL_ENABLE);
+ 		snd_soc_component_update_bits(comp, WCD9335_HPH_PA_CTL1,
+ 				WCD9335_HPH_PA_GM3_IB_SCALE_MASK,
+ 				0x0C);
+ 		wcd9335_codec_hph_mode_gain_opt(comp, 0x11);
+ 	}
+ 
+ 	if (SND_SOC_DAPM_EVENT_OFF(event)) {
+ 		snd_soc_component_update_bits(comp, WCD9335_HPH_PA_CTL2,
+ 			WCD9335_HPH_PA_CTL2_FORCE_IQCTRL_MASK,
+ 			WCD9335_HPH_PA_CTL2_FORCE_IQCTRL_DISABLE);
+ 		snd_soc_component_update_bits(comp, WCD9335_HPH_CNP_WG_CTL,
+ 				WCD9335_HPH_CNP_WG_CTL_CURR_LDIV_MASK,
+ 				WCD9335_HPH_CNP_WG_CTL_CURR_LDIV_RATIO_500);
+ 	}
+ }
+ 
+ static void wcd9335_codec_hph_mode_config(struct snd_soc_component *component,
+ 					  int event, int mode)
+ {
+ 	switch (mode) {
+ 	case CLS_H_LP:
+ 		wcd9335_codec_hph_lp_config(component, event);
+ 		break;
+ 	case CLS_H_LOHIFI:
+ 		wcd9335_codec_hph_lohifi_config(component, event);
+ 		break;
+ 	case CLS_H_HIFI:
+ 		wcd9335_codec_hph_hifi_config(component, event);
+ 		break;
+ 	}
+ }
+ 
+ static int wcd9335_codec_hphl_dac_event(struct snd_soc_dapm_widget *w,
+ 					struct snd_kcontrol *kc,
+ 					int event)
+ {
+ 	struct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);
+ 	struct wcd9335_codec *wcd = dev_get_drvdata(comp->dev);
+ 	int hph_mode = wcd->hph_mode;
+ 	u8 dem_inp;
+ 	int ret = 0;
+ 
+ 	switch (event) {
+ 	case SND_SOC_DAPM_PRE_PMU:
+ 		/* Read DEM INP Select */
+ 		dem_inp = snd_soc_component_read32(comp,
+ 				WCD9335_CDC_RX1_RX_PATH_SEC0) & 0x03;
+ 		if (((hph_mode == CLS_H_HIFI) || (hph_mode == CLS_H_LOHIFI) ||
+ 				(hph_mode == CLS_H_LP)) && (dem_inp != 0x01)) {
+ 			dev_err(comp->dev, "Incorrect DEM Input\n");
+ 			return -EINVAL;
+ 		}
+ 		wcd_clsh_ctrl_set_state(wcd->clsh_ctrl, WCD_CLSH_EVENT_PRE_DAC,
+ 					WCD_CLSH_STATE_HPHL,
+ 					((hph_mode == CLS_H_LOHIFI) ?
+ 					 CLS_H_HIFI : hph_mode));
+ 
+ 		wcd9335_codec_hph_mode_config(comp, event, hph_mode);
+ 
+ 		break;
+ 	case SND_SOC_DAPM_POST_PMU:
+ 		usleep_range(1000, 1100);
+ 		break;
+ 	case SND_SOC_DAPM_PRE_PMD:
+ 		break;
+ 	case SND_SOC_DAPM_POST_PMD:
+ 		/* 1000us required as per HW requirement */
+ 		usleep_range(1000, 1100);
+ 
+ 		if (!(wcd_clsh_ctrl_get_state(wcd->clsh_ctrl) &
+ 				WCD_CLSH_STATE_HPHR))
+ 			wcd9335_codec_hph_mode_config(comp, event, hph_mode);
+ 
+ 		wcd_clsh_ctrl_set_state(wcd->clsh_ctrl, WCD_CLSH_EVENT_POST_PA,
+ 				WCD_CLSH_STATE_HPHL,
+ 				((hph_mode == CLS_H_LOHIFI) ?
+ 				 CLS_H_HIFI : hph_mode));
+ 		break;
+ 	};
+ 
+ 	return ret;
+ }
+ 
+ static int wcd9335_codec_lineout_dac_event(struct snd_soc_dapm_widget *w,
+ 					   struct snd_kcontrol *kc, int event)
+ {
+ 	struct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);
+ 	struct wcd9335_codec *wcd = dev_get_drvdata(comp->dev);
+ 
+ 	switch (event) {
+ 	case SND_SOC_DAPM_PRE_PMU:
+ 		wcd_clsh_ctrl_set_state(wcd->clsh_ctrl, WCD_CLSH_EVENT_PRE_DAC,
+ 					WCD_CLSH_STATE_LO, CLS_AB);
+ 		break;
+ 	case SND_SOC_DAPM_POST_PMD:
+ 		wcd_clsh_ctrl_set_state(wcd->clsh_ctrl, WCD_CLSH_EVENT_POST_PA,
+ 					WCD_CLSH_STATE_LO, CLS_AB);
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int wcd9335_codec_ear_dac_event(struct snd_soc_dapm_widget *w,
+ 				       struct snd_kcontrol *kc, int event)
+ {
+ 	struct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);
+ 	struct wcd9335_codec *wcd = dev_get_drvdata(comp->dev);
+ 	int ret = 0;
+ 
+ 	switch (event) {
+ 	case SND_SOC_DAPM_PRE_PMU:
+ 		wcd_clsh_ctrl_set_state(wcd->clsh_ctrl, WCD_CLSH_EVENT_PRE_DAC,
+ 					WCD_CLSH_STATE_EAR, CLS_H_NORMAL);
+ 
+ 		break;
+ 	case SND_SOC_DAPM_POST_PMD:
+ 		wcd_clsh_ctrl_set_state(wcd->clsh_ctrl, WCD_CLSH_EVENT_POST_PA,
+ 					WCD_CLSH_STATE_EAR, CLS_H_NORMAL);
+ 		break;
+ 	};
+ 
+ 	return ret;
+ }
+ 
+ static void wcd9335_codec_hph_post_pa_config(struct wcd9335_codec *wcd,
+ 					     int mode, int event)
+ {
+ 	u8 scale_val = 0;
+ 
+ 	switch (event) {
+ 	case SND_SOC_DAPM_POST_PMU:
+ 		switch (mode) {
+ 		case CLS_H_HIFI:
+ 			scale_val = 0x3;
+ 			break;
+ 		case CLS_H_LOHIFI:
+ 			scale_val = 0x1;
+ 			break;
+ 		}
+ 		break;
+ 	case SND_SOC_DAPM_PRE_PMD:
+ 		scale_val = 0x6;
+ 		break;
+ 	}
+ 
+ 	if (scale_val)
+ 		snd_soc_component_update_bits(wcd->component,
+ 					WCD9335_HPH_PA_CTL1,
+ 					WCD9335_HPH_PA_GM3_IB_SCALE_MASK,
+ 					scale_val << 1);
+ 	if (SND_SOC_DAPM_EVENT_ON(event)) {
+ 		if (wcd->comp_enabled[COMPANDER_1] ||
+ 		    wcd->comp_enabled[COMPANDER_2]) {
+ 			/* GAIN Source Selection */
+ 			snd_soc_component_update_bits(wcd->component,
+ 					WCD9335_HPH_L_EN,
+ 					WCD9335_HPH_GAIN_SRC_SEL_MASK,
+ 					WCD9335_HPH_GAIN_SRC_SEL_COMPANDER);
+ 			snd_soc_component_update_bits(wcd->component,
+ 					WCD9335_HPH_R_EN,
+ 					WCD9335_HPH_GAIN_SRC_SEL_MASK,
+ 					WCD9335_HPH_GAIN_SRC_SEL_COMPANDER);
+ 			snd_soc_component_update_bits(wcd->component,
+ 					WCD9335_HPH_AUTO_CHOP,
+ 					WCD9335_HPH_AUTO_CHOP_MASK,
+ 					WCD9335_HPH_AUTO_CHOP_FORCE_ENABLE);
+ 		}
+ 		snd_soc_component_update_bits(wcd->component,
+ 						WCD9335_HPH_L_EN,
+ 						WCD9335_HPH_PA_GAIN_MASK,
+ 						wcd->hph_l_gain);
+ 		snd_soc_component_update_bits(wcd->component,
+ 						WCD9335_HPH_R_EN,
+ 						WCD9335_HPH_PA_GAIN_MASK,
+ 						wcd->hph_r_gain);
+ 	}
+ 
+ 	if (SND_SOC_DAPM_EVENT_OFF(event))
+ 		snd_soc_component_update_bits(wcd->component,
+ 				WCD9335_HPH_AUTO_CHOP,
+ 				WCD9335_HPH_AUTO_CHOP_MASK,
+ 				WCD9335_HPH_AUTO_CHOP_ENABLE_BY_CMPDR_GAIN);
+ }
+ 
+ static int wcd9335_codec_hphr_dac_event(struct snd_soc_dapm_widget *w,
+ 				      struct snd_kcontrol *kc,
+ 				      int event)
+ {
+ 	struct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);
+ 	struct wcd9335_codec *wcd = dev_get_drvdata(comp->dev);
+ 	int hph_mode = wcd->hph_mode;
+ 	u8 dem_inp;
+ 	int ret = 0;
+ 
+ 	switch (event) {
+ 	case SND_SOC_DAPM_PRE_PMU:
+ 
+ 		/* Read DEM INP Select */
+ 		dem_inp = snd_soc_component_read32(comp,
+ 				WCD9335_CDC_RX2_RX_PATH_SEC0) &
+ 				WCD9335_CDC_RX_PATH_DEM_INP_SEL_MASK;
+ 		if (((hph_mode == CLS_H_HIFI) || (hph_mode == CLS_H_LOHIFI) ||
+ 		     (hph_mode == CLS_H_LP)) && (dem_inp != 0x01)) {
+ 			dev_err(comp->dev, "DEM Input not set correctly, hph_mode: %d\n",
+ 				hph_mode);
+ 			return -EINVAL;
+ 		}
+ 
+ 		wcd_clsh_ctrl_set_state(wcd->clsh_ctrl,
+ 			     WCD_CLSH_EVENT_PRE_DAC,
+ 			     WCD_CLSH_STATE_HPHR,
+ 			     ((hph_mode == CLS_H_LOHIFI) ?
+ 			       CLS_H_HIFI : hph_mode));
+ 
+ 		wcd9335_codec_hph_mode_config(comp, event, hph_mode);
+ 
+ 		break;
+ 	case SND_SOC_DAPM_POST_PMD:
+ 		/* 1000us required as per HW requirement */
+ 		usleep_range(1000, 1100);
+ 
+ 		if (!(wcd_clsh_ctrl_get_state(wcd->clsh_ctrl) &
+ 					WCD_CLSH_STATE_HPHL))
+ 			wcd9335_codec_hph_mode_config(comp, event, hph_mode);
+ 
+ 		wcd_clsh_ctrl_set_state(wcd->clsh_ctrl, WCD_CLSH_EVENT_POST_PA,
+ 			     WCD_CLSH_STATE_HPHR, ((hph_mode == CLS_H_LOHIFI) ?
+ 						CLS_H_HIFI : hph_mode));
+ 		break;
+ 	};
+ 
+ 	return ret;
+ }
+ 
+ static int wcd9335_codec_enable_hphl_pa(struct snd_soc_dapm_widget *w,
+ 				      struct snd_kcontrol *kc,
+ 				      int event)
+ {
+ 	struct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);
+ 	struct wcd9335_codec *wcd = dev_get_drvdata(comp->dev);
+ 	int hph_mode = wcd->hph_mode;
+ 	int ret = 0;
+ 
+ 	switch (event) {
+ 	case SND_SOC_DAPM_PRE_PMU:
+ 		break;
+ 	case SND_SOC_DAPM_POST_PMU:
+ 		/*
+ 		 * 7ms sleep is required after PA is enabled as per
+ 		 * HW requirement
+ 		 */
+ 		usleep_range(7000, 7100);
+ 
+ 		wcd9335_codec_hph_post_pa_config(wcd, hph_mode, event);
+ 		snd_soc_component_update_bits(comp,
+ 					WCD9335_CDC_RX1_RX_PATH_CTL,
+ 					WCD9335_CDC_RX_PGA_MUTE_EN_MASK,
+ 					WCD9335_CDC_RX_PGA_MUTE_DISABLE);
+ 
+ 		/* Remove mix path mute if it is enabled */
+ 		if ((snd_soc_component_read32(comp,
+ 					WCD9335_CDC_RX1_RX_PATH_MIX_CTL)) &
+ 					WCD9335_CDC_RX_PGA_MUTE_EN_MASK)
+ 			snd_soc_component_update_bits(comp,
+ 					    WCD9335_CDC_RX1_RX_PATH_MIX_CTL,
+ 					    WCD9335_CDC_RX_PGA_MUTE_EN_MASK,
+ 					    WCD9335_CDC_RX_PGA_MUTE_DISABLE);
+ 
+ 		break;
+ 	case SND_SOC_DAPM_PRE_PMD:
+ 		wcd9335_codec_hph_post_pa_config(wcd, hph_mode, event);
+ 		break;
+ 	case SND_SOC_DAPM_POST_PMD:
+ 		/* 5ms sleep is required after PA is disabled as per
+ 		 * HW requirement
+ 		 */
+ 		usleep_range(5000, 5500);
+ 		break;
+ 	};
+ 
+ 	return ret;
+ }
+ 
+ static int wcd9335_codec_enable_lineout_pa(struct snd_soc_dapm_widget *w,
+ 					 struct snd_kcontrol *kc,
+ 					 int event)
+ {
+ 	struct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);
+ 	int vol_reg = 0, mix_vol_reg = 0;
+ 	int ret = 0;
+ 
+ 	if (w->reg == WCD9335_ANA_LO_1_2) {
+ 		if (w->shift == 7) {
+ 			vol_reg = WCD9335_CDC_RX3_RX_PATH_CTL;
+ 			mix_vol_reg = WCD9335_CDC_RX3_RX_PATH_MIX_CTL;
+ 		} else if (w->shift == 6) {
+ 			vol_reg = WCD9335_CDC_RX4_RX_PATH_CTL;
+ 			mix_vol_reg = WCD9335_CDC_RX4_RX_PATH_MIX_CTL;
+ 		}
+ 	} else if (w->reg == WCD9335_ANA_LO_3_4) {
+ 		if (w->shift == 7) {
+ 			vol_reg = WCD9335_CDC_RX5_RX_PATH_CTL;
+ 			mix_vol_reg = WCD9335_CDC_RX5_RX_PATH_MIX_CTL;
+ 		} else if (w->shift == 6) {
+ 			vol_reg = WCD9335_CDC_RX6_RX_PATH_CTL;
+ 			mix_vol_reg = WCD9335_CDC_RX6_RX_PATH_MIX_CTL;
+ 		}
+ 	} else {
+ 		dev_err(comp->dev, "Error enabling lineout PA\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	switch (event) {
+ 	case SND_SOC_DAPM_POST_PMU:
+ 		/* 5ms sleep is required after PA is enabled as per
+ 		 * HW requirement
+ 		 */
+ 		usleep_range(5000, 5500);
+ 		snd_soc_component_update_bits(comp, vol_reg,
+ 					WCD9335_CDC_RX_PGA_MUTE_EN_MASK,
+ 					WCD9335_CDC_RX_PGA_MUTE_DISABLE);
+ 
+ 		/* Remove mix path mute if it is enabled */
+ 		if ((snd_soc_component_read32(comp, mix_vol_reg)) &
+ 					WCD9335_CDC_RX_PGA_MUTE_EN_MASK)
+ 			snd_soc_component_update_bits(comp,  mix_vol_reg,
+ 					WCD9335_CDC_RX_PGA_MUTE_EN_MASK,
+ 					WCD9335_CDC_RX_PGA_MUTE_DISABLE);
+ 		break;
+ 	case SND_SOC_DAPM_POST_PMD:
+ 		/* 5ms sleep is required after PA is disabled as per
+ 		 * HW requirement
+ 		 */
+ 		usleep_range(5000, 5500);
+ 		break;
+ 	};
+ 
+ 	return ret;
+ }
+ 
+ static void wcd9335_codec_init_flyback(struct snd_soc_component *component)
+ {
+ 	snd_soc_component_update_bits(component, WCD9335_HPH_L_EN,
+ 					WCD9335_HPH_CONST_SEL_L_MASK,
+ 					WCD9335_HPH_CONST_SEL_L_BYPASS);
+ 	snd_soc_component_update_bits(component, WCD9335_HPH_R_EN,
+ 					WCD9335_HPH_CONST_SEL_L_MASK,
+ 					WCD9335_HPH_CONST_SEL_L_BYPASS);
+ 	snd_soc_component_update_bits(component, WCD9335_RX_BIAS_FLYB_BUFF,
+ 					WCD9335_RX_BIAS_FLYB_VPOS_5_UA_MASK,
+ 					WCD9335_RX_BIAS_FLYB_I_0P0_UA);
+ 	snd_soc_component_update_bits(component, WCD9335_RX_BIAS_FLYB_BUFF,
+ 					WCD9335_RX_BIAS_FLYB_VNEG_5_UA_MASK,
+ 					WCD9335_RX_BIAS_FLYB_I_0P0_UA);
+ }
+ 
+ static int wcd9335_codec_enable_rx_bias(struct snd_soc_dapm_widget *w,
+ 		struct snd_kcontrol *kc, int event)
+ {
+ 	struct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);
+ 	struct wcd9335_codec *wcd = dev_get_drvdata(comp->dev);
+ 
+ 	switch (event) {
+ 	case SND_SOC_DAPM_PRE_PMU:
+ 		wcd->rx_bias_count++;
+ 		if (wcd->rx_bias_count == 1) {
+ 			wcd9335_codec_init_flyback(comp);
+ 			snd_soc_component_update_bits(comp,
+ 						WCD9335_ANA_RX_SUPPLIES,
+ 						WCD9335_ANA_RX_BIAS_ENABLE_MASK,
+ 						WCD9335_ANA_RX_BIAS_ENABLE);
+ 		}
+ 		break;
+ 	case SND_SOC_DAPM_POST_PMD:
+ 		wcd->rx_bias_count--;
+ 		if (!wcd->rx_bias_count)
+ 			snd_soc_component_update_bits(comp,
+ 					WCD9335_ANA_RX_SUPPLIES,
+ 					WCD9335_ANA_RX_BIAS_ENABLE_MASK,
+ 					WCD9335_ANA_RX_BIAS_DISABLE);
+ 		break;
+ 	};
+ 
+ 	return 0;
+ }
+ 
+ static int wcd9335_codec_enable_hphr_pa(struct snd_soc_dapm_widget *w,
+ 					struct snd_kcontrol *kc, int event)
+ {
+ 	struct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);
+ 	struct wcd9335_codec *wcd = dev_get_drvdata(comp->dev);
+ 	int hph_mode = wcd->hph_mode;
+ 	int ret = 0;
+ 
+ 	switch (event) {
+ 	case SND_SOC_DAPM_PRE_PMU:
+ 		break;
+ 	case SND_SOC_DAPM_POST_PMU:
+ 		/*
+ 		 * 7ms sleep is required after PA is enabled as per
+ 		 * HW requirement
+ 		 */
+ 		usleep_range(7000, 7100);
+ 		wcd9335_codec_hph_post_pa_config(wcd, hph_mode, event);
+ 		snd_soc_component_update_bits(comp,
+ 					WCD9335_CDC_RX2_RX_PATH_CTL,
+ 					WCD9335_CDC_RX_PGA_MUTE_EN_MASK,
+ 					WCD9335_CDC_RX_PGA_MUTE_DISABLE);
+ 		/* Remove mix path mute if it is enabled */
+ 		if ((snd_soc_component_read32(comp,
+ 					WCD9335_CDC_RX2_RX_PATH_MIX_CTL)) &
+ 					WCD9335_CDC_RX_PGA_MUTE_EN_MASK)
+ 			snd_soc_component_update_bits(comp,
+ 					WCD9335_CDC_RX2_RX_PATH_MIX_CTL,
+ 					WCD9335_CDC_RX_PGA_MUTE_EN_MASK,
+ 					WCD9335_CDC_RX_PGA_MUTE_DISABLE);
+ 
+ 		break;
+ 
+ 	case SND_SOC_DAPM_PRE_PMD:
+ 		wcd9335_codec_hph_post_pa_config(wcd, hph_mode, event);
+ 		break;
+ 	case SND_SOC_DAPM_POST_PMD:
+ 		/* 5ms sleep is required after PA is disabled as per
+ 		 * HW requirement
+ 		 */
+ 		usleep_range(5000, 5500);
+ 		break;
+ 	};
+ 
+ 	return ret;
+ }
+ 
+ static int wcd9335_codec_enable_ear_pa(struct snd_soc_dapm_widget *w,
+ 				       struct snd_kcontrol *kc, int event)
+ {
+ 	struct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);
+ 	int ret = 0;
+ 
+ 	switch (event) {
+ 	case SND_SOC_DAPM_POST_PMU:
+ 		/* 5ms sleep is required after PA is enabled as per
+ 		 * HW requirement
+ 		 */
+ 		usleep_range(5000, 5500);
+ 		snd_soc_component_update_bits(comp,
+ 					WCD9335_CDC_RX0_RX_PATH_CTL,
+ 					WCD9335_CDC_RX_PGA_MUTE_EN_MASK,
+ 					WCD9335_CDC_RX_PGA_MUTE_DISABLE);
+ 		/* Remove mix path mute if it is enabled */
+ 		if ((snd_soc_component_read32(comp,
+ 					WCD9335_CDC_RX0_RX_PATH_MIX_CTL)) &
+ 					WCD9335_CDC_RX_PGA_MUTE_EN_MASK)
+ 			snd_soc_component_update_bits(comp,
+ 					WCD9335_CDC_RX0_RX_PATH_MIX_CTL,
+ 					WCD9335_CDC_RX_PGA_MUTE_EN_MASK,
+ 					WCD9335_CDC_RX_PGA_MUTE_DISABLE);
+ 		break;
+ 	case SND_SOC_DAPM_POST_PMD:
+ 		/* 5ms sleep is required after PA is disabled as per
+ 		 * HW requirement
+ 		 */
+ 		usleep_range(5000, 5500);
+ 
+ 		break;
+ 	};
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> 93f97ff1911a (ASoC: wcd9335: add audio routings)
  static irqreturn_t wcd9335_slimbus_irq(int irq, void *data)
  {
  	struct wcd9335_codec *wcd = data;
@@@ -1119,13 -4910,249 +2983,22 @@@ static const struct snd_soc_component_d
  	.probe = wcd9335_codec_probe,
  	.remove = wcd9335_codec_remove,
  	.set_sysclk = wcd9335_codec_set_sysclk,
++<<<<<<< HEAD
++=======
+ 	.controls = wcd9335_snd_controls,
+ 	.num_controls = ARRAY_SIZE(wcd9335_snd_controls),
+ 	.dapm_widgets = wcd9335_dapm_widgets,
+ 	.num_dapm_widgets = ARRAY_SIZE(wcd9335_dapm_widgets),
+ 	.dapm_routes = wcd9335_audio_map,
+ 	.num_dapm_routes = ARRAY_SIZE(wcd9335_audio_map),
++>>>>>>> 93f97ff1911a (ASoC: wcd9335: add audio routings)
  };
  
 -static int wcd9335_probe(struct wcd9335_codec *wcd)
 -{
 -	struct device *dev = wcd->dev;
 -
 -	memcpy(wcd->rx_chs, wcd9335_rx_chs, sizeof(wcd9335_rx_chs));
 -	memcpy(wcd->tx_chs, wcd9335_tx_chs, sizeof(wcd9335_tx_chs));
 -
 -	wcd->sido_input_src = SIDO_SOURCE_INTERNAL;
 -	wcd->sido_voltage = SIDO_VOLTAGE_NOMINAL_MV;
 -
 -	return devm_snd_soc_register_component(dev, &wcd9335_component_drv,
 -					       wcd9335_slim_dais,
 -					       ARRAY_SIZE(wcd9335_slim_dais));
 -}
 -
 -static const struct regmap_range_cfg wcd9335_ranges[] = {
 -	{
 -		.name = "WCD9335",
 -		.range_min =  0x0,
 -		.range_max =  WCD9335_MAX_REGISTER,
 -		.selector_reg = WCD9335_REG(0x0, 0),
 -		.selector_mask = 0xff,
 -		.selector_shift = 0,
 -		.window_start = 0x0,
 -		.window_len = 0x1000,
 -	},
 -};
 -
 -static bool wcd9335_is_volatile_register(struct device *dev, unsigned int reg)
 -{
 -	switch (reg) {
 -	case WCD9335_INTR_PIN1_STATUS0...WCD9335_INTR_PIN2_CLEAR3:
 -	case WCD9335_ANA_MBHC_RESULT_3:
 -	case WCD9335_ANA_MBHC_RESULT_2:
 -	case WCD9335_ANA_MBHC_RESULT_1:
 -	case WCD9335_ANA_MBHC_MECH:
 -	case WCD9335_ANA_MBHC_ELECT:
 -	case WCD9335_ANA_MBHC_ZDET:
 -	case WCD9335_ANA_MICB2:
 -	case WCD9335_ANA_RCO:
 -	case WCD9335_ANA_BIAS:
 -		return true;
 -	default:
 -		return false;
 -	}
 -}
 -
 -static struct regmap_config wcd9335_regmap_config = {
 -	.reg_bits = 16,
 -	.val_bits = 8,
 -	.cache_type = REGCACHE_RBTREE,
 -	.max_register = WCD9335_MAX_REGISTER,
 -	.can_multi_write = true,
 -	.ranges = wcd9335_ranges,
 -	.num_ranges = ARRAY_SIZE(wcd9335_ranges),
 -	.volatile_reg = wcd9335_is_volatile_register,
 -};
 -
 -static const struct regmap_range_cfg wcd9335_ifc_ranges[] = {
 -	{
 -		.name = "WCD9335-IFC-DEV",
 -		.range_min =  0x0,
 -		.range_max = WCD9335_REG(0, 0x7ff),
 -		.selector_reg = WCD9335_REG(0, 0x0),
 -		.selector_mask = 0xff,
 -		.selector_shift = 0,
 -		.window_start = 0x0,
 -		.window_len = 0x1000,
 -	},
 -};
 -
 -static struct regmap_config wcd9335_ifc_regmap_config = {
 -	.reg_bits = 16,
 -	.val_bits = 8,
 -	.can_multi_write = true,
 -	.max_register = WCD9335_REG(0, 0x7FF),
 -	.ranges = wcd9335_ifc_ranges,
 -	.num_ranges = ARRAY_SIZE(wcd9335_ifc_ranges),
 -};
 -
 -static const struct regmap_irq wcd9335_codec_irqs[] = {
 -	/* INTR_REG 0 */
 -	[WCD9335_IRQ_SLIMBUS] = {
 -		.reg_offset = 0,
 -		.mask = BIT(0),
 -		.type = {
 -			.type_reg_offset = 0,
 -			.types_supported = IRQ_TYPE_EDGE_BOTH,
 -			.type_reg_mask	= BIT(0),
 -		},
 -	},
 -};
 -
 -static const struct regmap_irq_chip wcd9335_regmap_irq1_chip = {
 -	.name = "wcd9335_pin1_irq",
 -	.status_base = WCD9335_INTR_PIN1_STATUS0,
 -	.mask_base = WCD9335_INTR_PIN1_MASK0,
 -	.ack_base = WCD9335_INTR_PIN1_CLEAR0,
 -	.type_base = WCD9335_INTR_LEVEL0,
 -	.num_type_reg = 4,
 -	.num_regs = 4,
 -	.irqs = wcd9335_codec_irqs,
 -	.num_irqs = ARRAY_SIZE(wcd9335_codec_irqs),
 -};
 -
 -static int wcd9335_parse_dt(struct wcd9335_codec *wcd)
 -{
 -	struct device *dev = wcd->dev;
 -	struct device_node *np = dev->of_node;
 -	int ret;
 -
 -	wcd->reset_gpio = of_get_named_gpio(np,	"reset-gpios", 0);
 -	if (wcd->reset_gpio < 0) {
 -		dev_err(dev, "Reset GPIO missing from DT\n");
 -		return wcd->reset_gpio;
 -	}
 -
 -	wcd->mclk = devm_clk_get(dev, "mclk");
 -	if (IS_ERR(wcd->mclk)) {
 -		dev_err(dev, "mclk not found\n");
 -		return PTR_ERR(wcd->mclk);
 -	}
 -
 -	wcd->native_clk = devm_clk_get(dev, "slimbus");
 -	if (IS_ERR(wcd->native_clk)) {
 -		dev_err(dev, "slimbus clock not found\n");
 -		return PTR_ERR(wcd->native_clk);
 -	}
 -
 -	wcd->supplies[0].supply = "vdd-buck";
 -	wcd->supplies[1].supply = "vdd-buck-sido";
 -	wcd->supplies[2].supply = "vdd-tx";
 -	wcd->supplies[3].supply = "vdd-rx";
 -	wcd->supplies[4].supply = "vdd-io";
 -
 -	ret = regulator_bulk_get(dev, WCD9335_MAX_SUPPLY, wcd->supplies);
 -	if (ret) {
 -		dev_err(dev, "Failed to get supplies: err = %d\n", ret);
 -		return ret;
 -	}
 -
 -	return 0;
 -}
 -
 -static int wcd9335_power_on_reset(struct wcd9335_codec *wcd)
 -{
 -	struct device *dev = wcd->dev;
 -	int ret;
 -
 -	ret = regulator_bulk_enable(WCD9335_MAX_SUPPLY, wcd->supplies);
 -	if (ret) {
 -		dev_err(dev, "Failed to get supplies: err = %d\n", ret);
 -		return ret;
 -	}
 -
 -	/*
 -	 * For WCD9335, it takes about 600us for the Vout_A and
 -	 * Vout_D to be ready after BUCK_SIDO is powered up.
 -	 * SYS_RST_N shouldn't be pulled high during this time
 -	 * Toggle the reset line to make sure the reset pulse is
 -	 * correctly applied
 -	 */
 -	usleep_range(600, 650);
 -
 -	gpio_direction_output(wcd->reset_gpio, 0);
 -	msleep(20);
 -	gpio_set_value(wcd->reset_gpio, 1);
 -	msleep(20);
 -
 -	return 0;
 -}
 -
 -static int wcd9335_bring_up(struct wcd9335_codec *wcd)
 -{
 -	struct regmap *rm = wcd->regmap;
 -	int val, byte0;
 -
 -	regmap_read(rm, WCD9335_CHIP_TIER_CTRL_EFUSE_VAL_OUT0, &val);
 -	regmap_read(rm, WCD9335_CHIP_TIER_CTRL_CHIP_ID_BYTE0, &byte0);
 -
 -	if ((val < 0) || (byte0 < 0)) {
 -		dev_err(wcd->dev, "WCD9335 CODEC version detection fail!\n");
 -		return -EINVAL;
 -	}
 -
 -	if (byte0 == 0x1) {
 -		dev_info(wcd->dev, "WCD9335 CODEC version is v2.0\n");
 -		wcd->version = WCD9335_VERSION_2_0;
 -		regmap_write(rm, WCD9335_CODEC_RPM_RST_CTL, 0x01);
 -		regmap_write(rm, WCD9335_SIDO_SIDO_TEST_2, 0x00);
 -		regmap_write(rm, WCD9335_SIDO_SIDO_CCL_8, 0x6F);
 -		regmap_write(rm, WCD9335_BIAS_VBG_FINE_ADJ, 0x65);
 -		regmap_write(rm, WCD9335_CODEC_RPM_PWR_CDC_DIG_HM_CTL, 0x5);
 -		regmap_write(rm, WCD9335_CODEC_RPM_PWR_CDC_DIG_HM_CTL, 0x7);
 -		regmap_write(rm, WCD9335_CODEC_RPM_PWR_CDC_DIG_HM_CTL, 0x3);
 -		regmap_write(rm, WCD9335_CODEC_RPM_RST_CTL, 0x3);
 -	} else {
 -		dev_err(wcd->dev, "WCD9335 CODEC version not supported\n");
 -		return -EINVAL;
 -	}
 -
 -	return 0;
 -}
 -
 -static int wcd9335_irq_init(struct wcd9335_codec *wcd)
 -{
 -	int ret;
 -
 -	/*
 -	 * INTR1 consists of all possible interrupt sources Ear OCP,
 -	 * HPH OCP, MBHC, MAD, VBAT, and SVA
 -	 * INTR2 is a subset of first interrupt sources MAD, VBAT, and SVA
 -	 */
 -	wcd->intr1 = of_irq_get_byname(wcd->dev->of_node, "intr1");
 -	if (wcd->intr1 < 0) {
 -		if (wcd->intr1 != -EPROBE_DEFER)
 -			dev_err(wcd->dev, "Unable to configure IRQ\n");
 -
 -		return wcd->intr1;
 -	}
 -
 -	ret = devm_regmap_add_irq_chip(wcd->dev, wcd->regmap, wcd->intr1,
 -				 IRQF_TRIGGER_HIGH, 0,
 -				 &wcd9335_regmap_irq1_chip, &wcd->irq_data);
 -	if (ret)
 -		dev_err(wcd->dev, "Failed to register IRQ chip: %d\n", ret);
 -
 -	return ret;
 -}
 -
 -static int wcd9335_slim_probe(struct slim_device *slim)
 +static int wcd9335_probe(struct platform_device *pdev)
  {
 -	struct device *dev = &slim->dev;
 +	struct wcd9335 *pdata = dev_get_drvdata(pdev->dev.parent);
 +	struct device *dev = &pdev->dev;
  	struct wcd9335_codec *wcd;
 -	int ret;
  
  	wcd = devm_kzalloc(dev, sizeof(*wcd), GFP_KERNEL);
  	if (!wcd)
* Unmerged path sound/soc/codecs/wcd9335.c
