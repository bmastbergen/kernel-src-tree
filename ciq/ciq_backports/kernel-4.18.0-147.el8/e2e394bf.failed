drm/i915/selftests: Add mock selftest for remapped vmas

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit e2e394bffa19365aa86eb898f6225919d02d6b6c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/e2e394bf.failed

Extend the rotated vma mock selftest to cover remapped vmas as
well.

TODO: reindent the loops I guess? Left like this for now to
ease review

v2: Include the vma type in the error message (Chris)
v3: Deal with trimmed sg
v4: Drop leftover debugs

	Cc: Chris Wilson <chris@chris-wilson.co.uk>
	Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190509122159.24376-3-ville.syrjala@linux.intel.com
	Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
(cherry picked from commit e2e394bffa19365aa86eb898f6225919d02d6b6c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/selftests/i915_vma.c
diff --cc drivers/gpu/drm/i915/selftests/i915_vma.c
index e90f97236e50,89f6ef945c1b..000000000000
--- a/drivers/gpu/drm/i915/selftests/i915_vma.c
+++ b/drivers/gpu/drm/i915/selftests/i915_vma.c
@@@ -396,18 -397,79 +396,84 @@@ assert_rotated(struct drm_i915_gem_obje
  	return sg;
  }
  
++<<<<<<< HEAD
 +static unsigned int rotated_size(const struct intel_rotation_plane_info *a,
 +				 const struct intel_rotation_plane_info *b)
++=======
+ static unsigned long remapped_index(const struct intel_remapped_info *r,
+ 				    unsigned int n,
+ 				    unsigned int x,
+ 				    unsigned int y)
+ {
+ 	return (r->plane[n].stride * y +
+ 		r->plane[n].offset + x);
+ }
+ 
+ static struct scatterlist *
+ assert_remapped(struct drm_i915_gem_object *obj,
+ 		const struct intel_remapped_info *r, unsigned int n,
+ 		struct scatterlist *sg)
+ {
+ 	unsigned int x, y;
+ 	unsigned int left = 0;
+ 	unsigned int offset;
+ 
+ 	for (y = 0; y < r->plane[n].height; y++) {
+ 		for (x = 0; x < r->plane[n].width; x++) {
+ 			unsigned long src_idx;
+ 			dma_addr_t src;
+ 
+ 			if (!sg) {
+ 				pr_err("Invalid sg table: too short at plane %d, (%d, %d)!\n",
+ 				       n, x, y);
+ 				return ERR_PTR(-EINVAL);
+ 			}
+ 			if (!left) {
+ 				offset = 0;
+ 				left = sg_dma_len(sg);
+ 			}
+ 
+ 			src_idx = remapped_index(r, n, x, y);
+ 			src = i915_gem_object_get_dma_address(obj, src_idx);
+ 
+ 			if (left < PAGE_SIZE || left & (PAGE_SIZE-1)) {
+ 				pr_err("Invalid sg.length, found %d, expected %lu for remapped page (%d, %d) [src index %lu]\n",
+ 				       sg_dma_len(sg), PAGE_SIZE,
+ 				       x, y, src_idx);
+ 				return ERR_PTR(-EINVAL);
+ 			}
+ 
+ 			if (sg_dma_address(sg) + offset != src) {
+ 				pr_err("Invalid address for remapped page (%d, %d) [src index %lu]\n",
+ 				       x, y, src_idx);
+ 				return ERR_PTR(-EINVAL);
+ 			}
+ 
+ 			left -= PAGE_SIZE;
+ 			offset += PAGE_SIZE;
+ 
+ 
+ 			if (!left)
+ 				sg = sg_next(sg);
+ 		}
+ 	}
+ 
+ 	return sg;
+ }
+ 
+ static unsigned int rotated_size(const struct intel_remapped_plane_info *a,
+ 				 const struct intel_remapped_plane_info *b)
++>>>>>>> e2e394bffa19 (drm/i915/selftests: Add mock selftest for remapped vmas)
  {
  	return a->width * a->height + b->width * b->height;
  }
  
- static int igt_vma_rotate(void *arg)
+ static int igt_vma_rotate_remap(void *arg)
  {
 -	struct i915_ggtt *ggtt = arg;
 -	struct i915_address_space *vm = &ggtt->vm;
 +	struct drm_i915_private *i915 = arg;
 +	struct i915_address_space *vm = &i915->ggtt.base;
  	struct drm_i915_gem_object *obj;
 -	const struct intel_remapped_plane_info planes[] = {
 +	const struct intel_rotation_plane_info planes[] = {
  		{ .width = 1, .height = 1, .stride = 1 },
  		{ .width = 2, .height = 2, .stride = 2 },
  		{ .width = 4, .height = 4, .stride = 4 },
* Unmerged path drivers/gpu/drm/i915/selftests/i915_vma.c
