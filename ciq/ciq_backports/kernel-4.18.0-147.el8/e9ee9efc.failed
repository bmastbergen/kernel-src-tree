bpf: Add BPF_F_ANY_ALIGNMENT.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [tools] bpf: Add BPF_F_ANY_ALIGNMENT (Yauheni Kaliuta) [1700846]
Rebuild_FUZZ: 98.25%
commit-author David Miller <davem@davemloft.net>
commit e9ee9efc0d176512cdce9d27ff8549d7ffa2bfcd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/e9ee9efc.failed

Often we want to write tests cases that check things like bad context
offset accesses.  And one way to do this is to use an odd offset on,
for example, a 32-bit load.

This unfortunately triggers the alignment checks first on platforms
that do not set CONFIG_EFFICIENT_UNALIGNED_ACCESS.  So the test
case see the alignment failure rather than what it was testing for.

It is often not completely possible to respect the original intention
of the test, or even test the same exact thing, while solving the
alignment issue.

Another option could have been to check the alignment after the
context and other validations are performed by the verifier, but
that is a non-trivial change to the verifier.

	Signed-off-by: David S. Miller <davem@davemloft.net>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit e9ee9efc0d176512cdce9d27ff8549d7ffa2bfcd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/bpf.h
diff --cc tools/lib/bpf/bpf.h
index c0ddff373cbd,60392b70587c..000000000000
--- a/tools/lib/bpf/bpf.h
+++ b/tools/lib/bpf/bpf.h
@@@ -78,44 -89,56 +78,60 @@@ struct bpf_load_program_attr 
  
  /* Recommend log buffer size */
  #define BPF_LOG_BUF_SIZE (256 * 1024)
++<<<<<<< HEAD
 +int bpf_load_program_xattr(const struct bpf_load_program_attr *load_attr,
 +			   char *log_buf, size_t log_buf_sz);
 +int bpf_load_program(enum bpf_prog_type type, const struct bpf_insn *insns,
 +		     size_t insns_cnt, const char *license,
 +		     __u32 kern_version, char *log_buf,
 +		     size_t log_buf_sz);
 +int bpf_verify_program(enum bpf_prog_type type, const struct bpf_insn *insns,
 +		       size_t insns_cnt, int strict_alignment,
 +		       const char *license, __u32 kern_version,
 +		       char *log_buf, size_t log_buf_sz, int log_level);
++=======
+ LIBBPF_API int
+ bpf_load_program_xattr(const struct bpf_load_program_attr *load_attr,
+ 		       char *log_buf, size_t log_buf_sz);
+ LIBBPF_API int bpf_load_program(enum bpf_prog_type type,
+ 				const struct bpf_insn *insns, size_t insns_cnt,
+ 				const char *license, __u32 kern_version,
+ 				char *log_buf, size_t log_buf_sz);
+ LIBBPF_API int bpf_verify_program(enum bpf_prog_type type,
+ 				  const struct bpf_insn *insns,
+ 				  size_t insns_cnt, __u32 prog_flags,
+ 				  const char *license, __u32 kern_version,
+ 				  char *log_buf, size_t log_buf_sz,
+ 				  int log_level);
++>>>>>>> e9ee9efc0d17 (bpf: Add BPF_F_ANY_ALIGNMENT.)
  
 -LIBBPF_API int bpf_map_update_elem(int fd, const void *key, const void *value,
 -				   __u64 flags);
 -
 -LIBBPF_API int bpf_map_lookup_elem(int fd, const void *key, void *value);
 -LIBBPF_API int bpf_map_lookup_and_delete_elem(int fd, const void *key,
 -					      void *value);
 -LIBBPF_API int bpf_map_delete_elem(int fd, const void *key);
 -LIBBPF_API int bpf_map_get_next_key(int fd, const void *key, void *next_key);
 -LIBBPF_API int bpf_obj_pin(int fd, const char *pathname);
 -LIBBPF_API int bpf_obj_get(const char *pathname);
 -LIBBPF_API int bpf_prog_attach(int prog_fd, int attachable_fd,
 -			       enum bpf_attach_type type, unsigned int flags);
 -LIBBPF_API int bpf_prog_detach(int attachable_fd, enum bpf_attach_type type);
 -LIBBPF_API int bpf_prog_detach2(int prog_fd, int attachable_fd,
 -				enum bpf_attach_type type);
 -LIBBPF_API int bpf_prog_test_run(int prog_fd, int repeat, void *data,
 -				 __u32 size, void *data_out, __u32 *size_out,
 -				 __u32 *retval, __u32 *duration);
 -LIBBPF_API int bpf_prog_get_next_id(__u32 start_id, __u32 *next_id);
 -LIBBPF_API int bpf_map_get_next_id(__u32 start_id, __u32 *next_id);
 -LIBBPF_API int bpf_prog_get_fd_by_id(__u32 id);
 -LIBBPF_API int bpf_map_get_fd_by_id(__u32 id);
 -LIBBPF_API int bpf_btf_get_fd_by_id(__u32 id);
 -LIBBPF_API int bpf_obj_get_info_by_fd(int prog_fd, void *info, __u32 *info_len);
 -LIBBPF_API int bpf_prog_query(int target_fd, enum bpf_attach_type type,
 -			      __u32 query_flags, __u32 *attach_flags,
 -			      __u32 *prog_ids, __u32 *prog_cnt);
 -LIBBPF_API int bpf_raw_tracepoint_open(const char *name, int prog_fd);
 -LIBBPF_API int bpf_load_btf(void *btf, __u32 btf_size, char *log_buf,
 -			    __u32 log_buf_size, bool do_log);
 -LIBBPF_API int bpf_task_fd_query(int pid, int fd, __u32 flags, char *buf,
 -				 __u32 *buf_len, __u32 *prog_id, __u32 *fd_type,
 -				 __u64 *probe_offset, __u64 *probe_addr);
 +int bpf_map_update_elem(int fd, const void *key, const void *value,
 +			__u64 flags);
  
 -#ifdef __cplusplus
 -} /* extern "C" */
 +int bpf_map_lookup_elem(int fd, const void *key, void *value);
 +int bpf_map_delete_elem(int fd, const void *key);
 +int bpf_map_get_next_key(int fd, const void *key, void *next_key);
 +int bpf_obj_pin(int fd, const char *pathname);
 +int bpf_obj_get(const char *pathname);
 +int bpf_prog_attach(int prog_fd, int attachable_fd, enum bpf_attach_type type,
 +		    unsigned int flags);
 +int bpf_prog_detach(int attachable_fd, enum bpf_attach_type type);
 +int bpf_prog_detach2(int prog_fd, int attachable_fd, enum bpf_attach_type type);
 +int bpf_prog_test_run(int prog_fd, int repeat, void *data, __u32 size,
 +		      void *data_out, __u32 *size_out, __u32 *retval,
 +		      __u32 *duration);
 +int bpf_prog_get_next_id(__u32 start_id, __u32 *next_id);
 +int bpf_map_get_next_id(__u32 start_id, __u32 *next_id);
 +int bpf_prog_get_fd_by_id(__u32 id);
 +int bpf_map_get_fd_by_id(__u32 id);
 +int bpf_btf_get_fd_by_id(__u32 id);
 +int bpf_obj_get_info_by_fd(int prog_fd, void *info, __u32 *info_len);
 +int bpf_prog_query(int target_fd, enum bpf_attach_type type, __u32 query_flags,
 +		   __u32 *attach_flags, __u32 *prog_ids, __u32 *prog_cnt);
 +int bpf_raw_tracepoint_open(const char *name, int prog_fd);
 +int bpf_load_btf(void *btf, __u32 btf_size, char *log_buf, __u32 log_buf_size,
 +		 bool do_log);
 +int bpf_task_fd_query(int pid, int fd, __u32 flags, char *buf, __u32 *buf_len,
 +		      __u32 *prog_id, __u32 *fd_type, __u64 *probe_offset,
 +		      __u64 *probe_addr);
  #endif
 -
 -#endif /* __LIBBPF_BPF_H */
diff --git a/include/uapi/linux/bpf.h b/include/uapi/linux/bpf.h
index 2293d9a9b442..0586a648da6d 100644
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@ -227,6 +227,20 @@ enum bpf_attach_type {
  */
 #define BPF_F_STRICT_ALIGNMENT	(1U << 0)
 
+/* If BPF_F_ANY_ALIGNMENT is used in BPF_PROF_LOAD command, the
+ * verifier will allow any alignment whatsoever.  On platforms
+ * with strict alignment requirements for loads ands stores (such
+ * as sparc and mips) the verifier validates that all loads and
+ * stores provably follow this requirement.  This flag turns that
+ * checking and enforcement off.
+ *
+ * It is mostly used for testing when we want to validate the
+ * context and memory access aspects of the verifier, but because
+ * of an unaligned access the alignment check would trigger before
+ * the one we are interested in.
+ */
+#define BPF_F_ANY_ALIGNMENT	(1U << 1)
+
 /* when bpf_ldimm64->src_reg == BPF_PSEUDO_MAP_FD, bpf_ldimm64->imm == fd */
 #define BPF_PSEUDO_MAP_FD	1
 
diff --git a/kernel/bpf/syscall.c b/kernel/bpf/syscall.c
index 0226bc9e5288..c5838852180d 100644
--- a/kernel/bpf/syscall.c
+++ b/kernel/bpf/syscall.c
@@ -1465,9 +1465,14 @@ static int bpf_prog_load(union bpf_attr *attr)
 	if (CHECK_ATTR(BPF_PROG_LOAD))
 		return -EINVAL;
 
-	if (attr->prog_flags & ~BPF_F_STRICT_ALIGNMENT)
+	if (attr->prog_flags & ~(BPF_F_STRICT_ALIGNMENT | BPF_F_ANY_ALIGNMENT))
 		return -EINVAL;
 
+	if (!IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) &&
+	    (attr->prog_flags & BPF_F_ANY_ALIGNMENT) &&
+	    !capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
 	/* copy eBPF program license from user space */
 	if (strncpy_from_user(license, u64_to_user_ptr(attr->license),
 			      sizeof(license) - 1) < 0)
diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c
index 9aed50935989..981488c6239a 100644
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@ -6163,6 +6163,8 @@ int bpf_check(struct bpf_prog **prog, union bpf_attr *attr)
 	env->strict_alignment = !!(attr->prog_flags & BPF_F_STRICT_ALIGNMENT);
 	if (!IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS))
 		env->strict_alignment = true;
+	if (attr->prog_flags & BPF_F_ANY_ALIGNMENT)
+		env->strict_alignment = false;
 
 	ret = replace_map_fd_with_map_ptr(env);
 	if (ret < 0)
diff --git a/tools/include/uapi/linux/bpf.h b/tools/include/uapi/linux/bpf.h
index dd0da04bd3ab..c5466b45fcd1 100644
--- a/tools/include/uapi/linux/bpf.h
+++ b/tools/include/uapi/linux/bpf.h
@@ -224,6 +224,20 @@ enum bpf_attach_type {
  */
 #define BPF_F_STRICT_ALIGNMENT	(1U << 0)
 
+/* If BPF_F_ANY_ALIGNMENT is used in BPF_PROF_LOAD command, the
+ * verifier will allow any alignment whatsoever.  On platforms
+ * with strict alignment requirements for loads ands stores (such
+ * as sparc and mips) the verifier validates that all loads and
+ * stores provably follow this requirement.  This flag turns that
+ * checking and enforcement off.
+ *
+ * It is mostly used for testing when we want to validate the
+ * context and memory access aspects of the verifier, but because
+ * of an unaligned access the alignment check would trigger before
+ * the one we are interested in.
+ */
+#define BPF_F_ANY_ALIGNMENT	(1U << 1)
+
 /* when bpf_ldimm64->src_reg == BPF_PSEUDO_MAP_FD, bpf_ldimm64->imm == fd */
 #define BPF_PSEUDO_MAP_FD	1
 
diff --git a/tools/lib/bpf/bpf.c b/tools/lib/bpf/bpf.c
index 2accecf0ac8f..33f69cfda05e 100644
--- a/tools/lib/bpf/bpf.c
+++ b/tools/lib/bpf/bpf.c
@@ -243,9 +243,9 @@ int bpf_load_program(enum bpf_prog_type type, const struct bpf_insn *insns,
 }
 
 int bpf_verify_program(enum bpf_prog_type type, const struct bpf_insn *insns,
-		       size_t insns_cnt, int strict_alignment,
-		       const char *license, __u32 kern_version,
-		       char *log_buf, size_t log_buf_sz, int log_level)
+		       size_t insns_cnt, __u32 prog_flags, const char *license,
+		       __u32 kern_version, char *log_buf, size_t log_buf_sz,
+		       int log_level)
 {
 	union bpf_attr attr;
 
@@ -259,7 +259,7 @@ int bpf_verify_program(enum bpf_prog_type type, const struct bpf_insn *insns,
 	attr.log_level = log_level;
 	log_buf[0] = 0;
 	attr.kern_version = kern_version;
-	attr.prog_flags = strict_alignment ? BPF_F_STRICT_ALIGNMENT : 0;
+	attr.prog_flags = prog_flags;
 
 	return sys_bpf(BPF_PROG_LOAD, &attr, sizeof(attr));
 }
* Unmerged path tools/lib/bpf/bpf.h
diff --git a/tools/testing/selftests/bpf/test_align.c b/tools/testing/selftests/bpf/test_align.c
index 5f377ec53f2f..3c789d03b629 100644
--- a/tools/testing/selftests/bpf/test_align.c
+++ b/tools/testing/selftests/bpf/test_align.c
@@ -620,8 +620,8 @@ static int do_test_single(struct bpf_align_test *test)
 
 	prog_len = probe_filter_length(prog);
 	fd_prog = bpf_verify_program(prog_type ? : BPF_PROG_TYPE_SOCKET_FILTER,
-				     prog, prog_len, 1, "GPL", 0,
-				     bpf_vlog, sizeof(bpf_vlog), 2);
+				     prog, prog_len, BPF_F_STRICT_ALIGNMENT,
+				     "GPL", 0, bpf_vlog, sizeof(bpf_vlog), 2);
 	if (fd_prog < 0 && test->result != REJECT) {
 		printf("Failed to load program.\n");
 		printf("%s", bpf_vlog);
diff --git a/tools/testing/selftests/bpf/test_verifier.c b/tools/testing/selftests/bpf/test_verifier.c
index 0254c6a3fb82..e6323a8df04f 100644
--- a/tools/testing/selftests/bpf/test_verifier.c
+++ b/tools/testing/selftests/bpf/test_verifier.c
@@ -14246,7 +14246,8 @@ static void do_test_single(struct bpf_test *test, bool unpriv,
 	prog_len = probe_filter_length(prog);
 
 	fd_prog = bpf_verify_program(prog_type, prog, prog_len,
-				     test->flags & F_LOAD_WITH_STRICT_ALIGNMENT,
+				     test->flags & F_LOAD_WITH_STRICT_ALIGNMENT ?
+				     BPF_F_STRICT_ALIGNMENT : 0,
 				     "GPL", 0, bpf_vlog, sizeof(bpf_vlog), 1);
 
 	expected_ret = unpriv && test->result_unpriv != UNDEF ?
