net/ipv6: Update inet6_dump_addr for strict data checking

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [net] ipv6: Update inet6_dump_addr for strict data checking (Petr Oros) [1700306]
Rebuild_FUZZ: 96.36%
commit-author David Ahern <dsahern@gmail.com>
commit ed6eff11790a5bf1ce9b0421667e46ab1cf368f4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/ed6eff11.failed

Update inet6_dump_addr for strict data checking. If the flag is set, the
dump request is expected to have an ifaddrmsg struct as the header
potentially followed by one or more attributes. Any data passed in the
header or as an attribute is taken as a request to influence the data
returned. Only values suppored by the dump handler are allowed to be
non-0 or set in the request. At the moment only the IFA_TARGET_NETNSID
attribute is supported. Follow on patches can add support for other fields
(e.g., honor ifa_index and only return data for the given device index).

	Signed-off-by: David Ahern <dsahern@gmail.com>
	Acked-by: Christian Brauner <christian@brauner.io>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ed6eff11790a5bf1ce9b0421667e46ab1cf368f4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/addrconf.c
diff --cc net/ipv6/addrconf.c
index 75a2cc3a2edb,095d3f56f0a9..000000000000
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@@ -5006,10 -5053,16 +5058,20 @@@ static int inet6_valid_dump_ifaddr_req(
  static int inet6_dump_addr(struct sk_buff *skb, struct netlink_callback *cb,
  			   enum addr_type_t type)
  {
++<<<<<<< HEAD
++=======
+ 	const struct nlmsghdr *nlh = cb->nlh;
+ 	struct inet6_fill_args fillargs = {
+ 		.portid = NETLINK_CB(cb->skb).portid,
+ 		.seq = cb->nlh->nlmsg_seq,
+ 		.flags = NLM_F_MULTI,
+ 		.netnsid = -1,
+ 		.type = type,
+ 	};
++>>>>>>> ed6eff11790a (net/ipv6: Update inet6_dump_addr for strict data checking)
  	struct net *net = sock_net(skb->sk);
- 	struct nlattr *tb[IFA_MAX+1];
  	struct net *tgt_net = net;
 +	int netnsid = -1;
  	int h, s_h;
  	int idx, ip_idx;
  	int s_idx, s_ip_idx;
@@@ -5021,15 -5074,13 +5083,25 @@@
  	s_idx = idx = cb->args[1];
  	s_ip_idx = ip_idx = cb->args[2];
  
++<<<<<<< HEAD
 +	if (nlmsg_parse(cb->nlh, sizeof(struct ifaddrmsg), tb, IFA_MAX,
 +			ifa_ipv6_policy, NULL) >= 0) {
 +		if (tb[IFA_TARGET_NETNSID]) {
 +			netnsid = nla_get_s32(tb[IFA_TARGET_NETNSID]);
 +
 +			tgt_net = rtnl_get_net_ns_capable(skb->sk, netnsid);
 +			if (IS_ERR(tgt_net))
 +				return PTR_ERR(tgt_net);
 +		}
++=======
+ 	if (cb->strict_check) {
+ 		int err;
+ 
+ 		err = inet6_valid_dump_ifaddr_req(nlh, &fillargs, &tgt_net,
+ 						  skb->sk, cb->extack);
+ 		if (err < 0)
+ 			return err;
++>>>>>>> ed6eff11790a (net/ipv6: Update inet6_dump_addr for strict data checking)
  	}
  
  	rcu_read_lock();
* Unmerged path net/ipv6/addrconf.c
