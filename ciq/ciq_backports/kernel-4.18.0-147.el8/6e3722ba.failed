IB/mlx5: Use the correct commands for UMEM and UCTX allocation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Yishai Hadas <yishaih@mellanox.com>
commit 6e3722baac048fdf95b867c5ee7e270718e8630d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/6e3722ba.failed

During testing the command format was changed to close a security
hole. Revise the driver to use the command format that will actually be
supported in GA firmware.

Both the UMEM and UCTX are intended only for use by the kernel and cannot
be executed using a general command.

Since the UMEM and CTX are not part of the general object the caps bits
were moved to be some log_xxx location in the general HCA caps.

The firmware code was adapted as well to match the above.

Fixes: a8b92ca1b0e5 ("IB/mlx5: Introduce DEVX")
	Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
	Reviewed-by: Achiad Shochat <achiad@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 6e3722baac048fdf95b867c5ee7e270718e8630d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/devx.c
#	include/linux/mlx5/mlx5_ifc.h
diff --cc drivers/infiniband/hw/mlx5/devx.c
index c7f8859c08ee,dcc7c974173f..000000000000
--- a/drivers/infiniband/hw/mlx5/devx.c
+++ b/drivers/infiniband/hw/mlx5/devx.c
@@@ -33,40 -51,38 +33,63 @@@ int mlx5_ib_devx_create(struct mlx5_ib_
  {
  	u32 in[MLX5_ST_SZ_DW(create_uctx_in)] = {0};
  	u32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)] = {0};
++<<<<<<< HEAD
 +	u64 general_obj_types;
 +	void *hdr;
++=======
+ 	void *uctx;
++>>>>>>> 6e3722baac04 (IB/mlx5: Use the correct commands for UMEM and UCTX allocation)
  	int err;
 -	u16 uid;
 -	u32 cap = 0;
  
++<<<<<<< HEAD
 +	hdr = MLX5_ADDR_OF(create_uctx_in, in, hdr);
 +
 +	general_obj_types = MLX5_CAP_GEN_64(dev->mdev, general_obj_types);
 +	if (!(general_obj_types & MLX5_GENERAL_OBJ_TYPES_CAP_UCTX) ||
 +	    !(general_obj_types & MLX5_GENERAL_OBJ_TYPES_CAP_UMEM))
 +		return -EINVAL;
 +
 +	if (!capable(CAP_NET_RAW))
 +		return -EPERM;
 +
 +	MLX5_SET(general_obj_in_cmd_hdr, hdr, opcode, MLX5_CMD_OP_CREATE_GENERAL_OBJECT);
 +	MLX5_SET(general_obj_in_cmd_hdr, hdr, obj_type, MLX5_OBJ_TYPE_UCTX);
++=======
+ 	/* 0 means not supported */
+ 	if (!MLX5_CAP_GEN(dev->mdev, log_max_uctx))
+ 		return -EINVAL;
+ 
+ 	uctx = MLX5_ADDR_OF(create_uctx_in, in, uctx);
+ 	if (is_user && capable(CAP_NET_RAW) &&
+ 	    (MLX5_CAP_GEN(dev->mdev, uctx_cap) & MLX5_UCTX_CAP_RAW_TX))
+ 		cap |= MLX5_UCTX_CAP_RAW_TX;
+ 
+ 	MLX5_SET(create_uctx_in, in, opcode, MLX5_CMD_OP_CREATE_UCTX);
+ 	MLX5_SET(uctx, uctx, cap, cap);
++>>>>>>> 6e3722baac04 (IB/mlx5: Use the correct commands for UMEM and UCTX allocation)
  
  	err = mlx5_cmd_exec(dev->mdev, in, sizeof(in), out, sizeof(out));
  	if (err)
  		return err;
  
 -	uid = MLX5_GET(general_obj_out_cmd_hdr, out, obj_id);
 -	return uid;
 +	context->devx_uid = MLX5_GET(general_obj_out_cmd_hdr, out, obj_id);
 +	return 0;
  }
  
 -void mlx5_ib_devx_destroy(struct mlx5_ib_dev *dev, u16 uid)
 +void mlx5_ib_devx_destroy(struct mlx5_ib_dev *dev,
 +			  struct mlx5_ib_ucontext *context)
  {
- 	u32 in[MLX5_ST_SZ_DW(general_obj_in_cmd_hdr)] = {0};
+ 	u32 in[MLX5_ST_SZ_DW(destroy_uctx_in)] = {0};
  	u32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)] = {0};
  
++<<<<<<< HEAD
 +	MLX5_SET(general_obj_in_cmd_hdr, in, opcode, MLX5_CMD_OP_DESTROY_GENERAL_OBJECT);
 +	MLX5_SET(general_obj_in_cmd_hdr, in, obj_type, MLX5_OBJ_TYPE_UCTX);
 +	MLX5_SET(general_obj_in_cmd_hdr, in, obj_id, context->devx_uid);
++=======
+ 	MLX5_SET(destroy_uctx_in, in, opcode, MLX5_CMD_OP_DESTROY_UCTX);
+ 	MLX5_SET(destroy_uctx_in, in, uid, uid);
++>>>>>>> 6e3722baac04 (IB/mlx5: Use the correct commands for UMEM and UCTX allocation)
  
  	mlx5_cmd_exec(dev->mdev, in, sizeof(in), out, sizeof(out));
  }
@@@ -428,47 -1088,372 +455,391 @@@ obj_free
  	return err;
  }
  
 -static int UVERBS_HANDLER(MLX5_IB_METHOD_DEVX_OBJ_MODIFY)(
 -	struct uverbs_attr_bundle *attrs)
 -{
 -	void *cmd_in = uverbs_attr_get_alloced_ptr(attrs, MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_IN);
 -	int cmd_out_len = uverbs_attr_get_len(attrs,
 -					MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_OUT);
 -	struct ib_uobject *uobj = uverbs_attr_get_uobject(attrs,
 -							  MLX5_IB_ATTR_DEVX_OBJ_MODIFY_HANDLE);
 -	struct mlx5_ib_ucontext *c = to_mucontext(uobj->context);
 -	struct mlx5_ib_dev *mdev = to_mdev(uobj->context->device);
 -	void *cmd_out;
 -	int err;
 -	int uid;
 -
 -	uid = devx_get_uid(c, cmd_in);
 -	if (uid < 0)
 -		return uid;
 -
 -	if (!devx_is_obj_modify_cmd(cmd_in))
 -		return -EINVAL;
 -
 -	if (!devx_is_valid_obj_id(uobj, cmd_in))
 -		return -EINVAL;
 -
 -	cmd_out = uverbs_zalloc(attrs, cmd_out_len);
 -	if (IS_ERR(cmd_out))
 -		return PTR_ERR(cmd_out);
 -
 +static DECLARE_UVERBS_NAMED_METHOD(MLX5_IB_METHOD_DEVX_OTHER,
 +	&UVERBS_ATTR_PTR_IN_SZ(MLX5_IB_ATTR_DEVX_OTHER_CMD_IN,
 +			       UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
 +			       UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY |
 +					UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO |
 +					UVERBS_ATTR_SPEC_F_ALLOC_AND_COPY)),
 +	&UVERBS_ATTR_PTR_OUT_SZ(MLX5_IB_ATTR_DEVX_OTHER_CMD_OUT,
 +				UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_out_cmd_hdr)),
 +				UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY |
 +					 UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO))
 +);
 +
 +static DECLARE_UVERBS_NAMED_METHOD(MLX5_IB_METHOD_DEVX_OBJ_CREATE,
 +	&UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_CREATE_HANDLE,
 +			 MLX5_IB_OBJECT_DEVX_OBJ,
 +			 UVERBS_ACCESS_NEW,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN_SZ(MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_IN,
 +			       UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
 +			       UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY |
 +					UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO |
 +					UVERBS_ATTR_SPEC_F_ALLOC_AND_COPY)),
 +	&UVERBS_ATTR_PTR_OUT_SZ(MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_OUT,
 +				UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_out_cmd_hdr)),
 +				UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY |
 +					 UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO)));
 +
 +static DECLARE_UVERBS_NAMED_METHOD(MLX5_IB_METHOD_DEVX_OBJ_DESTROY,
 +	&UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_DESTROY_HANDLE,
 +			 MLX5_IB_OBJECT_DEVX_OBJ,
 +			 UVERBS_ACCESS_DESTROY,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
 +
 +static DECLARE_UVERBS_GLOBAL_METHODS(MLX5_IB_OBJECT_DEVX,
 +	&UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OTHER));
 +
 +static DECLARE_UVERBS_NAMED_OBJECT(MLX5_IB_OBJECT_DEVX_OBJ,
 +	&UVERBS_TYPE_ALLOC_IDR(0, devx_obj_cleanup),
 +		&UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OBJ_CREATE),
 +		&UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OBJ_DESTROY));
 +
++<<<<<<< HEAD
 +static DECLARE_UVERBS_OBJECT_TREE(devx_objects,
 +	&UVERBS_OBJECT(MLX5_IB_OBJECT_DEVX),
 +	&UVERBS_OBJECT(MLX5_IB_OBJECT_DEVX_OBJ));
++=======
+ 	MLX5_SET(general_obj_in_cmd_hdr, cmd_in, uid, uid);
+ 	devx_set_umem_valid(cmd_in);
+ 
+ 	err = mlx5_cmd_exec(mdev->mdev, cmd_in,
+ 			    uverbs_attr_get_len(attrs, MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_IN),
+ 			    cmd_out, cmd_out_len);
+ 	if (err)
+ 		return err;
+ 
+ 	return uverbs_copy_to(attrs, MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_OUT,
+ 			      cmd_out, cmd_out_len);
+ }
+ 
+ static int UVERBS_HANDLER(MLX5_IB_METHOD_DEVX_OBJ_QUERY)(
+ 	struct uverbs_attr_bundle *attrs)
+ {
+ 	void *cmd_in = uverbs_attr_get_alloced_ptr(attrs, MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_IN);
+ 	int cmd_out_len = uverbs_attr_get_len(attrs,
+ 					      MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_OUT);
+ 	struct ib_uobject *uobj = uverbs_attr_get_uobject(attrs,
+ 							  MLX5_IB_ATTR_DEVX_OBJ_QUERY_HANDLE);
+ 	struct mlx5_ib_ucontext *c = to_mucontext(uobj->context);
+ 	void *cmd_out;
+ 	int err;
+ 	int uid;
+ 	struct mlx5_ib_dev *mdev = to_mdev(uobj->context->device);
+ 
+ 	uid = devx_get_uid(c, cmd_in);
+ 	if (uid < 0)
+ 		return uid;
+ 
+ 	if (!devx_is_obj_query_cmd(cmd_in))
+ 		return -EINVAL;
+ 
+ 	if (!devx_is_valid_obj_id(uobj, cmd_in))
+ 		return -EINVAL;
+ 
+ 	cmd_out = uverbs_zalloc(attrs, cmd_out_len);
+ 	if (IS_ERR(cmd_out))
+ 		return PTR_ERR(cmd_out);
+ 
+ 	MLX5_SET(general_obj_in_cmd_hdr, cmd_in, uid, uid);
+ 	err = mlx5_cmd_exec(mdev->mdev, cmd_in,
+ 			    uverbs_attr_get_len(attrs, MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_IN),
+ 			    cmd_out, cmd_out_len);
+ 	if (err)
+ 		return err;
+ 
+ 	return uverbs_copy_to(attrs, MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_OUT,
+ 			      cmd_out, cmd_out_len);
+ }
+ 
+ static int devx_umem_get(struct mlx5_ib_dev *dev, struct ib_ucontext *ucontext,
+ 			 struct uverbs_attr_bundle *attrs,
+ 			 struct devx_umem *obj)
+ {
+ 	u64 addr;
+ 	size_t size;
+ 	u32 access;
+ 	int npages;
+ 	int err;
+ 	u32 page_mask;
+ 
+ 	if (uverbs_copy_from(&addr, attrs, MLX5_IB_ATTR_DEVX_UMEM_REG_ADDR) ||
+ 	    uverbs_copy_from(&size, attrs, MLX5_IB_ATTR_DEVX_UMEM_REG_LEN))
+ 		return -EFAULT;
+ 
+ 	err = uverbs_get_flags32(&access, attrs,
+ 				 MLX5_IB_ATTR_DEVX_UMEM_REG_ACCESS,
+ 				 IB_ACCESS_SUPPORTED);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ib_check_mr_access(access);
+ 	if (err)
+ 		return err;
+ 
+ 	obj->umem = ib_umem_get(ucontext, addr, size, access, 0);
+ 	if (IS_ERR(obj->umem))
+ 		return PTR_ERR(obj->umem);
+ 
+ 	mlx5_ib_cont_pages(obj->umem, obj->umem->address,
+ 			   MLX5_MKEY_PAGE_SHIFT_MASK, &npages,
+ 			   &obj->page_shift, &obj->ncont, NULL);
+ 
+ 	if (!npages) {
+ 		ib_umem_release(obj->umem);
+ 		return -EINVAL;
+ 	}
+ 
+ 	page_mask = (1 << obj->page_shift) - 1;
+ 	obj->page_offset = obj->umem->address & page_mask;
+ 
+ 	return 0;
+ }
+ 
+ static int devx_umem_reg_cmd_alloc(struct uverbs_attr_bundle *attrs,
+ 				   struct devx_umem *obj,
+ 				   struct devx_umem_reg_cmd *cmd)
+ {
+ 	cmd->inlen = MLX5_ST_SZ_BYTES(create_umem_in) +
+ 		    (MLX5_ST_SZ_BYTES(mtt) * obj->ncont);
+ 	cmd->in = uverbs_zalloc(attrs, cmd->inlen);
+ 	return PTR_ERR_OR_ZERO(cmd->in);
+ }
+ 
+ static void devx_umem_reg_cmd_build(struct mlx5_ib_dev *dev,
+ 				    struct devx_umem *obj,
+ 				    struct devx_umem_reg_cmd *cmd)
+ {
+ 	void *umem;
+ 	__be64 *mtt;
+ 
+ 	umem = MLX5_ADDR_OF(create_umem_in, cmd->in, umem);
+ 	mtt = (__be64 *)MLX5_ADDR_OF(umem, umem, mtt);
+ 
+ 	MLX5_SET(create_umem_in, cmd->in, opcode, MLX5_CMD_OP_CREATE_UMEM);
+ 	MLX5_SET64(umem, umem, num_of_mtt, obj->ncont);
+ 	MLX5_SET(umem, umem, log_page_size, obj->page_shift -
+ 					    MLX5_ADAPTER_PAGE_SHIFT);
+ 	MLX5_SET(umem, umem, page_offset, obj->page_offset);
+ 	mlx5_ib_populate_pas(dev, obj->umem, obj->page_shift, mtt,
+ 			     (obj->umem->writable ? MLX5_IB_MTT_WRITE : 0) |
+ 			     MLX5_IB_MTT_READ);
+ }
+ 
+ static int UVERBS_HANDLER(MLX5_IB_METHOD_DEVX_UMEM_REG)(
+ 	struct uverbs_attr_bundle *attrs)
+ {
+ 	struct devx_umem_reg_cmd cmd;
+ 	struct devx_umem *obj;
+ 	struct ib_uobject *uobj = uverbs_attr_get_uobject(
+ 		attrs, MLX5_IB_ATTR_DEVX_UMEM_REG_HANDLE);
+ 	u32 obj_id;
+ 	struct mlx5_ib_ucontext *c = to_mucontext(uobj->context);
+ 	struct mlx5_ib_dev *dev = to_mdev(c->ibucontext.device);
+ 	int err;
+ 
+ 	if (!c->devx_uid)
+ 		return -EINVAL;
+ 
+ 	obj = kzalloc(sizeof(struct devx_umem), GFP_KERNEL);
+ 	if (!obj)
+ 		return -ENOMEM;
+ 
+ 	err = devx_umem_get(dev, &c->ibucontext, attrs, obj);
+ 	if (err)
+ 		goto err_obj_free;
+ 
+ 	err = devx_umem_reg_cmd_alloc(attrs, obj, &cmd);
+ 	if (err)
+ 		goto err_umem_release;
+ 
+ 	devx_umem_reg_cmd_build(dev, obj, &cmd);
+ 
+ 	MLX5_SET(create_umem_in, cmd.in, uid, c->devx_uid);
+ 	err = mlx5_cmd_exec(dev->mdev, cmd.in, cmd.inlen, cmd.out,
+ 			    sizeof(cmd.out));
+ 	if (err)
+ 		goto err_umem_release;
+ 
+ 	obj->mdev = dev->mdev;
+ 	uobj->object = obj;
+ 	devx_obj_build_destroy_cmd(cmd.in, cmd.out, obj->dinbox, &obj->dinlen, &obj_id);
+ 	err = uverbs_copy_to(attrs, MLX5_IB_ATTR_DEVX_UMEM_REG_OUT_ID, &obj_id, sizeof(obj_id));
+ 	if (err)
+ 		goto err_umem_destroy;
+ 
+ 	return 0;
+ 
+ err_umem_destroy:
+ 	mlx5_cmd_exec(obj->mdev, obj->dinbox, obj->dinlen, cmd.out, sizeof(cmd.out));
+ err_umem_release:
+ 	ib_umem_release(obj->umem);
+ err_obj_free:
+ 	kfree(obj);
+ 	return err;
+ }
+ 
+ static int devx_umem_cleanup(struct ib_uobject *uobject,
+ 			     enum rdma_remove_reason why)
+ {
+ 	struct devx_umem *obj = uobject->object;
+ 	u32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)];
+ 	int err;
+ 
+ 	err = mlx5_cmd_exec(obj->mdev, obj->dinbox, obj->dinlen, out, sizeof(out));
+ 	if (ib_is_destroy_retryable(err, why, uobject))
+ 		return err;
+ 
+ 	ib_umem_release(obj->umem);
+ 	kfree(obj);
+ 	return 0;
+ }
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	MLX5_IB_METHOD_DEVX_UMEM_REG,
+ 	UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_UMEM_REG_HANDLE,
+ 			MLX5_IB_OBJECT_DEVX_UMEM,
+ 			UVERBS_ACCESS_NEW,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_DEVX_UMEM_REG_ADDR,
+ 			   UVERBS_ATTR_TYPE(u64),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_DEVX_UMEM_REG_LEN,
+ 			   UVERBS_ATTR_TYPE(u64),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_FLAGS_IN(MLX5_IB_ATTR_DEVX_UMEM_REG_ACCESS,
+ 			     enum ib_access_flags),
+ 	UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_DEVX_UMEM_REG_OUT_ID,
+ 			    UVERBS_ATTR_TYPE(u32),
+ 			    UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD_DESTROY(
+ 	MLX5_IB_METHOD_DEVX_UMEM_DEREG,
+ 	UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_UMEM_DEREG_HANDLE,
+ 			MLX5_IB_OBJECT_DEVX_UMEM,
+ 			UVERBS_ACCESS_DESTROY,
+ 			UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	MLX5_IB_METHOD_DEVX_QUERY_EQN,
+ 	UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_DEVX_QUERY_EQN_USER_VEC,
+ 			   UVERBS_ATTR_TYPE(u32),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_DEVX_QUERY_EQN_DEV_EQN,
+ 			    UVERBS_ATTR_TYPE(u32),
+ 			    UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	MLX5_IB_METHOD_DEVX_QUERY_UAR,
+ 	UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_DEVX_QUERY_UAR_USER_IDX,
+ 			   UVERBS_ATTR_TYPE(u32),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_DEVX_QUERY_UAR_DEV_IDX,
+ 			    UVERBS_ATTR_TYPE(u32),
+ 			    UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	MLX5_IB_METHOD_DEVX_OTHER,
+ 	UVERBS_ATTR_PTR_IN(
+ 		MLX5_IB_ATTR_DEVX_OTHER_CMD_IN,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
+ 		UA_MANDATORY,
+ 		UA_ALLOC_AND_COPY),
+ 	UVERBS_ATTR_PTR_OUT(
+ 		MLX5_IB_ATTR_DEVX_OTHER_CMD_OUT,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_out_cmd_hdr)),
+ 		UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	MLX5_IB_METHOD_DEVX_OBJ_CREATE,
+ 	UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_CREATE_HANDLE,
+ 			MLX5_IB_OBJECT_DEVX_OBJ,
+ 			UVERBS_ACCESS_NEW,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(
+ 		MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_IN,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
+ 		UA_MANDATORY,
+ 		UA_ALLOC_AND_COPY),
+ 	UVERBS_ATTR_PTR_OUT(
+ 		MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_OUT,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_out_cmd_hdr)),
+ 		UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD_DESTROY(
+ 	MLX5_IB_METHOD_DEVX_OBJ_DESTROY,
+ 	UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_DESTROY_HANDLE,
+ 			MLX5_IB_OBJECT_DEVX_OBJ,
+ 			UVERBS_ACCESS_DESTROY,
+ 			UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	MLX5_IB_METHOD_DEVX_OBJ_MODIFY,
+ 	UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_MODIFY_HANDLE,
+ 			UVERBS_IDR_ANY_OBJECT,
+ 			UVERBS_ACCESS_WRITE,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(
+ 		MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_IN,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
+ 		UA_MANDATORY,
+ 		UA_ALLOC_AND_COPY),
+ 	UVERBS_ATTR_PTR_OUT(
+ 		MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_OUT,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_out_cmd_hdr)),
+ 		UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	MLX5_IB_METHOD_DEVX_OBJ_QUERY,
+ 	UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_QUERY_HANDLE,
+ 			UVERBS_IDR_ANY_OBJECT,
+ 			UVERBS_ACCESS_READ,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(
+ 		MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_IN,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
+ 		UA_MANDATORY,
+ 		UA_ALLOC_AND_COPY),
+ 	UVERBS_ATTR_PTR_OUT(
+ 		MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_OUT,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_out_cmd_hdr)),
+ 		UA_MANDATORY));
+ 
+ DECLARE_UVERBS_GLOBAL_METHODS(MLX5_IB_OBJECT_DEVX,
+ 			      &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OTHER),
+ 			      &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_QUERY_UAR),
+ 			      &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_QUERY_EQN));
+ 
+ DECLARE_UVERBS_NAMED_OBJECT(MLX5_IB_OBJECT_DEVX_OBJ,
+ 			    UVERBS_TYPE_ALLOC_IDR(devx_obj_cleanup),
+ 			    &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OBJ_CREATE),
+ 			    &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OBJ_DESTROY),
+ 			    &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OBJ_MODIFY),
+ 			    &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OBJ_QUERY));
+ 
+ DECLARE_UVERBS_NAMED_OBJECT(MLX5_IB_OBJECT_DEVX_UMEM,
+ 			    UVERBS_TYPE_ALLOC_IDR(devx_umem_cleanup),
+ 			    &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_UMEM_REG),
+ 			    &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_UMEM_DEREG));
+ 
+ static bool devx_is_supported(struct ib_device *device)
+ {
+ 	struct mlx5_ib_dev *dev = to_mdev(device);
+ 
+ 	return !dev->rep && MLX5_CAP_GEN(dev->mdev, log_max_uctx);
+ }
+ 
+ const struct uapi_definition mlx5_ib_devx_defs[] = {
+ 	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(
+ 		MLX5_IB_OBJECT_DEVX,
+ 		UAPI_DEF_IS_OBJ_SUPPORTED(devx_is_supported)),
+ 	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(
+ 		MLX5_IB_OBJECT_DEVX_OBJ,
+ 		UAPI_DEF_IS_OBJ_SUPPORTED(devx_is_supported)),
+ 	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(
+ 		MLX5_IB_OBJECT_DEVX_UMEM,
+ 		UAPI_DEF_IS_OBJ_SUPPORTED(devx_is_supported)),
+ 	{},
+ };
++>>>>>>> 6e3722baac04 (IB/mlx5: Use the correct commands for UMEM and UCTX allocation)
diff --cc include/linux/mlx5/mlx5_ifc.h
index 3d06ab0e777b,5ae0b0b9914a..000000000000
--- a/include/linux/mlx5/mlx5_ifc.h
+++ b/include/linux/mlx5/mlx5_ifc.h
@@@ -76,6 -76,10 +76,13 @@@ enum 
  };
  
  enum {
++<<<<<<< HEAD
++=======
+ 	MLX5_SHARED_RESOURCE_UID = 0xffff,
+ };
+ 
+ enum {
++>>>>>>> 6e3722baac04 (IB/mlx5: Use the correct commands for UMEM and UCTX allocation)
  	MLX5_CMD_OP_QUERY_HCA_CAP                 = 0x100,
  	MLX5_CMD_OP_QUERY_ADAPTER                 = 0x101,
  	MLX5_CMD_OP_INIT_HCA                      = 0x102,
@@@ -242,6 -253,14 +249,17 @@@
  	MLX5_CMD_OP_FPGA_QUERY_QP                 = 0x962,
  	MLX5_CMD_OP_FPGA_DESTROY_QP               = 0x963,
  	MLX5_CMD_OP_FPGA_QUERY_QP_COUNTERS        = 0x964,
++<<<<<<< HEAD
++=======
+ 	MLX5_CMD_OP_CREATE_GENERAL_OBJECT         = 0xa00,
+ 	MLX5_CMD_OP_MODIFY_GENERAL_OBJECT         = 0xa01,
+ 	MLX5_CMD_OP_QUERY_GENERAL_OBJECT          = 0xa02,
+ 	MLX5_CMD_OP_DESTROY_GENERAL_OBJECT        = 0xa03,
+ 	MLX5_CMD_OP_CREATE_UCTX                   = 0xa04,
+ 	MLX5_CMD_OP_DESTROY_UCTX                  = 0xa06,
+ 	MLX5_CMD_OP_CREATE_UMEM                   = 0xa08,
+ 	MLX5_CMD_OP_DESTROY_UMEM                  = 0xa0a,
++>>>>>>> 6e3722baac04 (IB/mlx5: Use the correct commands for UMEM and UCTX allocation)
  	MLX5_CMD_OP_MAX
  };
  
@@@ -1152,9 -1181,14 +1170,12 @@@ struct mlx5_ifc_cmd_hca_cap_bits 
  	u8         reserved_at_3f8[0x3];
  	u8         log_max_current_uc_list[0x5];
  
 -	u8         general_obj_types[0x40];
 -
 -	u8         reserved_at_440[0x20];
 +	u8         reserved_at_400[0x60];
  
- 	u8         reserved_at_460[0x10];
+ 	u8         reserved_at_460[0x3];
+ 	u8         log_max_uctx[0x5];
+ 	u8         reserved_at_468[0x3];
+ 	u8         log_max_umem[0x5];
  	u8         max_num_eqs[0x10];
  
  	u8         reserved_at_480[0x3];
@@@ -9231,4 -9373,140 +9252,143 @@@ struct mlx5_ifc_dealloc_memic_out_bits 
  	u8         reserved_at_40[0x40];
  };
  
++<<<<<<< HEAD
++=======
+ struct mlx5_ifc_general_obj_in_cmd_hdr_bits {
+ 	u8         opcode[0x10];
+ 	u8         uid[0x10];
+ 
+ 	u8         reserved_at_20[0x10];
+ 	u8         obj_type[0x10];
+ 
+ 	u8         obj_id[0x20];
+ 
+ 	u8         reserved_at_60[0x20];
+ };
+ 
+ struct mlx5_ifc_general_obj_out_cmd_hdr_bits {
+ 	u8         status[0x8];
+ 	u8         reserved_at_8[0x18];
+ 
+ 	u8         syndrome[0x20];
+ 
+ 	u8         obj_id[0x20];
+ 
+ 	u8         reserved_at_60[0x20];
+ };
+ 
+ struct mlx5_ifc_umem_bits {
+ 	u8         reserved_at_0[0x80];
+ 
+ 	u8         reserved_at_80[0x1b];
+ 	u8         log_page_size[0x5];
+ 
+ 	u8         page_offset[0x20];
+ 
+ 	u8         num_of_mtt[0x40];
+ 
+ 	struct mlx5_ifc_mtt_bits  mtt[0];
+ };
+ 
+ struct mlx5_ifc_uctx_bits {
+ 	u8         cap[0x20];
+ 
+ 	u8         reserved_at_20[0x160];
+ };
+ 
+ struct mlx5_ifc_create_umem_in_bits {
+ 	u8         opcode[0x10];
+ 	u8         uid[0x10];
+ 
+ 	u8         reserved_at_20[0x10];
+ 	u8         op_mod[0x10];
+ 
+ 	u8         reserved_at_40[0x40];
+ 
+ 	struct mlx5_ifc_umem_bits  umem;
+ };
+ 
+ struct mlx5_ifc_create_uctx_in_bits {
+ 	u8         opcode[0x10];
+ 	u8         reserved_at_10[0x10];
+ 
+ 	u8         reserved_at_20[0x10];
+ 	u8         op_mod[0x10];
+ 
+ 	u8         reserved_at_40[0x40];
+ 
+ 	struct mlx5_ifc_uctx_bits  uctx;
+ };
+ 
+ struct mlx5_ifc_destroy_uctx_in_bits {
+ 	u8         opcode[0x10];
+ 	u8         reserved_at_10[0x10];
+ 
+ 	u8         reserved_at_20[0x10];
+ 	u8         op_mod[0x10];
+ 
+ 	u8         reserved_at_40[0x10];
+ 	u8         uid[0x10];
+ 
+ 	u8         reserved_at_60[0x20];
+ };
+ 
+ struct mlx5_ifc_mtrc_string_db_param_bits {
+ 	u8         string_db_base_address[0x20];
+ 
+ 	u8         reserved_at_20[0x8];
+ 	u8         string_db_size[0x18];
+ };
+ 
+ struct mlx5_ifc_mtrc_cap_bits {
+ 	u8         trace_owner[0x1];
+ 	u8         trace_to_memory[0x1];
+ 	u8         reserved_at_2[0x4];
+ 	u8         trc_ver[0x2];
+ 	u8         reserved_at_8[0x14];
+ 	u8         num_string_db[0x4];
+ 
+ 	u8         first_string_trace[0x8];
+ 	u8         num_string_trace[0x8];
+ 	u8         reserved_at_30[0x28];
+ 
+ 	u8         log_max_trace_buffer_size[0x8];
+ 
+ 	u8         reserved_at_60[0x20];
+ 
+ 	struct mlx5_ifc_mtrc_string_db_param_bits string_db_param[8];
+ 
+ 	u8         reserved_at_280[0x180];
+ };
+ 
+ struct mlx5_ifc_mtrc_conf_bits {
+ 	u8         reserved_at_0[0x1c];
+ 	u8         trace_mode[0x4];
+ 	u8         reserved_at_20[0x18];
+ 	u8         log_trace_buffer_size[0x8];
+ 	u8         trace_mkey[0x20];
+ 	u8         reserved_at_60[0x3a0];
+ };
+ 
+ struct mlx5_ifc_mtrc_stdb_bits {
+ 	u8         string_db_index[0x4];
+ 	u8         reserved_at_4[0x4];
+ 	u8         read_size[0x18];
+ 	u8         start_offset[0x20];
+ 	u8         string_db_data[0];
+ };
+ 
+ struct mlx5_ifc_mtrc_ctrl_bits {
+ 	u8         trace_status[0x2];
+ 	u8         reserved_at_2[0x2];
+ 	u8         arm_event[0x1];
+ 	u8         reserved_at_5[0xb];
+ 	u8         modify_field_select[0x10];
+ 	u8         reserved_at_20[0x2b];
+ 	u8         current_timestamp52_32[0x15];
+ 	u8         current_timestamp31_0[0x20];
+ 	u8         reserved_at_80[0x180];
+ };
+ 
++>>>>>>> 6e3722baac04 (IB/mlx5: Use the correct commands for UMEM and UCTX allocation)
  #endif /* MLX5_IFC_H */
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
* Unmerged path include/linux/mlx5/mlx5_ifc.h
