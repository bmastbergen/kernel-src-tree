KVM: PPC: Book3S HV: XIVE: Add a control to configure a source

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Cédric Le Goater <clg@kaod.org>
commit e8676ce50e224d507946b1c535bc13584e6b49ff
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/e8676ce5.failed

This control will be used by the H_INT_SET_SOURCE_CONFIG hcall from
QEMU to configure the target of a source and also to restore the
configuration of a source when migrating the VM.

The XIVE source interrupt structure is extended with the value of the
Effective Interrupt Source Number. The EISN is the interrupt number
pushed in the event queue that the guest OS will use to dispatch
events internally. Caching the EISN value in KVM eases the test when
checking if a reconfiguration is indeed needed.

	Signed-off-by: Cédric Le Goater <clg@kaod.org>
	Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
	Signed-off-by: Paul Mackerras <paulus@ozlabs.org>
(cherry picked from commit e8676ce50e224d507946b1c535bc13584e6b49ff)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/virtual/kvm/devices/xive.txt
#	arch/powerpc/include/uapi/asm/kvm.h
#	arch/powerpc/kvm/book3s_xive.h
#	arch/powerpc/kvm/book3s_xive_native.c
diff --cc Documentation/virtual/kvm/devices/xive.txt
index fdbd2ff92a88,33c64b2cdbe8..000000000000
--- a/Documentation/virtual/kvm/devices/xive.txt
+++ b/Documentation/virtual/kvm/devices/xive.txt
@@@ -17,3 -17,39 +17,42 @@@ the legacy interrupt mode, referred as 
  
    1. KVM_DEV_XIVE_GRP_CTRL
    Provides global controls on the device
++<<<<<<< HEAD
++=======
+ 
+   2. KVM_DEV_XIVE_GRP_SOURCE (write only)
+   Initializes a new source in the XIVE device and mask it.
+   Attributes:
+     Interrupt source number  (64-bit)
+   The kvm_device_attr.addr points to a __u64 value:
+   bits:     | 63   ....  2 |   1   |   0
+   values:   |    unused    | level | type
+   - type:  0:MSI 1:LSI
+   - level: assertion level in case of an LSI.
+   Errors:
+     -E2BIG:  Interrupt source number is out of range
+     -ENOMEM: Could not create a new source block
+     -EFAULT: Invalid user pointer for attr->addr.
+     -ENXIO:  Could not allocate underlying HW interrupt
+ 
+   3. KVM_DEV_XIVE_GRP_SOURCE_CONFIG (write only)
+   Configures source targeting
+   Attributes:
+     Interrupt source number  (64-bit)
+   The kvm_device_attr.addr points to a __u64 value:
+   bits:     | 63   ....  33 |  32  | 31 .. 3 |  2 .. 0
+   values:   |    eisn       | mask |  server | priority
+   - priority: 0-7 interrupt priority level
+   - server: CPU number chosen to handle the interrupt
+   - mask: mask flag (unused)
+   - eisn: Effective Interrupt Source Number
+   Errors:
+     -ENOENT: Unknown source number
+     -EINVAL: Not initialized source number
+     -EINVAL: Invalid priority
+     -EINVAL: Invalid CPU number.
+     -EFAULT: Invalid user pointer for attr->addr.
+     -ENXIO:  CPU event queues not configured or configuration of the
+              underlying HW interrupt failed
+     -EBUSY:  No CPU available to serve interrupt
++>>>>>>> e8676ce50e22 (KVM: PPC: Book3S HV: XIVE: Add a control to configure a source)
diff --cc arch/powerpc/include/uapi/asm/kvm.h
index be0ce1f17625,e8161e21629b..000000000000
--- a/arch/powerpc/include/uapi/asm/kvm.h
+++ b/arch/powerpc/include/uapi/asm/kvm.h
@@@ -679,5 -679,21 +679,24 @@@ struct kvm_ppc_cpu_char 
  
  /* POWER9 XIVE Native Interrupt Controller */
  #define KVM_DEV_XIVE_GRP_CTRL		1
++<<<<<<< HEAD
++=======
+ #define KVM_DEV_XIVE_GRP_SOURCE		2	/* 64-bit source identifier */
+ #define KVM_DEV_XIVE_GRP_SOURCE_CONFIG	3	/* 64-bit source identifier */
+ 
+ /* Layout of 64-bit XIVE source attribute values */
+ #define KVM_XIVE_LEVEL_SENSITIVE	(1ULL << 0)
+ #define KVM_XIVE_LEVEL_ASSERTED		(1ULL << 1)
++>>>>>>> e8676ce50e22 (KVM: PPC: Book3S HV: XIVE: Add a control to configure a source)
+ 
+ /* Layout of 64-bit XIVE source configuration attribute values */
+ #define KVM_XIVE_SOURCE_PRIORITY_SHIFT	0
+ #define KVM_XIVE_SOURCE_PRIORITY_MASK	0x7
+ #define KVM_XIVE_SOURCE_SERVER_SHIFT	3
+ #define KVM_XIVE_SOURCE_SERVER_MASK	0xfffffff8ULL
+ #define KVM_XIVE_SOURCE_MASKED_SHIFT	32
+ #define KVM_XIVE_SOURCE_MASKED_MASK	0x100000000ULL
+ #define KVM_XIVE_SOURCE_EISN_SHIFT	33
+ #define KVM_XIVE_SOURCE_EISN_MASK	0xfffffffe00000000ULL
  
  #endif /* __LINUX_KVM_POWERPC_H */
diff --cc arch/powerpc/kvm/book3s_xive.h
index a08ae6fd4c51,ae26fe653d98..000000000000
--- a/arch/powerpc/kvm/book3s_xive.h
+++ b/arch/powerpc/kvm/book3s_xive.h
@@@ -248,5 -263,15 +251,18 @@@ extern int (*__xive_vm_h_ipi)(struct kv
  extern int (*__xive_vm_h_cppr)(struct kvm_vcpu *vcpu, unsigned long cppr);
  extern int (*__xive_vm_h_eoi)(struct kvm_vcpu *vcpu, unsigned long xirr);
  
++<<<<<<< HEAD
++=======
+ /*
+  * Common Xive routines for XICS-over-XIVE and XIVE native
+  */
+ void kvmppc_xive_disable_vcpu_interrupts(struct kvm_vcpu *vcpu);
+ int kvmppc_xive_debug_show_queues(struct seq_file *m, struct kvm_vcpu *vcpu);
+ struct kvmppc_xive_src_block *kvmppc_xive_create_src_block(
+ 	struct kvmppc_xive *xive, int irq);
+ void kvmppc_xive_free_sources(struct kvmppc_xive_src_block *sb);
+ int kvmppc_xive_select_target(struct kvm *kvm, u32 *server, u8 prio);
+ 
++>>>>>>> e8676ce50e22 (KVM: PPC: Book3S HV: XIVE: Add a control to configure a source)
  #endif /* CONFIG_KVM_XICS */
  #endif /* _KVM_PPC_BOOK3S_XICS_H */
diff --cc arch/powerpc/kvm/book3s_xive_native.c
index 751259394150,492825a35958..000000000000
--- a/arch/powerpc/kvm/book3s_xive_native.c
+++ b/arch/powerpc/kvm/book3s_xive_native.c
@@@ -26,12 -26,329 +26,333 @@@
  
  #include "book3s_xive.h"
  
++<<<<<<< HEAD
++=======
+ static u8 xive_vm_esb_load(struct xive_irq_data *xd, u32 offset)
+ {
+ 	u64 val;
+ 
+ 	if (xd->flags & XIVE_IRQ_FLAG_SHIFT_BUG)
+ 		offset |= offset << 4;
+ 
+ 	val = in_be64(xd->eoi_mmio + offset);
+ 	return (u8)val;
+ }
+ 
+ static void kvmppc_xive_native_cleanup_queue(struct kvm_vcpu *vcpu, int prio)
+ {
+ 	struct kvmppc_xive_vcpu *xc = vcpu->arch.xive_vcpu;
+ 	struct xive_q *q = &xc->queues[prio];
+ 
+ 	xive_native_disable_queue(xc->vp_id, q, prio);
+ 	if (q->qpage) {
+ 		put_page(virt_to_page(q->qpage));
+ 		q->qpage = NULL;
+ 	}
+ }
+ 
+ void kvmppc_xive_native_cleanup_vcpu(struct kvm_vcpu *vcpu)
+ {
+ 	struct kvmppc_xive_vcpu *xc = vcpu->arch.xive_vcpu;
+ 	int i;
+ 
+ 	if (!kvmppc_xive_enabled(vcpu))
+ 		return;
+ 
+ 	if (!xc)
+ 		return;
+ 
+ 	pr_devel("native_cleanup_vcpu(cpu=%d)\n", xc->server_num);
+ 
+ 	/* Ensure no interrupt is still routed to that VP */
+ 	xc->valid = false;
+ 	kvmppc_xive_disable_vcpu_interrupts(vcpu);
+ 
+ 	/* Disable the VP */
+ 	xive_native_disable_vp(xc->vp_id);
+ 
+ 	/* Free the queues & associated interrupts */
+ 	for (i = 0; i < KVMPPC_XIVE_Q_COUNT; i++) {
+ 		/* Free the escalation irq */
+ 		if (xc->esc_virq[i]) {
+ 			free_irq(xc->esc_virq[i], vcpu);
+ 			irq_dispose_mapping(xc->esc_virq[i]);
+ 			kfree(xc->esc_virq_names[i]);
+ 			xc->esc_virq[i] = 0;
+ 		}
+ 
+ 		/* Free the queue */
+ 		kvmppc_xive_native_cleanup_queue(vcpu, i);
+ 	}
+ 
+ 	/* Free the VP */
+ 	kfree(xc);
+ 
+ 	/* Cleanup the vcpu */
+ 	vcpu->arch.irq_type = KVMPPC_IRQ_DEFAULT;
+ 	vcpu->arch.xive_vcpu = NULL;
+ }
+ 
+ int kvmppc_xive_native_connect_vcpu(struct kvm_device *dev,
+ 				    struct kvm_vcpu *vcpu, u32 server_num)
+ {
+ 	struct kvmppc_xive *xive = dev->private;
+ 	struct kvmppc_xive_vcpu *xc = NULL;
+ 	int rc;
+ 
+ 	pr_devel("native_connect_vcpu(server=%d)\n", server_num);
+ 
+ 	if (dev->ops != &kvm_xive_native_ops) {
+ 		pr_devel("Wrong ops !\n");
+ 		return -EPERM;
+ 	}
+ 	if (xive->kvm != vcpu->kvm)
+ 		return -EPERM;
+ 	if (vcpu->arch.irq_type != KVMPPC_IRQ_DEFAULT)
+ 		return -EBUSY;
+ 	if (server_num >= KVM_MAX_VCPUS) {
+ 		pr_devel("Out of bounds !\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	mutex_lock(&vcpu->kvm->lock);
+ 
+ 	if (kvmppc_xive_find_server(vcpu->kvm, server_num)) {
+ 		pr_devel("Duplicate !\n");
+ 		rc = -EEXIST;
+ 		goto bail;
+ 	}
+ 
+ 	xc = kzalloc(sizeof(*xc), GFP_KERNEL);
+ 	if (!xc) {
+ 		rc = -ENOMEM;
+ 		goto bail;
+ 	}
+ 
+ 	vcpu->arch.xive_vcpu = xc;
+ 	xc->xive = xive;
+ 	xc->vcpu = vcpu;
+ 	xc->server_num = server_num;
+ 
+ 	xc->vp_id = kvmppc_xive_vp(xive, server_num);
+ 	xc->valid = true;
+ 	vcpu->arch.irq_type = KVMPPC_IRQ_XIVE;
+ 
+ 	rc = xive_native_get_vp_info(xc->vp_id, &xc->vp_cam, &xc->vp_chip_id);
+ 	if (rc) {
+ 		pr_err("Failed to get VP info from OPAL: %d\n", rc);
+ 		goto bail;
+ 	}
+ 
+ 	/*
+ 	 * Enable the VP first as the single escalation mode will
+ 	 * affect escalation interrupts numbering
+ 	 */
+ 	rc = xive_native_enable_vp(xc->vp_id, xive->single_escalation);
+ 	if (rc) {
+ 		pr_err("Failed to enable VP in OPAL: %d\n", rc);
+ 		goto bail;
+ 	}
+ 
+ 	/* Configure VCPU fields for use by assembly push/pull */
+ 	vcpu->arch.xive_saved_state.w01 = cpu_to_be64(0xff000000);
+ 	vcpu->arch.xive_cam_word = cpu_to_be32(xc->vp_cam | TM_QW1W2_VO);
+ 
+ 	/* TODO: reset all queues to a clean state ? */
+ bail:
+ 	mutex_unlock(&vcpu->kvm->lock);
+ 	if (rc)
+ 		kvmppc_xive_native_cleanup_vcpu(vcpu);
+ 
+ 	return rc;
+ }
+ 
+ static int kvmppc_xive_native_set_source(struct kvmppc_xive *xive, long irq,
+ 					 u64 addr)
+ {
+ 	struct kvmppc_xive_src_block *sb;
+ 	struct kvmppc_xive_irq_state *state;
+ 	u64 __user *ubufp = (u64 __user *) addr;
+ 	u64 val;
+ 	u16 idx;
+ 	int rc;
+ 
+ 	pr_devel("%s irq=0x%lx\n", __func__, irq);
+ 
+ 	if (irq < KVMPPC_XIVE_FIRST_IRQ || irq >= KVMPPC_XIVE_NR_IRQS)
+ 		return -E2BIG;
+ 
+ 	sb = kvmppc_xive_find_source(xive, irq, &idx);
+ 	if (!sb) {
+ 		pr_debug("No source, creating source block...\n");
+ 		sb = kvmppc_xive_create_src_block(xive, irq);
+ 		if (!sb) {
+ 			pr_err("Failed to create block...\n");
+ 			return -ENOMEM;
+ 		}
+ 	}
+ 	state = &sb->irq_state[idx];
+ 
+ 	if (get_user(val, ubufp)) {
+ 		pr_err("fault getting user info !\n");
+ 		return -EFAULT;
+ 	}
+ 
+ 	arch_spin_lock(&sb->lock);
+ 
+ 	/*
+ 	 * If the source doesn't already have an IPI, allocate
+ 	 * one and get the corresponding data
+ 	 */
+ 	if (!state->ipi_number) {
+ 		state->ipi_number = xive_native_alloc_irq();
+ 		if (state->ipi_number == 0) {
+ 			pr_err("Failed to allocate IRQ !\n");
+ 			rc = -ENXIO;
+ 			goto unlock;
+ 		}
+ 		xive_native_populate_irq_data(state->ipi_number,
+ 					      &state->ipi_data);
+ 		pr_debug("%s allocated hw_irq=0x%x for irq=0x%lx\n", __func__,
+ 			 state->ipi_number, irq);
+ 	}
+ 
+ 	/* Restore LSI state */
+ 	if (val & KVM_XIVE_LEVEL_SENSITIVE) {
+ 		state->lsi = true;
+ 		if (val & KVM_XIVE_LEVEL_ASSERTED)
+ 			state->asserted = true;
+ 		pr_devel("  LSI ! Asserted=%d\n", state->asserted);
+ 	}
+ 
+ 	/* Mask IRQ to start with */
+ 	state->act_server = 0;
+ 	state->act_priority = MASKED;
+ 	xive_vm_esb_load(&state->ipi_data, XIVE_ESB_SET_PQ_01);
+ 	xive_native_configure_irq(state->ipi_number, 0, MASKED, 0);
+ 
+ 	/* Increment the number of valid sources and mark this one valid */
+ 	if (!state->valid)
+ 		xive->src_count++;
+ 	state->valid = true;
+ 
+ 	rc = 0;
+ 
+ unlock:
+ 	arch_spin_unlock(&sb->lock);
+ 
+ 	return rc;
+ }
+ 
+ static int kvmppc_xive_native_update_source_config(struct kvmppc_xive *xive,
+ 					struct kvmppc_xive_src_block *sb,
+ 					struct kvmppc_xive_irq_state *state,
+ 					u32 server, u8 priority, bool masked,
+ 					u32 eisn)
+ {
+ 	struct kvm *kvm = xive->kvm;
+ 	u32 hw_num;
+ 	int rc = 0;
+ 
+ 	arch_spin_lock(&sb->lock);
+ 
+ 	if (state->act_server == server && state->act_priority == priority &&
+ 	    state->eisn == eisn)
+ 		goto unlock;
+ 
+ 	pr_devel("new_act_prio=%d new_act_server=%d mask=%d act_server=%d act_prio=%d\n",
+ 		 priority, server, masked, state->act_server,
+ 		 state->act_priority);
+ 
+ 	kvmppc_xive_select_irq(state, &hw_num, NULL);
+ 
+ 	if (priority != MASKED && !masked) {
+ 		rc = kvmppc_xive_select_target(kvm, &server, priority);
+ 		if (rc)
+ 			goto unlock;
+ 
+ 		state->act_priority = priority;
+ 		state->act_server = server;
+ 		state->eisn = eisn;
+ 
+ 		rc = xive_native_configure_irq(hw_num,
+ 					       kvmppc_xive_vp(xive, server),
+ 					       priority, eisn);
+ 	} else {
+ 		state->act_priority = MASKED;
+ 		state->act_server = 0;
+ 		state->eisn = 0;
+ 
+ 		rc = xive_native_configure_irq(hw_num, 0, MASKED, 0);
+ 	}
+ 
+ unlock:
+ 	arch_spin_unlock(&sb->lock);
+ 	return rc;
+ }
+ 
+ static int kvmppc_xive_native_set_source_config(struct kvmppc_xive *xive,
+ 						long irq, u64 addr)
+ {
+ 	struct kvmppc_xive_src_block *sb;
+ 	struct kvmppc_xive_irq_state *state;
+ 	u64 __user *ubufp = (u64 __user *) addr;
+ 	u16 src;
+ 	u64 kvm_cfg;
+ 	u32 server;
+ 	u8 priority;
+ 	bool masked;
+ 	u32 eisn;
+ 
+ 	sb = kvmppc_xive_find_source(xive, irq, &src);
+ 	if (!sb)
+ 		return -ENOENT;
+ 
+ 	state = &sb->irq_state[src];
+ 
+ 	if (!state->valid)
+ 		return -EINVAL;
+ 
+ 	if (get_user(kvm_cfg, ubufp))
+ 		return -EFAULT;
+ 
+ 	pr_devel("%s irq=0x%lx cfg=%016llx\n", __func__, irq, kvm_cfg);
+ 
+ 	priority = (kvm_cfg & KVM_XIVE_SOURCE_PRIORITY_MASK) >>
+ 		KVM_XIVE_SOURCE_PRIORITY_SHIFT;
+ 	server = (kvm_cfg & KVM_XIVE_SOURCE_SERVER_MASK) >>
+ 		KVM_XIVE_SOURCE_SERVER_SHIFT;
+ 	masked = (kvm_cfg & KVM_XIVE_SOURCE_MASKED_MASK) >>
+ 		KVM_XIVE_SOURCE_MASKED_SHIFT;
+ 	eisn = (kvm_cfg & KVM_XIVE_SOURCE_EISN_MASK) >>
+ 		KVM_XIVE_SOURCE_EISN_SHIFT;
+ 
+ 	if (priority != xive_prio_from_guest(priority)) {
+ 		pr_err("invalid priority for queue %d for VCPU %d\n",
+ 		       priority, server);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return kvmppc_xive_native_update_source_config(xive, sb, state, server,
+ 						       priority, masked, eisn);
+ }
+ 
++>>>>>>> e8676ce50e22 (KVM: PPC: Book3S HV: XIVE: Add a control to configure a source)
  static int kvmppc_xive_native_set_attr(struct kvm_device *dev,
  				       struct kvm_device_attr *attr)
  {
  	switch (attr->group) {
  	case KVM_DEV_XIVE_GRP_CTRL:
  		break;
++<<<<<<< HEAD
++=======
+ 	case KVM_DEV_XIVE_GRP_SOURCE:
+ 		return kvmppc_xive_native_set_source(xive, attr->attr,
+ 						     attr->addr);
+ 	case KVM_DEV_XIVE_GRP_SOURCE_CONFIG:
+ 		return kvmppc_xive_native_set_source_config(xive, attr->attr,
+ 							    attr->addr);
++>>>>>>> e8676ce50e22 (KVM: PPC: Book3S HV: XIVE: Add a control to configure a source)
  	}
  	return -ENXIO;
  }
@@@ -48,6 -365,12 +369,15 @@@ static int kvmppc_xive_native_has_attr(
  	switch (attr->group) {
  	case KVM_DEV_XIVE_GRP_CTRL:
  		break;
++<<<<<<< HEAD
++=======
+ 	case KVM_DEV_XIVE_GRP_SOURCE:
+ 	case KVM_DEV_XIVE_GRP_SOURCE_CONFIG:
+ 		if (attr->attr >= KVMPPC_XIVE_FIRST_IRQ &&
+ 		    attr->attr < KVMPPC_XIVE_NR_IRQS)
+ 			return 0;
+ 		break;
++>>>>>>> e8676ce50e22 (KVM: PPC: Book3S HV: XIVE: Add a control to configure a source)
  	}
  	return -ENXIO;
  }
* Unmerged path Documentation/virtual/kvm/devices/xive.txt
* Unmerged path arch/powerpc/include/uapi/asm/kvm.h
diff --git a/arch/powerpc/kvm/book3s_xive.c b/arch/powerpc/kvm/book3s_xive.c
index f78d002f0fe0..4a12ac74c208 100644
--- a/arch/powerpc/kvm/book3s_xive.c
+++ b/arch/powerpc/kvm/book3s_xive.c
@@ -342,7 +342,7 @@ static int xive_try_pick_queue(struct kvm_vcpu *vcpu, u8 prio)
 	return atomic_add_unless(&q->count, 1, max) ? 0 : -EBUSY;
 }
 
-static int xive_select_target(struct kvm *kvm, u32 *server, u8 prio)
+int kvmppc_xive_select_target(struct kvm *kvm, u32 *server, u8 prio)
 {
 	struct kvm_vcpu *vcpu;
 	int i, rc;
@@ -535,7 +535,7 @@ static int xive_target_interrupt(struct kvm *kvm,
 	 * priority. The count for that new target will have
 	 * already been incremented.
 	 */
-	rc = xive_select_target(kvm, &server, prio);
+	rc = kvmppc_xive_select_target(kvm, &server, prio);
 
 	/*
 	 * We failed to find a target ? Not much we can do
@@ -1509,6 +1509,7 @@ static struct kvmppc_xive_src_block *xive_create_src_block(struct kvmppc_xive *x
 
 	for (i = 0; i < KVMPPC_XICS_IRQ_PER_ICS; i++) {
 		sb->irq_state[i].number = (bid << KVMPPC_XICS_ICS_SHIFT) | i;
+		sb->irq_state[i].eisn = 0;
 		sb->irq_state[i].guest_priority = MASKED;
 		sb->irq_state[i].saved_priority = MASKED;
 		sb->irq_state[i].act_priority = MASKED;
* Unmerged path arch/powerpc/kvm/book3s_xive.h
* Unmerged path arch/powerpc/kvm/book3s_xive_native.c
