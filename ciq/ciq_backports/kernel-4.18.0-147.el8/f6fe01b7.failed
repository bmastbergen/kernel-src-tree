IB/mlx5: Add DEVX query EQN support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Yishai Hadas <yishaih@mellanox.com>
commit f6fe01b7181be1751a5d8f19f230eb0d17b9a7b1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/f6fe01b7.failed

Return the matching device EQN for a given user vector number via the
DEVX interface.

Note:
EQs are owned by the kernel and shared by all user processes.
Basically, a user CQ can point to any EQ.
The kernel doesn't enforce any such limitation today either.

	Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit f6fe01b7181be1751a5d8f19f230eb0d17b9a7b1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/devx.c
#	include/uapi/rdma/mlx5_user_ioctl_cmds.h
diff --cc drivers/infiniband/hw/mlx5/devx.c
index 87116a3b7916,dbf2d61591d3..000000000000
--- a/drivers/infiniband/hw/mlx5/devx.c
+++ b/drivers/infiniband/hw/mlx5/devx.c
@@@ -142,6 -389,75 +142,78 @@@ static bool devx_is_general_cmd(const v
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static int UVERBS_HANDLER(MLX5_IB_METHOD_DEVX_QUERY_EQN)(struct ib_device *ib_dev,
+ 				  struct ib_uverbs_file *file,
+ 				  struct uverbs_attr_bundle *attrs)
+ {
+ 	struct mlx5_ib_dev *dev = to_mdev(ib_dev);
+ 	int user_vector;
+ 	int dev_eqn;
+ 	unsigned int irqn;
+ 	int err;
+ 
+ 	if (uverbs_copy_from(&user_vector, attrs,
+ 			     MLX5_IB_ATTR_DEVX_QUERY_EQN_USER_VEC))
+ 		return -EFAULT;
+ 
+ 	err = mlx5_vector2eqn(dev->mdev, user_vector, &dev_eqn, &irqn);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	if (uverbs_copy_to(attrs, MLX5_IB_ATTR_DEVX_QUERY_EQN_DEV_EQN,
+ 			   &dev_eqn, sizeof(dev_eqn)))
+ 		return -EFAULT;
+ 
+ 	return 0;
+ }
+ 
+ /*
+  *Security note:
+  * The hardware protection mechanism works like this: Each device object that
+  * is subject to UAR doorbells (QP/SQ/CQ) gets a UAR ID (called uar_page in
+  * the device specification manual) upon its creation. Then upon doorbell,
+  * hardware fetches the object context for which the doorbell was rang, and
+  * validates that the UAR through which the DB was rang matches the UAR ID
+  * of the object.
+  * If no match the doorbell is silently ignored by the hardware. Of course,
+  * the user cannot ring a doorbell on a UAR that was not mapped to it.
+  * Now in devx, as the devx kernel does not manipulate the QP/SQ/CQ command
+  * mailboxes (except tagging them with UID), we expose to the user its UAR
+  * ID, so it can embed it in these objects in the expected specification
+  * format. So the only thing the user can do is hurt itself by creating a
+  * QP/SQ/CQ with a UAR ID other than his, and then in this case other users
+  * may ring a doorbell on its objects.
+  * The consequence of that will be that another user can schedule a QP/SQ
+  * of the buggy user for execution (just insert it to the hardware schedule
+  * queue or arm its CQ for event generation), no further harm is expected.
+  */
+ static int UVERBS_HANDLER(MLX5_IB_METHOD_DEVX_QUERY_UAR)(struct ib_device *ib_dev,
+ 				  struct ib_uverbs_file *file,
+ 				  struct uverbs_attr_bundle *attrs)
+ {
+ 	struct mlx5_ib_ucontext *c = devx_ufile2uctx(file);
+ 	u32 user_idx;
+ 	s32 dev_idx;
+ 
+ 	if (uverbs_copy_from(&user_idx, attrs,
+ 			     MLX5_IB_ATTR_DEVX_QUERY_UAR_USER_IDX))
+ 		return -EFAULT;
+ 
+ 	dev_idx = bfregn_to_uar_index(to_mdev(ib_dev),
+ 				      &c->bfregi, user_idx, true);
+ 	if (dev_idx < 0)
+ 		return dev_idx;
+ 
+ 	if (uverbs_copy_to(attrs, MLX5_IB_ATTR_DEVX_QUERY_UAR_DEV_IDX,
+ 			   &dev_idx, sizeof(dev_idx)))
+ 		return -EFAULT;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> f6fe01b7181b (IB/mlx5: Add DEVX query EQN support)
  static int UVERBS_HANDLER(MLX5_IB_METHOD_DEVX_OTHER)(struct ib_device *ib_dev,
  				  struct ib_uverbs_file *file,
  				  struct uverbs_attr_bundle *attrs)
@@@ -430,6 -746,276 +502,279 @@@ obj_free
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int UVERBS_HANDLER(MLX5_IB_METHOD_DEVX_OBJ_MODIFY)(struct ib_device *ib_dev,
+ 				   struct ib_uverbs_file *file,
+ 				   struct uverbs_attr_bundle *attrs)
+ {
+ 	struct mlx5_ib_ucontext *c = devx_ufile2uctx(file);
+ 	struct mlx5_ib_dev *dev = to_mdev(ib_dev);
+ 	void *cmd_in = uverbs_attr_get_alloced_ptr(attrs, MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_IN);
+ 	int cmd_out_len = uverbs_attr_get_len(attrs,
+ 					MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_OUT);
+ 	struct ib_uobject *uobj = uverbs_attr_get_uobject(attrs,
+ 							  MLX5_IB_ATTR_DEVX_OBJ_MODIFY_HANDLE);
+ 	void *cmd_out;
+ 	int err;
+ 
+ 	if (!c->devx_uid)
+ 		return -EPERM;
+ 
+ 	if (!devx_is_obj_modify_cmd(cmd_in))
+ 		return -EINVAL;
+ 
+ 	if (!devx_is_valid_obj_id(uobj->object, cmd_in))
+ 		return -EINVAL;
+ 
+ 	cmd_out = kvzalloc(cmd_out_len, GFP_KERNEL);
+ 	if (!cmd_out)
+ 		return -ENOMEM;
+ 
+ 	MLX5_SET(general_obj_in_cmd_hdr, cmd_in, uid, c->devx_uid);
+ 	err = mlx5_cmd_exec(dev->mdev, cmd_in,
+ 			    uverbs_attr_get_len(attrs, MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_IN),
+ 			    cmd_out, cmd_out_len);
+ 	if (err)
+ 		goto other_cmd_free;
+ 
+ 	err = uverbs_copy_to(attrs, MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_OUT,
+ 			     cmd_out, cmd_out_len);
+ 
+ other_cmd_free:
+ 	kvfree(cmd_out);
+ 	return err;
+ }
+ 
+ static int UVERBS_HANDLER(MLX5_IB_METHOD_DEVX_OBJ_QUERY)(struct ib_device *ib_dev,
+ 				   struct ib_uverbs_file *file,
+ 				   struct uverbs_attr_bundle *attrs)
+ {
+ 	struct mlx5_ib_ucontext *c = devx_ufile2uctx(file);
+ 	struct mlx5_ib_dev *dev = to_mdev(ib_dev);
+ 	void *cmd_in = uverbs_attr_get_alloced_ptr(attrs, MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_IN);
+ 	int cmd_out_len = uverbs_attr_get_len(attrs,
+ 					      MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_OUT);
+ 	struct ib_uobject *uobj = uverbs_attr_get_uobject(attrs,
+ 							  MLX5_IB_ATTR_DEVX_OBJ_QUERY_HANDLE);
+ 	void *cmd_out;
+ 	int err;
+ 
+ 	if (!c->devx_uid)
+ 		return -EPERM;
+ 
+ 	if (!devx_is_obj_query_cmd(cmd_in))
+ 		return -EINVAL;
+ 
+ 	if (!devx_is_valid_obj_id(uobj->object, cmd_in))
+ 		return -EINVAL;
+ 
+ 	cmd_out = kvzalloc(cmd_out_len, GFP_KERNEL);
+ 	if (!cmd_out)
+ 		return -ENOMEM;
+ 
+ 	MLX5_SET(general_obj_in_cmd_hdr, cmd_in, uid, c->devx_uid);
+ 	err = mlx5_cmd_exec(dev->mdev, cmd_in,
+ 			    uverbs_attr_get_len(attrs, MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_IN),
+ 			    cmd_out, cmd_out_len);
+ 	if (err)
+ 		goto other_cmd_free;
+ 
+ 	err = uverbs_copy_to(attrs, MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_OUT, cmd_out, cmd_out_len);
+ 
+ other_cmd_free:
+ 	kvfree(cmd_out);
+ 	return err;
+ }
+ 
+ static int devx_umem_get(struct mlx5_ib_dev *dev, struct ib_ucontext *ucontext,
+ 			 struct uverbs_attr_bundle *attrs,
+ 			 struct devx_umem *obj)
+ {
+ 	u64 addr;
+ 	size_t size;
+ 	int access;
+ 	int npages;
+ 	int err;
+ 	u32 page_mask;
+ 
+ 	if (uverbs_copy_from(&addr, attrs, MLX5_IB_ATTR_DEVX_UMEM_REG_ADDR) ||
+ 	    uverbs_copy_from(&size, attrs, MLX5_IB_ATTR_DEVX_UMEM_REG_LEN) ||
+ 	    uverbs_copy_from(&access, attrs, MLX5_IB_ATTR_DEVX_UMEM_REG_ACCESS))
+ 		return -EFAULT;
+ 
+ 	err = ib_check_mr_access(access);
+ 	if (err)
+ 		return err;
+ 
+ 	obj->umem = ib_umem_get(ucontext, addr, size, access, 0);
+ 	if (IS_ERR(obj->umem))
+ 		return PTR_ERR(obj->umem);
+ 
+ 	mlx5_ib_cont_pages(obj->umem, obj->umem->address,
+ 			   MLX5_MKEY_PAGE_SHIFT_MASK, &npages,
+ 			   &obj->page_shift, &obj->ncont, NULL);
+ 
+ 	if (!npages) {
+ 		ib_umem_release(obj->umem);
+ 		return -EINVAL;
+ 	}
+ 
+ 	page_mask = (1 << obj->page_shift) - 1;
+ 	obj->page_offset = obj->umem->address & page_mask;
+ 
+ 	return 0;
+ }
+ 
+ static int devx_umem_reg_cmd_alloc(struct devx_umem *obj,
+ 				   struct devx_umem_reg_cmd *cmd)
+ {
+ 	cmd->inlen = MLX5_ST_SZ_BYTES(create_umem_in) +
+ 		    (MLX5_ST_SZ_BYTES(mtt) * obj->ncont);
+ 	cmd->in = kvzalloc(cmd->inlen, GFP_KERNEL);
+ 	return cmd->in ? 0 : -ENOMEM;
+ }
+ 
+ static void devx_umem_reg_cmd_free(struct devx_umem_reg_cmd *cmd)
+ {
+ 	kvfree(cmd->in);
+ }
+ 
+ static void devx_umem_reg_cmd_build(struct mlx5_ib_dev *dev,
+ 				    struct devx_umem *obj,
+ 				    struct devx_umem_reg_cmd *cmd)
+ {
+ 	void *umem;
+ 	__be64 *mtt;
+ 
+ 	umem = MLX5_ADDR_OF(create_umem_in, cmd->in, umem);
+ 	mtt = (__be64 *)MLX5_ADDR_OF(umem, umem, mtt);
+ 
+ 	MLX5_SET(general_obj_in_cmd_hdr, cmd->in, opcode, MLX5_CMD_OP_CREATE_GENERAL_OBJECT);
+ 	MLX5_SET(general_obj_in_cmd_hdr, cmd->in, obj_type, MLX5_OBJ_TYPE_UMEM);
+ 	MLX5_SET64(umem, umem, num_of_mtt, obj->ncont);
+ 	MLX5_SET(umem, umem, log_page_size, obj->page_shift -
+ 					    MLX5_ADAPTER_PAGE_SHIFT);
+ 	MLX5_SET(umem, umem, page_offset, obj->page_offset);
+ 	mlx5_ib_populate_pas(dev, obj->umem, obj->page_shift, mtt,
+ 			     (obj->umem->writable ? MLX5_IB_MTT_WRITE : 0) |
+ 			     MLX5_IB_MTT_READ);
+ }
+ 
+ static int UVERBS_HANDLER(MLX5_IB_METHOD_DEVX_UMEM_REG)(struct ib_device *ib_dev,
+ 				 struct ib_uverbs_file *file,
+ 				 struct uverbs_attr_bundle *attrs)
+ {
+ 	struct mlx5_ib_ucontext *c = devx_ufile2uctx(file);
+ 	struct mlx5_ib_dev *dev = to_mdev(ib_dev);
+ 	struct devx_umem_reg_cmd cmd;
+ 	struct devx_umem *obj;
+ 	struct ib_uobject *uobj;
+ 	u32 obj_id;
+ 	int err;
+ 
+ 	if (!c->devx_uid)
+ 		return -EPERM;
+ 
+ 	uobj = uverbs_attr_get_uobject(attrs, MLX5_IB_ATTR_DEVX_UMEM_REG_HANDLE);
+ 	obj = kzalloc(sizeof(struct devx_umem), GFP_KERNEL);
+ 	if (!obj)
+ 		return -ENOMEM;
+ 
+ 	err = devx_umem_get(dev, &c->ibucontext, attrs, obj);
+ 	if (err)
+ 		goto err_obj_free;
+ 
+ 	err = devx_umem_reg_cmd_alloc(obj, &cmd);
+ 	if (err)
+ 		goto err_umem_release;
+ 
+ 	devx_umem_reg_cmd_build(dev, obj, &cmd);
+ 
+ 	MLX5_SET(general_obj_in_cmd_hdr, cmd.in, uid, c->devx_uid);
+ 	err = mlx5_cmd_exec(dev->mdev, cmd.in, cmd.inlen, cmd.out,
+ 			    sizeof(cmd.out));
+ 	if (err)
+ 		goto err_umem_reg_cmd_free;
+ 
+ 	obj->mdev = dev->mdev;
+ 	uobj->object = obj;
+ 	devx_obj_build_destroy_cmd(cmd.in, cmd.out, obj->dinbox, &obj->dinlen, &obj_id);
+ 	err = uverbs_copy_to(attrs, MLX5_IB_ATTR_DEVX_UMEM_REG_OUT_ID, &obj_id, sizeof(obj_id));
+ 	if (err)
+ 		goto err_umem_destroy;
+ 
+ 	devx_umem_reg_cmd_free(&cmd);
+ 
+ 	return 0;
+ 
+ err_umem_destroy:
+ 	mlx5_cmd_exec(obj->mdev, obj->dinbox, obj->dinlen, cmd.out, sizeof(cmd.out));
+ err_umem_reg_cmd_free:
+ 	devx_umem_reg_cmd_free(&cmd);
+ err_umem_release:
+ 	ib_umem_release(obj->umem);
+ err_obj_free:
+ 	kfree(obj);
+ 	return err;
+ }
+ 
+ static int UVERBS_HANDLER(MLX5_IB_METHOD_DEVX_UMEM_DEREG)(struct ib_device *ib_dev,
+ 				   struct ib_uverbs_file *file,
+ 				   struct uverbs_attr_bundle *attrs)
+ {
+ 	return 0;
+ }
+ 
+ static int devx_umem_cleanup(struct ib_uobject *uobject,
+ 			     enum rdma_remove_reason why)
+ {
+ 	struct devx_umem *obj = uobject->object;
+ 	u32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)];
+ 	int err;
+ 
+ 	err = mlx5_cmd_exec(obj->mdev, obj->dinbox, obj->dinlen, out, sizeof(out));
+ 	if (err && why == RDMA_REMOVE_DESTROY)
+ 		return err;
+ 
+ 	ib_umem_release(obj->umem);
+ 	kfree(obj);
+ 	return 0;
+ }
+ 
+ static DECLARE_UVERBS_NAMED_METHOD(MLX5_IB_METHOD_DEVX_UMEM_REG,
+ 	&UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_UMEM_REG_HANDLE,
+ 			 MLX5_IB_OBJECT_DEVX_UMEM,
+ 			 UVERBS_ACCESS_NEW,
+ 			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
+ 	&UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_DEVX_UMEM_REG_ADDR, UVERBS_ATTR_TYPE(u64),
+ 			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
+ 	&UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_DEVX_UMEM_REG_LEN, UVERBS_ATTR_TYPE(u64),
+ 			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
+ 	&UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_DEVX_UMEM_REG_ACCESS, UVERBS_ATTR_TYPE(u32),
+ 			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
+ 	&UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_DEVX_UMEM_REG_OUT_ID, UVERBS_ATTR_TYPE(u32),
+ 			     UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
+ 
+ static DECLARE_UVERBS_NAMED_METHOD(MLX5_IB_METHOD_DEVX_UMEM_DEREG,
+ 	&UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_UMEM_DEREG_HANDLE,
+ 			 MLX5_IB_OBJECT_DEVX_UMEM,
+ 			 UVERBS_ACCESS_DESTROY,
+ 			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
+ 
+ static DECLARE_UVERBS_NAMED_METHOD(MLX5_IB_METHOD_DEVX_QUERY_EQN,
+ 	&UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_DEVX_QUERY_EQN_USER_VEC, UVERBS_ATTR_TYPE(u32),
+ 			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
+ 	&UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_DEVX_QUERY_EQN_DEV_EQN, UVERBS_ATTR_TYPE(u32),
+ 			     UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
+ 
+ static DECLARE_UVERBS_NAMED_METHOD(MLX5_IB_METHOD_DEVX_QUERY_UAR,
+ 	&UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_DEVX_QUERY_UAR_USER_IDX, UVERBS_ATTR_TYPE(u32),
+ 			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
+ 	&UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_DEVX_QUERY_UAR_DEV_IDX, UVERBS_ATTR_TYPE(u32),
+ 			     UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
+ 
++>>>>>>> f6fe01b7181b (IB/mlx5: Add DEVX query EQN support)
  static DECLARE_UVERBS_NAMED_METHOD(MLX5_IB_METHOD_DEVX_OTHER,
  	&UVERBS_ATTR_PTR_IN_SZ(MLX5_IB_ATTR_DEVX_OTHER_CMD_IN,
  			       UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
@@@ -463,8 -1049,40 +808,14 @@@ static DECLARE_UVERBS_NAMED_METHOD(MLX5
  			 UVERBS_ACCESS_DESTROY,
  			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
  
 -static DECLARE_UVERBS_NAMED_METHOD(MLX5_IB_METHOD_DEVX_OBJ_MODIFY,
 -	&UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_MODIFY_HANDLE,
 -			 MLX5_IB_OBJECT_DEVX_OBJ,
 -			 UVERBS_ACCESS_WRITE,
 -			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 -	&UVERBS_ATTR_PTR_IN_SZ(MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_IN,
 -			       UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
 -			       UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY |
 -					UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO |
 -					UVERBS_ATTR_SPEC_F_ALLOC_AND_COPY)),
 -	&UVERBS_ATTR_PTR_OUT_SZ(MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_OUT,
 -				UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_out_cmd_hdr)),
 -				UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY |
 -					 UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO)));
 -
 -static DECLARE_UVERBS_NAMED_METHOD(MLX5_IB_METHOD_DEVX_OBJ_QUERY,
 -	&UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_QUERY_HANDLE,
 -			 MLX5_IB_OBJECT_DEVX_OBJ,
 -			 UVERBS_ACCESS_READ,
 -			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 -	&UVERBS_ATTR_PTR_IN_SZ(MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_IN,
 -			       UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
 -			       UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY |
 -					UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO |
 -					UVERBS_ATTR_SPEC_F_ALLOC_AND_COPY)),
 -	&UVERBS_ATTR_PTR_OUT_SZ(MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_OUT,
 -				UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_out_cmd_hdr)),
 -				UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY |
 -					 UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO)));
 -
  static DECLARE_UVERBS_GLOBAL_METHODS(MLX5_IB_OBJECT_DEVX,
++<<<<<<< HEAD
 +	&UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OTHER));
++=======
+ 	&UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OTHER),
+ 	&UVERBS_METHOD(MLX5_IB_METHOD_DEVX_QUERY_UAR),
+ 	&UVERBS_METHOD(MLX5_IB_METHOD_DEVX_QUERY_EQN));
++>>>>>>> f6fe01b7181b (IB/mlx5: Add DEVX query EQN support)
  
  static DECLARE_UVERBS_NAMED_OBJECT(MLX5_IB_OBJECT_DEVX_OBJ,
  	&UVERBS_TYPE_ALLOC_IDR(0, devx_obj_cleanup),
diff --cc include/uapi/rdma/mlx5_user_ioctl_cmds.h
index 8d285f4555cd,1a05bb4b0b34..000000000000
--- a/include/uapi/rdma/mlx5_user_ioctl_cmds.h
+++ b/include/uapi/rdma/mlx5_user_ioctl_cmds.h
@@@ -47,6 -47,8 +47,11 @@@ enum mlx5_ib_alloc_dm_attrs 
  
  enum mlx5_ib_devx_methods {
  	MLX5_IB_METHOD_DEVX_OTHER  = (1U << UVERBS_ID_NS_SHIFT),
++<<<<<<< HEAD
++=======
+ 	MLX5_IB_METHOD_DEVX_QUERY_UAR,
+ 	MLX5_IB_METHOD_DEVX_QUERY_EQN,
++>>>>>>> f6fe01b7181b (IB/mlx5: Add DEVX query EQN support)
  };
  
  enum  mlx5_ib_devx_other_attrs {
@@@ -64,6 -71,23 +69,26 @@@ enum mlx5_ib_devx_obj_destroy_attrs 
  	MLX5_IB_ATTR_DEVX_OBJ_DESTROY_HANDLE = (1U << UVERBS_ID_NS_SHIFT),
  };
  
++<<<<<<< HEAD
++=======
+ enum mlx5_ib_devx_obj_modify_attrs {
+ 	MLX5_IB_ATTR_DEVX_OBJ_MODIFY_HANDLE = (1U << UVERBS_ID_NS_SHIFT),
+ 	MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_IN,
+ 	MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_OUT,
+ };
+ 
+ enum mlx5_ib_devx_obj_query_attrs {
+ 	MLX5_IB_ATTR_DEVX_OBJ_QUERY_HANDLE = (1U << UVERBS_ID_NS_SHIFT),
+ 	MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_IN,
+ 	MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_OUT,
+ };
+ 
+ enum  mlx5_ib_devx_query_eqn_attrs {
+ 	MLX5_IB_ATTR_DEVX_QUERY_EQN_USER_VEC = (1U << UVERBS_ID_NS_SHIFT),
+ 	MLX5_IB_ATTR_DEVX_QUERY_EQN_DEV_EQN,
+ };
+ 
++>>>>>>> f6fe01b7181b (IB/mlx5: Add DEVX query EQN support)
  enum mlx5_ib_devx_obj_methods {
  	MLX5_IB_METHOD_DEVX_OBJ_CREATE = (1U << UVERBS_ID_NS_SHIFT),
  	MLX5_IB_METHOD_DEVX_OBJ_DESTROY,
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
* Unmerged path include/uapi/rdma/mlx5_user_ioctl_cmds.h
