drm/i915: Extract skl_compute_wm_params()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit c92558aa41722f95160d96b8e1ac8dd36731a836
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/c92558aa.failed

Extract the meat of skl_compute_plane_wm_params() into a lower
level helper that doesn't depend on the plane state. We'll
reuse this for the cursor ddb allocation calculations.

	Cc: Neel Desai <neel.desai@intel.com>
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190312205844.6339-4-ville.syrjala@linux.intel.com
	Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
(cherry picked from commit c92558aa41722f95160d96b8e1ac8dd36731a836)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_pm.c
diff --cc drivers/gpu/drm/i915/intel_pm.c
index a1b763e0c3a9,9e7b4412f7a8..000000000000
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@@ -4483,57 -4584,40 +4483,94 @@@ skl_adjusted_plane_pixel_rate(const str
  }
  
  static int
++<<<<<<< HEAD
 +skl_compute_plane_wm_params(const struct drm_i915_private *dev_priv,
 +			    struct intel_crtc_state *cstate,
 +			    const struct intel_plane_state *intel_pstate,
 +			    struct skl_wm_params *wp, int plane_id)
 +{
 +	struct intel_plane *plane = to_intel_plane(intel_pstate->base.plane);
 +	const struct drm_plane_state *pstate = &intel_pstate->base;
 +	const struct drm_framebuffer *fb = pstate->fb;
 +	uint32_t interm_pbpl;
 +	struct intel_atomic_state *state =
 +		to_intel_atomic_state(cstate->base.state);
 +	bool apply_memory_bw_wa = skl_needs_memory_bw_wa(state);
 +
 +	if (!intel_wm_plane_visible(cstate, intel_pstate))
 +		return 0;
 +
 +	/* only NV12 format has two planes */
 +	if (plane_id == 1 && fb->format->format != DRM_FORMAT_NV12) {
 +		DRM_DEBUG_KMS("Non NV12 format have single plane\n");
 +		return -EINVAL;
 +	}
 +
 +	wp->y_tiled = fb->modifier == I915_FORMAT_MOD_Y_TILED ||
 +		      fb->modifier == I915_FORMAT_MOD_Yf_TILED ||
 +		      fb->modifier == I915_FORMAT_MOD_Y_TILED_CCS ||
 +		      fb->modifier == I915_FORMAT_MOD_Yf_TILED_CCS;
 +	wp->x_tiled = fb->modifier == I915_FORMAT_MOD_X_TILED;
 +	wp->rc_surface = fb->modifier == I915_FORMAT_MOD_Y_TILED_CCS ||
 +			 fb->modifier == I915_FORMAT_MOD_Yf_TILED_CCS;
 +	wp->is_planar = fb->format->format == DRM_FORMAT_NV12;
 +
 +	if (plane->id == PLANE_CURSOR) {
 +		wp->width = intel_pstate->base.crtc_w;
 +	} else {
 +		/*
 +		 * Src coordinates are already rotated by 270 degrees for
 +		 * the 90/270 degree plane rotation cases (to match the
 +		 * GTT mapping), hence no need to account for rotation here.
 +		 */
 +		wp->width = drm_rect_width(&intel_pstate->base.src) >> 16;
 +	}
 +
 +	if (plane_id == 1 && wp->is_planar)
 +		wp->width /= 2;
 +
 +	wp->cpp = fb->format->cpp[plane_id];
 +	wp->plane_pixel_rate = skl_adjusted_plane_pixel_rate(cstate,
 +							     intel_pstate);
 +
 +	if (INTEL_GEN(dev_priv) >= 11 &&
 +	    fb->modifier == I915_FORMAT_MOD_Yf_TILED && wp->cpp == 8)
++=======
+ skl_compute_wm_params(const struct intel_crtc_state *crtc_state,
+ 		      int width, const struct drm_format_info *format,
+ 		      u64 modifier, unsigned int rotation,
+ 		      u32 plane_pixel_rate, struct skl_wm_params *wp,
+ 		      int color_plane)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->base.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	u32 interm_pbpl;
+ 
+ 	/* only planar format has two planes */
+ 	if (color_plane == 1 && !is_planar_yuv_format(format->format)) {
+ 		DRM_DEBUG_KMS("Non planar format have single plane\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	wp->y_tiled = modifier == I915_FORMAT_MOD_Y_TILED ||
+ 		      modifier == I915_FORMAT_MOD_Yf_TILED ||
+ 		      modifier == I915_FORMAT_MOD_Y_TILED_CCS ||
+ 		      modifier == I915_FORMAT_MOD_Yf_TILED_CCS;
+ 	wp->x_tiled = modifier == I915_FORMAT_MOD_X_TILED;
+ 	wp->rc_surface = modifier == I915_FORMAT_MOD_Y_TILED_CCS ||
+ 			 modifier == I915_FORMAT_MOD_Yf_TILED_CCS;
+ 	wp->is_planar = is_planar_yuv_format(format->format);
+ 
+ 	wp->width = width;
+ 	if (color_plane == 1 && wp->is_planar)
+ 		wp->width /= 2;
+ 
+ 	wp->cpp = format->cpp[color_plane];
+ 	wp->plane_pixel_rate = plane_pixel_rate;
+ 
+ 	if (INTEL_GEN(dev_priv) >= 11 &&
+ 	    modifier == I915_FORMAT_MOD_Yf_TILED  && wp->cpp == 1)
++>>>>>>> c92558aa4172 (drm/i915: Extract skl_compute_wm_params())
  		wp->dbuf_block_size = 256;
  	else
  		wp->dbuf_block_size = 512;
@@@ -4590,29 -4674,58 +4627,60 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int skl_compute_plane_wm(const struct drm_i915_private *dev_priv,
 +				struct intel_crtc_state *cstate,
 +				const struct intel_plane_state *intel_pstate,
 +				uint16_t ddb_allocation,
 +				int level,
 +				const struct skl_wm_params *wp,
 +				const struct skl_wm_level *result_prev,
 +				struct skl_wm_level *result /* out */)
++=======
+ static int
+ skl_compute_plane_wm_params(const struct intel_crtc_state *crtc_state,
+ 			    const struct intel_plane_state *plane_state,
+ 			    struct skl_wm_params *wp, int color_plane)
+ {
+ 	struct intel_plane *plane = to_intel_plane(plane_state->base.plane);
+ 	const struct drm_framebuffer *fb = plane_state->base.fb;
+ 	int width;
+ 
+ 	if (plane->id == PLANE_CURSOR) {
+ 		width = plane_state->base.crtc_w;
+ 	} else {
+ 		/*
+ 		 * Src coordinates are already rotated by 270 degrees for
+ 		 * the 90/270 degree plane rotation cases (to match the
+ 		 * GTT mapping), hence no need to account for rotation here.
+ 		 */
+ 		width = drm_rect_width(&plane_state->base.src) >> 16;
+ 	}
+ 
+ 	return skl_compute_wm_params(crtc_state, width,
+ 				     fb->format, fb->modifier,
+ 				     plane_state->base.rotation,
+ 				     skl_adjusted_plane_pixel_rate(crtc_state, plane_state),
+ 				     wp, color_plane);
+ }
+ 
+ static bool skl_wm_has_lines(struct drm_i915_private *dev_priv, int level)
++>>>>>>> c92558aa4172 (drm/i915: Extract skl_compute_wm_params())
  {
 -	if (INTEL_GEN(dev_priv) >= 10 || IS_GEMINILAKE(dev_priv))
 -		return true;
 -
 -	/* The number of lines are ignored for the level 0 watermark. */
 -	return level > 0;
 -}
 -
 -static void skl_compute_plane_wm(const struct intel_crtc_state *cstate,
 -				 int level,
 -				 const struct skl_wm_params *wp,
 -				 const struct skl_wm_level *result_prev,
 -				 struct skl_wm_level *result /* out */)
 -{
 -	struct drm_i915_private *dev_priv = to_i915(cstate->base.crtc->dev);
 -	u32 latency = dev_priv->wm.skl_latency[level];
 +	const struct drm_plane_state *pstate = &intel_pstate->base;
 +	uint32_t latency = dev_priv->wm.skl_latency[level];
  	uint_fixed_16_16_t method1, method2;
  	uint_fixed_16_16_t selected_result;
 -	u32 res_blocks, res_lines, min_ddb_alloc = 0;
 +	uint32_t res_blocks, res_lines;
 +	struct intel_atomic_state *state =
 +		to_intel_atomic_state(cstate->base.state);
 +	bool apply_memory_bw_wa = skl_needs_memory_bw_wa(state);
 +	uint32_t min_disp_buf_needed;
  
 -	if (latency == 0) {
 -		/* reject it */
 -		result->min_ddb_alloc = U16_MAX;
 -		return;
 +	if (latency == 0 ||
 +	    !intel_wm_plane_visible(cstate, intel_pstate)) {
 +		result->plane_en = false;
 +		return 0;
  	}
  
  	/* Display WA #1141: kbl,cfl */
* Unmerged path drivers/gpu/drm/i915/intel_pm.c
