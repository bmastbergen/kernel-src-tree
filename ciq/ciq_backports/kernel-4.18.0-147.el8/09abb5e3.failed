KVM: nVMX: call kvm_skip_emulated_instruction in nested_vmx_{fail,succeed}

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [kvm] KVM: nVMX: call kvm_skip_emulated_instruction in nested_vmx_{fail, succeed} (Vitaly Kuznetsov) [1692804]
Rebuild_FUZZ: 99.33%
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 09abb5e3e5e50eef72b09adaa798b7ef0ce9239b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/09abb5e3.failed

... as every invocation of nested_vmx_{fail,succeed} is immediately
followed by a call to kvm_skip_emulated_instruction().  This saves
a bit of code and eliminates some silly paths, e.g. nested_vmx_run()
ended up with a goto label purely used to call and return
kvm_skip_emulated_instruction().

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Reviewed-by: Jim Mattson <jmattson@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 09abb5e3e5e50eef72b09adaa798b7ef0ce9239b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index cdbb9746c7c6,2d120de9054e..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -8901,17 -8850,9 +8868,23 @@@ static int handle_vmptrld(struct kvm_vc
  		struct vmcs12 *new_vmcs12;
  		struct page *page;
  		page = kvm_vcpu_gpa_to_page(vcpu, vmptr);
++<<<<<<< HEAD
 +		if (is_error_page(page)) {
 +			/*
 +			 * Reads from an unbacked page return all 1s,
 +			 * which means that the 32 bits located at the
 +			 * given physical address won't match the required
 +			 * VMCS12_REVISION identifier.
 +			 */
 +			nested_vmx_failValid(vcpu,
 +				VMXERR_VMPTRLD_INCORRECT_VMCS_REVISION_ID);
 +			return kvm_skip_emulated_instruction(vcpu);
 +		}
++=======
+ 		if (is_error_page(page))
+ 			return nested_vmx_failInvalid(vcpu);
+ 
++>>>>>>> 09abb5e3e5e5 (KVM: nVMX: call kvm_skip_emulated_instruction in nested_vmx_{fail,succeed})
  		new_vmcs12 = kmap(page);
  		if (new_vmcs12->hdr.revision_id != VMCS12_REVISION ||
  		    (new_vmcs12->hdr.shadow_vmcs &&
* Unmerged path arch/x86/kvm/vmx.c
