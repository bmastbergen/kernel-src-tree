net: use indirect call wrappers at GRO transport layer

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [net] use indirect call wrappers at GRO transport layer (Paolo Abeni) [1700747]
Rebuild_FUZZ: 95.15%
commit-author Paolo Abeni <pabeni@redhat.com>
commit 028e0a4766844e7eeb31b93479ea6dd40cfc2895
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/028e0a47.failed

This avoids an indirect call in the receive path for TCP and UDP
packets. TCP takes precedence on UDP, so that we have a single
additional conditional in the common case.

When IPV6 is build as module, all gro symbols except UDPv6 are
builtin, while the latter belong to the ipv6 module, so we
need some special care.

v1 -> v2:
 - adapted to INDIRECT_CALL_ changes
v2 -> v3:
 - fix build issue with CONFIG_IPV6=m

	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 028e0a4766844e7eeb31b93479ea6dd40cfc2895)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/af_inet.c
#	net/ipv4/tcp_offload.c
#	net/ipv4/udp_offload.c
#	net/ipv6/ip6_offload.c
#	net/ipv6/tcpv6_offload.c
#	net/ipv6/udp_offload.c
diff --cc net/ipv4/af_inet.c
index c0e7a847efb4,0dfb72c46671..000000000000
--- a/net/ipv4/af_inet.c
+++ b/net/ipv4/af_inet.c
@@@ -1386,12 -1385,16 +1386,20 @@@ out
  }
  EXPORT_SYMBOL(inet_gso_segment);
  
++<<<<<<< HEAD
 +struct sk_buff **inet_gro_receive(struct sk_buff **head, struct sk_buff *skb)
++=======
+ INDIRECT_CALLABLE_DECLARE(struct sk_buff *tcp4_gro_receive(struct list_head *,
+ 							   struct sk_buff *));
+ INDIRECT_CALLABLE_DECLARE(struct sk_buff *udp4_gro_receive(struct list_head *,
+ 							   struct sk_buff *));
+ struct sk_buff *inet_gro_receive(struct list_head *head, struct sk_buff *skb)
++>>>>>>> 028e0a476684 (net: use indirect call wrappers at GRO transport layer)
  {
  	const struct net_offload *ops;
 -	struct sk_buff *pp = NULL;
 -	const struct iphdr *iph;
 +	struct sk_buff **pp = NULL;
  	struct sk_buff *p;
 +	const struct iphdr *iph;
  	unsigned int hlen;
  	unsigned int off;
  	unsigned int id;
diff --cc net/ipv4/tcp_offload.c
index 9628329d4d43,0fbf7d4df9da..000000000000
--- a/net/ipv4/tcp_offload.c
+++ b/net/ipv4/tcp_offload.c
@@@ -305,7 -306,8 +306,12 @@@ int tcp_gro_complete(struct sk_buff *sk
  }
  EXPORT_SYMBOL(tcp_gro_complete);
  
++<<<<<<< HEAD
 +static struct sk_buff **tcp4_gro_receive(struct sk_buff **head, struct sk_buff *skb)
++=======
+ INDIRECT_CALLABLE_SCOPE
+ struct sk_buff *tcp4_gro_receive(struct list_head *head, struct sk_buff *skb)
++>>>>>>> 028e0a476684 (net: use indirect call wrappers at GRO transport layer)
  {
  	/* Don't bother verifying checksum if we're going to flush anyway. */
  	if (!NAPI_GRO_CB(skb)->flush &&
diff --cc net/ipv4/udp_offload.c
index 69c54540d5b4,9a141a6cf1a0..000000000000
--- a/net/ipv4/udp_offload.c
+++ b/net/ipv4/udp_offload.c
@@@ -399,8 -452,8 +400,13 @@@ out
  }
  EXPORT_SYMBOL(udp_gro_receive);
  
++<<<<<<< HEAD
 +static struct sk_buff **udp4_gro_receive(struct sk_buff **head,
 +					 struct sk_buff *skb)
++=======
+ INDIRECT_CALLABLE_SCOPE
+ struct sk_buff *udp4_gro_receive(struct list_head *head, struct sk_buff *skb)
++>>>>>>> 028e0a476684 (net: use indirect call wrappers at GRO transport layer)
  {
  	struct udphdr *uh = udp_gro_udphdr(skb);
  
diff --cc net/ipv6/ip6_offload.c
index c6b75e96868c,5c045691c302..000000000000
--- a/net/ipv6/ip6_offload.c
+++ b/net/ipv6/ip6_offload.c
@@@ -164,11 -181,15 +181,20 @@@ static int ipv6_exthdrs_len(struct ipv6
  	return len;
  }
  
++<<<<<<< HEAD
 +static struct sk_buff **ipv6_gro_receive(struct sk_buff **head,
 +					 struct sk_buff *skb)
++=======
+ INDIRECT_CALLABLE_DECLARE(struct sk_buff *tcp6_gro_receive(struct list_head *,
+ 							   struct sk_buff *));
+ INDIRECT_CALLABLE_DECLARE(struct sk_buff *udp6_gro_receive(struct list_head *,
+ 							   struct sk_buff *));
+ INDIRECT_CALLABLE_SCOPE struct sk_buff *ipv6_gro_receive(struct list_head *head,
+ 							 struct sk_buff *skb)
++>>>>>>> 028e0a476684 (net: use indirect call wrappers at GRO transport layer)
  {
  	const struct net_offload *ops;
 -	struct sk_buff *pp = NULL;
 +	struct sk_buff **pp = NULL;
  	struct sk_buff *p;
  	struct ipv6hdr *iph;
  	unsigned int nlen;
@@@ -294,7 -323,9 +321,13 @@@ static struct sk_buff **ip4ip6_gro_rece
  	return inet_gro_receive(head, skb);
  }
  
++<<<<<<< HEAD
 +static int ipv6_gro_complete(struct sk_buff *skb, int nhoff)
++=======
+ INDIRECT_CALLABLE_DECLARE(int tcp6_gro_complete(struct sk_buff *, int));
+ INDIRECT_CALLABLE_DECLARE(int udp6_gro_complete(struct sk_buff *, int));
+ INDIRECT_CALLABLE_SCOPE int ipv6_gro_complete(struct sk_buff *skb, int nhoff)
++>>>>>>> 028e0a476684 (net: use indirect call wrappers at GRO transport layer)
  {
  	const struct net_offload *ops;
  	struct ipv6hdr *iph = (struct ipv6hdr *)(skb->data + nhoff);
diff --cc net/ipv6/tcpv6_offload.c
index 278e49cd67d4,3179c425d7ff..000000000000
--- a/net/ipv6/tcpv6_offload.c
+++ b/net/ipv6/tcpv6_offload.c
@@@ -15,8 -16,8 +16,13 @@@
  #include <net/ip6_checksum.h>
  #include "ip6_offload.h"
  
++<<<<<<< HEAD
 +static struct sk_buff **tcp6_gro_receive(struct sk_buff **head,
 +					 struct sk_buff *skb)
++=======
+ INDIRECT_CALLABLE_SCOPE
+ struct sk_buff *tcp6_gro_receive(struct list_head *head, struct sk_buff *skb)
++>>>>>>> 028e0a476684 (net: use indirect call wrappers at GRO transport layer)
  {
  	/* Don't bother verifying checksum if we're going to flush anyway. */
  	if (!NAPI_GRO_CB(skb)->flush &&
diff --cc net/ipv6/udp_offload.c
index 03a2ff3fe1e6,83b11d0ac091..000000000000
--- a/net/ipv6/udp_offload.c
+++ b/net/ipv6/udp_offload.c
@@@ -114,8 -115,8 +115,13 @@@ out
  	return segs;
  }
  
++<<<<<<< HEAD
 +static struct sk_buff **udp6_gro_receive(struct sk_buff **head,
 +					 struct sk_buff *skb)
++=======
+ INDIRECT_CALLABLE_SCOPE
+ struct sk_buff *udp6_gro_receive(struct list_head *head, struct sk_buff *skb)
++>>>>>>> 028e0a476684 (net: use indirect call wrappers at GRO transport layer)
  {
  	struct udphdr *uh = udp_gro_udphdr(skb);
  
diff --git a/include/net/inet_common.h b/include/net/inet_common.h
index 384b90c62c0b..5e83762eb228 100644
--- a/include/net/inet_common.h
+++ b/include/net/inet_common.h
@@ -54,4 +54,11 @@ static inline void inet_ctl_sock_destroy(struct sock *sk)
 		sock_release(sk->sk_socket);
 }
 
+#define indirect_call_gro_receive(f2, f1, cb, head, skb)	\
+({								\
+	unlikely(gro_recursion_inc_test(skb)) ?			\
+		NAPI_GRO_CB(skb)->flush |= 1, NULL :		\
+		INDIRECT_CALL_2(cb, f2, f1, head, skb);		\
+})
+
 #endif
* Unmerged path net/ipv4/af_inet.c
* Unmerged path net/ipv4/tcp_offload.c
* Unmerged path net/ipv4/udp_offload.c
* Unmerged path net/ipv6/ip6_offload.c
* Unmerged path net/ipv6/tcpv6_offload.c
* Unmerged path net/ipv6/udp_offload.c
