bpf: Ensure line_info.insn_off cannot point to insn with zero code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Martin KaFai Lau <kafai@fb.com>
commit fdbaa0beb78b7c8847e261fe2c32816e9d1c54cc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/fdbaa0be.failed

This patch rejects a line_info if the bpf insn code referred by
line_info.insn_off is 0. F.e. a broken userspace tool might generate
a line_info.insn_off that points to the second 8 bytes of a BPF_LD_IMM64.

	Signed-off-by: Martin KaFai Lau <kafai@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit fdbaa0beb78b7c8847e261fe2c32816e9d1c54cc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/verifier.c
diff --cc kernel/bpf/verifier.c
index a82a9c1d99de,5c64281d566e..000000000000
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@@ -4510,6 -4782,277 +4510,280 @@@ err_free
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ /* The minimum supported BTF func info size */
+ #define MIN_BPF_FUNCINFO_SIZE	8
+ #define MAX_FUNCINFO_REC_SIZE	252
+ 
+ static int check_btf_func(struct bpf_verifier_env *env,
+ 			  const union bpf_attr *attr,
+ 			  union bpf_attr __user *uattr)
+ {
+ 	u32 i, nfuncs, urec_size, min_size, prev_offset;
+ 	u32 krec_size = sizeof(struct bpf_func_info);
+ 	struct bpf_func_info *krecord;
+ 	const struct btf_type *type;
+ 	struct bpf_prog *prog;
+ 	const struct btf *btf;
+ 	void __user *urecord;
+ 	int ret = 0;
+ 
+ 	nfuncs = attr->func_info_cnt;
+ 	if (!nfuncs)
+ 		return 0;
+ 
+ 	if (nfuncs != env->subprog_cnt) {
+ 		verbose(env, "number of funcs in func_info doesn't match number of subprogs\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	urec_size = attr->func_info_rec_size;
+ 	if (urec_size < MIN_BPF_FUNCINFO_SIZE ||
+ 	    urec_size > MAX_FUNCINFO_REC_SIZE ||
+ 	    urec_size % sizeof(u32)) {
+ 		verbose(env, "invalid func info rec size %u\n", urec_size);
+ 		return -EINVAL;
+ 	}
+ 
+ 	prog = env->prog;
+ 	btf = prog->aux->btf;
+ 
+ 	urecord = u64_to_user_ptr(attr->func_info);
+ 	min_size = min_t(u32, krec_size, urec_size);
+ 
+ 	krecord = kvcalloc(nfuncs, krec_size, GFP_KERNEL | __GFP_NOWARN);
+ 	if (!krecord)
+ 		return -ENOMEM;
+ 
+ 	for (i = 0; i < nfuncs; i++) {
+ 		ret = bpf_check_uarg_tail_zero(urecord, krec_size, urec_size);
+ 		if (ret) {
+ 			if (ret == -E2BIG) {
+ 				verbose(env, "nonzero tailing record in func info");
+ 				/* set the size kernel expects so loader can zero
+ 				 * out the rest of the record.
+ 				 */
+ 				if (put_user(min_size, &uattr->func_info_rec_size))
+ 					ret = -EFAULT;
+ 			}
+ 			goto err_free;
+ 		}
+ 
+ 		if (copy_from_user(&krecord[i], urecord, min_size)) {
+ 			ret = -EFAULT;
+ 			goto err_free;
+ 		}
+ 
+ 		/* check insn_off */
+ 		if (i == 0) {
+ 			if (krecord[i].insn_off) {
+ 				verbose(env,
+ 					"nonzero insn_off %u for the first func info record",
+ 					krecord[i].insn_off);
+ 				ret = -EINVAL;
+ 				goto err_free;
+ 			}
+ 		} else if (krecord[i].insn_off <= prev_offset) {
+ 			verbose(env,
+ 				"same or smaller insn offset (%u) than previous func info record (%u)",
+ 				krecord[i].insn_off, prev_offset);
+ 			ret = -EINVAL;
+ 			goto err_free;
+ 		}
+ 
+ 		if (env->subprog_info[i].start != krecord[i].insn_off) {
+ 			verbose(env, "func_info BTF section doesn't match subprog layout in BPF program\n");
+ 			ret = -EINVAL;
+ 			goto err_free;
+ 		}
+ 
+ 		/* check type_id */
+ 		type = btf_type_by_id(btf, krecord[i].type_id);
+ 		if (!type || BTF_INFO_KIND(type->info) != BTF_KIND_FUNC) {
+ 			verbose(env, "invalid type id %d in func info",
+ 				krecord[i].type_id);
+ 			ret = -EINVAL;
+ 			goto err_free;
+ 		}
+ 
+ 		prev_offset = krecord[i].insn_off;
+ 		urecord += urec_size;
+ 	}
+ 
+ 	prog->aux->func_info = krecord;
+ 	prog->aux->func_info_cnt = nfuncs;
+ 	return 0;
+ 
+ err_free:
+ 	kvfree(krecord);
+ 	return ret;
+ }
+ 
+ static void adjust_btf_func(struct bpf_verifier_env *env)
+ {
+ 	int i;
+ 
+ 	if (!env->prog->aux->func_info)
+ 		return;
+ 
+ 	for (i = 0; i < env->subprog_cnt; i++)
+ 		env->prog->aux->func_info[i].insn_off = env->subprog_info[i].start;
+ }
+ 
+ #define MIN_BPF_LINEINFO_SIZE	(offsetof(struct bpf_line_info, line_col) + \
+ 		sizeof(((struct bpf_line_info *)(0))->line_col))
+ #define MAX_LINEINFO_REC_SIZE	MAX_FUNCINFO_REC_SIZE
+ 
+ static int check_btf_line(struct bpf_verifier_env *env,
+ 			  const union bpf_attr *attr,
+ 			  union bpf_attr __user *uattr)
+ {
+ 	u32 i, s, nr_linfo, ncopy, expected_size, rec_size, prev_offset = 0;
+ 	struct bpf_subprog_info *sub;
+ 	struct bpf_line_info *linfo;
+ 	struct bpf_prog *prog;
+ 	const struct btf *btf;
+ 	void __user *ulinfo;
+ 	int err;
+ 
+ 	nr_linfo = attr->line_info_cnt;
+ 	if (!nr_linfo)
+ 		return 0;
+ 
+ 	rec_size = attr->line_info_rec_size;
+ 	if (rec_size < MIN_BPF_LINEINFO_SIZE ||
+ 	    rec_size > MAX_LINEINFO_REC_SIZE ||
+ 	    rec_size & (sizeof(u32) - 1))
+ 		return -EINVAL;
+ 
+ 	/* Need to zero it in case the userspace may
+ 	 * pass in a smaller bpf_line_info object.
+ 	 */
+ 	linfo = kvcalloc(nr_linfo, sizeof(struct bpf_line_info),
+ 			 GFP_KERNEL | __GFP_NOWARN);
+ 	if (!linfo)
+ 		return -ENOMEM;
+ 
+ 	prog = env->prog;
+ 	btf = prog->aux->btf;
+ 
+ 	s = 0;
+ 	sub = env->subprog_info;
+ 	ulinfo = u64_to_user_ptr(attr->line_info);
+ 	expected_size = sizeof(struct bpf_line_info);
+ 	ncopy = min_t(u32, expected_size, rec_size);
+ 	for (i = 0; i < nr_linfo; i++) {
+ 		err = bpf_check_uarg_tail_zero(ulinfo, expected_size, rec_size);
+ 		if (err) {
+ 			if (err == -E2BIG) {
+ 				verbose(env, "nonzero tailing record in line_info");
+ 				if (put_user(expected_size,
+ 					     &uattr->line_info_rec_size))
+ 					err = -EFAULT;
+ 			}
+ 			goto err_free;
+ 		}
+ 
+ 		if (copy_from_user(&linfo[i], ulinfo, ncopy)) {
+ 			err = -EFAULT;
+ 			goto err_free;
+ 		}
+ 
+ 		/*
+ 		 * Check insn_off to ensure
+ 		 * 1) strictly increasing AND
+ 		 * 2) bounded by prog->len
+ 		 *
+ 		 * The linfo[0].insn_off == 0 check logically falls into
+ 		 * the later "missing bpf_line_info for func..." case
+ 		 * because the first linfo[0].insn_off must be the
+ 		 * first sub also and the first sub must have
+ 		 * subprog_info[0].start == 0.
+ 		 */
+ 		if ((i && linfo[i].insn_off <= prev_offset) ||
+ 		    linfo[i].insn_off >= prog->len) {
+ 			verbose(env, "Invalid line_info[%u].insn_off:%u (prev_offset:%u prog->len:%u)\n",
+ 				i, linfo[i].insn_off, prev_offset,
+ 				prog->len);
+ 			err = -EINVAL;
+ 			goto err_free;
+ 		}
+ 
+ 		if (!prog->insnsi[linfo[i].insn_off].code) {
+ 			verbose(env,
+ 				"Invalid insn code at line_info[%u].insn_off\n",
+ 				i);
+ 			err = -EINVAL;
+ 			goto err_free;
+ 		}
+ 
+ 		if (!btf_name_by_offset(btf, linfo[i].line_off) ||
+ 		    !btf_name_by_offset(btf, linfo[i].file_name_off)) {
+ 			verbose(env, "Invalid line_info[%u].line_off or .file_name_off\n", i);
+ 			err = -EINVAL;
+ 			goto err_free;
+ 		}
+ 
+ 		if (s != env->subprog_cnt) {
+ 			if (linfo[i].insn_off == sub[s].start) {
+ 				sub[s].linfo_idx = i;
+ 				s++;
+ 			} else if (sub[s].start < linfo[i].insn_off) {
+ 				verbose(env, "missing bpf_line_info for func#%u\n", s);
+ 				err = -EINVAL;
+ 				goto err_free;
+ 			}
+ 		}
+ 
+ 		prev_offset = linfo[i].insn_off;
+ 		ulinfo += rec_size;
+ 	}
+ 
+ 	if (s != env->subprog_cnt) {
+ 		verbose(env, "missing bpf_line_info for %u funcs starting from func#%u\n",
+ 			env->subprog_cnt - s, s);
+ 		err = -EINVAL;
+ 		goto err_free;
+ 	}
+ 
+ 	prog->aux->linfo = linfo;
+ 	prog->aux->nr_linfo = nr_linfo;
+ 
+ 	return 0;
+ 
+ err_free:
+ 	kvfree(linfo);
+ 	return err;
+ }
+ 
+ static int check_btf_info(struct bpf_verifier_env *env,
+ 			  const union bpf_attr *attr,
+ 			  union bpf_attr __user *uattr)
+ {
+ 	struct btf *btf;
+ 	int err;
+ 
+ 	if (!attr->func_info_cnt && !attr->line_info_cnt)
+ 		return 0;
+ 
+ 	btf = btf_get_by_fd(attr->prog_btf_fd);
+ 	if (IS_ERR(btf))
+ 		return PTR_ERR(btf);
+ 	env->prog->aux->btf = btf;
+ 
+ 	err = check_btf_func(env, attr, uattr);
+ 	if (err)
+ 		return err;
+ 
+ 	err = check_btf_line(env, attr, uattr);
+ 	if (err)
+ 		return err;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> fdbaa0beb78b (bpf: Ensure line_info.insn_off cannot point to insn with zero code)
  /* check %cur's range satisfies %old's */
  static bool range_within(struct bpf_reg_state *old,
  			 struct bpf_reg_state *cur)
* Unmerged path kernel/bpf/verifier.c
