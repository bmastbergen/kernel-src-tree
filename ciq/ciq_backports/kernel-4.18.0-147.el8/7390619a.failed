x86/resctrl: Move per RDT domain initialization to a separate function

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Xiaochen Shen <xiaochen.shen@intel.com>
commit 7390619ab9ea9fd0ba9f4c3e4749ee20262cba7d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/7390619a.failed

Carve out per rdt_domain initialization code from rdtgroup_init_alloc()
into a separate function.

No functional change, make the code more readable and save us at least
two indentation levels.

	Signed-off-by: Xiaochen Shen <xiaochen.shen@intel.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Cc: Fenghua Yu <fenghua.yu@intel.com>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: pei.p.jia@intel.com
	Cc: Reinette Chatre <reinette.chatre@intel.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Tony Luck <tony.luck@intel.com>
	Cc: x86-ml <x86@kernel.org>
Link: https://lkml.kernel.org/r/1555499329-1170-2-git-send-email-xiaochen.shen@intel.com
(cherry picked from commit 7390619ab9ea9fd0ba9f4c3e4749ee20262cba7d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
diff --cc arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
index 1f3fa4aa5ccc,36ace51ee705..000000000000
--- a/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
+++ b/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
@@@ -2500,54 -2605,9 +2558,60 @@@ static int rdtgroup_init_alloc(struct r
  		if (r->rid == RDT_RESOURCE_MBA)
  			continue;
  		list_for_each_entry(d, &r->domains, list) {
++<<<<<<< HEAD:arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
 +			rdt_cdp_peer_get(r, d, &r_cdp, &d_cdp);
 +			d->have_new_ctrl = false;
 +			d->new_ctrl = r->cache.shareable_bits;
 +			used_b = r->cache.shareable_bits;
 +			ctrl = d->ctrl_val;
 +			for (i = 0; i < r->num_closid; i++, ctrl++) {
 +				if (closid_allocated(i) && i != closid) {
 +					mode = rdtgroup_mode_by_closid(i);
 +					if (mode == RDT_MODE_PSEUDO_LOCKSETUP)
 +						break;
 +					/*
 +					 * If CDP is active include peer
 +					 * domain's usage to ensure there
 +					 * is no overlap with an exclusive
 +					 * group.
 +					 */
 +					if (d_cdp)
 +						peer_ctl = d_cdp->ctrl_val[i];
 +					else
 +						peer_ctl = 0;
 +					used_b |= *ctrl | peer_ctl;
 +					if (mode == RDT_MODE_SHAREABLE)
 +						d->new_ctrl |= *ctrl | peer_ctl;
 +				}
 +			}
 +			if (d->plr && d->plr->cbm > 0)
 +				used_b |= d->plr->cbm;
 +			unused_b = used_b ^ (BIT_MASK(r->cache.cbm_len) - 1);
 +			unused_b &= BIT_MASK(r->cache.cbm_len) - 1;
 +			d->new_ctrl |= unused_b;
 +			/*
 +			 * Force the initial CBM to be valid, user can
 +			 * modify the CBM based on system availability.
 +			 */
 +			cbm_ensure_valid(&d->new_ctrl, r);
 +			/*
 +			 * Assign the u32 CBM to an unsigned long to ensure
 +			 * that bitmap_weight() does not access out-of-bound
 +			 * memory.
 +			 */
 +			tmp_cbm = d->new_ctrl;
 +			if (bitmap_weight(&tmp_cbm, r->cache.cbm_len) <
 +			    r->cache.min_cbm_bits) {
 +				rdt_last_cmd_printf("no space on %s:%d\n",
 +						    r->name, d->id);
 +				return -ENOSPC;
 +			}
 +			d->have_new_ctrl = true;
++=======
+ 			ret = __init_one_rdt_domain(d, r, rdtgrp->closid);
+ 			if (ret < 0)
+ 				return ret;
++>>>>>>> 7390619ab9ea (x86/resctrl: Move per RDT domain initialization to a separate function):arch/x86/kernel/cpu/resctrl/rdtgroup.c
  		}
  	}
  
* Unmerged path arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
