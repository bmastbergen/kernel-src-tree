RDMA/uverbs: Add an ioctl method to destroy an object

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Parav Pandit <parav@mellanox.com>
commit bbc13cda37711eb7baa4091017887a57074f5410
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/bbc13cda.failed

Add an ioctl method to destroy the PD, MR, MW, AH, flow, RWQ indirection
table and XRCD objects by handle which doesn't require any output response
during destruction.

	Signed-off-by: Parav Pandit <parav@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit bbc13cda37711eb7baa4091017887a57074f5410)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_std_types.c
#	drivers/infiniband/core/uverbs_std_types_mr.c
#	include/uapi/rdma/ib_user_ioctl_cmds.h
diff --cc drivers/infiniband/core/uverbs_std_types.c
index 06085446ffc0,8e975f5b1f01..000000000000
--- a/drivers/infiniband/core/uverbs_std_types.c
+++ b/drivers/infiniband/core/uverbs_std_types.c
@@@ -204,113 -214,120 +204,186 @@@ int uverbs_destroy_def_handler(struct i
  {
  	return 0;
  }
 -EXPORT_SYMBOL(uverbs_destroy_def_handler);
  
 -DECLARE_UVERBS_NAMED_OBJECT(
 -	UVERBS_OBJECT_COMP_CHANNEL,
 -	UVERBS_TYPE_ALLOC_FD(sizeof(struct ib_uverbs_completion_event_file),
 -			     uverbs_hot_unplug_completion_event_file,
 -			     &uverbs_event_fops,
 -			     "[infinibandevent]",
 -			     O_RDONLY));
 +/*
 + * This spec is used in order to pass information to the hardware driver in a
 + * legacy way. Every verb that could get driver specific data should get this
 + * spec.
 + */
 +const struct uverbs_attr_def uverbs_uhw_compat_in =
 +	UVERBS_ATTR_PTR_IN_SZ(UVERBS_ATTR_UHW_IN, UVERBS_ATTR_MIN_SIZE(0),
 +			      UA_FLAGS(UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO));
 +const struct uverbs_attr_def uverbs_uhw_compat_out =
 +	UVERBS_ATTR_PTR_OUT_SZ(UVERBS_ATTR_UHW_OUT, UVERBS_ATTR_MIN_SIZE(0),
 +			       UA_FLAGS(UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO));
 +
 +void create_udata(struct uverbs_attr_bundle *ctx, struct ib_udata *udata)
 +{
 +	/*
 +	 * This is for ease of conversion. The purpose is to convert all drivers
 +	 * to use uverbs_attr_bundle instead of ib_udata.
 +	 * Assume attr == 0 is input and attr == 1 is output.
 +	 */
 +	const struct uverbs_attr *uhw_in =
 +		uverbs_attr_get(ctx, UVERBS_ATTR_UHW_IN);
 +	const struct uverbs_attr *uhw_out =
 +		uverbs_attr_get(ctx, UVERBS_ATTR_UHW_OUT);
 +
 +	if (!IS_ERR(uhw_in)) {
 +		udata->inlen = uhw_in->ptr_attr.len;
 +		if (uverbs_attr_ptr_is_inline(uhw_in))
 +			udata->inbuf = &uhw_in->uattr->data;
 +		else
 +			udata->inbuf = u64_to_user_ptr(uhw_in->ptr_attr.data);
 +	} else {
 +		udata->inbuf = NULL;
 +		udata->inlen = 0;
 +	}
  
 -DECLARE_UVERBS_NAMED_OBJECT(
 -	UVERBS_OBJECT_QP,
 -	UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uqp_object), uverbs_free_qp));
 +	if (!IS_ERR(uhw_out)) {
 +		udata->outbuf = u64_to_user_ptr(uhw_out->ptr_attr.data);
 +		udata->outlen = uhw_out->ptr_attr.len;
 +	} else {
 +		udata->outbuf = NULL;
 +		udata->outlen = 0;
 +	}
 +}
 +
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_COMP_CHANNEL,
 +			    &UVERBS_TYPE_ALLOC_FD(0,
 +						  sizeof(struct ib_uverbs_completion_event_file),
 +						  uverbs_hot_unplug_completion_event_file,
 +						  &uverbs_event_fops,
 +						  "[infinibandevent]", O_RDONLY));
 +
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_QP,
 +			    &UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uqp_object), 0,
 +						      uverbs_free_qp));
  
+ DECLARE_UVERBS_NAMED_METHOD_DESTROY(
+ 	UVERBS_METHOD_MW_DESTROY,
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_DESTROY_MW_HANDLE,
+ 			UVERBS_OBJECT_MW,
+ 			UVERBS_ACCESS_DESTROY,
+ 			UA_MANDATORY));
+ 
  DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_MW,
++<<<<<<< HEAD
 +			    &UVERBS_TYPE_ALLOC_IDR(0, uverbs_free_mw));
++=======
+ 			    UVERBS_TYPE_ALLOC_IDR(uverbs_free_mw),
+ 			    &UVERBS_METHOD(UVERBS_METHOD_MW_DESTROY));
++>>>>>>> bbc13cda3771 (RDMA/uverbs: Add an ioctl method to destroy an object)
  
 -DECLARE_UVERBS_NAMED_OBJECT(
 -	UVERBS_OBJECT_SRQ,
 -	UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_usrq_object),
 -				 uverbs_free_srq));
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_SRQ,
 +			    &UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_usrq_object), 0,
 +						      uverbs_free_srq));
  
+ DECLARE_UVERBS_NAMED_METHOD_DESTROY(
+ 	UVERBS_METHOD_AH_DESTROY,
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_DESTROY_AH_HANDLE,
+ 			UVERBS_OBJECT_AH,
+ 			UVERBS_ACCESS_DESTROY,
+ 			UA_MANDATORY));
+ 
  DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_AH,
++<<<<<<< HEAD
 +			    &UVERBS_TYPE_ALLOC_IDR(0, uverbs_free_ah));
 +
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_FLOW,
 +			    &UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uflow_object),
 +						      0, uverbs_free_flow));
++=======
+ 			    UVERBS_TYPE_ALLOC_IDR(uverbs_free_ah),
+ 			    &UVERBS_METHOD(UVERBS_METHOD_AH_DESTROY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD_DESTROY(
+ 	UVERBS_METHOD_FLOW_DESTROY,
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_DESTROY_FLOW_HANDLE,
+ 			UVERBS_OBJECT_FLOW,
+ 			UVERBS_ACCESS_DESTROY,
+ 			UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_OBJECT(
+ 	UVERBS_OBJECT_FLOW,
+ 	UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uflow_object),
+ 				 uverbs_free_flow),
+ 			    &UVERBS_METHOD(UVERBS_METHOD_FLOW_DESTROY));
++>>>>>>> bbc13cda3771 (RDMA/uverbs: Add an ioctl method to destroy an object)
  
 -DECLARE_UVERBS_NAMED_OBJECT(
 -	UVERBS_OBJECT_WQ,
 -	UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uwq_object), uverbs_free_wq));
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_WQ,
 +			    &UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uwq_object), 0,
 +						      uverbs_free_wq));
  
+ DECLARE_UVERBS_NAMED_METHOD_DESTROY(
+ 	UVERBS_METHOD_RWQ_IND_TBL_DESTROY,
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_DESTROY_RWQ_IND_TBL_HANDLE,
+ 			UVERBS_OBJECT_RWQ_IND_TBL,
+ 			UVERBS_ACCESS_DESTROY,
+ 			UA_MANDATORY));
+ 
  DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_RWQ_IND_TBL,
++<<<<<<< HEAD
 +			    &UVERBS_TYPE_ALLOC_IDR(0, uverbs_free_rwq_ind_tbl));
 +
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_XRCD,
 +			    &UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uxrcd_object), 0,
 +						      uverbs_free_xrcd));
 +
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_PD,
 +			    /* 2 is used in order to free the PD after MRs */
 +			    &UVERBS_TYPE_ALLOC_IDR(2, uverbs_free_pd));
++=======
+ 			    UVERBS_TYPE_ALLOC_IDR(uverbs_free_rwq_ind_tbl),
+ 			    &UVERBS_METHOD(UVERBS_METHOD_RWQ_IND_TBL_DESTROY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD_DESTROY(
+ 	UVERBS_METHOD_XRCD_DESTROY,
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_DESTROY_XRCD_HANDLE,
+ 			UVERBS_OBJECT_XRCD,
+ 			UVERBS_ACCESS_DESTROY,
+ 			UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_OBJECT(
+ 	UVERBS_OBJECT_XRCD,
+ 	UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uxrcd_object),
+ 				 uverbs_free_xrcd),
+ 			    &UVERBS_METHOD(UVERBS_METHOD_XRCD_DESTROY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD_DESTROY(
+ 	UVERBS_METHOD_PD_DESTROY,
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_DESTROY_PD_HANDLE,
+ 			UVERBS_OBJECT_PD,
+ 			UVERBS_ACCESS_DESTROY,
+ 			UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_PD,
+ 			    UVERBS_TYPE_ALLOC_IDR(uverbs_free_pd),
+ 			    &UVERBS_METHOD(UVERBS_METHOD_PD_DESTROY));
 -
 -const struct uapi_definition uverbs_def_obj_intf[] = {
 -	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_PD,
 -				      UAPI_DEF_OBJ_NEEDS_FN(dealloc_pd)),
 -	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_COMP_CHANNEL,
 -				      UAPI_DEF_OBJ_NEEDS_FN(dealloc_pd)),
 -	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_QP,
 -				      UAPI_DEF_OBJ_NEEDS_FN(destroy_qp)),
 -	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_AH,
 -				      UAPI_DEF_OBJ_NEEDS_FN(destroy_ah)),
 -	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_MW,
 -				      UAPI_DEF_OBJ_NEEDS_FN(dealloc_mw)),
 -	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_SRQ,
 -				      UAPI_DEF_OBJ_NEEDS_FN(destroy_srq)),
 -	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_FLOW,
 -				      UAPI_DEF_OBJ_NEEDS_FN(destroy_flow)),
 -	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_WQ,
 -				      UAPI_DEF_OBJ_NEEDS_FN(destroy_wq)),
 -	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(
 -		UVERBS_OBJECT_RWQ_IND_TBL,
 -		UAPI_DEF_OBJ_NEEDS_FN(destroy_rwq_ind_table)),
 -	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_XRCD,
 -				      UAPI_DEF_OBJ_NEEDS_FN(dealloc_xrcd)),
 -	{}
 -};
++>>>>>>> bbc13cda3771 (RDMA/uverbs: Add an ioctl method to destroy an object)
 +
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_DEVICE, NULL);
 +
 +static DECLARE_UVERBS_OBJECT_TREE(uverbs_default_objects,
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_DEVICE),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_PD),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_MR),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_COMP_CHANNEL),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_CQ),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_QP),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_AH),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_MW),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_SRQ),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_FLOW),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_WQ),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_RWQ_IND_TBL),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_XRCD),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_FLOW_ACTION),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_DM),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_COUNTERS));
 +
 +const struct uverbs_object_tree_def *uverbs_default_get_objects(void)
 +{
 +	return &uverbs_default_objects;
 +}
 +EXPORT_SYMBOL_GPL(uverbs_default_get_objects);
diff --cc drivers/infiniband/core/uverbs_std_types_mr.c
index 68f7cadf088f,a034352ff60f..000000000000
--- a/drivers/infiniband/core/uverbs_std_types_mr.c
+++ b/drivers/infiniband/core/uverbs_std_types_mr.c
@@@ -115,33 -114,50 +115,54 @@@ err_dereg
  	return ret;
  }
  
 -DECLARE_UVERBS_NAMED_METHOD(
 -	UVERBS_METHOD_DM_MR_REG,
 -	UVERBS_ATTR_IDR(UVERBS_ATTR_REG_DM_MR_HANDLE,
 -			UVERBS_OBJECT_MR,
 -			UVERBS_ACCESS_NEW,
 -			UA_MANDATORY),
 -	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_REG_DM_MR_OFFSET,
 -			   UVERBS_ATTR_TYPE(u64),
 -			   UA_MANDATORY),
 -	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_REG_DM_MR_LENGTH,
 -			   UVERBS_ATTR_TYPE(u64),
 -			   UA_MANDATORY),
 -	UVERBS_ATTR_IDR(UVERBS_ATTR_REG_DM_MR_PD_HANDLE,
 -			UVERBS_OBJECT_PD,
 -			UVERBS_ACCESS_READ,
 -			UA_MANDATORY),
 -	UVERBS_ATTR_FLAGS_IN(UVERBS_ATTR_REG_DM_MR_ACCESS_FLAGS,
 -			     enum ib_access_flags),
 -	UVERBS_ATTR_IDR(UVERBS_ATTR_REG_DM_MR_DM_HANDLE,
 -			UVERBS_OBJECT_DM,
 -			UVERBS_ACCESS_READ,
 -			UA_MANDATORY),
 -	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_REG_DM_MR_RESP_LKEY,
 -			    UVERBS_ATTR_TYPE(u32),
 -			    UA_MANDATORY),
 -	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_REG_DM_MR_RESP_RKEY,
 +static DECLARE_UVERBS_NAMED_METHOD(UVERBS_METHOD_DM_MR_REG,
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_REG_DM_MR_HANDLE, UVERBS_OBJECT_MR,
 +			 UVERBS_ACCESS_NEW,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_REG_DM_MR_OFFSET,
 +			    UVERBS_ATTR_TYPE(u64),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_REG_DM_MR_LENGTH,
 +			    UVERBS_ATTR_TYPE(u64),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_REG_DM_MR_PD_HANDLE, UVERBS_OBJECT_PD,
 +			 UVERBS_ACCESS_READ,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_REG_DM_MR_ACCESS_FLAGS,
  			    UVERBS_ATTR_TYPE(u32),
 -			    UA_MANDATORY));
 -
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_REG_DM_MR_DM_HANDLE, UVERBS_OBJECT_DM,
 +			 UVERBS_ACCESS_READ,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_REG_DM_MR_RESP_LKEY,
 +			     UVERBS_ATTR_TYPE(u32),
 +			     UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_REG_DM_MR_RESP_RKEY,
 +			     UVERBS_ATTR_TYPE(u32),
 +			     UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
 +
++<<<<<<< HEAD
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_MR,
 +			    /* 1 is used in order to free the MR after all the MWs */
 +			    &UVERBS_TYPE_ALLOC_IDR(1, uverbs_free_mr),
 +			    &UVERBS_METHOD(UVERBS_METHOD_DM_MR_REG));
++=======
+ DECLARE_UVERBS_NAMED_METHOD_DESTROY(
+ 	UVERBS_METHOD_MR_DESTROY,
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_DESTROY_MR_HANDLE,
+ 			UVERBS_OBJECT_MR,
+ 			UVERBS_ACCESS_DESTROY,
+ 			UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_OBJECT(
+ 	UVERBS_OBJECT_MR,
+ 	UVERBS_TYPE_ALLOC_IDR(uverbs_free_mr),
+ 	&UVERBS_METHOD(UVERBS_METHOD_DM_MR_REG),
+ 	&UVERBS_METHOD(UVERBS_METHOD_MR_DESTROY));
+ 
+ const struct uapi_definition uverbs_def_obj_mr[] = {
+ 	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_MR,
+ 				      UAPI_DEF_OBJ_NEEDS_FN(dereg_mr)),
+ 	{}
+ };
++>>>>>>> bbc13cda3771 (RDMA/uverbs: Add an ioctl method to destroy an object)
diff --cc include/uapi/rdma/ib_user_ioctl_cmds.h
index 2c881aaf05c2,fbc92d0f0dcd..000000000000
--- a/include/uapi/rdma/ib_user_ioctl_cmds.h
+++ b/include/uapi/rdma/ib_user_ioctl_cmds.h
@@@ -157,4 -173,57 +162,60 @@@ enum uverbs_methods_actions_counters_op
  	UVERBS_METHOD_COUNTERS_READ,
  };
  
++<<<<<<< HEAD
++=======
+ enum uverbs_attrs_info_handles_id {
+ 	UVERBS_ATTR_INFO_OBJECT_ID,
+ 	UVERBS_ATTR_INFO_TOTAL_HANDLES,
+ 	UVERBS_ATTR_INFO_HANDLES_LIST,
+ };
+ 
+ enum uverbs_methods_pd {
+ 	UVERBS_METHOD_PD_DESTROY,
+ };
+ 
+ enum uverbs_attrs_pd_destroy_ids {
+ 	UVERBS_ATTR_DESTROY_PD_HANDLE,
+ };
+ 
+ enum uverbs_methods_mw {
+ 	UVERBS_METHOD_MW_DESTROY,
+ };
+ 
+ enum uverbs_attrs_mw_destroy_ids {
+ 	UVERBS_ATTR_DESTROY_MW_HANDLE,
+ };
+ 
+ enum uverbs_methods_xrcd {
+ 	UVERBS_METHOD_XRCD_DESTROY,
+ };
+ 
+ enum uverbs_attrs_xrcd_destroy_ids {
+ 	UVERBS_ATTR_DESTROY_XRCD_HANDLE,
+ };
+ 
+ enum uverbs_methods_ah {
+ 	UVERBS_METHOD_AH_DESTROY,
+ };
+ 
+ enum uverbs_attrs_ah_destroy_ids {
+ 	UVERBS_ATTR_DESTROY_AH_HANDLE,
+ };
+ 
+ enum uverbs_methods_rwq_ind_tbl {
+ 	UVERBS_METHOD_RWQ_IND_TBL_DESTROY,
+ };
+ 
+ enum uverbs_attrs_rwq_ind_tbl_destroy_ids {
+ 	UVERBS_ATTR_DESTROY_RWQ_IND_TBL_HANDLE,
+ };
+ 
+ enum uverbs_methods_flow {
+ 	UVERBS_METHOD_FLOW_DESTROY,
+ };
+ 
+ enum uverbs_attrs_flow_destroy_ids {
+ 	UVERBS_ATTR_DESTROY_FLOW_HANDLE,
+ };
++>>>>>>> bbc13cda3771 (RDMA/uverbs: Add an ioctl method to destroy an object)
  #endif
* Unmerged path drivers/infiniband/core/uverbs_std_types.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_mr.c
* Unmerged path include/uapi/rdma/ib_user_ioctl_cmds.h
