powerpc/mm_iommu: Allow pinning large regions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [powerpc] mm_iommu: Allow pinning large regions (David Gibson) [1629531]
Rebuild_FUZZ: 90.24%
commit-author Alexey Kardashevskiy <aik@ozlabs.ru>
commit 7a3a4d763837d3aa654cd1059030950410c04d77
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/7a3a4d76.failed

When called with vmas_arg==NULL, get_user_pages_longterm() allocates
an array of nr_pages*8 which can easily get greater that the max order,
for example, registering memory for a 256GB guest does this and fails
in __alloc_pages_nodemask().

This adds a loop over chunks of entries to fit the max order limit.

Fixes: 678e174c4c16 ("powerpc/mm/iommu: allow migration of cma allocated pages during mm_iommu_do_alloc", 2019-03-05)
	Signed-off-by: Alexey Kardashevskiy <aik@ozlabs.ru>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 7a3a4d763837d3aa654cd1059030950410c04d77)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/mm/mmu_context_iommu.c
diff --cc arch/powerpc/mm/mmu_context_iommu.c
index ce8cc69f7901,8330f135294f..000000000000
--- a/arch/powerpc/mm/mmu_context_iommu.c
+++ b/arch/powerpc/mm/mmu_context_iommu.c
@@@ -78,84 -91,23 +78,91 @@@ bool mm_iommu_preregistered(struct mm_s
  }
  EXPORT_SYMBOL_GPL(mm_iommu_preregistered);
  
 -static long mm_iommu_do_alloc(struct mm_struct *mm, unsigned long ua,
 -			      unsigned long entries, unsigned long dev_hpa,
 -			      struct mm_iommu_table_group_mem_t **pmem)
 +/*
 + * Taken from alloc_migrate_target with changes to remove CMA allocations
 + */
 +struct page *new_iommu_non_cma_page(struct page *page, unsigned long private)
  {
++<<<<<<< HEAD
 +	gfp_t gfp_mask = GFP_USER;
 +	struct page *new_page;
++=======
+ 	struct mm_iommu_table_group_mem_t *mem, *mem2;
+ 	long i, ret, locked_entries = 0, pinned = 0;
+ 	unsigned int pageshift;
+ 	unsigned long entry, chunk;
++>>>>>>> 7a3a4d763837 (powerpc/mm_iommu: Allow pinning large regions)
  
 -	if (dev_hpa == MM_IOMMU_TABLE_INVALID_HPA) {
 -		ret = mm_iommu_adjust_locked_vm(mm, entries, true);
 -		if (ret)
 -			return ret;
 +	if (PageCompound(page))
 +		return NULL;
  
 -		locked_entries = entries;
 +	if (PageHighMem(page))
 +		gfp_mask |= __GFP_HIGHMEM;
 +
 +	/*
 +	 * We don't want the allocation to force an OOM if possibe
 +	 */
 +	new_page = alloc_page(gfp_mask | __GFP_NORETRY | __GFP_NOWARN);
 +	return new_page;
 +}
 +
 +static int mm_iommu_move_page_from_cma(struct page *page)
 +{
 +	int ret = 0;
 +	LIST_HEAD(cma_migrate_pages);
 +
 +	/* Ignore huge pages for now */
 +	if (PageCompound(page))
 +		return -EBUSY;
 +
 +	lru_add_drain();
 +	ret = isolate_lru_page(page);
 +	if (ret)
 +		return ret;
 +
 +	list_add(&page->lru, &cma_migrate_pages);
 +	put_page(page); /* Drop the gup reference */
 +
 +	ret = migrate_pages(&cma_migrate_pages, new_iommu_non_cma_page,
 +				NULL, 0, MIGRATE_SYNC, MR_CONTIG_RANGE);
 +	if (ret) {
 +		if (!list_empty(&cma_migrate_pages))
 +			putback_movable_pages(&cma_migrate_pages);
  	}
  
 +	return 0;
 +}
 +
 +long mm_iommu_new(struct mm_struct *mm, unsigned long ua, unsigned long entries,
 +		struct mm_iommu_table_group_mem_t **pmem)
 +{
 +	struct mm_iommu_table_group_mem_t *mem;
 +	long i, j, ret = 0, locked_entries = 0;
 +	unsigned int pageshift;
 +	unsigned long flags;
 +	unsigned long cur_ua;
 +	struct page *page = NULL;
 +
 +	mutex_lock(&mem_list_mutex);
 +
 +	list_for_each_entry_rcu(mem, &mm->context.iommu_group_mem_list,
 +			next) {
 +		/* Overlap? */
 +		if ((mem->ua < (ua + (entries << PAGE_SHIFT))) &&
 +				(ua < (mem->ua +
 +				       (mem->entries << PAGE_SHIFT)))) {
 +			ret = -EINVAL;
 +			goto unlock_exit;
 +		}
 +
 +	}
 +
 +	ret = mm_iommu_adjust_locked_vm(mm, entries, true);
 +	if (ret)
 +		goto unlock_exit;
 +
 +	locked_entries = entries;
 +
  	mem = kzalloc(sizeof(*mem), GFP_KERNEL);
  	if (!mem) {
  		ret = -ENOMEM;
@@@ -175,58 -134,48 +182,86 @@@
  		goto unlock_exit;
  	}
  
++<<<<<<< HEAD
++=======
+ 	down_read(&mm->mmap_sem);
+ 	chunk = (1UL << (PAGE_SHIFT + MAX_ORDER - 1)) /
+ 			sizeof(struct vm_area_struct *);
+ 	chunk = min(chunk, entries);
+ 	for (entry = 0; entry < entries; entry += chunk) {
+ 		unsigned long n = min(entries - entry, chunk);
+ 
+ 		ret = get_user_pages_longterm(ua + (entry << PAGE_SHIFT), n,
+ 				FOLL_WRITE, mem->hpages + entry, NULL);
+ 		if (ret == n) {
+ 			pinned += n;
+ 			continue;
+ 		}
+ 		if (ret > 0)
+ 			pinned += ret;
+ 		break;
+ 	}
+ 	up_read(&mm->mmap_sem);
+ 	if (pinned != entries) {
+ 		if (!ret)
+ 			ret = -EFAULT;
+ 		goto free_exit;
+ 	}
+ 
+ 	pageshift = PAGE_SHIFT;
++>>>>>>> 7a3a4d763837 (powerpc/mm_iommu: Allow pinning large regions)
  	for (i = 0; i < entries; ++i) {
 -		struct page *page = mem->hpages[i];
 -
 +		cur_ua = ua + (i << PAGE_SHIFT);
 +		if (1 != get_user_pages_fast(cur_ua,
 +					1/* pages */, 1/* iswrite */, &page)) {
 +			ret = -EFAULT;
 +			for (j = 0; j < i; ++j)
 +				put_page(pfn_to_page(mem->hpas[j] >>
 +						PAGE_SHIFT));
 +			vfree(mem->hpas);
 +			kfree(mem);
 +			goto unlock_exit;
 +		}
  		/*
 -		 * Allow to use larger than 64k IOMMU pages. Only do that
 -		 * if we are backed by hugetlb.
 +		 * If we get a page from the CMA zone, since we are going to
 +		 * be pinning these entries, we might as well move them out
 +		 * of the CMA zone if possible. NOTE: faulting in + migration
 +		 * can be expensive. Batching can be considered later
  		 */
 -		if ((mem->pageshift > PAGE_SHIFT) && PageHuge(page)) {
 +		if (is_migrate_cma_page(page)) {
 +			if (mm_iommu_move_page_from_cma(page))
 +				goto populate;
 +			if (1 != get_user_pages_fast(cur_ua,
 +						1/* pages */, 1/* iswrite */,
 +						&page)) {
 +				ret = -EFAULT;
 +				for (j = 0; j < i; ++j)
 +					put_page(pfn_to_page(mem->hpas[j] >>
 +								PAGE_SHIFT));
 +				vfree(mem->hpas);
 +				kfree(mem);
 +				goto unlock_exit;
 +			}
 +		}
 +populate:
 +		pageshift = PAGE_SHIFT;
 +		if (mem->pageshift > PAGE_SHIFT && PageCompound(page)) {
 +			pte_t *pte;
  			struct page *head = compound_head(page);
 -
 -			pageshift = compound_order(head) + PAGE_SHIFT;
 +			unsigned int compshift = compound_order(head);
 +			unsigned int pteshift;
 +
 +			local_irq_save(flags); /* disables as well */
 +			pte = find_linux_pte(mm->pgd, cur_ua, NULL, &pteshift);
 +
 +			/* Double check it is still the same pinned page */
 +			if (pte && pte_page(*pte) == head &&
 +			    pteshift == compshift + PAGE_SHIFT)
 +				pageshift = max_t(unsigned int, pteshift,
 +						PAGE_SHIFT);
 +			local_irq_restore(flags);
  		}
  		mem->pageshift = min(mem->pageshift, pageshift);
 -		/*
 -		 * We don't need struct page reference any more, switch
 -		 * to physical address.
 -		 */
  		mem->hpas[i] = page_to_pfn(page) << PAGE_SHIFT;
  	}
  
* Unmerged path arch/powerpc/mm/mmu_context_iommu.c
