sched: loadavg: make calc_load_n() public

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Johannes Weiner <hannes@cmpxchg.org>
commit 5c54f5b9edb1aa2eabbb1091c458f1b6776a1896
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/5c54f5b9.failed

It's going to be used in a later patch. Keep the churn separate.

Link: http://lkml.kernel.org/r/20180828172258.3185-6-hannes@cmpxchg.org
	Signed-off-by: Johannes Weiner <hannes@cmpxchg.org>
	Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Tested-by: Suren Baghdasaryan <surenb@google.com>
	Tested-by: Daniel Drake <drake@endlessm.com>
	Cc: Christopher Lameter <cl@linux.com>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Johannes Weiner <jweiner@fb.com>
	Cc: Mike Galbraith <efault@gmx.de>
	Cc: Peter Enderborg <peter.enderborg@sony.com>
	Cc: Randy Dunlap <rdunlap@infradead.org>
	Cc: Shakeel Butt <shakeelb@google.com>
	Cc: Tejun Heo <tj@kernel.org>
	Cc: Vinayak Menon <vinmenon@codeaurora.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 5c54f5b9edb1aa2eabbb1091c458f1b6776a1896)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/sched/loadavg.h
#	kernel/sched/loadavg.c
diff --cc include/linux/sched/loadavg.h
index 80bc84ba5d2a,4859bea47a7b..000000000000
--- a/include/linux/sched/loadavg.h
+++ b/include/linux/sched/loadavg.h
@@@ -22,10 -22,26 +22,33 @@@ extern void get_avenrun(unsigned long *
  #define EXP_5		2014		/* 1/exp(5sec/5min) */
  #define EXP_15		2037		/* 1/exp(5sec/15min) */
  
++<<<<<<< HEAD
 +#define CALC_LOAD(load,exp,n) \
 +	load *= exp; \
 +	load += n*(FIXED_1-exp); \
 +	load >>= FSHIFT;
++=======
+ /*
+  * a1 = a0 * e + a * (1 - e)
+  */
+ static inline unsigned long
+ calc_load(unsigned long load, unsigned long exp, unsigned long active)
+ {
+ 	unsigned long newload;
+ 
+ 	newload = load * exp + active * (FIXED_1 - exp);
+ 	if (active >= load)
+ 		newload += FIXED_1-1;
+ 
+ 	return newload / FIXED_1;
+ }
+ 
+ extern unsigned long calc_load_n(unsigned long load, unsigned long exp,
+ 				 unsigned long active, unsigned int n);
+ 
+ #define LOAD_INT(x) ((x) >> FSHIFT)
+ #define LOAD_FRAC(x) LOAD_INT(((x) & (FIXED_1-1)) * 100)
++>>>>>>> 5c54f5b9edb1 (sched: loadavg: make calc_load_n() public)
  
  extern void calc_global_load(unsigned long ticks);
  
diff --cc kernel/sched/loadavg.c
index a171c1258109,28a516575c18..000000000000
--- a/kernel/sched/loadavg.c
+++ b/kernel/sched/loadavg.c
@@@ -91,19 -91,73 +91,89 @@@ long calc_load_fold_active(struct rq *t
  	return delta;
  }
  
++<<<<<<< HEAD
 +/*
 + * a1 = a0 * e + a * (1 - e)
 + */
 +static unsigned long
 +calc_load(unsigned long load, unsigned long exp, unsigned long active)
 +{
 +	unsigned long newload;
 +
 +	newload = load * exp + active * (FIXED_1 - exp);
 +	if (active >= load)
 +		newload += FIXED_1-1;
 +
 +	return newload / FIXED_1;
++=======
+ /**
+  * fixed_power_int - compute: x^n, in O(log n) time
+  *
+  * @x:         base of the power
+  * @frac_bits: fractional bits of @x
+  * @n:         power to raise @x to.
+  *
+  * By exploiting the relation between the definition of the natural power
+  * function: x^n := x*x*...*x (x multiplied by itself for n times), and
+  * the binary encoding of numbers used by computers: n := \Sum n_i * 2^i,
+  * (where: n_i \elem {0, 1}, the binary vector representing n),
+  * we find: x^n := x^(\Sum n_i * 2^i) := \Prod x^(n_i * 2^i), which is
+  * of course trivially computable in O(log_2 n), the length of our binary
+  * vector.
+  */
+ static unsigned long
+ fixed_power_int(unsigned long x, unsigned int frac_bits, unsigned int n)
+ {
+ 	unsigned long result = 1UL << frac_bits;
+ 
+ 	if (n) {
+ 		for (;;) {
+ 			if (n & 1) {
+ 				result *= x;
+ 				result += 1UL << (frac_bits - 1);
+ 				result >>= frac_bits;
+ 			}
+ 			n >>= 1;
+ 			if (!n)
+ 				break;
+ 			x *= x;
+ 			x += 1UL << (frac_bits - 1);
+ 			x >>= frac_bits;
+ 		}
+ 	}
+ 
+ 	return result;
+ }
+ 
+ /*
+  * a1 = a0 * e + a * (1 - e)
+  *
+  * a2 = a1 * e + a * (1 - e)
+  *    = (a0 * e + a * (1 - e)) * e + a * (1 - e)
+  *    = a0 * e^2 + a * (1 - e) * (1 + e)
+  *
+  * a3 = a2 * e + a * (1 - e)
+  *    = (a0 * e^2 + a * (1 - e) * (1 + e)) * e + a * (1 - e)
+  *    = a0 * e^3 + a * (1 - e) * (1 + e + e^2)
+  *
+  *  ...
+  *
+  * an = a0 * e^n + a * (1 - e) * (1 + e + ... + e^n-1) [1]
+  *    = a0 * e^n + a * (1 - e) * (1 - e^n)/(1 - e)
+  *    = a0 * e^n + a * (1 - e^n)
+  *
+  * [1] application of the geometric series:
+  *
+  *              n         1 - x^(n+1)
+  *     S_n := \Sum x^i = -------------
+  *             i=0          1 - x
+  */
+ unsigned long
+ calc_load_n(unsigned long load, unsigned long exp,
+ 	    unsigned long active, unsigned int n)
+ {
+ 	return calc_load(load, fixed_power_int(exp, FSHIFT, n), active);
++>>>>>>> 5c54f5b9edb1 (sched: loadavg: make calc_load_n() public)
  }
  
  #ifdef CONFIG_NO_HZ_COMMON
* Unmerged path include/linux/sched/loadavg.h
* Unmerged path kernel/sched/loadavg.c
