drm/i915: Make sandybridge_pcode_read() deal with the second data register

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit d284d5145eb8760b592e64249c1cd85c440fe90f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/d284d514.failed

The pcode mailbox has two data registers. So far we've only ever used
the one, but that's about to change. Expose the second data register to
the callers of sandybridge_pcode_read().

	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
	Reviewed-by: Clint Taylor <Clinton.A.Taylor@intel.com>
	Reviewed-by: Radhakrishna Sripada <radhakrishna.sripada@intel.com>
	Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190521164025.30225-1-ville.syrjala@linux.intel.com
(cherry picked from commit d284d5145eb8760b592e64249c1cd85c440fe90f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/i915_debugfs.c
#	drivers/gpu/drm/i915/intel_pm.c
#	drivers/gpu/drm/i915/intel_sideband.c
#	drivers/gpu/drm/i915/intel_sideband.h
diff --cc drivers/gpu/drm/i915/i915_debugfs.c
index 76b3f4beb643,344beab229a0..000000000000
--- a/drivers/gpu/drm/i915/i915_debugfs.c
+++ b/drivers/gpu/drm/i915/i915_debugfs.c
@@@ -1524,12 -1498,9 +1524,16 @@@ static int gen6_drpc_info(struct seq_fi
  		gen9_powergate_status = I915_READ(GEN9_PWRGT_DOMAIN_STATUS);
  	}
  
 -	if (INTEL_GEN(dev_priv) <= 7)
 +	if (INTEL_GEN(dev_priv) <= 7) {
 +		mutex_lock(&dev_priv->pcu_lock);
  		sandybridge_pcode_read(dev_priv, GEN6_PCODE_READ_RC6VIDS,
++<<<<<<< HEAD
 +				       &rc6vids);
 +		mutex_unlock(&dev_priv->pcu_lock);
 +	}
++=======
+ 				       &rc6vids, NULL);
++>>>>>>> d284d5145eb8 (drm/i915: Make sandybridge_pcode_read() deal with the second data register)
  
  	seq_printf(m, "RC1e Enabled: %s\n",
  		   yesno(rcctl1 & GEN6_RC_CTL_RC1e_ENABLE));
diff --cc drivers/gpu/drm/i915/intel_pm.c
index a1b763e0c3a9,8f82cb72d3a6..000000000000
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@@ -2806,11 -2820,9 +2806,15 @@@ static void intel_read_wm_latency(struc
  
  		/* read the first set of memory latencies[0:3] */
  		val = 0; /* data0 to be programmed to 0 for first set */
 +		mutex_lock(&dev_priv->pcu_lock);
  		ret = sandybridge_pcode_read(dev_priv,
  					     GEN9_PCODE_READ_MEM_LATENCY,
++<<<<<<< HEAD
 +					     &val);
 +		mutex_unlock(&dev_priv->pcu_lock);
++=======
+ 					     &val, NULL);
++>>>>>>> d284d5145eb8 (drm/i915: Make sandybridge_pcode_read() deal with the second data register)
  
  		if (ret) {
  			DRM_ERROR("SKL Mailbox read error = %d\n", ret);
@@@ -2827,11 -2839,9 +2831,15 @@@
  
  		/* read the second set of memory latencies[4:7] */
  		val = 1; /* data0 to be programmed to 1 for second set */
 +		mutex_lock(&dev_priv->pcu_lock);
  		ret = sandybridge_pcode_read(dev_priv,
  					     GEN9_PCODE_READ_MEM_LATENCY,
++<<<<<<< HEAD
 +					     &val);
 +		mutex_unlock(&dev_priv->pcu_lock);
++=======
+ 					     &val, NULL);
++>>>>>>> d284d5145eb8 (drm/i915: Make sandybridge_pcode_read() deal with the second data register)
  		if (ret) {
  			DRM_ERROR("SKL Mailbox read error = %d\n", ret);
  			return;
@@@ -7033,10 -7419,11 +7041,16 @@@ static void gen6_enable_rc6(struct drm_
  		   GEN6_RC_CTL_HW_ENABLE);
  
  	rc6vids = 0;
++<<<<<<< HEAD
 +	ret = sandybridge_pcode_read(dev_priv, GEN6_PCODE_READ_RC6VIDS, &rc6vids);
 +	if (IS_GEN6(dev_priv) && ret) {
++=======
+ 	ret = sandybridge_pcode_read(dev_priv, GEN6_PCODE_READ_RC6VIDS,
+ 				     &rc6vids, NULL);
+ 	if (IS_GEN(dev_priv, 6) && ret) {
++>>>>>>> d284d5145eb8 (drm/i915: Make sandybridge_pcode_read() deal with the second data register)
  		DRM_DEBUG_DRIVER("Couldn't check for BIOS workaround\n");
 -	} else if (IS_GEN(dev_priv, 6) && (GEN6_DECODE_RC6_VID(rc6vids & 0xff) < 450)) {
 +	} else if (IS_GEN6(dev_priv) && (GEN6_DECODE_RC6_VID(rc6vids & 0xff) < 450)) {
  		DRM_DEBUG_DRIVER("You should update your BIOS. Correcting minimum rc6 voltage (%dmV->%dmV)\n",
  			  GEN6_DECODE_RC6_VID(rc6vids & 0xff), 450);
  		rc6vids &= 0xffff00;
diff --cc drivers/gpu/drm/i915/intel_sideband.c
index 75c872bb8cc9,a115625e980c..000000000000
--- a/drivers/gpu/drm/i915/intel_sideband.c
+++ b/drivers/gpu/drm/i915/intel_sideband.c
@@@ -288,8 -266,269 +288,272 @@@ u32 vlv_flisdsi_read(struct drm_i915_pr
  	return val;
  }
  
 -void vlv_flisdsi_write(struct drm_i915_private *i915, u32 reg, u32 val)
 +void vlv_flisdsi_write(struct drm_i915_private *dev_priv, u32 reg, u32 val)
  {
 -	vlv_sideband_rw(i915, DPIO_DEVFN, IOSF_PORT_FLISDSI, SB_CRWRDA_NP,
 +	vlv_sideband_rw(dev_priv, DPIO_DEVFN, IOSF_PORT_FLISDSI, SB_CRWRDA_NP,
  			reg, &val);
  }
++<<<<<<< HEAD
++=======
+ 
+ /* SBI access */
+ static int intel_sbi_rw(struct drm_i915_private *i915, u16 reg,
+ 			enum intel_sbi_destination destination,
+ 			u32 *val, bool is_read)
+ {
+ 	struct intel_uncore *uncore = &i915->uncore;
+ 	u32 cmd;
+ 
+ 	lockdep_assert_held(&i915->sb_lock);
+ 
+ 	if (intel_wait_for_register_fw(uncore,
+ 				       SBI_CTL_STAT, SBI_BUSY, 0,
+ 				       100)) {
+ 		DRM_ERROR("timeout waiting for SBI to become ready\n");
+ 		return -EBUSY;
+ 	}
+ 
+ 	intel_uncore_write_fw(uncore, SBI_ADDR, (u32)reg << 16);
+ 	intel_uncore_write_fw(uncore, SBI_DATA, is_read ? 0 : *val);
+ 
+ 	if (destination == SBI_ICLK)
+ 		cmd = SBI_CTL_DEST_ICLK | SBI_CTL_OP_CRRD;
+ 	else
+ 		cmd = SBI_CTL_DEST_MPHY | SBI_CTL_OP_IORD;
+ 	if (!is_read)
+ 		cmd |= BIT(8);
+ 	intel_uncore_write_fw(uncore, SBI_CTL_STAT, cmd | SBI_BUSY);
+ 
+ 	if (__intel_wait_for_register_fw(uncore,
+ 					 SBI_CTL_STAT, SBI_BUSY, 0,
+ 					 100, 100, &cmd)) {
+ 		DRM_ERROR("timeout waiting for SBI to complete read\n");
+ 		return -ETIMEDOUT;
+ 	}
+ 
+ 	if (cmd & SBI_RESPONSE_FAIL) {
+ 		DRM_ERROR("error during SBI read of reg %x\n", reg);
+ 		return -ENXIO;
+ 	}
+ 
+ 	if (is_read)
+ 		*val = intel_uncore_read_fw(uncore, SBI_DATA);
+ 
+ 	return 0;
+ }
+ 
+ u32 intel_sbi_read(struct drm_i915_private *i915, u16 reg,
+ 		   enum intel_sbi_destination destination)
+ {
+ 	u32 result = 0;
+ 
+ 	intel_sbi_rw(i915, reg, destination, &result, true);
+ 
+ 	return result;
+ }
+ 
+ void intel_sbi_write(struct drm_i915_private *i915, u16 reg, u32 value,
+ 		     enum intel_sbi_destination destination)
+ {
+ 	intel_sbi_rw(i915, reg, destination, &value, false);
+ }
+ 
+ static inline int gen6_check_mailbox_status(u32 mbox)
+ {
+ 	switch (mbox & GEN6_PCODE_ERROR_MASK) {
+ 	case GEN6_PCODE_SUCCESS:
+ 		return 0;
+ 	case GEN6_PCODE_UNIMPLEMENTED_CMD:
+ 		return -ENODEV;
+ 	case GEN6_PCODE_ILLEGAL_CMD:
+ 		return -ENXIO;
+ 	case GEN6_PCODE_MIN_FREQ_TABLE_GT_RATIO_OUT_OF_RANGE:
+ 	case GEN7_PCODE_MIN_FREQ_TABLE_GT_RATIO_OUT_OF_RANGE:
+ 		return -EOVERFLOW;
+ 	case GEN6_PCODE_TIMEOUT:
+ 		return -ETIMEDOUT;
+ 	default:
+ 		MISSING_CASE(mbox & GEN6_PCODE_ERROR_MASK);
+ 		return 0;
+ 	}
+ }
+ 
+ static inline int gen7_check_mailbox_status(u32 mbox)
+ {
+ 	switch (mbox & GEN6_PCODE_ERROR_MASK) {
+ 	case GEN6_PCODE_SUCCESS:
+ 		return 0;
+ 	case GEN6_PCODE_ILLEGAL_CMD:
+ 		return -ENXIO;
+ 	case GEN7_PCODE_TIMEOUT:
+ 		return -ETIMEDOUT;
+ 	case GEN7_PCODE_ILLEGAL_DATA:
+ 		return -EINVAL;
+ 	case GEN7_PCODE_MIN_FREQ_TABLE_GT_RATIO_OUT_OF_RANGE:
+ 		return -EOVERFLOW;
+ 	default:
+ 		MISSING_CASE(mbox & GEN6_PCODE_ERROR_MASK);
+ 		return 0;
+ 	}
+ }
+ 
+ static int __sandybridge_pcode_rw(struct drm_i915_private *i915,
+ 				  u32 mbox, u32 *val, u32 *val1,
+ 				  int fast_timeout_us,
+ 				  int slow_timeout_ms,
+ 				  bool is_read)
+ {
+ 	struct intel_uncore *uncore = &i915->uncore;
+ 
+ 	lockdep_assert_held(&i915->sb_lock);
+ 
+ 	/*
+ 	 * GEN6_PCODE_* are outside of the forcewake domain, we can
+ 	 * use te fw I915_READ variants to reduce the amount of work
+ 	 * required when reading/writing.
+ 	 */
+ 
+ 	if (intel_uncore_read_fw(uncore, GEN6_PCODE_MAILBOX) & GEN6_PCODE_READY)
+ 		return -EAGAIN;
+ 
+ 	intel_uncore_write_fw(uncore, GEN6_PCODE_DATA, *val);
+ 	intel_uncore_write_fw(uncore, GEN6_PCODE_DATA1, val1 ? *val1 : 0);
+ 	intel_uncore_write_fw(uncore,
+ 			      GEN6_PCODE_MAILBOX, GEN6_PCODE_READY | mbox);
+ 
+ 	if (__intel_wait_for_register_fw(uncore,
+ 					 GEN6_PCODE_MAILBOX,
+ 					 GEN6_PCODE_READY, 0,
+ 					 fast_timeout_us,
+ 					 slow_timeout_ms,
+ 					 &mbox))
+ 		return -ETIMEDOUT;
+ 
+ 	if (is_read)
+ 		*val = intel_uncore_read_fw(uncore, GEN6_PCODE_DATA);
+ 	if (is_read && val1)
+ 		*val1 = intel_uncore_read_fw(uncore, GEN6_PCODE_DATA1);
+ 
+ 	if (INTEL_GEN(i915) > 6)
+ 		return gen7_check_mailbox_status(mbox);
+ 	else
+ 		return gen6_check_mailbox_status(mbox);
+ }
+ 
+ int sandybridge_pcode_read(struct drm_i915_private *i915, u32 mbox,
+ 			   u32 *val, u32 *val1)
+ {
+ 	int err;
+ 
+ 	mutex_lock(&i915->sb_lock);
+ 	err = __sandybridge_pcode_rw(i915, mbox, val, val1,
+ 				     500, 0,
+ 				     true);
+ 	mutex_unlock(&i915->sb_lock);
+ 
+ 	if (err) {
+ 		DRM_DEBUG_DRIVER("warning: pcode (read from mbox %x) mailbox access failed for %ps: %d\n",
+ 				 mbox, __builtin_return_address(0), err);
+ 	}
+ 
+ 	return err;
+ }
+ 
+ int sandybridge_pcode_write_timeout(struct drm_i915_private *i915,
+ 				    u32 mbox, u32 val,
+ 				    int fast_timeout_us,
+ 				    int slow_timeout_ms)
+ {
+ 	int err;
+ 
+ 	mutex_lock(&i915->sb_lock);
+ 	err = __sandybridge_pcode_rw(i915, mbox, &val, NULL,
+ 				     fast_timeout_us, slow_timeout_ms,
+ 				     false);
+ 	mutex_unlock(&i915->sb_lock);
+ 
+ 	if (err) {
+ 		DRM_DEBUG_DRIVER("warning: pcode (write of 0x%08x to mbox %x) mailbox access failed for %ps: %d\n",
+ 				 val, mbox, __builtin_return_address(0), err);
+ 	}
+ 
+ 	return err;
+ }
+ 
+ static bool skl_pcode_try_request(struct drm_i915_private *i915, u32 mbox,
+ 				  u32 request, u32 reply_mask, u32 reply,
+ 				  u32 *status)
+ {
+ 	*status = __sandybridge_pcode_rw(i915, mbox, &request, NULL,
+ 					 500, 0,
+ 					 true);
+ 
+ 	return *status || ((request & reply_mask) == reply);
+ }
+ 
+ /**
+  * skl_pcode_request - send PCODE request until acknowledgment
+  * @i915: device private
+  * @mbox: PCODE mailbox ID the request is targeted for
+  * @request: request ID
+  * @reply_mask: mask used to check for request acknowledgment
+  * @reply: value used to check for request acknowledgment
+  * @timeout_base_ms: timeout for polling with preemption enabled
+  *
+  * Keep resending the @request to @mbox until PCODE acknowledges it, PCODE
+  * reports an error or an overall timeout of @timeout_base_ms+50 ms expires.
+  * The request is acknowledged once the PCODE reply dword equals @reply after
+  * applying @reply_mask. Polling is first attempted with preemption enabled
+  * for @timeout_base_ms and if this times out for another 50 ms with
+  * preemption disabled.
+  *
+  * Returns 0 on success, %-ETIMEDOUT in case of a timeout, <0 in case of some
+  * other error as reported by PCODE.
+  */
+ int skl_pcode_request(struct drm_i915_private *i915, u32 mbox, u32 request,
+ 		      u32 reply_mask, u32 reply, int timeout_base_ms)
+ {
+ 	u32 status;
+ 	int ret;
+ 
+ 	mutex_lock(&i915->sb_lock);
+ 
+ #define COND \
+ 	skl_pcode_try_request(i915, mbox, request, reply_mask, reply, &status)
+ 
+ 	/*
+ 	 * Prime the PCODE by doing a request first. Normally it guarantees
+ 	 * that a subsequent request, at most @timeout_base_ms later, succeeds.
+ 	 * _wait_for() doesn't guarantee when its passed condition is evaluated
+ 	 * first, so send the first request explicitly.
+ 	 */
+ 	if (COND) {
+ 		ret = 0;
+ 		goto out;
+ 	}
+ 	ret = _wait_for(COND, timeout_base_ms * 1000, 10, 10);
+ 	if (!ret)
+ 		goto out;
+ 
+ 	/*
+ 	 * The above can time out if the number of requests was low (2 in the
+ 	 * worst case) _and_ PCODE was busy for some reason even after a
+ 	 * (queued) request and @timeout_base_ms delay. As a workaround retry
+ 	 * the poll with preemption disabled to maximize the number of
+ 	 * requests. Increase the timeout from @timeout_base_ms to 50ms to
+ 	 * account for interrupts that could reduce the number of these
+ 	 * requests, and for any quirks of the PCODE firmware that delays
+ 	 * the request completion.
+ 	 */
+ 	DRM_DEBUG_KMS("PCODE timeout, retrying with preemption disabled\n");
+ 	WARN_ON_ONCE(timeout_base_ms > 3);
+ 	preempt_disable();
+ 	ret = wait_for_atomic(COND, 50);
+ 	preempt_enable();
+ 
+ out:
+ 	mutex_unlock(&i915->sb_lock);
+ 	return ret ? ret : status;
+ #undef COND
+ }
++>>>>>>> d284d5145eb8 (drm/i915: Make sandybridge_pcode_read() deal with the second data register)
* Unmerged path drivers/gpu/drm/i915/intel_sideband.h
* Unmerged path drivers/gpu/drm/i915/i915_debugfs.c
* Unmerged path drivers/gpu/drm/i915/intel_pm.c
* Unmerged path drivers/gpu/drm/i915/intel_sideband.c
* Unmerged path drivers/gpu/drm/i915/intel_sideband.h
