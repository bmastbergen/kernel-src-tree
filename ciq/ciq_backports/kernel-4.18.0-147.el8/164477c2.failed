x86/mm: Clarify hardware vs. software "error_code"

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Dave Hansen <dave.hansen@linux.intel.com>
commit 164477c2331be75d9bd57fb76704e676b2bcd1cd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/164477c2.failed

We pass around a variable called "error_code" all around the page
fault code.  Sounds simple enough, especially since "error_code" looks
like it exactly matches the values that the hardware gives us on the
stack to report the page fault error code (PFEC in SDM parlance).

But, that's not how it works.

For part of the page fault handler, "error_code" does exactly match
PFEC.  But, during later parts, it diverges and starts to mean
something a bit different.

Give it two names for its two jobs.

The place it diverges is also really screwy.  It's only in a spot
where the hardware tells us we have kernel-mode access that occurred
while we were in usermode accessing user-controlled address space.
Add a warning in there.

	Cc: x86@kernel.org
	Cc: Jann Horn <jannh@google.com>
	Cc: Sean Christopherson <sean.j.christopherson@intel.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Andy Lutomirski <luto@kernel.org>
	Signed-off-by: Dave Hansen <dave.hansen@linux.intel.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: http://lkml.kernel.org/r/20180928160220.4A2272C9@viggo.jf.intel.com
(cherry picked from commit 164477c2331be75d9bd57fb76704e676b2bcd1cd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/mm/fault.c
diff --cc arch/x86/mm/fault.c
index 47dac7a97b95,cd08f4fef836..000000000000
--- a/arch/x86/mm/fault.c
+++ b/arch/x86/mm/fault.c
@@@ -1218,7 -1257,7 +1219,11 @@@ __do_page_fault(struct pt_regs *regs, u
  		 * Don't take the mm semaphore here. If we fixup a prefetch
  		 * fault we could otherwise deadlock:
  		 */
++<<<<<<< HEAD
 +		bad_area_nosemaphore(regs, error_code, address);
++=======
+ 		bad_area_nosemaphore(regs, hw_error_code, address, NULL);
++>>>>>>> 164477c2331b (x86/mm: Clarify hardware vs. software "error_code")
  
  		return;
  	}
@@@ -1227,11 -1266,11 +1232,16 @@@
  	if (unlikely(kprobes_fault(regs)))
  		return;
  
- 	if (unlikely(error_code & X86_PF_RSVD))
- 		pgtable_bad(regs, error_code, address);
+ 	if (unlikely(hw_error_code & X86_PF_RSVD))
+ 		pgtable_bad(regs, hw_error_code, address);
  
++<<<<<<< HEAD
 +	if (unlikely(smap_violation(error_code, regs))) {
 +		bad_area_nosemaphore(regs, error_code, address);
++=======
+ 	if (unlikely(smap_violation(hw_error_code, regs))) {
+ 		bad_area_nosemaphore(regs, hw_error_code, address, NULL);
++>>>>>>> 164477c2331b (x86/mm: Clarify hardware vs. software "error_code")
  		return;
  	}
  
@@@ -1240,7 -1279,7 +1250,11 @@@
  	 * in a region with pagefaults disabled then we must not take the fault
  	 */
  	if (unlikely(faulthandler_disabled() || !mm)) {
++<<<<<<< HEAD
 +		bad_area_nosemaphore(regs, error_code, address);
++=======
+ 		bad_area_nosemaphore(regs, hw_error_code, address, NULL);
++>>>>>>> 164477c2331b (x86/mm: Clarify hardware vs. software "error_code")
  		return;
  	}
  
@@@ -1284,9 -1349,9 +1324,13 @@@
  	 * space check, thus avoiding the deadlock:
  	 */
  	if (unlikely(!down_read_trylock(&mm->mmap_sem))) {
- 		if (!(error_code & X86_PF_USER) &&
+ 		if (!(sw_error_code & X86_PF_USER) &&
  		    !search_exception_tables(regs->ip)) {
++<<<<<<< HEAD
 +			bad_area_nosemaphore(regs, error_code, address);
++=======
+ 			bad_area_nosemaphore(regs, sw_error_code, address, NULL);
++>>>>>>> 164477c2331b (x86/mm: Clarify hardware vs. software "error_code")
  			return;
  		}
  retry:
* Unmerged path arch/x86/mm/fault.c
