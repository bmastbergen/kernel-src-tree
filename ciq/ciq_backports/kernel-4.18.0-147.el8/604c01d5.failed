nvme-pci: trace SQ status on completions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author yupeng <yupeng0921@gmail.com>
commit 604c01d567cb9ee7d19dc598272cb90ab6229a8a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/604c01d5.failed

Export the disk name, queue id, sq_head, sq_tail to a trace event in
completion handling.

Usage example:

cd /sys/kernel/debug/tracing/events/nvme/nvme_sq

echo 'disk=="nvme1n1"' > filter

echo 1 > enable

cat /sys/kernel/debug/tracing/trace_pipe

	Signed-off-by: yupeng <yupeng0921@gmail.com>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Reviewed-by: Keith Busch <keith.busch@intel.com>
[hch: slight formatting tweaks, use standard nvme tracepoint
 conventions]
	Signed-off-by: Christoph Hellwig <hch@lst.de>

wip

(cherry picked from commit 604c01d567cb9ee7d19dc598272cb90ab6229a8a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/trace.h
diff --cc drivers/nvme/host/trace.h
index a490790d6691,3564120aa7b3..000000000000
--- a/drivers/nvme/host/trace.h
+++ b/drivers/nvme/host/trace.h
@@@ -156,6 -156,57 +156,60 @@@ TRACE_EVENT(nvme_complete_rq
  
  );
  
++<<<<<<< HEAD
++=======
+ #define aer_name(aer) { aer, #aer }
+ 
+ TRACE_EVENT(nvme_async_event,
+ 	TP_PROTO(struct nvme_ctrl *ctrl, u32 result),
+ 	TP_ARGS(ctrl, result),
+ 	TP_STRUCT__entry(
+ 		__field(int, ctrl_id)
+ 		__field(u32, result)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->ctrl_id = ctrl->instance;
+ 		__entry->result = result;
+ 	),
+ 	TP_printk("nvme%d: NVME_AEN=%#08x [%s]",
+ 		__entry->ctrl_id, __entry->result,
+ 		__print_symbolic(__entry->result,
+ 		aer_name(NVME_AER_NOTICE_NS_CHANGED),
+ 		aer_name(NVME_AER_NOTICE_ANA),
+ 		aer_name(NVME_AER_NOTICE_FW_ACT_STARTING),
+ 		aer_name(NVME_AER_ERROR),
+ 		aer_name(NVME_AER_SMART),
+ 		aer_name(NVME_AER_CSS),
+ 		aer_name(NVME_AER_VS))
+ 	)
+ );
+ 
+ #undef aer_name
+ 
+ TRACE_EVENT(nvme_sq,
+ 	TP_PROTO(struct request *req, __le16 sq_head, int sq_tail),
+ 	TP_ARGS(req, sq_head, sq_tail),
+ 	TP_STRUCT__entry(
+ 		__field(int, ctrl_id)
+ 		__array(char, disk, DISK_NAME_LEN)
+ 		__field(int, qid)
+ 		__field(u16, sq_head)
+ 		__field(u16, sq_tail)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->ctrl_id = nvme_req(req)->ctrl->instance;
+ 		__assign_disk_name(__entry->disk, req->rq_disk);
+ 		__entry->qid = nvme_req_qid(req);
+ 		__entry->sq_head = le16_to_cpu(sq_head);
+ 		__entry->sq_tail = sq_tail;
+ 	),
+ 	TP_printk("nvme%d: %sqid=%d, head=%u, tail=%u",
+ 		__entry->ctrl_id, __print_disk_name(__entry->disk),
+ 		__entry->qid, __entry->sq_head, __entry->sq_tail
+ 	)
+ );
+ 
++>>>>>>> 604c01d567cb (nvme-pci: trace SQ status on completions)
  #endif /* _TRACE_NVME_H */
  
  #undef TRACE_INCLUDE_PATH
diff --git a/drivers/nvme/host/pci.c b/drivers/nvme/host/pci.c
index 2cf830d14bb4..584ea7a57122 100644
--- a/drivers/nvme/host/pci.c
+++ b/drivers/nvme/host/pci.c
@@ -32,6 +32,7 @@
 #include <linux/sed-opal.h>
 #include <linux/pci-p2pdma.h>
 
+#include "trace.h"
 #include "nvme.h"
 
 #define SQ_SIZE(depth)		(depth * sizeof(struct nvme_command))
@@ -1003,6 +1004,7 @@ static inline void nvme_handle_cqe(struct nvme_queue *nvmeq, u16 idx)
 	}
 
 	req = blk_mq_tag_to_rq(*nvmeq->tags, cqe->command_id);
+	trace_nvme_sq(req, cqe->sq_head, nvmeq->sq_tail);
 	nvme_end_request(req, cqe->status, cqe->result);
 }
 
diff --git a/drivers/nvme/host/trace.c b/drivers/nvme/host/trace.c
index 25b0e310f4a8..5566dda3237a 100644
--- a/drivers/nvme/host/trace.c
+++ b/drivers/nvme/host/trace.c
@@ -139,3 +139,6 @@ const char *nvme_trace_disk_name(struct trace_seq *p, char *name)
 
 	return ret;
 }
+EXPORT_SYMBOL_GPL(nvme_trace_disk_name);
+
+EXPORT_TRACEPOINT_SYMBOL_GPL(nvme_sq);
* Unmerged path drivers/nvme/host/trace.h
