tools/bpf: bpftool, split the function do_dump()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Prashant Bhole <bhole_prashant_q7@lab.ntt.co.jp>
commit 18a781daa93e67b795976353a6b5d120939c50bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/18a781da.failed

do_dump() function in bpftool/map.c has deep indentations. In order
to reduce deep indent, let's move element printing code out of
do_dump() into dump_map_elem() function.

	Signed-off-by: Prashant Bhole <bhole_prashant_q7@lab.ntt.co.jp>
	Acked-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Acked-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Song Liu <songliubraving@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit 18a781daa93e67b795976353a6b5d120939c50bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/bpf/bpftool/map.c
diff --cc tools/bpf/bpftool/map.c
index 4cd01a866163,28d365435fea..000000000000
--- a/tools/bpf/bpftool/map.c
+++ b/tools/bpf/bpftool/map.c
@@@ -515,12 -658,62 +515,60 @@@ static int do_show(int argc, char **arg
  	return errno == ENOENT ? 0 : -1;
  }
  
+ static int dump_map_elem(int fd, void *key, void *value,
+ 			 struct bpf_map_info *map_info, struct btf *btf,
+ 			 json_writer_t *btf_wtr)
+ {
+ 	int num_elems = 0;
+ 
+ 	if (!bpf_map_lookup_elem(fd, key, value)) {
+ 		if (json_output) {
+ 			print_entry_json(map_info, key, value, btf);
+ 		} else {
+ 			if (btf) {
+ 				struct btf_dumper d = {
+ 					.btf = btf,
+ 					.jw = btf_wtr,
+ 					.is_plain_text = true,
+ 				};
+ 
+ 				do_dump_btf(&d, map_info, key, value);
+ 			} else {
+ 				print_entry_plain(map_info, key, value);
+ 			}
+ 			num_elems++;
+ 		}
+ 		return num_elems;
+ 	}
+ 
+ 	/* lookup error handling */
+ 	if (map_is_map_of_maps(map_info->type) ||
+ 	    map_is_map_of_progs(map_info->type))
+ 		return 0;
+ 
+ 	if (json_output) {
+ 		jsonw_name(json_wtr, "key");
+ 		print_hex_data_json(key, map_info->key_size);
+ 		jsonw_name(json_wtr, "value");
+ 		jsonw_start_object(json_wtr);
+ 		jsonw_string_field(json_wtr, "error",
+ 				   "can't lookup element");
+ 		jsonw_end_object(json_wtr);
+ 	} else {
+ 		p_info("can't lookup element with key: ");
+ 		fprint_hex(stderr, key, map_info->key_size, " ");
+ 		fprintf(stderr, "\n");
+ 	}
+ 
+ 	return 0;
+ }
+ 
  static int do_dump(int argc, char **argv)
  {
 -	struct bpf_map_info info = {};
  	void *key, *value, *prev_key;
  	unsigned int num_elems = 0;
 +	struct bpf_map_info info = {};
  	__u32 len = sizeof(info);
 -	json_writer_t *btf_wtr;
 -	struct btf *btf = NULL;
  	int err;
  	int fd;
  
@@@ -555,30 -761,8 +603,34 @@@
  				err = 0;
  			break;
  		}
++<<<<<<< HEAD
 +
 +		if (!bpf_map_lookup_elem(fd, key, value)) {
 +			if (json_output)
 +				print_entry_json(&info, key, value);
 +			else
 +				print_entry_plain(&info, key, value);
 +		} else {
 +			if (json_output) {
 +				jsonw_name(json_wtr, "key");
 +				print_hex_data_json(key, info.key_size);
 +				jsonw_name(json_wtr, "value");
 +				jsonw_start_object(json_wtr);
 +				jsonw_string_field(json_wtr, "error",
 +						   "can't lookup element");
 +				jsonw_end_object(json_wtr);
 +			} else {
 +				p_info("can't lookup element with key: ");
 +				fprint_hex(stderr, key, info.key_size, " ");
 +				fprintf(stderr, "\n");
 +			}
 +		}
 +
++=======
+ 		num_elems += dump_map_elem(fd, key, value, &info, btf, btf_wtr);
++>>>>>>> 18a781daa93e (tools/bpf: bpftool, split the function do_dump())
  		prev_key = key;
 +		num_elems++;
  	}
  
  	if (json_output)
* Unmerged path tools/bpf/bpftool/map.c
