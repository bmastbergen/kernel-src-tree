proc/kcore: optimize multiple page reads

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Omar Sandoval <osandov@fb.com>
commit bf991c2231117d50a7645792b514354fc8d19dae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/bf991c22.failed

The current code does a full search of the segment list every time for
every page.  This is wasteful, since it's almost certain that the next
page will be in the same segment.  Instead, check if the previous segment
covers the current page before doing the list search.

Link: http://lkml.kernel.org/r/fd346c11090cf93d867e01b8d73a6567c5ac6361.1531953780.git.osandov@fb.com
	Signed-off-by: Omar Sandoval <osandov@fb.com>
	Cc: Alexey Dobriyan <adobriyan@gmail.com>
	Cc: Bhupesh Sharma <bhsharma@redhat.com>
	Cc: Eric Biederman <ebiederm@xmission.com>
	Cc: James Morse <james.morse@arm.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit bf991c2231117d50a7645792b514354fc8d19dae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/proc/kcore.c
diff --cc fs/proc/kcore.c
index 00d616f7727a,758c14e46a44..000000000000
--- a/fs/proc/kcore.c
+++ b/fs/proc/kcore.c
@@@ -491,16 -424,22 +491,32 @@@ read_kcore(struct file *file, char __us
  	 * Check to see if our file offset matches with any of
  	 * the addresses in the elf_phdr on our list.
  	 */
 -	start = kc_offset_to_vaddr(*fpos - data_offset);
 +	start = kc_offset_to_vaddr(*fpos - elf_buflen);
  	if ((tsz = (PAGE_SIZE - (start & ~PAGE_MASK))) > buflen)
  		tsz = buflen;
++<<<<<<< HEAD
 +		
 +	while (buflen) {
 +		struct kcore_list *m;
 +
 +		list_for_each_entry(m, &kclist_head, list) {
 +			if (start >= m->addr && start < (m->addr+m->size))
 +				break;
++=======
+ 
+ 	m = NULL;
+ 	while (buflen) {
+ 		/*
+ 		 * If this is the first iteration or the address is not within
+ 		 * the previous entry, search for a matching entry.
+ 		 */
+ 		if (!m || start < m->addr || start >= m->addr + m->size) {
+ 			list_for_each_entry(m, &kclist_head, list) {
+ 				if (start >= m->addr &&
+ 				    start < m->addr + m->size)
+ 					break;
+ 			}
++>>>>>>> bf991c223111 (proc/kcore: optimize multiple page reads)
  		}
  
  		if (&m->list == &kclist_head) {
* Unmerged path fs/proc/kcore.c
