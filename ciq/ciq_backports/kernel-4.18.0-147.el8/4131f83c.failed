KVM: PPC: Book3S HV: XIVE: add a control to initialize a source

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Cédric Le Goater <clg@kaod.org>
commit 4131f83c3d64e591014dad14c7f8070c538b9422
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/4131f83c.failed

The XIVE KVM device maintains a list of interrupt sources for the VM
which are allocated in the pool of generic interrupts (IPIs) of the
main XIVE IC controller. These are used for the CPU IPIs as well as
for virtual device interrupts. The IRQ number space is defined by
QEMU.

The XIVE device reuses the source structures of the XICS-on-XIVE
device for the source blocks (2-level tree) and for the source
interrupts. Under XIVE native, the source interrupt caches mostly
configuration information and is less used than under the XICS-on-XIVE
device in which hcalls are still necessary at run-time.

When a source is initialized in KVM, an IPI interrupt source is simply
allocated at the OPAL level and then MASKED. KVM only needs to know
about its type: LSI or MSI.

	Signed-off-by: Cédric Le Goater <clg@kaod.org>
	Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
	Signed-off-by: Paul Mackerras <paulus@ozlabs.org>
(cherry picked from commit 4131f83c3d64e591014dad14c7f8070c538b9422)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kvm/book3s_xive.h
#	arch/powerpc/kvm/book3s_xive_native.c
diff --cc arch/powerpc/kvm/book3s_xive.h
index a08ae6fd4c51,1be921cb5dcb..000000000000
--- a/arch/powerpc/kvm/book3s_xive.h
+++ b/arch/powerpc/kvm/book3s_xive.h
@@@ -248,5 -260,14 +255,17 @@@ extern int (*__xive_vm_h_ipi)(struct kv
  extern int (*__xive_vm_h_cppr)(struct kvm_vcpu *vcpu, unsigned long cppr);
  extern int (*__xive_vm_h_eoi)(struct kvm_vcpu *vcpu, unsigned long xirr);
  
++<<<<<<< HEAD
++=======
+ /*
+  * Common Xive routines for XICS-over-XIVE and XIVE native
+  */
+ void kvmppc_xive_disable_vcpu_interrupts(struct kvm_vcpu *vcpu);
+ int kvmppc_xive_debug_show_queues(struct seq_file *m, struct kvm_vcpu *vcpu);
+ struct kvmppc_xive_src_block *kvmppc_xive_create_src_block(
+ 	struct kvmppc_xive *xive, int irq);
+ void kvmppc_xive_free_sources(struct kvmppc_xive_src_block *sb);
+ 
++>>>>>>> 4131f83c3d64 (KVM: PPC: Book3S HV: XIVE: add a control to initialize a source)
  #endif /* CONFIG_KVM_XICS */
  #endif /* _KVM_PPC_BOOK3S_XICS_H */
diff --cc arch/powerpc/kvm/book3s_xive_native.c
index 751259394150,5f2bd6c137b7..000000000000
--- a/arch/powerpc/kvm/book3s_xive_native.c
+++ b/arch/powerpc/kvm/book3s_xive_native.c
@@@ -26,6 -26,222 +26,225 @@@
  
  #include "book3s_xive.h"
  
++<<<<<<< HEAD
++=======
+ static u8 xive_vm_esb_load(struct xive_irq_data *xd, u32 offset)
+ {
+ 	u64 val;
+ 
+ 	if (xd->flags & XIVE_IRQ_FLAG_SHIFT_BUG)
+ 		offset |= offset << 4;
+ 
+ 	val = in_be64(xd->eoi_mmio + offset);
+ 	return (u8)val;
+ }
+ 
+ static void kvmppc_xive_native_cleanup_queue(struct kvm_vcpu *vcpu, int prio)
+ {
+ 	struct kvmppc_xive_vcpu *xc = vcpu->arch.xive_vcpu;
+ 	struct xive_q *q = &xc->queues[prio];
+ 
+ 	xive_native_disable_queue(xc->vp_id, q, prio);
+ 	if (q->qpage) {
+ 		put_page(virt_to_page(q->qpage));
+ 		q->qpage = NULL;
+ 	}
+ }
+ 
+ void kvmppc_xive_native_cleanup_vcpu(struct kvm_vcpu *vcpu)
+ {
+ 	struct kvmppc_xive_vcpu *xc = vcpu->arch.xive_vcpu;
+ 	int i;
+ 
+ 	if (!kvmppc_xive_enabled(vcpu))
+ 		return;
+ 
+ 	if (!xc)
+ 		return;
+ 
+ 	pr_devel("native_cleanup_vcpu(cpu=%d)\n", xc->server_num);
+ 
+ 	/* Ensure no interrupt is still routed to that VP */
+ 	xc->valid = false;
+ 	kvmppc_xive_disable_vcpu_interrupts(vcpu);
+ 
+ 	/* Disable the VP */
+ 	xive_native_disable_vp(xc->vp_id);
+ 
+ 	/* Free the queues & associated interrupts */
+ 	for (i = 0; i < KVMPPC_XIVE_Q_COUNT; i++) {
+ 		/* Free the escalation irq */
+ 		if (xc->esc_virq[i]) {
+ 			free_irq(xc->esc_virq[i], vcpu);
+ 			irq_dispose_mapping(xc->esc_virq[i]);
+ 			kfree(xc->esc_virq_names[i]);
+ 			xc->esc_virq[i] = 0;
+ 		}
+ 
+ 		/* Free the queue */
+ 		kvmppc_xive_native_cleanup_queue(vcpu, i);
+ 	}
+ 
+ 	/* Free the VP */
+ 	kfree(xc);
+ 
+ 	/* Cleanup the vcpu */
+ 	vcpu->arch.irq_type = KVMPPC_IRQ_DEFAULT;
+ 	vcpu->arch.xive_vcpu = NULL;
+ }
+ 
+ int kvmppc_xive_native_connect_vcpu(struct kvm_device *dev,
+ 				    struct kvm_vcpu *vcpu, u32 server_num)
+ {
+ 	struct kvmppc_xive *xive = dev->private;
+ 	struct kvmppc_xive_vcpu *xc = NULL;
+ 	int rc;
+ 
+ 	pr_devel("native_connect_vcpu(server=%d)\n", server_num);
+ 
+ 	if (dev->ops != &kvm_xive_native_ops) {
+ 		pr_devel("Wrong ops !\n");
+ 		return -EPERM;
+ 	}
+ 	if (xive->kvm != vcpu->kvm)
+ 		return -EPERM;
+ 	if (vcpu->arch.irq_type != KVMPPC_IRQ_DEFAULT)
+ 		return -EBUSY;
+ 	if (server_num >= KVM_MAX_VCPUS) {
+ 		pr_devel("Out of bounds !\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	mutex_lock(&vcpu->kvm->lock);
+ 
+ 	if (kvmppc_xive_find_server(vcpu->kvm, server_num)) {
+ 		pr_devel("Duplicate !\n");
+ 		rc = -EEXIST;
+ 		goto bail;
+ 	}
+ 
+ 	xc = kzalloc(sizeof(*xc), GFP_KERNEL);
+ 	if (!xc) {
+ 		rc = -ENOMEM;
+ 		goto bail;
+ 	}
+ 
+ 	vcpu->arch.xive_vcpu = xc;
+ 	xc->xive = xive;
+ 	xc->vcpu = vcpu;
+ 	xc->server_num = server_num;
+ 
+ 	xc->vp_id = kvmppc_xive_vp(xive, server_num);
+ 	xc->valid = true;
+ 	vcpu->arch.irq_type = KVMPPC_IRQ_XIVE;
+ 
+ 	rc = xive_native_get_vp_info(xc->vp_id, &xc->vp_cam, &xc->vp_chip_id);
+ 	if (rc) {
+ 		pr_err("Failed to get VP info from OPAL: %d\n", rc);
+ 		goto bail;
+ 	}
+ 
+ 	/*
+ 	 * Enable the VP first as the single escalation mode will
+ 	 * affect escalation interrupts numbering
+ 	 */
+ 	rc = xive_native_enable_vp(xc->vp_id, xive->single_escalation);
+ 	if (rc) {
+ 		pr_err("Failed to enable VP in OPAL: %d\n", rc);
+ 		goto bail;
+ 	}
+ 
+ 	/* Configure VCPU fields for use by assembly push/pull */
+ 	vcpu->arch.xive_saved_state.w01 = cpu_to_be64(0xff000000);
+ 	vcpu->arch.xive_cam_word = cpu_to_be32(xc->vp_cam | TM_QW1W2_VO);
+ 
+ 	/* TODO: reset all queues to a clean state ? */
+ bail:
+ 	mutex_unlock(&vcpu->kvm->lock);
+ 	if (rc)
+ 		kvmppc_xive_native_cleanup_vcpu(vcpu);
+ 
+ 	return rc;
+ }
+ 
+ static int kvmppc_xive_native_set_source(struct kvmppc_xive *xive, long irq,
+ 					 u64 addr)
+ {
+ 	struct kvmppc_xive_src_block *sb;
+ 	struct kvmppc_xive_irq_state *state;
+ 	u64 __user *ubufp = (u64 __user *) addr;
+ 	u64 val;
+ 	u16 idx;
+ 	int rc;
+ 
+ 	pr_devel("%s irq=0x%lx\n", __func__, irq);
+ 
+ 	if (irq < KVMPPC_XIVE_FIRST_IRQ || irq >= KVMPPC_XIVE_NR_IRQS)
+ 		return -E2BIG;
+ 
+ 	sb = kvmppc_xive_find_source(xive, irq, &idx);
+ 	if (!sb) {
+ 		pr_debug("No source, creating source block...\n");
+ 		sb = kvmppc_xive_create_src_block(xive, irq);
+ 		if (!sb) {
+ 			pr_err("Failed to create block...\n");
+ 			return -ENOMEM;
+ 		}
+ 	}
+ 	state = &sb->irq_state[idx];
+ 
+ 	if (get_user(val, ubufp)) {
+ 		pr_err("fault getting user info !\n");
+ 		return -EFAULT;
+ 	}
+ 
+ 	arch_spin_lock(&sb->lock);
+ 
+ 	/*
+ 	 * If the source doesn't already have an IPI, allocate
+ 	 * one and get the corresponding data
+ 	 */
+ 	if (!state->ipi_number) {
+ 		state->ipi_number = xive_native_alloc_irq();
+ 		if (state->ipi_number == 0) {
+ 			pr_err("Failed to allocate IRQ !\n");
+ 			rc = -ENXIO;
+ 			goto unlock;
+ 		}
+ 		xive_native_populate_irq_data(state->ipi_number,
+ 					      &state->ipi_data);
+ 		pr_debug("%s allocated hw_irq=0x%x for irq=0x%lx\n", __func__,
+ 			 state->ipi_number, irq);
+ 	}
+ 
+ 	/* Restore LSI state */
+ 	if (val & KVM_XIVE_LEVEL_SENSITIVE) {
+ 		state->lsi = true;
+ 		if (val & KVM_XIVE_LEVEL_ASSERTED)
+ 			state->asserted = true;
+ 		pr_devel("  LSI ! Asserted=%d\n", state->asserted);
+ 	}
+ 
+ 	/* Mask IRQ to start with */
+ 	state->act_server = 0;
+ 	state->act_priority = MASKED;
+ 	xive_vm_esb_load(&state->ipi_data, XIVE_ESB_SET_PQ_01);
+ 	xive_native_configure_irq(state->ipi_number, 0, MASKED, 0);
+ 
+ 	/* Increment the number of valid sources and mark this one valid */
+ 	if (!state->valid)
+ 		xive->src_count++;
+ 	state->valid = true;
+ 
+ 	rc = 0;
+ 
+ unlock:
+ 	arch_spin_unlock(&sb->lock);
+ 
+ 	return rc;
+ }
+ 
++>>>>>>> 4131f83c3d64 (KVM: PPC: Book3S HV: XIVE: add a control to initialize a source)
  static int kvmppc_xive_native_set_attr(struct kvm_device *dev,
  				       struct kvm_device_attr *attr)
  {
diff --git a/Documentation/virtual/kvm/devices/xive.txt b/Documentation/virtual/kvm/devices/xive.txt
index fdbd2ff92a88..cd8bfc37b72e 100644
--- a/Documentation/virtual/kvm/devices/xive.txt
+++ b/Documentation/virtual/kvm/devices/xive.txt
@@ -17,3 +17,18 @@ the legacy interrupt mode, referred as XICS (POWER7/8).
 
   1. KVM_DEV_XIVE_GRP_CTRL
   Provides global controls on the device
+
+  2. KVM_DEV_XIVE_GRP_SOURCE (write only)
+  Initializes a new source in the XIVE device and mask it.
+  Attributes:
+    Interrupt source number  (64-bit)
+  The kvm_device_attr.addr points to a __u64 value:
+  bits:     | 63   ....  2 |   1   |   0
+  values:   |    unused    | level | type
+  - type:  0:MSI 1:LSI
+  - level: assertion level in case of an LSI.
+  Errors:
+    -E2BIG:  Interrupt source number is out of range
+    -ENOMEM: Could not create a new source block
+    -EFAULT: Invalid user pointer for attr->addr.
+    -ENXIO:  Could not allocate underlying HW interrupt
diff --git a/arch/powerpc/include/uapi/asm/kvm.h b/arch/powerpc/include/uapi/asm/kvm.h
index be0ce1f17625..d468294c2a67 100644
--- a/arch/powerpc/include/uapi/asm/kvm.h
+++ b/arch/powerpc/include/uapi/asm/kvm.h
@@ -679,5 +679,10 @@ struct kvm_ppc_cpu_char {
 
 /* POWER9 XIVE Native Interrupt Controller */
 #define KVM_DEV_XIVE_GRP_CTRL		1
+#define KVM_DEV_XIVE_GRP_SOURCE		2	/* 64-bit source identifier */
+
+/* Layout of 64-bit XIVE source attribute values */
+#define KVM_XIVE_LEVEL_SENSITIVE	(1ULL << 0)
+#define KVM_XIVE_LEVEL_ASSERTED		(1ULL << 1)
 
 #endif /* __LINUX_KVM_POWERPC_H */
diff --git a/arch/powerpc/kvm/book3s_xive.c b/arch/powerpc/kvm/book3s_xive.c
index f78d002f0fe0..dd52d42885ab 100644
--- a/arch/powerpc/kvm/book3s_xive.c
+++ b/arch/powerpc/kvm/book3s_xive.c
@@ -1485,8 +1485,8 @@ static int xive_get_source(struct kvmppc_xive *xive, long irq, u64 addr)
 	return 0;
 }
 
-static struct kvmppc_xive_src_block *xive_create_src_block(struct kvmppc_xive *xive,
-							   int irq)
+struct kvmppc_xive_src_block *kvmppc_xive_create_src_block(
+	struct kvmppc_xive *xive, int irq)
 {
 	struct kvm *kvm = xive->kvm;
 	struct kvmppc_xive_src_block *sb;
@@ -1565,7 +1565,7 @@ static int xive_set_source(struct kvmppc_xive *xive, long irq, u64 addr)
 	sb = kvmppc_xive_find_source(xive, irq, &idx);
 	if (!sb) {
 		pr_devel("No source, creating source block...\n");
-		sb = xive_create_src_block(xive, irq);
+		sb = kvmppc_xive_create_src_block(xive, irq);
 		if (!sb) {
 			pr_devel("Failed to create block...\n");
 			return -ENOMEM;
@@ -1789,7 +1789,7 @@ static void kvmppc_xive_cleanup_irq(u32 hw_num, struct xive_irq_data *xd)
 	xive_cleanup_irq_data(xd);
 }
 
-static void kvmppc_xive_free_sources(struct kvmppc_xive_src_block *sb)
+void kvmppc_xive_free_sources(struct kvmppc_xive_src_block *sb)
 {
 	int i;
 
* Unmerged path arch/powerpc/kvm/book3s_xive.h
* Unmerged path arch/powerpc/kvm/book3s_xive_native.c
