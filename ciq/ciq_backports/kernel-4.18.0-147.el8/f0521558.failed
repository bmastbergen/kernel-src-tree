drm/i915: Don't clobber M/N values during fastset check

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit f0521558a2a89d58a08745e225025d338572e60a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/f0521558.failed

We're now calling intel_pipe_config_compare(..., true) uncoditionally
which means we're always going clobber the calculated M/N values with
the old values if the fuzzy M/N check passes. That causes problems
because the fuzzy check allows for a huge difference in the values.

I'm actually tempted to just make the M/N checks exact, but that might
prevent fastboot from kicking in when people want it. So for now let's
overwrite the computed values with the old values only if decide to skip
the modeset.

v2: Copy has_drrs along with M/N M2/N2 values

	Cc: stable@vger.kernel.org
	Cc: Blubberbub@protonmail.com
	Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
	Cc: Hans de Goede <hdegoede@redhat.com>
	Tested-by: Blubberbub@protonmail.com
Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=110782
Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=110675
Fixes: d19f958db23c ("drm/i915: Enable fastset for non-boot modesets.")
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190612172423.25231-1-ville.syrjala@linux.intel.com
	Reviewed-by: Imre Deak <imre.deak@intel.com>
(cherry picked from commit f0521558a2a89d58a08745e225025d338572e60a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_display.c
diff --cc drivers/gpu/drm/i915/intel_display.c
index e393e09c8760,853f2a37e8db..000000000000
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@@ -12228,28 -13495,19 +12252,36 @@@ static int intel_atomic_check(struct dr
  			continue;
  		}
  
++<<<<<<< HEAD:drivers/gpu/drm/i915/intel_display.c
 +		ret = intel_modeset_pipe_config(crtc, pipe_config);
 +		if (ret) {
 +			intel_dump_pipe_config(to_intel_crtc(crtc),
 +					       pipe_config, "[failed]");
 +			return ret;
 +		}
++=======
+ 		ret = intel_modeset_pipe_config(new_crtc_state);
+ 		if (ret)
+ 			goto fail;
+ 
+ 		intel_crtc_check_fastset(old_crtc_state, new_crtc_state);
++>>>>>>> f0521558a2a8 (drm/i915: Don't clobber M/N values during fastset check):drivers/gpu/drm/i915/display/intel_display.c
  
 -		if (needs_modeset(&new_crtc_state->base))
 +		if (i915_modparams.fastboot &&
 +		    intel_pipe_config_compare(dev_priv,
 +					to_intel_crtc_state(old_crtc_state),
 +					pipe_config, true)) {
 +			crtc_state->mode_changed = false;
 +			pipe_config->update_pipe = true;
 +		}
 +
 +		if (needs_modeset(crtc_state))
  			any_ms = true;
 -	}
  
 -	ret = drm_dp_mst_atomic_check(&state->base);
 -	if (ret)
 -		goto fail;
 +		intel_dump_pipe_config(to_intel_crtc(crtc), pipe_config,
 +				       needs_modeset(crtc_state) ?
 +				       "[modeset]" : "[fastset]");
 +	}
  
  	if (any_ms) {
  		ret = intel_modeset_checks(state);
* Unmerged path drivers/gpu/drm/i915/intel_display.c
