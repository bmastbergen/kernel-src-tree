drm/i915: Dump skl+ watermark changes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit ab98e94435abc493c8fedf5e07b0b3f045424d32
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/ab98e944.failed

Currently we're only dumping out the ddb allocation changes, let's do
the same for the watermarks. This should help with debugging underruns
and whatnot.

First I tried one line per plane per wm level, but that resulted in
an obnoxious amount of lines printed. So as a compromise I settled
on a four line format, each line containing a single watermark related
value (enable,lines,blocks,min_ddb_alloc) for all 8 levels (+trans wm).
It still produces quite a lot of output but I can't really see a way
around that because we simply have a lot of data to dump.

Let's also pimp the ddb debug to print the size of the allocations
too, not just their bounds. Makes it a bit easier to compare against
the watermarks.

	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190208200527.12844-1-ville.syrjala@linux.intel.com
	Reviewed-by: Clint Taylor <Clinton.A.Taylor@intel.com>
(cherry picked from commit ab98e94435abc493c8fedf5e07b0b3f045424d32)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_pm.c
diff --cc drivers/gpu/drm/i915/intel_pm.c
index 53aaaa3e6886,279031502d43..000000000000
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@@ -5141,50 -5266,112 +5141,144 @@@ skl_compute_ddb(struct drm_atomic_stat
  	return 0;
  }
  
+ static char enast(bool enable)
+ {
+ 	return enable ? '*' : ' ';
+ }
+ 
  static void
 -skl_print_wm_changes(struct intel_atomic_state *state)
 +skl_copy_ddb_for_pipe(struct skl_ddb_values *dst,
 +		      struct skl_ddb_values *src,
 +		      enum pipe pipe)
  {
 -	struct drm_i915_private *dev_priv = to_i915(state->base.dev);
 -	const struct intel_crtc_state *old_crtc_state;
 -	const struct intel_crtc_state *new_crtc_state;
 -	struct intel_plane *plane;
 -	struct intel_crtc *crtc;
 +	memcpy(dst->ddb.uv_plane[pipe], src->ddb.uv_plane[pipe],
 +	       sizeof(dst->ddb.uv_plane[pipe]));
 +	memcpy(dst->ddb.plane[pipe], src->ddb.plane[pipe],
 +	       sizeof(dst->ddb.plane[pipe]));
 +}
 +
 +static void
 +skl_print_wm_changes(const struct drm_atomic_state *state)
 +{
 +	const struct drm_device *dev = state->dev;
 +	const struct drm_i915_private *dev_priv = to_i915(dev);
 +	const struct intel_atomic_state *intel_state =
 +		to_intel_atomic_state(state);
 +	const struct drm_crtc *crtc;
 +	const struct drm_crtc_state *cstate;
 +	const struct intel_plane *intel_plane;
 +	const struct skl_ddb_allocation *old_ddb = &dev_priv->wm.skl_hw.ddb;
 +	const struct skl_ddb_allocation *new_ddb = &intel_state->wm_results.ddb;
  	int i;
  
++<<<<<<< HEAD
 +	for_each_new_crtc_in_state(state, crtc, cstate, i) {
 +		const struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
 +		enum pipe pipe = intel_crtc->pipe;
 +
 +		for_each_intel_plane_on_crtc(dev, intel_crtc, intel_plane) {
 +			enum plane_id plane_id = intel_plane->id;
++=======
+ 	if ((drm_debug & DRM_UT_KMS) == 0)
+ 		return;
+ 
+ 	for_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,
+ 					    new_crtc_state, i) {
+ 		const struct skl_pipe_wm *old_pipe_wm, *new_pipe_wm;
+ 
+ 		old_pipe_wm = &old_crtc_state->wm.skl.optimal;
+ 		new_pipe_wm = &new_crtc_state->wm.skl.optimal;
+ 
+ 		for_each_intel_plane_on_crtc(&dev_priv->drm, crtc, plane) {
+ 			enum plane_id plane_id = plane->id;
++>>>>>>> ab98e94435ab (drm/i915: Dump skl+ watermark changes)
  			const struct skl_ddb_entry *old, *new;
  
 -			old = &old_crtc_state->wm.skl.plane_ddb_y[plane_id];
 -			new = &new_crtc_state->wm.skl.plane_ddb_y[plane_id];
 +			old = &old_ddb->plane[pipe][plane_id];
 +			new = &new_ddb->plane[pipe][plane_id];
  
  			if (skl_ddb_entry_equal(old, new))
  				continue;
  
++<<<<<<< HEAD
 +			DRM_DEBUG_ATOMIC("[PLANE:%d:%s] ddb (%d - %d) -> (%d - %d)\n",
 +					 intel_plane->base.base.id,
 +					 intel_plane->base.name,
 +					 old->start, old->end,
 +					 new->start, new->end);
++=======
+ 			DRM_DEBUG_KMS("[PLANE:%d:%s] ddb (%4d - %4d) -> (%4d - %4d), size %4d -> %4d\n",
+ 				      plane->base.base.id, plane->base.name,
+ 				      old->start, old->end, new->start, new->end,
+ 				      skl_ddb_entry_size(old), skl_ddb_entry_size(new));
+ 		}
+ 
+ 		for_each_intel_plane_on_crtc(&dev_priv->drm, crtc, plane) {
+ 			enum plane_id plane_id = plane->id;
+ 			const struct skl_plane_wm *old_wm, *new_wm;
+ 
+ 			old_wm = &old_pipe_wm->planes[plane_id];
+ 			new_wm = &new_pipe_wm->planes[plane_id];
+ 
+ 			if (skl_plane_wm_equals(dev_priv, old_wm, new_wm))
+ 				continue;
+ 
+ 			DRM_DEBUG_KMS("[PLANE:%d:%s]   level %cwm0,%cwm1,%cwm2,%cwm3,%cwm4,%cwm5,%cwm6,%cwm7,%ctwm"
+ 				      " -> %cwm0,%cwm1,%cwm2,%cwm3,%cwm4,%cwm5,%cwm6,%cwm7,%ctwm\n",
+ 				      plane->base.base.id, plane->base.name,
+ 				      enast(old_wm->wm[0].plane_en), enast(old_wm->wm[1].plane_en),
+ 				      enast(old_wm->wm[2].plane_en), enast(old_wm->wm[3].plane_en),
+ 				      enast(old_wm->wm[4].plane_en), enast(old_wm->wm[5].plane_en),
+ 				      enast(old_wm->wm[6].plane_en), enast(old_wm->wm[7].plane_en),
+ 				      enast(old_wm->trans_wm.plane_en),
+ 				      enast(new_wm->wm[0].plane_en), enast(new_wm->wm[1].plane_en),
+ 				      enast(new_wm->wm[2].plane_en), enast(new_wm->wm[3].plane_en),
+ 				      enast(new_wm->wm[4].plane_en), enast(new_wm->wm[5].plane_en),
+ 				      enast(new_wm->wm[6].plane_en), enast(new_wm->wm[7].plane_en),
+ 				      enast(new_wm->trans_wm.plane_en));
+ 
+ 			DRM_DEBUG_KMS("[PLANE:%d:%s]   lines %4d,%4d,%4d,%4d,%4d,%4d,%4d,%4d,%4d"
+ 				      " -> %4d,%4d,%4d,%4d,%4d,%4d,%4d,%4d,%4d\n",
+ 				      plane->base.base.id, plane->base.name,
+ 				      old_wm->wm[0].plane_res_l, old_wm->wm[1].plane_res_l,
+ 				      old_wm->wm[2].plane_res_l, old_wm->wm[3].plane_res_l,
+ 				      old_wm->wm[4].plane_res_l, old_wm->wm[5].plane_res_l,
+ 				      old_wm->wm[6].plane_res_l, old_wm->wm[7].plane_res_l,
+ 				      old_wm->trans_wm.plane_res_l,
+ 				      new_wm->wm[0].plane_res_l, new_wm->wm[1].plane_res_l,
+ 				      new_wm->wm[2].plane_res_l, new_wm->wm[3].plane_res_l,
+ 				      new_wm->wm[4].plane_res_l, new_wm->wm[5].plane_res_l,
+ 				      new_wm->wm[6].plane_res_l, new_wm->wm[7].plane_res_l,
+ 				      new_wm->trans_wm.plane_res_l);
+ 
+ 			DRM_DEBUG_KMS("[PLANE:%d:%s]  blocks %4d,%4d,%4d,%4d,%4d,%4d,%4d,%4d,%4d"
+ 				      " -> %4d,%4d,%4d,%4d,%4d,%4d,%4d,%4d,%4d\n",
+ 				      plane->base.base.id, plane->base.name,
+ 				      old_wm->wm[0].plane_res_b, old_wm->wm[1].plane_res_b,
+ 				      old_wm->wm[2].plane_res_b, old_wm->wm[3].plane_res_b,
+ 				      old_wm->wm[4].plane_res_b, old_wm->wm[5].plane_res_b,
+ 				      old_wm->wm[6].plane_res_b, old_wm->wm[7].plane_res_b,
+ 				      old_wm->trans_wm.plane_res_b,
+ 				      new_wm->wm[0].plane_res_b, new_wm->wm[1].plane_res_b,
+ 				      new_wm->wm[2].plane_res_b, new_wm->wm[3].plane_res_b,
+ 				      new_wm->wm[4].plane_res_b, new_wm->wm[5].plane_res_b,
+ 				      new_wm->wm[6].plane_res_b, new_wm->wm[7].plane_res_b,
+ 				      new_wm->trans_wm.plane_res_b);
+ 
+ 			DRM_DEBUG_KMS("[PLANE:%d:%s] min_ddb %4d,%4d,%4d,%4d,%4d,%4d,%4d,%4d,%4d"
+ 				      " -> %4d,%4d,%4d,%4d,%4d,%4d,%4d,%4d,%4d\n",
+ 				      plane->base.base.id, plane->base.name,
+ 				      old_wm->wm[0].min_ddb_alloc, old_wm->wm[1].min_ddb_alloc,
+ 				      old_wm->wm[2].min_ddb_alloc, old_wm->wm[3].min_ddb_alloc,
+ 				      old_wm->wm[4].min_ddb_alloc, old_wm->wm[5].min_ddb_alloc,
+ 				      old_wm->wm[6].min_ddb_alloc, old_wm->wm[7].min_ddb_alloc,
+ 				      old_wm->trans_wm.min_ddb_alloc,
+ 				      new_wm->wm[0].min_ddb_alloc, new_wm->wm[1].min_ddb_alloc,
+ 				      new_wm->wm[2].min_ddb_alloc, new_wm->wm[3].min_ddb_alloc,
+ 				      new_wm->wm[4].min_ddb_alloc, new_wm->wm[5].min_ddb_alloc,
+ 				      new_wm->wm[6].min_ddb_alloc, new_wm->wm[7].min_ddb_alloc,
+ 				      new_wm->trans_wm.min_ddb_alloc);
++>>>>>>> ab98e94435ab (drm/i915: Dump skl+ watermark changes)
  		}
  	}
  }
* Unmerged path drivers/gpu/drm/i915/intel_pm.c
