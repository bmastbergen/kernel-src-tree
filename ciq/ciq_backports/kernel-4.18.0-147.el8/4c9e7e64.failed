arm64: kexec_file: invoke the kernel without purgatory

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author AKASHI Takahiro <takahiro.akashi@linaro.org>
commit 4c9e7e649a3f291e1b939299458e6844c16afe70
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/4c9e7e64.failed

On arm64, purgatory would do almost nothing. So just invoke secondary
kernel directly by jumping into its entry code.

While, in this case, cpu_soft_restart() must be called with dtb address
in the fifth argument, the behavior still stays compatible with kexec_load
case as long as the argument is null.

	Signed-off-by: AKASHI Takahiro <takahiro.akashi@linaro.org>
	Reviewed-by: James Morse <james.morse@arm.com>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Will Deacon <will.deacon@arm.com>
	Signed-off-by: Will Deacon <will.deacon@arm.com>
(cherry picked from commit 4c9e7e649a3f291e1b939299458e6844c16afe70)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kernel/machine_kexec.c
diff --cc arch/arm64/kernel/machine_kexec.c
index fe402d1087e2,aa9c94113700..000000000000
--- a/arch/arm64/kernel/machine_kexec.c
+++ b/arch/arm64/kernel/machine_kexec.c
@@@ -205,10 -212,17 +205,23 @@@ void machine_kexec(struct kimage *kimag
  	 * uses physical addressing to relocate the new image to its final
  	 * position and transfers control to the image entry point when the
  	 * relocation is complete.
+ 	 * In kexec case, kimage->start points to purgatory assuming that
+ 	 * kernel entry and dtb address are embedded in purgatory by
+ 	 * userspace (kexec-tools).
+ 	 * In kexec_file case, the kernel starts directly without purgatory.
  	 */
++<<<<<<< HEAD
 +
 +	cpu_soft_restart(kimage != kexec_crash_image,
 +		reboot_code_buffer_phys, kimage->head, kimage->start, 0);
++=======
+ 	cpu_soft_restart(reboot_code_buffer_phys, kimage->head, kimage->start,
+ #ifdef CONFIG_KEXEC_FILE
+ 						kimage->arch.dtb_mem);
+ #else
+ 						0);
+ #endif
++>>>>>>> 4c9e7e649a3f (arm64: kexec_file: invoke the kernel without purgatory)
  
  	BUG(); /* Should never get here. */
  }
diff --git a/arch/arm64/kernel/cpu-reset.S b/arch/arm64/kernel/cpu-reset.S
index 8021b46c9743..a2be30275a73 100644
--- a/arch/arm64/kernel/cpu-reset.S
+++ b/arch/arm64/kernel/cpu-reset.S
@@ -22,11 +22,11 @@
  * __cpu_soft_restart(el2_switch, entry, arg0, arg1, arg2) - Helper for
  * cpu_soft_restart.
  *
- * @el2_switch: Flag to indicate a swich to EL2 is needed.
+ * @el2_switch: Flag to indicate a switch to EL2 is needed.
  * @entry: Location to jump to for soft reset.
- * arg0: First argument passed to @entry.
- * arg1: Second argument passed to @entry.
- * arg2: Third argument passed to @entry.
+ * arg0: First argument passed to @entry. (relocation list)
+ * arg1: Second argument passed to @entry.(physical kernel entry)
+ * arg2: Third argument passed to @entry. (physical dtb address)
  *
  * Put the CPU into the same state as it would be if it had been reset, and
  * branch to what would be the reset vector. It must be executed with the
* Unmerged path arch/arm64/kernel/machine_kexec.c
diff --git a/arch/arm64/kernel/relocate_kernel.S b/arch/arm64/kernel/relocate_kernel.S
index f407e422a720..95fd94209aae 100644
--- a/arch/arm64/kernel/relocate_kernel.S
+++ b/arch/arm64/kernel/relocate_kernel.S
@@ -32,6 +32,7 @@
 ENTRY(arm64_relocate_new_kernel)
 
 	/* Setup the list loop variables. */
+	mov	x18, x2				/* x18 = dtb address */
 	mov	x17, x1				/* x17 = kimage_start */
 	mov	x16, x0				/* x16 = kimage_head */
 	raw_dcache_line_size x15, x0		/* x15 = dcache line size */
@@ -107,7 +108,7 @@ ENTRY(arm64_relocate_new_kernel)
 	isb
 
 	/* Start new image. */
-	mov	x0, xzr
+	mov	x0, x18
 	mov	x1, xzr
 	mov	x2, xzr
 	mov	x3, xzr
