bpf: add msg_pop_data helper to tools

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author John Fastabend <john.fastabend@gmail.com>
commit d913a2273a8988cd810a031bfa08249ca7dd5f7c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/d913a227.failed

Add the necessary header definitions to tools for new
msg_pop_data_helper.

	Signed-off-by: John Fastabend <john.fastabend@gmail.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit d913a2273a8988cd810a031bfa08249ca7dd5f7c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/include/uapi/linux/bpf.h
#	tools/testing/selftests/bpf/bpf_helpers.h
diff --cc tools/include/uapi/linux/bpf.h
index dd0da04bd3ab,597afdbc1ab9..000000000000
--- a/tools/include/uapi/linux/bpf.h
+++ b/tools/include/uapi/linux/bpf.h
@@@ -2101,6 -2168,119 +2101,122 @@@ union bpf_attr 
   *		the shared data.
   *	Return
   *		Pointer to the local storage area.
++<<<<<<< HEAD
++=======
+  *
+  * int bpf_sk_select_reuseport(struct sk_reuseport_md *reuse, struct bpf_map *map, void *key, u64 flags)
+  *	Description
+  *		Select a SO_REUSEPORT sk from a	BPF_MAP_TYPE_REUSEPORT_ARRAY map
+  *		It checks the selected sk is matching the incoming
+  *		request in the skb.
+  *	Return
+  *		0 on success, or a negative error in case of failure.
+  *
+  * struct bpf_sock *bpf_sk_lookup_tcp(void *ctx, struct bpf_sock_tuple *tuple, u32 tuple_size, u32 netns, u64 flags)
+  *	Description
+  *		Look for TCP socket matching *tuple*, optionally in a child
+  *		network namespace *netns*. The return value must be checked,
+  *		and if non-NULL, released via **bpf_sk_release**\ ().
+  *
+  *		The *ctx* should point to the context of the program, such as
+  *		the skb or socket (depending on the hook in use). This is used
+  *		to determine the base network namespace for the lookup.
+  *
+  *		*tuple_size* must be one of:
+  *
+  *		**sizeof**\ (*tuple*\ **->ipv4**)
+  *			Look for an IPv4 socket.
+  *		**sizeof**\ (*tuple*\ **->ipv6**)
+  *			Look for an IPv6 socket.
+  *
+  *		If the *netns* is zero, then the socket lookup table in the
+  *		netns associated with the *ctx* will be used. For the TC hooks,
+  *		this in the netns of the device in the skb. For socket hooks,
+  *		this in the netns of the socket. If *netns* is non-zero, then
+  *		it specifies the ID of the netns relative to the netns
+  *		associated with the *ctx*.
+  *
+  *		All values for *flags* are reserved for future usage, and must
+  *		be left at zero.
+  *
+  *		This helper is available only if the kernel was compiled with
+  *		**CONFIG_NET** configuration option.
+  *	Return
+  *		Pointer to *struct bpf_sock*, or NULL in case of failure.
+  *		For sockets with reuseport option, *struct bpf_sock*
+  *		return is from reuse->socks[] using hash of the packet.
+  *
+  * struct bpf_sock *bpf_sk_lookup_udp(void *ctx, struct bpf_sock_tuple *tuple, u32 tuple_size, u32 netns, u64 flags)
+  *	Description
+  *		Look for UDP socket matching *tuple*, optionally in a child
+  *		network namespace *netns*. The return value must be checked,
+  *		and if non-NULL, released via **bpf_sk_release**\ ().
+  *
+  *		The *ctx* should point to the context of the program, such as
+  *		the skb or socket (depending on the hook in use). This is used
+  *		to determine the base network namespace for the lookup.
+  *
+  *		*tuple_size* must be one of:
+  *
+  *		**sizeof**\ (*tuple*\ **->ipv4**)
+  *			Look for an IPv4 socket.
+  *		**sizeof**\ (*tuple*\ **->ipv6**)
+  *			Look for an IPv6 socket.
+  *
+  *		If the *netns* is zero, then the socket lookup table in the
+  *		netns associated with the *ctx* will be used. For the TC hooks,
+  *		this in the netns of the device in the skb. For socket hooks,
+  *		this in the netns of the socket. If *netns* is non-zero, then
+  *		it specifies the ID of the netns relative to the netns
+  *		associated with the *ctx*.
+  *
+  *		All values for *flags* are reserved for future usage, and must
+  *		be left at zero.
+  *
+  *		This helper is available only if the kernel was compiled with
+  *		**CONFIG_NET** configuration option.
+  *	Return
+  *		Pointer to *struct bpf_sock*, or NULL in case of failure.
+  *		For sockets with reuseport option, *struct bpf_sock*
+  *		return is from reuse->socks[] using hash of the packet.
+  *
+  * int bpf_sk_release(struct bpf_sock *sk)
+  *	Description
+  *		Release the reference held by *sock*. *sock* must be a non-NULL
+  *		pointer that was returned from bpf_sk_lookup_xxx\ ().
+  *	Return
+  *		0 on success, or a negative error in case of failure.
+  *
+  * int bpf_msg_push_data(struct sk_buff *skb, u32 start, u32 len, u64 flags)
+  *	Description
+  *		For socket policies, insert *len* bytes into msg at offset
+  *		*start*.
+  *
+  *		If a program of type **BPF_PROG_TYPE_SK_MSG** is run on a
+  *		*msg* it may want to insert metadata or options into the msg.
+  *		This can later be read and used by any of the lower layer BPF
+  *		hooks.
+  *
+  *		This helper may fail if under memory pressure (a malloc
+  *		fails) in these cases BPF programs will get an appropriate
+  *		error and BPF programs will need to handle them.
+  *
+  *	Return
+  *		0 on success, or a negative error in case of failure.
+  *
+  * int bpf_msg_pop_data(struct sk_msg_buff *msg, u32 start, u32 pop, u64 flags)
+  *	 Description
+  *		Will remove *pop* bytes from a *msg* starting at byte *start*.
+  *		This may result in **ENOMEM** errors under certain situations if
+  *		an allocation and copy are required due to a full ring buffer.
+  *		However, the helper will try to avoid doing the allocation
+  *		if possible. Other errors can occur if input parameters are
+  *		invalid either due to *start* byte not being valid part of msg
+  *		payload and/or *pop* value being to large.
+  *
+  *	Return
+  *		0 on success, or a negative erro in case of failure.
++>>>>>>> d913a2273a89 (bpf: add msg_pop_data helper to tools)
   */
  #define __BPF_FUNC_MAPPER(FN)		\
  	FN(unspec),			\
@@@ -2184,7 -2364,17 +2300,21 @@@
  	FN(rc_keydown),			\
  	FN(skb_cgroup_id),		\
  	FN(get_current_cgroup_id),	\
++<<<<<<< HEAD
 +	FN(get_local_storage),
++=======
+ 	FN(get_local_storage),		\
+ 	FN(sk_select_reuseport),	\
+ 	FN(skb_ancestor_cgroup_id),	\
+ 	FN(sk_lookup_tcp),		\
+ 	FN(sk_lookup_udp),		\
+ 	FN(sk_release),			\
+ 	FN(map_push_elem),		\
+ 	FN(map_pop_elem),		\
+ 	FN(map_peek_elem),		\
+ 	FN(msg_push_data),		\
+ 	FN(msg_pop_data),
++>>>>>>> d913a2273a89 (bpf: add msg_pop_data helper to tools)
  
  /* integer value in 'imm' field of BPF_CALL instruction selects which helper
   * function eBPF program intends to call
diff --cc tools/testing/selftests/bpf/bpf_helpers.h
index e4be7730222d,7b69519a09b1..000000000000
--- a/tools/testing/selftests/bpf/bpf_helpers.h
+++ b/tools/testing/selftests/bpf/bpf_helpers.h
@@@ -104,6 -111,10 +104,13 @@@ static int (*bpf_msg_cork_bytes)(void *
  	(void *) BPF_FUNC_msg_cork_bytes;
  static int (*bpf_msg_pull_data)(void *ctx, int start, int end, int flags) =
  	(void *) BPF_FUNC_msg_pull_data;
++<<<<<<< HEAD
++=======
+ static int (*bpf_msg_push_data)(void *ctx, int start, int end, int flags) =
+ 	(void *) BPF_FUNC_msg_push_data;
+ static int (*bpf_msg_pop_data)(void *ctx, int start, int cut, int flags) =
+ 	(void *) BPF_FUNC_msg_pop_data;
++>>>>>>> d913a2273a89 (bpf: add msg_pop_data helper to tools)
  static int (*bpf_bind)(void *ctx, void *addr, int addr_len) =
  	(void *) BPF_FUNC_bind;
  static int (*bpf_xdp_adjust_tail)(void *ctx, int offset) =
* Unmerged path tools/include/uapi/linux/bpf.h
* Unmerged path tools/testing/selftests/bpf/bpf_helpers.h
