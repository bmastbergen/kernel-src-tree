RDMA/uverbs: Use only attrs for the write() handler signature

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jason Gunthorpe <jgg@ziepe.ca>
commit 974d6b4b2bc33c53334e086a40715b384f48f2e2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/974d6b4b.failed

All of the old arguments can be derived from the uverbs_attr_bundle
structure, so get rid of the redundant arguments. Most of the prior work
has been removing users of the arguments to allow this to be a simple
patch.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 974d6b4b2bc33c53334e086a40715b384f48f2e2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/rdma_core.h
#	drivers/infiniband/core/uverbs_cmd.c
#	drivers/infiniband/core/uverbs_main.c
#	drivers/infiniband/core/uverbs_uapi.c
#	include/rdma/uverbs_ioctl.h
diff --cc drivers/infiniband/core/rdma_core.h
index a243cc2a59f7,bac484d6753a..000000000000
--- a/drivers/infiniband/core/rdma_core.h
+++ b/drivers/infiniband/core/rdma_core.h
@@@ -113,4 -106,103 +113,106 @@@ int uverbs_finalize_object(struct ib_uo
  			   enum uverbs_obj_access access,
  			   bool commit);
  
++<<<<<<< HEAD
++=======
+ void setup_ufile_idr_uobject(struct ib_uverbs_file *ufile);
+ void release_ufile_idr_uobject(struct ib_uverbs_file *ufile);
+ 
+ /*
+  * This is the runtime description of the uverbs API, used by the syscall
+  * machinery to validate and dispatch calls.
+  */
+ 
+ /*
+  * Depending on ID the slot pointer in the radix tree points at one of these
+  * structs.
+  */
+ struct uverbs_api_object {
+ 	const struct uverbs_obj_type *type_attrs;
+ 	const struct uverbs_obj_type_class *type_class;
+ 	u8 disabled:1;
+ };
+ 
+ struct uverbs_api_ioctl_method {
+ 	int(__rcu *handler)(struct uverbs_attr_bundle *attrs);
+ 	DECLARE_BITMAP(attr_mandatory, UVERBS_API_ATTR_BKEY_LEN);
+ 	u16 bundle_size;
+ 	u8 use_stack:1;
+ 	u8 driver_method:1;
+ 	u8 disabled:1;
+ 	u8 has_udata:1;
+ 	u8 key_bitmap_len;
+ 	u8 destroy_bkey;
+ };
+ 
+ struct uverbs_api_write_method {
+ 	int (*handler)(struct uverbs_attr_bundle *attrs);
+ 	u8 disabled:1;
+ 	u8 is_ex:1;
+ 	u8 has_udata:1;
+ 	u8 has_resp:1;
+ 	u8 req_size;
+ 	u8 resp_size;
+ };
+ 
+ struct uverbs_api_attr {
+ 	struct uverbs_attr_spec spec;
+ };
+ 
+ struct uverbs_api {
+ 	/* radix tree contains struct uverbs_api_* pointers */
+ 	struct radix_tree_root radix;
+ 	enum rdma_driver_id driver_id;
+ 
+ 	unsigned int num_write;
+ 	unsigned int num_write_ex;
+ 	struct uverbs_api_write_method notsupp_method;
+ 	const struct uverbs_api_write_method **write_methods;
+ 	const struct uverbs_api_write_method **write_ex_methods;
+ };
+ 
+ static inline const struct uverbs_api_object *
+ uapi_get_object(struct uverbs_api *uapi, u16 object_id)
+ {
+ 	return radix_tree_lookup(&uapi->radix, uapi_key_obj(object_id));
+ }
+ 
+ char *uapi_key_format(char *S, unsigned int key);
+ struct uverbs_api *uverbs_alloc_api(struct ib_device *ibdev);
+ void uverbs_disassociate_api_pre(struct ib_uverbs_device *uverbs_dev);
+ void uverbs_disassociate_api(struct uverbs_api *uapi);
+ void uverbs_destroy_api(struct uverbs_api *uapi);
+ void uapi_compute_bundle_size(struct uverbs_api_ioctl_method *method_elm,
+ 			      unsigned int num_attrs);
+ void uverbs_user_mmap_disassociate(struct ib_uverbs_file *ufile);
+ 
+ extern const struct uapi_definition uverbs_def_obj_counters[];
+ extern const struct uapi_definition uverbs_def_obj_cq[];
+ extern const struct uapi_definition uverbs_def_obj_dm[];
+ extern const struct uapi_definition uverbs_def_obj_flow_action[];
+ extern const struct uapi_definition uverbs_def_obj_intf[];
+ extern const struct uapi_definition uverbs_def_obj_mr[];
+ extern const struct uapi_definition uverbs_def_write_intf[];
+ 
+ static inline const struct uverbs_api_write_method *
+ uapi_get_method(const struct uverbs_api *uapi, u32 command)
+ {
+ 	u32 cmd_idx = command & IB_USER_VERBS_CMD_COMMAND_MASK;
+ 
+ 	if (command & ~(u32)(IB_USER_VERBS_CMD_FLAG_EXTENDED |
+ 			     IB_USER_VERBS_CMD_COMMAND_MASK))
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	if (command & IB_USER_VERBS_CMD_FLAG_EXTENDED) {
+ 		if (cmd_idx >= uapi->num_write_ex)
+ 			return ERR_PTR(-EOPNOTSUPP);
+ 		return uapi->write_ex_methods[cmd_idx];
+ 	}
+ 
+ 	if (cmd_idx >= uapi->num_write)
+ 		return ERR_PTR(-EOPNOTSUPP);
+ 	return uapi->write_methods[cmd_idx];
+ }
+ 
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  #endif /* RDMA_CORE_H */
diff --cc drivers/infiniband/core/uverbs_cmd.c
index 300532a4cde8,4dab9f7e1f94..000000000000
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@@ -60,19 -180,17 +60,23 @@@ ib_uverbs_lookup_comp_file(int fd, stru
  	uverbs_uobject_get(uobj);
  	uobj_put_read(uobj);
  
 -	return container_of(uobj, struct ib_uverbs_completion_event_file,
 -			    uobj);
 +	uobj_file = container_of(uobj, struct ib_uobject_file, uobj);
 +	return container_of(uobj_file, struct ib_uverbs_completion_event_file,
 +			    uobj_file);
  }
 -#define ib_uverbs_lookup_comp_file(_fd, _ufile)                                \
 -	_ib_uverbs_lookup_comp_file((_fd)*typecheck(s32, _fd), _ufile)
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_get_context(struct ib_uverbs_file *file,
 +			      struct ib_device *ib_dev,
 +			      const char __user *buf,
 +			      int in_len, int out_len)
++=======
+ static int ib_uverbs_get_context(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
 -	struct ib_uverbs_file *file = attrs->ufile;
  	struct ib_uverbs_get_context      cmd;
  	struct ib_uverbs_get_context_resp resp;
 +	struct ib_udata                   udata;
  	struct ib_ucontext		 *ucontext;
  	struct file			 *filp;
  	struct ib_rdmacg_object		 cg_obj;
@@@ -220,10 -335,7 +224,14 @@@ static void copy_query_dev_fields(struc
  	resp->phys_port_cnt		= ib_dev->phys_port_cnt;
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_query_device(struct ib_uverbs_file *file,
 +			       struct ib_device *ib_dev,
 +			       const char __user *buf,
 +			       int in_len, int out_len)
++=======
+ static int ib_uverbs_query_device(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_query_device      cmd;
  	struct ib_uverbs_query_device_resp resp;
@@@ -264,10 -377,7 +272,14 @@@ static u32 make_port_cap_flags(const st
  	return res;
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_query_port(struct ib_uverbs_file *file,
 +			     struct ib_device *ib_dev,
 +			     const char __user *buf,
 +			     int in_len, int out_len)
++=======
+ static int ib_uverbs_query_port(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_query_port      cmd;
  	struct ib_uverbs_query_port_resp resp;
@@@ -317,16 -432,10 +329,20 @@@
  	resp.link_layer      = rdma_port_get_link_layer(ib_dev,
  							cmd.port_num);
  
 -	return uverbs_response(attrs, &resp, sizeof(resp));
 +	if (copy_to_user(u64_to_user_ptr(cmd.response), &resp, sizeof resp))
 +		return -EFAULT;
 +
 +	return in_len;
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_alloc_pd(struct ib_uverbs_file *file,
 +			   struct ib_device *ib_dev,
 +			   const char __user *buf,
 +			   int in_len, int out_len)
++=======
+ static int ib_uverbs_alloc_pd(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_alloc_pd      cmd;
  	struct ib_uverbs_alloc_pd_resp resp;
@@@ -384,18 -483,16 +400,22 @@@ err
  	return ret;
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_dealloc_pd(struct ib_uverbs_file *file,
 +			     struct ib_device *ib_dev,
 +			     const char __user *buf,
 +			     int in_len, int out_len)
++=======
+ static int ib_uverbs_dealloc_pd(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_dealloc_pd cmd;
 -	int ret;
  
 -	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
 -	if (ret)
 -		return ret;
 +	if (copy_from_user(&cmd, buf, sizeof cmd))
 +		return -EFAULT;
  
 -	return uobj_perform_destroy(UVERBS_OBJECT_PD, cmd.pd_handle, attrs);
 +	return uobj_perform_destroy(UVERBS_OBJECT_PD, cmd.pd_handle, file,
 +				    in_len);
  }
  
  struct xrcd_table_entry {
@@@ -483,14 -580,11 +503,18 @@@ static void xrcd_table_delete(struct ib
  	}
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_open_xrcd(struct ib_uverbs_file *file,
 +			    struct ib_device *ib_dev,
 +			    const char __user *buf, int in_len,
 +			    int out_len)
++=======
+ static int ib_uverbs_open_xrcd(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
 -	struct ib_uverbs_device *ibudev = attrs->ufile->device;
  	struct ib_uverbs_open_xrcd	cmd;
  	struct ib_uverbs_open_xrcd_resp	resp;
 +	struct ib_udata			udata;
  	struct ib_uxrcd_object         *obj;
  	struct ib_xrcd                 *xrcd = NULL;
  	struct fd			f = {NULL, 0};
@@@ -606,21 -692,19 +630,25 @@@ err_tree_mutex_unlock
  	return ret;
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_close_xrcd(struct ib_uverbs_file *file,
 +			     struct ib_device *ib_dev,
 +			     const char __user *buf, int in_len,
 +			     int out_len)
++=======
+ static int ib_uverbs_close_xrcd(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_close_xrcd cmd;
 -	int ret;
  
 -	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
 -	if (ret)
 -		return ret;
 +	if (copy_from_user(&cmd, buf, sizeof cmd))
 +		return -EFAULT;
  
 -	return uobj_perform_destroy(UVERBS_OBJECT_XRCD, cmd.xrcd_handle, attrs);
 +	return uobj_perform_destroy(UVERBS_OBJECT_XRCD, cmd.xrcd_handle, file,
 +				    in_len);
  }
  
 -int ib_uverbs_dealloc_xrcd(struct ib_uobject *uobject,
 +int ib_uverbs_dealloc_xrcd(struct ib_uverbs_device *dev,
  			   struct ib_xrcd *xrcd,
  			   enum rdma_remove_reason why)
  {
@@@ -641,10 -729,7 +669,14 @@@
  	return ret;
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_reg_mr(struct ib_uverbs_file *file,
 +			 struct ib_device *ib_dev,
 +			 const char __user *buf, int in_len,
 +			 int out_len)
++=======
+ static int ib_uverbs_reg_mr(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_reg_mr      cmd;
  	struct ib_uverbs_reg_mr_resp resp;
@@@ -735,10 -810,7 +767,14 @@@ err_free
  	return ret;
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_rereg_mr(struct ib_uverbs_file *file,
 +			   struct ib_device *ib_dev,
 +			   const char __user *buf, int in_len,
 +			   int out_len)
++=======
+ static int ib_uverbs_rereg_mr(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_rereg_mr      cmd;
  	struct ib_uverbs_rereg_mr_resp resp;
@@@ -827,24 -888,19 +863,32 @@@ put_uobjs
  	return ret;
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_dereg_mr(struct ib_uverbs_file *file,
 +			   struct ib_device *ib_dev,
 +			   const char __user *buf, int in_len,
 +			   int out_len)
++=======
+ static int ib_uverbs_dereg_mr(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_dereg_mr cmd;
 -	int ret;
  
 -	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
 -	if (ret)
 -		return ret;
 +	if (copy_from_user(&cmd, buf, sizeof cmd))
 +		return -EFAULT;
  
 -	return uobj_perform_destroy(UVERBS_OBJECT_MR, cmd.mr_handle, attrs);
 +	return uobj_perform_destroy(UVERBS_OBJECT_MR, cmd.mr_handle, file,
 +				    in_len);
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_alloc_mw(struct ib_uverbs_file *file,
 +			   struct ib_device *ib_dev,
 +			   const char __user *buf, int in_len,
 +			   int out_len)
++=======
+ static int ib_uverbs_alloc_mw(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_alloc_mw      cmd;
  	struct ib_uverbs_alloc_mw_resp resp;
@@@ -911,24 -957,19 +955,32 @@@ err_free
  	return ret;
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_dealloc_mw(struct ib_uverbs_file *file,
 +			     struct ib_device *ib_dev,
 +			     const char __user *buf, int in_len,
 +			     int out_len)
++=======
+ static int ib_uverbs_dealloc_mw(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_dealloc_mw cmd;
 -	int ret;
  
 -	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
 -	if (ret)
 -		return ret;
 +	if (copy_from_user(&cmd, buf, sizeof(cmd)))
 +		return -EFAULT;
  
 -	return uobj_perform_destroy(UVERBS_OBJECT_MW, cmd.mw_handle, attrs);
 +	return uobj_perform_destroy(UVERBS_OBJECT_MW, cmd.mw_handle, file,
 +				    in_len);
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_create_comp_channel(struct ib_uverbs_file *file,
 +				      struct ib_device *ib_dev,
 +				      const char __user *buf, int in_len,
 +				      int out_len)
++=======
+ static int ib_uverbs_create_comp_channel(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_create_comp_channel	   cmd;
  	struct ib_uverbs_create_comp_channel_resp  resp;
@@@ -1056,21 -1083,7 +1108,25 @@@ err
  	return ERR_PTR(ret);
  }
  
++<<<<<<< HEAD
 +static int ib_uverbs_create_cq_cb(struct ib_uverbs_file *file,
 +				  struct ib_ucq_object *obj,
 +				  struct ib_uverbs_ex_create_cq_resp *resp,
 +				  struct ib_udata *ucore, void *context)
 +{
 +	if (ib_copy_to_udata(ucore, &resp->base, sizeof(resp->base)))
 +		return -EFAULT;
 +
 +	return 0;
 +}
 +
 +ssize_t ib_uverbs_create_cq(struct ib_uverbs_file *file,
 +			    struct ib_device *ib_dev,
 +			    const char __user *buf, int in_len,
 +			    int out_len)
++=======
+ static int ib_uverbs_create_cq(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_create_cq      cmd;
  	struct ib_uverbs_ex_create_cq	cmd_ex;
@@@ -1099,44 -1100,19 +1155,48 @@@
  	cmd_ex.comp_vector = cmd.comp_vector;
  	cmd_ex.comp_channel = cmd.comp_channel;
  
 -	obj = create_cq(attrs, &cmd_ex);
 -	return PTR_ERR_OR_ZERO(obj);
 +	obj = create_cq(file, ib_dev, &ucore, &uhw, &cmd_ex,
 +			offsetof(typeof(cmd_ex), comp_channel) +
 +			sizeof(cmd.comp_channel), ib_uverbs_create_cq_cb,
 +			NULL);
 +
 +	if (IS_ERR(obj))
 +		return PTR_ERR(obj);
 +
 +	return in_len;
  }
  
++<<<<<<< HEAD
 +static int ib_uverbs_ex_create_cq_cb(struct ib_uverbs_file *file,
 +				     struct ib_ucq_object *obj,
 +				     struct ib_uverbs_ex_create_cq_resp *resp,
 +				     struct ib_udata *ucore, void *context)
++=======
+ static int ib_uverbs_ex_create_cq(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
 +	if (ib_copy_to_udata(ucore, resp, resp->response_length))
 +		return -EFAULT;
 +
 +	return 0;
 +}
 +
 +int ib_uverbs_ex_create_cq(struct ib_uverbs_file *file,
 +			 struct ib_device *ib_dev,
 +			   struct ib_udata *ucore,
 +			   struct ib_udata *uhw)
 +{
 +	struct ib_uverbs_ex_create_cq_resp resp;
  	struct ib_uverbs_ex_create_cq  cmd;
  	struct ib_ucq_object           *obj;
 -	int ret;
 +	int err;
  
 -	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
 -	if (ret)
 -		return ret;
 +	if (ucore->inlen < sizeof(cmd))
 +		return -EINVAL;
 +
 +	err = ib_copy_from_udata(&cmd, ucore, sizeof(cmd));
 +	if (err)
 +		return err;
  
  	if (cmd.comp_mask)
  		return -EINVAL;
@@@ -1155,10 -1124,7 +1215,14 @@@
  	return PTR_ERR_OR_ZERO(obj);
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_resize_cq(struct ib_uverbs_file *file,
 +			    struct ib_device *ib_dev,
 +			    const char __user *buf, int in_len,
 +			    int out_len)
++=======
+ static int ib_uverbs_resize_cq(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_resize_cq	cmd;
  	struct ib_uverbs_resize_cq_resp	resp = {};
@@@ -1223,10 -1182,7 +1287,14 @@@ static int copy_wc_to_user(struct ib_de
  	return 0;
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_poll_cq(struct ib_uverbs_file *file,
 +			  struct ib_device *ib_dev,
 +			  const char __user *buf, int in_len,
 +			  int out_len)
++=======
+ static int ib_uverbs_poll_cq(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_poll_cq       cmd;
  	struct ib_uverbs_poll_cq_resp  resp;
@@@ -1275,10 -1232,7 +1343,14 @@@ out_put
  	return ret;
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_req_notify_cq(struct ib_uverbs_file *file,
 +				struct ib_device *ib_dev,
 +				const char __user *buf, int in_len,
 +				int out_len)
++=======
+ static int ib_uverbs_req_notify_cq(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_req_notify_cq cmd;
  	struct ib_cq                  *cq;
@@@ -1295,13 -1251,10 +1367,17 @@@
  
  	uobj_put_obj_read(cq);
  
 -	return 0;
 +	return in_len;
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_destroy_cq(struct ib_uverbs_file *file,
 +			     struct ib_device *ib_dev,
 +			     const char __user *buf, int in_len,
 +			     int out_len)
++=======
+ static int ib_uverbs_destroy_cq(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_destroy_cq      cmd;
  	struct ib_uverbs_destroy_cq_resp resp;
@@@ -1619,20 -1526,7 +1695,24 @@@ err_put
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int ib_uverbs_create_qp_cb(struct ib_uverbs_file *file,
 +				  struct ib_uverbs_ex_create_qp_resp *resp,
 +				  struct ib_udata *ucore)
 +{
 +	if (ib_copy_to_udata(ucore, &resp->base, sizeof(resp->base)))
 +		return -EFAULT;
 +
 +	return 0;
 +}
 +
 +ssize_t ib_uverbs_create_qp(struct ib_uverbs_file *file,
 +			    struct ib_device *ib_dev,
 +			    const char __user *buf, int in_len,
 +			    int out_len)
++=======
+ static int ib_uverbs_create_qp(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_create_qp      cmd;
  	struct ib_uverbs_ex_create_qp	cmd_ex;
@@@ -1669,43 -1551,17 +1749,47 @@@
  	cmd_ex.qp_type = cmd.qp_type;
  	cmd_ex.is_srq = cmd.is_srq;
  
 -	return create_qp(attrs, &cmd_ex);
 +	err = create_qp(file, &ucore, &uhw, &cmd_ex,
 +			offsetof(typeof(cmd_ex), is_srq) +
 +			sizeof(cmd.is_srq), ib_uverbs_create_qp_cb,
 +			NULL);
 +
 +	if (err)
 +		return err;
 +
 +	return in_len;
  }
  
++<<<<<<< HEAD
 +static int ib_uverbs_ex_create_qp_cb(struct ib_uverbs_file *file,
 +				     struct ib_uverbs_ex_create_qp_resp *resp,
 +				     struct ib_udata *ucore)
++=======
+ static int ib_uverbs_ex_create_qp(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
 -	struct ib_uverbs_ex_create_qp cmd;
 -	int ret;
 +	if (ib_copy_to_udata(ucore, resp, resp->response_length))
 +		return -EFAULT;
  
 -	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
 -	if (ret)
 -		return ret;
 +	return 0;
 +}
 +
 +int ib_uverbs_ex_create_qp(struct ib_uverbs_file *file,
 +			   struct ib_device *ib_dev,
 +			   struct ib_udata *ucore,
 +			   struct ib_udata *uhw)
 +{
 +	struct ib_uverbs_ex_create_qp_resp resp;
 +	struct ib_uverbs_ex_create_qp cmd = {0};
 +	int err;
 +
 +	if (ucore->inlen < (offsetof(typeof(cmd), comp_mask) +
 +			    sizeof(cmd.comp_mask)))
 +		return -EINVAL;
 +
 +	err = ib_copy_from_udata(&cmd, ucore, min(sizeof(cmd), ucore->inlen));
 +	if (err)
 +		return err;
  
  	if (cmd.comp_mask & ~IB_UVERBS_CREATE_QP_SUP_COMP_MASK)
  		return -EINVAL;
@@@ -1713,23 -1569,10 +1797,27 @@@
  	if (cmd.reserved)
  		return -EINVAL;
  
 -	return create_qp(attrs, &cmd);
 +	if (ucore->outlen < (offsetof(typeof(resp), response_length) +
 +			     sizeof(resp.response_length)))
 +		return -ENOSPC;
 +
 +	err = create_qp(file, ucore, uhw, &cmd,
 +			min(ucore->inlen, sizeof(cmd)),
 +			ib_uverbs_ex_create_qp_cb, NULL);
 +
 +	if (err)
 +		return err;
 +
 +	return 0;
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_open_qp(struct ib_uverbs_file *file,
 +			  struct ib_device *ib_dev,
 +			  const char __user *buf, int in_len, int out_len)
++=======
+ static int ib_uverbs_open_qp(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_open_qp        cmd;
  	struct ib_uverbs_create_qp_resp resp;
@@@ -1838,10 -1669,7 +1926,14 @@@ static void copy_ah_attr_to_uverbs(stru
  	uverb_attr->port_num          = rdma_ah_get_port_num(rdma_attr);
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_query_qp(struct ib_uverbs_file *file,
 +			   struct ib_device *ib_dev,
 +			   const char __user *buf, int in_len,
 +			   int out_len)
++=======
+ static int ib_uverbs_query_qp(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_query_qp      cmd;
  	struct ib_uverbs_query_qp_resp resp;
@@@ -2112,27 -1941,31 +2204,43 @@@ out
  	return ret;
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_modify_qp(struct ib_uverbs_file *file,
 +			    struct ib_device *ib_dev,
 +			    const char __user *buf, int in_len,
 +			    int out_len)
++=======
+ static int ib_uverbs_modify_qp(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
 -	struct ib_uverbs_ex_modify_qp cmd;
 +	struct ib_uverbs_ex_modify_qp cmd = {};
 +	struct ib_udata udata;
  	int ret;
  
 -	ret = uverbs_request(attrs, &cmd.base, sizeof(cmd.base));
 -	if (ret)
 -		return ret;
 +	if (copy_from_user(&cmd.base, buf, sizeof(cmd.base)))
 +		return -EFAULT;
  
  	if (cmd.base.attr_mask &
  	    ~((IB_USER_LEGACY_LAST_QP_ATTR_MASK << 1) - 1))
  		return -EOPNOTSUPP;
  
 -	return modify_qp(attrs, &cmd);
 -}
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd.base), NULL,
 +		   in_len - sizeof(cmd.base) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len);
  
++<<<<<<< HEAD
 +	ret = modify_qp(file, &cmd, &udata);
++=======
+ static int ib_uverbs_ex_modify_qp(struct uverbs_attr_bundle *attrs)
+ {
+ 	struct ib_uverbs_ex_modify_qp cmd;
+ 	struct ib_uverbs_ex_modify_qp_resp resp = {
+ 		.response_length = uverbs_response_length(attrs, sizeof(resp))
+ 	};
+ 	int ret;
+ 
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  	if (ret)
  		return ret;
  
@@@ -2164,21 -1979,14 +2272,25 @@@ int ib_uverbs_ex_modify_qp(struct ib_uv
  	    ~((IB_USER_LAST_QP_ATTR_MASK << 1) - 1))
  		return -EOPNOTSUPP;
  
 -	ret = modify_qp(attrs, &cmd);
 -	if (ret)
 -		return ret;
 +	if (ucore->inlen > sizeof(cmd)) {
 +		if (!ib_is_udata_cleared(ucore, sizeof(cmd),
 +					 ucore->inlen - sizeof(cmd)))
 +			return -EOPNOTSUPP;
 +	}
 +
 +	ret = modify_qp(file, &cmd, uhw);
  
 -	return uverbs_response(attrs, &resp, sizeof(resp));
 +	return ret;
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_destroy_qp(struct ib_uverbs_file *file,
 +			     struct ib_device *ib_dev,
 +			     const char __user *buf, int in_len,
 +			     int out_len)
++=======
+ static int ib_uverbs_destroy_qp(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_destroy_qp      cmd;
  	struct ib_uverbs_destroy_qp_resp resp;
@@@ -2228,10 -2021,7 +2340,14 @@@ static void *alloc_wr(size_t wr_size, _
  			 num_sge * sizeof (struct ib_sge), GFP_KERNEL);
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_post_send(struct ib_uverbs_file *file,
 +			    struct ib_device *ib_dev,
 +			    const char __user *buf, int in_len,
 +			    int out_len)
++=======
+ static int ib_uverbs_post_send(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_post_send      cmd;
  	struct ib_uverbs_post_send_resp resp;
@@@ -2508,10 -2310,7 +2624,14 @@@ err
  	return ERR_PTR(ret);
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_post_recv(struct ib_uverbs_file *file,
 +			    struct ib_device *ib_dev,
 +			    const char __user *buf, int in_len,
 +			    int out_len)
++=======
+ static int ib_uverbs_post_recv(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_post_recv      cmd;
  	struct ib_uverbs_post_recv_resp resp;
@@@ -2554,13 -2357,10 +2674,17 @@@ out
  		wr = next;
  	}
  
 -	return ret;
 +	return ret ? ret : in_len;
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_post_srq_recv(struct ib_uverbs_file *file,
 +				struct ib_device *ib_dev,
 +				const char __user *buf, int in_len,
 +				int out_len)
++=======
+ static int ib_uverbs_post_srq_recv(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_post_srq_recv      cmd;
  	struct ib_uverbs_post_srq_recv_resp resp;
@@@ -2604,13 -2408,10 +2728,17 @@@ out
  		wr = next;
  	}
  
 -	return ret;
 +	return ret ? ret : in_len;
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_create_ah(struct ib_uverbs_file *file,
 +			    struct ib_device *ib_dev,
 +			    const char __user *buf, int in_len,
 +			    int out_len)
++=======
+ static int ib_uverbs_create_ah(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_create_ah	 cmd;
  	struct ib_uverbs_create_ah_resp	 resp;
@@@ -2696,23 -2489,19 +2824,31 @@@ err
  	return ret;
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_destroy_ah(struct ib_uverbs_file *file,
 +			     struct ib_device *ib_dev,
 +			     const char __user *buf, int in_len, int out_len)
++=======
+ static int ib_uverbs_destroy_ah(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_destroy_ah cmd;
 -	int ret;
  
 -	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
 -	if (ret)
 -		return ret;
 +	if (copy_from_user(&cmd, buf, sizeof cmd))
 +		return -EFAULT;
  
 -	return uobj_perform_destroy(UVERBS_OBJECT_AH, cmd.ah_handle, attrs);
 +	return uobj_perform_destroy(UVERBS_OBJECT_AH, cmd.ah_handle, file,
 +				    in_len);
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_attach_mcast(struct ib_uverbs_file *file,
 +			       struct ib_device *ib_dev,
 +			       const char __user *buf, int in_len,
 +			       int out_len)
++=======
+ static int ib_uverbs_attach_mcast(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_attach_mcast cmd;
  	struct ib_qp                 *qp;
@@@ -2756,13 -2546,10 +2892,17 @@@ out_put
  	mutex_unlock(&obj->mcast_lock);
  	uobj_put_obj_read(qp);
  
 -	return ret;
 +	return ret ? ret : in_len;
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_detach_mcast(struct ib_uverbs_file *file,
 +			       struct ib_device *ib_dev,
 +			       const char __user *buf, int in_len,
 +			       int out_len)
++=======
+ static int ib_uverbs_detach_mcast(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_detach_mcast cmd;
  	struct ib_uqp_object         *obj;
@@@ -3128,12 -2910,9 +3268,16 @@@ static int kern_spec_to_ib_spec(struct 
  		return kern_spec_to_ib_spec_filter(kern_spec, ib_spec);
  }
  
++<<<<<<< HEAD
 +int ib_uverbs_ex_create_wq(struct ib_uverbs_file *file,
 +			   struct ib_device *ib_dev,
 +			   struct ib_udata *ucore,
 +			   struct ib_udata *uhw)
++=======
+ static int ib_uverbs_ex_create_wq(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
 -	struct ib_uverbs_ex_create_wq cmd;
 +	struct ib_uverbs_ex_create_wq	  cmd = {};
  	struct ib_uverbs_ex_create_wq_resp resp = {};
  	struct ib_uwq_object           *obj;
  	int err = 0;
@@@ -3245,12 -3001,9 +3389,16 @@@ err_uobj
  	return err;
  }
  
++<<<<<<< HEAD
 +int ib_uverbs_ex_destroy_wq(struct ib_uverbs_file *file,
 +			    struct ib_device *ib_dev,
 +			    struct ib_udata *ucore,
 +			    struct ib_udata *uhw)
++=======
+ static int ib_uverbs_ex_destroy_wq(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
 -	struct ib_uverbs_ex_destroy_wq	cmd;
 +	struct ib_uverbs_ex_destroy_wq	cmd = {};
  	struct ib_uverbs_ex_destroy_wq_resp	resp = {};
  	struct ib_uobject		*uobj;
  	struct ib_uwq_object		*obj;
@@@ -3286,42 -3022,21 +3434,46 @@@
  		return PTR_ERR(uobj);
  
  	obj = container_of(uobj, struct ib_uwq_object, uevent.uobject);
 -	resp.events_reported = obj->uevent.events_reported;
 +	/*
 +	 * Make sure we don't free the memory in remove_commit as we still
 +	 * needs the uobject memory to create the response.
 +	 */
 +	uverbs_uobject_get(uobj);
  
 -	uobj_put_destroy(uobj);
 +	ret = uobj_remove_commit(uobj);
 +	resp.events_reported = obj->uevent.events_reported;
 +	uverbs_uobject_put(uobj);
 +	if (ret)
 +		return ret;
  
 -	return uverbs_response(attrs, &resp, sizeof(resp));
 +	return ib_copy_to_udata(ucore, &resp, resp.response_length);
  }
  
++<<<<<<< HEAD
 +int ib_uverbs_ex_modify_wq(struct ib_uverbs_file *file,
 +			   struct ib_device *ib_dev,
 +			   struct ib_udata *ucore,
 +			   struct ib_udata *uhw)
++=======
+ static int ib_uverbs_ex_modify_wq(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
 -	struct ib_uverbs_ex_modify_wq cmd;
 +	struct ib_uverbs_ex_modify_wq cmd = {};
  	struct ib_wq *wq;
  	struct ib_wq_attr wq_attr = {};
 +	size_t required_cmd_sz;
  	int ret;
  
 -	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
 +	required_cmd_sz = offsetof(typeof(cmd), curr_wq_state) + sizeof(cmd.curr_wq_state);
 +	if (ucore->inlen < required_cmd_sz)
 +		return -EINVAL;
 +
 +	if (ucore->inlen > sizeof(cmd) &&
 +	    !ib_is_udata_cleared(ucore, sizeof(cmd),
 +				 ucore->inlen - sizeof(cmd)))
 +		return -EOPNOTSUPP;
 +
 +	ret = ib_copy_from_udata(&cmd, ucore, min(sizeof(cmd), ucore->inlen));
  	if (ret)
  		return ret;
  
@@@ -3351,15 -3062,12 +3503,19 @@@ out
  	return ret;
  }
  
++<<<<<<< HEAD
 +int ib_uverbs_ex_create_rwq_ind_table(struct ib_uverbs_file *file,
 +				      struct ib_device *ib_dev,
 +				      struct ib_udata *ucore,
 +				      struct ib_udata *uhw)
++=======
+ static int ib_uverbs_ex_create_rwq_ind_table(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
 -	struct ib_uverbs_ex_create_rwq_ind_table cmd;
 +	struct ib_uverbs_ex_create_rwq_ind_table	  cmd = {};
  	struct ib_uverbs_ex_create_rwq_ind_table_resp  resp = {};
  	struct ib_uobject		  *uobj;
 -	int err;
 +	int err = 0;
  	struct ib_rwq_ind_table_init_attr init_attr = {};
  	struct ib_rwq_ind_table *rwq_ind_tbl;
  	struct ib_wq	**wqs = NULL;
@@@ -3495,26 -3176,12 +3651,30 @@@ err_free
  	return err;
  }
  
++<<<<<<< HEAD
 +int ib_uverbs_ex_destroy_rwq_ind_table(struct ib_uverbs_file *file,
 +				       struct ib_device *ib_dev,
 +				       struct ib_udata *ucore,
 +				       struct ib_udata *uhw)
++=======
+ static int ib_uverbs_ex_destroy_rwq_ind_table(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
 -	struct ib_uverbs_ex_destroy_rwq_ind_table cmd;
 -	int ret;
 +	struct ib_uverbs_ex_destroy_rwq_ind_table	cmd = {};
 +	int			ret;
 +	size_t required_cmd_sz;
  
 -	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
 +	required_cmd_sz = offsetof(typeof(cmd), ind_tbl_handle) + sizeof(cmd.ind_tbl_handle);
 +
 +	if (ucore->inlen < required_cmd_sz)
 +		return -EINVAL;
 +
 +	if (ucore->inlen > sizeof(cmd) &&
 +	    !ib_is_udata_cleared(ucore, sizeof(cmd),
 +				 ucore->inlen - sizeof(cmd)))
 +		return -EOPNOTSUPP;
 +
 +	ret = ib_copy_from_udata(&cmd, ucore, min(sizeof(cmd), ucore->inlen));
  	if (ret)
  		return ret;
  
@@@ -3522,13 -3189,10 +3682,17 @@@
  		return -EOPNOTSUPP;
  
  	return uobj_perform_destroy(UVERBS_OBJECT_RWQ_IND_TBL,
 -				    cmd.ind_tbl_handle, attrs);
 +				    cmd.ind_tbl_handle, file, 0);
  }
  
++<<<<<<< HEAD
 +int ib_uverbs_ex_create_flow(struct ib_uverbs_file *file,
 +			     struct ib_device *ib_dev,
 +			     struct ib_udata *ucore,
 +			     struct ib_udata *uhw)
++=======
+ static int ib_uverbs_ex_create_flow(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_create_flow	  cmd;
  	struct ib_uverbs_create_flow_resp resp;
@@@ -3705,10 -3357,7 +3869,14 @@@ err_free_attr
  	return err;
  }
  
++<<<<<<< HEAD
 +int ib_uverbs_ex_destroy_flow(struct ib_uverbs_file *file,
 +			      struct ib_device *ib_dev,
 +			      struct ib_udata *ucore,
 +			      struct ib_udata *uhw)
++=======
+ static int ib_uverbs_ex_destroy_flow(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_destroy_flow	cmd;
  	int				ret;
@@@ -3865,10 -3506,7 +4033,14 @@@ err
  	return ret;
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_create_srq(struct ib_uverbs_file *file,
 +			     struct ib_device *ib_dev,
 +			     const char __user *buf, int in_len,
 +			     int out_len)
++=======
+ static int ib_uverbs_create_srq(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_create_srq      cmd;
  	struct ib_uverbs_create_xsrq     xcmd;
@@@ -3891,52 -3525,24 +4063,65 @@@
  	xcmd.max_sge	 = cmd.max_sge;
  	xcmd.srq_limit	 = cmd.srq_limit;
  
 -	return __uverbs_create_xsrq(attrs, &xcmd, &attrs->driver_udata);
 -}
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len - sizeof(resp));
  
++<<<<<<< HEAD
 +	ret = __uverbs_create_xsrq(file, ib_dev, &xcmd, &udata);
++=======
+ static int ib_uverbs_create_xsrq(struct uverbs_attr_bundle *attrs)
+ {
+ 	struct ib_uverbs_create_xsrq     cmd;
+ 	int ret;
+ 
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
 +	if (ret)
 +		return ret;
 +
 +	return in_len;
 +}
 +
++<<<<<<< HEAD
 +ssize_t ib_uverbs_create_xsrq(struct ib_uverbs_file *file,
 +			      struct ib_device *ib_dev,
 +			      const char __user *buf, int in_len, int out_len)
 +{
 +	struct ib_uverbs_create_xsrq     cmd;
 +	struct ib_uverbs_create_srq_resp resp;
 +	struct ib_udata                  udata;
 +	int ret;
 +
 +	if (out_len < sizeof resp)
 +		return -ENOSPC;
 +
 +	if (copy_from_user(&cmd, buf, sizeof cmd))
 +		return -EFAULT;
 +
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len - sizeof(resp));
 +
 +	ret = __uverbs_create_xsrq(file, ib_dev, &cmd, &udata);
  	if (ret)
  		return ret;
  
 -	return __uverbs_create_xsrq(attrs, &cmd, &attrs->driver_udata);
 +	return in_len;
  }
  
 +ssize_t ib_uverbs_modify_srq(struct ib_uverbs_file *file,
 +			     struct ib_device *ib_dev,
 +			     const char __user *buf, int in_len,
 +			     int out_len)
++=======
+ static int ib_uverbs_modify_srq(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_modify_srq cmd;
 +	struct ib_udata             udata;
  	struct ib_srq              *srq;
  	struct ib_srq_attr          attr;
  	int                         ret;
@@@ -3958,13 -3563,10 +4143,17 @@@
  
  	uobj_put_obj_read(srq);
  
 -	return ret;
 +	return ret ? ret : in_len;
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_query_srq(struct ib_uverbs_file *file,
 +			    struct ib_device *ib_dev,
 +			    const char __user *buf,
 +			    int in_len, int out_len)
++=======
+ static int ib_uverbs_query_srq(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_query_srq      cmd;
  	struct ib_uverbs_query_srq_resp resp;
@@@ -3995,16 -3595,10 +4184,20 @@@
  	resp.max_sge   = attr.max_sge;
  	resp.srq_limit = attr.srq_limit;
  
 -	return uverbs_response(attrs, &resp, sizeof(resp));
 +	if (copy_to_user(u64_to_user_ptr(cmd.response), &resp, sizeof resp))
 +		return -EFAULT;
 +
 +	return in_len;
  }
  
++<<<<<<< HEAD
 +ssize_t ib_uverbs_destroy_srq(struct ib_uverbs_file *file,
 +			      struct ib_device *ib_dev,
 +			      const char __user *buf, int in_len,
 +			      int out_len)
++=======
+ static int ib_uverbs_destroy_srq(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
  	struct ib_uverbs_destroy_srq      cmd;
  	struct ib_uverbs_destroy_srq_resp resp;
@@@ -4021,44 -3615,29 +4214,48 @@@
  		return PTR_ERR(uobj);
  
  	obj = container_of(uobj, struct ib_uevent_object, uobject);
 +	/*
 +	 * Make sure we don't free the memory in remove_commit as we still
 +	 * needs the uobject memory to create the response.
 +	 */
 +	uverbs_uobject_get(uobj);
 +
  	memset(&resp, 0, sizeof(resp));
 -	resp.events_reported = obj->events_reported;
  
 -	uobj_put_destroy(uobj);
 +	ret = uobj_remove_commit(uobj);
 +	if (ret) {
 +		uverbs_uobject_put(uobj);
 +		return ret;
 +	}
 +	resp.events_reported = obj->events_reported;
 +	uverbs_uobject_put(uobj);
 +	if (copy_to_user(u64_to_user_ptr(cmd.response), &resp, sizeof(resp)))
 +		return -EFAULT;
  
 -	return uverbs_response(attrs, &resp, sizeof(resp));
 +	return in_len;
  }
  
++<<<<<<< HEAD
 +int ib_uverbs_ex_query_device(struct ib_uverbs_file *file,
 +			      struct ib_device *ib_dev,
 +			      struct ib_udata *ucore,
 +			      struct ib_udata *uhw)
++=======
+ static int ib_uverbs_ex_query_device(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
 -	struct ib_uverbs_ex_query_device_resp resp = {};
 +	struct ib_uverbs_ex_query_device_resp resp = { {0} };
  	struct ib_uverbs_ex_query_device  cmd;
  	struct ib_device_attr attr = {0};
 -	struct ib_ucontext *ucontext;
 -	struct ib_device *ib_dev;
  	int err;
  
 -	ucontext = ib_uverbs_get_ucontext(attrs);
 -	if (IS_ERR(ucontext))
 -		return PTR_ERR(ucontext);
 -	ib_dev = ucontext->device;
 +	if (!ib_dev->query_device)
 +		return -EOPNOTSUPP;
 +
 +	if (ucore->inlen < sizeof(cmd))
 +		return -EINVAL;
  
 -	err = uverbs_request(attrs, &cmd, sizeof(cmd));
 +	err = ib_copy_from_udata(&cmd, ucore, sizeof(cmd));
  	if (err)
  		return err;
  
@@@ -4151,40 -3682,19 +4348,44 @@@
  		attr.cq_caps.max_cq_moderation_count;
  	resp.cq_moderation_caps.max_cq_moderation_period =
  		attr.cq_caps.max_cq_moderation_period;
 -	resp.max_dm_size = attr.max_dm_size;
 -	resp.response_length = uverbs_response_length(attrs, sizeof(resp));
 +	resp.response_length += sizeof(resp.cq_moderation_caps);
  
 -	return uverbs_response(attrs, &resp, sizeof(resp));
 +	if (ucore->outlen < resp.response_length + sizeof(resp.max_dm_size))
 +		goto end;
 +
 +	resp.max_dm_size = attr.max_dm_size;
 +	resp.response_length += sizeof(resp.max_dm_size);
 +end:
 +	err = ib_copy_to_udata(ucore, &resp, resp.response_length);
 +	return err;
  }
  
++<<<<<<< HEAD
 +int ib_uverbs_ex_modify_cq(struct ib_uverbs_file *file,
 +			   struct ib_device *ib_dev,
 +			   struct ib_udata *ucore,
 +			   struct ib_udata *uhw)
++=======
+ static int ib_uverbs_ex_modify_cq(struct uverbs_attr_bundle *attrs)
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  {
 -	struct ib_uverbs_ex_modify_cq cmd;
 +	struct ib_uverbs_ex_modify_cq cmd = {};
  	struct ib_cq *cq;
 +	size_t required_cmd_sz;
  	int ret;
  
 -	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
 +	required_cmd_sz = offsetof(typeof(cmd), reserved) +
 +				sizeof(cmd.reserved);
 +	if (ucore->inlen < required_cmd_sz)
 +		return -EINVAL;
 +
 +	/* sanity checks */
 +	if (ucore->inlen > sizeof(cmd) &&
 +	    !ib_is_udata_cleared(ucore, sizeof(cmd),
 +				 ucore->inlen - sizeof(cmd)))
 +		return -EOPNOTSUPP;
 +
 +	ret = ib_copy_from_udata(&cmd, ucore, min(sizeof(cmd), ucore->inlen));
  	if (ret)
  		return ret;
  
diff --cc drivers/infiniband/core/uverbs_main.c
index 495189811c27,96a5f89bbb75..000000000000
--- a/drivers/infiniband/core/uverbs_main.c
+++ b/drivers/infiniband/core/uverbs_main.c
@@@ -749,10 -688,89 +749,96 @@@ static ssize_t ib_uverbs_write(struct f
  		return ret;
  
  	srcu_key = srcu_read_lock(&file->device->disassociate_srcu);
++<<<<<<< HEAD
 +	ib_dev = srcu_dereference(file->device->ib_dev,
 +				  &file->device->disassociate_srcu);
 +	if (!ib_dev) {
 +		ret = -EIO;
++=======
+ 
+ 	buf += sizeof(hdr);
+ 
+ 	bundle.ufile = file;
+ 	if (!method_elm->is_ex) {
+ 		size_t in_len = hdr.in_words * 4 - sizeof(hdr);
+ 		size_t out_len = hdr.out_words * 4;
+ 		u64 response = 0;
+ 
+ 		if (method_elm->has_udata) {
+ 			bundle.driver_udata.inlen =
+ 				in_len - method_elm->req_size;
+ 			in_len = method_elm->req_size;
+ 			if (bundle.driver_udata.inlen)
+ 				bundle.driver_udata.inbuf = buf + in_len;
+ 			else
+ 				bundle.driver_udata.inbuf = NULL;
+ 		} else {
+ 			memset(&bundle.driver_udata, 0,
+ 			       sizeof(bundle.driver_udata));
+ 		}
+ 
+ 		if (method_elm->has_resp) {
+ 			/*
+ 			 * The macros check that if has_resp is set
+ 			 * then the command request structure starts
+ 			 * with a '__aligned u64 response' member.
+ 			 */
+ 			ret = get_user(response, (const u64 *)buf);
+ 			if (ret)
+ 				goto out_unlock;
+ 
+ 			if (method_elm->has_udata) {
+ 				bundle.driver_udata.outlen =
+ 					out_len - method_elm->resp_size;
+ 				out_len = method_elm->resp_size;
+ 				if (bundle.driver_udata.outlen)
+ 					bundle.driver_udata.outbuf =
+ 						u64_to_user_ptr(response +
+ 								out_len);
+ 				else
+ 					bundle.driver_udata.outbuf = NULL;
+ 			}
+ 		} else {
+ 			bundle.driver_udata.outlen = 0;
+ 			bundle.driver_udata.outbuf = NULL;
+ 		}
+ 
+ 		ib_uverbs_init_udata_buf_or_null(
+ 			&bundle.ucore, buf, u64_to_user_ptr(response),
+ 			in_len, out_len);
+ 	} else {
+ 		buf += sizeof(ex_hdr);
+ 
+ 		ib_uverbs_init_udata_buf_or_null(&bundle.ucore, buf,
+ 					u64_to_user_ptr(ex_hdr.response),
+ 					hdr.in_words * 8, hdr.out_words * 8);
+ 
+ 		ib_uverbs_init_udata_buf_or_null(
+ 			&bundle.driver_udata, buf + bundle.ucore.inlen,
+ 			u64_to_user_ptr(ex_hdr.response) + bundle.ucore.outlen,
+ 			ex_hdr.provider_in_words * 8,
+ 			ex_hdr.provider_out_words * 8);
+ 
+ 	}
+ 
+ 	ret = method_elm->handler(&bundle);
+ out_unlock:
+ 	srcu_read_unlock(&file->device->disassociate_srcu, srcu_key);
+ 	return (ret) ? : count;
+ }
+ 
+ static int ib_uverbs_mmap(struct file *filp, struct vm_area_struct *vma)
+ {
+ 	struct ib_uverbs_file *file = filp->private_data;
+ 	struct ib_ucontext *ucontext;
+ 	int ret = 0;
+ 	int srcu_key;
+ 
+ 	srcu_key = srcu_read_lock(&file->device->disassociate_srcu);
+ 	ucontext = ib_uverbs_get_ucontext_file(file);
+ 	if (IS_ERR(ucontext)) {
+ 		ret = PTR_ERR(ucontext);
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  		goto out;
  	}
  
diff --cc include/rdma/uverbs_ioctl.h
index 90a4947ff548,7f4ace93e502..000000000000
--- a/include/rdma/uverbs_ioctl.h
+++ b/include/rdma/uverbs_ioctl.h
@@@ -191,137 -339,269 +191,266 @@@ struct uverbs_object_def 
  	const struct uverbs_method_def * const (*methods)[];
  };
  
 -enum uapi_definition_kind {
 -	UAPI_DEF_END = 0,
 -	UAPI_DEF_OBJECT_START,
 -	UAPI_DEF_WRITE,
 -	UAPI_DEF_CHAIN_OBJ_TREE,
 -	UAPI_DEF_CHAIN,
 -	UAPI_DEF_IS_SUPPORTED_FUNC,
 -	UAPI_DEF_IS_SUPPORTED_DEV_FN,
 -};
 -
 -enum uapi_definition_scope {
 -	UAPI_SCOPE_OBJECT = 1,
 -	UAPI_SCOPE_METHOD = 2,
 +struct uverbs_object_tree_def {
 +	size_t					 num_objects;
 +	const struct uverbs_object_def * const (*objects)[];
  };
  
 +#define UA_FLAGS(_flags)  .flags = _flags
 +#define __UVERBS_ATTR0(_id, _type, _fld, _attr, ...)              \
 +	((const struct uverbs_attr_def)				  \
 +	 {.id = _id, .attr = {{._fld = {.type = _type, _attr, .flags = 0, } }, } })
 +#define __UVERBS_ATTR1(_id, _type, _fld, _attr, _extra1, ...)      \
 +	((const struct uverbs_attr_def)				  \
 +	 {.id = _id, .attr = {{._fld = {.type = _type, _attr, _extra1 } },} })
 +#define __UVERBS_ATTR2(_id, _type, _fld, _attr, _extra1, _extra2)    \
 +	((const struct uverbs_attr_def)				  \
 +	 {.id = _id, .attr = {{._fld = {.type = _type, _attr, _extra1, _extra2 } },} })
 +#define __UVERBS_ATTR(_id, _type, _fld, _attr, _extra1, _extra2, _n, ...)	\
 +	__UVERBS_ATTR##_n(_id, _type, _fld, _attr, _extra1, _extra2)
 +
++<<<<<<< HEAD
++=======
+ struct uapi_definition {
+ 	u8 kind;
+ 	u8 scope;
+ 	union {
+ 		struct {
+ 			u16 object_id;
+ 		} object_start;
+ 		struct {
+ 			u16 command_num;
+ 			u8 is_ex:1;
+ 			u8 has_udata:1;
+ 			u8 has_resp:1;
+ 			u8 req_size;
+ 			u8 resp_size;
+ 		} write;
+ 	};
+ 
+ 	union {
+ 		bool (*func_is_supported)(struct ib_device *device);
+ 		int (*func_write)(struct uverbs_attr_bundle *attrs);
+ 		const struct uapi_definition *chain;
+ 		const struct uverbs_object_def *chain_obj_tree;
+ 		size_t needs_fn_offset;
+ 	};
+ };
+ 
+ /* Define things connected to object_id */
+ #define DECLARE_UVERBS_OBJECT(_object_id, ...)                                 \
+ 	{                                                                      \
+ 		.kind = UAPI_DEF_OBJECT_START,                                 \
+ 		.object_start = { .object_id = _object_id },                   \
+ 	},                                                                     \
+ 		##__VA_ARGS__
+ 
+ /* Use in a var_args of DECLARE_UVERBS_OBJECT */
+ #define DECLARE_UVERBS_WRITE(_command_num, _func, _cmd_desc, ...)              \
+ 	{                                                                      \
+ 		.kind = UAPI_DEF_WRITE,                                        \
+ 		.scope = UAPI_SCOPE_OBJECT,                                    \
+ 		.write = { .is_ex = 0, .command_num = _command_num },          \
+ 		.func_write = _func,                                           \
+ 		_cmd_desc,                                                     \
+ 	},                                                                     \
+ 		##__VA_ARGS__
+ 
+ /* Use in a var_args of DECLARE_UVERBS_OBJECT */
+ #define DECLARE_UVERBS_WRITE_EX(_command_num, _func, _cmd_desc, ...)           \
+ 	{                                                                      \
+ 		.kind = UAPI_DEF_WRITE,                                        \
+ 		.scope = UAPI_SCOPE_OBJECT,                                    \
+ 		.write = { .is_ex = 1, .command_num = _command_num },          \
+ 		.func_write = _func,                                           \
+ 		_cmd_desc,                                                     \
+ 	},                                                                     \
+ 		##__VA_ARGS__
+ 
+ /*
+  * Object is only supported if the function pointer named ibdev_fn in struct
+  * ib_device is not NULL.
+  */
+ #define UAPI_DEF_OBJ_NEEDS_FN(ibdev_fn)                                        \
+ 	{                                                                      \
+ 		.kind = UAPI_DEF_IS_SUPPORTED_DEV_FN,                          \
+ 		.scope = UAPI_SCOPE_OBJECT,                                    \
+ 		.needs_fn_offset =                                             \
+ 			offsetof(struct ib_device, ibdev_fn) +                 \
+ 			BUILD_BUG_ON_ZERO(                                     \
+ 				sizeof(((struct ib_device *)0)->ibdev_fn) !=   \
+ 				sizeof(void *)),                               \
+ 	}
+ 
+ /*
+  * Method is only supported if the function pointer named ibdev_fn in struct
+  * ib_device is not NULL.
+  */
+ #define UAPI_DEF_METHOD_NEEDS_FN(ibdev_fn)                                     \
+ 	{                                                                      \
+ 		.kind = UAPI_DEF_IS_SUPPORTED_DEV_FN,                          \
+ 		.scope = UAPI_SCOPE_METHOD,                                    \
+ 		.needs_fn_offset =                                             \
+ 			offsetof(struct ib_device, ibdev_fn) +                 \
+ 			BUILD_BUG_ON_ZERO(                                     \
+ 				sizeof(((struct ib_device *)0)->ibdev_fn) !=   \
+ 				sizeof(void *)),                               \
+ 	}
+ 
+ /* Call a function to determine if the entire object is supported or not */
+ #define UAPI_DEF_IS_OBJ_SUPPORTED(_func)                                       \
+ 	{                                                                      \
+ 		.kind = UAPI_DEF_IS_SUPPORTED_FUNC,                            \
+ 		.scope = UAPI_SCOPE_OBJECT, .func_is_supported = _func,        \
+ 	}
+ 
+ /* Include another struct uapi_definition in this one */
+ #define UAPI_DEF_CHAIN(_def_var)                                               \
+ 	{                                                                      \
+ 		.kind = UAPI_DEF_CHAIN, .chain = _def_var,                     \
+ 	}
+ 
+ /* Temporary until the tree base description is replaced */
+ #define UAPI_DEF_CHAIN_OBJ_TREE(_object_enum, _object_ptr)                     \
+ 	{                                                                      \
+ 		.kind = UAPI_DEF_CHAIN_OBJ_TREE,                               \
+ 		.object_start = { .object_id = _object_enum },                 \
+ 		.chain_obj_tree = _object_ptr,                                 \
+ 	}
+ #define UAPI_DEF_CHAIN_OBJ_TREE_NAMED(_object_enum, ...)                       \
+ 	UAPI_DEF_CHAIN_OBJ_TREE(_object_enum, &UVERBS_OBJECT(_object_enum)),   \
+ 		##__VA_ARGS__
+ 
+ /*
+  * =======================================
+  *	Attribute Specifications
+  * =======================================
+  */
+ 
+ #define UVERBS_ATTR_SIZE(_min_len, _len)			\
+ 	.u.ptr.min_len = _min_len, .u.ptr.len = _len
+ 
+ #define UVERBS_ATTR_NO_DATA() UVERBS_ATTR_SIZE(0, 0)
+ 
+ /*
+  * Specifies a uapi structure that cannot be extended. The user must always
+  * supply the whole structure and nothing more. The structure must be declared
+  * in a header under include/uapi/rdma.
+  */
++>>>>>>> 974d6b4b2bc3 (RDMA/uverbs: Use only attrs for the write() handler signature)
  #define UVERBS_ATTR_TYPE(_type)					\
 -	.u.ptr.min_len = sizeof(_type), .u.ptr.len = sizeof(_type)
 -/*
 - * Specifies a uapi structure where the user must provide at least up to
 - * member 'last'.  Anything after last and up until the end of the structure
 - * can be non-zero, anything longer than the end of the structure must be
 - * zero. The structure must be declared in a header under include/uapi/rdma.
 - */
 -#define UVERBS_ATTR_STRUCT(_type, _last)                                       \
 -	.zero_trailing = 1,                                                    \
 -	UVERBS_ATTR_SIZE(((uintptr_t)(&((_type *)0)->_last + 1)),              \
 -			 sizeof(_type))
 -/*
 - * Specifies at least min_len bytes must be passed in, but the amount can be
 - * larger, up to the protocol maximum size. No check for zeroing is done.
 - */
 -#define UVERBS_ATTR_MIN_SIZE(_min_len) UVERBS_ATTR_SIZE(_min_len, USHRT_MAX)
 -
 -/* Must be used in the '...' of any UVERBS_ATTR */
 -#define UA_ALLOC_AND_COPY .alloc_and_copy = 1
 -#define UA_MANDATORY .mandatory = 1
 -#define UA_OPTIONAL .mandatory = 0
 -
 -/*
 - * min_len must be bigger than 0 and _max_len must be smaller than 4095.  Only
 - * READ\WRITE accesses are supported.
 - */
 -#define UVERBS_ATTR_IDRS_ARR(_attr_id, _idr_type, _access, _min_len, _max_len, \
 -			     ...)                                              \
 -	(&(const struct uverbs_attr_def){                                      \
 -		.id = (_attr_id) +                                             \
 -		      BUILD_BUG_ON_ZERO((_min_len) == 0 ||                     \
 -					(_max_len) >                           \
 -						PAGE_SIZE / sizeof(void *) ||  \
 -					(_min_len) > (_max_len) ||             \
 -					(_access) == UVERBS_ACCESS_NEW ||      \
 -					(_access) == UVERBS_ACCESS_DESTROY),   \
 -		.attr = { .type = UVERBS_ATTR_TYPE_IDRS_ARRAY,                 \
 -			  .u2.objs_arr.obj_type = _idr_type,                   \
 -			  .u2.objs_arr.access = _access,                       \
 -			  .u2.objs_arr.min_len = _min_len,                     \
 -			  .u2.objs_arr.max_len = _max_len,                     \
 -			  __VA_ARGS__ } })
 -
 -#define UVERBS_ATTR_IDR(_attr_id, _idr_type, _access, ...)                     \
 -	(&(const struct uverbs_attr_def){                                      \
 -		.id = _attr_id,                                                \
 -		.attr = { .type = UVERBS_ATTR_TYPE_IDR,                        \
 -			  .u.obj.obj_type = _idr_type,                         \
 -			  .u.obj.access = _access,                             \
 -			  __VA_ARGS__ } })
 -
 -#define UVERBS_ATTR_FD(_attr_id, _fd_type, _access, ...)                       \
 -	(&(const struct uverbs_attr_def){                                      \
 -		.id = (_attr_id) +                                             \
 -		      BUILD_BUG_ON_ZERO((_access) != UVERBS_ACCESS_NEW &&      \
 -					(_access) != UVERBS_ACCESS_READ),      \
 -		.attr = { .type = UVERBS_ATTR_TYPE_FD,                         \
 -			  .u.obj.obj_type = _fd_type,                          \
 -			  .u.obj.access = _access,                             \
 -			  __VA_ARGS__ } })
 -
 -#define UVERBS_ATTR_PTR_IN(_attr_id, _type, ...)                               \
 -	(&(const struct uverbs_attr_def){                                      \
 -		.id = _attr_id,                                                \
 -		.attr = { .type = UVERBS_ATTR_TYPE_PTR_IN,                     \
 -			  _type,                                               \
 -			  __VA_ARGS__ } })
 -
 -#define UVERBS_ATTR_PTR_OUT(_attr_id, _type, ...)                              \
 -	(&(const struct uverbs_attr_def){                                      \
 -		.id = _attr_id,                                                \
 -		.attr = { .type = UVERBS_ATTR_TYPE_PTR_OUT,                    \
 -			  _type,                                               \
 -			  __VA_ARGS__ } })
 -
 -/* _enum_arry should be a 'static const union uverbs_attr_spec[]' */
 -#define UVERBS_ATTR_ENUM_IN(_attr_id, _enum_arr, ...)                          \
 -	(&(const struct uverbs_attr_def){                                      \
 -		.id = _attr_id,                                                \
 -		.attr = { .type = UVERBS_ATTR_TYPE_ENUM_IN,                    \
 -			  .u2.enum_def.ids = _enum_arr,                        \
 -			  .u.enum_def.num_elems = ARRAY_SIZE(_enum_arr),       \
 -			  __VA_ARGS__ },                                       \
 -	})
 -
 -/* An input value that is a member in the enum _enum_type. */
 -#define UVERBS_ATTR_CONST_IN(_attr_id, _enum_type, ...)                        \
 -	UVERBS_ATTR_PTR_IN(                                                    \
 -		_attr_id,                                                      \
 -		UVERBS_ATTR_SIZE(                                              \
 -			sizeof(u64) + BUILD_BUG_ON_ZERO(!sizeof(_enum_type)),  \
 -			sizeof(u64)),                                          \
 -		__VA_ARGS__)
 +	.min_len = sizeof(_type), .len = sizeof(_type)
 +#define UVERBS_ATTR_STRUCT(_type, _last)			\
 +	.min_len = ((uintptr_t)(&((_type *)0)->_last + 1)), .len = sizeof(_type)
 +#define UVERBS_ATTR_SIZE(_min_len, _len)			\
 +	.min_len = _min_len, .len = _len
 +#define UVERBS_ATTR_MIN_SIZE(_min_len)				\
 +	UVERBS_ATTR_SIZE(_min_len, USHRT_MAX)
  
  /*
 - * An input value that is a bitwise combination of values of _enum_type.
 - * This permits the flag value to be passed as either a u32 or u64, it must
 - * be retrieved via uverbs_get_flag().
 + * In new compiler, UVERBS_ATTR could be simplified by declaring it as
 + * [_id] = {.type = _type, .len = _len, ##__VA_ARGS__}
 + * But since we support older compilers too, we need the more complex code.
   */
 -#define UVERBS_ATTR_FLAGS_IN(_attr_id, _enum_type, ...)                        \
 -	UVERBS_ATTR_PTR_IN(                                                    \
 -		_attr_id,                                                      \
 -		UVERBS_ATTR_SIZE(sizeof(u32) + BUILD_BUG_ON_ZERO(              \
 -						       !sizeof(_enum_type *)), \
 -				 sizeof(u64)),                                 \
 -		__VA_ARGS__)
 +#define UVERBS_ATTR(_id, _type, _fld, _attr, ...)			\
 +	__UVERBS_ATTR(_id, _type, _fld, _attr, ##__VA_ARGS__, 2, 1, 0)
 +#define UVERBS_ATTR_PTR_IN_SZ(_id, _len, ...)				\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_PTR_IN, ptr, _len, ##__VA_ARGS__)
 +/* If sizeof(_type) <= sizeof(u64), this will be inlined rather than a pointer */
 +#define UVERBS_ATTR_PTR_IN(_id, _type, ...)				\
 +	UVERBS_ATTR_PTR_IN_SZ(_id, _type, ##__VA_ARGS__)
 +#define UVERBS_ATTR_PTR_OUT_SZ(_id, _len, ...)				\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_PTR_OUT, ptr, _len, ##__VA_ARGS__)
 +#define UVERBS_ATTR_PTR_OUT(_id, _type, ...)				\
 +	UVERBS_ATTR_PTR_OUT_SZ(_id, _type, ##__VA_ARGS__)
 +#define UVERBS_ATTR_ENUM_IN(_id, _enum_arr, ...)			\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_ENUM_IN, enum_def,		\
 +		    .ids = (_enum_arr),					\
 +		    .num_elems = ARRAY_SIZE(_enum_arr), ##__VA_ARGS__)
  
  /*
 - * This spec is used in order to pass information to the hardware driver in a
 - * legacy way. Every verb that could get driver specific data should get this
 - * spec.
 + * In new compiler, UVERBS_ATTR_IDR (and FD) could be simplified by declaring
 + * it as
 + * {.id = _id,								\
 + *  .attr {.type = __obj_class,						\
 + *         .obj = {.obj_type = _idr_type,				\
 + *                       .access = _access                              \
 + *                }, ##__VA_ARGS__ } }
 + * But since we support older compilers too, we need the more complex code.
   */
 -#define UVERBS_ATTR_UHW()                                                      \
 -	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_UHW_IN,                                 \
 -			   UVERBS_ATTR_MIN_SIZE(0),			       \
 -			   UA_OPTIONAL,                                        \
 -			   .is_udata = 1),				       \
 -	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_UHW_OUT,                               \
 -			    UVERBS_ATTR_MIN_SIZE(0),			       \
 -			    UA_OPTIONAL,                                       \
 -			    .is_udata = 1)
 +#define ___UVERBS_ATTR_OBJ0(_id, _obj_class, _obj_type, _access, ...)\
 +	((const struct uverbs_attr_def)					\
 +	{.id = _id,							\
 +	 .attr = { {.obj = {.type = _obj_class, .obj_type = _obj_type,	\
 +			    .access = _access, .flags = 0 } }, } })
 +#define ___UVERBS_ATTR_OBJ1(_id, _obj_class, _obj_type, _access, _flags)\
 +	((const struct uverbs_attr_def)					\
 +	{.id = _id,							\
 +	.attr = { {.obj = {.type = _obj_class, .obj_type = _obj_type,	\
 +			   .access = _access, _flags} }, } })
 +#define ___UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access, _flags, \
 +			   _n, ...)					\
 +	___UVERBS_ATTR_OBJ##_n(_id, _obj_class, _obj_type, _access, _flags)
 +#define __UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access, ...)	\
 +	___UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access,		\
 +			   ##__VA_ARGS__, 1, 0)
 +#define UVERBS_ATTR_IDR(_id, _idr_type, _access, ...)			 \
 +	__UVERBS_ATTR_OBJ(_id, UVERBS_ATTR_TYPE_IDR, _idr_type, _access,\
 +			  ##__VA_ARGS__)
 +#define UVERBS_ATTR_FD(_id, _fd_type, _access, ...)			\
 +	__UVERBS_ATTR_OBJ(_id, UVERBS_ATTR_TYPE_FD, _fd_type,		\
 +			  (_access) + BUILD_BUG_ON_ZERO(		\
 +				(_access) != UVERBS_ACCESS_NEW &&	\
 +				(_access) != UVERBS_ACCESS_READ),	\
 +			  ##__VA_ARGS__)
 +#define DECLARE_UVERBS_ATTR_SPEC(_name, ...)				\
 +	const struct uverbs_attr_def _name = __VA_ARGS__
 +
 +#define DECLARE_UVERBS_ENUM(_name, ...)					\
 +	const struct uverbs_enum_spec _name = {				\
 +		.len = ARRAY_SIZE(((struct uverbs_attr_spec[]){__VA_ARGS__})),\
 +		.ids = {__VA_ARGS__},					\
 +	}
 +#define _UVERBS_METHOD_ATTRS_SZ(...)					\
 +	(sizeof((const struct uverbs_attr_def * const []){__VA_ARGS__}) /\
 +	 sizeof(const struct uverbs_attr_def *))
 +#define _UVERBS_METHOD(_id, _handler, _flags, ...)			\
 +	((const struct uverbs_method_def) {				\
 +	 .id = _id,							\
 +	 .flags = _flags,						\
 +	 .handler = _handler,						\
 +	 .num_attrs = _UVERBS_METHOD_ATTRS_SZ(__VA_ARGS__),		\
 +	 .attrs = &(const struct uverbs_attr_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_METHOD(_name, _id, _handler, ...)		\
 +	const struct uverbs_method_def _name =				\
 +		_UVERBS_METHOD(_id, _handler, 0, ##__VA_ARGS__)
 +#define DECLARE_UVERBS_CTX_METHOD(_name, _id, _handler, _flags, ...)	\
 +	const struct uverbs_method_def _name =				\
 +		_UVERBS_METHOD(_id, _handler,				\
 +			       UVERBS_ACTION_FLAG_CREATE_ROOT,		\
 +			       ##__VA_ARGS__)
 +#define _UVERBS_OBJECT_METHODS_SZ(...)					\
 +	(sizeof((const struct uverbs_method_def * const []){__VA_ARGS__}) / \
 +	 sizeof(const struct uverbs_method_def *))
 +#define _UVERBS_OBJECT(_id, _type_attrs, ...)				\
 +	((const struct uverbs_object_def) {				\
 +	 .id = _id,							\
 +	 .type_attrs = _type_attrs,					\
 +	 .num_methods = _UVERBS_OBJECT_METHODS_SZ(__VA_ARGS__),		\
 +	 .methods = &(const struct uverbs_method_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_OBJECT(_name, _id, _type_attrs, ...)		\
 +	const struct uverbs_object_def _name =				\
 +		_UVERBS_OBJECT(_id, _type_attrs, ##__VA_ARGS__)
 +#define _UVERBS_TREE_OBJECTS_SZ(...)					\
 +	(sizeof((const struct uverbs_object_def * const []){__VA_ARGS__}) / \
 +	 sizeof(const struct uverbs_object_def *))
 +#define _UVERBS_OBJECT_TREE(...)					\
 +	((const struct uverbs_object_tree_def) {			\
 +	 .num_objects = _UVERBS_TREE_OBJECTS_SZ(__VA_ARGS__),		\
 +	 .objects = &(const struct uverbs_object_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_OBJECT_TREE(_name, ...)				\
 +	const struct uverbs_object_tree_def _name =			\
 +		_UVERBS_OBJECT_TREE(__VA_ARGS__)
  
  /* =================================================
   *              Parsing infrastructure
* Unmerged path drivers/infiniband/core/uverbs_uapi.c
* Unmerged path drivers/infiniband/core/rdma_core.h
* Unmerged path drivers/infiniband/core/uverbs_cmd.c
* Unmerged path drivers/infiniband/core/uverbs_main.c
* Unmerged path drivers/infiniband/core/uverbs_uapi.c
* Unmerged path include/rdma/uverbs_ioctl.h
