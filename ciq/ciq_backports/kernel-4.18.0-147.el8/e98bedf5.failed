net/mlx5e: Add extack messages for TC offload failures

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Eli Britstein <elibr@mellanox.com>
commit e98bedf5e61beb8ea4707e97ff9ef14d9deeb0c9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/e98bedf5.failed

Return tc extack messages for failures to user space.
Messages provide reasons for not being able to offload rules to HW.

	Signed-off-by: Eli Britstein <elibr@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit e98bedf5e61beb8ea4707e97ff9ef14d9deeb0c9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index b9f5104c3e10,eeb2b215f5a4..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -2506,8 -2614,10 +2569,10 @@@ vxlan_encap_offload_err
  
  	if (mlx5_vxlan_lookup_port(priv->mdev->vxlan, be16_to_cpu(key->tp_dst)) &&
  	    MLX5_CAP_ESW(priv->mdev, vxlan_encap_decap)) {
 -		tunnel_type = MLX5_HEADER_TYPE_VXLAN;
 +		tunnel_type = MLX5_REFORMAT_TYPE_L2_TO_VXLAN;
  	} else {
+ 		NL_SET_ERR_MSG_MOD(extack,
+ 				   "port isn't an offloaded vxlan udp dport");
  		netdev_warn(priv->netdev,
  			    "%d isn't an offloaded vxlan udp dport\n", be16_to_cpu(key->tp_dst));
  		return -EOPNOTSUPP;
@@@ -2560,9 -2670,60 +2625,10 @@@ out_err
  	return err;
  }
  
 -static int parse_tc_vlan_action(struct mlx5e_priv *priv,
 -				const struct tc_action *a,
 -				struct mlx5_esw_flow_attr *attr,
 -				u32 *action)
 -{
 -	u8 vlan_idx = attr->total_vlan;
 -
 -	if (vlan_idx >= MLX5_FS_VLAN_DEPTH)
 -		return -EOPNOTSUPP;
 -
 -	if (tcf_vlan_action(a) == TCA_VLAN_ACT_POP) {
 -		if (vlan_idx) {
 -			if (!mlx5_eswitch_vlan_actions_supported(priv->mdev,
 -								 MLX5_FS_VLAN_DEPTH))
 -				return -EOPNOTSUPP;
 -
 -			*action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_POP_2;
 -		} else {
 -			*action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_POP;
 -		}
 -	} else if (tcf_vlan_action(a) == TCA_VLAN_ACT_PUSH) {
 -		attr->vlan_vid[vlan_idx] = tcf_vlan_push_vid(a);
 -		attr->vlan_prio[vlan_idx] = tcf_vlan_push_prio(a);
 -		attr->vlan_proto[vlan_idx] = tcf_vlan_push_proto(a);
 -		if (!attr->vlan_proto[vlan_idx])
 -			attr->vlan_proto[vlan_idx] = htons(ETH_P_8021Q);
 -
 -		if (vlan_idx) {
 -			if (!mlx5_eswitch_vlan_actions_supported(priv->mdev,
 -								 MLX5_FS_VLAN_DEPTH))
 -				return -EOPNOTSUPP;
 -
 -			*action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH_2;
 -		} else {
 -			if (!mlx5_eswitch_vlan_actions_supported(priv->mdev, 1) &&
 -			    (tcf_vlan_push_proto(a) != htons(ETH_P_8021Q) ||
 -			     tcf_vlan_push_prio(a)))
 -				return -EOPNOTSUPP;
 -
 -			*action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH;
 -		}
 -	} else { /* action is TCA_VLAN_ACT_MODIFY */
 -		return -EOPNOTSUPP;
 -	}
 -
 -	attr->total_vlan = vlan_idx + 1;
 -
 -	return 0;
 -}
 -
  static int parse_tc_fdb_actions(struct mlx5e_priv *priv, struct tcf_exts *exts,
  				struct mlx5e_tc_flow_parse_attr *parse_attr,
- 				struct mlx5e_tc_flow *flow)
+ 				struct mlx5e_tc_flow *flow,
+ 				struct netlink_ext_ack *extack)
  {
  	struct mlx5_esw_flow_attr *attr = flow->esw_attr;
  	struct mlx5e_rep_priv *rpriv = priv->ppriv;
@@@ -2587,10 -2748,8 +2653,10 @@@
  		}
  
  		if (is_tcf_pedit(a)) {
 +			int err;
 +
  			err = parse_tc_pedit_action(priv, a, MLX5_FLOW_NAMESPACE_FDB,
- 						    parse_attr);
+ 						    parse_attr, extack);
  			if (err)
  				return err;
  
@@@ -2685,10 -2837,12 +2756,16 @@@
  	}
  
  	attr->action = action;
- 	if (!actions_match_supported(priv, exts, parse_attr, flow))
+ 	if (!actions_match_supported(priv, exts, parse_attr, flow, extack))
  		return -EOPNOTSUPP;
  
++<<<<<<< HEAD
 +	if (attr->mirror_count > 0 && !mlx5_esw_has_fwd_fdb(priv->mdev)) {
++=======
+ 	if (attr->out_count > 1 && !mlx5_esw_has_fwd_fdb(priv->mdev)) {
+ 		NL_SET_ERR_MSG_MOD(extack,
+ 				   "current firmware doesn't support split rule for port mirroring");
++>>>>>>> e98bedf5e61b (net/mlx5e: Add extack messages for TC offload failures)
  		netdev_warn_once(priv->netdev, "current firmware doesn't support split rule for port mirroring\n");
  		return -EOPNOTSUPP;
  	}
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
