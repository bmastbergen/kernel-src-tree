arm64: KVM: export the capability to set guest SError syndrome

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Dongjiu Geng <gengdongjiu@huawei.com>
commit be26b3a73413c2ebf14d5e76a66ad964e6458080
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/be26b3a7.failed

For the arm64 RAS Extension, user space can inject a virtual-SError
with specified ESR. So user space needs to know whether KVM support
to inject such SError, this interface adds this query for this capability.

KVM will check whether system support RAS Extension, if supported, KVM
returns true to user space, otherwise returns false.

	Signed-off-by: Dongjiu Geng <gengdongjiu@huawei.com>
	Reviewed-by: James Morse <james.morse@arm.com>
[expanded documentation wording]
	Signed-off-by: James Morse <james.morse@arm.com>
	Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
(cherry picked from commit be26b3a73413c2ebf14d5e76a66ad964e6458080)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/kvm.h
diff --cc include/uapi/linux/kvm.h
index a76a9addaa2b,a7d9bc4e4068..000000000000
--- a/include/uapi/linux/kvm.h
+++ b/include/uapi/linux/kvm.h
@@@ -959,12 -949,7 +959,16 @@@ struct kvm_ppc_resize_hpt 
  #define KVM_CAP_GET_MSR_FEATURES 153
  #define KVM_CAP_HYPERV_EVENTFD 154
  #define KVM_CAP_HYPERV_TLBFLUSH 155
++<<<<<<< HEAD
 +#define KVM_CAP_S390_HPAGE_1M 156
 +#define KVM_CAP_NESTED_STATE 157
 +#define KVM_CAP_ARM_INJECT_SERROR_ESR 158
 +#define KVM_CAP_MSR_PLATFORM_INFO 159
 +#define KVM_CAP_PPC_NESTED_HV 160
 +#define KVM_CAP_ARM_VM_IPA_SIZE 165
++=======
+ #define KVM_CAP_ARM_INJECT_SERROR_ESR 156
++>>>>>>> be26b3a73413 (arm64: KVM: export the capability to set guest SError syndrome)
  
  #ifdef KVM_CAP_IRQ_ROUTING
  
diff --git a/Documentation/virtual/kvm/api.txt b/Documentation/virtual/kvm/api.txt
index 6a9ffc956cf5..36994a221e2f 100644
--- a/Documentation/virtual/kvm/api.txt
+++ b/Documentation/virtual/kvm/api.txt
@@ -938,6 +938,18 @@ SError is pending, the architecture's 'Multiple SError interrupts' rules should
 be followed. (2.5.3 of DDI0587.a "ARM Reliability, Availability, and
 Serviceability (RAS) Specification").
 
+SError exceptions always have an ESR value. Some CPUs have the ability to
+specify what the virtual SError's ESR value should be. These systems will
+advertise KVM_CAP_ARM_SET_SERROR_ESR. In this case exception.has_esr will
+always have a non-zero value when read, and the agent making an SError pending
+should specify the ISS field in the lower 24 bits of exception.serror_esr. If
+the system supports KVM_CAP_ARM_SET_SERROR_ESR, but user-space sets the events
+with exception.has_esr as zero, KVM will choose an ESR.
+
+Specifying exception.has_esr on a system that does not support it will return
+-EINVAL. Setting anything other than the lower 24bits of exception.serror_esr
+will return -EINVAL.
+
 struct kvm_vcpu_events {
 	struct {
 		__u8 serror_pending;
@@ -4796,3 +4808,17 @@ This capability indicates that KVM supports paravirtualized Hyper-V TLB Flush
 hypercalls:
 HvFlushVirtualAddressSpace, HvFlushVirtualAddressSpaceEx,
 HvFlushVirtualAddressList, HvFlushVirtualAddressListEx.
+
+8.19 KVM_CAP_ARM_SET_SERROR_ESR
+
+Architectures: arm, arm64
+
+This capability indicates that userspace can specify (via the
+KVM_SET_VCPU_EVENTS ioctl) the syndrome value reported to the guest when it
+takes a virtual SError interrupt exception.
+If KVM advertises this capability, userspace can only specify the ISS field for
+the ESR syndrome. Other parts of the ESR, such as the EC are generated by the
+CPU when the exception is taken. If this virtual SError is taken to EL1 using
+AArch64, this value will be reported in the ISS field of ESR_ELx.
+
+See KVM_CAP_VCPU_EVENTS for more details.
diff --git a/arch/arm64/kvm/reset.c b/arch/arm64/kvm/reset.c
index 20de62ef6cc6..082218acbc49 100644
--- a/arch/arm64/kvm/reset.c
+++ b/arch/arm64/kvm/reset.c
@@ -81,6 +81,9 @@ int kvm_arch_dev_ioctl_check_extension(struct kvm *kvm, long ext)
 	case KVM_CAP_ARM_PMU_V3:
 		r = kvm_arm_support_pmu_v3();
 		break;
+	case KVM_CAP_ARM_INJECT_SERROR_ESR:
+		r = cpus_have_const_cap(ARM64_HAS_RAS_EXTN);
+		break;
 	case KVM_CAP_SET_GUEST_DEBUG:
 	case KVM_CAP_VCPU_ATTRIBUTES:
 	case KVM_CAP_VCPU_EVENTS:
* Unmerged path include/uapi/linux/kvm.h
