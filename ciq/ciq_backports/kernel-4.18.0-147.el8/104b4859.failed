s390/qeth: be drop monitor friendly

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit 104b48592b5441c722dcd95c38ab9300f2d94856
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/104b4859.failed

As part of the TX completion path, qeth_release_skbs() frees the completed
skbs with __skb_queue_purge(). This ends in kfree_skb(), reporting every
completed skb as dropped.
On the other hand when dropping an skb in .ndo_start_xmit, we end up
calling consume_skb()... where we should be using kfree_skb() so that
drop monitors get notified.

Switch the drop/consume logic around, and also don't accumulate dropped
packets in the tx_errors statistics.

Fixes: dc149e3764d8 ("s390/qeth: replace open-coded skb_queue_walk()")
	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 104b48592b5441c722dcd95c38ab9300f2d94856)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_l2_main.c
#	drivers/s390/net/qeth_l3_main.c
diff --cc drivers/s390/net/qeth_l2_main.c
index 6befe93240a9,c3067fd3bd9e..000000000000
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@@ -728,10 -628,8 +728,15 @@@ static netdev_tx_t qeth_l2_hard_start_x
  		return NETDEV_TX_BUSY;
  	} /* else fall through */
  
++<<<<<<< HEAD
 +tx_drop:
 +	card->stats.tx_dropped++;
 +	card->stats.tx_errors++;
 +	dev_kfree_skb_any(skb);
++=======
+ 	QETH_TXQ_STAT_INC(queue, tx_dropped);
+ 	kfree_skb(skb);
++>>>>>>> 104b48592b54 (s390/qeth: be drop monitor friendly)
  	netif_wake_queue(dev);
  	return NETDEV_TX_OK;
  }
diff --cc drivers/s390/net/qeth_l3_main.c
index a1a6237d4aae,53712cf26406..000000000000
--- a/drivers/s390/net/qeth_l3_main.c
+++ b/drivers/s390/net/qeth_l3_main.c
@@@ -2222,9 -2095,8 +2222,14 @@@ static netdev_tx_t qeth_l3_hard_start_x
  	} /* else fall through */
  
  tx_drop:
++<<<<<<< HEAD
 +	card->stats.tx_dropped++;
 +	card->stats.tx_errors++;
 +	dev_kfree_skb_any(skb);
++=======
+ 	QETH_TXQ_STAT_INC(queue, tx_dropped);
+ 	kfree_skb(skb);
++>>>>>>> 104b48592b54 (s390/qeth: be drop monitor friendly)
  	netif_wake_queue(dev);
  	return NETDEV_TX_OK;
  }
diff --git a/drivers/s390/net/qeth_core_main.c b/drivers/s390/net/qeth_core_main.c
index 454bf33bdb64..2e1667a632bc 100644
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@ -1168,13 +1168,16 @@ static void qeth_notify_skbs(struct qeth_qdio_out_q *q,
 
 static void qeth_release_skbs(struct qeth_qdio_out_buffer *buf)
 {
+	struct sk_buff *skb;
+
 	/* release may never happen from within CQ tasklet scope */
 	WARN_ON_ONCE(atomic_read(&buf->state) == QETH_QDIO_BUF_IN_CQ);
 
 	if (atomic_read(&buf->state) == QETH_QDIO_BUF_PENDING)
 		qeth_notify_skbs(buf->q, buf, TX_NOTIFY_GENERALERROR);
 
-	__skb_queue_purge(&buf->skb_list);
+	while ((skb = __skb_dequeue(&buf->skb_list)) != NULL)
+		consume_skb(skb);
 }
 
 static void qeth_clear_output_buffer(struct qeth_qdio_out_q *queue,
* Unmerged path drivers/s390/net/qeth_l2_main.c
* Unmerged path drivers/s390/net/qeth_l3_main.c
