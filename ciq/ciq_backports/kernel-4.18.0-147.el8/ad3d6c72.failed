xarray: Add XArray load operation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Matthew Wilcox <willy@infradead.org>
commit ad3d6c7263e368abdc151e1cc13dc78aa39cc7a7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/ad3d6c72.failed

The xa_load function brings with it a lot of infrastructure; xa_empty(),
xa_is_err(), and large chunks of the XArray advanced API that are used
to implement xa_load.

As the test-suite demonstrates, it is possible to use the XArray functions
on a radix tree.  The radix tree functions depend on the GFP flags being
stored in the root of the tree, so it's not possible to use the radix
tree functions on an XArray.

	Signed-off-by: Matthew Wilcox <willy@infradead.org>
(cherry picked from commit ad3d6c7263e368abdc151e1cc13dc78aa39cc7a7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/xarray.h
#	lib/radix-tree.c
#	lib/xarray.c
#	tools/testing/radix-tree/Makefile
#	tools/testing/radix-tree/xarray.c
diff --cc include/linux/xarray.h
index 2dfc8006fe64,a0df8217068c..000000000000
--- a/include/linux/xarray.h
+++ b/include/linux/xarray.h
@@@ -4,10 -4,279 +4,281 @@@
  /*
   * eXtensible Arrays
   * Copyright (c) 2017 Microsoft Corporation
 - * Author: Matthew Wilcox <willy@infradead.org>
 - *
 - * See Documentation/core-api/xarray.rst for how to use the XArray.
 + * Author: Matthew Wilcox <mawilcox@microsoft.com>
   */
  
++<<<<<<< HEAD
 +#include <linux/spinlock.h>
++=======
+ #include <linux/bug.h>
+ #include <linux/compiler.h>
+ #include <linux/kconfig.h>
+ #include <linux/kernel.h>
+ #include <linux/rcupdate.h>
+ #include <linux/spinlock.h>
+ #include <linux/types.h>
+ 
+ /*
+  * The bottom two bits of the entry determine how the XArray interprets
+  * the contents:
+  *
+  * 00: Pointer entry
+  * 10: Internal entry
+  * x1: Value entry or tagged pointer
+  *
+  * Attempting to store internal entries in the XArray is a bug.
+  *
+  * Most internal entries are pointers to the next node in the tree.
+  * The following internal entries have a special meaning:
+  *
+  * 0-62: Sibling entries
+  * 256: Retry entry
+  *
+  * Errors are also represented as internal entries, but use the negative
+  * space (-4094 to -2).  They're never stored in the slots array; only
+  * returned by the normal API.
+  */
+ 
+ #define BITS_PER_XA_VALUE	(BITS_PER_LONG - 1)
+ 
+ /**
+  * xa_mk_value() - Create an XArray entry from an integer.
+  * @v: Value to store in XArray.
+  *
+  * Context: Any context.
+  * Return: An entry suitable for storing in the XArray.
+  */
+ static inline void *xa_mk_value(unsigned long v)
+ {
+ 	WARN_ON((long)v < 0);
+ 	return (void *)((v << 1) | 1);
+ }
+ 
+ /**
+  * xa_to_value() - Get value stored in an XArray entry.
+  * @entry: XArray entry.
+  *
+  * Context: Any context.
+  * Return: The value stored in the XArray entry.
+  */
+ static inline unsigned long xa_to_value(const void *entry)
+ {
+ 	return (unsigned long)entry >> 1;
+ }
+ 
+ /**
+  * xa_is_value() - Determine if an entry is a value.
+  * @entry: XArray entry.
+  *
+  * Context: Any context.
+  * Return: True if the entry is a value, false if it is a pointer.
+  */
+ static inline bool xa_is_value(const void *entry)
+ {
+ 	return (unsigned long)entry & 1;
+ }
+ 
+ /**
+  * xa_tag_pointer() - Create an XArray entry for a tagged pointer.
+  * @p: Plain pointer.
+  * @tag: Tag value (0, 1 or 3).
+  *
+  * If the user of the XArray prefers, they can tag their pointers instead
+  * of storing value entries.  Three tags are available (0, 1 and 3).
+  * These are distinct from the xa_mark_t as they are not replicated up
+  * through the array and cannot be searched for.
+  *
+  * Context: Any context.
+  * Return: An XArray entry.
+  */
+ static inline void *xa_tag_pointer(void *p, unsigned long tag)
+ {
+ 	return (void *)((unsigned long)p | tag);
+ }
+ 
+ /**
+  * xa_untag_pointer() - Turn an XArray entry into a plain pointer.
+  * @entry: XArray entry.
+  *
+  * If you have stored a tagged pointer in the XArray, call this function
+  * to get the untagged version of the pointer.
+  *
+  * Context: Any context.
+  * Return: A pointer.
+  */
+ static inline void *xa_untag_pointer(void *entry)
+ {
+ 	return (void *)((unsigned long)entry & ~3UL);
+ }
+ 
+ /**
+  * xa_pointer_tag() - Get the tag stored in an XArray entry.
+  * @entry: XArray entry.
+  *
+  * If you have stored a tagged pointer in the XArray, call this function
+  * to get the tag of that pointer.
+  *
+  * Context: Any context.
+  * Return: A tag.
+  */
+ static inline unsigned int xa_pointer_tag(void *entry)
+ {
+ 	return (unsigned long)entry & 3UL;
+ }
+ 
+ /*
+  * xa_mk_internal() - Create an internal entry.
+  * @v: Value to turn into an internal entry.
+  *
+  * Context: Any context.
+  * Return: An XArray internal entry corresponding to this value.
+  */
+ static inline void *xa_mk_internal(unsigned long v)
+ {
+ 	return (void *)((v << 2) | 2);
+ }
+ 
+ /*
+  * xa_to_internal() - Extract the value from an internal entry.
+  * @entry: XArray entry.
+  *
+  * Context: Any context.
+  * Return: The value which was stored in the internal entry.
+  */
+ static inline unsigned long xa_to_internal(const void *entry)
+ {
+ 	return (unsigned long)entry >> 2;
+ }
+ 
+ /*
+  * xa_is_internal() - Is the entry an internal entry?
+  * @entry: XArray entry.
+  *
+  * Context: Any context.
+  * Return: %true if the entry is an internal entry.
+  */
+ static inline bool xa_is_internal(const void *entry)
+ {
+ 	return ((unsigned long)entry & 3) == 2;
+ }
+ 
+ /**
+  * xa_is_err() - Report whether an XArray operation returned an error
+  * @entry: Result from calling an XArray function
+  *
+  * If an XArray operation cannot complete an operation, it will return
+  * a special value indicating an error.  This function tells you
+  * whether an error occurred; xa_err() tells you which error occurred.
+  *
+  * Context: Any context.
+  * Return: %true if the entry indicates an error.
+  */
+ static inline bool xa_is_err(const void *entry)
+ {
+ 	return unlikely(xa_is_internal(entry));
+ }
+ 
+ /**
+  * xa_err() - Turn an XArray result into an errno.
+  * @entry: Result from calling an XArray function.
+  *
+  * If an XArray operation cannot complete an operation, it will return
+  * a special pointer value which encodes an errno.  This function extracts
+  * the errno from the pointer value, or returns 0 if the pointer does not
+  * represent an errno.
+  *
+  * Context: Any context.
+  * Return: A negative errno or 0.
+  */
+ static inline int xa_err(void *entry)
+ {
+ 	/* xa_to_internal() would not do sign extension. */
+ 	if (xa_is_err(entry))
+ 		return (long)entry >> 2;
+ 	return 0;
+ }
+ 
+ /**
+  * struct xarray - The anchor of the XArray.
+  * @xa_lock: Lock that protects the contents of the XArray.
+  *
+  * To use the xarray, define it statically or embed it in your data structure.
+  * It is a very small data structure, so it does not usually make sense to
+  * allocate it separately and keep a pointer to it in your data structure.
+  *
+  * You may use the xa_lock to protect your own data structures as well.
+  */
+ /*
+  * If all of the entries in the array are NULL, @xa_head is a NULL pointer.
+  * If the only non-NULL entry in the array is at index 0, @xa_head is that
+  * entry.  If any other entry in the array is non-NULL, @xa_head points
+  * to an @xa_node.
+  */
+ struct xarray {
+ 	spinlock_t	xa_lock;
+ /* private: The rest of the data structure is not to be used directly. */
+ 	gfp_t		xa_flags;
+ 	void __rcu *	xa_head;
+ };
+ 
+ #define XARRAY_INIT(name, flags) {				\
+ 	.xa_lock = __SPIN_LOCK_UNLOCKED(name.xa_lock),		\
+ 	.xa_flags = flags,					\
+ 	.xa_head = NULL,					\
+ }
+ 
+ /**
+  * DEFINE_XARRAY_FLAGS() - Define an XArray with custom flags.
+  * @name: A string that names your XArray.
+  * @flags: XA_FLAG values.
+  *
+  * This is intended for file scope definitions of XArrays.  It declares
+  * and initialises an empty XArray with the chosen name and flags.  It is
+  * equivalent to calling xa_init_flags() on the array, but it does the
+  * initialisation at compiletime instead of runtime.
+  */
+ #define DEFINE_XARRAY_FLAGS(name, flags)				\
+ 	struct xarray name = XARRAY_INIT(name, flags)
+ 
+ /**
+  * DEFINE_XARRAY() - Define an XArray.
+  * @name: A string that names your XArray.
+  *
+  * This is intended for file scope definitions of XArrays.  It declares
+  * and initialises an empty XArray with the chosen name.  It is equivalent
+  * to calling xa_init() on the array, but it does the initialisation at
+  * compiletime instead of runtime.
+  */
+ #define DEFINE_XARRAY(name) DEFINE_XARRAY_FLAGS(name, 0)
+ 
+ void xa_init_flags(struct xarray *, gfp_t flags);
+ void *xa_load(struct xarray *, unsigned long index);
+ 
+ /**
+  * xa_init() - Initialise an empty XArray.
+  * @xa: XArray.
+  *
+  * An empty XArray is full of NULL entries.
+  *
+  * Context: Any context.
+  */
+ static inline void xa_init(struct xarray *xa)
+ {
+ 	xa_init_flags(xa, 0);
+ }
++>>>>>>> ad3d6c7263e3 (xarray: Add XArray load operation)
+ 
+ /**
+  * xa_empty() - Determine if an array has any present entries.
+  * @xa: XArray.
+  *
+  * Context: Any context.
+  * Return: %true if the array contains only NULL pointers.
+  */
+ static inline bool xa_empty(const struct xarray *xa)
+ {
+ 	return xa->xa_head == NULL;
+ }
  
  #define xa_trylock(xa)		spin_trylock(&(xa)->xa_lock)
  #define xa_lock(xa)		spin_lock(&(xa)->xa_lock)
@@@ -21,4 -290,362 +292,365 @@@
  #define xa_unlock_irqrestore(xa, flags) \
  				spin_unlock_irqrestore(&(xa)->xa_lock, flags)
  
++<<<<<<< HEAD
++=======
+ /* Everything below here is the Advanced API.  Proceed with caution. */
+ 
+ /*
+  * The xarray is constructed out of a set of 'chunks' of pointers.  Choosing
+  * the best chunk size requires some tradeoffs.  A power of two recommends
+  * itself so that we can walk the tree based purely on shifts and masks.
+  * Generally, the larger the better; as the number of slots per level of the
+  * tree increases, the less tall the tree needs to be.  But that needs to be
+  * balanced against the memory consumption of each node.  On a 64-bit system,
+  * xa_node is currently 576 bytes, and we get 7 of them per 4kB page.  If we
+  * doubled the number of slots per node, we'd get only 3 nodes per 4kB page.
+  */
+ #ifndef XA_CHUNK_SHIFT
+ #define XA_CHUNK_SHIFT		(CONFIG_BASE_SMALL ? 4 : 6)
+ #endif
+ #define XA_CHUNK_SIZE		(1UL << XA_CHUNK_SHIFT)
+ #define XA_CHUNK_MASK		(XA_CHUNK_SIZE - 1)
+ #define XA_MAX_MARKS		3
+ #define XA_MARK_LONGS		DIV_ROUND_UP(XA_CHUNK_SIZE, BITS_PER_LONG)
+ 
+ /*
+  * @count is the count of every non-NULL element in the ->slots array
+  * whether that is a value entry, a retry entry, a user pointer,
+  * a sibling entry or a pointer to the next level of the tree.
+  * @nr_values is the count of every element in ->slots which is
+  * either a value entry or a sibling of a value entry.
+  */
+ struct xa_node {
+ 	unsigned char	shift;		/* Bits remaining in each slot */
+ 	unsigned char	offset;		/* Slot offset in parent */
+ 	unsigned char	count;		/* Total entry count */
+ 	unsigned char	nr_values;	/* Value entry count */
+ 	struct xa_node __rcu *parent;	/* NULL at top of tree */
+ 	struct xarray	*array;		/* The array we belong to */
+ 	union {
+ 		struct list_head private_list;	/* For tree user */
+ 		struct rcu_head	rcu_head;	/* Used when freeing node */
+ 	};
+ 	void __rcu	*slots[XA_CHUNK_SIZE];
+ 	union {
+ 		unsigned long	tags[XA_MAX_MARKS][XA_MARK_LONGS];
+ 		unsigned long	marks[XA_MAX_MARKS][XA_MARK_LONGS];
+ 	};
+ };
+ 
+ void xa_dump(const struct xarray *);
+ void xa_dump_node(const struct xa_node *);
+ 
+ #ifdef XA_DEBUG
+ #define XA_BUG_ON(xa, x) do {					\
+ 		if (x) {					\
+ 			xa_dump(xa);				\
+ 			BUG();					\
+ 		}						\
+ 	} while (0)
+ #define XA_NODE_BUG_ON(node, x) do {				\
+ 		if (x) {					\
+ 			if (node) xa_dump_node(node);		\
+ 			BUG();					\
+ 		}						\
+ 	} while (0)
+ #else
+ #define XA_BUG_ON(xa, x)	do { } while (0)
+ #define XA_NODE_BUG_ON(node, x)	do { } while (0)
+ #endif
+ 
+ /* Private */
+ static inline void *xa_head(const struct xarray *xa)
+ {
+ 	return rcu_dereference_check(xa->xa_head,
+ 						lockdep_is_held(&xa->xa_lock));
+ }
+ 
+ /* Private */
+ static inline void *xa_head_locked(const struct xarray *xa)
+ {
+ 	return rcu_dereference_protected(xa->xa_head,
+ 						lockdep_is_held(&xa->xa_lock));
+ }
+ 
+ /* Private */
+ static inline void *xa_entry(const struct xarray *xa,
+ 				const struct xa_node *node, unsigned int offset)
+ {
+ 	XA_NODE_BUG_ON(node, offset >= XA_CHUNK_SIZE);
+ 	return rcu_dereference_check(node->slots[offset],
+ 						lockdep_is_held(&xa->xa_lock));
+ }
+ 
+ /* Private */
+ static inline void *xa_entry_locked(const struct xarray *xa,
+ 				const struct xa_node *node, unsigned int offset)
+ {
+ 	XA_NODE_BUG_ON(node, offset >= XA_CHUNK_SIZE);
+ 	return rcu_dereference_protected(node->slots[offset],
+ 						lockdep_is_held(&xa->xa_lock));
+ }
+ 
+ /* Private */
+ static inline struct xa_node *xa_to_node(const void *entry)
+ {
+ 	return (struct xa_node *)((unsigned long)entry - 2);
+ }
+ 
+ /* Private */
+ static inline bool xa_is_node(const void *entry)
+ {
+ 	return xa_is_internal(entry) && (unsigned long)entry > 4096;
+ }
+ 
+ /* Private */
+ static inline void *xa_mk_sibling(unsigned int offset)
+ {
+ 	return xa_mk_internal(offset);
+ }
+ 
+ /* Private */
+ static inline unsigned long xa_to_sibling(const void *entry)
+ {
+ 	return xa_to_internal(entry);
+ }
+ 
+ /**
+  * xa_is_sibling() - Is the entry a sibling entry?
+  * @entry: Entry retrieved from the XArray
+  *
+  * Return: %true if the entry is a sibling entry.
+  */
+ static inline bool xa_is_sibling(const void *entry)
+ {
+ 	return IS_ENABLED(CONFIG_XARRAY_MULTI) && xa_is_internal(entry) &&
+ 		(entry < xa_mk_sibling(XA_CHUNK_SIZE - 1));
+ }
+ 
+ #define XA_RETRY_ENTRY		xa_mk_internal(256)
+ 
+ /**
+  * xa_is_retry() - Is the entry a retry entry?
+  * @entry: Entry retrieved from the XArray
+  *
+  * Return: %true if the entry is a retry entry.
+  */
+ static inline bool xa_is_retry(const void *entry)
+ {
+ 	return unlikely(entry == XA_RETRY_ENTRY);
+ }
+ 
+ /**
+  * typedef xa_update_node_t - A callback function from the XArray.
+  * @node: The node which is being processed
+  *
+  * This function is called every time the XArray updates the count of
+  * present and value entries in a node.  It allows advanced users to
+  * maintain the private_list in the node.
+  *
+  * Context: The xa_lock is held and interrupts may be disabled.
+  *	    Implementations should not drop the xa_lock, nor re-enable
+  *	    interrupts.
+  */
+ typedef void (*xa_update_node_t)(struct xa_node *node);
+ 
+ /*
+  * The xa_state is opaque to its users.  It contains various different pieces
+  * of state involved in the current operation on the XArray.  It should be
+  * declared on the stack and passed between the various internal routines.
+  * The various elements in it should not be accessed directly, but only
+  * through the provided accessor functions.  The below documentation is for
+  * the benefit of those working on the code, not for users of the XArray.
+  *
+  * @xa_node usually points to the xa_node containing the slot we're operating
+  * on (and @xa_offset is the offset in the slots array).  If there is a
+  * single entry in the array at index 0, there are no allocated xa_nodes to
+  * point to, and so we store %NULL in @xa_node.  @xa_node is set to
+  * the value %XAS_RESTART if the xa_state is not walked to the correct
+  * position in the tree of nodes for this operation.  If an error occurs
+  * during an operation, it is set to an %XAS_ERROR value.  If we run off the
+  * end of the allocated nodes, it is set to %XAS_BOUNDS.
+  */
+ struct xa_state {
+ 	struct xarray *xa;
+ 	unsigned long xa_index;
+ 	unsigned char xa_shift;
+ 	unsigned char xa_sibs;
+ 	unsigned char xa_offset;
+ 	unsigned char xa_pad;		/* Helps gcc generate better code */
+ 	struct xa_node *xa_node;
+ 	struct xa_node *xa_alloc;
+ 	xa_update_node_t xa_update;
+ };
+ 
+ /*
+  * We encode errnos in the xas->xa_node.  If an error has happened, we need to
+  * drop the lock to fix it, and once we've done so the xa_state is invalid.
+  */
+ #define XA_ERROR(errno) ((struct xa_node *)(((unsigned long)errno << 2) | 2UL))
+ #define XAS_BOUNDS	((struct xa_node *)1UL)
+ #define XAS_RESTART	((struct xa_node *)3UL)
+ 
+ #define __XA_STATE(array, index, shift, sibs)  {	\
+ 	.xa = array,					\
+ 	.xa_index = index,				\
+ 	.xa_shift = shift,				\
+ 	.xa_sibs = sibs,				\
+ 	.xa_offset = 0,					\
+ 	.xa_pad = 0,					\
+ 	.xa_node = XAS_RESTART,				\
+ 	.xa_alloc = NULL,				\
+ 	.xa_update = NULL				\
+ }
+ 
+ /**
+  * XA_STATE() - Declare an XArray operation state.
+  * @name: Name of this operation state (usually xas).
+  * @array: Array to operate on.
+  * @index: Initial index of interest.
+  *
+  * Declare and initialise an xa_state on the stack.
+  */
+ #define XA_STATE(name, array, index)				\
+ 	struct xa_state name = __XA_STATE(array, index, 0, 0)
+ 
+ /**
+  * XA_STATE_ORDER() - Declare an XArray operation state.
+  * @name: Name of this operation state (usually xas).
+  * @array: Array to operate on.
+  * @index: Initial index of interest.
+  * @order: Order of entry.
+  *
+  * Declare and initialise an xa_state on the stack.  This variant of
+  * XA_STATE() allows you to specify the 'order' of the element you
+  * want to operate on.`
+  */
+ #define XA_STATE_ORDER(name, array, index, order)		\
+ 	struct xa_state name = __XA_STATE(array,		\
+ 			(index >> order) << order,		\
+ 			order - (order % XA_CHUNK_SHIFT),	\
+ 			(1U << (order % XA_CHUNK_SHIFT)) - 1)
+ 
+ #define xas_marked(xas, mark)	xa_marked((xas)->xa, (mark))
+ #define xas_trylock(xas)	xa_trylock((xas)->xa)
+ #define xas_lock(xas)		xa_lock((xas)->xa)
+ #define xas_unlock(xas)		xa_unlock((xas)->xa)
+ #define xas_lock_bh(xas)	xa_lock_bh((xas)->xa)
+ #define xas_unlock_bh(xas)	xa_unlock_bh((xas)->xa)
+ #define xas_lock_irq(xas)	xa_lock_irq((xas)->xa)
+ #define xas_unlock_irq(xas)	xa_unlock_irq((xas)->xa)
+ #define xas_lock_irqsave(xas, flags) \
+ 				xa_lock_irqsave((xas)->xa, flags)
+ #define xas_unlock_irqrestore(xas, flags) \
+ 				xa_unlock_irqrestore((xas)->xa, flags)
+ 
+ /**
+  * xas_error() - Return an errno stored in the xa_state.
+  * @xas: XArray operation state.
+  *
+  * Return: 0 if no error has been noted.  A negative errno if one has.
+  */
+ static inline int xas_error(const struct xa_state *xas)
+ {
+ 	return xa_err(xas->xa_node);
+ }
+ 
+ /**
+  * xas_set_err() - Note an error in the xa_state.
+  * @xas: XArray operation state.
+  * @err: Negative error number.
+  *
+  * Only call this function with a negative @err; zero or positive errors
+  * will probably not behave the way you think they should.  If you want
+  * to clear the error from an xa_state, use xas_reset().
+  */
+ static inline void xas_set_err(struct xa_state *xas, long err)
+ {
+ 	xas->xa_node = XA_ERROR(err);
+ }
+ 
+ /**
+  * xas_invalid() - Is the xas in a retry or error state?
+  * @xas: XArray operation state.
+  *
+  * Return: %true if the xas cannot be used for operations.
+  */
+ static inline bool xas_invalid(const struct xa_state *xas)
+ {
+ 	return (unsigned long)xas->xa_node & 3;
+ }
+ 
+ /**
+  * xas_valid() - Is the xas a valid cursor into the array?
+  * @xas: XArray operation state.
+  *
+  * Return: %true if the xas can be used for operations.
+  */
+ static inline bool xas_valid(const struct xa_state *xas)
+ {
+ 	return !xas_invalid(xas);
+ }
+ 
+ /**
+  * xas_reset() - Reset an XArray operation state.
+  * @xas: XArray operation state.
+  *
+  * Resets the error or walk state of the @xas so future walks of the
+  * array will start from the root.  Use this if you have dropped the
+  * xarray lock and want to reuse the xa_state.
+  *
+  * Context: Any context.
+  */
+ static inline void xas_reset(struct xa_state *xas)
+ {
+ 	xas->xa_node = XAS_RESTART;
+ }
+ 
+ /**
+  * xas_retry() - Retry the operation if appropriate.
+  * @xas: XArray operation state.
+  * @entry: Entry from xarray.
+  *
+  * The advanced functions may sometimes return an internal entry, such as
+  * a retry entry or a zero entry.  This function sets up the @xas to restart
+  * the walk from the head of the array if needed.
+  *
+  * Context: Any context.
+  * Return: true if the operation needs to be retried.
+  */
+ static inline bool xas_retry(struct xa_state *xas, const void *entry)
+ {
+ 	if (!xa_is_retry(entry))
+ 		return false;
+ 	xas_reset(xas);
+ 	return true;
+ }
+ 
+ void *xas_load(struct xa_state *);
+ 
+ /**
+  * xas_reload() - Refetch an entry from the xarray.
+  * @xas: XArray operation state.
+  *
+  * Use this function to check that a previously loaded entry still has
+  * the same value.  This is useful for the lockless pagecache lookup where
+  * we walk the array with only the RCU lock to protect us, lock the page,
+  * then check that the page hasn't moved since we looked it up.
+  *
+  * The caller guarantees that @xas is still valid.  If it may be in an
+  * error or restart state, call xas_load() instead.
+  *
+  * Return: The entry at this location in the xarray.
+  */
+ static inline void *xas_reload(struct xa_state *xas)
+ {
+ 	struct xa_node *node = xas->xa_node;
+ 
+ 	if (node)
+ 		return xa_entry(xas->xa, node, xas->xa_offset);
+ 	return xa_head(xas->xa);
+ }
+ 
++>>>>>>> ad3d6c7263e3 (xarray: Add XArray load operation)
  #endif /* _LINUX_XARRAY_H */
diff --cc lib/radix-tree.c
index a904a8ddd174,b8e961428484..000000000000
--- a/lib/radix-tree.c
+++ b/lib/radix-tree.c
@@@ -278,49 -256,6 +278,52 @@@ static unsigned long next_index(unsigne
  }
  
  #ifndef __KERNEL__
++<<<<<<< HEAD
 +static void dump_node(struct radix_tree_node *node, unsigned long index)
 +{
 +	unsigned long i;
 +
 +	pr_debug("radix node: %p offset %d indices %lu-%lu parent %p tags %lx %lx %lx shift %d count %d exceptional %d\n",
 +		node, node->offset, index, index | node_maxindex(node),
 +		node->parent,
 +		node->tags[0][0], node->tags[1][0], node->tags[2][0],
 +		node->shift, node->count, node->exceptional);
 +
 +	for (i = 0; i < RADIX_TREE_MAP_SIZE; i++) {
 +		unsigned long first = index | (i << node->shift);
 +		unsigned long last = first | ((1UL << node->shift) - 1);
 +		void *entry = node->slots[i];
 +		if (!entry)
 +			continue;
 +		if (entry == RADIX_TREE_RETRY) {
 +			pr_debug("radix retry offset %ld indices %lu-%lu parent %p\n",
 +					i, first, last, node);
 +		} else if (!radix_tree_is_internal_node(entry)) {
 +			pr_debug("radix entry %p offset %ld indices %lu-%lu parent %p\n",
 +					entry, i, first, last, node);
 +		} else if (is_sibling_entry(node, entry)) {
 +			pr_debug("radix sblng %p offset %ld indices %lu-%lu parent %p val %p\n",
 +					entry, i, first, last, node,
 +					*(void **)entry_to_node(entry));
 +		} else {
 +			dump_node(entry_to_node(entry), first);
 +		}
 +	}
 +}
 +
 +/* For debug */
 +static void radix_tree_dump(struct radix_tree_root *root)
 +{
 +	pr_debug("radix root: %p rnode %p tags %x\n",
 +			root, root->rnode,
 +			root->gfp_mask >> ROOT_TAG_SHIFT);
 +	if (!radix_tree_is_internal_node(root->rnode))
 +		return;
 +	dump_node(entry_to_node(root->rnode), 0);
 +}
 +
++=======
++>>>>>>> ad3d6c7263e3 (xarray: Add XArray load operation)
  static void dump_ida_node(void *entry, unsigned long index)
  {
  	unsigned long i;
diff --cc tools/testing/radix-tree/Makefile
index 37baecc3766f,1379f1d78d0b..000000000000
--- a/tools/testing/radix-tree/Makefile
+++ b/tools/testing/radix-tree/Makefile
@@@ -4,8 -4,8 +4,13 @@@ CFLAGS += -I. -I../../include -g -Og -W
  	  -fsanitize=undefined
  LDFLAGS += -fsanitize=address -fsanitize=undefined
  LDLIBS+= -lpthread -lurcu
++<<<<<<< HEAD
 +TARGETS = main idr-test multiorder
 +CORE_OFILES := radix-tree.o idr.o linux.o test.o find_bit.o
++=======
+ TARGETS = main idr-test multiorder xarray
+ CORE_OFILES := xarray.o radix-tree.o idr.o linux.o test.o find_bit.o
++>>>>>>> ad3d6c7263e3 (xarray: Add XArray load operation)
  OFILES = main.o $(CORE_OFILES) regression1.o regression2.o regression3.o \
  	 tag_check.o multiorder.o idr-test.o iteration_check.o benchmark.o
  
@@@ -44,8 -47,10 +51,13 @@@ radix-tree.c: ../../../lib/radix-tree.
  idr.c: ../../../lib/idr.c
  	sed -e 's/^static //' -e 's/__always_inline //' -e 's/inline //' < $< > $@
  
++<<<<<<< HEAD
++=======
+ xarray.o: ../../../lib/xarray.c ../../../lib/test_xarray.c
+ 
++>>>>>>> ad3d6c7263e3 (xarray: Add XArray load operation)
  generated/map-shift.h:
  	@if ! grep -qws $(SHIFT) generated/map-shift.h; then		\
 -		echo "#define XA_CHUNK_SHIFT $(SHIFT)" >		\
 +		echo "#define RADIX_TREE_MAP_SHIFT $(SHIFT)" >		\
  				generated/map-shift.h;			\
  	fi
* Unmerged path lib/xarray.c
* Unmerged path tools/testing/radix-tree/xarray.c
* Unmerged path include/linux/xarray.h
diff --git a/lib/Kconfig.debug b/lib/Kconfig.debug
index 2fff661d9070..343f870835b4 100644
--- a/lib/Kconfig.debug
+++ b/lib/Kconfig.debug
@@ -1805,6 +1805,9 @@ config TEST_BITMAP
 config TEST_UUID
 	tristate "Test functions located in the uuid module at runtime"
 
+config TEST_XARRAY
+	tristate "Test the XArray code at runtime"
+
 config TEST_OVERFLOW
 	tristate "Test check_*_overflow() functions at runtime"
 
diff --git a/lib/Makefile b/lib/Makefile
index cbc4517d9693..43ed117b700c 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -67,6 +67,7 @@ obj-$(CONFIG_TEST_STATIC_KEYS) += test_static_key_base.o
 obj-$(CONFIG_TEST_PRINTF) += test_printf.o
 obj-$(CONFIG_TEST_BITMAP) += test_bitmap.o
 obj-$(CONFIG_TEST_UUID) += test_uuid.o
+obj-$(CONFIG_TEST_XARRAY) += test_xarray.o
 obj-$(CONFIG_TEST_PARMAN) += test_parman.o
 obj-$(CONFIG_TEST_KMOD) += test_kmod.o
 obj-$(CONFIG_TEST_DEBUG_VIRTUAL) += test_debug_virtual.o
* Unmerged path lib/radix-tree.c
diff --git a/lib/test_xarray.c b/lib/test_xarray.c
new file mode 100644
index 000000000000..a7248b87617f
--- /dev/null
+++ b/lib/test_xarray.c
@@ -0,0 +1,87 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * test_xarray.c: Test the XArray API
+ * Copyright (c) 2017-2018 Microsoft Corporation
+ * Author: Matthew Wilcox <willy@infradead.org>
+ */
+
+#include <linux/xarray.h>
+#include <linux/module.h>
+
+static unsigned int tests_run;
+static unsigned int tests_passed;
+
+#ifndef XA_DEBUG
+# ifdef __KERNEL__
+void xa_dump(const struct xarray *xa) { }
+# endif
+#undef XA_BUG_ON
+#define XA_BUG_ON(xa, x) do {					\
+	tests_run++;						\
+	if (x) {						\
+		printk("BUG at %s:%d\n", __func__, __LINE__);	\
+		xa_dump(xa);					\
+		dump_stack();					\
+	} else {						\
+		tests_passed++;					\
+	}							\
+} while (0)
+#endif
+
+static void *xa_store_index(struct xarray *xa, unsigned long index, gfp_t gfp)
+{
+	radix_tree_insert(xa, index, xa_mk_value(index));
+	return NULL;
+}
+
+static void xa_erase_index(struct xarray *xa, unsigned long index)
+{
+	radix_tree_delete(xa, index);
+}
+
+static noinline void check_xa_load(struct xarray *xa)
+{
+	unsigned long i, j;
+
+	for (i = 0; i < 1024; i++) {
+		for (j = 0; j < 1024; j++) {
+			void *entry = xa_load(xa, j);
+			if (j < i)
+				XA_BUG_ON(xa, xa_to_value(entry) != j);
+			else
+				XA_BUG_ON(xa, entry);
+		}
+		XA_BUG_ON(xa, xa_store_index(xa, i, GFP_KERNEL) != NULL);
+	}
+
+	for (i = 0; i < 1024; i++) {
+		for (j = 0; j < 1024; j++) {
+			void *entry = xa_load(xa, j);
+			if (j >= i)
+				XA_BUG_ON(xa, xa_to_value(entry) != j);
+			else
+				XA_BUG_ON(xa, entry);
+		}
+		xa_erase_index(xa, i);
+	}
+	XA_BUG_ON(xa, !xa_empty(xa));
+}
+
+static RADIX_TREE(array, GFP_KERNEL);
+
+static int xarray_checks(void)
+{
+	check_xa_load(&array);
+
+	printk("XArray: %u of %u tests passed\n", tests_passed, tests_run);
+	return (tests_run == tests_passed) ? 0 : -EINVAL;
+}
+
+static void xarray_exit(void)
+{
+}
+
+module_init(xarray_checks);
+module_exit(xarray_exit);
+MODULE_AUTHOR("Matthew Wilcox <willy@infradead.org>");
+MODULE_LICENSE("GPL");
* Unmerged path lib/xarray.c
diff --git a/tools/include/linux/kernel.h b/tools/include/linux/kernel.h
index 0ad884452c5c..6935ef94e77a 100644
--- a/tools/include/linux/kernel.h
+++ b/tools/include/linux/kernel.h
@@ -70,6 +70,7 @@
 #define BUG_ON(cond) assert(!(cond))
 #endif
 #endif
+#define BUG()	BUG_ON(1)
 
 #if __BYTE_ORDER == __BIG_ENDIAN
 #define cpu_to_le16 bswap_16
diff --git a/tools/testing/radix-tree/.gitignore b/tools/testing/radix-tree/.gitignore
index d4706c0ffceb..3834899b6693 100644
--- a/tools/testing/radix-tree/.gitignore
+++ b/tools/testing/radix-tree/.gitignore
@@ -4,3 +4,4 @@ idr-test
 main
 multiorder
 radix-tree.c
+xarray
* Unmerged path tools/testing/radix-tree/Makefile
diff --git a/tools/testing/radix-tree/linux/kernel.h b/tools/testing/radix-tree/linux/kernel.h
index 426f32f28547..5d06ac75a14d 100644
--- a/tools/testing/radix-tree/linux/kernel.h
+++ b/tools/testing/radix-tree/linux/kernel.h
@@ -14,6 +14,7 @@
 #include "../../../include/linux/kconfig.h"
 
 #define printk printf
+#define pr_info printk
 #define pr_debug printk
 #define pr_cont printk
 
diff --git a/tools/testing/radix-tree/linux/rcupdate.h b/tools/testing/radix-tree/linux/rcupdate.h
index 73ed33658203..fd280b070fdb 100644
--- a/tools/testing/radix-tree/linux/rcupdate.h
+++ b/tools/testing/radix-tree/linux/rcupdate.h
@@ -6,5 +6,7 @@
 
 #define rcu_dereference_raw(p) rcu_dereference(p)
 #define rcu_dereference_protected(p, cond) rcu_dereference(p)
+#define rcu_dereference_check(p, cond) rcu_dereference(p)
+#define RCU_INIT_POINTER(p, v)	(p) = (v)
 
 #endif
diff --git a/tools/testing/radix-tree/main.c b/tools/testing/radix-tree/main.c
index b741686e53d6..09deaf4f0959 100644
--- a/tools/testing/radix-tree/main.c
+++ b/tools/testing/radix-tree/main.c
@@ -365,6 +365,7 @@ int main(int argc, char **argv)
 	rcu_register_thread();
 	radix_tree_init();
 
+	xarray_tests();
 	regression1_test();
 	regression2_test();
 	regression3_test();
diff --git a/tools/testing/radix-tree/test.h b/tools/testing/radix-tree/test.h
index 92d901eacf49..e3dc7a16f09b 100644
--- a/tools/testing/radix-tree/test.h
+++ b/tools/testing/radix-tree/test.h
@@ -34,6 +34,7 @@ int tag_tagged_items(struct radix_tree_root *, pthread_mutex_t *,
 			unsigned iftag, unsigned thentag);
 unsigned long find_item(struct radix_tree_root *, void *item);
 
+void xarray_tests(void);
 void tag_check(void);
 void multiorder_checks(void);
 void iteration_test(unsigned order, unsigned duration);
* Unmerged path tools/testing/radix-tree/xarray.c
