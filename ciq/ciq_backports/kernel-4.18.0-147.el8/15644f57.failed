RDMA/i40iw: Initialize ib_device_ops struct

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Kamal Heib <kamalheib1@gmail.com>
commit 15644f57cb6659349bc1ca7419fa89a28fbcfe61
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/15644f57.failed

Initialize ib_device_ops with the supported operations using
ib_set_device_ops().

	Signed-off-by: Kamal Heib <kamalheib1@gmail.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 15644f57cb6659349bc1ca7419fa89a28fbcfe61)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/i40iw/i40iw_verbs.c
diff --cc drivers/infiniband/hw/i40iw/i40iw_verbs.c
index 7d85414742ff,9e42ac2db3ca..000000000000
--- a/drivers/infiniband/hw/i40iw/i40iw_verbs.c
+++ b/drivers/infiniband/hw/i40iw/i40iw_verbs.c
@@@ -2734,47 -2721,39 +2734,80 @@@ static int i40iw_query_pkey(struct ib_d
  	return 0;
  }
  
+ static const struct ib_device_ops i40iw_dev_ops = {
+ 	.alloc_hw_stats = i40iw_alloc_hw_stats,
+ 	.alloc_mr = i40iw_alloc_mr,
+ 	.alloc_pd = i40iw_alloc_pd,
+ 	.alloc_ucontext = i40iw_alloc_ucontext,
+ 	.create_cq = i40iw_create_cq,
+ 	.create_qp = i40iw_create_qp,
+ 	.dealloc_pd = i40iw_dealloc_pd,
+ 	.dealloc_ucontext = i40iw_dealloc_ucontext,
+ 	.dereg_mr = i40iw_dereg_mr,
+ 	.destroy_cq = i40iw_destroy_cq,
+ 	.destroy_qp = i40iw_destroy_qp,
+ 	.drain_rq = i40iw_drain_rq,
+ 	.drain_sq = i40iw_drain_sq,
+ 	.get_dev_fw_str = i40iw_get_dev_fw_str,
+ 	.get_dma_mr = i40iw_get_dma_mr,
+ 	.get_hw_stats = i40iw_get_hw_stats,
+ 	.get_port_immutable = i40iw_port_immutable,
+ 	.map_mr_sg = i40iw_map_mr_sg,
+ 	.mmap = i40iw_mmap,
+ 	.modify_qp = i40iw_modify_qp,
+ 	.poll_cq = i40iw_poll_cq,
+ 	.post_recv = i40iw_post_recv,
+ 	.post_send = i40iw_post_send,
+ 	.query_device = i40iw_query_device,
+ 	.query_gid = i40iw_query_gid,
+ 	.query_pkey = i40iw_query_pkey,
+ 	.query_port = i40iw_query_port,
+ 	.query_qp = i40iw_query_qp,
+ 	.reg_user_mr = i40iw_reg_user_mr,
+ 	.req_notify_cq = i40iw_req_notify_cq,
+ };
+ 
 +/**
 + * i40iw_create_ah - create address handle
 + * @ibpd: ptr of pd
 + * @ah_attr: address handle attributes
 + */
 +static struct ib_ah *i40iw_create_ah(struct ib_pd *ibpd,
 +				     struct rdma_ah_attr *attr,
 +				     struct ib_udata *udata)
 +
 +{
 +	return ERR_PTR(-ENOSYS);
 +}
 +
 +/**
 + * i40iw_destroy_ah - Destroy address handle
 + * @ah: pointer to address handle
 + */
 +static int i40iw_destroy_ah(struct ib_ah *ah)
 +{
 +	return -ENOSYS;
 +}
 +
 +/**
 + * i40iw_get_vector_affinity - report IRQ affinity mask
 + * @ibdev: IB device
 + * @comp_vector: completion vector index
 + */
 +static const struct cpumask *i40iw_get_vector_affinity(struct ib_device *ibdev,
 +						       int comp_vector)
 +{
 +	struct i40iw_device *iwdev = to_iwdev(ibdev);
 +	struct i40iw_msix_vector *msix_vec;
 +
 +	if (iwdev->msix_shared)
 +		msix_vec = &iwdev->iw_msixtbl[comp_vector];
 +	else
 +		msix_vec = &iwdev->iw_msixtbl[comp_vector + 1];
 +
 +	return irq_get_affinity_mask(msix_vec->irq);
 +}
 +
  /**
   * i40iw_init_rdma_device - initialization of iwarp device
   * @iwdev: iwarp device
@@@ -2822,33 -2800,6 +2855,36 @@@ static struct i40iw_ib_device *i40iw_in
  	iwibdev->ibdev.phys_port_cnt = 1;
  	iwibdev->ibdev.num_comp_vectors = iwdev->ceqs_count;
  	iwibdev->ibdev.dev.parent = &pcidev->dev;
++<<<<<<< HEAD
 +	iwibdev->ibdev.query_port = i40iw_query_port;
 +	iwibdev->ibdev.modify_port = i40iw_modify_port;
 +	iwibdev->ibdev.query_pkey = i40iw_query_pkey;
 +	iwibdev->ibdev.query_gid = i40iw_query_gid;
 +	iwibdev->ibdev.alloc_ucontext = i40iw_alloc_ucontext;
 +	iwibdev->ibdev.dealloc_ucontext = i40iw_dealloc_ucontext;
 +	iwibdev->ibdev.mmap = i40iw_mmap;
 +	iwibdev->ibdev.alloc_pd = i40iw_alloc_pd;
 +	iwibdev->ibdev.dealloc_pd = i40iw_dealloc_pd;
 +	iwibdev->ibdev.create_qp = i40iw_create_qp;
 +	iwibdev->ibdev.modify_qp = i40iw_modify_qp;
 +	iwibdev->ibdev.query_qp = i40iw_query_qp;
 +	iwibdev->ibdev.destroy_qp = i40iw_destroy_qp;
 +	iwibdev->ibdev.create_cq = i40iw_create_cq;
 +	iwibdev->ibdev.destroy_cq = i40iw_destroy_cq;
 +	iwibdev->ibdev.get_dma_mr = i40iw_get_dma_mr;
 +	iwibdev->ibdev.reg_user_mr = i40iw_reg_user_mr;
 +	iwibdev->ibdev.dereg_mr = i40iw_dereg_mr;
 +	iwibdev->ibdev.alloc_hw_stats = i40iw_alloc_hw_stats;
 +	iwibdev->ibdev.get_hw_stats = i40iw_get_hw_stats;
 +	iwibdev->ibdev.query_device = i40iw_query_device;
 +	iwibdev->ibdev.create_ah = i40iw_create_ah;
 +	iwibdev->ibdev.destroy_ah = i40iw_destroy_ah;
 +	iwibdev->ibdev.drain_sq = i40iw_drain_sq;
 +	iwibdev->ibdev.drain_rq = i40iw_drain_rq;
 +	iwibdev->ibdev.alloc_mr = i40iw_alloc_mr;
 +	iwibdev->ibdev.map_mr_sg = i40iw_map_mr_sg;
++=======
++>>>>>>> 15644f57cb66 (RDMA/i40iw: Initialize ib_device_ops struct)
  	iwibdev->ibdev.iwcm = kzalloc(sizeof(*iwibdev->ibdev.iwcm), GFP_KERNEL);
  	if (!iwibdev->ibdev.iwcm) {
  		ib_dealloc_device(&iwibdev->ibdev);
@@@ -2865,13 -2816,6 +2901,16 @@@
  	iwibdev->ibdev.iwcm->destroy_listen = i40iw_destroy_listen;
  	memcpy(iwibdev->ibdev.iwcm->ifname, netdev->name,
  	       sizeof(iwibdev->ibdev.iwcm->ifname));
++<<<<<<< HEAD
 +	iwibdev->ibdev.get_port_immutable   = i40iw_port_immutable;
 +	iwibdev->ibdev.get_dev_fw_str       = i40iw_get_dev_fw_str;
 +	iwibdev->ibdev.poll_cq = i40iw_poll_cq;
 +	iwibdev->ibdev.req_notify_cq = i40iw_req_notify_cq;
 +	iwibdev->ibdev.post_send = i40iw_post_send;
 +	iwibdev->ibdev.post_recv = i40iw_post_recv;
 +	iwibdev->ibdev.get_vector_affinity = i40iw_get_vector_affinity;
++=======
++>>>>>>> 15644f57cb66 (RDMA/i40iw: Initialize ib_device_ops struct)
  
  	return iwibdev;
  }
* Unmerged path drivers/infiniband/hw/i40iw/i40iw_verbs.c
