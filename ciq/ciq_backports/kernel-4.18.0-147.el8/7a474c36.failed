xfrm: policy: increment xfrm_hash_generation on hash rebuild

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Florian Westphal <fw@strlen.de>
commit 7a474c36586f4277f930ab7e6865c97e44dfc3bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/7a474c36.failed

Hash rebuild will re-set all the inexact entries, then re-insert them.
Lookups that can occur in parallel will therefore not find any policies.

This was safe when lookups were still guarded by rwlock.
After rcu-ification, lookups check the hash_generation seqcount to detect
when a hash resize takes place.  Hash rebuild missed the needed increment.

Hash resizes and hash rebuilds cannot occur in parallel (both acquire
hash_resize_mutex), so just increment xfrm_hash_generation, like resize.

Fixes: a7c44247f704e3 ("xfrm: policy: make xfrm_policy_lookup_bytype lockless")
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit 7a474c36586f4277f930ab7e6865c97e44dfc3bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/xfrm/xfrm_policy.c
diff --cc net/xfrm/xfrm_policy.c
index f38329efbfdb,d8fba27a4bfb..000000000000
--- a/net/xfrm/xfrm_policy.c
+++ b/net/xfrm/xfrm_policy.c
@@@ -593,8 -1235,52 +593,9 @@@ static void xfrm_hash_rebuild(struct wo
  	} while (read_seqretry(&net->xfrm.policy_hthresh.lock, seq));
  
  	spin_lock_bh(&net->xfrm.xfrm_policy_lock);
+ 	write_seqcount_begin(&xfrm_policy_hash_generation);
  
 -	/* make sure that we can insert the indirect policies again before
 -	 * we start with destructive action.
 -	 */
 -	list_for_each_entry(policy, &net->xfrm.policy_all, walk.all) {
 -		struct xfrm_pol_inexact_bin *bin;
 -		u8 dbits, sbits;
 -
 -		dir = xfrm_policy_id2dir(policy->index);
 -		if (policy->walk.dead || dir >= XFRM_POLICY_MAX)
 -			continue;
 -
 -		if ((dir & XFRM_POLICY_MASK) == XFRM_POLICY_OUT) {
 -			if (policy->family == AF_INET) {
 -				dbits = rbits4;
 -				sbits = lbits4;
 -			} else {
 -				dbits = rbits6;
 -				sbits = lbits6;
 -			}
 -		} else {
 -			if (policy->family == AF_INET) {
 -				dbits = lbits4;
 -				sbits = rbits4;
 -			} else {
 -				dbits = lbits6;
 -				sbits = rbits6;
 -			}
 -		}
 -
 -		if (policy->selector.prefixlen_d < dbits ||
 -		    policy->selector.prefixlen_s < sbits)
 -			continue;
 -
 -		bin = xfrm_policy_inexact_alloc_bin(policy, dir);
 -		if (!bin)
 -			goto out_unlock;
 -
 -		if (!xfrm_policy_inexact_alloc_chain(bin, policy, dir))
 -			goto out_unlock;
 -	}
 -
  	/* reset the bydst and inexact table in all directions */
 -	xfrm_hash_reset_inexact_table(net);
 -
  	for (dir = 0; dir < XFRM_POLICY_MAX; dir++) {
  		INIT_HLIST_HEAD(&net->xfrm.policy_inexact[dir]);
  		hmask = net->xfrm.policy_bydst[dir].hmask;
@@@ -639,6 -1333,9 +640,12 @@@
  			hlist_add_head_rcu(&policy->bydst, chain);
  	}
  
++<<<<<<< HEAD
++=======
+ out_unlock:
+ 	__xfrm_policy_inexact_flush(net);
+ 	write_seqcount_end(&xfrm_policy_hash_generation);
++>>>>>>> 7a474c36586f (xfrm: policy: increment xfrm_hash_generation on hash rebuild)
  	spin_unlock_bh(&net->xfrm.xfrm_policy_lock);
  
  	mutex_unlock(&hash_resize_mutex);
* Unmerged path net/xfrm/xfrm_policy.c
