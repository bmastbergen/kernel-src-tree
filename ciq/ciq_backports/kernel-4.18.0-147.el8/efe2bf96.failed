drm/virtio: set seqno for dma-fence

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Chia-I Wu <olvaffe@gmail.com>
commit efe2bf965522bf0796d413b47a2abbf81d471d6f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/efe2bf96.failed

This is motivated by having meaningful ftrace events, but it also
fixes use cases where dma_fence_is_later is called, such as in
sync_file_merge.

In other drivers, fence creation and cmdbuf submission normally
happen atomically,

  mutex_lock();
  fence = dma_fence_create(..., ++timeline->seqno);
  submit_cmdbuf();
  mutex_unlock();

and have no such issue.  But in our driver, because most ioctls
queue commands into ctrlq, we do not want to grab a lock.  Instead,
we set seqno to 0 when a fence is created, and update it when the
command is finally queued and the seqno is known.

	Signed-off-by: Chia-I Wu <olvaffe@gmail.com>
	Reviewed-by: Emil Velikov <emil.velikov@collabora.com>
Link: http://patchwork.freedesktop.org/patch/msgid/20190429220825.156644-1-olvaffe@gmail.com
	Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
(cherry picked from commit efe2bf965522bf0796d413b47a2abbf81d471d6f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/virtio/virtgpu_fence.c
diff --cc drivers/gpu/drm/virtio/virtgpu_fence.c
index 23353521f903,72b4f7561432..000000000000
--- a/drivers/gpu/drm/virtio/virtgpu_fence.c
+++ b/drivers/gpu/drm/virtio/virtgpu_fence.c
@@@ -74,28 -65,40 +72,60 @@@ static const struct dma_fence_ops virti
  	.timeline_value_str  = virtio_timeline_value_str,
  };
  
++<<<<<<< HEAD
++=======
+ struct virtio_gpu_fence *virtio_gpu_fence_alloc(struct virtio_gpu_device *vgdev)
+ {
+ 	struct virtio_gpu_fence_driver *drv = &vgdev->fence_drv;
+ 	struct virtio_gpu_fence *fence = kzalloc(sizeof(struct virtio_gpu_fence),
+ 							GFP_ATOMIC);
+ 	if (!fence)
+ 		return fence;
+ 
+ 	fence->drv = drv;
+ 
+ 	/* This only partially initializes the fence because the seqno is
+ 	 * unknown yet.  The fence must not be used outside of the driver
+ 	 * until virtio_gpu_fence_emit is called.
+ 	 */
+ 	dma_fence_init(&fence->f, &virtio_fence_ops, &drv->lock, drv->context, 0);
+ 
+ 	return fence;
+ }
+ 
++>>>>>>> efe2bf965522 (drm/virtio: set seqno for dma-fence)
  int virtio_gpu_fence_emit(struct virtio_gpu_device *vgdev,
  			  struct virtio_gpu_ctrl_hdr *cmd_hdr,
 -			  struct virtio_gpu_fence *fence)
 +			  struct virtio_gpu_fence **fence)
  {
  	struct virtio_gpu_fence_driver *drv = &vgdev->fence_drv;
  	unsigned long irq_flags;
  
 +	*fence = kmalloc(sizeof(struct virtio_gpu_fence), GFP_ATOMIC);
 +	if ((*fence) == NULL)
 +		return -ENOMEM;
 +
  	spin_lock_irqsave(&drv->lock, irq_flags);
++<<<<<<< HEAD
 +	(*fence)->drv = drv;
 +	(*fence)->seq = ++drv->sync_seq;
 +	dma_fence_init(&(*fence)->f, &virtio_fence_ops, &drv->lock,
 +		       drv->context, (*fence)->seq);
 +	dma_fence_get(&(*fence)->f);
 +	list_add_tail(&(*fence)->node, &drv->fences);
 +	spin_unlock_irqrestore(&drv->lock, irq_flags);
 +
 +	cmd_hdr->flags |= cpu_to_le32(VIRTIO_GPU_FLAG_FENCE);
 +	cmd_hdr->fence_id = cpu_to_le64((*fence)->seq);
++=======
+ 	fence->f.seqno = ++drv->sync_seq;
+ 	dma_fence_get(&fence->f);
+ 	list_add_tail(&fence->node, &drv->fences);
+ 	spin_unlock_irqrestore(&drv->lock, irq_flags);
+ 
+ 	cmd_hdr->flags |= cpu_to_le32(VIRTIO_GPU_FLAG_FENCE);
+ 	cmd_hdr->fence_id = cpu_to_le64(fence->f.seqno);
++>>>>>>> efe2bf965522 (drm/virtio: set seqno for dma-fence)
  	return 0;
  }
  
diff --git a/drivers/gpu/drm/virtio/virtgpu_drv.h b/drivers/gpu/drm/virtio/virtgpu_drv.h
index d25c8ca224aa..207dd61d9d2d 100644
--- a/drivers/gpu/drm/virtio/virtgpu_drv.h
+++ b/drivers/gpu/drm/virtio/virtgpu_drv.h
@@ -85,7 +85,6 @@ struct virtio_gpu_fence {
 	struct dma_fence f;
 	struct virtio_gpu_fence_driver *drv;
 	struct list_head node;
-	uint64_t seq;
 };
 #define to_virtio_fence(x) \
 	container_of(x, struct virtio_gpu_fence, f)
* Unmerged path drivers/gpu/drm/virtio/virtgpu_fence.c
