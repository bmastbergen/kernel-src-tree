net/mlx5e: Support offloading tc double vlan headers match

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jianbo Liu <jianbol@mellanox.com>
commit 699e96ddf47fe67e28522e511f6e1bce8a20b4e1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/699e96dd.failed

We can match on both outer and inner vlan tags, add support for
offloading that.

	Signed-off-by: Jianbo Liu <jianbol@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 699e96ddf47fe67e28522e511f6e1bce8a20b4e1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 1a38c9a292e1,dcb8c4993811..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -1382,6 -1321,91 +1387,94 @@@ static int __parse_cls_flower(struct ml
  			*match_level = MLX5_MATCH_L2;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (dissector_uses_key(f->dissector, FLOW_DISSECTOR_KEY_VLAN)) {
+ 		struct flow_dissector_key_vlan *key =
+ 			skb_flow_dissector_target(f->dissector,
+ 						  FLOW_DISSECTOR_KEY_VLAN,
+ 						  f->key);
+ 		struct flow_dissector_key_vlan *mask =
+ 			skb_flow_dissector_target(f->dissector,
+ 						  FLOW_DISSECTOR_KEY_VLAN,
+ 						  f->mask);
+ 		if (mask->vlan_id || mask->vlan_priority || mask->vlan_tpid) {
+ 			if (key->vlan_tpid == htons(ETH_P_8021AD)) {
+ 				MLX5_SET(fte_match_set_lyr_2_4, headers_c,
+ 					 svlan_tag, 1);
+ 				MLX5_SET(fte_match_set_lyr_2_4, headers_v,
+ 					 svlan_tag, 1);
+ 			} else {
+ 				MLX5_SET(fte_match_set_lyr_2_4, headers_c,
+ 					 cvlan_tag, 1);
+ 				MLX5_SET(fte_match_set_lyr_2_4, headers_v,
+ 					 cvlan_tag, 1);
+ 			}
+ 
+ 			MLX5_SET(fte_match_set_lyr_2_4, headers_c, first_vid, mask->vlan_id);
+ 			MLX5_SET(fte_match_set_lyr_2_4, headers_v, first_vid, key->vlan_id);
+ 
+ 			MLX5_SET(fte_match_set_lyr_2_4, headers_c, first_prio, mask->vlan_priority);
+ 			MLX5_SET(fte_match_set_lyr_2_4, headers_v, first_prio, key->vlan_priority);
+ 
+ 			*match_level = MLX5_MATCH_L2;
+ 		}
+ 	}
+ 
+ 	if (dissector_uses_key(f->dissector, FLOW_DISSECTOR_KEY_CVLAN)) {
+ 		struct flow_dissector_key_vlan *key =
+ 			skb_flow_dissector_target(f->dissector,
+ 						  FLOW_DISSECTOR_KEY_CVLAN,
+ 						  f->key);
+ 		struct flow_dissector_key_vlan *mask =
+ 			skb_flow_dissector_target(f->dissector,
+ 						  FLOW_DISSECTOR_KEY_CVLAN,
+ 						  f->mask);
+ 		if (mask->vlan_id || mask->vlan_priority || mask->vlan_tpid) {
+ 			if (key->vlan_tpid == htons(ETH_P_8021AD)) {
+ 				MLX5_SET(fte_match_set_misc, misc_c,
+ 					 outer_second_svlan_tag, 1);
+ 				MLX5_SET(fte_match_set_misc, misc_v,
+ 					 outer_second_svlan_tag, 1);
+ 			} else {
+ 				MLX5_SET(fte_match_set_misc, misc_c,
+ 					 outer_second_cvlan_tag, 1);
+ 				MLX5_SET(fte_match_set_misc, misc_v,
+ 					 outer_second_cvlan_tag, 1);
+ 			}
+ 
+ 			MLX5_SET(fte_match_set_misc, misc_c, outer_second_vid,
+ 				 mask->vlan_id);
+ 			MLX5_SET(fte_match_set_misc, misc_v, outer_second_vid,
+ 				 key->vlan_id);
+ 			MLX5_SET(fte_match_set_misc, misc_c, outer_second_prio,
+ 				 mask->vlan_priority);
+ 			MLX5_SET(fte_match_set_misc, misc_v, outer_second_prio,
+ 				 key->vlan_priority);
+ 
+ 			*match_level = MLX5_MATCH_L2;
+ 		}
+ 	}
+ 
+ 	if (dissector_uses_key(f->dissector, FLOW_DISSECTOR_KEY_BASIC)) {
+ 		struct flow_dissector_key_basic *key =
+ 			skb_flow_dissector_target(f->dissector,
+ 						  FLOW_DISSECTOR_KEY_BASIC,
+ 						  f->key);
+ 		struct flow_dissector_key_basic *mask =
+ 			skb_flow_dissector_target(f->dissector,
+ 						  FLOW_DISSECTOR_KEY_BASIC,
+ 						  f->mask);
+ 		MLX5_SET(fte_match_set_lyr_2_4, headers_c, ethertype,
+ 			 ntohs(mask->n_proto));
+ 		MLX5_SET(fte_match_set_lyr_2_4, headers_v, ethertype,
+ 			 ntohs(key->n_proto));
+ 
+ 		if (mask->n_proto)
+ 			*match_level = MLX5_MATCH_L2;
+ 	}
+ 
++>>>>>>> 699e96ddf47f (net/mlx5e: Support offloading tc double vlan headers match)
  	if (dissector_uses_key(f->dissector, FLOW_DISSECTOR_KEY_CONTROL)) {
  		struct flow_dissector_key_control *key =
  			skb_flow_dissector_target(f->dissector,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
