net/mlx5: Remove unused events callback and logic

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Saeed Mahameed <saeedm@mellanox.com>
commit 02039fb659b366011f55b15890136754f3d82e2d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/02039fb6.failed

The mlx5_interface->event callback is not used by mlx5e/mlx5_ib anymore.

We totally remove the delayed events logic work around, since with
the dynamic notifier registration API it is not needed anymore, mlx5_ib
can register its notifier and start receiving events exactly at the moment
it is ready to handle them.

	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 02039fb659b366011f55b15890136754f3d82e2d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/events.c
#	drivers/net/ethernet/mellanox/mlx5/core/health.c
#	drivers/net/ethernet/mellanox/mlx5/core/main.c
#	drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
#	include/linux/mlx5/driver.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/health.c
index 43118de8ee99,196c07383082..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/health.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/health.c
@@@ -38,6 -38,8 +38,11 @@@
  #include <linux/mlx5/driver.h>
  #include <linux/mlx5/cmd.h>
  #include "mlx5_core.h"
++<<<<<<< HEAD
++=======
+ #include "lib/eq.h"
+ #include "lib/mlx5.h"
++>>>>>>> 02039fb659b3 (net/mlx5: Remove unused events callback and logic)
  
  enum {
  	MLX5_HEALTH_POLL_INTERVAL	= 2 * HZ,
@@@ -124,10 -103,10 +129,10 @@@ void mlx5_enter_error_state(struct mlx5
  	mlx5_core_err(dev, "start\n");
  	if (pci_channel_offline(dev->pdev) || in_fatal(dev) || force) {
  		dev->state = MLX5_DEVICE_STATE_INTERNAL_ERROR;
 -		mlx5_cmd_trigger_completions(dev);
 +		trigger_cmd_completions(dev);
  	}
  
- 	mlx5_core_event(dev, MLX5_DEV_EVENT_SYS_ERROR, 1);
+ 	mlx5_notifier_call_chain(dev->priv.events, MLX5_DEV_EVENT_SYS_ERROR, (void *)1);
  	mlx5_core_err(dev, "end\n");
  
  unlock:
diff --cc drivers/net/ethernet/mellanox/mlx5/core/main.c
index cfdc2f0b35a2,4bc27a073dc4..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c
@@@ -1388,17 -1165,6 +1381,20 @@@ static int init_one(struct pci_dev *pde
  	mutex_init(&dev->pci_status_mutex);
  	mutex_init(&dev->intf_state_mutex);
  
++<<<<<<< HEAD
 +	INIT_LIST_HEAD(&priv->waiting_events_list);
 +	priv->is_accum_events = false;
 +
 +#ifdef CONFIG_INFINIBAND_ON_DEMAND_PAGING
 +	err = init_srcu_struct(&priv->pfault_srcu);
 +	if (err) {
 +		dev_err(&pdev->dev, "init_srcu_struct failed with error code %d\n",
 +			err);
 +		goto clean_dev;
 +	}
 +#endif
++=======
++>>>>>>> 02039fb659b3 (net/mlx5: Remove unused events callback and logic)
  	mutex_init(&priv->bfregs.reg_head.lock);
  	mutex_init(&priv->bfregs.wc_head.lock);
  	INIT_LIST_HEAD(&priv->bfregs.reg_head.list);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
index 0594d0961cb3,fd3141a4b3f1..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
@@@ -97,12 -102,6 +97,15 @@@ int mlx5_cmd_init_hca(struct mlx5_core_
  int mlx5_cmd_teardown_hca(struct mlx5_core_dev *dev);
  int mlx5_cmd_force_teardown_hca(struct mlx5_core_dev *dev);
  int mlx5_cmd_fast_teardown_hca(struct mlx5_core_dev *dev);
++<<<<<<< HEAD
 +
 +void mlx5_core_event(struct mlx5_core_dev *dev, enum mlx5_dev_event event,
 +		     unsigned long param);
 +void mlx5_core_page_fault(struct mlx5_core_dev *dev,
 +			  struct mlx5_pagefault *pfault);
 +void mlx5_port_module_event(struct mlx5_core_dev *dev, struct mlx5_eqe *eqe);
++=======
++>>>>>>> 02039fb659b3 (net/mlx5: Remove unused events callback and logic)
  void mlx5_enter_error_state(struct mlx5_core_dev *dev, bool force);
  void mlx5_disable_device(struct mlx5_core_dev *dev);
  void mlx5_recover_device(struct mlx5_core_dev *dev);
diff --cc include/linux/mlx5/driver.h
index 17a4bd81b40d,d3ffc64f9a75..000000000000
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@@ -679,9 -588,7 +679,13 @@@ struct mlx5_priv 
  	struct list_head        dev_list;
  	struct list_head        ctx_list;
  	spinlock_t              ctx_lock;
++<<<<<<< HEAD
 +
 +	struct list_head	waiting_events_list;
 +	bool			is_accum_events;
++=======
+ 	struct mlx5_events      *events;
++>>>>>>> 02039fb659b3 (net/mlx5: Remove unused events callback and logic)
  
  	struct mlx5_flow_steering *steering;
  	struct mlx5_mpfs        *mpfs;
@@@ -1190,11 -1047,6 +1191,14 @@@ struct mlx5_interface 
  	void			(*remove)(struct mlx5_core_dev *dev, void *context);
  	int			(*attach)(struct mlx5_core_dev *dev, void *context);
  	void			(*detach)(struct mlx5_core_dev *dev, void *context);
++<<<<<<< HEAD
 +	void			(*event)(struct mlx5_core_dev *dev, void *context,
 +					 enum mlx5_dev_event event, unsigned long param);
 +	void			(*pfault)(struct mlx5_core_dev *dev,
 +					  void *context,
 +					  struct mlx5_pagefault *pfault);
++=======
++>>>>>>> 02039fb659b3 (net/mlx5: Remove unused events callback and logic)
  	void *                  (*get_dev)(void *context);
  	int			protocol;
  	struct list_head	list;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/events.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/dev.c b/drivers/net/ethernet/mellanox/mlx5/core/dev.c
index 62ed11202de3..ce4be6e204a4 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/dev.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/dev.c
@@ -32,7 +32,6 @@
 
 #include <linux/mlx5/driver.h>
 #include "mlx5_core.h"
-#include "lib/mlx5.h"
 
 static LIST_HEAD(intf_list);
 static LIST_HEAD(mlx5_dev_list);
@@ -46,75 +45,11 @@ struct mlx5_device_context {
 	unsigned long		state;
 };
 
-struct mlx5_delayed_event {
-	struct list_head	list;
-	struct mlx5_core_dev	*dev;
-	enum mlx5_dev_event	event;
-	unsigned long		param;
-};
-
 enum {
 	MLX5_INTERFACE_ADDED,
 	MLX5_INTERFACE_ATTACHED,
 };
 
-static void add_delayed_event(struct mlx5_priv *priv,
-			      struct mlx5_core_dev *dev,
-			      enum mlx5_dev_event event,
-			      unsigned long param)
-{
-	struct mlx5_delayed_event *delayed_event;
-
-	delayed_event = kzalloc(sizeof(*delayed_event), GFP_ATOMIC);
-	if (!delayed_event) {
-		mlx5_core_err(dev, "event %d is missed\n", event);
-		return;
-	}
-
-	mlx5_core_dbg(dev, "Accumulating event %d\n", event);
-	delayed_event->dev = dev;
-	delayed_event->event = event;
-	delayed_event->param = param;
-	list_add_tail(&delayed_event->list, &priv->waiting_events_list);
-}
-
-static void delayed_event_release(struct mlx5_device_context *dev_ctx,
-				  struct mlx5_priv *priv)
-{
-	struct mlx5_core_dev *dev = container_of(priv, struct mlx5_core_dev, priv);
-	struct mlx5_delayed_event *de;
-	struct mlx5_delayed_event *n;
-	struct list_head temp;
-
-	INIT_LIST_HEAD(&temp);
-
-	spin_lock_irq(&priv->ctx_lock);
-
-	priv->is_accum_events = false;
-	list_splice_init(&priv->waiting_events_list, &temp);
-	if (!dev_ctx->context)
-		goto out;
-	list_for_each_entry_safe(de, n, &temp, list)
-		dev_ctx->intf->event(dev, dev_ctx->context, de->event, de->param);
-
-out:
-	spin_unlock_irq(&priv->ctx_lock);
-
-	list_for_each_entry_safe(de, n, &temp, list) {
-		list_del(&de->list);
-		kfree(de);
-	}
-}
-
-/* accumulating events that can come after mlx5_ib calls to
- * ib_register_device, till adding that interface to the events list.
- */
-static void delayed_event_start(struct mlx5_priv *priv)
-{
-	spin_lock_irq(&priv->ctx_lock);
-	priv->is_accum_events = true;
-	spin_unlock_irq(&priv->ctx_lock);
-}
 
 void mlx5_add_device(struct mlx5_interface *intf, struct mlx5_priv *priv)
 {
@@ -130,8 +65,6 @@ void mlx5_add_device(struct mlx5_interface *intf, struct mlx5_priv *priv)
 
 	dev_ctx->intf = intf;
 
-	delayed_event_start(priv);
-
 	dev_ctx->context = intf->add(dev);
 	if (dev_ctx->context) {
 		set_bit(MLX5_INTERFACE_ADDED, &dev_ctx->state);
@@ -154,8 +87,6 @@ void mlx5_add_device(struct mlx5_interface *intf, struct mlx5_priv *priv)
 		spin_unlock_irq(&priv->ctx_lock);
 	}
 
-	delayed_event_release(dev_ctx, priv);
-
 	if (!dev_ctx->context)
 		kfree(dev_ctx);
 }
@@ -208,26 +139,20 @@ static void mlx5_attach_interface(struct mlx5_interface *intf, struct mlx5_priv
 	if (!dev_ctx)
 		return;
 
-	delayed_event_start(priv);
 	if (intf->attach) {
 		if (test_bit(MLX5_INTERFACE_ATTACHED, &dev_ctx->state))
-			goto out;
+			return;
 		if (intf->attach(dev, dev_ctx->context))
-			goto out;
-
+			return;
 		set_bit(MLX5_INTERFACE_ATTACHED, &dev_ctx->state);
 	} else {
 		if (test_bit(MLX5_INTERFACE_ADDED, &dev_ctx->state))
-			goto out;
+			return;
 		dev_ctx->context = intf->add(dev);
 		if (!dev_ctx->context)
-			goto out;
-
+			return;
 		set_bit(MLX5_INTERFACE_ADDED, &dev_ctx->state);
 	}
-
-out:
-	delayed_event_release(dev_ctx, priv);
 }
 
 void mlx5_attach_device(struct mlx5_core_dev *dev)
@@ -423,32 +348,6 @@ struct mlx5_core_dev *mlx5_get_next_phys_dev(struct mlx5_core_dev *dev)
 	return res;
 }
 
-void mlx5_core_event(struct mlx5_core_dev *dev, enum mlx5_dev_event event,
-		     unsigned long param)
-{
-	struct mlx5_priv *priv = &dev->priv;
-	struct mlx5_device_context *dev_ctx;
-	unsigned long flags;
-
-	spin_lock_irqsave(&priv->ctx_lock, flags);
-
-	if (priv->is_accum_events)
-		add_delayed_event(priv, dev, event, param);
-
-	/* After mlx5_detach_device, the dev_ctx->intf is still set and dev_ctx is
-	 * still in priv->ctx_list. In this case, only notify the dev_ctx if its
-	 * ADDED or ATTACHED bit are set.
-	 */
-	list_for_each_entry(dev_ctx, &priv->ctx_list, list)
-		if (dev_ctx->intf->event &&
-		    (test_bit(MLX5_INTERFACE_ADDED, &dev_ctx->state) ||
-		     test_bit(MLX5_INTERFACE_ATTACHED, &dev_ctx->state)))
-			dev_ctx->intf->event(dev, dev_ctx->context, event, param);
-
-	spin_unlock_irqrestore(&priv->ctx_lock, flags);
-
-	mlx5_notifier_call_chain(dev->priv.events, event, (void *)param);
-}
 
 #ifdef CONFIG_INFINIBAND_ON_DEMAND_PAGING
 void mlx5_core_page_fault(struct mlx5_core_dev *dev,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/events.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/health.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
* Unmerged path include/linux/mlx5/driver.h
