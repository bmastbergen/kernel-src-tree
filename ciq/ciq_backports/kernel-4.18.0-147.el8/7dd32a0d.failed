KVM: arm/arm64: Add KVM_ARM_VCPU_FINALIZE ioctl

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Dave Martin <Dave.Martin@arm.com>
commit 7dd32a0d0103a5941efbb971f85a3e930cc5665e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/7dd32a0d.failed

Some aspects of vcpu configuration may be too complex to be
completed inside KVM_ARM_VCPU_INIT.  Thus, there may be a
requirement for userspace to do some additional configuration
before various other ioctls will work in a consistent way.

In particular this will be the case for SVE, where userspace will
need to negotiate the set of vector lengths to be made available to
the guest before the vcpu becomes fully usable.

In order to provide an explicit way for userspace to confirm that
it has finished setting up a particular vcpu feature, this patch
adds a new ioctl KVM_ARM_VCPU_FINALIZE.

When userspace has opted into a feature that requires finalization,
typically by means of a feature flag passed to KVM_ARM_VCPU_INIT, a
matching call to KVM_ARM_VCPU_FINALIZE is now required before
KVM_RUN or KVM_GET_REG_LIST is allowed.  Individual features may
impose additional restrictions where appropriate.

No existing vcpu features are affected by this, so current
userspace implementations will continue to work exactly as before,
with no need to issue KVM_ARM_VCPU_FINALIZE.

As implemented in this patch, KVM_ARM_VCPU_FINALIZE is currently a
placeholder: no finalizable features exist yet, so ioctl is not
required and will always yield EINVAL.  Subsequent patches will add
the finalization logic to make use of this ioctl for SVE.

No functional change for existing userspace.

	Signed-off-by: Dave Martin <Dave.Martin@arm.com>
	Reviewed-by: Julien Thierry <julien.thierry@arm.com>
	Tested-by: zhang.lei <zhang.lei@jp.fujitsu.com>
	Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
(cherry picked from commit 7dd32a0d0103a5941efbb971f85a3e930cc5665e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/asm/kvm_host.h
#	include/uapi/linux/kvm.h
#	virt/kvm/arm/arm.c
diff --cc arch/arm64/include/asm/kvm_host.h
index 7eeddb2d82c2,98658f7dad68..000000000000
--- a/arch/arm64/include/asm/kvm_host.h
+++ b/arch/arm64/include/asm/kvm_host.h
@@@ -22,8 -22,14 +22,13 @@@
  #ifndef __ARM64_KVM_HOST_H__
  #define __ARM64_KVM_HOST_H__
  
++<<<<<<< HEAD
++=======
+ #include <linux/bitmap.h>
+ #include <linux/errno.h>
++>>>>>>> 7dd32a0d0103 (KVM: arm/arm64: Add KVM_ARM_VCPU_FINALIZE ioctl)
  #include <linux/types.h>
 -#include <linux/jump_label.h>
  #include <linux/kvm_types.h>
 -#include <linux/percpu.h>
 -#include <asm/arch_gicv3.h>
 -#include <asm/barrier.h>
  #include <asm/cpufeature.h>
  #include <asm/daifflags.h>
  #include <asm/fpsimd.h>
diff --cc include/uapi/linux/kvm.h
index f0694ccb9051,c3b8e7a31315..000000000000
--- a/include/uapi/linux/kvm.h
+++ b/include/uapi/linux/kvm.h
@@@ -1414,6 -1435,15 +1414,18 @@@ struct kvm_enc_region 
  #define KVM_GET_NESTED_STATE         _IOWR(KVMIO, 0xbe, struct kvm_nested_state)
  #define KVM_SET_NESTED_STATE         _IOW(KVMIO,  0xbf, struct kvm_nested_state)
  
++<<<<<<< HEAD
++=======
+ /* Available with KVM_CAP_MANUAL_DIRTY_LOG_PROTECT */
+ #define KVM_CLEAR_DIRTY_LOG          _IOWR(KVMIO, 0xc0, struct kvm_clear_dirty_log)
+ 
+ /* Available with KVM_CAP_HYPERV_CPUID */
+ #define KVM_GET_SUPPORTED_HV_CPUID _IOWR(KVMIO, 0xc1, struct kvm_cpuid2)
+ 
+ /* Available with KVM_CAP_ARM_SVE */
+ #define KVM_ARM_VCPU_FINALIZE	  _IOW(KVMIO,  0xc2, int)
+ 
++>>>>>>> 7dd32a0d0103 (KVM: arm/arm64: Add KVM_ARM_VCPU_FINALIZE ioctl)
  /* Secure Encrypted Virtualization command */
  enum sev_cmd_id {
  	/* Guest initialization commands */
diff --cc virt/kvm/arm/arm.c
index 8f118ce084d3,9edbf0f676e7..000000000000
--- a/virt/kvm/arm/arm.c
+++ b/virt/kvm/arm/arm.c
@@@ -1180,7 -1176,17 +1187,21 @@@ long kvm_arch_vcpu_ioctl(struct file *f
  
  		return kvm_arm_vcpu_set_events(vcpu, &events);
  	}
++<<<<<<< HEAD
 +#endif
++=======
+ 	case KVM_ARM_VCPU_FINALIZE: {
+ 		int what;
+ 
+ 		if (!kvm_vcpu_initialized(vcpu))
+ 			return -ENOEXEC;
+ 
+ 		if (get_user(what, (const int __user *)argp))
+ 			return -EFAULT;
+ 
+ 		return kvm_arm_vcpu_finalize(vcpu, what);
+ 	}
++>>>>>>> 7dd32a0d0103 (KVM: arm/arm64: Add KVM_ARM_VCPU_FINALIZE ioctl)
  	default:
  		r = -EINVAL;
  	}
diff --git a/arch/arm/include/asm/kvm_host.h b/arch/arm/include/asm/kvm_host.h
index 4d0897ce0a24..97198c209973 100644
--- a/arch/arm/include/asm/kvm_host.h
+++ b/arch/arm/include/asm/kvm_host.h
@@ -19,6 +19,7 @@
 #ifndef __ARM_KVM_HOST_H__
 #define __ARM_KVM_HOST_H__
 
+#include <linux/errno.h>
 #include <linux/types.h>
 #include <linux/kvm_types.h>
 #include <asm/cputype.h>
@@ -360,4 +361,7 @@ static inline int kvm_arm_setup_stage2(struct kvm *kvm, unsigned long type)
 	return 0;
 }
 
+#define kvm_arm_vcpu_finalize(vcpu, what) (-EINVAL)
+#define kvm_arm_vcpu_is_finalized(vcpu) true
+
 #endif /* __ARM_KVM_HOST_H__ */
* Unmerged path arch/arm64/include/asm/kvm_host.h
* Unmerged path include/uapi/linux/kvm.h
* Unmerged path virt/kvm/arm/arm.c
