net/mlx5: Forward QP/WorkQueues resource events

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Saeed Mahameed <saeedm@mellanox.com>
commit 451be51c0b474f790e9833cd575fd9a6fbd679df
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/451be51c.failed

Allow forwarding QP and WQ events to mlx5_core interfaces, e.g. mlx5_ib

Use mlx5_notifier_register/unregister in qp.c in order to allow seamless
transition of qp.c to infiniband subsystem.

	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 451be51c0b474f790e9833cd575fd9a6fbd679df)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/events.c
#	drivers/net/ethernet/mellanox/mlx5/core/qp.c
#	include/linux/mlx5/driver.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/qp.c
index cba4a435043a,388f205a497f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/qp.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/qp.c
@@@ -120,14 -115,52 +120,50 @@@ static bool is_event_type_allowed(int r
  	}
  }
  
 -static int rsc_event_notifier(struct notifier_block *nb,
 -			      unsigned long type, void *data)
 +void mlx5_rsc_event(struct mlx5_core_dev *dev, u32 rsn, int event_type)
  {
 -	struct mlx5_core_rsc_common *common;
 -	struct mlx5_qp_table *table;
 -	struct mlx5_core_dev *dev;
 +	struct mlx5_core_rsc_common *common = mlx5_get_rsc(dev, rsn);
  	struct mlx5_core_dct *dct;
 -	u8 event_type = (u8)type;
  	struct mlx5_core_qp *qp;
 -	struct mlx5_priv *priv;
 -	struct mlx5_eqe *eqe;
 -	u32 rsn;
  
++<<<<<<< HEAD
 +	if (!common)
 +		return;
++=======
+ 	switch (event_type) {
+ 	case MLX5_EVENT_TYPE_DCT_DRAINED:
+ 		eqe = data;
+ 		rsn = be32_to_cpu(eqe->data.dct.dctn) & 0xffffff;
+ 		rsn |= (MLX5_RES_DCT << MLX5_USER_INDEX_LEN);
+ 		break;
+ 	case MLX5_EVENT_TYPE_PATH_MIG:
+ 	case MLX5_EVENT_TYPE_COMM_EST:
+ 	case MLX5_EVENT_TYPE_SQ_DRAINED:
+ 	case MLX5_EVENT_TYPE_SRQ_LAST_WQE:
+ 	case MLX5_EVENT_TYPE_WQ_CATAS_ERROR:
+ 	case MLX5_EVENT_TYPE_PATH_MIG_FAILED:
+ 	case MLX5_EVENT_TYPE_WQ_INVAL_REQ_ERROR:
+ 	case MLX5_EVENT_TYPE_WQ_ACCESS_ERROR:
+ 		eqe = data;
+ 		rsn = be32_to_cpu(eqe->data.qp_srq.qp_srq_n) & 0xffffff;
+ 		rsn |= (eqe->data.qp_srq.type << MLX5_USER_INDEX_LEN);
+ 		break;
+ 	default:
+ 		return NOTIFY_DONE;
+ 	}
+ 
+ 	table = container_of(nb, struct mlx5_qp_table, nb);
+ 	priv  = container_of(table, struct mlx5_priv, qp_table);
+ 	dev   = container_of(priv, struct mlx5_core_dev, priv);
+ 
+ 	mlx5_core_dbg(dev, "event (%d) arrived on resource 0x%x\n", eqe->type, rsn);
+ 
+ 	common = mlx5_get_rsc(table, rsn);
+ 	if (!common) {
+ 		mlx5_core_warn(dev, "Async event for bogus resource 0x%x\n", rsn);
+ 		return NOTIFY_OK;
+ 	}
++>>>>>>> 451be51c0b47 (net/mlx5: Forward QP/WorkQueues resource events)
  
  	if (!is_event_type_allowed((rsn >> MLX5_USER_INDEX_LEN), event_type)) {
  		mlx5_core_warn(dev, "event 0x%.2x is not allowed on resource 0x%.8x\n",
@@@ -487,10 -522,16 +523,22 @@@ void mlx5_init_qp_table(struct mlx5_cor
  	spin_lock_init(&table->lock);
  	INIT_RADIX_TREE(&table->tree, GFP_ATOMIC);
  	mlx5_qp_debugfs_init(dev);
++<<<<<<< HEAD
++=======
+ 
+ 	table->nb.notifier_call = rsc_event_notifier;
+ 	mlx5_notifier_register(dev, &table->nb);
++>>>>>>> 451be51c0b47 (net/mlx5: Forward QP/WorkQueues resource events)
  }
  
  void mlx5_cleanup_qp_table(struct mlx5_core_dev *dev)
  {
++<<<<<<< HEAD
++=======
+ 	struct mlx5_qp_table *table = &dev->priv.qp_table;
+ 
+ 	mlx5_notifier_unregister(dev, &table->nb);
++>>>>>>> 451be51c0b47 (net/mlx5: Forward QP/WorkQueues resource events)
  	mlx5_qp_debugfs_cleanup(dev);
  }
  
diff --cc include/linux/mlx5/driver.h
index 17a4bd81b40d,4f078b7f6620..000000000000
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@@ -531,6 -456,8 +531,11 @@@ struct mlx5_core_health 
  };
  
  struct mlx5_qp_table {
++<<<<<<< HEAD
++=======
+ 	struct notifier_block   nb;
+ 
++>>>>>>> 451be51c0b47 (net/mlx5: Forward QP/WorkQueues resource events)
  	/* protect radix tree
  	 */
  	spinlock_t		lock;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/events.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/events.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/qp.c
* Unmerged path include/linux/mlx5/driver.h
