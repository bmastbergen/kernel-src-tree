net: tls: Refactor control message handling on recv

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [net] tls: Refactor control message handling on recv (Sabrina Dubroca) [1711821]
Rebuild_FUZZ: 94.85%
commit-author Dave Watson <davejwatson@fb.com>
commit fedf201e12960bd2fab0596422851b20a8d80d20
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/fedf201e.failed

For TLS 1.3, the control message is encrypted.  Handle control
message checks after decryption.

	Signed-off-by: Dave Watson <davejwatson@fb.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fedf201e12960bd2fab0596422851b20a8d80d20)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/tls/tls_sw.c
diff --cc net/tls/tls_sw.c
index 3f443983a6b3,34f3523f668e..000000000000
--- a/net/tls/tls_sw.c
+++ b/net/tls/tls_sw.c
@@@ -1344,36 -1644,23 +1362,56 @@@ int tls_sw_recvmsg(struct sock *sk
  			goto recv_end;
  		}
  
++<<<<<<< HEAD
 +		if (!ctx->decrypted) {
 +			int to_copy = rxm->full_len - tls_ctx->rx.overhead_size;
 +
 +			if (!is_kvec && to_copy <= len &&
 +			    likely(!(flags & MSG_PEEK)))
 +				zc = true;
 +
 +			err = decrypt_skb_update(sk, skb, &msg->msg_iter,
 +						 &chunk, &zc);
 +			if (err < 0 && err != -EINPROGRESS) {
 +				tls_err_abort(sk, EBADMSG);
 +				goto recv_end;
 +			}
 +
 +			if (err == -EINPROGRESS) {
 +				async = true;
 +				num_async++;
 +				goto pick_next_record;
 +			}
 +
 +			ctx->decrypted = true;
 +		}
 +
 +		if (!zc) {
 +			chunk = min_t(unsigned int, rxm->full_len, len);
 +
 +			err = skb_copy_datagram_msg(skb, rxm->offset, msg,
 +						    chunk);
 +			if (err < 0)
 +				goto recv_end;
++=======
+ 		if (!zc) {
+ 			if (rxm->full_len > len) {
+ 				retain_skb = true;
+ 				chunk = len;
+ 			} else {
+ 				chunk = rxm->full_len;
+ 			}
+ 
+ 			err = skb_copy_datagram_msg(skb, rxm->offset,
+ 						    msg, chunk);
+ 			if (err < 0)
+ 				goto recv_end;
+ 
+ 			if (!is_peek) {
+ 				rxm->offset = rxm->offset + chunk;
+ 				rxm->full_len = rxm->full_len - chunk;
+ 			}
++>>>>>>> fedf201e1296 (net: tls: Refactor control message handling on recv)
  		}
  
  pick_next_record:
@@@ -1455,15 -1759,15 +1493,15 @@@ ssize_t tls_sw_splice_read(struct socke
  	if (!skb)
  		goto splice_read_end;
  
- 	/* splice does not support reading control messages */
- 	if (ctx->control != TLS_RECORD_TYPE_DATA) {
- 		err = -ENOTSUPP;
- 		goto splice_read_end;
- 	}
- 
  	if (!ctx->decrypted) {
 -		err = decrypt_skb_update(sk, skb, NULL, &chunk, &zc, false);
 +		err = decrypt_skb_update(sk, skb, NULL, &chunk, &zc);
  
+ 		/* splice does not support reading control messages */
+ 		if (ctx->control != TLS_RECORD_TYPE_DATA) {
+ 			err = -ENOTSUPP;
+ 			goto splice_read_end;
+ 		}
+ 
  		if (err < 0) {
  			tls_err_abort(sk, EBADMSG);
  			goto splice_read_end;
* Unmerged path net/tls/tls_sw.c
