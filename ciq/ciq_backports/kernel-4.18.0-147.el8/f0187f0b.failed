bpf: libbpf: Refactor and bug fix on the bpf_func_info loading logic

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Martin KaFai Lau <kafai@fb.com>
commit f0187f0b17fad7439f510eff4d65606c9ea1190f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/f0187f0b.failed

This patch refactor and fix a bug in the libbpf's bpf_func_info loading
logic.  The bug fix and refactoring are targeting the same
commit 2993e0515bb4 ("tools/bpf: add support to read .BTF.ext sections")
which is in the bpf-next branch.

1) In bpf_load_program_xattr(), it should retry when errno == E2BIG
   regardless of log_buf and log_buf_sz.  This patch fixes it.

2) btf_ext__reloc_init() and btf_ext__reloc() are essentially
   the same except btf_ext__reloc_init() always has insns_cnt == 0.
   Hence, btf_ext__reloc_init() is removed.

   btf_ext__reloc() is also renamed to btf_ext__reloc_func_info()
   to get ready for the line_info support in the next patch.

3) Consolidate func_info section logic from "btf_ext_parse_hdr()",
   "btf_ext_validate_func_info()" and "btf_ext__new()" to
   a new function "btf_ext_copy_func_info()" such that similar
   logic can be reused by the later libbpf's line_info patch.

4) The next line_info patch will store line_info_cnt instead of
   line_info_len in the bpf_program because the kernel is taking
   line_info_cnt also.  It will save a few "len" to "cnt" conversions
   and will also save some function args.

   Hence, this patch also makes bpf_program to store func_info_cnt
   instead of func_info_len.

5) btf_ext depends on btf.  e.g. the func_info's type_id
   in ".BTF.ext" is not useful when ".BTF" is absent.
   This patch only init the obj->btf_ext pointer after
   it has successfully init the obj->btf pointer.

   This can avoid always checking "obj->btf && obj->btf_ext"
   together for accessing ".BTF.ext".  Checking "obj->btf_ext"
   alone will do.

6) Move "struct btf_sec_func_info" from btf.h to btf.c.
   There is no external usage outside btf.c.

Fixes: 2993e0515bb4 ("tools/bpf: add support to read .BTF.ext sections")
	Signed-off-by: Martin KaFai Lau <kafai@fb.com>
	Acked-by: Yonghong Song <yhs@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit f0187f0b17fad7439f510eff4d65606c9ea1190f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/bpf.c
#	tools/lib/bpf/btf.c
#	tools/lib/bpf/btf.h
#	tools/lib/bpf/libbpf.c
diff --cc tools/lib/bpf/bpf.c
index 2accecf0ac8f,9fbbc0ed5952..000000000000
--- a/tools/lib/bpf/bpf.c
+++ b/tools/lib/bpf/bpf.c
@@@ -212,9 -205,52 +212,55 @@@ int bpf_load_program_xattr(const struc
  	       min(name_len, BPF_OBJ_NAME_LEN - 1));
  
  	fd = sys_bpf(BPF_PROG_LOAD, &attr, sizeof(attr));
- 	if (fd >= 0 || !log_buf || !log_buf_sz)
+ 	if (fd >= 0)
  		return fd;
  
++<<<<<<< HEAD
++=======
+ 	/* After bpf_prog_load, the kernel may modify certain attributes
+ 	 * to give user space a hint how to deal with loading failure.
+ 	 * Check to see whether we can make some changes and load again.
+ 	 */
+ 	if (errno == E2BIG && attr.func_info_cnt &&
+ 	    attr.func_info_rec_size < load_attr->func_info_rec_size) {
+ 		__u32 actual_rec_size = load_attr->func_info_rec_size;
+ 		__u32 expected_rec_size = attr.func_info_rec_size;
+ 		__u32 finfo_cnt = load_attr->func_info_cnt;
+ 		__u64 finfo_len = actual_rec_size * finfo_cnt;
+ 		const void *orecord;
+ 		void *nrecord;
+ 		int i;
+ 
+ 		finfo = malloc(finfo_len);
+ 		if (!finfo)
+ 			/* further try with log buffer won't help */
+ 			return fd;
+ 
+ 		/* zero out bytes kernel does not understand */
+ 		orecord = load_attr->func_info;
+ 		nrecord = finfo;
+ 		for (i = 0; i < load_attr->func_info_cnt; i++) {
+ 			memcpy(nrecord, orecord, expected_rec_size);
+ 			memset(nrecord + expected_rec_size, 0,
+ 			       actual_rec_size - expected_rec_size);
+ 			orecord += actual_rec_size;
+ 			nrecord += actual_rec_size;
+ 		}
+ 
+ 		/* try with corrected func info records */
+ 		attr.func_info = ptr_to_u64(finfo);
+ 		attr.func_info_rec_size = load_attr->func_info_rec_size;
+ 
+ 		fd = sys_bpf(BPF_PROG_LOAD, &attr, sizeof(attr));
+ 
+ 		if (fd >= 0)
+ 			goto done;
+ 	}
+ 
+ 	if (!log_buf || !log_buf_sz)
+ 		goto done;
+ 
++>>>>>>> f0187f0b17fa (bpf: libbpf: Refactor and bug fix on the bpf_func_info loading logic)
  	/* Try again with log */
  	attr.log_buf = ptr_to_u64(log_buf);
  	attr.log_size = log_buf_sz;
diff --cc tools/lib/bpf/btf.c
index ad19a43e946a,aa4fa02b13fc..000000000000
--- a/tools/lib/bpf/btf.c
+++ b/tools/lib/bpf/btf.c
@@@ -32,12 -37,28 +32,35 @@@ struct btf 
  	int fd;
  };
  
++<<<<<<< HEAD
 +static const char *btf_name_by_offset(const struct btf *btf, __u32 offset)
++=======
+ struct btf_ext {
+ 	void *func_info;
+ 	__u32 func_info_rec_size;
+ 	__u32 func_info_len;
+ };
+ 
+ struct btf_sec_func_info {
+ 	__u32	sec_name_off;
+ 	__u32	num_func_info;
+ 	/* Followed by num_func_info number of bpf func_info records */
+ 	__u8	data[0];
+ };
+ 
+ /* The minimum bpf_func_info checked by the loader */
+ struct bpf_func_info_min {
+ 	__u32   insn_off;
+ 	__u32   type_id;
+ };
+ 
+ static inline __u64 ptr_to_u64(const void *ptr)
++>>>>>>> f0187f0b17fa (bpf: libbpf: Refactor and bug fix on the bpf_func_info loading logic)
  {
 -	return (__u64) (unsigned long) ptr;
 +	if (offset < btf->hdr->str_len)
 +		return &btf->strings[offset];
 +	else
 +		return NULL;
  }
  
  static int btf_add_type(struct btf *btf, struct btf_type *t)
@@@ -372,3 -413,285 +395,288 @@@ int btf__fd(const struct btf *btf
  {
  	return btf->fd;
  }
++<<<<<<< HEAD
++=======
+ 
+ const char *btf__name_by_offset(const struct btf *btf, __u32 offset)
+ {
+ 	if (offset < btf->hdr->str_len)
+ 		return &btf->strings[offset];
+ 	else
+ 		return NULL;
+ }
+ 
+ int btf__get_from_id(__u32 id, struct btf **btf)
+ {
+ 	struct bpf_btf_info btf_info = { 0 };
+ 	__u32 len = sizeof(btf_info);
+ 	__u32 last_size;
+ 	int btf_fd;
+ 	void *ptr;
+ 	int err;
+ 
+ 	err = 0;
+ 	*btf = NULL;
+ 	btf_fd = bpf_btf_get_fd_by_id(id);
+ 	if (btf_fd < 0)
+ 		return 0;
+ 
+ 	/* we won't know btf_size until we call bpf_obj_get_info_by_fd(). so
+ 	 * let's start with a sane default - 4KiB here - and resize it only if
+ 	 * bpf_obj_get_info_by_fd() needs a bigger buffer.
+ 	 */
+ 	btf_info.btf_size = 4096;
+ 	last_size = btf_info.btf_size;
+ 	ptr = malloc(last_size);
+ 	if (!ptr) {
+ 		err = -ENOMEM;
+ 		goto exit_free;
+ 	}
+ 
+ 	bzero(ptr, last_size);
+ 	btf_info.btf = ptr_to_u64(ptr);
+ 	err = bpf_obj_get_info_by_fd(btf_fd, &btf_info, &len);
+ 
+ 	if (!err && btf_info.btf_size > last_size) {
+ 		void *temp_ptr;
+ 
+ 		last_size = btf_info.btf_size;
+ 		temp_ptr = realloc(ptr, last_size);
+ 		if (!temp_ptr) {
+ 			err = -ENOMEM;
+ 			goto exit_free;
+ 		}
+ 		ptr = temp_ptr;
+ 		bzero(ptr, last_size);
+ 		btf_info.btf = ptr_to_u64(ptr);
+ 		err = bpf_obj_get_info_by_fd(btf_fd, &btf_info, &len);
+ 	}
+ 
+ 	if (err || btf_info.btf_size > last_size) {
+ 		err = errno;
+ 		goto exit_free;
+ 	}
+ 
+ 	*btf = btf__new((__u8 *)(long)btf_info.btf, btf_info.btf_size, NULL);
+ 	if (IS_ERR(*btf)) {
+ 		err = PTR_ERR(*btf);
+ 		*btf = NULL;
+ 	}
+ 
+ exit_free:
+ 	close(btf_fd);
+ 	free(ptr);
+ 
+ 	return err;
+ }
+ 
+ static int btf_ext_copy_func_info(struct btf_ext *btf_ext,
+ 				  __u8 *data, __u32 data_size,
+ 				  btf_print_fn_t err_log)
+ {
+ 	const struct btf_ext_header *hdr = (struct btf_ext_header *)data;
+ 	const struct btf_sec_func_info *sinfo;
+ 	__u32 info_left, record_size;
+ 	/* The start of the info sec (including the __u32 record_size). */
+ 	const void *info;
+ 
+ 	/* data and data_size do not include btf_ext_header from now on */
+ 	data = data + hdr->hdr_len;
+ 	data_size -= hdr->hdr_len;
+ 
+ 	if (hdr->func_info_off & 0x03) {
+ 		elog("BTF.ext func_info section is not aligned to 4 bytes\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (data_size < hdr->func_info_off ||
+ 	    hdr->func_info_len > data_size - hdr->func_info_off) {
+ 		elog("func_info section (off:%u len:%u) is beyond the end of the ELF section .BTF.ext\n",
+ 		     hdr->func_info_off, hdr->func_info_len);
+ 		return -EINVAL;
+ 	}
+ 
+ 	info = data + hdr->func_info_off;
+ 	info_left = hdr->func_info_len;
+ 
+ 	/* At least a func_info record size */
+ 	if (info_left < sizeof(__u32)) {
+ 		elog("BTF.ext func_info record size not found");
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* The record size needs to meet the minimum standard */
+ 	record_size = *(__u32 *)info;
+ 	if (record_size < sizeof(struct bpf_func_info_min) ||
+ 	    record_size & 0x03) {
+ 		elog("BTF.ext func_info invalid record size");
+ 		return -EINVAL;
+ 	}
+ 
+ 	sinfo = info + sizeof(__u32);
+ 	info_left -= sizeof(__u32);
+ 
+ 	/* If no func_info records, return failure now so .BTF.ext
+ 	 * won't be used.
+ 	 */
+ 	if (!info_left) {
+ 		elog("BTF.ext no func info records");
+ 		return -EINVAL;
+ 	}
+ 
+ 	while (info_left) {
+ 		unsigned int sec_hdrlen = sizeof(struct btf_sec_func_info);
+ 		__u64 total_record_size;
+ 		__u32 num_records;
+ 
+ 		if (info_left < sec_hdrlen) {
+ 			elog("BTF.ext func_info header not found");
+ 			return -EINVAL;
+ 		}
+ 
+ 		num_records = sinfo->num_func_info;
+ 		if (num_records == 0) {
+ 			elog("incorrect BTF.ext num_func_info");
+ 			return -EINVAL;
+ 		}
+ 
+ 		total_record_size = sec_hdrlen +
+ 				    (__u64)num_records * record_size;
+ 		if (info_left < total_record_size) {
+ 			elog("incorrect BTF.ext num_func_info");
+ 			return -EINVAL;
+ 		}
+ 
+ 		info_left -= total_record_size;
+ 		sinfo = (void *)sinfo + total_record_size;
+ 	}
+ 
+ 	btf_ext->func_info_len = hdr->func_info_len - sizeof(__u32);
+ 	btf_ext->func_info_rec_size = record_size;
+ 	btf_ext->func_info = malloc(btf_ext->func_info_len);
+ 	if (!btf_ext->func_info)
+ 		return -ENOMEM;
+ 	memcpy(btf_ext->func_info, info + sizeof(__u32),
+ 	       btf_ext->func_info_len);
+ 
+ 	return 0;
+ }
+ 
+ static int btf_ext_parse_hdr(__u8 *data, __u32 data_size,
+ 			     btf_print_fn_t err_log)
+ {
+ 	const struct btf_ext_header *hdr = (struct btf_ext_header *)data;
+ 
+ 	if (data_size < offsetof(struct btf_ext_header, func_info_off) ||
+ 	    data_size < hdr->hdr_len) {
+ 		elog("BTF.ext header not found");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (hdr->magic != BTF_MAGIC) {
+ 		elog("Invalid BTF.ext magic:%x\n", hdr->magic);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (hdr->version != BTF_VERSION) {
+ 		elog("Unsupported BTF.ext version:%u\n", hdr->version);
+ 		return -ENOTSUP;
+ 	}
+ 
+ 	if (hdr->flags) {
+ 		elog("Unsupported BTF.ext flags:%x\n", hdr->flags);
+ 		return -ENOTSUP;
+ 	}
+ 
+ 	if (data_size == hdr->hdr_len) {
+ 		elog("BTF.ext has no data\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ void btf_ext__free(struct btf_ext *btf_ext)
+ {
+ 	if (!btf_ext)
+ 		return;
+ 
+ 	free(btf_ext->func_info);
+ 	free(btf_ext);
+ }
+ 
+ struct btf_ext *btf_ext__new(__u8 *data, __u32 size, btf_print_fn_t err_log)
+ {
+ 	struct btf_ext *btf_ext;
+ 	int err;
+ 
+ 	err = btf_ext_parse_hdr(data, size, err_log);
+ 	if (err)
+ 		return ERR_PTR(err);
+ 
+ 	btf_ext = calloc(1, sizeof(struct btf_ext));
+ 	if (!btf_ext)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	err = btf_ext_copy_func_info(btf_ext, data, size, err_log);
+ 	if (err) {
+ 		btf_ext__free(btf_ext);
+ 		return ERR_PTR(err);
+ 	}
+ 
+ 	return btf_ext;
+ }
+ 
+ int btf_ext__reloc_func_info(struct btf *btf, struct btf_ext *btf_ext,
+ 			     const char *sec_name, __u32 insns_cnt,
+ 			     void **func_info, __u32 *cnt)
+ {
+ 	__u32 sec_hdrlen = sizeof(struct btf_sec_func_info);
+ 	__u32 i, record_size, existing_flen, records_len;
+ 	struct btf_sec_func_info *sinfo;
+ 	const char *info_sec_name;
+ 	__u64 remain_len;
+ 	void *data;
+ 
+ 	record_size = btf_ext->func_info_rec_size;
+ 	sinfo = btf_ext->func_info;
+ 	remain_len = btf_ext->func_info_len;
+ 	while (remain_len > 0) {
+ 		records_len = sinfo->num_func_info * record_size;
+ 		info_sec_name = btf__name_by_offset(btf, sinfo->sec_name_off);
+ 		if (strcmp(info_sec_name, sec_name)) {
+ 			remain_len -= sec_hdrlen + records_len;
+ 			sinfo = (void *)sinfo + sec_hdrlen + records_len;
+ 			continue;
+ 		}
+ 
+ 		existing_flen = (*cnt) * record_size;
+ 		data = realloc(*func_info, existing_flen + records_len);
+ 		if (!data)
+ 			return -ENOMEM;
+ 
+ 		memcpy(data + existing_flen, sinfo->data, records_len);
+ 		/* adjust insn_off only, the rest data will be passed
+ 		 * to the kernel.
+ 		 */
+ 		for (i = 0; i < sinfo->num_func_info; i++) {
+ 			struct bpf_func_info_min *record;
+ 
+ 			record = data + existing_flen + i * record_size;
+ 			record->insn_off =
+ 				record->insn_off / sizeof(struct bpf_insn) +
+ 				insns_cnt;
+ 		}
+ 		*func_info = data;
+ 		*cnt += sinfo->num_func_info;
+ 		return 0;
+ 	}
+ 
+ 	return -ENOENT;
+ }
+ 
+ __u32 btf_ext__func_info_rec_size(const struct btf_ext *btf_ext)
+ {
+ 	return btf_ext->func_info_rec_size;
+ }
++>>>>>>> f0187f0b17fa (bpf: libbpf: Refactor and bug fix on the bpf_func_info loading logic)
diff --cc tools/lib/bpf/btf.h
index caac3a404dc5,936177a538cd..000000000000
--- a/tools/lib/bpf/btf.h
+++ b/tools/lib/bpf/btf.h
@@@ -6,19 -6,77 +6,66 @@@
  
  #include <linux/types.h>
  
 -#ifdef __cplusplus
 -extern "C" {
 -#endif
 -
 -#ifndef LIBBPF_API
 -#define LIBBPF_API __attribute__((visibility("default")))
 -#endif
 -
  #define BTF_ELF_SEC ".BTF"
 -#define BTF_EXT_ELF_SEC ".BTF.ext"
  
  struct btf;
 -struct btf_ext;
  struct btf_type;
  
++<<<<<<< HEAD
++=======
+ /*
+  * The .BTF.ext ELF section layout defined as
+  *   struct btf_ext_header
+  *   func_info subsection
+  *
+  * The func_info subsection layout:
+  *   record size for struct bpf_func_info in the func_info subsection
+  *   struct btf_sec_func_info for section #1
+  *   a list of bpf_func_info records for section #1
+  *     where struct bpf_func_info mimics one in include/uapi/linux/bpf.h
+  *     but may not be identical
+  *   struct btf_sec_func_info for section #2
+  *   a list of bpf_func_info records for section #2
+  *   ......
+  *
+  * Note that the bpf_func_info record size in .BTF.ext may not
+  * be the same as the one defined in include/uapi/linux/bpf.h.
+  * The loader should ensure that record_size meets minimum
+  * requirement and pass the record as is to the kernel. The
+  * kernel will handle the func_info properly based on its contents.
+  */
+ struct btf_ext_header {
+ 	__u16	magic;
+ 	__u8	version;
+ 	__u8	flags;
+ 	__u32	hdr_len;
+ 
+ 	/* All offsets are in bytes relative to the end of this header */
+ 	__u32	func_info_off;
+ 	__u32	func_info_len;
+ };
+ 
++>>>>>>> f0187f0b17fa (bpf: libbpf: Refactor and bug fix on the bpf_func_info loading logic)
  typedef int (*btf_print_fn_t)(const char *, ...)
  	__attribute__((format(printf, 1, 2)));
  
 -LIBBPF_API void btf__free(struct btf *btf);
 -LIBBPF_API struct btf *btf__new(__u8 *data, __u32 size, btf_print_fn_t err_log);
 -LIBBPF_API __s32 btf__find_by_name(const struct btf *btf,
 -				   const char *type_name);
 -LIBBPF_API const struct btf_type *btf__type_by_id(const struct btf *btf,
 -						  __u32 id);
 -LIBBPF_API __s64 btf__resolve_size(const struct btf *btf, __u32 type_id);
 -LIBBPF_API int btf__resolve_type(const struct btf *btf, __u32 type_id);
 -LIBBPF_API int btf__fd(const struct btf *btf);
 -LIBBPF_API const char *btf__name_by_offset(const struct btf *btf, __u32 offset);
 -LIBBPF_API int btf__get_from_id(__u32 id, struct btf **btf);
 +void btf__free(struct btf *btf);
 +struct btf *btf__new(__u8 *data, __u32 size, btf_print_fn_t err_log);
 +__s32 btf__find_by_name(const struct btf *btf, const char *type_name);
 +const struct btf_type *btf__type_by_id(const struct btf *btf, __u32 id);
 +__s64 btf__resolve_size(const struct btf *btf, __u32 type_id);
 +int btf__fd(const struct btf *btf);
  
++<<<<<<< HEAD
++=======
+ struct btf_ext *btf_ext__new(__u8 *data, __u32 size, btf_print_fn_t err_log);
+ void btf_ext__free(struct btf_ext *btf_ext);
+ int btf_ext__reloc_func_info(struct btf *btf, struct btf_ext *btf_ext,
+ 			     const char *sec_name, __u32 insns_cnt,
+ 			     void **func_info, __u32 *func_info_len);
+ __u32 btf_ext__func_info_rec_size(const struct btf_ext *btf_ext);
+ 
+ #ifdef __cplusplus
+ } /* extern "C" */
++>>>>>>> f0187f0b17fa (bpf: libbpf: Refactor and bug fix on the bpf_func_info loading logic)
  #endif
 -
 -#endif /* __LIBBPF_BTF_H */
diff --cc tools/lib/bpf/libbpf.c
index 38df8e0ed95d,4ea3368bf803..000000000000
--- a/tools/lib/bpf/libbpf.c
+++ b/tools/lib/bpf/libbpf.c
@@@ -167,6 -164,12 +167,15 @@@ struct bpf_program 
  	bpf_program_clear_priv_t clear_priv;
  
  	enum bpf_attach_type expected_attach_type;
++<<<<<<< HEAD
++=======
+ 	int btf_fd;
+ 	void *func_info;
+ 	__u32 func_info_rec_size;
+ 	__u32 func_info_cnt;
+ 
+ 	struct bpf_capabilities *caps;
++>>>>>>> f0187f0b17fa (bpf: libbpf: Refactor and bug fix on the bpf_func_info loading logic)
  };
  
  struct bpf_map {
@@@ -799,6 -841,8 +809,11 @@@ static int bpf_object__elf_collect(stru
  					   BTF_ELF_SEC, PTR_ERR(obj->btf));
  				obj->btf = NULL;
  			}
++<<<<<<< HEAD
++=======
+ 		} else if (strcmp(name, BTF_EXT_ELF_SEC) == 0) {
+ 			btf_ext_data = data;
++>>>>>>> f0187f0b17fa (bpf: libbpf: Refactor and bug fix on the bpf_func_info loading logic)
  		} else if (sh.sh_type == SHT_SYMTAB) {
  			if (obj->efile.symbols) {
  				pr_warning("bpf: multiple SYMTAB in %s\n",
@@@ -1205,6 -1378,15 +1299,18 @@@ bpf_program__reloc_text(struct bpf_prog
  			pr_warning("oom in prog realloc\n");
  			return -ENOMEM;
  		}
++<<<<<<< HEAD
++=======
+ 
+ 		if (obj->btf_ext) {
+ 			err = bpf_program_reloc_btf_ext(prog, obj,
+ 							text->section_name,
+ 							prog->insns_cnt);
+ 			if (err)
+ 				return err;
+ 		}
+ 
++>>>>>>> f0187f0b17fa (bpf: libbpf: Refactor and bug fix on the bpf_func_info loading logic)
  		memcpy(new_insn + prog->insns_cnt, text->insns,
  		       text->insns_cnt * sizeof(*insn));
  		prog->insns = new_insn;
@@@ -1224,7 -1406,17 +1330,21 @@@ bpf_program__relocate(struct bpf_progra
  {
  	int i, err;
  
++<<<<<<< HEAD
 +	if (!prog || !prog->reloc_desc)
++=======
+ 	if (!prog)
+ 		return 0;
+ 
+ 	if (obj->btf_ext) {
+ 		err = bpf_program_reloc_btf_ext(prog, obj,
+ 						prog->section_name, 0);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	if (!prog->reloc_desc)
++>>>>>>> f0187f0b17fa (bpf: libbpf: Refactor and bug fix on the bpf_func_info loading logic)
  		return 0;
  
  	for (i = 0; i < prog->nr_reloc; i++) {
@@@ -1312,9 -1504,8 +1432,14 @@@ static int bpf_object__collect_reloc(st
  }
  
  static int
++<<<<<<< HEAD
 +load_program(enum bpf_prog_type type, enum bpf_attach_type expected_attach_type,
 +	     const char *name, struct bpf_insn *insns, int insns_cnt,
 +	     char *license, __u32 kern_version, int *pfd, int prog_ifindex)
++=======
+ load_program(struct bpf_program *prog, struct bpf_insn *insns, int insns_cnt,
+ 	     char *license, __u32 kern_version, int *pfd)
++>>>>>>> f0187f0b17fa (bpf: libbpf: Refactor and bug fix on the bpf_func_info loading logic)
  {
  	struct bpf_load_program_attr load_attr;
  	char *cp, errmsg[STRERR_BUFSIZE];
@@@ -1329,8 -1521,11 +1454,16 @@@
  	load_attr.insns_cnt = insns_cnt;
  	load_attr.license = license;
  	load_attr.kern_version = kern_version;
++<<<<<<< HEAD
 +	load_attr.prog_ifindex = prog_ifindex;
 +
++=======
+ 	load_attr.prog_ifindex = prog->prog_ifindex;
+ 	load_attr.prog_btf_fd = prog->btf_fd >= 0 ? prog->btf_fd : 0;
+ 	load_attr.func_info = prog->func_info;
+ 	load_attr.func_info_rec_size = prog->func_info_rec_size;
+ 	load_attr.func_info_cnt = prog->func_info_cnt;
++>>>>>>> f0187f0b17fa (bpf: libbpf: Refactor and bug fix on the bpf_func_info loading logic)
  	if (!load_attr.insns || !load_attr.insns_cnt)
  		return -EINVAL;
  
@@@ -1410,10 -1605,8 +1543,15 @@@ bpf_program__load(struct bpf_program *p
  			pr_warning("Program '%s' is inconsistent: nr(%d) != 1\n",
  				   prog->section_name, prog->instances.nr);
  		}
++<<<<<<< HEAD
 +		err = load_program(prog->type, prog->expected_attach_type,
 +				   prog->name, prog->insns, prog->insns_cnt,
 +				   license, kern_version, &fd,
 +				   prog->prog_ifindex);
++=======
+ 		err = load_program(prog, prog->insns, prog->insns_cnt,
+ 				   license, kern_version, &fd);
++>>>>>>> f0187f0b17fa (bpf: libbpf: Refactor and bug fix on the bpf_func_info loading logic)
  		if (!err)
  			prog->instances.fds[0] = fd;
  		goto out;
@@@ -1441,11 -1634,9 +1579,15 @@@
  			continue;
  		}
  
 -		err = load_program(prog, result.new_insn_ptr,
 +		err = load_program(prog->type, prog->expected_attach_type,
 +				   prog->name, result.new_insn_ptr,
  				   result.new_insn_cnt,
++<<<<<<< HEAD
 +				   license, kern_version, &fd,
 +				   prog->prog_ifindex);
++=======
+ 				   license, kern_version, &fd);
++>>>>>>> f0187f0b17fa (bpf: libbpf: Refactor and bug fix on the bpf_func_info loading logic)
  
  		if (err) {
  			pr_warning("Loading the %dth instance of program '%s' failed\n",
* Unmerged path tools/lib/bpf/bpf.c
* Unmerged path tools/lib/bpf/btf.c
* Unmerged path tools/lib/bpf/btf.h
* Unmerged path tools/lib/bpf/libbpf.c
