scsi: qla2xxx: Complain loudly about reference count underflow

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Bart Van Assche <bvanassche@acm.org>
commit db4bf822c58cd2b4a6718c982ce48a5292f5cc6a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/db4bf822.failed

A reference count underflow is a severe bug. Hence complain loudly if a
reference count underflow happens.

	Cc: Himanshu Madhani <hmadhani@marvell.com>
	Cc: Giridhar Malavali <gmalavali@marvell.com>
	Signed-off-by: Bart Van Assche <bvanassche@acm.org>
	Acked-by: Himanshu Madhani <hmadhani@marvell.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit db4bf822c58cd2b4a6718c982ce48a5292f5cc6a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_nvme.c
#	drivers/scsi/qla2xxx/qla_os.c
diff --cc drivers/scsi/qla2xxx/qla_nvme.c
index fd5f4610435f,22e3fba28e51..000000000000
--- a/drivers/scsi/qla2xxx/qla_nvme.c
+++ b/drivers/scsi/qla2xxx/qla_nvme.c
@@@ -127,14 -131,10 +127,11 @@@ static void qla_nvme_sp_ls_done(void *p
  	struct nvmefc_ls_req   *fd;
  	struct nvme_private *priv;
  
- 	if (atomic_read(&sp->ref_count) == 0) {
- 		ql_log(ql_log_warn, sp->fcport->vha, 0x2123,
- 		    "SP reference-count to ZERO on LS_done -- sp=%p.\n", sp);
+ 	if (WARN_ON_ONCE(atomic_read(&sp->ref_count) == 0))
  		return;
- 	}
  
 -	atomic_dec(&sp->ref_count);
 +	if (!atomic_dec_and_test(&sp->ref_count))
 +		return;
  
  	if (res)
  		res = -EINVAL;
@@@ -157,15 -157,18 +154,22 @@@ static void qla_nvme_sp_done(void *ptr
  	nvme = &sp->u.iocb_cmd;
  	fd = nvme->u.nvme.desc;
  
++<<<<<<< HEAD
 +	if (!atomic_dec_and_test(&sp->ref_count))
 +		return;
++=======
+ 	if (WARN_ON_ONCE(atomic_read(&sp->ref_count) == 0))
+ 		return;
+ 
+ 	atomic_dec(&sp->ref_count);
++>>>>>>> db4bf822c58c (scsi: qla2xxx: Complain loudly about reference count underflow)
  
 -	if (res == QLA_SUCCESS) {
 -		fd->rcv_rsplen = nvme->u.nvme.rsp_pyld_len;
 -	} else {
 -		fd->rcv_rsplen = 0;
 -		fd->transferred_length = 0;
 -	}
 -	fd->status = 0;
 +	if (res == QLA_SUCCESS)
 +		fd->status = 0;
 +	else
 +		fd->status = NVME_SC_INTERNAL;
 +
 +	fd->rcv_rsplen = nvme->u.nvme.rsp_pyld_len;
  	fd->done(fd);
  	qla2xxx_rel_qpair_sp(sp->qpair, sp);
  
@@@ -188,6 -191,17 +192,20 @@@ static void qla_nvme_abort_work(struct 
  	if (!ha->flags.fw_started && (fcport && fcport->deleted))
  		return;
  
++<<<<<<< HEAD
++=======
+ 	if (ha->flags.host_shutting_down) {
+ 		ql_log(ql_log_info, sp->fcport->vha, 0xffff,
+ 		    "%s Calling done on sp: %p, type: 0x%x, sp->ref_count: 0x%x\n",
+ 		    __func__, sp, sp->type, atomic_read(&sp->ref_count));
+ 		sp->done(sp, 0);
+ 		return;
+ 	}
+ 
+ 	if (WARN_ON_ONCE(atomic_read(&sp->ref_count) == 0))
+ 		return;
+ 
++>>>>>>> db4bf822c58c (scsi: qla2xxx: Complain loudly about reference count underflow)
  	rval = ha->isp_ops->abort_command(sp);
  
  	ql_dbg(ql_dbg_io, fcport->vha, 0x212b,
diff --cc drivers/scsi/qla2xxx/qla_os.c
index 9c7c364118a9,e1c82a0a9745..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -756,17 -714,12 +756,17 @@@ qla2x00_sp_compl(void *ptr, int res
  {
  	srb_t *sp = ptr;
  	struct scsi_cmnd *cmd = GET_CMD_SP(sp);
 -	struct completion *comp = sp->comp;
  
- 	if (atomic_read(&sp->ref_count) == 0) {
- 		ql_dbg(ql_dbg_io, sp->vha, 0x3015,
- 		    "SP reference-count to ZERO -- sp=%p cmd=%p.\n",
- 		    sp, GET_CMD_SP(sp));
- 		if (ql2xextended_error_logging & ql_dbg_io)
- 			WARN_ON(atomic_read(&sp->ref_count) == 0);
+ 	if (WARN_ON_ONCE(atomic_read(&sp->ref_count) == 0))
  		return;
++<<<<<<< HEAD
 +	}
 +	if (!atomic_dec_and_test(&sp->ref_count))
 +		return;
++=======
+ 
+ 	atomic_dec(&sp->ref_count);
++>>>>>>> db4bf822c58c (scsi: qla2xxx: Complain loudly about reference count underflow)
  
  	sp->free(sp);
  	cmd->result = res;
@@@ -827,27 -819,22 +827,27 @@@ qla2xxx_qpair_sp_compl(void *ptr, int r
  {
  	srb_t *sp = ptr;
  	struct scsi_cmnd *cmd = GET_CMD_SP(sp);
 -	struct completion *comp = sp->comp;
 +
 +	cmd->result = res;
  
- 	if (atomic_read(&sp->ref_count) == 0) {
- 		ql_dbg(ql_dbg_io, sp->fcport->vha, 0x3079,
- 		    "SP reference-count to ZERO -- sp=%p cmd=%p.\n",
- 		    sp, GET_CMD_SP(sp));
- 		if (ql2xextended_error_logging & ql_dbg_io)
- 			WARN_ON(atomic_read(&sp->ref_count) == 0);
+ 	if (WARN_ON_ONCE(atomic_read(&sp->ref_count) == 0))
  		return;
++<<<<<<< HEAD
 +	}
 +	if (!atomic_dec_and_test(&sp->ref_count))
 +		return;
++=======
+ 
+ 	atomic_dec(&sp->ref_count);
++>>>>>>> db4bf822c58c (scsi: qla2xxx: Complain loudly about reference count underflow)
  
  	sp->free(sp);
 -	cmd->result = res;
 -	CMD_SP(cmd) = NULL;
  	cmd->scsi_done(cmd);
 -	if (comp)
 -		complete(comp);
 -	qla2xxx_rel_qpair_sp(sp->qpair, sp);
  }
  
 +/* If we are SP1 here, we need to still take and release the host_lock as SP1
 + * does not have the changes necessary to avoid taking host->host_lock.
 + */
  static int
  qla2xxx_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *cmd)
  {
* Unmerged path drivers/scsi/qla2xxx/qla_nvme.c
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
