scsi: qla2xxx: Split the __qla2x00_abort_all_cmds() function

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Bart Van Assche <bvanassche@acm.org>
commit c4e521b654e15e372a6429e269e7e907b4698224
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/c4e521b6.failed

Nesting in __qla2x00_abort_all_cmds() is way too deep. Reduce the nesting
level by introducing a helper function. This patch does not change any
functionality.

	Reviewed-by: Laurence Oberman <loberman@redhat.com>
	Acked-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Bart Van Assche <bvanassche@acm.org>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit c4e521b654e15e372a6429e269e7e907b4698224)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_os.c
diff --cc drivers/scsi/qla2xxx/qla_os.c
index 5e9ae3138bee,4a75e0572121..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -1729,61 -1801,16 +1764,69 @@@ __qla2x00_abort_all_cmds(struct qla_qpa
  		sp = req->outstanding_cmds[cnt];
  		if (sp) {
  			req->outstanding_cmds[cnt] = NULL;
++<<<<<<< HEAD
 +			if (sp->cmd_type == TYPE_SRB) {
 +				if (sp->type == SRB_NVME_CMD ||
 +				    sp->type == SRB_NVME_LS) {
 +					sp_get(sp);
 +					spin_unlock_irqrestore(qp->qp_lock_ptr,
 +					    flags);
 +					qla_nvme_abort(ha, sp, res);
 +					spin_lock_irqsave(qp->qp_lock_ptr,
 +					    flags);
 +				} else if (GET_CMD_SP(sp) &&
 +				    !ha->flags.eeh_busy &&
 +				    (!test_bit(ABORT_ISP_ACTIVE,
 +					&vha->dpc_flags)) &&
 +				    !qla2x00_isp_reg_stat(ha) &&
 +				    (sp->type == SRB_SCSI_CMD)) {
 +					/*
 +					 * Don't abort commands in
 +					 * adapter during EEH
 +					 * recovery as it's not
 +					 * accessible/responding.
 +					 *
 +					 * Get a reference to the sp
 +					 * and drop the lock. The
 +					 * reference ensures this
 +					 * sp->done() call and not the
 +					 * call in qla2xxx_eh_abort()
 +					 * ends the SCSI command (with
 +					 * result 'res').
 +					 */
 +					sp_get(sp);
 +					spin_unlock_irqrestore(qp->qp_lock_ptr,
 +					    flags);
 +					status = qla2xxx_eh_abort(
 +					    GET_CMD_SP(sp));
 +					spin_lock_irqsave(qp->qp_lock_ptr,
 +					    flags);
 +					/*
 +					 * Get rid of extra reference
 +					 * if immediate exit from
 +					 * ql2xxx_eh_abort
 +					 */
 +					if (status == FAILED &&
 +					    (qla2x00_isp_reg_stat(ha)))
 +						atomic_dec(
 +						    &sp->ref_count);
 +				}
 +				sp->done(sp, res);
 +			} else {
++=======
+ 			switch (sp->cmd_type) {
+ 			case TYPE_SRB:
+ 				qla2x00_abort_srb(qp, sp, res, &flags);
+ 				break;
+ 			case TYPE_TGT_CMD:
++>>>>>>> c4e521b654e1 (scsi: qla2xxx: Split the __qla2x00_abort_all_cmds() function)
  				if (!vha->hw->tgt.tgt_ops || !tgt ||
  				    qla_ini_mode_enabled(vha)) {
 -					ql_dbg(ql_dbg_tgt_mgt, vha, 0xf003,
 -					    "HOST-ABORT-HNDLR: dpc_flags=%lx. Target mode disabled\n",
 -					    vha->dpc_flags);
 +					if (!trace)
 +						ql_dbg(ql_dbg_tgt_mgt,
 +						    vha, 0xf003,
 +						    "HOST-ABORT-HNDLR: dpc_flags=%lx. Target mode disabled\n",
 +						    vha->dpc_flags);
  					continue;
  				}
  				cmd = (struct qla_tgt_cmd *)sp;
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
