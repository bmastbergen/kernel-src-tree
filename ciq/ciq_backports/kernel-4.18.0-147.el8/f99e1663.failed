tools: bpftool: add probes for eBPF map types

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Quentin Monnet <quentin.monnet@netronome.com>
commit f99e166397f0298fe78bce24c55c6d074f9bf196
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/f99e1663.failed

Add new probes for eBPF map types, to detect what are the ones available
on the system. Try creating one map of each type, and see if the kernel
complains.

Sample output:

    # bpftool feature probe kernel
    ...
    Scanning eBPF map types...
    eBPF map_type hash is available
    eBPF map_type array is available
    eBPF map_type prog_array is available
    ...

    # bpftool --json --pretty feature probe kernel
    {
        ...
        "map_types": {
            "have_hash_map_type": true,
            "have_array_map_type": true,
            "have_prog_array_map_type": true,
            ...
        }
    }

v5:
- In libbpf.map, move global symbol to the new LIBBPF_0.0.2 section.

v3:
- Use a switch with all enum values for setting specific map parameters,
  so that gcc complains at compile time (-Wswitch-enum) if new map types
  were added to the kernel but libbpf was not updated.

v2:
- Move probes from bpftool to libbpf.
- Remove C-style macros output from this patch.

	Signed-off-by: Quentin Monnet <quentin.monnet@netronome.com>
	Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Stanislav Fomichev <sdf@google.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit f99e166397f0298fe78bce24c55c6d074f9bf196)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/bpf/bpftool/feature.c
#	tools/lib/bpf/libbpf.h
#	tools/lib/bpf/libbpf.map
#	tools/lib/bpf/libbpf_probes.c
diff --cc tools/bpf/bpftool/feature.c
index 4a2867439ab7,cc731475c74b..000000000000
--- a/tools/bpf/bpftool/feature.c
+++ b/tools/bpf/bpftool/feature.c
@@@ -403,6 -416,48 +403,51 @@@ static bool probe_bpf_syscall(void
  	return res;
  }
  
++<<<<<<< HEAD
++=======
+ static void probe_prog_type(enum bpf_prog_type prog_type, bool *supported_types)
+ {
+ 	const char *plain_comment = "eBPF program_type ";
+ 	char feat_name[128], plain_desc[128];
+ 	size_t maxlen;
+ 	bool res;
+ 
+ 	res = bpf_probe_prog_type(prog_type, 0);
+ 
+ 	supported_types[prog_type] |= res;
+ 
+ 	maxlen = sizeof(plain_desc) - strlen(plain_comment) - 1;
+ 	if (strlen(prog_type_name[prog_type]) > maxlen) {
+ 		p_info("program type name too long");
+ 		return;
+ 	}
+ 
+ 	sprintf(feat_name, "have_%s_prog_type", prog_type_name[prog_type]);
+ 	sprintf(plain_desc, "%s%s", plain_comment, prog_type_name[prog_type]);
+ 	print_bool_feature(feat_name, plain_desc, res);
+ }
+ 
+ static void probe_map_type(enum bpf_map_type map_type)
+ {
+ 	const char *plain_comment = "eBPF map_type ";
+ 	char feat_name[128], plain_desc[128];
+ 	size_t maxlen;
+ 	bool res;
+ 
+ 	res = bpf_probe_map_type(map_type, 0);
+ 
+ 	maxlen = sizeof(plain_desc) - strlen(plain_comment) - 1;
+ 	if (strlen(map_type_name[map_type]) > maxlen) {
+ 		p_info("map type name too long");
+ 		return;
+ 	}
+ 
+ 	sprintf(feat_name, "have_%s_map_type", map_type_name[map_type]);
+ 	sprintf(plain_desc, "%s%s", plain_comment, map_type_name[map_type]);
+ 	print_bool_feature(feat_name, plain_desc, res);
+ }
+ 
++>>>>>>> f99e166397f0 (tools: bpftool: add probes for eBPF map types)
  static int do_probe(int argc, char **argv)
  {
  	enum probe_component target = COMPONENT_UNSPEC;
@@@ -460,8 -517,23 +505,24 @@@
  	print_start_section("syscall_config",
  			    "Scanning system call availability...");
  
 -	if (!probe_bpf_syscall())
 -		/* bpf() syscall unavailable, don't probe other BPF features */
 -		goto exit_close_json;
 +	probe_bpf_syscall();
  
++<<<<<<< HEAD
++=======
+ 	print_end_then_start_section("program_types",
+ 				     "Scanning eBPF program types...");
+ 
+ 	for (i = BPF_PROG_TYPE_UNSPEC + 1; i < ARRAY_SIZE(prog_type_name); i++)
+ 		probe_prog_type(i, supported_types);
+ 
+ 	print_end_then_start_section("map_types",
+ 				     "Scanning eBPF map types...");
+ 
+ 	for (i = BPF_MAP_TYPE_UNSPEC + 1; i < map_type_name_size; i++)
+ 		probe_map_type(i);
+ 
+ exit_close_json:
++>>>>>>> f99e166397f0 (tools: bpftool: add probes for eBPF map types)
  	if (json_output) {
  		/* End current "section" of probes */
  		jsonw_end_object(json_wtr);
diff --cc tools/lib/bpf/libbpf.h
index c8c168c73302,72385f6f9415..000000000000
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@@ -298,10 -321,54 +298,61 @@@ enum bpf_perf_event_ret 
  	LIBBPF_PERF_EVENT_CONT	= -2,
  };
  
++<<<<<<< HEAD
 +typedef enum bpf_perf_event_ret (*bpf_perf_event_print_t)(void *event,
 +							  void *priv);
 +int bpf_perf_event_read_simple(void *mem, unsigned long size,
 +			       unsigned long page_size,
 +			       void **buf, size_t *buf_len,
 +			       bpf_perf_event_print_t fn, void *priv);
++=======
+ struct perf_event_header;
+ typedef enum bpf_perf_event_ret
+ 	(*bpf_perf_event_print_t)(struct perf_event_header *hdr,
+ 				  void *private_data);
+ LIBBPF_API enum bpf_perf_event_ret
+ bpf_perf_event_read_simple(void *mmap_mem, size_t mmap_size, size_t page_size,
+ 			   void **copy_mem, size_t *copy_size,
+ 			   bpf_perf_event_print_t fn, void *private_data);
+ 
+ struct nlattr;
+ typedef int (*libbpf_dump_nlmsg_t)(void *cookie, void *msg, struct nlattr **tb);
+ int libbpf_netlink_open(unsigned int *nl_pid);
+ int libbpf_nl_get_link(int sock, unsigned int nl_pid,
+ 		       libbpf_dump_nlmsg_t dump_link_nlmsg, void *cookie);
+ int libbpf_nl_get_class(int sock, unsigned int nl_pid, int ifindex,
+ 			libbpf_dump_nlmsg_t dump_class_nlmsg, void *cookie);
+ int libbpf_nl_get_qdisc(int sock, unsigned int nl_pid, int ifindex,
+ 			libbpf_dump_nlmsg_t dump_qdisc_nlmsg, void *cookie);
+ int libbpf_nl_get_filter(int sock, unsigned int nl_pid, int ifindex, int handle,
+ 			 libbpf_dump_nlmsg_t dump_filter_nlmsg, void *cookie);
+ 
+ struct bpf_prog_linfo;
+ struct bpf_prog_info;
+ 
+ LIBBPF_API void bpf_prog_linfo__free(struct bpf_prog_linfo *prog_linfo);
+ LIBBPF_API struct bpf_prog_linfo *
+ bpf_prog_linfo__new(const struct bpf_prog_info *info);
+ LIBBPF_API const struct bpf_line_info *
+ bpf_prog_linfo__lfind_addr_func(const struct bpf_prog_linfo *prog_linfo,
+ 				__u64 addr, __u32 func_idx, __u32 nr_skip);
+ LIBBPF_API const struct bpf_line_info *
+ bpf_prog_linfo__lfind(const struct bpf_prog_linfo *prog_linfo,
+ 		      __u32 insn_off, __u32 nr_skip);
+ 
+ /*
+  * Probe for supported system features
+  *
+  * Note that running many of these probes in a short amount of time can cause
+  * the kernel to reach the maximal size of lockable memory allowed for the
+  * user, causing subsequent probes to fail. In this case, the caller may want
+  * to adjust that limit with setrlimit().
+  */
+ LIBBPF_API bool bpf_probe_prog_type(enum bpf_prog_type prog_type,
+ 				    __u32 ifindex);
+ LIBBPF_API bool bpf_probe_map_type(enum bpf_map_type map_type, __u32 ifindex);
+ 
+ #ifdef __cplusplus
+ } /* extern "C" */
++>>>>>>> f99e166397f0 (tools: bpftool: add probes for eBPF map types)
  #endif
 -
 -#endif /* __LIBBPF_LIBBPF_H */
diff --cc tools/lib/bpf/libbpf.map
index 4fb29f6d7a80,bb2dfc3b2d7b..000000000000
--- a/tools/lib/bpf/libbpf.map
+++ b/tools/lib/bpf/libbpf.map
@@@ -119,3 -124,9 +119,12 @@@ LIBBPF_0.0.1 
  	local:
  		*;
  };
++<<<<<<< HEAD
++=======
+ 
+ LIBBPF_0.0.2 {
+ 	global:
+ 		bpf_probe_map_type;
+ 		bpf_probe_prog_type;
+ } LIBBPF_0.0.1;
++>>>>>>> f99e166397f0 (tools: bpftool: add probes for eBPF map types)
* Unmerged path tools/lib/bpf/libbpf_probes.c
* Unmerged path tools/bpf/bpftool/feature.c
diff --git a/tools/bpf/bpftool/main.h b/tools/bpf/bpftool/main.h
index 748f4e06dc0c..a93e8c663c8e 100644
--- a/tools/bpf/bpftool/main.h
+++ b/tools/bpf/bpftool/main.h
@@ -75,6 +75,9 @@ static const char * const prog_type_name[] = {
 	[BPF_PROG_TYPE_FLOW_DISSECTOR]		= "flow_dissector",
 };
 
+extern const char * const map_type_name[];
+extern const size_t map_type_name_size;
+
 enum bpf_obj_type {
 	BPF_OBJ_UNKNOWN,
 	BPF_OBJ_PROG,
diff --git a/tools/bpf/bpftool/map.c b/tools/bpf/bpftool/map.c
index 59e0acd2979b..caa907110447 100644
--- a/tools/bpf/bpftool/map.c
+++ b/tools/bpf/bpftool/map.c
@@ -18,7 +18,7 @@
 
 #include "main.h"
 
-static const char * const map_type_name[] = {
+const char * const map_type_name[] = {
 	[BPF_MAP_TYPE_UNSPEC]			= "unspec",
 	[BPF_MAP_TYPE_HASH]			= "hash",
 	[BPF_MAP_TYPE_ARRAY]			= "array",
@@ -45,6 +45,8 @@ static const char * const map_type_name[] = {
 	[BPF_MAP_TYPE_STACK]			= "stack",
 };
 
+const size_t map_type_name_size = ARRAY_SIZE(map_type_name);
+
 static bool map_is_per_cpu(__u32 type)
 {
 	return type == BPF_MAP_TYPE_PERCPU_HASH ||
* Unmerged path tools/lib/bpf/libbpf.h
* Unmerged path tools/lib/bpf/libbpf.map
* Unmerged path tools/lib/bpf/libbpf_probes.c
