nvme: take node locality into account when selecting a path

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Christoph Hellwig <hch@lst.de>
commit f333444708f82c4a4d3ccac004da0bfd9cfdfa42
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/f3334447.failed

Make current_path an array with an entry for every possible node, and
cache the best path on a per-node basis.  Take the node distance into
account when selecting it.  This is primarily useful for dual-ported PCIe
devices which are connected to PCIe root ports on different sockets.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Keith Busch <keith.busch@intel.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
(cherry picked from commit f333444708f82c4a4d3ccac004da0bfd9cfdfa42)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/multipath.c
#	drivers/nvme/host/nvme.h
diff --cc drivers/nvme/host/multipath.c
index 1b128a2a399e,52987052b7fc..000000000000
--- a/drivers/nvme/host/multipath.c
+++ b/drivers/nvme/host/multipath.c
@@@ -68,26 -108,80 +68,100 @@@ void nvme_kick_requeue_lists(struct nvm
  	up_read(&ctrl->namespaces_rwsem);
  }
  
++<<<<<<< HEAD
 +static struct nvme_ns *__nvme_find_path(struct nvme_ns_head *head)
 +{
 +	struct nvme_ns *ns;
 +
 +	list_for_each_entry_rcu(ns, &head->list, siblings) {
 +		if (ns->ctrl->state == NVME_CTRL_LIVE) {
 +			rcu_assign_pointer(head->current_path, ns);
 +			return ns;
 +		}
 +	}
 +
 +	return NULL;
++=======
+ static const char *nvme_ana_state_names[] = {
+ 	[0]				= "invalid state",
+ 	[NVME_ANA_OPTIMIZED]		= "optimized",
+ 	[NVME_ANA_NONOPTIMIZED]		= "non-optimized",
+ 	[NVME_ANA_INACCESSIBLE]		= "inaccessible",
+ 	[NVME_ANA_PERSISTENT_LOSS]	= "persistent-loss",
+ 	[NVME_ANA_CHANGE]		= "change",
+ };
+ 
+ void nvme_mpath_clear_current_path(struct nvme_ns *ns)
+ {
+ 	struct nvme_ns_head *head = ns->head;
+ 	int node;
+ 
+ 	if (!head)
+ 		return;
+ 
+ 	for_each_node(node) {
+ 		if (ns == rcu_access_pointer(head->current_path[node]))
+ 			rcu_assign_pointer(head->current_path[node], NULL);
+ 	}
+ }
+ 
+ static struct nvme_ns *__nvme_find_path(struct nvme_ns_head *head, int node)
+ {
+ 	int found_distance = INT_MAX, fallback_distance = INT_MAX, distance;
+ 	struct nvme_ns *found = NULL, *fallback = NULL, *ns;
+ 
+ 	list_for_each_entry_rcu(ns, &head->list, siblings) {
+ 		if (ns->ctrl->state != NVME_CTRL_LIVE ||
+ 		    test_bit(NVME_NS_ANA_PENDING, &ns->flags))
+ 			continue;
+ 
+ 		distance = node_distance(node, dev_to_node(ns->ctrl->dev));
+ 
+ 		switch (ns->ana_state) {
+ 		case NVME_ANA_OPTIMIZED:
+ 			if (distance < found_distance) {
+ 				found_distance = distance;
+ 				found = ns;
+ 			}
+ 			break;
+ 		case NVME_ANA_NONOPTIMIZED:
+ 			if (distance < fallback_distance) {
+ 				fallback_distance = distance;
+ 				fallback = ns;
+ 			}
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (!found)
+ 		found = fallback;
+ 	if (found)
+ 		rcu_assign_pointer(head->current_path[node], found);
+ 	return found;
+ }
+ 
+ static inline bool nvme_path_is_optimized(struct nvme_ns *ns)
+ {
+ 	return ns->ctrl->state == NVME_CTRL_LIVE &&
+ 		ns->ana_state == NVME_ANA_OPTIMIZED;
++>>>>>>> f333444708f8 (nvme: take node locality into account when selecting a path)
  }
  
  inline struct nvme_ns *nvme_find_path(struct nvme_ns_head *head)
  {
- 	struct nvme_ns *ns = srcu_dereference(head->current_path, &head->srcu);
+ 	int node = numa_node_id();
+ 	struct nvme_ns *ns;
  
++<<<<<<< HEAD
 +	if (unlikely(!ns || ns->ctrl->state != NVME_CTRL_LIVE))
 +		ns = __nvme_find_path(head);
++=======
+ 	ns = srcu_dereference(head->current_path[node], &head->srcu);
+ 	if (unlikely(!ns || !nvme_path_is_optimized(ns)))
+ 		ns = __nvme_find_path(head, node);
++>>>>>>> f333444708f8 (nvme: take node locality into account when selecting a path)
  	return ns;
  }
  
@@@ -126,6 -220,21 +200,24 @@@ static blk_qc_t nvme_ns_head_make_reque
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static bool nvme_ns_head_poll(struct request_queue *q, blk_qc_t qc)
+ {
+ 	struct nvme_ns_head *head = q->queuedata;
+ 	struct nvme_ns *ns;
+ 	bool found = false;
+ 	int srcu_idx;
+ 
+ 	srcu_idx = srcu_read_lock(&head->srcu);
+ 	ns = srcu_dereference(head->current_path[numa_node_id()], &head->srcu);
+ 	if (likely(ns && nvme_path_is_optimized(ns)))
+ 		found = ns->queue->poll_fn(q, qc);
+ 	srcu_read_unlock(&head->srcu, srcu_idx);
+ 	return found;
+ }
+ 
++>>>>>>> f333444708f8 (nvme: take node locality into account when selecting a path)
  static void nvme_requeue_work(struct work_struct *work)
  {
  	struct nvme_ns_head *head =
diff --cc drivers/nvme/host/nvme.h
index 43c5bb60abbc,9fefba039d1e..000000000000
--- a/drivers/nvme/host/nvme.h
+++ b/drivers/nvme/host/nvme.h
@@@ -257,13 -277,6 +257,16 @@@ struct nvme_ns_ids 
   * only ever has a single entry for private namespaces.
   */
  struct nvme_ns_head {
++<<<<<<< HEAD
 +#ifdef CONFIG_NVME_MULTIPATH
 +	struct gendisk		*disk;
 +	struct nvme_ns __rcu	*current_path;
 +	struct bio_list		requeue_list;
 +	spinlock_t		requeue_lock;
 +	struct work_struct	requeue_work;
 +#endif
++=======
++>>>>>>> f333444708f8 (nvme: take node locality into account when selecting a path)
  	struct list_head	list;
  	struct srcu_struct      srcu;
  	struct nvme_subsystem	*subsys;
@@@ -443,16 -469,12 +454,23 @@@ void nvme_set_disk_name(char *disk_name
  void nvme_failover_req(struct request *req);
  void nvme_kick_requeue_lists(struct nvme_ctrl *ctrl);
  int nvme_mpath_alloc_disk(struct nvme_ctrl *ctrl,struct nvme_ns_head *head);
 -void nvme_mpath_add_disk(struct nvme_ns *ns, struct nvme_id_ns *id);
 +void nvme_mpath_add_disk(struct nvme_ns_head *head);
  void nvme_mpath_remove_disk(struct nvme_ns_head *head);
++<<<<<<< HEAD
 +
 +static inline void nvme_mpath_clear_current_path(struct nvme_ns *ns)
 +{
 +	struct nvme_ns_head *head = ns->head;
 +
 +	if (head && ns == rcu_access_pointer(head->current_path))
 +		rcu_assign_pointer(head->current_path, NULL);
 +}
++=======
+ int nvme_mpath_init(struct nvme_ctrl *ctrl, struct nvme_id_ctrl *id);
+ void nvme_mpath_uninit(struct nvme_ctrl *ctrl);
+ void nvme_mpath_stop(struct nvme_ctrl *ctrl);
+ void nvme_mpath_clear_current_path(struct nvme_ns *ns);
++>>>>>>> f333444708f8 (nvme: take node locality into account when selecting a path)
  struct nvme_ns *nvme_find_path(struct nvme_ns_head *head);
  
  static inline void nvme_mpath_check_last_path(struct nvme_ns *ns)
diff --git a/drivers/nvme/host/core.c b/drivers/nvme/host/core.c
index 4726c694b7b8..3bdb75652fbf 100644
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@ -2896,9 +2896,14 @@ static struct nvme_ns_head *nvme_alloc_ns_head(struct nvme_ctrl *ctrl,
 		unsigned nsid, struct nvme_id_ns *id)
 {
 	struct nvme_ns_head *head;
+	size_t size = sizeof(*head);
 	int ret = -ENOMEM;
 
-	head = kzalloc(sizeof(*head), GFP_KERNEL);
+#ifdef CONFIG_NVME_MULTIPATH
+	size += num_possible_nodes() * sizeof(struct nvme_ns *);
+#endif
+
+	head = kzalloc(size, GFP_KERNEL);
 	if (!head)
 		goto out;
 	ret = ida_simple_get(&ctrl->subsys->ns_ida, 1, 0, GFP_KERNEL);
* Unmerged path drivers/nvme/host/multipath.c
* Unmerged path drivers/nvme/host/nvme.h
