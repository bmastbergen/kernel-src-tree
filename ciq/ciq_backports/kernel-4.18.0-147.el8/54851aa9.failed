ipv6: Unlink sibling route in case of failure

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Ido Schimmel <idosch@mellanox.com>
commit 54851aa90cf27041d64b12f65ac72e9f97bd90fd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/54851aa9.failed

When a route needs to be appended to an existing multipath route,
fib6_add_rt2node() first appends it to the siblings list and increments
the number of sibling routes on each sibling.

Later, the function notifies the route via call_fib6_entry_notifiers().
In case the notification is vetoed, the route is not unlinked from the
siblings list, which can result in a use-after-free.

Fix this by unlinking the route from the siblings list before returning
an error.

Audited the rest of the call sites from which the FIB notification chain
is called and could not find more problems.

Fixes: 2233000cba40 ("net/ipv6: Move call_fib6_entry_notifiers up for route adds")
	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Reported-by: Alexander Petrovskiy <alexpe@mellanox.com>
	Reviewed-by: David Ahern <dsahern@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 54851aa90cf27041d64b12f65ac72e9f97bd90fd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_fib.c
diff --cc net/ipv6/ip6_fib.c
index 7411bc5ac659,87f47bc55c5e..000000000000
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@@ -1114,14 -1147,32 +1114,40 @@@ next_iter
  add:
  		nlflags |= NLM_F_CREATE;
  
++<<<<<<< HEAD
 +		err = call_fib6_entry_notifiers(info->nl_net,
 +						FIB_EVENT_ENTRY_ADD,
 +						rt, extack);
 +		if (err)
 +			return err;
++=======
+ 		if (!info->skip_notify_kernel) {
+ 			err = call_fib6_entry_notifiers(info->nl_net,
+ 							FIB_EVENT_ENTRY_ADD,
+ 							rt, extack);
+ 			if (err) {
+ 				struct fib6_info *sibling, *next_sibling;
+ 
+ 				/* If the route has siblings, then it first
+ 				 * needs to be unlinked from them.
+ 				 */
+ 				if (!rt->fib6_nsiblings)
+ 					return err;
+ 
+ 				list_for_each_entry_safe(sibling, next_sibling,
+ 							 &rt->fib6_siblings,
+ 							 fib6_siblings)
+ 					sibling->fib6_nsiblings--;
+ 				rt->fib6_nsiblings = 0;
+ 				list_del_init(&rt->fib6_siblings);
+ 				rt6_multipath_rebalance(next_sibling);
+ 				return err;
+ 			}
+ 		}
++>>>>>>> 54851aa90cf2 (ipv6: Unlink sibling route in case of failure)
  
  		rcu_assign_pointer(rt->fib6_next, iter);
 -		fib6_info_hold(rt);
 +		atomic_inc(&rt->fib6_ref);
  		rcu_assign_pointer(rt->fib6_node, fn);
  		rcu_assign_pointer(*ins, rt);
  		if (!info->skip_notify)
* Unmerged path net/ipv6/ip6_fib.c
