bpf: Add BPF_LD_IMM64 to the line_info test

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Martin KaFai Lau <kafai@fb.com>
commit e30f5640e32455e02ba08983ebe0b46054f1f6f0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/e30f5640.failed

This patch adds a BPF_LD_IMM64 case to the line_info test
to ensure the kernel rejects linfo_info.insn_off pointing
to the 2nd 8 bytes of the BPF_LD_IMM64.

	Signed-off-by: Martin KaFai Lau <kafai@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit e30f5640e32455e02ba08983ebe0b46054f1f6f0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/bpf/test_btf.c
diff --cc tools/testing/selftests/bpf/test_btf.c
index 63c4a0e26e4e,8bcd38010582..000000000000
--- a/tools/testing/selftests/bpf/test_btf.c
+++ b/tools/testing/selftests/bpf/test_btf.c
@@@ -4176,6 -4194,305 +4176,308 @@@ static struct btf_func_type_test 
  	.func_info = { {0, 5}, {2, 6} },
  	.func_info_rec_size = 8,
  	.func_info_cnt = 2,
++<<<<<<< HEAD
++=======
+ 	.line_info = { BTF_END_RAW },
+ 	.expected_prog_load_failure = true,
+ },
+ 
+ {
+ 	.descr = "line_info (No subprog)",
+ 	.raw_types = {
+ 		BTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),	/* [1] */
+ 		BTF_END_RAW,
+ 	},
+ 	BTF_STR_SEC("\0int\0int a=1;\0int b=2;\0return a + b;\0return a + b;"),
+ 	.insns = {
+ 		BPF_MOV64_IMM(BPF_REG_0, 1),
+ 		BPF_MOV64_IMM(BPF_REG_1, 2),
+ 		BPF_ALU64_REG(BPF_ADD, BPF_REG_0, BPF_REG_1),
+ 		BPF_EXIT_INSN(),
+ 	},
+ 	.prog_type = BPF_PROG_TYPE_TRACEPOINT,
+ 	.func_info_cnt = 0,
+ 	.line_info = {
+ 		BPF_LINE_INFO_ENC(0, 0, NAME_TBD, 1, 10),
+ 		BPF_LINE_INFO_ENC(1, 0, NAME_TBD, 2, 9),
+ 		BPF_LINE_INFO_ENC(2, 0, NAME_TBD, 3, 8),
+ 		BPF_LINE_INFO_ENC(3, 0, NAME_TBD, 4, 7),
+ 		BTF_END_RAW,
+ 	},
+ 	.line_info_rec_size = sizeof(struct bpf_line_info),
+ 	.nr_jited_ksyms = 1,
+ },
+ 
+ {
+ 	.descr = "line_info (No subprog. insn_off >= prog->len)",
+ 	.raw_types = {
+ 		BTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),	/* [1] */
+ 		BTF_END_RAW,
+ 	},
+ 	BTF_STR_SEC("\0int\0int a=1;\0int b=2;\0return a + b;\0return a + b;"),
+ 	.insns = {
+ 		BPF_MOV64_IMM(BPF_REG_0, 1),
+ 		BPF_MOV64_IMM(BPF_REG_1, 2),
+ 		BPF_ALU64_REG(BPF_ADD, BPF_REG_0, BPF_REG_1),
+ 		BPF_EXIT_INSN(),
+ 	},
+ 	.prog_type = BPF_PROG_TYPE_TRACEPOINT,
+ 	.func_info_cnt = 0,
+ 	.line_info = {
+ 		BPF_LINE_INFO_ENC(0, 0, NAME_TBD, 1, 10),
+ 		BPF_LINE_INFO_ENC(1, 0, NAME_TBD, 2, 9),
+ 		BPF_LINE_INFO_ENC(2, 0, NAME_TBD, 3, 8),
+ 		BPF_LINE_INFO_ENC(3, 0, NAME_TBD, 4, 7),
+ 		BPF_LINE_INFO_ENC(4, 0, 0, 5, 6),
+ 		BTF_END_RAW,
+ 	},
+ 	.line_info_rec_size = sizeof(struct bpf_line_info),
+ 	.nr_jited_ksyms = 1,
+ 	.err_str = "line_info[4].insn_off",
+ 	.expected_prog_load_failure = true,
+ },
+ 
+ {
+ 	.descr = "line_info (Zero bpf insn code)",
+ 	.raw_types = {
+ 		BTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),	/* [1] */
+ 		BTF_TYPE_INT_ENC(NAME_TBD, 0, 0, 64, 8),	/* [2] */
+ 		BTF_TYPEDEF_ENC(NAME_TBD, 2),			/* [3] */
+ 		BTF_END_RAW,
+ 	},
+ 	BTF_STR_SEC("\0int\0unsigned long\0u64\0u64 a=1;\0return a;"),
+ 	.insns = {
+ 		BPF_LD_IMM64(BPF_REG_0, 1),
+ 		BPF_EXIT_INSN(),
+ 	},
+ 	.prog_type = BPF_PROG_TYPE_TRACEPOINT,
+ 	.func_info_cnt = 0,
+ 	.line_info = {
+ 		BPF_LINE_INFO_ENC(0, 0, NAME_TBD, 1, 10),
+ 		BPF_LINE_INFO_ENC(1, 0, 0, 2, 9),
+ 		BPF_LINE_INFO_ENC(2, 0, NAME_TBD, 3, 8),
+ 		BTF_END_RAW,
+ 	},
+ 	.line_info_rec_size = sizeof(struct bpf_line_info),
+ 	.nr_jited_ksyms = 1,
+ 	.err_str = "Invalid insn code at line_info[1]",
+ 	.expected_prog_load_failure = true,
+ },
+ 
+ {
+ 	.descr = "line_info (No subprog. zero tailing line_info",
+ 	.raw_types = {
+ 		BTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),	/* [1] */
+ 		BTF_END_RAW,
+ 	},
+ 	BTF_STR_SEC("\0int\0int a=1;\0int b=2;\0return a + b;\0return a + b;"),
+ 	.insns = {
+ 		BPF_MOV64_IMM(BPF_REG_0, 1),
+ 		BPF_MOV64_IMM(BPF_REG_1, 2),
+ 		BPF_ALU64_REG(BPF_ADD, BPF_REG_0, BPF_REG_1),
+ 		BPF_EXIT_INSN(),
+ 	},
+ 	.prog_type = BPF_PROG_TYPE_TRACEPOINT,
+ 	.func_info_cnt = 0,
+ 	.line_info = {
+ 		BPF_LINE_INFO_ENC(0, 0, NAME_TBD, 1, 10), 0,
+ 		BPF_LINE_INFO_ENC(1, 0, NAME_TBD, 2, 9), 0,
+ 		BPF_LINE_INFO_ENC(2, 0, NAME_TBD, 3, 8), 0,
+ 		BPF_LINE_INFO_ENC(3, 0, NAME_TBD, 4, 7), 0,
+ 		BTF_END_RAW,
+ 	},
+ 	.line_info_rec_size = sizeof(struct bpf_line_info) + sizeof(__u32),
+ 	.nr_jited_ksyms = 1,
+ },
+ 
+ {
+ 	.descr = "line_info (No subprog. nonzero tailing line_info)",
+ 	.raw_types = {
+ 		BTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),	/* [1] */
+ 		BTF_END_RAW,
+ 	},
+ 	BTF_STR_SEC("\0int\0int a=1;\0int b=2;\0return a + b;\0return a + b;"),
+ 	.insns = {
+ 		BPF_MOV64_IMM(BPF_REG_0, 1),
+ 		BPF_MOV64_IMM(BPF_REG_1, 2),
+ 		BPF_ALU64_REG(BPF_ADD, BPF_REG_0, BPF_REG_1),
+ 		BPF_EXIT_INSN(),
+ 	},
+ 	.prog_type = BPF_PROG_TYPE_TRACEPOINT,
+ 	.func_info_cnt = 0,
+ 	.line_info = {
+ 		BPF_LINE_INFO_ENC(0, 0, NAME_TBD, 1, 10), 0,
+ 		BPF_LINE_INFO_ENC(1, 0, NAME_TBD, 2, 9), 0,
+ 		BPF_LINE_INFO_ENC(2, 0, NAME_TBD, 3, 8), 0,
+ 		BPF_LINE_INFO_ENC(3, 0, NAME_TBD, 4, 7), 1,
+ 		BTF_END_RAW,
+ 	},
+ 	.line_info_rec_size = sizeof(struct bpf_line_info) + sizeof(__u32),
+ 	.nr_jited_ksyms = 1,
+ 	.err_str = "nonzero tailing record in line_info",
+ 	.expected_prog_load_failure = true,
+ },
+ 
+ {
+ 	.descr = "line_info (subprog)",
+ 	.raw_types = {
+ 		BTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),	/* [1] */
+ 		BTF_END_RAW,
+ 	},
+ 	BTF_STR_SEC("\0int\0int a=1+1;\0return func(a);\0b+=1;\0return b;"),
+ 	.insns = {
+ 		BPF_MOV64_IMM(BPF_REG_2, 1),
+ 		BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, 1),
+ 		BPF_MOV64_REG(BPF_REG_1, BPF_REG_2),
+ 		BPF_CALL_REL(1),
+ 		BPF_EXIT_INSN(),
+ 		BPF_MOV64_REG(BPF_REG_0, BPF_REG_1),
+ 		BPF_ALU64_IMM(BPF_ADD, BPF_REG_0, 1),
+ 		BPF_EXIT_INSN(),
+ 	},
+ 	.prog_type = BPF_PROG_TYPE_TRACEPOINT,
+ 	.func_info_cnt = 0,
+ 	.line_info = {
+ 		BPF_LINE_INFO_ENC(0, 0, NAME_TBD, 1, 10),
+ 		BPF_LINE_INFO_ENC(2, 0, NAME_TBD, 2, 9),
+ 		BPF_LINE_INFO_ENC(5, 0, NAME_TBD, 3, 8),
+ 		BPF_LINE_INFO_ENC(7, 0, NAME_TBD, 4, 7),
+ 		BTF_END_RAW,
+ 	},
+ 	.line_info_rec_size = sizeof(struct bpf_line_info),
+ 	.nr_jited_ksyms = 2,
+ },
+ 
+ {
+ 	.descr = "line_info (subprog + func_info)",
+ 	.raw_types = {
+ 		BTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),	/* [1] */
+ 		BTF_FUNC_PROTO_ENC(1, 1),			/* [2] */
+ 			BTF_FUNC_PROTO_ARG_ENC(NAME_TBD, 1),
+ 		BTF_FUNC_ENC(NAME_TBD, 2),			/* [3] */
+ 		BTF_FUNC_ENC(NAME_TBD, 2),			/* [4] */
+ 		BTF_END_RAW,
+ 	},
+ 	BTF_STR_SEC("\0int\0x\0sub\0main\0int a=1+1;\0return func(a);\0b+=1;\0return b;"),
+ 	.insns = {
+ 		BPF_MOV64_IMM(BPF_REG_2, 1),
+ 		BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, 1),
+ 		BPF_MOV64_REG(BPF_REG_1, BPF_REG_2),
+ 		BPF_CALL_REL(1),
+ 		BPF_EXIT_INSN(),
+ 		BPF_MOV64_REG(BPF_REG_0, BPF_REG_1),
+ 		BPF_ALU64_IMM(BPF_ADD, BPF_REG_0, 1),
+ 		BPF_EXIT_INSN(),
+ 	},
+ 	.prog_type = BPF_PROG_TYPE_TRACEPOINT,
+ 	.func_info_cnt = 2,
+ 	.func_info_rec_size = 8,
+ 	.func_info = { {0, 4}, {5, 3} },
+ 	.line_info = {
+ 		BPF_LINE_INFO_ENC(0, 0, NAME_TBD, 1, 10),
+ 		BPF_LINE_INFO_ENC(2, 0, NAME_TBD, 2, 9),
+ 		BPF_LINE_INFO_ENC(5, 0, NAME_TBD, 3, 8),
+ 		BPF_LINE_INFO_ENC(7, 0, NAME_TBD, 4, 7),
+ 		BTF_END_RAW,
+ 	},
+ 	.line_info_rec_size = sizeof(struct bpf_line_info),
+ 	.nr_jited_ksyms = 2,
+ },
+ 
+ {
+ 	.descr = "line_info (subprog. missing 1st func line info)",
+ 	.raw_types = {
+ 		BTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),	/* [1] */
+ 		BTF_END_RAW,
+ 	},
+ 	BTF_STR_SEC("\0int\0int a=1+1;\0return func(a);\0b+=1;\0return b;"),
+ 	.insns = {
+ 		BPF_MOV64_IMM(BPF_REG_2, 1),
+ 		BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, 1),
+ 		BPF_MOV64_REG(BPF_REG_1, BPF_REG_2),
+ 		BPF_CALL_REL(1),
+ 		BPF_EXIT_INSN(),
+ 		BPF_MOV64_REG(BPF_REG_0, BPF_REG_1),
+ 		BPF_ALU64_IMM(BPF_ADD, BPF_REG_0, 1),
+ 		BPF_EXIT_INSN(),
+ 	},
+ 	.prog_type = BPF_PROG_TYPE_TRACEPOINT,
+ 	.func_info_cnt = 0,
+ 	.line_info = {
+ 		BPF_LINE_INFO_ENC(1, 0, NAME_TBD, 1, 10),
+ 		BPF_LINE_INFO_ENC(2, 0, NAME_TBD, 2, 9),
+ 		BPF_LINE_INFO_ENC(5, 0, NAME_TBD, 3, 8),
+ 		BPF_LINE_INFO_ENC(7, 0, NAME_TBD, 4, 7),
+ 		BTF_END_RAW,
+ 	},
+ 	.line_info_rec_size = sizeof(struct bpf_line_info),
+ 	.nr_jited_ksyms = 2,
+ 	.err_str = "missing bpf_line_info for func#0",
+ 	.expected_prog_load_failure = true,
+ },
+ 
+ {
+ 	.descr = "line_info (subprog. missing 2nd func line info)",
+ 	.raw_types = {
+ 		BTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),	/* [1] */
+ 		BTF_END_RAW,
+ 	},
+ 	BTF_STR_SEC("\0int\0int a=1+1;\0return func(a);\0b+=1;\0return b;"),
+ 	.insns = {
+ 		BPF_MOV64_IMM(BPF_REG_2, 1),
+ 		BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, 1),
+ 		BPF_MOV64_REG(BPF_REG_1, BPF_REG_2),
+ 		BPF_CALL_REL(1),
+ 		BPF_EXIT_INSN(),
+ 		BPF_MOV64_REG(BPF_REG_0, BPF_REG_1),
+ 		BPF_ALU64_IMM(BPF_ADD, BPF_REG_0, 1),
+ 		BPF_EXIT_INSN(),
+ 	},
+ 	.prog_type = BPF_PROG_TYPE_TRACEPOINT,
+ 	.func_info_cnt = 0,
+ 	.line_info = {
+ 		BPF_LINE_INFO_ENC(0, 0, NAME_TBD, 1, 10),
+ 		BPF_LINE_INFO_ENC(2, 0, NAME_TBD, 2, 9),
+ 		BPF_LINE_INFO_ENC(6, 0, NAME_TBD, 3, 8),
+ 		BPF_LINE_INFO_ENC(7, 0, NAME_TBD, 4, 7),
+ 		BTF_END_RAW,
+ 	},
+ 	.line_info_rec_size = sizeof(struct bpf_line_info),
+ 	.nr_jited_ksyms = 2,
+ 	.err_str = "missing bpf_line_info for func#1",
+ 	.expected_prog_load_failure = true,
+ },
+ 
+ {
+ 	.descr = "line_info (subprog. unordered insn offset)",
+ 	.raw_types = {
+ 		BTF_TYPE_INT_ENC(NAME_TBD, BTF_INT_SIGNED, 0, 32, 4),	/* [1] */
+ 		BTF_END_RAW,
+ 	},
+ 	BTF_STR_SEC("\0int\0int a=1+1;\0return func(a);\0b+=1;\0return b;"),
+ 	.insns = {
+ 		BPF_MOV64_IMM(BPF_REG_2, 1),
+ 		BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, 1),
+ 		BPF_MOV64_REG(BPF_REG_1, BPF_REG_2),
+ 		BPF_CALL_REL(1),
+ 		BPF_EXIT_INSN(),
+ 		BPF_MOV64_REG(BPF_REG_0, BPF_REG_1),
+ 		BPF_ALU64_IMM(BPF_ADD, BPF_REG_0, 1),
+ 		BPF_EXIT_INSN(),
+ 	},
+ 	.prog_type = BPF_PROG_TYPE_TRACEPOINT,
+ 	.func_info_cnt = 0,
+ 	.line_info = {
+ 		BPF_LINE_INFO_ENC(0, 0, NAME_TBD, 1, 10),
+ 		BPF_LINE_INFO_ENC(5, 0, NAME_TBD, 2, 9),
+ 		BPF_LINE_INFO_ENC(2, 0, NAME_TBD, 3, 8),
+ 		BPF_LINE_INFO_ENC(7, 0, NAME_TBD, 4, 7),
+ 		BTF_END_RAW,
+ 	},
+ 	.line_info_rec_size = sizeof(struct bpf_line_info),
+ 	.nr_jited_ksyms = 2,
+ 	.err_str = "Invalid line_info[2].insn_off",
++>>>>>>> e30f5640e324 (bpf: Add BPF_LD_IMM64 to the line_info test)
  	.expected_prog_load_failure = true,
  },
  
* Unmerged path tools/testing/selftests/bpf/test_btf.c
