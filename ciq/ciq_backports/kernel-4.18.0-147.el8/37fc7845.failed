drm/i915: Call MG_DP_MODE() macro with the right parameters order

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author José Roberto de Souza <jose.souza@intel.com>
commit 37fc7845df7b6ab9b2885b42e8de8ebcf33bee7a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/37fc7845.failed

The commit that this patch fixes changed the order of the parameters
of MG_DP_MODE() but din't update the callers, breaking type-c on ICL.

Fixes: 58106b7d816e ("drm/i915: Make MG PHY macros semantically consistent")
	Cc: Clint Taylor <clinton.a.taylor@intel.com>
	Cc: Imre Deak <imre.deak@intel.com>
	Cc: Jani Nikula <jani.nikula@linux.intel.com>
	Cc: Aditya Swarup <aditya.swarup@intel.com>
	Cc: Manasi navare <manasi.d.navare@intel.com>
	Cc: Jani Nikula <jani.nikula@intel.com>
	Signed-off-by: José Roberto de Souza <jose.souza@intel.com>
	Reviewed-by: Lucas De Marchi <lucas.demarchi@intel.com>
	Signed-off-by: Jani Nikula <jani.nikula@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190222202437.6575-1-jose.souza@intel.com
(cherry picked from commit 37fc7845df7b6ab9b2885b42e8de8ebcf33bee7a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_ddi.c
diff --cc drivers/gpu/drm/i915/intel_ddi.c
index fed26d6e4e27,1355be8dec3b..000000000000
--- a/drivers/gpu/drm/i915/intel_ddi.c
+++ b/drivers/gpu/drm/i915/intel_ddi.c
@@@ -2582,6 -2923,184 +2582,187 @@@ static void intel_ddi_clk_disable(struc
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void icl_enable_phy_clock_gating(struct intel_digital_port *dig_port)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(dig_port->base.base.dev);
+ 	enum port port = dig_port->base.port;
+ 	enum tc_port tc_port = intel_port_to_tc(dev_priv, port);
+ 	i915_reg_t mg_regs[2] = { MG_DP_MODE(0, port), MG_DP_MODE(1, port) };
+ 	u32 val;
+ 	int i;
+ 
+ 	if (tc_port == PORT_TC_NONE)
+ 		return;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(mg_regs); i++) {
+ 		val = I915_READ(mg_regs[i]);
+ 		val |= MG_DP_MODE_CFG_TR2PWR_GATING |
+ 		       MG_DP_MODE_CFG_TRPWR_GATING |
+ 		       MG_DP_MODE_CFG_CLNPWR_GATING |
+ 		       MG_DP_MODE_CFG_DIGPWR_GATING |
+ 		       MG_DP_MODE_CFG_GAONPWR_GATING;
+ 		I915_WRITE(mg_regs[i], val);
+ 	}
+ 
+ 	val = I915_READ(MG_MISC_SUS0(tc_port));
+ 	val |= MG_MISC_SUS0_SUSCLK_DYNCLKGATE_MODE(3) |
+ 	       MG_MISC_SUS0_CFG_TR2PWR_GATING |
+ 	       MG_MISC_SUS0_CFG_CL2PWR_GATING |
+ 	       MG_MISC_SUS0_CFG_GAONPWR_GATING |
+ 	       MG_MISC_SUS0_CFG_TRPWR_GATING |
+ 	       MG_MISC_SUS0_CFG_CL1PWR_GATING |
+ 	       MG_MISC_SUS0_CFG_DGPWR_GATING;
+ 	I915_WRITE(MG_MISC_SUS0(tc_port), val);
+ }
+ 
+ static void icl_disable_phy_clock_gating(struct intel_digital_port *dig_port)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(dig_port->base.base.dev);
+ 	enum port port = dig_port->base.port;
+ 	enum tc_port tc_port = intel_port_to_tc(dev_priv, port);
+ 	i915_reg_t mg_regs[2] = { MG_DP_MODE(port, 0), MG_DP_MODE(port, 1) };
+ 	u32 val;
+ 	int i;
+ 
+ 	if (tc_port == PORT_TC_NONE)
+ 		return;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(mg_regs); i++) {
+ 		val = I915_READ(mg_regs[i]);
+ 		val &= ~(MG_DP_MODE_CFG_TR2PWR_GATING |
+ 			 MG_DP_MODE_CFG_TRPWR_GATING |
+ 			 MG_DP_MODE_CFG_CLNPWR_GATING |
+ 			 MG_DP_MODE_CFG_DIGPWR_GATING |
+ 			 MG_DP_MODE_CFG_GAONPWR_GATING);
+ 		I915_WRITE(mg_regs[i], val);
+ 	}
+ 
+ 	val = I915_READ(MG_MISC_SUS0(tc_port));
+ 	val &= ~(MG_MISC_SUS0_SUSCLK_DYNCLKGATE_MODE_MASK |
+ 		 MG_MISC_SUS0_CFG_TR2PWR_GATING |
+ 		 MG_MISC_SUS0_CFG_CL2PWR_GATING |
+ 		 MG_MISC_SUS0_CFG_GAONPWR_GATING |
+ 		 MG_MISC_SUS0_CFG_TRPWR_GATING |
+ 		 MG_MISC_SUS0_CFG_CL1PWR_GATING |
+ 		 MG_MISC_SUS0_CFG_DGPWR_GATING);
+ 	I915_WRITE(MG_MISC_SUS0(tc_port), val);
+ }
+ 
+ static void icl_program_mg_dp_mode(struct intel_digital_port *intel_dig_port)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(intel_dig_port->base.base.dev);
+ 	enum port port = intel_dig_port->base.port;
+ 	enum tc_port tc_port = intel_port_to_tc(dev_priv, port);
+ 	u32 ln0, ln1, lane_info;
+ 
+ 	if (tc_port == PORT_TC_NONE || intel_dig_port->tc_type == TC_PORT_TBT)
+ 		return;
+ 
+ 	ln0 = I915_READ(MG_DP_MODE(0, port));
+ 	ln1 = I915_READ(MG_DP_MODE(1, port));
+ 
+ 	switch (intel_dig_port->tc_type) {
+ 	case TC_PORT_TYPEC:
+ 		ln0 &= ~(MG_DP_MODE_CFG_DP_X1_MODE | MG_DP_MODE_CFG_DP_X2_MODE);
+ 		ln1 &= ~(MG_DP_MODE_CFG_DP_X1_MODE | MG_DP_MODE_CFG_DP_X2_MODE);
+ 
+ 		lane_info = (I915_READ(PORT_TX_DFLEXDPSP) &
+ 			     DP_LANE_ASSIGNMENT_MASK(tc_port)) >>
+ 			    DP_LANE_ASSIGNMENT_SHIFT(tc_port);
+ 
+ 		switch (lane_info) {
+ 		case 0x1:
+ 		case 0x4:
+ 			break;
+ 		case 0x2:
+ 			ln0 |= MG_DP_MODE_CFG_DP_X1_MODE;
+ 			break;
+ 		case 0x3:
+ 			ln0 |= MG_DP_MODE_CFG_DP_X1_MODE |
+ 			       MG_DP_MODE_CFG_DP_X2_MODE;
+ 			break;
+ 		case 0x8:
+ 			ln1 |= MG_DP_MODE_CFG_DP_X1_MODE;
+ 			break;
+ 		case 0xC:
+ 			ln1 |= MG_DP_MODE_CFG_DP_X1_MODE |
+ 			       MG_DP_MODE_CFG_DP_X2_MODE;
+ 			break;
+ 		case 0xF:
+ 			ln0 |= MG_DP_MODE_CFG_DP_X1_MODE |
+ 			       MG_DP_MODE_CFG_DP_X2_MODE;
+ 			ln1 |= MG_DP_MODE_CFG_DP_X1_MODE |
+ 			       MG_DP_MODE_CFG_DP_X2_MODE;
+ 			break;
+ 		default:
+ 			MISSING_CASE(lane_info);
+ 		}
+ 		break;
+ 
+ 	case TC_PORT_LEGACY:
+ 		ln0 |= MG_DP_MODE_CFG_DP_X1_MODE | MG_DP_MODE_CFG_DP_X2_MODE;
+ 		ln1 |= MG_DP_MODE_CFG_DP_X1_MODE | MG_DP_MODE_CFG_DP_X2_MODE;
+ 		break;
+ 
+ 	default:
+ 		MISSING_CASE(intel_dig_port->tc_type);
+ 		return;
+ 	}
+ 
+ 	I915_WRITE(MG_DP_MODE(0, port), ln0);
+ 	I915_WRITE(MG_DP_MODE(1, port), ln1);
+ }
+ 
+ static void intel_dp_sink_set_fec_ready(struct intel_dp *intel_dp,
+ 					const struct intel_crtc_state *crtc_state)
+ {
+ 	if (!crtc_state->fec_enable)
+ 		return;
+ 
+ 	if (drm_dp_dpcd_writeb(&intel_dp->aux, DP_FEC_CONFIGURATION, DP_FEC_READY) <= 0)
+ 		DRM_DEBUG_KMS("Failed to set FEC_READY in the sink\n");
+ }
+ 
+ static void intel_ddi_enable_fec(struct intel_encoder *encoder,
+ 				 const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
+ 	enum port port = encoder->port;
+ 	u32 val;
+ 
+ 	if (!crtc_state->fec_enable)
+ 		return;
+ 
+ 	val = I915_READ(DP_TP_CTL(port));
+ 	val |= DP_TP_CTL_FEC_ENABLE;
+ 	I915_WRITE(DP_TP_CTL(port), val);
+ 
+ 	if (intel_wait_for_register(dev_priv, DP_TP_STATUS(port),
+ 				    DP_TP_STATUS_FEC_ENABLE_LIVE,
+ 				    DP_TP_STATUS_FEC_ENABLE_LIVE,
+ 				    1))
+ 		DRM_ERROR("Timed out waiting for FEC Enable Status\n");
+ }
+ 
+ static void intel_ddi_disable_fec_state(struct intel_encoder *encoder,
+ 					const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
+ 	enum port port = encoder->port;
+ 	u32 val;
+ 
+ 	if (!crtc_state->fec_enable)
+ 		return;
+ 
+ 	val = I915_READ(DP_TP_CTL(port));
+ 	val &= ~DP_TP_CTL_FEC_ENABLE;
+ 	I915_WRITE(DP_TP_CTL(port), val);
+ 	POSTING_READ(DP_TP_CTL(port));
+ }
+ 
++>>>>>>> 37fc7845df7b (drm/i915: Call MG_DP_MODE() macro with the right parameters order)
  static void intel_ddi_pre_enable_dp(struct intel_encoder *encoder,
  				    const struct intel_crtc_state *crtc_state,
  				    const struct drm_connector_state *conn_state)
* Unmerged path drivers/gpu/drm/i915/intel_ddi.c
