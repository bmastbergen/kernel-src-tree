ice: Refactor getting/setting coalesce

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Brett Creeley <brett.creeley@intel.com>
commit e40c899a64ca6222ea45a045b2d7a09491274163
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/e40c899a.failed

Currently if the driver has an uneven amount of Rx/Tx queues
setting the coalesce settings through ethtool will result in
an error. This is happening because in the setting coalesce
flow we are reporting an error if either Rx or Tx fails.

Also, the flow for setting/getting per_q_coalesce and
setting/getting coalesce settings for the entire device
is different.

Fix these issues by adding one function, ice_set_q_coalesce(),
and another, ice_get_q_coalesce(), that both getting/setting
per_q and entire device coalesce can use. This makes handling
the error cases generic between the two flows and simplifies
__ice_set_coalesce() and __ice_get_coalesce().

Also, add a header comment to __ice_set_coalesce().

	Signed-off-by: Brett Creeley <brett.creeley@intel.com>
	Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit e40c899a64ca6222ea45a045b2d7a09491274163)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_ethtool.c
diff --cc drivers/net/ethernet/intel/ice/ice_ethtool.c
index 93176df70fc9,08ec2f3c5977..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_ethtool.c
+++ b/drivers/net/ethernet/intel/ice/ice_ethtool.c
@@@ -2173,6 -2208,323 +2173,326 @@@ static int ice_set_rxfh(struct net_devi
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ enum ice_container_type {
+ 	ICE_RX_CONTAINER,
+ 	ICE_TX_CONTAINER,
+ };
+ 
+ /**
+  * ice_get_rc_coalesce - get ITR values for specific ring container
+  * @ec: ethtool structure to fill with driver's coalesce settings
+  * @c_type: container type, Rx or Tx
+  * @rc: ring container that the ITR values will come from
+  *
+  * Query the device for ice_ring_container specific ITR values. This is
+  * done per ice_ring_container because each q_vector can have 1 or more rings
+  * and all of said ring(s) will have the same ITR values.
+  *
+  * Returns 0 on success, negative otherwise.
+  */
+ static int
+ ice_get_rc_coalesce(struct ethtool_coalesce *ec, enum ice_container_type c_type,
+ 		    struct ice_ring_container *rc)
+ {
+ 	struct ice_pf *pf;
+ 
+ 	if (!rc->ring)
+ 		return -EINVAL;
+ 
+ 	pf = rc->ring->vsi->back;
+ 
+ 	switch (c_type) {
+ 	case ICE_RX_CONTAINER:
+ 		ec->use_adaptive_rx_coalesce = ITR_IS_DYNAMIC(rc->itr_setting);
+ 		ec->rx_coalesce_usecs = rc->itr_setting & ~ICE_ITR_DYNAMIC;
+ 		ec->rx_coalesce_usecs_high = rc->ring->q_vector->intrl;
+ 		break;
+ 	case ICE_TX_CONTAINER:
+ 		ec->use_adaptive_tx_coalesce = ITR_IS_DYNAMIC(rc->itr_setting);
+ 		ec->tx_coalesce_usecs = rc->itr_setting & ~ICE_ITR_DYNAMIC;
+ 		break;
+ 	default:
+ 		dev_dbg(&pf->pdev->dev, "Invalid c_type %d\n", c_type);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_get_q_coalesce - get a queue's ITR/INTRL (coalesce) settings
+  * @vsi: VSI associated to the queue for getting ITR/INTRL (coalesce) settings
+  * @ec: coalesce settings to program the device with
+  * @q_num: update ITR/INTRL (coalesce) settings for this queue number/index
+  *
+  * Return 0 on success, and negative under the following conditions:
+  * 1. Getting Tx or Rx ITR/INTRL (coalesce) settings failed.
+  * 2. The q_num passed in is not a valid number/index for Tx and Rx rings.
+  */
+ static int
+ ice_get_q_coalesce(struct ice_vsi *vsi, struct ethtool_coalesce *ec, int q_num)
+ {
+ 	if (q_num < vsi->num_rxq && q_num < vsi->num_txq) {
+ 		if (ice_get_rc_coalesce(ec, ICE_RX_CONTAINER,
+ 					&vsi->rx_rings[q_num]->q_vector->rx))
+ 			return -EINVAL;
+ 		if (ice_get_rc_coalesce(ec, ICE_TX_CONTAINER,
+ 					&vsi->tx_rings[q_num]->q_vector->tx))
+ 			return -EINVAL;
+ 	} else if (q_num < vsi->num_rxq) {
+ 		if (ice_get_rc_coalesce(ec, ICE_RX_CONTAINER,
+ 					&vsi->rx_rings[q_num]->q_vector->rx))
+ 			return -EINVAL;
+ 	} else if (q_num < vsi->num_txq) {
+ 		if (ice_get_rc_coalesce(ec, ICE_TX_CONTAINER,
+ 					&vsi->tx_rings[q_num]->q_vector->tx))
+ 			return -EINVAL;
+ 	} else {
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * __ice_get_coalesce - get ITR/INTRL values for the device
+  * @netdev: pointer to the netdev associated with this query
+  * @ec: ethtool structure to fill with driver's coalesce settings
+  * @q_num: queue number to get the coalesce settings for
+  *
+  * If the caller passes in a negative q_num then we return coalesce settings
+  * based on queue number 0, else use the actual q_num passed in.
+  */
+ static int
+ __ice_get_coalesce(struct net_device *netdev, struct ethtool_coalesce *ec,
+ 		   int q_num)
+ {
+ 	struct ice_netdev_priv *np = netdev_priv(netdev);
+ 	struct ice_vsi *vsi = np->vsi;
+ 
+ 	if (q_num < 0)
+ 		q_num = 0;
+ 
+ 	if (ice_get_q_coalesce(vsi, ec, q_num))
+ 		return -EINVAL;
+ 
+ 	if (q_num < vsi->num_txq)
+ 		ec->tx_max_coalesced_frames_irq = vsi->work_lmt;
+ 
+ 	if (q_num < vsi->num_rxq)
+ 		ec->rx_max_coalesced_frames_irq = vsi->work_lmt;
+ 
+ 	return 0;
+ }
+ 
+ static int
+ ice_get_coalesce(struct net_device *netdev, struct ethtool_coalesce *ec)
+ {
+ 	return __ice_get_coalesce(netdev, ec, -1);
+ }
+ 
+ static int
+ ice_get_per_q_coalesce(struct net_device *netdev, u32 q_num,
+ 		       struct ethtool_coalesce *ec)
+ {
+ 	return __ice_get_coalesce(netdev, ec, q_num);
+ }
+ 
+ /**
+  * ice_set_rc_coalesce - set ITR values for specific ring container
+  * @c_type: container type, Rx or Tx
+  * @ec: ethtool structure from user to update ITR settings
+  * @rc: ring container that the ITR values will come from
+  * @vsi: VSI associated to the ring container
+  *
+  * Set specific ITR values. This is done per ice_ring_container because each
+  * q_vector can have 1 or more rings and all of said ring(s) will have the same
+  * ITR values.
+  *
+  * Returns 0 on success, negative otherwise.
+  */
+ static int
+ ice_set_rc_coalesce(enum ice_container_type c_type, struct ethtool_coalesce *ec,
+ 		    struct ice_ring_container *rc, struct ice_vsi *vsi)
+ {
+ 	struct ice_pf *pf = vsi->back;
+ 	u16 itr_setting;
+ 
+ 	if (!rc->ring)
+ 		return -EINVAL;
+ 
+ 	itr_setting = rc->itr_setting & ~ICE_ITR_DYNAMIC;
+ 
+ 	switch (c_type) {
+ 	case ICE_RX_CONTAINER:
+ 		if (ec->rx_coalesce_usecs_high > ICE_MAX_INTRL ||
+ 		    (ec->rx_coalesce_usecs_high &&
+ 		     ec->rx_coalesce_usecs_high < pf->hw.intrl_gran)) {
+ 			netdev_info(vsi->netdev,
+ 				    "Invalid value, rx-usecs-high valid values are 0 (disabled), %d-%d\n",
+ 				    pf->hw.intrl_gran, ICE_MAX_INTRL);
+ 			return -EINVAL;
+ 		}
+ 
+ 		if (ec->rx_coalesce_usecs_high != rc->ring->q_vector->intrl) {
+ 			rc->ring->q_vector->intrl = ec->rx_coalesce_usecs_high;
+ 			wr32(&pf->hw, GLINT_RATE(vsi->hw_base_vector +
+ 						 rc->ring->q_vector->v_idx),
+ 			     ice_intrl_usec_to_reg(ec->rx_coalesce_usecs_high,
+ 						   pf->hw.intrl_gran));
+ 		}
+ 
+ 		if (ec->rx_coalesce_usecs != itr_setting &&
+ 		    ec->use_adaptive_rx_coalesce) {
+ 			netdev_info(vsi->netdev,
+ 				    "Rx interrupt throttling cannot be changed if adaptive-rx is enabled\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		if (ec->rx_coalesce_usecs > ICE_ITR_MAX) {
+ 			netdev_info(vsi->netdev,
+ 				    "Invalid value, rx-usecs range is 0-%d\n",
+ 				   ICE_ITR_MAX);
+ 			return -EINVAL;
+ 		}
+ 
+ 		if (ec->use_adaptive_rx_coalesce) {
+ 			rc->itr_setting |= ICE_ITR_DYNAMIC;
+ 		} else {
+ 			rc->itr_setting = ITR_REG_ALIGN(ec->rx_coalesce_usecs);
+ 			rc->target_itr = ITR_TO_REG(rc->itr_setting);
+ 		}
+ 		break;
+ 	case ICE_TX_CONTAINER:
+ 		if (ec->tx_coalesce_usecs_high) {
+ 			netdev_info(vsi->netdev,
+ 				    "setting tx-usecs-high is not supported\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		if (ec->tx_coalesce_usecs != itr_setting &&
+ 		    ec->use_adaptive_tx_coalesce) {
+ 			netdev_info(vsi->netdev,
+ 				    "Tx interrupt throttling cannot be changed if adaptive-tx is enabled\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		if (ec->tx_coalesce_usecs > ICE_ITR_MAX) {
+ 			netdev_info(vsi->netdev,
+ 				    "Invalid value, tx-usecs range is 0-%d\n",
+ 				   ICE_ITR_MAX);
+ 			return -EINVAL;
+ 		}
+ 
+ 		if (ec->use_adaptive_tx_coalesce) {
+ 			rc->itr_setting |= ICE_ITR_DYNAMIC;
+ 		} else {
+ 			rc->itr_setting = ITR_REG_ALIGN(ec->tx_coalesce_usecs);
+ 			rc->target_itr = ITR_TO_REG(rc->itr_setting);
+ 		}
+ 		break;
+ 	default:
+ 		dev_dbg(&pf->pdev->dev, "Invalid container type %d\n", c_type);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_set_q_coalesce - set a queue's ITR/INTRL (coalesce) settings
+  * @vsi: VSI associated to the queue that need updating
+  * @ec: coalesce settings to program the device with
+  * @q_num: update ITR/INTRL (coalesce) settings for this queue number/index
+  *
+  * Return 0 on success, and negative under the following conditions:
+  * 1. Setting Tx or Rx ITR/INTRL (coalesce) settings failed.
+  * 2. The q_num passed in is not a valid number/index for Tx and Rx rings.
+  */
+ static int
+ ice_set_q_coalesce(struct ice_vsi *vsi, struct ethtool_coalesce *ec, int q_num)
+ {
+ 	if (q_num < vsi->num_rxq && q_num < vsi->num_txq) {
+ 		if (ice_set_rc_coalesce(ICE_RX_CONTAINER, ec,
+ 					&vsi->rx_rings[q_num]->q_vector->rx,
+ 					vsi))
+ 			return -EINVAL;
+ 
+ 		if (ice_set_rc_coalesce(ICE_TX_CONTAINER, ec,
+ 					&vsi->tx_rings[q_num]->q_vector->tx,
+ 					vsi))
+ 			return -EINVAL;
+ 	} else if (q_num < vsi->num_rxq) {
+ 		if (ice_set_rc_coalesce(ICE_RX_CONTAINER, ec,
+ 					&vsi->rx_rings[q_num]->q_vector->rx,
+ 					vsi))
+ 			return -EINVAL;
+ 	} else if (q_num < vsi->num_txq) {
+ 		if (ice_set_rc_coalesce(ICE_TX_CONTAINER, ec,
+ 					&vsi->tx_rings[q_num]->q_vector->tx,
+ 					vsi))
+ 			return -EINVAL;
+ 	} else {
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * __ice_set_coalesce - set ITR/INTRL values for the device
+  * @netdev: pointer to the netdev associated with this query
+  * @ec: ethtool structure to fill with driver's coalesce settings
+  * @q_num: queue number to get the coalesce settings for
+  *
+  * If the caller passes in a negative q_num then we set the coalesce settings
+  * for all Tx/Rx queues, else use the actual q_num passed in.
+  */
+ static int
+ __ice_set_coalesce(struct net_device *netdev, struct ethtool_coalesce *ec,
+ 		   int q_num)
+ {
+ 	struct ice_netdev_priv *np = netdev_priv(netdev);
+ 	struct ice_vsi *vsi = np->vsi;
+ 
+ 	if (q_num < 0) {
+ 		int i;
+ 
+ 		ice_for_each_q_vector(vsi, i) {
+ 			if (ice_set_q_coalesce(vsi, ec, i))
+ 				return -EINVAL;
+ 		}
+ 		goto set_work_lmt;
+ 	}
+ 
+ 	if (ice_set_q_coalesce(vsi, ec, q_num))
+ 		return -EINVAL;
+ 
+ set_work_lmt:
+ 
+ 	if (ec->tx_max_coalesced_frames_irq || ec->rx_max_coalesced_frames_irq)
+ 		vsi->work_lmt = max(ec->tx_max_coalesced_frames_irq,
+ 				    ec->rx_max_coalesced_frames_irq);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ ice_set_coalesce(struct net_device *netdev, struct ethtool_coalesce *ec)
+ {
+ 	return __ice_set_coalesce(netdev, ec, -1);
+ }
+ 
+ static int
+ ice_set_per_q_coalesce(struct net_device *netdev, u32 q_num,
+ 		       struct ethtool_coalesce *ec)
+ {
+ 	return __ice_set_coalesce(netdev, ec, q_num);
+ }
+ 
++>>>>>>> e40c899a64ca (ice: Refactor getting/setting coalesce)
  static const struct ethtool_ops ice_ethtool_ops = {
  	.get_link_ksettings	= ice_get_link_ksettings,
  	.set_link_ksettings	= ice_set_link_ksettings,
* Unmerged path drivers/net/ethernet/intel/ice/ice_ethtool.c
