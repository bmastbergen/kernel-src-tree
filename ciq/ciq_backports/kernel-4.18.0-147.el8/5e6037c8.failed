drm/i915: Move some variables to tighter scope

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit 5e6037c88ad5f052e317a56cff54df40b7e82e5f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/5e6037c8.failed

Clean up skl_allocate_pipe_ddb() a bit by moving the 'wm' variable
to tighter scope. We'll also consitify it where appropriate.

Also initialize plane_alloc/uv_plane_alloc when decrlaring them
rather than later.

v2: Update commit message (Matt)

	Cc: Neel Desai <neel.desai@intel.com>
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190312205844.6339-8-ville.syrjala@linux.intel.com
	Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
(cherry picked from commit 5e6037c88ad5f052e317a56cff54df40b7e82e5f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_pm.c
diff --cc drivers/gpu/drm/i915/intel_pm.c
index a1b763e0c3a9,0b3e29eb0701..000000000000
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@@ -4282,23 -4341,23 +4282,30 @@@ skl_allocate_pipe_ddb(struct intel_crtc
  {
  	struct drm_atomic_state *state = cstate->base.state;
  	struct drm_crtc *crtc = cstate->base.crtc;
 -	struct drm_i915_private *dev_priv = to_i915(crtc->dev);
 +	struct drm_device *dev = crtc->dev;
  	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
 +	enum pipe pipe = intel_crtc->pipe;
  	struct skl_ddb_entry *alloc = &cstate->wm.skl.ddb;
++<<<<<<< HEAD
 +	uint16_t alloc_size, start;
 +	uint16_t minimum[I915_MAX_PLANES] = {};
 +	uint16_t uv_minimum[I915_MAX_PLANES] = {};
 +	unsigned int total_data_rate;
++=======
+ 	u16 alloc_size, start = 0;
+ 	u16 total[I915_MAX_PLANES] = {};
+ 	u16 uv_total[I915_MAX_PLANES] = {};
+ 	u64 total_data_rate;
++>>>>>>> 5e6037c88ad5 (drm/i915: Move some variables to tighter scope)
  	enum plane_id plane_id;
  	int num_active;
 -	u64 plane_data_rate[I915_MAX_PLANES] = {};
 -	u64 uv_plane_data_rate[I915_MAX_PLANES] = {};
 -	u32 blocks;
 -	int level;
 +	unsigned int plane_data_rate[I915_MAX_PLANES] = {};
 +	unsigned int uv_plane_data_rate[I915_MAX_PLANES] = {};
 +	uint16_t total_min_blocks = 0;
  
  	/* Clear the partitioning for disabled planes. */
 -	memset(cstate->wm.skl.plane_ddb_y, 0, sizeof(cstate->wm.skl.plane_ddb_y));
 -	memset(cstate->wm.skl.plane_ddb_uv, 0, sizeof(cstate->wm.skl.plane_ddb_uv));
 +	memset(ddb->plane[pipe], 0, sizeof(ddb->plane[pipe]));
 +	memset(ddb->uv_plane[pipe], 0, sizeof(ddb->uv_plane[pipe]));
  
  	if (WARN_ON(!state))
  		return 0;
@@@ -4317,80 -4383,172 +4324,193 @@@
  	if (alloc_size == 0)
  		return 0;
  
 -	/* Allocate fixed number of blocks for cursor. */
 -	total[PLANE_CURSOR] = skl_cursor_allocation(cstate, num_active);
 -	alloc_size -= total[PLANE_CURSOR];
 -	cstate->wm.skl.plane_ddb_y[PLANE_CURSOR].start =
 -		alloc->end - total[PLANE_CURSOR];
 -	cstate->wm.skl.plane_ddb_y[PLANE_CURSOR].end = alloc->end;
 -
 -	if (total_data_rate == 0)
 -		return 0;
 +	skl_ddb_calc_min(cstate, num_active, minimum, uv_minimum);
  
  	/*
 -	 * Find the highest watermark level for which we can satisfy the block
 -	 * requirement of active planes.
 +	 * 1. Allocate the mininum required blocks for each active plane
 +	 * and allocate the cursor, it doesn't require extra allocation
 +	 * proportional to the data rate.
  	 */
++<<<<<<< HEAD
++=======
+ 	for (level = ilk_wm_max_level(dev_priv); level >= 0; level--) {
+ 		blocks = 0;
+ 		for_each_plane_id_on_crtc(intel_crtc, plane_id) {
+ 			const struct skl_plane_wm *wm =
+ 				&cstate->wm.skl.optimal.planes[plane_id];
++>>>>>>> 5e6037c88ad5 (drm/i915: Move some variables to tighter scope)
  
 -			if (plane_id == PLANE_CURSOR) {
 -				if (WARN_ON(wm->wm[level].min_ddb_alloc >
 -					    total[PLANE_CURSOR])) {
 -					blocks = U32_MAX;
 -					break;
 -				}
 -				continue;
 -			}
 -
 -			blocks += wm->wm[level].min_ddb_alloc;
 -			blocks += wm->uv_wm[level].min_ddb_alloc;
 -		}
 -
 -		if (blocks <= alloc_size) {
 -			alloc_size -= blocks;
 -			break;
 -		}
 +	for_each_plane_id_on_crtc(intel_crtc, plane_id) {
 +		total_min_blocks += minimum[plane_id];
 +		total_min_blocks += uv_minimum[plane_id];
  	}
  
 -	if (level < 0) {
 +	if (total_min_blocks > alloc_size) {
  		DRM_DEBUG_KMS("Requested display configuration exceeds system DDB limitations");
 -		DRM_DEBUG_KMS("minimum required %d/%d\n", blocks,
 -			      alloc_size);
 +		DRM_DEBUG_KMS("minimum required %d/%d\n", total_min_blocks,
 +							alloc_size);
  		return -EINVAL;
  	}
  
 +	alloc_size -= total_min_blocks;
 +	ddb->plane[pipe][PLANE_CURSOR].start = alloc->end - minimum[PLANE_CURSOR];
 +	ddb->plane[pipe][PLANE_CURSOR].end = alloc->end;
 +
  	/*
 -	 * Grant each plane the blocks it requires at the highest achievable
 -	 * watermark level, plus an extra share of the leftover blocks
 -	 * proportional to its relative data rate.
 +	 * 2. Distribute the remaining space in proportion to the amount of
 +	 * data each plane needs to fetch from memory.
 +	 *
 +	 * FIXME: we may not allocate every single block here.
  	 */
++<<<<<<< HEAD
 +	if (total_data_rate == 0)
 +		return 0;
 +
 +	start = alloc->start;
 +	for_each_plane_id_on_crtc(intel_crtc, plane_id) {
 +		unsigned int data_rate, uv_data_rate;
 +		uint16_t plane_blocks, uv_plane_blocks;
++=======
+ 	for_each_plane_id_on_crtc(intel_crtc, plane_id) {
+ 		const struct skl_plane_wm *wm =
+ 			&cstate->wm.skl.optimal.planes[plane_id];
+ 		u64 rate;
+ 		u16 extra;
  
  		if (plane_id == PLANE_CURSOR)
  			continue;
  
+ 		/*
+ 		 * We've accounted for all active planes; remaining planes are
+ 		 * all disabled.
+ 		 */
+ 		if (total_data_rate == 0)
+ 			break;
+ 
+ 		rate = plane_data_rate[plane_id];
+ 		extra = min_t(u16, alloc_size,
+ 			      DIV64_U64_ROUND_UP(alloc_size * rate,
+ 						 total_data_rate));
+ 		total[plane_id] = wm->wm[level].min_ddb_alloc + extra;
+ 		alloc_size -= extra;
+ 		total_data_rate -= rate;
+ 
+ 		if (total_data_rate == 0)
+ 			break;
+ 
+ 		rate = uv_plane_data_rate[plane_id];
+ 		extra = min_t(u16, alloc_size,
+ 			      DIV64_U64_ROUND_UP(alloc_size * rate,
+ 						 total_data_rate));
+ 		uv_total[plane_id] = wm->uv_wm[level].min_ddb_alloc + extra;
+ 		alloc_size -= extra;
+ 		total_data_rate -= rate;
+ 	}
+ 	WARN_ON(alloc_size != 0 || total_data_rate != 0);
+ 
+ 	/* Set the actual DDB start/end points for each plane */
+ 	start = alloc->start;
+ 	for_each_plane_id_on_crtc(intel_crtc, plane_id) {
+ 		struct skl_ddb_entry *plane_alloc =
+ 			&cstate->wm.skl.plane_ddb_y[plane_id];
+ 		struct skl_ddb_entry *uv_plane_alloc =
+ 			&cstate->wm.skl.plane_ddb_uv[plane_id];
++>>>>>>> 5e6037c88ad5 (drm/i915: Move some variables to tighter scope)
+ 
+ 		if (plane_id == PLANE_CURSOR)
+ 			continue;
+ 
++<<<<<<< HEAD
 +		data_rate = plane_data_rate[plane_id];
 +
 +		/*
 +		 * allocation for (packed formats) or (uv-plane part of planar format):
 +		 * promote the expression to 64 bits to avoid overflowing, the
 +		 * result is < available as data_rate / total_data_rate < 1
 +		 */
 +		plane_blocks = minimum[plane_id];
 +		plane_blocks += div_u64((uint64_t)alloc_size * data_rate,
 +					total_data_rate);
++=======
+ 		/* Gen11+ uses a separate plane for UV watermarks */
+ 		WARN_ON(INTEL_GEN(dev_priv) >= 11 && uv_total[plane_id]);
++>>>>>>> 5e6037c88ad5 (drm/i915: Move some variables to tighter scope)
  
  		/* Leave disabled planes at (0,0) */
 -		if (total[plane_id]) {
 -			plane_alloc->start = start;
 -			start += total[plane_id];
 -			plane_alloc->end = start;
 +		if (data_rate) {
 +			ddb->plane[pipe][plane_id].start = start;
 +			ddb->plane[pipe][plane_id].end = start + plane_blocks;
  		}
  
 -		if (uv_total[plane_id]) {
 -			uv_plane_alloc->start = start;
 -			start += uv_total[plane_id];
 -			uv_plane_alloc->end = start;
 +		start += plane_blocks;
 +
 +		/* Allocate DDB for UV plane for planar format/NV12 */
 +		uv_data_rate = uv_plane_data_rate[plane_id];
 +
 +		uv_plane_blocks = uv_minimum[plane_id];
 +		uv_plane_blocks += div_u64((uint64_t)alloc_size * uv_data_rate,
 +					   total_data_rate);
 +
 +		if (uv_data_rate) {
 +			ddb->uv_plane[pipe][plane_id].start = start;
 +			ddb->uv_plane[pipe][plane_id].end =
 +				start + uv_plane_blocks;
  		}
 -	}
  
++<<<<<<< HEAD
 +		start += uv_plane_blocks;
++=======
+ 	/*
+ 	 * When we calculated watermark values we didn't know how high
+ 	 * of a level we'd actually be able to hit, so we just marked
+ 	 * all levels as "enabled."  Go back now and disable the ones
+ 	 * that aren't actually possible.
+ 	 */
+ 	for (level++; level <= ilk_wm_max_level(dev_priv); level++) {
+ 		for_each_plane_id_on_crtc(intel_crtc, plane_id) {
+ 			struct skl_plane_wm *wm =
+ 				&cstate->wm.skl.optimal.planes[plane_id];
+ 
+ 			/*
+ 			 * We only disable the watermarks for each plane if
+ 			 * they exceed the ddb allocation of said plane. This
+ 			 * is done so that we don't end up touching cursor
+ 			 * watermarks needlessly when some other plane reduces
+ 			 * our max possible watermark level.
+ 			 *
+ 			 * Bspec has this to say about the PLANE_WM enable bit:
+ 			 * "All the watermarks at this level for all enabled
+ 			 *  planes must be enabled before the level will be used."
+ 			 * So this is actually safe to do.
+ 			 */
+ 			if (wm->wm[level].min_ddb_alloc > total[plane_id] ||
+ 			    wm->uv_wm[level].min_ddb_alloc > uv_total[plane_id])
+ 				memset(&wm->wm[level], 0, sizeof(wm->wm[level]));
+ 
+ 			/*
+ 			 * Wa_1408961008:icl
+ 			 * Underruns with WM1+ disabled
+ 			 */
+ 			if (IS_ICELAKE(dev_priv) &&
+ 			    level == 1 && wm->wm[0].plane_en) {
+ 				wm->wm[level].plane_res_b = wm->wm[0].plane_res_b;
+ 				wm->wm[level].plane_res_l = wm->wm[0].plane_res_l;
+ 				wm->wm[level].ignore_lines = wm->wm[0].ignore_lines;
+ 			}
+ 		}
+ 	}
+ 
+ 	/*
+ 	 * Go back and disable the transition watermark if it turns out we
+ 	 * don't have enough DDB blocks for it.
+ 	 */
+ 	for_each_plane_id_on_crtc(intel_crtc, plane_id) {
+ 		struct skl_plane_wm *wm =
+ 			&cstate->wm.skl.optimal.planes[plane_id];
+ 
+ 		if (wm->trans_wm.plane_res_b >= total[plane_id])
+ 			memset(&wm->trans_wm, 0, sizeof(wm->trans_wm));
++>>>>>>> 5e6037c88ad5 (drm/i915: Move some variables to tighter scope)
  	}
  
  	return 0;
* Unmerged path drivers/gpu/drm/i915/intel_pm.c
