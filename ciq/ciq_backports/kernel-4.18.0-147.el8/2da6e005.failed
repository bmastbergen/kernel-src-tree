nvmet: add error log support for admin-cmd

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Chaitanya Kulkarni <chaitanya.kulkarni@wdc.com>
commit 2da6e00580f5bc13ed0ba0acaa9d7ce0df226e7e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/2da6e005.failed

This patch adds the support to maintain the error log page for admin
commands.

	Signed-off-by: Chaitanya Kulkarni <chaitanya.kulkarni@wdc.com>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 2da6e00580f5bc13ed0ba0acaa9d7ce0df226e7e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/target/admin-cmd.c
diff --cc drivers/nvme/target/admin-cmd.c
index 34c4ad15edb3,fa62db7a5e9e..000000000000
--- a/drivers/nvme/target/admin-cmd.c
+++ b/drivers/nvme/target/admin-cmd.c
@@@ -455,6 -544,80 +458,83 @@@ static void nvmet_execute_abort(struct 
  	nvmet_req_complete(req, 0);
  }
  
++<<<<<<< HEAD
++=======
+ static u16 nvmet_write_protect_flush_sync(struct nvmet_req *req)
+ {
+ 	u16 status;
+ 
+ 	if (req->ns->file)
+ 		status = nvmet_file_flush(req);
+ 	else
+ 		status = nvmet_bdev_flush(req);
+ 
+ 	if (status)
+ 		pr_err("write protect flush failed nsid: %u\n", req->ns->nsid);
+ 	return status;
+ }
+ 
+ static u16 nvmet_set_feat_write_protect(struct nvmet_req *req)
+ {
+ 	u32 write_protect = le32_to_cpu(req->cmd->common.cdw11);
+ 	struct nvmet_subsys *subsys = req->sq->ctrl->subsys;
+ 	u16 status = NVME_SC_FEATURE_NOT_CHANGEABLE;
+ 
+ 	req->ns = nvmet_find_namespace(req->sq->ctrl, req->cmd->rw.nsid);
+ 	if (unlikely(!req->ns)) {
+ 		req->error_loc = offsetof(struct nvme_common_command, nsid);
+ 		return status;
+ 	}
+ 
+ 	mutex_lock(&subsys->lock);
+ 	switch (write_protect) {
+ 	case NVME_NS_WRITE_PROTECT:
+ 		req->ns->readonly = true;
+ 		status = nvmet_write_protect_flush_sync(req);
+ 		if (status)
+ 			req->ns->readonly = false;
+ 		break;
+ 	case NVME_NS_NO_WRITE_PROTECT:
+ 		req->ns->readonly = false;
+ 		status = 0;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	if (!status)
+ 		nvmet_ns_changed(subsys, req->ns->nsid);
+ 	mutex_unlock(&subsys->lock);
+ 	return status;
+ }
+ 
+ u16 nvmet_set_feat_kato(struct nvmet_req *req)
+ {
+ 	u32 val32 = le32_to_cpu(req->cmd->common.cdw11);
+ 
+ 	req->sq->ctrl->kato = DIV_ROUND_UP(val32, 1000);
+ 
+ 	nvmet_set_result(req, req->sq->ctrl->kato);
+ 
+ 	return 0;
+ }
+ 
+ u16 nvmet_set_feat_async_event(struct nvmet_req *req, u32 mask)
+ {
+ 	u32 val32 = le32_to_cpu(req->cmd->common.cdw11);
+ 
+ 	if (val32 & ~mask) {
+ 		req->error_loc = offsetof(struct nvme_common_command, cdw11);
+ 		return NVME_SC_INVALID_FIELD | NVME_SC_DNR;
+ 	}
+ 
+ 	WRITE_ONCE(req->sq->ctrl->aen_enabled, val32);
+ 	nvmet_set_result(req, val32);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 2da6e00580f5 (nvmet: add error log support for admin-cmd)
  static void nvmet_execute_set_features(struct nvmet_req *req)
  {
  	struct nvmet_subsys *subsys = req->sq->ctrl->subsys;
@@@ -485,7 -638,11 +565,8 @@@
  	case NVME_FEAT_HOST_ID:
  		status = NVME_SC_CMD_SEQ_ERROR | NVME_SC_DNR;
  		break;
 -	case NVME_FEAT_WRITE_PROTECT:
 -		status = nvmet_set_feat_write_protect(req);
 -		break;
  	default:
+ 		req->error_loc = offsetof(struct nvme_common_command, cdw10);
  		status = NVME_SC_INVALID_FIELD | NVME_SC_DNR;
  		break;
  	}
@@@ -493,6 -650,37 +574,40 @@@
  	nvmet_req_complete(req, status);
  }
  
++<<<<<<< HEAD
++=======
+ static u16 nvmet_get_feat_write_protect(struct nvmet_req *req)
+ {
+ 	struct nvmet_subsys *subsys = req->sq->ctrl->subsys;
+ 	u32 result;
+ 
+ 	req->ns = nvmet_find_namespace(req->sq->ctrl, req->cmd->common.nsid);
+ 	if (!req->ns)  {
+ 		req->error_loc = offsetof(struct nvme_common_command, nsid);
+ 		return NVME_SC_INVALID_NS | NVME_SC_DNR;
+ 	}
+ 	mutex_lock(&subsys->lock);
+ 	if (req->ns->readonly == true)
+ 		result = NVME_NS_WRITE_PROTECT;
+ 	else
+ 		result = NVME_NS_NO_WRITE_PROTECT;
+ 	nvmet_set_result(req, result);
+ 	mutex_unlock(&subsys->lock);
+ 
+ 	return 0;
+ }
+ 
+ void nvmet_get_feat_kato(struct nvmet_req *req)
+ {
+ 	nvmet_set_result(req, req->sq->ctrl->kato * 1000);
+ }
+ 
+ void nvmet_get_feat_async_event(struct nvmet_req *req)
+ {
+ 	nvmet_set_result(req, READ_ONCE(req->sq->ctrl->aen_enabled));
+ }
+ 
++>>>>>>> 2da6e00580f5 (nvmet: add error log support for admin-cmd)
  static void nvmet_execute_get_features(struct nvmet_req *req)
  {
  	struct nvmet_subsys *subsys = req->sq->ctrl->subsys;
@@@ -536,7 -724,9 +651,13 @@@
  		break;
  	case NVME_FEAT_HOST_ID:
  		/* need 128-bit host identifier flag */
++<<<<<<< HEAD
 +		if (!(req->cmd->common.cdw10[1] & cpu_to_le32(1 << 0))) {
++=======
+ 		if (!(req->cmd->common.cdw11 & cpu_to_le32(1 << 0))) {
+ 			req->error_loc =
+ 				offsetof(struct nvme_common_command, cdw11);
++>>>>>>> 2da6e00580f5 (nvmet: add error log support for admin-cmd)
  			status = NVME_SC_INVALID_FIELD | NVME_SC_DNR;
  			break;
  		}
@@@ -544,7 -734,12 +665,9 @@@
  		status = nvmet_copy_to_sgl(req, 0, &req->sq->ctrl->hostid,
  				sizeof(req->sq->ctrl->hostid));
  		break;
 -	case NVME_FEAT_WRITE_PROTECT:
 -		status = nvmet_get_feat_write_protect(req);
 -		break;
  	default:
+ 		req->error_loc =
+ 			offsetof(struct nvme_common_command, cdw10);
  		status = NVME_SC_INVALID_FIELD | NVME_SC_DNR;
  		break;
  	}
* Unmerged path drivers/nvme/target/admin-cmd.c
