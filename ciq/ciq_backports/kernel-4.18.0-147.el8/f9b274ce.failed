mlxsw: spectrum_acl: Push rehash dw struct into rehash sub-struct

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jiri Pirko <jiri@mellanox.com>
commit f9b274ce014421899b62cb0e41e5e7b72773782b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/f9b274ce.failed

More rehash related fields are going to come. Push "dw" into sub-struct
that will accommodate the others as well.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f9b274ce014421899b62cb0e41e5e7b72773782b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
index c607c62a43ae,e2699373dfa7..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
@@@ -163,11 -180,24 +163,22 @@@ struct mlxsw_sp_acl_tcam_group 
  };
  
  struct mlxsw_sp_acl_tcam_vregion {
 -	struct mutex lock; /* Protects consistency of region, region2 pointers
 -			    * and vchunk_list.
 -			    */
  	struct mlxsw_sp_acl_tcam_region *region;
 -	struct mlxsw_sp_acl_tcam_region *region2; /* Used during migration */
  	struct list_head list; /* Member of a TCAM group */
 -	struct list_head tlist; /* Member of a TCAM */
  	struct list_head vchunk_list; /* List of vchunks under this vregion */
 +	struct mlxsw_sp_acl_tcam_group *group;
  	struct mlxsw_afk_key_info *key_info;
++<<<<<<< HEAD
++=======
+ 	struct mlxsw_sp_acl_tcam *tcam;
+ 	struct mlxsw_sp_acl_tcam_vgroup *vgroup;
+ 	struct {
+ 		struct delayed_work dw;
+ 	} rehash;
+ 	struct mlxsw_sp *mlxsw_sp;
+ 	bool failed_rollback; /* Indicates failed rollback during migration */
+ 	unsigned int ref_count;
++>>>>>>> f9b274ce0144 (mlxsw: spectrum_acl: Push rehash dw struct into rehash sub-struct)
  };
  
  struct mlxsw_sp_acl_tcam_vchunk;
@@@ -603,12 -713,40 +614,40 @@@ mlxsw_sp_acl_tcam_region_destroy(struc
  	kfree(region);
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ mlxsw_sp_acl_tcam_vregion_rehash_work_schedule(struct mlxsw_sp_acl_tcam_vregion *vregion)
+ {
+ 	unsigned long interval = vregion->tcam->vregion_rehash_intrvl;
+ 
+ 	if (!interval)
+ 		return;
+ 	mlxsw_core_schedule_dw(&vregion->rehash.dw,
+ 			       msecs_to_jiffies(interval));
+ }
+ 
+ static int
+ mlxsw_sp_acl_tcam_vregion_rehash(struct mlxsw_sp *mlxsw_sp,
+ 				 struct mlxsw_sp_acl_tcam_vregion *vregion);
+ 
+ static void mlxsw_sp_acl_tcam_vregion_rehash_work(struct work_struct *work)
+ {
+ 	struct mlxsw_sp_acl_tcam_vregion *vregion =
+ 		container_of(work, struct mlxsw_sp_acl_tcam_vregion,
+ 			     rehash.dw.work);
+ 
+ 	mlxsw_sp_acl_tcam_vregion_rehash(vregion->mlxsw_sp, vregion);
+ 	mlxsw_sp_acl_tcam_vregion_rehash_work_schedule(vregion);
+ }
+ 
++>>>>>>> f9b274ce0144 (mlxsw: spectrum_acl: Push rehash dw struct into rehash sub-struct)
  static struct mlxsw_sp_acl_tcam_vregion *
  mlxsw_sp_acl_tcam_vregion_create(struct mlxsw_sp *mlxsw_sp,
 -				 struct mlxsw_sp_acl_tcam_vgroup *vgroup,
 -				 unsigned int priority,
 +				 struct mlxsw_sp_acl_tcam *tcam,
  				 struct mlxsw_afk_element_usage *elusage)
  {
 -	const struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;
  	struct mlxsw_afk *afk = mlxsw_sp_acl_afk(mlxsw_sp->acl);
 -	struct mlxsw_sp_acl_tcam *tcam = vgroup->group.tcam;
  	struct mlxsw_sp_acl_tcam_vregion *vregion;
  	int err;
  
@@@ -630,8 -773,25 +669,26 @@@
  		goto err_region_create;
  	}
  
++<<<<<<< HEAD
++=======
+ 	err = mlxsw_sp_acl_tcam_vgroup_vregion_attach(mlxsw_sp, vgroup, vregion,
+ 						      priority);
+ 	if (err)
+ 		goto err_vgroup_vregion_attach;
+ 
+ 	if (vgroup->vregion_rehash_enabled && ops->region_rehash_hints_get) {
+ 		/* Create the delayed work for vregion periodic rehash */
+ 		INIT_DELAYED_WORK(&vregion->rehash.dw,
+ 				  mlxsw_sp_acl_tcam_vregion_rehash_work);
+ 		mlxsw_sp_acl_tcam_vregion_rehash_work_schedule(vregion);
+ 		mutex_lock(&tcam->lock);
+ 		list_add_tail(&vregion->tlist, &tcam->vregion_list);
+ 		mutex_unlock(&tcam->lock);
+ 	}
+ 
++>>>>>>> f9b274ce0144 (mlxsw: spectrum_acl: Push rehash dw struct into rehash sub-struct)
  	return vregion;
  
 -err_vgroup_vregion_attach:
 -	mlxsw_sp_acl_tcam_region_destroy(mlxsw_sp, vregion->region);
  err_region_create:
  	mlxsw_afk_key_info_put(vregion->key_info);
  err_key_info_get:
@@@ -643,62 -803,92 +700,120 @@@ static voi
  mlxsw_sp_acl_tcam_vregion_destroy(struct mlxsw_sp *mlxsw_sp,
  				  struct mlxsw_sp_acl_tcam_vregion *vregion)
  {
++<<<<<<< HEAD
++=======
+ 	const struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;
+ 	struct mlxsw_sp_acl_tcam_vgroup *vgroup = vregion->vgroup;
+ 	struct mlxsw_sp_acl_tcam *tcam = vregion->tcam;
+ 
+ 	if (vgroup->vregion_rehash_enabled && ops->region_rehash_hints_get) {
+ 		mutex_lock(&tcam->lock);
+ 		list_del(&vregion->tlist);
+ 		mutex_unlock(&tcam->lock);
+ 		cancel_delayed_work_sync(&vregion->rehash.dw);
+ 	}
+ 	mlxsw_sp_acl_tcam_vgroup_vregion_detach(mlxsw_sp, vregion);
+ 	if (vregion->region2)
+ 		mlxsw_sp_acl_tcam_region_destroy(mlxsw_sp, vregion->region2);
++>>>>>>> f9b274ce0144 (mlxsw: spectrum_acl: Push rehash dw struct into rehash sub-struct)
  	mlxsw_sp_acl_tcam_region_destroy(mlxsw_sp, vregion->region);
  	mlxsw_afk_key_info_put(vregion->key_info);
 -	mutex_destroy(&vregion->lock);
  	kfree(vregion);
  }
  
 -u32 mlxsw_sp_acl_tcam_vregion_rehash_intrvl_get(struct mlxsw_sp *mlxsw_sp,
 -						struct mlxsw_sp_acl_tcam *tcam)
 +static int
 +mlxsw_sp_acl_tcam_vchunk_assoc(struct mlxsw_sp *mlxsw_sp,
 +			       struct mlxsw_sp_acl_tcam_group *group,
 +			       unsigned int priority,
 +			       struct mlxsw_afk_element_usage *elusage,
 +			       struct mlxsw_sp_acl_tcam_vchunk *vchunk)
  {
++<<<<<<< HEAD
++=======
+ 	const struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;
+ 	u32 vregion_rehash_intrvl;
+ 
+ 	if (WARN_ON(!ops->region_rehash_hints_get))
+ 		return 0;
+ 	vregion_rehash_intrvl = tcam->vregion_rehash_intrvl;
+ 	return vregion_rehash_intrvl;
+ }
+ 
+ int mlxsw_sp_acl_tcam_vregion_rehash_intrvl_set(struct mlxsw_sp *mlxsw_sp,
+ 						struct mlxsw_sp_acl_tcam *tcam,
+ 						u32 val)
+ {
+ 	const struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;
+ 	struct mlxsw_sp_acl_tcam_vregion *vregion;
+ 
+ 	if (val < MLXSW_SP_ACL_TCAM_VREGION_REHASH_INTRVL_MIN && val)
+ 		return -EINVAL;
+ 	if (WARN_ON(!ops->region_rehash_hints_get))
+ 		return -EOPNOTSUPP;
+ 	tcam->vregion_rehash_intrvl = val;
+ 	mutex_lock(&tcam->lock);
+ 	list_for_each_entry(vregion, &tcam->vregion_list, tlist) {
+ 		if (val)
+ 			mlxsw_core_schedule_dw(&vregion->rehash.dw, 0);
+ 		else
+ 			cancel_delayed_work_sync(&vregion->rehash.dw);
+ 	}
+ 	mutex_unlock(&tcam->lock);
+ 	return 0;
+ }
+ 
+ static struct mlxsw_sp_acl_tcam_vregion *
+ mlxsw_sp_acl_tcam_vregion_get(struct mlxsw_sp *mlxsw_sp,
+ 			      struct mlxsw_sp_acl_tcam_vgroup *vgroup,
+ 			      unsigned int priority,
+ 			      struct mlxsw_afk_element_usage *elusage)
+ {
+ 	struct mlxsw_afk_element_usage vregion_elusage;
++>>>>>>> f9b274ce0144 (mlxsw: spectrum_acl: Push rehash dw struct into rehash sub-struct)
  	struct mlxsw_sp_acl_tcam_vregion *vregion;
 +	bool vregion_created = false;
  	bool need_split;
 +	int err;
  
 -	vregion = mlxsw_sp_acl_tcam_vgroup_vregion_find(vgroup, priority,
 -							elusage, &need_split);
 -	if (vregion) {
 -		if (need_split) {
 -			/* According to priority, new vchunk should belong to
 -			 * an existing vregion. However, this vchunk needs
 -			 * elements that vregion does not contain. We need
 -			 * to split the existing vregion into two and create
 -			 * a new vregion for the new vchunk in between.
 -			 * This is not supported now.
 -			 */
 -			return ERR_PTR(-EOPNOTSUPP);
 -		}
 -		vregion->ref_count++;
 -		return vregion;
 +	vregion = mlxsw_sp_acl_tcam_group_vregion_find(group, priority, elusage,
 +						       &need_split);
 +	if (vregion && need_split) {
 +		/* According to priority, the vchunk should belong to an
 +		 * existing vregion. However, this vchunk needs elements
 +		 * that vregion does not contain. We need to split the existing
 +		 * vregion into two and create a new vregion for this vchunk
 +		 * in between. This is not supported now.
 +		 */
 +		return -EOPNOTSUPP;
 +	}
 +	if (!vregion) {
 +		struct mlxsw_afk_element_usage vregion_elusage;
 +
 +		mlxsw_sp_acl_tcam_group_use_patterns(group, elusage,
 +						     &vregion_elusage);
 +		vregion = mlxsw_sp_acl_tcam_vregion_create(mlxsw_sp,
 +							   group->tcam,
 +							   &vregion_elusage);
 +		if (IS_ERR(vregion))
 +			return PTR_ERR(vregion);
 +		vregion_created = true;
  	}
  
 -	mlxsw_sp_acl_tcam_vgroup_use_patterns(vgroup, elusage,
 -					      &vregion_elusage);
 +	vchunk->vregion = vregion;
 +	list_add_tail(&vchunk->list, &vregion->vchunk_list);
  
 -	return mlxsw_sp_acl_tcam_vregion_create(mlxsw_sp, vgroup, priority,
 -						&vregion_elusage);
 +	if (!vregion_created)
 +		return 0;
 +
 +	err = mlxsw_sp_acl_tcam_group_vregion_attach(mlxsw_sp, group, vregion);
 +	if (err)
 +		goto err_group_vregion_attach;
 +
 +	return 0;
 +
 +err_group_vregion_attach:
 +	mlxsw_sp_acl_tcam_vregion_destroy(mlxsw_sp, vregion);
 +	return err;
  }
  
  static void
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
