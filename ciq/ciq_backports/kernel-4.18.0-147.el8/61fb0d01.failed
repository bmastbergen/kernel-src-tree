ipv6: prevent possible fib6 leaks

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Eric Dumazet <edumazet@google.com>
commit 61fb0d01680771f72cc9d39783fb2c122aaad51e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/61fb0d01.failed

At ipv6 route dismantle, fib6_drop_pcpu_from() is responsible
for finding all percpu routes and set their ->from pointer
to NULL, so that fib6_ref can reach its expected value (1).

The problem right now is that other cpus can still catch the
route being deleted, since there is no rcu grace period
between the route deletion and call to fib6_drop_pcpu_from()

This can leak the fib6 and associated resources, since no
notifier will take care of removing the last reference(s).

I decided to add another boolean (fib6_destroying) instead
of reusing/renaming exception_bucket_flushed to ease stable backports,
and properly document the memory barriers used to implement this fix.

This patch has been co-developped with Wei Wang.

Fixes: 93531c674315 ("net/ipv6: separate handling of FIB entries from dst based routes")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Reported-by: syzbot <syzkaller@googlegroups.com>
	Cc: Wei Wang <weiwan@google.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Martin Lau <kafai@fb.com>
	Acked-by: Wei Wang <weiwan@google.com>
	Acked-by: Martin KaFai Lau <kafai@fb.com>
	Reviewed-by: David Ahern <dsahern@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 61fb0d01680771f72cc9d39783fb2c122aaad51e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_fib.c
diff --cc net/ipv6/ip6_fib.c
index 36599696c3b1,008421b550c6..000000000000
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@@ -935,7 -933,10 +941,14 @@@ static void fib6_purge_rt(struct fib6_i
  {
  	struct fib6_table *table = rt->fib6_table;
  
++<<<<<<< HEAD
 +	if (atomic_read(&rt->fib6_ref) != 1) {
++=======
+ 	if (rt->rt6i_pcpu)
+ 		fib6_drop_pcpu_from(rt, table);
+ 
+ 	if (refcount_read(&rt->fib6_ref) != 1) {
++>>>>>>> 61fb0d016807 (ipv6: prevent possible fib6 leaks)
  		/* This route is used as dummy address holder in some split
  		 * nodes. It is not leaked, but it still holds other resources,
  		 * which must be released in time. So, scan ascendant nodes
diff --git a/include/net/ip6_fib.h b/include/net/ip6_fib.h
index 59f77b8442d3..62c936230cc8 100644
--- a/include/net/ip6_fib.h
+++ b/include/net/ip6_fib.h
@@ -171,7 +171,8 @@ struct fib6_info {
 					dst_nocount:1,
 					dst_nopolicy:1,
 					dst_host:1,
-					unused:3;
+					fib6_destroying:1,
+					unused:2;
 
 	struct fib6_nh			fib6_nh;
 	struct rcu_head			rcu;
* Unmerged path net/ipv6/ip6_fib.c
diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index d3c309542319..61517c39fcd1 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -1268,6 +1268,13 @@ static struct rt6_info *rt6_make_pcpu_route(struct net *net,
 	prev = cmpxchg(p, NULL, pcpu_rt);
 	BUG_ON(prev);
 
+	if (res->f6i->fib6_destroying) {
+		struct fib6_info *from;
+
+		from = xchg((__force struct fib6_info **)&pcpu_rt->from, NULL);
+		fib6_info_release(from);
+	}
+
 	return pcpu_rt;
 }
 
