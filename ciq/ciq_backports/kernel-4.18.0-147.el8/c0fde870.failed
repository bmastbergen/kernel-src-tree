neighbor: NTF_PROXY is a valid ndm_flag for a dump request

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author David Ahern <dsahern@gmail.com>
commit c0fde870d96e42bbdcc0d9af7ae5e190c767aab8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/c0fde870.failed

When dumping proxy entries the dump request has NTF_PROXY set in
ndm_flags. strict mode checking needs to be updated to allow this
flag.

Fixes: 51183d233b5a ("net/neighbor: Update neigh_dump_info for strict data checking")
	Signed-off-by: David Ahern <dsahern@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c0fde870d96e42bbdcc0d9af7ae5e190c767aab8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/neighbour.c
diff --cc net/core/neighbour.c
index decf897d9d53,5fa32c064baf..000000000000
--- a/net/core/neighbour.c
+++ b/net/core/neighbour.c
@@@ -2452,6 -2476,74 +2452,77 @@@ out
  
  }
  
++<<<<<<< HEAD
++=======
+ static int neigh_valid_dump_req(const struct nlmsghdr *nlh,
+ 				bool strict_check,
+ 				struct neigh_dump_filter *filter,
+ 				struct netlink_ext_ack *extack)
+ {
+ 	struct nlattr *tb[NDA_MAX + 1];
+ 	int err, i;
+ 
+ 	if (strict_check) {
+ 		struct ndmsg *ndm;
+ 
+ 		if (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ndm))) {
+ 			NL_SET_ERR_MSG(extack, "Invalid header for neighbor dump request");
+ 			return -EINVAL;
+ 		}
+ 
+ 		ndm = nlmsg_data(nlh);
+ 		if (ndm->ndm_pad1  || ndm->ndm_pad2  || ndm->ndm_ifindex ||
+ 		    ndm->ndm_state || ndm->ndm_type) {
+ 			NL_SET_ERR_MSG(extack, "Invalid values in header for neighbor dump request");
+ 			return -EINVAL;
+ 		}
+ 
+ 		if (ndm->ndm_flags & ~NTF_PROXY) {
+ 			NL_SET_ERR_MSG(extack, "Invalid flags in header for neighbor dump request");
+ 			return -EINVAL;
+ 		}
+ 
+ 		err = nlmsg_parse_strict(nlh, sizeof(struct ndmsg), tb, NDA_MAX,
+ 					 NULL, extack);
+ 	} else {
+ 		err = nlmsg_parse(nlh, sizeof(struct ndmsg), tb, NDA_MAX,
+ 				  NULL, extack);
+ 	}
+ 	if (err < 0)
+ 		return err;
+ 
+ 	for (i = 0; i <= NDA_MAX; ++i) {
+ 		if (!tb[i])
+ 			continue;
+ 
+ 		/* all new attributes should require strict_check */
+ 		switch (i) {
+ 		case NDA_IFINDEX:
+ 			if (nla_len(tb[i]) != sizeof(u32)) {
+ 				NL_SET_ERR_MSG(extack, "Invalid IFINDEX attribute in neighbor dump request");
+ 				return -EINVAL;
+ 			}
+ 			filter->dev_idx = nla_get_u32(tb[i]);
+ 			break;
+ 		case NDA_MASTER:
+ 			if (nla_len(tb[i]) != sizeof(u32)) {
+ 				NL_SET_ERR_MSG(extack, "Invalid MASTER attribute in neighbor dump request");
+ 				return -EINVAL;
+ 			}
+ 			filter->master_idx = nla_get_u32(tb[i]);
+ 			break;
+ 		default:
+ 			if (strict_check) {
+ 				NL_SET_ERR_MSG(extack, "Unsupported attribute in neighbor dump request");
+ 				return -EINVAL;
+ 			}
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> c0fde870d96e (neighbor: NTF_PROXY is a valid ndm_flag for a dump request)
  static int neigh_dump_info(struct sk_buff *skb, struct netlink_callback *cb)
  {
  	const struct nlmsghdr *nlh = cb->nlh;
* Unmerged path net/core/neighbour.c
