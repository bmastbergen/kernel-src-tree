mac80211: fix rate reporting inside cfg80211_calculate_bitrate_he()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author John Crispin <john@phrozen.org>
commit 25d16d124a5e249e947c0487678b61dcff25cf8b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/25d16d12.failed

The reported rate is not scaled down correctly. After applying this patch,
the function will behave just like the v/ht equivalents.

	Signed-off-by: Shashidhar Lakkavalli <slakkavalli@datto.com>
	Signed-off-by: John Crispin <john@phrozen.org>
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 25d16d124a5e249e947c0487678b61dcff25cf8b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/wireless/util.c
diff --cc net/wireless/util.c
index 3c654cd7ba56,b9d8ceb21327..000000000000
--- a/net/wireless/util.c
+++ b/net/wireless/util.c
@@@ -1142,6 -1168,87 +1142,90 @@@ static u32 cfg80211_calculate_bitrate_v
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static u32 cfg80211_calculate_bitrate_he(struct rate_info *rate)
+ {
+ #define SCALE 2048
+ 	u16 mcs_divisors[12] = {
+ 		34133, /* 16.666666... */
+ 		17067, /*  8.333333... */
+ 		11378, /*  5.555555... */
+ 		 8533, /*  4.166666... */
+ 		 5689, /*  2.777777... */
+ 		 4267, /*  2.083333... */
+ 		 3923, /*  1.851851... */
+ 		 3413, /*  1.666666... */
+ 		 2844, /*  1.388888... */
+ 		 2560, /*  1.250000... */
+ 		 2276, /*  1.111111... */
+ 		 2048, /*  1.000000... */
+ 	};
+ 	u32 rates_160M[3] = { 960777777, 907400000, 816666666 };
+ 	u32 rates_969[3] =  { 480388888, 453700000, 408333333 };
+ 	u32 rates_484[3] =  { 229411111, 216666666, 195000000 };
+ 	u32 rates_242[3] =  { 114711111, 108333333,  97500000 };
+ 	u32 rates_106[3] =  {  40000000,  37777777,  34000000 };
+ 	u32 rates_52[3]  =  {  18820000,  17777777,  16000000 };
+ 	u32 rates_26[3]  =  {   9411111,   8888888,   8000000 };
+ 	u64 tmp;
+ 	u32 result;
+ 
+ 	if (WARN_ON_ONCE(rate->mcs > 11))
+ 		return 0;
+ 
+ 	if (WARN_ON_ONCE(rate->he_gi > NL80211_RATE_INFO_HE_GI_3_2))
+ 		return 0;
+ 	if (WARN_ON_ONCE(rate->he_ru_alloc >
+ 			 NL80211_RATE_INFO_HE_RU_ALLOC_2x996))
+ 		return 0;
+ 	if (WARN_ON_ONCE(rate->nss < 1 || rate->nss > 8))
+ 		return 0;
+ 
+ 	if (rate->bw == RATE_INFO_BW_160)
+ 		result = rates_160M[rate->he_gi];
+ 	else if (rate->bw == RATE_INFO_BW_80 ||
+ 		 (rate->bw == RATE_INFO_BW_HE_RU &&
+ 		  rate->he_ru_alloc == NL80211_RATE_INFO_HE_RU_ALLOC_996))
+ 		result = rates_969[rate->he_gi];
+ 	else if (rate->bw == RATE_INFO_BW_40 ||
+ 		 (rate->bw == RATE_INFO_BW_HE_RU &&
+ 		  rate->he_ru_alloc == NL80211_RATE_INFO_HE_RU_ALLOC_484))
+ 		result = rates_484[rate->he_gi];
+ 	else if (rate->bw == RATE_INFO_BW_20 ||
+ 		 (rate->bw == RATE_INFO_BW_HE_RU &&
+ 		  rate->he_ru_alloc == NL80211_RATE_INFO_HE_RU_ALLOC_242))
+ 		result = rates_242[rate->he_gi];
+ 	else if (rate->bw == RATE_INFO_BW_HE_RU &&
+ 		 rate->he_ru_alloc == NL80211_RATE_INFO_HE_RU_ALLOC_106)
+ 		result = rates_106[rate->he_gi];
+ 	else if (rate->bw == RATE_INFO_BW_HE_RU &&
+ 		 rate->he_ru_alloc == NL80211_RATE_INFO_HE_RU_ALLOC_52)
+ 		result = rates_52[rate->he_gi];
+ 	else if (rate->bw == RATE_INFO_BW_HE_RU &&
+ 		 rate->he_ru_alloc == NL80211_RATE_INFO_HE_RU_ALLOC_26)
+ 		result = rates_26[rate->he_gi];
+ 	else {
+ 		WARN(1, "invalid HE MCS: bw:%d, ru:%d\n",
+ 		     rate->bw, rate->he_ru_alloc);
+ 		return 0;
+ 	}
+ 
+ 	/* now scale to the appropriate MCS */
+ 	tmp = result;
+ 	tmp *= SCALE;
+ 	do_div(tmp, mcs_divisors[rate->mcs]);
+ 	result = tmp;
+ 
+ 	/* and take NSS, DCM into account */
+ 	result = (result * rate->nss) / 8;
+ 	if (rate->he_dcm)
+ 		result /= 2;
+ 
+ 	return result / 10000;
+ }
+ 
++>>>>>>> 25d16d124a5e (mac80211: fix rate reporting inside cfg80211_calculate_bitrate_he())
  u32 cfg80211_calculate_bitrate(struct rate_info *rate)
  {
  	if (rate->flags & RATE_INFO_FLAGS_MCS)
* Unmerged path net/wireless/util.c
