arm64/speculation: Support 'mitigations=' cmdline option

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Josh Poimboeuf <jpoimboe@redhat.com>
commit a111b7c0f20e13b54df2fa959b3dc0bdf1925ae6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/a111b7c0.failed

Configure arm64 runtime CPU speculation bug mitigations in accordance
with the 'mitigations=' cmdline option.  This affects Meltdown, Spectre
v2, and Speculative Store Bypass.

The default behavior is unchanged.

	Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
[will: reorder checks so KASLR implies KPTI and SSBS is affected by cmdline]
	Signed-off-by: Will Deacon <will.deacon@arm.com>
(cherry picked from commit a111b7c0f20e13b54df2fa959b3dc0bdf1925ae6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/admin-guide/kernel-parameters.txt
#	arch/arm64/kernel/cpu_errata.c
#	arch/arm64/kernel/cpufeature.c
diff --cc Documentation/admin-guide/kernel-parameters.txt
index 9dd2dc57265b,ce226f7ee566..000000000000
--- a/Documentation/admin-guide/kernel-parameters.txt
+++ b/Documentation/admin-guide/kernel-parameters.txt
@@@ -2526,8 -2545,8 +2526,13 @@@
  			http://repo.or.cz/w/linux-2.6/mini2440.git
  
  	mitigations=
++<<<<<<< HEAD
 +			[X86] Control optional mitigations for CPU
 +			vulnerabilities.  This is a set of curated,
++=======
+ 			[X86,PPC,S390,ARM64] Control optional mitigations for
+ 			CPU vulnerabilities.  This is a set of curated,
++>>>>>>> a111b7c0f20e (arm64/speculation: Support 'mitigations=' cmdline option)
  			arch-independent options, each of which is an
  			aggregation of existing arch-specific options.
  
@@@ -2535,12 -2554,15 +2540,23 @@@
  				Disable all optional CPU mitigations.  This
  				improves system performance, but it may also
  				expose users to several CPU vulnerabilities.
++<<<<<<< HEAD
 +				Equivalent to: nopti [X86]
 +					       nospectre_v2 [X86]
 +					       spectre_v2_user=off [X86]
 +					       spec_store_bypass_disable=off [X86]
++=======
+ 				Equivalent to: nopti [X86,PPC]
+ 					       kpti=0 [ARM64]
+ 					       nospectre_v1 [PPC]
+ 					       nobp=0 [S390]
+ 					       nospectre_v2 [X86,PPC,S390,ARM64]
+ 					       spectre_v2_user=off [X86]
+ 					       spec_store_bypass_disable=off [X86,PPC]
+ 					       ssbd=force-off [ARM64]
++>>>>>>> a111b7c0f20e (arm64/speculation: Support 'mitigations=' cmdline option)
  					       l1tf=off [X86]
 +					       mds=off [X86]
  
  			auto (default)
  				Mitigate all CPU vulnerabilities, but leave SMT
diff --cc arch/arm64/kernel/cpu_errata.c
index fde6f87a8b7e,1b9ce0fdd81d..000000000000
--- a/arch/arm64/kernel/cpu_errata.c
+++ b/arch/arm64/kernel/cpu_errata.c
@@@ -342,8 -386,25 +343,25 @@@ static bool has_ssbd_mitigation(const s
  
  	WARN_ON(scope != SCOPE_LOCAL_CPU || preemptible());
  
++<<<<<<< HEAD
++=======
+ 	if (cpu_mitigations_off())
+ 		ssbd_state = ARM64_SSBD_FORCE_DISABLE;
+ 
+ 	/* delay setting __ssb_safe until we get a firmware response */
+ 	if (is_midr_in_range_list(read_cpuid_id(), entry->midr_range_list))
+ 		this_cpu_safe = true;
+ 
+ 	if (this_cpu_has_cap(ARM64_SSBS)) {
+ 		if (!this_cpu_safe)
+ 			__ssb_safe = false;
+ 		required = false;
+ 		goto out_printmsg;
+ 	}
+ 
++>>>>>>> a111b7c0f20e (arm64/speculation: Support 'mitigations=' cmdline option)
  	if (psci_ops.smccc_version == SMCCC_VERSION_1_0) {
  		ssbd_state = ARM64_SSBD_UNKNOWN;
 -		if (!this_cpu_safe)
 -			__ssb_safe = false;
  		return false;
  	}
  
@@@ -454,54 -545,73 +472,92 @@@
  	.type = ARM64_CPUCAP_LOCAL_CPU_ERRATUM,			\
  	CAP_MIDR_RANGE_LIST(midr_list)
  
 -/* Track overall mitigation state. We are only mitigated if all cores are ok */
 -static bool __hardenbp_enab = true;
 -static bool __spectrev2_safe = true;
 -
  /*
 - * List of CPUs that do not need any Spectre-v2 mitigation at all.
 - */
 -static const struct midr_range spectre_v2_safe_list[] = {
 -	MIDR_ALL_VERSIONS(MIDR_CORTEX_A35),
 -	MIDR_ALL_VERSIONS(MIDR_CORTEX_A53),
 -	MIDR_ALL_VERSIONS(MIDR_CORTEX_A55),
 -	{ /* sentinel */ }
 -};
 -
 -/*
 - * Track overall bp hardening for all heterogeneous cores in the machine.
 - * We are only considered "safe" if all booted cores are known safe.
 + * Generic helper for handling capabilties with multiple (match,enable) pairs
 + * of call backs, sharing the same capability bit.
 + * Iterate over each entry to see if at least one matches.
   */
  static bool __maybe_unused
 -check_branch_predictor(const struct arm64_cpu_capabilities *entry, int scope)
 +multi_entry_cap_matches(const struct arm64_cpu_capabilities *entry, int scope)
  {
 -	int need_wa;
 +	const struct arm64_cpu_capabilities *caps;
  
 -	WARN_ON(scope != SCOPE_LOCAL_CPU || preemptible());
 +	for (caps = entry->match_list; caps->matches; caps++)
 +		if (caps->matches(caps, scope))
 +			return true;
  
++<<<<<<< HEAD
 +	return false;
++=======
+ 	/* If the CPU has CSV2 set, we're safe */
+ 	if (cpuid_feature_extract_unsigned_field(read_cpuid(ID_AA64PFR0_EL1),
+ 						 ID_AA64PFR0_CSV2_SHIFT))
+ 		return false;
+ 
+ 	/* Alternatively, we have a list of unaffected CPUs */
+ 	if (is_midr_in_range_list(read_cpuid_id(), spectre_v2_safe_list))
+ 		return false;
+ 
+ 	/* Fallback to firmware detection */
+ 	need_wa = detect_harden_bp_fw();
+ 	if (!need_wa)
+ 		return false;
+ 
+ 	__spectrev2_safe = false;
+ 
+ 	if (!IS_ENABLED(CONFIG_HARDEN_BRANCH_PREDICTOR)) {
+ 		pr_warn_once("spectrev2 mitigation disabled by kernel configuration\n");
+ 		__hardenbp_enab = false;
+ 		return false;
+ 	}
+ 
+ 	/* forced off */
+ 	if (__nospectre_v2 || cpu_mitigations_off()) {
+ 		pr_info_once("spectrev2 mitigation disabled by command line option\n");
+ 		__hardenbp_enab = false;
+ 		return false;
+ 	}
+ 
+ 	if (need_wa < 0) {
+ 		pr_warn_once("ARM_SMCCC_ARCH_WORKAROUND_1 missing from firmware\n");
+ 		__hardenbp_enab = false;
+ 	}
+ 
+ 	return (need_wa > 0);
++>>>>>>> a111b7c0f20e (arm64/speculation: Support 'mitigations=' cmdline option)
  }
  
 -#ifdef CONFIG_HARDEN_EL2_VECTORS
 +/*
 + * Take appropriate action for all matching entries in the shared capability
 + * entry.
 + */
 +static void __maybe_unused
 +multi_entry_cap_cpu_enable(const struct arm64_cpu_capabilities *entry)
 +{
 +	const struct arm64_cpu_capabilities *caps;
  
 -static const struct midr_range arm64_harden_el2_vectors[] = {
 +	for (caps = entry->match_list; caps->matches; caps++)
 +		if (caps->matches(caps, SCOPE_LOCAL_CPU) &&
 +		    caps->cpu_enable)
 +			caps->cpu_enable(caps);
 +}
 +
 +#ifdef CONFIG_HARDEN_BRANCH_PREDICTOR
 +
 +/*
 + * List of CPUs where we need to issue a psci call to
 + * harden the branch predictor.
 + */
 +static const struct midr_range arm64_bp_harden_smccc_cpus[] = {
  	MIDR_ALL_VERSIONS(MIDR_CORTEX_A57),
  	MIDR_ALL_VERSIONS(MIDR_CORTEX_A72),
 +	MIDR_ALL_VERSIONS(MIDR_CORTEX_A73),
 +	MIDR_ALL_VERSIONS(MIDR_CORTEX_A75),
 +	MIDR_ALL_VERSIONS(MIDR_BRCM_VULCAN),
 +	MIDR_ALL_VERSIONS(MIDR_CAVIUM_THUNDERX2),
 +	MIDR_ALL_VERSIONS(MIDR_QCOM_FALKOR_V1),
 +	MIDR_ALL_VERSIONS(MIDR_QCOM_FALKOR),
 +	MIDR_ALL_VERSIONS(MIDR_NVIDIA_DENVER),
  	{},
  };
  
diff --cc arch/arm64/kernel/cpufeature.c
index b12c81308403,f3b32d88f165..000000000000
--- a/arch/arm64/kernel/cpufeature.c
+++ b/arch/arm64/kernel/cpufeature.c
@@@ -894,7 -967,17 +895,21 @@@ static bool unmap_kernel_at_el0(const s
  		MIDR_ALL_VERSIONS(MIDR_HISI_TSV110),
  		{ /* sentinel */ }
  	};
++<<<<<<< HEAD
 +	char const *str = "command line option";
++=======
+ 	char const *str = "kpti command line option";
+ 	bool meltdown_safe;
+ 
+ 	meltdown_safe = is_midr_in_range_list(read_cpuid_id(), kpti_safe_list);
+ 
+ 	/* Defer to CPU feature registers */
+ 	if (has_cpuid_feature(entry, scope))
+ 		meltdown_safe = true;
+ 
+ 	if (!meltdown_safe)
+ 		__meltdown_safe = false;
++>>>>>>> a111b7c0f20e (arm64/speculation: Support 'mitigations=' cmdline option)
  
  	/*
  	 * For reasons that aren't entirely clear, enabling KPTI on Cavium
@@@ -906,6 -989,24 +921,27 @@@
  		__kpti_forced = -1;
  	}
  
++<<<<<<< HEAD
++=======
+ 	/* Useful for KASLR robustness */
+ 	if (IS_ENABLED(CONFIG_RANDOMIZE_BASE) && kaslr_offset() > 0) {
+ 		if (!__kpti_forced) {
+ 			str = "KASLR";
+ 			__kpti_forced = 1;
+ 		}
+ 	}
+ 
+ 	if (cpu_mitigations_off() && !__kpti_forced) {
+ 		str = "mitigations=off";
+ 		__kpti_forced = -1;
+ 	}
+ 
+ 	if (!IS_ENABLED(CONFIG_UNMAP_KERNEL_AT_EL0)) {
+ 		pr_info_once("kernel page table isolation disabled by kernel configuration\n");
+ 		return false;
+ 	}
+ 
++>>>>>>> a111b7c0f20e (arm64/speculation: Support 'mitigations=' cmdline option)
  	/* Forced? */
  	if (__kpti_forced) {
  		pr_info_once("kernel page table isolation forced %s by %s\n",
* Unmerged path Documentation/admin-guide/kernel-parameters.txt
* Unmerged path arch/arm64/kernel/cpu_errata.c
* Unmerged path arch/arm64/kernel/cpufeature.c
