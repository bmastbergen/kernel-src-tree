nvme-multipath: relax ANA state check

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Martin George <marting@netapp.com>
commit cc2278c413c3a06a93c23ee8722e4dd3d621de12
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/cc2278c4.failed

When undergoing state transitions I/O might be requeued, hence
we should always call nvme_mpath_set_live() to schedule requeue_work
whenever the nvme device is live, independent on whether the
old state was live or not.

	Signed-off-by: Martin George <marting@netapp.com>
	Signed-off-by: Gargi Srinivas <sring@netapp.com>
	Signed-off-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit cc2278c413c3a06a93c23ee8722e4dd3d621de12)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/multipath.c
diff --cc drivers/nvme/host/multipath.c
index 1b128a2a399e,f0716f6ce41f..000000000000
--- a/drivers/nvme/host/multipath.c
+++ b/drivers/nvme/host/multipath.c
@@@ -203,15 -336,256 +203,263 @@@ void nvme_mpath_add_disk(struct nvme_ns
  	if (!head->disk)
  		return;
  
++<<<<<<< HEAD
 +	mutex_lock(&head->subsys->lock);
 +	if (!(head->disk->flags & GENHD_FL_UP)) {
 +		device_add_disk(&head->subsys->dev, head->disk);
 +		if (sysfs_create_group(&disk_to_dev(head->disk)->kobj,
 +				&nvme_ns_id_attr_group))
 +			pr_warn("%s: failed to create sysfs group for identification\n",
 +				head->disk->disk_name);
++=======
+ 	if (!(head->disk->flags & GENHD_FL_UP))
+ 		device_add_disk(&head->subsys->dev, head->disk,
+ 				nvme_ns_id_attr_groups);
+ 
+ 	if (nvme_path_is_optimized(ns)) {
+ 		int node, srcu_idx;
+ 
+ 		srcu_idx = srcu_read_lock(&head->srcu);
+ 		for_each_node(node)
+ 			__nvme_find_path(head, node);
+ 		srcu_read_unlock(&head->srcu, srcu_idx);
+ 	}
+ 
+ 	kblockd_schedule_work(&ns->head->requeue_work);
+ }
+ 
+ static int nvme_parse_ana_log(struct nvme_ctrl *ctrl, void *data,
+ 		int (*cb)(struct nvme_ctrl *ctrl, struct nvme_ana_group_desc *,
+ 			void *))
+ {
+ 	void *base = ctrl->ana_log_buf;
+ 	size_t offset = sizeof(struct nvme_ana_rsp_hdr);
+ 	int error, i;
+ 
+ 	lockdep_assert_held(&ctrl->ana_lock);
+ 
+ 	for (i = 0; i < le16_to_cpu(ctrl->ana_log_buf->ngrps); i++) {
+ 		struct nvme_ana_group_desc *desc = base + offset;
+ 		u32 nr_nsids = le32_to_cpu(desc->nnsids);
+ 		size_t nsid_buf_size = nr_nsids * sizeof(__le32);
+ 
+ 		if (WARN_ON_ONCE(desc->grpid == 0))
+ 			return -EINVAL;
+ 		if (WARN_ON_ONCE(le32_to_cpu(desc->grpid) > ctrl->anagrpmax))
+ 			return -EINVAL;
+ 		if (WARN_ON_ONCE(desc->state == 0))
+ 			return -EINVAL;
+ 		if (WARN_ON_ONCE(desc->state > NVME_ANA_CHANGE))
+ 			return -EINVAL;
+ 
+ 		offset += sizeof(*desc);
+ 		if (WARN_ON_ONCE(offset > ctrl->ana_log_size - nsid_buf_size))
+ 			return -EINVAL;
+ 
+ 		error = cb(ctrl, desc, data);
+ 		if (error)
+ 			return error;
+ 
+ 		offset += nsid_buf_size;
+ 		if (WARN_ON_ONCE(offset > ctrl->ana_log_size - sizeof(*desc)))
+ 			return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static inline bool nvme_state_is_live(enum nvme_ana_state state)
+ {
+ 	return state == NVME_ANA_OPTIMIZED || state == NVME_ANA_NONOPTIMIZED;
+ }
+ 
+ static void nvme_update_ns_ana_state(struct nvme_ana_group_desc *desc,
+ 		struct nvme_ns *ns)
+ {
+ 	mutex_lock(&ns->head->lock);
+ 	ns->ana_grpid = le32_to_cpu(desc->grpid);
+ 	ns->ana_state = desc->state;
+ 	clear_bit(NVME_NS_ANA_PENDING, &ns->flags);
+ 
+ 	if (nvme_state_is_live(ns->ana_state))
+ 		nvme_mpath_set_live(ns);
+ 	mutex_unlock(&ns->head->lock);
+ }
+ 
+ static int nvme_update_ana_state(struct nvme_ctrl *ctrl,
+ 		struct nvme_ana_group_desc *desc, void *data)
+ {
+ 	u32 nr_nsids = le32_to_cpu(desc->nnsids), n = 0;
+ 	unsigned *nr_change_groups = data;
+ 	struct nvme_ns *ns;
+ 
+ 	dev_info(ctrl->device, "ANA group %d: %s.\n",
+ 			le32_to_cpu(desc->grpid),
+ 			nvme_ana_state_names[desc->state]);
+ 
+ 	if (desc->state == NVME_ANA_CHANGE)
+ 		(*nr_change_groups)++;
+ 
+ 	if (!nr_nsids)
+ 		return 0;
+ 
+ 	down_write(&ctrl->namespaces_rwsem);
+ 	list_for_each_entry(ns, &ctrl->namespaces, list) {
+ 		if (ns->head->ns_id != le32_to_cpu(desc->nsids[n]))
+ 			continue;
+ 		nvme_update_ns_ana_state(desc, ns);
+ 		if (++n == nr_nsids)
+ 			break;
+ 	}
+ 	up_write(&ctrl->namespaces_rwsem);
+ 	WARN_ON_ONCE(n < nr_nsids);
+ 	return 0;
+ }
+ 
+ static int nvme_read_ana_log(struct nvme_ctrl *ctrl, bool groups_only)
+ {
+ 	u32 nr_change_groups = 0;
+ 	int error;
+ 
+ 	mutex_lock(&ctrl->ana_lock);
+ 	error = nvme_get_log(ctrl, NVME_NSID_ALL, NVME_LOG_ANA,
+ 			groups_only ? NVME_ANA_LOG_RGO : 0,
+ 			ctrl->ana_log_buf, ctrl->ana_log_size, 0);
+ 	if (error) {
+ 		dev_warn(ctrl->device, "Failed to get ANA log: %d\n", error);
+ 		goto out_unlock;
+ 	}
+ 
+ 	error = nvme_parse_ana_log(ctrl, &nr_change_groups,
+ 			nvme_update_ana_state);
+ 	if (error)
+ 		goto out_unlock;
+ 
+ 	/*
+ 	 * In theory we should have an ANATT timer per group as they might enter
+ 	 * the change state at different times.  But that is a lot of overhead
+ 	 * just to protect against a target that keeps entering new changes
+ 	 * states while never finishing previous ones.  But we'll still
+ 	 * eventually time out once all groups are in change state, so this
+ 	 * isn't a big deal.
+ 	 *
+ 	 * We also double the ANATT value to provide some slack for transports
+ 	 * or AEN processing overhead.
+ 	 */
+ 	if (nr_change_groups)
+ 		mod_timer(&ctrl->anatt_timer, ctrl->anatt * HZ * 2 + jiffies);
+ 	else
+ 		del_timer_sync(&ctrl->anatt_timer);
+ out_unlock:
+ 	mutex_unlock(&ctrl->ana_lock);
+ 	return error;
+ }
+ 
+ static void nvme_ana_work(struct work_struct *work)
+ {
+ 	struct nvme_ctrl *ctrl = container_of(work, struct nvme_ctrl, ana_work);
+ 
+ 	nvme_read_ana_log(ctrl, false);
+ }
+ 
+ static void nvme_anatt_timeout(struct timer_list *t)
+ {
+ 	struct nvme_ctrl *ctrl = from_timer(ctrl, t, anatt_timer);
+ 
+ 	dev_info(ctrl->device, "ANATT timeout, resetting controller.\n");
+ 	nvme_reset_ctrl(ctrl);
+ }
+ 
+ void nvme_mpath_stop(struct nvme_ctrl *ctrl)
+ {
+ 	if (!nvme_ctrl_use_ana(ctrl))
+ 		return;
+ 	del_timer_sync(&ctrl->anatt_timer);
+ 	cancel_work_sync(&ctrl->ana_work);
+ }
+ 
+ #define SUBSYS_ATTR_RW(_name, _mode, _show, _store)  \
+ 	struct device_attribute subsys_attr_##_name =	\
+ 		__ATTR(_name, _mode, _show, _store)
+ 
+ static const char *nvme_iopolicy_names[] = {
+ 	[NVME_IOPOLICY_NUMA]	= "numa",
+ 	[NVME_IOPOLICY_RR]	= "round-robin",
+ };
+ 
+ static ssize_t nvme_subsys_iopolicy_show(struct device *dev,
+ 		struct device_attribute *attr, char *buf)
+ {
+ 	struct nvme_subsystem *subsys =
+ 		container_of(dev, struct nvme_subsystem, dev);
+ 
+ 	return sprintf(buf, "%s\n",
+ 			nvme_iopolicy_names[READ_ONCE(subsys->iopolicy)]);
+ }
+ 
+ static ssize_t nvme_subsys_iopolicy_store(struct device *dev,
+ 		struct device_attribute *attr, const char *buf, size_t count)
+ {
+ 	struct nvme_subsystem *subsys =
+ 		container_of(dev, struct nvme_subsystem, dev);
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(nvme_iopolicy_names); i++) {
+ 		if (sysfs_streq(buf, nvme_iopolicy_names[i])) {
+ 			WRITE_ONCE(subsys->iopolicy, i);
+ 			return count;
+ 		}
+ 	}
+ 
+ 	return -EINVAL;
+ }
+ SUBSYS_ATTR_RW(iopolicy, S_IRUGO | S_IWUSR,
+ 		      nvme_subsys_iopolicy_show, nvme_subsys_iopolicy_store);
+ 
+ static ssize_t ana_grpid_show(struct device *dev, struct device_attribute *attr,
+ 		char *buf)
+ {
+ 	return sprintf(buf, "%d\n", nvme_get_ns_from_dev(dev)->ana_grpid);
+ }
+ DEVICE_ATTR_RO(ana_grpid);
+ 
+ static ssize_t ana_state_show(struct device *dev, struct device_attribute *attr,
+ 		char *buf)
+ {
+ 	struct nvme_ns *ns = nvme_get_ns_from_dev(dev);
+ 
+ 	return sprintf(buf, "%s\n", nvme_ana_state_names[ns->ana_state]);
+ }
+ DEVICE_ATTR_RO(ana_state);
+ 
+ static int nvme_set_ns_ana_state(struct nvme_ctrl *ctrl,
+ 		struct nvme_ana_group_desc *desc, void *data)
+ {
+ 	struct nvme_ns *ns = data;
+ 
+ 	if (ns->ana_grpid == le32_to_cpu(desc->grpid)) {
+ 		nvme_update_ns_ana_state(desc, ns);
+ 		return -ENXIO; /* just break out of the loop */
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ void nvme_mpath_add_disk(struct nvme_ns *ns, struct nvme_id_ns *id)
+ {
+ 	if (nvme_ctrl_use_ana(ns->ctrl)) {
+ 		mutex_lock(&ns->ctrl->ana_lock);
+ 		ns->ana_grpid = le32_to_cpu(id->anagrpid);
+ 		nvme_parse_ana_log(ns->ctrl, ns, nvme_set_ns_ana_state);
+ 		mutex_unlock(&ns->ctrl->ana_lock);
+ 	} else {
+ 		mutex_lock(&ns->head->lock);
+ 		ns->ana_state = NVME_ANA_OPTIMIZED; 
+ 		nvme_mpath_set_live(ns);
+ 		mutex_unlock(&ns->head->lock);
++>>>>>>> cc2278c413c3 (nvme-multipath: relax ANA state check)
  	}
 +	mutex_unlock(&head->subsys->lock);
  }
  
  void nvme_mpath_remove_disk(struct nvme_ns_head *head)
* Unmerged path drivers/nvme/host/multipath.c
