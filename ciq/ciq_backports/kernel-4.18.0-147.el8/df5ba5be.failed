kernel/sched/psi.c: expose pressure metrics on root cgroup

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Dan Schatzberg <dschatzberg@fb.com>
commit df5ba5be7425e1df296d40c5f37a39d98ec666a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/df5ba5be.failed

Pressure metrics are already recorded and exposed in procfs for the
entire system, but any tool which monitors cgroup pressure has to
special case the root cgroup to read from procfs.  This patch exposes
the already recorded pressure metrics on the root cgroup.

Link: http://lkml.kernel.org/r/20190510174938.3361741-1-dschatzberg@fb.com
	Signed-off-by: Dan Schatzberg <dschatzberg@fb.com>
	Acked-by: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Tejun Heo <tj@kernel.org>
	Cc: Li Zefan <lizefan@huawei.com>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit df5ba5be7425e1df296d40c5f37a39d98ec666a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/psi.h
#	kernel/cgroup/cgroup.c
#	kernel/sched/psi.c
diff --cc kernel/cgroup/cgroup.c
index 0344a4e6701f,217cec4e22c6..000000000000
--- a/kernel/cgroup/cgroup.c
+++ b/kernel/cgroup/cgroup.c
@@@ -3481,6 -3537,122 +3481,125 @@@ static int cpu_stat_show(struct seq_fil
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_PSI
+ static int cgroup_io_pressure_show(struct seq_file *seq, void *v)
+ {
+ 	struct cgroup *cgroup = seq_css(seq)->cgroup;
+ 	struct psi_group *psi = cgroup->id == 1 ? &psi_system : &cgroup->psi;
+ 
+ 	return psi_show(seq, psi, PSI_IO);
+ }
+ static int cgroup_memory_pressure_show(struct seq_file *seq, void *v)
+ {
+ 	struct cgroup *cgroup = seq_css(seq)->cgroup;
+ 	struct psi_group *psi = cgroup->id == 1 ? &psi_system : &cgroup->psi;
+ 
+ 	return psi_show(seq, psi, PSI_MEM);
+ }
+ static int cgroup_cpu_pressure_show(struct seq_file *seq, void *v)
+ {
+ 	struct cgroup *cgroup = seq_css(seq)->cgroup;
+ 	struct psi_group *psi = cgroup->id == 1 ? &psi_system : &cgroup->psi;
+ 
+ 	return psi_show(seq, psi, PSI_CPU);
+ }
+ 
+ static ssize_t cgroup_pressure_write(struct kernfs_open_file *of, char *buf,
+ 					  size_t nbytes, enum psi_res res)
+ {
+ 	struct psi_trigger *new;
+ 	struct cgroup *cgrp;
+ 
+ 	cgrp = cgroup_kn_lock_live(of->kn, false);
+ 	if (!cgrp)
+ 		return -ENODEV;
+ 
+ 	cgroup_get(cgrp);
+ 	cgroup_kn_unlock(of->kn);
+ 
+ 	new = psi_trigger_create(&cgrp->psi, buf, nbytes, res);
+ 	if (IS_ERR(new)) {
+ 		cgroup_put(cgrp);
+ 		return PTR_ERR(new);
+ 	}
+ 
+ 	psi_trigger_replace(&of->priv, new);
+ 
+ 	cgroup_put(cgrp);
+ 
+ 	return nbytes;
+ }
+ 
+ static ssize_t cgroup_io_pressure_write(struct kernfs_open_file *of,
+ 					  char *buf, size_t nbytes,
+ 					  loff_t off)
+ {
+ 	return cgroup_pressure_write(of, buf, nbytes, PSI_IO);
+ }
+ 
+ static ssize_t cgroup_memory_pressure_write(struct kernfs_open_file *of,
+ 					  char *buf, size_t nbytes,
+ 					  loff_t off)
+ {
+ 	return cgroup_pressure_write(of, buf, nbytes, PSI_MEM);
+ }
+ 
+ static ssize_t cgroup_cpu_pressure_write(struct kernfs_open_file *of,
+ 					  char *buf, size_t nbytes,
+ 					  loff_t off)
+ {
+ 	return cgroup_pressure_write(of, buf, nbytes, PSI_CPU);
+ }
+ 
+ static __poll_t cgroup_pressure_poll(struct kernfs_open_file *of,
+ 					  poll_table *pt)
+ {
+ 	return psi_trigger_poll(&of->priv, of->file, pt);
+ }
+ 
+ static void cgroup_pressure_release(struct kernfs_open_file *of)
+ {
+ 	psi_trigger_replace(&of->priv, NULL);
+ }
+ #endif /* CONFIG_PSI */
+ 
+ static int cgroup_freeze_show(struct seq_file *seq, void *v)
+ {
+ 	struct cgroup *cgrp = seq_css(seq)->cgroup;
+ 
+ 	seq_printf(seq, "%d\n", cgrp->freezer.freeze);
+ 
+ 	return 0;
+ }
+ 
+ static ssize_t cgroup_freeze_write(struct kernfs_open_file *of,
+ 				   char *buf, size_t nbytes, loff_t off)
+ {
+ 	struct cgroup *cgrp;
+ 	ssize_t ret;
+ 	int freeze;
+ 
+ 	ret = kstrtoint(strstrip(buf), 0, &freeze);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (freeze < 0 || freeze > 1)
+ 		return -ERANGE;
+ 
+ 	cgrp = cgroup_kn_lock_live(of->kn, false);
+ 	if (!cgrp)
+ 		return -ENOENT;
+ 
+ 	cgroup_freeze(cgrp, freeze);
+ 
+ 	cgroup_kn_unlock(of->kn);
+ 
+ 	return nbytes;
+ }
+ 
++>>>>>>> df5ba5be7425 (kernel/sched/psi.c: expose pressure metrics on root cgroup)
  static int cgroup_file_open(struct kernfs_open_file *of)
  {
  	struct cftype *cft = of->kn->priv;
@@@ -4629,6 -4807,29 +4748,32 @@@ static struct cftype cgroup_base_files[
  		.flags = CFTYPE_NOT_ON_ROOT,
  		.seq_show = cpu_stat_show,
  	},
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_PSI
+ 	{
+ 		.name = "io.pressure",
+ 		.seq_show = cgroup_io_pressure_show,
+ 		.write = cgroup_io_pressure_write,
+ 		.poll = cgroup_pressure_poll,
+ 		.release = cgroup_pressure_release,
+ 	},
+ 	{
+ 		.name = "memory.pressure",
+ 		.seq_show = cgroup_memory_pressure_show,
+ 		.write = cgroup_memory_pressure_write,
+ 		.poll = cgroup_pressure_poll,
+ 		.release = cgroup_pressure_release,
+ 	},
+ 	{
+ 		.name = "cpu.pressure",
+ 		.seq_show = cgroup_cpu_pressure_show,
+ 		.write = cgroup_cpu_pressure_write,
+ 		.poll = cgroup_pressure_poll,
+ 		.release = cgroup_pressure_release,
+ 	},
+ #endif /* CONFIG_PSI */
++>>>>>>> df5ba5be7425 (kernel/sched/psi.c: expose pressure metrics on root cgroup)
  	{ }	/* terminate */
  };
  
* Unmerged path include/linux/psi.h
* Unmerged path kernel/sched/psi.c
* Unmerged path include/linux/psi.h
* Unmerged path kernel/cgroup/cgroup.c
* Unmerged path kernel/sched/psi.c
