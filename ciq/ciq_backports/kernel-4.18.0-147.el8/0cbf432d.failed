RDMA/uverbs: Use a linear list to describe the compiled-in uapi

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jason Gunthorpe <jgg@ziepe.ca>
commit 0cbf432db405289216747a8d31d74bab2452337c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/0cbf432d.failed

The 'tree' data structure is very hard to build at compile time, and this
makes it very limited. The new radix tree based compiler can handle a more
complex input language that does not require the compiler to perfectly
group everything into a neat tree structure.

Instead use a simple list to describe to input, where the list elements
can be of various different 'opcodes' instructing the radix compiler what
to do. Start out with opcodes chaining to other definition lists and
chaining to the existing 'tree' definition.

Replace the very top level of the 'object tree' with this list type and
get rid of struct uverbs_object_tree_def and DECLARE_UVERBS_OBJECT_TREE.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
(cherry picked from commit 0cbf432db405289216747a8d31d74bab2452337c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/rdma_core.h
#	drivers/infiniband/core/uverbs_main.c
#	drivers/infiniband/core/uverbs_std_types.c
#	drivers/infiniband/core/uverbs_uapi.c
#	drivers/infiniband/hw/mlx5/devx.c
#	drivers/infiniband/hw/mlx5/flow.c
#	drivers/infiniband/hw/mlx5/main.c
#	drivers/infiniband/hw/mlx5/mlx5_ib.h
#	include/rdma/ib_verbs.h
#	include/rdma/uverbs_ioctl.h
#	include/rdma/uverbs_named_ioctl.h
#	include/rdma/uverbs_std_types.h
diff --cc drivers/infiniband/core/rdma_core.h
index a243cc2a59f7,e39e9da1ff71..000000000000
--- a/drivers/infiniband/core/rdma_core.h
+++ b/drivers/infiniband/core/rdma_core.h
@@@ -113,4 -106,61 +113,64 @@@ int uverbs_finalize_object(struct ib_uo
  			   enum uverbs_obj_access access,
  			   bool commit);
  
++<<<<<<< HEAD
++=======
+ void setup_ufile_idr_uobject(struct ib_uverbs_file *ufile);
+ void release_ufile_idr_uobject(struct ib_uverbs_file *ufile);
+ 
+ /*
+  * This is the runtime description of the uverbs API, used by the syscall
+  * machinery to validate and dispatch calls.
+  */
+ 
+ /*
+  * Depending on ID the slot pointer in the radix tree points at one of these
+  * structs.
+  */
+ struct uverbs_api_object {
+ 	const struct uverbs_obj_type *type_attrs;
+ 	const struct uverbs_obj_type_class *type_class;
+ };
+ 
+ struct uverbs_api_ioctl_method {
+ 	int (__rcu *handler)(struct ib_uverbs_file *ufile,
+ 			     struct uverbs_attr_bundle *ctx);
+ 	DECLARE_BITMAP(attr_mandatory, UVERBS_API_ATTR_BKEY_LEN);
+ 	u16 bundle_size;
+ 	u8 use_stack:1;
+ 	u8 driver_method:1;
+ 	u8 key_bitmap_len;
+ 	u8 destroy_bkey;
+ };
+ 
+ struct uverbs_api_attr {
+ 	struct uverbs_attr_spec spec;
+ };
+ 
+ struct uverbs_api_object;
+ struct uverbs_api {
+ 	/* radix tree contains struct uverbs_api_* pointers */
+ 	struct radix_tree_root radix;
+ 	enum rdma_driver_id driver_id;
+ };
+ 
+ static inline const struct uverbs_api_object *
+ uapi_get_object(struct uverbs_api *uapi, u16 object_id)
+ {
+ 	return radix_tree_lookup(&uapi->radix, uapi_key_obj(object_id));
+ }
+ 
+ char *uapi_key_format(char *S, unsigned int key);
+ struct uverbs_api *uverbs_alloc_api(const struct uapi_definition *driver_def,
+ 				    enum rdma_driver_id driver_id);
+ void uverbs_disassociate_api_pre(struct ib_uverbs_device *uverbs_dev);
+ void uverbs_disassociate_api(struct uverbs_api *uapi);
+ void uverbs_destroy_api(struct uverbs_api *uapi);
+ void uapi_compute_bundle_size(struct uverbs_api_ioctl_method *method_elm,
+ 			      unsigned int num_attrs);
+ void uverbs_user_mmap_disassociate(struct ib_uverbs_file *ufile);
+ 
+ extern const struct uapi_definition uverbs_def_obj_intf[];
+ 
++>>>>>>> 0cbf432db405 (RDMA/uverbs: Use a linear list to describe the compiled-in uapi)
  #endif /* RDMA_CORE_H */
diff --cc drivers/infiniband/core/uverbs_main.c
index 495189811c27,9a3b88d0095a..000000000000
--- a/drivers/infiniband/core/uverbs_main.c
+++ b/drivers/infiniband/core/uverbs_main.c
@@@ -1002,6 -1219,19 +1002,22 @@@ static DEVICE_ATTR(abi_version, S_IRUGO
  static CLASS_ATTR_STRING(abi_version, S_IRUGO,
  			 __stringify(IB_USER_VERBS_ABI_VERSION));
  
++<<<<<<< HEAD
++=======
+ static int ib_uverbs_create_uapi(struct ib_device *device,
+ 				 struct ib_uverbs_device *uverbs_dev)
+ {
+ 	struct uverbs_api *uapi;
+ 
+ 	uapi = uverbs_alloc_api(device->driver_def, device->driver_id);
+ 	if (IS_ERR(uapi))
+ 		return PTR_ERR(uapi);
+ 
+ 	uverbs_dev->uapi = uapi;
+ 	return 0;
+ }
+ 
++>>>>>>> 0cbf432db405 (RDMA/uverbs: Use a linear list to describe the compiled-in uapi)
  static void ib_uverbs_add_one(struct ib_device *device)
  {
  	int devnum;
diff --cc drivers/infiniband/core/uverbs_std_types.c
index 06085446ffc0,2db188ed825f..000000000000
--- a/drivers/infiniband/core/uverbs_std_types.c
+++ b/drivers/infiniband/core/uverbs_std_types.c
@@@ -204,113 -215,69 +204,135 @@@ int uverbs_destroy_def_handler(struct i
  {
  	return 0;
  }
 -EXPORT_SYMBOL(uverbs_destroy_def_handler);
  
 -DECLARE_UVERBS_NAMED_OBJECT(
 -	UVERBS_OBJECT_COMP_CHANNEL,
 -	UVERBS_TYPE_ALLOC_FD(sizeof(struct ib_uverbs_completion_event_file),
 -			     uverbs_hot_unplug_completion_event_file,
 -			     &uverbs_event_fops,
 -			     "[infinibandevent]",
 -			     O_RDONLY));
 +/*
 + * This spec is used in order to pass information to the hardware driver in a
 + * legacy way. Every verb that could get driver specific data should get this
 + * spec.
 + */
 +const struct uverbs_attr_def uverbs_uhw_compat_in =
 +	UVERBS_ATTR_PTR_IN_SZ(UVERBS_ATTR_UHW_IN, UVERBS_ATTR_MIN_SIZE(0),
 +			      UA_FLAGS(UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO));
 +const struct uverbs_attr_def uverbs_uhw_compat_out =
 +	UVERBS_ATTR_PTR_OUT_SZ(UVERBS_ATTR_UHW_OUT, UVERBS_ATTR_MIN_SIZE(0),
 +			       UA_FLAGS(UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO));
 +
 +void create_udata(struct uverbs_attr_bundle *ctx, struct ib_udata *udata)
 +{
 +	/*
 +	 * This is for ease of conversion. The purpose is to convert all drivers
 +	 * to use uverbs_attr_bundle instead of ib_udata.
 +	 * Assume attr == 0 is input and attr == 1 is output.
 +	 */
 +	const struct uverbs_attr *uhw_in =
 +		uverbs_attr_get(ctx, UVERBS_ATTR_UHW_IN);
 +	const struct uverbs_attr *uhw_out =
 +		uverbs_attr_get(ctx, UVERBS_ATTR_UHW_OUT);
 +
 +	if (!IS_ERR(uhw_in)) {
 +		udata->inlen = uhw_in->ptr_attr.len;
 +		if (uverbs_attr_ptr_is_inline(uhw_in))
 +			udata->inbuf = &uhw_in->uattr->data;
 +		else
 +			udata->inbuf = u64_to_user_ptr(uhw_in->ptr_attr.data);
 +	} else {
 +		udata->inbuf = NULL;
 +		udata->inlen = 0;
 +	}
 +
 +	if (!IS_ERR(uhw_out)) {
 +		udata->outbuf = u64_to_user_ptr(uhw_out->ptr_attr.data);
 +		udata->outlen = uhw_out->ptr_attr.len;
 +	} else {
 +		udata->outbuf = NULL;
 +		udata->outlen = 0;
 +	}
 +}
 +
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_COMP_CHANNEL,
 +			    &UVERBS_TYPE_ALLOC_FD(0,
 +						  sizeof(struct ib_uverbs_completion_event_file),
 +						  uverbs_hot_unplug_completion_event_file,
 +						  &uverbs_event_fops,
 +						  "[infinibandevent]", O_RDONLY));
  
 -DECLARE_UVERBS_NAMED_OBJECT(
 -	UVERBS_OBJECT_QP,
 -	UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uqp_object), uverbs_free_qp));
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_QP,
 +			    &UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uqp_object), 0,
 +						      uverbs_free_qp));
  
  DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_MW,
 -			    UVERBS_TYPE_ALLOC_IDR(uverbs_free_mw));
 +			    &UVERBS_TYPE_ALLOC_IDR(0, uverbs_free_mw));
  
 -DECLARE_UVERBS_NAMED_OBJECT(
 -	UVERBS_OBJECT_SRQ,
 -	UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_usrq_object),
 -				 uverbs_free_srq));
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_SRQ,
 +			    &UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_usrq_object), 0,
 +						      uverbs_free_srq));
  
  DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_AH,
 -			    UVERBS_TYPE_ALLOC_IDR(uverbs_free_ah));
 +			    &UVERBS_TYPE_ALLOC_IDR(0, uverbs_free_ah));
  
 -DECLARE_UVERBS_NAMED_OBJECT(
 -	UVERBS_OBJECT_FLOW,
 -	UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uflow_object),
 -				 uverbs_free_flow));
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_FLOW,
 +			    &UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uflow_object),
 +						      0, uverbs_free_flow));
  
 -DECLARE_UVERBS_NAMED_OBJECT(
 -	UVERBS_OBJECT_WQ,
 -	UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uwq_object), uverbs_free_wq));
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_WQ,
 +			    &UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uwq_object), 0,
 +						      uverbs_free_wq));
  
  DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_RWQ_IND_TBL,
 -			    UVERBS_TYPE_ALLOC_IDR(uverbs_free_rwq_ind_tbl));
 +			    &UVERBS_TYPE_ALLOC_IDR(0, uverbs_free_rwq_ind_tbl));
  
 -DECLARE_UVERBS_NAMED_OBJECT(
 -	UVERBS_OBJECT_XRCD,
 -	UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uxrcd_object),
 -				 uverbs_free_xrcd));
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_XRCD,
 +			    &UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uxrcd_object), 0,
 +						      uverbs_free_xrcd));
  
  DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_PD,
 -			    UVERBS_TYPE_ALLOC_IDR(uverbs_free_pd));
 -
 -DECLARE_UVERBS_GLOBAL_METHODS(UVERBS_OBJECT_DEVICE);
 -
 +			    /* 2 is used in order to free the PD after MRs */
 +			    &UVERBS_TYPE_ALLOC_IDR(2, uverbs_free_pd));
 +
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_DEVICE, NULL);
 +
++<<<<<<< HEAD
 +static DECLARE_UVERBS_OBJECT_TREE(uverbs_default_objects,
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_DEVICE),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_PD),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_MR),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_COMP_CHANNEL),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_CQ),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_QP),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_AH),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_MW),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_SRQ),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_FLOW),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_WQ),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_RWQ_IND_TBL),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_XRCD),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_FLOW_ACTION),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_DM),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_COUNTERS));
 +
 +const struct uverbs_object_tree_def *uverbs_default_get_objects(void)
 +{
 +	return &uverbs_default_objects;
 +}
 +EXPORT_SYMBOL_GPL(uverbs_default_get_objects);
++=======
+ const struct uapi_definition uverbs_def_obj_intf[] = {
+ 	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_DEVICE),
+ 	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_PD),
+ 	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_MR),
+ 	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_COMP_CHANNEL),
+ 	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_CQ),
+ 	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_QP),
+ 	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_AH),
+ 	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_MW),
+ 	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_SRQ),
+ 	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_FLOW),
+ 	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_WQ),
+ 	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_RWQ_IND_TBL),
+ 	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_XRCD),
+ 	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_FLOW_ACTION),
+ 	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_DM),
+ 	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_COUNTERS),
+ 	{}
+ };
++>>>>>>> 0cbf432db405 (RDMA/uverbs: Use a linear list to describe the compiled-in uapi)
diff --cc drivers/infiniband/hw/mlx5/devx.c
index c7f8859c08ee,992aca00f53c..000000000000
--- a/drivers/infiniband/hw/mlx5/devx.c
+++ b/drivers/infiniband/hw/mlx5/devx.c
@@@ -428,47 -969,363 +428,382 @@@ obj_free
  	return err;
  }
  
 -static int UVERBS_HANDLER(MLX5_IB_METHOD_DEVX_OBJ_MODIFY)(
 -	struct ib_uverbs_file *file, struct uverbs_attr_bundle *attrs)
 -{
 -	void *cmd_in = uverbs_attr_get_alloced_ptr(attrs, MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_IN);
 -	int cmd_out_len = uverbs_attr_get_len(attrs,
 -					MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_OUT);
 -	struct ib_uobject *uobj = uverbs_attr_get_uobject(attrs,
 -							  MLX5_IB_ATTR_DEVX_OBJ_MODIFY_HANDLE);
 -	struct mlx5_ib_ucontext *c = to_mucontext(uobj->context);
 -	struct devx_obj *obj = uobj->object;
 -	void *cmd_out;
 -	int err;
 -	int uid;
 -
 -	uid = devx_get_uid(c, cmd_in);
 -	if (uid < 0)
 -		return uid;
 -
 -	if (!devx_is_obj_modify_cmd(cmd_in))
 -		return -EINVAL;
 -
 -	if (!devx_is_valid_obj_id(obj, cmd_in))
 -		return -EINVAL;
 -
 -	cmd_out = uverbs_zalloc(attrs, cmd_out_len);
 -	if (IS_ERR(cmd_out))
 -		return PTR_ERR(cmd_out);
 -
 +static DECLARE_UVERBS_NAMED_METHOD(MLX5_IB_METHOD_DEVX_OTHER,
 +	&UVERBS_ATTR_PTR_IN_SZ(MLX5_IB_ATTR_DEVX_OTHER_CMD_IN,
 +			       UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
 +			       UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY |
 +					UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO |
 +					UVERBS_ATTR_SPEC_F_ALLOC_AND_COPY)),
 +	&UVERBS_ATTR_PTR_OUT_SZ(MLX5_IB_ATTR_DEVX_OTHER_CMD_OUT,
 +				UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_out_cmd_hdr)),
 +				UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY |
 +					 UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO))
 +);
 +
 +static DECLARE_UVERBS_NAMED_METHOD(MLX5_IB_METHOD_DEVX_OBJ_CREATE,
 +	&UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_CREATE_HANDLE,
 +			 MLX5_IB_OBJECT_DEVX_OBJ,
 +			 UVERBS_ACCESS_NEW,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN_SZ(MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_IN,
 +			       UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
 +			       UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY |
 +					UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO |
 +					UVERBS_ATTR_SPEC_F_ALLOC_AND_COPY)),
 +	&UVERBS_ATTR_PTR_OUT_SZ(MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_OUT,
 +				UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_out_cmd_hdr)),
 +				UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY |
 +					 UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO)));
 +
 +static DECLARE_UVERBS_NAMED_METHOD(MLX5_IB_METHOD_DEVX_OBJ_DESTROY,
 +	&UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_DESTROY_HANDLE,
 +			 MLX5_IB_OBJECT_DEVX_OBJ,
 +			 UVERBS_ACCESS_DESTROY,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
 +
 +static DECLARE_UVERBS_GLOBAL_METHODS(MLX5_IB_OBJECT_DEVX,
 +	&UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OTHER));
 +
 +static DECLARE_UVERBS_NAMED_OBJECT(MLX5_IB_OBJECT_DEVX_OBJ,
 +	&UVERBS_TYPE_ALLOC_IDR(0, devx_obj_cleanup),
 +		&UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OBJ_CREATE),
 +		&UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OBJ_DESTROY));
 +
++<<<<<<< HEAD
 +static DECLARE_UVERBS_OBJECT_TREE(devx_objects,
 +	&UVERBS_OBJECT(MLX5_IB_OBJECT_DEVX),
 +	&UVERBS_OBJECT(MLX5_IB_OBJECT_DEVX_OBJ));
++=======
+ 	MLX5_SET(general_obj_in_cmd_hdr, cmd_in, uid, uid);
+ 	devx_set_umem_valid(cmd_in);
+ 
+ 	err = mlx5_cmd_exec(obj->mdev, cmd_in,
+ 			    uverbs_attr_get_len(attrs, MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_IN),
+ 			    cmd_out, cmd_out_len);
+ 	if (err)
+ 		return err;
+ 
+ 	return uverbs_copy_to(attrs, MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_OUT,
+ 			      cmd_out, cmd_out_len);
+ }
+ 
+ static int UVERBS_HANDLER(MLX5_IB_METHOD_DEVX_OBJ_QUERY)(
+ 	struct ib_uverbs_file *file, struct uverbs_attr_bundle *attrs)
+ {
+ 	void *cmd_in = uverbs_attr_get_alloced_ptr(attrs, MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_IN);
+ 	int cmd_out_len = uverbs_attr_get_len(attrs,
+ 					      MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_OUT);
+ 	struct ib_uobject *uobj = uverbs_attr_get_uobject(attrs,
+ 							  MLX5_IB_ATTR_DEVX_OBJ_QUERY_HANDLE);
+ 	struct mlx5_ib_ucontext *c = to_mucontext(uobj->context);
+ 	struct devx_obj *obj = uobj->object;
+ 	void *cmd_out;
+ 	int err;
+ 	int uid;
+ 
+ 	uid = devx_get_uid(c, cmd_in);
+ 	if (uid < 0)
+ 		return uid;
+ 
+ 	if (!devx_is_obj_query_cmd(cmd_in))
+ 		return -EINVAL;
+ 
+ 	if (!devx_is_valid_obj_id(obj, cmd_in))
+ 		return -EINVAL;
+ 
+ 	cmd_out = uverbs_zalloc(attrs, cmd_out_len);
+ 	if (IS_ERR(cmd_out))
+ 		return PTR_ERR(cmd_out);
+ 
+ 	MLX5_SET(general_obj_in_cmd_hdr, cmd_in, uid, uid);
+ 	err = mlx5_cmd_exec(obj->mdev, cmd_in,
+ 			    uverbs_attr_get_len(attrs, MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_IN),
+ 			    cmd_out, cmd_out_len);
+ 	if (err)
+ 		return err;
+ 
+ 	return uverbs_copy_to(attrs, MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_OUT,
+ 			      cmd_out, cmd_out_len);
+ }
+ 
+ static int devx_umem_get(struct mlx5_ib_dev *dev, struct ib_ucontext *ucontext,
+ 			 struct uverbs_attr_bundle *attrs,
+ 			 struct devx_umem *obj)
+ {
+ 	u64 addr;
+ 	size_t size;
+ 	u32 access;
+ 	int npages;
+ 	int err;
+ 	u32 page_mask;
+ 
+ 	if (uverbs_copy_from(&addr, attrs, MLX5_IB_ATTR_DEVX_UMEM_REG_ADDR) ||
+ 	    uverbs_copy_from(&size, attrs, MLX5_IB_ATTR_DEVX_UMEM_REG_LEN))
+ 		return -EFAULT;
+ 
+ 	err = uverbs_get_flags32(&access, attrs,
+ 				 MLX5_IB_ATTR_DEVX_UMEM_REG_ACCESS,
+ 				 IB_ACCESS_SUPPORTED);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ib_check_mr_access(access);
+ 	if (err)
+ 		return err;
+ 
+ 	obj->umem = ib_umem_get(ucontext, addr, size, access, 0);
+ 	if (IS_ERR(obj->umem))
+ 		return PTR_ERR(obj->umem);
+ 
+ 	mlx5_ib_cont_pages(obj->umem, obj->umem->address,
+ 			   MLX5_MKEY_PAGE_SHIFT_MASK, &npages,
+ 			   &obj->page_shift, &obj->ncont, NULL);
+ 
+ 	if (!npages) {
+ 		ib_umem_release(obj->umem);
+ 		return -EINVAL;
+ 	}
+ 
+ 	page_mask = (1 << obj->page_shift) - 1;
+ 	obj->page_offset = obj->umem->address & page_mask;
+ 
+ 	return 0;
+ }
+ 
+ static int devx_umem_reg_cmd_alloc(struct uverbs_attr_bundle *attrs,
+ 				   struct devx_umem *obj,
+ 				   struct devx_umem_reg_cmd *cmd)
+ {
+ 	cmd->inlen = MLX5_ST_SZ_BYTES(create_umem_in) +
+ 		    (MLX5_ST_SZ_BYTES(mtt) * obj->ncont);
+ 	cmd->in = uverbs_zalloc(attrs, cmd->inlen);
+ 	return PTR_ERR_OR_ZERO(cmd->in);
+ }
+ 
+ static void devx_umem_reg_cmd_build(struct mlx5_ib_dev *dev,
+ 				    struct devx_umem *obj,
+ 				    struct devx_umem_reg_cmd *cmd)
+ {
+ 	void *umem;
+ 	__be64 *mtt;
+ 
+ 	umem = MLX5_ADDR_OF(create_umem_in, cmd->in, umem);
+ 	mtt = (__be64 *)MLX5_ADDR_OF(umem, umem, mtt);
+ 
+ 	MLX5_SET(general_obj_in_cmd_hdr, cmd->in, opcode, MLX5_CMD_OP_CREATE_GENERAL_OBJECT);
+ 	MLX5_SET(general_obj_in_cmd_hdr, cmd->in, obj_type, MLX5_OBJ_TYPE_UMEM);
+ 	MLX5_SET64(umem, umem, num_of_mtt, obj->ncont);
+ 	MLX5_SET(umem, umem, log_page_size, obj->page_shift -
+ 					    MLX5_ADAPTER_PAGE_SHIFT);
+ 	MLX5_SET(umem, umem, page_offset, obj->page_offset);
+ 	mlx5_ib_populate_pas(dev, obj->umem, obj->page_shift, mtt,
+ 			     (obj->umem->writable ? MLX5_IB_MTT_WRITE : 0) |
+ 			     MLX5_IB_MTT_READ);
+ }
+ 
+ static int UVERBS_HANDLER(MLX5_IB_METHOD_DEVX_UMEM_REG)(
+ 	struct ib_uverbs_file *file, struct uverbs_attr_bundle *attrs)
+ {
+ 	struct devx_umem_reg_cmd cmd;
+ 	struct devx_umem *obj;
+ 	struct ib_uobject *uobj = uverbs_attr_get_uobject(
+ 		attrs, MLX5_IB_ATTR_DEVX_UMEM_REG_HANDLE);
+ 	u32 obj_id;
+ 	struct mlx5_ib_ucontext *c = to_mucontext(uobj->context);
+ 	struct mlx5_ib_dev *dev = to_mdev(c->ibucontext.device);
+ 	int err;
+ 
+ 	if (!c->devx_uid)
+ 		return -EINVAL;
+ 
+ 	if (!capable(CAP_NET_RAW))
+ 		return -EPERM;
+ 
+ 	obj = kzalloc(sizeof(struct devx_umem), GFP_KERNEL);
+ 	if (!obj)
+ 		return -ENOMEM;
+ 
+ 	err = devx_umem_get(dev, &c->ibucontext, attrs, obj);
+ 	if (err)
+ 		goto err_obj_free;
+ 
+ 	err = devx_umem_reg_cmd_alloc(attrs, obj, &cmd);
+ 	if (err)
+ 		goto err_umem_release;
+ 
+ 	devx_umem_reg_cmd_build(dev, obj, &cmd);
+ 
+ 	MLX5_SET(general_obj_in_cmd_hdr, cmd.in, uid, c->devx_uid);
+ 	err = mlx5_cmd_exec(dev->mdev, cmd.in, cmd.inlen, cmd.out,
+ 			    sizeof(cmd.out));
+ 	if (err)
+ 		goto err_umem_release;
+ 
+ 	obj->mdev = dev->mdev;
+ 	uobj->object = obj;
+ 	devx_obj_build_destroy_cmd(cmd.in, cmd.out, obj->dinbox, &obj->dinlen, &obj_id);
+ 	err = uverbs_copy_to(attrs, MLX5_IB_ATTR_DEVX_UMEM_REG_OUT_ID, &obj_id, sizeof(obj_id));
+ 	if (err)
+ 		goto err_umem_destroy;
+ 
+ 	return 0;
+ 
+ err_umem_destroy:
+ 	mlx5_cmd_exec(obj->mdev, obj->dinbox, obj->dinlen, cmd.out, sizeof(cmd.out));
+ err_umem_release:
+ 	ib_umem_release(obj->umem);
+ err_obj_free:
+ 	kfree(obj);
+ 	return err;
+ }
+ 
+ static int devx_umem_cleanup(struct ib_uobject *uobject,
+ 			     enum rdma_remove_reason why)
+ {
+ 	struct devx_umem *obj = uobject->object;
+ 	u32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)];
+ 	int err;
+ 
+ 	err = mlx5_cmd_exec(obj->mdev, obj->dinbox, obj->dinlen, out, sizeof(out));
+ 	if (ib_is_destroy_retryable(err, why, uobject))
+ 		return err;
+ 
+ 	ib_umem_release(obj->umem);
+ 	kfree(obj);
+ 	return 0;
+ }
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	MLX5_IB_METHOD_DEVX_UMEM_REG,
+ 	UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_UMEM_REG_HANDLE,
+ 			MLX5_IB_OBJECT_DEVX_UMEM,
+ 			UVERBS_ACCESS_NEW,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_DEVX_UMEM_REG_ADDR,
+ 			   UVERBS_ATTR_TYPE(u64),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_DEVX_UMEM_REG_LEN,
+ 			   UVERBS_ATTR_TYPE(u64),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_FLAGS_IN(MLX5_IB_ATTR_DEVX_UMEM_REG_ACCESS,
+ 			     enum ib_access_flags),
+ 	UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_DEVX_UMEM_REG_OUT_ID,
+ 			    UVERBS_ATTR_TYPE(u32),
+ 			    UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD_DESTROY(
+ 	MLX5_IB_METHOD_DEVX_UMEM_DEREG,
+ 	UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_UMEM_DEREG_HANDLE,
+ 			MLX5_IB_OBJECT_DEVX_UMEM,
+ 			UVERBS_ACCESS_DESTROY,
+ 			UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	MLX5_IB_METHOD_DEVX_QUERY_EQN,
+ 	UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_DEVX_QUERY_EQN_USER_VEC,
+ 			   UVERBS_ATTR_TYPE(u32),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_DEVX_QUERY_EQN_DEV_EQN,
+ 			    UVERBS_ATTR_TYPE(u32),
+ 			    UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	MLX5_IB_METHOD_DEVX_QUERY_UAR,
+ 	UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_DEVX_QUERY_UAR_USER_IDX,
+ 			   UVERBS_ATTR_TYPE(u32),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_DEVX_QUERY_UAR_DEV_IDX,
+ 			    UVERBS_ATTR_TYPE(u32),
+ 			    UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	MLX5_IB_METHOD_DEVX_OTHER,
+ 	UVERBS_ATTR_PTR_IN(
+ 		MLX5_IB_ATTR_DEVX_OTHER_CMD_IN,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
+ 		UA_MANDATORY,
+ 		UA_ALLOC_AND_COPY),
+ 	UVERBS_ATTR_PTR_OUT(
+ 		MLX5_IB_ATTR_DEVX_OTHER_CMD_OUT,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_out_cmd_hdr)),
+ 		UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	MLX5_IB_METHOD_DEVX_OBJ_CREATE,
+ 	UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_CREATE_HANDLE,
+ 			MLX5_IB_OBJECT_DEVX_OBJ,
+ 			UVERBS_ACCESS_NEW,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(
+ 		MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_IN,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
+ 		UA_MANDATORY,
+ 		UA_ALLOC_AND_COPY),
+ 	UVERBS_ATTR_PTR_OUT(
+ 		MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_OUT,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_out_cmd_hdr)),
+ 		UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD_DESTROY(
+ 	MLX5_IB_METHOD_DEVX_OBJ_DESTROY,
+ 	UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_DESTROY_HANDLE,
+ 			MLX5_IB_OBJECT_DEVX_OBJ,
+ 			UVERBS_ACCESS_DESTROY,
+ 			UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	MLX5_IB_METHOD_DEVX_OBJ_MODIFY,
+ 	UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_MODIFY_HANDLE,
+ 			MLX5_IB_OBJECT_DEVX_OBJ,
+ 			UVERBS_ACCESS_WRITE,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(
+ 		MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_IN,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
+ 		UA_MANDATORY,
+ 		UA_ALLOC_AND_COPY),
+ 	UVERBS_ATTR_PTR_OUT(
+ 		MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_OUT,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_out_cmd_hdr)),
+ 		UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	MLX5_IB_METHOD_DEVX_OBJ_QUERY,
+ 	UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_QUERY_HANDLE,
+ 			MLX5_IB_OBJECT_DEVX_OBJ,
+ 			UVERBS_ACCESS_READ,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(
+ 		MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_IN,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
+ 		UA_MANDATORY,
+ 		UA_ALLOC_AND_COPY),
+ 	UVERBS_ATTR_PTR_OUT(
+ 		MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_OUT,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_out_cmd_hdr)),
+ 		UA_MANDATORY));
+ 
+ DECLARE_UVERBS_GLOBAL_METHODS(MLX5_IB_OBJECT_DEVX,
+ 			      &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OTHER),
+ 			      &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_QUERY_UAR),
+ 			      &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_QUERY_EQN));
+ 
+ DECLARE_UVERBS_NAMED_OBJECT(MLX5_IB_OBJECT_DEVX_OBJ,
+ 			    UVERBS_TYPE_ALLOC_IDR(devx_obj_cleanup),
+ 			    &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OBJ_CREATE),
+ 			    &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OBJ_DESTROY),
+ 			    &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OBJ_MODIFY),
+ 			    &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OBJ_QUERY));
+ 
+ DECLARE_UVERBS_NAMED_OBJECT(MLX5_IB_OBJECT_DEVX_UMEM,
+ 			    UVERBS_TYPE_ALLOC_IDR(devx_umem_cleanup),
+ 			    &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_UMEM_REG),
+ 			    &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_UMEM_DEREG));
+ 
+ const struct uapi_definition mlx5_ib_devx_defs[] = {
+ 	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(MLX5_IB_OBJECT_DEVX),
+ 	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(MLX5_IB_OBJECT_DEVX_OBJ),
+ 	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(MLX5_IB_OBJECT_DEVX_UMEM),
+ 	{},
+ };
++>>>>>>> 0cbf432db405 (RDMA/uverbs: Use a linear list to describe the compiled-in uapi)
diff --cc drivers/infiniband/hw/mlx5/main.c
index 72ce00f38f1d,30a35a8ae0bb..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -5262,45 -5532,54 +5262,76 @@@ static void mlx5_ib_cleanup_multiport_m
  	mlx5_nic_vport_disable_roce(dev->mdev);
  }
  
 -ADD_UVERBS_ATTRIBUTES_SIMPLE(
 -	mlx5_ib_dm,
 -	UVERBS_OBJECT_DM,
 -	UVERBS_METHOD_DM_ALLOC,
 -	UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_ALLOC_DM_RESP_START_OFFSET,
 -			    UVERBS_ATTR_TYPE(u64),
 -			    UA_MANDATORY),
 -	UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_ALLOC_DM_RESP_PAGE_INDEX,
 -			    UVERBS_ATTR_TYPE(u16),
 -			    UA_MANDATORY));
 -
 -ADD_UVERBS_ATTRIBUTES_SIMPLE(
 -	mlx5_ib_flow_action,
 -	UVERBS_OBJECT_FLOW_ACTION,
 -	UVERBS_METHOD_FLOW_ACTION_ESP_CREATE,
 -	UVERBS_ATTR_FLAGS_IN(MLX5_IB_ATTR_CREATE_FLOW_ACTION_FLAGS,
 -			     enum mlx5_ib_uapi_flow_action_flags));
 +ADD_UVERBS_ATTRIBUTES_SIMPLE(mlx5_ib_dm, UVERBS_OBJECT_DM,
 +			     UVERBS_METHOD_DM_ALLOC,
 +			     &UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_ALLOC_DM_RESP_START_OFFSET,
 +						  UVERBS_ATTR_TYPE(u64),
 +						  UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +			     &UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_ALLOC_DM_RESP_PAGE_INDEX,
 +						  UVERBS_ATTR_TYPE(u16),
 +						  UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
 +
 +ADD_UVERBS_ATTRIBUTES_SIMPLE(mlx5_ib_flow_action, UVERBS_OBJECT_FLOW_ACTION,
 +			     UVERBS_METHOD_FLOW_ACTION_ESP_CREATE,
 +			     &UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_CREATE_FLOW_ACTION_FLAGS,
 +						 UVERBS_ATTR_TYPE(u64),
 +						 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
 +
++<<<<<<< HEAD
 +#define NUM_TREES	2
 +static int populate_specs_root(struct mlx5_ib_dev *dev)
 +{
 +	const struct uverbs_object_tree_def *default_root[NUM_TREES + 1] = {
 +		uverbs_default_get_objects()};
 +	size_t num_trees = 1;
 +
 +	if (mlx5_accel_ipsec_device_caps(dev->mdev) & MLX5_ACCEL_IPSEC_CAP_DEVICE &&
 +	    !WARN_ON(num_trees >= ARRAY_SIZE(default_root)))
 +		default_root[num_trees++] = &mlx5_ib_flow_action;
 +
 +	if (MLX5_CAP_DEV_MEM(dev->mdev, memic) &&
 +	    !WARN_ON(num_trees >= ARRAY_SIZE(default_root)))
 +		default_root[num_trees++] = &mlx5_ib_dm;
 +
 +	dev->ib_dev.specs_root =
 +		uverbs_alloc_spec_tree(num_trees, default_root);
  
 +	return PTR_ERR_OR_ZERO(dev->ib_dev.specs_root);
 +}
++=======
+ static const struct uapi_definition mlx5_ib_defs[] = {
+ #if IS_ENABLED(CONFIG_INFINIBAND_USER_ACCESS)
+ 	UAPI_DEF_CHAIN(mlx5_ib_flow_defs),
+ #endif
+ 
+ 	UAPI_DEF_CHAIN_OBJ_TREE(UVERBS_OBJECT_FLOW_ACTION,
+ 				&mlx5_ib_flow_action),
+ 	UAPI_DEF_CHAIN_OBJ_TREE(UVERBS_OBJECT_DM, &mlx5_ib_dm),
+ 	{}
+ };
+ 
+ static int populate_specs_root(struct mlx5_ib_dev *dev)
+ {
+ 	struct uapi_definition *defs = dev->driver_defs;
+ 
+ #if IS_ENABLED(CONFIG_INFINIBAND_USER_ACCESS)
+ 	if (MLX5_CAP_GEN_64(dev->mdev, general_obj_types) &
+ 	    MLX5_GENERAL_OBJ_TYPES_CAP_UCTX)
+ 		*defs++ = (struct uapi_definition)UAPI_DEF_CHAIN(
+ 			mlx5_ib_devx_defs);
+ #endif
+ 
+ 	*defs++ = (struct uapi_definition)UAPI_DEF_CHAIN(mlx5_ib_defs);
+ 	*defs++ = (struct uapi_definition){};
+ 	WARN_ON(defs - dev->driver_defs >= ARRAY_SIZE(dev->driver_defs));
+ 
+ 	if (IS_ENABLED(CONFIG_INFINIBAND_USER_ACCESS))
+ 		dev->ib_dev.driver_def = dev->driver_defs;
++>>>>>>> 0cbf432db405 (RDMA/uverbs: Use a linear list to describe the compiled-in uapi)
  
 -	return 0;
 +static void depopulate_specs_root(struct mlx5_ib_dev *dev)
 +{
 +	uverbs_free_spec_tree(dev->ib_dev.specs_root);
  }
  
  static int mlx5_ib_read_counters(struct ib_counters *counters,
diff --cc drivers/infiniband/hw/mlx5/mlx5_ib.h
index bc0aa5141161,3663664ecee8..000000000000
--- a/drivers/infiniband/hw/mlx5/mlx5_ib.h
+++ b/drivers/infiniband/hw/mlx5/mlx5_ib.h
@@@ -845,8 -872,26 +845,12 @@@ to_mcounters(struct ib_counters *ibcntr
  int parse_flow_flow_action(struct mlx5_ib_flow_action *maction,
  			   bool is_egress,
  			   struct mlx5_flow_act *action);
 -struct mlx5_ib_lb_state {
 -	/* protect the user_td */
 -	struct mutex		mutex;
 -	u32			user_td;
 -	int			qps;
 -	bool			enabled;
 -};
 -
 -struct mlx5_ib_pf_eq {
 -	struct mlx5_ib_dev *dev;
 -	struct mlx5_eq *core;
 -	struct work_struct work;
 -	spinlock_t lock; /* Pagefaults spinlock */
 -	struct workqueue_struct *wq;
 -	mempool_t *pool;
 -};
 -
  struct mlx5_ib_dev {
  	struct ib_device		ib_dev;
++<<<<<<< HEAD
++=======
+ 	struct uapi_definition		driver_defs[7];
++>>>>>>> 0cbf432db405 (RDMA/uverbs: Use a linear list to describe the compiled-in uapi)
  	struct mlx5_core_dev		*mdev;
  	struct mlx5_roce		roce[MLX5_MAX_PORTS];
  	int				num_ports;
@@@ -1212,16 -1261,31 +1216,44 @@@ void mlx5_ib_put_native_port_mdev(struc
  				  u8 port_num);
  
  #if IS_ENABLED(CONFIG_INFINIBAND_USER_ACCESS)
++<<<<<<< HEAD
 +int mlx5_ib_devx_create(struct mlx5_ib_dev *dev,
 +			struct mlx5_ib_ucontext *context);
 +void mlx5_ib_devx_destroy(struct mlx5_ib_dev *dev,
 +			  struct mlx5_ib_ucontext *context);
 +#else
 +static inline int
 +mlx5_ib_devx_create(struct mlx5_ib_dev *dev,
 +		    struct mlx5_ib_ucontext *context) { return -EOPNOTSUPP; };
 +static inline void mlx5_ib_devx_destroy(struct mlx5_ib_dev *dev,
 +					struct mlx5_ib_ucontext *context) {}
++=======
+ int mlx5_ib_devx_create(struct mlx5_ib_dev *dev);
+ void mlx5_ib_devx_destroy(struct mlx5_ib_dev *dev, u16 uid);
+ const struct uverbs_object_tree_def *mlx5_ib_get_devx_tree(void);
+ extern const struct uapi_definition mlx5_ib_devx_defs[];
+ extern const struct uapi_definition mlx5_ib_flow_defs[];
+ struct mlx5_ib_flow_handler *mlx5_ib_raw_fs_rule_add(
+ 	struct mlx5_ib_dev *dev, struct mlx5_ib_flow_matcher *fs_matcher,
+ 	struct mlx5_flow_act *flow_act, void *cmd_in, int inlen,
+ 	int dest_id, int dest_type);
+ bool mlx5_ib_devx_is_flow_dest(void *obj, int *dest_id, int *dest_type);
+ void mlx5_ib_destroy_flow_action_raw(struct mlx5_ib_flow_action *maction);
+ #else
+ static inline int
+ mlx5_ib_devx_create(struct mlx5_ib_dev *dev) { return -EOPNOTSUPP; };
+ static inline void mlx5_ib_devx_destroy(struct mlx5_ib_dev *dev, u16 uid) {}
+ static inline bool mlx5_ib_devx_is_flow_dest(void *obj, int *dest_id,
+ 					     int *dest_type)
+ {
+ 	return false;
+ }
+ static inline void
+ mlx5_ib_destroy_flow_action_raw(struct mlx5_ib_flow_action *maction)
+ {
+ 	return;
+ };
++>>>>>>> 0cbf432db405 (RDMA/uverbs: Use a linear list to describe the compiled-in uapi)
  #endif
  static inline void init_query_mad(struct ib_smp *mad)
  {
diff --cc include/rdma/ib_verbs.h
index 7d63f1ad4c1e,1af7bf34c04c..000000000000
--- a/include/rdma/ib_verbs.h
+++ b/include/rdma/ib_verbs.h
@@@ -2856,15 -2600,8 +2856,19 @@@ struct ib_device 
  	const struct cpumask *(*get_vector_affinity)(struct ib_device *ibdev,
  						     int comp_vector);
  
++<<<<<<< HEAD
 +	struct uverbs_root_spec		*specs_root;
++=======
+ 	const struct uapi_definition   *driver_def;
++>>>>>>> 0cbf432db405 (RDMA/uverbs: Use a linear list to describe the compiled-in uapi)
  	enum rdma_driver_id		driver_id;
 +
 +	/*
 +	 * Positive refcount indicates that the device is currently
 +	 * registered and cannot be unregistered.
 +	 */
 +	refcount_t refcount;
 +	struct completion unreg_completion;
  };
  
  struct ib_client {
diff --cc include/rdma/uverbs_ioctl.h
index 90a4947ff548,9fa0cca45783..000000000000
--- a/include/rdma/uverbs_ioctl.h
+++ b/include/rdma/uverbs_ioctl.h
@@@ -191,137 -296,179 +191,192 @@@ struct uverbs_object_def 
  	const struct uverbs_method_def * const (*methods)[];
  };
  
- struct uverbs_object_tree_def {
- 	size_t					 num_objects;
- 	const struct uverbs_object_def * const (*objects)[];
+ enum uapi_definition_kind {
+ 	UAPI_DEF_END = 0,
+ 	UAPI_DEF_CHAIN_OBJ_TREE,
+ 	UAPI_DEF_CHAIN,
  };
  
++<<<<<<< HEAD
 +#define UA_FLAGS(_flags)  .flags = _flags
 +#define __UVERBS_ATTR0(_id, _type, _fld, _attr, ...)              \
 +	((const struct uverbs_attr_def)				  \
 +	 {.id = _id, .attr = {{._fld = {.type = _type, _attr, .flags = 0, } }, } })
 +#define __UVERBS_ATTR1(_id, _type, _fld, _attr, _extra1, ...)      \
 +	((const struct uverbs_attr_def)				  \
 +	 {.id = _id, .attr = {{._fld = {.type = _type, _attr, _extra1 } },} })
 +#define __UVERBS_ATTR2(_id, _type, _fld, _attr, _extra1, _extra2)    \
 +	((const struct uverbs_attr_def)				  \
 +	 {.id = _id, .attr = {{._fld = {.type = _type, _attr, _extra1, _extra2 } },} })
 +#define __UVERBS_ATTR(_id, _type, _fld, _attr, _extra1, _extra2, _n, ...)	\
 +	__UVERBS_ATTR##_n(_id, _type, _fld, _attr, _extra1, _extra2)
++=======
+ struct uapi_definition {
+ 	u8 kind;
+ 	union {
+ 		struct {
+ 			u16 object_id;
+ 		} object_start;
+ 	};
+ 
+ 	union {
+ 		const struct uapi_definition *chain;
+ 		const struct uverbs_object_def *chain_obj_tree;
+ 	};
+ };
+ 
+ /* Include another struct uapi_definition in this one */
+ #define UAPI_DEF_CHAIN(_def_var)                                               \
+ 	{                                                                      \
+ 		.kind = UAPI_DEF_CHAIN, .chain = _def_var,                     \
+ 	}
+ 
+ /* Temporary until the tree base description is replaced */
+ #define UAPI_DEF_CHAIN_OBJ_TREE(_object_enum, _object_ptr)                     \
+ 	{                                                                      \
+ 		.kind = UAPI_DEF_CHAIN_OBJ_TREE,                               \
+ 		.object_start = { .object_id = _object_enum },                 \
+ 		.chain_obj_tree = _object_ptr,                                 \
+ 	}
+ #define UAPI_DEF_CHAIN_OBJ_TREE_NAMED(_object_enum, ...)                       \
+ 	UAPI_DEF_CHAIN_OBJ_TREE(_object_enum, &UVERBS_OBJECT(_object_enum)),   \
+ 		##__VA_ARGS__
+ 
+ /*
+  * =======================================
+  *	Attribute Specifications
+  * =======================================
+  */
++>>>>>>> 0cbf432db405 (RDMA/uverbs: Use a linear list to describe the compiled-in uapi)
  
 -#define UVERBS_ATTR_SIZE(_min_len, _len)			\
 -	.u.ptr.min_len = _min_len, .u.ptr.len = _len
 -
 -#define UVERBS_ATTR_NO_DATA() UVERBS_ATTR_SIZE(0, 0)
 -
 -/*
 - * Specifies a uapi structure that cannot be extended. The user must always
 - * supply the whole structure and nothing more. The structure must be declared
 - * in a header under include/uapi/rdma.
 - */
  #define UVERBS_ATTR_TYPE(_type)					\
 -	.u.ptr.min_len = sizeof(_type), .u.ptr.len = sizeof(_type)
 -/*
 - * Specifies a uapi structure where the user must provide at least up to
 - * member 'last'.  Anything after last and up until the end of the structure
 - * can be non-zero, anything longer than the end of the structure must be
 - * zero. The structure must be declared in a header under include/uapi/rdma.
 - */
 -#define UVERBS_ATTR_STRUCT(_type, _last)                                       \
 -	.zero_trailing = 1,                                                    \
 -	UVERBS_ATTR_SIZE(((uintptr_t)(&((_type *)0)->_last + 1)),              \
 -			 sizeof(_type))
 -/*
 - * Specifies at least min_len bytes must be passed in, but the amount can be
 - * larger, up to the protocol maximum size. No check for zeroing is done.
 - */
 -#define UVERBS_ATTR_MIN_SIZE(_min_len) UVERBS_ATTR_SIZE(_min_len, USHRT_MAX)
 -
 -/* Must be used in the '...' of any UVERBS_ATTR */
 -#define UA_ALLOC_AND_COPY .alloc_and_copy = 1
 -#define UA_MANDATORY .mandatory = 1
 -#define UA_OPTIONAL .mandatory = 0
 +	.min_len = sizeof(_type), .len = sizeof(_type)
 +#define UVERBS_ATTR_STRUCT(_type, _last)			\
 +	.min_len = ((uintptr_t)(&((_type *)0)->_last + 1)), .len = sizeof(_type)
 +#define UVERBS_ATTR_SIZE(_min_len, _len)			\
 +	.min_len = _min_len, .len = _len
 +#define UVERBS_ATTR_MIN_SIZE(_min_len)				\
 +	UVERBS_ATTR_SIZE(_min_len, USHRT_MAX)
  
  /*
 - * min_len must be bigger than 0 and _max_len must be smaller than 4095.  Only
 - * READ\WRITE accesses are supported.
 + * In new compiler, UVERBS_ATTR could be simplified by declaring it as
 + * [_id] = {.type = _type, .len = _len, ##__VA_ARGS__}
 + * But since we support older compilers too, we need the more complex code.
   */
 -#define UVERBS_ATTR_IDRS_ARR(_attr_id, _idr_type, _access, _min_len, _max_len, \
 -			     ...)                                              \
 -	(&(const struct uverbs_attr_def){                                      \
 -		.id = (_attr_id) +                                             \
 -		      BUILD_BUG_ON_ZERO((_min_len) == 0 ||                     \
 -					(_max_len) >                           \
 -						PAGE_SIZE / sizeof(void *) ||  \
 -					(_min_len) > (_max_len) ||             \
 -					(_access) == UVERBS_ACCESS_NEW ||      \
 -					(_access) == UVERBS_ACCESS_DESTROY),   \
 -		.attr = { .type = UVERBS_ATTR_TYPE_IDRS_ARRAY,                 \
 -			  .u2.objs_arr.obj_type = _idr_type,                   \
 -			  .u2.objs_arr.access = _access,                       \
 -			  .u2.objs_arr.min_len = _min_len,                     \
 -			  .u2.objs_arr.max_len = _max_len,                     \
 -			  __VA_ARGS__ } })
 -
 -#define UVERBS_ATTR_IDR(_attr_id, _idr_type, _access, ...)                     \
 -	(&(const struct uverbs_attr_def){                                      \
 -		.id = _attr_id,                                                \
 -		.attr = { .type = UVERBS_ATTR_TYPE_IDR,                        \
 -			  .u.obj.obj_type = _idr_type,                         \
 -			  .u.obj.access = _access,                             \
 -			  __VA_ARGS__ } })
 -
 -#define UVERBS_ATTR_FD(_attr_id, _fd_type, _access, ...)                       \
 -	(&(const struct uverbs_attr_def){                                      \
 -		.id = (_attr_id) +                                             \
 -		      BUILD_BUG_ON_ZERO((_access) != UVERBS_ACCESS_NEW &&      \
 -					(_access) != UVERBS_ACCESS_READ),      \
 -		.attr = { .type = UVERBS_ATTR_TYPE_FD,                         \
 -			  .u.obj.obj_type = _fd_type,                          \
 -			  .u.obj.access = _access,                             \
 -			  __VA_ARGS__ } })
 -
 -#define UVERBS_ATTR_PTR_IN(_attr_id, _type, ...)                               \
 -	(&(const struct uverbs_attr_def){                                      \
 -		.id = _attr_id,                                                \
 -		.attr = { .type = UVERBS_ATTR_TYPE_PTR_IN,                     \
 -			  _type,                                               \
 -			  __VA_ARGS__ } })
 -
 -#define UVERBS_ATTR_PTR_OUT(_attr_id, _type, ...)                              \
 -	(&(const struct uverbs_attr_def){                                      \
 -		.id = _attr_id,                                                \
 -		.attr = { .type = UVERBS_ATTR_TYPE_PTR_OUT,                    \
 -			  _type,                                               \
 -			  __VA_ARGS__ } })
 -
 -/* _enum_arry should be a 'static const union uverbs_attr_spec[]' */
 -#define UVERBS_ATTR_ENUM_IN(_attr_id, _enum_arr, ...)                          \
 -	(&(const struct uverbs_attr_def){                                      \
 -		.id = _attr_id,                                                \
 -		.attr = { .type = UVERBS_ATTR_TYPE_ENUM_IN,                    \
 -			  .u2.enum_def.ids = _enum_arr,                        \
 -			  .u.enum_def.num_elems = ARRAY_SIZE(_enum_arr),       \
 -			  __VA_ARGS__ },                                       \
 -	})
 -
 -/* An input value that is a member in the enum _enum_type. */
 -#define UVERBS_ATTR_CONST_IN(_attr_id, _enum_type, ...)                        \
 -	UVERBS_ATTR_PTR_IN(                                                    \
 -		_attr_id,                                                      \
 -		UVERBS_ATTR_SIZE(                                              \
 -			sizeof(u64) + BUILD_BUG_ON_ZERO(!sizeof(_enum_type)),  \
 -			sizeof(u64)),                                          \
 -		__VA_ARGS__)
 +#define UVERBS_ATTR(_id, _type, _fld, _attr, ...)			\
 +	__UVERBS_ATTR(_id, _type, _fld, _attr, ##__VA_ARGS__, 2, 1, 0)
 +#define UVERBS_ATTR_PTR_IN_SZ(_id, _len, ...)				\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_PTR_IN, ptr, _len, ##__VA_ARGS__)
 +/* If sizeof(_type) <= sizeof(u64), this will be inlined rather than a pointer */
 +#define UVERBS_ATTR_PTR_IN(_id, _type, ...)				\
 +	UVERBS_ATTR_PTR_IN_SZ(_id, _type, ##__VA_ARGS__)
 +#define UVERBS_ATTR_PTR_OUT_SZ(_id, _len, ...)				\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_PTR_OUT, ptr, _len, ##__VA_ARGS__)
 +#define UVERBS_ATTR_PTR_OUT(_id, _type, ...)				\
 +	UVERBS_ATTR_PTR_OUT_SZ(_id, _type, ##__VA_ARGS__)
 +#define UVERBS_ATTR_ENUM_IN(_id, _enum_arr, ...)			\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_ENUM_IN, enum_def,		\
 +		    .ids = (_enum_arr),					\
 +		    .num_elems = ARRAY_SIZE(_enum_arr), ##__VA_ARGS__)
  
  /*
 - * An input value that is a bitwise combination of values of _enum_type.
 - * This permits the flag value to be passed as either a u32 or u64, it must
 - * be retrieved via uverbs_get_flag().
 + * In new compiler, UVERBS_ATTR_IDR (and FD) could be simplified by declaring
 + * it as
 + * {.id = _id,								\
 + *  .attr {.type = __obj_class,						\
 + *         .obj = {.obj_type = _idr_type,				\
 + *                       .access = _access                              \
 + *                }, ##__VA_ARGS__ } }
 + * But since we support older compilers too, we need the more complex code.
   */
 -#define UVERBS_ATTR_FLAGS_IN(_attr_id, _enum_type, ...)                        \
 -	UVERBS_ATTR_PTR_IN(                                                    \
 -		_attr_id,                                                      \
 -		UVERBS_ATTR_SIZE(sizeof(u32) + BUILD_BUG_ON_ZERO(              \
 -						       !sizeof(_enum_type *)), \
 -				 sizeof(u64)),                                 \
 -		__VA_ARGS__)
 -
 +#define ___UVERBS_ATTR_OBJ0(_id, _obj_class, _obj_type, _access, ...)\
 +	((const struct uverbs_attr_def)					\
 +	{.id = _id,							\
 +	 .attr = { {.obj = {.type = _obj_class, .obj_type = _obj_type,	\
 +			    .access = _access, .flags = 0 } }, } })
 +#define ___UVERBS_ATTR_OBJ1(_id, _obj_class, _obj_type, _access, _flags)\
 +	((const struct uverbs_attr_def)					\
 +	{.id = _id,							\
 +	.attr = { {.obj = {.type = _obj_class, .obj_type = _obj_type,	\
 +			   .access = _access, _flags} }, } })
 +#define ___UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access, _flags, \
 +			   _n, ...)					\
 +	___UVERBS_ATTR_OBJ##_n(_id, _obj_class, _obj_type, _access, _flags)
 +#define __UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access, ...)	\
 +	___UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access,		\
 +			   ##__VA_ARGS__, 1, 0)
 +#define UVERBS_ATTR_IDR(_id, _idr_type, _access, ...)			 \
 +	__UVERBS_ATTR_OBJ(_id, UVERBS_ATTR_TYPE_IDR, _idr_type, _access,\
 +			  ##__VA_ARGS__)
 +#define UVERBS_ATTR_FD(_id, _fd_type, _access, ...)			\
 +	__UVERBS_ATTR_OBJ(_id, UVERBS_ATTR_TYPE_FD, _fd_type,		\
 +			  (_access) + BUILD_BUG_ON_ZERO(		\
 +				(_access) != UVERBS_ACCESS_NEW &&	\
 +				(_access) != UVERBS_ACCESS_READ),	\
 +			  ##__VA_ARGS__)
 +#define DECLARE_UVERBS_ATTR_SPEC(_name, ...)				\
 +	const struct uverbs_attr_def _name = __VA_ARGS__
 +
++<<<<<<< HEAD
 +#define DECLARE_UVERBS_ENUM(_name, ...)					\
 +	const struct uverbs_enum_spec _name = {				\
 +		.len = ARRAY_SIZE(((struct uverbs_attr_spec[]){__VA_ARGS__})),\
 +		.ids = {__VA_ARGS__},					\
 +	}
 +#define _UVERBS_METHOD_ATTRS_SZ(...)					\
 +	(sizeof((const struct uverbs_attr_def * const []){__VA_ARGS__}) /\
 +	 sizeof(const struct uverbs_attr_def *))
 +#define _UVERBS_METHOD(_id, _handler, _flags, ...)			\
 +	((const struct uverbs_method_def) {				\
 +	 .id = _id,							\
 +	 .flags = _flags,						\
 +	 .handler = _handler,						\
 +	 .num_attrs = _UVERBS_METHOD_ATTRS_SZ(__VA_ARGS__),		\
 +	 .attrs = &(const struct uverbs_attr_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_METHOD(_name, _id, _handler, ...)		\
 +	const struct uverbs_method_def _name =				\
 +		_UVERBS_METHOD(_id, _handler, 0, ##__VA_ARGS__)
 +#define DECLARE_UVERBS_CTX_METHOD(_name, _id, _handler, _flags, ...)	\
 +	const struct uverbs_method_def _name =				\
 +		_UVERBS_METHOD(_id, _handler,				\
 +			       UVERBS_ACTION_FLAG_CREATE_ROOT,		\
 +			       ##__VA_ARGS__)
 +#define _UVERBS_OBJECT_METHODS_SZ(...)					\
 +	(sizeof((const struct uverbs_method_def * const []){__VA_ARGS__}) / \
 +	 sizeof(const struct uverbs_method_def *))
 +#define _UVERBS_OBJECT(_id, _type_attrs, ...)				\
 +	((const struct uverbs_object_def) {				\
 +	 .id = _id,							\
 +	 .type_attrs = _type_attrs,					\
 +	 .num_methods = _UVERBS_OBJECT_METHODS_SZ(__VA_ARGS__),		\
 +	 .methods = &(const struct uverbs_method_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_OBJECT(_name, _id, _type_attrs, ...)		\
 +	const struct uverbs_object_def _name =				\
 +		_UVERBS_OBJECT(_id, _type_attrs, ##__VA_ARGS__)
 +#define _UVERBS_TREE_OBJECTS_SZ(...)					\
 +	(sizeof((const struct uverbs_object_def * const []){__VA_ARGS__}) / \
 +	 sizeof(const struct uverbs_object_def *))
 +#define _UVERBS_OBJECT_TREE(...)					\
 +	((const struct uverbs_object_tree_def) {			\
 +	 .num_objects = _UVERBS_TREE_OBJECTS_SZ(__VA_ARGS__),		\
 +	 .objects = &(const struct uverbs_object_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_OBJECT_TREE(_name, ...)				\
 +	const struct uverbs_object_tree_def _name =			\
 +		_UVERBS_OBJECT_TREE(__VA_ARGS__)
++=======
+ /*
+  * This spec is used in order to pass information to the hardware driver in a
+  * legacy way. Every verb that could get driver specific data should get this
+  * spec.
+  */
+ #define UVERBS_ATTR_UHW()                                                      \
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_UHW_IN,                                 \
+ 			   UVERBS_ATTR_MIN_SIZE(0),			       \
+ 			   UA_OPTIONAL),				       \
+ 	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_UHW_OUT,                               \
+ 			    UVERBS_ATTR_MIN_SIZE(0),			       \
+ 			    UA_OPTIONAL)
++>>>>>>> 0cbf432db405 (RDMA/uverbs: Use a linear list to describe the compiled-in uapi)
  
  /* =================================================
   *              Parsing infrastructure
diff --cc include/rdma/uverbs_named_ioctl.h
index 94863ed7644d,b586e7c41d4a..000000000000
--- a/include/rdma/uverbs_named_ioctl.h
+++ b/include/rdma/uverbs_named_ioctl.h
@@@ -43,52 -43,82 +43,87 @@@
  #define _UVERBS_NAME(x, y)	_UVERBS_PASTE(x, y)
  #define UVERBS_METHOD(id)	_UVERBS_NAME(UVERBS_MODULE_NAME, _method_##id)
  #define UVERBS_HANDLER(id)	_UVERBS_NAME(UVERBS_MODULE_NAME, _handler_##id)
 -#define UVERBS_OBJECT(id)	_UVERBS_NAME(UVERBS_MOUDLE_NAME, _object_##id)
 +#define UVERBS_OBJECT(id)	_UVERBS_NAME(UVERBS_MODULE_NAME, _object_##id)
  
 -/* These are static so they do not need to be qualified */
 -#define UVERBS_METHOD_ATTRS(method_id) _method_attrs_##method_id
 -#define UVERBS_OBJECT_METHODS(object_id) _object_methods_##object_id
 +#define DECLARE_UVERBS_NAMED_METHOD(id, ...)	\
 +	DECLARE_UVERBS_METHOD(UVERBS_METHOD(id), id, UVERBS_HANDLER(id), ##__VA_ARGS__)
  
 -#define DECLARE_UVERBS_NAMED_METHOD(_method_id, ...)                           \
 -	static const struct uverbs_attr_def *const UVERBS_METHOD_ATTRS(        \
 -		_method_id)[] = { __VA_ARGS__ };                               \
 -	static const struct uverbs_method_def UVERBS_METHOD(_method_id) = {    \
 -		.id = _method_id,                                              \
 -		.handler = UVERBS_HANDLER(_method_id),                         \
 -		.num_attrs = ARRAY_SIZE(UVERBS_METHOD_ATTRS(_method_id)),      \
 -		.attrs = &UVERBS_METHOD_ATTRS(_method_id),                     \
 -	}
 +#define DECLARE_UVERBS_NAMED_METHOD_WITH_HANDLER(id, handler, ...)	\
 +	DECLARE_UVERBS_METHOD(UVERBS_METHOD(id), id, handler, ##__VA_ARGS__)
  
 -/* Create a standard destroy method using the default handler. The handle_attr
 - * argument must be the attribute specifying the handle to destroy, the
 - * default handler does not support any other attributes.
 - */
 -#define DECLARE_UVERBS_NAMED_METHOD_DESTROY(_method_id, _handle_attr)          \
 -	static const struct uverbs_attr_def *const UVERBS_METHOD_ATTRS(        \
 -		_method_id)[] = { _handle_attr };                              \
 -	static const struct uverbs_method_def UVERBS_METHOD(_method_id) = {    \
 -		.id = _method_id,                                              \
 -		.handler = uverbs_destroy_def_handler,                         \
 -		.num_attrs = ARRAY_SIZE(UVERBS_METHOD_ATTRS(_method_id)),      \
 -		.attrs = &UVERBS_METHOD_ATTRS(_method_id),                     \
 -	}
 +#define DECLARE_UVERBS_NAMED_METHOD_NO_OVERRIDE(id, handler, ...)	\
 +	DECLARE_UVERBS_METHOD(UVERBS_METHOD(id), id, NULL, ##__VA_ARGS__)
  
 -#define DECLARE_UVERBS_NAMED_OBJECT(_object_id, _type_attrs, ...)              \
 -	static const struct uverbs_method_def *const UVERBS_OBJECT_METHODS(    \
 -		_object_id)[] = { __VA_ARGS__ };                               \
 -	const struct uverbs_object_def UVERBS_OBJECT(_object_id) = {           \
 -		.id = _object_id,                                              \
 -		.type_attrs = &_type_attrs,                                    \
 -		.num_methods = ARRAY_SIZE(UVERBS_OBJECT_METHODS(_object_id)),  \
 -		.methods = &UVERBS_OBJECT_METHODS(_object_id)                  \
 -	}
 +#define DECLARE_UVERBS_NAMED_OBJECT(id, ...)	\
 +	DECLARE_UVERBS_OBJECT(UVERBS_OBJECT(id), id, ##__VA_ARGS__)
  
 -/*
 - * Declare global methods. These still have a unique object_id because we
 - * identify all uapi methods with a (object,method) tuple. However, they have
 - * no type pointer.
 +#define DECLARE_UVERBS_GLOBAL_METHODS(_name, ...)	\
 +	DECLARE_UVERBS_NAMED_OBJECT(_name, NULL, ##__VA_ARGS__)
 +
 +#define _UVERBS_COMP_NAME(x, y, z) _UVERBS_NAME(_UVERBS_NAME(x, y), z)
 +
 +#define UVERBS_NO_OVERRIDE	NULL
 +
 +/* This declares a parsing tree with one object and one method. This is usually
 + * used for merging driver attributes to the common attributes. The driver has
 + * a chance to override the handler and type attrs of the original object.
 + * The __VA_ARGS__ just contains a list of attributes.
 + */
 +#define ADD_UVERBS_ATTRIBUTES(_name, _object, _method, _type_attrs, _handler, ...) \
 +static DECLARE_UVERBS_METHOD(_UVERBS_COMP_NAME(UVERBS_MODULE_NAME,	     \
 +					       _method_, _name),	     \
 +			     _method, _handler, ##__VA_ARGS__);		     \
 +									     \
 +static DECLARE_UVERBS_OBJECT(_UVERBS_COMP_NAME(UVERBS_MODULE_NAME,	     \
 +					       _object_, _name),	     \
 +			     _object, _type_attrs,			     \
 +			     &_UVERBS_COMP_NAME(UVERBS_MODULE_NAME,	     \
 +					       _method_, _name));	     \
 +									     \
 +static DECLARE_UVERBS_OBJECT_TREE(_name,				     \
 +				  &_UVERBS_COMP_NAME(UVERBS_MODULE_NAME,     \
 +						     _object_, _name))
 +
 +/* A very common use case is that the driver doesn't override the handler and
 + * type_attrs. Therefore, we provide a simplified macro for this common case.
   */
++<<<<<<< HEAD
 +#define ADD_UVERBS_ATTRIBUTES_SIMPLE(_name, _object, _method, ...)	     \
 +	ADD_UVERBS_ATTRIBUTES(_name, _object, _method, UVERBS_NO_OVERRIDE,   \
 +			      UVERBS_NO_OVERRIDE, ##__VA_ARGS__)
++=======
+ #define DECLARE_UVERBS_GLOBAL_METHODS(_object_id, ...)	\
+ 	static const struct uverbs_method_def *const UVERBS_OBJECT_METHODS(    \
+ 		_object_id)[] = { __VA_ARGS__ };                               \
+ 	const struct uverbs_object_def UVERBS_OBJECT(_object_id) = {           \
+ 		.id = _object_id,                                              \
+ 		.num_methods = ARRAY_SIZE(UVERBS_OBJECT_METHODS(_object_id)),  \
+ 		.methods = &UVERBS_OBJECT_METHODS(_object_id)                  \
+ 	}
+ 
+ /* Used by drivers to declare a complete parsing tree for new methods
+  */
+ #define ADD_UVERBS_METHODS(_name, _object_id, ...)                             \
+ 	static const struct uverbs_method_def *const UVERBS_OBJECT_METHODS(    \
+ 		_object_id)[] = { __VA_ARGS__ };                               \
+ 	static const struct uverbs_object_def _name = {                        \
+ 		.id = _object_id,                                              \
+ 		.num_methods = ARRAY_SIZE(UVERBS_OBJECT_METHODS(_object_id)),  \
+ 		.methods = &UVERBS_OBJECT_METHODS(_object_id)                  \
+ 	};
+ 
+ /* Used by drivers to declare a complete parsing tree for a single method that
+  * differs only in having additional driver specific attributes.
+  */
+ #define ADD_UVERBS_ATTRIBUTES_SIMPLE(_name, _object_id, _method_id, ...)       \
+ 	static const struct uverbs_attr_def *const UVERBS_METHOD_ATTRS(        \
+ 		_method_id)[] = { __VA_ARGS__ };                               \
+ 	static const struct uverbs_method_def UVERBS_METHOD(_method_id) = {    \
+ 		.id = _method_id,                                              \
+ 		.num_attrs = ARRAY_SIZE(UVERBS_METHOD_ATTRS(_method_id)),      \
+ 		.attrs = &UVERBS_METHOD_ATTRS(_method_id),                     \
+ 	};                                                                     \
+ 	ADD_UVERBS_METHODS(_name, _object_id, &UVERBS_METHOD(_method_id))
++>>>>>>> 0cbf432db405 (RDMA/uverbs: Use a linear list to describe the compiled-in uapi)
  
  #endif
diff --cc include/rdma/uverbs_std_types.h
index 27c24453fc12,e3154f8d3cda..000000000000
--- a/include/rdma/uverbs_std_types.h
+++ b/include/rdma/uverbs_std_types.h
@@@ -37,44 -37,57 +37,68 @@@
  #include <rdma/uverbs_ioctl.h>
  #include <rdma/ib_user_ioctl_verbs.h>
  
++<<<<<<< HEAD
 +#if IS_ENABLED(CONFIG_INFINIBAND_USER_ACCESS)
 +const struct uverbs_object_tree_def *uverbs_default_get_objects(void);
 +#else
 +static inline const struct uverbs_object_tree_def *uverbs_default_get_objects(void)
 +{
 +	return NULL;
 +}
 +#endif
 +
 +static inline struct ib_uobject *__uobj_get(const struct uverbs_obj_type *type,
 +					    bool write,
 +					    struct ib_ucontext *ucontext,
 +					    int id)
++=======
+ /* Returns _id, or causes a compile error if _id is not a u32.
+  *
+  * The uobj APIs should only be used with the write based uAPI to access
+  * object IDs. The write API must use a u32 for the object handle, which is
+  * checked by this macro.
+  */
+ #define _uobj_check_id(_id) ((_id) * typecheck(u32, _id))
+ 
+ #define uobj_get_type(_ufile, _object)                                         \
+ 	uapi_get_object((_ufile)->device->uapi, _object)
+ 
+ #define uobj_get_read(_type, _id, _ufile)                                      \
+ 	rdma_lookup_get_uobject(uobj_get_type(_ufile, _type), _ufile,          \
+ 				_uobj_check_id(_id), UVERBS_LOOKUP_READ)
+ 
+ #define ufd_get_read(_type, _fdnum, _ufile)                                    \
+ 	rdma_lookup_get_uobject(uobj_get_type(_ufile, _type), _ufile,          \
+ 				(_fdnum)*typecheck(s32, _fdnum),               \
+ 				UVERBS_LOOKUP_READ)
+ 
+ static inline void *_uobj_get_obj_read(struct ib_uobject *uobj)
++>>>>>>> 0cbf432db405 (RDMA/uverbs: Use a linear list to describe the compiled-in uapi)
  {
 -	if (IS_ERR(uobj))
 -		return NULL;
 -	return uobj->object;
 +	return rdma_lookup_get_uobject(type, ucontext, id, write);
  }
 -#define uobj_get_obj_read(_object, _type, _id, _ufile)                         \
 -	((struct ib_##_object *)_uobj_get_obj_read(                            \
 -		uobj_get_read(_type, _id, _ufile)))
  
 -#define uobj_get_write(_type, _id, _ufile)                                     \
 -	rdma_lookup_get_uobject(uobj_get_type(_ufile, _type), _ufile,          \
 -				_uobj_check_id(_id), UVERBS_LOOKUP_WRITE)
 +#define uobj_get_type(_object) UVERBS_OBJECT(_object).type_attrs
  
 -int __uobj_perform_destroy(const struct uverbs_api_object *obj, u32 id,
 -			   struct ib_uverbs_file *ufile, int success_res);
 -#define uobj_perform_destroy(_type, _id, _ufile, _success_res)                 \
 -	__uobj_perform_destroy(uobj_get_type(_ufile, _type),                   \
 -			       _uobj_check_id(_id), _ufile, _success_res)
 +#define uobj_get_read(_type, _id, _ucontext)				\
 +	 __uobj_get(uobj_get_type(_type), false, _ucontext, _id)
  
 -struct ib_uobject *__uobj_get_destroy(const struct uverbs_api_object *obj,
 -				      u32 id, struct ib_uverbs_file *ufile);
 +#define uobj_get_obj_read(_object, _type, _id, _ucontext)		\
 +({									\
 +	struct ib_uobject *__uobj =					\
 +		__uobj_get(uobj_get_type(_type),			\
 +			   false, _ucontext, _id);			\
 +									\
 +	(struct ib_##_object *)(IS_ERR(__uobj) ? NULL : __uobj->object);\
 +})
  
 -#define uobj_get_destroy(_type, _id, _ufile)                                   \
 -	__uobj_get_destroy(uobj_get_type(_ufile, _type), _uobj_check_id(_id),  \
 -			   _ufile)
 +#define uobj_get_write(_type, _id, _ucontext)				\
 +	 __uobj_get(uobj_get_type(_type), true, _ucontext, _id)
  
 -static inline void uobj_put_destroy(struct ib_uobject *uobj)
 -{
 -	rdma_lookup_put_uobject(uobj, UVERBS_LOOKUP_WRITE);
 -}
 +int __uobj_perform_destroy(const struct uverbs_obj_type *type, int id,
 +			   struct ib_uverbs_file *ufile, int success_res);
 +#define uobj_perform_destroy(_type, _id, _ufile, _success_res)                 \
 +	__uobj_perform_destroy(uobj_get_type(_type), _id, _ufile, _success_res)
  
  static inline void uobj_put_read(struct ib_uobject *uobj)
  {
* Unmerged path drivers/infiniband/core/uverbs_uapi.c
* Unmerged path drivers/infiniband/hw/mlx5/flow.c
* Unmerged path drivers/infiniband/core/rdma_core.h
* Unmerged path drivers/infiniband/core/uverbs_main.c
* Unmerged path drivers/infiniband/core/uverbs_std_types.c
* Unmerged path drivers/infiniband/core/uverbs_uapi.c
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
* Unmerged path drivers/infiniband/hw/mlx5/flow.c
* Unmerged path drivers/infiniband/hw/mlx5/main.c
* Unmerged path drivers/infiniband/hw/mlx5/mlx5_ib.h
* Unmerged path include/rdma/ib_verbs.h
* Unmerged path include/rdma/uverbs_ioctl.h
* Unmerged path include/rdma/uverbs_named_ioctl.h
* Unmerged path include/rdma/uverbs_std_types.h
