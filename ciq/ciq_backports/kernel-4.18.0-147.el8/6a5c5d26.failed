rdma: fix build errors on s390 and MIPS due to bad ZERO_PAGE use

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Linus Torvalds <torvalds@linux-foundation.org>
commit 6a5c5d26c4c6c3cc486fef0bf04ff9551132611b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/6a5c5d26.failed

The parameter to ZERO_PAGE() was wrong, but since all architectures
except for MIPS and s390 ignore it, it wasn't noticed until 0-day
reported the build error.

Fixes: 67f269b37f9b ("RDMA/ucontext: Fix regression with disassociate")
	Cc: stable@vger.kernel.org
	Cc: Andrea Arcangeli <aarcange@redhat.com>
	Cc: Leon Romanovsky <leonro@mellanox.com>
	Cc: Jason Gunthorpe <jgg@mellanox.com>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 6a5c5d26c4c6c3cc486fef0bf04ff9551132611b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_main.c
diff --cc drivers/infiniband/core/uverbs_main.c
index 495189811c27,c489f545baae..000000000000
--- a/drivers/infiniband/core/uverbs_main.c
+++ b/drivers/infiniband/core/uverbs_main.c
@@@ -809,20 -774,149 +809,111 @@@ static int ib_uverbs_mmap(struct file *
  	int ret = 0;
  	int srcu_key;
  
++<<<<<<< HEAD
  	srcu_key = srcu_read_lock(&file->device->disassociate_srcu);
 -	ucontext = ib_uverbs_get_ucontext_file(file);
 -	if (IS_ERR(ucontext)) {
 -		ret = PTR_ERR(ucontext);
 +	ib_dev = srcu_dereference(file->device->ib_dev,
 +				  &file->device->disassociate_srcu);
 +	if (!ib_dev) {
 +		ret = -EIO;
  		goto out;
 -	}
 -
 -	ret = ucontext->device->ops.mmap(ucontext, vma);
 -out:
 -	srcu_read_unlock(&file->device->disassociate_srcu, srcu_key);
 -	return ret;
 -}
 -
 -/*
 - * Each time we map IO memory into user space this keeps track of the mapping.
 - * When the device is hot-unplugged we 'zap' the mmaps in user space to point
 - * to the zero page and allow the hot unplug to proceed.
 - *
 - * This is necessary for cases like PCI physical hot unplug as the actual BAR
 - * memory may vanish after this and access to it from userspace could MCE.
 - *
 - * RDMA drivers supporting disassociation must have their user space designed
 - * to cope in some way with their IO pages going to the zero page.
 - */
 -struct rdma_umap_priv {
 -	struct vm_area_struct *vma;
 -	struct list_head list;
 -};
 -
 -static const struct vm_operations_struct rdma_umap_ops;
 -
 -static void rdma_umap_priv_init(struct rdma_umap_priv *priv,
 -				struct vm_area_struct *vma)
 -{
 -	struct ib_uverbs_file *ufile = vma->vm_file->private_data;
 -
++=======
+ 	priv->vma = vma;
+ 	vma->vm_private_data = priv;
+ 	vma->vm_ops = &rdma_umap_ops;
+ 
+ 	mutex_lock(&ufile->umap_lock);
+ 	list_add(&priv->list, &ufile->umaps);
+ 	mutex_unlock(&ufile->umap_lock);
+ }
+ 
+ /*
+  * The VMA has been dup'd, initialize the vm_private_data with a new tracking
+  * struct
+  */
+ static void rdma_umap_open(struct vm_area_struct *vma)
+ {
+ 	struct ib_uverbs_file *ufile = vma->vm_file->private_data;
+ 	struct rdma_umap_priv *opriv = vma->vm_private_data;
+ 	struct rdma_umap_priv *priv;
+ 
+ 	if (!opriv)
+ 		return;
+ 
+ 	/* We are racing with disassociation */
+ 	if (!down_read_trylock(&ufile->hw_destroy_rwsem))
+ 		goto out_zap;
+ 	/*
+ 	 * Disassociation already completed, the VMA should already be zapped.
+ 	 */
+ 	if (!ufile->ucontext)
+ 		goto out_unlock;
+ 
+ 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+ 	if (!priv)
+ 		goto out_unlock;
+ 	rdma_umap_priv_init(priv, vma);
+ 
+ 	up_read(&ufile->hw_destroy_rwsem);
+ 	return;
+ 
+ out_unlock:
+ 	up_read(&ufile->hw_destroy_rwsem);
+ out_zap:
+ 	/*
+ 	 * We can't allow the VMA to be created with the actual IO pages, that
+ 	 * would break our API contract, and it can't be stopped at this
+ 	 * point, so zap it.
+ 	 */
+ 	vma->vm_private_data = NULL;
+ 	zap_vma_ptes(vma, vma->vm_start, vma->vm_end - vma->vm_start);
+ }
+ 
+ static void rdma_umap_close(struct vm_area_struct *vma)
+ {
+ 	struct ib_uverbs_file *ufile = vma->vm_file->private_data;
+ 	struct rdma_umap_priv *priv = vma->vm_private_data;
+ 
+ 	if (!priv)
+ 		return;
+ 
+ 	/*
+ 	 * The vma holds a reference on the struct file that created it, which
+ 	 * in turn means that the ib_uverbs_file is guaranteed to exist at
+ 	 * this point.
+ 	 */
+ 	mutex_lock(&ufile->umap_lock);
+ 	list_del(&priv->list);
+ 	mutex_unlock(&ufile->umap_lock);
+ 	kfree(priv);
+ }
+ 
+ /*
+  * Once the zap_vma_ptes has been called touches to the VMA will come here and
+  * we return a dummy writable zero page for all the pfns.
+  */
+ static vm_fault_t rdma_umap_fault(struct vm_fault *vmf)
+ {
+ 	struct ib_uverbs_file *ufile = vmf->vma->vm_file->private_data;
+ 	struct rdma_umap_priv *priv = vmf->vma->vm_private_data;
+ 	vm_fault_t ret = 0;
+ 
+ 	if (!priv)
+ 		return VM_FAULT_SIGBUS;
+ 
+ 	/* Read only pages can just use the system zero page. */
+ 	if (!(vmf->vma->vm_flags & (VM_WRITE | VM_MAYWRITE))) {
+ 		vmf->page = ZERO_PAGE(vmf->address);
+ 		get_page(vmf->page);
+ 		return 0;
++>>>>>>> 6a5c5d26c4c6 (rdma: fix build errors on s390 and MIPS due to bad ZERO_PAGE use)
  	}
  
 -	mutex_lock(&ufile->umap_lock);
 -	if (!ufile->disassociate_page)
 -		ufile->disassociate_page =
 -			alloc_pages(vmf->gfp_mask | __GFP_ZERO, 0);
 -
 -	if (ufile->disassociate_page) {
 -		/*
 -		 * This VMA is forced to always be shared so this doesn't have
 -		 * to worry about COW.
 -		 */
 -		vmf->page = ufile->disassociate_page;
 -		get_page(vmf->page);
 -	} else {
 -		ret = VM_FAULT_SIGBUS;
 -	}
 -	mutex_unlock(&ufile->umap_lock);
 -
 +	if (!file->ucontext)
 +		ret = -ENODEV;
 +	else
 +		ret = ib_dev->mmap(file->ucontext, vma);
 +out:
 +	srcu_read_unlock(&file->device->disassociate_srcu, srcu_key);
  	return ret;
  }
  
* Unmerged path drivers/infiniband/core/uverbs_main.c
