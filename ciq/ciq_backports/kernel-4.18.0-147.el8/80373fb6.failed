drm/i915: Store DIMM rank information as a number

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit 80373fb6be9643d065c57c1030038fe927cfb478
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/80373fb6.failed

Life will be easier later if we have the ranks stored
as a bare number.

v2: s/%d/%u/ all over (Jani)

	Reviewed-by: Jani Nikula <jani.nikula@intel.com>
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190306203551.24592-2-ville.syrjala@linux.intel.com
(cherry picked from commit 80373fb6be9643d065c57c1030038fe927cfb478)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/i915_drv.c
#	drivers/gpu/drm/i915/i915_drv.h
diff --cc drivers/gpu/drm/i915/i915_drv.c
index 07735f386eab,ec3fb349d49e..000000000000
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@@ -1054,6 -1068,293 +1054,296 @@@ static void intel_sanitize_options(stru
  	intel_gvt_sanitize_options(dev_priv);
  }
  
++<<<<<<< HEAD
++=======
+ static int skl_get_dimm_ranks(u8 size, u32 rank)
+ {
+ 	if (size == 0)
+ 		return 0;
+ 	if (rank == SKL_DRAM_RANK_SINGLE)
+ 		return 1;
+ 	else if (rank == SKL_DRAM_RANK_DUAL)
+ 		return 2;
+ 
+ 	return 0;
+ }
+ 
+ static bool
+ skl_is_16gb_dimm(u8 ranks, u8 size, u8 width)
+ {
+ 	if (ranks == 1 && width == 8 && size == 16)
+ 		return true;
+ 	else if (ranks == 2 && width == 8 && size == 32)
+ 		return true;
+ 	else if (ranks == 1 && width == 16 && size == 8)
+ 		return true;
+ 	else if (ranks == 2 && width == 16 && size == 16)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ static int
+ skl_dram_get_channel_info(struct dram_channel_info *ch, u32 val)
+ {
+ 	u32 tmp_l, tmp_s;
+ 	u32 s_val = val >> SKL_DRAM_S_SHIFT;
+ 
+ 	if (!val)
+ 		return -EINVAL;
+ 
+ 	tmp_l = val & SKL_DRAM_SIZE_MASK;
+ 	tmp_s = s_val & SKL_DRAM_SIZE_MASK;
+ 
+ 	if (tmp_l == 0 && tmp_s == 0)
+ 		return -EINVAL;
+ 
+ 	ch->l_info.size = tmp_l;
+ 	ch->s_info.size = tmp_s;
+ 
+ 	tmp_l = (val & SKL_DRAM_WIDTH_MASK) >> SKL_DRAM_WIDTH_SHIFT;
+ 	tmp_s = (s_val & SKL_DRAM_WIDTH_MASK) >> SKL_DRAM_WIDTH_SHIFT;
+ 	ch->l_info.width = (1 << tmp_l) * 8;
+ 	ch->s_info.width = (1 << tmp_s) * 8;
+ 
+ 	tmp_l = val & SKL_DRAM_RANK_MASK;
+ 	tmp_s = s_val & SKL_DRAM_RANK_MASK;
+ 	ch->l_info.ranks = skl_get_dimm_ranks(ch->l_info.size, tmp_l);
+ 	ch->s_info.ranks = skl_get_dimm_ranks(ch->s_info.size, tmp_s);
+ 
+ 	if (ch->l_info.ranks == 2 || ch->s_info.ranks == 2)
+ 		ch->ranks = 2;
+ 	else if (ch->l_info.ranks == 1 && ch->s_info.ranks == 1)
+ 		ch->ranks = 2;
+ 	else
+ 		ch->ranks = 1;
+ 
+ 	ch->is_16gb_dimm = skl_is_16gb_dimm(ch->l_info.ranks, ch->l_info.size,
+ 					    ch->l_info.width) ||
+ 			   skl_is_16gb_dimm(ch->s_info.ranks, ch->s_info.size,
+ 					    ch->s_info.width);
+ 
+ 	DRM_DEBUG_KMS("(size:width:ranks) L(%uGB:X%u:%u) S(%uGB:X%u:%u)\n",
+ 		      ch->l_info.size, ch->l_info.width, ch->l_info.ranks,
+ 		      ch->s_info.size, ch->s_info.width, ch->s_info.ranks);
+ 
+ 	return 0;
+ }
+ 
+ static bool
+ intel_is_dram_symmetric(u32 val_ch0, u32 val_ch1,
+ 			struct dram_channel_info *ch0)
+ {
+ 	return (val_ch0 == val_ch1 &&
+ 		(ch0->s_info.size == 0 ||
+ 		 (ch0->l_info.size == ch0->s_info.size &&
+ 		  ch0->l_info.width == ch0->s_info.width &&
+ 		  ch0->l_info.ranks == ch0->s_info.ranks)));
+ }
+ 
+ static int
+ skl_dram_get_channels_info(struct drm_i915_private *dev_priv)
+ {
+ 	struct dram_info *dram_info = &dev_priv->dram_info;
+ 	struct dram_channel_info ch0, ch1;
+ 	u32 val_ch0, val_ch1;
+ 	int ret;
+ 
+ 	val_ch0 = I915_READ(SKL_MAD_DIMM_CH0_0_0_0_MCHBAR_MCMAIN);
+ 	ret = skl_dram_get_channel_info(&ch0, val_ch0);
+ 	if (ret == 0)
+ 		dram_info->num_channels++;
+ 
+ 	val_ch1 = I915_READ(SKL_MAD_DIMM_CH1_0_0_0_MCHBAR_MCMAIN);
+ 	ret = skl_dram_get_channel_info(&ch1, val_ch1);
+ 	if (ret == 0)
+ 		dram_info->num_channels++;
+ 
+ 	if (dram_info->num_channels == 0) {
+ 		DRM_INFO("Number of memory channels is zero\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	/*
+ 	 * If any of the channel is single rank channel, worst case output
+ 	 * will be same as if single rank memory, so consider single rank
+ 	 * memory.
+ 	 */
+ 	if (ch0.ranks == 1 || ch1.ranks == 1)
+ 		dram_info->ranks = 1;
+ 	else
+ 		dram_info->ranks = max(ch0.ranks, ch1.ranks);
+ 
+ 	if (dram_info->ranks == 0) {
+ 		DRM_INFO("couldn't get memory rank information\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	dram_info->is_16gb_dimm = ch0.is_16gb_dimm || ch1.is_16gb_dimm;
+ 
+ 	dev_priv->dram_info.symmetric_memory = intel_is_dram_symmetric(val_ch0,
+ 								       val_ch1,
+ 								       &ch0);
+ 
+ 	DRM_DEBUG_KMS("memory configuration is %sSymmetric memory\n",
+ 		      dev_priv->dram_info.symmetric_memory ? "" : "not ");
+ 	return 0;
+ }
+ 
+ static int
+ skl_get_dram_info(struct drm_i915_private *dev_priv)
+ {
+ 	struct dram_info *dram_info = &dev_priv->dram_info;
+ 	u32 mem_freq_khz, val;
+ 	int ret;
+ 
+ 	ret = skl_dram_get_channels_info(dev_priv);
+ 	if (ret)
+ 		return ret;
+ 
+ 	val = I915_READ(SKL_MC_BIOS_DATA_0_0_0_MCHBAR_PCU);
+ 	mem_freq_khz = DIV_ROUND_UP((val & SKL_REQ_DATA_MASK) *
+ 				    SKL_MEMORY_FREQ_MULTIPLIER_HZ, 1000);
+ 
+ 	dram_info->bandwidth_kbps = dram_info->num_channels *
+ 							mem_freq_khz * 8;
+ 
+ 	if (dram_info->bandwidth_kbps == 0) {
+ 		DRM_INFO("Couldn't get system memory bandwidth\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	dram_info->valid = true;
+ 	return 0;
+ }
+ 
+ static int
+ bxt_get_dram_info(struct drm_i915_private *dev_priv)
+ {
+ 	struct dram_info *dram_info = &dev_priv->dram_info;
+ 	u32 dram_channels;
+ 	u32 mem_freq_khz, val;
+ 	u8 num_active_channels;
+ 	int i;
+ 
+ 	val = I915_READ(BXT_P_CR_MC_BIOS_REQ_0_0_0);
+ 	mem_freq_khz = DIV_ROUND_UP((val & BXT_REQ_DATA_MASK) *
+ 				    BXT_MEMORY_FREQ_MULTIPLIER_HZ, 1000);
+ 
+ 	dram_channels = val & BXT_DRAM_CHANNEL_ACTIVE_MASK;
+ 	num_active_channels = hweight32(dram_channels);
+ 
+ 	/* Each active bit represents 4-byte channel */
+ 	dram_info->bandwidth_kbps = (mem_freq_khz * num_active_channels * 4);
+ 
+ 	if (dram_info->bandwidth_kbps == 0) {
+ 		DRM_INFO("Couldn't get system memory bandwidth\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	/*
+ 	 * Now read each DUNIT8/9/10/11 to check the rank of each dimms.
+ 	 */
+ 	for (i = BXT_D_CR_DRP0_DUNIT_START; i <= BXT_D_CR_DRP0_DUNIT_END; i++) {
+ 		u8 size, width, ranks;
+ 		u32 tmp;
+ 
+ 		val = I915_READ(BXT_D_CR_DRP0_DUNIT(i));
+ 		if (val == 0xFFFFFFFF)
+ 			continue;
+ 
+ 		dram_info->num_channels++;
+ 		tmp = val & BXT_DRAM_RANK_MASK;
+ 
+ 		if (tmp == BXT_DRAM_RANK_SINGLE)
+ 			ranks = 1;
+ 		else if (tmp == BXT_DRAM_RANK_DUAL)
+ 			ranks = 2;
+ 		else
+ 			ranks = 0;
+ 
+ 		tmp = val & BXT_DRAM_SIZE_MASK;
+ 		if (tmp == BXT_DRAM_SIZE_4GB)
+ 			size = 4;
+ 		else if (tmp == BXT_DRAM_SIZE_6GB)
+ 			size = 6;
+ 		else if (tmp == BXT_DRAM_SIZE_8GB)
+ 			size = 8;
+ 		else if (tmp == BXT_DRAM_SIZE_12GB)
+ 			size = 12;
+ 		else if (tmp == BXT_DRAM_SIZE_16GB)
+ 			size = 16;
+ 		else
+ 			size = 0;
+ 
+ 		tmp = (val & BXT_DRAM_WIDTH_MASK) >> BXT_DRAM_WIDTH_SHIFT;
+ 		width = (1 << tmp) * 8;
+ 		DRM_DEBUG_KMS("dram size:%uGB width:X%u ranks:%u\n",
+ 			      size, width, ranks);
+ 
+ 		/*
+ 		 * If any of the channel is single rank channel,
+ 		 * worst case output will be same as if single rank
+ 		 * memory, so consider single rank memory.
+ 		 */
+ 		if (dram_info->ranks == 0)
+ 			dram_info->ranks = ranks;
+ 		else if (ranks == 1)
+ 			dram_info->ranks = 1;
+ 	}
+ 
+ 	if (dram_info->ranks == 0) {
+ 		DRM_INFO("couldn't get memory rank information\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	dram_info->valid = true;
+ 	return 0;
+ }
+ 
+ static void
+ intel_get_dram_info(struct drm_i915_private *dev_priv)
+ {
+ 	struct dram_info *dram_info = &dev_priv->dram_info;
+ 	char bandwidth_str[32];
+ 	int ret;
+ 
+ 	dram_info->valid = false;
+ 	dram_info->ranks = 0;
+ 	dram_info->bandwidth_kbps = 0;
+ 	dram_info->num_channels = 0;
+ 
+ 	/*
+ 	 * Assume 16Gb DIMMs are present until proven otherwise.
+ 	 * This is only used for the level 0 watermark latency
+ 	 * w/a which does not apply to bxt/glk.
+ 	 */
+ 	dram_info->is_16gb_dimm = !IS_GEN9_LP(dev_priv);
+ 
+ 	if (INTEL_GEN(dev_priv) < 9 || IS_GEMINILAKE(dev_priv))
+ 		return;
+ 
+ 	/* Need to calculate bandwidth only for Gen9 */
+ 	if (IS_BROXTON(dev_priv))
+ 		ret = bxt_get_dram_info(dev_priv);
+ 	else if (IS_GEN(dev_priv, 9))
+ 		ret = skl_get_dram_info(dev_priv);
+ 	else
+ 		ret = skl_dram_get_channels_info(dev_priv);
+ 	if (ret)
+ 		return;
+ 
+ 	if (dram_info->bandwidth_kbps)
+ 		sprintf(bandwidth_str, "%d KBps", dram_info->bandwidth_kbps);
+ 	else
+ 		sprintf(bandwidth_str, "unknown");
+ 	DRM_DEBUG_KMS("DRAM bandwidth:%s, total-channels: %u\n",
+ 		      bandwidth_str, dram_info->num_channels);
+ 	DRM_DEBUG_KMS("DRAM ranks: %u, 16GB-dimm:%s\n",
+ 		      dram_info->ranks, yesno(dram_info->is_16gb_dimm));
+ }
+ 
++>>>>>>> 80373fb6be96 (drm/i915: Store DIMM rank information as a number)
  /**
   * i915_driver_init_hw - setup state requiring device access
   * @dev_priv: device private
diff --cc drivers/gpu/drm/i915/i915_drv.h
index 13092094d7ec,6f8e9910bb47..000000000000
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@@ -1925,6 -1822,15 +1925,18 @@@ struct drm_i915_private 
  		bool distrust_bios_wm;
  	} wm;
  
++<<<<<<< HEAD
++=======
+ 	struct dram_info {
+ 		bool valid;
+ 		bool is_16gb_dimm;
+ 		u8 num_channels;
+ 		u8 ranks;
+ 		u32 bandwidth_kbps;
+ 		bool symmetric_memory;
+ 	} dram_info;
+ 
++>>>>>>> 80373fb6be96 (drm/i915: Store DIMM rank information as a number)
  	struct i915_runtime_pm runtime_pm;
  
  	struct {
@@@ -2136,6 -2052,14 +2148,17 @@@
  	 */
  };
  
++<<<<<<< HEAD
++=======
+ struct dram_channel_info {
+ 	struct info {
+ 		u8 size, width, ranks;
+ 	} l_info, s_info;
+ 	u8 ranks;
+ 	bool is_16gb_dimm;
+ };
+ 
++>>>>>>> 80373fb6be96 (drm/i915: Store DIMM rank information as a number)
  static inline struct drm_i915_private *to_i915(const struct drm_device *dev)
  {
  	return container_of(dev, struct drm_i915_private, drm);
* Unmerged path drivers/gpu/drm/i915/i915_drv.c
* Unmerged path drivers/gpu/drm/i915/i915_drv.h
