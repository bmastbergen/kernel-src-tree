net/mlx5e: Properly set steering match levels for offloaded TC decap rules

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Or Gerlitz <ogerlitz@mellanox.com>
commit 6363651d6dd79694d586f4ae68967036dd14bc3a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/6363651d.failed

The match level computed by the driver gets to be wrong for decap
rules with wildcarded inner packet match such as:

tc filter add dev vxlan_sys_4789 protocol all parent ffff: prio 2 flower
       enc_dst_ip 192.168.0.9 enc_key_id 100 enc_dst_port 4789
       action tunnel_key unset
       action mirred egress redirect dev eth1

The FW errs for a missing matching meta-data indicator for the outer
headers (where we do have a match), and a wrong matching meta-data
indicator for the inner headers (where we don't have a match).

Fix that by taking into account the matching on the tunnel info and
relating the match level of the encapsulated packet to the firmware
inner headers indicator in case of decap.

As for vxlan we mandate a match on the tunnel udp dst port, and in general
we practically madndate a match on the source or dest ip for any IP tunnel,
the fix was done in a minimal manner around the tunnel match parsing code.

Fixes: d708f902989b ('net/mlx5e: Get the required HW match level while parsing TC flow matches')
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Reported-by: Slava Ovsiienko <viacheslavo@mellanox.com>
	Reviewed-by: Jianbo Liu <jianbol@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 6363651d6dd79694d586f4ae68967036dd14bc3a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 1e07eea25cbe,043896e13ffa..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -1126,10 -1298,13 +1126,15 @@@ static void parse_vxlan_attr(struct mlx
  	}
  }
  
 -
  static int parse_tunnel_attr(struct mlx5e_priv *priv,
  			     struct mlx5_flow_spec *spec,
++<<<<<<< HEAD
 +			     struct tc_cls_flower_offload *f)
++=======
+ 			     struct tc_cls_flower_offload *f,
+ 			     struct net_device *filter_dev, u8 *match_level)
++>>>>>>> 6363651d6dd7 (net/mlx5e: Properly set steering match levels for offloaded TC decap rules)
  {
 -	struct netlink_ext_ack *extack = f->common.extack;
  	void *headers_c = MLX5_ADDR_OF(fte_match_param, spec->match_criteria,
  				       outer_headers);
  	void *headers_v = MLX5_ADDR_OF(fte_match_param, spec->match_value,
@@@ -1139,44 -1314,14 +1144,53 @@@
  		skb_flow_dissector_target(f->dissector,
  					  FLOW_DISSECTOR_KEY_ENC_CONTROL,
  					  f->key);
 -	int err = 0;
  
++<<<<<<< HEAD
 +	if (dissector_uses_key(f->dissector, FLOW_DISSECTOR_KEY_ENC_PORTS)) {
 +		struct flow_dissector_key_ports *key =
 +			skb_flow_dissector_target(f->dissector,
 +						  FLOW_DISSECTOR_KEY_ENC_PORTS,
 +						  f->key);
 +		struct flow_dissector_key_ports *mask =
 +			skb_flow_dissector_target(f->dissector,
 +						  FLOW_DISSECTOR_KEY_ENC_PORTS,
 +						  f->mask);
 +
 +		/* Full udp dst port must be given */
 +		if (memchr_inv(&mask->dst, 0xff, sizeof(mask->dst)))
 +			goto vxlan_match_offload_err;
 +
 +		if (mlx5_vxlan_lookup_port(priv->mdev->vxlan, be16_to_cpu(key->dst)) &&
 +		    MLX5_CAP_ESW(priv->mdev, vxlan_encap_decap))
 +			parse_vxlan_attr(spec, f);
 +		else {
 +			netdev_warn(priv->netdev,
 +				    "%d isn't an offloaded vxlan udp dport\n", be16_to_cpu(key->dst));
 +			return -EOPNOTSUPP;
 +		}
 +
 +		MLX5_SET(fte_match_set_lyr_2_4, headers_c,
 +			 udp_dport, ntohs(mask->dst));
 +		MLX5_SET(fte_match_set_lyr_2_4, headers_v,
 +			 udp_dport, ntohs(key->dst));
 +
 +		MLX5_SET(fte_match_set_lyr_2_4, headers_c,
 +			 udp_sport, ntohs(mask->src));
 +		MLX5_SET(fte_match_set_lyr_2_4, headers_v,
 +			 udp_sport, ntohs(key->src));
 +	} else { /* udp dst port must be given */
 +vxlan_match_offload_err:
 +		netdev_warn(priv->netdev,
 +			    "IP tunnel decap offload supported only for vxlan, must set UDP dport\n");
 +		return -EOPNOTSUPP;
++=======
+ 	err = mlx5e_tc_tun_parse(filter_dev, priv, spec, f,
+ 				 headers_c, headers_v, match_level);
+ 	if (err) {
+ 		NL_SET_ERR_MSG_MOD(extack,
+ 				   "failed to parse tunnel attributes");
+ 		return err;
++>>>>>>> 6363651d6dd7 (net/mlx5e: Properly set steering match levels for offloaded TC decap rules)
  	}
  
  	if (enc_control->addr_type == FLOW_DISSECTOR_KEY_IPV4_ADDRS) {
@@@ -1270,8 -1425,10 +1284,13 @@@
  static int __parse_cls_flower(struct mlx5e_priv *priv,
  			      struct mlx5_flow_spec *spec,
  			      struct tc_cls_flower_offload *f,
++<<<<<<< HEAD
 +			      u8 *match_level)
++=======
+ 			      struct net_device *filter_dev,
+ 			      u8 *match_level, u8 *tunnel_match_level)
++>>>>>>> 6363651d6dd7 (net/mlx5e: Properly set steering match levels for offloaded TC decap rules)
  {
 -	struct netlink_ext_ack *extack = f->common.extack;
  	void *headers_c = MLX5_ADDR_OF(fte_match_param, spec->match_criteria,
  				       outer_headers);
  	void *headers_v = MLX5_ADDR_OF(fte_match_param, spec->match_value,
@@@ -1314,7 -1477,7 +1333,11 @@@
  		switch (key->addr_type) {
  		case FLOW_DISSECTOR_KEY_IPV4_ADDRS:
  		case FLOW_DISSECTOR_KEY_IPV6_ADDRS:
++<<<<<<< HEAD
 +			if (parse_tunnel_attr(priv, spec, f))
++=======
+ 			if (parse_tunnel_attr(priv, spec, f, filter_dev, tunnel_match_level))
++>>>>>>> 6363651d6dd7 (net/mlx5e: Properly set steering match levels for offloaded TC decap rules)
  				return -EOPNOTSUPP;
  			break;
  		default:
@@@ -1612,11 -1825,12 +1635,15 @@@ static int parse_cls_flower(struct mlx5
  	struct mlx5_core_dev *dev = priv->mdev;
  	struct mlx5_eswitch *esw = dev->priv.eswitch;
  	struct mlx5e_rep_priv *rpriv = priv->ppriv;
+ 	u8 match_level, tunnel_match_level = MLX5_MATCH_NONE;
  	struct mlx5_eswitch_rep *rep;
- 	u8 match_level;
  	int err;
  
++<<<<<<< HEAD
 +	err = __parse_cls_flower(priv, spec, f, &match_level);
++=======
+ 	err = __parse_cls_flower(priv, spec, f, filter_dev, &match_level, &tunnel_match_level);
++>>>>>>> 6363651d6dd7 (net/mlx5e: Properly set steering match levels for offloaded TC decap rules)
  
  	if (!err && (flow->flags & MLX5E_TC_FLOW_ESWITCH)) {
  		rep = rpriv->rep;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index ea6bca2dae6d..9aa57784a8c0 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@ -297,6 +297,7 @@ struct mlx5_esw_flow_attr {
 	u32	encap_id;
 	u32	mod_hdr_id;
 	u8	match_level;
+	u8	tunnel_match_level;
 	struct mlx5_fc *counter;
 	u32	chain;
 	u16	prio;
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index b4200165ccae..17165757d111 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@ -147,14 +147,15 @@ mlx5_eswitch_add_offloaded_rule(struct mlx5_eswitch *esw,
 		MLX5_SET_TO_ONES(fte_match_set_misc, misc,
 				 source_eswitch_owner_vhca_id);
 
-	if (attr->match_level == MLX5_MATCH_NONE)
-		spec->match_criteria_enable = MLX5_MATCH_MISC_PARAMETERS;
-	else
-		spec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS |
-					      MLX5_MATCH_MISC_PARAMETERS;
-
-	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_DECAP)
-		spec->match_criteria_enable |= MLX5_MATCH_INNER_HEADERS;
+	spec->match_criteria_enable = MLX5_MATCH_MISC_PARAMETERS;
+	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_DECAP) {
+		if (attr->tunnel_match_level != MLX5_MATCH_NONE)
+			spec->match_criteria_enable |= MLX5_MATCH_OUTER_HEADERS;
+		if (attr->match_level != MLX5_MATCH_NONE)
+			spec->match_criteria_enable |= MLX5_MATCH_INNER_HEADERS;
+	} else if (attr->match_level != MLX5_MATCH_NONE) {
+		spec->match_criteria_enable |= MLX5_MATCH_OUTER_HEADERS;
+	}
 
 	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR)
 		flow_act.modify_id = attr->mod_hdr_id;
