net/mlx5e: XDP, Add array for WQE info descriptors

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Tariq Toukan <tariqt@mellanox.com>
commit 1feeab80078078186b5080fe15c51a5cce724a0e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/1feeab80.failed

Each xdp_wqe_info instance describes the number of data-segments
and WQEBBs of the WQE.
This is useful for a downstream patch that adds support for
Multi-Packet TX WQE feature.

	Signed-off-by: Tariq Toukan <tariqt@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 1feeab80078078186b5080fe15c51a5cce724a0e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
#	drivers/net/ethernet/mellanox/mlx5/core/en/xdp.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en.h
index 007808f3e87f,20b3432b35de..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@@ -408,6 -404,18 +408,21 @@@ struct mlx5e_xdp_info 
  	struct mlx5e_dma_info di;
  };
  
++<<<<<<< HEAD
++=======
+ struct mlx5e_xdp_info_fifo {
+ 	struct mlx5e_xdp_info *xi;
+ 	u32 *cc;
+ 	u32 *pc;
+ 	u32 mask;
+ };
+ 
+ struct mlx5e_xdp_wqe_info {
+ 	u8 num_wqebbs;
+ 	u8 num_ds;
+ };
+ 
++>>>>>>> 1feeab800780 (net/mlx5e: XDP, Add array for WQE info descriptors)
  struct mlx5e_xdpsq {
  	/* data path */
  
@@@ -425,7 -435,8 +440,12 @@@
  	struct mlx5_wq_cyc         wq;
  	struct mlx5e_xdpsq_stats  *stats;
  	struct {
++<<<<<<< HEAD
 +		struct mlx5e_xdp_info     *xdpi;
++=======
+ 		struct mlx5e_xdp_wqe_info *wqe_info;
+ 		struct mlx5e_xdp_info_fifo xdpi_fifo;
++>>>>>>> 1feeab800780 (net/mlx5e: XDP, Add array for WQE info descriptors)
  	} db;
  	void __iomem              *uar_map;
  	u32                        sqn;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/xdp.c
index 60fd47414ccc,5e5e43ea9b53..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/xdp.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/xdp.c
@@@ -203,17 -199,28 +203,42 @@@ bool mlx5e_poll_xdpsq_cq(struct mlx5e_c
  					 get_cqe_opcode(cqe));
  
  		do {
++<<<<<<< HEAD
 +			struct mlx5e_xdp_info *xdpi;
 +			u16 ci;
 +
 +			last_wqe = (sqcc == wqe_counter);
 +
 +			ci = mlx5_wq_cyc_ctr2ix(&sq->wq, sqcc);
 +			xdpi = &sq->db.xdpi[ci];
 +
 +			sqcc++;
 +			/* Recycle RX page */
 +			mlx5e_page_release(rq, &xdpi->di, true);
++=======
+ 			struct mlx5e_xdp_wqe_info *wi;
+ 			u16 ci, j;
+ 
+ 			last_wqe = (sqcc == wqe_counter);
+ 			ci = mlx5_wq_cyc_ctr2ix(&sq->wq, sqcc);
+ 			wi = &sq->db.wqe_info[ci];
+ 
+ 			sqcc += wi->num_wqebbs;
+ 
+ 			for (j = 0; j < wi->num_ds; j++) {
+ 				struct mlx5e_xdp_info xdpi =
+ 					mlx5e_xdpi_fifo_pop(xdpi_fifo);
+ 
+ 				if (is_redirect) {
+ 					xdp_return_frame(xdpi.xdpf);
+ 					dma_unmap_single(sq->pdev, xdpi.dma_addr,
+ 							 xdpi.xdpf->len, DMA_TO_DEVICE);
+ 				} else {
+ 					/* Recycle RX page */
+ 					mlx5e_page_release(rq, &xdpi.di, true);
+ 				}
+ 			}
++>>>>>>> 1feeab800780 (net/mlx5e: XDP, Add array for WQE info descriptors)
  		} while (!last_wqe);
  	} while ((++i < MLX5E_TX_CQ_POLL_BUDGET) && (cqe = mlx5_cqwq_get_cqe(&cq->wq)));
  
@@@ -228,18 -235,33 +253,42 @@@
  	return (i == MLX5E_TX_CQ_POLL_BUDGET);
  }
  
 -void mlx5e_free_xdpsq_descs(struct mlx5e_xdpsq *sq, struct mlx5e_rq *rq)
 +void mlx5e_free_xdpsq_descs(struct mlx5e_xdpsq *sq)
  {
 -	struct mlx5e_xdp_info_fifo *xdpi_fifo = &sq->db.xdpi_fifo;
 -	bool is_redirect = !rq;
 +	struct mlx5e_rq *rq = container_of(sq, struct mlx5e_rq, xdpsq);
 +	struct mlx5e_xdp_info *xdpi;
 +	u16 ci;
  
  	while (sq->cc != sq->pc) {
++<<<<<<< HEAD
 +		ci = mlx5_wq_cyc_ctr2ix(&sq->wq, sq->cc);
 +		xdpi = &sq->db.xdpi[ci];
 +		sq->cc++;
 +
 +		mlx5e_page_release(rq, &xdpi->di, false);
++=======
+ 		struct mlx5e_xdp_wqe_info *wi;
+ 		u16 ci, i;
+ 
+ 		ci = mlx5_wq_cyc_ctr2ix(&sq->wq, sq->cc);
+ 		wi = &sq->db.wqe_info[ci];
+ 
+ 		sq->cc += wi->num_wqebbs;
+ 
+ 		for (i = 0; i < wi->num_ds; i++) {
+ 			struct mlx5e_xdp_info xdpi =
+ 				mlx5e_xdpi_fifo_pop(xdpi_fifo);
+ 
+ 			if (is_redirect) {
+ 				xdp_return_frame(xdpi.xdpf);
+ 				dma_unmap_single(sq->pdev, xdpi.dma_addr,
+ 						 xdpi.xdpf->len, DMA_TO_DEVICE);
+ 			} else {
+ 				/* Recycle RX page */
+ 				mlx5e_page_release(rq, &xdpi.di, false);
+ 			}
+ 		}
++>>>>>>> 1feeab800780 (net/mlx5e: XDP, Add array for WQE info descriptors)
  	}
  }
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index b4f6c14ea722,7086c73d5915..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -987,18 -992,42 +987,53 @@@ static void mlx5e_close_rq(struct mlx5e
  
  static void mlx5e_free_xdpsq_db(struct mlx5e_xdpsq *sq)
  {
++<<<<<<< HEAD
 +	kvfree(sq->db.xdpi);
++=======
+ 	kvfree(sq->db.xdpi_fifo.xi);
+ 	kvfree(sq->db.wqe_info);
+ }
+ 
+ static int mlx5e_alloc_xdpsq_fifo(struct mlx5e_xdpsq *sq, int numa)
+ {
+ 	struct mlx5e_xdp_info_fifo *xdpi_fifo = &sq->db.xdpi_fifo;
+ 	int wq_sz        = mlx5_wq_cyc_get_size(&sq->wq);
+ 	int dsegs_per_wq = wq_sz * MLX5_SEND_WQEBB_NUM_DS;
+ 
+ 	xdpi_fifo->xi = kvzalloc_node(sizeof(*xdpi_fifo->xi) * dsegs_per_wq,
+ 				      GFP_KERNEL, numa);
+ 	if (!xdpi_fifo->xi)
+ 		return -ENOMEM;
+ 
+ 	xdpi_fifo->pc   = &sq->xdpi_fifo_pc;
+ 	xdpi_fifo->cc   = &sq->xdpi_fifo_cc;
+ 	xdpi_fifo->mask = dsegs_per_wq - 1;
+ 
+ 	return 0;
++>>>>>>> 1feeab800780 (net/mlx5e: XDP, Add array for WQE info descriptors)
  }
  
  static int mlx5e_alloc_xdpsq_db(struct mlx5e_xdpsq *sq, int numa)
  {
  	int wq_sz = mlx5_wq_cyc_get_size(&sq->wq);
++<<<<<<< HEAD
 +
 +	sq->db.xdpi = kvzalloc_node(array_size(wq_sz, sizeof(*sq->db.xdpi)),
 +				    GFP_KERNEL, numa);
 +	if (!sq->db.xdpi) {
++=======
+ 	int err;
+ 
+ 	sq->db.wqe_info = kvzalloc_node(sizeof(*sq->db.wqe_info) * wq_sz,
+ 					GFP_KERNEL, numa);
+ 	if (!sq->db.wqe_info)
+ 		return -ENOMEM;
+ 
+ 	err = mlx5e_alloc_xdpsq_fifo(sq, numa);
+ 	if (err) {
++>>>>>>> 1feeab800780 (net/mlx5e: XDP, Add array for WQE info descriptors)
  		mlx5e_free_xdpsq_db(sq);
 -		return err;
 +		return -ENOMEM;
  	}
  
  	return 0;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/xdp.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
