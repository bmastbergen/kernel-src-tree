drm/amd/display: Fix exception from AUX acquire failure

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Anthony Koo <Anthony.Koo@amd.com>
commit dcf1a988678e2e39ce2b4115b8ce14d208c8c481
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/dcf1a988.failed

[Why]
AUX arbitration occurs between SW and FW components.
When AUX acquire fails, it causes engine->ddc to be NULL,
which leads to an exception when we try to release the AUX
engine.

[How]
When AUX engine acquire fails, it should return from the
function without trying to continue the operation.
The upper level will determine if it wants to retry.
i.e. dce_aux_transfer_with_retries will be used and retry.

	Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
	Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
	Acked-by: Leo Li <sunpeng.li@amd.com>
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit dcf1a988678e2e39ce2b4115b8ce14d208c8c481)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/display/dc/i2caux/dce110/aux_engine_dce110.c
diff --cc drivers/gpu/drm/amd/display/dc/i2caux/dce110/aux_engine_dce110.c
index 5f47f6c007ac,2f50be33ab15..000000000000
--- a/drivers/gpu/drm/amd/display/dc/i2caux/dce110/aux_engine_dce110.c
+++ b/drivers/gpu/drm/amd/display/dc/i2caux/dce110/aux_engine_dce110.c
@@@ -410,57 -364,159 +410,175 @@@ static enum aux_channel_operation_resul
  	}
  }
  
 -enum i2caux_engine_type get_engine_type(
 -		const struct dce_aux *engine)
 -{
 -	return I2CAUX_ENGINE_TYPE_AUX;
 -}
 +static const struct aux_engine_funcs aux_engine_funcs = {
 +	.destroy = destroy,
 +	.acquire_engine = acquire_engine,
 +	.submit_channel_request = submit_channel_request,
 +	.process_channel_reply = process_channel_reply,
 +	.get_channel_status = get_channel_status,
 +	.is_engine_available = is_engine_available,
 +};
 +
 +static const struct engine_funcs engine_funcs = {
 +	.release_engine = release_engine,
 +	.submit_request = dal_aux_engine_submit_request,
 +	.get_engine_type = dal_aux_engine_get_engine_type,
 +	.acquire = dal_aux_engine_acquire,
 +};
  
 -static bool acquire(
 -	struct dce_aux *engine,
 -	struct ddc *ddc)
 +static void construct(
 +	struct aux_engine_dce110 *engine,
 +	const struct aux_engine_dce110_init_data *aux_init_data)
  {
 -	enum gpio_result result;
 +	dal_aux_engine_construct(&engine->base, aux_init_data->ctx);
 +	engine->base.base.funcs = &engine_funcs;
 +	engine->base.funcs = &aux_engine_funcs;
  
 -	if (!is_engine_available(engine))
 -		return false;
 +	engine->timeout_period = aux_init_data->timeout_period;
 +	engine->regs = aux_init_data->regs;
 +}
  
 -	result = dal_ddc_open(ddc, GPIO_MODE_HARDWARE,
 -		GPIO_DDC_CONFIG_TYPE_MODE_AUX);
 +static void destruct(
 +	struct aux_engine_dce110 *engine)
 +{
++<<<<<<< HEAD:drivers/gpu/drm/amd/display/dc/i2caux/dce110/aux_engine_dce110.c
 +	dal_aux_engine_destruct(&engine->base);
 +}
  
 -	if (result != GPIO_RESULT_OK)
 -		return false;
 +struct aux_engine *dal_aux_engine_dce110_create(
 +	const struct aux_engine_dce110_init_data *aux_init_data)
 +{
 +	struct aux_engine_dce110 *engine;
++=======
++	enum gpio_result result;
++>>>>>>> dcf1a988678e (drm/amd/display: Fix exception from AUX acquire failure):drivers/gpu/drm/amd/display/dc/dce/dce_aux.c
  
 -	if (!acquire_engine(engine)) {
 -		dal_ddc_close(ddc);
 -		return false;
 +	if (!aux_init_data) {
 +		ASSERT_CRITICAL(false);
 +		return NULL;
  	}
  
 -	engine->ddc = ddc;
 +	engine = kzalloc(sizeof(*engine), GFP_KERNEL);
  
++<<<<<<< HEAD:drivers/gpu/drm/amd/display/dc/i2caux/dce110/aux_engine_dce110.c
 +	if (!engine) {
 +		ASSERT_CRITICAL(false);
 +		return NULL;
++=======
+ 	return true;
+ }
+ 
+ void dce110_engine_destroy(struct dce_aux **engine)
+ {
+ 
+ 	struct aux_engine_dce110 *engine110 = FROM_AUX_ENGINE(*engine);
+ 
+ 	kfree(engine110);
+ 	*engine = NULL;
+ 
+ }
+ struct dce_aux *dce110_aux_engine_construct(struct aux_engine_dce110 *aux_engine110,
+ 		struct dc_context *ctx,
+ 		uint32_t inst,
+ 		uint32_t timeout_period,
+ 		const struct dce110_aux_registers *regs)
+ {
+ 	aux_engine110->base.ddc = NULL;
+ 	aux_engine110->base.ctx = ctx;
+ 	aux_engine110->base.delay = 0;
+ 	aux_engine110->base.max_defer_write_retry = 0;
+ 	aux_engine110->base.inst = inst;
+ 	aux_engine110->timeout_period = timeout_period;
+ 	aux_engine110->regs = regs;
+ 
+ 	return &aux_engine110->base;
+ }
+ 
+ static enum i2caux_transaction_action i2caux_action_from_payload(struct aux_payload *payload)
+ {
+ 	if (payload->i2c_over_aux) {
+ 		if (payload->write) {
+ 			if (payload->mot)
+ 				return I2CAUX_TRANSACTION_ACTION_I2C_WRITE_MOT;
+ 			return I2CAUX_TRANSACTION_ACTION_I2C_WRITE;
+ 		}
+ 		if (payload->mot)
+ 			return I2CAUX_TRANSACTION_ACTION_I2C_READ_MOT;
+ 		return I2CAUX_TRANSACTION_ACTION_I2C_READ;
+ 	}
+ 	if (payload->write)
+ 		return I2CAUX_TRANSACTION_ACTION_DP_WRITE;
+ 	return I2CAUX_TRANSACTION_ACTION_DP_READ;
+ }
+ 
+ int dce_aux_transfer(struct ddc_service *ddc,
+ 		struct aux_payload *payload)
+ {
+ 	struct ddc *ddc_pin = ddc->ddc_pin;
+ 	struct dce_aux *aux_engine;
+ 	enum aux_channel_operation_result operation_result;
+ 	struct aux_request_transaction_data aux_req;
+ 	struct aux_reply_transaction_data aux_rep;
+ 	uint8_t returned_bytes = 0;
+ 	int res = -1;
+ 	uint32_t status;
+ 
+ 	memset(&aux_req, 0, sizeof(aux_req));
+ 	memset(&aux_rep, 0, sizeof(aux_rep));
+ 
+ 	aux_engine = ddc->ctx->dc->res_pool->engines[ddc_pin->pin_data->en];
+ 	if (!acquire(aux_engine, ddc_pin))
+ 		return -1;
+ 
+ 	if (payload->i2c_over_aux)
+ 		aux_req.type = AUX_TRANSACTION_TYPE_I2C;
+ 	else
+ 		aux_req.type = AUX_TRANSACTION_TYPE_DP;
+ 
+ 	aux_req.action = i2caux_action_from_payload(payload);
+ 
+ 	aux_req.address = payload->address;
+ 	aux_req.delay = payload->defer_delay * 10;
+ 	aux_req.length = payload->length;
+ 	aux_req.data = payload->data;
+ 
+ 	submit_channel_request(aux_engine, &aux_req);
+ 	operation_result = get_channel_status(aux_engine, &returned_bytes);
+ 
+ 	switch (operation_result) {
+ 	case AUX_CHANNEL_OPERATION_SUCCEEDED:
+ 		res = read_channel_reply(aux_engine, payload->length,
+ 							payload->data, payload->reply,
+ 							&status);
+ 		break;
+ 	case AUX_CHANNEL_OPERATION_FAILED_HPD_DISCON:
+ 		res = 0;
+ 		break;
+ 	case AUX_CHANNEL_OPERATION_FAILED_REASON_UNKNOWN:
+ 	case AUX_CHANNEL_OPERATION_FAILED_INVALID_REPLY:
+ 	case AUX_CHANNEL_OPERATION_FAILED_TIMEOUT:
+ 		res = -1;
+ 		break;
+ 	}
+ 	release_engine(aux_engine);
+ 	return res;
+ }
+ 
+ #define AUX_RETRY_MAX 7
+ 
+ bool dce_aux_transfer_with_retries(struct ddc_service *ddc,
+ 		struct aux_payload *payload)
+ {
+ 	int i, ret = 0;
+ 	uint8_t reply;
+ 	bool payload_reply = true;
+ 
+ 	if (!payload->reply) {
+ 		payload_reply = false;
+ 		payload->reply = &reply;
++>>>>>>> dcf1a988678e (drm/amd/display: Fix exception from AUX acquire failure):drivers/gpu/drm/amd/display/dc/dce/dce_aux.c
  	}
  
 -	for (i = 0; i < AUX_RETRY_MAX; i++) {
 -		ret = dce_aux_transfer(ddc, payload);
 -
 -		if (ret >= 0) {
 -			if (*payload->reply == 0) {
 -				if (!payload_reply)
 -					payload->reply = NULL;
 -				return true;
 -			}
 -		}
 -
 -		udelay(1000);
 -	}
 -	return false;
 +	construct(engine, aux_init_data);
 +	return &engine->base;
  }
* Unmerged path drivers/gpu/drm/amd/display/dc/i2caux/dce110/aux_engine_dce110.c
