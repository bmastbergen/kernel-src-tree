virtio/s390: use DMA memory for ccw I/O and classic notifiers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Halil Pasic <pasic@linux.ibm.com>
commit 48720ba56891570e3b750b271d80efb631478630
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/48720ba5.failed

Before virtio-ccw could get away with not using DMA API for the pieces of
memory it does ccw I/O with. With protected virtualization this has to
change, since the hypervisor needs to read and sometimes also write these
pieces of memory.

The hypervisor is supposed to poke the classic notifiers, if these are
used, out of band with regards to ccw I/O. So these need to be allocated
as DMA memory (which is shared memory for protected virtualization
guests).

Let us factor out everything from struct virtio_ccw_device that needs to
be DMA memory in a satellite that is allocated as such.

Note: The control blocks of I/O instructions do not need to be shared.
These are marshalled by the ultravisor.

	Signed-off-by: Halil Pasic <pasic@linux.ibm.com>
	Reviewed-by: Pierre Morel <pmorel@linux.ibm.com>
	Reviewed-by: Cornelia Huck <cohuck@redhat.com>
	Reviewed-by: Michael Mueller <mimu@linux.ibm.com>
	Tested-by: Michael Mueller <mimu@linux.ibm.com>
	Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
(cherry picked from commit 48720ba56891570e3b750b271d80efb631478630)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/virtio/virtio_ccw.c
diff --cc drivers/s390/virtio/virtio_ccw.c
index e75f3ebc5617,800252955a2f..000000000000
--- a/drivers/s390/virtio/virtio_ccw.c
+++ b/drivers/s390/virtio/virtio_ccw.c
@@@ -640,10 -647,10 +647,10 @@@ static int virtio_ccw_find_vqs(struct v
  {
  	struct virtio_ccw_device *vcdev = to_vc_device(vdev);
  	unsigned long *indicatorp = NULL;
 -	int ret, i, queue_idx = 0;
 +	int ret, i;
  	struct ccw1 *ccw;
  
- 	ccw = kzalloc(sizeof(*ccw), GFP_DMA | GFP_KERNEL);
+ 	ccw = ccw_device_dma_zalloc(vcdev->cdev, sizeof(*ccw));
  	if (!ccw)
  		return -ENOMEM;
  
@@@ -1249,24 -1279,19 +1263,31 @@@ static int virtio_ccw_online(struct ccw
  		ret = -ENOMEM;
  		goto out_free;
  	}
++<<<<<<< HEAD
 +	vcdev->config_block = kzalloc(sizeof(*vcdev->config_block),
 +				   GFP_DMA | GFP_KERNEL);
 +	if (!vcdev->config_block) {
 +		ret = -ENOMEM;
 +		goto out_free;
 +	}
 +	vcdev->status = kzalloc(sizeof(*vcdev->status), GFP_DMA | GFP_KERNEL);
 +	if (!vcdev->status) {
++=======
+ 	vcdev->vdev.dev.parent = &cdev->dev;
+ 	vcdev->cdev = cdev;
+ 	vcdev->dma_area = ccw_device_dma_zalloc(vcdev->cdev,
+ 						sizeof(*vcdev->dma_area));
+ 	if (!vcdev->dma_area) {
++>>>>>>> 48720ba56891 (virtio/s390: use DMA memory for ccw I/O and classic notifiers)
  		ret = -ENOMEM;
  		goto out_free;
  	}
  
  	vcdev->is_thinint = virtio_ccw_use_airq; /* at least try */
  
 +	vcdev->vdev.dev.parent = &cdev->dev;
  	vcdev->vdev.dev.release = virtio_ccw_release_dev;
  	vcdev->vdev.config = &virtio_ccw_config_ops;
- 	vcdev->cdev = cdev;
  	init_waitqueue_head(&vcdev->wait_q);
  	INIT_LIST_HEAD(&vcdev->virtqueues);
  	spin_lock_init(&vcdev->lock);
* Unmerged path drivers/s390/virtio/virtio_ccw.c
