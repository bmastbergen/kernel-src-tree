libbpf: Name changing for btf_get_from_id

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Martin KaFai Lau <kafai@fb.com>
commit 1d2f44ca342445f7da56555ca7a43d19aac8996a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/1d2f44ca.failed

s/btf_get_from_id/btf__get_from_id/ to restore the API naming convention.

	Signed-off-by: Martin KaFai Lau <kafai@fb.com>
	Signed-off-by: Andrey Ignatov <rdna@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit 1d2f44ca342445f7da56555ca7a43d19aac8996a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/bpf/bpftool/map.c
#	tools/lib/bpf/btf.c
#	tools/lib/bpf/btf.h
diff --cc tools/bpf/bpftool/map.c
index 4f5bec07dc46,3850f8d65703..000000000000
--- a/tools/bpf/bpftool/map.c
+++ b/tools/bpf/bpftool/map.c
@@@ -560,8 -712,27 +560,18 @@@ static int do_dump(int argc, char **arg
  	}
  
  	prev_key = NULL;
++<<<<<<< HEAD
++=======
+ 
+ 	err = btf__get_from_id(info.btf_id, &btf);
+ 	if (err) {
+ 		p_err("failed to get btf");
+ 		goto exit_free;
+ 	}
+ 
++>>>>>>> 1d2f44ca3424 (libbpf: Name changing for btf_get_from_id)
  	if (json_output)
  		jsonw_start_array(json_wtr);
 -	else
 -		if (btf) {
 -			btf_wtr = get_btf_writer();
 -			if (!btf_wtr) {
 -				p_info("failed to create json writer for btf. falling back to plain output");
 -				btf__free(btf);
 -				btf = NULL;
 -			} else {
 -				jsonw_start_array(btf_wtr);
 -			}
 -		}
 -
  	while (true) {
  		err = bpf_map_get_next_key(fd, prev_key, key);
  		if (err) {
@@@ -684,21 -840,53 +694,58 @@@ static int do_lookup(int argc, char **a
  		goto exit_free;
  
  	err = bpf_map_lookup_elem(fd, key, value);
++<<<<<<< HEAD
 +	if (!err) {
 +		if (json_output)
 +			print_entry_json(&info, key, value);
 +		else
++=======
+ 	if (err) {
+ 		if (errno == ENOENT) {
+ 			if (json_output) {
+ 				jsonw_null(json_wtr);
+ 			} else {
+ 				printf("key:\n");
+ 				fprint_hex(stdout, key, info.key_size, " ");
+ 				printf("\n\nNot found\n");
+ 			}
+ 		} else {
+ 			p_err("lookup failed: %s", strerror(errno));
+ 		}
+ 
+ 		goto exit_free;
+ 	}
+ 
+ 	/* here means bpf_map_lookup_elem() succeeded */
+ 	err = btf__get_from_id(info.btf_id, &btf);
+ 	if (err) {
+ 		p_err("failed to get btf");
+ 		goto exit_free;
+ 	}
+ 
+ 	if (json_output) {
+ 		print_entry_json(&info, key, value, btf);
+ 	} else if (btf) {
+ 		/* if here json_wtr wouldn't have been initialised,
+ 		 * so let's create separate writer for btf
+ 		 */
+ 		btf_wtr = get_btf_writer();
+ 		if (!btf_wtr) {
+ 			p_info("failed to create json writer for btf. falling back to plain output");
+ 			btf__free(btf);
+ 			btf = NULL;
++>>>>>>> 1d2f44ca3424 (libbpf: Name changing for btf_get_from_id)
  			print_entry_plain(&info, key, value);
 +	} else if (errno == ENOENT) {
 +		if (json_output) {
 +			jsonw_null(json_wtr);
  		} else {
 -			struct btf_dumper d = {
 -				.btf = btf,
 -				.jw = btf_wtr,
 -				.is_plain_text = true,
 -			};
 -
 -			do_dump_btf(&d, &info, key, value);
 -			jsonw_destroy(&btf_wtr);
 +			printf("key:\n");
 +			fprint_hex(stdout, key, info.key_size, " ");
 +			printf("\n\nNot found\n");
  		}
  	} else {
 -		print_entry_plain(&info, key, value);
 +		p_err("lookup failed: %s", strerror(errno));
  	}
  
  exit_free:
diff --cc tools/lib/bpf/btf.c
index ad19a43e946a,eadcf8dfd295..000000000000
--- a/tools/lib/bpf/btf.c
+++ b/tools/lib/bpf/btf.c
@@@ -372,3 -406,337 +372,340 @@@ int btf__fd(const struct btf *btf
  {
  	return btf->fd;
  }
++<<<<<<< HEAD
++=======
+ 
+ const char *btf__name_by_offset(const struct btf *btf, __u32 offset)
+ {
+ 	if (offset < btf->hdr->str_len)
+ 		return &btf->strings[offset];
+ 	else
+ 		return NULL;
+ }
+ 
+ int btf__get_from_id(__u32 id, struct btf **btf)
+ {
+ 	struct bpf_btf_info btf_info = { 0 };
+ 	__u32 len = sizeof(btf_info);
+ 	__u32 last_size;
+ 	int btf_fd;
+ 	void *ptr;
+ 	int err;
+ 
+ 	err = 0;
+ 	*btf = NULL;
+ 	btf_fd = bpf_btf_get_fd_by_id(id);
+ 	if (btf_fd < 0)
+ 		return 0;
+ 
+ 	/* we won't know btf_size until we call bpf_obj_get_info_by_fd(). so
+ 	 * let's start with a sane default - 4KiB here - and resize it only if
+ 	 * bpf_obj_get_info_by_fd() needs a bigger buffer.
+ 	 */
+ 	btf_info.btf_size = 4096;
+ 	last_size = btf_info.btf_size;
+ 	ptr = malloc(last_size);
+ 	if (!ptr) {
+ 		err = -ENOMEM;
+ 		goto exit_free;
+ 	}
+ 
+ 	bzero(ptr, last_size);
+ 	btf_info.btf = ptr_to_u64(ptr);
+ 	err = bpf_obj_get_info_by_fd(btf_fd, &btf_info, &len);
+ 
+ 	if (!err && btf_info.btf_size > last_size) {
+ 		void *temp_ptr;
+ 
+ 		last_size = btf_info.btf_size;
+ 		temp_ptr = realloc(ptr, last_size);
+ 		if (!temp_ptr) {
+ 			err = -ENOMEM;
+ 			goto exit_free;
+ 		}
+ 		ptr = temp_ptr;
+ 		bzero(ptr, last_size);
+ 		btf_info.btf = ptr_to_u64(ptr);
+ 		err = bpf_obj_get_info_by_fd(btf_fd, &btf_info, &len);
+ 	}
+ 
+ 	if (err || btf_info.btf_size > last_size) {
+ 		err = errno;
+ 		goto exit_free;
+ 	}
+ 
+ 	*btf = btf__new((__u8 *)btf_info.btf, btf_info.btf_size, NULL);
+ 	if (IS_ERR(*btf)) {
+ 		err = PTR_ERR(*btf);
+ 		*btf = NULL;
+ 	}
+ 
+ exit_free:
+ 	close(btf_fd);
+ 	free(ptr);
+ 
+ 	return err;
+ }
+ 
+ static int btf_ext_validate_func_info(const void *finfo, __u32 size,
+ 				      btf_print_fn_t err_log)
+ {
+ 	int sec_hdrlen = sizeof(struct btf_sec_func_info);
+ 	__u32 size_left, num_records, record_size;
+ 	const struct btf_sec_func_info *sinfo;
+ 	__u64 total_record_size;
+ 
+ 	/* At least a func_info record size */
+ 	if (size < sizeof(__u32)) {
+ 		elog("BTF.ext func_info record size not found");
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* The record size needs to meet below minimum standard */
+ 	record_size = *(__u32 *)finfo;
+ 	if (record_size < sizeof(struct bpf_func_info_min) ||
+ 	    record_size % sizeof(__u32)) {
+ 		elog("BTF.ext func_info invalid record size");
+ 		return -EINVAL;
+ 	}
+ 
+ 	sinfo = finfo + sizeof(__u32);
+ 	size_left = size - sizeof(__u32);
+ 
+ 	/* If no func_info records, return failure now so .BTF.ext
+ 	 * won't be used.
+ 	 */
+ 	if (!size_left) {
+ 		elog("BTF.ext no func info records");
+ 		return -EINVAL;
+ 	}
+ 
+ 	while (size_left) {
+ 		if (size_left < sec_hdrlen) {
+ 			elog("BTF.ext func_info header not found");
+ 			return -EINVAL;
+ 		}
+ 
+ 		num_records = sinfo->num_func_info;
+ 		if (num_records == 0) {
+ 			elog("incorrect BTF.ext num_func_info");
+ 			return -EINVAL;
+ 		}
+ 
+ 		total_record_size = sec_hdrlen +
+ 				    (__u64)num_records * record_size;
+ 		if (size_left < total_record_size) {
+ 			elog("incorrect BTF.ext num_func_info");
+ 			return -EINVAL;
+ 		}
+ 
+ 		size_left -= total_record_size;
+ 		sinfo = (void *)sinfo + total_record_size;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int btf_ext_parse_hdr(__u8 *data, __u32 data_size,
+ 			     btf_print_fn_t err_log)
+ {
+ 	const struct btf_ext_header *hdr = (struct btf_ext_header *)data;
+ 	__u32 meta_left, last_func_info_pos;
+ 	void *finfo;
+ 
+ 	if (data_size < offsetof(struct btf_ext_header, func_info_off) ||
+ 	    data_size < hdr->hdr_len) {
+ 		elog("BTF.ext header not found");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (hdr->magic != BTF_MAGIC) {
+ 		elog("Invalid BTF.ext magic:%x\n", hdr->magic);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (hdr->version != BTF_VERSION) {
+ 		elog("Unsupported BTF.ext version:%u\n", hdr->version);
+ 		return -ENOTSUP;
+ 	}
+ 
+ 	if (hdr->flags) {
+ 		elog("Unsupported BTF.ext flags:%x\n", hdr->flags);
+ 		return -ENOTSUP;
+ 	}
+ 
+ 	meta_left = data_size - hdr->hdr_len;
+ 	if (!meta_left) {
+ 		elog("BTF.ext has no data\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (meta_left < hdr->func_info_off) {
+ 		elog("Invalid BTF.ext func_info section offset:%u\n",
+ 		     hdr->func_info_off);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (hdr->func_info_off & 0x03) {
+ 		elog("BTF.ext func_info section is not aligned to 4 bytes\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	last_func_info_pos = hdr->hdr_len + hdr->func_info_off +
+ 			     hdr->func_info_len;
+ 	if (last_func_info_pos > data_size) {
+ 		elog("Invalid BTF.ext func_info section size:%u\n",
+ 		     hdr->func_info_len);
+ 		return -EINVAL;
+ 	}
+ 
+ 	finfo = data + hdr->hdr_len + hdr->func_info_off;
+ 	return btf_ext_validate_func_info(finfo, hdr->func_info_len,
+ 					  err_log);
+ }
+ 
+ void btf_ext__free(struct btf_ext *btf_ext)
+ {
+ 	if (!btf_ext)
+ 		return;
+ 
+ 	free(btf_ext->func_info);
+ 	free(btf_ext);
+ }
+ 
+ struct btf_ext *btf_ext__new(__u8 *data, __u32 size, btf_print_fn_t err_log)
+ {
+ 	const struct btf_ext_header *hdr;
+ 	struct btf_ext *btf_ext;
+ 	void *org_fdata, *fdata;
+ 	__u32 hdrlen, size_u32;
+ 	int err;
+ 
+ 	err = btf_ext_parse_hdr(data, size, err_log);
+ 	if (err)
+ 		return ERR_PTR(err);
+ 
+ 	btf_ext = calloc(1, sizeof(struct btf_ext));
+ 	if (!btf_ext)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	hdr = (const struct btf_ext_header *)data;
+ 	hdrlen = hdr->hdr_len;
+ 	size_u32 = sizeof(__u32);
+ 	fdata = malloc(hdr->func_info_len - size_u32);
+ 	if (!fdata) {
+ 		free(btf_ext);
+ 		return ERR_PTR(-ENOMEM);
+ 	}
+ 
+ 	/* remember record size and copy rest of func_info data */
+ 	org_fdata = data + hdrlen + hdr->func_info_off;
+ 	btf_ext->func_info_rec_size = *(__u32 *)org_fdata;
+ 	memcpy(fdata, org_fdata + size_u32, hdr->func_info_len - size_u32);
+ 	btf_ext->func_info = fdata;
+ 	btf_ext->func_info_len = hdr->func_info_len - size_u32;
+ 
+ 	return btf_ext;
+ }
+ 
+ int btf_ext__reloc_init(struct btf *btf, struct btf_ext *btf_ext,
+ 			const char *sec_name, void **func_info,
+ 			__u32 *func_info_rec_size, __u32 *func_info_len)
+ {
+ 	__u32 sec_hdrlen = sizeof(struct btf_sec_func_info);
+ 	__u32 i, record_size, records_len;
+ 	struct btf_sec_func_info *sinfo;
+ 	const char *info_sec_name;
+ 	__s64 remain_len;
+ 	void *data;
+ 
+ 	record_size = btf_ext->func_info_rec_size;
+ 	sinfo = btf_ext->func_info;
+ 	remain_len = btf_ext->func_info_len;
+ 
+ 	while (remain_len > 0) {
+ 		records_len = sinfo->num_func_info * record_size;
+ 		info_sec_name = btf__name_by_offset(btf, sinfo->sec_name_off);
+ 		if (strcmp(info_sec_name, sec_name)) {
+ 			remain_len -= sec_hdrlen + records_len;
+ 			sinfo = (void *)sinfo + sec_hdrlen + records_len;
+ 			continue;
+ 		}
+ 
+ 		data = malloc(records_len);
+ 		if (!data)
+ 			return -ENOMEM;
+ 
+ 		memcpy(data, sinfo->data, records_len);
+ 
+ 		/* adjust the insn_offset, the data in .BTF.ext is
+ 		 * the actual byte offset, and the kernel expects
+ 		 * the offset in term of bpf_insn.
+ 		 *
+ 		 * adjust the insn offset only, the rest data will
+ 		 * be passed to kernel.
+ 		 */
+ 		for (i = 0; i < sinfo->num_func_info; i++) {
+ 			struct bpf_func_info_min *record;
+ 
+ 			record = data + i * record_size;
+ 			record->insn_offset /= sizeof(struct bpf_insn);
+ 		}
+ 
+ 		*func_info = data;
+ 		*func_info_len = records_len;
+ 		*func_info_rec_size = record_size;
+ 		return 0;
+ 	}
+ 
+ 	return -EINVAL;
+ }
+ 
+ int btf_ext__reloc(struct btf *btf, struct btf_ext *btf_ext,
+ 		   const char *sec_name, __u32 insns_cnt,
+ 		   void **func_info, __u32 *func_info_len)
+ {
+ 	__u32 sec_hdrlen = sizeof(struct btf_sec_func_info);
+ 	__u32 i, record_size, existing_flen, records_len;
+ 	struct btf_sec_func_info *sinfo;
+ 	const char *info_sec_name;
+ 	__u64 remain_len;
+ 	void *data;
+ 
+ 	record_size = btf_ext->func_info_rec_size;
+ 	sinfo = btf_ext->func_info;
+ 	remain_len = btf_ext->func_info_len;
+ 	while (remain_len > 0) {
+ 		records_len = sinfo->num_func_info * record_size;
+ 		info_sec_name = btf__name_by_offset(btf, sinfo->sec_name_off);
+ 		if (strcmp(info_sec_name, sec_name)) {
+ 			remain_len -= sec_hdrlen + records_len;
+ 			sinfo = (void *)sinfo + sec_hdrlen + records_len;
+ 			continue;
+ 		}
+ 
+ 		existing_flen = *func_info_len;
+ 		data = realloc(*func_info, existing_flen + records_len);
+ 		if (!data)
+ 			return -ENOMEM;
+ 
+ 		memcpy(data + existing_flen, sinfo->data, records_len);
+ 		/* adjust insn_offset only, the rest data will be passed
+ 		 * to the kernel.
+ 		 */
+ 		for (i = 0; i < sinfo->num_func_info; i++) {
+ 			struct bpf_func_info_min *record;
+ 
+ 			record = data + existing_flen + i * record_size;
+ 			record->insn_offset =
+ 				record->insn_offset / sizeof(struct bpf_insn) +
+ 				insns_cnt;
+ 		}
+ 		*func_info = data;
+ 		*func_info_len = existing_flen + records_len;
+ 		return 0;
+ 	}
+ 
+ 	return -EINVAL;
+ }
++>>>>>>> 1d2f44ca3424 (libbpf: Name changing for btf_get_from_id)
diff --cc tools/lib/bpf/btf.h
index caac3a404dc5,5336b2f37293..000000000000
--- a/tools/lib/bpf/btf.h
+++ b/tools/lib/bpf/btf.h
@@@ -14,11 -24,68 +14,25 @@@ struct btf_type
  typedef int (*btf_print_fn_t)(const char *, ...)
  	__attribute__((format(printf, 1, 2)));
  
++<<<<<<< HEAD
 +void btf__free(struct btf *btf);
 +struct btf *btf__new(__u8 *data, __u32 size, btf_print_fn_t err_log);
 +__s32 btf__find_by_name(const struct btf *btf, const char *type_name);
 +const struct btf_type *btf__type_by_id(const struct btf *btf, __u32 id);
 +__s64 btf__resolve_size(const struct btf *btf, __u32 type_id);
 +int btf__fd(const struct btf *btf);
++=======
+ LIBBPF_API void btf__free(struct btf *btf);
+ LIBBPF_API struct btf *btf__new(__u8 *data, __u32 size, btf_print_fn_t err_log);
+ LIBBPF_API __s32 btf__find_by_name(const struct btf *btf,
+ 				   const char *type_name);
+ LIBBPF_API const struct btf_type *btf__type_by_id(const struct btf *btf,
+ 						  __u32 id);
+ LIBBPF_API __s64 btf__resolve_size(const struct btf *btf, __u32 type_id);
+ LIBBPF_API int btf__resolve_type(const struct btf *btf, __u32 type_id);
+ LIBBPF_API int btf__fd(const struct btf *btf);
+ LIBBPF_API const char *btf__name_by_offset(const struct btf *btf, __u32 offset);
+ LIBBPF_API int btf__get_from_id(__u32 id, struct btf **btf);
++>>>>>>> 1d2f44ca3424 (libbpf: Name changing for btf_get_from_id)
  
 -struct btf_ext *btf_ext__new(__u8 *data, __u32 size, btf_print_fn_t err_log);
 -void btf_ext__free(struct btf_ext *btf_ext);
 -int btf_ext__reloc_init(struct btf *btf, struct btf_ext *btf_ext,
 -			const char *sec_name, void **func_info,
 -			__u32 *func_info_rec_size, __u32 *func_info_len);
 -int btf_ext__reloc(struct btf *btf, struct btf_ext *btf_ext,
 -		   const char *sec_name, __u32 insns_cnt, void **func_info,
 -		   __u32 *func_info_len);
 -
 -#ifdef __cplusplus
 -} /* extern "C" */
  #endif
 -
 -#endif /* __LIBBPF_BTF_H */
* Unmerged path tools/bpf/bpftool/map.c
diff --git a/tools/bpf/bpftool/prog.c b/tools/bpf/bpftool/prog.c
index 2c39fe85a416..5cff6ba9da1b 100644
--- a/tools/bpf/bpftool/prog.c
+++ b/tools/bpf/bpftool/prog.c
@@ -622,7 +622,7 @@ static int do_dump(int argc, char **argv)
 		goto err_free;
 	}
 
-	if (info.btf_id && btf_get_from_id(info.btf_id, &btf)) {
+	if (info.btf_id && btf__get_from_id(info.btf_id, &btf)) {
 		p_err("failed to get btf");
 		goto err_free;
 	}
* Unmerged path tools/lib/bpf/btf.c
* Unmerged path tools/lib/bpf/btf.h
diff --git a/tools/testing/selftests/bpf/test_btf.c b/tools/testing/selftests/bpf/test_btf.c
index b4c8725b3004..bae7308b7ec5 100644
--- a/tools/testing/selftests/bpf/test_btf.c
+++ b/tools/testing/selftests/bpf/test_btf.c
@@ -2585,7 +2585,7 @@ static int do_test_file(unsigned int test_num)
 		goto done;
 	}
 
-	err = btf_get_from_id(info.btf_id, &btf);
+	err = btf__get_from_id(info.btf_id, &btf);
 	if (CHECK(err, "cannot get btf from kernel, err: %d", err))
 		goto done;
 
