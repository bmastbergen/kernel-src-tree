mlxsw: spectrum_acl: Don't take rtnl lock during vregion_rehash_intrvl_set()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jiri Pirko <jiri@mellanox.com>
commit 7b0f62eefc7f04a6fd3bddc88cf39c7a60f28672
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/7b0f62ee.failed

Relax dependency on rtnl mutex during vregion_rehash_intrvl_set(). The
vregion list is protected with newly introduced mutex.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7b0f62eefc7f04a6fd3bddc88cf39c7a60f28672)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
index c607c62a43ae,5c8976e471ad..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
@@@ -33,6 -38,11 +33,14 @@@ int mlxsw_sp_acl_tcam_init(struct mlxsw
  	size_t alloc_size;
  	int err;
  
++<<<<<<< HEAD
++=======
+ 	mutex_init(&tcam->lock);
+ 	tcam->vregion_rehash_intrvl =
+ 			MLXSW_SP_ACL_TCAM_VREGION_REHASH_INTRVL_DFLT;
+ 	INIT_LIST_HEAD(&tcam->vregion_list);
+ 
++>>>>>>> 7b0f62eefc7f (mlxsw: spectrum_acl: Don't take rtnl lock during vregion_rehash_intrvl_set())
  	max_tcam_regions = MLXSW_CORE_RES_GET(mlxsw_sp->core,
  					      ACL_MAX_TCAM_REGIONS);
  	max_regions = MLXSW_CORE_RES_GET(mlxsw_sp->core, ACL_MAX_REGIONS);
@@@ -630,8 -776,25 +639,26 @@@ mlxsw_sp_acl_tcam_vregion_create(struc
  		goto err_region_create;
  	}
  
++<<<<<<< HEAD
++=======
+ 	err = mlxsw_sp_acl_tcam_vgroup_vregion_attach(mlxsw_sp, vgroup, vregion,
+ 						      priority);
+ 	if (err)
+ 		goto err_vgroup_vregion_attach;
+ 
+ 	if (vgroup->vregion_rehash_enabled && ops->region_rehash_hints_get) {
+ 		/* Create the delayed work for vregion periodic rehash */
+ 		INIT_DELAYED_WORK(&vregion->rehash_dw,
+ 				  mlxsw_sp_acl_tcam_vregion_rehash_work);
+ 		mlxsw_sp_acl_tcam_vregion_rehash_work_schedule(vregion);
+ 		mutex_lock(&tcam->lock);
+ 		list_add_tail(&vregion->tlist, &tcam->vregion_list);
+ 		mutex_unlock(&tcam->lock);
+ 	}
+ 
++>>>>>>> 7b0f62eefc7f (mlxsw: spectrum_acl: Don't take rtnl lock during vregion_rehash_intrvl_set())
  	return vregion;
  
 -err_vgroup_vregion_attach:
 -	mlxsw_sp_acl_tcam_region_destroy(mlxsw_sp, vregion->region);
  err_region_create:
  	mlxsw_afk_key_info_put(vregion->key_info);
  err_key_info_get:
@@@ -643,62 -806,92 +670,120 @@@ static voi
  mlxsw_sp_acl_tcam_vregion_destroy(struct mlxsw_sp *mlxsw_sp,
  				  struct mlxsw_sp_acl_tcam_vregion *vregion)
  {
++<<<<<<< HEAD
++=======
+ 	const struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;
+ 	struct mlxsw_sp_acl_tcam_vgroup *vgroup = vregion->vgroup;
+ 	struct mlxsw_sp_acl_tcam *tcam = vregion->tcam;
+ 
+ 	if (vgroup->vregion_rehash_enabled && ops->region_rehash_hints_get) {
+ 		mutex_lock(&tcam->lock);
+ 		list_del(&vregion->tlist);
+ 		mutex_unlock(&tcam->lock);
+ 		cancel_delayed_work_sync(&vregion->rehash_dw);
+ 	}
+ 	mlxsw_sp_acl_tcam_vgroup_vregion_detach(mlxsw_sp, vregion);
+ 	if (vregion->region2)
+ 		mlxsw_sp_acl_tcam_region_destroy(mlxsw_sp, vregion->region2);
++>>>>>>> 7b0f62eefc7f (mlxsw: spectrum_acl: Don't take rtnl lock during vregion_rehash_intrvl_set())
  	mlxsw_sp_acl_tcam_region_destroy(mlxsw_sp, vregion->region);
  	mlxsw_afk_key_info_put(vregion->key_info);
 -	mutex_destroy(&vregion->lock);
  	kfree(vregion);
  }
  
 -u32 mlxsw_sp_acl_tcam_vregion_rehash_intrvl_get(struct mlxsw_sp *mlxsw_sp,
 -						struct mlxsw_sp_acl_tcam *tcam)
 +static int
 +mlxsw_sp_acl_tcam_vchunk_assoc(struct mlxsw_sp *mlxsw_sp,
 +			       struct mlxsw_sp_acl_tcam_group *group,
 +			       unsigned int priority,
 +			       struct mlxsw_afk_element_usage *elusage,
 +			       struct mlxsw_sp_acl_tcam_vchunk *vchunk)
  {
++<<<<<<< HEAD
++=======
+ 	const struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;
+ 	u32 vregion_rehash_intrvl;
+ 
+ 	if (WARN_ON(!ops->region_rehash_hints_get))
+ 		return 0;
+ 	vregion_rehash_intrvl = tcam->vregion_rehash_intrvl;
+ 	return vregion_rehash_intrvl;
+ }
+ 
+ int mlxsw_sp_acl_tcam_vregion_rehash_intrvl_set(struct mlxsw_sp *mlxsw_sp,
+ 						struct mlxsw_sp_acl_tcam *tcam,
+ 						u32 val)
+ {
+ 	const struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;
+ 	struct mlxsw_sp_acl_tcam_vregion *vregion;
+ 
+ 	if (val < MLXSW_SP_ACL_TCAM_VREGION_REHASH_INTRVL_MIN && val)
+ 		return -EINVAL;
+ 	if (WARN_ON(!ops->region_rehash_hints_get))
+ 		return -EOPNOTSUPP;
+ 	tcam->vregion_rehash_intrvl = val;
+ 	mutex_lock(&tcam->lock);
+ 	list_for_each_entry(vregion, &tcam->vregion_list, tlist) {
+ 		if (val)
+ 			mlxsw_core_schedule_dw(&vregion->rehash_dw, 0);
+ 		else
+ 			cancel_delayed_work_sync(&vregion->rehash_dw);
+ 	}
+ 	mutex_unlock(&tcam->lock);
+ 	return 0;
+ }
+ 
+ static struct mlxsw_sp_acl_tcam_vregion *
+ mlxsw_sp_acl_tcam_vregion_get(struct mlxsw_sp *mlxsw_sp,
+ 			      struct mlxsw_sp_acl_tcam_vgroup *vgroup,
+ 			      unsigned int priority,
+ 			      struct mlxsw_afk_element_usage *elusage)
+ {
+ 	struct mlxsw_afk_element_usage vregion_elusage;
++>>>>>>> 7b0f62eefc7f (mlxsw: spectrum_acl: Don't take rtnl lock during vregion_rehash_intrvl_set())
  	struct mlxsw_sp_acl_tcam_vregion *vregion;
 +	bool vregion_created = false;
  	bool need_split;
 +	int err;
  
 -	vregion = mlxsw_sp_acl_tcam_vgroup_vregion_find(vgroup, priority,
 -							elusage, &need_split);
 -	if (vregion) {
 -		if (need_split) {
 -			/* According to priority, new vchunk should belong to
 -			 * an existing vregion. However, this vchunk needs
 -			 * elements that vregion does not contain. We need
 -			 * to split the existing vregion into two and create
 -			 * a new vregion for the new vchunk in between.
 -			 * This is not supported now.
 -			 */
 -			return ERR_PTR(-EOPNOTSUPP);
 -		}
 -		vregion->ref_count++;
 -		return vregion;
 +	vregion = mlxsw_sp_acl_tcam_group_vregion_find(group, priority, elusage,
 +						       &need_split);
 +	if (vregion && need_split) {
 +		/* According to priority, the vchunk should belong to an
 +		 * existing vregion. However, this vchunk needs elements
 +		 * that vregion does not contain. We need to split the existing
 +		 * vregion into two and create a new vregion for this vchunk
 +		 * in between. This is not supported now.
 +		 */
 +		return -EOPNOTSUPP;
 +	}
 +	if (!vregion) {
 +		struct mlxsw_afk_element_usage vregion_elusage;
 +
 +		mlxsw_sp_acl_tcam_group_use_patterns(group, elusage,
 +						     &vregion_elusage);
 +		vregion = mlxsw_sp_acl_tcam_vregion_create(mlxsw_sp,
 +							   group->tcam,
 +							   &vregion_elusage);
 +		if (IS_ERR(vregion))
 +			return PTR_ERR(vregion);
 +		vregion_created = true;
  	}
  
 -	mlxsw_sp_acl_tcam_vgroup_use_patterns(vgroup, elusage,
 -					      &vregion_elusage);
 +	vchunk->vregion = vregion;
 +	list_add_tail(&vchunk->list, &vregion->vchunk_list);
 +
 +	if (!vregion_created)
 +		return 0;
 +
 +	err = mlxsw_sp_acl_tcam_group_vregion_attach(mlxsw_sp, group, vregion);
 +	if (err)
 +		goto err_group_vregion_attach;
  
 -	return mlxsw_sp_acl_tcam_vregion_create(mlxsw_sp, vgroup, priority,
 -						&vregion_elusage);
 +	return 0;
 +
 +err_group_vregion_attach:
 +	mlxsw_sp_acl_tcam_vregion_destroy(mlxsw_sp, vregion);
 +	return err;
  }
  
  static void
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h
index a90942bc1fe9,5965913565a5..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h
@@@ -17,6 -17,9 +17,12 @@@ struct mlxsw_sp_acl_tcam 
  	unsigned long *used_groups;  /* bit array */
  	unsigned int max_groups;
  	unsigned int max_group_size;
++<<<<<<< HEAD
++=======
+ 	struct mutex lock; /* guards vregion list */
+ 	struct list_head vregion_list;
+ 	u32 vregion_rehash_intrvl;   /* ms */
++>>>>>>> 7b0f62eefc7f (mlxsw: spectrum_acl: Don't take rtnl lock during vregion_rehash_intrvl_set())
  	unsigned long priv[0];
  	/* priv has to be always the last item */
  };
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h
