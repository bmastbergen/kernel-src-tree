nvmet: track and limit the number of namespaces per subsystem

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 793c7cfce02ce88b7bd67d43834c052d16c096e3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/793c7cfc.failed

TP 4004 introduces a new 'Maximum Number of Allocated Namespaces' field
in the Identify controller data to help the host size resources.  Put
an upper limit on the supported namespaces to be able to support this
value as supporting 32-bits worth of namespaces would lead to very
large buffers.  The limit is completely arbitrary at this point.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Keith Busch <keith.busch@intel.com>
	Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
(cherry picked from commit 793c7cfce02ce88b7bd67d43834c052d16c096e3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/target/core.c
diff --cc drivers/nvme/target/core.c
index cbb053d0f927,42e8565015d5..000000000000
--- a/drivers/nvme/target/core.c
+++ b/drivers/nvme/target/core.c
@@@ -420,10 -337,13 +420,18 @@@ static void nvmet_p2pmem_ns_add_p2p(str
  int nvmet_ns_enable(struct nvmet_ns *ns)
  {
  	struct nvmet_subsys *subsys = ns->subsys;
++<<<<<<< HEAD
 +	struct nvmet_ctrl *ctrl;
 +	int ret = 0;
++=======
+ 	int ret;
++>>>>>>> 793c7cfce02c (nvmet: track and limit the number of namespaces per subsystem)
  
  	mutex_lock(&subsys->lock);
+ 	ret = -EMFILE;
+ 	if (subsys->nr_namespaces == NVMET_MAX_NAMESPACES)
+ 		goto out_unlock;
+ 	ret = 0;
  	if (ns->enabled)
  		goto out_unlock;
  
diff --git a/drivers/nvme/target/admin-cmd.c b/drivers/nvme/target/admin-cmd.c
index 16a9b24270f9..55f2bf4b5d07 100644
--- a/drivers/nvme/target/admin-cmd.c
+++ b/drivers/nvme/target/admin-cmd.c
@@ -252,6 +252,7 @@ static void nvmet_execute_identify_ctrl(struct nvmet_req *req)
 	id->maxcmd = cpu_to_le16(NVMET_MAX_CMD);
 
 	id->nn = cpu_to_le32(ctrl->subsys->max_nsid);
+	id->mnan = cpu_to_le32(NVMET_MAX_NAMESPACES);
 	id->oncs = cpu_to_le16(NVME_CTRL_ONCS_DSM |
 			NVME_CTRL_ONCS_WRITE_ZEROES);
 
* Unmerged path drivers/nvme/target/core.c
diff --git a/drivers/nvme/target/nvmet.h b/drivers/nvme/target/nvmet.h
index 89c4b1275043..d04121daced1 100644
--- a/drivers/nvme/target/nvmet.h
+++ b/drivers/nvme/target/nvmet.h
@@ -181,6 +181,7 @@ struct nvmet_subsys {
 	struct kref		ref;
 
 	struct list_head	namespaces;
+	unsigned int		nr_namespaces;
 	unsigned int		max_nsid;
 
 	struct list_head	ctrls;
@@ -376,6 +377,13 @@ u32 nvmet_get_log_page_len(struct nvme_command *cmd);
 #define NVMET_QUEUE_SIZE	1024
 #define NVMET_NR_QUEUES		128
 #define NVMET_MAX_CMD		NVMET_QUEUE_SIZE
+
+/*
+ * Nice round number that makes a list of nsids fit into a page.
+ * Should become tunable at some point in the future.
+ */
+#define NVMET_MAX_NAMESPACES	1024
+
 #define NVMET_KAS		10
 #define NVMET_DISC_KATO		120
 
