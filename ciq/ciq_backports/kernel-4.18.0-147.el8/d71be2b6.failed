arm64: cpufeature: Detect SSBS and advertise to userspace

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Will Deacon <will.deacon@arm.com>
commit d71be2b6c0e19180b5f80a6d42039cc074a693a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/d71be2b6.failed

Armv8.5 introduces a new PSTATE bit known as Speculative Store Bypass
Safe (SSBS) which can be used as a mitigation against Spectre variant 4.

Additionally, a CPU may provide instructions to manipulate PSTATE.SSBS
directly, so that userspace can toggle the SSBS control without trapping
to the kernel.

This patch probes for the existence of SSBS and advertise the new instructions
to userspace if they exist.

	Reviewed-by: Suzuki K Poulose <suzuki.poulose@arm.com>
	Signed-off-by: Will Deacon <will.deacon@arm.com>
	Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
(cherry picked from commit d71be2b6c0e19180b5f80a6d42039cc074a693a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/asm/cpucaps.h
#	arch/arm64/include/uapi/asm/hwcap.h
#	arch/arm64/kernel/cpufeature.c
#	arch/arm64/kernel/cpuinfo.c
diff --cc arch/arm64/include/asm/cpucaps.h
index c0f5aa4ec4c9,38eec9cf30f2..000000000000
--- a/arch/arm64/include/asm/cpucaps.h
+++ b/arch/arm64/include/asm/cpucaps.h
@@@ -49,9 -49,11 +49,18 @@@
  #define ARM64_HAS_CACHE_DIC			28
  #define ARM64_HW_DBM				29
  #define ARM64_SSBD				30
++<<<<<<< HEAD
 +#define ARM64_HAS_SB				31
 +#define ARM64_HAS_CNP				32
 +
 +#define ARM64_NCAPS				33
++=======
+ #define ARM64_MISMATCHED_CACHE_TYPE		31
+ #define ARM64_HAS_STAGE2_FWB			32
+ #define ARM64_HAS_CRC32				33
+ #define ARM64_SSBS				34
+ 
+ #define ARM64_NCAPS				35
++>>>>>>> d71be2b6c0e1 (arm64: cpufeature: Detect SSBS and advertise to userspace)
  
  #endif /* __ASM_CPUCAPS_H */
diff --cc arch/arm64/include/uapi/asm/hwcap.h
index 61d92b00261b,2bcd6e4f3474..000000000000
--- a/arch/arm64/include/uapi/asm/hwcap.h
+++ b/arch/arm64/include/uapi/asm/hwcap.h
@@@ -48,6 -48,6 +48,10 @@@
  #define HWCAP_USCAT		(1 << 25)
  #define HWCAP_ILRCPC		(1 << 26)
  #define HWCAP_FLAGM		(1 << 27)
++<<<<<<< HEAD
 +#define HWCAP_SB		(1 << 29)
++=======
+ #define HWCAP_SSBS		(1 << 28)
++>>>>>>> d71be2b6c0e1 (arm64: cpufeature: Detect SSBS and advertise to userspace)
  
  #endif /* _UAPI__ASM_HWCAP_H */
diff --cc arch/arm64/kernel/cpufeature.c
index cbb9accafe8b,5794959d8beb..000000000000
--- a/arch/arm64/kernel/cpufeature.c
+++ b/arch/arm64/kernel/cpufeature.c
@@@ -1220,28 -1227,24 +1224,41 @@@ static const struct arm64_cpu_capabilit
  	},
  #endif
  	{
 -		.desc = "CRC32 instructions",
 -		.capability = ARM64_HAS_CRC32,
 +		.desc = "Speculation barrier (SB)",
 +		.capability = ARM64_HAS_SB,
  		.type = ARM64_CPUCAP_SYSTEM_FEATURE,
  		.matches = has_cpuid_feature,
 -		.sys_reg = SYS_ID_AA64ISAR0_EL1,
 -		.field_pos = ID_AA64ISAR0_CRC32_SHIFT,
 +		.sys_reg = SYS_ID_AA64ISAR1_EL1,
 +		.field_pos = ID_AA64ISAR1_SB_SHIFT,
 +		.sign = FTR_UNSIGNED,
 +		.min_field_value = 1,
 +	},
++<<<<<<< HEAD
 +#ifdef CONFIG_ARM64_CNP
 +	{
 +		.desc = "Common not Private translations",
 +		.capability = ARM64_HAS_CNP,
 +		.type = ARM64_CPUCAP_SYSTEM_FEATURE,
 +		.matches = has_useable_cnp,
 +		.sys_reg = SYS_ID_AA64MMFR2_EL1,
 +		.sign = FTR_UNSIGNED,
 +		.field_pos = ID_AA64MMFR2_CNP_SHIFT,
  		.min_field_value = 1,
 +		.cpu_enable = cpu_enable_cnp,
  	},
 +#endif
++=======
+ 	{
+ 		.desc = "Speculative Store Bypassing Safe (SSBS)",
+ 		.capability = ARM64_SSBS,
+ 		.type = ARM64_CPUCAP_WEAK_LOCAL_CPU_FEATURE,
+ 		.matches = has_cpuid_feature,
+ 		.sys_reg = SYS_ID_AA64PFR1_EL1,
+ 		.field_pos = ID_AA64PFR1_SSBS_SHIFT,
+ 		.sign = FTR_UNSIGNED,
+ 		.min_field_value = ID_AA64PFR1_SSBS_PSTATE_ONLY,
+ 	},
++>>>>>>> d71be2b6c0e1 (arm64: cpufeature: Detect SSBS and advertise to userspace)
  	{},
  };
  
diff --cc arch/arm64/kernel/cpuinfo.c
index e9fc9d7eae34,dce971f2c167..000000000000
--- a/arch/arm64/kernel/cpuinfo.c
+++ b/arch/arm64/kernel/cpuinfo.c
@@@ -81,7 -81,7 +81,11 @@@ static const char *const hwcap_str[] = 
  	"uscat",
  	"ilrcpc",
  	"flagm",
++<<<<<<< HEAD
 +	"sb",
++=======
+ 	"ssbs",
++>>>>>>> d71be2b6c0e1 (arm64: cpufeature: Detect SSBS and advertise to userspace)
  	NULL
  };
  
* Unmerged path arch/arm64/include/asm/cpucaps.h
diff --git a/arch/arm64/include/asm/sysreg.h b/arch/arm64/include/asm/sysreg.h
index 9e38d54b6b00..347d6b4258ee 100644
--- a/arch/arm64/include/asm/sysreg.h
+++ b/arch/arm64/include/asm/sysreg.h
@@ -432,6 +432,7 @@
 #define SYS_ZCR_EL12			sys_reg(3, 5, 1, 2, 0)
 
 /* Common SCTLR_ELx flags. */
+#define SCTLR_ELx_DSSBS	(1UL << 44)
 #define SCTLR_ELx_EE    (1 << 25)
 #define SCTLR_ELx_IESB	(1 << 21)
 #define SCTLR_ELx_WXN	(1 << 19)
@@ -452,7 +453,7 @@
 			 (1 << 10) | (1 << 13) | (1 << 14) | (1 << 15) | \
 			 (1 << 17) | (1 << 20) | (1 << 24) | (1 << 26) | \
 			 (1 << 27) | (1 << 30) | (1 << 31) | \
-			 (0xffffffffUL << 32))
+			 (0xffffefffUL << 32))
 
 #ifdef CONFIG_CPU_BIG_ENDIAN
 #define ENDIAN_SET_EL2		SCTLR_ELx_EE
@@ -466,7 +467,7 @@
 #define SCTLR_EL2_SET	(SCTLR_ELx_IESB   | ENDIAN_SET_EL2   | SCTLR_EL2_RES1)
 #define SCTLR_EL2_CLEAR	(SCTLR_ELx_M      | SCTLR_ELx_A    | SCTLR_ELx_C   | \
 			 SCTLR_ELx_SA     | SCTLR_ELx_I    | SCTLR_ELx_WXN | \
-			 ENDIAN_CLEAR_EL2 | SCTLR_EL2_RES0)
+			 SCTLR_ELx_DSSBS | ENDIAN_CLEAR_EL2 | SCTLR_EL2_RES0)
 
 #if (SCTLR_EL2_SET ^ SCTLR_EL2_CLEAR) != 0xffffffffffffffff
 #error "Inconsistent SCTLR_EL2 set/clear bits"
@@ -490,7 +491,7 @@
 			 (1 << 29))
 #define SCTLR_EL1_RES0  ((1 << 6)  | (1 << 10) | (1 << 13) | (1 << 17) | \
 			 (1 << 27) | (1 << 30) | (1 << 31) | \
-			 (0xffffffffUL << 32))
+			 (0xffffefffUL << 32))
 
 #ifdef CONFIG_CPU_BIG_ENDIAN
 #define ENDIAN_SET_EL1		(SCTLR_EL1_E0E | SCTLR_ELx_EE)
@@ -507,7 +508,7 @@
 			 ENDIAN_SET_EL1 | SCTLR_EL1_UCI  | SCTLR_EL1_RES1)
 #define SCTLR_EL1_CLEAR	(SCTLR_ELx_A   | SCTLR_EL1_CP15BEN | SCTLR_EL1_ITD    |\
 			 SCTLR_EL1_UMA | SCTLR_ELx_WXN     | ENDIAN_CLEAR_EL1 |\
-			 SCTLR_EL1_RES0)
+			 SCTLR_ELx_DSSBS | SCTLR_EL1_RES0)
 
 #if (SCTLR_EL1_SET ^ SCTLR_EL1_CLEAR) != 0xffffffffffffffff
 #error "Inconsistent SCTLR_EL1 set/clear bits"
@@ -558,6 +559,13 @@
 #define ID_AA64PFR0_EL0_64BIT_ONLY	0x1
 #define ID_AA64PFR0_EL0_32BIT_64BIT	0x2
 
+/* id_aa64pfr1 */
+#define ID_AA64PFR1_SSBS_SHIFT		4
+
+#define ID_AA64PFR1_SSBS_PSTATE_NI	0
+#define ID_AA64PFR1_SSBS_PSTATE_ONLY	1
+#define ID_AA64PFR1_SSBS_PSTATE_INSNS	2
+
 /* id_aa64mmfr0 */
 #define ID_AA64MMFR0_TGRAN4_SHIFT	28
 #define ID_AA64MMFR0_TGRAN64_SHIFT	24
* Unmerged path arch/arm64/include/uapi/asm/hwcap.h
* Unmerged path arch/arm64/kernel/cpufeature.c
* Unmerged path arch/arm64/kernel/cpuinfo.c
