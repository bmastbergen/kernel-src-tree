drm/nouveau: Only recalculate PBN/VCPI on mode/connector changes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Lyude Paul <lyude@redhat.com>
commit db1231ddc04682f60d56ff42447f13099c6c4a4c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/db1231dd.failed

I -thought- I had fixed this entirely, but it looks like that I didn't
test this thoroughly enough as we apparently still make one big mistake
with nv50_msto_atomic_check() - we don't handle the following scenario:

* CRTC #1 has n VCPI allocated to it, is attached to connector DP-4
  which is attached to encoder #1. enabled=y active=n
* CRTC #1 is changed from DP-4 to DP-5, causing:
  * DP-4 crtc=#1→NULL (VCPI n→0)
  * DP-5 crtc=NULL→#1
  * CRTC #1 steals encoder #1 back from DP-4 and gives it to DP-5
  * CRTC #1 maintains the same mode as before, just with a different
    connector
* mode_changed=n connectors_changed=y
  (we _SHOULD_ do VCPI 0→n here, but don't)

Once the above scenario is repeated once, we'll attempt freeing VCPI
from the connector that we didn't allocate due to the connectors
changing, but the mode staying the same. Sigh.

Since nv50_msto_atomic_check() has broken a few times now, let's rethink
things a bit to be more careful: limit both VCPI/PBN allocations to
mode_changed || connectors_changed, since neither VCPI or PBN should
ever need to change outside of routing and mode changes.

Changes since v1:
* Fix accidental reversal of clock and bpp arguments in
  drm_dp_calc_pbn_mode() - William Lewis

	Signed-off-by: Lyude Paul <lyude@redhat.com>
	Reported-by: Bohdan Milar <bmilar@redhat.com>
	Tested-by: Bohdan Milar <bmilar@redhat.com>
Fixes: 232c9eec417a ("drm/nouveau: Use atomic VCPI helpers for MST")
References: 412e85b60531 ("drm/nouveau: Only release VCPI slots on mode changes")
	Cc: Lyude Paul <lyude@redhat.com>
	Cc: Ben Skeggs <bskeggs@redhat.com>
	Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
	Cc: David Airlie <airlied@redhat.com>
	Cc: Jerry Zuo <Jerry.Zuo@amd.com>
	Cc: Harry Wentland <harry.wentland@amd.com>
	Cc: Juston Li <juston.li@intel.com>
	Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
	Cc: Karol Herbst <karolherbst@gmail.com>
	Cc: Ilia Mirkin <imirkin@alum.mit.edu>
	Cc: <stable@vger.kernel.org> # v5.1+
	Acked-by: Ben Skeggs <bskeggs@redhat.com>
	Signed-off-by: Dave Airlie <airlied@redhat.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190809005307.18391-1-lyude@redhat.com
(cherry picked from commit db1231ddc04682f60d56ff42447f13099c6c4a4c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/nouveau/dispnv50/disp.c
diff --cc drivers/gpu/drm/nouveau/dispnv50/disp.c
index 37293d7f32f3,5c36c75232e6..000000000000
--- a/drivers/gpu/drm/nouveau/dispnv50/disp.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/disp.c
@@@ -684,16 -764,35 +684,41 @@@ nv50_msto_atomic_check(struct drm_encod
  		       struct drm_crtc_state *crtc_state,
  		       struct drm_connector_state *conn_state)
  {
 -	struct drm_atomic_state *state = crtc_state->state;
 -	struct drm_connector *connector = conn_state->connector;
 -	struct nv50_mstc *mstc = nv50_mstc(connector);
 +	struct nv50_mstc *mstc = nv50_mstc(conn_state->connector);
  	struct nv50_mstm *mstm = mstc->mstm;
 -	struct nv50_head_atom *asyh = nv50_head_atom(crtc_state);
 +	int bpp = conn_state->connector->display_info.bpc * 3;
  	int slots;
  
++<<<<<<< HEAD
 +	mstc->pbn = drm_dp_calc_pbn_mode(crtc_state->adjusted_mode.clock, bpp);
 +
 +	slots = drm_dp_find_vcpi_slots(&mstm->mgr, mstc->pbn);
 +	if (slots < 0)
 +		return slots;
++=======
+ 	if (crtc_state->mode_changed || crtc_state->connectors_changed) {
+ 		/*
+ 		 * When restoring duplicated states, we need to make sure that
+ 		 * the bw remains the same and avoid recalculating it, as the
+ 		 * connector's bpc may have changed after the state was
+ 		 * duplicated
+ 		 */
+ 		if (!state->duplicated) {
+ 			const int bpp = connector->display_info.bpc * 3;
+ 			const int clock = crtc_state->adjusted_mode.clock;
+ 
+ 			asyh->dp.pbn = drm_dp_calc_pbn_mode(clock, bpp);
+ 		}
+ 
+ 		slots = drm_dp_atomic_find_vcpi_slots(state, &mstm->mgr,
+ 						      mstc->port,
+ 						      asyh->dp.pbn);
+ 		if (slots < 0)
+ 			return slots;
+ 
+ 		asyh->dp.tu = slots;
+ 	}
++>>>>>>> db1231ddc046 (drm/nouveau: Only recalculate PBN/VCPI on mode/connector changes)
  
  	return nv50_outp_atomic_check_view(encoder, crtc_state, conn_state,
  					   mstc->native);
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/disp.c
