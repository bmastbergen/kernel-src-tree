scsi: qla2xxx: Fix driver unload when FC-NVMe LUNs are connected

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Giridhar Malavali <gmalavali@marvell.com>
commit b2d1453a45aa8477b1d33ee94a7694146bb8b340
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/b2d1453a.failed

This patch allows driver to unload using "modprobe -r" when FC-NVMe LUNs
are connected.

	Signed-off-by: Giridhar Malavali <gmalavali@marvell.com>
	Signed-off-by: Himanshu Madhani <hmadhani@marvell.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit b2d1453a45aa8477b1d33ee94a7694146bb8b340)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_os.c
diff --cc drivers/scsi/qla2xxx/qla_os.c
index 9af7817f8d01,d49208c16928..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -6415,13 -6742,26 +6415,28 @@@ qla2x00_timer(struct timer_list *t
  	 * FC-NVME
  	 * see if the active AEN count has changed from what was last reported.
  	 */
++<<<<<<< HEAD
++=======
+ 	if (!vha->vp_idx &&
+ 	    (atomic_read(&ha->nvme_active_aen_cnt) != ha->nvme_last_rptd_aen) &&
+ 	    ha->zio_mode == QLA_ZIO_MODE_6 &&
+ 	    !ha->flags.host_shutting_down) {
+ 		ql_log(ql_log_info, vha, 0x3002,
+ 		    "nvme: Sched: Set ZIO exchange threshold to %d.\n",
+ 		    ha->nvme_last_rptd_aen);
+ 		ha->nvme_last_rptd_aen = atomic_read(&ha->nvme_active_aen_cnt);
+ 		set_bit(SET_NVME_ZIO_THRESHOLD_NEEDED, &vha->dpc_flags);
+ 		start_dpc++;
+ 	}
+ 
++>>>>>>> b2d1453a45aa (scsi: qla2xxx: Fix driver unload when FC-NVMe LUNs are connected)
  	if (!vha->vp_idx &&
 -	    (atomic_read(&ha->zio_threshold) != ha->last_zio_threshold) &&
 -	    (ha->zio_mode == QLA_ZIO_MODE_6) &&
 -	    (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha))) {
 +		atomic_read(&ha->nvme_active_aen_cnt) != ha->nvme_last_rptd_aen &&
 +		ha->zio_mode == QLA_ZIO_MODE_6) {
  		ql_log(ql_log_info, vha, 0x3002,
 -		    "Sched: Set ZIO exchange threshold to %d.\n",
 -		    ha->last_zio_threshold);
 -		ha->last_zio_threshold = atomic_read(&ha->zio_threshold);
 +			"nvme: Sched: Set ZIO exchange threshold to %d.\n",
 +			ha->nvme_last_rptd_aen);
 +		ha->nvme_last_rptd_aen = atomic_read(&ha->nvme_active_aen_cnt);
  		set_bit(SET_ZIO_THRESHOLD_NEEDED, &vha->dpc_flags);
  		start_dpc++;
  	}
diff --git a/drivers/scsi/qla2xxx/qla_nvme.c b/drivers/scsi/qla2xxx/qla_nvme.c
index e6775656d006..12c7b28724bd 100644
--- a/drivers/scsi/qla2xxx/qla_nvme.c
+++ b/drivers/scsi/qla2xxx/qla_nvme.c
@@ -161,12 +161,13 @@ static void qla_nvme_sp_done(void *ptr, int res)
 	if (!atomic_dec_and_test(&sp->ref_count))
 		return;
 
-	if (res == QLA_SUCCESS)
-		fd->status = 0;
-	else
-		fd->status = NVME_SC_INTERNAL;
-
-	fd->rcv_rsplen = nvme->u.nvme.rsp_pyld_len;
+	if (res == QLA_SUCCESS) {
+		fd->rcv_rsplen = nvme->u.nvme.rsp_pyld_len;
+	} else {
+		fd->rcv_rsplen = 0;
+		fd->transferred_length = 0;
+	}
+	fd->status = 0;
 	fd->done(fd);
 	qla2xxx_rel_qpair_sp(sp->qpair, sp);
 
@@ -190,6 +191,22 @@ static void qla_nvme_abort_work(struct work_struct *work)
 	if (!ha->flags.fw_started && (fcport && fcport->deleted))
 		return;
 
+	if (ha->flags.host_shutting_down) {
+		ql_log(ql_log_info, sp->fcport->vha, 0xffff,
+		    "%s Calling done on sp: %p, type: 0x%x, sp->ref_count: 0x%x\n",
+		    __func__, sp, sp->type, atomic_read(&sp->ref_count));
+		sp->done(sp, 0);
+		return;
+	}
+
+	if (atomic_read(&sp->ref_count) == 0) {
+		WARN_ON(1);
+		ql_log(ql_log_info, fcport->vha, 0xffff,
+			"%s: command alredy aborted on sp: %p\n",
+			__func__, sp);
+		return;
+	}
+
 	rval = ha->isp_ops->abort_command(sp);
 
 	ql_dbg(ql_dbg_io, fcport->vha, 0x212b,
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
