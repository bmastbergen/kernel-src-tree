IB/uverbs: Do not pass struct ib_device to the write based methods

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jason Gunthorpe <jgg@ziepe.ca>
commit bbd51e881ff05aa6dccda025e335438f3b3a1dba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/bbd51e88.failed

This is a step to get rid of the global check for disassociation. In this
model, the ib_dev is not proven to be valid by the core code and cannot be
provided to the method. Instead, every method decides if it is able to
run after disassociation and obtains the ib_dev using one of three
different approaches:

- Call srcu_dereference on the udevice's ib_dev. As before, this means
  the method cannot be called after disassociation begins.
  (eg alloc ucontext)
- Retrieve the ib_dev from the ucontext, via ib_uverbs_get_ucontext()
- Retrieve the ib_dev from the uobject->object after checking
  under SRCU if disassociation has started (eg uobj_get)

Largely, the code is all ready for this, the main work is to provide a
ib_dev after calling uobj_alloc(). The few other places simply use
ib_uverbs_get_ucontext() to get the ib_dev.

This flexibility will let the next patches allow destroy to operate
after disassociation.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit bbd51e881ff05aa6dccda025e335438f3b3a1dba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_cmd.c
#	include/rdma/uverbs_std_types.h
diff --cc drivers/infiniband/core/uverbs_cmd.c
index 300532a4cde8,465b4d921024..000000000000
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@@ -60,13 -59,13 +60,12 @@@ ib_uverbs_lookup_comp_file(int fd, stru
  	uverbs_uobject_get(uobj);
  	uobj_put_read(uobj);
  
 -	return container_of(uobj, struct ib_uverbs_completion_event_file,
 -			    uobj);
 +	uobj_file = container_of(uobj, struct ib_uobject_file, uobj);
 +	return container_of(uobj_file, struct ib_uverbs_completion_event_file,
 +			    uobj_file);
  }
 -#define ib_uverbs_lookup_comp_file(_fd, _ufile)                                \
 -	_ib_uverbs_lookup_comp_file((_fd)*typecheck(s32, _fd), _ufile)
  
  ssize_t ib_uverbs_get_context(struct ib_uverbs_file *file,
- 			      struct ib_device *ib_dev,
  			      const char __user *buf,
  			      int in_len, int out_len)
  {
@@@ -84,7 -84,13 +84,17 @@@
  	if (copy_from_user(&cmd, buf, sizeof cmd))
  		return -EFAULT;
  
++<<<<<<< HEAD
 +	mutex_lock(&file->mutex);
++=======
+ 	mutex_lock(&file->ucontext_lock);
+ 	ib_dev = srcu_dereference(file->device->ib_dev,
+ 				  &file->device->disassociate_srcu);
+ 	if (!ib_dev) {
+ 		ret = -EIO;
+ 		goto err;
+ 	}
++>>>>>>> bbd51e881ff0 (IB/uverbs: Do not pass struct ib_device to the write based methods)
  
  	if (file->ucontext) {
  		ret = -EINVAL;
@@@ -346,7 -367,7 +367,11 @@@ ssize_t ib_uverbs_alloc_pd(struct ib_uv
                     in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
                     out_len - sizeof(resp));
  
++<<<<<<< HEAD
 +	uobj  = uobj_alloc(UVERBS_OBJECT_PD, file->ucontext);
++=======
+ 	uobj = uobj_alloc(UVERBS_OBJECT_PD, file, &ib_dev);
++>>>>>>> bbd51e881ff0 (IB/uverbs: Do not pass struct ib_device to the write based methods)
  	if (IS_ERR(uobj))
  		return PTR_ERR(uobj);
  
@@@ -533,8 -551,8 +557,13 @@@ ssize_t ib_uverbs_open_xrcd(struct ib_u
  		}
  	}
  
++<<<<<<< HEAD
 +	obj  = (struct ib_uxrcd_object *)uobj_alloc(UVERBS_OBJECT_XRCD,
 +						    file->ucontext);
++=======
+ 	obj = (struct ib_uxrcd_object *)uobj_alloc(UVERBS_OBJECT_XRCD, file,
+ 						   &ib_dev);
++>>>>>>> bbd51e881ff0 (IB/uverbs: Do not pass struct ib_device to the write based methods)
  	if (IS_ERR(obj)) {
  		ret = PTR_ERR(obj);
  		goto err_tree_mutex_unlock;
@@@ -672,7 -691,7 +700,11 @@@ ssize_t ib_uverbs_reg_mr(struct ib_uver
  	if (ret)
  		return ret;
  
++<<<<<<< HEAD
 +	uobj  = uobj_alloc(UVERBS_OBJECT_MR, file->ucontext);
++=======
+ 	uobj = uobj_alloc(UVERBS_OBJECT_MR, file, &ib_dev);
++>>>>>>> bbd51e881ff0 (IB/uverbs: Do not pass struct ib_device to the write based methods)
  	if (IS_ERR(uobj))
  		return PTR_ERR(uobj);
  
@@@ -860,7 -875,7 +890,11 @@@ ssize_t ib_uverbs_alloc_mw(struct ib_uv
  	if (copy_from_user(&cmd, buf, sizeof(cmd)))
  		return -EFAULT;
  
++<<<<<<< HEAD
 +	uobj  = uobj_alloc(UVERBS_OBJECT_MW, file->ucontext);
++=======
+ 	uobj = uobj_alloc(UVERBS_OBJECT_MW, file, &ib_dev);
++>>>>>>> bbd51e881ff0 (IB/uverbs: Do not pass struct ib_device to the write based methods)
  	if (IS_ERR(uobj))
  		return PTR_ERR(uobj);
  
@@@ -941,7 -953,7 +974,11 @@@ ssize_t ib_uverbs_create_comp_channel(s
  	if (copy_from_user(&cmd, buf, sizeof cmd))
  		return -EFAULT;
  
++<<<<<<< HEAD
 +	uobj = uobj_alloc(UVERBS_OBJECT_COMP_CHANNEL, file->ucontext);
++=======
+ 	uobj = uobj_alloc(UVERBS_OBJECT_COMP_CHANNEL, file, &ib_dev);
++>>>>>>> bbd51e881ff0 (IB/uverbs: Do not pass struct ib_device to the write based methods)
  	if (IS_ERR(uobj))
  		return PTR_ERR(uobj);
  
@@@ -986,14 -994,18 +1020,24 @@@ static struct ib_ucq_object *create_cq(
  	if (cmd->comp_vector >= file->device->num_comp_vectors)
  		return ERR_PTR(-EINVAL);
  
++<<<<<<< HEAD
 +	obj  = (struct ib_ucq_object *)uobj_alloc(UVERBS_OBJECT_CQ,
 +						  file->ucontext);
++=======
+ 	obj = (struct ib_ucq_object *)uobj_alloc(UVERBS_OBJECT_CQ, file,
+ 						 &ib_dev);
++>>>>>>> bbd51e881ff0 (IB/uverbs: Do not pass struct ib_device to the write based methods)
  	if (IS_ERR(obj))
  		return obj;
  
+ 	if (!ib_dev->create_cq) {
+ 		ret = -EOPNOTSUPP;
+ 		goto err;
+ 	}
+ 
  	if (cmd->comp_channel >= 0) {
 -		ev_file = ib_uverbs_lookup_comp_file(cmd->comp_channel, file);
 +		ev_file = ib_uverbs_lookup_comp_file(cmd->comp_channel,
 +						     file->ucontext);
  		if (IS_ERR(ev_file)) {
  			ret = PTR_ERR(ev_file);
  			goto err;
@@@ -1372,8 -1365,8 +1411,13 @@@ static int create_qp(struct ib_uverbs_f
  	if (cmd->qp_type == IB_QPT_RAW_PACKET && !capable(CAP_NET_RAW))
  		return -EPERM;
  
++<<<<<<< HEAD
 +	obj  = (struct ib_uqp_object *)uobj_alloc(UVERBS_OBJECT_QP,
 +						  file->ucontext);
++=======
+ 	obj = (struct ib_uqp_object *)uobj_alloc(UVERBS_OBJECT_QP, file,
+ 						 &ib_dev);
++>>>>>>> bbd51e881ff0 (IB/uverbs: Do not pass struct ib_device to the write based methods)
  	if (IS_ERR(obj))
  		return PTR_ERR(obj);
  	obj->uxrcd = NULL;
@@@ -1752,8 -1743,8 +1794,13 @@@ ssize_t ib_uverbs_open_qp(struct ib_uve
  		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
  		   out_len - sizeof(resp));
  
++<<<<<<< HEAD
 +	obj  = (struct ib_uqp_object *)uobj_alloc(UVERBS_OBJECT_QP,
 +						  file->ucontext);
++=======
+ 	obj = (struct ib_uqp_object *)uobj_alloc(UVERBS_OBJECT_QP, file,
+ 						 &ib_dev);
++>>>>>>> bbd51e881ff0 (IB/uverbs: Do not pass struct ib_device to the write based methods)
  	if (IS_ERR(obj))
  		return PTR_ERR(obj);
  
@@@ -2635,11 -2530,16 +2672,24 @@@ ssize_t ib_uverbs_create_ah(struct ib_u
  		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
  		   out_len - sizeof(resp));
  
++<<<<<<< HEAD
 +	uobj  = uobj_alloc(UVERBS_OBJECT_AH, file->ucontext);
 +	if (IS_ERR(uobj))
 +		return PTR_ERR(uobj);
 +
 +	pd = uobj_get_obj_read(pd, UVERBS_OBJECT_PD, cmd.pd_handle, file->ucontext);
++=======
+ 	uobj = uobj_alloc(UVERBS_OBJECT_AH, file, &ib_dev);
+ 	if (IS_ERR(uobj))
+ 		return PTR_ERR(uobj);
+ 
+ 	if (!rdma_is_port_valid(ib_dev, cmd.attr.port_num)) {
+ 		ret = -EINVAL;
+ 		goto err;
+ 	}
+ 
+ 	pd = uobj_get_obj_read(pd, UVERBS_OBJECT_PD, cmd.pd_handle, file);
++>>>>>>> bbd51e881ff0 (IB/uverbs: Do not pass struct ib_device to the write based methods)
  	if (!pd) {
  		ret = -EINVAL;
  		goto err;
@@@ -3165,8 -3060,8 +3212,13 @@@ int ib_uverbs_ex_create_wq(struct ib_uv
  	if (cmd.comp_mask)
  		return -EOPNOTSUPP;
  
++<<<<<<< HEAD
 +	obj  = (struct ib_uwq_object *)uobj_alloc(UVERBS_OBJECT_WQ,
 +						  file->ucontext);
++=======
+ 	obj = (struct ib_uwq_object *)uobj_alloc(UVERBS_OBJECT_WQ, file,
+ 						 &ib_dev);
++>>>>>>> bbd51e881ff0 (IB/uverbs: Do not pass struct ib_device to the write based methods)
  	if (IS_ERR(obj))
  		return PTR_ERR(obj);
  
@@@ -3435,7 -3318,7 +3485,11 @@@ int ib_uverbs_ex_create_rwq_ind_table(s
  		wqs[num_read_wqs] = wq;
  	}
  
++<<<<<<< HEAD
 +	uobj  = uobj_alloc(UVERBS_OBJECT_RWQ_IND_TBL, file->ucontext);
++=======
+ 	uobj = uobj_alloc(UVERBS_OBJECT_RWQ_IND_TBL, file, &ib_dev);
++>>>>>>> bbd51e881ff0 (IB/uverbs: Do not pass struct ib_device to the write based methods)
  	if (IS_ERR(uobj)) {
  		err = PTR_ERR(uobj);
  		goto put_wqs;
@@@ -3539,10 -3419,11 +3591,11 @@@ int ib_uverbs_ex_create_flow(struct ib_
  	struct ib_flow_attr		  *flow_attr;
  	struct ib_qp			  *qp;
  	struct ib_uflow_resources	  *uflow_res;
 +	struct ib_uverbs_flow_spec_hdr	  *kern_spec;
  	int err = 0;
 -	void *kern_spec;
  	void *ib_spec;
  	int i;
+ 	struct ib_device *ib_dev;
  
  	if (ucore->inlen < sizeof(cmd))
  		return -EINVAL;
@@@ -3598,7 -3479,7 +3651,11 @@@
  		kern_flow_attr = &cmd.flow_attr;
  	}
  
++<<<<<<< HEAD
 +	uobj  = uobj_alloc(UVERBS_OBJECT_FLOW, file->ucontext);
++=======
+ 	uobj = uobj_alloc(UVERBS_OBJECT_FLOW, file, &ib_dev);
++>>>>>>> bbd51e881ff0 (IB/uverbs: Do not pass struct ib_device to the write based methods)
  	if (IS_ERR(uobj)) {
  		err = PTR_ERR(uobj);
  		goto err_free_attr;
@@@ -3739,9 -3615,10 +3794,15 @@@ static int __uverbs_create_xsrq(struct 
  	struct ib_uobject               *uninitialized_var(xrcd_uobj);
  	struct ib_srq_init_attr          attr;
  	int ret;
+ 	struct ib_device *ib_dev;
  
++<<<<<<< HEAD
 +	obj  = (struct ib_usrq_object *)uobj_alloc(UVERBS_OBJECT_SRQ,
 +						   file->ucontext);
++=======
+ 	obj = (struct ib_usrq_object *)uobj_alloc(UVERBS_OBJECT_SRQ, file,
+ 						  &ib_dev);
++>>>>>>> bbd51e881ff0 (IB/uverbs: Do not pass struct ib_device to the write based methods)
  	if (IS_ERR(obj))
  		return PTR_ERR(obj);
  
diff --cc include/rdma/uverbs_std_types.h
index 27c24453fc12,64ee2545dd3d..000000000000
--- a/include/rdma/uverbs_std_types.h
+++ b/include/rdma/uverbs_std_types.h
@@@ -105,13 -125,18 +105,28 @@@ static inline void uobj_alloc_abort(str
  }
  
  static inline struct ib_uobject *__uobj_alloc(const struct uverbs_obj_type *type,
++<<<<<<< HEAD
 +					      struct ib_ucontext *ucontext)
 +{
 +	return rdma_alloc_begin_uobject(type, ucontext);
 +}
 +
 +#define uobj_alloc(_type, ucontext)	\
 +	__uobj_alloc(uobj_get_type(_type), ucontext)
++=======
+ 					      struct ib_uverbs_file *ufile,
+ 					      struct ib_device **ib_dev)
+ {
+ 	struct ib_uobject *uobj = rdma_alloc_begin_uobject(type, ufile);
+ 
+ 	if (!IS_ERR(uobj))
+ 		*ib_dev = uobj->context->device;
+ 	return uobj;
+ }
+ 
+ #define uobj_alloc(_type, _ufile, _ib_dev)                                     \
+ 	__uobj_alloc(uobj_get_type(_type), _ufile, _ib_dev)
++>>>>>>> bbd51e881ff0 (IB/uverbs: Do not pass struct ib_device to the write based methods)
  
  #endif
  
diff --git a/drivers/infiniband/core/uverbs.h b/drivers/infiniband/core/uverbs.h
index 6700adb08a26..190512f1fd2c 100644
--- a/drivers/infiniband/core/uverbs.h
+++ b/drivers/infiniband/core/uverbs.h
@@ -291,7 +291,6 @@ extern const struct uverbs_object_def UVERBS_OBJECT(UVERBS_OBJECT_COUNTERS);
 
 #define IB_UVERBS_DECLARE_CMD(name)					\
 	ssize_t ib_uverbs_##name(struct ib_uverbs_file *file,		\
-				 struct ib_device *ib_dev,              \
 				 const char __user *buf, int in_len,	\
 				 int out_len)
 
@@ -333,7 +332,6 @@ IB_UVERBS_DECLARE_CMD(close_xrcd);
 
 #define IB_UVERBS_DECLARE_EX_CMD(name)				\
 	int ib_uverbs_ex_##name(struct ib_uverbs_file *file,	\
-				struct ib_device *ib_dev,		\
 				struct ib_udata *ucore,		\
 				struct ib_udata *uhw)
 
* Unmerged path drivers/infiniband/core/uverbs_cmd.c
diff --git a/drivers/infiniband/core/uverbs_main.c b/drivers/infiniband/core/uverbs_main.c
index f24a6ab4cbde..72431714c01a 100644
--- a/drivers/infiniband/core/uverbs_main.c
+++ b/drivers/infiniband/core/uverbs_main.c
@@ -77,7 +77,6 @@ static struct class *uverbs_class;
 static DECLARE_BITMAP(dev_map, IB_UVERBS_MAX_DEVICES);
 
 static ssize_t (*uverbs_cmd_table[])(struct ib_uverbs_file *file,
-				     struct ib_device *ib_dev,
 				     const char __user *buf, int in_len,
 				     int out_len) = {
 	[IB_USER_VERBS_CMD_GET_CONTEXT]		= ib_uverbs_get_context,
@@ -118,7 +117,6 @@ static ssize_t (*uverbs_cmd_table[])(struct ib_uverbs_file *file,
 };
 
 static int (*uverbs_ex_cmd_table[])(struct ib_uverbs_file *file,
-				    struct ib_device *ib_dev,
 				    struct ib_udata *ucore,
 				    struct ib_udata *uhw) = {
 	[IB_USER_VERBS_EX_CMD_CREATE_FLOW]	= ib_uverbs_ex_create_flow,
@@ -774,7 +772,7 @@ static ssize_t ib_uverbs_write(struct file *filp, const char __user *buf,
 	buf += sizeof(hdr);
 
 	if (!extended) {
-		ret = uverbs_cmd_table[command](file, ib_dev, buf,
+		ret = uverbs_cmd_table[command](file, buf,
 						hdr.in_words * 4,
 						hdr.out_words * 4);
 	} else {
@@ -793,7 +791,7 @@ static ssize_t ib_uverbs_write(struct file *filp, const char __user *buf,
 					ex_hdr.provider_in_words * 8,
 					ex_hdr.provider_out_words * 8);
 
-		ret = uverbs_ex_cmd_table[command](file, ib_dev, &ucore, &uhw);
+		ret = uverbs_ex_cmd_table[command](file, &ucore, &uhw);
 		ret = (ret) ? : count;
 	}
 
* Unmerged path include/rdma/uverbs_std_types.h
