IB/mlx5: Add support for DEVX query UAR

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Yishai Hadas <yishaih@mellanox.com>
commit 7c043e908a74ae0a935037cdd984d0cb89b2b970
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/7c043e90.failed

Return a device UAR index for a given user index via the DEVX interface.

Security note:
The hardware protection mechanism works like this: Each device object that
is subject to UAR doorbells (QP/SQ/CQ) gets a UAR ID (called uar_page in
the device specification manual) upon its creation. Then upon doorbell,
hardware fetches the object context for which the doorbell was rang, and
validates that the UAR through which the DB was rang matches the UAR ID
of the object.

If no match the doorbell is silently ignored by the hardware.  Of
course, the user cannot ring a doorbell on a UAR that was not mapped to
it.

Now in devx, as the devx kernel does not manipulate the QP/SQ/CQ command
mailboxes (except tagging them with UID), we expose to the user its UAR
ID, so it can embed it in these objects in the expected specification
format. So the only thing the user can do is hurt itself by creating a
QP/SQ/CQ with a UAR ID other than his, and then in this case other users
may ring a doorbell on its objects.

The consequence of that will be that another user can schedule a QP/SQ
of the buggy user for execution (just insert it to the hardware schedule
queue or arm its CQ for event generation), no further harm is expected.

	Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 7c043e908a74ae0a935037cdd984d0cb89b2b970)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/devx.c
diff --cc drivers/infiniband/hw/mlx5/devx.c
index 87116a3b7916,9b1804eb9924..000000000000
--- a/drivers/infiniband/hw/mlx5/devx.c
+++ b/drivers/infiniband/hw/mlx5/devx.c
@@@ -430,6 -705,95 +474,98 @@@ obj_free
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int UVERBS_HANDLER(MLX5_IB_METHOD_DEVX_OBJ_MODIFY)(struct ib_device *ib_dev,
+ 				   struct ib_uverbs_file *file,
+ 				   struct uverbs_attr_bundle *attrs)
+ {
+ 	struct mlx5_ib_ucontext *c = devx_ufile2uctx(file);
+ 	struct mlx5_ib_dev *dev = to_mdev(ib_dev);
+ 	void *cmd_in = uverbs_attr_get_alloced_ptr(attrs, MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_IN);
+ 	int cmd_out_len = uverbs_attr_get_len(attrs,
+ 					MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_OUT);
+ 	struct ib_uobject *uobj = uverbs_attr_get_uobject(attrs,
+ 							  MLX5_IB_ATTR_DEVX_OBJ_MODIFY_HANDLE);
+ 	void *cmd_out;
+ 	int err;
+ 
+ 	if (!c->devx_uid)
+ 		return -EPERM;
+ 
+ 	if (!devx_is_obj_modify_cmd(cmd_in))
+ 		return -EINVAL;
+ 
+ 	if (!devx_is_valid_obj_id(uobj->object, cmd_in))
+ 		return -EINVAL;
+ 
+ 	cmd_out = kvzalloc(cmd_out_len, GFP_KERNEL);
+ 	if (!cmd_out)
+ 		return -ENOMEM;
+ 
+ 	MLX5_SET(general_obj_in_cmd_hdr, cmd_in, uid, c->devx_uid);
+ 	err = mlx5_cmd_exec(dev->mdev, cmd_in,
+ 			    uverbs_attr_get_len(attrs, MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_IN),
+ 			    cmd_out, cmd_out_len);
+ 	if (err)
+ 		goto other_cmd_free;
+ 
+ 	err = uverbs_copy_to(attrs, MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_OUT,
+ 			     cmd_out, cmd_out_len);
+ 
+ other_cmd_free:
+ 	kvfree(cmd_out);
+ 	return err;
+ }
+ 
+ static int UVERBS_HANDLER(MLX5_IB_METHOD_DEVX_OBJ_QUERY)(struct ib_device *ib_dev,
+ 				   struct ib_uverbs_file *file,
+ 				   struct uverbs_attr_bundle *attrs)
+ {
+ 	struct mlx5_ib_ucontext *c = devx_ufile2uctx(file);
+ 	struct mlx5_ib_dev *dev = to_mdev(ib_dev);
+ 	void *cmd_in = uverbs_attr_get_alloced_ptr(attrs, MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_IN);
+ 	int cmd_out_len = uverbs_attr_get_len(attrs,
+ 					      MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_OUT);
+ 	struct ib_uobject *uobj = uverbs_attr_get_uobject(attrs,
+ 							  MLX5_IB_ATTR_DEVX_OBJ_QUERY_HANDLE);
+ 	void *cmd_out;
+ 	int err;
+ 
+ 	if (!c->devx_uid)
+ 		return -EPERM;
+ 
+ 	if (!devx_is_obj_query_cmd(cmd_in))
+ 		return -EINVAL;
+ 
+ 	if (!devx_is_valid_obj_id(uobj->object, cmd_in))
+ 		return -EINVAL;
+ 
+ 	cmd_out = kvzalloc(cmd_out_len, GFP_KERNEL);
+ 	if (!cmd_out)
+ 		return -ENOMEM;
+ 
+ 	MLX5_SET(general_obj_in_cmd_hdr, cmd_in, uid, c->devx_uid);
+ 	err = mlx5_cmd_exec(dev->mdev, cmd_in,
+ 			    uverbs_attr_get_len(attrs, MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_IN),
+ 			    cmd_out, cmd_out_len);
+ 	if (err)
+ 		goto other_cmd_free;
+ 
+ 	err = uverbs_copy_to(attrs, MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_OUT, cmd_out, cmd_out_len);
+ 
+ other_cmd_free:
+ 	kvfree(cmd_out);
+ 	return err;
+ }
+ 
+ static DECLARE_UVERBS_NAMED_METHOD(MLX5_IB_METHOD_DEVX_QUERY_UAR,
+ 	&UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_DEVX_QUERY_UAR_USER_IDX, UVERBS_ATTR_TYPE(u32),
+ 			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
+ 	&UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_DEVX_QUERY_UAR_DEV_IDX, UVERBS_ATTR_TYPE(u32),
+ 			     UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
+ 
++>>>>>>> 7c043e908a74 (IB/mlx5: Add support for DEVX query UAR)
  static DECLARE_UVERBS_NAMED_METHOD(MLX5_IB_METHOD_DEVX_OTHER,
  	&UVERBS_ATTR_PTR_IN_SZ(MLX5_IB_ATTR_DEVX_OTHER_CMD_IN,
  			       UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
@@@ -463,8 -827,39 +599,9 @@@ static DECLARE_UVERBS_NAMED_METHOD(MLX5
  			 UVERBS_ACCESS_DESTROY,
  			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
  
 -static DECLARE_UVERBS_NAMED_METHOD(MLX5_IB_METHOD_DEVX_OBJ_MODIFY,
 -	&UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_MODIFY_HANDLE,
 -			 MLX5_IB_OBJECT_DEVX_OBJ,
 -			 UVERBS_ACCESS_WRITE,
 -			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 -	&UVERBS_ATTR_PTR_IN_SZ(MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_IN,
 -			       UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
 -			       UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY |
 -					UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO |
 -					UVERBS_ATTR_SPEC_F_ALLOC_AND_COPY)),
 -	&UVERBS_ATTR_PTR_OUT_SZ(MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_OUT,
 -				UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_out_cmd_hdr)),
 -				UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY |
 -					 UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO)));
 -
 -static DECLARE_UVERBS_NAMED_METHOD(MLX5_IB_METHOD_DEVX_OBJ_QUERY,
 -	&UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_QUERY_HANDLE,
 -			 MLX5_IB_OBJECT_DEVX_OBJ,
 -			 UVERBS_ACCESS_READ,
 -			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 -	&UVERBS_ATTR_PTR_IN_SZ(MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_IN,
 -			       UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
 -			       UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY |
 -					UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO |
 -					UVERBS_ATTR_SPEC_F_ALLOC_AND_COPY)),
 -	&UVERBS_ATTR_PTR_OUT_SZ(MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_OUT,
 -				UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_out_cmd_hdr)),
 -				UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY |
 -					 UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO)));
 -
  static DECLARE_UVERBS_GLOBAL_METHODS(MLX5_IB_OBJECT_DEVX,
- 	&UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OTHER));
+ 	&UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OTHER),
+ 	&UVERBS_METHOD(MLX5_IB_METHOD_DEVX_QUERY_UAR));
  
  static DECLARE_UVERBS_NAMED_OBJECT(MLX5_IB_OBJECT_DEVX_OBJ,
  	&UVERBS_TYPE_ALLOC_IDR(0, devx_obj_cleanup),
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
diff --git a/drivers/infiniband/hw/mlx5/mlx5_ib.h b/drivers/infiniband/hw/mlx5/mlx5_ib.h
index 0a444a251012..85d796ab82ff 100644
--- a/drivers/infiniband/hw/mlx5/mlx5_ib.h
+++ b/drivers/infiniband/hw/mlx5/mlx5_ib.h
@@ -1329,4 +1329,7 @@ static inline int get_num_static_uars(struct mlx5_ib_dev *dev,
 unsigned long mlx5_ib_get_xlt_emergency_page(void);
 void mlx5_ib_put_xlt_emergency_page(void);
 
+int bfregn_to_uar_index(struct mlx5_ib_dev *dev,
+			struct mlx5_bfreg_info *bfregi, int bfregn,
+			bool dyn_bfreg);
 #endif /* MLX5_IB_H */
diff --git a/drivers/infiniband/hw/mlx5/qp.c b/drivers/infiniband/hw/mlx5/qp.c
index d5e714bb62f2..d8f6223be476 100644
--- a/drivers/infiniband/hw/mlx5/qp.c
+++ b/drivers/infiniband/hw/mlx5/qp.c
@@ -641,9 +641,9 @@ static void mlx5_ib_lock_cqs(struct mlx5_ib_cq *send_cq,
 static void mlx5_ib_unlock_cqs(struct mlx5_ib_cq *send_cq,
 			       struct mlx5_ib_cq *recv_cq);
 
-static int bfregn_to_uar_index(struct mlx5_ib_dev *dev,
-			       struct mlx5_bfreg_info *bfregi, int bfregn,
-			       bool dyn_bfreg)
+int bfregn_to_uar_index(struct mlx5_ib_dev *dev,
+			struct mlx5_bfreg_info *bfregi, int bfregn,
+			bool dyn_bfreg)
 {
 	int bfregs_per_sys_page;
 	int index_of_sys_page;
@@ -653,6 +653,9 @@ static int bfregn_to_uar_index(struct mlx5_ib_dev *dev,
 				MLX5_NON_FP_BFREGS_PER_UAR;
 	index_of_sys_page = bfregn / bfregs_per_sys_page;
 
+	if (index_of_sys_page >= bfregi->num_sys_pages)
+		return -EINVAL;
+
 	if (dyn_bfreg) {
 		index_of_sys_page += bfregi->num_static_sys_pages;
 		if (bfregn > bfregi->num_dyn_bfregs ||
diff --git a/include/uapi/rdma/mlx5_user_ioctl_cmds.h b/include/uapi/rdma/mlx5_user_ioctl_cmds.h
index 8d285f4555cd..6c14a342779f 100644
--- a/include/uapi/rdma/mlx5_user_ioctl_cmds.h
+++ b/include/uapi/rdma/mlx5_user_ioctl_cmds.h
@@ -47,6 +47,7 @@ enum mlx5_ib_alloc_dm_attrs {
 
 enum mlx5_ib_devx_methods {
 	MLX5_IB_METHOD_DEVX_OTHER  = (1U << UVERBS_ID_NS_SHIFT),
+	MLX5_IB_METHOD_DEVX_QUERY_UAR,
 };
 
 enum  mlx5_ib_devx_other_attrs {
@@ -60,6 +61,11 @@ enum mlx5_ib_devx_obj_create_attrs {
 	MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_OUT,
 };
 
+enum  mlx5_ib_devx_query_uar_attrs {
+	MLX5_IB_ATTR_DEVX_QUERY_UAR_USER_IDX = (1U << UVERBS_ID_NS_SHIFT),
+	MLX5_IB_ATTR_DEVX_QUERY_UAR_DEV_IDX,
+};
+
 enum mlx5_ib_devx_obj_destroy_attrs {
 	MLX5_IB_ATTR_DEVX_OBJ_DESTROY_HANDLE = (1U << UVERBS_ID_NS_SHIFT),
 };
