net/mlx5e: Use dedicated uplink vport netdev representor

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Or Gerlitz <ogerlitz@mellanox.com>
commit d9ee0491c2ffbb5bc8bc418dd857a045d0d0130f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/d9ee0491.failed

Currently, when running in sriov switchdev mode, we are using the PF
netdevice as the uplink representor, this is problematic from few aspects:

- will break when the PF isn't eswitch manager (e.g smart NIC env)
- misalignment with other NIC switchdev drivers
- makes us have and maintain special code, hurts the driver quality/robustness
- which in turn opens the door for future bugs

As of each and all of the above, we move to have a dedicated netdev representor
for the uplink vport in a similar manner done for for the VF vports.

This includes the following:

1. have an uplink rep netdev as we have for VF reps
2. all reps use same load/unload functions
3. HW stats for uplink based on physical port counters and not vport counters
4. link state for the uplink managed through PAOS and not vport state
5. the uplink rep has sysfs link to the PF PCI function && uses the PF MAC address

	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit d9ee0491c2ffbb5bc8bc418dd857a045d0d0130f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index 58cddf0a96a7,b48ba3234ac5..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -196,14 -312,21 +222,14 @@@ static const struct ethtool_ops mlx5e_r
  	.get_strings       = mlx5e_rep_get_strings,
  	.get_sset_count    = mlx5e_rep_get_sset_count,
  	.get_ethtool_stats = mlx5e_rep_get_ethtool_stats,
 -	.get_ringparam     = mlx5e_rep_get_ringparam,
 -	.set_ringparam     = mlx5e_rep_set_ringparam,
 -	.get_channels      = mlx5e_rep_get_channels,
 -	.set_channels      = mlx5e_rep_set_channels,
 -	.get_rxfh_key_size   = mlx5e_rep_get_rxfh_key_size,
 -	.get_rxfh_indir_size = mlx5e_rep_get_rxfh_indir_size,
  };
  
- int mlx5e_attr_get(struct net_device *dev, struct switchdev_attr *attr)
+ static int mlx5e_attr_get(struct net_device *dev, struct switchdev_attr *attr)
  {
  	struct mlx5e_priv *priv = netdev_priv(dev);
 +	struct mlx5e_rep_priv *rpriv = priv->ppriv;
 +	struct mlx5_eswitch_rep *rep = rpriv->rep;
  	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
 -	struct net_device *uplink_upper = NULL;
 -	struct mlx5e_priv *uplink_priv = NULL;
 -	struct net_device *uplink_dev;
  
  	if (esw->mode == SRIOV_NONE)
  		return -EOPNOTSUPP;
@@@ -466,7 -602,25 +492,29 @@@ mlx5e_rep_indr_offload(struct net_devic
  		       struct tc_cls_flower_offload *flower,
  		       struct mlx5e_rep_indr_block_priv *indr_priv)
  {
++<<<<<<< HEAD
 +	return -EOPNOTSUPP;
++=======
+ 	struct mlx5e_priv *priv = netdev_priv(indr_priv->rpriv->netdev);
+ 	int flags = MLX5E_TC_EGRESS | MLX5E_TC_ESW_OFFLOAD;
+ 	int err = 0;
+ 
+ 	switch (flower->command) {
+ 	case TC_CLSFLOWER_REPLACE:
+ 		err = mlx5e_configure_flower(netdev, priv, flower, flags);
+ 		break;
+ 	case TC_CLSFLOWER_DESTROY:
+ 		err = mlx5e_delete_flower(netdev, priv, flower, flags);
+ 		break;
+ 	case TC_CLSFLOWER_STATS:
+ 		err = mlx5e_stats_flower(netdev, priv, flower, flags);
+ 		break;
+ 	default:
+ 		err = -EOPNOTSUPP;
+ 	}
+ 
+ 	return err;
++>>>>>>> d9ee0491c2ff (net/mlx5e: Use dedicated uplink vport netdev representor)
  }
  
  static int mlx5e_rep_indr_setup_block_cb(enum tc_setup_type type,
@@@ -943,12 -1084,10 +991,13 @@@ static int mlx5e_rep_setup_tc_cb(enum t
  {
  	struct mlx5e_priv *priv = cb_priv;
  
 +	if (!tc_cls_can_offload_and_chain0(priv->netdev, type_data))
 +		return -EOPNOTSUPP;
 +
  	switch (type) {
  	case TC_SETUP_CLSFLOWER:
- 		return mlx5e_rep_setup_tc_cls_flower(priv, type_data, MLX5E_TC_INGRESS);
+ 		return mlx5e_rep_setup_tc_cls_flower(priv, type_data, MLX5E_TC_INGRESS |
+ 						     MLX5E_TC_ESW_OFFLOAD);
  	default:
  		return -EOPNOTSUPP;
  	}
@@@ -1085,22 -1246,33 +1156,41 @@@ static const struct net_device_ops mlx5
  	.ndo_start_xmit          = mlx5e_xmit,
  	.ndo_get_phys_port_name  = mlx5e_rep_get_phys_port_name,
  	.ndo_setup_tc            = mlx5e_rep_setup_tc,
- 	.ndo_get_stats64         = mlx5e_rep_get_stats,
+ 	.ndo_get_stats64         = mlx5e_get_stats,
  	.ndo_has_offload_stats	 = mlx5e_has_offload_stats,
  	.ndo_get_offload_stats	 = mlx5e_get_offload_stats,
- 	.ndo_change_mtu          = mlx5e_change_rep_mtu,
+ 	.ndo_change_mtu          = mlx5e_uplink_rep_change_mtu,
  };
  
 -static void mlx5e_build_rep_params(struct net_device *netdev)
 +static void mlx5e_build_rep_params(struct mlx5_core_dev *mdev,
 +				   struct mlx5e_params *params, u16 mtu)
  {
++<<<<<<< HEAD
++=======
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 	struct mlx5e_rep_priv *rpriv = priv->ppriv;
+ 	struct mlx5_eswitch_rep *rep = rpriv->rep;
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	struct mlx5e_params *params;
+ 
++>>>>>>> d9ee0491c2ff (net/mlx5e: Use dedicated uplink vport netdev representor)
  	u8 cq_period_mode = MLX5_CAP_GEN(mdev, cq_period_start_from_cqe) ?
  					 MLX5_CQ_PERIOD_MODE_START_FROM_CQE :
  					 MLX5_CQ_PERIOD_MODE_START_FROM_EQE;
  
 -	params = &priv->channels.params;
  	params->hard_mtu    = MLX5E_ETH_HARD_MTU;
++<<<<<<< HEAD
 +	params->sw_mtu      = mtu;
 +	params->log_sq_size = MLX5E_REP_PARAMS_LOG_SQ_SIZE;
++=======
+ 	params->sw_mtu      = netdev->mtu;
+ 
+ 	/* SQ */
+ 	if (rep->vport == FDB_UPLINK_VPORT)
+ 		params->log_sq_size = MLX5E_PARAMS_DEFAULT_LOG_SQ_SIZE;
+ 	else
+ 		params->log_sq_size = MLX5E_REP_PARAMS_LOG_SQ_SIZE;
++>>>>>>> d9ee0491c2ff (net/mlx5e: Use dedicated uplink vport netdev representor)
  
  	/* RQ */
  	mlx5e_build_rq_params(mdev, params);
@@@ -1160,9 -1353,10 +1268,16 @@@ static int mlx5e_init_rep(struct mlx5_c
  	if (err)
  		return err;
  
++<<<<<<< HEAD
 +	priv->channels.params.num_channels = MLX5E_REP_PARAMS_DEF_NUM_CHANNELS;
 +
 +	mlx5e_build_rep_params(mdev, &priv->channels.params, netdev->mtu);
++=======
+ 	priv->channels.params.num_channels =
+ 			mlx5e_rep_get_default_num_channels(rpriv->rep, netdev);
+ 
+ 	mlx5e_build_rep_params(netdev);
++>>>>>>> d9ee0491c2ff (net/mlx5e: Use dedicated uplink vport netdev representor)
  	mlx5e_build_rep_netdev(netdev);
  
  	mlx5e_timestamp_init(priv);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index c9ee89f4edb1,c1a9120412b8..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -69,11 -69,13 +69,21 @@@ struct mlx5_nic_flow_attr 
  enum {
  	MLX5E_TC_FLOW_INGRESS	= MLX5E_TC_INGRESS,
  	MLX5E_TC_FLOW_EGRESS	= MLX5E_TC_EGRESS,
++<<<<<<< HEAD
 +	MLX5E_TC_FLOW_ESWITCH	= BIT(MLX5E_TC_FLOW_BASE),
 +	MLX5E_TC_FLOW_NIC	= BIT(MLX5E_TC_FLOW_BASE + 1),
 +	MLX5E_TC_FLOW_OFFLOADED	= BIT(MLX5E_TC_FLOW_BASE + 2),
 +	MLX5E_TC_FLOW_HAIRPIN	= BIT(MLX5E_TC_FLOW_BASE + 3),
 +	MLX5E_TC_FLOW_HAIRPIN_RSS = BIT(MLX5E_TC_FLOW_BASE + 4),
++=======
+ 	MLX5E_TC_FLOW_ESWITCH	= MLX5E_TC_ESW_OFFLOAD,
+ 	MLX5E_TC_FLOW_NIC	= MLX5E_TC_NIC_OFFLOAD,
+ 	MLX5E_TC_FLOW_OFFLOADED	= BIT(MLX5E_TC_FLOW_BASE),
+ 	MLX5E_TC_FLOW_HAIRPIN	= BIT(MLX5E_TC_FLOW_BASE + 1),
+ 	MLX5E_TC_FLOW_HAIRPIN_RSS = BIT(MLX5E_TC_FLOW_BASE + 2),
+ 	MLX5E_TC_FLOW_SLOW	  = BIT(MLX5E_TC_FLOW_BASE + 3),
+ 	MLX5E_TC_FLOW_DUP         = BIT(MLX5E_TC_FLOW_BASE + 4),
++>>>>>>> d9ee0491c2ff (net/mlx5e: Use dedicated uplink vport netdev representor)
  };
  
  #define MLX5E_TC_MAX_SPLITS 1
@@@ -2803,47 -2748,264 +2818,150 @@@ int mlx5e_configure_flower(struct mlx5e
  	flow->flags = flow_flags;
  	flow->priv = priv;
  
 -	*__flow = flow;
 -	*__parse_attr = parse_attr;
 -
 -	return 0;
 -
 -err_free:
 -	kfree(flow);
 -	kvfree(parse_attr);
 -	return err;
 -}
 -
 -static int
 -__mlx5e_add_fdb_flow(struct mlx5e_priv *priv,
 -		     struct tc_cls_flower_offload *f,
 -		     u16 flow_flags,
 -		     struct net_device *filter_dev,
 -		     struct mlx5_eswitch_rep *in_rep,
 -		     struct mlx5_core_dev *in_mdev,
 -		     struct mlx5e_tc_flow **__flow)
 -{
 -	struct netlink_ext_ack *extack = f->common.extack;
 -	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
 -	struct mlx5e_tc_flow_parse_attr *parse_attr;
 -	struct mlx5e_tc_flow *flow;
 -	int attr_size, err;
 -
 -	flow_flags |= MLX5E_TC_FLOW_ESWITCH;
 -	attr_size  = sizeof(struct mlx5_esw_flow_attr);
 -	err = mlx5e_alloc_flow(priv, attr_size, f, flow_flags,
 -			       &parse_attr, &flow);
 -	if (err)
 -		goto out;
 -	parse_attr->filter_dev = filter_dev;
 -	flow->esw_attr->parse_attr = parse_attr;
 -	err = parse_cls_flower(flow->priv, flow, &parse_attr->spec,
 -			       f, filter_dev);
 -	if (err)
 -		goto err_free;
 -
 -	flow->esw_attr->chain = f->common.chain_index;
 -	flow->esw_attr->prio = TC_H_MAJ(f->common.prio) >> 16;
 -	err = parse_tc_fdb_actions(priv, f->exts, parse_attr, flow, extack);
 -	if (err)
 -		goto err_free;
 -
 -	flow->esw_attr->in_rep = in_rep;
 -	flow->esw_attr->in_mdev = in_mdev;
 -
 -	if (MLX5_CAP_ESW(esw->dev, counter_eswitch_affinity) ==
 -	    MLX5_COUNTER_SOURCE_ESWITCH)
 -		flow->esw_attr->counter_dev = in_mdev;
 -	else
 -		flow->esw_attr->counter_dev = priv->mdev;
 -
 -	err = mlx5e_tc_add_fdb_flow(priv, parse_attr, flow, extack);
 -	if (err)
 +	err = parse_cls_flower(priv, flow, &parse_attr->spec, f);
 +	if (err < 0)
  		goto err_free;
  
 -	*__flow = flow;
 -
 -	return 0;
 -
 -err_free:
 -	kfree(flow);
 -	kvfree(parse_attr);
 -out:
 -	return err;
 -}
 -
 -static int mlx5e_tc_add_fdb_peer_flow(struct tc_cls_flower_offload *f,
 -				      struct mlx5e_tc_flow *flow)
 -{
 -	struct mlx5e_priv *priv = flow->priv, *peer_priv;
 -	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch, *peer_esw;
 -	struct mlx5_devcom *devcom = priv->mdev->priv.devcom;
 -	struct mlx5e_tc_flow_parse_attr *parse_attr;
 -	struct mlx5e_rep_priv *peer_urpriv;
 -	struct mlx5e_tc_flow *peer_flow;
 -	struct mlx5_core_dev *in_mdev;
 -	int err = 0;
 -
 -	peer_esw = mlx5_devcom_get_peer_data(devcom, MLX5_DEVCOM_ESW_OFFLOADS);
 -	if (!peer_esw)
 -		return -ENODEV;
 -
 -	peer_urpriv = mlx5_eswitch_get_uplink_priv(peer_esw, REP_ETH);
 -	peer_priv = netdev_priv(peer_urpriv->netdev);
 -
 -	/* in_mdev is assigned of which the packet originated from.
 -	 * So packets redirected to uplink use the same mdev of the
 -	 * original flow and packets redirected from uplink use the
 -	 * peer mdev.
 -	 */
 -	if (flow->esw_attr->in_rep->vport == FDB_UPLINK_VPORT)
 -		in_mdev = peer_priv->mdev;
 -	else
 -		in_mdev = priv->mdev;
 -
 -	parse_attr = flow->esw_attr->parse_attr;
 -	err = __mlx5e_add_fdb_flow(peer_priv, f, flow->flags,
 -				   parse_attr->filter_dev,
 -				   flow->esw_attr->in_rep, in_mdev, &peer_flow);
 -	if (err)
 -		goto out;
 -
 -	flow->peer_flow = peer_flow;
 -	flow->flags |= MLX5E_TC_FLOW_DUP;
 -	mutex_lock(&esw->offloads.peer_mutex);
 -	list_add_tail(&flow->peer, &esw->offloads.peer_flows);
 -	mutex_unlock(&esw->offloads.peer_mutex);
 -
 -out:
 -	mlx5_devcom_release_peer_data(devcom, MLX5_DEVCOM_ESW_OFFLOADS);
 -	return err;
 -}
 -
 -static int
 -mlx5e_add_fdb_flow(struct mlx5e_priv *priv,
 -		   struct tc_cls_flower_offload *f,
 -		   u16 flow_flags,
 -		   struct net_device *filter_dev,
 -		   struct mlx5e_tc_flow **__flow)
 -{
 -	struct mlx5e_rep_priv *rpriv = priv->ppriv;
 -	struct mlx5_eswitch_rep *in_rep = rpriv->rep;
 -	struct mlx5_core_dev *in_mdev = priv->mdev;
 -	struct mlx5e_tc_flow *flow;
 -	int err;
 -
 -	err = __mlx5e_add_fdb_flow(priv, f, flow_flags, filter_dev, in_rep,
 -				   in_mdev, &flow);
 -	if (err)
 -		goto out;
 -
 -	if (is_peer_flow_needed(flow)) {
 -		err = mlx5e_tc_add_fdb_peer_flow(f, flow);
 -		if (err) {
 -			mlx5e_tc_del_fdb_flow(priv, flow);
 -			goto out;
 -		}
 +	if (flow->flags & MLX5E_TC_FLOW_ESWITCH) {
 +		err = parse_tc_fdb_actions(priv, f->exts, parse_attr, flow);
 +		if (err < 0)
 +			goto err_free;
 +		flow->rule[0] = mlx5e_tc_add_fdb_flow(priv, parse_attr, flow);
 +	} else {
 +		err = parse_tc_nic_actions(priv, f->exts, parse_attr, flow);
 +		if (err < 0)
 +			goto err_free;
 +		flow->rule[0] = mlx5e_tc_add_nic_flow(priv, parse_attr, flow);
  	}
  
++<<<<<<< HEAD
 +	if (IS_ERR(flow->rule[0])) {
 +		err = PTR_ERR(flow->rule[0]);
 +		if (err != -EAGAIN)
 +			goto err_free;
++=======
+ 	*__flow = flow;
+ 
+ 	return 0;
+ 
+ out:
+ 	return err;
+ }
+ 
+ static int
+ mlx5e_add_nic_flow(struct mlx5e_priv *priv,
+ 		   struct tc_cls_flower_offload *f,
+ 		   u16 flow_flags,
+ 		   struct net_device *filter_dev,
+ 		   struct mlx5e_tc_flow **__flow)
+ {
+ 	struct netlink_ext_ack *extack = f->common.extack;
+ 	struct mlx5e_tc_flow_parse_attr *parse_attr;
+ 	struct mlx5e_tc_flow *flow;
+ 	int attr_size, err;
+ 
+ 	/* multi-chain not supported for NIC rules */
+ 	if (!tc_cls_can_offload_and_chain0(priv->netdev, &f->common))
+ 		return -EOPNOTSUPP;
+ 
+ 	flow_flags |= MLX5E_TC_FLOW_NIC;
+ 	attr_size  = sizeof(struct mlx5_nic_flow_attr);
+ 	err = mlx5e_alloc_flow(priv, attr_size, f, flow_flags,
+ 			       &parse_attr, &flow);
+ 	if (err)
+ 		goto out;
+ 
+ 	parse_attr->filter_dev = filter_dev;
+ 	err = parse_cls_flower(flow->priv, flow, &parse_attr->spec,
+ 			       f, filter_dev);
+ 	if (err)
+ 		goto err_free;
+ 
+ 	err = parse_tc_nic_actions(priv, f->exts, parse_attr, flow, extack);
+ 	if (err)
+ 		goto err_free;
+ 
+ 	err = mlx5e_tc_add_nic_flow(priv, parse_attr, flow, extack);
+ 	if (err)
+ 		goto err_free;
+ 
+ 	flow->flags |= MLX5E_TC_FLOW_OFFLOADED;
+ 	kvfree(parse_attr);
+ 	*__flow = flow;
+ 
+ 	return 0;
+ 
+ err_free:
+ 	kfree(flow);
+ 	kvfree(parse_attr);
+ out:
+ 	return err;
+ }
+ 
+ static int
+ mlx5e_tc_add_flow(struct mlx5e_priv *priv,
+ 		  struct tc_cls_flower_offload *f,
+ 		  int flags,
+ 		  struct net_device *filter_dev,
+ 		  struct mlx5e_tc_flow **flow)
+ {
+ 	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
+ 	u16 flow_flags;
+ 	int err;
+ 
+ 	get_flags(flags, &flow_flags);
+ 
+ 	if (!tc_can_offload_extack(priv->netdev, f->common.extack))
+ 		return -EOPNOTSUPP;
+ 
+ 	if (esw && esw->mode == SRIOV_OFFLOADS)
+ 		err = mlx5e_add_fdb_flow(priv, f, flow_flags,
+ 					 filter_dev, flow);
+ 	else
+ 		err = mlx5e_add_nic_flow(priv, f, flow_flags,
+ 					 filter_dev, flow);
+ 
+ 	return err;
+ }
+ 
+ int mlx5e_configure_flower(struct net_device *dev, struct mlx5e_priv *priv,
+ 			   struct tc_cls_flower_offload *f, int flags)
+ {
+ 	struct netlink_ext_ack *extack = f->common.extack;
+ 	struct rhashtable *tc_ht = get_tc_ht(priv, flags);
+ 	struct mlx5e_tc_flow *flow;
+ 	int err = 0;
+ 
+ 	flow = rhashtable_lookup_fast(tc_ht, &f->cookie, tc_ht_params);
+ 	if (flow) {
+ 		NL_SET_ERR_MSG_MOD(extack,
+ 				   "flow cookie already exists, ignoring");
+ 		netdev_warn_once(priv->netdev,
+ 				 "flow cookie %lx already exists, ignoring\n",
+ 				 f->cookie);
+ 		goto out;
++>>>>>>> d9ee0491c2ff (net/mlx5e: Use dedicated uplink vport netdev representor)
  	}
  
 -	err = mlx5e_tc_add_flow(priv, f, flags, dev, &flow);
 -	if (err)
 -		goto out;
 +	if (err != -EAGAIN)
 +		flow->flags |= MLX5E_TC_FLOW_OFFLOADED;
 +
 +	if (!(flow->flags & MLX5E_TC_FLOW_ESWITCH) ||
 +	    !(flow->esw_attr->action &
 +	      MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT))
 +		kvfree(parse_attr);
  
  	err = rhashtable_insert_fast(tc_ht, &flow->node, tc_ht_params);
 -	if (err)
 -		goto err_free;
 +	if (err) {
 +		mlx5e_tc_del_flow(priv, flow);
 +		kfree(flow);
 +	}
  
 -	return 0;
 +	return err;
  
  err_free:
 -	mlx5e_tc_del_flow(priv, flow);
 +	kvfree(parse_attr);
  	kfree(flow);
 -out:
  	return err;
  }
  
@@@ -2858,10 -3020,10 +2976,10 @@@ static bool same_flow_direction(struct 
  	return false;
  }
  
 -int mlx5e_delete_flower(struct net_device *dev, struct mlx5e_priv *priv,
 +int mlx5e_delete_flower(struct mlx5e_priv *priv,
  			struct tc_cls_flower_offload *f, int flags)
  {
- 	struct rhashtable *tc_ht = get_tc_ht(priv);
+ 	struct rhashtable *tc_ht = get_tc_ht(priv, flags);
  	struct mlx5e_tc_flow *flow;
  
  	flow = rhashtable_lookup_fast(tc_ht, &f->cookie, tc_ht_params);
@@@ -2877,10 -3039,12 +2995,16 @@@
  	return 0;
  }
  
 -int mlx5e_stats_flower(struct net_device *dev, struct mlx5e_priv *priv,
 +int mlx5e_stats_flower(struct mlx5e_priv *priv,
  		       struct tc_cls_flower_offload *f, int flags)
  {
++<<<<<<< HEAD
 +	struct rhashtable *tc_ht = get_tc_ht(priv);
++=======
+ 	struct mlx5_devcom *devcom = priv->mdev->priv.devcom;
+ 	struct rhashtable *tc_ht = get_tc_ht(priv, flags);
+ 	struct mlx5_eswitch *peer_esw;
++>>>>>>> d9ee0491c2ff (net/mlx5e: Use dedicated uplink vport netdev representor)
  	struct mlx5e_tc_flow *flow;
  	struct mlx5_fc *counter;
  	u64 bytes;
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en.h b/drivers/net/ethernet/mellanox/mlx5/core/en.h
index d2c773481d2f..40437eca0ccc 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@ -763,6 +763,7 @@ mlx5e_skb_from_cqe_nonlinear(struct mlx5e_rq *rq, struct mlx5_cqe64 *cqe,
 			     struct mlx5e_wqe_frag_info *wi, u32 cqe_bcnt);
 
 void mlx5e_update_stats(struct mlx5e_priv *priv);
+void mlx5e_get_stats(struct net_device *dev, struct rtnl_link_stats64 *stats);
 
 void mlx5e_init_l2_addr(struct mlx5e_priv *priv);
 int mlx5e_self_test_num(struct mlx5e_priv *priv);
@@ -927,7 +928,6 @@ int mlx5e_create_tis(struct mlx5_core_dev *mdev, int tc,
 void mlx5e_destroy_tis(struct mlx5_core_dev *mdev, u32 tisn);
 
 int mlx5e_create_tises(struct mlx5e_priv *priv);
-void mlx5e_cleanup_nic_tx(struct mlx5e_priv *priv);
 int mlx5e_close(struct net_device *netdev);
 int mlx5e_open(struct net_device *netdev);
 
@@ -935,6 +935,7 @@ void mlx5e_queue_update_stats(struct mlx5e_priv *priv);
 int mlx5e_bits_invert(unsigned long a, int size);
 
 typedef int (*change_hw_mtu_cb)(struct mlx5e_priv *priv);
+int mlx5e_set_dev_port_mtu(struct mlx5e_priv *priv);
 int mlx5e_change_mtu(struct net_device *netdev, int new_mtu,
 		     change_hw_mtu_cb set_mtu_cb);
 
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index b4f6c14ea722..58e3246ebb8d 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@ -2794,7 +2794,7 @@ static void mlx5e_query_mtu(struct mlx5_core_dev *mdev,
 	*mtu = MLX5E_HW2SW_MTU(params, hw_mtu);
 }
 
-static int mlx5e_set_dev_port_mtu(struct mlx5e_priv *priv)
+int mlx5e_set_dev_port_mtu(struct mlx5e_priv *priv)
 {
 	struct mlx5e_params *params = &priv->channels.params;
 	struct net_device *netdev = priv->netdev;
@@ -2874,7 +2874,7 @@ void mlx5e_activate_priv_channels(struct mlx5e_priv *priv)
 	mlx5e_activate_channels(&priv->channels);
 	netif_tx_start_all_queues(priv->netdev);
 
-	if (MLX5_ESWITCH_MANAGER(priv->mdev))
+	if (mlx5e_is_vport_rep(priv))
 		mlx5e_add_sqs_fwd_rules(priv);
 
 	mlx5e_wait_channels_min_rx_wqes(&priv->channels);
@@ -2885,7 +2885,7 @@ void mlx5e_deactivate_priv_channels(struct mlx5e_priv *priv)
 {
 	mlx5e_redirect_rqts_to_drop(priv);
 
-	if (MLX5_ESWITCH_MANAGER(priv->mdev))
+	if (mlx5e_is_vport_rep(priv))
 		mlx5e_remove_sqs_fwd_rules(priv);
 
 	/* FIXME: This is a W/A only for tx timeout watch dog false alarm when
@@ -3137,7 +3137,7 @@ int mlx5e_create_tises(struct mlx5e_priv *priv)
 	return err;
 }
 
-void mlx5e_cleanup_nic_tx(struct mlx5e_priv *priv)
+static void mlx5e_cleanup_nic_tx(struct mlx5e_priv *priv)
 {
 	int tc;
 
@@ -3382,7 +3382,8 @@ static int mlx5e_setup_tc_block_cb(enum tc_setup_type type, void *type_data,
 
 	switch (type) {
 	case TC_SETUP_CLSFLOWER:
-		return mlx5e_setup_tc_cls_flower(priv, type_data, MLX5E_TC_INGRESS);
+		return mlx5e_setup_tc_cls_flower(priv, type_data, MLX5E_TC_INGRESS |
+						 MLX5E_TC_NIC_OFFLOAD);
 	default:
 		return -EOPNOTSUPP;
 	}
@@ -3425,7 +3426,7 @@ static int mlx5e_setup_tc(struct net_device *dev, enum tc_setup_type type,
 	}
 }
 
-static void
+void
 mlx5e_get_stats(struct net_device *dev, struct rtnl_link_stats64 *stats)
 {
 	struct mlx5e_priv *priv = netdev_priv(dev);
@@ -3567,7 +3568,7 @@ static int set_feature_tc_num_filters(struct net_device *netdev, bool enable)
 {
 	struct mlx5e_priv *priv = netdev_priv(netdev);
 
-	if (!enable && mlx5e_tc_num_filters(priv)) {
+	if (!enable && mlx5e_tc_num_filters(priv, MLX5E_TC_NIC_OFFLOAD)) {
 		netdev_err(netdev,
 			   "Active offloaded tc filters, can't turn hw_tc_offload off\n");
 		return -EINVAL;
@@ -4569,12 +4570,6 @@ static void mlx5e_set_netdev_dev_addr(struct net_device *netdev)
 	}
 }
 
-#if IS_ENABLED(CONFIG_MLX5_ESWITCH)
-static const struct switchdev_ops mlx5e_switchdev_ops = {
-	.switchdev_port_attr_get	= mlx5e_attr_get,
-};
-#endif
-
 static void mlx5e_build_nic_netdev(struct net_device *netdev)
 {
 	struct mlx5e_priv *priv = netdev_priv(netdev);
@@ -4684,12 +4679,6 @@ static void mlx5e_build_nic_netdev(struct net_device *netdev)
 	netdev->priv_flags       |= IFF_UNICAST_FLT;
 
 	mlx5e_set_netdev_dev_addr(netdev);
-
-#if IS_ENABLED(CONFIG_MLX5_ESWITCH)
-	if (MLX5_ESWITCH_MANAGER(mdev))
-		netdev->switchdev_ops = &mlx5e_switchdev_ops;
-#endif
-
 	mlx5e_ipsec_build_netdev(priv);
 	mlx5e_tls_build_netdev(priv);
 }
@@ -4866,7 +4855,7 @@ static void mlx5e_nic_enable(struct mlx5e_priv *priv)
 	mlx5e_enable_async_events(priv);
 
 	if (MLX5_ESWITCH_MANAGER(priv->mdev))
-		mlx5e_register_vport_reps(priv);
+		mlx5e_rep_register_vport_reps(priv);
 
 	if (netdev->reg_state != NETREG_REGISTERED)
 		return;
@@ -4901,7 +4890,7 @@ static void mlx5e_nic_disable(struct mlx5e_priv *priv)
 	queue_work(priv->wq, &priv->set_rx_mode_work);
 
 	if (MLX5_ESWITCH_MANAGER(priv->mdev))
-		mlx5e_unregister_vport_reps(priv);
+		mlx5e_rep_unregister_vport_reps(priv);
 
 	mlx5e_disable_async_events(priv);
 	mlx5_lag_remove(mdev);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index c078c6703dc7..07603eafc237 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -160,8 +160,8 @@ struct mlx5e_rep_sq {
 };
 
 void *mlx5e_alloc_nic_rep_priv(struct mlx5_core_dev *mdev);
-void mlx5e_register_vport_reps(struct mlx5e_priv *priv);
-void mlx5e_unregister_vport_reps(struct mlx5e_priv *priv);
+void mlx5e_rep_register_vport_reps(struct mlx5e_priv *priv);
+void mlx5e_rep_unregister_vport_reps(struct mlx5e_priv *priv);
 bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv);
 int mlx5e_add_sqs_fwd_rules(struct mlx5e_priv *priv);
 void mlx5e_remove_sqs_fwd_rules(struct mlx5e_priv *priv);
@@ -169,7 +169,6 @@ void mlx5e_remove_sqs_fwd_rules(struct mlx5e_priv *priv);
 int mlx5e_get_offload_stats(int attr_id, const struct net_device *dev, void *sp);
 bool mlx5e_has_offload_stats(const struct net_device *dev, int attr_id);
 
-int mlx5e_attr_get(struct net_device *dev, struct switchdev_attr *attr);
 void mlx5e_handle_rx_cqe_rep(struct mlx5e_rq *rq, struct mlx5_cqe64 *cqe);
 
 int mlx5e_rep_encap_entry_attach(struct mlx5e_priv *priv,
@@ -179,11 +178,15 @@ void mlx5e_rep_encap_entry_detach(struct mlx5e_priv *priv,
 
 void mlx5e_rep_queue_neigh_stats_work(struct mlx5e_priv *priv);
 #else /* CONFIG_MLX5_ESWITCH */
-static inline void mlx5e_register_vport_reps(struct mlx5e_priv *priv) {}
-static inline void mlx5e_unregister_vport_reps(struct mlx5e_priv *priv) {}
+static inline void mlx5e_rep_register_vport_reps(struct mlx5e_priv *priv) {}
+static inline void mlx5e_rep_unregister_vport_reps(struct mlx5e_priv *priv) {}
 static inline bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv) { return false; }
 static inline int mlx5e_add_sqs_fwd_rules(struct mlx5e_priv *priv) { return 0; }
 static inline void mlx5e_remove_sqs_fwd_rules(struct mlx5e_priv *priv) {}
 #endif
 
+static inline bool mlx5e_is_vport_rep(struct mlx5e_priv *priv)
+{
+	return (MLX5_ESWITCH_MANAGER(priv->mdev) && priv->ppriv);
+}
 #endif /* __MLX5E_REP_H__ */
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_stats.c b/drivers/net/ethernet/mellanox/mlx5/core/en_stats.c
index 44aa09167d37..c5da6d3961de 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_stats.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_stats.c
@@ -473,7 +473,7 @@ static int mlx5e_grp_802_3_fill_stats(struct mlx5e_priv *priv, u64 *data,
 #define MLX5_BASIC_PPCNT_SUPPORTED(mdev) \
 	(MLX5_CAP_GEN(mdev, pcam_reg) ? MLX5_CAP_PCAM_REG(mdev, ppcnt) : 1)
 
-static void mlx5e_grp_802_3_update_stats(struct mlx5e_priv *priv)
+void mlx5e_grp_802_3_update_stats(struct mlx5e_priv *priv)
 {
 	struct mlx5e_pport_stats *pstats = &priv->stats.pport;
 	struct mlx5_core_dev *mdev = priv->mdev;
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_stats.h b/drivers/net/ethernet/mellanox/mlx5/core/en_stats.h
index e51f4a4578b2..6096732f6b3d 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_stats.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_stats.h
@@ -273,5 +273,6 @@ extern const struct mlx5e_stats_grp mlx5e_stats_grps[];
 extern const int mlx5e_num_stats_grps;
 
 void mlx5e_grp_sw_update_stats(struct mlx5e_priv *priv);
+void mlx5e_grp_802_3_update_stats(struct mlx5e_priv *priv);
 
 #endif /* __MLX5_EN_STATS_H__ */
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 378507988a32..3d5d5cbd0d82 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -42,7 +42,9 @@
 enum {
 	MLX5E_TC_INGRESS = BIT(0),
 	MLX5E_TC_EGRESS  = BIT(1),
-	MLX5E_TC_LAST_EXPORTED_BIT = 1,
+	MLX5E_TC_NIC_OFFLOAD = BIT(2),
+	MLX5E_TC_ESW_OFFLOAD = BIT(3),
+	MLX5E_TC_LAST_EXPORTED_BIT = 3,
 };
 
 int mlx5e_tc_nic_init(struct mlx5e_priv *priv);
@@ -68,7 +70,7 @@ void mlx5e_tc_encap_flows_del(struct mlx5e_priv *priv,
 struct mlx5e_neigh_hash_entry;
 void mlx5e_tc_update_neigh_used_value(struct mlx5e_neigh_hash_entry *nhe);
 
-int mlx5e_tc_num_filters(struct mlx5e_priv *priv);
+int mlx5e_tc_num_filters(struct mlx5e_priv *priv, int flags);
 
 bool mlx5e_tc_tun_device_to_offload(struct mlx5e_priv *priv,
 				    struct net_device *netdev);
@@ -76,7 +78,7 @@ bool mlx5e_tc_tun_device_to_offload(struct mlx5e_priv *priv,
 #else /* CONFIG_MLX5_ESWITCH */
 static inline int  mlx5e_tc_nic_init(struct mlx5e_priv *priv) { return 0; }
 static inline void mlx5e_tc_nic_cleanup(struct mlx5e_priv *priv) {}
-static inline int  mlx5e_tc_num_filters(struct mlx5e_priv *priv) { return 0; }
+static inline int  mlx5e_tc_num_filters(struct mlx5e_priv *priv, int flags) { return 0; }
 #endif
 
 #endif /* __MLX5_EN_TC_H__ */
