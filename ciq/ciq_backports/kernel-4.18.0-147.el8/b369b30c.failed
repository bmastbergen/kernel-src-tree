nvmet: use Retain Async Event bit to clear AEN

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Chaitanya Kulkarni <chaitanya.kulkarni@wdc.com>
commit b369b30cf510fe94d8884837039362e2ec223cec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/b369b30c.failed

In the current implementation, we clear the AEN bit when we get the
"get log page" command if given log page is associated with AEN.
This patch allows optionally retaining the AEN for the ctrl
under consideration when Retain Asynchronous Event (RAE) bit is set
as a part of "get log page" command.

This allows the host to read the Log page and optionally retaining the
AEN associated with this log page when using userspace tools like
nvme-cli.

	Signed-off-by: Chaitanya Kulkarni <chaitanya.kulkarni@wdc.com>
[hch: also use the new helper in the just merged ANA code]
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit b369b30cf510fe94d8884837039362e2ec223cec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/target/admin-cmd.c
diff --cc drivers/nvme/target/admin-cmd.c
index 16a9b24270f9,f517bc562d26..000000000000
--- a/drivers/nvme/target/admin-cmd.c
+++ b/drivers/nvme/target/admin-cmd.c
@@@ -182,6 -195,70 +195,73 @@@ out
  	nvmet_req_complete(req, status);
  }
  
++<<<<<<< HEAD
++=======
+ static u32 nvmet_format_ana_group(struct nvmet_req *req, u32 grpid,
+ 		struct nvme_ana_group_desc *desc)
+ {
+ 	struct nvmet_ctrl *ctrl = req->sq->ctrl;
+ 	struct nvmet_ns *ns;
+ 	u32 count = 0;
+ 
+ 	if (!(req->cmd->get_log_page.lsp & NVME_ANA_LOG_RGO)) {
+ 		rcu_read_lock();
+ 		list_for_each_entry_rcu(ns, &ctrl->subsys->namespaces, dev_link)
+ 			if (ns->anagrpid == grpid)
+ 				desc->nsids[count++] = cpu_to_le32(ns->nsid);
+ 		rcu_read_unlock();
+ 	}
+ 
+ 	desc->grpid = cpu_to_le32(grpid);
+ 	desc->nnsids = cpu_to_le32(count);
+ 	desc->chgcnt = cpu_to_le64(nvmet_ana_chgcnt);
+ 	desc->state = req->port->ana_state[grpid];
+ 	memset(desc->rsvd17, 0, sizeof(desc->rsvd17));
+ 	return sizeof(struct nvme_ana_group_desc) + count * sizeof(__le32);
+ }
+ 
+ static void nvmet_execute_get_log_page_ana(struct nvmet_req *req)
+ {
+ 	struct nvme_ana_rsp_hdr hdr = { 0, };
+ 	struct nvme_ana_group_desc *desc;
+ 	size_t offset = sizeof(struct nvme_ana_rsp_hdr); /* start beyond hdr */
+ 	size_t len;
+ 	u32 grpid;
+ 	u16 ngrps = 0;
+ 	u16 status;
+ 
+ 	status = NVME_SC_INTERNAL;
+ 	desc = kmalloc(sizeof(struct nvme_ana_group_desc) +
+ 			NVMET_MAX_NAMESPACES * sizeof(__le32), GFP_KERNEL);
+ 	if (!desc)
+ 		goto out;
+ 
+ 	down_read(&nvmet_ana_sem);
+ 	for (grpid = 1; grpid <= NVMET_MAX_ANAGRPS; grpid++) {
+ 		if (!nvmet_ana_group_enabled[grpid])
+ 			continue;
+ 		len = nvmet_format_ana_group(req, grpid, desc);
+ 		status = nvmet_copy_to_sgl(req, offset, desc, len);
+ 		if (status)
+ 			break;
+ 		offset += len;
+ 		ngrps++;
+ 	}
+ 
+ 	hdr.chgcnt = cpu_to_le64(nvmet_ana_chgcnt);
+ 	hdr.ngrps = cpu_to_le16(ngrps);
+ 	nvmet_clear_aen(req, NVME_AEN_CFG_ANA_CHANGE);
+ 	up_read(&nvmet_ana_sem);
+ 
+ 	kfree(desc);
+ 
+ 	/* copy the header last once we know the number of groups */
+ 	status = nvmet_copy_to_sgl(req, 0, &hdr, sizeof(hdr));
+ out:
+ 	nvmet_req_complete(req, status);
+ }
+ 
++>>>>>>> b369b30cf510 (nvmet: use Retain Async Event bit to clear AEN)
  static void nvmet_execute_identify_ctrl(struct nvmet_req *req)
  {
  	struct nvmet_ctrl *ctrl = req->sq->ctrl;
* Unmerged path drivers/nvme/target/admin-cmd.c
