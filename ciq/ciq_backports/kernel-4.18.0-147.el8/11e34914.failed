x86/kvm/nVMX: fix VMCLEAR when Enlightened VMCS is in use

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [x86] kvm/nvmx: fix VMCLEAR when Enlightened VMCS is in use (Vitaly Kuznetsov) [1717785]
Rebuild_FUZZ: 96.36%
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 11e349143e3289ab99f1b4858649f60703b7bf35
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/11e34914.failed

When Enlightened VMCS is in use, it is valid to do VMCLEAR and,
according to TLFS, this should "transition an enlightened VMCS from the
active to the non-active state". It is, however, wrong to assume that
it is only valid to do VMCLEAR for the eVMCS which is currently active
on the vCPU performing VMCLEAR.

Currently, the logic in handle_vmclear() is broken: in case, there is no
active eVMCS on the vCPU doing VMCLEAR we treat the argument as a 'normal'
VMCS and kvm_vcpu_write_guest() to the 'launch_state' field irreversibly
corrupts the memory area.

So, in case the VMCLEAR argument is not the current active eVMCS on the
vCPU, how can we know if the area it is pointing to is a normal or an
enlightened VMCS?
Thanks to the bug in Hyper-V (see commit 72aeb60c52bf7 ("KVM: nVMX: Verify
eVMCS revision id match supported eVMCS version on eVMCS VMPTRLD")) we can
not, the revision can't be used to distinguish between them. So let's
assume it is always enlightened in case enlightened vmentry is enabled in
the assist page. Also, check if vmx->nested.enlightened_vmcs_enabled to
minimize the impact for 'unenlightened' workloads.

Fixes: b8bbab928fb1 ("KVM: nVMX: implement enlightened VMPTRLD and VMCLEAR")
	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 11e349143e3289ab99f1b4858649f60703b7bf35)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/evmcs.h
#	arch/x86/kvm/vmx/nested.c
#	arch/x86/kvm/vmx/vmx_evmcs.h
diff --cc arch/x86/kvm/vmx/vmx_evmcs.h
index 210a884090ad,72359709cdc1..000000000000
--- a/arch/x86/kvm/vmx/vmx_evmcs.h
+++ b/arch/x86/kvm/vmx/vmx_evmcs.h
@@@ -1,8 -1,16 +1,22 @@@
 -// SPDX-License-Identifier: GPL-2.0
 +/* SPDX-License-Identifier: GPL-2.0 */
 +#ifndef __KVM_X86_VMX_EVMCS_H
 +#define __KVM_X86_VMX_EVMCS_H
  
++<<<<<<< HEAD:arch/x86/kvm/vmx/vmx_evmcs.h
 +#include <asm/hyperv-tlfs.h>
++=======
+ #include <linux/errno.h>
+ #include <linux/smp.h>
+ 
+ #include "../hyperv.h"
+ #include "evmcs.h"
+ #include "vmcs.h"
+ #include "vmx.h"
+ 
+ DEFINE_STATIC_KEY_FALSE(enable_evmcs);
+ 
+ #if IS_ENABLED(CONFIG_HYPERV)
++>>>>>>> 11e349143e32 (x86/kvm/nVMX: fix VMCLEAR when Enlightened VMCS is in use):arch/x86/kvm/vmx/evmcs.c
  
  #define ROL16(val, n) ((u16)(((u16)(val) << (n)) | ((u16)(val) >> (16 - (n)))))
  #define EVMCS1_OFFSET(x) offsetof(struct hv_enlightened_vmcs, x)
@@@ -298,27 -301,71 +312,58 @@@ static const struct evmcs_field vmcs_fi
  	EVMCS1_FIELD(VIRTUAL_PROCESSOR_ID, virtual_processor_id,
  		     HV_VMX_ENLIGHTENED_CLEAN_FIELD_CONTROL_XLAT),
  };
 -const unsigned int nr_evmcs_1_fields = ARRAY_SIZE(vmcs_field_to_evmcs_1);
  
 -void evmcs_sanitize_exec_ctrls(struct vmcs_config *vmcs_conf)
 +static __always_inline int get_evmcs_offset(unsigned long field,
 +					    u16 *clean_field)
  {
 -	vmcs_conf->pin_based_exec_ctrl &= ~EVMCS1_UNSUPPORTED_PINCTRL;
 -	vmcs_conf->cpu_based_2nd_exec_ctrl &= ~EVMCS1_UNSUPPORTED_2NDEXEC;
 +	unsigned int index = ROL16(field, 6);
 +	const struct evmcs_field *evmcs_field;
  
 -	vmcs_conf->vmexit_ctrl &= ~EVMCS1_UNSUPPORTED_VMEXIT_CTRL;
 -	vmcs_conf->vmentry_ctrl &= ~EVMCS1_UNSUPPORTED_VMENTRY_CTRL;
 +	if (unlikely(index >= ARRAY_SIZE(vmcs_field_to_evmcs_1))) {
 +		WARN_ONCE(1, "KVM: accessing unsupported EVMCS field %lx\n",
 +			  field);
 +		return -ENOENT;
 +	}
  
 -}
 -#endif
 +	evmcs_field = &vmcs_field_to_evmcs_1[index];
  
++<<<<<<< HEAD:arch/x86/kvm/vmx/vmx_evmcs.h
 +	if (clean_field)
 +		*clean_field = evmcs_field->clean_field;
++=======
+ bool nested_enlightened_vmentry(struct kvm_vcpu *vcpu, u64 *evmcs_gpa)
+ {
+ 	struct hv_vp_assist_page assist_page;
+ 
+ 	*evmcs_gpa = -1ull;
+ 
+ 	if (unlikely(!kvm_hv_get_assist_page(vcpu, &assist_page)))
+ 		return false;
+ 
+ 	if (unlikely(!assist_page.enlighten_vmentry))
+ 		return false;
+ 
+ 	*evmcs_gpa = assist_page.current_nested_vmcs;
+ 
+ 	return true;
+ }
+ 
+ uint16_t nested_get_evmcs_version(struct kvm_vcpu *vcpu)
+ {
+        struct vcpu_vmx *vmx = to_vmx(vcpu);
+        /*
+         * vmcs_version represents the range of supported Enlightened VMCS
+         * versions: lower 8 bits is the minimal version, higher 8 bits is the
+         * maximum supported version. KVM supports versions from 1 to
+         * KVM_EVMCS_VERSION.
+         */
+        if (vmx->nested.enlightened_vmcs_enabled)
+                return (KVM_EVMCS_VERSION << 8) | 1;
++>>>>>>> 11e349143e32 (x86/kvm/nVMX: fix VMCLEAR when Enlightened VMCS is in use):arch/x86/kvm/vmx/evmcs.c
  
 -       return 0;
 +	return evmcs_field->offset;
  }
  
 -int nested_enable_evmcs(struct kvm_vcpu *vcpu,
 -			uint16_t *vmcs_version)
 -{
 -	struct vcpu_vmx *vmx = to_vmx(vcpu);
 -	bool evmcs_already_enabled = vmx->nested.enlightened_vmcs_enabled;
 -
 -	vmx->nested.enlightened_vmcs_enabled = true;
 +#undef ROL16
  
 -	if (vmcs_version)
 -		*vmcs_version = nested_get_evmcs_version(vcpu);
 -
 -	/* We don't support disabling the feature for simplicity. */
 -	if (evmcs_already_enabled)
 -		return 0;
 -
 -	vmx->nested.msrs.pinbased_ctls_high &= ~EVMCS1_UNSUPPORTED_PINCTRL;
 -	vmx->nested.msrs.entry_ctls_high &= ~EVMCS1_UNSUPPORTED_VMENTRY_CTRL;
 -	vmx->nested.msrs.exit_ctls_high &= ~EVMCS1_UNSUPPORTED_VMEXIT_CTRL;
 -	vmx->nested.msrs.secondary_ctls_high &= ~EVMCS1_UNSUPPORTED_2NDEXEC;
 -	vmx->nested.msrs.vmfunc_controls &= ~EVMCS1_UNSUPPORTED_VMFUNC;
 -
 -	return 0;
 -}
 +#endif /* __KVM_X86_VMX_EVMCS_H */
* Unmerged path arch/x86/kvm/vmx/evmcs.h
* Unmerged path arch/x86/kvm/vmx/nested.c
* Unmerged path arch/x86/kvm/vmx/evmcs.h
* Unmerged path arch/x86/kvm/vmx/nested.c
* Unmerged path arch/x86/kvm/vmx/vmx_evmcs.h
