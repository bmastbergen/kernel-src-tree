mm: introduce new vm_map_pages() and vm_map_pages_zero() API

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Souptick Joarder <jrdr.linux@gmail.com>
commit a667d7456f189e3422725dddcd067537feac49c0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/a667d745.failed

Patch series "mm: Use vm_map_pages() and vm_map_pages_zero() API", v5.

This patch (of 5):

Previouly drivers have their own way of mapping range of kernel
pages/memory into user vma and this was done by invoking vm_insert_page()
within a loop.

As this pattern is common across different drivers, it can be generalized
by creating new functions and using them across the drivers.

vm_map_pages() is the API which can be used to map kernel memory/pages in
drivers which have considered vm_pgoff

vm_map_pages_zero() is the API which can be used to map a range of kernel
memory/pages in drivers which have not considered vm_pgoff.  vm_pgoff is
passed as default 0 for those drivers.

We _could_ then at a later "fix" these drivers which are using
vm_map_pages_zero() to behave according to the normal vm_pgoff offsetting
simply by removing the _zero suffix on the function name and if that
causes regressions, it gives us an easy way to revert.

Tested on Rockchip hardware and display is working, including talking to
Lima via prime.

Link: http://lkml.kernel.org/r/751cb8a0f4c3e67e95c58a3b072937617f338eea.1552921225.git.jrdr.linux@gmail.com
	Signed-off-by: Souptick Joarder <jrdr.linux@gmail.com>
	Suggested-by: Russell King <linux@armlinux.org.uk>
	Suggested-by: Matthew Wilcox <willy@infradead.org>
	Reviewed-by: Mike Rapoport <rppt@linux.ibm.com>
	Tested-by: Heiko Stuebner <heiko@sntech.de>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Cc: Rik van Riel <riel@surriel.com>
	Cc: Stephen Rothwell <sfr@canb.auug.org.au>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Robin Murphy <robin.murphy@arm.com>
	Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
	Cc: Thierry Reding <treding@nvidia.com>
	Cc: Kees Cook <keescook@chromium.org>
	Cc: Marek Szyprowski <m.szyprowski@samsung.com>
	Cc: Stefan Richter <stefanr@s5r6.in-berlin.de>
	Cc: Sandy Huang <hjc@rock-chips.com>
	Cc: David Airlie <airlied@linux.ie>
	Cc: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
	Cc: Joerg Roedel <joro@8bytes.org>
	Cc: Pawel Osciak <pawel@osciak.com>
	Cc: Kyungmin Park <kyungmin.park@samsung.com>
	Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
	Cc: Juergen Gross <jgross@suse.com>
	Cc: Mauro Carvalho Chehab <mchehab@infradead.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit a667d7456f189e3422725dddcd067537feac49c0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mm.h
#	mm/memory.c
diff --cc include/linux/mm.h
index 26b4440159c9,912614fbbef3..000000000000
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@@ -2540,11 -2579,15 +2540,19 @@@ struct vm_area_struct *find_extend_vma(
  int remap_pfn_range(struct vm_area_struct *, unsigned long addr,
  			unsigned long pfn, unsigned long size, pgprot_t);
  int vm_insert_page(struct vm_area_struct *, unsigned long addr, struct page *);
++<<<<<<< HEAD
 +int vm_insert_pfn(struct vm_area_struct *vma, unsigned long addr,
++=======
+ int vm_map_pages(struct vm_area_struct *vma, struct page **pages,
+ 				unsigned long num);
+ int vm_map_pages_zero(struct vm_area_struct *vma, struct page **pages,
+ 				unsigned long num);
+ vm_fault_t vmf_insert_pfn(struct vm_area_struct *vma, unsigned long addr,
++>>>>>>> a667d7456f18 (mm: introduce new vm_map_pages() and vm_map_pages_zero() API)
  			unsigned long pfn);
 -vm_fault_t vmf_insert_pfn_prot(struct vm_area_struct *vma, unsigned long addr,
 +int vm_insert_pfn_prot(struct vm_area_struct *vma, unsigned long addr,
  			unsigned long pfn, pgprot_t pgprot);
 -vm_fault_t vmf_insert_mixed(struct vm_area_struct *vma, unsigned long addr,
 +int vm_insert_mixed(struct vm_area_struct *vma, unsigned long addr,
  			pfn_t pfn);
  vm_fault_t vmf_insert_mixed_mkwrite(struct vm_area_struct *vma,
  		unsigned long addr, pfn_t pfn);
diff --cc mm/memory.c
index 4358ebf4e80c,96f1d473c89a..000000000000
--- a/mm/memory.c
+++ b/mm/memory.c
@@@ -1779,7 -1527,88 +1779,92 @@@ int vm_insert_page(struct vm_area_struc
  }
  EXPORT_SYMBOL(vm_insert_page);
  
++<<<<<<< HEAD
 +static int insert_pfn(struct vm_area_struct *vma, unsigned long addr,
++=======
+ /*
+  * __vm_map_pages - maps range of kernel pages into user vma
+  * @vma: user vma to map to
+  * @pages: pointer to array of source kernel pages
+  * @num: number of pages in page array
+  * @offset: user's requested vm_pgoff
+  *
+  * This allows drivers to map range of kernel pages into a user vma.
+  *
+  * Return: 0 on success and error code otherwise.
+  */
+ static int __vm_map_pages(struct vm_area_struct *vma, struct page **pages,
+ 				unsigned long num, unsigned long offset)
+ {
+ 	unsigned long count = vma_pages(vma);
+ 	unsigned long uaddr = vma->vm_start;
+ 	int ret, i;
+ 
+ 	/* Fail if the user requested offset is beyond the end of the object */
+ 	if (offset > num)
+ 		return -ENXIO;
+ 
+ 	/* Fail if the user requested size exceeds available object size */
+ 	if (count > num - offset)
+ 		return -ENXIO;
+ 
+ 	for (i = 0; i < count; i++) {
+ 		ret = vm_insert_page(vma, uaddr, pages[offset + i]);
+ 		if (ret < 0)
+ 			return ret;
+ 		uaddr += PAGE_SIZE;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * vm_map_pages - maps range of kernel pages starts with non zero offset
+  * @vma: user vma to map to
+  * @pages: pointer to array of source kernel pages
+  * @num: number of pages in page array
+  *
+  * Maps an object consisting of @num pages, catering for the user's
+  * requested vm_pgoff
+  *
+  * If we fail to insert any page into the vma, the function will return
+  * immediately leaving any previously inserted pages present.  Callers
+  * from the mmap handler may immediately return the error as their caller
+  * will destroy the vma, removing any successfully inserted pages. Other
+  * callers should make their own arrangements for calling unmap_region().
+  *
+  * Context: Process context. Called by mmap handlers.
+  * Return: 0 on success and error code otherwise.
+  */
+ int vm_map_pages(struct vm_area_struct *vma, struct page **pages,
+ 				unsigned long num)
+ {
+ 	return __vm_map_pages(vma, pages, num, vma->vm_pgoff);
+ }
+ EXPORT_SYMBOL(vm_map_pages);
+ 
+ /**
+  * vm_map_pages_zero - map range of kernel pages starts with zero offset
+  * @vma: user vma to map to
+  * @pages: pointer to array of source kernel pages
+  * @num: number of pages in page array
+  *
+  * Similar to vm_map_pages(), except that it explicitly sets the offset
+  * to 0. This function is intended for the drivers that did not consider
+  * vm_pgoff.
+  *
+  * Context: Process context. Called by mmap handlers.
+  * Return: 0 on success and error code otherwise.
+  */
+ int vm_map_pages_zero(struct vm_area_struct *vma, struct page **pages,
+ 				unsigned long num)
+ {
+ 	return __vm_map_pages(vma, pages, num, 0);
+ }
+ EXPORT_SYMBOL(vm_map_pages_zero);
+ 
+ static vm_fault_t insert_pfn(struct vm_area_struct *vma, unsigned long addr,
++>>>>>>> a667d7456f18 (mm: introduce new vm_map_pages() and vm_map_pages_zero() API)
  			pfn_t pfn, pgprot_t prot, bool mkwrite)
  {
  	struct mm_struct *mm = vma->vm_mm;
* Unmerged path include/linux/mm.h
* Unmerged path mm/memory.c
diff --git a/mm/nommu.c b/mm/nommu.c
index 2714d30a7b22..39635d5b9019 100644
--- a/mm/nommu.c
+++ b/mm/nommu.c
@@ -477,6 +477,20 @@ int vm_insert_page(struct vm_area_struct *vma, unsigned long addr,
 }
 EXPORT_SYMBOL(vm_insert_page);
 
+int vm_map_pages(struct vm_area_struct *vma, struct page **pages,
+			unsigned long num)
+{
+	return -EINVAL;
+}
+EXPORT_SYMBOL(vm_map_pages);
+
+int vm_map_pages_zero(struct vm_area_struct *vma, struct page **pages,
+				unsigned long num)
+{
+	return -EINVAL;
+}
+EXPORT_SYMBOL(vm_map_pages_zero);
+
 /*
  *  sys_brk() for the most part doesn't need the global kernel
  *  lock, except when an application is doing something nasty
