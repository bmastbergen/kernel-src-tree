mlxsw: spectrum_acl: Refactor vregion association code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jiri Pirko <jiri@mellanox.com>
commit 79604b6e17426d64435bc947532a89fa8b0cf6b4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/79604b6e.failed

Refactor existing _vchunk_assoc/_vchunk_deassoc() functions into
_vregion_get()/_vregion_put() to make the code simpler and prepared for
vregion locking.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 79604b6e17426d64435bc947532a89fa8b0cf6b4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
index c607c62a43ae,e100b14b4815..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
@@@ -164,10 -179,16 +164,18 @@@ struct mlxsw_sp_acl_tcam_group 
  
  struct mlxsw_sp_acl_tcam_vregion {
  	struct mlxsw_sp_acl_tcam_region *region;
 -	struct mlxsw_sp_acl_tcam_region *region2; /* Used during migration */
  	struct list_head list; /* Member of a TCAM group */
 -	struct list_head tlist; /* Member of a TCAM */
  	struct list_head vchunk_list; /* List of vchunks under this vregion */
 +	struct mlxsw_sp_acl_tcam_group *group;
  	struct mlxsw_afk_key_info *key_info;
++<<<<<<< HEAD
++=======
+ 	struct mlxsw_sp_acl_tcam *tcam;
+ 	struct delayed_work rehash_dw;
+ 	struct mlxsw_sp *mlxsw_sp;
+ 	bool failed_rollback; /* Indicates failed rollback during migration */
+ 	unsigned int ref_count;
++>>>>>>> 79604b6e1742 (mlxsw: spectrum_acl: Refactor vregion association code)
  };
  
  struct mlxsw_sp_acl_tcam_vchunk;
@@@ -329,13 -387,37 +337,45 @@@ mlxsw_sp_acl_tcam_vregion_max_prio(stru
  
  static int
  mlxsw_sp_acl_tcam_group_region_attach(struct mlxsw_sp *mlxsw_sp,
++<<<<<<< HEAD
 +				      struct mlxsw_sp_acl_tcam_region *region)
++=======
+ 				      struct mlxsw_sp_acl_tcam_group *group,
+ 				      struct mlxsw_sp_acl_tcam_region *region,
+ 				      unsigned int priority,
+ 				      struct mlxsw_sp_acl_tcam_region *next_region)
++>>>>>>> 79604b6e1742 (mlxsw: spectrum_acl: Refactor vregion association code)
  {
 -	struct mlxsw_sp_acl_tcam_region *region2;
 -	struct list_head *pos;
 +	struct mlxsw_sp_acl_tcam_group *group = region->vregion->group;
  	int err;
  
++<<<<<<< HEAD
 +	if (group->region_count == group->tcam->max_group_size)
 +		return -ENOBUFS;
++=======
+ 	mutex_lock(&group->lock);
+ 	if (group->region_count == group->tcam->max_group_size) {
+ 		err = -ENOBUFS;
+ 		goto err_region_count_check;
+ 	}
+ 
+ 	if (next_region) {
+ 		/* If the next region is defined, place the new one
+ 		 * before it. The next one is a sibling.
+ 		 */
+ 		pos = &next_region->list;
+ 	} else {
+ 		/* Position the region inside the list according to priority */
+ 		list_for_each(pos, &group->region_list) {
+ 			region2 = list_entry(pos, typeof(*region2), list);
+ 			if (mlxsw_sp_acl_tcam_vregion_prio(region2->vregion) >
+ 			    priority)
+ 				break;
+ 		}
+ 	}
+ 	list_add_tail(&region->list, pos);
+ 	region->group = group;
++>>>>>>> 79604b6e1742 (mlxsw: spectrum_acl: Refactor vregion association code)
  
  	err = mlxsw_sp_acl_tcam_group_update(mlxsw_sp, group);
  	if (err)
@@@ -356,25 -447,27 +396,42 @@@ mlxsw_sp_acl_tcam_group_region_detach(s
  }
  
  static int
++<<<<<<< HEAD
 +mlxsw_sp_acl_tcam_group_vregion_attach(struct mlxsw_sp *mlxsw_sp,
 +				       struct mlxsw_sp_acl_tcam_group *group,
 +				       struct mlxsw_sp_acl_tcam_vregion *vregion)
++=======
+ mlxsw_sp_acl_tcam_vgroup_vregion_attach(struct mlxsw_sp *mlxsw_sp,
+ 					struct mlxsw_sp_acl_tcam_vgroup *vgroup,
+ 					struct mlxsw_sp_acl_tcam_vregion *vregion,
+ 					unsigned int priority)
++>>>>>>> 79604b6e1742 (mlxsw: spectrum_acl: Refactor vregion association code)
  {
  	struct mlxsw_sp_acl_tcam_vregion *vregion2;
  	struct list_head *pos;
  	int err;
  
  	/* Position the vregion inside the list according to priority */
 -	list_for_each(pos, &vgroup->vregion_list) {
 +	list_for_each(pos, &group->vregion_list) {
  		vregion2 = list_entry(pos, typeof(*vregion2), list);
++<<<<<<< HEAD
 +		if (mlxsw_sp_acl_tcam_vregion_prio(vregion2) >
 +		    mlxsw_sp_acl_tcam_vregion_prio(vregion))
++=======
+ 		if (mlxsw_sp_acl_tcam_vregion_prio(vregion2) > priority)
++>>>>>>> 79604b6e1742 (mlxsw: spectrum_acl: Refactor vregion association code)
  			break;
  	}
  	list_add_tail(&vregion->list, pos);
 +	vregion->group = group;
  
++<<<<<<< HEAD
 +	err = mlxsw_sp_acl_tcam_group_region_attach(mlxsw_sp, vregion->region);
++=======
+ 	err = mlxsw_sp_acl_tcam_group_region_attach(mlxsw_sp, &vgroup->group,
+ 						    vregion->region,
+ 						    priority, NULL);
++>>>>>>> 79604b6e1742 (mlxsw: spectrum_acl: Refactor vregion association code)
  	if (err)
  		goto err_region_attach;
  
@@@ -603,12 -701,45 +660,14 @@@ mlxsw_sp_acl_tcam_region_destroy(struc
  	kfree(region);
  }
  
 -static void
 -mlxsw_sp_acl_tcam_vregion_rehash_work_schedule(struct mlxsw_sp_acl_tcam_vregion *vregion)
 -{
 -	unsigned long interval = vregion->tcam->vregion_rehash_intrvl;
 -
 -	if (!interval)
 -		return;
 -	mlxsw_core_schedule_dw(&vregion->rehash_dw,
 -			       msecs_to_jiffies(interval));
 -}
 -
 -static int
 -mlxsw_sp_acl_tcam_vregion_rehash(struct mlxsw_sp *mlxsw_sp,
 -				 struct mlxsw_sp_acl_tcam_vregion *vregion);
 -
 -static void mlxsw_sp_acl_tcam_vregion_rehash_work(struct work_struct *work)
 -{
 -	struct mlxsw_sp_acl_tcam_vregion *vregion =
 -		container_of(work, struct mlxsw_sp_acl_tcam_vregion,
 -			     rehash_dw.work);
 -
 -	/* TODO: Take rtnl lock here as the rest of the code counts on it
 -	 * now. Later, this should be replaced by per-vregion lock.
 -	 */
 -	rtnl_lock();
 -	mlxsw_sp_acl_tcam_vregion_rehash(vregion->mlxsw_sp, vregion);
 -	rtnl_unlock();
 -	mlxsw_sp_acl_tcam_vregion_rehash_work_schedule(vregion);
 -}
 -
  static struct mlxsw_sp_acl_tcam_vregion *
  mlxsw_sp_acl_tcam_vregion_create(struct mlxsw_sp *mlxsw_sp,
- 				 struct mlxsw_sp_acl_tcam *tcam,
+ 				 struct mlxsw_sp_acl_tcam_vgroup *vgroup,
+ 				 unsigned int priority,
  				 struct mlxsw_afk_element_usage *elusage)
  {
 -	const struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;
  	struct mlxsw_afk *afk = mlxsw_sp_acl_afk(mlxsw_sp->acl);
+ 	struct mlxsw_sp_acl_tcam *tcam = vgroup->group.tcam;
  	struct mlxsw_sp_acl_tcam_vregion *vregion;
  	int err;
  
@@@ -616,6 -747,9 +675,12 @@@
  	if (!vregion)
  		return ERR_PTR(-ENOMEM);
  	INIT_LIST_HEAD(&vregion->vchunk_list);
++<<<<<<< HEAD
++=======
+ 	vregion->tcam = tcam;
+ 	vregion->mlxsw_sp = mlxsw_sp;
+ 	vregion->ref_count = 1;
++>>>>>>> 79604b6e1742 (mlxsw: spectrum_acl: Refactor vregion association code)
  
  	vregion->key_info = mlxsw_afk_key_info_get(afk, elusage);
  	if (IS_ERR(vregion->key_info)) {
@@@ -630,8 -764,24 +695,27 @@@
  		goto err_region_create;
  	}
  
++<<<<<<< HEAD
++=======
+ 	err = mlxsw_sp_acl_tcam_vgroup_vregion_attach(mlxsw_sp, vgroup, vregion,
+ 						      priority);
+ 	if (err)
+ 		goto err_vgroup_vregion_attach;
+ 
+ 	list_add_tail(&vregion->tlist, &tcam->vregion_list);
+ 
+ 	if (ops->region_rehash_hints_get) {
+ 		/* Create the delayed work for vregion periodic rehash */
+ 		INIT_DELAYED_WORK(&vregion->rehash_dw,
+ 				  mlxsw_sp_acl_tcam_vregion_rehash_work);
+ 		mlxsw_sp_acl_tcam_vregion_rehash_work_schedule(vregion);
+ 	}
+ 
++>>>>>>> 79604b6e1742 (mlxsw: spectrum_acl: Refactor vregion association code)
  	return vregion;
  
+ err_vgroup_vregion_attach:
+ 	mlxsw_sp_acl_tcam_region_destroy(mlxsw_sp, vregion->region);
  err_region_create:
  	mlxsw_afk_key_info_put(vregion->key_info);
  err_key_info_get:
@@@ -643,75 -793,95 +727,157 @@@ static voi
  mlxsw_sp_acl_tcam_vregion_destroy(struct mlxsw_sp *mlxsw_sp,
  				  struct mlxsw_sp_acl_tcam_vregion *vregion)
  {
++<<<<<<< HEAD
++=======
+ 	const struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;
+ 
+ 	if (ops->region_rehash_hints_get)
+ 		cancel_delayed_work_sync(&vregion->rehash_dw);
+ 	list_del(&vregion->tlist);
+ 	mlxsw_sp_acl_tcam_vgroup_vregion_detach(mlxsw_sp, vregion);
+ 	if (vregion->region2)
+ 		mlxsw_sp_acl_tcam_region_destroy(mlxsw_sp, vregion->region2);
++>>>>>>> 79604b6e1742 (mlxsw: spectrum_acl: Refactor vregion association code)
  	mlxsw_sp_acl_tcam_region_destroy(mlxsw_sp, vregion->region);
  	mlxsw_afk_key_info_put(vregion->key_info);
  	kfree(vregion);
  }
  
++<<<<<<< HEAD
 +static int
 +mlxsw_sp_acl_tcam_vchunk_assoc(struct mlxsw_sp *mlxsw_sp,
 +			       struct mlxsw_sp_acl_tcam_group *group,
 +			       unsigned int priority,
 +			       struct mlxsw_afk_element_usage *elusage,
 +			       struct mlxsw_sp_acl_tcam_vchunk *vchunk)
++=======
+ u32 mlxsw_sp_acl_tcam_vregion_rehash_intrvl_get(struct mlxsw_sp *mlxsw_sp,
+ 						struct mlxsw_sp_acl_tcam *tcam)
  {
+ 	const struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;
+ 	u32 vregion_rehash_intrvl;
+ 
+ 	if (WARN_ON(!ops->region_rehash_hints_get))
+ 		return 0;
+ 	vregion_rehash_intrvl = tcam->vregion_rehash_intrvl;
+ 	return vregion_rehash_intrvl;
+ }
+ 
+ int mlxsw_sp_acl_tcam_vregion_rehash_intrvl_set(struct mlxsw_sp *mlxsw_sp,
+ 						struct mlxsw_sp_acl_tcam *tcam,
+ 						u32 val)
+ {
+ 	const struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;
+ 	struct mlxsw_sp_acl_tcam_vregion *vregion;
+ 
+ 	if (val < MLXSW_SP_ACL_TCAM_VREGION_REHASH_INTRVL_MIN && val)
+ 		return -EINVAL;
+ 	if (WARN_ON(!ops->region_rehash_hints_get))
+ 		return -EOPNOTSUPP;
+ 	tcam->vregion_rehash_intrvl = val;
+ 	rtnl_lock();
+ 	list_for_each_entry(vregion, &tcam->vregion_list, tlist) {
+ 		if (val)
+ 			mlxsw_core_schedule_dw(&vregion->rehash_dw, 0);
+ 		else
+ 			cancel_delayed_work_sync(&vregion->rehash_dw);
+ 	}
+ 	rtnl_unlock();
+ 	return 0;
+ }
+ 
+ static struct mlxsw_sp_acl_tcam_vregion *
+ mlxsw_sp_acl_tcam_vregion_get(struct mlxsw_sp *mlxsw_sp,
+ 			      struct mlxsw_sp_acl_tcam_vgroup *vgroup,
+ 			      unsigned int priority,
+ 			      struct mlxsw_afk_element_usage *elusage)
++>>>>>>> 79604b6e1742 (mlxsw: spectrum_acl: Refactor vregion association code)
+ {
+ 	struct mlxsw_afk_element_usage vregion_elusage;
  	struct mlxsw_sp_acl_tcam_vregion *vregion;
- 	bool vregion_created = false;
  	bool need_split;
- 	int err;
  
++<<<<<<< HEAD
 +	vregion = mlxsw_sp_acl_tcam_group_vregion_find(group, priority, elusage,
 +						       &need_split);
 +	if (vregion && need_split) {
 +		/* According to priority, the vchunk should belong to an
 +		 * existing vregion. However, this vchunk needs elements
 +		 * that vregion does not contain. We need to split the existing
 +		 * vregion into two and create a new vregion for this vchunk
 +		 * in between. This is not supported now.
 +		 */
 +		return -EOPNOTSUPP;
 +	}
 +	if (!vregion) {
 +		struct mlxsw_afk_element_usage vregion_elusage;
 +
 +		mlxsw_sp_acl_tcam_group_use_patterns(group, elusage,
 +						     &vregion_elusage);
 +		vregion = mlxsw_sp_acl_tcam_vregion_create(mlxsw_sp,
 +							   group->tcam,
 +							   &vregion_elusage);
 +		if (IS_ERR(vregion))
 +			return PTR_ERR(vregion);
 +		vregion_created = true;
++=======
+ 	vregion = mlxsw_sp_acl_tcam_vgroup_vregion_find(vgroup, priority,
+ 							elusage, &need_split);
+ 	if (vregion) {
+ 		if (need_split) {
+ 			/* According to priority, new vchunk should belong to
+ 			 * an existing vregion. However, this vchunk needs
+ 			 * elements that vregion does not contain. We need
+ 			 * to split the existing vregion into two and create
+ 			 * a new vregion for the new vchunk in between.
+ 			 * This is not supported now.
+ 			 */
+ 			return ERR_PTR(-EOPNOTSUPP);
+ 		}
+ 		vregion->ref_count++;
+ 		return vregion;
++>>>>>>> 79604b6e1742 (mlxsw: spectrum_acl: Refactor vregion association code)
  	}
  
- 	vchunk->vregion = vregion;
- 	list_add_tail(&vchunk->list, &vregion->vchunk_list);
+ 	mlxsw_sp_acl_tcam_vgroup_use_patterns(vgroup, elusage,
+ 					      &vregion_elusage);
  
++<<<<<<< HEAD
 +	if (!vregion_created)
 +		return 0;
 +
 +	err = mlxsw_sp_acl_tcam_group_vregion_attach(mlxsw_sp, group, vregion);
 +	if (err)
 +		goto err_group_vregion_attach;
 +
 +	return 0;
 +
 +err_group_vregion_attach:
 +	mlxsw_sp_acl_tcam_vregion_destroy(mlxsw_sp, vregion);
 +	return err;
++=======
+ 	return mlxsw_sp_acl_tcam_vregion_create(mlxsw_sp, vgroup, priority,
+ 						&vregion_elusage);
++>>>>>>> 79604b6e1742 (mlxsw: spectrum_acl: Refactor vregion association code)
  }
  
  static void
- mlxsw_sp_acl_tcam_vchunk_deassoc(struct mlxsw_sp *mlxsw_sp,
- 				 struct mlxsw_sp_acl_tcam_vchunk *vchunk)
+ mlxsw_sp_acl_tcam_vregion_put(struct mlxsw_sp *mlxsw_sp,
+ 			      struct mlxsw_sp_acl_tcam_vregion *vregion)
  {
++<<<<<<< HEAD
 +	struct mlxsw_sp_acl_tcam_vregion *vregion = vchunk->vregion;
 +
 +	list_del(&vchunk->list);
 +	if (list_empty(&vregion->vchunk_list)) {
 +		mlxsw_sp_acl_tcam_group_vregion_detach(mlxsw_sp, vregion);
 +		mlxsw_sp_acl_tcam_vregion_destroy(mlxsw_sp, vregion);
 +	}
++=======
+ 	if (--vregion->ref_count)
+ 		return;
+ 	mlxsw_sp_acl_tcam_vregion_destroy(mlxsw_sp, vregion);
++>>>>>>> 79604b6e1742 (mlxsw: spectrum_acl: Refactor vregion association code)
  }
  
  static struct mlxsw_sp_acl_tcam_chunk *
@@@ -756,16 -928,21 +923,27 @@@ mlxsw_sp_acl_tcam_vchunk_create(struct 
  	vchunk = kzalloc(sizeof(*vchunk), GFP_KERNEL);
  	if (!vchunk)
  		return ERR_PTR(-ENOMEM);
 -	INIT_LIST_HEAD(&vchunk->ventry_list);
  	vchunk->priority = priority;
 -	vchunk->vgroup = vgroup;
 +	vchunk->group = group;
  	vchunk->ref_count = 1;
  
++<<<<<<< HEAD
 +	err = mlxsw_sp_acl_tcam_vchunk_assoc(mlxsw_sp, group, priority,
 +					     elusage, vchunk);
 +	if (err)
 +		goto err_vchunk_assoc;
++=======
+ 	vregion = mlxsw_sp_acl_tcam_vregion_get(mlxsw_sp, vgroup,
+ 						priority, elusage);
+ 	if (IS_ERR(vregion)) {
+ 		err = PTR_ERR(vregion);
+ 		goto err_vregion_get;
+ 	}
+ 
+ 	vchunk->vregion = vregion;
++>>>>>>> 79604b6e1742 (mlxsw: spectrum_acl: Refactor vregion association code)
  
 -	err = rhashtable_insert_fast(&vgroup->vchunk_ht, &vchunk->ht_node,
 +	err = rhashtable_insert_fast(&group->vchunk_ht, &vchunk->ht_node,
  				     mlxsw_sp_acl_tcam_vchunk_ht_params);
  	if (err)
  		goto err_rhashtable_insert;
@@@ -780,11 -959,11 +960,11 @@@
  	return vchunk;
  
  err_chunk_create:
 -	rhashtable_remove_fast(&vgroup->vchunk_ht, &vchunk->ht_node,
 +	rhashtable_remove_fast(&group->vchunk_ht, &vchunk->ht_node,
  			       mlxsw_sp_acl_tcam_vchunk_ht_params);
  err_rhashtable_insert:
- 	mlxsw_sp_acl_tcam_vchunk_deassoc(mlxsw_sp, vchunk);
- err_vchunk_assoc:
+ 	mlxsw_sp_acl_tcam_vregion_put(mlxsw_sp, vregion);
+ err_vregion_get:
  	kfree(vchunk);
  	return ERR_PTR(err);
  }
@@@ -793,12 -972,15 +973,18 @@@ static voi
  mlxsw_sp_acl_tcam_vchunk_destroy(struct mlxsw_sp *mlxsw_sp,
  				 struct mlxsw_sp_acl_tcam_vchunk *vchunk)
  {
 -	struct mlxsw_sp_acl_tcam_vgroup *vgroup = vchunk->vgroup;
 +	struct mlxsw_sp_acl_tcam_group *group = vchunk->group;
  
++<<<<<<< HEAD
++=======
+ 	list_del(&vchunk->list);
+ 	if (vchunk->chunk2)
+ 		mlxsw_sp_acl_tcam_chunk_destroy(mlxsw_sp, vchunk->chunk2);
++>>>>>>> 79604b6e1742 (mlxsw: spectrum_acl: Refactor vregion association code)
  	mlxsw_sp_acl_tcam_chunk_destroy(mlxsw_sp, vchunk->chunk);
 -	rhashtable_remove_fast(&vgroup->vchunk_ht, &vchunk->ht_node,
 +	rhashtable_remove_fast(&group->vchunk_ht, &vchunk->ht_node,
  			       mlxsw_sp_acl_tcam_vchunk_ht_params);
- 	mlxsw_sp_acl_tcam_vchunk_deassoc(mlxsw_sp, vchunk);
+ 	mlxsw_sp_acl_tcam_vregion_put(mlxsw_sp, vchunk->vregion);
  	kfree(vchunk);
  }
  
@@@ -958,6 -1136,186 +1144,189 @@@ mlxsw_sp_acl_tcam_ventry_activity_get(s
  						    ventry->entry, activity);
  }
  
++<<<<<<< HEAD
++=======
+ static int
+ mlxsw_sp_acl_tcam_ventry_migrate(struct mlxsw_sp *mlxsw_sp,
+ 				 struct mlxsw_sp_acl_tcam_ventry *ventry,
+ 				 struct mlxsw_sp_acl_tcam_chunk *chunk2)
+ {
+ 	struct mlxsw_sp_acl_tcam_entry *entry2;
+ 
+ 	entry2 = mlxsw_sp_acl_tcam_entry_create(mlxsw_sp, ventry, chunk2);
+ 	if (IS_ERR(entry2))
+ 		return PTR_ERR(entry2);
+ 	mlxsw_sp_acl_tcam_entry_destroy(mlxsw_sp, ventry->entry);
+ 	ventry->entry = entry2;
+ 	return 0;
+ }
+ 
+ static int
+ mlxsw_sp_acl_tcam_vchunk_migrate_one(struct mlxsw_sp *mlxsw_sp,
+ 				     struct mlxsw_sp_acl_tcam_vchunk *vchunk,
+ 				     struct mlxsw_sp_acl_tcam_region *region,
+ 				     bool this_is_rollback)
+ {
+ 	struct mlxsw_sp_acl_tcam_ventry *ventry;
+ 	struct mlxsw_sp_acl_tcam_chunk *chunk2;
+ 	int err;
+ 	int err2;
+ 
+ 	chunk2 = mlxsw_sp_acl_tcam_chunk_create(mlxsw_sp, vchunk, region);
+ 	if (IS_ERR(chunk2)) {
+ 		if (this_is_rollback)
+ 			vchunk->vregion->failed_rollback = true;
+ 		return PTR_ERR(chunk2);
+ 	}
+ 	vchunk->chunk2 = chunk2;
+ 	list_for_each_entry(ventry, &vchunk->ventry_list, list) {
+ 		err = mlxsw_sp_acl_tcam_ventry_migrate(mlxsw_sp, ventry,
+ 						       vchunk->chunk2);
+ 		if (err) {
+ 			if (this_is_rollback) {
+ 				vchunk->vregion->failed_rollback = true;
+ 				return err;
+ 			}
+ 			goto rollback;
+ 		}
+ 	}
+ 	mlxsw_sp_acl_tcam_chunk_destroy(mlxsw_sp, vchunk->chunk);
+ 	vchunk->chunk = chunk2;
+ 	vchunk->chunk2 = NULL;
+ 	return 0;
+ 
+ rollback:
+ 	/* Migrate the entries back to the original chunk. If some entry
+ 	 * migration fails, there's no good way how to proceed. Set the
+ 	 * vregion with "failed_rollback" flag.
+ 	 */
+ 	list_for_each_entry_continue_reverse(ventry, &vchunk->ventry_list,
+ 					     list) {
+ 		err2 = mlxsw_sp_acl_tcam_ventry_migrate(mlxsw_sp, ventry,
+ 							vchunk->chunk);
+ 		if (err2) {
+ 			vchunk->vregion->failed_rollback = true;
+ 			goto err_rollback;
+ 		}
+ 	}
+ 
+ 	mlxsw_sp_acl_tcam_chunk_destroy(mlxsw_sp, vchunk->chunk2);
+ 	vchunk->chunk2 = NULL;
+ 
+ err_rollback:
+ 	return err;
+ }
+ 
+ static int
+ mlxsw_sp_acl_tcam_vchunk_migrate_all(struct mlxsw_sp *mlxsw_sp,
+ 				     struct mlxsw_sp_acl_tcam_vregion *vregion)
+ {
+ 	struct mlxsw_sp_acl_tcam_vchunk *vchunk;
+ 	int err;
+ 
+ 	list_for_each_entry(vchunk, &vregion->vchunk_list, list) {
+ 		err = mlxsw_sp_acl_tcam_vchunk_migrate_one(mlxsw_sp, vchunk,
+ 							   vregion->region2,
+ 							   false);
+ 		if (err)
+ 			goto rollback;
+ 	}
+ 	return 0;
+ 
+ rollback:
+ 	list_for_each_entry_continue_reverse(vchunk, &vregion->vchunk_list,
+ 					     list) {
+ 		mlxsw_sp_acl_tcam_vchunk_migrate_one(mlxsw_sp, vchunk,
+ 						     vregion->region, true);
+ 	}
+ 	return err;
+ }
+ 
+ static int
+ mlxsw_sp_acl_tcam_vregion_migrate(struct mlxsw_sp *mlxsw_sp,
+ 				  struct mlxsw_sp_acl_tcam_vregion *vregion,
+ 				  void *hints_priv)
+ {
+ 	unsigned int priority = mlxsw_sp_acl_tcam_vregion_prio(vregion);
+ 	struct mlxsw_sp_acl_tcam_region *region2, *unused_region;
+ 	int err;
+ 
+ 	trace_mlxsw_sp_acl_tcam_vregion_migrate(mlxsw_sp, vregion);
+ 
+ 	region2 = mlxsw_sp_acl_tcam_region_create(mlxsw_sp, vregion->tcam,
+ 						  vregion, hints_priv);
+ 	if (IS_ERR(region2))
+ 		return PTR_ERR(region2);
+ 
+ 	vregion->region2 = region2;
+ 	err = mlxsw_sp_acl_tcam_group_region_attach(mlxsw_sp,
+ 						    vregion->region->group,
+ 						    region2, priority,
+ 						    vregion->region);
+ 	if (err)
+ 		goto err_group_region_attach;
+ 
+ 	err = mlxsw_sp_acl_tcam_vchunk_migrate_all(mlxsw_sp, vregion);
+ 	if (!vregion->failed_rollback) {
+ 		if (!err) {
+ 			/* In case of successful migration, region2 is used and
+ 			 * the original is unused.
+ 			 */
+ 			unused_region = vregion->region;
+ 			vregion->region = vregion->region2;
+ 		} else {
+ 			/* In case of failure during migration, the original
+ 			 * region is still used.
+ 			 */
+ 			unused_region = vregion->region2;
+ 		}
+ 		vregion->region2 = NULL;
+ 		mlxsw_sp_acl_tcam_group_region_detach(mlxsw_sp, unused_region);
+ 		mlxsw_sp_acl_tcam_region_destroy(mlxsw_sp, unused_region);
+ 	}
+ 	return err;
+ 
+ err_group_region_attach:
+ 	vregion->region2 = NULL;
+ 	mlxsw_sp_acl_tcam_region_destroy(mlxsw_sp, region2);
+ 	return err;
+ }
+ 
+ static int
+ mlxsw_sp_acl_tcam_vregion_rehash(struct mlxsw_sp *mlxsw_sp,
+ 				 struct mlxsw_sp_acl_tcam_vregion *vregion)
+ {
+ 	const struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;
+ 	void *hints_priv;
+ 	int err;
+ 
+ 	trace_mlxsw_sp_acl_tcam_vregion_rehash(mlxsw_sp, vregion);
+ 	if (vregion->failed_rollback)
+ 		return -EBUSY;
+ 
+ 	hints_priv = ops->region_rehash_hints_get(vregion->region->priv);
+ 	if (IS_ERR(hints_priv)) {
+ 		err = PTR_ERR(hints_priv);
+ 		if (err != -EAGAIN)
+ 			dev_err(mlxsw_sp->bus_info->dev, "Failed get rehash hints\n");
+ 		return err;
+ 	}
+ 
+ 	err = mlxsw_sp_acl_tcam_vregion_migrate(mlxsw_sp, vregion, hints_priv);
+ 	if (err) {
+ 		dev_err(mlxsw_sp->bus_info->dev, "Failed to migrate vregion\n");
+ 		if (vregion->failed_rollback) {
+ 			trace_mlxsw_sp_acl_tcam_vregion_rehash_dis(mlxsw_sp,
+ 								   vregion);
+ 			dev_err(mlxsw_sp->bus_info->dev, "Failed to rollback during vregion migration fail\n");
+ 		}
+ 	}
+ 
+ 	ops->region_rehash_hints_put(hints_priv);
+ 	return err;
+ }
+ 
++>>>>>>> 79604b6e1742 (mlxsw: spectrum_acl: Refactor vregion association code)
  static const enum mlxsw_afk_element mlxsw_sp_acl_tcam_pattern_ipv4[] = {
  	MLXSW_AFK_ELEMENT_SRC_SYS_PORT,
  	MLXSW_AFK_ELEMENT_DMAC_32_47,
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
