arm64: cpu_errata: Remove ARM64_MISMATCHED_CACHE_LINE_SIZE

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Will Deacon <will.deacon@arm.com>
commit 880f7cc47265e7b195781dfa9a0cd62ef78304e3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/880f7cc4.failed

There's no need to treat mismatched cache-line sizes reported by CTR_EL0
differently to any other mismatched fields that we treat as "STRICT" in
the cpufeature code. In both cases we need to trap and emulate EL0
accesses to the register, so drop ARM64_MISMATCHED_CACHE_LINE_SIZE and
rely on ARM64_MISMATCHED_CACHE_TYPE instead.

	Reviewed-by: Suzuki K Poulose <suzuki.poulose@arm.com>
	Signed-off-by: Will Deacon <will.deacon@arm.com>
[catalin.marinas@arm.com: move ARM64_HAS_CNP in the empty cpucaps.h slot]
	Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
(cherry picked from commit 880f7cc47265e7b195781dfa9a0cd62ef78304e3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/asm/cpucaps.h
#	arch/arm64/kernel/cpu_errata.c
diff --cc arch/arm64/include/asm/cpucaps.h
index c0f5aa4ec4c9,6eb1b3fd0493..000000000000
--- a/arch/arm64/include/asm/cpucaps.h
+++ b/arch/arm64/include/asm/cpucaps.h
@@@ -49,9 -49,11 +49,18 @@@
  #define ARM64_HAS_CACHE_DIC			28
  #define ARM64_HW_DBM				29
  #define ARM64_SSBD				30
++<<<<<<< HEAD
 +#define ARM64_HAS_SB				31
 +#define ARM64_HAS_CNP				32
 +
 +#define ARM64_NCAPS				33
++=======
+ #define ARM64_MISMATCHED_CACHE_TYPE		31
+ #define ARM64_HAS_STAGE2_FWB			32
+ #define ARM64_HAS_CRC32				33
+ #define ARM64_SSBS				34
+ 
+ #define ARM64_NCAPS				35
++>>>>>>> 880f7cc47265 (arm64: cpu_errata: Remove ARM64_MISMATCHED_CACHE_LINE_SIZE)
  
  #endif /* __ASM_CPUCAPS_H */
diff --cc arch/arm64/kernel/cpu_errata.c
index fde6f87a8b7e,20be4c578e0a..000000000000
--- a/arch/arm64/kernel/cpu_errata.c
+++ b/arch/arm64/kernel/cpu_errata.c
@@@ -65,10 -65,10 +65,14 @@@ is_kryo_midr(const struct arm64_cpu_cap
  }
  
  static bool
 -has_mismatched_cache_type(const struct arm64_cpu_capabilities *entry,
 -			  int scope)
 +has_mismatched_cache_line_size(const struct arm64_cpu_capabilities *entry,
 +				int scope)
  {
++<<<<<<< HEAD
 +	u64 mask = CTR_CACHE_MINLINE_MASK;
++=======
+ 	u64 mask = arm64_ftr_reg_ctrel0.strict_mask;;
++>>>>>>> 880f7cc47265 (arm64: cpu_errata: Remove ARM64_MISMATCHED_CACHE_LINE_SIZE)
  
  	WARN_ON(scope != SCOPE_LOCAL_CPU || preemptible());
  	return (read_cpuid_cachetype() & mask) !=
@@@ -624,9 -640,9 +628,15 @@@ const struct arm64_cpu_capabilities arm
  	},
  #endif
  	{
++<<<<<<< HEAD
 +		.desc = "Mismatched cache line size",
 +		.capability = ARM64_MISMATCHED_CACHE_LINE_SIZE,
 +		.matches = has_mismatched_cache_line_size,
++=======
+ 		.desc = "Mismatched cache type (CTR_EL0)",
+ 		.capability = ARM64_MISMATCHED_CACHE_TYPE,
+ 		.matches = has_mismatched_cache_type,
++>>>>>>> 880f7cc47265 (arm64: cpu_errata: Remove ARM64_MISMATCHED_CACHE_LINE_SIZE)
  		.type = ARM64_CPUCAP_LOCAL_CPU_ERRATUM,
  		.cpu_enable = cpu_enable_trap_ctr_access,
  	},
diff --git a/arch/arm64/include/asm/assembler.h b/arch/arm64/include/asm/assembler.h
index 9f5a38dceda2..786af963cf0b 100644
--- a/arch/arm64/include/asm/assembler.h
+++ b/arch/arm64/include/asm/assembler.h
@@ -299,12 +299,11 @@ alternative_endif
 	ldr	\rd, [\rn, #MM_CONTEXT_ID]
 	.endm
 /*
- * read_ctr - read CTR_EL0. If the system has mismatched
- * cache line sizes, provide the system wide safe value
- * from arm64_ftr_reg_ctrel0.sys_val
+ * read_ctr - read CTR_EL0. If the system has mismatched register fields,
+ * provide the system wide safe value from arm64_ftr_reg_ctrel0.sys_val
  */
 	.macro	read_ctr, reg
-alternative_if_not ARM64_MISMATCHED_CACHE_LINE_SIZE
+alternative_if_not ARM64_MISMATCHED_CACHE_TYPE
 	mrs	\reg, ctr_el0			// read CTR
 	nop
 alternative_else
* Unmerged path arch/arm64/include/asm/cpucaps.h
* Unmerged path arch/arm64/kernel/cpu_errata.c
