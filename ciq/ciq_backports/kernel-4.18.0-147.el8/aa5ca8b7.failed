drm/i915: Align dumb buffer stride to 4k to allow for gtt remapping

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit aa5ca8b7421cdbdd2b1275e0cc4d11bdce043de9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/aa5ca8b7.failed

Align dumb buffer stride to 4k if the fb will be big enough to
require gtt remapping.

v2: Leave the stride alone for buffers that look to be for the cursor
v3: Make it not a hack (Daniel)

	Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190509122159.24376-7-ville.syrjala@linux.intel.com
	Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
	Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
(cherry picked from commit aa5ca8b7421cdbdd2b1275e0cc4d11bdce043de9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/i915_gem.c
#	drivers/gpu/drm/i915/intel_display.c
#	drivers/gpu/drm/i915/intel_display.h
diff --cc drivers/gpu/drm/i915/i915_gem.c
index 17c5097721e8,7cafd5612f71..000000000000
--- a/drivers/gpu/drm/i915/i915_gem.c
+++ b/drivers/gpu/drm/i915/i915_gem.c
@@@ -46,6 -37,25 +46,28 @@@
  #include <linux/swap.h>
  #include <linux/pci.h>
  #include <linux/dma-buf.h>
++<<<<<<< HEAD
++=======
+ #include <linux/mman.h>
+ 
+ #include "gt/intel_engine_pm.h"
+ #include "gt/intel_gt_pm.h"
+ #include "gt/intel_mocs.h"
+ #include "gt/intel_reset.h"
+ #include "gt/intel_workarounds.h"
+ 
+ #include "i915_drv.h"
+ #include "i915_gem_clflush.h"
+ #include "i915_gemfs.h"
+ #include "i915_gem_pm.h"
+ #include "i915_trace.h"
+ #include "i915_vgpu.h"
+ 
+ #include "intel_display.h"
+ #include "intel_drv.h"
+ #include "intel_frontbuffer.h"
+ #include "intel_pm.h"
++>>>>>>> aa5ca8b7421c (drm/i915: Align dumb buffer stride to 4k to allow for gtt remapping)
  
  static void i915_gem_flush_free_objects(struct drm_i915_private *i915);
  
@@@ -736,11 -561,34 +758,34 @@@ i915_gem_dumb_create(struct drm_file *f
  		     struct drm_device *dev,
  		     struct drm_mode_create_dumb *args)
  {
+ 	int cpp = DIV_ROUND_UP(args->bpp, 8);
+ 	u32 format;
+ 
+ 	switch (cpp) {
+ 	case 1:
+ 		format = DRM_FORMAT_C8;
+ 		break;
+ 	case 2:
+ 		format = DRM_FORMAT_RGB565;
+ 		break;
+ 	case 4:
+ 		format = DRM_FORMAT_XRGB8888;
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
  	/* have to work out size/pitch and return them */
- 	args->pitch = ALIGN(args->width * DIV_ROUND_UP(args->bpp, 8), 64);
+ 	args->pitch = ALIGN(args->width * cpp, 64);
+ 
+ 	/* align stride to page size so that we can remap */
+ 	if (args->pitch > intel_plane_fb_max_stride(to_i915(dev), format,
+ 						    DRM_FORMAT_MOD_LINEAR))
+ 		args->pitch = ALIGN(args->pitch, 4096);
+ 
  	args->size = args->pitch * args->height;
  	return i915_gem_create(file, to_i915(dev),
 -			       &args->size, &args->handle);
 +			       args->size, &args->handle);
  }
  
  static bool gpu_write_needs_clflush(struct drm_i915_gem_object *obj)
diff --cc drivers/gpu/drm/i915/intel_display.c
index 98867581a27e,2d78bd75c153..000000000000
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@@ -2515,6 -2492,127 +2515,130 @@@ intel_get_format_info(const struct drm_
  	}
  }
  
++<<<<<<< HEAD
++=======
+ bool is_ccs_modifier(u64 modifier)
+ {
+ 	return modifier == I915_FORMAT_MOD_Y_TILED_CCS ||
+ 	       modifier == I915_FORMAT_MOD_Yf_TILED_CCS;
+ }
+ 
+ u32 intel_plane_fb_max_stride(struct drm_i915_private *dev_priv,
+ 			      u32 pixel_format, u64 modifier)
+ {
+ 	struct intel_crtc *crtc;
+ 	struct intel_plane *plane;
+ 
+ 	/*
+ 	 * We assume the primary plane for pipe A has
+ 	 * the highest stride limits of them all.
+ 	 */
+ 	crtc = intel_get_crtc_for_pipe(dev_priv, PIPE_A);
+ 	plane = to_intel_plane(crtc->base.primary);
+ 
+ 	return plane->max_stride(plane, pixel_format, modifier,
+ 				 DRM_MODE_ROTATE_0);
+ }
+ 
+ static
+ u32 intel_fb_max_stride(struct drm_i915_private *dev_priv,
+ 			u32 pixel_format, u64 modifier)
+ {
+ 	return intel_plane_fb_max_stride(dev_priv, pixel_format, modifier);
+ }
+ 
+ static u32
+ intel_fb_stride_alignment(const struct drm_framebuffer *fb, int color_plane)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(fb->dev);
+ 
+ 	if (fb->modifier == DRM_FORMAT_MOD_LINEAR) {
+ 		u32 max_stride = intel_plane_fb_max_stride(dev_priv,
+ 							   fb->format->format,
+ 							   fb->modifier);
+ 
+ 		/*
+ 		 * To make remapping with linear generally feasible
+ 		 * we need the stride to be page aligned.
+ 		 */
+ 		if (fb->pitches[color_plane] > max_stride)
+ 			return intel_tile_size(dev_priv);
+ 		else
+ 			return 64;
+ 	} else {
+ 		return intel_tile_width_bytes(fb, color_plane);
+ 	}
+ }
+ 
+ bool intel_plane_can_remap(const struct intel_plane_state *plane_state)
+ {
+ 	struct intel_plane *plane = to_intel_plane(plane_state->base.plane);
+ 	struct drm_i915_private *dev_priv = to_i915(plane->base.dev);
+ 	const struct drm_framebuffer *fb = plane_state->base.fb;
+ 	int i;
+ 
+ 	/* We don't want to deal with remapping with cursors */
+ 	if (plane->id == PLANE_CURSOR)
+ 		return false;
+ 
+ 	/*
+ 	 * The display engine limits already match/exceed the
+ 	 * render engine limits, so not much point in remapping.
+ 	 * Would also need to deal with the fence POT alignment
+ 	 * and gen2 2KiB GTT tile size.
+ 	 */
+ 	if (INTEL_GEN(dev_priv) < 4)
+ 		return false;
+ 
+ 	/*
+ 	 * The new CCS hash mode isn't compatible with remapping as
+ 	 * the virtual address of the pages affects the compressed data.
+ 	 */
+ 	if (is_ccs_modifier(fb->modifier))
+ 		return false;
+ 
+ 	/* Linear needs a page aligned stride for remapping */
+ 	if (fb->modifier == DRM_FORMAT_MOD_LINEAR) {
+ 		unsigned int alignment = intel_tile_size(dev_priv) - 1;
+ 
+ 		for (i = 0; i < fb->format->num_planes; i++) {
+ 			if (fb->pitches[i] & alignment)
+ 				return false;
+ 		}
+ 	}
+ 
+ 	return true;
+ }
+ 
+ static bool intel_plane_needs_remap(const struct intel_plane_state *plane_state)
+ {
+ 	struct intel_plane *plane = to_intel_plane(plane_state->base.plane);
+ 	const struct drm_framebuffer *fb = plane_state->base.fb;
+ 	unsigned int rotation = plane_state->base.rotation;
+ 	u32 stride, max_stride;
+ 
+ 	/*
+ 	 * No remapping for invisible planes since we don't have
+ 	 * an actual source viewport to remap.
+ 	 */
+ 	if (!plane_state->base.visible)
+ 		return false;
+ 
+ 	if (!intel_plane_can_remap(plane_state))
+ 		return false;
+ 
+ 	/*
+ 	 * FIXME: aux plane limits on gen9+ are
+ 	 * unclear in Bspec, for now no checking.
+ 	 */
+ 	stride = intel_fb_pitch(fb, 0, rotation);
+ 	max_stride = plane->max_stride(plane, fb->format->format,
+ 				       fb->modifier, rotation);
+ 
+ 	return stride > max_stride;
+ }
+ 
++>>>>>>> aa5ca8b7421c (drm/i915: Align dumb buffer stride to 4k to allow for gtt remapping)
  static int
  intel_fill_fb_info(struct drm_i915_private *dev_priv,
  		   struct drm_framebuffer *fb)
diff --cc drivers/gpu/drm/i915/intel_display.h
index 2ef31617614a,a43d54089be3..000000000000
--- a/drivers/gpu/drm/i915/intel_display.h
+++ b/drivers/gpu/drm/i915/intel_display.h
@@@ -333,9 -421,23 +333,18 @@@ struct intel_link_m_n 
  	     (__i)++) \
  		for_each_if(plane)
  
 -#define for_each_oldnew_intel_crtc_in_state(__state, crtc, old_crtc_state, new_crtc_state, __i) \
 -	for ((__i) = 0; \
 -	     (__i) < (__state)->base.dev->mode_config.num_crtc && \
 -		     ((crtc) = to_intel_crtc((__state)->base.crtcs[__i].ptr), \
 -		      (old_crtc_state) = to_intel_crtc_state((__state)->base.crtcs[__i].old_state), \
 -		      (new_crtc_state) = to_intel_crtc_state((__state)->base.crtcs[__i].new_state), 1); \
 -	     (__i)++) \
 -		for_each_if(crtc)
 -
 -void intel_link_compute_m_n(u16 bpp, int nlanes,
 +void intel_link_compute_m_n(int bpp, int nlanes,
  			    int pixel_clock, int link_clock,
  			    struct intel_link_m_n *m_n,
++<<<<<<< HEAD
 +			    bool reduce_m_n);
++=======
+ 			    bool constant_n);
+ bool is_ccs_modifier(u64 modifier);
+ void lpt_disable_clkout_dp(struct drm_i915_private *dev_priv);
+ u32 intel_plane_fb_max_stride(struct drm_i915_private *dev_priv,
+ 			      u32 pixel_format, u64 modifier);
+ bool intel_plane_can_remap(const struct intel_plane_state *plane_state);
++>>>>>>> aa5ca8b7421c (drm/i915: Align dumb buffer stride to 4k to allow for gtt remapping)
  
  #endif
* Unmerged path drivers/gpu/drm/i915/i915_gem.c
* Unmerged path drivers/gpu/drm/i915/intel_display.c
* Unmerged path drivers/gpu/drm/i915/intel_display.h
