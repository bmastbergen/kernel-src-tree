drm/amd/display: disable link before changing link settings

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Anthony Koo <Anthony.Koo@amd.com>
commit 15ae3b28f8ca406b449d36d36021e96b66aedb5d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/15ae3b28.failed

[Why]
If link is already enabled at a different rate (for example 5.4 Gbps)
then calling VBIOS command table to switch to a new rate
(for example 2.7 Gbps) will not take effect.
This can lead to link training failure to occur.

[How]
If the requested link rate is different than the current link rate,
the link must be disabled in order to re-enable at the new
link rate.

In today's logic it is currently only impacting eDP since DP
connection types will always disable the link during display
detection, when initial link verification occurs.

	Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
	Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
	Acked-by: Leo Li <sunpeng.li@amd.com>
	Acked-by: Tony Cheng <Tony.Cheng@amd.com>
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit 15ae3b28f8ca406b449d36d36021e96b66aedb5d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/display/dc/core/dc_link.c
diff --cc drivers/gpu/drm/amd/display/dc/core/dc_link.c
index 2fa521812d23,3b1e38e110ee..000000000000
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link.c
@@@ -1277,37 -1396,18 +1277,52 @@@ static enum dc_status enable_link_dp
  	/* get link settings for video mode timing */
  	decide_link_settings(stream, &link_settings);
  
++<<<<<<< HEAD
 +	/* raise clock state for HBR3 if required. Confirmed with HW DCE/DPCS
 +	 * logic for HBR3 still needs Nominal (0.8V) on VDDC rail
 +	 */
 +	if (link->link_enc->features.flags.bits.IS_HBR3_CAPABLE)
 +		max_link_rate = LINK_RATE_HIGH3;
 +
 +	if (link_settings.link_rate == max_link_rate) {
 +		if (state->dis_clk->funcs->set_min_clocks_state) {
 +			if (state->dis_clk->cur_min_clks_state < DM_PP_CLOCKS_STATE_NOMINAL)
 +				state->dis_clk->funcs->set_min_clocks_state(
 +					state->dis_clk, DM_PP_CLOCKS_STATE_NOMINAL);
 +		} else {
 +			uint32_t dp_phyclk_in_khz;
 +			const struct clocks_value clocks_value =
 +					state->dis_clk->cur_clocks_value;
 +
 +			/* 27mhz = 27000000hz= 27000khz */
 +			dp_phyclk_in_khz = link_settings.link_rate * 27000;
 +
 +			if (((clocks_value.max_non_dp_phyclk_in_khz != 0) &&
 +				(dp_phyclk_in_khz > clocks_value.max_non_dp_phyclk_in_khz)) ||
 +				(dp_phyclk_in_khz > clocks_value.max_dp_phyclk_in_khz)) {
 +				state->dis_clk->funcs->apply_clock_voltage_request(
 +						state->dis_clk,
 +						DM_PP_CLOCK_TYPE_DISPLAYPHYCLK,
 +						dp_phyclk_in_khz,
 +						false,
 +						true);
 +			}
 +		}
 +	}
++=======
+ 	/* If link settings are different than current and link already enabled
+ 	 * then need to disable before programming to new rate.
+ 	 */
+ 	if (link->link_status.link_active &&
+ 		(link->cur_link_settings.lane_count != link_settings.lane_count ||
+ 		 link->cur_link_settings.link_rate != link_settings.link_rate)) {
+ 		dp_disable_link_phy(link, pipe_ctx->stream->signal);
+ 	}
+ 
+ 	pipe_ctx->stream_res.pix_clk_params.requested_sym_clk =
+ 			link_settings.link_rate * LINK_RATE_REF_FREQ_IN_KHZ;
+ 	state->clk_mgr->funcs->update_clocks(state->clk_mgr, state, false);
++>>>>>>> 15ae3b28f8ca (drm/amd/display: disable link before changing link settings)
  
  	dp_enable_link_phy(
  		link,
* Unmerged path drivers/gpu/drm/amd/display/dc/core/dc_link.c
