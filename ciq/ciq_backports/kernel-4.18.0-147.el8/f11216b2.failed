bpf: add skb->tstamp r/w access from tc clsact and cg skb progs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Vlad Dumitrescu <vladum@google.com>
commit f11216b24219ab26d8d159fbfa12dff886b16e32
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/f11216b2.failed

This could be used to rate limit egress traffic in concert with a qdisc
which supports Earliest Departure Time, such as FQ.

Write access from cg skb progs only with CAP_SYS_ADMIN, since the value
will be used by downstream qdiscs. It might make sense to relax this.

Changes v1 -> v2:
  - allow access from cg skb, write only with CAP_SYS_ADMIN

	Signed-off-by: Vlad Dumitrescu <vladum@google.com>
	Acked-by: Eric Dumazet <edumazet@google.com>
	Acked-by: Willem de Bruijn <willemb@google.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit f11216b24219ab26d8d159fbfa12dff886b16e32)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/bpf.h
#	net/core/filter.c
#	tools/include/uapi/linux/bpf.h
diff --cc include/uapi/linux/bpf.h
index 2293d9a9b442,23e2031a43d4..000000000000
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@@ -2311,6 -2467,8 +2311,11 @@@ struct __sk_buff 
  	/* ... here. */
  
  	__u32 data_meta;
++<<<<<<< HEAD
++=======
+ 	struct bpf_flow_keys *flow_keys;
+ 	__u64 tstamp;
++>>>>>>> f11216b24219 (bpf: add skb->tstamp r/w access from tc clsact and cg skb progs)
  };
  
  struct bpf_tunnel_key {
diff --cc net/core/filter.c
index 5c01834ee5a7,65dc13aeca7c..000000000000
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@@ -5184,6 -5569,14 +5184,17 @@@ static bool bpf_skb_is_valid_access(in
  		if (size != size_default)
  			return false;
  		break;
++<<<<<<< HEAD
++=======
+ 	case bpf_ctx_range(struct __sk_buff, flow_keys):
+ 		if (size != sizeof(struct bpf_flow_keys *))
+ 			return false;
+ 		break;
+ 	case bpf_ctx_range(struct __sk_buff, tstamp):
+ 		if (size != sizeof(__u64))
+ 			return false;
+ 		break;
++>>>>>>> f11216b24219 (bpf: add skb->tstamp r/w access from tc clsact and cg skb progs)
  	default:
  		/* Only narrow read access allowed for now. */
  		if (type == BPF_WRITE) {
@@@ -5209,7 -5602,9 +5220,8 @@@ static bool sk_filter_is_valid_access(i
  	case bpf_ctx_range(struct __sk_buff, data):
  	case bpf_ctx_range(struct __sk_buff, data_meta):
  	case bpf_ctx_range(struct __sk_buff, data_end):
 -	case bpf_ctx_range(struct __sk_buff, flow_keys):
  	case bpf_ctx_range_till(struct __sk_buff, family, local_port):
+ 	case bpf_ctx_range(struct __sk_buff, tstamp):
  		return false;
  	}
  
@@@ -5274,6 -5673,8 +5290,11 @@@ static bool lwt_is_valid_access(int off
  	case bpf_ctx_range(struct __sk_buff, tc_classid):
  	case bpf_ctx_range_till(struct __sk_buff, family, local_port):
  	case bpf_ctx_range(struct __sk_buff, data_meta):
++<<<<<<< HEAD
++=======
+ 	case bpf_ctx_range(struct __sk_buff, flow_keys):
+ 	case bpf_ctx_range(struct __sk_buff, tstamp):
++>>>>>>> f11216b24219 (bpf: add skb->tstamp r/w access from tc clsact and cg skb progs)
  		return false;
  	}
  
@@@ -5694,6 -6103,8 +5716,11 @@@ static bool sk_skb_is_valid_access(int 
  	switch (off) {
  	case bpf_ctx_range(struct __sk_buff, tc_classid):
  	case bpf_ctx_range(struct __sk_buff, data_meta):
++<<<<<<< HEAD
++=======
+ 	case bpf_ctx_range(struct __sk_buff, flow_keys):
+ 	case bpf_ctx_range(struct __sk_buff, tstamp):
++>>>>>>> f11216b24219 (bpf: add skb->tstamp r/w access from tc clsact and cg skb progs)
  		return false;
  	}
  
@@@ -5753,6 -6164,40 +5780,43 @@@ static bool sk_msg_is_valid_access(int 
  	return true;
  }
  
++<<<<<<< HEAD
++=======
+ static bool flow_dissector_is_valid_access(int off, int size,
+ 					   enum bpf_access_type type,
+ 					   const struct bpf_prog *prog,
+ 					   struct bpf_insn_access_aux *info)
+ {
+ 	if (type == BPF_WRITE) {
+ 		switch (off) {
+ 		case bpf_ctx_range_till(struct __sk_buff, cb[0], cb[4]):
+ 			break;
+ 		default:
+ 			return false;
+ 		}
+ 	}
+ 
+ 	switch (off) {
+ 	case bpf_ctx_range(struct __sk_buff, data):
+ 		info->reg_type = PTR_TO_PACKET;
+ 		break;
+ 	case bpf_ctx_range(struct __sk_buff, data_end):
+ 		info->reg_type = PTR_TO_PACKET_END;
+ 		break;
+ 	case bpf_ctx_range(struct __sk_buff, flow_keys):
+ 		info->reg_type = PTR_TO_FLOW_KEYS;
+ 		break;
+ 	case bpf_ctx_range(struct __sk_buff, tc_classid):
+ 	case bpf_ctx_range(struct __sk_buff, data_meta):
+ 	case bpf_ctx_range_till(struct __sk_buff, family, local_port):
+ 	case bpf_ctx_range(struct __sk_buff, tstamp):
+ 		return false;
+ 	}
+ 
+ 	return bpf_skb_is_valid_access(off, size, type, prog, info);
+ }
+ 
++>>>>>>> f11216b24219 (bpf: add skb->tstamp r/w access from tc clsact and cg skb progs)
  static u32 bpf_convert_ctx_access(enum bpf_access_type type,
  				  const struct bpf_insn *si,
  				  struct bpf_insn *insn_buf,
@@@ -6050,6 -6492,31 +6114,34 @@@
  				      bpf_target_off(struct sock_common,
  						     skc_num, 2, target_size));
  		break;
++<<<<<<< HEAD
++=======
+ 
+ 	case offsetof(struct __sk_buff, flow_keys):
+ 		off  = si->off;
+ 		off -= offsetof(struct __sk_buff, flow_keys);
+ 		off += offsetof(struct sk_buff, cb);
+ 		off += offsetof(struct qdisc_skb_cb, flow_keys);
+ 		*insn++ = BPF_LDX_MEM(BPF_SIZEOF(void *), si->dst_reg,
+ 				      si->src_reg, off);
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, tstamp):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, tstamp) != 8);
+ 
+ 		if (type == BPF_WRITE)
+ 			*insn++ = BPF_STX_MEM(BPF_DW,
+ 					      si->dst_reg, si->src_reg,
+ 					      bpf_target_off(struct sk_buff,
+ 							     tstamp, 8,
+ 							     target_size));
+ 		else
+ 			*insn++ = BPF_LDX_MEM(BPF_DW,
+ 					      si->dst_reg, si->src_reg,
+ 					      bpf_target_off(struct sk_buff,
+ 							     tstamp, 8,
+ 							     target_size));
++>>>>>>> f11216b24219 (bpf: add skb->tstamp r/w access from tc clsact and cg skb progs)
  	}
  
  	return insn - insn_buf;
diff --cc tools/include/uapi/linux/bpf.h
index dd0da04bd3ab,23e2031a43d4..000000000000
--- a/tools/include/uapi/linux/bpf.h
+++ b/tools/include/uapi/linux/bpf.h
@@@ -2291,6 -2467,8 +2291,11 @@@ struct __sk_buff 
  	/* ... here. */
  
  	__u32 data_meta;
++<<<<<<< HEAD
++=======
+ 	struct bpf_flow_keys *flow_keys;
+ 	__u64 tstamp;
++>>>>>>> f11216b24219 (bpf: add skb->tstamp r/w access from tc clsact and cg skb progs)
  };
  
  struct bpf_tunnel_key {
* Unmerged path include/uapi/linux/bpf.h
* Unmerged path net/core/filter.c
* Unmerged path tools/include/uapi/linux/bpf.h
diff --git a/tools/testing/selftests/bpf/test_verifier.c b/tools/testing/selftests/bpf/test_verifier.c
index 0f3f97a401c9..17021d2b6bfe 100644
--- a/tools/testing/selftests/bpf/test_verifier.c
+++ b/tools/testing/selftests/bpf/test_verifier.c
@@ -2446,6 +2446,10 @@ static struct bpf_test tests[] = {
 				    offsetof(struct __sk_buff, tc_index)),
 			BPF_STX_MEM(BPF_W, BPF_REG_1, BPF_REG_0,
 				    offsetof(struct __sk_buff, cb[3])),
+			BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_1,
+				    offsetof(struct __sk_buff, tstamp)),
+			BPF_STX_MEM(BPF_DW, BPF_REG_1, BPF_REG_0,
+				    offsetof(struct __sk_buff, tstamp)),
 			BPF_EXIT_INSN(),
 		},
 		.errstr_unpriv = "",
@@ -5297,6 +5301,31 @@ static struct bpf_test tests[] = {
 		.errstr_unpriv = "R2 leaks addr into helper function",
 		.prog_type = BPF_PROG_TYPE_CGROUP_SKB,
 	},
+	{
+		"write tstamp from CGROUP_SKB",
+		.insns = {
+			BPF_MOV64_IMM(BPF_REG_0, 0),
+			BPF_STX_MEM(BPF_DW, BPF_REG_1, BPF_REG_0,
+				    offsetof(struct __sk_buff, tstamp)),
+			BPF_MOV64_IMM(BPF_REG_0, 0),
+			BPF_EXIT_INSN(),
+		},
+		.result = ACCEPT,
+		.result_unpriv = REJECT,
+		.errstr_unpriv = "invalid bpf_context access off=152 size=8",
+		.prog_type = BPF_PROG_TYPE_CGROUP_SKB,
+	},
+	{
+		"read tstamp from CGROUP_SKB",
+		.insns = {
+			BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_1,
+				    offsetof(struct __sk_buff, tstamp)),
+			BPF_MOV64_IMM(BPF_REG_0, 0),
+			BPF_EXIT_INSN(),
+		},
+		.result = ACCEPT,
+		.prog_type = BPF_PROG_TYPE_CGROUP_SKB,
+	},
 	{
 		"multiple registers share map_lookup_elem result",
 		.insns = {
