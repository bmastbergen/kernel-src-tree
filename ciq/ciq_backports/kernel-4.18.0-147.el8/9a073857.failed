RDMA/uverbs: Use uverbs_response() for remaining response copying

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jason Gunthorpe <jgg@ziepe.ca>
commit 9a0738575f2691d3a417fb5f83b6dcdaf0dcc36e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/9a073857.failed

This function properly truncates and zero-fills the response which is the
standard used by the ioctl uAPI when working with user data.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 9a0738575f2691d3a417fb5f83b6dcdaf0dcc36e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_cmd.c
diff --cc drivers/infiniband/core/uverbs_cmd.c
index 300532a4cde8,79e6594f9309..000000000000
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@@ -141,18 -162,21 +141,17 @@@ ssize_t ib_uverbs_get_context(struct ib
  		goto err_fd;
  	}
  
- 	if (copy_to_user(u64_to_user_ptr(cmd.response), &resp, sizeof resp)) {
- 		ret = -EFAULT;
+ 	ret = uverbs_response(attrs, &resp, sizeof(resp));
+ 	if (ret)
  		goto err_file;
- 	}
  
 -	fd_install(resp.async_fd, filp);
 +	file->ucontext = ucontext;
  
 -	/*
 -	 * Make sure that ib_uverbs_get_ucontext() sees the pointer update
 -	 * only after all writes to setup the ucontext have completed
 -	 */
 -	smp_store_release(&file->ucontext, ucontext);
 +	fd_install(resp.async_fd, filp);
  
 -	mutex_unlock(&file->ucontext_lock);
 +	mutex_unlock(&file->mutex);
  
 -	return 0;
 +	return in_len;
  
  err_file:
  	ib_uverbs_free_async_event_file(file);
@@@ -235,12 -260,9 +234,16 @@@ ssize_t ib_uverbs_query_device(struct i
  		return -EFAULT;
  
  	memset(&resp, 0, sizeof resp);
 -	copy_query_dev_fields(ucontext, &resp, &ucontext->device->attrs);
 +	copy_query_dev_fields(file, ib_dev, &resp, &ib_dev->attrs);
 +
++<<<<<<< HEAD
 +	if (copy_to_user(u64_to_user_ptr(cmd.response), &resp, sizeof resp))
 +		return -EFAULT;
  
 +	return in_len;
++=======
+ 	return uverbs_response(attrs, &resp, sizeof(resp));
++>>>>>>> 9a0738575f26 (RDMA/uverbs: Use uverbs_response() for remaining response copying)
  }
  
  /*
@@@ -317,16 -341,11 +320,20 @@@ ssize_t ib_uverbs_query_port(struct ib_
  	resp.link_layer      = rdma_port_get_link_layer(ib_dev,
  							cmd.port_num);
  
++<<<<<<< HEAD
 +	if (copy_to_user(u64_to_user_ptr(cmd.response), &resp, sizeof resp))
 +		return -EFAULT;
 +
 +	return in_len;
++=======
+ 	return uverbs_response(attrs, &resp, sizeof(resp));
++>>>>>>> 9a0738575f26 (RDMA/uverbs: Use uverbs_response() for remaining response copying)
  }
  
 -static int ib_uverbs_alloc_pd(struct uverbs_attr_bundle *attrs,
 -			      const char __user *buf, int in_len, int out_len)
 +ssize_t ib_uverbs_alloc_pd(struct ib_uverbs_file *file,
 +			   struct ib_device *ib_dev,
 +			   const char __user *buf,
 +			   int in_len, int out_len)
  {
  	struct ib_uverbs_alloc_pd      cmd;
  	struct ib_uverbs_alloc_pd_resp resp;
@@@ -367,14 -378,11 +374,13 @@@
  	pd->res.type = RDMA_RESTRACK_PD;
  	rdma_restrack_add(&pd->res);
  
- 	if (copy_to_user(u64_to_user_ptr(cmd.response), &resp, sizeof resp)) {
- 		ret = -EFAULT;
+ 	ret = uverbs_response(attrs, &resp, sizeof(resp));
+ 	if (ret)
  		goto err_copy;
- 	}
  
 -	return uobj_alloc_commit(uobj);
 +	uobj_alloc_commit(uobj);
 +
 +	return in_len;
  
  err_copy:
  	ib_dealloc_pd(pd);
@@@ -812,10 -783,7 +816,14 @@@ ssize_t ib_uverbs_rereg_mr(struct ib_uv
  	resp.lkey      = mr->lkey;
  	resp.rkey      = mr->rkey;
  
++<<<<<<< HEAD
 +	if (copy_to_user(u64_to_user_ptr(cmd.response), &resp, sizeof(resp)))
 +		ret = -EFAULT;
 +	else
 +		ret = in_len;
++=======
+ 	ret = uverbs_response(attrs, &resp, sizeof(resp));
++>>>>>>> 9a0738575f26 (RDMA/uverbs: Use uverbs_response() for remaining response copying)
  
  put_uobj_pd:
  	if (cmd.flags & IB_MR_REREG_PD)
@@@ -892,15 -847,12 +900,14 @@@ ssize_t ib_uverbs_alloc_mw(struct ib_uv
  	resp.rkey      = mw->rkey;
  	resp.mw_handle = uobj->id;
  
- 	if (copy_to_user(u64_to_user_ptr(cmd.response), &resp, sizeof(resp))) {
- 		ret = -EFAULT;
+ 	ret = uverbs_response(attrs, &resp, sizeof(resp));
+ 	if (ret)
  		goto err_copy;
- 	}
  
  	uobj_put_obj_read(pd);
 -	return uobj_alloc_commit(uobj);
 +	uobj_alloc_commit(uobj);
 +
 +	return in_len;
  
  err_copy:
  	uverbs_dealloc_mw(mw);
@@@ -934,9 -882,8 +941,14 @@@ ssize_t ib_uverbs_create_comp_channel(s
  	struct ib_uverbs_create_comp_channel_resp  resp;
  	struct ib_uobject			  *uobj;
  	struct ib_uverbs_completion_event_file	  *ev_file;
++<<<<<<< HEAD
 +
 +	if (out_len < sizeof resp)
 +		return -ENOSPC;
++=======
+ 	struct ib_device *ib_dev;
+ 	int ret;
++>>>>>>> 9a0738575f26 (RDMA/uverbs: Use uverbs_response() for remaining response copying)
  
  	if (copy_from_user(&cmd, buf, sizeof cmd))
  		return -EFAULT;
@@@ -948,30 -895,21 +960,31 @@@
  	resp.fd = uobj->id;
  
  	ev_file = container_of(uobj, struct ib_uverbs_completion_event_file,
 -			       uobj);
 +			       uobj_file.uobj);
  	ib_uverbs_init_event_queue(&ev_file->ev_queue);
  
- 	if (copy_to_user(u64_to_user_ptr(cmd.response), &resp, sizeof resp)) {
+ 	ret = uverbs_response(attrs, &resp, sizeof(resp));
+ 	if (ret) {
  		uobj_alloc_abort(uobj);
- 		return -EFAULT;
+ 		return ret;
  	}
  
 -	return uobj_alloc_commit(uobj);
 +	uobj_alloc_commit(uobj);
 +	return in_len;
  }
  
 -static struct ib_ucq_object *create_cq(struct uverbs_attr_bundle *attrs,
 +static struct ib_ucq_object *create_cq(struct ib_uverbs_file *file,
 +					struct ib_device *ib_dev,
 +				       struct ib_udata *ucore,
 +				       struct ib_udata *uhw,
  				       struct ib_uverbs_ex_create_cq *cmd,
 -				       size_t cmd_sz)
 +				       size_t cmd_sz,
 +				       int (*cb)(struct ib_uverbs_file *file,
 +						 struct ib_ucq_object *obj,
 +						 struct ib_uverbs_ex_create_cq_resp *resp,
 +						 struct ib_udata *udata,
 +						 void *context),
 +				       void *context)
  {
  	struct ib_ucq_object           *obj;
  	struct ib_uverbs_completion_event_file    *ev_file = NULL;
@@@ -1337,22 -1193,13 +1348,28 @@@ ssize_t ib_uverbs_destroy_cq(struct ib_
  	resp.comp_events_reported  = obj->comp_events_reported;
  	resp.async_events_reported = obj->async_events_reported;
  
++<<<<<<< HEAD
 +	uverbs_uobject_put(uobj);
 +	if (copy_to_user(u64_to_user_ptr(cmd.response), &resp, sizeof resp))
 +		return -EFAULT;
 +
 +	return in_len;
++=======
+ 	uobj_put_destroy(uobj);
+ 
+ 	return uverbs_response(attrs, &resp, sizeof(resp));
++>>>>>>> 9a0738575f26 (RDMA/uverbs: Use uverbs_response() for remaining response copying)
  }
  
 -static int create_qp(struct uverbs_attr_bundle *attrs,
 -		     struct ib_uverbs_ex_create_qp *cmd, size_t cmd_sz)
 +static int create_qp(struct ib_uverbs_file *file,
 +		     struct ib_udata *ucore,
 +		     struct ib_udata *uhw,
 +		     struct ib_uverbs_ex_create_qp *cmd,
 +		     size_t cmd_sz,
 +		     int (*cb)(struct ib_uverbs_file *file,
 +			       struct ib_uverbs_ex_create_qp_resp *resp,
 +			       struct ib_udata *udata),
 +		     void *context)
  {
  	struct ib_uqp_object		*obj;
  	struct ib_device		*device;
@@@ -2197,25 -1955,12 +2212,29 @@@ ssize_t ib_uverbs_destroy_qp(struct ib_
  		return PTR_ERR(uobj);
  
  	obj = container_of(uobj, struct ib_uqp_object, uevent.uobject);
 -	memset(&resp, 0, sizeof(resp));
 +	/*
 +	 * Make sure we don't free the memory in remove_commit as we still
 +	 * needs the uobject memory to create the response.
 +	 */
 +	uverbs_uobject_get(uobj);
 +
 +	ret = uobj_remove_commit(uobj);
 +	if (ret) {
 +		uverbs_uobject_put(uobj);
 +		return ret;
 +	}
 +
  	resp.events_reported = obj->uevent.events_reported;
 +	uverbs_uobject_put(uobj);
  
 -	uobj_put_destroy(uobj);
++<<<<<<< HEAD
 +	if (copy_to_user(u64_to_user_ptr(cmd.response), &resp, sizeof resp))
 +		return -EFAULT;
  
 +	return in_len;
++=======
+ 	return uverbs_response(attrs, &resp, sizeof(resp));
++>>>>>>> 9a0738575f26 (RDMA/uverbs: Use uverbs_response() for remaining response copying)
  }
  
  static void *alloc_wr(size_t wr_size, __u32 num_sge)
@@@ -2515,9 -2258,10 +2535,9 @@@ ssize_t ib_uverbs_post_recv(struct ib_u
  {
  	struct ib_uverbs_post_recv      cmd;
  	struct ib_uverbs_post_recv_resp resp;
 -	struct ib_recv_wr              *wr, *next;
 -	const struct ib_recv_wr	       *bad_wr;
 +	struct ib_recv_wr              *wr, *next, *bad_wr;
  	struct ib_qp                   *qp;
- 	ssize_t                         ret = -EINVAL;
+ 	int ret, ret2;
  
  	if (copy_from_user(&cmd, buf, sizeof cmd))
  		return -EFAULT;
@@@ -2528,9 -2272,11 +2548,16 @@@
  	if (IS_ERR(wr))
  		return PTR_ERR(wr);
  
++<<<<<<< HEAD
 +	qp = uobj_get_obj_read(qp, UVERBS_OBJECT_QP, cmd.qp_handle, file->ucontext);
 +	if (!qp)
++=======
+ 	qp = uobj_get_obj_read(qp, UVERBS_OBJECT_QP, cmd.qp_handle, attrs);
+ 	if (!qp) {
+ 		ret = -EINVAL;
++>>>>>>> 9a0738575f26 (RDMA/uverbs: Use uverbs_response() for remaining response copying)
  		goto out;
+ 	}
  
  	resp.bad_wr = 0;
  	ret = qp->device->post_recv(qp->real_qp, wr, &bad_wr);
@@@ -2564,9 -2309,10 +2591,9 @@@ ssize_t ib_uverbs_post_srq_recv(struct 
  {
  	struct ib_uverbs_post_srq_recv      cmd;
  	struct ib_uverbs_post_srq_recv_resp resp;
 -	struct ib_recv_wr                  *wr, *next;
 -	const struct ib_recv_wr		   *bad_wr;
 +	struct ib_recv_wr                  *wr, *next, *bad_wr;
  	struct ib_srq                      *srq;
- 	ssize_t                             ret = -EINVAL;
+ 	int ret, ret2;
  
  	if (copy_from_user(&cmd, buf, sizeof cmd))
  		return -EFAULT;
@@@ -2577,13 -2323,14 +2604,20 @@@
  	if (IS_ERR(wr))
  		return PTR_ERR(wr);
  
++<<<<<<< HEAD
 +	srq = uobj_get_obj_read(srq, UVERBS_OBJECT_SRQ, cmd.srq_handle, file->ucontext);
 +	if (!srq)
++=======
+ 	srq = uobj_get_obj_read(srq, UVERBS_OBJECT_SRQ, cmd.srq_handle, attrs);
+ 	if (!srq) {
+ 		ret = -EINVAL;
++>>>>>>> 9a0738575f26 (RDMA/uverbs: Use uverbs_response() for remaining response copying)
  		goto out;
+ 	}
  
  	resp.bad_wr = 0;
 -	ret = srq->device->post_srq_recv(srq, wr, &bad_wr);
 +	ret = srq->device->post_srq_recv ?
 +		srq->device->post_srq_recv(srq, wr, &bad_wr) : -EOPNOTSUPP;
  
  	uobj_put_obj_read(srq);
  
@@@ -2675,15 -2415,12 +2710,14 @@@ ssize_t ib_uverbs_create_ah(struct ib_u
  
  	resp.ah_handle = uobj->id;
  
- 	if (copy_to_user(u64_to_user_ptr(cmd.response), &resp, sizeof resp)) {
- 		ret = -EFAULT;
+ 	ret = uverbs_response(attrs, &resp, sizeof(resp));
+ 	if (ret)
  		goto err_copy;
- 	}
  
  	uobj_put_obj_read(pd);
 -	return uobj_alloc_commit(uobj);
 +	uobj_alloc_commit(uobj);
 +
 +	return in_len;
  
  err_copy:
  	rdma_destroy_ah(ah);
@@@ -3286,25 -3003,15 +3319,25 @@@ int ib_uverbs_ex_destroy_wq(struct ib_u
  		return PTR_ERR(uobj);
  
  	obj = container_of(uobj, struct ib_uwq_object, uevent.uobject);
 -	resp.events_reported = obj->uevent.events_reported;
 +	/*
 +	 * Make sure we don't free the memory in remove_commit as we still
 +	 * needs the uobject memory to create the response.
 +	 */
 +	uverbs_uobject_get(uobj);
  
 -	uobj_put_destroy(uobj);
 +	ret = uobj_remove_commit(uobj);
 +	resp.events_reported = obj->uevent.events_reported;
 +	uverbs_uobject_put(uobj);
 +	if (ret)
 +		return ret;
  
- 	return ib_copy_to_udata(ucore, &resp, resp.response_length);
+ 	return uverbs_response(attrs, &resp, sizeof(resp));
  }
  
 -static int ib_uverbs_ex_modify_wq(struct uverbs_attr_bundle *attrs,
 -				  struct ib_udata *ucore)
 +int ib_uverbs_ex_modify_wq(struct ib_uverbs_file *file,
 +			   struct ib_device *ib_dev,
 +			   struct ib_udata *ucore,
 +			   struct ib_udata *uhw)
  {
  	struct ib_uverbs_ex_modify_wq cmd = {};
  	struct ib_wq *wq;
@@@ -3995,16 -3632,12 +4024,20 @@@ ssize_t ib_uverbs_query_srq(struct ib_u
  	resp.max_sge   = attr.max_sge;
  	resp.srq_limit = attr.srq_limit;
  
++<<<<<<< HEAD
 +	if (copy_to_user(u64_to_user_ptr(cmd.response), &resp, sizeof resp))
 +		return -EFAULT;
 +
 +	return in_len;
++=======
+ 	return uverbs_response(attrs, &resp, sizeof(resp));
++>>>>>>> 9a0738575f26 (RDMA/uverbs: Use uverbs_response() for remaining response copying)
  }
  
 -static int ib_uverbs_destroy_srq(struct uverbs_attr_bundle *attrs,
 -				 const char __user *buf, int in_len,
 -				 int out_len)
 +ssize_t ib_uverbs_destroy_srq(struct ib_uverbs_file *file,
 +			      struct ib_device *ib_dev,
 +			      const char __user *buf, int in_len,
 +			      int out_len)
  {
  	struct ib_uverbs_destroy_srq      cmd;
  	struct ib_uverbs_destroy_srq_resp resp;
@@@ -4021,31 -3652,16 +4054,38 @@@
  		return PTR_ERR(uobj);
  
  	obj = container_of(uobj, struct ib_uevent_object, uobject);
 +	/*
 +	 * Make sure we don't free the memory in remove_commit as we still
 +	 * needs the uobject memory to create the response.
 +	 */
 +	uverbs_uobject_get(uobj);
 +
  	memset(&resp, 0, sizeof(resp));
 +
 +	ret = uobj_remove_commit(uobj);
 +	if (ret) {
 +		uverbs_uobject_put(uobj);
 +		return ret;
 +	}
  	resp.events_reported = obj->events_reported;
++<<<<<<< HEAD
 +	uverbs_uobject_put(uobj);
 +	if (copy_to_user(u64_to_user_ptr(cmd.response), &resp, sizeof(resp)))
 +		return -EFAULT;
 +
 +	return in_len;
++=======
+ 
+ 	uobj_put_destroy(uobj);
+ 
+ 	return uverbs_response(attrs, &resp, sizeof(resp));
++>>>>>>> 9a0738575f26 (RDMA/uverbs: Use uverbs_response() for remaining response copying)
  }
  
 -static int ib_uverbs_ex_query_device(struct uverbs_attr_bundle *attrs,
 -				     struct ib_udata *ucore)
 +int ib_uverbs_ex_query_device(struct ib_uverbs_file *file,
 +			      struct ib_device *ib_dev,
 +			      struct ib_udata *ucore,
 +			      struct ib_udata *uhw)
  {
  	struct ib_uverbs_ex_query_device_resp resp = { {0} };
  	struct ib_uverbs_ex_query_device  cmd;
@@@ -4159,14 -3779,11 +4199,13 @@@
  	resp.max_dm_size = attr.max_dm_size;
  	resp.response_length += sizeof(resp.max_dm_size);
  end:
- 	err = ib_copy_to_udata(ucore, &resp, resp.response_length);
- 	return err;
+ 	return uverbs_response(attrs, &resp, sizeof(resp));
  }
  
 -static int ib_uverbs_ex_modify_cq(struct uverbs_attr_bundle *attrs,
 -				  struct ib_udata *ucore)
 +int ib_uverbs_ex_modify_cq(struct ib_uverbs_file *file,
 +			   struct ib_device *ib_dev,
 +			   struct ib_udata *ucore,
 +			   struct ib_udata *uhw)
  {
  	struct ib_uverbs_ex_modify_cq cmd = {};
  	struct ib_cq *cq;
* Unmerged path drivers/infiniband/core/uverbs_cmd.c
