bpf: fix segfault in test_verifier selftest

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Daniel Borkmann <daniel@iogearbox.net>
commit 7fa4bd739fc0fa209fa5120383aab17f6e9600f7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/7fa4bd73.failed

Minor fallout from merge resolution, test_verifier was segfaulting
because the REJECT result was correct, but errstr was NULL. Properly
fix it as in 339bbff2d6e0.

Fixes: 339bbff2d6e0 ("Merge git://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf-next")
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7fa4bd739fc0fa209fa5120383aab17f6e9600f7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/bpf/test_verifier.c
diff --cc tools/testing/selftests/bpf/test_verifier.c
index 4817cd00d5ac,33f7d38849b8..000000000000
--- a/tools/testing/selftests/bpf/test_verifier.c
+++ b/tools/testing/selftests/bpf/test_verifier.c
@@@ -14124,9 -14194,103 +14124,109 @@@ static struct bpf_test tests[] = 
  		},
  		.prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
  		.errstr_unpriv = "function calls to other bpf functions are allowed for root only",
++<<<<<<< HEAD
 +		.result_unpriv = REJECT,
 +		.errstr = "!read_ok",
 +		.result = REJECT,
++=======
+ 		.errstr = "!read_ok",
+ 		.result = REJECT,
+ 	},
+ 	{
+ 		"jset: functional",
+ 		.insns = {
+ 			/* r0 = 0 */
+ 			BPF_MOV64_IMM(BPF_REG_0, 0),
+ 			/* prep for direct packet access via r2 */
+ 			BPF_LDX_MEM(BPF_W, BPF_REG_2, BPF_REG_1,
+ 				    offsetof(struct __sk_buff, data)),
+ 			BPF_LDX_MEM(BPF_W, BPF_REG_3, BPF_REG_1,
+ 				    offsetof(struct __sk_buff, data_end)),
+ 			BPF_MOV64_REG(BPF_REG_4, BPF_REG_2),
+ 			BPF_ALU64_IMM(BPF_ADD, BPF_REG_4, 8),
+ 			BPF_JMP_REG(BPF_JLE, BPF_REG_4, BPF_REG_3, 1),
+ 			BPF_EXIT_INSN(),
+ 
+ 			BPF_LDX_MEM(BPF_DW, BPF_REG_7, BPF_REG_2, 0),
+ 
+ 			/* reg, bit 63 or bit 0 set, taken */
+ 			BPF_LD_IMM64(BPF_REG_8, 0x8000000000000001),
+ 			BPF_JMP_REG(BPF_JSET, BPF_REG_7, BPF_REG_8, 1),
+ 			BPF_EXIT_INSN(),
+ 
+ 			/* reg, bit 62, not taken */
+ 			BPF_LD_IMM64(BPF_REG_8, 0x4000000000000000),
+ 			BPF_JMP_REG(BPF_JSET, BPF_REG_7, BPF_REG_8, 1),
+ 			BPF_JMP_IMM(BPF_JA, 0, 0, 1),
+ 			BPF_EXIT_INSN(),
+ 
+ 			/* imm, any bit set, taken */
+ 			BPF_JMP_IMM(BPF_JSET, BPF_REG_7, -1, 1),
+ 			BPF_EXIT_INSN(),
+ 
+ 			/* imm, bit 31 set, taken */
+ 			BPF_JMP_IMM(BPF_JSET, BPF_REG_7, 0x80000000, 1),
+ 			BPF_EXIT_INSN(),
+ 
+ 			/* all good - return r0 == 2 */
+ 			BPF_MOV64_IMM(BPF_REG_0, 2),
+ 			BPF_EXIT_INSN(),
+ 		},
+ 		.prog_type = BPF_PROG_TYPE_SCHED_CLS,
+ 		.result = ACCEPT,
+ 		.runs = 7,
+ 		.retvals = {
+ 			{ .retval = 2,
+ 			  .data64 = { (1ULL << 63) | (1U << 31) | (1U << 0), }
+ 			},
+ 			{ .retval = 2,
+ 			  .data64 = { (1ULL << 63) | (1U << 31), }
+ 			},
+ 			{ .retval = 2,
+ 			  .data64 = { (1ULL << 31) | (1U << 0), }
+ 			},
+ 			{ .retval = 2,
+ 			  .data64 = { (__u32)-1, }
+ 			},
+ 			{ .retval = 2,
+ 			  .data64 = { ~0x4000000000000000ULL, }
+ 			},
+ 			{ .retval = 0,
+ 			  .data64 = { 0, }
+ 			},
+ 			{ .retval = 0,
+ 			  .data64 = { ~0ULL, }
+ 			},
+ 		},
+ 	},
+ 	{
+ 		"jset: sign-extend",
+ 		.insns = {
+ 			/* r0 = 0 */
+ 			BPF_MOV64_IMM(BPF_REG_0, 0),
+ 			/* prep for direct packet access via r2 */
+ 			BPF_LDX_MEM(BPF_W, BPF_REG_2, BPF_REG_1,
+ 				    offsetof(struct __sk_buff, data)),
+ 			BPF_LDX_MEM(BPF_W, BPF_REG_3, BPF_REG_1,
+ 				    offsetof(struct __sk_buff, data_end)),
+ 			BPF_MOV64_REG(BPF_REG_4, BPF_REG_2),
+ 			BPF_ALU64_IMM(BPF_ADD, BPF_REG_4, 8),
+ 			BPF_JMP_REG(BPF_JLE, BPF_REG_4, BPF_REG_3, 1),
+ 			BPF_EXIT_INSN(),
+ 
+ 			BPF_LDX_MEM(BPF_DW, BPF_REG_7, BPF_REG_2, 0),
+ 
+ 			BPF_JMP_IMM(BPF_JSET, BPF_REG_7, 0x80000000, 1),
+ 			BPF_EXIT_INSN(),
+ 
+ 			BPF_MOV64_IMM(BPF_REG_0, 2),
+ 			BPF_EXIT_INSN(),
+ 		},
+ 		.prog_type = BPF_PROG_TYPE_SCHED_CLS,
+ 		.result = ACCEPT,
+ 		.retval = 2,
+ 		.data = { 1, 0, 0, 0, 0, 0, 0, 1, },
++>>>>>>> 7fa4bd739fc0 (bpf: fix segfault in test_verifier selftest)
  	},
  	{
  		"jset: known const compare",
* Unmerged path tools/testing/selftests/bpf/test_verifier.c
