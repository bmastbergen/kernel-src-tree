arm64: cpufeature: Trap CTR_EL0 access only where it is necessary

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Suzuki K Poulose <suzuki.poulose@arm.com>
commit 4afe8e79da920bdf6698b01bc668fffc6758f37b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/4afe8e79.failed

When there is a mismatch in the CTR_EL0 field, we trap
access to CTR from EL0 on all CPUs to expose the safe
value. However, we could skip trapping on a CPU which
matches the safe value.

	Cc: Mark Rutland <mark.rutland@arm.com>
	Cc: Will Deacon <will.deacon@arm.com>
	Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
	Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
(cherry picked from commit 4afe8e79da920bdf6698b01bc668fffc6758f37b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kernel/cpu_errata.c
diff --cc arch/arm64/kernel/cpu_errata.c
index fde6f87a8b7e,9af8df96ec49..000000000000
--- a/arch/arm64/kernel/cpu_errata.c
+++ b/arch/arm64/kernel/cpu_errata.c
@@@ -78,8 -99,12 +78,17 @@@ has_mismatched_cache_line_size(const st
  static void
  cpu_enable_trap_ctr_access(const struct arm64_cpu_capabilities *__unused)
  {
++<<<<<<< HEAD
 +	/* Clear SCTLR_EL1.UCT */
 +	config_sctlr_el1(SCTLR_EL1_UCT, 0);
++=======
+ 	u64 mask = arm64_ftr_reg_ctrel0.strict_mask;
+ 
+ 	/* Trap CTR_EL0 access on this CPU, only if it has a mismatch */
+ 	if ((read_cpuid_cachetype() & mask) !=
+ 	    (arm64_ftr_reg_ctrel0.sys_val & mask))
+ 		sysreg_clear_set(sctlr_el1, SCTLR_EL1_UCT, 0);
++>>>>>>> 4afe8e79da92 (arm64: cpufeature: Trap CTR_EL0 access only where it is necessary)
  }
  
  atomic_t arm64_el2_vector_last_slot = ATOMIC_INIT(-1);
* Unmerged path arch/arm64/kernel/cpu_errata.c
