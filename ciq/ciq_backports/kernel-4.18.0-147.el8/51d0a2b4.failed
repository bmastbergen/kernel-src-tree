IB/uverbs: Remove struct uverbs_root_spec and all supporting code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jason Gunthorpe <jgg@ziepe.ca>
commit 51d0a2b4cfa9979fd8a59faf483b4e84587ab4ea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/51d0a2b4.failed

Everything now uses the uverbs_uapi data structure.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 51d0a2b4cfa9979fd8a59faf483b4e84587ab4ea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/rdma_core.c
#	drivers/infiniband/core/rdma_core.h
#	drivers/infiniband/core/uverbs.h
#	drivers/infiniband/core/uverbs_ioctl_merge.c
#	drivers/infiniband/core/uverbs_main.c
#	include/rdma/uverbs_ioctl.h
diff --cc drivers/infiniband/core/rdma_core.c
index 7abca5514e4d,12e7c6c102c1..000000000000
--- a/drivers/infiniband/core/rdma_core.c
+++ b/drivers/infiniband/core/rdma_core.c
@@@ -41,51 -42,6 +41,54 @@@
  #include "core_priv.h"
  #include "rdma_core.h"
  
++<<<<<<< HEAD
 +int uverbs_ns_idx(u16 *id, unsigned int ns_count)
 +{
 +	int ret = (*id & UVERBS_ID_NS_MASK) >> UVERBS_ID_NS_SHIFT;
 +
 +	if (ret >= ns_count)
 +		return -EINVAL;
 +
 +	*id &= ~UVERBS_ID_NS_MASK;
 +	return ret;
 +}
 +
 +const struct uverbs_object_spec *uverbs_get_object(const struct ib_device *ibdev,
 +						   uint16_t object)
 +{
 +	const struct uverbs_root_spec *object_hash = ibdev->specs_root;
 +	const struct uverbs_object_spec_hash *objects;
 +	int ret = uverbs_ns_idx(&object, object_hash->num_buckets);
 +
 +	if (ret < 0)
 +		return NULL;
 +
 +	objects = object_hash->object_buckets[ret];
 +
 +	if (object >= objects->num_objects)
 +		return NULL;
 +
 +	return objects->objects[object];
 +}
 +
 +const struct uverbs_method_spec *uverbs_get_method(const struct uverbs_object_spec *object,
 +						   uint16_t method)
 +{
 +	const struct uverbs_method_spec_hash *methods;
 +	int ret = uverbs_ns_idx(&method, object->num_buckets);
 +
 +	if (ret < 0)
 +		return NULL;
 +
 +	methods = object->method_buckets[ret];
 +	if (method >= methods->num_methods)
 +		return NULL;
 +
 +	return methods->methods[method];
 +}
 +
++=======
++>>>>>>> 51d0a2b4cfa9 (IB/uverbs: Remove struct uverbs_root_spec and all supporting code)
  void uverbs_uobject_get(struct ib_uobject *uobject)
  {
  	kref_get(&uobject->ref);
diff --cc drivers/infiniband/core/rdma_core.h
index a243cc2a59f7,f962f2a593ba..000000000000
--- a/drivers/infiniband/core/rdma_core.h
+++ b/drivers/infiniband/core/rdma_core.h
@@@ -43,20 -43,12 +43,29 @@@
  #include <rdma/ib_verbs.h>
  #include <linux/mutex.h>
  
++<<<<<<< HEAD
 +int uverbs_ns_idx(u16 *id, unsigned int ns_count);
 +const struct uverbs_object_spec *uverbs_get_object(const struct ib_device *ibdev,
 +						   uint16_t object);
 +const struct uverbs_method_spec *uverbs_get_method(const struct uverbs_object_spec *object,
 +						   uint16_t method);
 +/*
 + * These functions initialize the context and cleanups its uobjects.
 + * The context has a list of objects which is protected by a mutex
 + * on the context. initialize_ucontext should be called when we create
 + * a context.
 + * cleanup_ucontext removes all uobjects from the context and puts them.
 + */
 +void uverbs_cleanup_ucontext(struct ib_ucontext *ucontext, bool device_removed);
 +void uverbs_initialize_ucontext(struct ib_ucontext *ucontext);
++=======
+ struct ib_uverbs_device;
+ 
+ void uverbs_destroy_ufile_hw(struct ib_uverbs_file *ufile,
+ 			     enum rdma_remove_reason reason);
+ 
+ int uobj_destroy(struct ib_uobject *uobj);
++>>>>>>> 51d0a2b4cfa9 (IB/uverbs: Remove struct uverbs_root_spec and all supporting code)
  
  /*
   * uverbs_uobject_get is called in order to increase the reference count on
diff --cc drivers/infiniband/core/uverbs.h
index 6700adb08a26,5df8e548cc14..000000000000
--- a/drivers/infiniband/core/uverbs.h
+++ b/drivers/infiniband/core/uverbs.h
@@@ -111,7 -111,7 +111,11 @@@ struct ib_uverbs_device 
  	struct mutex				lists_mutex; /* protect lists */
  	struct list_head			uverbs_file_list;
  	struct list_head			uverbs_events_file_list;
++<<<<<<< HEAD
 +	struct uverbs_root_spec			*specs_root;
++=======
+ 	struct uverbs_api			*uapi;
++>>>>>>> 51d0a2b4cfa9 (IB/uverbs: Remove struct uverbs_root_spec and all supporting code)
  };
  
  struct ib_uverbs_event_queue {
diff --cc drivers/infiniband/core/uverbs_main.c
index f24a6ab4cbde,823beca448e1..000000000000
--- a/drivers/infiniband/core/uverbs_main.c
+++ b/drivers/infiniband/core/uverbs_main.c
@@@ -1005,6 -994,19 +1005,22 @@@ static DEVICE_ATTR(abi_version, S_IRUGO
  static CLASS_ATTR_STRING(abi_version, S_IRUGO,
  			 __stringify(IB_USER_VERBS_ABI_VERSION));
  
++<<<<<<< HEAD
++=======
+ static int ib_uverbs_create_uapi(struct ib_device *device,
+ 				 struct ib_uverbs_device *uverbs_dev)
+ {
+ 	struct uverbs_api *uapi;
+ 
+ 	uapi = uverbs_alloc_api(device->driver_specs, device->driver_id);
+ 	if (IS_ERR(uapi))
+ 		return PTR_ERR(uapi);
+ 
+ 	uverbs_dev->uapi = uapi;
+ 	return 0;
+ }
+ 
++>>>>>>> 51d0a2b4cfa9 (IB/uverbs: Remove struct uverbs_root_spec and all supporting code)
  static void ib_uverbs_add_one(struct ib_device *device)
  {
  	int devnum;
diff --cc include/rdma/uverbs_ioctl.h
index 90a4947ff548,9e997c3c2f04..000000000000
--- a/include/rdma/uverbs_ioctl.h
+++ b/include/rdma/uverbs_ioctl.h
@@@ -110,59 -109,148 +110,62 @@@ struct uverbs_attr_spec 
  			 * contained in the ids array. Currently only PTR_IN
  			 * attributes are supported in the ids array.
  			 */
 -			const struct uverbs_attr_spec *ids;
 +			const struct uverbs_attr_spec	*ids;
  		} enum_def;
 -	} u2;
 +	};
  };
  
 -/*
 - * Information about the API is loaded into a radix tree. For IOCTL we start
 - * with a tuple of:
 - *  object_id, attr_id, method_id
 - *
 - * Which is a 48 bit value, with most of the bits guaranteed to be zero. Based
 - * on the current kernel support this is compressed into 16 bit key for the
 - * radix tree. Since this compression is entirely internal to the kernel the
 - * below limits can be revised if the kernel gains additional data.
 - *
 - * With 64 leafs per node this is a 3 level radix tree.
 - *
 - * The tree encodes multiple types, and uses a scheme where OBJ_ID,0,0 returns
 - * the object slot, and OBJ_ID,METH_ID,0 and returns the method slot.
 - */
 -enum uapi_radix_data {
 -	UVERBS_API_NS_FLAG = 1U << UVERBS_ID_NS_SHIFT,
 -
 -	UVERBS_API_ATTR_KEY_BITS = 6,
 -	UVERBS_API_ATTR_KEY_MASK = GENMASK(UVERBS_API_ATTR_KEY_BITS - 1, 0),
 -	UVERBS_API_ATTR_BKEY_LEN = (1 << UVERBS_API_ATTR_KEY_BITS) - 1,
 -
 -	UVERBS_API_METHOD_KEY_BITS = 5,
 -	UVERBS_API_METHOD_KEY_SHIFT = UVERBS_API_ATTR_KEY_BITS,
 -	UVERBS_API_METHOD_KEY_NUM_CORE = 24,
 -	UVERBS_API_METHOD_KEY_NUM_DRIVER = (1 << UVERBS_API_METHOD_KEY_BITS) -
 -					   UVERBS_API_METHOD_KEY_NUM_CORE,
 -	UVERBS_API_METHOD_KEY_MASK = GENMASK(
 -		UVERBS_API_METHOD_KEY_BITS + UVERBS_API_METHOD_KEY_SHIFT - 1,
 -		UVERBS_API_METHOD_KEY_SHIFT),
 -
 -	UVERBS_API_OBJ_KEY_BITS = 5,
 -	UVERBS_API_OBJ_KEY_SHIFT =
 -		UVERBS_API_METHOD_KEY_BITS + UVERBS_API_METHOD_KEY_SHIFT,
 -	UVERBS_API_OBJ_KEY_NUM_CORE = 24,
 -	UVERBS_API_OBJ_KEY_NUM_DRIVER =
 -		(1 << UVERBS_API_OBJ_KEY_BITS) - UVERBS_API_OBJ_KEY_NUM_CORE,
 -	UVERBS_API_OBJ_KEY_MASK = GENMASK(31, UVERBS_API_OBJ_KEY_SHIFT),
 -
 -	/* This id guaranteed to not exist in the radix tree */
 -	UVERBS_API_KEY_ERR = 0xFFFFFFFF,
++<<<<<<< HEAD
 +struct uverbs_attr_spec_hash {
 +	size_t				num_attrs;
 +	unsigned long			*mandatory_attrs_bitmask;
 +	struct uverbs_attr_spec		attrs[0];
  };
  
 -static inline __attribute_const__ u32 uapi_key_obj(u32 id)
 -{
 -	if (id & UVERBS_API_NS_FLAG) {
 -		id &= ~UVERBS_API_NS_FLAG;
 -		if (id >= UVERBS_API_OBJ_KEY_NUM_DRIVER)
 -			return UVERBS_API_KEY_ERR;
 -		id = id + UVERBS_API_OBJ_KEY_NUM_CORE;
 -	} else {
 -		if (id >= UVERBS_API_OBJ_KEY_NUM_CORE)
 -			return UVERBS_API_KEY_ERR;
 -	}
 -
 -	return id << UVERBS_API_OBJ_KEY_SHIFT;
 -}
 -
 -static inline __attribute_const__ bool uapi_key_is_object(u32 key)
 -{
 -	return (key & ~UVERBS_API_OBJ_KEY_MASK) == 0;
 -}
 +struct uverbs_attr_bundle;
 +struct ib_uverbs_file;
  
 -static inline __attribute_const__ u32 uapi_key_ioctl_method(u32 id)
 -{
 -	if (id & UVERBS_API_NS_FLAG) {
 -		id &= ~UVERBS_API_NS_FLAG;
 -		if (id >= UVERBS_API_METHOD_KEY_NUM_DRIVER)
 -			return UVERBS_API_KEY_ERR;
 -		id = id + UVERBS_API_METHOD_KEY_NUM_CORE;
 -	} else {
 -		id++;
 -		if (id >= UVERBS_API_METHOD_KEY_NUM_CORE)
 -			return UVERBS_API_KEY_ERR;
 -	}
 -
 -	return id << UVERBS_API_METHOD_KEY_SHIFT;
 -}
 -
 -static inline __attribute_const__ u32 uapi_key_attr_to_method(u32 attr_key)
 -{
 -	return attr_key &
 -	       (UVERBS_API_OBJ_KEY_MASK | UVERBS_API_METHOD_KEY_MASK);
 -}
 -
 -static inline __attribute_const__ bool uapi_key_is_ioctl_method(u32 key)
 -{
 -	return (key & UVERBS_API_METHOD_KEY_MASK) != 0 &&
 -	       (key & UVERBS_API_ATTR_KEY_MASK) == 0;
 -}
 -
 -static inline __attribute_const__ u32 uapi_key_attrs_start(u32 ioctl_method_key)
 -{
 -	/* 0 is the method slot itself */
 -	return ioctl_method_key + 1;
 -}
 -
 -static inline __attribute_const__ u32 uapi_key_attr(u32 id)
 -{
 +enum {
  	/*
 -	 * The attr is designed to fit in the typical single radix tree node
 -	 * of 64 entries. Since allmost all methods have driver attributes we
 -	 * organize things so that the driver and core attributes interleave to
 -	 * reduce the length of the attributes array in typical cases.
 +	 * Action marked with this flag creates a context (or root for all
 +	 * objects).
  	 */
 -	if (id & UVERBS_API_NS_FLAG) {
 -		id &= ~UVERBS_API_NS_FLAG;
 -		id++;
 -		if (id >= 1 << (UVERBS_API_ATTR_KEY_BITS - 1))
 -			return UVERBS_API_KEY_ERR;
 -		id = (id << 1) | 0;
 -	} else {
 -		if (id >= 1 << (UVERBS_API_ATTR_KEY_BITS - 1))
 -			return UVERBS_API_KEY_ERR;
 -		id = (id << 1) | 1;
 -	}
 +	UVERBS_ACTION_FLAG_CREATE_ROOT = 1U << 0,
 +};
  
 -	return id;
 -}
 +struct uverbs_method_spec {
 +	/* Combination of bits from enum UVERBS_ACTION_FLAG_XXXX */
 +	u32						flags;
 +	size_t						num_buckets;
 +	size_t						num_child_attrs;
 +	int (*handler)(struct ib_device *ib_dev, struct ib_uverbs_file *ufile,
 +		       struct uverbs_attr_bundle *ctx);
 +	struct uverbs_attr_spec_hash		*attr_buckets[0];
 +};
  
 -static inline __attribute_const__ bool uapi_key_is_attr(u32 key)
 -{
 -	return (key & UVERBS_API_METHOD_KEY_MASK) != 0 &&
 -	       (key & UVERBS_API_ATTR_KEY_MASK) != 0;
 -}
 +struct uverbs_method_spec_hash {
 +	size_t					num_methods;
 +	struct uverbs_method_spec		*methods[0];
 +};
  
 -/*
 - * This returns a value in the range [0 to UVERBS_API_ATTR_BKEY_LEN),
 - * basically it undoes the reservation of 0 in the ID numbering. attr_key
 - * must already be masked with UVERBS_API_ATTR_KEY_MASK, or be the output of
 - * uapi_key_attr().
 - */
 -static inline __attribute_const__ u32 uapi_bkey_attr(u32 attr_key)
 -{
 -	return attr_key - 1;
 -}
 +struct uverbs_object_spec {
 +	const struct uverbs_obj_type		*type_attrs;
 +	size_t					num_buckets;
 +	struct uverbs_method_spec_hash		*method_buckets[0];
 +};
 +
 +struct uverbs_object_spec_hash {
 +	size_t					num_objects;
 +	struct uverbs_object_spec		*objects[0];
 +};
  
 +struct uverbs_root_spec {
 +	size_t					num_buckets;
 +	struct uverbs_object_spec_hash		*object_buckets[0];
 +};
 +
++=======
++>>>>>>> 51d0a2b4cfa9 (IB/uverbs: Remove struct uverbs_root_spec and all supporting code)
  /*
   * =======================================
   *	Verbs definitions
@@@ -547,54 -582,54 +550,105 @@@ static inline int _uverbs_copy_from_or_
  #define uverbs_copy_from_or_zero(to, attrs_bundle, idx)			      \
  	_uverbs_copy_from_or_zero(to, attrs_bundle, idx, sizeof(*to))
  
++<<<<<<< HEAD
 +/* =================================================
 + *	 Definitions -> Specs infrastructure
 + * =================================================
 + */
 +
 +/*
 + * uverbs_alloc_spec_tree - Merges different common and driver specific feature
 + *	into one parsing tree that every uverbs command will be parsed upon.
 + *
 + * @num_trees: Number of trees in the array @trees.
 + * @trees: Array of pointers to tree root definitions to merge. Each such tree
 + *	   possibly contains objects, methods and attributes definitions.
 + *
 + * Returns:
 + *	uverbs_root_spec *: The root of the merged parsing tree.
 + *	On error, we return an error code. Error is checked via IS_ERR.
 + *
 + * The following merges could take place:
 + * a. Two trees representing the same method with different handler
 + *	-> We take the handler of the tree that its handler != NULL
 + *	   and its index in the trees array is greater. The incentive for that
 + *	   is that developers are expected to first merge common trees and then
 + *	   merge trees that gives specialized the behaviour.
 + * b. Two trees representing the same object with different
 + *    type_attrs (struct uverbs_obj_type):
 + *	-> We take the type_attrs of the tree that its type_attr != NULL
 + *	   and its index in the trees array is greater. This could be used
 + *	   in order to override the free function, allocation size, etc.
 + * c. Two trees representing the same method attribute (same id but possibly
 + *    different attributes):
 + *	-> ERROR (-ENOENT), we believe that's not the programmer's intent.
 + *
 + * An object without any methods is considered invalid and will abort the
 + * function with -ENOENT error.
 + */
 +#if IS_ENABLED(CONFIG_INFINIBAND_USER_ACCESS)
 +struct uverbs_root_spec *uverbs_alloc_spec_tree(unsigned int num_trees,
 +						const struct uverbs_object_tree_def **trees);
 +void uverbs_free_spec_tree(struct uverbs_root_spec *root);
 +#else
 +static inline struct uverbs_root_spec *uverbs_alloc_spec_tree(unsigned int num_trees,
 +							      const struct uverbs_object_tree_def **trees)
 +{
 +	return NULL;
 +}
 +
 +static inline void uverbs_free_spec_tree(struct uverbs_root_spec *root)
 +{
++=======
+ #if IS_ENABLED(CONFIG_INFINIBAND_USER_ACCESS)
+ int uverbs_get_flags64(u64 *to, const struct uverbs_attr_bundle *attrs_bundle,
+ 		       size_t idx, u64 allowed_bits);
+ int uverbs_get_flags32(u32 *to, const struct uverbs_attr_bundle *attrs_bundle,
+ 		       size_t idx, u64 allowed_bits);
+ int uverbs_copy_to(const struct uverbs_attr_bundle *attrs_bundle, size_t idx,
+ 		   const void *from, size_t size);
+ __malloc void *_uverbs_alloc(struct uverbs_attr_bundle *bundle, size_t size,
+ 			     gfp_t flags);
+ 
+ static inline __malloc void *uverbs_alloc(struct uverbs_attr_bundle *bundle,
+ 					  size_t size)
+ {
+ 	return _uverbs_alloc(bundle, size, GFP_KERNEL);
+ }
+ 
+ static inline __malloc void *uverbs_zalloc(struct uverbs_attr_bundle *bundle,
+ 					   size_t size)
+ {
+ 	return _uverbs_alloc(bundle, size, GFP_KERNEL | __GFP_ZERO);
+ }
+ #else
+ static inline int
+ uverbs_get_flags64(u64 *to, const struct uverbs_attr_bundle *attrs_bundle,
+ 		   size_t idx, u64 allowed_bits)
+ {
+ 	return -EINVAL;
+ }
+ static inline int
+ uverbs_get_flags32(u32 *to, const struct uverbs_attr_bundle *attrs_bundle,
+ 		   size_t idx, u64 allowed_bits)
+ {
+ 	return -EINVAL;
+ }
+ static inline int uverbs_copy_to(const struct uverbs_attr_bundle *attrs_bundle,
+ 				 size_t idx, const void *from, size_t size)
+ {
+ 	return -EINVAL;
+ }
+ static inline __malloc void *uverbs_alloc(struct uverbs_attr_bundle *bundle,
+ 					  size_t size)
+ {
+ 	return ERR_PTR(-EINVAL);
+ }
+ static inline __malloc void *uverbs_zalloc(struct uverbs_attr_bundle *bundle,
+ 					   size_t size)
+ {
+ 	return ERR_PTR(-EINVAL);
++>>>>>>> 51d0a2b4cfa9 (IB/uverbs: Remove struct uverbs_root_spec and all supporting code)
  }
  #endif
  
* Unmerged path drivers/infiniband/core/uverbs_ioctl_merge.c
diff --git a/drivers/infiniband/core/Makefile b/drivers/infiniband/core/Makefile
index 61667705d746..53c33ff15939 100644
--- a/drivers/infiniband/core/Makefile
+++ b/drivers/infiniband/core/Makefile
@@ -35,6 +35,6 @@ ib_ucm-y :=			ucm.o
 
 ib_uverbs-y :=			uverbs_main.o uverbs_cmd.o uverbs_marshall.o \
 				rdma_core.o uverbs_std_types.o uverbs_ioctl.o \
-				uverbs_ioctl_merge.o uverbs_std_types_cq.o \
+				uverbs_std_types_cq.o \
 				uverbs_std_types_flow_action.o uverbs_std_types_dm.o \
 				uverbs_std_types_mr.o uverbs_std_types_counters.o
* Unmerged path drivers/infiniband/core/rdma_core.c
* Unmerged path drivers/infiniband/core/rdma_core.h
* Unmerged path drivers/infiniband/core/uverbs.h
* Unmerged path drivers/infiniband/core/uverbs_ioctl_merge.c
* Unmerged path drivers/infiniband/core/uverbs_main.c
* Unmerged path include/rdma/uverbs_ioctl.h
