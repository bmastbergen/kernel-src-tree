tcp: tcp_fragment() should apply sane memory limits

jira LE-1907
cve CVE-2019-11478
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Eric Dumazet <edumazet@google.com>
commit f070ef2ac66716357066b683fb0baf55f8191a2e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/f070ef2a.failed

Jonathan Looney reported that a malicious peer can force a sender
to fragment its retransmit queue into tiny skbs, inflating memory
usage and/or overflow 32bit counters.

TCP allows an application to queue up to sk_sndbuf bytes,
so we need to give some allowance for non malicious splitting
of retransmit queue.

A new SNMP counter is added to monitor how many times TCP
did not allow to split an skb if the allowance was exceeded.

Note that this counter might increase in the case applications
use SO_SNDBUF socket option to lower sk_sndbuf.

CVE-2019-11478 : tcp_fragment, prevent fragmenting a packet when the
	socket is already using more than half the allowed space

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Reported-by: Jonathan Looney <jtl@netflix.com>
	Acked-by: Neal Cardwell <ncardwell@google.com>
	Acked-by: Yuchung Cheng <ycheng@google.com>
	Reviewed-by: Tyler Hicks <tyhicks@canonical.com>
	Cc: Bruce Curtis <brucec@netflix.com>
	Cc: Jonathan Lemon <jonathan.lemon@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f070ef2ac66716357066b683fb0baf55f8191a2e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/snmp.h
#	net/ipv4/proc.c
diff --cc include/uapi/linux/snmp.h
index e908dd0f7577,fd42c1316d3d..000000000000
--- a/include/uapi/linux/snmp.h
+++ b/include/uapi/linux/snmp.h
@@@ -280,6 -281,9 +280,12 @@@ enu
  	LINUX_MIB_TCPDELIVERED,			/* TCPDelivered */
  	LINUX_MIB_TCPDELIVEREDCE,		/* TCPDeliveredCE */
  	LINUX_MIB_TCPACKCOMPRESSED,		/* TCPAckCompressed */
++<<<<<<< HEAD
++=======
+ 	LINUX_MIB_TCPZEROWINDOWDROP,		/* TCPZeroWindowDrop */
+ 	LINUX_MIB_TCPRCVQDROP,			/* TCPRcvQDrop */
+ 	LINUX_MIB_TCPWQUEUETOOBIG,		/* TCPWqueueTooBig */
++>>>>>>> f070ef2ac667 (tcp: tcp_fragment() should apply sane memory limits)
  	__LINUX_MIB_MAX
  };
  
diff --cc net/ipv4/proc.c
index 2194746cb037,073273b751f8..000000000000
--- a/net/ipv4/proc.c
+++ b/net/ipv4/proc.c
@@@ -288,6 -285,9 +288,12 @@@ static const struct snmp_mib snmp4_net_
  	SNMP_MIB_ITEM("TCPDelivered", LINUX_MIB_TCPDELIVERED),
  	SNMP_MIB_ITEM("TCPDeliveredCE", LINUX_MIB_TCPDELIVEREDCE),
  	SNMP_MIB_ITEM("TCPAckCompressed", LINUX_MIB_TCPACKCOMPRESSED),
++<<<<<<< HEAD
++=======
+ 	SNMP_MIB_ITEM("TCPZeroWindowDrop", LINUX_MIB_TCPZEROWINDOWDROP),
+ 	SNMP_MIB_ITEM("TCPRcvQDrop", LINUX_MIB_TCPRCVQDROP),
+ 	SNMP_MIB_ITEM("TCPWqueueTooBig", LINUX_MIB_TCPWQUEUETOOBIG),
++>>>>>>> f070ef2ac667 (tcp: tcp_fragment() should apply sane memory limits)
  	SNMP_MIB_SENTINEL
  };
  
* Unmerged path include/uapi/linux/snmp.h
* Unmerged path net/ipv4/proc.c
diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c
index beb57383eebd..6a7bdd0eec97 100644
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@ -1312,6 +1312,11 @@ int tcp_fragment(struct sock *sk, enum tcp_queue tcp_queue,
 	if (nsize < 0)
 		nsize = 0;
 
+	if (unlikely((sk->sk_wmem_queued >> 1) > sk->sk_sndbuf)) {
+		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPWQUEUETOOBIG);
+		return -ENOMEM;
+	}
+
 	if (skb_unclone(skb, gfp))
 		return -ENOMEM;
 
