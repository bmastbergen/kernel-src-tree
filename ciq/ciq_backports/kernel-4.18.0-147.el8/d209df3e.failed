netfilter: nf_tables: fix register ordering

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Florian Westphal <fw@strlen.de>
commit d209df3e7f7002d9099fdb0f6df0f972b4386a63
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/d209df3e.failed

We must register nfnetlink ops last, as that exposes nf_tables to
userspace.  Without this, we could theoretically get nfnetlink request
before net->nft state has been initialized.

Fixes: 99633ab29b213 ("netfilter: nf_tables: complete net namespace support")
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit d209df3e7f7002d9099fdb0f6df0f972b4386a63)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
diff --cc net/netfilter/nf_tables_api.c
index 011a9d777a15,80636cc59686..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -7319,38 -7273,36 +7319,67 @@@ static int __init nf_tables_module_init
  {
  	int err;
  
++<<<<<<< HEAD
 +	nft_chain_filter_init();
 +
 +	info = kmalloc_array(NFT_RULE_MAXEXPRS, sizeof(struct nft_expr_info),
 +			     GFP_KERNEL);
 +	if (info == NULL) {
 +		err = -ENOMEM;
 +		goto err1;
 +	}
 +
 +	err = nf_tables_core_module_init();
++=======
+ 	err = register_pernet_subsys(&nf_tables_net_ops);
++>>>>>>> d209df3e7f70 (netfilter: nf_tables: fix register ordering)
  	if (err < 0)
 -		return err;
 +		goto err2;
  
+ 	err = nft_chain_filter_init();
+ 	if (err < 0)
+ 		goto err1;
+ 
+ 	err = nf_tables_core_module_init();
+ 	if (err < 0)
+ 		goto err2;
+ 
+ 	err = register_netdevice_notifier(&nf_tables_flowtable_notifier);
+ 	if (err < 0)
+ 		goto err3;
+ 
+ 	/* must be last */
  	err = nfnetlink_subsys_register(&nf_tables_subsys);
 +	if (err < 0)
++<<<<<<< HEAD
 +		goto err3;
 +
 +	register_netdevice_notifier(&nf_tables_flowtable_notifier);
 +
 +	err = rhltable_init(&nft_objname_ht, &nft_objname_ht_params);
  	if (err < 0)
  		goto err4;
  
 +
 +	return register_pernet_subsys(&nf_tables_net_ops);
++=======
++		goto err4;
++
+ 	return err;
++>>>>>>> d209df3e7f70 (netfilter: nf_tables: fix register ordering)
  err4:
  	unregister_netdevice_notifier(&nf_tables_flowtable_notifier);
  err3:
  	nf_tables_core_module_exit();
  err2:
++<<<<<<< HEAD
 +	kfree(info);
 +err1:
++=======
+ 	nft_chain_filter_fini();
+ err1:
+ 	unregister_pernet_subsys(&nf_tables_net_ops);
++>>>>>>> d209df3e7f70 (netfilter: nf_tables: fix register ordering)
  	return err;
  }
  
diff --git a/include/net/netfilter/nf_tables.h b/include/net/netfilter/nf_tables.h
index 238c6aa0f934..594e46c116e9 100644
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@ -1386,6 +1386,6 @@ struct nft_trans_flowtable {
 	(((struct nft_trans_flowtable *)trans->data)->flowtable)
 
 int __init nft_chain_filter_init(void);
-void __exit nft_chain_filter_fini(void);
+void nft_chain_filter_fini(void);
 
 #endif /* _NET_NF_TABLES_H */
* Unmerged path net/netfilter/nf_tables_api.c
diff --git a/net/netfilter/nft_chain_filter.c b/net/netfilter/nft_chain_filter.c
index d21834bed805..fa8dbcb0c580 100644
--- a/net/netfilter/nft_chain_filter.c
+++ b/net/netfilter/nft_chain_filter.c
@@ -392,7 +392,7 @@ int __init nft_chain_filter_init(void)
 	return 0;
 }
 
-void __exit nft_chain_filter_fini(void)
+void nft_chain_filter_fini(void)
 {
 	nft_chain_filter_bridge_fini();
 	nft_chain_filter_inet_fini();
