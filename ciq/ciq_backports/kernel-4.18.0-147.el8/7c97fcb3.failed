KVM: VMX: Expose nested_vmx_allowed() to nested VMX as a non-inline

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 7c97fcb3b68cd4d48a071bc1929c753d255dea47
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/7c97fcb3.failed

Exposing only the function allows @nested, i.e. the module param, to be
statically defined in vmx.c, ensuring we aren't unnecessarily checking
said variable in the nested code.  nested_vmx_allowed() is exposed due
to the need to verify nested support in vmx_{get,set}_nested_state().
The downside is that nested_vmx_allowed() likely won't be inlined in
vmx_{get,set}_nested_state(), but that should be a non-issue as they're
not a hot path.  Keeping vmx_{get,set}_nested_state() in vmx.c isn't a
viable option as they need access to several nested-only functions.

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 7c97fcb3b68cd4d48a071bc1929c753d255dea47)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/vmx.c
#	arch/x86/kvm/vmx/vmx.h
diff --cc arch/x86/kvm/vmx/vmx.c
index d9061399dcbb,58bb8de04d0d..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -2116,19 -698,7 +2116,23 @@@ static struct shared_msr_entry *find_ms
  	return NULL;
  }
  
++<<<<<<< HEAD
 +static void vmcs_clear(struct vmcs *vmcs)
 +{
 +	u64 phys_addr = __pa(vmcs);
 +	bool error;
 +
 +	asm volatile (__ex("vmclear %1") CC_SET(na)
 +		      : CC_OUT(na) (error) : "m"(phys_addr));
 +	if (unlikely(error))
 +		printk(KERN_ERR "kvm: vmclear fail: %p/%llx\n",
 +		       vmcs, phys_addr);
 +}
 +
 +static inline void loaded_vmcs_init(struct loaded_vmcs *loaded_vmcs)
++=======
+ void loaded_vmcs_init(struct loaded_vmcs *loaded_vmcs)
++>>>>>>> 7c97fcb3b68c (KVM: VMX: Expose nested_vmx_allowed() to nested VMX as a non-inline)
  {
  	vmcs_clear(loaded_vmcs->vmcs);
  	if (loaded_vmcs->shadow_vmcs && loaded_vmcs->launched)
@@@ -2137,21 -707,6 +2141,24 @@@
  	loaded_vmcs->launched = 0;
  }
  
++<<<<<<< HEAD
 +static void vmcs_load(struct vmcs *vmcs)
 +{
 +	u64 phys_addr = __pa(vmcs);
 +	bool error;
 +
 +	if (static_branch_unlikely(&enable_evmcs))
 +		return evmcs_load(phys_addr);
 +
 +	asm volatile (__ex("vmptrld %1") CC_SET(na)
 +		      : CC_OUT(na) (error) : "m"(phys_addr));
 +	if (unlikely(error))
 +		printk(KERN_ERR "kvm: vmptrld %p/%llx failed\n",
 +		       vmcs, phys_addr);
 +}
 +
++=======
++>>>>>>> 7c97fcb3b68c (KVM: VMX: Expose nested_vmx_allowed() to nested VMX as a non-inline)
  #ifdef CONFIG_KEXEC_CORE
  /*
   * This bitmap is used to indicate whether the vmclear
* Unmerged path arch/x86/kvm/vmx/vmx.h
* Unmerged path arch/x86/kvm/vmx/vmx.c
* Unmerged path arch/x86/kvm/vmx/vmx.h
