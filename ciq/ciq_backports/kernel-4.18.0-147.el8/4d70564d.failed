net/mlx5e: Refactor VXLAN tunnel decap offloading code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Oz Shlomo <ozsh@mellanox.com>
commit 4d70564d1c9e812b83f30c8dc23cd506abfcfc08
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/4d70564d.failed

Separates the vxlan header match handling from the matching on the
general fields of ipv4/6 tunnels, thus allowing the common IP tunnel
match code to branch in down stream patch, to multiple IP tunnels.

This patch doesn't add any functionality.

	Signed-off-by: Oz Shlomo <ozsh@mellanox.com>
	Reviewed-by: Eli Britstein <elibr@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 4d70564d1c9e812b83f30c8dc23cd506abfcfc08)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index c9ee89f4edb1,74823cab1d16..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -1141,39 -1279,16 +1180,36 @@@ static int parse_tunnel_attr(struct mlx
  					  f->key);
  
  	if (dissector_uses_key(f->dissector, FLOW_DISSECTOR_KEY_ENC_PORTS)) {
- 		struct flow_dissector_key_ports *key =
- 			skb_flow_dissector_target(f->dissector,
- 						  FLOW_DISSECTOR_KEY_ENC_PORTS,
- 						  f->key);
- 		struct flow_dissector_key_ports *mask =
- 			skb_flow_dissector_target(f->dissector,
- 						  FLOW_DISSECTOR_KEY_ENC_PORTS,
- 						  f->mask);
+ 		int err = 0;
  
- 		/* Full udp dst port must be given */
- 		if (memchr_inv(&mask->dst, 0xff, sizeof(mask->dst)))
+ 		err = parse_tunnel_vxlan_attr(priv, spec, f,
+ 					      headers_c, headers_v);
+ 		if (err)
  			goto vxlan_match_offload_err;
++<<<<<<< HEAD
 +
 +		if (mlx5_vxlan_lookup_port(priv->mdev->vxlan, be16_to_cpu(key->dst)) &&
 +		    MLX5_CAP_ESW(priv->mdev, vxlan_encap_decap))
 +			parse_vxlan_attr(spec, f);
 +		else {
 +			netdev_warn(priv->netdev,
 +				    "%d isn't an offloaded vxlan udp dport\n", be16_to_cpu(key->dst));
 +			return -EOPNOTSUPP;
 +		}
 +
 +		MLX5_SET(fte_match_set_lyr_2_4, headers_c,
 +			 udp_dport, ntohs(mask->dst));
 +		MLX5_SET(fte_match_set_lyr_2_4, headers_v,
 +			 udp_dport, ntohs(key->dst));
 +
 +		MLX5_SET(fte_match_set_lyr_2_4, headers_c,
 +			 udp_sport, ntohs(mask->src));
 +		MLX5_SET(fte_match_set_lyr_2_4, headers_v,
 +			 udp_sport, ntohs(key->src));
++=======
++>>>>>>> 4d70564d1c9e (net/mlx5e: Refactor VXLAN tunnel decap offloading code)
  	} else { /* udp dst port must be given */
  vxlan_match_offload_err:
 -		NL_SET_ERR_MSG_MOD(extack,
 -				   "IP tunnel decap offload supported only for vxlan, must set UDP dport");
  		netdev_warn(priv->netdev,
  			    "IP tunnel decap offload supported only for vxlan, must set UDP dport\n");
  		return -EOPNOTSUPP;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
