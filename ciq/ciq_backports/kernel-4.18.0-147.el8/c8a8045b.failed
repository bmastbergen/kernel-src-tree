net: hns3: Fix NULL deref when unloading driver

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Huazhong Tan <tanhuazhong@huawei.com>
commit c8a8045b2d0a974149d65bbe6a7acbcde93cf85b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/c8a8045b.failed

When the driver is unloading, if there is a calling of ndo_open occurs
between phy_disconnect() and unregister_netdev(), it will end up
causing the kernel to eventually hit a NULL deref:

[14942.417828] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000048
[14942.529878] Mem abort info:
[14942.551166]   ESR = 0x96000006
[14942.567070]   Exception class = DABT (current EL), IL = 32 bits
[14942.623081]   SET = 0, FnV = 0
[14942.639112]   EA = 0, S1PTW = 0
[14942.643628] Data abort info:
[14942.659227]   ISV = 0, ISS = 0x00000006
[14942.674870]   CM = 0, WnR = 0
[14942.679449] user pgtable: 4k pages, 48-bit VAs, pgdp = 00000000224ad6ad
[14942.695595] [0000000000000048] pgd=00000021e6673003, pud=00000021dbf01003, pmd=0000000000000000
[14942.723163] Internal error: Oops: 96000006 [#1] PREEMPT SMP
[14942.729358] Modules linked in: hns3(O) hclge(O) pv680_mii(O) hnae3(O) [last unloaded: hclge]
[14942.738907] CPU: 1 PID: 26629 Comm: kworker/u4:13 Tainted: G           O      4.18.0-rc1-12928-ga960791-dirty #145
[14942.749491] Hardware name: Huawei Technologies Co., Ltd. D05/D05, BIOS Hi1620 FPGA TB BOOT BIOS B763 08/17/2018
[14942.760392] Workqueue: events_power_efficient phy_state_machine
[14942.766644] pstate: 80c00009 (Nzcv daif +PAN +UAO)
[14942.771918] pc : test_and_set_bit+0x18/0x38
[14942.776589] lr : netif_carrier_off+0x24/0x70
[14942.781033] sp : ffff0000121abd20
[14942.784518] x29: ffff0000121abd20 x28: 0000000000000000
[14942.790208] x27: ffff0000164d3cd8 x26: ffff8021da68b7b8
[14942.795832] x25: 0000000000000000 x24: ffff8021eb407800
[14942.801445] x23: 0000000000000000 x22: 0000000000000000
[14942.807046] x21: 0000000000000001 x20: 0000000000000000
[14942.812672] x19: 0000000000000000 x18: ffff000009781708
[14942.818284] x17: 00000000004970e8 x16: ffff00000816ad48
[14942.823900] x15: 0000000000000000 x14: 0000000000000008
[14942.829528] x13: 0000000000000000 x12: 0000000000000f65
[14942.835149] x11: 0000000000000001 x10: 00000000000009d0
[14942.840753] x9 : ffff0000121abaa0 x8 : 0000000000000000
[14942.846360] x7 : ffff000009781708 x6 : 0000000000000003
[14942.851970] x5 : 0000000000000020 x4 : 0000000000000004
[14942.857575] x3 : 0000000000000002 x2 : 0000000000000001
[14942.863180] x1 : 0000000000000048 x0 : 0000000000000000
[14942.868875] Process kworker/u4:13 (pid: 26629, stack limit = 0x00000000c909dbf3)
[14942.876464] Call trace:
[14942.879200]  test_and_set_bit+0x18/0x38
[14942.883376]  phy_link_change+0x38/0x78
[14942.887378]  phy_state_machine+0x3dc/0x4f8
[14942.891968]  process_one_work+0x158/0x470
[14942.896223]  worker_thread+0x50/0x470
[14942.900219]  kthread+0x104/0x130
[14942.903905]  ret_from_fork+0x10/0x1c
[14942.907755] Code: d2800022 8b400c21 f9800031 9ac32044 (c85f7c22)
[14942.914185] ---[ end trace 968c9e12eb740b23 ]---

So this patch fixes it by modifying the timing to do phy_connect_direct()
and phy_disconnect().

Fixes: 256727da7395 ("net: hns3: Add MDIO support to HNS3 Ethernet driver for hip08 SoC")
	Signed-off-by: Huazhong Tan <tanhuazhong@huawei.com>
	Signed-off-by: Peng Li <lipeng321@huawei.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c8a8045b2d0a974149d65bbe6a7acbcde93cf85b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/hisilicon/hns3/hnae3.h
#	drivers/net/ethernet/hisilicon/hns3/hns3_enet.c
#	drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
diff --cc drivers/net/ethernet/hisilicon/hns3/hnae3.h
index 0806b3dfac1c,e05b4926feb2..000000000000
--- a/drivers/net/ethernet/hisilicon/hns3/hnae3.h
+++ b/drivers/net/ethernet/hisilicon/hns3/hnae3.h
@@@ -416,7 -442,30 +416,34 @@@ struct hnae3_ae_ops 
  	void (*get_link_mode)(struct hnae3_handle *handle,
  			      unsigned long *supported,
  			      unsigned long *advertising);
++<<<<<<< HEAD
 +	void (*get_port_type)(struct hnae3_handle *handle, u8 *port_type);
++=======
+ 	int (*add_fd_entry)(struct hnae3_handle *handle,
+ 			    struct ethtool_rxnfc *cmd);
+ 	int (*del_fd_entry)(struct hnae3_handle *handle,
+ 			    struct ethtool_rxnfc *cmd);
+ 	void (*del_all_fd_entries)(struct hnae3_handle *handle,
+ 				   bool clear_list);
+ 	int (*get_fd_rule_cnt)(struct hnae3_handle *handle,
+ 			       struct ethtool_rxnfc *cmd);
+ 	int (*get_fd_rule_info)(struct hnae3_handle *handle,
+ 				struct ethtool_rxnfc *cmd);
+ 	int (*get_fd_all_rules)(struct hnae3_handle *handle,
+ 				struct ethtool_rxnfc *cmd, u32 *rule_locs);
+ 	int (*restore_fd_rules)(struct hnae3_handle *handle);
+ 	void (*enable_fd)(struct hnae3_handle *handle, bool enable);
+ 	int (*dbg_run_cmd)(struct hnae3_handle *handle, char *cmd_buf);
+ 	pci_ers_result_t (*handle_hw_ras_error)(struct hnae3_ae_dev *ae_dev);
+ 	bool (*get_hw_reset_stat)(struct hnae3_handle *handle);
+ 	bool (*ae_dev_resetting)(struct hnae3_handle *handle);
+ 	unsigned long (*ae_dev_reset_cnt)(struct hnae3_handle *handle);
+ 	int (*set_gro_en)(struct hnae3_handle *handle, int enable);
+ 	u16 (*get_global_queue_id)(struct hnae3_handle *handle, u16 queue_id);
+ 	void (*set_timer_task)(struct hnae3_handle *handle, bool enable);
+ 	int (*mac_connect_phy)(struct hnae3_handle *handle);
+ 	void (*mac_disconnect_phy)(struct hnae3_handle *handle);
++>>>>>>> c8a8045b2d0a (net: hns3: Fix NULL deref when unloading driver)
  };
  
  struct hnae3_dcb_ops {
diff --cc drivers/net/ethernet/hisilicon/hns3/hns3_enet.c
index df37179cf65a,ac9b0aa258ec..000000000000
--- a/drivers/net/ethernet/hisilicon/hns3/hns3_enet.c
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3_enet.c
@@@ -3134,17 -3526,47 +3134,40 @@@ static void hns3_init_mac_addr(struct n
  	}
  
  	if (h->ae_algo->ops->set_mac_addr)
 -		ret = h->ae_algo->ops->set_mac_addr(h, netdev->dev_addr, true);
 +		h->ae_algo->ops->set_mac_addr(h, netdev->dev_addr, true);
  
 -	return ret;
  }
  
++<<<<<<< HEAD
 +static void hns3_uninit_mac_addr(struct net_device *netdev)
++=======
+ static int hns3_init_phy(struct net_device *netdev)
+ {
+ 	struct hnae3_handle *h = hns3_get_handle(netdev);
+ 	int ret = 0;
+ 
+ 	if (h->ae_algo->ops->mac_connect_phy)
+ 		ret = h->ae_algo->ops->mac_connect_phy(h);
+ 
+ 	return ret;
+ }
+ 
+ static void hns3_uninit_phy(struct net_device *netdev)
+ {
+ 	struct hnae3_handle *h = hns3_get_handle(netdev);
+ 
+ 	if (h->ae_algo->ops->mac_disconnect_phy)
+ 		h->ae_algo->ops->mac_disconnect_phy(h);
+ }
+ 
+ static int hns3_restore_fd_rules(struct net_device *netdev)
++>>>>>>> c8a8045b2d0a (net: hns3: Fix NULL deref when unloading driver)
  {
 -	struct hnae3_handle *h = hns3_get_handle(netdev);
 -	int ret = 0;
 -
 -	if (h->ae_algo->ops->restore_fd_rules)
 -		ret = h->ae_algo->ops->restore_fd_rules(h);
 -
 -	return ret;
 -}
 -
 -static void hns3_del_all_fd_rules(struct net_device *netdev, bool clear_list)
 -{
 -	struct hnae3_handle *h = hns3_get_handle(netdev);
 +	struct hns3_nic_priv *priv = netdev_priv(netdev);
 +	struct hnae3_handle *h = priv->ae_handle;
  
 -	if (h->ae_algo->ops->del_all_fd_entries)
 -		h->ae_algo->ops->del_all_fd_entries(h, clear_list);
 +	if (h->ae_algo->ops->rm_uc_addr)
 +		h->ae_algo->ops->rm_uc_addr(h, netdev->dev_addr);
  }
  
  static void hns3_nic_set_priv_ops(struct net_device *netdev)
@@@ -3261,8 -3711,21 +3291,10 @@@ static void hns3_client_uninit(struct h
  	if (netdev->reg_state != NETREG_UNINITIALIZED)
  		unregister_netdev(netdev);
  
 -	if (!test_and_clear_bit(HNS3_NIC_STATE_INITED, &priv->state)) {
 -		netdev_warn(netdev, "already uninitialized\n");
 -		goto out_netdev_free;
 -	}
 -
 -	hns3_del_all_fd_rules(netdev, true);
 -
  	hns3_force_clear_all_rx_ring(handle);
  
+ 	hns3_uninit_phy(netdev);
+ 
  	ret = hns3_nic_uninit_vector_data(priv);
  	if (ret)
  		netdev_err(netdev, "uninit vector error\n");
diff --cc drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
index b85a8165d846,795ebedde284..000000000000
--- a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
@@@ -6283,7 -8042,24 +6265,28 @@@ static const struct hnae3_ae_ops hclge_
  	.get_regs = hclge_get_regs,
  	.set_led_id = hclge_set_led_id,
  	.get_link_mode = hclge_get_link_mode,
++<<<<<<< HEAD
 +	.get_port_type = hclge_get_port_type,
++=======
+ 	.add_fd_entry = hclge_add_fd_entry,
+ 	.del_fd_entry = hclge_del_fd_entry,
+ 	.del_all_fd_entries = hclge_del_all_fd_entries,
+ 	.get_fd_rule_cnt = hclge_get_fd_rule_cnt,
+ 	.get_fd_rule_info = hclge_get_fd_rule_info,
+ 	.get_fd_all_rules = hclge_get_all_rules,
+ 	.restore_fd_rules = hclge_restore_fd_entries,
+ 	.enable_fd = hclge_enable_fd,
+ 	.dbg_run_cmd = hclge_dbg_run_cmd,
+ 	.handle_hw_ras_error = hclge_handle_hw_ras_error,
+ 	.get_hw_reset_stat = hclge_get_hw_reset_stat,
+ 	.ae_dev_resetting = hclge_ae_dev_resetting,
+ 	.ae_dev_reset_cnt = hclge_ae_dev_reset_cnt,
+ 	.set_gro_en = hclge_gro_en,
+ 	.get_global_queue_id = hclge_covert_handle_qid_global,
+ 	.set_timer_task = hclge_set_timer_task,
+ 	.mac_connect_phy = hclge_mac_connect_phy,
+ 	.mac_disconnect_phy = hclge_mac_disconnect_phy,
++>>>>>>> c8a8045b2d0a (net: hns3: Fix NULL deref when unloading driver)
  };
  
  static struct hnae3_ae_algo ae_algo = {
* Unmerged path drivers/net/ethernet/hisilicon/hns3/hnae3.h
* Unmerged path drivers/net/ethernet/hisilicon/hns3/hns3_enet.c
* Unmerged path drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
diff --git a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_mdio.c b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_mdio.c
index 436771cd9695..e7cc99783629 100644
--- a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_mdio.c
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_mdio.c
@@ -199,8 +199,10 @@ static void hclge_mac_adjust_link(struct net_device *netdev)
 		netdev_err(netdev, "failed to configure flow control.\n");
 }
 
-int hclge_mac_connect_phy(struct hclge_dev *hdev)
+int hclge_mac_connect_phy(struct hnae3_handle *handle)
 {
+	struct hclge_vport *vport = hclge_get_vport(handle);
+	struct hclge_dev *hdev = vport->back;
 	struct net_device *netdev = hdev->vport[0].nic.netdev;
 	struct phy_device *phydev = hdev->hw.mac.phydev;
 	int ret;
@@ -224,8 +226,10 @@ int hclge_mac_connect_phy(struct hclge_dev *hdev)
 	return 0;
 }
 
-void hclge_mac_disconnect_phy(struct hclge_dev *hdev)
+void hclge_mac_disconnect_phy(struct hnae3_handle *handle)
 {
+	struct hclge_vport *vport = hclge_get_vport(handle);
+	struct hclge_dev *hdev = vport->back;
 	struct phy_device *phydev = hdev->hw.mac.phydev;
 
 	if (!phydev)
diff --git a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_mdio.h b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_mdio.h
index d386234e0b83..a2bb47c66f86 100644
--- a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_mdio.h
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_mdio.h
@@ -11,8 +11,8 @@
 #define __HCLGE_MDIO_H
 
 int hclge_mac_mdio_config(struct hclge_dev *hdev);
-int hclge_mac_connect_phy(struct hclge_dev *hdev);
-void hclge_mac_disconnect_phy(struct hclge_dev *hdev);
+int hclge_mac_connect_phy(struct hnae3_handle *handle);
+void hclge_mac_disconnect_phy(struct hnae3_handle *handle);
 void hclge_mac_start_phy(struct hclge_dev *hdev);
 void hclge_mac_stop_phy(struct hclge_dev *hdev);
 
