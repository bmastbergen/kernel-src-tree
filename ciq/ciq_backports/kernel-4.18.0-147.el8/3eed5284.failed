net: sched: don't set tunnel for decap action

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [net] sched: don't set tunnel for decap action (Ivan Vecera) [1688236 1687456]
Rebuild_FUZZ: 94.12%
commit-author Vlad Buslov <vladbu@mellanox.com>
commit 3eed52842b9fd291233c15f65fed34c5d3241183
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/3eed5284.failed

Action tunnel_key doesn't have a metadata/tunnel for release(decap) action.
Drivers do not dereference entry->tunnel pointer for that action type, so
this behavior doesn't result in a crash at the moment. However, this needs
to be corrected as a preparation for updating hardware offloads API to not
rely on rtnl lock, for which flow_action code will copy the tunnel data to
temporary buffer to prevent concurrent action overwrite from
invalidating/freeing it.

Fixes: 3a7b68617de7 ("cls_api: add translator to flow_action representation")
	Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3eed52842b9fd291233c15f65fed34c5d3241183)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/cls_api.c
diff --cc net/sched/cls_api.c
index 7baa7d9ab5a0,9115f053883f..000000000000
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@@ -3049,6 -3175,113 +3049,116 @@@ int tc_setup_cb_call(struct tcf_block *
  }
  EXPORT_SYMBOL(tc_setup_cb_call);
  
++<<<<<<< HEAD
++=======
+ int tc_setup_flow_action(struct flow_action *flow_action,
+ 			 const struct tcf_exts *exts)
+ {
+ 	const struct tc_action *act;
+ 	int i, j, k;
+ 
+ 	if (!exts)
+ 		return 0;
+ 
+ 	j = 0;
+ 	tcf_exts_for_each_action(i, act, exts) {
+ 		struct flow_action_entry *entry;
+ 
+ 		entry = &flow_action->entries[j];
+ 		if (is_tcf_gact_ok(act)) {
+ 			entry->id = FLOW_ACTION_ACCEPT;
+ 		} else if (is_tcf_gact_shot(act)) {
+ 			entry->id = FLOW_ACTION_DROP;
+ 		} else if (is_tcf_gact_trap(act)) {
+ 			entry->id = FLOW_ACTION_TRAP;
+ 		} else if (is_tcf_gact_goto_chain(act)) {
+ 			entry->id = FLOW_ACTION_GOTO;
+ 			entry->chain_index = tcf_gact_goto_chain_index(act);
+ 		} else if (is_tcf_mirred_egress_redirect(act)) {
+ 			entry->id = FLOW_ACTION_REDIRECT;
+ 			entry->dev = tcf_mirred_dev(act);
+ 		} else if (is_tcf_mirred_egress_mirror(act)) {
+ 			entry->id = FLOW_ACTION_MIRRED;
+ 			entry->dev = tcf_mirred_dev(act);
+ 		} else if (is_tcf_vlan(act)) {
+ 			switch (tcf_vlan_action(act)) {
+ 			case TCA_VLAN_ACT_PUSH:
+ 				entry->id = FLOW_ACTION_VLAN_PUSH;
+ 				entry->vlan.vid = tcf_vlan_push_vid(act);
+ 				entry->vlan.proto = tcf_vlan_push_proto(act);
+ 				entry->vlan.prio = tcf_vlan_push_prio(act);
+ 				break;
+ 			case TCA_VLAN_ACT_POP:
+ 				entry->id = FLOW_ACTION_VLAN_POP;
+ 				break;
+ 			case TCA_VLAN_ACT_MODIFY:
+ 				entry->id = FLOW_ACTION_VLAN_MANGLE;
+ 				entry->vlan.vid = tcf_vlan_push_vid(act);
+ 				entry->vlan.proto = tcf_vlan_push_proto(act);
+ 				entry->vlan.prio = tcf_vlan_push_prio(act);
+ 				break;
+ 			default:
+ 				goto err_out;
+ 			}
+ 		} else if (is_tcf_tunnel_set(act)) {
+ 			entry->id = FLOW_ACTION_TUNNEL_ENCAP;
+ 			entry->tunnel = tcf_tunnel_info(act);
+ 		} else if (is_tcf_tunnel_release(act)) {
+ 			entry->id = FLOW_ACTION_TUNNEL_DECAP;
+ 		} else if (is_tcf_pedit(act)) {
+ 			for (k = 0; k < tcf_pedit_nkeys(act); k++) {
+ 				switch (tcf_pedit_cmd(act, k)) {
+ 				case TCA_PEDIT_KEY_EX_CMD_SET:
+ 					entry->id = FLOW_ACTION_MANGLE;
+ 					break;
+ 				case TCA_PEDIT_KEY_EX_CMD_ADD:
+ 					entry->id = FLOW_ACTION_ADD;
+ 					break;
+ 				default:
+ 					goto err_out;
+ 				}
+ 				entry->mangle.htype = tcf_pedit_htype(act, k);
+ 				entry->mangle.mask = tcf_pedit_mask(act, k);
+ 				entry->mangle.val = tcf_pedit_val(act, k);
+ 				entry->mangle.offset = tcf_pedit_offset(act, k);
+ 				entry = &flow_action->entries[++j];
+ 			}
+ 		} else if (is_tcf_csum(act)) {
+ 			entry->id = FLOW_ACTION_CSUM;
+ 			entry->csum_flags = tcf_csum_update_flags(act);
+ 		} else if (is_tcf_skbedit_mark(act)) {
+ 			entry->id = FLOW_ACTION_MARK;
+ 			entry->mark = tcf_skbedit_mark(act);
+ 		} else {
+ 			goto err_out;
+ 		}
+ 
+ 		if (!is_tcf_pedit(act))
+ 			j++;
+ 	}
+ 	return 0;
+ err_out:
+ 	return -EOPNOTSUPP;
+ }
+ EXPORT_SYMBOL(tc_setup_flow_action);
+ 
+ unsigned int tcf_exts_num_actions(struct tcf_exts *exts)
+ {
+ 	unsigned int num_acts = 0;
+ 	struct tc_action *act;
+ 	int i;
+ 
+ 	tcf_exts_for_each_action(i, act, exts) {
+ 		if (is_tcf_pedit(act))
+ 			num_acts += tcf_pedit_nkeys(act);
+ 		else
+ 			num_acts++;
+ 	}
+ 	return num_acts;
+ }
+ EXPORT_SYMBOL(tcf_exts_num_actions);
+ 
++>>>>>>> 3eed52842b9f (net: sched: don't set tunnel for decap action)
  static __net_init int tcf_net_init(struct net *net)
  {
  	struct tcf_net *tn = net_generic(net, tcf_net_id);
* Unmerged path net/sched/cls_api.c
