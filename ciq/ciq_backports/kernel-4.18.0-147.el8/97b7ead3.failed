KVM: VMX: Expose various getters and setters to nested VMX

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 97b7ead392637247569818b6603e54b0a6277dd0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/97b7ead3.failed

...as they're used directly by the nested code.  This will allow
moving the bulk of the nested code out of vmx.c without concurrent
changes to vmx.h.

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 97b7ead392637247569818b6603e54b0a6277dd0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/vmx.c
#	arch/x86/kvm/vmx/vmx.h
diff --cc arch/x86/kvm/vmx/vmx.c
index d9061399dcbb,20d4a1325d08..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -1285,12 -365,6 +1285,15 @@@ static inline struct vmcs12 *get_shadow
  
  static bool nested_ept_ad_enabled(struct kvm_vcpu *vcpu);
  static unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);
++<<<<<<< HEAD
 +static u64 construct_eptp(struct kvm_vcpu *vcpu, unsigned long root_hpa);
 +static bool vmx_xsaves_supported(void);
 +static void vmx_set_segment(struct kvm_vcpu *vcpu,
 +			    struct kvm_segment *var, int seg);
 +static void vmx_get_segment(struct kvm_vcpu *vcpu,
 +			    struct kvm_segment *var, int seg);
++=======
++>>>>>>> 97b7ead39263 (KVM: VMX: Expose various getters and setters to nested VMX)
  static bool guest_state_valid(struct kvm_vcpu *vcpu);
  static u32 vmx_segment_access_rights(struct kvm_segment *var);
  static void copy_shadow_to_vmcs12(struct vcpu_vmx *vmx);
@@@ -1373,10 -429,8 +1373,8 @@@ static const struct kvm_vmx_segment_fie
  	VMX_SEGMENT_FIELD(LDTR),
  };
  
 -u64 host_efer;
 +static u64 host_efer;
  
- static void ept_save_pdptrs(struct kvm_vcpu *vcpu);
- 
  /*
   * Keep MSR_STAR at the end, as setup_msrs() will try to optimize it
   * away by decrementing the array size.
@@@ -2080,33 -688,7 +2078,37 @@@ static inline int __find_msr_index(stru
  	return -1;
  }
  
++<<<<<<< HEAD
 +static inline void __invvpid(unsigned long ext, u16 vpid, gva_t gva)
 +{
 +    struct {
 +	u64 vpid : 16;
 +	u64 rsvd : 48;
 +	u64 gva;
 +    } operand = { vpid, 0, gva };
 +    bool error;
 +
 +    asm volatile (__ex("invvpid %2, %1") CC_SET(na)
 +		  : CC_OUT(na) (error) : "r"(ext), "m"(operand));
 +    BUG_ON(error);
 +}
 +
 +static inline void __invept(unsigned long ext, u64 eptp, gpa_t gpa)
 +{
 +	struct {
 +		u64 eptp, gpa;
 +	} operand = {eptp, gpa};
 +	bool error;
 +
 +	asm volatile (__ex("invept %2, %1") CC_SET(na)
 +		      : CC_OUT(na) (error) : "r"(ext), "m"(operand));
 +	BUG_ON(error);
 +}
 +
 +static struct shared_msr_entry *find_msr_entry(struct vcpu_vmx *vmx, u32 msr)
++=======
+ struct shared_msr_entry *find_msr_entry(struct vcpu_vmx *vmx, u32 msr)
++>>>>>>> 97b7ead39263 (KVM: VMX: Expose various getters and setters to nested VMX)
  {
  	int i;
  
@@@ -2116,42 -698,6 +2118,45 @@@
  	return NULL;
  }
  
++<<<<<<< HEAD
 +static void vmcs_clear(struct vmcs *vmcs)
 +{
 +	u64 phys_addr = __pa(vmcs);
 +	bool error;
 +
 +	asm volatile (__ex("vmclear %1") CC_SET(na)
 +		      : CC_OUT(na) (error) : "m"(phys_addr));
 +	if (unlikely(error))
 +		printk(KERN_ERR "kvm: vmclear fail: %p/%llx\n",
 +		       vmcs, phys_addr);
 +}
 +
 +static inline void loaded_vmcs_init(struct loaded_vmcs *loaded_vmcs)
 +{
 +	vmcs_clear(loaded_vmcs->vmcs);
 +	if (loaded_vmcs->shadow_vmcs && loaded_vmcs->launched)
 +		vmcs_clear(loaded_vmcs->shadow_vmcs);
 +	loaded_vmcs->cpu = -1;
 +	loaded_vmcs->launched = 0;
 +}
 +
 +static void vmcs_load(struct vmcs *vmcs)
 +{
 +	u64 phys_addr = __pa(vmcs);
 +	bool error;
 +
 +	if (static_branch_unlikely(&enable_evmcs))
 +		return evmcs_load(phys_addr);
 +
 +	asm volatile (__ex("vmptrld %1") CC_SET(na)
 +		      : CC_OUT(na) (error) : "m"(phys_addr));
 +	if (unlikely(error))
 +		printk(KERN_ERR "kvm: vmptrld %p/%llx failed\n",
 +		       vmcs, phys_addr);
 +}
 +
++=======
++>>>>>>> 97b7ead39263 (KVM: VMX: Expose various getters and setters to nested VMX)
  #ifdef CONFIG_KEXEC_CORE
  /*
   * This bitmap is used to indicate whether the vmclear
* Unmerged path arch/x86/kvm/vmx/vmx.h
* Unmerged path arch/x86/kvm/vmx/vmx.c
* Unmerged path arch/x86/kvm/vmx/vmx.h
