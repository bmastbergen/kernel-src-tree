libbpf: make sure bpf headers are c++ include-able

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Stanislav Fomichev <sdf@google.com>
commit 8c4905b995c649ac71e21611abc2fcefc904b56a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/8c4905b9.failed

Wrap headers in extern "C", to turn off C++ mangling.
This simplifies including libbpf in c++ and linking against it.

v2 changes:
* do the same for btf.h

v3 changes:
* test_libbpf.cpp to test for possible future c++ breakages

	Signed-off-by: Stanislav Fomichev <sdf@google.com>
	Acked-by: Alexei Starovoitov <ast@kernel.org>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit 8c4905b995c649ac71e21611abc2fcefc904b56a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/bpf.h
#	tools/lib/bpf/btf.h
#	tools/lib/bpf/libbpf.h
diff --cc tools/lib/bpf/bpf.h
index c0ddff373cbd,09e8bbe111d4..000000000000
--- a/tools/lib/bpf/bpf.h
+++ b/tools/lib/bpf/bpf.h
@@@ -27,6 -27,14 +27,17 @@@
  #include <stdbool.h>
  #include <stddef.h>
  
++<<<<<<< HEAD
++=======
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+ 
+ #ifndef LIBBPF_API
+ #define LIBBPF_API __attribute__((visibility("default")))
+ #endif
+ 
++>>>>>>> 8c4905b995c6 (libbpf: make sure bpf headers are c++ include-able)
  struct bpf_create_map_attr {
  	const char *name;
  	enum bpf_map_type map_type;
@@@ -78,44 -89,56 +89,83 @@@ struct bpf_load_program_attr 
  
  /* Recommend log buffer size */
  #define BPF_LOG_BUF_SIZE (256 * 1024)
 -LIBBPF_API int
 -bpf_load_program_xattr(const struct bpf_load_program_attr *load_attr,
 -		       char *log_buf, size_t log_buf_sz);
 -LIBBPF_API int bpf_load_program(enum bpf_prog_type type,
 -				const struct bpf_insn *insns, size_t insns_cnt,
 -				const char *license, __u32 kern_version,
 -				char *log_buf, size_t log_buf_sz);
 -LIBBPF_API int bpf_verify_program(enum bpf_prog_type type,
 -				  const struct bpf_insn *insns,
 -				  size_t insns_cnt, int strict_alignment,
 -				  const char *license, __u32 kern_version,
 -				  char *log_buf, size_t log_buf_sz,
 -				  int log_level);
 +int bpf_load_program_xattr(const struct bpf_load_program_attr *load_attr,
 +			   char *log_buf, size_t log_buf_sz);
 +int bpf_load_program(enum bpf_prog_type type, const struct bpf_insn *insns,
 +		     size_t insns_cnt, const char *license,
 +		     __u32 kern_version, char *log_buf,
 +		     size_t log_buf_sz);
 +int bpf_verify_program(enum bpf_prog_type type, const struct bpf_insn *insns,
 +		       size_t insns_cnt, int strict_alignment,
 +		       const char *license, __u32 kern_version,
 +		       char *log_buf, size_t log_buf_sz, int log_level);
  
 -LIBBPF_API int bpf_map_update_elem(int fd, const void *key, const void *value,
 -				   __u64 flags);
 +int bpf_map_update_elem(int fd, const void *key, const void *value,
 +			__u64 flags);
  
++<<<<<<< HEAD
 +int bpf_map_lookup_elem(int fd, const void *key, void *value);
 +int bpf_map_delete_elem(int fd, const void *key);
 +int bpf_map_get_next_key(int fd, const void *key, void *next_key);
 +int bpf_obj_pin(int fd, const char *pathname);
 +int bpf_obj_get(const char *pathname);
 +int bpf_prog_attach(int prog_fd, int attachable_fd, enum bpf_attach_type type,
 +		    unsigned int flags);
 +int bpf_prog_detach(int attachable_fd, enum bpf_attach_type type);
 +int bpf_prog_detach2(int prog_fd, int attachable_fd, enum bpf_attach_type type);
 +int bpf_prog_test_run(int prog_fd, int repeat, void *data, __u32 size,
 +		      void *data_out, __u32 *size_out, __u32 *retval,
 +		      __u32 *duration);
 +int bpf_prog_get_next_id(__u32 start_id, __u32 *next_id);
 +int bpf_map_get_next_id(__u32 start_id, __u32 *next_id);
 +int bpf_prog_get_fd_by_id(__u32 id);
 +int bpf_map_get_fd_by_id(__u32 id);
 +int bpf_btf_get_fd_by_id(__u32 id);
 +int bpf_obj_get_info_by_fd(int prog_fd, void *info, __u32 *info_len);
 +int bpf_prog_query(int target_fd, enum bpf_attach_type type, __u32 query_flags,
 +		   __u32 *attach_flags, __u32 *prog_ids, __u32 *prog_cnt);
 +int bpf_raw_tracepoint_open(const char *name, int prog_fd);
 +int bpf_load_btf(void *btf, __u32 btf_size, char *log_buf, __u32 log_buf_size,
 +		 bool do_log);
 +int bpf_task_fd_query(int pid, int fd, __u32 flags, char *buf, __u32 *buf_len,
 +		      __u32 *prog_id, __u32 *fd_type, __u64 *probe_offset,
 +		      __u64 *probe_addr);
 +#endif
++=======
+ LIBBPF_API int bpf_map_lookup_elem(int fd, const void *key, void *value);
+ LIBBPF_API int bpf_map_lookup_and_delete_elem(int fd, const void *key,
+ 					      void *value);
+ LIBBPF_API int bpf_map_delete_elem(int fd, const void *key);
+ LIBBPF_API int bpf_map_get_next_key(int fd, const void *key, void *next_key);
+ LIBBPF_API int bpf_obj_pin(int fd, const char *pathname);
+ LIBBPF_API int bpf_obj_get(const char *pathname);
+ LIBBPF_API int bpf_prog_attach(int prog_fd, int attachable_fd,
+ 			       enum bpf_attach_type type, unsigned int flags);
+ LIBBPF_API int bpf_prog_detach(int attachable_fd, enum bpf_attach_type type);
+ LIBBPF_API int bpf_prog_detach2(int prog_fd, int attachable_fd,
+ 				enum bpf_attach_type type);
+ LIBBPF_API int bpf_prog_test_run(int prog_fd, int repeat, void *data,
+ 				 __u32 size, void *data_out, __u32 *size_out,
+ 				 __u32 *retval, __u32 *duration);
+ LIBBPF_API int bpf_prog_get_next_id(__u32 start_id, __u32 *next_id);
+ LIBBPF_API int bpf_map_get_next_id(__u32 start_id, __u32 *next_id);
+ LIBBPF_API int bpf_prog_get_fd_by_id(__u32 id);
+ LIBBPF_API int bpf_map_get_fd_by_id(__u32 id);
+ LIBBPF_API int bpf_btf_get_fd_by_id(__u32 id);
+ LIBBPF_API int bpf_obj_get_info_by_fd(int prog_fd, void *info, __u32 *info_len);
+ LIBBPF_API int bpf_prog_query(int target_fd, enum bpf_attach_type type,
+ 			      __u32 query_flags, __u32 *attach_flags,
+ 			      __u32 *prog_ids, __u32 *prog_cnt);
+ LIBBPF_API int bpf_raw_tracepoint_open(const char *name, int prog_fd);
+ LIBBPF_API int bpf_load_btf(void *btf, __u32 btf_size, char *log_buf,
+ 			    __u32 log_buf_size, bool do_log);
+ LIBBPF_API int bpf_task_fd_query(int pid, int fd, __u32 flags, char *buf,
+ 				 __u32 *buf_len, __u32 *prog_id, __u32 *fd_type,
+ 				 __u64 *probe_offset, __u64 *probe_addr);
+ 
+ #ifdef __cplusplus
+ } /* extern "C" */
+ #endif
+ 
+ #endif /* __LIBBPF_BPF_H */
++>>>>>>> 8c4905b995c6 (libbpf: make sure bpf headers are c++ include-able)
diff --cc tools/lib/bpf/btf.h
index caac3a404dc5,701ad2b6c41f..000000000000
--- a/tools/lib/bpf/btf.h
+++ b/tools/lib/bpf/btf.h
@@@ -6,19 -6,86 +6,47 @@@
  
  #include <linux/types.h>
  
++<<<<<<< HEAD
++=======
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+ 
+ #ifndef LIBBPF_API
+ #define LIBBPF_API __attribute__((visibility("default")))
+ #endif
+ 
++>>>>>>> 8c4905b995c6 (libbpf: make sure bpf headers are c++ include-able)
  #define BTF_ELF_SEC ".BTF"
 -#define BTF_EXT_ELF_SEC ".BTF.ext"
  
  struct btf;
 -struct btf_ext;
  struct btf_type;
  
 -/*
 - * The .BTF.ext ELF section layout defined as
 - *   struct btf_ext_header
 - *   func_info subsection
 - *
 - * The func_info subsection layout:
 - *   record size for struct bpf_func_info in the func_info subsection
 - *   struct btf_sec_func_info for section #1
 - *   a list of bpf_func_info records for section #1
 - *     where struct bpf_func_info mimics one in include/uapi/linux/bpf.h
 - *     but may not be identical
 - *   struct btf_sec_func_info for section #2
 - *   a list of bpf_func_info records for section #2
 - *   ......
 - *
 - * Note that the bpf_func_info record size in .BTF.ext may not
 - * be the same as the one defined in include/uapi/linux/bpf.h.
 - * The loader should ensure that record_size meets minimum
 - * requirement and pass the record as is to the kernel. The
 - * kernel will handle the func_info properly based on its contents.
 - */
 -struct btf_ext_header {
 -	__u16	magic;
 -	__u8	version;
 -	__u8	flags;
 -	__u32	hdr_len;
 -
 -	/* All offsets are in bytes relative to the end of this header */
 -	__u32	func_info_off;
 -	__u32	func_info_len;
 -};
 -
 -struct btf_sec_func_info {
 -	__u32	sec_name_off;
 -	__u32	num_func_info;
 -	/* Followed by num_func_info number of bpf func_info records */
 -	__u8	data[0];
 -};
 -
  typedef int (*btf_print_fn_t)(const char *, ...)
  	__attribute__((format(printf, 1, 2)));
  
 -LIBBPF_API void btf__free(struct btf *btf);
 -LIBBPF_API struct btf *btf__new(__u8 *data, __u32 size, btf_print_fn_t err_log);
 -LIBBPF_API __s32 btf__find_by_name(const struct btf *btf,
 -				   const char *type_name);
 -LIBBPF_API const struct btf_type *btf__type_by_id(const struct btf *btf,
 -						  __u32 id);
 -LIBBPF_API __s64 btf__resolve_size(const struct btf *btf, __u32 type_id);
 -LIBBPF_API int btf__resolve_type(const struct btf *btf, __u32 type_id);
 -LIBBPF_API int btf__fd(const struct btf *btf);
 -LIBBPF_API const char *btf__name_by_offset(const struct btf *btf, __u32 offset);
 -LIBBPF_API int btf_get_from_id(__u32 id, struct btf **btf);
 +void btf__free(struct btf *btf);
 +struct btf *btf__new(__u8 *data, __u32 size, btf_print_fn_t err_log);
 +__s32 btf__find_by_name(const struct btf *btf, const char *type_name);
 +const struct btf_type *btf__type_by_id(const struct btf *btf, __u32 id);
 +__s64 btf__resolve_size(const struct btf *btf, __u32 type_id);
 +int btf__fd(const struct btf *btf);
  
++<<<<<<< HEAD
 +#endif
++=======
+ struct btf_ext *btf_ext__new(__u8 *data, __u32 size, btf_print_fn_t err_log);
+ void btf_ext__free(struct btf_ext *btf_ext);
+ int btf_ext__reloc_init(struct btf *btf, struct btf_ext *btf_ext,
+ 			const char *sec_name, void **func_info,
+ 			__u32 *func_info_rec_size, __u32 *func_info_len);
+ int btf_ext__reloc(struct btf *btf, struct btf_ext *btf_ext,
+ 		   const char *sec_name, __u32 insns_cnt, void **func_info,
+ 		   __u32 *func_info_len);
+ 
+ #ifdef __cplusplus
+ } /* extern "C" */
+ #endif
+ 
+ #endif /* __LIBBPF_BTF_H */
++>>>>>>> 8c4905b995c6 (libbpf: make sure bpf headers are c++ include-able)
diff --cc tools/lib/bpf/libbpf.h
index c8c168c73302,74e57e041705..000000000000
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@@ -29,6 -16,14 +29,17 @@@
  #include <sys/types.h>  // for size_t
  #include <linux/bpf.h>
  
++<<<<<<< HEAD
++=======
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+ 
+ #ifndef LIBBPF_API
+ #define LIBBPF_API __attribute__((visibility("default")))
+ #endif
+ 
++>>>>>>> 8c4905b995c6 (libbpf: make sure bpf headers are c++ include-able)
  enum libbpf_errno {
  	__LIBBPF_ERRNO__START = 4000,
  
@@@ -298,10 -319,29 +309,39 @@@ enum bpf_perf_event_ret 
  	LIBBPF_PERF_EVENT_CONT	= -2,
  };
  
++<<<<<<< HEAD
 +typedef enum bpf_perf_event_ret (*bpf_perf_event_print_t)(void *event,
 +							  void *priv);
 +int bpf_perf_event_read_simple(void *mem, unsigned long size,
 +			       unsigned long page_size,
 +			       void **buf, size_t *buf_len,
 +			       bpf_perf_event_print_t fn, void *priv);
 +#endif
++=======
+ struct perf_event_header;
+ typedef enum bpf_perf_event_ret
+ 	(*bpf_perf_event_print_t)(struct perf_event_header *hdr,
+ 				  void *private_data);
+ LIBBPF_API enum bpf_perf_event_ret
+ bpf_perf_event_read_simple(void *mmap_mem, size_t mmap_size, size_t page_size,
+ 			   void **copy_mem, size_t *copy_size,
+ 			   bpf_perf_event_print_t fn, void *private_data);
+ 
+ struct nlattr;
+ typedef int (*libbpf_dump_nlmsg_t)(void *cookie, void *msg, struct nlattr **tb);
+ int libbpf_netlink_open(unsigned int *nl_pid);
+ int libbpf_nl_get_link(int sock, unsigned int nl_pid,
+ 		       libbpf_dump_nlmsg_t dump_link_nlmsg, void *cookie);
+ int libbpf_nl_get_class(int sock, unsigned int nl_pid, int ifindex,
+ 			libbpf_dump_nlmsg_t dump_class_nlmsg, void *cookie);
+ int libbpf_nl_get_qdisc(int sock, unsigned int nl_pid, int ifindex,
+ 			libbpf_dump_nlmsg_t dump_qdisc_nlmsg, void *cookie);
+ int libbpf_nl_get_filter(int sock, unsigned int nl_pid, int ifindex, int handle,
+ 			 libbpf_dump_nlmsg_t dump_filter_nlmsg, void *cookie);
+ 
+ #ifdef __cplusplus
+ } /* extern "C" */
+ #endif
+ 
+ #endif /* __LIBBPF_LIBBPF_H */
++>>>>>>> 8c4905b995c6 (libbpf: make sure bpf headers are c++ include-able)
diff --git a/tools/lib/bpf/Makefile b/tools/lib/bpf/Makefile
index 9bc7b2565c85..c212198930b7 100644
--- a/tools/lib/bpf/Makefile
+++ b/tools/lib/bpf/Makefile
@@ -66,7 +66,7 @@ ifndef VERBOSE
 endif
 
 FEATURE_USER = .libbpf
-FEATURE_TESTS = libelf libelf-mmap bpf reallocarray
+FEATURE_TESTS = libelf libelf-mmap bpf reallocarray cxx
 FEATURE_DISPLAY = libelf bpf
 
 INCLUDES = -I. -I$(srctree)/tools/include -I$(srctree)/tools/arch/$(ARCH)/include/uapi -I$(srctree)/tools/include/uapi
@@ -147,6 +147,12 @@ LIB_FILE := $(addprefix $(OUTPUT),$(LIB_FILE))
 
 CMD_TARGETS = $(LIB_FILE)
 
+CXX_TEST_TARGET = $(OUTPUT)test_libbpf
+
+ifeq ($(feature-cxx), 1)
+	CMD_TARGETS += $(CXX_TEST_TARGET)
+endif
+
 TARGETS = $(CMD_TARGETS)
 
 all: fixdep all_cmd
@@ -174,6 +180,9 @@ $(OUTPUT)libbpf.so: $(BPF_IN)
 $(OUTPUT)libbpf.a: $(BPF_IN)
 	$(QUIET_LINK)$(RM) $@; $(AR) rcs $@ $^
 
+$(OUTPUT)test_libbpf: test_libbpf.cpp $(OUTPUT)libbpf.a
+	$(QUIET_LINK)$(CXX) $^ -lelf -o $@
+
 define do_install
 	if [ ! -d '$(DESTDIR_SQ)$2' ]; then		\
 		$(INSTALL) -d -m 755 '$(DESTDIR_SQ)$2';	\
@@ -200,8 +209,8 @@ config-clean:
 	$(Q)$(MAKE) -C $(srctree)/tools/build/feature/ clean >/dev/null
 
 clean:
-	$(call QUIET_CLEAN, libbpf) $(RM) *.o *~ $(TARGETS) *.a *.so .*.d .*.cmd \
-		$(RM) LIBBPF-CFLAGS
+	$(call QUIET_CLEAN, libbpf) $(RM) $(TARGETS) $(CXX_TEST_TARGET) \
+		*.o *~ *.a *.so .*.d .*.cmd LIBBPF-CFLAGS
 	$(call QUIET_CLEAN, core-gen) $(RM) $(OUTPUT)FEATURE-DUMP.libbpf
 
 
* Unmerged path tools/lib/bpf/bpf.h
* Unmerged path tools/lib/bpf/btf.h
* Unmerged path tools/lib/bpf/libbpf.h
diff --git a/tools/lib/bpf/test_libbpf.cpp b/tools/lib/bpf/test_libbpf.cpp
new file mode 100644
index 000000000000..abf3fc25c9fa
--- /dev/null
+++ b/tools/lib/bpf/test_libbpf.cpp
@@ -0,0 +1,18 @@
+/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */
+#include "libbpf.h"
+#include "bpf.h"
+#include "btf.h"
+
+/* do nothing, just make sure we can link successfully */
+
+int main(int argc, char *argv[])
+{
+    /* libbpf.h */
+    libbpf_set_print(NULL, NULL, NULL);
+
+    /* bpf.h */
+    bpf_prog_get_fd_by_id(0);
+
+    /* btf.h */
+    btf__new(NULL, 0, NULL);
+}
