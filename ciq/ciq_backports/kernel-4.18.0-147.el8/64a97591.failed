libbpf: add bpf_prog_test_run_xattr

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Lorenz Bauer <lmb@cloudflare.com>
commit 64a975913b311e5192a76cd10721d4565c9addd1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/64a97591.failed

Add a new function, which encourages safe usage of the test interface.
bpf_prog_test_run continues to work as before, but should be considered
unsafe.

	Signed-off-by: Lorenz Bauer <lmb@cloudflare.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit 64a975913b311e5192a76cd10721d4565c9addd1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/bpf.h
diff --cc tools/lib/bpf/bpf.h
index c0ddff373cbd,098e6f793b76..000000000000
--- a/tools/lib/bpf/bpf.h
+++ b/tools/lib/bpf/bpf.h
@@@ -78,44 -89,75 +78,99 @@@ struct bpf_load_program_attr 
  
  /* Recommend log buffer size */
  #define BPF_LOG_BUF_SIZE (256 * 1024)
 -LIBBPF_API int
 -bpf_load_program_xattr(const struct bpf_load_program_attr *load_attr,
 -		       char *log_buf, size_t log_buf_sz);
 -LIBBPF_API int bpf_load_program(enum bpf_prog_type type,
 -				const struct bpf_insn *insns, size_t insns_cnt,
 -				const char *license, __u32 kern_version,
 -				char *log_buf, size_t log_buf_sz);
 -LIBBPF_API int bpf_verify_program(enum bpf_prog_type type,
 -				  const struct bpf_insn *insns,
 -				  size_t insns_cnt, __u32 prog_flags,
 -				  const char *license, __u32 kern_version,
 -				  char *log_buf, size_t log_buf_sz,
 -				  int log_level);
 -
 -LIBBPF_API int bpf_map_update_elem(int fd, const void *key, const void *value,
 -				   __u64 flags);
 -
 +int bpf_load_program_xattr(const struct bpf_load_program_attr *load_attr,
 +			   char *log_buf, size_t log_buf_sz);
 +int bpf_load_program(enum bpf_prog_type type, const struct bpf_insn *insns,
 +		     size_t insns_cnt, const char *license,
 +		     __u32 kern_version, char *log_buf,
 +		     size_t log_buf_sz);
 +int bpf_verify_program(enum bpf_prog_type type, const struct bpf_insn *insns,
 +		       size_t insns_cnt, int strict_alignment,
 +		       const char *license, __u32 kern_version,
 +		       char *log_buf, size_t log_buf_sz, int log_level);
 +
 +int bpf_map_update_elem(int fd, const void *key, const void *value,
 +			__u64 flags);
 +
++<<<<<<< HEAD
 +int bpf_map_lookup_elem(int fd, const void *key, void *value);
 +int bpf_map_delete_elem(int fd, const void *key);
 +int bpf_map_get_next_key(int fd, const void *key, void *next_key);
 +int bpf_obj_pin(int fd, const char *pathname);
 +int bpf_obj_get(const char *pathname);
 +int bpf_prog_attach(int prog_fd, int attachable_fd, enum bpf_attach_type type,
 +		    unsigned int flags);
 +int bpf_prog_detach(int attachable_fd, enum bpf_attach_type type);
 +int bpf_prog_detach2(int prog_fd, int attachable_fd, enum bpf_attach_type type);
 +int bpf_prog_test_run(int prog_fd, int repeat, void *data, __u32 size,
 +		      void *data_out, __u32 *size_out, __u32 *retval,
 +		      __u32 *duration);
 +int bpf_prog_get_next_id(__u32 start_id, __u32 *next_id);
 +int bpf_map_get_next_id(__u32 start_id, __u32 *next_id);
 +int bpf_prog_get_fd_by_id(__u32 id);
 +int bpf_map_get_fd_by_id(__u32 id);
 +int bpf_btf_get_fd_by_id(__u32 id);
 +int bpf_obj_get_info_by_fd(int prog_fd, void *info, __u32 *info_len);
 +int bpf_prog_query(int target_fd, enum bpf_attach_type type, __u32 query_flags,
 +		   __u32 *attach_flags, __u32 *prog_ids, __u32 *prog_cnt);
 +int bpf_raw_tracepoint_open(const char *name, int prog_fd);
 +int bpf_load_btf(void *btf, __u32 btf_size, char *log_buf, __u32 log_buf_size,
 +		 bool do_log);
 +int bpf_task_fd_query(int pid, int fd, __u32 flags, char *buf, __u32 *buf_len,
 +		      __u32 *prog_id, __u32 *fd_type, __u64 *probe_offset,
 +		      __u64 *probe_addr);
++=======
+ LIBBPF_API int bpf_map_lookup_elem(int fd, const void *key, void *value);
+ LIBBPF_API int bpf_map_lookup_and_delete_elem(int fd, const void *key,
+ 					      void *value);
+ LIBBPF_API int bpf_map_delete_elem(int fd, const void *key);
+ LIBBPF_API int bpf_map_get_next_key(int fd, const void *key, void *next_key);
+ LIBBPF_API int bpf_obj_pin(int fd, const char *pathname);
+ LIBBPF_API int bpf_obj_get(const char *pathname);
+ LIBBPF_API int bpf_prog_attach(int prog_fd, int attachable_fd,
+ 			       enum bpf_attach_type type, unsigned int flags);
+ LIBBPF_API int bpf_prog_detach(int attachable_fd, enum bpf_attach_type type);
+ LIBBPF_API int bpf_prog_detach2(int prog_fd, int attachable_fd,
+ 				enum bpf_attach_type type);
+ 
+ struct bpf_prog_test_run_attr {
+ 	int prog_fd;
+ 	int repeat;
+ 	const void *data_in;
+ 	__u32 data_size_in;
+ 	void *data_out;      /* optional */
+ 	__u32 data_size_out; /* in: max length of data_out
+ 			      * out: length of data_out */
+ 	__u32 retval;        /* out: return code of the BPF program */
+ 	__u32 duration;      /* out: average per repetition in ns */
+ };
+ 
+ LIBBPF_API int bpf_prog_test_run_xattr(struct bpf_prog_test_run_attr *test_attr);
+ 
+ /*
+  * bpf_prog_test_run does not check that data_out is large enough. Consider
+  * using bpf_prog_test_run_xattr instead.
+  */
+ LIBBPF_API int bpf_prog_test_run(int prog_fd, int repeat, void *data,
+ 				 __u32 size, void *data_out, __u32 *size_out,
+ 				 __u32 *retval, __u32 *duration);
+ LIBBPF_API int bpf_prog_get_next_id(__u32 start_id, __u32 *next_id);
+ LIBBPF_API int bpf_map_get_next_id(__u32 start_id, __u32 *next_id);
+ LIBBPF_API int bpf_prog_get_fd_by_id(__u32 id);
+ LIBBPF_API int bpf_map_get_fd_by_id(__u32 id);
+ LIBBPF_API int bpf_btf_get_fd_by_id(__u32 id);
+ LIBBPF_API int bpf_obj_get_info_by_fd(int prog_fd, void *info, __u32 *info_len);
+ LIBBPF_API int bpf_prog_query(int target_fd, enum bpf_attach_type type,
+ 			      __u32 query_flags, __u32 *attach_flags,
+ 			      __u32 *prog_ids, __u32 *prog_cnt);
+ LIBBPF_API int bpf_raw_tracepoint_open(const char *name, int prog_fd);
+ LIBBPF_API int bpf_load_btf(void *btf, __u32 btf_size, char *log_buf,
+ 			    __u32 log_buf_size, bool do_log);
+ LIBBPF_API int bpf_task_fd_query(int pid, int fd, __u32 flags, char *buf,
+ 				 __u32 *buf_len, __u32 *prog_id, __u32 *fd_type,
+ 				 __u64 *probe_offset, __u64 *probe_addr);
+ 
+ #ifdef __cplusplus
+ } /* extern "C" */
++>>>>>>> 64a975913b31 (libbpf: add bpf_prog_test_run_xattr)
  #endif
 -
 -#endif /* __LIBBPF_BPF_H */
diff --git a/tools/lib/bpf/bpf.c b/tools/lib/bpf/bpf.c
index 2accecf0ac8f..961724743429 100644
--- a/tools/lib/bpf/bpf.c
+++ b/tools/lib/bpf/bpf.c
@@ -415,6 +415,29 @@ int bpf_prog_test_run(int prog_fd, int repeat, void *data, __u32 size,
 	return ret;
 }
 
+int bpf_prog_test_run_xattr(struct bpf_prog_test_run_attr *test_attr)
+{
+	union bpf_attr attr;
+	int ret;
+
+	if (!test_attr->data_out && test_attr->data_size_out > 0)
+		return -EINVAL;
+
+	bzero(&attr, sizeof(attr));
+	attr.test.prog_fd = test_attr->prog_fd;
+	attr.test.data_in = ptr_to_u64(test_attr->data_in);
+	attr.test.data_out = ptr_to_u64(test_attr->data_out);
+	attr.test.data_size_in = test_attr->data_size_in;
+	attr.test.data_size_out = test_attr->data_size_out;
+	attr.test.repeat = test_attr->repeat;
+
+	ret = sys_bpf(BPF_PROG_TEST_RUN, &attr, sizeof(attr));
+	test_attr->data_size_out = attr.test.data_size_out;
+	test_attr->retval = attr.test.retval;
+	test_attr->duration = attr.test.duration;
+	return ret;
+}
+
 int bpf_prog_get_next_id(__u32 start_id, __u32 *next_id)
 {
 	union bpf_attr attr;
* Unmerged path tools/lib/bpf/bpf.h
diff --git a/tools/lib/bpf/libbpf.map b/tools/lib/bpf/libbpf.map
index 4fb29f6d7a80..8deff22d61bb 100644
--- a/tools/lib/bpf/libbpf.map
+++ b/tools/lib/bpf/libbpf.map
@@ -65,6 +65,7 @@ LIBBPF_0.0.1 {
 		bpf_prog_load_xattr;
 		bpf_prog_query;
 		bpf_prog_test_run;
+		bpf_prog_test_run_xattr;
 		bpf_program__fd;
 		bpf_program__is_kprobe;
 		bpf_program__is_perf_event;
