flow_offload: add flow action infrastructure

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit e3ab786b42535da00c731c3585165e88bf35ab09
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/e3ab786b.failed

This new infrastructure defines the nic actions that you can perform
from existing network drivers. This infrastructure allows us to avoid a
direct dependency with the native software TC action representation.

	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e3ab786b42535da00c731c3585165e88bf35ab09)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/flow_offload.h
#	include/net/pkt_cls.h
#	net/core/flow_offload.c
#	net/sched/cls_flower.c
diff --cc include/net/pkt_cls.h
index 222c878d3994,74a7582ad47c..000000000000
--- a/include/net/pkt_cls.h
+++ b/include/net/pkt_cls.h
@@@ -633,8 -620,9 +633,14 @@@ tcf_match_indev(struct sk_buff *skb, in
  }
  #endif /* CONFIG_NET_CLS_IND */
  
++<<<<<<< HEAD
 +int tc_setup_cb_call(struct tcf_block *block, struct tcf_exts *exts,
 +		     enum tc_setup_type type, void *type_data, bool err_stop);
++=======
+ int tc_setup_cb_call(struct tcf_block *block, enum tc_setup_type type,
+ 		     void *type_data, bool err_stop);
+ unsigned int tcf_exts_num_actions(struct tcf_exts *exts);
++>>>>>>> e3ab786b4253 (flow_offload: add flow action infrastructure)
  
  enum tc_block_command {
  	TC_BLOCK_BIND,
diff --cc net/sched/cls_flower.c
index d984c61e0ed5,0062c9133a22..000000000000
--- a/net/sched/cls_flower.c
+++ b/net/sched/cls_flower.c
@@@ -303,6 -381,10 +303,13 @@@ static int fl_hw_replace_filter(struct 
  	bool skip_sw = tc_skip_sw(f->flags);
  	int err;
  
++<<<<<<< HEAD
++=======
+ 	cls_flower.rule = flow_rule_alloc(tcf_exts_num_actions(&f->exts));
+ 	if (!cls_flower.rule)
+ 		return -ENOMEM;
+ 
++>>>>>>> e3ab786b4253 (flow_offload: add flow action infrastructure)
  	tc_cls_common_offload_init(&cls_flower.common, tp, f->flags, extack);
  	cls_flower.command = TC_CLSFLOWER_REPLACE;
  	cls_flower.cookie = (unsigned long) f;
@@@ -1344,6 -1469,11 +1351,14 @@@ static int fl_reoffload(struct tcf_prot
  			if (tc_skip_hw(f->flags))
  				continue;
  
++<<<<<<< HEAD
++=======
+ 			cls_flower.rule =
+ 				flow_rule_alloc(tcf_exts_num_actions(&f->exts));
+ 			if (!cls_flower.rule)
+ 				return -ENOMEM;
+ 
++>>>>>>> e3ab786b4253 (flow_offload: add flow action infrastructure)
  			tc_cls_common_offload_init(&cls_flower.common, tp,
  						   f->flags, extack);
  			cls_flower.command = add ?
@@@ -1377,6 -1509,10 +1392,13 @@@ static void fl_hw_create_tmplt(struct t
  	struct tcf_block *block = chain->block;
  	struct tcf_exts dummy_exts = { 0, };
  
++<<<<<<< HEAD
++=======
+ 	cls_flower.rule = flow_rule_alloc(0);
+ 	if (!cls_flower.rule)
+ 		return -ENOMEM;
+ 
++>>>>>>> e3ab786b4253 (flow_offload: add flow action infrastructure)
  	cls_flower.common.chain_index = chain->index;
  	cls_flower.command = TC_CLSFLOWER_TMPLT_CREATE;
  	cls_flower.cookie = (unsigned long) tmplt;
* Unmerged path include/net/flow_offload.h
* Unmerged path net/core/flow_offload.c
* Unmerged path include/net/flow_offload.h
* Unmerged path include/net/pkt_cls.h
* Unmerged path net/core/flow_offload.c
diff --git a/net/sched/cls_api.c b/net/sched/cls_api.c
index 7787b5e79877..803c71ac803d 100644
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@ -31,6 +31,7 @@
 #include <net/netlink.h>
 #include <net/pkt_sched.h>
 #include <net/pkt_cls.h>
+#include <net/tc_act/tc_pedit.h>
 
 extern const struct nla_policy rtm_tca_policy[TCA_MAX + 1];
 
@@ -2566,6 +2567,22 @@ int tc_setup_cb_call(struct tcf_block *block, struct tcf_exts *exts,
 }
 EXPORT_SYMBOL(tc_setup_cb_call);
 
+unsigned int tcf_exts_num_actions(struct tcf_exts *exts)
+{
+	unsigned int num_acts = 0;
+	struct tc_action *act;
+	int i;
+
+	tcf_exts_for_each_action(i, act, exts) {
+		if (is_tcf_pedit(act))
+			num_acts += tcf_pedit_nkeys(act);
+		else
+			num_acts++;
+	}
+	return num_acts;
+}
+EXPORT_SYMBOL(tcf_exts_num_actions);
+
 static __net_init int tcf_net_init(struct net *net)
 {
 	struct tcf_net *tn = net_generic(net, tcf_net_id);
* Unmerged path net/sched/cls_flower.c
