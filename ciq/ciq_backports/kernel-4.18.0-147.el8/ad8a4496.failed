IB/uverbs: Add support to advise_mr

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Moni Shoua <monis@mellanox.com>
commit ad8a4496757f6f7344011a20a07195bd27e3989c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/ad8a4496.failed

Add new ioctl method for the MR object - ADVISE_MR.

This command can be used by users to give an advice or directions to the
kernel about an address range that belongs to memory regions.

A new ib_device callback, advise_mr(), is introduced here to suupport the
new command. This command takes the following arguments:

- pd:		The protection domain to which all memory regions belong
- advice: 	The type of the advice
	  	* IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH - Pre-fetch a range of
		an on-demand paging MR
	  	* IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_WRITE - Pre-fetch a range
		of an on-demand paging MR with write intention
- flags:	The properties of the advice
		* IB_UVERBS_ADVISE_MR_FLAG_FLUSH - Operation must end before
		return to the caller
- sg_list:	The list of memory ranges
- num_sge:	The number of memory ranges in the list
- attrs:	More attributes to be parsed by the provider

	Signed-off-by: Moni Shoua <monis@mellanox.com>
	Reviewed-by: Guy Levi <guyle@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit ad8a4496757f6f7344011a20a07195bd27e3989c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_std_types_mr.c
#	include/uapi/rdma/ib_user_ioctl_cmds.h
diff --cc drivers/infiniband/core/uverbs_std_types_mr.c
index 68f7cadf088f,71dfa5e5938e..000000000000
--- a/drivers/infiniband/core/uverbs_std_types_mr.c
+++ b/drivers/infiniband/core/uverbs_std_types_mr.c
@@@ -39,14 -39,54 +39,55 @@@ static int uverbs_free_mr(struct ib_uob
  	return ib_dereg_mr((struct ib_mr *)uobject->object);
  }
  
++<<<<<<< HEAD
 +static int UVERBS_HANDLER(UVERBS_METHOD_DM_MR_REG)(struct ib_device *ib_dev,
 +						   struct ib_uverbs_file *file,
 +						   struct uverbs_attr_bundle *attrs)
++=======
+ static int UVERBS_HANDLER(UVERBS_METHOD_ADVISE_MR)(
+ 	struct uverbs_attr_bundle *attrs)
+ {
+ 	struct ib_pd *pd =
+ 		uverbs_attr_get_obj(attrs, UVERBS_ATTR_ADVISE_MR_PD_HANDLE);
+ 	enum ib_uverbs_advise_mr_advice advice;
+ 	struct ib_device *ib_dev = pd->device;
+ 	struct ib_sge *sg_list;
+ 	u32 num_sge;
+ 	u32 flags;
+ 	int ret;
+ 
+ 	/* FIXME: Extend the UAPI_DEF_OBJ_NEEDS_FN stuff.. */
+ 	if (!ib_dev->ops.advise_mr)
+ 		return -EOPNOTSUPP;
+ 
+ 	ret = uverbs_get_const(&advice, attrs, UVERBS_ATTR_ADVISE_MR_ADVICE);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = uverbs_get_flags32(&flags, attrs, UVERBS_ATTR_ADVISE_MR_FLAGS,
+ 				 IB_UVERBS_ADVISE_MR_FLAG_FLUSH);
+ 	if (ret)
+ 		return ret;
+ 
+ 	num_sge = uverbs_attr_ptr_get_array_size(
+ 		attrs, UVERBS_ATTR_ADVISE_MR_SGE_LIST, sizeof(struct ib_sge));
+ 	if (num_sge < 0)
+ 		return num_sge;
+ 
+ 	sg_list = uverbs_attr_get_alloced_ptr(attrs,
+ 					      UVERBS_ATTR_ADVISE_MR_SGE_LIST);
+ 	return ib_dev->ops.advise_mr(pd, advice, flags, sg_list, num_sge,
+ 				     attrs);
+ }
+ 
+ static int UVERBS_HANDLER(UVERBS_METHOD_DM_MR_REG)(
+ 	struct uverbs_attr_bundle *attrs)
++>>>>>>> ad8a4496757f (IB/uverbs: Add support to advise_mr)
  {
  	struct ib_dm_mr_attr attr = {};
 -	struct ib_uobject *uobj =
 -		uverbs_attr_get_uobject(attrs, UVERBS_ATTR_REG_DM_MR_HANDLE);
 -	struct ib_dm *dm =
 -		uverbs_attr_get_obj(attrs, UVERBS_ATTR_REG_DM_MR_DM_HANDLE);
 -	struct ib_pd *pd =
 -		uverbs_attr_get_obj(attrs, UVERBS_ATTR_REG_DM_MR_PD_HANDLE);
 -	struct ib_device *ib_dev = pd->device;
 -
 +	struct ib_uobject *uobj;
 +	struct ib_dm *dm;
 +	struct ib_pd *pd;
  	struct ib_mr *mr;
  	int ret;
  
@@@ -115,33 -150,68 +156,98 @@@ err_dereg
  	return ret;
  }
  
++<<<<<<< HEAD
 +static DECLARE_UVERBS_NAMED_METHOD(UVERBS_METHOD_DM_MR_REG,
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_REG_DM_MR_HANDLE, UVERBS_OBJECT_MR,
 +			 UVERBS_ACCESS_NEW,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_REG_DM_MR_OFFSET,
 +			    UVERBS_ATTR_TYPE(u64),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_REG_DM_MR_LENGTH,
 +			    UVERBS_ATTR_TYPE(u64),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_REG_DM_MR_PD_HANDLE, UVERBS_OBJECT_PD,
 +			 UVERBS_ACCESS_READ,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_REG_DM_MR_ACCESS_FLAGS,
++=======
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	UVERBS_METHOD_ADVISE_MR,
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_ADVISE_MR_PD_HANDLE,
+ 			UVERBS_OBJECT_PD,
+ 			UVERBS_ACCESS_READ,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_CONST_IN(UVERBS_ATTR_ADVISE_MR_ADVICE,
+ 			     enum ib_uverbs_advise_mr_advice,
+ 			     UA_MANDATORY),
+ 	UVERBS_ATTR_FLAGS_IN(UVERBS_ATTR_ADVISE_MR_FLAGS,
+ 			     enum ib_uverbs_advise_mr_flag,
+ 			     UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_ADVISE_MR_SGE_LIST,
+ 			   UVERBS_ATTR_MIN_SIZE(sizeof(struct ib_uverbs_sge)),
+ 			   UA_MANDATORY,
+ 			   UA_ALLOC_AND_COPY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	UVERBS_METHOD_DM_MR_REG,
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_REG_DM_MR_HANDLE,
+ 			UVERBS_OBJECT_MR,
+ 			UVERBS_ACCESS_NEW,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_REG_DM_MR_OFFSET,
+ 			   UVERBS_ATTR_TYPE(u64),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_REG_DM_MR_LENGTH,
+ 			   UVERBS_ATTR_TYPE(u64),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_REG_DM_MR_PD_HANDLE,
+ 			UVERBS_OBJECT_PD,
+ 			UVERBS_ACCESS_READ,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_FLAGS_IN(UVERBS_ATTR_REG_DM_MR_ACCESS_FLAGS,
+ 			     enum ib_access_flags),
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_REG_DM_MR_DM_HANDLE,
+ 			UVERBS_OBJECT_DM,
+ 			UVERBS_ACCESS_READ,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_REG_DM_MR_RESP_LKEY,
++>>>>>>> ad8a4496757f (IB/uverbs: Add support to advise_mr)
  			    UVERBS_ATTR_TYPE(u32),
 -			    UA_MANDATORY),
 -	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_REG_DM_MR_RESP_RKEY,
 -			    UVERBS_ATTR_TYPE(u32),
 -			    UA_MANDATORY));
 -
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_REG_DM_MR_DM_HANDLE, UVERBS_OBJECT_DM,
 +			 UVERBS_ACCESS_READ,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_REG_DM_MR_RESP_LKEY,
 +			     UVERBS_ATTR_TYPE(u32),
 +			     UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_REG_DM_MR_RESP_RKEY,
 +			     UVERBS_ATTR_TYPE(u32),
 +			     UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
 +
++<<<<<<< HEAD
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_MR,
 +			    /* 1 is used in order to free the MR after all the MWs */
 +			    &UVERBS_TYPE_ALLOC_IDR(1, uverbs_free_mr),
 +			    &UVERBS_METHOD(UVERBS_METHOD_DM_MR_REG));
++=======
+ DECLARE_UVERBS_NAMED_METHOD_DESTROY(
+ 	UVERBS_METHOD_MR_DESTROY,
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_DESTROY_MR_HANDLE,
+ 			UVERBS_OBJECT_MR,
+ 			UVERBS_ACCESS_DESTROY,
+ 			UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_OBJECT(
+ 	UVERBS_OBJECT_MR,
+ 	UVERBS_TYPE_ALLOC_IDR(uverbs_free_mr),
+ 	&UVERBS_METHOD(UVERBS_METHOD_DM_MR_REG),
+ 	&UVERBS_METHOD(UVERBS_METHOD_MR_DESTROY),
+ 	&UVERBS_METHOD(UVERBS_METHOD_ADVISE_MR));
+ 
+ const struct uapi_definition uverbs_def_obj_mr[] = {
+ 	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_MR,
+ 				      UAPI_DEF_OBJ_NEEDS_FN(dereg_mr)),
+ 	{}
+ };
++>>>>>>> ad8a4496757f (IB/uverbs: Add support to advise_mr)
diff --cc include/uapi/rdma/ib_user_ioctl_cmds.h
index 2c881aaf05c2,f04647852add..000000000000
--- a/include/uapi/rdma/ib_user_ioctl_cmds.h
+++ b/include/uapi/rdma/ib_user_ioctl_cmds.h
@@@ -135,6 -146,19 +135,22 @@@ enum uverbs_attrs_reg_dm_mr_cmd_attr_id
  
  enum uverbs_methods_mr {
  	UVERBS_METHOD_DM_MR_REG,
++<<<<<<< HEAD
++=======
+ 	UVERBS_METHOD_MR_DESTROY,
+ 	UVERBS_METHOD_ADVISE_MR,
+ };
+ 
+ enum uverbs_attrs_mr_destroy_ids {
+ 	UVERBS_ATTR_DESTROY_MR_HANDLE,
++>>>>>>> ad8a4496757f (IB/uverbs: Add support to advise_mr)
+ };
+ 
+ enum uverbs_attrs_advise_mr_cmd_attr_ids {
+ 	UVERBS_ATTR_ADVISE_MR_PD_HANDLE,
+ 	UVERBS_ATTR_ADVISE_MR_ADVICE,
+ 	UVERBS_ATTR_ADVISE_MR_FLAGS,
+ 	UVERBS_ATTR_ADVISE_MR_SGE_LIST,
  };
  
  enum uverbs_attrs_create_counters_cmd_attr_ids {
* Unmerged path drivers/infiniband/core/uverbs_std_types_mr.c
diff --git a/include/rdma/ib_verbs.h b/include/rdma/ib_verbs.h
index 302ba690752e..25e564d60ba8 100644
--- a/include/rdma/ib_verbs.h
+++ b/include/rdma/ib_verbs.h
@@ -2426,6 +2426,10 @@ struct ib_device_ops {
 	int (*dereg_mr)(struct ib_mr *mr);
 	struct ib_mr *(*alloc_mr)(struct ib_pd *pd, enum ib_mr_type mr_type,
 				  u32 max_num_sg);
+	int (*advise_mr)(struct ib_pd *pd,
+			 enum ib_uverbs_advise_mr_advice advice, u32 flags,
+			 struct ib_sge *sg_list, u32 num_sge,
+			 struct uverbs_attr_bundle *attrs);
 	int (*map_mr_sg)(struct ib_mr *mr, struct scatterlist *sg, int sg_nents,
 			 unsigned int *sg_offset);
 	int (*check_mr_status)(struct ib_mr *mr, u32 check_mask,
* Unmerged path include/uapi/rdma/ib_user_ioctl_cmds.h
diff --git a/include/uapi/rdma/ib_user_ioctl_verbs.h b/include/uapi/rdma/ib_user_ioctl_verbs.h
index 6cdf192070a2..9dcd345b852a 100644
--- a/include/uapi/rdma/ib_user_ioctl_verbs.h
+++ b/include/uapi/rdma/ib_user_ioctl_verbs.h
@@ -157,4 +157,13 @@ enum ib_uverbs_read_counters_flags {
 	IB_UVERBS_READ_COUNTERS_PREFER_CACHED = 1 << 0,
 };
 
+enum ib_uverbs_advise_mr_advice {
+	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH,
+	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_WRITE,
+};
+
+enum ib_uverbs_advise_mr_flag {
+	IB_UVERBS_ADVISE_MR_FLAG_FLUSH = 1 << 0,
+};
+
 #endif
