rtnetlink: Move ifm in valid_fdb_dump_legacy to closer to use

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author David Ahern <dsahern@gmail.com>
commit 4565d7e5a300fcc3a41d40dbcf7ff9d1fe316814
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/4565d7e5.failed

Move setting of local variable ifm to after the message parsing in
valid_fdb_dump_legacy. Avoid potential future use of unchecked variable.

Fixes: 8dfbda19a21b ("rtnetlink: Move input checking for rtnl_fdb_dump to helper")
	Reported-by: Christian Brauner <christian@brauner.io>
	Signed-off-by: David Ahern <dsahern@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4565d7e5a300fcc3a41d40dbcf7ff9d1fe316814)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/rtnetlink.c
diff --cc net/core/rtnetlink.c
index b3d57e308987,2715f8d21517..000000000000
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@@ -3766,6 -3799,94 +3766,97 @@@ out
  }
  EXPORT_SYMBOL(ndo_dflt_fdb_dump);
  
++<<<<<<< HEAD
++=======
+ static int valid_fdb_dump_strict(const struct nlmsghdr *nlh,
+ 				 int *br_idx, int *brport_idx,
+ 				 struct netlink_ext_ack *extack)
+ {
+ 	struct nlattr *tb[NDA_MAX + 1];
+ 	struct ndmsg *ndm;
+ 	int err, i;
+ 
+ 	if (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ndm))) {
+ 		NL_SET_ERR_MSG(extack, "Invalid header for fdb dump request");
+ 		return -EINVAL;
+ 	}
+ 
+ 	ndm = nlmsg_data(nlh);
+ 	if (ndm->ndm_pad1  || ndm->ndm_pad2  || ndm->ndm_state ||
+ 	    ndm->ndm_flags || ndm->ndm_type) {
+ 		NL_SET_ERR_MSG(extack, "Invalid values in header for fbd dump request");
+ 		return -EINVAL;
+ 	}
+ 
+ 	err = nlmsg_parse_strict(nlh, sizeof(struct ndmsg), tb, NDA_MAX,
+ 				 NULL, extack);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	*brport_idx = ndm->ndm_ifindex;
+ 	for (i = 0; i <= NDA_MAX; ++i) {
+ 		if (!tb[i])
+ 			continue;
+ 
+ 		switch (i) {
+ 		case NDA_IFINDEX:
+ 			if (nla_len(tb[i]) != sizeof(u32)) {
+ 				NL_SET_ERR_MSG(extack, "Invalid IFINDEX attribute in fdb dump request");
+ 				return -EINVAL;
+ 			}
+ 			*brport_idx = nla_get_u32(tb[NDA_IFINDEX]);
+ 			break;
+ 		case NDA_MASTER:
+ 			if (nla_len(tb[i]) != sizeof(u32)) {
+ 				NL_SET_ERR_MSG(extack, "Invalid MASTER attribute in fdb dump request");
+ 				return -EINVAL;
+ 			}
+ 			*br_idx = nla_get_u32(tb[NDA_MASTER]);
+ 			break;
+ 		default:
+ 			NL_SET_ERR_MSG(extack, "Unsupported attribute in fdb dump request");
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int valid_fdb_dump_legacy(const struct nlmsghdr *nlh,
+ 				 int *br_idx, int *brport_idx,
+ 				 struct netlink_ext_ack *extack)
+ {
+ 	struct nlattr *tb[IFLA_MAX+1];
+ 	int err;
+ 
+ 	/* A hack to preserve kernel<->userspace interface.
+ 	 * Before Linux v4.12 this code accepted ndmsg since iproute2 v3.3.0.
+ 	 * However, ndmsg is shorter than ifinfomsg thus nlmsg_parse() bails.
+ 	 * So, check for ndmsg with an optional u32 attribute (not used here).
+ 	 * Fortunately these sizes don't conflict with the size of ifinfomsg
+ 	 * with an optional attribute.
+ 	 */
+ 	if (nlmsg_len(nlh) != sizeof(struct ndmsg) &&
+ 	    (nlmsg_len(nlh) != sizeof(struct ndmsg) +
+ 	     nla_attr_size(sizeof(u32)))) {
+ 		struct ifinfomsg *ifm;
+ 
+ 		err = nlmsg_parse(nlh, sizeof(struct ifinfomsg), tb, IFLA_MAX,
+ 				  ifla_policy, extack);
+ 		if (err < 0) {
+ 			return -EINVAL;
+ 		} else if (err == 0) {
+ 			if (tb[IFLA_MASTER])
+ 				*br_idx = nla_get_u32(tb[IFLA_MASTER]);
+ 		}
+ 
+ 		ifm = nlmsg_data(nlh);
+ 		*brport_idx = ifm->ifi_index;
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> 4565d7e5a300 (rtnetlink: Move ifm in valid_fdb_dump_legacy to closer to use)
  static int rtnl_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb)
  {
  	struct net_device *dev;
* Unmerged path net/core/rtnetlink.c
