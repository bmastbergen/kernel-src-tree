tipc: add trace_events for tipc bearer

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Tuong Lien <tuong.t.lien@dektech.com.au>
commit cf5f55f7f01397015dfa390256f2c20ceaabfcfb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/cf5f55f7.failed

The commit adds the new trace_event for TIPC bearer, L2 device event:

trace_tipc_l2_device_event()

Also, it puts the trace at the tipc_l2_device_event() function, then
the device/bearer events and related info can be traced out during
runtime when needed.

	Acked-by: Ying Xue <ying.xue@windriver.com>
	Tested-by: Ying Xue <ying.xue@windriver.com>
	Acked-by: Jon Maloy <jon.maloy@ericsson.com>
	Signed-off-by: Tuong Lien <tuong.t.lien@dektech.com.au>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit cf5f55f7f01397015dfa390256f2c20ceaabfcfb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/tipc/trace.h
diff --cc net/tipc/trace.h
index 4c74927df685,4d8e00483afc..000000000000
--- a/net/tipc/trace.h
+++ b/net/tipc/trace.h
@@@ -74,6 -74,58 +74,61 @@@ enum 
  };
  #endif
  
++<<<<<<< HEAD
++=======
+ /* Link & Node FSM states: */
+ #define state_sym(val)							  \
+ 	__print_symbolic(val,						  \
+ 			{(0xe),		"ESTABLISHED"			},\
+ 			{(0xe << 4),	"ESTABLISHING"			},\
+ 			{(0x1 << 8),	"RESET"				},\
+ 			{(0x2 << 12),	"RESETTING"			},\
+ 			{(0xd << 16),	"PEER_RESET"			},\
+ 			{(0xf << 20),	"FAILINGOVER"			},\
+ 			{(0xc << 24),	"SYNCHING"			},\
+ 			{(0xdd),	"SELF_DOWN_PEER_DOWN"		},\
+ 			{(0xaa),	"SELF_UP_PEER_UP"		},\
+ 			{(0xd1),	"SELF_DOWN_PEER_LEAVING"	},\
+ 			{(0xac),	"SELF_UP_PEER_COMING"		},\
+ 			{(0xca),	"SELF_COMING_PEER_UP"		},\
+ 			{(0x1d),	"SELF_LEAVING_PEER_DOWN"	},\
+ 			{(0xf0),	"FAILINGOVER"			},\
+ 			{(0xcc),	"SYNCHING"			})
+ 
+ /* Link & Node FSM events: */
+ #define evt_sym(val)							  \
+ 	__print_symbolic(val,						  \
+ 			{(0xec1ab1e),	"ESTABLISH_EVT"			},\
+ 			{(0x9eed0e),	"PEER_RESET_EVT"		},\
+ 			{(0xfa110e),	"FAILURE_EVT"			},\
+ 			{(0x10ca1d0e),	"RESET_EVT"			},\
+ 			{(0xfa110bee),	"FAILOVER_BEGIN_EVT"		},\
+ 			{(0xfa110ede),	"FAILOVER_END_EVT"		},\
+ 			{(0xc1ccbee),	"SYNCH_BEGIN_EVT"		},\
+ 			{(0xc1ccede),	"SYNCH_END_EVT"			},\
+ 			{(0xece),	"SELF_ESTABL_CONTACT_EVT"	},\
+ 			{(0x1ce),	"SELF_LOST_CONTACT_EVT"		},\
+ 			{(0x9ece),	"PEER_ESTABL_CONTACT_EVT"	},\
+ 			{(0x91ce),	"PEER_LOST_CONTACT_EVT"		},\
+ 			{(0xfbe),	"FAILOVER_BEGIN_EVT"		},\
+ 			{(0xfee),	"FAILOVER_END_EVT"		},\
+ 			{(0xcbe),	"SYNCH_BEGIN_EVT"		},\
+ 			{(0xcee),	"SYNCH_END_EVT"			})
+ 
+ /* Bearer, net device events: */
+ #define dev_evt_sym(val)						  \
+ 	__print_symbolic(val,						  \
+ 			{(NETDEV_CHANGE),	"NETDEV_CHANGE"		},\
+ 			{(NETDEV_GOING_DOWN),	"NETDEV_GOING_DOWN"	},\
+ 			{(NETDEV_UP),		"NETDEV_UP"		},\
+ 			{(NETDEV_CHANGEMTU),	"NETDEV_CHANGEMTU"	},\
+ 			{(NETDEV_CHANGEADDR),	"NETDEV_CHANGEADDR"	},\
+ 			{(NETDEV_UNREGISTER),	"NETDEV_UNREGISTER"	},\
+ 			{(NETDEV_CHANGENAME),	"NETDEV_CHANGENAME"	})
+ 
+ extern unsigned long sysctl_tipc_sk_filter[5] __read_mostly;
+ 
++>>>>>>> cf5f55f7f013 (tipc: add trace_events for tipc bearer)
  int tipc_skb_dump(struct sk_buff *skb, bool more, char *buf);
  int tipc_list_dump(struct sk_buff_head *list, bool more, char *buf);
  int tipc_sk_dump(struct sock *sk, u16 dqueues, char *buf);
@@@ -220,7 -348,79 +275,39 @@@ DEFINE_EVENT(tipc_node_class, name, 
  	TP_PROTO(struct tipc_node *n, bool more, const char *header), \
  	TP_ARGS(n, more, header))
  DEFINE_NODE_EVENT(tipc_node_dump);
 -DEFINE_NODE_EVENT(tipc_node_create);
 -DEFINE_NODE_EVENT(tipc_node_delete);
 -DEFINE_NODE_EVENT(tipc_node_lost_contact);
 -DEFINE_NODE_EVENT(tipc_node_timeout);
 -DEFINE_NODE_EVENT(tipc_node_link_up);
 -DEFINE_NODE_EVENT(tipc_node_link_down);
 -DEFINE_NODE_EVENT(tipc_node_reset_links);
 -DEFINE_NODE_EVENT(tipc_node_check_state);
 -
 -DECLARE_EVENT_CLASS(tipc_fsm_class,
 -
 -	TP_PROTO(const char *name, u32 os, u32 ns, int evt),
 -
 -	TP_ARGS(name, os, ns, evt),
 -
 -	TP_STRUCT__entry(
 -		__string(name, name)
 -		__field(u32, os)
 -		__field(u32, ns)
 -		__field(u32, evt)
 -	),
 -
 -	TP_fast_assign(
 -		__assign_str(name, name);
 -		__entry->os = os;
 -		__entry->ns = ns;
 -		__entry->evt = evt;
 -	),
 -
 -	TP_printk("<%s> %s--(%s)->%s\n", __get_str(name),
 -		  state_sym(__entry->os), evt_sym(__entry->evt),
 -		  state_sym(__entry->ns))
 -);
 -
 -#define DEFINE_FSM_EVENT(fsm_name) \
 -DEFINE_EVENT(tipc_fsm_class, fsm_name, \
 -	TP_PROTO(const char *name, u32 os, u32 ns, int evt), \
 -	TP_ARGS(name, os, ns, evt))
 -DEFINE_FSM_EVENT(tipc_link_fsm);
 -DEFINE_FSM_EVENT(tipc_node_fsm);
  
+ TRACE_EVENT(tipc_l2_device_event,
+ 
+ 	TP_PROTO(struct net_device *dev, struct tipc_bearer *b,
+ 		 unsigned long evt),
+ 
+ 	TP_ARGS(dev, b, evt),
+ 
+ 	TP_STRUCT__entry(
+ 		__string(dev_name, dev->name)
+ 		__string(b_name, b->name)
+ 		__field(unsigned long, evt)
+ 		__field(u8, b_up)
+ 		__field(u8, carrier)
+ 		__field(u8, oper)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__assign_str(dev_name, dev->name);
+ 		__assign_str(b_name, b->name);
+ 		__entry->evt = evt;
+ 		__entry->b_up = test_bit(0, &b->up);
+ 		__entry->carrier = netif_carrier_ok(dev);
+ 		__entry->oper = netif_oper_up(dev);
+ 	),
+ 
+ 	TP_printk("%s on: <%s>/<%s> oper: %s carrier: %s bearer: %s\n",
+ 		  dev_evt_sym(__entry->evt), __get_str(dev_name),
+ 		  __get_str(b_name), (__entry->oper) ? "up" : "down",
+ 		  (__entry->carrier) ? "ok" : "notok",
+ 		  (__entry->b_up) ? "up" : "down")
+ );
+ 
  #endif /* _TIPC_TRACE_H */
  
  /* This part must be outside protection */
diff --git a/net/tipc/bearer.c b/net/tipc/bearer.c
index 8424f0960166..bef44275b658 100644
--- a/net/tipc/bearer.c
+++ b/net/tipc/bearer.c
@@ -43,6 +43,7 @@
 #include "bcast.h"
 #include "netlink.h"
 #include "udp_media.h"
+#include "trace.h"
 
 #define MAX_ADDR_STR 60
 
@@ -608,6 +609,7 @@ static int tipc_l2_device_event(struct notifier_block *nb, unsigned long evt,
 	if (!b)
 		return NOTIFY_DONE;
 
+	trace_tipc_l2_device_event(dev, b, evt);
 	switch (evt) {
 	case NETDEV_CHANGE:
 		if (netif_carrier_ok(dev) && netif_oper_up(dev)) {
* Unmerged path net/tipc/trace.h
