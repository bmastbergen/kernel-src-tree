tipc: add trace_events for tipc node

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Tuong Lien <tuong.t.lien@dektech.com.au>
commit eb18a510b5cd4daeb9736ad8db57a9fc49db185b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/eb18a510.failed

The commit adds the new trace_events for TIPC node object:

trace_tipc_node_create()
trace_tipc_node_delete()
trace_tipc_node_lost_contact()
trace_tipc_node_timeout()
trace_tipc_node_link_up()
trace_tipc_node_link_down()
trace_tipc_node_reset_links()
trace_tipc_node_fsm_evt()
trace_tipc_node_check_state()

Also, enables the traces for the following cases:
- When a node is created/deleted;
- When a node contact is lost;
- When a node timer is timed out;
- When a node link is up/down;
- When all node links are reset;
- When node state is changed;
- When a skb comes and node state needs to be checked/updated.

	Acked-by: Ying Xue <ying.xue@windriver.com>
	Tested-by: Ying Xue <ying.xue@windriver.com>
	Acked-by: Jon Maloy <jon.maloy@ericsson.com>
	Signed-off-by: Tuong Lien <tuong.t.lien@dektech.com.au>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit eb18a510b5cd4daeb9736ad8db57a9fc49db185b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/tipc/trace.h
diff --cc net/tipc/trace.h
index 4c74927df685,4d05141866aa..000000000000
--- a/net/tipc/trace.h
+++ b/net/tipc/trace.h
@@@ -220,7 -337,47 +220,50 @@@ DEFINE_EVENT(tipc_node_class, name, 
  	TP_PROTO(struct tipc_node *n, bool more, const char *header), \
  	TP_ARGS(n, more, header))
  DEFINE_NODE_EVENT(tipc_node_dump);
+ DEFINE_NODE_EVENT(tipc_node_create);
+ DEFINE_NODE_EVENT(tipc_node_delete);
+ DEFINE_NODE_EVENT(tipc_node_lost_contact);
+ DEFINE_NODE_EVENT(tipc_node_timeout);
+ DEFINE_NODE_EVENT(tipc_node_link_up);
+ DEFINE_NODE_EVENT(tipc_node_link_down);
+ DEFINE_NODE_EVENT(tipc_node_reset_links);
+ DEFINE_NODE_EVENT(tipc_node_check_state);
  
++<<<<<<< HEAD
++=======
+ DECLARE_EVENT_CLASS(tipc_fsm_class,
+ 
+ 	TP_PROTO(const char *name, u32 os, u32 ns, int evt),
+ 
+ 	TP_ARGS(name, os, ns, evt),
+ 
+ 	TP_STRUCT__entry(
+ 		__string(name, name)
+ 		__field(u32, os)
+ 		__field(u32, ns)
+ 		__field(u32, evt)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__assign_str(name, name);
+ 		__entry->os = os;
+ 		__entry->ns = ns;
+ 		__entry->evt = evt;
+ 	),
+ 
+ 	TP_printk("<%s> %s--(%s)->%s\n", __get_str(name),
+ 		  state_sym(__entry->os), evt_sym(__entry->evt),
+ 		  state_sym(__entry->ns))
+ );
+ 
+ #define DEFINE_FSM_EVENT(fsm_name) \
+ DEFINE_EVENT(tipc_fsm_class, fsm_name, \
+ 	TP_PROTO(const char *name, u32 os, u32 ns, int evt), \
+ 	TP_ARGS(name, os, ns, evt))
+ DEFINE_FSM_EVENT(tipc_link_fsm);
+ DEFINE_FSM_EVENT(tipc_node_fsm);
+ 
++>>>>>>> eb18a510b5cd (tipc: add trace_events for tipc node)
  #endif /* _TIPC_TRACE_H */
  
  /* This part must be outside protection */
diff --git a/net/tipc/node.c b/net/tipc/node.c
index ecb40d1c5036..62fa06a4ce02 100644
--- a/net/tipc/node.c
+++ b/net/tipc/node.c
@@ -433,6 +433,7 @@ static struct tipc_node *tipc_node_create(struct net *net, u32 addr,
 			break;
 	}
 	list_add_tail_rcu(&n->list, &temp_node->list);
+	trace_tipc_node_create(n, true, " ");
 exit:
 	spin_unlock_bh(&tn->node_list_lock);
 	return n;
@@ -460,6 +461,7 @@ static void tipc_node_delete_from_list(struct tipc_node *node)
 
 static void tipc_node_delete(struct tipc_node *node)
 {
+	trace_tipc_node_delete(node, true, " ");
 	tipc_node_delete_from_list(node);
 
 	del_timer_sync(&node->timer);
@@ -617,6 +619,7 @@ static void tipc_node_timeout(struct timer_list *t)
 	int bearer_id;
 	int rc = 0;
 
+	trace_tipc_node_timeout(n, false, " ");
 	if (!node_is_up(n) && tipc_node_cleanup(n)) {
 		/*Removing the reference of Timer*/
 		tipc_node_put(n);
@@ -682,6 +685,7 @@ static void __tipc_node_link_up(struct tipc_node *n, int bearer_id,
 
 	pr_debug("Established link <%s> on network plane %c\n",
 		 tipc_link_name(nl), tipc_link_plane(nl));
+	trace_tipc_node_link_up(n, true, " ");
 
 	/* Ensure that a STATE message goes first */
 	tipc_link_build_state_msg(nl, xmitq);
@@ -833,6 +837,7 @@ static void tipc_node_link_down(struct tipc_node *n, int bearer_id, bool delete)
 		/* Defuse pending tipc_node_link_up() */
 		tipc_link_fsm_evt(l, LINK_RESET_EVT);
 	}
+	trace_tipc_node_link_down(n, true, "node link down or deleted!");
 	tipc_node_write_unlock(n);
 	if (delete)
 		tipc_mon_remove_peer(n->net, n->addr, old_bearer_id);
@@ -1061,6 +1066,7 @@ static void tipc_node_reset_links(struct tipc_node *n)
 
 	pr_warn("Resetting all links to %x\n", n->addr);
 
+	trace_tipc_node_reset_links(n, true, " ");
 	for (i = 0; i < MAX_BEARERS; i++) {
 		tipc_node_link_down(n, i, false);
 	}
@@ -1236,11 +1242,13 @@ static void tipc_node_fsm_evt(struct tipc_node *n, int evt)
 		pr_err("Unknown node fsm state %x\n", state);
 		break;
 	}
+	trace_tipc_node_fsm(n->peer_id, n->state, state, evt);
 	n->state = state;
 	return;
 
 illegal_evt:
 	pr_err("Illegal node fsm evt %x in state %x\n", evt, state);
+	trace_tipc_node_fsm(n->peer_id, n->state, state, evt);
 }
 
 static void node_lost_contact(struct tipc_node *n,
@@ -1254,6 +1262,7 @@ static void node_lost_contact(struct tipc_node *n,
 
 	pr_debug("Lost contact with %x\n", n->addr);
 	n->delete_at = jiffies + msecs_to_jiffies(NODE_CLEANUP_AFTER);
+	trace_tipc_node_lost_contact(n, true, " ");
 
 	/* Clean up broadcast state */
 	tipc_bcast_remove_peer(n->net, n->bc_entry.link);
@@ -1582,6 +1591,10 @@ static bool tipc_node_check_state(struct tipc_node *n, struct sk_buff *skb,
 	struct tipc_media_addr *maddr;
 	int pb_id;
 
+	if (trace_tipc_node_check_state_enabled()) {
+		trace_tipc_skb_dump(skb, false, "skb for node state check");
+		trace_tipc_node_check_state(n, true, " ");
+	}
 	l = n->links[bearer_id].link;
 	if (!l)
 		return false;
@@ -1627,6 +1640,8 @@ static bool tipc_node_check_state(struct tipc_node *n, struct sk_buff *skb,
 		syncpt = oseqno + exp_pkts - 1;
 		if (pl && tipc_link_is_up(pl)) {
 			__tipc_node_link_down(n, &pb_id, xmitq, &maddr);
+			trace_tipc_node_link_down(n, true,
+						  "node link down <- failover!");
 			tipc_skb_queue_splice_tail_init(tipc_link_inputq(pl),
 							tipc_link_inputq(l));
 		}
* Unmerged path net/tipc/trace.h
