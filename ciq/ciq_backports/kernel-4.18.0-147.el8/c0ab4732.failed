net/tls: Do not use async crypto for non-data records

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [net] tls: Do not use async crypto for non-data records (Sabrina Dubroca) [1711821]
Rebuild_FUZZ: 96.08%
commit-author Vakul Garg <vakul.garg@nxp.com>
commit c0ab4732d4c658f74eb929d3f615d390f03d660c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/c0ab4732.failed

Addition of tls1.3 support broke tls1.2 handshake when async crypto
accelerator is used. This is because the record type for non-data
records is not propagated to user application. Also when async
decryption happens, the decryption does not stop when two different
types of records get dequeued and submitted for decryption. To address
it, we decrypt tls1.2 non-data records in synchronous way. We check
whether the record we just processed has same type as the previous one
before checking for async condition and jumping to dequeue next record.

Fixes: 130b392c6cd6b ("net: tls: Add tls 1.3 support")
	Signed-off-by: Vakul Garg <vakul.garg@nxp.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c0ab4732d4c658f74eb929d3f615d390f03d660c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/tls/tls_sw.c
diff --cc net/tls/tls_sw.c
index 3f443983a6b3,ae4784734547..000000000000
--- a/net/tls/tls_sw.c
+++ b/net/tls/tls_sw.c
@@@ -1312,21 -1623,73 +1312,52 @@@ int tls_sw_recvmsg(struct sock *sk
  	if (unlikely(flags & MSG_ERRQUEUE))
  		return sock_recv_errqueue(sk, msg, len, SOL_IP, IP_RECVERR);
  
 -	psock = sk_psock_get(sk);
  	lock_sock(sk);
  
 -	/* Process pending decrypted records. It must be non-zero-copy */
 -	err = process_rx_list(ctx, msg, 0, len, false, is_peek);
 -	if (err < 0) {
 -		tls_err_abort(sk, err);
 -		goto end;
 -	} else {
 -		copied = err;
 -	}
 -
 -	len = len - copied;
 -	if (len) {
 -		target = sock_rcvlowat(sk, flags & MSG_WAITALL, len);
 -		timeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);
 -	} else {
 -		goto recv_end;
 -	}
 -
 +	target = sock_rcvlowat(sk, flags & MSG_WAITALL, len);
 +	timeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);
  	do {
++<<<<<<< HEAD
++=======
+ 		bool retain_skb = false;
++>>>>>>> c0ab4732d4c6 (net/tls: Do not use async crypto for non-data records)
  		bool zc = false;
 -		int to_decrypt;
 +		bool async = false;
  		int chunk = 0;
+ 		bool async;
  
 -		skb = tls_wait_data(sk, psock, flags, timeo, &err);
 -		if (!skb) {
 -			if (psock) {
 -				int ret = __tcp_bpf_recvmsg(sk, psock,
 -							    msg, len, flags);
 -
 -				if (ret > 0) {
 -					decrypted += ret;
 -					len -= ret;
 -					continue;
 -				}
 -			}
 +		skb = tls_wait_data(sk, flags, timeo, &err);
 +		if (!skb)
  			goto recv_end;
 -		}
  
  		rxm = strp_msg(skb);
  
++<<<<<<< HEAD
++=======
+ 		to_decrypt = rxm->full_len - tls_ctx->rx.overhead_size;
+ 
+ 		if (to_decrypt <= len && !is_kvec && !is_peek &&
+ 		    ctx->control == TLS_RECORD_TYPE_DATA &&
+ 		    tls_ctx->crypto_recv.info.version != TLS_1_3_VERSION)
+ 			zc = true;
+ 
+ 		/* Do not use async mode if record is non-data */
+ 		if (ctx->control == TLS_RECORD_TYPE_DATA)
+ 			async = ctx->async_capable;
+ 		else
+ 			async = false;
+ 
+ 		err = decrypt_skb_update(sk, skb, &msg->msg_iter,
+ 					 &chunk, &zc, async);
+ 		if (err < 0 && err != -EINPROGRESS) {
+ 			tls_err_abort(sk, EBADMSG);
+ 			goto recv_end;
+ 		}
+ 
+ 		if (err == -EINPROGRESS)
+ 			num_async++;
+ 
++>>>>>>> c0ab4732d4c6 (net/tls: Do not use async crypto for non-data records)
  		if (!cmsg) {
  			int cerr;
  
@@@ -1344,65 -1707,50 +1375,77 @@@
  			goto recv_end;
  		}
  
++<<<<<<< HEAD
 +		if (!ctx->decrypted) {
 +			int to_copy = rxm->full_len - tls_ctx->rx.overhead_size;
 +
 +			if (!is_kvec && to_copy <= len &&
 +			    likely(!(flags & MSG_PEEK)))
 +				zc = true;
 +
 +			err = decrypt_skb_update(sk, skb, &msg->msg_iter,
 +						 &chunk, &zc);
 +			if (err < 0 && err != -EINPROGRESS) {
 +				tls_err_abort(sk, EBADMSG);
 +				goto recv_end;
++=======
+ 		if (async)
+ 			goto pick_next_record;
+ 
+ 		if (!zc) {
+ 			if (rxm->full_len > len) {
+ 				retain_skb = true;
+ 				chunk = len;
+ 			} else {
+ 				chunk = rxm->full_len;
++>>>>>>> c0ab4732d4c6 (net/tls: Do not use async crypto for non-data records)
  			}
  
 -			err = skb_copy_datagram_msg(skb, rxm->offset,
 -						    msg, chunk);
 -			if (err < 0)
 -				goto recv_end;
 -
 -			if (!is_peek) {
 -				rxm->offset = rxm->offset + chunk;
 -				rxm->full_len = rxm->full_len - chunk;
 +			if (err == -EINPROGRESS) {
 +				async = true;
 +				num_async++;
 +				goto pick_next_record;
  			}
 -		}
  
 -pick_next_record:
 -		if (chunk > len)
 -			chunk = len;
 +			ctx->decrypted = true;
 +		}
  
 -		decrypted += chunk;
 -		len -= chunk;
 +		if (!zc) {
 +			chunk = min_t(unsigned int, rxm->full_len, len);
  
 -		/* For async or peek case, queue the current skb */
 -		if (async || is_peek || retain_skb) {
 -			skb_queue_tail(&ctx->rx_list, skb);
 -			skb = NULL;
 +			err = skb_copy_datagram_msg(skb, rxm->offset, msg,
 +						    chunk);
 +			if (err < 0)
 +				goto recv_end;
  		}
  
 -		if (tls_sw_advance_skb(sk, skb, chunk)) {
 -			/* Return full control message to
 -			 * userspace before trying to parse
 -			 * another message type
 -			 */
 -			msg->msg_flags |= MSG_EOR;
 -			if (ctx->control != TLS_RECORD_TYPE_DATA)
 -				goto recv_end;
 +pick_next_record:
 +		copied += chunk;
 +		len -= chunk;
 +		if (likely(!(flags & MSG_PEEK))) {
 +			u8 control = ctx->control;
 +
 +			/* For async, drop current skb reference */
 +			if (async)
 +				skb = NULL;
 +
 +			if (tls_sw_advance_skb(sk, skb, chunk)) {
 +				/* Return full control message to
 +				 * userspace before trying to parse
 +				 * another message type
 +				 */
 +				msg->msg_flags |= MSG_EOR;
 +				if (control != TLS_RECORD_TYPE_DATA)
 +					goto recv_end;
 +			} else {
 +				break;
 +			}
  		} else {
 +			/* MSG_PEEK right now cannot look beyond current skb
 +			 * from strparser, meaning we cannot advance skb here
 +			 * and thus unpause strparser since we'd loose original
 +			 * one.
 +			 */
  			break;
  		}
  
* Unmerged path net/tls/tls_sw.c
