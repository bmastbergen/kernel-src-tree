drm/amdgpu/soc15: skip reset on init

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Alex Deucher <alexander.deucher@amd.com>
commit 5887a59961e2295c5b02f39dbc0ecf9212709b7b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/5887a599.failed

Not necessary on soc15 and breaks driver reload on server cards.

	Acked-by: Amber Lin <Amber.Lin@amd.com>
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
	Cc: stable@vger.kernel.org
(cherry picked from commit 5887a59961e2295c5b02f39dbc0ecf9212709b7b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/amdgpu/soc15.c
diff --cc drivers/gpu/drm/amd/amdgpu/soc15.c
index 83f2717fcf81,b7e594c2bfb4..000000000000
--- a/drivers/gpu/drm/amd/amdgpu/soc15.c
+++ b/drivers/gpu/drm/amd/amdgpu/soc15.c
@@@ -586,6 -680,73 +586,76 @@@ static bool soc15_need_full_reset(struc
  	/* change this when we implement soft reset */
  	return true;
  }
++<<<<<<< HEAD
++=======
+ static void soc15_get_pcie_usage(struct amdgpu_device *adev, uint64_t *count0,
+ 				 uint64_t *count1)
+ {
+ 	uint32_t perfctr = 0;
+ 	uint64_t cnt0_of, cnt1_of;
+ 	int tmp;
+ 
+ 	/* This reports 0 on APUs, so return to avoid writing/reading registers
+ 	 * that may or may not be different from their GPU counterparts
+ 	 */
+ 	 if (adev->flags & AMD_IS_APU)
+ 		 return;
+ 
+ 	/* Set the 2 events that we wish to watch, defined above */
+ 	/* Reg 40 is # received msgs, Reg 104 is # of posted requests sent */
+ 	perfctr = REG_SET_FIELD(perfctr, PCIE_PERF_CNTL_TXCLK, EVENT0_SEL, 40);
+ 	perfctr = REG_SET_FIELD(perfctr, PCIE_PERF_CNTL_TXCLK, EVENT1_SEL, 104);
+ 
+ 	/* Write to enable desired perf counters */
+ 	WREG32_PCIE(smnPCIE_PERF_CNTL_TXCLK, perfctr);
+ 	/* Zero out and enable the perf counters
+ 	 * Write 0x5:
+ 	 * Bit 0 = Start all counters(1)
+ 	 * Bit 2 = Global counter reset enable(1)
+ 	 */
+ 	WREG32_PCIE(smnPCIE_PERF_COUNT_CNTL, 0x00000005);
+ 
+ 	msleep(1000);
+ 
+ 	/* Load the shadow and disable the perf counters
+ 	 * Write 0x2:
+ 	 * Bit 0 = Stop counters(0)
+ 	 * Bit 1 = Load the shadow counters(1)
+ 	 */
+ 	WREG32_PCIE(smnPCIE_PERF_COUNT_CNTL, 0x00000002);
+ 
+ 	/* Read register values to get any >32bit overflow */
+ 	tmp = RREG32_PCIE(smnPCIE_PERF_CNTL_TXCLK);
+ 	cnt0_of = REG_GET_FIELD(tmp, PCIE_PERF_CNTL_TXCLK, COUNTER0_UPPER);
+ 	cnt1_of = REG_GET_FIELD(tmp, PCIE_PERF_CNTL_TXCLK, COUNTER1_UPPER);
+ 
+ 	/* Get the values and add the overflow */
+ 	*count0 = RREG32_PCIE(smnPCIE_PERF_COUNT0_TXCLK) | (cnt0_of << 32);
+ 	*count1 = RREG32_PCIE(smnPCIE_PERF_COUNT1_TXCLK) | (cnt1_of << 32);
+ }
+ 
+ static bool soc15_need_reset_on_init(struct amdgpu_device *adev)
+ {
+ 	u32 sol_reg;
+ 
+ 	/* Just return false for soc15 GPUs.  Reset does not seem to
+ 	 * be necessary.
+ 	 */
+ 	return false;
+ 
+ 	if (adev->flags & AMD_IS_APU)
+ 		return false;
+ 
+ 	/* Check sOS sign of life register to confirm sys driver and sOS
+ 	 * are already been loaded.
+ 	 */
+ 	sol_reg = RREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_81);
+ 	if (sol_reg)
+ 		return true;
+ 
+ 	return false;
+ }
++>>>>>>> 5887a59961e2 (drm/amdgpu/soc15: skip reset on init)
  
  static const struct amdgpu_asic_funcs soc15_asic_funcs =
  {
* Unmerged path drivers/gpu/drm/amd/amdgpu/soc15.c
