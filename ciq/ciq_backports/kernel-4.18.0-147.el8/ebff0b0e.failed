KVM: arm64: Reset the PMU in preemptible context

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Marc Zyngier <marc.zyngier@arm.com>
commit ebff0b0e3d3c862c16c487959db5e0d879632559
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/ebff0b0e.failed

We've become very cautious to now always reset the vcpu when nothing
is loaded on the physical CPU. To do so, we now disable preemption
and do a kvm_arch_vcpu_put() to make sure we have all the state
in memory (and that it won't be loaded behind out back).

This now causes issues with resetting the PMU, which calls into perf.
Perf itself uses mutexes, which clashes with the lack of preemption.
It is worth realizing that the PMU is fully emulated, and that
no PMU state is ever loaded on the physical CPU. This means we can
perfectly reset the PMU outside of the non-preemptible section.

Fixes: e761a927bc9a ("KVM: arm/arm64: Reset the VCPU without preemption and vcpu state loaded")
	Reported-by: Julien Grall <julien.grall@arm.com>
	Tested-by: Julien Grall <julien.grall@arm.com>
	Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
(cherry picked from commit ebff0b0e3d3c862c16c487959db5e0d879632559)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kvm/reset.c
diff --cc arch/arm64/kvm/reset.c
index 9b8e8bd8b60b,e2a0500cd7a2..000000000000
--- a/arch/arm64/kvm/reset.c
+++ b/arch/arm64/kvm/reset.c
@@@ -143,8 -150,28 +146,33 @@@ int kvm_reset_vcpu(struct kvm_vcpu *vcp
  	/* Reset system registers */
  	kvm_reset_sys_regs(vcpu);
  
++<<<<<<< HEAD
 +	/* Reset PMU */
 +	kvm_pmu_vcpu_reset(vcpu);
++=======
+ 	/*
+ 	 * Additional reset state handling that PSCI may have imposed on us.
+ 	 * Must be done after all the sys_reg reset.
+ 	 */
+ 	if (vcpu->arch.reset_state.reset) {
+ 		unsigned long target_pc = vcpu->arch.reset_state.pc;
+ 
+ 		/* Gracefully handle Thumb2 entry point */
+ 		if (vcpu_mode_is_32bit(vcpu) && (target_pc & 1)) {
+ 			target_pc &= ~1UL;
+ 			vcpu_set_thumb(vcpu);
+ 		}
+ 
+ 		/* Propagate caller endianness */
+ 		if (vcpu->arch.reset_state.be)
+ 			kvm_vcpu_set_be(vcpu);
+ 
+ 		*vcpu_pc(vcpu) = target_pc;
+ 		vcpu_set_reg(vcpu, 0, vcpu->arch.reset_state.r0);
+ 
+ 		vcpu->arch.reset_state.reset = false;
+ 	}
++>>>>>>> ebff0b0e3d3c (KVM: arm64: Reset the PMU in preemptible context)
  
  	/* Default workaround setup is enabled (if supported) */
  	if (kvm_arm_have_ssbd() == KVM_SSBD_KERNEL)
* Unmerged path arch/arm64/kvm/reset.c
