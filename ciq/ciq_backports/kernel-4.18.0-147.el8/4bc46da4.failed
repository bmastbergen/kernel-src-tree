drm/amd/display: Reset planes that were disabled in init_pipes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
commit 4bc46da4a3aeeb4d55e83dd276cf72756e908286
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/4bc46da4.failed

[Why]
Seamless boot tries to reuse planes that were enabled for the first
commit applied.

In the case where Raven is booting with two monitors connected and the
first commit contains two streams the screen corruption would occur
because the second stream was trying to re-use a tg and plane that
weren't previously enabled.

The state on the first commit looks something like the following:

TG0: enabled=1
TG1: enabled=0
TG2: enabled=0
TG3: enabled=0

New state: pipe=0, stream=0,    plane=0,       new_tg=0
New state: pipe=1, stream=1,    plane=1,       new_tg=1
New state: pipe=2, stream=NULL, plane=NULL,    new_tg=NULL
New state: pipe=3, stream=NULL, plane=NULL,    new_tg=NULL

Only one plane/tg is setup before we enter accelerated mode so
we really want to disabling everything but that first plane.

[How]

Check if the stream is not NULL and if the tg is enabled before
deciding whether to skip the plane disable.

Also ensure we're also disabling on the current state's pipe_ctx so
we don't overwrite the fields in the new pending state.

	Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
	Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
	Acked-by: Harry Wentland <Harry.Wentland@amd.com>
	Acked-by: Leo Li <sunpeng.li@amd.com>
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit 4bc46da4a3aeeb4d55e83dd276cf72756e908286)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
diff --cc drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index f8e0576af6e0,7ba3e09ad3c9..000000000000
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@@ -1024,9 -1018,23 +1024,27 @@@ static void dcn10_init_hw(struct dc *dc
  
  	for (i = 0; i < dc->res_pool->pipe_count; i++) {
  		struct timing_generator *tg = dc->res_pool->timing_generators[i];
 +		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
  		struct hubp *hubp = dc->res_pool->hubps[i];
  		struct dpp *dpp = dc->res_pool->dpps[i];
++<<<<<<< HEAD
++=======
+ 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+ 
+ 		/* There is assumption that pipe_ctx is not mapping irregularly
+ 		 * to non-preferred front end. If pipe_ctx->stream is not NULL,
+ 		 * we will use the pipe, so don't disable
+ 		 */
+ 		if (pipe_ctx->stream != NULL &&
+ 		    pipe_ctx->stream_res.tg->funcs->is_tg_enabled(
+ 			    pipe_ctx->stream_res.tg))
+ 			continue;
+ 
+ 		/* Disable on the current state so the new one isn't cleared. */
+ 		pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];
+ 
+ 		dpp->funcs->dpp_reset(dpp);
++>>>>>>> 4bc46da4a3ae (drm/amd/display: Reset planes that were disabled in init_pipes)
  
  		pipe_ctx->stream_res.tg = tg;
  		pipe_ctx->pipe_idx = i;
* Unmerged path drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
