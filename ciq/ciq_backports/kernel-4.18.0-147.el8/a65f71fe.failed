ice: map Rx buffer pages with DMA attributes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Maciej Fijalkowski <maciej.fijalkowski@intel.com>
commit a65f71fed5add2ec5713fcc605842f5f2dff22a3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/a65f71fe.failed

Provide DMA_ATTR_WEAK_ORDERING and DMA_ATTR_SKIP_CPU_SYNC attributes to
the DMA API during the mapping operations on Rx side. With this change
the non-x86 platforms will be able to sync only with what is being used
(2k buffer) instead of entire page. This should yield a slight
performance improvement.

Furthermore, DMA unmap may destroy the changes that were made to the
buffer by CPU when platform is not a x86 one. DMA_ATTR_SKIP_CPU_SYNC
attribute usage fixes this issue.

Also add a sync_single_for_device call during the Rx buffer assignment,
to make sure that the cache lines are cleared before device attempting
to write to the buffer.

	Signed-off-by: Maciej Fijalkowski <maciej.fijalkowski@intel.com>
	Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit a65f71fed5add2ec5713fcc605842f5f2dff22a3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_txrx.c
diff --cc drivers/net/ethernet/intel/ice/ice_txrx.c
index b0086743621b,ea4ec3760f8b..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_txrx.c
+++ b/drivers/net/ethernet/intel/ice/ice_txrx.c
@@@ -282,8 -282,17 +282,22 @@@ void ice_clean_rx_ring(struct ice_ring 
  		if (!rx_buf->page)
  			continue;
  
++<<<<<<< HEAD
 +		dma_unmap_page(dev, rx_buf->dma, PAGE_SIZE, DMA_FROM_DEVICE);
 +		__free_pages(rx_buf->page, 0);
++=======
+ 		/* Invalidate cache lines that may have been written to by
+ 		 * device so that we avoid corrupting memory.
+ 		 */
+ 		dma_sync_single_range_for_cpu(dev, rx_buf->dma,
+ 					      rx_buf->page_offset,
+ 					      ICE_RXBUF_2048, DMA_FROM_DEVICE);
+ 
+ 		/* free resources associated with mapping */
+ 		dma_unmap_page_attrs(dev, rx_buf->dma, PAGE_SIZE,
+ 				     DMA_FROM_DEVICE, ICE_RX_DMA_ATTR);
+ 		__page_frag_cache_drain(rx_buf->page, rx_buf->pagecnt_bias);
++>>>>>>> a65f71fed5ad (ice: map Rx buffer pages with DMA attributes)
  
  		rx_buf->page = NULL;
  		rx_buf->page_offset = 0;
@@@ -668,8 -742,9 +689,14 @@@ static struct sk_buff *ice_fetch_rx_buf
  		rx_ring->rx_stats.page_reuse_count++;
  	} else {
  		/* we are not reusing the buffer so unmap it */
++<<<<<<< HEAD
 +		dma_unmap_page(rx_ring->dev, rx_buf->dma, PAGE_SIZE,
 +			       DMA_FROM_DEVICE);
++=======
+ 		dma_unmap_page_attrs(rx_ring->dev, rx_buf->dma, PAGE_SIZE,
+ 				     DMA_FROM_DEVICE, ICE_RX_DMA_ATTR);
+ 		__page_frag_cache_drain(rx_buf->page, rx_buf->pagecnt_bias);
++>>>>>>> a65f71fed5ad (ice: map Rx buffer pages with DMA attributes)
  	}
  
  	/* clear contents of buffer_info */
* Unmerged path drivers/net/ethernet/intel/ice/ice_txrx.c
diff --git a/drivers/net/ethernet/intel/ice/ice_txrx.h b/drivers/net/ethernet/intel/ice/ice_txrx.h
index 75d0eaf6c9dd..6b95ab8ea494 100644
--- a/drivers/net/ethernet/intel/ice/ice_txrx.h
+++ b/drivers/net/ethernet/intel/ice/ice_txrx.h
@@ -47,6 +47,9 @@
 #define ICE_TX_FLAGS_VLAN_M	0xffff0000
 #define ICE_TX_FLAGS_VLAN_S	16
 
+#define ICE_RX_DMA_ATTR \
+	(DMA_ATTR_SKIP_CPU_SYNC | DMA_ATTR_WEAK_ORDERING)
+
 struct ice_tx_buf {
 	struct ice_tx_desc *next_to_watch;
 	struct sk_buff *skb;
