cgroup: prevent spurious transition into non-frozen state

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Roman Gushchin <guro@fb.com>
commit cb2c4cd87874a7975b7b8615866b3a87bae10aab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/cb2c4cd8.failed

If freezing of a cgroup races with waking of a task from
the frozen state (like waiting in vfork() or in do_signal_stop()),
a spurious transition of the cgroup state can happen.

The task enters cgroup_leave_frozen(true), the cgroup->nr_frozen_tasks
counter decrements, and the cgroup is switched to the unfrozen state.

To prevent it, let's reserve cgroup_leave_frozen(true) for
terminating processes and use cgroup_leave_frozen(false) otherwise.

To avoid busy-looping in the signal handling loop waiting
for JOBCTL_TRAP_FREEZE set from the cgroup freezing path,
let's do it explicitly in cgroup_leave_frozen(), if the task
is going to stay frozen.

	Suggested-by: Oleg Nesterov <oleg@redhat.com>
	Signed-off-by: Roman Gushchin <guro@fb.com>
	Signed-off-by: Tejun Heo <tj@kernel.org>
(cherry picked from commit cb2c4cd87874a7975b7b8615866b3a87bae10aab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/cgroup/freezer.c
#	kernel/signal.c
diff --cc kernel/signal.c
index 99d3b75cccbf,16b72f4f14df..000000000000
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@@ -2450,9 -2497,24 +2450,13 @@@ relock
  		    do_signal_stop(0))
  			goto relock;
  
 -		if (unlikely(current->jobctl &
 -			     (JOBCTL_TRAP_MASK | JOBCTL_TRAP_FREEZE))) {
 -			if (current->jobctl & JOBCTL_TRAP_MASK) {
 -				do_jobctl_trap();
 -				spin_unlock_irq(&sighand->siglock);
 -			} else if (current->jobctl & JOBCTL_TRAP_FREEZE)
 -				do_freezer_trap();
 -
 -			goto relock;
 -		}
 -
 -		/*
 -		 * If the task is leaving the frozen state, let's update
 -		 * cgroup counters and reset the frozen bit.
 -		 */
 -		if (unlikely(cgroup_task_frozen(current))) {
 +		if (unlikely(current->jobctl & JOBCTL_TRAP_MASK)) {
 +			do_jobctl_trap();
  			spin_unlock_irq(&sighand->siglock);
++<<<<<<< HEAD
++=======
+ 			cgroup_leave_frozen(false);
++>>>>>>> cb2c4cd87874 (cgroup: prevent spurious transition into non-frozen state)
  			goto relock;
  		}
  
* Unmerged path kernel/cgroup/freezer.c
* Unmerged path kernel/cgroup/freezer.c
* Unmerged path kernel/signal.c
