ice: Add ability to update rx-usecs-high

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Brett Creeley <brett.creeley@intel.com>
commit b9c8bb06b53d28c83c47988f645b6cf4543c2685
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/b9c8bb06.failed

Currently the driver allows rx-usecs-high values to be set,
but when querying the device for rx-usecs-high the value
does not stick. This is because it was not yet implemented.
Add code to allow the user to change rx-usecs-high and
use this to set the q_vector's intrl value.

	Signed-off-by: Brett Creeley <brett.creeley@intel.com>
	Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit b9c8bb06b53d28c83c47988f645b6cf4543c2685)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_ethtool.c
diff --cc drivers/net/ethernet/intel/ice/ice_ethtool.c
index ca448587ac24,f995ed599cd9..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_ethtool.c
+++ b/drivers/net/ethernet/intel/ice/ice_ethtool.c
@@@ -2172,6 -2207,289 +2172,292 @@@ static int ice_set_rxfh(struct net_devi
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ enum ice_container_type {
+ 	ICE_RX_CONTAINER,
+ 	ICE_TX_CONTAINER,
+ };
+ 
+ /**
+  * ice_get_rc_coalesce - get ITR values for specific ring container
+  * @ec: ethtool structure to fill with driver's coalesce settings
+  * @c_type: container type, Rx or Tx
+  * @rc: ring container that the ITR values will come from
+  *
+  * Query the device for ice_ring_container specific ITR values. This is
+  * done per ice_ring_container because each q_vector can have 1 or more rings
+  * and all of said ring(s) will have the same ITR values.
+  *
+  * Returns 0 on success, negative otherwise.
+  */
+ static int
+ ice_get_rc_coalesce(struct ethtool_coalesce *ec, enum ice_container_type c_type,
+ 		    struct ice_ring_container *rc)
+ {
+ 	struct ice_pf *pf;
+ 
+ 	if (!rc->ring)
+ 		return -EINVAL;
+ 
+ 	pf = rc->ring->vsi->back;
+ 
+ 	switch (c_type) {
+ 	case ICE_RX_CONTAINER:
+ 		ec->use_adaptive_rx_coalesce = ITR_IS_DYNAMIC(rc->itr_setting);
+ 		ec->rx_coalesce_usecs = rc->itr_setting & ~ICE_ITR_DYNAMIC;
+ 		ec->rx_coalesce_usecs_high = rc->ring->q_vector->intrl;
+ 		break;
+ 	case ICE_TX_CONTAINER:
+ 		ec->use_adaptive_tx_coalesce = ITR_IS_DYNAMIC(rc->itr_setting);
+ 		ec->tx_coalesce_usecs = rc->itr_setting & ~ICE_ITR_DYNAMIC;
+ 		break;
+ 	default:
+ 		dev_dbg(&pf->pdev->dev, "Invalid c_type %d\n", c_type);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * __ice_get_coalesce - get ITR/INTRL values for the device
+  * @netdev: pointer to the netdev associated with this query
+  * @ec: ethtool structure to fill with driver's coalesce settings
+  * @q_num: queue number to get the coalesce settings for
+  */
+ static int
+ __ice_get_coalesce(struct net_device *netdev, struct ethtool_coalesce *ec,
+ 		   int q_num)
+ {
+ 	struct ice_netdev_priv *np = netdev_priv(netdev);
+ 	int tx = -EINVAL, rx = -EINVAL;
+ 	struct ice_vsi *vsi = np->vsi;
+ 
+ 	if (q_num < 0) {
+ 		rx = ice_get_rc_coalesce(ec, ICE_RX_CONTAINER,
+ 					 &vsi->rx_rings[0]->q_vector->rx);
+ 		tx = ice_get_rc_coalesce(ec, ICE_TX_CONTAINER,
+ 					 &vsi->tx_rings[0]->q_vector->tx);
+ 
+ 		goto update_coalesced_frames;
+ 	}
+ 
+ 	if (q_num < vsi->num_rxq && q_num < vsi->num_txq) {
+ 		rx = ice_get_rc_coalesce(ec, ICE_RX_CONTAINER,
+ 					 &vsi->rx_rings[q_num]->q_vector->rx);
+ 		tx = ice_get_rc_coalesce(ec, ICE_TX_CONTAINER,
+ 					 &vsi->tx_rings[q_num]->q_vector->tx);
+ 	} else if (q_num < vsi->num_rxq) {
+ 		rx = ice_get_rc_coalesce(ec, ICE_RX_CONTAINER,
+ 					 &vsi->rx_rings[q_num]->q_vector->rx);
+ 	} else if (q_num < vsi->num_txq) {
+ 		tx = ice_get_rc_coalesce(ec, ICE_TX_CONTAINER,
+ 					 &vsi->tx_rings[q_num]->q_vector->tx);
+ 	} else {
+ 		/* q_num is invalid for both Rx and Tx queues */
+ 		return -EINVAL;
+ 	}
+ 
+ update_coalesced_frames:
+ 	/* either q_num is invalid for both Rx and Tx queues or setting coalesce
+ 	 * failed completely
+ 	 */
+ 	if (tx && rx)
+ 		return -EINVAL;
+ 
+ 	if (q_num < vsi->num_txq)
+ 		ec->tx_max_coalesced_frames_irq = vsi->work_lmt;
+ 
+ 	if (q_num < vsi->num_rxq)
+ 		ec->rx_max_coalesced_frames_irq = vsi->work_lmt;
+ 
+ 	return 0;
+ }
+ 
+ static int
+ ice_get_coalesce(struct net_device *netdev, struct ethtool_coalesce *ec)
+ {
+ 	return __ice_get_coalesce(netdev, ec, -1);
+ }
+ 
+ static int
+ ice_get_per_q_coalesce(struct net_device *netdev, u32 q_num,
+ 		       struct ethtool_coalesce *ec)
+ {
+ 	return __ice_get_coalesce(netdev, ec, q_num);
+ }
+ 
+ /**
+  * ice_set_rc_coalesce - set ITR values for specific ring container
+  * @c_type: container type, Rx or Tx
+  * @ec: ethtool structure from user to update ITR settings
+  * @rc: ring container that the ITR values will come from
+  * @vsi: VSI associated to the ring container
+  *
+  * Set specific ITR values. This is done per ice_ring_container because each
+  * q_vector can have 1 or more rings and all of said ring(s) will have the same
+  * ITR values.
+  *
+  * Returns 0 on success, negative otherwise.
+  */
+ static int
+ ice_set_rc_coalesce(enum ice_container_type c_type, struct ethtool_coalesce *ec,
+ 		    struct ice_ring_container *rc, struct ice_vsi *vsi)
+ {
+ 	struct ice_pf *pf = vsi->back;
+ 	u16 itr_setting;
+ 
+ 	if (!rc->ring)
+ 		return -EINVAL;
+ 
+ 	itr_setting = rc->itr_setting & ~ICE_ITR_DYNAMIC;
+ 
+ 	switch (c_type) {
+ 	case ICE_RX_CONTAINER:
+ 		if (ec->rx_coalesce_usecs_high > ICE_MAX_INTRL ||
+ 		    (ec->rx_coalesce_usecs_high &&
+ 		     ec->rx_coalesce_usecs_high < pf->hw.intrl_gran)) {
+ 			netdev_info(vsi->netdev,
+ 				    "Invalid value, rx-usecs-high valid values are 0 (disabled), %d-%d\n",
+ 				    pf->hw.intrl_gran, ICE_MAX_INTRL);
+ 			return -EINVAL;
+ 		}
+ 
+ 		if (ec->rx_coalesce_usecs_high != rc->ring->q_vector->intrl) {
+ 			rc->ring->q_vector->intrl = ec->rx_coalesce_usecs_high;
+ 			wr32(&pf->hw, GLINT_RATE(vsi->hw_base_vector +
+ 						 rc->ring->q_vector->v_idx),
+ 			     ice_intrl_usec_to_reg(ec->rx_coalesce_usecs_high,
+ 						   pf->hw.intrl_gran));
+ 		}
+ 
+ 		if (ec->rx_coalesce_usecs != itr_setting &&
+ 		    ec->use_adaptive_rx_coalesce) {
+ 			netdev_info(vsi->netdev,
+ 				    "Rx interrupt throttling cannot be changed if adaptive-rx is enabled\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		if (ec->rx_coalesce_usecs > ICE_ITR_MAX) {
+ 			netdev_info(vsi->netdev,
+ 				    "Invalid value, rx-usecs range is 0-%d\n",
+ 				   ICE_ITR_MAX);
+ 			return -EINVAL;
+ 		}
+ 
+ 		if (ec->use_adaptive_rx_coalesce) {
+ 			rc->itr_setting |= ICE_ITR_DYNAMIC;
+ 		} else {
+ 			rc->itr_setting = ITR_REG_ALIGN(ec->rx_coalesce_usecs);
+ 			rc->target_itr = ITR_TO_REG(rc->itr_setting);
+ 		}
+ 		break;
+ 	case ICE_TX_CONTAINER:
+ 		if (ec->tx_coalesce_usecs_high) {
+ 			netdev_info(vsi->netdev,
+ 				    "setting tx-usecs-high is not supported\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		if (ec->tx_coalesce_usecs != itr_setting &&
+ 		    ec->use_adaptive_tx_coalesce) {
+ 			netdev_info(vsi->netdev,
+ 				    "Tx interrupt throttling cannot be changed if adaptive-tx is enabled\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		if (ec->tx_coalesce_usecs > ICE_ITR_MAX) {
+ 			netdev_info(vsi->netdev,
+ 				    "Invalid value, tx-usecs range is 0-%d\n",
+ 				   ICE_ITR_MAX);
+ 			return -EINVAL;
+ 		}
+ 
+ 		if (ec->use_adaptive_tx_coalesce) {
+ 			rc->itr_setting |= ICE_ITR_DYNAMIC;
+ 		} else {
+ 			rc->itr_setting = ITR_REG_ALIGN(ec->tx_coalesce_usecs);
+ 			rc->target_itr = ITR_TO_REG(rc->itr_setting);
+ 		}
+ 		break;
+ 	default:
+ 		dev_dbg(&pf->pdev->dev, "Invalid container type %d\n", c_type);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int
+ __ice_set_coalesce(struct net_device *netdev, struct ethtool_coalesce *ec,
+ 		   int q_num)
+ {
+ 	struct ice_netdev_priv *np = netdev_priv(netdev);
+ 	int rx = -EINVAL, tx = -EINVAL;
+ 	struct ice_vsi *vsi = np->vsi;
+ 
+ 	if (q_num < 0) {
+ 		int i;
+ 
+ 		ice_for_each_q_vector(vsi, i) {
+ 			struct ice_q_vector *q_vector = vsi->q_vectors[i];
+ 
+ 			if (ice_set_rc_coalesce(ICE_RX_CONTAINER, ec,
+ 						&q_vector->rx, vsi) ||
+ 			    ice_set_rc_coalesce(ICE_TX_CONTAINER, ec,
+ 						&q_vector->tx, vsi))
+ 				return -EINVAL;
+ 		}
+ 
+ 		goto set_work_lmt;
+ 	}
+ 
+ 	if (q_num < vsi->num_rxq && q_num < vsi->num_txq) {
+ 		rx = ice_set_rc_coalesce(ICE_RX_CONTAINER, ec,
+ 					 &vsi->rx_rings[q_num]->q_vector->rx,
+ 					 vsi);
+ 		tx = ice_set_rc_coalesce(ICE_TX_CONTAINER, ec,
+ 					 &vsi->tx_rings[q_num]->q_vector->tx,
+ 					 vsi);
+ 	} else if (q_num < vsi->num_rxq) {
+ 		rx = ice_set_rc_coalesce(ICE_RX_CONTAINER, ec,
+ 					 &vsi->rx_rings[q_num]->q_vector->rx,
+ 					 vsi);
+ 	} else if (q_num < vsi->num_txq) {
+ 		tx  = ice_set_rc_coalesce(ICE_TX_CONTAINER, ec,
+ 					  &vsi->tx_rings[q_num]->q_vector->tx,
+ 					  vsi);
+ 	}
+ 
+ 	/* either q_num is invalid for both Rx and Tx queues or setting coalesce
+ 	 * failed completely
+ 	 */
+ 	if (rx && tx)
+ 		return -EINVAL;
+ 
+ set_work_lmt:
+ 	if (ec->tx_max_coalesced_frames_irq || ec->rx_max_coalesced_frames_irq)
+ 		vsi->work_lmt = max(ec->tx_max_coalesced_frames_irq,
+ 				    ec->rx_max_coalesced_frames_irq);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ ice_set_coalesce(struct net_device *netdev, struct ethtool_coalesce *ec)
+ {
+ 	return __ice_set_coalesce(netdev, ec, -1);
+ }
+ 
+ static int
+ ice_set_per_q_coalesce(struct net_device *netdev, u32 q_num,
+ 		       struct ethtool_coalesce *ec)
+ {
+ 	return __ice_set_coalesce(netdev, ec, q_num);
+ }
+ 
++>>>>>>> b9c8bb06b53d (ice: Add ability to update rx-usecs-high)
  static const struct ethtool_ops ice_ethtool_ops = {
  	.get_link_ksettings	= ice_get_link_ksettings,
  	.set_link_ksettings	= ice_set_link_ksettings,
* Unmerged path drivers/net/ethernet/intel/ice/ice_ethtool.c
diff --git a/drivers/net/ethernet/intel/ice/ice_lib.c b/drivers/net/ethernet/intel/ice/ice_lib.c
index 828d9ad1c731..f55238a739fc 100644
--- a/drivers/net/ethernet/intel/ice/ice_lib.c
+++ b/drivers/net/ethernet/intel/ice/ice_lib.c
@@ -1757,7 +1757,7 @@ int ice_vsi_cfg_lan_txqs(struct ice_vsi *vsi)
  * This function converts a decimal interrupt rate limit in usecs to the format
  * expected by firmware.
  */
-static u32 ice_intrl_usec_to_reg(u8 intrl, u8 gran)
+u32 ice_intrl_usec_to_reg(u8 intrl, u8 gran)
 {
 	u32 val = intrl / gran;
 
diff --git a/drivers/net/ethernet/intel/ice/ice_lib.h b/drivers/net/ethernet/intel/ice/ice_lib.h
index 7988a53729a9..455e779ff525 100644
--- a/drivers/net/ethernet/intel/ice/ice_lib.h
+++ b/drivers/net/ethernet/intel/ice/ice_lib.h
@@ -74,4 +74,5 @@ int ice_vsi_cfg_tc(struct ice_vsi *vsi, u8 ena_tc);
 
 int ice_vsi_manage_rss_lut(struct ice_vsi *vsi, bool ena);
 
+u32 ice_intrl_usec_to_reg(u8 intrl, u8 gran);
 #endif /* !_ICE_LIB_H_ */
diff --git a/drivers/net/ethernet/intel/ice/ice_txrx.h b/drivers/net/ethernet/intel/ice/ice_txrx.h
index 75d0eaf6c9dd..bfbabae3b438 100644
--- a/drivers/net/ethernet/intel/ice/ice_txrx.h
+++ b/drivers/net/ethernet/intel/ice/ice_txrx.h
@@ -128,6 +128,7 @@ enum ice_rx_dtype {
 				   ((itr_gran) / 2))
 
 #define ICE_DFLT_INTRL	0
+#define ICE_MAX_INTRL	236
 
 /* Legacy or Advanced Mode Queue */
 #define ICE_TX_ADVANCED	0
