mlxsw: spectrum_acl: Add couple of vregion rehash tracepoints

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jiri Pirko <jiri@mellanox.com>
commit 3985de7260a7342a474a0792fcd23737341657ce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/3985de72.failed

As vregion rehash is happening in delayed work, add some visibility to
the process using a few tracepoints.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3985de7260a7342a474a0792fcd23737341657ce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
index a68b538897ef,7e225a86e3a8..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
@@@ -959,6 -1072,182 +960,185 @@@ mlxsw_sp_acl_tcam_ventry_activity_get(s
  						    ventry->entry, activity);
  }
  
++<<<<<<< HEAD
++=======
+ static int
+ mlxsw_sp_acl_tcam_ventry_migrate(struct mlxsw_sp *mlxsw_sp,
+ 				 struct mlxsw_sp_acl_tcam_ventry *ventry,
+ 				 struct mlxsw_sp_acl_tcam_chunk *chunk2)
+ {
+ 	struct mlxsw_sp_acl_tcam_entry *entry2;
+ 
+ 	entry2 = mlxsw_sp_acl_tcam_entry_create(mlxsw_sp, ventry, chunk2);
+ 	if (IS_ERR(entry2))
+ 		return PTR_ERR(entry2);
+ 	mlxsw_sp_acl_tcam_entry_destroy(mlxsw_sp, ventry->entry);
+ 	ventry->entry = entry2;
+ 	return 0;
+ }
+ 
+ static int
+ mlxsw_sp_acl_tcam_vchunk_migrate_one(struct mlxsw_sp *mlxsw_sp,
+ 				     struct mlxsw_sp_acl_tcam_vchunk *vchunk,
+ 				     struct mlxsw_sp_acl_tcam_region *region,
+ 				     bool this_is_rollback)
+ {
+ 	struct mlxsw_sp_acl_tcam_ventry *ventry;
+ 	struct mlxsw_sp_acl_tcam_chunk *chunk2;
+ 	int err;
+ 	int err2;
+ 
+ 	chunk2 = mlxsw_sp_acl_tcam_chunk_create(mlxsw_sp, vchunk, region);
+ 	if (IS_ERR(chunk2)) {
+ 		if (this_is_rollback)
+ 			vchunk->vregion->failed_rollback = true;
+ 		return PTR_ERR(chunk2);
+ 	}
+ 	vchunk->chunk2 = chunk2;
+ 	list_for_each_entry(ventry, &vchunk->ventry_list, list) {
+ 		err = mlxsw_sp_acl_tcam_ventry_migrate(mlxsw_sp, ventry,
+ 						       vchunk->chunk2);
+ 		if (err) {
+ 			if (this_is_rollback) {
+ 				vchunk->vregion->failed_rollback = true;
+ 				return err;
+ 			}
+ 			goto rollback;
+ 		}
+ 	}
+ 	mlxsw_sp_acl_tcam_chunk_destroy(mlxsw_sp, vchunk->chunk);
+ 	vchunk->chunk = chunk2;
+ 	vchunk->chunk2 = NULL;
+ 	return 0;
+ 
+ rollback:
+ 	/* Migrate the entries back to the original chunk. If some entry
+ 	 * migration fails, there's no good way how to proceed. Set the
+ 	 * vregion with "failed_rollback" flag.
+ 	 */
+ 	list_for_each_entry_continue_reverse(ventry, &vchunk->ventry_list,
+ 					     list) {
+ 		err2 = mlxsw_sp_acl_tcam_ventry_migrate(mlxsw_sp, ventry,
+ 							vchunk->chunk);
+ 		if (err2) {
+ 			vchunk->vregion->failed_rollback = true;
+ 			goto err_rollback;
+ 		}
+ 	}
+ 
+ 	mlxsw_sp_acl_tcam_chunk_destroy(mlxsw_sp, vchunk->chunk2);
+ 	vchunk->chunk2 = NULL;
+ 
+ err_rollback:
+ 	return err;
+ }
+ 
+ static int
+ mlxsw_sp_acl_tcam_vchunk_migrate_all(struct mlxsw_sp *mlxsw_sp,
+ 				     struct mlxsw_sp_acl_tcam_vregion *vregion)
+ {
+ 	struct mlxsw_sp_acl_tcam_vchunk *vchunk;
+ 	int err;
+ 
+ 	list_for_each_entry(vchunk, &vregion->vchunk_list, list) {
+ 		err = mlxsw_sp_acl_tcam_vchunk_migrate_one(mlxsw_sp, vchunk,
+ 							   vregion->region2,
+ 							   false);
+ 		if (err)
+ 			goto rollback;
+ 	}
+ 	return 0;
+ 
+ rollback:
+ 	list_for_each_entry_continue_reverse(vchunk, &vregion->vchunk_list,
+ 					     list) {
+ 		mlxsw_sp_acl_tcam_vchunk_migrate_one(mlxsw_sp, vchunk,
+ 						     vregion->region, true);
+ 	}
+ 	return err;
+ }
+ 
+ static int
+ mlxsw_sp_acl_tcam_vregion_migrate(struct mlxsw_sp *mlxsw_sp,
+ 				  struct mlxsw_sp_acl_tcam_vregion *vregion,
+ 				  void *hints_priv)
+ {
+ 	struct mlxsw_sp_acl_tcam_region *region2, *unused_region;
+ 	int err;
+ 
+ 	trace_mlxsw_sp_acl_tcam_vregion_migrate(mlxsw_sp, vregion);
+ 
+ 	region2 = mlxsw_sp_acl_tcam_region_create(mlxsw_sp, vregion->tcam,
+ 						  vregion, hints_priv);
+ 	if (IS_ERR(region2))
+ 		return PTR_ERR(region2);
+ 
+ 	vregion->region2 = region2;
+ 	err = mlxsw_sp_acl_tcam_group_region_attach(mlxsw_sp, region2);
+ 	if (err)
+ 		goto err_group_region_attach;
+ 
+ 	err = mlxsw_sp_acl_tcam_vchunk_migrate_all(mlxsw_sp, vregion);
+ 	if (!vregion->failed_rollback) {
+ 		if (!err) {
+ 			/* In case of successful migration, region2 is used and
+ 			 * the original is unused.
+ 			 */
+ 			unused_region = vregion->region;
+ 			vregion->region = vregion->region2;
+ 		} else {
+ 			/* In case of failure during migration, the original
+ 			 * region is still used.
+ 			 */
+ 			unused_region = vregion->region2;
+ 		}
+ 		vregion->region2 = NULL;
+ 		mlxsw_sp_acl_tcam_group_region_detach(mlxsw_sp, unused_region);
+ 		mlxsw_sp_acl_tcam_region_destroy(mlxsw_sp, unused_region);
+ 	}
+ 	return err;
+ 
+ err_group_region_attach:
+ 	vregion->region2 = NULL;
+ 	mlxsw_sp_acl_tcam_region_destroy(mlxsw_sp, region2);
+ 	return err;
+ }
+ 
+ static int
+ mlxsw_sp_acl_tcam_vregion_rehash(struct mlxsw_sp *mlxsw_sp,
+ 				 struct mlxsw_sp_acl_tcam_vregion *vregion)
+ {
+ 	const struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;
+ 	void *hints_priv;
+ 	int err;
+ 
+ 	trace_mlxsw_sp_acl_tcam_vregion_rehash(mlxsw_sp, vregion);
+ 	if (vregion->failed_rollback)
+ 		return -EBUSY;
+ 
+ 	hints_priv = ops->region_rehash_hints_get(vregion->region->priv);
+ 	if (IS_ERR(hints_priv)) {
+ 		err = PTR_ERR(hints_priv);
+ 		if (err != -EAGAIN)
+ 			dev_err(mlxsw_sp->bus_info->dev, "Failed get rehash hints\n");
+ 		return err;
+ 	}
+ 
+ 	err = mlxsw_sp_acl_tcam_vregion_migrate(mlxsw_sp, vregion, hints_priv);
+ 	if (err) {
+ 		dev_err(mlxsw_sp->bus_info->dev, "Failed to migrate vregion\n");
+ 		if (vregion->failed_rollback) {
+ 			trace_mlxsw_sp_acl_tcam_vregion_rehash_dis(mlxsw_sp,
+ 								   vregion);
+ 			dev_err(mlxsw_sp->bus_info->dev, "Failed to rollback during vregion migration fail\n");
+ 		}
+ 	}
+ 
+ 	ops->region_rehash_hints_put(hints_priv);
+ 	return err;
+ }
+ 
++>>>>>>> 3985de7260a7 (mlxsw: spectrum_acl: Add couple of vregion rehash tracepoints)
  static const enum mlxsw_afk_element mlxsw_sp_acl_tcam_pattern_ipv4[] = {
  	MLXSW_AFK_ELEMENT_SRC_SYS_PORT,
  	MLXSW_AFK_ELEMENT_DMAC_32_47,
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
diff --git a/include/trace/events/mlxsw.h b/include/trace/events/mlxsw.h
index 6c2bafcade18..a5ce6df9dc49 100644
--- a/include/trace/events/mlxsw.h
+++ b/include/trace/events/mlxsw.h
@@ -11,6 +11,7 @@
 
 struct mlxsw_sp;
 struct mlxsw_sp_acl_atcam_region;
+struct mlxsw_sp_acl_tcam_vregion;
 
 TRACE_EVENT(mlxsw_sp_acl_atcam_entry_add_ctcam_spill,
 	TP_PROTO(const struct mlxsw_sp *mlxsw_sp,
@@ -32,6 +33,66 @@ TRACE_EVENT(mlxsw_sp_acl_atcam_entry_add_ctcam_spill,
 		  __entry->mlxsw_sp, __entry->aregion)
 );
 
+TRACE_EVENT(mlxsw_sp_acl_tcam_vregion_rehash,
+	TP_PROTO(const struct mlxsw_sp *mlxsw_sp,
+		 const struct mlxsw_sp_acl_tcam_vregion *vregion),
+
+	TP_ARGS(mlxsw_sp, vregion),
+
+	TP_STRUCT__entry(
+		__field(const void *, mlxsw_sp)
+		__field(const void *, vregion)
+	),
+
+	TP_fast_assign(
+		__entry->mlxsw_sp = mlxsw_sp;
+		__entry->vregion = vregion;
+	),
+
+	TP_printk("mlxsw_sp %p, vregion %p",
+		  __entry->mlxsw_sp, __entry->vregion)
+);
+
+TRACE_EVENT(mlxsw_sp_acl_tcam_vregion_migrate,
+	TP_PROTO(const struct mlxsw_sp *mlxsw_sp,
+		 const struct mlxsw_sp_acl_tcam_vregion *vregion),
+
+	TP_ARGS(mlxsw_sp, vregion),
+
+	TP_STRUCT__entry(
+		__field(const void *, mlxsw_sp)
+		__field(const void *, vregion)
+	),
+
+	TP_fast_assign(
+		__entry->mlxsw_sp = mlxsw_sp;
+		__entry->vregion = vregion;
+	),
+
+	TP_printk("mlxsw_sp %p, vregion %p",
+		  __entry->mlxsw_sp, __entry->vregion)
+);
+
+TRACE_EVENT(mlxsw_sp_acl_tcam_vregion_rehash_dis,
+	TP_PROTO(const struct mlxsw_sp *mlxsw_sp,
+		 const struct mlxsw_sp_acl_tcam_vregion *vregion),
+
+	TP_ARGS(mlxsw_sp, vregion),
+
+	TP_STRUCT__entry(
+		__field(const void *, mlxsw_sp)
+		__field(const void *, vregion)
+	),
+
+	TP_fast_assign(
+		__entry->mlxsw_sp = mlxsw_sp;
+		__entry->vregion = vregion;
+	),
+
+	TP_printk("mlxsw_sp %p, vregion %p",
+		  __entry->mlxsw_sp, __entry->vregion)
+);
+
 #endif /* _MLXSW_TRACEPOINT_H */
 
 /* This part must be outside protection */
