bpf: Fix various lib and testsuite build failures on 32-bit.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [tools] bpf: Fix various lib and testsuite build failures on 32-bit (Yauheni Kaliuta) [1700846]
Rebuild_FUZZ: 99.16%
commit-author David Miller <davem@davemloft.net>
commit 1ad93ab10e24856ea1ae9f0fd3352992afa67e1b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/1ad93ab1.failed

Cannot cast a u64 to a pointer on 32-bit without an intervening (long)
cast otherwise GCC warns.

	Signed-off-by: David S. Miller <davem@davemloft.net>
	Acked-by: Song Liu <songliubraving@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit 1ad93ab10e24856ea1ae9f0fd3352992afa67e1b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/btf.c
diff --cc tools/lib/bpf/btf.c
index ad19a43e946a,c2d641f3e16e..000000000000
--- a/tools/lib/bpf/btf.c
+++ b/tools/lib/bpf/btf.c
@@@ -372,3 -406,337 +372,340 @@@ int btf__fd(const struct btf *btf
  {
  	return btf->fd;
  }
++<<<<<<< HEAD
++=======
+ 
+ const char *btf__name_by_offset(const struct btf *btf, __u32 offset)
+ {
+ 	if (offset < btf->hdr->str_len)
+ 		return &btf->strings[offset];
+ 	else
+ 		return NULL;
+ }
+ 
+ int btf__get_from_id(__u32 id, struct btf **btf)
+ {
+ 	struct bpf_btf_info btf_info = { 0 };
+ 	__u32 len = sizeof(btf_info);
+ 	__u32 last_size;
+ 	int btf_fd;
+ 	void *ptr;
+ 	int err;
+ 
+ 	err = 0;
+ 	*btf = NULL;
+ 	btf_fd = bpf_btf_get_fd_by_id(id);
+ 	if (btf_fd < 0)
+ 		return 0;
+ 
+ 	/* we won't know btf_size until we call bpf_obj_get_info_by_fd(). so
+ 	 * let's start with a sane default - 4KiB here - and resize it only if
+ 	 * bpf_obj_get_info_by_fd() needs a bigger buffer.
+ 	 */
+ 	btf_info.btf_size = 4096;
+ 	last_size = btf_info.btf_size;
+ 	ptr = malloc(last_size);
+ 	if (!ptr) {
+ 		err = -ENOMEM;
+ 		goto exit_free;
+ 	}
+ 
+ 	bzero(ptr, last_size);
+ 	btf_info.btf = ptr_to_u64(ptr);
+ 	err = bpf_obj_get_info_by_fd(btf_fd, &btf_info, &len);
+ 
+ 	if (!err && btf_info.btf_size > last_size) {
+ 		void *temp_ptr;
+ 
+ 		last_size = btf_info.btf_size;
+ 		temp_ptr = realloc(ptr, last_size);
+ 		if (!temp_ptr) {
+ 			err = -ENOMEM;
+ 			goto exit_free;
+ 		}
+ 		ptr = temp_ptr;
+ 		bzero(ptr, last_size);
+ 		btf_info.btf = ptr_to_u64(ptr);
+ 		err = bpf_obj_get_info_by_fd(btf_fd, &btf_info, &len);
+ 	}
+ 
+ 	if (err || btf_info.btf_size > last_size) {
+ 		err = errno;
+ 		goto exit_free;
+ 	}
+ 
+ 	*btf = btf__new((__u8 *)(long)btf_info.btf, btf_info.btf_size, NULL);
+ 	if (IS_ERR(*btf)) {
+ 		err = PTR_ERR(*btf);
+ 		*btf = NULL;
+ 	}
+ 
+ exit_free:
+ 	close(btf_fd);
+ 	free(ptr);
+ 
+ 	return err;
+ }
+ 
+ static int btf_ext_validate_func_info(const void *finfo, __u32 size,
+ 				      btf_print_fn_t err_log)
+ {
+ 	int sec_hdrlen = sizeof(struct btf_sec_func_info);
+ 	__u32 size_left, num_records, record_size;
+ 	const struct btf_sec_func_info *sinfo;
+ 	__u64 total_record_size;
+ 
+ 	/* At least a func_info record size */
+ 	if (size < sizeof(__u32)) {
+ 		elog("BTF.ext func_info record size not found");
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* The record size needs to meet below minimum standard */
+ 	record_size = *(__u32 *)finfo;
+ 	if (record_size < sizeof(struct bpf_func_info_min) ||
+ 	    record_size % sizeof(__u32)) {
+ 		elog("BTF.ext func_info invalid record size");
+ 		return -EINVAL;
+ 	}
+ 
+ 	sinfo = finfo + sizeof(__u32);
+ 	size_left = size - sizeof(__u32);
+ 
+ 	/* If no func_info records, return failure now so .BTF.ext
+ 	 * won't be used.
+ 	 */
+ 	if (!size_left) {
+ 		elog("BTF.ext no func info records");
+ 		return -EINVAL;
+ 	}
+ 
+ 	while (size_left) {
+ 		if (size_left < sec_hdrlen) {
+ 			elog("BTF.ext func_info header not found");
+ 			return -EINVAL;
+ 		}
+ 
+ 		num_records = sinfo->num_func_info;
+ 		if (num_records == 0) {
+ 			elog("incorrect BTF.ext num_func_info");
+ 			return -EINVAL;
+ 		}
+ 
+ 		total_record_size = sec_hdrlen +
+ 				    (__u64)num_records * record_size;
+ 		if (size_left < total_record_size) {
+ 			elog("incorrect BTF.ext num_func_info");
+ 			return -EINVAL;
+ 		}
+ 
+ 		size_left -= total_record_size;
+ 		sinfo = (void *)sinfo + total_record_size;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int btf_ext_parse_hdr(__u8 *data, __u32 data_size,
+ 			     btf_print_fn_t err_log)
+ {
+ 	const struct btf_ext_header *hdr = (struct btf_ext_header *)data;
+ 	__u32 meta_left, last_func_info_pos;
+ 	void *finfo;
+ 
+ 	if (data_size < offsetof(struct btf_ext_header, func_info_off) ||
+ 	    data_size < hdr->hdr_len) {
+ 		elog("BTF.ext header not found");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (hdr->magic != BTF_MAGIC) {
+ 		elog("Invalid BTF.ext magic:%x\n", hdr->magic);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (hdr->version != BTF_VERSION) {
+ 		elog("Unsupported BTF.ext version:%u\n", hdr->version);
+ 		return -ENOTSUP;
+ 	}
+ 
+ 	if (hdr->flags) {
+ 		elog("Unsupported BTF.ext flags:%x\n", hdr->flags);
+ 		return -ENOTSUP;
+ 	}
+ 
+ 	meta_left = data_size - hdr->hdr_len;
+ 	if (!meta_left) {
+ 		elog("BTF.ext has no data\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (meta_left < hdr->func_info_off) {
+ 		elog("Invalid BTF.ext func_info section offset:%u\n",
+ 		     hdr->func_info_off);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (hdr->func_info_off & 0x03) {
+ 		elog("BTF.ext func_info section is not aligned to 4 bytes\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	last_func_info_pos = hdr->hdr_len + hdr->func_info_off +
+ 			     hdr->func_info_len;
+ 	if (last_func_info_pos > data_size) {
+ 		elog("Invalid BTF.ext func_info section size:%u\n",
+ 		     hdr->func_info_len);
+ 		return -EINVAL;
+ 	}
+ 
+ 	finfo = data + hdr->hdr_len + hdr->func_info_off;
+ 	return btf_ext_validate_func_info(finfo, hdr->func_info_len,
+ 					  err_log);
+ }
+ 
+ void btf_ext__free(struct btf_ext *btf_ext)
+ {
+ 	if (!btf_ext)
+ 		return;
+ 
+ 	free(btf_ext->func_info);
+ 	free(btf_ext);
+ }
+ 
+ struct btf_ext *btf_ext__new(__u8 *data, __u32 size, btf_print_fn_t err_log)
+ {
+ 	const struct btf_ext_header *hdr;
+ 	struct btf_ext *btf_ext;
+ 	void *org_fdata, *fdata;
+ 	__u32 hdrlen, size_u32;
+ 	int err;
+ 
+ 	err = btf_ext_parse_hdr(data, size, err_log);
+ 	if (err)
+ 		return ERR_PTR(err);
+ 
+ 	btf_ext = calloc(1, sizeof(struct btf_ext));
+ 	if (!btf_ext)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	hdr = (const struct btf_ext_header *)data;
+ 	hdrlen = hdr->hdr_len;
+ 	size_u32 = sizeof(__u32);
+ 	fdata = malloc(hdr->func_info_len - size_u32);
+ 	if (!fdata) {
+ 		free(btf_ext);
+ 		return ERR_PTR(-ENOMEM);
+ 	}
+ 
+ 	/* remember record size and copy rest of func_info data */
+ 	org_fdata = data + hdrlen + hdr->func_info_off;
+ 	btf_ext->func_info_rec_size = *(__u32 *)org_fdata;
+ 	memcpy(fdata, org_fdata + size_u32, hdr->func_info_len - size_u32);
+ 	btf_ext->func_info = fdata;
+ 	btf_ext->func_info_len = hdr->func_info_len - size_u32;
+ 
+ 	return btf_ext;
+ }
+ 
+ int btf_ext__reloc_init(struct btf *btf, struct btf_ext *btf_ext,
+ 			const char *sec_name, void **func_info,
+ 			__u32 *func_info_rec_size, __u32 *func_info_len)
+ {
+ 	__u32 sec_hdrlen = sizeof(struct btf_sec_func_info);
+ 	__u32 i, record_size, records_len;
+ 	struct btf_sec_func_info *sinfo;
+ 	const char *info_sec_name;
+ 	__s64 remain_len;
+ 	void *data;
+ 
+ 	record_size = btf_ext->func_info_rec_size;
+ 	sinfo = btf_ext->func_info;
+ 	remain_len = btf_ext->func_info_len;
+ 
+ 	while (remain_len > 0) {
+ 		records_len = sinfo->num_func_info * record_size;
+ 		info_sec_name = btf__name_by_offset(btf, sinfo->sec_name_off);
+ 		if (strcmp(info_sec_name, sec_name)) {
+ 			remain_len -= sec_hdrlen + records_len;
+ 			sinfo = (void *)sinfo + sec_hdrlen + records_len;
+ 			continue;
+ 		}
+ 
+ 		data = malloc(records_len);
+ 		if (!data)
+ 			return -ENOMEM;
+ 
+ 		memcpy(data, sinfo->data, records_len);
+ 
+ 		/* adjust the insn_offset, the data in .BTF.ext is
+ 		 * the actual byte offset, and the kernel expects
+ 		 * the offset in term of bpf_insn.
+ 		 *
+ 		 * adjust the insn offset only, the rest data will
+ 		 * be passed to kernel.
+ 		 */
+ 		for (i = 0; i < sinfo->num_func_info; i++) {
+ 			struct bpf_func_info_min *record;
+ 
+ 			record = data + i * record_size;
+ 			record->insn_offset /= sizeof(struct bpf_insn);
+ 		}
+ 
+ 		*func_info = data;
+ 		*func_info_len = records_len;
+ 		*func_info_rec_size = record_size;
+ 		return 0;
+ 	}
+ 
+ 	return -EINVAL;
+ }
+ 
+ int btf_ext__reloc(struct btf *btf, struct btf_ext *btf_ext,
+ 		   const char *sec_name, __u32 insns_cnt,
+ 		   void **func_info, __u32 *func_info_len)
+ {
+ 	__u32 sec_hdrlen = sizeof(struct btf_sec_func_info);
+ 	__u32 i, record_size, existing_flen, records_len;
+ 	struct btf_sec_func_info *sinfo;
+ 	const char *info_sec_name;
+ 	__u64 remain_len;
+ 	void *data;
+ 
+ 	record_size = btf_ext->func_info_rec_size;
+ 	sinfo = btf_ext->func_info;
+ 	remain_len = btf_ext->func_info_len;
+ 	while (remain_len > 0) {
+ 		records_len = sinfo->num_func_info * record_size;
+ 		info_sec_name = btf__name_by_offset(btf, sinfo->sec_name_off);
+ 		if (strcmp(info_sec_name, sec_name)) {
+ 			remain_len -= sec_hdrlen + records_len;
+ 			sinfo = (void *)sinfo + sec_hdrlen + records_len;
+ 			continue;
+ 		}
+ 
+ 		existing_flen = *func_info_len;
+ 		data = realloc(*func_info, existing_flen + records_len);
+ 		if (!data)
+ 			return -ENOMEM;
+ 
+ 		memcpy(data + existing_flen, sinfo->data, records_len);
+ 		/* adjust insn_offset only, the rest data will be passed
+ 		 * to the kernel.
+ 		 */
+ 		for (i = 0; i < sinfo->num_func_info; i++) {
+ 			struct bpf_func_info_min *record;
+ 
+ 			record = data + existing_flen + i * record_size;
+ 			record->insn_offset =
+ 				record->insn_offset / sizeof(struct bpf_insn) +
+ 				insns_cnt;
+ 		}
+ 		*func_info = data;
+ 		*func_info_len = existing_flen + records_len;
+ 		return 0;
+ 	}
+ 
+ 	return -EINVAL;
+ }
++>>>>>>> 1ad93ab10e24 (bpf: Fix various lib and testsuite build failures on 32-bit.)
* Unmerged path tools/lib/bpf/btf.c
diff --git a/tools/testing/selftests/bpf/test_progs.c b/tools/testing/selftests/bpf/test_progs.c
index 631fffe5854a..04ef59e749a4 100644
--- a/tools/testing/selftests/bpf/test_progs.c
+++ b/tools/testing/selftests/bpf/test_progs.c
@@ -524,7 +524,7 @@ static void test_bpf_obj_id(void)
 			  load_time < now - 60 || load_time > now + 60 ||
 			  prog_infos[i].created_by_uid != my_uid ||
 			  prog_infos[i].nr_map_ids != 1 ||
-			  *(int *)prog_infos[i].map_ids != map_infos[i].id ||
+			  *(int *)(long)prog_infos[i].map_ids != map_infos[i].id ||
 			  strcmp((char *)prog_infos[i].name, expected_prog_name),
 			  "get-prog-info(fd)",
 			  "err %d errno %d i %d type %d(%d) info_len %u(%Zu) jit_enabled %d jited_prog_len %u xlated_prog_len %u jited_prog %d xlated_prog %d load_time %lu(%lu) uid %u(%u) nr_map_ids %u(%u) map_id %u(%u) name %s(%s)\n",
@@ -539,7 +539,7 @@ static void test_bpf_obj_id(void)
 			  load_time, now,
 			  prog_infos[i].created_by_uid, my_uid,
 			  prog_infos[i].nr_map_ids, 1,
-			  *(int *)prog_infos[i].map_ids, map_infos[i].id,
+			  *(int *)(long)prog_infos[i].map_ids, map_infos[i].id,
 			  prog_infos[i].name, expected_prog_name))
 			goto done;
 	}
@@ -585,7 +585,7 @@ static void test_bpf_obj_id(void)
 		bzero(&prog_info, sizeof(prog_info));
 		info_len = sizeof(prog_info);
 
-		saved_map_id = *(int *)(prog_infos[i].map_ids);
+		saved_map_id = *(int *)((long)prog_infos[i].map_ids);
 		prog_info.map_ids = prog_infos[i].map_ids;
 		prog_info.nr_map_ids = 2;
 		err = bpf_obj_get_info_by_fd(prog_fd, &prog_info, &info_len);
@@ -593,12 +593,12 @@ static void test_bpf_obj_id(void)
 		prog_infos[i].xlated_prog_insns = 0;
 		CHECK(err || info_len != sizeof(struct bpf_prog_info) ||
 		      memcmp(&prog_info, &prog_infos[i], info_len) ||
-		      *(int *)prog_info.map_ids != saved_map_id,
+		      *(int *)(long)prog_info.map_ids != saved_map_id,
 		      "get-prog-info(next_id->fd)",
 		      "err %d errno %d info_len %u(%Zu) memcmp %d map_id %u(%u)\n",
 		      err, errno, info_len, sizeof(struct bpf_prog_info),
 		      memcmp(&prog_info, &prog_infos[i], info_len),
-		      *(int *)prog_info.map_ids, saved_map_id);
+		      *(int *)(long)prog_info.map_ids, saved_map_id);
 		close(prog_fd);
 	}
 	CHECK(nr_id_found != nr_iters,
