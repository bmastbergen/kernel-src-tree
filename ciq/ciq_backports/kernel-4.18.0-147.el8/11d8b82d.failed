bpf: rename *_info_cnt to nr_*_info in bpf_prog_info

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Yonghong Song <yhs@fb.com>
commit 11d8b82d2222cade12caad2c125f23023777dcbc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/11d8b82d.failed

In uapi bpf.h, currently we have the following fields in
the struct bpf_prog_info:
	__u32 func_info_cnt;
	__u32 line_info_cnt;
	__u32 jited_line_info_cnt;
The above field names "func_info_cnt" and "line_info_cnt"
also appear in union bpf_attr for program loading.

The original intention is to keep the names the same
between bpf_prog_info and bpf_attr
so it will imply what we returned to user space will be
the same as what the user space passed to the kernel.

Such a naming convention in bpf_prog_info is not consistent
with other fields like:
        __u32 nr_jited_ksyms;
        __u32 nr_jited_func_lens;

This patch made this adjustment so in bpf_prog_info
newly introduced *_info_cnt becomes nr_*_info.

	Acked-by: Song Liu <songliubraving@fb.com>
	Acked-by: Martin KaFai Lau <kafai@fb.com>
	Signed-off-by: Yonghong Song <yhs@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit 11d8b82d2222cade12caad2c125f23023777dcbc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/bpf.h
#	kernel/bpf/syscall.c
diff --cc include/uapi/linux/bpf.h
index 3ec7fe43b907,f943ed803309..000000000000
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@@ -2445,6 -2693,16 +2445,19 @@@ struct bpf_prog_info 
  	__u32 nr_jited_func_lens;
  	__aligned_u64 jited_ksyms;
  	__aligned_u64 jited_func_lens;
++<<<<<<< HEAD
++=======
+ 	__u32 btf_id;
+ 	__u32 func_info_rec_size;
+ 	__aligned_u64 func_info;
+ 	__u32 nr_func_info;
+ 	__u32 nr_line_info;
+ 	__aligned_u64 line_info;
+ 	__aligned_u64 jited_line_info;
+ 	__u32 nr_jited_line_info;
+ 	__u32 line_info_rec_size;
+ 	__u32 jited_line_info_rec_size;
++>>>>>>> 11d8b82d2222 (bpf: rename *_info_cnt to nr_*_info in bpf_prog_info)
  } __attribute__((aligned(8)));
  
  struct bpf_map_info {
diff --cc kernel/bpf/syscall.c
index fa009c1c3655,5745c7837621..000000000000
--- a/kernel/bpf/syscall.c
+++ b/kernel/bpf/syscall.c
@@@ -2045,6 -2043,37 +2045,40 @@@ static struct bpf_insn *bpf_insn_prepar
  	return insns;
  }
  
++<<<<<<< HEAD
++=======
+ static int set_info_rec_size(struct bpf_prog_info *info)
+ {
+ 	/*
+ 	 * Ensure info.*_rec_size is the same as kernel expected size
+ 	 *
+ 	 * or
+ 	 *
+ 	 * Only allow zero *_rec_size if both _rec_size and _cnt are
+ 	 * zero.  In this case, the kernel will set the expected
+ 	 * _rec_size back to the info.
+ 	 */
+ 
+ 	if ((info->nr_func_info || info->func_info_rec_size) &&
+ 	    info->func_info_rec_size != sizeof(struct bpf_func_info))
+ 		return -EINVAL;
+ 
+ 	if ((info->nr_line_info || info->line_info_rec_size) &&
+ 	    info->line_info_rec_size != sizeof(struct bpf_line_info))
+ 		return -EINVAL;
+ 
+ 	if ((info->nr_jited_line_info || info->jited_line_info_rec_size) &&
+ 	    info->jited_line_info_rec_size != sizeof(__u64))
+ 		return -EINVAL;
+ 
+ 	info->func_info_rec_size = sizeof(struct bpf_func_info);
+ 	info->line_info_rec_size = sizeof(struct bpf_line_info);
+ 	info->jited_line_info_rec_size = sizeof(__u64);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 11d8b82d2222 (bpf: rename *_info_cnt to nr_*_info in bpf_prog_info)
  static int bpf_prog_get_info_by_fd(struct bpf_prog *prog,
  				   const union bpf_attr *attr,
  				   union bpf_attr __user *uattr)
@@@ -2092,6 -2125,9 +2126,12 @@@
  		info.xlated_prog_len = 0;
  		info.nr_jited_ksyms = 0;
  		info.nr_jited_func_lens = 0;
++<<<<<<< HEAD
++=======
+ 		info.nr_func_info = 0;
+ 		info.nr_line_info = 0;
+ 		info.nr_jited_line_info = 0;
++>>>>>>> 11d8b82d2222 (bpf: rename *_info_cnt to nr_*_info in bpf_prog_info)
  		goto done;
  	}
  
@@@ -2229,6 -2265,63 +2269,66 @@@
  		}
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (prog->aux->btf)
+ 		info.btf_id = btf_id(prog->aux->btf);
+ 
+ 	ulen = info.nr_func_info;
+ 	info.nr_func_info = prog->aux->func_info_cnt;
+ 	if (info.nr_func_info && ulen) {
+ 		if (bpf_dump_raw_ok()) {
+ 			char __user *user_finfo;
+ 
+ 			user_finfo = u64_to_user_ptr(info.func_info);
+ 			ulen = min_t(u32, info.nr_func_info, ulen);
+ 			if (copy_to_user(user_finfo, prog->aux->func_info,
+ 					 info.func_info_rec_size * ulen))
+ 				return -EFAULT;
+ 		} else {
+ 			info.func_info = 0;
+ 		}
+ 	}
+ 
+ 	ulen = info.nr_line_info;
+ 	info.nr_line_info = prog->aux->nr_linfo;
+ 	if (info.nr_line_info && ulen) {
+ 		if (bpf_dump_raw_ok()) {
+ 			__u8 __user *user_linfo;
+ 
+ 			user_linfo = u64_to_user_ptr(info.line_info);
+ 			ulen = min_t(u32, info.nr_line_info, ulen);
+ 			if (copy_to_user(user_linfo, prog->aux->linfo,
+ 					 info.line_info_rec_size * ulen))
+ 				return -EFAULT;
+ 		} else {
+ 			info.line_info = 0;
+ 		}
+ 	}
+ 
+ 	ulen = info.nr_jited_line_info;
+ 	if (prog->aux->jited_linfo)
+ 		info.nr_jited_line_info = prog->aux->nr_linfo;
+ 	else
+ 		info.nr_jited_line_info = 0;
+ 	if (info.nr_jited_line_info && ulen) {
+ 		if (bpf_dump_raw_ok()) {
+ 			__u64 __user *user_linfo;
+ 			u32 i;
+ 
+ 			user_linfo = u64_to_user_ptr(info.jited_line_info);
+ 			ulen = min_t(u32, info.nr_jited_line_info, ulen);
+ 			for (i = 0; i < ulen; i++) {
+ 				if (put_user((__u64)(long)prog->aux->jited_linfo[i],
+ 					     &user_linfo[i]))
+ 					return -EFAULT;
+ 			}
+ 		} else {
+ 			info.jited_line_info = 0;
+ 		}
+ 	}
+ 
++>>>>>>> 11d8b82d2222 (bpf: rename *_info_cnt to nr_*_info in bpf_prog_info)
  done:
  	if (copy_to_user(uinfo, &info, info_len) ||
  	    put_user(info_len, &uattr->info.info_len))
* Unmerged path include/uapi/linux/bpf.h
* Unmerged path kernel/bpf/syscall.c
