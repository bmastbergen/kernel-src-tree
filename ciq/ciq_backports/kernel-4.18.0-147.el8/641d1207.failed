IB/core: Move query port to ioctl

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Michael Guralnik <michaelgur@mellanox.com>
commit 641d1207d2ed0ef21ff5ad61e067d630028e2f62
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/641d1207.failed

Add a method for query port under the uverbs global methods.  Current
ib_port_attr struct is passed as a single attribute and port_cap_flags2 is
added as a new attribute to the function.

	Signed-off-by: Michael Guralnik <michaelgur@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 641d1207d2ed0ef21ff5ad61e067d630028e2f62)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs.h
#	drivers/infiniband/core/uverbs_cmd.c
#	drivers/infiniband/core/uverbs_std_types_device.c
#	include/uapi/rdma/ib_user_ioctl_cmds.h
#	include/uapi/rdma/ib_user_ioctl_verbs.h
diff --cc drivers/infiniband/core/uverbs.h
index 55f338e6340d,ea0bc6885517..000000000000
--- a/drivers/infiniband/core/uverbs.h
+++ b/drivers/infiniband/core/uverbs.h
@@@ -288,65 -293,29 +288,93 @@@ extern const struct uverbs_object_def U
  extern const struct uverbs_object_def UVERBS_OBJECT(UVERBS_OBJECT_DM);
  extern const struct uverbs_object_def UVERBS_OBJECT(UVERBS_OBJECT_COUNTERS);
  
++<<<<<<< HEAD
 +#define IB_UVERBS_DECLARE_CMD(name)					\
 +	ssize_t ib_uverbs_##name(struct ib_uverbs_file *file,		\
 +				 struct ib_device *ib_dev,              \
 +				 const char __user *buf, int in_len,	\
 +				 int out_len)
 +
 +IB_UVERBS_DECLARE_CMD(get_context);
 +IB_UVERBS_DECLARE_CMD(query_device);
 +IB_UVERBS_DECLARE_CMD(query_port);
 +IB_UVERBS_DECLARE_CMD(alloc_pd);
 +IB_UVERBS_DECLARE_CMD(dealloc_pd);
 +IB_UVERBS_DECLARE_CMD(reg_mr);
 +IB_UVERBS_DECLARE_CMD(rereg_mr);
 +IB_UVERBS_DECLARE_CMD(dereg_mr);
 +IB_UVERBS_DECLARE_CMD(alloc_mw);
 +IB_UVERBS_DECLARE_CMD(dealloc_mw);
 +IB_UVERBS_DECLARE_CMD(create_comp_channel);
 +IB_UVERBS_DECLARE_CMD(create_cq);
 +IB_UVERBS_DECLARE_CMD(resize_cq);
 +IB_UVERBS_DECLARE_CMD(poll_cq);
 +IB_UVERBS_DECLARE_CMD(req_notify_cq);
 +IB_UVERBS_DECLARE_CMD(destroy_cq);
 +IB_UVERBS_DECLARE_CMD(create_qp);
 +IB_UVERBS_DECLARE_CMD(open_qp);
 +IB_UVERBS_DECLARE_CMD(query_qp);
 +IB_UVERBS_DECLARE_CMD(modify_qp);
 +IB_UVERBS_DECLARE_CMD(destroy_qp);
 +IB_UVERBS_DECLARE_CMD(post_send);
 +IB_UVERBS_DECLARE_CMD(post_recv);
 +IB_UVERBS_DECLARE_CMD(post_srq_recv);
 +IB_UVERBS_DECLARE_CMD(create_ah);
 +IB_UVERBS_DECLARE_CMD(destroy_ah);
 +IB_UVERBS_DECLARE_CMD(attach_mcast);
 +IB_UVERBS_DECLARE_CMD(detach_mcast);
 +IB_UVERBS_DECLARE_CMD(create_srq);
 +IB_UVERBS_DECLARE_CMD(modify_srq);
 +IB_UVERBS_DECLARE_CMD(query_srq);
 +IB_UVERBS_DECLARE_CMD(destroy_srq);
 +IB_UVERBS_DECLARE_CMD(create_xsrq);
 +IB_UVERBS_DECLARE_CMD(open_xrcd);
 +IB_UVERBS_DECLARE_CMD(close_xrcd);
 +
 +#define IB_UVERBS_DECLARE_EX_CMD(name)				\
 +	int ib_uverbs_ex_##name(struct ib_uverbs_file *file,	\
 +				struct ib_device *ib_dev,		\
 +				struct ib_udata *ucore,		\
 +				struct ib_udata *uhw)
 +
 +IB_UVERBS_DECLARE_EX_CMD(create_flow);
 +IB_UVERBS_DECLARE_EX_CMD(destroy_flow);
 +IB_UVERBS_DECLARE_EX_CMD(query_device);
 +IB_UVERBS_DECLARE_EX_CMD(create_cq);
 +IB_UVERBS_DECLARE_EX_CMD(create_qp);
 +IB_UVERBS_DECLARE_EX_CMD(create_wq);
 +IB_UVERBS_DECLARE_EX_CMD(modify_wq);
 +IB_UVERBS_DECLARE_EX_CMD(destroy_wq);
 +IB_UVERBS_DECLARE_EX_CMD(create_rwq_ind_table);
 +IB_UVERBS_DECLARE_EX_CMD(destroy_rwq_ind_table);
 +IB_UVERBS_DECLARE_EX_CMD(modify_qp);
 +IB_UVERBS_DECLARE_EX_CMD(modify_cq);
 +
++=======
+ /*
+  * ib_uverbs_query_port_resp.port_cap_flags started out as just a copy of the
+  * PortInfo CapabilityMask, but was extended with unique bits.
+  */
+ static inline u32 make_port_cap_flags(const struct ib_port_attr *attr)
+ {
+ 	u32 res;
+ 
+ 	/* All IBA CapabilityMask bits are passed through here, except bit 26,
+ 	 * which is overridden with IP_BASED_GIDS. This is due to a historical
+ 	 * mistake in the implementation of IP_BASED_GIDS. Otherwise all other
+ 	 * bits match the IBA definition across all kernel versions.
+ 	 */
+ 	res = attr->port_cap_flags & ~(u32)IB_UVERBS_PCF_IP_BASED_GIDS;
+ 
+ 	if (attr->ip_gids)
+ 		res |= IB_UVERBS_PCF_IP_BASED_GIDS;
+ 
+ 	return res;
+ }
+ 
+ 
+ void copy_port_attr_to_resp(struct ib_port_attr *attr,
+ 			    struct ib_uverbs_query_port_resp *resp,
+ 			    struct ib_device *ib_dev, u8 port_num);
++>>>>>>> 641d1207d2ed (IB/core: Move query port to ioctl)
  #endif /* UVERBS_H */
diff --cc drivers/infiniband/core/uverbs_cmd.c
index 300532a4cde8,6b12cc5f97b2..000000000000
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@@ -227,47 -344,24 +227,51 @@@ ssize_t ib_uverbs_query_device(struct i
  {
  	struct ib_uverbs_query_device      cmd;
  	struct ib_uverbs_query_device_resp resp;
 -	struct ib_ucontext *ucontext;
 -	int ret;
  
 -	ucontext = ib_uverbs_get_ucontext(attrs);
 -	if (IS_ERR(ucontext))
 -		return PTR_ERR(ucontext);
 +	if (out_len < sizeof resp)
 +		return -ENOSPC;
  
 -	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
 -	if (ret)
 -		return ret;
 +	if (copy_from_user(&cmd, buf, sizeof cmd))
 +		return -EFAULT;
  
  	memset(&resp, 0, sizeof resp);
 -	copy_query_dev_fields(ucontext, &resp, &ucontext->device->attrs);
 +	copy_query_dev_fields(file, ib_dev, &resp, &ib_dev->attrs);
 +
 +	if (copy_to_user(u64_to_user_ptr(cmd.response), &resp, sizeof resp))
 +		return -EFAULT;
 +
 +	return in_len;
 +}
 +
++<<<<<<< HEAD
 +/*
 + * ib_uverbs_query_port_resp.port_cap_flags started out as just a copy of the
 + * PortInfo CapabilityMask, but was extended with unique bits.
 + */
 +static u32 make_port_cap_flags(const struct ib_port_attr *attr)
 +{
 +	u32 res;
 +
 +	/* All IBA CapabilityMask bits are passed through here, except bit 26,
 +	 * which is overridden with IP_BASED_GIDS. This is due to a historical
 +	 * mistake in the implementation of IP_BASED_GIDS. Otherwise all other
 +	 * bits match the IBA definition across all kernel versions.
 +	 */
 +	res = attr->port_cap_flags & ~(u32)IB_UVERBS_PCF_IP_BASED_GIDS;
  
 -	return uverbs_response(attrs, &resp, sizeof(resp));
 +	if (attr->ip_gids)
 +		res |= IB_UVERBS_PCF_IP_BASED_GIDS;
 +
 +	return res;
  }
  
 +ssize_t ib_uverbs_query_port(struct ib_uverbs_file *file,
 +			     struct ib_device *ib_dev,
 +			     const char __user *buf,
 +			     int in_len, int out_len)
++=======
+ static int ib_uverbs_query_port(struct uverbs_attr_bundle *attrs)
++>>>>>>> 641d1207d2ed (IB/core: Move query port to ioctl)
  {
  	struct ib_uverbs_query_port      cmd;
  	struct ib_uverbs_query_port_resp resp;
@@@ -285,48 -384,12 +289,18 @@@
  		return ret;
  
  	memset(&resp, 0, sizeof resp);
- 
- 	resp.state 	     = attr.state;
- 	resp.max_mtu 	     = attr.max_mtu;
- 	resp.active_mtu      = attr.active_mtu;
- 	resp.gid_tbl_len     = attr.gid_tbl_len;
- 	resp.port_cap_flags  = make_port_cap_flags(&attr);
- 	resp.max_msg_sz      = attr.max_msg_sz;
- 	resp.bad_pkey_cntr   = attr.bad_pkey_cntr;
- 	resp.qkey_viol_cntr  = attr.qkey_viol_cntr;
- 	resp.pkey_tbl_len    = attr.pkey_tbl_len;
- 
- 	if (rdma_is_grh_required(ib_dev, cmd.port_num))
- 		resp.flags |= IB_UVERBS_QPF_GRH_REQUIRED;
- 
- 	if (rdma_cap_opa_ah(ib_dev, cmd.port_num)) {
- 		resp.lid     = OPA_TO_IB_UCAST_LID(attr.lid);
- 		resp.sm_lid  = OPA_TO_IB_UCAST_LID(attr.sm_lid);
- 	} else {
- 		resp.lid     = ib_lid_cpu16(attr.lid);
- 		resp.sm_lid  = ib_lid_cpu16(attr.sm_lid);
- 	}
- 	resp.lmc 	     = attr.lmc;
- 	resp.max_vl_num      = attr.max_vl_num;
- 	resp.sm_sl 	     = attr.sm_sl;
- 	resp.subnet_timeout  = attr.subnet_timeout;
- 	resp.init_type_reply = attr.init_type_reply;
- 	resp.active_width    = attr.active_width;
- 	resp.active_speed    = attr.active_speed;
- 	resp.phys_state      = attr.phys_state;
- 	resp.link_layer      = rdma_port_get_link_layer(ib_dev,
- 							cmd.port_num);
+ 	copy_port_attr_to_resp(&attr, &resp, ib_dev, cmd.port_num);
  
 -	return uverbs_response(attrs, &resp, sizeof(resp));
 +	if (copy_to_user(u64_to_user_ptr(cmd.response), &resp, sizeof resp))
 +		return -EFAULT;
 +
 +	return in_len;
  }
  
 -static int ib_uverbs_alloc_pd(struct uverbs_attr_bundle *attrs)
 +ssize_t ib_uverbs_alloc_pd(struct ib_uverbs_file *file,
 +			   struct ib_device *ib_dev,
 +			   const char __user *buf,
 +			   int in_len, int out_len)
  {
  	struct ib_uverbs_alloc_pd      cmd;
  	struct ib_uverbs_alloc_pd_resp resp;
diff --cc include/uapi/rdma/ib_user_ioctl_cmds.h
index 2c881aaf05c2,64f0e3aacd3f..000000000000
--- a/include/uapi/rdma/ib_user_ioctl_cmds.h
+++ b/include/uapi/rdma/ib_user_ioctl_cmds.h
@@@ -63,6 -63,23 +63,26 @@@ enum 
  	UVERBS_ATTR_UHW_OUT,
  };
  
++<<<<<<< HEAD
++=======
+ enum uverbs_methods_device {
+ 	UVERBS_METHOD_INVOKE_WRITE,
+ 	UVERBS_METHOD_INFO_HANDLES,
+ 	UVERBS_METHOD_QUERY_PORT,
+ };
+ 
+ enum uverbs_attrs_invoke_write_cmd_attr_ids {
+ 	UVERBS_ATTR_CORE_IN,
+ 	UVERBS_ATTR_CORE_OUT,
+ 	UVERBS_ATTR_WRITE_CMD,
+ };
+ 
+ enum uverbs_attrs_query_port_cmd_attr_ids {
+ 	UVERBS_ATTR_QUERY_PORT_PORT_NUM,
+ 	UVERBS_ATTR_QUERY_PORT_RESP,
+ };
+ 
++>>>>>>> 641d1207d2ed (IB/core: Move query port to ioctl)
  enum uverbs_attrs_create_cq_cmd_attr_ids {
  	UVERBS_ATTR_CREATE_CQ_HANDLE,
  	UVERBS_ATTR_CREATE_CQ_CQE,
@@@ -157,4 -187,58 +177,61 @@@ enum uverbs_methods_actions_counters_op
  	UVERBS_METHOD_COUNTERS_READ,
  };
  
++<<<<<<< HEAD
++=======
+ enum uverbs_attrs_info_handles_id {
+ 	UVERBS_ATTR_INFO_OBJECT_ID,
+ 	UVERBS_ATTR_INFO_TOTAL_HANDLES,
+ 	UVERBS_ATTR_INFO_HANDLES_LIST,
+ };
+ 
+ enum uverbs_methods_pd {
+ 	UVERBS_METHOD_PD_DESTROY,
+ };
+ 
+ enum uverbs_attrs_pd_destroy_ids {
+ 	UVERBS_ATTR_DESTROY_PD_HANDLE,
+ };
+ 
+ enum uverbs_methods_mw {
+ 	UVERBS_METHOD_MW_DESTROY,
+ };
+ 
+ enum uverbs_attrs_mw_destroy_ids {
+ 	UVERBS_ATTR_DESTROY_MW_HANDLE,
+ };
+ 
+ enum uverbs_methods_xrcd {
+ 	UVERBS_METHOD_XRCD_DESTROY,
+ };
+ 
+ enum uverbs_attrs_xrcd_destroy_ids {
+ 	UVERBS_ATTR_DESTROY_XRCD_HANDLE,
+ };
+ 
+ enum uverbs_methods_ah {
+ 	UVERBS_METHOD_AH_DESTROY,
+ };
+ 
+ enum uverbs_attrs_ah_destroy_ids {
+ 	UVERBS_ATTR_DESTROY_AH_HANDLE,
+ };
+ 
+ enum uverbs_methods_rwq_ind_tbl {
+ 	UVERBS_METHOD_RWQ_IND_TBL_DESTROY,
+ };
+ 
+ enum uverbs_attrs_rwq_ind_tbl_destroy_ids {
+ 	UVERBS_ATTR_DESTROY_RWQ_IND_TBL_HANDLE,
+ };
+ 
+ enum uverbs_methods_flow {
+ 	UVERBS_METHOD_FLOW_DESTROY,
+ };
+ 
+ enum uverbs_attrs_flow_destroy_ids {
+ 	UVERBS_ATTR_DESTROY_FLOW_HANDLE,
+ };
+ 
++>>>>>>> 641d1207d2ed (IB/core: Move query port to ioctl)
  #endif
diff --cc include/uapi/rdma/ib_user_ioctl_verbs.h
index 6cdf192070a2,72c7fc75f960..000000000000
--- a/include/uapi/rdma/ib_user_ioctl_verbs.h
+++ b/include/uapi/rdma/ib_user_ioctl_verbs.h
@@@ -157,4 -158,19 +158,22 @@@ enum ib_uverbs_read_counters_flags 
  	IB_UVERBS_READ_COUNTERS_PREFER_CACHED = 1 << 0,
  };
  
++<<<<<<< HEAD
++=======
+ enum ib_uverbs_advise_mr_advice {
+ 	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH,
+ 	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_WRITE,
+ };
+ 
+ enum ib_uverbs_advise_mr_flag {
+ 	IB_UVERBS_ADVISE_MR_FLAG_FLUSH = 1 << 0,
+ };
+ 
+ struct ib_uverbs_query_port_resp_ex {
+ 	struct ib_uverbs_query_port_resp legacy_resp;
+ 	__u16 port_cap_flags2;
+ 	__u8  reserved[6];
+ };
+ 
++>>>>>>> 641d1207d2ed (IB/core: Move query port to ioctl)
  #endif
* Unmerged path drivers/infiniband/core/uverbs_std_types_device.c
* Unmerged path drivers/infiniband/core/uverbs.h
* Unmerged path drivers/infiniband/core/uverbs_cmd.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_device.c
* Unmerged path include/uapi/rdma/ib_user_ioctl_cmds.h
* Unmerged path include/uapi/rdma/ib_user_ioctl_verbs.h
