devlink: Add health reporter create/destroy functionality

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Eran Ben Elisha <eranbe@mellanox.com>
commit 880ee82f0313453ec5a6cb122866ac057263066b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/880ee82f.failed

Devlink health reporter is an instance for reporting, diagnosing and
recovering from run time errors discovered by the reporters.
Define it's data structure and supported operations.
In addition, expose devlink API to create and destroy a reporter.
Each devlink instance will hold it's own reporters list.

As part of the allocation, driver shall provide a set of callbacks which
will be used the devlink in order to handle health reports and user
commands related to this reporter. In addition, driver is entitled to
provide some priv pointer, which can be fetched from the reporter by
devlink_health_reporter_priv function.

For each reporter, devlink will hold a metadata of statistics,
buffers and status.

	Signed-off-by: Eran Ben Elisha <eranbe@mellanox.com>
	Reviewed-by: Moshe Shemesh <moshe@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 880ee82f0313453ec5a6cb122866ac057263066b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/devlink.h
diff --cc include/net/devlink.h
index 4d183c766687,7fe30d67678a..000000000000
--- a/include/net/devlink.h
+++ b/include/net/devlink.h
@@@ -426,7 -424,35 +427,39 @@@ struct devlink_info_req
  
  typedef void devlink_snapshot_data_dest_t(const void *data);
  
++<<<<<<< HEAD
 +struct devlink_fmsg;
++=======
+ struct devlink_health_buffer;
+ struct devlink_health_reporter;
+ 
+ /**
+  * struct devlink_health_reporter_ops - Reporter operations
+  * @name: reporter name
+  * dump_size: dump buffer size allocated by the devlink
+  * diagnose_size: diagnose buffer size allocated by the devlink
+  * recover: callback to recover from reported error
+  *          if priv_ctx is NULL, run a full recover
+  * dump: callback to dump an object
+  *       if priv_ctx is NULL, run a full dump
+  * diagnose: callback to diagnose the current status
+  */
+ 
+ struct devlink_health_reporter_ops {
+ 	char *name;
+ 	unsigned int dump_size;
+ 	unsigned int diagnose_size;
+ 	int (*recover)(struct devlink_health_reporter *reporter,
+ 		       void *priv_ctx);
+ 	int (*dump)(struct devlink_health_reporter *reporter,
+ 		    struct devlink_health_buffer **buffers_array,
+ 		    unsigned int buffer_size, unsigned int num_buffers,
+ 		    void *priv_ctx);
+ 	int (*diagnose)(struct devlink_health_reporter *reporter,
+ 			struct devlink_health_buffer **buffers_array,
+ 			unsigned int buffer_size, unsigned int num_buffers);
+ };
++>>>>>>> 880ee82f0313 (devlink: Add health reporter create/destroy functionality)
  
  struct devlink_ops {
  	int (*reload)(struct devlink *devlink, struct netlink_ext_ack *extack);
@@@ -605,51 -614,33 +638,80 @@@ u32 devlink_region_shapshot_id_get(stru
  int devlink_region_snapshot_create(struct devlink_region *region, u64 data_len,
  				   u8 *data, u32 snapshot_id,
  				   devlink_snapshot_data_dest_t *data_destructor);
 -
 +int devlink_info_serial_number_put(struct devlink_info_req *req,
 +				   const char *sn);
 +int devlink_info_driver_name_put(struct devlink_info_req *req,
 +				 const char *name);
 +int devlink_info_version_fixed_put(struct devlink_info_req *req,
 +				   const char *version_name,
 +				   const char *version_value);
 +int devlink_info_version_stored_put(struct devlink_info_req *req,
 +				    const char *version_name,
 +				    const char *version_value);
 +int devlink_info_version_running_put(struct devlink_info_req *req,
 +				     const char *version_name,
 +				     const char *version_value);
 +
 +int devlink_fmsg_obj_nest_start(struct devlink_fmsg *fmsg);
 +int devlink_fmsg_obj_nest_end(struct devlink_fmsg *fmsg);
 +
 +int devlink_fmsg_pair_nest_start(struct devlink_fmsg *fmsg, const char *name);
 +int devlink_fmsg_pair_nest_end(struct devlink_fmsg *fmsg);
 +
 +int devlink_fmsg_arr_pair_nest_start(struct devlink_fmsg *fmsg,
 +				     const char *name);
 +int devlink_fmsg_arr_pair_nest_end(struct devlink_fmsg *fmsg);
 +
 +int devlink_fmsg_bool_put(struct devlink_fmsg *fmsg, bool value);
 +int devlink_fmsg_u8_put(struct devlink_fmsg *fmsg, u8 value);
 +int devlink_fmsg_u32_put(struct devlink_fmsg *fmsg, u32 value);
 +int devlink_fmsg_u64_put(struct devlink_fmsg *fmsg, u64 value);
 +int devlink_fmsg_string_put(struct devlink_fmsg *fmsg, const char *value);
 +int devlink_fmsg_binary_put(struct devlink_fmsg *fmsg, const void *value,
 +			    u16 value_len);
 +
 +int devlink_fmsg_bool_pair_put(struct devlink_fmsg *fmsg, const char *name,
 +			       bool value);
 +int devlink_fmsg_u8_pair_put(struct devlink_fmsg *fmsg, const char *name,
 +			     u8 value);
 +int devlink_fmsg_u32_pair_put(struct devlink_fmsg *fmsg, const char *name,
 +			      u32 value);
 +int devlink_fmsg_u64_pair_put(struct devlink_fmsg *fmsg, const char *name,
 +			      u64 value);
 +int devlink_fmsg_string_pair_put(struct devlink_fmsg *fmsg, const char *name,
 +				 const char *value);
 +int devlink_fmsg_binary_pair_put(struct devlink_fmsg *fmsg, const char *name,
 +				 const void *value, u16 value_len);
 +
++<<<<<<< HEAD
++=======
+ int devlink_health_buffer_nest_start(struct devlink_health_buffer *buffer,
+ 				     int attrtype);
+ void devlink_health_buffer_nest_end(struct devlink_health_buffer *buffer);
+ void devlink_health_buffer_nest_cancel(struct devlink_health_buffer *buffer);
+ int devlink_health_buffer_put_object_name(struct devlink_health_buffer *buffer,
+ 					  char *name);
+ int devlink_health_buffer_put_value_u8(struct devlink_health_buffer *buffer,
+ 				       u8 value);
+ int devlink_health_buffer_put_value_u32(struct devlink_health_buffer *buffer,
+ 					u32 value);
+ int devlink_health_buffer_put_value_u64(struct devlink_health_buffer *buffer,
+ 					u64 value);
+ int devlink_health_buffer_put_value_string(struct devlink_health_buffer *buffer,
+ 					   char *name);
+ int devlink_health_buffer_put_value_data(struct devlink_health_buffer *buffer,
+ 					 void *data, int len);
+ struct devlink_health_reporter *
+ devlink_health_reporter_create(struct devlink *devlink,
+ 			       const struct devlink_health_reporter_ops *ops,
+ 			       u64 graceful_period, bool auto_recover,
+ 			       void *priv);
+ void
+ devlink_health_reporter_destroy(struct devlink_health_reporter *reporter);
+ 
+ void *
+ devlink_health_reporter_priv(struct devlink_health_reporter *reporter);
++>>>>>>> 880ee82f0313 (devlink: Add health reporter create/destroy functionality)
  #else
  
  static inline struct devlink *devlink_alloc(const struct devlink_ops *ops,
@@@ -1098,16 -959,26 +1160,36 @@@ devlink_fmsg_binary_pair_put(struct dev
  {
  	return 0;
  }
+ 
+ static inline struct devlink_health_reporter *
+ devlink_health_reporter_create(struct devlink *devlink,
+ 			       const struct devlink_health_reporter_ops *ops,
+ 			       u64 graceful_period, bool auto_recover,
+ 			       void *priv)
+ {
+ 	return NULL;
+ }
+ 
+ static inline void
+ devlink_health_reporter_destroy(struct devlink_health_reporter *reporter)
+ {
+ }
+ 
+ static inline void *
+ devlink_health_reporter_priv(struct devlink_health_reporter *reporter)
+ {
+ 	return NULL;
+ }
  #endif
  
 +#if IS_REACHABLE(CONFIG_NET_DEVLINK)
 +void devlink_compat_running_version(struct net_device *dev,
 +				    char *buf, size_t len);
 +#else
 +static inline void
 +devlink_compat_running_version(struct net_device *dev, char *buf, size_t len)
 +{
 +}
 +#endif
 +
  #endif /* _NET_DEVLINK_H_ */
* Unmerged path include/net/devlink.h
diff --git a/net/core/devlink.c b/net/core/devlink.c
index 14d28d5d1c6c..d00a38ae1e8d 100644
--- a/net/core/devlink.c
+++ b/net/core/devlink.c
@@ -4368,6 +4368,132 @@ static int devlink_fmsg_snd(struct devlink_fmsg *fmsg,
 	return err;
 }
 
+struct devlink_health_reporter {
+	struct list_head list;
+	struct devlink_health_buffer **dump_buffers_array;
+	struct mutex dump_lock; /* lock parallel read/write from dump buffers */
+	struct devlink_health_buffer **diagnose_buffers_array;
+	struct mutex diagnose_lock; /* lock parallel read/write from diagnose buffers */
+	void *priv;
+	const struct devlink_health_reporter_ops *ops;
+	struct devlink *devlink;
+	u64 graceful_period;
+	bool auto_recover;
+	u8 health_state;
+};
+
+void *
+devlink_health_reporter_priv(struct devlink_health_reporter *reporter)
+{
+	return reporter->priv;
+}
+EXPORT_SYMBOL_GPL(devlink_health_reporter_priv);
+
+static struct devlink_health_reporter *
+devlink_health_reporter_find_by_name(struct devlink *devlink,
+				     const char *reporter_name)
+{
+	struct devlink_health_reporter *reporter;
+
+	list_for_each_entry(reporter, &devlink->reporter_list, list)
+		if (!strcmp(reporter->ops->name, reporter_name))
+			return reporter;
+	return NULL;
+}
+
+/**
+ *	devlink_health_reporter_create - create devlink health reporter
+ *
+ *	@devlink: devlink
+ *	@ops: ops
+ *	@graceful_period: to avoid recovery loops, in msecs
+ *	@auto_recover: auto recover when error occurs
+ *	@priv: priv
+ */
+struct devlink_health_reporter *
+devlink_health_reporter_create(struct devlink *devlink,
+			       const struct devlink_health_reporter_ops *ops,
+			       u64 graceful_period, bool auto_recover,
+			       void *priv)
+{
+	struct devlink_health_reporter *reporter;
+
+	mutex_lock(&devlink->lock);
+	if (devlink_health_reporter_find_by_name(devlink, ops->name)) {
+		reporter = ERR_PTR(-EEXIST);
+		goto unlock;
+	}
+
+	if (WARN_ON(ops->dump && !ops->dump_size) ||
+	    WARN_ON(ops->diagnose && !ops->diagnose_size) ||
+	    WARN_ON(auto_recover && !ops->recover) ||
+	    WARN_ON(graceful_period && !ops->recover)) {
+		reporter = ERR_PTR(-EINVAL);
+		goto unlock;
+	}
+
+	reporter = kzalloc(sizeof(*reporter), GFP_KERNEL);
+	if (!reporter) {
+		reporter = ERR_PTR(-ENOMEM);
+		goto unlock;
+	}
+
+	if (ops->dump) {
+		reporter->dump_buffers_array =
+			devlink_health_buffers_create(ops->dump_size);
+		if (!reporter->dump_buffers_array) {
+			kfree(reporter);
+			reporter = ERR_PTR(-ENOMEM);
+			goto unlock;
+		}
+	}
+
+	if (ops->diagnose) {
+		reporter->diagnose_buffers_array =
+			devlink_health_buffers_create(ops->diagnose_size);
+		if (!reporter->diagnose_buffers_array) {
+			devlink_health_buffers_destroy(reporter->dump_buffers_array,
+						       DEVLINK_HEALTH_SIZE_TO_BUFFERS(ops->dump_size));
+			kfree(reporter);
+			reporter = ERR_PTR(-ENOMEM);
+			goto unlock;
+		}
+	}
+
+	list_add_tail(&reporter->list, &devlink->reporter_list);
+	mutex_init(&reporter->dump_lock);
+	mutex_init(&reporter->diagnose_lock);
+
+	reporter->priv = priv;
+	reporter->ops = ops;
+	reporter->devlink = devlink;
+	reporter->graceful_period = graceful_period;
+	reporter->auto_recover = auto_recover;
+unlock:
+	mutex_unlock(&devlink->lock);
+	return reporter;
+}
+EXPORT_SYMBOL_GPL(devlink_health_reporter_create);
+
+/**
+ *	devlink_health_reporter_destroy - destroy devlink health reporter
+ *
+ *	@reporter: devlink health reporter to destroy
+ */
+void
+devlink_health_reporter_destroy(struct devlink_health_reporter *reporter)
+{
+	mutex_lock(&reporter->devlink->lock);
+	list_del(&reporter->list);
+	devlink_health_buffers_destroy(reporter->dump_buffers_array,
+				       DEVLINK_HEALTH_SIZE_TO_BUFFERS(reporter->ops->dump_size));
+	devlink_health_buffers_destroy(reporter->diagnose_buffers_array,
+				       DEVLINK_HEALTH_SIZE_TO_BUFFERS(reporter->ops->diagnose_size));
+	kfree(reporter);
+	mutex_unlock(&reporter->devlink->lock);
+}
+EXPORT_SYMBOL_GPL(devlink_health_reporter_destroy);
+
 static const struct nla_policy devlink_nl_policy[DEVLINK_ATTR_MAX + 1] = {
 	[DEVLINK_ATTR_BUS_NAME] = { .type = NLA_NUL_STRING },
 	[DEVLINK_ATTR_DEV_NAME] = { .type = NLA_NUL_STRING },
@@ -4676,6 +4802,7 @@ struct devlink *devlink_alloc(const struct devlink_ops *ops, size_t priv_size)
 	INIT_LIST_HEAD(&devlink->resource_list);
 	INIT_LIST_HEAD(&devlink->param_list);
 	INIT_LIST_HEAD(&devlink->region_list);
+	INIT_LIST_HEAD(&devlink->reporter_list);
 	mutex_init(&devlink->lock);
 	return devlink;
 }
