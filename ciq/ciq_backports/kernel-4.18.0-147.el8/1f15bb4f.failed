net: sched: flower: only return error from hw offload if skip_sw

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [net] sched: flower: only return error from hw offload if skip_sw (Ivan Vecera) [1691738]
Rebuild_FUZZ: 95.93%
commit-author Vlad Buslov <vladbu@mellanox.com>
commit 1f15bb4f399ceccd85522b24af31198f53516f9b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/1f15bb4f.failed

Recently introduced tc_setup_flow_action() can fail when parsing tcf_exts
on some unsupported action commands. However, this should not affect the
case when user did not explicitly request hw offload by setting skip_sw
flag. Modify tc_setup_flow_action() callers to only propagate the error if
skip_sw flag is set for filter that is being offloaded, and set extack
error message in that case.

	Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
Fixes: 3a7b68617de7 ("cls_api: add translator to flow_action representation")
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1f15bb4f399ceccd85522b24af31198f53516f9b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/cls_flower.c
diff --cc net/sched/cls_flower.c
index d984c61e0ed5,640f83e7f93f..000000000000
--- a/net/sched/cls_flower.c
+++ b/net/sched/cls_flower.c
@@@ -306,14 -384,28 +306,30 @@@ static int fl_hw_replace_filter(struct 
  	tc_cls_common_offload_init(&cls_flower.common, tp, f->flags, extack);
  	cls_flower.command = TC_CLSFLOWER_REPLACE;
  	cls_flower.cookie = (unsigned long) f;
 -	cls_flower.rule->match.dissector = &f->mask->dissector;
 -	cls_flower.rule->match.mask = &f->mask->key;
 -	cls_flower.rule->match.key = &f->mkey;
 +	cls_flower.dissector = &f->mask->dissector;
 +	cls_flower.mask = &f->mask->key;
 +	cls_flower.key = &f->mkey;
 +	cls_flower.exts = &f->exts;
  	cls_flower.classid = f->res.classid;
  
++<<<<<<< HEAD
 +	err = tc_setup_cb_call(block, &f->exts, TC_SETUP_CLSFLOWER,
 +			       &cls_flower, skip_sw);
++=======
+ 	err = tc_setup_flow_action(&cls_flower.rule->action, &f->exts);
+ 	if (err) {
+ 		kfree(cls_flower.rule);
+ 		if (skip_sw) {
+ 			NL_SET_ERR_MSG_MOD(extack, "Failed to setup flow action");
+ 			return err;
+ 		}
+ 		return 0;
+ 	}
+ 
+ 	err = tc_setup_cb_call(block, TC_SETUP_CLSFLOWER, &cls_flower, skip_sw);
+ 	kfree(cls_flower.rule);
+ 
++>>>>>>> 1f15bb4f399c (net: sched: flower: only return error from hw offload if skip_sw)
  	if (err < 0) {
  		fl_hw_destroy_filter(tp, f, NULL);
  		return err;
@@@ -1349,10 -1499,21 +1365,28 @@@ static int fl_reoffload(struct tcf_prot
  			cls_flower.command = add ?
  				TC_CLSFLOWER_REPLACE : TC_CLSFLOWER_DESTROY;
  			cls_flower.cookie = (unsigned long)f;
++<<<<<<< HEAD
 +			cls_flower.dissector = &mask->dissector;
 +			cls_flower.mask = &mask->key;
 +			cls_flower.key = &f->mkey;
 +			cls_flower.exts = &f->exts;
++=======
+ 			cls_flower.rule->match.dissector = &mask->dissector;
+ 			cls_flower.rule->match.mask = &mask->key;
+ 			cls_flower.rule->match.key = &f->mkey;
+ 
+ 			err = tc_setup_flow_action(&cls_flower.rule->action,
+ 						   &f->exts);
+ 			if (err) {
+ 				kfree(cls_flower.rule);
+ 				if (tc_skip_sw(f->flags)) {
+ 					NL_SET_ERR_MSG_MOD(extack, "Failed to setup flow action");
+ 					return err;
+ 				}
+ 				continue;
+ 			}
+ 
++>>>>>>> 1f15bb4f399c (net: sched: flower: only return error from hw offload if skip_sw)
  			cls_flower.classid = f->res.classid;
  
  			err = cb(TC_SETUP_CLSFLOWER, &cls_flower, cb_priv);
* Unmerged path net/sched/cls_flower.c
