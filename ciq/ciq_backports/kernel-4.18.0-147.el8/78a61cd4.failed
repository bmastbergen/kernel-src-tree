nvme-multipath: drop optimization for static ANA group IDs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Hannes Reinecke <hare@suse.de>
commit 78a61cd42a64f3587862b372a79e1d6aaf131fd7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/78a61cd4.failed

Bit 6 in the ANACAP field is used to indicate that the ANA group ID
doesn't change while the namespace is attached to the controller.
There is an optimisation in the code to only allocate space
for the ANA group header, as the namespace list won't change and
hence would not need to be refreshed.
However, this optimisation was never carried over to the actual
workflow, which always assumes that the buffer is large enough
to hold the ANA header _and_ the namespace list.
So drop this optimisation and always allocate enough space.

	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 78a61cd42a64f3587862b372a79e1d6aaf131fd7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/multipath.c
diff --cc drivers/nvme/host/multipath.c
index 1b128a2a399e,b9fff3b8ed1b..000000000000
--- a/drivers/nvme/host/multipath.c
+++ b/drivers/nvme/host/multipath.c
@@@ -228,3 -528,55 +228,58 @@@ void nvme_mpath_remove_disk(struct nvme
  	blk_cleanup_queue(head->disk->queue);
  	put_disk(head->disk);
  }
++<<<<<<< HEAD
++=======
+ 
+ int nvme_mpath_init(struct nvme_ctrl *ctrl, struct nvme_id_ctrl *id)
+ {
+ 	int error;
+ 
+ 	if (!nvme_ctrl_use_ana(ctrl))
+ 		return 0;
+ 
+ 	ctrl->anacap = id->anacap;
+ 	ctrl->anatt = id->anatt;
+ 	ctrl->nanagrpid = le32_to_cpu(id->nanagrpid);
+ 	ctrl->anagrpmax = le32_to_cpu(id->anagrpmax);
+ 
+ 	mutex_init(&ctrl->ana_lock);
+ 	timer_setup(&ctrl->anatt_timer, nvme_anatt_timeout, 0);
+ 	ctrl->ana_log_size = sizeof(struct nvme_ana_rsp_hdr) +
+ 		ctrl->nanagrpid * sizeof(struct nvme_ana_group_desc);
+ 	ctrl->ana_log_size += ctrl->max_namespaces * sizeof(__le32);
+ 
+ 	if (ctrl->ana_log_size > ctrl->max_hw_sectors << SECTOR_SHIFT) {
+ 		dev_err(ctrl->device,
+ 			"ANA log page size (%zd) larger than MDTS (%d).\n",
+ 			ctrl->ana_log_size,
+ 			ctrl->max_hw_sectors << SECTOR_SHIFT);
+ 		dev_err(ctrl->device, "disabling ANA support.\n");
+ 		return 0;
+ 	}
+ 
+ 	INIT_WORK(&ctrl->ana_work, nvme_ana_work);
+ 	ctrl->ana_log_buf = kmalloc(ctrl->ana_log_size, GFP_KERNEL);
+ 	if (!ctrl->ana_log_buf) {
+ 		error = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	error = nvme_read_ana_log(ctrl, true);
+ 	if (error)
+ 		goto out_free_ana_log_buf;
+ 	return 0;
+ out_free_ana_log_buf:
+ 	kfree(ctrl->ana_log_buf);
+ 	ctrl->ana_log_buf = NULL;
+ out:
+ 	return error;
+ }
+ 
+ void nvme_mpath_uninit(struct nvme_ctrl *ctrl)
+ {
+ 	kfree(ctrl->ana_log_buf);
+ 	ctrl->ana_log_buf = NULL;
+ }
+ 
++>>>>>>> 78a61cd42a64 (nvme-multipath: drop optimization for static ANA group IDs)
* Unmerged path drivers/nvme/host/multipath.c
