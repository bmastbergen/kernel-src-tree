IB/mlx5: Verify DEVX object type

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Yishai Hadas <yishaih@mellanox.com>
commit 2351776e87a18318b5f4732e7790f0c726cc37a0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/2351776e.failed

Verify that the input DEVX object type matches the created object.

As the obj_id in the firmware is not globally unique the object type must
be considered upon checking for a valid object id.

Once both the type and the id match we know that the lock was taken on the
correct object by the uverbs layer.

Fixes: e662e14d801b ("IB/mlx5: Add DEVX support for modify and query commands")
	Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
	Reviewed-by: Artemy Kovalyov <artemyko@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 2351776e87a18318b5f4732e7790f0c726cc37a0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/devx.c
diff --cc drivers/infiniband/hw/mlx5/devx.c
index c7f8859c08ee,61aab7c0c513..000000000000
--- a/drivers/infiniband/hw/mlx5/devx.c
+++ b/drivers/infiniband/hw/mlx5/devx.c
@@@ -71,11 -84,347 +71,351 @@@ void mlx5_ib_devx_destroy(struct mlx5_i
  	mlx5_cmd_exec(dev->mdev, in, sizeof(in), out, sizeof(out));
  }
  
++<<<<<<< HEAD
 +static bool devx_is_obj_create_cmd(const void *in)
++=======
+ bool mlx5_ib_devx_is_flow_dest(void *obj, int *dest_id, int *dest_type)
+ {
+ 	struct devx_obj *devx_obj = obj;
+ 	u16 opcode = MLX5_GET(general_obj_in_cmd_hdr, devx_obj->dinbox, opcode);
+ 
+ 	switch (opcode) {
+ 	case MLX5_CMD_OP_DESTROY_TIR:
+ 		*dest_type = MLX5_FLOW_DESTINATION_TYPE_TIR;
+ 		*dest_id = MLX5_GET(general_obj_in_cmd_hdr, devx_obj->dinbox,
+ 				    obj_id);
+ 		return true;
+ 
+ 	case MLX5_CMD_OP_DESTROY_FLOW_TABLE:
+ 		*dest_type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
+ 		*dest_id = MLX5_GET(destroy_flow_table_in, devx_obj->dinbox,
+ 				    table_id);
+ 		return true;
+ 	default:
+ 		return false;
+ 	}
+ }
+ 
+ /*
+  * As the obj_id in the firmware is not globally unique the object type
+  * must be considered upon checking for a valid object id.
+  * For that the opcode of the creator command is encoded as part of the obj_id.
+  */
+ static u64 get_enc_obj_id(u16 opcode, u32 obj_id)
+ {
+ 	return ((u64)opcode << 32) | obj_id;
+ }
+ 
+ static int devx_is_valid_obj_id(struct devx_obj *obj, const void *in)
  {
  	u16 opcode = MLX5_GET(general_obj_in_cmd_hdr, in, opcode);
+ 	u64 obj_id;
  
  	switch (opcode) {
+ 	case MLX5_CMD_OP_MODIFY_GENERAL_OBJECT:
+ 	case MLX5_CMD_OP_QUERY_GENERAL_OBJECT:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_GENERAL_OBJECT,
+ 					MLX5_GET(general_obj_in_cmd_hdr, in,
+ 						 obj_id));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_MKEY:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_MKEY,
+ 					MLX5_GET(query_mkey_in, in,
+ 						 mkey_index));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_CQ:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_CQ,
+ 					MLX5_GET(query_cq_in, in, cqn));
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_CQ:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_CQ,
+ 					MLX5_GET(modify_cq_in, in, cqn));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_SQ:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_SQ,
+ 					MLX5_GET(query_sq_in, in, sqn));
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_SQ:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_SQ,
+ 					MLX5_GET(modify_sq_in, in, sqn));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_RQ:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_RQ,
+ 					MLX5_GET(query_rq_in, in, rqn));
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_RQ:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_RQ,
+ 					MLX5_GET(modify_rq_in, in, rqn));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_RMP:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_RMP,
+ 					MLX5_GET(query_rmp_in, in, rmpn));
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_RMP:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_RMP,
+ 					MLX5_GET(modify_rmp_in, in, rmpn));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_RQT:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_RQT,
+ 					MLX5_GET(query_rqt_in, in, rqtn));
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_RQT:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_RQT,
+ 					MLX5_GET(modify_rqt_in, in, rqtn));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_TIR:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_TIR,
+ 					MLX5_GET(query_tir_in, in, tirn));
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_TIR:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_TIR,
+ 					MLX5_GET(modify_tir_in, in, tirn));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_TIS:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_TIS,
+ 					MLX5_GET(query_tis_in, in, tisn));
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_TIS:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_TIS,
+ 					MLX5_GET(modify_tis_in, in, tisn));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_FLOW_TABLE:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_FLOW_TABLE,
+ 					MLX5_GET(query_flow_table_in, in,
+ 						 table_id));
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_FLOW_TABLE:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_FLOW_TABLE,
+ 					MLX5_GET(modify_flow_table_in, in,
+ 						 table_id));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_FLOW_GROUP:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_FLOW_GROUP,
+ 					MLX5_GET(query_flow_group_in, in,
+ 						 group_id));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_FLOW_TABLE_ENTRY:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_SET_FLOW_TABLE_ENTRY,
+ 					MLX5_GET(query_fte_in, in,
+ 						 flow_index));
+ 		break;
+ 	case MLX5_CMD_OP_SET_FLOW_TABLE_ENTRY:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_SET_FLOW_TABLE_ENTRY,
+ 					MLX5_GET(set_fte_in, in, flow_index));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_Q_COUNTER:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_ALLOC_Q_COUNTER,
+ 					MLX5_GET(query_q_counter_in, in,
+ 						 counter_set_id));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_FLOW_COUNTER:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_ALLOC_FLOW_COUNTER,
+ 					MLX5_GET(query_flow_counter_in, in,
+ 						 flow_counter_id));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_MODIFY_HEADER_CONTEXT:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_ALLOC_MODIFY_HEADER_CONTEXT,
+ 					MLX5_GET(general_obj_in_cmd_hdr, in,
+ 						 obj_id));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_SCHEDULING_ELEMENT:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_SCHEDULING_ELEMENT,
+ 					MLX5_GET(query_scheduling_element_in,
+ 						 in, scheduling_element_id));
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_SCHEDULING_ELEMENT:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_SCHEDULING_ELEMENT,
+ 					MLX5_GET(modify_scheduling_element_in,
+ 						 in, scheduling_element_id));
+ 		break;
+ 	case MLX5_CMD_OP_ADD_VXLAN_UDP_DPORT:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_ADD_VXLAN_UDP_DPORT,
+ 					MLX5_GET(add_vxlan_udp_dport_in, in,
+ 						 vxlan_udp_port));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_L2_TABLE_ENTRY:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_SET_L2_TABLE_ENTRY,
+ 					MLX5_GET(query_l2_table_entry_in, in,
+ 						 table_index));
+ 		break;
+ 	case MLX5_CMD_OP_SET_L2_TABLE_ENTRY:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_SET_L2_TABLE_ENTRY,
+ 					MLX5_GET(set_l2_table_entry_in, in,
+ 						 table_index));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_QP:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_QP,
+ 					MLX5_GET(query_qp_in, in, qpn));
+ 		break;
+ 	case MLX5_CMD_OP_RST2INIT_QP:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_QP,
+ 					MLX5_GET(rst2init_qp_in, in, qpn));
+ 		break;
+ 	case MLX5_CMD_OP_INIT2RTR_QP:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_QP,
+ 					MLX5_GET(init2rtr_qp_in, in, qpn));
+ 		break;
+ 	case MLX5_CMD_OP_RTR2RTS_QP:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_QP,
+ 					MLX5_GET(rtr2rts_qp_in, in, qpn));
+ 		break;
+ 	case MLX5_CMD_OP_RTS2RTS_QP:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_QP,
+ 					MLX5_GET(rts2rts_qp_in, in, qpn));
+ 		break;
+ 	case MLX5_CMD_OP_SQERR2RTS_QP:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_QP,
+ 					MLX5_GET(sqerr2rts_qp_in, in, qpn));
+ 		break;
+ 	case MLX5_CMD_OP_2ERR_QP:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_QP,
+ 					MLX5_GET(qp_2err_in, in, qpn));
+ 		break;
+ 	case MLX5_CMD_OP_2RST_QP:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_QP,
+ 					MLX5_GET(qp_2rst_in, in, qpn));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_DCT:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_DCT,
+ 					MLX5_GET(query_dct_in, in, dctn));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_XRQ:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_XRQ,
+ 					MLX5_GET(query_xrq_in, in, xrqn));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_XRC_SRQ:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_XRC_SRQ,
+ 					MLX5_GET(query_xrc_srq_in, in,
+ 						 xrc_srqn));
+ 		break;
+ 	case MLX5_CMD_OP_ARM_XRC_SRQ:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_XRC_SRQ,
+ 					MLX5_GET(arm_xrc_srq_in, in, xrc_srqn));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_SRQ:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_SRQ,
+ 					MLX5_GET(query_srq_in, in, srqn));
+ 		break;
+ 	case MLX5_CMD_OP_ARM_RQ:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_RQ,
+ 					MLX5_GET(arm_rq_in, in, srq_number));
+ 		break;
+ 	case MLX5_CMD_OP_DRAIN_DCT:
+ 	case MLX5_CMD_OP_ARM_DCT_FOR_KEY_VIOLATION:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_DCT,
+ 					MLX5_GET(drain_dct_in, in, dctn));
+ 		break;
+ 	case MLX5_CMD_OP_ARM_XRQ:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_XRQ,
+ 					MLX5_GET(arm_xrq_in, in, xrqn));
+ 		break;
+ 	default:
+ 		return false;
+ 	}
+ 
+ 	if (obj_id == obj->obj_id)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ static void devx_set_umem_valid(const void *in)
+ {
+ 	u16 opcode = MLX5_GET(general_obj_in_cmd_hdr, in, opcode);
+ 
+ 	switch (opcode) {
+ 	case MLX5_CMD_OP_CREATE_MKEY:
+ 		MLX5_SET(create_mkey_in, in, mkey_umem_valid, 1);
+ 		break;
+ 	case MLX5_CMD_OP_CREATE_CQ:
+ 	{
+ 		void *cqc;
+ 
+ 		MLX5_SET(create_cq_in, in, cq_umem_valid, 1);
+ 		cqc = MLX5_ADDR_OF(create_cq_in, in, cq_context);
+ 		MLX5_SET(cqc, cqc, dbr_umem_valid, 1);
+ 		break;
+ 	}
+ 	case MLX5_CMD_OP_CREATE_QP:
+ 	{
+ 		void *qpc;
+ 
+ 		qpc = MLX5_ADDR_OF(create_qp_in, in, qpc);
+ 		MLX5_SET(qpc, qpc, dbr_umem_valid, 1);
+ 		MLX5_SET(create_qp_in, in, wq_umem_valid, 1);
+ 		break;
+ 	}
+ 
+ 	case MLX5_CMD_OP_CREATE_RQ:
+ 	{
+ 		void *rqc, *wq;
+ 
+ 		rqc = MLX5_ADDR_OF(create_rq_in, in, ctx);
+ 		wq  = MLX5_ADDR_OF(rqc, rqc, wq);
+ 		MLX5_SET(wq, wq, dbr_umem_valid, 1);
+ 		MLX5_SET(wq, wq, wq_umem_valid, 1);
+ 		break;
+ 	}
+ 
+ 	case MLX5_CMD_OP_CREATE_SQ:
+ 	{
+ 		void *sqc, *wq;
+ 
+ 		sqc = MLX5_ADDR_OF(create_sq_in, in, ctx);
+ 		wq = MLX5_ADDR_OF(sqc, sqc, wq);
+ 		MLX5_SET(wq, wq, dbr_umem_valid, 1);
+ 		MLX5_SET(wq, wq, wq_umem_valid, 1);
+ 		break;
+ 	}
+ 
+ 	case MLX5_CMD_OP_MODIFY_CQ:
+ 		MLX5_SET(modify_cq_in, in, cq_umem_valid, 1);
+ 		break;
+ 
+ 	case MLX5_CMD_OP_CREATE_RMP:
+ 	{
+ 		void *rmpc, *wq;
+ 
+ 		rmpc = MLX5_ADDR_OF(create_rmp_in, in, ctx);
+ 		wq = MLX5_ADDR_OF(rmpc, rmpc, wq);
+ 		MLX5_SET(wq, wq, dbr_umem_valid, 1);
+ 		MLX5_SET(wq, wq, wq_umem_valid, 1);
+ 		break;
+ 	}
+ 
+ 	case MLX5_CMD_OP_CREATE_XRQ:
+ 	{
+ 		void *xrqc, *wq;
+ 
+ 		xrqc = MLX5_ADDR_OF(create_xrq_in, in, xrq_context);
+ 		wq = MLX5_ADDR_OF(xrqc, xrqc, wq);
+ 		MLX5_SET(wq, wq, dbr_umem_valid, 1);
+ 		MLX5_SET(wq, wq, wq_umem_valid, 1);
+ 		break;
+ 	}
+ 
+ 	case MLX5_CMD_OP_CREATE_XRC_SRQ:
+ 	{
+ 		void *xrc_srqc;
+ 
+ 		MLX5_SET(create_xrc_srq_in, in, xrc_srq_umem_valid, 1);
+ 		xrc_srqc = MLX5_ADDR_OF(create_xrc_srq_in, in,
+ 					xrc_srq_context_entry);
+ 		MLX5_SET(xrc_srqc, xrc_srqc, dbr_umem_valid, 1);
+ 		break;
+ 	}
+ 
+ 	default:
+ 		return;
+ 	}
+ }
+ 
+ static bool devx_is_obj_create_cmd(const void *in, u16 *opcode)
++>>>>>>> 2351776e87a1 (IB/mlx5: Verify DEVX object type)
+ {
+ 	*opcode = MLX5_GET(general_obj_in_cmd_hdr, in, opcode);
+ 
+ 	switch (*opcode) {
  	case MLX5_CMD_OP_CREATE_GENERAL_OBJECT:
  	case MLX5_CMD_OP_CREATE_MKEY:
  	case MLX5_CMD_OP_CREATE_CQ:
@@@ -381,16 -914,28 +721,22 @@@ static int UVERBS_HANDLER(MLX5_IB_METHO
  	int cmd_out_len =  uverbs_attr_get_len(attrs,
  					MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_OUT);
  	void *cmd_out;
 -	struct ib_uobject *uobj = uverbs_attr_get_uobject(
 -		attrs, MLX5_IB_ATTR_DEVX_OBJ_CREATE_HANDLE);
 -	struct mlx5_ib_ucontext *c = to_mucontext(uobj->context);
 -	struct mlx5_ib_dev *dev = to_mdev(c->ibucontext.device);
 -	u32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)];
 +	struct ib_uobject *uobj;
  	struct devx_obj *obj;
  	int err;
++<<<<<<< HEAD
++=======
+ 	int uid;
+ 	u32 obj_id;
+ 	u16 opcode;
++>>>>>>> 2351776e87a1 (IB/mlx5: Verify DEVX object type)
  
 -	uid = devx_get_uid(c, cmd_in);
 -	if (uid < 0)
 -		return uid;
 +	if (!c->devx_uid)
 +		return -EPERM;
  
- 	if (!devx_is_obj_create_cmd(cmd_in))
+ 	if (!devx_is_obj_create_cmd(cmd_in, &opcode))
  		return -EINVAL;
  
 -	cmd_out = uverbs_zalloc(attrs, cmd_out_len);
 -	if (IS_ERR(cmd_out))
 -		return PTR_ERR(cmd_out);
 -
  	obj = kzalloc(sizeof(struct devx_obj), GFP_KERNEL);
  	if (!obj)
  		return -ENOMEM;
@@@ -406,23 -947,23 +752,28 @@@
  			    uverbs_attr_get_len(attrs, MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_IN),
  			    cmd_out, cmd_out_len);
  	if (err)
 -		goto obj_free;
 +		goto cmd_free;
  
 +	uobj = uverbs_attr_get_uobject(attrs, MLX5_IB_ATTR_DEVX_OBJ_CREATE_HANDLE);
  	uobj->object = obj;
  	obj->mdev = dev->mdev;
- 	devx_obj_build_destroy_cmd(cmd_in, cmd_out, obj->dinbox, &obj->dinlen, &obj->obj_id);
+ 	devx_obj_build_destroy_cmd(cmd_in, cmd_out, obj->dinbox, &obj->dinlen,
+ 				   &obj_id);
  	WARN_ON(obj->dinlen > MLX5_MAX_DESTROY_INBOX_SIZE_DW * sizeof(u32));
  
  	err = uverbs_copy_to(attrs, MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_OUT, cmd_out, cmd_out_len);
  	if (err)
 -		goto obj_destroy;
 +		goto cmd_free;
  
++<<<<<<< HEAD
 +	kvfree(cmd_out);
++=======
+ 	obj->obj_id = get_enc_obj_id(opcode, obj_id);
++>>>>>>> 2351776e87a1 (IB/mlx5: Verify DEVX object type)
  	return 0;
  
 -obj_destroy:
 -	mlx5_cmd_exec(obj->mdev, obj->dinbox, obj->dinlen, out, sizeof(out));
 +cmd_free:
 +	kvfree(cmd_out);
  obj_free:
  	kfree(obj);
  	return err;
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
