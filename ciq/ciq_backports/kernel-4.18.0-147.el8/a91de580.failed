drm/i915/icl: Enable pipe output csc

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Uma Shankar <uma.shankar@intel.com>
commit a91de580541c37dcd6a82091fdd2d36cca7cda77
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/a91de580.failed

GEN11+ onwards an output csc hardware block has been added.
This is after the pipe gamma block and is in addition to the
legacy pipe CSC block. Primary use case for this block is to
convert RGB to YUV in case sink supports YUV.
This patch adds supports for the same.

v2: This is added after splitting the existing ICL pipe CSC
handling. As per Matt's suggestion, made this to co-exist
with existing pipe CSC, wherein both can be enabled if a
certain usecase arises.

v3: Fixed an issue with co-existence of output csc and normal
pipe csc, spotted by Matt. Put the csc mode flag enabling to
color_check to align with atomic.

v4: Fixed macro alignment and checkpatch complaints wrt line over
100 characters limit.

	Signed-off-by: Uma Shankar <uma.shankar@intel.com>
	Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
	Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/1549893025-21837-5-git-send-email-uma.shankar@intel.com
(cherry picked from commit a91de580541c37dcd6a82091fdd2d36cca7cda77)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_color.c
diff --cc drivers/gpu/drm/i915/intel_color.c
index 6218c9abc57c,da7a07d5ccea..000000000000
--- a/drivers/gpu/drm/i915/intel_color.c
+++ b/drivers/gpu/drm/i915/intel_color.c
@@@ -108,52 -113,84 +108,93 @@@ static u64 *ctm_mult_by_limited(u64 *re
  	return result;
  }
  
 -static void ilk_load_ycbcr_conversion_matrix(struct intel_crtc *crtc)
 +static void ilk_load_ycbcr_conversion_matrix(struct intel_crtc *intel_crtc)
  {
 -	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
 -	enum pipe pipe = crtc->pipe;
 +	int pipe = intel_crtc->pipe;
 +	struct drm_i915_private *dev_priv = to_i915(intel_crtc->base.dev);
  
- 	I915_WRITE(PIPE_CSC_PREOFF_HI(pipe), 0);
- 	I915_WRITE(PIPE_CSC_PREOFF_ME(pipe), 0);
- 	I915_WRITE(PIPE_CSC_PREOFF_LO(pipe), 0);
+ 	if (INTEL_GEN(dev_priv) < 11) {
+ 		I915_WRITE(PIPE_CSC_PREOFF_HI(pipe), 0);
+ 		I915_WRITE(PIPE_CSC_PREOFF_ME(pipe), 0);
+ 		I915_WRITE(PIPE_CSC_PREOFF_LO(pipe), 0);
  
- 	I915_WRITE(PIPE_CSC_COEFF_RU_GU(pipe), CSC_RGB_TO_YUV_RU_GU);
- 	I915_WRITE(PIPE_CSC_COEFF_BU(pipe), CSC_RGB_TO_YUV_BU);
+ 		I915_WRITE(PIPE_CSC_COEFF_RU_GU(pipe), CSC_RGB_TO_YUV_RU_GU);
+ 		I915_WRITE(PIPE_CSC_COEFF_BU(pipe), CSC_RGB_TO_YUV_BU);
  
- 	I915_WRITE(PIPE_CSC_COEFF_RY_GY(pipe), CSC_RGB_TO_YUV_RY_GY);
- 	I915_WRITE(PIPE_CSC_COEFF_BY(pipe), CSC_RGB_TO_YUV_BY);
+ 		I915_WRITE(PIPE_CSC_COEFF_RY_GY(pipe), CSC_RGB_TO_YUV_RY_GY);
+ 		I915_WRITE(PIPE_CSC_COEFF_BY(pipe), CSC_RGB_TO_YUV_BY);
  
- 	I915_WRITE(PIPE_CSC_COEFF_RV_GV(pipe), CSC_RGB_TO_YUV_RV_GV);
- 	I915_WRITE(PIPE_CSC_COEFF_BV(pipe), CSC_RGB_TO_YUV_BV);
+ 		I915_WRITE(PIPE_CSC_COEFF_RV_GV(pipe), CSC_RGB_TO_YUV_RV_GV);
+ 		I915_WRITE(PIPE_CSC_COEFF_BV(pipe), CSC_RGB_TO_YUV_BV);
  
- 	I915_WRITE(PIPE_CSC_POSTOFF_HI(pipe), POSTOFF_RGB_TO_YUV_HI);
- 	I915_WRITE(PIPE_CSC_POSTOFF_ME(pipe), POSTOFF_RGB_TO_YUV_ME);
- 	I915_WRITE(PIPE_CSC_POSTOFF_LO(pipe), POSTOFF_RGB_TO_YUV_LO);
- 	I915_WRITE(PIPE_CSC_MODE(pipe), 0);
+ 		I915_WRITE(PIPE_CSC_POSTOFF_HI(pipe), POSTOFF_RGB_TO_YUV_HI);
+ 		I915_WRITE(PIPE_CSC_POSTOFF_ME(pipe), POSTOFF_RGB_TO_YUV_ME);
+ 		I915_WRITE(PIPE_CSC_POSTOFF_LO(pipe), POSTOFF_RGB_TO_YUV_LO);
+ 	} else {
+ 		I915_WRITE(PIPE_CSC_OUTPUT_PREOFF_HI(pipe), 0);
+ 		I915_WRITE(PIPE_CSC_OUTPUT_PREOFF_ME(pipe), 0);
+ 		I915_WRITE(PIPE_CSC_OUTPUT_PREOFF_LO(pipe), 0);
+ 
+ 		I915_WRITE(PIPE_CSC_OUTPUT_COEFF_RU_GU(pipe),
+ 			   CSC_RGB_TO_YUV_RU_GU);
+ 		I915_WRITE(PIPE_CSC_OUTPUT_COEFF_BU(pipe), CSC_RGB_TO_YUV_BU);
+ 
+ 		I915_WRITE(PIPE_CSC_OUTPUT_COEFF_RY_GY(pipe),
+ 			   CSC_RGB_TO_YUV_RY_GY);
+ 		I915_WRITE(PIPE_CSC_OUTPUT_COEFF_BY(pipe), CSC_RGB_TO_YUV_BY);
+ 
+ 		I915_WRITE(PIPE_CSC_OUTPUT_COEFF_RV_GV(pipe),
+ 			   CSC_RGB_TO_YUV_RV_GV);
+ 		I915_WRITE(PIPE_CSC_OUTPUT_COEFF_BV(pipe), CSC_RGB_TO_YUV_BV);
+ 
+ 		I915_WRITE(PIPE_CSC_OUTPUT_POSTOFF_HI(pipe),
+ 			   POSTOFF_RGB_TO_YUV_HI);
+ 		I915_WRITE(PIPE_CSC_OUTPUT_POSTOFF_ME(pipe),
+ 			   POSTOFF_RGB_TO_YUV_ME);
+ 		I915_WRITE(PIPE_CSC_OUTPUT_POSTOFF_LO(pipe),
+ 			   POSTOFF_RGB_TO_YUV_LO);
+ 	}
  }
  
 -static void ilk_load_csc_matrix(const struct intel_crtc_state *crtc_state)
 +static void ilk_load_csc_matrix(struct drm_crtc_state *crtc_state)
  {
 -	struct intel_crtc *crtc = to_intel_crtc(crtc_state->base.crtc);
 -	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
 +	struct drm_crtc *crtc = crtc_state->crtc;
 +	struct drm_i915_private *dev_priv = to_i915(crtc->dev);
 +	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
 +	int i, pipe = intel_crtc->pipe;
 +	uint16_t coeffs[9] = { 0, };
 +	struct intel_crtc_state *intel_crtc_state = to_intel_crtc_state(crtc_state);
  	bool limited_color_range = false;
 -	enum pipe pipe = crtc->pipe;
 -	u16 coeffs[9] = {};
 -	int i;
  
  	/*
  	 * FIXME if there's a gamma LUT after the CSC, we should
  	 * do the range compression using the gamma LUT instead.
  	 */
  	if (INTEL_GEN(dev_priv) >= 8 || IS_HASWELL(dev_priv))
 -		limited_color_range = crtc_state->limited_color_range;
 +		limited_color_range = intel_crtc_state->limited_color_range;
  
++<<<<<<< HEAD
 +	if (intel_crtc_state->ycbcr420) {
 +		ilk_load_ycbcr_conversion_matrix(intel_crtc);
 +		return;
 +	} else if (crtc_state->ctm) {
 +		struct drm_color_ctm *ctm = crtc_state->ctm->data;
++=======
+ 	if (crtc_state->output_format == INTEL_OUTPUT_FORMAT_YCBCR420 ||
+ 	    crtc_state->output_format == INTEL_OUTPUT_FORMAT_YCBCR444) {
+ 		ilk_load_ycbcr_conversion_matrix(crtc);
+ 		I915_WRITE(PIPE_CSC_MODE(pipe), crtc_state->csc_mode);
+ 		/*
+ 		 * On pre GEN11 output CSC is not there, so with 1 pipe CSC
+ 		 * RGB to YUV conversion can be done. No need to go further
+ 		 */
+ 		if (INTEL_GEN(dev_priv) < 11)
+ 			return;
+ 	}
+ 
+ 	if (crtc_state->base.ctm) {
+ 		struct drm_color_ctm *ctm = crtc_state->base.ctm->data;
++>>>>>>> a91de580541c (drm/i915/icl: Enable pipe output csc)
  		const u64 *input;
  		u64 temp[9];
  
@@@ -238,12 -275,9 +279,9 @@@
  		I915_WRITE(PIPE_CSC_POSTOFF_ME(pipe), postoff);
  		I915_WRITE(PIPE_CSC_POSTOFF_LO(pipe), postoff);
  
- 		if (INTEL_GEN(dev_priv) >= 11)
- 			I915_WRITE(PIPE_CSC_MODE(pipe), ICL_CSC_ENABLE);
- 		else
- 			I915_WRITE(PIPE_CSC_MODE(pipe), 0);
+ 		I915_WRITE(PIPE_CSC_MODE(pipe), crtc_state->csc_mode);
  	} else {
 -		u32 mode = CSC_MODE_YUV_TO_RGB;
 +		uint32_t mode = CSC_MODE_YUV_TO_RGB;
  
  		if (limited_color_range)
  			mode |= CSC_BLACK_SCREEN_OFFSET;
@@@ -616,56 -679,183 +654,85 @@@ void intel_color_load_luts(struct drm_c
  	dev_priv->display.load_luts(crtc_state);
  }
  
 -void intel_color_commit(const struct intel_crtc_state *crtc_state)
 +int intel_color_check(struct drm_crtc *crtc,
 +		      struct drm_crtc_state *crtc_state)
  {
 -	struct drm_i915_private *dev_priv = to_i915(crtc_state->base.crtc->dev);
 -
 -	dev_priv->display.color_commit(crtc_state);
 -}
 +	struct drm_i915_private *dev_priv = to_i915(crtc->dev);
 +	size_t gamma_length, degamma_length;
  
 -static bool need_plane_update(struct intel_plane *plane,
 -			      const struct intel_crtc_state *crtc_state)
 -{
 -	struct drm_i915_private *dev_priv = to_i915(plane->base.dev);
 +	degamma_length = INTEL_INFO(dev_priv)->color.degamma_lut_size;
 +	gamma_length = INTEL_INFO(dev_priv)->color.gamma_lut_size;
  
  	/*
 -	 * On pre-SKL the pipe gamma enable and pipe csc enable for
 -	 * the pipe bottom color are configured via the primary plane.
 -	 * We have to reconfigure that even if the plane is inactive.
 +	 * We allow both degamma & gamma luts at the right size or
 +	 * NULL.
  	 */
 -	return crtc_state->active_planes & BIT(plane->id) ||
 -		(INTEL_GEN(dev_priv) < 9 &&
 -		 plane->id == PLANE_PRIMARY);
 -}
 -
 -static int
 -intel_color_add_affected_planes(struct intel_crtc_state *new_crtc_state)
 -{
 -	struct intel_crtc *crtc = to_intel_crtc(new_crtc_state->base.crtc);
 -	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
 -	struct intel_atomic_state *state =
 -		to_intel_atomic_state(new_crtc_state->base.state);
 -	const struct intel_crtc_state *old_crtc_state =
 -		intel_atomic_get_old_crtc_state(state, crtc);
 -	struct intel_plane *plane;
 -
 -	if (!new_crtc_state->base.active ||
 -	    drm_atomic_crtc_needs_modeset(&new_crtc_state->base))
 -		return 0;
 -
 -	if (new_crtc_state->gamma_enable == old_crtc_state->gamma_enable &&
 -	    new_crtc_state->csc_enable == old_crtc_state->csc_enable)
 +	if ((!crtc_state->degamma_lut ||
 +	     drm_color_lut_size(crtc_state->degamma_lut) == degamma_length) &&
 +	    (!crtc_state->gamma_lut ||
 +	     drm_color_lut_size(crtc_state->gamma_lut) == gamma_length))
  		return 0;
  
 -	for_each_intel_plane_on_crtc(&dev_priv->drm, crtc, plane) {
 -		struct intel_plane_state *plane_state;
 -
 -		if (!need_plane_update(plane, new_crtc_state))
 -			continue;
 -
 -		plane_state = intel_atomic_get_plane_state(state, plane);
 -		if (IS_ERR(plane_state))
 -			return PTR_ERR(plane_state);
 -
 -		new_crtc_state->update_planes |= BIT(plane->id);
 -	}
 -
 -	return 0;
 -}
 -
 -static int check_lut_size(const struct drm_property_blob *lut, int expected)
 -{
 -	int len;
 -
 -	if (!lut)
 -		return 0;
 -
 -	len = drm_color_lut_size(lut);
 -	if (len != expected) {
 -		DRM_DEBUG_KMS("Invalid LUT size; got %d, expected %d\n",
 -			      len, expected);
 -		return -EINVAL;
 -	}
 -
 -	return 0;
 -}
 -
 -int intel_color_check(struct intel_crtc_state *crtc_state)
 -{
 -	struct drm_i915_private *dev_priv = to_i915(crtc_state->base.crtc->dev);
 -	const struct drm_property_blob *gamma_lut = crtc_state->base.gamma_lut;
 -	const struct drm_property_blob *degamma_lut = crtc_state->base.degamma_lut;
 -	bool limited_color_range = false;
 -	int gamma_length, degamma_length;
 -	u32 gamma_tests, degamma_tests;
 -	int ret;
 -
 -	degamma_length = INTEL_INFO(dev_priv)->color.degamma_lut_size;
 -	gamma_length = INTEL_INFO(dev_priv)->color.gamma_lut_size;
 -	degamma_tests = INTEL_INFO(dev_priv)->color.degamma_lut_tests;
 -	gamma_tests = INTEL_INFO(dev_priv)->color.gamma_lut_tests;
 -
 -	/* C8 needs the legacy LUT all to itself */
 -	if (crtc_state->c8_planes &&
 -	    !crtc_state_is_legacy_gamma(crtc_state))
 -		return -EINVAL;
 -
 -	crtc_state->gamma_enable = (gamma_lut || degamma_lut) &&
 -		!crtc_state->c8_planes;
 -
 -	if (INTEL_GEN(dev_priv) >= 9 ||
 -	    IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv))
 -		limited_color_range = crtc_state->limited_color_range;
 -
 -	crtc_state->csc_enable =
 -		crtc_state->output_format != INTEL_OUTPUT_FORMAT_RGB ||
 -		crtc_state->base.ctm || limited_color_range;
 -
 -	ret = intel_color_add_affected_planes(crtc_state);
 -	if (ret)
 -		return ret;
 -
 -	/* Always allow legacy gamma LUT with no further checking. */
 -	if (!crtc_state->gamma_enable ||
 -	    crtc_state_is_legacy_gamma(crtc_state)) {
 -		crtc_state->gamma_mode = GAMMA_MODE_MODE_8BIT;
 +	/*
 +	 * We also allow no degamma lut/ctm and a gamma lut at the legacy
 +	 * size (256 entries).
 +	 */
 +	if (crtc_state_is_legacy_gamma(crtc_state))
  		return 0;
 -	}
 -
 -	if (check_lut_size(degamma_lut, degamma_length) ||
 -	    check_lut_size(gamma_lut, gamma_length))
 -		return -EINVAL;
  
++<<<<<<< HEAD
 +	return -EINVAL;
++=======
+ 	if (drm_color_lut_check(degamma_lut, degamma_tests) ||
+ 	    drm_color_lut_check(gamma_lut, gamma_tests))
+ 		return -EINVAL;
+ 
+ 	if (INTEL_GEN(dev_priv) >= 11)
+ 		crtc_state->gamma_mode = GAMMA_MODE_MODE_10BIT |
+ 					 PRE_CSC_GAMMA_ENABLE |
+ 					 POST_CSC_GAMMA_ENABLE;
+ 	else if (INTEL_GEN(dev_priv) >= 10 || IS_GEMINILAKE(dev_priv))
+ 		crtc_state->gamma_mode = GAMMA_MODE_MODE_10BIT;
+ 	else if (INTEL_GEN(dev_priv) >= 9 || IS_BROADWELL(dev_priv))
+ 		crtc_state->gamma_mode = GAMMA_MODE_MODE_SPLIT;
+ 	else
+ 		crtc_state->gamma_mode = GAMMA_MODE_MODE_8BIT;
+ 
+ 	crtc_state->csc_mode = 0;
+ 
+ 	if (INTEL_GEN(dev_priv) >= 11) {
+ 		if (crtc_state->output_format == INTEL_OUTPUT_FORMAT_YCBCR420 ||
+ 		    crtc_state->output_format == INTEL_OUTPUT_FORMAT_YCBCR444)
+ 			crtc_state->csc_mode |= ICL_OUTPUT_CSC_ENABLE;
+ 
+ 		crtc_state->csc_mode |= ICL_CSC_ENABLE;
+ 	}
+ 
+ 	return 0;
++>>>>>>> a91de580541c (drm/i915/icl: Enable pipe output csc)
  }
  
 -void intel_color_init(struct intel_crtc *crtc)
 +void intel_color_init(struct drm_crtc *crtc)
  {
 -	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
 -
 -	drm_mode_crtc_set_gamma_size(&crtc->base, 256);
 -
 -	if (HAS_GMCH(dev_priv)) {
 -		if (IS_CHERRYVIEW(dev_priv))
 -			dev_priv->display.load_luts = cherryview_load_luts;
 -		else
 -			dev_priv->display.load_luts = i9xx_load_luts;
 -
 -		dev_priv->display.color_commit = i9xx_color_commit;
 +	struct drm_i915_private *dev_priv = to_i915(crtc->dev);
 +
 +	drm_mode_crtc_set_gamma_size(crtc, 256);
 +
 +	if (IS_CHERRYVIEW(dev_priv)) {
 +		dev_priv->display.load_csc_matrix = cherryview_load_csc_matrix;
 +		dev_priv->display.load_luts = cherryview_load_luts;
 +	} else if (IS_HASWELL(dev_priv)) {
 +		dev_priv->display.load_csc_matrix = ilk_load_csc_matrix;
 +		dev_priv->display.load_luts = haswell_load_luts;
 +	} else if (IS_BROADWELL(dev_priv) || IS_GEN9_BC(dev_priv) ||
 +		   IS_BROXTON(dev_priv)) {
 +		dev_priv->display.load_csc_matrix = ilk_load_csc_matrix;
 +		dev_priv->display.load_luts = broadwell_load_luts;
 +	} else if (IS_GEMINILAKE(dev_priv) || IS_CANNONLAKE(dev_priv)) {
 +		dev_priv->display.load_csc_matrix = ilk_load_csc_matrix;
 +		dev_priv->display.load_luts = glk_load_luts;
  	} else {
 -		if (IS_ICELAKE(dev_priv))
 -			dev_priv->display.load_luts = icl_load_luts;
 -		else if (IS_CANNONLAKE(dev_priv) || IS_GEMINILAKE(dev_priv))
 -			dev_priv->display.load_luts = glk_load_luts;
 -		else if (INTEL_GEN(dev_priv) >= 9 || IS_BROADWELL(dev_priv))
 -			dev_priv->display.load_luts = broadwell_load_luts;
 -		else
 -			dev_priv->display.load_luts = i9xx_load_luts;
 -
 -		if (INTEL_GEN(dev_priv) >= 9)
 -			dev_priv->display.color_commit = skl_color_commit;
 -		else if (IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv))
 -			dev_priv->display.color_commit = hsw_color_commit;
 -		else
 -			dev_priv->display.color_commit = ilk_color_commit;
 +		dev_priv->display.load_luts = i9xx_load_luts;
  	}
  
  	/* Enable color management support when we have degamma & gamma LUTs. */
diff --git a/drivers/gpu/drm/i915/i915_reg.h b/drivers/gpu/drm/i915/i915_reg.h
index a78c6ef1f608..540dfca58918 100644
--- a/drivers/gpu/drm/i915/i915_reg.h
+++ b/drivers/gpu/drm/i915/i915_reg.h
@@ -9200,6 +9200,7 @@ enum skl_power_gate {
 
 #define _PIPE_A_CSC_MODE	0x49028
 #define  ICL_CSC_ENABLE			(1 << 31)
+#define  ICL_OUTPUT_CSC_ENABLE		(1 << 30)
 #define  CSC_BLACK_SCREEN_OFFSET	(1 << 2)
 #define  CSC_POSITION_BEFORE_GAMMA	(1 << 1)
 #define  CSC_MODE_YUV_TO_RGB		(1 << 0)
@@ -9239,6 +9240,70 @@ enum skl_power_gate {
 #define PIPE_CSC_POSTOFF_ME(pipe)	_MMIO_PIPE(pipe, _PIPE_A_CSC_POSTOFF_ME, _PIPE_B_CSC_POSTOFF_ME)
 #define PIPE_CSC_POSTOFF_LO(pipe)	_MMIO_PIPE(pipe, _PIPE_A_CSC_POSTOFF_LO, _PIPE_B_CSC_POSTOFF_LO)
 
+/* Pipe Output CSC */
+#define _PIPE_A_OUTPUT_CSC_COEFF_RY_GY	0x49050
+#define _PIPE_A_OUTPUT_CSC_COEFF_BY	0x49054
+#define _PIPE_A_OUTPUT_CSC_COEFF_RU_GU	0x49058
+#define _PIPE_A_OUTPUT_CSC_COEFF_BU	0x4905c
+#define _PIPE_A_OUTPUT_CSC_COEFF_RV_GV	0x49060
+#define _PIPE_A_OUTPUT_CSC_COEFF_BV	0x49064
+#define _PIPE_A_OUTPUT_CSC_PREOFF_HI	0x49068
+#define _PIPE_A_OUTPUT_CSC_PREOFF_ME	0x4906c
+#define _PIPE_A_OUTPUT_CSC_PREOFF_LO	0x49070
+#define _PIPE_A_OUTPUT_CSC_POSTOFF_HI	0x49074
+#define _PIPE_A_OUTPUT_CSC_POSTOFF_ME	0x49078
+#define _PIPE_A_OUTPUT_CSC_POSTOFF_LO	0x4907c
+
+#define _PIPE_B_OUTPUT_CSC_COEFF_RY_GY	0x49150
+#define _PIPE_B_OUTPUT_CSC_COEFF_BY	0x49154
+#define _PIPE_B_OUTPUT_CSC_COEFF_RU_GU	0x49158
+#define _PIPE_B_OUTPUT_CSC_COEFF_BU	0x4915c
+#define _PIPE_B_OUTPUT_CSC_COEFF_RV_GV	0x49160
+#define _PIPE_B_OUTPUT_CSC_COEFF_BV	0x49164
+#define _PIPE_B_OUTPUT_CSC_PREOFF_HI	0x49168
+#define _PIPE_B_OUTPUT_CSC_PREOFF_ME	0x4916c
+#define _PIPE_B_OUTPUT_CSC_PREOFF_LO	0x49170
+#define _PIPE_B_OUTPUT_CSC_POSTOFF_HI	0x49174
+#define _PIPE_B_OUTPUT_CSC_POSTOFF_ME	0x49178
+#define _PIPE_B_OUTPUT_CSC_POSTOFF_LO	0x4917c
+
+#define PIPE_CSC_OUTPUT_COEFF_RY_GY(pipe)	_MMIO_PIPE(pipe,\
+							   _PIPE_A_OUTPUT_CSC_COEFF_RY_GY,\
+							   _PIPE_B_OUTPUT_CSC_COEFF_RY_GY)
+#define PIPE_CSC_OUTPUT_COEFF_BY(pipe)		_MMIO_PIPE(pipe, \
+							   _PIPE_A_OUTPUT_CSC_COEFF_BY, \
+							   _PIPE_B_OUTPUT_CSC_COEFF_BY)
+#define PIPE_CSC_OUTPUT_COEFF_RU_GU(pipe)	_MMIO_PIPE(pipe, \
+							   _PIPE_A_OUTPUT_CSC_COEFF_RU_GU, \
+							   _PIPE_B_OUTPUT_CSC_COEFF_RU_GU)
+#define PIPE_CSC_OUTPUT_COEFF_BU(pipe)		_MMIO_PIPE(pipe, \
+							   _PIPE_A_OUTPUT_CSC_COEFF_BU, \
+							   _PIPE_B_OUTPUT_CSC_COEFF_BU)
+#define PIPE_CSC_OUTPUT_COEFF_RV_GV(pipe)	_MMIO_PIPE(pipe, \
+							   _PIPE_A_OUTPUT_CSC_COEFF_RV_GV, \
+							   _PIPE_B_OUTPUT_CSC_COEFF_RV_GV)
+#define PIPE_CSC_OUTPUT_COEFF_BV(pipe)		_MMIO_PIPE(pipe, \
+							   _PIPE_A_OUTPUT_CSC_COEFF_BV, \
+							   _PIPE_B_OUTPUT_CSC_COEFF_BV)
+#define PIPE_CSC_OUTPUT_PREOFF_HI(pipe)		_MMIO_PIPE(pipe, \
+							   _PIPE_A_OUTPUT_CSC_PREOFF_HI, \
+							   _PIPE_B_OUTPUT_CSC_PREOFF_HI)
+#define PIPE_CSC_OUTPUT_PREOFF_ME(pipe)		_MMIO_PIPE(pipe, \
+							   _PIPE_A_OUTPUT_CSC_PREOFF_ME, \
+							   _PIPE_B_OUTPUT_CSC_PREOFF_ME)
+#define PIPE_CSC_OUTPUT_PREOFF_LO(pipe)		_MMIO_PIPE(pipe, \
+							   _PIPE_A_OUTPUT_CSC_PREOFF_LO, \
+							   _PIPE_B_OUTPUT_CSC_PREOFF_LO)
+#define PIPE_CSC_OUTPUT_POSTOFF_HI(pipe)	_MMIO_PIPE(pipe, \
+							   _PIPE_A_OUTPUT_CSC_POSTOFF_HI, \
+							   _PIPE_B_OUTPUT_CSC_POSTOFF_HI)
+#define PIPE_CSC_OUTPUT_POSTOFF_ME(pipe)	_MMIO_PIPE(pipe, \
+							   _PIPE_A_OUTPUT_CSC_POSTOFF_ME, \
+							   _PIPE_B_OUTPUT_CSC_POSTOFF_ME)
+#define PIPE_CSC_OUTPUT_POSTOFF_LO(pipe)	_MMIO_PIPE(pipe, \
+							   _PIPE_A_OUTPUT_CSC_POSTOFF_LO, \
+							   _PIPE_B_OUTPUT_CSC_POSTOFF_LO)
+
 /* pipe degamma/gamma LUTs on IVB+ */
 #define _PAL_PREC_INDEX_A	0x4A400
 #define _PAL_PREC_INDEX_B	0x4AC00
* Unmerged path drivers/gpu/drm/i915/intel_color.c
diff --git a/drivers/gpu/drm/i915/intel_drv.h b/drivers/gpu/drm/i915/intel_drv.h
index b8eefbffc77d..663b6c3f2bfb 100644
--- a/drivers/gpu/drm/i915/intel_drv.h
+++ b/drivers/gpu/drm/i915/intel_drv.h
@@ -887,6 +887,9 @@ struct intel_crtc_state {
 	/* Gamma mode programmed on the pipe */
 	uint32_t gamma_mode;
 
+	/* CSC mode programmed on the pipe */
+	u32 csc_mode;
+
 	/* bitmask of visible planes (enum plane_id) */
 	u8 active_planes;
 	u8 nv12_planes;
