RDMA/uverbs: Optimize clearing of extra bytes in response

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Leon Romanovsky <leon@kernel.org>
commit 9435ef4caeea0a1141e461f9ee6f91b173867c05
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/9435ef4c.failed

Clear extra bytes in response in batch manner instead
of doing it per-byte.

	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Reviewed-by: Yuval Shaia <yuval.shaia@oracle.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 9435ef4caeea0a1141e461f9ee6f91b173867c05)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_cmd.c
diff --cc drivers/infiniband/core/uverbs_cmd.c
index 300532a4cde8,7f10eade7653..000000000000
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@@ -47,12 -47,134 +47,138 @@@
  #include "uverbs.h"
  #include "core_priv.h"
  
++<<<<<<< HEAD
++=======
+ /*
+  * Copy a response to userspace. If the provided 'resp' is larger than the
+  * user buffer it is silently truncated. If the user provided a larger buffer
+  * then the trailing portion is zero filled.
+  *
+  * These semantics are intended to support future extension of the output
+  * structures.
+  */
+ static int uverbs_response(struct uverbs_attr_bundle *attrs, const void *resp,
+ 			   size_t resp_len)
+ {
+ 	int ret;
+ 
+ 	if (copy_to_user(attrs->ucore.outbuf, resp,
+ 			 min(attrs->ucore.outlen, resp_len)))
+ 		return -EFAULT;
+ 
+ 	if (resp_len < attrs->ucore.outlen) {
+ 		/*
+ 		 * Zero fill any extra memory that user
+ 		 * space might have provided.
+ 		 */
+ 		ret = clear_user(attrs->ucore.outbuf + resp_len,
+ 				 attrs->ucore.outlen - resp_len);
+ 		if (ret)
+ 			return -EFAULT;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Copy a request from userspace. If the provided 'req' is larger than the
+  * user buffer then the user buffer is zero extended into the 'req'. If 'req'
+  * is smaller than the user buffer then the uncopied bytes in the user buffer
+  * must be zero.
+  */
+ static int uverbs_request(struct uverbs_attr_bundle *attrs, void *req,
+ 			  size_t req_len)
+ {
+ 	if (copy_from_user(req, attrs->ucore.inbuf,
+ 			   min(attrs->ucore.inlen, req_len)))
+ 		return -EFAULT;
+ 
+ 	if (attrs->ucore.inlen < req_len) {
+ 		memset(req + attrs->ucore.inlen, 0,
+ 		       req_len - attrs->ucore.inlen);
+ 	} else if (attrs->ucore.inlen > req_len) {
+ 		if (!ib_is_buffer_cleared(attrs->ucore.inbuf + req_len,
+ 					  attrs->ucore.inlen - req_len))
+ 			return -EOPNOTSUPP;
+ 	}
+ 	return 0;
+ }
+ 
+ /*
+  * Generate the value for the 'response_length' protocol used by write_ex.
+  * This is the number of bytes the kernel actually wrote. Userspace can use
+  * this to detect what structure members in the response the kernel
+  * understood.
+  */
+ static u32 uverbs_response_length(struct uverbs_attr_bundle *attrs,
+ 				  size_t resp_len)
+ {
+ 	return min_t(size_t, attrs->ucore.outlen, resp_len);
+ }
+ 
+ /*
+  * The iterator version of the request interface is for handlers that need to
+  * step over a flex array at the end of a command header.
+  */
+ struct uverbs_req_iter {
+ 	const void __user *cur;
+ 	const void __user *end;
+ };
+ 
+ static int uverbs_request_start(struct uverbs_attr_bundle *attrs,
+ 				struct uverbs_req_iter *iter,
+ 				void *req,
+ 				size_t req_len)
+ {
+ 	if (attrs->ucore.inlen < req_len)
+ 		return -ENOSPC;
+ 
+ 	if (copy_from_user(req, attrs->ucore.inbuf, req_len))
+ 		return -EFAULT;
+ 
+ 	iter->cur = attrs->ucore.inbuf + req_len;
+ 	iter->end = attrs->ucore.inbuf + attrs->ucore.inlen;
+ 	return 0;
+ }
+ 
+ static int uverbs_request_next(struct uverbs_req_iter *iter, void *val,
+ 			       size_t len)
+ {
+ 	if (iter->cur + len > iter->end)
+ 		return -ENOSPC;
+ 
+ 	if (copy_from_user(val, iter->cur, len))
+ 		return -EFAULT;
+ 
+ 	iter->cur += len;
+ 	return 0;
+ }
+ 
+ static const void __user *uverbs_request_next_ptr(struct uverbs_req_iter *iter,
+ 						  size_t len)
+ {
+ 	const void __user *res = iter->cur;
+ 
+ 	if (iter->cur + len > iter->end)
+ 		return ERR_PTR(-ENOSPC);
+ 	iter->cur += len;
+ 	return res;
+ }
+ 
+ static int uverbs_request_finish(struct uverbs_req_iter *iter)
+ {
+ 	if (!ib_is_buffer_cleared(iter->cur, iter->end - iter->cur))
+ 		return -EOPNOTSUPP;
+ 	return 0;
+ }
+ 
++>>>>>>> 9435ef4caeea (RDMA/uverbs: Optimize clearing of extra bytes in response)
  static struct ib_uverbs_completion_event_file *
 -_ib_uverbs_lookup_comp_file(s32 fd, const struct uverbs_attr_bundle *attrs)
 +ib_uverbs_lookup_comp_file(int fd, struct ib_ucontext *context)
  {
 -	struct ib_uobject *uobj = ufd_get_read(UVERBS_OBJECT_COMP_CHANNEL,
 -					       fd, attrs);
 +	struct ib_uobject *uobj = uobj_get_read(UVERBS_OBJECT_COMP_CHANNEL,
 +						fd, context);
 +	struct ib_uobject_file *uobj_file;
  
  	if (IS_ERR(uobj))
  		return (void *)uobj;
* Unmerged path drivers/infiniband/core/uverbs_cmd.c
