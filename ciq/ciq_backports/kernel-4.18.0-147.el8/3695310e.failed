scsi: qla2xxx: Update flash read/write routine

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Joe Carnuccio <joe.carnuccio@cavium.com>
commit 3695310e37b4e571d40593cbe59188b0006a2274
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/3695310e.failed

This patch makes following changes to flash access routines:

- update return type for read_optrom
- use void instead of uint32_t * for buffer parameter in read
  and write optrom routines
- fix flash/nvram addressing

	Signed-off-by: Joe Carnuccio <joe.carnuccio@cavium.com>
	Signed-off-by: Himanshu Madhani <hmadhani@marvell.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 3695310e37b4e571d40593cbe59188b0006a2274)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_attr.c
#	drivers/scsi/qla2xxx/qla_init.c
#	drivers/scsi/qla2xxx/qla_sup.c
diff --cc drivers/scsi/qla2xxx/qla_attr.c
index 55925877df53,35f7804682ec..000000000000
--- a/drivers/scsi/qla2xxx/qla_attr.c
+++ b/drivers/scsi/qla2xxx/qla_attr.c
@@@ -208,10 -216,17 +208,17 @@@ qla2x00_sysfs_write_nvram(struct file *
  		return -EAGAIN;
  	}
  
 -	mutex_lock(&ha->optrom_mutex);
 -	if (qla2x00_chip_is_down(vha)) {
 -		mutex_unlock(&ha->optrom_mutex);
 -		return -EAGAIN;
 -	}
 -
  	/* Write NVRAM. */
++<<<<<<< HEAD
 +	ha->isp_ops->write_nvram(vha, (uint8_t *)buf, ha->nvram_base, count);
 +	ha->isp_ops->read_nvram(vha, (uint8_t *)ha->nvram, ha->nvram_base,
 +	    count);
++=======
+ 	ha->isp_ops->write_nvram(vha, buf, ha->nvram_base, count);
+ 	ha->isp_ops->read_nvram(vha, ha->nvram, ha->nvram_base,
+ 	    count);
+ 	mutex_unlock(&ha->optrom_mutex);
++>>>>>>> 3695310e37b4 (scsi: qla2xxx: Update flash read/write routine)
  
  	ql_dbg(ql_dbg_user, vha, 0x7060,
  	    "Setting ISP_ABORT_NEEDED\n");
@@@ -492,16 -511,24 +499,33 @@@ qla2x00_sysfs_read_vpd(struct file *fil
  	if (!capable(CAP_SYS_ADMIN))
  		return -EINVAL;
  
- 	if (IS_NOCACHE_VPD_TYPE(ha)) {
- 		faddr = ha->flt_region_vpd << 2;
+ 	if (IS_NOCACHE_VPD_TYPE(ha))
+ 		goto skip;
  
++<<<<<<< HEAD
 +		if (IS_QLA27XX(ha) &&
 +		    qla27xx_find_valid_image(vha) == QLA27XX_SECONDARY_IMAGE)
 +			faddr = ha->flt_region_vpd_sec << 2;
 +
 +		ha->isp_ops->read_optrom(vha, ha->vpd, faddr,
 +		    ha->vpd_size);
++=======
+ 	faddr = ha->flt_region_vpd << 2;
+ 
+ 	if ((IS_QLA27XX(ha) || IS_QLA28XX(ha)) &&
+ 	    qla27xx_find_valid_image(vha) == QLA27XX_SECONDARY_IMAGE)
+ 		faddr = ha->flt_region_vpd_sec << 2;
+ 
+ 	mutex_lock(&ha->optrom_mutex);
+ 	if (qla2x00_chip_is_down(vha)) {
+ 		mutex_unlock(&ha->optrom_mutex);
+ 		return -EAGAIN;
++>>>>>>> 3695310e37b4 (scsi: qla2xxx: Update flash read/write routine)
  	}
+ 
+ 	ha->isp_ops->read_optrom(vha, ha->vpd, faddr, ha->vpd_size);
+ 	mutex_unlock(&ha->optrom_mutex);
+ skip:
  	return memory_read_from_buffer(buf, count, &off, ha->vpd, ha->vpd_size);
  }
  
@@@ -531,13 -558,21 +555,13 @@@ qla2x00_sysfs_write_vpd(struct file *fi
  		return -EAGAIN;
  	}
  
 -	mutex_lock(&ha->optrom_mutex);
 -	if (qla2x00_chip_is_down(vha)) {
 -		mutex_unlock(&ha->optrom_mutex);
 -		return -EAGAIN;
 -	}
 -
  	/* Write NVRAM. */
- 	ha->isp_ops->write_nvram(vha, (uint8_t *)buf, ha->vpd_base, count);
- 	ha->isp_ops->read_nvram(vha, (uint8_t *)ha->vpd, ha->vpd_base, count);
+ 	ha->isp_ops->write_nvram(vha, buf, ha->vpd_base, count);
+ 	ha->isp_ops->read_nvram(vha, ha->vpd, ha->vpd_base, count);
  
  	/* Update flash version information for 4Gb & above. */
 -	if (!IS_FWI2_CAPABLE(ha)) {
 -		mutex_unlock(&ha->optrom_mutex);
 +	if (!IS_FWI2_CAPABLE(ha))
  		return -EINVAL;
 -	}
  
  	tmp_data = vmalloc(256);
  	if (!tmp_data) {
@@@ -915,13 -987,14 +939,18 @@@ qla2x00_free_sysfs_attr(scsi_qla_host_
  	struct qla_hw_data *ha = vha->hw;
  
  	for (iter = bin_file_entries; iter->name; iter++) {
- 		if (iter->is4GBp_only && !IS_FWI2_CAPABLE(ha))
+ 		if (iter->type && !IS_FWI2_CAPABLE(ha))
  			continue;
- 		if (iter->is4GBp_only == 2 && !IS_QLA25XX(ha))
+ 		if (iter->type == 2 && !IS_QLA25XX(ha))
  			continue;
- 		if (iter->is4GBp_only == 3 && !(IS_CNA_CAPABLE(vha->hw)))
+ 		if (iter->type == 3 && !(IS_CNA_CAPABLE(ha)))
  			continue;
++<<<<<<< HEAD
 +		if (iter->is4GBp_only == 0x27 && !IS_QLA27XX(vha->hw))
++=======
+ 		if (iter->type == 0x27 &&
+ 		    (!IS_QLA27XX(ha) || !IS_QLA28XX(ha)))
++>>>>>>> 3695310e37b4 (scsi: qla2xxx: Update flash read/write routine)
  			continue;
  
  		sysfs_remove_bin_file(&host->shost_gendev.kobj,
diff --cc drivers/scsi/qla2xxx/qla_init.c
index 046c47b82245,158ec5aa2837..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -4172,16 -4412,15 +4172,15 @@@ qla2x00_nvram_config(scsi_qla_host_t *v
  	ql_dbg(ql_dbg_init + ql_dbg_buffer, vha, 0x010f,
  	    "Contents of NVRAM.\n");
  	ql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x0110,
 -	    nv, ha->nvram_size);
 +	    (uint8_t *)nv, ha->nvram_size);
  
  	/* Bad NVRAM data, set defaults parameters. */
 -	if (chksum || memcmp("ISP ", nv->id, sizeof(nv->id)) ||
 -	    nv->nvram_version < 1) {
 +	if (chksum || nv->id[0] != 'I' || nv->id[1] != 'S' ||
 +	    nv->id[2] != 'P' || nv->id[3] != ' ' || nv->nvram_version < 1) {
  		/* Reset NVRAM data. */
  		ql_log(ql_log_warn, vha, 0x0064,
- 		    "Inconsistent NVRAM "
- 		    "detected: checksum=0x%x id=%c version=0x%x.\n",
- 		    chksum, nv->id[0], nv->nvram_version);
+ 		    "Inconsistent NVRAM detected: checksum=%#x id=%.4s version=%#x.\n",
+ 		    chksum, nv->id, nv->nvram_version);
  		ql_log(ql_log_warn, vha, 0x0065,
  		    "Falling back to "
  		    "functioning (yet invalid -- WWPN) defaults.\n");
@@@ -6718,16 -7018,16 +6716,22 @@@ qla24xx_nvram_config(scsi_qla_host_t *v
  	ql_dbg(ql_dbg_init + ql_dbg_buffer, vha, 0x006a,
  	    "Contents of NVRAM\n");
  	ql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x010d,
 -	    nv, ha->nvram_size);
 +	    (uint8_t *)nv, ha->nvram_size);
  
  	/* Bad NVRAM data, set defaults parameters. */
 -	if (chksum || memcmp("ISP ", nv->id, sizeof(nv->id)) ||
 -	    le16_to_cpu(nv->nvram_version) < ICB_VERSION) {
 +	if (chksum || nv->id[0] != 'I' || nv->id[1] != 'S' || nv->id[2] != 'P'
 +	    || nv->id[3] != ' ' ||
 +	    nv->nvram_version < cpu_to_le16(ICB_VERSION)) {
  		/* Reset NVRAM data. */
  		ql_log(ql_log_warn, vha, 0x006b,
++<<<<<<< HEAD
 +		    "Inconsistent NVRAM detected: checksum=0x%x id=%c "
 +		    "version=0x%x.\n", chksum, nv->id[0], nv->nvram_version);
++=======
+ 		    "Inconsistent NVRAM checksum=%#x id=%.4s version=%#x.\n",
+ 		    chksum, nv->id, nv->nvram_version);
+ 		ql_dump_buffer(ql_dbg_init, vha, 0x006b, nv, sizeof(*nv));
++>>>>>>> 3695310e37b4 (scsi: qla2xxx: Update flash read/write routine)
  		ql_log(ql_log_warn, vha, 0x006c,
  		    "Falling back to functioning (yet invalid -- WWPN) "
  		    "defaults.\n");
@@@ -7100,72 -7402,84 +7104,86 @@@ qla24xx_load_risc_flash(scsi_qla_host_
  			faddr += dlen;
  			risc_addr += dlen;
  			risc_size -= dlen;
 +			fragment++;
  		}
 -	}
  
 -	if (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))
 -		return QLA_SUCCESS;
 +		/* Next segment. */
 +		segments--;
 +	}
  
 -	templates = (risc_attr & BIT_9) ? 2 : 1;
 -	ql_dbg(ql_dbg_init, vha, 0x0160, "-> templates = %u\n", templates);
 -	for (j = 0; j < templates; j++, fwdt++) {
 -		if (fwdt->template)
 -			vfree(fwdt->template);
 -		fwdt->template = NULL;
 -		fwdt->length = 0;
 +	if (!IS_QLA27XX(ha))
 +		return rval;
  
 +	if (ha->fw_dump_template)
 +		vfree(ha->fw_dump_template);
 +	ha->fw_dump_template = NULL;
 +	ha->fw_dump_template_len = 0;
 +
++<<<<<<< HEAD
 +	ql_dbg(ql_dbg_init, vha, 0x0161,
 +	    "Loading fwdump template from %x\n", faddr);
 +	qla24xx_read_flash_data(vha, dcode, faddr, 7);
 +	risc_size = be32_to_cpu(dcode[2]);
 +	ql_dbg(ql_dbg_init, vha, 0x0162,
 +	    "-> array size %x dwords\n", risc_size);
 +	if (risc_size == 0 || risc_size == ~0)
 +		goto failed;
++=======
+ 		dcode = (void *)req->ring;
+ 		qla24xx_read_flash_data(vha, dcode, faddr, 7);
+ 		risc_size = be32_to_cpu(dcode[2]);
+ 		ql_dbg(ql_dbg_init, vha, 0x0161,
+ 		    "-> fwdt%u template array at %#x (%#x dwords)\n",
+ 		    j, faddr, risc_size);
+ 		if (!risc_size || !~risc_size) {
+ 			ql_dbg(ql_dbg_init, vha, 0x0162,
+ 			    "-> fwdt%u failed to read array\n", j);
+ 			goto failed;
+ 		}
++>>>>>>> 3695310e37b4 (scsi: qla2xxx: Update flash read/write routine)
  
 -		/* skip header and ignore checksum */
 -		faddr += 7;
 -		risc_size -= 8;
 -
 -		ql_dbg(ql_dbg_init, vha, 0x0163,
 -		    "-> fwdt%u template allocate template %#x words...\n",
 -		    j, risc_size);
 -		fwdt->template = vmalloc(risc_size * sizeof(*dcode));
 -		if (!fwdt->template) {
 -			ql_log(ql_log_warn, vha, 0x0164,
 -			    "-> fwdt%u failed allocate template.\n", j);
 -			goto failed;
 -		}
 -
 -		dcode = fwdt->template;
 -		qla24xx_read_flash_data(vha, dcode, faddr, risc_size);
 -		for (i = 0; i < risc_size; i++)
 -			dcode[i] = le32_to_cpu(dcode[i]);
 -
 -		if (!qla27xx_fwdt_template_valid(dcode)) {
 -			ql_log(ql_log_warn, vha, 0x0165,
 -			    "-> fwdt%u failed template validate\n", j);
 -			goto failed;
 -		}
 -
 -		dlen = qla27xx_fwdt_template_size(dcode);
 -		ql_dbg(ql_dbg_init, vha, 0x0166,
 -		    "-> fwdt%u template size %#lx bytes (%#lx words)\n",
 -		    j, dlen, dlen / sizeof(*dcode));
 -		if (dlen > risc_size * sizeof(*dcode)) {
 -			ql_log(ql_log_warn, vha, 0x0167,
 -			    "-> fwdt%u template exceeds array (%-lu bytes)\n",
 -			    j, dlen - risc_size * sizeof(*dcode));
 -			goto failed;
 -		}
 +	dlen = (risc_size - 8) * sizeof(*dcode);
 +	ql_dbg(ql_dbg_init, vha, 0x0163,
 +	    "-> template allocating %x bytes...\n", dlen);
 +	ha->fw_dump_template = vmalloc(dlen);
 +	if (!ha->fw_dump_template) {
 +		ql_log(ql_log_warn, vha, 0x0164,
 +		    "Failed fwdump template allocate %x bytes.\n", risc_size);
 +		goto failed;
 +	}
  
 -		fwdt->length = dlen;
 -		ql_dbg(ql_dbg_init, vha, 0x0168,
 -		    "-> fwdt%u loaded template ok\n", j);
 +	faddr += 7;
 +	risc_size -= 8;
 +	dcode = ha->fw_dump_template;
 +	qla24xx_read_flash_data(vha, dcode, faddr, risc_size);
 +	for (i = 0; i < risc_size; i++)
 +		dcode[i] = le32_to_cpu(dcode[i]);
  
 -		faddr += risc_size + 1;
 +	if (!qla27xx_fwdt_template_valid(dcode)) {
 +		ql_log(ql_log_warn, vha, 0x0165,
 +		    "Failed fwdump template validate\n");
 +		goto failed;
  	}
  
 -	return QLA_SUCCESS;
 +	dlen = qla27xx_fwdt_template_size(dcode);
 +	ql_dbg(ql_dbg_init, vha, 0x0166,
 +	    "-> template size %x bytes\n", dlen);
 +	if (dlen > risc_size * sizeof(*dcode)) {
 +		ql_log(ql_log_warn, vha, 0x0167,
 +		    "Failed fwdump template exceeds array by %zx bytes\n",
 +		    (size_t)(dlen - risc_size * sizeof(*dcode)));
 +		goto failed;
 +	}
 +	ha->fw_dump_template_len = dlen;
 +	return rval;
  
  failed:
 -	if (fwdt->template)
 -		vfree(fwdt->template);
 -	fwdt->template = NULL;
 -	fwdt->length = 0;
 -
 -	return QLA_SUCCESS;
 +	ql_log(ql_log_warn, vha, 0x016d, "Failed fwdump template\n");
 +	if (ha->fw_dump_template)
 +		vfree(ha->fw_dump_template);
 +	ha->fw_dump_template = NULL;
 +	ha->fw_dump_template_len = 0;
 +	return rval;
  }
  
  #define QLA_FW_URL "http://ldriver.qlogic.com/firmware/"
@@@ -7681,17 -8012,16 +7699,23 @@@ qla81xx_nvram_config(scsi_qla_host_t *v
  	ql_dbg(ql_dbg_init + ql_dbg_buffer, vha, 0x0111,
  	    "Contents of NVRAM:\n");
  	ql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x0112,
 -	    nv, ha->nvram_size);
 +	    (uint8_t *)nv, ha->nvram_size);
  
  	/* Bad NVRAM data, set defaults parameters. */
 -	if (chksum || memcmp("ISP ", nv->id, sizeof(nv->id)) ||
 -	    le16_to_cpu(nv->nvram_version) < ICB_VERSION) {
 +	if (chksum || nv->id[0] != 'I' || nv->id[1] != 'S' || nv->id[2] != 'P'
 +	    || nv->id[3] != ' ' ||
 +	    nv->nvram_version < cpu_to_le16(ICB_VERSION)) {
  		/* Reset NVRAM data. */
  		ql_log(ql_log_info, vha, 0x0073,
++<<<<<<< HEAD
 +		    "Inconsistent NVRAM detected: checksum=0x%x id=%c "
 +		    "version=0x%x.\n", chksum, nv->id[0],
 +		    le16_to_cpu(nv->nvram_version));
++=======
+ 		    "Inconsistent NVRAM checksum=%#x id=%.4s version=%#x.\n",
+ 		    chksum, nv->id, le16_to_cpu(nv->nvram_version));
+ 		ql_dump_buffer(ql_dbg_init, vha, 0x0073, nv, sizeof(*nv));
++>>>>>>> 3695310e37b4 (scsi: qla2xxx: Update flash read/write routine)
  		ql_log(ql_log_info, vha, 0x0074,
  		    "Falling back to functioning (yet invalid -- WWPN) "
  		    "defaults.\n");
diff --cc drivers/scsi/qla2xxx/qla_sup.c
index 2a3055c799fb,eb4514a56640..000000000000
--- a/drivers/scsi/qla2xxx/qla_sup.c
+++ b/drivers/scsi/qla2xxx/qla_sup.c
@@@ -571,12 -573,13 +573,10 @@@ qla2xxx_find_flt_start(scsi_qla_host_t 
  	} else if (IS_QLA83XX(ha) || IS_QLA27XX(ha)) {
  		*start = FA_FLASH_LAYOUT_ADDR_83;
  		goto end;
 -	} else if (IS_QLA28XX(ha)) {
 -		*start = FA_FLASH_LAYOUT_ADDR_28;
 -		goto end;
  	}
+ 
  	/* Begin with first PCI expansion ROM header. */
- 	buf = (uint8_t *)req->ring;
- 	dcode = (uint32_t *)req->ring;
  	pcihdr = 0;
- 	last_image = 1;
  	do {
  		/* Verify PCI expansion ROM header. */
  		qla24xx_read_flash_data(vha, dcode, pcihdr >> 2, 0x20);
@@@ -1246,30 -1242,30 +1238,45 @@@ qla24xx_write_flash_data(scsi_qla_host_
  	void *optrom = NULL;
  	struct qla_hw_data *ha = vha->hw;
  
++<<<<<<< HEAD
 +	/* Prepare burst-capable write on supported ISPs. */
 +	if ((IS_QLA25XX(ha) || IS_QLA81XX(ha) || IS_QLA83XX(ha) ||
 +	    IS_QLA27XX(ha)) &&
 +	    !(faddr & 0xfff) && dwords > OPTROM_BURST_DWORDS) {
 +		optrom = dma_alloc_coherent(&ha->pdev->dev, OPTROM_BURST_SIZE,
 +		    &optrom_dma, GFP_KERNEL);
 +		if (!optrom) {
 +			ql_log(ql_log_warn, vha, 0x7095,
 +			    "Unable to allocate "
 +			    "memory for optrom burst write (%x KB).\n",
 +			    OPTROM_BURST_SIZE / 1024);
 +		}
- 	}
++=======
+ 	if (!IS_QLA25XX(ha) && !IS_QLA81XX(ha) && !IS_QLA83XX(ha) &&
+ 	    !IS_QLA27XX(ha) && !IS_QLA28XX(ha))
+ 		goto next;
  
- 	rest_addr = (ha->fdt_block_size >> 2) - 1;
- 	sec_mask = ~rest_addr;
+ 	/* Allocate dma buffer for burst write */
+ 	optrom = dma_alloc_coherent(&ha->pdev->dev, OPTROM_BURST_SIZE,
+ 	    &optrom_dma, GFP_KERNEL);
+ 	if (!optrom) {
+ 		ql_log(ql_log_warn, vha, 0x7095,
+ 		    "Failed allocate burst (%x bytes)\n", OPTROM_BURST_SIZE);
+ 	}
  
+ next:
+ 	ql_log(ql_log_warn + ql_dbg_verbose, vha, 0x7095,
+ 	    "Unprotect flash...\n");
  	ret = qla24xx_unprotect_flash(vha);
- 	if (ret != QLA_SUCCESS) {
+ 	if (ret) {
  		ql_log(ql_log_warn, vha, 0x7096,
- 		    "Unable to unprotect flash for update.\n");
+ 		    "Failed to unprotect flash.\n");
  		goto done;
++>>>>>>> 3695310e37b4 (scsi: qla2xxx: Update flash read/write routine)
  	}
  
+ 	rest_addr = (ha->fdt_block_size >> 2) - 1;
+ 	sec_mask = ~rest_addr;
  	for (liter = 0; liter < dwords; liter++, faddr++, dwptr++) {
  		fdata = (faddr & sec_mask) << 2;
  
@@@ -2874,7 -2874,7 +2882,11 @@@ qla2x00_get_flash_version(scsi_qla_host
  		    "Dumping fw "
  		    "ver from flash:.\n");
  		ql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x010b,
++<<<<<<< HEAD
 +		    (uint8_t *)dbyte, 8);
++=======
+ 		    dbyte, 32);
++>>>>>>> 3695310e37b4 (scsi: qla2xxx: Update flash read/write routine)
  
  		if ((dcode[0] == 0xffff && dcode[1] == 0xffff &&
  		    dcode[2] == 0xffff && dcode[3] == 0xffff) ||
@@@ -3040,9 -3032,8 +3044,8 @@@ qla24xx_get_flash_version(scsi_qla_host
  	memset(ha->fcode_revision, 0, sizeof(ha->fcode_revision));
  	memset(ha->fw_revision, 0, sizeof(ha->fw_revision));
  
- 	dcode = mbuf;
  	pcihdr = ha->flt_region_boot << 2;
 -	if ((IS_QLA27XX(ha) || IS_QLA28XX(ha)) &&
 +	if (IS_QLA27XX(ha) &&
  	    qla27xx_find_valid_image(vha) == QLA27XX_SECONDARY_IMAGE)
  		pcihdr = ha->flt_region_boot_sec << 2;
  
@@@ -3117,9 -3107,8 +3119,8 @@@
  
  	/* Read firmware image information. */
  	memset(ha->fw_revision, 0, sizeof(ha->fw_revision));
- 	dcode = mbuf;
  	faddr = ha->flt_region_fw;
 -	if ((IS_QLA27XX(ha) || IS_QLA28XX(ha)) &&
 +	if (IS_QLA27XX(ha) &&
  	    qla27xx_find_valid_image(vha) == QLA27XX_SECONDARY_IMAGE)
  		faddr = ha->flt_region_fw_sec;
  
@@@ -3134,13 -3117,12 +3135,18 @@@
  		ql_log(ql_log_warn, vha, 0x005f,
  		    "Unrecognized fw revision at %x.\n",
  		    ha->flt_region_fw * 4);
+ 		ql_dump_buffer(ql_dbg_init, vha, 0x005f, dcode, 32);
  	} else {
 -		for (i = 0; i < 4; i++)
 -			ha->fw_revision[i] = be32_to_cpu(dcode[4+i]);
 +		ha->fw_revision[0] = dcode[0];
 +		ha->fw_revision[1] = dcode[1];
 +		ha->fw_revision[2] = dcode[2];
 +		ha->fw_revision[3] = dcode[3];
  		ql_dbg(ql_dbg_init, vha, 0x0060,
++<<<<<<< HEAD
 +		    "Firmware revision %d.%d.%d (%x).\n",
++=======
+ 		    "Firmware revision (flash) %u.%u.%u (%x).\n",
++>>>>>>> 3695310e37b4 (scsi: qla2xxx: Update flash read/write routine)
  		    ha->fw_revision[0], ha->fw_revision[1],
  		    ha->fw_revision[2], ha->fw_revision[3]);
  	}
@@@ -3152,15 -3134,12 +3158,21 @@@
  	}
  
  	memset(ha->gold_fw_version, 0, sizeof(ha->gold_fw_version));
++<<<<<<< HEAD
 +	dcode = mbuf;
 +	ha->isp_ops->read_optrom(vha, (uint8_t *)dcode,
 +	    ha->flt_region_gold_fw << 2, 32);
 +
 +	if (dcode[4] == 0xFFFFFFFF && dcode[5] == 0xFFFFFFFF &&
 +	    dcode[6] == 0xFFFFFFFF && dcode[7] == 0xFFFFFFFF) {
++=======
+ 	faddr = ha->flt_region_gold_fw;
+ 	qla24xx_read_flash_data(vha, (void *)dcode, ha->flt_region_gold_fw, 8);
+ 	if (qla24xx_risc_firmware_invalid(dcode)) {
++>>>>>>> 3695310e37b4 (scsi: qla2xxx: Update flash read/write routine)
  		ql_log(ql_log_warn, vha, 0x0056,
- 		    "Unrecognized golden fw at 0x%x.\n",
- 		    ha->flt_region_gold_fw * 4);
+ 		    "Unrecognized golden fw at %#x.\n", faddr);
+ 		ql_dump_buffer(ql_dbg_init, vha, 0x0056, dcode, 32);
  		return ret;
  	}
  
* Unmerged path drivers/scsi/qla2xxx/qla_attr.c
diff --git a/drivers/scsi/qla2xxx/qla_def.h b/drivers/scsi/qla2xxx/qla_def.h
index 824b13554ed2..1ba4f72607dc 100644
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@ -3144,9 +3144,9 @@ struct isp_operations {
 	void *(*prep_ms_fdmi_iocb) (struct scsi_qla_host *, uint32_t,
 	    uint32_t);
 
-	uint8_t *(*read_nvram) (struct scsi_qla_host *, uint8_t *,
+	uint8_t *(*read_nvram)(struct scsi_qla_host *, void *,
 		uint32_t, uint32_t);
-	int (*write_nvram) (struct scsi_qla_host *, uint8_t *, uint32_t,
+	int (*write_nvram)(struct scsi_qla_host *, void *, uint32_t,
 		uint32_t);
 
 	void (*fw_dump) (struct scsi_qla_host *, int);
@@ -3155,9 +3155,9 @@ struct isp_operations {
 	int (*beacon_off) (struct scsi_qla_host *);
 	void (*beacon_blink) (struct scsi_qla_host *);
 
-	uint8_t * (*read_optrom) (struct scsi_qla_host *, uint8_t *,
+	void *(*read_optrom)(struct scsi_qla_host *, void *,
 		uint32_t, uint32_t);
-	int (*write_optrom) (struct scsi_qla_host *, uint8_t *, uint32_t,
+	int (*write_optrom)(struct scsi_qla_host *, void *, uint32_t,
 		uint32_t);
 
 	int (*get_flash_version) (struct scsi_qla_host *, void *);
diff --git a/drivers/scsi/qla2xxx/qla_gbl.h b/drivers/scsi/qla2xxx/qla_gbl.h
index ca3f732c0824..a9f9ce3043de 100644
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@ -540,19 +540,20 @@ fc_port_t *qla2x00_find_fcport_by_nportid(scsi_qla_host_t *, port_id_t *, u8);
  */
 extern void qla2x00_release_nvram_protection(scsi_qla_host_t *);
 extern uint32_t *qla24xx_read_flash_data(scsi_qla_host_t *, uint32_t *,
-					 uint32_t, uint32_t);
-extern uint8_t *qla2x00_read_nvram_data(scsi_qla_host_t *, uint8_t *, uint32_t,
-					uint32_t);
-extern uint8_t *qla24xx_read_nvram_data(scsi_qla_host_t *, uint8_t *, uint32_t,
-					uint32_t);
-extern int qla2x00_write_nvram_data(scsi_qla_host_t *, uint8_t *, uint32_t,
-				    uint32_t);
-extern int qla24xx_write_nvram_data(scsi_qla_host_t *, uint8_t *, uint32_t,
-				    uint32_t);
-extern uint8_t *qla25xx_read_nvram_data(scsi_qla_host_t *, uint8_t *, uint32_t,
-					uint32_t);
-extern int qla25xx_write_nvram_data(scsi_qla_host_t *, uint8_t *, uint32_t,
-				    uint32_t);
+    uint32_t, uint32_t);
+extern uint8_t *qla2x00_read_nvram_data(scsi_qla_host_t *, void *, uint32_t,
+    uint32_t);
+extern uint8_t *qla24xx_read_nvram_data(scsi_qla_host_t *, void *, uint32_t,
+    uint32_t);
+extern int qla2x00_write_nvram_data(scsi_qla_host_t *, void *, uint32_t,
+    uint32_t);
+extern int qla24xx_write_nvram_data(scsi_qla_host_t *, void *, uint32_t,
+    uint32_t);
+extern uint8_t *qla25xx_read_nvram_data(scsi_qla_host_t *, void *, uint32_t,
+    uint32_t);
+extern int qla25xx_write_nvram_data(scsi_qla_host_t *, void *, uint32_t,
+    uint32_t);
+
 extern int qla2x00_is_a_vp_did(scsi_qla_host_t *, uint32_t);
 bool qla2x00_check_reg32_for_disconnect(scsi_qla_host_t *, uint32_t);
 bool qla2x00_check_reg16_for_disconnect(scsi_qla_host_t *, uint16_t);
@@ -572,18 +573,18 @@ extern int qla83xx_restart_nic_firmware(scsi_qla_host_t *);
 extern int qla83xx_access_control(scsi_qla_host_t *, uint16_t, uint32_t,
 				  uint32_t, uint16_t *);
 
-extern uint8_t *qla2x00_read_optrom_data(struct scsi_qla_host *, uint8_t *,
+extern void *qla2x00_read_optrom_data(struct scsi_qla_host *, void *,
 					 uint32_t, uint32_t);
-extern int qla2x00_write_optrom_data(struct scsi_qla_host *, uint8_t *,
+extern int qla2x00_write_optrom_data(struct scsi_qla_host *, void *,
 				     uint32_t, uint32_t);
-extern uint8_t *qla24xx_read_optrom_data(struct scsi_qla_host *, uint8_t *,
+extern void *qla24xx_read_optrom_data(struct scsi_qla_host *, void *,
 					 uint32_t, uint32_t);
-extern int qla24xx_write_optrom_data(struct scsi_qla_host *, uint8_t *,
+extern int qla24xx_write_optrom_data(struct scsi_qla_host *, void *,
 				     uint32_t, uint32_t);
-extern uint8_t *qla25xx_read_optrom_data(struct scsi_qla_host *, uint8_t *,
+extern void *qla25xx_read_optrom_data(struct scsi_qla_host *, void *,
 					 uint32_t, uint32_t);
-extern uint8_t *qla8044_read_optrom_data(struct scsi_qla_host *,
-					 uint8_t *, uint32_t, uint32_t);
+extern void *qla8044_read_optrom_data(struct scsi_qla_host *,
+					 void *, uint32_t, uint32_t);
 extern void qla8044_watchdog(struct scsi_qla_host *vha);
 
 extern int qla2x00_get_flash_version(scsi_qla_host_t *, void *);
@@ -767,9 +768,9 @@ extern int qla82xx_start_firmware(scsi_qla_host_t *);
 
 /* Firmware and flash related functions */
 extern int qla82xx_load_risc(scsi_qla_host_t *, uint32_t *);
-extern uint8_t *qla82xx_read_optrom_data(struct scsi_qla_host *, uint8_t *,
+extern void *qla82xx_read_optrom_data(struct scsi_qla_host *, void *,
 					 uint32_t, uint32_t);
-extern int qla82xx_write_optrom_data(struct scsi_qla_host *, uint8_t *,
+extern int qla82xx_write_optrom_data(struct scsi_qla_host *, void *,
 				     uint32_t, uint32_t);
 
 /* Mailbox related functions */
@@ -865,7 +866,7 @@ extern void qla8044_clear_drv_active(struct qla_hw_data *);
 void qla8044_get_minidump(struct scsi_qla_host *vha);
 int qla8044_collect_md_data(struct scsi_qla_host *vha);
 extern int qla8044_md_get_template(scsi_qla_host_t *);
-extern int qla8044_write_optrom_data(struct scsi_qla_host *, uint8_t *,
+extern int qla8044_write_optrom_data(struct scsi_qla_host *, void *,
 				     uint32_t, uint32_t);
 extern irqreturn_t qla8044_intr_handler(int, void *);
 extern void qla82xx_mbx_completion(scsi_qla_host_t *, uint16_t);
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
diff --git a/drivers/scsi/qla2xxx/qla_nx.c b/drivers/scsi/qla2xxx/qla_nx.c
index f2f54806f4da..d545d34419e5 100644
--- a/drivers/scsi/qla2xxx/qla_nx.c
+++ b/drivers/scsi/qla2xxx/qla_nx.c
@@ -2658,8 +2658,8 @@ qla82xx_erase_sector(struct qla_hw_data *ha, int addr)
 /*
  * Address and length are byte address
  */
-uint8_t *
-qla82xx_read_optrom_data(struct scsi_qla_host *vha, uint8_t *buf,
+void *
+qla82xx_read_optrom_data(struct scsi_qla_host *vha, void *buf,
 	uint32_t offset, uint32_t length)
 {
 	scsi_block_requests(vha->host);
@@ -2767,15 +2767,14 @@ qla82xx_write_flash_data(struct scsi_qla_host *vha, uint32_t *dwptr,
 }
 
 int
-qla82xx_write_optrom_data(struct scsi_qla_host *vha, uint8_t *buf,
+qla82xx_write_optrom_data(struct scsi_qla_host *vha, void *buf,
 	uint32_t offset, uint32_t length)
 {
 	int rval;
 
 	/* Suspend HBA. */
 	scsi_block_requests(vha->host);
-	rval = qla82xx_write_flash_data(vha, (uint32_t *)buf, offset,
-		length >> 2);
+	rval = qla82xx_write_flash_data(vha, buf, offset, length >> 2);
 	scsi_unblock_requests(vha->host);
 
 	/* Convert return ISP82xx to generic */
@@ -3699,8 +3698,8 @@ qla82xx_chip_reset_cleanup(scsi_qla_host_t *vha)
 		spin_unlock_irqrestore(&ha->hardware_lock, flags);
 
 		/* Wait for pending cmds (physical and virtual) to complete */
-		if (qla2x00_eh_wait_for_pending_commands(vha, 0, 0,
-		    WAIT_HOST)) {
+		if (!qla2x00_eh_wait_for_pending_commands(vha, 0, 0,
+		    WAIT_HOST) == QLA_SUCCESS) {
 			ql_dbg(ql_dbg_init, vha, 0x00b3,
 			    "Done wait for "
 			    "pending commands.\n");
diff --git a/drivers/scsi/qla2xxx/qla_nx2.c b/drivers/scsi/qla2xxx/qla_nx2.c
index fe856b602e03..691f81d7b1a3 100644
--- a/drivers/scsi/qla2xxx/qla_nx2.c
+++ b/drivers/scsi/qla2xxx/qla_nx2.c
@@ -559,12 +559,12 @@ qla8044_read_flash_data(scsi_qla_host_t *vha,  uint8_t *p_data,
 /*
  * Address and length are byte address
  */
-uint8_t *
-qla8044_read_optrom_data(struct scsi_qla_host *vha, uint8_t *buf,
+void *
+qla8044_read_optrom_data(struct scsi_qla_host *vha, void *buf,
 	uint32_t offset, uint32_t length)
 {
 	scsi_block_requests(vha->host);
-	if (qla8044_read_flash_data(vha, (uint8_t *)buf, offset, length / 4)
+	if (qla8044_read_flash_data(vha, buf, offset, length / 4)
 	    != QLA_SUCCESS) {
 		ql_log(ql_log_warn, vha,  0xb08d,
 		    "%s: Failed to read from flash\n",
@@ -3797,7 +3797,7 @@ qla8044_write_flash_dword_mode(scsi_qla_host_t *vha, uint32_t *dwptr,
 }
 
 int
-qla8044_write_optrom_data(struct scsi_qla_host *vha, uint8_t *buf,
+qla8044_write_optrom_data(struct scsi_qla_host *vha, void *buf,
 			  uint32_t offset, uint32_t length)
 {
 	int rval = QLA_FUNCTION_FAILED, i, burst_iter_count;
* Unmerged path drivers/scsi/qla2xxx/qla_sup.c
