net/ipv6: Refactor address dump to push inet6_fill_args to in6_dump_addrs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [net] ipv6: Refactor address dump to push inet6_fill_args to in6_dump_addrs (Petr Oros) [1700306]
Rebuild_FUZZ: 97.18%
commit-author David Ahern <dsahern@gmail.com>
commit 6ba1e6e856ab0531c5e0a5ecefc9fff8490d9a04
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/6ba1e6e8.failed

Pull the inet6_fill_args arg up to in6_dump_addrs and move netnsid
into it.

	Signed-off-by: David Ahern <dsahern@gmail.com>
	Acked-by: Christian Brauner <christian@brauner.io>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6ba1e6e856ab0531c5e0a5ecefc9fff8490d9a04)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/addrconf.c
diff --cc net/ipv6/addrconf.c
index 75a2cc3a2edb,afa279170ba5..000000000000
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@@ -4801,9 -4793,23 +4801,27 @@@ static inline int inet6_ifaddr_msgsize(
  	       + nla_total_size(4)  /* IFA_RT_PRIORITY */;
  }
  
++<<<<<<< HEAD
++=======
+ enum addr_type_t {
+ 	UNICAST_ADDR,
+ 	MULTICAST_ADDR,
+ 	ANYCAST_ADDR,
+ };
+ 
+ struct inet6_fill_args {
+ 	u32 portid;
+ 	u32 seq;
+ 	int event;
+ 	unsigned int flags;
+ 	int netnsid;
+ 	enum addr_type_t type;
+ };
+ 
++>>>>>>> 6ba1e6e856ab (net/ipv6: Refactor address dump to push inet6_fill_args to in6_dump_addrs)
  static int inet6_fill_ifaddr(struct sk_buff *skb, struct inet6_ifaddr *ifa,
 -			     struct inet6_fill_args *args)
 +			     u32 portid, u32 seq, int event, unsigned int flags,
 +			     int netnsid)
  {
  	struct nlmsghdr  *nlh;
  	u32 preferred, valid;
@@@ -4944,19 -4949,16 +4957,29 @@@ static int in6_dump_addrs(struct inet6_
  	int ip_idx = *p_ip_idx;
  
  	read_lock_bh(&idev->lock);
- 	switch (type) {
+ 	switch (fillargs->type) {
  	case UNICAST_ADDR: {
  		struct inet6_ifaddr *ifa;
++<<<<<<< HEAD
 +
 +		/* unicast address incl. temp addr */
 +		list_for_each_entry(ifa, &idev->addr_list, if_list) {
 +			if (ip_idx < s_ip_idx)
 +				goto next;
 +			err = inet6_fill_ifaddr(skb, ifa,
 +						NETLINK_CB(cb->skb).portid,
 +						cb->nlh->nlmsg_seq,
 +						RTM_NEWADDR,
 +						NLM_F_MULTI, netnsid);
++=======
+ 		fillargs->event = RTM_NEWADDR;
+ 
+ 		/* unicast address incl. temp addr */
+ 		list_for_each_entry(ifa, &idev->addr_list, if_list) {
+ 			if (++ip_idx < s_ip_idx)
+ 				continue;
+ 			err = inet6_fill_ifaddr(skb, ifa, fillargs);
++>>>>>>> 6ba1e6e856ab (net/ipv6: Refactor address dump to push inet6_fill_args to in6_dump_addrs)
  			if (err < 0)
  				break;
  			nl_dump_check_consistent(cb, nlmsg_hdr(skb));
@@@ -4966,31 -4966,26 +4989,48 @@@ next
  		break;
  	}
  	case MULTICAST_ADDR:
++<<<<<<< HEAD
++=======
+ 		fillargs->event = RTM_GETMULTICAST;
+ 
++>>>>>>> 6ba1e6e856ab (net/ipv6: Refactor address dump to push inet6_fill_args to in6_dump_addrs)
  		/* multicast address */
  		for (ifmca = idev->mc_list; ifmca;
  		     ifmca = ifmca->next, ip_idx++) {
  			if (ip_idx < s_ip_idx)
  				continue;
++<<<<<<< HEAD
 +			err = inet6_fill_ifmcaddr(skb, ifmca,
 +						  NETLINK_CB(cb->skb).portid,
 +						  cb->nlh->nlmsg_seq,
 +						  RTM_GETMULTICAST,
 +						  NLM_F_MULTI, netnsid);
++=======
+ 			err = inet6_fill_ifmcaddr(skb, ifmca, fillargs);
++>>>>>>> 6ba1e6e856ab (net/ipv6: Refactor address dump to push inet6_fill_args to in6_dump_addrs)
  			if (err < 0)
  				break;
  		}
  		break;
  	case ANYCAST_ADDR:
++<<<<<<< HEAD
++=======
+ 		fillargs->event = RTM_GETANYCAST;
++>>>>>>> 6ba1e6e856ab (net/ipv6: Refactor address dump to push inet6_fill_args to in6_dump_addrs)
  		/* anycast address */
  		for (ifaca = idev->ac_list; ifaca;
  		     ifaca = ifaca->aca_next, ip_idx++) {
  			if (ip_idx < s_ip_idx)
  				continue;
++<<<<<<< HEAD
 +			err = inet6_fill_ifacaddr(skb, ifaca,
 +						  NETLINK_CB(cb->skb).portid,
 +						  cb->nlh->nlmsg_seq,
 +						  RTM_GETANYCAST,
 +						  NLM_F_MULTI, netnsid);
++=======
+ 			err = inet6_fill_ifacaddr(skb, ifaca, fillargs);
++>>>>>>> 6ba1e6e856ab (net/ipv6: Refactor address dump to push inet6_fill_args to in6_dump_addrs)
  			if (err < 0)
  				break;
  		}
@@@ -5022,11 -5023,12 +5068,12 @@@ static int inet6_dump_addr(struct sk_bu
  	s_ip_idx = ip_idx = cb->args[2];
  
  	if (nlmsg_parse(cb->nlh, sizeof(struct ifaddrmsg), tb, IFA_MAX,
 -			ifa_ipv6_policy, cb->extack) >= 0) {
 +			ifa_ipv6_policy, NULL) >= 0) {
  		if (tb[IFA_TARGET_NETNSID]) {
- 			netnsid = nla_get_s32(tb[IFA_TARGET_NETNSID]);
+ 			fillargs.netnsid = nla_get_s32(tb[IFA_TARGET_NETNSID]);
  
- 			tgt_net = rtnl_get_net_ns_capable(skb->sk, netnsid);
+ 			tgt_net = rtnl_get_net_ns_capable(skb->sk,
+ 							  fillargs.netnsid);
  			if (IS_ERR(tgt_net))
  				return PTR_ERR(tgt_net);
  		}
* Unmerged path net/ipv6/addrconf.c
