nfp: flower: fix masks for tcp and ip flags fields

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Pieter Jansen van Vuuren <pieter.jansenvanvuuren@netronome.com>
commit 0496743b202ac0f2710ae243a493118ca5096c04
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/0496743b.failed

Check mask fields of tcp and ip flags when setting the corresponding mask
flag used in hardware.

Fixes: 8f2566225ae2 ("flow_offload: add flow_rule and flow_match")
	Signed-off-by: Pieter Jansen van Vuuren <pieter.jansenvanvuuren@netronome.com>
	Reviewed-by: John Hurley <john.hurley@netronome.com>
	Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0496743b202ac0f2710ae243a493118ca5096c04)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/flower/match.c
diff --cc drivers/net/ethernet/netronome/nfp/flower/match.c
index c7e562a3162e,e03c8ef2c28c..000000000000
--- a/drivers/net/ethernet/netronome/nfp/flower/match.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/match.c
@@@ -133,61 -147,76 +133,108 @@@ nfp_flower_compile_tport(struct nfp_flo
  }
  
  static void
 -nfp_flower_compile_ip_ext(struct nfp_flower_ip_ext *ext,
 -			  struct nfp_flower_ip_ext *msk,
 -			  struct tc_cls_flower_offload *flow)
 +nfp_flower_compile_ip_ext(struct nfp_flower_ip_ext *frame,
 +			  struct tc_cls_flower_offload *flow,
 +			  bool mask_version)
  {
 -	struct flow_rule *rule = tc_cls_flower_offload_flow_rule(flow);
 +	struct fl_flow_key *target = mask_version ? flow->mask : flow->key;
  
 -	if (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_BASIC)) {
 -		struct flow_match_basic match;
 +	if (dissector_uses_key(flow->dissector, FLOW_DISSECTOR_KEY_BASIC)) {
 +		struct flow_dissector_key_basic *basic;
  
 -		flow_rule_match_basic(rule, &match);
 -		ext->proto = match.key->ip_proto;
 -		msk->proto = match.mask->ip_proto;
 +		basic = skb_flow_dissector_target(flow->dissector,
 +						  FLOW_DISSECTOR_KEY_BASIC,
 +						  target);
 +		frame->proto = basic->ip_proto;
  	}
  
 -	if (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_IP)) {
 -		struct flow_match_ip match;
 +	if (dissector_uses_key(flow->dissector, FLOW_DISSECTOR_KEY_IP)) {
 +		struct flow_dissector_key_ip *flow_ip;
  
 -		flow_rule_match_ip(rule, &match);
 -		ext->tos = match.key->tos;
 -		ext->ttl = match.key->ttl;
 -		msk->tos = match.mask->tos;
 -		msk->ttl = match.mask->ttl;
 +		flow_ip = skb_flow_dissector_target(flow->dissector,
 +						    FLOW_DISSECTOR_KEY_IP,
 +						    target);
 +		frame->tos = flow_ip->tos;
 +		frame->ttl = flow_ip->ttl;
  	}
  
++<<<<<<< HEAD
 +	if (dissector_uses_key(flow->dissector, FLOW_DISSECTOR_KEY_TCP)) {
 +		struct flow_dissector_key_tcp *tcp;
 +		u32 tcp_flags;
 +
 +		tcp = skb_flow_dissector_target(flow->dissector,
 +						FLOW_DISSECTOR_KEY_TCP, target);
 +		tcp_flags = be16_to_cpu(tcp->flags);
 +
 +		if (tcp_flags & TCPHDR_FIN)
 +			frame->flags |= NFP_FL_TCP_FLAG_FIN;
 +		if (tcp_flags & TCPHDR_SYN)
 +			frame->flags |= NFP_FL_TCP_FLAG_SYN;
 +		if (tcp_flags & TCPHDR_RST)
 +			frame->flags |= NFP_FL_TCP_FLAG_RST;
 +		if (tcp_flags & TCPHDR_PSH)
 +			frame->flags |= NFP_FL_TCP_FLAG_PSH;
 +		if (tcp_flags & TCPHDR_URG)
 +			frame->flags |= NFP_FL_TCP_FLAG_URG;
++=======
+ 	if (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_TCP)) {
+ 		u16 tcp_flags, tcp_flags_mask;
+ 		struct flow_match_tcp match;
+ 
+ 		flow_rule_match_tcp(rule, &match);
+ 		tcp_flags = be16_to_cpu(match.key->flags);
+ 		tcp_flags_mask = be16_to_cpu(match.mask->flags);
+ 
+ 		if (tcp_flags & TCPHDR_FIN)
+ 			ext->flags |= NFP_FL_TCP_FLAG_FIN;
+ 		if (tcp_flags_mask & TCPHDR_FIN)
+ 			msk->flags |= NFP_FL_TCP_FLAG_FIN;
+ 
+ 		if (tcp_flags & TCPHDR_SYN)
+ 			ext->flags |= NFP_FL_TCP_FLAG_SYN;
+ 		if (tcp_flags_mask & TCPHDR_SYN)
+ 			msk->flags |= NFP_FL_TCP_FLAG_SYN;
+ 
+ 		if (tcp_flags & TCPHDR_RST)
+ 			ext->flags |= NFP_FL_TCP_FLAG_RST;
+ 		if (tcp_flags_mask & TCPHDR_RST)
+ 			msk->flags |= NFP_FL_TCP_FLAG_RST;
+ 
+ 		if (tcp_flags & TCPHDR_PSH)
+ 			ext->flags |= NFP_FL_TCP_FLAG_PSH;
+ 		if (tcp_flags_mask & TCPHDR_PSH)
+ 			msk->flags |= NFP_FL_TCP_FLAG_PSH;
+ 
+ 		if (tcp_flags & TCPHDR_URG)
+ 			ext->flags |= NFP_FL_TCP_FLAG_URG;
+ 		if (tcp_flags_mask & TCPHDR_URG)
+ 			msk->flags |= NFP_FL_TCP_FLAG_URG;
++>>>>>>> 0496743b202a (nfp: flower: fix masks for tcp and ip flags fields)
  	}
  
 -	if (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_CONTROL)) {
 -		struct flow_match_control match;
 -
 +	if (dissector_uses_key(flow->dissector, FLOW_DISSECTOR_KEY_CONTROL)) {
 +		struct flow_dissector_key_control *key;
 +
++<<<<<<< HEAD
 +		key = skb_flow_dissector_target(flow->dissector,
 +						FLOW_DISSECTOR_KEY_CONTROL,
 +						target);
 +		if (key->flags & FLOW_DIS_IS_FRAGMENT)
 +			frame->flags |= NFP_FL_IP_FRAGMENTED;
 +		if (key->flags & FLOW_DIS_FIRST_FRAG)
 +			frame->flags |= NFP_FL_IP_FRAG_FIRST;
++=======
+ 		flow_rule_match_control(rule, &match);
+ 		if (match.key->flags & FLOW_DIS_IS_FRAGMENT)
+ 			ext->flags |= NFP_FL_IP_FRAGMENTED;
+ 		if (match.mask->flags & FLOW_DIS_IS_FRAGMENT)
+ 			msk->flags |= NFP_FL_IP_FRAGMENTED;
+ 		if (match.key->flags & FLOW_DIS_FIRST_FRAG)
+ 			ext->flags |= NFP_FL_IP_FRAG_FIRST;
+ 		if (match.mask->flags & FLOW_DIS_FIRST_FRAG)
+ 			msk->flags |= NFP_FL_IP_FRAG_FIRST;
++>>>>>>> 0496743b202a (nfp: flower: fix masks for tcp and ip flags fields)
  	}
  }
  
* Unmerged path drivers/net/ethernet/netronome/nfp/flower/match.c
