net/mlx5e: Offload TC e-switch rules with egress LAG device

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Rabie Loulou <rabiel@mellanox.com>
commit 7ba58ba7ba5e19324b3879000ef341966b19727b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/7ba58ba7.failed

When parsing TC FDB actions, if the egress device is a bond/team
net-device which enslaved the uplink representor of the e-switch,
use the uplink representor as the destination in the HW rule.

	Signed-off-by: Rabie Loulou <rabiel@mellanox.com>
	Signed-off-by: Aviv Heller <avivh@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 7ba58ba7ba5e19324b3879000ef341966b19727b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index c9ee89f4edb1,cede77fd208f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -2661,21 -2572,44 +2661,33 @@@ static int parse_tc_fdb_actions(struct 
  			if (switchdev_port_same_parent_id(priv->netdev,
  							  out_dev) ||
  			    is_merged_eswitch_dev(priv, out_dev)) {
++<<<<<<< HEAD
 +				action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +					  MLX5_FLOW_CONTEXT_ACTION_COUNT;
++=======
+ 				struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
+ 				struct net_device *uplink_dev = mlx5_eswitch_uplink_get_proto_dev(esw, REP_ETH);
+ 				struct net_device *uplink_upper = netdev_master_upper_dev_get(uplink_dev);
+ 
+ 				if (uplink_upper &&
+ 				    netif_is_lag_master(uplink_upper) &&
+ 				    uplink_upper == out_dev)
+ 					out_dev = uplink_dev;
+ 
++>>>>>>> 7ba58ba7ba5e (net/mlx5e: Offload TC e-switch rules with egress LAG device)
  				out_priv = netdev_priv(out_dev);
  				rpriv = out_priv->ppriv;
 -				attr->dests[attr->out_count].rep = rpriv->rep;
 -				attr->dests[attr->out_count].mdev = out_priv->mdev;
 -				attr->out_count++;
 +				attr->out_rep[attr->out_count] = rpriv->rep;
 +				attr->out_mdev[attr->out_count++] = out_priv->mdev;
  			} else if (encap) {
 -				parse_attr->mirred_ifindex[attr->out_count] =
 -					out_dev->ifindex;
 -				parse_attr->tun_info[attr->out_count] = *info;
 -				encap = false;
 +				parse_attr->mirred_ifindex = out_dev->ifindex;
 +				parse_attr->tun_info = *info;
  				attr->parse_attr = parse_attr;
 -				attr->dests[attr->out_count].flags |=
 -					MLX5_ESW_DEST_ENCAP;
 -				attr->out_count++;
 -				/* attr->dests[].rep is resolved when we
 -				 * handle encap
 -				 */
 -			} else if (parse_attr->filter_dev != priv->netdev) {
 -				/* All mlx5 devices are called to configure
 -				 * high level device filters. Therefore, the
 -				 * *attempt* to  install a filter on invalid
 -				 * eswitch should not trigger an explicit error
 -				 */
 -				return -EINVAL;
 +				action |= MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT |
 +					  MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +					  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +				/* attr->out_rep is resolved when we handle encap */
  			} else {
 -				NL_SET_ERR_MSG_MOD(extack,
 -						   "devices are not on same switch HW, can't offload forwarding");
  				pr_err("devices %s %s not on same switch HW, can't offload forwarding\n",
  				       priv->netdev->name, out_dev->name);
  				return -EINVAL;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
