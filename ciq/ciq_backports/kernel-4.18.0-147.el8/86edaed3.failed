bpf: libbpf: retry loading program on EAGAIN

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Lorenz Bauer <lmb@cloudflare.com>
commit 86edaed379632e216a97e6bcef9f498b64522d50
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/86edaed3.failed

Commit c3494801cd17 ("bpf: check pending signals while
verifying programs") makes it possible for the BPF_PROG_LOAD
to fail with EAGAIN. Retry unconditionally in this case.

Fixes: c3494801cd17 ("bpf: check pending signals while verifying programs")
	Signed-off-by: Lorenz Bauer <lmb@cloudflare.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit 86edaed379632e216a97e6bcef9f498b64522d50)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/bpf.c
diff --cc tools/lib/bpf/bpf.c
index 2accecf0ac8f,88cbd110ae58..000000000000
--- a/tools/lib/bpf/bpf.c
+++ b/tools/lib/bpf/bpf.c
@@@ -211,16 -240,65 +222,73 @@@ int bpf_load_program_xattr(const struc
  	memcpy(attr.prog_name, load_attr->name,
  	       min(name_len, BPF_OBJ_NAME_LEN - 1));
  
++<<<<<<< HEAD
 +	fd = sys_bpf(BPF_PROG_LOAD, &attr, sizeof(attr));
 +	if (fd >= 0 || !log_buf || !log_buf_sz)
 +		return fd;
 +
++=======
+ 	fd = sys_bpf_prog_load(&attr, sizeof(attr));
+ 	if (fd >= 0)
+ 		return fd;
+ 
+ 	/* After bpf_prog_load, the kernel may modify certain attributes
+ 	 * to give user space a hint how to deal with loading failure.
+ 	 * Check to see whether we can make some changes and load again.
+ 	 */
+ 	while (errno == E2BIG && (!finfo || !linfo)) {
+ 		if (!finfo && attr.func_info_cnt &&
+ 		    attr.func_info_rec_size < load_attr->func_info_rec_size) {
+ 			/* try with corrected func info records */
+ 			finfo = alloc_zero_tailing_info(load_attr->func_info,
+ 							load_attr->func_info_cnt,
+ 							load_attr->func_info_rec_size,
+ 							attr.func_info_rec_size);
+ 			if (!finfo)
+ 				goto done;
+ 
+ 			attr.func_info = ptr_to_u64(finfo);
+ 			attr.func_info_rec_size = load_attr->func_info_rec_size;
+ 		} else if (!linfo && attr.line_info_cnt &&
+ 			   attr.line_info_rec_size <
+ 			   load_attr->line_info_rec_size) {
+ 			linfo = alloc_zero_tailing_info(load_attr->line_info,
+ 							load_attr->line_info_cnt,
+ 							load_attr->line_info_rec_size,
+ 							attr.line_info_rec_size);
+ 			if (!linfo)
+ 				goto done;
+ 
+ 			attr.line_info = ptr_to_u64(linfo);
+ 			attr.line_info_rec_size = load_attr->line_info_rec_size;
+ 		} else {
+ 			break;
+ 		}
+ 
+ 		fd = sys_bpf_prog_load(&attr, sizeof(attr));
+ 
+ 		if (fd >= 0)
+ 			goto done;
+ 	}
+ 
+ 	if (!log_buf || !log_buf_sz)
+ 		goto done;
+ 
++>>>>>>> 86edaed37963 (bpf: libbpf: retry loading program on EAGAIN)
  	/* Try again with log */
  	attr.log_buf = ptr_to_u64(log_buf);
  	attr.log_size = log_buf_sz;
  	attr.log_level = 1;
  	log_buf[0] = 0;
++<<<<<<< HEAD
 +	return sys_bpf(BPF_PROG_LOAD, &attr, sizeof(attr));
++=======
+ 	fd = sys_bpf_prog_load(&attr, sizeof(attr));
+ done:
+ 	free(finfo);
+ 	free(linfo);
+ 	return fd;
++>>>>>>> 86edaed37963 (bpf: libbpf: retry loading program on EAGAIN)
  }
  
  int bpf_load_program(enum bpf_prog_type type, const struct bpf_insn *insns,
@@@ -259,9 -337,9 +327,9 @@@ int bpf_verify_program(enum bpf_prog_ty
  	attr.log_level = log_level;
  	log_buf[0] = 0;
  	attr.kern_version = kern_version;
 -	attr.prog_flags = prog_flags;
 +	attr.prog_flags = strict_alignment ? BPF_F_STRICT_ALIGNMENT : 0;
  
- 	return sys_bpf(BPF_PROG_LOAD, &attr, sizeof(attr));
+ 	return sys_bpf_prog_load(&attr, sizeof(attr));
  }
  
  int bpf_map_update_elem(int fd, const void *key, const void *value,
* Unmerged path tools/lib/bpf/bpf.c
