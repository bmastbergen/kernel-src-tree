ASoC: simple-scu-card: care multi DPCM codec_conf

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [sound] ALSA: ASoC: simple-scu-card: care multi DPCM codec_conf (Jaroslav Kysela) [1683051]
Rebuild_FUZZ: 94.23%
commit-author Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
commit 0a26d6df4fd8aa8f4fb444446d162e01c3e349c0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/0a26d6df.failed

Current simple-scu-card didn't care about codec_conf
for multi DPCM case. This patch cares it.

	Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 0a26d6df4fd8aa8f4fb444446d162e01c3e349c0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/generic/simple-scu-card.c
diff --cc sound/soc/generic/simple-scu-card.c
index 43df520e787a,9d7299d536a8..000000000000
--- a/sound/soc/generic/simple-scu-card.c
+++ b/sound/soc/generic/simple-scu-card.c
@@@ -21,15 -21,18 +21,16 @@@
  
  struct simple_card_data {
  	struct snd_soc_card snd_card;
- 	struct snd_soc_codec_conf codec_conf;
  	struct simple_dai_props {
 -		struct asoc_simple_dai *cpu_dai;
 -		struct asoc_simple_dai *codec_dai;
 +		struct asoc_simple_dai dai;
  		struct snd_soc_dai_link_component codecs;
  		struct snd_soc_dai_link_component platform;
  		struct asoc_simple_card_data adata;
+ 		struct snd_soc_codec_conf *codec_conf;
  	} *dai_props;
  	struct snd_soc_dai_link *dai_link;
 -	struct asoc_simple_dai *dais;
  	struct asoc_simple_card_data adata;
+ 	struct snd_soc_codec_conf *codec_conf;
  };
  
  #define simple_priv_to_card(priv) (&(priv)->snd_card)
@@@ -101,7 -117,8 +102,12 @@@ static int asoc_simple_card_dai_link_of
  					struct device_node *np,
  					struct device_node *codec,
  					struct simple_card_data *priv,
++<<<<<<< HEAD
 +					int idx, bool is_fe,
++=======
+ 					int *dai_idx, int link_idx,
+ 					int *conf_idx, int is_fe,
++>>>>>>> 0a26d6df4fd8 (ASoC: simple-scu-card: care multi DPCM codec_conf)
  					bool is_top_level_node)
  {
  	struct device *dev = simple_priv_to_dev(priv);
@@@ -155,6 -178,12 +163,15 @@@
  		dai_link->no_pcm		= 1;
  		dai_link->be_hw_params_fixup	= asoc_simple_card_be_hw_params_fixup;
  
++<<<<<<< HEAD
++=======
+ 		dai =
+ 		dai_props->codec_dai	= &priv->dais[(*dai_idx)++];
+ 
+ 		cconf =
+ 		dai_props->codec_conf	= &priv->codec_conf[(*conf_idx)++];
+ 
++>>>>>>> 0a26d6df4fd8 (ASoC: simple-scu-card: care multi DPCM codec_conf)
  		ret = asoc_simple_card_parse_codec(np, dai_link, DAI, CELL);
  		if (ret < 0)
  			return ret;
@@@ -214,9 -242,10 +229,14 @@@ static int asoc_simple_card_parse_of(st
  	struct device_node *codec;
  	struct snd_soc_card *card = simple_priv_to_card(priv);
  	bool is_fe;
++<<<<<<< HEAD
 +	int ret, i;
++=======
+ 	int ret, loop;
+ 	int dai_idx, link_idx, conf_idx;
++>>>>>>> 0a26d6df4fd8 (ASoC: simple-scu-card: care multi DPCM codec_conf)
  
 -	if (!top)
 +	if (!node)
  		return -EINVAL;
  
  	ret = asoc_simple_card_of_parse_widgets(card, PREFIX);
@@@ -227,25 -256,37 +247,57 @@@
  	if (ret < 0)
  		return ret;
  
 -	asoc_simple_card_parse_convert(dev, top, PREFIX, &priv->adata);
 +	asoc_simple_card_parse_convert(dev, node, PREFIX, &priv->adata);
 +
++<<<<<<< HEAD
 +	i = 0;
 +	codec = of_get_child_by_name(node, PREFIX "codec");
 +	if (!codec)
 +		return -ENODEV;
 +
 +	for_each_child_of_node(node, np) {
 +		is_fe = false;
 +		if (strcmp(np->name, PREFIX "cpu") == 0)
 +			is_fe = true;
 +
 +		ret = asoc_simple_card_dai_link_of(node, np, codec, priv,
 +						   i, is_fe, true);
 +		if (ret < 0)
 +			return ret;
 +		i++;
 +	}
  
++=======
+ 	loop = 1;
+ 	link_idx = 0;
+ 	dai_idx = 0;
+ 	conf_idx = 0;
+ 	node = of_get_child_by_name(top, PREFIX "dai-link");
+ 	if (!node) {
+ 		node = dev->of_node;
+ 		loop = 0;
+ 	}
+ 
+ 	do  {
+ 		codec = of_get_child_by_name(node,
+ 					     loop ? "codec" : PREFIX "codec");
+ 		if (!codec)
+ 			return -ENODEV;
+ 
+ 		for_each_child_of_node(node, np) {
+ 			is_fe = (np != codec);
+ 
+ 			ret = asoc_simple_card_dai_link_of(node, np, codec, priv,
+ 							   &dai_idx, link_idx++,
+ 							   &conf_idx,
+ 							   is_fe, !loop);
+ 			if (ret < 0)
+ 				return ret;
+ 		}
+ 		node = of_get_next_child(top, node);
+ 	} while (loop && node);
+ 
++>>>>>>> 0a26d6df4fd8 (ASoC: simple-scu-card: care multi DPCM codec_conf)
  	ret = asoc_simple_card_parse_card_name(card, PREFIX);
  	if (ret < 0)
  		return ret;
@@@ -332,7 -373,9 +384,8 @@@ static int asoc_simple_card_probe(struc
  	struct simple_card_data *priv;
  	struct snd_soc_dai_link *dai_link;
  	struct simple_dai_props *dai_props;
 -	struct asoc_simple_dai *dais;
  	struct snd_soc_card *card;
+ 	struct snd_soc_codec_conf *cconf;
  	struct device *dev = &pdev->dev;
  	int ret, i;
  	int lnum = 0, dnum = 0, cnum = 0;
@@@ -348,7 -391,9 +401,13 @@@
  
  	dai_props = devm_kcalloc(dev, lnum, sizeof(*dai_props), GFP_KERNEL);
  	dai_link  = devm_kcalloc(dev, lnum, sizeof(*dai_link), GFP_KERNEL);
++<<<<<<< HEAD
 +	if (!dai_props || !dai_link)
++=======
+ 	dais      = devm_kcalloc(dev, dnum, sizeof(*dais),      GFP_KERNEL);
+ 	cconf     = devm_kcalloc(dev, cnum, sizeof(*cconf),     GFP_KERNEL);
+ 	if (!dai_props || !dai_link || !dais)
++>>>>>>> 0a26d6df4fd8 (ASoC: simple-scu-card: care multi DPCM codec_conf)
  		return -ENOMEM;
  
  	/*
@@@ -365,6 -410,8 +424,11 @@@
  
  	priv->dai_props				= dai_props;
  	priv->dai_link				= dai_link;
++<<<<<<< HEAD
++=======
+ 	priv->dais				= dais;
+ 	priv->codec_conf			= cconf;
++>>>>>>> 0a26d6df4fd8 (ASoC: simple-scu-card: care multi DPCM codec_conf)
  
  	/* Init snd_soc_card */
  	card = simple_priv_to_card(priv);
* Unmerged path sound/soc/generic/simple-scu-card.c
