fanotify: support reporting thread id instead of process id

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Amir Goldstein <amir73il@gmail.com>
commit d0a6a87e40da49cfc7954c491d3065a25a641b29
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/d0a6a87e.failed

In order to identify which thread triggered the event in a
multi-threaded program, add the FAN_REPORT_TID flag in fanotify_init to
opt-in for reporting the event creator's thread id information.

	Signed-off-by: nixiaoming <nixiaoming@huawei.com>
	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
(cherry picked from commit d0a6a87e40da49cfc7954c491d3065a25a641b29)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/notify/fanotify/fanotify_user.c
#	include/linux/fanotify.h
#	include/uapi/linux/fanotify.h
diff --cc fs/notify/fanotify/fanotify_user.c
index 5c361e628c83,e03be5071362..000000000000
--- a/fs/notify/fanotify/fanotify_user.c
+++ b/fs/notify/fanotify/fanotify_user.c
@@@ -130,8 -131,8 +130,13 @@@ static int fill_event_metadata(struct f
  	metadata->metadata_len = FAN_EVENT_METADATA_LEN;
  	metadata->vers = FANOTIFY_METADATA_VERSION;
  	metadata->reserved = 0;
++<<<<<<< HEAD
 +	metadata->mask = fsn_event->mask & FAN_ALL_OUTGOING_EVENTS;
 +	metadata->pid = pid_vnr(event->tgid);
++=======
+ 	metadata->mask = fsn_event->mask & FANOTIFY_OUTGOING_EVENTS;
+ 	metadata->pid = pid_vnr(event->pid);
++>>>>>>> d0a6a87e40da (fanotify: support reporting thread id instead of process id)
  	if (unlikely(fsn_event->mask & FAN_Q_OVERFLOW))
  		metadata->fd = FAN_NOFD;
  	else {
@@@ -960,7 -944,11 +965,15 @@@ COMPAT_SYSCALL_DEFINE6(fanotify_mark
   */
  static int __init fanotify_user_setup(void)
  {
++<<<<<<< HEAD
 +	fanotify_mark_cache = KMEM_CACHE(fsnotify_mark, SLAB_PANIC);
++=======
+ 	BUILD_BUG_ON(HWEIGHT32(FANOTIFY_INIT_FLAGS) != 7);
+ 	BUILD_BUG_ON(HWEIGHT32(FANOTIFY_MARK_FLAGS) != 9);
+ 
+ 	fanotify_mark_cache = KMEM_CACHE(fsnotify_mark,
+ 					 SLAB_PANIC|SLAB_ACCOUNT);
++>>>>>>> d0a6a87e40da (fanotify: support reporting thread id instead of process id)
  	fanotify_event_cachep = KMEM_CACHE(fanotify_event_info, SLAB_PANIC);
  	if (IS_ENABLED(CONFIG_FANOTIFY_ACCESS_PERMISSIONS)) {
  		fanotify_perm_event_cachep =
diff --cc include/linux/fanotify.h
index e70fccc3757e,a5a60691e48b..000000000000
--- a/include/linux/fanotify.h
+++ b/include/linux/fanotify.h
@@@ -10,4 -7,58 +10,61 @@@
  #define FAN_GROUP_FLAG(group, flag) \
  	((group)->fanotify_data.flags & (flag))
  
++<<<<<<< HEAD
++=======
+ /*
+  * Flags allowed to be passed from/to userspace.
+  *
+  * We intentionally do not add new bits to the old FAN_ALL_* constants, because
+  * they are uapi exposed constants. If there are programs out there using
+  * these constant, the programs may break if re-compiled with new uapi headers
+  * and then run on an old kernel.
+  */
+ #define FANOTIFY_CLASS_BITS	(FAN_CLASS_NOTIF | FAN_CLASS_CONTENT | \
+ 				 FAN_CLASS_PRE_CONTENT)
+ 
+ #define FANOTIFY_INIT_FLAGS	(FANOTIFY_CLASS_BITS | \
+ 				 FAN_REPORT_TID | \
+ 				 FAN_CLOEXEC | FAN_NONBLOCK | \
+ 				 FAN_UNLIMITED_QUEUE | FAN_UNLIMITED_MARKS)
+ 
+ #define FANOTIFY_MARK_TYPE_BITS	(FAN_MARK_INODE | FAN_MARK_MOUNT | \
+ 				 FAN_MARK_FILESYSTEM)
+ 
+ #define FANOTIFY_MARK_FLAGS	(FANOTIFY_MARK_TYPE_BITS | \
+ 				 FAN_MARK_ADD | \
+ 				 FAN_MARK_REMOVE | \
+ 				 FAN_MARK_DONT_FOLLOW | \
+ 				 FAN_MARK_ONLYDIR | \
+ 				 FAN_MARK_IGNORED_MASK | \
+ 				 FAN_MARK_IGNORED_SURV_MODIFY | \
+ 				 FAN_MARK_FLUSH)
+ 
+ /* Events that user can request to be notified on */
+ #define FANOTIFY_EVENTS		(FAN_ACCESS | FAN_MODIFY | \
+ 				 FAN_CLOSE | FAN_OPEN)
+ 
+ /* Events that require a permission response from user */
+ #define FANOTIFY_PERM_EVENTS	(FAN_OPEN_PERM | FAN_ACCESS_PERM)
+ 
+ /* Extra flags that may be reported with event or control handling of events */
+ #define FANOTIFY_EVENT_FLAGS	(FAN_EVENT_ON_CHILD | FAN_ONDIR)
+ 
+ /* Events that may be reported to user */
+ #define FANOTIFY_OUTGOING_EVENTS	(FANOTIFY_EVENTS | \
+ 					 FANOTIFY_PERM_EVENTS | \
+ 					 FAN_Q_OVERFLOW)
+ 
+ #define ALL_FANOTIFY_EVENT_BITS		(FANOTIFY_OUTGOING_EVENTS | \
+ 					 FANOTIFY_EVENT_FLAGS)
+ 
+ /* Do not use these old uapi constants internally */
+ #undef FAN_ALL_CLASS_BITS
+ #undef FAN_ALL_INIT_FLAGS
+ #undef FAN_ALL_MARK_FLAGS
+ #undef FAN_ALL_EVENTS
+ #undef FAN_ALL_PERM_EVENTS
+ #undef FAN_ALL_OUTGOING_EVENTS
+ 
++>>>>>>> d0a6a87e40da (fanotify: support reporting thread id instead of process id)
  #endif /* _LINUX_FANOTIFY_H */
diff --cc include/uapi/linux/fanotify.h
index 74247917de04,b86740d1c50a..000000000000
--- a/include/uapi/linux/fanotify.h
+++ b/include/uapi/linux/fanotify.h
@@@ -38,6 -40,10 +38,13 @@@
  #define FAN_UNLIMITED_MARKS	0x00000020
  #define FAN_ENABLE_AUDIT	0x00000040
  
++<<<<<<< HEAD
++=======
+ /* Flags to determine fanotify event format */
+ #define FAN_REPORT_TID		0x00000100	/* event->pid is thread id */
+ 
+ /* Deprecated - do not use this in programs and do not add new flags here! */
++>>>>>>> d0a6a87e40da (fanotify: support reporting thread id instead of process id)
  #define FAN_ALL_INIT_FLAGS	(FAN_CLOEXEC | FAN_NONBLOCK | \
  				 FAN_ALL_CLASS_BITS | FAN_UNLIMITED_QUEUE |\
  				 FAN_UNLIMITED_MARKS)
diff --git a/fs/notify/fanotify/fanotify.c b/fs/notify/fanotify/fanotify.c
index cdce46db0d71..1967e8916742 100644
--- a/fs/notify/fanotify/fanotify.c
+++ b/fs/notify/fanotify/fanotify.c
@@ -24,7 +24,7 @@ static bool should_merge(struct fsnotify_event *old_fsn,
 	old = FANOTIFY_E(old_fsn);
 	new = FANOTIFY_E(new_fsn);
 
-	if (old_fsn->inode == new_fsn->inode && old->tgid == new->tgid &&
+	if (old_fsn->inode == new_fsn->inode && old->pid == new->pid &&
 	    old->path.mnt == new->path.mnt &&
 	    old->path.dentry == new->path.dentry)
 		return true;
@@ -167,7 +167,10 @@ struct fanotify_event_info *fanotify_alloc_event(struct fsnotify_group *group,
 		return NULL;
 init: __maybe_unused
 	fsnotify_init_event(&event->fse, inode, mask);
-	event->tgid = get_pid(task_tgid(current));
+	if (FAN_GROUP_FLAG(group, FAN_REPORT_TID))
+		event->pid = get_pid(task_pid(current));
+	else
+		event->pid = get_pid(task_tgid(current));
 	if (path) {
 		event->path = *path;
 		path_get(&event->path);
@@ -262,7 +265,7 @@ static void fanotify_free_event(struct fsnotify_event *fsn_event)
 
 	event = FANOTIFY_E(fsn_event);
 	path_put(&event->path);
-	put_pid(event->tgid);
+	put_pid(event->pid);
 	if (fanotify_is_perm_event(fsn_event->mask)) {
 		kmem_cache_free(fanotify_perm_event_cachep,
 				FANOTIFY_PE(fsn_event));
diff --git a/fs/notify/fanotify/fanotify.h b/fs/notify/fanotify/fanotify.h
index 8609ba06f474..d8d85104e7ff 100644
--- a/fs/notify/fanotify/fanotify.h
+++ b/fs/notify/fanotify/fanotify.h
@@ -19,7 +19,7 @@ struct fanotify_event_info {
 	 * during this object's lifetime
 	 */
 	struct path path;
-	struct pid *tgid;
+	struct pid *pid;
 };
 
 /*
* Unmerged path fs/notify/fanotify/fanotify_user.c
* Unmerged path include/linux/fanotify.h
* Unmerged path include/uapi/linux/fanotify.h
