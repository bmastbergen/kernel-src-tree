IB/mlx5: DEVX handling for indirection MKEY

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Yishai Hadas <yishaih@mellanox.com>
commit fa31f14380bea60ccc9d7a314e0cb61f6984627f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/fa31f143.failed

Once an indirection MKEY is created umem valid bit shouldn't be set as
this MKEY doesn't really hold a umem.

	Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
	Reviewed-by: Artemy Kovalyov <artemyko@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit fa31f14380bea60ccc9d7a314e0cb61f6984627f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/devx.c
diff --cc drivers/infiniband/hw/mlx5/devx.c
index c7f8859c08ee,b7ff2138ac2a..000000000000
--- a/drivers/infiniband/hw/mlx5/devx.c
+++ b/drivers/infiniband/hw/mlx5/devx.c
@@@ -380,38 -1058,54 +406,50 @@@ static int UVERBS_HANDLER(MLX5_IB_METHO
  	void *cmd_in = uverbs_attr_get_alloced_ptr(attrs, MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_IN);
  	int cmd_out_len =  uverbs_attr_get_len(attrs,
  					MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_OUT);
+ 	int cmd_in_len = uverbs_attr_get_len(attrs,
+ 					MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_IN);
  	void *cmd_out;
 -	struct ib_uobject *uobj = uverbs_attr_get_uobject(
 -		attrs, MLX5_IB_ATTR_DEVX_OBJ_CREATE_HANDLE);
 -	struct mlx5_ib_ucontext *c = to_mucontext(uobj->context);
 -	struct mlx5_ib_dev *dev = to_mdev(c->ibucontext.device);
 -	u32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)];
 +	struct ib_uobject *uobj;
  	struct devx_obj *obj;
  	int err;
 -	int uid;
 -	u32 obj_id;
 -	u16 opcode;
  
 -	uid = devx_get_uid(c, cmd_in);
 -	if (uid < 0)
 -		return uid;
 +	if (!c->devx_uid)
 +		return -EPERM;
  
 -	if (!devx_is_obj_create_cmd(cmd_in, &opcode))
 +	if (!devx_is_obj_create_cmd(cmd_in))
  		return -EINVAL;
  
 -	cmd_out = uverbs_zalloc(attrs, cmd_out_len);
 -	if (IS_ERR(cmd_out))
 -		return PTR_ERR(cmd_out);
 -
  	obj = kzalloc(sizeof(struct devx_obj), GFP_KERNEL);
  	if (!obj)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	cmd_out = kvzalloc(cmd_out_len, GFP_KERNEL);
 +	if (!cmd_out) {
 +		err = -ENOMEM;
 +		goto obj_free;
++=======
+ 	MLX5_SET(general_obj_in_cmd_hdr, cmd_in, uid, uid);
+ 	if (opcode == MLX5_CMD_OP_CREATE_MKEY) {
+ 		err = devx_handle_mkey_create(dev, obj, cmd_in, cmd_in_len);
+ 		if (err)
+ 			goto obj_free;
+ 	} else {
+ 		devx_set_umem_valid(cmd_in);
++>>>>>>> fa31f14380be (IB/mlx5: DEVX handling for indirection MKEY)
  	}
  
 +	MLX5_SET(general_obj_in_cmd_hdr, cmd_in, uid, c->devx_uid);
  	err = mlx5_cmd_exec(dev->mdev, cmd_in,
- 			    uverbs_attr_get_len(attrs, MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_IN),
+ 			    cmd_in_len,
  			    cmd_out, cmd_out_len);
  	if (err)
 -		goto obj_free;
 +		goto cmd_free;
  
 +	uobj = uverbs_attr_get_uobject(attrs, MLX5_IB_ATTR_DEVX_OBJ_CREATE_HANDLE);
  	uobj->object = obj;
  	obj->mdev = dev->mdev;
 -	devx_obj_build_destroy_cmd(cmd_in, cmd_out, obj->dinbox, &obj->dinlen,
 -				   &obj_id);
 +	devx_obj_build_destroy_cmd(cmd_in, cmd_out, obj->dinbox, &obj->dinlen, &obj->obj_id);
  	WARN_ON(obj->dinlen > MLX5_MAX_DESTROY_INBOX_SIZE_DW * sizeof(u32));
  
  	err = uverbs_copy_to(attrs, MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_OUT, cmd_out, cmd_out_len);
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
