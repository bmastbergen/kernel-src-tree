net: IP6 defrag: use rbtrees in nf_conntrack_reasm.c

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [net] IP6 defrag: use rbtrees in nf_conntrack_reasm.c (Guillaume Nault) [1660282]
Rebuild_FUZZ: 94.95%
commit-author Peter Oskolkov <posk@google.com>
commit 997dd96471641e147cb2c33ad54284000d0f5e35
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/997dd964.failed

Currently, IPv6 defragmentation code drops non-last fragments that
are smaller than 1280 bytes: see
commit 0ed4229b08c1 ("ipv6: defrag: drop non-last frags smaller than min mtu")

This behavior is not specified in IPv6 RFCs and appears to break
compatibility with some IPv6 implemenations, as reported here:
https://www.spinics.net/lists/netdev/msg543846.html

This patch re-uses common IP defragmentation queueing and reassembly
code in IP6 defragmentation in nf_conntrack, removing the 1280 byte
restriction.

	Signed-off-by: Peter Oskolkov <posk@google.com>
	Reported-by: Tom Herbert <tom@herbertland.com>
	Cc: Eric Dumazet <edumazet@google.com>
	Cc: Florian Westphal <fw@strlen.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 997dd96471641e147cb2c33ad54284000d0f5e35)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/netfilter/nf_conntrack_reasm.c
diff --cc net/ipv6/netfilter/nf_conntrack_reasm.c
index 043ed8eb0ab9,cb1b4772dac0..000000000000
--- a/net/ipv6/netfilter/nf_conntrack_reasm.c
+++ b/net/ipv6/netfilter/nf_conntrack_reasm.c
@@@ -433,41 -343,27 +343,37 @@@ static int nf_ct_frag6_reasm(struct fra
  
  	/* We have to remove fragment header from datagram and to relocate
  	 * header in order to calculate ICV correctly. */
- 	skb_network_header(head)[fq->nhoffset] = skb_transport_header(head)[0];
- 	memmove(head->head + sizeof(struct frag_hdr), head->head,
- 		(head->data - head->head) - sizeof(struct frag_hdr));
- 	head->mac_header += sizeof(struct frag_hdr);
- 	head->network_header += sizeof(struct frag_hdr);
- 
- 	skb_shinfo(head)->frag_list = head->next;
- 	skb_reset_transport_header(head);
- 	skb_push(head, head->data - skb_network_header(head));
- 
- 	for (fp = head->next; fp; fp = fp->next) {
- 		head->data_len += fp->len;
- 		head->len += fp->len;
- 		if (head->ip_summed != fp->ip_summed)
- 			head->ip_summed = CHECKSUM_NONE;
- 		else if (head->ip_summed == CHECKSUM_COMPLETE)
- 			head->csum = csum_add(head->csum, fp->csum);
- 		head->truesize += fp->truesize;
- 		fp->sk = NULL;
- 	}
- 	sub_frag_mem_limit(fq->q.net, head->truesize);
+ 	skb_network_header(skb)[fq->nhoffset] = skb_transport_header(skb)[0];
+ 	memmove(skb->head + sizeof(struct frag_hdr), skb->head,
+ 		(skb->data - skb->head) - sizeof(struct frag_hdr));
+ 	skb->mac_header += sizeof(struct frag_hdr);
+ 	skb->network_header += sizeof(struct frag_hdr);
+ 
+ 	skb_reset_transport_header(skb);
  
+ 	inet_frag_reasm_finish(&fq->q, skb, reasm_data);
+ 
++<<<<<<< HEAD
 +	head->ignore_df = 1;
 +	head->next = NULL;
 +	head->dev = dev;
 +	head->tstamp = fq->q.stamp;
 +	ipv6_hdr(head)->payload_len = htons(payload_len);
 +	ipv6_change_dsfield(ipv6_hdr(head), 0xff, ecn);
 +	IP6CB(head)->frag_max_size = sizeof(struct ipv6hdr) + fq->q.max_size;
++=======
+ 	skb->ignore_df = 1;
+ 	skb->dev = dev;
+ 	ipv6_hdr(skb)->payload_len = htons(payload_len);
+ 	ipv6_change_dsfield(ipv6_hdr(skb), 0xff, ecn);
+ 	IP6CB(skb)->frag_max_size = sizeof(struct ipv6hdr) + fq->q.max_size;
++>>>>>>> 997dd9647164 (net: IP6 defrag: use rbtrees in nf_conntrack_reasm.c)
  
  	/* Yes, and fold redundant checksum back. 8) */
- 	if (head->ip_summed == CHECKSUM_COMPLETE)
- 		head->csum = csum_partial(skb_network_header(head),
- 					  skb_network_header_len(head),
- 					  head->csum);
+ 	if (skb->ip_summed == CHECKSUM_COMPLETE)
+ 		skb->csum = csum_partial(skb_network_header(skb),
+ 					 skb_network_header_len(skb),
+ 					 skb->csum);
  
  	fq->q.fragments = NULL;
  	fq->q.rb_fragments = RB_ROOT;
* Unmerged path net/ipv6/netfilter/nf_conntrack_reasm.c
