x86/intel_rdt: Move pseudo_lock_region_clear()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Reinette Chatre <reinette.chatre@intel.com>
commit ce730f1cc1255be152c879a2bc5f295d341d8036
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/ce730f1c.failed

The pseudo_lock_region_clear() function is moved to earlier in the file in
preparation for its use in functions that currently appear before it. No
functional change.

	Signed-off-by: Reinette Chatre <reinette.chatre@intel.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: fenghua.yu@intel.com
	Cc: tony.luck@intel.com
	Cc: vikas.shivappa@linux.intel.com
	Cc: gavin.hindman@intel.com
	Cc: jithu.joseph@intel.com
	Cc: dave.hansen@intel.com
	Cc: hpa@zytor.com
Link: https://lkml.kernel.org/r/ef098ec2a45501e23792289bff80ae3152141e2f.1530421026.git.reinette.chatre@intel.com

(cherry picked from commit ce730f1cc1255be152c879a2bc5f295d341d8036)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/intel_rdt_pseudo_lock.c
diff --cc arch/x86/kernel/cpu/intel_rdt_pseudo_lock.c
index dd1341557c9d,1860ec10302d..000000000000
--- a/arch/x86/kernel/cpu/intel_rdt_pseudo_lock.c
+++ b/arch/x86/kernel/cpu/intel_rdt_pseudo_lock.c
@@@ -176,6 -177,99 +176,102 @@@ static struct rdtgroup *region_find_by_
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * pseudo_lock_pm_req - A power management QoS request list entry
+  * @list:	Entry within the @pm_reqs list for a pseudo-locked region
+  * @req:	PM QoS request
+  */
+ struct pseudo_lock_pm_req {
+ 	struct list_head list;
+ 	struct dev_pm_qos_request req;
+ };
+ 
+ static void pseudo_lock_cstates_relax(struct pseudo_lock_region *plr)
+ {
+ 	struct pseudo_lock_pm_req *pm_req, *next;
+ 
+ 	list_for_each_entry_safe(pm_req, next, &plr->pm_reqs, list) {
+ 		dev_pm_qos_remove_request(&pm_req->req);
+ 		list_del(&pm_req->list);
+ 		kfree(pm_req);
+ 	}
+ }
+ 
+ /**
+  * pseudo_lock_cstates_constrain - Restrict cores from entering C6
+  *
+  * To prevent the cache from being affected by power management entering
+  * C6 has to be avoided. This is accomplished by requesting a latency
+  * requirement lower than lowest C6 exit latency of all supported
+  * platforms as found in the cpuidle state tables in the intel_idle driver.
+  * At this time it is possible to do so with a single latency requirement
+  * for all supported platforms.
+  *
+  * Since Goldmont is supported, which is affected by X86_BUG_MONITOR,
+  * the ACPI latencies need to be considered while keeping in mind that C2
+  * may be set to map to deeper sleep states. In this case the latency
+  * requirement needs to prevent entering C2 also.
+  */
+ static int pseudo_lock_cstates_constrain(struct pseudo_lock_region *plr)
+ {
+ 	struct pseudo_lock_pm_req *pm_req;
+ 	int cpu;
+ 	int ret;
+ 
+ 	for_each_cpu(cpu, &plr->d->cpu_mask) {
+ 		pm_req = kzalloc(sizeof(*pm_req), GFP_KERNEL);
+ 		if (!pm_req) {
+ 			rdt_last_cmd_puts("fail allocating mem for PM QoS\n");
+ 			ret = -ENOMEM;
+ 			goto out_err;
+ 		}
+ 		ret = dev_pm_qos_add_request(get_cpu_device(cpu),
+ 					     &pm_req->req,
+ 					     DEV_PM_QOS_RESUME_LATENCY,
+ 					     30);
+ 		if (ret < 0) {
+ 			rdt_last_cmd_printf("fail to add latency req cpu%d\n",
+ 					    cpu);
+ 			kfree(pm_req);
+ 			ret = -1;
+ 			goto out_err;
+ 		}
+ 		list_add(&pm_req->list, &plr->pm_reqs);
+ 	}
+ 
+ 	return 0;
+ 
+ out_err:
+ 	pseudo_lock_cstates_relax(plr);
+ 	return ret;
+ }
+ 
+ /**
+  * pseudo_lock_region_clear - Reset pseudo-lock region data
+  * @plr: pseudo-lock region
+  *
+  * All content of the pseudo-locked region is reset - any memory allocated
+  * freed.
+  *
+  * Return: void
+  */
+ static void pseudo_lock_region_clear(struct pseudo_lock_region *plr)
+ {
+ 	plr->size = 0;
+ 	plr->line_size = 0;
+ 	kfree(plr->kmem);
+ 	plr->kmem = NULL;
+ 	plr->r = NULL;
+ 	if (plr->d)
+ 		plr->d->plr = NULL;
+ 	plr->d = NULL;
+ 	plr->cbm = 0;
+ 	plr->debugfs_dir = NULL;
+ }
+ 
+ /**
++>>>>>>> ce730f1cc125 (x86/intel_rdt: Move pseudo_lock_region_clear())
   * pseudo_lock_region_init - Initialize pseudo-lock region information
   * @plr: pseudo-lock region
   *
* Unmerged path arch/x86/kernel/cpu/intel_rdt_pseudo_lock.c
