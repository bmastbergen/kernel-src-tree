mlxsw: spectrum_acl: Introduce a mutex to guard region list updates

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jiri Pirko <jiri@mellanox.com>
commit 5ec2ee28d27b9232d1cae08ec597b9f3464fd8be
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/5ec2ee28.failed

In order to remove RTNL lock dependency, it is needed to protect
the regions list in a group. Introduce a mutex to do the job.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5ec2ee28d27b9232d1cae08ec597b9f3464fd8be)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
index c607c62a43ae,21ebda19a2ad..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
@@@ -8,6 -8,8 +8,11 @@@
  #include <linux/list.h>
  #include <linux/rhashtable.h>
  #include <linux/netdevice.h>
++<<<<<<< HEAD
++=======
+ #include <linux/mutex.h>
+ #include <trace/events/mlxsw.h>
++>>>>>>> 5ec2ee28d27b (mlxsw: spectrum_acl: Introduce a mutex to guard region list updates)
  
  #include "reg.h"
  #include "core.h"
@@@ -153,8 -162,14 +158,18 @@@ struct mlxsw_sp_acl_tcam_pattern 
  struct mlxsw_sp_acl_tcam_group {
  	struct mlxsw_sp_acl_tcam *tcam;
  	u16 id;
++<<<<<<< HEAD
++=======
+ 	struct mutex lock; /* guards region list updates */
+ 	struct list_head region_list;
+ 	unsigned int region_count;
+ };
+ 
+ struct mlxsw_sp_acl_tcam_vgroup {
+ 	struct mlxsw_sp_acl_tcam_group group;
++>>>>>>> 5ec2ee28d27b (mlxsw: spectrum_acl: Introduce a mutex to guard region list updates)
  	struct list_head vregion_list;
 +	unsigned int region_count;
  	struct rhashtable vchunk_ht;
  	const struct mlxsw_sp_acl_tcam_pattern *patterns;
  	unsigned int patterns_count;
@@@ -232,19 -261,49 +247,64 @@@ mlxsw_sp_acl_tcam_group_add(struct mlxs
  	int err;
  
  	group->tcam = tcam;
++<<<<<<< HEAD
 +	group->patterns = patterns;
 +	group->patterns_count = patterns_count;
 +	if (tmplt_elusage) {
 +		group->tmplt_elusage_set = true;
 +		memcpy(&group->tmplt_elusage, tmplt_elusage,
 +		       sizeof(group->tmplt_elusage));
 +	}
 +	INIT_LIST_HEAD(&group->vregion_list);
++=======
+ 	mutex_init(&group->lock);
+ 	INIT_LIST_HEAD(&group->region_list);
+ 
++>>>>>>> 5ec2ee28d27b (mlxsw: spectrum_acl: Introduce a mutex to guard region list updates)
  	err = mlxsw_sp_acl_tcam_group_id_get(tcam, &group->id);
  	if (err)
  		return err;
  
++<<<<<<< HEAD
 +	err = rhashtable_init(&group->vchunk_ht,
++=======
+ 	return 0;
+ }
+ 
+ static void mlxsw_sp_acl_tcam_group_del(struct mlxsw_sp_acl_tcam_group *group)
+ {
+ 	struct mlxsw_sp_acl_tcam *tcam = group->tcam;
+ 
+ 	mutex_destroy(&group->lock);
+ 	mlxsw_sp_acl_tcam_group_id_put(tcam, group->id);
+ 	WARN_ON(!list_empty(&group->region_list));
+ }
+ 
+ static int
+ mlxsw_sp_acl_tcam_vgroup_add(struct mlxsw_sp *mlxsw_sp,
+ 			     struct mlxsw_sp_acl_tcam *tcam,
+ 			     struct mlxsw_sp_acl_tcam_vgroup *vgroup,
+ 			     const struct mlxsw_sp_acl_tcam_pattern *patterns,
+ 			     unsigned int patterns_count,
+ 			     struct mlxsw_afk_element_usage *tmplt_elusage)
+ {
+ 	int err;
+ 
+ 	vgroup->patterns = patterns;
+ 	vgroup->patterns_count = patterns_count;
+ 	if (tmplt_elusage) {
+ 		vgroup->tmplt_elusage_set = true;
+ 		memcpy(&vgroup->tmplt_elusage, tmplt_elusage,
+ 		       sizeof(vgroup->tmplt_elusage));
+ 	}
+ 	INIT_LIST_HEAD(&vgroup->vregion_list);
+ 
+ 	err = mlxsw_sp_acl_tcam_group_add(tcam, &vgroup->group);
+ 	if (err)
+ 		return err;
+ 
+ 	err = rhashtable_init(&vgroup->vchunk_ht,
++>>>>>>> 5ec2ee28d27b (mlxsw: spectrum_acl: Introduce a mutex to guard region list updates)
  			      &mlxsw_sp_acl_tcam_vchunk_ht_params);
  	if (err)
  		goto err_rhashtable_init;
@@@ -329,30 -386,63 +389,49 @@@ mlxsw_sp_acl_tcam_vregion_max_prio(stru
  
  static int
  mlxsw_sp_acl_tcam_group_region_attach(struct mlxsw_sp *mlxsw_sp,
 -				      struct mlxsw_sp_acl_tcam_group *group,
 -				      struct mlxsw_sp_acl_tcam_region *region,
 -				      struct mlxsw_sp_acl_tcam_region *next_region)
 +				      struct mlxsw_sp_acl_tcam_region *region)
  {
 -	struct mlxsw_sp_acl_tcam_region *region2;
 -	struct list_head *pos;
 +	struct mlxsw_sp_acl_tcam_group *group = region->vregion->group;
  	int err;
  
- 	if (group->region_count == group->tcam->max_group_size)
- 		return -ENOBUFS;
+ 	mutex_lock(&group->lock);
+ 	if (group->region_count == group->tcam->max_group_size) {
+ 		err = -ENOBUFS;
+ 		goto err_region_count_check;
+ 	}
  
 -	if (next_region) {
 -		/* If the next region is defined, place the new one
 -		 * before it. The next one is a sibling.
 -		 */
 -		pos = &next_region->list;
 -	} else {
 -		/* Position the region inside the list according to priority */
 -		list_for_each(pos, &group->region_list) {
 -			region2 = list_entry(pos, typeof(*region2), list);
 -			if (mlxsw_sp_acl_tcam_vregion_prio(region2->vregion) >
 -			    mlxsw_sp_acl_tcam_vregion_prio(region->vregion))
 -				break;
 -		}
 -	}
 -	list_add_tail(&region->list, pos);
 -	region->group = group;
 -
  	err = mlxsw_sp_acl_tcam_group_update(mlxsw_sp, group);
  	if (err)
 -		goto err_group_update;
 +		return err;
  
  	group->region_count++;
+ 	mutex_unlock(&group->lock);
  	return 0;
++<<<<<<< HEAD
++=======
+ 
+ err_group_update:
+ 	list_del(&region->list);
+ err_region_count_check:
+ 	mutex_unlock(&group->lock);
+ 	return err;
++>>>>>>> 5ec2ee28d27b (mlxsw: spectrum_acl: Introduce a mutex to guard region list updates)
  }
  
  static void
  mlxsw_sp_acl_tcam_group_region_detach(struct mlxsw_sp *mlxsw_sp,
  				      struct mlxsw_sp_acl_tcam_region *region)
  {
 -	struct mlxsw_sp_acl_tcam_group *group = region->group;
 +	struct mlxsw_sp_acl_tcam_group *group = region->vregion->group;
  
++<<<<<<< HEAD
++=======
+ 	mutex_lock(&group->lock);
+ 	list_del(&region->list);
++>>>>>>> 5ec2ee28d27b (mlxsw: spectrum_acl: Introduce a mutex to guard region list updates)
  	group->region_count--;
  	mlxsw_sp_acl_tcam_group_update(mlxsw_sp, group);
+ 	mutex_unlock(&group->lock);
  }
  
  static int
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
