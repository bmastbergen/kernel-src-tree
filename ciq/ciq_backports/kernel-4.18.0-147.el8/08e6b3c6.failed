libnvdimm: Introduce locked DIMM capacity support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Dan Williams <dan.j.williams@intel.com>
commit 08e6b3c6e3a054f566367740c94b8c1d18e52056
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/08e6b3c6.failed

When a DIMM is locked its namespace label area may not be. Introduce the
distinction of locked namespaces to allow namespace enumeration while
the capacity is locked.

	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 08e6b3c6e3a054f566367740c94b8c1d18e52056)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvdimm/dimm.c
diff --cc drivers/nvdimm/dimm.c
index 1555c3d54980,6c8fb7590838..000000000000
--- a/drivers/nvdimm/dimm.c
+++ b/drivers/nvdimm/dimm.c
@@@ -54,7 -69,13 +69,17 @@@ static int nvdimm_probe(struct device *
  	if (rc)
  		goto err;
  
++<<<<<<< HEAD
 +	rc = nd_label_data_init(ndd);
++=======
+ 	/*
+ 	 * EACCES failures reading the namespace label-data are
+ 	 * interpreted as the label area being locked in addition to the
+ 	 * DIMM capacity. We fail the dimm probe to prevent regions from
+ 	 * attempting to parse the label area.
+ 	 */
+ 	rc = nvdimm_init_config_data(ndd);
++>>>>>>> 08e6b3c6e3a0 (libnvdimm: Introduce locked DIMM capacity support)
  	if (rc == -EACCES)
  		nvdimm_set_locked(dev);
  	if (rc)
* Unmerged path drivers/nvdimm/dimm.c
diff --git a/drivers/nvdimm/namespace_devs.c b/drivers/nvdimm/namespace_devs.c
index 4525d8ef6022..4a4266250c28 100644
--- a/drivers/nvdimm/namespace_devs.c
+++ b/drivers/nvdimm/namespace_devs.c
@@ -1144,6 +1144,26 @@ resource_size_t nvdimm_namespace_capacity(struct nd_namespace_common *ndns)
 }
 EXPORT_SYMBOL(nvdimm_namespace_capacity);
 
+bool nvdimm_namespace_locked(struct nd_namespace_common *ndns)
+{
+	int i;
+	bool locked = false;
+	struct device *dev = &ndns->dev;
+	struct nd_region *nd_region = to_nd_region(dev->parent);
+
+	for (i = 0; i < nd_region->ndr_mappings; i++) {
+		struct nd_mapping *nd_mapping = &nd_region->mapping[i];
+		struct nvdimm *nvdimm = nd_mapping->nvdimm;
+
+		if (test_bit(NDD_LOCKED, &nvdimm->flags)) {
+			dev_dbg(dev, "%s locked\n", nvdimm_name(nvdimm));
+			locked = true;
+		}
+	}
+	return locked;
+}
+EXPORT_SYMBOL(nvdimm_namespace_locked);
+
 static ssize_t size_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
@@ -1695,6 +1715,9 @@ struct nd_namespace_common *nvdimm_namespace_common_probe(struct device *dev)
 		}
 	}
 
+	if (nvdimm_namespace_locked(ndns))
+		return ERR_PTR(-EACCES);
+
 	size = nvdimm_namespace_capacity(ndns);
 	if (size < ND_MIN_NAMESPACE_SIZE) {
 		dev_dbg(&ndns->dev, "%pa, too small must be at least %#x\n",
diff --git a/drivers/nvdimm/nd.h b/drivers/nvdimm/nd.h
index 4edbf9666a07..e79cc8e5c114 100644
--- a/drivers/nvdimm/nd.h
+++ b/drivers/nvdimm/nd.h
@@ -359,6 +359,7 @@ struct resource *nvdimm_allocate_dpa(struct nvdimm_drvdata *ndd,
 		struct nd_label_id *label_id, resource_size_t start,
 		resource_size_t n);
 resource_size_t nvdimm_namespace_capacity(struct nd_namespace_common *ndns);
+bool nvdimm_namespace_locked(struct nd_namespace_common *ndns);
 struct nd_namespace_common *nvdimm_namespace_common_probe(struct device *dev);
 int nvdimm_namespace_attach_btt(struct nd_namespace_common *ndns);
 int nvdimm_namespace_detach_btt(struct nd_btt *nd_btt);
