net/mlx5e: Allow association of a flow to multiple encaps

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Eli Britstein <elibr@mellanox.com>
commit 79baaec71989afa805a0f2dd532451a6103e11b4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/79baaec7.failed

Currently a flow can be associated with a single encap entry. The
extended destination feature enables the driver to configure multiple
encap entries per flow.

Change the encap flow association field to array as a pre-step towards
supporting multiple encap destinations. Use only the first array
element, with no functional change.

	Signed-off-by: Eli Britstein <elibr@mellanox.com>
	Reviewed-by: Oz Shlomo <ozsh@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 79baaec71989afa805a0f2dd532451a6103e11b4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index c9ee89f4edb1,58b83489a6d6..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -82,9 -104,13 +104,13 @@@ struct mlx5e_tc_flow 
  	struct rhash_head	node;
  	struct mlx5e_priv	*priv;
  	u64			cookie;
 -	u16			flags;
 +	u8			flags;
  	struct mlx5_flow_handle *rule[MLX5E_TC_MAX_SPLITS + 1];
- 	struct list_head	encap;   /* flows sharing the same encap ID */
+ 	/* Flow can be associated with multiple encap IDs.
+ 	 * The number of encaps is bounded by the number of supported
+ 	 * destinations.
+ 	 */
+ 	struct encap_flow_item encaps[MLX5_MAX_FLOW_FWD_VPORTS];
  	struct list_head	mod_hdr; /* flows sharing the same mod hdr ID */
  	struct list_head	hairpin; /* flows sharing the same hairpin */
  	union {
@@@ -941,7 -1066,10 +967,14 @@@ void mlx5e_tc_encap_flows_add(struct ml
  			      struct mlx5e_encap_entry *e)
  {
  	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
++<<<<<<< HEAD
 +	struct mlx5_esw_flow_attr *esw_attr;
++=======
+ 	struct mlx5_esw_flow_attr slow_attr, *esw_attr;
+ 	struct mlx5_flow_handle *rule;
+ 	struct mlx5_flow_spec *spec;
+ 	struct encap_flow_item *efi;
++>>>>>>> 79baaec71989 (net/mlx5e: Allow association of a flow to multiple encaps)
  	struct mlx5e_tc_flow *flow;
  	int err;
  
@@@ -957,12 -1086,16 +990,13 @@@
  	e->flags |= MLX5_ENCAP_ENTRY_VALID;
  	mlx5e_rep_queue_neigh_stats_work(priv);
  
- 	list_for_each_entry(flow, &e->flows, encap) {
+ 	list_for_each_entry(efi, &e->flows, list) {
+ 		flow = container_of(efi, struct mlx5e_tc_flow, encaps[efi->index]);
  		esw_attr = flow->esw_attr;
  		esw_attr->encap_id = e->encap_id;
 -		spec = &esw_attr->parse_attr->spec;
 -
 -		/* update from slow path rule to encap rule */
 -		rule = mlx5e_tc_offload_fdb_rules(esw, flow, spec, esw_attr);
 -		if (IS_ERR(rule)) {
 -			err = PTR_ERR(rule);
 +		flow->rule[0] = mlx5_eswitch_add_offloaded_rule(esw, &esw_attr->parse_attr->spec, esw_attr);
 +		if (IS_ERR(flow->rule[0])) {
 +			err = PTR_ERR(flow->rule[0]);
  			mlx5_core_warn(priv->mdev, "Failed to update cached encapsulation flow, %d\n",
  				       err);
  			continue;
@@@ -987,22 -1111,36 +1021,35 @@@ void mlx5e_tc_encap_flows_del(struct ml
  			      struct mlx5e_encap_entry *e)
  {
  	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
++<<<<<<< HEAD
++=======
+ 	struct mlx5_esw_flow_attr slow_attr;
+ 	struct mlx5_flow_handle *rule;
+ 	struct mlx5_flow_spec *spec;
+ 	struct encap_flow_item *efi;
++>>>>>>> 79baaec71989 (net/mlx5e: Allow association of a flow to multiple encaps)
  	struct mlx5e_tc_flow *flow;
 -	int err;
  
++<<<<<<< HEAD
 +	list_for_each_entry(flow, &e->flows, encap) {
 +		if (flow->flags & MLX5E_TC_FLOW_OFFLOADED) {
 +			struct mlx5_esw_flow_attr *attr = flow->esw_attr;
++=======
+ 	list_for_each_entry(efi, &e->flows, list) {
+ 		flow = container_of(efi, struct mlx5e_tc_flow, encaps[efi->index]);
+ 		spec = &flow->esw_attr->parse_attr->spec;
++>>>>>>> 79baaec71989 (net/mlx5e: Allow association of a flow to multiple encaps)
  
 -		/* update from encap rule to slow path rule */
 -		rule = mlx5e_tc_offload_to_slow_path(esw, flow, spec, &slow_attr);
 -
 -		if (IS_ERR(rule)) {
 -			err = PTR_ERR(rule);
 -			mlx5_core_warn(priv->mdev, "Failed to update slow path (encap) flow, %d\n",
 -				       err);
 -			continue;
 +			flow->flags &= ~MLX5E_TC_FLOW_OFFLOADED;
 +			if (attr->mirror_count)
 +				mlx5_eswitch_del_fwd_rule(esw, flow->rule[1], attr);
 +			mlx5_eswitch_del_offloaded_rule(esw, flow->rule[0], attr);
  		}
 -
 -		mlx5e_tc_unoffload_fdb_rules(esw, flow, flow->esw_attr);
 -		flow->flags |= MLX5E_TC_FLOW_OFFLOADED; /* was unset when fast path rule removed */
 -		flow->rule[0] = rule;
  	}
  
 -	if (e->flags & MLX5_ENCAP_ENTRY_VALID) {
 -		e->flags &= ~MLX5_ENCAP_ENTRY_VALID;
 -		mlx5_packet_reformat_dealloc(priv->mdev, e->encap_id);
 -	}
 +	/* we know that the encap is valid */
 +	e->flags &= ~MLX5_ENCAP_ENTRY_VALID;
 +	mlx5_packet_reformat_dealloc(priv->mdev, e->encap_id);
  }
  
  static struct mlx5_fc *mlx5e_tc_get_counter(struct mlx5e_tc_flow *flow)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
