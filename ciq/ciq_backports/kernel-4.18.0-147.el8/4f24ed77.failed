udp: use indirect call wrappers for GRO socket lookup

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Paolo Abeni <pabeni@redhat.com>
commit 4f24ed77dec9b067d08f7958a287cbf48665f35e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/4f24ed77.failed

This avoids another indirect call for UDP GRO. Again, the test
for the IPv6 variant is performed first.

v1 -> v2:
 - adapted to INDIRECT_CALL_ changes

	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4f24ed77dec9b067d08f7958a287cbf48665f35e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/udp_offload.c
diff --cc net/ipv4/udp_offload.c
index 69c54540d5b4,64f9715173ac..000000000000
--- a/net/ipv4/udp_offload.c
+++ b/net/ipv4/udp_offload.c
@@@ -343,15 -344,78 +343,84 @@@ out
  	return segs;
  }
  
 -#define UDP_GRO_CNT_MAX 64
 -static struct sk_buff *udp_gro_receive_segment(struct list_head *head,
 -					       struct sk_buff *skb)
 +struct sk_buff **udp_gro_receive(struct sk_buff **head, struct sk_buff *skb,
 +				 struct udphdr *uh, udp_lookup_t lookup)
  {
++<<<<<<< HEAD
 +	struct sk_buff *p, **pp = NULL;
++=======
+ 	struct udphdr *uh = udp_hdr(skb);
+ 	struct sk_buff *pp = NULL;
+ 	struct udphdr *uh2;
+ 	struct sk_buff *p;
+ 
+ 	/* requires non zero csum, for symmetry with GSO */
+ 	if (!uh->check) {
+ 		NAPI_GRO_CB(skb)->flush = 1;
+ 		return NULL;
+ 	}
+ 
+ 	/* pull encapsulating udp header */
+ 	skb_gro_pull(skb, sizeof(struct udphdr));
+ 	skb_gro_postpull_rcsum(skb, uh, sizeof(struct udphdr));
+ 
+ 	list_for_each_entry(p, head, list) {
+ 		if (!NAPI_GRO_CB(p)->same_flow)
+ 			continue;
+ 
+ 		uh2 = udp_hdr(p);
+ 
+ 		/* Match ports only, as csum is always non zero */
+ 		if ((*(u32 *)&uh->source != *(u32 *)&uh2->source)) {
+ 			NAPI_GRO_CB(p)->same_flow = 0;
+ 			continue;
+ 		}
+ 
+ 		/* Terminate the flow on len mismatch or if it grow "too much".
+ 		 * Under small packet flood GRO count could elsewhere grow a lot
+ 		 * leading to execessive truesize values
+ 		 */
+ 		if (!skb_gro_receive(p, skb) &&
+ 		    NAPI_GRO_CB(p)->count >= UDP_GRO_CNT_MAX)
+ 			pp = p;
+ 		else if (uh->len != uh2->len)
+ 			pp = p;
+ 
+ 		return pp;
+ 	}
+ 
+ 	/* mismatch, but we never need to flush */
+ 	return NULL;
+ }
+ 
+ INDIRECT_CALLABLE_DECLARE(struct sock *udp6_lib_lookup_skb(struct sk_buff *skb,
+ 						   __be16 sport, __be16 dport));
+ struct sk_buff *udp_gro_receive(struct list_head *head, struct sk_buff *skb,
+ 				struct udphdr *uh, udp_lookup_t lookup)
+ {
+ 	struct sk_buff *pp = NULL;
+ 	struct sk_buff *p;
++>>>>>>> 4f24ed77dec9 (udp: use indirect call wrappers for GRO socket lookup)
  	struct udphdr *uh2;
  	unsigned int off = skb_gro_offset(skb);
  	int flush = 1;
  	struct sock *sk;
  
++<<<<<<< HEAD
++=======
+ 	rcu_read_lock();
+ 	sk = INDIRECT_CALL_INET(lookup, udp6_lib_lookup_skb,
+ 				udp4_lib_lookup_skb, skb, uh->source, uh->dest);
+ 	if (!sk)
+ 		goto out_unlock;
+ 
+ 	if (udp_sk(sk)->gro_enabled) {
+ 		pp = call_gro_receive(udp_gro_receive_segment, head, skb);
+ 		rcu_read_unlock();
+ 		return pp;
+ 	}
+ 
++>>>>>>> 4f24ed77dec9 (udp: use indirect call wrappers for GRO socket lookup)
  	if (NAPI_GRO_CB(skb)->encap_mark ||
  	    (skb->ip_summed != CHECKSUM_PARTIAL &&
  	     NAPI_GRO_CB(skb)->csum_cnt == 0 &&
@@@ -436,16 -505,22 +505,31 @@@ int udp_gro_complete(struct sk_buff *sk
  
  	uh->len = newlen;
  
 +	/* Set encapsulation before calling into inner gro_complete() functions
 +	 * to make them set up the inner offsets.
 +	 */
 +	skb->encapsulation = 1;
 +
  	rcu_read_lock();
++<<<<<<< HEAD
 +	sk = (*lookup)(skb, uh->source, uh->dest);
 +	if (sk && udp_sk(sk)->gro_complete)
++=======
+ 	sk = INDIRECT_CALL_INET(lookup, udp6_lib_lookup_skb,
+ 				udp4_lib_lookup_skb, skb, uh->source, uh->dest);
+ 	if (sk && udp_sk(sk)->gro_enabled) {
+ 		err = udp_gro_complete_segment(skb);
+ 	} else if (sk && udp_sk(sk)->gro_complete) {
+ 		skb_shinfo(skb)->gso_type = uh->check ? SKB_GSO_UDP_TUNNEL_CSUM
+ 					: SKB_GSO_UDP_TUNNEL;
+ 
+ 		/* Set encapsulation before calling into inner gro_complete()
+ 		 * functions to make them set up the inner offsets.
+ 		 */
+ 		skb->encapsulation = 1;
++>>>>>>> 4f24ed77dec9 (udp: use indirect call wrappers for GRO socket lookup)
  		err = udp_sk(sk)->gro_complete(sk, skb,
  				nhoff + sizeof(struct udphdr));
 -	}
  	rcu_read_unlock();
  
  	if (skb->remcsum_offload)
* Unmerged path net/ipv4/udp_offload.c
