mlx5: handle DMA mapping error case for XDP redirect

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jesper Dangaard Brouer <brouer@redhat.com>
commit 39c64d8c876622e766dd2112baf81151dd82da02
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/39c64d8c.failed

Commit 58b99ee3e3eb ("net/mlx5e: Add support for XDP_REDIRECT in device-out side")
forgot to return/free the xdp_frame in case the DMA mapping failed, correct this.

Also DMA unmap the frame in case mlx5e_xmit_xdp_frame() fails.

Fixes: 58b99ee3e3eb ("net/mlx5e: Add support for XDP_REDIRECT in device-out side")
	Signed-off-by: Jesper Dangaard Brouer <brouer@redhat.com>
	Reviewed-by: Tariq Toukan <tariqt@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 39c64d8c876622e766dd2112baf81151dd82da02)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/xdp.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/xdp.c
index eabd5537927d,1881468dbcfa..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/xdp.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/xdp.c
@@@ -236,3 -251,55 +236,58 @@@ void mlx5e_free_xdpsq_descs(struct mlx5
  	}
  }
  
++<<<<<<< HEAD
++=======
+ int mlx5e_xdp_xmit(struct net_device *dev, int n, struct xdp_frame **frames,
+ 		   u32 flags)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(dev);
+ 	struct mlx5e_xdpsq *sq;
+ 	int drops = 0;
+ 	int sq_num;
+ 	int i;
+ 
+ 	if (unlikely(!test_bit(MLX5E_STATE_OPENED, &priv->state)))
+ 		return -ENETDOWN;
+ 
+ 	if (unlikely(flags & ~XDP_XMIT_FLAGS_MASK))
+ 		return -EINVAL;
+ 
+ 	sq_num = smp_processor_id();
+ 
+ 	if (unlikely(sq_num >= priv->channels.num))
+ 		return -ENXIO;
+ 
+ 	sq = &priv->channels.c[sq_num]->xdpsq;
+ 
+ 	if (unlikely(!test_bit(MLX5E_SQ_STATE_ENABLED, &sq->state)))
+ 		return -ENETDOWN;
+ 
+ 	for (i = 0; i < n; i++) {
+ 		struct xdp_frame *xdpf = frames[i];
+ 		struct mlx5e_xdp_info xdpi;
+ 
+ 		xdpi.dma_addr = dma_map_single(sq->pdev, xdpf->data, xdpf->len,
+ 					       DMA_TO_DEVICE);
+ 		if (unlikely(dma_mapping_error(sq->pdev, xdpi.dma_addr))) {
+ 			xdp_return_frame_rx_napi(xdpf);
+ 			drops++;
+ 			continue;
+ 		}
+ 
+ 		xdpi.xdpf = xdpf;
+ 
+ 		if (unlikely(!mlx5e_xmit_xdp_frame(sq, &xdpi))) {
+ 			dma_unmap_single(sq->pdev, xdpi.dma_addr,
+ 					 xdpf->len, DMA_TO_DEVICE);
+ 			xdp_return_frame_rx_napi(xdpf);
+ 			drops++;
+ 		}
+ 	}
+ 
+ 	if (flags & XDP_XMIT_FLUSH)
+ 		mlx5e_xmit_xdp_doorbell(sq);
+ 
+ 	return n - drops;
+ }
++>>>>>>> 39c64d8c8766 (mlx5: handle DMA mapping error case for XDP redirect)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/xdp.c
