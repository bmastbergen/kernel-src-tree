net/mlx5e: Remove leftover code from the PF netdev being uplink rep

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Or Gerlitz <ogerlitz@mellanox.com>
commit 13e509a4c1949855ddd5ef2e23bafdfb27b8337a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/13e509a4.failed

Remove some last leftovers from using the PF netdev as
the e-switch uplink representor.

	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 13e509a4c1949855ddd5ef2e23bafdfb27b8337a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index 58cddf0a96a7,73c6f24771bd..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -994,36 -1132,17 +994,21 @@@ bool mlx5e_is_uplink_rep(struct mlx5e_p
  	if (!MLX5_ESWITCH_MANAGER(priv->mdev))
  		return false;
  
 -	if (!rpriv) /* non vport rep mlx5e instances don't use this field */
 -		return false;
 -
  	rep = rpriv->rep;
 -	return (rep->vport == FDB_UPLINK_VPORT);
 +	if (esw->mode == SRIOV_OFFLOADS &&
 +	    rep && rep->vport == FDB_UPLINK_VPORT)
 +		return true;
 +
 +	return false;
  }
  
- static bool mlx5e_is_vf_vport_rep(struct mlx5e_priv *priv)
- {
- 	struct mlx5e_rep_priv *rpriv = priv->ppriv;
- 	struct mlx5_eswitch_rep *rep;
- 
- 	if (!MLX5_ESWITCH_MANAGER(priv->mdev))
- 		return false;
- 
- 	rep = rpriv->rep;
- 	if (rep && rep->vport != FDB_UPLINK_VPORT)
- 		return true;
- 
- 	return false;
- }
- 
- bool mlx5e_has_offload_stats(const struct net_device *dev, int attr_id)
+ static bool mlx5e_rep_has_offload_stats(const struct net_device *dev, int attr_id)
  {
 +	struct mlx5e_priv *priv = netdev_priv(dev);
 +
  	switch (attr_id) {
  	case IFLA_OFFLOAD_XSTATS_CPU_HIT:
 +		if (mlx5e_is_vf_vport_rep(priv) || mlx5e_is_uplink_rep(priv))
  			return true;
  	}
  
@@@ -1074,26 -1213,38 +1059,54 @@@ static const struct switchdev_ops mlx5e
  	.switchdev_port_attr_get	= mlx5e_attr_get,
  };
  
++<<<<<<< HEAD
 +static int mlx5e_change_rep_mtu(struct net_device *netdev, int new_mtu)
++=======
+ static const struct net_device_ops mlx5e_netdev_ops_vf_rep = {
+ 	.ndo_open                = mlx5e_vf_rep_open,
+ 	.ndo_stop                = mlx5e_vf_rep_close,
+ 	.ndo_start_xmit          = mlx5e_xmit,
+ 	.ndo_get_phys_port_name  = mlx5e_rep_get_phys_port_name,
+ 	.ndo_setup_tc            = mlx5e_rep_setup_tc,
+ 	.ndo_get_stats64         = mlx5e_vf_rep_get_stats,
+ 	.ndo_has_offload_stats	 = mlx5e_rep_has_offload_stats,
+ 	.ndo_get_offload_stats	 = mlx5e_rep_get_offload_stats,
+ 	.ndo_change_mtu          = mlx5e_vf_rep_change_mtu,
+ };
+ 
+ static const struct net_device_ops mlx5e_netdev_ops_uplink_rep = {
+ 	.ndo_open                = mlx5e_uplink_rep_open,
+ 	.ndo_stop                = mlx5e_close,
+ 	.ndo_start_xmit          = mlx5e_xmit,
+ 	.ndo_get_phys_port_name  = mlx5e_rep_get_phys_port_name,
+ 	.ndo_setup_tc            = mlx5e_rep_setup_tc,
+ 	.ndo_get_stats64         = mlx5e_get_stats,
+ 	.ndo_has_offload_stats	 = mlx5e_rep_has_offload_stats,
+ 	.ndo_get_offload_stats	 = mlx5e_rep_get_offload_stats,
+ 	.ndo_change_mtu          = mlx5e_uplink_rep_change_mtu,
+ };
+ 
+ static void mlx5e_build_rep_params(struct net_device *netdev)
++>>>>>>> 13e509a4c194 (net/mlx5e: Remove leftover code from the PF netdev being uplink rep)
  {
 -	struct mlx5e_priv *priv = netdev_priv(netdev);
 -	struct mlx5e_rep_priv *rpriv = priv->ppriv;
 -	struct mlx5_eswitch_rep *rep = rpriv->rep;
 -	struct mlx5_core_dev *mdev = priv->mdev;
 -	struct mlx5e_params *params;
 +	return mlx5e_change_mtu(netdev, new_mtu, NULL);
 +}
  
 +static const struct net_device_ops mlx5e_netdev_ops_rep = {
 +	.ndo_open                = mlx5e_rep_open,
 +	.ndo_stop                = mlx5e_rep_close,
 +	.ndo_start_xmit          = mlx5e_xmit,
 +	.ndo_get_phys_port_name  = mlx5e_rep_get_phys_port_name,
 +	.ndo_setup_tc            = mlx5e_rep_setup_tc,
 +	.ndo_get_stats64         = mlx5e_rep_get_stats,
 +	.ndo_has_offload_stats	 = mlx5e_has_offload_stats,
 +	.ndo_get_offload_stats	 = mlx5e_get_offload_stats,
 +	.ndo_change_mtu          = mlx5e_change_rep_mtu,
 +};
 +
 +static void mlx5e_build_rep_params(struct mlx5_core_dev *mdev,
 +				   struct mlx5e_params *params, u16 mtu)
 +{
  	u8 cq_period_mode = MLX5_CAP_GEN(mdev, cq_period_start_from_cqe) ?
  					 MLX5_CQ_PERIOD_MODE_START_FROM_CQE :
  					 MLX5_CQ_PERIOD_MODE_START_FROM_EQE;
@@@ -1458,48 -1645,6 +1408,51 @@@ static void mlx5e_rep_unregister_vf_vpo
  	int total_vfs = MLX5_TOTAL_VPORTS(mdev);
  	int vport;
  
 -	for (vport = total_vfs - 1; vport >= 0; vport--)
 +	for (vport = 1; vport < total_vfs; vport++)
  		mlx5_eswitch_unregister_vport_rep(esw, vport, REP_ETH);
  }
++<<<<<<< HEAD
 +
 +void mlx5e_register_vport_reps(struct mlx5e_priv *priv)
 +{
 +	struct mlx5_core_dev *mdev = priv->mdev;
 +	struct mlx5_eswitch *esw   = mdev->priv.eswitch;
 +	struct mlx5_eswitch_rep_if rep_if;
 +	struct mlx5e_rep_priv *rpriv;
 +
 +	rpriv = priv->ppriv;
 +	rpriv->netdev = priv->netdev;
 +
 +	rep_if.load = mlx5e_nic_rep_load;
 +	rep_if.unload = mlx5e_nic_rep_unload;
 +	rep_if.get_proto_dev = mlx5e_vport_rep_get_proto_dev;
 +	rep_if.priv = rpriv;
 +	INIT_LIST_HEAD(&rpriv->vport_sqs_list);
 +	mlx5_eswitch_register_vport_rep(esw, 0, &rep_if, REP_ETH); /* UPLINK PF vport*/
 +
 +	mlx5e_rep_register_vf_vports(priv); /* VFs vports */
 +}
 +
 +void mlx5e_unregister_vport_reps(struct mlx5e_priv *priv)
 +{
 +	struct mlx5_core_dev *mdev = priv->mdev;
 +	struct mlx5_eswitch *esw   = mdev->priv.eswitch;
 +
 +	mlx5e_rep_unregister_vf_vports(priv); /* VFs vports */
 +	mlx5_eswitch_unregister_vport_rep(esw, 0, REP_ETH); /* UPLINK PF*/
 +}
 +
 +void *mlx5e_alloc_nic_rep_priv(struct mlx5_core_dev *mdev)
 +{
 +	struct mlx5_eswitch *esw = mdev->priv.eswitch;
 +	struct mlx5e_rep_priv *rpriv;
 +
 +	rpriv = kzalloc(sizeof(*rpriv), GFP_KERNEL);
 +	if (!rpriv)
 +		return NULL;
 +
 +	rpriv->rep = &esw->offloads.vport_reps[0];
 +	return rpriv;
 +}
++=======
++>>>>>>> 13e509a4c194 (net/mlx5e: Remove leftover code from the PF netdev being uplink rep)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index c078c6703dc7,bb2d2484eb64..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@@ -166,10 -168,6 +166,13 @@@ bool mlx5e_is_uplink_rep(struct mlx5e_p
  int mlx5e_add_sqs_fwd_rules(struct mlx5e_priv *priv);
  void mlx5e_remove_sqs_fwd_rules(struct mlx5e_priv *priv);
  
++<<<<<<< HEAD
 +int mlx5e_get_offload_stats(int attr_id, const struct net_device *dev, void *sp);
 +bool mlx5e_has_offload_stats(const struct net_device *dev, int attr_id);
 +
 +int mlx5e_attr_get(struct net_device *dev, struct switchdev_attr *attr);
++=======
++>>>>>>> 13e509a4c194 (net/mlx5e: Remove leftover code from the PF netdev being uplink rep)
  void mlx5e_handle_rx_cqe_rep(struct mlx5e_rq *rq, struct mlx5_cqe64 *cqe);
  
  int mlx5e_rep_encap_entry_attach(struct mlx5e_priv *priv,
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index b4f6c14ea722..7bdb59bd91aa 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@ -4350,8 +4350,6 @@ const struct net_device_ops mlx5e_netdev_ops = {
 	.ndo_get_vf_config       = mlx5e_get_vf_config,
 	.ndo_set_vf_link_state   = mlx5e_set_vf_link_state,
 	.ndo_get_vf_stats        = mlx5e_get_vf_stats,
-	.ndo_has_offload_stats	 = mlx5e_has_offload_stats,
-	.ndo_get_offload_stats	 = mlx5e_get_offload_stats,
 #endif
 };
 
@@ -5098,7 +5096,6 @@ static void mlx5e_detach(struct mlx5_core_dev *mdev, void *vpriv)
 static void *mlx5e_add(struct mlx5_core_dev *mdev)
 {
 	struct net_device *netdev;
-	void *rpriv = NULL;
 	void *priv;
 	int err;
 	int nch;
@@ -5107,21 +5104,11 @@ static void *mlx5e_add(struct mlx5_core_dev *mdev)
 	if (err)
 		return NULL;
 
-#ifdef CONFIG_MLX5_ESWITCH
-	if (MLX5_ESWITCH_MANAGER(mdev)) {
-		rpriv = mlx5e_alloc_nic_rep_priv(mdev);
-		if (!rpriv) {
-			mlx5_core_warn(mdev, "Failed to alloc NIC rep priv data\n");
-			return NULL;
-		}
-	}
-#endif
-
 	nch = mlx5e_get_max_num_channels(mdev);
-	netdev = mlx5e_create_netdev(mdev, &mlx5e_nic_profile, nch, rpriv);
+	netdev = mlx5e_create_netdev(mdev, &mlx5e_nic_profile, nch, NULL);
 	if (!netdev) {
 		mlx5_core_err(mdev, "mlx5e_create_netdev failed\n");
-		goto err_free_rpriv;
+		return NULL;
 	}
 
 	priv = netdev_priv(netdev);
@@ -5147,8 +5134,6 @@ static void *mlx5e_add(struct mlx5_core_dev *mdev)
 	mlx5e_detach(mdev, priv);
 err_destroy_netdev:
 	mlx5e_destroy_netdev(priv);
-err_free_rpriv:
-	kfree(rpriv);
 	return NULL;
 }
 
@@ -5163,7 +5148,6 @@ static void mlx5e_remove(struct mlx5_core_dev *mdev, void *vpriv)
 	unregister_netdev(priv->netdev);
 	mlx5e_detach(mdev, vpriv);
 	mlx5e_destroy_netdev(priv);
-	kfree(ppriv);
 }
 
 static void *mlx5e_get_netdev(void *vpriv)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
