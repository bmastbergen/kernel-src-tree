uprobes/sdt: Prevent multiple reference counter for same uprobe

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Ravi Bangoria <ravi.bangoria@linux.ibm.com>
commit 22bad38286d9a652d7061a02f9743bb2ebb84e59
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/22bad382.failed

We assume to have only one reference counter for one uprobe.
Don't allow user to register multiple uprobes having same
inode+offset but different reference counter.

Link: http://lkml.kernel.org/r/20180820044250.11659-3-ravi.bangoria@linux.ibm.com

	Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
	Reviewed-by: Oleg Nesterov <oleg@redhat.com>
	Reviewed-by: Song Liu <songliubraving@fb.com>
	Tested-by: Song Liu <songliubraving@fb.com>
	Signed-off-by: Ravi Bangoria <ravi.bangoria@linux.ibm.com>
	Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
(cherry picked from commit 22bad38286d9a652d7061a02f9743bb2ebb84e59)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/events/uprobes.c
diff --cc kernel/events/uprobes.c
index 85aea4cff4cb,96fb51f3994f..000000000000
--- a/kernel/events/uprobes.c
+++ b/kernel/events/uprobes.c
@@@ -484,7 -679,18 +484,22 @@@ static struct uprobe *insert_uprobe(str
  	return u;
  }
  
++<<<<<<< HEAD
 +static struct uprobe *alloc_uprobe(struct inode *inode, loff_t offset)
++=======
+ static void
+ ref_ctr_mismatch_warn(struct uprobe *cur_uprobe, struct uprobe *uprobe)
+ {
+ 	pr_warn("ref_ctr_offset mismatch. inode: 0x%lx offset: 0x%llx "
+ 		"ref_ctr_offset(old): 0x%llx ref_ctr_offset(new): 0x%llx\n",
+ 		uprobe->inode->i_ino, (unsigned long long) uprobe->offset,
+ 		(unsigned long long) cur_uprobe->ref_ctr_offset,
+ 		(unsigned long long) uprobe->ref_ctr_offset);
+ }
+ 
+ static struct uprobe *alloc_uprobe(struct inode *inode, loff_t offset,
+ 				   loff_t ref_ctr_offset)
++>>>>>>> 22bad38286d9 (uprobes/sdt: Prevent multiple reference counter for same uprobe)
  {
  	struct uprobe *uprobe, *cur_uprobe;
  
@@@ -895,9 -1125,12 +916,12 @@@ int uprobe_register(struct inode *inode
  		return -EINVAL;
  
   retry:
 -	uprobe = alloc_uprobe(inode, offset, ref_ctr_offset);
 +	uprobe = alloc_uprobe(inode, offset);
  	if (!uprobe)
  		return -ENOMEM;
+ 	if (IS_ERR(uprobe))
+ 		return PTR_ERR(uprobe);
+ 
  	/*
  	 * We can race with uprobe_unregister()->delete_uprobe().
  	 * Check uprobe_is_active() and retry if it is false.
* Unmerged path kernel/events/uprobes.c
