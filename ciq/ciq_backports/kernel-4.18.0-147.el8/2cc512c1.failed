bpf: btf: fix inconsistent IS_ERR and PTR_ERR

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author YueHaibing <yuehaibing@huawei.com>
commit 2cc512c1fa1ee99879d55d1cb4e3fd0e6eab35b3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/2cc512c1.failed

Fix inconsistent IS_ERR and PTR_ERR in get_btf,
the proper pointer to be passed as argument is '*btf'

This issue was detected with the help of Coccinelle.

Fixes: 2d3feca8c44f ("bpf: btf: print map dump and lookup with btf info")
	Signed-off-by: YueHaibing <yuehaibing@huawei.com>
	Acked-by: David S. Miller <davem@davemloft.net>
	Acked-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Acked-by: Martin KaFai Lau <kafai@fb.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit 2cc512c1fa1ee99879d55d1cb4e3fd0e6eab35b3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/bpf/bpftool/map.c
diff --cc tools/bpf/bpftool/map.c
index 538986c08337,0ee3ba479d87..000000000000
--- a/tools/bpf/bpftool/map.c
+++ b/tools/bpf/bpftool/map.c
@@@ -150,8 -151,109 +150,112 @@@ int map_parse_fd_and_info(int *argc, ch
  	return fd;
  }
  
++<<<<<<< HEAD
++=======
+ static int do_dump_btf(const struct btf_dumper *d,
+ 		       struct bpf_map_info *map_info, void *key,
+ 		       void *value)
+ {
+ 	int ret;
+ 
+ 	/* start of key-value pair */
+ 	jsonw_start_object(d->jw);
+ 
+ 	jsonw_name(d->jw, "key");
+ 
+ 	ret = btf_dumper_type(d, map_info->btf_key_type_id, key);
+ 	if (ret)
+ 		goto err_end_obj;
+ 
+ 	jsonw_name(d->jw, "value");
+ 
+ 	ret = btf_dumper_type(d, map_info->btf_value_type_id, value);
+ 
+ err_end_obj:
+ 	/* end of key-value pair */
+ 	jsonw_end_object(d->jw);
+ 
+ 	return ret;
+ }
+ 
+ static int get_btf(struct bpf_map_info *map_info, struct btf **btf)
+ {
+ 	struct bpf_btf_info btf_info = { 0 };
+ 	__u32 len = sizeof(btf_info);
+ 	__u32 last_size;
+ 	int btf_fd;
+ 	void *ptr;
+ 	int err;
+ 
+ 	err = 0;
+ 	*btf = NULL;
+ 	btf_fd = bpf_btf_get_fd_by_id(map_info->btf_id);
+ 	if (btf_fd < 0)
+ 		return 0;
+ 
+ 	/* we won't know btf_size until we call bpf_obj_get_info_by_fd(). so
+ 	 * let's start with a sane default - 4KiB here - and resize it only if
+ 	 * bpf_obj_get_info_by_fd() needs a bigger buffer.
+ 	 */
+ 	btf_info.btf_size = 4096;
+ 	last_size = btf_info.btf_size;
+ 	ptr = malloc(last_size);
+ 	if (!ptr) {
+ 		err = -ENOMEM;
+ 		goto exit_free;
+ 	}
+ 
+ 	bzero(ptr, last_size);
+ 	btf_info.btf = ptr_to_u64(ptr);
+ 	err = bpf_obj_get_info_by_fd(btf_fd, &btf_info, &len);
+ 
+ 	if (!err && btf_info.btf_size > last_size) {
+ 		void *temp_ptr;
+ 
+ 		last_size = btf_info.btf_size;
+ 		temp_ptr = realloc(ptr, last_size);
+ 		if (!temp_ptr) {
+ 			err = -ENOMEM;
+ 			goto exit_free;
+ 		}
+ 		ptr = temp_ptr;
+ 		bzero(ptr, last_size);
+ 		btf_info.btf = ptr_to_u64(ptr);
+ 		err = bpf_obj_get_info_by_fd(btf_fd, &btf_info, &len);
+ 	}
+ 
+ 	if (err || btf_info.btf_size > last_size) {
+ 		err = errno;
+ 		goto exit_free;
+ 	}
+ 
+ 	*btf = btf__new((__u8 *)btf_info.btf, btf_info.btf_size, NULL);
+ 	if (IS_ERR(*btf)) {
+ 		err = PTR_ERR(*btf);
+ 		*btf = NULL;
+ 	}
+ 
+ exit_free:
+ 	close(btf_fd);
+ 	free(ptr);
+ 
+ 	return err;
+ }
+ 
+ static json_writer_t *get_btf_writer(void)
+ {
+ 	json_writer_t *jw = jsonw_new(stdout);
+ 
+ 	if (!jw)
+ 		return NULL;
+ 	jsonw_pretty(jw, true);
+ 
+ 	return jw;
+ }
+ 
++>>>>>>> 2cc512c1fa1e (bpf: btf: fix inconsistent IS_ERR and PTR_ERR)
  static void print_entry_json(struct bpf_map_info *info, unsigned char *key,
 -			     unsigned char *value, struct btf *btf)
 +			     unsigned char *value)
  {
  	jsonw_start_object(json_wtr);
  
* Unmerged path tools/bpf/bpftool/map.c
