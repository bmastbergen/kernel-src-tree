net/mlx5e: XDP, Maintain a FIFO structure for xdp_info instances

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Tariq Toukan <tariqt@mellanox.com>
commit fea28dd6a281045e18c1412ab5bba54436c11088
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/fea28dd6.failed

This provides infrastructure to have multiple xdp_info instances
for the same consumer index.

	Signed-off-by: Tariq Toukan <tariqt@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit fea28dd6a281045e18c1412ab5bba54436c11088)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
#	drivers/net/ethernet/mellanox/mlx5/core/en/xdp.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en.h
index 007808f3e87f,fab49cbdb85d..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@@ -416,8 -420,9 +424,14 @@@ struct mlx5e_xdpsq 
  	bool                       redirect_flush;
  
  	/* dirtied @xmit */
++<<<<<<< HEAD
 +	u16                        pc ____cacheline_aligned_in_smp;
 +	bool                       doorbell;
++=======
+ 	u32                        xdpi_fifo_pc ____cacheline_aligned_in_smp;
+ 	u16                        pc;
+ 	struct mlx5_wqe_ctrl_seg   *doorbell_cseg;
++>>>>>>> fea28dd6a281 (net/mlx5e: XDP, Maintain a FIFO structure for xdp_info instances)
  
  	struct mlx5e_cq            cq;
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/xdp.c
index 60fd47414ccc,fe8788a7744e..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/xdp.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/xdp.c
@@@ -152,23 -149,21 +152,21 @@@ bool mlx5e_xmit_xdp_frame(struct mlx5e_
  
  	cseg->opmod_idx_opcode = cpu_to_be32((sq->pc << 8) | MLX5_OPCODE_SEND);
  
- 	/* move page to reference to sq responsibility,
- 	 * and mark so it's not put back in page-cache.
- 	 */
- 	sq->db.xdpi[pi] = *xdpi;
  	sq->pc++;
  
 -	sq->doorbell_cseg = cseg;
 +	sq->doorbell = true;
  
+ 	mlx5e_xdpi_fifo_push(&sq->db.xdpi_fifo, xdpi);
  	stats->xmit++;
  	return true;
  }
  
 -bool mlx5e_poll_xdpsq_cq(struct mlx5e_cq *cq, struct mlx5e_rq *rq)
 +bool mlx5e_poll_xdpsq_cq(struct mlx5e_cq *cq)
  {
+ 	struct mlx5e_xdp_info_fifo *xdpi_fifo;
  	struct mlx5e_xdpsq *sq;
  	struct mlx5_cqe64 *cqe;
 -	bool is_redirect;
 +	struct mlx5e_rq *rq;
  	u16 sqcc;
  	int i;
  
@@@ -181,7 -176,8 +179,12 @@@
  	if (!cqe)
  		return false;
  
++<<<<<<< HEAD
 +	rq = container_of(sq, struct mlx5e_rq, xdpsq);
++=======
+ 	is_redirect = !rq;
+ 	xdpi_fifo = &sq->db.xdpi_fifo;
++>>>>>>> fea28dd6a281 (net/mlx5e: XDP, Maintain a FIFO structure for xdp_info instances)
  
  	/* sq->cc must be updated only after mlx5_cqwq_update_db_record(),
  	 * otherwise a cq overrun may occur
@@@ -203,17 -199,20 +206,33 @@@
  					 get_cqe_opcode(cqe));
  
  		do {
++<<<<<<< HEAD
 +			struct mlx5e_xdp_info *xdpi;
 +			u16 ci;
++=======
+ 			struct mlx5e_xdp_info xdpi =
+ 				mlx5e_xdpi_fifo_pop(xdpi_fifo);
++>>>>>>> fea28dd6a281 (net/mlx5e: XDP, Maintain a FIFO structure for xdp_info instances)
  
  			last_wqe = (sqcc == wqe_counter);
 -			sqcc++;
  
++<<<<<<< HEAD
 +			ci = mlx5_wq_cyc_ctr2ix(&sq->wq, sqcc);
 +			xdpi = &sq->db.xdpi[ci];
 +
 +			sqcc++;
 +			/* Recycle RX page */
 +			mlx5e_page_release(rq, &xdpi->di, true);
++=======
+ 			if (is_redirect) {
+ 				xdp_return_frame(xdpi.xdpf);
+ 				dma_unmap_single(sq->pdev, xdpi.dma_addr,
+ 						 xdpi.xdpf->len, DMA_TO_DEVICE);
+ 			} else {
+ 				/* Recycle RX page */
+ 				mlx5e_page_release(rq, &xdpi.di, true);
+ 			}
++>>>>>>> fea28dd6a281 (net/mlx5e: XDP, Maintain a FIFO structure for xdp_info instances)
  		} while (!last_wqe);
  	} while ((++i < MLX5E_TX_CQ_POLL_BUDGET) && (cqe = mlx5_cqwq_get_cqe(&cq->wq)));
  
@@@ -228,18 -227,25 +247,38 @@@
  	return (i == MLX5E_TX_CQ_POLL_BUDGET);
  }
  
 -void mlx5e_free_xdpsq_descs(struct mlx5e_xdpsq *sq, struct mlx5e_rq *rq)
 +void mlx5e_free_xdpsq_descs(struct mlx5e_xdpsq *sq)
  {
++<<<<<<< HEAD
 +	struct mlx5e_rq *rq = container_of(sq, struct mlx5e_rq, xdpsq);
 +	struct mlx5e_xdp_info *xdpi;
 +	u16 ci;
 +
 +	while (sq->cc != sq->pc) {
 +		ci = mlx5_wq_cyc_ctr2ix(&sq->wq, sq->cc);
 +		xdpi = &sq->db.xdpi[ci];
 +		sq->cc++;
 +
 +		mlx5e_page_release(rq, &xdpi->di, false);
++=======
+ 	struct mlx5e_xdp_info_fifo *xdpi_fifo = &sq->db.xdpi_fifo;
+ 	bool is_redirect = !rq;
+ 
+ 	while (sq->cc != sq->pc) {
+ 		struct mlx5e_xdp_info xdpi =
+ 			mlx5e_xdpi_fifo_pop(xdpi_fifo);
+ 
+ 		sq->cc++;
+ 
+ 		if (is_redirect) {
+ 			xdp_return_frame(xdpi.xdpf);
+ 			dma_unmap_single(sq->pdev, xdpi.dma_addr,
+ 					 xdpi.xdpf->len, DMA_TO_DEVICE);
+ 		} else {
+ 			/* Recycle RX page */
+ 			mlx5e_page_release(rq, &xdpi.di, false);
+ 		}
++>>>>>>> fea28dd6a281 (net/mlx5e: XDP, Maintain a FIFO structure for xdp_info instances)
  	}
  }
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/xdp.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/xdp.h b/drivers/net/ethernet/mellanox/mlx5/core/en/xdp.h
index 81739aad0188..cb10f91c439a 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/xdp.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/xdp.h
@@ -58,4 +58,19 @@ static inline void mlx5e_xmit_xdp_doorbell(struct mlx5e_xdpsq *sq)
 	mlx5e_notify_hw(wq, sq->pc, sq->uar_map, &wqe->ctrl);
 }
 
+static inline void
+mlx5e_xdpi_fifo_push(struct mlx5e_xdp_info_fifo *fifo,
+		     struct mlx5e_xdp_info *xi)
+{
+	u32 i = (*fifo->pc)++ & fifo->mask;
+
+	fifo->xi[i] = *xi;
+}
+
+static inline struct mlx5e_xdp_info
+mlx5e_xdpi_fifo_pop(struct mlx5e_xdp_info_fifo *fifo)
+{
+	return fifo->xi[(*fifo->cc)++ & fifo->mask];
+}
+
 #endif
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index b4f6c14ea722..269ffb078351 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@ -987,18 +987,35 @@ static void mlx5e_close_rq(struct mlx5e_rq *rq)
 
 static void mlx5e_free_xdpsq_db(struct mlx5e_xdpsq *sq)
 {
-	kvfree(sq->db.xdpi);
+	kvfree(sq->db.xdpi_fifo.xi);
+}
+
+static int mlx5e_alloc_xdpsq_fifo(struct mlx5e_xdpsq *sq, int numa)
+{
+	struct mlx5e_xdp_info_fifo *xdpi_fifo = &sq->db.xdpi_fifo;
+	int wq_sz        = mlx5_wq_cyc_get_size(&sq->wq);
+	int dsegs_per_wq = wq_sz * MLX5_SEND_WQEBB_NUM_DS;
+
+	xdpi_fifo->xi = kvzalloc_node(sizeof(*xdpi_fifo->xi) * dsegs_per_wq,
+				      GFP_KERNEL, numa);
+	if (!xdpi_fifo->xi)
+		return -ENOMEM;
+
+	xdpi_fifo->pc   = &sq->xdpi_fifo_pc;
+	xdpi_fifo->cc   = &sq->xdpi_fifo_cc;
+	xdpi_fifo->mask = dsegs_per_wq - 1;
+
+	return 0;
 }
 
 static int mlx5e_alloc_xdpsq_db(struct mlx5e_xdpsq *sq, int numa)
 {
-	int wq_sz = mlx5_wq_cyc_get_size(&sq->wq);
+	int err;
 
-	sq->db.xdpi = kvzalloc_node(array_size(wq_sz, sizeof(*sq->db.xdpi)),
-				    GFP_KERNEL, numa);
-	if (!sq->db.xdpi) {
+	err = mlx5e_alloc_xdpsq_fifo(sq, numa);
+	if (err) {
 		mlx5e_free_xdpsq_db(sq);
-		return -ENOMEM;
+		return err;
 	}
 
 	return 0;
