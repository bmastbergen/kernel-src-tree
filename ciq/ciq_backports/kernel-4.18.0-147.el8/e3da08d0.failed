bpf: allow BPF read access to qdisc pkt_len

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Petar Penkov <ppenkov@google.com>
commit e3da08d057002f9d0831949d51666c3e15dc6b29
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/e3da08d0.failed

The pkt_len field in qdisc_skb_cb stores the skb length as it will
appear on the wire after segmentation. For byte accounting, this value
is more accurate than skb->len. It is computed on entry to the TC
layer, so only valid there.

Allow read access to this field from BPF tc classifier and action
programs. The implementation is analogous to tc_classid, aside from
restricting to read access.

To distinguish it from skb->len and self-describe export as wire_len.

Changes v1->v2
  - Rename pkt_len to wire_len

	Signed-off-by: Petar Penkov <ppenkov@google.com>
	Signed-off-by: Vlad Dumitrescu <vladum@google.com>
	Signed-off-by: Willem de Bruijn <willemb@google.com>
	Acked-by: Song Liu <songliubraving@fb.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit e3da08d057002f9d0831949d51666c3e15dc6b29)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/bpf.h
#	net/core/filter.c
#	tools/include/uapi/linux/bpf.h
diff --cc include/uapi/linux/bpf.h
index 2293d9a9b442,0183b8e70a9e..000000000000
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@@ -2311,6 -2495,9 +2311,12 @@@ struct __sk_buff 
  	/* ... here. */
  
  	__u32 data_meta;
++<<<<<<< HEAD
++=======
+ 	struct bpf_flow_keys *flow_keys;
+ 	__u64 tstamp;
+ 	__u32 wire_len;
++>>>>>>> e3da08d05700 (bpf: allow BPF read access to qdisc pkt_len)
  };
  
  struct bpf_tunnel_key {
diff --cc net/core/filter.c
index 5c01834ee5a7,3d54af4c363d..000000000000
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@@ -5209,7 -5770,10 +5209,12 @@@ static bool sk_filter_is_valid_access(i
  	case bpf_ctx_range(struct __sk_buff, data):
  	case bpf_ctx_range(struct __sk_buff, data_meta):
  	case bpf_ctx_range(struct __sk_buff, data_end):
 -	case bpf_ctx_range(struct __sk_buff, flow_keys):
  	case bpf_ctx_range_till(struct __sk_buff, family, local_port):
++<<<<<<< HEAD
++=======
+ 	case bpf_ctx_range(struct __sk_buff, tstamp):
+ 	case bpf_ctx_range(struct __sk_buff, wire_len):
++>>>>>>> e3da08d05700 (bpf: allow BPF read access to qdisc pkt_len)
  		return false;
  	}
  
@@@ -5274,6 -5843,9 +5280,12 @@@ static bool lwt_is_valid_access(int off
  	case bpf_ctx_range(struct __sk_buff, tc_classid):
  	case bpf_ctx_range_till(struct __sk_buff, family, local_port):
  	case bpf_ctx_range(struct __sk_buff, data_meta):
++<<<<<<< HEAD
++=======
+ 	case bpf_ctx_range(struct __sk_buff, flow_keys):
+ 	case bpf_ctx_range(struct __sk_buff, tstamp):
+ 	case bpf_ctx_range(struct __sk_buff, wire_len):
++>>>>>>> e3da08d05700 (bpf: allow BPF read access to qdisc pkt_len)
  		return false;
  	}
  
@@@ -5694,6 -6274,9 +5706,12 @@@ static bool sk_skb_is_valid_access(int 
  	switch (off) {
  	case bpf_ctx_range(struct __sk_buff, tc_classid):
  	case bpf_ctx_range(struct __sk_buff, data_meta):
++<<<<<<< HEAD
++=======
+ 	case bpf_ctx_range(struct __sk_buff, flow_keys):
+ 	case bpf_ctx_range(struct __sk_buff, tstamp):
+ 	case bpf_ctx_range(struct __sk_buff, wire_len):
++>>>>>>> e3da08d05700 (bpf: allow BPF read access to qdisc pkt_len)
  		return false;
  	}
  
@@@ -5753,6 -6336,41 +5771,44 @@@ static bool sk_msg_is_valid_access(int 
  	return true;
  }
  
++<<<<<<< HEAD
++=======
+ static bool flow_dissector_is_valid_access(int off, int size,
+ 					   enum bpf_access_type type,
+ 					   const struct bpf_prog *prog,
+ 					   struct bpf_insn_access_aux *info)
+ {
+ 	if (type == BPF_WRITE) {
+ 		switch (off) {
+ 		case bpf_ctx_range_till(struct __sk_buff, cb[0], cb[4]):
+ 			break;
+ 		default:
+ 			return false;
+ 		}
+ 	}
+ 
+ 	switch (off) {
+ 	case bpf_ctx_range(struct __sk_buff, data):
+ 		info->reg_type = PTR_TO_PACKET;
+ 		break;
+ 	case bpf_ctx_range(struct __sk_buff, data_end):
+ 		info->reg_type = PTR_TO_PACKET_END;
+ 		break;
+ 	case bpf_ctx_range(struct __sk_buff, flow_keys):
+ 		info->reg_type = PTR_TO_FLOW_KEYS;
+ 		break;
+ 	case bpf_ctx_range(struct __sk_buff, tc_classid):
+ 	case bpf_ctx_range(struct __sk_buff, data_meta):
+ 	case bpf_ctx_range_till(struct __sk_buff, family, local_port):
+ 	case bpf_ctx_range(struct __sk_buff, tstamp):
+ 	case bpf_ctx_range(struct __sk_buff, wire_len):
+ 		return false;
+ 	}
+ 
+ 	return bpf_skb_is_valid_access(off, size, type, prog, info);
+ }
+ 
++>>>>>>> e3da08d05700 (bpf: allow BPF read access to qdisc pkt_len)
  static u32 bpf_convert_ctx_access(enum bpf_access_type type,
  				  const struct bpf_insn *si,
  				  struct bpf_insn *insn_buf,
@@@ -6050,6 -6665,42 +6106,45 @@@
  				      bpf_target_off(struct sock_common,
  						     skc_num, 2, target_size));
  		break;
++<<<<<<< HEAD
++=======
+ 
+ 	case offsetof(struct __sk_buff, flow_keys):
+ 		off  = si->off;
+ 		off -= offsetof(struct __sk_buff, flow_keys);
+ 		off += offsetof(struct sk_buff, cb);
+ 		off += offsetof(struct qdisc_skb_cb, flow_keys);
+ 		*insn++ = BPF_LDX_MEM(BPF_SIZEOF(void *), si->dst_reg,
+ 				      si->src_reg, off);
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, tstamp):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, tstamp) != 8);
+ 
+ 		if (type == BPF_WRITE)
+ 			*insn++ = BPF_STX_MEM(BPF_DW,
+ 					      si->dst_reg, si->src_reg,
+ 					      bpf_target_off(struct sk_buff,
+ 							     tstamp, 8,
+ 							     target_size));
+ 		else
+ 			*insn++ = BPF_LDX_MEM(BPF_DW,
+ 					      si->dst_reg, si->src_reg,
+ 					      bpf_target_off(struct sk_buff,
+ 							     tstamp, 8,
+ 							     target_size));
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, wire_len):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct qdisc_skb_cb, pkt_len) != 4);
+ 
+ 		off = si->off;
+ 		off -= offsetof(struct __sk_buff, wire_len);
+ 		off += offsetof(struct sk_buff, cb);
+ 		off += offsetof(struct qdisc_skb_cb, pkt_len);
+ 		*target_size = 4;
+ 		*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->src_reg, off);
++>>>>>>> e3da08d05700 (bpf: allow BPF read access to qdisc pkt_len)
  	}
  
  	return insn - insn_buf;
diff --cc tools/include/uapi/linux/bpf.h
index dd0da04bd3ab,0183b8e70a9e..000000000000
--- a/tools/include/uapi/linux/bpf.h
+++ b/tools/include/uapi/linux/bpf.h
@@@ -2291,6 -2495,9 +2291,12 @@@ struct __sk_buff 
  	/* ... here. */
  
  	__u32 data_meta;
++<<<<<<< HEAD
++=======
+ 	struct bpf_flow_keys *flow_keys;
+ 	__u64 tstamp;
+ 	__u32 wire_len;
++>>>>>>> e3da08d05700 (bpf: allow BPF read access to qdisc pkt_len)
  };
  
  struct bpf_tunnel_key {
* Unmerged path include/uapi/linux/bpf.h
* Unmerged path net/core/filter.c
* Unmerged path tools/include/uapi/linux/bpf.h
diff --git a/tools/testing/selftests/bpf/test_verifier.c b/tools/testing/selftests/bpf/test_verifier.c
index f055e79c6ae7..d78cf3bd2e0f 100644
--- a/tools/testing/selftests/bpf/test_verifier.c
+++ b/tools/testing/selftests/bpf/test_verifier.c
@@ -14004,6 +14004,38 @@ static struct bpf_test tests[] = {
 		.result_unpriv = REJECT,
 		.result = ACCEPT,
 	},
+	{
+		"check wire_len is not readable by sockets",
+		.insns = {
+			BPF_LDX_MEM(BPF_W, BPF_REG_0, BPF_REG_1,
+				    offsetof(struct __sk_buff, wire_len)),
+			BPF_EXIT_INSN(),
+		},
+		.errstr = "invalid bpf_context access",
+		.result = REJECT,
+	},
+	{
+		"check wire_len is readable by tc classifier",
+		.insns = {
+			BPF_LDX_MEM(BPF_W, BPF_REG_0, BPF_REG_1,
+				    offsetof(struct __sk_buff, wire_len)),
+			BPF_EXIT_INSN(),
+		},
+		.prog_type = BPF_PROG_TYPE_SCHED_CLS,
+		.result = ACCEPT,
+	},
+	{
+		"check wire_len is not writable by tc classifier",
+		.insns = {
+			BPF_STX_MEM(BPF_W, BPF_REG_1, BPF_REG_1,
+				    offsetof(struct __sk_buff, wire_len)),
+			BPF_EXIT_INSN(),
+		},
+		.prog_type = BPF_PROG_TYPE_SCHED_CLS,
+		.errstr = "invalid bpf_context access",
+		.errstr_unpriv = "R1 leaks addr",
+		.result = REJECT,
+	},
 };
 
 static int probe_filter_length(const struct bpf_insn *fp)
