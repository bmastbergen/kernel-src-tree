net: use indirect call wrappers at GRO network layer

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [net] use indirect call wrappers at GRO network layer (Paolo Abeni) [1700747]
Rebuild_FUZZ: 94.95%
commit-author Paolo Abeni <pabeni@redhat.com>
commit aaa5d90b395a72faff797b00d815165ee0e664c0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/aaa5d90b.failed

This avoids an indirect calls for L3 GRO receive path, both
for ipv4 and ipv6, if the latter is not compiled as a module.

Note that when IPv6 is compiled as builtin, it will be checked first,
so we have a single additional compare for the more common path.

v1 -> v2:
 - adapted to INDIRECT_CALL_ changes

	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit aaa5d90b395a72faff797b00d815165ee0e664c0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/dev.c
#	net/ipv6/ip6_offload.c
diff --cc net/core/dev.c
index 0aa2cd48e023,1b5a4410be0e..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -5269,14 -5490,39 +5274,40 @@@ static void gro_pull_from_frag0(struct 
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void gro_flush_oldest(struct list_head *head)
+ {
+ 	struct sk_buff *oldest;
+ 
+ 	oldest = list_last_entry(head, struct sk_buff, list);
+ 
+ 	/* We are called with head length >= MAX_GRO_SKBS, so this is
+ 	 * impossible.
+ 	 */
+ 	if (WARN_ON_ONCE(!oldest))
+ 		return;
+ 
+ 	/* Do not adjust napi->gro_hash[].count, caller is adding a new
+ 	 * SKB to the chain.
+ 	 */
+ 	skb_list_del_init(oldest);
+ 	napi_gro_complete(oldest);
+ }
+ 
+ INDIRECT_CALLABLE_DECLARE(struct sk_buff *inet_gro_receive(struct list_head *,
+ 							   struct sk_buff *));
+ INDIRECT_CALLABLE_DECLARE(struct sk_buff *ipv6_gro_receive(struct list_head *,
+ 							   struct sk_buff *));
++>>>>>>> aaa5d90b395a (net: use indirect call wrappers at GRO network layer)
  static enum gro_result dev_gro_receive(struct napi_struct *napi, struct sk_buff *skb)
  {
 -	u32 hash = skb_get_hash_raw(skb) & (GRO_HASH_BUCKETS - 1);
 -	struct list_head *head = &offload_base;
 +	struct sk_buff **pp = NULL;
  	struct packet_offload *ptype;
  	__be16 type = skb->protocol;
 -	struct list_head *gro_head;
 -	struct sk_buff *pp = NULL;
 -	enum gro_result ret;
 +	struct list_head *head = &offload_base;
  	int same_flow;
 +	enum gro_result ret;
  	int grow;
  
  	if (netif_elide_gro(skb->dev))
@@@ -5316,7 -5562,9 +5347,13 @@@
  			NAPI_GRO_CB(skb)->csum_valid = 0;
  		}
  
++<<<<<<< HEAD
 +		pp = ptype->callbacks.gro_receive(&napi->gro_list, skb);
++=======
+ 		pp = INDIRECT_CALL_INET(ptype->callbacks.gro_receive,
+ 					ipv6_gro_receive, inet_gro_receive,
+ 					gro_head, skb);
++>>>>>>> aaa5d90b395a (net: use indirect call wrappers at GRO network layer)
  		break;
  	}
  	rcu_read_unlock();
diff --cc net/ipv6/ip6_offload.c
index c6b75e96868c,ff8b484d2258..000000000000
--- a/net/ipv6/ip6_offload.c
+++ b/net/ipv6/ip6_offload.c
@@@ -164,11 -164,11 +164,16 @@@ static int ipv6_exthdrs_len(struct ipv6
  	return len;
  }
  
++<<<<<<< HEAD
 +static struct sk_buff **ipv6_gro_receive(struct sk_buff **head,
 +					 struct sk_buff *skb)
++=======
+ INDIRECT_CALLABLE_SCOPE struct sk_buff *ipv6_gro_receive(struct list_head *head,
+ 							 struct sk_buff *skb)
++>>>>>>> aaa5d90b395a (net: use indirect call wrappers at GRO network layer)
  {
  	const struct net_offload *ops;
 -	struct sk_buff *pp = NULL;
 +	struct sk_buff **pp = NULL;
  	struct sk_buff *p;
  	struct ipv6hdr *iph;
  	unsigned int nlen;
diff --git a/include/net/inet_common.h b/include/net/inet_common.h
index 384b90c62c0b..299a0f904564 100644
--- a/include/net/inet_common.h
+++ b/include/net/inet_common.h
@@ -2,6 +2,8 @@
 #ifndef _INET_COMMON_H
 #define _INET_COMMON_H
 
+#include <linux/indirect_call_wrapper.h>
+
 extern const struct proto_ops inet_stream_ops;
 extern const struct proto_ops inet_dgram_ops;
 
* Unmerged path net/core/dev.c
* Unmerged path net/ipv6/ip6_offload.c
