IB/hfi: Move RC functions into a header file

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Kaike Wan <kaike.wan@intel.com>
commit 385156c5f2a61834666f079ee66338f177c65c28
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/385156c5.failed

This patch moves some RC helper functions into a header file so that
they can be called from both RC and  TID RDMA functions. In addition,
a common function for rewinding a request is created in rdmavt so that
it can be shared between qib and hfi1 driver.

	Reviewed-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Signed-off-by: Mitko Haralanov <mitko.haralanov@intel.com>
	Signed-off-by: Kaike Wan <kaike.wan@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 385156c5f2a61834666f079ee66338f177c65c28)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/rc.c
diff --cc drivers/infiniband/hw/hfi1/rc.c
index 3158958b7198,6e74cd3814b8..000000000000
--- a/drivers/infiniband/hw/hfi1/rc.c
+++ b/drivers/infiniband/hw/hfi1/rc.c
@@@ -54,21 -55,44 +55,52 @@@
  #include "verbs_txreq.h"
  #include "trace.h"
  
++<<<<<<< HEAD
 +/* cut down ridiculously long IB macro names */
 +#define OP(x) RC_OP(x)
 +
 +static u32 restart_sge(struct rvt_sge_state *ss, struct rvt_swqe *wqe,
 +		       u32 psn, u32 pmtu)
++=======
+ struct rvt_ack_entry *find_prev_entry(struct rvt_qp *qp, u32 psn, u8 *prev,
+ 				      u8 *prev_ack, bool *scheduled)
+ 	__must_hold(&qp->s_lock)
++>>>>>>> 385156c5f2a6 (IB/hfi: Move RC functions into a header file)
  {
- 	u32 len;
+ 	struct rvt_ack_entry *e = NULL;
+ 	u8 i, p;
+ 	bool s = true;
  
- 	len = delta_psn(psn, wqe->psn) * pmtu;
- 	ss->sge = wqe->sg_list[0];
- 	ss->sg_list = wqe->sg_list + 1;
- 	ss->num_sge = wqe->wr.num_sge;
- 	ss->total_len = wqe->length;
- 	rvt_skip_sge(ss, len, false);
- 	return wqe->length - len;
+ 	for (i = qp->r_head_ack_queue; ; i = p) {
+ 		if (i == qp->s_tail_ack_queue)
+ 			s = false;
+ 		if (i)
+ 			p = i - 1;
+ 		else
+ 			p = rvt_size_atomic(ib_to_rvt(qp->ibqp.device));
+ 		if (p == qp->r_head_ack_queue) {
+ 			e = NULL;
+ 			break;
+ 		}
+ 		e = &qp->s_ack_queue[p];
+ 		if (!e->opcode) {
+ 			e = NULL;
+ 			break;
+ 		}
+ 		if (cmp_psn(psn, e->psn) >= 0) {
+ 			if (p == qp->s_tail_ack_queue &&
+ 			    cmp_psn(psn, e->lpsn) <= 0)
+ 				s = false;
+ 			break;
+ 		}
+ 	}
+ 	if (prev)
+ 		*prev = p;
+ 	if (prev_ack)
+ 		*prev_ack = i;
+ 	if (scheduled)
+ 		*scheduled = s;
+ 	return e;
  }
  
  /**
@@@ -1810,29 -1854,8 +1833,34 @@@ static noinline int rc_rcv_error(struc
  
  	spin_lock_irqsave(&qp->s_lock, flags);
  
++<<<<<<< HEAD
 +	for (i = qp->r_head_ack_queue; ; i = prev) {
 +		if (i == qp->s_tail_ack_queue)
 +			old_req = 0;
 +		if (i)
 +			prev = i - 1;
 +		else
 +			prev = HFI1_MAX_RDMA_ATOMIC;
 +		if (prev == qp->r_head_ack_queue) {
 +			e = NULL;
 +			break;
 +		}
 +		e = &qp->s_ack_queue[prev];
 +		if (!e->opcode) {
 +			e = NULL;
 +			break;
 +		}
 +		if (cmp_psn(psn, e->psn) >= 0) {
 +			if (prev == qp->s_tail_ack_queue &&
 +			    cmp_psn(psn, e->lpsn) <= 0)
 +				old_req = 0;
 +			break;
 +		}
 +	}
++=======
+ 	e = find_prev_entry(qp, psn, &prev, &mra, &old_req);
+ 
++>>>>>>> 385156c5f2a6 (IB/hfi: Move RC functions into a header file)
  	switch (opcode) {
  	case OP(RDMA_READ_REQUEST): {
  		struct ib_reth *reth;
@@@ -1935,17 -1958,6 +1963,20 @@@ send_ack
  	return 0;
  }
  
++<<<<<<< HEAD
 +static inline void update_ack_queue(struct rvt_qp *qp, unsigned n)
 +{
 +	unsigned next;
 +
 +	next = n + 1;
 +	if (next > HFI1_MAX_RDMA_ATOMIC)
 +		next = 0;
 +	qp->s_tail_ack_queue = next;
 +	qp->s_ack_state = OP(ACKNOWLEDGE);
 +}
 +
++=======
++>>>>>>> 385156c5f2a6 (IB/hfi: Move RC functions into a header file)
  static void log_cca_event(struct hfi1_pportdata *ppd, u8 sl, u32 rlid,
  			  u32 lqpn, u32 rqpn, u8 svc_type)
  {
* Unmerged path drivers/infiniband/hw/hfi1/rc.c
diff --git a/drivers/infiniband/hw/hfi1/rc.h b/drivers/infiniband/hw/hfi1/rc.h
new file mode 100644
index 000000000000..4329eadcb3df
--- /dev/null
+++ b/drivers/infiniband/hw/hfi1/rc.h
@@ -0,0 +1,50 @@
+/* SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause) */
+/*
+ * Copyright(c) 2018 Intel Corporation.
+ *
+ */
+
+#ifndef HFI1_RC_H
+#define HFI1_RC_H
+
+/* cut down ridiculously long IB macro names */
+#define OP(x) IB_OPCODE_RC_##x
+
+static inline void update_ack_queue(struct rvt_qp *qp, unsigned int n)
+{
+	unsigned int next;
+
+	next = n + 1;
+	if (next > rvt_size_atomic(ib_to_rvt(qp->ibqp.device)))
+		next = 0;
+	qp->s_tail_ack_queue = next;
+	qp->s_ack_state = OP(ACKNOWLEDGE);
+}
+
+static inline void rc_defered_ack(struct hfi1_ctxtdata *rcd,
+				  struct rvt_qp *qp)
+{
+	if (list_empty(&qp->rspwait)) {
+		qp->r_flags |= RVT_R_RSP_NAK;
+		rvt_get_qp(qp);
+		list_add_tail(&qp->rspwait, &rcd->qp_wait_list);
+	}
+}
+
+static inline u32 restart_sge(struct rvt_sge_state *ss, struct rvt_swqe *wqe,
+			      u32 psn, u32 pmtu)
+{
+	u32 len;
+
+	len = delta_psn(psn, wqe->psn) * pmtu;
+	return rvt_restart_sge(ss, wqe, len);
+}
+
+struct rvt_ack_entry *find_prev_entry(struct rvt_qp *qp, u32 psn, u8 *prev,
+				      u8 *prev_ack, bool *scheduled);
+int do_rc_ack(struct rvt_qp *qp, u32 aeth, u32 psn, int opcode, u64 val,
+	      struct hfi1_ctxtdata *rcd);
+struct rvt_swqe *do_rc_completion(struct rvt_qp *qp, struct rvt_swqe *wqe,
+				  struct hfi1_ibport *ibp);
+
+#endif /* HFI1_RC_H */
diff --git a/drivers/infiniband/hw/qib/qib_rc.c b/drivers/infiniband/hw/qib/qib_rc.c
index f35fdeb14347..b70180476637 100644
--- a/drivers/infiniband/hw/qib/qib_rc.c
+++ b/drivers/infiniband/hw/qib/qib_rc.c
@@ -45,12 +45,7 @@ static u32 restart_sge(struct rvt_sge_state *ss, struct rvt_swqe *wqe,
 	u32 len;
 
 	len = ((psn - wqe->psn) & QIB_PSN_MASK) * pmtu;
-	ss->sge = wqe->sg_list[0];
-	ss->sg_list = wqe->sg_list + 1;
-	ss->num_sge = wqe->wr.num_sge;
-	ss->total_len = wqe->length;
-	rvt_skip_sge(ss, len, false);
-	return wqe->length - len;
+	return rvt_restart_sge(ss, wqe, len);
 }
 
 /**
diff --git a/drivers/infiniband/sw/rdmavt/rc.c b/drivers/infiniband/sw/rdmavt/rc.c
index 6131cc558bdb..8d71647820a8 100644
--- a/drivers/infiniband/sw/rdmavt/rc.c
+++ b/drivers/infiniband/sw/rdmavt/rc.c
@@ -187,3 +187,16 @@ void rvt_get_credit(struct rvt_qp *qp, u32 aeth)
 	}
 }
 EXPORT_SYMBOL(rvt_get_credit);
+
+/* rvt_restart_sge - rewind the sge state for a wqe */
+u32 rvt_restart_sge(struct rvt_sge_state *ss, struct rvt_swqe *wqe, u32 len)
+{
+	ss->sge = wqe->sg_list[0];
+	ss->sg_list = wqe->sg_list + 1;
+	ss->num_sge = wqe->wr.num_sge;
+	ss->total_len = wqe->length;
+	rvt_skip_sge(ss, len, false);
+	return wqe->length - len;
+}
+EXPORT_SYMBOL(rvt_restart_sge);
+
diff --git a/include/rdma/rdmavt_qp.h b/include/rdma/rdmavt_qp.h
index 927f6d5b6d0f..d27945558799 100644
--- a/include/rdma/rdmavt_qp.h
+++ b/include/rdma/rdmavt_qp.h
@@ -628,6 +628,16 @@ __be32 rvt_compute_aeth(struct rvt_qp *qp);
  */
 void rvt_get_credit(struct rvt_qp *qp, u32 aeth);
 
+/**
+ * rvt_restart_sge - rewind the sge state for a wqe
+ * @ss: the sge state pointer
+ * @wqe: the wqe to rewind
+ * @len: the data length from the start of the wqe in bytes
+ *
+ * Returns the remaining data length.
+ */
+u32 rvt_restart_sge(struct rvt_sge_state *ss, struct rvt_swqe *wqe, u32 len);
+
 /**
  * @qp - the qp pair
  * @len - the length
