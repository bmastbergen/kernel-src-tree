bpf: verbose log bpf_line_info in verifier

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Martin KaFai Lau <kafai@fb.com>
commit d9762e84ede3eae9636f5dbbe0c8f0390d37e114
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/d9762e84.failed

This patch adds bpf_line_info during the verifier's verbose.
It can give error context for debug purpose.

~~~~~~~~~~
Here is the verbose log for backedge:
	while (a) {
		a += bpf_get_smp_processor_id();
		bpf_trace_printk(fmt, sizeof(fmt), a);
	}

~> bpftool prog load ./test_loop.o /sys/fs/bpf/test_loop type tracepoint
13: while (a) {
3: a += bpf_get_smp_processor_id();
back-edge from insn 13 to 3

~~~~~~~~~~
Here is the verbose log for invalid pkt access:
Modification to test_xdp_noinline.c:

	data = (void *)(long)xdp->data;
	data_end = (void *)(long)xdp->data_end;
/*
	if (data + 4 > data_end)
		return XDP_DROP;
*/
	*(u32 *)data = dst->dst;

~> bpftool prog load ./test_xdp_noinline.o /sys/fs/bpf/test_xdp_noinline type xdp
; data = (void *)(long)xdp->data;
224: (79) r2 = *(u64 *)(r10 -112)
225: (61) r2 = *(u32 *)(r2 +0)
; *(u32 *)data = dst->dst;
226: (63) *(u32 *)(r2 +0) = r1
invalid access to packet, off=0 size=4, R2(id=0,off=0,r=0)
R2 offset is outside of the packet

	Signed-off-by: Martin KaFai Lau <kafai@fb.com>
	Acked-by: Yonghong Song <yhs@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit d9762e84ede3eae9636f5dbbe0c8f0390d37e114)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/verifier.c
diff --cc kernel/bpf/verifier.c
index 214ce04692a3,ba8e3134bbc2..000000000000
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@@ -5015,7 -5580,8 +5074,12 @@@ static int do_check(struct bpf_verifier
  				.private_data	= env,
  			};
  
++<<<<<<< HEAD
 +			verbose(env, "%d: ", env->insn_idx);
++=======
+ 			verbose_linfo(env, insn_idx, "; ");
+ 			verbose(env, "%d: ", insn_idx);
++>>>>>>> d9762e84ede3 (bpf: verbose log bpf_line_info in verifier)
  			print_bpf_insn(&cbs, insn, env->allow_ptr_leaks);
  		}
  
@@@ -6268,10 -6815,18 +6332,21 @@@ int bpf_check(struct bpf_prog **prog, u
  
  	env->allow_ptr_leaks = capable(CAP_SYS_ADMIN);
  
+ 	ret = check_subprogs(env);
+ 	if (ret < 0)
+ 		goto skip_full_check;
+ 
++<<<<<<< HEAD
++=======
+ 	ret = check_btf_info(env, attr, uattr);
+ 	if (ret < 0)
+ 		goto skip_full_check;
+ 
  	ret = check_cfg(env);
  	if (ret < 0)
  		goto skip_full_check;
  
++>>>>>>> d9762e84ede3 (bpf: verbose log bpf_line_info in verifier)
  	ret = do_check(env);
  	if (env->cur_state) {
  		free_verifier_state(env->cur_state, true);
diff --git a/include/linux/bpf_verifier.h b/include/linux/bpf_verifier.h
index 60fc755117b1..68b76ae07eae 100644
--- a/include/linux/bpf_verifier.h
+++ b/include/linux/bpf_verifier.h
@@ -221,6 +221,7 @@ struct bpf_verifier_env {
 	bool allow_ptr_leaks;
 	bool seen_direct_write;
 	struct bpf_insn_aux_data *insn_aux_data; /* array of per-insn state */
+	const struct bpf_line_info *prev_linfo;
 	struct bpf_verifier_log log;
 	struct bpf_subprog_info subprog_info[BPF_MAX_SUBPROGS + 1];
 	u32 subprog_cnt;
* Unmerged path kernel/bpf/verifier.c
