mlxsw: spectrum_acl: Split TCAM group structure into two

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jiri Pirko <jiri@mellanox.com>
commit 2802aadfcff32a61d4afe78c07137dac63cd8d3c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/2802aadf.failed

Make the existing group structure to contain fields needed for HW region
list manipulations. Move the rest of the fields into new vgroup struct.
This makes layering cleaner as the vgroup struct is on higher level than
low-level group struct. Also, this makes it possible to introduce
fine-grained locking.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2802aadfcff32a61d4afe78c07137dac63cd8d3c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
index c607c62a43ae,922f17adcee7..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
@@@ -164,10 -177,15 +169,9 @@@ struct mlxsw_sp_acl_tcam_vgroup 
  
  struct mlxsw_sp_acl_tcam_vregion {
  	struct mlxsw_sp_acl_tcam_region *region;
 -	struct mlxsw_sp_acl_tcam_region *region2; /* Used during migration */
  	struct list_head list; /* Member of a TCAM group */
 -	struct list_head tlist; /* Member of a TCAM */
  	struct list_head vchunk_list; /* List of vchunks under this vregion */
- 	struct mlxsw_sp_acl_tcam_group *group;
  	struct mlxsw_afk_key_info *key_info;
 -	struct mlxsw_sp_acl_tcam *tcam;
 -	struct delayed_work rehash_dw;
 -	struct mlxsw_sp *mlxsw_sp;
 -	bool failed_rollback; /* Indicates failed rollback during migration */
  };
  
  struct mlxsw_sp_acl_tcam_vchunk;
@@@ -180,10 -199,12 +184,10 @@@ struct mlxsw_sp_acl_tcam_chunk 
  
  struct mlxsw_sp_acl_tcam_vchunk {
  	struct mlxsw_sp_acl_tcam_chunk *chunk;
 -	struct mlxsw_sp_acl_tcam_chunk *chunk2; /* Used during migration */
  	struct list_head list; /* Member of a TCAM vregion */
  	struct rhash_head ht_node; /* Member of a chunk HT */
 -	struct list_head ventry_list;
  	unsigned int priority; /* Priority within the vregion and group */
- 	struct mlxsw_sp_acl_tcam_group *group;
+ 	struct mlxsw_sp_acl_tcam_vgroup *vgroup;
  	struct mlxsw_sp_acl_tcam_vregion *vregion;
  	unsigned int ref_count;
  };
@@@ -214,9 -238,16 +218,22 @@@ static int mlxsw_sp_acl_tcam_group_upda
  	int acl_index = 0;
  
  	mlxsw_reg_pagt_pack(pagt_pl, group->id);
++<<<<<<< HEAD
 +	list_for_each_entry(vregion, &group->vregion_list, list)
 +		mlxsw_reg_pagt_acl_id_pack(pagt_pl, acl_index++,
 +					   vregion->region->id, false);
++=======
+ 	list_for_each_entry(region, &group->region_list, list) {
+ 		bool multi = false;
+ 
+ 		/* Check if the next entry in the list has the same vregion. */
+ 		if (region->list.next != &group->region_list &&
+ 		    list_next_entry(region, list)->vregion == region->vregion)
+ 			multi = true;
+ 		mlxsw_reg_pagt_acl_id_pack(pagt_pl, acl_index++,
+ 					   region->id, multi);
+ 	}
++>>>>>>> 2802aadfcff3 (mlxsw: spectrum_acl: Split TCAM group structure into two)
  	mlxsw_reg_pagt_size_set(pagt_pl, acl_index);
  	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(pagt), pagt_pl);
  }
@@@ -386,10 -465,13 +451,10 @@@ err_region_attach
  }
  
  static void
- mlxsw_sp_acl_tcam_group_vregion_detach(struct mlxsw_sp *mlxsw_sp,
- 				       struct mlxsw_sp_acl_tcam_vregion *vregion)
+ mlxsw_sp_acl_tcam_vgroup_vregion_detach(struct mlxsw_sp *mlxsw_sp,
+ 					struct mlxsw_sp_acl_tcam_vregion *vregion)
  {
  	list_del(&vregion->list);
 -	if (vregion->region2)
 -		mlxsw_sp_acl_tcam_group_region_detach(mlxsw_sp,
 -						      vregion->region2);
  	mlxsw_sp_acl_tcam_group_region_detach(mlxsw_sp, vregion->region);
  }
  
@@@ -648,9 -781,44 +713,9 @@@ mlxsw_sp_acl_tcam_vregion_destroy(struc
  	kfree(vregion);
  }
  
 -u32 mlxsw_sp_acl_tcam_vregion_rehash_intrvl_get(struct mlxsw_sp *mlxsw_sp,
 -						struct mlxsw_sp_acl_tcam *tcam)
 -{
 -	const struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;
 -	u32 vregion_rehash_intrvl;
 -
 -	if (WARN_ON(!ops->region_rehash_hints_get))
 -		return 0;
 -	vregion_rehash_intrvl = tcam->vregion_rehash_intrvl;
 -	return vregion_rehash_intrvl;
 -}
 -
 -int mlxsw_sp_acl_tcam_vregion_rehash_intrvl_set(struct mlxsw_sp *mlxsw_sp,
 -						struct mlxsw_sp_acl_tcam *tcam,
 -						u32 val)
 -{
 -	const struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;
 -	struct mlxsw_sp_acl_tcam_vregion *vregion;
 -
 -	if (val < MLXSW_SP_ACL_TCAM_VREGION_REHASH_INTRVL_MIN && val)
 -		return -EINVAL;
 -	if (WARN_ON(!ops->region_rehash_hints_get))
 -		return -EOPNOTSUPP;
 -	tcam->vregion_rehash_intrvl = val;
 -	rtnl_lock();
 -	list_for_each_entry(vregion, &tcam->vregion_list, tlist) {
 -		if (val)
 -			mlxsw_core_schedule_dw(&vregion->rehash_dw, 0);
 -		else
 -			cancel_delayed_work_sync(&vregion->rehash_dw);
 -	}
 -	rtnl_unlock();
 -	return 0;
 -}
 -
  static int
  mlxsw_sp_acl_tcam_vchunk_assoc(struct mlxsw_sp *mlxsw_sp,
- 			       struct mlxsw_sp_acl_tcam_group *group,
+ 			       struct mlxsw_sp_acl_tcam_vgroup *vgroup,
  			       unsigned int priority,
  			       struct mlxsw_afk_element_usage *elusage,
  			       struct mlxsw_sp_acl_tcam_vchunk *vchunk)
@@@ -756,11 -926,12 +822,11 @@@ mlxsw_sp_acl_tcam_vchunk_create(struct 
  	vchunk = kzalloc(sizeof(*vchunk), GFP_KERNEL);
  	if (!vchunk)
  		return ERR_PTR(-ENOMEM);
 -	INIT_LIST_HEAD(&vchunk->ventry_list);
  	vchunk->priority = priority;
- 	vchunk->group = group;
+ 	vchunk->vgroup = vgroup;
  	vchunk->ref_count = 1;
  
- 	err = mlxsw_sp_acl_tcam_vchunk_assoc(mlxsw_sp, group, priority,
+ 	err = mlxsw_sp_acl_tcam_vchunk_assoc(mlxsw_sp, vgroup, priority,
  					     elusage, vchunk);
  	if (err)
  		goto err_vchunk_assoc;
@@@ -793,10 -964,12 +859,10 @@@ static voi
  mlxsw_sp_acl_tcam_vchunk_destroy(struct mlxsw_sp *mlxsw_sp,
  				 struct mlxsw_sp_acl_tcam_vchunk *vchunk)
  {
- 	struct mlxsw_sp_acl_tcam_group *group = vchunk->group;
+ 	struct mlxsw_sp_acl_tcam_vgroup *vgroup = vchunk->vgroup;
  
 -	if (vchunk->chunk2)
 -		mlxsw_sp_acl_tcam_chunk_destroy(mlxsw_sp, vchunk->chunk2);
  	mlxsw_sp_acl_tcam_chunk_destroy(mlxsw_sp, vchunk->chunk);
- 	rhashtable_remove_fast(&group->vchunk_ht, &vchunk->ht_node,
+ 	rhashtable_remove_fast(&vgroup->vchunk_ht, &vchunk->ht_node,
  			       mlxsw_sp_acl_tcam_vchunk_ht_params);
  	mlxsw_sp_acl_tcam_vchunk_deassoc(mlxsw_sp, vchunk);
  	kfree(vchunk);
@@@ -958,6 -1127,184 +1024,187 @@@ mlxsw_sp_acl_tcam_ventry_activity_get(s
  						    ventry->entry, activity);
  }
  
++<<<<<<< HEAD
++=======
+ static int
+ mlxsw_sp_acl_tcam_ventry_migrate(struct mlxsw_sp *mlxsw_sp,
+ 				 struct mlxsw_sp_acl_tcam_ventry *ventry,
+ 				 struct mlxsw_sp_acl_tcam_chunk *chunk2)
+ {
+ 	struct mlxsw_sp_acl_tcam_entry *entry2;
+ 
+ 	entry2 = mlxsw_sp_acl_tcam_entry_create(mlxsw_sp, ventry, chunk2);
+ 	if (IS_ERR(entry2))
+ 		return PTR_ERR(entry2);
+ 	mlxsw_sp_acl_tcam_entry_destroy(mlxsw_sp, ventry->entry);
+ 	ventry->entry = entry2;
+ 	return 0;
+ }
+ 
+ static int
+ mlxsw_sp_acl_tcam_vchunk_migrate_one(struct mlxsw_sp *mlxsw_sp,
+ 				     struct mlxsw_sp_acl_tcam_vchunk *vchunk,
+ 				     struct mlxsw_sp_acl_tcam_region *region,
+ 				     bool this_is_rollback)
+ {
+ 	struct mlxsw_sp_acl_tcam_ventry *ventry;
+ 	struct mlxsw_sp_acl_tcam_chunk *chunk2;
+ 	int err;
+ 	int err2;
+ 
+ 	chunk2 = mlxsw_sp_acl_tcam_chunk_create(mlxsw_sp, vchunk, region);
+ 	if (IS_ERR(chunk2)) {
+ 		if (this_is_rollback)
+ 			vchunk->vregion->failed_rollback = true;
+ 		return PTR_ERR(chunk2);
+ 	}
+ 	vchunk->chunk2 = chunk2;
+ 	list_for_each_entry(ventry, &vchunk->ventry_list, list) {
+ 		err = mlxsw_sp_acl_tcam_ventry_migrate(mlxsw_sp, ventry,
+ 						       vchunk->chunk2);
+ 		if (err) {
+ 			if (this_is_rollback) {
+ 				vchunk->vregion->failed_rollback = true;
+ 				return err;
+ 			}
+ 			goto rollback;
+ 		}
+ 	}
+ 	mlxsw_sp_acl_tcam_chunk_destroy(mlxsw_sp, vchunk->chunk);
+ 	vchunk->chunk = chunk2;
+ 	vchunk->chunk2 = NULL;
+ 	return 0;
+ 
+ rollback:
+ 	/* Migrate the entries back to the original chunk. If some entry
+ 	 * migration fails, there's no good way how to proceed. Set the
+ 	 * vregion with "failed_rollback" flag.
+ 	 */
+ 	list_for_each_entry_continue_reverse(ventry, &vchunk->ventry_list,
+ 					     list) {
+ 		err2 = mlxsw_sp_acl_tcam_ventry_migrate(mlxsw_sp, ventry,
+ 							vchunk->chunk);
+ 		if (err2) {
+ 			vchunk->vregion->failed_rollback = true;
+ 			goto err_rollback;
+ 		}
+ 	}
+ 
+ 	mlxsw_sp_acl_tcam_chunk_destroy(mlxsw_sp, vchunk->chunk2);
+ 	vchunk->chunk2 = NULL;
+ 
+ err_rollback:
+ 	return err;
+ }
+ 
+ static int
+ mlxsw_sp_acl_tcam_vchunk_migrate_all(struct mlxsw_sp *mlxsw_sp,
+ 				     struct mlxsw_sp_acl_tcam_vregion *vregion)
+ {
+ 	struct mlxsw_sp_acl_tcam_vchunk *vchunk;
+ 	int err;
+ 
+ 	list_for_each_entry(vchunk, &vregion->vchunk_list, list) {
+ 		err = mlxsw_sp_acl_tcam_vchunk_migrate_one(mlxsw_sp, vchunk,
+ 							   vregion->region2,
+ 							   false);
+ 		if (err)
+ 			goto rollback;
+ 	}
+ 	return 0;
+ 
+ rollback:
+ 	list_for_each_entry_continue_reverse(vchunk, &vregion->vchunk_list,
+ 					     list) {
+ 		mlxsw_sp_acl_tcam_vchunk_migrate_one(mlxsw_sp, vchunk,
+ 						     vregion->region, true);
+ 	}
+ 	return err;
+ }
+ 
+ static int
+ mlxsw_sp_acl_tcam_vregion_migrate(struct mlxsw_sp *mlxsw_sp,
+ 				  struct mlxsw_sp_acl_tcam_vregion *vregion,
+ 				  void *hints_priv)
+ {
+ 	struct mlxsw_sp_acl_tcam_region *region2, *unused_region;
+ 	int err;
+ 
+ 	trace_mlxsw_sp_acl_tcam_vregion_migrate(mlxsw_sp, vregion);
+ 
+ 	region2 = mlxsw_sp_acl_tcam_region_create(mlxsw_sp, vregion->tcam,
+ 						  vregion, hints_priv);
+ 	if (IS_ERR(region2))
+ 		return PTR_ERR(region2);
+ 
+ 	vregion->region2 = region2;
+ 	err = mlxsw_sp_acl_tcam_group_region_attach(mlxsw_sp,
+ 						    vregion->region->group,
+ 						    region2, vregion->region);
+ 	if (err)
+ 		goto err_group_region_attach;
+ 
+ 	err = mlxsw_sp_acl_tcam_vchunk_migrate_all(mlxsw_sp, vregion);
+ 	if (!vregion->failed_rollback) {
+ 		if (!err) {
+ 			/* In case of successful migration, region2 is used and
+ 			 * the original is unused.
+ 			 */
+ 			unused_region = vregion->region;
+ 			vregion->region = vregion->region2;
+ 		} else {
+ 			/* In case of failure during migration, the original
+ 			 * region is still used.
+ 			 */
+ 			unused_region = vregion->region2;
+ 		}
+ 		vregion->region2 = NULL;
+ 		mlxsw_sp_acl_tcam_group_region_detach(mlxsw_sp, unused_region);
+ 		mlxsw_sp_acl_tcam_region_destroy(mlxsw_sp, unused_region);
+ 	}
+ 	return err;
+ 
+ err_group_region_attach:
+ 	vregion->region2 = NULL;
+ 	mlxsw_sp_acl_tcam_region_destroy(mlxsw_sp, region2);
+ 	return err;
+ }
+ 
+ static int
+ mlxsw_sp_acl_tcam_vregion_rehash(struct mlxsw_sp *mlxsw_sp,
+ 				 struct mlxsw_sp_acl_tcam_vregion *vregion)
+ {
+ 	const struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;
+ 	void *hints_priv;
+ 	int err;
+ 
+ 	trace_mlxsw_sp_acl_tcam_vregion_rehash(mlxsw_sp, vregion);
+ 	if (vregion->failed_rollback)
+ 		return -EBUSY;
+ 
+ 	hints_priv = ops->region_rehash_hints_get(vregion->region->priv);
+ 	if (IS_ERR(hints_priv)) {
+ 		err = PTR_ERR(hints_priv);
+ 		if (err != -EAGAIN)
+ 			dev_err(mlxsw_sp->bus_info->dev, "Failed get rehash hints\n");
+ 		return err;
+ 	}
+ 
+ 	err = mlxsw_sp_acl_tcam_vregion_migrate(mlxsw_sp, vregion, hints_priv);
+ 	if (err) {
+ 		dev_err(mlxsw_sp->bus_info->dev, "Failed to migrate vregion\n");
+ 		if (vregion->failed_rollback) {
+ 			trace_mlxsw_sp_acl_tcam_vregion_rehash_dis(mlxsw_sp,
+ 								   vregion);
+ 			dev_err(mlxsw_sp->bus_info->dev, "Failed to rollback during vregion migration fail\n");
+ 		}
+ 	}
+ 
+ 	ops->region_rehash_hints_put(hints_priv);
+ 	return err;
+ }
+ 
++>>>>>>> 2802aadfcff3 (mlxsw: spectrum_acl: Split TCAM group structure into two)
  static const enum mlxsw_afk_element mlxsw_sp_acl_tcam_pattern_ipv4[] = {
  	MLXSW_AFK_ELEMENT_SRC_SYS_PORT,
  	MLXSW_AFK_ELEMENT_DMAC_32_47,
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h b/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h
index a90942bc1fe9..e01778fe7960 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h
@@ -71,6 +71,8 @@ struct mlxsw_sp_acl_tcam_vregion;
 
 struct mlxsw_sp_acl_tcam_region {
 	struct mlxsw_sp_acl_tcam_vregion *vregion;
+	struct mlxsw_sp_acl_tcam_group *group;
+	struct list_head list; /* Member of a TCAM group */
 	enum mlxsw_reg_ptar_key_type key_type;
 	u16 id; /* ACL ID and region ID - they are same */
 	char tcam_region_info[MLXSW_REG_PXXX_TCAM_REGION_INFO_LEN];
