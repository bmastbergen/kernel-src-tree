KVM: arm64/sve: Allow userspace to enable SVE for vcpus

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Dave Martin <Dave.Martin@arm.com>
commit 9a3cdf26e3363ec5460ebe20c508114fa63bcf26
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/9a3cdf26.failed

Now that all the pieces are in place, this patch offers a new flag
KVM_ARM_VCPU_SVE that userspace can pass to KVM_ARM_VCPU_INIT to
turn on SVE for the guest, on a per-vcpu basis.

As part of this, support for initialisation and reset of the SVE
vector length set and registers is added in the appropriate places,
as well as finally setting the KVM_ARM64_GUEST_HAS_SVE vcpu flag,
to turn on the SVE support code.

Allocation of the SVE register storage in vcpu->arch.sve_state is
deferred until the SVE configuration is finalized, by which time
the size of the registers is known.

Setting the vector lengths supported by the vcpu is considered
configuration of the emulated hardware rather than runtime
configuration, so no support is offered for changing the vector
lengths available to an existing vcpu across reset.

	Signed-off-by: Dave Martin <Dave.Martin@arm.com>
	Reviewed-by: Julien Thierry <julien.thierry@arm.com>
	Tested-by: zhang.lei <zhang.lei@jp.fujitsu.com>
	Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
(cherry picked from commit 9a3cdf26e3363ec5460ebe20c508114fa63bcf26)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/asm/kvm_host.h
#	arch/arm64/kvm/reset.c
diff --cc arch/arm64/include/asm/kvm_host.h
index 7eeddb2d82c2,9d57cf8be879..000000000000
--- a/arch/arm64/include/asm/kvm_host.h
+++ b/arch/arm64/include/asm/kvm_host.h
@@@ -43,7 -49,7 +43,11 @@@
  
  #define KVM_MAX_VCPUS VGIC_V3_MAX_CPUS
  
++<<<<<<< HEAD
 +#define KVM_VCPU_MAX_FEATURES 4
++=======
+ #define KVM_VCPU_MAX_FEATURES 5
++>>>>>>> 9a3cdf26e336 (KVM: arm64/sve: Allow userspace to enable SVE for vcpus)
  
  #define KVM_REQ_SLEEP \
  	KVM_ARCH_REQ_FLAGS(0, KVM_REQUEST_WAIT | KVM_REQUEST_NO_WAKEUP)
diff --cc arch/arm64/kvm/reset.c
index 9b8e8bd8b60b,32c5ac0a3872..000000000000
--- a/arch/arm64/kvm/reset.c
+++ b/arch/arm64/kvm/reset.c
@@@ -23,6 -24,9 +24,12 @@@
  #include <linux/kvm_host.h>
  #include <linux/kvm.h>
  #include <linux/hw_breakpoint.h>
++<<<<<<< HEAD
++=======
+ #include <linux/slab.h>
+ #include <linux/string.h>
+ #include <linux/types.h>
++>>>>>>> 9a3cdf26e336 (KVM: arm64/sve: Allow userspace to enable SVE for vcpus)
  
  #include <kvm/arm_arch_timer.h>
  
@@@ -32,7 -37,9 +39,8 @@@
  #include <asm/kvm_arm.h>
  #include <asm/kvm_asm.h>
  #include <asm/kvm_coproc.h>
 -#include <asm/kvm_emulate.h>
  #include <asm/kvm_mmu.h>
+ #include <asm/virt.h>
  
  /* Maximum phys_shift supported for any VM on this host */
  static u32 kvm_ipa_limit;
@@@ -95,6 -105,119 +103,122 @@@ int kvm_arch_vm_ioctl_check_extension(s
  	return r;
  }
  
++<<<<<<< HEAD
++=======
+ unsigned int kvm_sve_max_vl;
+ 
+ int kvm_arm_init_arch_resources(void)
+ {
+ 	if (system_supports_sve()) {
+ 		kvm_sve_max_vl = sve_max_virtualisable_vl;
+ 
+ 		/*
+ 		 * The get_sve_reg()/set_sve_reg() ioctl interface will need
+ 		 * to be extended with multiple register slice support in
+ 		 * order to support vector lengths greater than
+ 		 * SVE_VL_ARCH_MAX:
+ 		 */
+ 		if (WARN_ON(kvm_sve_max_vl > SVE_VL_ARCH_MAX))
+ 			kvm_sve_max_vl = SVE_VL_ARCH_MAX;
+ 
+ 		/*
+ 		 * Don't even try to make use of vector lengths that
+ 		 * aren't available on all CPUs, for now:
+ 		 */
+ 		if (kvm_sve_max_vl < sve_max_vl)
+ 			pr_warn("KVM: SVE vector length for guests limited to %u bytes\n",
+ 				kvm_sve_max_vl);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int kvm_vcpu_enable_sve(struct kvm_vcpu *vcpu)
+ {
+ 	if (!system_supports_sve())
+ 		return -EINVAL;
+ 
+ 	/* Verify that KVM startup enforced this when SVE was detected: */
+ 	if (WARN_ON(!has_vhe()))
+ 		return -EINVAL;
+ 
+ 	vcpu->arch.sve_max_vl = kvm_sve_max_vl;
+ 
+ 	/*
+ 	 * Userspace can still customize the vector lengths by writing
+ 	 * KVM_REG_ARM64_SVE_VLS.  Allocation is deferred until
+ 	 * kvm_arm_vcpu_finalize(), which freezes the configuration.
+ 	 */
+ 	vcpu->arch.flags |= KVM_ARM64_GUEST_HAS_SVE;
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Finalize vcpu's maximum SVE vector length, allocating
+  * vcpu->arch.sve_state as necessary.
+  */
+ static int kvm_vcpu_finalize_sve(struct kvm_vcpu *vcpu)
+ {
+ 	void *buf;
+ 	unsigned int vl;
+ 
+ 	vl = vcpu->arch.sve_max_vl;
+ 
+ 	/*
+ 	 * Resposibility for these properties is shared between
+ 	 * kvm_arm_init_arch_resources(), kvm_vcpu_enable_sve() and
+ 	 * set_sve_vls().  Double-check here just to be sure:
+ 	 */
+ 	if (WARN_ON(!sve_vl_valid(vl) || vl > sve_max_virtualisable_vl ||
+ 		    vl > SVE_VL_ARCH_MAX))
+ 		return -EIO;
+ 
+ 	buf = kzalloc(SVE_SIG_REGS_SIZE(sve_vq_from_vl(vl)), GFP_KERNEL);
+ 	if (!buf)
+ 		return -ENOMEM;
+ 
+ 	vcpu->arch.sve_state = buf;
+ 	vcpu->arch.flags |= KVM_ARM64_VCPU_SVE_FINALIZED;
+ 	return 0;
+ }
+ 
+ int kvm_arm_vcpu_finalize(struct kvm_vcpu *vcpu, int what)
+ {
+ 	switch (what) {
+ 	case KVM_ARM_VCPU_SVE:
+ 		if (!vcpu_has_sve(vcpu))
+ 			return -EINVAL;
+ 
+ 		if (kvm_arm_vcpu_sve_finalized(vcpu))
+ 			return -EPERM;
+ 
+ 		return kvm_vcpu_finalize_sve(vcpu);
+ 	}
+ 
+ 	return -EINVAL;
+ }
+ 
+ bool kvm_arm_vcpu_is_finalized(struct kvm_vcpu *vcpu)
+ {
+ 	if (vcpu_has_sve(vcpu) && !kvm_arm_vcpu_sve_finalized(vcpu))
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ void kvm_arch_vcpu_uninit(struct kvm_vcpu *vcpu)
+ {
+ 	kfree(vcpu->arch.sve_state);
+ }
+ 
+ static void kvm_vcpu_reset_sve(struct kvm_vcpu *vcpu)
+ {
+ 	if (vcpu_has_sve(vcpu))
+ 		memset(vcpu->arch.sve_state, 0, vcpu_sve_state_size(vcpu));
+ }
+ 
++>>>>>>> 9a3cdf26e336 (KVM: arm64/sve: Allow userspace to enable SVE for vcpus)
  /**
   * kvm_reset_vcpu - sets core registers and sys_regs to reset value
   * @vcpu: The VCPU pointer
* Unmerged path arch/arm64/include/asm/kvm_host.h
* Unmerged path arch/arm64/kvm/reset.c
