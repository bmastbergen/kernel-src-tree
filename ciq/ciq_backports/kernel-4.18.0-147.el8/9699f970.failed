x86/kvm/hyper-v: don't announce GUEST IDLE MSR support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 9699f970de84292a766709029e5135ea0b6c9aa9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/9699f970.failed

HV_X64_MSR_GUEST_IDLE_AVAILABLE appeared in kvm_vcpu_ioctl_get_hv_cpuid()
by mistake: it announces support for HV_X64_MSR_GUEST_IDLE (0x400000F0)
which we don't support in KVM (yet).

Fixes: 2bc39970e932 ("x86/kvm/hyper-v: Introduce KVM_GET_SUPPORTED_HV_CPUID")
	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 9699f970de84292a766709029e5135ea0b6c9aa9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/hyperv.c
diff --cc arch/x86/kvm/hyperv.c
index bd5751b7365c,ac44a681f065..000000000000
--- a/arch/x86/kvm/hyperv.c
+++ b/arch/x86/kvm/hyperv.c
@@@ -1669,3 -1768,123 +1669,126 @@@ int kvm_vm_ioctl_hv_eventfd(struct kvm 
  		return kvm_hv_eventfd_deassign(kvm, args->conn_id);
  	return kvm_hv_eventfd_assign(kvm, args->conn_id, args->fd);
  }
++<<<<<<< HEAD
++=======
+ 
+ int kvm_vcpu_ioctl_get_hv_cpuid(struct kvm_vcpu *vcpu, struct kvm_cpuid2 *cpuid,
+ 				struct kvm_cpuid_entry2 __user *entries)
+ {
+ 	uint16_t evmcs_ver = kvm_x86_ops->nested_get_evmcs_version(vcpu);
+ 	struct kvm_cpuid_entry2 cpuid_entries[] = {
+ 		{ .function = HYPERV_CPUID_VENDOR_AND_MAX_FUNCTIONS },
+ 		{ .function = HYPERV_CPUID_INTERFACE },
+ 		{ .function = HYPERV_CPUID_VERSION },
+ 		{ .function = HYPERV_CPUID_FEATURES },
+ 		{ .function = HYPERV_CPUID_ENLIGHTMENT_INFO },
+ 		{ .function = HYPERV_CPUID_IMPLEMENT_LIMITS },
+ 		{ .function = HYPERV_CPUID_NESTED_FEATURES },
+ 	};
+ 	int i, nent = ARRAY_SIZE(cpuid_entries);
+ 
+ 	/* Skip NESTED_FEATURES if eVMCS is not supported */
+ 	if (!evmcs_ver)
+ 		--nent;
+ 
+ 	if (cpuid->nent < nent)
+ 		return -E2BIG;
+ 
+ 	if (cpuid->nent > nent)
+ 		cpuid->nent = nent;
+ 
+ 	for (i = 0; i < nent; i++) {
+ 		struct kvm_cpuid_entry2 *ent = &cpuid_entries[i];
+ 		u32 signature[3];
+ 
+ 		switch (ent->function) {
+ 		case HYPERV_CPUID_VENDOR_AND_MAX_FUNCTIONS:
+ 			memcpy(signature, "Linux KVM Hv", 12);
+ 
+ 			ent->eax = HYPERV_CPUID_NESTED_FEATURES;
+ 			ent->ebx = signature[0];
+ 			ent->ecx = signature[1];
+ 			ent->edx = signature[2];
+ 			break;
+ 
+ 		case HYPERV_CPUID_INTERFACE:
+ 			memcpy(signature, "Hv#1\0\0\0\0\0\0\0\0", 12);
+ 			ent->eax = signature[0];
+ 			break;
+ 
+ 		case HYPERV_CPUID_VERSION:
+ 			/*
+ 			 * We implement some Hyper-V 2016 functions so let's use
+ 			 * this version.
+ 			 */
+ 			ent->eax = 0x00003839;
+ 			ent->ebx = 0x000A0000;
+ 			break;
+ 
+ 		case HYPERV_CPUID_FEATURES:
+ 			ent->eax |= HV_X64_MSR_VP_RUNTIME_AVAILABLE;
+ 			ent->eax |= HV_MSR_TIME_REF_COUNT_AVAILABLE;
+ 			ent->eax |= HV_X64_MSR_SYNIC_AVAILABLE;
+ 			ent->eax |= HV_MSR_SYNTIMER_AVAILABLE;
+ 			ent->eax |= HV_X64_MSR_APIC_ACCESS_AVAILABLE;
+ 			ent->eax |= HV_X64_MSR_HYPERCALL_AVAILABLE;
+ 			ent->eax |= HV_X64_MSR_VP_INDEX_AVAILABLE;
+ 			ent->eax |= HV_X64_MSR_RESET_AVAILABLE;
+ 			ent->eax |= HV_MSR_REFERENCE_TSC_AVAILABLE;
+ 			ent->eax |= HV_X64_ACCESS_FREQUENCY_MSRS;
+ 			ent->eax |= HV_X64_ACCESS_REENLIGHTENMENT;
+ 
+ 			ent->ebx |= HV_X64_POST_MESSAGES;
+ 			ent->ebx |= HV_X64_SIGNAL_EVENTS;
+ 
+ 			ent->edx |= HV_FEATURE_FREQUENCY_MSRS_AVAILABLE;
+ 			ent->edx |= HV_FEATURE_GUEST_CRASH_MSR_AVAILABLE;
+ 			ent->edx |= HV_STIMER_DIRECT_MODE_AVAILABLE;
+ 
+ 			break;
+ 
+ 		case HYPERV_CPUID_ENLIGHTMENT_INFO:
+ 			ent->eax |= HV_X64_REMOTE_TLB_FLUSH_RECOMMENDED;
+ 			ent->eax |= HV_X64_APIC_ACCESS_RECOMMENDED;
+ 			ent->eax |= HV_X64_SYSTEM_RESET_RECOMMENDED;
+ 			ent->eax |= HV_X64_RELAXED_TIMING_RECOMMENDED;
+ 			ent->eax |= HV_X64_CLUSTER_IPI_RECOMMENDED;
+ 			ent->eax |= HV_X64_EX_PROCESSOR_MASKS_RECOMMENDED;
+ 			ent->eax |= HV_X64_ENLIGHTENED_VMCS_RECOMMENDED;
+ 
+ 			/*
+ 			 * Default number of spinlock retry attempts, matches
+ 			 * HyperV 2016.
+ 			 */
+ 			ent->ebx = 0x00000FFF;
+ 
+ 			break;
+ 
+ 		case HYPERV_CPUID_IMPLEMENT_LIMITS:
+ 			/* Maximum number of virtual processors */
+ 			ent->eax = KVM_MAX_VCPUS;
+ 			/*
+ 			 * Maximum number of logical processors, matches
+ 			 * HyperV 2016.
+ 			 */
+ 			ent->ebx = 64;
+ 
+ 			break;
+ 
+ 		case HYPERV_CPUID_NESTED_FEATURES:
+ 			ent->eax = evmcs_ver;
+ 
+ 			break;
+ 
+ 		default:
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (copy_to_user(entries, cpuid_entries,
+ 			 nent * sizeof(struct kvm_cpuid_entry2)))
+ 		return -EFAULT;
+ 
+ 	return 0;
+ }
++>>>>>>> 9699f970de84 (x86/kvm/hyper-v: don't announce GUEST IDLE MSR support)
* Unmerged path arch/x86/kvm/hyperv.c
