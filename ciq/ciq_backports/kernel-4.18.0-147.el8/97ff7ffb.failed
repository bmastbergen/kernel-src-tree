net: use indirect calls helpers at early demux stage

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [net] use indirect calls helpers at early demux stage (Paolo Abeni) [1700747]
Rebuild_FUZZ: 94.95%
commit-author Paolo Abeni <pabeni@redhat.com>
commit 97ff7ffb11fe7a859a490771e7ce23f1f335176b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/97ff7ffb.failed

So that we avoid another indirect call per RX packet, if
early demux is enabled.

	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 97ff7ffb11fe7a859a490771e7ce23f1f335176b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/ip_input.c
#	net/ipv6/ip6_input.c
diff --cc net/ipv4/ip_input.c
index 7582713dd18f,ed97724c5e33..000000000000
--- a/net/ipv4/ip_input.c
+++ b/net/ipv4/ip_input.c
@@@ -307,7 -309,10 +307,14 @@@ drop
  	return true;
  }
  
++<<<<<<< HEAD
 +static int ip_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb)
++=======
+ INDIRECT_CALLABLE_DECLARE(int udp_v4_early_demux(struct sk_buff *));
+ INDIRECT_CALLABLE_DECLARE(int tcp_v4_early_demux(struct sk_buff *));
+ static int ip_rcv_finish_core(struct net *net, struct sock *sk,
+ 			      struct sk_buff *skb, struct net_device *dev)
++>>>>>>> 97ff7ffb11fe (net: use indirect calls helpers at early demux stage)
  {
  	const struct iphdr *iph = ip_hdr(skb);
  	int (*edemux)(struct sk_buff *skb);
diff --cc net/ipv6/ip6_input.c
index f08d34491ece,b50b1af1f530..000000000000
--- a/net/ipv6/ip6_input.c
+++ b/net/ipv6/ip6_input.c
@@@ -47,7 -48,10 +47,14 @@@
  #include <net/inet_ecn.h>
  #include <net/dst_metadata.h>
  
++<<<<<<< HEAD
 +int ip6_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb)
++=======
+ INDIRECT_CALLABLE_DECLARE(void udp_v6_early_demux(struct sk_buff *));
+ INDIRECT_CALLABLE_DECLARE(void tcp_v6_early_demux(struct sk_buff *));
+ static void ip6_rcv_finish_core(struct net *net, struct sock *sk,
+ 				struct sk_buff *skb)
++>>>>>>> 97ff7ffb11fe (net: use indirect calls helpers at early demux stage)
  {
  	void (*edemux)(struct sk_buff *skb);
  
* Unmerged path net/ipv4/ip_input.c
* Unmerged path net/ipv6/ip6_input.c
diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c
index 03e6b7a2bc53..ec79af4b4fb1 100644
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@ -1637,7 +1637,7 @@ static int tcp_v6_rcv(struct sk_buff *skb)
 	goto discard_it;
 }
 
-static void tcp_v6_early_demux(struct sk_buff *skb)
+INDIRECT_CALLABLE_SCOPE void tcp_v6_early_demux(struct sk_buff *skb)
 {
 	const struct ipv6hdr *hdr;
 	const struct tcphdr *th;
diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c
index e2839a12108d..778dd31b8bdb 100644
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@ -900,7 +900,7 @@ static struct sock *__udp6_lib_demux_lookup(struct net *net,
 	return NULL;
 }
 
-static void udp_v6_early_demux(struct sk_buff *skb)
+INDIRECT_CALLABLE_SCOPE void udp_v6_early_demux(struct sk_buff *skb)
 {
 	struct net *net = dev_net(skb->dev);
 	const struct udphdr *uh;
