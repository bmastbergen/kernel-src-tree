devlink: Add health report functionality

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Eran Ben Elisha <eranbe@mellanox.com>
commit c7af343b4e33578b7de91786a3f639c8cfa0d97b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/c7af343b.failed

Upon error discover, every driver can report it to the devlink health
mechanism via devlink_health_report function, using the appropriate
reporter registered to it. Driver can pass error specific context which
will be delivered to it as part of the dump / recovery callbacks.

Once an error is reported, devlink health will do the following actions:
* A log is being send to the kernel trace events buffer
* Health status and statistics are being updated for the reporter instance
* Object dump is being taken and stored at the reporter instance (as long
  as there is no other dump which is already stored)
* Auto recovery attempt is being done. depends on:
  - Auto Recovery configuration
  - Grace period vs. time since last recover

	Signed-off-by: Eran Ben Elisha <eranbe@mellanox.com>
	Reviewed-by: Moshe Shemesh <moshe@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c7af343b4e33578b7de91786a3f639c8cfa0d97b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/devlink.h
#	include/trace/events/devlink.h
#	net/core/devlink.c
diff --cc include/net/devlink.h
index 4d183c766687,a81a1b7a67d7..000000000000
--- a/include/net/devlink.h
+++ b/include/net/devlink.h
@@@ -605,51 -614,35 +605,58 @@@ u32 devlink_region_shapshot_id_get(stru
  int devlink_region_snapshot_create(struct devlink_region *region, u64 data_len,
  				   u8 *data, u32 snapshot_id,
  				   devlink_snapshot_data_dest_t *data_destructor);
 -
 -int devlink_health_buffer_nest_start(struct devlink_health_buffer *buffer,
 -				     int attrtype);
 -void devlink_health_buffer_nest_end(struct devlink_health_buffer *buffer);
 -void devlink_health_buffer_nest_cancel(struct devlink_health_buffer *buffer);
 -int devlink_health_buffer_put_object_name(struct devlink_health_buffer *buffer,
 -					  char *name);
 -int devlink_health_buffer_put_value_u8(struct devlink_health_buffer *buffer,
 -				       u8 value);
 -int devlink_health_buffer_put_value_u32(struct devlink_health_buffer *buffer,
 -					u32 value);
 -int devlink_health_buffer_put_value_u64(struct devlink_health_buffer *buffer,
 -					u64 value);
 -int devlink_health_buffer_put_value_string(struct devlink_health_buffer *buffer,
 -					   char *name);
 -int devlink_health_buffer_put_value_data(struct devlink_health_buffer *buffer,
 -					 void *data, int len);
 -struct devlink_health_reporter *
 -devlink_health_reporter_create(struct devlink *devlink,
 -			       const struct devlink_health_reporter_ops *ops,
 -			       u64 graceful_period, bool auto_recover,
 -			       void *priv);
 -void
 -devlink_health_reporter_destroy(struct devlink_health_reporter *reporter);
 -
 +int devlink_info_serial_number_put(struct devlink_info_req *req,
 +				   const char *sn);
 +int devlink_info_driver_name_put(struct devlink_info_req *req,
 +				 const char *name);
 +int devlink_info_version_fixed_put(struct devlink_info_req *req,
 +				   const char *version_name,
 +				   const char *version_value);
 +int devlink_info_version_stored_put(struct devlink_info_req *req,
 +				    const char *version_name,
 +				    const char *version_value);
 +int devlink_info_version_running_put(struct devlink_info_req *req,
 +				     const char *version_name,
 +				     const char *version_value);
 +
 +int devlink_fmsg_obj_nest_start(struct devlink_fmsg *fmsg);
 +int devlink_fmsg_obj_nest_end(struct devlink_fmsg *fmsg);
 +
 +int devlink_fmsg_pair_nest_start(struct devlink_fmsg *fmsg, const char *name);
 +int devlink_fmsg_pair_nest_end(struct devlink_fmsg *fmsg);
 +
 +int devlink_fmsg_arr_pair_nest_start(struct devlink_fmsg *fmsg,
 +				     const char *name);
 +int devlink_fmsg_arr_pair_nest_end(struct devlink_fmsg *fmsg);
 +
 +int devlink_fmsg_bool_put(struct devlink_fmsg *fmsg, bool value);
 +int devlink_fmsg_u8_put(struct devlink_fmsg *fmsg, u8 value);
 +int devlink_fmsg_u32_put(struct devlink_fmsg *fmsg, u32 value);
 +int devlink_fmsg_u64_put(struct devlink_fmsg *fmsg, u64 value);
 +int devlink_fmsg_string_put(struct devlink_fmsg *fmsg, const char *value);
 +int devlink_fmsg_binary_put(struct devlink_fmsg *fmsg, const void *value,
 +			    u16 value_len);
 +
 +int devlink_fmsg_bool_pair_put(struct devlink_fmsg *fmsg, const char *name,
 +			       bool value);
 +int devlink_fmsg_u8_pair_put(struct devlink_fmsg *fmsg, const char *name,
 +			     u8 value);
 +int devlink_fmsg_u32_pair_put(struct devlink_fmsg *fmsg, const char *name,
 +			      u32 value);
 +int devlink_fmsg_u64_pair_put(struct devlink_fmsg *fmsg, const char *name,
 +			      u64 value);
 +int devlink_fmsg_string_pair_put(struct devlink_fmsg *fmsg, const char *name,
 +				 const char *value);
 +int devlink_fmsg_binary_pair_put(struct devlink_fmsg *fmsg, const char *name,
 +				 const void *value, u16 value_len);
 +
++<<<<<<< HEAD
++=======
+ void *
+ devlink_health_reporter_priv(struct devlink_health_reporter *reporter);
+ int devlink_health_report(struct devlink_health_reporter *reporter,
+ 			  const char *msg, void *priv_ctx);
++>>>>>>> c7af343b4e33 (devlink: Add health report functionality)
  #else
  
  static inline struct devlink *devlink_alloc(const struct devlink_ops *ops,
@@@ -1050,64 -910,84 +1057,141 @@@ devlink_fmsg_string_put(struct devlink_
  	return 0;
  }
  
 +static inline int
 +devlink_fmsg_binary_put(struct devlink_fmsg *fmsg, const void *value,
 +			u16 value_len)
 +{
 +	return 0;
 +}
 +
 +static inline int
 +devlink_fmsg_bool_pair_put(struct devlink_fmsg *fmsg, const char *name,
 +			   bool value)
 +{
 +	return 0;
 +}
 +
 +static inline int
 +devlink_fmsg_u8_pair_put(struct devlink_fmsg *fmsg, const char *name,
 +			 u8 value)
 +{
 +	return 0;
 +}
 +
 +static inline int
 +devlink_fmsg_u32_pair_put(struct devlink_fmsg *fmsg, const char *name,
 +			  u32 value)
 +{
 +	return 0;
 +}
 +
 +static inline int
 +devlink_fmsg_u64_pair_put(struct devlink_fmsg *fmsg, const char *name,
 +			  u64 value)
 +{
 +	return 0;
 +}
 +
 +static inline int
 +devlink_fmsg_string_pair_put(struct devlink_fmsg *fmsg, const char *name,
 +			     const char *value)
 +{
 +	return 0;
 +}
 +
 +static inline int
 +devlink_fmsg_binary_pair_put(struct devlink_fmsg *fmsg, const char *name,
 +			     const void *value, u16 value_len)
 +{
 +	return 0;
 +}
 +#endif
 +
 +#if IS_REACHABLE(CONFIG_NET_DEVLINK)
 +void devlink_compat_running_version(struct net_device *dev,
 +				    char *buf, size_t len);
 +#else
  static inline void
 -devlink_health_buffer_nest_end(struct devlink_health_buffer *buffer)
 +devlink_compat_running_version(struct net_device *dev, char *buf, size_t len)
  {
  }
++<<<<<<< HEAD
++=======
+ 
+ static inline void
+ devlink_health_buffer_nest_cancel(struct devlink_health_buffer *buffer)
+ {
+ }
+ 
+ static inline int
+ devlink_health_buffer_put_object_name(struct devlink_health_buffer *buffer,
+ 				      char *name)
+ {
+ 	return 0;
+ }
+ 
+ static inline int
+ devlink_health_buffer_put_value_u8(struct devlink_health_buffer *buffer,
+ 				   u8 value)
+ {
+ 	return 0;
+ }
+ 
+ static inline int
+ devlink_health_buffer_put_value_u32(struct devlink_health_buffer *buffer,
+ 				    u32 value)
+ {
+ 	return 0;
+ }
+ 
+ static inline int
+ devlink_health_buffer_put_value_u64(struct devlink_health_buffer *buffer,
+ 				    u64 value)
+ {
+ 	return 0;
+ }
+ 
+ static inline int
+ devlink_health_buffer_put_value_string(struct devlink_health_buffer *buffer,
+ 				       char *name)
+ {
+ 	return 0;
+ }
+ 
+ static inline int
+ devlink_health_buffer_put_value_data(struct devlink_health_buffer *buffer,
+ 				     void *data, int len)
+ {
+ 	return 0;
+ }
+ 
+ static inline struct devlink_health_reporter *
+ devlink_health_reporter_create(struct devlink *devlink,
+ 			       const struct devlink_health_reporter_ops *ops,
+ 			       u64 graceful_period, bool auto_recover,
+ 			       void *priv)
+ {
+ 	return NULL;
+ }
+ 
+ static inline void
+ devlink_health_reporter_destroy(struct devlink_health_reporter *reporter)
+ {
+ }
+ 
+ static inline void *
+ devlink_health_reporter_priv(struct devlink_health_reporter *reporter)
+ {
+ 	return NULL;
+ }
+ 
+ static inline int
+ devlink_health_report(struct devlink_health_reporter *reporter,
+ 		      const char *msg, void *priv_ctx)
+ {
+ 	return 0;
+ }
++>>>>>>> c7af343b4e33 (devlink: Add health report functionality)
  #endif
  
  #endif /* _NET_DEVLINK_H_ */
diff --cc include/trace/events/devlink.h
index 40705364a50f,7e39d2fc7c75..000000000000
--- a/include/trace/events/devlink.h
+++ b/include/trace/events/devlink.h
@@@ -46,33 -46,63 +46,89 @@@ TRACE_EVENT(devlink_hwmsg
  		  (int) __entry->len, __get_dynamic_array(buf), __entry->len)
  );
  
++<<<<<<< HEAD
 +/*
 + * Tracepoint for devlink hardware error:
 + */
 +TRACE_EVENT(devlink_hwerr,
 +	TP_PROTO(const struct devlink *devlink, int err, const char *msg),
 +
 +	TP_ARGS(devlink, err, msg),
++=======
+ TRACE_EVENT(devlink_health_report,
+ 	TP_PROTO(const struct devlink *devlink, const char *reporter_name,
+ 		 const char *msg),
+ 
+ 	TP_ARGS(devlink, reporter_name, msg),
++>>>>>>> c7af343b4e33 (devlink: Add health report functionality)
  
  	TP_STRUCT__entry(
  		__string(bus_name, devlink->dev->bus->name)
  		__string(dev_name, dev_name(devlink->dev))
  		__string(driver_name, devlink->dev->driver->name)
++<<<<<<< HEAD
 +		__field(int, err)
 +		__string(msg, msg)
 +		),
++=======
+ 		__string(reporter_name, msg)
+ 		__string(msg, msg)
+ 	),
++>>>>>>> c7af343b4e33 (devlink: Add health report functionality)
  
  	TP_fast_assign(
  		__assign_str(bus_name, devlink->dev->bus->name);
  		__assign_str(dev_name, dev_name(devlink->dev));
  		__assign_str(driver_name, devlink->dev->driver->name);
++<<<<<<< HEAD
 +		__entry->err = err;
 +		__assign_str(msg, msg);
 +		),
 +
 +	TP_printk("bus_name=%s dev_name=%s driver_name=%s err=%d %s",
 +			__get_str(bus_name), __get_str(dev_name),
 +			__get_str(driver_name), __entry->err, __get_str(msg))
++=======
+ 		__assign_str(reporter_name, reporter_name);
+ 		__assign_str(msg, msg);
+ 	),
+ 
+ 	TP_printk("bus_name=%s dev_name=%s driver_name=%s reporter_name=%s: %s",
+ 		  __get_str(bus_name), __get_str(dev_name),
+ 		  __get_str(driver_name), __get_str(reporter_name),
+ 		  __get_str(msg))
+ );
+ 
+ TRACE_EVENT(devlink_health_recover_aborted,
+ 	TP_PROTO(const struct devlink *devlink, const char *reporter_name,
+ 		 bool health_state, u64 time_since_last_recover),
+ 
+ 	TP_ARGS(devlink, reporter_name, health_state, time_since_last_recover),
+ 
+ 	TP_STRUCT__entry(
+ 		__string(bus_name, devlink->dev->bus->name)
+ 		__string(dev_name, dev_name(devlink->dev))
+ 		__string(driver_name, devlink->dev->driver->name)
+ 		__string(reporter_name, reporter_name)
+ 		__field(bool, health_state)
+ 		__field(u64, time_since_last_recover)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__assign_str(bus_name, devlink->dev->bus->name);
+ 		__assign_str(dev_name, dev_name(devlink->dev));
+ 		__assign_str(driver_name, devlink->dev->driver->name);
+ 		__assign_str(reporter_name, reporter_name);
+ 		__entry->health_state = health_state;
+ 		__entry->time_since_last_recover = time_since_last_recover;
+ 	),
+ 
+ 	TP_printk("bus_name=%s dev_name=%s driver_name=%s reporter_name=%s: health_state=%d time_since_last_recover = %llu recover aborted",
+ 		  __get_str(bus_name), __get_str(dev_name),
+ 		  __get_str(driver_name), __get_str(reporter_name),
+ 		  __entry->health_state,
+ 		  __entry->time_since_last_recover)
++>>>>>>> c7af343b4e33 (devlink: Add health report functionality)
  );
  
  #endif /* _TRACE_DEVLINK_H */
@@@ -93,8 -123,7 +149,12 @@@ static inline void trace_devlink_hwmsg(
  {
  }
  
++<<<<<<< HEAD
 +static inline void trace_devlink_hwerr(const struct devlink *devlink,
 +				       int err, const char *msg)
++=======
+ static inline void trace_devlink_health(const char *msg)
++>>>>>>> c7af343b4e33 (devlink: Add health report functionality)
  {
  }
  #endif /* _TRACE_DEVLINK_H */
diff --cc net/core/devlink.c
index 14d28d5d1c6c,943d3e7dea6a..000000000000
--- a/net/core/devlink.c
+++ b/net/core/devlink.c
@@@ -4368,6 -4098,225 +4368,228 @@@ nla_put_failure
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ struct devlink_health_reporter {
+ 	struct list_head list;
+ 	struct devlink_health_buffer **dump_buffers_array;
+ 	struct mutex dump_lock; /* lock parallel read/write from dump buffers */
+ 	struct devlink_health_buffer **diagnose_buffers_array;
+ 	struct mutex diagnose_lock; /* lock parallel read/write from diagnose buffers */
+ 	void *priv;
+ 	const struct devlink_health_reporter_ops *ops;
+ 	struct devlink *devlink;
+ 	u64 graceful_period;
+ 	bool auto_recover;
+ 	u8 health_state;
+ 	u8 dump_avail;
+ 	u64 dump_ts;
+ 	u64 error_count;
+ 	u64 recovery_count;
+ 	u64 last_recovery_ts;
+ };
+ 
+ enum devlink_health_reporter_state {
+ 	DEVLINK_HEALTH_REPORTER_STATE_HEALTHY,
+ 	DEVLINK_HEALTH_REPORTER_STATE_ERROR,
+ };
+ 
+ void *
+ devlink_health_reporter_priv(struct devlink_health_reporter *reporter)
+ {
+ 	return reporter->priv;
+ }
+ EXPORT_SYMBOL_GPL(devlink_health_reporter_priv);
+ 
+ static struct devlink_health_reporter *
+ devlink_health_reporter_find_by_name(struct devlink *devlink,
+ 				     const char *reporter_name)
+ {
+ 	struct devlink_health_reporter *reporter;
+ 
+ 	list_for_each_entry(reporter, &devlink->reporter_list, list)
+ 		if (!strcmp(reporter->ops->name, reporter_name))
+ 			return reporter;
+ 	return NULL;
+ }
+ 
+ /**
+  *	devlink_health_reporter_create - create devlink health reporter
+  *
+  *	@devlink: devlink
+  *	@ops: ops
+  *	@graceful_period: to avoid recovery loops, in msecs
+  *	@auto_recover: auto recover when error occurs
+  *	@priv: priv
+  */
+ struct devlink_health_reporter *
+ devlink_health_reporter_create(struct devlink *devlink,
+ 			       const struct devlink_health_reporter_ops *ops,
+ 			       u64 graceful_period, bool auto_recover,
+ 			       void *priv)
+ {
+ 	struct devlink_health_reporter *reporter;
+ 
+ 	mutex_lock(&devlink->lock);
+ 	if (devlink_health_reporter_find_by_name(devlink, ops->name)) {
+ 		reporter = ERR_PTR(-EEXIST);
+ 		goto unlock;
+ 	}
+ 
+ 	if (WARN_ON(ops->dump && !ops->dump_size) ||
+ 	    WARN_ON(ops->diagnose && !ops->diagnose_size) ||
+ 	    WARN_ON(auto_recover && !ops->recover) ||
+ 	    WARN_ON(graceful_period && !ops->recover)) {
+ 		reporter = ERR_PTR(-EINVAL);
+ 		goto unlock;
+ 	}
+ 
+ 	reporter = kzalloc(sizeof(*reporter), GFP_KERNEL);
+ 	if (!reporter) {
+ 		reporter = ERR_PTR(-ENOMEM);
+ 		goto unlock;
+ 	}
+ 
+ 	if (ops->dump) {
+ 		reporter->dump_buffers_array =
+ 			devlink_health_buffers_create(ops->dump_size);
+ 		if (!reporter->dump_buffers_array) {
+ 			kfree(reporter);
+ 			reporter = ERR_PTR(-ENOMEM);
+ 			goto unlock;
+ 		}
+ 	}
+ 
+ 	if (ops->diagnose) {
+ 		reporter->diagnose_buffers_array =
+ 			devlink_health_buffers_create(ops->diagnose_size);
+ 		if (!reporter->diagnose_buffers_array) {
+ 			devlink_health_buffers_destroy(reporter->dump_buffers_array,
+ 						       DEVLINK_HEALTH_SIZE_TO_BUFFERS(ops->dump_size));
+ 			kfree(reporter);
+ 			reporter = ERR_PTR(-ENOMEM);
+ 			goto unlock;
+ 		}
+ 	}
+ 
+ 	list_add_tail(&reporter->list, &devlink->reporter_list);
+ 	mutex_init(&reporter->dump_lock);
+ 	mutex_init(&reporter->diagnose_lock);
+ 
+ 	reporter->priv = priv;
+ 	reporter->ops = ops;
+ 	reporter->devlink = devlink;
+ 	reporter->graceful_period = graceful_period;
+ 	reporter->auto_recover = auto_recover;
+ unlock:
+ 	mutex_unlock(&devlink->lock);
+ 	return reporter;
+ }
+ EXPORT_SYMBOL_GPL(devlink_health_reporter_create);
+ 
+ /**
+  *	devlink_health_reporter_destroy - destroy devlink health reporter
+  *
+  *	@reporter: devlink health reporter to destroy
+  */
+ void
+ devlink_health_reporter_destroy(struct devlink_health_reporter *reporter)
+ {
+ 	mutex_lock(&reporter->devlink->lock);
+ 	list_del(&reporter->list);
+ 	devlink_health_buffers_destroy(reporter->dump_buffers_array,
+ 				       DEVLINK_HEALTH_SIZE_TO_BUFFERS(reporter->ops->dump_size));
+ 	devlink_health_buffers_destroy(reporter->diagnose_buffers_array,
+ 				       DEVLINK_HEALTH_SIZE_TO_BUFFERS(reporter->ops->diagnose_size));
+ 	kfree(reporter);
+ 	mutex_unlock(&reporter->devlink->lock);
+ }
+ EXPORT_SYMBOL_GPL(devlink_health_reporter_destroy);
+ 
+ static int
+ devlink_health_reporter_recover(struct devlink_health_reporter *reporter,
+ 				void *priv_ctx)
+ {
+ 	int err;
+ 
+ 	if (!reporter->ops->recover)
+ 		return -EOPNOTSUPP;
+ 
+ 	err = reporter->ops->recover(reporter, priv_ctx);
+ 	if (err)
+ 		return err;
+ 
+ 	reporter->recovery_count++;
+ 	reporter->health_state = DEVLINK_HEALTH_REPORTER_STATE_HEALTHY;
+ 	reporter->last_recovery_ts = jiffies;
+ 
+ 	return 0;
+ }
+ 
+ static int devlink_health_do_dump(struct devlink_health_reporter *reporter,
+ 				  void *priv_ctx)
+ {
+ 	int err;
+ 
+ 	if (!reporter->ops->dump)
+ 		return 0;
+ 
+ 	if (reporter->dump_avail)
+ 		return 0;
+ 
+ 	devlink_health_buffers_reset(reporter->dump_buffers_array,
+ 				     DEVLINK_HEALTH_SIZE_TO_BUFFERS(reporter->ops->dump_size));
+ 	err = reporter->ops->dump(reporter, reporter->dump_buffers_array,
+ 				     DEVLINK_HEALTH_BUFFER_SIZE,
+ 				     DEVLINK_HEALTH_SIZE_TO_BUFFERS(reporter->ops->dump_size),
+ 				     priv_ctx);
+ 	if (!err) {
+ 		reporter->dump_avail = true;
+ 		reporter->dump_ts = jiffies;
+ 	}
+ 
+ 	return err;
+ }
+ 
+ int devlink_health_report(struct devlink_health_reporter *reporter,
+ 			  const char *msg, void *priv_ctx)
+ {
+ 	struct devlink *devlink = reporter->devlink;
+ 	int err = 0;
+ 
+ 	/* write a log message of the current error */
+ 	WARN_ON(!msg);
+ 	trace_devlink_health_report(devlink, reporter->ops->name, msg);
+ 	reporter->error_count++;
+ 
+ 	/* abort if the previous error wasn't recovered */
+ 	if (reporter->auto_recover &&
+ 	    (reporter->health_state != DEVLINK_HEALTH_REPORTER_STATE_HEALTHY ||
+ 	     jiffies - reporter->last_recovery_ts <
+ 	     msecs_to_jiffies(reporter->graceful_period))) {
+ 		trace_devlink_health_recover_aborted(devlink,
+ 						     reporter->ops->name,
+ 						     reporter->health_state,
+ 						     jiffies -
+ 						     reporter->last_recovery_ts);
+ 		return -ECANCELED;
+ 	}
+ 
+ 	reporter->health_state = DEVLINK_HEALTH_REPORTER_STATE_ERROR;
+ 
+ 	mutex_lock(&reporter->dump_lock);
+ 	/* store current dump of current error, for later analysis */
+ 	devlink_health_do_dump(reporter, priv_ctx);
+ 	mutex_unlock(&reporter->dump_lock);
+ 
+ 	if (reporter->auto_recover)
+ 		err = devlink_health_reporter_recover(reporter, priv_ctx);
+ 
+ 	return err;
+ }
+ EXPORT_SYMBOL_GPL(devlink_health_report);
+ 
++>>>>>>> c7af343b4e33 (devlink: Add health report functionality)
  static const struct nla_policy devlink_nl_policy[DEVLINK_ATTR_MAX + 1] = {
  	[DEVLINK_ATTR_BUS_NAME] = { .type = NLA_NUL_STRING },
  	[DEVLINK_ATTR_DEV_NAME] = { .type = NLA_NUL_STRING },
* Unmerged path include/net/devlink.h
* Unmerged path include/trace/events/devlink.h
* Unmerged path net/core/devlink.c
