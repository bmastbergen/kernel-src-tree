tools: bpftool: add C-style "#define" output for probes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Quentin Monnet <quentin.monnet@netronome.com>
commit d267cff46753b0e8b2f169ff4a3f1bb40c2387a8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/d267cff4.failed

Make bpftool able to dump a subset of the parameters collected by
probing the system as a listing of C-style #define macros, so that
external projects can reuse the result of this probing and build
BPF-based project in accordance with the features available on the
system.

The new "macros" keyword is used to select this output. An additional
"prefix" keyword is added so that users can select a custom prefix for
macro names, in order to avoid any namespace conflict.

Sample output:

    # bpftool feature probe kernel macros prefix FOO_
    /*** System call availability ***/
    #define FOO_HAVE_BPF_SYSCALL

    /*** eBPF program types ***/
    #define FOO_HAVE_SOCKET_FILTER_PROG_TYPE
    #define FOO_HAVE_KPROBE_PROG_TYPE
    #define FOO_HAVE_SCHED_CLS_PROG_TYPE
    ...

    /*** eBPF map types ***/
    #define FOO_HAVE_HASH_MAP_TYPE
    #define FOO_HAVE_ARRAY_MAP_TYPE
    #define FOO_HAVE_PROG_ARRAY_MAP_TYPE
    ...

    /*** eBPF helper functions ***/
    /*
     * Use FOO_HAVE_PROG_TYPE_HELPER(prog_type_name, helper_name)
     * to determine if <helper_name> is available for <prog_type_name>,
     * e.g.
     *      #if FOO_HAVE_PROG_TYPE_HELPER(xdp, bpf_redirect)
     *              // do stuff with this helper
     *      #elif
     *              // use a workaround
     *      #endif
     */
    #define FOO_HAVE_PROG_TYPE_HELPER(prog_type, helper)        \
            FOO_BPF__PROG_TYPE_ ## prog_type ## __HELPER_ ## helper
    ...
    #define FOO_BPF__PROG_TYPE_socket_filter__HELPER_bpf_probe_read 0
    #define FOO_BPF__PROG_TYPE_socket_filter__HELPER_bpf_ktime_get_ns 1
    #define FOO_BPF__PROG_TYPE_socket_filter__HELPER_bpf_trace_printk 1
    ...

v3:
- Change output for helpers again: add a
  HAVE_PROG_TYPE_HELPER(type, helper) macro that can be used to tell
  if <helper> is available for program <type>.

v2:
- #define-based output added as a distinct patch.
- "HAVE_" prefix appended to macro names.
- Output limited to bpf() syscall availability, BPF prog and map types,
  helper functions. In this version kernel config options, procfs
  parameter or kernel version are intentionally left aside.
- Following the change on helper probes, format for helper probes in
  this output style has changed (now a list of compatible program
  types).

	Signed-off-by: Quentin Monnet <quentin.monnet@netronome.com>
	Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Stanislav Fomichev <sdf@google.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit d267cff46753b0e8b2f169ff4a3f1bb40c2387a8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/bpf/bpftool/feature.c
diff --cc tools/bpf/bpftool/feature.c
index 4a2867439ab7,a62e637953b7..000000000000
--- a/tools/bpf/bpftool/feature.c
+++ b/tools/bpf/bpftool/feature.c
@@@ -83,6 -109,20 +100,23 @@@ print_start_section(const char *json_ti
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ print_end_then_start_section(const char *json_title, const char *plain_title,
+ 			     const char *define_comment,
+ 			     const char *define_prefix)
+ {
+ 	if (json_output)
+ 		jsonw_end_object(json_wtr);
+ 	else
+ 		printf("\n");
+ 
+ 	print_start_section(json_title, plain_title, define_comment,
+ 			    define_prefix);
+ }
+ 
++>>>>>>> d267cff46753 (tools: bpftool: add C-style "#define" output for probes)
  /* Probing functions */
  
  static int read_procfs(const char *path)
@@@ -403,9 -454,106 +448,112 @@@ static bool probe_bpf_syscall(const cha
  	return res;
  }
  
++<<<<<<< HEAD
++static int do_probe(int argc, char **argv)
++{
++	enum probe_component target = COMPONENT_UNSPEC;
++=======
+ static void
+ probe_prog_type(enum bpf_prog_type prog_type, bool *supported_types,
+ 		const char *define_prefix)
+ {
+ 	char feat_name[128], plain_desc[128], define_name[128];
+ 	const char *plain_comment = "eBPF program_type ";
+ 	size_t maxlen;
+ 	bool res;
+ 
+ 	res = bpf_probe_prog_type(prog_type, 0);
+ 
+ 	supported_types[prog_type] |= res;
+ 
+ 	maxlen = sizeof(plain_desc) - strlen(plain_comment) - 1;
+ 	if (strlen(prog_type_name[prog_type]) > maxlen) {
+ 		p_info("program type name too long");
+ 		return;
+ 	}
+ 
+ 	sprintf(feat_name, "have_%s_prog_type", prog_type_name[prog_type]);
+ 	sprintf(define_name, "%s_prog_type", prog_type_name[prog_type]);
+ 	uppercase(define_name, sizeof(define_name));
+ 	sprintf(plain_desc, "%s%s", plain_comment, prog_type_name[prog_type]);
+ 	print_bool_feature(feat_name, plain_desc, define_name, res,
+ 			   define_prefix);
+ }
+ 
+ static void
+ probe_map_type(enum bpf_map_type map_type, const char *define_prefix)
+ {
+ 	char feat_name[128], plain_desc[128], define_name[128];
+ 	const char *plain_comment = "eBPF map_type ";
+ 	size_t maxlen;
+ 	bool res;
+ 
+ 	res = bpf_probe_map_type(map_type, 0);
+ 
+ 	maxlen = sizeof(plain_desc) - strlen(plain_comment) - 1;
+ 	if (strlen(map_type_name[map_type]) > maxlen) {
+ 		p_info("map type name too long");
+ 		return;
+ 	}
+ 
+ 	sprintf(feat_name, "have_%s_map_type", map_type_name[map_type]);
+ 	sprintf(define_name, "%s_map_type", map_type_name[map_type]);
+ 	uppercase(define_name, sizeof(define_name));
+ 	sprintf(plain_desc, "%s%s", plain_comment, map_type_name[map_type]);
+ 	print_bool_feature(feat_name, plain_desc, define_name, res,
+ 			   define_prefix);
+ }
+ 
+ static void
+ probe_helpers_for_progtype(enum bpf_prog_type prog_type, bool supported_type,
+ 			   const char *define_prefix)
+ {
+ 	const char *ptype_name = prog_type_name[prog_type];
+ 	char feat_name[128];
+ 	unsigned int id;
+ 	bool res;
+ 
+ 	if (json_output) {
+ 		sprintf(feat_name, "%s_available_helpers", ptype_name);
+ 		jsonw_name(json_wtr, feat_name);
+ 		jsonw_start_array(json_wtr);
+ 	} else if (!define_prefix) {
+ 		printf("eBPF helpers supported for program type %s:",
+ 		       ptype_name);
+ 	}
+ 
+ 	for (id = 1; id < ARRAY_SIZE(helper_name); id++) {
+ 		if (!supported_type)
+ 			res = false;
+ 		else
+ 			res = bpf_probe_helper(id, prog_type, 0);
+ 
+ 		if (json_output) {
+ 			if (res)
+ 				jsonw_string(json_wtr, helper_name[id]);
+ 		} else if (define_prefix) {
+ 			printf("#define %sBPF__PROG_TYPE_%s__HELPER_%s %s\n",
+ 			       define_prefix, ptype_name, helper_name[id],
+ 			       res ? "1" : "0");
+ 		} else {
+ 			if (res)
+ 				printf("\n\t- %s", helper_name[id]);
+ 		}
+ 	}
+ 
+ 	if (json_output)
+ 		jsonw_end_array(json_wtr);
+ 	else if (!define_prefix)
+ 		printf("\n");
+ }
+ 
  static int do_probe(int argc, char **argv)
  {
  	enum probe_component target = COMPONENT_UNSPEC;
+ 	const char *define_prefix = NULL;
+ 	bool supported_types[128] = {};
+ 	unsigned int i;
++>>>>>>> d267cff46753 (tools: bpftool: add C-style "#define" output for probes)
  
  	/* Detection assumes user has sufficient privileges (CAP_SYS_ADMIN).
  	 * Let's approximate, and restrict usage to root user only.
@@@ -458,10 -630,55 +630,60 @@@
  	}
  
  	print_start_section("syscall_config",
- 			    "Scanning system call availability...");
+ 			    "Scanning system call availability...",
+ 			    "/*** System call availability ***/",
+ 			    define_prefix);
  
++<<<<<<< HEAD
 +	probe_bpf_syscall();
 +
++=======
+ 	if (!probe_bpf_syscall(define_prefix))
+ 		/* bpf() syscall unavailable, don't probe other BPF features */
+ 		goto exit_close_json;
+ 
+ 	print_end_then_start_section("program_types",
+ 				     "Scanning eBPF program types...",
+ 				     "/*** eBPF program types ***/",
+ 				     define_prefix);
+ 
+ 	for (i = BPF_PROG_TYPE_UNSPEC + 1; i < ARRAY_SIZE(prog_type_name); i++)
+ 		probe_prog_type(i, supported_types, define_prefix);
+ 
+ 	print_end_then_start_section("map_types",
+ 				     "Scanning eBPF map types...",
+ 				     "/*** eBPF map types ***/",
+ 				     define_prefix);
+ 
+ 	for (i = BPF_MAP_TYPE_UNSPEC + 1; i < map_type_name_size; i++)
+ 		probe_map_type(i, define_prefix);
+ 
+ 	print_end_then_start_section("helpers",
+ 				     "Scanning eBPF helper functions...",
+ 				     "/*** eBPF helper functions ***/",
+ 				     define_prefix);
+ 
+ 	if (define_prefix)
+ 		printf("/*\n"
+ 		       " * Use %sHAVE_PROG_TYPE_HELPER(prog_type_name, helper_name)\n"
+ 		       " * to determine if <helper_name> is available for <prog_type_name>,\n"
+ 		       " * e.g.\n"
+ 		       " *	#if %sHAVE_PROG_TYPE_HELPER(xdp, bpf_redirect)\n"
+ 		       " *		// do stuff with this helper\n"
+ 		       " *	#elif\n"
+ 		       " *		// use a workaround\n"
+ 		       " *	#endif\n"
+ 		       " */\n"
+ 		       "#define %sHAVE_PROG_TYPE_HELPER(prog_type, helper)	\\\n"
+ 		       "	%sBPF__PROG_TYPE_ ## prog_type ## __HELPER_ ## helper\n",
+ 		       define_prefix, define_prefix, define_prefix,
+ 		       define_prefix);
+ 	for (i = BPF_PROG_TYPE_UNSPEC + 1; i < ARRAY_SIZE(prog_type_name); i++)
+ 		probe_helpers_for_progtype(i, supported_types[i],
+ 					   define_prefix);
+ 
+ exit_close_json:
++>>>>>>> d267cff46753 (tools: bpftool: add C-style "#define" output for probes)
  	if (json_output) {
  		/* End current "section" of probes */
  		jsonw_end_object(json_wtr);
diff --git a/tools/bpf/bpftool/Documentation/bpftool-feature.rst b/tools/bpf/bpftool/Documentation/bpftool-feature.rst
index 40ac13c0b782..6434f7478601 100644
--- a/tools/bpf/bpftool/Documentation/bpftool-feature.rst
+++ b/tools/bpf/bpftool/Documentation/bpftool-feature.rst
@@ -19,15 +19,24 @@ SYNOPSIS
 MAP COMMANDS
 =============
 
-|	**bpftool** **feature probe** [**kernel**]
+|	**bpftool** **feature probe** [**kernel**] [**macros** [**prefix** *PREFIX*]]
 |	**bpftool** **feature help**
 
 DESCRIPTION
 ===========
-	**bpftool feature probe** [**kernel**]
+	**bpftool feature probe** [**kernel**] [**macros** [**prefix** *PREFIX*]]
 		  Probe the running kernel and dump a number of eBPF-related
 		  parameters, such as availability of the **bpf()** system call.
 
+		  If the **macros** keyword (but not the **-j** option) is
+		  passed, a subset of the output is dumped as a list of
+		  **#define** macros that are ready to be included in a C
+		  header file, for example. If, additionally, **prefix** is
+		  used to define a *PREFIX*, the provided string will be used
+		  as a prefix to the names of the macros: this can be used to
+		  avoid conflicts on macro names when including the output of
+		  this command as a header file.
+
 		  Keyword **kernel** can be omitted.
 
 	**bpftool feature help**
* Unmerged path tools/bpf/bpftool/feature.c
