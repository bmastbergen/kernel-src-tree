drm/i915: Update DSPCNTR gamma/csc bits during crtc_enable()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit 73a116be688041149bbdd1f0ba25da5c4c78a306
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/73a116be.failed

On g4x+ we depend on the primary plane DSPCNTR gamma/csc enable
bits for the pipe bottom color. To guarantee that those are
correct already when enabling the crtc let's do an explicit
->disable_plane() call before enabling the pipe.

On skl+ this will be handled by the explicit PIPE_BOTTOM_COLOR
register which is already part of the normal color commit we
do durign crtc enable.

	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
	Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190207202146.26423-8-ville.syrjala@linux.intel.com
(cherry picked from commit 73a116be688041149bbdd1f0ba25da5c4c78a306)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_color.c
#	drivers/gpu/drm/i915/intel_display.c
diff --cc drivers/gpu/drm/i915/intel_color.c
index c6a7beabd58d,c0e2806febf6..000000000000
--- a/drivers/gpu/drm/i915/intel_color.c
+++ b/drivers/gpu/drm/i915/intel_color.c
@@@ -613,11 -630,89 +613,95 @@@ void intel_color_load_luts(struct drm_c
  	dev_priv->display.load_luts(crtc_state);
  }
  
 -void intel_color_commit(const struct intel_crtc_state *crtc_state)
 +int intel_color_check(struct drm_crtc *crtc,
 +		      struct drm_crtc_state *crtc_state)
  {
++<<<<<<< HEAD
 +	struct drm_i915_private *dev_priv = to_i915(crtc->dev);
 +	size_t gamma_length, degamma_length;
++=======
+ 	struct drm_i915_private *dev_priv = to_i915(crtc_state->base.crtc->dev);
+ 
+ 	dev_priv->display.color_commit(crtc_state);
+ }
+ 
+ static bool need_plane_update(struct intel_plane *plane,
+ 			      const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(plane->base.dev);
+ 
+ 	/*
+ 	 * On pre-SKL the pipe gamma enable and pipe csc enable for
+ 	 * the pipe bottom color are configured via the primary plane.
+ 	 * We have to reconfigure that even if the plane is inactive.
+ 	 */
+ 	return crtc_state->active_planes & BIT(plane->id) ||
+ 		(INTEL_GEN(dev_priv) < 9 &&
+ 		 plane->id == PLANE_PRIMARY);
+ }
+ 
+ static int
+ intel_color_add_affected_planes(struct intel_crtc_state *new_crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(new_crtc_state->base.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	struct intel_atomic_state *state =
+ 		to_intel_atomic_state(new_crtc_state->base.state);
+ 	const struct intel_crtc_state *old_crtc_state =
+ 		intel_atomic_get_old_crtc_state(state, crtc);
+ 	struct intel_plane *plane;
+ 
+ 	if (!new_crtc_state->base.active ||
+ 	    drm_atomic_crtc_needs_modeset(&new_crtc_state->base))
+ 		return 0;
+ 
+ 	if (new_crtc_state->gamma_enable == old_crtc_state->gamma_enable &&
+ 	    new_crtc_state->csc_enable == old_crtc_state->csc_enable)
+ 		return 0;
+ 
+ 	for_each_intel_plane_on_crtc(&dev_priv->drm, crtc, plane) {
+ 		struct intel_plane_state *plane_state;
+ 
+ 		if (!need_plane_update(plane, new_crtc_state))
+ 			continue;
+ 
+ 		plane_state = intel_atomic_get_plane_state(state, plane);
+ 		if (IS_ERR(plane_state))
+ 			return PTR_ERR(plane_state);
+ 
+ 		new_crtc_state->update_planes |= BIT(plane->id);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int check_lut_size(const struct drm_property_blob *lut, int expected)
+ {
+ 	int len;
+ 
+ 	if (!lut)
+ 		return 0;
+ 
+ 	len = drm_color_lut_size(lut);
+ 	if (len != expected) {
+ 		DRM_DEBUG_KMS("Invalid LUT size; got %d, expected %d\n",
+ 			      len, expected);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ int intel_color_check(struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(crtc_state->base.crtc->dev);
+ 	const struct drm_property_blob *gamma_lut = crtc_state->base.gamma_lut;
+ 	const struct drm_property_blob *degamma_lut = crtc_state->base.degamma_lut;
+ 	bool limited_color_range = false;
+ 	int gamma_length, degamma_length;
+ 	u32 gamma_tests, degamma_tests;
+ 	int ret;
++>>>>>>> 73a116be6880 (drm/i915: Update DSPCNTR gamma/csc bits during crtc_enable())
  
  	degamma_length = INTEL_INFO(dev_priv)->color.degamma_lut_size;
  	gamma_length = INTEL_INFO(dev_priv)->color.gamma_lut_size;
diff --cc drivers/gpu/drm/i915/intel_display.c
index dec0d60921bf,c496b6e0226b..000000000000
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@@ -5477,6 -5722,34 +5477,37 @@@ static void intel_encoders_post_pll_dis
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void intel_encoders_update_pipe(struct drm_crtc *crtc,
+ 				       struct intel_crtc_state *crtc_state,
+ 				       struct drm_atomic_state *old_state)
+ {
+ 	struct drm_connector_state *conn_state;
+ 	struct drm_connector *conn;
+ 	int i;
+ 
+ 	for_each_new_connector_in_state(old_state, conn, conn_state, i) {
+ 		struct intel_encoder *encoder =
+ 			to_intel_encoder(conn_state->best_encoder);
+ 
+ 		if (conn_state->crtc != crtc)
+ 			continue;
+ 
+ 		if (encoder->update_pipe)
+ 			encoder->update_pipe(encoder, crtc_state, conn_state);
+ 	}
+ }
+ 
+ static void intel_disable_primary_plane(const struct intel_crtc_state *crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->base.crtc);
+ 	struct intel_plane *plane = to_intel_plane(crtc->base.primary);
+ 
+ 	plane->disable_plane(plane, crtc_state);
+ }
+ 
++>>>>>>> 73a116be6880 (drm/i915: Update DSPCNTR gamma/csc bits during crtc_enable())
  static void ironlake_crtc_enable(struct intel_crtc_state *pipe_config,
  				 struct drm_atomic_state *old_state)
  {
@@@ -5542,17 -5813,20 +5573,24 @@@
  	 * On ILK+ LUT must be loaded before the pipe is running but with
  	 * clocks enabled
  	 */
++<<<<<<< HEAD
 +	intel_color_load_luts(&pipe_config->base);
++=======
+ 	intel_color_load_luts(pipe_config);
+ 	intel_color_commit(pipe_config);
+ 	/* update DSPCNTR to configure gamma for pipe bottom color */
+ 	intel_disable_primary_plane(pipe_config);
++>>>>>>> 73a116be6880 (drm/i915: Update DSPCNTR gamma/csc bits during crtc_enable())
  
  	if (dev_priv->display.initial_watermarks != NULL)
 -		dev_priv->display.initial_watermarks(old_intel_state, pipe_config);
 +		dev_priv->display.initial_watermarks(old_intel_state, intel_crtc->config);
  	intel_enable_pipe(pipe_config);
  
 -	if (pipe_config->has_pch_encoder)
 -		ironlake_pch_enable(old_intel_state, pipe_config);
 +	if (intel_crtc->config->has_pch_encoder)
 +		ironlake_pch_enable(pipe_config);
  
  	assert_vblank_disabled(crtc);
 -	intel_crtc_vblank_on(pipe_config);
 +	drm_crtc_vblank_on(crtc);
  
  	intel_encoders_enable(crtc, pipe_config, old_state);
  
@@@ -5671,7 -5943,14 +5709,18 @@@ static void haswell_crtc_enable(struct 
  	 * On ILK+ LUT must be loaded before the pipe is running but with
  	 * clocks enabled
  	 */
++<<<<<<< HEAD
 +	intel_color_load_luts(&pipe_config->base);
++=======
+ 	intel_color_load_luts(pipe_config);
+ 	intel_color_commit(pipe_config);
+ 	/* update DSPCNTR to configure gamma/csc for pipe bottom color */
+ 	if (INTEL_GEN(dev_priv) < 9)
+ 		intel_disable_primary_plane(pipe_config);
+ 
+ 	if (INTEL_GEN(dev_priv) >= 11)
+ 		icl_set_pipe_chicken(intel_crtc);
++>>>>>>> 73a116be6880 (drm/i915: Update DSPCNTR gamma/csc bits during crtc_enable())
  
  	intel_ddi_set_pipe_settings(pipe_config);
  	if (!transcoder_is_dsi(cpu_transcoder))
@@@ -5980,9 -6301,12 +6029,16 @@@ static void valleyview_crtc_enable(stru
  
  	intel_encoders_pre_enable(crtc, pipe_config, old_state);
  
 -	i9xx_pfit_enable(pipe_config);
 +	i9xx_pfit_enable(intel_crtc);
  
++<<<<<<< HEAD
 +	intel_color_load_luts(&pipe_config->base);
++=======
+ 	intel_color_load_luts(pipe_config);
+ 	intel_color_commit(pipe_config);
+ 	/* update DSPCNTR to configure gamma for pipe bottom color */
+ 	intel_disable_primary_plane(pipe_config);
++>>>>>>> 73a116be6880 (drm/i915: Update DSPCNTR gamma/csc bits during crtc_enable())
  
  	dev_priv->display.initial_watermarks(old_intel_state,
  					     pipe_config);
@@@ -6036,9 -6360,12 +6092,16 @@@ static void i9xx_crtc_enable(struct int
  
  	i9xx_enable_pll(intel_crtc, pipe_config);
  
 -	i9xx_pfit_enable(pipe_config);
 +	i9xx_pfit_enable(intel_crtc);
  
++<<<<<<< HEAD
 +	intel_color_load_luts(&pipe_config->base);
++=======
+ 	intel_color_load_luts(pipe_config);
+ 	intel_color_commit(pipe_config);
+ 	/* update DSPCNTR to configure gamma for pipe bottom color */
+ 	intel_disable_primary_plane(pipe_config);
++>>>>>>> 73a116be6880 (drm/i915: Update DSPCNTR gamma/csc bits during crtc_enable())
  
  	if (dev_priv->display.initial_watermarks != NULL)
  		dev_priv->display.initial_watermarks(old_intel_state,
* Unmerged path drivers/gpu/drm/i915/intel_color.c
* Unmerged path drivers/gpu/drm/i915/intel_display.c
