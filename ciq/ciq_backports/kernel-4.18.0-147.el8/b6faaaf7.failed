scsi: qla2xxx: Serialize mailbox request

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Quinn Tran <quinn.tran@cavium.com>
commit b6faaaf796d7bfb00e32ca5c905d55cc43e89448
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/b6faaaf7.failed

For driver MBX submission, use mbox_busy to serialize request.  For Userspace
MBX submission, use optrom mutex to serialize request.

	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit b6faaaf796d7bfb00e32ca5c905d55cc43e89448)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_attr.c
diff --cc drivers/scsi/qla2xxx/qla_attr.c
index c8731568f9c4,14c496bab280..000000000000
--- a/drivers/scsi/qla2xxx/qla_attr.c
+++ b/drivers/scsi/qla2xxx/qla_attr.c
@@@ -570,10 -606,15 +606,19 @@@ qla2x00_sysfs_read_sfp(struct file *fil
  	if (!capable(CAP_SYS_ADMIN) || off != 0 || count < SFP_DEV_SIZE)
  		return 0;
  
++<<<<<<< HEAD
 +	if (qla2x00_reset_active(vha))
++=======
+ 	mutex_lock(&vha->hw->optrom_mutex);
+ 	if (qla2x00_chip_is_down(vha)) {
+ 		mutex_unlock(&vha->hw->optrom_mutex);
++>>>>>>> b6faaaf796d7 (scsi: qla2xxx: Serialize mailbox request)
  		return 0;
+ 	}
  
  	rval = qla2x00_read_sfp_dev(vha, buf, count);
+ 	mutex_unlock(&vha->hw->optrom_mutex);
+ 
  	if (rval)
  		return -EIO;
  
@@@ -771,6 -821,14 +816,17 @@@ qla2x00_sysfs_read_xgmac_stats(struct f
  	if (!capable(CAP_SYS_ADMIN) || off != 0 || count > XGMAC_DATA_SIZE)
  		return 0;
  
++<<<<<<< HEAD
++=======
+ 	if (unlikely(pci_channel_offline(ha->pdev)))
+ 		return 0;
+ 	mutex_lock(&vha->hw->optrom_mutex);
+ 	if (qla2x00_chip_is_down(vha)) {
+ 		mutex_unlock(&vha->hw->optrom_mutex);
+ 		return 0;
+ 	}
+ 
++>>>>>>> b6faaaf796d7 (scsi: qla2xxx: Serialize mailbox request)
  	if (ha->xgmac_data)
  		goto do_read;
  
@@@ -824,6 -885,11 +883,14 @@@ qla2x00_sysfs_read_dcbx_tlv(struct fil
  
  	if (ha->dcbx_tlv)
  		goto do_read;
++<<<<<<< HEAD
++=======
+ 	mutex_lock(&vha->hw->optrom_mutex);
+ 	if (qla2x00_chip_is_down(vha)) {
+ 		mutex_unlock(&vha->hw->optrom_mutex);
+ 		return 0;
+ 	}
++>>>>>>> b6faaaf796d7 (scsi: qla2xxx: Serialize mailbox request)
  
  	ha->dcbx_tlv = dma_alloc_coherent(&ha->pdev->dev, DCBX_TLV_DATA_SIZE,
  	    &ha->dcbx_tlv_dma, GFP_KERNEL);
@@@ -1163,7 -1233,12 +1234,16 @@@ qla2x00_beacon_store(struct device *dev
  	if (IS_QLA2100(ha) || IS_QLA2200(ha))
  		return -EPERM;
  
++<<<<<<< HEAD
 +	if (test_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags)) {
++=======
+ 	if (sscanf(buf, "%d", &val) != 1)
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&vha->hw->optrom_mutex);
+ 	if (qla2x00_chip_is_down(vha)) {
+ 		mutex_unlock(&vha->hw->optrom_mutex);
++>>>>>>> b6faaaf796d7 (scsi: qla2xxx: Serialize mailbox request)
  		ql_log(ql_log_warn, vha, 0x707a,
  		    "Abort ISP active -- ignoring beacon request.\n");
  		return -EBUSY;
@@@ -1349,8 -1423,11 +1428,15 @@@ qla2x00_thermal_temp_show(struct devic
  {
  	scsi_qla_host_t *vha = shost_priv(class_to_shost(dev));
  	uint16_t temp = 0;
+ 	int rc;
  
++<<<<<<< HEAD
 +	if (qla2x00_reset_active(vha)) {
++=======
+ 	mutex_lock(&vha->hw->optrom_mutex);
+ 	if (qla2x00_chip_is_down(vha)) {
+ 		mutex_unlock(&vha->hw->optrom_mutex);
++>>>>>>> b6faaaf796d7 (scsi: qla2xxx: Serialize mailbox request)
  		ql_log(ql_log_warn, vha, 0x70dc, "ISP reset active.\n");
  		goto done;
  	}
@@@ -1381,13 -1461,24 +1470,28 @@@ qla2x00_fw_state_show(struct device *de
  		return scnprintf(buf, PAGE_SIZE, "0x%x\n", pstate);
  	}
  
++<<<<<<< HEAD
 +	if (qla2x00_reset_active(vha))
++=======
+ 	mutex_lock(&vha->hw->optrom_mutex);
+ 	if (qla2x00_chip_is_down(vha)) {
+ 		mutex_unlock(&vha->hw->optrom_mutex);
++>>>>>>> b6faaaf796d7 (scsi: qla2xxx: Serialize mailbox request)
  		ql_log(ql_log_warn, vha, 0x707c,
  		    "ISP reset active.\n");
- 	else if (!vha->hw->flags.eeh_busy)
- 		rval = qla2x00_get_firmware_state(vha, state);
- 	if (rval != QLA_SUCCESS)
+ 		goto out;
+ 	} else if (vha->hw->flags.eeh_busy) {
+ 		mutex_unlock(&vha->hw->optrom_mutex);
+ 		goto out;
+ 	}
+ 
+ 	rval = qla2x00_get_firmware_state(vha, state);
+ 	mutex_unlock(&vha->hw->optrom_mutex);
+ out:
+ 	if (rval != QLA_SUCCESS) {
  		memset(state, -1, sizeof(state));
+ 		rval = qla2x00_get_firmware_state(vha, state);
+ 	}
  
  	return scnprintf(buf, PAGE_SIZE, "0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n",
  	    state[0], state[1], state[2], state[3], state[4], state[5]);
* Unmerged path drivers/scsi/qla2xxx/qla_attr.c
diff --git a/drivers/scsi/qla2xxx/qla_mbx.c b/drivers/scsi/qla2xxx/qla_mbx.c
index da026f46e757..49ce9951e8d3 100644
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@ -188,7 +188,7 @@ qla2x00_mailbox_command(scsi_qla_host_t *vha, mbx_cmd_t *mcp)
 		goto premature_exit;
 	}
 
-	ha->flags.mbox_busy = 1;
+
 	/* Save mailbox command for debug */
 	ha->mcp = mcp;
 
@@ -197,12 +197,13 @@ qla2x00_mailbox_command(scsi_qla_host_t *vha, mbx_cmd_t *mcp)
 
 	spin_lock_irqsave(&ha->hardware_lock, flags);
 
-	if (ha->flags.purge_mbox || chip_reset != ha->chip_reset) {
+	if (ha->flags.purge_mbox || chip_reset != ha->chip_reset ||
+	    ha->flags.mbox_busy) {
 		rval = QLA_ABORTED;
-		ha->flags.mbox_busy = 0;
 		spin_unlock_irqrestore(&ha->hardware_lock, flags);
 		goto premature_exit;
 	}
+	ha->flags.mbox_busy = 1;
 
 	/* Load mailbox registers. */
 	if (IS_P3P_TYPE(ha))
@@ -253,9 +254,10 @@ qla2x00_mailbox_command(scsi_qla_host_t *vha, mbx_cmd_t *mcp)
 		if (IS_P3P_TYPE(ha)) {
 			if (RD_REG_DWORD(&reg->isp82.hint) &
 				HINT_MBX_INT_PENDING) {
+				ha->flags.mbox_busy = 0;
 				spin_unlock_irqrestore(&ha->hardware_lock,
 					flags);
-				ha->flags.mbox_busy = 0;
+
 				atomic_dec(&ha->num_pend_mbx_stage2);
 				ql_dbg(ql_dbg_mbx, vha, 0x1010,
 				    "Pending mailbox timeout, exiting.\n");
@@ -273,6 +275,16 @@ qla2x00_mailbox_command(scsi_qla_host_t *vha, mbx_cmd_t *mcp)
 		atomic_inc(&ha->num_pend_mbx_stage3);
 		if (!wait_for_completion_timeout(&ha->mbx_intr_comp,
 		    mcp->tov * HZ)) {
+			if (chip_reset != ha->chip_reset) {
+				spin_lock_irqsave(&ha->hardware_lock, flags);
+				ha->flags.mbox_busy = 0;
+				spin_unlock_irqrestore(&ha->hardware_lock,
+				    flags);
+				atomic_dec(&ha->num_pend_mbx_stage2);
+				atomic_dec(&ha->num_pend_mbx_stage3);
+				rval = QLA_ABORTED;
+				goto premature_exit;
+			}
 			ql_dbg(ql_dbg_mbx, vha, 0x117a,
 			    "cmd=%x Timeout.\n", command);
 			spin_lock_irqsave(&ha->hardware_lock, flags);
@@ -281,7 +293,9 @@ qla2x00_mailbox_command(scsi_qla_host_t *vha, mbx_cmd_t *mcp)
 
 		} else if (ha->flags.purge_mbox ||
 		    chip_reset != ha->chip_reset) {
+			spin_lock_irqsave(&ha->hardware_lock, flags);
 			ha->flags.mbox_busy = 0;
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
 			atomic_dec(&ha->num_pend_mbx_stage2);
 			atomic_dec(&ha->num_pend_mbx_stage3);
 			rval = QLA_ABORTED;
@@ -299,9 +313,9 @@ qla2x00_mailbox_command(scsi_qla_host_t *vha, mbx_cmd_t *mcp)
 		if (IS_P3P_TYPE(ha)) {
 			if (RD_REG_DWORD(&reg->isp82.hint) &
 				HINT_MBX_INT_PENDING) {
+				ha->flags.mbox_busy = 0;
 				spin_unlock_irqrestore(&ha->hardware_lock,
 					flags);
-				ha->flags.mbox_busy = 0;
 				atomic_dec(&ha->num_pend_mbx_stage2);
 				ql_dbg(ql_dbg_mbx, vha, 0x1012,
 				    "Pending mailbox timeout, exiting.\n");
@@ -319,7 +333,10 @@ qla2x00_mailbox_command(scsi_qla_host_t *vha, mbx_cmd_t *mcp)
 		while (!ha->flags.mbox_int) {
 			if (ha->flags.purge_mbox ||
 			    chip_reset != ha->chip_reset) {
+				spin_lock_irqsave(&ha->hardware_lock, flags);
 				ha->flags.mbox_busy = 0;
+				spin_unlock_irqrestore(&ha->hardware_lock,
+				    flags);
 				atomic_dec(&ha->num_pend_mbx_stage2);
 				rval = QLA_ABORTED;
 				goto premature_exit;
@@ -362,7 +379,10 @@ qla2x00_mailbox_command(scsi_qla_host_t *vha, mbx_cmd_t *mcp)
 		clear_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags);
 
 		if (IS_P3P_TYPE(ha) && ha->flags.isp82xx_fw_hung) {
+			spin_lock_irqsave(&ha->hardware_lock, flags);
 			ha->flags.mbox_busy = 0;
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
 			/* Setting Link-Down error */
 			mcp->mb[0] = MBS_LINK_DOWN_ERROR;
 			ha->mcp = NULL;
@@ -435,7 +455,10 @@ qla2x00_mailbox_command(scsi_qla_host_t *vha, mbx_cmd_t *mcp)
 				 * then only PCI ERR flag would be set.
 				 * we will do premature exit for above case.
 				 */
+				spin_lock_irqsave(&ha->hardware_lock, flags);
 				ha->flags.mbox_busy = 0;
+				spin_unlock_irqrestore(&ha->hardware_lock,
+				    flags);
 				rval = QLA_FUNCTION_TIMEOUT;
 				goto premature_exit;
 			}
@@ -450,8 +473,9 @@ qla2x00_mailbox_command(scsi_qla_host_t *vha, mbx_cmd_t *mcp)
 			rval = QLA_FUNCTION_TIMEOUT;
 		 }
 	}
-
+	spin_lock_irqsave(&ha->hardware_lock, flags);
 	ha->flags.mbox_busy = 0;
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 
 	/* Clean up */
 	ha->mcp = NULL;
diff --git a/drivers/scsi/qla2xxx/qla_target.c b/drivers/scsi/qla2xxx/qla_target.c
index 0a79c28f94c5..a52db34c146a 100644
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@ -1476,27 +1476,14 @@ int qlt_stop_phase1(struct qla_tgt *tgt)
 	struct qla_hw_data *ha = tgt->ha;
 	unsigned long flags;
 
+	mutex_lock(&ha->optrom_mutex);
 	mutex_lock(&qla_tgt_mutex);
-	if (!vha->fc_vport) {
-		struct Scsi_Host *sh = vha->host;
-		struct fc_host_attrs *fc_host = shost_to_fc_host(sh);
-		bool npiv_vports;
-
-		spin_lock_irqsave(sh->host_lock, flags);
-		npiv_vports = (fc_host->npiv_vports_inuse);
-		spin_unlock_irqrestore(sh->host_lock, flags);
-
-		if (npiv_vports) {
-			mutex_unlock(&qla_tgt_mutex);
-			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf021,
-			    "NPIV is in use. Can not stop target\n");
-			return -EPERM;
-		}
-	}
+
 	if (tgt->tgt_stop || tgt->tgt_stopped) {
 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf04e,
 		    "Already in tgt->tgt_stop or tgt_stopped state\n");
 		mutex_unlock(&qla_tgt_mutex);
+		mutex_unlock(&ha->optrom_mutex);
 		return -EPERM;
 	}
 
@@ -1534,6 +1521,8 @@ int qlt_stop_phase1(struct qla_tgt *tgt)
 
 	/* Wait for sessions to clear out (just in case) */
 	wait_event_timeout(tgt->waitQ, test_tgt_sess_count(tgt), 10*HZ);
+	mutex_unlock(&ha->optrom_mutex);
+
 	return 0;
 }
 EXPORT_SYMBOL(qlt_stop_phase1);
@@ -6537,6 +6526,9 @@ qlt_enable_vha(struct scsi_qla_host *vha)
 	qlt_set_mode(vha);
 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 
+	mutex_lock(&ha->optrom_mutex);
+	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf021,
+	    "%s.\n", __func__);
 	if (vha->vp_idx) {
 		qla24xx_disable_vp(vha);
 		qla24xx_enable_vp(vha);
@@ -6545,6 +6537,7 @@ qlt_enable_vha(struct scsi_qla_host *vha)
 		qla2xxx_wake_dpc(base_vha);
 		qla2x00_wait_for_hba_online(base_vha);
 	}
+	mutex_unlock(&ha->optrom_mutex);
 }
 EXPORT_SYMBOL(qlt_enable_vha);
 
