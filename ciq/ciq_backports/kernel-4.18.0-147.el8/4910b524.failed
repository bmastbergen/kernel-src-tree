scsi: qla2xxx: Add support for setting port speed

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Anil Gurumurthy <agurumurthy@marvell.com>
commit 4910b524ac9e61b70e35280877361b790a657d48
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/4910b524.failed

This patch adds sysfs node

1. There is a new sysfs node port_speed
2. The possible values are 2(Auto neg), 8, 16, 32
3. A value outside of the above defaults to Auto neg
4. Any update to the setting causes a link toggle
5. This feature is currently only for ISP27xx

	Signed-off-by: Anil Gurumurthy <agurumurthy@marvell.com>
	Signed-off-by: Quinn Tran <qtran@marvell.com>
	Signed-off-by: Himanshu Madhani <hmadhani@marvell.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 4910b524ac9e61b70e35280877361b790a657d48)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_attr.c
#	drivers/scsi/qla2xxx/qla_gbl.h
diff --cc drivers/scsi/qla2xxx/qla_attr.c
index c8731568f9c4,ee9f943f4d07..000000000000
--- a/drivers/scsi/qla2xxx/qla_attr.c
+++ b/drivers/scsi/qla2xxx/qla_attr.c
@@@ -1513,7 -1632,534 +1513,538 @@@ qla2x00_max_speed_sup_show(struct devic
  	    ha->max_speed_sup ? "32Gps" : "16Gps");
  }
  
++<<<<<<< HEAD
 +static DEVICE_ATTR(driver_version, S_IRUGO, qla2x00_drvr_version_show, NULL);
++=======
+ static ssize_t
+ qla2x00_port_speed_store(struct device *dev, struct device_attribute *attr,
+     const char *buf, size_t count)
+ {
+ 	struct scsi_qla_host *vha = shost_priv(dev_to_shost(dev));
+ 	ulong type, speed;
+ 	int oldspeed, rval;
+ 	int mode = QLA_SET_DATA_RATE_LR;
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	if (!IS_QLA27XX(vha->hw)) {
+ 		ql_log(ql_log_warn, vha, 0x70d8,
+ 		    "Speed setting not supported \n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	rval = kstrtol(buf, 10, &type);
+ 	speed = type;
+ 	if (type == 40 || type == 80 || type == 160 ||
+ 	    type == 320) {
+ 		ql_dbg(ql_dbg_user, vha, 0x70d9,
+ 		    "Setting will be affected after a loss of sync\n");
+ 		type = type/10;
+ 		mode = QLA_SET_DATA_RATE_NOLR;
+ 	}
+ 
+ 	oldspeed = ha->set_data_rate;
+ 
+ 	switch (type) {
+ 	case 0:
+ 		ha->set_data_rate = PORT_SPEED_AUTO;
+ 		break;
+ 	case 4:
+ 		ha->set_data_rate = PORT_SPEED_4GB;
+ 		break;
+ 	case 8:
+ 		ha->set_data_rate = PORT_SPEED_8GB;
+ 		break;
+ 	case 16:
+ 		ha->set_data_rate = PORT_SPEED_16GB;
+ 		break;
+ 	case 32:
+ 		ha->set_data_rate = PORT_SPEED_32GB;
+ 		break;
+ 	default:
+ 		ql_log(ql_log_warn, vha, 0x1199,
+ 		    "Unrecognized speed setting:%lx. Setting Autoneg\n",
+ 		    speed);
+ 		ha->set_data_rate = PORT_SPEED_AUTO;
+ 	}
+ 
+ 	if (qla2x00_chip_is_down(vha) || (oldspeed == ha->set_data_rate))
+ 		return -EINVAL;
+ 
+ 	ql_log(ql_log_info, vha, 0x70da,
+ 	    "Setting speed to %lx Gbps \n", type);
+ 
+ 	rval = qla2x00_set_data_rate(vha, mode);
+ 	if (rval != QLA_SUCCESS)
+ 		return -EIO;
+ 
+ 	return strlen(buf);
+ }
+ 
+ static ssize_t
+ qla2x00_port_speed_show(struct device *dev, struct device_attribute *attr,
+     char *buf)
+ {
+ 	struct scsi_qla_host *vha = shost_priv(dev_to_shost(dev));
+ 	struct qla_hw_data *ha = vha->hw;
+ 	ssize_t rval;
+ 	char *spd[7] = {"0", "0", "0", "4", "8", "16", "32"};
+ 
+ 	rval = qla2x00_get_data_rate(vha);
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_log(ql_log_warn, vha, 0x70db,
+ 		    "Unable to get port speed rval:%zd\n", rval);
+ 		return -EINVAL;
+ 	}
+ 
+ 	ql_log(ql_log_info, vha, 0x70d6,
+ 	    "port speed:%d\n", ha->link_data_rate);
+ 
+ 	return scnprintf(buf, PAGE_SIZE, "%s\n", spd[ha->link_data_rate]);
+ }
+ 
+ /* ----- */
+ 
+ static ssize_t
+ qlini_mode_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	scsi_qla_host_t *vha = shost_priv(class_to_shost(dev));
+ 	int len = 0;
+ 
+ 	len += scnprintf(buf + len, PAGE_SIZE-len,
+ 	    "Supported options: enabled | disabled | dual | exclusive\n");
+ 
+ 	/* --- */
+ 	len += scnprintf(buf + len, PAGE_SIZE-len, "Current selection: ");
+ 
+ 	switch (vha->qlini_mode) {
+ 	case QLA2XXX_INI_MODE_EXCLUSIVE:
+ 		len += scnprintf(buf + len, PAGE_SIZE-len,
+ 		    QLA2XXX_INI_MODE_STR_EXCLUSIVE);
+ 		break;
+ 	case QLA2XXX_INI_MODE_DISABLED:
+ 		len += scnprintf(buf + len, PAGE_SIZE-len,
+ 		    QLA2XXX_INI_MODE_STR_DISABLED);
+ 		break;
+ 	case QLA2XXX_INI_MODE_ENABLED:
+ 		len += scnprintf(buf + len, PAGE_SIZE-len,
+ 		    QLA2XXX_INI_MODE_STR_ENABLED);
+ 		break;
+ 	case QLA2XXX_INI_MODE_DUAL:
+ 		len += scnprintf(buf + len, PAGE_SIZE-len,
+ 		    QLA2XXX_INI_MODE_STR_DUAL);
+ 		break;
+ 	}
+ 	len += scnprintf(buf + len, PAGE_SIZE-len, "\n");
+ 
+ 	return len;
+ }
+ 
+ static char *mode_to_str[] = {
+ 	"exclusive",
+ 	"disabled",
+ 	"enabled",
+ 	"dual",
+ };
+ 
+ #define NEED_EXCH_OFFLOAD(_exchg) ((_exchg) > FW_DEF_EXCHANGES_CNT)
+ static int qla_set_ini_mode(scsi_qla_host_t *vha, int op)
+ {
+ 	int rc = 0;
+ 	enum {
+ 		NO_ACTION,
+ 		MODE_CHANGE_ACCEPT,
+ 		MODE_CHANGE_NO_ACTION,
+ 		TARGET_STILL_ACTIVE,
+ 	};
+ 	int action = NO_ACTION;
+ 	int set_mode = 0;
+ 	u8  eo_toggle = 0;	/* exchange offload flipped */
+ 
+ 	switch (vha->qlini_mode) {
+ 	case QLA2XXX_INI_MODE_DISABLED:
+ 		switch (op) {
+ 		case QLA2XXX_INI_MODE_DISABLED:
+ 			if (qla_tgt_mode_enabled(vha)) {
+ 				if (NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld) !=
+ 				    vha->hw->flags.exchoffld_enabled)
+ 					eo_toggle = 1;
+ 				if (((vha->ql2xexchoffld !=
+ 				    vha->u_ql2xexchoffld) &&
+ 				    NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld)) ||
+ 				    eo_toggle) {
+ 					/*
+ 					 * The number of exchange to be offload
+ 					 * was tweaked or offload option was
+ 					 * flipped
+ 					 */
+ 					action = MODE_CHANGE_ACCEPT;
+ 				} else {
+ 					action = MODE_CHANGE_NO_ACTION;
+ 				}
+ 			} else {
+ 				action = MODE_CHANGE_NO_ACTION;
+ 			}
+ 			break;
+ 		case QLA2XXX_INI_MODE_EXCLUSIVE:
+ 			if (qla_tgt_mode_enabled(vha)) {
+ 				if (NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld) !=
+ 				    vha->hw->flags.exchoffld_enabled)
+ 					eo_toggle = 1;
+ 				if (((vha->ql2xexchoffld !=
+ 				    vha->u_ql2xexchoffld) &&
+ 				    NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld)) ||
+ 				    eo_toggle) {
+ 					/*
+ 					 * The number of exchange to be offload
+ 					 * was tweaked or offload option was
+ 					 * flipped
+ 					 */
+ 					action = MODE_CHANGE_ACCEPT;
+ 				} else {
+ 					action = MODE_CHANGE_NO_ACTION;
+ 				}
+ 			} else {
+ 				action = MODE_CHANGE_ACCEPT;
+ 			}
+ 			break;
+ 		case QLA2XXX_INI_MODE_DUAL:
+ 			action = MODE_CHANGE_ACCEPT;
+ 			/* active_mode is target only, reset it to dual */
+ 			if (qla_tgt_mode_enabled(vha)) {
+ 				set_mode = 1;
+ 				action = MODE_CHANGE_ACCEPT;
+ 			} else {
+ 				action = MODE_CHANGE_NO_ACTION;
+ 			}
+ 			break;
+ 
+ 		case QLA2XXX_INI_MODE_ENABLED:
+ 			if (qla_tgt_mode_enabled(vha))
+ 				action = TARGET_STILL_ACTIVE;
+ 			else {
+ 				action = MODE_CHANGE_ACCEPT;
+ 				set_mode = 1;
+ 			}
+ 			break;
+ 		}
+ 		break;
+ 
+ 	case QLA2XXX_INI_MODE_EXCLUSIVE:
+ 		switch (op) {
+ 		case QLA2XXX_INI_MODE_EXCLUSIVE:
+ 			if (qla_tgt_mode_enabled(vha)) {
+ 				if (NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld) !=
+ 				    vha->hw->flags.exchoffld_enabled)
+ 					eo_toggle = 1;
+ 				if (((vha->ql2xexchoffld !=
+ 				    vha->u_ql2xexchoffld) &&
+ 				    NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld)) ||
+ 				    eo_toggle)
+ 					/*
+ 					 * The number of exchange to be offload
+ 					 * was tweaked or offload option was
+ 					 * flipped
+ 					 */
+ 					action = MODE_CHANGE_ACCEPT;
+ 				else
+ 					action = NO_ACTION;
+ 			} else
+ 				action = NO_ACTION;
+ 
+ 			break;
+ 
+ 		case QLA2XXX_INI_MODE_DISABLED:
+ 			if (qla_tgt_mode_enabled(vha)) {
+ 				if (NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld) !=
+ 				    vha->hw->flags.exchoffld_enabled)
+ 					eo_toggle = 1;
+ 				if (((vha->ql2xexchoffld !=
+ 				      vha->u_ql2xexchoffld) &&
+ 				    NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld)) ||
+ 				    eo_toggle)
+ 					action = MODE_CHANGE_ACCEPT;
+ 				else
+ 					action = MODE_CHANGE_NO_ACTION;
+ 			} else
+ 				action = MODE_CHANGE_NO_ACTION;
+ 			break;
+ 
+ 		case QLA2XXX_INI_MODE_DUAL: /* exclusive -> dual */
+ 			if (qla_tgt_mode_enabled(vha)) {
+ 				action = MODE_CHANGE_ACCEPT;
+ 				set_mode = 1;
+ 			} else
+ 				action = MODE_CHANGE_ACCEPT;
+ 			break;
+ 
+ 		case QLA2XXX_INI_MODE_ENABLED:
+ 			if (qla_tgt_mode_enabled(vha))
+ 				action = TARGET_STILL_ACTIVE;
+ 			else {
+ 				if (vha->hw->flags.fw_started)
+ 					action = MODE_CHANGE_NO_ACTION;
+ 				else
+ 					action = MODE_CHANGE_ACCEPT;
+ 			}
+ 			break;
+ 		}
+ 		break;
+ 
+ 	case QLA2XXX_INI_MODE_ENABLED:
+ 		switch (op) {
+ 		case QLA2XXX_INI_MODE_ENABLED:
+ 			if (NEED_EXCH_OFFLOAD(vha->u_ql2xiniexchg) !=
+ 			    vha->hw->flags.exchoffld_enabled)
+ 				eo_toggle = 1;
+ 			if (((vha->ql2xiniexchg != vha->u_ql2xiniexchg) &&
+ 				NEED_EXCH_OFFLOAD(vha->u_ql2xiniexchg)) ||
+ 			    eo_toggle)
+ 				action = MODE_CHANGE_ACCEPT;
+ 			else
+ 				action = NO_ACTION;
+ 			break;
+ 		case QLA2XXX_INI_MODE_DUAL:
+ 		case QLA2XXX_INI_MODE_DISABLED:
+ 			action = MODE_CHANGE_ACCEPT;
+ 			break;
+ 		default:
+ 			action = MODE_CHANGE_NO_ACTION;
+ 			break;
+ 		}
+ 		break;
+ 
+ 	case QLA2XXX_INI_MODE_DUAL:
+ 		switch (op) {
+ 		case QLA2XXX_INI_MODE_DUAL:
+ 			if (qla_tgt_mode_enabled(vha) ||
+ 			    qla_dual_mode_enabled(vha)) {
+ 				if (NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld +
+ 					vha->u_ql2xiniexchg) !=
+ 				    vha->hw->flags.exchoffld_enabled)
+ 					eo_toggle = 1;
+ 
+ 				if ((((vha->ql2xexchoffld +
+ 				       vha->ql2xiniexchg) !=
+ 				    (vha->u_ql2xiniexchg +
+ 				     vha->u_ql2xexchoffld)) &&
+ 				    NEED_EXCH_OFFLOAD(vha->u_ql2xiniexchg +
+ 					vha->u_ql2xexchoffld)) || eo_toggle)
+ 					action = MODE_CHANGE_ACCEPT;
+ 				else
+ 					action = NO_ACTION;
+ 			} else {
+ 				if (NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld +
+ 					vha->u_ql2xiniexchg) !=
+ 				    vha->hw->flags.exchoffld_enabled)
+ 					eo_toggle = 1;
+ 
+ 				if ((((vha->ql2xexchoffld + vha->ql2xiniexchg)
+ 				    != (vha->u_ql2xiniexchg +
+ 					vha->u_ql2xexchoffld)) &&
+ 				    NEED_EXCH_OFFLOAD(vha->u_ql2xiniexchg +
+ 					vha->u_ql2xexchoffld)) || eo_toggle)
+ 					action = MODE_CHANGE_NO_ACTION;
+ 				else
+ 					action = NO_ACTION;
+ 			}
+ 			break;
+ 
+ 		case QLA2XXX_INI_MODE_DISABLED:
+ 			if (qla_tgt_mode_enabled(vha) ||
+ 			    qla_dual_mode_enabled(vha)) {
+ 				/* turning off initiator mode */
+ 				set_mode = 1;
+ 				action = MODE_CHANGE_ACCEPT;
+ 			} else {
+ 				action = MODE_CHANGE_NO_ACTION;
+ 			}
+ 			break;
+ 
+ 		case QLA2XXX_INI_MODE_EXCLUSIVE:
+ 			if (qla_tgt_mode_enabled(vha) ||
+ 			    qla_dual_mode_enabled(vha)) {
+ 				set_mode = 1;
+ 				action = MODE_CHANGE_ACCEPT;
+ 			} else {
+ 				action = MODE_CHANGE_ACCEPT;
+ 			}
+ 			break;
+ 
+ 		case QLA2XXX_INI_MODE_ENABLED:
+ 			if (qla_tgt_mode_enabled(vha) ||
+ 			    qla_dual_mode_enabled(vha)) {
+ 				action = TARGET_STILL_ACTIVE;
+ 			} else {
+ 				action = MODE_CHANGE_ACCEPT;
+ 			}
+ 		}
+ 		break;
+ 	}
+ 
+ 	switch (action) {
+ 	case MODE_CHANGE_ACCEPT:
+ 		ql_log(ql_log_warn, vha, 0xffff,
+ 		    "Mode change accepted. From %s to %s, Tgt exchg %d|%d. ini exchg %d|%d\n",
+ 		    mode_to_str[vha->qlini_mode], mode_to_str[op],
+ 		    vha->ql2xexchoffld, vha->u_ql2xexchoffld,
+ 		    vha->ql2xiniexchg, vha->u_ql2xiniexchg);
+ 
+ 		vha->qlini_mode = op;
+ 		vha->ql2xexchoffld = vha->u_ql2xexchoffld;
+ 		vha->ql2xiniexchg = vha->u_ql2xiniexchg;
+ 		if (set_mode)
+ 			qlt_set_mode(vha);
+ 		vha->flags.online = 1;
+ 		set_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);
+ 		break;
+ 
+ 	case MODE_CHANGE_NO_ACTION:
+ 		ql_log(ql_log_warn, vha, 0xffff,
+ 		    "Mode is set. No action taken. From %s to %s, Tgt exchg %d|%d. ini exchg %d|%d\n",
+ 		    mode_to_str[vha->qlini_mode], mode_to_str[op],
+ 		    vha->ql2xexchoffld, vha->u_ql2xexchoffld,
+ 		    vha->ql2xiniexchg, vha->u_ql2xiniexchg);
+ 		vha->qlini_mode = op;
+ 		vha->ql2xexchoffld = vha->u_ql2xexchoffld;
+ 		vha->ql2xiniexchg = vha->u_ql2xiniexchg;
+ 		break;
+ 
+ 	case TARGET_STILL_ACTIVE:
+ 		ql_log(ql_log_warn, vha, 0xffff,
+ 		    "Target Mode is active. Unable to change Mode.\n");
+ 		break;
+ 
+ 	case NO_ACTION:
+ 	default:
+ 		ql_log(ql_log_warn, vha, 0xffff,
+ 		    "Mode unchange. No action taken. %d|%d pct %d|%d.\n",
+ 		    vha->qlini_mode, op,
+ 		    vha->ql2xexchoffld, vha->u_ql2xexchoffld);
+ 		break;
+ 	}
+ 
+ 	return rc;
+ }
+ 
+ static ssize_t
+ qlini_mode_store(struct device *dev, struct device_attribute *attr,
+     const char *buf, size_t count)
+ {
+ 	scsi_qla_host_t *vha = shost_priv(class_to_shost(dev));
+ 	int ini;
+ 
+ 	if (!buf)
+ 		return -EINVAL;
+ 
+ 	if (strncasecmp(QLA2XXX_INI_MODE_STR_EXCLUSIVE, buf,
+ 		strlen(QLA2XXX_INI_MODE_STR_EXCLUSIVE)) == 0)
+ 		ini = QLA2XXX_INI_MODE_EXCLUSIVE;
+ 	else if (strncasecmp(QLA2XXX_INI_MODE_STR_DISABLED, buf,
+ 		strlen(QLA2XXX_INI_MODE_STR_DISABLED)) == 0)
+ 		ini = QLA2XXX_INI_MODE_DISABLED;
+ 	else if (strncasecmp(QLA2XXX_INI_MODE_STR_ENABLED, buf,
+ 		  strlen(QLA2XXX_INI_MODE_STR_ENABLED)) == 0)
+ 		ini = QLA2XXX_INI_MODE_ENABLED;
+ 	else if (strncasecmp(QLA2XXX_INI_MODE_STR_DUAL, buf,
+ 		strlen(QLA2XXX_INI_MODE_STR_DUAL)) == 0)
+ 		ini = QLA2XXX_INI_MODE_DUAL;
+ 	else
+ 		return -EINVAL;
+ 
+ 	qla_set_ini_mode(vha, ini);
+ 	return strlen(buf);
+ }
+ 
+ static ssize_t
+ ql2xexchoffld_show(struct device *dev, struct device_attribute *attr,
+     char *buf)
+ {
+ 	scsi_qla_host_t *vha = shost_priv(class_to_shost(dev));
+ 	int len = 0;
+ 
+ 	len += scnprintf(buf + len, PAGE_SIZE-len,
+ 		"target exchange: new %d : current: %d\n\n",
+ 		vha->u_ql2xexchoffld, vha->ql2xexchoffld);
+ 
+ 	len += scnprintf(buf + len, PAGE_SIZE-len,
+ 	    "Please (re)set operating mode via \"/sys/class/scsi_host/host%ld/qlini_mode\" to load new setting.\n",
+ 	    vha->host_no);
+ 
+ 	return len;
+ }
+ 
+ static ssize_t
+ ql2xexchoffld_store(struct device *dev, struct device_attribute *attr,
+     const char *buf, size_t count)
+ {
+ 	scsi_qla_host_t *vha = shost_priv(class_to_shost(dev));
+ 	int val = 0;
+ 
+ 	if (sscanf(buf, "%d", &val) != 1)
+ 		return -EINVAL;
+ 
+ 	if (val > FW_MAX_EXCHANGES_CNT)
+ 		val = FW_MAX_EXCHANGES_CNT;
+ 	else if (val < 0)
+ 		val = 0;
+ 
+ 	vha->u_ql2xexchoffld = val;
+ 	return strlen(buf);
+ }
+ 
+ static ssize_t
+ ql2xiniexchg_show(struct device *dev, struct device_attribute *attr,
+     char *buf)
+ {
+ 	scsi_qla_host_t *vha = shost_priv(class_to_shost(dev));
+ 	int len = 0;
+ 
+ 	len += scnprintf(buf + len, PAGE_SIZE-len,
+ 		"target exchange: new %d : current: %d\n\n",
+ 		vha->u_ql2xiniexchg, vha->ql2xiniexchg);
+ 
+ 	len += scnprintf(buf + len, PAGE_SIZE-len,
+ 	    "Please (re)set operating mode via \"/sys/class/scsi_host/host%ld/qlini_mode\" to load new setting.\n",
+ 	    vha->host_no);
+ 
+ 	return len;
+ }
+ 
+ static ssize_t
+ ql2xiniexchg_store(struct device *dev, struct device_attribute *attr,
+     const char *buf, size_t count)
+ {
+ 	scsi_qla_host_t *vha = shost_priv(class_to_shost(dev));
+ 	int val = 0;
+ 
+ 	if (sscanf(buf, "%d", &val) != 1)
+ 		return -EINVAL;
+ 
+ 	if (val > FW_MAX_EXCHANGES_CNT)
+ 		val = FW_MAX_EXCHANGES_CNT;
+ 	else if (val < 0)
+ 		val = 0;
+ 
+ 	vha->u_ql2xiniexchg = val;
+ 	return strlen(buf);
+ }
+ 
+ static ssize_t
+ qla2x00_dif_bundle_statistics_show(struct device *dev,
+     struct device_attribute *attr, char *buf)
+ {
+ 	scsi_qla_host_t *vha = shost_priv(class_to_shost(dev));
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	return scnprintf(buf, PAGE_SIZE,
+ 	    "cross=%llu read=%llu write=%llu kalloc=%llu dma_alloc=%llu unusable=%u\n",
+ 	    ha->dif_bundle_crossed_pages, ha->dif_bundle_reads,
+ 	    ha->dif_bundle_writes, ha->dif_bundle_kallocs,
+ 	    ha->dif_bundle_dma_allocs, ha->pool.unusable.count);
+ }
+ 
+ static DEVICE_ATTR(driver_version, S_IRUGO, qla2x00_driver_version_show, NULL);
++>>>>>>> 4910b524ac9e (scsi: qla2xxx: Add support for setting port speed)
  static DEVICE_ATTR(fw_version, S_IRUGO, qla2x00_fw_version_show, NULL);
  static DEVICE_ATTR(serial_num, S_IRUGO, qla2x00_serial_num_show, NULL);
  static DEVICE_ATTR(isp_name, S_IRUGO, qla2x00_isp_name_show, NULL);
@@@ -1560,6 -2206,17 +2091,20 @@@ static DEVICE_ATTR(allow_cna_fw_dump, S
  static DEVICE_ATTR(pep_version, S_IRUGO, qla2x00_pep_version_show, NULL);
  static DEVICE_ATTR(min_link_speed, S_IRUGO, qla2x00_min_link_speed_show, NULL);
  static DEVICE_ATTR(max_speed_sup, S_IRUGO, qla2x00_max_speed_sup_show, NULL);
++<<<<<<< HEAD
++=======
+ static DEVICE_ATTR(zio_threshold, 0644,
+     qla_zio_threshold_show,
+     qla_zio_threshold_store);
+ static DEVICE_ATTR_RW(qlini_mode);
+ static DEVICE_ATTR_RW(ql2xexchoffld);
+ static DEVICE_ATTR_RW(ql2xiniexchg);
+ static DEVICE_ATTR(dif_bundle_statistics, 0444,
+     qla2x00_dif_bundle_statistics_show, NULL);
+ static DEVICE_ATTR(port_speed, 0644, qla2x00_port_speed_show,
+     qla2x00_port_speed_store);
+ 
++>>>>>>> 4910b524ac9e (scsi: qla2xxx: Add support for setting port speed)
  
  struct device_attribute *qla2x00_host_attrs[] = {
  	&dev_attr_driver_version,
@@@ -1596,6 -2253,12 +2141,15 @@@
  	&dev_attr_pep_version,
  	&dev_attr_min_link_speed,
  	&dev_attr_max_speed_sup,
++<<<<<<< HEAD
++=======
+ 	&dev_attr_zio_threshold,
+ 	&dev_attr_dif_bundle_statistics,
+ 	&dev_attr_port_speed,
+ 	NULL, /* reserve for qlini_mode */
+ 	NULL, /* reserve for ql2xiniexchg */
+ 	NULL, /* reserve for ql2xexchoffld */
++>>>>>>> 4910b524ac9e (scsi: qla2xxx: Add support for setting port speed)
  	NULL,
  };
  
diff --cc drivers/scsi/qla2xxx/qla_gbl.h
index e792c390f32e,3c59006e64bb..000000000000
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@@ -895,5 -898,7 +895,10 @@@ void qlt_unknown_atio_work_fn(struct wo
  void qlt_update_host_map(struct scsi_qla_host *, port_id_t);
  void qlt_remove_target_resources(struct qla_hw_data *);
  void qlt_clr_qp_table(struct scsi_qla_host *vha);
++<<<<<<< HEAD
++=======
+ void qlt_set_mode(struct scsi_qla_host *);
+ int qla2x00_set_data_rate(scsi_qla_host_t *vha, uint16_t mode);
++>>>>>>> 4910b524ac9e (scsi: qla2xxx: Add support for setting port speed)
  
  #endif /* _QLA_GBL_H */
* Unmerged path drivers/scsi/qla2xxx/qla_attr.c
diff --git a/drivers/scsi/qla2xxx/qla_def.h b/drivers/scsi/qla2xxx/qla_def.h
index 1ec64c7b6ed3..9ec3b1119bd6 100644
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@ -3679,12 +3679,14 @@ struct qla_hw_data {
 #define PORT_SPEED_UNKNOWN 0xFFFF
 #define PORT_SPEED_1GB  0x00
 #define PORT_SPEED_2GB  0x01
+#define PORT_SPEED_AUTO 0x02
 #define PORT_SPEED_4GB  0x03
 #define PORT_SPEED_8GB  0x04
 #define PORT_SPEED_16GB 0x05
 #define PORT_SPEED_32GB 0x06
 #define PORT_SPEED_10GB	0x13
 	uint16_t	link_data_rate;         /* F/W operating speed */
+	uint16_t	set_data_rate;		/* Set by user */
 
 	uint8_t		current_topology;
 	uint8_t		prev_topology;
@@ -4186,6 +4188,10 @@ struct qla_hw_data {
 #define FW_ABILITY_MAX_SPEED(ha)	\
 	(ha->fw_ability_mask & FW_ABILITY_MAX_SPEED_MASK)
 
+#define QLA_GET_DATA_RATE	0
+#define QLA_SET_DATA_RATE_NOLR	1
+#define QLA_SET_DATA_RATE_LR	2 /* Set speed and initiate LR */
+
 /*
  * Qlogic scsi host structure
  */
* Unmerged path drivers/scsi/qla2xxx/qla_gbl.h
diff --git a/drivers/scsi/qla2xxx/qla_init.c b/drivers/scsi/qla2xxx/qla_init.c
index 662860045a48..ba1ee900acce 100644
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@ -3694,8 +3694,17 @@ qla24xx_config_rings(struct scsi_qla_host *vha)
 		WRT_REG_DWORD(&reg->isp24.rsp_q_in, 0);
 		WRT_REG_DWORD(&reg->isp24.rsp_q_out, 0);
 	}
+
 	qlt_24xx_config_rings(vha);
 
+	/* If the user has configured the speed, set it here */
+	if (ha->set_data_rate) {
+		ql_dbg(ql_dbg_init, vha, 0x00fd,
+		    "Speed set by user : %s Gbps \n",
+		    qla2x00_get_link_speed_str(ha, ha->set_data_rate));
+		icb->firmware_options_3 = (ha->set_data_rate << 13);
+	}
+
 	/* PCI posting */
 	RD_REG_DWORD(&ioreg->hccr);
 }
diff --git a/drivers/scsi/qla2xxx/qla_mbx.c b/drivers/scsi/qla2xxx/qla_mbx.c
index 208425525023..244aa70abd7d 100644
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@ -5204,6 +5204,66 @@ qla81xx_write_mpi_register(scsi_qla_host_t *vha, uint16_t *mb)
 	return rval;
 }
 
+/* Set the specified data rate */
+int
+qla2x00_set_data_rate(scsi_qla_host_t *vha, uint16_t mode)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+	struct qla_hw_data *ha = vha->hw;
+	uint16_t val;
+
+	ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1106,
+	    "Entered %s speed:0x%x mode:0x%x.\n", __func__, ha->set_data_rate,
+	    mode);
+
+	if (!IS_FWI2_CAPABLE(ha))
+		return QLA_FUNCTION_FAILED;
+
+	memset(mcp, 0, sizeof(*mcp));
+	switch (ha->set_data_rate) {
+	case PORT_SPEED_AUTO:
+	case PORT_SPEED_4GB:
+	case PORT_SPEED_8GB:
+	case PORT_SPEED_16GB:
+	case PORT_SPEED_32GB:
+		val = ha->set_data_rate;
+		break;
+	default:
+		ql_log(ql_log_warn, vha, 0x1199,
+		    "Unrecognized speed setting:%d. Setting Autoneg\n",
+		    ha->set_data_rate);
+		val = ha->set_data_rate = PORT_SPEED_AUTO;
+		break;
+	}
+
+	mcp->mb[0] = MBC_DATA_RATE;
+	mcp->mb[1] = mode;
+	mcp->mb[2] = val;
+
+	mcp->out_mb = MBX_2|MBX_1|MBX_0;
+	mcp->in_mb = MBX_2|MBX_1|MBX_0;
+	if (IS_QLA83XX(ha) || IS_QLA27XX(ha))
+		mcp->in_mb |= MBX_4|MBX_3;
+	mcp->tov = MBX_TOV_SECONDS;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(vha, mcp);
+	if (rval != QLA_SUCCESS) {
+		ql_dbg(ql_dbg_mbx, vha, 0x1107,
+		    "Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);
+	} else {
+		if (mcp->mb[1] != 0x7)
+			ql_dbg(ql_dbg_mbx, vha, 0x1179,
+				"Speed set:0x%x\n", mcp->mb[1]);
+
+		ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1108,
+		    "Done %s.\n", __func__);
+	}
+
+	return rval;
+}
+
 int
 qla2x00_get_data_rate(scsi_qla_host_t *vha)
 {
@@ -5219,7 +5279,7 @@ qla2x00_get_data_rate(scsi_qla_host_t *vha)
 		return QLA_FUNCTION_FAILED;
 
 	mcp->mb[0] = MBC_DATA_RATE;
-	mcp->mb[1] = 0;
+	mcp->mb[1] = QLA_GET_DATA_RATE;
 	mcp->out_mb = MBX_1|MBX_0;
 	mcp->in_mb = MBX_2|MBX_1|MBX_0;
 	if (IS_QLA83XX(ha) || IS_QLA27XX(ha))
