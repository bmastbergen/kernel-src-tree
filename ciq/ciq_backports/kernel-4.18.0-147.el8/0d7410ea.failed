tools/bpf: check precise {func, line, jited_line}_info_rec_size in test_btf

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Yonghong Song <yhs@fb.com>
commit 0d7410ea6efcdfda56773999f692bbd5d4e4bc00
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/0d7410ea.failed

Current btf func_info, line_info and jited_line are designed to be
extensible. The record sizes for {func,line}_info are passed to kernel,
and the record sizes for {func,line,jited_line}_info are returned to
userspace during bpf_prog_info query.

In bpf selftests test_btf.c, when testing whether kernel returns
a legitimate {func,line, jited_line)_info rec_size, the test only
compares to the minimum allowed size. If the returned rec_size is smaller
than the minimum allowed size, it is considered incorrect.
The minimum allowed size for these three info sizes are equal to
current value of sizeof(struct bpf_func_info), sizeof(struct bpf_line_info)
and sizeof(__u64).

The original thinking was that in the future when rec_size is increased
in kernel, the same test should run correctly. But this sacrificed
the precision of testing under the very kernel the test is shipped with,
and bpf selftest is typically run with the same repo kernel.

So this patch changed the testing of rec_size such that the
kernel returned value should be equal to the size defined by
tools uapi header bpf.h which syncs with kernel uapi header.

Martin discovered a bug in one of rec_size comparisons.
Instead of comparing to minimum func_info rec_size 8, it compares to 4.
This patch fixed that issue as well.

Fixes: 999d82cbc044 ("tools/bpf: enhance test_btf file testing to test func info")
Fixes: 05687352c600 ("bpf: Refactor and bug fix in test_func_type in test_btf.c")
Fixes: 4d6304c76355 ("bpf: Add unit tests for bpf_line_info")
	Suggested-by: Martin KaFai Lau <kafai@fb.com>
	Acked-by: Martin KaFai Lau <kafai@fb.com>
	Signed-off-by: Yonghong Song <yhs@fb.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit 0d7410ea6efcdfda56773999f692bbd5d4e4bc00)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/bpf/test_btf.c
diff --cc tools/testing/selftests/bpf/test_btf.c
index 63c4a0e26e4e,8024b7d4c354..000000000000
--- a/tools/testing/selftests/bpf/test_btf.c
+++ b/tools/testing/selftests/bpf/test_btf.c
@@@ -4191,20 -4481,345 +4191,310 @@@ static size_t probe_prog_length(const s
  	return len + 1;
  }
  
 -static __u32 *patch_name_tbd(const __u32 *raw_u32,
 -			     const char *str, __u32 str_off,
 -			     unsigned int str_sec_size,
 -			     unsigned int *ret_size)
 -{
 -	int i, raw_u32_size = get_raw_sec_size(raw_u32);
 -	const char *end_str = str + str_sec_size;
 -	const char *next_str = str + str_off;
 -	__u32 *new_u32 = NULL;
 -
 -	if (raw_u32_size == -1)
 -		return ERR_PTR(-EINVAL);
 -
 -	if (!raw_u32_size) {
 -		*ret_size = 0;
 -		return NULL;
 -	}
 -
 -	new_u32 = malloc(raw_u32_size);
 -	if (!new_u32)
 -		return ERR_PTR(-ENOMEM);
 -
 -	for (i = 0; i < raw_u32_size / sizeof(raw_u32[0]); i++) {
 -		if (raw_u32[i] == NAME_TBD) {
 -			next_str = get_next_str(next_str, end_str);
 -			if (CHECK(!next_str, "Error in getting next_str\n")) {
 -				free(new_u32);
 -				return ERR_PTR(-EINVAL);
 -			}
 -			new_u32[i] = next_str - str;
 -			next_str += strlen(next_str);
 -		} else {
 -			new_u32[i] = raw_u32[i];
 -		}
 -	}
 -
 -	*ret_size = raw_u32_size;
 -	return new_u32;
 -}
 -
 -static int test_get_finfo(const struct prog_info_raw_test *test,
 -			  int prog_fd)
 +static int do_test_func_type(int test_num)
  {
 +	const struct btf_func_type_test *test = &func_type_test[test_num];
 +	unsigned int raw_btf_size, info_len, rec_size;
 +	int i, btf_fd = -1, prog_fd = -1, err = 0;
 +	struct bpf_load_program_attr attr = {};
 +	void *raw_btf, *func_info = NULL;
  	struct bpf_prog_info info = {};
  	struct bpf_func_info *finfo;
 -	__u32 info_len, rec_size, i;
 -	void *func_info = NULL;
 -	int err;
  
++<<<<<<< HEAD
 +	fprintf(stderr, "%s......", test->descr);
++=======
+ 	/* get necessary lens */
+ 	info_len = sizeof(struct bpf_prog_info);
+ 	err = bpf_obj_get_info_by_fd(prog_fd, &info, &info_len);
+ 	if (CHECK(err == -1, "invalid get info (1st) errno:%d", errno)) {
+ 		fprintf(stderr, "%s\n", btf_log_buf);
+ 		return -1;
+ 	}
+ 	if (CHECK(info.nr_func_info != test->func_info_cnt,
+ 		  "incorrect info.nr_func_info (1st) %d",
+ 		  info.nr_func_info)) {
+ 		return -1;
+ 	}
+ 
+ 	rec_size = info.func_info_rec_size;
+ 	if (CHECK(rec_size != sizeof(struct bpf_func_info),
+ 		  "incorrect info.func_info_rec_size (1st) %d", rec_size)) {
+ 		return -1;
+ 	}
+ 
+ 	if (!info.nr_func_info)
+ 		return 0;
+ 
+ 	func_info = malloc(info.nr_func_info * rec_size);
+ 	if (CHECK(!func_info, "out of memory"))
+ 		return -1;
+ 
+ 	/* reset info to only retrieve func_info related data */
+ 	memset(&info, 0, sizeof(info));
+ 	info.nr_func_info = test->func_info_cnt;
+ 	info.func_info_rec_size = rec_size;
+ 	info.func_info = ptr_to_u64(func_info);
+ 	err = bpf_obj_get_info_by_fd(prog_fd, &info, &info_len);
+ 	if (CHECK(err == -1, "invalid get info (2nd) errno:%d", errno)) {
+ 		fprintf(stderr, "%s\n", btf_log_buf);
+ 		err = -1;
+ 		goto done;
+ 	}
+ 	if (CHECK(info.nr_func_info != test->func_info_cnt,
+ 		  "incorrect info.nr_func_info (2nd) %d",
+ 		  info.nr_func_info)) {
+ 		err = -1;
+ 		goto done;
+ 	}
+ 	if (CHECK(info.func_info_rec_size != rec_size,
+ 		  "incorrect info.func_info_rec_size (2nd) %d",
+ 		  info.func_info_rec_size)) {
+ 		err = -1;
+ 		goto done;
+ 	}
+ 
+ 	finfo = func_info;
+ 	for (i = 0; i < test->func_info_cnt; i++) {
+ 		if (CHECK(finfo->type_id != test->func_info[i][1],
+ 			  "incorrect func_type %u expected %u",
+ 			  finfo->type_id, test->func_info[i][1])) {
+ 			err = -1;
+ 			goto done;
+ 		}
+ 		finfo = (void *)finfo + rec_size;
+ 	}
+ 
+ 	err = 0;
+ 
+ done:
+ 	free(func_info);
+ 	return err;
+ }
+ 
+ static int test_get_linfo(const struct prog_info_raw_test *test,
+ 			  const void *patched_linfo,
+ 			  __u32 cnt, int prog_fd)
+ {
+ 	__u32 i, info_len, nr_jited_ksyms, nr_jited_func_lens;
+ 	__u64 *jited_linfo = NULL, *jited_ksyms = NULL;
+ 	__u32 rec_size, jited_rec_size, jited_cnt;
+ 	struct bpf_line_info *linfo = NULL;
+ 	__u32 cur_func_len, ksyms_found;
+ 	struct bpf_prog_info info = {};
+ 	__u32 *jited_func_lens = NULL;
+ 	__u64 cur_func_ksyms;
+ 	int err;
+ 
+ 	jited_cnt = cnt;
+ 	rec_size = sizeof(*linfo);
+ 	jited_rec_size = sizeof(*jited_linfo);
+ 	if (test->nr_jited_ksyms)
+ 		nr_jited_ksyms = test->nr_jited_ksyms;
+ 	else
+ 		nr_jited_ksyms = test->func_info_cnt;
+ 	nr_jited_func_lens = nr_jited_ksyms;
+ 
+ 	info_len = sizeof(struct bpf_prog_info);
+ 	err = bpf_obj_get_info_by_fd(prog_fd, &info, &info_len);
+ 	if (CHECK(err == -1, "err:%d errno:%d", err, errno)) {
+ 		err = -1;
+ 		goto done;
+ 	}
+ 
+ 	if (!info.jited_prog_len) {
+ 		/* prog is not jited */
+ 		jited_cnt = 0;
+ 		nr_jited_ksyms = 1;
+ 		nr_jited_func_lens = 1;
+ 	}
+ 
+ 	if (CHECK(info.nr_line_info != cnt ||
+ 		  info.nr_jited_line_info != jited_cnt ||
+ 		  info.nr_jited_ksyms != nr_jited_ksyms ||
+ 		  info.nr_jited_func_lens != nr_jited_func_lens ||
+ 		  (!info.nr_line_info && info.nr_jited_line_info),
+ 		  "info: nr_line_info:%u(expected:%u) nr_jited_line_info:%u(expected:%u) nr_jited_ksyms:%u(expected:%u) nr_jited_func_lens:%u(expected:%u)",
+ 		  info.nr_line_info, cnt,
+ 		  info.nr_jited_line_info, jited_cnt,
+ 		  info.nr_jited_ksyms, nr_jited_ksyms,
+ 		  info.nr_jited_func_lens, nr_jited_func_lens)) {
+ 		err = -1;
+ 		goto done;
+ 	}
+ 
+ 	if (CHECK(info.line_info_rec_size != sizeof(struct bpf_line_info) ||
+ 		  info.jited_line_info_rec_size != sizeof(__u64),
+ 		  "info: line_info_rec_size:%u(userspace expected:%u) jited_line_info_rec_size:%u(userspace expected:%u)",
+ 		  info.line_info_rec_size, rec_size,
+ 		  info.jited_line_info_rec_size, jited_rec_size)) {
+ 		err = -1;
+ 		goto done;
+ 	}
+ 
+ 	if (!cnt)
+ 		return 0;
+ 
+ 	rec_size = info.line_info_rec_size;
+ 	jited_rec_size = info.jited_line_info_rec_size;
+ 
+ 	memset(&info, 0, sizeof(info));
+ 
+ 	linfo = calloc(cnt, rec_size);
+ 	if (CHECK(!linfo, "!linfo")) {
+ 		err = -1;
+ 		goto done;
+ 	}
+ 	info.nr_line_info = cnt;
+ 	info.line_info_rec_size = rec_size;
+ 	info.line_info = ptr_to_u64(linfo);
+ 
+ 	if (jited_cnt) {
+ 		jited_linfo = calloc(jited_cnt, jited_rec_size);
+ 		jited_ksyms = calloc(nr_jited_ksyms, sizeof(*jited_ksyms));
+ 		jited_func_lens = calloc(nr_jited_func_lens,
+ 					 sizeof(*jited_func_lens));
+ 		if (CHECK(!jited_linfo || !jited_ksyms || !jited_func_lens,
+ 			  "jited_linfo:%p jited_ksyms:%p jited_func_lens:%p",
+ 			  jited_linfo, jited_ksyms, jited_func_lens)) {
+ 			err = -1;
+ 			goto done;
+ 		}
+ 
+ 		info.nr_jited_line_info = jited_cnt;
+ 		info.jited_line_info_rec_size = jited_rec_size;
+ 		info.jited_line_info = ptr_to_u64(jited_linfo);
+ 		info.nr_jited_ksyms = nr_jited_ksyms;
+ 		info.jited_ksyms = ptr_to_u64(jited_ksyms);
+ 		info.nr_jited_func_lens = nr_jited_func_lens;
+ 		info.jited_func_lens = ptr_to_u64(jited_func_lens);
+ 	}
+ 
+ 	err = bpf_obj_get_info_by_fd(prog_fd, &info, &info_len);
+ 
+ 	/*
+ 	 * Only recheck the info.*line_info* fields.
+ 	 * Other fields are not the concern of this test.
+ 	 */
+ 	if (CHECK(err == -1 ||
+ 		  info.nr_line_info != cnt ||
+ 		  (jited_cnt && !info.jited_line_info) ||
+ 		  info.nr_jited_line_info != jited_cnt ||
+ 		  info.line_info_rec_size != rec_size ||
+ 		  info.jited_line_info_rec_size != jited_rec_size,
+ 		  "err:%d errno:%d info: nr_line_info:%u(expected:%u) nr_jited_line_info:%u(expected:%u) line_info_rec_size:%u(expected:%u) jited_linfo_rec_size:%u(expected:%u) line_info:%p jited_line_info:%p",
+ 		  err, errno,
+ 		  info.nr_line_info, cnt,
+ 		  info.nr_jited_line_info, jited_cnt,
+ 		  info.line_info_rec_size, rec_size,
+ 		  info.jited_line_info_rec_size, jited_rec_size,
+ 		  (void *)(long)info.line_info,
+ 		  (void *)(long)info.jited_line_info)) {
+ 		err = -1;
+ 		goto done;
+ 	}
+ 
+ 	CHECK(linfo[0].insn_off, "linfo[0].insn_off:%u",
+ 	      linfo[0].insn_off);
+ 	for (i = 1; i < cnt; i++) {
+ 		const struct bpf_line_info *expected_linfo;
+ 
+ 		expected_linfo = patched_linfo + (i * test->line_info_rec_size);
+ 		if (CHECK(linfo[i].insn_off <= linfo[i - 1].insn_off,
+ 			  "linfo[%u].insn_off:%u <= linfo[%u].insn_off:%u",
+ 			  i, linfo[i].insn_off,
+ 			  i - 1, linfo[i - 1].insn_off)) {
+ 			err = -1;
+ 			goto done;
+ 		}
+ 		if (CHECK(linfo[i].file_name_off != expected_linfo->file_name_off ||
+ 			  linfo[i].line_off != expected_linfo->line_off ||
+ 			  linfo[i].line_col != expected_linfo->line_col,
+ 			  "linfo[%u] (%u, %u, %u) != (%u, %u, %u)", i,
+ 			  linfo[i].file_name_off,
+ 			  linfo[i].line_off,
+ 			  linfo[i].line_col,
+ 			  expected_linfo->file_name_off,
+ 			  expected_linfo->line_off,
+ 			  expected_linfo->line_col)) {
+ 			err = -1;
+ 			goto done;
+ 		}
+ 	}
+ 
+ 	if (!jited_cnt) {
+ 		fprintf(stderr, "not jited. skipping jited_line_info check. ");
+ 		err = 0;
+ 		goto done;
+ 	}
+ 
+ 	if (CHECK(jited_linfo[0] != jited_ksyms[0],
+ 		  "jited_linfo[0]:%lx != jited_ksyms[0]:%lx",
+ 		  (long)(jited_linfo[0]), (long)(jited_ksyms[0]))) {
+ 		err = -1;
+ 		goto done;
+ 	}
+ 
+ 	ksyms_found = 1;
+ 	cur_func_len = jited_func_lens[0];
+ 	cur_func_ksyms = jited_ksyms[0];
+ 	for (i = 1; i < jited_cnt; i++) {
+ 		if (ksyms_found < nr_jited_ksyms &&
+ 		    jited_linfo[i] == jited_ksyms[ksyms_found]) {
+ 			cur_func_ksyms = jited_ksyms[ksyms_found];
+ 			cur_func_len = jited_ksyms[ksyms_found];
+ 			ksyms_found++;
+ 			continue;
+ 		}
+ 
+ 		if (CHECK(jited_linfo[i] <= jited_linfo[i - 1],
+ 			  "jited_linfo[%u]:%lx <= jited_linfo[%u]:%lx",
+ 			  i, (long)jited_linfo[i],
+ 			  i - 1, (long)(jited_linfo[i - 1]))) {
+ 			err = -1;
+ 			goto done;
+ 		}
+ 
+ 		if (CHECK(jited_linfo[i] - cur_func_ksyms > cur_func_len,
+ 			  "jited_linfo[%u]:%lx - %lx > %u",
+ 			  i, (long)jited_linfo[i], (long)cur_func_ksyms,
+ 			  cur_func_len)) {
+ 			err = -1;
+ 			goto done;
+ 		}
+ 	}
+ 
+ 	if (CHECK(ksyms_found != nr_jited_ksyms,
+ 		  "ksyms_found:%u != nr_jited_ksyms:%u",
+ 		  ksyms_found, nr_jited_ksyms)) {
+ 		err = -1;
+ 		goto done;
+ 	}
+ 
+ 	err = 0;
+ 
+ done:
+ 	free(linfo);
+ 	free(jited_linfo);
+ 	free(jited_ksyms);
+ 	free(jited_func_lens);
+ 	return err;
+ }
+ 
+ static int do_test_info_raw(unsigned int test_num)
+ {
+ 	const struct prog_info_raw_test *test = &info_raw_tests[test_num - 1];
+ 	unsigned int raw_btf_size, linfo_str_off, linfo_size;
+ 	int btf_fd = -1, prog_fd = -1, err = 0;
+ 	void *raw_btf, *patched_linfo = NULL;
+ 	const char *ret_next_str;
+ 	union bpf_attr attr = {};
+ 
+ 	fprintf(stderr, "BTF prog info raw test[%u] (%s): ", test_num, test->descr);
++>>>>>>> 0d7410ea6efc (tools/bpf: check precise {func, line, jited_line}_info_rec_size in test_btf)
  	raw_btf = btf_raw_create(&hdr_tmpl, test->raw_types,
  				 test->str_sec, test->str_sec_size,
 -				 &raw_btf_size, &ret_next_str);
 +				 &raw_btf_size);
  
  	if (!raw_btf)
  		return -1;
* Unmerged path tools/testing/selftests/bpf/test_btf.c
