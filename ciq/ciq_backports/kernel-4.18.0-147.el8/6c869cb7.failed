ice: Retrieve rx_buf in separate function

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Maciej Fijalkowski <maciej.fijalkowski@intel.com>
commit 6c869cb7a8f02b0c5f5494bb37c29b6686711ec8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/6c869cb7.failed

Introduce ice_get_rx_buf, which will fetch the Rx buffer and do the DMA
synchronization. Length of the packet that hardware Rx descriptor
contains is now read in ice_clean_rx_irq, so we can feed ice_get_rx_buf
with it and resign from rx_desc passed as argument in ice_fetch_rx_buf
and ice_add_rx_frag.

	Signed-off-by: Maciej Fijalkowski <maciej.fijalkowski@intel.com>
	Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 6c869cb7a8f02b0c5f5494bb37c29b6686711ec8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_txrx.c
diff --cc drivers/net/ethernet/intel/ice/ice_txrx.c
index b0086743621b,8c0a8b63670b..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_txrx.c
+++ b/drivers/net/ethernet/intel/ice/ice_txrx.c
@@@ -510,9 -510,9 +510,15 @@@ static bool ice_page_is_reserved(struc
   * The function will then update the page offset if necessary and return
   * true if the buffer can be reused by the adapter.
   */
++<<<<<<< HEAD
 +static bool ice_add_rx_frag(struct ice_rx_buf *rx_buf,
 +			    union ice_32b_rx_flex_desc *rx_desc,
 +			    struct sk_buff *skb)
++=======
+ static bool
+ ice_add_rx_frag(struct ice_rx_buf *rx_buf, struct sk_buff *skb,
+ 		unsigned int size)
++>>>>>>> 6c869cb7a8f0 (ice: Retrieve rx_buf in separate function)
  {
  #if (PAGE_SIZE < 8192)
  	unsigned int truesize = ICE_RXBUF_2048;
@@@ -613,21 -634,15 +640,20 @@@ ice_get_rx_buf(struct ice_ring *rx_ring
   * correctly, as well as handling calling the page recycle function if
   * necessary.
   */
++<<<<<<< HEAD
 +static struct sk_buff *ice_fetch_rx_buf(struct ice_ring *rx_ring,
 +					union ice_32b_rx_flex_desc *rx_desc)
++=======
+ static struct sk_buff *
+ ice_fetch_rx_buf(struct ice_ring *rx_ring, struct ice_rx_buf *rx_buf,
+ 		 unsigned int size)
++>>>>>>> 6c869cb7a8f0 (ice: Retrieve rx_buf in separate function)
  {
- 	struct ice_rx_buf *rx_buf;
- 	struct sk_buff *skb;
- 	struct page *page;
- 
- 	rx_buf = &rx_ring->rx_buf[rx_ring->next_to_clean];
- 	page = rx_buf->page;
- 	prefetchw(page);
- 
- 	skb = rx_buf->skb;
+ 	struct sk_buff *skb = rx_buf->skb;
  
  	if (likely(!skb)) {
- 		u8 *page_addr = page_address(page) + rx_buf->page_offset;
+ 		u8 *page_addr = page_address(rx_buf->page) +
+ 				rx_buf->page_offset;
  
  		/* prefetch first cache line of first page */
  		prefetch(page_addr);
* Unmerged path drivers/net/ethernet/intel/ice/ice_txrx.c
