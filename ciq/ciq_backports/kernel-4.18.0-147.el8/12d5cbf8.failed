net/mlx5e: Fix calling wrong function to get inner vlan key and mask

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [net] mlx5e: Fix calling wrong function to get inner vlan key and mask (Ivan Vecera) [1688236 1687456]
Rebuild_FUZZ: 96.97%
commit-author Jianbo Liu <jianbol@mellanox.com>
commit 12d5cbf89a6599f6bbd7b373dba0e74b5bd9c505
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/12d5cbf8.failed

When flow_rule_match_XYZ() functions were first introduced,
flow_rule_match_cvlan() for inner vlan is missing.

In mlx5_core driver, to get inner vlan key and mask, flow_rule_match_vlan()
is just called, which is wrong because it obtains outer vlan information by
FLOW_DISSECTOR_KEY_VLAN.

This commit fixes this by changing to call flow_rule_match_cvlan() after
it's added.

Fixes: 8f2566225ae2 ("flow_offload: add flow_rule and flow_match structures and use them")
	Signed-off-by: Jianbo Liu <jianbol@mellanox.com>
	Signed-off-by: Edward Cree <ecree@solarflare.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 12d5cbf89a6599f6bbd7b373dba0e74b5bd9c505)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 0898ea0b9f0c,542354b5eb4d..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -1376,22 -1592,48 +1376,58 @@@ static int __parse_cls_flower(struct ml
  		*match_level = MLX5_MATCH_L2;
  	}
  
 -	if (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_CVLAN)) {
 -		struct flow_match_vlan match;
 +	if (dissector_uses_key(f->dissector, FLOW_DISSECTOR_KEY_ETH_ADDRS)) {
 +		struct flow_dissector_key_eth_addrs *key =
 +			skb_flow_dissector_target(f->dissector,
 +						  FLOW_DISSECTOR_KEY_ETH_ADDRS,
 +						  f->key);
 +		struct flow_dissector_key_eth_addrs *mask =
 +			skb_flow_dissector_target(f->dissector,
 +						  FLOW_DISSECTOR_KEY_ETH_ADDRS,
 +						  f->mask);
  
++<<<<<<< HEAD
++=======
+ 		flow_rule_match_cvlan(rule, &match);
+ 		if (match.mask->vlan_id ||
+ 		    match.mask->vlan_priority ||
+ 		    match.mask->vlan_tpid) {
+ 			if (match.key->vlan_tpid == htons(ETH_P_8021AD)) {
+ 				MLX5_SET(fte_match_set_misc, misc_c,
+ 					 outer_second_svlan_tag, 1);
+ 				MLX5_SET(fte_match_set_misc, misc_v,
+ 					 outer_second_svlan_tag, 1);
+ 			} else {
+ 				MLX5_SET(fte_match_set_misc, misc_c,
+ 					 outer_second_cvlan_tag, 1);
+ 				MLX5_SET(fte_match_set_misc, misc_v,
+ 					 outer_second_cvlan_tag, 1);
+ 			}
+ 
+ 			MLX5_SET(fte_match_set_misc, misc_c, outer_second_vid,
+ 				 match.mask->vlan_id);
+ 			MLX5_SET(fte_match_set_misc, misc_v, outer_second_vid,
+ 				 match.key->vlan_id);
+ 			MLX5_SET(fte_match_set_misc, misc_c, outer_second_prio,
+ 				 match.mask->vlan_priority);
+ 			MLX5_SET(fte_match_set_misc, misc_v, outer_second_prio,
+ 				 match.key->vlan_priority);
+ 
+ 			*match_level = MLX5_MATCH_L2;
+ 		}
+ 	}
+ 
+ 	if (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ETH_ADDRS)) {
+ 		struct flow_match_eth_addrs match;
+ 
+ 		flow_rule_match_eth_addrs(rule, &match);
++>>>>>>> 12d5cbf89a65 (net/mlx5e: Fix calling wrong function to get inner vlan key and mask)
  		ether_addr_copy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_c,
  					     dmac_47_16),
 -				match.mask->dst);
 +				mask->dst);
  		ether_addr_copy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_v,
  					     dmac_47_16),
 -				match.key->dst);
 +				key->dst);
  
  		ether_addr_copy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_c,
  					     smac_47_16),
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
