bpf: fix pointer offsets in context for 32 bit

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Daniel Borkmann <daniel@iogearbox.net>
commit b7df9ada9a7700dbcca1ba53d217c01e3d48179c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/b7df9ada.failed

Currently, pointer offsets in three BPF context structures are
broken in two scenarios: i) 32 bit compiled applications running
on 64 bit kernels, and ii) LLVM compiled BPF programs running
on 32 bit kernels. The latter is due to BPF target machine being
strictly 64 bit. So in each of the cases the offsets will mismatch
in verifier when checking / rewriting context access. Fix this by
providing a helper macro __bpf_md_ptr() that will enforce padding
up to 64 bit and proper alignment, and for context access a macro
bpf_ctx_range_ptr() which will cover full 64 bit member range on
32 bit archs. For flow_keys, we additionally need to force the
size check to sizeof(__u64) as with other pointer types.

Fixes: d58e468b1112 ("flow_dissector: implements flow dissector BPF hook")
Fixes: 4f738adba30a ("bpf: create tcp_bpf_ulp allowing BPF to monitor socket TX/RX data")
Fixes: 2dbb9b9e6df6 ("bpf: Introduce BPF_PROG_TYPE_SK_REUSEPORT")
	Reported-by: David S. Miller <davem@davemloft.net>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: David S. Miller <davem@davemloft.net>
	Tested-by: David S. Miller <davem@davemloft.net>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit b7df9ada9a7700dbcca1ba53d217c01e3d48179c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/bpf.h
#	net/core/filter.c
#	tools/include/uapi/linux/bpf.h
diff --cc include/uapi/linux/bpf.h
index 4b63e0cf1b0e,426b5c8a245b..000000000000
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@@ -2320,6 -2462,7 +2326,10 @@@ struct __sk_buff 
  	/* ... here. */
  
  	__u32 data_meta;
++<<<<<<< HEAD
++=======
+ 	__bpf_md_ptr(struct bpf_flow_keys *, flow_keys);
++>>>>>>> b7df9ada9a77 (bpf: fix pointer offsets in context for 32 bit)
  };
  
  struct bpf_tunnel_key {
@@@ -2430,6 -2590,31 +2440,34 @@@ struct sk_msg_md 
  	__u32 local_port;	/* stored in host byte order */
  };
  
++<<<<<<< HEAD
++=======
+ struct sk_reuseport_md {
+ 	/*
+ 	 * Start of directly accessible data. It begins from
+ 	 * the tcp/udp header.
+ 	 */
+ 	__bpf_md_ptr(void *, data);
+ 	/* End of directly accessible data */
+ 	__bpf_md_ptr(void *, data_end);
+ 	/*
+ 	 * Total length of packet (starting from the tcp/udp header).
+ 	 * Note that the directly accessible bytes (data_end - data)
+ 	 * could be less than this "len".  Those bytes could be
+ 	 * indirectly read by a helper "bpf_skb_load_bytes()".
+ 	 */
+ 	__u32 len;
+ 	/*
+ 	 * Eth protocol in the mac header (network byte order). e.g.
+ 	 * ETH_P_IP(0x0800) and ETH_P_IPV6(0x86DD)
+ 	 */
+ 	__u32 eth_protocol;
+ 	__u32 ip_protocol;	/* IP protocol. e.g. IPPROTO_TCP, IPPROTO_UDP */
+ 	__u32 bind_inany;	/* Is sock bound to an INANY address? */
+ 	__u32 hash;		/* A hash of the packet 4 tuples */
+ };
+ 
++>>>>>>> b7df9ada9a77 (bpf: fix pointer offsets in context for 32 bit)
  #define BPF_TAG_SIZE	8
  
  struct bpf_prog_info {
diff --cc net/core/filter.c
index f21f8ac16bbc,6ee605da990f..000000000000
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@@ -5185,6 -5435,10 +5185,13 @@@ static bool bpf_skb_is_valid_access(in
  		if (size != size_default)
  			return false;
  		break;
++<<<<<<< HEAD
++=======
+ 	case bpf_ctx_range_ptr(struct __sk_buff, flow_keys):
+ 		if (size != sizeof(__u64))
+ 			return false;
+ 		break;
++>>>>>>> b7df9ada9a77 (bpf: fix pointer offsets in context for 32 bit)
  	default:
  		/* Only narrow read access allowed for now. */
  		if (type == BPF_WRITE) {
@@@ -5210,6 -5464,7 +5217,10 @@@ static bool sk_filter_is_valid_access(i
  	case bpf_ctx_range(struct __sk_buff, data):
  	case bpf_ctx_range(struct __sk_buff, data_meta):
  	case bpf_ctx_range(struct __sk_buff, data_end):
++<<<<<<< HEAD
++=======
+ 	case bpf_ctx_range_ptr(struct __sk_buff, flow_keys):
++>>>>>>> b7df9ada9a77 (bpf: fix pointer offsets in context for 32 bit)
  	case bpf_ctx_range_till(struct __sk_buff, family, local_port):
  		return false;
  	}
@@@ -5275,6 -5530,7 +5286,10 @@@ static bool lwt_is_valid_access(int off
  	case bpf_ctx_range(struct __sk_buff, tc_classid):
  	case bpf_ctx_range_till(struct __sk_buff, family, local_port):
  	case bpf_ctx_range(struct __sk_buff, data_meta):
++<<<<<<< HEAD
++=======
+ 	case bpf_ctx_range_ptr(struct __sk_buff, flow_keys):
++>>>>>>> b7df9ada9a77 (bpf: fix pointer offsets in context for 32 bit)
  		return false;
  	}
  
@@@ -5494,6 -5756,7 +5509,10 @@@ static bool tc_cls_act_is_valid_access(
  	case bpf_ctx_range(struct __sk_buff, data_end):
  		info->reg_type = PTR_TO_PACKET_END;
  		break;
++<<<<<<< HEAD
++=======
+ 	case bpf_ctx_range_ptr(struct __sk_buff, flow_keys):
++>>>>>>> b7df9ada9a77 (bpf: fix pointer offsets in context for 32 bit)
  	case bpf_ctx_range_till(struct __sk_buff, family, local_port):
  		return false;
  	}
@@@ -5695,6 -5958,7 +5714,10 @@@ static bool sk_skb_is_valid_access(int 
  	switch (off) {
  	case bpf_ctx_range(struct __sk_buff, tc_classid):
  	case bpf_ctx_range(struct __sk_buff, data_meta):
++<<<<<<< HEAD
++=======
+ 	case bpf_ctx_range_ptr(struct __sk_buff, flow_keys):
++>>>>>>> b7df9ada9a77 (bpf: fix pointer offsets in context for 32 bit)
  		return false;
  	}
  
@@@ -5761,6 -6018,39 +5784,42 @@@ static bool sk_msg_is_valid_access(int 
  	return true;
  }
  
++<<<<<<< HEAD
++=======
+ static bool flow_dissector_is_valid_access(int off, int size,
+ 					   enum bpf_access_type type,
+ 					   const struct bpf_prog *prog,
+ 					   struct bpf_insn_access_aux *info)
+ {
+ 	if (type == BPF_WRITE) {
+ 		switch (off) {
+ 		case bpf_ctx_range_till(struct __sk_buff, cb[0], cb[4]):
+ 			break;
+ 		default:
+ 			return false;
+ 		}
+ 	}
+ 
+ 	switch (off) {
+ 	case bpf_ctx_range(struct __sk_buff, data):
+ 		info->reg_type = PTR_TO_PACKET;
+ 		break;
+ 	case bpf_ctx_range(struct __sk_buff, data_end):
+ 		info->reg_type = PTR_TO_PACKET_END;
+ 		break;
+ 	case bpf_ctx_range_ptr(struct __sk_buff, flow_keys):
+ 		info->reg_type = PTR_TO_FLOW_KEYS;
+ 		break;
+ 	case bpf_ctx_range(struct __sk_buff, tc_classid):
+ 	case bpf_ctx_range(struct __sk_buff, data_meta):
+ 	case bpf_ctx_range_till(struct __sk_buff, family, local_port):
+ 		return false;
+ 	}
+ 
+ 	return bpf_skb_is_valid_access(off, size, type, prog, info);
+ }
+ 
++>>>>>>> b7df9ada9a77 (bpf: fix pointer offsets in context for 32 bit)
  static u32 bpf_convert_ctx_access(enum bpf_access_type type,
  				  const struct bpf_insn *si,
  				  struct bpf_insn *insn_buf,
diff --cc tools/include/uapi/linux/bpf.h
index a7cd2d213091,426b5c8a245b..000000000000
--- a/tools/include/uapi/linux/bpf.h
+++ b/tools/include/uapi/linux/bpf.h
@@@ -2302,6 -2462,7 +2308,10 @@@ struct __sk_buff 
  	/* ... here. */
  
  	__u32 data_meta;
++<<<<<<< HEAD
++=======
+ 	__bpf_md_ptr(struct bpf_flow_keys *, flow_keys);
++>>>>>>> b7df9ada9a77 (bpf: fix pointer offsets in context for 32 bit)
  };
  
  struct bpf_tunnel_key {
@@@ -2410,7 -2588,31 +2420,35 @@@ struct sk_msg_md 
  	__u32 local_ip6[4];	/* Stored in network byte order */
  	__u32 remote_port;	/* Stored in network byte order */
  	__u32 local_port;	/* stored in host byte order */
++<<<<<<< HEAD
 +	__u32 size;		/* Total size of sk_msg */
++=======
+ };
+ 
+ struct sk_reuseport_md {
+ 	/*
+ 	 * Start of directly accessible data. It begins from
+ 	 * the tcp/udp header.
+ 	 */
+ 	__bpf_md_ptr(void *, data);
+ 	/* End of directly accessible data */
+ 	__bpf_md_ptr(void *, data_end);
+ 	/*
+ 	 * Total length of packet (starting from the tcp/udp header).
+ 	 * Note that the directly accessible bytes (data_end - data)
+ 	 * could be less than this "len".  Those bytes could be
+ 	 * indirectly read by a helper "bpf_skb_load_bytes()".
+ 	 */
+ 	__u32 len;
+ 	/*
+ 	 * Eth protocol in the mac header (network byte order). e.g.
+ 	 * ETH_P_IP(0x0800) and ETH_P_IPV6(0x86DD)
+ 	 */
+ 	__u32 eth_protocol;
+ 	__u32 ip_protocol;	/* IP protocol. e.g. IPPROTO_TCP, IPPROTO_UDP */
+ 	__u32 bind_inany;	/* Is sock bound to an INANY address? */
+ 	__u32 hash;		/* A hash of the packet 4 tuples */
++>>>>>>> b7df9ada9a77 (bpf: fix pointer offsets in context for 32 bit)
  };
  
  #define BPF_TAG_SIZE	8
diff --git a/include/linux/filter.h b/include/linux/filter.h
index 08b997703a96..3abb48df38a6 100644
--- a/include/linux/filter.h
+++ b/include/linux/filter.h
@@ -444,6 +444,13 @@ struct xdp_buff;
 	offsetof(TYPE, MEMBER) ... offsetofend(TYPE, MEMBER) - 1
 #define bpf_ctx_range_till(TYPE, MEMBER1, MEMBER2)				\
 	offsetof(TYPE, MEMBER1) ... offsetofend(TYPE, MEMBER2) - 1
+#if BITS_PER_LONG == 64
+# define bpf_ctx_range_ptr(TYPE, MEMBER)					\
+	offsetof(TYPE, MEMBER) ... offsetofend(TYPE, MEMBER) - 1
+#else
+# define bpf_ctx_range_ptr(TYPE, MEMBER)					\
+	offsetof(TYPE, MEMBER) ... offsetof(TYPE, MEMBER) + 8 - 1
+#endif /* BITS_PER_LONG == 64 */
 
 #define bpf_target_off(TYPE, MEMBER, SIZE, PTR_SIZE)				\
 	({									\
* Unmerged path include/uapi/linux/bpf.h
* Unmerged path net/core/filter.c
* Unmerged path tools/include/uapi/linux/bpf.h
