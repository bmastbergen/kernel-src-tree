virtio: Introduce virtio_max_dma_size()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Joerg Roedel <jroedel@suse.de>
commit e6d6dd6c875eb3c9b69bb640419405726e6e0bbe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/e6d6dd6c.failed

This function returns the maximum segment size for a single
dma transaction of a virtio device. The possible limit comes
from the SWIOTLB implementation in the Linux kernel, that
has an upper limit of (currently) 256kb of contiguous
memory it can map. Other DMA-API implementations might also
have limits.

Use the new dma_max_mapping_size() function to determine the
maximum mapping size when DMA-API is in use for virtio.

	Cc: stable@vger.kernel.org
	Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
	Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
(cherry picked from commit e6d6dd6c875eb3c9b69bb640419405726e6e0bbe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/virtio/virtio_ring.c
diff --cc drivers/virtio/virtio_ring.c
index 814b395007b2,18846afb39da..000000000000
--- a/drivers/virtio/virtio_ring.c
+++ b/drivers/virtio/virtio_ring.c
@@@ -161,6 -271,59 +161,62 @@@ static bool vring_use_dma_api(struct vi
  	return false;
  }
  
++<<<<<<< HEAD
++=======
+ size_t virtio_max_dma_size(struct virtio_device *vdev)
+ {
+ 	size_t max_segment_size = SIZE_MAX;
+ 
+ 	if (vring_use_dma_api(vdev))
+ 		max_segment_size = dma_max_mapping_size(&vdev->dev);
+ 
+ 	return max_segment_size;
+ }
+ EXPORT_SYMBOL_GPL(virtio_max_dma_size);
+ 
+ static void *vring_alloc_queue(struct virtio_device *vdev, size_t size,
+ 			      dma_addr_t *dma_handle, gfp_t flag)
+ {
+ 	if (vring_use_dma_api(vdev)) {
+ 		return dma_alloc_coherent(vdev->dev.parent, size,
+ 					  dma_handle, flag);
+ 	} else {
+ 		void *queue = alloc_pages_exact(PAGE_ALIGN(size), flag);
+ 
+ 		if (queue) {
+ 			phys_addr_t phys_addr = virt_to_phys(queue);
+ 			*dma_handle = (dma_addr_t)phys_addr;
+ 
+ 			/*
+ 			 * Sanity check: make sure we dind't truncate
+ 			 * the address.  The only arches I can find that
+ 			 * have 64-bit phys_addr_t but 32-bit dma_addr_t
+ 			 * are certain non-highmem MIPS and x86
+ 			 * configurations, but these configurations
+ 			 * should never allocate physical pages above 32
+ 			 * bits, so this is fine.  Just in case, throw a
+ 			 * warning and abort if we end up with an
+ 			 * unrepresentable address.
+ 			 */
+ 			if (WARN_ON_ONCE(*dma_handle != phys_addr)) {
+ 				free_pages_exact(queue, PAGE_ALIGN(size));
+ 				return NULL;
+ 			}
+ 		}
+ 		return queue;
+ 	}
+ }
+ 
+ static void vring_free_queue(struct virtio_device *vdev, size_t size,
+ 			     void *queue, dma_addr_t dma_handle)
+ {
+ 	if (vring_use_dma_api(vdev))
+ 		dma_free_coherent(vdev->dev.parent, size, queue, dma_handle);
+ 	else
+ 		free_pages_exact(queue, PAGE_ALIGN(size));
+ }
+ 
++>>>>>>> e6d6dd6c875e (virtio: Introduce virtio_max_dma_size())
  /*
   * The DMA ops on various arches are rather gnarly right now, and
   * making all of the arch DMA ops work on the vring device itself
* Unmerged path drivers/virtio/virtio_ring.c
diff --git a/include/linux/virtio.h b/include/linux/virtio.h
index fa1b5da2804e..673fe3ef3607 100644
--- a/include/linux/virtio.h
+++ b/include/linux/virtio.h
@@ -157,6 +157,8 @@ int virtio_device_freeze(struct virtio_device *dev);
 int virtio_device_restore(struct virtio_device *dev);
 #endif
 
+size_t virtio_max_dma_size(struct virtio_device *vdev);
+
 #define virtio_device_for_each_vq(vdev, vq) \
 	list_for_each_entry(vq, &vdev->vqs, list)
 
