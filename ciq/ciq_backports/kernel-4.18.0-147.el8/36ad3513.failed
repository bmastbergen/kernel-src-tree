x86/speculation: Consolidate CPU whitelists

jira LE-1907
cve CVE-2019-11091
cve CVE-2018-12130
cve CVE-2018-12127
cve CVE-2018-12126
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 36ad35131adacc29b328b9c8b6277a8bf0d6fd5d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/36ad3513.failed

The CPU vulnerability whitelists have some overlap and there are more
whitelists coming along.

Use the driver_data field in the x86_cpu_id struct to denote the
whitelisted vulnerabilities and combine all whitelists into one.

	Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Frederic Weisbecker <frederic@kernel.org>
	Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Reviewed-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Jon Masters <jcm@redhat.com>
	Tested-by: Jon Masters <jcm@redhat.com>
(cherry picked from commit 36ad35131adacc29b328b9c8b6277a8bf0d6fd5d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/common.c
diff --cc arch/x86/kernel/cpu/common.c
index 966180cda17e,26ec15034f86..000000000000
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@@ -949,54 -948,66 +949,117 @@@ static void identify_cpu_without_cpuid(
  #endif
  }
  
++<<<<<<< HEAD
 +static const __initconst struct x86_cpu_id cpu_no_speculation[] = {
 +	{ X86_VENDOR_INTEL,	6, INTEL_FAM6_ATOM_CEDARVIEW,	X86_FEATURE_ANY },
 +	{ X86_VENDOR_INTEL,	6, INTEL_FAM6_ATOM_CLOVERVIEW,	X86_FEATURE_ANY },
 +	{ X86_VENDOR_INTEL,	6, INTEL_FAM6_ATOM_LINCROFT,	X86_FEATURE_ANY },
 +	{ X86_VENDOR_INTEL,	6, INTEL_FAM6_ATOM_PENWELL,	X86_FEATURE_ANY },
 +	{ X86_VENDOR_INTEL,	6, INTEL_FAM6_ATOM_PINEVIEW,	X86_FEATURE_ANY },
 +	{ X86_VENDOR_CENTAUR,	5 },
 +	{ X86_VENDOR_INTEL,	5 },
 +	{ X86_VENDOR_NSC,	5 },
 +	{ X86_VENDOR_ANY,	4 },
 +	{}
 +};
 +
 +static const __initconst struct x86_cpu_id cpu_no_meltdown[] = {
 +	{ X86_VENDOR_AMD },
 +	{}
 +};
 +
 +/* Only list CPUs which speculate but are non susceptible to SSB */
 +static const __initconst struct x86_cpu_id cpu_no_spec_store_bypass[] = {
 +	{ X86_VENDOR_INTEL,	6,	INTEL_FAM6_ATOM_SILVERMONT1	},
 +	{ X86_VENDOR_INTEL,	6,	INTEL_FAM6_ATOM_AIRMONT		},
 +	{ X86_VENDOR_INTEL,	6,	INTEL_FAM6_ATOM_SILVERMONT2	},
 +	{ X86_VENDOR_INTEL,	6,	INTEL_FAM6_ATOM_MERRIFIELD	},
 +	{ X86_VENDOR_INTEL,	6,	INTEL_FAM6_CORE_YONAH		},
 +	{ X86_VENDOR_INTEL,	6,	INTEL_FAM6_XEON_PHI_KNL		},
 +	{ X86_VENDOR_INTEL,	6,	INTEL_FAM6_XEON_PHI_KNM		},
 +	{ X86_VENDOR_AMD,	0x12,					},
 +	{ X86_VENDOR_AMD,	0x11,					},
 +	{ X86_VENDOR_AMD,	0x10,					},
 +	{ X86_VENDOR_AMD,	0xf,					},
 +	{}
 +};
 +
 +static const __initconst struct x86_cpu_id cpu_no_l1tf[] = {
 +	/* in addition to cpu_no_speculation */
 +	{ X86_VENDOR_INTEL,	6,	INTEL_FAM6_ATOM_SILVERMONT1	},
 +	{ X86_VENDOR_INTEL,	6,	INTEL_FAM6_ATOM_SILVERMONT2	},
 +	{ X86_VENDOR_INTEL,	6,	INTEL_FAM6_ATOM_AIRMONT		},
 +	{ X86_VENDOR_INTEL,	6,	INTEL_FAM6_ATOM_MERRIFIELD	},
 +	{ X86_VENDOR_INTEL,	6,	INTEL_FAM6_ATOM_MOOREFIELD	},
 +	{ X86_VENDOR_INTEL,	6,	INTEL_FAM6_ATOM_GOLDMONT	},
 +	{ X86_VENDOR_INTEL,	6,	INTEL_FAM6_ATOM_DENVERTON	},
 +	{ X86_VENDOR_INTEL,	6,	INTEL_FAM6_ATOM_GEMINI_LAKE	},
 +	{ X86_VENDOR_INTEL,	6,	INTEL_FAM6_XEON_PHI_KNL		},
 +	{ X86_VENDOR_INTEL,	6,	INTEL_FAM6_XEON_PHI_KNM		},
 +	{}
 +};
++=======
+ #define NO_SPECULATION	BIT(0)
+ #define NO_MELTDOWN	BIT(1)
+ #define NO_SSB		BIT(2)
+ #define NO_L1TF		BIT(3)
+ 
+ #define VULNWL(_vendor, _family, _model, _whitelist)	\
+ 	{ X86_VENDOR_##_vendor, _family, _model, X86_FEATURE_ANY, _whitelist }
+ 
+ #define VULNWL_INTEL(model, whitelist)		\
+ 	VULNWL(INTEL, 6, INTEL_FAM6_##model, whitelist)
+ 
+ #define VULNWL_AMD(family, whitelist)		\
+ 	VULNWL(AMD, family, X86_MODEL_ANY, whitelist)
+ 
+ #define VULNWL_HYGON(family, whitelist)		\
+ 	VULNWL(HYGON, family, X86_MODEL_ANY, whitelist)
+ 
+ static const __initconst struct x86_cpu_id cpu_vuln_whitelist[] = {
+ 	VULNWL(ANY,	4, X86_MODEL_ANY,	NO_SPECULATION),
+ 	VULNWL(CENTAUR,	5, X86_MODEL_ANY,	NO_SPECULATION),
+ 	VULNWL(INTEL,	5, X86_MODEL_ANY,	NO_SPECULATION),
+ 	VULNWL(NSC,	5, X86_MODEL_ANY,	NO_SPECULATION),
+ 
+ 	VULNWL_INTEL(ATOM_SALTWELL,		NO_SPECULATION),
+ 	VULNWL_INTEL(ATOM_SALTWELL_TABLET,	NO_SPECULATION),
+ 	VULNWL_INTEL(ATOM_SALTWELL_MID,		NO_SPECULATION),
+ 	VULNWL_INTEL(ATOM_BONNELL,		NO_SPECULATION),
+ 	VULNWL_INTEL(ATOM_BONNELL_MID,		NO_SPECULATION),
+ 
+ 	VULNWL_INTEL(ATOM_SILVERMONT,		NO_SSB | NO_L1TF),
+ 	VULNWL_INTEL(ATOM_SILVERMONT_X,		NO_SSB | NO_L1TF),
+ 	VULNWL_INTEL(ATOM_SILVERMONT_MID,	NO_SSB | NO_L1TF),
+ 	VULNWL_INTEL(ATOM_AIRMONT,		NO_SSB | NO_L1TF),
+ 	VULNWL_INTEL(XEON_PHI_KNL,		NO_SSB | NO_L1TF),
+ 	VULNWL_INTEL(XEON_PHI_KNM,		NO_SSB | NO_L1TF),
+ 
+ 	VULNWL_INTEL(CORE_YONAH,		NO_SSB),
+ 
+ 	VULNWL_INTEL(ATOM_AIRMONT_MID,		NO_L1TF),
+ 	VULNWL_INTEL(ATOM_GOLDMONT,		NO_L1TF),
+ 	VULNWL_INTEL(ATOM_GOLDMONT_X,		NO_L1TF),
+ 	VULNWL_INTEL(ATOM_GOLDMONT_PLUS,	NO_L1TF),
+ 
+ 	VULNWL_AMD(0x0f,		NO_MELTDOWN | NO_SSB | NO_L1TF),
+ 	VULNWL_AMD(0x10,		NO_MELTDOWN | NO_SSB | NO_L1TF),
+ 	VULNWL_AMD(0x11,		NO_MELTDOWN | NO_SSB | NO_L1TF),
+ 	VULNWL_AMD(0x12,		NO_MELTDOWN | NO_SSB | NO_L1TF),
+ 
+ 	/* FAMILY_ANY must be last, otherwise 0x0f - 0x12 matches won't work */
+ 	VULNWL_AMD(X86_FAMILY_ANY,	NO_MELTDOWN | NO_L1TF),
+ 	VULNWL_HYGON(X86_FAMILY_ANY,	NO_MELTDOWN | NO_L1TF),
+ 	{}
+ };
+ 
+ static bool __init cpu_matches(unsigned long which)
+ {
+ 	const struct x86_cpu_id *m = x86_match_cpu(cpu_vuln_whitelist);
+ 
+ 	return m && !!(m->driver_data & which);
+ }
++>>>>>>> 36ad35131ada (x86/speculation: Consolidate CPU whitelists)
  
  static void __init cpu_set_bug_bits(struct cpuinfo_x86 *c)
  {
* Unmerged path arch/x86/kernel/cpu/common.c
