dma-mapping: add a dma_alloc_need_uncached helper

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 4b85faed211ccfbcc7f3adf1cd62f0b00d1a172b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/4b85faed.failed

Check if we need to allocate uncached memory for a device given the
allocation flags.  Switch over the uncached segment check to this helper
to deal with architectures that do not support the dma_cache_sync
operation and thus should not returned cacheable memory for
DMA_ATTR_NON_CONSISTENT allocations.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 4b85faed211ccfbcc7f3adf1cd62f0b00d1a172b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/dma/direct.c
diff --cc kernel/dma/direct.c
index 26bb7b9a7670,c2893713bf80..000000000000
--- a/kernel/dma/direct.c
+++ b/kernel/dma/direct.c
@@@ -159,6 -158,13 +159,16 @@@ void *dma_direct_alloc_pages(struct dev
  		*dma_handle = phys_to_dma(dev, page_to_phys(page));
  	}
  	memset(ret, 0, size);
++<<<<<<< HEAD
++=======
+ 
+ 	if (IS_ENABLED(CONFIG_ARCH_HAS_UNCACHED_SEGMENT) &&
+ 	    dma_alloc_need_uncached(dev, attrs)) {
+ 		arch_dma_prep_coherent(page, size);
+ 		ret = uncached_kernel_address(ret);
+ 	}
+ 
++>>>>>>> 4b85faed211c (dma-mapping: add a dma_alloc_need_uncached helper)
  	return ret;
  }
  
@@@ -174,6 -180,10 +184,13 @@@ void dma_direct_free_pages(struct devic
  
  	if (force_dma_unencrypted())
  		set_memory_encrypted((unsigned long)cpu_addr, 1 << page_order);
++<<<<<<< HEAD
++=======
+ 
+ 	if (IS_ENABLED(CONFIG_ARCH_HAS_UNCACHED_SEGMENT) &&
+ 	    dma_alloc_need_uncached(dev, attrs))
+ 		cpu_addr = cached_kernel_address(cpu_addr);
++>>>>>>> 4b85faed211c (dma-mapping: add a dma_alloc_need_uncached helper)
  	__dma_direct_free_pages(dev, size, virt_to_page(cpu_addr));
  }
  
diff --git a/include/linux/dma-noncoherent.h b/include/linux/dma-noncoherent.h
index 69b36ed31a99..d35797fa4f9c 100644
--- a/include/linux/dma-noncoherent.h
+++ b/include/linux/dma-noncoherent.h
@@ -20,6 +20,20 @@ static inline bool dev_is_dma_coherent(struct device *dev)
 }
 #endif /* CONFIG_ARCH_HAS_DMA_COHERENCE_H */
 
+/*
+ * Check if an allocation needs to be marked uncached to be coherent.
+ */
+static inline bool dma_alloc_need_uncached(struct device *dev,
+		unsigned long attrs)
+{
+	if (dev_is_dma_coherent(dev))
+		return false;
+	if (IS_ENABLED(CONFIG_DMA_NONCOHERENT_CACHE_SYNC) &&
+	    (attrs & DMA_ATTR_NON_CONSISTENT))
+		return false;
+	return true;
+}
+
 void *arch_dma_alloc(struct device *dev, size_t size, dma_addr_t *dma_handle,
 		gfp_t gfp, unsigned long attrs);
 void arch_dma_free(struct device *dev, size_t size, void *cpu_addr,
* Unmerged path kernel/dma/direct.c
