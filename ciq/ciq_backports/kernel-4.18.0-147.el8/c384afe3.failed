drm/i915: Finalize Wa_1408961008:icl

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit c384afe35200f090b10ff5b4e8c7e6ea6a54eb19
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/c384afe3.failed

The icl wm1+ underrun w/a has been added to the spec. It changed
slightly from the previous incarnation by requiring that we mirror
the lines watermark and the ignore lines bit from WM0 into WM1.

	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190228173639.18422-1-ville.syrjala@linux.intel.com
	Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
	Tested-by: Clint Taylor <Clinton.A.Taylor@intel.com>
(cherry picked from commit c384afe35200f090b10ff5b4e8c7e6ea6a54eb19)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_pm.c
diff --cc drivers/gpu/drm/i915/intel_pm.c
index 53aaaa3e6886,9c97a95c1816..000000000000
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@@ -4353,39 -4436,58 +4353,74 @@@ skl_allocate_pipe_ddb(struct intel_crtc
  		if (plane_id == PLANE_CURSOR)
  			continue;
  
 -		plane_alloc = &cstate->wm.skl.plane_ddb_y[plane_id];
 -		uv_plane_alloc = &cstate->wm.skl.plane_ddb_uv[plane_id];
 +		data_rate = plane_data_rate[plane_id];
  
 -		/* Gen11+ uses a separate plane for UV watermarks */
 -		WARN_ON(INTEL_GEN(dev_priv) >= 11 && uv_total[plane_id]);
 +		/*
 +		 * allocation for (packed formats) or (uv-plane part of planar format):
 +		 * promote the expression to 64 bits to avoid overflowing, the
 +		 * result is < available as data_rate / total_data_rate < 1
 +		 */
 +		plane_blocks = minimum[plane_id];
 +		plane_blocks += div_u64((uint64_t)alloc_size * data_rate,
 +					total_data_rate);
  
  		/* Leave disabled planes at (0,0) */
 -		if (total[plane_id]) {
 -			plane_alloc->start = start;
 -			start += total[plane_id];
 -			plane_alloc->end = start;
 +		if (data_rate) {
 +			ddb->plane[pipe][plane_id].start = start;
 +			ddb->plane[pipe][plane_id].end = start + plane_blocks;
  		}
  
 -		if (uv_total[plane_id]) {
 -			uv_plane_alloc->start = start;
 -			start += uv_total[plane_id];
 -			uv_plane_alloc->end = start;
 +		start += plane_blocks;
 +
 +		/* Allocate DDB for UV plane for planar format/NV12 */
 +		uv_data_rate = uv_plane_data_rate[plane_id];
 +
 +		uv_plane_blocks = uv_minimum[plane_id];
 +		uv_plane_blocks += div_u64((uint64_t)alloc_size * uv_data_rate,
 +					   total_data_rate);
 +
 +		if (uv_data_rate) {
 +			ddb->uv_plane[pipe][plane_id].start = start;
 +			ddb->uv_plane[pipe][plane_id].end =
 +				start + uv_plane_blocks;
  		}
 -	}
  
++<<<<<<< HEAD
 +		start += uv_plane_blocks;
++=======
+ 	/*
+ 	 * When we calculated watermark values we didn't know how high
+ 	 * of a level we'd actually be able to hit, so we just marked
+ 	 * all levels as "enabled."  Go back now and disable the ones
+ 	 * that aren't actually possible.
+ 	 */
+ 	for (level++; level <= ilk_wm_max_level(dev_priv); level++) {
+ 		for_each_plane_id_on_crtc(intel_crtc, plane_id) {
+ 			wm = &cstate->wm.skl.optimal.planes[plane_id];
+ 			memset(&wm->wm[level], 0, sizeof(wm->wm[level]));
+ 
+ 			/*
+ 			 * Wa_1408961008:icl
+ 			 * Underruns with WM1+ disabled
+ 			 */
+ 			if (IS_ICELAKE(dev_priv) &&
+ 			    level == 1 && wm->wm[0].plane_en) {
+ 				wm->wm[level].plane_res_b = wm->wm[0].plane_res_b;
+ 				wm->wm[level].plane_res_l = wm->wm[0].plane_res_l;
+ 				wm->wm[level].ignore_lines = wm->wm[0].ignore_lines;
+ 			}
+ 		}
+ 	}
+ 
+ 	/*
+ 	 * Go back and disable the transition watermark if it turns out we
+ 	 * don't have enough DDB blocks for it.
+ 	 */
+ 	for_each_plane_id_on_crtc(intel_crtc, plane_id) {
+ 		wm = &cstate->wm.skl.optimal.planes[plane_id];
+ 		if (wm->trans_wm.plane_res_b >= total[plane_id])
+ 			memset(&wm->trans_wm, 0, sizeof(wm->trans_wm));
++>>>>>>> c384afe35200 (drm/i915: Finalize Wa_1408961008:icl)
  	}
  
  	return 0;
* Unmerged path drivers/gpu/drm/i915/intel_pm.c
