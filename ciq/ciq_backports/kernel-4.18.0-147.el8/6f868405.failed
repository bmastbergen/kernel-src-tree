KVM: PPC: Book3S HV: XIVE: Prevent races when releasing device

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Paul Mackerras <paulus@ozlabs.org>
commit 6f868405faf067e8cfb6a8349890e82f74616c75
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/6f868405.failed

Now that we have the possibility of a XIVE or XICS-on-XIVE device being
released while the VM is still running, we need to be careful about
races and potential use-after-free bugs.  Although the kvmppc_xive
struct is not freed, but kept around for re-use, the kvmppc_xive_vcpu
structs are freed, and they are used extensively in both the XIVE native
and XICS-on-XIVE code.

There are various ways in which XIVE code gets invoked:

- VCPU entry and exit, which do push and pull operations on the XIVE hardware
- one_reg get and set functions (vcpu->mutex is held)
- XICS hypercalls (but only inside guest execution, not from
  kvmppc_pseries_do_hcall)
- device creation calls (kvm->lock is held)
- device callbacks - get/set attribute, mmap, pagefault, release/destroy
- set_mapped/clr_mapped calls (kvm->lock is held)
- connect_vcpu calls
- debugfs file read callbacks

Inside a device release function, we know that userspace cannot have an
open file descriptor referring to the device, nor can it have any mmapped
regions from the device.  Therefore the device callbacks are excluded,
as are the connect_vcpu calls (since they need a fd for the device).
Further, since the caller holds the kvm->lock mutex, no other device
creation calls or set/clr_mapped calls can be executing concurrently.

To exclude VCPU execution and XICS hypercalls, we temporarily set
kvm->arch.mmu_ready to 0.  This forces any VCPU task that is trying to
enter the guest to take the kvm->lock mutex, which is held by the caller
of the release function.  Then, sending an IPI to all other CPUs forces
any VCPU currently executing in the guest to exit.

Finally, we take the vcpu->mutex for each VCPU around the process of
cleaning up and freeing its XIVE data structures, in order to exclude
any one_reg get/set calls.

To exclude the debugfs read callbacks, we just need to ensure that
debugfs_remove is called before freeing any data structures.  Once it
returns we know that no CPU can be executing the callbacks (for our
kvmppc_xive instance).

	Signed-off-by: Paul Mackerras <paulus@ozlabs.org>
(cherry picked from commit 6f868405faf067e8cfb6a8349890e82f74616c75)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kvm/book3s_xive.c
#	arch/powerpc/kvm/book3s_xive_native.c
diff --cc arch/powerpc/kvm/book3s_xive.c
index f78d002f0fe0,4280cd8bb70c..000000000000
--- a/arch/powerpc/kvm/book3s_xive.c
+++ b/arch/powerpc/kvm/book3s_xive.c
@@@ -1810,16 -1835,55 +1811,61 @@@ static void kvmppc_xive_free_sources(st
  	}
  }
  
++<<<<<<< HEAD
 +static void kvmppc_xive_free(struct kvm_device *dev)
++=======
+ /*
+  * Called when device fd is closed.  kvm->lock is held.
+  */
+ static void kvmppc_xive_release(struct kvm_device *dev)
++>>>>>>> 6f868405faf0 (KVM: PPC: Book3S HV: XIVE: Prevent races when releasing device)
  {
  	struct kvmppc_xive *xive = dev->private;
  	struct kvm *kvm = xive->kvm;
 -	struct kvm_vcpu *vcpu;
  	int i;
+ 	int was_ready;
  
++<<<<<<< HEAD
++=======
+ 	pr_devel("Releasing xive device\n");
+ 
++>>>>>>> 6f868405faf0 (KVM: PPC: Book3S HV: XIVE: Prevent races when releasing device)
  	debugfs_remove(xive->dentry);
  
- 	if (kvm)
- 		kvm->arch.xive = NULL;
+ 	/*
+ 	 * Clearing mmu_ready temporarily while holding kvm->lock
+ 	 * is a way of ensuring that no vcpus can enter the guest
+ 	 * until we drop kvm->lock.  Doing kick_all_cpus_sync()
+ 	 * ensures that any vcpu executing inside the guest has
+ 	 * exited the guest.  Once kick_all_cpus_sync() has finished,
+ 	 * we know that no vcpu can be executing the XIVE push or
+ 	 * pull code, or executing a XICS hcall.
+ 	 *
+ 	 * Since this is the device release function, we know that
+ 	 * userspace does not have any open fd referring to the
+ 	 * device.  Therefore there can not be any of the device
+ 	 * attribute set/get functions being executed concurrently,
+ 	 * and similarly, the connect_vcpu and set/clr_mapped
+ 	 * functions also cannot be being executed.
+ 	 */
+ 	was_ready = kvm->arch.mmu_ready;
+ 	kvm->arch.mmu_ready = 0;
+ 	kick_all_cpus_sync();
+ 
+ 	/*
+ 	 * We should clean up the vCPU interrupt presenters first.
+ 	 */
+ 	kvm_for_each_vcpu(i, vcpu, kvm) {
+ 		/*
+ 		 * Take vcpu->mutex to ensure that no one_reg get/set ioctl
+ 		 * (i.e. kvmppc_xive_[gs]et_icp) can be done concurrently.
+ 		 */
+ 		mutex_lock(&vcpu->mutex);
+ 		kvmppc_xive_cleanup_vcpu(vcpu);
+ 		mutex_unlock(&vcpu->mutex);
+ 	}
+ 
+ 	kvm->arch.xive = NULL;
  
  	/* Mask and free interrupts */
  	for (i = 0; i <= xive->max_sbid; i++) {
@@@ -1832,11 -1896,47 +1878,54 @@@
  	if (xive->vp_base != XIVE_INVALID_VP)
  		xive_native_free_vp_block(xive->vp_base);
  
++<<<<<<< HEAD
++=======
+ 	kvm->arch.mmu_ready = was_ready;
+ 
+ 	/*
+ 	 * A reference of the kvmppc_xive pointer is now kept under
+ 	 * the xive_devices struct of the machine for reuse. It is
+ 	 * freed when the VM is destroyed for now until we fix all the
+ 	 * execution paths.
+ 	 */
++>>>>>>> 6f868405faf0 (KVM: PPC: Book3S HV: XIVE: Prevent races when releasing device)
  
 +	kfree(xive);
  	kfree(dev);
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * When the guest chooses the interrupt mode (XICS legacy or XIVE
+  * native), the VM will switch of KVM device. The previous device will
+  * be "released" before the new one is created.
+  *
+  * Until we are sure all execution paths are well protected, provide a
+  * fail safe (transitional) method for device destruction, in which
+  * the XIVE device pointer is recycled and not directly freed.
+  */
+ struct kvmppc_xive *kvmppc_xive_get_device(struct kvm *kvm, u32 type)
+ {
+ 	struct kvmppc_xive **kvm_xive_device = type == KVM_DEV_TYPE_XIVE ?
+ 		&kvm->arch.xive_devices.native :
+ 		&kvm->arch.xive_devices.xics_on_xive;
+ 	struct kvmppc_xive *xive = *kvm_xive_device;
+ 
+ 	if (!xive) {
+ 		xive = kzalloc(sizeof(*xive), GFP_KERNEL);
+ 		*kvm_xive_device = xive;
+ 	} else {
+ 		memset(xive, 0, sizeof(*xive));
+ 	}
+ 
+ 	return xive;
+ }
+ 
+ /*
+  * Create a XICS device with XIVE backend.  kvm->lock is held.
+  */
++>>>>>>> 6f868405faf0 (KVM: PPC: Book3S HV: XIVE: Prevent races when releasing device)
  static int kvmppc_xive_create(struct kvm_device *dev, u32 type)
  {
  	struct kvmppc_xive *xive;
diff --cc arch/powerpc/kvm/book3s_xive_native.c
index 751259394150,5e14df1a4403..000000000000
--- a/arch/powerpc/kvm/book3s_xive_native.c
+++ b/arch/powerpc/kvm/book3s_xive_native.c
@@@ -56,18 -971,69 +56,73 @@@ static void kvmppc_xive_native_free(str
  {
  	struct kvmppc_xive *xive = dev->private;
  	struct kvm *kvm = xive->kvm;
++<<<<<<< HEAD
 +
 +	debugfs_remove(xive->dentry);
 +
 +	pr_devel("Destroying xive native device\n");
++=======
+ 	struct kvm_vcpu *vcpu;
+ 	int i;
+ 	int was_ready;
  
- 	if (kvm)
- 		kvm->arch.xive = NULL;
+ 	debugfs_remove(xive->dentry);
+ 
+ 	pr_devel("Releasing xive native device\n");
+ 
+ 	/*
+ 	 * Clearing mmu_ready temporarily while holding kvm->lock
+ 	 * is a way of ensuring that no vcpus can enter the guest
+ 	 * until we drop kvm->lock.  Doing kick_all_cpus_sync()
+ 	 * ensures that any vcpu executing inside the guest has
+ 	 * exited the guest.  Once kick_all_cpus_sync() has finished,
+ 	 * we know that no vcpu can be executing the XIVE push or
+ 	 * pull code or accessing the XIVE MMIO regions.
+ 	 *
+ 	 * Since this is the device release function, we know that
+ 	 * userspace does not have any open fd or mmap referring to
+ 	 * the device.  Therefore there can not be any of the
+ 	 * device attribute set/get, mmap, or page fault functions
+ 	 * being executed concurrently, and similarly, the
+ 	 * connect_vcpu and set/clr_mapped functions also cannot
+ 	 * be being executed.
+ 	 */
+ 	was_ready = kvm->arch.mmu_ready;
+ 	kvm->arch.mmu_ready = 0;
+ 	kick_all_cpus_sync();
++>>>>>>> 6f868405faf0 (KVM: PPC: Book3S HV: XIVE: Prevent races when releasing device)
+ 
+ 	/*
+ 	 * We should clean up the vCPU interrupt presenters first.
+ 	 */
+ 	kvm_for_each_vcpu(i, vcpu, kvm) {
+ 		/*
+ 		 * Take vcpu->mutex to ensure that no one_reg get/set ioctl
+ 		 * (i.e. kvmppc_xive_native_[gs]et_vp) can be being done.
+ 		 */
+ 		mutex_lock(&vcpu->mutex);
+ 		kvmppc_xive_native_cleanup_vcpu(vcpu);
+ 		mutex_unlock(&vcpu->mutex);
+ 	}
+ 
+ 	kvm->arch.xive = NULL;
  
 -	for (i = 0; i <= xive->max_sbid; i++) {
 -		if (xive->src_blocks[i])
 -			kvmppc_xive_free_sources(xive->src_blocks[i]);
 -		kfree(xive->src_blocks[i]);
 -		xive->src_blocks[i] = NULL;
 -	}
 -
  	if (xive->vp_base != XIVE_INVALID_VP)
  		xive_native_free_vp_block(xive->vp_base);
  
++<<<<<<< HEAD
 +	kfree(xive);
++=======
+ 	kvm->arch.mmu_ready = was_ready;
+ 
+ 	/*
+ 	 * A reference of the kvmppc_xive pointer is now kept under
+ 	 * the xive_devices struct of the machine for reuse. It is
+ 	 * freed when the VM is destroyed for now until we fix all the
+ 	 * execution paths.
+ 	 */
+ 
++>>>>>>> 6f868405faf0 (KVM: PPC: Book3S HV: XIVE: Prevent races when releasing device)
  	kfree(dev);
  }
  
* Unmerged path arch/powerpc/kvm/book3s_xive.c
* Unmerged path arch/powerpc/kvm/book3s_xive_native.c
