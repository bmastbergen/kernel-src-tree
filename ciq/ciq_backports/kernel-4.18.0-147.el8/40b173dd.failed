qedr: Add user space support for SRQ

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Yuval Bason <yuval.bason@cavium.com>
commit 40b173ddce0fc6653a859889d1a90b5f5817061b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/40b173dd.failed

This patch adds support for SRQ's created in user space and update
qedr_affiliated_event to deal with general SRQ events.

	Signed-off-by: Michal Kalderon <michal.kalderon@cavium.com>
	Signed-off-by: Yuval Bason <yuval.bason@cavium.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 40b173ddce0fc6653a859889d1a90b5f5817061b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/qedr/verbs.c
diff --cc drivers/infiniband/hw/qedr/verbs.c
index 54c9d61675a0,3f46fc14ee38..000000000000
--- a/drivers/infiniband/hw/qedr/verbs.c
+++ b/drivers/infiniband/hw/qedr/verbs.c
@@@ -1257,9 -1306,303 +1272,309 @@@ static void qedr_set_roce_db_info(struc
  	qp->sq.db = dev->db_addr +
  		    DB_ADDR_SHIFT(DQ_PWM_OFFSET_XCM_RDMA_SQ_PROD);
  	qp->sq.db_data.data.icid = qp->icid + 1;
++<<<<<<< HEAD
 +	qp->rq.db = dev->db_addr +
 +		    DB_ADDR_SHIFT(DQ_PWM_OFFSET_TCM_ROCE_RQ_PROD);
 +	qp->rq.db_data.data.icid = qp->icid;
++=======
+ 	if (!qp->srq) {
+ 		qp->rq.db = dev->db_addr +
+ 			    DB_ADDR_SHIFT(DQ_PWM_OFFSET_TCM_ROCE_RQ_PROD);
+ 		qp->rq.db_data.data.icid = qp->icid;
+ 	}
+ }
+ 
+ static int qedr_check_srq_params(struct ib_pd *ibpd, struct qedr_dev *dev,
+ 				 struct ib_srq_init_attr *attrs,
+ 				 struct ib_udata *udata)
+ {
+ 	struct qedr_device_attr *qattr = &dev->attr;
+ 
+ 	if (attrs->attr.max_wr > qattr->max_srq_wr) {
+ 		DP_ERR(dev,
+ 		       "create srq: unsupported srq_wr=0x%x requested (max_srq_wr=0x%x)\n",
+ 		       attrs->attr.max_wr, qattr->max_srq_wr);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (attrs->attr.max_sge > qattr->max_sge) {
+ 		DP_ERR(dev,
+ 		       "create srq: unsupported sge=0x%x requested (max_srq_sge=0x%x)\n",
+ 		       attrs->attr.max_sge, qattr->max_sge);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void qedr_free_srq_user_params(struct qedr_srq *srq)
+ {
+ 	qedr_free_pbl(srq->dev, &srq->usrq.pbl_info, srq->usrq.pbl_tbl);
+ 	ib_umem_release(srq->usrq.umem);
+ 	ib_umem_release(srq->prod_umem);
+ }
+ 
+ static void qedr_free_srq_kernel_params(struct qedr_srq *srq)
+ {
+ 	struct qedr_srq_hwq_info *hw_srq = &srq->hw_srq;
+ 	struct qedr_dev *dev = srq->dev;
+ 
+ 	dev->ops->common->chain_free(dev->cdev, &hw_srq->pbl);
+ 
+ 	dma_free_coherent(&dev->pdev->dev, sizeof(struct rdma_srq_producers),
+ 			  hw_srq->virt_prod_pair_addr,
+ 			  hw_srq->phy_prod_pair_addr);
+ }
+ 
+ static int qedr_init_srq_user_params(struct ib_ucontext *ib_ctx,
+ 				     struct qedr_srq *srq,
+ 				     struct qedr_create_srq_ureq *ureq,
+ 				     int access, int dmasync)
+ {
+ 	struct scatterlist *sg;
+ 	int rc;
+ 
+ 	rc = qedr_init_user_queue(ib_ctx, srq->dev, &srq->usrq, ureq->srq_addr,
+ 				  ureq->srq_len, access, dmasync, 1);
+ 	if (rc)
+ 		return rc;
+ 
+ 	srq->prod_umem = ib_umem_get(ib_ctx, ureq->prod_pair_addr,
+ 				     sizeof(struct rdma_srq_producers),
+ 				     access, dmasync);
+ 	if (IS_ERR(srq->prod_umem)) {
+ 		qedr_free_pbl(srq->dev, &srq->usrq.pbl_info, srq->usrq.pbl_tbl);
+ 		ib_umem_release(srq->usrq.umem);
+ 		DP_ERR(srq->dev,
+ 		       "create srq: failed ib_umem_get for producer, got %ld\n",
+ 		       PTR_ERR(srq->prod_umem));
+ 		return PTR_ERR(srq->prod_umem);
+ 	}
+ 
+ 	sg = srq->prod_umem->sg_head.sgl;
+ 	srq->hw_srq.phy_prod_pair_addr = sg_dma_address(sg);
+ 
+ 	return 0;
+ }
+ 
+ static int qedr_alloc_srq_kernel_params(struct qedr_srq *srq,
+ 					struct qedr_dev *dev,
+ 					struct ib_srq_init_attr *init_attr)
+ {
+ 	struct qedr_srq_hwq_info *hw_srq = &srq->hw_srq;
+ 	dma_addr_t phy_prod_pair_addr;
+ 	u32 num_elems;
+ 	void *va;
+ 	int rc;
+ 
+ 	va = dma_alloc_coherent(&dev->pdev->dev,
+ 				sizeof(struct rdma_srq_producers),
+ 				&phy_prod_pair_addr, GFP_KERNEL);
+ 	if (!va) {
+ 		DP_ERR(dev,
+ 		       "create srq: failed to allocate dma memory for producer\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	hw_srq->phy_prod_pair_addr = phy_prod_pair_addr;
+ 	hw_srq->virt_prod_pair_addr = va;
+ 
+ 	num_elems = init_attr->attr.max_wr * RDMA_MAX_SRQ_WQE_SIZE;
+ 	rc = dev->ops->common->chain_alloc(dev->cdev,
+ 					   QED_CHAIN_USE_TO_CONSUME_PRODUCE,
+ 					   QED_CHAIN_MODE_PBL,
+ 					   QED_CHAIN_CNT_TYPE_U32,
+ 					   num_elems,
+ 					   QEDR_SRQ_WQE_ELEM_SIZE,
+ 					   &hw_srq->pbl, NULL);
+ 	if (rc)
+ 		goto err0;
+ 
+ 	hw_srq->num_elems = num_elems;
+ 
+ 	return 0;
+ 
+ err0:
+ 	dma_free_coherent(&dev->pdev->dev, sizeof(struct rdma_srq_producers),
+ 			  va, phy_prod_pair_addr);
+ 	return rc;
+ }
+ 
+ static int qedr_idr_add(struct qedr_dev *dev, struct qedr_idr *qidr,
+ 			void *ptr, u32 id);
+ static void qedr_idr_remove(struct qedr_dev *dev,
+ 			    struct qedr_idr *qidr, u32 id);
+ 
+ struct ib_srq *qedr_create_srq(struct ib_pd *ibpd,
+ 			       struct ib_srq_init_attr *init_attr,
+ 			       struct ib_udata *udata)
+ {
+ 	struct qed_rdma_destroy_srq_in_params destroy_in_params;
+ 	struct qed_rdma_create_srq_in_params in_params = {};
+ 	struct qedr_dev *dev = get_qedr_dev(ibpd->device);
+ 	struct qed_rdma_create_srq_out_params out_params;
+ 	struct qedr_pd *pd = get_qedr_pd(ibpd);
+ 	struct qedr_create_srq_ureq ureq = {};
+ 	u64 pbl_base_addr, phy_prod_pair_addr;
+ 	struct ib_ucontext *ib_ctx = NULL;
+ 	struct qedr_srq_hwq_info *hw_srq;
+ 	struct qedr_ucontext *ctx = NULL;
+ 	u32 page_cnt, page_size;
+ 	struct qedr_srq *srq;
+ 	int rc = 0;
+ 
+ 	DP_DEBUG(dev, QEDR_MSG_QP,
+ 		 "create SRQ called from %s (pd %p)\n",
+ 		 (udata) ? "User lib" : "kernel", pd);
+ 
+ 	rc = qedr_check_srq_params(ibpd, dev, init_attr, udata);
+ 	if (rc)
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	srq = kzalloc(sizeof(*srq), GFP_KERNEL);
+ 	if (!srq)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	srq->dev = dev;
+ 	hw_srq = &srq->hw_srq;
+ 	spin_lock_init(&srq->lock);
+ 
+ 	hw_srq->max_wr = init_attr->attr.max_wr;
+ 	hw_srq->max_sges = init_attr->attr.max_sge;
+ 
+ 	if (udata && ibpd->uobject && ibpd->uobject->context) {
+ 		ib_ctx = ibpd->uobject->context;
+ 		ctx = get_qedr_ucontext(ib_ctx);
+ 
+ 		if (ib_copy_from_udata(&ureq, udata, sizeof(ureq))) {
+ 			DP_ERR(dev,
+ 			       "create srq: problem copying data from user space\n");
+ 			goto err0;
+ 		}
+ 
+ 		rc = qedr_init_srq_user_params(ib_ctx, srq, &ureq, 0, 0);
+ 		if (rc)
+ 			goto err0;
+ 
+ 		page_cnt = srq->usrq.pbl_info.num_pbes;
+ 		pbl_base_addr = srq->usrq.pbl_tbl->pa;
+ 		phy_prod_pair_addr = hw_srq->phy_prod_pair_addr;
+ 		page_size = BIT(srq->usrq.umem->page_shift);
+ 	} else {
+ 		struct qed_chain *pbl;
+ 
+ 		rc = qedr_alloc_srq_kernel_params(srq, dev, init_attr);
+ 		if (rc)
+ 			goto err0;
+ 
+ 		pbl = &hw_srq->pbl;
+ 		page_cnt = qed_chain_get_page_cnt(pbl);
+ 		pbl_base_addr = qed_chain_get_pbl_phys(pbl);
+ 		phy_prod_pair_addr = hw_srq->phy_prod_pair_addr;
+ 		page_size = QED_CHAIN_PAGE_SIZE;
+ 	}
+ 
+ 	in_params.pd_id = pd->pd_id;
+ 	in_params.pbl_base_addr = pbl_base_addr;
+ 	in_params.prod_pair_addr = phy_prod_pair_addr;
+ 	in_params.num_pages = page_cnt;
+ 	in_params.page_size = page_size;
+ 
+ 	rc = dev->ops->rdma_create_srq(dev->rdma_ctx, &in_params, &out_params);
+ 	if (rc)
+ 		goto err1;
+ 
+ 	srq->srq_id = out_params.srq_id;
+ 
+ 	if (udata) {
+ 		rc = qedr_copy_srq_uresp(dev, srq, udata);
+ 		if (rc)
+ 			goto err2;
+ 	}
+ 
+ 	rc = qedr_idr_add(dev, &dev->srqidr, srq, srq->srq_id);
+ 	if (rc)
+ 		goto err2;
+ 
+ 	DP_DEBUG(dev, QEDR_MSG_SRQ,
+ 		 "create srq: created srq with srq_id=0x%0x\n", srq->srq_id);
+ 	return &srq->ibsrq;
+ 
+ err2:
+ 	destroy_in_params.srq_id = srq->srq_id;
+ 
+ 	dev->ops->rdma_destroy_srq(dev->rdma_ctx, &destroy_in_params);
+ err1:
+ 	if (udata)
+ 		qedr_free_srq_user_params(srq);
+ 	else
+ 		qedr_free_srq_kernel_params(srq);
+ err0:
+ 	kfree(srq);
+ 
+ 	return ERR_PTR(-EFAULT);
+ }
+ 
+ int qedr_destroy_srq(struct ib_srq *ibsrq)
+ {
+ 	struct qed_rdma_destroy_srq_in_params in_params = {};
+ 	struct qedr_dev *dev = get_qedr_dev(ibsrq->device);
+ 	struct qedr_srq *srq = get_qedr_srq(ibsrq);
+ 
+ 	qedr_idr_remove(dev, &dev->srqidr, srq->srq_id);
+ 	in_params.srq_id = srq->srq_id;
+ 	dev->ops->rdma_destroy_srq(dev->rdma_ctx, &in_params);
+ 
+ 	if (ibsrq->pd->uobject)
+ 		qedr_free_srq_user_params(srq);
+ 	else
+ 		qedr_free_srq_kernel_params(srq);
+ 
+ 	DP_DEBUG(dev, QEDR_MSG_SRQ,
+ 		 "destroy srq: destroyed srq with srq_id=0x%0x\n",
+ 		 srq->srq_id);
+ 	kfree(srq);
+ 
+ 	return 0;
+ }
+ 
+ int qedr_modify_srq(struct ib_srq *ibsrq, struct ib_srq_attr *attr,
+ 		    enum ib_srq_attr_mask attr_mask, struct ib_udata *udata)
+ {
+ 	struct qed_rdma_modify_srq_in_params in_params = {};
+ 	struct qedr_dev *dev = get_qedr_dev(ibsrq->device);
+ 	struct qedr_srq *srq = get_qedr_srq(ibsrq);
+ 	int rc;
+ 
+ 	if (attr_mask & IB_SRQ_MAX_WR) {
+ 		DP_ERR(dev,
+ 		       "modify srq: invalid attribute mask=0x%x specified for %p\n",
+ 		       attr_mask, srq);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (attr_mask & IB_SRQ_LIMIT) {
+ 		if (attr->srq_limit >= srq->hw_srq.max_wr) {
+ 			DP_ERR(dev,
+ 			       "modify srq: invalid srq_limit=0x%x (max_srq_limit=0x%x)\n",
+ 			       attr->srq_limit, srq->hw_srq.max_wr);
+ 			return -EINVAL;
+ 		}
+ 
+ 		in_params.srq_id = srq->srq_id;
+ 		in_params.wqe_limit = attr->srq_limit;
+ 		rc = dev->ops->rdma_modify_srq(dev->rdma_ctx, &in_params);
+ 		if (rc)
+ 			return rc;
+ 	}
+ 
+ 	srq->srq_limit = attr->srq_limit;
+ 
+ 	DP_DEBUG(dev, QEDR_MSG_SRQ,
+ 		 "modify srq: modified srq with srq_id=0x%0x\n", srq->srq_id);
+ 
+ 	return 0;
++>>>>>>> 40b173ddce0f (qedr: Add user space support for SRQ)
  }
  
  static inline void
diff --git a/drivers/infiniband/hw/qedr/main.c b/drivers/infiniband/hw/qedr/main.c
index d1fc9ba8e85c..6d8b86944f60 100644
--- a/drivers/infiniband/hw/qedr/main.c
+++ b/drivers/infiniband/hw/qedr/main.c
@@ -191,6 +191,11 @@ static int qedr_register_device(struct qedr_dev *dev)
 				     QEDR_UVERBS(MODIFY_QP) |
 				     QEDR_UVERBS(QUERY_QP) |
 				     QEDR_UVERBS(DESTROY_QP) |
+				     QEDR_UVERBS(CREATE_SRQ) |
+				     QEDR_UVERBS(DESTROY_SRQ) |
+				     QEDR_UVERBS(QUERY_SRQ) |
+				     QEDR_UVERBS(MODIFY_SRQ) |
+				     QEDR_UVERBS(POST_SRQ_RECV) |
 				     QEDR_UVERBS(REG_MR) |
 				     QEDR_UVERBS(DEREG_MR) |
 				     QEDR_UVERBS(POLL_CQ) |
@@ -653,42 +658,70 @@ static void qedr_affiliated_event(void *context, u8 e_code, void *fw_handle)
 #define EVENT_TYPE_NOT_DEFINED	0
 #define EVENT_TYPE_CQ		1
 #define EVENT_TYPE_QP		2
+#define EVENT_TYPE_SRQ		3
 	struct qedr_dev *dev = (struct qedr_dev *)context;
 	struct regpair *async_handle = (struct regpair *)fw_handle;
 	u64 roce_handle64 = ((u64) async_handle->hi << 32) + async_handle->lo;
 	u8 event_type = EVENT_TYPE_NOT_DEFINED;
 	struct ib_event event;
+	struct ib_srq *ibsrq;
+	struct qedr_srq *srq;
+	unsigned long flags;
 	struct ib_cq *ibcq;
 	struct ib_qp *ibqp;
 	struct qedr_cq *cq;
 	struct qedr_qp *qp;
+	u16 srq_id;
 
-	switch (e_code) {
-	case ROCE_ASYNC_EVENT_CQ_OVERFLOW_ERR:
-		event.event = IB_EVENT_CQ_ERR;
-		event_type = EVENT_TYPE_CQ;
-		break;
-	case ROCE_ASYNC_EVENT_SQ_DRAINED:
-		event.event = IB_EVENT_SQ_DRAINED;
-		event_type = EVENT_TYPE_QP;
-		break;
-	case ROCE_ASYNC_EVENT_QP_CATASTROPHIC_ERR:
-		event.event = IB_EVENT_QP_FATAL;
-		event_type = EVENT_TYPE_QP;
-		break;
-	case ROCE_ASYNC_EVENT_LOCAL_INVALID_REQUEST_ERR:
-		event.event = IB_EVENT_QP_REQ_ERR;
-		event_type = EVENT_TYPE_QP;
-		break;
-	case ROCE_ASYNC_EVENT_LOCAL_ACCESS_ERR:
-		event.event = IB_EVENT_QP_ACCESS_ERR;
-		event_type = EVENT_TYPE_QP;
-		break;
-	default:
+	if (IS_ROCE(dev)) {
+		switch (e_code) {
+		case ROCE_ASYNC_EVENT_CQ_OVERFLOW_ERR:
+			event.event = IB_EVENT_CQ_ERR;
+			event_type = EVENT_TYPE_CQ;
+			break;
+		case ROCE_ASYNC_EVENT_SQ_DRAINED:
+			event.event = IB_EVENT_SQ_DRAINED;
+			event_type = EVENT_TYPE_QP;
+			break;
+		case ROCE_ASYNC_EVENT_QP_CATASTROPHIC_ERR:
+			event.event = IB_EVENT_QP_FATAL;
+			event_type = EVENT_TYPE_QP;
+			break;
+		case ROCE_ASYNC_EVENT_LOCAL_INVALID_REQUEST_ERR:
+			event.event = IB_EVENT_QP_REQ_ERR;
+			event_type = EVENT_TYPE_QP;
+			break;
+		case ROCE_ASYNC_EVENT_LOCAL_ACCESS_ERR:
+			event.event = IB_EVENT_QP_ACCESS_ERR;
+			event_type = EVENT_TYPE_QP;
+			break;
+		case ROCE_ASYNC_EVENT_SRQ_LIMIT:
+			event.event = IB_EVENT_SRQ_LIMIT_REACHED;
+			event_type = EVENT_TYPE_SRQ;
+			break;
+		case ROCE_ASYNC_EVENT_SRQ_EMPTY:
+			event.event = IB_EVENT_SRQ_ERR;
+			event_type = EVENT_TYPE_SRQ;
+			break;
+		default:
+			DP_ERR(dev, "unsupported event %d on handle=%llx\n",
+			       e_code, roce_handle64);
+		}
+	} else {
+		switch (e_code) {
+		case QED_IWARP_EVENT_SRQ_LIMIT:
+			event.event = IB_EVENT_SRQ_LIMIT_REACHED;
+			event_type = EVENT_TYPE_SRQ;
+			break;
+		case QED_IWARP_EVENT_SRQ_EMPTY:
+			event.event = IB_EVENT_SRQ_ERR;
+			event_type = EVENT_TYPE_SRQ;
+			break;
+		default:
 		DP_ERR(dev, "unsupported event %d on handle=%llx\n", e_code,
 		       roce_handle64);
+		}
 	}
-
 	switch (event_type) {
 	case EVENT_TYPE_CQ:
 		cq = (struct qedr_cq *)(uintptr_t)roce_handle64;
@@ -722,6 +755,25 @@ static void qedr_affiliated_event(void *context, u8 e_code, void *fw_handle)
 		}
 		DP_ERR(dev, "QP event %d on handle %p\n", e_code, qp);
 		break;
+	case EVENT_TYPE_SRQ:
+		srq_id = (u16)roce_handle64;
+		spin_lock_irqsave(&dev->srqidr.idr_lock, flags);
+		srq = idr_find(&dev->srqidr.idr, srq_id);
+		if (srq) {
+			ibsrq = &srq->ibsrq;
+			if (ibsrq->event_handler) {
+				event.device = ibsrq->device;
+				event.element.srq = ibsrq;
+				ibsrq->event_handler(&event,
+						     ibsrq->srq_context);
+			}
+		} else {
+			DP_NOTICE(dev,
+				  "SRQ event with NULL pointer ibsrq. Handle=%llx\n",
+				  roce_handle64);
+		}
+		spin_unlock_irqrestore(&dev->srqidr.idr_lock, flags);
+		DP_NOTICE(dev, "SRQ event %d on handle %p\n", e_code, srq);
 	default:
 		break;
 	}
* Unmerged path drivers/infiniband/hw/qedr/verbs.c
diff --git a/include/uapi/rdma/qedr-abi.h b/include/uapi/rdma/qedr-abi.h
index 24c658b3c790..7a10b3a325fa 100644
--- a/include/uapi/rdma/qedr-abi.h
+++ b/include/uapi/rdma/qedr-abi.h
@@ -111,4 +111,21 @@ struct qedr_create_qp_uresp {
 	__u32 reserved;
 };
 
+struct qedr_create_srq_ureq {
+	/* user space virtual address of producer pair */
+	__aligned_u64 prod_pair_addr;
+
+	/* user space virtual address of SRQ buffer */
+	__aligned_u64 srq_addr;
+
+	/* length of SRQ buffer */
+	__aligned_u64 srq_len;
+};
+
+struct qedr_create_srq_uresp {
+	__u16 srq_id;
+	__u16 reserved0;
+	__u32 reserved1;
+};
+
 #endif /* __QEDR_USER_H__ */
