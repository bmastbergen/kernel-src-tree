drm/i915: Track pipe gamma enable/disable in crtc state

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit 5f29ab23046a4bb08a850e41bdb579b2cb59421d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/5f29ab23.failed

Track whether pipe gamma is enabled or disabled. For now we
stick to the current behaviour of always enabling gamma. But
we do get working state readout for this now. On SKL+ we use
the pipe bottom color as our hardware state. On pre-SKL we
read the state back from the primary plane control register.
That only really correct for g4x+, as older platforms never
gamma correct pipe bottom color. But doing the readout the
same way on all platforms is fine, and there is no other way
to do it really.

v2: Initialize val at declaration (Uma)
    Drop the bogus skl scaler comment change (Uma)
    Rebase
v3: Allow fastboot with gamma_enable changes (Maarten)
v4: Drop the PIPE_BOTTOM_COLOR write from
    intel_update_pipe_config() again. It snuck back in
    during the rebase

	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
	Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
	Reviewed-by: Uma Shankar <uma.shankar@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190207203913.5529-1-ville.syrjala@linux.intel.com
(cherry picked from commit 5f29ab23046a4bb08a850e41bdb579b2cb59421d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_color.c
#	drivers/gpu/drm/i915/intel_display.c
#	drivers/gpu/drm/i915/intel_drv.h
#	drivers/gpu/drm/i915/intel_sprite.c
diff --cc drivers/gpu/drm/i915/intel_color.c
index c6a7beabd58d,746138d7bcbc..000000000000
--- a/drivers/gpu/drm/i915/intel_color.c
+++ b/drivers/gpu/drm/i915/intel_color.c
@@@ -352,47 -346,76 +352,100 @@@ static void i9xx_load_luts_internal(str
  	}
  }
  
 -static void i9xx_load_luts(const struct intel_crtc_state *crtc_state)
 +static void i9xx_load_luts(struct drm_crtc_state *crtc_state)
  {
 -	i9xx_load_luts_internal(crtc_state, crtc_state->base.gamma_lut);
 +	i9xx_load_luts_internal(crtc_state->crtc, crtc_state->gamma_lut,
 +				to_intel_crtc_state(crtc_state));
  }
  
 -static void i9xx_color_commit(const struct intel_crtc_state *crtc_state)
 +/* Loads the legacy palette/gamma unit for the CRTC on Haswell. */
 +static void haswell_load_luts(struct drm_crtc_state *crtc_state)
  {
 -	struct intel_crtc *crtc = to_intel_crtc(crtc_state->base.crtc);
 -	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
 -	enum pipe pipe = crtc->pipe;
 -	u32 val;
 +	struct drm_crtc *crtc = crtc_state->crtc;
 +	struct drm_device *dev = crtc->dev;
 +	struct drm_i915_private *dev_priv = to_i915(dev);
 +	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
 +	struct intel_crtc_state *intel_crtc_state =
 +		to_intel_crtc_state(crtc_state);
 +	bool reenable_ips = false;
  
 -	val = I915_READ(PIPECONF(pipe));
 -	val &= ~PIPECONF_GAMMA_MODE_MASK_I9XX;
 -	val |= PIPECONF_GAMMA_MODE(crtc_state->gamma_mode);
 -	I915_WRITE(PIPECONF(pipe), val);
 +	/*
 +	 * Workaround : Do not read or write the pipe palette/gamma data while
 +	 * GAMMA_MODE is configured for split gamma and IPS_CTL has IPS enabled.
 +	 */
 +	if (IS_HASWELL(dev_priv) && intel_crtc_state->ips_enabled &&
 +	    (intel_crtc_state->gamma_mode == GAMMA_MODE_MODE_SPLIT)) {
 +		hsw_disable_ips(intel_crtc_state);
 +		reenable_ips = true;
 +	}
 +
 +	intel_crtc_state->gamma_mode = GAMMA_MODE_MODE_8BIT;
 +	I915_WRITE(GAMMA_MODE(intel_crtc->pipe), GAMMA_MODE_MODE_8BIT);
 +
 +	i9xx_load_luts(crtc_state);
 +
 +	if (reenable_ips)
 +		hsw_enable_ips(intel_crtc_state);
  }
  
 -static void ilk_color_commit(const struct intel_crtc_state *crtc_state)
 +static void bdw_load_degamma_lut(struct drm_crtc_state *state)
  {
++<<<<<<< HEAD
 +	struct drm_i915_private *dev_priv = to_i915(state->crtc->dev);
 +	enum pipe pipe = to_intel_crtc(state->crtc)->pipe;
 +	uint32_t i, lut_size = INTEL_INFO(dev_priv)->color.degamma_lut_size;
++=======
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->base.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	enum pipe pipe = crtc->pipe;
+ 	u32 val;
+ 
+ 	val = I915_READ(PIPECONF(pipe));
+ 	val &= ~PIPECONF_GAMMA_MODE_MASK_ILK;
+ 	val |= PIPECONF_GAMMA_MODE(crtc_state->gamma_mode);
+ 	I915_WRITE(PIPECONF(pipe), val);
+ }
+ 
+ static void hsw_color_commit(const struct intel_crtc_state *crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->base.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 
+ 	I915_WRITE(GAMMA_MODE(crtc->pipe), crtc_state->gamma_mode);
+ 
+ 	ilk_load_csc_matrix(crtc_state);
+ }
+ 
+ static void skl_color_commit(const struct intel_crtc_state *crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->base.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	enum pipe pipe = crtc->pipe;
+ 	u32 val = 0;
+ 
+ 	/*
+ 	 * We don't (yet) allow userspace to control the pipe background color,
+ 	 * so force it to black, but apply pipe gamma and CSC appropriately
+ 	 * so that its handling will match how we program our planes.
+ 	 */
+ 	if (crtc_state->gamma_enable)
+ 		val |= SKL_BOTTOM_COLOR_GAMMA_ENABLE;
+ 	val |= SKL_BOTTOM_COLOR_CSC_ENABLE;
+ 	I915_WRITE(SKL_BOTTOM_COLOR(pipe), val);
+ 
+ 	I915_WRITE(GAMMA_MODE(crtc->pipe), crtc_state->gamma_mode);
+ 
+ 	ilk_load_csc_matrix(crtc_state);
+ }
+ 
+ static void bdw_load_degamma_lut(const struct intel_crtc_state *crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->base.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	const struct drm_property_blob *degamma_lut = crtc_state->base.degamma_lut;
+ 	u32 i, lut_size = INTEL_INFO(dev_priv)->color.degamma_lut_size;
+ 	enum pipe pipe = crtc->pipe;
++>>>>>>> 5f29ab23046a (drm/i915: Track pipe gamma enable/disable in crtc state)
  
  	I915_WRITE(PREC_PAL_INDEX(pipe),
  		   PAL_PREC_SPLIT_MODE | PAL_PREC_AUTO_INCREMENT);
@@@ -621,48 -663,62 +674,72 @@@ int intel_color_check(struct drm_crtc *
  
  	degamma_length = INTEL_INFO(dev_priv)->color.degamma_lut_size;
  	gamma_length = INTEL_INFO(dev_priv)->color.gamma_lut_size;
 -	degamma_tests = INTEL_INFO(dev_priv)->color.degamma_lut_tests;
 -	gamma_tests = INTEL_INFO(dev_priv)->color.gamma_lut_tests;
  
++<<<<<<< HEAD
 +	/*
 +	 * We allow both degamma & gamma luts at the right size or
 +	 * NULL.
 +	 */
 +	if ((!crtc_state->degamma_lut ||
 +	     drm_color_lut_size(crtc_state->degamma_lut) == degamma_length) &&
 +	    (!crtc_state->gamma_lut ||
 +	     drm_color_lut_size(crtc_state->gamma_lut) == gamma_length))
++=======
+ 	crtc_state->gamma_enable = true;
+ 
+ 	/* Always allow legacy gamma LUT with no further checking. */
+ 	if (crtc_state_is_legacy_gamma(crtc_state)) {
+ 		crtc_state->gamma_mode = GAMMA_MODE_MODE_8BIT;
++>>>>>>> 5f29ab23046a (drm/i915: Track pipe gamma enable/disable in crtc state)
  		return 0;
 -	}
 -
 -	if (check_lut_size(degamma_lut, degamma_length) ||
 -	    check_lut_size(gamma_lut, gamma_length))
 -		return -EINVAL;
  
 -	if (drm_color_lut_check(degamma_lut, degamma_tests) ||
 -	    drm_color_lut_check(gamma_lut, gamma_tests))
 -		return -EINVAL;
 -
 -	if (INTEL_GEN(dev_priv) >= 10 || IS_GEMINILAKE(dev_priv))
 -		crtc_state->gamma_mode = GAMMA_MODE_MODE_10BIT;
 -	else if (INTEL_GEN(dev_priv) >= 9 || IS_BROADWELL(dev_priv))
 -		crtc_state->gamma_mode = GAMMA_MODE_MODE_SPLIT;
 -	else
 -		crtc_state->gamma_mode = GAMMA_MODE_MODE_8BIT;
 +	/*
 +	 * We also allow no degamma lut/ctm and a gamma lut at the legacy
 +	 * size (256 entries).
 +	 */
 +	if (crtc_state_is_legacy_gamma(crtc_state))
 +		return 0;
  
 -	return 0;
 +	return -EINVAL;
  }
  
 -void intel_color_init(struct intel_crtc *crtc)
 +void intel_color_init(struct drm_crtc *crtc)
  {
 -	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
 -
 -	drm_mode_crtc_set_gamma_size(&crtc->base, 256);
 -
 -	if (HAS_GMCH(dev_priv)) {
 -		if (IS_CHERRYVIEW(dev_priv))
 -			dev_priv->display.load_luts = cherryview_load_luts;
 -		else
 -			dev_priv->display.load_luts = i9xx_load_luts;
 -
 -		dev_priv->display.color_commit = i9xx_color_commit;
 +	struct drm_i915_private *dev_priv = to_i915(crtc->dev);
 +
 +	drm_mode_crtc_set_gamma_size(crtc, 256);
 +
 +	if (IS_CHERRYVIEW(dev_priv)) {
 +		dev_priv->display.load_csc_matrix = cherryview_load_csc_matrix;
 +		dev_priv->display.load_luts = cherryview_load_luts;
 +	} else if (IS_HASWELL(dev_priv)) {
 +		dev_priv->display.load_csc_matrix = ilk_load_csc_matrix;
 +		dev_priv->display.load_luts = haswell_load_luts;
 +	} else if (IS_BROADWELL(dev_priv) || IS_GEN9_BC(dev_priv) ||
 +		   IS_BROXTON(dev_priv)) {
 +		dev_priv->display.load_csc_matrix = ilk_load_csc_matrix;
 +		dev_priv->display.load_luts = broadwell_load_luts;
 +	} else if (IS_GEMINILAKE(dev_priv) || IS_CANNONLAKE(dev_priv)) {
 +		dev_priv->display.load_csc_matrix = ilk_load_csc_matrix;
 +		dev_priv->display.load_luts = glk_load_luts;
  	} else {
++<<<<<<< HEAD
 +		dev_priv->display.load_luts = i9xx_load_luts;
++=======
+ 		if (IS_CANNONLAKE(dev_priv) || IS_GEMINILAKE(dev_priv))
+ 			dev_priv->display.load_luts = glk_load_luts;
+ 		else if (INTEL_GEN(dev_priv) >= 9 || IS_BROADWELL(dev_priv))
+ 			dev_priv->display.load_luts = broadwell_load_luts;
+ 		else
+ 			dev_priv->display.load_luts = i9xx_load_luts;
+ 
+ 		if (INTEL_GEN(dev_priv) >= 9)
+ 			dev_priv->display.color_commit = skl_color_commit;
+ 		else if (IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv))
+ 			dev_priv->display.color_commit = hsw_color_commit;
+ 		else
+ 			dev_priv->display.color_commit = ilk_color_commit;
++>>>>>>> 5f29ab23046a (drm/i915: Track pipe gamma enable/disable in crtc state)
  	}
  
  	/* Enable color management support when we have degamma & gamma LUTs. */
diff --cc drivers/gpu/drm/i915/intel_display.c
index dec0d60921bf,6f5f7525a2cb..000000000000
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@@ -3248,6 -3188,51 +3248,54 @@@ int skl_check_plane_surface(const struc
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ unsigned int
+ i9xx_plane_max_stride(struct intel_plane *plane,
+ 		      u32 pixel_format, u64 modifier,
+ 		      unsigned int rotation)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(plane->base.dev);
+ 
+ 	if (!HAS_GMCH(dev_priv)) {
+ 		return 32*1024;
+ 	} else if (INTEL_GEN(dev_priv) >= 4) {
+ 		if (modifier == I915_FORMAT_MOD_X_TILED)
+ 			return 16*1024;
+ 		else
+ 			return 32*1024;
+ 	} else if (INTEL_GEN(dev_priv) >= 3) {
+ 		if (modifier == I915_FORMAT_MOD_X_TILED)
+ 			return 8*1024;
+ 		else
+ 			return 16*1024;
+ 	} else {
+ 		if (plane->i9xx_plane == PLANE_C)
+ 			return 4*1024;
+ 		else
+ 			return 8*1024;
+ 	}
+ }
+ 
+ static u32 i9xx_plane_ctl_crtc(const struct intel_crtc_state *crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->base.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	u32 dspcntr = 0;
+ 
+ 	if (crtc_state->gamma_enable)
+ 		dspcntr |= DISPPLANE_GAMMA_ENABLE;
+ 
+ 	if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
+ 		dspcntr |= DISPPLANE_PIPE_CSC_ENABLE;
+ 
+ 	if (INTEL_GEN(dev_priv) < 5)
+ 		dspcntr |= DISPPLANE_SEL_PIPE(crtc->pipe);
+ 
+ 	return dspcntr;
+ }
+ 
++>>>>>>> 5f29ab23046a (drm/i915: Track pipe gamma enable/disable in crtc state)
  static u32 i9xx_plane_ctl(const struct intel_crtc_state *crtc_state,
  			  const struct intel_plane_state *plane_state)
  {
@@@ -3632,6 -3694,22 +3680,25 @@@ static u32 cnl_plane_ctl_flip(unsigned 
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ u32 skl_plane_ctl_crtc(const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(crtc_state->base.crtc->dev);
+ 	u32 plane_ctl = 0;
+ 
+ 	if (INTEL_GEN(dev_priv) >= 10 || IS_GEMINILAKE(dev_priv))
+ 		return plane_ctl;
+ 
+ 	if (crtc_state->gamma_enable)
+ 		plane_ctl |= PLANE_CTL_PIPE_GAMMA_ENABLE;
+ 
+ 	plane_ctl |= PLANE_CTL_PIPE_CSC_ENABLE;
+ 
+ 	return plane_ctl;
+ }
+ 
++>>>>>>> 5f29ab23046a (drm/i915: Track pipe gamma enable/disable in crtc state)
  u32 skl_plane_ctl(const struct intel_crtc_state *crtc_state,
  		  const struct intel_plane_state *plane_state)
  {
@@@ -3674,6 -3749,22 +3741,25 @@@
  	return plane_ctl;
  }
  
++<<<<<<< HEAD
++=======
+ u32 glk_plane_color_ctl_crtc(const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(crtc_state->base.crtc->dev);
+ 	u32 plane_color_ctl = 0;
+ 
+ 	if (INTEL_GEN(dev_priv) >= 11)
+ 		return plane_color_ctl;
+ 
+ 	if (crtc_state->gamma_enable)
+ 		plane_color_ctl |= PLANE_COLOR_PIPE_GAMMA_ENABLE;
+ 
+ 	plane_color_ctl |= PLANE_COLOR_PIPE_CSC_ENABLE;
+ 
+ 	return plane_color_ctl;
+ }
+ 
++>>>>>>> 5f29ab23046a (drm/i915: Track pipe gamma enable/disable in crtc state)
  u32 glk_plane_color_ctl(const struct intel_crtc_state *crtc_state,
  			const struct intel_plane_state *plane_state)
  {
@@@ -3881,16 -3993,19 +3967,22 @@@ static void intel_update_pipe_config(co
  
  	/* on skylake this is done by detaching scalers */
  	if (INTEL_GEN(dev_priv) >= 9) {
 -		skl_detach_scalers(new_crtc_state);
 +		skl_detach_scalers(crtc);
  
  		if (new_crtc_state->pch_pfit.enabled)
 -			skylake_pfit_enable(new_crtc_state);
 +			skylake_pfit_enable(crtc);
  	} else if (HAS_PCH_SPLIT(dev_priv)) {
  		if (new_crtc_state->pch_pfit.enabled)
 -			ironlake_pfit_enable(new_crtc_state);
 +			ironlake_pfit_enable(crtc);
  		else if (old_crtc_state->pch_pfit.enabled)
 -			ironlake_pfit_disable(old_crtc_state);
 +			ironlake_pfit_disable(crtc, true);
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (INTEL_GEN(dev_priv) >= 11)
+ 		icl_set_pipe_chicken(crtc);
++>>>>>>> 5f29ab23046a (drm/i915: Track pipe gamma enable/disable in crtc state)
  }
  
  static void intel_fdi_normal_train(struct intel_crtc *crtc)
@@@ -7775,6 -8053,63 +7867,66 @@@ static void chv_crtc_clock_get(struct i
  	pipe_config->port_clock = chv_calc_dpll_params(refclk, &clock);
  }
  
++<<<<<<< HEAD
++=======
+ static void intel_get_crtc_ycbcr_config(struct intel_crtc *crtc,
+ 					struct intel_crtc_state *pipe_config)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	enum intel_output_format output = INTEL_OUTPUT_FORMAT_RGB;
+ 
+ 	pipe_config->lspcon_downsampling = false;
+ 
+ 	if (IS_BROADWELL(dev_priv) || INTEL_GEN(dev_priv) >= 9) {
+ 		u32 tmp = I915_READ(PIPEMISC(crtc->pipe));
+ 
+ 		if (tmp & PIPEMISC_OUTPUT_COLORSPACE_YUV) {
+ 			bool ycbcr420_enabled = tmp & PIPEMISC_YUV420_ENABLE;
+ 			bool blend = tmp & PIPEMISC_YUV420_MODE_FULL_BLEND;
+ 
+ 			if (ycbcr420_enabled) {
+ 				/* We support 4:2:0 in full blend mode only */
+ 				if (!blend)
+ 					output = INTEL_OUTPUT_FORMAT_INVALID;
+ 				else if (!(IS_GEMINILAKE(dev_priv) ||
+ 					   INTEL_GEN(dev_priv) >= 10))
+ 					output = INTEL_OUTPUT_FORMAT_INVALID;
+ 				else
+ 					output = INTEL_OUTPUT_FORMAT_YCBCR420;
+ 			} else {
+ 				/*
+ 				 * Currently there is no interface defined to
+ 				 * check user preference between RGB/YCBCR444
+ 				 * or YCBCR420. So the only possible case for
+ 				 * YCBCR444 usage is driving YCBCR420 output
+ 				 * with LSPCON, when pipe is configured for
+ 				 * YCBCR444 output and LSPCON takes care of
+ 				 * downsampling it.
+ 				 */
+ 				pipe_config->lspcon_downsampling = true;
+ 				output = INTEL_OUTPUT_FORMAT_YCBCR444;
+ 			}
+ 		}
+ 	}
+ 
+ 	pipe_config->output_format = output;
+ }
+ 
+ static void i9xx_get_pipe_color_config(struct intel_crtc_state *crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->base.crtc);
+ 	struct intel_plane *plane = to_intel_plane(crtc->base.primary);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	enum i9xx_plane_id i9xx_plane = plane->i9xx_plane;
+ 	u32 tmp;
+ 
+ 	tmp = I915_READ(DSPCNTR(i9xx_plane));
+ 
+ 	if (tmp & DISPPLANE_GAMMA_ENABLE)
+ 		crtc_state->gamma_enable = true;
+ }
+ 
++>>>>>>> 5f29ab23046a (drm/i915: Track pipe gamma enable/disable in crtc state)
  static bool i9xx_get_pipe_config(struct intel_crtc *crtc,
  				 struct intel_crtc_state *pipe_config)
  {
@@@ -7817,6 -8155,11 +7969,14 @@@
  	    (tmp & PIPECONF_COLOR_RANGE_SELECT))
  		pipe_config->limited_color_range = true;
  
++<<<<<<< HEAD
++=======
+ 	pipe_config->gamma_mode = (tmp & PIPECONF_GAMMA_MODE_MASK_I9XX) >>
+ 		PIPECONF_GAMMA_MODE_SHIFT;
+ 
+ 	i9xx_get_pipe_color_config(pipe_config);
+ 
++>>>>>>> 5f29ab23046a (drm/i915: Track pipe gamma enable/disable in crtc state)
  	if (INTEL_GEN(dev_priv) < 4)
  		pipe_config->double_wide = tmp & PIPECONF_DOUBLE_WIDE;
  
@@@ -8863,6 -9235,11 +9023,14 @@@ static bool ironlake_get_pipe_config(st
  	if (tmp & PIPECONF_COLOR_RANGE_SELECT)
  		pipe_config->limited_color_range = true;
  
++<<<<<<< HEAD
++=======
+ 	pipe_config->gamma_mode = (tmp & PIPECONF_GAMMA_MODE_MASK_ILK) >>
+ 		PIPECONF_GAMMA_MODE_SHIFT;
+ 
+ 	i9xx_get_pipe_color_config(pipe_config);
+ 
++>>>>>>> 5f29ab23046a (drm/i915: Track pipe gamma enable/disable in crtc state)
  	if (I915_READ(PCH_TRANSCONF(crtc->pipe)) & TRANS_ENABLE) {
  		struct intel_shared_dpll *pll;
  		enum intel_dpll_id pll_id;
@@@ -9429,21 -9874,13 +9597,31 @@@ static bool haswell_get_pipe_config(str
  	pipe_config->gamma_mode =
  		I915_READ(GAMMA_MODE(crtc->pipe)) & GAMMA_MODE_MODE_MASK;
  
++<<<<<<< HEAD
 +	if (IS_BROADWELL(dev_priv) || INTEL_GEN(dev_priv) >= 9) {
 +		u32 tmp = I915_READ(PIPEMISC(crtc->pipe));
 +		bool clrspace_yuv = tmp & PIPEMISC_OUTPUT_COLORSPACE_YUV;
 +
 +		if (IS_GEMINILAKE(dev_priv) || INTEL_GEN(dev_priv) >= 10) {
 +			bool blend_mode_420 = tmp &
 +					      PIPEMISC_YUV420_MODE_FULL_BLEND;
 +
 +			pipe_config->ycbcr420 = tmp & PIPEMISC_YUV420_ENABLE;
 +			if (pipe_config->ycbcr420 != clrspace_yuv ||
 +			    pipe_config->ycbcr420 != blend_mode_420)
 +				DRM_DEBUG_KMS("Bad 4:2:0 mode (%08x)\n", tmp);
 +		} else if (clrspace_yuv) {
 +			DRM_DEBUG_KMS("YCbCr 4:2:0 Unsupported\n");
 +		}
++=======
+ 	if (INTEL_GEN(dev_priv) >= 9) {
+ 		u32 tmp = I915_READ(SKL_BOTTOM_COLOR(crtc->pipe));
+ 
+ 		if (tmp & SKL_BOTTOM_COLOR_GAMMA_ENABLE)
+ 			pipe_config->gamma_enable = true;
+ 	} else {
+ 		i9xx_get_pipe_color_config(pipe_config);
++>>>>>>> 5f29ab23046a (drm/i915: Track pipe gamma enable/disable in crtc state)
  	}
  
  	power_domain = POWER_DOMAIN_PIPE_PANEL_FITTER(crtc->pipe);
@@@ -9579,6 -10010,57 +9757,27 @@@ static int intel_check_cursor(struct in
  	return 0;
  }
  
 -static int intel_check_cursor(struct intel_crtc_state *crtc_state,
 -			      struct intel_plane_state *plane_state)
++<<<<<<< HEAD
++=======
++static unsigned int
++i845_cursor_max_stride(struct intel_plane *plane,
++		       u32 pixel_format, u64 modifier,
++		       unsigned int rotation)
+ {
 -	const struct drm_framebuffer *fb = plane_state->base.fb;
 -	int ret;
++	return 2048;
++}
+ 
 -	if (fb && fb->modifier != DRM_FORMAT_MOD_LINEAR) {
 -		DRM_DEBUG_KMS("cursor cannot be tiled\n");
 -		return -EINVAL;
 -	}
++static u32 i845_cursor_ctl_crtc(const struct intel_crtc_state *crtc_state)
++{
++	u32 cntl = 0;
+ 
 -	ret = drm_atomic_helper_check_plane_state(&plane_state->base,
 -						  &crtc_state->base,
 -						  DRM_PLANE_HELPER_NO_SCALING,
 -						  DRM_PLANE_HELPER_NO_SCALING,
 -						  true, true);
 -	if (ret)
 -		return ret;
 -
 -	if (!plane_state->base.visible)
 -		return 0;
 -
 -	ret = intel_plane_check_src_coordinates(plane_state);
 -	if (ret)
 -		return ret;
 -
 -	ret = intel_cursor_check_surface(plane_state);
 -	if (ret)
 -		return ret;
 -
 -	return 0;
 -}
 -
 -static unsigned int
 -i845_cursor_max_stride(struct intel_plane *plane,
 -		       u32 pixel_format, u64 modifier,
 -		       unsigned int rotation)
 -{
 -	return 2048;
 -}
 -
 -static u32 i845_cursor_ctl_crtc(const struct intel_crtc_state *crtc_state)
 -{
 -	u32 cntl = 0;
 -
 -	if (crtc_state->gamma_enable)
 -		cntl |= CURSOR_GAMMA_ENABLE;
++	if (crtc_state->gamma_enable)
++		cntl |= CURSOR_GAMMA_ENABLE;
+ 
+ 	return cntl;
+ }
+ 
++>>>>>>> 5f29ab23046a (drm/i915: Track pipe gamma enable/disable in crtc state)
  static u32 i845_cursor_ctl(const struct intel_crtc_state *crtc_state,
  			   const struct intel_plane_state *plane_state)
  {
@@@ -9709,6 -10195,35 +9908,38 @@@ static bool i845_cursor_get_hw_state(st
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static unsigned int
+ i9xx_cursor_max_stride(struct intel_plane *plane,
+ 		       u32 pixel_format, u64 modifier,
+ 		       unsigned int rotation)
+ {
+ 	return plane->base.dev->mode_config.cursor_width * 4;
+ }
+ 
+ static u32 i9xx_cursor_ctl_crtc(const struct intel_crtc_state *crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->base.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	u32 cntl = 0;
+ 
+ 	if (INTEL_GEN(dev_priv) >= 11)
+ 		return cntl;
+ 
+ 	if (crtc_state->gamma_enable)
+ 		cntl = MCURSOR_GAMMA_ENABLE;
+ 
+ 	if (HAS_DDI(dev_priv))
+ 		cntl |= MCURSOR_PIPE_CSC_ENABLE;
+ 
+ 	if (INTEL_GEN(dev_priv) < 5 && !IS_G4X(dev_priv))
+ 		cntl |= MCURSOR_PIPE_SELECT(crtc->pipe);
+ 
+ 	return cntl;
+ }
+ 
++>>>>>>> 5f29ab23046a (drm/i915: Track pipe gamma enable/disable in crtc state)
  static u32 i9xx_cursor_ctl(const struct intel_crtc_state *crtc_state,
  			   const struct intel_plane_state *plane_state)
  {
@@@ -10556,16 -11204,10 +10787,10 @@@ static int intel_crtc_atomic_check(stru
  			return ret;
  	}
  
 -	if (mode_changed || crtc_state->color_mgmt_changed) {
 -		ret = intel_color_check(pipe_config);
 +	if (crtc_state->color_mgmt_changed) {
 +		ret = intel_color_check(crtc, crtc_state);
  		if (ret)
  			return ret;
- 
- 		/*
- 		 * Changing color management on Intel hardware is
- 		 * handled as part of planes update.
- 		 */
- 		crtc_state->planes_changed = true;
  	}
  
  	ret = 0;
@@@ -11427,6 -12112,9 +11652,12 @@@ intel_pipe_config_compare(struct drm_i9
  
  		PIPE_CONF_CHECK_I(scaler_state.scaler_id);
  		PIPE_CONF_CHECK_CLOCK_FUZZY(pixel_rate);
++<<<<<<< HEAD
++=======
+ 
+ 		PIPE_CONF_CHECK_X(gamma_mode);
+ 		PIPE_CONF_CHECK_BOOL(gamma_enable);
++>>>>>>> 5f29ab23046a (drm/i915: Track pipe gamma enable/disable in crtc state)
  	}
  
  	PIPE_CONF_CHECK_BOOL(double_wide);
diff --cc drivers/gpu/drm/i915/intel_drv.h
index b8eefbffc77d,52584d9516d4..000000000000
--- a/drivers/gpu/drm/i915/intel_drv.h
+++ b/drivers/gpu/drm/i915/intel_drv.h
@@@ -897,8 -954,26 +897,31 @@@ struct intel_crtc_state 
  	/* HDMI High TMDS char rate ratio */
  	bool hdmi_high_tmds_clock_ratio;
  
++<<<<<<< HEAD
 +	/* output format is YCBCR 4:2:0 */
 +	bool ycbcr420;
++=======
+ 	/* Output format RGB/YCBCR etc */
+ 	enum intel_output_format output_format;
+ 
+ 	/* Output down scaling is done in LSPCON device */
+ 	bool lspcon_downsampling;
+ 
+ 	/* enable pipe gamma? */
+ 	bool gamma_enable;
+ 
+ 	/* Display Stream compression state */
+ 	struct {
+ 		bool compression_enable;
+ 		bool dsc_split;
+ 		u16 compressed_bpp;
+ 		u8 slice_count;
+ 	} dsc_params;
+ 	struct drm_dsc_config dp_dsc_cfg;
+ 
+ 	/* Forward Error correction State */
+ 	bool fec_enable;
++>>>>>>> 5f29ab23046a (drm/i915: Track pipe gamma enable/disable in crtc state)
  };
  
  struct intel_crtc {
diff --cc drivers/gpu/drm/i915/intel_sprite.c
index ee23613f9fd4,db373e3ac601..000000000000
--- a/drivers/gpu/drm/i915/intel_sprite.c
+++ b/drivers/gpu/drm/i915/intel_sprite.c
@@@ -444,6 -739,16 +444,19 @@@ vlv_update_clrc(const struct intel_plan
  		      SP_SH_SIN(sh_sin) | SP_SH_COS(sh_cos));
  }
  
++<<<<<<< HEAD
++=======
+ static u32 vlv_sprite_ctl_crtc(const struct intel_crtc_state *crtc_state)
+ {
+ 	u32 sprctl = 0;
+ 
+ 	if (crtc_state->gamma_enable)
+ 		sprctl |= SP_GAMMA_ENABLE;
+ 
+ 	return sprctl;
+ }
+ 
++>>>>>>> 5f29ab23046a (drm/i915: Track pipe gamma enable/disable in crtc state)
  static u32 vlv_sprite_ctl(const struct intel_crtc_state *crtc_state,
  			  const struct intel_plane_state *plane_state)
  {
@@@ -607,6 -919,20 +620,23 @@@ vlv_plane_get_hw_state(struct intel_pla
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static u32 ivb_sprite_ctl_crtc(const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(crtc_state->base.crtc->dev);
+ 	u32 sprctl = 0;
+ 
+ 	if (crtc_state->gamma_enable)
+ 		sprctl |= SPRITE_GAMMA_ENABLE;
+ 
+ 	if (IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
+ 		sprctl |= SPRITE_PIPE_CSC_ENABLE;
+ 
+ 	return sprctl;
+ }
+ 
++>>>>>>> 5f29ab23046a (drm/i915: Track pipe gamma enable/disable in crtc state)
  static u32 ivb_sprite_ctl(const struct intel_crtc_state *crtc_state,
  			  const struct intel_plane_state *plane_state)
  {
@@@ -772,6 -1103,24 +802,27 @@@ ivb_plane_get_hw_state(struct intel_pla
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static unsigned int
+ g4x_sprite_max_stride(struct intel_plane *plane,
+ 		      u32 pixel_format, u64 modifier,
+ 		      unsigned int rotation)
+ {
+ 	return 16384;
+ }
+ 
+ static u32 g4x_sprite_ctl_crtc(const struct intel_crtc_state *crtc_state)
+ {
+ 	u32 dvscntr = 0;
+ 
+ 	if (crtc_state->gamma_enable)
+ 		dvscntr |= DVS_GAMMA_ENABLE;
+ 
+ 	return dvscntr;
+ }
+ 
++>>>>>>> 5f29ab23046a (drm/i915: Track pipe gamma enable/disable in crtc state)
  static u32 g4x_sprite_ctl(const struct intel_crtc_state *crtc_state,
  			  const struct intel_plane_state *plane_state)
  {
* Unmerged path drivers/gpu/drm/i915/intel_color.c
* Unmerged path drivers/gpu/drm/i915/intel_display.c
* Unmerged path drivers/gpu/drm/i915/intel_drv.h
* Unmerged path drivers/gpu/drm/i915/intel_sprite.c
