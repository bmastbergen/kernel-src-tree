IB/uverbs: Fix locking around struct ib_uverbs_file ucontext

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jason Gunthorpe <jgg@ziepe.ca>
commit 22fa27fbc64d01cbbe1e4da751e64cc22d24a6e4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/22fa27fb.failed

We have a parallel unlocked reader and writer with ib_uverbs_get_context()
vs everything else, and nothing guarantees this works properly.

Audit and fix all of the places that access ucontext to use one of the
following locking schemes:
- Call ib_uverbs_get_ucontext() under SRCU and check for failure
- Access the ucontext through an struct ib_uobject context member
  while holding a READ or WRITE lock on the uobject.
  This value cannot be NULL and has no race.
- Hold the ucontext_lock and check for ufile->ucontext !NULL

This also re-implements ib_uverbs_get_ucontext() in a way that is safe
against concurrent ib_uverbs_get_context() and disassociation.

As a side effect, every access to ucontext in the commands is via
ib_uverbs_get_context() with an error check, or via the uobject, so there
is no longer any need for the core code to check ucontext on every command
call. These checks are also removed.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 22fa27fbc64d01cbbe1e4da751e64cc22d24a6e4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/rdma_core.c
#	drivers/infiniband/core/uverbs.h
#	drivers/infiniband/core/uverbs_cmd.c
#	drivers/infiniband/core/uverbs_ioctl.c
#	drivers/infiniband/core/uverbs_main.c
#	drivers/infiniband/hw/mlx5/devx.c
diff --cc drivers/infiniband/core/rdma_core.c
index 7abca5514e4d,a63844ba8414..000000000000
--- a/drivers/infiniband/core/rdma_core.c
+++ b/drivers/infiniband/core/rdma_core.c
@@@ -150,18 -151,26 +150,30 @@@ int __uobj_perform_destroy(const struc
  	return success_res;
  }
  
 -static struct ib_uobject *alloc_uobj(struct ib_uverbs_file *ufile,
 +static struct ib_uobject *alloc_uobj(struct ib_ucontext *context,
  				     const struct uverbs_obj_type *type)
  {
- 	struct ib_uobject *uobj = kzalloc(type->obj_size, GFP_KERNEL);
+ 	struct ib_uobject *uobj;
+ 	struct ib_ucontext *ucontext;
+ 
+ 	ucontext = ib_uverbs_get_ucontext(ufile);
+ 	if (IS_ERR(ucontext))
+ 		return ERR_CAST(ucontext);
  
+ 	uobj = kzalloc(type->obj_size, GFP_KERNEL);
  	if (!uobj)
  		return ERR_PTR(-ENOMEM);
  	/*
  	 * user_handle should be filled by the handler,
  	 * The object is added to the list in the commit stage.
  	 */
++<<<<<<< HEAD
 +	uobj->context = context;
++=======
+ 	uobj->ufile = ufile;
+ 	uobj->context = ucontext;
+ 	INIT_LIST_HEAD(&uobj->list);
++>>>>>>> 22fa27fbc64d (IB/uverbs: Fix locking around struct ib_uverbs_file ucontext)
  	uobj->type = type;
  	/*
  	 * Allocated objects start out as write locked to deny any other
@@@ -312,7 -315,7 +324,11 @@@ static struct ib_uobject *alloc_begin_i
  	if (ret)
  		goto uobj_put;
  
++<<<<<<< HEAD
 +	ret = ib_rdmacg_try_charge(&uobj->cg_obj, ucontext->device,
++=======
+ 	ret = ib_rdmacg_try_charge(&uobj->cg_obj, uobj->context->device,
++>>>>>>> 22fa27fbc64d (IB/uverbs: Fix locking around struct ib_uverbs_file ucontext)
  				   RDMACG_RESOURCE_HCA_OBJECT);
  	if (ret)
  		goto idr_remove;
@@@ -658,78 -692,186 +674,200 @@@ unlock
  
  void uverbs_close_fd(struct file *f)
  {
 -	struct ib_uobject *uobj = f->private_data;
 -	struct ib_uverbs_file *ufile = uobj->ufile;
 +	struct ib_uobject_file *uobj_file = f->private_data;
 +	struct kref *uverbs_file_ref = &uobj_file->ufile->ref;
  
 -	if (down_read_trylock(&ufile->hw_destroy_rwsem)) {
 -		_uverbs_close_fd(uobj);
 -		up_read(&ufile->hw_destroy_rwsem);
 -	}
 +	_uverbs_close_fd(uobj_file);
 +	uverbs_uobject_put(&uobj_file->uobj);
 +	kref_put(uverbs_file_ref, ib_uverbs_release_file);
 +}
  
 -	uobj->object = NULL;
 -	/* Matches the get in alloc_begin_fd_uobject */
 -	kref_put(&ufile->ref, ib_uverbs_release_file);
 +void uverbs_cleanup_ucontext(struct ib_ucontext *ucontext, bool device_removed)
 +{
 +	enum rdma_remove_reason reason = device_removed ?
 +		RDMA_REMOVE_DRIVER_REMOVE : RDMA_REMOVE_CLOSE;
 +	unsigned int cur_order = 0;
  
 -	/* Pairs with filp->private_data in alloc_begin_fd_uobject */
 -	uverbs_uobject_put(uobj);
 -}
 +	ucontext->cleanup_reason = reason;
 +	/*
 +	 * Waits for all remove_commit and alloc_commit to finish. Logically, We
 +	 * want to hold this forever as the context is going to be destroyed,
 +	 * but we'll release it since it causes a "held lock freed" BUG message.
 +	 */
 +	down_write(&ucontext->cleanup_rwsem);
 +
 +	while (!list_empty(&ucontext->uobjects)) {
 +		struct ib_uobject *obj, *next_obj;
 +		unsigned int next_order = UINT_MAX;
  
 -static void ufile_disassociate_ucontext(struct ib_ucontext *ibcontext)
 -{
 -	struct ib_device *ib_dev = ibcontext->device;
 -	struct task_struct *owning_process  = NULL;
 -	struct mm_struct   *owning_mm       = NULL;
 -
 -	owning_process = get_pid_task(ibcontext->tgid, PIDTYPE_PID);
 -	if (!owning_process)
 -		return;
 -
 -	owning_mm = get_task_mm(owning_process);
 -	if (!owning_mm) {
 -		pr_info("no mm, disassociate ucontext is pending task termination\n");
 -		while (1) {
 -			put_task_struct(owning_process);
 -			usleep_range(1000, 2000);
 -			owning_process = get_pid_task(ibcontext->tgid,
 -						      PIDTYPE_PID);
 -			if (!owning_process ||
 -			    owning_process->state == TASK_DEAD) {
 -				pr_info("disassociate ucontext done, task was terminated\n");
 -				/* in case task was dead need to release the
 -				 * task struct.
 +		/*
 +		 * This shouldn't run while executing other commands on this
 +		 * context. Thus, the only thing we should take care of is
 +		 * releasing a FD while traversing this list. The FD could be
 +		 * closed and released from the _release fop of this FD.
 +		 * In order to mitigate this, we add a lock.
 +		 * We take and release the lock per order traversal in order
 +		 * to let other threads (which might still use the FDs) chance
 +		 * to run.
 +		 */
 +		mutex_lock(&ucontext->uobjects_lock);
 +		list_for_each_entry_safe(obj, next_obj, &ucontext->uobjects,
 +					 list) {
 +			if (obj->type->destroy_order == cur_order) {
 +				int ret;
 +
 +				/*
 +				 * if we hit this WARN_ON, that means we are
 +				 * racing with a lookup_get.
  				 */
 -				if (owning_process)
 -					put_task_struct(owning_process);
 -				return;
 +				WARN_ON(uverbs_try_lock_object(obj, true));
 +				ret = obj->type->type_class->remove_commit(obj,
 +									   reason);
 +				list_del(&obj->list);
 +				if (ret)
 +					pr_warn("ib_uverbs: failed to remove uobject id %d order %u\n",
 +						obj->id, cur_order);
 +				/* put the ref we took when we created the object */
 +				uverbs_uobject_put(obj);
 +			} else {
 +				next_order = min(next_order,
 +						 obj->type->destroy_order);
  			}
  		}
 +		mutex_unlock(&ucontext->uobjects_lock);
 +		cur_order = next_order;
  	}
 -
 -	down_write(&owning_mm->mmap_sem);
 -	ib_dev->disassociate_ucontext(ibcontext);
 -	up_write(&owning_mm->mmap_sem);
 -	mmput(owning_mm);
 -	put_task_struct(owning_process);
 +	up_write(&ucontext->cleanup_rwsem);
  }
  
 -/*
 - * Drop the ucontext off the ufile and completely disconnect it from the
 - * ib_device
 - */
 -static void ufile_destroy_ucontext(struct ib_uverbs_file *ufile,
 -				   enum rdma_remove_reason reason)
 +void uverbs_initialize_ucontext(struct ib_ucontext *ucontext)
  {
++<<<<<<< HEAD
 +	ucontext->cleanup_reason = 0;
 +	mutex_init(&ucontext->uobjects_lock);
 +	INIT_LIST_HEAD(&ucontext->uobjects);
 +	init_rwsem(&ucontext->cleanup_rwsem);
++=======
+ 	struct ib_ucontext *ucontext = ufile->ucontext;
+ 	int ret;
+ 
+ 	if (reason == RDMA_REMOVE_DRIVER_REMOVE)
+ 		ufile_disassociate_ucontext(ucontext);
+ 
+ 	put_pid(ucontext->tgid);
+ 	ib_rdmacg_uncharge(&ucontext->cg_obj, ucontext->device,
+ 			   RDMACG_RESOURCE_HCA_HANDLE);
+ 
+ 	/*
+ 	 * FIXME: Drivers are not permitted to fail dealloc_ucontext, remove
+ 	 * the error return.
+ 	 */
+ 	ret = ucontext->device->dealloc_ucontext(ucontext);
+ 	WARN_ON(ret);
+ 
+ 	ufile->ucontext = NULL;
+ }
+ 
+ static int __uverbs_cleanup_ufile(struct ib_uverbs_file *ufile,
+ 				  enum rdma_remove_reason reason)
+ {
+ 	struct ib_uobject *obj, *next_obj;
+ 	int ret = -EINVAL;
+ 	int err = 0;
+ 
+ 	/*
+ 	 * This shouldn't run while executing other commands on this
+ 	 * context. Thus, the only thing we should take care of is
+ 	 * releasing a FD while traversing this list. The FD could be
+ 	 * closed and released from the _release fop of this FD.
+ 	 * In order to mitigate this, we add a lock.
+ 	 * We take and release the lock per traversal in order to let
+ 	 * other threads (which might still use the FDs) chance to run.
+ 	 */
+ 	list_for_each_entry_safe(obj, next_obj, &ufile->uobjects, list) {
+ 		/*
+ 		 * if we hit this WARN_ON, that means we are
+ 		 * racing with a lookup_get.
+ 		 */
+ 		WARN_ON(uverbs_try_lock_object(obj, true));
+ 		err = obj->type->type_class->remove_commit(obj, reason);
+ 
+ 		if (ib_is_destroy_retryable(err, reason, obj)) {
+ 			pr_debug("ib_uverbs: failed to remove uobject id %d err %d\n",
+ 				 obj->id, err);
+ 			atomic_set(&obj->usecnt, 0);
+ 			continue;
+ 		}
+ 
+ 		if (err)
+ 			pr_err("ib_uverbs: unable to remove uobject id %d err %d\n",
+ 				obj->id, err);
+ 
+ 		list_del(&obj->list);
+ 		/* Pairs with the get in rdma_alloc_commit_uobject() */
+ 		uverbs_uobject_put(obj);
+ 		ret = 0;
+ 	}
+ 	return ret;
+ }
+ 
+ /*
+  * Destroy the uncontext and every uobject associated with it. If called with
+  * reason != RDMA_REMOVE_CLOSE this will not return until the destruction has
+  * been completed and ufile->ucontext is NULL.
+  *
+  * This is internally locked and can be called in parallel from multiple
+  * contexts.
+  */
+ void uverbs_destroy_ufile_hw(struct ib_uverbs_file *ufile,
+ 			     enum rdma_remove_reason reason)
+ {
+ 	if (reason == RDMA_REMOVE_CLOSE) {
+ 		/*
+ 		 * During destruction we might trigger something that
+ 		 * synchronously calls release on any file descriptor. For
+ 		 * this reason all paths that come from file_operations
+ 		 * release must use try_lock. They can progress knowing that
+ 		 * there is an ongoing uverbs_destroy_ufile_hw that will clean
+ 		 * up the driver resources.
+ 		 */
+ 		if (!mutex_trylock(&ufile->ucontext_lock))
+ 			return;
+ 
+ 	} else {
+ 		mutex_lock(&ufile->ucontext_lock);
+ 	}
+ 
+ 	down_write(&ufile->hw_destroy_rwsem);
+ 
+ 	/*
+ 	 * If a ucontext was never created then we can't have any uobjects to
+ 	 * cleanup, nothing to do.
+ 	 */
+ 	if (!ufile->ucontext)
+ 		goto done;
+ 
+ 	ufile->ucontext->closing = true;
+ 	ufile->ucontext->cleanup_retryable = true;
+ 	while (!list_empty(&ufile->uobjects))
+ 		if (__uverbs_cleanup_ufile(ufile, reason)) {
+ 			/*
+ 			 * No entry was cleaned-up successfully during this
+ 			 * iteration
+ 			 */
+ 			break;
+ 		}
+ 
+ 	ufile->ucontext->cleanup_retryable = false;
+ 	if (!list_empty(&ufile->uobjects))
+ 		__uverbs_cleanup_ufile(ufile, reason);
+ 
+ 	ufile_destroy_ucontext(ufile, reason);
+ 
+ done:
+ 	up_write(&ufile->hw_destroy_rwsem);
+ 	mutex_unlock(&ufile->ucontext_lock);
++>>>>>>> 22fa27fbc64d (IB/uverbs: Fix locking around struct ib_uverbs_file ucontext)
  }
  
  const struct uverbs_obj_type_class uverbs_fd_class = {
diff --cc drivers/infiniband/core/uverbs.h
index 6700adb08a26,cf02b433000c..000000000000
--- a/drivers/infiniband/core/uverbs.h
+++ b/drivers/infiniband/core/uverbs.h
@@@ -136,9 -136,12 +136,17 @@@ struct ib_uverbs_completion_event_file 
  
  struct ib_uverbs_file {
  	struct kref				ref;
 +	struct mutex				mutex;
 +	struct mutex                            cleanup_mutex; /* protect cleanup */
  	struct ib_uverbs_device		       *device;
++<<<<<<< HEAD
++=======
+ 	struct mutex				ucontext_lock;
+ 	/*
+ 	 * ucontext must be accessed via ib_uverbs_get_ucontext() or with
+ 	 * ucontext_lock held
+ 	 */
++>>>>>>> 22fa27fbc64d (IB/uverbs: Fix locking around struct ib_uverbs_file ucontext)
  	struct ib_ucontext		       *ucontext;
  	struct ib_event_handler			event_handler;
  	struct ib_uverbs_async_event_file       *async_file;
diff --cc drivers/infiniband/core/uverbs_cmd.c
index 0dac1a540f96,38d7de3f9b2f..000000000000
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@@ -146,11 -146,15 +146,19 @@@ ssize_t ib_uverbs_get_context(struct ib
  		goto err_file;
  	}
  
- 	file->ucontext = ucontext;
- 
  	fd_install(resp.async_fd, filp);
  
++<<<<<<< HEAD
 +	mutex_unlock(&file->mutex);
++=======
+ 	/*
+ 	 * Make sure that ib_uverbs_get_ucontext() sees the pointer update
+ 	 * only after all writes to setup the ucontext have completed
+ 	 */
+ 	smp_store_release(&file->ucontext, ucontext);
+ 
+ 	mutex_unlock(&file->ucontext_lock);
++>>>>>>> 22fa27fbc64d (IB/uverbs: Fix locking around struct ib_uverbs_file ucontext)
  
  	return in_len;
  
diff --cc drivers/infiniband/core/uverbs_ioctl.c
index 03065bad8dae,db7a92ea5dbe..000000000000
--- a/drivers/infiniband/core/uverbs_ioctl.c
+++ b/drivers/infiniband/core/uverbs_ioctl.c
@@@ -145,7 -140,7 +145,11 @@@ static int uverbs_process_attr(struct i
  		if (uattr->attr_data.reserved)
  			return -EINVAL;
  
++<<<<<<< HEAD
 +		if (uattr->len != 0 || !ucontext || uattr->data > INT_MAX)
++=======
+ 		if (uattr->len != 0)
++>>>>>>> 22fa27fbc64d (IB/uverbs: Fix locking around struct ib_uverbs_file ucontext)
  			return -EINVAL;
  
  		o_attr = &e->obj_attr;
diff --cc drivers/infiniband/core/uverbs_main.c
index f24a6ab4cbde,34df04ed142b..000000000000
--- a/drivers/infiniband/core/uverbs_main.c
+++ b/drivers/infiniband/core/uverbs_main.c
@@@ -138,6 -136,30 +138,33 @@@ static int (*uverbs_ex_cmd_table[])(str
  static void ib_uverbs_add_one(struct ib_device *device);
  static void ib_uverbs_remove_one(struct ib_device *device, void *client_data);
  
++<<<<<<< HEAD
++=======
+ /*
+  * Must be called with the ufile->device->disassociate_srcu held, and the lock
+  * must be held until use of the ucontext is finished.
+  */
+ struct ib_ucontext *ib_uverbs_get_ucontext(struct ib_uverbs_file *ufile)
+ {
+ 	/*
+ 	 * We do not hold the hw_destroy_rwsem lock for this flow, instead
+ 	 * srcu is used. It does not matter if someone races this with
+ 	 * get_context, we get NULL or valid ucontext.
+ 	 */
+ 	struct ib_ucontext *ucontext = smp_load_acquire(&ufile->ucontext);
+ 
+ 	if (!srcu_dereference(ufile->device->ib_dev,
+ 			      &ufile->device->disassociate_srcu))
+ 		return ERR_PTR(-EIO);
+ 
+ 	if (!ucontext)
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	return ucontext;
+ }
+ EXPORT_SYMBOL(ib_uverbs_get_ucontext);
+ 
++>>>>>>> 22fa27fbc64d (IB/uverbs: Fix locking around struct ib_uverbs_file ucontext)
  int uverbs_dealloc_mw(struct ib_mw *mw)
  {
  	struct ib_pd *pd = mw->pd;
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
* Unmerged path drivers/infiniband/core/rdma_core.c
* Unmerged path drivers/infiniband/core/uverbs.h
* Unmerged path drivers/infiniband/core/uverbs_cmd.c
* Unmerged path drivers/infiniband/core/uverbs_ioctl.c
* Unmerged path drivers/infiniband/core/uverbs_main.c
diff --git a/drivers/infiniband/core/uverbs_std_types_cq.c b/drivers/infiniband/core/uverbs_std_types_cq.c
index 150b7c04ce15..75deea3890de 100644
--- a/drivers/infiniband/core/uverbs_std_types_cq.c
+++ b/drivers/infiniband/core/uverbs_std_types_cq.c
@@ -109,7 +109,7 @@ static int UVERBS_HANDLER(UVERBS_METHOD_CQ_CREATE)(struct ib_device *ib_dev,
 	/* Temporary, only until drivers get the new uverbs_attr_bundle */
 	create_udata(attrs, &uhw);
 
-	cq = ib_dev->create_cq(ib_dev, &attr, file->ucontext, &uhw);
+	cq = ib_dev->create_cq(ib_dev, &attr, obj->uobject.context, &uhw);
 	if (IS_ERR(cq)) {
 		ret = PTR_ERR(cq);
 		goto err_event_file;
diff --git a/drivers/infiniband/core/uverbs_std_types_dm.c b/drivers/infiniband/core/uverbs_std_types_dm.c
index b11344264f4e..bd95c47d34c5 100644
--- a/drivers/infiniband/core/uverbs_std_types_dm.c
+++ b/drivers/infiniband/core/uverbs_std_types_dm.c
@@ -68,7 +68,7 @@ static int UVERBS_HANDLER(UVERBS_METHOD_DM_ALLOC)(struct ib_device *ib_dev,
 
 	uobj = uverbs_attr_get(attrs, UVERBS_ATTR_ALLOC_DM_HANDLE)->obj_attr.uobject;
 
-	dm = ib_dev->alloc_dm(ib_dev, file->ucontext, &attr, attrs);
+	dm = ib_dev->alloc_dm(ib_dev, uobj->context, &attr, attrs);
 	if (IS_ERR(dm))
 		return PTR_ERR(dm);
 
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
diff --git a/include/rdma/uverbs_ioctl.h b/include/rdma/uverbs_ioctl.h
index 90a4947ff548..ac00c138f8a6 100644
--- a/include/rdma/uverbs_ioctl.h
+++ b/include/rdma/uverbs_ioctl.h
@@ -124,14 +124,6 @@ struct uverbs_attr_spec_hash {
 struct uverbs_attr_bundle;
 struct ib_uverbs_file;
 
-enum {
-	/*
-	 * Action marked with this flag creates a context (or root for all
-	 * objects).
-	 */
-	UVERBS_ACTION_FLAG_CREATE_ROOT = 1U << 0,
-};
-
 struct uverbs_method_spec {
 	/* Combination of bits from enum UVERBS_ACTION_FLAG_XXXX */
 	u32						flags;
