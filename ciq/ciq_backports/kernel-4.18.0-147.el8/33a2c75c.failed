libbpf: add internal pin_name

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Stanislav Fomichev <sdf@google.com>
commit 33a2c75c55e24aa30ff9fed805ae8bea13c1e2a3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/33a2c75c.failed

pin_name is the same as section_name where '/' is replaced
by '_'. bpf_object__pin_programs is converted to use pin_name
to avoid the situation where section_name would require creating another
subdirectory for a pin (as, for example, when calling bpf_object__pin_programs
for programs in sections like "cgroup/connect6").

	Signed-off-by: Stanislav Fomichev <sdf@google.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit 33a2c75c55e24aa30ff9fed805ae8bea13c1e2a3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/libbpf.c
diff --cc tools/lib/bpf/libbpf.c
index f064c910a99d,e827542ffa3a..000000000000
--- a/tools/lib/bpf/libbpf.c
+++ b/tools/lib/bpf/libbpf.c
@@@ -1789,6 -1899,194 +1812,197 @@@ int bpf_map__pin(struct bpf_map *map, c
  	}
  
  	pr_debug("pinned map '%s'\n", path);
++<<<<<<< HEAD
++=======
+ 
+ 	return 0;
+ }
+ 
+ int bpf_map__unpin(struct bpf_map *map, const char *path)
+ {
+ 	int err;
+ 
+ 	err = check_path(path);
+ 	if (err)
+ 		return err;
+ 
+ 	if (map == NULL) {
+ 		pr_warning("invalid map pointer\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	err = unlink(path);
+ 	if (err != 0)
+ 		return -errno;
+ 	pr_debug("unpinned map '%s'\n", path);
+ 
+ 	return 0;
+ }
+ 
+ int bpf_object__pin_maps(struct bpf_object *obj, const char *path)
+ {
+ 	struct bpf_map *map;
+ 	int err;
+ 
+ 	if (!obj)
+ 		return -ENOENT;
+ 
+ 	if (!obj->loaded) {
+ 		pr_warning("object not yet loaded; load it first\n");
+ 		return -ENOENT;
+ 	}
+ 
+ 	err = make_dir(path);
+ 	if (err)
+ 		return err;
+ 
+ 	bpf_map__for_each(map, obj) {
+ 		char buf[PATH_MAX];
+ 		int len;
+ 
+ 		len = snprintf(buf, PATH_MAX, "%s/%s", path,
+ 			       bpf_map__name(map));
+ 		if (len < 0) {
+ 			err = -EINVAL;
+ 			goto err_unpin_maps;
+ 		} else if (len >= PATH_MAX) {
+ 			err = -ENAMETOOLONG;
+ 			goto err_unpin_maps;
+ 		}
+ 
+ 		err = bpf_map__pin(map, buf);
+ 		if (err)
+ 			goto err_unpin_maps;
+ 	}
+ 
+ 	return 0;
+ 
+ err_unpin_maps:
+ 	while ((map = bpf_map__prev(map, obj))) {
+ 		char buf[PATH_MAX];
+ 		int len;
+ 
+ 		len = snprintf(buf, PATH_MAX, "%s/%s", path,
+ 			       bpf_map__name(map));
+ 		if (len < 0)
+ 			continue;
+ 		else if (len >= PATH_MAX)
+ 			continue;
+ 
+ 		bpf_map__unpin(map, buf);
+ 	}
+ 
+ 	return err;
+ }
+ 
+ int bpf_object__unpin_maps(struct bpf_object *obj, const char *path)
+ {
+ 	struct bpf_map *map;
+ 	int err;
+ 
+ 	if (!obj)
+ 		return -ENOENT;
+ 
+ 	bpf_map__for_each(map, obj) {
+ 		char buf[PATH_MAX];
+ 		int len;
+ 
+ 		len = snprintf(buf, PATH_MAX, "%s/%s", path,
+ 			       bpf_map__name(map));
+ 		if (len < 0)
+ 			return -EINVAL;
+ 		else if (len >= PATH_MAX)
+ 			return -ENAMETOOLONG;
+ 
+ 		err = bpf_map__unpin(map, buf);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ int bpf_object__pin_programs(struct bpf_object *obj, const char *path)
+ {
+ 	struct bpf_program *prog;
+ 	int err;
+ 
+ 	if (!obj)
+ 		return -ENOENT;
+ 
+ 	if (!obj->loaded) {
+ 		pr_warning("object not yet loaded; load it first\n");
+ 		return -ENOENT;
+ 	}
+ 
+ 	err = make_dir(path);
+ 	if (err)
+ 		return err;
+ 
+ 	bpf_object__for_each_program(prog, obj) {
+ 		char buf[PATH_MAX];
+ 		int len;
+ 
+ 		len = snprintf(buf, PATH_MAX, "%s/%s", path,
+ 			       prog->pin_name);
+ 		if (len < 0) {
+ 			err = -EINVAL;
+ 			goto err_unpin_programs;
+ 		} else if (len >= PATH_MAX) {
+ 			err = -ENAMETOOLONG;
+ 			goto err_unpin_programs;
+ 		}
+ 
+ 		err = bpf_program__pin(prog, buf);
+ 		if (err)
+ 			goto err_unpin_programs;
+ 	}
+ 
+ 	return 0;
+ 
+ err_unpin_programs:
+ 	while ((prog = bpf_program__prev(prog, obj))) {
+ 		char buf[PATH_MAX];
+ 		int len;
+ 
+ 		len = snprintf(buf, PATH_MAX, "%s/%s", path,
+ 			       prog->pin_name);
+ 		if (len < 0)
+ 			continue;
+ 		else if (len >= PATH_MAX)
+ 			continue;
+ 
+ 		bpf_program__unpin(prog, buf);
+ 	}
+ 
+ 	return err;
+ }
+ 
+ int bpf_object__unpin_programs(struct bpf_object *obj, const char *path)
+ {
+ 	struct bpf_program *prog;
+ 	int err;
+ 
+ 	if (!obj)
+ 		return -ENOENT;
+ 
+ 	bpf_object__for_each_program(prog, obj) {
+ 		char buf[PATH_MAX];
+ 		int len;
+ 
+ 		len = snprintf(buf, PATH_MAX, "%s/%s", path,
+ 			       prog->pin_name);
+ 		if (len < 0)
+ 			return -EINVAL;
+ 		else if (len >= PATH_MAX)
+ 			return -ENAMETOOLONG;
+ 
+ 		err = bpf_program__unpin(prog, buf);
+ 		if (err)
+ 			return err;
+ 	}
+ 
++>>>>>>> 33a2c75c55e2 (libbpf: add internal pin_name)
  	return 0;
  }
  
* Unmerged path tools/lib/bpf/libbpf.c
