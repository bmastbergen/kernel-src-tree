RDMA/uverbs: Do not pass ib_uverbs_file to ioctl methods

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jason Gunthorpe <jgg@ziepe.ca>
commit 15a1b4becba886176aa1426604548c34904fd054
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/15a1b4be.failed

The uverbs_attr_bundle already contains this pointer, and most methods
don't actually need it. Get rid of the redundant function argument.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
(cherry picked from commit 15a1b4becba886176aa1426604548c34904fd054)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/rdma_core.h
#	drivers/infiniband/core/uverbs_ioctl.c
#	drivers/infiniband/core/uverbs_std_types.c
#	drivers/infiniband/core/uverbs_std_types_counters.c
#	drivers/infiniband/core/uverbs_std_types_cq.c
#	drivers/infiniband/core/uverbs_std_types_dm.c
#	drivers/infiniband/core/uverbs_std_types_flow_action.c
#	drivers/infiniband/core/uverbs_std_types_mr.c
#	drivers/infiniband/hw/mlx5/devx.c
#	drivers/infiniband/hw/mlx5/flow.c
#	include/rdma/ib_verbs.h
#	include/rdma/uverbs_ioctl.h
diff --cc drivers/infiniband/core/rdma_core.h
index a243cc2a59f7,ce323439a0f9..000000000000
--- a/drivers/infiniband/core/rdma_core.h
+++ b/drivers/infiniband/core/rdma_core.h
@@@ -113,4 -106,101 +113,104 @@@ int uverbs_finalize_object(struct ib_uo
  			   enum uverbs_obj_access access,
  			   bool commit);
  
++<<<<<<< HEAD
++=======
+ void setup_ufile_idr_uobject(struct ib_uverbs_file *ufile);
+ void release_ufile_idr_uobject(struct ib_uverbs_file *ufile);
+ 
+ /*
+  * This is the runtime description of the uverbs API, used by the syscall
+  * machinery to validate and dispatch calls.
+  */
+ 
+ /*
+  * Depending on ID the slot pointer in the radix tree points at one of these
+  * structs.
+  */
+ struct uverbs_api_object {
+ 	const struct uverbs_obj_type *type_attrs;
+ 	const struct uverbs_obj_type_class *type_class;
+ 	u8 disabled:1;
+ };
+ 
+ struct uverbs_api_ioctl_method {
+ 	int(__rcu *handler)(struct uverbs_attr_bundle *attrs);
+ 	DECLARE_BITMAP(attr_mandatory, UVERBS_API_ATTR_BKEY_LEN);
+ 	u16 bundle_size;
+ 	u8 use_stack:1;
+ 	u8 driver_method:1;
+ 	u8 disabled:1;
+ 	u8 key_bitmap_len;
+ 	u8 destroy_bkey;
+ };
+ 
+ struct uverbs_api_write_method {
+ 	int (*handler)(struct uverbs_attr_bundle *attrs, const char __user *buf,
+ 		       int in_len, int out_len);
+ 	int (*handler_ex)(struct uverbs_attr_bundle *attrs,
+ 			  struct ib_udata *ucore, struct ib_udata *uhw);
+ 	u8 disabled:1;
+ 	u8 is_ex:1;
+ };
+ 
+ struct uverbs_api_attr {
+ 	struct uverbs_attr_spec spec;
+ };
+ 
+ struct uverbs_api {
+ 	/* radix tree contains struct uverbs_api_* pointers */
+ 	struct radix_tree_root radix;
+ 	enum rdma_driver_id driver_id;
+ 
+ 	unsigned int num_write;
+ 	unsigned int num_write_ex;
+ 	struct uverbs_api_write_method notsupp_method;
+ 	const struct uverbs_api_write_method **write_methods;
+ 	const struct uverbs_api_write_method **write_ex_methods;
+ };
+ 
+ static inline const struct uverbs_api_object *
+ uapi_get_object(struct uverbs_api *uapi, u16 object_id)
+ {
+ 	return radix_tree_lookup(&uapi->radix, uapi_key_obj(object_id));
+ }
+ 
+ char *uapi_key_format(char *S, unsigned int key);
+ struct uverbs_api *uverbs_alloc_api(struct ib_device *ibdev);
+ void uverbs_disassociate_api_pre(struct ib_uverbs_device *uverbs_dev);
+ void uverbs_disassociate_api(struct uverbs_api *uapi);
+ void uverbs_destroy_api(struct uverbs_api *uapi);
+ void uapi_compute_bundle_size(struct uverbs_api_ioctl_method *method_elm,
+ 			      unsigned int num_attrs);
+ void uverbs_user_mmap_disassociate(struct ib_uverbs_file *ufile);
+ 
+ extern const struct uapi_definition uverbs_def_obj_counters[];
+ extern const struct uapi_definition uverbs_def_obj_cq[];
+ extern const struct uapi_definition uverbs_def_obj_dm[];
+ extern const struct uapi_definition uverbs_def_obj_flow_action[];
+ extern const struct uapi_definition uverbs_def_obj_intf[];
+ extern const struct uapi_definition uverbs_def_obj_mr[];
+ extern const struct uapi_definition uverbs_def_write_intf[];
+ 
+ static inline const struct uverbs_api_write_method *
+ uapi_get_method(const struct uverbs_api *uapi, u32 command)
+ {
+ 	u32 cmd_idx = command & IB_USER_VERBS_CMD_COMMAND_MASK;
+ 
+ 	if (command & ~(u32)(IB_USER_VERBS_CMD_FLAG_EXTENDED |
+ 			     IB_USER_VERBS_CMD_COMMAND_MASK))
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	if (command & IB_USER_VERBS_CMD_FLAG_EXTENDED) {
+ 		if (cmd_idx >= uapi->num_write_ex)
+ 			return ERR_PTR(-EOPNOTSUPP);
+ 		return uapi->write_ex_methods[cmd_idx];
+ 	}
+ 
+ 	if (cmd_idx >= uapi->num_write)
+ 		return ERR_PTR(-EOPNOTSUPP);
+ 	return uapi->write_methods[cmd_idx];
+ }
+ 
++>>>>>>> 15a1b4becba8 (RDMA/uverbs: Do not pass ib_uverbs_file to ioctl methods)
  #endif /* RDMA_CORE_H */
diff --cc drivers/infiniband/core/uverbs_ioctl.c
index 03065bad8dae,5c04149ce775..000000000000
--- a/drivers/infiniband/core/uverbs_ioctl.c
+++ b/drivers/infiniband/core/uverbs_ioctl.c
@@@ -183,311 -339,408 +183,376 @@@ static int uverbs_process_attr(struct i
  	return 0;
  }
  
 -/*
 - * We search the radix tree with the method prefix and now we want to fast
 - * search the suffix bits to get a particular attribute pointer. It is not
 - * totally clear to me if this breaks the radix tree encasulation or not, but
 - * it uses the iter data to determine if the method iter points at the same
 - * chunk that will store the attribute, if so it just derefs it directly. By
 - * construction in most kernel configs the method and attrs will all fit in a
 - * single radix chunk, so in most cases this will have no search. Other cases
 - * this falls back to a full search.
 - */
 -static void __rcu **uapi_get_attr_for_method(struct bundle_priv *pbundle,
 -					     u32 attr_key)
 +static int uverbs_finalize_attrs(struct uverbs_attr_bundle *attrs_bundle,
 +				 struct uverbs_attr_spec_hash *const *spec_hash,
 +				 size_t num, bool commit)
  {
++<<<<<<< HEAD
++=======
+ 	void __rcu **slot;
+ 
+ 	if (likely(attr_key < pbundle->radix_slots_len)) {
+ 		void *entry;
+ 
+ 		slot = pbundle->radix_slots + attr_key;
+ 		entry = rcu_dereference_raw(*slot);
+ 		if (likely(!radix_tree_is_internal_node(entry) && entry))
+ 			return slot;
+ 	}
+ 
+ 	return radix_tree_lookup_slot(pbundle->radix,
+ 				      pbundle->method_key | attr_key);
+ }
+ 
+ static int uverbs_set_attr(struct bundle_priv *pbundle,
+ 			   struct ib_uverbs_attr *uattr)
+ {
+ 	u32 attr_key = uapi_key_attr(uattr->attr_id);
+ 	u32 attr_bkey = uapi_bkey_attr(attr_key);
+ 	const struct uverbs_api_attr *attr;
+ 	void __rcu **slot;
+ 	int ret;
+ 
+ 	slot = uapi_get_attr_for_method(pbundle, attr_key);
+ 	if (!slot) {
+ 		/*
+ 		 * Kernel does not support the attribute but user-space says it
+ 		 * is mandatory
+ 		 */
+ 		if (uattr->flags & UVERBS_ATTR_F_MANDATORY)
+ 			return -EPROTONOSUPPORT;
+ 		return 0;
+ 	}
+ 	attr = rcu_dereference_protected(*slot, true);
+ 
+ 	/* Reject duplicate attributes from user-space */
+ 	if (test_bit(attr_bkey, pbundle->bundle.attr_present))
+ 		return -EINVAL;
+ 
+ 	ret = uverbs_process_attr(pbundle, attr, uattr, attr_bkey);
+ 	if (ret)
+ 		return ret;
+ 
+ 	__set_bit(attr_bkey, pbundle->bundle.attr_present);
+ 
+ 	return 0;
+ }
+ 
+ static int ib_uverbs_run_method(struct bundle_priv *pbundle,
+ 				unsigned int num_attrs)
+ {
+ 	int (*handler)(struct uverbs_attr_bundle *attrs);
+ 	size_t uattrs_size = array_size(sizeof(*pbundle->uattrs), num_attrs);
+ 	unsigned int destroy_bkey = pbundle->method_elm->destroy_bkey;
++>>>>>>> 15a1b4becba8 (RDMA/uverbs: Do not pass ib_uverbs_file to ioctl methods)
  	unsigned int i;
 -	int ret;
 +	int ret = 0;
  
 -	/* See uverbs_disassociate_api() */
 -	handler = srcu_dereference(
 -		pbundle->method_elm->handler,
 -		&pbundle->bundle.ufile->device->disassociate_srcu);
 -	if (!handler)
 -		return -EIO;
 -
 -	pbundle->uattrs = uverbs_alloc(&pbundle->bundle, uattrs_size);
 -	if (IS_ERR(pbundle->uattrs))
 -		return PTR_ERR(pbundle->uattrs);
 -	if (copy_from_user(pbundle->uattrs, pbundle->user_attrs, uattrs_size))
 -		return -EFAULT;
 -
 -	for (i = 0; i != num_attrs; i++) {
 -		ret = uverbs_set_attr(pbundle, &pbundle->uattrs[i]);
 -		if (unlikely(ret))
 -			return ret;
 -	}
 +	for (i = 0; i < num; i++) {
 +		struct uverbs_attr_bundle_hash *curr_bundle =
 +			&attrs_bundle->hash[i];
 +		const struct uverbs_attr_spec_hash *curr_spec_bucket =
 +			spec_hash[i];
 +		unsigned int j;
  
 -	/* User space did not provide all the mandatory attributes */
 -	if (unlikely(!bitmap_subset(pbundle->method_elm->attr_mandatory,
 -				    pbundle->bundle.attr_present,
 -				    pbundle->method_elm->key_bitmap_len)))
 -		return -EINVAL;
 +		if (!curr_spec_bucket)
 +			continue;
 +
 +		for (j = 0; j < curr_bundle->num_attrs; j++) {
 +			struct uverbs_attr *attr;
 +			const struct uverbs_attr_spec *spec;
 +
 +			if (!uverbs_attr_is_valid_in_hash(curr_bundle, j))
 +				continue;
 +
 +			attr = &curr_bundle->attrs[j];
 +			spec = &curr_spec_bucket->attrs[j];
 +
 +			if (spec->type == UVERBS_ATTR_TYPE_IDR ||
 +			    spec->type == UVERBS_ATTR_TYPE_FD) {
 +				int current_ret;
 +
 +				current_ret = uverbs_finalize_object(
 +					attr->obj_attr.uobject,
 +					spec->obj.access, commit);
 +				if (!ret)
 +					ret = current_ret;
 +			} else if (spec->type == UVERBS_ATTR_TYPE_PTR_IN &&
 +				   spec->flags &
 +					   UVERBS_ATTR_SPEC_F_ALLOC_AND_COPY &&
 +				   !uverbs_attr_ptr_is_inline(attr)) {
 +				kvfree(attr->ptr_attr.ptr);
 +			}
 +		}
 +	}
 +	return ret;
 +}
  
 -	if (destroy_bkey != UVERBS_API_ATTR_BKEY_LEN) {
 -		struct uverbs_obj_attr *destroy_attr =
 -			&pbundle->bundle.attrs[destroy_bkey].obj_attr;
 +static int uverbs_uattrs_process(struct ib_device *ibdev,
 +				 struct ib_ucontext *ucontext,
 +				 const struct ib_uverbs_attr *uattrs,
 +				 size_t num_uattrs,
 +				 const struct uverbs_method_spec *method,
 +				 struct uverbs_attr_bundle *attr_bundle,
 +				 struct ib_uverbs_attr __user *uattr_ptr)
 +{
 +	size_t i;
 +	int ret = 0;
 +	int num_given_buckets = 0;
 +
 +	for (i = 0; i < num_uattrs; i++) {
 +		const struct ib_uverbs_attr *uattr = &uattrs[i];
 +		u16 attr_id = uattr->attr_id;
 +		struct uverbs_attr_spec_hash *attr_spec_bucket;
 +
 +		ret = uverbs_ns_idx(&attr_id, method->num_buckets);
 +		if (ret < 0 || !method->attr_buckets[ret]) {
 +			if (uattr->flags & UVERBS_ATTR_F_MANDATORY) {
 +				uverbs_finalize_attrs(attr_bundle,
 +						      method->attr_buckets,
 +						      num_given_buckets,
 +						      false);
 +				return ret;
 +			}
 +			continue;
 +		}
  
 -		ret = uobj_destroy(destroy_attr->uobject);
 -		if (ret)
 +		/*
 +		 * ret is the found ns, so increase num_given_buckets if
 +		 * necessary.
 +		 */
 +		if (ret >= num_given_buckets)
 +			num_given_buckets = ret + 1;
 +
 +		attr_spec_bucket = method->attr_buckets[ret];
 +		ret = uverbs_process_attr(ibdev, ucontext, uattr, attr_id,
 +					  attr_spec_bucket, &attr_bundle->hash[ret],
 +					  uattr_ptr++);
 +		if (ret) {
 +			uverbs_finalize_attrs(attr_bundle,
 +					      method->attr_buckets,
 +					      num_given_buckets,
 +					      false);
  			return ret;
 -		__clear_bit(destroy_bkey, pbundle->uobj_finalize);
 -
 -		ret = handler(&pbundle->bundle);
 -		uobj_put_destroy(destroy_attr->uobject);
 -	} else {
 -		ret = handler(&pbundle->bundle);
 +		}
  	}
  
 -	/*
 -	 * EPROTONOSUPPORT is ONLY to be returned if the ioctl framework can
 -	 * not invoke the method because the request is not supported.  No
 -	 * other cases should return this code.
 -	 */
 -	if (WARN_ON_ONCE(ret == -EPROTONOSUPPORT))
 -		return -EINVAL;
 -
 -	return ret;
 +	return num_given_buckets;
  }
  
 -static int bundle_destroy(struct bundle_priv *pbundle, bool commit)
 +static int uverbs_validate_kernel_mandatory(const struct uverbs_method_spec *method_spec,
 +					    struct uverbs_attr_bundle *attr_bundle)
  {
 -	unsigned int key_bitmap_len = pbundle->method_elm->key_bitmap_len;
 -	struct bundle_alloc_head *memblock;
  	unsigned int i;
 -	int ret = 0;
  
 -	/* fast path for simple uobjects */
 -	i = -1;
 -	while ((i = find_next_bit(pbundle->uobj_finalize, key_bitmap_len,
 -				  i + 1)) < key_bitmap_len) {
 -		struct uverbs_attr *attr = &pbundle->bundle.attrs[i];
 -		int current_ret;
 -
 -		current_ret = uverbs_finalize_object(
 -			attr->obj_attr.uobject,
 -			attr->obj_attr.attr_elm->spec.u.obj.access, commit);
 -		if (!ret)
 -			ret = current_ret;
 -	}
 +	for (i = 0; i < attr_bundle->num_buckets; i++) {
 +		struct uverbs_attr_spec_hash *attr_spec_bucket =
 +			method_spec->attr_buckets[i];
  
 -	i = -1;
 -	while ((i = find_next_bit(pbundle->spec_finalize, key_bitmap_len,
 -				  i + 1)) < key_bitmap_len) {
 -		struct uverbs_attr *attr = &pbundle->bundle.attrs[i];
 -		const struct uverbs_api_attr *attr_uapi;
 -		void __rcu **slot;
 -		int current_ret;
 -
 -		slot = uapi_get_attr_for_method(
 -			pbundle,
 -			pbundle->method_key | uapi_bkey_to_key_attr(i));
 -		if (WARN_ON(!slot))
 +		if (!attr_spec_bucket)
  			continue;
  
 -		attr_uapi = rcu_dereference_protected(*slot, true);
 -
 -		if (attr_uapi->spec.type == UVERBS_ATTR_TYPE_IDRS_ARRAY) {
 -			current_ret = uverbs_free_idrs_array(
 -				attr_uapi, &attr->objs_arr_attr, commit);
 -			if (!ret)
 -				ret = current_ret;
 -		}
 +		if (!bitmap_subset(attr_spec_bucket->mandatory_attrs_bitmask,
 +				   attr_bundle->hash[i].valid_bitmap,
 +				   attr_spec_bucket->num_attrs))
 +			return -EINVAL;
  	}
  
 -	for (memblock = pbundle->allocated_mem; memblock;) {
 -		struct bundle_alloc_head *tmp = memblock;
 +	for (; i < method_spec->num_buckets; i++) {
 +		struct uverbs_attr_spec_hash *attr_spec_bucket =
 +			method_spec->attr_buckets[i];
  
 -		memblock = memblock->next;
 -		kvfree(tmp);
 +		if (!bitmap_empty(attr_spec_bucket->mandatory_attrs_bitmask,
 +				  attr_spec_bucket->num_attrs))
 +			return -EINVAL;
  	}
  
 -	return ret;
 +	return 0;
  }
  
 -static int ib_uverbs_cmd_verbs(struct ib_uverbs_file *ufile,
 -			       struct ib_uverbs_ioctl_hdr *hdr,
 -			       struct ib_uverbs_attr __user *user_attrs)
 +static int uverbs_handle_method(struct ib_uverbs_attr __user *uattr_ptr,
 +				const struct ib_uverbs_attr *uattrs,
 +				size_t num_uattrs,
 +				struct ib_device *ibdev,
 +				struct ib_uverbs_file *ufile,
 +				const struct uverbs_method_spec *method_spec,
 +				struct uverbs_attr_bundle *attr_bundle)
  {
 -	const struct uverbs_api_ioctl_method *method_elm;
 -	struct uverbs_api *uapi = ufile->device->uapi;
 -	struct radix_tree_iter attrs_iter;
 -	struct bundle_priv *pbundle;
 -	struct bundle_priv onstack;
 -	void __rcu **slot;
 -	int destroy_ret;
  	int ret;
 +	int finalize_ret;
 +	int num_given_buckets;
  
 -	if (unlikely(hdr->driver_id != uapi->driver_id))
 +	num_given_buckets = uverbs_uattrs_process(ibdev, ufile->ucontext, uattrs,
 +						  num_uattrs, method_spec,
 +						  attr_bundle, uattr_ptr);
 +	if (num_given_buckets <= 0)
  		return -EINVAL;
  
 -	slot = radix_tree_iter_lookup(
 -		&uapi->radix, &attrs_iter,
 -		uapi_key_obj(hdr->object_id) |
 -			uapi_key_ioctl_method(hdr->method_id));
 -	if (unlikely(!slot))
 -		return -EPROTONOSUPPORT;
 -	method_elm = rcu_dereference_protected(*slot, true);
 -
 -	if (!method_elm->use_stack) {
 -		pbundle = kmalloc(method_elm->bundle_size, GFP_KERNEL);
 -		if (!pbundle)
 -			return -ENOMEM;
 -		pbundle->internal_avail =
 -			method_elm->bundle_size -
 -			offsetof(struct bundle_priv, internal_buffer);
 -		pbundle->alloc_head.next = NULL;
 -		pbundle->allocated_mem = &pbundle->alloc_head;
 -	} else {
 -		pbundle = &onstack;
 -		pbundle->internal_avail = sizeof(pbundle->internal_buffer);
 -		pbundle->allocated_mem = NULL;
 -	}
 +	attr_bundle->num_buckets = num_given_buckets;
 +	ret = uverbs_validate_kernel_mandatory(method_spec, attr_bundle);
 +	if (ret)
 +		goto cleanup;
  
 -	/* Space for the pbundle->bundle.attrs flex array */
 -	pbundle->method_elm = method_elm;
 -	pbundle->method_key = attrs_iter.index;
 -	pbundle->bundle.ufile = ufile;
 -	pbundle->radix = &uapi->radix;
 -	pbundle->radix_slots = slot;
 -	pbundle->radix_slots_len = radix_tree_chunk_size(&attrs_iter);
 -	pbundle->user_attrs = user_attrs;
 -
 -	pbundle->internal_used = ALIGN(pbundle->method_elm->key_bitmap_len *
 -					       sizeof(*pbundle->bundle.attrs),
 -				       sizeof(*pbundle->internal_buffer));
 -	memset(pbundle->bundle.attr_present, 0,
 -	       sizeof(pbundle->bundle.attr_present));
 -	memset(pbundle->uobj_finalize, 0, sizeof(pbundle->uobj_finalize));
 -	memset(pbundle->spec_finalize, 0, sizeof(pbundle->spec_finalize));
 -
 -	ret = ib_uverbs_run_method(pbundle, hdr->num_attrs);
 -	destroy_ret = bundle_destroy(pbundle, ret == 0);
 -	if (unlikely(destroy_ret && !ret))
 -		return destroy_ret;
 +	ret = method_spec->handler(ibdev, ufile, attr_bundle);
 +cleanup:
 +	finalize_ret = uverbs_finalize_attrs(attr_bundle,
 +					     method_spec->attr_buckets,
 +					     attr_bundle->num_buckets,
 +					     !ret);
  
 -	return ret;
++<<<<<<< HEAD
 +	return ret ? ret : finalize_ret;
  }
  
 -long ib_uverbs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 +#define UVERBS_OPTIMIZE_USING_STACK_SZ  256
 +static long ib_uverbs_cmd_verbs(struct ib_device *ib_dev,
 +				struct ib_uverbs_file *file,
 +				struct ib_uverbs_ioctl_hdr *hdr,
 +				void __user *buf)
  {
 -	struct ib_uverbs_file *file = filp->private_data;
 -	struct ib_uverbs_ioctl_hdr __user *user_hdr =
 -		(struct ib_uverbs_ioctl_hdr __user *)arg;
 -	struct ib_uverbs_ioctl_hdr hdr;
 -	int srcu_key;
 -	int err;
 -
 -	if (unlikely(cmd != RDMA_VERBS_IOCTL))
 -		return -ENOIOCTLCMD;
 -
 -	err = copy_from_user(&hdr, user_hdr, sizeof(hdr));
 -	if (err)
 -		return -EFAULT;
 -
 -	if (hdr.length > PAGE_SIZE ||
 -	    hdr.length != struct_size(&hdr, attrs, hdr.num_attrs))
 +	const struct uverbs_object_spec *object_spec;
 +	const struct uverbs_method_spec *method_spec;
 +	long err = 0;
 +	unsigned int i;
 +	struct {
 +		struct ib_uverbs_attr		*uattrs;
 +		struct uverbs_attr_bundle	*uverbs_attr_bundle;
 +	} *ctx = NULL;
 +	struct uverbs_attr *curr_attr;
 +	unsigned long *curr_bitmap;
 +	size_t ctx_size;
 +	uintptr_t data[UVERBS_OPTIMIZE_USING_STACK_SZ / sizeof(uintptr_t)];
 +
 +	if (hdr->driver_id != ib_dev->driver_id)
  		return -EINVAL;
  
 -	if (hdr.reserved1 || hdr.reserved2)
 +	object_spec = uverbs_get_object(ib_dev, hdr->object_id);
 +	if (!object_spec)
  		return -EPROTONOSUPPORT;
  
 -	srcu_key = srcu_read_lock(&file->device->disassociate_srcu);
 -	err = ib_uverbs_cmd_verbs(file, &hdr, user_hdr->attrs);
 -	srcu_read_unlock(&file->device->disassociate_srcu, srcu_key);
 -	return err;
 -}
 +	method_spec = uverbs_get_method(object_spec, hdr->method_id);
 +	if (!method_spec)
 +		return -EPROTONOSUPPORT;
  
 -int uverbs_get_flags64(u64 *to, const struct uverbs_attr_bundle *attrs_bundle,
 -		       size_t idx, u64 allowed_bits)
 -{
 -	const struct uverbs_attr *attr;
 -	u64 flags;
 +	if ((method_spec->flags & UVERBS_ACTION_FLAG_CREATE_ROOT) ^ !file->ucontext)
 +		return -EINVAL;
  
 -	attr = uverbs_attr_get(attrs_bundle, idx);
 -	/* Missing attribute means 0 flags */
 -	if (IS_ERR(attr)) {
 -		*to = 0;
 -		return 0;
 -	}
 +	ctx_size = sizeof(*ctx) +
 +		   sizeof(struct uverbs_attr_bundle) +
 +		   sizeof(struct uverbs_attr_bundle_hash) * method_spec->num_buckets +
 +		   sizeof(*ctx->uattrs) * hdr->num_attrs +
 +		   sizeof(*ctx->uverbs_attr_bundle->hash[0].attrs) *
 +		   method_spec->num_child_attrs +
 +		   sizeof(*ctx->uverbs_attr_bundle->hash[0].valid_bitmap) *
 +			(method_spec->num_child_attrs / BITS_PER_LONG +
 +			 method_spec->num_buckets);
 +
 +	if (ctx_size <= UVERBS_OPTIMIZE_USING_STACK_SZ)
 +		ctx = (void *)data;
 +	if (!ctx)
 +		ctx = kmalloc(ctx_size, GFP_KERNEL);
 +	if (!ctx)
 +		return -ENOMEM;
 +
 +	ctx->uverbs_attr_bundle = (void *)ctx + sizeof(*ctx);
 +	ctx->uattrs = (void *)(ctx->uverbs_attr_bundle + 1) +
 +			      (sizeof(ctx->uverbs_attr_bundle->hash[0]) *
 +			       method_spec->num_buckets);
 +	curr_attr = (void *)(ctx->uattrs + hdr->num_attrs);
 +	curr_bitmap = (void *)(curr_attr + method_spec->num_child_attrs);
  
  	/*
 -	 * New userspace code should use 8 bytes to pass flags, but we
 -	 * transparently support old userspaces that were using 4 bytes as
 -	 * well.
 +	 * We just fill the pointers and num_attrs here. The data itself will be
 +	 * filled at a later stage (uverbs_process_attr)
  	 */
 -	if (attr->ptr_attr.len == 8)
 -		flags = attr->ptr_attr.data;
 -	else if (attr->ptr_attr.len == 4)
 -		flags = *(u32 *)&attr->ptr_attr.data;
 -	else
 -		return -EINVAL;
 -
 -	if (flags & ~allowed_bits)
 -		return -EINVAL;
 -
 -	*to = flags;
 -	return 0;
 -}
 -EXPORT_SYMBOL(uverbs_get_flags64);
 -
 -int uverbs_get_flags32(u32 *to, const struct uverbs_attr_bundle *attrs_bundle,
 -		       size_t idx, u64 allowed_bits)
 -{
 -	u64 flags;
 -	int ret;
 +	for (i = 0; i < method_spec->num_buckets; i++) {
 +		unsigned int curr_num_attrs;
  
 -	ret = uverbs_get_flags64(&flags, attrs_bundle, idx, allowed_bits);
 -	if (ret)
 -		return ret;
 +		if (!method_spec->attr_buckets[i])
 +			continue;
  
 -	if (flags > U32_MAX)
 -		return -EINVAL;
 -	*to = flags;
 +		curr_num_attrs = method_spec->attr_buckets[i]->num_attrs;
  
 -	return 0;
 -}
 -EXPORT_SYMBOL(uverbs_get_flags32);
 -
 -/*
 - * This is for ease of conversion. The purpose is to convert all drivers to
 - * use uverbs_attr_bundle instead of ib_udata.  Assume attr == 0 is input and
 - * attr == 1 is output.
 - */
 -void create_udata(struct uverbs_attr_bundle *bundle, struct ib_udata *udata)
 -{
 -	struct bundle_priv *pbundle =
 -		container_of(bundle, struct bundle_priv, bundle);
 -	const struct uverbs_attr *uhw_in =
 -		uverbs_attr_get(bundle, UVERBS_ATTR_UHW_IN);
 -	const struct uverbs_attr *uhw_out =
 -		uverbs_attr_get(bundle, UVERBS_ATTR_UHW_OUT);
 -
 -	if (!IS_ERR(uhw_in)) {
 -		udata->inlen = uhw_in->ptr_attr.len;
 -		if (uverbs_attr_ptr_is_inline(uhw_in))
 -			udata->inbuf =
 -				&pbundle->user_attrs[uhw_in->ptr_attr.uattr_idx]
 -					 .data;
 -		else
 -			udata->inbuf = u64_to_user_ptr(uhw_in->ptr_attr.data);
 +		ctx->uverbs_attr_bundle->hash[i].attrs = curr_attr;
 +		curr_attr += curr_num_attrs;
 +		ctx->uverbs_attr_bundle->hash[i].num_attrs = curr_num_attrs;
 +		ctx->uverbs_attr_bundle->hash[i].valid_bitmap = curr_bitmap;
 +		bitmap_zero(curr_bitmap, curr_num_attrs);
 +		curr_bitmap += BITS_TO_LONGS(curr_num_attrs);
++=======
++		ret = handler(&pbundle->bundle);
++		uobj_put_destroy(destroy_attr->uobject);
+ 	} else {
 -		udata->inbuf = NULL;
 -		udata->inlen = 0;
++		ret = handler(&pbundle->bundle);
++>>>>>>> 15a1b4becba8 (RDMA/uverbs: Do not pass ib_uverbs_file to ioctl methods)
  	}
  
 -	if (!IS_ERR(uhw_out)) {
 -		udata->outbuf = u64_to_user_ptr(uhw_out->ptr_attr.data);
 -		udata->outlen = uhw_out->ptr_attr.len;
 -	} else {
 -		udata->outbuf = NULL;
 -		udata->outlen = 0;
 +	err = copy_from_user(ctx->uattrs, buf,
 +			     sizeof(*ctx->uattrs) * hdr->num_attrs);
 +	if (err) {
 +		err = -EFAULT;
 +		goto out;
  	}
 -}
  
 -int uverbs_copy_to(const struct uverbs_attr_bundle *bundle, size_t idx,
 -		   const void *from, size_t size)
 -{
 -	struct bundle_priv *pbundle =
 -		container_of(bundle, struct bundle_priv, bundle);
 -	const struct uverbs_attr *attr = uverbs_attr_get(bundle, idx);
 -	u16 flags;
 -	size_t min_size;
 +	err = uverbs_handle_method(buf, ctx->uattrs, hdr->num_attrs, ib_dev,
 +				   file, method_spec, ctx->uverbs_attr_bundle);
 +
 +	/*
 +	 * EPROTONOSUPPORT is ONLY to be returned if the ioctl framework can
 +	 * not invoke the method because the request is not supported.  No
 +	 * other cases should return this code.
 +	*/
 +	if (unlikely(err == -EPROTONOSUPPORT)) {
 +		WARN_ON_ONCE(err == -EPROTONOSUPPORT);
 +		err = -EINVAL;
 +	}
 +out:
 +	if (ctx != (void *)data)
 +		kfree(ctx);
 +	return err;
 +}
  
 -	if (IS_ERR(attr))
 -		return PTR_ERR(attr);
 +#define IB_UVERBS_MAX_CMD_SZ 4096
  
 -	min_size = min_t(size_t, attr->ptr_attr.len, size);
 -	if (copy_to_user(u64_to_user_ptr(attr->ptr_attr.data), from, min_size))
 -		return -EFAULT;
 +long ib_uverbs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 +{
 +	struct ib_uverbs_file *file = filp->private_data;
 +	struct ib_uverbs_ioctl_hdr __user *user_hdr =
 +		(struct ib_uverbs_ioctl_hdr __user *)arg;
 +	struct ib_uverbs_ioctl_hdr hdr;
 +	struct ib_device *ib_dev;
 +	int srcu_key;
 +	long err;
  
 -	flags = pbundle->uattrs[attr->ptr_attr.uattr_idx].flags |
 -		UVERBS_ATTR_F_VALID_OUTPUT;
 -	if (put_user(flags,
 -		     &pbundle->user_attrs[attr->ptr_attr.uattr_idx].flags))
 -		return -EFAULT;
 +	srcu_key = srcu_read_lock(&file->device->disassociate_srcu);
 +	ib_dev = srcu_dereference(file->device->ib_dev,
 +				  &file->device->disassociate_srcu);
 +	if (!ib_dev) {
 +		err = -EIO;
 +		goto out;
 +	}
  
 -	return 0;
 -}
 -EXPORT_SYMBOL(uverbs_copy_to);
 +	if (cmd == RDMA_VERBS_IOCTL) {
 +		err = copy_from_user(&hdr, user_hdr, sizeof(hdr));
  
 -int _uverbs_get_const(s64 *to, const struct uverbs_attr_bundle *attrs_bundle,
 -		      size_t idx, s64 lower_bound, u64 upper_bound,
 -		      s64  *def_val)
 -{
 -	const struct uverbs_attr *attr;
 +		if (err || hdr.length > IB_UVERBS_MAX_CMD_SZ ||
 +		    hdr.length != sizeof(hdr) + hdr.num_attrs * sizeof(struct ib_uverbs_attr)) {
 +			err = -EINVAL;
 +			goto out;
 +		}
  
 -	attr = uverbs_attr_get(attrs_bundle, idx);
 -	if (IS_ERR(attr)) {
 -		if ((PTR_ERR(attr) != -ENOENT) || !def_val)
 -			return PTR_ERR(attr);
 +		if (hdr.reserved1 || hdr.reserved2) {
 +			err = -EPROTONOSUPPORT;
 +			goto out;
 +		}
  
 -		*to = *def_val;
 +		err = ib_uverbs_cmd_verbs(ib_dev, file, &hdr,
 +					  (__user void *)arg + sizeof(hdr));
  	} else {
 -		*to = attr->ptr_attr.data;
 +		err = -ENOIOCTLCMD;
  	}
 +out:
 +	srcu_read_unlock(&file->device->disassociate_srcu, srcu_key);
  
 -	if (*to < lower_bound || (*to > 0 && (u64)*to > upper_bound))
 -		return -EINVAL;
 -
 -	return 0;
 +	return err;
  }
 -EXPORT_SYMBOL(_uverbs_get_const);
diff --cc drivers/infiniband/core/uverbs_std_types.c
index 06085446ffc0,063aff9e7a04..000000000000
--- a/drivers/infiniband/core/uverbs_std_types.c
+++ b/drivers/infiniband/core/uverbs_std_types.c
@@@ -198,9 -210,7 +198,13 @@@ static int uverbs_hot_unplug_completion
  	return 0;
  };
  
++<<<<<<< HEAD
 +int uverbs_destroy_def_handler(struct ib_device *ib_dev,
 +			       struct ib_uverbs_file *file,
 +			       struct uverbs_attr_bundle *attrs)
++=======
+ int uverbs_destroy_def_handler(struct uverbs_attr_bundle *attrs)
++>>>>>>> 15a1b4becba8 (RDMA/uverbs: Do not pass ib_uverbs_file to ioctl methods)
  {
  	return 0;
  }
diff --cc drivers/infiniband/core/uverbs_std_types_counters.c
index 03b182a684a6,8835bad5c6dd..000000000000
--- a/drivers/infiniband/core/uverbs_std_types_counters.c
+++ b/drivers/infiniband/core/uverbs_std_types_counters.c
@@@ -46,12 -47,13 +46,17 @@@ static int uverbs_free_counters(struct 
  	return counters->device->destroy_counters(counters);
  }
  
++<<<<<<< HEAD
 +static int UVERBS_HANDLER(UVERBS_METHOD_COUNTERS_CREATE)(struct ib_device *ib_dev,
 +							 struct ib_uverbs_file *file,
 +							 struct uverbs_attr_bundle *attrs)
++=======
+ static int UVERBS_HANDLER(UVERBS_METHOD_COUNTERS_CREATE)(
+ 	struct uverbs_attr_bundle *attrs)
++>>>>>>> 15a1b4becba8 (RDMA/uverbs: Do not pass ib_uverbs_file to ioctl methods)
  {
 -	struct ib_uobject *uobj = uverbs_attr_get_uobject(
 -		attrs, UVERBS_ATTR_CREATE_COUNTERS_HANDLE);
 -	struct ib_device *ib_dev = uobj->context->device;
  	struct ib_counters *counters;
 +	struct ib_uobject *uobj;
  	int ret;
  
  	/*
@@@ -80,9 -81,8 +85,14 @@@ err_create_counters
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int UVERBS_HANDLER(UVERBS_METHOD_COUNTERS_READ)(struct ib_device *ib_dev,
 +						       struct ib_uverbs_file *file,
 +						       struct uverbs_attr_bundle *attrs)
++=======
+ static int UVERBS_HANDLER(UVERBS_METHOD_COUNTERS_READ)(
+ 	struct uverbs_attr_bundle *attrs)
++>>>>>>> 15a1b4becba8 (RDMA/uverbs: Do not pass ib_uverbs_file to ioctl methods)
  {
  	struct ib_counters_read_attr read_attr = {};
  	const struct uverbs_attr *uattr;
diff --cc drivers/infiniband/core/uverbs_std_types_cq.c
index 150b7c04ce15,859d1e862034..000000000000
--- a/drivers/infiniband/core/uverbs_std_types_cq.c
+++ b/drivers/infiniband/core/uverbs_std_types_cq.c
@@@ -53,11 -57,13 +53,16 @@@ static int uverbs_free_cq(struct ib_uob
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int UVERBS_HANDLER(UVERBS_METHOD_CQ_CREATE)(struct ib_device *ib_dev,
 +						   struct ib_uverbs_file *file,
 +						   struct uverbs_attr_bundle *attrs)
++=======
+ static int UVERBS_HANDLER(UVERBS_METHOD_CQ_CREATE)(
+ 	struct uverbs_attr_bundle *attrs)
++>>>>>>> 15a1b4becba8 (RDMA/uverbs: Do not pass ib_uverbs_file to ioctl methods)
  {
 -	struct ib_ucq_object *obj = container_of(
 -		uverbs_attr_get_uobject(attrs, UVERBS_ATTR_CREATE_CQ_HANDLE),
 -		typeof(*obj), uobject);
 -	struct ib_device *ib_dev = obj->uobject.context->device;
 +	struct ib_ucq_object           *obj;
  	struct ib_udata uhw;
  	int ret;
  	u64 user_handle;
@@@ -141,29 -146,34 +146,34 @@@ err_event_file
  	return ret;
  };
  
 -DECLARE_UVERBS_NAMED_METHOD(
 -	UVERBS_METHOD_CQ_CREATE,
 -	UVERBS_ATTR_IDR(UVERBS_ATTR_CREATE_CQ_HANDLE,
 -			UVERBS_OBJECT_CQ,
 -			UVERBS_ACCESS_NEW,
 -			UA_MANDATORY),
 -	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_CQE,
 -			   UVERBS_ATTR_TYPE(u32),
 -			   UA_MANDATORY),
 -	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_USER_HANDLE,
 -			   UVERBS_ATTR_TYPE(u64),
 -			   UA_MANDATORY),
 -	UVERBS_ATTR_FD(UVERBS_ATTR_CREATE_CQ_COMP_CHANNEL,
 -		       UVERBS_OBJECT_COMP_CHANNEL,
 -		       UVERBS_ACCESS_READ,
 -		       UA_OPTIONAL),
 -	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_COMP_VECTOR,
 -			   UVERBS_ATTR_TYPE(u32),
 -			   UA_MANDATORY),
 -	UVERBS_ATTR_FLAGS_IN(UVERBS_ATTR_CREATE_CQ_FLAGS,
 -			     enum ib_uverbs_ex_create_cq_flags),
 -	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_CREATE_CQ_RESP_CQE,
 +static DECLARE_UVERBS_NAMED_METHOD(UVERBS_METHOD_CQ_CREATE,
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_CREATE_CQ_HANDLE, UVERBS_OBJECT_CQ,
 +			 UVERBS_ACCESS_NEW,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_CQE,
  			    UVERBS_ATTR_TYPE(u32),
 -			    UA_MANDATORY),
 -	UVERBS_ATTR_UHW());
 -
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_USER_HANDLE,
 +			    UVERBS_ATTR_TYPE(u64),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_FD(UVERBS_ATTR_CREATE_CQ_COMP_CHANNEL,
 +			UVERBS_OBJECT_COMP_CHANNEL,
 +			UVERBS_ACCESS_READ),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_COMP_VECTOR, UVERBS_ATTR_TYPE(u32),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_FLAGS, UVERBS_ATTR_TYPE(u32)),
 +	&UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_CREATE_CQ_RESP_CQE, UVERBS_ATTR_TYPE(u32),
 +			     UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&uverbs_uhw_compat_in, &uverbs_uhw_compat_out);
 +
++<<<<<<< HEAD
 +static int UVERBS_HANDLER(UVERBS_METHOD_CQ_DESTROY)(struct ib_device *ib_dev,
 +						    struct ib_uverbs_file *file,
 +						    struct uverbs_attr_bundle *attrs)
++=======
+ static int UVERBS_HANDLER(UVERBS_METHOD_CQ_DESTROY)(
+ 	struct uverbs_attr_bundle *attrs)
++>>>>>>> 15a1b4becba8 (RDMA/uverbs: Do not pass ib_uverbs_file to ioctl methods)
  {
  	struct ib_uobject *uobj =
  		uverbs_attr_get_uobject(attrs, UVERBS_ATTR_DESTROY_CQ_HANDLE);
diff --cc drivers/infiniband/core/uverbs_std_types_dm.c
index b11344264f4e,658261b8f08e..000000000000
--- a/drivers/infiniband/core/uverbs_std_types_dm.c
+++ b/drivers/infiniband/core/uverbs_std_types_dm.c
@@@ -44,12 -46,14 +44,17 @@@ static int uverbs_free_dm(struct ib_uob
  	return dm->device->dealloc_dm(dm);
  }
  
++<<<<<<< HEAD
 +static int UVERBS_HANDLER(UVERBS_METHOD_DM_ALLOC)(struct ib_device *ib_dev,
 +						  struct ib_uverbs_file *file,
 +						  struct uverbs_attr_bundle *attrs)
++=======
+ static int UVERBS_HANDLER(UVERBS_METHOD_DM_ALLOC)(
+ 	struct uverbs_attr_bundle *attrs)
++>>>>>>> 15a1b4becba8 (RDMA/uverbs: Do not pass ib_uverbs_file to ioctl methods)
  {
  	struct ib_dm_alloc_attr attr = {};
 -	struct ib_uobject *uobj =
 -		uverbs_attr_get(attrs, UVERBS_ATTR_ALLOC_DM_HANDLE)
 -			->obj_attr.uobject;
 -	struct ib_device *ib_dev = uobj->context->device;
 +	struct ib_uobject *uobj;
  	struct ib_dm *dm;
  	int ret;
  
diff --cc drivers/infiniband/core/uverbs_std_types_flow_action.c
index e3d282cb7bf2,e4d01fb5335d..000000000000
--- a/drivers/infiniband/core/uverbs_std_types_flow_action.c
+++ b/drivers/infiniband/core/uverbs_std_types_flow_action.c
@@@ -303,12 -303,13 +302,17 @@@ static int parse_flow_action_esp(struc
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int UVERBS_HANDLER(UVERBS_METHOD_FLOW_ACTION_ESP_CREATE)(struct ib_device *ib_dev,
 +								struct ib_uverbs_file *file,
 +								struct uverbs_attr_bundle *attrs)
++=======
+ static int UVERBS_HANDLER(UVERBS_METHOD_FLOW_ACTION_ESP_CREATE)(
+ 	struct uverbs_attr_bundle *attrs)
++>>>>>>> 15a1b4becba8 (RDMA/uverbs: Do not pass ib_uverbs_file to ioctl methods)
  {
 -	struct ib_uobject *uobj = uverbs_attr_get_uobject(
 -		attrs, UVERBS_ATTR_CREATE_FLOW_ACTION_ESP_HANDLE);
 -	struct ib_device *ib_dev = uobj->context->device;
  	int				  ret;
 +	struct ib_uobject		  *uobj;
  	struct ib_flow_action		  *action;
  	struct ib_flow_action_esp_attr	  esp_attr = {};
  
@@@ -335,19 -331,19 +339,28 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int UVERBS_HANDLER(UVERBS_METHOD_FLOW_ACTION_ESP_MODIFY)(struct ib_device *ib_dev,
 +								struct ib_uverbs_file *file,
 +								struct uverbs_attr_bundle *attrs)
++=======
+ static int UVERBS_HANDLER(UVERBS_METHOD_FLOW_ACTION_ESP_MODIFY)(
+ 	struct uverbs_attr_bundle *attrs)
++>>>>>>> 15a1b4becba8 (RDMA/uverbs: Do not pass ib_uverbs_file to ioctl methods)
  {
 -	struct ib_uobject *uobj = uverbs_attr_get_uobject(
 -		attrs, UVERBS_ATTR_MODIFY_FLOW_ACTION_ESP_HANDLE);
 -	struct ib_flow_action *action = uobj->object;
  	int				  ret;
 +	struct ib_uobject		  *uobj;
 +	struct ib_flow_action		  *action;
  	struct ib_flow_action_esp_attr	  esp_attr = {};
  
 -	if (!action->device->modify_flow_action_esp)
 +	if (!ib_dev->modify_flow_action_esp)
  		return -EOPNOTSUPP;
  
++<<<<<<< HEAD
 +	ret = parse_flow_action_esp(ib_dev, file, attrs, &esp_attr, true);
++=======
+ 	ret = parse_flow_action_esp(action->device, attrs, &esp_attr, true);
++>>>>>>> 15a1b4becba8 (RDMA/uverbs: Do not pass ib_uverbs_file to ioctl methods)
  	if (ret)
  		return ret;
  
diff --cc drivers/infiniband/core/uverbs_std_types_mr.c
index 68f7cadf088f,70ea48cfc047..000000000000
--- a/drivers/infiniband/core/uverbs_std_types_mr.c
+++ b/drivers/infiniband/core/uverbs_std_types_mr.c
@@@ -39,14 -39,18 +39,19 @@@ static int uverbs_free_mr(struct ib_uob
  	return ib_dereg_mr((struct ib_mr *)uobject->object);
  }
  
++<<<<<<< HEAD
 +static int UVERBS_HANDLER(UVERBS_METHOD_DM_MR_REG)(struct ib_device *ib_dev,
 +						   struct ib_uverbs_file *file,
 +						   struct uverbs_attr_bundle *attrs)
++=======
+ static int UVERBS_HANDLER(UVERBS_METHOD_DM_MR_REG)(
+ 	struct uverbs_attr_bundle *attrs)
++>>>>>>> 15a1b4becba8 (RDMA/uverbs: Do not pass ib_uverbs_file to ioctl methods)
  {
  	struct ib_dm_mr_attr attr = {};
 -	struct ib_uobject *uobj =
 -		uverbs_attr_get_uobject(attrs, UVERBS_ATTR_REG_DM_MR_HANDLE);
 -	struct ib_dm *dm =
 -		uverbs_attr_get_obj(attrs, UVERBS_ATTR_REG_DM_MR_DM_HANDLE);
 -	struct ib_pd *pd =
 -		uverbs_attr_get_obj(attrs, UVERBS_ATTR_REG_DM_MR_PD_HANDLE);
 -	struct ib_device *ib_dev = pd->device;
 -
 +	struct ib_uobject *uobj;
 +	struct ib_dm *dm;
 +	struct ib_pd *pd;
  	struct ib_mr *mr;
  	int ret;
  
diff --cc include/rdma/ib_verbs.h
index b27ceb4ca59e,92633c15125b..000000000000
--- a/include/rdma/ib_verbs.h
+++ b/include/rdma/ib_verbs.h
@@@ -4147,6 -4207,11 +4147,14 @@@ ib_get_vector_affinity(struct ib_devic
   */
  void rdma_roce_rescan_device(struct ib_device *ibdev);
  
++<<<<<<< HEAD
++=======
+ struct ib_ucontext *ib_uverbs_get_ucontext_file(struct ib_uverbs_file *ufile);
+ 
+ 
+ int uverbs_destroy_def_handler(struct uverbs_attr_bundle *attrs);
+ 
++>>>>>>> 15a1b4becba8 (RDMA/uverbs: Do not pass ib_uverbs_file to ioctl methods)
  struct net_device *rdma_alloc_netdev(struct ib_device *device, u8 port_num,
  				     enum rdma_netdev_t type, const char *name,
  				     unsigned char name_assign_type,
diff --cc include/rdma/uverbs_ioctl.h
index 90a4947ff548,e0b1a77b1c2c..000000000000
--- a/include/rdma/uverbs_ioctl.h
+++ b/include/rdma/uverbs_ioctl.h
@@@ -180,8 -327,7 +180,12 @@@ struct uverbs_method_def 
  	u32				     flags;
  	size_t				     num_attrs;
  	const struct uverbs_attr_def * const (*attrs)[];
++<<<<<<< HEAD
 +	int (*handler)(struct ib_device *ib_dev, struct ib_uverbs_file *ufile,
 +		       struct uverbs_attr_bundle *ctx);
++=======
+ 	int (*handler)(struct uverbs_attr_bundle *attrs);
++>>>>>>> 15a1b4becba8 (RDMA/uverbs: Do not pass ib_uverbs_file to ioctl methods)
  };
  
  struct uverbs_object_def {
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
* Unmerged path drivers/infiniband/hw/mlx5/flow.c
* Unmerged path drivers/infiniband/core/rdma_core.h
* Unmerged path drivers/infiniband/core/uverbs_ioctl.c
* Unmerged path drivers/infiniband/core/uverbs_std_types.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_counters.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_cq.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_dm.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_flow_action.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_mr.c
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
* Unmerged path drivers/infiniband/hw/mlx5/flow.c
* Unmerged path include/rdma/ib_verbs.h
* Unmerged path include/rdma/uverbs_ioctl.h
