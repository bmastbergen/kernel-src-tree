drm/i915: Make sure cursor has enough ddb for the selected wm level

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit 10a7e07b68b9ecf9251f78043fb7b342bf9b04e8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/10a7e07b.failed

We use a fixed ddb allocation for the cursor. Now the calculation
actually makes sure we have enough ddb space, but let's double check
anyway.

	Cc: Neel Desai <neel.desai@intel.com>
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190312205844.6339-6-ville.syrjala@linux.intel.com
	Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
(cherry picked from commit 10a7e07b68b9ecf9251f78043fb7b342bf9b04e8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_pm.c
diff --cc drivers/gpu/drm/i915/intel_pm.c
index a1b763e0c3a9,d54b70db3f20..000000000000
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@@ -4317,23 -4384,48 +4317,48 @@@ skl_allocate_pipe_ddb(struct intel_crtc
  	if (alloc_size == 0)
  		return 0;
  
 -	/* Allocate fixed number of blocks for cursor. */
 -	total[PLANE_CURSOR] = skl_cursor_allocation(cstate, num_active);
 -	alloc_size -= total[PLANE_CURSOR];
 -	cstate->wm.skl.plane_ddb_y[PLANE_CURSOR].start =
 -		alloc->end - total[PLANE_CURSOR];
 -	cstate->wm.skl.plane_ddb_y[PLANE_CURSOR].end = alloc->end;
 -
 -	if (total_data_rate == 0)
 -		return 0;
 +	skl_ddb_calc_min(cstate, num_active, minimum, uv_minimum);
  
  	/*
 -	 * Find the highest watermark level for which we can satisfy the block
 -	 * requirement of active planes.
 +	 * 1. Allocate the mininum required blocks for each active plane
 +	 * and allocate the cursor, it doesn't require extra allocation
 +	 * proportional to the data rate.
  	 */
++<<<<<<< HEAD
 +
 +	for_each_plane_id_on_crtc(intel_crtc, plane_id) {
 +		total_min_blocks += minimum[plane_id];
 +		total_min_blocks += uv_minimum[plane_id];
++=======
+ 	for (level = ilk_wm_max_level(dev_priv); level >= 0; level--) {
+ 		blocks = 0;
+ 		for_each_plane_id_on_crtc(intel_crtc, plane_id) {
+ 			wm = &cstate->wm.skl.optimal.planes[plane_id];
+ 
+ 			if (plane_id == PLANE_CURSOR) {
+ 				if (WARN_ON(wm->wm[level].min_ddb_alloc >
+ 					    total[PLANE_CURSOR])) {
+ 					blocks = U32_MAX;
+ 					break;
+ 				}
+ 				continue;
+ 			}
+ 
+ 			blocks += wm->wm[level].min_ddb_alloc;
+ 			blocks += wm->uv_wm[level].min_ddb_alloc;
+ 		}
+ 
+ 		if (blocks <= alloc_size) {
+ 			alloc_size -= blocks;
+ 			break;
+ 		}
++>>>>>>> 10a7e07b68b9 (drm/i915: Make sure cursor has enough ddb for the selected wm level)
  	}
  
 -	if (level < 0) {
 +	if (total_min_blocks > alloc_size) {
  		DRM_DEBUG_KMS("Requested display configuration exceeds system DDB limitations");
 -		DRM_DEBUG_KMS("minimum required %d/%d\n", blocks,
 -			      alloc_size);
 +		DRM_DEBUG_KMS("minimum required %d/%d\n", total_min_blocks,
 +							alloc_size);
  		return -EINVAL;
  	}
  
* Unmerged path drivers/gpu/drm/i915/intel_pm.c
