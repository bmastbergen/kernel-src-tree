switchdev: Add extack argument to call_switchdev_notifiers()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Petr Machata <petrm@mellanox.com>
commit 6685987c29582afc79b7fa3998dfbf36b4295791
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/6685987c.failed

A follow-up patch will enable vetoing of FDB entries. Make it possible
to communicate details of why an FDB entry is not acceptable back to the
user.

	Signed-off-by: Petr Machata <petrm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6685987c29582afc79b7fa3998dfbf36b4295791)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
#	drivers/net/vxlan.c
#	net/switchdev/switchdev.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index cb43d17097fa,042341c7f6b9..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -6876,11 -7257,45 +6876,46 @@@ static void mlxsw_sp_rif_vlan_deconfigu
  }
  
  static struct mlxsw_sp_fid *
 -mlxsw_sp_rif_vlan_fid_get(struct mlxsw_sp_rif *rif,
 -			  struct netlink_ext_ack *extack)
 +mlxsw_sp_rif_vlan_fid_get(struct mlxsw_sp_rif *rif)
  {
 -	struct net_device *br_dev = rif->dev;
 -	u16 vid;
 -	int err;
 +	u16 vid = is_vlan_dev(rif->dev) ? vlan_dev_vlan_id(rif->dev) : 1;
  
++<<<<<<< HEAD
 +	return mlxsw_sp_fid_8021q_get(rif->mlxsw_sp, vid);
++=======
+ 	if (is_vlan_dev(rif->dev)) {
+ 		vid = vlan_dev_vlan_id(rif->dev);
+ 		br_dev = vlan_dev_real_dev(rif->dev);
+ 		if (WARN_ON(!netif_is_bridge_master(br_dev)))
+ 			return ERR_PTR(-EINVAL);
+ 	} else {
+ 		err = br_vlan_get_pvid(rif->dev, &vid);
+ 		if (err < 0 || !vid) {
+ 			NL_SET_ERR_MSG_MOD(extack, "Couldn't determine bridge PVID");
+ 			return ERR_PTR(-EINVAL);
+ 		}
+ 	}
+ 
+ 	return mlxsw_sp_bridge_fid_get(rif->mlxsw_sp, br_dev, vid, extack);
+ }
+ 
+ static void mlxsw_sp_rif_vlan_fdb_del(struct mlxsw_sp_rif *rif, const char *mac)
+ {
+ 	u16 vid = mlxsw_sp_fid_8021q_vid(rif->fid);
+ 	struct switchdev_notifier_fdb_info info;
+ 	struct net_device *br_dev;
+ 	struct net_device *dev;
+ 
+ 	br_dev = is_vlan_dev(rif->dev) ? vlan_dev_real_dev(rif->dev) : rif->dev;
+ 	dev = br_fdb_find_port(br_dev, mac, vid);
+ 	if (!dev)
+ 		return;
+ 
+ 	info.addr = mac;
+ 	info.vid = vid;
+ 	call_switchdev_notifiers(SWITCHDEV_FDB_DEL_TO_BRIDGE, dev, &info.info,
+ 				 NULL);
++>>>>>>> 6685987c2958 (switchdev: Add extack argument to call_switchdev_notifiers())
  }
  
  static const struct mlxsw_sp_rif_ops mlxsw_sp_rif_vlan_ops = {
@@@ -6948,9 -7365,25 +6983,28 @@@ static void mlxsw_sp_rif_fid_deconfigur
  }
  
  static struct mlxsw_sp_fid *
 -mlxsw_sp_rif_fid_fid_get(struct mlxsw_sp_rif *rif,
 -			 struct netlink_ext_ack *extack)
 +mlxsw_sp_rif_fid_fid_get(struct mlxsw_sp_rif *rif)
  {
++<<<<<<< HEAD
 +	return mlxsw_sp_fid_8021d_get(rif->mlxsw_sp, rif->dev->ifindex);
++=======
+ 	return mlxsw_sp_bridge_fid_get(rif->mlxsw_sp, rif->dev, 0, extack);
+ }
+ 
+ static void mlxsw_sp_rif_fid_fdb_del(struct mlxsw_sp_rif *rif, const char *mac)
+ {
+ 	struct switchdev_notifier_fdb_info info;
+ 	struct net_device *dev;
+ 
+ 	dev = br_fdb_find_port(rif->dev, mac, 0);
+ 	if (!dev)
+ 		return;
+ 
+ 	info.addr = mac;
+ 	info.vid = 0;
+ 	call_switchdev_notifiers(SWITCHDEV_FDB_DEL_TO_BRIDGE, dev, &info.info,
+ 				 NULL);
++>>>>>>> 6685987c2958 (switchdev: Add extack argument to call_switchdev_notifiers())
  }
  
  static const struct mlxsw_sp_rif_ops mlxsw_sp_rif_fid_ops = {
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
index a5639e7f2685,71aad9d4e160..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
@@@ -2079,6 -2349,115 +2079,118 @@@ void mlxsw_sp_port_bridge_leave(struct 
  	mlxsw_sp_bridge_port_put(mlxsw_sp->bridge, bridge_port);
  }
  
++<<<<<<< HEAD
++=======
+ int mlxsw_sp_bridge_vxlan_join(struct mlxsw_sp *mlxsw_sp,
+ 			       const struct net_device *br_dev,
+ 			       const struct net_device *vxlan_dev, u16 vid,
+ 			       struct netlink_ext_ack *extack)
+ {
+ 	struct mlxsw_sp_bridge_device *bridge_device;
+ 
+ 	bridge_device = mlxsw_sp_bridge_device_find(mlxsw_sp->bridge, br_dev);
+ 	if (WARN_ON(!bridge_device))
+ 		return -EINVAL;
+ 
+ 	return bridge_device->ops->vxlan_join(bridge_device, vxlan_dev, vid,
+ 					      extack);
+ }
+ 
+ void mlxsw_sp_bridge_vxlan_leave(struct mlxsw_sp *mlxsw_sp,
+ 				 const struct net_device *vxlan_dev)
+ {
+ 	struct vxlan_dev *vxlan = netdev_priv(vxlan_dev);
+ 	struct mlxsw_sp_fid *fid;
+ 
+ 	/* If the VxLAN device is down, then the FID does not have a VNI */
+ 	fid = mlxsw_sp_fid_lookup_by_vni(mlxsw_sp, vxlan->cfg.vni);
+ 	if (!fid)
+ 		return;
+ 
+ 	mlxsw_sp_nve_fid_disable(mlxsw_sp, fid);
+ 	mlxsw_sp_fid_put(fid);
+ }
+ 
+ struct mlxsw_sp_fid *mlxsw_sp_bridge_fid_get(struct mlxsw_sp *mlxsw_sp,
+ 					     const struct net_device *br_dev,
+ 					     u16 vid,
+ 					     struct netlink_ext_ack *extack)
+ {
+ 	struct mlxsw_sp_bridge_device *bridge_device;
+ 
+ 	bridge_device = mlxsw_sp_bridge_device_find(mlxsw_sp->bridge, br_dev);
+ 	if (WARN_ON(!bridge_device))
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	return bridge_device->ops->fid_get(bridge_device, vid, extack);
+ }
+ 
+ static void
+ mlxsw_sp_switchdev_vxlan_addr_convert(const union vxlan_addr *vxlan_addr,
+ 				      enum mlxsw_sp_l3proto *proto,
+ 				      union mlxsw_sp_l3addr *addr)
+ {
+ 	if (vxlan_addr->sa.sa_family == AF_INET) {
+ 		addr->addr4 = vxlan_addr->sin.sin_addr.s_addr;
+ 		*proto = MLXSW_SP_L3_PROTO_IPV4;
+ 	} else {
+ 		addr->addr6 = vxlan_addr->sin6.sin6_addr;
+ 		*proto = MLXSW_SP_L3_PROTO_IPV6;
+ 	}
+ }
+ 
+ static void
+ mlxsw_sp_switchdev_addr_vxlan_convert(enum mlxsw_sp_l3proto proto,
+ 				      const union mlxsw_sp_l3addr *addr,
+ 				      union vxlan_addr *vxlan_addr)
+ {
+ 	switch (proto) {
+ 	case MLXSW_SP_L3_PROTO_IPV4:
+ 		vxlan_addr->sa.sa_family = AF_INET;
+ 		vxlan_addr->sin.sin_addr.s_addr = addr->addr4;
+ 		break;
+ 	case MLXSW_SP_L3_PROTO_IPV6:
+ 		vxlan_addr->sa.sa_family = AF_INET6;
+ 		vxlan_addr->sin6.sin6_addr = addr->addr6;
+ 		break;
+ 	}
+ }
+ 
+ static void mlxsw_sp_fdb_vxlan_call_notifiers(struct net_device *dev,
+ 					      const char *mac,
+ 					      enum mlxsw_sp_l3proto proto,
+ 					      union mlxsw_sp_l3addr *addr,
+ 					      __be32 vni, bool adding)
+ {
+ 	struct switchdev_notifier_vxlan_fdb_info info;
+ 	struct vxlan_dev *vxlan = netdev_priv(dev);
+ 	enum switchdev_notifier_type type;
+ 
+ 	type = adding ? SWITCHDEV_VXLAN_FDB_ADD_TO_BRIDGE :
+ 			SWITCHDEV_VXLAN_FDB_DEL_TO_BRIDGE;
+ 	mlxsw_sp_switchdev_addr_vxlan_convert(proto, addr, &info.remote_ip);
+ 	info.remote_port = vxlan->cfg.dst_port;
+ 	info.remote_vni = vni;
+ 	info.remote_ifindex = 0;
+ 	ether_addr_copy(info.eth_addr, mac);
+ 	info.vni = vni;
+ 	info.offloaded = adding;
+ 	call_switchdev_notifiers(type, dev, &info.info, NULL);
+ }
+ 
+ static void mlxsw_sp_fdb_nve_call_notifiers(struct net_device *dev,
+ 					    const char *mac,
+ 					    enum mlxsw_sp_l3proto proto,
+ 					    union mlxsw_sp_l3addr *addr,
+ 					    __be32 vni,
+ 					    bool adding)
+ {
+ 	if (netif_is_vxlan(dev))
+ 		mlxsw_sp_fdb_vxlan_call_notifiers(dev, mac, proto, addr, vni,
+ 						  adding);
+ }
+ 
++>>>>>>> 6685987c2958 (switchdev: Add extack argument to call_switchdev_notifiers())
  static void
  mlxsw_sp_fdb_call_notifiers(enum switchdev_notifier_type type,
  			    const char *mac, u16 vid,
@@@ -2281,7 -2788,106 +2393,110 @@@ struct mlxsw_sp_switchdev_event_work 
  	unsigned long event;
  };
  
++<<<<<<< HEAD
 +static void mlxsw_sp_switchdev_event_work(struct work_struct *work)
++=======
+ static void
+ mlxsw_sp_switchdev_bridge_vxlan_fdb_event(struct mlxsw_sp *mlxsw_sp,
+ 					  struct mlxsw_sp_switchdev_event_work *
+ 					  switchdev_work,
+ 					  struct mlxsw_sp_fid *fid, __be32 vni)
+ {
+ 	struct switchdev_notifier_vxlan_fdb_info vxlan_fdb_info;
+ 	struct switchdev_notifier_fdb_info *fdb_info;
+ 	struct net_device *dev = switchdev_work->dev;
+ 	enum mlxsw_sp_l3proto proto;
+ 	union mlxsw_sp_l3addr addr;
+ 	int err;
+ 
+ 	fdb_info = &switchdev_work->fdb_info;
+ 	err = vxlan_fdb_find_uc(dev, fdb_info->addr, vni, &vxlan_fdb_info);
+ 	if (err)
+ 		return;
+ 
+ 	mlxsw_sp_switchdev_vxlan_addr_convert(&vxlan_fdb_info.remote_ip,
+ 					      &proto, &addr);
+ 
+ 	switch (switchdev_work->event) {
+ 	case SWITCHDEV_FDB_ADD_TO_DEVICE:
+ 		err = mlxsw_sp_port_fdb_tunnel_uc_op(mlxsw_sp,
+ 						     vxlan_fdb_info.eth_addr,
+ 						     mlxsw_sp_fid_index(fid),
+ 						     proto, &addr, true, false);
+ 		if (err)
+ 			return;
+ 		vxlan_fdb_info.offloaded = true;
+ 		call_switchdev_notifiers(SWITCHDEV_VXLAN_FDB_OFFLOADED, dev,
+ 					 &vxlan_fdb_info.info, NULL);
+ 		mlxsw_sp_fdb_call_notifiers(SWITCHDEV_FDB_OFFLOADED,
+ 					    vxlan_fdb_info.eth_addr,
+ 					    fdb_info->vid, dev, true);
+ 		break;
+ 	case SWITCHDEV_FDB_DEL_TO_DEVICE:
+ 		err = mlxsw_sp_port_fdb_tunnel_uc_op(mlxsw_sp,
+ 						     vxlan_fdb_info.eth_addr,
+ 						     mlxsw_sp_fid_index(fid),
+ 						     proto, &addr, false,
+ 						     false);
+ 		vxlan_fdb_info.offloaded = false;
+ 		call_switchdev_notifiers(SWITCHDEV_VXLAN_FDB_OFFLOADED, dev,
+ 					 &vxlan_fdb_info.info, NULL);
+ 		break;
+ 	}
+ }
+ 
+ static void
+ mlxsw_sp_switchdev_bridge_nve_fdb_event(struct mlxsw_sp_switchdev_event_work *
+ 					switchdev_work)
+ {
+ 	struct mlxsw_sp_bridge_device *bridge_device;
+ 	struct net_device *dev = switchdev_work->dev;
+ 	struct net_device *br_dev;
+ 	struct mlxsw_sp *mlxsw_sp;
+ 	struct mlxsw_sp_fid *fid;
+ 	__be32 vni;
+ 	int err;
+ 
+ 	if (switchdev_work->event != SWITCHDEV_FDB_ADD_TO_DEVICE &&
+ 	    switchdev_work->event != SWITCHDEV_FDB_DEL_TO_DEVICE)
+ 		return;
+ 
+ 	if (switchdev_work->event == SWITCHDEV_FDB_ADD_TO_DEVICE &&
+ 	    !switchdev_work->fdb_info.added_by_user)
+ 		return;
+ 
+ 	if (!netif_running(dev))
+ 		return;
+ 	br_dev = netdev_master_upper_dev_get(dev);
+ 	if (!br_dev)
+ 		return;
+ 	if (!netif_is_bridge_master(br_dev))
+ 		return;
+ 	mlxsw_sp = mlxsw_sp_lower_get(br_dev);
+ 	if (!mlxsw_sp)
+ 		return;
+ 	bridge_device = mlxsw_sp_bridge_device_find(mlxsw_sp->bridge, br_dev);
+ 	if (!bridge_device)
+ 		return;
+ 
+ 	fid = bridge_device->ops->fid_lookup(bridge_device,
+ 					     switchdev_work->fdb_info.vid);
+ 	if (!fid)
+ 		return;
+ 
+ 	err = mlxsw_sp_fid_vni(fid, &vni);
+ 	if (err)
+ 		goto out;
+ 
+ 	mlxsw_sp_switchdev_bridge_vxlan_fdb_event(mlxsw_sp, switchdev_work, fid,
+ 						  vni);
+ 
+ out:
+ 	mlxsw_sp_fid_put(fid);
+ }
+ 
+ static void mlxsw_sp_switchdev_bridge_fdb_event_work(struct work_struct *work)
++>>>>>>> 6685987c2958 (switchdev: Add extack argument to call_switchdev_notifiers())
  {
  	struct mlxsw_sp_switchdev_event_work *switchdev_work =
  		container_of(work, struct mlxsw_sp_switchdev_event_work, work);
@@@ -2330,6 -2939,189 +2545,192 @@@ out
  	dev_put(dev);
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ mlxsw_sp_switchdev_vxlan_fdb_add(struct mlxsw_sp *mlxsw_sp,
+ 				 struct mlxsw_sp_switchdev_event_work *
+ 				 switchdev_work)
+ {
+ 	struct switchdev_notifier_vxlan_fdb_info *vxlan_fdb_info;
+ 	struct mlxsw_sp_bridge_device *bridge_device;
+ 	struct net_device *dev = switchdev_work->dev;
+ 	u8 all_zeros_mac[ETH_ALEN] = { 0 };
+ 	enum mlxsw_sp_l3proto proto;
+ 	union mlxsw_sp_l3addr addr;
+ 	struct net_device *br_dev;
+ 	struct mlxsw_sp_fid *fid;
+ 	u16 vid;
+ 	int err;
+ 
+ 	vxlan_fdb_info = &switchdev_work->vxlan_fdb_info;
+ 	br_dev = netdev_master_upper_dev_get(dev);
+ 
+ 	bridge_device = mlxsw_sp_bridge_device_find(mlxsw_sp->bridge, br_dev);
+ 	if (!bridge_device)
+ 		return;
+ 
+ 	fid = mlxsw_sp_fid_lookup_by_vni(mlxsw_sp, vxlan_fdb_info->vni);
+ 	if (!fid)
+ 		return;
+ 
+ 	mlxsw_sp_switchdev_vxlan_addr_convert(&vxlan_fdb_info->remote_ip,
+ 					      &proto, &addr);
+ 
+ 	if (ether_addr_equal(vxlan_fdb_info->eth_addr, all_zeros_mac)) {
+ 		err = mlxsw_sp_nve_flood_ip_add(mlxsw_sp, fid, proto, &addr);
+ 		if (err) {
+ 			mlxsw_sp_fid_put(fid);
+ 			return;
+ 		}
+ 		vxlan_fdb_info->offloaded = true;
+ 		call_switchdev_notifiers(SWITCHDEV_VXLAN_FDB_OFFLOADED, dev,
+ 					 &vxlan_fdb_info->info, NULL);
+ 		mlxsw_sp_fid_put(fid);
+ 		return;
+ 	}
+ 
+ 	/* The device has a single FDB table, whereas Linux has two - one
+ 	 * in the bridge driver and another in the VxLAN driver. We only
+ 	 * program an entry to the device if the MAC points to the VxLAN
+ 	 * device in the bridge's FDB table
+ 	 */
+ 	vid = bridge_device->ops->fid_vid(bridge_device, fid);
+ 	if (br_fdb_find_port(br_dev, vxlan_fdb_info->eth_addr, vid) != dev)
+ 		goto err_br_fdb_find;
+ 
+ 	err = mlxsw_sp_port_fdb_tunnel_uc_op(mlxsw_sp, vxlan_fdb_info->eth_addr,
+ 					     mlxsw_sp_fid_index(fid), proto,
+ 					     &addr, true, false);
+ 	if (err)
+ 		goto err_fdb_tunnel_uc_op;
+ 	vxlan_fdb_info->offloaded = true;
+ 	call_switchdev_notifiers(SWITCHDEV_VXLAN_FDB_OFFLOADED, dev,
+ 				 &vxlan_fdb_info->info, NULL);
+ 	mlxsw_sp_fdb_call_notifiers(SWITCHDEV_FDB_OFFLOADED,
+ 				    vxlan_fdb_info->eth_addr, vid, dev, true);
+ 
+ 	mlxsw_sp_fid_put(fid);
+ 
+ 	return;
+ 
+ err_fdb_tunnel_uc_op:
+ err_br_fdb_find:
+ 	mlxsw_sp_fid_put(fid);
+ }
+ 
+ static void
+ mlxsw_sp_switchdev_vxlan_fdb_del(struct mlxsw_sp *mlxsw_sp,
+ 				 struct mlxsw_sp_switchdev_event_work *
+ 				 switchdev_work)
+ {
+ 	struct switchdev_notifier_vxlan_fdb_info *vxlan_fdb_info;
+ 	struct mlxsw_sp_bridge_device *bridge_device;
+ 	struct net_device *dev = switchdev_work->dev;
+ 	struct net_device *br_dev = netdev_master_upper_dev_get(dev);
+ 	u8 all_zeros_mac[ETH_ALEN] = { 0 };
+ 	enum mlxsw_sp_l3proto proto;
+ 	union mlxsw_sp_l3addr addr;
+ 	struct mlxsw_sp_fid *fid;
+ 	u16 vid;
+ 
+ 	vxlan_fdb_info = &switchdev_work->vxlan_fdb_info;
+ 
+ 	bridge_device = mlxsw_sp_bridge_device_find(mlxsw_sp->bridge, br_dev);
+ 	if (!bridge_device)
+ 		return;
+ 
+ 	fid = mlxsw_sp_fid_lookup_by_vni(mlxsw_sp, vxlan_fdb_info->vni);
+ 	if (!fid)
+ 		return;
+ 
+ 	mlxsw_sp_switchdev_vxlan_addr_convert(&vxlan_fdb_info->remote_ip,
+ 					      &proto, &addr);
+ 
+ 	if (ether_addr_equal(vxlan_fdb_info->eth_addr, all_zeros_mac)) {
+ 		mlxsw_sp_nve_flood_ip_del(mlxsw_sp, fid, proto, &addr);
+ 		mlxsw_sp_fid_put(fid);
+ 		return;
+ 	}
+ 
+ 	mlxsw_sp_port_fdb_tunnel_uc_op(mlxsw_sp, vxlan_fdb_info->eth_addr,
+ 				       mlxsw_sp_fid_index(fid), proto, &addr,
+ 				       false, false);
+ 	vid = bridge_device->ops->fid_vid(bridge_device, fid);
+ 	mlxsw_sp_fdb_call_notifiers(SWITCHDEV_FDB_OFFLOADED,
+ 				    vxlan_fdb_info->eth_addr, vid, dev, false);
+ 
+ 	mlxsw_sp_fid_put(fid);
+ }
+ 
+ static void mlxsw_sp_switchdev_vxlan_fdb_event_work(struct work_struct *work)
+ {
+ 	struct mlxsw_sp_switchdev_event_work *switchdev_work =
+ 		container_of(work, struct mlxsw_sp_switchdev_event_work, work);
+ 	struct net_device *dev = switchdev_work->dev;
+ 	struct mlxsw_sp *mlxsw_sp;
+ 	struct net_device *br_dev;
+ 
+ 	rtnl_lock();
+ 
+ 	if (!netif_running(dev))
+ 		goto out;
+ 	br_dev = netdev_master_upper_dev_get(dev);
+ 	if (!br_dev)
+ 		goto out;
+ 	if (!netif_is_bridge_master(br_dev))
+ 		goto out;
+ 	mlxsw_sp = mlxsw_sp_lower_get(br_dev);
+ 	if (!mlxsw_sp)
+ 		goto out;
+ 
+ 	switch (switchdev_work->event) {
+ 	case SWITCHDEV_VXLAN_FDB_ADD_TO_DEVICE:
+ 		mlxsw_sp_switchdev_vxlan_fdb_add(mlxsw_sp, switchdev_work);
+ 		break;
+ 	case SWITCHDEV_VXLAN_FDB_DEL_TO_DEVICE:
+ 		mlxsw_sp_switchdev_vxlan_fdb_del(mlxsw_sp, switchdev_work);
+ 		break;
+ 	}
+ 
+ out:
+ 	rtnl_unlock();
+ 	kfree(switchdev_work);
+ 	dev_put(dev);
+ }
+ 
+ static int
+ mlxsw_sp_switchdev_vxlan_work_prepare(struct mlxsw_sp_switchdev_event_work *
+ 				      switchdev_work,
+ 				      struct switchdev_notifier_info *info)
+ {
+ 	struct vxlan_dev *vxlan = netdev_priv(switchdev_work->dev);
+ 	struct switchdev_notifier_vxlan_fdb_info *vxlan_fdb_info;
+ 	struct vxlan_config *cfg = &vxlan->cfg;
+ 
+ 	vxlan_fdb_info = container_of(info,
+ 				      struct switchdev_notifier_vxlan_fdb_info,
+ 				      info);
+ 
+ 	if (vxlan_fdb_info->remote_port != cfg->dst_port)
+ 		return -EOPNOTSUPP;
+ 	if (vxlan_fdb_info->remote_vni != cfg->vni)
+ 		return -EOPNOTSUPP;
+ 	if (vxlan_fdb_info->vni != cfg->vni)
+ 		return -EOPNOTSUPP;
+ 	if (vxlan_fdb_info->remote_ifindex)
+ 		return -EOPNOTSUPP;
+ 	if (is_multicast_ether_addr(vxlan_fdb_info->eth_addr))
+ 		return -EOPNOTSUPP;
+ 	if (vxlan_addr_multicast(&vxlan_fdb_info->remote_ip))
+ 		return -EOPNOTSUPP;
+ 
+ 	switchdev_work->vxlan_fdb_info = *vxlan_fdb_info;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 6685987c2958 (switchdev: Add extack argument to call_switchdev_notifiers())
  /* Called under rcu_read_lock() */
  static int mlxsw_sp_switchdev_event(struct notifier_block *unused,
  				    unsigned long event, void *ptr)
diff --cc drivers/net/vxlan.c
index 36bd1c86ec20,ef45c3c925be..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -368,31 -391,31 +368,38 @@@ static void vxlan_fdb_switchdev_call_no
  
  	notifier_type = adding ? SWITCHDEV_VXLAN_FDB_ADD_TO_DEVICE
  			       : SWITCHDEV_VXLAN_FDB_DEL_TO_DEVICE;
++<<<<<<< HEAD
 +
 +	info = (struct switchdev_notifier_vxlan_fdb_info){
 +		.remote_ip = rd->remote_ip,
 +		.remote_port = rd->remote_port,
 +		.remote_vni = rd->remote_vni,
 +		.remote_ifindex = rd->remote_ifindex,
 +		.vni = fdb->vni,
 +		.offloaded = rd->offloaded,
 +	};
 +	memcpy(info.eth_addr, fdb->eth_addr, ETH_ALEN);
 +
 +	call_switchdev_notifiers(notifier_type, vxlan->dev,
 +				 &info.info);
++=======
+ 	vxlan_fdb_switchdev_notifier_info(vxlan, fdb, rd, NULL, &info);
+ 	ret = call_switchdev_notifiers(notifier_type, vxlan->dev,
+ 				       &info.info, extack);
+ 	return notifier_to_errno(ret);
++>>>>>>> 6685987c2958 (switchdev: Add extack argument to call_switchdev_notifiers())
  }
  
 -static int vxlan_fdb_notify(struct vxlan_dev *vxlan, struct vxlan_fdb *fdb,
 -			    struct vxlan_rdst *rd, int type, bool swdev_notify,
 -			    struct netlink_ext_ack *extack)
 +static void vxlan_fdb_notify(struct vxlan_dev *vxlan, struct vxlan_fdb *fdb,
 +			     struct vxlan_rdst *rd, int type)
  {
 -	int err;
 -
 -	if (swdev_notify) {
 -		switch (type) {
 -		case RTM_NEWNEIGH:
 -			err = vxlan_fdb_switchdev_call_notifiers(vxlan, fdb, rd,
 -								 true, extack);
 -			if (err)
 -				return err;
 -			break;
 -		case RTM_DELNEIGH:
 -			vxlan_fdb_switchdev_call_notifiers(vxlan, fdb, rd,
 -							   false, extack);
 -			break;
 -		}
 +	switch (type) {
 +	case RTM_NEWNEIGH:
 +		vxlan_fdb_switchdev_call_notifiers(vxlan, fdb, rd, true);
 +		break;
 +	case RTM_DELNEIGH:
 +		vxlan_fdb_switchdev_call_notifiers(vxlan, fdb, rd, false);
 +		break;
  	}
  
  	__vxlan_fdb_notify(vxlan, fdb, rd, type);
diff --cc net/switchdev/switchdev.c
index 52d193fe2d47,cd78253de31d..000000000000
--- a/net/switchdev/switchdev.c
+++ b/net/switchdev/switchdev.c
@@@ -570,9 -556,11 +570,14 @@@ EXPORT_SYMBOL_GPL(unregister_switchdev_
   *	Call all network notifier blocks.
   */
  int call_switchdev_notifiers(unsigned long val, struct net_device *dev,
- 			     struct switchdev_notifier_info *info)
+ 			     struct switchdev_notifier_info *info,
+ 			     struct netlink_ext_ack *extack)
  {
  	info->dev = dev;
++<<<<<<< HEAD
++=======
+ 	info->extack = extack;
++>>>>>>> 6685987c2958 (switchdev: Add extack argument to call_switchdev_notifiers())
  	return atomic_notifier_call_chain(&switchdev_notif_chain, val, info);
  }
  EXPORT_SYMBOL_GPL(call_switchdev_notifiers);
diff --git a/Documentation/networking/switchdev.txt b/Documentation/networking/switchdev.txt
index 82236a17b5e6..f3244d87512a 100644
--- a/Documentation/networking/switchdev.txt
+++ b/Documentation/networking/switchdev.txt
@@ -196,7 +196,7 @@ The switch device will learn/forget source MAC address/VLAN on ingress packets
 and notify the switch driver of the mac/vlan/port tuples.  The switch driver,
 in turn, will notify the bridge driver using the switchdev notifier call:
 
-	err = call_switchdev_notifiers(val, dev, info);
+	err = call_switchdev_notifiers(val, dev, info, extack);
 
 Where val is SWITCHDEV_FDB_ADD when learning and SWITCHDEV_FDB_DEL when
 forgetting, and info points to a struct switchdev_notifier_fdb_info.  On
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
diff --git a/drivers/net/ethernet/rocker/rocker_main.c b/drivers/net/ethernet/rocker/rocker_main.c
index eb24e9c7d7c2..55591089ca52 100644
--- a/drivers/net/ethernet/rocker/rocker_main.c
+++ b/drivers/net/ethernet/rocker/rocker_main.c
@@ -2727,7 +2727,7 @@ rocker_fdb_offload_notify(struct rocker_port *rocker_port,
 	info.vid = recv_info->vid;
 	info.offloaded = true;
 	call_switchdev_notifiers(SWITCHDEV_FDB_OFFLOADED,
-				 rocker_port->dev, &info.info);
+				 rocker_port->dev, &info.info, NULL);
 }
 
 static void rocker_switchdev_event_work(struct work_struct *work)
diff --git a/drivers/net/ethernet/rocker/rocker_ofdpa.c b/drivers/net/ethernet/rocker/rocker_ofdpa.c
index 6473cc68c2d5..bea7895930f6 100644
--- a/drivers/net/ethernet/rocker/rocker_ofdpa.c
+++ b/drivers/net/ethernet/rocker/rocker_ofdpa.c
@@ -1833,10 +1833,10 @@ static void ofdpa_port_fdb_learn_work(struct work_struct *work)
 	rtnl_lock();
 	if (learned && removing)
 		call_switchdev_notifiers(SWITCHDEV_FDB_DEL_TO_BRIDGE,
-					 lw->ofdpa_port->dev, &info.info);
+					 lw->ofdpa_port->dev, &info.info, NULL);
 	else if (learned && !removing)
 		call_switchdev_notifiers(SWITCHDEV_FDB_ADD_TO_BRIDGE,
-					 lw->ofdpa_port->dev, &info.info);
+					 lw->ofdpa_port->dev, &info.info, NULL);
 	rtnl_unlock();
 
 	kfree(work);
* Unmerged path drivers/net/vxlan.c
diff --git a/include/net/switchdev.h b/include/net/switchdev.h
index 28a4884a2674..2f30f6145dfe 100644
--- a/include/net/switchdev.h
+++ b/include/net/switchdev.h
@@ -215,7 +215,8 @@ int switchdev_port_obj_del(struct net_device *dev,
 int register_switchdev_notifier(struct notifier_block *nb);
 int unregister_switchdev_notifier(struct notifier_block *nb);
 int call_switchdev_notifiers(unsigned long val, struct net_device *dev,
-			     struct switchdev_notifier_info *info);
+			     struct switchdev_notifier_info *info,
+			     struct netlink_ext_ack *extack);
 
 int register_switchdev_blocking_notifier(struct notifier_block *nb);
 int unregister_switchdev_blocking_notifier(struct notifier_block *nb);
@@ -285,7 +286,8 @@ static inline int unregister_switchdev_notifier(struct notifier_block *nb)
 
 static inline int call_switchdev_notifiers(unsigned long val,
 					   struct net_device *dev,
-					   struct switchdev_notifier_info *info)
+					   struct switchdev_notifier_info *info,
+					   struct netlink_ext_ack *extack)
 {
 	return NOTIFY_DONE;
 }
diff --git a/net/bridge/br_switchdev.c b/net/bridge/br_switchdev.c
index 99ba32177b31..aaeb9f897d1c 100644
--- a/net/bridge/br_switchdev.c
+++ b/net/bridge/br_switchdev.c
@@ -113,7 +113,7 @@ br_switchdev_fdb_call_notifiers(bool adding, const unsigned char *mac,
 	info.added_by_user = added_by_user;
 	info.offloaded = offloaded;
 	notifier_type = adding ? SWITCHDEV_FDB_ADD_TO_DEVICE : SWITCHDEV_FDB_DEL_TO_DEVICE;
-	call_switchdev_notifiers(notifier_type, dev, &info.info);
+	call_switchdev_notifiers(notifier_type, dev, &info.info, NULL);
 }
 
 void
diff --git a/net/dsa/slave.c b/net/dsa/slave.c
index ee559da90c50..4dd13507d37a 100644
--- a/net/dsa/slave.c
+++ b/net/dsa/slave.c
@@ -1453,7 +1453,7 @@ static void dsa_slave_switchdev_event_work(struct work_struct *work)
 		}
 		fdb_info->offloaded = true;
 		call_switchdev_notifiers(SWITCHDEV_FDB_OFFLOADED, dev,
-					 &fdb_info->info);
+					 &fdb_info->info, NULL);
 		break;
 
 	case SWITCHDEV_FDB_DEL_TO_DEVICE:
* Unmerged path net/switchdev/switchdev.c
