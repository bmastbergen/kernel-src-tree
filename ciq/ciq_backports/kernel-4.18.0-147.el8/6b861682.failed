mlxsw: spectrum_acl: Enable vregion rehash per-profile

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jiri Pirko <jiri@mellanox.com>
commit 6b861682474ca0dd78bcaebbd3f471c8244689de
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/6b861682.failed

For MR ACL profile is does not make sense to do periodical rehashes, as
there is only one mask in use during the whole vregion lifetime.
Therefore periodical work is scheduled but the rehash never happens.
So allow to enable/disable rehash for the whole group, which is added
per-profile. Disable rehashing for MR profile.

Addition to the vregion list is done only in case the rehash is enable
on the particular vregion. Also, the addition is moved after delayed
work init to avoid schedule of uninitialized work
from vregion_rehash_intrvl_set(). Symmetrically, deletion from
the list is done before canceling the delayed work so it is
not scheduled by vregion_rehash_intrvl_set() again.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6b861682474ca0dd78bcaebbd3f471c8244689de)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
index c607c62a43ae,cdbcf612b6fd..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
@@@ -163,11 -179,21 +164,20 @@@ struct mlxsw_sp_acl_tcam_group 
  };
  
  struct mlxsw_sp_acl_tcam_vregion {
 -	struct mutex lock; /* Protects consistency of region, region2 pointers
 -			    * and vchunk_list.
 -			    */
  	struct mlxsw_sp_acl_tcam_region *region;
 -	struct mlxsw_sp_acl_tcam_region *region2; /* Used during migration */
  	struct list_head list; /* Member of a TCAM group */
 -	struct list_head tlist; /* Member of a TCAM */
  	struct list_head vchunk_list; /* List of vchunks under this vregion */
 +	struct mlxsw_sp_acl_tcam_group *group;
  	struct mlxsw_afk_key_info *key_info;
++<<<<<<< HEAD
++=======
+ 	struct mlxsw_sp_acl_tcam *tcam;
+ 	struct mlxsw_sp_acl_tcam_vgroup *vgroup;
+ 	struct delayed_work rehash_dw;
+ 	struct mlxsw_sp *mlxsw_sp;
+ 	bool failed_rollback; /* Indicates failed rollback during migration */
+ 	unsigned int ref_count;
++>>>>>>> 6b861682474c (mlxsw: spectrum_acl: Enable vregion rehash per-profile)
  };
  
  struct mlxsw_sp_acl_tcam_vchunk;
@@@ -244,7 -274,45 +254,49 @@@ mlxsw_sp_acl_tcam_group_add(struct mlxs
  	if (err)
  		return err;
  
++<<<<<<< HEAD
 +	err = rhashtable_init(&group->vchunk_ht,
++=======
+ 	return 0;
+ }
+ 
+ static void mlxsw_sp_acl_tcam_group_del(struct mlxsw_sp_acl_tcam_group *group)
+ {
+ 	struct mlxsw_sp_acl_tcam *tcam = group->tcam;
+ 
+ 	mutex_destroy(&group->lock);
+ 	mlxsw_sp_acl_tcam_group_id_put(tcam, group->id);
+ 	WARN_ON(!list_empty(&group->region_list));
+ }
+ 
+ static int
+ mlxsw_sp_acl_tcam_vgroup_add(struct mlxsw_sp *mlxsw_sp,
+ 			     struct mlxsw_sp_acl_tcam *tcam,
+ 			     struct mlxsw_sp_acl_tcam_vgroup *vgroup,
+ 			     const struct mlxsw_sp_acl_tcam_pattern *patterns,
+ 			     unsigned int patterns_count,
+ 			     struct mlxsw_afk_element_usage *tmplt_elusage,
+ 			     bool vregion_rehash_enabled)
+ {
+ 	int err;
+ 
+ 	vgroup->patterns = patterns;
+ 	vgroup->patterns_count = patterns_count;
+ 	vgroup->vregion_rehash_enabled = vregion_rehash_enabled;
+ 
+ 	if (tmplt_elusage) {
+ 		vgroup->tmplt_elusage_set = true;
+ 		memcpy(&vgroup->tmplt_elusage, tmplt_elusage,
+ 		       sizeof(vgroup->tmplt_elusage));
+ 	}
+ 	INIT_LIST_HEAD(&vgroup->vregion_list);
+ 
+ 	err = mlxsw_sp_acl_tcam_group_add(tcam, &vgroup->group);
+ 	if (err)
+ 		return err;
+ 
+ 	err = rhashtable_init(&vgroup->vchunk_ht,
++>>>>>>> 6b861682474c (mlxsw: spectrum_acl: Enable vregion rehash per-profile)
  			      &mlxsw_sp_acl_tcam_vchunk_ht_params);
  	if (err)
  		goto err_rhashtable_init;
@@@ -616,6 -755,11 +668,14 @@@ mlxsw_sp_acl_tcam_vregion_create(struc
  	if (!vregion)
  		return ERR_PTR(-ENOMEM);
  	INIT_LIST_HEAD(&vregion->vchunk_list);
++<<<<<<< HEAD
++=======
+ 	mutex_init(&vregion->lock);
+ 	vregion->tcam = tcam;
+ 	vregion->mlxsw_sp = mlxsw_sp;
+ 	vregion->vgroup = vgroup;
+ 	vregion->ref_count = 1;
++>>>>>>> 6b861682474c (mlxsw: spectrum_acl: Enable vregion rehash per-profile)
  
  	vregion->key_info = mlxsw_afk_key_info_get(afk, elusage);
  	if (IS_ERR(vregion->key_info)) {
@@@ -630,8 -774,23 +690,24 @@@
  		goto err_region_create;
  	}
  
++<<<<<<< HEAD
++=======
+ 	err = mlxsw_sp_acl_tcam_vgroup_vregion_attach(mlxsw_sp, vgroup, vregion,
+ 						      priority);
+ 	if (err)
+ 		goto err_vgroup_vregion_attach;
+ 
+ 	if (vgroup->vregion_rehash_enabled && ops->region_rehash_hints_get) {
+ 		/* Create the delayed work for vregion periodic rehash */
+ 		INIT_DELAYED_WORK(&vregion->rehash_dw,
+ 				  mlxsw_sp_acl_tcam_vregion_rehash_work);
+ 		mlxsw_sp_acl_tcam_vregion_rehash_work_schedule(vregion);
+ 		list_add_tail(&vregion->tlist, &tcam->vregion_list);
+ 	}
+ 
++>>>>>>> 6b861682474c (mlxsw: spectrum_acl: Enable vregion rehash per-profile)
  	return vregion;
  
 -err_vgroup_vregion_attach:
 -	mlxsw_sp_acl_tcam_region_destroy(mlxsw_sp, vregion->region);
  err_region_create:
  	mlxsw_afk_key_info_put(vregion->key_info);
  err_key_info_get:
@@@ -643,8 -802,19 +719,21 @@@ static voi
  mlxsw_sp_acl_tcam_vregion_destroy(struct mlxsw_sp *mlxsw_sp,
  				  struct mlxsw_sp_acl_tcam_vregion *vregion)
  {
++<<<<<<< HEAD
++=======
+ 	const struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;
+ 	struct mlxsw_sp_acl_tcam_vgroup *vgroup = vregion->vgroup;
+ 
+ 	if (vgroup->vregion_rehash_enabled && ops->region_rehash_hints_get) {
+ 		list_del(&vregion->tlist);
+ 		cancel_delayed_work_sync(&vregion->rehash_dw);
+ 	}
+ 	mlxsw_sp_acl_tcam_vgroup_vregion_detach(mlxsw_sp, vregion);
+ 	if (vregion->region2)
+ 		mlxsw_sp_acl_tcam_region_destroy(mlxsw_sp, vregion->region2);
++>>>>>>> 6b861682474c (mlxsw: spectrum_acl: Enable vregion rehash per-profile)
  	mlxsw_sp_acl_tcam_region_destroy(mlxsw_sp, vregion->region);
  	mlxsw_afk_key_info_put(vregion->key_info);
 -	mutex_destroy(&vregion->lock);
  	kfree(vregion);
  }
  
@@@ -1023,10 -1414,10 +1112,17 @@@ mlxsw_sp_acl_tcam_flower_ruleset_add(st
  {
  	struct mlxsw_sp_acl_tcam_flower_ruleset *ruleset = ruleset_priv;
  
++<<<<<<< HEAD
 +	return mlxsw_sp_acl_tcam_group_add(mlxsw_sp, tcam, &ruleset->group,
 +					   mlxsw_sp_acl_tcam_patterns,
 +					   MLXSW_SP_ACL_TCAM_PATTERNS_COUNT,
 +					   tmplt_elusage);
++=======
+ 	return mlxsw_sp_acl_tcam_vgroup_add(mlxsw_sp, tcam, &ruleset->vgroup,
+ 					    mlxsw_sp_acl_tcam_patterns,
+ 					    MLXSW_SP_ACL_TCAM_PATTERNS_COUNT,
+ 					    tmplt_elusage, true);
++>>>>>>> 6b861682474c (mlxsw: spectrum_acl: Enable vregion rehash per-profile)
  }
  
  static void
@@@ -1140,10 -1531,10 +1236,17 @@@ mlxsw_sp_acl_tcam_mr_ruleset_add(struc
  	struct mlxsw_sp_acl_tcam_mr_ruleset *ruleset = ruleset_priv;
  	int err;
  
++<<<<<<< HEAD
 +	err = mlxsw_sp_acl_tcam_group_add(mlxsw_sp, tcam, &ruleset->group,
 +					  mlxsw_sp_acl_tcam_patterns,
 +					  MLXSW_SP_ACL_TCAM_PATTERNS_COUNT,
 +					  tmplt_elusage);
++=======
+ 	err = mlxsw_sp_acl_tcam_vgroup_add(mlxsw_sp, tcam, &ruleset->vgroup,
+ 					   mlxsw_sp_acl_tcam_patterns,
+ 					   MLXSW_SP_ACL_TCAM_PATTERNS_COUNT,
+ 					   tmplt_elusage, false);
++>>>>>>> 6b861682474c (mlxsw: spectrum_acl: Enable vregion rehash per-profile)
  	if (err)
  		return err;
  
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
