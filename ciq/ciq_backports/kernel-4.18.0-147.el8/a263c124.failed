RDMA/ocrdma: Initialize ib_device_ops struct

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Kamal Heib <kamalheib1@gmail.com>
commit a263c1241a18975756fcdbb6ccdb6460c89b04a5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/a263c124.failed

Initialize ib_device_ops with the supported operations using
ib_set_device_ops().

	Signed-off-by: Kamal Heib <kamalheib1@gmail.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit a263c1241a18975756fcdbb6ccdb6460c89b04a5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/ocrdma/ocrdma_main.c
diff --cc drivers/infiniband/hw/ocrdma/ocrdma_main.c
index 5962c0ed9847,1f393842453a..000000000000
--- a/drivers/infiniband/hw/ocrdma/ocrdma_main.c
+++ b/drivers/infiniband/hw/ocrdma/ocrdma_main.c
@@@ -114,9 -114,81 +114,85 @@@ static void get_dev_fw_str(struct ib_de
  	snprintf(str, IB_FW_VERSION_NAME_MAX, "%s", &dev->attr.fw_ver[0]);
  }
  
++<<<<<<< HEAD
++=======
+ /* OCRDMA sysfs interface */
+ static ssize_t hw_rev_show(struct device *device,
+ 			   struct device_attribute *attr, char *buf)
+ {
+ 	struct ocrdma_dev *dev = dev_get_drvdata(device);
+ 
+ 	return scnprintf(buf, PAGE_SIZE, "0x%x\n", dev->nic_info.pdev->vendor);
+ }
+ static DEVICE_ATTR_RO(hw_rev);
+ 
+ static ssize_t hca_type_show(struct device *device,
+ 			     struct device_attribute *attr, char *buf)
+ {
+ 	struct ocrdma_dev *dev = dev_get_drvdata(device);
+ 
+ 	return scnprintf(buf, PAGE_SIZE, "%s\n", &dev->model_number[0]);
+ }
+ static DEVICE_ATTR_RO(hca_type);
+ 
+ static struct attribute *ocrdma_attributes[] = {
+ 	&dev_attr_hw_rev.attr,
+ 	&dev_attr_hca_type.attr,
+ 	NULL
+ };
+ 
+ static const struct attribute_group ocrdma_attr_group = {
+ 	.attrs = ocrdma_attributes,
+ };
+ 
+ static const struct ib_device_ops ocrdma_dev_ops = {
+ 	.alloc_mr = ocrdma_alloc_mr,
+ 	.alloc_pd = ocrdma_alloc_pd,
+ 	.alloc_ucontext = ocrdma_alloc_ucontext,
+ 	.create_ah = ocrdma_create_ah,
+ 	.create_cq = ocrdma_create_cq,
+ 	.create_qp = ocrdma_create_qp,
+ 	.dealloc_pd = ocrdma_dealloc_pd,
+ 	.dealloc_ucontext = ocrdma_dealloc_ucontext,
+ 	.dereg_mr = ocrdma_dereg_mr,
+ 	.destroy_ah = ocrdma_destroy_ah,
+ 	.destroy_cq = ocrdma_destroy_cq,
+ 	.destroy_qp = ocrdma_destroy_qp,
+ 	.get_dev_fw_str = get_dev_fw_str,
+ 	.get_dma_mr = ocrdma_get_dma_mr,
+ 	.get_link_layer = ocrdma_link_layer,
+ 	.get_netdev = ocrdma_get_netdev,
+ 	.get_port_immutable = ocrdma_port_immutable,
+ 	.map_mr_sg = ocrdma_map_mr_sg,
+ 	.mmap = ocrdma_mmap,
+ 	.modify_port = ocrdma_modify_port,
+ 	.modify_qp = ocrdma_modify_qp,
+ 	.poll_cq = ocrdma_poll_cq,
+ 	.post_recv = ocrdma_post_recv,
+ 	.post_send = ocrdma_post_send,
+ 	.process_mad = ocrdma_process_mad,
+ 	.query_ah = ocrdma_query_ah,
+ 	.query_device = ocrdma_query_device,
+ 	.query_pkey = ocrdma_query_pkey,
+ 	.query_port = ocrdma_query_port,
+ 	.query_qp = ocrdma_query_qp,
+ 	.reg_user_mr = ocrdma_reg_user_mr,
+ 	.req_notify_cq = ocrdma_arm_cq,
+ 	.resize_cq = ocrdma_resize_cq,
+ };
+ 
+ static const struct ib_device_ops ocrdma_dev_srq_ops = {
+ 	.create_srq = ocrdma_create_srq,
+ 	.destroy_srq = ocrdma_destroy_srq,
+ 	.modify_srq = ocrdma_modify_srq,
+ 	.post_srq_recv = ocrdma_post_srq_recv,
+ 	.query_srq = ocrdma_query_srq,
+ };
+ 
++>>>>>>> a263c1241a18 (RDMA/ocrdma: Initialize ib_device_ops struct)
  static int ocrdma_register_device(struct ocrdma_dev *dev)
  {
 +	strlcpy(dev->ibdev.name, "ocrdma%d", IB_DEVICE_NAME_MAX);
  	ocrdma_get_guid(dev, (u8 *)&dev->ibdev.node_guid);
  	BUILD_BUG_ON(sizeof(OCRDMA_NODE_DESC) > IB_DEVICE_NODE_DESC_MAX);
  	memcpy(dev->ibdev.node_desc, OCRDMA_NODE_DESC,
@@@ -154,51 -226,10 +230,49 @@@
  	dev->ibdev.phys_port_cnt = 1;
  	dev->ibdev.num_comp_vectors = dev->eq_cnt;
  
++<<<<<<< HEAD
 +	/* mandatory verbs. */
 +	dev->ibdev.query_device = ocrdma_query_device;
 +	dev->ibdev.query_port = ocrdma_query_port;
 +	dev->ibdev.modify_port = ocrdma_modify_port;
 +	dev->ibdev.get_netdev = ocrdma_get_netdev;
 +	dev->ibdev.get_link_layer = ocrdma_link_layer;
 +	dev->ibdev.alloc_pd = ocrdma_alloc_pd;
 +	dev->ibdev.dealloc_pd = ocrdma_dealloc_pd;
 +
 +	dev->ibdev.create_cq = ocrdma_create_cq;
 +	dev->ibdev.destroy_cq = ocrdma_destroy_cq;
 +	dev->ibdev.resize_cq = ocrdma_resize_cq;
 +
 +	dev->ibdev.create_qp = ocrdma_create_qp;
 +	dev->ibdev.modify_qp = ocrdma_modify_qp;
 +	dev->ibdev.query_qp = ocrdma_query_qp;
 +	dev->ibdev.destroy_qp = ocrdma_destroy_qp;
 +
 +	dev->ibdev.query_pkey = ocrdma_query_pkey;
 +	dev->ibdev.create_ah = ocrdma_create_ah;
 +	dev->ibdev.destroy_ah = ocrdma_destroy_ah;
 +	dev->ibdev.query_ah = ocrdma_query_ah;
 +	dev->ibdev.modify_ah = ocrdma_modify_ah;
 +
 +	dev->ibdev.poll_cq = ocrdma_poll_cq;
 +	dev->ibdev.post_send = ocrdma_post_send;
 +	dev->ibdev.post_recv = ocrdma_post_recv;
 +	dev->ibdev.req_notify_cq = ocrdma_arm_cq;
 +
 +	dev->ibdev.get_dma_mr = ocrdma_get_dma_mr;
 +	dev->ibdev.dereg_mr = ocrdma_dereg_mr;
 +	dev->ibdev.reg_user_mr = ocrdma_reg_user_mr;
 +
 +	dev->ibdev.alloc_mr = ocrdma_alloc_mr;
 +	dev->ibdev.map_mr_sg = ocrdma_map_mr_sg;
 +
++=======
++>>>>>>> a263c1241a18 (RDMA/ocrdma: Initialize ib_device_ops struct)
  	/* mandatory to support user space verbs consumer. */
- 	dev->ibdev.alloc_ucontext = ocrdma_alloc_ucontext;
- 	dev->ibdev.dealloc_ucontext = ocrdma_dealloc_ucontext;
- 	dev->ibdev.mmap = ocrdma_mmap;
  	dev->ibdev.dev.parent = &dev->nic_info.pdev->dev;
  
- 	dev->ibdev.process_mad = ocrdma_process_mad;
- 	dev->ibdev.get_port_immutable = ocrdma_port_immutable;
- 	dev->ibdev.get_dev_fw_str     = get_dev_fw_str;
+ 	ib_set_device_ops(&dev->ibdev, &ocrdma_dev_ops);
  
  	if (ocrdma_get_asic_type(dev) == OCRDMA_ASIC_GEN_SKH_R) {
  		dev->ibdev.uverbs_cmd_mask |=
@@@ -208,14 -239,11 +282,10 @@@
  		     OCRDMA_UVERBS(DESTROY_SRQ) |
  		     OCRDMA_UVERBS(POST_SRQ_RECV);
  
- 		dev->ibdev.create_srq = ocrdma_create_srq;
- 		dev->ibdev.modify_srq = ocrdma_modify_srq;
- 		dev->ibdev.query_srq = ocrdma_query_srq;
- 		dev->ibdev.destroy_srq = ocrdma_destroy_srq;
- 		dev->ibdev.post_srq_recv = ocrdma_post_srq_recv;
+ 		ib_set_device_ops(&dev->ibdev, &ocrdma_dev_srq_ops);
  	}
 -	rdma_set_device_sysfs_group(&dev->ibdev, &ocrdma_attr_group);
  	dev->ibdev.driver_id = RDMA_DRIVER_OCRDMA;
 -	return ib_register_device(&dev->ibdev, "ocrdma%d", NULL);
 +	return ib_register_device(&dev->ibdev, NULL);
  }
  
  static int ocrdma_alloc_resources(struct ocrdma_dev *dev)
* Unmerged path drivers/infiniband/hw/ocrdma/ocrdma_main.c
