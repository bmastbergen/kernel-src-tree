radix tree test suite: Convert iteration test to XArray

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Matthew Wilcox <willy@infradead.org>
commit 47e0fab2b15155e33fdff777c791bebfd5855bbc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/47e0fab2.failed

With no code left in the kernel using the multiorder radix tree, convert
the iteration test from the radix tree to the XArray.  It's unlikely to
suffer the same bug as the radix tree, but this test will prevent that
bug from ever creeping into the XArray implementation.

	Signed-off-by: Matthew Wilcox <willy@infradead.org>
(cherry picked from commit 47e0fab2b15155e33fdff777c791bebfd5855bbc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/radix-tree/iteration_check.c
diff --cc tools/testing/radix-tree/iteration_check.c
index a92bab513701,238db187aa15..000000000000
--- a/tools/testing/radix-tree/iteration_check.c
+++ b/tools/testing/radix-tree/iteration_check.c
@@@ -18,13 -17,12 +17,13 @@@
  
  #define NUM_THREADS	5
  #define MAX_IDX		100
 -#define TAG		XA_MARK_0
 -#define NEW_TAG		XA_MARK_1
 +#define TAG		0
 +#define NEW_TAG		1
  
 +static pthread_mutex_t tree_lock = PTHREAD_MUTEX_INITIALIZER;
  static pthread_t threads[NUM_THREADS];
  static unsigned int seeds[3];
- static RADIX_TREE(tree, GFP_KERNEL);
+ static DEFINE_XARRAY(array);
  static bool test_complete;
  static int max_order;
  
@@@ -35,18 -57,9 +58,21 @@@ static void *add_entries_fn(void *arg
  
  	while (!test_complete) {
  		unsigned long pgoff;
- 		int order;
  
  		for (pgoff = 0; pgoff < MAX_IDX; pgoff++) {
++<<<<<<< HEAD
 +			pthread_mutex_lock(&tree_lock);
 +			for (order = max_order; order >= 0; order--) {
 +				if (item_insert_order(&tree, pgoff, order)
 +						== 0) {
 +					item_tag_set(&tree, pgoff, TAG);
 +					break;
 +				}
 +			}
 +			pthread_mutex_unlock(&tree_lock);
++=======
+ 			my_item_insert(&array, pgoff);
++>>>>>>> 47e0fab2b151 (radix tree test suite: Convert iteration test to XArray)
  		}
  	}
  
@@@ -150,9 -148,9 +161,15 @@@ static void *remove_entries_fn(void *ar
  
  		pgoff = rand_r(&seeds[2]) % MAX_IDX;
  
++<<<<<<< HEAD
 +		pthread_mutex_lock(&tree_lock);
 +		item_delete(&tree, pgoff);
 +		pthread_mutex_unlock(&tree_lock);
++=======
+ 		item = xa_erase(&array, pgoff);
+ 		if (item)
+ 			item_free(item, pgoff);
++>>>>>>> 47e0fab2b151 (radix tree test suite: Convert iteration test to XArray)
  	}
  
  	rcu_unregister_thread();
@@@ -165,8 -163,7 +182,12 @@@ static void *tag_entries_fn(void *arg
  	rcu_register_thread();
  
  	while (!test_complete) {
++<<<<<<< HEAD
 +		tag_tagged_items(&tree, &tree_lock, 0, MAX_IDX, 10, TAG,
 +					NEW_TAG);
++=======
+ 		tag_tagged_items(&array, 0, MAX_IDX, 10, TAG, NEW_TAG);
++>>>>>>> 47e0fab2b151 (radix tree test suite: Convert iteration test to XArray)
  	}
  	rcu_unregister_thread();
  	return NULL;
* Unmerged path tools/testing/radix-tree/iteration_check.c
diff --git a/tools/testing/radix-tree/test.c b/tools/testing/radix-tree/test.c
index def6015570b2..9a59807bddfe 100644
--- a/tools/testing/radix-tree/test.c
+++ b/tools/testing/radix-tree/test.c
@@ -63,16 +63,21 @@ void item_sanity(struct item *item, unsigned long index)
 	assert((item->index | mask) == (index | mask));
 }
 
+void item_free(struct item *item, unsigned long index)
+{
+	item_sanity(item, index);
+	free(item);
+}
+
 int item_delete(struct radix_tree_root *root, unsigned long index)
 {
 	struct item *item = radix_tree_delete(root, index);
 
-	if (item) {
-		item_sanity(item, index);
-		free(item);
-		return 1;
-	}
-	return 0;
+	if (!item)
+		return 0;
+
+	item_free(item, index);
+	return 1;
 }
 
 static void item_free_rcu(struct rcu_head *head)
diff --git a/tools/testing/radix-tree/test.h b/tools/testing/radix-tree/test.h
index 92d901eacf49..323fcc45e4e0 100644
--- a/tools/testing/radix-tree/test.h
+++ b/tools/testing/radix-tree/test.h
@@ -14,6 +14,7 @@ struct item *item_create(unsigned long index, unsigned int order);
 int __item_insert(struct radix_tree_root *root, struct item *item);
 int item_insert(struct radix_tree_root *root, unsigned long index);
 void item_sanity(struct item *item, unsigned long index);
+void item_free(struct item *item, unsigned long index);
 int item_insert_order(struct radix_tree_root *root, unsigned long index,
 			unsigned order);
 int item_delete(struct radix_tree_root *root, unsigned long index);
