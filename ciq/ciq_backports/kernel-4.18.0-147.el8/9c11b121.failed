drm/i915/icl: Fix MG_DP_MODE() register programming

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Imre Deak <imre.deak@intel.com>
commit 9c11b12184bb01d8ba2c48e655509b184f02c769
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/9c11b121.failed

Fix the order of lane, port parameters passed to the register macro.

Note that this was already partly fixed by commit
37fc7845df7b6 ("drm/i915: Call MG_DP_MODE() macro with the right parameters order")

While at it simplify things by using the macro directly instead of an
unnecessary redirection via an array.

v2:
- Add a note the commit message about simplifying things. (José)

Fixes: 58106b7d816e1 ("drm/i915: Make MG PHY macros semantically consistent")
	Cc: José Roberto de Souza <jose.souza@intel.com>
	Cc: Lucas De Marchi <lucas.demarchi@intel.com>
	Cc: Aditya Swarup <aditya.swarup@intel.com>
	Signed-off-by: Imre Deak <imre.deak@intel.com>
	Reviewed-by: Lucas De Marchi <lucas.demarchi@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190419071026.32370-1-imre.deak@intel.com
(cherry picked from commit 9c11b12184bb01d8ba2c48e655509b184f02c769)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_ddi.c
diff --cc drivers/gpu/drm/i915/intel_ddi.c
index fed26d6e4e27,f181c26f62fd..000000000000
--- a/drivers/gpu/drm/i915/intel_ddi.c
+++ b/drivers/gpu/drm/i915/intel_ddi.c
@@@ -2582,6 -2900,182 +2582,185 @@@ static void intel_ddi_clk_disable(struc
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void icl_enable_phy_clock_gating(struct intel_digital_port *dig_port)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(dig_port->base.base.dev);
+ 	enum port port = dig_port->base.port;
+ 	enum tc_port tc_port = intel_port_to_tc(dev_priv, port);
+ 	u32 val;
+ 	int ln;
+ 
+ 	if (tc_port == PORT_TC_NONE)
+ 		return;
+ 
+ 	for (ln = 0; ln < 2; ln++) {
+ 		val = I915_READ(MG_DP_MODE(ln, port));
+ 		val |= MG_DP_MODE_CFG_TR2PWR_GATING |
+ 		       MG_DP_MODE_CFG_TRPWR_GATING |
+ 		       MG_DP_MODE_CFG_CLNPWR_GATING |
+ 		       MG_DP_MODE_CFG_DIGPWR_GATING |
+ 		       MG_DP_MODE_CFG_GAONPWR_GATING;
+ 		I915_WRITE(MG_DP_MODE(ln, port), val);
+ 	}
+ 
+ 	val = I915_READ(MG_MISC_SUS0(tc_port));
+ 	val |= MG_MISC_SUS0_SUSCLK_DYNCLKGATE_MODE(3) |
+ 	       MG_MISC_SUS0_CFG_TR2PWR_GATING |
+ 	       MG_MISC_SUS0_CFG_CL2PWR_GATING |
+ 	       MG_MISC_SUS0_CFG_GAONPWR_GATING |
+ 	       MG_MISC_SUS0_CFG_TRPWR_GATING |
+ 	       MG_MISC_SUS0_CFG_CL1PWR_GATING |
+ 	       MG_MISC_SUS0_CFG_DGPWR_GATING;
+ 	I915_WRITE(MG_MISC_SUS0(tc_port), val);
+ }
+ 
+ static void icl_disable_phy_clock_gating(struct intel_digital_port *dig_port)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(dig_port->base.base.dev);
+ 	enum port port = dig_port->base.port;
+ 	enum tc_port tc_port = intel_port_to_tc(dev_priv, port);
+ 	u32 val;
+ 	int ln;
+ 
+ 	if (tc_port == PORT_TC_NONE)
+ 		return;
+ 
+ 	for (ln = 0; ln < 2; ln++) {
+ 		val = I915_READ(MG_DP_MODE(ln, port));
+ 		val &= ~(MG_DP_MODE_CFG_TR2PWR_GATING |
+ 			 MG_DP_MODE_CFG_TRPWR_GATING |
+ 			 MG_DP_MODE_CFG_CLNPWR_GATING |
+ 			 MG_DP_MODE_CFG_DIGPWR_GATING |
+ 			 MG_DP_MODE_CFG_GAONPWR_GATING);
+ 		I915_WRITE(MG_DP_MODE(ln, port), val);
+ 	}
+ 
+ 	val = I915_READ(MG_MISC_SUS0(tc_port));
+ 	val &= ~(MG_MISC_SUS0_SUSCLK_DYNCLKGATE_MODE_MASK |
+ 		 MG_MISC_SUS0_CFG_TR2PWR_GATING |
+ 		 MG_MISC_SUS0_CFG_CL2PWR_GATING |
+ 		 MG_MISC_SUS0_CFG_GAONPWR_GATING |
+ 		 MG_MISC_SUS0_CFG_TRPWR_GATING |
+ 		 MG_MISC_SUS0_CFG_CL1PWR_GATING |
+ 		 MG_MISC_SUS0_CFG_DGPWR_GATING);
+ 	I915_WRITE(MG_MISC_SUS0(tc_port), val);
+ }
+ 
+ static void icl_program_mg_dp_mode(struct intel_digital_port *intel_dig_port)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(intel_dig_port->base.base.dev);
+ 	enum port port = intel_dig_port->base.port;
+ 	enum tc_port tc_port = intel_port_to_tc(dev_priv, port);
+ 	u32 ln0, ln1, lane_info;
+ 
+ 	if (tc_port == PORT_TC_NONE || intel_dig_port->tc_type == TC_PORT_TBT)
+ 		return;
+ 
+ 	ln0 = I915_READ(MG_DP_MODE(0, port));
+ 	ln1 = I915_READ(MG_DP_MODE(1, port));
+ 
+ 	switch (intel_dig_port->tc_type) {
+ 	case TC_PORT_TYPEC:
+ 		ln0 &= ~(MG_DP_MODE_CFG_DP_X1_MODE | MG_DP_MODE_CFG_DP_X2_MODE);
+ 		ln1 &= ~(MG_DP_MODE_CFG_DP_X1_MODE | MG_DP_MODE_CFG_DP_X2_MODE);
+ 
+ 		lane_info = (I915_READ(PORT_TX_DFLEXDPSP) &
+ 			     DP_LANE_ASSIGNMENT_MASK(tc_port)) >>
+ 			    DP_LANE_ASSIGNMENT_SHIFT(tc_port);
+ 
+ 		switch (lane_info) {
+ 		case 0x1:
+ 		case 0x4:
+ 			break;
+ 		case 0x2:
+ 			ln0 |= MG_DP_MODE_CFG_DP_X1_MODE;
+ 			break;
+ 		case 0x3:
+ 			ln0 |= MG_DP_MODE_CFG_DP_X1_MODE |
+ 			       MG_DP_MODE_CFG_DP_X2_MODE;
+ 			break;
+ 		case 0x8:
+ 			ln1 |= MG_DP_MODE_CFG_DP_X1_MODE;
+ 			break;
+ 		case 0xC:
+ 			ln1 |= MG_DP_MODE_CFG_DP_X1_MODE |
+ 			       MG_DP_MODE_CFG_DP_X2_MODE;
+ 			break;
+ 		case 0xF:
+ 			ln0 |= MG_DP_MODE_CFG_DP_X1_MODE |
+ 			       MG_DP_MODE_CFG_DP_X2_MODE;
+ 			ln1 |= MG_DP_MODE_CFG_DP_X1_MODE |
+ 			       MG_DP_MODE_CFG_DP_X2_MODE;
+ 			break;
+ 		default:
+ 			MISSING_CASE(lane_info);
+ 		}
+ 		break;
+ 
+ 	case TC_PORT_LEGACY:
+ 		ln0 |= MG_DP_MODE_CFG_DP_X1_MODE | MG_DP_MODE_CFG_DP_X2_MODE;
+ 		ln1 |= MG_DP_MODE_CFG_DP_X1_MODE | MG_DP_MODE_CFG_DP_X2_MODE;
+ 		break;
+ 
+ 	default:
+ 		MISSING_CASE(intel_dig_port->tc_type);
+ 		return;
+ 	}
+ 
+ 	I915_WRITE(MG_DP_MODE(0, port), ln0);
+ 	I915_WRITE(MG_DP_MODE(1, port), ln1);
+ }
+ 
+ static void intel_dp_sink_set_fec_ready(struct intel_dp *intel_dp,
+ 					const struct intel_crtc_state *crtc_state)
+ {
+ 	if (!crtc_state->fec_enable)
+ 		return;
+ 
+ 	if (drm_dp_dpcd_writeb(&intel_dp->aux, DP_FEC_CONFIGURATION, DP_FEC_READY) <= 0)
+ 		DRM_DEBUG_KMS("Failed to set FEC_READY in the sink\n");
+ }
+ 
+ static void intel_ddi_enable_fec(struct intel_encoder *encoder,
+ 				 const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
+ 	enum port port = encoder->port;
+ 	u32 val;
+ 
+ 	if (!crtc_state->fec_enable)
+ 		return;
+ 
+ 	val = I915_READ(DP_TP_CTL(port));
+ 	val |= DP_TP_CTL_FEC_ENABLE;
+ 	I915_WRITE(DP_TP_CTL(port), val);
+ 
+ 	if (intel_wait_for_register(&dev_priv->uncore, DP_TP_STATUS(port),
+ 				    DP_TP_STATUS_FEC_ENABLE_LIVE,
+ 				    DP_TP_STATUS_FEC_ENABLE_LIVE,
+ 				    1))
+ 		DRM_ERROR("Timed out waiting for FEC Enable Status\n");
+ }
+ 
+ static void intel_ddi_disable_fec_state(struct intel_encoder *encoder,
+ 					const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
+ 	enum port port = encoder->port;
+ 	u32 val;
+ 
+ 	if (!crtc_state->fec_enable)
+ 		return;
+ 
+ 	val = I915_READ(DP_TP_CTL(port));
+ 	val &= ~DP_TP_CTL_FEC_ENABLE;
+ 	I915_WRITE(DP_TP_CTL(port), val);
+ 	POSTING_READ(DP_TP_CTL(port));
+ }
+ 
++>>>>>>> 9c11b12184bb (drm/i915/icl: Fix MG_DP_MODE() register programming)
  static void intel_ddi_pre_enable_dp(struct intel_encoder *encoder,
  				    const struct intel_crtc_state *crtc_state,
  				    const struct drm_connector_state *conn_state)
* Unmerged path drivers/gpu/drm/i915/intel_ddi.c
