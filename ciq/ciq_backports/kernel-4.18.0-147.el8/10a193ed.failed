net/mlx5: Expose lag operations in header file

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Roi Dayan <roid@mellanox.com>
commit 10a193ed78adc6667684981697b050c27a3e42db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/10a193ed.failed

The change is a refactoring step towards a multipath use case.

	Signed-off-by: Roi Dayan <roid@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 10a193ed78adc6667684981697b050c27a3e42db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/lag.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/lag.c
index 333f773609a0,3b0f7cf822d5..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/lag.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/lag.c
@@@ -35,34 -35,7 +35,38 @@@
  #include <linux/mlx5/vport.h>
  #include "mlx5_core.h"
  #include "eswitch.h"
++<<<<<<< HEAD
 +
 +enum {
 +	MLX5_LAG_FLAG_BONDED = 1 << 0,
 +};
 +
 +struct lag_func {
 +	struct mlx5_core_dev *dev;
 +	struct net_device    *netdev;
 +};
 +
 +/* Used for collection of netdev event info. */
 +struct lag_tracker {
 +	enum   netdev_lag_tx_type           tx_type;
 +	struct netdev_lag_lower_state_info  netdev_state[MLX5_MAX_PORTS];
 +	unsigned int is_bonded:1;
 +};
 +
 +/* LAG data of a ConnectX card.
 + * It serves both its phys functions.
 + */
 +struct mlx5_lag {
 +	u8                        flags;
 +	u8                        v2p_map[MLX5_MAX_PORTS];
 +	struct lag_func           pf[MLX5_MAX_PORTS];
 +	struct lag_tracker        tracker;
 +	struct delayed_work       bond_work;
 +	struct notifier_block     nb;
 +};
++=======
+ #include "lag.h"
++>>>>>>> 10a193ed78ad (net/mlx5: Expose lag operations in header file)
  
  /* General purpose, use for short periods of time.
   * Beware of lock dependencies (preferably, no locks should be acquired
@@@ -161,9 -129,14 +160,20 @@@ int mlx5_lag_dev_get_netdev_idx(struct 
  	return -1;
  }
  
++<<<<<<< HEAD
 +static bool __mlx5_lag_is_active(struct mlx5_lag *ldev)
 +{
 +	return !!(ldev->flags & MLX5_LAG_FLAG_BONDED);
++=======
+ static bool __mlx5_lag_is_roce(struct mlx5_lag *ldev)
+ {
+ 	return !!(ldev->flags & MLX5_LAG_FLAG_ROCE);
+ }
+ 
+ static bool __mlx5_lag_is_sriov(struct mlx5_lag *ldev)
+ {
+ 	return !!(ldev->flags & MLX5_LAG_FLAG_SRIOV);
++>>>>>>> 10a193ed78ad (net/mlx5: Expose lag operations in header file)
  }
  
  static void mlx5_infer_tx_affinity_mapping(struct lag_tracker *tracker,
@@@ -228,25 -201,52 +238,31 @@@ static int mlx5_create_lag(struct mlx5_
  	return err;
  }
  
++<<<<<<< HEAD
 +static void mlx5_activate_lag(struct mlx5_lag *ldev,
 +			      struct lag_tracker *tracker)
++=======
+ int mlx5_activate_lag(struct mlx5_lag *ldev,
+ 		      struct lag_tracker *tracker,
+ 		      u8 flags)
++>>>>>>> 10a193ed78ad (net/mlx5: Expose lag operations in header file)
  {
 -	bool roce_lag = !!(flags & MLX5_LAG_FLAG_ROCE);
 -	struct mlx5_core_dev *dev0 = ldev->pf[0].dev;
 -	int err;
 -
 -	err = mlx5_create_lag(ldev, tracker);
 -	if (err) {
 -		if (roce_lag) {
 -			mlx5_core_err(dev0,
 -				      "Failed to activate RoCE LAG\n");
 -		} else {
 -			mlx5_core_err(dev0,
 -				      "Failed to activate VF LAG\n"
 -				      "Make sure all VFs are unbound prior to VF LAG activation or deactivation\n");
 -		}
 -		return err;
 -	}
 -
 -	ldev->flags |= flags;
 -	return 0;
 +	ldev->flags |= MLX5_LAG_FLAG_BONDED;
 +	mlx5_create_lag(ldev, tracker);
  }
  
 -static int mlx5_deactivate_lag(struct mlx5_lag *ldev)
 +static void mlx5_deactivate_lag(struct mlx5_lag *ldev)
  {
  	struct mlx5_core_dev *dev0 = ldev->pf[0].dev;
 -	bool roce_lag = __mlx5_lag_is_roce(ldev);
  	int err;
  
 -	ldev->flags &= ~MLX5_LAG_MODE_FLAGS;
 +	ldev->flags &= ~MLX5_LAG_FLAG_BONDED;
  
  	err = mlx5_cmd_destroy_lag(dev0);
 -	if (err) {
 -		if (roce_lag) {
 -			mlx5_core_err(dev0,
 -				      "Failed to deactivate RoCE LAG; driver restart required\n");
 -		} else {
 -			mlx5_core_err(dev0,
 -				      "Failed to deactivate VF LAG; driver restart required\n"
 -				      "Make sure all VFs are unbound prior to VF LAG activation or deactivation\n");
 -		}
 -	}
 -
 -	return err;
 +	if (err)
 +		mlx5_core_err(dev0,
 +			      "Failed to destroy LAG (%d)\n",
 +			      err);
  }
  
  static bool mlx5_lag_check_prereq(struct mlx5_lag *ldev)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/lag.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/lag.h b/drivers/net/ethernet/mellanox/mlx5/core/lag.h
new file mode 100644
index 000000000000..a6637016c1ab
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlx5/core/lag.h
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB */
+/* Copyright (c) 2019 Mellanox Technologies. */
+
+#ifndef __MLX5_LAG_H__
+#define __MLX5_LAG_H__
+
+#include "mlx5_core.h"
+
+enum {
+	MLX5_LAG_FLAG_ROCE   = 1 << 0,
+	MLX5_LAG_FLAG_SRIOV  = 1 << 1,
+};
+
+#define MLX5_LAG_MODE_FLAGS (MLX5_LAG_FLAG_ROCE | MLX5_LAG_FLAG_SRIOV)
+
+struct lag_func {
+	struct mlx5_core_dev *dev;
+	struct net_device    *netdev;
+};
+
+/* Used for collection of netdev event info. */
+struct lag_tracker {
+	enum   netdev_lag_tx_type           tx_type;
+	struct netdev_lag_lower_state_info  netdev_state[MLX5_MAX_PORTS];
+	unsigned int is_bonded:1;
+};
+
+/* LAG data of a ConnectX card.
+ * It serves both its phys functions.
+ */
+struct mlx5_lag {
+	u8                        flags;
+	u8                        v2p_map[MLX5_MAX_PORTS];
+	struct lag_func           pf[MLX5_MAX_PORTS];
+	struct lag_tracker        tracker;
+	struct delayed_work       bond_work;
+	struct notifier_block     nb;
+};
+
+static inline struct mlx5_lag *
+mlx5_lag_dev_get(struct mlx5_core_dev *dev)
+{
+	return dev->priv.lag;
+}
+
+static inline bool
+__mlx5_lag_is_active(struct mlx5_lag *ldev)
+{
+	return !!(ldev->flags & MLX5_LAG_MODE_FLAGS);
+}
+
+void mlx5_modify_lag(struct mlx5_lag *ldev,
+		     struct lag_tracker *tracker);
+int mlx5_activate_lag(struct mlx5_lag *ldev,
+		      struct lag_tracker *tracker,
+		      u8 flags);
+int mlx5_lag_dev_get_netdev_idx(struct mlx5_lag *ldev,
+				struct net_device *ndev);
+
+#endif /* __MLX5_LAG_H__ */
