ASoC: wcd9335: fix a leaked reference by adding missing of_node_put

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [sound] ALSA: ASoC: wcd9335: fix a leaked reference by adding missing of_node_put (Jaroslav Kysela) [1683051]
Rebuild_FUZZ: 95.71%
commit-author Wen Yang <wen.yang99@zte.com.cn>
commit 64b92de9603f22b5455da925ee57268ef7fb4e80
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/64b92de9.failed

The call to of_parse_phandle returns a node pointer with refcount
incremented thus it must be explicitly decremented after the last
usage.

Detected by coccinelle with the following warnings:
./sound/soc/codecs/wcd9335.c:5193:2-8: ERROR: missing of_node_put; acquired a node pointer with refcount incremented on line 5183, but without a correspon    ding object release within this function.

	Signed-off-by: Wen Yang <wen.yang99@zte.com.cn>
	Cc: Liam Girdwood <lgirdwood@gmail.com>
	Cc: Mark Brown <broonie@kernel.org>
	Cc: Jaroslav Kysela <perex@perex.cz>
	Cc: Takashi Iwai <tiwai@suse.com>
	Cc: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
	Cc: Vinod Koul <vkoul@kernel.org>
	Cc: Dan Carpenter <dan.carpenter@oracle.com> (commit_signer:1/11=9%,authored:1/11=9%)
	Cc: alsa-devel@alsa-project.org
	Cc: linux-kernel@vger.kernel.org
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 64b92de9603f22b5455da925ee57268ef7fb4e80)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/codecs/wcd9335.c
diff --cc sound/soc/codecs/wcd9335.c
index 06c73699f16f,a04a7cedd99d..000000000000
--- a/sound/soc/codecs/wcd9335.c
+++ b/sound/soc/codecs/wcd9335.c
@@@ -1153,12 -4929,317 +1153,317 @@@ static int wcd9335_probe(struct platfor
  					       ARRAY_SIZE(wcd9335_slim_dais));
  }
  
++<<<<<<< HEAD
 +static struct platform_driver wcd9335_codec_driver = {
 +	.probe = wcd9335_probe,
++=======
+ static const struct regmap_range_cfg wcd9335_ranges[] = {
+ 	{
+ 		.name = "WCD9335",
+ 		.range_min =  0x0,
+ 		.range_max =  WCD9335_MAX_REGISTER,
+ 		.selector_reg = WCD9335_REG(0x0, 0),
+ 		.selector_mask = 0xff,
+ 		.selector_shift = 0,
+ 		.window_start = 0x0,
+ 		.window_len = 0x1000,
+ 	},
+ };
+ 
+ static bool wcd9335_is_volatile_register(struct device *dev, unsigned int reg)
+ {
+ 	switch (reg) {
+ 	case WCD9335_INTR_PIN1_STATUS0...WCD9335_INTR_PIN2_CLEAR3:
+ 	case WCD9335_ANA_MBHC_RESULT_3:
+ 	case WCD9335_ANA_MBHC_RESULT_2:
+ 	case WCD9335_ANA_MBHC_RESULT_1:
+ 	case WCD9335_ANA_MBHC_MECH:
+ 	case WCD9335_ANA_MBHC_ELECT:
+ 	case WCD9335_ANA_MBHC_ZDET:
+ 	case WCD9335_ANA_MICB2:
+ 	case WCD9335_ANA_RCO:
+ 	case WCD9335_ANA_BIAS:
+ 		return true;
+ 	default:
+ 		return false;
+ 	}
+ }
+ 
+ static struct regmap_config wcd9335_regmap_config = {
+ 	.reg_bits = 16,
+ 	.val_bits = 8,
+ 	.cache_type = REGCACHE_RBTREE,
+ 	.max_register = WCD9335_MAX_REGISTER,
+ 	.can_multi_write = true,
+ 	.ranges = wcd9335_ranges,
+ 	.num_ranges = ARRAY_SIZE(wcd9335_ranges),
+ 	.volatile_reg = wcd9335_is_volatile_register,
+ };
+ 
+ static const struct regmap_range_cfg wcd9335_ifc_ranges[] = {
+ 	{
+ 		.name = "WCD9335-IFC-DEV",
+ 		.range_min =  0x0,
+ 		.range_max = WCD9335_REG(0, 0x7ff),
+ 		.selector_reg = WCD9335_REG(0, 0x0),
+ 		.selector_mask = 0xff,
+ 		.selector_shift = 0,
+ 		.window_start = 0x0,
+ 		.window_len = 0x1000,
+ 	},
+ };
+ 
+ static struct regmap_config wcd9335_ifc_regmap_config = {
+ 	.reg_bits = 16,
+ 	.val_bits = 8,
+ 	.can_multi_write = true,
+ 	.max_register = WCD9335_REG(0, 0x7FF),
+ 	.ranges = wcd9335_ifc_ranges,
+ 	.num_ranges = ARRAY_SIZE(wcd9335_ifc_ranges),
+ };
+ 
+ static const struct regmap_irq wcd9335_codec_irqs[] = {
+ 	/* INTR_REG 0 */
+ 	[WCD9335_IRQ_SLIMBUS] = {
+ 		.reg_offset = 0,
+ 		.mask = BIT(0),
+ 		.type = {
+ 			.type_reg_offset = 0,
+ 			.types_supported = IRQ_TYPE_EDGE_BOTH,
+ 			.type_reg_mask	= BIT(0),
+ 		},
+ 	},
+ };
+ 
+ static const struct regmap_irq_chip wcd9335_regmap_irq1_chip = {
+ 	.name = "wcd9335_pin1_irq",
+ 	.status_base = WCD9335_INTR_PIN1_STATUS0,
+ 	.mask_base = WCD9335_INTR_PIN1_MASK0,
+ 	.ack_base = WCD9335_INTR_PIN1_CLEAR0,
+ 	.type_base = WCD9335_INTR_LEVEL0,
+ 	.num_type_reg = 4,
+ 	.num_regs = 4,
+ 	.irqs = wcd9335_codec_irqs,
+ 	.num_irqs = ARRAY_SIZE(wcd9335_codec_irqs),
+ };
+ 
+ static int wcd9335_parse_dt(struct wcd9335_codec *wcd)
+ {
+ 	struct device *dev = wcd->dev;
+ 	struct device_node *np = dev->of_node;
+ 	int ret;
+ 
+ 	wcd->reset_gpio = of_get_named_gpio(np,	"reset-gpios", 0);
+ 	if (wcd->reset_gpio < 0) {
+ 		dev_err(dev, "Reset GPIO missing from DT\n");
+ 		return wcd->reset_gpio;
+ 	}
+ 
+ 	wcd->mclk = devm_clk_get(dev, "mclk");
+ 	if (IS_ERR(wcd->mclk)) {
+ 		dev_err(dev, "mclk not found\n");
+ 		return PTR_ERR(wcd->mclk);
+ 	}
+ 
+ 	wcd->native_clk = devm_clk_get(dev, "slimbus");
+ 	if (IS_ERR(wcd->native_clk)) {
+ 		dev_err(dev, "slimbus clock not found\n");
+ 		return PTR_ERR(wcd->native_clk);
+ 	}
+ 
+ 	wcd->supplies[0].supply = "vdd-buck";
+ 	wcd->supplies[1].supply = "vdd-buck-sido";
+ 	wcd->supplies[2].supply = "vdd-tx";
+ 	wcd->supplies[3].supply = "vdd-rx";
+ 	wcd->supplies[4].supply = "vdd-io";
+ 
+ 	ret = regulator_bulk_get(dev, WCD9335_MAX_SUPPLY, wcd->supplies);
+ 	if (ret) {
+ 		dev_err(dev, "Failed to get supplies: err = %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int wcd9335_power_on_reset(struct wcd9335_codec *wcd)
+ {
+ 	struct device *dev = wcd->dev;
+ 	int ret;
+ 
+ 	ret = regulator_bulk_enable(WCD9335_MAX_SUPPLY, wcd->supplies);
+ 	if (ret) {
+ 		dev_err(dev, "Failed to get supplies: err = %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	/*
+ 	 * For WCD9335, it takes about 600us for the Vout_A and
+ 	 * Vout_D to be ready after BUCK_SIDO is powered up.
+ 	 * SYS_RST_N shouldn't be pulled high during this time
+ 	 * Toggle the reset line to make sure the reset pulse is
+ 	 * correctly applied
+ 	 */
+ 	usleep_range(600, 650);
+ 
+ 	gpio_direction_output(wcd->reset_gpio, 0);
+ 	msleep(20);
+ 	gpio_set_value(wcd->reset_gpio, 1);
+ 	msleep(20);
+ 
+ 	return 0;
+ }
+ 
+ static int wcd9335_bring_up(struct wcd9335_codec *wcd)
+ {
+ 	struct regmap *rm = wcd->regmap;
+ 	int val, byte0;
+ 
+ 	regmap_read(rm, WCD9335_CHIP_TIER_CTRL_EFUSE_VAL_OUT0, &val);
+ 	regmap_read(rm, WCD9335_CHIP_TIER_CTRL_CHIP_ID_BYTE0, &byte0);
+ 
+ 	if ((val < 0) || (byte0 < 0)) {
+ 		dev_err(wcd->dev, "WCD9335 CODEC version detection fail!\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (byte0 == 0x1) {
+ 		dev_info(wcd->dev, "WCD9335 CODEC version is v2.0\n");
+ 		wcd->version = WCD9335_VERSION_2_0;
+ 		regmap_write(rm, WCD9335_CODEC_RPM_RST_CTL, 0x01);
+ 		regmap_write(rm, WCD9335_SIDO_SIDO_TEST_2, 0x00);
+ 		regmap_write(rm, WCD9335_SIDO_SIDO_CCL_8, 0x6F);
+ 		regmap_write(rm, WCD9335_BIAS_VBG_FINE_ADJ, 0x65);
+ 		regmap_write(rm, WCD9335_CODEC_RPM_PWR_CDC_DIG_HM_CTL, 0x5);
+ 		regmap_write(rm, WCD9335_CODEC_RPM_PWR_CDC_DIG_HM_CTL, 0x7);
+ 		regmap_write(rm, WCD9335_CODEC_RPM_PWR_CDC_DIG_HM_CTL, 0x3);
+ 		regmap_write(rm, WCD9335_CODEC_RPM_RST_CTL, 0x3);
+ 	} else {
+ 		dev_err(wcd->dev, "WCD9335 CODEC version not supported\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int wcd9335_irq_init(struct wcd9335_codec *wcd)
+ {
+ 	int ret;
+ 
+ 	/*
+ 	 * INTR1 consists of all possible interrupt sources Ear OCP,
+ 	 * HPH OCP, MBHC, MAD, VBAT, and SVA
+ 	 * INTR2 is a subset of first interrupt sources MAD, VBAT, and SVA
+ 	 */
+ 	wcd->intr1 = of_irq_get_byname(wcd->dev->of_node, "intr1");
+ 	if (wcd->intr1 < 0) {
+ 		if (wcd->intr1 != -EPROBE_DEFER)
+ 			dev_err(wcd->dev, "Unable to configure IRQ\n");
+ 
+ 		return wcd->intr1;
+ 	}
+ 
+ 	ret = devm_regmap_add_irq_chip(wcd->dev, wcd->regmap, wcd->intr1,
+ 				 IRQF_TRIGGER_HIGH, 0,
+ 				 &wcd9335_regmap_irq1_chip, &wcd->irq_data);
+ 	if (ret)
+ 		dev_err(wcd->dev, "Failed to register IRQ chip: %d\n", ret);
+ 
+ 	return ret;
+ }
+ 
+ static int wcd9335_slim_probe(struct slim_device *slim)
+ {
+ 	struct device *dev = &slim->dev;
+ 	struct wcd9335_codec *wcd;
+ 	int ret;
+ 
+ 	wcd = devm_kzalloc(dev, sizeof(*wcd), GFP_KERNEL);
+ 	if (!wcd)
+ 		return	-ENOMEM;
+ 
+ 	wcd->dev = dev;
+ 	ret = wcd9335_parse_dt(wcd);
+ 	if (ret) {
+ 		dev_err(dev, "Error parsing DT: %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	ret = wcd9335_power_on_reset(wcd);
+ 	if (ret)
+ 		return ret;
+ 
+ 	dev_set_drvdata(dev, wcd);
+ 
+ 	return 0;
+ }
+ 
+ static int wcd9335_slim_status(struct slim_device *sdev,
+ 			       enum slim_device_status status)
+ {
+ 	struct device *dev = &sdev->dev;
+ 	struct device_node *ifc_dev_np;
+ 	struct wcd9335_codec *wcd;
+ 	int ret;
+ 
+ 	wcd = dev_get_drvdata(dev);
+ 
+ 	ifc_dev_np = of_parse_phandle(dev->of_node, "slim-ifc-dev", 0);
+ 	if (!ifc_dev_np) {
+ 		dev_err(dev, "No Interface device found\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	wcd->slim = sdev;
+ 	wcd->slim_ifc_dev = of_slim_get_device(sdev->ctrl, ifc_dev_np);
+ 	of_node_put(ifc_dev_np);
+ 	if (!wcd->slim_ifc_dev) {
+ 		dev_err(dev, "Unable to get SLIM Interface device\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	slim_get_logical_addr(wcd->slim_ifc_dev);
+ 
+ 	wcd->regmap = regmap_init_slimbus(sdev, &wcd9335_regmap_config);
+ 	if (IS_ERR(wcd->regmap)) {
+ 		dev_err(dev, "Failed to allocate slim register map\n");
+ 		return PTR_ERR(wcd->regmap);
+ 	}
+ 
+ 	wcd->if_regmap = regmap_init_slimbus(wcd->slim_ifc_dev,
+ 						  &wcd9335_ifc_regmap_config);
+ 	if (IS_ERR(wcd->if_regmap)) {
+ 		dev_err(dev, "Failed to allocate ifc register map\n");
+ 		return PTR_ERR(wcd->if_regmap);
+ 	}
+ 
+ 	ret = wcd9335_bring_up(wcd);
+ 	if (ret) {
+ 		dev_err(dev, "Failed to bringup WCD9335\n");
+ 		return ret;
+ 	}
+ 
+ 	ret = wcd9335_irq_init(wcd);
+ 	if (ret)
+ 		return ret;
+ 
+ 	wcd9335_probe(wcd);
+ 
+ 	return ret;
+ }
+ 
+ static const struct slim_device_id wcd9335_slim_id[] = {
+ 	{SLIM_MANF_ID_QCOM, SLIM_PROD_CODE_WCD9335, 0x1, 0x0},
+ 	{}
+ };
+ MODULE_DEVICE_TABLE(slim, wcd9335_slim_id);
+ 
+ static struct slim_driver wcd9335_slim_driver = {
++>>>>>>> 64b92de9603f (ASoC: wcd9335: fix a leaked reference by adding missing of_node_put)
  	.driver = {
 -		.name = "wcd9335-slim",
 +		.name = "wcd9335-codec",
  	},
 -	.probe = wcd9335_slim_probe,
 -	.device_status = wcd9335_slim_status,
 -	.id_table = wcd9335_slim_id,
  };
 -
 -module_slim_driver(wcd9335_slim_driver);
 -MODULE_DESCRIPTION("WCD9335 slim driver");
 +module_platform_driver(wcd9335_codec_driver);
 +MODULE_DESCRIPTION("WCD9335 Codec driver");
  MODULE_LICENSE("GPL v2");
 -MODULE_ALIAS("slim:217:1a0:*");
* Unmerged path sound/soc/codecs/wcd9335.c
