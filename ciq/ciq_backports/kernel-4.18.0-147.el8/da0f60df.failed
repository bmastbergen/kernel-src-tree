RDMA/uverbs: Prohibit write() calls with too small buffers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jason Gunthorpe <jgg@ziepe.ca>
commit da0f60df7bd5a045aa423ec64fe5d7e29ba803ff
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/da0f60df.failed

The size meta-data in the prior patch describes the smallest acceptable
buffer for the write() interface. Globally check this in the core code.

This is necessary in the case of write() methods that have a driver udata
to prevent computing a negative udata buffer length.

The return code of -ENOSPC is chosen here as some of the handlers already
use this code, however many other handler use EINVAL.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
(cherry picked from commit da0f60df7bd5a045aa423ec64fe5d7e29ba803ff)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_main.c
diff --cc drivers/infiniband/core/uverbs_main.c
index 495189811c27,bcbee8fc83a9..000000000000
--- a/drivers/infiniband/core/uverbs_main.c
+++ b/drivers/infiniband/core/uverbs_main.c
@@@ -638,46 -588,11 +638,46 @@@ err_put_refs
  	return filp;
  }
  
 +static bool verify_command_mask(struct ib_device *ib_dev,
 +				u32 command, bool extended)
 +{
 +	if (!extended)
 +		return ib_dev->uverbs_cmd_mask & BIT_ULL(command);
 +
 +	return ib_dev->uverbs_ex_cmd_mask & BIT_ULL(command);
 +}
 +
 +static bool verify_command_idx(u32 command, bool extended)
 +{
 +	if (extended)
 +		return command < ARRAY_SIZE(uverbs_ex_cmd_table) &&
 +		       uverbs_ex_cmd_table[command];
 +
 +	return command < ARRAY_SIZE(uverbs_cmd_table) &&
 +	       uverbs_cmd_table[command];
 +}
 +
 +static ssize_t process_hdr(struct ib_uverbs_cmd_hdr *hdr,
 +			   u32 *command, bool *extended)
 +{
 +	if (hdr->command & ~(u32)(IB_USER_VERBS_CMD_FLAG_EXTENDED |
 +				   IB_USER_VERBS_CMD_COMMAND_MASK))
 +		return -EINVAL;
 +
 +	*command = hdr->command & IB_USER_VERBS_CMD_COMMAND_MASK;
 +	*extended = hdr->command & IB_USER_VERBS_CMD_FLAG_EXTENDED;
 +
 +	if (!verify_command_idx(*command, *extended))
 +		return -EOPNOTSUPP;
 +
 +	return 0;
 +}
 +
  static ssize_t verify_hdr(struct ib_uverbs_cmd_hdr *hdr,
- 			  struct ib_uverbs_ex_cmd_hdr *ex_hdr,
- 			  size_t count, bool extended)
+ 			  struct ib_uverbs_ex_cmd_hdr *ex_hdr, size_t count,
+ 			  const struct uverbs_api_write_method *method_elm)
  {
- 	if (extended) {
+ 	if (method_elm->is_ex) {
  		count -= sizeof(*hdr) + sizeof(*ex_hdr);
  
  		if ((hdr->in_words + ex_hdr->provider_in_words) * 8 != count)
@@@ -744,7 -683,7 +768,11 @@@ static ssize_t ib_uverbs_write(struct f
  			return -EFAULT;
  	}
  
++<<<<<<< HEAD
 +	ret = verify_hdr(&hdr, &ex_hdr, count, extended);
++=======
+ 	ret = verify_hdr(&hdr, &ex_hdr, count, method_elm);
++>>>>>>> da0f60df7bd5 (RDMA/uverbs: Prohibit write() calls with too small buffers)
  	if (ret)
  		return ret;
  
* Unmerged path drivers/infiniband/core/uverbs_main.c
