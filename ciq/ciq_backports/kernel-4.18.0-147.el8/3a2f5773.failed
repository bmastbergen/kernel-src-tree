x86/kvm/hyper-v: nested_enable_evmcs() sets vmcs_version incorrectly

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 3a2f5773baab34a9943be4c77e1ff2ac79d16c75
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/3a2f5773.failed

Commit e2e871ab2f02 ("x86/kvm/hyper-v: Introduce nested_get_evmcs_version()
helper") broke EVMCS enablement: to set vmcs_version we now call
nested_get_evmcs_version() but this function checks
enlightened_vmcs_enabled flag which is not yet set so we end up returning
zero.

Fix the issue by re-arranging things in nested_enable_evmcs().

Fixes: e2e871ab2f02 ("x86/kvm/hyper-v: Introduce nested_get_evmcs_version() helper")
	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 3a2f5773baab34a9943be4c77e1ff2ac79d16c75)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/vmx_evmcs.h
diff --cc arch/x86/kvm/vmx/vmx_evmcs.h
index 210a884090ad,5466c6d85cf3..000000000000
--- a/arch/x86/kvm/vmx/vmx_evmcs.h
+++ b/arch/x86/kvm/vmx/vmx_evmcs.h
@@@ -298,27 -300,54 +298,53 @@@ static const struct evmcs_field vmcs_fi
  	EVMCS1_FIELD(VIRTUAL_PROCESSOR_ID, virtual_processor_id,
  		     HV_VMX_ENLIGHTENED_CLEAN_FIELD_CONTROL_XLAT),
  };
 -const unsigned int nr_evmcs_1_fields = ARRAY_SIZE(vmcs_field_to_evmcs_1);
  
 -void evmcs_sanitize_exec_ctrls(struct vmcs_config *vmcs_conf)
 +static __always_inline int get_evmcs_offset(unsigned long field,
 +					    u16 *clean_field)
  {
 -	vmcs_conf->pin_based_exec_ctrl &= ~EVMCS1_UNSUPPORTED_PINCTRL;
 -	vmcs_conf->cpu_based_2nd_exec_ctrl &= ~EVMCS1_UNSUPPORTED_2NDEXEC;
 +	unsigned int index = ROL16(field, 6);
 +	const struct evmcs_field *evmcs_field;
  
 -	vmcs_conf->vmexit_ctrl &= ~EVMCS1_UNSUPPORTED_VMEXIT_CTRL;
 -	vmcs_conf->vmentry_ctrl &= ~EVMCS1_UNSUPPORTED_VMENTRY_CTRL;
 +	if (unlikely(index >= ARRAY_SIZE(vmcs_field_to_evmcs_1))) {
 +		WARN_ONCE(1, "KVM: accessing unsupported EVMCS field %lx\n",
 +			  field);
 +		return -ENOENT;
 +	}
  
 -}
 -#endif
 +	evmcs_field = &vmcs_field_to_evmcs_1[index];
  
 -uint16_t nested_get_evmcs_version(struct kvm_vcpu *vcpu)
 -{
 -       struct vcpu_vmx *vmx = to_vmx(vcpu);
 -       /*
 -        * vmcs_version represents the range of supported Enlightened VMCS
 -        * versions: lower 8 bits is the minimal version, higher 8 bits is the
 -        * maximum supported version. KVM supports versions from 1 to
 -        * KVM_EVMCS_VERSION.
 -        */
 -       if (vmx->nested.enlightened_vmcs_enabled)
 -               return (KVM_EVMCS_VERSION << 8) | 1;
 +	if (clean_field)
 +		*clean_field = evmcs_field->clean_field;
  
 -       return 0;
 +	return evmcs_field->offset;
  }
  
++<<<<<<< HEAD:arch/x86/kvm/vmx/vmx_evmcs.h
 +#undef ROL16
 +
 +#endif /* __KVM_X86_VMX_EVMCS_H */
++=======
+ int nested_enable_evmcs(struct kvm_vcpu *vcpu,
+ 			uint16_t *vmcs_version)
+ {
+ 	struct vcpu_vmx *vmx = to_vmx(vcpu);
+ 	bool evmcs_already_enabled = vmx->nested.enlightened_vmcs_enabled;
+ 
+ 	vmx->nested.enlightened_vmcs_enabled = true;
+ 
+ 	if (vmcs_version)
+ 		*vmcs_version = nested_get_evmcs_version(vcpu);
+ 
+ 	/* We don't support disabling the feature for simplicity. */
+ 	if (evmcs_already_enabled)
+ 		return 0;
+ 
+ 	vmx->nested.msrs.pinbased_ctls_high &= ~EVMCS1_UNSUPPORTED_PINCTRL;
+ 	vmx->nested.msrs.entry_ctls_high &= ~EVMCS1_UNSUPPORTED_VMENTRY_CTRL;
+ 	vmx->nested.msrs.exit_ctls_high &= ~EVMCS1_UNSUPPORTED_VMEXIT_CTRL;
+ 	vmx->nested.msrs.secondary_ctls_high &= ~EVMCS1_UNSUPPORTED_2NDEXEC;
+ 	vmx->nested.msrs.vmfunc_controls &= ~EVMCS1_UNSUPPORTED_VMFUNC;
+ 
+ 	return 0;
+ }
++>>>>>>> 3a2f5773baab (x86/kvm/hyper-v: nested_enable_evmcs() sets vmcs_version incorrectly):arch/x86/kvm/vmx/evmcs.c
* Unmerged path arch/x86/kvm/vmx/vmx_evmcs.h
