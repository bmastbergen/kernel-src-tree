x86/kvmclock: Move kvmclock vsyscall param and init to kvmclock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit e499a9b6dc488aff7f284bee51936f510ab7ad15
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/e499a9b6.failed

There is no point to have this in the kvm code itself and call it from
there. This can be called from an initcall and the parameter is cleared
when the hypervisor is not KVM.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Pavel Tatashin <pasha.tatashin@oracle.com>
	Acked-by: Paolo Bonzini <pbonzini@redhat.com>
	Cc: steven.sistare@oracle.com
	Cc: daniel.m.jordan@oracle.com
	Cc: linux@armlinux.org.uk
	Cc: schwidefsky@de.ibm.com
	Cc: heiko.carstens@de.ibm.com
	Cc: john.stultz@linaro.org
	Cc: sboyd@codeaurora.org
	Cc: hpa@zytor.com
	Cc: douly.fnst@cn.fujitsu.com
	Cc: peterz@infradead.org
	Cc: prarit@redhat.com
	Cc: feng.tang@intel.com
	Cc: pmladek@suse.com
	Cc: gnomes@lxorguk.ukuu.org.uk
	Cc: linux-s390@vger.kernel.org
	Cc: boris.ostrovsky@oracle.com
	Cc: jgross@suse.com
Link: https://lkml.kernel.org/r/20180719205545.16512-7-pasha.tatashin@oracle.com

(cherry picked from commit e499a9b6dc488aff7f284bee51936f510ab7ad15)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/kvm.c
diff --cc arch/x86/kernel/kvm.c
index 24b1f9d35c86,a560750cc76f..000000000000
--- a/arch/x86/kernel/kvm.c
+++ b/arch/x86/kernel/kvm.c
@@@ -45,8 -45,6 +45,11 @@@
  #include <asm/apic.h>
  #include <asm/apicdef.h>
  #include <asm/hypervisor.h>
++<<<<<<< HEAD
 +#include <asm/kvm_guest.h>
 +#include <asm/tlb.h>
++=======
++>>>>>>> e499a9b6dc48 (x86/kvmclock: Move kvmclock vsyscall param and init to kvmclock)
  
  static int kvmapf = 1;
  
diff --git a/arch/x86/include/asm/kvm_guest.h b/arch/x86/include/asm/kvm_guest.h
deleted file mode 100644
index 46185263d9c2..000000000000
--- a/arch/x86/include/asm/kvm_guest.h
+++ /dev/null
@@ -1,7 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef _ASM_X86_KVM_GUEST_H
-#define _ASM_X86_KVM_GUEST_H
-
-int kvm_setup_vsyscall_timeinfo(void);
-
-#endif /* _ASM_X86_KVM_GUEST_H */
* Unmerged path arch/x86/kernel/kvm.c
diff --git a/arch/x86/kernel/kvmclock.c b/arch/x86/kernel/kvmclock.c
index 78aec160f5e0..7d690d2238f8 100644
--- a/arch/x86/kernel/kvmclock.c
+++ b/arch/x86/kernel/kvmclock.c
@@ -27,12 +27,14 @@
 #include <linux/sched/clock.h>
 #include <linux/mm.h>
 
+#include <asm/hypervisor.h>
 #include <asm/mem_encrypt.h>
 #include <asm/x86_init.h>
 #include <asm/reboot.h>
 #include <asm/kvmclock.h>
 
 static int kvmclock __initdata = 1;
+static int kvmclock_vsyscall __initdata = 1;
 static int msr_kvm_system_time __ro_after_init = MSR_KVM_SYSTEM_TIME;
 static int msr_kvm_wall_clock __ro_after_init = MSR_KVM_WALL_CLOCK;
 static u64 kvm_sched_clock_offset __ro_after_init;
@@ -44,6 +46,13 @@ static int __init parse_no_kvmclock(char *arg)
 }
 early_param("no-kvmclock", parse_no_kvmclock);
 
+static int __init parse_no_kvmclock_vsyscall(char *arg)
+{
+	kvmclock_vsyscall = 0;
+	return 0;
+}
+early_param("no-kvmclock-vsyscall", parse_no_kvmclock_vsyscall);
+
 /* Aligned to page sizes to match whats mapped via vsyscalls to userspace */
 #define HV_CLOCK_SIZE	(sizeof(struct pvclock_vsyscall_time_info) * NR_CPUS)
 
@@ -228,6 +237,24 @@ static void kvm_shutdown(void)
 	native_machine_shutdown();
 }
 
+static int __init kvm_setup_vsyscall_timeinfo(void)
+{
+#ifdef CONFIG_X86_64
+	u8 flags;
+
+	if (!hv_clock || !kvmclock_vsyscall)
+		return 0;
+
+	flags = pvclock_read_flags(&hv_clock[0].pvti);
+	if (!(flags & PVCLOCK_TSC_STABLE_BIT))
+		return 1;
+
+	kvm_clock.archdata.vclock_mode = VCLOCK_PVCLOCK;
+#endif
+	return 0;
+}
+early_initcall(kvm_setup_vsyscall_timeinfo);
+
 void __init kvmclock_init(void)
 {
 	u8 flags;
@@ -272,20 +299,3 @@ void __init kvmclock_init(void)
 	clocksource_register_hz(&kvm_clock, NSEC_PER_SEC);
 	pv_info.name = "KVM";
 }
-
-int __init kvm_setup_vsyscall_timeinfo(void)
-{
-#ifdef CONFIG_X86_64
-	u8 flags;
-
-	if (!hv_clock)
-		return 0;
-
-	flags = pvclock_read_flags(&hv_clock[0].pvti);
-	if (!(flags & PVCLOCK_TSC_STABLE_BIT))
-		return 1;
-
-	kvm_clock.archdata.vclock_mode = VCLOCK_PVCLOCK;
-#endif
-	return 0;
-}
