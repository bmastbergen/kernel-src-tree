KVM: PPC: Book3S HV: XIVE: Add get/set accessors for the VP XIVE state

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Cédric Le Goater <clg@kaod.org>
commit e4945b9da52b36052b7c509ca31c5ead1d165b24
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/e4945b9d.failed

The state of the thread interrupt management registers needs to be
collected for migration. These registers are cached under the
'xive_saved_state.w01' field of the VCPU when the VPCU context is
pulled from the HW thread. An OPAL call retrieves the backup of the
IPB register in the underlying XIVE NVT structure and merges it in the
KVM state.

	Signed-off-by: Cédric Le Goater <clg@kaod.org>
	Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
	Signed-off-by: Paul Mackerras <paulus@ozlabs.org>
(cherry picked from commit e4945b9da52b36052b7c509ca31c5ead1d165b24)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/virtual/kvm/devices/xive.txt
diff --cc Documentation/virtual/kvm/devices/xive.txt
index fdbd2ff92a88,525d1eebcf34..000000000000
--- a/Documentation/virtual/kvm/devices/xive.txt
+++ b/Documentation/virtual/kvm/devices/xive.txt
@@@ -17,3 -17,132 +17,135 @@@ the legacy interrupt mode, referred as 
  
    1. KVM_DEV_XIVE_GRP_CTRL
    Provides global controls on the device
++<<<<<<< HEAD
++=======
+   Attributes:
+     1.1 KVM_DEV_XIVE_RESET (write only)
+     Resets the interrupt controller configuration for sources and event
+     queues. To be used by kexec and kdump.
+     Errors: none
+ 
+     1.2 KVM_DEV_XIVE_EQ_SYNC (write only)
+     Sync all the sources and queues and mark the EQ pages dirty. This
+     to make sure that a consistent memory state is captured when
+     migrating the VM.
+     Errors: none
+ 
+   2. KVM_DEV_XIVE_GRP_SOURCE (write only)
+   Initializes a new source in the XIVE device and mask it.
+   Attributes:
+     Interrupt source number  (64-bit)
+   The kvm_device_attr.addr points to a __u64 value:
+   bits:     | 63   ....  2 |   1   |   0
+   values:   |    unused    | level | type
+   - type:  0:MSI 1:LSI
+   - level: assertion level in case of an LSI.
+   Errors:
+     -E2BIG:  Interrupt source number is out of range
+     -ENOMEM: Could not create a new source block
+     -EFAULT: Invalid user pointer for attr->addr.
+     -ENXIO:  Could not allocate underlying HW interrupt
+ 
+   3. KVM_DEV_XIVE_GRP_SOURCE_CONFIG (write only)
+   Configures source targeting
+   Attributes:
+     Interrupt source number  (64-bit)
+   The kvm_device_attr.addr points to a __u64 value:
+   bits:     | 63   ....  33 |  32  | 31 .. 3 |  2 .. 0
+   values:   |    eisn       | mask |  server | priority
+   - priority: 0-7 interrupt priority level
+   - server: CPU number chosen to handle the interrupt
+   - mask: mask flag (unused)
+   - eisn: Effective Interrupt Source Number
+   Errors:
+     -ENOENT: Unknown source number
+     -EINVAL: Not initialized source number
+     -EINVAL: Invalid priority
+     -EINVAL: Invalid CPU number.
+     -EFAULT: Invalid user pointer for attr->addr.
+     -ENXIO:  CPU event queues not configured or configuration of the
+              underlying HW interrupt failed
+     -EBUSY:  No CPU available to serve interrupt
+ 
+   4. KVM_DEV_XIVE_GRP_EQ_CONFIG (read-write)
+   Configures an event queue of a CPU
+   Attributes:
+     EQ descriptor identifier (64-bit)
+   The EQ descriptor identifier is a tuple (server, priority) :
+   bits:     | 63   ....  32 | 31 .. 3 |  2 .. 0
+   values:   |    unused     |  server | priority
+   The kvm_device_attr.addr points to :
+     struct kvm_ppc_xive_eq {
+ 	__u32 flags;
+ 	__u32 qshift;
+ 	__u64 qaddr;
+ 	__u32 qtoggle;
+ 	__u32 qindex;
+ 	__u8  pad[40];
+     };
+   - flags: queue flags
+     KVM_XIVE_EQ_ALWAYS_NOTIFY (required)
+ 	forces notification without using the coalescing mechanism
+ 	provided by the XIVE END ESBs.
+   - qshift: queue size (power of 2)
+   - qaddr: real address of queue
+   - qtoggle: current queue toggle bit
+   - qindex: current queue index
+   - pad: reserved for future use
+   Errors:
+     -ENOENT: Invalid CPU number
+     -EINVAL: Invalid priority
+     -EINVAL: Invalid flags
+     -EINVAL: Invalid queue size
+     -EINVAL: Invalid queue address
+     -EFAULT: Invalid user pointer for attr->addr.
+     -EIO:    Configuration of the underlying HW failed
+ 
+   5. KVM_DEV_XIVE_GRP_SOURCE_SYNC (write only)
+   Synchronize the source to flush event notifications
+   Attributes:
+     Interrupt source number  (64-bit)
+   Errors:
+     -ENOENT: Unknown source number
+     -EINVAL: Not initialized source number
+ 
+ * VCPU state
+ 
+   The XIVE IC maintains VP interrupt state in an internal structure
+   called the NVT. When a VP is not dispatched on a HW processor
+   thread, this structure can be updated by HW if the VP is the target
+   of an event notification.
+ 
+   It is important for migration to capture the cached IPB from the NVT
+   as it synthesizes the priorities of the pending interrupts. We
+   capture a bit more to report debug information.
+ 
+   KVM_REG_PPC_VP_STATE (2 * 64bits)
+   bits:     |  63  ....  32  |  31  ....  0  |
+   values:   |   TIMA word0   |   TIMA word1  |
+   bits:     | 127       ..........       64  |
+   values:   |            unused              |
+ 
+ * Migration:
+ 
+   Saving the state of a VM using the XIVE native exploitation mode
+   should follow a specific sequence. When the VM is stopped :
+ 
+   1. Mask all sources (PQ=01) to stop the flow of events.
+ 
+   2. Sync the XIVE device with the KVM control KVM_DEV_XIVE_EQ_SYNC to
+   flush any in-flight event notification and to stabilize the EQs. At
+   this stage, the EQ pages are marked dirty to make sure they are
+   transferred in the migration sequence.
+ 
+   3. Capture the state of the source targeting, the EQs configuration
+   and the state of thread interrupt context registers.
+ 
+   Restore is similar :
+ 
+   1. Restore the EQ configuration. As targeting depends on it.
+   2. Restore targeting
+   3. Restore the thread interrupt contexts
+   4. Restore the source states
+   5. Let the vCPU run
++>>>>>>> e4945b9da52b (KVM: PPC: Book3S HV: XIVE: Add get/set accessors for the VP XIVE state)
diff --git a/Documentation/virtual/kvm/api.txt b/Documentation/virtual/kvm/api.txt
index 8283ab2604ae..6a2698506463 100644
--- a/Documentation/virtual/kvm/api.txt
+++ b/Documentation/virtual/kvm/api.txt
@@ -1941,6 +1941,7 @@ registers, find a list below:
   PPC   | KVM_REG_PPC_TLB3PS            | 32
   PPC   | KVM_REG_PPC_EPTCFG            | 32
   PPC   | KVM_REG_PPC_ICP_STATE         | 64
+  PPC   | KVM_REG_PPC_VP_STATE          | 128
   PPC   | KVM_REG_PPC_TB_OFFSET         | 64
   PPC   | KVM_REG_PPC_SPMC1             | 32
   PPC   | KVM_REG_PPC_SPMC2             | 32
* Unmerged path Documentation/virtual/kvm/devices/xive.txt
diff --git a/arch/powerpc/include/asm/kvm_ppc.h b/arch/powerpc/include/asm/kvm_ppc.h
index f3383e76017a..64db4dc2b579 100644
--- a/arch/powerpc/include/asm/kvm_ppc.h
+++ b/arch/powerpc/include/asm/kvm_ppc.h
@@ -273,6 +273,7 @@ union kvmppc_one_reg {
 		u64	addr;
 		u64	length;
 	}	vpaval;
+	u64	xive_timaval[2];
 };
 
 struct kvmppc_ops {
@@ -597,6 +598,10 @@ extern void kvmppc_xive_push_vcpu(struct kvm_vcpu *vcpu);
 
 extern void kvmppc_xive_native_init_module(void);
 extern void kvmppc_xive_native_exit_module(void);
+extern int kvmppc_xive_native_get_vp(struct kvm_vcpu *vcpu,
+				     union kvmppc_one_reg *val);
+extern int kvmppc_xive_native_set_vp(struct kvm_vcpu *vcpu,
+				     union kvmppc_one_reg *val);
 
 #else
 static inline int kvmppc_xive_set_xive(struct kvm *kvm, u32 irq, u32 server,
@@ -624,6 +629,12 @@ static inline void kvmppc_xive_push_vcpu(struct kvm_vcpu *vcpu) { }
 
 static inline void kvmppc_xive_native_init_module(void) { }
 static inline void kvmppc_xive_native_exit_module(void) { }
+static inline int kvmppc_xive_native_get_vp(struct kvm_vcpu *vcpu,
+					    union kvmppc_one_reg *val)
+{ return 0; }
+static inline int kvmppc_xive_native_set_vp(struct kvm_vcpu *vcpu,
+					    union kvmppc_one_reg *val)
+{ return -ENOENT; }
 
 #endif /* CONFIG_KVM_XIVE */
 
diff --git a/arch/powerpc/include/uapi/asm/kvm.h b/arch/powerpc/include/uapi/asm/kvm.h
index be0ce1f17625..e623462c4927 100644
--- a/arch/powerpc/include/uapi/asm/kvm.h
+++ b/arch/powerpc/include/uapi/asm/kvm.h
@@ -482,6 +482,8 @@ struct kvm_ppc_cpu_char {
 #define  KVM_REG_PPC_ICP_PPRI_SHIFT	16	/* pending irq priority */
 #define  KVM_REG_PPC_ICP_PPRI_MASK	0xff
 
+#define KVM_REG_PPC_VP_STATE	(KVM_REG_PPC | KVM_REG_SIZE_U128 | 0x8d)
+
 /* Device control API: PPC-specific devices */
 #define KVM_DEV_MPIC_GRP_MISC		1
 #define   KVM_DEV_MPIC_BASE_ADDR	0	/* 64-bit */
diff --git a/arch/powerpc/kvm/book3s.c b/arch/powerpc/kvm/book3s.c
index 3ca9dac20fad..d327e4fcc166 100644
--- a/arch/powerpc/kvm/book3s.c
+++ b/arch/powerpc/kvm/book3s.c
@@ -652,6 +652,18 @@ int kvmppc_get_one_reg(struct kvm_vcpu *vcpu, u64 id,
 				*val = get_reg_val(id, kvmppc_xics_get_icp(vcpu));
 			break;
 #endif /* CONFIG_KVM_XICS */
+#ifdef CONFIG_KVM_XIVE
+		case KVM_REG_PPC_VP_STATE:
+			if (!vcpu->arch.xive_vcpu) {
+				r = -ENXIO;
+				break;
+			}
+			if (xive_enabled())
+				r = kvmppc_xive_native_get_vp(vcpu, val);
+			else
+				r = -ENXIO;
+			break;
+#endif /* CONFIG_KVM_XIVE */
 		case KVM_REG_PPC_FSCR:
 			*val = get_reg_val(id, vcpu->arch.fscr);
 			break;
@@ -725,6 +737,18 @@ int kvmppc_set_one_reg(struct kvm_vcpu *vcpu, u64 id,
 				r = kvmppc_xics_set_icp(vcpu, set_reg_val(id, *val));
 			break;
 #endif /* CONFIG_KVM_XICS */
+#ifdef CONFIG_KVM_XIVE
+		case KVM_REG_PPC_VP_STATE:
+			if (!vcpu->arch.xive_vcpu) {
+				r = -ENXIO;
+				break;
+			}
+			if (xive_enabled())
+				r = kvmppc_xive_native_set_vp(vcpu, val);
+			else
+				r = -ENXIO;
+			break;
+#endif /* CONFIG_KVM_XIVE */
 		case KVM_REG_PPC_FSCR:
 			vcpu->arch.fscr = set_reg_val(id, *val);
 			break;
diff --git a/arch/powerpc/kvm/book3s_xive_native.c b/arch/powerpc/kvm/book3s_xive_native.c
index 751259394150..1eadbc44f0d1 100644
--- a/arch/powerpc/kvm/book3s_xive_native.c
+++ b/arch/powerpc/kvm/book3s_xive_native.c
@@ -110,6 +110,82 @@ static int kvmppc_xive_native_create(struct kvm_device *dev, u32 type)
 	return ret;
 }
 
+/*
+ * Interrupt Pending Buffer (IPB) offset
+ */
+#define TM_IPB_SHIFT 40
+#define TM_IPB_MASK  (((u64) 0xFF) << TM_IPB_SHIFT)
+
+int kvmppc_xive_native_get_vp(struct kvm_vcpu *vcpu, union kvmppc_one_reg *val)
+{
+	struct kvmppc_xive_vcpu *xc = vcpu->arch.xive_vcpu;
+	u64 opal_state;
+	int rc;
+
+	if (!kvmppc_xive_enabled(vcpu))
+		return -EPERM;
+
+	if (!xc)
+		return -ENOENT;
+
+	/* Thread context registers. We only care about IPB and CPPR */
+	val->xive_timaval[0] = vcpu->arch.xive_saved_state.w01;
+
+	/* Get the VP state from OPAL */
+	rc = xive_native_get_vp_state(xc->vp_id, &opal_state);
+	if (rc)
+		return rc;
+
+	/*
+	 * Capture the backup of IPB register in the NVT structure and
+	 * merge it in our KVM VP state.
+	 */
+	val->xive_timaval[0] |= cpu_to_be64(opal_state & TM_IPB_MASK);
+
+	pr_devel("%s NSR=%02x CPPR=%02x IBP=%02x PIPR=%02x w01=%016llx w2=%08x opal=%016llx\n",
+		 __func__,
+		 vcpu->arch.xive_saved_state.nsr,
+		 vcpu->arch.xive_saved_state.cppr,
+		 vcpu->arch.xive_saved_state.ipb,
+		 vcpu->arch.xive_saved_state.pipr,
+		 vcpu->arch.xive_saved_state.w01,
+		 (u32) vcpu->arch.xive_cam_word, opal_state);
+
+	return 0;
+}
+
+int kvmppc_xive_native_set_vp(struct kvm_vcpu *vcpu, union kvmppc_one_reg *val)
+{
+	struct kvmppc_xive_vcpu *xc = vcpu->arch.xive_vcpu;
+	struct kvmppc_xive *xive = vcpu->kvm->arch.xive;
+
+	pr_devel("%s w01=%016llx vp=%016llx\n", __func__,
+		 val->xive_timaval[0], val->xive_timaval[1]);
+
+	if (!kvmppc_xive_enabled(vcpu))
+		return -EPERM;
+
+	if (!xc || !xive)
+		return -ENOENT;
+
+	/* We can't update the state of a "pushed" VCPU	 */
+	if (WARN_ON(vcpu->arch.xive_pushed))
+		return -EBUSY;
+
+	/*
+	 * Restore the thread context registers. IPB and CPPR should
+	 * be the only ones that matter.
+	 */
+	vcpu->arch.xive_saved_state.w01 = val->xive_timaval[0];
+
+	/*
+	 * There is no need to restore the XIVE internal state (IPB
+	 * stored in the NVT) as the IPB register was merged in KVM VP
+	 * state when captured.
+	 */
+	return 0;
+}
+
 static int xive_native_debug_show(struct seq_file *m, void *private)
 {
 	struct kvmppc_xive *xive = m->private;
