RDMA/uverbs: Remove UA_FLAGS

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jason Gunthorpe <jgg@ziepe.ca>
commit 83bb4442330f035bd68ec5d2f5b87bfef1c1a4ab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/83bb4442.failed

This bit of boilerplate isn't really necessary, we can use bitfields
instead of a flags enum and the macros can then individually initialize
them through the __VA_ARGS__ like everything else.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
(cherry picked from commit 83bb4442330f035bd68ec5d2f5b87bfef1c1a4ab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_ioctl.c
#	drivers/infiniband/core/uverbs_std_types_counters.c
#	drivers/infiniband/core/uverbs_std_types_cq.c
#	drivers/infiniband/core/uverbs_std_types_dm.c
#	drivers/infiniband/core/uverbs_std_types_flow_action.c
#	drivers/infiniband/core/uverbs_std_types_mr.c
#	drivers/infiniband/hw/mlx5/devx.c
#	drivers/infiniband/hw/mlx5/main.c
#	include/rdma/uverbs_ioctl.h
diff --cc drivers/infiniband/core/uverbs_ioctl.c
index 03065bad8dae,cb6109036129..000000000000
--- a/drivers/infiniband/core/uverbs_ioctl.c
+++ b/drivers/infiniband/core/uverbs_ioctl.c
@@@ -98,16 -97,16 +98,28 @@@ static int uverbs_process_attr(struct i
  		 * longer struct will fail here if used with an old kernel and
  		 * non-zero content, making ABI compat/discovery simpler.
  		 */
++<<<<<<< HEAD
 +		if (uattr->len > val_spec->ptr.len &&
 +		    val_spec->flags & UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO &&
 +		    !uverbs_is_attr_cleared(uattr, val_spec->ptr.len))
++=======
+ 		if (uattr->len > val_spec->u.ptr.len &&
+ 		    val_spec->min_sz_or_zero &&
+ 		    !uverbs_is_attr_cleared(uattr, val_spec->u.ptr.len))
++>>>>>>> 83bb4442330f (RDMA/uverbs: Remove UA_FLAGS)
  			return -EOPNOTSUPP;
  
  	/* fall through */
  	case UVERBS_ATTR_TYPE_PTR_OUT:
++<<<<<<< HEAD
 +		if (uattr->len < val_spec->ptr.min_len ||
 +		    (!(val_spec->flags & UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO) &&
 +		     uattr->len > val_spec->ptr.len))
++=======
+ 		if (uattr->len < val_spec->u.ptr.min_len ||
+ 		    (!val_spec->min_sz_or_zero &&
+ 		     uattr->len > val_spec->u.ptr.len))
++>>>>>>> 83bb4442330f (RDMA/uverbs: Remove UA_FLAGS)
  			return -EINVAL;
  
  		if (spec->type != UVERBS_ATTR_TYPE_ENUM_IN &&
diff --cc drivers/infiniband/core/uverbs_std_types_counters.c
index 03b182a684a6,202e3782e740..000000000000
--- a/drivers/infiniband/core/uverbs_std_types_counters.c
+++ b/drivers/infiniband/core/uverbs_std_types_counters.c
@@@ -123,34 -124,36 +123,64 @@@ err_read
  	return ret;
  }
  
++<<<<<<< HEAD
 +static DECLARE_UVERBS_NAMED_METHOD(UVERBS_METHOD_COUNTERS_CREATE,
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_CREATE_COUNTERS_HANDLE,
 +			 UVERBS_OBJECT_COUNTERS,
 +			 UVERBS_ACCESS_NEW,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
 +
 +static DECLARE_UVERBS_NAMED_METHOD_WITH_HANDLER(UVERBS_METHOD_COUNTERS_DESTROY,
 +	uverbs_destroy_def_handler,
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_DESTROY_COUNTERS_HANDLE,
 +			 UVERBS_OBJECT_COUNTERS,
 +			 UVERBS_ACCESS_DESTROY,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
 +
 +#define MAX_COUNTERS_BUFF_SIZE USHRT_MAX
 +static DECLARE_UVERBS_NAMED_METHOD(UVERBS_METHOD_COUNTERS_READ,
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_READ_COUNTERS_HANDLE,
 +			 UVERBS_OBJECT_COUNTERS,
 +			 UVERBS_ACCESS_READ,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_READ_COUNTERS_BUFF,
 +			     UVERBS_ATTR_SIZE(0, MAX_COUNTERS_BUFF_SIZE),
 +			     UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_READ_COUNTERS_FLAGS,
 +			    UVERBS_ATTR_TYPE(__u32),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
++=======
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	UVERBS_METHOD_COUNTERS_CREATE,
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_CREATE_COUNTERS_HANDLE,
+ 			UVERBS_OBJECT_COUNTERS,
+ 			UVERBS_ACCESS_NEW,
+ 			UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD_DESTROY(
+ 	UVERBS_METHOD_COUNTERS_DESTROY,
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_DESTROY_COUNTERS_HANDLE,
+ 			UVERBS_OBJECT_COUNTERS,
+ 			UVERBS_ACCESS_DESTROY,
+ 			UA_MANDATORY));
+ 
+ #define MAX_COUNTERS_BUFF_SIZE USHRT_MAX
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	UVERBS_METHOD_COUNTERS_READ,
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_READ_COUNTERS_HANDLE,
+ 			UVERBS_OBJECT_COUNTERS,
+ 			UVERBS_ACCESS_READ,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_READ_COUNTERS_BUFF,
+ 			    UVERBS_ATTR_SIZE(0, MAX_COUNTERS_BUFF_SIZE),
+ 			    UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_READ_COUNTERS_FLAGS,
+ 			   UVERBS_ATTR_TYPE(__u32),
+ 			   UA_MANDATORY));
++>>>>>>> 83bb4442330f (RDMA/uverbs: Remove UA_FLAGS)
  
  DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_COUNTERS,
 -			    UVERBS_TYPE_ALLOC_IDR(uverbs_free_counters),
 +			    &UVERBS_TYPE_ALLOC_IDR(0, uverbs_free_counters),
  			    &UVERBS_METHOD(UVERBS_METHOD_COUNTERS_CREATE),
  			    &UVERBS_METHOD(UVERBS_METHOD_COUNTERS_DESTROY),
  			    &UVERBS_METHOD(UVERBS_METHOD_COUNTERS_READ));
diff --cc drivers/infiniband/core/uverbs_std_types_cq.c
index 3d293d01afea,1a14c245b511..000000000000
--- a/drivers/infiniband/core/uverbs_std_types_cq.c
+++ b/drivers/infiniband/core/uverbs_std_types_cq.c
@@@ -143,25 -147,30 +143,52 @@@ err_event_file
  	return ret;
  };
  
++<<<<<<< HEAD
 +static DECLARE_UVERBS_NAMED_METHOD(UVERBS_METHOD_CQ_CREATE,
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_CREATE_CQ_HANDLE, UVERBS_OBJECT_CQ,
 +			 UVERBS_ACCESS_NEW,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_CQE,
 +			    UVERBS_ATTR_TYPE(u32),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_USER_HANDLE,
 +			    UVERBS_ATTR_TYPE(u64),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_FD(UVERBS_ATTR_CREATE_CQ_COMP_CHANNEL,
 +			UVERBS_OBJECT_COMP_CHANNEL,
 +			UVERBS_ACCESS_READ),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_COMP_VECTOR, UVERBS_ATTR_TYPE(u32),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_FLAGS, UVERBS_ATTR_TYPE(u32)),
 +	&UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_CREATE_CQ_RESP_CQE, UVERBS_ATTR_TYPE(u32),
 +			     UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&uverbs_uhw_compat_in, &uverbs_uhw_compat_out);
++=======
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	UVERBS_METHOD_CQ_CREATE,
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_CREATE_CQ_HANDLE,
+ 			UVERBS_OBJECT_CQ,
+ 			UVERBS_ACCESS_NEW,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_CQE,
+ 			   UVERBS_ATTR_TYPE(u32),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_USER_HANDLE,
+ 			   UVERBS_ATTR_TYPE(u64),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_FD(UVERBS_ATTR_CREATE_CQ_COMP_CHANNEL,
+ 		       UVERBS_OBJECT_COMP_CHANNEL,
+ 		       UVERBS_ACCESS_READ,
+ 		       UA_OPTIONAL),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_COMP_VECTOR,
+ 			   UVERBS_ATTR_TYPE(u32),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_FLAGS, UVERBS_ATTR_TYPE(u32)),
+ 	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_CREATE_CQ_RESP_CQE,
+ 			    UVERBS_ATTR_TYPE(u32),
+ 			    UA_MANDATORY),
+ 	UVERBS_ATTR_UHW());
++>>>>>>> 83bb4442330f (RDMA/uverbs: Remove UA_FLAGS)
  
  static int UVERBS_HANDLER(UVERBS_METHOD_CQ_DESTROY)(struct ib_device *ib_dev,
  						    struct ib_uverbs_file *file,
@@@ -192,20 -201,22 +219,36 @@@
  			      sizeof(resp));
  }
  
++<<<<<<< HEAD
 +static DECLARE_UVERBS_NAMED_METHOD(UVERBS_METHOD_CQ_DESTROY,
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_DESTROY_CQ_HANDLE, UVERBS_OBJECT_CQ,
 +			 UVERBS_ACCESS_DESTROY,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_DESTROY_CQ_RESP,
 +			     UVERBS_ATTR_TYPE(struct ib_uverbs_destroy_cq_resp),
 +			     UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
++=======
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	UVERBS_METHOD_CQ_DESTROY,
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_DESTROY_CQ_HANDLE,
+ 			UVERBS_OBJECT_CQ,
+ 			UVERBS_ACCESS_DESTROY,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_DESTROY_CQ_RESP,
+ 			    UVERBS_ATTR_TYPE(struct ib_uverbs_destroy_cq_resp),
+ 			    UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_OBJECT(
+ 	UVERBS_OBJECT_CQ,
+ 	UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_ucq_object), uverbs_free_cq),
++>>>>>>> 83bb4442330f (RDMA/uverbs: Remove UA_FLAGS)
  
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_CQ,
 +			    &UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_ucq_object), 0,
 +						      uverbs_free_cq),
  #if IS_ENABLED(CONFIG_INFINIBAND_EXP_LEGACY_VERBS_NEW_UAPI)
 -	&UVERBS_METHOD(UVERBS_METHOD_CQ_CREATE),
 -	&UVERBS_METHOD(UVERBS_METHOD_CQ_DESTROY)
 +			    &UVERBS_METHOD(UVERBS_METHOD_CQ_CREATE),
 +			    &UVERBS_METHOD(UVERBS_METHOD_CQ_DESTROY)
  #endif
 -);
 +			   );
 +
diff --cc drivers/infiniband/core/uverbs_std_types_dm.c
index 8b681575b615,8a2548173a90..000000000000
--- a/drivers/infiniband/core/uverbs_std_types_dm.c
+++ b/drivers/infiniband/core/uverbs_std_types_dm.c
@@@ -83,26 -85,27 +83,48 @@@ static int UVERBS_HANDLER(UVERBS_METHOD
  	return 0;
  }
  
++<<<<<<< HEAD
 +static DECLARE_UVERBS_NAMED_METHOD(UVERBS_METHOD_DM_ALLOC,
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_ALLOC_DM_HANDLE, UVERBS_OBJECT_DM,
 +			 UVERBS_ACCESS_NEW,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_ALLOC_DM_LENGTH,
 +			    UVERBS_ATTR_TYPE(u64),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_ALLOC_DM_ALIGNMENT,
 +			    UVERBS_ATTR_TYPE(u32),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
 +
 +static DECLARE_UVERBS_NAMED_METHOD_WITH_HANDLER(UVERBS_METHOD_DM_FREE,
 +	uverbs_destroy_def_handler,
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_FREE_DM_HANDLE,
 +			 UVERBS_OBJECT_DM,
 +			 UVERBS_ACCESS_DESTROY,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
++=======
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	UVERBS_METHOD_DM_ALLOC,
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_ALLOC_DM_HANDLE,
+ 			UVERBS_OBJECT_DM,
+ 			UVERBS_ACCESS_NEW,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_ALLOC_DM_LENGTH,
+ 			   UVERBS_ATTR_TYPE(u64),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_ALLOC_DM_ALIGNMENT,
+ 			   UVERBS_ATTR_TYPE(u32),
+ 			   UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD_DESTROY(
+ 	UVERBS_METHOD_DM_FREE,
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_FREE_DM_HANDLE,
+ 			UVERBS_OBJECT_DM,
+ 			UVERBS_ACCESS_DESTROY,
+ 			UA_MANDATORY));
++>>>>>>> 83bb4442330f (RDMA/uverbs: Remove UA_FLAGS)
  
  DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_DM,
 -			    UVERBS_TYPE_ALLOC_IDR(uverbs_free_dm),
 +			    /* 1 is used in order to free the DM after MRs */
 +			    &UVERBS_TYPE_ALLOC_IDR(1, uverbs_free_dm),
  			    &UVERBS_METHOD(UVERBS_METHOD_DM_ALLOC),
  			    &UVERBS_METHOD(UVERBS_METHOD_DM_FREE));
diff --cc drivers/infiniband/core/uverbs_std_types_flow_action.c
index e3d282cb7bf2,143dbfdfda6f..000000000000
--- a/drivers/infiniband/core/uverbs_std_types_flow_action.c
+++ b/drivers/infiniband/core/uverbs_std_types_flow_action.c
@@@ -365,75 -366,87 +365,148 @@@ static int UVERBS_HANDLER(UVERBS_METHOD
  
  static const struct uverbs_attr_spec uverbs_flow_action_esp_keymat[] = {
  	[IB_UVERBS_FLOW_ACTION_ESP_KEYMAT_AES_GCM] = {
++<<<<<<< HEAD
 +		{ .ptr = {
 +			.type = UVERBS_ATTR_TYPE_PTR_IN,
 +			UVERBS_ATTR_TYPE(struct ib_uverbs_flow_action_esp_keymat_aes_gcm),
 +			.flags = UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO,
 +		} },
++=======
+ 		.type = UVERBS_ATTR_TYPE_PTR_IN,
+ 		UVERBS_ATTR_TYPE(struct ib_uverbs_flow_action_esp_keymat_aes_gcm),
+ 		UA_MIN_SZ_OR_ZERO
++>>>>>>> 83bb4442330f (RDMA/uverbs: Remove UA_FLAGS)
  	},
  };
  
  static const struct uverbs_attr_spec uverbs_flow_action_esp_replay[] = {
  	[IB_UVERBS_FLOW_ACTION_ESP_REPLAY_NONE] = {
 -		.type = UVERBS_ATTR_TYPE_PTR_IN,
 -		/* No need to specify any data */
 -		UVERBS_ATTR_SIZE(0, 0),
 +		{ .ptr = {
 +			.type = UVERBS_ATTR_TYPE_PTR_IN,
 +			/* No need to specify any data */
 +			.len = 0,
 +		} }
  	},
  	[IB_UVERBS_FLOW_ACTION_ESP_REPLAY_BMP] = {
++<<<<<<< HEAD
 +		{ .ptr = {
 +			.type = UVERBS_ATTR_TYPE_PTR_IN,
 +			UVERBS_ATTR_STRUCT(struct ib_uverbs_flow_action_esp_replay_bmp, size),
 +			.flags = UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO,
 +		} }
 +	},
 +};
 +
 +static DECLARE_UVERBS_NAMED_METHOD(UVERBS_METHOD_FLOW_ACTION_ESP_CREATE,
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_CREATE_FLOW_ACTION_ESP_HANDLE,
 +			 UVERBS_OBJECT_FLOW_ACTION,
 +			 UVERBS_ACCESS_NEW,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_FLOW_ACTION_ESP_ATTRS,
 +			    UVERBS_ATTR_STRUCT(struct ib_uverbs_flow_action_esp, hard_limit_pkts),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY |
 +				     UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_FLOW_ACTION_ESP_ESN, UVERBS_ATTR_TYPE(__u32)),
 +	&UVERBS_ATTR_ENUM_IN(UVERBS_ATTR_FLOW_ACTION_ESP_KEYMAT,
 +			     uverbs_flow_action_esp_keymat,
 +			     UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_ENUM_IN(UVERBS_ATTR_FLOW_ACTION_ESP_REPLAY,
 +			     uverbs_flow_action_esp_replay),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_FLOW_ACTION_ESP_ENCAP,
 +			    UVERBS_ATTR_STRUCT(struct ib_uverbs_flow_action_esp_encap, type)));
 +
 +static DECLARE_UVERBS_NAMED_METHOD(UVERBS_METHOD_FLOW_ACTION_ESP_MODIFY,
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_MODIFY_FLOW_ACTION_ESP_HANDLE,
 +			 UVERBS_OBJECT_FLOW_ACTION,
 +			 UVERBS_ACCESS_WRITE,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_FLOW_ACTION_ESP_ATTRS,
 +			    UVERBS_ATTR_STRUCT(struct ib_uverbs_flow_action_esp, hard_limit_pkts),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_FLOW_ACTION_ESP_ESN, UVERBS_ATTR_TYPE(__u32)),
 +	&UVERBS_ATTR_ENUM_IN(UVERBS_ATTR_FLOW_ACTION_ESP_KEYMAT,
 +			     uverbs_flow_action_esp_keymat),
 +	&UVERBS_ATTR_ENUM_IN(UVERBS_ATTR_FLOW_ACTION_ESP_REPLAY,
 +			     uverbs_flow_action_esp_replay),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_FLOW_ACTION_ESP_ENCAP,
 +			    UVERBS_ATTR_STRUCT(struct ib_uverbs_flow_action_esp_encap, type)));
 +
 +static DECLARE_UVERBS_NAMED_METHOD_WITH_HANDLER(UVERBS_METHOD_FLOW_ACTION_DESTROY,
 +	uverbs_destroy_def_handler,
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_DESTROY_FLOW_ACTION_HANDLE,
 +			 UVERBS_OBJECT_FLOW_ACTION,
 +			 UVERBS_ACCESS_DESTROY,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
 +
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_FLOW_ACTION,
 +			    &UVERBS_TYPE_ALLOC_IDR(0, uverbs_free_flow_action),
 +			    &UVERBS_METHOD(UVERBS_METHOD_FLOW_ACTION_ESP_CREATE),
 +			    &UVERBS_METHOD(UVERBS_METHOD_FLOW_ACTION_DESTROY),
 +			    &UVERBS_METHOD(UVERBS_METHOD_FLOW_ACTION_ESP_MODIFY));
++=======
+ 		.type = UVERBS_ATTR_TYPE_PTR_IN,
+ 		UVERBS_ATTR_STRUCT(struct ib_uverbs_flow_action_esp_replay_bmp, size),
+ 		UA_MIN_SZ_OR_ZERO
+ 	},
+ };
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	UVERBS_METHOD_FLOW_ACTION_ESP_CREATE,
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_CREATE_FLOW_ACTION_ESP_HANDLE,
+ 			UVERBS_OBJECT_FLOW_ACTION,
+ 			UVERBS_ACCESS_NEW,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_FLOW_ACTION_ESP_ATTRS,
+ 			   UVERBS_ATTR_STRUCT(struct ib_uverbs_flow_action_esp,
+ 					      hard_limit_pkts),
+ 			   UA_MANDATORY,
+ 			   UA_MIN_SZ_OR_ZERO),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_FLOW_ACTION_ESP_ESN,
+ 			   UVERBS_ATTR_TYPE(__u32),
+ 			   UA_OPTIONAL),
+ 	UVERBS_ATTR_ENUM_IN(UVERBS_ATTR_FLOW_ACTION_ESP_KEYMAT,
+ 			    uverbs_flow_action_esp_keymat,
+ 			    UA_MANDATORY),
+ 	UVERBS_ATTR_ENUM_IN(UVERBS_ATTR_FLOW_ACTION_ESP_REPLAY,
+ 			    uverbs_flow_action_esp_replay,
+ 			    UA_OPTIONAL),
+ 	UVERBS_ATTR_PTR_IN(
+ 		UVERBS_ATTR_FLOW_ACTION_ESP_ENCAP,
+ 		UVERBS_ATTR_STRUCT(struct ib_uverbs_flow_action_esp_encap,
+ 				   type),
+ 		UA_OPTIONAL));
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	UVERBS_METHOD_FLOW_ACTION_ESP_MODIFY,
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_MODIFY_FLOW_ACTION_ESP_HANDLE,
+ 			UVERBS_OBJECT_FLOW_ACTION,
+ 			UVERBS_ACCESS_WRITE,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_FLOW_ACTION_ESP_ATTRS,
+ 			   UVERBS_ATTR_STRUCT(struct ib_uverbs_flow_action_esp,
+ 					      hard_limit_pkts),
+ 			   UA_OPTIONAL,
+ 			   UA_MIN_SZ_OR_ZERO),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_FLOW_ACTION_ESP_ESN,
+ 			   UVERBS_ATTR_TYPE(__u32),
+ 			   UA_OPTIONAL),
+ 	UVERBS_ATTR_ENUM_IN(UVERBS_ATTR_FLOW_ACTION_ESP_KEYMAT,
+ 			    uverbs_flow_action_esp_keymat,
+ 			    UA_OPTIONAL),
+ 	UVERBS_ATTR_ENUM_IN(UVERBS_ATTR_FLOW_ACTION_ESP_REPLAY,
+ 			    uverbs_flow_action_esp_replay,
+ 			    UA_OPTIONAL),
+ 	UVERBS_ATTR_PTR_IN(
+ 		UVERBS_ATTR_FLOW_ACTION_ESP_ENCAP,
+ 		UVERBS_ATTR_STRUCT(struct ib_uverbs_flow_action_esp_encap,
+ 				   type),
+ 		UA_OPTIONAL));
+ 
+ DECLARE_UVERBS_NAMED_METHOD_DESTROY(
+ 	UVERBS_METHOD_FLOW_ACTION_DESTROY,
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_DESTROY_FLOW_ACTION_HANDLE,
+ 			UVERBS_OBJECT_FLOW_ACTION,
+ 			UVERBS_ACCESS_DESTROY,
+ 			UA_MANDATORY));
++>>>>>>> 83bb4442330f (RDMA/uverbs: Remove UA_FLAGS)
  
 -DECLARE_UVERBS_NAMED_OBJECT(
 -	UVERBS_OBJECT_FLOW_ACTION,
 -	UVERBS_TYPE_ALLOC_IDR(uverbs_free_flow_action),
 -	&UVERBS_METHOD(UVERBS_METHOD_FLOW_ACTION_ESP_CREATE),
 -	&UVERBS_METHOD(UVERBS_METHOD_FLOW_ACTION_DESTROY),
 -	&UVERBS_METHOD(UVERBS_METHOD_FLOW_ACTION_ESP_MODIFY));
diff --cc drivers/infiniband/core/uverbs_std_types_mr.c
index 68f7cadf088f,c1b9124d611e..000000000000
--- a/drivers/infiniband/core/uverbs_std_types_mr.c
+++ b/drivers/infiniband/core/uverbs_std_types_mr.c
@@@ -115,33 -115,37 +115,65 @@@ err_dereg
  	return ret;
  }
  
++<<<<<<< HEAD
 +static DECLARE_UVERBS_NAMED_METHOD(UVERBS_METHOD_DM_MR_REG,
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_REG_DM_MR_HANDLE, UVERBS_OBJECT_MR,
 +			 UVERBS_ACCESS_NEW,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_REG_DM_MR_OFFSET,
 +			    UVERBS_ATTR_TYPE(u64),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_REG_DM_MR_LENGTH,
 +			    UVERBS_ATTR_TYPE(u64),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_REG_DM_MR_PD_HANDLE, UVERBS_OBJECT_PD,
 +			 UVERBS_ACCESS_READ,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_REG_DM_MR_ACCESS_FLAGS,
 +			    UVERBS_ATTR_TYPE(u32),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_REG_DM_MR_DM_HANDLE, UVERBS_OBJECT_DM,
 +			 UVERBS_ACCESS_READ,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_REG_DM_MR_RESP_LKEY,
 +			     UVERBS_ATTR_TYPE(u32),
 +			     UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_REG_DM_MR_RESP_RKEY,
 +			     UVERBS_ATTR_TYPE(u32),
 +			     UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
++=======
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	UVERBS_METHOD_DM_MR_REG,
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_REG_DM_MR_HANDLE,
+ 			UVERBS_OBJECT_MR,
+ 			UVERBS_ACCESS_NEW,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_REG_DM_MR_OFFSET,
+ 			   UVERBS_ATTR_TYPE(u64),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_REG_DM_MR_LENGTH,
+ 			   UVERBS_ATTR_TYPE(u64),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_REG_DM_MR_PD_HANDLE,
+ 			UVERBS_OBJECT_PD,
+ 			UVERBS_ACCESS_READ,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_REG_DM_MR_ACCESS_FLAGS,
+ 			   UVERBS_ATTR_TYPE(u32),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_REG_DM_MR_DM_HANDLE,
+ 			UVERBS_OBJECT_DM,
+ 			UVERBS_ACCESS_READ,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_REG_DM_MR_RESP_LKEY,
+ 			    UVERBS_ATTR_TYPE(u32),
+ 			    UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_REG_DM_MR_RESP_RKEY,
+ 			    UVERBS_ATTR_TYPE(u32),
+ 			    UA_MANDATORY));
++>>>>>>> 83bb4442330f (RDMA/uverbs: Remove UA_FLAGS)
  
 -DECLARE_UVERBS_NAMED_OBJECT(
 -	UVERBS_OBJECT_MR,
 -	UVERBS_TYPE_ALLOC_IDR(uverbs_free_mr),
 -	&UVERBS_METHOD(UVERBS_METHOD_DM_MR_REG));
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_MR,
 +			    /* 1 is used in order to free the MR after all the MWs */
 +			    &UVERBS_TYPE_ALLOC_IDR(1, uverbs_free_mr),
 +			    &UVERBS_METHOD(UVERBS_METHOD_DM_MR_REG));
diff --cc drivers/infiniband/hw/mlx5/main.c
index b694e9761d0f,54d45e13de34..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -5204,22 -5315,26 +5204,43 @@@ static void mlx5_ib_cleanup_multiport_m
  	mlx5_nic_vport_disable_roce(dev->mdev);
  }
  
++<<<<<<< HEAD
 +ADD_UVERBS_ATTRIBUTES_SIMPLE(mlx5_ib_dm, UVERBS_OBJECT_DM,
 +			     UVERBS_METHOD_DM_ALLOC,
 +			     &UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_ALLOC_DM_RESP_START_OFFSET,
 +						  UVERBS_ATTR_TYPE(u64),
 +						  UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +			     &UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_ALLOC_DM_RESP_PAGE_INDEX,
 +						  UVERBS_ATTR_TYPE(u16),
 +						  UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
 +
 +ADD_UVERBS_ATTRIBUTES_SIMPLE(mlx5_ib_flow_action, UVERBS_OBJECT_FLOW_ACTION,
 +			     UVERBS_METHOD_FLOW_ACTION_ESP_CREATE,
 +			     &UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_CREATE_FLOW_ACTION_FLAGS,
 +						 UVERBS_ATTR_TYPE(u64),
 +						 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
++=======
+ ADD_UVERBS_ATTRIBUTES_SIMPLE(
+ 	mlx5_ib_dm,
+ 	UVERBS_OBJECT_DM,
+ 	UVERBS_METHOD_DM_ALLOC,
+ 	UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_ALLOC_DM_RESP_START_OFFSET,
+ 			    UVERBS_ATTR_TYPE(u64),
+ 			    UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_ALLOC_DM_RESP_PAGE_INDEX,
+ 			    UVERBS_ATTR_TYPE(u16),
+ 			    UA_MANDATORY));
+ 
+ ADD_UVERBS_ATTRIBUTES_SIMPLE(
+ 	mlx5_ib_flow_action,
+ 	UVERBS_OBJECT_FLOW_ACTION,
+ 	UVERBS_METHOD_FLOW_ACTION_ESP_CREATE,
+ 	UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_CREATE_FLOW_ACTION_FLAGS,
+ 			   UVERBS_ATTR_TYPE(u64),
+ 			   UA_MANDATORY));
++>>>>>>> 83bb4442330f (RDMA/uverbs: Remove UA_FLAGS)
  
 -#define NUM_TREES	3
 +#define NUM_TREES	2
  static int populate_specs_root(struct mlx5_ib_dev *dev)
  {
  	const struct uverbs_object_tree_def *default_root[NUM_TREES + 1] = {
diff --cc include/rdma/uverbs_ioctl.h
index 90a4947ff548,6073fd9d9c49..000000000000
--- a/include/rdma/uverbs_ioctl.h
+++ b/include/rdma/uverbs_ioctl.h
@@@ -61,38 -61,32 +61,46 @@@ enum uverbs_obj_access 
  	UVERBS_ACCESS_DESTROY
  };
  
- enum {
- 	UVERBS_ATTR_SPEC_F_MANDATORY	= 1U << 0,
- 	/* Support extending attributes by length, validate all unknown size == zero  */
- 	UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO = 1U << 1,
+ /* Specification of a single attribute inside the ioctl message */
+ /* good size 16 */
+ struct uverbs_attr_spec {
++<<<<<<< HEAD
++=======
+ 	u8 type;
+ 
  	/*
- 	 * Valid only for PTR_IN. Allocate and copy the data inside the parser
+ 	 * Support extending attributes by length, validate all
+ 	 * unknown size == zero
  	 */
- 	UVERBS_ATTR_SPEC_F_ALLOC_AND_COPY = 1U << 2,
- };
+ 	u8 min_sz_or_zero:1;
+ 	/*
+ 	 * Valid only for PTR_IN. Allocate and copy the data inside
+ 	 * the parser
+ 	 */
+ 	u8 alloc_and_copy:1;
+ 	u8 mandatory:1;
  
- /* Specification of a single attribute inside the ioctl message */
- struct uverbs_attr_spec {
++>>>>>>> 83bb4442330f (RDMA/uverbs: Remove UA_FLAGS)
  	union {
 +		/* Header shared by all following union members - to reduce space. */
  		struct {
 +			enum uverbs_attr_type		type;
 +			/* Combination of bits from enum UVERBS_ATTR_SPEC_F_XXXX */
 +			u8				flags;
 +		};
 +		struct {
 +			enum uverbs_attr_type		type;
 +			/* Combination of bits from enum UVERBS_ATTR_SPEC_F_XXXX */
 +			u8				flags;
  			/* Current known size to kernel */
 -			u16 len;
 +			u16				len;
  			/* User isn't allowed to provide something < min_len */
 -			u16 min_len;
 +			u16				min_len;
  		} ptr;
 -
  		struct {
 +			enum uverbs_attr_type		type;
 +			/* Combination of bits from enum UVERBS_ATTR_SPEC_F_XXXX */
 +			u8				flags;
  			/*
  			 * higher bits mean the namespace and lower bits mean
  			 * the type id within the namespace.
@@@ -218,110 -210,83 +226,172 @@@ struct uverbs_object_tree_def 
  #define UVERBS_ATTR_MIN_SIZE(_min_len)				\
  	UVERBS_ATTR_SIZE(_min_len, USHRT_MAX)
  
++<<<<<<< HEAD
 +/*
 + * In new compiler, UVERBS_ATTR could be simplified by declaring it as
 + * [_id] = {.type = _type, .len = _len, ##__VA_ARGS__}
 + * But since we support older compilers too, we need the more complex code.
 + */
 +#define UVERBS_ATTR(_id, _type, _fld, _attr, ...)			\
 +	__UVERBS_ATTR(_id, _type, _fld, _attr, ##__VA_ARGS__, 2, 1, 0)
 +#define UVERBS_ATTR_PTR_IN_SZ(_id, _len, ...)				\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_PTR_IN, ptr, _len, ##__VA_ARGS__)
 +/* If sizeof(_type) <= sizeof(u64), this will be inlined rather than a pointer */
 +#define UVERBS_ATTR_PTR_IN(_id, _type, ...)				\
 +	UVERBS_ATTR_PTR_IN_SZ(_id, _type, ##__VA_ARGS__)
 +#define UVERBS_ATTR_PTR_OUT_SZ(_id, _len, ...)				\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_PTR_OUT, ptr, _len, ##__VA_ARGS__)
 +#define UVERBS_ATTR_PTR_OUT(_id, _type, ...)				\
 +	UVERBS_ATTR_PTR_OUT_SZ(_id, _type, ##__VA_ARGS__)
 +#define UVERBS_ATTR_ENUM_IN(_id, _enum_arr, ...)			\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_ENUM_IN, enum_def,		\
 +		    .ids = (_enum_arr),					\
 +		    .num_elems = ARRAY_SIZE(_enum_arr), ##__VA_ARGS__)
++=======
+ /* Must be used in the '...' of any UVERBS_ATTR */
+ #define UA_ALLOC_AND_COPY .alloc_and_copy = 1
+ #define UA_MANDATORY .mandatory = 1
+ #define UA_MIN_SZ_OR_ZERO .min_sz_or_zero = 1
+ #define UA_OPTIONAL .mandatory = 0
+ 
+ #define UVERBS_ATTR_IDR(_attr_id, _idr_type, _access, ...)                     \
+ 	(&(const struct uverbs_attr_def){                                      \
+ 		.id = _attr_id,                                                \
+ 		.attr = { .type = UVERBS_ATTR_TYPE_IDR,                        \
+ 			  .u.obj.obj_type = _idr_type,                         \
+ 			  .u.obj.access = _access,                             \
+ 			  __VA_ARGS__ } })
+ 
+ #define UVERBS_ATTR_FD(_attr_id, _fd_type, _access, ...)                       \
+ 	(&(const struct uverbs_attr_def){                                      \
+ 		.id = (_attr_id) +                                             \
+ 		      BUILD_BUG_ON_ZERO((_access) != UVERBS_ACCESS_NEW &&      \
+ 					(_access) != UVERBS_ACCESS_READ),      \
+ 		.attr = { .type = UVERBS_ATTR_TYPE_FD,                         \
+ 			  .u.obj.obj_type = _fd_type,                          \
+ 			  .u.obj.access = _access,                             \
+ 			  __VA_ARGS__ } })
+ 
+ #define UVERBS_ATTR_PTR_IN(_attr_id, _type, ...)                               \
+ 	(&(const struct uverbs_attr_def){                                      \
+ 		.id = _attr_id,                                                \
+ 		.attr = { .type = UVERBS_ATTR_TYPE_PTR_IN,                     \
+ 			  _type,                                               \
+ 			  __VA_ARGS__ } })
+ 
+ #define UVERBS_ATTR_PTR_OUT(_attr_id, _type, ...)                              \
+ 	(&(const struct uverbs_attr_def){                                      \
+ 		.id = _attr_id,                                                \
+ 		.attr = { .type = UVERBS_ATTR_TYPE_PTR_OUT,                    \
+ 			  _type,                                               \
+ 			  __VA_ARGS__ } })
+ 
+ /* _enum_arry should be a 'static const union uverbs_attr_spec[]' */
+ #define UVERBS_ATTR_ENUM_IN(_attr_id, _enum_arr, ...)                          \
+ 	(&(const struct uverbs_attr_def){                                      \
+ 		.id = _attr_id,                                                \
+ 		.attr = { .type = UVERBS_ATTR_TYPE_ENUM_IN,                    \
+ 			  .u2.enum_def.ids = _enum_arr,                        \
+ 			  .u.enum_def.num_elems = ARRAY_SIZE(_enum_arr),       \
+ 			  __VA_ARGS__ },                                       \
+ 	})
++>>>>>>> 83bb4442330f (RDMA/uverbs: Remove UA_FLAGS)
  
  /*
 - * This spec is used in order to pass information to the hardware driver in a
 - * legacy way. Every verb that could get driver specific data should get this
 - * spec.
 + * In new compiler, UVERBS_ATTR_IDR (and FD) could be simplified by declaring
 + * it as
 + * {.id = _id,								\
 + *  .attr {.type = __obj_class,						\
 + *         .obj = {.obj_type = _idr_type,				\
 + *                       .access = _access                              \
 + *                }, ##__VA_ARGS__ } }
 + * But since we support older compilers too, we need the more complex code.
   */
++<<<<<<< HEAD
 +#define ___UVERBS_ATTR_OBJ0(_id, _obj_class, _obj_type, _access, ...)\
 +	((const struct uverbs_attr_def)					\
 +	{.id = _id,							\
 +	 .attr = { {.obj = {.type = _obj_class, .obj_type = _obj_type,	\
 +			    .access = _access, .flags = 0 } }, } })
 +#define ___UVERBS_ATTR_OBJ1(_id, _obj_class, _obj_type, _access, _flags)\
 +	((const struct uverbs_attr_def)					\
 +	{.id = _id,							\
 +	.attr = { {.obj = {.type = _obj_class, .obj_type = _obj_type,	\
 +			   .access = _access, _flags} }, } })
 +#define ___UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access, _flags, \
 +			   _n, ...)					\
 +	___UVERBS_ATTR_OBJ##_n(_id, _obj_class, _obj_type, _access, _flags)
 +#define __UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access, ...)	\
 +	___UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access,		\
 +			   ##__VA_ARGS__, 1, 0)
 +#define UVERBS_ATTR_IDR(_id, _idr_type, _access, ...)			 \
 +	__UVERBS_ATTR_OBJ(_id, UVERBS_ATTR_TYPE_IDR, _idr_type, _access,\
 +			  ##__VA_ARGS__)
 +#define UVERBS_ATTR_FD(_id, _fd_type, _access, ...)			\
 +	__UVERBS_ATTR_OBJ(_id, UVERBS_ATTR_TYPE_FD, _fd_type,		\
 +			  (_access) + BUILD_BUG_ON_ZERO(		\
 +				(_access) != UVERBS_ACCESS_NEW &&	\
 +				(_access) != UVERBS_ACCESS_READ),	\
 +			  ##__VA_ARGS__)
 +#define DECLARE_UVERBS_ATTR_SPEC(_name, ...)				\
 +	const struct uverbs_attr_def _name = __VA_ARGS__
++=======
+ #define UVERBS_ATTR_UHW()                                                      \
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_UHW_IN,                                 \
+ 			   UVERBS_ATTR_SIZE(0, USHRT_MAX),		       \
+ 			   UA_OPTIONAL,					       \
+ 			   UA_MIN_SZ_OR_ZERO),				       \
+ 	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_UHW_OUT,                               \
+ 			    UVERBS_ATTR_SIZE(0, USHRT_MAX),		       \
+ 			    UA_OPTIONAL,				       \
+ 			    UA_MIN_SZ_OR_ZERO),				       \
++>>>>>>> 83bb4442330f (RDMA/uverbs: Remove UA_FLAGS)
  
 -/*
 - * =======================================
 - *	Declaration helpers
 - * =======================================
 - */
 -
 -#define DECLARE_UVERBS_OBJECT_TREE(_name, ...)                                 \
 -	static const struct uverbs_object_def *const _name##_ptr[] = {         \
 -		__VA_ARGS__,                                                   \
 -	};                                                                     \
 -	static const struct uverbs_object_tree_def _name = {                   \
 -		.num_objects = ARRAY_SIZE(_name##_ptr),                        \
 -		.objects = &_name##_ptr,                                       \
 +#define DECLARE_UVERBS_ENUM(_name, ...)					\
 +	const struct uverbs_enum_spec _name = {				\
 +		.len = ARRAY_SIZE(((struct uverbs_attr_spec[]){__VA_ARGS__})),\
 +		.ids = {__VA_ARGS__},					\
  	}
 +#define _UVERBS_METHOD_ATTRS_SZ(...)					\
 +	(sizeof((const struct uverbs_attr_def * const []){__VA_ARGS__}) /\
 +	 sizeof(const struct uverbs_attr_def *))
 +#define _UVERBS_METHOD(_id, _handler, _flags, ...)			\
 +	((const struct uverbs_method_def) {				\
 +	 .id = _id,							\
 +	 .flags = _flags,						\
 +	 .handler = _handler,						\
 +	 .num_attrs = _UVERBS_METHOD_ATTRS_SZ(__VA_ARGS__),		\
 +	 .attrs = &(const struct uverbs_attr_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_METHOD(_name, _id, _handler, ...)		\
 +	const struct uverbs_method_def _name =				\
 +		_UVERBS_METHOD(_id, _handler, 0, ##__VA_ARGS__)
 +#define DECLARE_UVERBS_CTX_METHOD(_name, _id, _handler, _flags, ...)	\
 +	const struct uverbs_method_def _name =				\
 +		_UVERBS_METHOD(_id, _handler,				\
 +			       UVERBS_ACTION_FLAG_CREATE_ROOT,		\
 +			       ##__VA_ARGS__)
 +#define _UVERBS_OBJECT_METHODS_SZ(...)					\
 +	(sizeof((const struct uverbs_method_def * const []){__VA_ARGS__}) / \
 +	 sizeof(const struct uverbs_method_def *))
 +#define _UVERBS_OBJECT(_id, _type_attrs, ...)				\
 +	((const struct uverbs_object_def) {				\
 +	 .id = _id,							\
 +	 .type_attrs = _type_attrs,					\
 +	 .num_methods = _UVERBS_OBJECT_METHODS_SZ(__VA_ARGS__),		\
 +	 .methods = &(const struct uverbs_method_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_OBJECT(_name, _id, _type_attrs, ...)		\
 +	const struct uverbs_object_def _name =				\
 +		_UVERBS_OBJECT(_id, _type_attrs, ##__VA_ARGS__)
 +#define _UVERBS_TREE_OBJECTS_SZ(...)					\
 +	(sizeof((const struct uverbs_object_def * const []){__VA_ARGS__}) / \
 +	 sizeof(const struct uverbs_object_def *))
 +#define _UVERBS_OBJECT_TREE(...)					\
 +	((const struct uverbs_object_tree_def) {			\
 +	 .num_objects = _UVERBS_TREE_OBJECTS_SZ(__VA_ARGS__),		\
 +	 .objects = &(const struct uverbs_object_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_OBJECT_TREE(_name, ...)				\
 +	const struct uverbs_object_tree_def _name =			\
 +		_UVERBS_OBJECT_TREE(__VA_ARGS__)
  
  /* =================================================
   *              Parsing infrastructure
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
* Unmerged path drivers/infiniband/core/uverbs_ioctl.c
diff --git a/drivers/infiniband/core/uverbs_ioctl_merge.c b/drivers/infiniband/core/uverbs_ioctl_merge.c
index 6ceb672c4d46..5bd842e73a3e 100644
--- a/drivers/infiniband/core/uverbs_ioctl_merge.c
+++ b/drivers/infiniband/core/uverbs_ioctl_merge.c
@@ -374,18 +374,18 @@ static struct uverbs_method_spec *build_method_with_attrs(const struct uverbs_me
 				 "ib_uverbs: Method contains more than one object attr (%d) with new/destroy access\n",
 				 min_id) ||
 			    WARN(attr_obj_with_special_access &&
-				 !(attr->flags & UVERBS_ATTR_SPEC_F_MANDATORY),
+				 !attr->mandatory,
 				 "ib_uverbs: Tried to merge attr (%d) but it's an object with new/destroy access but isn't mandatory\n",
 				 min_id) ||
 			    WARN(IS_ATTR_OBJECT(attr) &&
-				 attr->flags & UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO,
+				 attr->min_sz_or_zero,
 				 "ib_uverbs: Tried to merge attr (%d) but it's an object with min_sz flag\n",
 				 min_id)) {
 				res = -EINVAL;
 				goto free;
 			}
 
-			if (attr->flags & UVERBS_ATTR_SPEC_F_MANDATORY)
+			if (attr->mandatory)
 				set_bit(min_id, hash->mandatory_attrs_bitmask);
 			min_id++;
 
* Unmerged path drivers/infiniband/core/uverbs_std_types_counters.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_cq.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_dm.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_flow_action.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_mr.c
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
* Unmerged path drivers/infiniband/hw/mlx5/main.c
* Unmerged path include/rdma/uverbs_ioctl.h
