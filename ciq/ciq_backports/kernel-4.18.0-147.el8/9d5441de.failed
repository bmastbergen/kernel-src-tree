drm/i915: Populate gamma_mode for all platforms

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit 9d5441de28e2b1e5087ce63c4fe9e0b1c5b3fcaa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/9d5441de.failed

On pre-HSW gamma mode is configured via PIPECONF. The bits are
the same except shifted up, so we can reuse just store them in
crtc_state->gamma_mode in the HSW+ way, allowing us to share
some code later.

v2: Allow fastboot with gamma_mode changes (Maarten)
    Add space around the '<<' in the reg macro
    Deal with HAS_GMCH

	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
	Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190207202146.26423-2-ville.syrjala@linux.intel.com
(cherry picked from commit 9d5441de28e2b1e5087ce63c4fe9e0b1c5b3fcaa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/i915_reg.h
#	drivers/gpu/drm/i915/intel_color.c
#	drivers/gpu/drm/i915/intel_display.c
diff --cc drivers/gpu/drm/i915/i915_reg.h
index 7720569f2024,c3bc99d9a904..000000000000
--- a/drivers/gpu/drm/i915/i915_reg.h
+++ b/drivers/gpu/drm/i915/i915_reg.h
@@@ -5384,18 -5581,24 +5384,31 @@@ enum 
  #define   DSL_LINEMASK_GEN2	0x00000fff
  #define   DSL_LINEMASK_GEN3	0x00001fff
  #define _PIPEACONF		0x70008
 -#define   PIPECONF_ENABLE	(1 << 31)
 +#define   PIPECONF_ENABLE	(1<<31)
  #define   PIPECONF_DISABLE	0
 -#define   PIPECONF_DOUBLE_WIDE	(1 << 30)
 -#define   I965_PIPECONF_ACTIVE	(1 << 30)
 -#define   PIPECONF_DSI_PLL_LOCKED	(1 << 29) /* vlv & pipe A only */
 -#define   PIPECONF_FRAME_START_DELAY_MASK (3 << 27)
 +#define   PIPECONF_DOUBLE_WIDE	(1<<30)
 +#define   I965_PIPECONF_ACTIVE	(1<<30)
 +#define   PIPECONF_DSI_PLL_LOCKED	(1<<29) /* vlv & pipe A only */
 +#define   PIPECONF_FRAME_START_DELAY_MASK (3<<27)
  #define   PIPECONF_SINGLE_WIDE	0
  #define   PIPECONF_PIPE_UNLOCKED 0
++<<<<<<< HEAD
 +#define   PIPECONF_PIPE_LOCKED	(1<<25)
 +#define   PIPECONF_PALETTE	0
 +#define   PIPECONF_GAMMA		(1<<24)
 +#define   PIPECONF_FORCE_BORDER	(1<<25)
++=======
+ #define   PIPECONF_PIPE_LOCKED	(1 << 25)
+ #define   PIPECONF_FORCE_BORDER	(1 << 25)
+ #define   PIPECONF_GAMMA_MODE_MASK_I9XX	(1 << 24) /* gmch */
+ #define   PIPECONF_GAMMA_MODE_MASK_ILK	(3 << 24) /* ilk-ivb */
+ #define   PIPECONF_GAMMA_MODE_8BIT	(0 << 24) /* gmch,ilk-ivb */
+ #define   PIPECONF_GAMMA_MODE_10BIT	(1 << 24) /* gmch,ilk-ivb */
+ #define   PIPECONF_GAMMA_MODE_12BIT	(2 << 24) /* ilk-ivb */
+ #define   PIPECONF_GAMMA_MODE_SPLIT	(3 << 24) /* ivb */
+ #define   PIPECONF_GAMMA_MODE(x)	((x) << 24) /* pass in GAMMA_MODE_MODE_* */
+ #define   PIPECONF_GAMMA_MODE_SHIFT	24
++>>>>>>> 9d5441de28e2 (drm/i915: Populate gamma_mode for all platforms)
  #define   PIPECONF_INTERLACE_MASK	(7 << 21)
  #define   PIPECONF_INTERLACE_MASK_HSW	(3 << 21)
  /* Note that pre-gen3 does not support interlaced display directly. Panel
diff --cc drivers/gpu/drm/i915/intel_color.c
index c6a7beabd58d,86915125d17c..000000000000
--- a/drivers/gpu/drm/i915/intel_color.c
+++ b/drivers/gpu/drm/i915/intel_color.c
@@@ -352,47 -346,54 +352,77 @@@ static void i9xx_load_luts_internal(str
  	}
  }
  
 -static void i9xx_load_luts(const struct intel_crtc_state *crtc_state)
 +static void i9xx_load_luts(struct drm_crtc_state *crtc_state)
  {
 -	i9xx_load_luts_internal(crtc_state, crtc_state->base.gamma_lut);
 +	i9xx_load_luts_internal(crtc_state->crtc, crtc_state->gamma_lut,
 +				to_intel_crtc_state(crtc_state));
  }
  
++<<<<<<< HEAD
 +/* Loads the legacy palette/gamma unit for the CRTC on Haswell. */
 +static void haswell_load_luts(struct drm_crtc_state *crtc_state)
++=======
+ static void i9xx_color_commit(const struct intel_crtc_state *crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->base.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	enum pipe pipe = crtc->pipe;
+ 	u32 val;
+ 
+ 	val = I915_READ(PIPECONF(pipe));
+ 	val &= ~PIPECONF_GAMMA_MODE_MASK_I9XX;
+ 	val |= PIPECONF_GAMMA_MODE(crtc_state->gamma_mode);
+ 	I915_WRITE(PIPECONF(pipe), val);
+ }
+ 
+ static void ilk_color_commit(const struct intel_crtc_state *crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->base.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	enum pipe pipe = crtc->pipe;
+ 	u32 val;
+ 
+ 	val = I915_READ(PIPECONF(pipe));
+ 	val &= ~PIPECONF_GAMMA_MODE_MASK_ILK;
+ 	val |= PIPECONF_GAMMA_MODE(crtc_state->gamma_mode);
+ 	I915_WRITE(PIPECONF(pipe), val);
+ }
+ 
+ static void hsw_color_commit(const struct intel_crtc_state *crtc_state)
++>>>>>>> 9d5441de28e2 (drm/i915: Populate gamma_mode for all platforms)
  {
 -	struct intel_crtc *crtc = to_intel_crtc(crtc_state->base.crtc);
 -	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
 +	struct drm_crtc *crtc = crtc_state->crtc;
 +	struct drm_device *dev = crtc->dev;
 +	struct drm_i915_private *dev_priv = to_i915(dev);
 +	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
 +	struct intel_crtc_state *intel_crtc_state =
 +		to_intel_crtc_state(crtc_state);
 +	bool reenable_ips = false;
 +
 +	/*
 +	 * Workaround : Do not read or write the pipe palette/gamma data while
 +	 * GAMMA_MODE is configured for split gamma and IPS_CTL has IPS enabled.
 +	 */
 +	if (IS_HASWELL(dev_priv) && intel_crtc_state->ips_enabled &&
 +	    (intel_crtc_state->gamma_mode == GAMMA_MODE_MODE_SPLIT)) {
 +		hsw_disable_ips(intel_crtc_state);
 +		reenable_ips = true;
 +	}
 +
 +	intel_crtc_state->gamma_mode = GAMMA_MODE_MODE_8BIT;
 +	I915_WRITE(GAMMA_MODE(intel_crtc->pipe), GAMMA_MODE_MODE_8BIT);
  
 -	I915_WRITE(GAMMA_MODE(crtc->pipe), crtc_state->gamma_mode);
 +	i9xx_load_luts(crtc_state);
  
 -	ilk_load_csc_matrix(crtc_state);
 +	if (reenable_ips)
 +		hsw_enable_ips(intel_crtc_state);
  }
  
 -static void bdw_load_degamma_lut(const struct intel_crtc_state *crtc_state)
 +static void bdw_load_degamma_lut(struct drm_crtc_state *state)
  {
 -	struct intel_crtc *crtc = to_intel_crtc(crtc_state->base.crtc);
 -	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
 -	const struct drm_property_blob *degamma_lut = crtc_state->base.degamma_lut;
 -	u32 i, lut_size = INTEL_INFO(dev_priv)->color.degamma_lut_size;
 -	enum pipe pipe = crtc->pipe;
 +	struct drm_i915_private *dev_priv = to_i915(state->crtc->dev);
 +	enum pipe pipe = to_intel_crtc(state->crtc)->pipe;
 +	uint32_t i, lut_size = INTEL_INFO(dev_priv)->color.degamma_lut_size;
  
  	I915_WRITE(PREC_PAL_INDEX(pipe),
  		   PAL_PREC_SPLIT_MODE | PAL_PREC_AUTO_INCREMENT);
@@@ -613,56 -607,92 +643,108 @@@ void intel_color_load_luts(struct drm_c
  	dev_priv->display.load_luts(crtc_state);
  }
  
 -void intel_color_commit(const struct intel_crtc_state *crtc_state)
 +int intel_color_check(struct drm_crtc *crtc,
 +		      struct drm_crtc_state *crtc_state)
  {
++<<<<<<< HEAD
 +	struct drm_i915_private *dev_priv = to_i915(crtc->dev);
 +	size_t gamma_length, degamma_length;
++=======
+ 	struct drm_i915_private *dev_priv = to_i915(crtc_state->base.crtc->dev);
+ 
+ 	dev_priv->display.color_commit(crtc_state);
+ }
+ 
+ static int check_lut_size(const struct drm_property_blob *lut, int expected)
+ {
+ 	int len;
+ 
+ 	if (!lut)
+ 		return 0;
+ 
+ 	len = drm_color_lut_size(lut);
+ 	if (len != expected) {
+ 		DRM_DEBUG_KMS("Invalid LUT size; got %d, expected %d\n",
+ 			      len, expected);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ int intel_color_check(struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(crtc_state->base.crtc->dev);
+ 	const struct drm_property_blob *gamma_lut = crtc_state->base.gamma_lut;
+ 	const struct drm_property_blob *degamma_lut = crtc_state->base.degamma_lut;
+ 	int gamma_length, degamma_length;
+ 	u32 gamma_tests, degamma_tests;
++>>>>>>> 9d5441de28e2 (drm/i915: Populate gamma_mode for all platforms)
  
  	degamma_length = INTEL_INFO(dev_priv)->color.degamma_lut_size;
  	gamma_length = INTEL_INFO(dev_priv)->color.gamma_lut_size;
 -	degamma_tests = INTEL_INFO(dev_priv)->color.degamma_lut_tests;
 -	gamma_tests = INTEL_INFO(dev_priv)->color.gamma_lut_tests;
  
 -	/* Always allow legacy gamma LUT with no further checking. */
 -	if (crtc_state_is_legacy_gamma(crtc_state)) {
 -		crtc_state->gamma_mode = GAMMA_MODE_MODE_8BIT;
 +	/*
 +	 * We allow both degamma & gamma luts at the right size or
 +	 * NULL.
 +	 */
 +	if ((!crtc_state->degamma_lut ||
 +	     drm_color_lut_size(crtc_state->degamma_lut) == degamma_length) &&
 +	    (!crtc_state->gamma_lut ||
 +	     drm_color_lut_size(crtc_state->gamma_lut) == gamma_length))
  		return 0;
 -	}
  
 -	if (check_lut_size(degamma_lut, degamma_length) ||
 -	    check_lut_size(gamma_lut, gamma_length))
 -		return -EINVAL;
 -
 -	if (drm_color_lut_check(degamma_lut, degamma_tests) ||
 -	    drm_color_lut_check(gamma_lut, gamma_tests))
 -		return -EINVAL;
 -
 -	if (INTEL_GEN(dev_priv) >= 10 || IS_GEMINILAKE(dev_priv))
 -		crtc_state->gamma_mode = GAMMA_MODE_MODE_10BIT;
 -	else if (INTEL_GEN(dev_priv) >= 9 || IS_BROADWELL(dev_priv))
 -		crtc_state->gamma_mode = GAMMA_MODE_MODE_SPLIT;
 -	else
 -		crtc_state->gamma_mode = GAMMA_MODE_MODE_8BIT;
 +	/*
 +	 * We also allow no degamma lut/ctm and a gamma lut at the legacy
 +	 * size (256 entries).
 +	 */
 +	if (crtc_state_is_legacy_gamma(crtc_state))
 +		return 0;
  
 -	return 0;
 +	return -EINVAL;
  }
  
 -void intel_color_init(struct intel_crtc *crtc)
 +void intel_color_init(struct drm_crtc *crtc)
  {
 -	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
 -
 -	drm_mode_crtc_set_gamma_size(&crtc->base, 256);
 -
 +	struct drm_i915_private *dev_priv = to_i915(crtc->dev);
 +
 +	drm_mode_crtc_set_gamma_size(crtc, 256);
 +
++<<<<<<< HEAD
 +	if (IS_CHERRYVIEW(dev_priv)) {
 +		dev_priv->display.load_csc_matrix = cherryview_load_csc_matrix;
 +		dev_priv->display.load_luts = cherryview_load_luts;
 +	} else if (IS_HASWELL(dev_priv)) {
 +		dev_priv->display.load_csc_matrix = ilk_load_csc_matrix;
 +		dev_priv->display.load_luts = haswell_load_luts;
 +	} else if (IS_BROADWELL(dev_priv) || IS_GEN9_BC(dev_priv) ||
 +		   IS_BROXTON(dev_priv)) {
 +		dev_priv->display.load_csc_matrix = ilk_load_csc_matrix;
 +		dev_priv->display.load_luts = broadwell_load_luts;
 +	} else if (IS_GEMINILAKE(dev_priv) || IS_CANNONLAKE(dev_priv)) {
 +		dev_priv->display.load_csc_matrix = ilk_load_csc_matrix;
 +		dev_priv->display.load_luts = glk_load_luts;
++=======
+ 	if (HAS_GMCH(dev_priv)) {
+ 		if (IS_CHERRYVIEW(dev_priv))
+ 			dev_priv->display.load_luts = cherryview_load_luts;
+ 		else
+ 			dev_priv->display.load_luts = i9xx_load_luts;
+ 
+ 		dev_priv->display.color_commit = i9xx_color_commit;
++>>>>>>> 9d5441de28e2 (drm/i915: Populate gamma_mode for all platforms)
  	} else {
- 		dev_priv->display.load_luts = i9xx_load_luts;
+ 		if (IS_CANNONLAKE(dev_priv) || IS_GEMINILAKE(dev_priv))
+ 			dev_priv->display.load_luts = glk_load_luts;
+ 		else if (INTEL_GEN(dev_priv) >= 9 || IS_BROADWELL(dev_priv))
+ 			dev_priv->display.load_luts = broadwell_load_luts;
+ 		else
+ 			dev_priv->display.load_luts = i9xx_load_luts;
+ 
+ 		if (INTEL_GEN(dev_priv) >= 8 || IS_HASWELL(dev_priv))
+ 			dev_priv->display.color_commit = hsw_color_commit;
+ 		else
+ 			dev_priv->display.color_commit = ilk_color_commit;
  	}
  
  	/* Enable color management support when we have degamma & gamma LUTs. */
diff --cc drivers/gpu/drm/i915/intel_display.c
index dec0d60921bf,cd3241d336e9..000000000000
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@@ -3417,6 -3440,19 +3417,22 @@@ static void i9xx_disable_plane(struct i
  	struct drm_i915_private *dev_priv = to_i915(plane->base.dev);
  	enum i9xx_plane_id i9xx_plane = plane->i9xx_plane;
  	unsigned long irqflags;
++<<<<<<< HEAD
++=======
+ 	u32 dspcntr;
+ 
+ 	/*
+ 	 * DSPCNTR pipe gamma enable on g4x+ and pipe csc
+ 	 * enable on ilk+ affect the pipe bottom color as
+ 	 * well, so we must configure them even if the plane
+ 	 * is disabled.
+ 	 *
+ 	 * On pre-g4x there is no way to gamma correct the
+ 	 * pipe bottom color but we'll keep on doing this
+ 	 * anyway so that the crtc state readout works correctly.
+ 	 */
+ 	dspcntr = i9xx_plane_ctl_crtc(crtc_state);
++>>>>>>> 9d5441de28e2 (drm/i915: Populate gamma_mode for all platforms)
  
  	spin_lock_irqsave(&dev_priv->uncore.lock, irqflags);
  
@@@ -7417,11 -7689,13 +7433,18 @@@ static void i9xx_set_pipeconf(struct in
  		pipeconf |= PIPECONF_PROGRESSIVE;
  
  	if ((IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) &&
 -	     crtc_state->limited_color_range)
 +	     intel_crtc->config->limited_color_range)
  		pipeconf |= PIPECONF_COLOR_RANGE_SELECT;
  
++<<<<<<< HEAD
 +	I915_WRITE(PIPECONF(intel_crtc->pipe), pipeconf);
 +	POSTING_READ(PIPECONF(intel_crtc->pipe));
++=======
+ 	pipeconf |= PIPECONF_GAMMA_MODE(crtc_state->gamma_mode);
+ 
+ 	I915_WRITE(PIPECONF(crtc->pipe), pipeconf);
+ 	POSTING_READ(PIPECONF(crtc->pipe));
++>>>>>>> 9d5441de28e2 (drm/i915: Populate gamma_mode for all platforms)
  }
  
  static int i8xx_crtc_compute_clock(struct intel_crtc *crtc,
@@@ -8353,9 -8685,11 +8379,11 @@@ static void ironlake_set_pipeconf(struc
  	else
  		val |= PIPECONF_PROGRESSIVE;
  
 -	if (crtc_state->limited_color_range)
 +	if (intel_crtc->config->limited_color_range)
  		val |= PIPECONF_COLOR_RANGE_SELECT;
  
+ 	val |= PIPECONF_GAMMA_MODE(crtc_state->gamma_mode);
+ 
  	I915_WRITE(PIPECONF(pipe), val);
  	POSTING_READ(PIPECONF(pipe));
  }
* Unmerged path drivers/gpu/drm/i915/i915_reg.h
* Unmerged path drivers/gpu/drm/i915/intel_color.c
* Unmerged path drivers/gpu/drm/i915/intel_display.c
