net: tls: Add tests for TLS 1.3

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [net] tls: Add tests for TLS 1.3 (Sabrina Dubroca) [1711821]
Rebuild_FUZZ: 91.23%
commit-author Dave Watson <davejwatson@fb.com>
commit 8debd67e79daf655820557c51222004d0c43af43
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/8debd67e.failed

Change most tests to TLS 1.3, while adding tests for previous TLS 1.2
behavior.

	Signed-off-by: Dave Watson <davejwatson@fb.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8debd67e79daf655820557c51222004d0c43af43)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/net/tls.c
diff --cc tools/testing/selftests/net/tls.c
index f846f2589fa0,4ac50ccb3272..000000000000
--- a/tools/testing/selftests/net/tls.c
+++ b/tools/testing/selftests/net/tls.c
@@@ -713,4 -763,140 +713,143 @@@ TEST_F(tls, control_msg
  	EXPECT_EQ(memcmp(buf, test_str, send_len), 0);
  }
  
++<<<<<<< HEAD
++=======
+ TEST(keysizes) {
+ 	struct tls12_crypto_info_aes_gcm_256 tls12;
+ 	struct sockaddr_in addr;
+ 	int sfd, ret, fd, cfd;
+ 	socklen_t len;
+ 	bool notls;
+ 
+ 	notls = false;
+ 	len = sizeof(addr);
+ 
+ 	memset(&tls12, 0, sizeof(tls12));
+ 	tls12.info.version = TLS_1_2_VERSION;
+ 	tls12.info.cipher_type = TLS_CIPHER_AES_GCM_256;
+ 
+ 	addr.sin_family = AF_INET;
+ 	addr.sin_addr.s_addr = htonl(INADDR_ANY);
+ 	addr.sin_port = 0;
+ 
+ 	fd = socket(AF_INET, SOCK_STREAM, 0);
+ 	sfd = socket(AF_INET, SOCK_STREAM, 0);
+ 
+ 	ret = bind(sfd, &addr, sizeof(addr));
+ 	ASSERT_EQ(ret, 0);
+ 	ret = listen(sfd, 10);
+ 	ASSERT_EQ(ret, 0);
+ 
+ 	ret = getsockname(sfd, &addr, &len);
+ 	ASSERT_EQ(ret, 0);
+ 
+ 	ret = connect(fd, &addr, sizeof(addr));
+ 	ASSERT_EQ(ret, 0);
+ 
+ 	ret = setsockopt(fd, IPPROTO_TCP, TCP_ULP, "tls", sizeof("tls"));
+ 	if (ret != 0) {
+ 		notls = true;
+ 		printf("Failure setting TCP_ULP, testing without tls\n");
+ 	}
+ 
+ 	if (!notls) {
+ 		ret = setsockopt(fd, SOL_TLS, TLS_TX, &tls12,
+ 				 sizeof(tls12));
+ 		EXPECT_EQ(ret, 0);
+ 	}
+ 
+ 	cfd = accept(sfd, &addr, &len);
+ 	ASSERT_GE(cfd, 0);
+ 
+ 	if (!notls) {
+ 		ret = setsockopt(cfd, IPPROTO_TCP, TCP_ULP, "tls",
+ 				 sizeof("tls"));
+ 		EXPECT_EQ(ret, 0);
+ 
+ 		ret = setsockopt(cfd, SOL_TLS, TLS_RX, &tls12,
+ 				 sizeof(tls12));
+ 		EXPECT_EQ(ret, 0);
+ 	}
+ 
+ 	close(sfd);
+ 	close(fd);
+ 	close(cfd);
+ }
+ 
+ TEST(tls12) {
+ 	int fd, cfd;
+ 	bool notls;
+ 
+ 	struct tls12_crypto_info_aes_gcm_128 tls12;
+ 	struct sockaddr_in addr;
+ 	socklen_t len;
+ 	int sfd, ret;
+ 
+ 	notls = false;
+ 	len = sizeof(addr);
+ 
+ 	memset(&tls12, 0, sizeof(tls12));
+ 	tls12.info.version = TLS_1_2_VERSION;
+ 	tls12.info.cipher_type = TLS_CIPHER_AES_GCM_128;
+ 
+ 	addr.sin_family = AF_INET;
+ 	addr.sin_addr.s_addr = htonl(INADDR_ANY);
+ 	addr.sin_port = 0;
+ 
+ 	fd = socket(AF_INET, SOCK_STREAM, 0);
+ 	sfd = socket(AF_INET, SOCK_STREAM, 0);
+ 
+ 	ret = bind(sfd, &addr, sizeof(addr));
+ 	ASSERT_EQ(ret, 0);
+ 	ret = listen(sfd, 10);
+ 	ASSERT_EQ(ret, 0);
+ 
+ 	ret = getsockname(sfd, &addr, &len);
+ 	ASSERT_EQ(ret, 0);
+ 
+ 	ret = connect(fd, &addr, sizeof(addr));
+ 	ASSERT_EQ(ret, 0);
+ 
+ 	ret = setsockopt(fd, IPPROTO_TCP, TCP_ULP, "tls", sizeof("tls"));
+ 	if (ret != 0) {
+ 		notls = true;
+ 		printf("Failure setting TCP_ULP, testing without tls\n");
+ 	}
+ 
+ 	if (!notls) {
+ 		ret = setsockopt(fd, SOL_TLS, TLS_TX, &tls12,
+ 				 sizeof(tls12));
+ 		ASSERT_EQ(ret, 0);
+ 	}
+ 
+ 	cfd = accept(sfd, &addr, &len);
+ 	ASSERT_GE(cfd, 0);
+ 
+ 	if (!notls) {
+ 		ret = setsockopt(cfd, IPPROTO_TCP, TCP_ULP, "tls",
+ 				 sizeof("tls"));
+ 		ASSERT_EQ(ret, 0);
+ 
+ 		ret = setsockopt(cfd, SOL_TLS, TLS_RX, &tls12,
+ 				 sizeof(tls12));
+ 		ASSERT_EQ(ret, 0);
+ 	}
+ 
+ 	close(sfd);
+ 
+ 	char const *test_str = "test_read";
+ 	int send_len = 10;
+ 	char buf[10];
+ 
+ 	send_len = strlen(test_str) + 1;
+ 	EXPECT_EQ(send(fd, test_str, send_len, 0), send_len);
+ 	EXPECT_NE(recv(cfd, buf, send_len, 0), -1);
+ 	EXPECT_EQ(memcmp(buf, test_str, send_len), 0);
+ 
+ 	close(fd);
+ 	close(cfd);
+ }
+ 
++>>>>>>> 8debd67e79da (net: tls: Add tests for TLS 1.3)
  TEST_HARNESS_MAIN
* Unmerged path tools/testing/selftests/net/tls.c
