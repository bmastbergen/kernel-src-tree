net: tls: prevent false connection termination with offload

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [net] tls: prevent false connection termination with offload (Sabrina Dubroca) [1711821]
Rebuild_FUZZ: 95.58%
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit c43ac97bac987e56c179598ce3398a95d55067bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/c43ac97b.failed

Only decrypt_internal() performs zero copy on rx, all paths
which don't hit decrypt_internal() must set zc to false,
otherwise tls_sw_recvmsg() may return 0 causing the application
to believe that that connection got closed.

Currently this happens with device offload when new record
is first read from.

Fixes: d069b780e367 ("tls: Fix tls_device receive")
	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Simon Horman <simon.horman@netronome.com>
	Reported-by: David Beckett <david.beckett@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c43ac97bac987e56c179598ce3398a95d55067bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/tls/tls_sw.c
diff --cc net/tls/tls_sw.c
index 3f443983a6b3,20b191227969..000000000000
--- a/net/tls/tls_sw.c
+++ b/net/tls/tls_sw.c
@@@ -1229,19 -1465,35 +1229,26 @@@ static int decrypt_skb_update(struct so
  	struct strp_msg *rxm = strp_msg(skb);
  	int err = 0;
  
 -	if (!ctx->decrypted) {
  #ifdef CONFIG_TLS_DEVICE
 -		err = tls_device_decrypted(sk, skb);
 -		if (err < 0)
 -			return err;
 +	err = tls_device_decrypted(sk, skb);
 +	if (err < 0)
 +		return err;
  #endif
 -		/* Still not decrypted after tls_device */
 -		if (!ctx->decrypted) {
 -			err = decrypt_internal(sk, skb, dest, NULL, chunk, zc,
 -					       async);
 -			if (err < 0) {
 -				if (err == -EINPROGRESS)
 -					tls_advance_record_sn(sk, &tls_ctx->rx,
 -							      version);
 +	if (!ctx->decrypted) {
 +		err = decrypt_internal(sk, skb, dest, NULL, chunk, zc);
 +		if (err < 0) {
 +			if (err == -EINPROGRESS)
 +				tls_advance_record_sn(sk, &tls_ctx->rx);
  
++<<<<<<< HEAD
 +			return err;
++=======
+ 				return err;
+ 			}
+ 		} else {
+ 			*zc = false;
++>>>>>>> c43ac97bac98 (net: tls: prevent false connection termination with offload)
  		}
 -
 -		rxm->full_len -= padding_length(ctx, tls_ctx, skb);
 -		rxm->offset += prot->prepend_size;
 -		rxm->full_len -= prot->overhead_size;
 -		tls_advance_record_sn(sk, &tls_ctx->rx, version);
 -		ctx->decrypted = true;
 -		ctx->saved_data_ready(sk);
  	} else {
  		*zc = false;
  	}
* Unmerged path net/tls/tls_sw.c
