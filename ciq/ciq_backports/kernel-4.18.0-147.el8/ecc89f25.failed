scsi: qla2xxx: Add Device ID for ISP28XX

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Joe Carnuccio <joe.carnuccio@cavium.com>
commit ecc89f25e225fabfffc709dbc43c928bc276cade
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/ecc89f25.failed

This patch adds PCI device ID ISP28XX for Gen7 support.  Also signature
determination for primary/secondary flash image for ISP27XX/28XX is aded as
part of Gen7 support.

	Signed-off-by: Joe Carnuccio <joe.carnuccio@cavium.com>
	Signed-off-by: Himanshu Madhani <hmadhani@marvell.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit ecc89f25e225fabfffc709dbc43c928bc276cade)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_attr.c
#	drivers/scsi/qla2xxx/qla_init.c
#	drivers/scsi/qla2xxx/qla_mbx.c
#	drivers/scsi/qla2xxx/qla_os.c
diff --cc drivers/scsi/qla2xxx/qla_attr.c
index 55925877df53,f035251a86ce..000000000000
--- a/drivers/scsi/qla2xxx/qla_attr.c
+++ b/drivers/scsi/qla2xxx/qla_attr.c
@@@ -1516,7 -1637,562 +1518,566 @@@ qla2x00_max_speed_sup_show(struct devic
  	    ha->max_speed_sup ? "32Gps" : "16Gps");
  }
  
++<<<<<<< HEAD
 +static DEVICE_ATTR(driver_version, S_IRUGO, qla2x00_drvr_version_show, NULL);
++=======
+ static ssize_t
+ qla2x00_port_speed_store(struct device *dev, struct device_attribute *attr,
+     const char *buf, size_t count)
+ {
+ 	struct scsi_qla_host *vha = shost_priv(dev_to_shost(dev));
+ 	ulong type, speed;
+ 	int oldspeed, rval;
+ 	int mode = QLA_SET_DATA_RATE_LR;
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	if (!IS_QLA27XX(ha) && !IS_QLA28XX(ha)) {
+ 		ql_log(ql_log_warn, vha, 0x70d8,
+ 		    "Speed setting not supported \n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	rval = kstrtol(buf, 10, &type);
+ 	if (rval)
+ 		return rval;
+ 	speed = type;
+ 	if (type == 40 || type == 80 || type == 160 ||
+ 	    type == 320) {
+ 		ql_dbg(ql_dbg_user, vha, 0x70d9,
+ 		    "Setting will be affected after a loss of sync\n");
+ 		type = type/10;
+ 		mode = QLA_SET_DATA_RATE_NOLR;
+ 	}
+ 
+ 	oldspeed = ha->set_data_rate;
+ 
+ 	switch (type) {
+ 	case 0:
+ 		ha->set_data_rate = PORT_SPEED_AUTO;
+ 		break;
+ 	case 4:
+ 		ha->set_data_rate = PORT_SPEED_4GB;
+ 		break;
+ 	case 8:
+ 		ha->set_data_rate = PORT_SPEED_8GB;
+ 		break;
+ 	case 16:
+ 		ha->set_data_rate = PORT_SPEED_16GB;
+ 		break;
+ 	case 32:
+ 		ha->set_data_rate = PORT_SPEED_32GB;
+ 		break;
+ 	default:
+ 		ql_log(ql_log_warn, vha, 0x1199,
+ 		    "Unrecognized speed setting:%lx. Setting Autoneg\n",
+ 		    speed);
+ 		ha->set_data_rate = PORT_SPEED_AUTO;
+ 	}
+ 
+ 	if (qla2x00_chip_is_down(vha) || (oldspeed == ha->set_data_rate))
+ 		return -EINVAL;
+ 
+ 	ql_log(ql_log_info, vha, 0x70da,
+ 	    "Setting speed to %lx Gbps \n", type);
+ 
+ 	rval = qla2x00_set_data_rate(vha, mode);
+ 	if (rval != QLA_SUCCESS)
+ 		return -EIO;
+ 
+ 	return strlen(buf);
+ }
+ 
+ static ssize_t
+ qla2x00_port_speed_show(struct device *dev, struct device_attribute *attr,
+     char *buf)
+ {
+ 	struct scsi_qla_host *vha = shost_priv(dev_to_shost(dev));
+ 	struct qla_hw_data *ha = vha->hw;
+ 	ssize_t rval;
+ 	char *spd[7] = {"0", "0", "0", "4", "8", "16", "32"};
+ 
+ 	rval = qla2x00_get_data_rate(vha);
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_log(ql_log_warn, vha, 0x70db,
+ 		    "Unable to get port speed rval:%zd\n", rval);
+ 		return -EINVAL;
+ 	}
+ 
+ 	ql_log(ql_log_info, vha, 0x70d6,
+ 	    "port speed:%d\n", ha->link_data_rate);
+ 
+ 	return scnprintf(buf, PAGE_SIZE, "%s\n", spd[ha->link_data_rate]);
+ }
+ 
+ /* ----- */
+ 
+ static ssize_t
+ qlini_mode_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	scsi_qla_host_t *vha = shost_priv(class_to_shost(dev));
+ 	int len = 0;
+ 
+ 	len += scnprintf(buf + len, PAGE_SIZE-len,
+ 	    "Supported options: enabled | disabled | dual | exclusive\n");
+ 
+ 	/* --- */
+ 	len += scnprintf(buf + len, PAGE_SIZE-len, "Current selection: ");
+ 
+ 	switch (vha->qlini_mode) {
+ 	case QLA2XXX_INI_MODE_EXCLUSIVE:
+ 		len += scnprintf(buf + len, PAGE_SIZE-len,
+ 		    QLA2XXX_INI_MODE_STR_EXCLUSIVE);
+ 		break;
+ 	case QLA2XXX_INI_MODE_DISABLED:
+ 		len += scnprintf(buf + len, PAGE_SIZE-len,
+ 		    QLA2XXX_INI_MODE_STR_DISABLED);
+ 		break;
+ 	case QLA2XXX_INI_MODE_ENABLED:
+ 		len += scnprintf(buf + len, PAGE_SIZE-len,
+ 		    QLA2XXX_INI_MODE_STR_ENABLED);
+ 		break;
+ 	case QLA2XXX_INI_MODE_DUAL:
+ 		len += scnprintf(buf + len, PAGE_SIZE-len,
+ 		    QLA2XXX_INI_MODE_STR_DUAL);
+ 		break;
+ 	}
+ 	len += scnprintf(buf + len, PAGE_SIZE-len, "\n");
+ 
+ 	return len;
+ }
+ 
+ static char *mode_to_str[] = {
+ 	"exclusive",
+ 	"disabled",
+ 	"enabled",
+ 	"dual",
+ };
+ 
+ #define NEED_EXCH_OFFLOAD(_exchg) ((_exchg) > FW_DEF_EXCHANGES_CNT)
+ static int qla_set_ini_mode(scsi_qla_host_t *vha, int op)
+ {
+ 	int rc = 0;
+ 	enum {
+ 		NO_ACTION,
+ 		MODE_CHANGE_ACCEPT,
+ 		MODE_CHANGE_NO_ACTION,
+ 		TARGET_STILL_ACTIVE,
+ 	};
+ 	int action = NO_ACTION;
+ 	int set_mode = 0;
+ 	u8  eo_toggle = 0;	/* exchange offload flipped */
+ 
+ 	switch (vha->qlini_mode) {
+ 	case QLA2XXX_INI_MODE_DISABLED:
+ 		switch (op) {
+ 		case QLA2XXX_INI_MODE_DISABLED:
+ 			if (qla_tgt_mode_enabled(vha)) {
+ 				if (NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld) !=
+ 				    vha->hw->flags.exchoffld_enabled)
+ 					eo_toggle = 1;
+ 				if (((vha->ql2xexchoffld !=
+ 				    vha->u_ql2xexchoffld) &&
+ 				    NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld)) ||
+ 				    eo_toggle) {
+ 					/*
+ 					 * The number of exchange to be offload
+ 					 * was tweaked or offload option was
+ 					 * flipped
+ 					 */
+ 					action = MODE_CHANGE_ACCEPT;
+ 				} else {
+ 					action = MODE_CHANGE_NO_ACTION;
+ 				}
+ 			} else {
+ 				action = MODE_CHANGE_NO_ACTION;
+ 			}
+ 			break;
+ 		case QLA2XXX_INI_MODE_EXCLUSIVE:
+ 			if (qla_tgt_mode_enabled(vha)) {
+ 				if (NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld) !=
+ 				    vha->hw->flags.exchoffld_enabled)
+ 					eo_toggle = 1;
+ 				if (((vha->ql2xexchoffld !=
+ 				    vha->u_ql2xexchoffld) &&
+ 				    NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld)) ||
+ 				    eo_toggle) {
+ 					/*
+ 					 * The number of exchange to be offload
+ 					 * was tweaked or offload option was
+ 					 * flipped
+ 					 */
+ 					action = MODE_CHANGE_ACCEPT;
+ 				} else {
+ 					action = MODE_CHANGE_NO_ACTION;
+ 				}
+ 			} else {
+ 				action = MODE_CHANGE_ACCEPT;
+ 			}
+ 			break;
+ 		case QLA2XXX_INI_MODE_DUAL:
+ 			action = MODE_CHANGE_ACCEPT;
+ 			/* active_mode is target only, reset it to dual */
+ 			if (qla_tgt_mode_enabled(vha)) {
+ 				set_mode = 1;
+ 				action = MODE_CHANGE_ACCEPT;
+ 			} else {
+ 				action = MODE_CHANGE_NO_ACTION;
+ 			}
+ 			break;
+ 
+ 		case QLA2XXX_INI_MODE_ENABLED:
+ 			if (qla_tgt_mode_enabled(vha))
+ 				action = TARGET_STILL_ACTIVE;
+ 			else {
+ 				action = MODE_CHANGE_ACCEPT;
+ 				set_mode = 1;
+ 			}
+ 			break;
+ 		}
+ 		break;
+ 
+ 	case QLA2XXX_INI_MODE_EXCLUSIVE:
+ 		switch (op) {
+ 		case QLA2XXX_INI_MODE_EXCLUSIVE:
+ 			if (qla_tgt_mode_enabled(vha)) {
+ 				if (NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld) !=
+ 				    vha->hw->flags.exchoffld_enabled)
+ 					eo_toggle = 1;
+ 				if (((vha->ql2xexchoffld !=
+ 				    vha->u_ql2xexchoffld) &&
+ 				    NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld)) ||
+ 				    eo_toggle)
+ 					/*
+ 					 * The number of exchange to be offload
+ 					 * was tweaked or offload option was
+ 					 * flipped
+ 					 */
+ 					action = MODE_CHANGE_ACCEPT;
+ 				else
+ 					action = NO_ACTION;
+ 			} else
+ 				action = NO_ACTION;
+ 
+ 			break;
+ 
+ 		case QLA2XXX_INI_MODE_DISABLED:
+ 			if (qla_tgt_mode_enabled(vha)) {
+ 				if (NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld) !=
+ 				    vha->hw->flags.exchoffld_enabled)
+ 					eo_toggle = 1;
+ 				if (((vha->ql2xexchoffld !=
+ 				      vha->u_ql2xexchoffld) &&
+ 				    NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld)) ||
+ 				    eo_toggle)
+ 					action = MODE_CHANGE_ACCEPT;
+ 				else
+ 					action = MODE_CHANGE_NO_ACTION;
+ 			} else
+ 				action = MODE_CHANGE_NO_ACTION;
+ 			break;
+ 
+ 		case QLA2XXX_INI_MODE_DUAL: /* exclusive -> dual */
+ 			if (qla_tgt_mode_enabled(vha)) {
+ 				action = MODE_CHANGE_ACCEPT;
+ 				set_mode = 1;
+ 			} else
+ 				action = MODE_CHANGE_ACCEPT;
+ 			break;
+ 
+ 		case QLA2XXX_INI_MODE_ENABLED:
+ 			if (qla_tgt_mode_enabled(vha))
+ 				action = TARGET_STILL_ACTIVE;
+ 			else {
+ 				if (vha->hw->flags.fw_started)
+ 					action = MODE_CHANGE_NO_ACTION;
+ 				else
+ 					action = MODE_CHANGE_ACCEPT;
+ 			}
+ 			break;
+ 		}
+ 		break;
+ 
+ 	case QLA2XXX_INI_MODE_ENABLED:
+ 		switch (op) {
+ 		case QLA2XXX_INI_MODE_ENABLED:
+ 			if (NEED_EXCH_OFFLOAD(vha->u_ql2xiniexchg) !=
+ 			    vha->hw->flags.exchoffld_enabled)
+ 				eo_toggle = 1;
+ 			if (((vha->ql2xiniexchg != vha->u_ql2xiniexchg) &&
+ 				NEED_EXCH_OFFLOAD(vha->u_ql2xiniexchg)) ||
+ 			    eo_toggle)
+ 				action = MODE_CHANGE_ACCEPT;
+ 			else
+ 				action = NO_ACTION;
+ 			break;
+ 		case QLA2XXX_INI_MODE_DUAL:
+ 		case QLA2XXX_INI_MODE_DISABLED:
+ 			action = MODE_CHANGE_ACCEPT;
+ 			break;
+ 		default:
+ 			action = MODE_CHANGE_NO_ACTION;
+ 			break;
+ 		}
+ 		break;
+ 
+ 	case QLA2XXX_INI_MODE_DUAL:
+ 		switch (op) {
+ 		case QLA2XXX_INI_MODE_DUAL:
+ 			if (qla_tgt_mode_enabled(vha) ||
+ 			    qla_dual_mode_enabled(vha)) {
+ 				if (NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld +
+ 					vha->u_ql2xiniexchg) !=
+ 				    vha->hw->flags.exchoffld_enabled)
+ 					eo_toggle = 1;
+ 
+ 				if ((((vha->ql2xexchoffld +
+ 				       vha->ql2xiniexchg) !=
+ 				    (vha->u_ql2xiniexchg +
+ 				     vha->u_ql2xexchoffld)) &&
+ 				    NEED_EXCH_OFFLOAD(vha->u_ql2xiniexchg +
+ 					vha->u_ql2xexchoffld)) || eo_toggle)
+ 					action = MODE_CHANGE_ACCEPT;
+ 				else
+ 					action = NO_ACTION;
+ 			} else {
+ 				if (NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld +
+ 					vha->u_ql2xiniexchg) !=
+ 				    vha->hw->flags.exchoffld_enabled)
+ 					eo_toggle = 1;
+ 
+ 				if ((((vha->ql2xexchoffld + vha->ql2xiniexchg)
+ 				    != (vha->u_ql2xiniexchg +
+ 					vha->u_ql2xexchoffld)) &&
+ 				    NEED_EXCH_OFFLOAD(vha->u_ql2xiniexchg +
+ 					vha->u_ql2xexchoffld)) || eo_toggle)
+ 					action = MODE_CHANGE_NO_ACTION;
+ 				else
+ 					action = NO_ACTION;
+ 			}
+ 			break;
+ 
+ 		case QLA2XXX_INI_MODE_DISABLED:
+ 			if (qla_tgt_mode_enabled(vha) ||
+ 			    qla_dual_mode_enabled(vha)) {
+ 				/* turning off initiator mode */
+ 				set_mode = 1;
+ 				action = MODE_CHANGE_ACCEPT;
+ 			} else {
+ 				action = MODE_CHANGE_NO_ACTION;
+ 			}
+ 			break;
+ 
+ 		case QLA2XXX_INI_MODE_EXCLUSIVE:
+ 			if (qla_tgt_mode_enabled(vha) ||
+ 			    qla_dual_mode_enabled(vha)) {
+ 				set_mode = 1;
+ 				action = MODE_CHANGE_ACCEPT;
+ 			} else {
+ 				action = MODE_CHANGE_ACCEPT;
+ 			}
+ 			break;
+ 
+ 		case QLA2XXX_INI_MODE_ENABLED:
+ 			if (qla_tgt_mode_enabled(vha) ||
+ 			    qla_dual_mode_enabled(vha)) {
+ 				action = TARGET_STILL_ACTIVE;
+ 			} else {
+ 				action = MODE_CHANGE_ACCEPT;
+ 			}
+ 		}
+ 		break;
+ 	}
+ 
+ 	switch (action) {
+ 	case MODE_CHANGE_ACCEPT:
+ 		ql_log(ql_log_warn, vha, 0xffff,
+ 		    "Mode change accepted. From %s to %s, Tgt exchg %d|%d. ini exchg %d|%d\n",
+ 		    mode_to_str[vha->qlini_mode], mode_to_str[op],
+ 		    vha->ql2xexchoffld, vha->u_ql2xexchoffld,
+ 		    vha->ql2xiniexchg, vha->u_ql2xiniexchg);
+ 
+ 		vha->qlini_mode = op;
+ 		vha->ql2xexchoffld = vha->u_ql2xexchoffld;
+ 		vha->ql2xiniexchg = vha->u_ql2xiniexchg;
+ 		if (set_mode)
+ 			qlt_set_mode(vha);
+ 		vha->flags.online = 1;
+ 		set_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);
+ 		break;
+ 
+ 	case MODE_CHANGE_NO_ACTION:
+ 		ql_log(ql_log_warn, vha, 0xffff,
+ 		    "Mode is set. No action taken. From %s to %s, Tgt exchg %d|%d. ini exchg %d|%d\n",
+ 		    mode_to_str[vha->qlini_mode], mode_to_str[op],
+ 		    vha->ql2xexchoffld, vha->u_ql2xexchoffld,
+ 		    vha->ql2xiniexchg, vha->u_ql2xiniexchg);
+ 		vha->qlini_mode = op;
+ 		vha->ql2xexchoffld = vha->u_ql2xexchoffld;
+ 		vha->ql2xiniexchg = vha->u_ql2xiniexchg;
+ 		break;
+ 
+ 	case TARGET_STILL_ACTIVE:
+ 		ql_log(ql_log_warn, vha, 0xffff,
+ 		    "Target Mode is active. Unable to change Mode.\n");
+ 		break;
+ 
+ 	case NO_ACTION:
+ 	default:
+ 		ql_log(ql_log_warn, vha, 0xffff,
+ 		    "Mode unchange. No action taken. %d|%d pct %d|%d.\n",
+ 		    vha->qlini_mode, op,
+ 		    vha->ql2xexchoffld, vha->u_ql2xexchoffld);
+ 		break;
+ 	}
+ 
+ 	return rc;
+ }
+ 
+ static ssize_t
+ qlini_mode_store(struct device *dev, struct device_attribute *attr,
+     const char *buf, size_t count)
+ {
+ 	scsi_qla_host_t *vha = shost_priv(class_to_shost(dev));
+ 	int ini;
+ 
+ 	if (!buf)
+ 		return -EINVAL;
+ 
+ 	if (strncasecmp(QLA2XXX_INI_MODE_STR_EXCLUSIVE, buf,
+ 		strlen(QLA2XXX_INI_MODE_STR_EXCLUSIVE)) == 0)
+ 		ini = QLA2XXX_INI_MODE_EXCLUSIVE;
+ 	else if (strncasecmp(QLA2XXX_INI_MODE_STR_DISABLED, buf,
+ 		strlen(QLA2XXX_INI_MODE_STR_DISABLED)) == 0)
+ 		ini = QLA2XXX_INI_MODE_DISABLED;
+ 	else if (strncasecmp(QLA2XXX_INI_MODE_STR_ENABLED, buf,
+ 		  strlen(QLA2XXX_INI_MODE_STR_ENABLED)) == 0)
+ 		ini = QLA2XXX_INI_MODE_ENABLED;
+ 	else if (strncasecmp(QLA2XXX_INI_MODE_STR_DUAL, buf,
+ 		strlen(QLA2XXX_INI_MODE_STR_DUAL)) == 0)
+ 		ini = QLA2XXX_INI_MODE_DUAL;
+ 	else
+ 		return -EINVAL;
+ 
+ 	qla_set_ini_mode(vha, ini);
+ 	return strlen(buf);
+ }
+ 
+ static ssize_t
+ ql2xexchoffld_show(struct device *dev, struct device_attribute *attr,
+     char *buf)
+ {
+ 	scsi_qla_host_t *vha = shost_priv(class_to_shost(dev));
+ 	int len = 0;
+ 
+ 	len += scnprintf(buf + len, PAGE_SIZE-len,
+ 		"target exchange: new %d : current: %d\n\n",
+ 		vha->u_ql2xexchoffld, vha->ql2xexchoffld);
+ 
+ 	len += scnprintf(buf + len, PAGE_SIZE-len,
+ 	    "Please (re)set operating mode via \"/sys/class/scsi_host/host%ld/qlini_mode\" to load new setting.\n",
+ 	    vha->host_no);
+ 
+ 	return len;
+ }
+ 
+ static ssize_t
+ ql2xexchoffld_store(struct device *dev, struct device_attribute *attr,
+     const char *buf, size_t count)
+ {
+ 	scsi_qla_host_t *vha = shost_priv(class_to_shost(dev));
+ 	int val = 0;
+ 
+ 	if (sscanf(buf, "%d", &val) != 1)
+ 		return -EINVAL;
+ 
+ 	if (val > FW_MAX_EXCHANGES_CNT)
+ 		val = FW_MAX_EXCHANGES_CNT;
+ 	else if (val < 0)
+ 		val = 0;
+ 
+ 	vha->u_ql2xexchoffld = val;
+ 	return strlen(buf);
+ }
+ 
+ static ssize_t
+ ql2xiniexchg_show(struct device *dev, struct device_attribute *attr,
+     char *buf)
+ {
+ 	scsi_qla_host_t *vha = shost_priv(class_to_shost(dev));
+ 	int len = 0;
+ 
+ 	len += scnprintf(buf + len, PAGE_SIZE-len,
+ 		"target exchange: new %d : current: %d\n\n",
+ 		vha->u_ql2xiniexchg, vha->ql2xiniexchg);
+ 
+ 	len += scnprintf(buf + len, PAGE_SIZE-len,
+ 	    "Please (re)set operating mode via \"/sys/class/scsi_host/host%ld/qlini_mode\" to load new setting.\n",
+ 	    vha->host_no);
+ 
+ 	return len;
+ }
+ 
+ static ssize_t
+ ql2xiniexchg_store(struct device *dev, struct device_attribute *attr,
+     const char *buf, size_t count)
+ {
+ 	scsi_qla_host_t *vha = shost_priv(class_to_shost(dev));
+ 	int val = 0;
+ 
+ 	if (sscanf(buf, "%d", &val) != 1)
+ 		return -EINVAL;
+ 
+ 	if (val > FW_MAX_EXCHANGES_CNT)
+ 		val = FW_MAX_EXCHANGES_CNT;
+ 	else if (val < 0)
+ 		val = 0;
+ 
+ 	vha->u_ql2xiniexchg = val;
+ 	return strlen(buf);
+ }
+ 
+ static ssize_t
+ qla2x00_dif_bundle_statistics_show(struct device *dev,
+     struct device_attribute *attr, char *buf)
+ {
+ 	scsi_qla_host_t *vha = shost_priv(class_to_shost(dev));
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	return scnprintf(buf, PAGE_SIZE,
+ 	    "cross=%llu read=%llu write=%llu kalloc=%llu dma_alloc=%llu unusable=%u\n",
+ 	    ha->dif_bundle_crossed_pages, ha->dif_bundle_reads,
+ 	    ha->dif_bundle_writes, ha->dif_bundle_kallocs,
+ 	    ha->dif_bundle_dma_allocs, ha->pool.unusable.count);
+ }
+ 
+ static ssize_t
+ qla2x00_fw_attr_show(struct device *dev,
+     struct device_attribute *attr, char *buf)
+ {
+ 	scsi_qla_host_t *vha = shost_priv(class_to_shost(dev));
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	if (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))
+ 		return scnprintf(buf, PAGE_SIZE, "\n");
+ 
+ 	return scnprintf(buf, PAGE_SIZE, "%llx\n",
+ 	    (uint64_t)ha->fw_attributes_ext[1] << 48 |
+ 	    (uint64_t)ha->fw_attributes_ext[0] << 32 |
+ 	    (uint64_t)ha->fw_attributes_h << 16 |
+ 	    (uint64_t)ha->fw_attributes);
+ }
+ 
+ static ssize_t
+ qla2x00_port_no_show(struct device *dev, struct device_attribute *attr,
+     char *buf)
+ {
+ 	scsi_qla_host_t *vha = shost_priv(class_to_shost(dev));
+ 
+ 	return scnprintf(buf, PAGE_SIZE, "%u\n", vha->hw->port_no);
+ }
+ 
+ static DEVICE_ATTR(driver_version, S_IRUGO, qla2x00_driver_version_show, NULL);
++>>>>>>> ecc89f25e225 (scsi: qla2xxx: Add Device ID for ISP28XX)
  static DEVICE_ATTR(fw_version, S_IRUGO, qla2x00_fw_version_show, NULL);
  static DEVICE_ATTR(serial_num, S_IRUGO, qla2x00_serial_num_show, NULL);
  static DEVICE_ATTR(isp_name, S_IRUGO, qla2x00_isp_name_show, NULL);
diff --cc drivers/scsi/qla2xxx/qla_init.c
index 046c47b82245,d9177fd88461..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -3315,6 -3499,12 +3316,15 @@@ qla2x00_setup_chip(scsi_qla_host_t *vha
  			if (rval == QLA_SUCCESS) {
  				qla24xx_detect_sfp(vha);
  
++<<<<<<< HEAD
++=======
+ 				if ((IS_QLA83XX(ha) || IS_QLA27XX(ha) ||
+ 				    IS_QLA28XX(ha)) &&
+ 				    (ha->zio_mode == QLA_ZIO_MODE_6))
+ 					qla27xx_set_zio_threshold(vha,
+ 					    ha->last_zio_threshold);
+ 
++>>>>>>> ecc89f25e225 (scsi: qla2xxx: Add Device ID for ISP28XX)
  				rval = qla2x00_set_exlogins_buffer(vha);
  				if (rval != QLA_SUCCESS)
  					goto failed;
@@@ -7908,10 -8184,12 +7927,10 @@@ qla81xx_nvram_config(scsi_qla_host_t *v
  	}
  
  	 /* enable RIDA Format2 */
 -	icb->firmware_options_3 |= BIT_0;
 -
 -	/* N2N: driver will initiate Login instead of FW */
 -	icb->firmware_options_3 |= BIT_8;
 +	if (qla_tgt_mode_enabled(vha) || qla_dual_mode_enabled(vha))
 +		icb->firmware_options_3 |= BIT_0;
  
- 	if (IS_QLA27XX(ha)) {
+ 	if (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {
  		icb->firmware_options_3 |= BIT_8;
  		ql_dbg(ql_log_info, vha, 0x0075,
  		    "Enabling direct connection.\n");
diff --cc drivers/scsi/qla2xxx/qla_mbx.c
index 65b8016b6102,381221118830..000000000000
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@@ -5192,6 -5243,66 +5197,69 @@@ qla81xx_write_mpi_register(scsi_qla_hos
  	return rval;
  }
  
++<<<<<<< HEAD
++=======
+ /* Set the specified data rate */
+ int
+ qla2x00_set_data_rate(scsi_qla_host_t *vha, uint16_t mode)
+ {
+ 	int rval;
+ 	mbx_cmd_t mc;
+ 	mbx_cmd_t *mcp = &mc;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	uint16_t val;
+ 
+ 	ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1106,
+ 	    "Entered %s speed:0x%x mode:0x%x.\n", __func__, ha->set_data_rate,
+ 	    mode);
+ 
+ 	if (!IS_FWI2_CAPABLE(ha))
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	memset(mcp, 0, sizeof(*mcp));
+ 	switch (ha->set_data_rate) {
+ 	case PORT_SPEED_AUTO:
+ 	case PORT_SPEED_4GB:
+ 	case PORT_SPEED_8GB:
+ 	case PORT_SPEED_16GB:
+ 	case PORT_SPEED_32GB:
+ 		val = ha->set_data_rate;
+ 		break;
+ 	default:
+ 		ql_log(ql_log_warn, vha, 0x1199,
+ 		    "Unrecognized speed setting:%d. Setting Autoneg\n",
+ 		    ha->set_data_rate);
+ 		val = ha->set_data_rate = PORT_SPEED_AUTO;
+ 		break;
+ 	}
+ 
+ 	mcp->mb[0] = MBC_DATA_RATE;
+ 	mcp->mb[1] = mode;
+ 	mcp->mb[2] = val;
+ 
+ 	mcp->out_mb = MBX_2|MBX_1|MBX_0;
+ 	mcp->in_mb = MBX_2|MBX_1|MBX_0;
+ 	if (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha))
+ 		mcp->in_mb |= MBX_4|MBX_3;
+ 	mcp->tov = MBX_TOV_SECONDS;
+ 	mcp->flags = 0;
+ 	rval = qla2x00_mailbox_command(vha, mcp);
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_dbg(ql_dbg_mbx, vha, 0x1107,
+ 		    "Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);
+ 	} else {
+ 		if (mcp->mb[1] != 0x7)
+ 			ql_dbg(ql_dbg_mbx, vha, 0x1179,
+ 				"Speed set:0x%x\n", mcp->mb[1]);
+ 
+ 		ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1108,
+ 		    "Done %s.\n", __func__);
+ 	}
+ 
+ 	return rval;
+ }
+ 
++>>>>>>> ecc89f25e225 (scsi: qla2xxx: Add Device ID for ISP28XX)
  int
  qla2x00_get_data_rate(scsi_qla_host_t *vha)
  {
@@@ -5207,10 -5318,10 +5275,10 @@@
  		return QLA_FUNCTION_FAILED;
  
  	mcp->mb[0] = MBC_DATA_RATE;
 -	mcp->mb[1] = QLA_GET_DATA_RATE;
 +	mcp->mb[1] = 0;
  	mcp->out_mb = MBX_1|MBX_0;
  	mcp->in_mb = MBX_2|MBX_1|MBX_0;
- 	if (IS_QLA83XX(ha) || IS_QLA27XX(ha))
+ 	if (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha))
  		mcp->in_mb |= MBX_3;
  	mcp->tov = MBX_TOV_SECONDS;
  	mcp->flags = 0;
diff --cc drivers/scsi/qla2xxx/qla_os.c
index 9af7817f8d01,f5fce5b52067..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -6415,13 -6722,24 +6460,19 @@@ qla2x00_timer(struct timer_list *t
  	 * FC-NVME
  	 * see if the active AEN count has changed from what was last reported.
  	 */
 -	if (!vha->vp_idx && (atomic_read(&ha->nvme_active_aen_cnt) !=
 -	    ha->nvme_last_rptd_aen) && ha->zio_mode == QLA_ZIO_MODE_6) {
 -		ql_log(ql_log_info, vha, 0x3002,
 -		    "nvme: Sched: Set ZIO exchange threshold to %d.\n",
 -		    ha->nvme_last_rptd_aen);
 -		ha->nvme_last_rptd_aen = atomic_read(&ha->nvme_active_aen_cnt);
 -		set_bit(SET_NVME_ZIO_THRESHOLD_NEEDED, &vha->dpc_flags);
 -		start_dpc++;
 -	}
 -
  	if (!vha->vp_idx &&
++<<<<<<< HEAD
 +		atomic_read(&ha->nvme_active_aen_cnt) != ha->nvme_last_rptd_aen &&
 +		ha->zio_mode == QLA_ZIO_MODE_6) {
++=======
+ 	    (atomic_read(&ha->zio_threshold) != ha->last_zio_threshold) &&
+ 	    (ha->zio_mode == QLA_ZIO_MODE_6) &&
+ 	    (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha))) {
++>>>>>>> ecc89f25e225 (scsi: qla2xxx: Add Device ID for ISP28XX)
  		ql_log(ql_log_info, vha, 0x3002,
 -		    "Sched: Set ZIO exchange threshold to %d.\n",
 -		    ha->last_zio_threshold);
 -		ha->last_zio_threshold = atomic_read(&ha->zio_threshold);
 +			"nvme: Sched: Set ZIO exchange threshold to %d.\n",
 +			ha->nvme_last_rptd_aen);
 +		ha->nvme_last_rptd_aen = atomic_read(&ha->nvme_active_aen_cnt);
  		set_bit(SET_ZIO_THRESHOLD_NEEDED, &vha->dpc_flags);
  		start_dpc++;
  	}
* Unmerged path drivers/scsi/qla2xxx/qla_attr.c
diff --git a/drivers/scsi/qla2xxx/qla_bsg.c b/drivers/scsi/qla2xxx/qla_bsg.c
index 4a9fd8d944d6..589284c2b47c 100644
--- a/drivers/scsi/qla2xxx/qla_bsg.c
+++ b/drivers/scsi/qla2xxx/qla_bsg.c
@@ -1412,7 +1412,8 @@ qla2x00_optrom_setup(struct bsg_job *bsg_job, scsi_qla_host_t *vha,
 		    start == (ha->flt_region_fw * 4))
 			valid = 1;
 		else if (IS_QLA24XX_TYPE(ha) || IS_QLA25XX(ha) ||
-		    IS_CNA_CAPABLE(ha) || IS_QLA2031(ha) || IS_QLA27XX(ha))
+		    IS_CNA_CAPABLE(ha) || IS_QLA2031(ha) || IS_QLA27XX(ha) ||
+		    IS_QLA28XX(ha))
 			valid = 1;
 		if (!valid) {
 			ql_log(ql_log_warn, vha, 0x7058,
@@ -2157,7 +2158,7 @@ qla27xx_get_flash_upd_cap(struct bsg_job *bsg_job)
 	struct qla_hw_data *ha = vha->hw;
 	struct qla_flash_update_caps cap;
 
-	if (!(IS_QLA27XX(ha)))
+	if (!(IS_QLA27XX(ha)) && !IS_QLA28XX(ha))
 		return -EPERM;
 
 	memset(&cap, 0, sizeof(cap));
@@ -2190,7 +2191,7 @@ qla27xx_set_flash_upd_cap(struct bsg_job *bsg_job)
 	uint64_t online_fw_attr = 0;
 	struct qla_flash_update_caps cap;
 
-	if (!(IS_QLA27XX(ha)))
+	if (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))
 		return -EPERM;
 
 	memset(&cap, 0, sizeof(cap));
@@ -2238,7 +2239,7 @@ qla27xx_get_bbcr_data(struct bsg_job *bsg_job)
 	uint8_t domain, area, al_pa, state;
 	int rval;
 
-	if (!(IS_QLA27XX(ha)))
+	if (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))
 		return -EPERM;
 
 	memset(&bbcr, 0, sizeof(bbcr));
@@ -2353,7 +2354,8 @@ qla2x00_do_dport_diagnostics(struct bsg_job *bsg_job)
 	int rval;
 	struct qla_dport_diag *dd;
 
-	if (!IS_QLA83XX(vha->hw) && !IS_QLA27XX(vha->hw))
+	if (!IS_QLA83XX(vha->hw) && !IS_QLA27XX(vha->hw) &&
+	    !IS_QLA28XX(vha->hw))
 		return -EPERM;
 
 	dd = kmalloc(sizeof(*dd), GFP_KERNEL);
diff --git a/drivers/scsi/qla2xxx/qla_dbg.c b/drivers/scsi/qla2xxx/qla_dbg.c
index ec5bad0b0607..3cfd846cdb2a 100644
--- a/drivers/scsi/qla2xxx/qla_dbg.c
+++ b/drivers/scsi/qla2xxx/qla_dbg.c
@@ -176,7 +176,8 @@ qla27xx_dump_mpi_ram(struct qla_hw_data *ha, uint32_t addr, uint32_t *ram,
 			return rval;
 		}
 		for (j = 0; j < dwords; j++) {
-			ram[i + j] = IS_QLA27XX(ha) ?
+			ram[i + j] =
+			    (IS_QLA27XX(ha) || IS_QLA28XX(ha)) ?
 			    chunk[j] : swab32(chunk[j]);
 		}
 	}
@@ -251,7 +252,8 @@ qla24xx_dump_ram(struct qla_hw_data *ha, uint32_t addr, uint32_t *ram,
 			return rval;
 		}
 		for (j = 0; j < dwords; j++) {
-			ram[i + j] = IS_QLA27XX(ha) ?
+			ram[i + j] =
+			    (IS_QLA27XX(ha) || IS_QLA28XX(ha)) ?
 			    chunk[j] : swab32(chunk[j]);
 		}
 	}
@@ -665,7 +667,8 @@ qla25xx_copy_mq(struct qla_hw_data *ha, void *ptr, uint32_t **last_chain)
 	struct qla2xxx_mq_chain *mq = ptr;
 	device_reg_t *reg;
 
-	if (!ha->mqenable || IS_QLA83XX(ha) || IS_QLA27XX(ha))
+	if (!ha->mqenable || IS_QLA83XX(ha) || IS_QLA27XX(ha) ||
+	    IS_QLA28XX(ha))
 		return ptr;
 
 	mq = ptr;
diff --git a/drivers/scsi/qla2xxx/qla_def.h b/drivers/scsi/qla2xxx/qla_def.h
index 824b13554ed2..825a17bf7669 100644
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@ -1198,6 +1198,7 @@ struct mbx_cmd_32 {
 #define QLA27XX_IMG_STATUS_VER_MAJOR   0x01
 #define QLA27XX_IMG_STATUS_VER_MINOR    0x00
 #define QLA27XX_IMG_STATUS_SIGN   0xFACEFADE
+#define QLA28XX_IMG_STATUS_SIGN    0xFACEFADF
 #define QLA27XX_PRIMARY_IMAGE  1
 #define QLA27XX_SECONDARY_IMAGE    2
 
@@ -2657,6 +2658,7 @@ struct ct_fdmiv2_hba_attributes {
 #define FDMI_PORT_SPEED_8GB		0x10
 #define FDMI_PORT_SPEED_16GB		0x20
 #define FDMI_PORT_SPEED_32GB		0x40
+#define FDMI_PORT_SPEED_64GB		0x80
 #define FDMI_PORT_SPEED_UNKNOWN		0x8000
 
 #define FC_CLASS_2	0x04
@@ -3353,7 +3355,8 @@ struct qla_tc_param {
 #define QLA_MQ_SIZE 32
 #define QLA_MAX_QUEUES 256
 #define ISP_QUE_REG(ha, id) \
-	((ha->mqenable || IS_QLA83XX(ha) || IS_QLA27XX(ha)) ? \
+	((ha->mqenable || IS_QLA83XX(ha) || \
+	  IS_QLA27XX(ha) || IS_QLA28XX(ha)) ? \
 	 ((void __iomem *)ha->mqiobase + (QLA_QUE_PAGE * id)) :\
 	 ((void __iomem *)ha->iobase))
 #define QLA_REQ_QUE_ID(tag) \
@@ -3686,6 +3689,7 @@ struct qla_hw_data {
 #define PORT_SPEED_8GB  0x04
 #define PORT_SPEED_16GB 0x05
 #define PORT_SPEED_32GB 0x06
+#define PORT_SPEED_64GB 0x07
 #define PORT_SPEED_10GB	0x13
 	uint16_t	link_data_rate;         /* F/W operating speed */
 
@@ -3711,6 +3715,11 @@ struct qla_hw_data {
 #define PCI_DEVICE_ID_QLOGIC_ISP2071	0x2071
 #define PCI_DEVICE_ID_QLOGIC_ISP2271	0x2271
 #define PCI_DEVICE_ID_QLOGIC_ISP2261	0x2261
+#define PCI_DEVICE_ID_QLOGIC_ISP2061	0x2061
+#define PCI_DEVICE_ID_QLOGIC_ISP2081	0x2081
+#define PCI_DEVICE_ID_QLOGIC_ISP2089	0x2089
+#define PCI_DEVICE_ID_QLOGIC_ISP2281	0x2281
+#define PCI_DEVICE_ID_QLOGIC_ISP2289	0x2289
 
 	uint32_t	isp_type;
 #define DT_ISP2100                      BIT_0
@@ -3735,7 +3744,12 @@ struct qla_hw_data {
 #define DT_ISP2071			BIT_19
 #define DT_ISP2271			BIT_20
 #define DT_ISP2261			BIT_21
-#define DT_ISP_LAST			(DT_ISP2261 << 1)
+#define DT_ISP2061			BIT_22
+#define DT_ISP2081			BIT_23
+#define DT_ISP2089			BIT_24
+#define DT_ISP2281			BIT_25
+#define DT_ISP2289			BIT_26
+#define DT_ISP_LAST			(DT_ISP2289 << 1)
 
 	uint32_t	device_type;
 #define DT_T10_PI                       BIT_25
@@ -3770,6 +3784,8 @@ struct qla_hw_data {
 #define IS_QLA2071(ha)	(DT_MASK(ha) & DT_ISP2071)
 #define IS_QLA2271(ha)	(DT_MASK(ha) & DT_ISP2271)
 #define IS_QLA2261(ha)	(DT_MASK(ha) & DT_ISP2261)
+#define IS_QLA2081(ha)	(DT_MASK(ha) & DT_ISP2081)
+#define IS_QLA2281(ha)	(DT_MASK(ha) & DT_ISP2281)
 
 #define IS_QLA23XX(ha)  (IS_QLA2300(ha) || IS_QLA2312(ha) || IS_QLA2322(ha) || \
 			IS_QLA6312(ha) || IS_QLA6322(ha))
@@ -3779,6 +3795,7 @@ struct qla_hw_data {
 #define IS_QLA83XX(ha)	(IS_QLA2031(ha) || IS_QLA8031(ha))
 #define IS_QLA84XX(ha)  (IS_QLA8432(ha))
 #define IS_QLA27XX(ha)  (IS_QLA2071(ha) || IS_QLA2271(ha) || IS_QLA2261(ha))
+#define IS_QLA28XX(ha)	(IS_QLA2081(ha) || IS_QLA2281(ha))
 #define IS_QLA24XX_TYPE(ha)     (IS_QLA24XX(ha) || IS_QLA54XX(ha) || \
 				IS_QLA84XX(ha))
 #define IS_CNA_CAPABLE(ha)	(IS_QLA81XX(ha) || IS_QLA82XX(ha) || \
@@ -3787,14 +3804,15 @@ struct qla_hw_data {
 #define IS_QLA2XXX_MIDTYPE(ha)	(IS_QLA24XX(ha) || IS_QLA84XX(ha) || \
 				IS_QLA25XX(ha) || IS_QLA81XX(ha) || \
 				IS_QLA82XX(ha) || IS_QLA83XX(ha) || \
-				IS_QLA8044(ha) || IS_QLA27XX(ha))
+				IS_QLA8044(ha) || IS_QLA27XX(ha) || \
+				IS_QLA28XX(ha))
 #define IS_MSIX_NACK_CAPABLE(ha) (IS_QLA81XX(ha) || IS_QLA83XX(ha) || \
-				IS_QLA27XX(ha))
+				IS_QLA27XX(ha) || IS_QLA28XX(ha))
 #define IS_NOPOLLING_TYPE(ha)	(IS_QLA81XX(ha) && (ha)->flags.msix_enabled)
 #define IS_FAC_REQUIRED(ha)	(IS_QLA81XX(ha) || IS_QLA83XX(ha) || \
-				IS_QLA27XX(ha))
+				IS_QLA27XX(ha) || IS_QLA28XX(ha))
 #define IS_NOCACHE_VPD_TYPE(ha)	(IS_QLA81XX(ha) || IS_QLA83XX(ha) || \
-				IS_QLA27XX(ha))
+				IS_QLA27XX(ha) || IS_QLA28XX(ha))
 #define IS_ALOGIO_CAPABLE(ha)	(IS_QLA23XX(ha) || IS_FWI2_CAPABLE(ha))
 
 #define IS_T10_PI_CAPABLE(ha)   ((ha)->device_type & DT_T10_PI)
@@ -3805,28 +3823,34 @@ struct qla_hw_data {
 #define HAS_EXTENDED_IDS(ha)    ((ha)->device_type & DT_EXTENDED_IDS)
 #define IS_CT6_SUPPORTED(ha)	((ha)->device_type & DT_CT6_SUPPORTED)
 #define IS_MQUE_CAPABLE(ha)	((ha)->mqenable || IS_QLA83XX(ha) || \
-				IS_QLA27XX(ha))
-#define IS_BIDI_CAPABLE(ha)	((IS_QLA25XX(ha) || IS_QLA2031(ha)))
+				IS_QLA27XX(ha) || IS_QLA28XX(ha))
+#define IS_BIDI_CAPABLE(ha) \
+    (IS_QLA25XX(ha) || IS_QLA2031(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha))
 /* Bit 21 of fw_attributes decides the MCTP capabilities */
 #define IS_MCTP_CAPABLE(ha)	(IS_QLA2031(ha) && \
 				((ha)->fw_attributes_ext[0] & BIT_0))
 #define IS_PI_UNINIT_CAPABLE(ha)	(IS_QLA83XX(ha) || IS_QLA27XX(ha))
 #define IS_PI_IPGUARD_CAPABLE(ha)	(IS_QLA83XX(ha) || IS_QLA27XX(ha))
 #define IS_PI_DIFB_DIX0_CAPABLE(ha)	(0)
-#define IS_PI_SPLIT_DET_CAPABLE_HBA(ha)	(IS_QLA83XX(ha) || IS_QLA27XX(ha))
+#define IS_PI_SPLIT_DET_CAPABLE_HBA(ha)	(IS_QLA83XX(ha) || IS_QLA27XX(ha) || \
+					IS_QLA28XX(ha))
 #define IS_PI_SPLIT_DET_CAPABLE(ha)	(IS_PI_SPLIT_DET_CAPABLE_HBA(ha) && \
     (((ha)->fw_attributes_h << 16 | (ha)->fw_attributes) & BIT_22))
-#define IS_ATIO_MSIX_CAPABLE(ha) (IS_QLA83XX(ha) || IS_QLA27XX(ha))
+#define IS_ATIO_MSIX_CAPABLE(ha) (IS_QLA83XX(ha) || IS_QLA27XX(ha) || \
+				IS_QLA28XX(ha))
 #define IS_TGT_MODE_CAPABLE(ha)	(ha->tgt.atio_q_length)
-#define IS_SHADOW_REG_CAPABLE(ha)  (IS_QLA27XX(ha))
-#define IS_DPORT_CAPABLE(ha)  (IS_QLA83XX(ha) || IS_QLA27XX(ha))
-#define IS_FAWWN_CAPABLE(ha)	(IS_QLA83XX(ha) || IS_QLA27XX(ha))
+#define IS_SHADOW_REG_CAPABLE(ha)  (IS_QLA27XX(ha) || IS_QLA28XX(ha))
+#define IS_DPORT_CAPABLE(ha)  (IS_QLA83XX(ha) || IS_QLA27XX(ha) || \
+				IS_QLA28XX(ha))
+#define IS_FAWWN_CAPABLE(ha)	(IS_QLA83XX(ha) || IS_QLA27XX(ha) || \
+				IS_QLA28XX(ha))
 #define IS_EXCHG_OFFLD_CAPABLE(ha) \
-	(IS_QLA81XX(ha) || IS_QLA83XX(ha) || IS_QLA27XX(ha))
+	(IS_QLA81XX(ha) || IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha))
 #define IS_EXLOGIN_OFFLD_CAPABLE(ha) \
-	(IS_QLA25XX(ha) || IS_QLA81XX(ha) || IS_QLA83XX(ha) || IS_QLA27XX(ha))
+	(IS_QLA25XX(ha) || IS_QLA81XX(ha) || IS_QLA83XX(ha) || \
+	 IS_QLA27XX(ha) || IS_QLA28XX(ha))
 #define USE_ASYNC_SCAN(ha) (IS_QLA25XX(ha) || IS_QLA81XX(ha) ||\
-	IS_QLA83XX(ha) || IS_QLA27XX(ha))
+	IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha))
 
 	/* HBA serial number */
 	uint8_t		serial0;
@@ -4538,6 +4562,7 @@ struct qla2_sgx {
 #define OPTROM_SIZE_81XX	0x400000
 #define OPTROM_SIZE_82XX	0x800000
 #define OPTROM_SIZE_83XX	0x1000000
+#define OPTROM_SIZE_28XX	0x2000000
 
 #define OPTROM_BURST_SIZE	0x1000
 #define OPTROM_BURST_DWORDS	(OPTROM_BURST_SIZE / 4)
@@ -4634,10 +4659,11 @@ struct sff_8247_a0 {
 #define AUTO_DETECT_SFP_SUPPORT(_vha)\
 	(ql2xautodetectsfp && !_vha->vp_idx &&		\
 	(IS_QLA25XX(_vha->hw) || IS_QLA81XX(_vha->hw) ||\
-	IS_QLA83XX(_vha->hw) || IS_QLA27XX(_vha->hw)))
+	IS_QLA83XX(_vha->hw) || IS_QLA27XX(_vha->hw) || \
+	 IS_QLA28XX(_vha->hw)))
 
 #define USER_CTRL_IRQ(_ha) (ql2xuctrlirq && QLA_TGT_MODE_ENABLED() && \
-	(IS_QLA27XX(_ha) || IS_QLA83XX(_ha)))
+	(IS_QLA27XX(_ha) || IS_QLA28XX(_ha) || IS_QLA83XX(_ha)))
 
 #define SAVE_TOPO(_ha) { \
 	if (_ha->current_topology)				\
diff --git a/drivers/scsi/qla2xxx/qla_dfs.c b/drivers/scsi/qla2xxx/qla_dfs.c
index ead17288e2a7..b6d53bbd89df 100644
--- a/drivers/scsi/qla2xxx/qla_dfs.c
+++ b/drivers/scsi/qla2xxx/qla_dfs.c
@@ -384,7 +384,7 @@ qla_dfs_naqp_write(struct file *file, const char __user *buffer,
 	int rc = 0;
 	unsigned long num_act_qp;
 
-	if (!(IS_QLA27XX(ha) || IS_QLA83XX(ha))) {
+	if (!(IS_QLA27XX(ha) || IS_QLA83XX(ha) || IS_QLA28XX(ha))) {
 		pr_err("host%ld: this adapter does not support Multi Q.",
 		    vha->host_no);
 		return -EINVAL;
@@ -436,7 +436,7 @@ qla2x00_dfs_setup(scsi_qla_host_t *vha)
 	struct qla_hw_data *ha = vha->hw;
 
 	if (!IS_QLA25XX(ha) && !IS_QLA81XX(ha) && !IS_QLA83XX(ha) &&
-	    !IS_QLA27XX(ha))
+	    !IS_QLA27XX(ha) && !IS_QLA28XX(ha))
 		goto out;
 	if (!ha->fce)
 		goto out;
@@ -472,7 +472,7 @@ qla2x00_dfs_setup(scsi_qla_host_t *vha)
 	ha->tgt.dfs_tgt_sess = debugfs_create_file("tgt_sess",
 		S_IRUSR, ha->dfs_dir, vha, &dfs_tgt_sess_ops);
 
-	if (IS_QLA27XX(ha) || IS_QLA83XX(ha))
+	if (IS_QLA27XX(ha) || IS_QLA83XX(ha) || IS_QLA28XX(ha))
 		ha->tgt.dfs_naqp = debugfs_create_file("naqp",
 		    0400, ha->dfs_dir, vha, &dfs_naqp_ops);
 out:
diff --git a/drivers/scsi/qla2xxx/qla_fw.h b/drivers/scsi/qla2xxx/qla_fw.h
index 5d8688e5bc7c..3e328f90f465 100644
--- a/drivers/scsi/qla2xxx/qla_fw.h
+++ b/drivers/scsi/qla2xxx/qla_fw.h
@@ -2000,6 +2000,8 @@ struct ex_init_cb_81xx {
 
 #define FARX_ACCESS_FLASH_CONF_81XX	0x7FFD0000
 #define FARX_ACCESS_FLASH_DATA_81XX	0x7F800000
+#define FARX_ACCESS_FLASH_CONF_28XX	0x7FFD0000
+#define FARX_ACCESS_FLASH_DATA_28XX	0x7F7D0000
 
 /* FCP priority config defines *************************************/
 /* operations */
@@ -2074,6 +2076,7 @@ struct qla_fcp_prio_cfg {
 #define FA_NPIV_CONF1_ADDR_81	0xD2000
 
 /* 83XX Flash locations -- occupies second 8MB region. */
-#define FA_FLASH_LAYOUT_ADDR_83	0xFC400
+#define FA_FLASH_LAYOUT_ADDR_83	(0x3F1000/4)
+#define FA_FLASH_LAYOUT_ADDR_28	(0x11000/4)
 
 #endif
diff --git a/drivers/scsi/qla2xxx/qla_gs.c b/drivers/scsi/qla2xxx/qla_gs.c
index c63c6062b326..fdc875490d65 100644
--- a/drivers/scsi/qla2xxx/qla_gs.c
+++ b/drivers/scsi/qla2xxx/qla_gs.c
@@ -1790,7 +1790,7 @@ qla2x00_fdmi_rpa(scsi_qla_host_t *vha)
 	if (IS_CNA_CAPABLE(ha))
 		eiter->a.sup_speed = cpu_to_be32(
 		    FDMI_PORT_SPEED_10GB);
-	else if (IS_QLA27XX(ha))
+	else if (IS_QLA27XX(ha) || IS_QLA28XX(ha))
 		eiter->a.sup_speed = cpu_to_be32(
 		    FDMI_PORT_SPEED_32GB|
 		    FDMI_PORT_SPEED_16GB|
@@ -2369,7 +2369,7 @@ qla2x00_fdmiv2_rpa(scsi_qla_host_t *vha)
 	if (IS_CNA_CAPABLE(ha))
 		eiter->a.sup_speed = cpu_to_be32(
 		    FDMI_PORT_SPEED_10GB);
-	else if (IS_QLA27XX(ha))
+	else if (IS_QLA27XX(ha) || IS_QLA28XX(ha))
 		eiter->a.sup_speed = cpu_to_be32(
 		    FDMI_PORT_SPEED_32GB|
 		    FDMI_PORT_SPEED_16GB|
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
diff --git a/drivers/scsi/qla2xxx/qla_iocb.c b/drivers/scsi/qla2xxx/qla_iocb.c
index dd132658631c..376179d5fee4 100644
--- a/drivers/scsi/qla2xxx/qla_iocb.c
+++ b/drivers/scsi/qla2xxx/qla_iocb.c
@@ -467,7 +467,7 @@ qla2x00_start_iocbs(struct scsi_qla_host *vha, struct req_que *req)
 			req->ring_ptr++;
 
 		/* Set chip new ring index. */
-		if (ha->mqenable || IS_QLA27XX(ha)) {
+		if (ha->mqenable || IS_QLA27XX(ha) || IS_QLA28XX(ha)) {
 			WRT_REG_DWORD(req->req_q_in, req->ring_index);
 		} else if (IS_QLA83XX(ha)) {
 			WRT_REG_DWORD(req->req_q_in, req->ring_index);
@@ -2114,7 +2114,8 @@ __qla2x00_alloc_iocbs(struct qla_qpair *qpair, srb_t *sp)
 	if (req->cnt < req_cnt + 2) {
 		if (qpair->use_shadow_reg)
 			cnt = *req->out_ptr;
-		else if (ha->mqenable || IS_QLA83XX(ha) || IS_QLA27XX(ha))
+		else if (ha->mqenable || IS_QLA83XX(ha) || IS_QLA27XX(ha) ||
+		    IS_QLA28XX(ha))
 			cnt = RD_REG_DWORD(&reg->isp25mq.req_q_out);
 		else if (IS_P3P_TYPE(ha))
 			cnt = RD_REG_DWORD(&reg->isp82.req_q_out);
diff --git a/drivers/scsi/qla2xxx/qla_isr.c b/drivers/scsi/qla2xxx/qla_isr.c
index ae69f3c45259..d256debd2764 100644
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@ -708,7 +708,8 @@ qla2x00_async_event(scsi_qla_host_t *vha, struct rsp_que *rsp, uint16_t *mb)
 		break;
 
 	case MBA_SYSTEM_ERR:		/* System Error */
-		mbx = (IS_QLA81XX(ha) || IS_QLA83XX(ha) || IS_QLA27XX(ha)) ?
+		mbx = (IS_QLA81XX(ha) || IS_QLA83XX(ha) || IS_QLA27XX(ha) ||
+		    IS_QLA28XX(ha)) ?
 			RD_REG_WORD(&reg24->mailbox7) : 0;
 		ql_log(ql_log_warn, vha, 0x5003,
 		    "ISP System Error - mbx1=%xh mbx2=%xh mbx3=%xh "
@@ -3002,7 +3003,8 @@ void qla24xx_process_response_queue(struct scsi_qla_host *vha,
 			qla24xx_els_ct_entry(vha, rsp->req, pkt, ELS_IOCB_TYPE);
 			break;
 		case ABTS_RECV_24XX:
-			if (IS_QLA83XX(ha) || IS_QLA27XX(ha)) {
+			if (IS_QLA83XX(ha) || IS_QLA27XX(ha) ||
+			    IS_QLA28XX(ha)) {
 				/* ensure that the ATIO queue is empty */
 				qlt_handle_abts_recv(vha, rsp,
 				    (response_t *)pkt);
@@ -3075,7 +3077,7 @@ qla2xxx_check_risc_status(scsi_qla_host_t *vha)
 	struct device_reg_24xx __iomem *reg = &ha->iobase->isp24;
 
 	if (!IS_QLA25XX(ha) && !IS_QLA81XX(ha) && !IS_QLA83XX(ha) &&
-	    !IS_QLA27XX(ha))
+	    !IS_QLA27XX(ha) && !IS_QLA28XX(ha))
 		return;
 
 	rval = QLA_SUCCESS;
@@ -3527,7 +3529,7 @@ qla24xx_enable_msix(struct qla_hw_data *ha, struct rsp_que *rsp)
 	}
 
 	/* Enable MSI-X vector for response queue update for queue 0 */
-	if (IS_QLA83XX(ha) || IS_QLA27XX(ha)) {
+	if (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha)) {
 		if (ha->msixbase && ha->mqiobase &&
 		    (ha->max_rsp_queues > 1 || ha->max_req_queues > 1 ||
 		     ql2xmqsupport))
@@ -3558,7 +3560,7 @@ qla2x00_request_irqs(struct qla_hw_data *ha, struct rsp_que *rsp)
 	/* If possible, enable MSI-X. */
 	if (ql2xenablemsix == 0 || (!IS_QLA2432(ha) && !IS_QLA2532(ha) &&
 	    !IS_QLA8432(ha) && !IS_CNA_CAPABLE(ha) && !IS_QLA2031(ha) &&
-	    !IS_QLAFX00(ha) && !IS_QLA27XX(ha)))
+	    !IS_QLAFX00(ha) && !IS_QLA27XX(ha) && !IS_QLA28XX(ha)))
 		goto skip_msi;
 
 	if (ql2xenablemsix == 2)
@@ -3597,7 +3599,7 @@ qla2x00_request_irqs(struct qla_hw_data *ha, struct rsp_que *rsp)
 
 	if (!IS_QLA24XX(ha) && !IS_QLA2532(ha) && !IS_QLA8432(ha) &&
 	    !IS_QLA8001(ha) && !IS_P3P_TYPE(ha) && !IS_QLAFX00(ha) &&
-	    !IS_QLA27XX(ha))
+	    !IS_QLA27XX(ha) && !IS_QLA28XX(ha))
 		goto skip_msi;
 
 	ret = pci_alloc_irq_vectors(ha->pdev, 1, 1, PCI_IRQ_MSI);
* Unmerged path drivers/scsi/qla2xxx/qla_mbx.c
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
diff --git a/drivers/scsi/qla2xxx/qla_sup.c b/drivers/scsi/qla2xxx/qla_sup.c
index 2a3055c799fb..579d6a8c7ba0 100644
--- a/drivers/scsi/qla2xxx/qla_sup.c
+++ b/drivers/scsi/qla2xxx/qla_sup.c
@@ -571,6 +571,9 @@ qla2xxx_find_flt_start(scsi_qla_host_t *vha, uint32_t *start)
 	} else if (IS_QLA83XX(ha) || IS_QLA27XX(ha)) {
 		*start = FA_FLASH_LAYOUT_ADDR_83;
 		goto end;
+	} else if (IS_QLA28XX(ha)) {
+		*start = FA_FLASH_LAYOUT_ADDR_28;
+		goto end;
 	}
 	/* Begin with first PCI expansion ROM header. */
 	buf = (uint8_t *)req->ring;
@@ -753,13 +756,13 @@ qla2xxx_get_flt_info(scsi_qla_host_t *vha, uint32_t flt_addr)
 				ha->flt_region_vpd = start;
 			break;
 		case FLT_REG_VPD_2:
-			if (!IS_QLA27XX(ha))
+			if (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))
 				break;
 			if (ha->port_no == 2)
 				ha->flt_region_vpd = start;
 			break;
 		case FLT_REG_VPD_3:
-			if (!IS_QLA27XX(ha))
+			if (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))
 				break;
 			if (ha->port_no == 3)
 				ha->flt_region_vpd = start;
@@ -777,13 +780,13 @@ qla2xxx_get_flt_info(scsi_qla_host_t *vha, uint32_t flt_addr)
 				ha->flt_region_nvram = start;
 			break;
 		case FLT_REG_NVRAM_2:
-			if (!IS_QLA27XX(ha))
+			if (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))
 				break;
 			if (ha->port_no == 2)
 				ha->flt_region_nvram = start;
 			break;
 		case FLT_REG_NVRAM_3:
-			if (!IS_QLA27XX(ha))
+			if (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))
 				break;
 			if (ha->port_no == 3)
 				ha->flt_region_nvram = start;
@@ -847,35 +850,35 @@ qla2xxx_get_flt_info(scsi_qla_host_t *vha, uint32_t flt_addr)
 				ha->flt_region_nvram = start;
 			break;
 		case FLT_REG_IMG_PRI_27XX:
-			if (IS_QLA27XX(ha))
+			if (IS_QLA27XX(ha) && !IS_QLA28XX(ha))
 				ha->flt_region_img_status_pri = start;
 			break;
 		case FLT_REG_IMG_SEC_27XX:
-			if (IS_QLA27XX(ha))
+			if (IS_QLA27XX(ha) && !IS_QLA28XX(ha))
 				ha->flt_region_img_status_sec = start;
 			break;
 		case FLT_REG_FW_SEC_27XX:
-			if (IS_QLA27XX(ha))
+			if (IS_QLA27XX(ha) && !IS_QLA28XX(ha))
 				ha->flt_region_fw_sec = start;
 			break;
 		case FLT_REG_BOOTLOAD_SEC_27XX:
-			if (IS_QLA27XX(ha))
+			if (IS_QLA27XX(ha) && !IS_QLA28XX(ha))
 				ha->flt_region_boot_sec = start;
 			break;
 		case FLT_REG_VPD_SEC_27XX_0:
-			if (IS_QLA27XX(ha))
+			if (IS_QLA27XX(ha) && !IS_QLA28XX(ha))
 				ha->flt_region_vpd_sec = start;
 			break;
 		case FLT_REG_VPD_SEC_27XX_1:
-			if (IS_QLA27XX(ha))
+			if (IS_QLA27XX(ha) && !IS_QLA28XX(ha))
 				ha->flt_region_vpd_sec = start;
 			break;
 		case FLT_REG_VPD_SEC_27XX_2:
-			if (IS_QLA27XX(ha))
+			if (IS_QLA27XX(ha) && !IS_QLA28XX(ha))
 				ha->flt_region_vpd_sec = start;
 			break;
 		case FLT_REG_VPD_SEC_27XX_3:
-			if (IS_QLA27XX(ha))
+			if (IS_QLA27XX(ha) && !IS_QLA28XX(ha))
 				ha->flt_region_vpd_sec = start;
 			break;
 		}
@@ -1045,7 +1048,8 @@ qla2xxx_get_flash_info(scsi_qla_host_t *vha)
 	struct qla_hw_data *ha = vha->hw;
 
 	if (!IS_QLA24XX_TYPE(ha) && !IS_QLA25XX(ha) &&
-	    !IS_CNA_CAPABLE(ha) && !IS_QLA2031(ha) && !IS_QLA27XX(ha))
+	    !IS_CNA_CAPABLE(ha) && !IS_QLA2031(ha) &&
+	    !IS_QLA27XX(ha) && !IS_QLA28XX(ha))
 		return QLA_SUCCESS;
 
 	ret = qla2xxx_find_flt_start(vha, &flt_addr);
@@ -1248,7 +1252,7 @@ qla24xx_write_flash_data(scsi_qla_host_t *vha, uint32_t *dwptr, uint32_t faddr,
 
 	/* Prepare burst-capable write on supported ISPs. */
 	if ((IS_QLA25XX(ha) || IS_QLA81XX(ha) || IS_QLA83XX(ha) ||
-	    IS_QLA27XX(ha)) &&
+	    IS_QLA27XX(ha) || IS_QLA28XX(ha)) &&
 	    !(faddr & 0xfff) && dwords > OPTROM_BURST_DWORDS) {
 		optrom = dma_alloc_coherent(&ha->pdev->dev, OPTROM_BURST_SIZE,
 		    &optrom_dma, GFP_KERNEL);
@@ -1728,7 +1732,7 @@ qla83xx_select_led_port(struct qla_hw_data *ha)
 {
 	uint32_t led_select_value = 0;
 
-	if (!IS_QLA83XX(ha) && !IS_QLA27XX(ha))
+	if (!IS_QLA83XX(ha) && !IS_QLA27XX(ha) && !IS_QLA28XX(ha))
 		goto out;
 
 	if (ha->port_no == 0)
@@ -1749,13 +1753,14 @@ qla83xx_beacon_blink(struct scsi_qla_host *vha)
 	uint16_t orig_led_cfg[6];
 	uint32_t led_10_value, led_43_value;
 
-	if (!IS_QLA83XX(ha) && !IS_QLA81XX(ha) && !IS_QLA27XX(ha))
+	if (!IS_QLA83XX(ha) && !IS_QLA81XX(ha) && !IS_QLA27XX(ha) &&
+	    !IS_QLA28XX(ha))
 		return;
 
 	if (!ha->beacon_blink_led)
 		return;
 
-	if (IS_QLA27XX(ha)) {
+	if (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {
 		qla2x00_write_ram_word(vha, 0x1003, 0x40000230);
 		qla2x00_write_ram_word(vha, 0x1004, 0x40000230);
 	} else if (IS_QLA2031(ha)) {
@@ -1845,7 +1850,7 @@ qla24xx_beacon_on(struct scsi_qla_host *vha)
 			return QLA_FUNCTION_FAILED;
 		}
 
-		if (IS_QLA2031(ha) || IS_QLA27XX(ha))
+		if (IS_QLA2031(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha))
 			goto skip_gpio;
 
 		spin_lock_irqsave(&ha->hardware_lock, flags);
@@ -1885,7 +1890,7 @@ qla24xx_beacon_off(struct scsi_qla_host *vha)
 
 	ha->beacon_blink_led = 0;
 
-	if (IS_QLA2031(ha) || IS_QLA27XX(ha))
+	if (IS_QLA2031(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha))
 		goto set_fw_options;
 
 	if (IS_QLA8031(ha) || IS_QLA81XX(ha))
@@ -2620,7 +2625,7 @@ qla25xx_read_optrom_data(struct scsi_qla_host *vha, uint8_t *buf,
 	struct qla_hw_data *ha = vha->hw;
 
 	if (IS_QLA25XX(ha) || IS_QLA81XX(ha) || IS_QLA83XX(ha) ||
-	    IS_QLA27XX(ha))
+	    IS_QLA27XX(ha) || IS_QLA28XX(ha))
 		goto try_fast;
 	if (offset & 0xfff)
 		goto slow_read;
@@ -3042,7 +3047,7 @@ qla24xx_get_flash_version(scsi_qla_host_t *vha, void *mbuf)
 
 	dcode = mbuf;
 	pcihdr = ha->flt_region_boot << 2;
-	if (IS_QLA27XX(ha) &&
+	if ((IS_QLA27XX(ha) || IS_QLA28XX(ha)) &&
 	    qla27xx_find_valid_image(vha) == QLA27XX_SECONDARY_IMAGE)
 		pcihdr = ha->flt_region_boot_sec << 2;
 
@@ -3119,7 +3124,7 @@ qla24xx_get_flash_version(scsi_qla_host_t *vha, void *mbuf)
 	memset(ha->fw_revision, 0, sizeof(ha->fw_revision));
 	dcode = mbuf;
 	faddr = ha->flt_region_fw;
-	if (IS_QLA27XX(ha) &&
+	if ((IS_QLA27XX(ha) || IS_QLA28XX(ha)) &&
 	    qla27xx_find_valid_image(vha) == QLA27XX_SECONDARY_IMAGE)
 		faddr = ha->flt_region_fw_sec;
 
diff --git a/drivers/scsi/qla2xxx/qla_target.c b/drivers/scsi/qla2xxx/qla_target.c
index 93f50e9224ca..5f371503ecad 100644
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@ -6777,7 +6777,7 @@ qlt_24xx_config_rings(struct scsi_qla_host *vha)
 	RD_REG_DWORD(ISP_ATIO_Q_OUT(vha));
 
 	if (ha->flags.msix_enabled) {
-		if (IS_QLA83XX(ha) || IS_QLA27XX(ha)) {
+		if (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha)) {
 			if (IS_QLA2071(ha)) {
 				/* 4 ports Baker: Enable Interrupt Handshake */
 				icb->msix_atio = 0;
@@ -6792,7 +6792,7 @@ qlt_24xx_config_rings(struct scsi_qla_host *vha)
 		}
 	} else {
 		/* INTx|MSI */
-		if (IS_QLA83XX(ha) || IS_QLA27XX(ha)) {
+		if (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha)) {
 			icb->msix_atio = 0;
 			icb->firmware_options_2 |= BIT_26;
 			ql_dbg(ql_dbg_init, vha, 0xf072,
@@ -7058,7 +7058,8 @@ qlt_probe_one_stage1(struct scsi_qla_host *base_vha, struct qla_hw_data *ha)
 	if (!QLA_TGT_MODE_ENABLED())
 		return;
 
-	if  ((ql2xenablemsix == 0) || IS_QLA83XX(ha) || IS_QLA27XX(ha)) {
+	if  ((ql2xenablemsix == 0) || IS_QLA83XX(ha) || IS_QLA27XX(ha) ||
+	    IS_QLA28XX(ha)) {
 		ISP_ATIO_Q_IN(base_vha) = &ha->mqiobase->isp25mq.atio_q_in;
 		ISP_ATIO_Q_OUT(base_vha) = &ha->mqiobase->isp25mq.atio_q_out;
 	} else {
