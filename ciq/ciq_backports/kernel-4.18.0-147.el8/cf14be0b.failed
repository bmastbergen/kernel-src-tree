dma-direct: fix DMA_ATTR_NO_KERNEL_MAPPING

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Christoph Hellwig <hch@lst.de>
commit cf14be0b41c659ede89abef3f7ec0e98e6cfea5b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/cf14be0b.failed

The new DMA_ATTR_NO_KERNEL_MAPPING needs to actually assign
a dma_addr to work.  Also skip it if the architecture needs
forced decryption handling, as that needs a kernel virtual
address.

Fixes: d98849aff879 (dma-direct: handle DMA_ATTR_NO_KERNEL_MAPPING in common code)
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Lucas Stach <l.stach@pengutronix.de>
(cherry picked from commit cf14be0b41c659ede89abef3f7ec0e98e6cfea5b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/dma/direct.c
diff --cc kernel/dma/direct.c
index 26bb7b9a7670,974e96a1de44..000000000000
--- a/kernel/dma/direct.c
+++ b/kernel/dma/direct.c
@@@ -139,6 -130,16 +139,19 @@@ void *dma_direct_alloc_pages(struct dev
  	if (!page)
  		return NULL;
  
++<<<<<<< HEAD
++=======
+ 	if ((attrs & DMA_ATTR_NO_KERNEL_MAPPING) &&
+ 	    !force_dma_unencrypted(dev)) {
+ 		/* remove any dirty cache lines on the kernel alias */
+ 		if (!PageHighMem(page))
+ 			arch_dma_prep_coherent(page, size);
+ 		*dma_handle = phys_to_dma(dev, page_to_phys(page));
+ 		/* return the page pointer as the opaque cookie */
+ 		return page;
+ 	}
+ 
++>>>>>>> cf14be0b41c6 (dma-direct: fix DMA_ATTR_NO_KERNEL_MAPPING)
  	if (PageHighMem(page)) {
  		/*
  		 * Depending on the cma= arguments and per-arch setup
@@@ -172,8 -180,19 +185,19 @@@ void dma_direct_free_pages(struct devic
  {
  	unsigned int page_order = get_order(size);
  
++<<<<<<< HEAD
 +	if (force_dma_unencrypted())
++=======
+ 	if ((attrs & DMA_ATTR_NO_KERNEL_MAPPING) &&
+ 	    !force_dma_unencrypted(dev)) {
+ 		/* cpu_addr is a struct page cookie, not a kernel address */
+ 		__dma_direct_free_pages(dev, size, cpu_addr);
+ 		return;
+ 	}
+ 
+ 	if (force_dma_unencrypted(dev))
++>>>>>>> cf14be0b41c6 (dma-direct: fix DMA_ATTR_NO_KERNEL_MAPPING)
  		set_memory_encrypted((unsigned long)cpu_addr, 1 << page_order);
 -
 -	if (IS_ENABLED(CONFIG_ARCH_HAS_UNCACHED_SEGMENT) &&
 -	    dma_alloc_need_uncached(dev, attrs))
 -		cpu_addr = cached_kernel_address(cpu_addr);
  	__dma_direct_free_pages(dev, size, virt_to_page(cpu_addr));
  }
  
* Unmerged path kernel/dma/direct.c
