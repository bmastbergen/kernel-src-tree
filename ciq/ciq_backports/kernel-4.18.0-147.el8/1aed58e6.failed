Uprobes: Fix kernel oops with delayed_uprobe_remove()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Ravi Bangoria <ravi.bangoria@linux.ibm.com>
commit 1aed58e67a6ec1e7a18bfabe8ba6ec2d27c15636
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/1aed58e6.failed

There could be a race between task exit and probe unregister:

  exit_mm()
  mmput()
  __mmput()                     uprobe_unregister()
  uprobe_clear_state()          put_uprobe()
  delayed_uprobe_remove()       delayed_uprobe_remove()

put_uprobe() is calling delayed_uprobe_remove() without taking
delayed_uprobe_lock and thus the race sometimes results in a
kernel crash. Fix this by taking delayed_uprobe_lock before
calling delayed_uprobe_remove() from put_uprobe().

Detailed crash log can be found at:
  Link: http://lkml.kernel.org/r/000000000000140c370577db5ece@google.com

Link: http://lkml.kernel.org/r/20181205033423.26242-1-ravi.bangoria@linux.ibm.com

	Acked-by: Oleg Nesterov <oleg@redhat.com>
	Reviewed-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
	Reported-by: syzbot+cb1fb754b771caca0a88@syzkaller.appspotmail.com
Fixes: 1cc33161a83d ("uprobes: Support SDT markers having reference count (semaphore)")
	Signed-off-by: Ravi Bangoria <ravi.bangoria@linux.ibm.com>
	Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
(cherry picked from commit 1aed58e67a6ec1e7a18bfabe8ba6ec2d27c15636)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/events/uprobes.c
diff --cc kernel/events/uprobes.c
index 85aea4cff4cb,98b9312ce6b2..000000000000
--- a/kernel/events/uprobes.c
+++ b/kernel/events/uprobes.c
@@@ -378,8 -566,17 +378,20 @@@ static struct uprobe *get_uprobe(struc
  
  static void put_uprobe(struct uprobe *uprobe)
  {
++<<<<<<< HEAD
 +	if (atomic_dec_and_test(&uprobe->ref))
++=======
+ 	if (atomic_dec_and_test(&uprobe->ref)) {
+ 		/*
+ 		 * If application munmap(exec_vma) before uprobe_unregister()
+ 		 * gets called, we don't get a chance to remove uprobe from
+ 		 * delayed_uprobe_list from remove_breakpoint(). Do it here.
+ 		 */
+ 		mutex_lock(&delayed_uprobe_lock);
+ 		delayed_uprobe_remove(uprobe, NULL);
+ 		mutex_unlock(&delayed_uprobe_lock);
++>>>>>>> 1aed58e67a6e (Uprobes: Fix kernel oops with delayed_uprobe_remove())
  		kfree(uprobe);
 -	}
  }
  
  static int match_uprobe(struct uprobe *l, struct uprobe *r)
* Unmerged path kernel/events/uprobes.c
