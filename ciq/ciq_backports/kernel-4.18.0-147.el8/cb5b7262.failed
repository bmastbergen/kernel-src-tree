nvme: provide fallback for discard alloc failure

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jens Axboe <axboe@kernel.dk>
commit cb5b7262b011cfb793519bf97e54dff5282da23c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/cb5b7262.failed

When boxes are run near (or to) OOM, we have a problem with the discard
page allocation in nvme. If we fail allocating the special page, we
return busy, and it'll get retried. But since ordering is honored for
dispatch requests, we can keep retrying this same IO and failing. Behind
that IO could be requests that want to free memory, but they never get
the chance.

Allocate a fixed discard page per controller for a safe fallback, and use
that if the initial allocation fails.

	Signed-off-by: Jens Axboe <axboe@kernel.dk>
	Reviewed-by: Keith Busch <keith.busch@intel.com>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit cb5b7262b011cfb793519bf97e54dff5282da23c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
diff --cc drivers/nvme/host/core.c
index ce791195c81d,168f2c1eaf60..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -3489,6 -3595,8 +3507,11 @@@ static void nvme_free_ctrl(struct devic
  
  	ida_simple_remove(&nvme_instance_ida, ctrl->instance);
  	kfree(ctrl->effects);
++<<<<<<< HEAD
++=======
+ 	nvme_mpath_uninit(ctrl);
+ 	kfree(ctrl->discard_page);
++>>>>>>> cb5b7262b011 (nvme: provide fallback for discard alloc failure)
  
  	if (subsys) {
  		mutex_lock(&subsys->lock);
* Unmerged path drivers/nvme/host/core.c
diff --git a/drivers/nvme/host/nvme.h b/drivers/nvme/host/nvme.h
index 3d04af723ac5..08c4d7d4e319 100644
--- a/drivers/nvme/host/nvme.h
+++ b/drivers/nvme/host/nvme.h
@@ -224,6 +224,9 @@ struct nvme_ctrl {
 	u16 maxcmd;
 	int nr_reconnects;
 	struct nvmf_ctrl_options *opts;
+
+	struct page *discard_page;
+	unsigned long discard_page_busy;
 };
 
 struct nvme_subsystem {
