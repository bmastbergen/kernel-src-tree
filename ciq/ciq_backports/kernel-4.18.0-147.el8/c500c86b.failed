net/mlx5e: support for two independent packet edit actions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit c500c86b0c75da167b59ee82f78e394fd10cb792
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/c500c86b.failed

This patch adds pedit_headers_action structure to store the result of
parsing tc pedit actions. Then, it calls alloc_tc_pedit_action() to
populate the mlx5e hardware intermediate representation once all actions
have been parsed.

This patch comes in preparation for the new flow_action infrastructure,
where each packet mangling comes in an separated action, ie. not packed
as in tc pedit.

	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Acked-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c500c86b0c75da167b59ee82f78e394fd10cb792)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 06543506a2d4,1c8e8da166bd..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -1719,13 -1881,13 +1724,19 @@@ static struct mlx5_fields fields[] = 
  	OFFLOAD(UDP_DPORT, 2, udp.dest,   0),
  };
  
 -/* On input attr->num_mod_hdr_actions tells how many HW actions can be parsed at
 - * max from the SW pedit action. On success, it says how many HW actions were
 - * actually parsed.
 +/* On input attr->max_mod_hdr_actions tells how many HW actions can be parsed at
 + * max from the SW pedit action. On success, attr->num_mod_hdr_actions
 + * says how many HW actions were actually parsed.
   */
++<<<<<<< HEAD
 +static int offload_pedit_fields(struct pedit_headers *masks,
 +				struct pedit_headers *vals,
 +				struct mlx5e_tc_flow_parse_attr *parse_attr)
++=======
+ static int offload_pedit_fields(struct pedit_headers_action *hdrs,
+ 				struct mlx5e_tc_flow_parse_attr *parse_attr,
+ 				struct netlink_ext_ack *extack)
++>>>>>>> c500c86b0c75 (net/mlx5e: support for two independent packet edit actions)
  {
  	struct pedit_headers *set_masks, *add_masks, *set_vals, *add_vals;
  	int i, action_size, nactions, max_actions, first, last, next_z;
@@@ -1738,17 -1900,15 +1749,17 @@@
  	__be16 mask_be16;
  	void *action;
  
- 	set_masks = &masks[TCA_PEDIT_KEY_EX_CMD_SET];
- 	add_masks = &masks[TCA_PEDIT_KEY_EX_CMD_ADD];
- 	set_vals = &vals[TCA_PEDIT_KEY_EX_CMD_SET];
- 	add_vals = &vals[TCA_PEDIT_KEY_EX_CMD_ADD];
+ 	set_masks = &hdrs[TCA_PEDIT_KEY_EX_CMD_SET].masks;
+ 	add_masks = &hdrs[TCA_PEDIT_KEY_EX_CMD_ADD].masks;
+ 	set_vals = &hdrs[TCA_PEDIT_KEY_EX_CMD_SET].vals;
+ 	add_vals = &hdrs[TCA_PEDIT_KEY_EX_CMD_ADD].vals;
  
  	action_size = MLX5_UN_SZ_BYTES(set_action_in_add_action_in_auto);
 -	action = parse_attr->mod_hdr_actions;
 -	max_actions = parse_attr->num_mod_hdr_actions;
 -	nactions = 0;
 +	action = parse_attr->mod_hdr_actions +
 +		 parse_attr->num_mod_hdr_actions * action_size;
 +
 +	max_actions = parse_attr->max_mod_hdr_actions;
 +	nactions = parse_attr->num_mod_hdr_actions;
  
  	for (i = 0; i < ARRAY_SIZE(fields); i++) {
  		f = &fields[i];
@@@ -1861,9 -2029,10 +1874,14 @@@ static const struct pedit_headers zero_
  
  static int parse_tc_pedit_action(struct mlx5e_priv *priv,
  				 const struct tc_action *a, int namespace,
++<<<<<<< HEAD
 +				 struct mlx5e_tc_flow_parse_attr *parse_attr)
++=======
+ 				 struct mlx5e_tc_flow_parse_attr *parse_attr,
+ 				 struct pedit_headers_action *hdrs,
+ 				 struct netlink_ext_ack *extack)
++>>>>>>> c500c86b0c75 (net/mlx5e: support for two independent packet edit actions)
  {
- 	struct pedit_headers masks[__PEDIT_CMD_MAX], vals[__PEDIT_CMD_MAX], *cmd_masks;
  	int nkeys, i, err = -EOPNOTSUPP;
  	u32 mask, val, offset;
  	u8 cmd, htype;
@@@ -1892,24 -2059,40 +1907,48 @@@
  		val = tcf_pedit_val(a, i);
  		offset = tcf_pedit_offset(a, i);
  
- 		err = set_pedit_val(htype, ~mask, val, offset, &masks[cmd], &vals[cmd]);
+ 		err = set_pedit_val(htype, ~mask, val, offset, &hdrs[cmd]);
  		if (err)
  			goto out_err;
+ 
+ 		hdrs[cmd].pedits++;
  	}
  
++<<<<<<< HEAD
 +	if (!parse_attr->mod_hdr_actions) {
 +		err = alloc_mod_hdr_actions(priv, a, namespace, parse_attr);
 +		if (err)
 +			goto out_err;
 +	}
 +
 +	err = offload_pedit_fields(masks, vals, parse_attr);
++=======
+ 	return 0;
+ out_err:
+ 	return err;
+ }
+ 
+ static int alloc_tc_pedit_action(struct mlx5e_priv *priv, int namespace,
+ 				 struct mlx5e_tc_flow_parse_attr *parse_attr,
+ 				 struct pedit_headers_action *hdrs,
+ 				 struct netlink_ext_ack *extack)
+ {
+ 	struct pedit_headers *cmd_masks;
+ 	int err;
+ 	u8 cmd;
+ 
+ 	err = alloc_mod_hdr_actions(priv, hdrs, namespace, parse_attr);
+ 	if (err)
+ 		goto out_err;
+ 
+ 	err = offload_pedit_fields(hdrs, parse_attr, extack);
++>>>>>>> c500c86b0c75 (net/mlx5e: support for two independent packet edit actions)
  	if (err < 0)
  		goto out_dealloc_parsed_actions;
  
  	for (cmd = 0; cmd < __PEDIT_CMD_MAX; cmd++) {
- 		cmd_masks = &masks[cmd];
+ 		cmd_masks = &hdrs[cmd].masks;
  		if (memcmp(cmd_masks, &zero_masks, sizeof(zero_masks))) {
 -			NL_SET_ERR_MSG_MOD(extack,
 -					   "attempt to offload an unsupported field");
  			netdev_warn(priv->netdev, "attempt to offload an unsupported field (cmd %d)\n", cmd);
  			print_hex_dump(KERN_WARNING, "mask: ", DUMP_PREFIX_ADDRESS,
  				       16, 1, cmd_masks, sizeof(zero_masks), true);
@@@ -2032,8 -2227,10 +2071,9 @@@ static bool same_hw_devs(struct mlx5e_p
  
  static int parse_tc_nic_actions(struct mlx5e_priv *priv, struct tcf_exts *exts,
  				struct mlx5e_tc_flow_parse_attr *parse_attr,
 -				struct mlx5e_tc_flow *flow,
 -				struct netlink_ext_ack *extack)
 +				struct mlx5e_tc_flow *flow)
  {
+ 	struct pedit_headers_action hdrs[__PEDIT_CMD_MAX] = {};
  	struct mlx5_nic_flow_attr *attr = flow->nic_attr;
  	const struct tc_action *a;
  	u32 action = 0;
@@@ -2055,7 -2252,7 +2095,11 @@@
  
  		if (is_tcf_pedit(a)) {
  			err = parse_tc_pedit_action(priv, a, MLX5_FLOW_NAMESPACE_KERNEL,
++<<<<<<< HEAD
 +						    parse_attr);
++=======
+ 						    parse_attr, hdrs, extack);
++>>>>>>> c500c86b0c75 (net/mlx5e: support for two independent packet edit actions)
  			if (err)
  				return err;
  
@@@ -2106,8 -2306,16 +2150,16 @@@
  		return -EINVAL;
  	}
  
+ 	if (hdrs[TCA_PEDIT_KEY_EX_CMD_SET].pedits ||
+ 	    hdrs[TCA_PEDIT_KEY_EX_CMD_ADD].pedits) {
+ 		err = alloc_tc_pedit_action(priv, MLX5_FLOW_NAMESPACE_KERNEL,
+ 					    parse_attr, hdrs, extack);
+ 		if (err)
+ 			return err;
+ 	}
+ 
  	attr->action = action;
 -	if (!actions_match_supported(priv, exts, parse_attr, flow, extack))
 +	if (!actions_match_supported(priv, exts, parse_attr, flow))
  		return -EOPNOTSUPP;
  
  	return 0;
@@@ -2604,8 -2471,11 +2656,13 @@@ out_err
  
  static int parse_tc_fdb_actions(struct mlx5e_priv *priv, struct tcf_exts *exts,
  				struct mlx5e_tc_flow_parse_attr *parse_attr,
 -				struct mlx5e_tc_flow *flow,
 -				struct netlink_ext_ack *extack)
 +				struct mlx5e_tc_flow *flow)
  {
++<<<<<<< HEAD
++=======
+ 	struct pedit_headers_action hdrs[__PEDIT_CMD_MAX] = {};
+ 	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
++>>>>>>> c500c86b0c75 (net/mlx5e: support for two independent packet edit actions)
  	struct mlx5_esw_flow_attr *attr = flow->esw_attr;
  	struct mlx5e_rep_priv *rpriv = priv->ppriv;
  	struct ip_tunnel_info *info = NULL;
@@@ -2628,10 -2498,8 +2685,14 @@@
  		}
  
  		if (is_tcf_pedit(a)) {
 +			int err;
 +
  			err = parse_tc_pedit_action(priv, a, MLX5_FLOW_NAMESPACE_FDB,
++<<<<<<< HEAD
 +						    parse_attr);
++=======
+ 						    parse_attr, hdrs, extack);
++>>>>>>> c500c86b0c75 (net/mlx5e: support for two independent packet edit actions)
  			if (err)
  				return err;
  
@@@ -2725,11 -2616,47 +2786,19 @@@
  		return -EINVAL;
  	}
  
+ 	if (hdrs[TCA_PEDIT_KEY_EX_CMD_SET].pedits ||
+ 	    hdrs[TCA_PEDIT_KEY_EX_CMD_ADD].pedits) {
+ 		err = alloc_tc_pedit_action(priv, MLX5_FLOW_NAMESPACE_KERNEL,
+ 					    parse_attr, hdrs, extack);
+ 		if (err)
+ 			return err;
+ 	}
+ 
  	attr->action = action;
 -	if (!actions_match_supported(priv, exts, parse_attr, flow, extack))
 +	if (!actions_match_supported(priv, exts, parse_attr, flow))
  		return -EOPNOTSUPP;
  
 -	if (attr->dest_chain) {
 -		if (attr->action & MLX5_FLOW_CONTEXT_ACTION_FWD_DEST) {
 -			NL_SET_ERR_MSG(extack, "Mirroring goto chain rules isn't supported");
 -			return -EOPNOTSUPP;
 -		}
 -		attr->action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;
 -	}
 -
 -	if (attr->split_count > 0 && !mlx5_esw_has_fwd_fdb(priv->mdev)) {
 -		NL_SET_ERR_MSG_MOD(extack,
 -				   "current firmware doesn't support split rule for port mirroring");
 +	if (attr->mirror_count > 0 && !mlx5_esw_has_fwd_fdb(priv->mdev)) {
  		netdev_warn_once(priv->netdev, "current firmware doesn't support split rule for port mirroring\n");
  		return -EOPNOTSUPP;
  	}
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
