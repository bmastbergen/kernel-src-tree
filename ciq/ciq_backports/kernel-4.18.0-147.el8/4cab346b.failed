net/mlx5: No command allowed when command interface is not ready

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Huy Nguyen <huyn@mellanox.com>
commit 4cab346bcf74f44665d57726ec2bccff6e679619
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/4cab346b.failed

When EEH is injected and PCI bus stalls, mlx5's pci error detect
function is called to deactivate the command interface and tear down
the device. The issue is that there can be a thread that already
passed MLX5_DEVICE_STATE_INTERNAL_ERROR check, it will send the command
and stuck in the wait_func.

Solution:
Add function mlx5_cmd_flush to disable command interface and clear all
the pending commands. When device state is set to
MLX5_DEVICE_STATE_INTERNAL_ERROR, call mlx5_cmd_flush to ensure all
pending threads waiting for firmware commands completion are terminated.

Fixes: c1d4d2e92ad6 ("net/mlx5: Avoid calling sleeping function by the health poll thread")
	Signed-off-by: Huy Nguyen <huyn@mellanox.com>
	Reviewed-by: Daniel Jurgens <danielj@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 4cab346bcf74f44665d57726ec2bccff6e679619)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/health.c
#	drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/health.c
index 43118de8ee99,cb9fa3430c53..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/health.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/health.c
@@@ -124,10 -103,10 +124,14 @@@ void mlx5_enter_error_state(struct mlx5
  	mlx5_core_err(dev, "start\n");
  	if (pci_channel_offline(dev->pdev) || in_fatal(dev) || force) {
  		dev->state = MLX5_DEVICE_STATE_INTERNAL_ERROR;
++<<<<<<< HEAD
 +		trigger_cmd_completions(dev);
++=======
+ 		mlx5_cmd_flush(dev);
++>>>>>>> 4cab346bcf74 (net/mlx5: No command allowed when command interface is not ready)
  	}
  
 -	mlx5_notifier_call_chain(dev->priv.events, MLX5_DEV_EVENT_SYS_ERROR, (void *)1);
 +	mlx5_core_event(dev, MLX5_DEV_EVENT_SYS_ERROR, 1);
  	mlx5_core_err(dev, "end\n");
  
  unlock:
diff --cc drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
index dad0e9c5ec61,4fdac020b795..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
@@@ -126,28 -125,8 +126,33 @@@ int mlx5_wait_for_vf_pages(struct mlx5_
  u64 mlx5_read_internal_timer(struct mlx5_core_dev *dev,
  			     struct ptp_system_timestamp *sts);
  
++<<<<<<< HEAD
 +int mlx5_eq_init(struct mlx5_core_dev *dev);
 +void mlx5_eq_cleanup(struct mlx5_core_dev *dev);
 +int mlx5_create_map_eq(struct mlx5_core_dev *dev, struct mlx5_eq *eq, u8 vecidx,
 +		       int nent, u64 mask, const char *name,
 +		       enum mlx5_eq_type type);
 +int mlx5_destroy_unmap_eq(struct mlx5_core_dev *dev, struct mlx5_eq *eq);
 +int mlx5_eq_add_cq(struct mlx5_eq *eq, struct mlx5_core_cq *cq);
 +int mlx5_eq_del_cq(struct mlx5_eq *eq, struct mlx5_core_cq *cq);
 +int mlx5_core_eq_query(struct mlx5_core_dev *dev, struct mlx5_eq *eq,
 +		       u32 *out, int outlen);
 +int mlx5_start_eqs(struct mlx5_core_dev *dev);
 +void mlx5_stop_eqs(struct mlx5_core_dev *dev);
 +/* This function should only be called after mlx5_cmd_force_teardown_hca */
 +void mlx5_core_eq_free_irqs(struct mlx5_core_dev *dev);
 +struct mlx5_eq *mlx5_eqn2eq(struct mlx5_core_dev *dev, int eqn);
 +u32 mlx5_eq_poll_irq_disabled(struct mlx5_eq *eq);
 +void mlx5_cq_tasklet_cb(unsigned long data);
 +void mlx5_cmd_comp_handler(struct mlx5_core_dev *dev, u64 vec, bool forced);
 +int mlx5_debug_eq_add(struct mlx5_core_dev *dev, struct mlx5_eq *eq);
 +void mlx5_debug_eq_remove(struct mlx5_core_dev *dev, struct mlx5_eq *eq);
 +int mlx5_eq_debugfs_init(struct mlx5_core_dev *dev);
 +void mlx5_eq_debugfs_cleanup(struct mlx5_core_dev *dev);
++=======
+ void mlx5_cmd_trigger_completions(struct mlx5_core_dev *dev);
+ void mlx5_cmd_flush(struct mlx5_core_dev *dev);
++>>>>>>> 4cab346bcf74 (net/mlx5: No command allowed when command interface is not ready)
  int mlx5_cq_debugfs_init(struct mlx5_core_dev *dev);
  void mlx5_cq_debugfs_cleanup(struct mlx5_core_dev *dev);
  
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/cmd.c b/drivers/net/ethernet/mellanox/mlx5/core/cmd.c
index e8bb3b4dbc2b..23ea65ebffee 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/cmd.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/cmd.c
@@ -1514,6 +1514,24 @@ void mlx5_cmd_comp_handler(struct mlx5_core_dev *dev, u64 vec, bool forced)
 }
 EXPORT_SYMBOL(mlx5_cmd_comp_handler);
 
+void mlx5_cmd_flush(struct mlx5_core_dev *dev)
+{
+	struct mlx5_cmd *cmd = &dev->cmd;
+	int i;
+
+	for (i = 0; i < cmd->max_reg_cmds; i++)
+		while (down_trylock(&cmd->sem))
+			mlx5_cmd_trigger_completions(dev);
+
+	while (down_trylock(&cmd->pages_sem))
+		mlx5_cmd_trigger_completions(dev);
+
+	/* Unlock cmdif */
+	up(&cmd->pages_sem);
+	for (i = 0; i < cmd->max_reg_cmds; i++)
+		up(&cmd->sem);
+}
+
 static int status_to_err(u8 status)
 {
 	return status ? -1 : 0; /* TBD more meaningful codes */
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/health.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
