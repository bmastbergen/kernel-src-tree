scsi: qla2xxx: Add fw_attr and port_no SysFS node

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Joe Carnuccio <joe.carnuccio@cavium.com>
commit df617ffbbc5ecb64334548546d4b0cc4ff0527c0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/df617ffb.failed

This patch adds new sysfs node to display firmware attributes and port
number.

	Signed-off-by: Joe Carnuccio <joe.carnuccio@cavium.com>
	Signed-off-by: Himanshu Madhani <hmadhani@marvell.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit df617ffbbc5ecb64334548546d4b0cc4ff0527c0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_attr.c
diff --cc drivers/scsi/qla2xxx/qla_attr.c
index 55925877df53,8cc4d6589cbb..000000000000
--- a/drivers/scsi/qla2xxx/qla_attr.c
+++ b/drivers/scsi/qla2xxx/qla_attr.c
@@@ -1516,7 -1635,562 +1516,566 @@@ qla2x00_max_speed_sup_show(struct devic
  	    ha->max_speed_sup ? "32Gps" : "16Gps");
  }
  
++<<<<<<< HEAD
 +static DEVICE_ATTR(driver_version, S_IRUGO, qla2x00_drvr_version_show, NULL);
++=======
+ static ssize_t
+ qla2x00_port_speed_store(struct device *dev, struct device_attribute *attr,
+     const char *buf, size_t count)
+ {
+ 	struct scsi_qla_host *vha = shost_priv(dev_to_shost(dev));
+ 	ulong type, speed;
+ 	int oldspeed, rval;
+ 	int mode = QLA_SET_DATA_RATE_LR;
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	if (!IS_QLA27XX(vha->hw)) {
+ 		ql_log(ql_log_warn, vha, 0x70d8,
+ 		    "Speed setting not supported \n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	rval = kstrtol(buf, 10, &type);
+ 	if (rval)
+ 		return rval;
+ 	speed = type;
+ 	if (type == 40 || type == 80 || type == 160 ||
+ 	    type == 320) {
+ 		ql_dbg(ql_dbg_user, vha, 0x70d9,
+ 		    "Setting will be affected after a loss of sync\n");
+ 		type = type/10;
+ 		mode = QLA_SET_DATA_RATE_NOLR;
+ 	}
+ 
+ 	oldspeed = ha->set_data_rate;
+ 
+ 	switch (type) {
+ 	case 0:
+ 		ha->set_data_rate = PORT_SPEED_AUTO;
+ 		break;
+ 	case 4:
+ 		ha->set_data_rate = PORT_SPEED_4GB;
+ 		break;
+ 	case 8:
+ 		ha->set_data_rate = PORT_SPEED_8GB;
+ 		break;
+ 	case 16:
+ 		ha->set_data_rate = PORT_SPEED_16GB;
+ 		break;
+ 	case 32:
+ 		ha->set_data_rate = PORT_SPEED_32GB;
+ 		break;
+ 	default:
+ 		ql_log(ql_log_warn, vha, 0x1199,
+ 		    "Unrecognized speed setting:%lx. Setting Autoneg\n",
+ 		    speed);
+ 		ha->set_data_rate = PORT_SPEED_AUTO;
+ 	}
+ 
+ 	if (qla2x00_chip_is_down(vha) || (oldspeed == ha->set_data_rate))
+ 		return -EINVAL;
+ 
+ 	ql_log(ql_log_info, vha, 0x70da,
+ 	    "Setting speed to %lx Gbps \n", type);
+ 
+ 	rval = qla2x00_set_data_rate(vha, mode);
+ 	if (rval != QLA_SUCCESS)
+ 		return -EIO;
+ 
+ 	return strlen(buf);
+ }
+ 
+ static ssize_t
+ qla2x00_port_speed_show(struct device *dev, struct device_attribute *attr,
+     char *buf)
+ {
+ 	struct scsi_qla_host *vha = shost_priv(dev_to_shost(dev));
+ 	struct qla_hw_data *ha = vha->hw;
+ 	ssize_t rval;
+ 	char *spd[7] = {"0", "0", "0", "4", "8", "16", "32"};
+ 
+ 	rval = qla2x00_get_data_rate(vha);
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_log(ql_log_warn, vha, 0x70db,
+ 		    "Unable to get port speed rval:%zd\n", rval);
+ 		return -EINVAL;
+ 	}
+ 
+ 	ql_log(ql_log_info, vha, 0x70d6,
+ 	    "port speed:%d\n", ha->link_data_rate);
+ 
+ 	return scnprintf(buf, PAGE_SIZE, "%s\n", spd[ha->link_data_rate]);
+ }
+ 
+ /* ----- */
+ 
+ static ssize_t
+ qlini_mode_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	scsi_qla_host_t *vha = shost_priv(class_to_shost(dev));
+ 	int len = 0;
+ 
+ 	len += scnprintf(buf + len, PAGE_SIZE-len,
+ 	    "Supported options: enabled | disabled | dual | exclusive\n");
+ 
+ 	/* --- */
+ 	len += scnprintf(buf + len, PAGE_SIZE-len, "Current selection: ");
+ 
+ 	switch (vha->qlini_mode) {
+ 	case QLA2XXX_INI_MODE_EXCLUSIVE:
+ 		len += scnprintf(buf + len, PAGE_SIZE-len,
+ 		    QLA2XXX_INI_MODE_STR_EXCLUSIVE);
+ 		break;
+ 	case QLA2XXX_INI_MODE_DISABLED:
+ 		len += scnprintf(buf + len, PAGE_SIZE-len,
+ 		    QLA2XXX_INI_MODE_STR_DISABLED);
+ 		break;
+ 	case QLA2XXX_INI_MODE_ENABLED:
+ 		len += scnprintf(buf + len, PAGE_SIZE-len,
+ 		    QLA2XXX_INI_MODE_STR_ENABLED);
+ 		break;
+ 	case QLA2XXX_INI_MODE_DUAL:
+ 		len += scnprintf(buf + len, PAGE_SIZE-len,
+ 		    QLA2XXX_INI_MODE_STR_DUAL);
+ 		break;
+ 	}
+ 	len += scnprintf(buf + len, PAGE_SIZE-len, "\n");
+ 
+ 	return len;
+ }
+ 
+ static char *mode_to_str[] = {
+ 	"exclusive",
+ 	"disabled",
+ 	"enabled",
+ 	"dual",
+ };
+ 
+ #define NEED_EXCH_OFFLOAD(_exchg) ((_exchg) > FW_DEF_EXCHANGES_CNT)
+ static int qla_set_ini_mode(scsi_qla_host_t *vha, int op)
+ {
+ 	int rc = 0;
+ 	enum {
+ 		NO_ACTION,
+ 		MODE_CHANGE_ACCEPT,
+ 		MODE_CHANGE_NO_ACTION,
+ 		TARGET_STILL_ACTIVE,
+ 	};
+ 	int action = NO_ACTION;
+ 	int set_mode = 0;
+ 	u8  eo_toggle = 0;	/* exchange offload flipped */
+ 
+ 	switch (vha->qlini_mode) {
+ 	case QLA2XXX_INI_MODE_DISABLED:
+ 		switch (op) {
+ 		case QLA2XXX_INI_MODE_DISABLED:
+ 			if (qla_tgt_mode_enabled(vha)) {
+ 				if (NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld) !=
+ 				    vha->hw->flags.exchoffld_enabled)
+ 					eo_toggle = 1;
+ 				if (((vha->ql2xexchoffld !=
+ 				    vha->u_ql2xexchoffld) &&
+ 				    NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld)) ||
+ 				    eo_toggle) {
+ 					/*
+ 					 * The number of exchange to be offload
+ 					 * was tweaked or offload option was
+ 					 * flipped
+ 					 */
+ 					action = MODE_CHANGE_ACCEPT;
+ 				} else {
+ 					action = MODE_CHANGE_NO_ACTION;
+ 				}
+ 			} else {
+ 				action = MODE_CHANGE_NO_ACTION;
+ 			}
+ 			break;
+ 		case QLA2XXX_INI_MODE_EXCLUSIVE:
+ 			if (qla_tgt_mode_enabled(vha)) {
+ 				if (NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld) !=
+ 				    vha->hw->flags.exchoffld_enabled)
+ 					eo_toggle = 1;
+ 				if (((vha->ql2xexchoffld !=
+ 				    vha->u_ql2xexchoffld) &&
+ 				    NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld)) ||
+ 				    eo_toggle) {
+ 					/*
+ 					 * The number of exchange to be offload
+ 					 * was tweaked or offload option was
+ 					 * flipped
+ 					 */
+ 					action = MODE_CHANGE_ACCEPT;
+ 				} else {
+ 					action = MODE_CHANGE_NO_ACTION;
+ 				}
+ 			} else {
+ 				action = MODE_CHANGE_ACCEPT;
+ 			}
+ 			break;
+ 		case QLA2XXX_INI_MODE_DUAL:
+ 			action = MODE_CHANGE_ACCEPT;
+ 			/* active_mode is target only, reset it to dual */
+ 			if (qla_tgt_mode_enabled(vha)) {
+ 				set_mode = 1;
+ 				action = MODE_CHANGE_ACCEPT;
+ 			} else {
+ 				action = MODE_CHANGE_NO_ACTION;
+ 			}
+ 			break;
+ 
+ 		case QLA2XXX_INI_MODE_ENABLED:
+ 			if (qla_tgt_mode_enabled(vha))
+ 				action = TARGET_STILL_ACTIVE;
+ 			else {
+ 				action = MODE_CHANGE_ACCEPT;
+ 				set_mode = 1;
+ 			}
+ 			break;
+ 		}
+ 		break;
+ 
+ 	case QLA2XXX_INI_MODE_EXCLUSIVE:
+ 		switch (op) {
+ 		case QLA2XXX_INI_MODE_EXCLUSIVE:
+ 			if (qla_tgt_mode_enabled(vha)) {
+ 				if (NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld) !=
+ 				    vha->hw->flags.exchoffld_enabled)
+ 					eo_toggle = 1;
+ 				if (((vha->ql2xexchoffld !=
+ 				    vha->u_ql2xexchoffld) &&
+ 				    NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld)) ||
+ 				    eo_toggle)
+ 					/*
+ 					 * The number of exchange to be offload
+ 					 * was tweaked or offload option was
+ 					 * flipped
+ 					 */
+ 					action = MODE_CHANGE_ACCEPT;
+ 				else
+ 					action = NO_ACTION;
+ 			} else
+ 				action = NO_ACTION;
+ 
+ 			break;
+ 
+ 		case QLA2XXX_INI_MODE_DISABLED:
+ 			if (qla_tgt_mode_enabled(vha)) {
+ 				if (NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld) !=
+ 				    vha->hw->flags.exchoffld_enabled)
+ 					eo_toggle = 1;
+ 				if (((vha->ql2xexchoffld !=
+ 				      vha->u_ql2xexchoffld) &&
+ 				    NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld)) ||
+ 				    eo_toggle)
+ 					action = MODE_CHANGE_ACCEPT;
+ 				else
+ 					action = MODE_CHANGE_NO_ACTION;
+ 			} else
+ 				action = MODE_CHANGE_NO_ACTION;
+ 			break;
+ 
+ 		case QLA2XXX_INI_MODE_DUAL: /* exclusive -> dual */
+ 			if (qla_tgt_mode_enabled(vha)) {
+ 				action = MODE_CHANGE_ACCEPT;
+ 				set_mode = 1;
+ 			} else
+ 				action = MODE_CHANGE_ACCEPT;
+ 			break;
+ 
+ 		case QLA2XXX_INI_MODE_ENABLED:
+ 			if (qla_tgt_mode_enabled(vha))
+ 				action = TARGET_STILL_ACTIVE;
+ 			else {
+ 				if (vha->hw->flags.fw_started)
+ 					action = MODE_CHANGE_NO_ACTION;
+ 				else
+ 					action = MODE_CHANGE_ACCEPT;
+ 			}
+ 			break;
+ 		}
+ 		break;
+ 
+ 	case QLA2XXX_INI_MODE_ENABLED:
+ 		switch (op) {
+ 		case QLA2XXX_INI_MODE_ENABLED:
+ 			if (NEED_EXCH_OFFLOAD(vha->u_ql2xiniexchg) !=
+ 			    vha->hw->flags.exchoffld_enabled)
+ 				eo_toggle = 1;
+ 			if (((vha->ql2xiniexchg != vha->u_ql2xiniexchg) &&
+ 				NEED_EXCH_OFFLOAD(vha->u_ql2xiniexchg)) ||
+ 			    eo_toggle)
+ 				action = MODE_CHANGE_ACCEPT;
+ 			else
+ 				action = NO_ACTION;
+ 			break;
+ 		case QLA2XXX_INI_MODE_DUAL:
+ 		case QLA2XXX_INI_MODE_DISABLED:
+ 			action = MODE_CHANGE_ACCEPT;
+ 			break;
+ 		default:
+ 			action = MODE_CHANGE_NO_ACTION;
+ 			break;
+ 		}
+ 		break;
+ 
+ 	case QLA2XXX_INI_MODE_DUAL:
+ 		switch (op) {
+ 		case QLA2XXX_INI_MODE_DUAL:
+ 			if (qla_tgt_mode_enabled(vha) ||
+ 			    qla_dual_mode_enabled(vha)) {
+ 				if (NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld +
+ 					vha->u_ql2xiniexchg) !=
+ 				    vha->hw->flags.exchoffld_enabled)
+ 					eo_toggle = 1;
+ 
+ 				if ((((vha->ql2xexchoffld +
+ 				       vha->ql2xiniexchg) !=
+ 				    (vha->u_ql2xiniexchg +
+ 				     vha->u_ql2xexchoffld)) &&
+ 				    NEED_EXCH_OFFLOAD(vha->u_ql2xiniexchg +
+ 					vha->u_ql2xexchoffld)) || eo_toggle)
+ 					action = MODE_CHANGE_ACCEPT;
+ 				else
+ 					action = NO_ACTION;
+ 			} else {
+ 				if (NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld +
+ 					vha->u_ql2xiniexchg) !=
+ 				    vha->hw->flags.exchoffld_enabled)
+ 					eo_toggle = 1;
+ 
+ 				if ((((vha->ql2xexchoffld + vha->ql2xiniexchg)
+ 				    != (vha->u_ql2xiniexchg +
+ 					vha->u_ql2xexchoffld)) &&
+ 				    NEED_EXCH_OFFLOAD(vha->u_ql2xiniexchg +
+ 					vha->u_ql2xexchoffld)) || eo_toggle)
+ 					action = MODE_CHANGE_NO_ACTION;
+ 				else
+ 					action = NO_ACTION;
+ 			}
+ 			break;
+ 
+ 		case QLA2XXX_INI_MODE_DISABLED:
+ 			if (qla_tgt_mode_enabled(vha) ||
+ 			    qla_dual_mode_enabled(vha)) {
+ 				/* turning off initiator mode */
+ 				set_mode = 1;
+ 				action = MODE_CHANGE_ACCEPT;
+ 			} else {
+ 				action = MODE_CHANGE_NO_ACTION;
+ 			}
+ 			break;
+ 
+ 		case QLA2XXX_INI_MODE_EXCLUSIVE:
+ 			if (qla_tgt_mode_enabled(vha) ||
+ 			    qla_dual_mode_enabled(vha)) {
+ 				set_mode = 1;
+ 				action = MODE_CHANGE_ACCEPT;
+ 			} else {
+ 				action = MODE_CHANGE_ACCEPT;
+ 			}
+ 			break;
+ 
+ 		case QLA2XXX_INI_MODE_ENABLED:
+ 			if (qla_tgt_mode_enabled(vha) ||
+ 			    qla_dual_mode_enabled(vha)) {
+ 				action = TARGET_STILL_ACTIVE;
+ 			} else {
+ 				action = MODE_CHANGE_ACCEPT;
+ 			}
+ 		}
+ 		break;
+ 	}
+ 
+ 	switch (action) {
+ 	case MODE_CHANGE_ACCEPT:
+ 		ql_log(ql_log_warn, vha, 0xffff,
+ 		    "Mode change accepted. From %s to %s, Tgt exchg %d|%d. ini exchg %d|%d\n",
+ 		    mode_to_str[vha->qlini_mode], mode_to_str[op],
+ 		    vha->ql2xexchoffld, vha->u_ql2xexchoffld,
+ 		    vha->ql2xiniexchg, vha->u_ql2xiniexchg);
+ 
+ 		vha->qlini_mode = op;
+ 		vha->ql2xexchoffld = vha->u_ql2xexchoffld;
+ 		vha->ql2xiniexchg = vha->u_ql2xiniexchg;
+ 		if (set_mode)
+ 			qlt_set_mode(vha);
+ 		vha->flags.online = 1;
+ 		set_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);
+ 		break;
+ 
+ 	case MODE_CHANGE_NO_ACTION:
+ 		ql_log(ql_log_warn, vha, 0xffff,
+ 		    "Mode is set. No action taken. From %s to %s, Tgt exchg %d|%d. ini exchg %d|%d\n",
+ 		    mode_to_str[vha->qlini_mode], mode_to_str[op],
+ 		    vha->ql2xexchoffld, vha->u_ql2xexchoffld,
+ 		    vha->ql2xiniexchg, vha->u_ql2xiniexchg);
+ 		vha->qlini_mode = op;
+ 		vha->ql2xexchoffld = vha->u_ql2xexchoffld;
+ 		vha->ql2xiniexchg = vha->u_ql2xiniexchg;
+ 		break;
+ 
+ 	case TARGET_STILL_ACTIVE:
+ 		ql_log(ql_log_warn, vha, 0xffff,
+ 		    "Target Mode is active. Unable to change Mode.\n");
+ 		break;
+ 
+ 	case NO_ACTION:
+ 	default:
+ 		ql_log(ql_log_warn, vha, 0xffff,
+ 		    "Mode unchange. No action taken. %d|%d pct %d|%d.\n",
+ 		    vha->qlini_mode, op,
+ 		    vha->ql2xexchoffld, vha->u_ql2xexchoffld);
+ 		break;
+ 	}
+ 
+ 	return rc;
+ }
+ 
+ static ssize_t
+ qlini_mode_store(struct device *dev, struct device_attribute *attr,
+     const char *buf, size_t count)
+ {
+ 	scsi_qla_host_t *vha = shost_priv(class_to_shost(dev));
+ 	int ini;
+ 
+ 	if (!buf)
+ 		return -EINVAL;
+ 
+ 	if (strncasecmp(QLA2XXX_INI_MODE_STR_EXCLUSIVE, buf,
+ 		strlen(QLA2XXX_INI_MODE_STR_EXCLUSIVE)) == 0)
+ 		ini = QLA2XXX_INI_MODE_EXCLUSIVE;
+ 	else if (strncasecmp(QLA2XXX_INI_MODE_STR_DISABLED, buf,
+ 		strlen(QLA2XXX_INI_MODE_STR_DISABLED)) == 0)
+ 		ini = QLA2XXX_INI_MODE_DISABLED;
+ 	else if (strncasecmp(QLA2XXX_INI_MODE_STR_ENABLED, buf,
+ 		  strlen(QLA2XXX_INI_MODE_STR_ENABLED)) == 0)
+ 		ini = QLA2XXX_INI_MODE_ENABLED;
+ 	else if (strncasecmp(QLA2XXX_INI_MODE_STR_DUAL, buf,
+ 		strlen(QLA2XXX_INI_MODE_STR_DUAL)) == 0)
+ 		ini = QLA2XXX_INI_MODE_DUAL;
+ 	else
+ 		return -EINVAL;
+ 
+ 	qla_set_ini_mode(vha, ini);
+ 	return strlen(buf);
+ }
+ 
+ static ssize_t
+ ql2xexchoffld_show(struct device *dev, struct device_attribute *attr,
+     char *buf)
+ {
+ 	scsi_qla_host_t *vha = shost_priv(class_to_shost(dev));
+ 	int len = 0;
+ 
+ 	len += scnprintf(buf + len, PAGE_SIZE-len,
+ 		"target exchange: new %d : current: %d\n\n",
+ 		vha->u_ql2xexchoffld, vha->ql2xexchoffld);
+ 
+ 	len += scnprintf(buf + len, PAGE_SIZE-len,
+ 	    "Please (re)set operating mode via \"/sys/class/scsi_host/host%ld/qlini_mode\" to load new setting.\n",
+ 	    vha->host_no);
+ 
+ 	return len;
+ }
+ 
+ static ssize_t
+ ql2xexchoffld_store(struct device *dev, struct device_attribute *attr,
+     const char *buf, size_t count)
+ {
+ 	scsi_qla_host_t *vha = shost_priv(class_to_shost(dev));
+ 	int val = 0;
+ 
+ 	if (sscanf(buf, "%d", &val) != 1)
+ 		return -EINVAL;
+ 
+ 	if (val > FW_MAX_EXCHANGES_CNT)
+ 		val = FW_MAX_EXCHANGES_CNT;
+ 	else if (val < 0)
+ 		val = 0;
+ 
+ 	vha->u_ql2xexchoffld = val;
+ 	return strlen(buf);
+ }
+ 
+ static ssize_t
+ ql2xiniexchg_show(struct device *dev, struct device_attribute *attr,
+     char *buf)
+ {
+ 	scsi_qla_host_t *vha = shost_priv(class_to_shost(dev));
+ 	int len = 0;
+ 
+ 	len += scnprintf(buf + len, PAGE_SIZE-len,
+ 		"target exchange: new %d : current: %d\n\n",
+ 		vha->u_ql2xiniexchg, vha->ql2xiniexchg);
+ 
+ 	len += scnprintf(buf + len, PAGE_SIZE-len,
+ 	    "Please (re)set operating mode via \"/sys/class/scsi_host/host%ld/qlini_mode\" to load new setting.\n",
+ 	    vha->host_no);
+ 
+ 	return len;
+ }
+ 
+ static ssize_t
+ ql2xiniexchg_store(struct device *dev, struct device_attribute *attr,
+     const char *buf, size_t count)
+ {
+ 	scsi_qla_host_t *vha = shost_priv(class_to_shost(dev));
+ 	int val = 0;
+ 
+ 	if (sscanf(buf, "%d", &val) != 1)
+ 		return -EINVAL;
+ 
+ 	if (val > FW_MAX_EXCHANGES_CNT)
+ 		val = FW_MAX_EXCHANGES_CNT;
+ 	else if (val < 0)
+ 		val = 0;
+ 
+ 	vha->u_ql2xiniexchg = val;
+ 	return strlen(buf);
+ }
+ 
+ static ssize_t
+ qla2x00_dif_bundle_statistics_show(struct device *dev,
+     struct device_attribute *attr, char *buf)
+ {
+ 	scsi_qla_host_t *vha = shost_priv(class_to_shost(dev));
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	return scnprintf(buf, PAGE_SIZE,
+ 	    "cross=%llu read=%llu write=%llu kalloc=%llu dma_alloc=%llu unusable=%u\n",
+ 	    ha->dif_bundle_crossed_pages, ha->dif_bundle_reads,
+ 	    ha->dif_bundle_writes, ha->dif_bundle_kallocs,
+ 	    ha->dif_bundle_dma_allocs, ha->pool.unusable.count);
+ }
+ 
+ static ssize_t
+ qla2x00_fw_attr_show(struct device *dev,
+     struct device_attribute *attr, char *buf)
+ {
+ 	scsi_qla_host_t *vha = shost_priv(class_to_shost(dev));
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	if (!IS_QLA27XX(ha))
+ 		return scnprintf(buf, PAGE_SIZE, "\n");
+ 
+ 	return scnprintf(buf, PAGE_SIZE, "%llx\n",
+ 	    (uint64_t)ha->fw_attributes_ext[1] << 48 |
+ 	    (uint64_t)ha->fw_attributes_ext[0] << 32 |
+ 	    (uint64_t)ha->fw_attributes_h << 16 |
+ 	    (uint64_t)ha->fw_attributes);
+ }
+ 
+ static ssize_t
+ qla2x00_port_no_show(struct device *dev, struct device_attribute *attr,
+     char *buf)
+ {
+ 	scsi_qla_host_t *vha = shost_priv(class_to_shost(dev));
+ 
+ 	return scnprintf(buf, PAGE_SIZE, "%u\n", vha->hw->port_no);
+ }
+ 
+ static DEVICE_ATTR(driver_version, S_IRUGO, qla2x00_driver_version_show, NULL);
++>>>>>>> df617ffbbc5e (scsi: qla2xxx: Add fw_attr and port_no SysFS node)
  static DEVICE_ATTR(fw_version, S_IRUGO, qla2x00_fw_version_show, NULL);
  static DEVICE_ATTR(serial_num, S_IRUGO, qla2x00_serial_num_show, NULL);
  static DEVICE_ATTR(isp_name, S_IRUGO, qla2x00_isp_name_show, NULL);
@@@ -1563,6 -2237,19 +2122,22 @@@ static DEVICE_ATTR(allow_cna_fw_dump, S
  static DEVICE_ATTR(pep_version, S_IRUGO, qla2x00_pep_version_show, NULL);
  static DEVICE_ATTR(min_link_speed, S_IRUGO, qla2x00_min_link_speed_show, NULL);
  static DEVICE_ATTR(max_speed_sup, S_IRUGO, qla2x00_max_speed_sup_show, NULL);
++<<<<<<< HEAD
++=======
+ static DEVICE_ATTR(zio_threshold, 0644,
+     qla_zio_threshold_show,
+     qla_zio_threshold_store);
+ static DEVICE_ATTR_RW(qlini_mode);
+ static DEVICE_ATTR_RW(ql2xexchoffld);
+ static DEVICE_ATTR_RW(ql2xiniexchg);
+ static DEVICE_ATTR(dif_bundle_statistics, 0444,
+     qla2x00_dif_bundle_statistics_show, NULL);
+ static DEVICE_ATTR(port_speed, 0644, qla2x00_port_speed_show,
+     qla2x00_port_speed_store);
+ static DEVICE_ATTR(port_no, 0444, qla2x00_port_no_show, NULL);
+ static DEVICE_ATTR(fw_attr, 0444, qla2x00_fw_attr_show, NULL);
+ 
++>>>>>>> df617ffbbc5e (scsi: qla2xxx: Add fw_attr and port_no SysFS node)
  
  struct device_attribute *qla2x00_host_attrs[] = {
  	&dev_attr_driver_version,
@@@ -1599,6 -2286,14 +2174,17 @@@
  	&dev_attr_pep_version,
  	&dev_attr_min_link_speed,
  	&dev_attr_max_speed_sup,
++<<<<<<< HEAD
++=======
+ 	&dev_attr_zio_threshold,
+ 	&dev_attr_dif_bundle_statistics,
+ 	&dev_attr_port_speed,
+ 	&dev_attr_port_no,
+ 	&dev_attr_fw_attr,
+ 	NULL, /* reserve for qlini_mode */
+ 	NULL, /* reserve for ql2xiniexchg */
+ 	NULL, /* reserve for ql2xexchoffld */
++>>>>>>> df617ffbbc5e (scsi: qla2xxx: Add fw_attr and port_no SysFS node)
  	NULL,
  };
  
* Unmerged path drivers/scsi/qla2xxx/qla_attr.c
