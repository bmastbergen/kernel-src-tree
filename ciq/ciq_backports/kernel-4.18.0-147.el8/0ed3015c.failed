selftests/tls: Fix recv(MSG_PEEK) & splice() test cases

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Vakul Garg <vakul.garg@nxp.com>
commit 0ed3015c9964dab7a1693b3e40650f329c16691e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/0ed3015c.failed

TLS test cases splice_from_pipe, send_and_splice &
recv_peek_multiple_records expect to receive a given nummber of bytes
and then compare them against the number of bytes which were sent.
Therefore, system call recv() must not return before receiving the
requested number of bytes, otherwise the subsequent memcmp() fails.
This patch passes MSG_WAITALL flag to recv() so that it does not return
prematurely before requested number of bytes are copied to receive
buffer.

	Signed-off-by: Vakul Garg <vakul.garg@nxp.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0ed3015c9964dab7a1693b3e40650f329c16691e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/net/tls.c
diff --cc tools/testing/selftests/net/tls.c
index 96fc6fe70293,fac68d710f35..000000000000
--- a/tools/testing/selftests/net/tls.c
+++ b/tools/testing/selftests/net/tls.c
@@@ -502,6 -502,55 +502,58 @@@ TEST_F(tls, recv_peek_multiple
  	EXPECT_EQ(memcmp(test_str, buf, send_len), 0);
  }
  
++<<<<<<< HEAD
++=======
+ TEST_F(tls, recv_peek_multiple_records)
+ {
+ 	char const *test_str = "test_read_peek_mult_recs";
+ 	char const *test_str_first = "test_read_peek";
+ 	char const *test_str_second = "_mult_recs";
+ 	int len;
+ 	char buf[64];
+ 
+ 	len = strlen(test_str_first);
+ 	EXPECT_EQ(send(self->fd, test_str_first, len, 0), len);
+ 
+ 	len = strlen(test_str_second) + 1;
+ 	EXPECT_EQ(send(self->fd, test_str_second, len, 0), len);
+ 
+ 	len = strlen(test_str_first);
+ 	memset(buf, 0, len);
+ 	EXPECT_EQ(recv(self->cfd, buf, len, MSG_PEEK | MSG_WAITALL), len);
+ 
+ 	/* MSG_PEEK can only peek into the current record. */
+ 	len = strlen(test_str_first);
+ 	EXPECT_EQ(memcmp(test_str_first, buf, len), 0);
+ 
+ 	len = strlen(test_str) + 1;
+ 	memset(buf, 0, len);
+ 	EXPECT_EQ(recv(self->cfd, buf, len, MSG_WAITALL), len);
+ 
+ 	/* Non-MSG_PEEK will advance strparser (and therefore record)
+ 	 * however.
+ 	 */
+ 	len = strlen(test_str) + 1;
+ 	EXPECT_EQ(memcmp(test_str, buf, len), 0);
+ 
+ 	/* MSG_MORE will hold current record open, so later MSG_PEEK
+ 	 * will see everything.
+ 	 */
+ 	len = strlen(test_str_first);
+ 	EXPECT_EQ(send(self->fd, test_str_first, len, MSG_MORE), len);
+ 
+ 	len = strlen(test_str_second) + 1;
+ 	EXPECT_EQ(send(self->fd, test_str_second, len, 0), len);
+ 
+ 	len = strlen(test_str) + 1;
+ 	memset(buf, 0, len);
+ 	EXPECT_EQ(recv(self->cfd, buf, len, MSG_PEEK | MSG_WAITALL), len);
+ 
+ 	len = strlen(test_str) + 1;
+ 	EXPECT_EQ(memcmp(test_str, buf, len), 0);
+ }
+ 
++>>>>>>> 0ed3015c9964 (selftests/tls: Fix recv(MSG_PEEK) & splice() test cases)
  TEST_F(tls, recv_peek_large_buf_mult_recs)
  {
  	char const *test_str = "test_read_peek_mult_recs";
* Unmerged path tools/testing/selftests/net/tls.c
