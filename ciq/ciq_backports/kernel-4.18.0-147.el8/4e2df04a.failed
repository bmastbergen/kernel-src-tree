net/mlx5: Forward SRQ resource events

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Saeed Mahameed <saeedm@mellanox.com>
commit 4e2df04ad25ab8e627878817e56d6a27645ca4a8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/4e2df04a.failed

Allow forwarding of SRQ events to mlx5_core interfaces, e.g. mlx5_ib.
Use mlx5_notifier_register/unregister in srq.c in order to allow seamless
transition of srq.c to infiniband subsystem.

	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 4e2df04ad25ab8e627878817e56d6a27645ca4a8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/events.c
#	drivers/net/ethernet/mellanox/mlx5/core/srq.c
#	include/linux/mlx5/driver.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/srq.c
index 5c519615fb1c,79c5f0d57956..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/srq.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/srq.c
@@@ -36,13 -36,31 +36,37 @@@
  #include <linux/mlx5/cmd.h>
  #include <linux/mlx5/srq.h>
  #include <rdma/ib_verbs.h>
 -#include <linux/mlx5/transobj.h>
  #include "mlx5_core.h"
 -#include "lib/eq.h"
 +#include <linux/mlx5/transobj.h>
  
++<<<<<<< HEAD
 +void mlx5_srq_event(struct mlx5_core_dev *dev, u32 srqn, int event_type)
 +{
 +	struct mlx5_srq_table *table = &dev->priv.srq_table;
 +	struct mlx5_core_srq *srq;
++=======
+ static int srq_event_notifier(struct notifier_block *nb,
+ 			      unsigned long type, void *data)
+ {
+ 	struct mlx5_srq_table *table;
+ 	struct mlx5_core_dev *dev;
+ 	struct mlx5_core_srq *srq;
+ 	struct mlx5_priv *priv;
+ 	struct mlx5_eqe *eqe;
+ 	u32 srqn;
+ 
+ 	if (type != MLX5_EVENT_TYPE_SRQ_CATAS_ERROR &&
+ 	    type != MLX5_EVENT_TYPE_SRQ_RQ_LIMIT)
+ 		return NOTIFY_DONE;
+ 
+ 	table = container_of(nb, struct mlx5_srq_table, nb);
+ 	priv  = container_of(table, struct mlx5_priv, srq_table);
+ 	dev   = container_of(priv, struct mlx5_core_dev, priv);
+ 
+ 	eqe = data;
+ 	srqn = be32_to_cpu(eqe->data.qp_srq.qp_srq_n) & 0xffffff;
+ 	mlx5_core_dbg(dev, "SRQ event (%d): srqn 0x%x\n", eqe->type, srqn);
++>>>>>>> 4e2df04ad25a (net/mlx5: Forward SRQ resource events)
  
  	spin_lock(&table->lock);
  
@@@ -61,6 -79,8 +85,11 @@@
  
  	if (atomic_dec_and_test(&srq->refcount))
  		complete(&srq->free);
++<<<<<<< HEAD
++=======
+ 
+ 	return NOTIFY_OK;
++>>>>>>> 4e2df04ad25a (net/mlx5: Forward SRQ resource events)
  }
  
  static int get_pas_size(struct mlx5_srq_attr *in)
@@@ -708,9 -728,14 +737,21 @@@ void mlx5_init_srq_table(struct mlx5_co
  	memset(table, 0, sizeof(*table));
  	spin_lock_init(&table->lock);
  	INIT_RADIX_TREE(&table->tree, GFP_ATOMIC);
++<<<<<<< HEAD
++=======
+ 
+ 	table->nb.notifier_call = srq_event_notifier;
+ 	mlx5_notifier_register(dev, &table->nb);
++>>>>>>> 4e2df04ad25a (net/mlx5: Forward SRQ resource events)
  }
  
  void mlx5_cleanup_srq_table(struct mlx5_core_dev *dev)
  {
++<<<<<<< HEAD
 +	/* nothing */
++=======
+ 	struct mlx5_srq_table *table = &dev->priv.srq_table;
+ 
+ 	mlx5_notifier_unregister(dev, &table->nb);
++>>>>>>> 4e2df04ad25a (net/mlx5: Forward SRQ resource events)
  }
diff --cc include/linux/mlx5/driver.h
index 17a4bd81b40d,27a481b159ed..000000000000
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@@ -538,6 -465,7 +538,10 @@@ struct mlx5_qp_table 
  };
  
  struct mlx5_srq_table {
++<<<<<<< HEAD
++=======
+ 	struct notifier_block   nb;
++>>>>>>> 4e2df04ad25a (net/mlx5: Forward SRQ resource events)
  	/* protect radix tree
  	 */
  	spinlock_t		lock;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/events.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/events.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/srq.c
* Unmerged path include/linux/mlx5/driver.h
