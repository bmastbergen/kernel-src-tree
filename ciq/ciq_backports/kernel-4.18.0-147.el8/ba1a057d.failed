IB/mlx5: Set valid umem bit on DEVX

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Yishai Hadas <yishaih@mellanox.com>
commit ba1a057da2f17411009ecfbdfde4d68bc8c1765e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/ba1a057d.failed

Set valid umem bit on DEVX commands that use umem.
This will enforce the umem usage by the firmware and not the 'pas' info.

	Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit ba1a057da2f17411009ecfbdfde4d68bc8c1765e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/devx.c
diff --cc drivers/infiniband/hw/mlx5/devx.c
index c7f8859c08ee,562c7936bbad..000000000000
--- a/drivers/infiniband/hw/mlx5/devx.c
+++ b/drivers/infiniband/hw/mlx5/devx.c
@@@ -71,6 -87,274 +71,277 @@@ void mlx5_ib_devx_destroy(struct mlx5_i
  	mlx5_cmd_exec(dev->mdev, in, sizeof(in), out, sizeof(out));
  }
  
++<<<<<<< HEAD
++=======
+ bool mlx5_ib_devx_is_flow_dest(void *obj, int *dest_id, int *dest_type)
+ {
+ 	struct devx_obj *devx_obj = obj;
+ 	u16 opcode = MLX5_GET(general_obj_in_cmd_hdr, devx_obj->dinbox, opcode);
+ 
+ 	switch (opcode) {
+ 	case MLX5_CMD_OP_DESTROY_TIR:
+ 		*dest_type = MLX5_FLOW_DESTINATION_TYPE_TIR;
+ 		*dest_id = MLX5_GET(general_obj_in_cmd_hdr, devx_obj->dinbox,
+ 				    obj_id);
+ 		return true;
+ 
+ 	case MLX5_CMD_OP_DESTROY_FLOW_TABLE:
+ 		*dest_type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
+ 		*dest_id = MLX5_GET(destroy_flow_table_in, devx_obj->dinbox,
+ 				    table_id);
+ 		return true;
+ 	default:
+ 		return false;
+ 	}
+ }
+ 
+ static int devx_is_valid_obj_id(struct devx_obj *obj, const void *in)
+ {
+ 	u16 opcode = MLX5_GET(general_obj_in_cmd_hdr, in, opcode);
+ 	u32 obj_id;
+ 
+ 	switch (opcode) {
+ 	case MLX5_CMD_OP_MODIFY_GENERAL_OBJECT:
+ 	case MLX5_CMD_OP_QUERY_GENERAL_OBJECT:
+ 		obj_id = MLX5_GET(general_obj_in_cmd_hdr, in, obj_id);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_MKEY:
+ 		obj_id = MLX5_GET(query_mkey_in, in, mkey_index);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_CQ:
+ 		obj_id = MLX5_GET(query_cq_in, in, cqn);
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_CQ:
+ 		obj_id = MLX5_GET(modify_cq_in, in, cqn);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_SQ:
+ 		obj_id = MLX5_GET(query_sq_in, in, sqn);
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_SQ:
+ 		obj_id = MLX5_GET(modify_sq_in, in, sqn);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_RQ:
+ 		obj_id = MLX5_GET(query_rq_in, in, rqn);
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_RQ:
+ 		obj_id = MLX5_GET(modify_rq_in, in, rqn);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_RMP:
+ 		obj_id = MLX5_GET(query_rmp_in, in, rmpn);
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_RMP:
+ 		obj_id = MLX5_GET(modify_rmp_in, in, rmpn);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_RQT:
+ 		obj_id = MLX5_GET(query_rqt_in, in, rqtn);
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_RQT:
+ 		obj_id = MLX5_GET(modify_rqt_in, in, rqtn);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_TIR:
+ 		obj_id = MLX5_GET(query_tir_in, in, tirn);
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_TIR:
+ 		obj_id = MLX5_GET(modify_tir_in, in, tirn);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_TIS:
+ 		obj_id = MLX5_GET(query_tis_in, in, tisn);
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_TIS:
+ 		obj_id = MLX5_GET(modify_tis_in, in, tisn);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_FLOW_TABLE:
+ 		obj_id = MLX5_GET(query_flow_table_in, in, table_id);
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_FLOW_TABLE:
+ 		obj_id = MLX5_GET(modify_flow_table_in, in, table_id);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_FLOW_GROUP:
+ 		obj_id = MLX5_GET(query_flow_group_in, in, group_id);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_FLOW_TABLE_ENTRY:
+ 		obj_id = MLX5_GET(query_fte_in, in, flow_index);
+ 		break;
+ 	case MLX5_CMD_OP_SET_FLOW_TABLE_ENTRY:
+ 		obj_id = MLX5_GET(set_fte_in, in, flow_index);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_Q_COUNTER:
+ 		obj_id = MLX5_GET(query_q_counter_in, in, counter_set_id);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_FLOW_COUNTER:
+ 		obj_id = MLX5_GET(query_flow_counter_in, in, flow_counter_id);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_MODIFY_HEADER_CONTEXT:
+ 		obj_id = MLX5_GET(general_obj_in_cmd_hdr, in, obj_id);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_SCHEDULING_ELEMENT:
+ 		obj_id = MLX5_GET(query_scheduling_element_in, in,
+ 				  scheduling_element_id);
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_SCHEDULING_ELEMENT:
+ 		obj_id = MLX5_GET(modify_scheduling_element_in, in,
+ 				  scheduling_element_id);
+ 		break;
+ 	case MLX5_CMD_OP_ADD_VXLAN_UDP_DPORT:
+ 		obj_id = MLX5_GET(add_vxlan_udp_dport_in, in, vxlan_udp_port);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_L2_TABLE_ENTRY:
+ 		obj_id = MLX5_GET(query_l2_table_entry_in, in, table_index);
+ 		break;
+ 	case MLX5_CMD_OP_SET_L2_TABLE_ENTRY:
+ 		obj_id = MLX5_GET(set_l2_table_entry_in, in, table_index);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_QP:
+ 		obj_id = MLX5_GET(query_qp_in, in, qpn);
+ 		break;
+ 	case MLX5_CMD_OP_RST2INIT_QP:
+ 		obj_id = MLX5_GET(rst2init_qp_in, in, qpn);
+ 		break;
+ 	case MLX5_CMD_OP_INIT2RTR_QP:
+ 		obj_id = MLX5_GET(init2rtr_qp_in, in, qpn);
+ 		break;
+ 	case MLX5_CMD_OP_RTR2RTS_QP:
+ 		obj_id = MLX5_GET(rtr2rts_qp_in, in, qpn);
+ 		break;
+ 	case MLX5_CMD_OP_RTS2RTS_QP:
+ 		obj_id = MLX5_GET(rts2rts_qp_in, in, qpn);
+ 		break;
+ 	case MLX5_CMD_OP_SQERR2RTS_QP:
+ 		obj_id = MLX5_GET(sqerr2rts_qp_in, in, qpn);
+ 		break;
+ 	case MLX5_CMD_OP_2ERR_QP:
+ 		obj_id = MLX5_GET(qp_2err_in, in, qpn);
+ 		break;
+ 	case MLX5_CMD_OP_2RST_QP:
+ 		obj_id = MLX5_GET(qp_2rst_in, in, qpn);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_DCT:
+ 		obj_id = MLX5_GET(query_dct_in, in, dctn);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_XRQ:
+ 		obj_id = MLX5_GET(query_xrq_in, in, xrqn);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_XRC_SRQ:
+ 		obj_id = MLX5_GET(query_xrc_srq_in, in, xrc_srqn);
+ 		break;
+ 	case MLX5_CMD_OP_ARM_XRC_SRQ:
+ 		obj_id = MLX5_GET(arm_xrc_srq_in, in, xrc_srqn);
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_SRQ:
+ 		obj_id = MLX5_GET(query_srq_in, in, srqn);
+ 		break;
+ 	case MLX5_CMD_OP_ARM_RQ:
+ 		obj_id = MLX5_GET(arm_rq_in, in, srq_number);
+ 		break;
+ 	case MLX5_CMD_OP_DRAIN_DCT:
+ 	case MLX5_CMD_OP_ARM_DCT_FOR_KEY_VIOLATION:
+ 		obj_id = MLX5_GET(drain_dct_in, in, dctn);
+ 		break;
+ 	case MLX5_CMD_OP_ARM_XRQ:
+ 		obj_id = MLX5_GET(arm_xrq_in, in, xrqn);
+ 		break;
+ 	default:
+ 		return false;
+ 	}
+ 
+ 	if (obj_id == obj->obj_id)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ static void devx_set_umem_valid(const void *in)
+ {
+ 	u16 opcode = MLX5_GET(general_obj_in_cmd_hdr, in, opcode);
+ 
+ 	switch (opcode) {
+ 	case MLX5_CMD_OP_CREATE_MKEY:
+ 		MLX5_SET(create_mkey_in, in, mkey_umem_valid, 1);
+ 		break;
+ 	case MLX5_CMD_OP_CREATE_CQ:
+ 	{
+ 		void *cqc;
+ 
+ 		MLX5_SET(create_cq_in, in, cq_umem_valid, 1);
+ 		cqc = MLX5_ADDR_OF(create_cq_in, in, cq_context);
+ 		MLX5_SET(cqc, cqc, dbr_umem_valid, 1);
+ 		break;
+ 	}
+ 	case MLX5_CMD_OP_CREATE_QP:
+ 	{
+ 		void *qpc;
+ 
+ 		qpc = MLX5_ADDR_OF(create_qp_in, in, qpc);
+ 		MLX5_SET(qpc, qpc, dbr_umem_valid, 1);
+ 		MLX5_SET(create_qp_in, in, wq_umem_valid, 1);
+ 		break;
+ 	}
+ 
+ 	case MLX5_CMD_OP_CREATE_RQ:
+ 	{
+ 		void *rqc, *wq;
+ 
+ 		rqc = MLX5_ADDR_OF(create_rq_in, in, ctx);
+ 		wq  = MLX5_ADDR_OF(rqc, rqc, wq);
+ 		MLX5_SET(wq, wq, dbr_umem_valid, 1);
+ 		MLX5_SET(wq, wq, wq_umem_valid, 1);
+ 		break;
+ 	}
+ 
+ 	case MLX5_CMD_OP_CREATE_SQ:
+ 	{
+ 		void *sqc, *wq;
+ 
+ 		sqc = MLX5_ADDR_OF(create_sq_in, in, ctx);
+ 		wq = MLX5_ADDR_OF(sqc, sqc, wq);
+ 		MLX5_SET(wq, wq, dbr_umem_valid, 1);
+ 		MLX5_SET(wq, wq, wq_umem_valid, 1);
+ 		break;
+ 	}
+ 
+ 	case MLX5_CMD_OP_MODIFY_CQ:
+ 		MLX5_SET(modify_cq_in, in, cq_umem_valid, 1);
+ 		break;
+ 
+ 	case MLX5_CMD_OP_CREATE_RMP:
+ 	{
+ 		void *rmpc, *wq;
+ 
+ 		rmpc = MLX5_ADDR_OF(create_rmp_in, in, ctx);
+ 		wq = MLX5_ADDR_OF(rmpc, rmpc, wq);
+ 		MLX5_SET(wq, wq, dbr_umem_valid, 1);
+ 		MLX5_SET(wq, wq, wq_umem_valid, 1);
+ 		break;
+ 	}
+ 
+ 	case MLX5_CMD_OP_CREATE_XRQ:
+ 	{
+ 		void *xrqc, *wq;
+ 
+ 		xrqc = MLX5_ADDR_OF(create_xrq_in, in, xrq_context);
+ 		wq = MLX5_ADDR_OF(xrqc, xrqc, wq);
+ 		MLX5_SET(wq, wq, dbr_umem_valid, 1);
+ 		MLX5_SET(wq, wq, wq_umem_valid, 1);
+ 		break;
+ 	}
+ 
+ 	case MLX5_CMD_OP_CREATE_XRC_SRQ:
+ 	{
+ 		void *xrc_srqc;
+ 
+ 		MLX5_SET(create_xrc_srq_in, in, xrc_srq_umem_valid, 1);
+ 		xrc_srqc = MLX5_ADDR_OF(create_xrc_srq_in, in,
+ 					xrc_srq_context_entry);
+ 		MLX5_SET(xrc_srqc, xrc_srqc, dbr_umem_valid, 1);
+ 		break;
+ 	}
+ 
+ 	default:
+ 		return;
+ 	}
+ }
+ 
++>>>>>>> ba1a057da2f1 (IB/mlx5: Set valid umem bit on DEVX)
  static bool devx_is_obj_create_cmd(const void *in)
  {
  	u16 opcode = MLX5_GET(general_obj_in_cmd_hdr, in, opcode);
@@@ -395,13 -831,9 +666,15 @@@ static int UVERBS_HANDLER(MLX5_IB_METHO
  	if (!obj)
  		return -ENOMEM;
  
 +	cmd_out = kvzalloc(cmd_out_len, GFP_KERNEL);
 +	if (!cmd_out) {
 +		err = -ENOMEM;
 +		goto obj_free;
 +	}
 +
  	MLX5_SET(general_obj_in_cmd_hdr, cmd_in, uid, c->devx_uid);
+ 	devx_set_umem_valid(cmd_in);
+ 
  	err = mlx5_cmd_exec(dev->mdev, cmd_in,
  			    uverbs_attr_get_len(attrs, MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_IN),
  			    cmd_out, cmd_out_len);
@@@ -428,47 -856,359 +701,380 @@@ obj_free
  	return err;
  }
  
 -static int UVERBS_HANDLER(MLX5_IB_METHOD_DEVX_OBJ_MODIFY)(
 -	struct ib_uverbs_file *file, struct uverbs_attr_bundle *attrs)
 -{
 -	void *cmd_in = uverbs_attr_get_alloced_ptr(attrs, MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_IN);
 -	int cmd_out_len = uverbs_attr_get_len(attrs,
 -					MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_OUT);
 -	struct ib_uobject *uobj = uverbs_attr_get_uobject(attrs,
 -							  MLX5_IB_ATTR_DEVX_OBJ_MODIFY_HANDLE);
 -	struct mlx5_ib_ucontext *c = to_mucontext(uobj->context);
 -	struct devx_obj *obj = uobj->object;
 -	void *cmd_out;
 -	int err;
 -
 -	if (!c->devx_uid)
 -		return -EPERM;
 -
 -	if (!devx_is_obj_modify_cmd(cmd_in))
 -		return -EINVAL;
 -
 -	if (!devx_is_valid_obj_id(obj, cmd_in))
 -		return -EINVAL;
 -
 -	cmd_out = uverbs_zalloc(attrs, cmd_out_len);
 -	if (IS_ERR(cmd_out))
 -		return PTR_ERR(cmd_out);
 -
 +static DECLARE_UVERBS_NAMED_METHOD(MLX5_IB_METHOD_DEVX_OTHER,
 +	&UVERBS_ATTR_PTR_IN_SZ(MLX5_IB_ATTR_DEVX_OTHER_CMD_IN,
 +			       UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
 +			       UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY |
 +					UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO |
 +					UVERBS_ATTR_SPEC_F_ALLOC_AND_COPY)),
 +	&UVERBS_ATTR_PTR_OUT_SZ(MLX5_IB_ATTR_DEVX_OTHER_CMD_OUT,
 +				UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_out_cmd_hdr)),
 +				UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY |
 +					 UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO))
 +);
 +
 +static DECLARE_UVERBS_NAMED_METHOD(MLX5_IB_METHOD_DEVX_OBJ_CREATE,
 +	&UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_CREATE_HANDLE,
 +			 MLX5_IB_OBJECT_DEVX_OBJ,
 +			 UVERBS_ACCESS_NEW,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN_SZ(MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_IN,
 +			       UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
 +			       UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY |
 +					UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO |
 +					UVERBS_ATTR_SPEC_F_ALLOC_AND_COPY)),
 +	&UVERBS_ATTR_PTR_OUT_SZ(MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_OUT,
 +				UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_out_cmd_hdr)),
 +				UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY |
 +					 UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO)));
 +
 +static DECLARE_UVERBS_NAMED_METHOD(MLX5_IB_METHOD_DEVX_OBJ_DESTROY,
 +	&UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_DESTROY_HANDLE,
 +			 MLX5_IB_OBJECT_DEVX_OBJ,
 +			 UVERBS_ACCESS_DESTROY,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
 +
 +static DECLARE_UVERBS_GLOBAL_METHODS(MLX5_IB_OBJECT_DEVX,
 +	&UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OTHER));
 +
 +static DECLARE_UVERBS_NAMED_OBJECT(MLX5_IB_OBJECT_DEVX_OBJ,
 +	&UVERBS_TYPE_ALLOC_IDR(0, devx_obj_cleanup),
 +		&UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OBJ_CREATE),
 +		&UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OBJ_DESTROY));
 +
++<<<<<<< HEAD
 +static DECLARE_UVERBS_OBJECT_TREE(devx_objects,
 +	&UVERBS_OBJECT(MLX5_IB_OBJECT_DEVX),
 +	&UVERBS_OBJECT(MLX5_IB_OBJECT_DEVX_OBJ));
++=======
+ 	MLX5_SET(general_obj_in_cmd_hdr, cmd_in, uid, c->devx_uid);
+ 	devx_set_umem_valid(cmd_in);
+ 
+ 	err = mlx5_cmd_exec(obj->mdev, cmd_in,
+ 			    uverbs_attr_get_len(attrs, MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_IN),
+ 			    cmd_out, cmd_out_len);
+ 	if (err)
+ 		return err;
+ 
+ 	return uverbs_copy_to(attrs, MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_OUT,
+ 			      cmd_out, cmd_out_len);
+ }
+ 
+ static int UVERBS_HANDLER(MLX5_IB_METHOD_DEVX_OBJ_QUERY)(
+ 	struct ib_uverbs_file *file, struct uverbs_attr_bundle *attrs)
+ {
+ 	void *cmd_in = uverbs_attr_get_alloced_ptr(attrs, MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_IN);
+ 	int cmd_out_len = uverbs_attr_get_len(attrs,
+ 					      MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_OUT);
+ 	struct ib_uobject *uobj = uverbs_attr_get_uobject(attrs,
+ 							  MLX5_IB_ATTR_DEVX_OBJ_QUERY_HANDLE);
+ 	struct mlx5_ib_ucontext *c = to_mucontext(uobj->context);
+ 	struct devx_obj *obj = uobj->object;
+ 	void *cmd_out;
+ 	int err;
+ 
+ 	if (!c->devx_uid)
+ 		return -EPERM;
+ 
+ 	if (!devx_is_obj_query_cmd(cmd_in))
+ 		return -EINVAL;
+ 
+ 	if (!devx_is_valid_obj_id(obj, cmd_in))
+ 		return -EINVAL;
+ 
+ 	cmd_out = uverbs_zalloc(attrs, cmd_out_len);
+ 	if (IS_ERR(cmd_out))
+ 		return PTR_ERR(cmd_out);
+ 
+ 	MLX5_SET(general_obj_in_cmd_hdr, cmd_in, uid, c->devx_uid);
+ 	err = mlx5_cmd_exec(obj->mdev, cmd_in,
+ 			    uverbs_attr_get_len(attrs, MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_IN),
+ 			    cmd_out, cmd_out_len);
+ 	if (err)
+ 		return err;
+ 
+ 	return uverbs_copy_to(attrs, MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_OUT,
+ 			      cmd_out, cmd_out_len);
+ }
+ 
+ static int devx_umem_get(struct mlx5_ib_dev *dev, struct ib_ucontext *ucontext,
+ 			 struct uverbs_attr_bundle *attrs,
+ 			 struct devx_umem *obj)
+ {
+ 	u64 addr;
+ 	size_t size;
+ 	u32 access;
+ 	int npages;
+ 	int err;
+ 	u32 page_mask;
+ 
+ 	if (uverbs_copy_from(&addr, attrs, MLX5_IB_ATTR_DEVX_UMEM_REG_ADDR) ||
+ 	    uverbs_copy_from(&size, attrs, MLX5_IB_ATTR_DEVX_UMEM_REG_LEN))
+ 		return -EFAULT;
+ 
+ 	err = uverbs_get_flags32(&access, attrs,
+ 				 MLX5_IB_ATTR_DEVX_UMEM_REG_ACCESS,
+ 				 IB_ACCESS_SUPPORTED);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ib_check_mr_access(access);
+ 	if (err)
+ 		return err;
+ 
+ 	obj->umem = ib_umem_get(ucontext, addr, size, access, 0);
+ 	if (IS_ERR(obj->umem))
+ 		return PTR_ERR(obj->umem);
+ 
+ 	mlx5_ib_cont_pages(obj->umem, obj->umem->address,
+ 			   MLX5_MKEY_PAGE_SHIFT_MASK, &npages,
+ 			   &obj->page_shift, &obj->ncont, NULL);
+ 
+ 	if (!npages) {
+ 		ib_umem_release(obj->umem);
+ 		return -EINVAL;
+ 	}
+ 
+ 	page_mask = (1 << obj->page_shift) - 1;
+ 	obj->page_offset = obj->umem->address & page_mask;
+ 
+ 	return 0;
+ }
+ 
+ static int devx_umem_reg_cmd_alloc(struct uverbs_attr_bundle *attrs,
+ 				   struct devx_umem *obj,
+ 				   struct devx_umem_reg_cmd *cmd)
+ {
+ 	cmd->inlen = MLX5_ST_SZ_BYTES(create_umem_in) +
+ 		    (MLX5_ST_SZ_BYTES(mtt) * obj->ncont);
+ 	cmd->in = uverbs_zalloc(attrs, cmd->inlen);
+ 	return PTR_ERR_OR_ZERO(cmd->in);
+ }
+ 
+ static void devx_umem_reg_cmd_build(struct mlx5_ib_dev *dev,
+ 				    struct devx_umem *obj,
+ 				    struct devx_umem_reg_cmd *cmd)
+ {
+ 	void *umem;
+ 	__be64 *mtt;
+ 
+ 	umem = MLX5_ADDR_OF(create_umem_in, cmd->in, umem);
+ 	mtt = (__be64 *)MLX5_ADDR_OF(umem, umem, mtt);
+ 
+ 	MLX5_SET(general_obj_in_cmd_hdr, cmd->in, opcode, MLX5_CMD_OP_CREATE_GENERAL_OBJECT);
+ 	MLX5_SET(general_obj_in_cmd_hdr, cmd->in, obj_type, MLX5_OBJ_TYPE_UMEM);
+ 	MLX5_SET64(umem, umem, num_of_mtt, obj->ncont);
+ 	MLX5_SET(umem, umem, log_page_size, obj->page_shift -
+ 					    MLX5_ADAPTER_PAGE_SHIFT);
+ 	MLX5_SET(umem, umem, page_offset, obj->page_offset);
+ 	mlx5_ib_populate_pas(dev, obj->umem, obj->page_shift, mtt,
+ 			     (obj->umem->writable ? MLX5_IB_MTT_WRITE : 0) |
+ 			     MLX5_IB_MTT_READ);
+ }
+ 
+ static int UVERBS_HANDLER(MLX5_IB_METHOD_DEVX_UMEM_REG)(
+ 	struct ib_uverbs_file *file, struct uverbs_attr_bundle *attrs)
+ {
+ 	struct devx_umem_reg_cmd cmd;
+ 	struct devx_umem *obj;
+ 	struct ib_uobject *uobj = uverbs_attr_get_uobject(
+ 		attrs, MLX5_IB_ATTR_DEVX_UMEM_REG_HANDLE);
+ 	u32 obj_id;
+ 	struct mlx5_ib_ucontext *c = to_mucontext(uobj->context);
+ 	struct mlx5_ib_dev *dev = to_mdev(c->ibucontext.device);
+ 	int err;
+ 
+ 	if (!c->devx_uid)
+ 		return -EPERM;
+ 
+ 	obj = kzalloc(sizeof(struct devx_umem), GFP_KERNEL);
+ 	if (!obj)
+ 		return -ENOMEM;
+ 
+ 	err = devx_umem_get(dev, &c->ibucontext, attrs, obj);
+ 	if (err)
+ 		goto err_obj_free;
+ 
+ 	err = devx_umem_reg_cmd_alloc(attrs, obj, &cmd);
+ 	if (err)
+ 		goto err_umem_release;
+ 
+ 	devx_umem_reg_cmd_build(dev, obj, &cmd);
+ 
+ 	MLX5_SET(general_obj_in_cmd_hdr, cmd.in, uid, c->devx_uid);
+ 	err = mlx5_cmd_exec(dev->mdev, cmd.in, cmd.inlen, cmd.out,
+ 			    sizeof(cmd.out));
+ 	if (err)
+ 		goto err_umem_release;
+ 
+ 	obj->mdev = dev->mdev;
+ 	uobj->object = obj;
+ 	devx_obj_build_destroy_cmd(cmd.in, cmd.out, obj->dinbox, &obj->dinlen, &obj_id);
+ 	err = uverbs_copy_to(attrs, MLX5_IB_ATTR_DEVX_UMEM_REG_OUT_ID, &obj_id, sizeof(obj_id));
+ 	if (err)
+ 		goto err_umem_destroy;
+ 
+ 	return 0;
+ 
+ err_umem_destroy:
+ 	mlx5_cmd_exec(obj->mdev, obj->dinbox, obj->dinlen, cmd.out, sizeof(cmd.out));
+ err_umem_release:
+ 	ib_umem_release(obj->umem);
+ err_obj_free:
+ 	kfree(obj);
+ 	return err;
+ }
+ 
+ static int devx_umem_cleanup(struct ib_uobject *uobject,
+ 			     enum rdma_remove_reason why)
+ {
+ 	struct devx_umem *obj = uobject->object;
+ 	u32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)];
+ 	int err;
+ 
+ 	err = mlx5_cmd_exec(obj->mdev, obj->dinbox, obj->dinlen, out, sizeof(out));
+ 	if (ib_is_destroy_retryable(err, why, uobject))
+ 		return err;
+ 
+ 	ib_umem_release(obj->umem);
+ 	kfree(obj);
+ 	return 0;
+ }
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	MLX5_IB_METHOD_DEVX_UMEM_REG,
+ 	UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_UMEM_REG_HANDLE,
+ 			MLX5_IB_OBJECT_DEVX_UMEM,
+ 			UVERBS_ACCESS_NEW,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_DEVX_UMEM_REG_ADDR,
+ 			   UVERBS_ATTR_TYPE(u64),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_DEVX_UMEM_REG_LEN,
+ 			   UVERBS_ATTR_TYPE(u64),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_FLAGS_IN(MLX5_IB_ATTR_DEVX_UMEM_REG_ACCESS,
+ 			     enum ib_access_flags),
+ 	UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_DEVX_UMEM_REG_OUT_ID,
+ 			    UVERBS_ATTR_TYPE(u32),
+ 			    UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD_DESTROY(
+ 	MLX5_IB_METHOD_DEVX_UMEM_DEREG,
+ 	UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_UMEM_DEREG_HANDLE,
+ 			MLX5_IB_OBJECT_DEVX_UMEM,
+ 			UVERBS_ACCESS_DESTROY,
+ 			UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	MLX5_IB_METHOD_DEVX_QUERY_EQN,
+ 	UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_DEVX_QUERY_EQN_USER_VEC,
+ 			   UVERBS_ATTR_TYPE(u32),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_DEVX_QUERY_EQN_DEV_EQN,
+ 			    UVERBS_ATTR_TYPE(u32),
+ 			    UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	MLX5_IB_METHOD_DEVX_QUERY_UAR,
+ 	UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_DEVX_QUERY_UAR_USER_IDX,
+ 			   UVERBS_ATTR_TYPE(u32),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_DEVX_QUERY_UAR_DEV_IDX,
+ 			    UVERBS_ATTR_TYPE(u32),
+ 			    UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	MLX5_IB_METHOD_DEVX_OTHER,
+ 	UVERBS_ATTR_PTR_IN(
+ 		MLX5_IB_ATTR_DEVX_OTHER_CMD_IN,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
+ 		UA_MANDATORY,
+ 		UA_ALLOC_AND_COPY),
+ 	UVERBS_ATTR_PTR_OUT(
+ 		MLX5_IB_ATTR_DEVX_OTHER_CMD_OUT,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_out_cmd_hdr)),
+ 		UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	MLX5_IB_METHOD_DEVX_OBJ_CREATE,
+ 	UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_CREATE_HANDLE,
+ 			MLX5_IB_OBJECT_DEVX_OBJ,
+ 			UVERBS_ACCESS_NEW,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(
+ 		MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_IN,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
+ 		UA_MANDATORY,
+ 		UA_ALLOC_AND_COPY),
+ 	UVERBS_ATTR_PTR_OUT(
+ 		MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_OUT,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_out_cmd_hdr)),
+ 		UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD_DESTROY(
+ 	MLX5_IB_METHOD_DEVX_OBJ_DESTROY,
+ 	UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_DESTROY_HANDLE,
+ 			MLX5_IB_OBJECT_DEVX_OBJ,
+ 			UVERBS_ACCESS_DESTROY,
+ 			UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	MLX5_IB_METHOD_DEVX_OBJ_MODIFY,
+ 	UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_MODIFY_HANDLE,
+ 			MLX5_IB_OBJECT_DEVX_OBJ,
+ 			UVERBS_ACCESS_WRITE,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(
+ 		MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_IN,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
+ 		UA_MANDATORY,
+ 		UA_ALLOC_AND_COPY),
+ 	UVERBS_ATTR_PTR_OUT(
+ 		MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_OUT,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_out_cmd_hdr)),
+ 		UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	MLX5_IB_METHOD_DEVX_OBJ_QUERY,
+ 	UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_QUERY_HANDLE,
+ 			MLX5_IB_OBJECT_DEVX_OBJ,
+ 			UVERBS_ACCESS_READ,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(
+ 		MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_IN,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
+ 		UA_MANDATORY,
+ 		UA_ALLOC_AND_COPY),
+ 	UVERBS_ATTR_PTR_OUT(
+ 		MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_OUT,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_out_cmd_hdr)),
+ 		UA_MANDATORY));
+ 
+ DECLARE_UVERBS_GLOBAL_METHODS(MLX5_IB_OBJECT_DEVX,
+ 			      &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OTHER),
+ 			      &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_QUERY_UAR),
+ 			      &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_QUERY_EQN));
+ 
+ DECLARE_UVERBS_NAMED_OBJECT(MLX5_IB_OBJECT_DEVX_OBJ,
+ 			    UVERBS_TYPE_ALLOC_IDR(devx_obj_cleanup),
+ 			    &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OBJ_CREATE),
+ 			    &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OBJ_DESTROY),
+ 			    &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OBJ_MODIFY),
+ 			    &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OBJ_QUERY));
+ 
+ DECLARE_UVERBS_NAMED_OBJECT(MLX5_IB_OBJECT_DEVX_UMEM,
+ 			    UVERBS_TYPE_ALLOC_IDR(devx_umem_cleanup),
+ 			    &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_UMEM_REG),
+ 			    &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_UMEM_DEREG));
+ 
+ DECLARE_UVERBS_OBJECT_TREE(devx_objects,
+ 			   &UVERBS_OBJECT(MLX5_IB_OBJECT_DEVX),
+ 			   &UVERBS_OBJECT(MLX5_IB_OBJECT_DEVX_OBJ),
+ 			   &UVERBS_OBJECT(MLX5_IB_OBJECT_DEVX_UMEM));
+ 
+ const struct uverbs_object_tree_def *mlx5_ib_get_devx_tree(void)
+ {
+ 	return &devx_objects;
+ }
++>>>>>>> ba1a057da2f1 (IB/mlx5: Set valid umem bit on DEVX)
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
