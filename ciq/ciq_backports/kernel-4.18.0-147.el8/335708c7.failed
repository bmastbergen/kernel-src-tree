RDMA/uverbs: Add a simple iterator interface for reading the command

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jason Gunthorpe <jgg@ziepe.ca>
commit 335708c751c1462b674892212e965fdde4c9b0d9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/335708c7.failed

Several methods have a command with a trailing flex array, and they
all open code some extraction scheme. Centralize this into a simple
iterator API.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 335708c751c1462b674892212e965fdde4c9b0d9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_cmd.c
diff --cc drivers/infiniband/core/uverbs_cmd.c
index 300532a4cde8,a89b8442ca32..000000000000
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@@ -47,12 -47,121 +47,125 @@@
  #include "uverbs.h"
  #include "core_priv.h"
  
++<<<<<<< HEAD
++=======
+ /*
+  * Copy a response to userspace. If the provided 'resp' is larger than the
+  * user buffer it is silently truncated. If the user provided a larger buffer
+  * then the trailing portion is zero filled.
+  *
+  * These semantics are intended to support future extension of the output
+  * structures.
+  */
+ static int uverbs_response(struct uverbs_attr_bundle *attrs, const void *resp,
+ 			   size_t resp_len)
+ {
+ 	u8 __user *cur = attrs->ucore.outbuf + resp_len;
+ 	u8 __user *end = attrs->ucore.outbuf + attrs->ucore.outlen;
+ 	int ret;
+ 
+ 	if (copy_to_user(attrs->ucore.outbuf, resp,
+ 			 min(attrs->ucore.outlen, resp_len)))
+ 		return -EFAULT;
+ 
+ 	/* Zero fill any extra memory that user space might have provided */
+ 	for (; cur < end; cur++) {
+ 		ret = put_user(0, cur);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Copy a request from userspace. If the provided 'req' is larger than the
+  * user buffer then the user buffer is zero extended into the 'req'. If 'req'
+  * is smaller than the user buffer then the uncopied bytes in the user buffer
+  * must be zero.
+  */
+ static int uverbs_request(struct uverbs_attr_bundle *attrs, void *req,
+ 			  size_t req_len)
+ {
+ 	if (copy_from_user(req, attrs->ucore.inbuf,
+ 			   min(attrs->ucore.inlen, req_len)))
+ 		return -EFAULT;
+ 
+ 	if (attrs->ucore.inlen < req_len) {
+ 		memset(req + attrs->ucore.inlen, 0,
+ 		       req_len - attrs->ucore.inlen);
+ 	} else if (attrs->ucore.inlen > req_len) {
+ 		if (!ib_is_buffer_cleared(attrs->ucore.inbuf + req_len,
+ 					  attrs->ucore.inlen - req_len))
+ 			return -EOPNOTSUPP;
+ 	}
+ 	return 0;
+ }
+ 
+ /*
+  * Generate the value for the 'response_length' protocol used by write_ex.
+  * This is the number of bytes the kernel actually wrote. Userspace can use
+  * this to detect what structure members in the response the kernel
+  * understood.
+  */
+ static u32 uverbs_response_length(struct uverbs_attr_bundle *attrs,
+ 				  size_t resp_len)
+ {
+ 	return min_t(size_t, attrs->ucore.outlen, resp_len);
+ }
+ 
+ /*
+  * The iterator version of the request interface is for handlers that need to
+  * step over a flex array at the end of a command header.
+  */
+ struct uverbs_req_iter {
+ 	const void __user *cur;
+ 	const void __user *end;
+ };
+ 
+ static int uverbs_request_start(struct uverbs_attr_bundle *attrs,
+ 				struct uverbs_req_iter *iter,
+ 				void *req,
+ 				size_t req_len)
+ {
+ 	if (attrs->ucore.inlen < req_len)
+ 		return -ENOSPC;
+ 
+ 	if (copy_from_user(req, attrs->ucore.inbuf, req_len))
+ 		return -EFAULT;
+ 
+ 	iter->cur = attrs->ucore.inbuf + req_len;
+ 	iter->end = attrs->ucore.inbuf + attrs->ucore.inlen;
+ 	return 0;
+ }
+ 
+ static int uverbs_request_next(struct uverbs_req_iter *iter, void *val,
+ 			       size_t len)
+ {
+ 	if (iter->cur + len > iter->end)
+ 		return -ENOSPC;
+ 
+ 	if (copy_from_user(val, iter->cur, len))
+ 		return -EFAULT;
+ 
+ 	iter->cur += len;
+ 	return 0;
+ }
+ 
+ static int uverbs_request_finish(struct uverbs_req_iter *iter)
+ {
+ 	if (!ib_is_buffer_cleared(iter->cur, iter->end - iter->cur))
+ 		return -EOPNOTSUPP;
+ 	return 0;
+ }
+ 
++>>>>>>> 335708c751c1 (RDMA/uverbs: Add a simple iterator interface for reading the command)
  static struct ib_uverbs_completion_event_file *
 -_ib_uverbs_lookup_comp_file(s32 fd, const struct uverbs_attr_bundle *attrs)
 +ib_uverbs_lookup_comp_file(int fd, struct ib_ucontext *context)
  {
 -	struct ib_uobject *uobj = ufd_get_read(UVERBS_OBJECT_COMP_CHANNEL,
 -					       fd, attrs);
 +	struct ib_uobject *uobj = uobj_get_read(UVERBS_OBJECT_COMP_CHANNEL,
 +						fd, context);
 +	struct ib_uobject_file *uobj_file;
  
  	if (IS_ERR(uobj))
  		return (void *)uobj;
@@@ -3351,15 -3102,13 +3464,15 @@@ out
  	return ret;
  }
  
 -static int ib_uverbs_ex_create_rwq_ind_table(struct uverbs_attr_bundle *attrs,
 -					     struct ib_udata *ucore)
 +int ib_uverbs_ex_create_rwq_ind_table(struct ib_uverbs_file *file,
 +				      struct ib_device *ib_dev,
 +				      struct ib_udata *ucore,
 +				      struct ib_udata *uhw)
  {
- 	struct ib_uverbs_ex_create_rwq_ind_table	  cmd = {};
+ 	struct ib_uverbs_ex_create_rwq_ind_table cmd;
  	struct ib_uverbs_ex_create_rwq_ind_table_resp  resp = {};
  	struct ib_uobject		  *uobj;
- 	int err = 0;
+ 	int err;
  	struct ib_rwq_ind_table_init_attr init_attr = {};
  	struct ib_rwq_ind_table *rwq_ind_tbl;
  	struct ib_wq	**wqs = NULL;
@@@ -3367,20 -3116,10 +3480,16 @@@
  	struct ib_wq	*wq = NULL;
  	int i, j, num_read_wqs;
  	u32 num_wq_handles;
++<<<<<<< HEAD
 +	u32 expected_in_size;
 +	size_t required_cmd_sz_header;
 +	size_t required_resp_len;
++=======
+ 	struct uverbs_req_iter iter;
+ 	struct ib_device *ib_dev;
++>>>>>>> 335708c751c1 (RDMA/uverbs: Add a simple iterator interface for reading the command)
  
- 	required_cmd_sz_header = offsetof(typeof(cmd), log_ind_tbl_size) + sizeof(cmd.log_ind_tbl_size);
- 	required_resp_len = offsetof(typeof(resp), ind_tbl_num) + sizeof(resp.ind_tbl_num);
- 
- 	if (ucore->inlen < required_cmd_sz_header)
- 		return -EINVAL;
- 
- 	if (ucore->outlen < required_resp_len)
- 		return -ENOSPC;
- 
- 	err = ib_copy_from_udata(&cmd, ucore, required_cmd_sz_header);
+ 	err = uverbs_request_start(attrs, &iter, &cmd, sizeof(cmd));
  	if (err)
  		return err;
  
@@@ -3540,17 -3246,13 +3637,12 @@@ int ib_uverbs_ex_create_flow(struct ib_
  	struct ib_qp			  *qp;
  	struct ib_uflow_resources	  *uflow_res;
  	struct ib_uverbs_flow_spec_hdr	  *kern_spec;
- 	int err = 0;
+ 	struct uverbs_req_iter iter;
+ 	int err;
  	void *ib_spec;
  	int i;
 -	struct ib_device *ib_dev;
  
- 	if (ucore->inlen < sizeof(cmd))
- 		return -EINVAL;
- 
- 	if (ucore->outlen < sizeof(resp))
- 		return -ENOSPC;
- 
- 	err = ib_copy_from_udata(&cmd, ucore, sizeof(cmd));
+ 	err = uverbs_request_start(attrs, &iter, &cmd, sizeof(cmd));
  	if (err)
  		return err;
  
@@@ -3598,7 -3296,11 +3686,15 @@@
  		kern_flow_attr = &cmd.flow_attr;
  	}
  
++<<<<<<< HEAD
 +	uobj  = uobj_alloc(UVERBS_OBJECT_FLOW, file->ucontext);
++=======
+ 	err = uverbs_request_finish(&iter);
+ 	if (err)
+ 		goto err_free_attr;
+ 
+ 	uobj = uobj_alloc(UVERBS_OBJECT_FLOW, attrs, &ib_dev);
++>>>>>>> 335708c751c1 (RDMA/uverbs: Add a simple iterator interface for reading the command)
  	if (IS_ERR(uobj)) {
  		err = PTR_ERR(uobj);
  		goto err_free_attr;
* Unmerged path drivers/infiniband/core/uverbs_cmd.c
