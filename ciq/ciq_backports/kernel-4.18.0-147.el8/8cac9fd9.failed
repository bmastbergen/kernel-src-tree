drm/i915: Inline skl_update_pipe_wm() into its only caller

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit 8cac9fd9bc7967cd114c543bdf70a5d0aa759498
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/8cac9fd9.failed

skl_update_pipe_wm() is quite pointless now. Just inline it into
skl_compute_wm().

v2: s/skl_build_pipe_wm/skl_update_pipe_wm/ in the commit message (Matt)

	Cc: Neel Desai <neel.desai@intel.com>
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190312205844.6339-10-ville.syrjala@linux.intel.com
	Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
(cherry picked from commit 8cac9fd9bc7967cd114c543bdf70a5d0aa759498)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_pm.c
diff --cc drivers/gpu/drm/i915/intel_pm.c
index a1b763e0c3a9,53e9304c66ab..000000000000
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@@ -5055,36 -5265,15 +5055,41 @@@ bool skl_ddb_allocation_overlaps(struc
  	return false;
  }
  
++<<<<<<< HEAD
 +static int skl_update_pipe_wm(struct drm_crtc_state *cstate,
 +			      const struct skl_pipe_wm *old_pipe_wm,
 +			      struct skl_pipe_wm *pipe_wm, /* out */
 +			      struct skl_ddb_allocation *ddb, /* out */
 +			      bool *changed /* out */)
 +{
 +	struct intel_crtc_state *intel_cstate = to_intel_crtc_state(cstate);
 +	int ret;
 +
 +	ret = skl_build_pipe_wm(intel_cstate, ddb, pipe_wm);
 +	if (ret)
 +		return ret;
 +
 +	if (!memcmp(old_pipe_wm, pipe_wm, sizeof(*pipe_wm)))
 +		*changed = false;
 +	else
 +		*changed = true;
 +
 +	return 0;
 +}
 +
 +static uint32_t
 +pipes_modified(struct drm_atomic_state *state)
++=======
+ static u32
+ pipes_modified(struct intel_atomic_state *state)
++>>>>>>> 8cac9fd9bc79 (drm/i915: Inline skl_update_pipe_wm() into its only caller)
  {
 -	struct intel_crtc *crtc;
 -	struct intel_crtc_state *cstate;
 -	u32 i, ret = 0;
 +	struct drm_crtc *crtc;
 +	struct drm_crtc_state *cstate;
 +	uint32_t i, ret = 0;
  
 -	for_each_new_intel_crtc_in_state(state, crtc, cstate, i)
 -		ret |= drm_crtc_mask(&crtc->base);
 +	for_each_new_crtc_in_state(state, crtc, cstate, i)
 +		ret |= drm_crtc_mask(crtc);
  
  	return ret;
  }
@@@ -5285,13 -5600,12 +5290,20 @@@ skl_ddb_add_affected_pipes(struct drm_a
  }
  
  static int
 -skl_compute_wm(struct intel_atomic_state *state)
 +skl_compute_wm(struct drm_atomic_state *state)
  {
++<<<<<<< HEAD
 +	struct drm_crtc *crtc;
 +	struct drm_crtc_state *cstate;
 +	struct intel_atomic_state *intel_state = to_intel_atomic_state(state);
 +	struct skl_ddb_values *results = &intel_state->wm_results;
 +	struct skl_pipe_wm *pipe_wm;
++=======
+ 	struct intel_crtc *crtc;
+ 	struct intel_crtc_state *new_crtc_state;
+ 	struct intel_crtc_state *old_crtc_state;
+ 	struct skl_ddb_values *results = &state->wm_results;
++>>>>>>> 8cac9fd9bc79 (drm/i915: Inline skl_update_pipe_wm() into its only caller)
  	bool changed = false;
  	int ret, i;
  
@@@ -5302,41 -5616,31 +5314,59 @@@
  	if (ret || !changed)
  		return ret;
  
 +	ret = skl_compute_ddb(state);
 +	if (ret)
 +		return ret;
 +
  	/*
  	 * Calculate WM's for all pipes that are part of this transaction.
 -	 * Note that skl_ddb_add_affected_pipes may have added more CRTC's that
 +	 * Note that the DDB allocation above may have added more CRTC's that
  	 * weren't otherwise being modified (and set bits in dirty_pipes) if
  	 * pipe allocations had to change.
 +	 *
 +	 * FIXME:  Now that we're doing this in the atomic check phase, we
 +	 * should allow skl_update_pipe_wm() to return failure in cases where
 +	 * no suitable watermark values can be found.
  	 */
++<<<<<<< HEAD
 +	for_each_new_crtc_in_state(state, crtc, cstate, i) {
 +		struct intel_crtc_state *intel_cstate =
 +			to_intel_crtc_state(cstate);
 +		const struct skl_pipe_wm *old_pipe_wm =
 +			&to_intel_crtc_state(crtc->state)->wm.skl.optimal;
 +
 +		pipe_wm = &intel_cstate->wm.skl.optimal;
 +		ret = skl_update_pipe_wm(cstate, old_pipe_wm, pipe_wm,
 +					 &results->ddb, &changed);
 +		if (ret)
 +			return ret;
 +
 +		if (changed)
 +			results->dirty_pipes |= drm_crtc_mask(crtc);
++=======
+ 	for_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,
+ 					    new_crtc_state, i) {
+ 		ret = skl_build_pipe_wm(new_crtc_state);
+ 		if (ret)
+ 			return ret;
+ 
+ 		ret = skl_wm_add_affected_planes(state, crtc);
+ 		if (ret)
+ 			return ret;
+ 
+ 		if (!skl_pipe_wm_equals(crtc,
+ 					&old_crtc_state->wm.skl.optimal,
+ 					&new_crtc_state->wm.skl.optimal))
+ 			results->dirty_pipes |= drm_crtc_mask(&crtc->base);
+ 	}
++>>>>>>> 8cac9fd9bc79 (drm/i915: Inline skl_update_pipe_wm() into its only caller)
  
 -	ret = skl_compute_ddb(state);
 -	if (ret)
 -		return ret;
 +		if ((results->dirty_pipes & drm_crtc_mask(crtc)) == 0)
 +			/* This pipe's WM's did not change */
 +			continue;
 +
 +		intel_cstate->update_wm_pre = true;
 +	}
  
  	skl_print_wm_changes(state);
  
* Unmerged path drivers/gpu/drm/i915/intel_pm.c
