ice: Update rings based on TC information

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
commit a629cf0a018b8d80b65bfd2b7f0d209a52834315
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/a629cf0a.failed

This patch adds a new function ice_vsi_cfg_dcb_rings which updates a
VSI's rings based on DCB traffic class information.

	Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit a629cf0a018b8d80b65bfd2b7f0d209a52834315)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_dcb_lib.c
#	drivers/net/ethernet/intel/ice/ice_dcb_lib.h
diff --cc drivers/net/ethernet/intel/ice/ice_dcb_lib.c
index f2dd41408652,aabba91189bd..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_dcb_lib.c
+++ b/drivers/net/ethernet/intel/ice/ice_dcb_lib.c
@@@ -4,6 -4,271 +4,274 @@@
  #include "ice_dcb_lib.h"
  
  /**
++<<<<<<< HEAD
++=======
+  * ice_dcb_get_ena_tc - return bitmap of enabled TCs
+  * @dcbcfg: DCB config to evaluate for enabled TCs
+  */
+ u8 ice_dcb_get_ena_tc(struct ice_dcbx_cfg *dcbcfg)
+ {
+ 	u8 i, num_tc, ena_tc = 1;
+ 
+ 	num_tc = ice_dcb_get_num_tc(dcbcfg);
+ 
+ 	for (i = 0; i < num_tc; i++)
+ 		ena_tc |= BIT(i);
+ 
+ 	return ena_tc;
+ }
+ 
+ /**
+  * ice_dcb_get_num_tc - Get the number of TCs from DCBX config
+  * @dcbcfg: config to retrieve number of TCs from
+  */
+ u8 ice_dcb_get_num_tc(struct ice_dcbx_cfg *dcbcfg)
+ {
+ 	bool tc_unused = false;
+ 	u8 num_tc = 0;
+ 	u8 ret = 0;
+ 	int i;
+ 
+ 	/* Scan the ETS Config Priority Table to find traffic classes
+ 	 * enabled and create a bitmask of enabled TCs
+ 	 */
+ 	for (i = 0; i < CEE_DCBX_MAX_PRIO; i++)
+ 		num_tc |= BIT(dcbcfg->etscfg.prio_table[i]);
+ 
+ 	/* Scan bitmask for contiguous TCs starting with TC0 */
+ 	for (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {
+ 		if (num_tc & BIT(i)) {
+ 			if (!tc_unused) {
+ 				ret++;
+ 			} else {
+ 				pr_err("Non-contiguous TCs - Disabling DCB\n");
+ 				return 1;
+ 			}
+ 		} else {
+ 			tc_unused = true;
+ 		}
+ 	}
+ 
+ 	/* There is always at least 1 TC */
+ 	if (!ret)
+ 		ret = 1;
+ 
+ 	return ret;
+ }
+ 
+ /**
+  * ice_vsi_cfg_dcb_rings - Update rings to reflect DCB TC
+  * @vsi: VSI owner of rings being updated
+  */
+ void ice_vsi_cfg_dcb_rings(struct ice_vsi *vsi)
+ {
+ 	struct ice_ring *tx_ring, *rx_ring;
+ 	u16 qoffset, qcount;
+ 	int i, n;
+ 
+ 	if (!test_bit(ICE_FLAG_DCB_ENA, vsi->back->flags)) {
+ 		/* Reset the TC information */
+ 		for (i = 0; i < vsi->num_txq; i++) {
+ 			tx_ring = vsi->tx_rings[i];
+ 			tx_ring->dcb_tc = 0;
+ 		}
+ 		for (i = 0; i < vsi->num_rxq; i++) {
+ 			rx_ring = vsi->rx_rings[i];
+ 			rx_ring->dcb_tc = 0;
+ 		}
+ 		return;
+ 	}
+ 
+ 	ice_for_each_traffic_class(n) {
+ 		if (!(vsi->tc_cfg.ena_tc & BIT(n)))
+ 			break;
+ 
+ 		qoffset = vsi->tc_cfg.tc_info[n].qoffset;
+ 		qcount = vsi->tc_cfg.tc_info[n].qcount_tx;
+ 		for (i = qoffset; i < (qoffset + qcount); i++) {
+ 			tx_ring = vsi->tx_rings[i];
+ 			rx_ring = vsi->rx_rings[i];
+ 			tx_ring->dcb_tc = n;
+ 			rx_ring->dcb_tc = n;
+ 		}
+ 	}
+ }
+ 
+ /**
+  * ice_pf_dcb_recfg - Reconfigure all VEBs and VSIs
+  * @pf: pointer to the PF struct
+  *
+  * Assumed caller has already disabled all VSIs before
+  * calling this function. Reconfiguring DCB based on
+  * local_dcbx_cfg.
+  */
+ static void ice_pf_dcb_recfg(struct ice_pf *pf)
+ {
+ 	struct ice_dcbx_cfg *dcbcfg = &pf->hw.port_info->local_dcbx_cfg;
+ 	u8 tc_map = 0;
+ 	int v, ret;
+ 
+ 	/* Update each VSI */
+ 	ice_for_each_vsi(pf, v) {
+ 		if (!pf->vsi[v])
+ 			continue;
+ 
+ 		if (pf->vsi[v]->type == ICE_VSI_PF)
+ 			tc_map = ice_dcb_get_ena_tc(dcbcfg);
+ 		else
+ 			tc_map = ICE_DFLT_TRAFFIC_CLASS;
+ 
+ 		ret = ice_vsi_cfg_tc(pf->vsi[v], tc_map);
+ 		if (ret)
+ 			dev_err(&pf->pdev->dev,
+ 				"Failed to config TC for VSI index: %d\n",
+ 				pf->vsi[v]->idx);
+ 		else
+ 			ice_vsi_map_rings_to_vectors(pf->vsi[v]);
+ 	}
+ }
+ 
+ /**
+  * ice_pf_dcb_cfg - Apply new DCB configuration
+  * @pf: pointer to the PF struct
+  * @new_cfg: DCBX config to apply
+  */
+ static int ice_pf_dcb_cfg(struct ice_pf *pf, struct ice_dcbx_cfg *new_cfg)
+ {
+ 	struct ice_dcbx_cfg *old_cfg, *curr_cfg;
+ 	struct ice_aqc_port_ets_elem buf = { 0 };
+ 	int ret = 0;
+ 
+ 	curr_cfg = &pf->hw.port_info->local_dcbx_cfg;
+ 
+ 	/* Enable DCB tagging only when more than one TC */
+ 	if (ice_dcb_get_num_tc(new_cfg) > 1) {
+ 		dev_dbg(&pf->pdev->dev, "DCB tagging enabled (num TC > 1)\n");
+ 		set_bit(ICE_FLAG_DCB_ENA, pf->flags);
+ 	} else {
+ 		dev_dbg(&pf->pdev->dev, "DCB tagging disabled (num TC = 1)\n");
+ 		clear_bit(ICE_FLAG_DCB_ENA, pf->flags);
+ 	}
+ 
+ 	if (!memcmp(new_cfg, curr_cfg, sizeof(*new_cfg))) {
+ 		dev_dbg(&pf->pdev->dev, "No change in DCB config required\n");
+ 		return ret;
+ 	}
+ 
+ 	/* Store old config in case FW config fails */
+ 	old_cfg = devm_kzalloc(&pf->pdev->dev, sizeof(*old_cfg), GFP_KERNEL);
+ 	memcpy(old_cfg, curr_cfg, sizeof(*old_cfg));
+ 
+ 	/* avoid race conditions by holding the lock while disabling and
+ 	 * re-enabling the VSI
+ 	 */
+ 	rtnl_lock();
+ 	ice_pf_dis_all_vsi(pf, true);
+ 
+ 	memcpy(curr_cfg, new_cfg, sizeof(*curr_cfg));
+ 	memcpy(&curr_cfg->etsrec, &curr_cfg->etscfg, sizeof(curr_cfg->etsrec));
+ 
+ 	/* Only send new config to HW if we are in SW LLDP mode. Otherwise,
+ 	 * the new config came from the HW in the first place.
+ 	 */
+ 	if (pf->hw.port_info->is_sw_lldp) {
+ 		ret = ice_set_dcb_cfg(pf->hw.port_info);
+ 		if (ret) {
+ 			dev_err(&pf->pdev->dev, "Set DCB Config failed\n");
+ 			/* Restore previous settings to local config */
+ 			memcpy(curr_cfg, old_cfg, sizeof(*curr_cfg));
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	ret = ice_query_port_ets(pf->hw.port_info, &buf, sizeof(buf), NULL);
+ 	if (ret) {
+ 		dev_err(&pf->pdev->dev, "Query Port ETS failed\n");
+ 		goto out;
+ 	}
+ 
+ 	ice_pf_dcb_recfg(pf);
+ 
+ out:
+ 	ice_pf_ena_all_vsi(pf, true);
+ 	rtnl_unlock();
+ 	devm_kfree(&pf->pdev->dev, old_cfg);
+ 	return ret;
+ }
+ 
+ /**
+  * ice_dcb_init_cfg - set the initial DCB config in SW
+  * @pf: pf to apply config to
+  */
+ static int ice_dcb_init_cfg(struct ice_pf *pf)
+ {
+ 	struct ice_dcbx_cfg *newcfg;
+ 	struct ice_port_info *pi;
+ 	int ret = 0;
+ 
+ 	pi = pf->hw.port_info;
+ 	newcfg = devm_kzalloc(&pf->pdev->dev, sizeof(*newcfg), GFP_KERNEL);
+ 	if (!newcfg)
+ 		return -ENOMEM;
+ 
+ 	memcpy(newcfg, &pi->local_dcbx_cfg, sizeof(*newcfg));
+ 	memset(&pi->local_dcbx_cfg, 0, sizeof(*newcfg));
+ 
+ 	dev_info(&pf->pdev->dev, "Configuring initial DCB values\n");
+ 	if (ice_pf_dcb_cfg(pf, newcfg))
+ 		ret = -EINVAL;
+ 
+ 	devm_kfree(&pf->pdev->dev, newcfg);
+ 
+ 	return ret;
+ }
+ 
+ /**
+  * ice_dcb_sw_default_config - Apply a default DCB config
+  * @pf: pf to apply config to
+  */
+ static int ice_dcb_sw_dflt_cfg(struct ice_pf *pf)
+ {
+ 	struct ice_aqc_port_ets_elem buf = { 0 };
+ 	struct ice_dcbx_cfg *dcbcfg;
+ 	struct ice_port_info *pi;
+ 	struct ice_hw *hw;
+ 	int ret;
+ 
+ 	hw = &pf->hw;
+ 	pi = hw->port_info;
+ 	dcbcfg = devm_kzalloc(&pf->pdev->dev, sizeof(*dcbcfg), GFP_KERNEL);
+ 
+ 	memset(dcbcfg, 0, sizeof(*dcbcfg));
+ 	memset(&pi->local_dcbx_cfg, 0, sizeof(*dcbcfg));
+ 
+ 	dcbcfg->etscfg.willing = 1;
+ 	dcbcfg->etscfg.maxtcs = 8;
+ 	dcbcfg->etscfg.tcbwtable[0] = 100;
+ 	dcbcfg->etscfg.tsatable[0] = ICE_IEEE_TSA_ETS;
+ 
+ 	memcpy(&dcbcfg->etsrec, &dcbcfg->etscfg,
+ 	       sizeof(dcbcfg->etsrec));
+ 	dcbcfg->etsrec.willing = 0;
+ 
+ 	dcbcfg->pfc.willing = 1;
+ 	dcbcfg->pfc.pfccap = IEEE_8021QAZ_MAX_TCS;
+ 
+ 	dcbcfg->numapps = 1;
+ 	dcbcfg->app[0].selector = ICE_APP_SEL_ETHTYPE;
+ 	dcbcfg->app[0].priority = 3;
+ 	dcbcfg->app[0].prot_id = ICE_APP_PROT_ID_FCOE;
+ 
+ 	ret = ice_pf_dcb_cfg(pf, dcbcfg);
+ 	devm_kfree(&pf->pdev->dev, dcbcfg);
+ 	if (ret)
+ 		return ret;
+ 
+ 	return ice_query_port_ets(pi, &buf, sizeof(buf), NULL);
+ }
+ 
+ /**
++>>>>>>> a629cf0a018b (ice: Update rings based on TC information)
   * ice_init_pf_dcb - initialize DCB for a PF
   * @pf: pf to initiialize DCB for
   */
diff --cc drivers/net/ethernet/intel/ice/ice_dcb_lib.h
index d67c769a9fb5,8932702b0b66..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_dcb_lib.h
+++ b/drivers/net/ethernet/intel/ice/ice_dcb_lib.h
@@@ -8,12 -8,37 +8,34 @@@
  #include "ice_lib.h"
  
  #ifdef CONFIG_DCB
++<<<<<<< HEAD
 +int ice_init_pf_dcb(struct ice_pf *pf);
++=======
+ u8 ice_dcb_get_ena_tc(struct ice_dcbx_cfg *dcbcfg);
+ u8 ice_dcb_get_num_tc(struct ice_dcbx_cfg *dcbcfg);
+ void ice_vsi_cfg_dcb_rings(struct ice_vsi *vsi);
+ int ice_init_pf_dcb(struct ice_pf *pf);
+ void
+ ice_dcb_process_lldp_set_mib_change(struct ice_pf *pf,
+ 				    struct ice_rq_event_info *event);
+ static inline void
+ ice_set_cgd_num(struct ice_tlan_ctx *tlan_ctx, struct ice_ring *ring)
+ {
+ 	tlan_ctx->cgd_num = ring->dcb_tc;
+ }
++>>>>>>> a629cf0a018b (ice: Update rings based on TC information)
  #else
 -static inline u8 ice_dcb_get_ena_tc(struct ice_dcbx_cfg __always_unused *dcbcfg)
 -{
 -	return ICE_DFLT_TRAFFIC_CLASS;
 -}
 -
 -static inline u8 ice_dcb_get_num_tc(struct ice_dcbx_cfg __always_unused *dcbcfg)
 -{
 -	return 1;
 -}
 -
  static inline int ice_init_pf_dcb(struct ice_pf *pf)
  {
  	dev_dbg(&pf->pdev->dev, "DCB not supported\n");
  	return -EOPNOTSUPP;
  }
++<<<<<<< HEAD
++=======
+ 
+ #define ice_vsi_cfg_dcb_rings(vsi) do {} while (0)
+ #define ice_dcb_process_lldp_set_mib_change(pf, event) do {} while (0)
+ #define ice_set_cgd_num(tlan_ctx, ring) do {} while (0)
++>>>>>>> a629cf0a018b (ice: Update rings based on TC information)
  #endif /* CONFIG_DCB */
  #endif /* _ICE_DCB_LIB_H_ */
* Unmerged path drivers/net/ethernet/intel/ice/ice_dcb_lib.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_dcb_lib.h
diff --git a/drivers/net/ethernet/intel/ice/ice_lib.c b/drivers/net/ethernet/intel/ice/ice_lib.c
index 332fa801ab27..aa7420f19ea1 100644
--- a/drivers/net/ethernet/intel/ice/ice_lib.c
+++ b/drivers/net/ethernet/intel/ice/ice_lib.c
@@ -124,6 +124,8 @@ ice_setup_tx_ctx(struct ice_ring *ring, struct ice_tlan_ctx *tlan_ctx, u16 pf_q)
 	/* Transmit Queue Length */
 	tlan_ctx->qlen = ring->count;
 
+	ice_set_cgd_num(tlan_ctx, ring);
+
 	/* PF number */
 	tlan_ctx->pf_num = hw->pf_id;
 
diff --git a/drivers/net/ethernet/intel/ice/ice_main.c b/drivers/net/ethernet/intel/ice/ice_main.c
index 7fbfa22e64eb..c164f8d5a7d7 100644
--- a/drivers/net/ethernet/intel/ice/ice_main.c
+++ b/drivers/net/ethernet/intel/ice/ice_main.c
@@ -2787,6 +2787,7 @@ static int ice_vsi_cfg(struct ice_vsi *vsi)
 		if (err)
 			return err;
 	}
+	ice_vsi_cfg_dcb_rings(vsi);
 
 	err = ice_vsi_cfg_lan_txqs(vsi);
 	if (!err)
diff --git a/drivers/net/ethernet/intel/ice/ice_txrx.h b/drivers/net/ethernet/intel/ice/ice_txrx.h
index 75d0eaf6c9dd..8cb130b0e155 100644
--- a/drivers/net/ethernet/intel/ice/ice_txrx.h
+++ b/drivers/net/ethernet/intel/ice/ice_txrx.h
@@ -148,6 +148,9 @@ struct ice_ring {
 	};
 	u16 q_index;			/* Queue number of ring */
 	u32 txq_teid;			/* Added Tx queue TEID */
+#ifdef CONFIG_DCB
+	u8 dcb_tc;		/* Traffic class of ring */
+#endif /* CONFIG_DCB */
 
 	u16 count;			/* Number of descriptors */
 	u16 reg_idx;			/* HW register index of the ring */
