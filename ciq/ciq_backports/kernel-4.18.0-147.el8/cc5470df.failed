iwlwifi: print fseq info upon fw assert

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Shahar S Matityahu <shahar.s.matityahu@intel.com>
commit cc5470df4495049170d49466415680ee3c2a9a42
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/cc5470df.failed

Read fseq info from FW registers and print it upon fw assert.
The print is needed since the fseq version coming from the TLV might
not be the actual version that is used.

	Signed-off-by: Shahar S Matityahu <shahar.s.matityahu@intel.com>
	Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
	Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
(cherry picked from commit cc5470df4495049170d49466415680ee3c2a9a42)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/intel/iwlwifi/fw/dbg.c
#	drivers/net/wireless/intel/iwlwifi/fw/dbg.h
#	drivers/net/wireless/intel/iwlwifi/iwl-prph.h
#	drivers/net/wireless/intel/iwlwifi/pcie/trans.c
diff --cc drivers/net/wireless/intel/iwlwifi/fw/dbg.c
index fa283285fcbe,33d7bc5500db..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/fw/dbg.c
+++ b/drivers/net/wireless/intel/iwlwifi/fw/dbg.c
@@@ -1169,3 -2325,464 +1169,467 @@@ out
  		fwrt->ops->dump_end(fwrt->ops_ctx);
  }
  
++<<<<<<< HEAD
++=======
+ void iwl_fw_dbg_read_d3_debug_data(struct iwl_fw_runtime *fwrt)
+ {
+ 	const struct iwl_cfg *cfg = fwrt->trans->cfg;
+ 
+ 	if (!iwl_fw_dbg_is_d3_debug_enabled(fwrt))
+ 		return;
+ 
+ 	if (!fwrt->dump.d3_debug_data) {
+ 		fwrt->dump.d3_debug_data = kmalloc(cfg->d3_debug_data_length,
+ 						   GFP_KERNEL);
+ 		if (!fwrt->dump.d3_debug_data) {
+ 			IWL_ERR(fwrt,
+ 				"failed to allocate memory for D3 debug data\n");
+ 			return;
+ 		}
+ 	}
+ 
+ 	/* if the buffer holds previous debug data it is overwritten */
+ 	iwl_trans_read_mem_bytes(fwrt->trans, cfg->d3_debug_data_base_addr,
+ 				 fwrt->dump.d3_debug_data,
+ 				 cfg->d3_debug_data_length);
+ }
+ IWL_EXPORT_SYMBOL(iwl_fw_dbg_read_d3_debug_data);
+ 
+ static void
+ iwl_fw_dbg_buffer_allocation(struct iwl_fw_runtime *fwrt, u32 size)
+ {
+ 	struct iwl_trans *trans = fwrt->trans;
+ 	void *virtual_addr = NULL;
+ 	dma_addr_t phys_addr;
+ 
+ 	if (WARN_ON_ONCE(trans->num_blocks == ARRAY_SIZE(trans->fw_mon)))
+ 		return;
+ 
+ 	virtual_addr =
+ 		dma_alloc_coherent(fwrt->trans->dev, size, &phys_addr,
+ 				   GFP_KERNEL | __GFP_NOWARN | __GFP_ZERO |
+ 				   __GFP_COMP);
+ 
+ 	/* TODO: alloc fragments if needed */
+ 	if (!virtual_addr)
+ 		IWL_ERR(fwrt, "Failed to allocate debug memory\n");
+ 
+ 	IWL_DEBUG_FW(trans,
+ 		     "Allocated DRAM buffer[%d], size=0x%x\n",
+ 		     trans->num_blocks, size);
+ 
+ 	trans->fw_mon[trans->num_blocks].block = virtual_addr;
+ 	trans->fw_mon[trans->num_blocks].physical = phys_addr;
+ 	trans->fw_mon[trans->num_blocks].size = size;
+ 	trans->num_blocks++;
+ }
+ 
+ static void iwl_fw_dbg_buffer_apply(struct iwl_fw_runtime *fwrt,
+ 				    struct iwl_fw_ini_allocation_data *alloc,
+ 				    enum iwl_fw_ini_apply_point pnt)
+ {
+ 	struct iwl_trans *trans = fwrt->trans;
+ 	struct iwl_ldbg_config_cmd ldbg_cmd = {
+ 		.type = cpu_to_le32(BUFFER_ALLOCATION),
+ 	};
+ 	struct iwl_buffer_allocation_cmd *cmd = &ldbg_cmd.buffer_allocation;
+ 	struct iwl_host_cmd hcmd = {
+ 		.id = LDBG_CONFIG_CMD,
+ 		.flags = CMD_ASYNC,
+ 		.data[0] = &ldbg_cmd,
+ 		.len[0] = sizeof(ldbg_cmd),
+ 	};
+ 	int block_idx = trans->num_blocks;
+ 	u32 buf_location = le32_to_cpu(alloc->tlv.buffer_location);
+ 
+ 	if (buf_location == IWL_FW_INI_LOCATION_SRAM_PATH) {
+ 		if (!WARN(pnt != IWL_FW_INI_APPLY_EARLY,
+ 			  "WRT: Invalid apply point %d for SMEM buffer allocation, aborting\n",
+ 			  pnt)) {
+ 			IWL_DEBUG_FW(trans,
+ 				     "WRT: applying SMEM buffer destination\n");
+ 
+ 			/* set sram monitor by enabling bit 7 */
+ 			iwl_set_bit(fwrt->trans, CSR_HW_IF_CONFIG_REG,
+ 				    CSR_HW_IF_CONFIG_REG_BIT_MONITOR_SRAM);
+ 		}
+ 		return;
+ 	}
+ 
+ 	if (buf_location != IWL_FW_INI_LOCATION_DRAM_PATH)
+ 		return;
+ 
+ 	if (!alloc->is_alloc) {
+ 		iwl_fw_dbg_buffer_allocation(fwrt,
+ 					     le32_to_cpu(alloc->tlv.size));
+ 		if (block_idx == trans->num_blocks)
+ 			return;
+ 		alloc->is_alloc = 1;
+ 	}
+ 
+ 	/* First block is assigned via registers / context info */
+ 	if (trans->num_blocks == 1)
+ 		return;
+ 
+ 	IWL_DEBUG_FW(trans,
+ 		     "WRT: applying DRAM buffer[%d] destination\n", block_idx);
+ 
+ 	cmd->num_frags = cpu_to_le32(1);
+ 	cmd->fragments[0].address =
+ 		cpu_to_le64(trans->fw_mon[block_idx].physical);
+ 	cmd->fragments[0].size = alloc->tlv.size;
+ 	cmd->allocation_id = alloc->tlv.allocation_id;
+ 	cmd->buffer_location = alloc->tlv.buffer_location;
+ 
+ 	iwl_trans_send_cmd(trans, &hcmd);
+ }
+ 
+ static void iwl_fw_dbg_send_hcmd(struct iwl_fw_runtime *fwrt,
+ 				 struct iwl_ucode_tlv *tlv,
+ 				 bool ext)
+ {
+ 	struct iwl_fw_ini_hcmd_tlv *hcmd_tlv = (void *)&tlv->data[0];
+ 	struct iwl_fw_ini_hcmd *data = &hcmd_tlv->hcmd;
+ 	u16 len = le32_to_cpu(tlv->length) - sizeof(*hcmd_tlv);
+ 
+ 	struct iwl_host_cmd hcmd = {
+ 		.id = WIDE_ID(data->group, data->id),
+ 		.len = { len, },
+ 		.data = { data->data, },
+ 	};
+ 
+ 	/* currently the driver supports always on domain only */
+ 	if (le32_to_cpu(hcmd_tlv->domain) != IWL_FW_INI_DBG_DOMAIN_ALWAYS_ON)
+ 		return;
+ 
+ 	IWL_DEBUG_FW(fwrt,
+ 		     "WRT: ext=%d. Sending host command id=0x%x, group=0x%x\n",
+ 		     ext, data->id, data->group);
+ 
+ 	iwl_trans_send_cmd(fwrt->trans, &hcmd);
+ }
+ 
+ static void iwl_fw_dbg_update_regions(struct iwl_fw_runtime *fwrt,
+ 				      struct iwl_fw_ini_region_tlv *tlv,
+ 				      bool ext, enum iwl_fw_ini_apply_point pnt)
+ {
+ 	void *iter = (void *)tlv->region_config;
+ 	int i, size = le32_to_cpu(tlv->num_regions);
+ 	const char *err_st =
+ 		"WRT: ext=%d. Invalid region %s %d for apply point %d\n";
+ 
+ 	for (i = 0; i < size; i++) {
+ 		struct iwl_fw_ini_region_cfg *reg = iter, **active;
+ 		int id = le32_to_cpu(reg->region_id);
+ 		u32 type = le32_to_cpu(reg->region_type);
+ 
+ 		if (WARN(id >= ARRAY_SIZE(fwrt->dump.active_regs), err_st, ext,
+ 			 "id", id, pnt))
+ 			break;
+ 
+ 		if (WARN(type == 0 || type >= IWL_FW_INI_REGION_NUM, err_st,
+ 			 ext, "type", type, pnt))
+ 			break;
+ 
+ 		active = &fwrt->dump.active_regs[id];
+ 
+ 		if (*active)
+ 			IWL_WARN(fwrt->trans,
+ 				 "WRT: ext=%d. Region id %d override\n",
+ 				 ext, id);
+ 
+ 		IWL_DEBUG_FW(fwrt,
+ 			     "WRT: ext=%d. Activating region id %d\n",
+ 			     ext, id);
+ 
+ 		*active = reg;
+ 
+ 		if (type == IWL_FW_INI_REGION_TXF ||
+ 		    type == IWL_FW_INI_REGION_RXF)
+ 			iter += le32_to_cpu(reg->fifos.num_of_registers) *
+ 				sizeof(__le32);
+ 		else if (type == IWL_FW_INI_REGION_DEVICE_MEMORY ||
+ 			 type == IWL_FW_INI_REGION_PERIPHERY_MAC ||
+ 			 type == IWL_FW_INI_REGION_PERIPHERY_PHY ||
+ 			 type == IWL_FW_INI_REGION_PERIPHERY_AUX ||
+ 			 type == IWL_FW_INI_REGION_INTERNAL_BUFFER ||
+ 			 type == IWL_FW_INI_REGION_PAGING ||
+ 			 type == IWL_FW_INI_REGION_CSR ||
+ 			 type == IWL_FW_INI_REGION_LMAC_ERROR_TABLE ||
+ 			 type == IWL_FW_INI_REGION_UMAC_ERROR_TABLE)
+ 			iter += le32_to_cpu(reg->internal.num_of_ranges) *
+ 				sizeof(__le32);
+ 
+ 		iter += sizeof(*reg);
+ 	}
+ }
+ 
+ static int iwl_fw_dbg_trig_realloc(struct iwl_fw_runtime *fwrt,
+ 				   struct iwl_fw_ini_active_triggers *active,
+ 				   u32 id, int size)
+ {
+ 	void *ptr;
+ 
+ 	if (size <= active->size)
+ 		return 0;
+ 
+ 	ptr = krealloc(active->trig, size, GFP_KERNEL);
+ 	if (!ptr) {
+ 		IWL_ERR(fwrt, "WRT: Failed to allocate memory for trigger %d\n",
+ 			id);
+ 		return -ENOMEM;
+ 	}
+ 	active->trig = ptr;
+ 	active->size = size;
+ 
+ 	return 0;
+ }
+ 
+ static void iwl_fw_dbg_update_triggers(struct iwl_fw_runtime *fwrt,
+ 				       struct iwl_fw_ini_trigger_tlv *tlv,
+ 				       bool ext,
+ 				       enum iwl_fw_ini_apply_point apply_point)
+ {
+ 	int i, size = le32_to_cpu(tlv->num_triggers);
+ 	void *iter = (void *)tlv->trigger_config;
+ 
+ 	for (i = 0; i < size; i++) {
+ 		struct iwl_fw_ini_trigger *trig = iter;
+ 		struct iwl_fw_ini_active_triggers *active;
+ 		int id = le32_to_cpu(trig->trigger_id);
+ 		u32 trig_regs_size = le32_to_cpu(trig->num_regions) *
+ 			sizeof(__le32);
+ 
+ 		if (WARN(id >= ARRAY_SIZE(fwrt->dump.active_trigs),
+ 			 "WRT: ext=%d. Invalid trigger id %d for apply point %d\n",
+ 			 ext, id, apply_point))
+ 			break;
+ 
+ 		active = &fwrt->dump.active_trigs[id];
+ 
+ 		if (!active->active) {
+ 			size_t trig_size = sizeof(*trig) + trig_regs_size;
+ 
+ 			IWL_DEBUG_FW(fwrt,
+ 				     "WRT: ext=%d. Activating trigger %d\n",
+ 				     ext, id);
+ 
+ 			if (iwl_fw_dbg_trig_realloc(fwrt, active, id,
+ 						    trig_size))
+ 				goto next;
+ 
+ 			memcpy(active->trig, trig, trig_size);
+ 
+ 		} else {
+ 			u32 conf_override =
+ 				!(le32_to_cpu(trig->override_trig) & 0xff);
+ 			u32 region_override =
+ 				!(le32_to_cpu(trig->override_trig) & 0xff00);
+ 			u32 offset = 0;
+ 			u32 active_regs =
+ 				le32_to_cpu(active->trig->num_regions);
+ 			u32 new_regs = le32_to_cpu(trig->num_regions);
+ 			int mem_to_add = trig_regs_size;
+ 
+ 			if (region_override) {
+ 				IWL_DEBUG_FW(fwrt,
+ 					     "WRT: ext=%d. Trigger %d regions override\n",
+ 					     ext, id);
+ 
+ 				mem_to_add -= active_regs * sizeof(__le32);
+ 			} else {
+ 				IWL_DEBUG_FW(fwrt,
+ 					     "WRT: ext=%d. Trigger %d regions appending\n",
+ 					     ext, id);
+ 
+ 				offset += active_regs;
+ 				new_regs += active_regs;
+ 			}
+ 
+ 			if (iwl_fw_dbg_trig_realloc(fwrt, active, id,
+ 						    active->size + mem_to_add))
+ 				goto next;
+ 
+ 			if (conf_override) {
+ 				IWL_DEBUG_FW(fwrt,
+ 					     "WRT: ext=%d. Trigger %d configuration override\n",
+ 					     ext, id);
+ 
+ 				memcpy(active->trig, trig, sizeof(*trig));
+ 			}
+ 
+ 			memcpy(active->trig->data + offset, trig->data,
+ 			       trig_regs_size);
+ 			active->trig->num_regions = cpu_to_le32(new_regs);
+ 		}
+ 
+ 		/* Since zero means infinity - just set to -1 */
+ 		if (!le32_to_cpu(active->trig->occurrences))
+ 			active->trig->occurrences = cpu_to_le32(-1);
+ 
+ 		active->active = true;
+ 
+ 		if (id == IWL_FW_TRIGGER_ID_PERIODIC_TRIGGER) {
+ 			u32 collect_interval = le32_to_cpu(trig->trigger_data);
+ 
+ 			/* the minimum allowed interval is 50ms */
+ 			if (collect_interval < 50) {
+ 				collect_interval = 50;
+ 				trig->trigger_data =
+ 					cpu_to_le32(collect_interval);
+ 			}
+ 
+ 			mod_timer(&fwrt->dump.periodic_trig,
+ 				  jiffies + msecs_to_jiffies(collect_interval));
+ 		}
+ next:
+ 		iter += sizeof(*trig) + trig_regs_size;
+ 
+ 	}
+ }
+ 
+ static void _iwl_fw_dbg_apply_point(struct iwl_fw_runtime *fwrt,
+ 				    struct iwl_apply_point_data *data,
+ 				    enum iwl_fw_ini_apply_point pnt,
+ 				    bool ext)
+ {
+ 	void *iter = data->data;
+ 
+ 	while (iter && iter < data->data + data->size) {
+ 		struct iwl_ucode_tlv *tlv = iter;
+ 		void *ini_tlv = (void *)tlv->data;
+ 		u32 type = le32_to_cpu(tlv->type);
+ 
+ 		switch (type) {
+ 		case IWL_UCODE_TLV_TYPE_BUFFER_ALLOCATION: {
+ 			struct iwl_fw_ini_allocation_data *buf_alloc = ini_tlv;
+ 
+ 			iwl_fw_dbg_buffer_apply(fwrt, ini_tlv, pnt);
+ 			iter += sizeof(buf_alloc->is_alloc);
+ 			break;
+ 		}
+ 		case IWL_UCODE_TLV_TYPE_HCMD:
+ 			if (pnt < IWL_FW_INI_APPLY_AFTER_ALIVE) {
+ 				IWL_ERR(fwrt,
+ 					"WRT: ext=%d. Invalid apply point %d for host command\n",
+ 					ext, pnt);
+ 				goto next;
+ 			}
+ 			iwl_fw_dbg_send_hcmd(fwrt, tlv, ext);
+ 			break;
+ 		case IWL_UCODE_TLV_TYPE_REGIONS:
+ 			iwl_fw_dbg_update_regions(fwrt, ini_tlv, ext, pnt);
+ 			break;
+ 		case IWL_UCODE_TLV_TYPE_TRIGGERS:
+ 			iwl_fw_dbg_update_triggers(fwrt, ini_tlv, ext, pnt);
+ 			break;
+ 		case IWL_UCODE_TLV_TYPE_DEBUG_FLOW:
+ 			break;
+ 		default:
+ 			WARN_ONCE(1,
+ 				  "WRT: ext=%d. Invalid TLV 0x%x for apply point\n",
+ 				  ext, type);
+ 			break;
+ 		}
+ next:
+ 		iter += sizeof(*tlv) + le32_to_cpu(tlv->length);
+ 	}
+ }
+ 
+ void iwl_fw_dbg_apply_point(struct iwl_fw_runtime *fwrt,
+ 			    enum iwl_fw_ini_apply_point apply_point)
+ {
+ 	void *data = &fwrt->trans->apply_points[apply_point];
+ 	int i;
+ 
+ 	IWL_DEBUG_FW(fwrt, "WRT: enabling apply point %d\n", apply_point);
+ 
+ 	if (apply_point == IWL_FW_INI_APPLY_EARLY) {
+ 		for (i = 0; i < IWL_FW_INI_MAX_REGION_ID; i++)
+ 			fwrt->dump.active_regs[i] = NULL;
+ 
+ 		/* disable the triggers, used in recovery flow */
+ 		for (i = 0; i < IWL_FW_TRIGGER_ID_NUM; i++)
+ 			fwrt->dump.active_trigs[i].active = false;
+ 	}
+ 
+ 	_iwl_fw_dbg_apply_point(fwrt, data, apply_point, false);
+ 
+ 	data = &fwrt->trans->apply_points_ext[apply_point];
+ 	_iwl_fw_dbg_apply_point(fwrt, data, apply_point, true);
+ }
+ IWL_EXPORT_SYMBOL(iwl_fw_dbg_apply_point);
+ 
+ void iwl_fwrt_stop_device(struct iwl_fw_runtime *fwrt)
+ {
+ 	del_timer(&fwrt->dump.periodic_trig);
+ 	iwl_fw_dbg_collect_sync(fwrt);
+ 
+ 	iwl_trans_stop_device(fwrt->trans);
+ }
+ IWL_EXPORT_SYMBOL(iwl_fwrt_stop_device);
+ 
+ void iwl_fw_dbg_periodic_trig_handler(struct timer_list *t)
+ {
+ 	struct iwl_fw_runtime *fwrt;
+ 	enum iwl_fw_ini_trigger_id id = IWL_FW_TRIGGER_ID_PERIODIC_TRIGGER;
+ 	int ret;
+ 	typeof(fwrt->dump) *dump_ptr = container_of(t, typeof(fwrt->dump),
+ 						    periodic_trig);
+ 
+ 	fwrt = container_of(dump_ptr, typeof(*fwrt), dump);
+ 
+ 	ret = _iwl_fw_dbg_ini_collect(fwrt, id);
+ 	if (!ret || ret == -EBUSY) {
+ 		struct iwl_fw_ini_trigger *trig =
+ 			fwrt->dump.active_trigs[id].trig;
+ 		u32 occur = le32_to_cpu(trig->occurrences);
+ 		u32 collect_interval = le32_to_cpu(trig->trigger_data);
+ 
+ 		if (!occur)
+ 			return;
+ 
+ 		mod_timer(&fwrt->dump.periodic_trig,
+ 			  jiffies + msecs_to_jiffies(collect_interval));
+ 	}
+ }
+ 
+ #define FSEQ_REG(x) { .addr = (x), .str = #x, }
+ 
+ void iwl_fw_error_print_fseq_regs(struct iwl_fw_runtime *fwrt)
+ {
+ 	struct iwl_trans *trans = fwrt->trans;
+ 	unsigned long flags;
+ 	int i;
+ 	struct {
+ 		u32 addr;
+ 		const char *str;
+ 	} fseq_regs[] = {
+ 		FSEQ_REG(FSEQ_ERROR_CODE),
+ 		FSEQ_REG(FSEQ_TOP_INIT_VERSION),
+ 		FSEQ_REG(FSEQ_CNVIO_INIT_VERSION),
+ 		FSEQ_REG(FSEQ_OTP_VERSION),
+ 		FSEQ_REG(FSEQ_TOP_CONTENT_VERSION),
+ 		FSEQ_REG(FSEQ_ALIVE_TOKEN),
+ 		FSEQ_REG(FSEQ_CNVI_ID),
+ 		FSEQ_REG(FSEQ_CNVR_ID),
+ 		FSEQ_REG(CNVI_AUX_MISC_CHIP),
+ 		FSEQ_REG(CNVR_AUX_MISC_CHIP),
+ 		FSEQ_REG(CNVR_SCU_SD_REGS_SD_REG_DIG_DCDC_VTRIM),
+ 		FSEQ_REG(CNVR_SCU_SD_REGS_SD_REG_ACTIVE_VDIG_MIRROR),
+ 	};
+ 
+ 	if (!iwl_trans_grab_nic_access(trans, &flags))
+ 		return;
+ 
+ 	IWL_ERR(fwrt, "Fseq Registers:\n");
+ 
+ 	for (i = 0; i < ARRAY_SIZE(fseq_regs); i++)
+ 		IWL_ERR(fwrt, "0x%08X | %s\n",
+ 			iwl_read_prph_no_grab(trans, fseq_regs[i].addr),
+ 			fseq_regs[i].str);
+ 
+ 	iwl_trans_release_nic_access(trans, &flags);
+ }
+ IWL_EXPORT_SYMBOL(iwl_fw_error_print_fseq_regs);
++>>>>>>> cc5470df4495 (iwlwifi: print fseq info upon fw assert)
diff --cc drivers/net/wireless/intel/iwlwifi/fw/dbg.h
index 507d9a49fa97,fd0ad220e961..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/fw/dbg.h
+++ b/drivers/net/wireless/intel/iwlwifi/fw/dbg.h
@@@ -263,4 -431,46 +263,49 @@@ static inline void iwl_fw_resume_timest
  
  #endif /* CONFIG_IWLWIFI_DEBUGFS */
  
++<<<<<<< HEAD
++=======
+ void iwl_fw_dbg_collect_sync(struct iwl_fw_runtime *fwrt);
+ void iwl_fw_dbg_apply_point(struct iwl_fw_runtime *fwrt,
+ 			    enum iwl_fw_ini_apply_point apply_point);
+ 
+ void iwl_fwrt_stop_device(struct iwl_fw_runtime *fwrt);
+ 
+ static inline void iwl_fw_lmac1_set_alive_err_table(struct iwl_trans *trans,
+ 						    u32 lmac_error_event_table)
+ {
+ 	if (!(trans->error_event_table_tlv_status &
+ 	      IWL_ERROR_EVENT_TABLE_LMAC1) ||
+ 	    WARN_ON(trans->lmac_error_event_table[0] !=
+ 		    lmac_error_event_table))
+ 		trans->lmac_error_event_table[0] = lmac_error_event_table;
+ }
+ 
+ static inline void iwl_fw_umac_set_alive_err_table(struct iwl_trans *trans,
+ 						   u32 umac_error_event_table)
+ {
+ 	if (!(trans->error_event_table_tlv_status &
+ 	      IWL_ERROR_EVENT_TABLE_UMAC) ||
+ 	    WARN_ON(trans->umac_error_event_table !=
+ 		    umac_error_event_table))
+ 		trans->umac_error_event_table = umac_error_event_table;
+ }
+ 
+ /* This bit is used to differentiate the legacy dump from the ini dump */
+ #define INI_DUMP_BIT BIT(31)
+ 
+ static inline void iwl_fw_error_collect(struct iwl_fw_runtime *fwrt)
+ {
+ 	if (fwrt->trans->ini_valid && fwrt->trans->hw_error) {
+ 		_iwl_fw_dbg_ini_collect(fwrt, IWL_FW_TRIGGER_ID_FW_HW_ERROR);
+ 		fwrt->trans->hw_error = false;
+ 	} else {
+ 		iwl_fw_dbg_collect_desc(fwrt, &iwl_dump_desc_assert, false, 0);
+ 	}
+ }
+ 
+ void iwl_fw_dbg_periodic_trig_handler(struct timer_list *t);
+ 
+ void iwl_fw_error_print_fseq_regs(struct iwl_fw_runtime *fwrt);
++>>>>>>> cc5470df4495 (iwlwifi: print fseq info upon fw assert)
  #endif  /* __iwl_fw_dbg_h__ */
diff --cc drivers/net/wireless/intel/iwlwifi/iwl-prph.h
index 421a869633a3,8d930bfe0727..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/iwl-prph.h
+++ b/drivers/net/wireless/intel/iwlwifi/iwl-prph.h
@@@ -425,4 -444,20 +429,23 @@@ enum 
  #define UREG_CHICK		(0xA05C00)
  #define UREG_CHICK_MSI_ENABLE	BIT(24)
  #define UREG_CHICK_MSIX_ENABLE	BIT(25)
++<<<<<<< HEAD
++=======
+ 
+ #define HPM_DEBUG			0xA03440
+ #define PERSISTENCE_BIT			BIT(12)
+ #define PREG_WFPM_ACCESS		BIT(12)
+ 
+ #define UREG_DOORBELL_TO_ISR6		0xA05C04
+ #define UREG_DOORBELL_TO_ISR6_NMI_BIT	BIT(0)
+ 
+ #define FSEQ_ERROR_CODE			0xA340C8
+ #define FSEQ_TOP_INIT_VERSION		0xA34038
+ #define FSEQ_CNVIO_INIT_VERSION		0xA3403C
+ #define FSEQ_OTP_VERSION		0xA340FC
+ #define FSEQ_TOP_CONTENT_VERSION	0xA340F4
+ #define FSEQ_ALIVE_TOKEN		0xA340F0
+ #define FSEQ_CNVI_ID			0xA3408C
+ #define FSEQ_CNVR_ID			0xA34090
++>>>>>>> cc5470df4495 (iwlwifi: print fseq info upon fw assert)
  #endif				/* __iwl_prph_h__ */
diff --cc drivers/net/wireless/intel/iwlwifi/pcie/trans.c
index a2a98087eb41,21da18af0155..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/pcie/trans.c
+++ b/drivers/net/wireless/intel/iwlwifi/pcie/trans.c
@@@ -3324,10 -3541,13 +3324,17 @@@ struct iwl_trans *iwl_trans_pcie_alloc(
  		if (iwl_trans_grab_nic_access(trans, &flags)) {
  			u32 hw_step;
  
 -			hw_step = iwl_read_umac_prph_no_grab(trans,
 -							     WFPM_CTRL_REG);
 +			hw_step = iwl_read_prph_no_grab(trans, WFPM_CTRL_REG);
  			hw_step |= ENABLE_WFPM;
++<<<<<<< HEAD
 +			iwl_write_prph_no_grab(trans, WFPM_CTRL_REG, hw_step);
 +			hw_step = iwl_read_prph_no_grab(trans, AUX_MISC_REG);
++=======
+ 			iwl_write_umac_prph_no_grab(trans, WFPM_CTRL_REG,
+ 						    hw_step);
+ 			hw_step = iwl_read_prph_no_grab(trans,
+ 							CNVI_AUX_MISC_CHIP);
++>>>>>>> cc5470df4495 (iwlwifi: print fseq info upon fw assert)
  			hw_step = (hw_step >> HW_STEP_LOCATION_BITS) & 0xF;
  			if (hw_step == 0x3)
  				trans->hw_rev = (trans->hw_rev & 0xFFFFFFF3) |
* Unmerged path drivers/net/wireless/intel/iwlwifi/fw/dbg.c
* Unmerged path drivers/net/wireless/intel/iwlwifi/fw/dbg.h
* Unmerged path drivers/net/wireless/intel/iwlwifi/iwl-prph.h
diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/utils.c b/drivers/net/wireless/intel/iwlwifi/mvm/utils.c
index 6a5349401aa9..8f89311ad14c 100644
--- a/drivers/net/wireless/intel/iwlwifi/mvm/utils.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/utils.c
@@ -603,6 +603,8 @@ void iwl_mvm_dump_nic_error_log(struct iwl_mvm *mvm)
 		iwl_mvm_dump_lmac_error_log(mvm, mvm->error_event_table[1]);
 
 	iwl_mvm_dump_umac_error_log(mvm);
+
+	iwl_fw_error_print_fseq_regs(&mvm->fwrt);
 }
 
 int iwl_mvm_find_free_queue(struct iwl_mvm *mvm, u8 sta_id, u8 minq, u8 maxq)
* Unmerged path drivers/net/wireless/intel/iwlwifi/pcie/trans.c
