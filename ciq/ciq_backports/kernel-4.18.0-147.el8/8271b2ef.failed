drm/i915: Track pipe csc enable in crtc state

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit 8271b2ef71aaabac452dc03a6cbe8960cbea4247
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/8271b2ef.failed

Just like we did for pipe gamma, let's also track the pipe csc
state. The hardware only exists on ILK+, and currently we always
enable it on hsw+ and never on any other platforms. Just like
with pipe gamma, the primary plane control register is used
for the readout on pre-SKL, and the pipe bottom color register
on SKL+.

v2: Rebase
v3: Allow fastboot with csc_enable changes (Maarten)
    Deal with HAS_GMCH

	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
	Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
	Reviewed-by: Uma Shankar <uma.shankar@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190207202146.26423-4-ville.syrjala@linux.intel.com
(cherry picked from commit 8271b2ef71aaabac452dc03a6cbe8960cbea4247)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/i915_reg.h
#	drivers/gpu/drm/i915/intel_color.c
#	drivers/gpu/drm/i915/intel_display.c
#	drivers/gpu/drm/i915/intel_drv.h
#	drivers/gpu/drm/i915/intel_sprite.c
diff --cc drivers/gpu/drm/i915/i915_reg.h
index 7720569f2024,11bf60d5e748..000000000000
--- a/drivers/gpu/drm/i915/i915_reg.h
+++ b/drivers/gpu/drm/i915/i915_reg.h
@@@ -5910,18 -6118,21 +5910,24 @@@ enum 
  #define   CURSOR_FORMAT_ARGB	(0x04 << CURSOR_FORMAT_SHIFT)
  #define   CURSOR_FORMAT_XRGB	(0x05 << CURSOR_FORMAT_SHIFT)
  /* New style CUR*CNTR flags */
 -#define   MCURSOR_MODE		0x27
 -#define   MCURSOR_MODE_DISABLE   0x00
 -#define   MCURSOR_MODE_128_32B_AX 0x02
 -#define   MCURSOR_MODE_256_32B_AX 0x03
 -#define   MCURSOR_MODE_64_32B_AX 0x07
 -#define   MCURSOR_MODE_128_ARGB_AX ((1 << 5) | MCURSOR_MODE_128_32B_AX)
 -#define   MCURSOR_MODE_256_ARGB_AX ((1 << 5) | MCURSOR_MODE_256_32B_AX)
 -#define   MCURSOR_MODE_64_ARGB_AX ((1 << 5) | MCURSOR_MODE_64_32B_AX)
 -#define   MCURSOR_PIPE_SELECT_MASK	(0x3 << 28)
 -#define   MCURSOR_PIPE_SELECT_SHIFT	28
 +#define   CURSOR_MODE		0x27
 +#define   CURSOR_MODE_DISABLE   0x00
 +#define   CURSOR_MODE_128_32B_AX 0x02
 +#define   CURSOR_MODE_256_32B_AX 0x03
 +#define   CURSOR_MODE_64_32B_AX 0x07
 +#define   CURSOR_MODE_128_ARGB_AX ((1 << 5) | CURSOR_MODE_128_32B_AX)
 +#define   CURSOR_MODE_256_ARGB_AX ((1 << 5) | CURSOR_MODE_256_32B_AX)
 +#define   CURSOR_MODE_64_ARGB_AX ((1 << 5) | CURSOR_MODE_64_32B_AX)
  #define   MCURSOR_PIPE_SELECT(pipe)	((pipe) << 28)
  #define   MCURSOR_GAMMA_ENABLE  (1 << 26)
++<<<<<<< HEAD
 +#define   CURSOR_ROTATE_180	(1<<15)
 +#define   CURSOR_TRICKLE_FEED_DISABLE	(1 << 14)
++=======
+ #define   MCURSOR_PIPE_CSC_ENABLE (1 << 24) /* ilk+ */
+ #define   MCURSOR_ROTATE_180	(1 << 15)
+ #define   MCURSOR_TRICKLE_FEED_DISABLE	(1 << 14)
++>>>>>>> 8271b2ef71aa (drm/i915: Track pipe csc enable in crtc state)
  #define _CURABASE		0x70084
  #define _CURAPOS		0x70088
  #define   CURSOR_POS_MASK       0x007FF
@@@ -5958,41 -6165,41 +5964,45 @@@
  
  /* Display A control */
  #define _DSPACNTR				0x70180
 -#define   DISPLAY_PLANE_ENABLE			(1 << 31)
 +#define   DISPLAY_PLANE_ENABLE			(1<<31)
  #define   DISPLAY_PLANE_DISABLE			0
 -#define   DISPPLANE_GAMMA_ENABLE		(1 << 30)
 +#define   DISPPLANE_GAMMA_ENABLE		(1<<30)
  #define   DISPPLANE_GAMMA_DISABLE		0
 -#define   DISPPLANE_PIXFORMAT_MASK		(0xf << 26)
 -#define   DISPPLANE_YUV422			(0x0 << 26)
 -#define   DISPPLANE_8BPP			(0x2 << 26)
 -#define   DISPPLANE_BGRA555			(0x3 << 26)
 -#define   DISPPLANE_BGRX555			(0x4 << 26)
 -#define   DISPPLANE_BGRX565			(0x5 << 26)
 -#define   DISPPLANE_BGRX888			(0x6 << 26)
 -#define   DISPPLANE_BGRA888			(0x7 << 26)
 -#define   DISPPLANE_RGBX101010			(0x8 << 26)
 -#define   DISPPLANE_RGBA101010			(0x9 << 26)
 -#define   DISPPLANE_BGRX101010			(0xa << 26)
 -#define   DISPPLANE_RGBX161616			(0xc << 26)
 -#define   DISPPLANE_RGBX888			(0xe << 26)
 -#define   DISPPLANE_RGBA888			(0xf << 26)
 -#define   DISPPLANE_STEREO_ENABLE		(1 << 25)
 +#define   DISPPLANE_PIXFORMAT_MASK		(0xf<<26)
 +#define   DISPPLANE_YUV422			(0x0<<26)
 +#define   DISPPLANE_8BPP			(0x2<<26)
 +#define   DISPPLANE_BGRA555			(0x3<<26)
 +#define   DISPPLANE_BGRX555			(0x4<<26)
 +#define   DISPPLANE_BGRX565			(0x5<<26)
 +#define   DISPPLANE_BGRX888			(0x6<<26)
 +#define   DISPPLANE_BGRA888			(0x7<<26)
 +#define   DISPPLANE_RGBX101010			(0x8<<26)
 +#define   DISPPLANE_RGBA101010			(0x9<<26)
 +#define   DISPPLANE_BGRX101010			(0xa<<26)
 +#define   DISPPLANE_RGBX161616			(0xc<<26)
 +#define   DISPPLANE_RGBX888			(0xe<<26)
 +#define   DISPPLANE_RGBA888			(0xf<<26)
 +#define   DISPPLANE_STEREO_ENABLE		(1<<25)
  #define   DISPPLANE_STEREO_DISABLE		0
++<<<<<<< HEAD
 +#define   DISPPLANE_PIPE_CSC_ENABLE		(1<<24)
++=======
+ #define   DISPPLANE_PIPE_CSC_ENABLE		(1 << 24) /* ilk+ */
++>>>>>>> 8271b2ef71aa (drm/i915: Track pipe csc enable in crtc state)
  #define   DISPPLANE_SEL_PIPE_SHIFT		24
 -#define   DISPPLANE_SEL_PIPE_MASK		(3 << DISPPLANE_SEL_PIPE_SHIFT)
 -#define   DISPPLANE_SEL_PIPE(pipe)		((pipe) << DISPPLANE_SEL_PIPE_SHIFT)
 -#define   DISPPLANE_SRC_KEY_ENABLE		(1 << 22)
 +#define   DISPPLANE_SEL_PIPE_MASK		(3<<DISPPLANE_SEL_PIPE_SHIFT)
 +#define   DISPPLANE_SEL_PIPE(pipe)		((pipe)<<DISPPLANE_SEL_PIPE_SHIFT)
 +#define   DISPPLANE_SRC_KEY_ENABLE		(1<<22)
  #define   DISPPLANE_SRC_KEY_DISABLE		0
 -#define   DISPPLANE_LINE_DOUBLE			(1 << 20)
 +#define   DISPPLANE_LINE_DOUBLE			(1<<20)
  #define   DISPPLANE_NO_LINE_DOUBLE		0
  #define   DISPPLANE_STEREO_POLARITY_FIRST	0
 -#define   DISPPLANE_STEREO_POLARITY_SECOND	(1 << 18)
 -#define   DISPPLANE_ALPHA_PREMULTIPLY		(1 << 16) /* CHV pipe B */
 -#define   DISPPLANE_ROTATE_180			(1 << 15)
 -#define   DISPPLANE_TRICKLE_FEED_DISABLE	(1 << 14) /* Ironlake */
 -#define   DISPPLANE_TILED			(1 << 10)
 -#define   DISPPLANE_MIRROR			(1 << 8) /* CHV pipe B */
 +#define   DISPPLANE_STEREO_POLARITY_SECOND	(1<<18)
 +#define   DISPPLANE_ALPHA_PREMULTIPLY		(1<<16) /* CHV pipe B */
 +#define   DISPPLANE_ROTATE_180			(1<<15)
 +#define   DISPPLANE_TRICKLE_FEED_DISABLE	(1<<14) /* Ironlake */
 +#define   DISPPLANE_TILED			(1<<10)
 +#define   DISPPLANE_MIRROR			(1<<8) /* CHV pipe B */
  #define _DSPAADDR				0x70184
  #define _DSPASTRIDE				0x70188
  #define _DSPAPOS				0x7018C /* reserved */
diff --cc drivers/gpu/drm/i915/intel_color.c
index c6a7beabd58d,e3bf3bd355ab..000000000000
--- a/drivers/gpu/drm/i915/intel_color.c
+++ b/drivers/gpu/drm/i915/intel_color.c
@@@ -352,47 -346,77 +352,55 @@@ static void i9xx_load_luts_internal(str
  	}
  }
  
 -static void i9xx_load_luts(const struct intel_crtc_state *crtc_state)
 -{
 -	i9xx_load_luts_internal(crtc_state, crtc_state->base.gamma_lut);
 -}
 -
 -static void i9xx_color_commit(const struct intel_crtc_state *crtc_state)
 -{
 -	struct intel_crtc *crtc = to_intel_crtc(crtc_state->base.crtc);
 -	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
 -	enum pipe pipe = crtc->pipe;
 -	u32 val;
 -
 -	val = I915_READ(PIPECONF(pipe));
 -	val &= ~PIPECONF_GAMMA_MODE_MASK_I9XX;
 -	val |= PIPECONF_GAMMA_MODE(crtc_state->gamma_mode);
 -	I915_WRITE(PIPECONF(pipe), val);
 -}
 -
 -static void ilk_color_commit(const struct intel_crtc_state *crtc_state)
 +static void i9xx_load_luts(struct drm_crtc_state *crtc_state)
  {
 -	struct intel_crtc *crtc = to_intel_crtc(crtc_state->base.crtc);
 -	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
 -	enum pipe pipe = crtc->pipe;
 -	u32 val;
 -
 -	val = I915_READ(PIPECONF(pipe));
 -	val &= ~PIPECONF_GAMMA_MODE_MASK_ILK;
 -	val |= PIPECONF_GAMMA_MODE(crtc_state->gamma_mode);
 -	I915_WRITE(PIPECONF(pipe), val);
 -}
 -
 -static void hsw_color_commit(const struct intel_crtc_state *crtc_state)
 -{
 -	struct intel_crtc *crtc = to_intel_crtc(crtc_state->base.crtc);
 -	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
 -
 -	I915_WRITE(GAMMA_MODE(crtc->pipe), crtc_state->gamma_mode);
 -
 -	ilk_load_csc_matrix(crtc_state);
 +	i9xx_load_luts_internal(crtc_state->crtc, crtc_state->gamma_lut,
 +				to_intel_crtc_state(crtc_state));
  }
  
 -static void skl_color_commit(const struct intel_crtc_state *crtc_state)
 +/* Loads the legacy palette/gamma unit for the CRTC on Haswell. */
 +static void haswell_load_luts(struct drm_crtc_state *crtc_state)
  {
 -	struct intel_crtc *crtc = to_intel_crtc(crtc_state->base.crtc);
 -	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
 -	enum pipe pipe = crtc->pipe;
 -	u32 val = 0;
 +	struct drm_crtc *crtc = crtc_state->crtc;
 +	struct drm_device *dev = crtc->dev;
 +	struct drm_i915_private *dev_priv = to_i915(dev);
 +	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
 +	struct intel_crtc_state *intel_crtc_state =
 +		to_intel_crtc_state(crtc_state);
 +	bool reenable_ips = false;
  
  	/*
 -	 * We don't (yet) allow userspace to control the pipe background color,
 -	 * so force it to black, but apply pipe gamma and CSC appropriately
 -	 * so that its handling will match how we program our planes.
 +	 * Workaround : Do not read or write the pipe palette/gamma data while
 +	 * GAMMA_MODE is configured for split gamma and IPS_CTL has IPS enabled.
  	 */
++<<<<<<< HEAD
 +	if (IS_HASWELL(dev_priv) && intel_crtc_state->ips_enabled &&
 +	    (intel_crtc_state->gamma_mode == GAMMA_MODE_MODE_SPLIT)) {
 +		hsw_disable_ips(intel_crtc_state);
 +		reenable_ips = true;
 +	}
++=======
+ 	if (crtc_state->gamma_enable)
+ 		val |= SKL_BOTTOM_COLOR_GAMMA_ENABLE;
+ 	if (crtc_state->csc_enable)
+ 		val |= SKL_BOTTOM_COLOR_CSC_ENABLE;
+ 	I915_WRITE(SKL_BOTTOM_COLOR(pipe), val);
++>>>>>>> 8271b2ef71aa (drm/i915: Track pipe csc enable in crtc state)
 +
 +	intel_crtc_state->gamma_mode = GAMMA_MODE_MODE_8BIT;
 +	I915_WRITE(GAMMA_MODE(intel_crtc->pipe), GAMMA_MODE_MODE_8BIT);
  
 -	I915_WRITE(GAMMA_MODE(crtc->pipe), crtc_state->gamma_mode);
 +	i9xx_load_luts(crtc_state);
  
 -	ilk_load_csc_matrix(crtc_state);
 +	if (reenable_ips)
 +		hsw_enable_ips(intel_crtc_state);
  }
  
 -static void bdw_load_degamma_lut(const struct intel_crtc_state *crtc_state)
 +static void bdw_load_degamma_lut(struct drm_crtc_state *state)
  {
 -	struct intel_crtc *crtc = to_intel_crtc(crtc_state->base.crtc);
 -	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
 -	const struct drm_property_blob *degamma_lut = crtc_state->base.degamma_lut;
 -	u32 i, lut_size = INTEL_INFO(dev_priv)->color.degamma_lut_size;
 -	enum pipe pipe = crtc->pipe;
 +	struct drm_i915_private *dev_priv = to_i915(state->crtc->dev);
 +	enum pipe pipe = to_intel_crtc(state->crtc)->pipe;
 +	uint32_t i, lut_size = INTEL_INFO(dev_priv)->color.degamma_lut_size;
  
  	I915_WRITE(PREC_PAL_INDEX(pipe),
  		   PAL_PREC_SPLIT_MODE | PAL_PREC_AUTO_INCREMENT);
@@@ -621,48 -664,66 +629,60 @@@ int intel_color_check(struct drm_crtc *
  
  	degamma_length = INTEL_INFO(dev_priv)->color.degamma_lut_size;
  	gamma_length = INTEL_INFO(dev_priv)->color.gamma_lut_size;
 -	degamma_tests = INTEL_INFO(dev_priv)->color.degamma_lut_tests;
 -	gamma_tests = INTEL_INFO(dev_priv)->color.gamma_lut_tests;
  
++<<<<<<< HEAD
 +	/*
 +	 * We allow both degamma & gamma luts at the right size or
 +	 * NULL.
 +	 */
 +	if ((!crtc_state->degamma_lut ||
 +	     drm_color_lut_size(crtc_state->degamma_lut) == degamma_length) &&
 +	    (!crtc_state->gamma_lut ||
 +	     drm_color_lut_size(crtc_state->gamma_lut) == gamma_length))
++=======
+ 	crtc_state->gamma_enable = true;
+ 
+ 	if (INTEL_GEN(dev_priv) >= 9 ||
+ 	    IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv))
+ 		crtc_state->csc_enable = true;
+ 
+ 	/* Always allow legacy gamma LUT with no further checking. */
+ 	if (crtc_state_is_legacy_gamma(crtc_state)) {
+ 		crtc_state->gamma_mode = GAMMA_MODE_MODE_8BIT;
++>>>>>>> 8271b2ef71aa (drm/i915: Track pipe csc enable in crtc state)
  		return 0;
 -	}
 -
 -	if (check_lut_size(degamma_lut, degamma_length) ||
 -	    check_lut_size(gamma_lut, gamma_length))
 -		return -EINVAL;
 -
 -	if (drm_color_lut_check(degamma_lut, degamma_tests) ||
 -	    drm_color_lut_check(gamma_lut, gamma_tests))
 -		return -EINVAL;
  
 -	if (INTEL_GEN(dev_priv) >= 10 || IS_GEMINILAKE(dev_priv))
 -		crtc_state->gamma_mode = GAMMA_MODE_MODE_10BIT;
 -	else if (INTEL_GEN(dev_priv) >= 9 || IS_BROADWELL(dev_priv))
 -		crtc_state->gamma_mode = GAMMA_MODE_MODE_SPLIT;
 -	else
 -		crtc_state->gamma_mode = GAMMA_MODE_MODE_8BIT;
 +	/*
 +	 * We also allow no degamma lut/ctm and a gamma lut at the legacy
 +	 * size (256 entries).
 +	 */
 +	if (crtc_state_is_legacy_gamma(crtc_state))
 +		return 0;
  
 -	return 0;
 +	return -EINVAL;
  }
  
 -void intel_color_init(struct intel_crtc *crtc)
 +void intel_color_init(struct drm_crtc *crtc)
  {
 -	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
 -
 -	drm_mode_crtc_set_gamma_size(&crtc->base, 256);
 -
 -	if (HAS_GMCH(dev_priv)) {
 -		if (IS_CHERRYVIEW(dev_priv))
 -			dev_priv->display.load_luts = cherryview_load_luts;
 -		else
 -			dev_priv->display.load_luts = i9xx_load_luts;
 -
 -		dev_priv->display.color_commit = i9xx_color_commit;
 +	struct drm_i915_private *dev_priv = to_i915(crtc->dev);
 +
 +	drm_mode_crtc_set_gamma_size(crtc, 256);
 +
 +	if (IS_CHERRYVIEW(dev_priv)) {
 +		dev_priv->display.load_csc_matrix = cherryview_load_csc_matrix;
 +		dev_priv->display.load_luts = cherryview_load_luts;
 +	} else if (IS_HASWELL(dev_priv)) {
 +		dev_priv->display.load_csc_matrix = ilk_load_csc_matrix;
 +		dev_priv->display.load_luts = haswell_load_luts;
 +	} else if (IS_BROADWELL(dev_priv) || IS_GEN9_BC(dev_priv) ||
 +		   IS_BROXTON(dev_priv)) {
 +		dev_priv->display.load_csc_matrix = ilk_load_csc_matrix;
 +		dev_priv->display.load_luts = broadwell_load_luts;
 +	} else if (IS_GEMINILAKE(dev_priv) || IS_CANNONLAKE(dev_priv)) {
 +		dev_priv->display.load_csc_matrix = ilk_load_csc_matrix;
 +		dev_priv->display.load_luts = glk_load_luts;
  	} else {
 -		if (IS_CANNONLAKE(dev_priv) || IS_GEMINILAKE(dev_priv))
 -			dev_priv->display.load_luts = glk_load_luts;
 -		else if (INTEL_GEN(dev_priv) >= 9 || IS_BROADWELL(dev_priv))
 -			dev_priv->display.load_luts = broadwell_load_luts;
 -		else
 -			dev_priv->display.load_luts = i9xx_load_luts;
 -
 -		if (INTEL_GEN(dev_priv) >= 9)
 -			dev_priv->display.color_commit = skl_color_commit;
 -		else if (IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv))
 -			dev_priv->display.color_commit = hsw_color_commit;
 -		else
 -			dev_priv->display.color_commit = ilk_color_commit;
 +		dev_priv->display.load_luts = i9xx_load_luts;
  	}
  
  	/* Enable color management support when we have degamma & gamma LUTs. */
diff --cc drivers/gpu/drm/i915/intel_display.c
index dec0d60921bf,78f46a94733d..000000000000
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@@ -3248,6 -3188,51 +3248,54 @@@ int skl_check_plane_surface(const struc
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ unsigned int
+ i9xx_plane_max_stride(struct intel_plane *plane,
+ 		      u32 pixel_format, u64 modifier,
+ 		      unsigned int rotation)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(plane->base.dev);
+ 
+ 	if (!HAS_GMCH(dev_priv)) {
+ 		return 32*1024;
+ 	} else if (INTEL_GEN(dev_priv) >= 4) {
+ 		if (modifier == I915_FORMAT_MOD_X_TILED)
+ 			return 16*1024;
+ 		else
+ 			return 32*1024;
+ 	} else if (INTEL_GEN(dev_priv) >= 3) {
+ 		if (modifier == I915_FORMAT_MOD_X_TILED)
+ 			return 8*1024;
+ 		else
+ 			return 16*1024;
+ 	} else {
+ 		if (plane->i9xx_plane == PLANE_C)
+ 			return 4*1024;
+ 		else
+ 			return 8*1024;
+ 	}
+ }
+ 
+ static u32 i9xx_plane_ctl_crtc(const struct intel_crtc_state *crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->base.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	u32 dspcntr = 0;
+ 
+ 	if (crtc_state->gamma_enable)
+ 		dspcntr |= DISPPLANE_GAMMA_ENABLE;
+ 
+ 	if (crtc_state->csc_enable)
+ 		dspcntr |= DISPPLANE_PIPE_CSC_ENABLE;
+ 
+ 	if (INTEL_GEN(dev_priv) < 5)
+ 		dspcntr |= DISPPLANE_SEL_PIPE(crtc->pipe);
+ 
+ 	return dspcntr;
+ }
+ 
++>>>>>>> 8271b2ef71aa (drm/i915: Track pipe csc enable in crtc state)
  static u32 i9xx_plane_ctl(const struct intel_crtc_state *crtc_state,
  			  const struct intel_plane_state *plane_state)
  {
@@@ -3632,6 -3694,23 +3680,26 @@@ static u32 cnl_plane_ctl_flip(unsigned 
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ u32 skl_plane_ctl_crtc(const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(crtc_state->base.crtc->dev);
+ 	u32 plane_ctl = 0;
+ 
+ 	if (INTEL_GEN(dev_priv) >= 10 || IS_GEMINILAKE(dev_priv))
+ 		return plane_ctl;
+ 
+ 	if (crtc_state->gamma_enable)
+ 		plane_ctl |= PLANE_CTL_PIPE_GAMMA_ENABLE;
+ 
+ 	if (crtc_state->csc_enable)
+ 		plane_ctl |= PLANE_CTL_PIPE_CSC_ENABLE;
+ 
+ 	return plane_ctl;
+ }
+ 
++>>>>>>> 8271b2ef71aa (drm/i915: Track pipe csc enable in crtc state)
  u32 skl_plane_ctl(const struct intel_crtc_state *crtc_state,
  		  const struct intel_plane_state *plane_state)
  {
@@@ -3674,6 -3750,23 +3742,26 @@@
  	return plane_ctl;
  }
  
++<<<<<<< HEAD
++=======
+ u32 glk_plane_color_ctl_crtc(const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(crtc_state->base.crtc->dev);
+ 	u32 plane_color_ctl = 0;
+ 
+ 	if (INTEL_GEN(dev_priv) >= 11)
+ 		return plane_color_ctl;
+ 
+ 	if (crtc_state->gamma_enable)
+ 		plane_color_ctl |= PLANE_COLOR_PIPE_GAMMA_ENABLE;
+ 
+ 	if (crtc_state->csc_enable)
+ 		plane_color_ctl |= PLANE_COLOR_PIPE_CSC_ENABLE;
+ 
+ 	return plane_color_ctl;
+ }
+ 
++>>>>>>> 8271b2ef71aa (drm/i915: Track pipe csc enable in crtc state)
  u32 glk_plane_color_ctl(const struct intel_crtc_state *crtc_state,
  			const struct intel_plane_state *plane_state)
  {
@@@ -7775,6 -8055,67 +7863,70 @@@ static void chv_crtc_clock_get(struct i
  	pipe_config->port_clock = chv_calc_dpll_params(refclk, &clock);
  }
  
++<<<<<<< HEAD
++=======
+ static void intel_get_crtc_ycbcr_config(struct intel_crtc *crtc,
+ 					struct intel_crtc_state *pipe_config)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	enum intel_output_format output = INTEL_OUTPUT_FORMAT_RGB;
+ 
+ 	pipe_config->lspcon_downsampling = false;
+ 
+ 	if (IS_BROADWELL(dev_priv) || INTEL_GEN(dev_priv) >= 9) {
+ 		u32 tmp = I915_READ(PIPEMISC(crtc->pipe));
+ 
+ 		if (tmp & PIPEMISC_OUTPUT_COLORSPACE_YUV) {
+ 			bool ycbcr420_enabled = tmp & PIPEMISC_YUV420_ENABLE;
+ 			bool blend = tmp & PIPEMISC_YUV420_MODE_FULL_BLEND;
+ 
+ 			if (ycbcr420_enabled) {
+ 				/* We support 4:2:0 in full blend mode only */
+ 				if (!blend)
+ 					output = INTEL_OUTPUT_FORMAT_INVALID;
+ 				else if (!(IS_GEMINILAKE(dev_priv) ||
+ 					   INTEL_GEN(dev_priv) >= 10))
+ 					output = INTEL_OUTPUT_FORMAT_INVALID;
+ 				else
+ 					output = INTEL_OUTPUT_FORMAT_YCBCR420;
+ 			} else {
+ 				/*
+ 				 * Currently there is no interface defined to
+ 				 * check user preference between RGB/YCBCR444
+ 				 * or YCBCR420. So the only possible case for
+ 				 * YCBCR444 usage is driving YCBCR420 output
+ 				 * with LSPCON, when pipe is configured for
+ 				 * YCBCR444 output and LSPCON takes care of
+ 				 * downsampling it.
+ 				 */
+ 				pipe_config->lspcon_downsampling = true;
+ 				output = INTEL_OUTPUT_FORMAT_YCBCR444;
+ 			}
+ 		}
+ 	}
+ 
+ 	pipe_config->output_format = output;
+ }
+ 
+ static void i9xx_get_pipe_color_config(struct intel_crtc_state *crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->base.crtc);
+ 	struct intel_plane *plane = to_intel_plane(crtc->base.primary);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	enum i9xx_plane_id i9xx_plane = plane->i9xx_plane;
+ 	u32 tmp;
+ 
+ 	tmp = I915_READ(DSPCNTR(i9xx_plane));
+ 
+ 	if (tmp & DISPPLANE_GAMMA_ENABLE)
+ 		crtc_state->gamma_enable = true;
+ 
+ 	if (!HAS_GMCH(dev_priv) &&
+ 	    tmp & DISPPLANE_PIPE_CSC_ENABLE)
+ 		crtc_state->csc_enable = true;
+ }
+ 
++>>>>>>> 8271b2ef71aa (drm/i915: Track pipe csc enable in crtc state)
  static bool i9xx_get_pipe_config(struct intel_crtc *crtc,
  				 struct intel_crtc_state *pipe_config)
  {
@@@ -9429,21 -9880,16 +9581,31 @@@ static bool haswell_get_pipe_config(str
  	pipe_config->gamma_mode =
  		I915_READ(GAMMA_MODE(crtc->pipe)) & GAMMA_MODE_MODE_MASK;
  
 -	if (INTEL_GEN(dev_priv) >= 9) {
 -		u32 tmp = I915_READ(SKL_BOTTOM_COLOR(crtc->pipe));
 -
 +	if (IS_BROADWELL(dev_priv) || INTEL_GEN(dev_priv) >= 9) {
 +		u32 tmp = I915_READ(PIPEMISC(crtc->pipe));
 +		bool clrspace_yuv = tmp & PIPEMISC_OUTPUT_COLORSPACE_YUV;
 +
++<<<<<<< HEAD
 +		if (IS_GEMINILAKE(dev_priv) || INTEL_GEN(dev_priv) >= 10) {
 +			bool blend_mode_420 = tmp &
 +					      PIPEMISC_YUV420_MODE_FULL_BLEND;
 +
 +			pipe_config->ycbcr420 = tmp & PIPEMISC_YUV420_ENABLE;
 +			if (pipe_config->ycbcr420 != clrspace_yuv ||
 +			    pipe_config->ycbcr420 != blend_mode_420)
 +				DRM_DEBUG_KMS("Bad 4:2:0 mode (%08x)\n", tmp);
 +		} else if (clrspace_yuv) {
 +			DRM_DEBUG_KMS("YCbCr 4:2:0 Unsupported\n");
 +		}
++=======
+ 		if (tmp & SKL_BOTTOM_COLOR_GAMMA_ENABLE)
+ 			pipe_config->gamma_enable = true;
+ 
+ 		if (tmp & SKL_BOTTOM_COLOR_CSC_ENABLE)
+ 			pipe_config->csc_enable = true;
+ 	} else {
+ 		i9xx_get_pipe_color_config(pipe_config);
++>>>>>>> 8271b2ef71aa (drm/i915: Track pipe csc enable in crtc state)
  	}
  
  	power_domain = POWER_DOMAIN_PIPE_PANEL_FITTER(crtc->pipe);
@@@ -9709,6 -10204,35 +9871,38 @@@ static bool i845_cursor_get_hw_state(st
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static unsigned int
+ i9xx_cursor_max_stride(struct intel_plane *plane,
+ 		       u32 pixel_format, u64 modifier,
+ 		       unsigned int rotation)
+ {
+ 	return plane->base.dev->mode_config.cursor_width * 4;
+ }
+ 
+ static u32 i9xx_cursor_ctl_crtc(const struct intel_crtc_state *crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->base.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	u32 cntl = 0;
+ 
+ 	if (INTEL_GEN(dev_priv) >= 11)
+ 		return cntl;
+ 
+ 	if (crtc_state->gamma_enable)
+ 		cntl = MCURSOR_GAMMA_ENABLE;
+ 
+ 	if (crtc_state->csc_enable)
+ 		cntl |= MCURSOR_PIPE_CSC_ENABLE;
+ 
+ 	if (INTEL_GEN(dev_priv) < 5 && !IS_G4X(dev_priv))
+ 		cntl |= MCURSOR_PIPE_SELECT(crtc->pipe);
+ 
+ 	return cntl;
+ }
+ 
++>>>>>>> 8271b2ef71aa (drm/i915: Track pipe csc enable in crtc state)
  static u32 i9xx_cursor_ctl(const struct intel_crtc_state *crtc_state,
  			   const struct intel_plane_state *plane_state)
  {
@@@ -11427,6 -12121,10 +11621,13 @@@ intel_pipe_config_compare(struct drm_i9
  
  		PIPE_CONF_CHECK_I(scaler_state.scaler_id);
  		PIPE_CONF_CHECK_CLOCK_FUZZY(pixel_rate);
++<<<<<<< HEAD
++=======
+ 
+ 		PIPE_CONF_CHECK_X(gamma_mode);
+ 		PIPE_CONF_CHECK_BOOL(gamma_enable);
+ 		PIPE_CONF_CHECK_BOOL(csc_enable);
++>>>>>>> 8271b2ef71aa (drm/i915: Track pipe csc enable in crtc state)
  	}
  
  	PIPE_CONF_CHECK_BOOL(double_wide);
diff --cc drivers/gpu/drm/i915/intel_drv.h
index b8eefbffc77d,37e9542994d4..000000000000
--- a/drivers/gpu/drm/i915/intel_drv.h
+++ b/drivers/gpu/drm/i915/intel_drv.h
@@@ -897,8 -954,29 +897,34 @@@ struct intel_crtc_state 
  	/* HDMI High TMDS char rate ratio */
  	bool hdmi_high_tmds_clock_ratio;
  
++<<<<<<< HEAD
 +	/* output format is YCBCR 4:2:0 */
 +	bool ycbcr420;
++=======
+ 	/* Output format RGB/YCBCR etc */
+ 	enum intel_output_format output_format;
+ 
+ 	/* Output down scaling is done in LSPCON device */
+ 	bool lspcon_downsampling;
+ 
+ 	/* enable pipe gamma? */
+ 	bool gamma_enable;
+ 
+ 	/* enable pipe csc? */
+ 	bool csc_enable;
+ 
+ 	/* Display Stream compression state */
+ 	struct {
+ 		bool compression_enable;
+ 		bool dsc_split;
+ 		u16 compressed_bpp;
+ 		u8 slice_count;
+ 	} dsc_params;
+ 	struct drm_dsc_config dp_dsc_cfg;
+ 
+ 	/* Forward Error correction State */
+ 	bool fec_enable;
++>>>>>>> 8271b2ef71aa (drm/i915: Track pipe csc enable in crtc state)
  };
  
  struct intel_crtc {
diff --cc drivers/gpu/drm/i915/intel_sprite.c
index ee23613f9fd4,610398607e8e..000000000000
--- a/drivers/gpu/drm/i915/intel_sprite.c
+++ b/drivers/gpu/drm/i915/intel_sprite.c
@@@ -607,6 -919,19 +607,22 @@@ vlv_plane_get_hw_state(struct intel_pla
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static u32 ivb_sprite_ctl_crtc(const struct intel_crtc_state *crtc_state)
+ {
+ 	u32 sprctl = 0;
+ 
+ 	if (crtc_state->gamma_enable)
+ 		sprctl |= SPRITE_GAMMA_ENABLE;
+ 
+ 	if (crtc_state->csc_enable)
+ 		sprctl |= SPRITE_PIPE_CSC_ENABLE;
+ 
+ 	return sprctl;
+ }
+ 
++>>>>>>> 8271b2ef71aa (drm/i915: Track pipe csc enable in crtc state)
  static u32 ivb_sprite_ctl(const struct intel_crtc_state *crtc_state,
  			  const struct intel_plane_state *plane_state)
  {
@@@ -772,6 -1102,27 +788,30 @@@ ivb_plane_get_hw_state(struct intel_pla
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static unsigned int
+ g4x_sprite_max_stride(struct intel_plane *plane,
+ 		      u32 pixel_format, u64 modifier,
+ 		      unsigned int rotation)
+ {
+ 	return 16384;
+ }
+ 
+ static u32 g4x_sprite_ctl_crtc(const struct intel_crtc_state *crtc_state)
+ {
+ 	u32 dvscntr = 0;
+ 
+ 	if (crtc_state->gamma_enable)
+ 		dvscntr |= DVS_GAMMA_ENABLE;
+ 
+ 	if (crtc_state->csc_enable)
+ 		dvscntr |= DVS_PIPE_CSC_ENABLE;
+ 
+ 	return dvscntr;
+ }
+ 
++>>>>>>> 8271b2ef71aa (drm/i915: Track pipe csc enable in crtc state)
  static u32 g4x_sprite_ctl(const struct intel_crtc_state *crtc_state,
  			  const struct intel_plane_state *plane_state)
  {
* Unmerged path drivers/gpu/drm/i915/i915_reg.h
* Unmerged path drivers/gpu/drm/i915/intel_color.c
* Unmerged path drivers/gpu/drm/i915/intel_display.c
* Unmerged path drivers/gpu/drm/i915/intel_drv.h
* Unmerged path drivers/gpu/drm/i915/intel_sprite.c
