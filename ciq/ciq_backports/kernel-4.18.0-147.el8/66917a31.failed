fanotify: introduce new event mask FAN_OPEN_EXEC_PERM

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Matthew Bobrowski <mbobrowski@mbobrowski.org>
commit 66917a3130f218dcef9eeab4fd11a71cd00cd7c9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/66917a31.failed

A new event mask FAN_OPEN_EXEC_PERM has been defined. This allows users
to receive events and grant access to files that are intending to be
opened for execution. Events of FAN_OPEN_EXEC_PERM type will be
generated when a file has been opened by using either execve(),
execveat() or uselib() system calls.

This acts in the same manner as previous permission event mask, meaning
that an access response is required from the user application in order
to permit any further operations on the file.

	Signed-off-by: Matthew Bobrowski <mbobrowski@mbobrowski.org>
	Reviewed-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
(cherry picked from commit 66917a3130f218dcef9eeab4fd11a71cd00cd7c9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/notify/fanotify/fanotify.c
#	fs/notify/fsnotify.c
#	include/linux/fanotify.h
#	include/linux/fsnotify_backend.h
diff --cc fs/notify/fanotify/fanotify.c
index cdce46db0d71,3723f3d18d20..000000000000
--- a/fs/notify/fanotify/fanotify.c
+++ b/fs/notify/fanotify/fanotify.c
@@@ -198,8 -210,13 +198,18 @@@ static int fanotify_handle_event(struc
  	BUILD_BUG_ON(FAN_OPEN_PERM != FS_OPEN_PERM);
  	BUILD_BUG_ON(FAN_ACCESS_PERM != FS_ACCESS_PERM);
  	BUILD_BUG_ON(FAN_ONDIR != FS_ISDIR);
++<<<<<<< HEAD
 +
 +	if (!fanotify_should_send_event(iter_info, mask, data, data_type))
++=======
+ 	BUILD_BUG_ON(FAN_OPEN_EXEC != FS_OPEN_EXEC);
+ 	BUILD_BUG_ON(FAN_OPEN_EXEC_PERM != FS_OPEN_EXEC_PERM);
+ 
+ 	BUILD_BUG_ON(HWEIGHT32(ALL_FANOTIFY_EVENT_BITS) != 12);
+ 
+ 	mask = fanotify_group_event_mask(iter_info, mask, data, data_type);
+ 	if (!mask)
++>>>>>>> 66917a3130f2 (fanotify: introduce new event mask FAN_OPEN_EXEC_PERM)
  		return 0;
  
  	pr_debug("%s: group=%p inode=%p mask=%x\n", __func__, group, inode,
diff --cc fs/notify/fsnotify.c
index dff7a35ba887,ecf09b6243d9..000000000000
--- a/fs/notify/fsnotify.c
+++ b/fs/notify/fsnotify.c
@@@ -392,7 -401,7 +392,11 @@@ static __init int fsnotify_init(void
  {
  	int ret;
  
++<<<<<<< HEAD
 +	BUILD_BUG_ON(HWEIGHT32(ALL_FSNOTIFY_BITS) != 23);
++=======
+ 	BUILD_BUG_ON(HWEIGHT32(ALL_FSNOTIFY_BITS) != 25);
++>>>>>>> 66917a3130f2 (fanotify: introduce new event mask FAN_OPEN_EXEC_PERM)
  
  	ret = init_srcu_struct(&fsnotify_mark_srcu);
  	if (ret)
diff --cc include/linux/fanotify.h
index e70fccc3757e,9e2142795335..000000000000
--- a/include/linux/fanotify.h
+++ b/include/linux/fanotify.h
@@@ -10,4 -7,59 +10,62 @@@
  #define FAN_GROUP_FLAG(group, flag) \
  	((group)->fanotify_data.flags & (flag))
  
++<<<<<<< HEAD
++=======
+ /*
+  * Flags allowed to be passed from/to userspace.
+  *
+  * We intentionally do not add new bits to the old FAN_ALL_* constants, because
+  * they are uapi exposed constants. If there are programs out there using
+  * these constant, the programs may break if re-compiled with new uapi headers
+  * and then run on an old kernel.
+  */
+ #define FANOTIFY_CLASS_BITS	(FAN_CLASS_NOTIF | FAN_CLASS_CONTENT | \
+ 				 FAN_CLASS_PRE_CONTENT)
+ 
+ #define FANOTIFY_INIT_FLAGS	(FANOTIFY_CLASS_BITS | \
+ 				 FAN_REPORT_TID | \
+ 				 FAN_CLOEXEC | FAN_NONBLOCK | \
+ 				 FAN_UNLIMITED_QUEUE | FAN_UNLIMITED_MARKS)
+ 
+ #define FANOTIFY_MARK_TYPE_BITS	(FAN_MARK_INODE | FAN_MARK_MOUNT | \
+ 				 FAN_MARK_FILESYSTEM)
+ 
+ #define FANOTIFY_MARK_FLAGS	(FANOTIFY_MARK_TYPE_BITS | \
+ 				 FAN_MARK_ADD | \
+ 				 FAN_MARK_REMOVE | \
+ 				 FAN_MARK_DONT_FOLLOW | \
+ 				 FAN_MARK_ONLYDIR | \
+ 				 FAN_MARK_IGNORED_MASK | \
+ 				 FAN_MARK_IGNORED_SURV_MODIFY | \
+ 				 FAN_MARK_FLUSH)
+ 
+ /* Events that user can request to be notified on */
+ #define FANOTIFY_EVENTS		(FAN_ACCESS | FAN_MODIFY | \
+ 				 FAN_CLOSE | FAN_OPEN | FAN_OPEN_EXEC)
+ 
+ /* Events that require a permission response from user */
+ #define FANOTIFY_PERM_EVENTS	(FAN_OPEN_PERM | FAN_ACCESS_PERM | \
+ 				 FAN_OPEN_EXEC_PERM)
+ 
+ /* Extra flags that may be reported with event or control handling of events */
+ #define FANOTIFY_EVENT_FLAGS	(FAN_EVENT_ON_CHILD | FAN_ONDIR)
+ 
+ /* Events that may be reported to user */
+ #define FANOTIFY_OUTGOING_EVENTS	(FANOTIFY_EVENTS | \
+ 					 FANOTIFY_PERM_EVENTS | \
+ 					 FAN_Q_OVERFLOW)
+ 
+ #define ALL_FANOTIFY_EVENT_BITS		(FANOTIFY_OUTGOING_EVENTS | \
+ 					 FANOTIFY_EVENT_FLAGS)
+ 
+ /* Do not use these old uapi constants internally */
+ #undef FAN_ALL_CLASS_BITS
+ #undef FAN_ALL_INIT_FLAGS
+ #undef FAN_ALL_MARK_FLAGS
+ #undef FAN_ALL_EVENTS
+ #undef FAN_ALL_PERM_EVENTS
+ #undef FAN_ALL_OUTGOING_EVENTS
+ 
++>>>>>>> 66917a3130f2 (fanotify: introduce new event mask FAN_OPEN_EXEC_PERM)
  #endif /* _LINUX_FANOTIFY_H */
diff --cc include/linux/fsnotify_backend.h
index 7780a1a2c141,7639774e7475..000000000000
--- a/include/linux/fsnotify_backend.h
+++ b/include/linux/fsnotify_backend.h
@@@ -62,7 -64,8 +63,12 @@@
  #define FS_EVENTS_POSS_ON_CHILD   (FS_ACCESS | FS_MODIFY | FS_ATTRIB |\
  				   FS_CLOSE_WRITE | FS_CLOSE_NOWRITE | FS_OPEN |\
  				   FS_MOVED_FROM | FS_MOVED_TO | FS_CREATE |\
++<<<<<<< HEAD
 +				   FS_DELETE | FS_OPEN_PERM | FS_ACCESS_PERM)
++=======
+ 				   FS_DELETE | FS_OPEN_PERM | FS_ACCESS_PERM | \
+ 				   FS_OPEN_EXEC | FS_OPEN_EXEC_PERM)
++>>>>>>> 66917a3130f2 (fanotify: introduce new event mask FAN_OPEN_EXEC_PERM)
  
  #define FS_MOVE			(FS_MOVED_FROM | FS_MOVED_TO)
  
@@@ -74,7 -78,8 +81,12 @@@
  			     FS_MOVED_FROM | FS_MOVED_TO | FS_CREATE | \
  			     FS_DELETE | FS_DELETE_SELF | FS_MOVE_SELF | \
  			     FS_UNMOUNT | FS_Q_OVERFLOW | FS_IN_IGNORED | \
++<<<<<<< HEAD
 +			     FS_OPEN_PERM | FS_ACCESS_PERM | FS_DN_RENAME)
++=======
+ 			     FS_OPEN_PERM | FS_ACCESS_PERM | FS_DN_RENAME | \
+ 			     FS_OPEN_EXEC | FS_OPEN_EXEC_PERM)
++>>>>>>> 66917a3130f2 (fanotify: introduce new event mask FAN_OPEN_EXEC_PERM)
  
  /* Extra flags that may be reported with event or control handling of events */
  #define ALL_FSNOTIFY_FLAGS  (FS_EXCL_UNLINK | FS_ISDIR | FS_IN_ONESHOT | \
* Unmerged path fs/notify/fanotify/fanotify.c
* Unmerged path fs/notify/fsnotify.c
* Unmerged path include/linux/fanotify.h
diff --git a/include/linux/fsnotify.h b/include/linux/fsnotify.h
index 3f1a8af72a24..aaec98517b51 100644
--- a/include/linux/fsnotify.h
+++ b/include/linux/fsnotify.h
@@ -40,9 +40,10 @@ static inline int fsnotify_path(struct inode *inode, const struct path *path,
 	return fsnotify(inode, mask, path, FSNOTIFY_EVENT_PATH, NULL, 0);
 }
 
-/* simple call site for access decisions */
+/* Simple call site for access decisions */
 static inline int fsnotify_perm(struct file *file, int mask)
 {
+	int ret;
 	const struct path *path = &file->f_path;
 	struct inode *inode = file_inode(file);
 	__u32 fsnotify_mask = 0;
@@ -51,12 +52,18 @@ static inline int fsnotify_perm(struct file *file, int mask)
 		return 0;
 	if (!(mask & (MAY_READ | MAY_OPEN)))
 		return 0;
-	if (mask & MAY_OPEN)
+	if (mask & MAY_OPEN) {
 		fsnotify_mask = FS_OPEN_PERM;
-	else if (mask & MAY_READ)
+
+		if (file->f_flags & __FMODE_EXEC) {
+			ret = fsnotify_path(inode, path, FS_OPEN_EXEC_PERM);
+
+			if (ret)
+				return ret;
+		}
+	} else if (mask & MAY_READ) {
 		fsnotify_mask = FS_ACCESS_PERM;
-	else
-		BUG();
+	}
 
 	return fsnotify_path(inode, path, fsnotify_mask);
 }
* Unmerged path include/linux/fsnotify_backend.h
diff --git a/include/uapi/linux/fanotify.h b/include/uapi/linux/fanotify.h
index 74247917de04..4b01cd3ba11f 100644
--- a/include/uapi/linux/fanotify.h
+++ b/include/uapi/linux/fanotify.h
@@ -15,6 +15,7 @@
 
 #define FAN_OPEN_PERM		0x00010000	/* File open in perm check */
 #define FAN_ACCESS_PERM		0x00020000	/* File accessed in perm check */
+#define FAN_OPEN_EXEC_PERM	0x00040000	/* File open/exec in perm check */
 
 #define FAN_ONDIR		0x40000000	/* event occurred against dir */
 
