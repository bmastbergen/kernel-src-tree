bpf: enable cgroup local storage map pretty print with kind_flag

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Yonghong Song <yhs@fb.com>
commit ffa0c1cf59596fba54546ea828305acfcc2cf55e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/ffa0c1cf.failed

Commit 970289fc0a83 ("bpf: add bpffs pretty print for cgroup
local storage maps") added bpffs pretty print for cgroup
local storage maps. The commit worked for struct without kind_flag
set.

This patch refactored and made pretty print also work
with kind_flag set for the struct.

	Acked-by: Martin KaFai Lau <kafai@fb.com>
	Signed-off-by: Yonghong Song <yhs@fb.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit ffa0c1cf59596fba54546ea828305acfcc2cf55e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/btf.h
#	kernel/bpf/btf.c
#	kernel/bpf/local_storage.c
diff --cc include/linux/btf.h
index e076c4697049,12502e25e767..000000000000
--- a/include/linux/btf.h
+++ b/include/linux/btf.h
@@@ -46,5 -47,24 +47,27 @@@ void btf_type_seq_show(const struct bt
  		       struct seq_file *m);
  int btf_get_fd_by_id(u32 id);
  u32 btf_id(const struct btf *btf);
++<<<<<<< HEAD
++=======
+ bool btf_member_is_reg_int(const struct btf *btf, const struct btf_type *s,
+ 			   const struct btf_member *m,
+ 			   u32 expected_offset, u32 expected_size);
+ 
+ #ifdef CONFIG_BPF_SYSCALL
+ const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id);
+ const char *btf_name_by_offset(const struct btf *btf, u32 offset);
+ #else
+ static inline const struct btf_type *btf_type_by_id(const struct btf *btf,
+ 						    u32 type_id)
+ {
+ 	return NULL;
+ }
+ static inline const char *btf_name_by_offset(const struct btf *btf,
+ 					     u32 offset)
+ {
+ 	return NULL;
+ }
+ #endif
++>>>>>>> ffa0c1cf5959 (bpf: enable cgroup local storage map pretty print with kind_flag)
  
  #endif
diff --cc kernel/bpf/btf.c
index 0357a9e2e51e,e804b26a0506..000000000000
--- a/kernel/bpf/btf.c
+++ b/kernel/bpf/btf.c
@@@ -514,6 -545,47 +514,50 @@@ static bool btf_type_int_is_regular(con
  	return true;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Check that given struct member is a regular int with expected
+  * offset and size.
+  */
+ bool btf_member_is_reg_int(const struct btf *btf, const struct btf_type *s,
+ 			   const struct btf_member *m,
+ 			   u32 expected_offset, u32 expected_size)
+ {
+ 	const struct btf_type *t;
+ 	u32 id, int_data;
+ 	u8 nr_bits;
+ 
+ 	id = m->type;
+ 	t = btf_type_id_size(btf, &id, NULL);
+ 	if (!t || !btf_type_is_int(t))
+ 		return false;
+ 
+ 	int_data = btf_type_int(t);
+ 	nr_bits = BTF_INT_BITS(int_data);
+ 	if (btf_type_kflag(s)) {
+ 		u32 bitfield_size = BTF_MEMBER_BITFIELD_SIZE(m->offset);
+ 		u32 bit_offset = BTF_MEMBER_BIT_OFFSET(m->offset);
+ 
+ 		/* if kflag set, int should be a regular int and
+ 		 * bit offset should be at byte boundary.
+ 		 */
+ 		return !bitfield_size &&
+ 		       BITS_ROUNDUP_BYTES(bit_offset) == expected_offset &&
+ 		       BITS_ROUNDUP_BYTES(nr_bits) == expected_size;
+ 	}
+ 
+ 	if (BTF_INT_OFFSET(int_data) ||
+ 	    BITS_PER_BYTE_MASKED(m->offset) ||
+ 	    BITS_ROUNDUP_BYTES(m->offset) != expected_offset ||
+ 	    BITS_PER_BYTE_MASKED(nr_bits) ||
+ 	    BITS_ROUNDUP_BYTES(nr_bits) != expected_size)
+ 		return false;
+ 
+ 	return true;
+ }
+ 
++>>>>>>> ffa0c1cf5959 (bpf: enable cgroup local storage map pretty print with kind_flag)
  __printf(2, 3) static void __btf_verifier_log(struct bpf_verifier_log *log,
  					      const char *fmt, ...)
  {
diff --cc kernel/bpf/local_storage.c
index b65017dead44,07a34ef562a0..000000000000
--- a/kernel/bpf/local_storage.c
+++ b/kernel/bpf/local_storage.c
@@@ -308,6 -310,85 +308,88 @@@ static int cgroup_storage_delete_elem(s
  	return -EINVAL;
  }
  
++<<<<<<< HEAD
++=======
+ static int cgroup_storage_check_btf(const struct bpf_map *map,
+ 				    const struct btf *btf,
+ 				    const struct btf_type *key_type,
+ 				    const struct btf_type *value_type)
+ {
+ 	struct btf_member *m;
+ 	u32 offset, size;
+ 
+ 	/* Key is expected to be of struct bpf_cgroup_storage_key type,
+ 	 * which is:
+ 	 * struct bpf_cgroup_storage_key {
+ 	 *	__u64	cgroup_inode_id;
+ 	 *	__u32	attach_type;
+ 	 * };
+ 	 */
+ 
+ 	/*
+ 	 * Key_type must be a structure with two fields.
+ 	 */
+ 	if (BTF_INFO_KIND(key_type->info) != BTF_KIND_STRUCT ||
+ 	    BTF_INFO_VLEN(key_type->info) != 2)
+ 		return -EINVAL;
+ 
+ 	/*
+ 	 * The first field must be a 64 bit integer at 0 offset.
+ 	 */
+ 	m = (struct btf_member *)(key_type + 1);
+ 	size = FIELD_SIZEOF(struct bpf_cgroup_storage_key, cgroup_inode_id);
+ 	if (!btf_member_is_reg_int(btf, key_type, m, 0, size))
+ 		return -EINVAL;
+ 
+ 	/*
+ 	 * The second field must be a 32 bit integer at 64 bit offset.
+ 	 */
+ 	m++;
+ 	offset = offsetof(struct bpf_cgroup_storage_key, attach_type);
+ 	size = FIELD_SIZEOF(struct bpf_cgroup_storage_key, attach_type);
+ 	if (!btf_member_is_reg_int(btf, key_type, m, offset, size))
+ 		return -EINVAL;
+ 
+ 	return 0;
+ }
+ 
+ static void cgroup_storage_seq_show_elem(struct bpf_map *map, void *_key,
+ 					 struct seq_file *m)
+ {
+ 	enum bpf_cgroup_storage_type stype = cgroup_storage_type(map);
+ 	struct bpf_cgroup_storage_key *key = _key;
+ 	struct bpf_cgroup_storage *storage;
+ 	int cpu;
+ 
+ 	rcu_read_lock();
+ 	storage = cgroup_storage_lookup(map_to_storage(map), key, false);
+ 	if (!storage) {
+ 		rcu_read_unlock();
+ 		return;
+ 	}
+ 
+ 	btf_type_seq_show(map->btf, map->btf_key_type_id, key, m);
+ 	stype = cgroup_storage_type(map);
+ 	if (stype == BPF_CGROUP_STORAGE_SHARED) {
+ 		seq_puts(m, ": ");
+ 		btf_type_seq_show(map->btf, map->btf_value_type_id,
+ 				  &READ_ONCE(storage->buf)->data[0], m);
+ 		seq_puts(m, "\n");
+ 	} else {
+ 		seq_puts(m, ": {\n");
+ 		for_each_possible_cpu(cpu) {
+ 			seq_printf(m, "\tcpu%d: ", cpu);
+ 			btf_type_seq_show(map->btf, map->btf_value_type_id,
+ 					  per_cpu_ptr(storage->percpu_buf, cpu),
+ 					  m);
+ 			seq_puts(m, "\n");
+ 		}
+ 		seq_puts(m, "}\n");
+ 	}
+ 	rcu_read_unlock();
+ }
+ 
++>>>>>>> ffa0c1cf5959 (bpf: enable cgroup local storage map pretty print with kind_flag)
  const struct bpf_map_ops cgroup_storage_map_ops = {
  	.map_alloc = cgroup_storage_map_alloc,
  	.map_free = cgroup_storage_map_free,
* Unmerged path include/linux/btf.h
* Unmerged path kernel/bpf/btf.c
* Unmerged path kernel/bpf/local_storage.c
