btf: extract BTF type size calculation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit 69eaab04c675ef2d0127a80b3395aa90dfd1061f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/69eaab04.failed

This pre-patch extracts calculation of amount of space taken by BTF type descriptor
for later reuse by btf_dedup functionality.

	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit 69eaab04c675ef2d0127a80b3395aa90dfd1061f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/btf.c
diff --cc tools/lib/bpf/btf.c
index ad19a43e946a,06bd1a625ff4..000000000000
--- a/tools/lib/bpf/btf.c
+++ b/tools/lib/bpf/btf.c
@@@ -141,7 -182,38 +141,42 @@@ static int btf_parse_str_sec(struct bt
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int btf_parse_type_sec(struct btf *btf, btf_print_fn_t err_log)
++=======
+ static int btf_type_size(struct btf_type *t)
+ {
+ 	int base_size = sizeof(struct btf_type);
+ 	__u16 vlen = BTF_INFO_VLEN(t->info);
+ 
+ 	switch (BTF_INFO_KIND(t->info)) {
+ 	case BTF_KIND_FWD:
+ 	case BTF_KIND_CONST:
+ 	case BTF_KIND_VOLATILE:
+ 	case BTF_KIND_RESTRICT:
+ 	case BTF_KIND_PTR:
+ 	case BTF_KIND_TYPEDEF:
+ 	case BTF_KIND_FUNC:
+ 		return base_size;
+ 	case BTF_KIND_INT:
+ 		return base_size + sizeof(__u32);
+ 	case BTF_KIND_ENUM:
+ 		return base_size + vlen * sizeof(struct btf_enum);
+ 	case BTF_KIND_ARRAY:
+ 		return base_size + sizeof(struct btf_array);
+ 	case BTF_KIND_STRUCT:
+ 	case BTF_KIND_UNION:
+ 		return base_size + vlen * sizeof(struct btf_member);
+ 	case BTF_KIND_FUNC_PROTO:
+ 		return base_size + vlen * sizeof(struct btf_param);
+ 	default:
+ 		pr_debug("Unsupported BTF_KIND:%u\n", BTF_INFO_KIND(t->info));
+ 		return -EINVAL;
+ 	}
+ }
+ 
+ static int btf_parse_type_sec(struct btf *btf)
++>>>>>>> 69eaab04c675 (btf: extract BTF type size calculation)
  {
  	struct btf_header *hdr = btf->hdr;
  	void *nohdr_data = btf->nohdr_data;
@@@ -150,41 -222,13 +185,48 @@@
  
  	while (next_type < end_type) {
  		struct btf_type *t = next_type;
- 		__u16 vlen = BTF_INFO_VLEN(t->info);
+ 		int type_size;
  		int err;
  
++<<<<<<< HEAD
 +		next_type += sizeof(*t);
 +		switch (BTF_INFO_KIND(t->info)) {
 +		case BTF_KIND_INT:
 +			next_type += sizeof(int);
 +			break;
 +		case BTF_KIND_ARRAY:
 +			next_type += sizeof(struct btf_array);
 +			break;
 +		case BTF_KIND_STRUCT:
 +		case BTF_KIND_UNION:
 +			next_type += vlen * sizeof(struct btf_member);
 +			break;
 +		case BTF_KIND_ENUM:
 +			next_type += vlen * sizeof(struct btf_enum);
 +			break;
 +		case BTF_KIND_FUNC_PROTO:
 +			next_type += vlen * sizeof(struct btf_param);
 +			break;
 +		case BTF_KIND_FUNC:
 +		case BTF_KIND_TYPEDEF:
 +		case BTF_KIND_PTR:
 +		case BTF_KIND_FWD:
 +		case BTF_KIND_VOLATILE:
 +		case BTF_KIND_CONST:
 +		case BTF_KIND_RESTRICT:
 +			break;
 +		default:
 +			elog("Unsupported BTF_KIND:%u\n",
 +			     BTF_INFO_KIND(t->info));
 +			return -EINVAL;
 +		}
 +
++=======
+ 		type_size = btf_type_size(t);
+ 		if (type_size < 0)
+ 			return type_size;
+ 		next_type += type_size;
++>>>>>>> 69eaab04c675 (btf: extract BTF type size calculation)
  		err = btf_add_type(btf, t);
  		if (err)
  			return err;
* Unmerged path tools/lib/bpf/btf.c
