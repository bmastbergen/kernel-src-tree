net/ipv4: Move loop over addresses on a device into in_dev_dump_addr

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [net] ipv4: Move loop over addresses on a device into in_dev_dump_addr (Petr Oros) [1700306]
Rebuild_FUZZ: 96.97%
commit-author David Ahern <dsahern@gmail.com>
commit 1c98eca412e1f183070e76d103a296d7afccfd64
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/1c98eca4.failed

Similar to IPv6 move the logic that walks over the ipv4 address list
for a device into a helper.

	Signed-off-by: David Ahern <dsahern@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1c98eca412e1f183070e76d103a296d7afccfd64)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/devinet.c
diff --cc net/ipv4/devinet.c
index 6c015dfe13b4,67f382c560ba..000000000000
--- a/net/ipv4/devinet.c
+++ b/net/ipv4/devinet.c
@@@ -1659,11 -1660,91 +1659,93 @@@ nla_put_failure
  	return -EMSGSIZE;
  }
  
++<<<<<<< HEAD
++=======
+ static int inet_valid_dump_ifaddr_req(const struct nlmsghdr *nlh,
+ 				      struct inet_fill_args *fillargs,
+ 				      struct net **tgt_net, struct sock *sk,
+ 				      struct netlink_ext_ack *extack)
+ {
+ 	struct nlattr *tb[IFA_MAX+1];
+ 	struct ifaddrmsg *ifm;
+ 	int err, i;
+ 
+ 	if (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ifm))) {
+ 		NL_SET_ERR_MSG(extack, "ipv4: Invalid header for address dump request");
+ 		return -EINVAL;
+ 	}
+ 
+ 	ifm = nlmsg_data(nlh);
+ 	if (ifm->ifa_prefixlen || ifm->ifa_flags || ifm->ifa_scope) {
+ 		NL_SET_ERR_MSG(extack, "ipv4: Invalid values in header for address dump request");
+ 		return -EINVAL;
+ 	}
+ 	if (ifm->ifa_index) {
+ 		NL_SET_ERR_MSG(extack, "ipv4: Filter by device index not supported for address dump");
+ 		return -EINVAL;
+ 	}
+ 
+ 	err = nlmsg_parse_strict(nlh, sizeof(*ifm), tb, IFA_MAX,
+ 				 ifa_ipv4_policy, extack);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	for (i = 0; i <= IFA_MAX; ++i) {
+ 		if (!tb[i])
+ 			continue;
+ 
+ 		if (i == IFA_TARGET_NETNSID) {
+ 			struct net *net;
+ 
+ 			fillargs->netnsid = nla_get_s32(tb[i]);
+ 
+ 			net = rtnl_get_net_ns_capable(sk, fillargs->netnsid);
+ 			if (IS_ERR(net)) {
+ 				NL_SET_ERR_MSG(extack, "ipv4: Invalid target network namespace id");
+ 				return PTR_ERR(net);
+ 			}
+ 			*tgt_net = net;
+ 		} else {
+ 			NL_SET_ERR_MSG(extack, "ipv4: Unsupported attribute in dump request");
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int in_dev_dump_addr(struct in_device *in_dev, struct sk_buff *skb,
+ 			    struct netlink_callback *cb, int s_ip_idx,
+ 			    struct inet_fill_args *fillargs)
+ {
+ 	struct in_ifaddr *ifa;
+ 	int ip_idx = 0;
+ 	int err;
+ 
+ 	for (ifa = in_dev->ifa_list; ifa; ifa = ifa->ifa_next, ip_idx++) {
+ 		if (ip_idx < s_ip_idx)
+ 			continue;
+ 
+ 		err = inet_fill_ifaddr(skb, ifa, fillargs);
+ 		if (err < 0)
+ 			goto done;
+ 
+ 		nl_dump_check_consistent(cb, nlmsg_hdr(skb));
+ 	}
+ 	err = 0;
+ 
+ done:
+ 	cb->args[2] = ip_idx;
+ 
+ 	return err;
+ }
+ 
++>>>>>>> 1c98eca412e1 (net/ipv4: Move loop over addresses on a device into in_dev_dump_addr)
  static int inet_dump_ifaddr(struct sk_buff *skb, struct netlink_callback *cb)
  {
 -	const struct nlmsghdr *nlh = cb->nlh;
  	struct inet_fill_args fillargs = {
  		.portid = NETLINK_CB(cb->skb).portid,
 -		.seq = nlh->nlmsg_seq,
 +		.seq = cb->nlh->nlmsg_seq,
  		.event = RTM_NEWADDR,
  		.flags = NLM_F_MULTI,
  		.netnsid = -1,
@@@ -1681,18 -1761,13 +1763,26 @@@
  
  	s_h = cb->args[0];
  	s_idx = idx = cb->args[1];
- 	s_ip_idx = ip_idx = cb->args[2];
+ 	s_ip_idx = cb->args[2];
  
++<<<<<<< HEAD
 +	if (nlmsg_parse(cb->nlh, sizeof(struct ifaddrmsg), tb, IFA_MAX,
 +			ifa_ipv4_policy, NULL) >= 0) {
 +		if (tb[IFA_TARGET_NETNSID]) {
 +			fillargs.netnsid = nla_get_s32(tb[IFA_TARGET_NETNSID]);
 +
 +			tgt_net = rtnl_get_net_ns_capable(skb->sk,
 +							  fillargs.netnsid);
 +			if (IS_ERR(tgt_net))
 +				return PTR_ERR(tgt_net);
 +		}
++=======
+ 	if (cb->strict_check) {
+ 		err = inet_valid_dump_ifaddr_req(nlh, &fillargs, &tgt_net,
+ 						 skb->sk, cb->extack);
+ 		if (err < 0)
+ 			return err;
++>>>>>>> 1c98eca412e1 (net/ipv4: Move loop over addresses on a device into in_dev_dump_addr)
  	}
  
  	for (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {
* Unmerged path net/ipv4/devinet.c
