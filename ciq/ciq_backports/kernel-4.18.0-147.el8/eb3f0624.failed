KVM: arm64: Support handling access faults for PUD hugepages

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Punit Agrawal <punit.agrawal@arm.com>
commit eb3f0624ea082def887acc79e97934e27d0188b7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/eb3f0624.failed

In preparation for creating larger hugepages at Stage 2, extend the
access fault handling at Stage 2 to support PUD hugepages when
encountered.

Provide trivial helpers for arm32 to allow sharing of code.

	Signed-off-by: Punit Agrawal <punit.agrawal@arm.com>
	Reviewed-by: Christoffer Dall <christoffer.dall@arm.com>
	Cc: Russell King <linux@armlinux.org.uk>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Will Deacon <will.deacon@arm.com>
[ Replaced BUG() => WARN_ON(1) in PUD helpers ]
	Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
	Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
(cherry picked from commit eb3f0624ea082def887acc79e97934e27d0188b7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm/include/asm/kvm_mmu.h
#	arch/arm64/include/asm/kvm_mmu.h
diff --cc arch/arm/include/asm/kvm_mmu.h
index aa04390ce4a5,3a407204b957..000000000000
--- a/arch/arm/include/asm/kvm_mmu.h
+++ b/arch/arm/include/asm/kvm_mmu.h
@@@ -82,6 -82,41 +82,44 @@@ void kvm_clear_hyp_idmap(void)
  #define kvm_mk_pud(pmdp)	__pud(__pa(pmdp) | PMD_TYPE_TABLE)
  #define kvm_mk_pgd(pudp)	({ BUILD_BUG(); 0; })
  
++<<<<<<< HEAD
++=======
+ #define kvm_pfn_pte(pfn, prot)	pfn_pte(pfn, prot)
+ #define kvm_pfn_pmd(pfn, prot)	pfn_pmd(pfn, prot)
+ 
+ #define kvm_pud_pfn(pud)	({ WARN_ON(1); 0; })
+ 
+ 
+ #define kvm_pmd_mkhuge(pmd)	pmd_mkhuge(pmd)
+ 
+ /*
+  * The following kvm_*pud*() functions are provided strictly to allow
+  * sharing code with arm64. They should never be called in practice.
+  */
+ static inline void kvm_set_s2pud_readonly(pud_t *pud)
+ {
+ 	WARN_ON(1);
+ }
+ 
+ static inline bool kvm_s2pud_readonly(pud_t *pud)
+ {
+ 	WARN_ON(1);
+ 	return false;
+ }
+ 
+ static inline bool kvm_s2pud_exec(pud_t *pud)
+ {
+ 	WARN_ON(1);
+ 	return false;
+ }
+ 
+ static inline pud_t kvm_s2pud_mkyoung(pud_t pud)
+ {
+ 	BUG();
+ 	return pud;
+ }
+ 
++>>>>>>> eb3f0624ea08 (KVM: arm64: Support handling access faults for PUD hugepages)
  static inline pte_t kvm_s2pte_mkwrite(pte_t pte)
  {
  	pte_val(pte) |= L_PTE_S2_RDWR;
diff --cc arch/arm64/include/asm/kvm_mmu.h
index 94acbfa0650c,612032bbb428..000000000000
--- a/arch/arm64/include/asm/kvm_mmu.h
+++ b/arch/arm64/include/asm/kvm_mmu.h
@@@ -184,6 -184,13 +184,16 @@@ void kvm_clear_hyp_idmap(void)
  #define kvm_mk_pgd(pudp)					\
  	__pgd(__phys_to_pgd_val(__pa(pudp)) | PUD_TYPE_TABLE)
  
++<<<<<<< HEAD
++=======
+ #define kvm_pfn_pte(pfn, prot)		pfn_pte(pfn, prot)
+ #define kvm_pfn_pmd(pfn, prot)		pfn_pmd(pfn, prot)
+ 
+ #define kvm_pud_pfn(pud)		pud_pfn(pud)
+ 
+ #define kvm_pmd_mkhuge(pmd)		pmd_mkhuge(pmd)
+ 
++>>>>>>> eb3f0624ea08 (KVM: arm64: Support handling access faults for PUD hugepages)
  static inline pte_t kvm_s2pte_mkwrite(pte_t pte)
  {
  	pte_val(pte) |= PTE_S2_RDWR;
@@@ -246,6 -253,26 +256,29 @@@ static inline bool kvm_s2pmd_exec(pmd_
  	return !(READ_ONCE(pmd_val(*pmdp)) & PMD_S2_XN);
  }
  
++<<<<<<< HEAD
++=======
+ static inline void kvm_set_s2pud_readonly(pud_t *pudp)
+ {
+ 	kvm_set_s2pte_readonly((pte_t *)pudp);
+ }
+ 
+ static inline bool kvm_s2pud_readonly(pud_t *pudp)
+ {
+ 	return kvm_s2pte_readonly((pte_t *)pudp);
+ }
+ 
+ static inline bool kvm_s2pud_exec(pud_t *pudp)
+ {
+ 	return !(READ_ONCE(pud_val(*pudp)) & PUD_S2_XN);
+ }
+ 
+ static inline pud_t kvm_s2pud_mkyoung(pud_t pud)
+ {
+ 	return pud_mkyoung(pud);
+ }
+ 
++>>>>>>> eb3f0624ea08 (KVM: arm64: Support handling access faults for PUD hugepages)
  #define hyp_pte_table_empty(ptep) kvm_page_empty(ptep)
  
  #ifdef __PAGETABLE_PMD_FOLDED
* Unmerged path arch/arm/include/asm/kvm_mmu.h
* Unmerged path arch/arm64/include/asm/kvm_mmu.h
diff --git a/arch/arm64/include/asm/pgtable.h b/arch/arm64/include/asm/pgtable.h
index 7ab3f4580bbc..dd8d1bb1a437 100644
--- a/arch/arm64/include/asm/pgtable.h
+++ b/arch/arm64/include/asm/pgtable.h
@@ -315,6 +315,11 @@ static inline pte_t pud_pte(pud_t pud)
 	return __pte(pud_val(pud));
 }
 
+static inline pud_t pte_pud(pte_t pte)
+{
+	return __pud(pte_val(pte));
+}
+
 static inline pmd_t pud_pmd(pud_t pud)
 {
 	return __pmd(pud_val(pud));
@@ -381,6 +386,7 @@ static inline int pmd_protnone(pmd_t pmd)
 #define pfn_pmd(pfn,prot)	__pmd(__phys_to_pmd_val((phys_addr_t)(pfn) << PAGE_SHIFT) | pgprot_val(prot))
 #define mk_pmd(page,prot)	pfn_pmd(page_to_pfn(page),prot)
 
+#define pud_mkyoung(pud)	pte_pud(pte_mkyoung(pud_pte(pud)))
 #define pud_write(pud)		pte_write(pud_pte(pud))
 
 #define __pud_to_phys(pud)	__pte_to_phys(pud_pte(pud))
diff --git a/virt/kvm/arm/mmu.c b/virt/kvm/arm/mmu.c
index 22e88cffe24c..9788bb643d12 100644
--- a/virt/kvm/arm/mmu.c
+++ b/virt/kvm/arm/mmu.c
@@ -1682,6 +1682,7 @@ static int user_mem_abort(struct kvm_vcpu *vcpu, phys_addr_t fault_ipa,
  */
 static void handle_access_fault(struct kvm_vcpu *vcpu, phys_addr_t fault_ipa)
 {
+	pud_t *pud;
 	pmd_t *pmd;
 	pte_t *pte;
 	kvm_pfn_t pfn;
@@ -1691,24 +1692,23 @@ static void handle_access_fault(struct kvm_vcpu *vcpu, phys_addr_t fault_ipa)
 
 	spin_lock(&vcpu->kvm->mmu_lock);
 
-	pmd = stage2_get_pmd(vcpu->kvm, NULL, fault_ipa);
-	if (!pmd || pmd_none(*pmd))	/* Nothing there */
+	if (!stage2_get_leaf_entry(vcpu->kvm, fault_ipa, &pud, &pmd, &pte))
 		goto out;
 
-	if (pmd_thp_or_huge(*pmd)) {	/* THP, HugeTLB */
+	if (pud) {		/* HugeTLB */
+		*pud = kvm_s2pud_mkyoung(*pud);
+		pfn = kvm_pud_pfn(*pud);
+		pfn_valid = true;
+	} else	if (pmd) {	/* THP, HugeTLB */
 		*pmd = pmd_mkyoung(*pmd);
 		pfn = pmd_pfn(*pmd);
 		pfn_valid = true;
-		goto out;
+	} else {
+		*pte = pte_mkyoung(*pte);	/* Just a page... */
+		pfn = pte_pfn(*pte);
+		pfn_valid = true;
 	}
 
-	pte = pte_offset_kernel(pmd, fault_ipa);
-	if (pte_none(*pte))		/* Nothing there either */
-		goto out;
-
-	*pte = pte_mkyoung(*pte);	/* Just a page... */
-	pfn = pte_pfn(*pte);
-	pfn_valid = true;
 out:
 	spin_unlock(&vcpu->kvm->mmu_lock);
 	if (pfn_valid)
