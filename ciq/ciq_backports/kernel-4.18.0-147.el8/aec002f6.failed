net/mlx5e: Uninstantiate esw manager vport netdev on switchdev mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Or Gerlitz <ogerlitz@mellanox.com>
commit aec002f6f82cbfb39f92605614a88dd7a200a766
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/aec002f6.failed

Now, when we have a dedicated uplink representor, the netdev instance
set over the esw manager vport (PF) is of no-use. As such, remove it
once we're on switchdev mode and get it back to life when off switchdev.

This is done by reloading the Ethernet interface as well (we already
do that for the IB interface) from the eswitch code while going in/out
of switchdev mode.

The Eth add/remove entries are modified to act differently when called in
switchdev mode. In this case we only deal with registration of the eth
vport representors. The rep netdevices are created from the eswitch call
to load the registered eth representors.

	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit aec002f6f82cbfb39f92605614a88dd7a200a766)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index b4f6c14ea722,0fd5752fb181..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -4864,10 -4891,9 +4864,13 @@@ static void mlx5e_nic_enable(struct mlx
  	mlx5_lag_add(mdev, netdev);
  
  	mlx5e_enable_async_events(priv);
 -	if (mlx5e_monitor_counter_supported(priv))
 -		mlx5e_monitor_counter_init(priv);
  
++<<<<<<< HEAD
 +	if (MLX5_ESWITCH_MANAGER(priv->mdev))
 +		mlx5e_register_vport_reps(priv);
 +
++=======
++>>>>>>> aec002f6f82c (net/mlx5e: Uninstantiate esw manager vport netdev on switchdev mode)
  	if (netdev->reg_state != NETREG_REGISTERED)
  		return;
  #ifdef CONFIG_MLX5_CORE_EN_DCB
@@@ -4900,8 -4926,8 +4903,13 @@@ static void mlx5e_nic_disable(struct ml
  
  	queue_work(priv->wq, &priv->set_rx_mode_work);
  
++<<<<<<< HEAD
 +	if (MLX5_ESWITCH_MANAGER(priv->mdev))
 +		mlx5e_unregister_vport_reps(priv);
++=======
+ 	if (mlx5e_monitor_counter_supported(priv))
+ 		mlx5e_monitor_counter_cleanup(priv);
++>>>>>>> aec002f6f82c (net/mlx5e: Uninstantiate esw manager vport netdev on switchdev mode)
  
  	mlx5e_disable_async_events(priv);
  	mlx5_lag_remove(mdev);
@@@ -5108,12 -5133,10 +5116,19 @@@ static void *mlx5e_add(struct mlx5_core
  		return NULL;
  
  #ifdef CONFIG_MLX5_ESWITCH
++<<<<<<< HEAD
 +	if (MLX5_ESWITCH_MANAGER(mdev)) {
 +		rpriv = mlx5e_alloc_nic_rep_priv(mdev);
 +		if (!rpriv) {
 +			mlx5_core_warn(mdev, "Failed to alloc NIC rep priv data\n");
 +			return NULL;
 +		}
++=======
+ 	if (MLX5_ESWITCH_MANAGER(mdev) &&
+ 	    mlx5_eswitch_mode(mdev->priv.eswitch) == SRIOV_OFFLOADS) {
+ 		mlx5e_rep_register_vport_reps(mdev);
+ 		return mdev;
++>>>>>>> aec002f6f82c (net/mlx5e: Uninstantiate esw manager vport netdev on switchdev mode)
  	}
  #endif
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index 58cddf0a96a7,e4f8f639dea0..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -1409,18 -1613,13 +1419,20 @@@ mlx5e_vport_rep_unload(struct mlx5_eswi
  	struct mlx5e_rep_priv *rpriv = mlx5e_rep_to_rep_priv(rep);
  	struct net_device *netdev = rpriv->netdev;
  	struct mlx5e_priv *priv = netdev_priv(netdev);
 +	struct mlx5e_rep_priv *uplink_rpriv;
  	void *ppriv = priv->ppriv;
 +	struct mlx5e_priv *upriv;
  
  	unregister_netdev(netdev);
 +	uplink_rpriv = mlx5_eswitch_get_uplink_priv(priv->mdev->priv.eswitch,
 +						    REP_ETH);
 +	upriv = netdev_priv(uplink_rpriv->netdev);
 +	tc_setup_cb_egdev_unregister(netdev, mlx5e_rep_setup_tc_cb_egdev,
 +				     upriv);
  	mlx5e_rep_neigh_cleanup(rpriv);
  	mlx5e_detach_netdev(priv);
+ 	if (rep->vport == FDB_UPLINK_VPORT)
+ 		mlx5e_destroy_mdev_resources(priv->mdev);
  	mlx5e_destroy_netdev(priv);
  	kfree(ppriv); /* mlx5e_rep_priv */
  }
@@@ -1434,10 -1633,9 +1446,13 @@@ static void *mlx5e_vport_rep_get_proto_
  	return rpriv->netdev;
  }
  
++<<<<<<< HEAD
 +static void mlx5e_rep_register_vf_vports(struct mlx5e_priv *priv)
++=======
+ void mlx5e_rep_register_vport_reps(struct mlx5_core_dev *mdev)
++>>>>>>> aec002f6f82c (net/mlx5e: Uninstantiate esw manager vport netdev on switchdev mode)
  {
- 	struct mlx5_core_dev *mdev = priv->mdev;
- 	struct mlx5_eswitch *esw   = mdev->priv.eswitch;
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
  	int total_vfs = MLX5_TOTAL_VPORTS(mdev);
  	int vport;
  
@@@ -1451,9 -1649,8 +1466,12 @@@
  	}
  }
  
++<<<<<<< HEAD
 +static void mlx5e_rep_unregister_vf_vports(struct mlx5e_priv *priv)
++=======
+ void mlx5e_rep_unregister_vport_reps(struct mlx5_core_dev *mdev)
++>>>>>>> aec002f6f82c (net/mlx5e: Uninstantiate esw manager vport netdev on switchdev mode)
  {
- 	struct mlx5_core_dev *mdev = priv->mdev;
  	struct mlx5_eswitch *esw = mdev->priv.eswitch;
  	int total_vfs = MLX5_TOTAL_VPORTS(mdev);
  	int vport;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index c078c6703dc7,5645d3cef1bb..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@@ -160,8 -162,8 +160,13 @@@ struct mlx5e_rep_sq 
  };
  
  void *mlx5e_alloc_nic_rep_priv(struct mlx5_core_dev *mdev);
++<<<<<<< HEAD
 +void mlx5e_register_vport_reps(struct mlx5e_priv *priv);
 +void mlx5e_unregister_vport_reps(struct mlx5e_priv *priv);
++=======
+ void mlx5e_rep_register_vport_reps(struct mlx5_core_dev *mdev);
+ void mlx5e_rep_unregister_vport_reps(struct mlx5_core_dev *mdev);
++>>>>>>> aec002f6f82c (net/mlx5e: Uninstantiate esw manager vport netdev on switchdev mode)
  bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv);
  int mlx5e_add_sqs_fwd_rules(struct mlx5e_priv *priv);
  void mlx5e_remove_sqs_fwd_rules(struct mlx5e_priv *priv);
@@@ -179,8 -177,6 +184,11 @@@ void mlx5e_rep_encap_entry_detach(struc
  
  void mlx5e_rep_queue_neigh_stats_work(struct mlx5e_priv *priv);
  #else /* CONFIG_MLX5_ESWITCH */
++<<<<<<< HEAD
 +static inline void mlx5e_register_vport_reps(struct mlx5e_priv *priv) {}
 +static inline void mlx5e_unregister_vport_reps(struct mlx5e_priv *priv) {}
++=======
++>>>>>>> aec002f6f82c (net/mlx5e: Uninstantiate esw manager vport netdev on switchdev mode)
  static inline bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv) { return false; }
  static inline int mlx5e_add_sqs_fwd_rules(struct mlx5e_priv *priv) { return 0; }
  static inline void mlx5e_remove_sqs_fwd_rules(struct mlx5e_priv *priv) {}
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index e5c40d01db8a..d4286de03a8c 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@ -1615,6 +1615,7 @@ int mlx5_eswitch_enable_sriov(struct mlx5_eswitch *esw, int nvfs, int mode)
 		esw_warn(esw->dev, "E-Switch engress ACL is not supported by FW\n");
 
 	esw_info(esw->dev, "E-Switch enable SRIOV: nvfs(%d) mode (%d)\n", nvfs, mode);
+
 	esw->mode = mode;
 
 	mlx5_lag_update(esw->dev);
@@ -1622,8 +1623,8 @@ int mlx5_eswitch_enable_sriov(struct mlx5_eswitch *esw, int nvfs, int mode)
 	if (mode == SRIOV_LEGACY) {
 		err = esw_create_legacy_fdb_table(esw);
 	} else {
+		mlx5_reload_interface(esw->dev, MLX5_INTERFACE_PROTOCOL_ETH);
 		mlx5_reload_interface(esw->dev, MLX5_INTERFACE_PROTOCOL_IB);
-
 		err = esw_offloads_init(esw, nvfs + 1);
 	}
 
@@ -1649,8 +1650,10 @@ int mlx5_eswitch_enable_sriov(struct mlx5_eswitch *esw, int nvfs, int mode)
 abort:
 	esw->mode = SRIOV_NONE;
 
-	if (mode == SRIOV_OFFLOADS)
+	if (mode == SRIOV_OFFLOADS) {
 		mlx5_reload_interface(esw->dev, MLX5_INTERFACE_PROTOCOL_IB);
+		mlx5_reload_interface(esw->dev, MLX5_INTERFACE_PROTOCOL_ETH);
+	}
 
 	return err;
 }
@@ -1689,8 +1692,10 @@ void mlx5_eswitch_disable_sriov(struct mlx5_eswitch *esw)
 
 	mlx5_lag_update(esw->dev);
 
-	if (old_mode == SRIOV_OFFLOADS)
+	if (old_mode == SRIOV_OFFLOADS) {
 		mlx5_reload_interface(esw->dev, MLX5_INTERFACE_PROTOCOL_IB);
+		mlx5_reload_interface(esw->dev, MLX5_INTERFACE_PROTOCOL_ETH);
+	}
 }
 
 int mlx5_eswitch_init(struct mlx5_core_dev *dev)
