signal/arm64: Add and use arm64_force_sig_mceerr as appropriate

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit b4d5557caa07a01796ca8a2d756eeaa5308f6876
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/b4d5557c.failed

Add arm64_force_sig_mceerr for consistency with arm64_force_sig_fault,
and use it in the one location that can take advantage of it.

This removes the fiddly filling out of siginfo before sending a signal
reporting an memory error to userspace.

	Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
	Tested-by: Catalin Marinas <catalin.marinas@arm.com>
	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
(cherry picked from commit b4d5557caa07a01796ca8a2d756eeaa5308f6876)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/mm/fault.c
diff --cc arch/arm64/mm/fault.c
index cfdcd107860a,f0ccb209d181..000000000000
--- a/arch/arm64/mm/fault.c
+++ b/arch/arm64/mm/fault.c
@@@ -422,8 -422,7 +422,12 @@@ static int __kprobes do_page_fault(unsi
  	const struct fault_info *inf;
  	struct task_struct *tsk;
  	struct mm_struct *mm;
++<<<<<<< HEAD
 +	struct siginfo si;
 +	int fault, major = 0;
++=======
+ 	vm_fault_t fault, major = 0;
++>>>>>>> b4d5557caa07 (signal/arm64: Add and use arm64_force_sig_mceerr as appropriate)
  	unsigned long vm_flags = VM_READ | VM_WRITE;
  	unsigned int mm_flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;
  
diff --git a/arch/arm64/include/asm/traps.h b/arch/arm64/include/asm/traps.h
index 08e99901edbc..193f0b0e8ee3 100644
--- a/arch/arm64/include/asm/traps.h
+++ b/arch/arm64/include/asm/traps.h
@@ -38,6 +38,7 @@ void unregister_undef_hook(struct undef_hook *hook);
 void force_signal_inject(int signal, int code, unsigned long address);
 void arm64_notify_segfault(unsigned long addr);
 void arm64_force_sig_fault(int signo, int code, void __user *addr, const char *str);
+void arm64_force_sig_mceerr(int code, void __user *addr, short lsb, const char *str);
 void arm64_force_sig_info(struct siginfo *info, const char *str);
 
 /*
diff --git a/arch/arm64/kernel/traps.c b/arch/arm64/kernel/traps.c
index 4efd47b623f4..7b24bbaa264f 100644
--- a/arch/arm64/kernel/traps.c
+++ b/arch/arm64/kernel/traps.c
@@ -255,6 +255,13 @@ void arm64_force_sig_fault(int signo, int code, void __user *addr,
 	force_sig_fault(signo, code, addr, current);
 }
 
+void arm64_force_sig_mceerr(int code, void __user *addr, short lsb,
+			    const char *str)
+{
+	arm64_show_signal(SIGBUS, str);
+	force_sig_mceerr(code, addr, lsb, current);
+}
+
 void arm64_force_sig_info(struct siginfo *info, const char *str)
 {
 	arm64_show_signal(info->si_signo, str);
* Unmerged path arch/arm64/mm/fault.c
