net/tls: fix lowat calculation if some data came from previous record

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [net] tls: fix lowat calculation if some data came from previous record (Sabrina Dubroca) [1711821]
Rebuild_FUZZ: 97.01%
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 46a1695960d0600d58da7af33c65f24f3d839674
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/46a16959.failed

If some of the data came from the previous record, i.e. from
the rx_list it had already been decrypted, so it's not counted
towards the "decrypted" variable, but the "copied" variable.
Take that into account when checking lowat.

When calculating lowat target we need to pass the original len.
E.g. if lowat is at 80, len is 100 and we had 30 bytes on rx_list
target would currently be incorrectly calculated as 70, even though
we only need 50 more bytes to make up the 80.

Fixes: 692d7b5d1f91 ("tls: Fix recvmsg() to be able to peek across multiple records")
	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Dirk van der Merwe <dirk.vandermerwe@netronome.com>
	Tested-by: David Beckett <david.beckett@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 46a1695960d0600d58da7af33c65f24f3d839674)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/tls/tls_sw.c
diff --cc net/tls/tls_sw.c
index 3f443983a6b3,fc13234db74a..000000000000
--- a/net/tls/tls_sw.c
+++ b/net/tls/tls_sw.c
@@@ -1312,18 -1699,54 +1312,38 @@@ int tls_sw_recvmsg(struct sock *sk
  	if (unlikely(flags & MSG_ERRQUEUE))
  		return sock_recv_errqueue(sk, msg, len, SOL_IP, IP_RECVERR);
  
 -	psock = sk_psock_get(sk);
  	lock_sock(sk);
  
++<<<<<<< HEAD
 +	target = sock_rcvlowat(sk, flags & MSG_WAITALL, len);
 +	timeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);
++=======
+ 	/* Process pending decrypted records. It must be non-zero-copy */
+ 	err = process_rx_list(ctx, msg, &control, &cmsg, 0, len, false,
+ 			      is_peek);
+ 	if (err < 0) {
+ 		tls_err_abort(sk, err);
+ 		goto end;
+ 	} else {
+ 		copied = err;
+ 	}
+ 
+ 	if (len <= copied)
+ 		goto recv_end;
+ 
+ 	target = sock_rcvlowat(sk, flags & MSG_WAITALL, len);
+ 	len = len - copied;
+ 	timeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);
+ 
++>>>>>>> 46a1695960d0 (net/tls: fix lowat calculation if some data came from previous record)
  	do {
 -		bool retain_skb = false;
  		bool zc = false;
 -		int to_decrypt;
 -		int chunk = 0;
 -		bool async_capable;
  		bool async = false;
 +		int chunk = 0;
  
 -		skb = tls_wait_data(sk, psock, flags, timeo, &err);
 -		if (!skb) {
 -			if (psock) {
 -				int ret = __tcp_bpf_recvmsg(sk, psock,
 -							    msg, len, flags);
 -
 -				if (ret > 0) {
 -					decrypted += ret;
 -					len -= ret;
 -					continue;
 -				}
 -			}
 +		skb = tls_wait_data(sk, flags, timeo, &err);
 +		if (!skb)
  			goto recv_end;
 -		} else {
 -			tlm = tls_msg(skb);
 -			if (prot->version == TLS_1_3_VERSION)
 -				tlm->control = 0;
 -			else
 -				tlm->control = ctx->control;
 -		}
  
  		rxm = strp_msg(skb);
  
@@@ -1407,7 -1852,7 +1427,11 @@@ pick_next_record
  		}
  
  		/* If we have a new message from strparser, continue now. */
++<<<<<<< HEAD
 +		if (copied >= target && !ctx->recv_pkt)
++=======
+ 		if (decrypted + copied >= target && !ctx->recv_pkt)
++>>>>>>> 46a1695960d0 (net/tls: fix lowat calculation if some data came from previous record)
  			break;
  	} while (len);
  
* Unmerged path net/tls/tls_sw.c
