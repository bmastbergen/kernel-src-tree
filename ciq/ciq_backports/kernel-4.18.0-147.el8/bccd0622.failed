IB/uverbs: Add UVERBS_ATTR_FLAGS_IN to the specs language

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jason Gunthorpe <jgg@ziepe.ca>
commit bccd06223f21654eb268e153426a77deb117c1e8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/bccd0622.failed

This clearly indicates that the input is a bitwise combination of values
in an enum, and identifies which enum contains the definition of the bits.

Special accessors are provided that handle the mandatory validation of the
allowed bits and enforce the correct type for bitwise flags.

If we had introduced this at the start then the kabi would have uniformly
used u64 data to pass flags, however today there is a mixture of u64 and
u32 flags. All places are converted to accept both sizes and the accessor
fixes it. This allows all existing flags to grow to u64 in future without
any hassle.

Finally all flags are, by definition, optional. If flags are not passed
the accessor does not fail, but provides a value of zero.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
	Reviewed-by: Leon Romanovsky <leonro@mellanox.com>
(cherry picked from commit bccd06223f21654eb268e153426a77deb117c1e8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_std_types_counters.c
#	drivers/infiniband/core/uverbs_std_types_cq.c
#	drivers/infiniband/core/uverbs_std_types_mr.c
#	drivers/infiniband/hw/mlx5/devx.c
#	drivers/infiniband/hw/mlx5/main.c
#	include/rdma/uverbs_ioctl.h
diff --cc drivers/infiniband/core/uverbs_std_types_counters.c
index 03b182a684a6,34589799f446..000000000000
--- a/drivers/infiniband/core/uverbs_std_types_counters.c
+++ b/drivers/infiniband/core/uverbs_std_types_counters.c
@@@ -123,34 -125,34 +124,48 @@@ err_read
  	return ret;
  }
  
 -DECLARE_UVERBS_NAMED_METHOD(
 -	UVERBS_METHOD_COUNTERS_CREATE,
 -	UVERBS_ATTR_IDR(UVERBS_ATTR_CREATE_COUNTERS_HANDLE,
 -			UVERBS_OBJECT_COUNTERS,
 -			UVERBS_ACCESS_NEW,
 -			UA_MANDATORY));
 -
 -DECLARE_UVERBS_NAMED_METHOD_DESTROY(
 -	UVERBS_METHOD_COUNTERS_DESTROY,
 -	UVERBS_ATTR_IDR(UVERBS_ATTR_DESTROY_COUNTERS_HANDLE,
 -			UVERBS_OBJECT_COUNTERS,
 -			UVERBS_ACCESS_DESTROY,
 -			UA_MANDATORY));
 -
 +static DECLARE_UVERBS_NAMED_METHOD(UVERBS_METHOD_COUNTERS_CREATE,
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_CREATE_COUNTERS_HANDLE,
 +			 UVERBS_OBJECT_COUNTERS,
 +			 UVERBS_ACCESS_NEW,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
 +
 +static DECLARE_UVERBS_NAMED_METHOD_WITH_HANDLER(UVERBS_METHOD_COUNTERS_DESTROY,
 +	uverbs_destroy_def_handler,
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_DESTROY_COUNTERS_HANDLE,
 +			 UVERBS_OBJECT_COUNTERS,
 +			 UVERBS_ACCESS_DESTROY,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
 +
++<<<<<<< HEAD
 +#define MAX_COUNTERS_BUFF_SIZE USHRT_MAX
 +static DECLARE_UVERBS_NAMED_METHOD(UVERBS_METHOD_COUNTERS_READ,
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_READ_COUNTERS_HANDLE,
 +			 UVERBS_OBJECT_COUNTERS,
 +			 UVERBS_ACCESS_READ,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_READ_COUNTERS_BUFF,
 +			     UVERBS_ATTR_SIZE(0, MAX_COUNTERS_BUFF_SIZE),
 +			     UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_READ_COUNTERS_FLAGS,
 +			    UVERBS_ATTR_TYPE(__u32),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
++=======
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	UVERBS_METHOD_COUNTERS_READ,
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_READ_COUNTERS_HANDLE,
+ 			UVERBS_OBJECT_COUNTERS,
+ 			UVERBS_ACCESS_READ,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_READ_COUNTERS_BUFF,
+ 			    UVERBS_ATTR_MIN_SIZE(0),
+ 			    UA_MANDATORY),
+ 	UVERBS_ATTR_FLAGS_IN(UVERBS_ATTR_READ_COUNTERS_FLAGS,
+ 			     enum ib_uverbs_read_counters_flags));
++>>>>>>> bccd06223f21 (IB/uverbs: Add UVERBS_ATTR_FLAGS_IN to the specs language)
  
  DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_COUNTERS,
 -			    UVERBS_TYPE_ALLOC_IDR(uverbs_free_counters),
 +			    &UVERBS_TYPE_ALLOC_IDR(0, uverbs_free_counters),
  			    &UVERBS_METHOD(UVERBS_METHOD_COUNTERS_CREATE),
  			    &UVERBS_METHOD(UVERBS_METHOD_COUNTERS_DESTROY),
  			    &UVERBS_METHOD(UVERBS_METHOD_COUNTERS_READ));
diff --cc drivers/infiniband/core/uverbs_std_types_cq.c
index 150b7c04ce15,3179203a2dd7..000000000000
--- a/drivers/infiniband/core/uverbs_std_types_cq.c
+++ b/drivers/infiniband/core/uverbs_std_types_cq.c
@@@ -141,25 -147,31 +143,50 @@@ err_event_file
  	return ret;
  };
  
++<<<<<<< HEAD
 +static DECLARE_UVERBS_NAMED_METHOD(UVERBS_METHOD_CQ_CREATE,
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_CREATE_CQ_HANDLE, UVERBS_OBJECT_CQ,
 +			 UVERBS_ACCESS_NEW,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_CQE,
++=======
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	UVERBS_METHOD_CQ_CREATE,
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_CREATE_CQ_HANDLE,
+ 			UVERBS_OBJECT_CQ,
+ 			UVERBS_ACCESS_NEW,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_CQE,
+ 			   UVERBS_ATTR_TYPE(u32),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_USER_HANDLE,
+ 			   UVERBS_ATTR_TYPE(u64),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_FD(UVERBS_ATTR_CREATE_CQ_COMP_CHANNEL,
+ 		       UVERBS_OBJECT_COMP_CHANNEL,
+ 		       UVERBS_ACCESS_READ,
+ 		       UA_OPTIONAL),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_COMP_VECTOR,
+ 			   UVERBS_ATTR_TYPE(u32),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_FLAGS_IN(UVERBS_ATTR_CREATE_CQ_FLAGS,
+ 			     enum ib_uverbs_ex_create_cq_flags),
+ 	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_CREATE_CQ_RESP_CQE,
++>>>>>>> bccd06223f21 (IB/uverbs: Add UVERBS_ATTR_FLAGS_IN to the specs language)
  			    UVERBS_ATTR_TYPE(u32),
 -			    UA_MANDATORY),
 -	UVERBS_ATTR_UHW());
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_USER_HANDLE,
 +			    UVERBS_ATTR_TYPE(u64),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_FD(UVERBS_ATTR_CREATE_CQ_COMP_CHANNEL,
 +			UVERBS_OBJECT_COMP_CHANNEL,
 +			UVERBS_ACCESS_READ),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_COMP_VECTOR, UVERBS_ATTR_TYPE(u32),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_FLAGS, UVERBS_ATTR_TYPE(u32)),
 +	&UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_CREATE_CQ_RESP_CQE, UVERBS_ATTR_TYPE(u32),
 +			     UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&uverbs_uhw_compat_in, &uverbs_uhw_compat_out);
  
  static int UVERBS_HANDLER(UVERBS_METHOD_CQ_DESTROY)(struct ib_device *ib_dev,
  						    struct ib_uverbs_file *file,
diff --cc drivers/infiniband/core/uverbs_std_types_mr.c
index 68f7cadf088f,d63da0c2a8c1..000000000000
--- a/drivers/infiniband/core/uverbs_std_types_mr.c
+++ b/drivers/infiniband/core/uverbs_std_types_mr.c
@@@ -115,33 -116,36 +116,59 @@@ err_dereg
  	return ret;
  }
  
++<<<<<<< HEAD
 +static DECLARE_UVERBS_NAMED_METHOD(UVERBS_METHOD_DM_MR_REG,
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_REG_DM_MR_HANDLE, UVERBS_OBJECT_MR,
 +			 UVERBS_ACCESS_NEW,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_REG_DM_MR_OFFSET,
 +			    UVERBS_ATTR_TYPE(u64),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_REG_DM_MR_LENGTH,
 +			    UVERBS_ATTR_TYPE(u64),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_REG_DM_MR_PD_HANDLE, UVERBS_OBJECT_PD,
 +			 UVERBS_ACCESS_READ,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_REG_DM_MR_ACCESS_FLAGS,
++=======
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	UVERBS_METHOD_DM_MR_REG,
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_REG_DM_MR_HANDLE,
+ 			UVERBS_OBJECT_MR,
+ 			UVERBS_ACCESS_NEW,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_REG_DM_MR_OFFSET,
+ 			   UVERBS_ATTR_TYPE(u64),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_REG_DM_MR_LENGTH,
+ 			   UVERBS_ATTR_TYPE(u64),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_REG_DM_MR_PD_HANDLE,
+ 			UVERBS_OBJECT_PD,
+ 			UVERBS_ACCESS_READ,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_FLAGS_IN(UVERBS_ATTR_REG_DM_MR_ACCESS_FLAGS,
+ 			     enum ib_access_flags),
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_REG_DM_MR_DM_HANDLE,
+ 			UVERBS_OBJECT_DM,
+ 			UVERBS_ACCESS_READ,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_REG_DM_MR_RESP_LKEY,
++>>>>>>> bccd06223f21 (IB/uverbs: Add UVERBS_ATTR_FLAGS_IN to the specs language)
  			    UVERBS_ATTR_TYPE(u32),
 -			    UA_MANDATORY),
 -	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_REG_DM_MR_RESP_RKEY,
 -			    UVERBS_ATTR_TYPE(u32),
 -			    UA_MANDATORY));
 -
 -DECLARE_UVERBS_NAMED_OBJECT(
 -	UVERBS_OBJECT_MR,
 -	UVERBS_TYPE_ALLOC_IDR(uverbs_free_mr),
 -	&UVERBS_METHOD(UVERBS_METHOD_DM_MR_REG));
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_REG_DM_MR_DM_HANDLE, UVERBS_OBJECT_DM,
 +			 UVERBS_ACCESS_READ,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_REG_DM_MR_RESP_LKEY,
 +			     UVERBS_ATTR_TYPE(u32),
 +			     UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_REG_DM_MR_RESP_RKEY,
 +			     UVERBS_ATTR_TYPE(u32),
 +			     UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
 +
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_MR,
 +			    /* 1 is used in order to free the MR after all the MWs */
 +			    &UVERBS_TYPE_ALLOC_IDR(1, uverbs_free_mr),
 +			    &UVERBS_METHOD(UVERBS_METHOD_DM_MR_REG));
diff --cc drivers/infiniband/hw/mlx5/devx.c
index 7b7903c26e2e,c9a7a12a8c13..000000000000
--- a/drivers/infiniband/hw/mlx5/devx.c
+++ b/drivers/infiniband/hw/mlx5/devx.c
@@@ -428,47 -769,375 +428,395 @@@ obj_free
  	return err;
  }
  
 -static int UVERBS_HANDLER(MLX5_IB_METHOD_DEVX_OBJ_MODIFY)(struct ib_device *ib_dev,
 -				   struct ib_uverbs_file *file,
 -				   struct uverbs_attr_bundle *attrs)
 -{
 -	void *cmd_in = uverbs_attr_get_alloced_ptr(attrs, MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_IN);
 -	int cmd_out_len = uverbs_attr_get_len(attrs,
 -					MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_OUT);
 -	struct ib_uobject *uobj = uverbs_attr_get_uobject(attrs,
 -							  MLX5_IB_ATTR_DEVX_OBJ_MODIFY_HANDLE);
 -	struct mlx5_ib_ucontext *c = to_mucontext(uobj->context);
 -	struct devx_obj *obj = uobj->object;
 -	void *cmd_out;
 -	int err;
 -
 -	if (!c->devx_uid)
 -		return -EPERM;
 -
 -	if (!devx_is_obj_modify_cmd(cmd_in))
 -		return -EINVAL;
 -
 -	if (!devx_is_valid_obj_id(obj, cmd_in))
 -		return -EINVAL;
 -
 -	cmd_out = kvzalloc(cmd_out_len, GFP_KERNEL);
 -	if (!cmd_out)
 -		return -ENOMEM;
 -
 +static DECLARE_UVERBS_NAMED_METHOD(MLX5_IB_METHOD_DEVX_OTHER,
 +	&UVERBS_ATTR_PTR_IN_SZ(MLX5_IB_ATTR_DEVX_OTHER_CMD_IN,
 +			       UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
 +			       UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY |
 +					UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO |
 +					UVERBS_ATTR_SPEC_F_ALLOC_AND_COPY)),
 +	&UVERBS_ATTR_PTR_OUT_SZ(MLX5_IB_ATTR_DEVX_OTHER_CMD_OUT,
 +				UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_out_cmd_hdr)),
 +				UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY |
 +					 UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO))
 +);
 +
 +static DECLARE_UVERBS_NAMED_METHOD(MLX5_IB_METHOD_DEVX_OBJ_CREATE,
 +	&UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_CREATE_HANDLE,
 +			 MLX5_IB_OBJECT_DEVX_OBJ,
 +			 UVERBS_ACCESS_NEW,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN_SZ(MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_IN,
 +			       UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
 +			       UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY |
 +					UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO |
 +					UVERBS_ATTR_SPEC_F_ALLOC_AND_COPY)),
 +	&UVERBS_ATTR_PTR_OUT_SZ(MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_OUT,
 +				UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_out_cmd_hdr)),
 +				UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY |
 +					 UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO)));
 +
 +static DECLARE_UVERBS_NAMED_METHOD(MLX5_IB_METHOD_DEVX_OBJ_DESTROY,
 +	&UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_DESTROY_HANDLE,
 +			 MLX5_IB_OBJECT_DEVX_OBJ,
 +			 UVERBS_ACCESS_DESTROY,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
 +
 +static DECLARE_UVERBS_GLOBAL_METHODS(MLX5_IB_OBJECT_DEVX,
 +	&UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OTHER));
 +
 +static DECLARE_UVERBS_NAMED_OBJECT(MLX5_IB_OBJECT_DEVX_OBJ,
 +	&UVERBS_TYPE_ALLOC_IDR(0, devx_obj_cleanup),
 +		&UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OBJ_CREATE),
 +		&UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OBJ_DESTROY));
 +
++<<<<<<< HEAD
 +static DECLARE_UVERBS_OBJECT_TREE(devx_objects,
 +	&UVERBS_OBJECT(MLX5_IB_OBJECT_DEVX),
 +	&UVERBS_OBJECT(MLX5_IB_OBJECT_DEVX_OBJ));
++=======
+ 	MLX5_SET(general_obj_in_cmd_hdr, cmd_in, uid, c->devx_uid);
+ 	err = mlx5_cmd_exec(obj->mdev, cmd_in,
+ 			    uverbs_attr_get_len(attrs, MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_IN),
+ 			    cmd_out, cmd_out_len);
+ 	if (err)
+ 		goto other_cmd_free;
+ 
+ 	err = uverbs_copy_to(attrs, MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_OUT,
+ 			     cmd_out, cmd_out_len);
+ 
+ other_cmd_free:
+ 	kvfree(cmd_out);
+ 	return err;
+ }
+ 
+ static int UVERBS_HANDLER(MLX5_IB_METHOD_DEVX_OBJ_QUERY)(struct ib_device *ib_dev,
+ 				   struct ib_uverbs_file *file,
+ 				   struct uverbs_attr_bundle *attrs)
+ {
+ 	void *cmd_in = uverbs_attr_get_alloced_ptr(attrs, MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_IN);
+ 	int cmd_out_len = uverbs_attr_get_len(attrs,
+ 					      MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_OUT);
+ 	struct ib_uobject *uobj = uverbs_attr_get_uobject(attrs,
+ 							  MLX5_IB_ATTR_DEVX_OBJ_QUERY_HANDLE);
+ 	struct mlx5_ib_ucontext *c = to_mucontext(uobj->context);
+ 	struct devx_obj *obj = uobj->object;
+ 	void *cmd_out;
+ 	int err;
+ 
+ 	if (!c->devx_uid)
+ 		return -EPERM;
+ 
+ 	if (!devx_is_obj_query_cmd(cmd_in))
+ 		return -EINVAL;
+ 
+ 	if (!devx_is_valid_obj_id(obj, cmd_in))
+ 		return -EINVAL;
+ 
+ 	cmd_out = kvzalloc(cmd_out_len, GFP_KERNEL);
+ 	if (!cmd_out)
+ 		return -ENOMEM;
+ 
+ 	MLX5_SET(general_obj_in_cmd_hdr, cmd_in, uid, c->devx_uid);
+ 	err = mlx5_cmd_exec(obj->mdev, cmd_in,
+ 			    uverbs_attr_get_len(attrs, MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_IN),
+ 			    cmd_out, cmd_out_len);
+ 	if (err)
+ 		goto other_cmd_free;
+ 
+ 	err = uverbs_copy_to(attrs, MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_OUT, cmd_out, cmd_out_len);
+ 
+ other_cmd_free:
+ 	kvfree(cmd_out);
+ 	return err;
+ }
+ 
+ static int devx_umem_get(struct mlx5_ib_dev *dev, struct ib_ucontext *ucontext,
+ 			 struct uverbs_attr_bundle *attrs,
+ 			 struct devx_umem *obj)
+ {
+ 	u64 addr;
+ 	size_t size;
+ 	u32 access;
+ 	int npages;
+ 	int err;
+ 	u32 page_mask;
+ 
+ 	if (uverbs_copy_from(&addr, attrs, MLX5_IB_ATTR_DEVX_UMEM_REG_ADDR) ||
+ 	    uverbs_copy_from(&size, attrs, MLX5_IB_ATTR_DEVX_UMEM_REG_LEN))
+ 		return -EFAULT;
+ 
+ 	err = uverbs_get_flags32(&access, attrs,
+ 				 MLX5_IB_ATTR_DEVX_UMEM_REG_ACCESS,
+ 				 IB_ACCESS_SUPPORTED);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ib_check_mr_access(access);
+ 	if (err)
+ 		return err;
+ 
+ 	obj->umem = ib_umem_get(ucontext, addr, size, access, 0);
+ 	if (IS_ERR(obj->umem))
+ 		return PTR_ERR(obj->umem);
+ 
+ 	mlx5_ib_cont_pages(obj->umem, obj->umem->address,
+ 			   MLX5_MKEY_PAGE_SHIFT_MASK, &npages,
+ 			   &obj->page_shift, &obj->ncont, NULL);
+ 
+ 	if (!npages) {
+ 		ib_umem_release(obj->umem);
+ 		return -EINVAL;
+ 	}
+ 
+ 	page_mask = (1 << obj->page_shift) - 1;
+ 	obj->page_offset = obj->umem->address & page_mask;
+ 
+ 	return 0;
+ }
+ 
+ static int devx_umem_reg_cmd_alloc(struct devx_umem *obj,
+ 				   struct devx_umem_reg_cmd *cmd)
+ {
+ 	cmd->inlen = MLX5_ST_SZ_BYTES(create_umem_in) +
+ 		    (MLX5_ST_SZ_BYTES(mtt) * obj->ncont);
+ 	cmd->in = kvzalloc(cmd->inlen, GFP_KERNEL);
+ 	return cmd->in ? 0 : -ENOMEM;
+ }
+ 
+ static void devx_umem_reg_cmd_free(struct devx_umem_reg_cmd *cmd)
+ {
+ 	kvfree(cmd->in);
+ }
+ 
+ static void devx_umem_reg_cmd_build(struct mlx5_ib_dev *dev,
+ 				    struct devx_umem *obj,
+ 				    struct devx_umem_reg_cmd *cmd)
+ {
+ 	void *umem;
+ 	__be64 *mtt;
+ 
+ 	umem = MLX5_ADDR_OF(create_umem_in, cmd->in, umem);
+ 	mtt = (__be64 *)MLX5_ADDR_OF(umem, umem, mtt);
+ 
+ 	MLX5_SET(general_obj_in_cmd_hdr, cmd->in, opcode, MLX5_CMD_OP_CREATE_GENERAL_OBJECT);
+ 	MLX5_SET(general_obj_in_cmd_hdr, cmd->in, obj_type, MLX5_OBJ_TYPE_UMEM);
+ 	MLX5_SET64(umem, umem, num_of_mtt, obj->ncont);
+ 	MLX5_SET(umem, umem, log_page_size, obj->page_shift -
+ 					    MLX5_ADAPTER_PAGE_SHIFT);
+ 	MLX5_SET(umem, umem, page_offset, obj->page_offset);
+ 	mlx5_ib_populate_pas(dev, obj->umem, obj->page_shift, mtt,
+ 			     (obj->umem->writable ? MLX5_IB_MTT_WRITE : 0) |
+ 			     MLX5_IB_MTT_READ);
+ }
+ 
+ static int UVERBS_HANDLER(MLX5_IB_METHOD_DEVX_UMEM_REG)(struct ib_device *ib_dev,
+ 				 struct ib_uverbs_file *file,
+ 				 struct uverbs_attr_bundle *attrs)
+ {
+ 	struct devx_umem_reg_cmd cmd;
+ 	struct devx_umem *obj;
+ 	struct ib_uobject *uobj = uverbs_attr_get_uobject(
+ 		attrs, MLX5_IB_ATTR_DEVX_UMEM_REG_HANDLE);
+ 	u32 obj_id;
+ 	struct mlx5_ib_ucontext *c = to_mucontext(uobj->context);
+ 	struct mlx5_ib_dev *dev = to_mdev(c->ibucontext.device);
+ 	int err;
+ 
+ 	if (!c->devx_uid)
+ 		return -EPERM;
+ 
+ 	obj = kzalloc(sizeof(struct devx_umem), GFP_KERNEL);
+ 	if (!obj)
+ 		return -ENOMEM;
+ 
+ 	err = devx_umem_get(dev, &c->ibucontext, attrs, obj);
+ 	if (err)
+ 		goto err_obj_free;
+ 
+ 	err = devx_umem_reg_cmd_alloc(obj, &cmd);
+ 	if (err)
+ 		goto err_umem_release;
+ 
+ 	devx_umem_reg_cmd_build(dev, obj, &cmd);
+ 
+ 	MLX5_SET(general_obj_in_cmd_hdr, cmd.in, uid, c->devx_uid);
+ 	err = mlx5_cmd_exec(dev->mdev, cmd.in, cmd.inlen, cmd.out,
+ 			    sizeof(cmd.out));
+ 	if (err)
+ 		goto err_umem_reg_cmd_free;
+ 
+ 	obj->mdev = dev->mdev;
+ 	uobj->object = obj;
+ 	devx_obj_build_destroy_cmd(cmd.in, cmd.out, obj->dinbox, &obj->dinlen, &obj_id);
+ 	err = uverbs_copy_to(attrs, MLX5_IB_ATTR_DEVX_UMEM_REG_OUT_ID, &obj_id, sizeof(obj_id));
+ 	if (err)
+ 		goto err_umem_destroy;
+ 
+ 	devx_umem_reg_cmd_free(&cmd);
+ 
+ 	return 0;
+ 
+ err_umem_destroy:
+ 	mlx5_cmd_exec(obj->mdev, obj->dinbox, obj->dinlen, cmd.out, sizeof(cmd.out));
+ err_umem_reg_cmd_free:
+ 	devx_umem_reg_cmd_free(&cmd);
+ err_umem_release:
+ 	ib_umem_release(obj->umem);
+ err_obj_free:
+ 	kfree(obj);
+ 	return err;
+ }
+ 
+ static int devx_umem_cleanup(struct ib_uobject *uobject,
+ 			     enum rdma_remove_reason why)
+ {
+ 	struct devx_umem *obj = uobject->object;
+ 	u32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)];
+ 	int err;
+ 
+ 	err = mlx5_cmd_exec(obj->mdev, obj->dinbox, obj->dinlen, out, sizeof(out));
+ 	if (ib_is_destroy_retryable(err, why, uobject))
+ 		return err;
+ 
+ 	ib_umem_release(obj->umem);
+ 	kfree(obj);
+ 	return 0;
+ }
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	MLX5_IB_METHOD_DEVX_UMEM_REG,
+ 	UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_UMEM_REG_HANDLE,
+ 			MLX5_IB_OBJECT_DEVX_UMEM,
+ 			UVERBS_ACCESS_NEW,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_DEVX_UMEM_REG_ADDR,
+ 			   UVERBS_ATTR_TYPE(u64),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_DEVX_UMEM_REG_LEN,
+ 			   UVERBS_ATTR_TYPE(u64),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_FLAGS_IN(MLX5_IB_ATTR_DEVX_UMEM_REG_ACCESS,
+ 			     enum ib_access_flags),
+ 	UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_DEVX_UMEM_REG_OUT_ID,
+ 			    UVERBS_ATTR_TYPE(u32),
+ 			    UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD_DESTROY(
+ 	MLX5_IB_METHOD_DEVX_UMEM_DEREG,
+ 	UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_UMEM_DEREG_HANDLE,
+ 			MLX5_IB_OBJECT_DEVX_UMEM,
+ 			UVERBS_ACCESS_DESTROY,
+ 			UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	MLX5_IB_METHOD_DEVX_QUERY_EQN,
+ 	UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_DEVX_QUERY_EQN_USER_VEC,
+ 			   UVERBS_ATTR_TYPE(u32),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_DEVX_QUERY_EQN_DEV_EQN,
+ 			    UVERBS_ATTR_TYPE(u32),
+ 			    UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	MLX5_IB_METHOD_DEVX_QUERY_UAR,
+ 	UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_DEVX_QUERY_UAR_USER_IDX,
+ 			   UVERBS_ATTR_TYPE(u32),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_DEVX_QUERY_UAR_DEV_IDX,
+ 			    UVERBS_ATTR_TYPE(u32),
+ 			    UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	MLX5_IB_METHOD_DEVX_OTHER,
+ 	UVERBS_ATTR_PTR_IN(
+ 		MLX5_IB_ATTR_DEVX_OTHER_CMD_IN,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
+ 		UA_MANDATORY,
+ 		UA_ALLOC_AND_COPY),
+ 	UVERBS_ATTR_PTR_OUT(
+ 		MLX5_IB_ATTR_DEVX_OTHER_CMD_OUT,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_out_cmd_hdr)),
+ 		UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	MLX5_IB_METHOD_DEVX_OBJ_CREATE,
+ 	UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_CREATE_HANDLE,
+ 			MLX5_IB_OBJECT_DEVX_OBJ,
+ 			UVERBS_ACCESS_NEW,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(
+ 		MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_IN,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
+ 		UA_MANDATORY,
+ 		UA_ALLOC_AND_COPY),
+ 	UVERBS_ATTR_PTR_OUT(
+ 		MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_OUT,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_out_cmd_hdr)),
+ 		UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD_DESTROY(
+ 	MLX5_IB_METHOD_DEVX_OBJ_DESTROY,
+ 	UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_DESTROY_HANDLE,
+ 			MLX5_IB_OBJECT_DEVX_OBJ,
+ 			UVERBS_ACCESS_DESTROY,
+ 			UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	MLX5_IB_METHOD_DEVX_OBJ_MODIFY,
+ 	UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_MODIFY_HANDLE,
+ 			MLX5_IB_OBJECT_DEVX_OBJ,
+ 			UVERBS_ACCESS_WRITE,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(
+ 		MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_IN,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
+ 		UA_MANDATORY,
+ 		UA_ALLOC_AND_COPY),
+ 	UVERBS_ATTR_PTR_OUT(
+ 		MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_OUT,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_out_cmd_hdr)),
+ 		UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	MLX5_IB_METHOD_DEVX_OBJ_QUERY,
+ 	UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_QUERY_HANDLE,
+ 			MLX5_IB_OBJECT_DEVX_OBJ,
+ 			UVERBS_ACCESS_READ,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(
+ 		MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_IN,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_in_cmd_hdr)),
+ 		UA_MANDATORY,
+ 		UA_ALLOC_AND_COPY),
+ 	UVERBS_ATTR_PTR_OUT(
+ 		MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_OUT,
+ 		UVERBS_ATTR_MIN_SIZE(MLX5_ST_SZ_BYTES(general_obj_out_cmd_hdr)),
+ 		UA_MANDATORY));
+ 
+ DECLARE_UVERBS_GLOBAL_METHODS(MLX5_IB_OBJECT_DEVX,
+ 			      &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OTHER),
+ 			      &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_QUERY_UAR),
+ 			      &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_QUERY_EQN));
+ 
+ DECLARE_UVERBS_NAMED_OBJECT(MLX5_IB_OBJECT_DEVX_OBJ,
+ 			    UVERBS_TYPE_ALLOC_IDR(devx_obj_cleanup),
+ 			    &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OBJ_CREATE),
+ 			    &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OBJ_DESTROY),
+ 			    &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OBJ_MODIFY),
+ 			    &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_OBJ_QUERY));
+ 
+ DECLARE_UVERBS_NAMED_OBJECT(MLX5_IB_OBJECT_DEVX_UMEM,
+ 			    UVERBS_TYPE_ALLOC_IDR(devx_umem_cleanup),
+ 			    &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_UMEM_REG),
+ 			    &UVERBS_METHOD(MLX5_IB_METHOD_DEVX_UMEM_DEREG));
+ 
+ DECLARE_UVERBS_OBJECT_TREE(devx_objects,
+ 			   &UVERBS_OBJECT(MLX5_IB_OBJECT_DEVX),
+ 			   &UVERBS_OBJECT(MLX5_IB_OBJECT_DEVX_OBJ),
+ 			   &UVERBS_OBJECT(MLX5_IB_OBJECT_DEVX_UMEM));
+ 
+ const struct uverbs_object_tree_def *mlx5_ib_get_devx_tree(void)
+ {
+ 	return &devx_objects;
+ }
++>>>>>>> bccd06223f21 (IB/uverbs: Add UVERBS_ATTR_FLAGS_IN to the specs language)
diff --cc drivers/infiniband/hw/mlx5/main.c
index 6d899fc16add,06d6309b719a..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -5303,22 -5515,25 +5302,31 @@@ static void mlx5_ib_cleanup_multiport_m
  	mlx5_nic_vport_disable_roce(dev->mdev);
  }
  
 -ADD_UVERBS_ATTRIBUTES_SIMPLE(
 -	mlx5_ib_dm,
 -	UVERBS_OBJECT_DM,
 -	UVERBS_METHOD_DM_ALLOC,
 -	UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_ALLOC_DM_RESP_START_OFFSET,
 -			    UVERBS_ATTR_TYPE(u64),
 -			    UA_MANDATORY),
 -	UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_ALLOC_DM_RESP_PAGE_INDEX,
 -			    UVERBS_ATTR_TYPE(u16),
 -			    UA_MANDATORY));
 -
 +ADD_UVERBS_ATTRIBUTES_SIMPLE(mlx5_ib_dm, UVERBS_OBJECT_DM,
 +			     UVERBS_METHOD_DM_ALLOC,
 +			     &UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_ALLOC_DM_RESP_START_OFFSET,
 +						  UVERBS_ATTR_TYPE(u64),
 +						  UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +			     &UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_ALLOC_DM_RESP_PAGE_INDEX,
 +						  UVERBS_ATTR_TYPE(u16),
 +						  UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
 +
++<<<<<<< HEAD
 +ADD_UVERBS_ATTRIBUTES_SIMPLE(mlx5_ib_flow_action, UVERBS_OBJECT_FLOW_ACTION,
 +			     UVERBS_METHOD_FLOW_ACTION_ESP_CREATE,
 +			     &UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_CREATE_FLOW_ACTION_FLAGS,
 +						 UVERBS_ATTR_TYPE(u64),
 +						 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
++=======
+ ADD_UVERBS_ATTRIBUTES_SIMPLE(
+ 	mlx5_ib_flow_action,
+ 	UVERBS_OBJECT_FLOW_ACTION,
+ 	UVERBS_METHOD_FLOW_ACTION_ESP_CREATE,
+ 	UVERBS_ATTR_FLAGS_IN(MLX5_IB_ATTR_CREATE_FLOW_ACTION_FLAGS,
+ 			     enum mlx5_ib_uapi_flow_action_flags));
++>>>>>>> bccd06223f21 (IB/uverbs: Add UVERBS_ATTR_FLAGS_IN to the specs language)
  
 -#define NUM_TREES	5
 +#define NUM_TREES	2
  static int populate_specs_root(struct mlx5_ib_dev *dev)
  {
  	const struct uverbs_object_tree_def *default_root[NUM_TREES + 1] = {
diff --cc include/rdma/uverbs_ioctl.h
index 90a4947ff548,5e6d0569d97c..000000000000
--- a/include/rdma/uverbs_ioctl.h
+++ b/include/rdma/uverbs_ioctl.h
@@@ -196,132 -187,127 +196,151 @@@ struct uverbs_object_tree_def 
  	const struct uverbs_object_def * const (*objects)[];
  };
  
 -/*
 - * =======================================
 - *	Attribute Specifications
 - * =======================================
 - */
 -
 -#define UVERBS_ATTR_SIZE(_min_len, _len)			\
 -	.u.ptr.min_len = _min_len, .u.ptr.len = _len
 -
 -#define UVERBS_ATTR_NO_DATA() UVERBS_ATTR_SIZE(0, 0)
 +#define UA_FLAGS(_flags)  .flags = _flags
 +#define __UVERBS_ATTR0(_id, _type, _fld, _attr, ...)              \
 +	((const struct uverbs_attr_def)				  \
 +	 {.id = _id, .attr = {{._fld = {.type = _type, _attr, .flags = 0, } }, } })
 +#define __UVERBS_ATTR1(_id, _type, _fld, _attr, _extra1, ...)      \
 +	((const struct uverbs_attr_def)				  \
 +	 {.id = _id, .attr = {{._fld = {.type = _type, _attr, _extra1 } },} })
 +#define __UVERBS_ATTR2(_id, _type, _fld, _attr, _extra1, _extra2)    \
 +	((const struct uverbs_attr_def)				  \
 +	 {.id = _id, .attr = {{._fld = {.type = _type, _attr, _extra1, _extra2 } },} })
 +#define __UVERBS_ATTR(_id, _type, _fld, _attr, _extra1, _extra2, _n, ...)	\
 +	__UVERBS_ATTR##_n(_id, _type, _fld, _attr, _extra1, _extra2)
  
 -/*
 - * Specifies a uapi structure that cannot be extended. The user must always
 - * supply the whole structure and nothing more. The structure must be declared
 - * in a header under include/uapi/rdma.
 - */
  #define UVERBS_ATTR_TYPE(_type)					\
 -	.u.ptr.min_len = sizeof(_type), .u.ptr.len = sizeof(_type)
 -/*
 - * Specifies a uapi structure where the user must provide at least up to
 - * member 'last'.  Anything after last and up until the end of the structure
 - * can be non-zero, anything longer than the end of the structure must be
 - * zero. The structure must be declared in a header under include/uapi/rdma.
 - */
 -#define UVERBS_ATTR_STRUCT(_type, _last)                                       \
 -	.zero_trailing = 1,                                                    \
 -	UVERBS_ATTR_SIZE(((uintptr_t)(&((_type *)0)->_last + 1)),              \
 -			 sizeof(_type))
 -/*
 - * Specifies at least min_len bytes must be passed in, but the amount can be
 - * larger, up to the protocol maximum size. No check for zeroing is done.
 - */
 -#define UVERBS_ATTR_MIN_SIZE(_min_len) UVERBS_ATTR_SIZE(_min_len, USHRT_MAX)
 -
 -/* Must be used in the '...' of any UVERBS_ATTR */
 -#define UA_ALLOC_AND_COPY .alloc_and_copy = 1
 -#define UA_MANDATORY .mandatory = 1
 -#define UA_OPTIONAL .mandatory = 0
 -
 -#define UVERBS_ATTR_IDR(_attr_id, _idr_type, _access, ...)                     \
 -	(&(const struct uverbs_attr_def){                                      \
 -		.id = _attr_id,                                                \
 -		.attr = { .type = UVERBS_ATTR_TYPE_IDR,                        \
 -			  .u.obj.obj_type = _idr_type,                         \
 -			  .u.obj.access = _access,                             \
 -			  __VA_ARGS__ } })
 -
 -#define UVERBS_ATTR_FD(_attr_id, _fd_type, _access, ...)                       \
 -	(&(const struct uverbs_attr_def){                                      \
 -		.id = (_attr_id) +                                             \
 -		      BUILD_BUG_ON_ZERO((_access) != UVERBS_ACCESS_NEW &&      \
 -					(_access) != UVERBS_ACCESS_READ),      \
 -		.attr = { .type = UVERBS_ATTR_TYPE_FD,                         \
 -			  .u.obj.obj_type = _fd_type,                          \
 -			  .u.obj.access = _access,                             \
 -			  __VA_ARGS__ } })
 -
 -#define UVERBS_ATTR_PTR_IN(_attr_id, _type, ...)                               \
 -	(&(const struct uverbs_attr_def){                                      \
 -		.id = _attr_id,                                                \
 -		.attr = { .type = UVERBS_ATTR_TYPE_PTR_IN,                     \
 -			  _type,                                               \
 -			  __VA_ARGS__ } })
 -
 -#define UVERBS_ATTR_PTR_OUT(_attr_id, _type, ...)                              \
 -	(&(const struct uverbs_attr_def){                                      \
 -		.id = _attr_id,                                                \
 -		.attr = { .type = UVERBS_ATTR_TYPE_PTR_OUT,                    \
 -			  _type,                                               \
 -			  __VA_ARGS__ } })
 -
 -/* _enum_arry should be a 'static const union uverbs_attr_spec[]' */
 -#define UVERBS_ATTR_ENUM_IN(_attr_id, _enum_arr, ...)                          \
 -	(&(const struct uverbs_attr_def){                                      \
 -		.id = _attr_id,                                                \
 -		.attr = { .type = UVERBS_ATTR_TYPE_ENUM_IN,                    \
 -			  .u2.enum_def.ids = _enum_arr,                        \
 -			  .u.enum_def.num_elems = ARRAY_SIZE(_enum_arr),       \
 -			  __VA_ARGS__ },                                       \
 -	})
 +	.min_len = sizeof(_type), .len = sizeof(_type)
 +#define UVERBS_ATTR_STRUCT(_type, _last)			\
 +	.min_len = ((uintptr_t)(&((_type *)0)->_last + 1)), .len = sizeof(_type)
 +#define UVERBS_ATTR_SIZE(_min_len, _len)			\
 +	.min_len = _min_len, .len = _len
 +#define UVERBS_ATTR_MIN_SIZE(_min_len)				\
 +	UVERBS_ATTR_SIZE(_min_len, USHRT_MAX)
  
  /*
++<<<<<<< HEAD
 + * In new compiler, UVERBS_ATTR could be simplified by declaring it as
 + * [_id] = {.type = _type, .len = _len, ##__VA_ARGS__}
 + * But since we support older compilers too, we need the more complex code.
++=======
+  * An input value that is a bitwise combination of values of _enum_type.
+  * This permits the flag value to be passed as either a u32 or u64, it must
+  * be retrieved via uverbs_get_flag().
+  */
+ #define UVERBS_ATTR_FLAGS_IN(_attr_id, _enum_type, ...)                        \
+ 	UVERBS_ATTR_PTR_IN(                                                    \
+ 		_attr_id,                                                      \
+ 		UVERBS_ATTR_SIZE(sizeof(u32) + BUILD_BUG_ON_ZERO(              \
+ 						       !sizeof(_enum_type *)), \
+ 				 sizeof(u64)),                                 \
+ 		__VA_ARGS__)
+ 
+ /*
+  * This spec is used in order to pass information to the hardware driver in a
+  * legacy way. Every verb that could get driver specific data should get this
+  * spec.
++>>>>>>> bccd06223f21 (IB/uverbs: Add UVERBS_ATTR_FLAGS_IN to the specs language)
   */
 -#define UVERBS_ATTR_UHW()                                                      \
 -	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_UHW_IN,                                 \
 -			   UVERBS_ATTR_MIN_SIZE(0),			       \
 -			   UA_OPTIONAL),				       \
 -	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_UHW_OUT,                               \
 -			    UVERBS_ATTR_MIN_SIZE(0),			       \
 -			    UA_OPTIONAL)
 +#define UVERBS_ATTR(_id, _type, _fld, _attr, ...)			\
 +	__UVERBS_ATTR(_id, _type, _fld, _attr, ##__VA_ARGS__, 2, 1, 0)
 +#define UVERBS_ATTR_PTR_IN_SZ(_id, _len, ...)				\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_PTR_IN, ptr, _len, ##__VA_ARGS__)
 +/* If sizeof(_type) <= sizeof(u64), this will be inlined rather than a pointer */
 +#define UVERBS_ATTR_PTR_IN(_id, _type, ...)				\
 +	UVERBS_ATTR_PTR_IN_SZ(_id, _type, ##__VA_ARGS__)
 +#define UVERBS_ATTR_PTR_OUT_SZ(_id, _len, ...)				\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_PTR_OUT, ptr, _len, ##__VA_ARGS__)
 +#define UVERBS_ATTR_PTR_OUT(_id, _type, ...)				\
 +	UVERBS_ATTR_PTR_OUT_SZ(_id, _type, ##__VA_ARGS__)
 +#define UVERBS_ATTR_ENUM_IN(_id, _enum_arr, ...)			\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_ENUM_IN, enum_def,		\
 +		    .ids = (_enum_arr),					\
 +		    .num_elems = ARRAY_SIZE(_enum_arr), ##__VA_ARGS__)
  
  /*
 - * =======================================
 - *	Declaration helpers
 - * =======================================
 + * In new compiler, UVERBS_ATTR_IDR (and FD) could be simplified by declaring
 + * it as
 + * {.id = _id,								\
 + *  .attr {.type = __obj_class,						\
 + *         .obj = {.obj_type = _idr_type,				\
 + *                       .access = _access                              \
 + *                }, ##__VA_ARGS__ } }
 + * But since we support older compilers too, we need the more complex code.
   */
 -
 -#define DECLARE_UVERBS_OBJECT_TREE(_name, ...)                                 \
 -	static const struct uverbs_object_def *const _name##_ptr[] = {         \
 -		__VA_ARGS__,                                                   \
 -	};                                                                     \
 -	static const struct uverbs_object_tree_def _name = {                   \
 -		.num_objects = ARRAY_SIZE(_name##_ptr),                        \
 -		.objects = &_name##_ptr,                                       \
 +#define ___UVERBS_ATTR_OBJ0(_id, _obj_class, _obj_type, _access, ...)\
 +	((const struct uverbs_attr_def)					\
 +	{.id = _id,							\
 +	 .attr = { {.obj = {.type = _obj_class, .obj_type = _obj_type,	\
 +			    .access = _access, .flags = 0 } }, } })
 +#define ___UVERBS_ATTR_OBJ1(_id, _obj_class, _obj_type, _access, _flags)\
 +	((const struct uverbs_attr_def)					\
 +	{.id = _id,							\
 +	.attr = { {.obj = {.type = _obj_class, .obj_type = _obj_type,	\
 +			   .access = _access, _flags} }, } })
 +#define ___UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access, _flags, \
 +			   _n, ...)					\
 +	___UVERBS_ATTR_OBJ##_n(_id, _obj_class, _obj_type, _access, _flags)
 +#define __UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access, ...)	\
 +	___UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access,		\
 +			   ##__VA_ARGS__, 1, 0)
 +#define UVERBS_ATTR_IDR(_id, _idr_type, _access, ...)			 \
 +	__UVERBS_ATTR_OBJ(_id, UVERBS_ATTR_TYPE_IDR, _idr_type, _access,\
 +			  ##__VA_ARGS__)
 +#define UVERBS_ATTR_FD(_id, _fd_type, _access, ...)			\
 +	__UVERBS_ATTR_OBJ(_id, UVERBS_ATTR_TYPE_FD, _fd_type,		\
 +			  (_access) + BUILD_BUG_ON_ZERO(		\
 +				(_access) != UVERBS_ACCESS_NEW &&	\
 +				(_access) != UVERBS_ACCESS_READ),	\
 +			  ##__VA_ARGS__)
 +#define DECLARE_UVERBS_ATTR_SPEC(_name, ...)				\
 +	const struct uverbs_attr_def _name = __VA_ARGS__
 +
 +#define DECLARE_UVERBS_ENUM(_name, ...)					\
 +	const struct uverbs_enum_spec _name = {				\
 +		.len = ARRAY_SIZE(((struct uverbs_attr_spec[]){__VA_ARGS__})),\
 +		.ids = {__VA_ARGS__},					\
  	}
 +#define _UVERBS_METHOD_ATTRS_SZ(...)					\
 +	(sizeof((const struct uverbs_attr_def * const []){__VA_ARGS__}) /\
 +	 sizeof(const struct uverbs_attr_def *))
 +#define _UVERBS_METHOD(_id, _handler, _flags, ...)			\
 +	((const struct uverbs_method_def) {				\
 +	 .id = _id,							\
 +	 .flags = _flags,						\
 +	 .handler = _handler,						\
 +	 .num_attrs = _UVERBS_METHOD_ATTRS_SZ(__VA_ARGS__),		\
 +	 .attrs = &(const struct uverbs_attr_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_METHOD(_name, _id, _handler, ...)		\
 +	const struct uverbs_method_def _name =				\
 +		_UVERBS_METHOD(_id, _handler, 0, ##__VA_ARGS__)
 +#define DECLARE_UVERBS_CTX_METHOD(_name, _id, _handler, _flags, ...)	\
 +	const struct uverbs_method_def _name =				\
 +		_UVERBS_METHOD(_id, _handler,				\
 +			       UVERBS_ACTION_FLAG_CREATE_ROOT,		\
 +			       ##__VA_ARGS__)
 +#define _UVERBS_OBJECT_METHODS_SZ(...)					\
 +	(sizeof((const struct uverbs_method_def * const []){__VA_ARGS__}) / \
 +	 sizeof(const struct uverbs_method_def *))
 +#define _UVERBS_OBJECT(_id, _type_attrs, ...)				\
 +	((const struct uverbs_object_def) {				\
 +	 .id = _id,							\
 +	 .type_attrs = _type_attrs,					\
 +	 .num_methods = _UVERBS_OBJECT_METHODS_SZ(__VA_ARGS__),		\
 +	 .methods = &(const struct uverbs_method_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_OBJECT(_name, _id, _type_attrs, ...)		\
 +	const struct uverbs_object_def _name =				\
 +		_UVERBS_OBJECT(_id, _type_attrs, ##__VA_ARGS__)
 +#define _UVERBS_TREE_OBJECTS_SZ(...)					\
 +	(sizeof((const struct uverbs_object_def * const []){__VA_ARGS__}) / \
 +	 sizeof(const struct uverbs_object_def *))
 +#define _UVERBS_OBJECT_TREE(...)					\
 +	((const struct uverbs_object_tree_def) {			\
 +	 .num_objects = _UVERBS_TREE_OBJECTS_SZ(__VA_ARGS__),		\
 +	 .objects = &(const struct uverbs_object_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_OBJECT_TREE(_name, ...)				\
 +	const struct uverbs_object_tree_def _name =			\
 +		_UVERBS_OBJECT_TREE(__VA_ARGS__)
  
  /* =================================================
   *              Parsing infrastructure
diff --git a/drivers/infiniband/core/uverbs_ioctl.c b/drivers/infiniband/core/uverbs_ioctl.c
index 03065bad8dae..74572fc64196 100644
--- a/drivers/infiniband/core/uverbs_ioctl.c
+++ b/drivers/infiniband/core/uverbs_ioctl.c
@@ -491,3 +491,54 @@ long ib_uverbs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 
 	return err;
 }
+
+int uverbs_get_flags64(u64 *to, const struct uverbs_attr_bundle *attrs_bundle,
+		       size_t idx, u64 allowed_bits)
+{
+	const struct uverbs_attr *attr;
+	u64 flags;
+
+	attr = uverbs_attr_get(attrs_bundle, idx);
+	/* Missing attribute means 0 flags */
+	if (IS_ERR(attr)) {
+		*to = 0;
+		return 0;
+	}
+
+	/*
+	 * New userspace code should use 8 bytes to pass flags, but we
+	 * transparently support old userspaces that were using 4 bytes as
+	 * well.
+	 */
+	if (attr->ptr_attr.len == 8)
+		flags = attr->ptr_attr.data;
+	else if (attr->ptr_attr.len == 4)
+		memcpy(&flags, &attr->ptr_attr.data, 4);
+	else
+		return -EINVAL;
+
+	if (flags & ~allowed_bits)
+		return -EINVAL;
+
+	*to = flags;
+	return 0;
+}
+EXPORT_SYMBOL(uverbs_get_flags64);
+
+int uverbs_get_flags32(u32 *to, const struct uverbs_attr_bundle *attrs_bundle,
+		       size_t idx, u64 allowed_bits)
+{
+	u64 flags;
+	int ret;
+
+	ret = uverbs_get_flags64(&flags, attrs_bundle, idx, allowed_bits);
+	if (ret)
+		return ret;
+
+	if (flags > U32_MAX)
+		return -EINVAL;
+	*to = flags;
+
+	return 0;
+}
+EXPORT_SYMBOL(uverbs_get_flags32);
* Unmerged path drivers/infiniband/core/uverbs_std_types_counters.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_cq.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_mr.c
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
* Unmerged path drivers/infiniband/hw/mlx5/main.c
* Unmerged path include/rdma/uverbs_ioctl.h
