RDMA/cxgb4: Remove kref accounting for sync operation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Leon Romanovsky <leon@kernel.org>
commit cfe876d8e6b0491170d44c8040c518b121957104
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/cfe876d8.failed

Ucontext allocation and release aren't async events and don't need kref
accounting. The common layer of RDMA subsystem ensures that dealloc
ucontext will be called after all other objects are released.

	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Reviewed-by: Steve Wise <swise@opengridcomputing.com>
	Tested-by: Raju Rangoju <rajur@chelsio.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit cfe876d8e6b0491170d44c8040c518b121957104)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/cxgb4/provider.c
diff --cc drivers/infiniband/hw/cxgb4/provider.c
index fcc2f7a70397,81fcffb597ab..000000000000
--- a/drivers/infiniband/hw/cxgb4/provider.c
+++ b/drivers/infiniband/hw/cxgb4/provider.c
@@@ -58,44 -58,9 +58,48 @@@ static int fastreg_support = 1
  module_param(fastreg_support, int, 0644);
  MODULE_PARM_DESC(fastreg_support, "Advertise fastreg support (default=1)");
  
++<<<<<<< HEAD
 +static struct ib_ah *c4iw_ah_create(struct ib_pd *pd,
 +				    struct rdma_ah_attr *ah_attr,
 +				    struct ib_udata *udata)
 +
 +{
 +	return ERR_PTR(-ENOSYS);
 +}
 +
 +static int c4iw_ah_destroy(struct ib_ah *ah)
 +{
 +	return -ENOSYS;
 +}
 +
 +static int c4iw_multicast_attach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)
 +{
 +	return -ENOSYS;
 +}
 +
 +static int c4iw_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)
 +{
 +	return -ENOSYS;
 +}
 +
 +static int c4iw_process_mad(struct ib_device *ibdev, int mad_flags,
 +			    u8 port_num, const struct ib_wc *in_wc,
 +			    const struct ib_grh *in_grh,
 +			    const struct ib_mad_hdr *in_mad,
 +			    size_t in_mad_size,
 +			    struct ib_mad_hdr *out_mad,
 +			    size_t *out_mad_size,
 +			    u16 *out_mad_pkey_index)
 +{
 +	return -ENOSYS;
 +}
 +
 +void _c4iw_free_ucontext(struct kref *kref)
++=======
+ static int c4iw_dealloc_ucontext(struct ib_ucontext *context)
++>>>>>>> cfe876d8e6b0 (RDMA/cxgb4: Remove kref accounting for sync operation)
  {
- 	struct c4iw_ucontext *ucontext;
+ 	struct c4iw_ucontext *ucontext = to_c4iw_ucontext(context);
  	struct c4iw_dev *rhp;
  	struct c4iw_mm_entry *mm, *tmp;
  
diff --git a/drivers/infiniband/hw/cxgb4/iw_cxgb4.h b/drivers/infiniband/hw/cxgb4/iw_cxgb4.h
index 3235052a122e..fccb7dc98a4d 100644
--- a/drivers/infiniband/hw/cxgb4/iw_cxgb4.h
+++ b/drivers/infiniband/hw/cxgb4/iw_cxgb4.h
@@ -589,7 +589,6 @@ struct c4iw_ucontext {
 	u32 key;
 	spinlock_t mmap_lock;
 	struct list_head mmaps;
-	struct kref kref;
 	bool is_32b_cqe;
 };
 
@@ -598,18 +597,6 @@ static inline struct c4iw_ucontext *to_c4iw_ucontext(struct ib_ucontext *c)
 	return container_of(c, struct c4iw_ucontext, ibucontext);
 }
 
-void _c4iw_free_ucontext(struct kref *kref);
-
-static inline void c4iw_put_ucontext(struct c4iw_ucontext *ucontext)
-{
-	kref_put(&ucontext->kref, _c4iw_free_ucontext);
-}
-
-static inline void c4iw_get_ucontext(struct c4iw_ucontext *ucontext)
-{
-	kref_get(&ucontext->kref);
-}
-
 struct c4iw_mm_entry {
 	struct list_head entry;
 	u64 addr;
* Unmerged path drivers/infiniband/hw/cxgb4/provider.c
diff --git a/drivers/infiniband/hw/cxgb4/qp.c b/drivers/infiniband/hw/cxgb4/qp.c
index 9ad44d431983..211448fc94db 100644
--- a/drivers/infiniband/hw/cxgb4/qp.c
+++ b/drivers/infiniband/hw/cxgb4/qp.c
@@ -852,8 +852,6 @@ static void free_qp_work(struct work_struct *work)
 	destroy_qp(&rhp->rdev, &qhp->wq,
 		   ucontext ? &ucontext->uctx : &rhp->rdev.uctx);
 
-	if (ucontext)
-		c4iw_put_ucontext(ucontext);
 	c4iw_put_wr_wait(qhp->wr_waitp);
 	kfree(qhp);
 }
@@ -2159,7 +2157,6 @@ struct ib_qp *c4iw_create_qp(struct ib_pd *pd, struct ib_qp_init_attr *attrs,
 			insert_mmap(ucontext, ma_sync_key_mm);
 		}
 
-		c4iw_get_ucontext(ucontext);
 		qhp->ucontext = ucontext;
 	}
 	qhp->ibqp.qp_num = qhp->wq.sq.qid;
