net/mlx5e: Handle port mtu/link, dcb and lag for uplink reps

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Or Gerlitz <ogerlitz@mellanox.com>
commit b36cdb42ad4b114d4b9bbba8770d7a4b8e1a62f6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/b36cdb42.failed

Take care of setup/teardown for the port link, dcb, lag as well as
dealing with port mtu and carrier for e-switch uplink representors.

This is achieved by adding a dedicated profile instance for uplink
representors which includes the enable/disable and more profile routines
which are invoked by the general mlx5e code for netdev attach/detach.

	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit b36cdb42ad4b114d4b9bbba8770d7a4b8e1a62f6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en.h
index d2c773481d2f,71c0646c8108..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@@ -927,9 -940,10 +927,13 @@@ int mlx5e_create_tis(struct mlx5_core_d
  void mlx5e_destroy_tis(struct mlx5_core_dev *mdev, u32 tisn);
  
  int mlx5e_create_tises(struct mlx5e_priv *priv);
++<<<<<<< HEAD
 +void mlx5e_cleanup_nic_tx(struct mlx5e_priv *priv);
++=======
+ void mlx5e_update_carrier(struct mlx5e_priv *priv);
++>>>>>>> b36cdb42ad4b (net/mlx5e: Handle port mtu/link, dcb and lag for uplink reps)
  int mlx5e_close(struct net_device *netdev);
  int mlx5e_open(struct net_device *netdev);
 -void mlx5e_update_ndo_stats(struct mlx5e_priv *priv);
  
  void mlx5e_queue_update_stats(struct mlx5e_priv *priv);
  int mlx5e_bits_invert(unsigned long a, int size);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index 58cddf0a96a7,e676660826fc..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -1070,30 -1189,64 +1070,83 @@@ mlx5e_rep_get_stats(struct net_device *
  	memcpy(stats, &priv->stats.vf_vport, sizeof(*stats));
  }
  
++<<<<<<< HEAD
++=======
+ static int mlx5e_vf_rep_change_mtu(struct net_device *netdev, int new_mtu)
+ {
+ 	return mlx5e_change_mtu(netdev, new_mtu, NULL);
+ }
+ 
+ static int mlx5e_uplink_rep_change_mtu(struct net_device *netdev, int new_mtu)
+ {
+ 	return mlx5e_change_mtu(netdev, new_mtu, mlx5e_set_dev_port_mtu);
+ }
+ 
+ static int mlx5e_uplink_rep_set_mac(struct net_device *netdev, void *addr)
+ {
+ 	struct sockaddr *saddr = addr;
+ 
+ 	if (!is_valid_ether_addr(saddr->sa_data))
+ 		return -EADDRNOTAVAIL;
+ 
+ 	ether_addr_copy(netdev->dev_addr, saddr->sa_data);
+ 	return 0;
+ }
+ 
++>>>>>>> b36cdb42ad4b (net/mlx5e: Handle port mtu/link, dcb and lag for uplink reps)
  static const struct switchdev_ops mlx5e_rep_switchdev_ops = {
  	.switchdev_port_attr_get	= mlx5e_attr_get,
  };
  
++<<<<<<< HEAD
 +static int mlx5e_change_rep_mtu(struct net_device *netdev, int new_mtu)
++=======
+ static const struct net_device_ops mlx5e_netdev_ops_vf_rep = {
+ 	.ndo_open                = mlx5e_vf_rep_open,
+ 	.ndo_stop                = mlx5e_vf_rep_close,
+ 	.ndo_start_xmit          = mlx5e_xmit,
+ 	.ndo_get_phys_port_name  = mlx5e_rep_get_phys_port_name,
+ 	.ndo_setup_tc            = mlx5e_rep_setup_tc,
+ 	.ndo_get_stats64         = mlx5e_vf_rep_get_stats,
+ 	.ndo_has_offload_stats	 = mlx5e_rep_has_offload_stats,
+ 	.ndo_get_offload_stats	 = mlx5e_rep_get_offload_stats,
+ 	.ndo_change_mtu          = mlx5e_vf_rep_change_mtu,
+ };
+ 
+ static const struct net_device_ops mlx5e_netdev_ops_uplink_rep = {
+ 	.ndo_open                = mlx5e_open,
+ 	.ndo_stop                = mlx5e_close,
+ 	.ndo_start_xmit          = mlx5e_xmit,
+ 	.ndo_set_mac_address     = mlx5e_uplink_rep_set_mac,
+ 	.ndo_get_phys_port_name  = mlx5e_rep_get_phys_port_name,
+ 	.ndo_setup_tc            = mlx5e_rep_setup_tc,
+ 	.ndo_get_stats64         = mlx5e_get_stats,
+ 	.ndo_has_offload_stats	 = mlx5e_rep_has_offload_stats,
+ 	.ndo_get_offload_stats	 = mlx5e_rep_get_offload_stats,
+ 	.ndo_change_mtu          = mlx5e_uplink_rep_change_mtu,
+ };
+ 
+ static void mlx5e_build_rep_params(struct net_device *netdev)
++>>>>>>> b36cdb42ad4b (net/mlx5e: Handle port mtu/link, dcb and lag for uplink reps)
  {
 -	struct mlx5e_priv *priv = netdev_priv(netdev);
 -	struct mlx5e_rep_priv *rpriv = priv->ppriv;
 -	struct mlx5_eswitch_rep *rep = rpriv->rep;
 -	struct mlx5_core_dev *mdev = priv->mdev;
 -	struct mlx5e_params *params;
 +	return mlx5e_change_mtu(netdev, new_mtu, NULL);
 +}
 +
 +static const struct net_device_ops mlx5e_netdev_ops_rep = {
 +	.ndo_open                = mlx5e_rep_open,
 +	.ndo_stop                = mlx5e_rep_close,
 +	.ndo_start_xmit          = mlx5e_xmit,
 +	.ndo_get_phys_port_name  = mlx5e_rep_get_phys_port_name,
 +	.ndo_setup_tc            = mlx5e_rep_setup_tc,
 +	.ndo_get_stats64         = mlx5e_rep_get_stats,
 +	.ndo_has_offload_stats	 = mlx5e_has_offload_stats,
 +	.ndo_get_offload_stats	 = mlx5e_get_offload_stats,
 +	.ndo_change_mtu          = mlx5e_change_rep_mtu,
 +};
  
 +static void mlx5e_build_rep_params(struct mlx5_core_dev *mdev,
 +				   struct mlx5e_params *params, u16 mtu)
 +{
  	u8 cq_period_mode = MLX5_CAP_GEN(mdev, cq_period_start_from_cqe) ?
  					 MLX5_CQ_PERIOD_MODE_START_FROM_CQE :
  					 MLX5_CQ_PERIOD_MODE_START_FROM_EQE;
@@@ -1117,10 -1279,23 +1170,25 @@@
  static void mlx5e_build_rep_netdev(struct net_device *netdev)
  {
  	struct mlx5e_priv *priv = netdev_priv(netdev);
 -	struct mlx5e_rep_priv *rpriv = priv->ppriv;
 -	struct mlx5_eswitch_rep *rep = rpriv->rep;
  	struct mlx5_core_dev *mdev = priv->mdev;
- 	u16 max_mtu;
  
++<<<<<<< HEAD
 +	netdev->netdev_ops = &mlx5e_netdev_ops_rep;
++=======
+ 	if (rep->vport == FDB_UPLINK_VPORT) {
+ 		SET_NETDEV_DEV(netdev, &priv->mdev->pdev->dev);
+ 		netdev->netdev_ops = &mlx5e_netdev_ops_uplink_rep;
+ 		/* we want a persistent mac for the uplink rep */
+ 		mlx5_query_nic_vport_mac_address(mdev, 0, netdev->dev_addr);
+ #ifdef CONFIG_MLX5_CORE_EN_DCB
+ 		if (MLX5_CAP_GEN(mdev, qos))
+ 			netdev->dcbnl_ops = &mlx5e_dcbnl_ops;
+ #endif
+ 	} else {
+ 		netdev->netdev_ops = &mlx5e_netdev_ops_vf_rep;
+ 		eth_hw_addr_random(netdev);
+ 	}
++>>>>>>> b36cdb42ad4b (net/mlx5e: Handle port mtu/link, dcb and lag for uplink reps)
  
  	netdev->watchdog_timeo    = 15 * HZ;
  
@@@ -1140,12 -1315,15 +1208,15 @@@
  	netdev->hw_features    |= NETIF_F_RXCSUM;
  
  	netdev->features |= netdev->hw_features;
 -}
++<<<<<<< HEAD
  
 -static int mlx5e_rep_get_default_num_channels(struct mlx5_eswitch_rep *rep,
 -					      struct net_device *netdev)
 -{
 -	if (rep->vport == FDB_UPLINK_VPORT)
 -		return mlx5e_get_netdev_max_channels(netdev);
 -	else
 -		return 1;
 +	eth_hw_addr_random(netdev);
 +
 +	netdev->min_mtu = ETH_MIN_MTU;
 +	mlx5_query_port_max_mtu(mdev, &max_mtu, 1);
 +	netdev->max_mtu = MLX5E_HW2SW_MTU(&priv->channels.params, max_mtu);
++=======
++>>>>>>> b36cdb42ad4b (net/mlx5e: Handle port mtu/link, dcb and lag for uplink reps)
  }
  
  static int mlx5e_init_rep(struct mlx5_core_dev *mdev,
@@@ -1249,102 -1474,164 +1320,191 @@@ static int mlx5e_init_rep_tx(struct mlx
  		mlx5_core_warn(priv->mdev, "create tises failed, %d\n", err);
  		return err;
  	}
 -
 -	if (rpriv->rep->vport == FDB_UPLINK_VPORT) {
 -		uplink_priv = &rpriv->uplink_priv;
 -
 -		/* init shared tc flow table */
 -		err = mlx5e_tc_esw_init(&uplink_priv->tc_ht);
 -		if (err)
 -			goto destroy_tises;
 -
 -		/* init indirect block notifications */
 -		INIT_LIST_HEAD(&uplink_priv->tc_indr_block_priv_list);
 -		uplink_priv->netdevice_nb.notifier_call = mlx5e_nic_rep_netdevice_event;
 -		err = register_netdevice_notifier(&uplink_priv->netdevice_nb);
 -		if (err) {
 -			mlx5_core_err(priv->mdev, "Failed to register netdev notifier\n");
 -			goto tc_esw_cleanup;
 -		}
 -	}
 -
  	return 0;
 -
 -tc_esw_cleanup:
 -	mlx5e_tc_esw_cleanup(&uplink_priv->tc_ht);
 -destroy_tises:
 -	for (tc = 0; tc < priv->profile->max_tc; tc++)
 -		mlx5e_destroy_tis(priv->mdev, priv->tisn[tc]);
 -	return err;
 -}
 -
 -static void mlx5e_cleanup_rep_tx(struct mlx5e_priv *priv)
 -{
 -	struct mlx5e_rep_priv *rpriv = priv->ppriv;
 -	int tc;
 -
 -	for (tc = 0; tc < priv->profile->max_tc; tc++)
 -		mlx5e_destroy_tis(priv->mdev, priv->tisn[tc]);
 -
 -	if (rpriv->rep->vport == FDB_UPLINK_VPORT) {
 -		/* clean indirect TC block notifications */
 -		unregister_netdevice_notifier(&rpriv->uplink_priv.netdevice_nb);
 -		mlx5e_rep_indr_clean_block_privs(rpriv);
 -
 -		/* delete shared tc flow table */
 -		mlx5e_tc_esw_cleanup(&rpriv->uplink_priv.tc_ht);
 -	}
  }
  
- static const struct mlx5e_profile mlx5e_rep_profile = {
+ static void mlx5e_vf_rep_enable(struct mlx5e_priv *priv)
+ {
+ 	struct net_device *netdev = priv->netdev;
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	u16 max_mtu;
+ 
+ 	netdev->min_mtu = ETH_MIN_MTU;
+ 	mlx5_query_port_max_mtu(mdev, &max_mtu, 1);
+ 	netdev->max_mtu = MLX5E_HW2SW_MTU(&priv->channels.params, max_mtu);
+ }
+ 
+ static int uplink_rep_async_event(struct notifier_block *nb, unsigned long event, void *data)
+ {
+ 	struct mlx5e_priv *priv = container_of(nb, struct mlx5e_priv, events_nb);
+ 	struct mlx5_eqe   *eqe = data;
+ 
+ 	if (event != MLX5_EVENT_TYPE_PORT_CHANGE)
+ 		return NOTIFY_DONE;
+ 
+ 	switch (eqe->sub_type) {
+ 	case MLX5_PORT_CHANGE_SUBTYPE_DOWN:
+ 	case MLX5_PORT_CHANGE_SUBTYPE_ACTIVE:
+ 		queue_work(priv->wq, &priv->update_carrier_work);
+ 		break;
+ 	default:
+ 		return NOTIFY_DONE;
+ 	}
+ 
+ 	return NOTIFY_OK;
+ }
+ 
+ static void mlx5e_uplink_rep_enable(struct mlx5e_priv *priv)
+ {
+ 	struct net_device *netdev = priv->netdev;
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	u16 max_mtu;
+ 
+ 	netdev->min_mtu = ETH_MIN_MTU;
+ 	mlx5_query_port_max_mtu(priv->mdev, &max_mtu, 1);
+ 	netdev->max_mtu = MLX5E_HW2SW_MTU(&priv->channels.params, max_mtu);
+ 	mlx5e_set_dev_port_mtu(priv);
+ 
+ 	mlx5_lag_add(mdev, netdev);
+ 	priv->events_nb.notifier_call = uplink_rep_async_event;
+ 	mlx5_notifier_register(mdev, &priv->events_nb);
+ #ifdef CONFIG_MLX5_CORE_EN_DCB
+ 	mlx5e_dcbnl_initialize(priv);
+ 	mlx5e_dcbnl_init_app(priv);
+ #endif
+ }
+ 
+ static void mlx5e_uplink_rep_disable(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 
+ #ifdef CONFIG_MLX5_CORE_EN_DCB
+ 	mlx5e_dcbnl_delete_app(priv);
+ #endif
+ 	mlx5_notifier_unregister(mdev, &priv->events_nb);
+ 	mlx5_lag_remove(mdev);
+ }
+ 
+ static const struct mlx5e_profile mlx5e_vf_rep_profile = {
  	.init			= mlx5e_init_rep,
  	.cleanup		= mlx5e_cleanup_rep,
  	.init_rx		= mlx5e_init_rep_rx,
  	.cleanup_rx		= mlx5e_cleanup_rep_rx,
  	.init_tx		= mlx5e_init_rep_tx,
++<<<<<<< HEAD
 +	.cleanup_tx		= mlx5e_cleanup_nic_tx,
 +	.update_stats           = mlx5e_rep_update_hw_counters,
 +	.update_carrier		= NULL,
++=======
+ 	.cleanup_tx		= mlx5e_cleanup_rep_tx,
+ 	.enable		        = mlx5e_vf_rep_enable,
+ 	.update_stats           = mlx5e_vf_rep_update_hw_counters,
++>>>>>>> b36cdb42ad4b (net/mlx5e: Handle port mtu/link, dcb and lag for uplink reps)
  	.rx_handlers.handle_rx_cqe       = mlx5e_handle_rx_cqe_rep,
  	.rx_handlers.handle_rx_cqe_mpwqe = mlx5e_handle_rx_cqe_mpwrq,
  	.max_tc			= 1,
  };
  
+ static const struct mlx5e_profile mlx5e_uplink_rep_profile = {
+ 	.init			= mlx5e_init_rep,
+ 	.cleanup		= mlx5e_cleanup_rep,
+ 	.init_rx		= mlx5e_init_rep_rx,
+ 	.cleanup_rx		= mlx5e_cleanup_rep_rx,
+ 	.init_tx		= mlx5e_init_rep_tx,
+ 	.cleanup_tx		= mlx5e_cleanup_rep_tx,
+ 	.enable		        = mlx5e_uplink_rep_enable,
+ 	.disable	        = mlx5e_uplink_rep_disable,
+ 	.update_stats           = mlx5e_uplink_rep_update_hw_counters,
+ 	.update_carrier	        = mlx5e_update_carrier,
+ 	.rx_handlers.handle_rx_cqe       = mlx5e_handle_rx_cqe_rep,
+ 	.rx_handlers.handle_rx_cqe_mpwqe = mlx5e_handle_rx_cqe_mpwrq,
+ 	.max_tc			= MLX5E_MAX_NUM_TC,
+ };
+ 
  /* e-Switch vport representors */
 +
 +static int
 +mlx5e_nic_rep_load(struct mlx5_core_dev *dev, struct mlx5_eswitch_rep *rep)
 +{
 +	struct mlx5e_rep_priv *rpriv = mlx5e_rep_to_rep_priv(rep);
 +	struct mlx5e_priv *priv = netdev_priv(rpriv->netdev);
 +	struct mlx5_rep_uplink_priv *uplink_priv = &rpriv->uplink_priv;
 +	int err;
 +
 +	if (test_bit(MLX5E_STATE_OPENED, &priv->state)) {
 +		err = mlx5e_add_sqs_fwd_rules(priv);
 +		if (err)
 +			return err;
 +	}
 +
 +	err = mlx5e_rep_neigh_init(rpriv);
 +	if (err)
 +		goto err_remove_sqs;
 +
 +	/* init shared tc flow table */
 +	err = mlx5e_tc_esw_init(&uplink_priv->tc_ht);
 +	if (err)
 +		goto  err_neigh_cleanup;
 +
 +	/* init indirect block notifications */
 +	INIT_LIST_HEAD(&uplink_priv->tc_indr_block_priv_list);
 +	uplink_priv->netdevice_nb.notifier_call = mlx5e_nic_rep_netdevice_event;
 +	err = register_netdevice_notifier(&uplink_priv->netdevice_nb);
 +	if (err) {
 +		mlx5_core_err(priv->mdev, "Failed to register netdev notifier\n");
 +		goto err_indirect_block_cleanup;
 +	}
 +
 +	return 0;
 +
 +err_indirect_block_cleanup:
 +	mlx5e_tc_esw_cleanup(&uplink_priv->tc_ht);
 +err_neigh_cleanup:
 +	mlx5e_rep_neigh_cleanup(rpriv);
 +err_remove_sqs:
 +	mlx5e_remove_sqs_fwd_rules(priv);
 +	return err;
 +}
 +
 +static void
 +mlx5e_nic_rep_unload(struct mlx5_eswitch_rep *rep)
 +{
 +	struct mlx5e_rep_priv *rpriv = mlx5e_rep_to_rep_priv(rep);
 +	struct mlx5e_priv *priv = netdev_priv(rpriv->netdev);
 +
 +	if (test_bit(MLX5E_STATE_OPENED, &priv->state))
 +		mlx5e_remove_sqs_fwd_rules(priv);
 +
 +	/* clean indirect TC block notifications */
 +	unregister_netdevice_notifier(&rpriv->uplink_priv.netdevice_nb);
 +	mlx5e_rep_indr_clean_block_privs(rpriv);
 +
 +	/* clean uplink offloaded TC rules, delete shared tc flow table */
 +	mlx5e_tc_esw_cleanup(&rpriv->uplink_priv.tc_ht);
 +
 +	mlx5e_rep_neigh_cleanup(rpriv);
 +}
 +
  static int
  mlx5e_vport_rep_load(struct mlx5_core_dev *dev, struct mlx5_eswitch_rep *rep)
  {
++<<<<<<< HEAD
 +	struct mlx5e_rep_priv *uplink_rpriv;
++=======
+ 	const struct mlx5e_profile *profile;
++>>>>>>> b36cdb42ad4b (net/mlx5e: Handle port mtu/link, dcb and lag for uplink reps)
  	struct mlx5e_rep_priv *rpriv;
  	struct net_device *netdev;
 +	struct mlx5e_priv *upriv;
  	int nch, err;
  
  	rpriv = kzalloc(sizeof(*rpriv), GFP_KERNEL);
  	if (!rpriv)
  		return -ENOMEM;
  
 -	/* rpriv->rep to be looked up when profile->init() is called */
 -	rpriv->rep = rep;
 -
  	nch = mlx5e_get_max_num_channels(dev);
- 	netdev = mlx5e_create_netdev(dev, &mlx5e_rep_profile, nch, rpriv);
+ 	profile = (rep->vport == FDB_UPLINK_VPORT) ? &mlx5e_uplink_rep_profile : &mlx5e_vf_rep_profile;
+ 	netdev = mlx5e_create_netdev(dev, profile, nch, rpriv);
  	if (!netdev) {
  		pr_warn("Failed to create representor netdev for vport %d\n",
  			rep->vport);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index b4f6c14ea722..bce6e1b0c4f4 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@ -228,7 +228,7 @@ void mlx5e_set_rq_type(struct mlx5_core_dev *mdev, struct mlx5e_params *params)
 		MLX5_WQ_TYPE_CYCLIC;
 }
 
-static void mlx5e_update_carrier(struct mlx5e_priv *priv)
+void mlx5e_update_carrier(struct mlx5e_priv *priv)
 {
 	struct mlx5_core_dev *mdev = priv->mdev;
 	u8 port_state;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
