ice: Add code to get DCB related statistics

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
commit 4b0fdceb81ba60a8caea1993f0951a91de7a6f52
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/4b0fdceb.failed

This patch adds a new function ice_update_dcb_stats to get DCB stats
from the hardware and ethtool support for displaying these stats.

	Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 4b0fdceb81ba60a8caea1993f0951a91de7a6f52)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_dcb_lib.c
#	drivers/net/ethernet/intel/ice/ice_dcb_lib.h
diff --cc drivers/net/ethernet/intel/ice/ice_dcb_lib.c
index f2dd41408652,51f90696de56..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_dcb_lib.c
+++ b/drivers/net/ethernet/intel/ice/ice_dcb_lib.c
@@@ -38,5 -305,169 +38,173 @@@ int ice_init_pf_dcb(struct ice_pf *pf
  		ice_aq_start_stop_dcbx(hw, true, &dcbx_status, NULL);
  	}
  
++<<<<<<< HEAD
 +	return ice_init_dcb(hw);
++=======
+ 	err = ice_init_dcb(hw);
+ 	if (err) {
+ 		/* FW LLDP not in usable state, default to SW DCBx/LLDP */
+ 		dev_info(&pf->pdev->dev, "FW LLDP not in usable state\n");
+ 		hw->port_info->dcbx_status = ICE_DCBX_STATUS_NOT_STARTED;
+ 		hw->port_info->is_sw_lldp = true;
+ 	}
+ 
+ 	if (port_info->dcbx_status == ICE_DCBX_STATUS_DIS)
+ 		dev_info(&pf->pdev->dev, "DCBX disabled\n");
+ 
+ 	/* LLDP disabled in FW */
+ 	if (port_info->is_sw_lldp) {
+ 		sw_default = 1;
+ 		dev_info(&pf->pdev->dev, "DCBx/LLDP in SW mode.\n");
+ 	}
+ 
+ 	if (port_info->dcbx_status == ICE_DCBX_STATUS_NOT_STARTED) {
+ 		sw_default = 1;
+ 		dev_info(&pf->pdev->dev, "DCBX not started\n");
+ 	}
+ 
+ 	if (sw_default) {
+ 		err = ice_dcb_sw_dflt_cfg(pf);
+ 		if (err) {
+ 			dev_err(&pf->pdev->dev,
+ 				"Failed to set local DCB config %d\n", err);
+ 			err = -EIO;
+ 			goto dcb_init_err;
+ 		}
+ 
+ 		pf->dcbx_cap = DCB_CAP_DCBX_HOST | DCB_CAP_DCBX_VER_IEEE;
+ 		set_bit(ICE_FLAG_DCB_CAPABLE, pf->flags);
+ 		set_bit(ICE_FLAG_DCB_ENA, pf->flags);
+ 		return 0;
+ 	}
+ 
+ 	/* DCBX in FW and LLDP enabled in FW */
+ 	pf->dcbx_cap = DCB_CAP_DCBX_LLD_MANAGED | DCB_CAP_DCBX_VER_IEEE;
+ 
+ 	set_bit(ICE_FLAG_DCB_CAPABLE, pf->flags);
+ 
+ 	err = ice_dcb_init_cfg(pf);
+ 	if (err)
+ 		goto dcb_init_err;
+ 
+ 	dev_info(&pf->pdev->dev, "DCBX offload supported\n");
+ 	return err;
+ 
+ dcb_init_err:
+ 	dev_err(dev, "DCB init failed\n");
+ 	return err;
+ }
+ 
+ /**
+  * ice_update_dcb_stats - Update DCB stats counters
+  * @pf: PF whose stats needs to be updated
+  */
+ void ice_update_dcb_stats(struct ice_pf *pf)
+ {
+ 	struct ice_hw_port_stats *prev_ps, *cur_ps;
+ 	struct ice_hw *hw = &pf->hw;
+ 	u8 pf_id = hw->pf_id;
+ 	int i;
+ 
+ 	prev_ps = &pf->stats_prev;
+ 	cur_ps = &pf->stats;
+ 
+ 	for (i = 0; i < 8; i++) {
+ 		ice_stat_update32(hw, GLPRT_PXOFFRXC(pf_id, i),
+ 				  pf->stat_prev_loaded,
+ 				  &prev_ps->priority_xoff_rx[i],
+ 				  &cur_ps->priority_xoff_rx[i]);
+ 		ice_stat_update32(hw, GLPRT_PXONRXC(pf_id, i),
+ 				  pf->stat_prev_loaded,
+ 				  &prev_ps->priority_xon_rx[i],
+ 				  &cur_ps->priority_xon_rx[i]);
+ 		ice_stat_update32(hw, GLPRT_PXONTXC(pf_id, i),
+ 				  pf->stat_prev_loaded,
+ 				  &prev_ps->priority_xon_tx[i],
+ 				  &cur_ps->priority_xon_tx[i]);
+ 		ice_stat_update32(hw, GLPRT_PXOFFTXC(pf_id, i),
+ 				  pf->stat_prev_loaded,
+ 				  &prev_ps->priority_xoff_tx[i],
+ 				  &cur_ps->priority_xoff_tx[i]);
+ 		ice_stat_update32(hw, GLPRT_RXON2OFFCNT(pf_id, i),
+ 				  pf->stat_prev_loaded,
+ 				  &prev_ps->priority_xon_2_xoff[i],
+ 				  &cur_ps->priority_xon_2_xoff[i]);
+ 	}
+ }
+ 
+ /**
+  * ice_tx_prepare_vlan_flags_dcb - prepare VLAN tagging for DCB
+  * @tx_ring: ring to send buffer on
+  * @first: pointer to struct ice_tx_buf
+  */
+ int
+ ice_tx_prepare_vlan_flags_dcb(struct ice_ring *tx_ring,
+ 			      struct ice_tx_buf *first)
+ {
+ 	struct sk_buff *skb = first->skb;
+ 
+ 	if (!test_bit(ICE_FLAG_DCB_ENA, tx_ring->vsi->back->flags))
+ 		return 0;
+ 
+ 	/* Insert 802.1p priority into VLAN header */
+ 	if ((first->tx_flags & (ICE_TX_FLAGS_HW_VLAN | ICE_TX_FLAGS_SW_VLAN)) ||
+ 	    skb->priority != TC_PRIO_CONTROL) {
+ 		first->tx_flags &= ~ICE_TX_FLAGS_VLAN_PR_M;
+ 		/* Mask the lower 3 bits to set the 802.1p priority */
+ 		first->tx_flags |= (skb->priority & 0x7) <<
+ 				   ICE_TX_FLAGS_VLAN_PR_S;
+ 		if (first->tx_flags & ICE_TX_FLAGS_SW_VLAN) {
+ 			struct vlan_ethhdr *vhdr;
+ 			int rc;
+ 
+ 			rc = skb_cow_head(skb, 0);
+ 			if (rc < 0)
+ 				return rc;
+ 			vhdr = (struct vlan_ethhdr *)skb->data;
+ 			vhdr->h_vlan_TCI = htons(first->tx_flags >>
+ 						 ICE_TX_FLAGS_VLAN_S);
+ 		} else {
+ 			first->tx_flags |= ICE_TX_FLAGS_HW_VLAN;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_dcb_process_lldp_set_mib_change - Process MIB change
+  * @pf: ptr to ice_pf
+  * @event: pointer to the admin queue receive event
+  */
+ void
+ ice_dcb_process_lldp_set_mib_change(struct ice_pf *pf,
+ 				    struct ice_rq_event_info *event)
+ {
+ 	if (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED) {
+ 		struct ice_dcbx_cfg *dcbcfg, *prev_cfg;
+ 		int err;
+ 
+ 		prev_cfg = &pf->hw.port_info->local_dcbx_cfg;
+ 		dcbcfg = devm_kmemdup(&pf->pdev->dev, prev_cfg,
+ 				      sizeof(*dcbcfg), GFP_KERNEL);
+ 		if (!dcbcfg)
+ 			return;
+ 
+ 		err = ice_lldp_to_dcb_cfg(event->msg_buf, dcbcfg);
+ 		if (!err)
+ 			ice_pf_dcb_cfg(pf, dcbcfg);
+ 
+ 		devm_kfree(&pf->pdev->dev, dcbcfg);
+ 
+ 		/* Get updated DCBx data from firmware */
+ 		err = ice_get_dcb_cfg(pf->hw.port_info);
+ 		if (err)
+ 			dev_err(&pf->pdev->dev,
+ 				"Failed to get DCB config\n");
+ 	} else {
+ 		dev_dbg(&pf->pdev->dev,
+ 			"MIB Change Event in HOST mode\n");
+ 	}
++>>>>>>> 4b0fdceb81ba (ice: Add code to get DCB related statistics)
  }
diff --cc drivers/net/ethernet/intel/ice/ice_dcb_lib.h
index d67c769a9fb5,8829cccc0a6a..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_dcb_lib.h
+++ b/drivers/net/ethernet/intel/ice/ice_dcb_lib.h
@@@ -8,12 -8,49 +8,42 @@@
  #include "ice_lib.h"
  
  #ifdef CONFIG_DCB
 -u8 ice_dcb_get_ena_tc(struct ice_dcbx_cfg *dcbcfg);
 -u8 ice_dcb_get_num_tc(struct ice_dcbx_cfg *dcbcfg);
 -void ice_vsi_cfg_dcb_rings(struct ice_vsi *vsi);
  int ice_init_pf_dcb(struct ice_pf *pf);
++<<<<<<< HEAD
++=======
+ void ice_update_dcb_stats(struct ice_pf *pf);
+ int
+ ice_tx_prepare_vlan_flags_dcb(struct ice_ring *tx_ring,
+ 			      struct ice_tx_buf *first);
+ void
+ ice_dcb_process_lldp_set_mib_change(struct ice_pf *pf,
+ 				    struct ice_rq_event_info *event);
+ static inline void
+ ice_set_cgd_num(struct ice_tlan_ctx *tlan_ctx, struct ice_ring *ring)
+ {
+ 	tlan_ctx->cgd_num = ring->dcb_tc;
+ }
++>>>>>>> 4b0fdceb81ba (ice: Add code to get DCB related statistics)
  #else
 -static inline u8 ice_dcb_get_ena_tc(struct ice_dcbx_cfg __always_unused *dcbcfg)
 -{
 -	return ICE_DFLT_TRAFFIC_CLASS;
 -}
 -
 -static inline u8 ice_dcb_get_num_tc(struct ice_dcbx_cfg __always_unused *dcbcfg)
 -{
 -	return 1;
 -}
 -
  static inline int ice_init_pf_dcb(struct ice_pf *pf)
  {
  	dev_dbg(&pf->pdev->dev, "DCB not supported\n");
  	return -EOPNOTSUPP;
  }
++<<<<<<< HEAD
++=======
+ 
+ static inline int
+ ice_tx_prepare_vlan_flags_dcb(struct ice_ring __always_unused *tx_ring,
+ 			      struct ice_tx_buf __always_unused *first)
+ {
+ 	return 0;
+ }
+ 
+ #define ice_update_dcb_stats(pf) do {} while (0)
+ #define ice_vsi_cfg_dcb_rings(vsi) do {} while (0)
+ #define ice_dcb_process_lldp_set_mib_change(pf, event) do {} while (0)
+ #define ice_set_cgd_num(tlan_ctx, ring) do {} while (0)
++>>>>>>> 4b0fdceb81ba (ice: Add code to get DCB related statistics)
  #endif /* CONFIG_DCB */
  #endif /* _ICE_DCB_LIB_H_ */
* Unmerged path drivers/net/ethernet/intel/ice/ice_dcb_lib.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_dcb_lib.h
diff --git a/drivers/net/ethernet/intel/ice/ice_ethtool.c b/drivers/net/ethernet/intel/ice/ice_ethtool.c
index 77ffef7540a2..0bc17a52ef11 100644
--- a/drivers/net/ethernet/intel/ice/ice_ethtool.c
+++ b/drivers/net/ethernet/intel/ice/ice_ethtool.c
@@ -33,8 +33,14 @@ static int ice_q_stats_len(struct net_device *netdev)
 #define ICE_PF_STATS_LEN	ARRAY_SIZE(ice_gstrings_pf_stats)
 #define ICE_VSI_STATS_LEN	ARRAY_SIZE(ice_gstrings_vsi_stats)
 
-#define ICE_ALL_STATS_LEN(n)	(ICE_PF_STATS_LEN + ICE_VSI_STATS_LEN + \
-				 ice_q_stats_len(n))
+#define ICE_PFC_STATS_LEN ( \
+		(FIELD_SIZEOF(struct ice_pf, stats.priority_xoff_rx) + \
+		 FIELD_SIZEOF(struct ice_pf, stats.priority_xon_rx) + \
+		 FIELD_SIZEOF(struct ice_pf, stats.priority_xoff_tx) + \
+		 FIELD_SIZEOF(struct ice_pf, stats.priority_xon_tx)) \
+		 / sizeof(u64))
+#define ICE_ALL_STATS_LEN(n)	(ICE_PF_STATS_LEN + ICE_PFC_STATS_LEN + \
+				 ICE_VSI_STATS_LEN + ice_q_stats_len(n))
 
 static const struct ice_stats ice_gstrings_vsi_stats[] = {
 	ICE_VSI_STAT("tx_unicast", eth_stats.tx_unicast),
@@ -309,6 +315,22 @@ static void ice_get_strings(struct net_device *netdev, u32 stringset, u8 *data)
 			p += ETH_GSTRING_LEN;
 		}
 
+		for (i = 0; i < ICE_MAX_USER_PRIORITY; i++) {
+			snprintf(p, ETH_GSTRING_LEN,
+				 "port.tx-priority-%u-xon", i);
+			p += ETH_GSTRING_LEN;
+			snprintf(p, ETH_GSTRING_LEN,
+				 "port.tx-priority-%u-xoff", i);
+			p += ETH_GSTRING_LEN;
+		}
+		for (i = 0; i < ICE_MAX_USER_PRIORITY; i++) {
+			snprintf(p, ETH_GSTRING_LEN,
+				 "port.rx-priority-%u-xon", i);
+			p += ETH_GSTRING_LEN;
+			snprintf(p, ETH_GSTRING_LEN,
+				 "port.rx-priority-%u-xoff", i);
+			p += ETH_GSTRING_LEN;
+		}
 		break;
 	case ETH_SS_PRIV_FLAGS:
 		for (i = 0; i < ICE_PRIV_FLAG_ARRAY_SIZE; i++) {
@@ -486,6 +508,16 @@ ice_get_ethtool_stats(struct net_device *netdev,
 		data[i++] = (ice_gstrings_pf_stats[j].sizeof_stat ==
 			     sizeof(u64)) ? *(u64 *)p : *(u32 *)p;
 	}
+
+	for (j = 0; j < ICE_MAX_USER_PRIORITY; j++) {
+		data[i++] = pf->stats.priority_xon_tx[j];
+		data[i++] = pf->stats.priority_xoff_tx[j];
+	}
+
+	for (j = 0; j < ICE_MAX_USER_PRIORITY; j++) {
+		data[i++] = pf->stats.priority_xon_rx[j];
+		data[i++] = pf->stats.priority_xoff_rx[j];
+	}
 }
 
 /**
diff --git a/drivers/net/ethernet/intel/ice/ice_hw_autogen.h b/drivers/net/ethernet/intel/ice/ice_hw_autogen.h
index 24ec3f5f0d2b..fa971a853a28 100644
--- a/drivers/net/ethernet/intel/ice/ice_hw_autogen.h
+++ b/drivers/net/ethernet/intel/ice/ice_hw_autogen.h
@@ -310,11 +310,16 @@
 #define GLPRT_PTC64L(_i)			(0x00380B80 + ((_i) * 8))
 #define GLPRT_PTC9522H(_i)			(0x00380D04 + ((_i) * 8))
 #define GLPRT_PTC9522L(_i)			(0x00380D00 + ((_i) * 8))
+#define GLPRT_PXOFFRXC(_i, _j)			(0x00380500 + ((_i) * 8 + (_j) * 64))
+#define GLPRT_PXOFFTXC(_i, _j)			(0x00380F40 + ((_i) * 8 + (_j) * 64))
+#define GLPRT_PXONRXC(_i, _j)			(0x00380300 + ((_i) * 8 + (_j) * 64))
+#define GLPRT_PXONTXC(_i, _j)			(0x00380D40 + ((_i) * 8 + (_j) * 64))
 #define GLPRT_RFC(_i)				(0x00380AC0 + ((_i) * 8))
 #define GLPRT_RJC(_i)				(0x00380B00 + ((_i) * 8))
 #define GLPRT_RLEC(_i)				(0x00380140 + ((_i) * 8))
 #define GLPRT_ROC(_i)				(0x00380240 + ((_i) * 8))
 #define GLPRT_RUC(_i)				(0x00380200 + ((_i) * 8))
+#define GLPRT_RXON2OFFCNT(_i, _j)		(0x00380700 + ((_i) * 8 + (_j) * 64))
 #define GLPRT_TDOLD(_i)				(0x00381280 + ((_i) * 8))
 #define GLPRT_UPRCH(_i)				(0x00381304 + ((_i) * 8))
 #define GLPRT_UPRCL(_i)				(0x00381300 + ((_i) * 8))
diff --git a/drivers/net/ethernet/intel/ice/ice_main.c b/drivers/net/ethernet/intel/ice/ice_main.c
index 7fbfa22e64eb..17ea2e22db0a 100644
--- a/drivers/net/ethernet/intel/ice/ice_main.c
+++ b/drivers/net/ethernet/intel/ice/ice_main.c
@@ -3097,6 +3097,8 @@ static void ice_update_pf_stats(struct ice_pf *pf)
 	ice_stat_update32(hw, GLPRT_LXOFFTXC(pf_id), pf->stat_prev_loaded,
 			  &prev_ps->link_xoff_tx, &cur_ps->link_xoff_tx);
 
+	ice_update_dcb_stats(pf);
+
 	ice_stat_update32(hw, GLPRT_CRCERRS(pf_id), pf->stat_prev_loaded,
 			  &prev_ps->crc_errors, &cur_ps->crc_errors);
 
diff --git a/drivers/net/ethernet/intel/ice/ice_type.h b/drivers/net/ethernet/intel/ice/ice_type.h
index bd887c9917cf..25bb6ff5e566 100644
--- a/drivers/net/ethernet/intel/ice/ice_type.h
+++ b/drivers/net/ethernet/intel/ice/ice_type.h
@@ -475,6 +475,11 @@ struct ice_hw_port_stats {
 	u64 link_xoff_rx;		/* lxoffrxc */
 	u64 link_xon_tx;		/* lxontxc */
 	u64 link_xoff_tx;		/* lxofftxc */
+	u64 priority_xon_rx[8];		/* pxonrxc[8] */
+	u64 priority_xoff_rx[8];	/* pxoffrxc[8] */
+	u64 priority_xon_tx[8];		/* pxontxc[8] */
+	u64 priority_xoff_tx[8];	/* pxofftxc[8] */
+	u64 priority_xon_2_xoff[8];	/* pxon2offc[8] */
 	u64 rx_size_64;			/* prc64 */
 	u64 rx_size_127;		/* prc127 */
 	u64 rx_size_255;		/* prc255 */
