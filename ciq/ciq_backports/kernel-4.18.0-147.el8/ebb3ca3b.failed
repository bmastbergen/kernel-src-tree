cfg80211: use BIT_ULL in cfg80211_parse_mbssid_data()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Luca Coelho <luciano.coelho@intel.com>
commit ebb3ca3b4477bbc118976c77fe1913507df718ec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/ebb3ca3b.failed

The seen_indices variable is u64 and in other parts of the code we
assume mbssid_index_ie[2] can be up to 45, so we should use the 64-bit
versions of BIT, namely, BIT_ULL().

	Reported-by: Dan Carpented <dan.carpenter@oracle.com>
	Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit ebb3ca3b4477bbc118976c77fe1913507df718ec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/wireless/scan.c
diff --cc net/wireless/scan.c
index d36c3eb7b931,aa571d727903..000000000000
--- a/net/wireless/scan.c
+++ b/net/wireless/scan.c
@@@ -1173,15 -1454,329 +1173,228 @@@ cfg80211_inform_bss_data(struct wiphy *
  	/* cfg80211_bss_update gives us a referenced result */
  	return &res->pub;
  }
++<<<<<<< HEAD
++=======
+ 
+ static const struct element
+ *cfg80211_get_profile_continuation(const u8 *ie, size_t ielen,
+ 				   const struct element *mbssid_elem,
+ 				   const struct element *sub_elem)
+ {
+ 	const u8 *mbssid_end = mbssid_elem->data + mbssid_elem->datalen;
+ 	const struct element *next_mbssid;
+ 	const struct element *next_sub;
+ 
+ 	next_mbssid = cfg80211_find_elem(WLAN_EID_MULTIPLE_BSSID,
+ 					 mbssid_end,
+ 					 ielen - (mbssid_end - ie));
+ 
+ 	/*
+ 	 * If is is not the last subelement in current MBSSID IE or there isn't
+ 	 * a next MBSSID IE - profile is complete.
+ 	*/
+ 	if ((sub_elem->data + sub_elem->datalen < mbssid_end - 1) ||
+ 	    !next_mbssid)
+ 		return NULL;
+ 
+ 	/* For any length error, just return NULL */
+ 
+ 	if (next_mbssid->datalen < 4)
+ 		return NULL;
+ 
+ 	next_sub = (void *)&next_mbssid->data[1];
+ 
+ 	if (next_mbssid->data + next_mbssid->datalen <
+ 	    next_sub->data + next_sub->datalen)
+ 		return NULL;
+ 
+ 	if (next_sub->id != 0 || next_sub->datalen < 2)
+ 		return NULL;
+ 
+ 	/*
+ 	 * Check if the first element in the next sub element is a start
+ 	 * of a new profile
+ 	 */
+ 	return next_sub->data[0] == WLAN_EID_NON_TX_BSSID_CAP ?
+ 	       NULL : next_mbssid;
+ }
+ 
+ size_t cfg80211_merge_profile(const u8 *ie, size_t ielen,
+ 			      const struct element *mbssid_elem,
+ 			      const struct element *sub_elem,
+ 			      u8 *merged_ie, size_t max_copy_len)
+ {
+ 	size_t copied_len = sub_elem->datalen;
+ 	const struct element *next_mbssid;
+ 
+ 	if (sub_elem->datalen > max_copy_len)
+ 		return 0;
+ 
+ 	memcpy(merged_ie, sub_elem->data, sub_elem->datalen);
+ 
+ 	while ((next_mbssid = cfg80211_get_profile_continuation(ie, ielen,
+ 								mbssid_elem,
+ 								sub_elem))) {
+ 		const struct element *next_sub = (void *)&next_mbssid->data[1];
+ 
+ 		if (copied_len + next_sub->datalen > max_copy_len)
+ 			break;
+ 		memcpy(merged_ie + copied_len, next_sub->data,
+ 		       next_sub->datalen);
+ 		copied_len += next_sub->datalen;
+ 	}
+ 
+ 	return copied_len;
+ }
+ EXPORT_SYMBOL(cfg80211_merge_profile);
+ 
+ static void cfg80211_parse_mbssid_data(struct wiphy *wiphy,
+ 				       struct cfg80211_inform_bss *data,
+ 				       enum cfg80211_bss_frame_type ftype,
+ 				       const u8 *bssid, u64 tsf,
+ 				       u16 beacon_interval, const u8 *ie,
+ 				       size_t ielen,
+ 				       struct cfg80211_non_tx_bss *non_tx_data,
+ 				       gfp_t gfp)
+ {
+ 	const u8 *mbssid_index_ie;
+ 	const struct element *elem, *sub;
+ 	size_t new_ie_len;
+ 	u8 new_bssid[ETH_ALEN];
+ 	u8 *new_ie, *profile;
+ 	u64 seen_indices = 0;
+ 	u16 capability;
+ 	struct cfg80211_bss *bss;
+ 
+ 	if (!non_tx_data)
+ 		return;
+ 	if (!cfg80211_find_ie(WLAN_EID_MULTIPLE_BSSID, ie, ielen))
+ 		return;
+ 	if (!wiphy->support_mbssid)
+ 		return;
+ 	if (wiphy->support_only_he_mbssid &&
+ 	    !cfg80211_find_ext_ie(WLAN_EID_EXT_HE_CAPABILITY, ie, ielen))
+ 		return;
+ 
+ 	new_ie = kmalloc(IEEE80211_MAX_DATA_LEN, gfp);
+ 	if (!new_ie)
+ 		return;
+ 
+ 	profile = kmalloc(ielen, gfp);
+ 	if (!profile)
+ 		goto out;
+ 
+ 	for_each_element_id(elem, WLAN_EID_MULTIPLE_BSSID, ie, ielen) {
+ 		if (elem->datalen < 4)
+ 			continue;
+ 		for_each_element(sub, elem->data + 1, elem->datalen - 1) {
+ 			u8 profile_len;
+ 
+ 			if (sub->id != 0 || sub->datalen < 4) {
+ 				/* not a valid BSS profile */
+ 				continue;
+ 			}
+ 
+ 			if (sub->data[0] != WLAN_EID_NON_TX_BSSID_CAP ||
+ 			    sub->data[1] != 2) {
+ 				/* The first element within the Nontransmitted
+ 				 * BSSID Profile is not the Nontransmitted
+ 				 * BSSID Capability element.
+ 				 */
+ 				continue;
+ 			}
+ 
+ 			memset(profile, 0, ielen);
+ 			profile_len = cfg80211_merge_profile(ie, ielen,
+ 							     elem,
+ 							     sub,
+ 							     profile,
+ 							     ielen);
+ 
+ 			/* found a Nontransmitted BSSID Profile */
+ 			mbssid_index_ie = cfg80211_find_ie
+ 				(WLAN_EID_MULTI_BSSID_IDX,
+ 				 profile, profile_len);
+ 			if (!mbssid_index_ie || mbssid_index_ie[1] < 1 ||
+ 			    mbssid_index_ie[2] == 0 ||
+ 			    mbssid_index_ie[2] > 46) {
+ 				/* No valid Multiple BSSID-Index element */
+ 				continue;
+ 			}
+ 
+ 			if (seen_indices & BIT_ULL(mbssid_index_ie[2]))
+ 				/* We don't support legacy split of a profile */
+ 				net_dbg_ratelimited("Partial info for BSSID index %d\n",
+ 						    mbssid_index_ie[2]);
+ 
+ 			seen_indices |= BIT_ULL(mbssid_index_ie[2]);
+ 
+ 			non_tx_data->bssid_index = mbssid_index_ie[2];
+ 			non_tx_data->max_bssid_indicator = elem->data[0];
+ 
+ 			cfg80211_gen_new_bssid(bssid,
+ 					       non_tx_data->max_bssid_indicator,
+ 					       non_tx_data->bssid_index,
+ 					       new_bssid);
+ 			memset(new_ie, 0, IEEE80211_MAX_DATA_LEN);
+ 			new_ie_len = cfg80211_gen_new_ie(ie, ielen,
+ 							 profile,
+ 							 profile_len, new_ie,
+ 							 gfp);
+ 			if (!new_ie_len)
+ 				continue;
+ 
+ 			capability = get_unaligned_le16(profile + 2);
+ 			bss = cfg80211_inform_single_bss_data(wiphy, data,
+ 							      ftype,
+ 							      new_bssid, tsf,
+ 							      capability,
+ 							      beacon_interval,
+ 							      new_ie,
+ 							      new_ie_len,
+ 							      non_tx_data,
+ 							      gfp);
+ 			if (!bss)
+ 				break;
+ 			cfg80211_put_bss(wiphy, bss);
+ 		}
+ 	}
+ 
+ out:
+ 	kfree(new_ie);
+ 	kfree(profile);
+ }
+ 
+ struct cfg80211_bss *
+ cfg80211_inform_bss_data(struct wiphy *wiphy,
+ 			 struct cfg80211_inform_bss *data,
+ 			 enum cfg80211_bss_frame_type ftype,
+ 			 const u8 *bssid, u64 tsf, u16 capability,
+ 			 u16 beacon_interval, const u8 *ie, size_t ielen,
+ 			 gfp_t gfp)
+ {
+ 	struct cfg80211_bss *res;
+ 	struct cfg80211_non_tx_bss non_tx_data;
+ 
+ 	res = cfg80211_inform_single_bss_data(wiphy, data, ftype, bssid, tsf,
+ 					      capability, beacon_interval, ie,
+ 					      ielen, NULL, gfp);
+ 	non_tx_data.tx_bss = res;
+ 	cfg80211_parse_mbssid_data(wiphy, data, ftype, bssid, tsf,
+ 				   beacon_interval, ie, ielen, &non_tx_data,
+ 				   gfp);
+ 	return res;
+ }
++>>>>>>> ebb3ca3b4477 (cfg80211: use BIT_ULL in cfg80211_parse_mbssid_data())
  EXPORT_SYMBOL(cfg80211_inform_bss_data);
  
 -static void
 -cfg80211_parse_mbssid_frame_data(struct wiphy *wiphy,
 -				 struct cfg80211_inform_bss *data,
 -				 struct ieee80211_mgmt *mgmt, size_t len,
 -				 struct cfg80211_non_tx_bss *non_tx_data,
 -				 gfp_t gfp)
 -{
 -	enum cfg80211_bss_frame_type ftype;
 -	const u8 *ie = mgmt->u.probe_resp.variable;
 -	size_t ielen = len - offsetof(struct ieee80211_mgmt,
 -				      u.probe_resp.variable);
 -
 -	ftype = ieee80211_is_beacon(mgmt->frame_control) ?
 -		CFG80211_BSS_FTYPE_BEACON : CFG80211_BSS_FTYPE_PRESP;
 -
 -	cfg80211_parse_mbssid_data(wiphy, data, ftype, mgmt->bssid,
 -				   le64_to_cpu(mgmt->u.probe_resp.timestamp),
 -				   le16_to_cpu(mgmt->u.probe_resp.beacon_int),
 -				   ie, ielen, non_tx_data, gfp);
 -}
 -
 -static void
 -cfg80211_update_notlisted_nontrans(struct wiphy *wiphy,
 -				   struct cfg80211_bss *nontrans_bss,
 -				   struct ieee80211_mgmt *mgmt, size_t len,
 -				   gfp_t gfp)
 -{
 -	u8 *ie, *new_ie, *pos;
 -	const u8 *nontrans_ssid, *trans_ssid, *mbssid;
 -	size_t ielen = len - offsetof(struct ieee80211_mgmt,
 -				      u.probe_resp.variable);
 -	size_t new_ie_len;
 -	struct cfg80211_bss_ies *new_ies;
 -	const struct cfg80211_bss_ies *old;
 -	u8 cpy_len;
 -
 -	ie = mgmt->u.probe_resp.variable;
 -
 -	new_ie_len = ielen;
 -	trans_ssid = cfg80211_find_ie(WLAN_EID_SSID, ie, ielen);
 -	if (!trans_ssid)
 -		return;
 -	new_ie_len -= trans_ssid[1];
 -	mbssid = cfg80211_find_ie(WLAN_EID_MULTIPLE_BSSID, ie, ielen);
 -	if (!mbssid)
 -		return;
 -	new_ie_len -= mbssid[1];
 -	rcu_read_lock();
 -	nontrans_ssid = ieee80211_bss_get_ie(nontrans_bss, WLAN_EID_SSID);
 -	if (!nontrans_ssid) {
 -		rcu_read_unlock();
 -		return;
 -	}
 -	new_ie_len += nontrans_ssid[1];
 -	rcu_read_unlock();
 -
 -	/* generate new ie for nontrans BSS
 -	 * 1. replace SSID with nontrans BSS' SSID
 -	 * 2. skip MBSSID IE
 -	 */
 -	new_ie = kzalloc(new_ie_len, gfp);
 -	if (!new_ie)
 -		return;
 -	new_ies = kzalloc(sizeof(*new_ies) + new_ie_len, gfp);
 -	if (!new_ies)
 -		goto out_free;
 -
 -	pos = new_ie;
 -
 -	/* copy the nontransmitted SSID */
 -	cpy_len = nontrans_ssid[1] + 2;
 -	memcpy(pos, nontrans_ssid, cpy_len);
 -	pos += cpy_len;
 -	/* copy the IEs between SSID and MBSSID */
 -	cpy_len = trans_ssid[1] + 2;
 -	memcpy(pos, (trans_ssid + cpy_len), (mbssid - (trans_ssid + cpy_len)));
 -	pos += (mbssid - (trans_ssid + cpy_len));
 -	/* copy the IEs after MBSSID */
 -	cpy_len = mbssid[1] + 2;
 -	memcpy(pos, mbssid + cpy_len, ((ie + ielen) - (mbssid + cpy_len)));
 -
 -	/* update ie */
 -	new_ies->len = new_ie_len;
 -	new_ies->tsf = le64_to_cpu(mgmt->u.probe_resp.timestamp);
 -	new_ies->from_beacon = ieee80211_is_beacon(mgmt->frame_control);
 -	memcpy(new_ies->data, new_ie, new_ie_len);
 -	if (ieee80211_is_probe_resp(mgmt->frame_control)) {
 -		old = rcu_access_pointer(nontrans_bss->proberesp_ies);
 -		rcu_assign_pointer(nontrans_bss->proberesp_ies, new_ies);
 -		rcu_assign_pointer(nontrans_bss->ies, new_ies);
 -		if (old)
 -			kfree_rcu((struct cfg80211_bss_ies *)old, rcu_head);
 -	} else {
 -		old = rcu_access_pointer(nontrans_bss->beacon_ies);
 -		rcu_assign_pointer(nontrans_bss->beacon_ies, new_ies);
 -		rcu_assign_pointer(nontrans_bss->ies, new_ies);
 -		if (old)
 -			kfree_rcu((struct cfg80211_bss_ies *)old, rcu_head);
 -	}
 -
 -out_free:
 -	kfree(new_ie);
 -}
 -
  /* cfg80211_inform_bss_width_frame helper */
 -static struct cfg80211_bss *
 -cfg80211_inform_single_bss_frame_data(struct wiphy *wiphy,
 -				      struct cfg80211_inform_bss *data,
 -				      struct ieee80211_mgmt *mgmt, size_t len,
 -				      struct cfg80211_non_tx_bss *non_tx_data,
 -				      gfp_t gfp)
 +struct cfg80211_bss *
 +cfg80211_inform_bss_frame_data(struct wiphy *wiphy,
 +			       struct cfg80211_inform_bss *data,
 +			       struct ieee80211_mgmt *mgmt, size_t len,
 +			       gfp_t gfp)
 +
  {
  	struct cfg80211_internal_bss tmp = {}, *res;
  	struct cfg80211_bss_ies *ies;
* Unmerged path net/wireless/scan.c
