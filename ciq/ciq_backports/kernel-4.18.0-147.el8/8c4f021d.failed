ASoC: wcd9335: add basic controls

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [sound] ALSA: ASoC: wcd9335: add basic controls (Jaroslav Kysela) [1683051]
Rebuild_FUZZ: 91.67%
commit-author Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
commit 8c4f021d806ac52902856d7cbd148a4b24a88f59
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/8c4f021d.failed

This patch adds basic controls found in wcd9335 codec.

	Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
	Reviewed-by: Vinod Koul <vkoul@kernel.org>
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 8c4f021d806ac52902856d7cbd148a4b24a88f59)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/codecs/wcd9335.c
diff --cc sound/soc/codecs/wcd9335.c
index 06c73699f16f,66d634764d28..000000000000
--- a/sound/soc/codecs/wcd9335.c
+++ b/sound/soc/codecs/wcd9335.c
@@@ -184,6 -196,17 +196,20 @@@ struct wcd9335_codec 
  
  	struct wcd_clsh_ctrl *clsh_ctrl;
  	u32 hph_mode;
++<<<<<<< HEAD
++=======
+ 	int comp_enabled[COMPANDER_MAX];
+ 
+ 	int intr1;
+ 	int reset_gpio;
+ 	struct regulator_bulk_data supplies[WCD9335_MAX_SUPPLY];
+ };
+ 
+ struct wcd9335_irq {
+ 	int irq;
+ 	irqreturn_t (*handler)(int irq, void *data);
+ 	char *name;
++>>>>>>> 8c4f021d806a (ASoC: wcd9335: add basic controls)
  };
  
  static const struct wcd9335_slim_ch wcd9335_rx_chs[WCD9335_RX_MAX] = {
@@@ -293,8 -297,129 +319,113 @@@ static const struct wcd9335_reg_mask_va
  	{WCD9335_CDC_RX7_RX_PATH_MIX_CFG, 0x01, 0x01},
  	{WCD9335_CDC_RX8_RX_PATH_MIX_CFG, 0x01, 0x01},
  	{WCD9335_VBADC_IBIAS_FE, 0x0C, 0x08},
 -	{WCD9335_RCO_CTRL_2, 0x0F, 0x08},
 -	{WCD9335_RX_BIAS_FLYB_MID_RST, 0xF0, 0x10},
 -	{WCD9335_FLYBACK_CTRL_1, 0x20, 0x20},
 -	{WCD9335_HPH_OCP_CTL, 0xFF, 0x5A},
 -	{WCD9335_HPH_L_TEST, 0x01, 0x01},
 -	{WCD9335_HPH_R_TEST, 0x01, 0x01},
 -	{WCD9335_CDC_BOOST0_BOOST_CFG1, 0x3F, 0x12},
 -	{WCD9335_CDC_BOOST0_BOOST_CFG2, 0x1C, 0x08},
 -	{WCD9335_CDC_COMPANDER7_CTL7, 0x1E, 0x18},
 -	{WCD9335_CDC_BOOST1_BOOST_CFG1, 0x3F, 0x12},
 -	{WCD9335_CDC_BOOST1_BOOST_CFG2, 0x1C, 0x08},
 -	{WCD9335_CDC_COMPANDER8_CTL7, 0x1E, 0x18},
 -	{WCD9335_CDC_TX0_TX_PATH_SEC7, 0xFF, 0x45},
 -	{WCD9335_CDC_RX0_RX_PATH_SEC0, 0xFC, 0xF4},
 -	{WCD9335_HPH_REFBUFF_LP_CTL, 0x08, 0x08},
 -	{WCD9335_HPH_REFBUFF_LP_CTL, 0x06, 0x02},
  };
  
+ /* Cutoff frequency for high pass filter */
+ static const char * const cf_text[] = {
+ 	"CF_NEG_3DB_4HZ", "CF_NEG_3DB_75HZ", "CF_NEG_3DB_150HZ"
+ };
+ 
+ static const char * const rx_cf_text[] = {
+ 	"CF_NEG_3DB_4HZ", "CF_NEG_3DB_75HZ", "CF_NEG_3DB_150HZ",
+ 	"CF_NEG_3DB_0P48HZ"
+ };
+ 
+ static const char * const rx_hph_mode_mux_text[] = {
+ 	"Class H Invalid", "Class-H Hi-Fi", "Class-H Low Power", "Class-AB",
+ 	"Class-H Hi-Fi Low Power"
+ };
+ 
+ static const DECLARE_TLV_DB_SCALE(digital_gain, 0, 1, 0);
+ static const DECLARE_TLV_DB_SCALE(line_gain, 0, 7, 1);
+ static const DECLARE_TLV_DB_SCALE(analog_gain, 0, 25, 1);
+ static const DECLARE_TLV_DB_SCALE(ear_pa_gain, 0, 150, 0);
+ 
+ static const struct soc_enum cf_dec0_enum =
+ 	SOC_ENUM_SINGLE(WCD9335_CDC_TX0_TX_PATH_CFG0, 5, 3, cf_text);
+ 
+ static const struct soc_enum cf_dec1_enum =
+ 	SOC_ENUM_SINGLE(WCD9335_CDC_TX1_TX_PATH_CFG0, 5, 3, cf_text);
+ 
+ static const struct soc_enum cf_dec2_enum =
+ 	SOC_ENUM_SINGLE(WCD9335_CDC_TX2_TX_PATH_CFG0, 5, 3, cf_text);
+ 
+ static const struct soc_enum cf_dec3_enum =
+ 	SOC_ENUM_SINGLE(WCD9335_CDC_TX3_TX_PATH_CFG0, 5, 3, cf_text);
+ 
+ static const struct soc_enum cf_dec4_enum =
+ 	SOC_ENUM_SINGLE(WCD9335_CDC_TX4_TX_PATH_CFG0, 5, 3, cf_text);
+ 
+ static const struct soc_enum cf_dec5_enum =
+ 	SOC_ENUM_SINGLE(WCD9335_CDC_TX5_TX_PATH_CFG0, 5, 3, cf_text);
+ 
+ static const struct soc_enum cf_dec6_enum =
+ 	SOC_ENUM_SINGLE(WCD9335_CDC_TX6_TX_PATH_CFG0, 5, 3, cf_text);
+ 
+ static const struct soc_enum cf_dec7_enum =
+ 	SOC_ENUM_SINGLE(WCD9335_CDC_TX7_TX_PATH_CFG0, 5, 3, cf_text);
+ 
+ static const struct soc_enum cf_dec8_enum =
+ 	SOC_ENUM_SINGLE(WCD9335_CDC_TX8_TX_PATH_CFG0, 5, 3, cf_text);
+ 
+ static const struct soc_enum cf_int0_1_enum =
+ 	SOC_ENUM_SINGLE(WCD9335_CDC_RX0_RX_PATH_CFG2, 0, 4, rx_cf_text);
+ 
+ static SOC_ENUM_SINGLE_DECL(cf_int0_2_enum, WCD9335_CDC_RX0_RX_PATH_MIX_CFG, 2,
+ 		     rx_cf_text);
+ 
+ static const struct soc_enum cf_int1_1_enum =
+ 	SOC_ENUM_SINGLE(WCD9335_CDC_RX1_RX_PATH_CFG2, 0, 4, rx_cf_text);
+ 
+ static SOC_ENUM_SINGLE_DECL(cf_int1_2_enum, WCD9335_CDC_RX1_RX_PATH_MIX_CFG, 2,
+ 		     rx_cf_text);
+ 
+ static const struct soc_enum cf_int2_1_enum =
+ 	SOC_ENUM_SINGLE(WCD9335_CDC_RX2_RX_PATH_CFG2, 0, 4, rx_cf_text);
+ 
+ static SOC_ENUM_SINGLE_DECL(cf_int2_2_enum, WCD9335_CDC_RX2_RX_PATH_MIX_CFG, 2,
+ 		     rx_cf_text);
+ 
+ static const struct soc_enum cf_int3_1_enum =
+ 	SOC_ENUM_SINGLE(WCD9335_CDC_RX3_RX_PATH_CFG2, 0, 4, rx_cf_text);
+ 
+ static SOC_ENUM_SINGLE_DECL(cf_int3_2_enum, WCD9335_CDC_RX3_RX_PATH_MIX_CFG, 2,
+ 		     rx_cf_text);
+ 
+ static const struct soc_enum cf_int4_1_enum =
+ 	SOC_ENUM_SINGLE(WCD9335_CDC_RX4_RX_PATH_CFG2, 0, 4, rx_cf_text);
+ 
+ static SOC_ENUM_SINGLE_DECL(cf_int4_2_enum, WCD9335_CDC_RX4_RX_PATH_MIX_CFG, 2,
+ 		     rx_cf_text);
+ 
+ static const struct soc_enum cf_int5_1_enum =
+ 	SOC_ENUM_SINGLE(WCD9335_CDC_RX5_RX_PATH_CFG2, 0, 4, rx_cf_text);
+ 
+ static SOC_ENUM_SINGLE_DECL(cf_int5_2_enum, WCD9335_CDC_RX5_RX_PATH_MIX_CFG, 2,
+ 		     rx_cf_text);
+ 
+ static const struct soc_enum cf_int6_1_enum =
+ 	SOC_ENUM_SINGLE(WCD9335_CDC_RX6_RX_PATH_CFG2, 0, 4, rx_cf_text);
+ 
+ static SOC_ENUM_SINGLE_DECL(cf_int6_2_enum, WCD9335_CDC_RX6_RX_PATH_MIX_CFG, 2,
+ 		     rx_cf_text);
+ 
+ static const struct soc_enum cf_int7_1_enum =
+ 	SOC_ENUM_SINGLE(WCD9335_CDC_RX7_RX_PATH_CFG2, 0, 4, rx_cf_text);
+ 
+ static SOC_ENUM_SINGLE_DECL(cf_int7_2_enum, WCD9335_CDC_RX7_RX_PATH_MIX_CFG, 2,
+ 		     rx_cf_text);
+ 
+ static const struct soc_enum cf_int8_1_enum =
+ 	SOC_ENUM_SINGLE(WCD9335_CDC_RX8_RX_PATH_CFG2, 0, 4, rx_cf_text);
+ 
+ static SOC_ENUM_SINGLE_DECL(cf_int8_2_enum, WCD9335_CDC_RX8_RX_PATH_MIX_CFG, 2,
+ 		     rx_cf_text);
+ 
+ static const struct soc_enum rx_hph_mode_mux_enum =
+ 	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(rx_hph_mode_mux_text),
+ 			    rx_hph_mode_mux_text);
+ 
  static int wcd9335_set_mix_interpolator_rate(struct snd_soc_dai *dai,
  					     int rate_val,
  					     u32 rate)
@@@ -1119,13 -1485,244 +1454,15 @@@ static const struct snd_soc_component_d
  	.probe = wcd9335_codec_probe,
  	.remove = wcd9335_codec_remove,
  	.set_sysclk = wcd9335_codec_set_sysclk,
+ 	.controls = wcd9335_snd_controls,
+ 	.num_controls = ARRAY_SIZE(wcd9335_snd_controls),
  };
  
 -static int wcd9335_probe(struct wcd9335_codec *wcd)
 -{
 -	struct device *dev = wcd->dev;
 -
 -	memcpy(wcd->rx_chs, wcd9335_rx_chs, sizeof(wcd9335_rx_chs));
 -
 -	wcd->sido_input_src = SIDO_SOURCE_INTERNAL;
 -	wcd->sido_voltage = SIDO_VOLTAGE_NOMINAL_MV;
 -
 -	return devm_snd_soc_register_component(dev, &wcd9335_component_drv,
 -					       wcd9335_slim_dais,
 -					       ARRAY_SIZE(wcd9335_slim_dais));
 -}
 -
 -static const struct regmap_range_cfg wcd9335_ranges[] = {
 -	{
 -		.name = "WCD9335",
 -		.range_min =  0x0,
 -		.range_max =  WCD9335_MAX_REGISTER,
 -		.selector_reg = WCD9335_REG(0x0, 0),
 -		.selector_mask = 0xff,
 -		.selector_shift = 0,
 -		.window_start = 0x0,
 -		.window_len = 0x1000,
 -	},
 -};
 -
 -static bool wcd9335_is_volatile_register(struct device *dev, unsigned int reg)
 -{
 -	switch (reg) {
 -	case WCD9335_INTR_PIN1_STATUS0...WCD9335_INTR_PIN2_CLEAR3:
 -	case WCD9335_ANA_MBHC_RESULT_3:
 -	case WCD9335_ANA_MBHC_RESULT_2:
 -	case WCD9335_ANA_MBHC_RESULT_1:
 -	case WCD9335_ANA_MBHC_MECH:
 -	case WCD9335_ANA_MBHC_ELECT:
 -	case WCD9335_ANA_MBHC_ZDET:
 -	case WCD9335_ANA_MICB2:
 -	case WCD9335_ANA_RCO:
 -	case WCD9335_ANA_BIAS:
 -		return true;
 -	default:
 -		return false;
 -	}
 -}
 -
 -static struct regmap_config wcd9335_regmap_config = {
 -	.reg_bits = 16,
 -	.val_bits = 8,
 -	.cache_type = REGCACHE_RBTREE,
 -	.max_register = WCD9335_MAX_REGISTER,
 -	.can_multi_write = true,
 -	.ranges = wcd9335_ranges,
 -	.num_ranges = ARRAY_SIZE(wcd9335_ranges),
 -	.volatile_reg = wcd9335_is_volatile_register,
 -};
 -
 -static const struct regmap_range_cfg wcd9335_ifc_ranges[] = {
 -	{
 -		.name = "WCD9335-IFC-DEV",
 -		.range_min =  0x0,
 -		.range_max = WCD9335_REG(0, 0x7ff),
 -		.selector_reg = WCD9335_REG(0, 0x0),
 -		.selector_mask = 0xff,
 -		.selector_shift = 0,
 -		.window_start = 0x0,
 -		.window_len = 0x1000,
 -	},
 -};
 -
 -static struct regmap_config wcd9335_ifc_regmap_config = {
 -	.reg_bits = 16,
 -	.val_bits = 8,
 -	.can_multi_write = true,
 -	.max_register = WCD9335_REG(0, 0x7FF),
 -	.ranges = wcd9335_ifc_ranges,
 -	.num_ranges = ARRAY_SIZE(wcd9335_ifc_ranges),
 -};
 -
 -static const struct regmap_irq wcd9335_codec_irqs[] = {
 -	/* INTR_REG 0 */
 -	[WCD9335_IRQ_SLIMBUS] = {
 -		.reg_offset = 0,
 -		.mask = BIT(0),
 -		.type = {
 -			.type_reg_offset = 0,
 -			.types_supported = IRQ_TYPE_EDGE_BOTH,
 -			.type_reg_mask	= BIT(0),
 -		},
 -	},
 -};
 -
 -static const struct regmap_irq_chip wcd9335_regmap_irq1_chip = {
 -	.name = "wcd9335_pin1_irq",
 -	.status_base = WCD9335_INTR_PIN1_STATUS0,
 -	.mask_base = WCD9335_INTR_PIN1_MASK0,
 -	.ack_base = WCD9335_INTR_PIN1_CLEAR0,
 -	.type_base = WCD9335_INTR_LEVEL0,
 -	.num_type_reg = 4,
 -	.num_regs = 4,
 -	.irqs = wcd9335_codec_irqs,
 -	.num_irqs = ARRAY_SIZE(wcd9335_codec_irqs),
 -};
 -
 -static int wcd9335_parse_dt(struct wcd9335_codec *wcd)
 -{
 -	struct device *dev = wcd->dev;
 -	struct device_node *np = dev->of_node;
 -	int ret;
 -
 -	wcd->reset_gpio = of_get_named_gpio(np,	"reset-gpios", 0);
 -	if (wcd->reset_gpio < 0) {
 -		dev_err(dev, "Reset GPIO missing from DT\n");
 -		return wcd->reset_gpio;
 -	}
 -
 -	wcd->mclk = devm_clk_get(dev, "mclk");
 -	if (IS_ERR(wcd->mclk)) {
 -		dev_err(dev, "mclk not found\n");
 -		return PTR_ERR(wcd->mclk);
 -	}
 -
 -	wcd->native_clk = devm_clk_get(dev, "slimbus");
 -	if (IS_ERR(wcd->native_clk)) {
 -		dev_err(dev, "slimbus clock not found\n");
 -		return PTR_ERR(wcd->native_clk);
 -	}
 -
 -	wcd->supplies[0].supply = "vdd-buck";
 -	wcd->supplies[1].supply = "vdd-buck-sido";
 -	wcd->supplies[2].supply = "vdd-tx";
 -	wcd->supplies[3].supply = "vdd-rx";
 -	wcd->supplies[4].supply = "vdd-io";
 -
 -	ret = regulator_bulk_get(dev, WCD9335_MAX_SUPPLY, wcd->supplies);
 -	if (ret) {
 -		dev_err(dev, "Failed to get supplies: err = %d\n", ret);
 -		return ret;
 -	}
 -
 -	return 0;
 -}
 -
 -static int wcd9335_power_on_reset(struct wcd9335_codec *wcd)
 -{
 -	struct device *dev = wcd->dev;
 -	int ret;
 -
 -	ret = regulator_bulk_enable(WCD9335_MAX_SUPPLY, wcd->supplies);
 -	if (ret) {
 -		dev_err(dev, "Failed to get supplies: err = %d\n", ret);
 -		return ret;
 -	}
 -
 -	/*
 -	 * For WCD9335, it takes about 600us for the Vout_A and
 -	 * Vout_D to be ready after BUCK_SIDO is powered up.
 -	 * SYS_RST_N shouldn't be pulled high during this time
 -	 * Toggle the reset line to make sure the reset pulse is
 -	 * correctly applied
 -	 */
 -	usleep_range(600, 650);
 -
 -	gpio_direction_output(wcd->reset_gpio, 0);
 -	msleep(20);
 -	gpio_set_value(wcd->reset_gpio, 1);
 -	msleep(20);
 -
 -	return 0;
 -}
 -
 -static int wcd9335_bring_up(struct wcd9335_codec *wcd)
 -{
 -	struct regmap *rm = wcd->regmap;
 -	int val, byte0;
 -
 -	regmap_read(rm, WCD9335_CHIP_TIER_CTRL_EFUSE_VAL_OUT0, &val);
 -	regmap_read(rm, WCD9335_CHIP_TIER_CTRL_CHIP_ID_BYTE0, &byte0);
 -
 -	if ((val < 0) || (byte0 < 0)) {
 -		dev_err(wcd->dev, "WCD9335 CODEC version detection fail!\n");
 -		return -EINVAL;
 -	}
 -
 -	if (byte0 == 0x1) {
 -		dev_info(wcd->dev, "WCD9335 CODEC version is v2.0\n");
 -		wcd->version = WCD9335_VERSION_2_0;
 -		regmap_write(rm, WCD9335_CODEC_RPM_RST_CTL, 0x01);
 -		regmap_write(rm, WCD9335_SIDO_SIDO_TEST_2, 0x00);
 -		regmap_write(rm, WCD9335_SIDO_SIDO_CCL_8, 0x6F);
 -		regmap_write(rm, WCD9335_BIAS_VBG_FINE_ADJ, 0x65);
 -		regmap_write(rm, WCD9335_CODEC_RPM_PWR_CDC_DIG_HM_CTL, 0x5);
 -		regmap_write(rm, WCD9335_CODEC_RPM_PWR_CDC_DIG_HM_CTL, 0x7);
 -		regmap_write(rm, WCD9335_CODEC_RPM_PWR_CDC_DIG_HM_CTL, 0x3);
 -		regmap_write(rm, WCD9335_CODEC_RPM_RST_CTL, 0x3);
 -	} else {
 -		dev_err(wcd->dev, "WCD9335 CODEC version not supported\n");
 -		return -EINVAL;
 -	}
 -
 -	return 0;
 -}
 -
 -static int wcd9335_irq_init(struct wcd9335_codec *wcd)
 -{
 -	int ret;
 -
 -	/*
 -	 * INTR1 consists of all possible interrupt sources Ear OCP,
 -	 * HPH OCP, MBHC, MAD, VBAT, and SVA
 -	 * INTR2 is a subset of first interrupt sources MAD, VBAT, and SVA
 -	 */
 -	wcd->intr1 = of_irq_get_byname(wcd->dev->of_node, "intr1");
 -	if (wcd->intr1 < 0) {
 -		if (wcd->intr1 != -EPROBE_DEFER)
 -			dev_err(wcd->dev, "Unable to configure IRQ\n");
 -
 -		return wcd->intr1;
 -	}
 -
 -	ret = devm_regmap_add_irq_chip(wcd->dev, wcd->regmap, wcd->intr1,
 -				 IRQF_TRIGGER_HIGH, 0,
 -				 &wcd9335_regmap_irq1_chip, &wcd->irq_data);
 -	if (ret)
 -		dev_err(wcd->dev, "Failed to register IRQ chip: %d\n", ret);
 -
 -	return ret;
 -}
 -
 -static int wcd9335_slim_probe(struct slim_device *slim)
 +static int wcd9335_probe(struct platform_device *pdev)
  {
 -	struct device *dev = &slim->dev;
 +	struct wcd9335 *pdata = dev_get_drvdata(pdev->dev.parent);
 +	struct device *dev = &pdev->dev;
  	struct wcd9335_codec *wcd;
 -	int ret;
  
  	wcd = devm_kzalloc(dev, sizeof(*wcd), GFP_KERNEL);
  	if (!wcd)
* Unmerged path sound/soc/codecs/wcd9335.c
