nvmet: make kato and AEN processing for use by other controllers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jay Sternberg <jay.e.sternberg@intel.com>
commit 90107455cce753c05a5e1e80cb84b09da1c87eef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/90107455.failed

Make common process of get/set features available to other controllers by
making simple functions static inline and others not static and prototypes
in nvmet.h file

Also remove static from nvmet_execute_async_event and add prototype to
nvmet.h to allow used by other controllers

	Signed-off-by: Jay Sternberg <jay.e.sternberg@intel.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 90107455cce753c05a5e1e80cb84b09da1c87eef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/target/admin-cmd.c
diff --cc drivers/nvme/target/admin-cmd.c
index ede200e06c9d,753515fc8028..000000000000
--- a/drivers/nvme/target/admin-cmd.c
+++ b/drivers/nvme/target/admin-cmd.c
@@@ -454,6 -541,76 +454,79 @@@ static void nvmet_execute_abort(struct 
  	nvmet_req_complete(req, 0);
  }
  
++<<<<<<< HEAD
++=======
+ static u16 nvmet_write_protect_flush_sync(struct nvmet_req *req)
+ {
+ 	u16 status;
+ 
+ 	if (req->ns->file)
+ 		status = nvmet_file_flush(req);
+ 	else
+ 		status = nvmet_bdev_flush(req);
+ 
+ 	if (status)
+ 		pr_err("write protect flush failed nsid: %u\n", req->ns->nsid);
+ 	return status;
+ }
+ 
+ static u16 nvmet_set_feat_write_protect(struct nvmet_req *req)
+ {
+ 	u32 write_protect = le32_to_cpu(req->cmd->common.cdw10[1]);
+ 	struct nvmet_subsys *subsys = req->sq->ctrl->subsys;
+ 	u16 status = NVME_SC_FEATURE_NOT_CHANGEABLE;
+ 
+ 	req->ns = nvmet_find_namespace(req->sq->ctrl, req->cmd->rw.nsid);
+ 	if (unlikely(!req->ns))
+ 		return status;
+ 
+ 	mutex_lock(&subsys->lock);
+ 	switch (write_protect) {
+ 	case NVME_NS_WRITE_PROTECT:
+ 		req->ns->readonly = true;
+ 		status = nvmet_write_protect_flush_sync(req);
+ 		if (status)
+ 			req->ns->readonly = false;
+ 		break;
+ 	case NVME_NS_NO_WRITE_PROTECT:
+ 		req->ns->readonly = false;
+ 		status = 0;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	if (!status)
+ 		nvmet_ns_changed(subsys, req->ns->nsid);
+ 	mutex_unlock(&subsys->lock);
+ 	return status;
+ }
+ 
+ u16 nvmet_set_feat_kato(struct nvmet_req *req)
+ {
+ 	u32 val32 = le32_to_cpu(req->cmd->common.cdw10[1]);
+ 
+ 	req->sq->ctrl->kato = DIV_ROUND_UP(val32, 1000);
+ 
+ 	nvmet_set_result(req, req->sq->ctrl->kato);
+ 
+ 	return 0;
+ }
+ 
+ u16 nvmet_set_feat_async_event(struct nvmet_req *req, u32 mask)
+ {
+ 	u32 val32 = le32_to_cpu(req->cmd->common.cdw10[1]);
+ 
+ 	if (val32 & ~mask)
+ 		return NVME_SC_INVALID_FIELD | NVME_SC_DNR;
+ 
+ 	WRITE_ONCE(req->sq->ctrl->aen_enabled, val32);
+ 	nvmet_set_result(req, val32);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 90107455cce7 (nvmet: make kato and AEN processing for use by other controllers)
  static void nvmet_execute_set_features(struct nvmet_req *req)
  {
  	struct nvmet_subsys *subsys = req->sq->ctrl->subsys;
@@@ -492,6 -642,36 +555,39 @@@
  	nvmet_req_complete(req, status);
  }
  
++<<<<<<< HEAD
++=======
+ static u16 nvmet_get_feat_write_protect(struct nvmet_req *req)
+ {
+ 	struct nvmet_subsys *subsys = req->sq->ctrl->subsys;
+ 	u32 result;
+ 
+ 	req->ns = nvmet_find_namespace(req->sq->ctrl, req->cmd->common.nsid);
+ 	if (!req->ns)
+ 		return NVME_SC_INVALID_NS | NVME_SC_DNR;
+ 
+ 	mutex_lock(&subsys->lock);
+ 	if (req->ns->readonly == true)
+ 		result = NVME_NS_WRITE_PROTECT;
+ 	else
+ 		result = NVME_NS_NO_WRITE_PROTECT;
+ 	nvmet_set_result(req, result);
+ 	mutex_unlock(&subsys->lock);
+ 
+ 	return 0;
+ }
+ 
+ void nvmet_get_feat_kato(struct nvmet_req *req)
+ {
+ 	nvmet_set_result(req, req->sq->ctrl->kato * 1000);
+ }
+ 
+ void nvmet_get_feat_async_event(struct nvmet_req *req)
+ {
+ 	nvmet_set_result(req, READ_ONCE(req->sq->ctrl->aen_enabled));
+ }
+ 
++>>>>>>> 90107455cce7 (nvmet: make kato and AEN processing for use by other controllers)
  static void nvmet_execute_get_features(struct nvmet_req *req)
  {
  	struct nvmet_subsys *subsys = req->sq->ctrl->subsys;
* Unmerged path drivers/nvme/target/admin-cmd.c
diff --git a/drivers/nvme/target/nvmet.h b/drivers/nvme/target/nvmet.h
index 8dc4ba424a82..b8e671fe7211 100644
--- a/drivers/nvme/target/nvmet.h
+++ b/drivers/nvme/target/nvmet.h
@@ -328,6 +328,12 @@ static inline bool nvmet_aen_disabled(struct nvmet_ctrl *ctrl, u32 aen)
 	return test_and_set_bit(aen, &ctrl->aen_masked);
 }
 
+void nvmet_get_feat_kato(struct nvmet_req *req);
+void nvmet_get_feat_async_event(struct nvmet_req *req);
+u16 nvmet_set_feat_kato(struct nvmet_req *req);
+u16 nvmet_set_feat_async_event(struct nvmet_req *req, u32 mask);
+void nvmet_execute_async_event(struct nvmet_req *req);
+
 u16 nvmet_parse_connect_cmd(struct nvmet_req *req);
 u16 nvmet_bdev_parse_io_cmd(struct nvmet_req *req);
 u16 nvmet_file_parse_io_cmd(struct nvmet_req *req);
