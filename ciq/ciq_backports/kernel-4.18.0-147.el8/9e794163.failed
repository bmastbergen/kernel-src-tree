bpf: Remove bpf_dump_raw_ok() check for func_info and line_info

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Martin KaFai Lau <kafai@fb.com>
commit 9e794163a69c103633fefb10a3879408d4e4e2c8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/9e794163.failed

The func_info and line_info have the bpf insn offset but
they do not contain kernel address.  They will still be useful
for the userspace tool to annotate the xlated insn.

This patch removes the bpf_dump_raw_ok() guard for the
func_info and line_info during bpf_prog_get_info_by_fd().

The guard stays for jited_line_info which contains the kernel
address.

Although this bpf_dump_raw_ok() guard behavior has started since
the earlier func_info patch series, I marked the Fixes tag to the
latest line_info patch series which contains both func_info and
line_info and this patch is fixing for both of them.

Fixes: c454a46b5efd ("bpf: Add bpf_line_info support")
	Signed-off-by: Martin KaFai Lau <kafai@fb.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit 9e794163a69c103633fefb10a3879408d4e4e2c8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/syscall.c
diff --cc kernel/bpf/syscall.c
index 3cd7e2d75b5a,b7c585838c72..000000000000
--- a/kernel/bpf/syscall.c
+++ b/kernel/bpf/syscall.c
@@@ -2230,6 -2266,55 +2230,58 @@@ static int bpf_prog_get_info_by_fd(stru
  		}
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (prog->aux->btf)
+ 		info.btf_id = btf_id(prog->aux->btf);
+ 
+ 	ulen = info.nr_func_info;
+ 	info.nr_func_info = prog->aux->func_info_cnt;
+ 	if (info.nr_func_info && ulen) {
+ 		char __user *user_finfo;
+ 
+ 		user_finfo = u64_to_user_ptr(info.func_info);
+ 		ulen = min_t(u32, info.nr_func_info, ulen);
+ 		if (copy_to_user(user_finfo, prog->aux->func_info,
+ 				 info.func_info_rec_size * ulen))
+ 			return -EFAULT;
+ 	}
+ 
+ 	ulen = info.nr_line_info;
+ 	info.nr_line_info = prog->aux->nr_linfo;
+ 	if (info.nr_line_info && ulen) {
+ 		__u8 __user *user_linfo;
+ 
+ 		user_linfo = u64_to_user_ptr(info.line_info);
+ 		ulen = min_t(u32, info.nr_line_info, ulen);
+ 		if (copy_to_user(user_linfo, prog->aux->linfo,
+ 				 info.line_info_rec_size * ulen))
+ 			return -EFAULT;
+ 	}
+ 
+ 	ulen = info.nr_jited_line_info;
+ 	if (prog->aux->jited_linfo)
+ 		info.nr_jited_line_info = prog->aux->nr_linfo;
+ 	else
+ 		info.nr_jited_line_info = 0;
+ 	if (info.nr_jited_line_info && ulen) {
+ 		if (bpf_dump_raw_ok()) {
+ 			__u64 __user *user_linfo;
+ 			u32 i;
+ 
+ 			user_linfo = u64_to_user_ptr(info.jited_line_info);
+ 			ulen = min_t(u32, info.nr_jited_line_info, ulen);
+ 			for (i = 0; i < ulen; i++) {
+ 				if (put_user((__u64)(long)prog->aux->jited_linfo[i],
+ 					     &user_linfo[i]))
+ 					return -EFAULT;
+ 			}
+ 		} else {
+ 			info.jited_line_info = 0;
+ 		}
+ 	}
+ 
++>>>>>>> 9e794163a69c (bpf: Remove bpf_dump_raw_ok() check for func_info and line_info)
  done:
  	if (copy_to_user(uinfo, &info, info_len) ||
  	    put_user(info_len, &uattr->info.info_len))
* Unmerged path kernel/bpf/syscall.c
