libbpf: Consistent prefixes for interfaces in nlattr.h.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [tools] libbpf: Consistent prefixes for interfaces in nlattr.h (Yauheni Kaliuta) [1700846]
Rebuild_FUZZ: 99.08%
commit-author Andrey Ignatov <rdna@fb.com>
commit f04bc8a436e1b32f842a631ff889954bdf56b720
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/f04bc8a4.failed

libbpf is used more and more outside kernel tree. That means the library
should follow good practices in library design and implementation to
play well with third party code that uses it.

One of such practices is to have a common prefix (or a few) for every
interface, function or data structure, library provides. I helps to
avoid name conflicts with other libraries and keeps API consistent.

Inconsistent names in libbpf already cause problems in real life. E.g.
an application can't use both libbpf and libnl due to conflicting
symbols.

Having common prefix will help to fix current and avoid future problems.

libbpf already uses the following prefixes for its interfaces:
* bpf_ for bpf system call wrappers, program/map/elf-object
  abstractions and a few other things;
* btf_ for BTF related API;
* libbpf_ for everything else.

The patch adds libbpf_ prefix to interfaces in nlattr.h that use none of
mentioned above prefixes and doesn't fit well into the first two
categories.

Since affected part of API is used in bpftool, the patch applies
corresponding change to bpftool as well. Having it in a separate patch
will cause a state of tree where bpftool is broken what may not be a
good idea.

	Signed-off-by: Andrey Ignatov <rdna@fb.com>
	Acked-by: Alexei Starovoitov <ast@kernel.org>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit f04bc8a436e1b32f842a631ff889954bdf56b720)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/netlink.c
#	tools/lib/bpf/nlattr.c
#	tools/lib/bpf/nlattr.h
diff --cc tools/lib/bpf/nlattr.c
index 4719434278b2,e52257a7367a..000000000000
--- a/tools/lib/bpf/nlattr.c
+++ b/tools/lib/bpf/nlattr.c
@@@ -17,20 -17,15 +17,20 @@@
  #include <string.h>
  #include <stdio.h>
  
- static uint16_t nla_attr_minlen[NLA_TYPE_MAX+1] = {
- 	[NLA_U8]	= sizeof(uint8_t),
- 	[NLA_U16]	= sizeof(uint16_t),
- 	[NLA_U32]	= sizeof(uint32_t),
- 	[NLA_U64]	= sizeof(uint64_t),
- 	[NLA_STRING]	= 1,
- 	[NLA_FLAG]	= 0,
+ static uint16_t nla_attr_minlen[LIBBPF_NLA_TYPE_MAX+1] = {
+ 	[LIBBPF_NLA_U8]		= sizeof(uint8_t),
+ 	[LIBBPF_NLA_U16]	= sizeof(uint16_t),
+ 	[LIBBPF_NLA_U32]	= sizeof(uint32_t),
+ 	[LIBBPF_NLA_U64]	= sizeof(uint64_t),
+ 	[LIBBPF_NLA_STRING]	= 1,
+ 	[LIBBPF_NLA_FLAG]	= 0,
  };
  
 +static int nla_len(const struct nlattr *nla)
 +{
 +	return nla->nla_len - NLA_HDRLEN;
 +}
 +
  static struct nlattr *nla_next(const struct nlattr *nla, int *remaining)
  {
  	int totlen = NLA_ALIGN(nla->nla_len);
@@@ -114,8 -105,8 +115,13 @@@ static inline int nlmsg_len(const struc
   * @see nla_validate
   * @return 0 on success or a negative error code.
   */
++<<<<<<< HEAD
 +static int nla_parse(struct nlattr *tb[], int maxtype, struct nlattr *head, int len,
 +		     struct nla_policy *policy)
++=======
+ int libbpf_nla_parse(struct nlattr *tb[], int maxtype, struct nlattr *head,
+ 		     int len, struct libbpf_nla_policy *policy)
++>>>>>>> f04bc8a436e1 (libbpf: Consistent prefixes for interfaces in nlattr.h.)
  {
  	struct nlattr *nla;
  	int rem, err;
@@@ -146,12 -137,33 +152,36 @@@ errout
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * Create attribute index based on nested attribute
+  * @arg tb              Index array to be filled (maxtype+1 elements).
+  * @arg maxtype         Maximum attribute type expected and accepted.
+  * @arg nla             Nested Attribute.
+  * @arg policy          Attribute validation policy.
+  *
+  * Feeds the stream of attributes nested into the specified attribute
+  * to libbpf_nla_parse().
+  *
+  * @see libbpf_nla_parse
+  * @return 0 on success or a negative error code.
+  */
+ int libbpf_nla_parse_nested(struct nlattr *tb[], int maxtype,
+ 			    struct nlattr *nla,
+ 			    struct libbpf_nla_policy *policy)
+ {
+ 	return libbpf_nla_parse(tb, maxtype, libbpf_nla_data(nla),
+ 				libbpf_nla_len(nla), policy);
+ }
+ 
++>>>>>>> f04bc8a436e1 (libbpf: Consistent prefixes for interfaces in nlattr.h.)
  /* dump netlink extended ack error message */
- int nla_dump_errormsg(struct nlmsghdr *nlh)
+ int libbpf_nla_dump_errormsg(struct nlmsghdr *nlh)
  {
- 	struct nla_policy extack_policy[NLMSGERR_ATTR_MAX + 1] = {
- 		[NLMSGERR_ATTR_MSG]	= { .type = NLA_STRING },
- 		[NLMSGERR_ATTR_OFFS]	= { .type = NLA_U32 },
+ 	struct libbpf_nla_policy extack_policy[NLMSGERR_ATTR_MAX + 1] = {
+ 		[NLMSGERR_ATTR_MSG]	= { .type = LIBBPF_NLA_STRING },
+ 		[NLMSGERR_ATTR_OFFS]	= { .type = LIBBPF_NLA_U32 },
  	};
  	struct nlattr *tb[NLMSGERR_ATTR_MAX + 1], *attr;
  	struct nlmsgerr *err;
diff --cc tools/lib/bpf/nlattr.h
index 931a71f68f93,755a3312c87f..000000000000
--- a/tools/lib/bpf/nlattr.h
+++ b/tools/lib/bpf/nlattr.h
@@@ -67,6 -67,45 +67,49 @@@ struct libbpf_nla_policy 
  	     nla_ok(pos, rem); \
  	     pos = nla_next(pos, &(rem)))
  
++<<<<<<< HEAD
 +int nla_dump_errormsg(struct nlmsghdr *nlh);
++=======
+ /**
+  * libbpf_nla_data - head of payload
+  * @nla: netlink attribute
+  */
+ static inline void *libbpf_nla_data(const struct nlattr *nla)
+ {
+ 	return (char *) nla + NLA_HDRLEN;
+ }
+ 
+ static inline uint8_t libbpf_nla_getattr_u8(const struct nlattr *nla)
+ {
+ 	return *(uint8_t *)libbpf_nla_data(nla);
+ }
+ 
+ static inline uint32_t libbpf_nla_getattr_u32(const struct nlattr *nla)
+ {
+ 	return *(uint32_t *)libbpf_nla_data(nla);
+ }
+ 
+ static inline const char *libbpf_nla_getattr_str(const struct nlattr *nla)
+ {
+ 	return (const char *)libbpf_nla_data(nla);
+ }
+ 
+ /**
+  * libbpf_nla_len - length of payload
+  * @nla: netlink attribute
+  */
+ static inline int libbpf_nla_len(const struct nlattr *nla)
+ {
+ 	return nla->nla_len - NLA_HDRLEN;
+ }
+ 
+ int libbpf_nla_parse(struct nlattr *tb[], int maxtype, struct nlattr *head,
+ 		     int len, struct libbpf_nla_policy *policy);
+ int libbpf_nla_parse_nested(struct nlattr *tb[], int maxtype,
+ 			    struct nlattr *nla,
+ 			    struct libbpf_nla_policy *policy);
+ 
+ int libbpf_nla_dump_errormsg(struct nlmsghdr *nlh);
++>>>>>>> f04bc8a436e1 (libbpf: Consistent prefixes for interfaces in nlattr.h.)
  
  #endif /* __NLATTR_H */
* Unmerged path tools/lib/bpf/netlink.c
diff --git a/tools/bpf/bpftool/net.c b/tools/bpf/bpftool/net.c
index ed205ee57655..7c7de624a13d 100644
--- a/tools/bpf/bpftool/net.c
+++ b/tools/bpf/bpftool/net.c
@@ -69,7 +69,9 @@ static int dump_link_nlmsg(void *cookie, void *msg, struct nlattr **tb)
 	snprintf(netinfo->devices[netinfo->used_len].devname,
 		 sizeof(netinfo->devices[netinfo->used_len].devname),
 		 "%s",
-		 tb[IFLA_IFNAME] ? nla_getattr_str(tb[IFLA_IFNAME]) : "");
+		 tb[IFLA_IFNAME]
+			 ? libbpf_nla_getattr_str(tb[IFLA_IFNAME])
+			 : "");
 	netinfo->used_len++;
 
 	return do_xdp_dump(ifinfo, tb);
@@ -83,7 +85,7 @@ static int dump_class_qdisc_nlmsg(void *cookie, void *msg, struct nlattr **tb)
 	if (tcinfo->is_qdisc) {
 		/* skip clsact qdisc */
 		if (tb[TCA_KIND] &&
-		    strcmp(nla_data(tb[TCA_KIND]), "clsact") == 0)
+		    strcmp(libbpf_nla_data(tb[TCA_KIND]), "clsact") == 0)
 			return 0;
 		if (info->tcm_handle == 0)
 			return 0;
@@ -101,7 +103,9 @@ static int dump_class_qdisc_nlmsg(void *cookie, void *msg, struct nlattr **tb)
 	snprintf(tcinfo->handle_array[tcinfo->used_len].kind,
 		 sizeof(tcinfo->handle_array[tcinfo->used_len].kind),
 		 "%s",
-		 tb[TCA_KIND] ? nla_getattr_str(tb[TCA_KIND]) : "unknown");
+		 tb[TCA_KIND]
+			 ? libbpf_nla_getattr_str(tb[TCA_KIND])
+			 : "unknown");
 	tcinfo->used_len++;
 
 	return 0;
diff --git a/tools/bpf/bpftool/netlink_dumper.c b/tools/bpf/bpftool/netlink_dumper.c
index 6f5e9cc6836c..4e9f4531269f 100644
--- a/tools/bpf/bpftool/netlink_dumper.c
+++ b/tools/bpf/bpftool/netlink_dumper.c
@@ -21,7 +21,7 @@ static void xdp_dump_prog_id(struct nlattr **tb, int attr,
 	if (new_json_object)
 		NET_START_OBJECT
 	NET_DUMP_STR("mode", " %s", mode);
-	NET_DUMP_UINT("id", " id %u", nla_getattr_u32(tb[attr]))
+	NET_DUMP_UINT("id", " id %u", libbpf_nla_getattr_u32(tb[attr]))
 	if (new_json_object)
 		NET_END_OBJECT
 }
@@ -32,13 +32,13 @@ static int do_xdp_dump_one(struct nlattr *attr, unsigned int ifindex,
 	struct nlattr *tb[IFLA_XDP_MAX + 1];
 	unsigned char mode;
 
-	if (nla_parse_nested(tb, IFLA_XDP_MAX, attr, NULL) < 0)
+	if (libbpf_nla_parse_nested(tb, IFLA_XDP_MAX, attr, NULL) < 0)
 		return -1;
 
 	if (!tb[IFLA_XDP_ATTACHED])
 		return 0;
 
-	mode = nla_getattr_u8(tb[IFLA_XDP_ATTACHED]);
+	mode = libbpf_nla_getattr_u8(tb[IFLA_XDP_ATTACHED]);
 	if (mode == XDP_ATTACHED_NONE)
 		return 0;
 
@@ -75,14 +75,14 @@ int do_xdp_dump(struct ifinfomsg *ifinfo, struct nlattr **tb)
 		return 0;
 
 	return do_xdp_dump_one(tb[IFLA_XDP], ifinfo->ifi_index,
-			       nla_getattr_str(tb[IFLA_IFNAME]));
+			       libbpf_nla_getattr_str(tb[IFLA_IFNAME]));
 }
 
 static int do_bpf_dump_one_act(struct nlattr *attr)
 {
 	struct nlattr *tb[TCA_ACT_BPF_MAX + 1];
 
-	if (nla_parse_nested(tb, TCA_ACT_BPF_MAX, attr, NULL) < 0)
+	if (libbpf_nla_parse_nested(tb, TCA_ACT_BPF_MAX, attr, NULL) < 0)
 		return -LIBBPF_ERRNO__NLPARSE;
 
 	if (!tb[TCA_ACT_BPF_PARMS])
@@ -91,10 +91,10 @@ static int do_bpf_dump_one_act(struct nlattr *attr)
 	NET_START_OBJECT_NESTED2;
 	if (tb[TCA_ACT_BPF_NAME])
 		NET_DUMP_STR("name", "%s",
-			     nla_getattr_str(tb[TCA_ACT_BPF_NAME]));
+			     libbpf_nla_getattr_str(tb[TCA_ACT_BPF_NAME]));
 	if (tb[TCA_ACT_BPF_ID])
 		NET_DUMP_UINT("id", " id %u",
-			      nla_getattr_u32(tb[TCA_ACT_BPF_ID]));
+			      libbpf_nla_getattr_u32(tb[TCA_ACT_BPF_ID]));
 	NET_END_OBJECT_NESTED;
 	return 0;
 }
@@ -106,10 +106,11 @@ static int do_dump_one_act(struct nlattr *attr)
 	if (!attr)
 		return 0;
 
-	if (nla_parse_nested(tb, TCA_ACT_MAX, attr, NULL) < 0)
+	if (libbpf_nla_parse_nested(tb, TCA_ACT_MAX, attr, NULL) < 0)
 		return -LIBBPF_ERRNO__NLPARSE;
 
-	if (tb[TCA_ACT_KIND] && strcmp(nla_data(tb[TCA_ACT_KIND]), "bpf") == 0)
+	if (tb[TCA_ACT_KIND] &&
+	    strcmp(libbpf_nla_data(tb[TCA_ACT_KIND]), "bpf") == 0)
 		return do_bpf_dump_one_act(tb[TCA_ACT_OPTIONS]);
 
 	return 0;
@@ -120,7 +121,7 @@ static int do_bpf_act_dump(struct nlattr *attr)
 	struct nlattr *tb[TCA_ACT_MAX_PRIO + 1];
 	int act, ret;
 
-	if (nla_parse_nested(tb, TCA_ACT_MAX_PRIO, attr, NULL) < 0)
+	if (libbpf_nla_parse_nested(tb, TCA_ACT_MAX_PRIO, attr, NULL) < 0)
 		return -LIBBPF_ERRNO__NLPARSE;
 
 	NET_START_ARRAY("act", " %s [");
@@ -139,13 +140,15 @@ static int do_bpf_filter_dump(struct nlattr *attr)
 	struct nlattr *tb[TCA_BPF_MAX + 1];
 	int ret;
 
-	if (nla_parse_nested(tb, TCA_BPF_MAX, attr, NULL) < 0)
+	if (libbpf_nla_parse_nested(tb, TCA_BPF_MAX, attr, NULL) < 0)
 		return -LIBBPF_ERRNO__NLPARSE;
 
 	if (tb[TCA_BPF_NAME])
-		NET_DUMP_STR("name", " %s", nla_getattr_str(tb[TCA_BPF_NAME]));
+		NET_DUMP_STR("name", " %s",
+			     libbpf_nla_getattr_str(tb[TCA_BPF_NAME]));
 	if (tb[TCA_BPF_ID])
-		NET_DUMP_UINT("id", " id %u", nla_getattr_u32(tb[TCA_BPF_ID]));
+		NET_DUMP_UINT("id", " id %u",
+			      libbpf_nla_getattr_u32(tb[TCA_BPF_ID]));
 	if (tb[TCA_BPF_ACT]) {
 		ret = do_bpf_act_dump(tb[TCA_BPF_ACT]);
 		if (ret)
@@ -160,7 +163,8 @@ int do_filter_dump(struct tcmsg *info, struct nlattr **tb, const char *kind,
 {
 	int ret = 0;
 
-	if (tb[TCA_OPTIONS] && strcmp(nla_data(tb[TCA_KIND]), "bpf") == 0) {
+	if (tb[TCA_OPTIONS] &&
+	    strcmp(libbpf_nla_data(tb[TCA_KIND]), "bpf") == 0) {
 		NET_START_OBJECT;
 		if (devname[0] != '\0')
 			NET_DUMP_STR("devname", "%s", devname);
* Unmerged path tools/lib/bpf/netlink.c
* Unmerged path tools/lib/bpf/nlattr.c
* Unmerged path tools/lib/bpf/nlattr.h
