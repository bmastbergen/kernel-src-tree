cgroup: get rid of cgroup_freezer_frozen_exit()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Roman Gushchin <guro@fb.com>
commit 96b9c592def5d7203bdad1337d9c92a2183de5cb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/96b9c592.failed

A task should never enter the exit path with the task->frozen bit set.
Any frozen task must enter the signal handling loop and the only
way to escape is through cgroup_leave_frozen(true), which
unconditionally drops the task->frozen bit. So it means that
cgroyp_freezer_frozen_exit() has zero chances to be called and
has to be removed.

Let's put a WARN_ON_ONCE() instead of the cgroup_freezer_frozen_exit()
call to catch any potential leak of the task's frozen bit.

	Suggested-by: Oleg Nesterov <oleg@redhat.com>
	Signed-off-by: Roman Gushchin <guro@fb.com>
	Signed-off-by: Tejun Heo <tj@kernel.org>
(cherry picked from commit 96b9c592def5d7203bdad1337d9c92a2183de5cb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/cgroup.h
#	kernel/cgroup/cgroup.c
#	kernel/cgroup/freezer.c
diff --cc include/linux/cgroup.h
index 0c4d56acfdca,c0077adeea83..000000000000
--- a/include/linux/cgroup.h
+++ b/include/linux/cgroup.h
@@@ -843,4 -881,47 +843,50 @@@ static inline void put_cgroup_ns(struc
  		free_cgroup_ns(ns);
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_CGROUPS
+ 
+ void cgroup_enter_frozen(void);
+ void cgroup_leave_frozen(bool always_leave);
+ void cgroup_update_frozen(struct cgroup *cgrp);
+ void cgroup_freeze(struct cgroup *cgrp, bool freeze);
+ void cgroup_freezer_migrate_task(struct task_struct *task, struct cgroup *src,
+ 				 struct cgroup *dst);
+ 
+ static inline bool cgroup_task_freeze(struct task_struct *task)
+ {
+ 	bool ret;
+ 
+ 	if (task->flags & PF_KTHREAD)
+ 		return false;
+ 
+ 	rcu_read_lock();
+ 	ret = test_bit(CGRP_FREEZE, &task_dfl_cgroup(task)->flags);
+ 	rcu_read_unlock();
+ 
+ 	return ret;
+ }
+ 
+ static inline bool cgroup_task_frozen(struct task_struct *task)
+ {
+ 	return task->frozen;
+ }
+ 
+ #else /* !CONFIG_CGROUPS */
+ 
+ static inline void cgroup_enter_frozen(void) { }
+ static inline void cgroup_leave_frozen(bool always_leave) { }
+ static inline bool cgroup_task_freeze(struct task_struct *task)
+ {
+ 	return false;
+ }
+ static inline bool cgroup_task_frozen(struct task_struct *task)
+ {
+ 	return false;
+ }
+ 
+ #endif /* !CONFIG_CGROUPS */
+ 
++>>>>>>> 96b9c592def5 (cgroup: get rid of cgroup_freezer_frozen_exit())
  #endif /* _LINUX_CGROUP_H */
diff --cc kernel/cgroup/cgroup.c
index a73ca9f49f35,327f37c9fdfa..000000000000
--- a/kernel/cgroup/cgroup.c
+++ b/kernel/cgroup/cgroup.c
@@@ -5734,6 -5925,11 +5734,14 @@@ void cgroup_exit(struct task_struct *ts
  		spin_lock_irq(&css_set_lock);
  		css_set_move_task(tsk, cset, NULL, false);
  		cset->nr_tasks--;
++<<<<<<< HEAD
++=======
+ 
+ 		WARN_ON_ONCE(cgroup_task_frozen(tsk));
+ 		if (unlikely(cgroup_task_freeze(tsk)))
+ 			cgroup_update_frozen(task_dfl_cgroup(tsk));
+ 
++>>>>>>> 96b9c592def5 (cgroup: get rid of cgroup_freezer_frozen_exit())
  		spin_unlock_irq(&css_set_lock);
  	} else {
  		get_css_set(cset);
* Unmerged path kernel/cgroup/freezer.c
* Unmerged path include/linux/cgroup.h
* Unmerged path kernel/cgroup/cgroup.c
* Unmerged path kernel/cgroup/freezer.c
