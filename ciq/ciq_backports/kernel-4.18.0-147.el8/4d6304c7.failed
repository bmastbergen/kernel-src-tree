bpf: Add unit tests for bpf_line_info

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Martin KaFai Lau <kafai@fb.com>
commit 4d6304c763551cdb420201b1b754cc625d56bdd6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/4d6304c7.failed

Add unit tests for bpf_line_info for both BPF_PROG_LOAD and
BPF_OBJ_GET_INFO_BY_FD.

jit enabled:
[root@arch-fb-vm1 bpf]# ./test_btf -k 0
BTF prog info raw test[5] (line_info (No subprog)): OK
BTF prog info raw test[6] (line_info (No subprog. insn_off >= prog->len)): OK
BTF prog info raw test[7] (line_info (No subprog. zero tailing line_info): OK
BTF prog info raw test[8] (line_info (No subprog. nonzero tailing line_info)): OK
BTF prog info raw test[9] (line_info (subprog)): OK
BTF prog info raw test[10] (line_info (subprog + func_info)): OK
BTF prog info raw test[11] (line_info (subprog. missing 1st func line info)): OK
BTF prog info raw test[12] (line_info (subprog. missing 2nd func line info)): OK
BTF prog info raw test[13] (line_info (subprog. unordered insn offset)): OK

jit disabled:
BTF prog info raw test[5] (line_info (No subprog)): not jited. skipping jited_line_info check. OK
BTF prog info raw test[6] (line_info (No subprog. insn_off >= prog->len)): OK
BTF prog info raw test[7] (line_info (No subprog. zero tailing line_info): not jited. skipping jited_line_info check. OK
BTF prog info raw test[8] (line_info (No subprog. nonzero tailing line_info)): OK
BTF prog info raw test[9] (line_info (subprog)): not jited. skipping jited_line_info check. OK
BTF prog info raw test[10] (line_info (subprog + func_info)): not jited. skipping jited_line_info check. OK
BTF prog info raw test[11] (line_info (subprog. missing 1st func line info)): OK
BTF prog info raw test[12] (line_info (subprog. missing 2nd func line info)): OK
BTF prog info raw test[13] (line_info (subprog. unordered insn offset)): OK

	Signed-off-by: Martin KaFai Lau <kafai@fb.com>
	Acked-by: Yonghong Song <yhs@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit 4d6304c763551cdb420201b1b754cc625d56bdd6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/bpf/test_btf.c
diff --cc tools/testing/selftests/bpf/test_btf.c
index 42aad55cbe88,7707273736ac..000000000000
--- a/tools/testing/selftests/bpf/test_btf.c
+++ b/tools/testing/selftests/bpf/test_btf.c
@@@ -3412,18 -3059,25 +3418,29 @@@ static int test_pprint(void
  	return err;
  }
  
++<<<<<<< HEAD
 +static struct btf_func_type_test {
++=======
+ #define BPF_LINE_INFO_ENC(insn_off, file_off, line_off, line_num, line_col) \
+ 	(insn_off), (file_off), (line_off), ((line_num) << 10 | ((line_col) & 0x3ff))
+ 
+ static struct prog_info_raw_test {
++>>>>>>> 4d6304c76355 (bpf: Add unit tests for bpf_line_info)
  	const char *descr;
  	const char *str_sec;
- 	__u32 raw_types[MAX_NR_RAW_TYPES];
+ 	const char *err_str;
+ 	__u32 raw_types[MAX_NR_RAW_U32];
  	__u32 str_sec_size;
  	struct bpf_insn insns[MAX_INSNS];
  	__u32 prog_type;
  	__u32 func_info[MAX_SUBPROGS][2];
  	__u32 func_info_rec_size;
  	__u32 func_info_cnt;
+ 	__u32 line_info[MAX_NR_RAW_U32];
+ 	__u32 line_info_rec_size;
+ 	__u32 nr_jited_ksyms;
  	bool expected_prog_load_failure;
 -} info_raw_tests[] = {
 +} func_type_test[] = {
  {
  	.descr = "func_type (main func + one sub)",
  	.raw_types = {
@@@ -3559,20 -3488,352 +3851,362 @@@ static size_t probe_prog_length(const s
  	return len + 1;
  }
  
++<<<<<<< HEAD
 +static int do_test_func_type(int test_num)
++=======
+ static __u32 *patch_name_tbd(const __u32 *raw_u32,
+ 			     const char *str, __u32 str_off,
+ 			     unsigned int str_sec_size,
+ 			     unsigned int *ret_size)
+ {
+ 	int i, raw_u32_size = get_raw_sec_size(raw_u32);
+ 	const char *end_str = str + str_sec_size;
+ 	const char *next_str = str + str_off;
+ 	__u32 *new_u32 = NULL;
+ 
+ 	if (raw_u32_size == -1)
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	if (!raw_u32_size) {
+ 		*ret_size = 0;
+ 		return NULL;
+ 	}
+ 
+ 	new_u32 = malloc(raw_u32_size);
+ 	if (!new_u32)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	for (i = 0; i < raw_u32_size / sizeof(raw_u32[0]); i++) {
+ 		if (raw_u32[i] == NAME_TBD) {
+ 			next_str = get_next_str(next_str, end_str);
+ 			if (CHECK(!next_str, "Error in getting next_str\n")) {
+ 				free(new_u32);
+ 				return ERR_PTR(-EINVAL);
+ 			}
+ 			new_u32[i] = next_str - str;
+ 			next_str += strlen(next_str);
+ 		} else {
+ 			new_u32[i] = raw_u32[i];
+ 		}
+ 	}
+ 
+ 	*ret_size = raw_u32_size;
+ 	return new_u32;
+ }
+ 
+ static int test_get_finfo(const struct prog_info_raw_test *test,
+ 			  int prog_fd)
++>>>>>>> 4d6304c76355 (bpf: Add unit tests for bpf_line_info)
  {
 +	const struct btf_func_type_test *test = &func_type_test[test_num];
 +	unsigned int raw_btf_size, info_len, rec_size;
 +	int i, btf_fd = -1, prog_fd = -1, err = 0;
 +	struct bpf_load_program_attr attr = {};
 +	void *raw_btf, *func_info = NULL;
  	struct bpf_prog_info info = {};
  	struct bpf_func_info *finfo;
 -	__u32 info_len, rec_size, i;
 -	void *func_info = NULL;
 -	int err;
  
++<<<<<<< HEAD
 +	fprintf(stderr, "%s......", test->descr);
++=======
+ 	/* get necessary lens */
+ 	info_len = sizeof(struct bpf_prog_info);
+ 	err = bpf_obj_get_info_by_fd(prog_fd, &info, &info_len);
+ 	if (CHECK(err == -1, "invalid get info (1st) errno:%d", errno)) {
+ 		fprintf(stderr, "%s\n", btf_log_buf);
+ 		return -1;
+ 	}
+ 	if (CHECK(info.func_info_cnt != test->func_info_cnt,
+ 		  "incorrect info.func_info_cnt (1st) %d",
+ 		  info.func_info_cnt)) {
+ 		return -1;
+ 	}
+ 
+ 	rec_size = info.func_info_rec_size;
+ 	if (CHECK(rec_size < 8,
+ 		  "incorrect info.func_info_rec_size (1st) %d", rec_size)) {
+ 		return -1;
+ 	}
+ 
+ 	if (!info.func_info_cnt)
+ 		return 0;
+ 
+ 	func_info = malloc(info.func_info_cnt * rec_size);
+ 	if (CHECK(!func_info, "out of memory"))
+ 		return -1;
+ 
+ 	/* reset info to only retrieve func_info related data */
+ 	memset(&info, 0, sizeof(info));
+ 	info.func_info_cnt = test->func_info_cnt;
+ 	info.func_info_rec_size = rec_size;
+ 	info.func_info = ptr_to_u64(func_info);
+ 	err = bpf_obj_get_info_by_fd(prog_fd, &info, &info_len);
+ 	if (CHECK(err == -1, "invalid get info (2nd) errno:%d", errno)) {
+ 		fprintf(stderr, "%s\n", btf_log_buf);
+ 		err = -1;
+ 		goto done;
+ 	}
+ 	if (CHECK(info.func_info_cnt != test->func_info_cnt,
+ 		  "incorrect info.func_info_cnt (2nd) %d",
+ 		  info.func_info_cnt)) {
+ 		err = -1;
+ 		goto done;
+ 	}
+ 	if (CHECK(info.func_info_rec_size < 8,
+ 		  "incorrect info.func_info_rec_size (2nd) %d",
+ 		  info.func_info_rec_size)) {
+ 		err = -1;
+ 		goto done;
+ 	}
+ 
+ 	if (CHECK(!info.func_info,
+ 		  "info.func_info == 0. kernel.kptr_restrict is set?")) {
+ 		err = -1;
+ 		goto done;
+ 	}
+ 
+ 	finfo = func_info;
+ 	for (i = 0; i < test->func_info_cnt; i++) {
+ 		if (CHECK(finfo->type_id != test->func_info[i][1],
+ 			  "incorrect func_type %u expected %u",
+ 			  finfo->type_id, test->func_info[i][1])) {
+ 			err = -1;
+ 			goto done;
+ 		}
+ 		finfo = (void *)finfo + rec_size;
+ 	}
+ 
+ 	err = 0;
+ 
+ done:
+ 	free(func_info);
+ 	return err;
+ }
+ 
+ static int test_get_linfo(const struct prog_info_raw_test *test,
+ 			  const void *patched_linfo,
+ 			  __u32 cnt, int prog_fd)
+ {
+ 	__u32 i, info_len, nr_jited_ksyms, nr_jited_func_lens;
+ 	__u64 *jited_linfo = NULL, *jited_ksyms = NULL;
+ 	__u32 rec_size, jited_rec_size, jited_cnt;
+ 	struct bpf_line_info *linfo = NULL;
+ 	__u32 cur_func_len, ksyms_found;
+ 	struct bpf_prog_info info = {};
+ 	__u32 *jited_func_lens = NULL;
+ 	__u64 cur_func_ksyms;
+ 	int err;
+ 
+ 	jited_cnt = cnt;
+ 	rec_size = sizeof(*linfo);
+ 	jited_rec_size = sizeof(*jited_linfo);
+ 	if (test->nr_jited_ksyms)
+ 		nr_jited_ksyms = test->nr_jited_ksyms;
+ 	else
+ 		nr_jited_ksyms = test->func_info_cnt;
+ 	nr_jited_func_lens = nr_jited_ksyms;
+ 
+ 	info_len = sizeof(struct bpf_prog_info);
+ 	err = bpf_obj_get_info_by_fd(prog_fd, &info, &info_len);
+ 	if (CHECK(err == -1, "err:%d errno:%d", err, errno)) {
+ 		err = -1;
+ 		goto done;
+ 	}
+ 
+ 	if (!info.jited_prog_len) {
+ 		/* prog is not jited */
+ 		jited_cnt = 0;
+ 		nr_jited_ksyms = 1;
+ 		nr_jited_func_lens = 1;
+ 	}
+ 
+ 	if (CHECK(info.line_info_cnt != cnt ||
+ 		  info.jited_line_info_cnt != jited_cnt ||
+ 		  info.nr_jited_ksyms != nr_jited_ksyms ||
+ 		  info.nr_jited_func_lens != nr_jited_func_lens ||
+ 		  (!info.line_info_cnt && info.jited_line_info_cnt),
+ 		  "info: line_info_cnt:%u(expected:%u) jited_line_info_cnt:%u(expected:%u) nr_jited_ksyms:%u(expected:%u) nr_jited_func_lens:%u(expected:%u)",
+ 		  info.line_info_cnt, cnt,
+ 		  info.jited_line_info_cnt, jited_cnt,
+ 		  info.nr_jited_ksyms, nr_jited_ksyms,
+ 		  info.nr_jited_func_lens, nr_jited_func_lens)) {
+ 		err = -1;
+ 		goto done;
+ 	}
+ 
+ 	if (CHECK(info.line_info_rec_size < 16 ||
+ 		  info.jited_line_info_rec_size < 8,
+ 		  "info: line_info_rec_size:%u(userspace expected:%u) jited_line_info_rec_size:%u(userspace expected:%u)",
+ 		  info.line_info_rec_size, rec_size,
+ 		  info.jited_line_info_rec_size, jited_rec_size)) {
+ 		err = -1;
+ 		goto done;
+ 	}
+ 
+ 	if (!cnt)
+ 		return 0;
+ 
+ 	rec_size = info.line_info_rec_size;
+ 	jited_rec_size = info.jited_line_info_rec_size;
+ 
+ 	memset(&info, 0, sizeof(info));
+ 
+ 	linfo = calloc(cnt, rec_size);
+ 	if (CHECK(!linfo, "!linfo")) {
+ 		err = -1;
+ 		goto done;
+ 	}
+ 	info.line_info_cnt = cnt;
+ 	info.line_info_rec_size = rec_size;
+ 	info.line_info = ptr_to_u64(linfo);
+ 
+ 	if (jited_cnt) {
+ 		jited_linfo = calloc(jited_cnt, jited_rec_size);
+ 		jited_ksyms = calloc(nr_jited_ksyms, sizeof(*jited_ksyms));
+ 		jited_func_lens = calloc(nr_jited_func_lens,
+ 					 sizeof(*jited_func_lens));
+ 		if (CHECK(!jited_linfo || !jited_ksyms || !jited_func_lens,
+ 			  "jited_linfo:%p jited_ksyms:%p jited_func_lens:%p",
+ 			  jited_linfo, jited_ksyms, jited_func_lens)) {
+ 			err = -1;
+ 			goto done;
+ 		}
+ 
+ 		info.jited_line_info_cnt = jited_cnt;
+ 		info.jited_line_info_rec_size = jited_rec_size;
+ 		info.jited_line_info = ptr_to_u64(jited_linfo);
+ 		info.nr_jited_ksyms = nr_jited_ksyms;
+ 		info.jited_ksyms = ptr_to_u64(jited_ksyms);
+ 		info.nr_jited_func_lens = nr_jited_func_lens;
+ 		info.jited_func_lens = ptr_to_u64(jited_func_lens);
+ 	}
+ 
+ 	err = bpf_obj_get_info_by_fd(prog_fd, &info, &info_len);
+ 
+ 	/*
+ 	 * Only recheck the info.*line_info* fields.
+ 	 * Other fields are not the concern of this test.
+ 	 */
+ 	if (CHECK(err == -1 ||
+ 		  !info.line_info ||
+ 		  info.line_info_cnt != cnt ||
+ 		  (jited_cnt && !info.jited_line_info) ||
+ 		  info.jited_line_info_cnt != jited_cnt ||
+ 		  info.line_info_rec_size != rec_size ||
+ 		  info.jited_line_info_rec_size != jited_rec_size,
+ 		  "err:%d errno:%d info: line_info_cnt:%u(expected:%u) jited_line_info_cnt:%u(expected:%u) line_info_rec_size:%u(expected:%u) jited_linfo_rec_size:%u(expected:%u) line_info:%p jited_line_info:%p",
+ 		  err, errno,
+ 		  info.line_info_cnt, cnt,
+ 		  info.jited_line_info_cnt, jited_cnt,
+ 		  info.line_info_rec_size, rec_size,
+ 		  info.jited_line_info_rec_size, jited_rec_size,
+ 		  (void *)(long)info.line_info,
+ 		  (void *)(long)info.jited_line_info)) {
+ 		err = -1;
+ 		goto done;
+ 	}
+ 
+ 	CHECK(linfo[0].insn_off, "linfo[0].insn_off:%u",
+ 	      linfo[0].insn_off);
+ 	for (i = 1; i < cnt; i++) {
+ 		const struct bpf_line_info *expected_linfo;
+ 
+ 		expected_linfo = patched_linfo + (i * test->line_info_rec_size);
+ 		if (CHECK(linfo[i].insn_off <= linfo[i - 1].insn_off,
+ 			  "linfo[%u].insn_off:%u <= linfo[%u].insn_off:%u",
+ 			  i, linfo[i].insn_off,
+ 			  i - 1, linfo[i - 1].insn_off)) {
+ 			err = -1;
+ 			goto done;
+ 		}
+ 		if (CHECK(linfo[i].file_name_off != expected_linfo->file_name_off ||
+ 			  linfo[i].line_off != expected_linfo->line_off ||
+ 			  linfo[i].line_col != expected_linfo->line_col,
+ 			  "linfo[%u] (%u, %u, %u) != (%u, %u, %u)", i,
+ 			  linfo[i].file_name_off,
+ 			  linfo[i].line_off,
+ 			  linfo[i].line_col,
+ 			  expected_linfo->file_name_off,
+ 			  expected_linfo->line_off,
+ 			  expected_linfo->line_col)) {
+ 			err = -1;
+ 			goto done;
+ 		}
+ 	}
+ 
+ 	if (!jited_cnt) {
+ 		fprintf(stderr, "not jited. skipping jited_line_info check. ");
+ 		err = 0;
+ 		goto done;
+ 	}
+ 
+ 	if (CHECK(jited_linfo[0] != jited_ksyms[0],
+ 		  "jited_linfo[0]:%lx != jited_ksyms[0]:%lx",
+ 		  (long)(jited_linfo[0]), (long)(jited_ksyms[0]))) {
+ 		err = -1;
+ 		goto done;
+ 	}
+ 
+ 	ksyms_found = 1;
+ 	cur_func_len = jited_func_lens[0];
+ 	cur_func_ksyms = jited_ksyms[0];
+ 	for (i = 1; i < jited_cnt; i++) {
+ 		if (ksyms_found < nr_jited_ksyms &&
+ 		    jited_linfo[i] == jited_ksyms[ksyms_found]) {
+ 			cur_func_ksyms = jited_ksyms[ksyms_found];
+ 			cur_func_len = jited_ksyms[ksyms_found];
+ 			ksyms_found++;
+ 			continue;
+ 		}
+ 
+ 		if (CHECK(jited_linfo[i] <= jited_linfo[i - 1],
+ 			  "jited_linfo[%u]:%lx <= jited_linfo[%u]:%lx",
+ 			  i, (long)jited_linfo[i],
+ 			  i - 1, (long)(jited_linfo[i - 1]))) {
+ 			err = -1;
+ 			goto done;
+ 		}
+ 
+ 		if (CHECK(jited_linfo[i] - cur_func_ksyms > cur_func_len,
+ 			  "jited_linfo[%u]:%lx - %lx > %u",
+ 			  i, (long)jited_linfo[i], (long)cur_func_ksyms,
+ 			  cur_func_len)) {
+ 			err = -1;
+ 			goto done;
+ 		}
+ 	}
+ 
+ 	if (CHECK(ksyms_found != nr_jited_ksyms,
+ 		  "ksyms_found:%u != nr_jited_ksyms:%u",
+ 		  ksyms_found, nr_jited_ksyms)) {
+ 		err = -1;
+ 		goto done;
+ 	}
+ 
+ 	err = 0;
+ 
+ done:
+ 	free(linfo);
+ 	free(jited_linfo);
+ 	free(jited_ksyms);
+ 	free(jited_func_lens);
+ 	return err;
+ }
+ 
+ static int do_test_info_raw(unsigned int test_num)
+ {
+ 	const struct prog_info_raw_test *test = &info_raw_tests[test_num - 1];
+ 	unsigned int raw_btf_size, linfo_str_off, linfo_size;
+ 	int btf_fd = -1, prog_fd = -1, err = 0;
+ 	void *raw_btf, *patched_linfo = NULL;
+ 	const char *ret_next_str;
+ 	union bpf_attr attr = {};
+ 
+ 	fprintf(stderr, "BTF prog info raw test[%u] (%s): ", test_num, test->descr);
++>>>>>>> 4d6304c76355 (bpf: Add unit tests for bpf_line_info)
  	raw_btf = btf_raw_create(&hdr_tmpl, test->raw_types,
  				 test->str_sec, test->str_sec_size,
- 				 &raw_btf_size);
+ 				 &raw_btf_size, &ret_next_str);
  
  	if (!raw_btf)
  		return -1;
@@@ -3590,92 -3851,60 +4224,125 @@@
  
  	if (*btf_log_buf && args.always_log)
  		fprintf(stderr, "\n%s", btf_log_buf);
 -	*btf_log_buf = '\0';
  
+ 	linfo_str_off = ret_next_str - test->str_sec;
+ 	patched_linfo = patch_name_tbd(test->line_info,
+ 				       test->str_sec, linfo_str_off,
+ 				       test->str_sec_size, &linfo_size);
+ 	if (IS_ERR(patched_linfo)) {
+ 		fprintf(stderr, "error in creating raw bpf_line_info");
+ 		err = -1;
+ 		goto done;
+ 	}
+ 
  	attr.prog_type = test->prog_type;
 -	attr.insns = ptr_to_u64(test->insns);
 -	attr.insn_cnt = probe_prog_length(test->insns);
 -	attr.license = ptr_to_u64("GPL");
 +	attr.insns = test->insns;
 +	attr.insns_cnt = probe_prog_length(attr.insns);
 +	attr.license = "GPL";
  	attr.prog_btf_fd = btf_fd;
  	attr.func_info_rec_size = test->func_info_rec_size;
  	attr.func_info_cnt = test->func_info_cnt;
++<<<<<<< HEAD
 +	attr.func_info = test->func_info;
 +
 +	*btf_log_buf = '\0';
 +	prog_fd = bpf_load_program_xattr(&attr, btf_log_buf,
 +					 BTF_LOG_BUF_SIZE);
 +	if (test->expected_prog_load_failure && prog_fd == -1) {
 +		err = 0;
 +		goto done;
 +	}
 +	if (CHECK(prog_fd == -1, "invalid prog_id errno:%d", errno)) {
 +		fprintf(stderr, "%s\n", btf_log_buf);
++=======
+ 	attr.func_info = ptr_to_u64(test->func_info);
+ 	attr.log_buf = ptr_to_u64(btf_log_buf);
+ 	attr.log_size = BTF_LOG_BUF_SIZE;
+ 	attr.log_level = 1;
+ 	if (linfo_size) {
+ 		attr.line_info_rec_size = test->line_info_rec_size;
+ 		attr.line_info = ptr_to_u64(patched_linfo);
+ 		attr.line_info_cnt = linfo_size / attr.line_info_rec_size;
+ 	}
+ 
+ 	prog_fd = syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr));
+ 	err = ((prog_fd == -1) != test->expected_prog_load_failure);
+ 	if (CHECK(err, "prog_fd:%d expected_prog_load_failure:%u errno:%d",
+ 		  prog_fd, test->expected_prog_load_failure, errno) ||
+ 	    CHECK(test->err_str && !strstr(btf_log_buf, test->err_str),
+ 		  "expected err_str:%s", test->err_str)) {
++>>>>>>> 4d6304c76355 (bpf: Add unit tests for bpf_line_info)
  		err = -1;
  		goto done;
  	}
  
 -	if (prog_fd == -1)
 +	/* get necessary lens */
 +	info_len = sizeof(struct bpf_prog_info);
 +	err = bpf_obj_get_info_by_fd(prog_fd, &info, &info_len);
 +	if (CHECK(err == -1, "invalid get info (1st) errno:%d", errno)) {
 +		fprintf(stderr, "%s\n", btf_log_buf);
 +		err = -1;
 +		goto done;
 +	}
 +	if (CHECK(info.func_info_cnt != 2,
 +		  "incorrect info.func_info_cnt (1st) %d\n",
 +		  info.func_info_cnt)) {
 +		err = -1;
  		goto done;
 +	}
 +	rec_size = info.func_info_rec_size;
 +	if (CHECK(rec_size < 4,
 +		  "incorrect info.func_info_rec_size (1st) %d\n", rec_size)) {
 +		err = -1;
 +		goto done;
 +	}
  
 -	err = test_get_finfo(test, prog_fd);
 -	if (err)
 +	func_info = malloc(info.func_info_cnt * rec_size);
 +	if (CHECK(!func_info, "out of memory")) {
 +		err = -1;
 +		goto done;
 +	}
 +
 +	/* reset info to only retrieve func_info related data */
 +	memset(&info, 0, sizeof(info));
 +	info.func_info_cnt = 2;
 +	info.func_info_rec_size = rec_size;
 +	info.func_info = ptr_to_u64(func_info);
 +	err = bpf_obj_get_info_by_fd(prog_fd, &info, &info_len);
 +	if (CHECK(err == -1, "invalid get info (2nd) errno:%d", errno)) {
 +		fprintf(stderr, "%s\n", btf_log_buf);
 +		err = -1;
  		goto done;
 +	}
 +	if (CHECK(info.func_info_cnt != 2,
 +		  "incorrect info.func_info_cnt (2nd) %d\n",
 +		  info.func_info_cnt)) {
 +		err = -1;
 +		goto done;
 +	}
 +	if (CHECK(info.func_info_rec_size != rec_size,
 +		  "incorrect info.func_info_rec_size (2nd) %d\n",
 +		  info.func_info_rec_size)) {
 +		err = -1;
 +		goto done;
 +	}
 +
 +	finfo = func_info;
 +	for (i = 0; i < 2; i++) {
 +		if (CHECK(finfo->type_id != test->func_info[i][1],
 +			  "incorrect func_type %u expected %u",
 +			  finfo->type_id, test->func_info[i][1])) {
 +			err = -1;
 +			goto done;
 +		}
 +		finfo = (void *)finfo + rec_size;
 +	}
  
+ 	err = test_get_linfo(test, patched_linfo, attr.line_info_cnt, prog_fd);
+ 	if (err)
+ 		goto done;
+ 
  done:
 -	if (!err)
 -		fprintf(stderr, "OK");
 -
  	if (*btf_log_buf && (err || args.always_log))
  		fprintf(stderr, "\n%s", btf_log_buf);
  
@@@ -3683,7 -3912,10 +4350,14 @@@
  		close(btf_fd);
  	if (prog_fd != -1)
  		close(prog_fd);
++<<<<<<< HEAD
 +	free(func_info);
++=======
+ 
+ 	if (!IS_ERR(patched_linfo))
+ 		free(patched_linfo);
+ 
++>>>>>>> 4d6304c76355 (bpf: Add unit tests for bpf_line_info)
  	return err;
  }
  
* Unmerged path tools/testing/selftests/bpf/test_btf.c
