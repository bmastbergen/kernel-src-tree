taprio: Add support for cycle-time-extension

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Vinicius Costa Gomes <vinicius.gomes@intel.com>
commit c25031e993440debdd530278ce2171ce477df029
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/c25031e9.failed

IEEE 802.1Q-2018 defines the concept of a cycle-time-extension, so the
last entry of a schedule before the start of a new schedule can be
extended, so "too-short" entries can be avoided.

	Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c25031e993440debdd530278ce2171ce477df029)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/pkt_sched.h
#	net/sched/sch_taprio.c
diff --cc include/uapi/linux/pkt_sched.h
index a26080235fb7,8b2f993cbb77..000000000000
--- a/include/uapi/linux/pkt_sched.h
+++ b/include/uapi/linux/pkt_sched.h
@@@ -1153,6 -1166,9 +1153,12 @@@ enum 
  	TCA_TAPRIO_ATTR_SCHED_SINGLE_ENTRY, /* single entry */
  	TCA_TAPRIO_ATTR_SCHED_CLOCKID, /* s32 */
  	TCA_TAPRIO_PAD,
++<<<<<<< HEAD
++=======
+ 	TCA_TAPRIO_ATTR_ADMIN_SCHED, /* The admin sched, only used in dump */
+ 	TCA_TAPRIO_ATTR_SCHED_CYCLE_TIME, /* s64 */
+ 	TCA_TAPRIO_ATTR_SCHED_CYCLE_TIME_EXTENSION, /* s64 */
++>>>>>>> c25031e99344 (taprio: Add support for cycle-time-extension)
  	__TCA_TAPRIO_ATTR_MAX,
  };
  
diff --cc net/sched/sch_taprio.c
index fc147ade41b9,539677120b9f..000000000000
--- a/net/sched/sch_taprio.c
+++ b/net/sched/sch_taprio.c
@@@ -41,6 -42,16 +41,19 @@@ struct sched_entry 
  	u8 command;
  };
  
++<<<<<<< HEAD
++=======
+ struct sched_gate_list {
+ 	struct rcu_head rcu;
+ 	struct list_head entries;
+ 	size_t num_entries;
+ 	ktime_t cycle_close_time;
+ 	s64 cycle_time;
+ 	s64 cycle_time_extension;
+ 	s64 base_time;
+ };
+ 
++>>>>>>> c25031e99344 (taprio: Add support for cycle-time-extension)
  struct taprio_sched {
  	struct Qdisc **qdiscs;
  	struct Qdisc *root;
@@@ -211,6 -275,52 +224,55 @@@ done
  	return skb;
  }
  
++<<<<<<< HEAD
++=======
+ static bool should_restart_cycle(const struct sched_gate_list *oper,
+ 				 const struct sched_entry *entry)
+ {
+ 	if (list_is_last(&entry->list, &oper->entries))
+ 		return true;
+ 
+ 	if (ktime_compare(entry->close_time, oper->cycle_close_time) == 0)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ static bool should_change_schedules(const struct sched_gate_list *admin,
+ 				    const struct sched_gate_list *oper,
+ 				    ktime_t close_time)
+ {
+ 	ktime_t next_base_time, extension_time;
+ 
+ 	if (!admin)
+ 		return false;
+ 
+ 	next_base_time = sched_base_time(admin);
+ 
+ 	/* This is the simple case, the close_time would fall after
+ 	 * the next schedule base_time.
+ 	 */
+ 	if (ktime_compare(next_base_time, close_time) <= 0)
+ 		return true;
+ 
+ 	/* This is the cycle_time_extension case, if the close_time
+ 	 * plus the amount that can be extended would fall after the
+ 	 * next schedule base_time, we can extend the current schedule
+ 	 * for that amount.
+ 	 */
+ 	extension_time = ktime_add_ns(close_time, oper->cycle_time_extension);
+ 
+ 	/* FIXME: the IEEE 802.1Q-2018 Specification isn't clear about
+ 	 * how precisely the extension should be made. So after
+ 	 * conformance testing, this logic may change.
+ 	 */
+ 	if (ktime_compare(next_base_time, extension_time) <= 0)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
++>>>>>>> c25031e99344 (taprio: Add support for cycle-time-extension)
  static enum hrtimer_restart advance_sched(struct hrtimer *timer)
  {
  	struct taprio_sched *q = container_of(timer, struct taprio_sched,
@@@ -273,10 -405,12 +335,19 @@@ static const struct nla_policy taprio_p
  	[TCA_TAPRIO_ATTR_PRIOMAP]	       = {
  		.len = sizeof(struct tc_mqprio_qopt)
  	},
++<<<<<<< HEAD
 +	[TCA_TAPRIO_ATTR_SCHED_ENTRY_LIST]     = { .type = NLA_NESTED },
 +	[TCA_TAPRIO_ATTR_SCHED_BASE_TIME]      = { .type = NLA_S64 },
 +	[TCA_TAPRIO_ATTR_SCHED_SINGLE_ENTRY]   = { .type = NLA_NESTED },
 +	[TCA_TAPRIO_ATTR_SCHED_CLOCKID]        = { .type = NLA_S32 },
++=======
+ 	[TCA_TAPRIO_ATTR_SCHED_ENTRY_LIST]           = { .type = NLA_NESTED },
+ 	[TCA_TAPRIO_ATTR_SCHED_BASE_TIME]            = { .type = NLA_S64 },
+ 	[TCA_TAPRIO_ATTR_SCHED_SINGLE_ENTRY]         = { .type = NLA_NESTED },
+ 	[TCA_TAPRIO_ATTR_SCHED_CLOCKID]              = { .type = NLA_S32 },
+ 	[TCA_TAPRIO_ATTR_SCHED_CYCLE_TIME]           = { .type = NLA_S64 },
+ 	[TCA_TAPRIO_ATTR_SCHED_CYCLE_TIME_EXTENSION] = { .type = NLA_S64 },
++>>>>>>> c25031e99344 (taprio: Add support for cycle-time-extension)
  };
  
  static int fill_sched_entry(struct nlattr **tb, struct sched_entry *entry,
@@@ -426,38 -498,25 +497,46 @@@ static int parse_sched_list(struct nlat
  	return i;
  }
  
 -static int parse_taprio_schedule(struct nlattr **tb,
 -				 struct sched_gate_list *new,
 -				 struct netlink_ext_ack *extack)
 +/* Returns the number of entries in case of success */
 +static int parse_taprio_opt(struct nlattr **tb, struct taprio_sched *q,
 +			    struct netlink_ext_ack *extack)
  {
  	int err = 0;
 +	int clockid;
  
 -	if (tb[TCA_TAPRIO_ATTR_SCHED_SINGLE_ENTRY]) {
 -		NL_SET_ERR_MSG(extack, "Adding a single entry is not supported");
 -		return -ENOTSUPP;
 -	}
 +	if (tb[TCA_TAPRIO_ATTR_SCHED_ENTRY_LIST] &&
 +	    tb[TCA_TAPRIO_ATTR_SCHED_SINGLE_ENTRY])
 +		return -EINVAL;
 +
 +	if (tb[TCA_TAPRIO_ATTR_SCHED_SINGLE_ENTRY] && q->num_entries == 0)
 +		return -EINVAL;
 +
 +	if (q->clockid == -1 && !tb[TCA_TAPRIO_ATTR_SCHED_CLOCKID])
 +		return -EINVAL;
  
  	if (tb[TCA_TAPRIO_ATTR_SCHED_BASE_TIME])
 -		new->base_time = nla_get_s64(tb[TCA_TAPRIO_ATTR_SCHED_BASE_TIME]);
 +		q->base_time = nla_get_s64(
 +			tb[TCA_TAPRIO_ATTR_SCHED_BASE_TIME]);
  
++<<<<<<< HEAD
 +	if (tb[TCA_TAPRIO_ATTR_SCHED_CLOCKID]) {
 +		clockid = nla_get_s32(tb[TCA_TAPRIO_ATTR_SCHED_CLOCKID]);
 +
 +		/* We only support static clockids and we don't allow
 +		 * for it to be modified after the first init.
 +		 */
 +		if (clockid < 0 || (q->clockid != -1 && q->clockid != clockid))
 +			return -EINVAL;
 +
 +		q->clockid = clockid;
 +	}
++=======
+ 	if (tb[TCA_TAPRIO_ATTR_SCHED_CYCLE_TIME_EXTENSION])
+ 		new->cycle_time_extension = nla_get_s64(tb[TCA_TAPRIO_ATTR_SCHED_CYCLE_TIME_EXTENSION]);
+ 
+ 	if (tb[TCA_TAPRIO_ATTR_SCHED_CYCLE_TIME])
+ 		new->cycle_time = nla_get_s64(tb[TCA_TAPRIO_ATTR_SCHED_CYCLE_TIME]);
++>>>>>>> c25031e99344 (taprio: Add support for cycle-time-extension)
  
  	if (tb[TCA_TAPRIO_ATTR_SCHED_ENTRY_LIST])
  		err = parse_sched_list(
@@@ -868,6 -1013,42 +947,45 @@@ nla_put_failure
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ static int dump_schedule(struct sk_buff *msg,
+ 			 const struct sched_gate_list *root)
+ {
+ 	struct nlattr *entry_list;
+ 	struct sched_entry *entry;
+ 
+ 	if (nla_put_s64(msg, TCA_TAPRIO_ATTR_SCHED_BASE_TIME,
+ 			root->base_time, TCA_TAPRIO_PAD))
+ 		return -1;
+ 
+ 	if (nla_put_s64(msg, TCA_TAPRIO_ATTR_SCHED_CYCLE_TIME,
+ 			root->cycle_time, TCA_TAPRIO_PAD))
+ 		return -1;
+ 
+ 	if (nla_put_s64(msg, TCA_TAPRIO_ATTR_SCHED_CYCLE_TIME_EXTENSION,
+ 			root->cycle_time_extension, TCA_TAPRIO_PAD))
+ 		return -1;
+ 
+ 	entry_list = nla_nest_start_noflag(msg,
+ 					   TCA_TAPRIO_ATTR_SCHED_ENTRY_LIST);
+ 	if (!entry_list)
+ 		goto error_nest;
+ 
+ 	list_for_each_entry(entry, &root->entries, list) {
+ 		if (dump_entry(msg, entry) < 0)
+ 			goto error_nest;
+ 	}
+ 
+ 	nla_nest_end(msg, entry_list);
+ 	return 0;
+ 
+ error_nest:
+ 	nla_nest_cancel(msg, entry_list);
+ 	return -1;
+ }
+ 
++>>>>>>> c25031e99344 (taprio: Add support for cycle-time-extension)
  static int taprio_dump(struct Qdisc *sch, struct sk_buff *skb)
  {
  	struct taprio_sched *q = qdisc_priv(sch);
* Unmerged path include/uapi/linux/pkt_sched.h
* Unmerged path net/sched/sch_taprio.c
