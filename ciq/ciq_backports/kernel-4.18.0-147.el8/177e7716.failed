bpf: Remove !func_info and !line_info check from test_btf and bpftool

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Martin KaFai Lau <kafai@fb.com>
commit 177e77169b0b71587c74382d5f2207a16da34790
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/177e7716.failed

kernel can provide the func_info and line_info even
it fails the btf_dump_raw_ok() test because they don't contain
kernel address.  This patch removes the corresponding '== 0'
test.

	Signed-off-by: Martin KaFai Lau <kafai@fb.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit 177e77169b0b71587c74382d5f2207a16da34790)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/bpf/bpftool/prog.c
#	tools/lib/bpf/bpf_prog_linfo.c
#	tools/testing/selftests/bpf/test_btf.c
diff --cc tools/bpf/bpftool/prog.c
index 0e8e6ea9a35a,ee51279be9c7..000000000000
--- a/tools/bpf/bpftool/prog.c
+++ b/tools/bpf/bpftool/prog.c
@@@ -560,6 -596,30 +560,33 @@@ static int do_dump(int argc, char **arg
  		goto err_free;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (linfo && info.nr_line_info != nr_linfo) {
+ 		p_err("incorrect nr_line_info %u vs. expected %u",
+ 		      info.nr_line_info, nr_linfo);
+ 		goto err_free;
+ 	}
+ 
+ 	if (info.line_info_rec_size != linfo_rec_size) {
+ 		p_err("incorrect line_info_rec_size %u vs. expected %u",
+ 		      info.line_info_rec_size, linfo_rec_size);
+ 		goto err_free;
+ 	}
+ 
+ 	if (jited_linfo && info.nr_jited_line_info != nr_jited_linfo) {
+ 		p_err("incorrect nr_jited_line_info %u vs. expected %u",
+ 		      info.nr_jited_line_info, nr_jited_linfo);
+ 		goto err_free;
+ 	}
+ 
+ 	if (info.jited_line_info_rec_size != jited_linfo_rec_size) {
+ 		p_err("incorrect jited_line_info_rec_size %u vs. expected %u",
+ 		      info.jited_line_info_rec_size, jited_linfo_rec_size);
+ 		goto err_free;
+ 	}
+ 
++>>>>>>> 177e77169b0b (bpf: Remove !func_info and !line_info check from test_btf and bpftool)
  	if ((member_len == &info.jited_prog_len &&
  	     info.jited_prog_insns == 0) ||
  	    (member_len == &info.xlated_prog_len &&
diff --cc tools/testing/selftests/bpf/test_btf.c
index 42aad55cbe88,8478316aaf9a..000000000000
--- a/tools/testing/selftests/bpf/test_btf.c
+++ b/tools/testing/selftests/bpf/test_btf.c
@@@ -3559,20 -3849,345 +3559,310 @@@ static size_t probe_prog_length(const s
  	return len + 1;
  }
  
 -static __u32 *patch_name_tbd(const __u32 *raw_u32,
 -			     const char *str, __u32 str_off,
 -			     unsigned int str_sec_size,
 -			     unsigned int *ret_size)
 -{
 -	int i, raw_u32_size = get_raw_sec_size(raw_u32);
 -	const char *end_str = str + str_sec_size;
 -	const char *next_str = str + str_off;
 -	__u32 *new_u32 = NULL;
 -
 -	if (raw_u32_size == -1)
 -		return ERR_PTR(-EINVAL);
 -
 -	if (!raw_u32_size) {
 -		*ret_size = 0;
 -		return NULL;
 -	}
 -
 -	new_u32 = malloc(raw_u32_size);
 -	if (!new_u32)
 -		return ERR_PTR(-ENOMEM);
 -
 -	for (i = 0; i < raw_u32_size / sizeof(raw_u32[0]); i++) {
 -		if (raw_u32[i] == NAME_TBD) {
 -			next_str = get_next_str(next_str, end_str);
 -			if (CHECK(!next_str, "Error in getting next_str\n")) {
 -				free(new_u32);
 -				return ERR_PTR(-EINVAL);
 -			}
 -			new_u32[i] = next_str - str;
 -			next_str += strlen(next_str);
 -		} else {
 -			new_u32[i] = raw_u32[i];
 -		}
 -	}
 -
 -	*ret_size = raw_u32_size;
 -	return new_u32;
 -}
 -
 -static int test_get_finfo(const struct prog_info_raw_test *test,
 -			  int prog_fd)
 +static int do_test_func_type(int test_num)
  {
 +	const struct btf_func_type_test *test = &func_type_test[test_num];
 +	unsigned int raw_btf_size, info_len, rec_size;
 +	int i, btf_fd = -1, prog_fd = -1, err = 0;
 +	struct bpf_load_program_attr attr = {};
 +	void *raw_btf, *func_info = NULL;
  	struct bpf_prog_info info = {};
  	struct bpf_func_info *finfo;
 -	__u32 info_len, rec_size, i;
 -	void *func_info = NULL;
 -	int err;
  
++<<<<<<< HEAD
 +	fprintf(stderr, "%s......", test->descr);
++=======
+ 	/* get necessary lens */
+ 	info_len = sizeof(struct bpf_prog_info);
+ 	err = bpf_obj_get_info_by_fd(prog_fd, &info, &info_len);
+ 	if (CHECK(err == -1, "invalid get info (1st) errno:%d", errno)) {
+ 		fprintf(stderr, "%s\n", btf_log_buf);
+ 		return -1;
+ 	}
+ 	if (CHECK(info.nr_func_info != test->func_info_cnt,
+ 		  "incorrect info.nr_func_info (1st) %d",
+ 		  info.nr_func_info)) {
+ 		return -1;
+ 	}
+ 
+ 	rec_size = info.func_info_rec_size;
+ 	if (CHECK(rec_size < 8,
+ 		  "incorrect info.func_info_rec_size (1st) %d", rec_size)) {
+ 		return -1;
+ 	}
+ 
+ 	if (!info.nr_func_info)
+ 		return 0;
+ 
+ 	func_info = malloc(info.nr_func_info * rec_size);
+ 	if (CHECK(!func_info, "out of memory"))
+ 		return -1;
+ 
+ 	/* reset info to only retrieve func_info related data */
+ 	memset(&info, 0, sizeof(info));
+ 	info.nr_func_info = test->func_info_cnt;
+ 	info.func_info_rec_size = rec_size;
+ 	info.func_info = ptr_to_u64(func_info);
+ 	err = bpf_obj_get_info_by_fd(prog_fd, &info, &info_len);
+ 	if (CHECK(err == -1, "invalid get info (2nd) errno:%d", errno)) {
+ 		fprintf(stderr, "%s\n", btf_log_buf);
+ 		err = -1;
+ 		goto done;
+ 	}
+ 	if (CHECK(info.nr_func_info != test->func_info_cnt,
+ 		  "incorrect info.nr_func_info (2nd) %d",
+ 		  info.nr_func_info)) {
+ 		err = -1;
+ 		goto done;
+ 	}
+ 	if (CHECK(info.func_info_rec_size < 8,
+ 		  "incorrect info.func_info_rec_size (2nd) %d",
+ 		  info.func_info_rec_size)) {
+ 		err = -1;
+ 		goto done;
+ 	}
+ 
+ 	finfo = func_info;
+ 	for (i = 0; i < test->func_info_cnt; i++) {
+ 		if (CHECK(finfo->type_id != test->func_info[i][1],
+ 			  "incorrect func_type %u expected %u",
+ 			  finfo->type_id, test->func_info[i][1])) {
+ 			err = -1;
+ 			goto done;
+ 		}
+ 		finfo = (void *)finfo + rec_size;
+ 	}
+ 
+ 	err = 0;
+ 
+ done:
+ 	free(func_info);
+ 	return err;
+ }
+ 
+ static int test_get_linfo(const struct prog_info_raw_test *test,
+ 			  const void *patched_linfo,
+ 			  __u32 cnt, int prog_fd)
+ {
+ 	__u32 i, info_len, nr_jited_ksyms, nr_jited_func_lens;
+ 	__u64 *jited_linfo = NULL, *jited_ksyms = NULL;
+ 	__u32 rec_size, jited_rec_size, jited_cnt;
+ 	struct bpf_line_info *linfo = NULL;
+ 	__u32 cur_func_len, ksyms_found;
+ 	struct bpf_prog_info info = {};
+ 	__u32 *jited_func_lens = NULL;
+ 	__u64 cur_func_ksyms;
+ 	int err;
+ 
+ 	jited_cnt = cnt;
+ 	rec_size = sizeof(*linfo);
+ 	jited_rec_size = sizeof(*jited_linfo);
+ 	if (test->nr_jited_ksyms)
+ 		nr_jited_ksyms = test->nr_jited_ksyms;
+ 	else
+ 		nr_jited_ksyms = test->func_info_cnt;
+ 	nr_jited_func_lens = nr_jited_ksyms;
+ 
+ 	info_len = sizeof(struct bpf_prog_info);
+ 	err = bpf_obj_get_info_by_fd(prog_fd, &info, &info_len);
+ 	if (CHECK(err == -1, "err:%d errno:%d", err, errno)) {
+ 		err = -1;
+ 		goto done;
+ 	}
+ 
+ 	if (!info.jited_prog_len) {
+ 		/* prog is not jited */
+ 		jited_cnt = 0;
+ 		nr_jited_ksyms = 1;
+ 		nr_jited_func_lens = 1;
+ 	}
+ 
+ 	if (CHECK(info.nr_line_info != cnt ||
+ 		  info.nr_jited_line_info != jited_cnt ||
+ 		  info.nr_jited_ksyms != nr_jited_ksyms ||
+ 		  info.nr_jited_func_lens != nr_jited_func_lens ||
+ 		  (!info.nr_line_info && info.nr_jited_line_info),
+ 		  "info: nr_line_info:%u(expected:%u) nr_jited_line_info:%u(expected:%u) nr_jited_ksyms:%u(expected:%u) nr_jited_func_lens:%u(expected:%u)",
+ 		  info.nr_line_info, cnt,
+ 		  info.nr_jited_line_info, jited_cnt,
+ 		  info.nr_jited_ksyms, nr_jited_ksyms,
+ 		  info.nr_jited_func_lens, nr_jited_func_lens)) {
+ 		err = -1;
+ 		goto done;
+ 	}
+ 
+ 	if (CHECK(info.line_info_rec_size < 16 ||
+ 		  info.jited_line_info_rec_size < 8,
+ 		  "info: line_info_rec_size:%u(userspace expected:%u) jited_line_info_rec_size:%u(userspace expected:%u)",
+ 		  info.line_info_rec_size, rec_size,
+ 		  info.jited_line_info_rec_size, jited_rec_size)) {
+ 		err = -1;
+ 		goto done;
+ 	}
+ 
+ 	if (!cnt)
+ 		return 0;
+ 
+ 	rec_size = info.line_info_rec_size;
+ 	jited_rec_size = info.jited_line_info_rec_size;
+ 
+ 	memset(&info, 0, sizeof(info));
+ 
+ 	linfo = calloc(cnt, rec_size);
+ 	if (CHECK(!linfo, "!linfo")) {
+ 		err = -1;
+ 		goto done;
+ 	}
+ 	info.nr_line_info = cnt;
+ 	info.line_info_rec_size = rec_size;
+ 	info.line_info = ptr_to_u64(linfo);
+ 
+ 	if (jited_cnt) {
+ 		jited_linfo = calloc(jited_cnt, jited_rec_size);
+ 		jited_ksyms = calloc(nr_jited_ksyms, sizeof(*jited_ksyms));
+ 		jited_func_lens = calloc(nr_jited_func_lens,
+ 					 sizeof(*jited_func_lens));
+ 		if (CHECK(!jited_linfo || !jited_ksyms || !jited_func_lens,
+ 			  "jited_linfo:%p jited_ksyms:%p jited_func_lens:%p",
+ 			  jited_linfo, jited_ksyms, jited_func_lens)) {
+ 			err = -1;
+ 			goto done;
+ 		}
+ 
+ 		info.nr_jited_line_info = jited_cnt;
+ 		info.jited_line_info_rec_size = jited_rec_size;
+ 		info.jited_line_info = ptr_to_u64(jited_linfo);
+ 		info.nr_jited_ksyms = nr_jited_ksyms;
+ 		info.jited_ksyms = ptr_to_u64(jited_ksyms);
+ 		info.nr_jited_func_lens = nr_jited_func_lens;
+ 		info.jited_func_lens = ptr_to_u64(jited_func_lens);
+ 	}
+ 
+ 	err = bpf_obj_get_info_by_fd(prog_fd, &info, &info_len);
+ 
+ 	/*
+ 	 * Only recheck the info.*line_info* fields.
+ 	 * Other fields are not the concern of this test.
+ 	 */
+ 	if (CHECK(err == -1 ||
+ 		  info.nr_line_info != cnt ||
+ 		  (jited_cnt && !info.jited_line_info) ||
+ 		  info.nr_jited_line_info != jited_cnt ||
+ 		  info.line_info_rec_size != rec_size ||
+ 		  info.jited_line_info_rec_size != jited_rec_size,
+ 		  "err:%d errno:%d info: nr_line_info:%u(expected:%u) nr_jited_line_info:%u(expected:%u) line_info_rec_size:%u(expected:%u) jited_linfo_rec_size:%u(expected:%u) line_info:%p jited_line_info:%p",
+ 		  err, errno,
+ 		  info.nr_line_info, cnt,
+ 		  info.nr_jited_line_info, jited_cnt,
+ 		  info.line_info_rec_size, rec_size,
+ 		  info.jited_line_info_rec_size, jited_rec_size,
+ 		  (void *)(long)info.line_info,
+ 		  (void *)(long)info.jited_line_info)) {
+ 		err = -1;
+ 		goto done;
+ 	}
+ 
+ 	CHECK(linfo[0].insn_off, "linfo[0].insn_off:%u",
+ 	      linfo[0].insn_off);
+ 	for (i = 1; i < cnt; i++) {
+ 		const struct bpf_line_info *expected_linfo;
+ 
+ 		expected_linfo = patched_linfo + (i * test->line_info_rec_size);
+ 		if (CHECK(linfo[i].insn_off <= linfo[i - 1].insn_off,
+ 			  "linfo[%u].insn_off:%u <= linfo[%u].insn_off:%u",
+ 			  i, linfo[i].insn_off,
+ 			  i - 1, linfo[i - 1].insn_off)) {
+ 			err = -1;
+ 			goto done;
+ 		}
+ 		if (CHECK(linfo[i].file_name_off != expected_linfo->file_name_off ||
+ 			  linfo[i].line_off != expected_linfo->line_off ||
+ 			  linfo[i].line_col != expected_linfo->line_col,
+ 			  "linfo[%u] (%u, %u, %u) != (%u, %u, %u)", i,
+ 			  linfo[i].file_name_off,
+ 			  linfo[i].line_off,
+ 			  linfo[i].line_col,
+ 			  expected_linfo->file_name_off,
+ 			  expected_linfo->line_off,
+ 			  expected_linfo->line_col)) {
+ 			err = -1;
+ 			goto done;
+ 		}
+ 	}
+ 
+ 	if (!jited_cnt) {
+ 		fprintf(stderr, "not jited. skipping jited_line_info check. ");
+ 		err = 0;
+ 		goto done;
+ 	}
+ 
+ 	if (CHECK(jited_linfo[0] != jited_ksyms[0],
+ 		  "jited_linfo[0]:%lx != jited_ksyms[0]:%lx",
+ 		  (long)(jited_linfo[0]), (long)(jited_ksyms[0]))) {
+ 		err = -1;
+ 		goto done;
+ 	}
+ 
+ 	ksyms_found = 1;
+ 	cur_func_len = jited_func_lens[0];
+ 	cur_func_ksyms = jited_ksyms[0];
+ 	for (i = 1; i < jited_cnt; i++) {
+ 		if (ksyms_found < nr_jited_ksyms &&
+ 		    jited_linfo[i] == jited_ksyms[ksyms_found]) {
+ 			cur_func_ksyms = jited_ksyms[ksyms_found];
+ 			cur_func_len = jited_ksyms[ksyms_found];
+ 			ksyms_found++;
+ 			continue;
+ 		}
+ 
+ 		if (CHECK(jited_linfo[i] <= jited_linfo[i - 1],
+ 			  "jited_linfo[%u]:%lx <= jited_linfo[%u]:%lx",
+ 			  i, (long)jited_linfo[i],
+ 			  i - 1, (long)(jited_linfo[i - 1]))) {
+ 			err = -1;
+ 			goto done;
+ 		}
+ 
+ 		if (CHECK(jited_linfo[i] - cur_func_ksyms > cur_func_len,
+ 			  "jited_linfo[%u]:%lx - %lx > %u",
+ 			  i, (long)jited_linfo[i], (long)cur_func_ksyms,
+ 			  cur_func_len)) {
+ 			err = -1;
+ 			goto done;
+ 		}
+ 	}
+ 
+ 	if (CHECK(ksyms_found != nr_jited_ksyms,
+ 		  "ksyms_found:%u != nr_jited_ksyms:%u",
+ 		  ksyms_found, nr_jited_ksyms)) {
+ 		err = -1;
+ 		goto done;
+ 	}
+ 
+ 	err = 0;
+ 
+ done:
+ 	free(linfo);
+ 	free(jited_linfo);
+ 	free(jited_ksyms);
+ 	free(jited_func_lens);
+ 	return err;
+ }
+ 
+ static int do_test_info_raw(unsigned int test_num)
+ {
+ 	const struct prog_info_raw_test *test = &info_raw_tests[test_num - 1];
+ 	unsigned int raw_btf_size, linfo_str_off, linfo_size;
+ 	int btf_fd = -1, prog_fd = -1, err = 0;
+ 	void *raw_btf, *patched_linfo = NULL;
+ 	const char *ret_next_str;
+ 	union bpf_attr attr = {};
+ 
+ 	fprintf(stderr, "BTF prog info raw test[%u] (%s): ", test_num, test->descr);
++>>>>>>> 177e77169b0b (bpf: Remove !func_info and !line_info check from test_btf and bpftool)
  	raw_btf = btf_raw_create(&hdr_tmpl, test->raw_types,
  				 test->str_sec, test->str_sec_size,
 -				 &raw_btf_size, &ret_next_str);
 +				 &raw_btf_size);
  
  	if (!raw_btf)
  		return -1;
* Unmerged path tools/lib/bpf/bpf_prog_linfo.c
* Unmerged path tools/bpf/bpftool/prog.c
* Unmerged path tools/lib/bpf/bpf_prog_linfo.c
* Unmerged path tools/testing/selftests/bpf/test_btf.c
