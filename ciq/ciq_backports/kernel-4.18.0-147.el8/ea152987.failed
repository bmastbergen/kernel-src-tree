KVM: x86: hyper-v: don't crash on KVM_GET_SUPPORTED_HV_CPUID when kvm_intel.nested is disabled

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit ea1529873ab18c204688cf31746df851c098cbea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/ea152987.failed

If kvm_intel is loaded with nested=0 parameter an attempt to perform
KVM_GET_SUPPORTED_HV_CPUID results in OOPS as nested_get_evmcs_version hook
in kvm_x86_ops is NULL (we assign it in nested_vmx_hardware_setup() and
this only happens in case nested is enabled).

Check that kvm_x86_ops->nested_get_evmcs_version is not NULL before
calling it. With this, we can remove the stub from svm as it is no
longer needed.

	Cc: <stable@vger.kernel.org>
Fixes: e2e871ab2f02 ("x86/kvm/hyper-v: Introduce nested_get_evmcs_version() helper")
	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Reviewed-by: Jim Mattson <jmattson@google.com>
	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
(cherry picked from commit ea1529873ab18c204688cf31746df851c098cbea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/hyperv.c
#	arch/x86/kvm/svm.c
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/kvm/hyperv.c
index c842d377d484,fff790a3f4ee..000000000000
--- a/arch/x86/kvm/hyperv.c
+++ b/arch/x86/kvm/hyperv.c
@@@ -1678,3 -1777,126 +1678,129 @@@ int kvm_vm_ioctl_hv_eventfd(struct kvm 
  		return kvm_hv_eventfd_deassign(kvm, args->conn_id);
  	return kvm_hv_eventfd_assign(kvm, args->conn_id, args->fd);
  }
++<<<<<<< HEAD
++=======
+ 
+ int kvm_vcpu_ioctl_get_hv_cpuid(struct kvm_vcpu *vcpu, struct kvm_cpuid2 *cpuid,
+ 				struct kvm_cpuid_entry2 __user *entries)
+ {
+ 	uint16_t evmcs_ver = 0;
+ 	struct kvm_cpuid_entry2 cpuid_entries[] = {
+ 		{ .function = HYPERV_CPUID_VENDOR_AND_MAX_FUNCTIONS },
+ 		{ .function = HYPERV_CPUID_INTERFACE },
+ 		{ .function = HYPERV_CPUID_VERSION },
+ 		{ .function = HYPERV_CPUID_FEATURES },
+ 		{ .function = HYPERV_CPUID_ENLIGHTMENT_INFO },
+ 		{ .function = HYPERV_CPUID_IMPLEMENT_LIMITS },
+ 		{ .function = HYPERV_CPUID_NESTED_FEATURES },
+ 	};
+ 	int i, nent = ARRAY_SIZE(cpuid_entries);
+ 
+ 	if (kvm_x86_ops->nested_get_evmcs_version)
+ 		evmcs_ver = kvm_x86_ops->nested_get_evmcs_version(vcpu);
+ 
+ 	/* Skip NESTED_FEATURES if eVMCS is not supported */
+ 	if (!evmcs_ver)
+ 		--nent;
+ 
+ 	if (cpuid->nent < nent)
+ 		return -E2BIG;
+ 
+ 	if (cpuid->nent > nent)
+ 		cpuid->nent = nent;
+ 
+ 	for (i = 0; i < nent; i++) {
+ 		struct kvm_cpuid_entry2 *ent = &cpuid_entries[i];
+ 		u32 signature[3];
+ 
+ 		switch (ent->function) {
+ 		case HYPERV_CPUID_VENDOR_AND_MAX_FUNCTIONS:
+ 			memcpy(signature, "Linux KVM Hv", 12);
+ 
+ 			ent->eax = HYPERV_CPUID_NESTED_FEATURES;
+ 			ent->ebx = signature[0];
+ 			ent->ecx = signature[1];
+ 			ent->edx = signature[2];
+ 			break;
+ 
+ 		case HYPERV_CPUID_INTERFACE:
+ 			memcpy(signature, "Hv#1\0\0\0\0\0\0\0\0", 12);
+ 			ent->eax = signature[0];
+ 			break;
+ 
+ 		case HYPERV_CPUID_VERSION:
+ 			/*
+ 			 * We implement some Hyper-V 2016 functions so let's use
+ 			 * this version.
+ 			 */
+ 			ent->eax = 0x00003839;
+ 			ent->ebx = 0x000A0000;
+ 			break;
+ 
+ 		case HYPERV_CPUID_FEATURES:
+ 			ent->eax |= HV_X64_MSR_VP_RUNTIME_AVAILABLE;
+ 			ent->eax |= HV_MSR_TIME_REF_COUNT_AVAILABLE;
+ 			ent->eax |= HV_X64_MSR_SYNIC_AVAILABLE;
+ 			ent->eax |= HV_MSR_SYNTIMER_AVAILABLE;
+ 			ent->eax |= HV_X64_MSR_APIC_ACCESS_AVAILABLE;
+ 			ent->eax |= HV_X64_MSR_HYPERCALL_AVAILABLE;
+ 			ent->eax |= HV_X64_MSR_VP_INDEX_AVAILABLE;
+ 			ent->eax |= HV_X64_MSR_RESET_AVAILABLE;
+ 			ent->eax |= HV_MSR_REFERENCE_TSC_AVAILABLE;
+ 			ent->eax |= HV_X64_ACCESS_FREQUENCY_MSRS;
+ 			ent->eax |= HV_X64_ACCESS_REENLIGHTENMENT;
+ 
+ 			ent->ebx |= HV_X64_POST_MESSAGES;
+ 			ent->ebx |= HV_X64_SIGNAL_EVENTS;
+ 
+ 			ent->edx |= HV_FEATURE_FREQUENCY_MSRS_AVAILABLE;
+ 			ent->edx |= HV_FEATURE_GUEST_CRASH_MSR_AVAILABLE;
+ 			ent->edx |= HV_STIMER_DIRECT_MODE_AVAILABLE;
+ 
+ 			break;
+ 
+ 		case HYPERV_CPUID_ENLIGHTMENT_INFO:
+ 			ent->eax |= HV_X64_REMOTE_TLB_FLUSH_RECOMMENDED;
+ 			ent->eax |= HV_X64_APIC_ACCESS_RECOMMENDED;
+ 			ent->eax |= HV_X64_RELAXED_TIMING_RECOMMENDED;
+ 			ent->eax |= HV_X64_CLUSTER_IPI_RECOMMENDED;
+ 			ent->eax |= HV_X64_EX_PROCESSOR_MASKS_RECOMMENDED;
+ 			if (evmcs_ver)
+ 				ent->eax |= HV_X64_ENLIGHTENED_VMCS_RECOMMENDED;
+ 
+ 			/*
+ 			 * Default number of spinlock retry attempts, matches
+ 			 * HyperV 2016.
+ 			 */
+ 			ent->ebx = 0x00000FFF;
+ 
+ 			break;
+ 
+ 		case HYPERV_CPUID_IMPLEMENT_LIMITS:
+ 			/* Maximum number of virtual processors */
+ 			ent->eax = KVM_MAX_VCPUS;
+ 			/*
+ 			 * Maximum number of logical processors, matches
+ 			 * HyperV 2016.
+ 			 */
+ 			ent->ebx = 64;
+ 
+ 			break;
+ 
+ 		case HYPERV_CPUID_NESTED_FEATURES:
+ 			ent->eax = evmcs_ver;
+ 
+ 			break;
+ 
+ 		default:
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (copy_to_user(entries, cpuid_entries,
+ 			 nent * sizeof(struct kvm_cpuid_entry2)))
+ 		return -EFAULT;
+ 
+ 	return 0;
+ }
++>>>>>>> ea1529873ab1 (KVM: x86: hyper-v: don't crash on KVM_GET_SUPPORTED_HV_CPUID when kvm_intel.nested is disabled)
diff --cc arch/x86/kvm/svm.c
index 4f0b48cab1b5,e0368076a1ef..000000000000
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@@ -7102,6 -7128,71 +7102,74 @@@ failed
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int nested_enable_evmcs(struct kvm_vcpu *vcpu,
+ 				   uint16_t *vmcs_version)
+ {
+ 	/* Intel-only feature */
+ 	return -ENODEV;
+ }
+ 
+ static bool svm_need_emulation_on_page_fault(struct kvm_vcpu *vcpu)
+ {
+ 	unsigned long cr4 = kvm_read_cr4(vcpu);
+ 	bool smep = cr4 & X86_CR4_SMEP;
+ 	bool smap = cr4 & X86_CR4_SMAP;
+ 	bool is_user = svm_get_cpl(vcpu) == 3;
+ 
+ 	/*
+ 	 * Detect and workaround Errata 1096 Fam_17h_00_0Fh.
+ 	 *
+ 	 * Errata:
+ 	 * When CPU raise #NPF on guest data access and vCPU CR4.SMAP=1, it is
+ 	 * possible that CPU microcode implementing DecodeAssist will fail
+ 	 * to read bytes of instruction which caused #NPF. In this case,
+ 	 * GuestIntrBytes field of the VMCB on a VMEXIT will incorrectly
+ 	 * return 0 instead of the correct guest instruction bytes.
+ 	 *
+ 	 * This happens because CPU microcode reading instruction bytes
+ 	 * uses a special opcode which attempts to read data using CPL=0
+ 	 * priviledges. The microcode reads CS:RIP and if it hits a SMAP
+ 	 * fault, it gives up and returns no instruction bytes.
+ 	 *
+ 	 * Detection:
+ 	 * We reach here in case CPU supports DecodeAssist, raised #NPF and
+ 	 * returned 0 in GuestIntrBytes field of the VMCB.
+ 	 * First, errata can only be triggered in case vCPU CR4.SMAP=1.
+ 	 * Second, if vCPU CR4.SMEP=1, errata could only be triggered
+ 	 * in case vCPU CPL==3 (Because otherwise guest would have triggered
+ 	 * a SMEP fault instead of #NPF).
+ 	 * Otherwise, vCPU CR4.SMEP=0, errata could be triggered by any vCPU CPL.
+ 	 * As most guests enable SMAP if they have also enabled SMEP, use above
+ 	 * logic in order to attempt minimize false-positive of detecting errata
+ 	 * while still preserving all cases semantic correctness.
+ 	 *
+ 	 * Workaround:
+ 	 * To determine what instruction the guest was executing, the hypervisor
+ 	 * will have to decode the instruction at the instruction pointer.
+ 	 *
+ 	 * In non SEV guest, hypervisor will be able to read the guest
+ 	 * memory to decode the instruction pointer when insn_len is zero
+ 	 * so we return true to indicate that decoding is possible.
+ 	 *
+ 	 * But in the SEV guest, the guest memory is encrypted with the
+ 	 * guest specific key and hypervisor will not be able to decode the
+ 	 * instruction pointer so we will not able to workaround it. Lets
+ 	 * print the error and request to kill the guest.
+ 	 */
+ 	if (smap && (!smep || is_user)) {
+ 		if (!sev_guest(vcpu->kvm))
+ 			return true;
+ 
+ 		pr_err_ratelimited("KVM: SEV Guest triggered AMD Erratum 1096\n");
+ 		kvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);
+ 	}
+ 
+ 	return false;
+ }
+ 
++>>>>>>> ea1529873ab1 (KVM: x86: hyper-v: don't crash on KVM_GET_SUPPORTED_HV_CPUID when kvm_intel.nested is disabled)
  static struct kvm_x86_ops svm_x86_ops __ro_after_init = {
  	.cpu_has_kvm_support = has_svm,
  	.disabled_by_bios = is_disabled,
@@@ -7231,6 -7324,11 +7299,14 @@@
  	.mem_enc_op = svm_mem_enc_op,
  	.mem_enc_reg_region = svm_register_enc_region,
  	.mem_enc_unreg_region = svm_unregister_enc_region,
++<<<<<<< HEAD
++=======
+ 
+ 	.nested_enable_evmcs = nested_enable_evmcs,
+ 	.nested_get_evmcs_version = NULL,
+ 
+ 	.need_emulation_on_page_fault = svm_need_emulation_on_page_fault,
++>>>>>>> ea1529873ab1 (KVM: x86: hyper-v: don't crash on KVM_GET_SUPPORTED_HV_CPUID when kvm_intel.nested is disabled)
  };
  
  static int __init svm_init(void)
diff --cc arch/x86/kvm/vmx/vmx.c
index 328ef1cd3c5c,c030c96fc81a..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -15188,6 -7791,14 +15188,17 @@@ static struct kvm_x86_ops vmx_x86_ops _
  	.pre_enter_smm = vmx_pre_enter_smm,
  	.pre_leave_smm = vmx_pre_leave_smm,
  	.enable_smi_window = enable_smi_window,
++<<<<<<< HEAD
++=======
+ 
+ 	.check_nested_events = NULL,
+ 	.get_nested_state = NULL,
+ 	.set_nested_state = NULL,
+ 	.get_vmcs12_pages = NULL,
+ 	.nested_enable_evmcs = NULL,
+ 	.nested_get_evmcs_version = NULL,
+ 	.need_emulation_on_page_fault = vmx_need_emulation_on_page_fault,
++>>>>>>> ea1529873ab1 (KVM: x86: hyper-v: don't crash on KVM_GET_SUPPORTED_HV_CPUID when kvm_intel.nested is disabled)
  };
  
  static void vmx_cleanup_l1d_flush(void)
* Unmerged path arch/x86/kvm/hyperv.c
* Unmerged path arch/x86/kvm/svm.c
* Unmerged path arch/x86/kvm/vmx/vmx.c
