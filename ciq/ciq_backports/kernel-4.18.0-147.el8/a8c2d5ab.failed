drm/i915/gvt: emit init breadcrumb for gvt request

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Weinan <weinan.z.li@intel.com>
commit a8c2d5ab9e71be3f9431c47bd45329a36e1fc650
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/a8c2d5ab.failed

"To track whether a request has started on HW, we can emit a breadcrumb at
the beginning of the request and check its timeline's HWSP to see if the
breadcrumb has advanced past the start of this request." It means all the
request which timeline's has_init_breadcrumb is true, then the
emit_init_breadcrumb process must have before emitting the real commands,
otherwise, the scheduler might get a wrong state of this request during
reset. If the request is exactly the guilty one, the scheduler won't
terminate it with the wrong state. To avoid this, do emit_init_breadcrumb
for all the requests from gvt.

v2: cc to stable kernel

Fixes: 8547444137ec ("drm/i915: Identify active requests")
	Cc: stable@vger.kernel.org
	Acked-by: Zhenyu Wang <zhenyuw@linux.intel.com>
	Signed-off-by: Weinan <weinan.z.li@intel.com>
	Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
(cherry picked from commit a8c2d5ab9e71be3f9431c47bd45329a36e1fc650)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/gvt/scheduler.c
diff --cc drivers/gpu/drm/i915/gvt/scheduler.c
index c2d183b91500,ccd71152c9bc..000000000000
--- a/drivers/gpu/drm/i915/gvt/scheduler.c
+++ b/drivers/gpu/drm/i915/gvt/scheduler.c
@@@ -300,14 -295,34 +300,36 @@@ static void shadow_context_descriptor_u
  static int copy_workload_to_ring_buffer(struct intel_vgpu_workload *workload)
  {
  	struct intel_vgpu *vgpu = workload->vgpu;
 -	struct i915_request *req = workload->req;
  	void *shadow_ring_buffer_va;
  	u32 *cs;
++<<<<<<< HEAD
 +	struct i915_request *req = workload->req;
++=======
+ 	int err;
++>>>>>>> a8c2d5ab9e71 (drm/i915/gvt: emit init breadcrumb for gvt request)
  
 -	if ((IS_KABYLAKE(req->i915) || IS_BROXTON(req->i915)
 -		|| IS_COFFEELAKE(req->i915))
 -		&& is_inhibit_context(req->hw_context))
 +	if (IS_KABYLAKE(req->i915) &&
 +	    is_inhibit_context(req->ctx, req->engine->id))
  		intel_vgpu_restore_inhibit_context(vgpu, req);
  
+ 	/*
+ 	 * To track whether a request has started on HW, we can emit a
+ 	 * breadcrumb at the beginning of the request and check its
+ 	 * timeline's HWSP to see if the breadcrumb has advanced past the
+ 	 * start of this request. Actually, the request must have the
+ 	 * init_breadcrumb if its timeline set has_init_bread_crumb, or the
+ 	 * scheduler might get a wrong state of it during reset. Since the
+ 	 * requests from gvt always set the has_init_breadcrumb flag, here
+ 	 * need to do the emit_init_breadcrumb for all the requests.
+ 	 */
+ 	if (req->engine->emit_init_breadcrumb) {
+ 		err = req->engine->emit_init_breadcrumb(req);
+ 		if (err) {
+ 			gvt_vgpu_err("fail to emit init breadcrumb\n");
+ 			return err;
+ 		}
+ 	}
+ 
  	/* allocate shadow ring buffer */
  	cs = intel_ring_begin(workload->req, workload->rb_len / sizeof(u32));
  	if (IS_ERR(cs)) {
* Unmerged path drivers/gpu/drm/i915/gvt/scheduler.c
