nvme: count all ANA groups for ANA Log page

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Hannes Reinecke <hare@suse.de>
commit be1277f5eb17a2e5788139eabb0b53dd04c695f3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/be1277f5.failed

When issuing a short read on the ANA log page the number of groups
should not change, even though the final returned data might contain
less groups than that number.

	Signed-off-by: Hannes Reinecke <hare@suse.com>
[switched to a for loop]
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit be1277f5eb17a2e5788139eabb0b53dd04c695f3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/target/admin-cmd.c
diff --cc drivers/nvme/target/admin-cmd.c
index 16a9b24270f9,2008fa62a373..000000000000
--- a/drivers/nvme/target/admin-cmd.c
+++ b/drivers/nvme/target/admin-cmd.c
@@@ -182,6 -195,74 +182,77 @@@ out
  	nvmet_req_complete(req, status);
  }
  
++<<<<<<< HEAD
++=======
+ static u32 nvmet_format_ana_group(struct nvmet_req *req, u32 grpid,
+ 		struct nvme_ana_group_desc *desc)
+ {
+ 	struct nvmet_ctrl *ctrl = req->sq->ctrl;
+ 	struct nvmet_ns *ns;
+ 	u32 count = 0;
+ 
+ 	if (!(req->cmd->get_log_page.lsp & NVME_ANA_LOG_RGO)) {
+ 		rcu_read_lock();
+ 		list_for_each_entry_rcu(ns, &ctrl->subsys->namespaces, dev_link)
+ 			if (ns->anagrpid == grpid)
+ 				desc->nsids[count++] = cpu_to_le32(ns->nsid);
+ 		rcu_read_unlock();
+ 	}
+ 
+ 	desc->grpid = cpu_to_le32(grpid);
+ 	desc->nnsids = cpu_to_le32(count);
+ 	desc->chgcnt = cpu_to_le64(nvmet_ana_chgcnt);
+ 	desc->state = req->port->ana_state[grpid];
+ 	memset(desc->rsvd17, 0, sizeof(desc->rsvd17));
+ 	return sizeof(struct nvme_ana_group_desc) + count * sizeof(__le32);
+ }
+ 
+ static void nvmet_execute_get_log_page_ana(struct nvmet_req *req)
+ {
+ 	struct nvme_ana_rsp_hdr hdr = { 0, };
+ 	struct nvme_ana_group_desc *desc;
+ 	size_t offset = sizeof(struct nvme_ana_rsp_hdr); /* start beyond hdr */
+ 	size_t len;
+ 	u32 grpid;
+ 	u16 ngrps = 0;
+ 	u16 status;
+ 
+ 	status = NVME_SC_INTERNAL;
+ 	desc = kmalloc(sizeof(struct nvme_ana_group_desc) +
+ 			NVMET_MAX_NAMESPACES * sizeof(__le32), GFP_KERNEL);
+ 	if (!desc)
+ 		goto out;
+ 
+ 	down_read(&nvmet_ana_sem);
+ 	for (grpid = 1; grpid <= NVMET_MAX_ANAGRPS; grpid++) {
+ 		if (!nvmet_ana_group_enabled[grpid])
+ 			continue;
+ 		len = nvmet_format_ana_group(req, grpid, desc);
+ 		status = nvmet_copy_to_sgl(req, offset, desc, len);
+ 		if (status)
+ 			break;
+ 		offset += len;
+ 		ngrps++;
+ 	}
+ 	for ( ; grpid <= NVMET_MAX_ANAGRPS; grpid++) {
+ 		if (nvmet_ana_group_enabled[grpid])
+ 			ngrps++;
+ 	}
+ 
+ 	hdr.chgcnt = cpu_to_le64(nvmet_ana_chgcnt);
+ 	hdr.ngrps = cpu_to_le16(ngrps);
+ 	nvmet_clear_aen(req, NVME_AEN_CFG_ANA_CHANGE);
+ 	up_read(&nvmet_ana_sem);
+ 
+ 	kfree(desc);
+ 
+ 	/* copy the header last once we know the number of groups */
+ 	status = nvmet_copy_to_sgl(req, 0, &hdr, sizeof(hdr));
+ out:
+ 	nvmet_req_complete(req, status);
+ }
+ 
++>>>>>>> be1277f5eb17 (nvme: count all ANA groups for ANA Log page)
  static void nvmet_execute_identify_ctrl(struct nvmet_req *req)
  {
  	struct nvmet_ctrl *ctrl = req->sq->ctrl;
* Unmerged path drivers/nvme/target/admin-cmd.c
