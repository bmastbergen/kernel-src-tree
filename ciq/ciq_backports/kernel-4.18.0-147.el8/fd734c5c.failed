libbpf: bpf_program__pin: add special case for instances.nr == 1

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Stanislav Fomichev <sdf@google.com>
commit fd734c5cca62b7630703244d3613be135d646a0e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/fd734c5c.failed

When bpf_program has only one instance, don't create a subdirectory with
per-instance pin files (<prog>/0). Instead, just create a single pin file
for that single instance. This simplifies object pinning by not creating
unnecessary subdirectories.

This can potentially break existing users that depend on the case
where '/0' is always created. However, I couldn't find any serious
usage of bpf_program__pin inside the kernel tree and I suppose there
should be none outside.

	Signed-off-by: Stanislav Fomichev <sdf@google.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit fd734c5cca62b7630703244d3613be135d646a0e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/libbpf.c
diff --cc tools/lib/bpf/libbpf.c
index f064c910a99d,97ce9f214002..000000000000
--- a/tools/lib/bpf/libbpf.c
+++ b/tools/lib/bpf/libbpf.c
@@@ -1755,6 -1775,69 +1760,72 @@@ int bpf_program__pin(struct bpf_progra
  		int len;
  
  		len = snprintf(buf, PATH_MAX, "%s/%d", path, i);
++<<<<<<< HEAD
++=======
+ 		if (len < 0) {
+ 			err = -EINVAL;
+ 			goto err_unpin;
+ 		} else if (len >= PATH_MAX) {
+ 			err = -ENAMETOOLONG;
+ 			goto err_unpin;
+ 		}
+ 
+ 		err = bpf_program__pin_instance(prog, buf, i);
+ 		if (err)
+ 			goto err_unpin;
+ 	}
+ 
+ 	return 0;
+ 
+ err_unpin:
+ 	for (i = i - 1; i >= 0; i--) {
+ 		char buf[PATH_MAX];
+ 		int len;
+ 
+ 		len = snprintf(buf, PATH_MAX, "%s/%d", path, i);
+ 		if (len < 0)
+ 			continue;
+ 		else if (len >= PATH_MAX)
+ 			continue;
+ 
+ 		bpf_program__unpin_instance(prog, buf, i);
+ 	}
+ 
+ 	rmdir(path);
+ 
+ 	return err;
+ }
+ 
+ int bpf_program__unpin(struct bpf_program *prog, const char *path)
+ {
+ 	int i, err;
+ 
+ 	err = check_path(path);
+ 	if (err)
+ 		return err;
+ 
+ 	if (prog == NULL) {
+ 		pr_warning("invalid program pointer\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (prog->instances.nr <= 0) {
+ 		pr_warning("no instances of prog %s to pin\n",
+ 			   prog->section_name);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (prog->instances.nr == 1) {
+ 		/* don't create subdirs when pinning single instance */
+ 		return bpf_program__unpin_instance(prog, path, 0);
+ 	}
+ 
+ 	for (i = 0; i < prog->instances.nr; i++) {
+ 		char buf[PATH_MAX];
+ 		int len;
+ 
+ 		len = snprintf(buf, PATH_MAX, "%s/%d", path, i);
++>>>>>>> fd734c5cca62 (libbpf: bpf_program__pin: add special case for instances.nr == 1)
  		if (len < 0)
  			return -EINVAL;
  		else if (len >= PATH_MAX)
* Unmerged path tools/lib/bpf/libbpf.c
