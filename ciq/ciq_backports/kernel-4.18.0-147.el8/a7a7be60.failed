net/sched: add sample action to the hardware intermediate representation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [net] sched: add sample action to the hardware intermediate representation (Ivan Vecera) [1688236 1687456]
Rebuild_FUZZ: 97.14%
commit-author Pieter Jansen van Vuuren <pieter.jansenvanvuuren@netronome.com>
commit a7a7be6087b07563490725f61f4dbf4826f099e2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/a7a7be60.failed

Add sample action to the hardware intermediate representation model which
would subsequently allow it to be used by drivers for offload.

	Signed-off-by: Pieter Jansen van Vuuren <pieter.jansenvanvuuren@netronome.com>
	Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a7a7be6087b07563490725f61f4dbf4826f099e2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/flow_offload.h
#	net/sched/cls_api.c
diff --cc net/sched/cls_api.c
index 7baa7d9ab5a0,f8ee2d78654a..000000000000
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@@ -31,6 -31,14 +31,17 @@@
  #include <net/netlink.h>
  #include <net/pkt_sched.h>
  #include <net/pkt_cls.h>
++<<<<<<< HEAD
++=======
+ #include <net/tc_act/tc_pedit.h>
+ #include <net/tc_act/tc_mirred.h>
+ #include <net/tc_act/tc_vlan.h>
+ #include <net/tc_act/tc_tunnel_key.h>
+ #include <net/tc_act/tc_csum.h>
+ #include <net/tc_act/tc_gact.h>
+ #include <net/tc_act/tc_sample.h>
+ #include <net/tc_act/tc_skbedit.h>
++>>>>>>> a7a7be6087b0 (net/sched: add sample action to the hardware intermediate representation)
  
  extern const struct nla_policy rtm_tca_policy[TCA_MAX + 1];
  
@@@ -3049,6 -3180,120 +3060,123 @@@ int tc_setup_cb_call(struct tcf_block *
  }
  EXPORT_SYMBOL(tc_setup_cb_call);
  
++<<<<<<< HEAD
++=======
+ int tc_setup_flow_action(struct flow_action *flow_action,
+ 			 const struct tcf_exts *exts)
+ {
+ 	const struct tc_action *act;
+ 	int i, j, k;
+ 
+ 	if (!exts)
+ 		return 0;
+ 
+ 	j = 0;
+ 	tcf_exts_for_each_action(i, act, exts) {
+ 		struct flow_action_entry *entry;
+ 
+ 		entry = &flow_action->entries[j];
+ 		if (is_tcf_gact_ok(act)) {
+ 			entry->id = FLOW_ACTION_ACCEPT;
+ 		} else if (is_tcf_gact_shot(act)) {
+ 			entry->id = FLOW_ACTION_DROP;
+ 		} else if (is_tcf_gact_trap(act)) {
+ 			entry->id = FLOW_ACTION_TRAP;
+ 		} else if (is_tcf_gact_goto_chain(act)) {
+ 			entry->id = FLOW_ACTION_GOTO;
+ 			entry->chain_index = tcf_gact_goto_chain_index(act);
+ 		} else if (is_tcf_mirred_egress_redirect(act)) {
+ 			entry->id = FLOW_ACTION_REDIRECT;
+ 			entry->dev = tcf_mirred_dev(act);
+ 		} else if (is_tcf_mirred_egress_mirror(act)) {
+ 			entry->id = FLOW_ACTION_MIRRED;
+ 			entry->dev = tcf_mirred_dev(act);
+ 		} else if (is_tcf_vlan(act)) {
+ 			switch (tcf_vlan_action(act)) {
+ 			case TCA_VLAN_ACT_PUSH:
+ 				entry->id = FLOW_ACTION_VLAN_PUSH;
+ 				entry->vlan.vid = tcf_vlan_push_vid(act);
+ 				entry->vlan.proto = tcf_vlan_push_proto(act);
+ 				entry->vlan.prio = tcf_vlan_push_prio(act);
+ 				break;
+ 			case TCA_VLAN_ACT_POP:
+ 				entry->id = FLOW_ACTION_VLAN_POP;
+ 				break;
+ 			case TCA_VLAN_ACT_MODIFY:
+ 				entry->id = FLOW_ACTION_VLAN_MANGLE;
+ 				entry->vlan.vid = tcf_vlan_push_vid(act);
+ 				entry->vlan.proto = tcf_vlan_push_proto(act);
+ 				entry->vlan.prio = tcf_vlan_push_prio(act);
+ 				break;
+ 			default:
+ 				goto err_out;
+ 			}
+ 		} else if (is_tcf_tunnel_set(act)) {
+ 			entry->id = FLOW_ACTION_TUNNEL_ENCAP;
+ 			entry->tunnel = tcf_tunnel_info(act);
+ 		} else if (is_tcf_tunnel_release(act)) {
+ 			entry->id = FLOW_ACTION_TUNNEL_DECAP;
+ 		} else if (is_tcf_pedit(act)) {
+ 			for (k = 0; k < tcf_pedit_nkeys(act); k++) {
+ 				switch (tcf_pedit_cmd(act, k)) {
+ 				case TCA_PEDIT_KEY_EX_CMD_SET:
+ 					entry->id = FLOW_ACTION_MANGLE;
+ 					break;
+ 				case TCA_PEDIT_KEY_EX_CMD_ADD:
+ 					entry->id = FLOW_ACTION_ADD;
+ 					break;
+ 				default:
+ 					goto err_out;
+ 				}
+ 				entry->mangle.htype = tcf_pedit_htype(act, k);
+ 				entry->mangle.mask = tcf_pedit_mask(act, k);
+ 				entry->mangle.val = tcf_pedit_val(act, k);
+ 				entry->mangle.offset = tcf_pedit_offset(act, k);
+ 				entry = &flow_action->entries[++j];
+ 			}
+ 		} else if (is_tcf_csum(act)) {
+ 			entry->id = FLOW_ACTION_CSUM;
+ 			entry->csum_flags = tcf_csum_update_flags(act);
+ 		} else if (is_tcf_skbedit_mark(act)) {
+ 			entry->id = FLOW_ACTION_MARK;
+ 			entry->mark = tcf_skbedit_mark(act);
+ 		} else if (is_tcf_sample(act)) {
+ 			entry->id = FLOW_ACTION_SAMPLE;
+ 			entry->sample.psample_group =
+ 				tcf_sample_psample_group(act);
+ 			entry->sample.trunc_size = tcf_sample_trunc_size(act);
+ 			entry->sample.truncate = tcf_sample_truncate(act);
+ 			entry->sample.rate = tcf_sample_rate(act);
+ 		} else {
+ 			goto err_out;
+ 		}
+ 
+ 		if (!is_tcf_pedit(act))
+ 			j++;
+ 	}
+ 	return 0;
+ err_out:
+ 	return -EOPNOTSUPP;
+ }
+ EXPORT_SYMBOL(tc_setup_flow_action);
+ 
+ unsigned int tcf_exts_num_actions(struct tcf_exts *exts)
+ {
+ 	unsigned int num_acts = 0;
+ 	struct tc_action *act;
+ 	int i;
+ 
+ 	tcf_exts_for_each_action(i, act, exts) {
+ 		if (is_tcf_pedit(act))
+ 			num_acts += tcf_pedit_nkeys(act);
+ 		else
+ 			num_acts++;
+ 	}
+ 	return num_acts;
+ }
+ EXPORT_SYMBOL(tcf_exts_num_actions);
+ 
++>>>>>>> a7a7be6087b0 (net/sched: add sample action to the hardware intermediate representation)
  static __net_init int tcf_net_init(struct net *net)
  {
  	struct tcf_net *tn = net_generic(net, tcf_net_id);
* Unmerged path include/net/flow_offload.h
* Unmerged path include/net/flow_offload.h
* Unmerged path net/sched/cls_api.c
