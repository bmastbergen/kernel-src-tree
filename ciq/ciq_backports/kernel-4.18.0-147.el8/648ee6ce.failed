net: tls, correctly account for copied bytes with multiple sk_msgs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [net] tls, correctly account for copied bytes with multiple sk_msgs (Sabrina Dubroca) [1739260]
Rebuild_FUZZ: 96.06%
commit-author John Fastabend <john.fastabend@gmail.com>
commit 648ee6cea7dde4a5cdf817e5d964fd60b22006a4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/648ee6ce.failed

tls_sw_do_sendpage needs to return the total number of bytes sent
regardless of how many sk_msgs are allocated. Unfortunately, copied
(the value we return up the stack) is zero'd before each new sk_msg
is allocated so we only return the copied size of the last sk_msg used.

The caller (splice, etc.) of sendpage will then believe only part
of its data was sent and send the missing chunks again. However,
because the data actually was sent the receiver will get multiple
copies of the same data.

To reproduce this do multiple sendfile calls with a length close to
the max record size. This will in turn call splice/sendpage, sendpage
may use multiple sk_msg in this case and then returns the incorrect
number of bytes. This will cause splice to resend creating duplicate
data on the receiver. Andre created a C program that can easily
generate this case so we will push a similar selftest for this to
bpf-next shortly.

The fix is to _not_ zero the copied field so that the total sent
bytes is returned.

	Reported-by: Steinar H. Gunderson <steinar+kernel@gunderson.no>
	Reported-by: Andre Tomt <andre@tomt.net>
	Tested-by: Andre Tomt <andre@tomt.net>
Fixes: d829e9c4112b ("tls: convert to generic sk_msg interface")
	Signed-off-by: John Fastabend <john.fastabend@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 648ee6cea7dde4a5cdf817e5d964fd60b22006a4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/tls/tls_sw.c
diff --cc net/tls/tls_sw.c
index 3f443983a6b3,455a782c7658..000000000000
--- a/net/tls/tls_sw.c
+++ b/net/tls/tls_sw.c
@@@ -970,8 -1139,10 +970,12 @@@ int tls_sw_sendpage(struct sock *sk, st
  			goto sendpage_end;
  		}
  
 -		msg_pl = &rec->msg_plaintext;
 -
  		full_record = false;
++<<<<<<< HEAD
 +		record_room = TLS_MAX_PAYLOAD_SIZE - rec->sg_plaintext_size;
++=======
+ 		record_room = TLS_MAX_PAYLOAD_SIZE - msg_pl->sg.size;
++>>>>>>> 648ee6cea7dd (net: tls, correctly account for copied bytes with multiple sk_msgs)
  		copy = size;
  		if (copy >= record_room) {
  			copy = record_room;
* Unmerged path net/tls/tls_sw.c
