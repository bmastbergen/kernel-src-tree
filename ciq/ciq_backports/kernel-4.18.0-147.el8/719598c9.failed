IB/mlx5: Update the supported DEVX commands

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Yishai Hadas <yishaih@mellanox.com>
commit 719598c98d1961e78e2ad514a2cc15deb5e41db5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/719598c9.failed

Update the supported DEVX commands, it includes adding to the
query/modify command's list and to the encoding handling.

In addition, a valid range for general commands was added to be used for
future commands.

	Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
	Reviewed-by: Artemy Kovalyov <artemyko@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 719598c98d1961e78e2ad514a2cc15deb5e41db5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/devx.c
diff --cc drivers/infiniband/hw/mlx5/devx.c
index c7f8859c08ee,5271469aad10..000000000000
--- a/drivers/infiniband/hw/mlx5/devx.c
+++ b/drivers/infiniband/hw/mlx5/devx.c
@@@ -71,7 -93,359 +71,363 @@@ void mlx5_ib_devx_destroy(struct mlx5_i
  	mlx5_cmd_exec(dev->mdev, in, sizeof(in), out, sizeof(out));
  }
  
++<<<<<<< HEAD
 +static bool devx_is_obj_create_cmd(const void *in)
++=======
+ bool mlx5_ib_devx_is_flow_dest(void *obj, int *dest_id, int *dest_type)
+ {
+ 	struct devx_obj *devx_obj = obj;
+ 	u16 opcode = MLX5_GET(general_obj_in_cmd_hdr, devx_obj->dinbox, opcode);
+ 
+ 	switch (opcode) {
+ 	case MLX5_CMD_OP_DESTROY_TIR:
+ 		*dest_type = MLX5_FLOW_DESTINATION_TYPE_TIR;
+ 		*dest_id = MLX5_GET(general_obj_in_cmd_hdr, devx_obj->dinbox,
+ 				    obj_id);
+ 		return true;
+ 
+ 	case MLX5_CMD_OP_DESTROY_FLOW_TABLE:
+ 		*dest_type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
+ 		*dest_id = MLX5_GET(destroy_flow_table_in, devx_obj->dinbox,
+ 				    table_id);
+ 		return true;
+ 	default:
+ 		return false;
+ 	}
+ }
+ 
+ bool mlx5_ib_devx_is_flow_counter(void *obj, u32 *counter_id)
+ {
+ 	struct devx_obj *devx_obj = obj;
+ 	u16 opcode = MLX5_GET(general_obj_in_cmd_hdr, devx_obj->dinbox, opcode);
+ 
+ 	if (opcode == MLX5_CMD_OP_DEALLOC_FLOW_COUNTER) {
+ 		*counter_id = MLX5_GET(dealloc_flow_counter_in,
+ 				       devx_obj->dinbox,
+ 				       flow_counter_id);
+ 		return true;
+ 	}
+ 
+ 	return false;
+ }
+ 
+ /*
+  * As the obj_id in the firmware is not globally unique the object type
+  * must be considered upon checking for a valid object id.
+  * For that the opcode of the creator command is encoded as part of the obj_id.
+  */
+ static u64 get_enc_obj_id(u16 opcode, u32 obj_id)
+ {
+ 	return ((u64)opcode << 32) | obj_id;
+ }
+ 
+ static u64 devx_get_obj_id(const void *in)
+ {
+ 	u16 opcode = MLX5_GET(general_obj_in_cmd_hdr, in, opcode);
+ 	u64 obj_id;
+ 
+ 	switch (opcode) {
+ 	case MLX5_CMD_OP_MODIFY_GENERAL_OBJECT:
+ 	case MLX5_CMD_OP_QUERY_GENERAL_OBJECT:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_GENERAL_OBJECT,
+ 					MLX5_GET(general_obj_in_cmd_hdr, in,
+ 						 obj_id));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_MKEY:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_MKEY,
+ 					MLX5_GET(query_mkey_in, in,
+ 						 mkey_index));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_CQ:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_CQ,
+ 					MLX5_GET(query_cq_in, in, cqn));
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_CQ:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_CQ,
+ 					MLX5_GET(modify_cq_in, in, cqn));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_SQ:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_SQ,
+ 					MLX5_GET(query_sq_in, in, sqn));
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_SQ:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_SQ,
+ 					MLX5_GET(modify_sq_in, in, sqn));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_RQ:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_RQ,
+ 					MLX5_GET(query_rq_in, in, rqn));
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_RQ:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_RQ,
+ 					MLX5_GET(modify_rq_in, in, rqn));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_RMP:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_RMP,
+ 					MLX5_GET(query_rmp_in, in, rmpn));
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_RMP:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_RMP,
+ 					MLX5_GET(modify_rmp_in, in, rmpn));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_RQT:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_RQT,
+ 					MLX5_GET(query_rqt_in, in, rqtn));
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_RQT:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_RQT,
+ 					MLX5_GET(modify_rqt_in, in, rqtn));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_TIR:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_TIR,
+ 					MLX5_GET(query_tir_in, in, tirn));
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_TIR:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_TIR,
+ 					MLX5_GET(modify_tir_in, in, tirn));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_TIS:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_TIS,
+ 					MLX5_GET(query_tis_in, in, tisn));
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_TIS:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_TIS,
+ 					MLX5_GET(modify_tis_in, in, tisn));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_FLOW_TABLE:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_FLOW_TABLE,
+ 					MLX5_GET(query_flow_table_in, in,
+ 						 table_id));
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_FLOW_TABLE:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_FLOW_TABLE,
+ 					MLX5_GET(modify_flow_table_in, in,
+ 						 table_id));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_FLOW_GROUP:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_FLOW_GROUP,
+ 					MLX5_GET(query_flow_group_in, in,
+ 						 group_id));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_FLOW_TABLE_ENTRY:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_SET_FLOW_TABLE_ENTRY,
+ 					MLX5_GET(query_fte_in, in,
+ 						 flow_index));
+ 		break;
+ 	case MLX5_CMD_OP_SET_FLOW_TABLE_ENTRY:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_SET_FLOW_TABLE_ENTRY,
+ 					MLX5_GET(set_fte_in, in, flow_index));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_Q_COUNTER:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_ALLOC_Q_COUNTER,
+ 					MLX5_GET(query_q_counter_in, in,
+ 						 counter_set_id));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_FLOW_COUNTER:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_ALLOC_FLOW_COUNTER,
+ 					MLX5_GET(query_flow_counter_in, in,
+ 						 flow_counter_id));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_MODIFY_HEADER_CONTEXT:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_ALLOC_MODIFY_HEADER_CONTEXT,
+ 					MLX5_GET(general_obj_in_cmd_hdr, in,
+ 						 obj_id));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_SCHEDULING_ELEMENT:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_SCHEDULING_ELEMENT,
+ 					MLX5_GET(query_scheduling_element_in,
+ 						 in, scheduling_element_id));
+ 		break;
+ 	case MLX5_CMD_OP_MODIFY_SCHEDULING_ELEMENT:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_SCHEDULING_ELEMENT,
+ 					MLX5_GET(modify_scheduling_element_in,
+ 						 in, scheduling_element_id));
+ 		break;
+ 	case MLX5_CMD_OP_ADD_VXLAN_UDP_DPORT:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_ADD_VXLAN_UDP_DPORT,
+ 					MLX5_GET(add_vxlan_udp_dport_in, in,
+ 						 vxlan_udp_port));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_L2_TABLE_ENTRY:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_SET_L2_TABLE_ENTRY,
+ 					MLX5_GET(query_l2_table_entry_in, in,
+ 						 table_index));
+ 		break;
+ 	case MLX5_CMD_OP_SET_L2_TABLE_ENTRY:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_SET_L2_TABLE_ENTRY,
+ 					MLX5_GET(set_l2_table_entry_in, in,
+ 						 table_index));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_QP:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_QP,
+ 					MLX5_GET(query_qp_in, in, qpn));
+ 		break;
+ 	case MLX5_CMD_OP_RST2INIT_QP:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_QP,
+ 					MLX5_GET(rst2init_qp_in, in, qpn));
+ 		break;
+ 	case MLX5_CMD_OP_INIT2RTR_QP:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_QP,
+ 					MLX5_GET(init2rtr_qp_in, in, qpn));
+ 		break;
+ 	case MLX5_CMD_OP_RTR2RTS_QP:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_QP,
+ 					MLX5_GET(rtr2rts_qp_in, in, qpn));
+ 		break;
+ 	case MLX5_CMD_OP_RTS2RTS_QP:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_QP,
+ 					MLX5_GET(rts2rts_qp_in, in, qpn));
+ 		break;
+ 	case MLX5_CMD_OP_SQERR2RTS_QP:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_QP,
+ 					MLX5_GET(sqerr2rts_qp_in, in, qpn));
+ 		break;
+ 	case MLX5_CMD_OP_2ERR_QP:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_QP,
+ 					MLX5_GET(qp_2err_in, in, qpn));
+ 		break;
+ 	case MLX5_CMD_OP_2RST_QP:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_QP,
+ 					MLX5_GET(qp_2rst_in, in, qpn));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_DCT:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_DCT,
+ 					MLX5_GET(query_dct_in, in, dctn));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_XRQ:
+ 	case MLX5_CMD_OP_QUERY_XRQ_DC_PARAMS_ENTRY:
+ 	case MLX5_CMD_OP_QUERY_XRQ_ERROR_PARAMS:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_XRQ,
+ 					MLX5_GET(query_xrq_in, in, xrqn));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_XRC_SRQ:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_XRC_SRQ,
+ 					MLX5_GET(query_xrc_srq_in, in,
+ 						 xrc_srqn));
+ 		break;
+ 	case MLX5_CMD_OP_ARM_XRC_SRQ:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_XRC_SRQ,
+ 					MLX5_GET(arm_xrc_srq_in, in, xrc_srqn));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_SRQ:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_SRQ,
+ 					MLX5_GET(query_srq_in, in, srqn));
+ 		break;
+ 	case MLX5_CMD_OP_ARM_RQ:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_RQ,
+ 					MLX5_GET(arm_rq_in, in, srq_number));
+ 		break;
+ 	case MLX5_CMD_OP_DRAIN_DCT:
+ 	case MLX5_CMD_OP_ARM_DCT_FOR_KEY_VIOLATION:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_DCT,
+ 					MLX5_GET(drain_dct_in, in, dctn));
+ 		break;
+ 	case MLX5_CMD_OP_ARM_XRQ:
+ 	case MLX5_CMD_OP_SET_XRQ_DC_PARAMS_ENTRY:
+ 		obj_id = get_enc_obj_id(MLX5_CMD_OP_CREATE_XRQ,
+ 					MLX5_GET(arm_xrq_in, in, xrqn));
+ 		break;
+ 	case MLX5_CMD_OP_QUERY_PACKET_REFORMAT_CONTEXT:
+ 		obj_id = get_enc_obj_id
+ 				(MLX5_CMD_OP_ALLOC_PACKET_REFORMAT_CONTEXT,
+ 				 MLX5_GET(query_packet_reformat_context_in,
+ 					  in, packet_reformat_id));
+ 		break;
+ 	default:
+ 		obj_id = 0;
+ 	}
+ 
+ 	return obj_id;
+ }
+ 
+ static bool devx_is_valid_obj_id(struct ib_uobject *uobj, const void *in)
+ {
+ 	u64 obj_id = devx_get_obj_id(in);
+ 
+ 	if (!obj_id)
+ 		return false;
+ 
+ 	switch (uobj_get_object_id(uobj)) {
+ 	case UVERBS_OBJECT_CQ:
+ 		return get_enc_obj_id(MLX5_CMD_OP_CREATE_CQ,
+ 				      to_mcq(uobj->object)->mcq.cqn) ==
+ 				      obj_id;
+ 
+ 	case UVERBS_OBJECT_SRQ:
+ 	{
+ 		struct mlx5_core_srq *srq = &(to_msrq(uobj->object)->msrq);
+ 		struct mlx5_ib_dev *dev = to_mdev(uobj->context->device);
+ 		u16 opcode;
+ 
+ 		switch (srq->common.res) {
+ 		case MLX5_RES_XSRQ:
+ 			opcode = MLX5_CMD_OP_CREATE_XRC_SRQ;
+ 			break;
+ 		case MLX5_RES_XRQ:
+ 			opcode = MLX5_CMD_OP_CREATE_XRQ;
+ 			break;
+ 		default:
+ 			if (!dev->mdev->issi)
+ 				opcode = MLX5_CMD_OP_CREATE_SRQ;
+ 			else
+ 				opcode = MLX5_CMD_OP_CREATE_RMP;
+ 		}
+ 
+ 		return get_enc_obj_id(opcode,
+ 				      to_msrq(uobj->object)->msrq.srqn) ==
+ 				      obj_id;
+ 	}
+ 
+ 	case UVERBS_OBJECT_QP:
+ 	{
+ 		struct mlx5_ib_qp *qp = to_mqp(uobj->object);
+ 		enum ib_qp_type	qp_type = qp->ibqp.qp_type;
+ 
+ 		if (qp_type == IB_QPT_RAW_PACKET ||
+ 		    (qp->flags & MLX5_IB_QP_UNDERLAY)) {
+ 			struct mlx5_ib_raw_packet_qp *raw_packet_qp =
+ 							 &qp->raw_packet_qp;
+ 			struct mlx5_ib_rq *rq = &raw_packet_qp->rq;
+ 			struct mlx5_ib_sq *sq = &raw_packet_qp->sq;
+ 
+ 			return (get_enc_obj_id(MLX5_CMD_OP_CREATE_RQ,
+ 					       rq->base.mqp.qpn) == obj_id ||
+ 				get_enc_obj_id(MLX5_CMD_OP_CREATE_SQ,
+ 					       sq->base.mqp.qpn) == obj_id ||
+ 				get_enc_obj_id(MLX5_CMD_OP_CREATE_TIR,
+ 					       rq->tirn) == obj_id ||
+ 				get_enc_obj_id(MLX5_CMD_OP_CREATE_TIS,
+ 					       sq->tisn) == obj_id);
+ 		}
+ 
+ 		if (qp_type == MLX5_IB_QPT_DCT)
+ 			return get_enc_obj_id(MLX5_CMD_OP_CREATE_DCT,
+ 					      qp->dct.mdct.mqp.qpn) == obj_id;
+ 
+ 		return get_enc_obj_id(MLX5_CMD_OP_CREATE_QP,
+ 				      qp->ibqp.qp_num) == obj_id;
+ 	}
+ 
+ 	case UVERBS_OBJECT_WQ:
+ 		return get_enc_obj_id(MLX5_CMD_OP_CREATE_RQ,
+ 				      to_mrwq(uobj->object)->core_qp.qpn) ==
+ 				      obj_id;
+ 
+ 	case UVERBS_OBJECT_RWQ_IND_TBL:
+ 		return get_enc_obj_id(MLX5_CMD_OP_CREATE_RQT,
+ 				      to_mrwq_ind_table(uobj->object)->rqtn) ==
+ 				      obj_id;
+ 
+ 	case MLX5_IB_OBJECT_DEVX_OBJ:
+ 		return ((struct devx_obj *)uobj->object)->obj_id == obj_id;
+ 
+ 	default:
+ 		return false;
+ 	}
+ }
+ 
+ static void devx_set_umem_valid(const void *in)
++>>>>>>> 719598c98d19 (IB/mlx5: Update the supported DEVX commands)
  {
  	u16 opcode = MLX5_GET(general_obj_in_cmd_hdr, in, opcode);
  
@@@ -116,12 -581,130 +472,137 @@@
  	}
  }
  
++<<<<<<< HEAD
 +static bool devx_is_general_cmd(const void *in)
++=======
+ static bool devx_is_obj_modify_cmd(const void *in)
+ {
+ 	u16 opcode = MLX5_GET(general_obj_in_cmd_hdr, in, opcode);
+ 
+ 	switch (opcode) {
+ 	case MLX5_CMD_OP_MODIFY_GENERAL_OBJECT:
+ 	case MLX5_CMD_OP_MODIFY_CQ:
+ 	case MLX5_CMD_OP_MODIFY_RMP:
+ 	case MLX5_CMD_OP_MODIFY_SQ:
+ 	case MLX5_CMD_OP_MODIFY_RQ:
+ 	case MLX5_CMD_OP_MODIFY_RQT:
+ 	case MLX5_CMD_OP_MODIFY_TIR:
+ 	case MLX5_CMD_OP_MODIFY_TIS:
+ 	case MLX5_CMD_OP_MODIFY_FLOW_TABLE:
+ 	case MLX5_CMD_OP_MODIFY_SCHEDULING_ELEMENT:
+ 	case MLX5_CMD_OP_ADD_VXLAN_UDP_DPORT:
+ 	case MLX5_CMD_OP_SET_L2_TABLE_ENTRY:
+ 	case MLX5_CMD_OP_RST2INIT_QP:
+ 	case MLX5_CMD_OP_INIT2RTR_QP:
+ 	case MLX5_CMD_OP_RTR2RTS_QP:
+ 	case MLX5_CMD_OP_RTS2RTS_QP:
+ 	case MLX5_CMD_OP_SQERR2RTS_QP:
+ 	case MLX5_CMD_OP_2ERR_QP:
+ 	case MLX5_CMD_OP_2RST_QP:
+ 	case MLX5_CMD_OP_ARM_XRC_SRQ:
+ 	case MLX5_CMD_OP_ARM_RQ:
+ 	case MLX5_CMD_OP_DRAIN_DCT:
+ 	case MLX5_CMD_OP_ARM_DCT_FOR_KEY_VIOLATION:
+ 	case MLX5_CMD_OP_ARM_XRQ:
+ 	case MLX5_CMD_OP_SET_XRQ_DC_PARAMS_ENTRY:
+ 		return true;
+ 	case MLX5_CMD_OP_SET_FLOW_TABLE_ENTRY:
+ 	{
+ 		u16 op_mod = MLX5_GET(set_fte_in, in, op_mod);
+ 
+ 		if (op_mod == 1)
+ 			return true;
+ 		return false;
+ 	}
+ 	default:
+ 		return false;
+ 	}
+ }
+ 
+ static bool devx_is_obj_query_cmd(const void *in)
  {
  	u16 opcode = MLX5_GET(general_obj_in_cmd_hdr, in, opcode);
  
+ 	switch (opcode) {
+ 	case MLX5_CMD_OP_QUERY_GENERAL_OBJECT:
+ 	case MLX5_CMD_OP_QUERY_MKEY:
+ 	case MLX5_CMD_OP_QUERY_CQ:
+ 	case MLX5_CMD_OP_QUERY_RMP:
+ 	case MLX5_CMD_OP_QUERY_SQ:
+ 	case MLX5_CMD_OP_QUERY_RQ:
+ 	case MLX5_CMD_OP_QUERY_RQT:
+ 	case MLX5_CMD_OP_QUERY_TIR:
+ 	case MLX5_CMD_OP_QUERY_TIS:
+ 	case MLX5_CMD_OP_QUERY_Q_COUNTER:
+ 	case MLX5_CMD_OP_QUERY_FLOW_TABLE:
+ 	case MLX5_CMD_OP_QUERY_FLOW_GROUP:
+ 	case MLX5_CMD_OP_QUERY_FLOW_TABLE_ENTRY:
+ 	case MLX5_CMD_OP_QUERY_FLOW_COUNTER:
+ 	case MLX5_CMD_OP_QUERY_MODIFY_HEADER_CONTEXT:
+ 	case MLX5_CMD_OP_QUERY_SCHEDULING_ELEMENT:
+ 	case MLX5_CMD_OP_QUERY_L2_TABLE_ENTRY:
+ 	case MLX5_CMD_OP_QUERY_QP:
+ 	case MLX5_CMD_OP_QUERY_SRQ:
+ 	case MLX5_CMD_OP_QUERY_XRC_SRQ:
+ 	case MLX5_CMD_OP_QUERY_DCT:
+ 	case MLX5_CMD_OP_QUERY_XRQ:
+ 	case MLX5_CMD_OP_QUERY_XRQ_DC_PARAMS_ENTRY:
+ 	case MLX5_CMD_OP_QUERY_XRQ_ERROR_PARAMS:
+ 	case MLX5_CMD_OP_QUERY_PACKET_REFORMAT_CONTEXT:
+ 		return true;
+ 	default:
+ 		return false;
+ 	}
+ }
+ 
+ static bool devx_is_whitelist_cmd(void *in)
++>>>>>>> 719598c98d19 (IB/mlx5: Update the supported DEVX commands)
+ {
+ 	u16 opcode = MLX5_GET(general_obj_in_cmd_hdr, in, opcode);
+ 
+ 	switch (opcode) {
+ 	case MLX5_CMD_OP_QUERY_HCA_CAP:
++<<<<<<< HEAD
++=======
+ 	case MLX5_CMD_OP_QUERY_HCA_VPORT_CONTEXT:
+ 		return true;
+ 	default:
+ 		return false;
+ 	}
+ }
+ 
+ static int devx_get_uid(struct mlx5_ib_ucontext *c, void *cmd_in)
+ {
+ 	if (devx_is_whitelist_cmd(cmd_in)) {
+ 		struct mlx5_ib_dev *dev;
+ 
+ 		if (c->devx_uid)
+ 			return c->devx_uid;
+ 
+ 		dev = to_mdev(c->ibucontext.device);
+ 		if (dev->devx_whitelist_uid)
+ 			return dev->devx_whitelist_uid;
+ 
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	if (!c->devx_uid)
+ 		return -EINVAL;
+ 
+ 	return c->devx_uid;
+ }
+ static bool devx_is_general_cmd(void *in)
+ {
+ 	u16 opcode = MLX5_GET(general_obj_in_cmd_hdr, in, opcode);
+ 
+ 	if (opcode >= MLX5_CMD_OP_GENERAL_START &&
+ 	    opcode < MLX5_CMD_OP_GENERAL_END)
+ 		return true;
+ 
  	switch (opcode) {
  	case MLX5_CMD_OP_QUERY_HCA_CAP:
+ 	case MLX5_CMD_OP_QUERY_HCA_VPORT_CONTEXT:
++>>>>>>> 719598c98d19 (IB/mlx5: Update the supported DEVX commands)
  	case MLX5_CMD_OP_QUERY_VPORT_STATE:
  	case MLX5_CMD_OP_QUERY_ADAPTER:
  	case MLX5_CMD_OP_QUERY_ISSI:
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
diff --git a/include/linux/mlx5/mlx5_ifc.h b/include/linux/mlx5/mlx5_ifc.h
index 4454a747c745..a6db222490ab 100644
--- a/include/linux/mlx5/mlx5_ifc.h
+++ b/include/linux/mlx5/mlx5_ifc.h
@@ -134,6 +134,9 @@ enum {
 	MLX5_CMD_OP_DESTROY_XRQ                   = 0x718,
 	MLX5_CMD_OP_QUERY_XRQ                     = 0x719,
 	MLX5_CMD_OP_ARM_XRQ                       = 0x71a,
+	MLX5_CMD_OP_QUERY_XRQ_DC_PARAMS_ENTRY     = 0x725,
+	MLX5_CMD_OP_SET_XRQ_DC_PARAMS_ENTRY       = 0x726,
+	MLX5_CMD_OP_QUERY_XRQ_ERROR_PARAMS        = 0x727,
 	MLX5_CMD_OP_QUERY_VPORT_STATE             = 0x750,
 	MLX5_CMD_OP_MODIFY_VPORT_STATE            = 0x751,
 	MLX5_CMD_OP_QUERY_ESW_VPORT_CONTEXT       = 0x752,
@@ -235,6 +238,7 @@ enum {
 	MLX5_CMD_OP_MODIFY_FLOW_TABLE             = 0x93c,
 	MLX5_CMD_OP_ALLOC_PACKET_REFORMAT_CONTEXT = 0x93d,
 	MLX5_CMD_OP_DEALLOC_PACKET_REFORMAT_CONTEXT = 0x93e,
+	MLX5_CMD_OP_QUERY_PACKET_REFORMAT_CONTEXT = 0x93f,
 	MLX5_CMD_OP_ALLOC_MODIFY_HEADER_CONTEXT   = 0x940,
 	MLX5_CMD_OP_DEALLOC_MODIFY_HEADER_CONTEXT = 0x941,
 	MLX5_CMD_OP_FPGA_CREATE_QP                = 0x960,
@@ -245,6 +249,12 @@ enum {
 	MLX5_CMD_OP_MAX
 };
 
+/* Valid range for general commands that don't work over an object */
+enum {
+	MLX5_CMD_OP_GENERAL_START = 0xb00,
+	MLX5_CMD_OP_GENERAL_END = 0xd00,
+};
+
 struct mlx5_ifc_flow_table_fields_supported_bits {
 	u8         outer_dmac[0x1];
 	u8         outer_smac[0x1];
