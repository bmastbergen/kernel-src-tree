bpf: btf: support proper non-jit func info

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Yonghong Song <yhs@fb.com>
commit ba64e7d8525236aa56ab58ba3a3a71615c4ee289
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/ba64e7d8.failed

Commit 838e96904ff3 ("bpf: Introduce bpf_func_info")
added bpf func info support. The userspace is able
to get better ksym's for bpf programs with jit, and
is able to print out func prototypes.

For a program containing func-to-func calls, the existing
implementation returns user specified number of function
calls and BTF types if jit is enabled. If the jit is not
enabled, it only returns the type for the main function.

This is undesirable. Interpreter may still be used
and we should keep feature identical regardless of
whether jit is enabled or not.
This patch fixed this discrepancy.

Fixes: 838e96904ff3 ("bpf: Introduce bpf_func_info")
	Signed-off-by: Yonghong Song <yhs@fb.com>
	Acked-by: Martin KaFai Lau <kafai@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit ba64e7d8525236aa56ab58ba3a3a71615c4ee289)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/bpf.h
#	kernel/bpf/core.c
#	kernel/bpf/syscall.c
#	kernel/bpf/verifier.c
diff --cc include/linux/bpf.h
index 61dff997a78e,e82b7039fc66..000000000000
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@@ -305,6 -317,9 +306,12 @@@ struct bpf_prog_aux 
  	void *security;
  #endif
  	struct bpf_prog_offload *offload;
++<<<<<<< HEAD
++=======
+ 	struct btf *btf;
+ 	struct bpf_func_info *func_info;
+ 	u32 func_info_cnt;
++>>>>>>> ba64e7d85252 (bpf: btf: support proper non-jit func info)
  	union {
  		struct work_struct work;
  		struct rcu_head	rcu;
diff --cc kernel/bpf/core.c
index b3f0a11b622a,002d67c62c8b..000000000000
--- a/kernel/bpf/core.c
+++ b/kernel/bpf/core.c
@@@ -403,6 -408,16 +403,19 @@@ static void bpf_get_prog_name(const str
  
  	sym += snprintf(sym, KSYM_NAME_LEN, "bpf_prog_");
  	sym  = bin2hex(sym, prog->tag, sizeof(prog->tag));
++<<<<<<< HEAD
++=======
+ 
+ 	/* prog->aux->name will be ignored if full btf name is available */
+ 	if (prog->aux->btf) {
+ 		type = btf_type_by_id(prog->aux->btf,
+ 				      prog->aux->func_info[prog->aux->func_idx].type_id);
+ 		func_name = btf_name_by_offset(prog->aux->btf, type->name_off);
+ 		snprintf(sym, (size_t)(end - sym), "_%s", func_name);
+ 		return;
+ 	}
+ 
++>>>>>>> ba64e7d85252 (bpf: btf: support proper non-jit func info)
  	if (prog->aux->name[0])
  		snprintf(sym, (size_t)(end - sym), "_%s", prog->aux->name);
  	else
diff --cc kernel/bpf/syscall.c
index 0226bc9e5288,85cbeec06e50..000000000000
--- a/kernel/bpf/syscall.c
+++ b/kernel/bpf/syscall.c
@@@ -1228,6 -1213,8 +1228,11 @@@ static void __bpf_prog_put(struct bpf_p
  		/* bpf_prog_free_id() must be called first */
  		bpf_prog_free_id(prog, do_idr_lock);
  		bpf_prog_kallsyms_del_all(prog);
++<<<<<<< HEAD
++=======
+ 		btf_put(prog->aux->btf);
+ 		kvfree(prog->aux->func_info);
++>>>>>>> ba64e7d85252 (bpf: btf: support proper non-jit func info)
  
  		call_rcu(&prog->aux->rcu, __bpf_prog_put_rcu);
  	}
@@@ -2227,6 -2219,37 +2232,40 @@@ static int bpf_prog_get_info_by_fd(stru
  		}
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (prog->aux->btf) {
+ 		u32 krec_size = sizeof(struct bpf_func_info);
+ 		u32 ucnt, urec_size;
+ 
+ 		info.btf_id = btf_id(prog->aux->btf);
+ 
+ 		ucnt = info.func_info_cnt;
+ 		info.func_info_cnt = prog->aux->func_info_cnt;
+ 		urec_size = info.func_info_rec_size;
+ 		info.func_info_rec_size = krec_size;
+ 		if (ucnt) {
+ 			/* expect passed-in urec_size is what the kernel expects */
+ 			if (urec_size != info.func_info_rec_size)
+ 				return -EINVAL;
+ 
+ 			if (bpf_dump_raw_ok()) {
+ 				char __user *user_finfo;
+ 
+ 				user_finfo = u64_to_user_ptr(info.func_info);
+ 				ucnt = min_t(u32, info.func_info_cnt, ucnt);
+ 				if (copy_to_user(user_finfo, prog->aux->func_info,
+ 						 krec_size * ucnt))
+ 					return -EFAULT;
+ 			} else {
+ 				info.func_info_cnt = 0;
+ 			}
+ 		}
+ 	} else {
+ 		info.func_info_cnt = 0;
+ 	}
+ 
++>>>>>>> ba64e7d85252 (bpf: btf: support proper non-jit func info)
  done:
  	if (copy_to_user(uinfo, &info, info_len) ||
  	    put_user(info_len, &uattr->info.info_len))
diff --cc kernel/bpf/verifier.c
index 9aed50935989,05d95c0e4a26..000000000000
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@@ -4426,6 -4641,130 +4426,133 @@@ err_free
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ /* The minimum supported BTF func info size */
+ #define MIN_BPF_FUNCINFO_SIZE	8
+ #define MAX_FUNCINFO_REC_SIZE	252
+ 
+ static int check_btf_func(struct bpf_prog *prog, struct bpf_verifier_env *env,
+ 			  union bpf_attr *attr, union bpf_attr __user *uattr)
+ {
+ 	u32 i, nfuncs, urec_size, min_size, prev_offset;
+ 	u32 krec_size = sizeof(struct bpf_func_info);
+ 	struct bpf_func_info *krecord = NULL;
+ 	const struct btf_type *type;
+ 	void __user *urecord;
+ 	struct btf *btf;
+ 	int ret = 0;
+ 
+ 	nfuncs = attr->func_info_cnt;
+ 	if (!nfuncs)
+ 		return 0;
+ 
+ 	if (nfuncs != env->subprog_cnt) {
+ 		verbose(env, "number of funcs in func_info doesn't match number of subprogs\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	urec_size = attr->func_info_rec_size;
+ 	if (urec_size < MIN_BPF_FUNCINFO_SIZE ||
+ 	    urec_size > MAX_FUNCINFO_REC_SIZE ||
+ 	    urec_size % sizeof(u32)) {
+ 		verbose(env, "invalid func info rec size %u\n", urec_size);
+ 		return -EINVAL;
+ 	}
+ 
+ 	btf = btf_get_by_fd(attr->prog_btf_fd);
+ 	if (IS_ERR(btf)) {
+ 		verbose(env, "unable to get btf from fd\n");
+ 		return PTR_ERR(btf);
+ 	}
+ 
+ 	urecord = u64_to_user_ptr(attr->func_info);
+ 	min_size = min_t(u32, krec_size, urec_size);
+ 
+ 	krecord = kvcalloc(nfuncs, krec_size, GFP_KERNEL | __GFP_NOWARN);
+ 	if (!krecord) {
+ 		ret = -ENOMEM;
+ 		goto free_btf;
+ 	}
+ 
+ 	for (i = 0; i < nfuncs; i++) {
+ 		ret = bpf_check_uarg_tail_zero(urecord, krec_size, urec_size);
+ 		if (ret) {
+ 			if (ret == -E2BIG) {
+ 				verbose(env, "nonzero tailing record in func info");
+ 				/* set the size kernel expects so loader can zero
+ 				 * out the rest of the record.
+ 				 */
+ 				if (put_user(min_size, &uattr->func_info_rec_size))
+ 					ret = -EFAULT;
+ 			}
+ 			goto free_btf;
+ 		}
+ 
+ 		if (copy_from_user(&krecord[i], urecord, min_size)) {
+ 			ret = -EFAULT;
+ 			goto free_btf;
+ 		}
+ 
+ 		/* check insn_offset */
+ 		if (i == 0) {
+ 			if (krecord[i].insn_offset) {
+ 				verbose(env,
+ 					"nonzero insn_offset %u for the first func info record",
+ 					krecord[i].insn_offset);
+ 				ret = -EINVAL;
+ 				goto free_btf;
+ 			}
+ 		} else if (krecord[i].insn_offset <= prev_offset) {
+ 			verbose(env,
+ 				"same or smaller insn offset (%u) than previous func info record (%u)",
+ 				krecord[i].insn_offset, prev_offset);
+ 			ret = -EINVAL;
+ 			goto free_btf;
+ 		}
+ 
+ 		if (env->subprog_info[i].start != krecord[i].insn_offset) {
+ 			verbose(env, "func_info BTF section doesn't match subprog layout in BPF program\n");
+ 			ret = -EINVAL;
+ 			goto free_btf;
+ 		}
+ 
+ 		/* check type_id */
+ 		type = btf_type_by_id(btf, krecord[i].type_id);
+ 		if (!type || BTF_INFO_KIND(type->info) != BTF_KIND_FUNC) {
+ 			verbose(env, "invalid type id %d in func info",
+ 				krecord[i].type_id);
+ 			ret = -EINVAL;
+ 			goto free_btf;
+ 		}
+ 
+ 		prev_offset = krecord[i].insn_offset;
+ 		urecord += urec_size;
+ 	}
+ 
+ 	prog->aux->btf = btf;
+ 	prog->aux->func_info = krecord;
+ 	prog->aux->func_info_cnt = nfuncs;
+ 	return 0;
+ 
+ free_btf:
+ 	btf_put(btf);
+ 	kvfree(krecord);
+ 	return ret;
+ }
+ 
+ static void adjust_btf_func(struct bpf_verifier_env *env)
+ {
+ 	int i;
+ 
+ 	if (!env->prog->aux->func_info)
+ 		return;
+ 
+ 	for (i = 0; i < env->subprog_cnt; i++)
+ 		env->prog->aux->func_info[i].insn_offset = env->subprog_info[i].start;
+ }
+ 
++>>>>>>> ba64e7d85252 (bpf: btf: support proper non-jit func info)
  /* check %cur's range satisfies %old's */
  static bool range_within(struct bpf_reg_state *old,
  			 struct bpf_reg_state *cur)
* Unmerged path include/linux/bpf.h
* Unmerged path kernel/bpf/core.c
* Unmerged path kernel/bpf/syscall.c
* Unmerged path kernel/bpf/verifier.c
