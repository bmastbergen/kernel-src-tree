IB/uverbs: Remove the ib_uverbs_attr pointer from each attr

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jason Gunthorpe <jgg@ziepe.ca>
commit 6a1f444fefeba392d1232b408aaf5902e33e0982
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/6a1f444f.failed

Memory in the bundle is valuable, do not waste it holding an 8 byte
pointer for the rare case of writing to a PTR_OUT. We can compute the
pointer by storing a small 1 byte array offset and the base address of the
uattr memory in the bundle private memory.

This also means we can access the kernel's copy of the ib_uverbs_attr, so
drop the copy of flags as well.

Since the uattr base should be private bundle information this also
de-inlines the already too big uverbs_copy_to inline and moves
create_udata into uverbs_ioctl.c so they can see the private struct
definition.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
	Reviewed-by: Leon Romanovsky <leonro@mellanox.com>
(cherry picked from commit 6a1f444fefeba392d1232b408aaf5902e33e0982)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_ioctl.c
#	drivers/infiniband/core/uverbs_std_types.c
#	include/rdma/uverbs_ioctl.h
diff --cc drivers/infiniband/core/uverbs_ioctl.c
index 03065bad8dae,f355e938a0b1..000000000000
--- a/drivers/infiniband/core/uverbs_ioctl.c
+++ b/drivers/infiniband/core/uverbs_ioctl.c
@@@ -114,11 -123,10 +113,11 @@@ static int uverbs_process_attr(struct i
  		    uattr->attr_data.reserved)
  			return -EINVAL;
  
+ 		e->ptr_attr.uattr_idx = uattr - pbundle->uattrs;
  		e->ptr_attr.len = uattr->len;
- 		e->ptr_attr.flags = uattr->flags;
  
 -		if (val_spec->alloc_and_copy && !uverbs_attr_ptr_is_inline(e)) {
 +		if (val_spec->flags & UVERBS_ATTR_SPEC_F_ALLOC_AND_COPY &&
 +		    !uverbs_attr_ptr_is_inline(e)) {
  			void *p;
  
  			p = kvmalloc(uattr->len, GFP_KERNEL);
@@@ -162,11 -176,11 +161,11 @@@
  		if (IS_ERR(o_attr->uobject))
  			return PTR_ERR(o_attr->uobject);
  
 -		if (spec->u.obj.access == UVERBS_ACCESS_NEW) {
 -			s64 id = o_attr->uobject->id;
 +		if (spec->obj.access == UVERBS_ACCESS_NEW) {
 +			u64 id = o_attr->uobject->id;
  
  			/* Copy the allocated id to the user-space */
- 			if (put_user(id, &e->uattr->data)) {
+ 			if (put_user(id, &uattr_ptr->data)) {
  				uverbs_finalize_object(o_attr->uobject,
  						       UVERBS_ACCESS_NEW,
  						       false);
@@@ -491,3 -510,116 +490,119 @@@ out
  
  	return err;
  }
++<<<<<<< HEAD
++=======
+ 
+ int uverbs_get_flags64(u64 *to, const struct uverbs_attr_bundle *attrs_bundle,
+ 		       size_t idx, u64 allowed_bits)
+ {
+ 	const struct uverbs_attr *attr;
+ 	u64 flags;
+ 
+ 	attr = uverbs_attr_get(attrs_bundle, idx);
+ 	/* Missing attribute means 0 flags */
+ 	if (IS_ERR(attr)) {
+ 		*to = 0;
+ 		return 0;
+ 	}
+ 
+ 	/*
+ 	 * New userspace code should use 8 bytes to pass flags, but we
+ 	 * transparently support old userspaces that were using 4 bytes as
+ 	 * well.
+ 	 */
+ 	if (attr->ptr_attr.len == 8)
+ 		flags = attr->ptr_attr.data;
+ 	else if (attr->ptr_attr.len == 4)
+ 		flags = *(u32 *)&attr->ptr_attr.data;
+ 	else
+ 		return -EINVAL;
+ 
+ 	if (flags & ~allowed_bits)
+ 		return -EINVAL;
+ 
+ 	*to = flags;
+ 	return 0;
+ }
+ EXPORT_SYMBOL(uverbs_get_flags64);
+ 
+ int uverbs_get_flags32(u32 *to, const struct uverbs_attr_bundle *attrs_bundle,
+ 		       size_t idx, u64 allowed_bits)
+ {
+ 	u64 flags;
+ 	int ret;
+ 
+ 	ret = uverbs_get_flags64(&flags, attrs_bundle, idx, allowed_bits);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (flags > U32_MAX)
+ 		return -EINVAL;
+ 	*to = flags;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(uverbs_get_flags32);
+ 
+ /*
+  * This is for ease of conversion. The purpose is to convert all drivers to
+  * use uverbs_attr_bundle instead of ib_udata.  Assume attr == 0 is input and
+  * attr == 1 is output.
+  */
+ void create_udata(struct uverbs_attr_bundle *bundle, struct ib_udata *udata)
+ {
+ 	struct bundle_priv *pbundle =
+ 		container_of(bundle, struct bundle_priv, bundle);
+ 	const struct uverbs_attr *uhw_in =
+ 		uverbs_attr_get(bundle, UVERBS_ATTR_UHW_IN);
+ 	const struct uverbs_attr *uhw_out =
+ 		uverbs_attr_get(bundle, UVERBS_ATTR_UHW_OUT);
+ 
+ 	if (!IS_ERR(uhw_in)) {
+ 		udata->inlen = uhw_in->ptr_attr.len;
+ 		if (uverbs_attr_ptr_is_inline(uhw_in))
+ 			udata->inbuf =
+ 				&pbundle->user_attrs[uhw_in->ptr_attr.uattr_idx]
+ 					 .data;
+ 		else
+ 			udata->inbuf = u64_to_user_ptr(uhw_in->ptr_attr.data);
+ 	} else {
+ 		udata->inbuf = NULL;
+ 		udata->inlen = 0;
+ 	}
+ 
+ 	if (!IS_ERR(uhw_out)) {
+ 		udata->outbuf = u64_to_user_ptr(uhw_out->ptr_attr.data);
+ 		udata->outlen = uhw_out->ptr_attr.len;
+ 	} else {
+ 		udata->outbuf = NULL;
+ 		udata->outlen = 0;
+ 	}
+ }
+ 
+ int uverbs_copy_to(const struct uverbs_attr_bundle *bundle, size_t idx,
+ 		   const void *from, size_t size)
+ {
+ 	struct bundle_priv *pbundle =
+ 		container_of(bundle, struct bundle_priv, bundle);
+ 	const struct uverbs_attr *attr = uverbs_attr_get(bundle, idx);
+ 	u16 flags;
+ 	size_t min_size;
+ 
+ 	if (IS_ERR(attr))
+ 		return PTR_ERR(attr);
+ 
+ 	min_size = min_t(size_t, attr->ptr_attr.len, size);
+ 	if (copy_to_user(u64_to_user_ptr(attr->ptr_attr.data), from, min_size))
+ 		return -EFAULT;
+ 
+ 	flags = pbundle->uattrs[attr->ptr_attr.uattr_idx].flags |
+ 		UVERBS_ATTR_F_VALID_OUTPUT;
+ 	if (put_user(flags,
+ 		     &pbundle->user_attrs[attr->ptr_attr.uattr_idx].flags))
+ 		return -EFAULT;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(uverbs_copy_to);
++>>>>>>> 6a1f444fefeb (IB/uverbs: Remove the ib_uverbs_attr pointer from each attr)
diff --cc drivers/infiniband/core/uverbs_std_types.c
index 06085446ffc0,203cc96ac6f5..000000000000
--- a/drivers/infiniband/core/uverbs_std_types.c
+++ b/drivers/infiniband/core/uverbs_std_types.c
@@@ -204,110 -215,70 +204,120 @@@ int uverbs_destroy_def_handler(struct i
  {
  	return 0;
  }
 -EXPORT_SYMBOL(uverbs_destroy_def_handler);
  
 +/*
 + * This spec is used in order to pass information to the hardware driver in a
 + * legacy way. Every verb that could get driver specific data should get this
 + * spec.
 + */
 +const struct uverbs_attr_def uverbs_uhw_compat_in =
 +	UVERBS_ATTR_PTR_IN_SZ(UVERBS_ATTR_UHW_IN, UVERBS_ATTR_MIN_SIZE(0),
 +			      UA_FLAGS(UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO));
 +const struct uverbs_attr_def uverbs_uhw_compat_out =
 +	UVERBS_ATTR_PTR_OUT_SZ(UVERBS_ATTR_UHW_OUT, UVERBS_ATTR_MIN_SIZE(0),
 +			       UA_FLAGS(UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO));
 +
++<<<<<<< HEAD
 +void create_udata(struct uverbs_attr_bundle *ctx, struct ib_udata *udata)
 +{
 +	/*
 +	 * This is for ease of conversion. The purpose is to convert all drivers
 +	 * to use uverbs_attr_bundle instead of ib_udata.
 +	 * Assume attr == 0 is input and attr == 1 is output.
 +	 */
 +	const struct uverbs_attr *uhw_in =
 +		uverbs_attr_get(ctx, UVERBS_ATTR_UHW_IN);
 +	const struct uverbs_attr *uhw_out =
 +		uverbs_attr_get(ctx, UVERBS_ATTR_UHW_OUT);
 +
 +	if (!IS_ERR(uhw_in)) {
 +		udata->inlen = uhw_in->ptr_attr.len;
 +		if (uverbs_attr_ptr_is_inline(uhw_in))
 +			udata->inbuf = &uhw_in->uattr->data;
 +		else
 +			udata->inbuf = u64_to_user_ptr(uhw_in->ptr_attr.data);
 +	} else {
 +		udata->inbuf = NULL;
 +		udata->inlen = 0;
 +	}
 +
 +	if (!IS_ERR(uhw_out)) {
 +		udata->outbuf = u64_to_user_ptr(uhw_out->ptr_attr.data);
 +		udata->outlen = uhw_out->ptr_attr.len;
 +	} else {
 +		udata->outbuf = NULL;
 +		udata->outlen = 0;
 +	}
 +}
 +
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_COMP_CHANNEL,
 +			    &UVERBS_TYPE_ALLOC_FD(0,
 +						  sizeof(struct ib_uverbs_completion_event_file),
 +						  uverbs_hot_unplug_completion_event_file,
 +						  &uverbs_event_fops,
 +						  "[infinibandevent]", O_RDONLY));
++=======
+ DECLARE_UVERBS_NAMED_OBJECT(
+ 	UVERBS_OBJECT_COMP_CHANNEL,
+ 	UVERBS_TYPE_ALLOC_FD(sizeof(struct ib_uverbs_completion_event_file),
+ 			     uverbs_hot_unplug_completion_event_file,
+ 			     &uverbs_event_fops,
+ 			     "[infinibandevent]",
+ 			     O_RDONLY));
++>>>>>>> 6a1f444fefeb (IB/uverbs: Remove the ib_uverbs_attr pointer from each attr)
  
 -DECLARE_UVERBS_NAMED_OBJECT(
 -	UVERBS_OBJECT_QP,
 -	UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uqp_object), uverbs_free_qp));
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_QP,
 +			    &UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uqp_object), 0,
 +						      uverbs_free_qp));
  
  DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_MW,
 -			    UVERBS_TYPE_ALLOC_IDR(uverbs_free_mw));
 +			    &UVERBS_TYPE_ALLOC_IDR(0, uverbs_free_mw));
  
 -DECLARE_UVERBS_NAMED_OBJECT(
 -	UVERBS_OBJECT_SRQ,
 -	UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_usrq_object),
 -				 uverbs_free_srq));
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_SRQ,
 +			    &UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_usrq_object), 0,
 +						      uverbs_free_srq));
  
  DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_AH,
 -			    UVERBS_TYPE_ALLOC_IDR(uverbs_free_ah));
 +			    &UVERBS_TYPE_ALLOC_IDR(0, uverbs_free_ah));
  
 -DECLARE_UVERBS_NAMED_OBJECT(
 -	UVERBS_OBJECT_FLOW,
 -	UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uflow_object),
 -				 uverbs_free_flow));
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_FLOW,
 +			    &UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uflow_object),
 +						      0, uverbs_free_flow));
  
 -DECLARE_UVERBS_NAMED_OBJECT(
 -	UVERBS_OBJECT_WQ,
 -	UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uwq_object), uverbs_free_wq));
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_WQ,
 +			    &UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uwq_object), 0,
 +						      uverbs_free_wq));
  
  DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_RWQ_IND_TBL,
 -			    UVERBS_TYPE_ALLOC_IDR(uverbs_free_rwq_ind_tbl));
 +			    &UVERBS_TYPE_ALLOC_IDR(0, uverbs_free_rwq_ind_tbl));
  
 -DECLARE_UVERBS_NAMED_OBJECT(
 -	UVERBS_OBJECT_XRCD,
 -	UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uxrcd_object),
 -				 uverbs_free_xrcd));
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_XRCD,
 +			    &UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uxrcd_object), 0,
 +						      uverbs_free_xrcd));
  
  DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_PD,
 -			    UVERBS_TYPE_ALLOC_IDR(uverbs_free_pd));
 -
 -DECLARE_UVERBS_GLOBAL_METHODS(UVERBS_OBJECT_DEVICE);
 -
 -DECLARE_UVERBS_OBJECT_TREE(uverbs_default_objects,
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_DEVICE),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_PD),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_MR),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_COMP_CHANNEL),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_CQ),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_QP),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_AH),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_MW),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_SRQ),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_FLOW),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_WQ),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_RWQ_IND_TBL),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_XRCD),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_FLOW_ACTION),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_DM),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_COUNTERS));
 +			    /* 2 is used in order to free the PD after MRs */
 +			    &UVERBS_TYPE_ALLOC_IDR(2, uverbs_free_pd));
 +
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_DEVICE, NULL);
 +
 +static DECLARE_UVERBS_OBJECT_TREE(uverbs_default_objects,
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_DEVICE),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_PD),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_MR),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_COMP_CHANNEL),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_CQ),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_QP),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_AH),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_MW),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_SRQ),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_FLOW),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_WQ),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_RWQ_IND_TBL),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_XRCD),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_FLOW_ACTION),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_DM),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_COUNTERS));
  
  const struct uverbs_object_tree_def *uverbs_default_get_objects(void)
  {
diff --cc include/rdma/uverbs_ioctl.h
index 90a4947ff548,ecf028446cdf..000000000000
--- a/include/rdma/uverbs_ioctl.h
+++ b/include/rdma/uverbs_ioctl.h
@@@ -547,6 -644,33 +520,36 @@@ static inline int _uverbs_copy_from_or_
  #define uverbs_copy_from_or_zero(to, attrs_bundle, idx)			      \
  	_uverbs_copy_from_or_zero(to, attrs_bundle, idx, sizeof(*to))
  
++<<<<<<< HEAD
++=======
+ #if IS_ENABLED(CONFIG_INFINIBAND_USER_ACCESS)
+ int uverbs_get_flags64(u64 *to, const struct uverbs_attr_bundle *attrs_bundle,
+ 		       size_t idx, u64 allowed_bits);
+ int uverbs_get_flags32(u32 *to, const struct uverbs_attr_bundle *attrs_bundle,
+ 		       size_t idx, u64 allowed_bits);
+ int uverbs_copy_to(const struct uverbs_attr_bundle *attrs_bundle, size_t idx,
+ 		   const void *from, size_t size);
+ #else
+ static inline int
+ uverbs_get_flags64(u64 *to, const struct uverbs_attr_bundle *attrs_bundle,
+ 		   size_t idx, u64 allowed_bits)
+ {
+ 	return -EINVAL;
+ }
+ static inline int
+ uverbs_get_flags32(u32 *to, const struct uverbs_attr_bundle *attrs_bundle,
+ 		   size_t idx, u64 allowed_bits)
+ {
+ 	return -EINVAL;
+ }
+ static inline int uverbs_copy_to(const struct uverbs_attr_bundle *attrs_bundle,
+ 				 size_t idx, const void *from, size_t size)
+ {
+ 	return -EINVAL;
+ }
+ #endif
+ 
++>>>>>>> 6a1f444fefeb (IB/uverbs: Remove the ib_uverbs_attr pointer from each attr)
  /* =================================================
   *	 Definitions -> Specs infrastructure
   * =================================================
* Unmerged path drivers/infiniband/core/uverbs_ioctl.c
* Unmerged path drivers/infiniband/core/uverbs_std_types.c
* Unmerged path include/rdma/uverbs_ioctl.h
