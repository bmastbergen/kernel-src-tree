drm/i915: Really calculate the cursor ddb based on the highest enabled wm level

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit 6086e47b35e1a25df31842a49971c277cd84af8f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/6086e47b.failed

I added the loop but neglected to actually pass the level to the
function. So we were just looping 8 times calculating the exact
same thing every time.

Fixes: df331de3f8aa ("drm/i915: Allocate enough DDB for the cursor")
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190321175128.32178-1-ville.syrjala@linux.intel.com
	Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
(cherry picked from commit 6086e47b35e1a25df31842a49971c277cd84af8f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_pm.c
diff --cc drivers/gpu/drm/i915/intel_pm.c
index a1b763e0c3a9,eaf0793ebf60..000000000000
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@@ -3854,19 -3896,71 +3854,38 @@@ skl_ddb_get_pipe_allocation_limits(stru
  		return;
  	}
  
 -	/*
 -	 * Watermark/ddb requirement highly depends upon width of the
 -	 * framebuffer, So instead of allocating DDB equally among pipes
 -	 * distribute DDB based on resolution/width of the display.
 -	 */
 -	for_each_new_crtc_in_state(state, crtc, crtc_state, i) {
 -		const struct drm_display_mode *adjusted_mode;
 -		int hdisplay, vdisplay;
 -		enum pipe pipe;
 -
 -		if (!crtc_state->enable)
 -			continue;
 -
 -		pipe = to_intel_crtc(crtc)->pipe;
 -		adjusted_mode = &crtc_state->adjusted_mode;
 -		drm_mode_get_hv_timing(adjusted_mode, &hdisplay, &vdisplay);
 -		total_width += hdisplay;
 -
 -		if (pipe < for_pipe)
 -			width_before_pipe += hdisplay;
 -		else if (pipe == for_pipe)
 -			pipe_width = hdisplay;
 -	}
 -
 -	alloc->start = ddb_size * width_before_pipe / total_width;
 -	alloc->end = ddb_size * (width_before_pipe + pipe_width) / total_width;
 +	nth_active_pipe = hweight32(intel_state->active_crtcs &
 +				    (drm_crtc_mask(for_crtc) - 1));
 +	pipe_size = ddb_size / hweight32(intel_state->active_crtcs);
 +	alloc->start = nth_active_pipe * ddb_size / *num_active;
 +	alloc->end = alloc->start + pipe_size;
  }
  
 -static int skl_compute_wm_params(const struct intel_crtc_state *crtc_state,
 -				 int width, const struct drm_format_info *format,
 -				 u64 modifier, unsigned int rotation,
 -				 u32 plane_pixel_rate, struct skl_wm_params *wp,
 -				 int color_plane);
 -static void skl_compute_plane_wm(const struct intel_crtc_state *cstate,
 -				 int level,
 -				 const struct skl_wm_params *wp,
 -				 const struct skl_wm_level *result_prev,
 -				 struct skl_wm_level *result /* out */);
 -
 -static unsigned int
 -skl_cursor_allocation(const struct intel_crtc_state *crtc_state,
 -		      int num_active)
 +static unsigned int skl_cursor_allocation(int num_active)
  {
 -	struct drm_i915_private *dev_priv = to_i915(crtc_state->base.crtc->dev);
 -	int level, max_level = ilk_wm_max_level(dev_priv);
 -	struct skl_wm_level wm = {};
 -	int ret, min_ddb_alloc = 0;
 -	struct skl_wm_params wp;
 +	if (num_active == 1)
 +		return 32;
  
++<<<<<<< HEAD
 +	return 8;
++=======
+ 	ret = skl_compute_wm_params(crtc_state, 256,
+ 				    drm_format_info(DRM_FORMAT_ARGB8888),
+ 				    DRM_FORMAT_MOD_LINEAR,
+ 				    DRM_MODE_ROTATE_0,
+ 				    crtc_state->pixel_rate, &wp, 0);
+ 	WARN_ON(ret);
+ 
+ 	for (level = 0; level <= max_level; level++) {
+ 		skl_compute_plane_wm(crtc_state, level, &wp, &wm, &wm);
+ 		if (wm.min_ddb_alloc == U16_MAX)
+ 			break;
+ 
+ 		min_ddb_alloc = wm.min_ddb_alloc;
+ 	}
+ 
+ 	return max(num_active == 1 ? 32 : 8, min_ddb_alloc);
++>>>>>>> 6086e47b35e1 (drm/i915: Really calculate the cursor ddb based on the highest enabled wm level)
  }
  
  static void skl_ddb_entry_init_from_hw(struct drm_i915_private *dev_priv,
* Unmerged path drivers/gpu/drm/i915/intel_pm.c
