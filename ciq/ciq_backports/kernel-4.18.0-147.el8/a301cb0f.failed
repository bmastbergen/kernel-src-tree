drm/i915: Keep plane watermarks enabled more aggressively

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit a301cb0fca2d4c5a615d5dac1a3d80baa99518ac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/a301cb0f.failed

Currently we disable all the watermarks above the selected max
level for every plane. That would mean that the cursor's watermarks
may also get modified when another plane causes the selected
max watermark level to change. That is not so great as we would
like to keep the cursor as indepenedent as possible to avoid
having to throttle it in resposne to other plane activity.

To avoid that let's keep the watermarks enabled even for levels
above the max selected watermark level, iff the plane has enough
ddb for that particular level. This way the cursor's enabled
watermarks only depend on the cursor itself. This is safe because
the hardware will never choose to use a watermark level unless
all enabled planes have also enabled that level.

	Cc: Neel Desai <neel.desai@intel.com>
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190312205844.6339-7-ville.syrjala@linux.intel.com
	Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
(cherry picked from commit a301cb0fca2d4c5a615d5dac1a3d80baa99518ac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_pm.c
diff --cc drivers/gpu/drm/i915/intel_pm.c
index a1b763e0c3a9,e7bc38fc4f9d..000000000000
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@@ -4358,39 -4479,73 +4358,89 @@@ skl_allocate_pipe_ddb(struct intel_crtc
  		if (plane_id == PLANE_CURSOR)
  			continue;
  
 -		plane_alloc = &cstate->wm.skl.plane_ddb_y[plane_id];
 -		uv_plane_alloc = &cstate->wm.skl.plane_ddb_uv[plane_id];
 +		data_rate = plane_data_rate[plane_id];
  
 -		/* Gen11+ uses a separate plane for UV watermarks */
 -		WARN_ON(INTEL_GEN(dev_priv) >= 11 && uv_total[plane_id]);
 +		/*
 +		 * allocation for (packed formats) or (uv-plane part of planar format):
 +		 * promote the expression to 64 bits to avoid overflowing, the
 +		 * result is < available as data_rate / total_data_rate < 1
 +		 */
 +		plane_blocks = minimum[plane_id];
 +		plane_blocks += div_u64((uint64_t)alloc_size * data_rate,
 +					total_data_rate);
  
  		/* Leave disabled planes at (0,0) */
 -		if (total[plane_id]) {
 -			plane_alloc->start = start;
 -			start += total[plane_id];
 -			plane_alloc->end = start;
 +		if (data_rate) {
 +			ddb->plane[pipe][plane_id].start = start;
 +			ddb->plane[pipe][plane_id].end = start + plane_blocks;
  		}
  
 -		if (uv_total[plane_id]) {
 -			uv_plane_alloc->start = start;
 -			start += uv_total[plane_id];
 -			uv_plane_alloc->end = start;
 +		start += plane_blocks;
 +
 +		/* Allocate DDB for UV plane for planar format/NV12 */
 +		uv_data_rate = uv_plane_data_rate[plane_id];
 +
 +		uv_plane_blocks = uv_minimum[plane_id];
 +		uv_plane_blocks += div_u64((uint64_t)alloc_size * uv_data_rate,
 +					   total_data_rate);
 +
 +		if (uv_data_rate) {
 +			ddb->uv_plane[pipe][plane_id].start = start;
 +			ddb->uv_plane[pipe][plane_id].end =
 +				start + uv_plane_blocks;
  		}
 -	}
  
++<<<<<<< HEAD
 +		start += uv_plane_blocks;
++=======
+ 	/*
+ 	 * When we calculated watermark values we didn't know how high
+ 	 * of a level we'd actually be able to hit, so we just marked
+ 	 * all levels as "enabled."  Go back now and disable the ones
+ 	 * that aren't actually possible.
+ 	 */
+ 	for (level++; level <= ilk_wm_max_level(dev_priv); level++) {
+ 		for_each_plane_id_on_crtc(intel_crtc, plane_id) {
+ 			wm = &cstate->wm.skl.optimal.planes[plane_id];
+ 
+ 			/*
+ 			 * We only disable the watermarks for each plane if
+ 			 * they exceed the ddb allocation of said plane. This
+ 			 * is done so that we don't end up touching cursor
+ 			 * watermarks needlessly when some other plane reduces
+ 			 * our max possible watermark level.
+ 			 *
+ 			 * Bspec has this to say about the PLANE_WM enable bit:
+ 			 * "All the watermarks at this level for all enabled
+ 			 *  planes must be enabled before the level will be used."
+ 			 * So this is actually safe to do.
+ 			 */
+ 			if (wm->wm[level].min_ddb_alloc > total[plane_id] ||
+ 			    wm->uv_wm[level].min_ddb_alloc > uv_total[plane_id])
+ 				memset(&wm->wm[level], 0, sizeof(wm->wm[level]));
+ 
+ 			/*
+ 			 * Wa_1408961008:icl
+ 			 * Underruns with WM1+ disabled
+ 			 */
+ 			if (IS_ICELAKE(dev_priv) &&
+ 			    level == 1 && wm->wm[0].plane_en) {
+ 				wm->wm[level].plane_res_b = wm->wm[0].plane_res_b;
+ 				wm->wm[level].plane_res_l = wm->wm[0].plane_res_l;
+ 				wm->wm[level].ignore_lines = wm->wm[0].ignore_lines;
+ 			}
+ 		}
+ 	}
+ 
+ 	/*
+ 	 * Go back and disable the transition watermark if it turns out we
+ 	 * don't have enough DDB blocks for it.
+ 	 */
+ 	for_each_plane_id_on_crtc(intel_crtc, plane_id) {
+ 		wm = &cstate->wm.skl.optimal.planes[plane_id];
+ 		if (wm->trans_wm.plane_res_b >= total[plane_id])
+ 			memset(&wm->trans_wm, 0, sizeof(wm->trans_wm));
++>>>>>>> a301cb0fca2d (drm/i915: Keep plane watermarks enabled more aggressively)
  	}
  
  	return 0;
* Unmerged path drivers/gpu/drm/i915/intel_pm.c
