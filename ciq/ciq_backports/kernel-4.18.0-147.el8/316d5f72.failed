net/mlx5e: Always query offloaded tc peer rule counter

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Roi Dayan <roid@mellanox.com>
commit 316d5f72b4c1d4122f83cccbc9002e7b13660077
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/316d5f72.failed

Under multipath when encap rules are duplicated to HW in the driver,
it's possible for one flow to be currently un-offloaded (e.g. lack of
next-hop route or neigh entry) while the other flow is offloaded. As
such, we move to query the counters of both flows at all times.

	Signed-off-by: Roi Dayan <roid@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 316d5f72b4c1d4122f83cccbc9002e7b13660077)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 06543506a2d4,c44cb5083d55..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -2879,30 -3070,57 +2879,59 @@@ int mlx5e_delete_flower(struct mlx5e_pr
  	return 0;
  }
  
 -int mlx5e_stats_flower(struct net_device *dev, struct mlx5e_priv *priv,
 +int mlx5e_stats_flower(struct mlx5e_priv *priv,
  		       struct tc_cls_flower_offload *f, int flags)
  {
 -	struct mlx5_devcom *devcom = priv->mdev->priv.devcom;
 -	struct rhashtable *tc_ht = get_tc_ht(priv, flags);
 -	struct mlx5_eswitch *peer_esw;
 +	struct rhashtable *tc_ht = get_tc_ht(priv);
  	struct mlx5e_tc_flow *flow;
  	struct mlx5_fc *counter;
- 	u64 bytes;
- 	u64 packets;
- 	u64 lastuse;
+ 	u64 lastuse = 0;
+ 	u64 packets = 0;
+ 	u64 bytes = 0;
  
  	flow = rhashtable_lookup_fast(tc_ht, &f->cookie, tc_ht_params);
  	if (!flow || !same_flow_direction(flow, flags))
  		return -EINVAL;
  
- 	if (!(flow->flags & MLX5E_TC_FLOW_OFFLOADED))
- 		return 0;
- 
- 	counter = mlx5e_tc_get_counter(flow);
- 	if (!counter)
- 		return 0;
+ 	if (flow->flags & MLX5E_TC_FLOW_OFFLOADED) {
+ 		counter = mlx5e_tc_get_counter(flow);
+ 		if (!counter)
+ 			return 0;
  
- 	mlx5_fc_query_cached(counter, &bytes, &packets, &lastuse);
+ 		mlx5_fc_query_cached(counter, &bytes, &packets, &lastuse);
+ 	}
  
++<<<<<<< HEAD
 +	tcf_exts_stats_update(f->exts, bytes, packets, lastuse);
++=======
+ 	/* Under multipath it's possible for one rule to be currently
+ 	 * un-offloaded while the other rule is offloaded.
+ 	 */
+ 	peer_esw = mlx5_devcom_get_peer_data(devcom, MLX5_DEVCOM_ESW_OFFLOADS);
+ 	if (!peer_esw)
+ 		goto out;
+ 
+ 	if ((flow->flags & MLX5E_TC_FLOW_DUP) &&
+ 	    (flow->peer_flow->flags & MLX5E_TC_FLOW_OFFLOADED)) {
+ 		u64 bytes2;
+ 		u64 packets2;
+ 		u64 lastuse2;
+ 
+ 		counter = mlx5e_tc_get_counter(flow->peer_flow);
+ 		if (!counter)
+ 			goto no_peer_counter;
+ 		mlx5_fc_query_cached(counter, &bytes2, &packets2, &lastuse2);
+ 
+ 		bytes += bytes2;
+ 		packets += packets2;
+ 		lastuse = max_t(u64, lastuse, lastuse2);
+ 	}
+ 
+ no_peer_counter:
+ 	mlx5_devcom_release_peer_data(devcom, MLX5_DEVCOM_ESW_OFFLOADS);
+ out:
+ 	flow_stats_update(&f->stats, bytes, packets, lastuse);
++>>>>>>> 316d5f72b4c1 (net/mlx5e: Always query offloaded tc peer rule counter)
  
  	return 0;
  }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
