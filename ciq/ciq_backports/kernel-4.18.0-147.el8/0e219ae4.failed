net: use indirect calls helpers for L3 handler hooks

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
Rebuild_CHGLOG: - [net] use indirect calls helpers for L3 handler hooks (Paolo Abeni) [1700747]
Rebuild_FUZZ: 94.95%
commit-author Paolo Abeni <pabeni@redhat.com>
commit 0e219ae48c3bbf382ef96adf3825457315728c03
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/0e219ae4.failed

So that we avoid another indirect call per RX packet in the common
case.

	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0e219ae48c3bbf382ef96adf3825457315728c03)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/ip_input.c
diff --cc net/ipv4/ip_input.c
index 7582713dd18f,8d78de4b0304..000000000000
--- a/net/ipv4/ip_input.c
+++ b/net/ipv4/ip_input.c
@@@ -188,6 -189,47 +189,50 @@@ bool ip_call_ra_chain(struct sk_buff *s
  	return false;
  }
  
++<<<<<<< HEAD
++=======
+ INDIRECT_CALLABLE_DECLARE(int udp_rcv(struct sk_buff *));
+ INDIRECT_CALLABLE_DECLARE(int tcp_v4_rcv(struct sk_buff *));
+ void ip_protocol_deliver_rcu(struct net *net, struct sk_buff *skb, int protocol)
+ {
+ 	const struct net_protocol *ipprot;
+ 	int raw, ret;
+ 
+ resubmit:
+ 	raw = raw_local_deliver(skb, protocol);
+ 
+ 	ipprot = rcu_dereference(inet_protos[protocol]);
+ 	if (ipprot) {
+ 		if (!ipprot->no_policy) {
+ 			if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {
+ 				kfree_skb(skb);
+ 				return;
+ 			}
+ 			nf_reset(skb);
+ 		}
+ 		ret = INDIRECT_CALL_2(ipprot->handler, tcp_v4_rcv, udp_rcv,
+ 				      skb);
+ 		if (ret < 0) {
+ 			protocol = -ret;
+ 			goto resubmit;
+ 		}
+ 		__IP_INC_STATS(net, IPSTATS_MIB_INDELIVERS);
+ 	} else {
+ 		if (!raw) {
+ 			if (xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {
+ 				__IP_INC_STATS(net, IPSTATS_MIB_INUNKNOWNPROTOS);
+ 				icmp_send(skb, ICMP_DEST_UNREACH,
+ 					  ICMP_PROT_UNREACH, 0);
+ 			}
+ 			kfree_skb(skb);
+ 		} else {
+ 			__IP_INC_STATS(net, IPSTATS_MIB_INDELIVERS);
+ 			consume_skb(skb);
+ 		}
+ 	}
+ }
+ 
++>>>>>>> 0e219ae48c3b (net: use indirect calls helpers for L3 handler hooks)
  static int ip_local_deliver_finish(struct net *net, struct sock *sk, struct sk_buff *skb)
  {
  	__skb_pull(skb, skb_network_header_len(skb));
* Unmerged path net/ipv4/ip_input.c
diff --git a/net/ipv6/ip6_input.c b/net/ipv6/ip6_input.c
index f08d34491ece..0d3f5da3ae01 100644
--- a/net/ipv6/ip6_input.c
+++ b/net/ipv6/ip6_input.c
@@ -29,6 +29,7 @@
 #include <linux/icmpv6.h>
 #include <linux/mroute6.h>
 #include <linux/slab.h>
+#include <linux/indirect_call_wrapper.h>
 
 #include <linux/netfilter.h>
 #include <linux/netfilter_ipv6.h>
@@ -216,6 +217,9 @@ int ipv6_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt
 	return NET_RX_DROP;
 }
 
+INDIRECT_CALLABLE_DECLARE(int udpv6_rcv(struct sk_buff *));
+INDIRECT_CALLABLE_DECLARE(int tcp_v6_rcv(struct sk_buff *));
+
 /*
  *	Deliver the packet to the host
  */
@@ -281,7 +285,8 @@ static int ip6_input_finish(struct net *net, struct sock *sk, struct sk_buff *sk
 		    !xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))
 			goto discard;
 
-		ret = ipprot->handler(skb);
+		ret = INDIRECT_CALL_2(ipprot->handler, tcp_v6_rcv, udpv6_rcv,
+				      skb);
 		if (ret > 0) {
 			if (ipprot->flags & INET6_PROTO_FINAL) {
 				/* Not an extension header, most likely UDP
diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c
index 03e6b7a2bc53..be49da4021a5 100644
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@ -43,6 +43,7 @@
 #include <linux/ipv6.h>
 #include <linux/icmpv6.h>
 #include <linux/random.h>
+#include <linux/indirect_call_wrapper.h>
 
 #include <net/tcp.h>
 #include <net/ndisc.h>
@@ -1424,7 +1425,7 @@ static void tcp_v6_fill_cb(struct sk_buff *skb, const struct ipv6hdr *hdr,
 			skb->tstamp || skb_hwtstamps(skb)->hwtstamp;
 }
 
-static int tcp_v6_rcv(struct sk_buff *skb)
+INDIRECT_CALLABLE_SCOPE int tcp_v6_rcv(struct sk_buff *skb)
 {
 	int sdif = inet6_sdif(skb);
 	const struct tcphdr *th;
diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c
index e2839a12108d..3bee9466846e 100644
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@ -36,6 +36,7 @@
 #include <linux/skbuff.h>
 #include <linux/slab.h>
 #include <linux/uaccess.h>
+#include <linux/indirect_call_wrapper.h>
 
 #include <net/addrconf.h>
 #include <net/ndisc.h>
@@ -941,7 +942,7 @@ static void udp_v6_early_demux(struct sk_buff *skb)
 	}
 }
 
-static __inline__ int udpv6_rcv(struct sk_buff *skb)
+INDIRECT_CALLABLE_SCOPE int udpv6_rcv(struct sk_buff *skb)
 {
 	return __udp6_lib_rcv(skb, &udp_table, IPPROTO_UDP);
 }
