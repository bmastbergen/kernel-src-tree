drm/i915: Allocate enough DDB for the cursor

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit df331de3f8aac1a8080510d883fa40555809cddf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/df331de3.failed

Currently we just assume that 32 or 8 blocks of ddb is sufficient
for the cursor. The 32 might be, but the 8 is certainly not. The
minimum we need is at least what level 0 watermarks need, but that
is a bit restrictive, so instead let's calculate what level 7
would need for a 256x256 cursor. We'll use that to determine the
fixed ddb allocation for the cursor. This way the cursor will never
be responsible for missing out on deeper power saving states.

v2: Loop to make sure this works even if some wm levels are
    totally disabled (latency==0)

	Cc: Neel Desai <neel.desai@intel.com>
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
	Reviewed-by: Matt Roper <matthew.d.roper@intel.com> #v1
Link: https://patchwork.freedesktop.org/patch/msgid/20190319160311.23529-1-ville.syrjala@linux.intel.com
(cherry picked from commit df331de3f8aac1a8080510d883fa40555809cddf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_pm.c
diff --cc drivers/gpu/drm/i915/intel_pm.c
index a1b763e0c3a9,b35a55a59680..000000000000
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@@ -3854,19 -3896,71 +3854,50 @@@ skl_ddb_get_pipe_allocation_limits(stru
  		return;
  	}
  
 -	/*
 -	 * Watermark/ddb requirement highly depends upon width of the
 -	 * framebuffer, So instead of allocating DDB equally among pipes
 -	 * distribute DDB based on resolution/width of the display.
 -	 */
 -	for_each_new_crtc_in_state(state, crtc, crtc_state, i) {
 -		const struct drm_display_mode *adjusted_mode;
 -		int hdisplay, vdisplay;
 -		enum pipe pipe;
 -
 -		if (!crtc_state->enable)
 -			continue;
 -
 -		pipe = to_intel_crtc(crtc)->pipe;
 -		adjusted_mode = &crtc_state->adjusted_mode;
 -		drm_mode_get_hv_timing(adjusted_mode, &hdisplay, &vdisplay);
 -		total_width += hdisplay;
 -
 -		if (pipe < for_pipe)
 -			width_before_pipe += hdisplay;
 -		else if (pipe == for_pipe)
 -			pipe_width = hdisplay;
 -	}
 -
 -	alloc->start = ddb_size * width_before_pipe / total_width;
 -	alloc->end = ddb_size * (width_before_pipe + pipe_width) / total_width;
 +	nth_active_pipe = hweight32(intel_state->active_crtcs &
 +				    (drm_crtc_mask(for_crtc) - 1));
 +	pipe_size = ddb_size / hweight32(intel_state->active_crtcs);
 +	alloc->start = nth_active_pipe * ddb_size / *num_active;
 +	alloc->end = alloc->start + pipe_size;
  }
  
- static unsigned int skl_cursor_allocation(int num_active)
+ static int skl_compute_wm_params(const struct intel_crtc_state *crtc_state,
+ 				 int width, const struct drm_format_info *format,
+ 				 u64 modifier, unsigned int rotation,
+ 				 u32 plane_pixel_rate, struct skl_wm_params *wp,
+ 				 int color_plane);
+ static void skl_compute_plane_wm(const struct intel_crtc_state *cstate,
+ 				 int level,
+ 				 const struct skl_wm_params *wp,
+ 				 const struct skl_wm_level *result_prev,
+ 				 struct skl_wm_level *result /* out */);
+ 
+ static unsigned int
+ skl_cursor_allocation(const struct intel_crtc_state *crtc_state,
+ 		      int num_active)
  {
- 	if (num_active == 1)
- 		return 32;
+ 	struct drm_i915_private *dev_priv = to_i915(crtc_state->base.crtc->dev);
+ 	int level, max_level = ilk_wm_max_level(dev_priv);
+ 	struct skl_wm_level wm = {};
+ 	int ret, min_ddb_alloc = 0;
+ 	struct skl_wm_params wp;
+ 
+ 	ret = skl_compute_wm_params(crtc_state, 256,
+ 				    drm_format_info(DRM_FORMAT_ARGB8888),
+ 				    DRM_FORMAT_MOD_LINEAR,
+ 				    DRM_MODE_ROTATE_0,
+ 				    crtc_state->pixel_rate, &wp, 0);
+ 	WARN_ON(ret);
  
- 	return 8;
+ 	for (level = 0; level <= max_level; level++) {
+ 		skl_compute_plane_wm(crtc_state, 7, &wp, &wm, &wm);
+ 		if (wm.min_ddb_alloc == U16_MAX)
+ 			break;
+ 
+ 		min_ddb_alloc = wm.min_ddb_alloc;
+ 	}
+ 
+ 	return max(num_active == 1 ? 32 : 8, min_ddb_alloc);
  }
  
  static void skl_ddb_entry_init_from_hw(struct drm_i915_private *dev_priv,
@@@ -4317,23 -4384,41 +4348,35 @@@ skl_allocate_pipe_ddb(struct intel_crtc
  	if (alloc_size == 0)
  		return 0;
  
++<<<<<<< HEAD
 +	skl_ddb_calc_min(cstate, num_active, minimum, uv_minimum);
++=======
+ 	/* Allocate fixed number of blocks for cursor. */
+ 	total[PLANE_CURSOR] = skl_cursor_allocation(cstate, num_active);
+ 	alloc_size -= total[PLANE_CURSOR];
+ 	cstate->wm.skl.plane_ddb_y[PLANE_CURSOR].start =
+ 		alloc->end - total[PLANE_CURSOR];
+ 	cstate->wm.skl.plane_ddb_y[PLANE_CURSOR].end = alloc->end;
+ 
+ 	if (total_data_rate == 0)
+ 		return 0;
++>>>>>>> df331de3f8aa (drm/i915: Allocate enough DDB for the cursor)
  
  	/*
 -	 * Find the highest watermark level for which we can satisfy the block
 -	 * requirement of active planes.
 +	 * 1. Allocate the mininum required blocks for each active plane
 +	 * and allocate the cursor, it doesn't require extra allocation
 +	 * proportional to the data rate.
  	 */
 -	for (level = ilk_wm_max_level(dev_priv); level >= 0; level--) {
 -		blocks = 0;
 -		for_each_plane_id_on_crtc(intel_crtc, plane_id) {
 -			if (plane_id == PLANE_CURSOR)
 -				continue;
 -
 -			wm = &cstate->wm.skl.optimal.planes[plane_id];
 -			blocks += wm->wm[level].min_ddb_alloc;
 -			blocks += wm->uv_wm[level].min_ddb_alloc;
 -		}
  
 -		if (blocks <= alloc_size) {
 -			alloc_size -= blocks;
 -			break;
 -		}
 +	for_each_plane_id_on_crtc(intel_crtc, plane_id) {
 +		total_min_blocks += minimum[plane_id];
 +		total_min_blocks += uv_minimum[plane_id];
  	}
  
 -	if (level < 0) {
 +	if (total_min_blocks > alloc_size) {
  		DRM_DEBUG_KMS("Requested display configuration exceeds system DDB limitations");
 -		DRM_DEBUG_KMS("minimum required %d/%d\n", blocks,
 -			      alloc_size);
 +		DRM_DEBUG_KMS("minimum required %d/%d\n", total_min_blocks,
 +							alloc_size);
  		return -EINVAL;
  	}
  
* Unmerged path drivers/gpu/drm/i915/intel_pm.c
