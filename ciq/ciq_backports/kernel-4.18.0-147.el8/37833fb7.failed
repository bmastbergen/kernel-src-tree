acpi/nfit, libnvdimm: Add freeze security support to Intel nvdimm

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Dave Jiang <dave.jiang@intel.com>
commit 37833fb7989a9d3c3e26354e6878e682c340d718
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/37833fb7.failed

Add support for freeze security on Intel nvdimm. This locks out any
changes to security for the DIMM until a hard reset of the DIMM is
performed. This is triggered by writing "freeze" to the generic
nvdimm/nmemX "security" sysfs attribute.

	Signed-off-by: Dave Jiang <dave.jiang@intel.com>
Co-developed-by: Dan Williams <dan.j.williams@intel.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 37833fb7989a9d3c3e26354e6878e682c340d718)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/nfit/intel.c
#	drivers/nvdimm/dimm_devs.c
#	drivers/nvdimm/nd-core.h
#	include/linux/libnvdimm.h
diff --cc drivers/nvdimm/dimm_devs.c
index 508dd405f84f,8e0bd2ce4dd0..000000000000
--- a/drivers/nvdimm/dimm_devs.c
+++ b/drivers/nvdimm/dimm_devs.c
@@@ -370,6 -370,69 +370,72 @@@ static ssize_t available_slots_show(str
  }
  static DEVICE_ATTR_RO(available_slots);
  
++<<<<<<< HEAD
++=======
+ static ssize_t security_show(struct device *dev,
+ 		struct device_attribute *attr, char *buf)
+ {
+ 	struct nvdimm *nvdimm = to_nvdimm(dev);
+ 
+ 	switch (nvdimm->sec.state) {
+ 	case NVDIMM_SECURITY_DISABLED:
+ 		return sprintf(buf, "disabled\n");
+ 	case NVDIMM_SECURITY_UNLOCKED:
+ 		return sprintf(buf, "unlocked\n");
+ 	case NVDIMM_SECURITY_LOCKED:
+ 		return sprintf(buf, "locked\n");
+ 	case NVDIMM_SECURITY_FROZEN:
+ 		return sprintf(buf, "frozen\n");
+ 	case NVDIMM_SECURITY_OVERWRITE:
+ 		return sprintf(buf, "overwrite\n");
+ 	}
+ 
+ 	return -ENOTTY;
+ }
+ 
+ static ssize_t __security_store(struct device *dev, const char *buf, size_t len)
+ {
+ 	struct nvdimm *nvdimm = to_nvdimm(dev);
+ 	ssize_t rc;
+ 
+ 	if (atomic_read(&nvdimm->busy))
+ 		return -EBUSY;
+ 
+ 	if (sysfs_streq(buf, "freeze")) {
+ 		dev_dbg(dev, "freeze\n");
+ 		rc = nvdimm_security_freeze(nvdimm);
+ 	} else
+ 		return -EINVAL;
+ 
+ 	if (rc == 0)
+ 		rc = len;
+ 	return rc;
+ 
+ }
+ 
+ static ssize_t security_store(struct device *dev,
+ 		struct device_attribute *attr, const char *buf, size_t len)
+ 
+ {
+ 	ssize_t rc;
+ 
+ 	/*
+ 	 * Require all userspace triggered security management to be
+ 	 * done while probing is idle and the DIMM is not in active use
+ 	 * in any region.
+ 	 */
+ 	device_lock(dev);
+ 	nvdimm_bus_lock(dev);
+ 	wait_nvdimm_bus_probe_idle(dev);
+ 	rc = __security_store(dev, buf, len);
+ 	nvdimm_bus_unlock(dev);
+ 	device_unlock(dev);
+ 
+ 	return rc;
+ }
+ static DEVICE_ATTR_RW(security);
+ 
++>>>>>>> 37833fb7989a (acpi/nfit, libnvdimm: Add freeze security support to Intel nvdimm)
  static struct attribute *nvdimm_attributes[] = {
  	&dev_attr_state.attr,
  	&dev_attr_flags.attr,
@@@ -378,8 -441,25 +444,26 @@@
  	NULL,
  };
  
++<<<<<<< HEAD
++=======
+ static umode_t nvdimm_visible(struct kobject *kobj, struct attribute *a, int n)
+ {
+ 	struct device *dev = container_of(kobj, typeof(*dev), kobj);
+ 	struct nvdimm *nvdimm = to_nvdimm(dev);
+ 
+ 	if (a != &dev_attr_security.attr)
+ 		return a->mode;
+ 	if (nvdimm->sec.state < 0)
+ 		return 0;
+ 	/* Are there any state mutation ops? */
+ 	if (nvdimm->sec.ops->freeze)
+ 		return a->mode;
+ 	return 0444;
+ }
+ 
++>>>>>>> 37833fb7989a (acpi/nfit, libnvdimm: Add freeze security support to Intel nvdimm)
  struct attribute_group nvdimm_attribute_group = {
  	.attrs = nvdimm_attributes,
 -	.is_visible = nvdimm_visible,
  };
  EXPORT_SYMBOL_GPL(nvdimm_attribute_group);
  
diff --cc drivers/nvdimm/nd-core.h
index a5977b369651,15eff40f55f6..000000000000
--- a/drivers/nvdimm/nd-core.h
+++ b/drivers/nvdimm/nd-core.h
@@@ -42,8 -42,22 +42,21 @@@ struct nvdimm 
  	int id, num_flush;
  	struct resource *flush_wpq;
  	const char *dimm_id;
 -	struct {
 -		const struct nvdimm_security_ops *ops;
 -		enum nvdimm_security_state state;
 -	} sec;
  };
  
++<<<<<<< HEAD
++=======
+ static inline enum nvdimm_security_state nvdimm_security_state(
+ 		struct nvdimm *nvdimm)
+ {
+ 	if (!nvdimm->sec.ops)
+ 		return -ENXIO;
+ 
+ 	return nvdimm->sec.ops->state(nvdimm);
+ }
+ int nvdimm_security_freeze(struct nvdimm *nvdimm);
+ 
++>>>>>>> 37833fb7989a (acpi/nfit, libnvdimm: Add freeze security support to Intel nvdimm)
  /**
   * struct blk_alloc_info - tracking info for BLK dpa scanning
   * @nd_mapping: blk region mapping boundaries
diff --cc include/linux/libnvdimm.h
index c0e66496e33c,42c815f97c02..000000000000
--- a/include/linux/libnvdimm.h
+++ b/include/linux/libnvdimm.h
@@@ -155,6 -155,19 +155,22 @@@ static inline struct nd_blk_region_des
  
  }
  
++<<<<<<< HEAD
++=======
+ enum nvdimm_security_state {
+ 	NVDIMM_SECURITY_DISABLED,
+ 	NVDIMM_SECURITY_UNLOCKED,
+ 	NVDIMM_SECURITY_LOCKED,
+ 	NVDIMM_SECURITY_FROZEN,
+ 	NVDIMM_SECURITY_OVERWRITE,
+ };
+ 
+ struct nvdimm_security_ops {
+ 	enum nvdimm_security_state (*state)(struct nvdimm *nvdimm);
+ 	int (*freeze)(struct nvdimm *nvdimm);
+ };
+ 
++>>>>>>> 37833fb7989a (acpi/nfit, libnvdimm: Add freeze security support to Intel nvdimm)
  void badrange_init(struct badrange *badrange);
  int badrange_add(struct badrange *badrange, u64 addr, u64 length);
  void badrange_forget(struct badrange *badrange, phys_addr_t start,
* Unmerged path drivers/acpi/nfit/intel.c
* Unmerged path drivers/acpi/nfit/intel.c
* Unmerged path drivers/nvdimm/dimm_devs.c
* Unmerged path drivers/nvdimm/nd-core.h
* Unmerged path include/linux/libnvdimm.h
