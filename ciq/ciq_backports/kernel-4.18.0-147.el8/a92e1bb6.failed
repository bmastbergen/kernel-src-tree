ice: Validate ring existence and its q_vector per VSI

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Maciej Fijalkowski <maciej.fijalkowski@intel.com>
commit a92e1bb6ade7526f0c2b7b462516b1941e965504
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/a92e1bb6.failed

When stopping Tx rings, we use 'i' as an ring array index for looking up
whether the ice_ring exists and have assigned a q_vector. This checks
rings only within a given TC and we need to go through every ring in
VSI. Use 'q_idx' instead.

	Signed-off-by: Maciej Fijalkowski <maciej.fijalkowski@intel.com>
	Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit a92e1bb6ade7526f0c2b7b462516b1941e965504)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_lib.c
diff --cc drivers/net/ethernet/intel/ice/ice_lib.c
index 2719e9cabb7b,57b2873a6123..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_lib.c
+++ b/drivers/net/ethernet/intel/ice/ice_lib.c
@@@ -2007,47 -2057,66 +2007,84 @@@ ice_vsi_stop_tx_rings(struct ice_vsi *v
  		goto err_alloc_q_ids;
  	}
  
 -	q_handles = devm_kcalloc(&pf->pdev->dev, vsi->num_txq,
 -				 sizeof(*q_handles), GFP_KERNEL);
 -	if (!q_handles) {
 -		err = -ENOMEM;
 -		goto err_alloc_q_handles;
 -	}
 +	/* set up the Tx queue list to be disabled */
 +	ice_for_each_txq(vsi, i) {
 +		u16 v_idx;
  
++<<<<<<< HEAD
 +		if (!rings || !rings[i] || !rings[i]->q_vector) {
 +			err = -EINVAL;
 +			goto err_out;
++=======
+ 	/* set up the Tx queue list to be disabled for each enabled TC */
+ 	ice_for_each_traffic_class(tc) {
+ 		if (!(vsi->tc_cfg.ena_tc & BIT(tc)))
+ 			break;
+ 
+ 		for (i = 0; i < vsi->tc_cfg.tc_info[tc].qcount_tx; i++) {
+ 			u16 v_idx;
+ 
+ 			if (!rings || !rings[q_idx] ||
+ 			    !rings[q_idx]->q_vector) {
+ 				err = -EINVAL;
+ 				goto err_out;
+ 			}
+ 
+ 			q_ids[i] = vsi->txq_map[q_idx + offset];
+ 			q_teids[i] = rings[q_idx]->txq_teid;
+ 			q_handles[i] = i;
+ 
+ 			/* clear cause_ena bit for disabled queues */
+ 			val = rd32(hw, QINT_TQCTL(rings[i]->reg_idx));
+ 			val &= ~QINT_TQCTL_CAUSE_ENA_M;
+ 			wr32(hw, QINT_TQCTL(rings[i]->reg_idx), val);
+ 
+ 			/* software is expected to wait for 100 ns */
+ 			ndelay(100);
+ 
+ 			/* trigger a software interrupt for the vector
+ 			 * associated to the queue to schedule NAPI handler
+ 			 */
+ 			v_idx = rings[i]->q_vector->v_idx;
+ 			wr32(hw, GLINT_DYN_CTL(vsi->hw_base_vector + v_idx),
+ 			     GLINT_DYN_CTL_SWINT_TRIG_M |
+ 			     GLINT_DYN_CTL_INTENA_MSK_M);
+ 			q_idx++;
++>>>>>>> a92e1bb6ade7 (ice: Validate ring existence and its q_vector per VSI)
  		}
 -		status = ice_dis_vsi_txq(vsi->port_info, vsi->idx, tc,
 -					 vsi->num_txq, q_handles, q_ids,
 -					 q_teids, rst_src, rel_vmvf_num, NULL);
 -
 -		/* if the disable queue command was exercised during an active
 -		 * reset flow, ICE_ERR_RESET_ONGOING is returned. This is not
 -		 * an error as the reset operation disables queues at the
 -		 * hardware level anyway.
 +
 +		q_ids[i] = vsi->txq_map[i + offset];
 +		q_teids[i] = rings[i]->txq_teid;
 +
 +		/* clear cause_ena bit for disabled queues */
 +		val = rd32(hw, QINT_TQCTL(rings[i]->reg_idx));
 +		val &= ~QINT_TQCTL_CAUSE_ENA_M;
 +		wr32(hw, QINT_TQCTL(rings[i]->reg_idx), val);
 +
 +		/* software is expected to wait for 100 ns */
 +		ndelay(100);
 +
 +		/* trigger a software interrupt for the vector associated to
 +		 * the queue to schedule NAPI handler
  		 */
 -		if (status == ICE_ERR_RESET_ONGOING) {
 -			dev_dbg(&pf->pdev->dev,
 -				"Reset in progress. LAN Tx queues already disabled\n");
 -		} else if (status) {
 -			dev_err(&pf->pdev->dev,
 -				"Failed to disable LAN Tx queues, error: %d\n",
 -				status);
 -			err = -ENODEV;
 -		}
 +		v_idx = rings[i]->q_vector->v_idx;
 +		wr32(hw, GLINT_DYN_CTL(vsi->hw_base_vector + v_idx),
 +		     GLINT_DYN_CTL_SWINT_TRIG_M | GLINT_DYN_CTL_INTENA_MSK_M);
 +	}
 +	status = ice_dis_vsi_txq(vsi->port_info, vsi->num_txq, q_ids, q_teids,
 +				 rst_src, rel_vmvf_num, NULL);
 +	/* if the disable queue command was exercised during an active reset
 +	 * flow, ICE_ERR_RESET_ONGOING is returned. This is not an error as
 +	 * the reset operation disables queues at the hardware level anyway.
 +	 */
 +	if (status == ICE_ERR_RESET_ONGOING) {
 +		dev_info(&pf->pdev->dev,
 +			 "Reset in progress. LAN Tx queues already disabled\n");
 +	} else if (status) {
 +		dev_err(&pf->pdev->dev,
 +			"Failed to disable LAN Tx queues, error: %d\n",
 +			status);
 +		err = -ENODEV;
  	}
  
  err_out:
* Unmerged path drivers/net/ethernet/intel/ice/ice_lib.c
