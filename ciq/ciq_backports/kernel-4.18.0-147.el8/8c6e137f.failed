rtnetlink: Update rtnl_fdb_dump for strict data checking

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author David Ahern <dsahern@gmail.com>
commit 8c6e137fbc7f207cd1e3f3080bfad0d4fd538254
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/8c6e137f.failed

Update rtnl_fdb_dump for strict data checking. If the flag is set,
the dump request is expected to have an ndmsg struct as the header
potentially followed by one or more attributes. Any data passed in the
header or as an attribute is taken as a request to influence the data
returned. Only values supported by the dump handler are allowed to be
non-0 or set in the request. At the moment only the NDA_IFINDEX and
NDA_MASTER attributes are supported.

	Signed-off-by: David Ahern <dsahern@gmail.com>
	Acked-by: Christian Brauner <christian@brauner.io>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8c6e137fbc7f207cd1e3f3080bfad0d4fd538254)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/rtnetlink.c
diff --cc net/core/rtnetlink.c
index 931f7d02b264,c894c4af8981..000000000000
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@@ -3766,6 -3799,92 +3766,95 @@@ out
  }
  EXPORT_SYMBOL(ndo_dflt_fdb_dump);
  
++<<<<<<< HEAD
++=======
+ static int valid_fdb_dump_strict(const struct nlmsghdr *nlh,
+ 				 int *br_idx, int *brport_idx,
+ 				 struct netlink_ext_ack *extack)
+ {
+ 	struct nlattr *tb[NDA_MAX + 1];
+ 	struct ndmsg *ndm;
+ 	int err, i;
+ 
+ 	if (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ndm))) {
+ 		NL_SET_ERR_MSG(extack, "Invalid header for fdb dump request");
+ 		return -EINVAL;
+ 	}
+ 
+ 	ndm = nlmsg_data(nlh);
+ 	if (ndm->ndm_pad1  || ndm->ndm_pad2  || ndm->ndm_state ||
+ 	    ndm->ndm_flags || ndm->ndm_type) {
+ 		NL_SET_ERR_MSG(extack, "Invalid values in header for fbd dump request");
+ 		return -EINVAL;
+ 	}
+ 
+ 	err = nlmsg_parse_strict(nlh, sizeof(struct ndmsg), tb, NDA_MAX,
+ 				 NULL, extack);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	*brport_idx = ndm->ndm_ifindex;
+ 	for (i = 0; i <= NDA_MAX; ++i) {
+ 		if (!tb[i])
+ 			continue;
+ 
+ 		switch (i) {
+ 		case NDA_IFINDEX:
+ 			if (nla_len(tb[i]) != sizeof(u32)) {
+ 				NL_SET_ERR_MSG(extack, "Invalid IFINDEX attribute in fdb dump request");
+ 				return -EINVAL;
+ 			}
+ 			*brport_idx = nla_get_u32(tb[NDA_IFINDEX]);
+ 			break;
+ 		case NDA_MASTER:
+ 			if (nla_len(tb[i]) != sizeof(u32)) {
+ 				NL_SET_ERR_MSG(extack, "Invalid MASTER attribute in fdb dump request");
+ 				return -EINVAL;
+ 			}
+ 			*br_idx = nla_get_u32(tb[NDA_MASTER]);
+ 			break;
+ 		default:
+ 			NL_SET_ERR_MSG(extack, "Unsupported attribute in fdb dump request");
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int valid_fdb_dump_legacy(const struct nlmsghdr *nlh,
+ 				 int *br_idx, int *brport_idx,
+ 				 struct netlink_ext_ack *extack)
+ {
+ 	struct ifinfomsg *ifm = nlmsg_data(nlh);
+ 	struct nlattr *tb[IFLA_MAX+1];
+ 	int err;
+ 
+ 	/* A hack to preserve kernel<->userspace interface.
+ 	 * Before Linux v4.12 this code accepted ndmsg since iproute2 v3.3.0.
+ 	 * However, ndmsg is shorter than ifinfomsg thus nlmsg_parse() bails.
+ 	 * So, check for ndmsg with an optional u32 attribute (not used here).
+ 	 * Fortunately these sizes don't conflict with the size of ifinfomsg
+ 	 * with an optional attribute.
+ 	 */
+ 	if (nlmsg_len(nlh) != sizeof(struct ndmsg) &&
+ 	    (nlmsg_len(nlh) != sizeof(struct ndmsg) +
+ 	     nla_attr_size(sizeof(u32)))) {
+ 		err = nlmsg_parse(nlh, sizeof(struct ifinfomsg), tb, IFLA_MAX,
+ 				  ifla_policy, extack);
+ 		if (err < 0) {
+ 			return -EINVAL;
+ 		} else if (err == 0) {
+ 			if (tb[IFLA_MASTER])
+ 				*br_idx = nla_get_u32(tb[IFLA_MASTER]);
+ 		}
+ 
+ 		*brport_idx = ifm->ifi_index;
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> 8c6e137fbc7f (rtnetlink: Update rtnl_fdb_dump for strict data checking)
  static int rtnl_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb)
  {
  	struct net_device *dev;
@@@ -3783,27 -3900,14 +3872,38 @@@
  	int err = 0;
  	int fidx = 0;
  
++<<<<<<< HEAD
 +	/* A hack to preserve kernel<->userspace interface.
 +	 * Before Linux v4.12 this code accepted ndmsg since iproute2 v3.3.0.
 +	 * However, ndmsg is shorter than ifinfomsg thus nlmsg_parse() bails.
 +	 * So, check for ndmsg with an optional u32 attribute (not used here).
 +	 * Fortunately these sizes don't conflict with the size of ifinfomsg
 +	 * with an optional attribute.
 +	 */
 +	if (nlmsg_len(cb->nlh) != sizeof(struct ndmsg) &&
 +	    (nlmsg_len(cb->nlh) != sizeof(struct ndmsg) +
 +	     nla_attr_size(sizeof(u32)))) {
 +		err = nlmsg_parse(cb->nlh, sizeof(struct ifinfomsg), tb,
 +				  IFLA_MAX, ifla_policy, NULL);
 +		if (err < 0) {
 +			return -EINVAL;
 +		} else if (err == 0) {
 +			if (tb[IFLA_MASTER])
 +				br_idx = nla_get_u32(tb[IFLA_MASTER]);
 +		}
 +
 +		brport_idx = ifm->ifi_index;
 +	}
++=======
+ 	if (cb->strict_check)
+ 		err = valid_fdb_dump_strict(cb->nlh, &br_idx, &brport_idx,
+ 					    cb->extack);
+ 	else
+ 		err = valid_fdb_dump_legacy(cb->nlh, &br_idx, &brport_idx,
+ 					    cb->extack);
+ 	if (err < 0)
+ 		return err;
++>>>>>>> 8c6e137fbc7f (rtnetlink: Update rtnl_fdb_dump for strict data checking)
  
  	if (br_idx) {
  		br_dev = __dev_get_by_index(net, br_idx);
* Unmerged path net/core/rtnetlink.c
