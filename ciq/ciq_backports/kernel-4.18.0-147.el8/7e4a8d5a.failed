rtnetlink: s/IFLA_IF_NETNSID/IFLA_TARGET_NETNSID/g

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Christian Brauner <christian@brauner.io>
commit 7e4a8d5a93f649a1c0a0181cab5d965b1f85cf71
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/7e4a8d5a.failed

IFLA_TARGET_NETNSID is the new alias for IFLA_IF_NETNSID. This commit
replaces all occurrences of IFLA_IF_NETNSID with the new alias to
indicate that this identifier is the preferred one.

	Signed-off-by: Christian Brauner <christian@brauner.io>
	Cc: Nicolas Dichtel <nicolas.dichtel@6wind.com>
	Cc: Jiri Benc <jbenc@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7e4a8d5a93f649a1c0a0181cab5d965b1f85cf71)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/rtnetlink.c
diff --cc net/core/rtnetlink.c
index 5428cbf860da,e4ae0319e189..000000000000
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@@ -1018,9 -1016,11 +1018,9 @@@ static noinline size_t if_nlmsg_size(co
  	       + nla_total_size(4)  /* IFLA_NEW_NETNSID */
  	       + nla_total_size(4)  /* IFLA_NEW_IFINDEX */
  	       + nla_total_size(1)  /* IFLA_PROTO_DOWN */
- 	       + nla_total_size(4)  /* IFLA_IF_NETNSID */
+ 	       + nla_total_size(4)  /* IFLA_TARGET_NETNSID */
  	       + nla_total_size(4)  /* IFLA_CARRIER_UP_COUNT */
  	       + nla_total_size(4)  /* IFLA_CARRIER_DOWN_COUNT */
 -	       + nla_total_size(4)  /* IFLA_MIN_MTU */
 -	       + nla_total_size(4)  /* IFLA_MAX_MTU */
  	       + 0;
  }
  
@@@ -1750,9 -1737,11 +1750,9 @@@ static const struct nla_policy ifla_pol
  	[IFLA_XDP]		= { .type = NLA_NESTED },
  	[IFLA_EVENT]		= { .type = NLA_U32 },
  	[IFLA_GROUP]		= { .type = NLA_U32 },
- 	[IFLA_IF_NETNSID]	= { .type = NLA_S32 },
+ 	[IFLA_TARGET_NETNSID]	= { .type = NLA_S32 },
  	[IFLA_CARRIER_UP_COUNT]	= { .type = NLA_U32 },
  	[IFLA_CARRIER_DOWN_COUNT] = { .type = NLA_U32 },
 -	[IFLA_MIN_MTU]		= { .type = NLA_U32 },
 -	[IFLA_MAX_MTU]		= { .type = NLA_U32 },
  };
  
  static const struct nla_policy ifla_info_policy[IFLA_INFO_MAX+1] = {
@@@ -1906,11 -1904,13 +1906,21 @@@ static int rtnl_dump_ifinfo(struct sk_b
  
  	if (nlmsg_parse(cb->nlh, hdrlen, tb, IFLA_MAX,
  			ifla_policy, NULL) >= 0) {
++<<<<<<< HEAD
 +		if (tb[IFLA_IF_NETNSID]) {
 +			netnsid = nla_get_s32(tb[IFLA_IF_NETNSID]);
 +			tgt_net = get_target_net(skb->sk, netnsid);
 +			if (IS_ERR(tgt_net))
 +				return PTR_ERR(tgt_net);
++=======
+ 		if (tb[IFLA_TARGET_NETNSID]) {
+ 			netnsid = nla_get_s32(tb[IFLA_TARGET_NETNSID]);
+ 			tgt_net = rtnl_get_net_ns_capable(skb->sk, netnsid);
+ 			if (IS_ERR(tgt_net)) {
+ 				tgt_net = net;
+ 				netnsid = -1;
+ 			}
++>>>>>>> 7e4a8d5a93f6 (rtnetlink: s/IFLA_IF_NETNSID/IFLA_TARGET_NETNSID/g)
  		}
  
  		if (tb[IFLA_EXT_MASK])
@@@ -2773,9 -2772,9 +2783,15 @@@ static int rtnl_dellink(struct sk_buff 
  	if (tb[IFLA_IFNAME])
  		nla_strlcpy(ifname, tb[IFLA_IFNAME], IFNAMSIZ);
  
++<<<<<<< HEAD
 +	if (tb[IFLA_IF_NETNSID]) {
 +		netnsid = nla_get_s32(tb[IFLA_IF_NETNSID]);
 +		tgt_net = get_target_net(NETLINK_CB(skb).sk, netnsid);
++=======
+ 	if (tb[IFLA_TARGET_NETNSID]) {
+ 		netnsid = nla_get_s32(tb[IFLA_TARGET_NETNSID]);
+ 		tgt_net = rtnl_get_net_ns_capable(NETLINK_CB(skb).sk, netnsid);
++>>>>>>> 7e4a8d5a93f6 (rtnetlink: s/IFLA_IF_NETNSID/IFLA_TARGET_NETNSID/g)
  		if (IS_ERR(tgt_net))
  			return PTR_ERR(tgt_net);
  	}
@@@ -3190,9 -3182,9 +3206,15 @@@ static int rtnl_getlink(struct sk_buff 
  	if (err < 0)
  		return err;
  
++<<<<<<< HEAD
 +	if (tb[IFLA_IF_NETNSID]) {
 +		netnsid = nla_get_s32(tb[IFLA_IF_NETNSID]);
 +		tgt_net = get_target_net(NETLINK_CB(skb).sk, netnsid);
++=======
+ 	if (tb[IFLA_TARGET_NETNSID]) {
+ 		netnsid = nla_get_s32(tb[IFLA_TARGET_NETNSID]);
+ 		tgt_net = rtnl_get_net_ns_capable(NETLINK_CB(skb).sk, netnsid);
++>>>>>>> 7e4a8d5a93f6 (rtnetlink: s/IFLA_IF_NETNSID/IFLA_TARGET_NETNSID/g)
  		if (IS_ERR(tgt_net))
  			return PTR_ERR(tgt_net);
  	}
* Unmerged path net/core/rtnetlink.c
