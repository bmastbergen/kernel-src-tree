drm/i915: Bump fb stride limit to 128KiB for gen4+ and 256KiB for gen7+

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit 2033012982231533e545b002f744a60699fe968c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/20330129.failed

With gtt remapping plugged in we can simply raise the stride
limit on gen4+. Let's just pick the limit to match the render
engine max stride (256KiB on gen7+, 128KiB on gen4+).

No remapping CCS because the virtual address of each page actually
matters due to the new hash mode
(WaCompressedResourceDisplayNewHashMode:skl,kbl etc.), and no
remapping on gen2/3 due extra complications from fence alignment
and gen2 2KiB GTT tile size. Also no real benefit since the
display engine limits already match the other limits.

v2: Rebase due to is_ccs_modifier()
v3: Tweak the comment and commit msg
v4: Fix gen4+ stride limit to be 128KiB

	Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch> #v3
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190509122159.24376-8-ville.syrjala@linux.intel.com
	Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
(cherry picked from commit 2033012982231533e545b002f744a60699fe968c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_display.c
diff --cc drivers/gpu/drm/i915/intel_display.c
index 98867581a27e,ccdbeb2dbd28..000000000000
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@@ -2515,6 -2492,140 +2515,143 @@@ intel_get_format_info(const struct drm_
  	}
  }
  
++<<<<<<< HEAD
++=======
+ bool is_ccs_modifier(u64 modifier)
+ {
+ 	return modifier == I915_FORMAT_MOD_Y_TILED_CCS ||
+ 	       modifier == I915_FORMAT_MOD_Yf_TILED_CCS;
+ }
+ 
+ u32 intel_plane_fb_max_stride(struct drm_i915_private *dev_priv,
+ 			      u32 pixel_format, u64 modifier)
+ {
+ 	struct intel_crtc *crtc;
+ 	struct intel_plane *plane;
+ 
+ 	/*
+ 	 * We assume the primary plane for pipe A has
+ 	 * the highest stride limits of them all.
+ 	 */
+ 	crtc = intel_get_crtc_for_pipe(dev_priv, PIPE_A);
+ 	plane = to_intel_plane(crtc->base.primary);
+ 
+ 	return plane->max_stride(plane, pixel_format, modifier,
+ 				 DRM_MODE_ROTATE_0);
+ }
+ 
+ static
+ u32 intel_fb_max_stride(struct drm_i915_private *dev_priv,
+ 			u32 pixel_format, u64 modifier)
+ {
+ 	/*
+ 	 * Arbitrary limit for gen4+ chosen to match the
+ 	 * render engine max stride.
+ 	 *
+ 	 * The new CCS hash mode makes remapping impossible
+ 	 */
+ 	if (!is_ccs_modifier(modifier)) {
+ 		if (INTEL_GEN(dev_priv) >= 7)
+ 			return 256*1024;
+ 		else if (INTEL_GEN(dev_priv) >= 4)
+ 			return 128*1024;
+ 	}
+ 
+ 	return intel_plane_fb_max_stride(dev_priv, pixel_format, modifier);
+ }
+ 
+ static u32
+ intel_fb_stride_alignment(const struct drm_framebuffer *fb, int color_plane)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(fb->dev);
+ 
+ 	if (fb->modifier == DRM_FORMAT_MOD_LINEAR) {
+ 		u32 max_stride = intel_plane_fb_max_stride(dev_priv,
+ 							   fb->format->format,
+ 							   fb->modifier);
+ 
+ 		/*
+ 		 * To make remapping with linear generally feasible
+ 		 * we need the stride to be page aligned.
+ 		 */
+ 		if (fb->pitches[color_plane] > max_stride)
+ 			return intel_tile_size(dev_priv);
+ 		else
+ 			return 64;
+ 	} else {
+ 		return intel_tile_width_bytes(fb, color_plane);
+ 	}
+ }
+ 
+ bool intel_plane_can_remap(const struct intel_plane_state *plane_state)
+ {
+ 	struct intel_plane *plane = to_intel_plane(plane_state->base.plane);
+ 	struct drm_i915_private *dev_priv = to_i915(plane->base.dev);
+ 	const struct drm_framebuffer *fb = plane_state->base.fb;
+ 	int i;
+ 
+ 	/* We don't want to deal with remapping with cursors */
+ 	if (plane->id == PLANE_CURSOR)
+ 		return false;
+ 
+ 	/*
+ 	 * The display engine limits already match/exceed the
+ 	 * render engine limits, so not much point in remapping.
+ 	 * Would also need to deal with the fence POT alignment
+ 	 * and gen2 2KiB GTT tile size.
+ 	 */
+ 	if (INTEL_GEN(dev_priv) < 4)
+ 		return false;
+ 
+ 	/*
+ 	 * The new CCS hash mode isn't compatible with remapping as
+ 	 * the virtual address of the pages affects the compressed data.
+ 	 */
+ 	if (is_ccs_modifier(fb->modifier))
+ 		return false;
+ 
+ 	/* Linear needs a page aligned stride for remapping */
+ 	if (fb->modifier == DRM_FORMAT_MOD_LINEAR) {
+ 		unsigned int alignment = intel_tile_size(dev_priv) - 1;
+ 
+ 		for (i = 0; i < fb->format->num_planes; i++) {
+ 			if (fb->pitches[i] & alignment)
+ 				return false;
+ 		}
+ 	}
+ 
+ 	return true;
+ }
+ 
+ static bool intel_plane_needs_remap(const struct intel_plane_state *plane_state)
+ {
+ 	struct intel_plane *plane = to_intel_plane(plane_state->base.plane);
+ 	const struct drm_framebuffer *fb = plane_state->base.fb;
+ 	unsigned int rotation = plane_state->base.rotation;
+ 	u32 stride, max_stride;
+ 
+ 	/*
+ 	 * No remapping for invisible planes since we don't have
+ 	 * an actual source viewport to remap.
+ 	 */
+ 	if (!plane_state->base.visible)
+ 		return false;
+ 
+ 	if (!intel_plane_can_remap(plane_state))
+ 		return false;
+ 
+ 	/*
+ 	 * FIXME: aux plane limits on gen9+ are
+ 	 * unclear in Bspec, for now no checking.
+ 	 */
+ 	stride = intel_fb_pitch(fb, 0, rotation);
+ 	max_stride = plane->max_stride(plane, fb->format->format,
+ 				       fb->modifier, rotation);
+ 
+ 	return stride > max_stride;
+ }
+ 
++>>>>>>> 203301298223 (drm/i915: Bump fb stride limit to 128KiB for gen4+ and 256KiB for gen7+)
  static int
  intel_fill_fb_info(struct drm_i915_private *dev_priv,
  		   struct drm_framebuffer *fb)
* Unmerged path drivers/gpu/drm/i915/intel_display.c
