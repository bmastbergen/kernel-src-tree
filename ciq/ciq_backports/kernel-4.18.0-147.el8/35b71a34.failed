net/tls: don't leak partially sent record in device mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 35b71a34ada62c9573847a324bf06a133fe11b11
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/35b71a34.failed

David reports that tls triggers warnings related to
sk->sk_forward_alloc not being zero at destruction time:

WARNING: CPU: 5 PID: 6831 at net/core/stream.c:206 sk_stream_kill_queues+0x103/0x110
WARNING: CPU: 5 PID: 6831 at net/ipv4/af_inet.c:160 inet_sock_destruct+0x15b/0x170

When sender fills up the write buffer and dies from
SIGPIPE.  This is due to the device implementation
not cleaning up the partially_sent_record.

This is because commit a42055e8d2c3 ("net/tls: Add support for async encryption of records for performance")
moved the partial record cleanup to the SW-only path.

Fixes: a42055e8d2c3 ("net/tls: Add support for async encryption of records for performance")
	Reported-by: David Beckett <david.beckett@netronome.com>
	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Dirk van der Merwe <dirk.vandermerwe@netronome.com>
	Reviewed-by: Simon Horman <simon.horman@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 35b71a34ada62c9573847a324bf06a133fe11b11)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/tls/tls_main.c
diff --cc net/tls/tls_main.c
index a0dcca82c8b9,a3cca1ef0098..000000000000
--- a/net/tls/tls_main.c
+++ b/net/tls/tls_main.c
@@@ -205,17 -208,24 +205,38 @@@ int tls_push_partial_record(struct soc
  	return tls_push_sg(sk, ctx, sg, offset, flags);
  }
  
++<<<<<<< HEAD
 +int tls_push_pending_closed_record(struct sock *sk,
 +				   struct tls_context *tls_ctx,
 +				   int flags, long *timeo)
 +{
 +	struct tls_sw_context_tx *ctx = tls_sw_ctx_tx(tls_ctx);
 +
 +	if (tls_is_partially_sent_record(tls_ctx) ||
 +	    !list_empty(&ctx->tx_list))
 +		return tls_tx_records(sk, flags);
 +	else
 +		return tls_ctx->push_pending_record(sk, flags);
++=======
+ bool tls_free_partial_record(struct sock *sk, struct tls_context *ctx)
+ {
+ 	struct scatterlist *sg;
+ 
+ 	sg = ctx->partially_sent_record;
+ 	if (!sg)
+ 		return false;
+ 
+ 	while (1) {
+ 		put_page(sg_page(sg));
+ 		sk_mem_uncharge(sk, sg->length);
+ 
+ 		if (sg_is_last(sg))
+ 			break;
+ 		sg++;
+ 	}
+ 	ctx->partially_sent_record = NULL;
+ 	return true;
++>>>>>>> 35b71a34ada6 (net/tls: don't leak partially sent record in device mode)
  }
  
  static void tls_write_space(struct sock *sk)
@@@ -276,10 -287,15 +297,12 @@@ static void tls_sk_proto_close(struct s
  		kfree(ctx->tx.rec_seq);
  		kfree(ctx->tx.iv);
  		tls_sw_free_resources_tx(sk);
+ 	} else if (ctx->tx_conf == TLS_HW) {
+ 		tls_device_free_resources_tx(sk);
  	}
  
 -	if (ctx->rx_conf == TLS_SW) {
 -		kfree(ctx->rx.rec_seq);
 -		kfree(ctx->rx.iv);
 +	if (ctx->rx_conf == TLS_SW)
  		tls_sw_free_resources_rx(sk);
 -	}
  
  #ifdef CONFIG_TLS_DEVICE
  	if (ctx->rx_conf == TLS_HW)
diff --git a/include/net/tls.h b/include/net/tls.h
index 6da19b6e6db1..898940ef58a8 100644
--- a/include/net/tls.h
+++ b/include/net/tls.h
@@ -295,6 +295,7 @@ int tls_device_sendmsg(struct sock *sk, struct msghdr *msg, size_t size);
 int tls_device_sendpage(struct sock *sk, struct page *page,
 			int offset, size_t size, int flags);
 void tls_device_sk_destruct(struct sock *sk);
+void tls_device_free_resources_tx(struct sock *sk);
 void tls_device_init(void);
 void tls_device_cleanup(void);
 int tls_tx_records(struct sock *sk, int flags);
@@ -318,6 +319,7 @@ int tls_push_sg(struct sock *sk, struct tls_context *ctx,
 		int flags);
 int tls_push_partial_record(struct sock *sk, struct tls_context *ctx,
 			    int flags);
+bool tls_free_partial_record(struct sock *sk, struct tls_context *ctx);
 
 int tls_push_pending_closed_record(struct sock *sk, struct tls_context *ctx,
 				   int flags, long *timeo);
diff --git a/net/tls/tls_device.c b/net/tls/tls_device.c
index be826fc2113a..bd330c1dd4c0 100644
--- a/net/tls/tls_device.c
+++ b/net/tls/tls_device.c
@@ -216,6 +216,13 @@ void tls_device_sk_destruct(struct sock *sk)
 }
 EXPORT_SYMBOL(tls_device_sk_destruct);
 
+void tls_device_free_resources_tx(struct sock *sk)
+{
+	struct tls_context *tls_ctx = tls_get_ctx(sk);
+
+	tls_free_partial_record(sk, tls_ctx);
+}
+
 static void tls_append_frag(struct tls_record_info *record,
 			    struct page_frag *pfrag,
 			    int size)
* Unmerged path net/tls/tls_main.c
diff --git a/net/tls/tls_sw.c b/net/tls/tls_sw.c
index ad7a18109304..9afe8a93fc97 100644
--- a/net/tls/tls_sw.c
+++ b/net/tls/tls_sw.c
@@ -1402,20 +1402,7 @@ void tls_sw_free_resources_tx(struct sock *sk)
 	/* Free up un-sent records in tx_list. First, free
 	 * the partially sent record if any at head of tx_list.
 	 */
-	if (tls_ctx->partially_sent_record) {
-		struct scatterlist *sg = tls_ctx->partially_sent_record;
-
-		while (1) {
-			put_page(sg_page(sg));
-			sk_mem_uncharge(sk, sg->length);
-
-			if (sg_is_last(sg))
-				break;
-			sg++;
-		}
-
-		tls_ctx->partially_sent_record = NULL;
-
+	if (tls_free_partial_record(sk, tls_ctx)) {
 		rec = list_first_entry(&ctx->tx_list,
 				       struct tls_rec, list);
 
