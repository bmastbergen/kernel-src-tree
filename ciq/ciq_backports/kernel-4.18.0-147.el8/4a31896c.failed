XArray: Change xa_for_each iterator

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Matthew Wilcox <willy@infradead.org>
commit 4a31896c5b5a2715ecf4033426aa0a35066d92d6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/4a31896c.failed

There were three problems with this API:
1. It took too many arguments; almost all users wanted to iterate over
every element in the array rather than a subset.
2. It required that 'index' be initialised before use, and there's no
realistic way to make GCC catch that.
3. 'index' and 'entry' were the opposite way round from every other
member of the XArray APIs.

So split it into three different APIs:

xa_for_each(xa, index, entry)
xa_for_each_start(xa, index, entry, start)
xa_for_each_marked(xa, index, entry, filter)

	Signed-off-by: Matthew Wilcox <willy@infradead.org>
(cherry picked from commit 4a31896c5b5a2715ecf4033426aa0a35066d92d6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/xarray.h
#	lib/test_xarray.c
diff --cc include/linux/xarray.h
index 2dfc8006fe64,3d0ce8b267e3..000000000000
--- a/include/linux/xarray.h
+++ b/include/linux/xarray.h
@@@ -4,10 -4,440 +4,435 @@@
  /*
   * eXtensible Arrays
   * Copyright (c) 2017 Microsoft Corporation
 - * Author: Matthew Wilcox <willy@infradead.org>
 - *
 - * See Documentation/core-api/xarray.rst for how to use the XArray.
 + * Author: Matthew Wilcox <mawilcox@microsoft.com>
   */
  
 -#include <linux/bug.h>
 -#include <linux/compiler.h>
 -#include <linux/gfp.h>
 -#include <linux/kconfig.h>
 -#include <linux/kernel.h>
 -#include <linux/rcupdate.h>
  #include <linux/spinlock.h>
++<<<<<<< HEAD
++=======
+ #include <linux/types.h>
+ 
+ /*
+  * The bottom two bits of the entry determine how the XArray interprets
+  * the contents:
+  *
+  * 00: Pointer entry
+  * 10: Internal entry
+  * x1: Value entry or tagged pointer
+  *
+  * Attempting to store internal entries in the XArray is a bug.
+  *
+  * Most internal entries are pointers to the next node in the tree.
+  * The following internal entries have a special meaning:
+  *
+  * 0-62: Sibling entries
+  * 256: Zero entry
+  * 257: Retry entry
+  *
+  * Errors are also represented as internal entries, but use the negative
+  * space (-4094 to -2).  They're never stored in the slots array; only
+  * returned by the normal API.
+  */
+ 
+ #define BITS_PER_XA_VALUE	(BITS_PER_LONG - 1)
+ 
+ /**
+  * xa_mk_value() - Create an XArray entry from an integer.
+  * @v: Value to store in XArray.
+  *
+  * Context: Any context.
+  * Return: An entry suitable for storing in the XArray.
+  */
+ static inline void *xa_mk_value(unsigned long v)
+ {
+ 	WARN_ON((long)v < 0);
+ 	return (void *)((v << 1) | 1);
+ }
+ 
+ /**
+  * xa_to_value() - Get value stored in an XArray entry.
+  * @entry: XArray entry.
+  *
+  * Context: Any context.
+  * Return: The value stored in the XArray entry.
+  */
+ static inline unsigned long xa_to_value(const void *entry)
+ {
+ 	return (unsigned long)entry >> 1;
+ }
+ 
+ /**
+  * xa_is_value() - Determine if an entry is a value.
+  * @entry: XArray entry.
+  *
+  * Context: Any context.
+  * Return: True if the entry is a value, false if it is a pointer.
+  */
+ static inline bool xa_is_value(const void *entry)
+ {
+ 	return (unsigned long)entry & 1;
+ }
+ 
+ /**
+  * xa_tag_pointer() - Create an XArray entry for a tagged pointer.
+  * @p: Plain pointer.
+  * @tag: Tag value (0, 1 or 3).
+  *
+  * If the user of the XArray prefers, they can tag their pointers instead
+  * of storing value entries.  Three tags are available (0, 1 and 3).
+  * These are distinct from the xa_mark_t as they are not replicated up
+  * through the array and cannot be searched for.
+  *
+  * Context: Any context.
+  * Return: An XArray entry.
+  */
+ static inline void *xa_tag_pointer(void *p, unsigned long tag)
+ {
+ 	return (void *)((unsigned long)p | tag);
+ }
+ 
+ /**
+  * xa_untag_pointer() - Turn an XArray entry into a plain pointer.
+  * @entry: XArray entry.
+  *
+  * If you have stored a tagged pointer in the XArray, call this function
+  * to get the untagged version of the pointer.
+  *
+  * Context: Any context.
+  * Return: A pointer.
+  */
+ static inline void *xa_untag_pointer(void *entry)
+ {
+ 	return (void *)((unsigned long)entry & ~3UL);
+ }
+ 
+ /**
+  * xa_pointer_tag() - Get the tag stored in an XArray entry.
+  * @entry: XArray entry.
+  *
+  * If you have stored a tagged pointer in the XArray, call this function
+  * to get the tag of that pointer.
+  *
+  * Context: Any context.
+  * Return: A tag.
+  */
+ static inline unsigned int xa_pointer_tag(void *entry)
+ {
+ 	return (unsigned long)entry & 3UL;
+ }
+ 
+ /*
+  * xa_mk_internal() - Create an internal entry.
+  * @v: Value to turn into an internal entry.
+  *
+  * Context: Any context.
+  * Return: An XArray internal entry corresponding to this value.
+  */
+ static inline void *xa_mk_internal(unsigned long v)
+ {
+ 	return (void *)((v << 2) | 2);
+ }
+ 
+ /*
+  * xa_to_internal() - Extract the value from an internal entry.
+  * @entry: XArray entry.
+  *
+  * Context: Any context.
+  * Return: The value which was stored in the internal entry.
+  */
+ static inline unsigned long xa_to_internal(const void *entry)
+ {
+ 	return (unsigned long)entry >> 2;
+ }
+ 
+ /*
+  * xa_is_internal() - Is the entry an internal entry?
+  * @entry: XArray entry.
+  *
+  * Context: Any context.
+  * Return: %true if the entry is an internal entry.
+  */
+ static inline bool xa_is_internal(const void *entry)
+ {
+ 	return ((unsigned long)entry & 3) == 2;
+ }
+ 
+ /**
+  * xa_is_err() - Report whether an XArray operation returned an error
+  * @entry: Result from calling an XArray function
+  *
+  * If an XArray operation cannot complete an operation, it will return
+  * a special value indicating an error.  This function tells you
+  * whether an error occurred; xa_err() tells you which error occurred.
+  *
+  * Context: Any context.
+  * Return: %true if the entry indicates an error.
+  */
+ static inline bool xa_is_err(const void *entry)
+ {
+ 	return unlikely(xa_is_internal(entry));
+ }
+ 
+ /**
+  * xa_err() - Turn an XArray result into an errno.
+  * @entry: Result from calling an XArray function.
+  *
+  * If an XArray operation cannot complete an operation, it will return
+  * a special pointer value which encodes an errno.  This function extracts
+  * the errno from the pointer value, or returns 0 if the pointer does not
+  * represent an errno.
+  *
+  * Context: Any context.
+  * Return: A negative errno or 0.
+  */
+ static inline int xa_err(void *entry)
+ {
+ 	/* xa_to_internal() would not do sign extension. */
+ 	if (xa_is_err(entry))
+ 		return (long)entry >> 2;
+ 	return 0;
+ }
+ 
+ typedef unsigned __bitwise xa_mark_t;
+ #define XA_MARK_0		((__force xa_mark_t)0U)
+ #define XA_MARK_1		((__force xa_mark_t)1U)
+ #define XA_MARK_2		((__force xa_mark_t)2U)
+ #define XA_PRESENT		((__force xa_mark_t)8U)
+ #define XA_MARK_MAX		XA_MARK_2
+ #define XA_FREE_MARK		XA_MARK_0
+ 
+ enum xa_lock_type {
+ 	XA_LOCK_IRQ = 1,
+ 	XA_LOCK_BH = 2,
+ };
+ 
+ /*
+  * Values for xa_flags.  The radix tree stores its GFP flags in the xa_flags,
+  * and we remain compatible with that.
+  */
+ #define XA_FLAGS_LOCK_IRQ	((__force gfp_t)XA_LOCK_IRQ)
+ #define XA_FLAGS_LOCK_BH	((__force gfp_t)XA_LOCK_BH)
+ #define XA_FLAGS_TRACK_FREE	((__force gfp_t)4U)
+ #define XA_FLAGS_MARK(mark)	((__force gfp_t)((1U << __GFP_BITS_SHIFT) << \
+ 						(__force unsigned)(mark)))
+ 
+ #define XA_FLAGS_ALLOC	(XA_FLAGS_TRACK_FREE | XA_FLAGS_MARK(XA_FREE_MARK))
+ 
+ /**
+  * struct xarray - The anchor of the XArray.
+  * @xa_lock: Lock that protects the contents of the XArray.
+  *
+  * To use the xarray, define it statically or embed it in your data structure.
+  * It is a very small data structure, so it does not usually make sense to
+  * allocate it separately and keep a pointer to it in your data structure.
+  *
+  * You may use the xa_lock to protect your own data structures as well.
+  */
+ /*
+  * If all of the entries in the array are NULL, @xa_head is a NULL pointer.
+  * If the only non-NULL entry in the array is at index 0, @xa_head is that
+  * entry.  If any other entry in the array is non-NULL, @xa_head points
+  * to an @xa_node.
+  */
+ struct xarray {
+ 	spinlock_t	xa_lock;
+ /* private: The rest of the data structure is not to be used directly. */
+ 	gfp_t		xa_flags;
+ 	void __rcu *	xa_head;
+ };
+ 
+ #define XARRAY_INIT(name, flags) {				\
+ 	.xa_lock = __SPIN_LOCK_UNLOCKED(name.xa_lock),		\
+ 	.xa_flags = flags,					\
+ 	.xa_head = NULL,					\
+ }
+ 
+ /**
+  * DEFINE_XARRAY_FLAGS() - Define an XArray with custom flags.
+  * @name: A string that names your XArray.
+  * @flags: XA_FLAG values.
+  *
+  * This is intended for file scope definitions of XArrays.  It declares
+  * and initialises an empty XArray with the chosen name and flags.  It is
+  * equivalent to calling xa_init_flags() on the array, but it does the
+  * initialisation at compiletime instead of runtime.
+  */
+ #define DEFINE_XARRAY_FLAGS(name, flags)				\
+ 	struct xarray name = XARRAY_INIT(name, flags)
+ 
+ /**
+  * DEFINE_XARRAY() - Define an XArray.
+  * @name: A string that names your XArray.
+  *
+  * This is intended for file scope definitions of XArrays.  It declares
+  * and initialises an empty XArray with the chosen name.  It is equivalent
+  * to calling xa_init() on the array, but it does the initialisation at
+  * compiletime instead of runtime.
+  */
+ #define DEFINE_XARRAY(name) DEFINE_XARRAY_FLAGS(name, 0)
+ 
+ /**
+  * DEFINE_XARRAY_ALLOC() - Define an XArray which can allocate IDs.
+  * @name: A string that names your XArray.
+  *
+  * This is intended for file scope definitions of allocating XArrays.
+  * See also DEFINE_XARRAY().
+  */
+ #define DEFINE_XARRAY_ALLOC(name) DEFINE_XARRAY_FLAGS(name, XA_FLAGS_ALLOC)
+ 
+ void *xa_load(struct xarray *, unsigned long index);
+ void *xa_store(struct xarray *, unsigned long index, void *entry, gfp_t);
+ void *xa_erase(struct xarray *, unsigned long index);
+ void *xa_store_range(struct xarray *, unsigned long first, unsigned long last,
+ 			void *entry, gfp_t);
+ bool xa_get_mark(struct xarray *, unsigned long index, xa_mark_t);
+ void xa_set_mark(struct xarray *, unsigned long index, xa_mark_t);
+ void xa_clear_mark(struct xarray *, unsigned long index, xa_mark_t);
+ void *xa_find(struct xarray *xa, unsigned long *index,
+ 		unsigned long max, xa_mark_t) __attribute__((nonnull(2)));
+ void *xa_find_after(struct xarray *xa, unsigned long *index,
+ 		unsigned long max, xa_mark_t) __attribute__((nonnull(2)));
+ unsigned int xa_extract(struct xarray *, void **dst, unsigned long start,
+ 		unsigned long max, unsigned int n, xa_mark_t);
+ void xa_destroy(struct xarray *);
+ 
+ /**
+  * xa_init_flags() - Initialise an empty XArray with flags.
+  * @xa: XArray.
+  * @flags: XA_FLAG values.
+  *
+  * If you need to initialise an XArray with special flags (eg you need
+  * to take the lock from interrupt context), use this function instead
+  * of xa_init().
+  *
+  * Context: Any context.
+  */
+ static inline void xa_init_flags(struct xarray *xa, gfp_t flags)
+ {
+ 	spin_lock_init(&xa->xa_lock);
+ 	xa->xa_flags = flags;
+ 	xa->xa_head = NULL;
+ }
+ 
+ /**
+  * xa_init() - Initialise an empty XArray.
+  * @xa: XArray.
+  *
+  * An empty XArray is full of NULL entries.
+  *
+  * Context: Any context.
+  */
+ static inline void xa_init(struct xarray *xa)
+ {
+ 	xa_init_flags(xa, 0);
+ }
+ 
+ /**
+  * xa_empty() - Determine if an array has any present entries.
+  * @xa: XArray.
+  *
+  * Context: Any context.
+  * Return: %true if the array contains only NULL pointers.
+  */
+ static inline bool xa_empty(const struct xarray *xa)
+ {
+ 	return xa->xa_head == NULL;
+ }
+ 
+ /**
+  * xa_marked() - Inquire whether any entry in this array has a mark set
+  * @xa: Array
+  * @mark: Mark value
+  *
+  * Context: Any context.
+  * Return: %true if any entry has this mark set.
+  */
+ static inline bool xa_marked(const struct xarray *xa, xa_mark_t mark)
+ {
+ 	return xa->xa_flags & XA_FLAGS_MARK(mark);
+ }
+ 
+ /**
+  * xa_for_each_start() - Iterate over a portion of an XArray.
+  * @xa: XArray.
+  * @index: Index of @entry.
+  * @entry: Entry retrieved from array.
+  * @start: First index to retrieve from array.
+  *
+  * During the iteration, @entry will have the value of the entry stored
+  * in @xa at @index.  You may modify @index during the iteration if you
+  * want to skip or reprocess indices.  It is safe to modify the array
+  * during the iteration.  At the end of the iteration, @entry will be set
+  * to NULL and @index will have a value less than or equal to max.
+  *
+  * xa_for_each_start() is O(n.log(n)) while xas_for_each() is O(n).  You have
+  * to handle your own locking with xas_for_each(), and if you have to unlock
+  * after each iteration, it will also end up being O(n.log(n)).
+  * xa_for_each_start() will spin if it hits a retry entry; if you intend to
+  * see retry entries, you should use the xas_for_each() iterator instead.
+  * The xas_for_each() iterator will expand into more inline code than
+  * xa_for_each_start().
+  *
+  * Context: Any context.  Takes and releases the RCU lock.
+  */
+ #define xa_for_each_start(xa, index, entry, start)			\
+ 	for (index = start,						\
+ 	     entry = xa_find(xa, &index, ULONG_MAX, XA_PRESENT);	\
+ 	     entry;							\
+ 	     entry = xa_find_after(xa, &index, ULONG_MAX, XA_PRESENT))
+ 
+ /**
+  * xa_for_each() - Iterate over present entries in an XArray.
+  * @xa: XArray.
+  * @index: Index of @entry.
+  * @entry: Entry retrieved from array.
+  *
+  * During the iteration, @entry will have the value of the entry stored
+  * in @xa at @index.  You may modify @index during the iteration if you want
+  * to skip or reprocess indices.  It is safe to modify the array during the
+  * iteration.  At the end of the iteration, @entry will be set to NULL and
+  * @index will have a value less than or equal to max.
+  *
+  * xa_for_each() is O(n.log(n)) while xas_for_each() is O(n).  You have
+  * to handle your own locking with xas_for_each(), and if you have to unlock
+  * after each iteration, it will also end up being O(n.log(n)).  xa_for_each()
+  * will spin if it hits a retry entry; if you intend to see retry entries,
+  * you should use the xas_for_each() iterator instead.  The xas_for_each()
+  * iterator will expand into more inline code than xa_for_each().
+  *
+  * Context: Any context.  Takes and releases the RCU lock.
+  */
+ #define xa_for_each(xa, index, entry) \
+ 	xa_for_each_start(xa, index, entry, 0)
+ 
+ /**
+  * xa_for_each_marked() - Iterate over marked entries in an XArray.
+  * @xa: XArray.
+  * @index: Index of @entry.
+  * @entry: Entry retrieved from array.
+  * @filter: Selection criterion.
+  *
+  * During the iteration, @entry will have the value of the entry stored
+  * in @xa at @index.  The iteration will skip all entries in the array
+  * which do not match @filter.  You may modify @index during the iteration
+  * if you want to skip or reprocess indices.  It is safe to modify the array
+  * during the iteration.  At the end of the iteration, @entry will be set to
+  * NULL and @index will have a value less than or equal to max.
+  *
+  * xa_for_each_marked() is O(n.log(n)) while xas_for_each_marked() is O(n).
+  * You have to handle your own locking with xas_for_each(), and if you have
+  * to unlock after each iteration, it will also end up being O(n.log(n)).
+  * xa_for_each_marked() will spin if it hits a retry entry; if you intend to
+  * see retry entries, you should use the xas_for_each_marked() iterator
+  * instead.  The xas_for_each_marked() iterator will expand into more inline
+  * code than xa_for_each_marked().
+  *
+  * Context: Any context.  Takes and releases the RCU lock.
+  */
+ #define xa_for_each_marked(xa, index, entry, filter) \
+ 	for (index = 0, entry = xa_find(xa, &index, ULONG_MAX, filter); \
+ 	     entry; entry = xa_find_after(xa, &index, ULONG_MAX, filter))
++>>>>>>> 4a31896c5b5a (XArray: Change xa_for_each iterator)
  
  #define xa_trylock(xa)		spin_trylock(&(xa)->xa_lock)
  #define xa_lock(xa)		spin_lock(&(xa)->xa_lock)
* Unmerged path lib/test_xarray.c
* Unmerged path include/linux/xarray.h
* Unmerged path lib/test_xarray.c
