mac80211: remove set but not used variable 'old'

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author YueHaibing <yuehaibing@huawei.com>
commit 818e9dfa2c145c7b0d241c5c419f4b897a1af564
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/818e9dfa.failed

Fixes gcc '-Wunused-but-set-variable' warning:

net/mac80211/key.c: In function 'ieee80211_set_tx_key':
net/mac80211/key.c:271:24: warning:
 variable 'old' set but not used [-Wunused-but-set-variable]

It is not used since introduction in
commit 96fc6efb9ad9 ("mac80211: IEEE 802.11 Extended Key ID support")

	Signed-off-by: YueHaibing <yuehaibing@huawei.com>
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 818e9dfa2c145c7b0d241c5c419f4b897a1af564)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/key.c
diff --cc net/mac80211/key.c
index ee0d0cc8dc3b,89f09a09efdb..000000000000
--- a/net/mac80211/key.c
+++ b/net/mac80211/key.c
@@@ -256,8 -262,79 +256,82 @@@ static void ieee80211_key_disable_hw_ac
  			  "failed to remove key (%d, %pM) from hardware (%d)\n",
  			  key->conf.keyidx,
  			  sta ? sta->sta.addr : bcast_addr, ret);
 -}
  
++<<<<<<< HEAD
 +	key->flags &= ~KEY_FLAG_UPLOADED_TO_HARDWARE;
++=======
+ int ieee80211_set_tx_key(struct ieee80211_key *key)
+ {
+ 	struct sta_info *sta = key->sta;
+ 	struct ieee80211_local *local = key->local;
+ 
+ 	assert_key_lock(local);
+ 
+ 	sta->ptk_idx = key->conf.keyidx;
+ 	ieee80211_check_fast_xmit(sta);
+ 
+ 	return 0;
+ }
+ 
+ static int ieee80211_hw_key_replace(struct ieee80211_key *old_key,
+ 				    struct ieee80211_key *new_key,
+ 				    bool pairwise)
+ {
+ 	struct ieee80211_sub_if_data *sdata;
+ 	struct ieee80211_local *local;
+ 	struct sta_info *sta;
+ 	int ret;
+ 
+ 	/* Aggregation sessions are OK when running on SW crypto.
+ 	 * A broken remote STA may cause issues not observed with HW
+ 	 * crypto, though.
+ 	 */
+ 	if (!(old_key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE))
+ 		return 0;
+ 
+ 	assert_key_lock(old_key->local);
+ 	sta = old_key->sta;
+ 
+ 	/* Unicast rekey without Extended Key ID needs special handling */
+ 	if (new_key && sta && pairwise &&
+ 	    rcu_access_pointer(sta->ptk[sta->ptk_idx]) == old_key) {
+ 		local = old_key->local;
+ 		sdata = old_key->sdata;
+ 
+ 		/* Stop TX till we are on the new key */
+ 		old_key->flags |= KEY_FLAG_TAINTED;
+ 		ieee80211_clear_fast_xmit(sta);
+ 
+ 		/* Aggregation sessions during rekey are complicated due to the
+ 		 * reorder buffer and retransmits. Side step that by blocking
+ 		 * aggregation during rekey and tear down running sessions.
+ 		 */
+ 		if (ieee80211_hw_check(&local->hw, AMPDU_AGGREGATION)) {
+ 			set_sta_flag(sta, WLAN_STA_BLOCK_BA);
+ 			ieee80211_sta_tear_down_BA_sessions(sta,
+ 							    AGG_STOP_LOCAL_REQUEST);
+ 		}
+ 
+ 		if (!wiphy_ext_feature_isset(local->hw.wiphy,
+ 					     NL80211_EXT_FEATURE_CAN_REPLACE_PTK0)) {
+ 			pr_warn_ratelimited("Rekeying PTK for STA %pM but driver can't safely do that.",
+ 					    sta->sta.addr);
+ 			/* Flushing the driver queues *may* help prevent
+ 			 * the clear text leaks and freezes.
+ 			 */
+ 			ieee80211_flush_queues(local, sdata, false);
+ 		}
+ 	}
+ 
+ 	ieee80211_key_disable_hw_accel(old_key);
+ 
+ 	if (new_key)
+ 		ret = ieee80211_key_enable_hw_accel(new_key);
+ 	else
+ 		ret = 0;
+ 
+ 	return ret;
++>>>>>>> 818e9dfa2c14 (mac80211: remove set but not used variable 'old')
  }
  
  static void __ieee80211_set_default_key(struct ieee80211_sub_if_data *sdata,
* Unmerged path net/mac80211/key.c
