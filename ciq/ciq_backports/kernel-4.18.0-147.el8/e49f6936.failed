drm/amd/display: use proper formula to calculate bandwidth from timing

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Wenjing Liu <Wenjing.Liu@amd.com>
commit e49f69363adf8920883fff7e8ffecb802d897c6b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/e49f6936.failed

[why]
The existing calculation uses a wrong formula to
calculate bandwidth from timing.

[how]
Expose the existing proper function that calculates the bandwidth,
so dc_link can use it to calculate timing bandwidth correctly.

	Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
	Reviewed-by: Jun Lei <Jun.Lei@amd.com>
	Acked-by: Leo Li <sunpeng.li@amd.com>
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit e49f69363adf8920883fff7e8ffecb802d897c6b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/display/dc/core/dc_link.c
#	drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
diff --cc drivers/gpu/drm/amd/display/dc/core/dc_link.c
index 2fa521812d23,abf611538153..000000000000
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link.c
@@@ -2146,7 -2321,7 +2146,11 @@@ static struct fixed31_32 get_pbn_from_t
  	uint32_t denominator;
  
  	bpc = get_color_depth(pipe_ctx->stream_res.pix_clk_params.color_depth);
++<<<<<<< HEAD
 +	kbps = pipe_ctx->stream_res.pix_clk_params.requested_pix_clk * bpc * 3;
++=======
+ 	kbps = dc_bandwidth_in_kbps_from_timing(&pipe_ctx->stream->timing);
++>>>>>>> e49f69363adf (drm/amd/display: use proper formula to calculate bandwidth from timing)
  
  	/*
  	 * margin 5300ppm + 300ppm ~ 0.6% as per spec, factor is 1.006
diff --cc drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
index bdd121485cbc,491d13d27e9e..000000000000
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
@@@ -1373,53 -1533,6 +1373,56 @@@ static bool decide_fallback_link_settin
  	return true;
  }
  
++<<<<<<< HEAD
 +static uint32_t bandwidth_in_kbps_from_timing(
 +	const struct dc_crtc_timing *timing)
 +{
 +	uint32_t bits_per_channel = 0;
 +	uint32_t kbps;
 +
 +	switch (timing->display_color_depth) {
 +	case COLOR_DEPTH_666:
 +		bits_per_channel = 6;
 +		break;
 +	case COLOR_DEPTH_888:
 +		bits_per_channel = 8;
 +		break;
 +	case COLOR_DEPTH_101010:
 +		bits_per_channel = 10;
 +		break;
 +	case COLOR_DEPTH_121212:
 +		bits_per_channel = 12;
 +		break;
 +	case COLOR_DEPTH_141414:
 +		bits_per_channel = 14;
 +		break;
 +	case COLOR_DEPTH_161616:
 +		bits_per_channel = 16;
 +		break;
 +	default:
 +		break;
 +	}
 +
 +	ASSERT(bits_per_channel != 0);
 +
 +	kbps = timing->pix_clk_khz;
 +	kbps *= bits_per_channel;
 +
 +	if (timing->flags.Y_ONLY != 1) {
 +		/*Only YOnly make reduce bandwidth by 1/3 compares to RGB*/
 +		kbps *= 3;
 +		if (timing->pixel_encoding == PIXEL_ENCODING_YCBCR420)
 +			kbps /= 2;
 +		else if (timing->pixel_encoding == PIXEL_ENCODING_YCBCR422)
 +			kbps = kbps * 2 / 3;
 +	}
 +
 +	return kbps;
 +
 +}
 +
++=======
++>>>>>>> e49f69363adf (drm/amd/display: use proper formula to calculate bandwidth from timing)
  static uint32_t bandwidth_in_kbps_from_link_settings(
  	const struct dc_link_settings *link_setting)
  {
@@@ -1481,47 -1595,14 +1484,47 @@@ bool dp_validate_mode_timing
  		return false;
  }
  
 -static bool decide_dp_link_settings(struct dc_link *link, struct dc_link_settings *link_setting, uint32_t req_bw)
 +void decide_link_settings(struct dc_stream_state *stream,
 +	struct dc_link_settings *link_setting)
  {
 +
  	struct dc_link_settings initial_link_setting = {
 -		LANE_COUNT_ONE, LINK_RATE_LOW, LINK_SPREAD_DISABLED, false, 0};
 +		LANE_COUNT_ONE, LINK_RATE_LOW, LINK_SPREAD_DISABLED};
  	struct dc_link_settings current_link_setting =
  			initial_link_setting;
 +	struct dc_link *link;
 +	uint32_t req_bw;
  	uint32_t link_bw;
  
- 	req_bw = bandwidth_in_kbps_from_timing(&stream->timing);
++	req_bw = dc_bandwidth_in_kbps_from_timing(&stream->timing);
 +
 +	link = stream->sink->link;
 +
 +	/* if preferred is specified through AMDDP, use it, if it's enough
 +	 * to drive the mode
 +	 */
 +	if (link->preferred_link_setting.lane_count !=
 +			LANE_COUNT_UNKNOWN &&
 +			link->preferred_link_setting.link_rate !=
 +					LINK_RATE_UNKNOWN) {
 +		*link_setting =  link->preferred_link_setting;
 +		return;
 +	}
 +
 +	/* MST doesn't perform link training for now
 +	 * TODO: add MST specific link training routine
 +	 */
 +	if (stream->signal == SIGNAL_TYPE_DISPLAY_PORT_MST) {
 +		*link_setting = link->verified_link_cap;
 +		return;
 +	}
 +
 +	/* EDP use the link cap setting */
 +	if (stream->sink->sink_signal == SIGNAL_TYPE_EDP) {
 +		*link_setting = link->verified_link_cap;
 +		return;
 +	}
 +
  	/* search for the minimum link setting that:
  	 * 1. is supported according to the link training result
  	 * 2. could support the b/w requested by the timing
* Unmerged path drivers/gpu/drm/amd/display/dc/core/dc_link.c
* Unmerged path drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
diff --git a/drivers/gpu/drm/amd/display/dc/dc_link.h b/drivers/gpu/drm/amd/display/dc/dc_link.h
index 8a716baa1203..f752bb12da3b 100644
--- a/drivers/gpu/drm/amd/display/dc/dc_link.h
+++ b/drivers/gpu/drm/amd/display/dc/dc_link.h
@@ -219,4 +219,6 @@ bool dc_submit_i2c(
 		uint32_t link_index,
 		struct i2c_command *cmd);
 
+uint32_t dc_bandwidth_in_kbps_from_timing(
+	const struct dc_crtc_timing *timing);
 #endif /* DC_LINK_H_ */
