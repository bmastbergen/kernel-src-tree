psi: make disabling/enabling easier for vendor kernels

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Johannes Weiner <hannes@cmpxchg.org>
commit e0c274472d5d27f277af722e017525e0b33784cd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/e0c27447.failed

Mel Gorman reports a hackbench regression with psi that would prohibit
shipping the suse kernel with it default-enabled, but he'd still like
users to be able to opt in at little to no cost to others.

With the current combination of CONFIG_PSI and the psi_disabled bool set
from the commandline, this is a challenge.  Do the following things to
make it easier:

1. Add a config option CONFIG_PSI_DEFAULT_DISABLED that allows distros
   to enable CONFIG_PSI in their kernel but leave the feature disabled
   unless a user requests it at boot-time.

   To avoid double negatives, rename psi_disabled= to psi=.

2. Make psi_disabled a static branch to eliminate any branch costs
   when the feature is disabled.

In terms of numbers before and after this patch, Mel says:

: The following is a comparision using CONFIG_PSI=n as a baseline against
: your patch and a vanilla kernel
:
:                          4.20.0-rc4             4.20.0-rc4             4.20.0-rc4
:                 kconfigdisable-v1r1                vanilla        psidisable-v1r1
: Amean     1       1.3100 (   0.00%)      1.3923 (  -6.28%)      1.3427 (  -2.49%)
: Amean     3       3.8860 (   0.00%)      4.1230 *  -6.10%*      3.8860 (  -0.00%)
: Amean     5       6.8847 (   0.00%)      8.0390 * -16.77%*      6.7727 (   1.63%)
: Amean     7       9.9310 (   0.00%)     10.8367 *  -9.12%*      9.9910 (  -0.60%)
: Amean     12     16.6577 (   0.00%)     18.2363 *  -9.48%*     17.1083 (  -2.71%)
: Amean     18     26.5133 (   0.00%)     27.8833 *  -5.17%*     25.7663 (   2.82%)
: Amean     24     34.3003 (   0.00%)     34.6830 (  -1.12%)     32.0450 (   6.58%)
: Amean     30     40.0063 (   0.00%)     40.5800 (  -1.43%)     41.5087 (  -3.76%)
: Amean     32     40.1407 (   0.00%)     41.2273 (  -2.71%)     39.9417 (   0.50%)
:
: It's showing that the vanilla kernel takes a hit (as the bisection
: indicated it would) and that disabling PSI by default is reasonably
: close in terms of performance for this particular workload on this
: particular machine so;

Link: http://lkml.kernel.org/r/20181127165329.GA29728@cmpxchg.org
	Signed-off-by: Johannes Weiner <hannes@cmpxchg.org>
	Tested-by: Mel Gorman <mgorman@techsingularity.net>
	Reported-by: Mel Gorman <mgorman@techsingularity.net>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit e0c274472d5d27f277af722e017525e0b33784cd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/psi.h
#	init/Kconfig
#	kernel/sched/psi.c
#	kernel/sched/stats.h
diff --cc init/Kconfig
index 4e3ceb921310,cf5b5a0dcbc2..000000000000
--- a/init/Kconfig
+++ b/init/Kconfig
@@@ -473,6 -490,34 +473,37 @@@ config TASK_IO_ACCOUNTIN
  
  	  Say N if unsure.
  
++<<<<<<< HEAD
++=======
+ config PSI
+ 	bool "Pressure stall information tracking"
+ 	help
+ 	  Collect metrics that indicate how overcommitted the CPU, memory,
+ 	  and IO capacity are in the system.
+ 
+ 	  If you say Y here, the kernel will create /proc/pressure/ with the
+ 	  pressure statistics files cpu, memory, and io. These will indicate
+ 	  the share of walltime in which some or all tasks in the system are
+ 	  delayed due to contention of the respective resource.
+ 
+ 	  In kernels with cgroup support, cgroups (cgroup2 only) will
+ 	  have cpu.pressure, memory.pressure, and io.pressure files,
+ 	  which aggregate pressure stalls for the grouped tasks only.
+ 
+ 	  For more details see Documentation/accounting/psi.txt.
+ 
+ 	  Say N if unsure.
+ 
+ config PSI_DEFAULT_DISABLED
+ 	bool "Require boot parameter to enable pressure stall information tracking"
+ 	default n
+ 	depends on PSI
+ 	help
+ 	  If set, pressure stall information tracking will be disabled
+ 	  per default but can be enabled through passing psi_enable=1
+ 	  on the kernel commandline during boot.
+ 
++>>>>>>> e0c274472d5d (psi: make disabling/enabling easier for vendor kernels)
  endmenu # "CPU/Task time and stats accounting"
  
  config CPU_ISOLATION
diff --cc kernel/sched/stats.h
index 8aea199a39b4,aa0de240fb41..000000000000
--- a/kernel/sched/stats.h
+++ b/kernel/sched/stats.h
@@@ -55,6 -55,92 +55,95 @@@ static inline void rq_sched_info_depar
  # define   schedstat_val_or_zero(var)	0
  #endif /* CONFIG_SCHEDSTATS */
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_PSI
+ /*
+  * PSI tracks state that persists across sleeps, such as iowaits and
+  * memory stalls. As a result, it has to distinguish between sleeps,
+  * where a task's runnable state changes, and requeues, where a task
+  * and its state are being moved between CPUs and runqueues.
+  */
+ static inline void psi_enqueue(struct task_struct *p, bool wakeup)
+ {
+ 	int clear = 0, set = TSK_RUNNING;
+ 
+ 	if (static_branch_likely(&psi_disabled))
+ 		return;
+ 
+ 	if (!wakeup || p->sched_psi_wake_requeue) {
+ 		if (p->flags & PF_MEMSTALL)
+ 			set |= TSK_MEMSTALL;
+ 		if (p->sched_psi_wake_requeue)
+ 			p->sched_psi_wake_requeue = 0;
+ 	} else {
+ 		if (p->in_iowait)
+ 			clear |= TSK_IOWAIT;
+ 	}
+ 
+ 	psi_task_change(p, clear, set);
+ }
+ 
+ static inline void psi_dequeue(struct task_struct *p, bool sleep)
+ {
+ 	int clear = TSK_RUNNING, set = 0;
+ 
+ 	if (static_branch_likely(&psi_disabled))
+ 		return;
+ 
+ 	if (!sleep) {
+ 		if (p->flags & PF_MEMSTALL)
+ 			clear |= TSK_MEMSTALL;
+ 	} else {
+ 		if (p->in_iowait)
+ 			set |= TSK_IOWAIT;
+ 	}
+ 
+ 	psi_task_change(p, clear, set);
+ }
+ 
+ static inline void psi_ttwu_dequeue(struct task_struct *p)
+ {
+ 	if (static_branch_likely(&psi_disabled))
+ 		return;
+ 	/*
+ 	 * Is the task being migrated during a wakeup? Make sure to
+ 	 * deregister its sleep-persistent psi states from the old
+ 	 * queue, and let psi_enqueue() know it has to requeue.
+ 	 */
+ 	if (unlikely(p->in_iowait || (p->flags & PF_MEMSTALL))) {
+ 		struct rq_flags rf;
+ 		struct rq *rq;
+ 		int clear = 0;
+ 
+ 		if (p->in_iowait)
+ 			clear |= TSK_IOWAIT;
+ 		if (p->flags & PF_MEMSTALL)
+ 			clear |= TSK_MEMSTALL;
+ 
+ 		rq = __task_rq_lock(p, &rf);
+ 		psi_task_change(p, clear, 0);
+ 		p->sched_psi_wake_requeue = 1;
+ 		__task_rq_unlock(rq, &rf);
+ 	}
+ }
+ 
+ static inline void psi_task_tick(struct rq *rq)
+ {
+ 	if (static_branch_likely(&psi_disabled))
+ 		return;
+ 
+ 	if (unlikely(rq->curr->flags & PF_MEMSTALL))
+ 		psi_memstall_tick(rq->curr, cpu_of(rq));
+ }
+ #else /* CONFIG_PSI */
+ static inline void psi_enqueue(struct task_struct *p, bool wakeup) {}
+ static inline void psi_dequeue(struct task_struct *p, bool sleep) {}
+ static inline void psi_ttwu_dequeue(struct task_struct *p) {}
+ static inline void psi_task_tick(struct rq *rq) {}
+ #endif /* CONFIG_PSI */
+ 
++>>>>>>> e0c274472d5d (psi: make disabling/enabling easier for vendor kernels)
  #ifdef CONFIG_SCHED_INFO
  static inline void sched_info_reset_dequeued(struct task_struct *t)
  {
* Unmerged path include/linux/psi.h
* Unmerged path kernel/sched/psi.c
diff --git a/Documentation/admin-guide/kernel-parameters.txt b/Documentation/admin-guide/kernel-parameters.txt
index d0adba196d02..cd9ceb30fc63 100644
--- a/Documentation/admin-guide/kernel-parameters.txt
+++ b/Documentation/admin-guide/kernel-parameters.txt
@@ -3568,6 +3568,10 @@
 			before loading.
 			See Documentation/blockdev/ramdisk.txt.
 
+	psi=		[KNL] Enable or disable pressure stall information
+			tracking.
+			Format: <bool>
+
 	psmouse.proto=	[HW,MOUSE] Highest PS2 mouse protocol extension to
 			probe for; one of (bare|imps|exps|lifebook|any).
 	psmouse.rate=	[HW,MOUSE] Set desired mouse report rate, in reports
* Unmerged path include/linux/psi.h
* Unmerged path init/Kconfig
* Unmerged path kernel/sched/psi.c
* Unmerged path kernel/sched/stats.h
