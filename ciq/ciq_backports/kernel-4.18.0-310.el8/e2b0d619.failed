x86, sched: check for counters overflow in frequency invariant accounting

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Giovanni Gherdovich <ggherdovich@suse.cz>
commit e2b0d619b400ae326f954a018a1d65d736c237c5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/e2b0d619.failed

The product mcnt * arch_max_freq_ratio can overflows u64.

For context, a large value for arch_max_freq_ratio would be 5000,
corresponding to a turbo_freq/base_freq ratio of 5 (normally it's more like
1500-2000). A large increment frequency for the MPERF counter would be 5GHz
(the base clock of all CPUs on the market today is less than that). With
these figures, a CPU would need to go without a scheduler tick for around 8
days for the u64 overflow to happen. It is unlikely, but the check is
warranted.

Under similar conditions, the difference acnt of two consecutive APERF
readings can overflow as well.

In these circumstances is appropriate to disable frequency invariant
accounting: the feature relies on measures of the clock frequency done at
every scheduler tick, which need to be "fresh" to be at all meaningful.

A note on i386: prior to version 5.1, the GCC compiler didn't have the
builtin function __builtin_mul_overflow. In these GCC versions the macro
check_mul_overflow needs __udivdi3() to do (u64)a/b, which the kernel
doesn't provide. For this reason this change fails to build on i386 if
GCC<5.1, and we protect the entire frequency invariant code behind
CONFIG_X86_64 (special thanks to "kbuild test robot" <lkp@intel.com>).

Fixes: 1567c3e3467c ("x86, sched: Add support for frequency invariance")
	Signed-off-by: Giovanni Gherdovich <ggherdovich@suse.cz>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Link: https://lkml.kernel.org/r/20200531182453.15254-2-ggherdovich@suse.cz
(cherry picked from commit e2b0d619b400ae326f954a018a1d65d736c237c5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/smpboot.c
diff --cc arch/x86/kernel/smpboot.c
index 994d970d6d78,18d292fc466c..000000000000
--- a/arch/x86/kernel/smpboot.c
+++ b/arch/x86/kernel/smpboot.c
@@@ -57,6 -55,8 +57,11 @@@
  #include <linux/gfp.h>
  #include <linux/cpuidle.h>
  #include <linux/numa.h>
++<<<<<<< HEAD
++=======
+ #include <linux/pgtable.h>
+ #include <linux/overflow.h>
++>>>>>>> e2b0d619b400 (x86, sched: check for counters overflow in frequency invariant accounting)
  
  #include <asm/acpi.h>
  #include <asm/desc.h>
diff --git a/arch/x86/include/asm/topology.h b/arch/x86/include/asm/topology.h
index cdf7aedf4232..625627ab2d05 100644
--- a/arch/x86/include/asm/topology.h
+++ b/arch/x86/include/asm/topology.h
@@ -195,7 +195,7 @@ static inline void sched_clear_itmt_support(void)
 }
 #endif /* CONFIG_SCHED_MC_PRIO */
 
-#ifdef CONFIG_SMP
+#if defined(CONFIG_SMP) && defined(CONFIG_X86_64)
 #include <asm/cpufeature.h>
 
 DECLARE_STATIC_KEY_FALSE(arch_scale_freq_key);
* Unmerged path arch/x86/kernel/smpboot.c
