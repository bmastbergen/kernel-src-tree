nvme-core: remove extra condition for vwc

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Chaitanya Kulkarni <chaitanya.kulkarni@wdc.com>
commit c4485252cf36ae62c8bf12c4aede72345cad0d2b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/c4485252.failed

In nvme_set_queue_limits() we initialize vwc to false and later add
a condition to set vwc true. The value of the vwc can be declare
initialized which makes all the blk_queue_XXX() calls uniform.

	Signed-off-by: Chaitanya Kulkarni <chaitanya.kulkarni@wdc.com>
	Reviewed-by: Keith Busch <kbusch@kernel.org>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit c4485252cf36ae62c8bf12c4aede72345cad0d2b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
diff --cc drivers/nvme/host/core.c
index 61e952b9cd65,e85f6304efd7..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -1962,6 -1923,68 +1962,71 @@@ static int nvme_setup_streams_ns(struc
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int nvme_configure_metadata(struct nvme_ns *ns, struct nvme_id_ns *id)
+ {
+ 	struct nvme_ctrl *ctrl = ns->ctrl;
+ 
+ 	/*
+ 	 * The PI implementation requires the metadata size to be equal to the
+ 	 * t10 pi tuple size.
+ 	 */
+ 	ns->ms = le16_to_cpu(id->lbaf[id->flbas & NVME_NS_FLBAS_LBA_MASK].ms);
+ 	if (ns->ms == sizeof(struct t10_pi_tuple))
+ 		ns->pi_type = id->dps & NVME_NS_DPS_PI_MASK;
+ 	else
+ 		ns->pi_type = 0;
+ 
+ 	ns->features &= ~(NVME_NS_METADATA_SUPPORTED | NVME_NS_EXT_LBAS);
+ 	if (!ns->ms || !(ctrl->ops->flags & NVME_F_METADATA_SUPPORTED))
+ 		return 0;
+ 	if (ctrl->ops->flags & NVME_F_FABRICS) {
+ 		/*
+ 		 * The NVMe over Fabrics specification only supports metadata as
+ 		 * part of the extended data LBA.  We rely on HCA/HBA support to
+ 		 * remap the separate metadata buffer from the block layer.
+ 		 */
+ 		if (WARN_ON_ONCE(!(id->flbas & NVME_NS_FLBAS_META_EXT)))
+ 			return -EINVAL;
+ 		if (ctrl->max_integrity_segments)
+ 			ns->features |=
+ 				(NVME_NS_METADATA_SUPPORTED | NVME_NS_EXT_LBAS);
+ 	} else {
+ 		/*
+ 		 * For PCIe controllers, we can't easily remap the separate
+ 		 * metadata buffer from the block layer and thus require a
+ 		 * separate metadata buffer for block layer metadata/PI support.
+ 		 * We allow extended LBAs for the passthrough interface, though.
+ 		 */
+ 		if (id->flbas & NVME_NS_FLBAS_META_EXT)
+ 			ns->features |= NVME_NS_EXT_LBAS;
+ 		else
+ 			ns->features |= NVME_NS_METADATA_SUPPORTED;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void nvme_set_queue_limits(struct nvme_ctrl *ctrl,
+ 		struct request_queue *q)
+ {
+ 	bool vwc = ctrl->vwc & NVME_CTRL_VWC_PRESENT;
+ 
+ 	if (ctrl->max_hw_sectors) {
+ 		u32 max_segments =
+ 			(ctrl->max_hw_sectors / (NVME_CTRL_PAGE_SIZE >> 9)) + 1;
+ 
+ 		max_segments = min_not_zero(max_segments, ctrl->max_segments);
+ 		blk_queue_max_hw_sectors(q, ctrl->max_hw_sectors);
+ 		blk_queue_max_segments(q, min_t(u32, max_segments, USHRT_MAX));
+ 	}
+ 	blk_queue_virt_boundary(q, NVME_CTRL_PAGE_SIZE - 1);
+ 	blk_queue_dma_alignment(q, 7);
+ 	blk_queue_write_cache(q, vwc, vwc);
+ }
+ 
++>>>>>>> c4485252cf36 (nvme-core: remove extra condition for vwc)
  static void nvme_update_disk_info(struct gendisk *disk,
  		struct nvme_ns *ns, struct nvme_id_ns *id)
  {
* Unmerged path drivers/nvme/host/core.c
