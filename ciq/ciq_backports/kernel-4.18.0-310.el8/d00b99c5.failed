KVM: SVM: Add support for Virtual SPEC_CTRL

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Babu Moger <babu.moger@amd.com>
commit d00b99c514b33a3f40dbb3e730b14a283401aa8e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/d00b99c5.failed

Newer AMD processors have a feature to virtualize the use of the
SPEC_CTRL MSR. Presence of this feature is indicated via CPUID
function 0x8000000A_EDX[20]: GuestSpecCtrl. Hypervisors are not
required to enable this feature since it is automatically enabled on
processors that support it.

A hypervisor may wish to impose speculation controls on guest
execution or a guest may want to impose its own speculation controls.
Therefore, the processor implements both host and guest
versions of SPEC_CTRL.

When in host mode, the host SPEC_CTRL value is in effect and writes
update only the host version of SPEC_CTRL. On a VMRUN, the processor
loads the guest version of SPEC_CTRL from the VMCB. When the guest
writes SPEC_CTRL, only the guest version is updated. On a VMEXIT,
the guest version is saved into the VMCB and the processor returns
to only using the host SPEC_CTRL for speculation control. The guest
SPEC_CTRL is located at offset 0x2E0 in the VMCB.

The effective SPEC_CTRL setting is the guest SPEC_CTRL setting or'ed
with the hypervisor SPEC_CTRL setting. This allows the hypervisor to
ensure a minimum SPEC_CTRL if desired.

This support also fixes an issue where a guest may sometimes see an
inconsistent value for the SPEC_CTRL MSR on processors that support
this feature. With the current SPEC_CTRL support, the first write to
SPEC_CTRL is intercepted and the virtualized version of the SPEC_CTRL
MSR is not updated. When the guest reads back the SPEC_CTRL MSR, it
will be 0x0, instead of the actual expected value. There isn’t a
security concern here, because the host SPEC_CTRL value is or’ed with
the Guest SPEC_CTRL value to generate the effective SPEC_CTRL value.
KVM writes with the guest's virtualized SPEC_CTRL value to SPEC_CTRL
MSR just before the VMRUN, so it will always have the actual value
even though it doesn’t appear that way in the guest. The guest will
only see the proper value for the SPEC_CTRL register if the guest was
to write to the SPEC_CTRL register again. With Virtual SPEC_CTRL
support, the save area spec_ctrl is properly saved and restored.
So, the guest will always see the proper value when it is read back.

	Signed-off-by: Babu Moger <babu.moger@amd.com>
Message-Id: <161188100955.28787.11816849358413330720.stgit@bmoger-ubuntu>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit d00b99c514b33a3f40dbb3e730b14a283401aa8e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/svm.h
#	arch/x86/kvm/svm/nested.c
#	arch/x86/kvm/svm/svm.c
diff --cc arch/x86/include/asm/svm.h
index 1edf24f51b53,772e60efe243..000000000000
--- a/arch/x86/include/asm/svm.h
+++ b/arch/x86/include/asm/svm.h
@@@ -251,9 -266,14 +251,17 @@@ struct vmcb_save_area 
  
  	/*
  	 * The following part of the save area is valid only for
 -	 * SEV-ES guests when referenced through the GHCB or for
 -	 * saving to the host save area.
 +	 * SEV-ES guests when referenced through the GHCB.
  	 */
++<<<<<<< HEAD
 +	u8 reserved_7[104];
++=======
+ 	u8 reserved_7[72];
+ 	u32 spec_ctrl;		/* Guest version of SPEC_CTRL at 0x2E0 */
+ 	u8 reserved_7b[4];
+ 	u32 pkru;
+ 	u8 reserved_7a[20];
++>>>>>>> d00b99c514b3 (KVM: SVM: Add support for Virtual SPEC_CTRL)
  	u64 reserved_8;		/* rax already available at 0x01f8 */
  	u64 rcx;
  	u64 rdx;
diff --cc arch/x86/kvm/svm/nested.c
index e8796fbe795c,c8ed267b76f0..000000000000
--- a/arch/x86/kvm/svm/nested.c
+++ b/arch/x86/kvm/svm/nested.c
@@@ -464,9 -512,22 +464,25 @@@ static void nested_prepare_vmcb_control
  	recalc_intercepts(svm);
  }
  
++<<<<<<< HEAD
 +int enter_svm_guest_mode(struct vcpu_svm *svm, u64 vmcb12_gpa,
++=======
+ static void nested_svm_copy_common_state(struct vmcb *from_vmcb, struct vmcb *to_vmcb)
+ {
+ 	/*
+ 	 * Some VMCB state is shared between L1 and L2 and thus has to be
+ 	 * moved at the time of nested vmrun and vmexit.
+ 	 *
+ 	 * VMLOAD/VMSAVE state would also belong in this category, but KVM
+ 	 * always performs VMLOAD and VMSAVE from the VMCB01.
+ 	 */
+ 	to_vmcb->save.spec_ctrl = from_vmcb->save.spec_ctrl;
+ }
+ 
+ int enter_svm_guest_mode(struct kvm_vcpu *vcpu, u64 vmcb12_gpa,
++>>>>>>> d00b99c514b3 (KVM: SVM: Add support for Virtual SPEC_CTRL)
  			 struct vmcb *vmcb12)
  {
 -	struct vcpu_svm *svm = to_svm(vcpu);
  	int ret;
  
  	trace_kvm_nested_vmrun(svm->vmcb->save.rip, vmcb12_gpa,
@@@ -484,9 -545,15 +500,21 @@@
  
  
  	svm->nested.vmcb12_gpa = vmcb12_gpa;
++<<<<<<< HEAD
 +	load_nested_vmcb_control(svm, &vmcb12->control);
 +	nested_prepare_vmcb_save(svm, vmcb12);
 +	nested_prepare_vmcb_control(svm);
++=======
+ 
+ 	WARN_ON(svm->vmcb == svm->nested.vmcb02.ptr);
+ 
+ 	nested_svm_copy_common_state(svm->vmcb01.ptr, svm->nested.vmcb02.ptr);
+ 	nested_load_control_from_vmcb12(svm, &vmcb12->control);
+ 
+ 	svm_switch_vmcb(svm, &svm->nested.vmcb02);
+ 	nested_vmcb02_prepare_control(svm);
+ 	nested_vmcb02_prepare_save(svm, vmcb12);
++>>>>>>> d00b99c514b3 (KVM: SVM: Add support for Virtual SPEC_CTRL)
  
  	ret = nested_svm_load_cr3(&svm->vcpu, vmcb12->save.cr3,
  				  nested_npt_enabled(svm));
@@@ -677,11 -738,16 +705,17 @@@ int nested_svm_vmexit(struct vcpu_svm *
  	vmcb12->control.pause_filter_thresh =
  		svm->vmcb->control.pause_filter_thresh;
  
++<<<<<<< HEAD
 +	/* Restore the original control entries */
 +	copy_vmcb_control_area(&vmcb->control, &hsave->control);
++=======
+ 	nested_svm_copy_common_state(svm->nested.vmcb02.ptr, svm->vmcb01.ptr);
+ 
+ 	svm_switch_vmcb(svm, &svm->vmcb01);
++>>>>>>> d00b99c514b3 (KVM: SVM: Add support for Virtual SPEC_CTRL)
  
 -	/*
 -	 * On vmexit the  GIF is set to false and
 -	 * no event can be injected in L1.
 -	 */
 +	/* On vmexit the  GIF is set to false */
  	svm_set_gif(svm, false);
 -	svm->vmcb->control.exit_int_info = 0;
  
  	svm->vcpu.arch.tsc_offset = svm->vcpu.arch.l1_tsc_offset;
  	if (svm->vmcb->control.tsc_offset != svm->vcpu.arch.tsc_offset) {
diff --cc arch/x86/kvm/svm/svm.c
index dd9e65c2714d,40e520a98fbc..000000000000
--- a/arch/x86/kvm/svm/svm.c
+++ b/arch/x86/kvm/svm/svm.c
@@@ -1251,7 -1247,14 +1251,18 @@@ static void init_vmcb(struct vcpu_svm *
  
  	svm_check_invpcid(svm);
  
++<<<<<<< HEAD
 +	if (kvm_vcpu_apicv_active(&svm->vcpu))
++=======
+ 	/*
+ 	 * If the host supports V_SPEC_CTRL then disable the interception
+ 	 * of MSR_IA32_SPEC_CTRL.
+ 	 */
+ 	if (boot_cpu_has(X86_FEATURE_V_SPEC_CTRL))
+ 		set_msr_interception(vcpu, svm->msrpm, MSR_IA32_SPEC_CTRL, 1, 1);
+ 
+ 	if (kvm_vcpu_apicv_active(vcpu))
++>>>>>>> d00b99c514b3 (KVM: SVM: Add support for Virtual SPEC_CTRL)
  		avic_init_vmcb(svm);
  
  	/*
@@@ -3726,18 -3815,10 +3743,19 @@@ static fastpath_t svm_vcpu_run(struct k
  	 * is no need to worry about the conditional branch over the wrmsr
  	 * being speculatively taken.
  	 */
- 	x86_spec_ctrl_set_guest(svm->spec_ctrl, svm->virt_spec_ctrl);
+ 	if (!static_cpu_has(X86_FEATURE_V_SPEC_CTRL))
+ 		x86_spec_ctrl_set_guest(svm->spec_ctrl, svm->virt_spec_ctrl);
  
 -	svm_vcpu_enter_exit(vcpu);
 +	__svm_vcpu_run(svm->vmcb_pa, (unsigned long *)&svm->vcpu.arch.regs);
 +
 +#ifdef CONFIG_X86_64
 +	wrmsrl(MSR_GS_BASE, svm->host.gs_base);
 +#else
 +	loadsegment(fs, svm->host.fs);
 +#ifndef CONFIG_X86_32_LAZY_GS
 +	loadsegment(gs, svm->host.gs);
 +#endif
 +#endif
  
  	/*
  	 * We do not use IBRS in the kernel. If this vCPU has used the
@@@ -3754,20 -3835,25 +3772,22 @@@
  	 * If the L02 MSR bitmap does not intercept the MSR, then we need to
  	 * save it.
  	 */
- 	if (unlikely(!msr_write_intercepted(vcpu, MSR_IA32_SPEC_CTRL)))
+ 	if (!static_cpu_has(X86_FEATURE_V_SPEC_CTRL) &&
+ 	    unlikely(!msr_write_intercepted(vcpu, MSR_IA32_SPEC_CTRL)))
  		svm->spec_ctrl = native_read_msr(MSR_IA32_SPEC_CTRL);
  
 -	if (!sev_es_guest(vcpu->kvm))
 -		reload_tss(vcpu);
 +	reload_tss(vcpu);
  
- 	x86_spec_ctrl_restore_host(svm->spec_ctrl, svm->virt_spec_ctrl);
+ 	if (!static_cpu_has(X86_FEATURE_V_SPEC_CTRL))
+ 		x86_spec_ctrl_restore_host(svm->spec_ctrl, svm->virt_spec_ctrl);
  
 -	if (!sev_es_guest(vcpu->kvm)) {
 -		vcpu->arch.cr2 = svm->vmcb->save.cr2;
 -		vcpu->arch.regs[VCPU_REGS_RAX] = svm->vmcb->save.rax;
 -		vcpu->arch.regs[VCPU_REGS_RSP] = svm->vmcb->save.rsp;
 -		vcpu->arch.regs[VCPU_REGS_RIP] = svm->vmcb->save.rip;
 -	}
 +	vcpu->arch.cr2 = svm->vmcb->save.cr2;
 +	vcpu->arch.regs[VCPU_REGS_RAX] = svm->vmcb->save.rax;
 +	vcpu->arch.regs[VCPU_REGS_RSP] = svm->vmcb->save.rsp;
 +	vcpu->arch.regs[VCPU_REGS_RIP] = svm->vmcb->save.rip;
  
  	if (unlikely(svm->vmcb->control.exit_code == SVM_EXIT_NMI))
 -		kvm_before_interrupt(vcpu);
 +		kvm_before_interrupt(&svm->vcpu);
  
  	kvm_load_host_xsave_state(vcpu);
  	stgi();
* Unmerged path arch/x86/include/asm/svm.h
* Unmerged path arch/x86/kvm/svm/nested.c
* Unmerged path arch/x86/kvm/svm/svm.c
