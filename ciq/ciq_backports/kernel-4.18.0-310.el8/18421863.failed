docs: cgroup-v1: reflect the deprecation of the non-hierarchical mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Roman Gushchin <guro@fb.com>
commit 184218639a6f2a1cb84cf3ba583cee93a3ff4b81
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/18421863.failed

Update cgroup v1 docs after the deprecation of the non-hierarchical mode
of the memory controller.

Link: https://lkml.kernel.org/r/20201110220800.929549-3-guro@fb.com
	Signed-off-by: Roman Gushchin <guro@fb.com>
	Reviewed-by: Shakeel Butt <shakeelb@google.com>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Acked-by: David Rientjes <rientjes@google.com>
	Acked-by: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Tejun Heo <tj@kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 184218639a6f2a1cb84cf3ba583cee93a3ff4b81)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/cgroup-v1/memcg_test.txt
#	Documentation/cgroup-v1/memory.txt
diff --cc Documentation/cgroup-v1/memcg_test.txt
index 621e29ffb358,4f83de2dab6e..000000000000
--- a/Documentation/cgroup-v1/memcg_test.txt
+++ b/Documentation/cgroup-v1/memcg_test.txt
@@@ -151,46 -187,55 +151,56 @@@ Under below explanation, we assume CONF
  
  	In above set, when you moves a task from 01 to 02, page migration to
  	node 0 to node 1 will occur. Following is a script to migrate all
 -	under cpuset.::
 -
 -		--
 -		move_task()
 -		{
 -		for pid in $1
 -		do
 -			/bin/echo $pid >$2/tasks 2>/dev/null
 -			echo -n $pid
 -			echo -n " "
 -		done
 -		echo END
 -		}
 -
 -		G1_TASK=`cat ${G1}/tasks`
 -		G2_TASK=`cat ${G2}/tasks`
 -		move_task "${G1_TASK}" ${G2} &
 -		--
 -
 -9.4 Memory hotplug
 -------------------
 -
 +	under cpuset.
 +	--
 +	move_task()
 +	{
 +	for pid in $1
 +        do
 +                /bin/echo $pid >$2/tasks 2>/dev/null
 +		echo -n $pid
 +		echo -n " "
 +        done
 +	echo END
 +	}
 +
 +	G1_TASK=`cat ${G1}/tasks`
 +	G2_TASK=`cat ${G2}/tasks`
 +	move_task "${G1_TASK}" ${G2} &
 +	--
 + 9.4 Memory hotplug.
  	memory hotplug test is one of good test.
 -
 -	to offline memory, do following::
 -
 -		# echo offline > /sys/devices/system/memory/memoryXXX/state
 -
 +	to offline memory, do following.
 +	# echo offline > /sys/devices/system/memory/memoryXXX/state
  	(XXX is the place of memory)
 -
  	This is an easy way to test page migration, too.
  
++<<<<<<< HEAD:Documentation/cgroup-v1/memcg_test.txt
 + 9.5 mkdir/rmdir
 +	When using hierarchy, mkdir/rmdir test should be done.
 +	Use tests like the following.
 +
 +	echo 1 >/opt/cgroup/01/memory/use_hierarchy
 +	mkdir /opt/cgroup/01/child_a
 +	mkdir /opt/cgroup/01/child_b
++=======
+ 9.5 nested cgroups
+ ------------------
+ 
+ 	Use tests like the following for testing nested cgroups::
+ 
+ 		mkdir /opt/cgroup/01/child_a
+ 		mkdir /opt/cgroup/01/child_b
++>>>>>>> 184218639a6f (docs: cgroup-v1: reflect the deprecation of the non-hierarchical mode):Documentation/admin-guide/cgroup-v1/memcg_test.rst
  
 -		set limit to 01.
 -		add limit to 01/child_b
 -		run jobs under child_a and child_b
 -
 -	create/delete following groups at random while jobs are running::
 +	set limit to 01.
 +	add limit to 01/child_b
 +	run jobs under child_a and child_b
  
 -		/opt/cgroup/01/child_a/child_aa
 -		/opt/cgroup/01/child_b/child_bb
 -		/opt/cgroup/01/child_c
 +	create/delete following groups at random while jobs are running.
 +	/opt/cgroup/01/child_a/child_aa
 +	/opt/cgroup/01/child_b/child_bb
 +	/opt/cgroup/01/child_c
  
  	running new jobs in new group is also good.
  
diff --cc Documentation/cgroup-v1/memory.txt
index 317de4b3d3df,a44cd467d218..000000000000
--- a/Documentation/cgroup-v1/memory.txt
+++ b/Documentation/cgroup-v1/memory.txt
@@@ -54,41 -59,52 +54,80 @@@ Features
  
  Brief summary of control files.
  
++<<<<<<< HEAD:Documentation/cgroup-v1/memory.txt
 + tasks				 # attach a task(thread) and show list of threads
 + cgroup.procs			 # show list of processes
 + cgroup.event_control		 # an interface for event_fd()
 + memory.usage_in_bytes		 # show current usage for memory
 +				 (See 5.5 for details)
 + memory.memsw.usage_in_bytes	 # show current usage for memory+Swap
 +				 (See 5.5 for details)
 + memory.limit_in_bytes		 # set/show limit of memory usage
 + memory.memsw.limit_in_bytes	 # set/show limit of memory+Swap usage
 + memory.failcnt			 # show the number of memory usage hits limits
 + memory.memsw.failcnt		 # show the number of memory+Swap hits limits
 + memory.max_usage_in_bytes	 # show max memory usage recorded
 + memory.memsw.max_usage_in_bytes # show max memory+Swap usage recorded
 + memory.soft_limit_in_bytes	 # set/show soft limit of memory usage
 + memory.stat			 # show various statistics
 + memory.use_hierarchy		 # set/show hierarchical account enabled
 + memory.force_empty		 # trigger forced move charge to parent
 + memory.pressure_level		 # set memory pressure notifications
 + memory.swappiness		 # set/show swappiness parameter of vmscan
 +				 (See sysctl's vm.swappiness)
 + memory.move_charge_at_immigrate # set/show controls of moving charges
 + memory.oom_control		 # set/show oom controls.
 + memory.numa_stat		 # show the number of memory usage per numa node
++=======
+ ==================================== ==========================================
+  tasks				     attach a task(thread) and show list of
+ 				     threads
+  cgroup.procs			     show list of processes
+  cgroup.event_control		     an interface for event_fd()
+  memory.usage_in_bytes		     show current usage for memory
+ 				     (See 5.5 for details)
+  memory.memsw.usage_in_bytes	     show current usage for memory+Swap
+ 				     (See 5.5 for details)
+  memory.limit_in_bytes		     set/show limit of memory usage
+  memory.memsw.limit_in_bytes	     set/show limit of memory+Swap usage
+  memory.failcnt			     show the number of memory usage hits limits
+  memory.memsw.failcnt		     show the number of memory+Swap hits limits
+  memory.max_usage_in_bytes	     show max memory usage recorded
+  memory.memsw.max_usage_in_bytes     show max memory+Swap usage recorded
+  memory.soft_limit_in_bytes	     set/show soft limit of memory usage
+  memory.stat			     show various statistics
+  memory.use_hierarchy		     set/show hierarchical account enabled
+                                      This knob is deprecated and shouldn't be
+                                      used.
+  memory.force_empty		     trigger forced page reclaim
+  memory.pressure_level		     set memory pressure notifications
+  memory.swappiness		     set/show swappiness parameter of vmscan
+ 				     (See sysctl's vm.swappiness)
+  memory.move_charge_at_immigrate     set/show controls of moving charges
+  memory.oom_control		     set/show oom controls.
+  memory.numa_stat		     show the number of memory usage per numa
+ 				     node
+  memory.kmem.limit_in_bytes          set/show hard limit for kernel memory
+                                      This knob is deprecated and shouldn't be
+                                      used. It is planned that this be removed in
+                                      the foreseeable future.
+  memory.kmem.usage_in_bytes          show current kernel memory allocation
+  memory.kmem.failcnt                 show the number of kernel memory usage
+ 				     hits limits
+  memory.kmem.max_usage_in_bytes      show max kernel memory usage recorded
++>>>>>>> 184218639a6f (docs: cgroup-v1: reflect the deprecation of the non-hierarchical mode):Documentation/admin-guide/cgroup-v1/memory.rst
  
 - memory.kmem.tcp.limit_in_bytes      set/show hard limit for tcp buf memory
 - memory.kmem.tcp.usage_in_bytes      show current tcp buf memory allocation
 - memory.kmem.tcp.failcnt             show the number of tcp buf memory usage
 -				     hits limits
 - memory.kmem.tcp.max_usage_in_bytes  show max tcp buf memory usage recorded
 -==================================== ==========================================
 + memory.kmem.limit_in_bytes      # set/show hard limit for kernel memory
 + memory.kmem.usage_in_bytes      # show current kernel memory allocation
 + memory.kmem.failcnt             # show the number of kernel memory usage hits limits
 + memory.kmem.max_usage_in_bytes  # show max kernel memory usage recorded
 +
 + memory.kmem.tcp.limit_in_bytes  # set/show hard limit for tcp buf memory
 + memory.kmem.tcp.usage_in_bytes  # show current tcp buf memory allocation
 + memory.kmem.tcp.failcnt            # show the number of tcp buf memory usage hits limits
 + memory.kmem.tcp.max_usage_in_bytes # show max tcp buf memory usage recorded
  
  1. History
 -==========
  
  The memory controller has a long history. A request for comments for the memory
  controller was posted by Balbir Singh [1]. At the time the RFC was posted
@@@ -441,15 -504,15 +479,20 @@@ Charges recorded in swap information i
  Recorded information is discarded and a cgroup which uses swap (swapcache)
  will be charged as a new owner of it.
  
++<<<<<<< HEAD:Documentation/cgroup-v1/memory.txt
 +About use_hierarchy, see Section 6.
 +
 +5. Misc. interfaces.
++=======
+ 5. Misc. interfaces
+ ===================
++>>>>>>> 184218639a6f (docs: cgroup-v1: reflect the deprecation of the non-hierarchical mode):Documentation/admin-guide/cgroup-v1/memory.rst
  
  5.1 force_empty
 ----------------
    memory.force_empty interface is provided to make cgroup's memory usage empty.
 -  When writing anything to this::
 +  When writing anything to this
  
 -    # echo 0 > memory.force_empty
 +  # echo 0 > memory.force_empty
  
    the cgroup will be reclaimed and as many pages reclaimed as possible.
  
@@@ -462,9 -526,8 +505,7 @@@
    write will still return success. In this case, it is expected that
    memory.kmem.usage_in_bytes == memory.usage_in_bytes.
  
-   About use_hierarchy, see Section 6.
- 
  5.2 stat file
 --------------
  
  memory.stat file includes following statistics
  
@@@ -591,30 -672,23 +632,43 @@@ hierarch
  		      d   e
  
  In the diagram above, with hierarchical accounting enabled, all memory
- usage of e, is accounted to its ancestors up until the root (i.e, c and root),
- that has memory.use_hierarchy enabled. If one of the ancestors goes over its
- limit, the reclaim algorithm reclaims from the tasks in the ancestor and the
- children of the ancestor.
+ usage of e, is accounted to its ancestors up until the root (i.e, c and root).
+ If one of the ancestors goes over its limit, the reclaim algorithm reclaims
+ from the tasks in the ancestor and the children of the ancestor.
  
++<<<<<<< HEAD:Documentation/cgroup-v1/memory.txt
 +6.1 Enabling hierarchical accounting and reclaim
 +
 +A memory cgroup by default disables the hierarchy feature. Support
 +can be enabled by writing 1 to memory.use_hierarchy file of the root cgroup
++=======
+ 6.1 Hierarchical accounting and reclaim
+ ---------------------------------------
+ 
+ Hierarchical accounting is enabled by default. Disabling the hierarchical
+ accounting is deprecated. An attempt to do it will result in a failure
+ and a warning printed to dmesg.
+ 
+ For compatibility reasons writing 1 to memory.use_hierarchy will always pass::
++>>>>>>> 184218639a6f (docs: cgroup-v1: reflect the deprecation of the non-hierarchical mode):Documentation/admin-guide/cgroup-v1/memory.rst
 +
 +# echo 1 > memory.use_hierarchy
 +
++<<<<<<< HEAD:Documentation/cgroup-v1/memory.txt
 +The feature can be disabled by
  
 -	# echo 1 > memory.use_hierarchy
 +# echo 0 > memory.use_hierarchy
  
 +NOTE1: Enabling/disabling will fail if either the cgroup already has other
 +       cgroups created below it, or if the parent cgroup has use_hierarchy
 +       enabled.
 +
 +NOTE2: When panic_on_oom is set to "2", the whole system will panic in
 +       case of an OOM event in any cgroup.
 +
++=======
++>>>>>>> 184218639a6f (docs: cgroup-v1: reflect the deprecation of the non-hierarchical mode):Documentation/admin-guide/cgroup-v1/memory.rst
  7. Soft limits
 -==============
  
  Soft limits allow for greater sharing of memory. The idea behind soft limits
  is to allow control groups to use as much of the memory as needed, provided
* Unmerged path Documentation/cgroup-v1/memcg_test.txt
* Unmerged path Documentation/cgroup-v1/memory.txt
