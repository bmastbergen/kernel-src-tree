initramfs: panic with memory information

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Florian Fainelli <f.fainelli@gmail.com>
commit dd23e8098f33a55b22b869bc7fc0a795ccbb9f87
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/dd23e809.failed

On systems with large amounts of reserved memory we may fail to
successfully complete unpack_to_rootfs() and be left with:

 Kernel panic - not syncing: write error

this is not too helpful to understand what happened, so let's wrap the
panic() calls with a surrounding show_mem() such that we have a chance of
understanding the memory conditions leading to these allocation failures.

[akpm@linux-foundation.org: replace macro with C function]

Link: https://lkml.kernel.org/r/20210114231517.1854379-1-f.fainelli@gmail.com
	Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
	Cc: Barret Rhoden <brho@google.com>
	Cc: Arnd Bergmann <arnd@arndb.de>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit dd23e8098f33a55b22b869bc7fc0a795ccbb9f87)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	init/initramfs.c
diff --cc init/initramfs.c
index 7e6d9cd291dc,5fa84711127a..000000000000
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@@ -20,8 -10,13 +20,15 @@@
  #include <linux/syscalls.h>
  #include <linux/utime.h>
  #include <linux/file.h>
++<<<<<<< HEAD
++=======
+ #include <linux/memblock.h>
+ #include <linux/mm.h>
+ #include <linux/namei.h>
+ #include <linux/init_syscalls.h>
++>>>>>>> dd23e8098f33 (initramfs: panic with memory information)
  
 -static ssize_t __init xwrite(struct file *file, const char *p, size_t count,
 -		loff_t *pos)
 +static ssize_t __init xwrite(int fd, const char *p, size_t count)
  {
  	ssize_t out = 0;
  
@@@ -612,47 -618,35 +629,62 @@@ static int __init populate_rootfs(void
  	/* Load the built in initramfs */
  	char *err = unpack_to_rootfs(__initramfs_start, __initramfs_size);
  	if (err)
++<<<<<<< HEAD
 +		panic("%s", err); /* Failed to decompress INTERNAL initramfs */
 +	/* If available load the bootloader supplied initrd */
 +	if (initrd_start && !IS_ENABLED(CONFIG_INITRAMFS_FORCE)) {
++=======
+ 		panic_show_mem("%s", err); /* Failed to decompress INTERNAL initramfs */
+ 
+ 	if (!initrd_start || IS_ENABLED(CONFIG_INITRAMFS_FORCE))
+ 		goto done;
+ 
+ 	if (IS_ENABLED(CONFIG_BLK_DEV_RAM))
+ 		printk(KERN_INFO "Trying to unpack rootfs image as initramfs...\n");
+ 	else
+ 		printk(KERN_INFO "Unpacking initramfs...\n");
+ 
+ 	err = unpack_to_rootfs((char *)initrd_start, initrd_end - initrd_start);
+ 	if (err) {
++>>>>>>> dd23e8098f33 (initramfs: panic with memory information)
  #ifdef CONFIG_BLK_DEV_RAM
 -		populate_initrd_image(err);
 +		int fd;
 +		printk(KERN_INFO "Trying to unpack rootfs image as initramfs...\n");
 +		err = unpack_to_rootfs((char *)initrd_start,
 +			initrd_end - initrd_start);
 +		if (!err) {
 +			free_initrd();
 +			goto done;
 +		} else {
 +			clean_rootfs();
 +			unpack_to_rootfs(__initramfs_start, __initramfs_size);
 +		}
 +		printk(KERN_INFO "rootfs image is not initramfs (%s)"
 +				"; looks like an initrd\n", err);
 +		fd = ksys_open("/initrd.image",
 +			      O_WRONLY|O_CREAT, 0700);
 +		if (fd >= 0) {
 +			ssize_t written = xwrite(fd, (char *)initrd_start,
 +						initrd_end - initrd_start);
 +
 +			if (written != initrd_end - initrd_start)
 +				pr_err("/initrd.image: incomplete write (%zd != %ld)\n",
 +				       written, initrd_end - initrd_start);
 +
 +			ksys_close(fd);
 +			free_initrd();
 +		}
 +	done:
 +		/* empty statement */;
  #else
 -		printk(KERN_EMERG "Initramfs unpacking failed: %s\n", err);
 +		printk(KERN_INFO "Unpacking initramfs...\n");
 +		err = unpack_to_rootfs((char *)initrd_start,
 +			initrd_end - initrd_start);
 +		if (err)
 +			printk(KERN_EMERG "Initramfs unpacking failed: %s\n", err);
 +		free_initrd();
  #endif
  	}
 -
 -done:
 -	/*
 -	 * If the initrd region is overlapped with crashkernel reserved region,
 -	 * free only memory that is not part of crashkernel region.
 -	 */
 -	if (!do_retain_initrd && initrd_start && !kexec_free_initrd())
 -		free_initrd_mem(initrd_start, initrd_end);
 -	initrd_start = 0;
 -	initrd_end = 0;
 -
  	flush_delayed_fput();
  	return 0;
  }
* Unmerged path init/initramfs.c
