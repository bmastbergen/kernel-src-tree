devlink: Add reload stats

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Moshe Shemesh <moshe@mellanox.com>
commit a254c264267e8746fb257806c166e54375cf9c06
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/a254c264.failed

Add reload stats to hold the history per reload action type and limit.

For example, the number of times fw_activate has been performed on this
device since the driver module was added or if the firmware activation
was performed with or without reset.

Add devlink notification on stats update.

Expose devlink reload stats to the user through devlink dev get command.

Examples:
$ devlink dev show
pci/0000:82:00.0:
  stats:
      reload:
        driver_reinit 2 fw_activate 1 fw_activate_no_reset 0
pci/0000:82:00.1:
  stats:
      reload:
        driver_reinit 1 fw_activate 0 fw_activate_no_reset 0

$ devlink dev show -jp
{
    "dev": {
        "pci/0000:82:00.0": {
            "stats": {
                "reload": {
                    "driver_reinit": 2,
                    "fw_activate": 1,
                    "fw_activate_no_reset": 0
                }
            }
        },
        "pci/0000:82:00.1": {
            "stats": {
                "reload": {
                    "driver_reinit": 1,
                    "fw_activate": 0,
                    "fw_activate_no_reset": 0
                }
            }
        }
    }
}

	Signed-off-by: Moshe Shemesh <moshe@mellanox.com>
	Reviewed-by: Jiri Pirko <jiri@nvidia.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit a254c264267e8746fb257806c166e54375cf9c06)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/devlink.c
diff --cc net/core/devlink.c
index 7ae91478c0cd,a167c3bb468c..000000000000
--- a/net/core/devlink.c
+++ b/net/core/devlink.c
@@@ -466,6 -479,99 +466,102 @@@ static int devlink_nl_put_handle(struc
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ struct devlink_reload_combination {
+ 	enum devlink_reload_action action;
+ 	enum devlink_reload_limit limit;
+ };
+ 
+ static const struct devlink_reload_combination devlink_reload_invalid_combinations[] = {
+ 	{
+ 		/* can't reinitialize driver with no down time */
+ 		.action = DEVLINK_RELOAD_ACTION_DRIVER_REINIT,
+ 		.limit = DEVLINK_RELOAD_LIMIT_NO_RESET,
+ 	},
+ };
+ 
+ static bool
+ devlink_reload_combination_is_invalid(enum devlink_reload_action action,
+ 				      enum devlink_reload_limit limit)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(devlink_reload_invalid_combinations); i++)
+ 		if (devlink_reload_invalid_combinations[i].action == action &&
+ 		    devlink_reload_invalid_combinations[i].limit == limit)
+ 			return true;
+ 	return false;
+ }
+ 
+ static bool
+ devlink_reload_action_is_supported(struct devlink *devlink, enum devlink_reload_action action)
+ {
+ 	return test_bit(action, &devlink->ops->reload_actions);
+ }
+ 
+ static bool
+ devlink_reload_limit_is_supported(struct devlink *devlink, enum devlink_reload_limit limit)
+ {
+ 	return test_bit(limit, &devlink->ops->reload_limits);
+ }
+ 
+ static int devlink_reload_stat_put(struct sk_buff *msg, enum devlink_reload_action action,
+ 				   enum devlink_reload_limit limit, u32 value)
+ {
+ 	struct nlattr *reload_stats_entry;
+ 
+ 	reload_stats_entry = nla_nest_start(msg, DEVLINK_ATTR_RELOAD_STATS_ENTRY);
+ 	if (!reload_stats_entry)
+ 		return -EMSGSIZE;
+ 
+ 	if (nla_put_u8(msg, DEVLINK_ATTR_RELOAD_ACTION, action) ||
+ 	    nla_put_u8(msg, DEVLINK_ATTR_RELOAD_STATS_LIMIT, limit) ||
+ 	    nla_put_u32(msg, DEVLINK_ATTR_RELOAD_STATS_VALUE, value))
+ 		goto nla_put_failure;
+ 	nla_nest_end(msg, reload_stats_entry);
+ 	return 0;
+ 
+ nla_put_failure:
+ 	nla_nest_cancel(msg, reload_stats_entry);
+ 	return -EMSGSIZE;
+ }
+ 
+ static int devlink_reload_stats_put(struct sk_buff *msg, struct devlink *devlink)
+ {
+ 	struct nlattr *reload_stats_attr;
+ 	int i, j, stat_idx;
+ 	u32 value;
+ 
+ 	reload_stats_attr = nla_nest_start(msg, DEVLINK_ATTR_RELOAD_STATS);
+ 
+ 	if (!reload_stats_attr)
+ 		return -EMSGSIZE;
+ 
+ 	for (j = 0; j <= DEVLINK_RELOAD_LIMIT_MAX; j++) {
+ 		if (j != DEVLINK_RELOAD_LIMIT_UNSPEC &&
+ 		    !devlink_reload_limit_is_supported(devlink, j))
+ 			continue;
+ 		for (i = 0; i <= DEVLINK_RELOAD_ACTION_MAX; i++) {
+ 			if (!devlink_reload_action_is_supported(devlink, i) ||
+ 			    devlink_reload_combination_is_invalid(i, j))
+ 				continue;
+ 
+ 			stat_idx = j * __DEVLINK_RELOAD_ACTION_MAX + i;
+ 			value = devlink->stats.reload_stats[stat_idx];
+ 			if (devlink_reload_stat_put(msg, i, j, value))
+ 				goto nla_put_failure;
+ 		}
+ 	}
+ 	nla_nest_end(msg, reload_stats_attr);
+ 	return 0;
+ 
+ nla_put_failure:
+ 	nla_nest_cancel(msg, reload_stats_attr);
+ 	return -EMSGSIZE;
+ }
+ 
++>>>>>>> a254c264267e (devlink: Add reload stats)
  static int devlink_nl_fill(struct sk_buff *msg, struct devlink *devlink,
  			   enum devlink_command cmd, u32 portid,
  			   u32 seq, int flags)
@@@ -2972,8 -3087,32 +3079,31 @@@ bool devlink_is_reload_failed(const str
  }
  EXPORT_SYMBOL_GPL(devlink_is_reload_failed);
  
+ static void
+ __devlink_reload_stats_update(struct devlink *devlink, u32 *reload_stats,
+ 			      enum devlink_reload_limit limit, u32 actions_performed)
+ {
+ 	unsigned long actions = actions_performed;
+ 	int stat_idx;
+ 	int action;
+ 
+ 	for_each_set_bit(action, &actions, __DEVLINK_RELOAD_ACTION_MAX) {
+ 		stat_idx = limit * __DEVLINK_RELOAD_ACTION_MAX + action;
+ 		reload_stats[stat_idx]++;
+ 	}
+ 	devlink_notify(devlink, DEVLINK_CMD_NEW);
+ }
+ 
+ static void
+ devlink_reload_stats_update(struct devlink *devlink, enum devlink_reload_limit limit,
+ 			    u32 actions_performed)
+ {
+ 	__devlink_reload_stats_update(devlink, devlink->stats.reload_stats, limit,
+ 				      actions_performed);
+ }
+ 
  static int devlink_reload(struct devlink *devlink, struct net *dest_net,
 -			  enum devlink_reload_action action, enum devlink_reload_limit limit,
 -			  u32 *actions_performed, struct netlink_ext_ack *extack)
 +			  struct netlink_ext_ack *extack)
  {
  	int err;
  
@@@ -2987,9 -3126,46 +3117,50 @@@
  	if (dest_net && !net_eq(dest_net, devlink_net(devlink)))
  		devlink_reload_netns_change(devlink, dest_net);
  
 -	err = devlink->ops->reload_up(devlink, action, limit, actions_performed, extack);
 +	err = devlink->ops->reload_up(devlink, extack);
  	devlink_reload_failed_set(devlink, !!err);
++<<<<<<< HEAD
 +	return err;
++=======
+ 	if (err)
+ 		return err;
+ 
+ 	WARN_ON(!(*actions_performed & BIT(action)));
+ 	devlink_reload_stats_update(devlink, limit, *actions_performed);
+ 	return 0;
+ }
+ 
+ static int
+ devlink_nl_reload_actions_performed_snd(struct devlink *devlink, u32 actions_performed,
+ 					enum devlink_command cmd, struct genl_info *info)
+ {
+ 	struct sk_buff *msg;
+ 	void *hdr;
+ 
+ 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
+ 	if (!msg)
+ 		return -ENOMEM;
+ 
+ 	hdr = genlmsg_put(msg, info->snd_portid, info->snd_seq, &devlink_nl_family, 0, cmd);
+ 	if (!hdr)
+ 		goto free_msg;
+ 
+ 	if (devlink_nl_put_handle(msg, devlink))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_bitfield32(msg, DEVLINK_ATTR_RELOAD_ACTIONS_PERFORMED, actions_performed,
+ 			       actions_performed))
+ 		goto nla_put_failure;
+ 	genlmsg_end(msg, hdr);
+ 
+ 	return genlmsg_reply(msg, info);
+ 
+ nla_put_failure:
+ 	genlmsg_cancel(msg, hdr);
+ free_msg:
+ 	nlmsg_free(msg);
+ 	return -EMSGSIZE;
++>>>>>>> a254c264267e (devlink: Add reload stats)
  }
  
  static int devlink_nl_cmd_reload(struct sk_buff *skb, struct genl_info *info)
diff --git a/include/net/devlink.h b/include/net/devlink.h
index 5414aff70555..9e64805c2fd4 100644
--- a/include/net/devlink.h
+++ b/include/net/devlink.h
@@ -24,6 +24,13 @@
 #include <uapi/linux/devlink.h>
 #include <linux/xarray.h>
 
+#define DEVLINK_RELOAD_STATS_ARRAY_SIZE \
+	(__DEVLINK_RELOAD_LIMIT_MAX * __DEVLINK_RELOAD_ACTION_MAX)
+
+struct devlink_dev_stats {
+	u32 reload_stats[DEVLINK_RELOAD_STATS_ARRAY_SIZE];
+};
+
 struct devlink_ops;
 
 struct devlink {
@@ -42,6 +49,7 @@ struct devlink {
 	struct list_head trap_policer_list;
 	const struct devlink_ops *ops;
 	struct xarray snapshot_ids;
+	struct devlink_dev_stats stats;
 	struct device *dev;
 	possible_net_t _net;
 	struct mutex lock; /* Serializes access to devlink instance specific objects such as
diff --git a/include/uapi/linux/devlink.h b/include/uapi/linux/devlink.h
index f2172c34975d..6d0d0ab742c9 100644
--- a/include/uapi/linux/devlink.h
+++ b/include/uapi/linux/devlink.h
@@ -468,6 +468,12 @@ enum devlink_attr {
 
 	DEVLINK_ATTR_FLASH_UPDATE_STATUS_TIMEOUT,	/* u64 */
 
+	DEVLINK_ATTR_DEV_STATS,			/* nested */
+	DEVLINK_ATTR_RELOAD_STATS,		/* nested */
+	DEVLINK_ATTR_RELOAD_STATS_ENTRY,	/* nested */
+	DEVLINK_ATTR_RELOAD_STATS_LIMIT,	/* u8 */
+	DEVLINK_ATTR_RELOAD_STATS_VALUE,	/* u32 */
+
 	/* add new attributes above here, update the policy in devlink.c */
 
 	__DEVLINK_ATTR_MAX,
* Unmerged path net/core/devlink.c
