KVM: x86: Take KVM's SRCU lock only if steal time update is needed

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Sean Christopherson <seanjc@google.com>
commit 15b51dc08a349f2f0832606c900b638a3dd19839
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/15b51dc0.failed

Enter a SRCU critical section for a memslots lookup during steal time
update if and only if a steal time update is actually needed.  Taking
the lock can be avoided if steal time is disabled by the guest, or if
KVM knows it has already flagged the vCPU as being preempted.

Reword the comment to be more precise as to exactly why memslots will
be queried.

	Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20210123000334.3123628-3-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 15b51dc08a349f2f0832606c900b638a3dd19839)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/x86.c
index e3a7b625d1f4,fa1ec597d510..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -4031,18 -4045,10 +4041,16 @@@ out
  
  void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)
  {
++<<<<<<< HEAD
 +	int idx;
 +
 +	if (vcpu->preempted)
++=======
+ 	if (vcpu->preempted && !vcpu->arch.guest_state_protected)
++>>>>>>> 15b51dc08a34 (KVM: x86: Take KVM's SRCU lock only if steal time update is needed)
  		vcpu->arch.preempted_in_kernel = !kvm_x86_ops.get_cpl(vcpu);
  
- 	/*
- 	 * kvm_memslots() will be called by
- 	 * kvm_write_guest_offset_cached() so take the srcu lock.
- 	 */
- 	idx = srcu_read_lock(&vcpu->kvm->srcu);
  	kvm_steal_time_set_preempted(vcpu);
- 	srcu_read_unlock(&vcpu->kvm->srcu, idx);
  	kvm_x86_ops.vcpu_put(vcpu);
  	vcpu->arch.last_host_tsc = rdtsc();
  	/*
* Unmerged path arch/x86/kvm/x86.c
