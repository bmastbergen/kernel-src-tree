kcsan: Move interfaces that affects checks to kcsan-checks.h

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Marco Elver <elver@google.com>
commit f0f6928c2c4c19ab6171d4f468f542fac1888a8f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/f0f6928c.failed

This moves functions that affect state changing the behaviour of
kcsan_check_access() to kcsan-checks.h. Since these are likely used with
kcsan_check_access() it makes more sense to have them in kcsan-checks.h,
to avoid including all of 'include/linux/kcsan.h'.

No functional change intended.

	Acked-by: John Hubbard <jhubbard@nvidia.com>
	Signed-off-by: Marco Elver <elver@google.com>
	Signed-off-by: Paul E. McKenney <paulmck@kernel.org>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit f0f6928c2c4c19ab6171d4f468f542fac1888a8f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/kcsan.h
diff --cc include/linux/kcsan.h
index 9047048fee84,7a614ca558f6..000000000000
--- a/include/linux/kcsan.h
+++ b/include/linux/kcsan.h
@@@ -56,59 -56,11 +56,29 @@@ void kcsan_disable_current(void)
   */
  void kcsan_enable_current(void);
  
- /**
-  * kcsan_nestable_atomic_begin - begin nestable atomic region
-  *
-  * Accesses within the atomic region may appear to race with other accesses but
-  * should be considered atomic.
-  */
- void kcsan_nestable_atomic_begin(void);
- 
- /**
-  * kcsan_nestable_atomic_end - end nestable atomic region
-  */
- void kcsan_nestable_atomic_end(void);
- 
- /**
-  * kcsan_flat_atomic_begin - begin flat atomic region
-  *
-  * Accesses within the atomic region may appear to race with other accesses but
-  * should be considered atomic.
-  */
- void kcsan_flat_atomic_begin(void);
- 
- /**
-  * kcsan_flat_atomic_end - end flat atomic region
-  */
- void kcsan_flat_atomic_end(void);
- 
- /**
-  * kcsan_atomic_next - consider following accesses as atomic
-  *
-  * Force treating the next n memory accesses for the current context as atomic
-  * operations.
-  *
-  * @n number of following memory accesses to treat as atomic.
-  */
- void kcsan_atomic_next(int n);
- 
  #else /* CONFIG_KCSAN */
  
++<<<<<<< HEAD
 +static inline void kcsan_init(void) { }
 +
 +static inline void kcsan_disable_current(void) { }
 +
 +static inline void kcsan_enable_current(void) { }
 +
 +static inline void kcsan_nestable_atomic_begin(void) { }
 +
 +static inline void kcsan_nestable_atomic_end(void) { }
 +
 +static inline void kcsan_flat_atomic_begin(void) { }
 +
 +static inline void kcsan_flat_atomic_end(void) { }
 +
 +static inline void kcsan_atomic_next(int n) { }
++=======
+ static inline void kcsan_init(void)			{ }
+ static inline void kcsan_disable_current(void)		{ }
+ static inline void kcsan_enable_current(void)		{ }
++>>>>>>> f0f6928c2c4c (kcsan: Move interfaces that affects checks to kcsan-checks.h)
  
  #endif /* CONFIG_KCSAN */
  
diff --git a/include/linux/kcsan-checks.h b/include/linux/kcsan-checks.h
index 4289e1bad23d..962919b1c370 100644
--- a/include/linux/kcsan-checks.h
+++ b/include/linux/kcsan-checks.h
@@ -26,10 +26,54 @@
  */
 void __kcsan_check_access(const volatile void *ptr, size_t size, int type);
 
-#else
+/**
+ * kcsan_nestable_atomic_begin - begin nestable atomic region
+ *
+ * Accesses within the atomic region may appear to race with other accesses but
+ * should be considered atomic.
+ */
+void kcsan_nestable_atomic_begin(void);
+
+/**
+ * kcsan_nestable_atomic_end - end nestable atomic region
+ */
+void kcsan_nestable_atomic_end(void);
+
+/**
+ * kcsan_flat_atomic_begin - begin flat atomic region
+ *
+ * Accesses within the atomic region may appear to race with other accesses but
+ * should be considered atomic.
+ */
+void kcsan_flat_atomic_begin(void);
+
+/**
+ * kcsan_flat_atomic_end - end flat atomic region
+ */
+void kcsan_flat_atomic_end(void);
+
+/**
+ * kcsan_atomic_next - consider following accesses as atomic
+ *
+ * Force treating the next n memory accesses for the current context as atomic
+ * operations.
+ *
+ * @n number of following memory accesses to treat as atomic.
+ */
+void kcsan_atomic_next(int n);
+
+#else /* CONFIG_KCSAN */
+
 static inline void __kcsan_check_access(const volatile void *ptr, size_t size,
 					int type) { }
-#endif
+
+static inline void kcsan_nestable_atomic_begin(void)	{ }
+static inline void kcsan_nestable_atomic_end(void)	{ }
+static inline void kcsan_flat_atomic_begin(void)	{ }
+static inline void kcsan_flat_atomic_end(void)		{ }
+static inline void kcsan_atomic_next(int n)		{ }
+
+#endif /* CONFIG_KCSAN */
 
 /*
  * kcsan_*: Only calls into runtime when the particular compilation unit has
* Unmerged path include/linux/kcsan.h
