nvme: refactor nvme_validate_ns

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 0a05226a3a2038b28d78101239196222d375124a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/0a05226a.failed

Move the logic to revalidate the block_device size or remove the
namespace from the caller into nvme_validate_ns.  This removes
the return value and thus the status code translation.  Additionally
it also catches non-permanent errors from nvme_update_ns_info using
the existing logic.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Keith Busch <kbusch@kernel.org>
	Reviewed-by: Damien Le Moal <damien.lemoal@wdc.com>
(cherry picked from commit 0a05226a3a2038b28d78101239196222d375124a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
diff --cc drivers/nvme/host/core.c
index 61e952b9cd65,0b88a377a47f..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -4022,17 -3937,76 +4023,67 @@@ static void nvme_ns_remove_by_nsid(stru
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void nvme_validate_ns(struct nvme_ns *ns, struct nvme_ns_ids *ids)
+ {
+ 	struct nvme_ctrl *ctrl = ns->ctrl;
+ 	struct nvme_id_ns *id;
+ 	int ret = -ENODEV;
+ 
+ 	if (test_bit(NVME_NS_DEAD, &ns->flags))
+ 		goto out;
+ 
+ 	ret = nvme_identify_ns(ctrl, ns->head->ns_id, ids, &id);
+ 	if (ret)
+ 		goto out;
+ 
+ 	ret = -ENODEV;
+ 	if (!nvme_ns_ids_equal(&ns->head->ids, ids)) {
+ 		dev_err(ctrl->device,
+ 			"identifiers changed for nsid %d\n", ns->head->ns_id);
+ 		goto out_free_id;
+ 	}
+ 
+ 	ret = nvme_update_ns_info(ns, id);
+ 
+ out_free_id:
+ 	kfree(id);
+ out:
+ 	/*
+ 	 * Only remove the namespace if we got a fatal error back from the
+ 	 * device, otherwise ignore the error and just move on.
+ 	 *
+ 	 * TODO: we should probably schedule a delayed retry here.
+ 	 */
+ 	if (ret && ret != -ENOMEM && !(ret > 0 && !(ret & NVME_SC_DNR)))
+ 		nvme_ns_remove(ns);
+ 	else
+ 		revalidate_disk_size(ns->disk, true);
+ }
+ 
++>>>>>>> 0a05226a3a20 (nvme: refactor nvme_validate_ns)
  static void nvme_validate_or_alloc_ns(struct nvme_ctrl *ctrl, unsigned nsid)
  {
 -	struct nvme_ns_ids ids = { };
  	struct nvme_ns *ns;
++<<<<<<< HEAD
 +
 +	ns = nvme_find_get_ns(ctrl, nsid);
 +	if (ns) {
 +		if (revalidate_disk(ns->disk))
 +			nvme_ns_remove(ns);
++=======
+ 
+ 	if (nvme_identify_ns_descs(ctrl, nsid, &ids))
+ 		return;
+ 
+ 	ns = nvme_find_get_ns(ctrl, nsid);
+ 	if (ns) {
+ 		nvme_validate_ns(ns, &ids);
++>>>>>>> 0a05226a3a20 (nvme: refactor nvme_validate_ns)
  		nvme_put_ns(ns);
 -		return;
 -	}
 -
 -	switch (ids.csi) {
 -	case NVME_CSI_NVM:
 -		nvme_alloc_ns(ctrl, nsid, &ids);
 -		break;
 -	case NVME_CSI_ZNS:
 -		if (!IS_ENABLED(CONFIG_BLK_DEV_ZONED)) {
 -			dev_warn(ctrl->device,
 -				"nsid %u not supported without CONFIG_BLK_DEV_ZONED\n",
 -				nsid);
 -			break;
 -		}
 -		nvme_alloc_ns(ctrl, nsid, &ids);
 -		break;
 -	default:
 -		dev_warn(ctrl->device, "unknown csi %u for nsid %u\n",
 -			ids.csi, nsid);
 -		break;
 -	}
 +	} else
 +		nvme_alloc_ns(ctrl, nsid);
  }
  
  static void nvme_remove_invalid_namespaces(struct nvme_ctrl *ctrl,
* Unmerged path drivers/nvme/host/core.c
