cifs: move cache mount options to fs_context.ch

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Ronnie Sahlberg <lsahlber@redhat.com>
commit 2f20f076865daed006459b39ba78c2fc23b5c8b4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/2f20f076.failed

Helps to shrink connect.c and make it more readable
by moving mount related code to fs_context.c and
fs_context.h

	Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
	Reviewed-by: Aurelien Aptel <aaptel@suse.com>
(cherry picked from commit 2f20f076865daed006459b39ba78c2fc23b5c8b4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/connect.c
#	fs/cifs/fs_context.c
#	fs/cifs/fs_context.h
diff --cc fs/cifs/connect.c
index d324a8f1409c,f7ef38a9dafa..000000000000
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@@ -279,52 -280,6 +279,55 @@@ static const match_table_t cifs_mount_o
  	{ Opt_err, NULL }
  };
  
++<<<<<<< HEAD
 +enum {
 +	Opt_sec_krb5, Opt_sec_krb5i, Opt_sec_krb5p,
 +	Opt_sec_ntlmsspi, Opt_sec_ntlmssp,
 +	Opt_ntlm, Opt_sec_ntlmi, Opt_sec_ntlmv2,
 +	Opt_sec_ntlmv2i, Opt_sec_lanman,
 +	Opt_sec_none,
 +
 +	Opt_sec_err
 +};
 +
 +static const match_table_t cifs_secflavor_tokens = {
 +	{ Opt_sec_krb5, "krb5" },
 +	{ Opt_sec_krb5i, "krb5i" },
 +	{ Opt_sec_krb5p, "krb5p" },
 +	{ Opt_sec_ntlmsspi, "ntlmsspi" },
 +	{ Opt_sec_ntlmssp, "ntlmssp" },
 +	{ Opt_ntlm, "ntlm" },
 +	{ Opt_sec_ntlmi, "ntlmi" },
 +	{ Opt_sec_ntlmv2, "nontlm" },
 +	{ Opt_sec_ntlmv2, "ntlmv2" },
 +	{ Opt_sec_ntlmv2i, "ntlmv2i" },
 +	{ Opt_sec_lanman, "lanman" },
 +	{ Opt_sec_none, "none" },
 +
 +	{ Opt_sec_err, NULL }
 +};
 +
 +/* cache flavors */
 +enum {
 +	Opt_cache_loose,
 +	Opt_cache_strict,
 +	Opt_cache_none,
 +	Opt_cache_ro,
 +	Opt_cache_rw,
 +	Opt_cache_err
 +};
 +
 +static const match_table_t cifs_cacheflavor_tokens = {
 +	{ Opt_cache_loose, "loose" },
 +	{ Opt_cache_strict, "strict" },
 +	{ Opt_cache_none, "none" },
 +	{ Opt_cache_ro, "ro" },
 +	{ Opt_cache_rw, "singleclient" },
 +	{ Opt_cache_err, NULL }
 +};
 +
++=======
++>>>>>>> 2f20f076865d (cifs: move cache mount options to fs_context.ch)
  static const match_table_t cifs_smb_version_tokens = {
  	{ Smb_1, SMB1_VERSION_STRING },
  	{ Smb_20, SMB20_VERSION_STRING},
@@@ -1372,106 -1327,6 +1375,63 @@@ static int get_option_gid(substring_t a
  	return 0;
  }
  
 +static int cifs_parse_security_flavors(char *value,
 +				       struct smb_vol *vol)
 +{
 +
 +	substring_t args[MAX_OPT_ARGS];
 +
 +	/*
 +	 * With mount options, the last one should win. Reset any existing
 +	 * settings back to default.
 +	 */
 +	vol->sectype = Unspecified;
 +	vol->sign = false;
 +
 +	switch (match_token(value, cifs_secflavor_tokens, args)) {
 +	case Opt_sec_krb5p:
 +		cifs_dbg(VFS, "sec=krb5p is not supported!\n");
 +		return 1;
 +	case Opt_sec_krb5i:
 +		vol->sign = true;
 +		/* Fallthrough */
 +	case Opt_sec_krb5:
 +		vol->sectype = Kerberos;
 +		break;
 +	case Opt_sec_ntlmsspi:
 +		vol->sign = true;
 +		/* Fallthrough */
 +	case Opt_sec_ntlmssp:
 +		vol->sectype = RawNTLMSSP;
 +		break;
 +	case Opt_sec_ntlmi:
 +		vol->sign = true;
 +		/* Fallthrough */
 +	case Opt_ntlm:
 +		vol->sectype = NTLM;
 +		break;
 +	case Opt_sec_ntlmv2i:
 +		vol->sign = true;
 +		/* Fallthrough */
 +	case Opt_sec_ntlmv2:
 +		vol->sectype = NTLMv2;
 +		break;
 +#ifdef CONFIG_CIFS_WEAK_PW_HASH
 +	case Opt_sec_lanman:
 +		vol->sectype = LANMAN;
 +		break;
 +#endif
 +	case Opt_sec_none:
 +		vol->nullauth = 1;
 +		break;
 +	default:
 +		cifs_dbg(VFS, "bad security option: %s\n", value);
 +		return 1;
 +	}
 +
 +	return 0;
 +}
 +
- static int
- cifs_parse_cache_flavor(char *value, struct smb_vol *vol)
- {
- 	substring_t args[MAX_OPT_ARGS];
- 
- 	switch (match_token(value, cifs_cacheflavor_tokens, args)) {
- 	case Opt_cache_loose:
- 		vol->direct_io = false;
- 		vol->strict_io = false;
- 		vol->cache_ro = false;
- 		vol->cache_rw = false;
- 		break;
- 	case Opt_cache_strict:
- 		vol->direct_io = false;
- 		vol->strict_io = true;
- 		vol->cache_ro = false;
- 		vol->cache_rw = false;
- 		break;
- 	case Opt_cache_none:
- 		vol->direct_io = true;
- 		vol->strict_io = false;
- 		vol->cache_ro = false;
- 		vol->cache_rw = false;
- 		break;
- 	case Opt_cache_ro:
- 		vol->direct_io = false;
- 		vol->strict_io = false;
- 		vol->cache_ro = true;
- 		vol->cache_rw = false;
- 		break;
- 	case Opt_cache_rw:
- 		vol->direct_io = false;
- 		vol->strict_io = false;
- 		vol->cache_ro = false;
- 		vol->cache_rw = true;
- 		break;
- 	default:
- 		cifs_dbg(VFS, "bad cache= option: %s\n", value);
- 		return 1;
- 	}
- 	return 0;
- }
- 
  static int
  cifs_parse_smb_version(char *value, struct smb_vol *vol, bool is_smb3)
  {
diff --cc fs/cifs/fs_context.c
index f50dfc2d2e44,deb1168ed8af..000000000000
--- a/fs/cifs/fs_context.c
+++ b/fs/cifs/fs_context.c
@@@ -6,3 -6,131 +6,134 @@@
   *              David Howells <dhowells@redhat.com>
   */
  
++<<<<<<< HEAD
++=======
+ #include "cifsglob.h"
+ #include "cifs_debug.h"
+ #include "fs_context.h"
+ 
+ static const match_table_t cifs_secflavor_tokens = {
+ 	{ Opt_sec_krb5, "krb5" },
+ 	{ Opt_sec_krb5i, "krb5i" },
+ 	{ Opt_sec_krb5p, "krb5p" },
+ 	{ Opt_sec_ntlmsspi, "ntlmsspi" },
+ 	{ Opt_sec_ntlmssp, "ntlmssp" },
+ 	{ Opt_ntlm, "ntlm" },
+ 	{ Opt_sec_ntlmi, "ntlmi" },
+ 	{ Opt_sec_ntlmv2, "nontlm" },
+ 	{ Opt_sec_ntlmv2, "ntlmv2" },
+ 	{ Opt_sec_ntlmv2i, "ntlmv2i" },
+ 	{ Opt_sec_lanman, "lanman" },
+ 	{ Opt_sec_none, "none" },
+ 
+ 	{ Opt_sec_err, NULL }
+ };
+ 
+ int cifs_parse_security_flavors(char *value, struct smb_vol *vol)
+ {
+ 
+ 	substring_t args[MAX_OPT_ARGS];
+ 
+ 	/*
+ 	 * With mount options, the last one should win. Reset any existing
+ 	 * settings back to default.
+ 	 */
+ 	vol->sectype = Unspecified;
+ 	vol->sign = false;
+ 
+ 	switch (match_token(value, cifs_secflavor_tokens, args)) {
+ 	case Opt_sec_krb5p:
+ 		cifs_dbg(VFS, "sec=krb5p is not supported!\n");
+ 		return 1;
+ 	case Opt_sec_krb5i:
+ 		vol->sign = true;
+ 		fallthrough;
+ 	case Opt_sec_krb5:
+ 		vol->sectype = Kerberos;
+ 		break;
+ 	case Opt_sec_ntlmsspi:
+ 		vol->sign = true;
+ 		fallthrough;
+ 	case Opt_sec_ntlmssp:
+ 		vol->sectype = RawNTLMSSP;
+ 		break;
+ 	case Opt_sec_ntlmi:
+ 		vol->sign = true;
+ 		fallthrough;
+ 	case Opt_ntlm:
+ 		vol->sectype = NTLM;
+ 		break;
+ 	case Opt_sec_ntlmv2i:
+ 		vol->sign = true;
+ 		fallthrough;
+ 	case Opt_sec_ntlmv2:
+ 		vol->sectype = NTLMv2;
+ 		break;
+ #ifdef CONFIG_CIFS_WEAK_PW_HASH
+ 	case Opt_sec_lanman:
+ 		vol->sectype = LANMAN;
+ 		break;
+ #endif
+ 	case Opt_sec_none:
+ 		vol->nullauth = 1;
+ 		break;
+ 	default:
+ 		cifs_dbg(VFS, "bad security option: %s\n", value);
+ 		return 1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static const match_table_t cifs_cacheflavor_tokens = {
+ 	{ Opt_cache_loose, "loose" },
+ 	{ Opt_cache_strict, "strict" },
+ 	{ Opt_cache_none, "none" },
+ 	{ Opt_cache_ro, "ro" },
+ 	{ Opt_cache_rw, "singleclient" },
+ 	{ Opt_cache_err, NULL }
+ };
+ 
+ int
+ cifs_parse_cache_flavor(char *value, struct smb_vol *vol)
+ {
+ 	substring_t args[MAX_OPT_ARGS];
+ 
+ 	switch (match_token(value, cifs_cacheflavor_tokens, args)) {
+ 	case Opt_cache_loose:
+ 		vol->direct_io = false;
+ 		vol->strict_io = false;
+ 		vol->cache_ro = false;
+ 		vol->cache_rw = false;
+ 		break;
+ 	case Opt_cache_strict:
+ 		vol->direct_io = false;
+ 		vol->strict_io = true;
+ 		vol->cache_ro = false;
+ 		vol->cache_rw = false;
+ 		break;
+ 	case Opt_cache_none:
+ 		vol->direct_io = true;
+ 		vol->strict_io = false;
+ 		vol->cache_ro = false;
+ 		vol->cache_rw = false;
+ 		break;
+ 	case Opt_cache_ro:
+ 		vol->direct_io = false;
+ 		vol->strict_io = false;
+ 		vol->cache_ro = true;
+ 		vol->cache_rw = false;
+ 		break;
+ 	case Opt_cache_rw:
+ 		vol->direct_io = false;
+ 		vol->strict_io = false;
+ 		vol->cache_ro = false;
+ 		vol->cache_rw = true;
+ 		break;
+ 	default:
+ 		cifs_dbg(VFS, "bad cache= option: %s\n", value);
+ 		return 1;
+ 	}
+ 	return 0;
+ }
++>>>>>>> 2f20f076865d (cifs: move cache mount options to fs_context.ch)
diff --cc fs/cifs/fs_context.h
index 082f286f923e,3e3f6e29e787..000000000000
--- a/fs/cifs/fs_context.h
+++ b/fs/cifs/fs_context.h
@@@ -9,7 -9,36 +9,38 @@@
  #ifndef _FS_CONTEXT_H
  #define _FS_CONTEXT_H
  
 -#include <linux/parser.h>
 -#include "cifsglob.h"
  
++<<<<<<< HEAD
++=======
+ enum {
+ 	Opt_cache_loose,
+ 	Opt_cache_strict,
+ 	Opt_cache_none,
+ 	Opt_cache_ro,
+ 	Opt_cache_rw,
+ 	Opt_cache_err
+ };
+ 
+ int cifs_parse_cache_flavor(char *value, struct smb_vol *vol);
+ 
+ enum cifs_sec_param {
+ 	Opt_sec_krb5,
+ 	Opt_sec_krb5i,
+ 	Opt_sec_krb5p,
+ 	Opt_sec_ntlmsspi,
+ 	Opt_sec_ntlmssp,
+ 	Opt_ntlm,
+ 	Opt_sec_ntlmi,
+ 	Opt_sec_ntlmv2,
+ 	Opt_sec_ntlmv2i,
+ 	Opt_sec_lanman,
+ 	Opt_sec_none,
+ 
+ 	Opt_sec_err
+ };
+ 
+ int cifs_parse_security_flavors(char *value, struct smb_vol *vol);
++>>>>>>> 2f20f076865d (cifs: move cache mount options to fs_context.ch)
  
  #endif
 +
* Unmerged path fs/cifs/connect.c
* Unmerged path fs/cifs/fs_context.c
* Unmerged path fs/cifs/fs_context.h
