mm: memcg/slab: rename *_lruvec_slab_state to *_lruvec_kmem_state

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Muchun Song <songmuchun@bytedance.com>
commit da3ceeff923e3bc750a8423c840462760c463926
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/da3ceeff.failed

The *_lruvec_slab_state is also suitable for pages allocated from buddy,
not just for the slab objects.  But the function name seems to tell us
that only slab object is applicable.  So we can rename the keyword of slab
to kmem.

Link: https://lkml.kernel.org/r/20201117085249.24319-1-songmuchun@bytedance.com
	Signed-off-by: Muchun Song <songmuchun@bytedance.com>
	Acked-by: Roman Gushchin <guro@fb.com>
	Reviewed-by: Shakeel Butt <shakeelb@google.com>
	Acked-by: Johannes Weiner <hannes@cmpxchg.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit da3ceeff923e3bc750a8423c840462760c463926)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/memcontrol.h
#	kernel/fork.c
diff --cc include/linux/memcontrol.h
index da9b4f3ccbfd,71c961452d9a..000000000000
--- a/include/linux/memcontrol.h
+++ b/include/linux/memcontrol.h
@@@ -832,8 -788,17 +832,22 @@@ void __mod_memcg_lruvec_state(struct lr
  			      int val);
  void __mod_lruvec_state(struct lruvec *lruvec, enum node_stat_item idx,
  			int val);
++<<<<<<< HEAD
 +void __mod_lruvec_slab_state(void *p, enum node_stat_item idx, int val);
 +void mod_memcg_obj_state(void *p, int idx, int val);
++=======
+ void __mod_lruvec_kmem_state(void *p, enum node_stat_item idx, int val);
+ 
+ static inline void mod_lruvec_kmem_state(void *p, enum node_stat_item idx,
+ 					 int val)
+ {
+ 	unsigned long flags;
+ 
+ 	local_irq_save(flags);
+ 	__mod_lruvec_kmem_state(p, idx, val);
+ 	local_irq_restore(flags);
+ }
++>>>>>>> da3ceeff923e (mm: memcg/slab: rename *_lruvec_slab_state to *_lruvec_kmem_state)
  
  static inline void mod_memcg_lruvec_state(struct lruvec *lruvec,
  					  enum node_stat_item idx, int val)
@@@ -1263,8 -1237,12 +1277,13 @@@ static inline void __mod_lruvec_kmem_st
  	__mod_node_page_state(page_pgdat(page), idx, val);
  }
  
++<<<<<<< HEAD
 +static inline void mod_memcg_obj_state(void *p, int idx, int val)
++=======
+ static inline void mod_lruvec_kmem_state(void *p, enum node_stat_item idx,
+ 					 int val)
++>>>>>>> da3ceeff923e (mm: memcg/slab: rename *_lruvec_slab_state to *_lruvec_kmem_state)
  {
 -	struct page *page = virt_to_head_page(p);
 -
 -	mod_node_page_state(page_pgdat(page), idx, val);
  }
  
  static inline
diff --cc kernel/fork.c
index 9a2ad5adca15,5e7cc88eadb5..000000000000
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@@ -365,6 -379,22 +365,25 @@@ static void account_kernel_stack(struc
  	void *stack = task_stack_page(tsk);
  	struct vm_struct *vm = task_stack_vm_area(tsk);
  
++<<<<<<< HEAD
++=======
+ 
+ 	/* All stack pages are in the same node. */
+ 	if (vm)
+ 		mod_lruvec_page_state(vm->pages[0], NR_KERNEL_STACK_KB,
+ 				      account * (THREAD_SIZE / 1024));
+ 	else
+ 		mod_lruvec_kmem_state(stack, NR_KERNEL_STACK_KB,
+ 				      account * (THREAD_SIZE / 1024));
+ }
+ 
+ static int memcg_charge_kernel_stack(struct task_struct *tsk)
+ {
+ #ifdef CONFIG_VMAP_STACK
+ 	struct vm_struct *vm = task_stack_vm_area(tsk);
+ 	int ret;
+ 
++>>>>>>> da3ceeff923e (mm: memcg/slab: rename *_lruvec_slab_state to *_lruvec_kmem_state)
  	BUILD_BUG_ON(IS_ENABLED(CONFIG_VMAP_STACK) && PAGE_SIZE % 1024 != 0);
  
  	if (vm) {
* Unmerged path include/linux/memcontrol.h
* Unmerged path kernel/fork.c
diff --git a/mm/memcontrol.c b/mm/memcontrol.c
index dd6c716de020..2464ce2576aa 100644
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@ -867,7 +867,7 @@ void __mod_lruvec_state(struct lruvec *lruvec, enum node_stat_item idx,
 		__mod_memcg_lruvec_state(lruvec, idx, val);
 }
 
-void __mod_lruvec_slab_state(void *p, enum node_stat_item idx, int val)
+void __mod_lruvec_kmem_state(void *p, enum node_stat_item idx, int val)
 {
 	pg_data_t *pgdat = page_pgdat(virt_to_page(p));
 	struct mem_cgroup *memcg;
diff --git a/mm/workingset.c b/mm/workingset.c
index e185bfb8bd4e..d808a311e80d 100644
--- a/mm/workingset.c
+++ b/mm/workingset.c
@@ -445,12 +445,12 @@ void workingset_update_node(struct xa_node *node)
 	if (node->count && node->count == node->nr_values) {
 		if (list_empty(&node->private_list)) {
 			list_lru_add(&shadow_nodes, &node->private_list);
-			__inc_lruvec_slab_state(node, WORKINGSET_NODES);
+			__inc_lruvec_kmem_state(node, WORKINGSET_NODES);
 		}
 	} else {
 		if (!list_empty(&node->private_list)) {
 			list_lru_del(&shadow_nodes, &node->private_list);
-			__dec_lruvec_slab_state(node, WORKINGSET_NODES);
+			__dec_lruvec_kmem_state(node, WORKINGSET_NODES);
 		}
 	}
 }
@@ -544,7 +544,7 @@ static enum lru_status shadow_lru_isolate(struct list_head *item,
 	}
 
 	list_lru_isolate(lru, item);
-	__dec_lruvec_slab_state(node, WORKINGSET_NODES);
+	__dec_lruvec_kmem_state(node, WORKINGSET_NODES);
 
 	spin_unlock(lru_lock);
 
@@ -559,7 +559,7 @@ static enum lru_status shadow_lru_isolate(struct list_head *item,
 		goto out_invalid;
 	mapping->nrexceptional -= node->nr_values;
 	xa_delete_node(node, workingset_update_node);
-	__inc_lruvec_slab_state(node, WORKINGSET_NODERECLAIM);
+	__inc_lruvec_kmem_state(node, WORKINGSET_NODERECLAIM);
 
 out_invalid:
 	xa_unlock_irq(&mapping->i_pages);
