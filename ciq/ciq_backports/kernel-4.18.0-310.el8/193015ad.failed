KVM: nSVM: Track the ASID generation of the vmcb vmrun through the vmcb

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Cathy Avery <cavery@redhat.com>
commit 193015adf40d0465c240d4e9a7b6e4b84b531f8b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/193015ad.failed

This patch moves the asid_generation from the vcpu to the vmcb
in order to track the ASID generation that was active the last
time the vmcb was run. If sd->asid_generation changes between
two runs, the old ASID is invalid and must be changed.

	Suggested-by: Paolo Bonzini <pbonzini@redhat.com>
	Signed-off-by: Cathy Avery <cavery@redhat.com>
Message-Id: <20210112164313.4204-3-cavery@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 193015adf40d0465c240d4e9a7b6e4b84b531f8b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm/svm.c
#	arch/x86/kvm/svm/svm.h
diff --cc arch/x86/kvm/svm/svm.c
index 05deab5ed2e8,8779b7bdca1a..000000000000
--- a/arch/x86/kvm/svm/svm.c
+++ b/arch/x86/kvm/svm/svm.c
@@@ -1305,6 -1305,21 +1305,24 @@@ static void svm_vcpu_reset(struct kvm_v
  		avic_update_vapic_bar(svm, APIC_DEFAULT_PHYS_BASE);
  }
  
++<<<<<<< HEAD
++=======
+ void svm_switch_vmcb(struct vcpu_svm *svm, struct kvm_vmcb_info *target_vmcb)
+ {
+ 	svm->current_vmcb = target_vmcb;
+ 	svm->vmcb = target_vmcb->ptr;
+ 	svm->vmcb_pa = target_vmcb->pa;
+ 
+ 	/*
+ 	* Track the physical CPU the target_vmcb is running on
+ 	* in order to mark the VMCB dirty if the cpu changes at
+ 	* its next vmrun.
+ 	*/
+ 
+ 	svm->current_vmcb->cpu = svm->vcpu.cpu;
+ }
+ 
++>>>>>>> 193015adf40d (KVM: nSVM: Track the ASID generation of the vmcb vmrun through the vmcb)
  static int svm_create_vcpu(struct kvm_vcpu *vcpu)
  {
  	struct vcpu_svm *svm;
@@@ -1337,9 -1371,15 +1355,21 @@@
  
  	svm_vcpu_init_msrpm(vcpu, svm->msrpm);
  
++<<<<<<< HEAD
 +	svm->vmcb = page_address(vmcb_page);
 +	svm->vmcb_pa = __sme_set(page_to_pfn(vmcb_page) << PAGE_SHIFT);
 +	svm->asid_generation = 0;
++=======
+ 	svm->vmcb01.ptr = page_address(vmcb01_page);
+ 	svm->vmcb01.pa = __sme_set(page_to_pfn(vmcb01_page) << PAGE_SHIFT);
+ 
+ 	if (vmsa_page)
+ 		svm->vmsa = page_address(vmsa_page);
+ 
+ 	svm->guest_state_loaded = false;
+ 
+ 	svm_switch_vmcb(svm, &svm->vmcb01);
++>>>>>>> 193015adf40d (KVM: nSVM: Track the ASID generation of the vmcb vmrun through the vmcb)
  	init_vmcb(svm);
  
  	svm_init_osvw(vcpu);
@@@ -3332,6 -3423,18 +3362,21 @@@ static void pre_svm_run(struct vcpu_sv
  {
  	struct svm_cpu_data *sd = per_cpu(svm_data, svm->vcpu.cpu);
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * If the previous vmrun of the vmcb occurred on
+ 	 * a different physical cpu then we must mark the vmcb dirty.
+ 	 * and assign a new asid.
+ 	*/
+ 
+         if (unlikely(svm->current_vmcb->cpu != svm->vcpu.cpu)) {
+ 		svm->current_vmcb->asid_generation = 0;
+ 		vmcb_mark_all_dirty(svm->vmcb);
+ 		svm->current_vmcb->cpu = svm->vcpu.cpu;
+         }
+ 
++>>>>>>> 193015adf40d (KVM: nSVM: Track the ASID generation of the vmcb vmrun through the vmcb)
  	if (sev_guest(svm->vcpu.kvm))
  		return pre_sev_run(svm, svm->vcpu.cpu);
  
diff --cc arch/x86/kvm/svm/svm.h
index de600f536464,993155195212..000000000000
--- a/arch/x86/kvm/svm/svm.h
+++ b/arch/x86/kvm/svm/svm.h
@@@ -84,8 -81,15 +84,18 @@@ struct kvm_svm 
  
  struct kvm_vcpu;
  
++<<<<<<< HEAD
++=======
+ struct kvm_vmcb_info {
+ 	struct vmcb *ptr;
+ 	unsigned long pa;
+ 	int cpu;
+ 	uint64_t asid_generation;
+ };
+ 
++>>>>>>> 193015adf40d (KVM: nSVM: Track the ASID generation of the vmcb vmrun through the vmcb)
  struct svm_nested_state {
 -	struct kvm_vmcb_info vmcb02;
 +	struct vmcb *hsave;
  	u64 hsave_msr;
  	u64 vm_cr_msr;
  	u64 vmcb12_gpa;
@@@ -107,9 -111,10 +117,8 @@@ struct vcpu_svm 
  	struct kvm_vcpu vcpu;
  	struct vmcb *vmcb;
  	unsigned long vmcb_pa;
 -	struct kvm_vmcb_info vmcb01;
 -	struct kvm_vmcb_info *current_vmcb;
  	struct svm_cpu_data *svm_data;
  	u32 asid;
- 	uint64_t asid_generation;
  	uint64_t sysenter_esp;
  	uint64_t sysenter_eip;
  	uint64_t tsc_aux;
* Unmerged path arch/x86/kvm/svm/svm.c
* Unmerged path arch/x86/kvm/svm/svm.h
