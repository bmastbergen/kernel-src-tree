mm: memcontrol: convert NR_SHMEM_PMDMAPPED account to pages

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Muchun Song <songmuchun@bytedance.com>
commit a1528e21f8915e16252cda1137fe29672c918361
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/a1528e21.failed

Currently we use struct per_cpu_nodestat to cache the vmstat counters,
which leads to inaccurate statistics especially THP vmstat counters.  In
the systems with hundreds of processors it can be GBs of memory.  For
example, for a 96 CPUs system, the threshold is the maximum number of 125.
And the per cpu counters can cache 23.4375 GB in total.

The THP page is already a form of batched addition (it will add 512 worth
of memory in one go) so skipping the batching seems like sensible.
Although every THP stats update overflows the per-cpu counter, resorting
to atomic global updates.  But it can make the statistics more accuracy
for the THP vmstat counters.

So we convert the NR_SHMEM_PMDMAPPED account to pages.  This patch is
consistent with 8f182270dfec ("mm/swap.c: flush lru pvecs on compound page
arrival").  Doing this also can make the unit of vmstat counters more
unified.  Finally, the unit of the vmstat counters are pages, kB and
bytes.  The B/KB suffix can tell us that the unit is bytes or kB.  The
rest which is without suffix are pages.

Link: https://lkml.kernel.org/r/20201228164110.2838-6-songmuchun@bytedance.com
	Signed-off-by: Muchun Song <songmuchun@bytedance.com>
	Cc: Alexey Dobriyan <adobriyan@gmail.com>
	Cc: Feng Tang <feng.tang@intel.com>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: NeilBrown <neilb@suse.de>
	Cc: Pankaj Gupta <pankaj.gupta@cloud.ionos.com>
	Cc: Rafael. J. Wysocki <rafael@kernel.org>
	Cc: Randy Dunlap <rdunlap@infradead.org>
	Cc: Roman Gushchin <guro@fb.com>
	Cc: Sami Tolvanen <samitolvanen@google.com>
	Cc: Shakeel Butt <shakeelb@google.com>
	Cc: Vladimir Davydov <vdavydov.dev@gmail.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit a1528e21f8915e16252cda1137fe29672c918361)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/node.c
#	include/linux/mmzone.h
#	mm/page_alloc.c
diff --cc drivers/base/node.c
index 8633d5d90a7d,7a66aefe4e46..000000000000
--- a/drivers/base/node.c
+++ b/drivers/base/node.c
@@@ -369,99 -376,101 +369,109 @@@ static ssize_t node_read_meminfo(struc
  	si_meminfo_node(&i, nid);
  	sreclaimable = node_page_state_pages(pgdat, NR_SLAB_RECLAIMABLE_B);
  	sunreclaimable = node_page_state_pages(pgdat, NR_SLAB_UNRECLAIMABLE_B);
 -	len = sysfs_emit_at(buf, len,
 -			    "Node %d MemTotal:       %8lu kB\n"
 -			    "Node %d MemFree:        %8lu kB\n"
 -			    "Node %d MemUsed:        %8lu kB\n"
 -			    "Node %d Active:         %8lu kB\n"
 -			    "Node %d Inactive:       %8lu kB\n"
 -			    "Node %d Active(anon):   %8lu kB\n"
 -			    "Node %d Inactive(anon): %8lu kB\n"
 -			    "Node %d Active(file):   %8lu kB\n"
 -			    "Node %d Inactive(file): %8lu kB\n"
 -			    "Node %d Unevictable:    %8lu kB\n"
 -			    "Node %d Mlocked:        %8lu kB\n",
 -			    nid, K(i.totalram),
 -			    nid, K(i.freeram),
 -			    nid, K(i.totalram - i.freeram),
 -			    nid, K(node_page_state(pgdat, NR_ACTIVE_ANON) +
 -				   node_page_state(pgdat, NR_ACTIVE_FILE)),
 -			    nid, K(node_page_state(pgdat, NR_INACTIVE_ANON) +
 -				   node_page_state(pgdat, NR_INACTIVE_FILE)),
 -			    nid, K(node_page_state(pgdat, NR_ACTIVE_ANON)),
 -			    nid, K(node_page_state(pgdat, NR_INACTIVE_ANON)),
 -			    nid, K(node_page_state(pgdat, NR_ACTIVE_FILE)),
 -			    nid, K(node_page_state(pgdat, NR_INACTIVE_FILE)),
 -			    nid, K(node_page_state(pgdat, NR_UNEVICTABLE)),
 -			    nid, K(sum_zone_node_page_state(nid, NR_MLOCK)));
 +	n = sprintf(buf,
 +		       "Node %d MemTotal:       %8lu kB\n"
 +		       "Node %d MemFree:        %8lu kB\n"
 +		       "Node %d MemUsed:        %8lu kB\n"
 +		       "Node %d Active:         %8lu kB\n"
 +		       "Node %d Inactive:       %8lu kB\n"
 +		       "Node %d Active(anon):   %8lu kB\n"
 +		       "Node %d Inactive(anon): %8lu kB\n"
 +		       "Node %d Active(file):   %8lu kB\n"
 +		       "Node %d Inactive(file): %8lu kB\n"
 +		       "Node %d Unevictable:    %8lu kB\n"
 +		       "Node %d Mlocked:        %8lu kB\n",
 +		       nid, K(i.totalram),
 +		       nid, K(i.freeram),
 +		       nid, K(i.totalram - i.freeram),
 +		       nid, K(node_page_state(pgdat, NR_ACTIVE_ANON) +
 +				node_page_state(pgdat, NR_ACTIVE_FILE)),
 +		       nid, K(node_page_state(pgdat, NR_INACTIVE_ANON) +
 +				node_page_state(pgdat, NR_INACTIVE_FILE)),
 +		       nid, K(node_page_state(pgdat, NR_ACTIVE_ANON)),
 +		       nid, K(node_page_state(pgdat, NR_INACTIVE_ANON)),
 +		       nid, K(node_page_state(pgdat, NR_ACTIVE_FILE)),
 +		       nid, K(node_page_state(pgdat, NR_INACTIVE_FILE)),
 +		       nid, K(node_page_state(pgdat, NR_UNEVICTABLE)),
 +		       nid, K(sum_zone_node_page_state(nid, NR_MLOCK)));
  
  #ifdef CONFIG_HIGHMEM
 -	len += sysfs_emit_at(buf, len,
 -			     "Node %d HighTotal:      %8lu kB\n"
 -			     "Node %d HighFree:       %8lu kB\n"
 -			     "Node %d LowTotal:       %8lu kB\n"
 -			     "Node %d LowFree:        %8lu kB\n",
 -			     nid, K(i.totalhigh),
 -			     nid, K(i.freehigh),
 -			     nid, K(i.totalram - i.totalhigh),
 -			     nid, K(i.freeram - i.freehigh));
 +	n += sprintf(buf + n,
 +		       "Node %d HighTotal:      %8lu kB\n"
 +		       "Node %d HighFree:       %8lu kB\n"
 +		       "Node %d LowTotal:       %8lu kB\n"
 +		       "Node %d LowFree:        %8lu kB\n",
 +		       nid, K(i.totalhigh),
 +		       nid, K(i.freehigh),
 +		       nid, K(i.totalram - i.totalhigh),
 +		       nid, K(i.freeram - i.freehigh));
  #endif
 -	len += sysfs_emit_at(buf, len,
 -			     "Node %d Dirty:          %8lu kB\n"
 -			     "Node %d Writeback:      %8lu kB\n"
 -			     "Node %d FilePages:      %8lu kB\n"
 -			     "Node %d Mapped:         %8lu kB\n"
 -			     "Node %d AnonPages:      %8lu kB\n"
 -			     "Node %d Shmem:          %8lu kB\n"
 -			     "Node %d KernelStack:    %8lu kB\n"
 -#ifdef CONFIG_SHADOW_CALL_STACK
 -			     "Node %d ShadowCallStack:%8lu kB\n"
 -#endif
 -			     "Node %d PageTables:     %8lu kB\n"
 -			     "Node %d NFS_Unstable:   %8lu kB\n"
 -			     "Node %d Bounce:         %8lu kB\n"
 -			     "Node %d WritebackTmp:   %8lu kB\n"
 -			     "Node %d KReclaimable:   %8lu kB\n"
 -			     "Node %d Slab:           %8lu kB\n"
 -			     "Node %d SReclaimable:   %8lu kB\n"
 -			     "Node %d SUnreclaim:     %8lu kB\n"
 +	n += sprintf(buf + n,
 +		       "Node %d Dirty:          %8lu kB\n"
 +		       "Node %d Writeback:      %8lu kB\n"
 +		       "Node %d FilePages:      %8lu kB\n"
 +		       "Node %d Mapped:         %8lu kB\n"
 +		       "Node %d AnonPages:      %8lu kB\n"
 +		       "Node %d Shmem:          %8lu kB\n"
 +		       "Node %d KernelStack:    %8lu kB\n"
 +		       "Node %d PageTables:     %8lu kB\n"
 +		       "Node %d NFS_Unstable:   %8lu kB\n"
 +		       "Node %d Bounce:         %8lu kB\n"
 +		       "Node %d WritebackTmp:   %8lu kB\n"
 +		       "Node %d KReclaimable:   %8lu kB\n"
 +		       "Node %d Slab:           %8lu kB\n"
 +		       "Node %d SReclaimable:   %8lu kB\n"
 +		       "Node %d SUnreclaim:     %8lu kB\n"
  #ifdef CONFIG_TRANSPARENT_HUGEPAGE
 -			     "Node %d AnonHugePages:  %8lu kB\n"
 -			     "Node %d ShmemHugePages: %8lu kB\n"
 -			     "Node %d ShmemPmdMapped: %8lu kB\n"
 -			     "Node %d FileHugePages: %8lu kB\n"
 -			     "Node %d FilePmdMapped: %8lu kB\n"
 -#endif
 -			     ,
 -			     nid, K(node_page_state(pgdat, NR_FILE_DIRTY)),
 -			     nid, K(node_page_state(pgdat, NR_WRITEBACK)),
 -			     nid, K(node_page_state(pgdat, NR_FILE_PAGES)),
 -			     nid, K(node_page_state(pgdat, NR_FILE_MAPPED)),
 -			     nid, K(node_page_state(pgdat, NR_ANON_MAPPED)),
 -			     nid, K(i.sharedram),
 -			     nid, node_page_state(pgdat, NR_KERNEL_STACK_KB),
 -#ifdef CONFIG_SHADOW_CALL_STACK
 -			     nid, node_page_state(pgdat, NR_KERNEL_SCS_KB),
 +		       "Node %d AnonHugePages:  %8lu kB\n"
 +		       "Node %d ShmemHugePages: %8lu kB\n"
 +		       "Node %d ShmemPmdMapped: %8lu kB\n"
 +		       "Node %d FileHugePages: %8lu kB\n"
 +		       "Node %d FilePmdMapped: %8lu kB\n"
  #endif
 -			     nid, K(node_page_state(pgdat, NR_PAGETABLE)),
 -			     nid, 0UL,
 -			     nid, K(sum_zone_node_page_state(nid, NR_BOUNCE)),
 -			     nid, K(node_page_state(pgdat, NR_WRITEBACK_TEMP)),
 -			     nid, K(sreclaimable +
 -				    node_page_state(pgdat, NR_KERNEL_MISC_RECLAIMABLE)),
 -			     nid, K(sreclaimable + sunreclaimable),
 -			     nid, K(sreclaimable),
 -			     nid, K(sunreclaimable)
 +			,
 +		       nid, K(node_page_state(pgdat, NR_FILE_DIRTY)),
 +		       nid, K(node_page_state(pgdat, NR_WRITEBACK)),
 +		       nid, K(node_page_state(pgdat, NR_FILE_PAGES)),
 +		       nid, K(node_page_state(pgdat, NR_FILE_MAPPED)),
 +		       nid, K(node_page_state(pgdat, NR_ANON_MAPPED)),
 +		       nid, K(i.sharedram),
 +		       nid, sum_zone_node_page_state(nid, NR_KERNEL_STACK_KB),
 +		       nid, K(sum_zone_node_page_state(nid, NR_PAGETABLE)),
 +		       nid, 0UL,
 +		       nid, K(sum_zone_node_page_state(nid, NR_BOUNCE)),
 +		       nid, K(node_page_state(pgdat, NR_WRITEBACK_TEMP)),
 +		       nid, K(sreclaimable +
 +			      node_page_state(pgdat, NR_KERNEL_MISC_RECLAIMABLE)),
 +		       nid, K(sreclaimable + sunreclaimable),
 +		       nid, K(sreclaimable),
 +		       nid, K(sunreclaimable)
  #ifdef CONFIG_TRANSPARENT_HUGEPAGE
++<<<<<<< HEAD
 +		       ,
 +		       nid, K(node_page_state(pgdat, NR_ANON_THPS) *
 +				       HPAGE_PMD_NR),
 +		       nid, K(node_page_state(pgdat, NR_SHMEM_THPS) *
 +				       HPAGE_PMD_NR),
 +		       nid, K(node_page_state(pgdat, NR_SHMEM_PMDMAPPED) *
 +				       HPAGE_PMD_NR),
 +		       nid, K(node_page_state(pgdat, NR_FILE_THPS) *
 +				       HPAGE_PMD_NR),
 +		       nid, K(node_page_state(pgdat, NR_FILE_PMDMAPPED) *
 +				       HPAGE_PMD_NR)
++=======
+ 			     ,
+ 			     nid, K(node_page_state(pgdat, NR_ANON_THPS)),
+ 			     nid, K(node_page_state(pgdat, NR_SHMEM_THPS)),
+ 			     nid, K(node_page_state(pgdat, NR_SHMEM_PMDMAPPED)),
+ 			     nid, K(node_page_state(pgdat, NR_FILE_THPS)),
+ 			     nid, K(node_page_state(pgdat, NR_FILE_PMDMAPPED) *
+ 				    HPAGE_PMD_NR)
++>>>>>>> a1528e21f891 (mm: memcontrol: convert NR_SHMEM_PMDMAPPED account to pages)
  #endif
 -			    );
 -	len += hugetlb_report_node_meminfo(buf, len, nid);
 -	return len;
 +		       );
 +	n += hugetlb_report_node_meminfo(nid, buf + n);
 +	return n;
  }
  
  #undef K
diff --cc include/linux/mmzone.h
index ae118ed2cb9b,7bdbfeeb5c8c..000000000000
--- a/include/linux/mmzone.h
+++ b/include/linux/mmzone.h
@@@ -213,6 -210,22 +213,25 @@@ enum node_stat_item 
  };
  
  /*
++<<<<<<< HEAD
++=======
+  * Returns true if the item should be printed in THPs (/proc/vmstat
+  * currently prints number of anon, file and shmem THPs. But the item
+  * is charged in pages).
+  */
+ static __always_inline bool vmstat_item_print_in_thp(enum node_stat_item item)
+ {
+ 	if (!IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE))
+ 		return false;
+ 
+ 	return item == NR_ANON_THPS ||
+ 	       item == NR_FILE_THPS ||
+ 	       item == NR_SHMEM_THPS ||
+ 	       item == NR_SHMEM_PMDMAPPED;
+ }
+ 
+ /*
++>>>>>>> a1528e21f891 (mm: memcontrol: convert NR_SHMEM_PMDMAPPED account to pages)
   * Returns true if the value is measured in bytes (most vmstat values are
   * measured in pages). This defines the API part, the internal representation
   * might be different.
diff --cc mm/page_alloc.c
index 8c7425895151,069561aadc7b..000000000000
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@@ -5405,12 -5584,16 +5405,18 @@@ void show_free_areas(unsigned int filte
  			K(node_page_state(pgdat, NR_WRITEBACK)),
  			K(node_page_state(pgdat, NR_SHMEM)),
  #ifdef CONFIG_TRANSPARENT_HUGEPAGE
++<<<<<<< HEAD
 +			K(node_page_state(pgdat, NR_SHMEM_THPS) * HPAGE_PMD_NR),
 +			K(node_page_state(pgdat, NR_SHMEM_PMDMAPPED)
 +					* HPAGE_PMD_NR),
 +			K(node_page_state(pgdat, NR_ANON_THPS) * HPAGE_PMD_NR),
++=======
+ 			K(node_page_state(pgdat, NR_SHMEM_THPS)),
+ 			K(node_page_state(pgdat, NR_SHMEM_PMDMAPPED)),
+ 			K(node_page_state(pgdat, NR_ANON_THPS)),
++>>>>>>> a1528e21f891 (mm: memcontrol: convert NR_SHMEM_PMDMAPPED account to pages)
  #endif
  			K(node_page_state(pgdat, NR_WRITEBACK_TEMP)),
 -			node_page_state(pgdat, NR_KERNEL_STACK_KB),
 -#ifdef CONFIG_SHADOW_CALL_STACK
 -			node_page_state(pgdat, NR_KERNEL_SCS_KB),
 -#endif
 -			K(node_page_state(pgdat, NR_PAGETABLE)),
  			pgdat->kswapd_failures >= MAX_RECLAIM_RETRIES ?
  				"yes" : "no");
  	}
* Unmerged path drivers/base/node.c
diff --git a/fs/proc/meminfo.c b/fs/proc/meminfo.c
index 89a6b114397f..60647095a052 100644
--- a/fs/proc/meminfo.c
+++ b/fs/proc/meminfo.c
@@ -134,7 +134,7 @@ static int meminfo_proc_show(struct seq_file *m, void *v)
 	show_val_kb(m, "ShmemHugePages: ",
 		    global_node_page_state(NR_SHMEM_THPS) * HPAGE_PMD_NR);
 	show_val_kb(m, "ShmemPmdMapped: ",
-		    global_node_page_state(NR_SHMEM_PMDMAPPED) * HPAGE_PMD_NR);
+		    global_node_page_state(NR_SHMEM_PMDMAPPED));
 	show_val_kb(m, "FileHugePages:  ",
 		    global_node_page_state(NR_FILE_THPS) * HPAGE_PMD_NR);
 	show_val_kb(m, "FilePmdMapped:  ",
* Unmerged path include/linux/mmzone.h
* Unmerged path mm/page_alloc.c
diff --git a/mm/rmap.c b/mm/rmap.c
index 2dedbfb3e93d..b845fcc430c9 100644
--- a/mm/rmap.c
+++ b/mm/rmap.c
@@ -1204,14 +1204,17 @@ void page_add_file_rmap(struct page *page, bool compound)
 	VM_BUG_ON_PAGE(compound && !PageTransHuge(page), page);
 	lock_page_memcg(page);
 	if (compound && PageTransHuge(page)) {
-		for (i = 0, nr = 0; i < thp_nr_pages(page); i++) {
+		int nr_pages = thp_nr_pages(page);
+
+		for (i = 0, nr = 0; i < nr_pages; i++) {
 			if (atomic_inc_and_test(&page[i]._mapcount))
 				nr++;
 		}
 		if (!atomic_inc_and_test(compound_mapcount_ptr(page)))
 			goto out;
 		if (PageSwapBacked(page))
-			__inc_node_page_state(page, NR_SHMEM_PMDMAPPED);
+			__mod_lruvec_page_state(page, NR_SHMEM_PMDMAPPED,
+						nr_pages);
 		else
 			__inc_node_page_state(page, NR_FILE_PMDMAPPED);
 	} else {
@@ -1245,14 +1248,17 @@ static void page_remove_file_rmap(struct page *page, bool compound)
 
 	/* page still mapped by someone else? */
 	if (compound && PageTransHuge(page)) {
-		for (i = 0, nr = 0; i < thp_nr_pages(page); i++) {
+		int nr_pages = thp_nr_pages(page);
+
+		for (i = 0, nr = 0; i < nr_pages; i++) {
 			if (atomic_add_negative(-1, &page[i]._mapcount))
 				nr++;
 		}
 		if (!atomic_add_negative(-1, compound_mapcount_ptr(page)))
 			return;
 		if (PageSwapBacked(page))
-			__dec_node_page_state(page, NR_SHMEM_PMDMAPPED);
+			__mod_lruvec_page_state(page, NR_SHMEM_PMDMAPPED,
+						-nr_pages);
 		else
 			__dec_node_page_state(page, NR_FILE_PMDMAPPED);
 	} else {
