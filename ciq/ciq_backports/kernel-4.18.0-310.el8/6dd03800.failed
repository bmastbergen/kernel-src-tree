KVM: x86/mmu: Make dirty log size hook (PML) a value, not a function

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Sean Christopherson <seanjc@google.com>
commit 6dd03800b1afe4d3b6f26b0d20f2e1ecebf32b29
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/6dd03800.failed

Store the vendor-specific dirty log size in a variable, there's no need
to wrap it in a function since the value is constant after
hardware_setup() runs.

	Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20210213005015.1651772-9-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 6dd03800b1afe4d3b6f26b0d20f2e1ecebf32b29)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/kvm_host.h
#	arch/x86/kvm/mmu/mmu.c
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/include/asm/kvm_host.h
index 35dd7577a5ae,fb59933610d9..000000000000
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@@ -1286,6 -1294,7 +1286,10 @@@ struct kvm_x86_ops 
  	void (*enable_log_dirty_pt_masked)(struct kvm *kvm,
  					   struct kvm_memory_slot *slot,
  					   gfn_t offset, unsigned long mask);
++<<<<<<< HEAD
++=======
+ 	int cpu_dirty_log_size;
++>>>>>>> 6dd03800b1af (KVM: x86/mmu: Make dirty log size hook (PML) a value, not a function)
  
  	/* pmu operations of sub-arch */
  	const struct kvm_pmu_ops *pmu_ops;
diff --cc arch/x86/kvm/mmu/mmu.c
index d71bddea6b0a,0ed52397c274..000000000000
--- a/arch/x86/kvm/mmu/mmu.c
+++ b/arch/x86/kvm/mmu/mmu.c
@@@ -1291,6 -1292,11 +1291,14 @@@ void kvm_arch_mmu_enable_log_dirty_pt_m
  		kvm_mmu_write_protect_pt_masked(kvm, slot, gfn_offset, mask);
  }
  
++<<<<<<< HEAD
++=======
+ int kvm_cpu_dirty_log_size(void)
+ {
+ 	return kvm_x86_ops.cpu_dirty_log_size;
+ }
+ 
++>>>>>>> 6dd03800b1af (KVM: x86/mmu: Make dirty log size hook (PML) a value, not a function)
  bool kvm_mmu_slot_gfn_write_protect(struct kvm *kvm,
  				    struct kvm_memory_slot *slot, u64 gfn)
  {
diff --cc arch/x86/kvm/vmx/vmx.c
index 9c626d532031,02456ab8fd0c..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -7715,6 -7772,9 +7716,12 @@@ static struct kvm_x86_ops vmx_x86_ops _
  	.migrate_timers = vmx_migrate_timers,
  
  	.msr_filter_changed = vmx_msr_filter_changed,
++<<<<<<< HEAD
++=======
+ 	.complete_emulated_msr = kvm_complete_insn_gp,
+ 
+ 	.vcpu_deliver_sipi_vector = kvm_vcpu_deliver_sipi_vector,
++>>>>>>> 6dd03800b1af (KVM: x86/mmu: Make dirty log size hook (PML) a value, not a function)
  };
  
  static __init int hardware_setup(void)
@@@ -7832,6 -7894,7 +7839,10 @@@
  		vmx_x86_ops.slot_disable_log_dirty = NULL;
  		vmx_x86_ops.flush_log_dirty = NULL;
  		vmx_x86_ops.enable_log_dirty_pt_masked = NULL;
++<<<<<<< HEAD
++=======
+ 		vmx_x86_ops.cpu_dirty_log_size = 0;
++>>>>>>> 6dd03800b1af (KVM: x86/mmu: Make dirty log size hook (PML) a value, not a function)
  	}
  
  	if (!cpu_has_vmx_preemption_timer())
diff --git a/arch/x86/include/asm/kvm-x86-ops.h b/arch/x86/include/asm/kvm-x86-ops.h
index 355a2ab8fc09..28c07cc01474 100644
--- a/arch/x86/include/asm/kvm-x86-ops.h
+++ b/arch/x86/include/asm/kvm-x86-ops.h
@@ -97,7 +97,6 @@ KVM_X86_OP_NULL(slot_enable_log_dirty)
 KVM_X86_OP_NULL(slot_disable_log_dirty)
 KVM_X86_OP_NULL(flush_log_dirty)
 KVM_X86_OP_NULL(enable_log_dirty_pt_masked)
-KVM_X86_OP_NULL(cpu_dirty_log_size)
 KVM_X86_OP_NULL(pre_block)
 KVM_X86_OP_NULL(post_block)
 KVM_X86_OP_NULL(vcpu_blocking)
* Unmerged path arch/x86/include/asm/kvm_host.h
* Unmerged path arch/x86/kvm/mmu/mmu.c
* Unmerged path arch/x86/kvm/vmx/vmx.c
