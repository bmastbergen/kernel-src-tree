KVM: selftests: List all hugetlb src types specified with page sizes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Yanan Wang <wangyanan55@huawei.com>
commit 623653b7d4622cb7d016e9a81e6a9d0d9b1326df
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/623653b7.failed

With VM_MEM_SRC_ANONYMOUS_HUGETLB, we currently can only use system
default hugetlb pages to back the testing guest memory. In order to
add flexibility, now list all the known hugetlb backing src types with
different page sizes, so that we can specify use of hugetlb pages of the
exact granularity that we want. And as all the known hugetlb page sizes
are listed, it's appropriate for all architectures.

Besides, the helper get_backing_src_pagesz() is added to get the
granularity of different backing src types(anonumous, thp, hugetlb).

	Suggested-by: Ben Gardon <bgardon@google.com>
	Signed-off-by: Yanan Wang <wangyanan55@huawei.com>
	Reviewed-by: Andrew Jones <drjones@redhat.com>
Message-Id: <20210330080856.14940-9-wangyanan55@huawei.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 623653b7d4622cb7d016e9a81e6a9d0d9b1326df)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/kvm/include/test_util.h
#	tools/testing/selftests/kvm/lib/test_util.c
diff --cc tools/testing/selftests/kvm/include/test_util.h
index 1cc036ddb0c5,fade3130eb01..000000000000
--- a/tools/testing/selftests/kvm/include/test_util.h
+++ b/tools/testing/selftests/kvm/include/test_util.h
@@@ -64,6 -64,40 +64,44 @@@ int64_t timespec_to_ns(struct timespec 
  struct timespec timespec_add_ns(struct timespec ts, int64_t ns);
  struct timespec timespec_add(struct timespec ts1, struct timespec ts2);
  struct timespec timespec_sub(struct timespec ts1, struct timespec ts2);
++<<<<<<< HEAD
 +struct timespec timespec_diff_now(struct timespec start);
++=======
+ struct timespec timespec_elapsed(struct timespec start);
+ struct timespec timespec_div(struct timespec ts, int divisor);
+ 
+ enum vm_mem_backing_src_type {
+ 	VM_MEM_SRC_ANONYMOUS,
+ 	VM_MEM_SRC_ANONYMOUS_THP,
+ 	VM_MEM_SRC_ANONYMOUS_HUGETLB,
+ 	VM_MEM_SRC_ANONYMOUS_HUGETLB_16KB,
+ 	VM_MEM_SRC_ANONYMOUS_HUGETLB_64KB,
+ 	VM_MEM_SRC_ANONYMOUS_HUGETLB_512KB,
+ 	VM_MEM_SRC_ANONYMOUS_HUGETLB_1MB,
+ 	VM_MEM_SRC_ANONYMOUS_HUGETLB_2MB,
+ 	VM_MEM_SRC_ANONYMOUS_HUGETLB_8MB,
+ 	VM_MEM_SRC_ANONYMOUS_HUGETLB_16MB,
+ 	VM_MEM_SRC_ANONYMOUS_HUGETLB_32MB,
+ 	VM_MEM_SRC_ANONYMOUS_HUGETLB_256MB,
+ 	VM_MEM_SRC_ANONYMOUS_HUGETLB_512MB,
+ 	VM_MEM_SRC_ANONYMOUS_HUGETLB_1GB,
+ 	VM_MEM_SRC_ANONYMOUS_HUGETLB_2GB,
+ 	VM_MEM_SRC_ANONYMOUS_HUGETLB_16GB,
+ 	NUM_SRC_TYPES,
+ };
+ 
+ struct vm_mem_backing_src_alias {
+ 	const char *name;
+ 	uint32_t flag;
+ };
+ 
+ bool thp_configured(void);
+ size_t get_trans_hugepagesz(void);
+ size_t get_def_hugetlb_pagesz(void);
+ const struct vm_mem_backing_src_alias *vm_mem_backing_src_alias(uint32_t i);
+ size_t get_backing_src_pagesz(uint32_t i);
+ void backing_src_help(void);
+ enum vm_mem_backing_src_type parse_backing_src_type(const char *type_name);
++>>>>>>> 623653b7d462 (KVM: selftests: List all hugetlb src types specified with page sizes)
  
  #endif /* SELFTEST_KVM_TEST_UTIL_H */
diff --cc tools/testing/selftests/kvm/lib/test_util.c
index 1a46c2c48c7c,63d2bc7d757b..000000000000
--- a/tools/testing/selftests/kvm/lib/test_util.c
+++ b/tools/testing/selftests/kvm/lib/test_util.c
@@@ -10,6 -10,9 +10,12 @@@
  #include <limits.h>
  #include <stdlib.h>
  #include <time.h>
++<<<<<<< HEAD
++=======
+ #include <sys/stat.h>
+ #include <linux/mman.h>
+ #include "linux/kernel.h"
++>>>>>>> 623653b7d462 (KVM: selftests: List all hugetlb src types specified with page sizes)
  
  #include "test_util.h"
  
@@@ -102,3 -112,172 +108,175 @@@ void print_skip(const char *fmt, ...
  	va_end(ap);
  	puts(", skipping test");
  }
++<<<<<<< HEAD
++=======
+ 
+ bool thp_configured(void)
+ {
+ 	int ret;
+ 	struct stat statbuf;
+ 
+ 	ret = stat("/sys/kernel/mm/transparent_hugepage", &statbuf);
+ 	TEST_ASSERT(ret == 0 || (ret == -1 && errno == ENOENT),
+ 		    "Error in stating /sys/kernel/mm/transparent_hugepage");
+ 
+ 	return ret == 0;
+ }
+ 
+ size_t get_trans_hugepagesz(void)
+ {
+ 	size_t size;
+ 	FILE *f;
+ 
+ 	TEST_ASSERT(thp_configured(), "THP is not configured in host kernel");
+ 
+ 	f = fopen("/sys/kernel/mm/transparent_hugepage/hpage_pmd_size", "r");
+ 	TEST_ASSERT(f != NULL, "Error in opening transparent_hugepage/hpage_pmd_size");
+ 
+ 	fscanf(f, "%ld", &size);
+ 	fclose(f);
+ 
+ 	return size;
+ }
+ 
+ size_t get_def_hugetlb_pagesz(void)
+ {
+ 	char buf[64];
+ 	const char *tag = "Hugepagesize:";
+ 	FILE *f;
+ 
+ 	f = fopen("/proc/meminfo", "r");
+ 	TEST_ASSERT(f != NULL, "Error in opening /proc/meminfo");
+ 
+ 	while (fgets(buf, sizeof(buf), f) != NULL) {
+ 		if (strstr(buf, tag) == buf) {
+ 			fclose(f);
+ 			return strtoull(buf + strlen(tag), NULL, 10) << 10;
+ 		}
+ 	}
+ 
+ 	if (feof(f))
+ 		TEST_FAIL("HUGETLB is not configured in host kernel");
+ 	else
+ 		TEST_FAIL("Error in reading /proc/meminfo");
+ 
+ 	fclose(f);
+ 	return 0;
+ }
+ 
+ const struct vm_mem_backing_src_alias *vm_mem_backing_src_alias(uint32_t i)
+ {
+ 	static const struct vm_mem_backing_src_alias aliases[] = {
+ 		[VM_MEM_SRC_ANONYMOUS] = {
+ 			.name = "anonymous",
+ 			.flag = 0,
+ 		},
+ 		[VM_MEM_SRC_ANONYMOUS_THP] = {
+ 			.name = "anonymous_thp",
+ 			.flag = 0,
+ 		},
+ 		[VM_MEM_SRC_ANONYMOUS_HUGETLB] = {
+ 			.name = "anonymous_hugetlb",
+ 			.flag = MAP_HUGETLB,
+ 		},
+ 		[VM_MEM_SRC_ANONYMOUS_HUGETLB_16KB] = {
+ 			.name = "anonymous_hugetlb_16kb",
+ 			.flag = MAP_HUGETLB | MAP_HUGE_16KB,
+ 		},
+ 		[VM_MEM_SRC_ANONYMOUS_HUGETLB_64KB] = {
+ 			.name = "anonymous_hugetlb_64kb",
+ 			.flag = MAP_HUGETLB | MAP_HUGE_64KB,
+ 		},
+ 		[VM_MEM_SRC_ANONYMOUS_HUGETLB_512KB] = {
+ 			.name = "anonymous_hugetlb_512kb",
+ 			.flag = MAP_HUGETLB | MAP_HUGE_512KB,
+ 		},
+ 		[VM_MEM_SRC_ANONYMOUS_HUGETLB_1MB] = {
+ 			.name = "anonymous_hugetlb_1mb",
+ 			.flag = MAP_HUGETLB | MAP_HUGE_1MB,
+ 		},
+ 		[VM_MEM_SRC_ANONYMOUS_HUGETLB_2MB] = {
+ 			.name = "anonymous_hugetlb_2mb",
+ 			.flag = MAP_HUGETLB | MAP_HUGE_2MB,
+ 		},
+ 		[VM_MEM_SRC_ANONYMOUS_HUGETLB_8MB] = {
+ 			.name = "anonymous_hugetlb_8mb",
+ 			.flag = MAP_HUGETLB | MAP_HUGE_8MB,
+ 		},
+ 		[VM_MEM_SRC_ANONYMOUS_HUGETLB_16MB] = {
+ 			.name = "anonymous_hugetlb_16mb",
+ 			.flag = MAP_HUGETLB | MAP_HUGE_16MB,
+ 		},
+ 		[VM_MEM_SRC_ANONYMOUS_HUGETLB_32MB] = {
+ 			.name = "anonymous_hugetlb_32mb",
+ 			.flag = MAP_HUGETLB | MAP_HUGE_32MB,
+ 		},
+ 		[VM_MEM_SRC_ANONYMOUS_HUGETLB_256MB] = {
+ 			.name = "anonymous_hugetlb_256mb",
+ 			.flag = MAP_HUGETLB | MAP_HUGE_256MB,
+ 		},
+ 		[VM_MEM_SRC_ANONYMOUS_HUGETLB_512MB] = {
+ 			.name = "anonymous_hugetlb_512mb",
+ 			.flag = MAP_HUGETLB | MAP_HUGE_512MB,
+ 		},
+ 		[VM_MEM_SRC_ANONYMOUS_HUGETLB_1GB] = {
+ 			.name = "anonymous_hugetlb_1gb",
+ 			.flag = MAP_HUGETLB | MAP_HUGE_1GB,
+ 		},
+ 		[VM_MEM_SRC_ANONYMOUS_HUGETLB_2GB] = {
+ 			.name = "anonymous_hugetlb_2gb",
+ 			.flag = MAP_HUGETLB | MAP_HUGE_2GB,
+ 		},
+ 		[VM_MEM_SRC_ANONYMOUS_HUGETLB_16GB] = {
+ 			.name = "anonymous_hugetlb_16gb",
+ 			.flag = MAP_HUGETLB | MAP_HUGE_16GB,
+ 		},
+ 	};
+ 	_Static_assert(ARRAY_SIZE(aliases) == NUM_SRC_TYPES,
+ 		       "Missing new backing src types?");
+ 
+ 	TEST_ASSERT(i < NUM_SRC_TYPES, "Backing src type ID %d too big", i);
+ 
+ 	return &aliases[i];
+ }
+ 
+ #define MAP_HUGE_PAGE_SIZE(x) (1ULL << ((x >> MAP_HUGE_SHIFT) & MAP_HUGE_MASK))
+ 
+ size_t get_backing_src_pagesz(uint32_t i)
+ {
+ 	uint32_t flag = vm_mem_backing_src_alias(i)->flag;
+ 
+ 	switch (i) {
+ 	case VM_MEM_SRC_ANONYMOUS:
+ 		return getpagesize();
+ 	case VM_MEM_SRC_ANONYMOUS_THP:
+ 		return get_trans_hugepagesz();
+ 	case VM_MEM_SRC_ANONYMOUS_HUGETLB:
+ 		return get_def_hugetlb_pagesz();
+ 	default:
+ 		return MAP_HUGE_PAGE_SIZE(flag);
+ 	}
+ }
+ 
+ void backing_src_help(void)
+ {
+ 	int i;
+ 
+ 	printf("Available backing src types:\n");
+ 	for (i = 0; i < NUM_SRC_TYPES; i++)
+ 		printf("\t%s\n", vm_mem_backing_src_alias(i)->name);
+ }
+ 
+ enum vm_mem_backing_src_type parse_backing_src_type(const char *type_name)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < NUM_SRC_TYPES; i++)
+ 		if (!strcmp(type_name, vm_mem_backing_src_alias(i)->name))
+ 			return i;
+ 
+ 	backing_src_help();
+ 	TEST_FAIL("Unknown backing src type: %s", type_name);
+ 	return -1;
+ }
++>>>>>>> 623653b7d462 (KVM: selftests: List all hugetlb src types specified with page sizes)
* Unmerged path tools/testing/selftests/kvm/include/test_util.h
diff --git a/tools/testing/selftests/kvm/lib/kvm_util.c b/tools/testing/selftests/kvm/lib/kvm_util.c
index a84de7ef2cbb..c0602fe5e5f8 100644
--- a/tools/testing/selftests/kvm/lib/kvm_util.c
+++ b/tools/testing/selftests/kvm/lib/kvm_util.c
@@ -759,7 +759,7 @@ void vm_userspace_mem_region_add(struct kvm_vm *vm,
 	region->mmap_start = mmap(NULL, region->mmap_size,
 				  PROT_READ | PROT_WRITE,
 				  MAP_PRIVATE | MAP_ANONYMOUS
-				  | (src_type == VM_MEM_SRC_ANONYMOUS_HUGETLB ? MAP_HUGETLB : 0),
+				  | vm_mem_backing_src_alias(src_type)->flag,
 				  -1, 0);
 	TEST_ASSERT(region->mmap_start != MAP_FAILED,
 		    "test_malloc failed, mmap_start: %p errno: %i",
* Unmerged path tools/testing/selftests/kvm/lib/test_util.c
