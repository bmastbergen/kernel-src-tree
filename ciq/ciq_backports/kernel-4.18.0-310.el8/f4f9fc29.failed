nvme: fix the nsid value to print in nvme_validate_or_alloc_ns

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Christoph Hellwig <hch@lst.de>
commit f4f9fc29e56b6fa9d7fa65ec51d3c82aff99c99b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/f4f9fc29.failed

ns can be NULL at this point, and my move of the check from
the original patch by Chaitanya broke this.

Fixes: 0ec84df4953b ("nvme-core: check ctrl css before setting up zns")
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit f4f9fc29e56b6fa9d7fa65ec51d3c82aff99c99b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
diff --cc drivers/nvme/host/core.c
index 67eeb4f22720,a5653892d773..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -4143,17 -4036,79 +4143,47 @@@ static void nvme_ns_remove_by_nsid(stru
  	}
  }
  
 -static void nvme_validate_ns(struct nvme_ns *ns, struct nvme_ns_ids *ids)
 -{
 -	struct nvme_id_ns *id;
 -	int ret = NVME_SC_INVALID_NS | NVME_SC_DNR;
 -
 -	if (test_bit(NVME_NS_DEAD, &ns->flags))
 -		goto out;
 -
 -	ret = nvme_identify_ns(ns->ctrl, ns->head->ns_id, ids, &id);
 -	if (ret)
 -		goto out;
 -
 -	ret = NVME_SC_INVALID_NS | NVME_SC_DNR;
 -	if (!nvme_ns_ids_equal(&ns->head->ids, ids)) {
 -		dev_err(ns->ctrl->device,
 -			"identifiers changed for nsid %d\n", ns->head->ns_id);
 -		goto out_free_id;
 -	}
 -
 -	ret = nvme_update_ns_info(ns, id);
 -
 -out_free_id:
 -	kfree(id);
 -out:
 -	/*
 -	 * Only remove the namespace if we got a fatal error back from the
 -	 * device, otherwise ignore the error and just move on.
 -	 *
 -	 * TODO: we should probably schedule a delayed retry here.
 -	 */
 -	if (ret > 0 && (ret & NVME_SC_DNR))
 -		nvme_ns_remove(ns);
 -}
 -
  static void nvme_validate_or_alloc_ns(struct nvme_ctrl *ctrl, unsigned nsid)
  {
 -	struct nvme_ns_ids ids = { };
  	struct nvme_ns *ns;
  
 -	if (nvme_identify_ns_descs(ctrl, nsid, &ids))
 -		return;
 -
  	ns = nvme_find_get_ns(ctrl, nsid);
  	if (ns) {
 -		nvme_validate_ns(ns, &ids);
 +		if (revalidate_disk(ns->disk))
 +			nvme_ns_remove(ns);
  		nvme_put_ns(ns);
++<<<<<<< HEAD
 +	} else
 +		nvme_alloc_ns(ctrl, nsid);
++=======
+ 		return;
+ 	}
+ 
+ 	switch (ids.csi) {
+ 	case NVME_CSI_NVM:
+ 		nvme_alloc_ns(ctrl, nsid, &ids);
+ 		break;
+ 	case NVME_CSI_ZNS:
+ 		if (!IS_ENABLED(CONFIG_BLK_DEV_ZONED)) {
+ 			dev_warn(ctrl->device,
+ 				"nsid %u not supported without CONFIG_BLK_DEV_ZONED\n",
+ 				nsid);
+ 			break;
+ 		}
+ 		if (!nvme_multi_css(ctrl)) {
+ 			dev_warn(ctrl->device,
+ 				"command set not reported for nsid: %d\n",
+ 				nsid);
+ 			break;
+ 		}
+ 		nvme_alloc_ns(ctrl, nsid, &ids);
+ 		break;
+ 	default:
+ 		dev_warn(ctrl->device, "unknown csi %u for nsid %u\n",
+ 			ids.csi, nsid);
+ 		break;
+ 	}
++>>>>>>> f4f9fc29e56b (nvme: fix the nsid value to print in nvme_validate_or_alloc_ns)
  }
  
  static void nvme_remove_invalid_namespaces(struct nvme_ctrl *ctrl,
* Unmerged path drivers/nvme/host/core.c
