KVM: selftests: Add backing src parameter to dirty_log_perf_test

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Ben Gardon <bgardon@google.com>
commit 9e965bb75aaec28a9537e35871106367fe88b702
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/9e965bb7.failed

Add a parameter to control the backing memory type for
dirty_log_perf_test so that the test can be run with hugepages.

To: linux-kselftest@vger.kernel.org
CC: Peter Xu <peterx@redhat.com>
CC: Andrew Jones <drjones@redhat.com>
CC: Thomas Huth <thuth@redhat.com>
	Signed-off-by: Ben Gardon <bgardon@google.com>
Message-Id: <20210202185734.1680553-28-bgardon@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 9e965bb75aaec28a9537e35871106367fe88b702)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/kvm/demand_paging_test.c
#	tools/testing/selftests/kvm/dirty_log_perf_test.c
#	tools/testing/selftests/kvm/include/kvm_util.h
#	tools/testing/selftests/kvm/include/perf_test_util.h
#	tools/testing/selftests/kvm/lib/perf_test_util.c
#	tools/testing/selftests/kvm/memslot_modification_stress_test.c
diff --cc tools/testing/selftests/kvm/demand_paging_test.c
index 3d96a7bfaff3,5f7a229c3af1..000000000000
--- a/tools/testing/selftests/kvm/demand_paging_test.c
+++ b/tools/testing/selftests/kvm/demand_paging_test.c
@@@ -261,7 -266,8 +261,12 @@@ static void run_test(enum vm_guest_mod
  	int vcpu_id;
  	int r;
  
++<<<<<<< HEAD
 +	vm = create_vm(mode, nr_vcpus, guest_percpu_mem_size);
++=======
+ 	vm = perf_test_create_vm(mode, nr_vcpus, guest_percpu_mem_size,
+ 				 VM_MEM_SRC_ANONYMOUS);
++>>>>>>> 9e965bb75aae (KVM: selftests: Add backing src parameter to dirty_log_perf_test)
  
  	perf_test_args.wr_fract = 1;
  
diff --cc tools/testing/selftests/kvm/include/kvm_util.h
index dfa9d369e8fc,2d7eb6989e83..000000000000
--- a/tools/testing/selftests/kvm/include/kvm_util.h
+++ b/tools/testing/selftests/kvm/include/kvm_util.h
@@@ -70,11 -71,13 +70,21 @@@ enum vm_guest_mode 
  #define vm_guest_mode_string(m) vm_guest_mode_string[m]
  extern const char * const vm_guest_mode_string[];
  
++<<<<<<< HEAD
 +enum vm_mem_backing_src_type {
 +	VM_MEM_SRC_ANONYMOUS,
 +	VM_MEM_SRC_ANONYMOUS_THP,
 +	VM_MEM_SRC_ANONYMOUS_HUGETLB,
 +};
++=======
+ struct vm_guest_mode_params {
+ 	unsigned int pa_bits;
+ 	unsigned int va_bits;
+ 	unsigned int page_size;
+ 	unsigned int page_shift;
+ };
+ extern const struct vm_guest_mode_params vm_guest_mode_params[];
++>>>>>>> 9e965bb75aae (KVM: selftests: Add backing src parameter to dirty_log_perf_test)
  
  int kvm_check_cap(long cap);
  int vm_enable_cap(struct kvm_vm *vm, struct kvm_enable_cap *cap);
diff --cc tools/testing/selftests/kvm/include/perf_test_util.h
index e9e0ac1876cf,005f2143adeb..000000000000
--- a/tools/testing/selftests/kvm/include/perf_test_util.h
+++ b/tools/testing/selftests/kvm/include/perf_test_util.h
@@@ -54,139 -31,24 +54,149 @@@ struct perf_test_args 
  	uint64_t guest_page_size;
  	int wr_fract;
  
 -	struct perf_test_vcpu_args vcpu_args[KVM_MAX_VCPUS];
 +	struct vcpu_args vcpu_args[MAX_VCPUS];
  };
  
 -extern struct perf_test_args perf_test_args;
 +static struct perf_test_args perf_test_args;
  
  /*
 - * Guest physical memory offset of the testing memory slot.
 - * This will be set to the topmost valid physical address minus
 - * the test memory size.
 + * Continuously write to the first 8 bytes of each page in the
 + * specified region.
   */
 -extern uint64_t guest_test_phys_mem;
 +static void guest_code(uint32_t vcpu_id)
 +{
 +	struct vcpu_args *vcpu_args = &perf_test_args.vcpu_args[vcpu_id];
 +	uint64_t gva;
 +	uint64_t pages;
 +	int i;
 +
++<<<<<<< HEAD
 +	/* Make sure vCPU args data structure is not corrupt. */
 +	GUEST_ASSERT(vcpu_args->vcpu_id == vcpu_id);
 +
 +	gva = vcpu_args->gva;
 +	pages = vcpu_args->pages;
 +
 +	for (i = 0; i < pages; i++) {
 +		uint64_t addr = gva + (i * perf_test_args.guest_page_size);
 +
 +		if (i % perf_test_args.wr_fract == 0)
 +			*(uint64_t *)addr = 0x0123456789ABCDEF;
 +		else
 +			READ_ONCE(*(uint64_t *)addr);
 +	}
 +
 +	GUEST_SYNC(1);
 +}
 +
 +static struct kvm_vm *create_vm(enum vm_guest_mode mode, int vcpus,
 +				uint64_t vcpu_memory_bytes)
 +{
 +	struct kvm_vm *vm;
 +	uint64_t pages = DEFAULT_GUEST_PHY_PAGES;
 +	uint64_t guest_num_pages;
 +
 +	/* Account for a few pages per-vCPU for stacks */
 +	pages += DEFAULT_STACK_PGS * vcpus;
 +
 +	/*
 +	 * Reserve twice the ammount of memory needed to map the test region and
 +	 * the page table / stacks region, at 4k, for page tables. Do the
 +	 * calculation with 4K page size: the smallest of all archs. (e.g., 64K
 +	 * page size guest will need even less memory for page tables).
 +	 */
 +	pages += (2 * pages) / PTES_PER_4K_PT;
 +	pages += ((2 * vcpus * vcpu_memory_bytes) >> PAGE_SHIFT_4K) /
 +		 PTES_PER_4K_PT;
 +	pages = vm_adjust_num_guest_pages(mode, pages);
 +
 +	pr_info("Testing guest mode: %s\n", vm_guest_mode_string(mode));
 +
 +	vm = vm_create(mode, pages, O_RDWR);
 +	kvm_vm_elf_load(vm, program_invocation_name, 0, 0);
 +#ifdef __x86_64__
 +	vm_create_irqchip(vm);
 +#endif
 +
 +	perf_test_args.vm = vm;
 +	perf_test_args.guest_page_size = vm_get_page_size(vm);
 +	perf_test_args.host_page_size = getpagesize();
 +
 +	TEST_ASSERT(vcpu_memory_bytes % perf_test_args.guest_page_size == 0,
 +		    "Guest memory size is not guest page size aligned.");
 +
 +	guest_num_pages = (vcpus * vcpu_memory_bytes) /
 +			  perf_test_args.guest_page_size;
 +	guest_num_pages = vm_adjust_num_guest_pages(mode, guest_num_pages);
 +
 +	/*
 +	 * If there should be more memory in the guest test region than there
 +	 * can be pages in the guest, it will definitely cause problems.
 +	 */
 +	TEST_ASSERT(guest_num_pages < vm_get_max_gfn(vm),
 +		    "Requested more guest memory than address space allows.\n"
 +		    "    guest pages: %lx max gfn: %x vcpus: %d wss: %lx]\n",
 +		    guest_num_pages, vm_get_max_gfn(vm), vcpus,
 +		    vcpu_memory_bytes);
 +
 +	TEST_ASSERT(vcpu_memory_bytes % perf_test_args.host_page_size == 0,
 +		    "Guest memory size is not host page size aligned.");
 +
 +	guest_test_phys_mem = (vm_get_max_gfn(vm) - guest_num_pages) *
 +			      perf_test_args.guest_page_size;
 +	guest_test_phys_mem &= ~(perf_test_args.host_page_size - 1);
 +
 +#ifdef __s390x__
 +	/* Align to 1M (segment size) */
 +	guest_test_phys_mem &= ~((1 << 20) - 1);
 +#endif
 +
 +	pr_info("guest physical test memory offset: 0x%lx\n", guest_test_phys_mem);
 +
 +	/* Add an extra memory slot for testing */
 +	vm_userspace_mem_region_add(vm, VM_MEM_SRC_ANONYMOUS,
 +				    guest_test_phys_mem,
 +				    TEST_MEM_SLOT_INDEX,
 +				    guest_num_pages, 0);
 +
 +	/* Do mapping for the demand paging memory slot */
 +	virt_map(vm, guest_test_virt_mem, guest_test_phys_mem, guest_num_pages, 0);
 +
 +	ucall_init(vm, NULL);
 +
 +	return vm;
 +}
 +
 +static void add_vcpus(struct kvm_vm *vm, int vcpus, uint64_t vcpu_memory_bytes)
 +{
 +	vm_paddr_t vcpu_gpa;
 +	struct vcpu_args *vcpu_args;
 +	int vcpu_id;
 +
 +	for (vcpu_id = 0; vcpu_id < vcpus; vcpu_id++) {
 +		vcpu_args = &perf_test_args.vcpu_args[vcpu_id];
 +
 +		vm_vcpu_add_default(vm, vcpu_id, guest_code);
 +
 +		vcpu_args->vcpu_id = vcpu_id;
 +		vcpu_args->gva = guest_test_virt_mem +
 +				 (vcpu_id * vcpu_memory_bytes);
 +		vcpu_args->pages = vcpu_memory_bytes /
 +				   perf_test_args.guest_page_size;
  
 +		vcpu_gpa = guest_test_phys_mem + (vcpu_id * vcpu_memory_bytes);
 +		pr_debug("Added VCPU %d with test mem gpa [%lx, %lx)\n",
 +			 vcpu_id, vcpu_gpa, vcpu_gpa + vcpu_memory_bytes);
 +	}
 +}
++=======
+ struct kvm_vm *perf_test_create_vm(enum vm_guest_mode mode, int vcpus,
+ 				   uint64_t vcpu_memory_bytes,
+ 				   enum vm_mem_backing_src_type backing_src);
+ void perf_test_destroy_vm(struct kvm_vm *vm);
+ void perf_test_setup_vcpus(struct kvm_vm *vm, int vcpus,
+ 			   uint64_t vcpu_memory_bytes,
+ 			   bool partition_vcpu_memory_access);
++>>>>>>> 9e965bb75aae (KVM: selftests: Add backing src parameter to dirty_log_perf_test)
  
  #endif /* SELFTEST_KVM_PERF_TEST_UTIL_H */
* Unmerged path tools/testing/selftests/kvm/dirty_log_perf_test.c
* Unmerged path tools/testing/selftests/kvm/lib/perf_test_util.c
* Unmerged path tools/testing/selftests/kvm/memslot_modification_stress_test.c
* Unmerged path tools/testing/selftests/kvm/demand_paging_test.c
* Unmerged path tools/testing/selftests/kvm/dirty_log_perf_test.c
* Unmerged path tools/testing/selftests/kvm/include/kvm_util.h
* Unmerged path tools/testing/selftests/kvm/include/perf_test_util.h
diff --git a/tools/testing/selftests/kvm/include/test_util.h b/tools/testing/selftests/kvm/include/test_util.h
index 1cc036ddb0c5..35ae40c9cf4a 100644
--- a/tools/testing/selftests/kvm/include/test_util.h
+++ b/tools/testing/selftests/kvm/include/test_util.h
@@ -66,4 +66,18 @@ struct timespec timespec_add(struct timespec ts1, struct timespec ts2);
 struct timespec timespec_sub(struct timespec ts1, struct timespec ts2);
 struct timespec timespec_diff_now(struct timespec start);
 
+enum vm_mem_backing_src_type {
+	VM_MEM_SRC_ANONYMOUS,
+	VM_MEM_SRC_ANONYMOUS_THP,
+	VM_MEM_SRC_ANONYMOUS_HUGETLB,
+};
+
+struct vm_mem_backing_src_alias {
+	const char *name;
+	enum vm_mem_backing_src_type type;
+};
+
+void backing_src_help(void);
+enum vm_mem_backing_src_type parse_backing_src_type(const char *type_name);
+
 #endif /* SELFTEST_KVM_TEST_UTIL_H */
* Unmerged path tools/testing/selftests/kvm/lib/perf_test_util.c
diff --git a/tools/testing/selftests/kvm/lib/test_util.c b/tools/testing/selftests/kvm/lib/test_util.c
index 1a46c2c48c7c..6ec90d5b78d7 100644
--- a/tools/testing/selftests/kvm/lib/test_util.c
+++ b/tools/testing/selftests/kvm/lib/test_util.c
@@ -10,6 +10,7 @@
 #include <limits.h>
 #include <stdlib.h>
 #include <time.h>
+#include "linux/kernel.h"
 
 #include "test_util.h"
 
@@ -102,3 +103,31 @@ void print_skip(const char *fmt, ...)
 	va_end(ap);
 	puts(", skipping test");
 }
+
+const struct vm_mem_backing_src_alias backing_src_aliases[] = {
+	{"anonymous", VM_MEM_SRC_ANONYMOUS,},
+	{"anonymous_thp", VM_MEM_SRC_ANONYMOUS_THP,},
+	{"anonymous_hugetlb", VM_MEM_SRC_ANONYMOUS_HUGETLB,},
+};
+
+void backing_src_help(void)
+{
+	int i;
+
+	printf("Available backing src types:\n");
+	for (i = 0; i < ARRAY_SIZE(backing_src_aliases); i++)
+		printf("\t%s\n", backing_src_aliases[i].name);
+}
+
+enum vm_mem_backing_src_type parse_backing_src_type(const char *type_name)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(backing_src_aliases); i++)
+		if (!strcmp(type_name, backing_src_aliases[i].name))
+			return backing_src_aliases[i].type;
+
+	backing_src_help();
+	TEST_FAIL("Unknown backing src type: %s", type_name);
+	return -1;
+}
* Unmerged path tools/testing/selftests/kvm/memslot_modification_stress_test.c
