powerpc/mce: Remove per cpu variables from MCE handlers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Ganesh Goudar <ganeshgr@linux.ibm.com>
commit 923b3cf00b3ffc896543bac99affc0fa8553e41a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/923b3cf0.failed

Access to per-cpu variables requires translation to be enabled on
pseries machine running in hash mmu mode, Since part of MCE handler
runs in realmode and part of MCE handling code is shared between ppc
architectures pseries and powernv, it becomes difficult to manage
these variables differently on different architectures, So have
these variables in paca instead of having them as per-cpu variables
to avoid complications.

	Signed-off-by: Ganesh Goudar <ganeshgr@linux.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20210128104143.70668-2-ganeshgr@linux.ibm.com
(cherry picked from commit 923b3cf00b3ffc896543bac99affc0fa8553e41a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/paca.h
#	arch/powerpc/kernel/mce.c
#	arch/powerpc/kernel/setup-common.c
diff --cc arch/powerpc/include/asm/paca.h
index fc86b962d444,38e0c55e845d..000000000000
--- a/arch/powerpc/include/asm/paca.h
+++ b/arch/powerpc/include/asm/paca.h
@@@ -267,10 -271,12 +268,16 @@@ struct paca_struct 
  #ifdef CONFIG_MMIOWB
  	struct mmiowb_state mmiowb_state;
  #endif
++<<<<<<< HEAD
 +
 +#ifdef CONFIG_STACKPROTECTOR
 +	RH_KABI_EXTEND(unsigned long canary)
 +#endif
++=======
+ #ifdef CONFIG_PPC_BOOK3S_64
+ 	struct mce_info *mce_info;
+ #endif /* CONFIG_PPC_BOOK3S_64 */
++>>>>>>> 923b3cf00b3f (powerpc/mce: Remove per cpu variables from MCE handlers)
  } ____cacheline_aligned;
  
  extern void copy_mm_to_paca(struct mm_struct *mm);
diff --cc arch/powerpc/kernel/mce.c
index 03f15fd9bbae,3e3a84127c0e..000000000000
--- a/arch/powerpc/kernel/mce.c
+++ b/arch/powerpc/kernel/mce.c
@@@ -29,22 -16,15 +29,17 @@@
  #include <linux/export.h>
  #include <linux/irq_work.h>
  #include <linux/extable.h>
++<<<<<<< HEAD
++=======
+ #include <linux/ftrace.h>
+ #include <linux/memblock.h>
++>>>>>>> 923b3cf00b3f (powerpc/mce: Remove per cpu variables from MCE handlers)
  
  #include <asm/machdep.h>
  #include <asm/mce.h>
 -#include <asm/nmi.h>
 -#include <asm/asm-prototypes.h>
 +#include <asm/extable.h>
  
- static DEFINE_PER_CPU(int, mce_nest_count);
- static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);
- 
- /* Queue for delayed MCE events. */
- static DEFINE_PER_CPU(int, mce_queue_count);
- static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);
- 
- /* Queue for delayed MCE UE events. */
- static DEFINE_PER_CPU(int, mce_ue_count);
- static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],
- 					mce_ue_event_queue);
+ #include "setup.h"
  
  static void machine_check_process_queued_event(struct irq_work *work);
  static void machine_check_ue_irq_work(struct irq_work *work);
@@@ -287,9 -284,10 +285,16 @@@ static void machine_process_ue_event(st
  	int index;
  	struct machine_check_event *evt;
  
++<<<<<<< HEAD
 +	while (__this_cpu_read(mce_ue_count) > 0) {
 +		index = __this_cpu_read(mce_ue_count) - 1;
 +		evt = this_cpu_ptr(&mce_ue_event_queue[index]);
++=======
+ 	while (local_paca->mce_info->mce_ue_count > 0) {
+ 		index = local_paca->mce_info->mce_ue_count - 1;
+ 		evt = &local_paca->mce_info->mce_ue_event_queue[index];
+ 		blocking_notifier_call_chain(&mce_notifier_list, 0, evt);
++>>>>>>> 923b3cf00b3f (powerpc/mce: Remove per cpu variables from MCE handlers)
  #ifdef CONFIG_MEMORY_FAILURE
  		/*
  		 * This should probably queued elsewhere, but
@@@ -341,12 -339,11 +346,12 @@@ static void machine_check_process_queue
  
  		if (evt->error_type == MCE_ERROR_TYPE_UE &&
  		    evt->u.ue_error.ignore_event) {
- 			__this_cpu_dec(mce_queue_count);
+ 			local_paca->mce_info->mce_queue_count--;
  			continue;
  		}
 +
  		machine_check_print_event_info(evt, false, false);
- 		__this_cpu_dec(mce_queue_count);
+ 		local_paca->mce_info->mce_queue_count--;
  	}
  }
  
diff --cc arch/powerpc/kernel/setup-common.c
index 662a15c3be01,d480f091e0ad..000000000000
--- a/arch/powerpc/kernel/setup-common.c
+++ b/arch/powerpc/kernel/setup-common.c
@@@ -67,6 -63,8 +67,11 @@@
  #include <asm/livepatch.h>
  #include <asm/mmu_context.h>
  #include <asm/cpu_has_feature.h>
++<<<<<<< HEAD
++=======
+ #include <asm/kasan.h>
+ #include <asm/mce.h>
++>>>>>>> 923b3cf00b3f (powerpc/mce: Remove per cpu variables from MCE handlers)
  
  #include "setup.h"
  
diff --git a/arch/powerpc/include/asm/mce.h b/arch/powerpc/include/asm/mce.h
index 37b5c4a91870..d123f32a5e05 100644
--- a/arch/powerpc/include/asm/mce.h
+++ b/arch/powerpc/include/asm/mce.h
@@ -219,6 +219,17 @@ struct mce_error_info {
 
 #define MAX_MC_EVT	10
 
+struct mce_info {
+	int mce_nest_count;
+	struct machine_check_event mce_event[MAX_MC_EVT];
+	/* Queue for delayed MCE events. */
+	int mce_queue_count;
+	struct machine_check_event mce_event_queue[MAX_MC_EVT];
+	/* Queue for delayed MCE UE events. */
+	int mce_ue_count;
+	struct machine_check_event  mce_ue_event_queue[MAX_MC_EVT];
+};
+
 /* Release flags for get_mce_event() */
 #define MCE_EVENT_RELEASE	true
 #define MCE_EVENT_DONTRELEASE	false
@@ -244,4 +255,11 @@ long __machine_check_early_realmode_p8(struct pt_regs *regs);
 long __machine_check_early_realmode_p9(struct pt_regs *regs);
 long __machine_check_early_realmode_p10(struct pt_regs *regs);
 #endif /* CONFIG_PPC_BOOK3S_64 */
+
+#ifdef CONFIG_PPC_BOOK3S_64
+void mce_init(void);
+#else
+static inline void mce_init(void) { };
+#endif /* CONFIG_PPC_BOOK3S_64 */
+
 #endif /* __ASM_PPC64_MCE_H__ */
* Unmerged path arch/powerpc/include/asm/paca.h
* Unmerged path arch/powerpc/kernel/mce.c
* Unmerged path arch/powerpc/kernel/setup-common.c
