sysfs: add sysfs_group{s}_change_owner()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Christian Brauner <christian.brauner@ubuntu.com>
commit 303a42769c4c4d8e5e3ad928df87eb36f8c1fa60
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/303a4276.failed

Add helpers to change the owner of sysfs groups.
This function will be used to correctly account for kobject ownership
changes, e.g. when moving network devices between network namespaces.

	Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 303a42769c4c4d8e5e3ad928df87eb36f8c1fa60)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/sysfs/group.c
diff --cc fs/sysfs/group.c
index 704f35068912,5afe0e7ff7cd..000000000000
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@@ -467,4 -457,118 +468,122 @@@ int compat_only_sysfs_link_entry_to_kob
  	kernfs_put(target);
  	return PTR_ERR_OR_ZERO(link);
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL_GPL(compat_only_sysfs_link_entry_to_kobj);
++=======
+ EXPORT_SYMBOL_GPL(__compat_only_sysfs_link_entry_to_kobj);
+ 
+ static int sysfs_group_attrs_change_owner(struct kernfs_node *grp_kn,
+ 					  const struct attribute_group *grp,
+ 					  struct iattr *newattrs)
+ {
+ 	struct kernfs_node *kn;
+ 	int error;
+ 
+ 	if (grp->attrs) {
+ 		struct attribute *const *attr;
+ 
+ 		for (attr = grp->attrs; *attr; attr++) {
+ 			kn = kernfs_find_and_get(grp_kn, (*attr)->name);
+ 			if (!kn)
+ 				return -ENOENT;
+ 
+ 			error = kernfs_setattr(kn, newattrs);
+ 			kernfs_put(kn);
+ 			if (error)
+ 				return error;
+ 		}
+ 	}
+ 
+ 	if (grp->bin_attrs) {
+ 		struct bin_attribute *const *bin_attr;
+ 
+ 		for (bin_attr = grp->bin_attrs; *bin_attr; bin_attr++) {
+ 			kn = kernfs_find_and_get(grp_kn, (*bin_attr)->attr.name);
+ 			if (!kn)
+ 				return -ENOENT;
+ 
+ 			error = kernfs_setattr(kn, newattrs);
+ 			kernfs_put(kn);
+ 			if (error)
+ 				return error;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * sysfs_group_change_owner - change owner of an attribute group.
+  * @kobj:	The kobject containing the group.
+  * @grp:	The attribute group.
+  * @kuid:	new owner's kuid
+  * @kgid:	new owner's kgid
+  *
+  * Returns 0 on success or error code on failure.
+  */
+ int sysfs_group_change_owner(struct kobject *kobj,
+ 			     const struct attribute_group *grp, kuid_t kuid,
+ 			     kgid_t kgid)
+ {
+ 	struct kernfs_node *grp_kn;
+ 	int error;
+ 	struct iattr newattrs = {
+ 		.ia_valid = ATTR_UID | ATTR_GID,
+ 		.ia_uid = kuid,
+ 		.ia_gid = kgid,
+ 	};
+ 
+ 	if (!kobj->state_in_sysfs)
+ 		return -EINVAL;
+ 
+ 	if (grp->name) {
+ 		grp_kn = kernfs_find_and_get(kobj->sd, grp->name);
+ 	} else {
+ 		kernfs_get(kobj->sd);
+ 		grp_kn = kobj->sd;
+ 	}
+ 	if (!grp_kn)
+ 		return -ENOENT;
+ 
+ 	error = kernfs_setattr(grp_kn, &newattrs);
+ 	if (!error)
+ 		error = sysfs_group_attrs_change_owner(grp_kn, grp, &newattrs);
+ 
+ 	kernfs_put(grp_kn);
+ 
+ 	return error;
+ }
+ EXPORT_SYMBOL_GPL(sysfs_group_change_owner);
+ 
+ /**
+  * sysfs_groups_change_owner - change owner of a set of attribute groups.
+  * @kobj:	The kobject containing the groups.
+  * @groups:	The attribute groups.
+  * @kuid:	new owner's kuid
+  * @kgid:	new owner's kgid
+  *
+  * Returns 0 on success or error code on failure.
+  */
+ int sysfs_groups_change_owner(struct kobject *kobj,
+ 			      const struct attribute_group **groups,
+ 			      kuid_t kuid, kgid_t kgid)
+ {
+ 	int error = 0, i;
+ 
+ 	if (!kobj->state_in_sysfs)
+ 		return -EINVAL;
+ 
+ 	if (!groups)
+ 		return 0;
+ 
+ 	for (i = 0; groups[i]; i++) {
+ 		error = sysfs_group_change_owner(kobj, groups[i], kuid, kgid);
+ 		if (error)
+ 			break;
+ 	}
+ 
+ 	return error;
+ }
+ EXPORT_SYMBOL_GPL(sysfs_groups_change_owner);
++>>>>>>> 303a42769c4c (sysfs: add sysfs_group{s}_change_owner())
* Unmerged path fs/sysfs/group.c
diff --git a/include/linux/sysfs.h b/include/linux/sysfs.h
index 4cf71d5eb0b3..517b1d1d069d 100644
--- a/include/linux/sysfs.h
+++ b/include/linux/sysfs.h
@@ -325,6 +325,12 @@ int sysfs_file_change_owner(struct kobject *kobj, const char *name, kuid_t kuid,
 			    kgid_t kgid);
 int sysfs_link_change_owner(struct kobject *kobj, struct kobject *targ,
 			    const char *name, kuid_t kuid, kgid_t kgid);
+int sysfs_groups_change_owner(struct kobject *kobj,
+			      const struct attribute_group **groups,
+			      kuid_t kuid, kgid_t kgid);
+int sysfs_group_change_owner(struct kobject *kobj,
+			     const struct attribute_group *groups, kuid_t kuid,
+			     kgid_t kgid);
 
 #else /* CONFIG_SYSFS */
 
@@ -561,6 +567,20 @@ static inline int sysfs_link_change_owner(struct kobject *kobj,
 	return 0;
 }
 
+static inline int sysfs_groups_change_owner(struct kobject *kobj,
+			  const struct attribute_group **groups,
+			  kuid_t kuid, kgid_t kgid)
+{
+	return 0;
+}
+
+static inline int sysfs_group_change_owner(struct kobject *kobj,
+			 const struct attribute_group **groups,
+			 kuid_t kuid, kgid_t kgid)
+{
+	return 0;
+}
+
 #endif /* CONFIG_SYSFS */
 
 static inline int __must_check sysfs_create_file(struct kobject *kobj,
