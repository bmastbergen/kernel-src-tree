mm: move lruvec stats update functions to vmstat.h

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Shakeel Butt <shakeelb@google.com>
commit c47d5032ed3002311a4188eae51f4641ec436beb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/c47d5032.failed

Patch series "memcg: add pagetable comsumption to memory.stat", v2.

Many workloads consumes significant amount of memory in pagetables.  One
specific use-case is the user space network driver which mmaps the
application memory to provide zero copy transfer.  This driver can consume
a large amount memory in page tables.  This patch series exposes the
pagetable comsumption for each memory cgroup.

This patch (of 2):

This does not change any functionality and only move the functions which
update the lruvec stats to vmstat.h from memcontrol.h.  The main reason
for this patch is to be able to use these functions in the page table
contructor function which is defined in mm.h and we can not include the
memcontrol.h in that file.  Also this is a better place for this interface
in general.  The lruvec abstraction, while invented for memcg, isn't
specific to memcg at all.

Link: https://lkml.kernel.org/r/20201130212541.2781790-2-shakeelb@google.com
	Signed-off-by: Shakeel Butt <shakeelb@google.com>
	Acked-by: Johannes Weiner <hannes@cmpxchg.org>
	Acked-by: Roman Gushchin <guro@fb.com>
	Cc: Michal Hocko <mhocko@suse.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit c47d5032ed3002311a4188eae51f4641ec436beb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/memcontrol.h
#	mm/memcontrol.c
diff --cc include/linux/memcontrol.h
index da9b4f3ccbfd,f530d634f055..000000000000
--- a/include/linux/memcontrol.h
+++ b/include/linux/memcontrol.h
@@@ -830,50 -786,20 +830,27 @@@ static inline unsigned long lruvec_page
  
  void __mod_memcg_lruvec_state(struct lruvec *lruvec, enum node_stat_item idx,
  			      int val);
++<<<<<<< HEAD
 +void __mod_lruvec_state(struct lruvec *lruvec, enum node_stat_item idx,
 +			int val);
 +void __mod_lruvec_slab_state(void *p, enum node_stat_item idx, int val);
 +void mod_memcg_obj_state(void *p, int idx, int val);
++=======
+ void __mod_lruvec_kmem_state(void *p, enum node_stat_item idx, int val);
  
- static inline void mod_memcg_lruvec_state(struct lruvec *lruvec,
- 					  enum node_stat_item idx, int val)
- {
- 	unsigned long flags;
- 
- 	local_irq_save(flags);
- 	__mod_memcg_lruvec_state(lruvec, idx, val);
- 	local_irq_restore(flags);
- }
- 
- static inline void mod_lruvec_state(struct lruvec *lruvec,
- 				    enum node_stat_item idx, int val)
+ static inline void mod_lruvec_kmem_state(void *p, enum node_stat_item idx,
+ 					 int val)
  {
  	unsigned long flags;
  
  	local_irq_save(flags);
- 	__mod_lruvec_state(lruvec, idx, val);
+ 	__mod_lruvec_kmem_state(p, idx, val);
  	local_irq_restore(flags);
  }
++>>>>>>> c47d5032ed30 (mm: move lruvec stats update functions to vmstat.h)
  
- static inline void __mod_lruvec_page_state(struct page *page,
- 					   enum node_stat_item idx, int val)
- {
- 	struct page *head = compound_head(page); /* rmap on tail pages */
- 	pg_data_t *pgdat = page_pgdat(page);
- 	struct lruvec *lruvec;
- 
- 	/* Untracked pages have no memcg, no lruvec. Update only the node */
- 	if (!head->mem_cgroup) {
- 		__mod_node_page_state(pgdat, idx, val);
- 		return;
- 	}
- 
- 	lruvec = mem_cgroup_lruvec(head->mem_cgroup, pgdat);
- 	__mod_lruvec_state(lruvec, idx, val);
- }
- 
- static inline void mod_lruvec_page_state(struct page *page,
- 					 enum node_stat_item idx, int val)
+ static inline void mod_memcg_lruvec_state(struct lruvec *lruvec,
+ 					  enum node_stat_item idx, int val)
  {
  	unsigned long flags;
  
@@@ -1231,31 -1166,7 +1208,35 @@@ static inline void __mod_memcg_lruvec_s
  {
  }
  
++<<<<<<< HEAD
 +static inline void __mod_lruvec_state(struct lruvec *lruvec,
 +				      enum node_stat_item idx, int val)
 +{
 +	__mod_node_page_state(lruvec_pgdat(lruvec), idx, val);
 +}
 +
 +static inline void mod_lruvec_state(struct lruvec *lruvec,
 +				    enum node_stat_item idx, int val)
 +{
 +	mod_node_page_state(lruvec_pgdat(lruvec), idx, val);
 +}
 +
 +static inline void __mod_lruvec_page_state(struct page *page,
 +					   enum node_stat_item idx, int val)
 +{
 +	__mod_node_page_state(page_pgdat(page), idx, val);
 +}
 +
 +static inline void mod_lruvec_page_state(struct page *page,
 +					 enum node_stat_item idx, int val)
 +{
 +	mod_node_page_state(page_pgdat(page), idx, val);
 +}
 +
 +static inline void __mod_lruvec_slab_state(void *p, enum node_stat_item idx,
++=======
+ static inline void __mod_lruvec_kmem_state(void *p, enum node_stat_item idx,
++>>>>>>> c47d5032ed30 (mm: move lruvec stats update functions to vmstat.h)
  					   int val)
  {
  	struct page *page = virt_to_head_page(p);
@@@ -1330,38 -1245,14 +1311,42 @@@ static inline void __dec_memcg_page_sta
  	__mod_memcg_page_state(page, idx, -1);
  }
  
++<<<<<<< HEAD
 +static inline void __inc_lruvec_state(struct lruvec *lruvec,
 +				      enum node_stat_item idx)
 +{
 +	__mod_lruvec_state(lruvec, idx, 1);
 +}
 +
 +static inline void __dec_lruvec_state(struct lruvec *lruvec,
 +				      enum node_stat_item idx)
 +{
 +	__mod_lruvec_state(lruvec, idx, -1);
 +}
 +
 +static inline void __inc_lruvec_page_state(struct page *page,
 +					   enum node_stat_item idx)
 +{
 +	__mod_lruvec_page_state(page, idx, 1);
 +}
 +
 +static inline void __dec_lruvec_page_state(struct page *page,
 +					   enum node_stat_item idx)
 +{
 +	__mod_lruvec_page_state(page, idx, -1);
 +}
 +
 +static inline void __inc_lruvec_slab_state(void *p, enum node_stat_item idx)
++=======
+ static inline void __inc_lruvec_kmem_state(void *p, enum node_stat_item idx)
++>>>>>>> c47d5032ed30 (mm: move lruvec stats update functions to vmstat.h)
  {
 -	__mod_lruvec_kmem_state(p, idx, 1);
 +	__mod_lruvec_slab_state(p, idx, 1);
  }
  
 -static inline void __dec_lruvec_kmem_state(void *p, enum node_stat_item idx)
 +static inline void __dec_lruvec_slab_state(void *p, enum node_stat_item idx)
  {
 -	__mod_lruvec_kmem_state(p, idx, -1);
 +	__mod_lruvec_slab_state(p, idx, -1);
  }
  
  /* idx can be of type enum memcg_stat_item or node_stat_item */
diff --cc mm/memcontrol.c
index 867d18f31616,52837d68bbec..000000000000
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@@ -867,7 -853,24 +867,28 @@@ void __mod_lruvec_state(struct lruvec *
  		__mod_memcg_lruvec_state(lruvec, idx, val);
  }
  
++<<<<<<< HEAD
 +void __mod_lruvec_slab_state(void *p, enum node_stat_item idx, int val)
++=======
+ void __mod_lruvec_page_state(struct page *page, enum node_stat_item idx,
+ 			     int val)
+ {
+ 	struct page *head = compound_head(page); /* rmap on tail pages */
+ 	pg_data_t *pgdat = page_pgdat(page);
+ 	struct lruvec *lruvec;
+ 
+ 	/* Untracked pages have no memcg, no lruvec. Update only the node */
+ 	if (!head->mem_cgroup) {
+ 		__mod_node_page_state(pgdat, idx, val);
+ 		return;
+ 	}
+ 
+ 	lruvec = mem_cgroup_lruvec(head->mem_cgroup, pgdat);
+ 	__mod_lruvec_state(lruvec, idx, val);
+ }
+ 
+ void __mod_lruvec_kmem_state(void *p, enum node_stat_item idx, int val)
++>>>>>>> c47d5032ed30 (mm: move lruvec stats update functions to vmstat.h)
  {
  	pg_data_t *pgdat = page_pgdat(virt_to_page(p));
  	struct mem_cgroup *memcg;
* Unmerged path include/linux/memcontrol.h
diff --git a/include/linux/vmstat.h b/include/linux/vmstat.h
index 2f7cb92a9add..5fe0dc096126 100644
--- a/include/linux/vmstat.h
+++ b/include/linux/vmstat.h
@@ -450,4 +450,108 @@ static inline const char *vm_event_name(enum vm_event_item item)
 }
 #endif /* CONFIG_VM_EVENT_COUNTERS || CONFIG_MEMCG */
 
+#ifdef CONFIG_MEMCG
+
+void __mod_lruvec_state(struct lruvec *lruvec, enum node_stat_item idx,
+			int val);
+
+static inline void mod_lruvec_state(struct lruvec *lruvec,
+				    enum node_stat_item idx, int val)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	__mod_lruvec_state(lruvec, idx, val);
+	local_irq_restore(flags);
+}
+
+void __mod_lruvec_page_state(struct page *page,
+			     enum node_stat_item idx, int val);
+
+static inline void mod_lruvec_page_state(struct page *page,
+					 enum node_stat_item idx, int val)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	__mod_lruvec_page_state(page, idx, val);
+	local_irq_restore(flags);
+}
+
+#else
+
+static inline void __mod_lruvec_state(struct lruvec *lruvec,
+				      enum node_stat_item idx, int val)
+{
+	__mod_node_page_state(lruvec_pgdat(lruvec), idx, val);
+}
+
+static inline void mod_lruvec_state(struct lruvec *lruvec,
+				    enum node_stat_item idx, int val)
+{
+	mod_node_page_state(lruvec_pgdat(lruvec), idx, val);
+}
+
+static inline void __mod_lruvec_page_state(struct page *page,
+					   enum node_stat_item idx, int val)
+{
+	__mod_node_page_state(page_pgdat(page), idx, val);
+}
+
+static inline void mod_lruvec_page_state(struct page *page,
+					 enum node_stat_item idx, int val)
+{
+	mod_node_page_state(page_pgdat(page), idx, val);
+}
+
+#endif /* CONFIG_MEMCG */
+
+static inline void __inc_lruvec_state(struct lruvec *lruvec,
+				      enum node_stat_item idx)
+{
+	__mod_lruvec_state(lruvec, idx, 1);
+}
+
+static inline void __dec_lruvec_state(struct lruvec *lruvec,
+				      enum node_stat_item idx)
+{
+	__mod_lruvec_state(lruvec, idx, -1);
+}
+
+static inline void __inc_lruvec_page_state(struct page *page,
+					   enum node_stat_item idx)
+{
+	__mod_lruvec_page_state(page, idx, 1);
+}
+
+static inline void __dec_lruvec_page_state(struct page *page,
+					   enum node_stat_item idx)
+{
+	__mod_lruvec_page_state(page, idx, -1);
+}
+
+static inline void inc_lruvec_state(struct lruvec *lruvec,
+				    enum node_stat_item idx)
+{
+	mod_lruvec_state(lruvec, idx, 1);
+}
+
+static inline void dec_lruvec_state(struct lruvec *lruvec,
+				    enum node_stat_item idx)
+{
+	mod_lruvec_state(lruvec, idx, -1);
+}
+
+static inline void inc_lruvec_page_state(struct page *page,
+					 enum node_stat_item idx)
+{
+	mod_lruvec_page_state(page, idx, 1);
+}
+
+static inline void dec_lruvec_page_state(struct page *page,
+					 enum node_stat_item idx)
+{
+	mod_lruvec_page_state(page, idx, -1);
+}
+
 #endif /* _LINUX_VMSTAT_H */
* Unmerged path mm/memcontrol.c
