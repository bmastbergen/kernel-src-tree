static_call: Add static_call_cond()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Peter Zijlstra <peterz@infradead.org>
commit 452cddbff74b6a15b9354505671011700fe03710
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/452cddbf.failed

Extend the static_call infrastructure to optimize the following common
pattern:

	if (func_ptr)
		func_ptr(args...)

For the trampoline (which is in effect a tail-call), we patch the
JMP.d32 into a RET, which then directly consumes the trampoline call.

For the in-line sites we replace the CALL with a NOP5.

NOTE: this is 'obviously' limited to functions with a 'void' return type.

NOTE: DEFINE_STATIC_COND_CALL() only requires a typename, as opposed
      to a full function.

	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
Link: https://lore.kernel.org/r/20200818135805.042977182@infradead.org
(cherry picked from commit 452cddbff74b6a15b9354505671011700fe03710)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/static_call.h
#	arch/x86/kernel/static_call.c
#	include/linux/static_call.h
diff --cc include/linux/static_call.h
index d8892dff2e91,0f74581e0e2f..000000000000
--- a/include/linux/static_call.h
+++ b/include/linux/static_call.h
@@@ -95,7 -134,13 +134,16 @@@ extern void arch_static_call_transform(
  			     STATIC_CALL_TRAMP_ADDR(name), func);	\
  })
  
++<<<<<<< HEAD
 +#if defined(CONFIG_HAVE_STATIC_CALL)
++=======
+ #ifdef CONFIG_HAVE_STATIC_CALL_INLINE
+ 
+ struct static_call_mod {
+ 	struct static_call_mod *next;
+ 	struct module *mod; /* for vmlinux, mod == NULL */
+ 	struct static_call_site *sites;
+ };
  
  struct static_call_key {
  	void *func;
@@@ -108,7 -159,47 +162,48 @@@ extern int static_call_text_reserved(vo
  	};								\
  	ARCH_DEFINE_STATIC_CALL_TRAMP(name, _func)
  
+ #define DEFINE_STATIC_CALL_NULL(name, _func)				\
+ 	DECLARE_STATIC_CALL(name, _func);				\
+ 	struct static_call_key STATIC_CALL_KEY(name) = {		\
+ 		.func = NULL,						\
+ 		.type = 1,						\
+ 	};								\
+ 	ARCH_DEFINE_STATIC_CALL_NULL_TRAMP(name)
+ 
  #define static_call(name)	__static_call(name)
+ #define static_call_cond(name)	(void)__static_call(name)
+ 
+ #define EXPORT_STATIC_CALL(name)					\
+ 	EXPORT_SYMBOL(STATIC_CALL_KEY(name));				\
+ 	EXPORT_SYMBOL(STATIC_CALL_TRAMP(name))
+ 
+ #define EXPORT_STATIC_CALL_GPL(name)					\
+ 	EXPORT_SYMBOL_GPL(STATIC_CALL_KEY(name));			\
+ 	EXPORT_SYMBOL_GPL(STATIC_CALL_TRAMP(name))
+ 
+ #elif defined(CONFIG_HAVE_STATIC_CALL)
++>>>>>>> 452cddbff74b (static_call: Add static_call_cond())
+ 
+ struct static_call_key {
+ 	void *func;
+ };
+ 
+ #define DEFINE_STATIC_CALL(name, _func)					\
+ 	DECLARE_STATIC_CALL(name, _func);				\
+ 	struct static_call_key STATIC_CALL_KEY(name) = {		\
+ 		.func = _func,						\
+ 	};								\
+ 	ARCH_DEFINE_STATIC_CALL_TRAMP(name, _func)
+ 
+ #define DEFINE_STATIC_CALL_NULL(name, _func)				\
+ 	DECLARE_STATIC_CALL(name, _func);				\
+ 	struct static_call_key STATIC_CALL_KEY(name) = {		\
+ 		.func = NULL,						\
+ 	};								\
+ 	ARCH_DEFINE_STATIC_CALL_NULL_TRAMP(name)
+ 
+ #define static_call(name)	__static_call(name)
+ #define static_call_cond(name)	(void)__static_call(name)
  
  static inline
  void __static_call_update(struct static_call_key *key, void *tramp, void *func)
* Unmerged path arch/x86/include/asm/static_call.h
* Unmerged path arch/x86/kernel/static_call.c
* Unmerged path arch/x86/include/asm/static_call.h
* Unmerged path arch/x86/kernel/static_call.c
* Unmerged path include/linux/static_call.h
