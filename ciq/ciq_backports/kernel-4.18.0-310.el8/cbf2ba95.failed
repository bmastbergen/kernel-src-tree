powerpc/64s: system reset interrupt preserve HSRRs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Nicholas Piggin <npiggin@gmail.com>
commit cbf2ba952a70399c972f2a2126a4ac6f79437f37
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/cbf2ba95.failed

Code that uses HSRR registers is not required to clear MSR[RI] by
convention, however the system reset NMI itself may use HSRR
registers (e.g., to call OPAL) and clobber them.

Rather than introduce the requirement to clear RI in order to use
HSRRs, have system reset interrupt save and restore HSRRs.

	Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit cbf2ba952a70399c972f2a2126a4ac6f79437f37)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/traps.c
diff --cc arch/powerpc/kernel/traps.c
index 7b3619c07d86,a5757bef03cd..000000000000
--- a/arch/powerpc/kernel/traps.c
+++ b/arch/powerpc/kernel/traps.c
@@@ -353,8 -369,76 +353,12 @@@ void _exception(int signr, struct pt_re
  	force_sig_fault(signr, code, (void __user *)addr, current);
  }
  
 -/*
 - * The interrupt architecture has a quirk in that the HV interrupts excluding
 - * the NMIs (0x100 and 0x200) do not clear MSR[RI] at entry. The first thing
 - * that an interrupt handler must do is save off a GPR into a scratch register,
 - * and all interrupts on POWERNV (HV=1) use the HSPRG1 register as scratch.
 - * Therefore an NMI can clobber an HV interrupt's live HSPRG1 without noticing
 - * that it is non-reentrant, which leads to random data corruption.
 - *
 - * The solution is for NMI interrupts in HV mode to check if they originated
 - * from these critical HV interrupt regions. If so, then mark them not
 - * recoverable.
 - *
 - * An alternative would be for HV NMIs to use SPRG for scratch to avoid the
 - * HSPRG1 clobber, however this would cause guest SPRG to be clobbered. Linux
 - * guests should always have MSR[RI]=0 when its scratch SPRG is in use, so
 - * that would work. However any other guest OS that may have the SPRG live
 - * and MSR[RI]=1 could encounter silent corruption.
 - *
 - * Builds that do not support KVM could take this second option to increase
 - * the recoverability of NMIs.
 - */
 -void hv_nmi_check_nonrecoverable(struct pt_regs *regs)
 -{
 -#ifdef CONFIG_PPC_POWERNV
 -	unsigned long kbase = (unsigned long)_stext;
 -	unsigned long nip = regs->nip;
 -
 -	if (!(regs->msr & MSR_RI))
 -		return;
 -	if (!(regs->msr & MSR_HV))
 -		return;
 -	if (regs->msr & MSR_PR)
 -		return;
 -
 -	/*
 -	 * Now test if the interrupt has hit a range that may be using
 -	 * HSPRG1 without having RI=0 (i.e., an HSRR interrupt). The
 -	 * problem ranges all run un-relocated. Test real and virt modes
 -	 * at the same time by droping the high bit of the nip (virt mode
 -	 * entry points still have the +0x4000 offset).
 -	 */
 -	nip &= ~0xc000000000000000ULL;
 -	if ((nip >= 0x500 && nip < 0x600) || (nip >= 0x4500 && nip < 0x4600))
 -		goto nonrecoverable;
 -	if ((nip >= 0x980 && nip < 0xa00) || (nip >= 0x4980 && nip < 0x4a00))
 -		goto nonrecoverable;
 -	if ((nip >= 0xe00 && nip < 0xec0) || (nip >= 0x4e00 && nip < 0x4ec0))
 -		goto nonrecoverable;
 -	if ((nip >= 0xf80 && nip < 0xfa0) || (nip >= 0x4f80 && nip < 0x4fa0))
 -		goto nonrecoverable;
 -	/* Trampoline code runs un-relocated so subtract kbase. */
 -	if (nip >= real_trampolines_start - kbase &&
 -			nip < real_trampolines_end - kbase)
 -		goto nonrecoverable;
 -	if (nip >= virt_trampolines_start - kbase &&
 -			nip < virt_trampolines_end - kbase)
 -		goto nonrecoverable;
 -	return;
 -
 -nonrecoverable:
 -	regs->msr &= ~MSR_RI;
 -#endif
 -}
 -
  void system_reset_exception(struct pt_regs *regs)
  {
+ 	unsigned long hsrr0, hsrr1;
+ 	bool nested = in_nmi();
+ 	bool saved_hsrrs = false;
+ 
  	/*
  	 * Avoid crashes in case of nested NMI exceptions. Recoverability
  	 * is determined by RI and in_nmi
@@@ -362,7 -446,23 +366,26 @@@
  	if (!nested)
  		nmi_enter();
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * System reset can interrupt code where HSRRs are live and MSR[RI]=1.
+ 	 * The system reset interrupt itself may clobber HSRRs (e.g., to call
+ 	 * OPAL), so save them here and restore them before returning.
+ 	 *
+ 	 * Machine checks don't need to save HSRRs, as the real mode handler
+ 	 * is careful to avoid them, and the regular handler is not delivered
+ 	 * as an NMI.
+ 	 */
+ 	if (cpu_has_feature(CPU_FTR_HVMODE)) {
+ 		hsrr0 = mfspr(SPRN_HSRR0);
+ 		hsrr1 = mfspr(SPRN_HSRR1);
+ 		saved_hsrrs = true;
+ 	}
+ 
+ 	hv_nmi_check_nonrecoverable(regs);
+ 
++>>>>>>> cbf2ba952a70 (powerpc/64s: system reset interrupt preserve HSRRs)
  	__this_cpu_inc(irq_stat.sreset_irqs);
  
  	/* See if any machine dependent calls */
* Unmerged path arch/powerpc/kernel/traps.c
