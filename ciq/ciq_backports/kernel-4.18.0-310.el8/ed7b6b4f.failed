bdi: remove BDI_CAP_CGROUP_WRITEBACK

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Christoph Hellwig <hch@lst.de>
commit ed7b6b4f6e915cb0bc52d0000bcc63168867b6ac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/ed7b6b4f.failed

Just checking SB_I_CGROUPWB for cgroup writeback support is enough.
Either the file system allocates its own bdi (e.g. btrfs), in which case
it is known to support cgroup writeback, or the bdi comes from the block
layer, which always supports cgroup writeback.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Jan Kara <jack@suse.cz>
	Reviewed-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit ed7b6b4f6e915cb0bc52d0000bcc63168867b6ac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-core.c
#	fs/btrfs/disk-io.c
diff --cc block/blk-core.c
index d7680a7c3b43,1cc4fa6bc7fe..000000000000
--- a/block/blk-core.c
+++ b/block/blk-core.c
@@@ -529,9 -538,6 +529,12 @@@ struct request_queue *__blk_alloc_queue
  	if (!q->stats)
  		goto fail_stats;
  
++<<<<<<< HEAD
 +	q->backing_dev_info->ra_pages = VM_READAHEAD_PAGES;
 +	q->backing_dev_info->io_pages = VM_READAHEAD_PAGES;
 +	q->backing_dev_info->capabilities = BDI_CAP_CGROUP_WRITEBACK;
++=======
++>>>>>>> ed7b6b4f6e91 (bdi: remove BDI_CAP_CGROUP_WRITEBACK)
  	q->node = node_id;
  
  	atomic_set(&q->nr_active_requests_shared_sbitmap, 0);
diff --cc fs/btrfs/disk-io.c
index 28034e63e3b9,e24927bddd58..000000000000
--- a/fs/btrfs/disk-io.c
+++ b/fs/btrfs/disk-io.c
@@@ -2978,10 -3091,6 +2978,13 @@@ int open_ctree(struct super_block *sb
  		goto fail_sb_buffer;
  	}
  
++<<<<<<< HEAD
 +	sb->s_bdi->congested_fn = btrfs_congested_fn;
 +	sb->s_bdi->congested_data = fs_info;
 +	sb->s_bdi->capabilities |= BDI_CAP_CGROUP_WRITEBACK;
 +	sb->s_bdi->ra_pages = VM_READAHEAD_PAGES;
++=======
++>>>>>>> ed7b6b4f6e91 (bdi: remove BDI_CAP_CGROUP_WRITEBACK)
  	sb->s_bdi->ra_pages *= btrfs_super_num_devices(disk_super);
  	sb->s_bdi->ra_pages = max(sb->s_bdi->ra_pages, SZ_4M / PAGE_SIZE);
  
* Unmerged path block/blk-core.c
* Unmerged path fs/btrfs/disk-io.c
diff --git a/include/linux/backing-dev.h b/include/linux/backing-dev.h
index 6b3504bf7a42..94f1ffc6e749 100644
--- a/include/linux/backing-dev.h
+++ b/include/linux/backing-dev.h
@@ -123,7 +123,6 @@ int bdi_set_max_ratio(struct backing_dev_info *bdi, unsigned int max_ratio);
  * BDI_CAP_NO_ACCT_WB:     Don't automatically account writeback pages
  * BDI_CAP_STRICTLIMIT:    Keep number of dirty pages below bdi threshold.
  *
- * BDI_CAP_CGROUP_WRITEBACK: Supports cgroup-aware writeback.
  * BDI_CAP_SYNCHRONOUS_IO: Device is so fast that asynchronous IO would be
  *			   inefficient.
  */
@@ -240,9 +239,9 @@ int inode_congested(struct inode *inode, int cong_bits);
  * inode_cgwb_enabled - test whether cgroup writeback is enabled on an inode
  * @inode: inode of interest
  *
- * cgroup writeback requires support from both the bdi and filesystem.
- * Also, both memcg and iocg have to be on the default hierarchy.  Test
- * whether all conditions are met.
+ * Cgroup writeback requires support from the filesystem.  Also, both memcg and
+ * iocg have to be on the default hierarchy.  Test whether all conditions are
+ * met.
  *
  * Note that the test result may change dynamically on the same inode
  * depending on how memcg and iocg are configured.
@@ -254,7 +253,6 @@ static inline bool inode_cgwb_enabled(struct inode *inode)
 	return cgroup_subsys_on_dfl(memory_cgrp_subsys) &&
 		cgroup_subsys_on_dfl(io_cgrp_subsys) &&
 		bdi_cap_account_dirty(bdi) &&
-		(bdi->capabilities & BDI_CAP_CGROUP_WRITEBACK) &&
 		(inode->i_sb->s_iflags & SB_I_CGROUPWB);
 }
 
