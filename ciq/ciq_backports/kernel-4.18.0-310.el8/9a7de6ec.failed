KVM: nSVM: If VMRUN is single-stepped, queue the #DB intercept in nested_svm_vmexit()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Krish Sadhukhan <krish.sadhukhan@oracle.com>
commit 9a7de6ecc3ed80efb95fe1d97b6440922e55dbda
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/9a7de6ec.failed

According to APM, the #DB intercept for a single-stepped VMRUN must happen
after the completion of that instruction, when the guest does #VMEXIT to
the host. However, in the current implementation of KVM, the #DB intercept
for a single-stepped VMRUN happens after the completion of the instruction
that follows the VMRUN instruction. When the #DB intercept handler is
invoked, it shows the RIP of the instruction that follows VMRUN, instead of
of VMRUN itself. This is an incorrect RIP as far as single-stepping VMRUN
is concerned.

This patch fixes the problem by checking, in nested_svm_vmexit(), for the
condition that the VMRUN instruction is being single-stepped and if so,
queues the pending #DB intercept so that the #DB is accounted for before
we execute L1's next instruction.

	Suggested-by: Paolo Bonzini <pbonzini@redhat.com>
	Signed-off-by: Krish Sadhukhan <krish.sadhukhan@oraacle.com>
Message-Id: <20210323175006.73249-2-krish.sadhukhan@oracle.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 9a7de6ecc3ed80efb95fe1d97b6440922e55dbda)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm/nested.c
diff --cc arch/x86/kvm/svm/nested.c
index 2e68b35e628c,b974bd9c53c3..000000000000
--- a/arch/x86/kvm/svm/nested.c
+++ b/arch/x86/kvm/svm/nested.c
@@@ -679,11 -761,17 +679,21 @@@ int nested_svm_vmexit(struct vcpu_svm *
  	vmcb12->control.pause_filter_thresh =
  		svm->vmcb->control.pause_filter_thresh;
  
 -	nested_svm_copy_common_state(svm->nested.vmcb02.ptr, svm->vmcb01.ptr);
 +	/* Restore the original control entries */
 +	copy_vmcb_control_area(&vmcb->control, &hsave->control);
  
++<<<<<<< HEAD
 +	/* On vmexit the  GIF is set to false */
++=======
+ 	svm_switch_vmcb(svm, &svm->vmcb01);
+ 	WARN_ON_ONCE(svm->vmcb->control.exit_code != SVM_EXIT_VMRUN);
+ 
+ 	/*
+ 	 * On vmexit the  GIF is set to false and
+ 	 * no event can be injected in L1.
+ 	 */
++>>>>>>> 9a7de6ecc3ed (KVM: nSVM: If VMRUN is single-stepped, queue the #DB intercept in nested_svm_vmexit())
  	svm_set_gif(svm, false);
 -	svm->vmcb->control.exit_int_info = 0;
  
  	svm->vcpu.arch.tsc_offset = svm->vcpu.arch.l1_tsc_offset;
  	if (svm->vmcb->control.tsc_offset != svm->vcpu.arch.tsc_offset) {
@@@ -735,9 -815,18 +745,18 @@@
  	 * doesn't end up in L1.
  	 */
  	svm->vcpu.arch.nmi_injected = false;
 -	kvm_clear_exception_queue(vcpu);
 -	kvm_clear_interrupt_queue(vcpu);
 +	kvm_clear_exception_queue(&svm->vcpu);
 +	kvm_clear_interrupt_queue(&svm->vcpu);
  
+ 	/*
+ 	 * If we are here following the completion of a VMRUN that
+ 	 * is being single-stepped, queue the pending #DB intercept
+ 	 * right now so that it an be accounted for before we execute
+ 	 * L1's next instruction.
+ 	 */
+ 	if (unlikely(svm->vmcb->save.rflags & X86_EFLAGS_TF))
+ 		kvm_queue_exception(&(svm->vcpu), DB_VECTOR);
+ 
  	return 0;
  }
  
* Unmerged path arch/x86/kvm/svm/nested.c
