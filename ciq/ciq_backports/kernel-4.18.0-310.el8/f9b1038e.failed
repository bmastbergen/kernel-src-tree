mm/memcg: remove rcu locking for lock_page_lruvec function series

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Alex Shi <alex.shi@linux.alibaba.com>
commit f9b1038ebccad354256cf84749cbc321b5347497
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/f9b1038e.failed

lock_page_lruvec() and its variants used rcu_read_lock() with the
intention of safeguarding against the mem_cgroup being destroyed
concurrently; but so long as they are called under the specified
conditions (as they are), there is no way for the page's mem_cgroup to be
destroyed.  Delete the unnecessary rcu_read_lock() and _unlock().

Hugh Dickins polished the commit log.  Thanks a lot!

Link: https://lkml.kernel.org/r/1608614453-10739-2-git-send-email-alex.shi@linux.alibaba.com
	Signed-off-by: Alex Shi <alex.shi@linux.alibaba.com>
	Acked-by: Hugh Dickins <hughd@google.com>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Michal Hocko <mhocko@kernel.org>
	Cc: Vladimir Davydov <vdavydov.dev@gmail.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit f9b1038ebccad354256cf84749cbc321b5347497)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memcontrol.c
diff --cc mm/memcontrol.c
index 4d65b541b4a3,5435b370c929..000000000000
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@@ -1314,43 -1325,69 +1314,76 @@@ int mem_cgroup_scan_tasks(struct mem_cg
  	return ret;
  }
  
 -#ifdef CONFIG_DEBUG_VM
 -void lruvec_memcg_debug(struct lruvec *lruvec, struct page *page)
 -{
 -	struct mem_cgroup *memcg;
 -
 -	if (mem_cgroup_disabled())
 -		return;
 -
 -	memcg = page_memcg(page);
 -
 -	if (!memcg)
 -		VM_BUG_ON_PAGE(lruvec_memcg(lruvec) != root_mem_cgroup, page);
 -	else
 -		VM_BUG_ON_PAGE(lruvec_memcg(lruvec) != memcg, page);
 -}
 -#endif
 -
  /**
 - * lock_page_lruvec - lock and return lruvec for a given page.
 + * mem_cgroup_page_lruvec - return lruvec for isolating/putting an LRU page
   * @page: the page
 + * @pgdat: pgdat of the page
   *
 - * These functions are safe to use under any of the following conditions:
 - * - page locked
 - * - PageLRU cleared
 - * - lock_page_memcg()
 - * - page->_refcount is zero
 + * This function relies on page's memcg being stable - see the
 + * access rules in commit_charge().
   */
 -struct lruvec *lock_page_lruvec(struct page *page)
 +struct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)
  {
 +	struct mem_cgroup_per_node *mz;
 +	struct mem_cgroup *memcg;
  	struct lruvec *lruvec;
 -	struct pglist_data *pgdat = page_pgdat(page);
  
++<<<<<<< HEAD
 +	if (mem_cgroup_disabled()) {
 +		lruvec = &pgdat->__lruvec;
 +		goto out;
 +	}
 +
 +	memcg = page->mem_cgroup;
 +	/*
 +	 * Swapcache readahead pages are added to the LRU - and
 +	 * possibly migrated - before they are charged.
 +	 */
 +	if (!memcg)
 +		memcg = root_mem_cgroup;
++=======
+ 	lruvec = mem_cgroup_page_lruvec(page, pgdat);
+ 	spin_lock(&lruvec->lru_lock);
+ 
+ 	lruvec_memcg_debug(lruvec, page);
+ 
+ 	return lruvec;
+ }
+ 
+ struct lruvec *lock_page_lruvec_irq(struct page *page)
+ {
+ 	struct lruvec *lruvec;
+ 	struct pglist_data *pgdat = page_pgdat(page);
+ 
+ 	lruvec = mem_cgroup_page_lruvec(page, pgdat);
+ 	spin_lock_irq(&lruvec->lru_lock);
+ 
+ 	lruvec_memcg_debug(lruvec, page);
+ 
+ 	return lruvec;
+ }
+ 
+ struct lruvec *lock_page_lruvec_irqsave(struct page *page, unsigned long *flags)
+ {
+ 	struct lruvec *lruvec;
+ 	struct pglist_data *pgdat = page_pgdat(page);
+ 
+ 	lruvec = mem_cgroup_page_lruvec(page, pgdat);
+ 	spin_lock_irqsave(&lruvec->lru_lock, *flags);
+ 
+ 	lruvec_memcg_debug(lruvec, page);
++>>>>>>> f9b1038ebcca (mm/memcg: remove rcu locking for lock_page_lruvec function series)
  
 +	mz = mem_cgroup_page_nodeinfo(memcg, page);
 +	lruvec = &mz->lruvec;
 +out:
 +	/*
 +	 * Since a node can be onlined after the mem_cgroup was created,
 +	 * we have to be prepared to initialize lruvec->zone here;
 +	 * and if offlined then reonlined, we need to reinitialize it.
 +	 */
 +	if (unlikely(lruvec->pgdat != pgdat))
 +		lruvec->pgdat = pgdat;
  	return lruvec;
  }
  
* Unmerged path mm/memcontrol.c
