nvme-core: check ctrl css before setting up zns

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Chaitanya Kulkarni <chaitanya.kulkarni@wdc.com>
commit 0ec84df4953bd42c6583a555773f1d4996a061eb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/0ec84df4.failed

Ensure multiple Command Sets are supported before starting to setup a
ZNS namespace.

	Signed-off-by: Chaitanya Kulkarni <chaitanya.kulkarni@wdc.com>
[hch: move the check around a bit]
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 0ec84df4953bd42c6583a555773f1d4996a061eb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
diff --cc drivers/nvme/host/core.c
index 67eeb4f22720,82ad5eef9d0c..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -4143,17 -4036,79 +4143,47 @@@ static void nvme_ns_remove_by_nsid(stru
  	}
  }
  
 -static void nvme_validate_ns(struct nvme_ns *ns, struct nvme_ns_ids *ids)
 -{
 -	struct nvme_id_ns *id;
 -	int ret = NVME_SC_INVALID_NS | NVME_SC_DNR;
 -
 -	if (test_bit(NVME_NS_DEAD, &ns->flags))
 -		goto out;
 -
 -	ret = nvme_identify_ns(ns->ctrl, ns->head->ns_id, ids, &id);
 -	if (ret)
 -		goto out;
 -
 -	ret = NVME_SC_INVALID_NS | NVME_SC_DNR;
 -	if (!nvme_ns_ids_equal(&ns->head->ids, ids)) {
 -		dev_err(ns->ctrl->device,
 -			"identifiers changed for nsid %d\n", ns->head->ns_id);
 -		goto out_free_id;
 -	}
 -
 -	ret = nvme_update_ns_info(ns, id);
 -
 -out_free_id:
 -	kfree(id);
 -out:
 -	/*
 -	 * Only remove the namespace if we got a fatal error back from the
 -	 * device, otherwise ignore the error and just move on.
 -	 *
 -	 * TODO: we should probably schedule a delayed retry here.
 -	 */
 -	if (ret > 0 && (ret & NVME_SC_DNR))
 -		nvme_ns_remove(ns);
 -}
 -
  static void nvme_validate_or_alloc_ns(struct nvme_ctrl *ctrl, unsigned nsid)
  {
 -	struct nvme_ns_ids ids = { };
  	struct nvme_ns *ns;
  
 -	if (nvme_identify_ns_descs(ctrl, nsid, &ids))
 -		return;
 -
  	ns = nvme_find_get_ns(ctrl, nsid);
  	if (ns) {
 -		nvme_validate_ns(ns, &ids);
 +		if (revalidate_disk(ns->disk))
 +			nvme_ns_remove(ns);
  		nvme_put_ns(ns);
++<<<<<<< HEAD
 +	} else
 +		nvme_alloc_ns(ctrl, nsid);
++=======
+ 		return;
+ 	}
+ 
+ 	switch (ids.csi) {
+ 	case NVME_CSI_NVM:
+ 		nvme_alloc_ns(ctrl, nsid, &ids);
+ 		break;
+ 	case NVME_CSI_ZNS:
+ 		if (!IS_ENABLED(CONFIG_BLK_DEV_ZONED)) {
+ 			dev_warn(ctrl->device,
+ 				"nsid %u not supported without CONFIG_BLK_DEV_ZONED\n",
+ 				nsid);
+ 			break;
+ 		}
+ 		if (!nvme_multi_css(ctrl)) {
+ 			dev_warn(ctrl->device,
+ 				"command set not reported for nsid: %d\n",
+ 				ns->head->ns_id);
+ 			break;
+ 		}
+ 		nvme_alloc_ns(ctrl, nsid, &ids);
+ 		break;
+ 	default:
+ 		dev_warn(ctrl->device, "unknown csi %u for nsid %u\n",
+ 			ids.csi, nsid);
+ 		break;
+ 	}
++>>>>>>> 0ec84df4953b (nvme-core: check ctrl css before setting up zns)
  }
  
  static void nvme_remove_invalid_namespaces(struct nvme_ctrl *ctrl,
* Unmerged path drivers/nvme/host/core.c
