KVM: SVM: merge update_cr0_intercept into svm_set_cr0

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 2a32a77cefa662773197b362db8e4190027c89fa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/2a32a77c.failed

The logic of update_cr0_intercept is pointlessly complicated.
All svm_set_cr0 is compute the effective cr0 and compare it with
the guest value.

Inlining the function and simplifying the condition
clarifies what it is doing.

	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 2a32a77cefa662773197b362db8e4190027c89fa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm/svm.c
diff --cc arch/x86/kvm/svm/svm.c
index 05deab5ed2e8,a45f086a941d..000000000000
--- a/arch/x86/kvm/svm/svm.c
+++ b/arch/x86/kvm/svm/svm.c
@@@ -1652,31 -1720,13 +1652,35 @@@ static void svm_set_gdt(struct kvm_vcp
  	vmcb_mark_dirty(svm->vmcb, VMCB_DT);
  }
  
++<<<<<<< HEAD
 +static void update_cr0_intercept(struct vcpu_svm *svm)
 +{
 +	ulong gcr0 = svm->vcpu.arch.cr0;
 +	u64 *hcr0 = &svm->vmcb->save.cr0;
 +
 +	*hcr0 = (*hcr0 & ~SVM_CR0_SELECTIVE_MASK)
 +		| (gcr0 & SVM_CR0_SELECTIVE_MASK);
 +
 +	vmcb_mark_dirty(svm->vmcb, VMCB_CR);
 +
 +	if (gcr0 == *hcr0) {
 +		svm_clr_intercept(svm, INTERCEPT_CR0_READ);
 +		svm_clr_intercept(svm, INTERCEPT_CR0_WRITE);
 +	} else {
 +		svm_set_intercept(svm, INTERCEPT_CR0_READ);
 +		svm_set_intercept(svm, INTERCEPT_CR0_WRITE);
 +	}
 +}
 +
++=======
++>>>>>>> 2a32a77cefa6 (KVM: SVM: merge update_cr0_intercept into svm_set_cr0)
  void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)
  {
  	struct vcpu_svm *svm = to_svm(vcpu);
+ 	u64 hcr0 = cr0;
  
  #ifdef CONFIG_X86_64
 -	if (vcpu->arch.efer & EFER_LME && !vcpu->arch.guest_state_protected) {
 +	if (vcpu->arch.efer & EFER_LME) {
  		if (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {
  			vcpu->arch.efer |= EFER_LMA;
  			svm->vmcb->save.efer |= EFER_LMA | EFER_LME;
* Unmerged path arch/x86/kvm/svm/svm.c
