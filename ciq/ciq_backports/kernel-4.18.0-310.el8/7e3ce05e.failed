netlink: add tracepoint at NL_SET_ERR_MSG

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
commit 7e3ce05e7f650371061d0b9eec1e1cf74ed6fca0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/7e3ce05e.failed

Often userspace won't request the extack information, or they don't log it
because of log level or so, and even when they do, sometimes it's not
enough to know exactly what caused the error.

Netlink extack is the standard way of reporting erros with descriptive
error messages. With a trace point on it, we then can know exactly where
the error happened, regardless of userspace app. Also, we can even see if
the err msg was overwritten.

The wrapper do_trace_netlink_extack() is because trace points shouldn't be
called from .h files, as trace points are not that small, and the function
call to do_trace_netlink_extack() on the macros is not protected by
tracepoint_enabled() because the macros are called from modules, and this
would require exporting some trace structs. As this is error path, it's
better to export just the wrapper instead.

v2: removed leftover tracepoint declaration

	Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
	Reviewed-by: David Ahern <dsahern@kernel.org>
Link: https://lore.kernel.org/r/4546b63e67b2989789d146498b13cc09e1fdc543.1612403190.git.marcelo.leitner@gmail.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 7e3ce05e7f650371061d0b9eec1e1cf74ed6fca0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netlink.h
diff --cc include/linux/netlink.h
index cb511a513223,0bcf98098c5a..000000000000
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@@ -110,6 -108,24 +114,27 @@@ struct netlink_ext_ack 
  	}						\
  } while (0)
  
++<<<<<<< HEAD
++=======
+ #define NL_SET_BAD_ATTR(extack, attr) NL_SET_BAD_ATTR_POLICY(extack, attr, NULL)
+ 
+ #define NL_SET_ERR_MSG_ATTR_POL(extack, attr, pol, msg) do {	\
+ 	static const char __msg[] = msg;			\
+ 	struct netlink_ext_ack *__extack = (extack);		\
+ 								\
+ 	do_trace_netlink_extack(__msg);				\
+ 								\
+ 	if (__extack) {						\
+ 		__extack->_msg = __msg;				\
+ 		__extack->bad_attr = (attr);			\
+ 		__extack->policy = (pol);			\
+ 	}							\
+ } while (0)
+ 
+ #define NL_SET_ERR_MSG_ATTR(extack, attr, msg)		\
+ 	NL_SET_ERR_MSG_ATTR_POL(extack, attr, NULL, msg)
+ 
++>>>>>>> 7e3ce05e7f65 (netlink: add tracepoint at NL_SET_ERR_MSG)
  static inline void nl_set_extack_cookie_u64(struct netlink_ext_ack *extack,
  					    u64 cookie)
  {
* Unmerged path include/linux/netlink.h
diff --git a/include/trace/events/netlink.h b/include/trace/events/netlink.h
new file mode 100644
index 000000000000..3b7be3b386a4
--- /dev/null
+++ b/include/trace/events/netlink.h
@@ -0,0 +1,29 @@
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM netlink
+
+#if !defined(_TRACE_NETLINK_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_NETLINK_H
+
+#include <linux/tracepoint.h>
+
+TRACE_EVENT(netlink_extack,
+
+	TP_PROTO(const char *msg),
+
+	TP_ARGS(msg),
+
+	TP_STRUCT__entry(
+		__string(	msg,	msg	)
+	),
+
+	TP_fast_assign(
+		__assign_str(msg, msg);
+	),
+
+	TP_printk("msg=%s", __get_str(msg))
+);
+
+#endif /* _TRACE_NETLINK_H */
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c
index 2ef0699460d9..6016b34d7856 100644
--- a/net/netlink/af_netlink.c
+++ b/net/netlink/af_netlink.c
@@ -71,6 +71,8 @@
 #include <net/sock.h>
 #include <net/scm.h>
 #include <net/netlink.h>
+#define CREATE_TRACE_POINTS
+#include <trace/events/netlink.h>
 
 #include "af_netlink.h"
 
@@ -151,6 +153,12 @@ static BLOCKING_NOTIFIER_HEAD(netlink_chain);
 
 static const struct rhashtable_params netlink_rhashtable_params;
 
+void do_trace_netlink_extack(const char *msg)
+{
+	trace_netlink_extack(msg);
+}
+EXPORT_SYMBOL(do_trace_netlink_extack);
+
 static inline u32 netlink_group_mask(u32 group)
 {
 	return group ? 1 << (group - 1) : 0;
