kcsan: Prefer __always_inline for fast-path

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Marco Elver <elver@google.com>
commit 5c361425744d1e3b03d835dde659708683ca27d1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/5c361425.failed

Prefer __always_inline for fast-path functions that are called outside
of user_access_save, to avoid generating UACCESS warnings when
optimizing for size (CC_OPTIMIZE_FOR_SIZE). It will also avoid future
surprises with compiler versions that change the inlining heuristic even
when optimizing for performance.

	Reported-by: Randy Dunlap <rdunlap@infradead.org>
	Acked-by: Randy Dunlap <rdunlap@infradead.org> # build-tested
	Signed-off-by: Marco Elver <elver@google.com>
	Signed-off-by: Paul E. McKenney <paulmck@kernel.org>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
Link: http://lkml.kernel.org/r/58708908-84a0-0a81-a836-ad97e33dbb62@infradead.org
(cherry picked from commit 5c361425744d1e3b03d835dde659708683ca27d1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/kcsan/core.c
#	kernel/kcsan/encoding.h
diff --cc kernel/kcsan/core.c
index d9410d58c93e,4d4ab5c5dc53..000000000000
--- a/kernel/kcsan/core.c
+++ b/kernel/kcsan/core.c
@@@ -78,9 -78,10 +78,16 @@@ static atomic_long_t watchpoints[CONFIG
   */
  static DEFINE_PER_CPU(long, kcsan_skip);
  
++<<<<<<< HEAD
 +static inline atomic_long_t *find_watchpoint(unsigned long addr, size_t size,
 +					     bool expect_write,
 +					     long *encoded_watchpoint)
++=======
+ static __always_inline atomic_long_t *find_watchpoint(unsigned long addr,
+ 						      size_t size,
+ 						      bool expect_write,
+ 						      long *encoded_watchpoint)
++>>>>>>> 5c361425744d (kcsan: Prefer __always_inline for fast-path)
  {
  	const int slot = watchpoint_slot(addr);
  	const unsigned long addr_masked = addr & WATCHPOINT_ADDR_MASK;
@@@ -150,11 -146,10 +157,16 @@@ static inline atomic_long_t *insert_wat
   *	2. the thread that set up the watchpoint already removed it;
   *	3. the watchpoint was removed and then re-used.
   */
++<<<<<<< HEAD
 +static inline bool try_consume_watchpoint(atomic_long_t *watchpoint,
 +					  long encoded_watchpoint)
++=======
+ static __always_inline bool
+ try_consume_watchpoint(atomic_long_t *watchpoint, long encoded_watchpoint)
++>>>>>>> 5c361425744d (kcsan: Prefer __always_inline for fast-path)
  {
 -	return atomic_long_try_cmpxchg_relaxed(watchpoint, &encoded_watchpoint, CONSUMED_WATCHPOINT);
 +	return atomic_long_try_cmpxchg_relaxed(watchpoint, &encoded_watchpoint,
 +					       CONSUMED_WATCHPOINT);
  }
  
  /*
@@@ -162,14 -157,13 +174,14 @@@
   */
  static inline bool remove_watchpoint(atomic_long_t *watchpoint)
  {
 -	return atomic_long_xchg_relaxed(watchpoint, INVALID_WATCHPOINT) != CONSUMED_WATCHPOINT;
 +	return atomic_long_xchg_relaxed(watchpoint, INVALID_WATCHPOINT) !=
 +	       CONSUMED_WATCHPOINT;
  }
  
- static inline struct kcsan_ctx *get_ctx(void)
+ static __always_inline struct kcsan_ctx *get_ctx(void)
  {
  	/*
 -	 * In interrupts, use raw_cpu_ptr to avoid unnecessary checks, that would
 +	 * In interrupt, use raw_cpu_ptr to avoid unnecessary checks, that would
  	 * also result in calls that generate warnings in uaccess regions.
  	 */
  	return in_task() ? &current->kcsan_ctx : raw_cpu_ptr(&kcsan_cpu_ctx);
diff --cc kernel/kcsan/encoding.h
index e17bdac0e54b,f03562aaf2eb..000000000000
--- a/kernel/kcsan/encoding.h
+++ b/kernel/kcsan/encoding.h
@@@ -58,9 -59,10 +58,16 @@@ static inline long encode_watchpoint(un
  		      (addr & WATCHPOINT_ADDR_MASK));
  }
  
++<<<<<<< HEAD
 +static inline bool decode_watchpoint(long watchpoint,
 +				     unsigned long *addr_masked, size_t *size,
 +				     bool *is_write)
++=======
+ static __always_inline bool decode_watchpoint(long watchpoint,
+ 					      unsigned long *addr_masked,
+ 					      size_t *size,
+ 					      bool *is_write)
++>>>>>>> 5c361425744d (kcsan: Prefer __always_inline for fast-path)
  {
  	if (watchpoint == INVALID_WATCHPOINT ||
  	    watchpoint == CONSUMED_WATCHPOINT)
diff --git a/kernel/kcsan/atomic.h b/kernel/kcsan/atomic.h
index c9c3fe628011..466e6777533e 100644
--- a/kernel/kcsan/atomic.h
+++ b/kernel/kcsan/atomic.h
@@ -18,7 +18,7 @@
  * than cast to volatile. Eventually, we hope to be able to remove this
  * function.
  */
-static inline bool kcsan_is_atomic(const volatile void *ptr)
+static __always_inline bool kcsan_is_atomic(const volatile void *ptr)
 {
 	/* only jiffies for now */
 	return ptr == &jiffies;
* Unmerged path kernel/kcsan/core.c
* Unmerged path kernel/kcsan/encoding.h
