ocxl: Initiate a TLB invalidate command

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Christophe Lombard <clombard@linux.vnet.ibm.com>
commit 19b311ca51e108b6d8d679496af8635fdc1984a8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/19b311ca.failed

When a TLB Invalidate is required for the Logical Partition, the following
sequence has to be performed:

1. Load MMIO ATSD AVA register with the necessary value, if required.
2. Write the MMIO ATSD launch register to initiate the TLB Invalidate
command.
3. Poll the MMIO ATSD status register to determine when the TLB Invalidate
   has been completed.

	Signed-off-by: Christophe Lombard <clombard@linux.vnet.ibm.com>
	Acked-by: Frederic Barrat <fbarrat@linux.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20201125155013.39955-3-clombard@linux.vnet.ibm.com
(cherry picked from commit 19b311ca51e108b6d8d679496af8635fdc1984a8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/pnv-ocxl.h
#	arch/powerpc/platforms/powernv/ocxl.c
diff --cc arch/powerpc/include/asm/pnv-ocxl.h
index 208b5503f4ed,9acd1fbf1197..000000000000
--- a/arch/powerpc/include/asm/pnv-ocxl.h
+++ b/arch/powerpc/include/asm/pnv-ocxl.h
@@@ -9,28 -10,76 +10,89 @@@
  #define PNV_OCXL_TL_BITS_PER_RATE       4
  #define PNV_OCXL_TL_RATE_BUF_SIZE       ((PNV_OCXL_TL_MAX_TEMPLATE+1) * PNV_OCXL_TL_BITS_PER_RATE / 8)
  
++<<<<<<< HEAD
 +extern int pnv_ocxl_get_actag(struct pci_dev *dev, u16 *base, u16 *enabled,
 +			u16 *supported);
 +extern int pnv_ocxl_get_pasid_count(struct pci_dev *dev, int *count);
++=======
+ #define PNV_OCXL_ATSD_TIMEOUT		1
+ 
+ /* TLB Management Instructions */
+ #define PNV_OCXL_ATSD_LNCH		0x00
+ /* Radix Invalidate */
+ #define   PNV_OCXL_ATSD_LNCH_R		PPC_BIT(0)
+ /* Radix Invalidation Control
+  * 0b00 Just invalidate TLB.
+  * 0b01 Invalidate just Page Walk Cache.
+  * 0b10 Invalidate TLB, Page Walk Cache, and any
+  * caching of Partition and Process Table Entries.
+  */
+ #define   PNV_OCXL_ATSD_LNCH_RIC	PPC_BITMASK(1, 2)
+ /* Number and Page Size of translations to be invalidated */
+ #define   PNV_OCXL_ATSD_LNCH_LP		PPC_BITMASK(3, 10)
+ /* Invalidation Criteria
+  * 0b00 Invalidate just the target VA.
+  * 0b01 Invalidate matching PID.
+  */
+ #define   PNV_OCXL_ATSD_LNCH_IS		PPC_BITMASK(11, 12)
+ /* 0b1: Process Scope, 0b0: Partition Scope */
+ #define   PNV_OCXL_ATSD_LNCH_PRS	PPC_BIT(13)
+ /* Invalidation Flag */
+ #define   PNV_OCXL_ATSD_LNCH_B		PPC_BIT(14)
+ /* Actual Page Size to be invalidated
+  * 000 4KB
+  * 101 64KB
+  * 001 2MB
+  * 010 1GB
+  */
+ #define   PNV_OCXL_ATSD_LNCH_AP		PPC_BITMASK(15, 17)
+ /* Defines the large page select
+  * L=0b0 for 4KB pages
+  * L=0b1 for large pages)
+  */
+ #define   PNV_OCXL_ATSD_LNCH_L		PPC_BIT(18)
+ /* Process ID */
+ #define   PNV_OCXL_ATSD_LNCH_PID	PPC_BITMASK(19, 38)
+ /* NoFlush â€“ Assumed to be 0b0 */
+ #define   PNV_OCXL_ATSD_LNCH_F		PPC_BIT(39)
+ #define   PNV_OCXL_ATSD_LNCH_OCAPI_SLBI	PPC_BIT(40)
+ #define   PNV_OCXL_ATSD_LNCH_OCAPI_SINGLETON	PPC_BIT(41)
+ #define PNV_OCXL_ATSD_AVA		0x08
+ #define   PNV_OCXL_ATSD_AVA_AVA		PPC_BITMASK(0, 51)
+ #define PNV_OCXL_ATSD_STAT		0x10
+ 
+ int pnv_ocxl_get_actag(struct pci_dev *dev, u16 *base, u16 *enabled, u16 *supported);
+ int pnv_ocxl_get_pasid_count(struct pci_dev *dev, int *count);
++>>>>>>> 19b311ca51e1 (ocxl: Initiate a TLB invalidate command)
  
 -int pnv_ocxl_get_tl_cap(struct pci_dev *dev, long *cap,
 +extern int pnv_ocxl_get_tl_cap(struct pci_dev *dev, long *cap,
  			char *rate_buf, int rate_buf_size);
 -int pnv_ocxl_set_tl_conf(struct pci_dev *dev, long cap,
 -			 uint64_t rate_buf_phys, int rate_buf_size);
 +extern int pnv_ocxl_set_tl_conf(struct pci_dev *dev, long cap,
 +			uint64_t rate_buf_phys, int rate_buf_size);
  
 -int pnv_ocxl_get_xsl_irq(struct pci_dev *dev, int *hwirq);
 -void pnv_ocxl_unmap_xsl_regs(void __iomem *dsisr, void __iomem *dar,
 -			     void __iomem *tfc, void __iomem *pe_handle);
 -int pnv_ocxl_map_xsl_regs(struct pci_dev *dev, void __iomem **dsisr,
 -			  void __iomem **dar, void __iomem **tfc,
 -			  void __iomem **pe_handle);
 +extern int pnv_ocxl_get_xsl_irq(struct pci_dev *dev, int *hwirq);
 +extern void pnv_ocxl_unmap_xsl_regs(void __iomem *dsisr, void __iomem *dar,
 +				void __iomem *tfc, void __iomem *pe_handle);
 +extern int pnv_ocxl_map_xsl_regs(struct pci_dev *dev, void __iomem **dsisr,
 +				void __iomem **dar, void __iomem **tfc,
 +				void __iomem **pe_handle);
  
 -int pnv_ocxl_spa_setup(struct pci_dev *dev, void *spa_mem, int PE_mask, void **platform_data);
 -void pnv_ocxl_spa_release(void *platform_data);
 -int pnv_ocxl_spa_remove_pe_from_cache(void *platform_data, int pe_handle);
 +extern int pnv_ocxl_spa_setup(struct pci_dev *dev, void *spa_mem, int PE_mask,
 +			void **platform_data);
 +extern void pnv_ocxl_spa_release(void *platform_data);
 +extern int pnv_ocxl_spa_remove_pe_from_cache(void *platform_data, int pe_handle);
  
 +extern int pnv_ocxl_alloc_xive_irq(u32 *irq, u64 *trigger_addr);
 +extern void pnv_ocxl_free_xive_irq(u32 irq);
 +
++<<<<<<< HEAD
++=======
+ int pnv_ocxl_map_lpar(struct pci_dev *dev, uint64_t lparid,
+ 		      uint64_t lpcr, void __iomem **arva);
+ void pnv_ocxl_unmap_lpar(void __iomem *arva);
+ void pnv_ocxl_tlb_invalidate(void __iomem *arva,
+ 			     unsigned long pid,
+ 			     unsigned long addr,
+ 			     unsigned long page_size);
++>>>>>>> 19b311ca51e1 (ocxl: Initiate a TLB invalidate command)
  #endif /* _ASM_PNV_OCXL_H */
diff --cc arch/powerpc/platforms/powernv/ocxl.c
index 8c65aacda9c8,9105efcf242a..000000000000
--- a/arch/powerpc/platforms/powernv/ocxl.c
+++ b/arch/powerpc/platforms/powernv/ocxl.c
@@@ -485,31 -484,116 +485,104 @@@ int pnv_ocxl_spa_remove_pe_from_cache(v
  }
  EXPORT_SYMBOL_GPL(pnv_ocxl_spa_remove_pe_from_cache);
  
 -int pnv_ocxl_map_lpar(struct pci_dev *dev, uint64_t lparid,
 -		      uint64_t lpcr, void __iomem **arva)
 +int pnv_ocxl_alloc_xive_irq(u32 *irq, u64 *trigger_addr)
  {
 -	struct pci_controller *hose = pci_bus_to_host(dev->bus);
 -	struct pnv_phb *phb = hose->private_data;
 -	u64 mmio_atsd;
 -	int rc;
 -
 -	/* ATSD physical address.
 -	 * ATSD LAUNCH register: write access initiates a shoot down to
 -	 * initiate the TLB Invalidate command.
 -	 */
 -	rc = of_property_read_u64_index(hose->dn, "ibm,mmio-atsd",
 -					0, &mmio_atsd);
 -	if (rc) {
 -		dev_info(&dev->dev, "No available ATSD found\n");
 -		return rc;
 -	}
 -
 -	/* Assign a register set to a Logical Partition and MMIO ATSD
 -	 * LPARID register to the required value.
 -	 */
 -	rc = opal_npu_map_lpar(phb->opal_id, pci_dev_id(dev),
 -			       lparid, lpcr);
 -	if (rc) {
 -		dev_err(&dev->dev, "Error mapping device to LPAR: %d\n", rc);
 -		return rc;
 -	}
 -
 -	*arva = ioremap(mmio_atsd, 24);
 -	if (!(*arva)) {
 -		dev_warn(&dev->dev, "ioremap failed - mmio_atsd: %#llx\n", mmio_atsd);
 -		rc = -ENOMEM;
 +	__be64 flags, trigger_page;
 +	s64 rc;
 +	u32 hwirq;
 +
 +	hwirq = xive_native_alloc_irq();
 +	if (!hwirq)
 +		return -ENOENT;
 +
 +	rc = opal_xive_get_irq_info(hwirq, &flags, NULL, &trigger_page, NULL,
 +				NULL);
 +	if (rc || !trigger_page) {
 +		xive_native_free_irq(hwirq);
 +		return -ENOENT;
  	}
 +	*irq = hwirq;
 +	*trigger_addr = be64_to_cpu(trigger_page);
 +	return 0;
  
 -	return rc;
  }
 -EXPORT_SYMBOL_GPL(pnv_ocxl_map_lpar);
 +EXPORT_SYMBOL_GPL(pnv_ocxl_alloc_xive_irq);
  
 -void pnv_ocxl_unmap_lpar(void __iomem *arva)
 +void pnv_ocxl_free_xive_irq(u32 irq)
  {
 -	iounmap(arva);
 +	xive_native_free_irq(irq);
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL_GPL(pnv_ocxl_free_xive_irq);
++=======
+ EXPORT_SYMBOL_GPL(pnv_ocxl_unmap_lpar);
+ 
+ void pnv_ocxl_tlb_invalidate(void __iomem *arva,
+ 			     unsigned long pid,
+ 			     unsigned long addr,
+ 			     unsigned long page_size)
+ {
+ 	unsigned long timeout = jiffies + (HZ * PNV_OCXL_ATSD_TIMEOUT);
+ 	u64 val = 0ull;
+ 	int pend;
+ 	u8 size;
+ 
+ 	if (!(arva))
+ 		return;
+ 
+ 	if (addr) {
+ 		/* load Abbreviated Virtual Address register with
+ 		 * the necessary value
+ 		 */
+ 		val |= FIELD_PREP(PNV_OCXL_ATSD_AVA_AVA, addr >> (63-51));
+ 		out_be64(arva + PNV_OCXL_ATSD_AVA, val);
+ 	}
+ 
+ 	/* Write access initiates a shoot down to initiate the
+ 	 * TLB Invalidate command
+ 	 */
+ 	val = PNV_OCXL_ATSD_LNCH_R;
+ 	val |= FIELD_PREP(PNV_OCXL_ATSD_LNCH_RIC, 0b10);
+ 	if (addr)
+ 		val |= FIELD_PREP(PNV_OCXL_ATSD_LNCH_IS, 0b00);
+ 	else {
+ 		val |= FIELD_PREP(PNV_OCXL_ATSD_LNCH_IS, 0b01);
+ 		val |= PNV_OCXL_ATSD_LNCH_OCAPI_SINGLETON;
+ 	}
+ 	val |= PNV_OCXL_ATSD_LNCH_PRS;
+ 	/* Actual Page Size to be invalidated
+ 	 * 000 4KB
+ 	 * 101 64KB
+ 	 * 001 2MB
+ 	 * 010 1GB
+ 	 */
+ 	size = 0b101;
+ 	if (page_size == 0x1000)
+ 		size = 0b000;
+ 	if (page_size == 0x200000)
+ 		size = 0b001;
+ 	if (page_size == 0x40000000)
+ 		size = 0b010;
+ 	val |= FIELD_PREP(PNV_OCXL_ATSD_LNCH_AP, size);
+ 	val |= FIELD_PREP(PNV_OCXL_ATSD_LNCH_PID, pid);
+ 	out_be64(arva + PNV_OCXL_ATSD_LNCH, val);
+ 
+ 	/* Poll the ATSD status register to determine when the
+ 	 * TLB Invalidate has been completed.
+ 	 */
+ 	val = in_be64(arva + PNV_OCXL_ATSD_STAT);
+ 	pend = val >> 63;
+ 
+ 	while (pend) {
+ 		if (time_after_eq(jiffies, timeout)) {
+ 			pr_err("%s - Timeout while reading XTS MMIO ATSD status register (val=%#llx, pidr=0x%lx)\n",
+ 			       __func__, val, pid);
+ 			return;
+ 		}
+ 		cpu_relax();
+ 		val = in_be64(arva + PNV_OCXL_ATSD_STAT);
+ 		pend = val >> 63;
+ 	}
+ }
+ EXPORT_SYMBOL_GPL(pnv_ocxl_tlb_invalidate);
++>>>>>>> 19b311ca51e1 (ocxl: Initiate a TLB invalidate command)
* Unmerged path arch/powerpc/include/asm/pnv-ocxl.h
* Unmerged path arch/powerpc/platforms/powernv/ocxl.c
