RDMA/rxe: Remove unneeded pool->state

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Bob Pearson <rpearsonhpe@gmail.com>
commit eae5f0642e2f6a07a73f3fd60ecfeae9b4b32d5c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/eae5f064.failed

rxe_pool.c uses the field pool->state to mark a pool as invalid when it is
shut down and checks it in several pool APIs to verify that the pool has
not been shut down. This is unneeded because the pools are not marked
invalid unless the entire driver is being removed at which point no
functional APIs should or could be executing. This patch removes this
field and associated code.

Link: https://lore.kernel.org/r/20210125211641.2694-6-rpearson@hpe.com
	Suggested-by: zyjzyj2000@gmail.c
	Signed-off-by: Bob Pearson <rpearson@hpe.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit eae5f0642e2f6a07a73f3fd60ecfeae9b4b32d5c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/sw/rxe/rxe_pool.c
diff --cc drivers/infiniband/sw/rxe/rxe_pool.c
index 3727f20dbe87,5aa835028460..000000000000
--- a/drivers/infiniband/sw/rxe/rxe_pool.c
+++ b/drivers/infiniband/sw/rxe/rxe_pool.c
@@@ -222,31 -161,13 +220,30 @@@ out
  	return err;
  }
  
 +static void rxe_pool_release(struct kref *kref)
 +{
 +	struct rxe_pool *pool = container_of(kref, struct rxe_pool, ref_cnt);
 +
 +	pool->state = RXE_POOL_STATE_INVALID;
 +	kfree(pool->index.table);
 +}
 +
 +static void rxe_pool_put(struct rxe_pool *pool)
 +{
 +	kref_put(&pool->ref_cnt, rxe_pool_release);
 +}
 +
  void rxe_pool_cleanup(struct rxe_pool *pool)
  {
- 	unsigned long flags;
- 
- 	write_lock_irqsave(&pool->pool_lock, flags);
- 	pool->state = RXE_POOL_STATE_INVALID;
  	if (atomic_read(&pool->num_elem) > 0)
  		pr_warn("%s pool destroyed with unfree'd elem\n",
  			pool_name(pool));
- 	write_unlock_irqrestore(&pool->pool_lock, flags);
  
++<<<<<<< HEAD
 +	rxe_pool_put(pool);
++=======
+ 	kfree(pool->index.table);
++>>>>>>> eae5f0642e2f (RDMA/rxe: Remove unneeded pool->state)
  }
  
  static u32 alloc_index(struct rxe_pool *pool)
@@@ -365,24 -314,37 +362,58 @@@ void __rxe_drop_index(struct rxe_pool_e
  	write_unlock_irqrestore(&pool->pool_lock, flags);
  }
  
++<<<<<<< HEAD
++void *rxe_alloc(struct rxe_pool *pool)
++{
++=======
+ void *rxe_alloc_locked(struct rxe_pool *pool)
+ {
+ 	struct rxe_type_info *info = &rxe_type_info[pool->type];
+ 	struct rxe_pool_entry *elem;
+ 	u8 *obj;
+ 
+ 	if (atomic_inc_return(&pool->num_elem) > pool->max_elem)
+ 		goto out_cnt;
+ 
+ 	obj = kzalloc(info->size, GFP_ATOMIC);
+ 	if (!obj)
+ 		goto out_cnt;
+ 
+ 	elem = (struct rxe_pool_entry *)(obj + info->elem_offset);
+ 
+ 	elem->pool = pool;
+ 	kref_init(&elem->ref_cnt);
+ 
+ 	return obj;
+ 
+ out_cnt:
+ 	atomic_dec(&pool->num_elem);
+ 	return NULL;
+ }
+ 
  void *rxe_alloc(struct rxe_pool *pool)
  {
+ 	struct rxe_type_info *info = &rxe_type_info[pool->type];
++>>>>>>> eae5f0642e2f (RDMA/rxe: Remove unneeded pool->state)
  	struct rxe_pool_entry *elem;
 -	u8 *obj;
 +	unsigned long flags;
  
 +	might_sleep_if(!(pool->flags & RXE_POOL_ATOMIC));
 +
++<<<<<<< HEAD
 +	read_lock_irqsave(&pool->pool_lock, flags);
 +	if (pool->state != RXE_POOL_STATE_VALID) {
 +		read_unlock_irqrestore(&pool->pool_lock, flags);
 +		return NULL;
 +	}
 +	kref_get(&pool->ref_cnt);
 +	read_unlock_irqrestore(&pool->pool_lock, flags);
 +
 +	if (!ib_device_try_get(&pool->rxe->ib_dev))
 +		goto out_put_pool;
 +
++=======
++>>>>>>> eae5f0642e2f (RDMA/rxe: Remove unneeded pool->state)
  	if (atomic_inc_return(&pool->num_elem) > pool->max_elem)
  		goto out_cnt;
  
@@@ -407,21 -366,6 +438,24 @@@ out_put_pool
  
  int __rxe_add_to_pool(struct rxe_pool *pool, struct rxe_pool_entry *elem)
  {
++<<<<<<< HEAD
 +	unsigned long flags;
 +
 +	might_sleep_if(!(pool->flags & RXE_POOL_ATOMIC));
 +
 +	read_lock_irqsave(&pool->pool_lock, flags);
 +	if (pool->state != RXE_POOL_STATE_VALID) {
 +		read_unlock_irqrestore(&pool->pool_lock, flags);
 +		return -EINVAL;
 +	}
 +	kref_get(&pool->ref_cnt);
 +	read_unlock_irqrestore(&pool->pool_lock, flags);
 +
 +	if (!ib_device_try_get(&pool->rxe->ib_dev))
 +		goto out_put_pool;
 +
++=======
++>>>>>>> eae5f0642e2f (RDMA/rxe: Remove unneeded pool->state)
  	if (atomic_inc_return(&pool->num_elem) > pool->max_elem)
  		goto out_cnt;
  
@@@ -474,29 -417,30 +505,30 @@@ void *rxe_pool_get_index(struct rxe_poo
  			node = node->rb_left;
  		else if (elem->index < index)
  			node = node->rb_right;
 -		else
 +		else {
 +			kref_get(&elem->ref_cnt);
  			break;
 -	}
 -
 -	if (node) {
 -		kref_get(&elem->ref_cnt);
 -		obj = (u8 *)elem - info->elem_offset;
 -	} else {
 -		obj = NULL;
 +		}
  	}
  
- out:
  	read_unlock_irqrestore(&pool->pool_lock, flags);
++<<<<<<< HEAD
 +	return node ? elem : NULL;
++=======
+ 
+ 	return obj;
++>>>>>>> eae5f0642e2f (RDMA/rxe: Remove unneeded pool->state)
  }
  
 -void *rxe_pool_get_key_locked(struct rxe_pool *pool, void *key)
 +void *rxe_pool_get_key(struct rxe_pool *pool, void *key)
  {
 -	struct rxe_type_info *info = &rxe_type_info[pool->type];
 -	struct rb_node *node;
 -	struct rxe_pool_entry *elem;
 -	u8 *obj = NULL;
 +	struct rb_node *node = NULL;
 +	struct rxe_pool_entry *elem = NULL;
  	int cmp;
 +	unsigned long flags;
 +
 +	read_lock_irqsave(&pool->pool_lock, flags);
  
- 	if (pool->state != RXE_POOL_STATE_VALID)
- 		goto out;
- 
  	node = pool->key.tree.rb_node;
  
  	while (node) {
@@@ -513,10 -457,24 +545,23 @@@
  			break;
  	}
  
 -	if (node) {
 +	if (node)
  		kref_get(&elem->ref_cnt);
 -		obj = (u8 *)elem - info->elem_offset;
 -	} else {
 -		obj = NULL;
 -	}
  
++<<<<<<< HEAD
 +out:
++=======
+ 	return obj;
+ }
+ 
+ void *rxe_pool_get_key(struct rxe_pool *pool, void *key)
+ {
+ 	u8 *obj = NULL;
+ 	unsigned long flags;
+ 
+ 	read_lock_irqsave(&pool->pool_lock, flags);
+ 	obj = rxe_pool_get_key_locked(pool, key);
++>>>>>>> eae5f0642e2f (RDMA/rxe: Remove unneeded pool->state)
  	read_unlock_irqrestore(&pool->pool_lock, flags);
 -
 -	return obj;
 +	return node ? elem : NULL;
  }
* Unmerged path drivers/infiniband/sw/rxe/rxe_pool.c
diff --git a/drivers/infiniband/sw/rxe/rxe_pool.h b/drivers/infiniband/sw/rxe/rxe_pool.h
index e1a24bca99de..7ef4a31c1a6a 100644
--- a/drivers/infiniband/sw/rxe/rxe_pool.h
+++ b/drivers/infiniband/sw/rxe/rxe_pool.h
@@ -48,11 +48,6 @@ struct rxe_type_info {
 
 extern struct rxe_type_info rxe_type_info[];
 
-enum rxe_pool_state {
-	RXE_POOL_STATE_INVALID,
-	RXE_POOL_STATE_VALID,
-};
-
 struct rxe_pool_entry {
 	struct rxe_pool		*pool;
 	struct kref		ref_cnt;
@@ -72,7 +67,6 @@ struct rxe_pool {
 	size_t			elem_size;
 	struct kref		ref_cnt;
 	void			(*cleanup)(struct rxe_pool_entry *obj);
-	enum rxe_pool_state	state;
 	enum rxe_pool_flags	flags;
 	enum rxe_elem_type	type;
 
