block: integrate bd_start_claiming into __blkdev_get

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 5b642d8b9f2ef1212f33dfc337816e6b4ab83bb3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/5b642d8b.failed

bd_start_claiming duplicates a lot of the work done in __blkdev_get.
Integrate the two functions to avoid the duplicate work, and to do the
right thing for the md -ERESTARTSYS corner case.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Acked-by: Tejun Heo <tj@kernel.org>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 5b642d8b9f2ef1212f33dfc337816e6b4ab83bb3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/block_dev.c
diff --cc fs/block_dev.c
index f19cc879b480,3f94a06a0946..000000000000
--- a/fs/block_dev.c
+++ b/fs/block_dev.c
@@@ -1113,72 -1078,6 +1113,75 @@@ static struct gendisk *bdev_get_gendisk
  	return disk;
  }
  
++<<<<<<< HEAD
 +/**
 + * bd_start_claiming - start claiming a block device
 + * @bdev: block device of interest
 + * @holder: holder trying to claim @bdev
 + *
 + * @bdev is about to be opened exclusively.  Check @bdev can be opened
 + * exclusively and mark that an exclusive open is in progress.  Each
 + * successful call to this function must be matched with a call to
 + * either bd_finish_claiming() or bd_abort_claiming() (which do not
 + * fail).
 + *
 + * This function is used to gain exclusive access to the block device
 + * without actually causing other exclusive open attempts to fail. It
 + * should be used when the open sequence itself requires exclusive
 + * access but may subsequently fail.
 + *
 + * CONTEXT:
 + * Might sleep.
 + *
 + * RETURNS:
 + * Pointer to the block device containing @bdev on success, ERR_PTR()
 + * value on failure.
 + */
 +struct block_device *bd_start_claiming(struct block_device *bdev, void *holder)
 +{
 +	struct gendisk *disk;
 +	struct block_device *whole;
 +	int partno, err;
 +
 +	might_sleep();
 +
 +	/*
 +	 * @bdev might not have been initialized properly yet, look up
 +	 * and grab the outer block device the hard way.
 +	 */
 +	disk = bdev_get_gendisk(bdev, &partno);
 +	if (!disk)
 +		return ERR_PTR(-ENXIO);
 +
 +	/*
 +	 * Normally, @bdev should equal what's returned from bdget_disk()
 +	 * if partno is 0; however, some drivers (floppy) use multiple
 +	 * bdev's for the same physical device and @bdev may be one of the
 +	 * aliases.  Keep @bdev if partno is 0.  This means claimer
 +	 * tracking is broken for those devices but it has always been that
 +	 * way.
 +	 */
 +	if (partno)
 +		whole = bdget_disk(disk, 0);
 +	else
 +		whole = bdgrab(bdev);
 +
 +	put_disk_and_module(disk);
 +	if (!whole)
 +		return ERR_PTR(-ENOMEM);
 +
 +	err = bd_prepare_to_claim(bdev, whole, holder);
 +	if (err) {
 +		bdput(whole);
 +		return ERR_PTR(err);
 +	}
 +
 +	return whole;
 +}
 +EXPORT_SYMBOL(bd_start_claiming);
 +
++=======
++>>>>>>> 5b642d8b9f2e (block: integrate bd_start_claiming into __blkdev_get)
  static void bd_clear_claiming(struct block_device *whole, void *holder)
  {
  	lockdep_assert_held(&bdev_lock);
@@@ -1546,7 -1447,7 +1551,11 @@@ static int __blkdev_get(struct block_de
  	int ret;
  	int partno;
  	int perm = 0;
++<<<<<<< HEAD
 +	bool first_open = false;
++=======
+ 	bool first_open = false, unblock_events = true, need_restart;
++>>>>>>> 5b642d8b9f2e (block: integrate bd_start_claiming into __blkdev_get)
  
  	if (mode & FMODE_READ)
  		perm |= MAY_READ;
@@@ -1676,11 -1598,18 +1716,16 @@@
  		__blkdev_put(bdev->bd_contains, mode, 1);
  	bdev->bd_contains = NULL;
   out_unlock_bdev:
+ 	if (claiming)
+ 		bd_abort_claiming(bdev, claiming, holder);
  	mutex_unlock(&bdev->bd_mutex);
  	disk_unblock_events(disk);
+  out_put_whole:
+  	if (whole)
+ 		bdput(whole);
+  out_put_disk:
  	put_disk_and_module(disk);
 -	if (need_restart)
 -		goto restart;
   out:
- 
  	return ret;
  }
  
* Unmerged path fs/block_dev.c
