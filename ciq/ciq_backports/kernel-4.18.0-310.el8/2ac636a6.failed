KVM: nSVM: Add VMLOAD/VMSAVE helper to deduplicate code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Sean Christopherson <seanjc@google.com>
commit 2ac636a6ea4dae8260639e8df5c457c0c74cafa9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/2ac636a6.failed

Add another helper layer for VMLOAD+VMSAVE, the code is identical except
for the one line that determines which VMCB is the source and which is
the destination.

No functional change intended.

	Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20210205005750.3841462-5-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 2ac636a6ea4dae8260639e8df5c457c0c74cafa9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm/svm.c
diff --cc arch/x86/kvm/svm/svm.c
index 05deab5ed2e8,8e62b9988f10..000000000000
--- a/arch/x86/kvm/svm/svm.c
+++ b/arch/x86/kvm/svm/svm.c
@@@ -2049,19 -2108,20 +2049,23 @@@ static int nop_on_interception(struct v
  	return 1;
  }
  
 -static int halt_interception(struct kvm_vcpu *vcpu)
 +static int halt_interception(struct vcpu_svm *svm)
  {
 -	return kvm_emulate_halt(vcpu);
 +	return kvm_emulate_halt(&svm->vcpu);
  }
  
 -static int vmmcall_interception(struct kvm_vcpu *vcpu)
 +static int vmmcall_interception(struct vcpu_svm *svm)
  {
 -	return kvm_emulate_hypercall(vcpu);
 +	return kvm_emulate_hypercall(&svm->vcpu);
  }
  
++<<<<<<< HEAD
 +static int vmload_interception(struct vcpu_svm *svm)
++=======
+ static int vmload_vmsave_interception(struct kvm_vcpu *vcpu, bool vmload)
++>>>>>>> 2ac636a6ea4d (KVM: nSVM: Add VMLOAD/VMSAVE helper to deduplicate code)
  {
 -	struct vcpu_svm *svm = to_svm(vcpu);
 -	struct vmcb *vmcb12;
 +	struct vmcb *nested_vmcb;
  	struct kvm_host_map map;
  	int ret;
  
@@@ -2075,48 -2135,36 +2079,68 @@@
  		return 1;
  	}
  
 -	vmcb12 = map.hva;
 +	nested_vmcb = map.hva;
  
 -	ret = kvm_skip_emulated_instruction(vcpu);
 +	ret = kvm_skip_emulated_instruction(&svm->vcpu);
  
++<<<<<<< HEAD
 +	nested_svm_vmloadsave(nested_vmcb, svm->vmcb);
 +	kvm_vcpu_unmap(&svm->vcpu, &map, true);
++=======
+ 	if (vmload)
+ 		nested_svm_vmloadsave(vmcb12, svm->vmcb);
+ 	else
+ 		nested_svm_vmloadsave(svm->vmcb, vmcb12);
+ 
+ 	kvm_vcpu_unmap(vcpu, &map, true);
++>>>>>>> 2ac636a6ea4d (KVM: nSVM: Add VMLOAD/VMSAVE helper to deduplicate code)
  
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int vmsave_interception(struct vcpu_svm *svm)
 +{
 +	struct vmcb *nested_vmcb;
 +	struct kvm_host_map map;
 +	int ret;
 +
 +	if (nested_svm_check_permissions(svm))
 +		return 1;
 +
 +	ret = kvm_vcpu_map(&svm->vcpu, gpa_to_gfn(svm->vmcb->save.rax), &map);
 +	if (ret) {
 +		if (ret == -EINVAL)
 +			kvm_inject_gp(&svm->vcpu, 0);
 +		return 1;
 +	}
 +
 +	nested_vmcb = map.hva;
 +
 +	ret = kvm_skip_emulated_instruction(&svm->vcpu);
 +
 +	nested_svm_vmloadsave(svm->vmcb, nested_vmcb);
 +	kvm_vcpu_unmap(&svm->vcpu, &map, true);
 +
 +	return ret;
++=======
+ static int vmload_interception(struct kvm_vcpu *vcpu)
+ {
+ 	return vmload_vmsave_interception(vcpu, true);
+ }
+ 
+ static int vmsave_interception(struct kvm_vcpu *vcpu)
+ {
+ 	return vmload_vmsave_interception(vcpu, false);
++>>>>>>> 2ac636a6ea4d (KVM: nSVM: Add VMLOAD/VMSAVE helper to deduplicate code)
  }
  
 -static int vmrun_interception(struct kvm_vcpu *vcpu)
 +static int vmrun_interception(struct vcpu_svm *svm)
  {
 -	if (nested_svm_check_permissions(vcpu))
 +	if (nested_svm_check_permissions(svm))
  		return 1;
  
 -	return nested_svm_vmrun(vcpu);
 +	return nested_svm_vmrun(svm);
  }
  
  enum {
* Unmerged path arch/x86/kvm/svm/svm.c
