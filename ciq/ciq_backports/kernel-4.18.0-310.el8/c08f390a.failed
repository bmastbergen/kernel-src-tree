KVM: nSVM: only copy L1 non-VMLOAD/VMSAVE data in svm_set_nested_state()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit c08f390a75c14fb9f8115d74ae9b7a6142a659b3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/c08f390a.failed

The VMLOAD/VMSAVE data is not taken from userspace, since it will
not be restored on VMEXIT (it will be copied from VMCB02 to VMCB01).
For clarity, replace the wholesale copy of the VMCB save area
with a copy of that state only.

	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit c08f390a75c14fb9f8115d74ae9b7a6142a659b3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm/nested.c
diff --cc arch/x86/kvm/svm/nested.c
index 01d111af72de,56e6198d8f33..000000000000
--- a/arch/x86/kvm/svm/nested.c
+++ b/arch/x86/kvm/svm/nested.c
@@@ -664,24 -714,19 +664,40 @@@ int nested_svm_vmexit(struct vcpu_svm *
  
  	svm->nested.ctl.nested_cr3 = 0;
  
++<<<<<<< HEAD
 +	/* Restore selected save entries */
 +	svm->vmcb->save.es = hsave->save.es;
 +	svm->vmcb->save.cs = hsave->save.cs;
 +	svm->vmcb->save.ss = hsave->save.ss;
 +	svm->vmcb->save.ds = hsave->save.ds;
 +	svm->vmcb->save.gdtr = hsave->save.gdtr;
 +	svm->vmcb->save.idtr = hsave->save.idtr;
 +	kvm_set_rflags(&svm->vcpu, hsave->save.rflags);
 +	kvm_set_rflags(&svm->vcpu, hsave->save.rflags | X86_EFLAGS_FIXED);
 +	svm_set_efer(&svm->vcpu, hsave->save.efer);
 +	svm_set_cr0(&svm->vcpu, hsave->save.cr0 | X86_CR0_PE);
 +	svm_set_cr4(&svm->vcpu, hsave->save.cr4);
 +	kvm_rax_write(&svm->vcpu, hsave->save.rax);
 +	kvm_rsp_write(&svm->vcpu, hsave->save.rsp);
 +	kvm_rip_write(&svm->vcpu, hsave->save.rip);
 +	svm->vmcb->save.dr7 = DR7_FIXED_1;
 +	svm->vmcb->save.cpl = 0;
 +	svm->vmcb->control.exit_int_info = 0;
++=======
+ 	/*
+ 	 * Restore processor state that had been saved in vmcb01
+ 	 */
+ 	kvm_set_rflags(&svm->vcpu, svm->vmcb->save.rflags);
+ 	svm_set_efer(&svm->vcpu, svm->vmcb->save.efer);
+ 	svm_set_cr0(&svm->vcpu, svm->vmcb->save.cr0 | X86_CR0_PE);
+ 	svm_set_cr4(&svm->vcpu, svm->vmcb->save.cr4);
+ 	kvm_rax_write(&svm->vcpu, svm->vmcb->save.rax);
+ 	kvm_rsp_write(&svm->vcpu, svm->vmcb->save.rsp);
+ 	kvm_rip_write(&svm->vcpu, svm->vmcb->save.rip);
+ 
+ 	svm->vcpu.arch.dr7 = DR7_FIXED_1;
+ 	kvm_update_dr7(&svm->vcpu);
++>>>>>>> c08f390a75c1 (KVM: nSVM: only copy L1 non-VMLOAD/VMSAVE data in svm_set_nested_state())
  
  	trace_kvm_nested_vmexit_inject(vmcb12->control.exit_code,
  				       vmcb12->control.exit_info_1,
@@@ -1209,12 -1249,31 +1225,39 @@@ static int svm_set_nested_state(struct 
  	svm->nested.nested_run_pending =
  		!!(kvm_state->flags & KVM_STATE_NESTED_RUN_PENDING);
  
 +	copy_vmcb_control_area(&hsave->control, &svm->vmcb->control);
 +	hsave->save = *save;
 +
  	svm->nested.vmcb12_gpa = kvm_state->hdr.svm.vmcb_pa;
++<<<<<<< HEAD
 +	load_nested_vmcb_control(svm, ctl);
 +	nested_prepare_vmcb_control(svm);
++=======
+ 	if (svm->current_vmcb == &svm->vmcb01)
+ 		svm->nested.vmcb02.ptr->save = svm->vmcb01.ptr->save;
+ 
+ 	svm->vmcb01.ptr->save.es = save->es;
+ 	svm->vmcb01.ptr->save.cs = save->cs;
+ 	svm->vmcb01.ptr->save.ss = save->ss;
+ 	svm->vmcb01.ptr->save.ds = save->ds;
+ 	svm->vmcb01.ptr->save.gdtr = save->gdtr;
+ 	svm->vmcb01.ptr->save.idtr = save->idtr;
+ 	svm->vmcb01.ptr->save.rflags = save->rflags | X86_EFLAGS_FIXED;
+ 	svm->vmcb01.ptr->save.efer = save->efer;
+ 	svm->vmcb01.ptr->save.cr0 = save->cr0;
+ 	svm->vmcb01.ptr->save.cr3 = save->cr3;
+ 	svm->vmcb01.ptr->save.cr4 = save->cr4;
+ 	svm->vmcb01.ptr->save.rax = save->rax;
+ 	svm->vmcb01.ptr->save.rsp = save->rsp;
+ 	svm->vmcb01.ptr->save.rip = save->rip;
+ 	svm->vmcb01.ptr->save.cpl = 0;
+ 
+ 	nested_load_control_from_vmcb12(svm, ctl);
+ 
+ 	svm_switch_vmcb(svm, &svm->nested.vmcb02);
+ 
+ 	nested_vmcb02_prepare_control(svm);
++>>>>>>> c08f390a75c1 (KVM: nSVM: only copy L1 non-VMLOAD/VMSAVE data in svm_set_nested_state())
  
  	kvm_make_request(KVM_REQ_GET_NESTED_STATE_PAGES, vcpu);
  	ret = 0;
* Unmerged path arch/x86/kvm/svm/nested.c
