sched,rcu,tracing: Avoid tracing before in_nmi() is correct

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Peter Zijlstra <peterz@infradead.org>
commit f93524eb9c54f49be150167918f6546b0a2e09b1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/f93524eb.failed

If a tracer is invoked before in_nmi() becomes true, the tracer can no
longer detect it is called from NMI context and behave correctly.

Therefore change nmi_{enter,exit}() to use __preempt_count_{add,sub}()
as the normal preempt_count_{add,sub}() have a (desired) function
trace entry.

This fixes a potential issue with the current code; when the function-tracer
has stack-tracing enabled __trace_stack() will malfunction when it hits the
preempt_count_add() function entry from NMI context.

	Suggested-by: Steven Rostedt (VMware) <rosted@goodmis.org>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
	Reviewed-by: Alexandre Chartre <alexandre.chartre@oracle.com>
Link: https://lkml.kernel.org/r/20200505134101.434193525@linutronix.de


(cherry picked from commit f93524eb9c54f49be150167918f6546b0a2e09b1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/hardirq.h
diff --cc include/linux/hardirq.h
index 7c8b82f69288,621556efe45f..000000000000
--- a/include/linux/hardirq.h
+++ b/include/linux/hardirq.h
@@@ -65,14 -65,26 +65,34 @@@ extern void irq_exit(void)
  #define arch_nmi_exit()		do { } while (0)
  #endif
  
++<<<<<<< HEAD
++=======
+ /*
+  * NMI vs Tracing
+  * --------------
+  *
+  * We must not land in a tracer until (or after) we've changed preempt_count
+  * such that in_nmi() becomes true. To that effect all NMI C entry points must
+  * be marked 'notrace' and call nmi_enter() as soon as possible.
+  */
+ 
+ /*
+  * nmi_enter() can nest up to 15 times; see NMI_BITS.
+  */
++>>>>>>> f93524eb9c54 (sched,rcu,tracing: Avoid tracing before in_nmi() is correct)
  #define nmi_enter()						\
  	do {							\
  		arch_nmi_enter();				\
  		printk_nmi_enter();				\
  		lockdep_off();					\
  		ftrace_nmi_enter();				\
++<<<<<<< HEAD
 +		BUG_ON(in_nmi());				\
 +		preempt_count_add(NMI_OFFSET + HARDIRQ_OFFSET);	\
++=======
+ 		BUG_ON(in_nmi() == NMI_MASK);			\
+ 		__preempt_count_add(NMI_OFFSET + HARDIRQ_OFFSET);	\
++>>>>>>> f93524eb9c54 (sched,rcu,tracing: Avoid tracing before in_nmi() is correct)
  		rcu_nmi_enter();				\
  		lockdep_hardirq_enter();			\
  	} while (0)
* Unmerged path include/linux/hardirq.h
