KVM: SVM: Don't manually emulate RDPMC if nrips=0

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Sean Christopherson <seanjc@google.com>
commit 32c23c7d5275d41818807801be44cbba03045fc8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/32c23c7d.failed

Remove bizarre code that causes KVM to run RDPMC through the emulator
when nrips is disabled.  Accelerated emulation of RDPMC doesn't rely on
any additional data from the VMCB, and SVM has generic handling for
updating RIP to skip instructions when nrips is disabled.

	Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20210205005750.3841462-9-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 32c23c7d5275d41818807801be44cbba03045fc8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm/svm.c
diff --cc arch/x86/kvm/svm/svm.c
index 05deab5ed2e8,100cf2419587..000000000000
--- a/arch/x86/kvm/svm/svm.c
+++ b/arch/x86/kvm/svm/svm.c
@@@ -2399,49 -2403,33 +2399,53 @@@ static int iret_interception(struct vcp
  	return 1;
  }
  
 -static int invlpg_interception(struct kvm_vcpu *vcpu)
 +static int invd_interception(struct vcpu_svm *svm)
 +{
 +	/* Treat an INVD instruction as a NOP and just skip it. */
 +	return kvm_skip_emulated_instruction(&svm->vcpu);
 +}
 +
 +static int invlpg_interception(struct vcpu_svm *svm)
  {
  	if (!static_cpu_has(X86_FEATURE_DECODEASSISTS))
 -		return kvm_emulate_instruction(vcpu, 0);
 +		return kvm_emulate_instruction(&svm->vcpu, 0);
 +
 +	kvm_mmu_invlpg(&svm->vcpu, svm->vmcb->control.exit_info_1);
 +	return kvm_skip_emulated_instruction(&svm->vcpu);
 +}
  
 -	kvm_mmu_invlpg(vcpu, to_svm(vcpu)->vmcb->control.exit_info_1);
 -	return kvm_skip_emulated_instruction(vcpu);
 +static int emulate_on_interception(struct vcpu_svm *svm)
 +{
 +	return kvm_emulate_instruction(&svm->vcpu, 0);
  }
  
 -static int emulate_on_interception(struct kvm_vcpu *vcpu)
 +static int rsm_interception(struct vcpu_svm *svm)
  {
 -	return kvm_emulate_instruction(vcpu, 0);
 +	return kvm_emulate_instruction_from_buffer(&svm->vcpu, rsm_ins_bytes, 2);
  }
  
 -static int rsm_interception(struct kvm_vcpu *vcpu)
++<<<<<<< HEAD
 +static int rdpmc_interception(struct vcpu_svm *svm)
  {
 -	return kvm_emulate_instruction_from_buffer(vcpu, rsm_ins_bytes, 2);
 +	int err;
 +
 +	if (!nrips)
 +		return emulate_on_interception(svm);
 +
 +	err = kvm_rdpmc(&svm->vcpu);
 +	return kvm_complete_insn_gp(&svm->vcpu, err);
  }
  
 +static bool check_selective_cr0_intercepted(struct vcpu_svm *svm,
++=======
+ static bool check_selective_cr0_intercepted(struct kvm_vcpu *vcpu,
++>>>>>>> 32c23c7d5275 (KVM: SVM: Don't manually emulate RDPMC if nrips=0)
  					    unsigned long val)
  {
 -	struct vcpu_svm *svm = to_svm(vcpu);
 -	unsigned long cr0 = vcpu->arch.cr0;
 +	unsigned long cr0 = svm->vcpu.arch.cr0;
  	bool ret = false;
  
 -	if (!is_guest_mode(vcpu) ||
 +	if (!is_guest_mode(&svm->vcpu) ||
  	    (!(vmcb_is_intercept(&svm->nested.ctl, INTERCEPT_SELECTIVE_CR0))))
  		return false;
  
@@@ -3061,15 -3045,15 +3065,20 @@@ static int (*const svm_exit_handlers[])
  	[SVM_EXIT_EXCP_BASE + GP_VECTOR]	= gp_interception,
  	[SVM_EXIT_INTR]				= intr_interception,
  	[SVM_EXIT_NMI]				= nmi_interception,
 -	[SVM_EXIT_SMI]				= kvm_emulate_as_nop,
 -	[SVM_EXIT_INIT]				= kvm_emulate_as_nop,
 +	[SVM_EXIT_SMI]				= nop_on_interception,
 +	[SVM_EXIT_INIT]				= nop_on_interception,
  	[SVM_EXIT_VINTR]			= interrupt_window_interception,
++<<<<<<< HEAD
 +	[SVM_EXIT_RDPMC]			= rdpmc_interception,
 +	[SVM_EXIT_CPUID]			= cpuid_interception,
++=======
+ 	[SVM_EXIT_RDPMC]			= kvm_emulate_rdpmc,
+ 	[SVM_EXIT_CPUID]			= kvm_emulate_cpuid,
++>>>>>>> 32c23c7d5275 (KVM: SVM: Don't manually emulate RDPMC if nrips=0)
  	[SVM_EXIT_IRET]                         = iret_interception,
 -	[SVM_EXIT_INVD]                         = kvm_emulate_invd,
 +	[SVM_EXIT_INVD]                         = invd_interception,
  	[SVM_EXIT_PAUSE]			= pause_interception,
 -	[SVM_EXIT_HLT]				= kvm_emulate_halt,
 +	[SVM_EXIT_HLT]				= halt_interception,
  	[SVM_EXIT_INVLPG]			= invlpg_interception,
  	[SVM_EXIT_INVLPGA]			= invlpga_interception,
  	[SVM_EXIT_IOIO]				= io_interception,
* Unmerged path arch/x86/kvm/svm/svm.c
