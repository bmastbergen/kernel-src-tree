vmxnet3: Remove buf_info from device accessible structures

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Ronak Doshi <doshir@vmware.com>
commit de1da8bcf40564a2adada2d5d5426e05355f66e8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/de1da8bc.failed

buf_info structures in RX & TX queues are private driver data that
do not need to be visible to the device.  Although there is physical
address and length in the queue descriptor that points to these
structures, their layout is not standardized, and device never looks
at them.

So lets allocate these structures in non-DMA-able memory, and fill
physical address as all-ones and length as zero in the queue
descriptor.

That should alleviate worries brought by Martin Radev in
https://lists.osuosl.org/pipermail/intel-wired-lan/Week-of-Mon-20210104/022829.html
that malicious vmxnet3 device could subvert SVM/TDX guarantees.

	Signed-off-by: Petr Vandrovec <petr@vmware.com>
	Signed-off-by: Ronak Doshi <doshir@vmware.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit de1da8bcf40564a2adada2d5d5426e05355f66e8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vmxnet3/vmxnet3_drv.c
diff --cc drivers/net/vmxnet3/vmxnet3_drv.c
index 55770c7bc237,6e87f1fc4874..000000000000
--- a/drivers/net/vmxnet3/vmxnet3_drv.c
+++ b/drivers/net/vmxnet3/vmxnet3_drv.c
@@@ -534,9 -528,9 +528,15 @@@ vmxnet3_tq_create(struct vmxnet3_tx_que
  		goto err;
  	}
  
++<<<<<<< HEAD
 +	sz = tq->tx_ring.size * sizeof(tq->buf_info[0]);
 +	tq->buf_info = dma_zalloc_coherent(&adapter->pdev->dev, sz,
 +					   &tq->buf_info_pa, GFP_KERNEL);
++=======
+ 	tq->buf_info = kcalloc_node(tq->tx_ring.size, sizeof(tq->buf_info[0]),
+ 				    GFP_KERNEL,
+ 				    dev_to_node(&adapter->pdev->dev));
++>>>>>>> de1da8bcf405 (vmxnet3: Remove buf_info from device accessible structures)
  	if (!tq->buf_info)
  		goto err;
  
@@@ -1884,10 -1873,9 +1880,16 @@@ vmxnet3_rq_create(struct vmxnet3_rx_que
  		goto err;
  	}
  
++<<<<<<< HEAD
 +	sz = sizeof(struct vmxnet3_rx_buf_info) * (rq->rx_ring[0].size +
 +						   rq->rx_ring[1].size);
 +	bi = dma_zalloc_coherent(&adapter->pdev->dev, sz, &rq->buf_info_pa,
 +				 GFP_KERNEL);
++=======
+ 	bi = kcalloc_node(rq->rx_ring[0].size + rq->rx_ring[1].size,
+ 			  sizeof(rq->buf_info[0][0]), GFP_KERNEL,
+ 			  dev_to_node(&adapter->pdev->dev));
++>>>>>>> de1da8bcf405 (vmxnet3: Remove buf_info from device accessible structures)
  	if (!bi)
  		goto err;
  
* Unmerged path drivers/net/vmxnet3/vmxnet3_drv.c
diff --git a/drivers/net/vmxnet3/vmxnet3_int.h b/drivers/net/vmxnet3/vmxnet3_int.h
index d958b92c9429..e910596b79cf 100644
--- a/drivers/net/vmxnet3/vmxnet3_int.h
+++ b/drivers/net/vmxnet3/vmxnet3_int.h
@@ -240,7 +240,6 @@ struct vmxnet3_tx_queue {
 	spinlock_t                      tx_lock;
 	struct vmxnet3_cmd_ring         tx_ring;
 	struct vmxnet3_tx_buf_info      *buf_info;
-	dma_addr_t                       buf_info_pa;
 	struct vmxnet3_tx_data_ring     data_ring;
 	struct vmxnet3_comp_ring        comp_ring;
 	struct Vmxnet3_TxQueueCtrl      *shared;
@@ -298,7 +297,6 @@ struct vmxnet3_rx_queue {
 	u32 qid2;           /* rqID in RCD for buffer from 2nd ring */
 	u32 dataRingQid;    /* rqID in RCD for buffer from data ring */
 	struct vmxnet3_rx_buf_info     *buf_info[2];
-	dma_addr_t                      buf_info_pa;
 	struct Vmxnet3_RxQueueCtrl            *shared;
 	struct vmxnet3_rq_driver_stats  stats;
 } __attribute__((__aligned__(SMP_CACHE_BYTES)));
