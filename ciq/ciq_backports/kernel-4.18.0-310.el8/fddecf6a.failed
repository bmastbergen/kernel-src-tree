KVM: SVM: Add KVM_SEV_SEND_FINISH command

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Brijesh Singh <brijesh.singh@amd.com>
commit fddecf6a237ee464db7a1771fad6507d8c180c03
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/fddecf6a.failed

The command is used to finailize the encryption context created with
KVM_SEV_SEND_START command.

	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Cc: Joerg Roedel <joro@8bytes.org>
	Cc: Borislav Petkov <bp@suse.de>
	Cc: Tom Lendacky <thomas.lendacky@amd.com>
	Cc: x86@kernel.org
	Cc: kvm@vger.kernel.org
	Cc: linux-kernel@vger.kernel.org
	Reviewed-by: Steve Rutherford <srutherford@google.com>
	Signed-off-by: Brijesh Singh <brijesh.singh@amd.com>
	Signed-off-by: Ashish Kalra <ashish.kalra@amd.com>
Message-Id: <5082bd6a8539d24bc55a1dd63a1b341245bb168f.1618498113.git.ashish.kalra@amd.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit fddecf6a237ee464db7a1771fad6507d8c180c03)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/virt/kvm/amd-memory-encryption.rst
#	arch/x86/kvm/svm/sev.c
diff --cc Documentation/virt/kvm/amd-memory-encryption.rst
index 625ce89c7706,03f2518cfbeb..000000000000
--- a/Documentation/virt/kvm/amd-memory-encryption.rst
+++ b/Documentation/virt/kvm/amd-memory-encryption.rst
@@@ -314,6 -320,42 +314,45 @@@ Returns: 0 on success, -negative on err
                  __u32 session_len;
          };
  
++<<<<<<< HEAD
++=======
+ 12. KVM_SEV_SEND_UPDATE_DATA
+ ----------------------------
+ 
+ The KVM_SEV_SEND_UPDATE_DATA command can be used by the hypervisor to encrypt the
+ outgoing guest memory region with the encryption context creating using
+ KVM_SEV_SEND_START.
+ 
+ If hdr_len or trans_len are zero on entry, the length of the packet header and
+ transport region are written to hdr_len and trans_len respectively, and all
+ other fields are not used.
+ 
+ Parameters (in): struct kvm_sev_send_update_data
+ 
+ Returns: 0 on success, -negative on error
+ 
+ ::
+ 
+         struct kvm_sev_launch_send_update_data {
+                 __u64 hdr_uaddr;        /* userspace address containing the packet header */
+                 __u32 hdr_len;
+ 
+                 __u64 guest_uaddr;      /* the source memory region to be encrypted */
+                 __u32 guest_len;
+ 
+                 __u64 trans_uaddr;      /* the destination memory region  */
+                 __u32 trans_len;
+         };
+ 
+ 13. KVM_SEV_SEND_FINISH
+ ------------------------
+ 
+ After completion of the migration flow, the KVM_SEV_SEND_FINISH command can be
+ issued by the hypervisor to delete the encryption context.
+ 
+ Returns: 0 on success, -negative on error
+ 
++>>>>>>> fddecf6a237e (KVM: SVM: Add KVM_SEV_SEND_FINISH command)
  References
  ==========
  
diff --cc arch/x86/kvm/svm/sev.c
index fbe9a30eb1a6,f25c52a2dc14..000000000000
--- a/arch/x86/kvm/svm/sev.c
+++ b/arch/x86/kvm/svm/sev.c
@@@ -1221,6 -1237,146 +1221,149 @@@ e_free_session
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ /* Userspace wants to query either header or trans length. */
+ static int
+ __sev_send_update_data_query_lengths(struct kvm *kvm, struct kvm_sev_cmd *argp,
+ 				     struct kvm_sev_send_update_data *params)
+ {
+ 	struct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;
+ 	struct sev_data_send_update_data *data;
+ 	int ret;
+ 
+ 	data = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);
+ 	if (!data)
+ 		return -ENOMEM;
+ 
+ 	data->handle = sev->handle;
+ 	ret = sev_issue_cmd(kvm, SEV_CMD_SEND_UPDATE_DATA, data, &argp->error);
+ 	if (ret < 0)
+ 		goto out;
+ 
+ 	params->hdr_len = data->hdr_len;
+ 	params->trans_len = data->trans_len;
+ 
+ 	if (copy_to_user((void __user *)(uintptr_t)argp->data, params,
+ 			 sizeof(struct kvm_sev_send_update_data)))
+ 		ret = -EFAULT;
+ 
+ out:
+ 	kfree(data);
+ 	return ret;
+ }
+ 
+ static int sev_send_update_data(struct kvm *kvm, struct kvm_sev_cmd *argp)
+ {
+ 	struct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;
+ 	struct sev_data_send_update_data *data;
+ 	struct kvm_sev_send_update_data params;
+ 	void *hdr, *trans_data;
+ 	struct page **guest_page;
+ 	unsigned long n;
+ 	int ret, offset;
+ 
+ 	if (!sev_guest(kvm))
+ 		return -ENOTTY;
+ 
+ 	if (copy_from_user(&params, (void __user *)(uintptr_t)argp->data,
+ 			sizeof(struct kvm_sev_send_update_data)))
+ 		return -EFAULT;
+ 
+ 	/* userspace wants to query either header or trans length */
+ 	if (!params.trans_len || !params.hdr_len)
+ 		return __sev_send_update_data_query_lengths(kvm, argp, &params);
+ 
+ 	if (!params.trans_uaddr || !params.guest_uaddr ||
+ 	    !params.guest_len || !params.hdr_uaddr)
+ 		return -EINVAL;
+ 
+ 	/* Check if we are crossing the page boundary */
+ 	offset = params.guest_uaddr & (PAGE_SIZE - 1);
+ 	if ((params.guest_len + offset > PAGE_SIZE))
+ 		return -EINVAL;
+ 
+ 	/* Pin guest memory */
+ 	guest_page = sev_pin_memory(kvm, params.guest_uaddr & PAGE_MASK,
+ 				    PAGE_SIZE, &n, 0);
+ 	if (!guest_page)
+ 		return -EFAULT;
+ 
+ 	/* allocate memory for header and transport buffer */
+ 	ret = -ENOMEM;
+ 	hdr = kmalloc(params.hdr_len, GFP_KERNEL_ACCOUNT);
+ 	if (!hdr)
+ 		goto e_unpin;
+ 
+ 	trans_data = kmalloc(params.trans_len, GFP_KERNEL_ACCOUNT);
+ 	if (!trans_data)
+ 		goto e_free_hdr;
+ 
+ 	data = kzalloc(sizeof(*data), GFP_KERNEL);
+ 	if (!data)
+ 		goto e_free_trans_data;
+ 
+ 	data->hdr_address = __psp_pa(hdr);
+ 	data->hdr_len = params.hdr_len;
+ 	data->trans_address = __psp_pa(trans_data);
+ 	data->trans_len = params.trans_len;
+ 
+ 	/* The SEND_UPDATE_DATA command requires C-bit to be always set. */
+ 	data->guest_address = (page_to_pfn(guest_page[0]) << PAGE_SHIFT) +
+ 				offset;
+ 	data->guest_address |= sev_me_mask;
+ 	data->guest_len = params.guest_len;
+ 	data->handle = sev->handle;
+ 
+ 	ret = sev_issue_cmd(kvm, SEV_CMD_SEND_UPDATE_DATA, data, &argp->error);
+ 
+ 	if (ret)
+ 		goto e_free;
+ 
+ 	/* copy transport buffer to user space */
+ 	if (copy_to_user((void __user *)(uintptr_t)params.trans_uaddr,
+ 			 trans_data, params.trans_len)) {
+ 		ret = -EFAULT;
+ 		goto e_free;
+ 	}
+ 
+ 	/* Copy packet header to userspace. */
+ 	ret = copy_to_user((void __user *)(uintptr_t)params.hdr_uaddr, hdr,
+ 				params.hdr_len);
+ 
+ e_free:
+ 	kfree(data);
+ e_free_trans_data:
+ 	kfree(trans_data);
+ e_free_hdr:
+ 	kfree(hdr);
+ e_unpin:
+ 	sev_unpin_memory(kvm, guest_page, n);
+ 
+ 	return ret;
+ }
+ 
+ static int sev_send_finish(struct kvm *kvm, struct kvm_sev_cmd *argp)
+ {
+ 	struct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;
+ 	struct sev_data_send_finish *data;
+ 	int ret;
+ 
+ 	if (!sev_guest(kvm))
+ 		return -ENOTTY;
+ 
+ 	data = kzalloc(sizeof(*data), GFP_KERNEL);
+ 	if (!data)
+ 		return -ENOMEM;
+ 
+ 	data->handle = sev->handle;
+ 	ret = sev_issue_cmd(kvm, SEV_CMD_SEND_FINISH, data, &argp->error);
+ 
+ 	kfree(data);
+ 	return ret;
+ }
+ 
++>>>>>>> fddecf6a237e (KVM: SVM: Add KVM_SEV_SEND_FINISH command)
  int svm_mem_enc_op(struct kvm *kvm, void __user *argp)
  {
  	struct kvm_sev_cmd sev_cmd;
@@@ -1280,6 -1442,12 +1423,15 @@@
  	case KVM_SEV_SEND_START:
  		r = sev_send_start(kvm, &sev_cmd);
  		break;
++<<<<<<< HEAD
++=======
+ 	case KVM_SEV_SEND_UPDATE_DATA:
+ 		r = sev_send_update_data(kvm, &sev_cmd);
+ 		break;
+ 	case KVM_SEV_SEND_FINISH:
+ 		r = sev_send_finish(kvm, &sev_cmd);
+ 		break;
++>>>>>>> fddecf6a237e (KVM: SVM: Add KVM_SEV_SEND_FINISH command)
  	default:
  		r = -EINVAL;
  		goto out;
* Unmerged path Documentation/virt/kvm/amd-memory-encryption.rst
* Unmerged path arch/x86/kvm/svm/sev.c
