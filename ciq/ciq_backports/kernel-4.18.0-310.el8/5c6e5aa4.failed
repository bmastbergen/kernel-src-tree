cifs: move security mount options into fs_context.ch

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Ronnie Sahlberg <lsahlber@redhat.com>
commit 5c6e5aa496804451fc94d00a7cf9be2e3051ae29
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/5c6e5aa4.failed

This patch moves the parsing of security mount options into
fs_context.ch.  There are no changes to any logic.

	Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
	Reviewed-by: Aurelien Aptel <aaptel@suse.com>
(cherry picked from commit 5c6e5aa496804451fc94d00a7cf9be2e3051ae29)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/connect.c
diff --cc fs/cifs/connect.c
index d324a8f1409c,c2a92e26fef4..000000000000
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@@ -1372,63 -1346,6 +1346,66 @@@ static int get_option_gid(substring_t a
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int cifs_parse_security_flavors(char *value,
 +				       struct smb_vol *vol)
 +{
 +
 +	substring_t args[MAX_OPT_ARGS];
 +
 +	/*
 +	 * With mount options, the last one should win. Reset any existing
 +	 * settings back to default.
 +	 */
 +	vol->sectype = Unspecified;
 +	vol->sign = false;
 +
 +	switch (match_token(value, cifs_secflavor_tokens, args)) {
 +	case Opt_sec_krb5p:
 +		cifs_dbg(VFS, "sec=krb5p is not supported!\n");
 +		return 1;
 +	case Opt_sec_krb5i:
 +		vol->sign = true;
 +		/* Fallthrough */
 +	case Opt_sec_krb5:
 +		vol->sectype = Kerberos;
 +		break;
 +	case Opt_sec_ntlmsspi:
 +		vol->sign = true;
 +		/* Fallthrough */
 +	case Opt_sec_ntlmssp:
 +		vol->sectype = RawNTLMSSP;
 +		break;
 +	case Opt_sec_ntlmi:
 +		vol->sign = true;
 +		/* Fallthrough */
 +	case Opt_ntlm:
 +		vol->sectype = NTLM;
 +		break;
 +	case Opt_sec_ntlmv2i:
 +		vol->sign = true;
 +		/* Fallthrough */
 +	case Opt_sec_ntlmv2:
 +		vol->sectype = NTLMv2;
 +		break;
 +#ifdef CONFIG_CIFS_WEAK_PW_HASH
 +	case Opt_sec_lanman:
 +		vol->sectype = LANMAN;
 +		break;
 +#endif
 +	case Opt_sec_none:
 +		vol->nullauth = 1;
 +		break;
 +	default:
 +		cifs_dbg(VFS, "bad security option: %s\n", value);
 +		return 1;
 +	}
 +
 +	return 0;
 +}
 +
++=======
++>>>>>>> 5c6e5aa49680 (cifs: move security mount options into fs_context.ch)
  static int
  cifs_parse_cache_flavor(char *value, struct smb_vol *vol)
  {
* Unmerged path fs/cifs/connect.c
diff --git a/fs/cifs/fs_context.c b/fs/cifs/fs_context.c
index f50dfc2d2e44..dd9da734e346 100644
--- a/fs/cifs/fs_context.c
+++ b/fs/cifs/fs_context.c
@@ -6,3 +6,79 @@
  *              David Howells <dhowells@redhat.com>
  */
 
+#include "cifsglob.h"
+#include "cifs_debug.h"
+#include "fs_context.h"
+
+static const match_table_t cifs_secflavor_tokens = {
+	{ Opt_sec_krb5, "krb5" },
+	{ Opt_sec_krb5i, "krb5i" },
+	{ Opt_sec_krb5p, "krb5p" },
+	{ Opt_sec_ntlmsspi, "ntlmsspi" },
+	{ Opt_sec_ntlmssp, "ntlmssp" },
+	{ Opt_ntlm, "ntlm" },
+	{ Opt_sec_ntlmi, "ntlmi" },
+	{ Opt_sec_ntlmv2, "nontlm" },
+	{ Opt_sec_ntlmv2, "ntlmv2" },
+	{ Opt_sec_ntlmv2i, "ntlmv2i" },
+	{ Opt_sec_lanman, "lanman" },
+	{ Opt_sec_none, "none" },
+
+	{ Opt_sec_err, NULL }
+};
+
+int cifs_parse_security_flavors(char *value, struct smb_vol *vol)
+{
+
+	substring_t args[MAX_OPT_ARGS];
+
+	/*
+	 * With mount options, the last one should win. Reset any existing
+	 * settings back to default.
+	 */
+	vol->sectype = Unspecified;
+	vol->sign = false;
+
+	switch (match_token(value, cifs_secflavor_tokens, args)) {
+	case Opt_sec_krb5p:
+		cifs_dbg(VFS, "sec=krb5p is not supported!\n");
+		return 1;
+	case Opt_sec_krb5i:
+		vol->sign = true;
+		fallthrough;
+	case Opt_sec_krb5:
+		vol->sectype = Kerberos;
+		break;
+	case Opt_sec_ntlmsspi:
+		vol->sign = true;
+		fallthrough;
+	case Opt_sec_ntlmssp:
+		vol->sectype = RawNTLMSSP;
+		break;
+	case Opt_sec_ntlmi:
+		vol->sign = true;
+		fallthrough;
+	case Opt_ntlm:
+		vol->sectype = NTLM;
+		break;
+	case Opt_sec_ntlmv2i:
+		vol->sign = true;
+		fallthrough;
+	case Opt_sec_ntlmv2:
+		vol->sectype = NTLMv2;
+		break;
+#ifdef CONFIG_CIFS_WEAK_PW_HASH
+	case Opt_sec_lanman:
+		vol->sectype = LANMAN;
+		break;
+#endif
+	case Opt_sec_none:
+		vol->nullauth = 1;
+		break;
+	default:
+		cifs_dbg(VFS, "bad security option: %s\n", value);
+		return 1;
+	}
+
+	return 0;
+}
diff --git a/fs/cifs/fs_context.h b/fs/cifs/fs_context.h
index 082f286f923e..87747ef7a2d3 100644
--- a/fs/cifs/fs_context.h
+++ b/fs/cifs/fs_context.h
@@ -9,7 +9,25 @@
 #ifndef _FS_CONTEXT_H
 #define _FS_CONTEXT_H
 
+#include <linux/parser.h>
+#include "cifsglob.h"
 
+enum cifs_sec_param {
+	Opt_sec_krb5,
+	Opt_sec_krb5i,
+	Opt_sec_krb5p,
+	Opt_sec_ntlmsspi,
+	Opt_sec_ntlmssp,
+	Opt_ntlm,
+	Opt_sec_ntlmi,
+	Opt_sec_ntlmv2,
+	Opt_sec_ntlmv2i,
+	Opt_sec_lanman,
+	Opt_sec_none,
 
-#endif
+	Opt_sec_err
+};
+
+int cifs_parse_security_flavors(char *value, struct smb_vol *vol);
 
+#endif
