NFSD: Hoist status code encoding into XDR encoder functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit cc028a10a48c3c555d7772d02f56eea9f86fdf79
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/cc028a10.failed

The original intent was presumably to reduce code duplication. The
trade-off was:

- No support for an NFSD proc function returning a non-success
  RPC accept_stat value.
- No support for void NFS replies to non-NULL procedures.
- Everyone pays for the deduplication with a few extra conditional
  branches in a hot path.

In addition, nfsd_dispatch() leaves *statp uninitialized in the
success path, unlike svc_generic_dispatch().

Address all of these problems by moving the logic for encoding
the NFS status code into the NFS XDR encoders themselves. Then
update the NFS .pc_func methods to return an RPC accept_stat
value.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit cc028a10a48c3c555d7772d02f56eea9f86fdf79)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs2acl.c
#	fs/nfsd/nfs3acl.c
#	fs/nfsd/nfs3proc.c
#	fs/nfsd/nfsproc.c
#	fs/nfsd/nfssvc.c
#	fs/nfsd/nfsxdr.c
diff --cc fs/nfsd/nfs2acl.c
index 3c8b9250dc4a,6a900f770dd2..000000000000
--- a/fs/nfsd/nfs2acl.c
+++ b/fs/nfsd/nfs2acl.c
@@@ -78,7 -78,8 +78,12 @@@ static __be32 nfsacld_proc_getacl(struc
  	}
  
  	/* resp->acl_{access,default} are released in nfssvc_release_getacl. */
++<<<<<<< HEAD
 +	RETURN_STATUS(0);
++=======
+ out:
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  
  fail:
  	posix_acl_release(resp->acl_access);
@@@ -131,7 -131,8 +136,12 @@@ out
  	   nfssvc_decode_setaclargs. */
  	posix_acl_release(argp->acl_access);
  	posix_acl_release(argp->acl_default);
++<<<<<<< HEAD
 +	return nfserr;
++=======
+ 	return rpc_success;
+ 
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  out_drop_lock:
  	fh_unlock(fh);
  	fh_drop_write(fh);
@@@ -151,11 -152,12 +161,20 @@@ static __be32 nfsacld_proc_getattr(stru
  	dprintk("nfsd: GETATTR  %s\n", SVCFH_fmt(&argp->fh));
  
  	fh_copy(&resp->fh, &argp->fh);
++<<<<<<< HEAD
 +	nfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_NOP);
 +	if (nfserr)
 +		return nfserr;
 +	nfserr = fh_getattr(&resp->fh, &resp->stat);
 +	return nfserr;
++=======
+ 	resp->status = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_NOP);
+ 	if (resp->status != nfs_ok)
+ 		goto out;
+ 	resp->status = fh_getattr(&resp->fh, &resp->stat);
+ out:
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /*
@@@ -173,11 -174,12 +192,20 @@@ static __be32 nfsacld_proc_access(struc
  
  	fh_copy(&resp->fh, &argp->fh);
  	resp->access = argp->access;
++<<<<<<< HEAD
 +	nfserr = nfsd_access(rqstp, &resp->fh, &resp->access, NULL);
 +	if (nfserr)
 +		return nfserr;
 +	nfserr = fh_getattr(&resp->fh, &resp->stat);
 +	return nfserr;
++=======
+ 	resp->status = nfsd_access(rqstp, &resp->fh, &resp->access, NULL);
+ 	if (resp->status != nfs_ok)
+ 		goto out;
+ 	resp->status = fh_getattr(&resp->fh, &resp->stat);
+ out:
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /*
@@@ -273,6 -275,10 +301,13 @@@ static int nfsaclsvc_encode_getaclres(s
  	int n;
  	int w;
  
++<<<<<<< HEAD
++=======
+ 	*p++ = resp->status;
+ 	if (resp->status != nfs_ok)
+ 		return xdr_ressize_check(rqstp, p);
+ 
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  	/*
  	 * Since this is version 2, the check for nfserr in
  	 * nfsd_dispatch actually ensures the following cannot happen.
@@@ -312,7 -318,12 +347,15 @@@ static int nfsaclsvc_encode_attrstatres
  {
  	struct nfsd_attrstat *resp = rqstp->rq_resp;
  
++<<<<<<< HEAD
++=======
+ 	*p++ = resp->status;
+ 	if (resp->status != nfs_ok)
+ 		goto out;
+ 
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  	p = nfs2svc_encode_fattr(rqstp, p, &resp->fh, &resp->stat);
+ out:
  	return xdr_ressize_check(rqstp, p);
  }
  
@@@ -321,8 -332,13 +364,16 @@@ static int nfsaclsvc_encode_accessres(s
  {
  	struct nfsd3_accessres *resp = rqstp->rq_resp;
  
++<<<<<<< HEAD
++=======
+ 	*p++ = resp->status;
+ 	if (resp->status != nfs_ok)
+ 		goto out;
+ 
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  	p = nfs2svc_encode_fattr(rqstp, p, &resp->fh, &resp->stat);
  	*p++ = htonl(resp->access);
+ out:
  	return xdr_ressize_check(rqstp, p);
  }
  
diff --cc fs/nfsd/nfs3acl.c
index 614168675c17,34a394e50e1d..000000000000
--- a/fs/nfsd/nfs3acl.c
+++ b/fs/nfsd/nfs3acl.c
@@@ -71,7 -70,8 +71,12 @@@ static __be32 nfsd3_proc_getacl(struct 
  	}
  
  	/* resp->acl_{access,default} are released in nfs3svc_release_getacl. */
++<<<<<<< HEAD
 +	RETURN_STATUS(0);
++=======
+ out:
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  
  fail:
  	posix_acl_release(resp->acl_access);
@@@ -119,7 -118,7 +124,11 @@@ out
  	   nfs3svc_decode_setaclargs. */
  	posix_acl_release(argp->acl_access);
  	posix_acl_release(argp->acl_default);
++<<<<<<< HEAD
 +	RETURN_STATUS(nfserr);
++=======
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /*
diff --cc fs/nfsd/nfs3proc.c
index 18ff6c873ee5,14468613d150..000000000000
--- a/fs/nfsd/nfs3proc.c
+++ b/fs/nfsd/nfs3proc.c
@@@ -51,14 -48,14 +51,20 @@@ nfsd3_proc_getattr(struct svc_rqst *rqs
  		SVCFH_fmt(&argp->fh));
  
  	fh_copy(&resp->fh, &argp->fh);
 -	resp->status = fh_verify(rqstp, &resp->fh, 0,
 -				 NFSD_MAY_NOP | NFSD_MAY_BYPASS_GSS_ON_ROOT);
 -	if (resp->status != nfs_ok)
 -		goto out;
 +	nfserr = fh_verify(rqstp, &resp->fh, 0,
 +			NFSD_MAY_NOP | NFSD_MAY_BYPASS_GSS_ON_ROOT);
 +	if (nfserr)
 +		RETURN_STATUS(nfserr);
 +
++<<<<<<< HEAD
 +	nfserr = fh_getattr(&resp->fh, &resp->stat);
  
 +	RETURN_STATUS(nfserr);
++=======
+ 	resp->status = fh_getattr(&resp->fh, &resp->stat);
+ out:
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /*
@@@ -75,9 -71,9 +81,15 @@@ nfsd3_proc_setattr(struct svc_rqst *rqs
  				SVCFH_fmt(&argp->fh));
  
  	fh_copy(&resp->fh, &argp->fh);
++<<<<<<< HEAD
 +	nfserr = nfsd_setattr(rqstp, &resp->fh, &argp->attrs,
 +			      argp->check_guard, argp->guardtime);
 +	RETURN_STATUS(nfserr);
++=======
+ 	resp->status = nfsd_setattr(rqstp, &resp->fh, &argp->attrs,
+ 				    argp->check_guard, argp->guardtime);
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /*
@@@ -98,11 -93,10 +110,18 @@@ nfsd3_proc_lookup(struct svc_rqst *rqst
  	fh_copy(&resp->dirfh, &argp->fh);
  	fh_init(&resp->fh, NFS3_FHSIZE);
  
++<<<<<<< HEAD
 +	nfserr = nfsd_lookup(rqstp, &resp->dirfh,
 +				    argp->name,
 +				    argp->len,
 +				    &resp->fh);
 +	RETURN_STATUS(nfserr);
++=======
+ 	resp->status = nfsd_lookup(rqstp, &resp->dirfh,
+ 				   argp->name, argp->len,
+ 				   &resp->fh);
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /*
@@@ -121,8 -114,8 +140,13 @@@ nfsd3_proc_access(struct svc_rqst *rqst
  
  	fh_copy(&resp->fh, &argp->fh);
  	resp->access = argp->access;
++<<<<<<< HEAD
 +	nfserr = nfsd_access(rqstp, &resp->fh, &resp->access, NULL);
 +	RETURN_STATUS(nfserr);
++=======
+ 	resp->status = nfsd_access(rqstp, &resp->fh, &resp->access, NULL);
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /*
@@@ -140,8 -132,8 +164,13 @@@ nfsd3_proc_readlink(struct svc_rqst *rq
  	/* Read the symlink. */
  	fh_copy(&resp->fh, &argp->fh);
  	resp->len = NFS3_MAXPATHLEN;
++<<<<<<< HEAD
 +	nfserr = nfsd_readlink(rqstp, &resp->fh, argp->buffer, &resp->len);
 +	RETURN_STATUS(nfserr);
++=======
+ 	resp->status = nfsd_readlink(rqstp, &resp->fh, argp->buffer, &resp->len);
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /*
@@@ -169,12 -160,10 +198,19 @@@ nfsd3_proc_read(struct svc_rqst *rqstp
  	svc_reserve_auth(rqstp, ((1 + NFS3_POST_OP_ATTR_WORDS + 3)<<2) + resp->count +4);
  
  	fh_copy(&resp->fh, &argp->fh);
++<<<<<<< HEAD
 +	nfserr = nfsd_read(rqstp, &resp->fh,
 +				  argp->offset,
 +			   	  rqstp->rq_vec, argp->vlen,
 +				  &resp->count,
 +				  &resp->eof);
 +	RETURN_STATUS(nfserr);
++=======
+ 	resp->status = nfsd_read(rqstp, &resp->fh, argp->offset,
+ 				 rqstp->rq_vec, argp->vlen, &resp->count,
+ 				 &resp->eof);
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /*
@@@ -199,13 -187,16 +235,18 @@@ nfsd3_proc_write(struct svc_rqst *rqstp
  	resp->committed = argp->stable;
  	nvecs = svc_fill_write_vector(rqstp, rqstp->rq_arg.pages,
  				      &argp->first, cnt);
 -	if (!nvecs) {
 -		resp->status = nfserr_io;
 -		goto out;
 -	}
 -	resp->status = nfsd_write(rqstp, &resp->fh, argp->offset,
 -				  rqstp->rq_vec, nvecs, &cnt,
 -				  resp->committed, resp->verf);
 +	if (!nvecs)
 +		RETURN_STATUS(nfserr_io);
 +	nfserr = nfsd_write(rqstp, &resp->fh, argp->offset,
 +			    rqstp->rq_vec, nvecs, &cnt,
 +			    resp->committed);
  	resp->count = cnt;
++<<<<<<< HEAD
 +	RETURN_STATUS(nfserr);
++=======
+ out:
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /*
@@@ -241,11 -231,10 +282,18 @@@ nfsd3_proc_create(struct svc_rqst *rqst
  	}
  
  	/* Now create the file and set attributes */
++<<<<<<< HEAD
 +	nfserr = do_nfsd_create(rqstp, dirfhp, argp->name, argp->len,
 +				attr, newfhp,
 +				argp->createmode, (u32 *)argp->verf, NULL, NULL);
 +
 +	RETURN_STATUS(nfserr);
++=======
+ 	resp->status = do_nfsd_create(rqstp, dirfhp, argp->name, argp->len,
+ 				      attr, newfhp, argp->createmode,
+ 				      (u32 *)argp->verf, NULL, NULL);
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /*
@@@ -266,10 -254,10 +314,14 @@@ nfsd3_proc_mkdir(struct svc_rqst *rqstp
  	argp->attrs.ia_valid &= ~ATTR_SIZE;
  	fh_copy(&resp->dirfh, &argp->fh);
  	fh_init(&resp->fh, NFS3_FHSIZE);
 -	resp->status = nfsd_create(rqstp, &resp->dirfh, argp->name, argp->len,
 -				   &argp->attrs, S_IFDIR, 0, &resp->fh);
 +	nfserr = nfsd_create(rqstp, &resp->dirfh, argp->name, argp->len,
 +				    &argp->attrs, S_IFDIR, 0, &resp->fh);
  	fh_unlock(&resp->dirfh);
++<<<<<<< HEAD
 +	RETURN_STATUS(nfserr);
++=======
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  static __be32
@@@ -297,10 -290,11 +349,15 @@@ nfsd3_proc_symlink(struct svc_rqst *rqs
  
  	fh_copy(&resp->dirfh, &argp->ffh);
  	fh_init(&resp->fh, NFS3_FHSIZE);
 -	resp->status = nfsd_symlink(rqstp, &resp->dirfh, argp->fname,
 -				    argp->flen, argp->tname, &resp->fh);
 +	nfserr = nfsd_symlink(rqstp, &resp->dirfh, argp->fname, argp->flen,
 +						   argp->tname, &resp->fh);
  	kfree(argp->tname);
++<<<<<<< HEAD
 +	RETURN_STATUS(nfserr);
++=======
+ out:
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /*
@@@ -328,17 -323,21 +385,22 @@@ nfsd3_proc_mknod(struct svc_rqst *rqstp
  	if (argp->ftype == NF3CHR || argp->ftype == NF3BLK) {
  		rdev = MKDEV(argp->major, argp->minor);
  		if (MAJOR(rdev) != argp->major ||
 -		    MINOR(rdev) != argp->minor) {
 -			resp->status = nfserr_inval;
 -			goto out;
 -		}
 -	} else if (argp->ftype != NF3SOCK && argp->ftype != NF3FIFO) {
 -		resp->status = nfserr_inval;
 -		goto out;
 -	}
 +		    MINOR(rdev) != argp->minor)
 +			RETURN_STATUS(nfserr_inval);
 +	} else
 +		if (argp->ftype != NF3SOCK && argp->ftype != NF3FIFO)
 +			RETURN_STATUS(nfserr_inval);
  
  	type = nfs3_ftypes[argp->ftype];
 -	resp->status = nfsd_create(rqstp, &resp->dirfh, argp->name, argp->len,
 -				   &argp->attrs, type, rdev, &resp->fh);
 +	nfserr = nfsd_create(rqstp, &resp->dirfh, argp->name, argp->len,
 +				    &argp->attrs, type, rdev, &resp->fh);
  	fh_unlock(&resp->dirfh);
++<<<<<<< HEAD
 +	RETURN_STATUS(nfserr);
++=======
+ out:
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /*
@@@ -358,9 -356,10 +420,13 @@@ nfsd3_proc_remove(struct svc_rqst *rqst
  
  	/* Unlink. -S_IFDIR means file must not be a directory */
  	fh_copy(&resp->fh, &argp->fh);
 -	resp->status = nfsd_unlink(rqstp, &resp->fh, -S_IFDIR,
 -				   argp->name, argp->len);
 +	nfserr = nfsd_unlink(rqstp, &resp->fh, -S_IFDIR, argp->name, argp->len);
  	fh_unlock(&resp->fh);
++<<<<<<< HEAD
 +	RETURN_STATUS(nfserr);
++=======
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /*
@@@ -379,9 -377,10 +445,13 @@@ nfsd3_proc_rmdir(struct svc_rqst *rqstp
  				argp->name);
  
  	fh_copy(&resp->fh, &argp->fh);
 -	resp->status = nfsd_unlink(rqstp, &resp->fh, S_IFDIR,
 -				   argp->name, argp->len);
 +	nfserr = nfsd_unlink(rqstp, &resp->fh, S_IFDIR, argp->name, argp->len);
  	fh_unlock(&resp->fh);
++<<<<<<< HEAD
 +	RETURN_STATUS(nfserr);
++=======
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  static __be32
@@@ -402,9 -400,9 +472,15 @@@ nfsd3_proc_rename(struct svc_rqst *rqst
  
  	fh_copy(&resp->ffh, &argp->ffh);
  	fh_copy(&resp->tfh, &argp->tfh);
++<<<<<<< HEAD
 +	nfserr = nfsd_rename(rqstp, &resp->ffh, argp->fname, argp->flen,
 +				    &resp->tfh, argp->tname, argp->tlen);
 +	RETURN_STATUS(nfserr);
++=======
+ 	resp->status = nfsd_rename(rqstp, &resp->ffh, argp->fname, argp->flen,
+ 				   &resp->tfh, argp->tname, argp->tlen);
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  static __be32
@@@ -423,9 -420,9 +499,15 @@@ nfsd3_proc_link(struct svc_rqst *rqstp
  
  	fh_copy(&resp->fh,  &argp->ffh);
  	fh_copy(&resp->tfh, &argp->tfh);
++<<<<<<< HEAD
 +	nfserr = nfsd_link(rqstp, &resp->tfh, argp->tname, argp->tlen,
 +				  &resp->fh);
 +	RETURN_STATUS(nfserr);
++=======
+ 	resp->status = nfsd_link(rqstp, &resp->tfh, argp->tname, argp->tlen,
+ 				 &resp->fh);
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /*
@@@ -485,7 -481,7 +567,11 @@@ nfsd3_proc_readdir(struct svc_rqst *rqs
  		resp->offset = NULL;
  	}
  
++<<<<<<< HEAD
 +	RETURN_STATUS(nfserr);
++=======
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /*
@@@ -555,7 -550,8 +641,12 @@@ nfsd3_proc_readdirplus(struct svc_rqst 
  		resp->offset = NULL;
  	}
  
++<<<<<<< HEAD
 +	RETURN_STATUS(nfserr);
++=======
+ out:
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /*
@@@ -571,9 -566,9 +662,13 @@@ nfsd3_proc_fsstat(struct svc_rqst *rqst
  	dprintk("nfsd: FSSTAT(3)   %s\n",
  				SVCFH_fmt(&argp->fh));
  
 -	resp->status = nfsd_statfs(rqstp, &argp->fh, &resp->stats, 0);
 +	nfserr = nfsd_statfs(rqstp, &argp->fh, &resp->stats, 0);
  	fh_put(&argp->fh);
++<<<<<<< HEAD
 +	RETURN_STATUS(nfserr);
++=======
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /*
@@@ -617,7 -611,7 +712,11 @@@ nfsd3_proc_fsinfo(struct svc_rqst *rqst
  	}
  
  	fh_put(&argp->fh);
++<<<<<<< HEAD
 +	RETURN_STATUS(nfserr);
++=======
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /*
@@@ -660,10 -653,9 +759,14 @@@ nfsd3_proc_pathconf(struct svc_rqst *rq
  	}
  
  	fh_put(&argp->fh);
++<<<<<<< HEAD
 +	RETURN_STATUS(nfserr);
++=======
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
 +
  /*
   * Commit a file (range) to stable storage.
   */
@@@ -679,13 -670,16 +782,20 @@@ nfsd3_proc_commit(struct svc_rqst *rqst
  				argp->count,
  				(unsigned long long) argp->offset);
  
 -	if (argp->offset > NFS_OFFSET_MAX) {
 -		resp->status = nfserr_inval;
 -		goto out;
 -	}
 +	if (argp->offset > NFS_OFFSET_MAX)
 +		RETURN_STATUS(nfserr_inval);
  
  	fh_copy(&resp->fh, &argp->fh);
++<<<<<<< HEAD
 +	nfserr = nfsd_commit(rqstp, &resp->fh, argp->offset, argp->count);
 +
 +	RETURN_STATUS(nfserr);
++=======
+ 	resp->status = nfsd_commit(rqstp, &resp->fh, argp->offset,
+ 				   argp->count, resp->verf);
+ out:
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  
diff --cc fs/nfsd/nfsproc.c
index ff76d2e1e4f4,0d71549f9d42..000000000000
--- a/fs/nfsd/nfsproc.c
+++ b/fs/nfsd/nfsproc.c
@@@ -17,21 -16,9 +17,21 @@@
  static __be32
  nfsd_proc_null(struct svc_rqst *rqstp)
  {
- 	return nfs_ok;
+ 	return rpc_success;
  }
  
 +static __be32
 +nfsd_return_attrs(__be32 err, struct nfsd_attrstat *resp)
 +{
 +	if (err) return err;
 +	return fh_getattr(&resp->fh, &resp->stat);
 +}
 +static __be32
 +nfsd_return_dirop(__be32 err, struct nfsd_diropres *resp)
 +{
 +	if (err) return err;
 +	return fh_getattr(&resp->fh, &resp->stat);
 +}
  /*
   * Get a file's attributes
   * N.B. After this call resp->fh needs an fh_put
@@@ -45,9 -32,13 +45,19 @@@ nfsd_proc_getattr(struct svc_rqst *rqst
  	dprintk("nfsd: GETATTR  %s\n", SVCFH_fmt(&argp->fh));
  
  	fh_copy(&resp->fh, &argp->fh);
++<<<<<<< HEAD
 +	nfserr = fh_verify(rqstp, &resp->fh, 0,
 +			NFSD_MAY_NOP | NFSD_MAY_BYPASS_GSS_ON_ROOT);
 +	return nfsd_return_attrs(nfserr, resp);
++=======
+ 	resp->status = fh_verify(rqstp, &resp->fh, 0,
+ 				 NFSD_MAY_NOP | NFSD_MAY_BYPASS_GSS_ON_ROOT);
+ 	if (resp->status != nfs_ok)
+ 		goto out;
+ 	resp->status = fh_getattr(&resp->fh, &resp->stat);
+ out:
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /*
@@@ -93,9 -83,9 +103,15 @@@ nfsd_proc_setattr(struct svc_rqst *rqst
  		 */
  		time64_t delta = iap->ia_atime.tv_sec - ktime_get_real_seconds();
  
++<<<<<<< HEAD
 +		nfserr = fh_verify(rqstp, fhp, 0, NFSD_MAY_NOP);
 +		if (nfserr)
 +			goto done;
++=======
+ 		resp->status = fh_verify(rqstp, fhp, 0, NFSD_MAY_NOP);
+ 		if (resp->status != nfs_ok)
+ 			goto out;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  
  		if (delta < 0)
  			delta = -delta;
@@@ -110,9 -100,13 +126,19 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	nfserr = nfsd_setattr(rqstp, fhp, iap, 0, (time64_t)0);
 +done:
 +	return nfsd_return_attrs(nfserr, resp);
++=======
+ 	resp->status = nfsd_setattr(rqstp, fhp, iap, 0, (time64_t)0);
+ 	if (resp->status != nfs_ok)
+ 		goto out;
+ 
+ 	resp->status = fh_getattr(&resp->fh, &resp->stat);
+ out:
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /* Obsolete, replaced by MNTPROC_MNT. */
@@@ -139,11 -132,15 +165,17 @@@ nfsd_proc_lookup(struct svc_rqst *rqstp
  		SVCFH_fmt(&argp->fh), argp->len, argp->name);
  
  	fh_init(&resp->fh, NFS_FHSIZE);
 -	resp->status = nfsd_lookup(rqstp, &argp->fh, argp->name, argp->len,
 -				   &resp->fh);
 -	fh_put(&argp->fh);
 -	if (resp->status != nfs_ok)
 -		goto out;
 +	nfserr = nfsd_lookup(rqstp, &argp->fh, argp->name, argp->len,
 +				 &resp->fh);
  
++<<<<<<< HEAD
 +	fh_put(&argp->fh);
 +	return nfsd_return_dirop(nfserr, resp);
++=======
+ 	resp->status = fh_getattr(&resp->fh, &resp->stat);
+ out:
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /*
@@@ -160,10 -156,10 +192,14 @@@ nfsd_proc_readlink(struct svc_rqst *rqs
  
  	/* Read the symlink. */
  	resp->len = NFS_MAXPATHLEN;
 -	resp->status = nfsd_readlink(rqstp, &argp->fh, argp->buffer, &resp->len);
 +	nfserr = nfsd_readlink(rqstp, &argp->fh, argp->buffer, &resp->len);
  
  	fh_put(&argp->fh);
++<<<<<<< HEAD
 +	return nfserr;
++=======
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /*
@@@ -197,14 -192,16 +233,27 @@@ nfsd_proc_read(struct svc_rqst *rqstp
  	svc_reserve_auth(rqstp, (19<<2) + argp->count + 4);
  
  	resp->count = argp->count;
++<<<<<<< HEAD
 +	nfserr = nfsd_read(rqstp, fh_copy(&resp->fh, &argp->fh),
 +				  argp->offset,
 +			   	  rqstp->rq_vec, argp->vlen,
 +				  &resp->count,
 +				  &eof);
 +
 +	if (nfserr) return nfserr;
 +	return fh_getattr(&resp->fh, &resp->stat);
++=======
+ 	resp->status = nfsd_read(rqstp, fh_copy(&resp->fh, &argp->fh),
+ 				 argp->offset,
+ 				 rqstp->rq_vec, argp->vlen,
+ 				 &resp->count,
+ 				 &eof);
+ 	if (resp->status == nfs_ok)
+ 		resp->status = fh_getattr(&resp->fh, &resp->stat);
+ 	else if (resp->status == nfserr_jukebox)
+ 		return rpc_drop_reply;
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /* Reserved */
@@@ -233,12 -229,20 +282,29 @@@ nfsd_proc_write(struct svc_rqst *rqstp
  
  	nvecs = svc_fill_write_vector(rqstp, rqstp->rq_arg.pages,
  				      &argp->first, cnt);
++<<<<<<< HEAD
 +	if (!nvecs)
 +		return nfserr_io;
 +	nfserr = nfsd_write(rqstp, fh_copy(&resp->fh, &argp->fh),
 +			    argp->offset, rqstp->rq_vec, nvecs,
 +			    &cnt, NFS_DATA_SYNC);
 +	return nfsd_return_attrs(nfserr, resp);
++=======
+ 	if (!nvecs) {
+ 		resp->status = nfserr_io;
+ 		goto out;
+ 	}
+ 
+ 	resp->status = nfsd_write(rqstp, fh_copy(&resp->fh, &argp->fh),
+ 				  argp->offset, rqstp->rq_vec, nvecs,
+ 				  &cnt, NFS_DATA_SYNC, NULL);
+ 	if (resp->status == nfs_ok)
+ 		resp->status = fh_getattr(&resp->fh, &resp->stat);
+ 	else if (resp->status == nfserr_jukebox)
+ 		return rpc_drop_reply;
+ out:
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /*
@@@ -400,7 -405,11 +466,15 @@@ out_unlock
  	fh_drop_write(dirfhp);
  done:
  	fh_put(dirfhp);
++<<<<<<< HEAD
 +	return nfsd_return_dirop(nfserr, resp);
++=======
+ 	if (resp->status != nfs_ok)
+ 		goto out;
+ 	resp->status = fh_getattr(&resp->fh, &resp->stat);
+ out:
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  static __be32
@@@ -460,17 -470,21 +535,31 @@@ static __be3
  nfsd_proc_symlink(struct svc_rqst *rqstp)
  {
  	struct nfsd_symlinkargs *argp = rqstp->rq_argp;
+ 	struct nfsd_stat *resp = rqstp->rq_resp;
  	struct svc_fh	newfh;
- 	__be32		nfserr;
  
++<<<<<<< HEAD
 +	if (argp->tlen > NFS_MAXPATHLEN)
 +		return nfserr_nametoolong;
++=======
+ 	if (argp->tlen > NFS_MAXPATHLEN) {
+ 		resp->status = nfserr_nametoolong;
+ 		goto out;
+ 	}
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  
  	argp->tname = svc_fill_symlink_pathname(rqstp, &argp->first,
  						page_address(rqstp->rq_arg.pages[0]),
  						argp->tlen);
++<<<<<<< HEAD
 +	if (IS_ERR(argp->tname))
 +		return nfserrno(PTR_ERR(argp->tname));
++=======
+ 	if (IS_ERR(argp->tname)) {
+ 		resp->status = nfserrno(PTR_ERR(argp->tname));
+ 		goto out;
+ 	}
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  
  	dprintk("nfsd: SYMLINK  %s %.*s -> %.*s\n",
  		SVCFH_fmt(&argp->ffh), argp->flen, argp->fname,
@@@ -483,7 -497,8 +572,12 @@@
  	kfree(argp->tname);
  	fh_put(&argp->ffh);
  	fh_put(&newfh);
++<<<<<<< HEAD
 +	return nfserr;
++=======
+ out:
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /*
@@@ -506,10 -520,15 +600,19 @@@ nfsd_proc_mkdir(struct svc_rqst *rqstp
  
  	argp->attrs.ia_valid &= ~ATTR_SIZE;
  	fh_init(&resp->fh, NFS_FHSIZE);
 -	resp->status = nfsd_create(rqstp, &argp->fh, argp->name, argp->len,
 -				   &argp->attrs, S_IFDIR, 0, &resp->fh);
 +	nfserr = nfsd_create(rqstp, &argp->fh, argp->name, argp->len,
 +				    &argp->attrs, S_IFDIR, 0, &resp->fh);
  	fh_put(&argp->fh);
++<<<<<<< HEAD
 +	return nfsd_return_dirop(nfserr, resp);
++=======
+ 	if (resp->status != nfs_ok)
+ 		goto out;
+ 
+ 	resp->status = fh_getattr(&resp->fh, &resp->stat);
+ out:
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /*
@@@ -566,7 -585,7 +670,11 @@@ nfsd_proc_readdir(struct svc_rqst *rqst
  		*resp->offset = htonl(offset);
  
  	fh_put(&argp->fh);
++<<<<<<< HEAD
 +	return nfserr;
++=======
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /*
@@@ -581,10 -599,10 +689,14 @@@ nfsd_proc_statfs(struct svc_rqst *rqstp
  
  	dprintk("nfsd: STATFS   %s\n", SVCFH_fmt(&argp->fh));
  
 -	resp->status = nfsd_statfs(rqstp, &argp->fh, &resp->stats,
 -				   NFSD_MAY_BYPASS_GSS_ON_ROOT);
 +	nfserr = nfsd_statfs(rqstp, &argp->fh, &resp->stats,
 +			NFSD_MAY_BYPASS_GSS_ON_ROOT);
  	fh_put(&argp->fh);
++<<<<<<< HEAD
 +	return nfserr;
++=======
+ 	return rpc_success;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  }
  
  /*
diff --cc fs/nfsd/nfssvc.c
index 446151eeff5f,27b1ad136150..000000000000
--- a/fs/nfsd/nfssvc.c
+++ b/fs/nfsd/nfssvc.c
@@@ -1035,23 -1036,15 +1028,27 @@@ int nfsd_dispatch(struct svc_rqst *rqst
  	 * Need to grab the location to store the status, as
  	 * NFSv4 does some encoding while processing
  	 */
- 	nfserrp = resv->iov_base + resv->iov_len;
+ 	p = resv->iov_base + resv->iov_len;
  	resv->iov_len += sizeof(__be32);
  
- 	nfserr = proc->pc_func(rqstp);
- 	nfserr = map_new_errors(rqstp->rq_vers, nfserr);
- 	if (nfserr == nfserr_dropit || test_bit(RQ_DROPME, &rqstp->rq_flags))
+ 	*statp = proc->pc_func(rqstp);
+ 	if (*statp == rpc_drop_reply || test_bit(RQ_DROPME, &rqstp->rq_flags))
  		goto out_update_drop;
  
++<<<<<<< HEAD
 +	if (rqstp->rq_proc != 0)
 +		*nfserrp++ = nfserr;
 +
 +	/*
 +	 * For NFSv2, additional info is never returned in case of an error.
 +	 */
 +	if (!(nfserr && rqstp->rq_vers == 2))
 +		if (!proc->pc_encode(rqstp, nfserrp))
 +			goto out_encode_err;
++=======
+ 	if (!proc->pc_encode(rqstp, p))
+ 		goto out_encode_err;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  
  	nfsd_cache_update(rqstp, rqstp->rq_cachetype, statp + 1);
  out_cached_reply:
diff --cc fs/nfsd/nfsxdr.c
index 39c004ec7d85,8a288c8fcd57..000000000000
--- a/fs/nfsd/nfsxdr.c
+++ b/fs/nfsd/nfsxdr.c
@@@ -434,7 -443,11 +443,14 @@@ nfssvc_encode_attrstat(struct svc_rqst 
  {
  	struct nfsd_attrstat *resp = rqstp->rq_resp;
  
++<<<<<<< HEAD
++=======
+ 	*p++ = resp->status;
+ 	if (resp->status != nfs_ok)
+ 		goto out;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  	p = encode_fattr(rqstp, p, &resp->fh, &resp->stat);
+ out:
  	return xdr_ressize_check(rqstp, p);
  }
  
@@@ -443,8 -456,12 +459,15 @@@ nfssvc_encode_diropres(struct svc_rqst 
  {
  	struct nfsd_diropres *resp = rqstp->rq_resp;
  
++<<<<<<< HEAD
++=======
+ 	*p++ = resp->status;
+ 	if (resp->status != nfs_ok)
+ 		goto out;
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  	p = encode_fh(p, &resp->fh);
  	p = encode_fattr(rqstp, p, &resp->fh, &resp->stat);
+ out:
  	return xdr_ressize_check(rqstp, p);
  }
  
@@@ -453,6 -470,10 +476,13 @@@ nfssvc_encode_readlinkres(struct svc_rq
  {
  	struct nfsd_readlinkres *resp = rqstp->rq_resp;
  
++<<<<<<< HEAD
++=======
+ 	*p++ = resp->status;
+ 	if (resp->status != nfs_ok)
+ 		return xdr_ressize_check(rqstp, p);
+ 
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  	*p++ = htonl(resp->len);
  	xdr_ressize_check(rqstp, p);
  	rqstp->rq_res.page_len = resp->len;
@@@ -470,6 -491,10 +500,13 @@@ nfssvc_encode_readres(struct svc_rqst *
  {
  	struct nfsd_readres *resp = rqstp->rq_resp;
  
++<<<<<<< HEAD
++=======
+ 	*p++ = resp->status;
+ 	if (resp->status != nfs_ok)
+ 		return xdr_ressize_check(rqstp, p);
+ 
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  	p = encode_fattr(rqstp, p, &resp->fh, &resp->stat);
  	*p++ = htonl(resp->count);
  	xdr_ressize_check(rqstp, p);
@@@ -490,6 -515,10 +527,13 @@@ nfssvc_encode_readdirres(struct svc_rqs
  {
  	struct nfsd_readdirres *resp = rqstp->rq_resp;
  
++<<<<<<< HEAD
++=======
+ 	*p++ = resp->status;
+ 	if (resp->status != nfs_ok)
+ 		return xdr_ressize_check(rqstp, p);
+ 
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  	xdr_ressize_check(rqstp, p);
  	p = resp->buffer;
  	*p++ = 0;			/* no more entries */
@@@ -505,6 -534,10 +549,13 @@@ nfssvc_encode_statfsres(struct svc_rqs
  	struct nfsd_statfsres *resp = rqstp->rq_resp;
  	struct kstatfs	*stat = &resp->stats;
  
++<<<<<<< HEAD
++=======
+ 	*p++ = resp->status;
+ 	if (resp->status != nfs_ok)
+ 		return xdr_ressize_check(rqstp, p);
+ 
++>>>>>>> cc028a10a48c (NFSD: Hoist status code encoding into XDR encoder functions)
  	*p++ = htonl(NFSSVC_MAXBLKSIZE_V2);	/* max transfer size */
  	*p++ = htonl(stat->f_bsize);
  	*p++ = htonl(stat->f_blocks);
* Unmerged path fs/nfsd/nfs2acl.c
* Unmerged path fs/nfsd/nfs3acl.c
* Unmerged path fs/nfsd/nfs3proc.c
diff --git a/fs/nfsd/nfs3xdr.c b/fs/nfsd/nfs3xdr.c
index f681ed52b092..968e9c03dfe6 100644
--- a/fs/nfsd/nfs3xdr.c
+++ b/fs/nfsd/nfs3xdr.c
@@ -641,10 +641,7 @@ nfs3svc_decode_commitargs(struct svc_rqst *rqstp, __be32 *p)
 /*
  * XDR encode functions
  */
-/*
- * There must be an encoding function for void results so svc_process
- * will work properly.
- */
+
 int
 nfs3svc_encode_voidres(struct svc_rqst *rqstp, __be32 *p)
 {
@@ -657,6 +654,7 @@ nfs3svc_encode_attrstat(struct svc_rqst *rqstp, __be32 *p)
 {
 	struct nfsd3_attrstat *resp = rqstp->rq_resp;
 
+	*p++ = resp->status;
 	if (resp->status == 0) {
 		lease_get_mtime(d_inode(resp->fh.fh_dentry),
 				&resp->stat.mtime);
@@ -671,6 +669,7 @@ nfs3svc_encode_wccstat(struct svc_rqst *rqstp, __be32 *p)
 {
 	struct nfsd3_attrstat *resp = rqstp->rq_resp;
 
+	*p++ = resp->status;
 	p = encode_wcc_data(rqstp, p, &resp->fh);
 	return xdr_ressize_check(rqstp, p);
 }
@@ -681,6 +680,7 @@ nfs3svc_encode_diropres(struct svc_rqst *rqstp, __be32 *p)
 {
 	struct nfsd3_diropres *resp = rqstp->rq_resp;
 
+	*p++ = resp->status;
 	if (resp->status == 0) {
 		p = encode_fh(p, &resp->fh);
 		p = encode_post_op_attr(rqstp, p, &resp->fh);
@@ -695,6 +695,7 @@ nfs3svc_encode_accessres(struct svc_rqst *rqstp, __be32 *p)
 {
 	struct nfsd3_accessres *resp = rqstp->rq_resp;
 
+	*p++ = resp->status;
 	p = encode_post_op_attr(rqstp, p, &resp->fh);
 	if (resp->status == 0)
 		*p++ = htonl(resp->access);
@@ -707,6 +708,7 @@ nfs3svc_encode_readlinkres(struct svc_rqst *rqstp, __be32 *p)
 {
 	struct nfsd3_readlinkres *resp = rqstp->rq_resp;
 
+	*p++ = resp->status;
 	p = encode_post_op_attr(rqstp, p, &resp->fh);
 	if (resp->status == 0) {
 		*p++ = htonl(resp->len);
@@ -729,6 +731,7 @@ nfs3svc_encode_readres(struct svc_rqst *rqstp, __be32 *p)
 {
 	struct nfsd3_readres *resp = rqstp->rq_resp;
 
+	*p++ = resp->status;
 	p = encode_post_op_attr(rqstp, p, &resp->fh);
 	if (resp->status == 0) {
 		*p++ = htonl(resp->count);
@@ -756,6 +759,7 @@ nfs3svc_encode_writeres(struct svc_rqst *rqstp, __be32 *p)
 	struct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);
 	__be32 verf[2];
 
+	*p++ = resp->status;
 	p = encode_wcc_data(rqstp, p, &resp->fh);
 	if (resp->status == 0) {
 		*p++ = htonl(resp->count);
@@ -774,6 +778,7 @@ nfs3svc_encode_createres(struct svc_rqst *rqstp, __be32 *p)
 {
 	struct nfsd3_diropres *resp = rqstp->rq_resp;
 
+	*p++ = resp->status;
 	if (resp->status == 0) {
 		*p++ = xdr_one;
 		p = encode_fh(p, &resp->fh);
@@ -789,6 +794,7 @@ nfs3svc_encode_renameres(struct svc_rqst *rqstp, __be32 *p)
 {
 	struct nfsd3_renameres *resp = rqstp->rq_resp;
 
+	*p++ = resp->status;
 	p = encode_wcc_data(rqstp, p, &resp->ffh);
 	p = encode_wcc_data(rqstp, p, &resp->tfh);
 	return xdr_ressize_check(rqstp, p);
@@ -800,6 +806,7 @@ nfs3svc_encode_linkres(struct svc_rqst *rqstp, __be32 *p)
 {
 	struct nfsd3_linkres *resp = rqstp->rq_resp;
 
+	*p++ = resp->status;
 	p = encode_post_op_attr(rqstp, p, &resp->fh);
 	p = encode_wcc_data(rqstp, p, &resp->tfh);
 	return xdr_ressize_check(rqstp, p);
@@ -811,6 +818,7 @@ nfs3svc_encode_readdirres(struct svc_rqst *rqstp, __be32 *p)
 {
 	struct nfsd3_readdirres *resp = rqstp->rq_resp;
 
+	*p++ = resp->status;
 	p = encode_post_op_attr(rqstp, p, &resp->fh);
 
 	if (resp->status == 0) {
@@ -1063,6 +1071,7 @@ nfs3svc_encode_fsstatres(struct svc_rqst *rqstp, __be32 *p)
 	struct kstatfs	*s = &resp->stats;
 	u64		bs = s->f_bsize;
 
+	*p++ = resp->status;
 	*p++ = xdr_zero;	/* no post_op_attr */
 
 	if (resp->status == 0) {
@@ -1083,6 +1092,7 @@ nfs3svc_encode_fsinfores(struct svc_rqst *rqstp, __be32 *p)
 {
 	struct nfsd3_fsinfores *resp = rqstp->rq_resp;
 
+	*p++ = resp->status;
 	*p++ = xdr_zero;	/* no post_op_attr */
 
 	if (resp->status == 0) {
@@ -1130,6 +1140,7 @@ nfs3svc_encode_commitres(struct svc_rqst *rqstp, __be32 *p)
 	struct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);
 	__be32 verf[2];
 
+	*p++ = resp->status;
 	p = encode_wcc_data(rqstp, p, &resp->fh);
 	/* Write verifier */
 	if (resp->status == 0) {
diff --git a/fs/nfsd/nfs4proc.c b/fs/nfsd/nfs4proc.c
index 9c6c56e3f084..76a69692c439 100644
--- a/fs/nfsd/nfs4proc.c
+++ b/fs/nfsd/nfs4proc.c
@@ -1865,7 +1865,7 @@ nfsd4_removexattr(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 static __be32
 nfsd4_proc_null(struct svc_rqst *rqstp)
 {
-	return nfs_ok;
+	return rpc_success;
 }
 
 static inline void nfsd4_increment_op_stats(u32 opnum)
@@ -2115,15 +2115,14 @@ nfsd4_proc_compound(struct svc_rqst *rqstp)
 		nfsd4_increment_op_stats(op->opnum);
 	}
 
-	cstate->status = status;
 	fh_put(current_fh);
 	fh_put(save_fh);
 	BUG_ON(cstate->replay_owner);
 out:
+	cstate->status = status;
 	/* Reset deferral mechanism for RPC deferrals */
 	set_bit(RQ_USEDEFERRAL, &rqstp->rq_flags);
-	dprintk("nfsv4 compound returned %d\n", ntohl(status));
-	return status;
+	return rpc_success;
 }
 
 #define op_encode_hdr_size		(2)
diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.c
index 917b70911708..f873d427efce 100644
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@ -5020,15 +5020,14 @@ nfs4svc_decode_compoundargs(struct svc_rqst *rqstp, __be32 *p)
 int
 nfs4svc_encode_compoundres(struct svc_rqst *rqstp, __be32 *p)
 {
-	/*
-	 * All that remains is to write the tag and operation count...
-	 */
 	struct nfsd4_compoundres *resp = rqstp->rq_resp;
 	struct xdr_buf *buf = resp->xdr.buf;
 
 	WARN_ON_ONCE(buf->len != buf->head[0].iov_len + buf->page_len +
 				 buf->tail[0].iov_len);
 
+	*p = resp->cstate.status;
+
 	rqstp->rq_next_page = resp->xdr.page_ptr + 1;
 
 	p = resp->tagp;
* Unmerged path fs/nfsd/nfsproc.c
* Unmerged path fs/nfsd/nfssvc.c
* Unmerged path fs/nfsd/nfsxdr.c
diff --git a/fs/nfsd/xdr.h b/fs/nfsd/xdr.h
index 3d3e16d48268..228fb4117b80 100644
--- a/fs/nfsd/xdr.h
+++ b/fs/nfsd/xdr.h
@@ -82,6 +82,10 @@ struct nfsd_readdirargs {
 	__be32 *		buffer;
 };
 
+struct nfsd_stat {
+	__be32			status;
+};
+
 struct nfsd_attrstat {
 	struct svc_fh		fh;
 	struct kstat		stat;
@@ -146,6 +150,7 @@ int nfssvc_decode_linkargs(struct svc_rqst *, __be32 *);
 int nfssvc_decode_symlinkargs(struct svc_rqst *, __be32 *);
 int nfssvc_decode_readdirargs(struct svc_rqst *, __be32 *);
 int nfssvc_encode_void(struct svc_rqst *, __be32 *);
+int nfssvc_encode_stat(struct svc_rqst *, __be32 *);
 int nfssvc_encode_attrstat(struct svc_rqst *, __be32 *);
 int nfssvc_encode_diropres(struct svc_rqst *, __be32 *);
 int nfssvc_encode_readlinkres(struct svc_rqst *, __be32 *);
