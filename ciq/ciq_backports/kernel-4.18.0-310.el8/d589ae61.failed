asm-generic/hyperv: update hv_msi_entry

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Wei Liu <wei.liu@kernel.org>
commit d589ae61bc27b2b9aaac0bf20a9077b6fbda32b6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/d589ae61.failed

We will soon need to access fields inside the MSI address and MSI data
fields. Introduce hv_msi_address_register and hv_msi_data_register.

Fix up one user of hv_msi_entry in mshyperv.h.

No functional change expected.

	Signed-off-by: Wei Liu <wei.liu@kernel.org>
	Reviewed-by: Michael Kelley <mikelley@microsoft.com>
Link: https://lore.kernel.org/r/20210203150435.27941-12-wei.liu@kernel.org
(cherry picked from commit d589ae61bc27b2b9aaac0bf20a9077b6fbda32b6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/asm-generic/hyperv-tlfs.h
diff --cc include/asm-generic/hyperv-tlfs.h
index e232ddcb0a2d,8ac797e6a91a..000000000000
--- a/include/asm-generic/hyperv-tlfs.h
+++ b/include/asm-generic/hyperv-tlfs.h
@@@ -408,6 -412,99 +408,102 @@@ struct hv_tlb_flush_ex 
  	u64 gva_list[];
  } __packed;
  
++<<<<<<< HEAD
++=======
+ /* HvGetPartitionId hypercall (output only) */
+ struct hv_get_partition_id {
+ 	u64 partition_id;
+ } __packed;
+ 
+ /* HvDepositMemory hypercall */
+ struct hv_deposit_memory {
+ 	u64 partition_id;
+ 	u64 gpa_page_list[];
+ } __packed;
+ 
+ struct hv_proximity_domain_flags {
+ 	u32 proximity_preferred : 1;
+ 	u32 reserved : 30;
+ 	u32 proximity_info_valid : 1;
+ } __packed;
+ 
+ /* Not a union in windows but useful for zeroing */
+ union hv_proximity_domain_info {
+ 	struct {
+ 		u32 domain_id;
+ 		struct hv_proximity_domain_flags flags;
+ 	};
+ 	u64 as_uint64;
+ } __packed;
+ 
+ struct hv_lp_startup_status {
+ 	u64 hv_status;
+ 	u64 substatus1;
+ 	u64 substatus2;
+ 	u64 substatus3;
+ 	u64 substatus4;
+ 	u64 substatus5;
+ 	u64 substatus6;
+ } __packed;
+ 
+ /* HvAddLogicalProcessor hypercall */
+ struct hv_add_logical_processor_in {
+ 	u32 lp_index;
+ 	u32 apic_id;
+ 	union hv_proximity_domain_info proximity_domain_info;
+ 	u64 flags;
+ } __packed;
+ 
+ struct hv_add_logical_processor_out {
+ 	struct hv_lp_startup_status startup_status;
+ } __packed;
+ 
+ enum HV_SUBNODE_TYPE
+ {
+     HvSubnodeAny = 0,
+     HvSubnodeSocket = 1,
+     HvSubnodeAmdNode = 2,
+     HvSubnodeL3 = 3,
+     HvSubnodeCount = 4,
+     HvSubnodeInvalid = -1
+ };
+ 
+ /* HvCreateVp hypercall */
+ struct hv_create_vp {
+ 	u64 partition_id;
+ 	u32 vp_index;
+ 	u8 padding[3];
+ 	u8 subnode_type;
+ 	u64 subnode_id;
+ 	union hv_proximity_domain_info proximity_domain_info;
+ 	u64 flags;
+ } __packed;
+ 
+ union hv_msi_address_register {
+ 	u32 as_uint32;
+ 	struct {
+ 		u32 reserved1:2;
+ 		u32 destination_mode:1;
+ 		u32 redirection_hint:1;
+ 		u32 reserved2:8;
+ 		u32 destination_id:8;
+ 		u32 msi_base:12;
+ 	};
+ } __packed;
+ 
+ union hv_msi_data_register {
+ 	u32 as_uint32;
+ 	struct {
+ 		u32 vector:8;
+ 		u32 delivery_mode:3;
+ 		u32 reserved1:3;
+ 		u32 level_assert:1;
+ 		u32 trigger_mode:1;
+ 		u32 reserved2:16;
+ 	};
+ } __packed;
+ 
++>>>>>>> d589ae61bc27 (asm-generic/hyperv: update hv_msi_entry)
  /* HvRetargetDeviceInterrupt hypercall */
  union hv_msi_entry {
  	u64 as_uint64;
diff --git a/arch/x86/include/asm/mshyperv.h b/arch/x86/include/asm/mshyperv.h
index 0d450ce090df..25f82617c49b 100644
--- a/arch/x86/include/asm/mshyperv.h
+++ b/arch/x86/include/asm/mshyperv.h
@@ -242,8 +242,8 @@ static inline void hv_apic_init(void) {}
 static inline void hv_set_msi_entry_from_desc(union hv_msi_entry *msi_entry,
 					      struct msi_desc *msi_desc)
 {
-	msi_entry->address = msi_desc->msg.address_lo;
-	msi_entry->data = msi_desc->msg.data;
+	msi_entry->address.as_uint32 = msi_desc->msg.address_lo;
+	msi_entry->data.as_uint32 = msi_desc->msg.data;
 }
 
 #else /* CONFIG_HYPERV */
* Unmerged path include/asm-generic/hyperv-tlfs.h
