opp: of: Allow empty opp-table with opp-shared

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Nicola Mazzucato <nicola.mazzucato@arm.com>
commit 6ee70e8c34e37a34f4dc2c8bc06febffd375fac4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/6ee70e8c.failed

The opp binding now allows to have an empty opp table and shared-opp to
still describe that devices share v/f lines.

When initialising an empty opp table, allow such case by:
- treating such conditions with warnings in place of errors
- don't fail on empty table

	Signed-off-by: Nicola Mazzucato <nicola.mazzucato@arm.com>
	Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
(cherry picked from commit 6ee70e8c34e37a34f4dc2c8bc06febffd375fac4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/opp/of.c
diff --cc drivers/opp/of.c
index a637f30552a3,96113fc0e18c..000000000000
--- a/drivers/opp/of.c
+++ b/drivers/opp/of.c
@@@ -337,6 -333,107 +338,110 @@@ free_required_opps
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int _bandwidth_supported(struct device *dev, struct opp_table *opp_table)
+ {
+ 	struct device_node *np, *opp_np;
+ 	struct property *prop;
+ 
+ 	if (!opp_table) {
+ 		np = of_node_get(dev->of_node);
+ 		if (!np)
+ 			return -ENODEV;
+ 
+ 		opp_np = _opp_of_get_opp_desc_node(np, 0);
+ 		of_node_put(np);
+ 	} else {
+ 		opp_np = of_node_get(opp_table->np);
+ 	}
+ 
+ 	/* Lets not fail in case we are parsing opp-v1 bindings */
+ 	if (!opp_np)
+ 		return 0;
+ 
+ 	/* Checking only first OPP is sufficient */
+ 	np = of_get_next_available_child(opp_np, NULL);
+ 	if (!np) {
+ 		dev_err(dev, "OPP table empty\n");
+ 		return -EINVAL;
+ 	}
+ 	of_node_put(opp_np);
+ 
+ 	prop = of_find_property(np, "opp-peak-kBps", NULL);
+ 	of_node_put(np);
+ 
+ 	if (!prop || !prop->length)
+ 		return 0;
+ 
+ 	return 1;
+ }
+ 
+ int dev_pm_opp_of_find_icc_paths(struct device *dev,
+ 				 struct opp_table *opp_table)
+ {
+ 	struct device_node *np;
+ 	int ret, i, count, num_paths;
+ 	struct icc_path **paths;
+ 
+ 	ret = _bandwidth_supported(dev, opp_table);
+ 	if (ret == -EINVAL)
+ 		return 0; /* Empty OPP table is a valid corner-case, let's not fail */
+ 	else if (ret <= 0)
+ 		return ret;
+ 
+ 	ret = 0;
+ 
+ 	np = of_node_get(dev->of_node);
+ 	if (!np)
+ 		return 0;
+ 
+ 	count = of_count_phandle_with_args(np, "interconnects",
+ 					   "#interconnect-cells");
+ 	of_node_put(np);
+ 	if (count < 0)
+ 		return 0;
+ 
+ 	/* two phandles when #interconnect-cells = <1> */
+ 	if (count % 2) {
+ 		dev_err(dev, "%s: Invalid interconnects values\n", __func__);
+ 		return -EINVAL;
+ 	}
+ 
+ 	num_paths = count / 2;
+ 	paths = kcalloc(num_paths, sizeof(*paths), GFP_KERNEL);
+ 	if (!paths)
+ 		return -ENOMEM;
+ 
+ 	for (i = 0; i < num_paths; i++) {
+ 		paths[i] = of_icc_get_by_index(dev, i);
+ 		if (IS_ERR(paths[i])) {
+ 			ret = PTR_ERR(paths[i]);
+ 			if (ret != -EPROBE_DEFER) {
+ 				dev_err(dev, "%s: Unable to get path%d: %d\n",
+ 					__func__, i, ret);
+ 			}
+ 			goto err;
+ 		}
+ 	}
+ 
+ 	if (opp_table) {
+ 		opp_table->paths = paths;
+ 		opp_table->path_count = num_paths;
+ 		return 0;
+ 	}
+ 
+ err:
+ 	while (i--)
+ 		icc_put(paths[i]);
+ 
+ 	kfree(paths);
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(dev_pm_opp_of_find_icc_paths);
+ 
++>>>>>>> 6ee70e8c34e3 (opp: of: Allow empty opp-table with opp-shared)
  static bool _opp_is_supported(struct device *dev, struct opp_table *opp_table,
  			      struct device_node *np)
  {
* Unmerged path drivers/opp/of.c
