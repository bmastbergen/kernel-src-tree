mm: memcontrol: convert NR_ANON_THPS account to pages

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Muchun Song <songmuchun@bytedance.com>
commit 69473e5de87389be6c0fa4a5d574a50c8f904fb3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/69473e5d.failed

Currently we use struct per_cpu_nodestat to cache the vmstat counters,
which leads to inaccurate statistics especially THP vmstat counters.  In
the systems with hundreds of processors it can be GBs of memory.  For
example, for a 96 CPUs system, the threshold is the maximum number of 125.
And the per cpu counters can cache 23.4375 GB in total.

The THP page is already a form of batched addition (it will add 512 worth
of memory in one go) so skipping the batching seems like sensible.
Although every THP stats update overflows the per-cpu counter, resorting
to atomic global updates.  But it can make the statistics more accuracy
for the THP vmstat counters.

So we convert the NR_ANON_THPS account to pages.  This patch is consistent
with 8f182270dfec ("mm/swap.c: flush lru pvecs on compound page arrival").
Doing this also can make the unit of vmstat counters more unified.
Finally, the unit of the vmstat counters are pages, kB and bytes.  The
B/KB suffix can tell us that the unit is bytes or kB.  The rest which is
without suffix are pages.

Link: https://lkml.kernel.org/r/20201228164110.2838-3-songmuchun@bytedance.com
	Signed-off-by: Muchun Song <songmuchun@bytedance.com>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: Rafael. J. Wysocki <rafael@kernel.org>
	Cc: Alexey Dobriyan <adobriyan@gmail.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Vladimir Davydov <vdavydov.dev@gmail.com>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: Shakeel Butt <shakeelb@google.com>
	Cc: Roman Gushchin <guro@fb.com>
	Cc: Sami Tolvanen <samitolvanen@google.com>
	Cc: Feng Tang <feng.tang@intel.com>
	Cc: NeilBrown <neilb@suse.de>
	Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
	Cc: Randy Dunlap <rdunlap@infradead.org>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: Pankaj Gupta <pankaj.gupta@cloud.ionos.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 69473e5de87389be6c0fa4a5d574a50c8f904fb3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/node.c
#	mm/memcontrol.c
#	mm/rmap.c
diff --cc drivers/base/node.c
index 8633d5d90a7d,6da0c3508bc9..000000000000
--- a/drivers/base/node.c
+++ b/drivers/base/node.c
@@@ -369,99 -376,104 +369,112 @@@ static ssize_t node_read_meminfo(struc
  	si_meminfo_node(&i, nid);
  	sreclaimable = node_page_state_pages(pgdat, NR_SLAB_RECLAIMABLE_B);
  	sunreclaimable = node_page_state_pages(pgdat, NR_SLAB_UNRECLAIMABLE_B);
 -	len = sysfs_emit_at(buf, len,
 -			    "Node %d MemTotal:       %8lu kB\n"
 -			    "Node %d MemFree:        %8lu kB\n"
 -			    "Node %d MemUsed:        %8lu kB\n"
 -			    "Node %d Active:         %8lu kB\n"
 -			    "Node %d Inactive:       %8lu kB\n"
 -			    "Node %d Active(anon):   %8lu kB\n"
 -			    "Node %d Inactive(anon): %8lu kB\n"
 -			    "Node %d Active(file):   %8lu kB\n"
 -			    "Node %d Inactive(file): %8lu kB\n"
 -			    "Node %d Unevictable:    %8lu kB\n"
 -			    "Node %d Mlocked:        %8lu kB\n",
 -			    nid, K(i.totalram),
 -			    nid, K(i.freeram),
 -			    nid, K(i.totalram - i.freeram),
 -			    nid, K(node_page_state(pgdat, NR_ACTIVE_ANON) +
 -				   node_page_state(pgdat, NR_ACTIVE_FILE)),
 -			    nid, K(node_page_state(pgdat, NR_INACTIVE_ANON) +
 -				   node_page_state(pgdat, NR_INACTIVE_FILE)),
 -			    nid, K(node_page_state(pgdat, NR_ACTIVE_ANON)),
 -			    nid, K(node_page_state(pgdat, NR_INACTIVE_ANON)),
 -			    nid, K(node_page_state(pgdat, NR_ACTIVE_FILE)),
 -			    nid, K(node_page_state(pgdat, NR_INACTIVE_FILE)),
 -			    nid, K(node_page_state(pgdat, NR_UNEVICTABLE)),
 -			    nid, K(sum_zone_node_page_state(nid, NR_MLOCK)));
 +	n = sprintf(buf,
 +		       "Node %d MemTotal:       %8lu kB\n"
 +		       "Node %d MemFree:        %8lu kB\n"
 +		       "Node %d MemUsed:        %8lu kB\n"
 +		       "Node %d Active:         %8lu kB\n"
 +		       "Node %d Inactive:       %8lu kB\n"
 +		       "Node %d Active(anon):   %8lu kB\n"
 +		       "Node %d Inactive(anon): %8lu kB\n"
 +		       "Node %d Active(file):   %8lu kB\n"
 +		       "Node %d Inactive(file): %8lu kB\n"
 +		       "Node %d Unevictable:    %8lu kB\n"
 +		       "Node %d Mlocked:        %8lu kB\n",
 +		       nid, K(i.totalram),
 +		       nid, K(i.freeram),
 +		       nid, K(i.totalram - i.freeram),
 +		       nid, K(node_page_state(pgdat, NR_ACTIVE_ANON) +
 +				node_page_state(pgdat, NR_ACTIVE_FILE)),
 +		       nid, K(node_page_state(pgdat, NR_INACTIVE_ANON) +
 +				node_page_state(pgdat, NR_INACTIVE_FILE)),
 +		       nid, K(node_page_state(pgdat, NR_ACTIVE_ANON)),
 +		       nid, K(node_page_state(pgdat, NR_INACTIVE_ANON)),
 +		       nid, K(node_page_state(pgdat, NR_ACTIVE_FILE)),
 +		       nid, K(node_page_state(pgdat, NR_INACTIVE_FILE)),
 +		       nid, K(node_page_state(pgdat, NR_UNEVICTABLE)),
 +		       nid, K(sum_zone_node_page_state(nid, NR_MLOCK)));
  
  #ifdef CONFIG_HIGHMEM
 -	len += sysfs_emit_at(buf, len,
 -			     "Node %d HighTotal:      %8lu kB\n"
 -			     "Node %d HighFree:       %8lu kB\n"
 -			     "Node %d LowTotal:       %8lu kB\n"
 -			     "Node %d LowFree:        %8lu kB\n",
 -			     nid, K(i.totalhigh),
 -			     nid, K(i.freehigh),
 -			     nid, K(i.totalram - i.totalhigh),
 -			     nid, K(i.freeram - i.freehigh));
 +	n += sprintf(buf + n,
 +		       "Node %d HighTotal:      %8lu kB\n"
 +		       "Node %d HighFree:       %8lu kB\n"
 +		       "Node %d LowTotal:       %8lu kB\n"
 +		       "Node %d LowFree:        %8lu kB\n",
 +		       nid, K(i.totalhigh),
 +		       nid, K(i.freehigh),
 +		       nid, K(i.totalram - i.totalhigh),
 +		       nid, K(i.freeram - i.freehigh));
  #endif
 -	len += sysfs_emit_at(buf, len,
 -			     "Node %d Dirty:          %8lu kB\n"
 -			     "Node %d Writeback:      %8lu kB\n"
 -			     "Node %d FilePages:      %8lu kB\n"
 -			     "Node %d Mapped:         %8lu kB\n"
 -			     "Node %d AnonPages:      %8lu kB\n"
 -			     "Node %d Shmem:          %8lu kB\n"
 -			     "Node %d KernelStack:    %8lu kB\n"
 -#ifdef CONFIG_SHADOW_CALL_STACK
 -			     "Node %d ShadowCallStack:%8lu kB\n"
 -#endif
 -			     "Node %d PageTables:     %8lu kB\n"
 -			     "Node %d NFS_Unstable:   %8lu kB\n"
 -			     "Node %d Bounce:         %8lu kB\n"
 -			     "Node %d WritebackTmp:   %8lu kB\n"
 -			     "Node %d KReclaimable:   %8lu kB\n"
 -			     "Node %d Slab:           %8lu kB\n"
 -			     "Node %d SReclaimable:   %8lu kB\n"
 -			     "Node %d SUnreclaim:     %8lu kB\n"
 +	n += sprintf(buf + n,
 +		       "Node %d Dirty:          %8lu kB\n"
 +		       "Node %d Writeback:      %8lu kB\n"
 +		       "Node %d FilePages:      %8lu kB\n"
 +		       "Node %d Mapped:         %8lu kB\n"
 +		       "Node %d AnonPages:      %8lu kB\n"
 +		       "Node %d Shmem:          %8lu kB\n"
 +		       "Node %d KernelStack:    %8lu kB\n"
 +		       "Node %d PageTables:     %8lu kB\n"
 +		       "Node %d NFS_Unstable:   %8lu kB\n"
 +		       "Node %d Bounce:         %8lu kB\n"
 +		       "Node %d WritebackTmp:   %8lu kB\n"
 +		       "Node %d KReclaimable:   %8lu kB\n"
 +		       "Node %d Slab:           %8lu kB\n"
 +		       "Node %d SReclaimable:   %8lu kB\n"
 +		       "Node %d SUnreclaim:     %8lu kB\n"
  #ifdef CONFIG_TRANSPARENT_HUGEPAGE
 -			     "Node %d AnonHugePages:  %8lu kB\n"
 -			     "Node %d ShmemHugePages: %8lu kB\n"
 -			     "Node %d ShmemPmdMapped: %8lu kB\n"
 -			     "Node %d FileHugePages: %8lu kB\n"
 -			     "Node %d FilePmdMapped: %8lu kB\n"
 -#endif
 -			     ,
 -			     nid, K(node_page_state(pgdat, NR_FILE_DIRTY)),
 -			     nid, K(node_page_state(pgdat, NR_WRITEBACK)),
 -			     nid, K(node_page_state(pgdat, NR_FILE_PAGES)),
 -			     nid, K(node_page_state(pgdat, NR_FILE_MAPPED)),
 -			     nid, K(node_page_state(pgdat, NR_ANON_MAPPED)),
 -			     nid, K(i.sharedram),
 -			     nid, node_page_state(pgdat, NR_KERNEL_STACK_KB),
 -#ifdef CONFIG_SHADOW_CALL_STACK
 -			     nid, node_page_state(pgdat, NR_KERNEL_SCS_KB),
 +		       "Node %d AnonHugePages:  %8lu kB\n"
 +		       "Node %d ShmemHugePages: %8lu kB\n"
 +		       "Node %d ShmemPmdMapped: %8lu kB\n"
 +		       "Node %d FileHugePages: %8lu kB\n"
 +		       "Node %d FilePmdMapped: %8lu kB\n"
  #endif
 -			     nid, K(node_page_state(pgdat, NR_PAGETABLE)),
 -			     nid, 0UL,
 -			     nid, K(sum_zone_node_page_state(nid, NR_BOUNCE)),
 -			     nid, K(node_page_state(pgdat, NR_WRITEBACK_TEMP)),
 -			     nid, K(sreclaimable +
 -				    node_page_state(pgdat, NR_KERNEL_MISC_RECLAIMABLE)),
 -			     nid, K(sreclaimable + sunreclaimable),
 -			     nid, K(sreclaimable),
 -			     nid, K(sunreclaimable)
 +			,
 +		       nid, K(node_page_state(pgdat, NR_FILE_DIRTY)),
 +		       nid, K(node_page_state(pgdat, NR_WRITEBACK)),
 +		       nid, K(node_page_state(pgdat, NR_FILE_PAGES)),
 +		       nid, K(node_page_state(pgdat, NR_FILE_MAPPED)),
 +		       nid, K(node_page_state(pgdat, NR_ANON_MAPPED)),
 +		       nid, K(i.sharedram),
 +		       nid, sum_zone_node_page_state(nid, NR_KERNEL_STACK_KB),
 +		       nid, K(sum_zone_node_page_state(nid, NR_PAGETABLE)),
 +		       nid, 0UL,
 +		       nid, K(sum_zone_node_page_state(nid, NR_BOUNCE)),
 +		       nid, K(node_page_state(pgdat, NR_WRITEBACK_TEMP)),
 +		       nid, K(sreclaimable +
 +			      node_page_state(pgdat, NR_KERNEL_MISC_RECLAIMABLE)),
 +		       nid, K(sreclaimable + sunreclaimable),
 +		       nid, K(sreclaimable),
 +		       nid, K(sunreclaimable)
  #ifdef CONFIG_TRANSPARENT_HUGEPAGE
++<<<<<<< HEAD
 +		       ,
 +		       nid, K(node_page_state(pgdat, NR_ANON_THPS) *
 +				       HPAGE_PMD_NR),
 +		       nid, K(node_page_state(pgdat, NR_SHMEM_THPS) *
 +				       HPAGE_PMD_NR),
 +		       nid, K(node_page_state(pgdat, NR_SHMEM_PMDMAPPED) *
 +				       HPAGE_PMD_NR),
 +		       nid, K(node_page_state(pgdat, NR_FILE_THPS) *
 +				       HPAGE_PMD_NR),
 +		       nid, K(node_page_state(pgdat, NR_FILE_PMDMAPPED) *
 +				       HPAGE_PMD_NR)
++=======
+ 			     ,
+ 			     nid, K(node_page_state(pgdat, NR_ANON_THPS)),
+ 			     nid, K(node_page_state(pgdat, NR_SHMEM_THPS) *
+ 				    HPAGE_PMD_NR),
+ 			     nid, K(node_page_state(pgdat, NR_SHMEM_PMDMAPPED) *
+ 				    HPAGE_PMD_NR),
+ 			     nid, K(node_page_state(pgdat, NR_FILE_THPS) *
+ 				    HPAGE_PMD_NR),
+ 			     nid, K(node_page_state(pgdat, NR_FILE_PMDMAPPED) *
+ 				    HPAGE_PMD_NR)
++>>>>>>> 69473e5de873 (mm: memcontrol: convert NR_ANON_THPS account to pages)
  #endif
 -			    );
 -	len += hugetlb_report_node_meminfo(buf, len, nid);
 -	return len;
 +		       );
 +	n += hugetlb_report_node_meminfo(nid, buf + n);
 +	return n;
  }
  
  #undef K
@@@ -500,20 -513,26 +513,31 @@@ static ssize_t node_read_vmstat(struct 
  
  #ifdef CONFIG_NUMA
  	for (i = 0; i < NR_VM_NUMA_STAT_ITEMS; i++)
 -		len += sysfs_emit_at(buf, len, "%s %lu\n",
 -				     numa_stat_name(i),
 -				     sum_zone_numa_state(nid, i));
 -
 +		n += sprintf(buf+n, "%s %lu\n", numa_stat_name(i),
 +			     sum_zone_numa_state(nid, i));
  #endif
++<<<<<<< HEAD
++=======
+ 	for (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++) {
+ 		unsigned long pages = node_page_state_pages(pgdat, i);
+ 
+ 		if (vmstat_item_print_in_thp(i))
+ 			pages /= HPAGE_PMD_NR;
+ 		len += sysfs_emit_at(buf, len, "%s %lu\n", node_stat_name(i),
+ 				     pages);
+ 	}
++>>>>>>> 69473e5de873 (mm: memcontrol: convert NR_ANON_THPS account to pages)
  
 -	return len;
 +	for (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++)
 +		n += sprintf(buf+n, "%s %lu\n", node_stat_name(i),
 +			     node_page_state_pages(pgdat, i));
 +
 +	return n;
  }
 -static DEVICE_ATTR(vmstat, 0444, node_read_vmstat, NULL);
 +static DEVICE_ATTR(vmstat, S_IRUGO, node_read_vmstat, NULL);
  
  static ssize_t node_read_distance(struct device *dev,
 -				  struct device_attribute *attr, char *buf)
 +			struct device_attribute *attr, char *buf)
  {
  	int nid = dev->id;
  	int len = 0;
diff --cc mm/memcontrol.c
index 4d65b541b4a3,b2405f049006..000000000000
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@@ -1468,6 -1510,74 +1468,77 @@@ static bool mem_cgroup_wait_acct_move(s
  	return false;
  }
  
++<<<<<<< HEAD
++=======
+ struct memory_stat {
+ 	const char *name;
+ 	unsigned int ratio;
+ 	unsigned int idx;
+ };
+ 
+ static struct memory_stat memory_stats[] = {
+ 	{ "anon", PAGE_SIZE, NR_ANON_MAPPED },
+ 	{ "file", PAGE_SIZE, NR_FILE_PAGES },
+ 	{ "kernel_stack", 1024, NR_KERNEL_STACK_KB },
+ 	{ "pagetables", PAGE_SIZE, NR_PAGETABLE },
+ 	{ "percpu", 1, MEMCG_PERCPU_B },
+ 	{ "sock", PAGE_SIZE, MEMCG_SOCK },
+ 	{ "shmem", PAGE_SIZE, NR_SHMEM },
+ 	{ "file_mapped", PAGE_SIZE, NR_FILE_MAPPED },
+ 	{ "file_dirty", PAGE_SIZE, NR_FILE_DIRTY },
+ 	{ "file_writeback", PAGE_SIZE, NR_WRITEBACK },
+ #ifdef CONFIG_TRANSPARENT_HUGEPAGE
+ 	/*
+ 	 * The ratio will be initialized in memory_stats_init(). Because
+ 	 * on some architectures, the macro of HPAGE_PMD_SIZE is not
+ 	 * constant(e.g. powerpc).
+ 	 */
+ 	{ "anon_thp", PAGE_SIZE, NR_ANON_THPS },
+ 	{ "file_thp", 0, NR_FILE_THPS },
+ 	{ "shmem_thp", 0, NR_SHMEM_THPS },
+ #endif
+ 	{ "inactive_anon", PAGE_SIZE, NR_INACTIVE_ANON },
+ 	{ "active_anon", PAGE_SIZE, NR_ACTIVE_ANON },
+ 	{ "inactive_file", PAGE_SIZE, NR_INACTIVE_FILE },
+ 	{ "active_file", PAGE_SIZE, NR_ACTIVE_FILE },
+ 	{ "unevictable", PAGE_SIZE, NR_UNEVICTABLE },
+ 
+ 	/*
+ 	 * Note: The slab_reclaimable and slab_unreclaimable must be
+ 	 * together and slab_reclaimable must be in front.
+ 	 */
+ 	{ "slab_reclaimable", 1, NR_SLAB_RECLAIMABLE_B },
+ 	{ "slab_unreclaimable", 1, NR_SLAB_UNRECLAIMABLE_B },
+ 
+ 	/* The memory events */
+ 	{ "workingset_refault_anon", 1, WORKINGSET_REFAULT_ANON },
+ 	{ "workingset_refault_file", 1, WORKINGSET_REFAULT_FILE },
+ 	{ "workingset_activate_anon", 1, WORKINGSET_ACTIVATE_ANON },
+ 	{ "workingset_activate_file", 1, WORKINGSET_ACTIVATE_FILE },
+ 	{ "workingset_restore_anon", 1, WORKINGSET_RESTORE_ANON },
+ 	{ "workingset_restore_file", 1, WORKINGSET_RESTORE_FILE },
+ 	{ "workingset_nodereclaim", 1, WORKINGSET_NODERECLAIM },
+ };
+ 
+ static int __init memory_stats_init(void)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(memory_stats); i++) {
+ #ifdef CONFIG_TRANSPARENT_HUGEPAGE
+ 		if (memory_stats[i].idx == NR_FILE_THPS ||
+ 		    memory_stats[i].idx == NR_SHMEM_THPS)
+ 			memory_stats[i].ratio = HPAGE_PMD_SIZE;
+ #endif
+ 		VM_BUG_ON(!memory_stats[i].ratio);
+ 		VM_BUG_ON(memory_stats[i].idx >= MEMCG_NR_STAT);
+ 	}
+ 
+ 	return 0;
+ }
+ pure_initcall(memory_stats_init);
+ 
++>>>>>>> 69473e5de873 (mm: memcontrol: convert NR_ANON_THPS account to pages)
  static char *memory_stat_format(struct mem_cgroup *memcg)
  {
  	struct seq_buf s;
diff --cc mm/rmap.c
index 2dedbfb3e93d,c4d5c63cfd29..000000000000
--- a/mm/rmap.c
+++ b/mm/rmap.c
@@@ -1179,7 -1183,10 +1179,14 @@@ void page_add_new_anon_rmap(struct pag
  		VM_BUG_ON_PAGE(!PageTransHuge(page), page);
  		/* increment count (starts at -1) */
  		atomic_set(compound_mapcount_ptr(page), 0);
++<<<<<<< HEAD
 +		__inc_lruvec_page_state(page, NR_ANON_THPS);
++=======
+ 		if (hpage_pincount_available(page))
+ 			atomic_set(compound_pincount_ptr(page), 0);
+ 
+ 		__mod_lruvec_page_state(page, NR_ANON_THPS, nr);
++>>>>>>> 69473e5de873 (mm: memcontrol: convert NR_ANON_THPS account to pages)
  	} else {
  		/* Anon THP always mapped first with PMD */
  		VM_BUG_ON_PAGE(PageTransCompound(page), page);
* Unmerged path drivers/base/node.c
diff --git a/fs/proc/meminfo.c b/fs/proc/meminfo.c
index 89a6b114397f..85ce124c7685 100644
--- a/fs/proc/meminfo.c
+++ b/fs/proc/meminfo.c
@@ -130,7 +130,7 @@ static int meminfo_proc_show(struct seq_file *m, void *v)
 
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
 	show_val_kb(m, "AnonHugePages:  ",
-		    global_node_page_state(NR_ANON_THPS) * HPAGE_PMD_NR);
+		    global_node_page_state(NR_ANON_THPS));
 	show_val_kb(m, "ShmemHugePages: ",
 		    global_node_page_state(NR_SHMEM_THPS) * HPAGE_PMD_NR);
 	show_val_kb(m, "ShmemPmdMapped: ",
diff --git a/include/linux/mmzone.h b/include/linux/mmzone.h
index ae118ed2cb9b..fcea7f07acf7 100644
--- a/include/linux/mmzone.h
+++ b/include/linux/mmzone.h
@@ -212,6 +212,19 @@ enum node_stat_item {
 	NR_VM_NODE_STAT_ITEMS
 };
 
+/*
+ * Returns true if the item should be printed in THPs (/proc/vmstat
+ * currently prints number of anon, file and shmem THPs. But the item
+ * is charged in pages).
+ */
+static __always_inline bool vmstat_item_print_in_thp(enum node_stat_item item)
+{
+	if (!IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE))
+		return false;
+
+	return item == NR_ANON_THPS;
+}
+
 /*
  * Returns true if the value is measured in bytes (most vmstat values are
  * measured in pages). This defines the API part, the internal representation
diff --git a/mm/huge_memory.c b/mm/huge_memory.c
index f8f2e337b025..e7802092f2cc 100644
--- a/mm/huge_memory.c
+++ b/mm/huge_memory.c
@@ -2117,7 +2117,8 @@ static void __split_huge_pmd_locked(struct vm_area_struct *vma, pmd_t *pmd,
 		lock_page_memcg(page);
 		if (atomic_add_negative(-1, compound_mapcount_ptr(page))) {
 			/* Last compound_mapcount is gone. */
-			__dec_lruvec_page_state(page, NR_ANON_THPS);
+			__mod_lruvec_page_state(page, NR_ANON_THPS,
+						-HPAGE_PMD_NR);
 			if (TestClearPageDoubleMap(page)) {
 				/* No need in mapcount reference anymore */
 				for (i = 0; i < HPAGE_PMD_NR; i++)
* Unmerged path mm/memcontrol.c
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index 8c7425895151..870c1f6c0187 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -5408,7 +5408,7 @@ void show_free_areas(unsigned int filter, nodemask_t *nodemask)
 			K(node_page_state(pgdat, NR_SHMEM_THPS) * HPAGE_PMD_NR),
 			K(node_page_state(pgdat, NR_SHMEM_PMDMAPPED)
 					* HPAGE_PMD_NR),
-			K(node_page_state(pgdat, NR_ANON_THPS) * HPAGE_PMD_NR),
+			K(node_page_state(pgdat, NR_ANON_THPS)),
 #endif
 			K(node_page_state(pgdat, NR_WRITEBACK_TEMP)),
 			pgdat->kswapd_failures >= MAX_RECLAIM_RETRIES ?
* Unmerged path mm/rmap.c
diff --git a/mm/vmstat.c b/mm/vmstat.c
index d9662e48d82b..7c9e43a11a09 100644
--- a/mm/vmstat.c
+++ b/mm/vmstat.c
@@ -1613,8 +1613,12 @@ static void zoneinfo_show_print(struct seq_file *m, pg_data_t *pgdat,
 	if (is_zone_first_populated(pgdat, zone)) {
 		seq_printf(m, "\n  per-node stats");
 		for (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++) {
+			unsigned long pages = node_page_state_pages(pgdat, i);
+
+			if (vmstat_item_print_in_thp(i))
+				pages /= HPAGE_PMD_NR;
 			seq_printf(m, "\n      %-12s %lu", node_stat_name(i),
-				   node_page_state_pages(pgdat, i));
+				   pages);
 		}
 	}
 	seq_printf(m,
@@ -1734,8 +1738,11 @@ static void *vmstat_start(struct seq_file *m, loff_t *pos)
 	v += NR_VM_NUMA_STAT_ITEMS;
 #endif
 
-	for (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++)
+	for (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++) {
 		v[i] = global_node_page_state_pages(i);
+		if (vmstat_item_print_in_thp(i))
+			v[i] /= HPAGE_PMD_NR;
+	}
 	v += NR_VM_NODE_STAT_ITEMS;
 
 	global_dirty_limits(v + NR_DIRTY_BG_THRESHOLD,
