RDMA/rxe: Remove RXE_POOL_ATOMIC

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Bob Pearson <rpearsonhpe@gmail.com>
commit 4276fd0dddc98ee7d6c1a469b3f35b8ab51ddc2f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/4276fd0d.failed

rxe_alloc() used the RXE_POOL_ATOMIC flag in rxe_type_info to select
GFP_ATOMIC in calls to kzalloc(). This was intended to handle cases where
an object could be created in interrupt context. This no longer occurs
since allocating those objects has moved into the core so this flag is not
necessary. An incorrect use of this flag was still present for rxe_mc_elem
objects and is removed.

Link: https://lore.kernel.org/r/20210125211641.2694-4-rpearson@hpe.com
	Signed-off-by: Bob Pearson <rpearson@hpe.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit 4276fd0dddc98ee7d6c1a469b3f35b8ab51ddc2f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/sw/rxe/rxe_pool.c
diff --cc drivers/infiniband/sw/rxe/rxe_pool.c
index 3727f20dbe87,0ca46bd8be51..000000000000
--- a/drivers/infiniband/sw/rxe/rxe_pool.c
+++ b/drivers/infiniband/sw/rxe/rxe_pool.c
@@@ -365,13 -336,49 +364,11 @@@ void __rxe_drop_index(struct rxe_pool_e
  	write_unlock_irqrestore(&pool->pool_lock, flags);
  }
  
 -void *rxe_alloc_locked(struct rxe_pool *pool)
 -{
 -	struct rxe_type_info *info = &rxe_type_info[pool->type];
 -	struct rxe_pool_entry *elem;
 -	u8 *obj;
 -
 -	if (pool->state != RXE_POOL_STATE_VALID)
 -		return NULL;
 -
 -	kref_get(&pool->ref_cnt);
 -
 -	if (!ib_device_try_get(&pool->rxe->ib_dev))
 -		goto out_put_pool;
 -
 -	if (atomic_inc_return(&pool->num_elem) > pool->max_elem)
 -		goto out_cnt;
 -
 -	obj = kzalloc(info->size, GFP_ATOMIC);
 -	if (!obj)
 -		goto out_cnt;
 -
 -	elem = (struct rxe_pool_entry *)(obj + info->elem_offset);
 -
 -	elem->pool = pool;
 -	kref_init(&elem->ref_cnt);
 -
 -	return obj;
 -
 -out_cnt:
 -	atomic_dec(&pool->num_elem);
 -	ib_device_put(&pool->rxe->ib_dev);
 -out_put_pool:
 -	rxe_pool_put(pool);
 -	return NULL;
 -}
 -
  void *rxe_alloc(struct rxe_pool *pool)
  {
 -	unsigned long flags;
 -	struct rxe_type_info *info = &rxe_type_info[pool->type];
  	struct rxe_pool_entry *elem;
 -	u8 *obj;
 +	unsigned long flags;
  
- 	might_sleep_if(!(pool->flags & RXE_POOL_ATOMIC));
- 
  	read_lock_irqsave(&pool->pool_lock, flags);
  	if (pool->state != RXE_POOL_STATE_VALID) {
  		read_unlock_irqrestore(&pool->pool_lock, flags);
@@@ -386,12 -394,12 +383,17 @@@
  	if (atomic_inc_return(&pool->num_elem) > pool->max_elem)
  		goto out_cnt;
  
++<<<<<<< HEAD
 +	elem = kmem_cache_zalloc(pool_cache(pool),
 +				 (pool->flags & RXE_POOL_ATOMIC) ?
 +				 GFP_ATOMIC : GFP_KERNEL);
 +	if (!elem)
++=======
+ 	obj = kzalloc(info->size, GFP_KERNEL);
+ 	if (!obj)
++>>>>>>> 4276fd0dddc9 (RDMA/rxe: Remove RXE_POOL_ATOMIC)
  		goto out_cnt;
  
 -	elem = (struct rxe_pool_entry *)(obj + info->elem_offset);
 -
  	elem->pool = pool;
  	kref_init(&elem->ref_cnt);
  
* Unmerged path drivers/infiniband/sw/rxe/rxe_pool.c
diff --git a/drivers/infiniband/sw/rxe/rxe_pool.h b/drivers/infiniband/sw/rxe/rxe_pool.h
index e1a24bca99de..8fc6630bd507 100644
--- a/drivers/infiniband/sw/rxe/rxe_pool.h
+++ b/drivers/infiniband/sw/rxe/rxe_pool.h
@@ -11,7 +11,6 @@
 #define RXE_POOL_CACHE_FLAGS	(0)
 
 enum rxe_pool_flags {
-	RXE_POOL_ATOMIC		= BIT(0),
 	RXE_POOL_INDEX		= BIT(1),
 	RXE_POOL_KEY		= BIT(2),
 	RXE_POOL_NO_ALLOC	= BIT(4),
