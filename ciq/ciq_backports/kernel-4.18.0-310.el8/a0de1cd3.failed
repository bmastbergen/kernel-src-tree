ethtool: specify which header flags are supported per command

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Jakub Kicinski <kuba@kernel.org>
commit a0de1cd3568749d3410c89b1c8bb70e90d61659f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/a0de1cd3.failed

Perform header flags validation through the policy.

Only pause command supports ETHTOOL_FLAG_STATS. Create a separate
policy to be able to express that in policy dumps to user space.

Note that even though the core will validate the header policy,
it cannot record multiple layers of attributes and we have to
re-parse header sub-attrs. When doing so we could skip attribute
validation, or use most permissive policy. Opt for the former.

We will no longer return the extack cookie for flags but since
we only added first new flag in this release it's not expected
that any user space had a chance to make use of it.

v2: - remove the re-validation in ethnl_parse_header_dev_get()

	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a0de1cd3568749d3410c89b1c8bb70e90d61659f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ethtool/netlink.c
#	net/ethtool/netlink.h
#	net/ethtool/pause.c
diff --cc net/ethtool/netlink.c
index 9efa14e1ec40,8a85a4e6be9b..000000000000
--- a/net/ethtool/netlink.c
+++ b/net/ethtool/netlink.c
@@@ -14,8 -9,19 +14,24 @@@ static struct genl_family ethtool_genl_
  static bool ethnl_ok __read_mostly;
  static u32 ethnl_bcast_seq;
  
++<<<<<<< HEAD
 +static const struct nla_policy ethnl_header_policy[ETHTOOL_A_HEADER_MAX + 1] = {
 +	[ETHTOOL_A_HEADER_UNSPEC]	= { .type = NLA_REJECT },
++=======
+ #define ETHTOOL_FLAGS_BASIC (ETHTOOL_FLAG_COMPACT_BITSETS |	\
+ 			     ETHTOOL_FLAG_OMIT_REPLY)
+ #define ETHTOOL_FLAGS_STATS (ETHTOOL_FLAGS_BASIC | ETHTOOL_FLAG_STATS)
+ 
+ const struct nla_policy ethnl_header_policy[] = {
++>>>>>>> a0de1cd35687 (ethtool: specify which header flags are supported per command)
+ 	[ETHTOOL_A_HEADER_DEV_INDEX]	= { .type = NLA_U32 },
+ 	[ETHTOOL_A_HEADER_DEV_NAME]	= { .type = NLA_NUL_STRING,
+ 					    .len = ALTIFNAMSIZ - 1 },
+ 	[ETHTOOL_A_HEADER_FLAGS]	= NLA_POLICY_MASK(NLA_U32,
+ 							  ETHTOOL_FLAGS_BASIC),
+ };
+ 
+ const struct nla_policy ethnl_header_policy_stats[] = {
  	[ETHTOOL_A_HEADER_DEV_INDEX]	= { .type = NLA_U32 },
  	[ETHTOOL_A_HEADER_DEV_NAME]	= { .type = NLA_NUL_STRING,
  					    .len = ALTIFNAMSIZ - 1 },
@@@ -52,19 -59,15 +69,20 @@@ int ethnl_parse_header_dev_get(struct e
  		NL_SET_ERR_MSG(extack, "request header missing");
  		return -EINVAL;
  	}
++<<<<<<< HEAD
 +	ret = nla_parse_nested(tb, ETHTOOL_A_HEADER_MAX, header,
 +			       ethnl_header_policy, extack);
++=======
+ 	/* No validation here, command policy should have a nested policy set
+ 	 * for the header, therefore validation should have already been done.
+ 	 */
+ 	ret = nla_parse_nested(tb, ARRAY_SIZE(ethnl_header_policy) - 1, header,
+ 			       NULL, extack);
++>>>>>>> a0de1cd35687 (ethtool: specify which header flags are supported per command)
  	if (ret < 0)
  		return ret;
- 	if (tb[ETHTOOL_A_HEADER_FLAGS]) {
+ 	if (tb[ETHTOOL_A_HEADER_FLAGS])
  		flags = nla_get_u32(tb[ETHTOOL_A_HEADER_FLAGS]);
- 		if (flags & ~ETHTOOL_FLAG_ALL) {
- 			NL_SET_ERR_MSG_ATTR(extack, tb[ETHTOOL_A_HEADER_FLAGS],
- 					    "unrecognized request flags");
- 			nl_set_extack_cookie_u32(extack, ETHTOOL_FLAG_ALL);
- 			return -EOPNOTSUPP;
- 		}
- 	}
  
  	devname_attr = tb[ETHTOOL_A_HEADER_DEV_NAME];
  	if (tb[ETHTOOL_A_HEADER_DEV_INDEX]) {
diff --cc net/ethtool/netlink.h
index d150f5f5e92b,3f5719786b0f..000000000000
--- a/net/ethtool/netlink.h
+++ b/net/ethtool/netlink.h
@@@ -345,21 -345,36 +345,54 @@@ extern const struct ethnl_request_ops e
  extern const struct ethnl_request_ops ethnl_eee_request_ops;
  extern const struct ethnl_request_ops ethnl_tsinfo_request_ops;
  
++<<<<<<< HEAD
 +extern const struct nla_policy ethnl_strset_get_policy[ETHTOOL_A_STRSET_MAX + 1];
 +extern const struct nla_policy ethnl_linkinfo_get_policy[ETHTOOL_A_LINKINFO_MAX + 1];
 +extern const struct nla_policy ethnl_linkmodes_get_policy[ETHTOOL_A_LINKMODES_MAX + 1];
 +extern const struct nla_policy ethnl_linkstate_get_policy[ETHTOOL_A_LINKSTATE_MAX + 1];
 +extern const struct nla_policy ethnl_debug_get_policy[ETHTOOL_A_DEBUG_MAX + 1];
 +extern const struct nla_policy ethnl_wol_get_policy[ETHTOOL_A_WOL_MAX + 1];
 +extern const struct nla_policy ethnl_features_get_policy[ETHTOOL_A_FEATURES_MAX + 1];
 +extern const struct nla_policy ethnl_privflags_get_policy[ETHTOOL_A_PRIVFLAGS_MAX + 1];
 +extern const struct nla_policy ethnl_rings_get_policy[ETHTOOL_A_RINGS_MAX + 1];
 +extern const struct nla_policy ethnl_channels_get_policy[ETHTOOL_A_CHANNELS_MAX + 1];
 +extern const struct nla_policy ethnl_coalesce_get_policy[ETHTOOL_A_COALESCE_MAX + 1];
 +extern const struct nla_policy ethnl_pause_get_policy[ETHTOOL_A_PAUSE_MAX + 1];
 +extern const struct nla_policy ethnl_eee_get_policy[ETHTOOL_A_EEE_MAX + 1];
 +extern const struct nla_policy ethnl_tsinfo_get_policy[ETHTOOL_A_TSINFO_MAX + 1];
 +extern const struct nla_policy ethnl_tunnel_info_get_policy[ETHTOOL_A_TUNNEL_INFO_MAX + 1];
++=======
+ extern const struct nla_policy ethnl_header_policy[ETHTOOL_A_HEADER_FLAGS + 1];
+ extern const struct nla_policy ethnl_header_policy_stats[ETHTOOL_A_HEADER_FLAGS + 1];
+ extern const struct nla_policy ethnl_strset_get_policy[ETHTOOL_A_STRSET_STRINGSETS + 1];
+ extern const struct nla_policy ethnl_linkinfo_get_policy[ETHTOOL_A_LINKINFO_HEADER + 1];
+ extern const struct nla_policy ethnl_linkinfo_set_policy[ETHTOOL_A_LINKINFO_TP_MDIX_CTRL + 1];
+ extern const struct nla_policy ethnl_linkmodes_get_policy[ETHTOOL_A_LINKMODES_HEADER + 1];
+ extern const struct nla_policy ethnl_linkmodes_set_policy[ETHTOOL_A_LINKMODES_MASTER_SLAVE_CFG + 1];
+ extern const struct nla_policy ethnl_linkstate_get_policy[ETHTOOL_A_LINKSTATE_HEADER + 1];
+ extern const struct nla_policy ethnl_debug_get_policy[ETHTOOL_A_DEBUG_HEADER + 1];
+ extern const struct nla_policy ethnl_debug_set_policy[ETHTOOL_A_DEBUG_MSGMASK + 1];
+ extern const struct nla_policy ethnl_wol_get_policy[ETHTOOL_A_WOL_HEADER + 1];
+ extern const struct nla_policy ethnl_wol_set_policy[ETHTOOL_A_WOL_SOPASS + 1];
+ extern const struct nla_policy ethnl_features_get_policy[ETHTOOL_A_FEATURES_HEADER + 1];
+ extern const struct nla_policy ethnl_features_set_policy[ETHTOOL_A_FEATURES_WANTED + 1];
+ extern const struct nla_policy ethnl_privflags_get_policy[ETHTOOL_A_PRIVFLAGS_HEADER + 1];
+ extern const struct nla_policy ethnl_privflags_set_policy[ETHTOOL_A_PRIVFLAGS_FLAGS + 1];
+ extern const struct nla_policy ethnl_rings_get_policy[ETHTOOL_A_RINGS_HEADER + 1];
+ extern const struct nla_policy ethnl_rings_set_policy[ETHTOOL_A_RINGS_TX + 1];
+ extern const struct nla_policy ethnl_channels_get_policy[ETHTOOL_A_CHANNELS_HEADER + 1];
+ extern const struct nla_policy ethnl_channels_set_policy[ETHTOOL_A_CHANNELS_COMBINED_COUNT + 1];
+ extern const struct nla_policy ethnl_coalesce_get_policy[ETHTOOL_A_COALESCE_HEADER + 1];
+ extern const struct nla_policy ethnl_coalesce_set_policy[ETHTOOL_A_COALESCE_RATE_SAMPLE_INTERVAL + 1];
+ extern const struct nla_policy ethnl_pause_get_policy[ETHTOOL_A_PAUSE_HEADER + 1];
+ extern const struct nla_policy ethnl_pause_set_policy[ETHTOOL_A_PAUSE_TX + 1];
+ extern const struct nla_policy ethnl_eee_get_policy[ETHTOOL_A_EEE_HEADER + 1];
+ extern const struct nla_policy ethnl_eee_set_policy[ETHTOOL_A_EEE_TX_LPI_TIMER + 1];
+ extern const struct nla_policy ethnl_tsinfo_get_policy[ETHTOOL_A_TSINFO_HEADER + 1];
+ extern const struct nla_policy ethnl_cable_test_act_policy[ETHTOOL_A_CABLE_TEST_HEADER + 1];
+ extern const struct nla_policy ethnl_cable_test_tdr_act_policy[ETHTOOL_A_CABLE_TEST_TDR_CFG + 1];
+ extern const struct nla_policy ethnl_tunnel_info_get_policy[ETHTOOL_A_TUNNEL_INFO_HEADER + 1];
++>>>>>>> a0de1cd35687 (ethtool: specify which header flags are supported per command)
  
  int ethnl_set_linkinfo(struct sk_buff *skb, struct genl_info *info);
  int ethnl_set_linkmodes(struct sk_buff *skb, struct genl_info *info);
diff --cc net/ethtool/pause.c
index 8df854266d33,09998dc5c185..000000000000
--- a/net/ethtool/pause.c
+++ b/net/ethtool/pause.c
@@@ -15,14 -16,17 +15,20 @@@ struct pause_reply_data 
  #define PAUSE_REPDATA(__reply_base) \
  	container_of(__reply_base, struct pause_reply_data, base)
  
++<<<<<<< HEAD
 +const struct nla_policy ethnl_pause_get_policy[ETHTOOL_A_PAUSE_MAX + 1] = {
 +	[ETHTOOL_A_PAUSE_UNSPEC]		= { .type = NLA_REJECT },
 +	[ETHTOOL_A_PAUSE_HEADER]		= { .type = NLA_NESTED },
 +	[ETHTOOL_A_PAUSE_AUTONEG]		= { .type = NLA_REJECT },
 +	[ETHTOOL_A_PAUSE_RX]			= { .type = NLA_REJECT },
 +	[ETHTOOL_A_PAUSE_TX]			= { .type = NLA_REJECT },
++=======
+ const struct nla_policy ethnl_pause_get_policy[] = {
+ 	[ETHTOOL_A_PAUSE_HEADER]		=
+ 		NLA_POLICY_NESTED(ethnl_header_policy_stats),
++>>>>>>> a0de1cd35687 (ethtool: specify which header flags are supported per command)
  };
  
 -static void ethtool_stats_init(u64 *stats, unsigned int n)
 -{
 -	while (n--)
 -		stats[n] = ETHTOOL_STAT_NOT_SET;
 -}
 -
  static int pause_prepare_data(const struct ethnl_req_info *req_base,
  			      struct ethnl_reply_data *reply_base,
  			      struct genl_info *info)
* Unmerged path net/ethtool/netlink.c
* Unmerged path net/ethtool/netlink.h
* Unmerged path net/ethtool/pause.c
