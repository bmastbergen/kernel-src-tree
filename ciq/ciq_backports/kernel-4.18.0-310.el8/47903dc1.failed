KVM: SVM: Define actual size of IOPM and MSRPM tables

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Krish Sadhukhan <krish.sadhukhan@oracle.com>
commit 47903dc10e7ebb876c9a0f0522cc07a71c10273f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/47903dc1.failed

Define the actual size of the IOPM and MSRPM tables so that the actual size
can be used when initializing them and when checking the consistency of their
physical address.
These #defines are placed in svm.h so that they can be shared.

	Suggested-by: Sean Christopherson <seanjc@google.com>
	Signed-off-by: Krish Sadhukhan <krish.sadhukhan@oracle.com>
Message-Id: <20210412215611.110095-2-krish.sadhukhan@oracle.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 47903dc10e7ebb876c9a0f0522cc07a71c10273f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm/svm.c
#	arch/x86/kvm/svm/svm.h
diff --cc arch/x86/kvm/svm/svm.c
index b60ae08fb034,86e42d42637e..000000000000
--- a/arch/x86/kvm/svm/svm.c
+++ b/arch/x86/kvm/svm/svm.c
@@@ -1374,28 -1413,26 +1374,35 @@@ static void svm_free_vcpu(struct kvm_vc
  
  	svm_free_nested(svm);
  
++<<<<<<< HEAD
 +	__free_page(pfn_to_page(__sme_clr(svm->vmcb_pa) >> PAGE_SHIFT));
 +	__free_pages(virt_to_page(svm->msrpm), MSRPM_ALLOC_ORDER);
++=======
+ 	sev_free_vcpu(vcpu);
+ 
+ 	__free_page(pfn_to_page(__sme_clr(svm->vmcb01.pa) >> PAGE_SHIFT));
+ 	__free_pages(virt_to_page(svm->msrpm), get_order(MSRPM_SIZE));
++>>>>>>> 47903dc10e7e (KVM: SVM: Define actual size of IOPM and MSRPM tables)
  }
  
 -static void svm_prepare_guest_switch(struct kvm_vcpu *vcpu)
 +static void svm_vcpu_load(struct kvm_vcpu *vcpu, int cpu)
  {
  	struct vcpu_svm *svm = to_svm(vcpu);
 -	struct svm_cpu_data *sd = per_cpu(svm_data, vcpu->cpu);
 -	unsigned int i;
 +	struct svm_cpu_data *sd = per_cpu(svm_data, cpu);
 +	int i;
  
 -	if (svm->guest_state_loaded)
 -		return;
 +	if (unlikely(cpu != vcpu->cpu)) {
 +		svm->asid_generation = 0;
 +		vmcb_mark_all_dirty(svm->vmcb);
 +	}
 +
 +#ifdef CONFIG_X86_64
 +	rdmsrl(MSR_GS_BASE, to_svm(vcpu)->host.gs_base);
 +#endif
 +	savesegment(fs, svm->host.fs);
 +	savesegment(gs, svm->host.gs);
 +	svm->host.ldt = kvm_read_ldt();
  
 -	/*
 -	 * Certain MSRs are restored on VMEXIT (sev-es), or vmload of host save
 -	 * area (non-sev-es). Save ones that aren't so we can restore them
 -	 * individually later.
 -	 */
  	for (i = 0; i < NR_HOST_SAVE_USER_MSRS; i++)
  		rdmsrl(host_save_user_msrs[i], svm->host_user_msrs[i]);
  
diff --cc arch/x86/kvm/svm/svm.h
index a00ba3364393,7deb7a057004..000000000000
--- a/arch/x86/kvm/svm/svm.h
+++ b/arch/x86/kvm/svm/svm.h
@@@ -23,17 -24,14 +23,24 @@@
  #define __sme_page_pa(x) __sme_set(page_to_pfn(x) << PAGE_SHIFT)
  
  static const u32 host_save_user_msrs[] = {
 +#ifdef CONFIG_X86_64
 +	MSR_STAR, MSR_LSTAR, MSR_CSTAR, MSR_SYSCALL_MASK, MSR_KERNEL_GS_BASE,
 +	MSR_FS_BASE,
 +#endif
 +	MSR_IA32_SYSENTER_CS, MSR_IA32_SYSENTER_ESP, MSR_IA32_SYSENTER_EIP,
  	MSR_TSC_AUX,
  };
 +
  #define NR_HOST_SAVE_USER_MSRS ARRAY_SIZE(host_save_user_msrs)
  
++<<<<<<< HEAD
 +#define MAX_DIRECT_ACCESS_MSRS	15
++=======
+ #define	IOPM_SIZE PAGE_SIZE * 3
+ #define	MSRPM_SIZE PAGE_SIZE * 2
+ 
+ #define MAX_DIRECT_ACCESS_MSRS	20
++>>>>>>> 47903dc10e7e (KVM: SVM: Define actual size of IOPM and MSRPM tables)
  #define MSRPM_OFFSETS	16
  extern u32 msrpm_offsets[MSRPM_OFFSETS] __read_mostly;
  extern bool npt_enabled;
* Unmerged path arch/x86/kvm/svm/svm.c
* Unmerged path arch/x86/kvm/svm/svm.h
