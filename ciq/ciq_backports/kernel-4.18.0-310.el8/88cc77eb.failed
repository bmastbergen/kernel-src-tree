RDMA/rxe: Fix misleading comments and names

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Bob Pearson <rpearsonhpe@gmail.com>
commit 88cc77eb8bd05fd185a7d142dedc6e406c5c35b6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/88cc77eb.failed

The names and comments of the 'unlocked' pool APIs are very misleading and
not what was intended. This patch replaces 'rxe_xxx_nl' with
'rxe_xxx_locked' with comments indicating that the caller is expected to
hold the rxe pool lock.

Link: https://lore.kernel.org/r/20210125211641.2694-3-rpearson@hpe.com
	Reported-by: Hillf Danton <hdanton@sina.com>
	Suggested-by: Jason Gunthorpe <jgg@nvidia.com>
	Signed-off-by: Bob Pearson <rpearson@hpe.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit 88cc77eb8bd05fd185a7d142dedc6e406c5c35b6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/sw/rxe/rxe_pool.c
#	drivers/infiniband/sw/rxe/rxe_pool.h
diff --cc drivers/infiniband/sw/rxe/rxe_pool.c
index 3727f20dbe87,5ca54e09cd0e..000000000000
--- a/drivers/infiniband/sw/rxe/rxe_pool.c
+++ b/drivers/infiniband/sw/rxe/rxe_pool.c
@@@ -322,53 -266,119 +322,151 @@@ out
  	return;
  }
  
++<<<<<<< HEAD
++=======
+ void __rxe_add_key_locked(struct rxe_pool_entry *elem, void *key)
+ {
+ 	struct rxe_pool *pool = elem->pool;
+ 
+ 	memcpy((u8 *)elem + pool->key.key_offset, key, pool->key.key_size);
+ 	insert_key(pool, elem);
+ }
+ 
++>>>>>>> 88cc77eb8bd0 (RDMA/rxe: Fix misleading comments and names)
  void __rxe_add_key(struct rxe_pool_entry *elem, void *key)
  {
  	struct rxe_pool *pool = elem->pool;
  	unsigned long flags;
  
  	write_lock_irqsave(&pool->pool_lock, flags);
++<<<<<<< HEAD
 +	memcpy((u8 *)elem + pool->key.key_offset, key, pool->key.key_size);
 +	insert_key(pool, elem);
 +	write_unlock_irqrestore(&pool->pool_lock, flags);
 +}
 +
++=======
+ 	__rxe_add_key_locked(elem, key);
+ 	write_unlock_irqrestore(&pool->pool_lock, flags);
+ }
+ 
+ void __rxe_drop_key_locked(struct rxe_pool_entry *elem)
+ {
+ 	struct rxe_pool *pool = elem->pool;
+ 
+ 	rb_erase(&elem->key_node, &pool->key.tree);
+ }
+ 
++>>>>>>> 88cc77eb8bd0 (RDMA/rxe: Fix misleading comments and names)
  void __rxe_drop_key(struct rxe_pool_entry *elem)
  {
  	struct rxe_pool *pool = elem->pool;
  	unsigned long flags;
  
  	write_lock_irqsave(&pool->pool_lock, flags);
++<<<<<<< HEAD
 +	rb_erase(&elem->key_node, &pool->key.tree);
 +	write_unlock_irqrestore(&pool->pool_lock, flags);
 +}
 +
++=======
+ 	__rxe_drop_key_locked(elem);
+ 	write_unlock_irqrestore(&pool->pool_lock, flags);
+ }
+ 
+ void __rxe_add_index_locked(struct rxe_pool_entry *elem)
+ {
+ 	struct rxe_pool *pool = elem->pool;
+ 
+ 	elem->index = alloc_index(pool);
+ 	insert_index(pool, elem);
+ }
+ 
++>>>>>>> 88cc77eb8bd0 (RDMA/rxe: Fix misleading comments and names)
  void __rxe_add_index(struct rxe_pool_entry *elem)
  {
  	struct rxe_pool *pool = elem->pool;
  	unsigned long flags;
  
  	write_lock_irqsave(&pool->pool_lock, flags);
++<<<<<<< HEAD
 +	elem->index = alloc_index(pool);
 +	insert_index(pool, elem);
 +	write_unlock_irqrestore(&pool->pool_lock, flags);
 +}
 +
++=======
+ 	__rxe_add_index_locked(elem);
+ 	write_unlock_irqrestore(&pool->pool_lock, flags);
+ }
+ 
+ void __rxe_drop_index_locked(struct rxe_pool_entry *elem)
+ {
+ 	struct rxe_pool *pool = elem->pool;
+ 
+ 	clear_bit(elem->index - pool->index.min_index, pool->index.table);
+ 	rb_erase(&elem->index_node, &pool->index.tree);
+ }
+ 
++>>>>>>> 88cc77eb8bd0 (RDMA/rxe: Fix misleading comments and names)
  void __rxe_drop_index(struct rxe_pool_entry *elem)
  {
  	struct rxe_pool *pool = elem->pool;
  	unsigned long flags;
  
  	write_lock_irqsave(&pool->pool_lock, flags);
++<<<<<<< HEAD
 +	clear_bit(elem->index - pool->index.min_index, pool->index.table);
 +	rb_erase(&elem->index_node, &pool->index.tree);
 +	write_unlock_irqrestore(&pool->pool_lock, flags);
 +}
 +
++=======
+ 	__rxe_drop_index_locked(elem);
+ 	write_unlock_irqrestore(&pool->pool_lock, flags);
+ }
+ 
+ void *rxe_alloc_locked(struct rxe_pool *pool)
+ {
+ 	struct rxe_type_info *info = &rxe_type_info[pool->type];
+ 	struct rxe_pool_entry *elem;
+ 	u8 *obj;
+ 
+ 	if (pool->state != RXE_POOL_STATE_VALID)
+ 		return NULL;
+ 
+ 	kref_get(&pool->ref_cnt);
+ 
+ 	if (!ib_device_try_get(&pool->rxe->ib_dev))
+ 		goto out_put_pool;
+ 
+ 	if (atomic_inc_return(&pool->num_elem) > pool->max_elem)
+ 		goto out_cnt;
+ 
+ 	obj = kzalloc(info->size, GFP_ATOMIC);
+ 	if (!obj)
+ 		goto out_cnt;
+ 
+ 	elem = (struct rxe_pool_entry *)(obj + info->elem_offset);
+ 
+ 	elem->pool = pool;
+ 	kref_init(&elem->ref_cnt);
+ 
+ 	return obj;
+ 
+ out_cnt:
+ 	atomic_dec(&pool->num_elem);
+ 	ib_device_put(&pool->rxe->ib_dev);
+ out_put_pool:
+ 	rxe_pool_put(pool);
+ 	return NULL;
+ }
+ 
++>>>>>>> 88cc77eb8bd0 (RDMA/rxe: Fix misleading comments and names)
  void *rxe_alloc(struct rxe_pool *pool)
  {
 -	unsigned long flags;
 -	struct rxe_type_info *info = &rxe_type_info[pool->type];
  	struct rxe_pool_entry *elem;
 -	u8 *obj;
 +	unsigned long flags;
  
  	might_sleep_if(!(pool->flags & RXE_POOL_ATOMIC));
  
@@@ -482,17 -504,16 +580,21 @@@ void *rxe_pool_get_index(struct rxe_poo
  
  out:
  	read_unlock_irqrestore(&pool->pool_lock, flags);
 -	return obj;
 +	return node ? elem : NULL;
  }
  
++<<<<<<< HEAD
 +void *rxe_pool_get_key(struct rxe_pool *pool, void *key)
++=======
+ void *rxe_pool_get_key_locked(struct rxe_pool *pool, void *key)
++>>>>>>> 88cc77eb8bd0 (RDMA/rxe: Fix misleading comments and names)
  {
 -	struct rxe_type_info *info = &rxe_type_info[pool->type];
 -	struct rb_node *node;
 -	struct rxe_pool_entry *elem;
 -	u8 *obj = NULL;
 +	struct rb_node *node = NULL;
 +	struct rxe_pool_entry *elem = NULL;
  	int cmp;
 +	unsigned long flags;
 +
 +	read_lock_irqsave(&pool->pool_lock, flags);
  
  	if (pool->state != RXE_POOL_STATE_VALID)
  		goto out;
@@@ -513,10 -534,25 +615,23 @@@
  			break;
  	}
  
 -	if (node) {
 +	if (node)
  		kref_get(&elem->ref_cnt);
 -		obj = (u8 *)elem - info->elem_offset;
 -	} else {
 -		obj = NULL;
 -	}
  
  out:
++<<<<<<< HEAD
++=======
+ 	return obj;
+ }
+ 
+ void *rxe_pool_get_key(struct rxe_pool *pool, void *key)
+ {
+ 	u8 *obj = NULL;
+ 	unsigned long flags;
+ 
+ 	read_lock_irqsave(&pool->pool_lock, flags);
+ 	obj = rxe_pool_get_key_locked(pool, key);
++>>>>>>> 88cc77eb8bd0 (RDMA/rxe: Fix misleading comments and names)
  	read_unlock_irqrestore(&pool->pool_lock, flags);
 -
 -	return obj;
 +	return node ? elem : NULL;
  }
diff --cc drivers/infiniband/sw/rxe/rxe_pool.h
index e1a24bca99de,a75ac2d2847a..000000000000
--- a/drivers/infiniband/sw/rxe/rxe_pool.h
+++ b/drivers/infiniband/sw/rxe/rxe_pool.h
@@@ -113,44 -106,72 +113,100 @@@ int rxe_pool_init(struct rxe_dev *rxe, 
  /* free resources from object pool */
  void rxe_pool_cleanup(struct rxe_pool *pool);
  
- /* allocate an object from pool */
+ /* allocate an object from pool holding and not holding the pool lock */
+ void *rxe_alloc_locked(struct rxe_pool *pool);
+ 
++<<<<<<< HEAD
++=======
  void *rxe_alloc(struct rxe_pool *pool);
  
++>>>>>>> 88cc77eb8bd0 (RDMA/rxe: Fix misleading comments and names)
  /* connect already allocated object to pool */
  int __rxe_add_to_pool(struct rxe_pool *pool, struct rxe_pool_entry *elem);
  
  #define rxe_add_to_pool(pool, obj) __rxe_add_to_pool(pool, &(obj)->pelem)
  
  /* assign an index to an indexed object and insert object into
++<<<<<<< HEAD
 + *  pool's rb tree
++=======
+  *  pool's rb tree holding and not holding the pool_lock
++>>>>>>> 88cc77eb8bd0 (RDMA/rxe: Fix misleading comments and names)
   */
+ void __rxe_add_index_locked(struct rxe_pool_entry *elem);
+ 
+ #define rxe_add_index_locked(obj) __rxe_add_index_locked(&(obj)->pelem)
+ 
  void __rxe_add_index(struct rxe_pool_entry *elem);
  
  #define rxe_add_index(obj) __rxe_add_index(&(obj)->pelem)
  
++<<<<<<< HEAD
 +/* drop an index and remove object from rb tree */
++=======
+ /* drop an index and remove object from rb tree
+  * holding and not holding the pool_lock
+  */
+ void __rxe_drop_index_locked(struct rxe_pool_entry *elem);
+ 
+ #define rxe_drop_index_locked(obj) __rxe_drop_index_locked(&(obj)->pelem)
+ 
++>>>>>>> 88cc77eb8bd0 (RDMA/rxe: Fix misleading comments and names)
  void __rxe_drop_index(struct rxe_pool_entry *elem);
  
  #define rxe_drop_index(obj) __rxe_drop_index(&(obj)->pelem)
  
  /* assign a key to a keyed object and insert object into
++<<<<<<< HEAD
 + *  pool's rb tree
++=======
+  * pool's rb tree holding and not holding pool_lock
++>>>>>>> 88cc77eb8bd0 (RDMA/rxe: Fix misleading comments and names)
   */
+ void __rxe_add_key_locked(struct rxe_pool_entry *elem, void *key);
+ 
+ #define rxe_add_key_locked(obj, key) __rxe_add_key_locked(&(obj)->pelem, key)
+ 
  void __rxe_add_key(struct rxe_pool_entry *elem, void *key);
  
  #define rxe_add_key(obj, key) __rxe_add_key(&(obj)->pelem, key)
  
++<<<<<<< HEAD
 +/* remove elem from rb tree */
++=======
+ /* remove elem from rb tree holding and not holding the pool_lock */
+ void __rxe_drop_key_locked(struct rxe_pool_entry *elem);
+ 
+ #define rxe_drop_key_locked(obj) __rxe_drop_key_locked(&(obj)->pelem)
+ 
++>>>>>>> 88cc77eb8bd0 (RDMA/rxe: Fix misleading comments and names)
  void __rxe_drop_key(struct rxe_pool_entry *elem);
  
  #define rxe_drop_key(obj) __rxe_drop_key(&(obj)->pelem)
  
++<<<<<<< HEAD
 +/* lookup an indexed object from index. takes a reference on object */
 +void *rxe_pool_get_index(struct rxe_pool *pool, u32 index);
 +
 +/* lookup keyed object from key. takes a reference on the object */
 +void *rxe_pool_get_key(struct rxe_pool *pool, void *key);
 +
++=======
+ /* lookup an indexed object from index holding and not holding the pool_lock.
+  * takes a reference on object
+  */
+ void *rxe_pool_get_index_locked(struct rxe_pool *pool, u32 index);
+ 
+ void *rxe_pool_get_index(struct rxe_pool *pool, u32 index);
+ 
+ /* lookup keyed object from key holding and not holding the pool_lock.
+  * takes a reference on the objecti
+  */
+ void *rxe_pool_get_key_locked(struct rxe_pool *pool, void *key);
+ 
+ void *rxe_pool_get_key(struct rxe_pool *pool, void *key);
+ 
++>>>>>>> 88cc77eb8bd0 (RDMA/rxe: Fix misleading comments and names)
  /* cleanup an object when all references are dropped */
  void rxe_elem_release(struct kref *kref);
  
diff --git a/drivers/infiniband/sw/rxe/rxe_mcast.c b/drivers/infiniband/sw/rxe/rxe_mcast.c
index 5be47ce7d319..0ea9a5aa4ec0 100644
--- a/drivers/infiniband/sw/rxe/rxe_mcast.c
+++ b/drivers/infiniband/sw/rxe/rxe_mcast.c
@@ -15,18 +15,18 @@ static struct rxe_mc_grp *create_grp(struct rxe_dev *rxe,
 	int err;
 	struct rxe_mc_grp *grp;
 
-	grp = rxe_alloc_nl(&rxe->mc_grp_pool);
+	grp = rxe_alloc_locked(&rxe->mc_grp_pool);
 	if (!grp)
 		return ERR_PTR(-ENOMEM);
 
 	INIT_LIST_HEAD(&grp->qp_list);
 	spin_lock_init(&grp->mcg_lock);
 	grp->rxe = rxe;
-	rxe_add_key_nl(grp, mgid);
+	rxe_add_key_locked(grp, mgid);
 
 	err = rxe_mcast_add(rxe, mgid);
 	if (unlikely(err)) {
-		rxe_drop_key_nl(grp);
+		rxe_drop_key_locked(grp);
 		rxe_drop_ref(grp);
 		return ERR_PTR(err);
 	}
@@ -47,7 +47,7 @@ int rxe_mcast_get_grp(struct rxe_dev *rxe, union ib_gid *mgid,
 
 	write_lock_irqsave(&pool->pool_lock, flags);
 
-	grp = rxe_pool_get_key_nl(pool, mgid);
+	grp = rxe_pool_get_key_locked(pool, mgid);
 	if (grp)
 		goto done;
 
* Unmerged path drivers/infiniband/sw/rxe/rxe_pool.c
* Unmerged path drivers/infiniband/sw/rxe/rxe_pool.h
