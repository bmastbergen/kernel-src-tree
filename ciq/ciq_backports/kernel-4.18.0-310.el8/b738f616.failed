kcsan: Introduce kcsan_value_change type

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Marco Elver <elver@google.com>
commit b738f6169f1260b4ed5bd9f220b1c84d79f3ab8d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/b738f616.failed

Introduces kcsan_value_change type, which explicitly points out if we
either observed a value-change (TRUE), or we could not observe one but
cannot rule out a value-change happened (MAYBE). The MAYBE state can
either be reported or not, depending on configuration preferences.

A follow-up patch introduces the FALSE state, which should never be
reported.

No functional change intended.

	Acked-by: John Hubbard <jhubbard@nvidia.com>
	Signed-off-by: Marco Elver <elver@google.com>
	Signed-off-by: Paul E. McKenney <paulmck@kernel.org>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit b738f6169f1260b4ed5bd9f220b1c84d79f3ab8d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/kcsan/core.c
#	kernel/kcsan/kcsan.h
#	kernel/kcsan/report.c
diff --cc kernel/kcsan/core.c
index c40f2454f5a3,3f89801161d3..000000000000
--- a/kernel/kcsan/core.c
+++ b/kernel/kcsan/core.c
@@@ -421,14 -470,25 +435,31 @@@ static noinline void kcsan_setup_watchp
  		/*
  		 * No need to increment 'data_races' counter, as the racing
  		 * thread already did.
 -		 *
 -		 * Count 'assert_failures' for each failed ASSERT access,
 -		 * therefore both this thread and the racing thread may
 -		 * increment this counter.
  		 */
++<<<<<<< HEAD
 +		kcsan_report(ptr, size, is_write, size > 8 || value_change,
 +			     smp_processor_id(), KCSAN_REPORT_RACE_SIGNAL);
 +	} else if (value_change) {
++=======
+ 		if (is_assert && value_change == KCSAN_VALUE_CHANGE_TRUE)
+ 			kcsan_counter_inc(KCSAN_COUNTER_ASSERT_FAILURES);
+ 
+ 		kcsan_report(ptr, size, type, value_change, smp_processor_id(),
+ 			     KCSAN_REPORT_RACE_SIGNAL);
+ 	} else if (value_change == KCSAN_VALUE_CHANGE_TRUE) {
++>>>>>>> b738f6169f12 (kcsan: Introduce kcsan_value_change type)
  		/* Inferring a race, since the value should not have changed. */
 -
  		kcsan_counter_inc(KCSAN_COUNTER_RACES_UNKNOWN_ORIGIN);
++<<<<<<< HEAD
 +		if (IS_ENABLED(CONFIG_KCSAN_REPORT_RACE_UNKNOWN_ORIGIN))
 +			kcsan_report(ptr, size, is_write, true,
++=======
+ 		if (is_assert)
+ 			kcsan_counter_inc(KCSAN_COUNTER_ASSERT_FAILURES);
+ 
+ 		if (IS_ENABLED(CONFIG_KCSAN_REPORT_RACE_UNKNOWN_ORIGIN) || is_assert)
+ 			kcsan_report(ptr, size, type, KCSAN_VALUE_CHANGE_TRUE,
++>>>>>>> b738f6169f12 (kcsan: Introduce kcsan_value_change type)
  				     smp_processor_id(),
  				     KCSAN_REPORT_RACE_UNKNOWN_ORIGIN);
  	}
diff --cc kernel/kcsan/kcsan.h
index 1bb2f1c0d61e,83a79b08b550..000000000000
--- a/kernel/kcsan/kcsan.h
+++ b/kernel/kcsan/kcsan.h
@@@ -79,8 -86,24 +79,24 @@@ void kcsan_counter_dec(enum kcsan_count
   * Returns true if data races in the function symbol that maps to func_addr
   * (offsets are ignored) should *not* be reported.
   */
 -extern bool kcsan_skip_report_debugfs(unsigned long func_addr);
 +bool kcsan_skip_report_debugfs(unsigned long func_addr);
  
+ /*
+  * Value-change states.
+  */
+ enum kcsan_value_change {
+ 	/*
+ 	 * Did not observe a value-change, however, it is valid to report the
+ 	 * race, depending on preferences.
+ 	 */
+ 	KCSAN_VALUE_CHANGE_MAYBE,
+ 
+ 	/*
+ 	 * The value was observed to change, and the race should be reported.
+ 	 */
+ 	KCSAN_VALUE_CHANGE_TRUE,
+ };
+ 
  enum kcsan_report_type {
  	/*
  	 * The thread that set up the watchpoint and briefly stalled was
@@@ -102,7 -125,9 +118,13 @@@
  /*
   * Print a race report from thread that encountered the race.
   */
++<<<<<<< HEAD
 +void kcsan_report(const volatile void *ptr, size_t size, bool is_write,
 +		  bool value_change, int cpu_id, enum kcsan_report_type type);
++=======
+ extern void kcsan_report(const volatile void *ptr, size_t size, int access_type,
+ 			 enum kcsan_value_change value_change, int cpu_id,
+ 			 enum kcsan_report_type type);
++>>>>>>> b738f6169f12 (kcsan: Introduce kcsan_value_change type)
  
  #endif /* _KERNEL_KCSAN_KCSAN_H */
diff --cc kernel/kcsan/report.c
index ce5abefc35a9,d871476dc134..000000000000
--- a/kernel/kcsan/report.c
+++ b/kernel/kcsan/report.c
@@@ -41,11 -76,81 +41,36 @@@ static DEFINE_SPINLOCK(report_lock)
  /*
   * Special rules to skip reporting.
   */
++<<<<<<< HEAD
 +static bool skip_report(bool is_write, bool value_change,
 +			unsigned long top_frame)
 +{
 +	if (IS_ENABLED(CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY) && is_write &&
 +	    !value_change) {
++=======
+ static bool
+ skip_report(enum kcsan_value_change value_change, unsigned long top_frame)
+ {
+ 	/*
+ 	 * The first call to skip_report always has value_change==TRUE, since we
+ 	 * cannot know the value written of an instrumented access. For the 2nd
+ 	 * call there are 6 cases with CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY:
+ 	 *
+ 	 * 1. read watchpoint, conflicting write (value_change==TRUE): report;
+ 	 * 2. read watchpoint, conflicting write (value_change==MAYBE): skip;
+ 	 * 3. write watchpoint, conflicting write (value_change==TRUE): report;
+ 	 * 4. write watchpoint, conflicting write (value_change==MAYBE): skip;
+ 	 * 5. write watchpoint, conflicting read (value_change==MAYBE): skip;
+ 	 * 6. write watchpoint, conflicting read (value_change==TRUE): report;
+ 	 *
+ 	 * Cases 1-4 are intuitive and expected; case 5 ensures we do not report
+ 	 * data races where the write may have rewritten the same value; case 6
+ 	 * is possible either if the size is larger than what we check value
+ 	 * changes for or the access type is KCSAN_ACCESS_ASSERT.
+ 	 */
+ 	if (IS_ENABLED(CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY) &&
+ 	    value_change == KCSAN_VALUE_CHANGE_MAYBE) {
++>>>>>>> b738f6169f12 (kcsan: Introduce kcsan_value_change type)
  		/*
  		 * The access is a write, but the data value did not change.
  		 *
@@@ -112,8 -245,8 +137,13 @@@ static int sym_strcmp(void *addr1, voi
  /*
   * Returns true if a report was generated, false otherwise.
   */
++<<<<<<< HEAD
 +static bool print_report(const volatile void *ptr, size_t size, bool is_write,
 +			 bool value_change, int cpu_id,
++=======
+ static bool print_report(const volatile void *ptr, size_t size, int access_type,
+ 			 enum kcsan_value_change value_change, int cpu_id,
++>>>>>>> b738f6169f12 (kcsan: Introduce kcsan_value_change type)
  			 enum kcsan_report_type type)
  {
  	unsigned long stack_entries[NUM_STACK_ENTRIES] = { 0 };
@@@ -125,7 -259,7 +155,11 @@@
  	/*
  	 * Must check report filter rules before starting to print.
  	 */
++<<<<<<< HEAD
 +	if (skip_report(is_write, true, stack_entries[skipnr]))
++=======
+ 	if (skip_report(KCSAN_VALUE_CHANGE_TRUE, stack_entries[skipnr]))
++>>>>>>> b738f6169f12 (kcsan: Introduce kcsan_value_change type)
  		return false;
  
  	if (type == KCSAN_REPORT_RACE_SIGNAL) {
@@@ -341,8 -476,10 +375,14 @@@ retry
  	goto retry;
  }
  
++<<<<<<< HEAD
 +void kcsan_report(const volatile void *ptr, size_t size, bool is_write,
 +		  bool value_change, int cpu_id, enum kcsan_report_type type)
++=======
+ void kcsan_report(const volatile void *ptr, size_t size, int access_type,
+ 		  enum kcsan_value_change value_change, int cpu_id,
+ 		  enum kcsan_report_type type)
++>>>>>>> b738f6169f12 (kcsan: Introduce kcsan_value_change type)
  {
  	unsigned long flags = 0;
  
* Unmerged path kernel/kcsan/core.c
* Unmerged path kernel/kcsan/kcsan.h
* Unmerged path kernel/kcsan/report.c
