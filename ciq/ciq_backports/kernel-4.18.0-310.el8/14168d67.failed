NFSD: Remove the RETURN_STATUS() macro

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 14168d678a0fa0645609417ad9c384a7c6f895fd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/14168d67.failed

Refactor: I'm about to change the return value from .pc_func. Clear
the way by replacing the RETURN_STATUS() macro with logic that
plants the status code directly into the response structure.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit 14168d678a0fa0645609417ad9c384a7c6f895fd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs3proc.c
diff --cc fs/nfsd/nfs3proc.c
index 18ff6c873ee5,1d2c149e5ff4..000000000000
--- a/fs/nfsd/nfs3proc.c
+++ b/fs/nfsd/nfs3proc.c
@@@ -199,13 -187,16 +187,24 @@@ nfsd3_proc_write(struct svc_rqst *rqstp
  	resp->committed = argp->stable;
  	nvecs = svc_fill_write_vector(rqstp, rqstp->rq_arg.pages,
  				      &argp->first, cnt);
++<<<<<<< HEAD
 +	if (!nvecs)
 +		RETURN_STATUS(nfserr_io);
 +	nfserr = nfsd_write(rqstp, &resp->fh, argp->offset,
 +			    rqstp->rq_vec, nvecs, &cnt,
 +			    resp->committed);
++=======
+ 	if (!nvecs) {
+ 		resp->status = nfserr_io;
+ 		goto out;
+ 	}
+ 	resp->status = nfsd_write(rqstp, &resp->fh, argp->offset,
+ 				  rqstp->rq_vec, nvecs, &cnt,
+ 				  resp->committed, resp->verf);
++>>>>>>> 14168d678a0f (NFSD: Remove the RETURN_STATUS() macro)
  	resp->count = cnt;
- 	RETURN_STATUS(nfserr);
+ out:
+ 	return resp->status;
  }
  
  /*
@@@ -679,13 -670,16 +678,22 @@@ nfsd3_proc_commit(struct svc_rqst *rqst
  				argp->count,
  				(unsigned long long) argp->offset);
  
- 	if (argp->offset > NFS_OFFSET_MAX)
- 		RETURN_STATUS(nfserr_inval);
+ 	if (argp->offset > NFS_OFFSET_MAX) {
+ 		resp->status = nfserr_inval;
+ 		goto out;
+ 	}
  
  	fh_copy(&resp->fh, &argp->fh);
++<<<<<<< HEAD
 +	nfserr = nfsd_commit(rqstp, &resp->fh, argp->offset, argp->count);
 +
 +	RETURN_STATUS(nfserr);
++=======
+ 	resp->status = nfsd_commit(rqstp, &resp->fh, argp->offset,
+ 				   argp->count, resp->verf);
+ out:
+ 	return resp->status;
++>>>>>>> 14168d678a0f (NFSD: Remove the RETURN_STATUS() macro)
  }
  
  
diff --git a/fs/nfsd/nfs3acl.c b/fs/nfsd/nfs3acl.c
index 614168675c17..3fee24dee98c 100644
--- a/fs/nfsd/nfs3acl.c
+++ b/fs/nfsd/nfs3acl.c
@@ -13,8 +13,6 @@
 #include "xdr3.h"
 #include "vfs.h"
 
-#define RETURN_STATUS(st)	{ resp->status = (st); return (st); }
-
 /*
  * NULL call.
  */
@@ -34,17 +32,18 @@ static __be32 nfsd3_proc_getacl(struct svc_rqst *rqstp)
 	struct posix_acl *acl;
 	struct inode *inode;
 	svc_fh *fh;
-	__be32 nfserr = 0;
 
 	fh = fh_copy(&resp->fh, &argp->fh);
-	nfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_NOP);
-	if (nfserr)
-		RETURN_STATUS(nfserr);
+	resp->status = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_NOP);
+	if (resp->status != nfs_ok)
+		goto out;
 
 	inode = d_inode(fh->fh_dentry);
 
-	if (argp->mask & ~NFS_ACL_MASK)
-		RETURN_STATUS(nfserr_inval);
+	if (argp->mask & ~NFS_ACL_MASK) {
+		resp->status = nfserr_inval;
+		goto out;
+	}
 	resp->mask = argp->mask;
 
 	if (resp->mask & (NFS_ACL|NFS_ACLCNT)) {
@@ -54,7 +53,7 @@ static __be32 nfsd3_proc_getacl(struct svc_rqst *rqstp)
 			acl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);
 		}
 		if (IS_ERR(acl)) {
-			nfserr = nfserrno(PTR_ERR(acl));
+			resp->status = nfserrno(PTR_ERR(acl));
 			goto fail;
 		}
 		resp->acl_access = acl;
@@ -64,19 +63,20 @@ static __be32 nfsd3_proc_getacl(struct svc_rqst *rqstp)
 		   of a non-directory! */
 		acl = get_acl(inode, ACL_TYPE_DEFAULT);
 		if (IS_ERR(acl)) {
-			nfserr = nfserrno(PTR_ERR(acl));
+			resp->status = nfserrno(PTR_ERR(acl));
 			goto fail;
 		}
 		resp->acl_default = acl;
 	}
 
 	/* resp->acl_{access,default} are released in nfs3svc_release_getacl. */
-	RETURN_STATUS(0);
+out:
+	return resp->status;
 
 fail:
 	posix_acl_release(resp->acl_access);
 	posix_acl_release(resp->acl_default);
-	RETURN_STATUS(nfserr);
+	goto out;
 }
 
 /*
@@ -88,12 +88,11 @@ static __be32 nfsd3_proc_setacl(struct svc_rqst *rqstp)
 	struct nfsd3_attrstat *resp = rqstp->rq_resp;
 	struct inode *inode;
 	svc_fh *fh;
-	__be32 nfserr = 0;
 	int error;
 
 	fh = fh_copy(&resp->fh, &argp->fh);
-	nfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);
-	if (nfserr)
+	resp->status = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);
+	if (resp->status != nfs_ok)
 		goto out;
 
 	inode = d_inode(fh->fh_dentry);
@@ -113,13 +112,13 @@ static __be32 nfsd3_proc_setacl(struct svc_rqst *rqstp)
 	fh_unlock(fh);
 	fh_drop_write(fh);
 out_errno:
-	nfserr = nfserrno(error);
+	resp->status = nfserrno(error);
 out:
 	/* argp->acl_{access,default} may have been allocated in
 	   nfs3svc_decode_setaclargs. */
 	posix_acl_release(argp->acl_access);
 	posix_acl_release(argp->acl_default);
-	RETURN_STATUS(nfserr);
+	return resp->status;
 }
 
 /*
* Unmerged path fs/nfsd/nfs3proc.c
