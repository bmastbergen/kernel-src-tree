devlink: Add remote reload stats

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Moshe Shemesh <moshe@mellanox.com>
commit 77069ba2e3adf48c472fbbd9cbd7a4f5370b17df
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/77069ba2.failed

Add remote reload stats to hold the history of actions performed due
devlink reload commands initiated by remote host. For example, in case
firmware activation with reset finished successfully but was initiated
by remote host.

The function devlink_remote_reload_actions_performed() is exported to
enable drivers update on remote reload actions performed as it was not
initiated by their own devlink instance.

Expose devlink remote reload stats to the user through devlink dev get
command.

Examples:
$ devlink dev show
pci/0000:82:00.0:
  stats:
      reload:
        driver_reinit 2 fw_activate 1 fw_activate_no_reset 0
      remote_reload:
        driver_reinit 0 fw_activate 0 fw_activate_no_reset 0
pci/0000:82:00.1:
  stats:
      reload:
        driver_reinit 1 fw_activate 0 fw_activate_no_reset 0
      remote_reload:
        driver_reinit 1 fw_activate 1 fw_activate_no_reset 0

$ devlink dev show -jp
{
    "dev": {
        "pci/0000:82:00.0": {
            "stats": {
                "reload": {
                    "driver_reinit": 2,
                    "fw_activate": 1,
                    "fw_activate_no_reset": 0
                },
                "remote_reload": {
                    "driver_reinit": 0,
                    "fw_activate": 0,
                    "fw_activate_no_reset": 0
                }
            }
        },
        "pci/0000:82:00.1": {
            "stats": {
                "reload": {
                    "driver_reinit": 1,
                    "fw_activate": 0,
                    "fw_activate_no_reset": 0
                },
                "remote_reload": {
                    "driver_reinit": 1,
                    "fw_activate": 1,
                    "fw_activate_no_reset": 0
                }
            }
        }
    }
}

	Signed-off-by: Moshe Shemesh <moshe@mellanox.com>
	Reviewed-by: Jakub Kicinski <kuba@kernel.org>
	Reviewed-by: Jiri Pirko <jiri@nvidia.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 77069ba2e3adf48c472fbbd9cbd7a4f5370b17df)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/devlink.h
#	include/uapi/linux/devlink.h
#	net/core/devlink.c
diff --cc include/net/devlink.h
index 5414aff70555,d2771e57a278..000000000000
--- a/include/net/devlink.h
+++ b/include/net/devlink.h
@@@ -24,6 -20,14 +24,17 @@@
  #include <uapi/linux/devlink.h>
  #include <linux/xarray.h>
  
++<<<<<<< HEAD
++=======
+ #define DEVLINK_RELOAD_STATS_ARRAY_SIZE \
+ 	(__DEVLINK_RELOAD_LIMIT_MAX * __DEVLINK_RELOAD_ACTION_MAX)
+ 
+ struct devlink_dev_stats {
+ 	u32 reload_stats[DEVLINK_RELOAD_STATS_ARRAY_SIZE];
+ 	u32 remote_reload_stats[DEVLINK_RELOAD_STATS_ARRAY_SIZE];
+ };
+ 
++>>>>>>> 77069ba2e3ad (devlink: Add remote reload stats)
  struct devlink_ops;
  
  struct devlink {
diff --cc include/uapi/linux/devlink.h
index f2172c34975d,0113bc4db9f5..000000000000
--- a/include/uapi/linux/devlink.h
+++ b/include/uapi/linux/devlink.h
@@@ -462,11 -510,22 +462,26 @@@ enum devlink_attr 
  	DEVLINK_ATTR_PORT_LANES,			/* u32 */
  	DEVLINK_ATTR_PORT_SPLITTABLE,			/* u8 */
  
 -	DEVLINK_ATTR_PORT_EXTERNAL,		/* u8 */
 -	DEVLINK_ATTR_PORT_CONTROLLER_NUMBER,	/* u32 */
 +	/* Not supported in RHEL, i adding reserved fields due to keep UAPI */
 +	__RH_RESERVED_DEVLINK_ATTR_PORT_EXTERNAL,		/* u8 */
 +	__RH_RESERVED_DEVLINK_ATTR_PORT_CONTROLLER_NUMBER,	/* u32 */
  
  	DEVLINK_ATTR_FLASH_UPDATE_STATUS_TIMEOUT,	/* u64 */
++<<<<<<< HEAD
++=======
+ 	DEVLINK_ATTR_FLASH_UPDATE_OVERWRITE_MASK,	/* bitfield32 */
+ 
+ 	DEVLINK_ATTR_RELOAD_ACTION,		/* u8 */
+ 	DEVLINK_ATTR_RELOAD_ACTIONS_PERFORMED,	/* bitfield32 */
+ 	DEVLINK_ATTR_RELOAD_LIMITS,		/* bitfield32 */
+ 
+ 	DEVLINK_ATTR_DEV_STATS,			/* nested */
+ 	DEVLINK_ATTR_RELOAD_STATS,		/* nested */
+ 	DEVLINK_ATTR_RELOAD_STATS_ENTRY,	/* nested */
+ 	DEVLINK_ATTR_RELOAD_STATS_LIMIT,	/* u8 */
+ 	DEVLINK_ATTR_RELOAD_STATS_VALUE,	/* u32 */
+ 	DEVLINK_ATTR_REMOTE_RELOAD_STATS,	/* nested */
++>>>>>>> 77069ba2e3ad (devlink: Add remote reload stats)
  
  	/* add new attributes above here, update the policy in devlink.c */
  
diff --cc net/core/devlink.c
index 7ae91478c0cd,dd889334fed9..000000000000
--- a/net/core/devlink.c
+++ b/net/core/devlink.c
@@@ -466,6 -479,110 +466,113 @@@ static int devlink_nl_put_handle(struc
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ struct devlink_reload_combination {
+ 	enum devlink_reload_action action;
+ 	enum devlink_reload_limit limit;
+ };
+ 
+ static const struct devlink_reload_combination devlink_reload_invalid_combinations[] = {
+ 	{
+ 		/* can't reinitialize driver with no down time */
+ 		.action = DEVLINK_RELOAD_ACTION_DRIVER_REINIT,
+ 		.limit = DEVLINK_RELOAD_LIMIT_NO_RESET,
+ 	},
+ };
+ 
+ static bool
+ devlink_reload_combination_is_invalid(enum devlink_reload_action action,
+ 				      enum devlink_reload_limit limit)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(devlink_reload_invalid_combinations); i++)
+ 		if (devlink_reload_invalid_combinations[i].action == action &&
+ 		    devlink_reload_invalid_combinations[i].limit == limit)
+ 			return true;
+ 	return false;
+ }
+ 
+ static bool
+ devlink_reload_action_is_supported(struct devlink *devlink, enum devlink_reload_action action)
+ {
+ 	return test_bit(action, &devlink->ops->reload_actions);
+ }
+ 
+ static bool
+ devlink_reload_limit_is_supported(struct devlink *devlink, enum devlink_reload_limit limit)
+ {
+ 	return test_bit(limit, &devlink->ops->reload_limits);
+ }
+ 
+ static int devlink_reload_stat_put(struct sk_buff *msg, enum devlink_reload_action action,
+ 				   enum devlink_reload_limit limit, u32 value)
+ {
+ 	struct nlattr *reload_stats_entry;
+ 
+ 	reload_stats_entry = nla_nest_start(msg, DEVLINK_ATTR_RELOAD_STATS_ENTRY);
+ 	if (!reload_stats_entry)
+ 		return -EMSGSIZE;
+ 
+ 	if (nla_put_u8(msg, DEVLINK_ATTR_RELOAD_ACTION, action) ||
+ 	    nla_put_u8(msg, DEVLINK_ATTR_RELOAD_STATS_LIMIT, limit) ||
+ 	    nla_put_u32(msg, DEVLINK_ATTR_RELOAD_STATS_VALUE, value))
+ 		goto nla_put_failure;
+ 	nla_nest_end(msg, reload_stats_entry);
+ 	return 0;
+ 
+ nla_put_failure:
+ 	nla_nest_cancel(msg, reload_stats_entry);
+ 	return -EMSGSIZE;
+ }
+ 
+ static int devlink_reload_stats_put(struct sk_buff *msg, struct devlink *devlink, bool is_remote)
+ {
+ 	struct nlattr *reload_stats_attr;
+ 	int i, j, stat_idx;
+ 	u32 value;
+ 
+ 	if (!is_remote)
+ 		reload_stats_attr = nla_nest_start(msg, DEVLINK_ATTR_RELOAD_STATS);
+ 	else
+ 		reload_stats_attr = nla_nest_start(msg, DEVLINK_ATTR_REMOTE_RELOAD_STATS);
+ 
+ 	if (!reload_stats_attr)
+ 		return -EMSGSIZE;
+ 
+ 	for (j = 0; j <= DEVLINK_RELOAD_LIMIT_MAX; j++) {
+ 		/* Remote stats are shown even if not locally supported. Stats
+ 		 * of actions with unspecified limit are shown though drivers
+ 		 * don't need to register unspecified limit.
+ 		 */
+ 		if (!is_remote && j != DEVLINK_RELOAD_LIMIT_UNSPEC &&
+ 		    !devlink_reload_limit_is_supported(devlink, j))
+ 			continue;
+ 		for (i = 0; i <= DEVLINK_RELOAD_ACTION_MAX; i++) {
+ 			if ((!is_remote && !devlink_reload_action_is_supported(devlink, i)) ||
+ 			    i == DEVLINK_RELOAD_ACTION_UNSPEC ||
+ 			    devlink_reload_combination_is_invalid(i, j))
+ 				continue;
+ 
+ 			stat_idx = j * __DEVLINK_RELOAD_ACTION_MAX + i;
+ 			if (!is_remote)
+ 				value = devlink->stats.reload_stats[stat_idx];
+ 			else
+ 				value = devlink->stats.remote_reload_stats[stat_idx];
+ 			if (devlink_reload_stat_put(msg, i, j, value))
+ 				goto nla_put_failure;
+ 		}
+ 	}
+ 	nla_nest_end(msg, reload_stats_attr);
+ 	return 0;
+ 
+ nla_put_failure:
+ 	nla_nest_cancel(msg, reload_stats_attr);
+ 	return -EMSGSIZE;
+ }
+ 
++>>>>>>> 77069ba2e3ad (devlink: Add remote reload stats)
  static int devlink_nl_fill(struct sk_buff *msg, struct devlink *devlink,
  			   enum devlink_command cmd, u32 portid,
  			   u32 seq, int flags)
@@@ -481,6 -599,16 +588,19 @@@
  	if (nla_put_u8(msg, DEVLINK_ATTR_RELOAD_FAILED, devlink->reload_failed))
  		goto nla_put_failure;
  
++<<<<<<< HEAD
++=======
+ 	dev_stats = nla_nest_start(msg, DEVLINK_ATTR_DEV_STATS);
+ 	if (!dev_stats)
+ 		goto nla_put_failure;
+ 
+ 	if (devlink_reload_stats_put(msg, devlink, false))
+ 		goto dev_stats_nest_cancel;
+ 	if (devlink_reload_stats_put(msg, devlink, true))
+ 		goto dev_stats_nest_cancel;
+ 
+ 	nla_nest_end(msg, dev_stats);
++>>>>>>> 77069ba2e3ad (devlink: Add remote reload stats)
  	genlmsg_end(msg, hdr);
  	return 0;
  
@@@ -2972,24 -3100,120 +3092,130 @@@ bool devlink_is_reload_failed(const str
  }
  EXPORT_SYMBOL_GPL(devlink_is_reload_failed);
  
++<<<<<<< HEAD
++=======
+ static void
+ __devlink_reload_stats_update(struct devlink *devlink, u32 *reload_stats,
+ 			      enum devlink_reload_limit limit, u32 actions_performed)
+ {
+ 	unsigned long actions = actions_performed;
+ 	int stat_idx;
+ 	int action;
+ 
+ 	for_each_set_bit(action, &actions, __DEVLINK_RELOAD_ACTION_MAX) {
+ 		stat_idx = limit * __DEVLINK_RELOAD_ACTION_MAX + action;
+ 		reload_stats[stat_idx]++;
+ 	}
+ 	devlink_notify(devlink, DEVLINK_CMD_NEW);
+ }
+ 
+ static void
+ devlink_reload_stats_update(struct devlink *devlink, enum devlink_reload_limit limit,
+ 			    u32 actions_performed)
+ {
+ 	__devlink_reload_stats_update(devlink, devlink->stats.reload_stats, limit,
+ 				      actions_performed);
+ }
+ 
+ /**
+  *	devlink_remote_reload_actions_performed - Update devlink on reload actions
+  *	  performed which are not a direct result of devlink reload call.
+  *
+  *	This should be called by a driver after performing reload actions in case it was not
+  *	a result of devlink reload call. For example fw_activate was performed as a result
+  *	of devlink reload triggered fw_activate on another host.
+  *	The motivation for this function is to keep data on reload actions performed on this
+  *	function whether it was done due to direct devlink reload call or not.
+  *
+  *	@devlink: devlink
+  *	@limit: reload limit
+  *	@actions_performed: bitmask of actions performed
+  */
+ void devlink_remote_reload_actions_performed(struct devlink *devlink,
+ 					     enum devlink_reload_limit limit,
+ 					     u32 actions_performed)
+ {
+ 	if (WARN_ON(!actions_performed ||
+ 		    actions_performed & BIT(DEVLINK_RELOAD_ACTION_UNSPEC) ||
+ 		    actions_performed >= BIT(__DEVLINK_RELOAD_ACTION_MAX) ||
+ 		    limit > DEVLINK_RELOAD_LIMIT_MAX))
+ 		return;
+ 
+ 	__devlink_reload_stats_update(devlink, devlink->stats.remote_reload_stats, limit,
+ 				      actions_performed);
+ }
+ EXPORT_SYMBOL_GPL(devlink_remote_reload_actions_performed);
+ 
++>>>>>>> 77069ba2e3ad (devlink: Add remote reload stats)
  static int devlink_reload(struct devlink *devlink, struct net *dest_net,
 -			  enum devlink_reload_action action, enum devlink_reload_limit limit,
 -			  u32 *actions_performed, struct netlink_ext_ack *extack)
 +			  struct netlink_ext_ack *extack)
  {
+ 	u32 remote_reload_stats[DEVLINK_RELOAD_STATS_ARRAY_SIZE];
  	int err;
  
  	if (!devlink->reload_enabled)
  		return -EOPNOTSUPP;
  
++<<<<<<< HEAD
 +	err = devlink->ops->reload_down(devlink, !!dest_net, extack);
++=======
+ 	memcpy(remote_reload_stats, devlink->stats.remote_reload_stats,
+ 	       sizeof(remote_reload_stats));
+ 	err = devlink->ops->reload_down(devlink, !!dest_net, action, limit, extack);
++>>>>>>> 77069ba2e3ad (devlink: Add remote reload stats)
  	if (err)
  		return err;
  
  	if (dest_net && !net_eq(dest_net, devlink_net(devlink)))
  		devlink_reload_netns_change(devlink, dest_net);
  
 -	err = devlink->ops->reload_up(devlink, action, limit, actions_performed, extack);
 +	err = devlink->ops->reload_up(devlink, extack);
  	devlink_reload_failed_set(devlink, !!err);
++<<<<<<< HEAD
 +	return err;
++=======
+ 	if (err)
+ 		return err;
+ 
+ 	WARN_ON(!(*actions_performed & BIT(action)));
+ 	/* Catch driver on updating the remote action within devlink reload */
+ 	WARN_ON(memcmp(remote_reload_stats, devlink->stats.remote_reload_stats,
+ 		       sizeof(remote_reload_stats)));
+ 	devlink_reload_stats_update(devlink, limit, *actions_performed);
+ 	return 0;
+ }
+ 
+ static int
+ devlink_nl_reload_actions_performed_snd(struct devlink *devlink, u32 actions_performed,
+ 					enum devlink_command cmd, struct genl_info *info)
+ {
+ 	struct sk_buff *msg;
+ 	void *hdr;
+ 
+ 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
+ 	if (!msg)
+ 		return -ENOMEM;
+ 
+ 	hdr = genlmsg_put(msg, info->snd_portid, info->snd_seq, &devlink_nl_family, 0, cmd);
+ 	if (!hdr)
+ 		goto free_msg;
+ 
+ 	if (devlink_nl_put_handle(msg, devlink))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_bitfield32(msg, DEVLINK_ATTR_RELOAD_ACTIONS_PERFORMED, actions_performed,
+ 			       actions_performed))
+ 		goto nla_put_failure;
+ 	genlmsg_end(msg, hdr);
+ 
+ 	return genlmsg_reply(msg, info);
+ 
+ nla_put_failure:
+ 	genlmsg_cancel(msg, hdr);
+ free_msg:
+ 	nlmsg_free(msg);
+ 	return -EMSGSIZE;
++>>>>>>> 77069ba2e3ad (devlink: Add remote reload stats)
  }
  
  static int devlink_nl_cmd_reload(struct sk_buff *skb, struct genl_info *info)
* Unmerged path include/net/devlink.h
* Unmerged path include/uapi/linux/devlink.h
* Unmerged path net/core/devlink.c
