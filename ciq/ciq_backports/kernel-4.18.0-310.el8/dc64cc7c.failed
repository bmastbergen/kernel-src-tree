devlink: Add devlink reload limit option

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Moshe Shemesh <moshe@mellanox.com>
commit dc64cc7c63102ac78bac3cfbc00ef3abd7a3fdf3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/dc64cc7c.failed

Add reload limit to demand restrictions on reload actions.
Reload limits supported:
no_reset: No reset allowed, no down time allowed, no link flap and no
          configuration is lost.

By default reload limit is unspecified and so no constraints on reload
actions are required.

Some combinations of action and limit are invalid. For example, driver
can not reinitialize its entities without any downtime.

The no_reset reload limit will have usecase in this patchset to
implement restricted fw_activate on mlx5.

Have the uapi parameter of reload limit ready for future support of
multiselection.

	Signed-off-by: Moshe Shemesh <moshe@mellanox.com>
	Reviewed-by: Jiri Pirko <jiri@nvidia.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit dc64cc7c63102ac78bac3cfbc00ef3abd7a3fdf3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx4/main.c
#	drivers/net/ethernet/mellanox/mlx5/core/devlink.c
#	drivers/net/ethernet/mellanox/mlxsw/core.c
#	drivers/net/netdevsim/dev.c
#	include/net/devlink.h
#	include/uapi/linux/devlink.h
#	net/core/devlink.c
diff --cc drivers/net/ethernet/mellanox/mlx4/main.c
index 258c7a96f269,c326b434734e..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/main.c
+++ b/drivers/net/ethernet/mellanox/mlx4/main.c
@@@ -3935,6 -3946,8 +3935,11 @@@ static int mlx4_restart_one_up(struct p
  			       struct devlink *devlink);
  
  static int mlx4_devlink_reload_down(struct devlink *devlink, bool netns_change,
++<<<<<<< HEAD
++=======
+ 				    enum devlink_reload_action action,
+ 				    enum devlink_reload_limit limit,
++>>>>>>> dc64cc7c6310 (devlink: Add devlink reload limit option)
  				    struct netlink_ext_ack *extack)
  {
  	struct mlx4_priv *priv = devlink_priv(devlink);
@@@ -3951,7 -3964,8 +3956,12 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int mlx4_devlink_reload_up(struct devlink *devlink,
++=======
+ static int mlx4_devlink_reload_up(struct devlink *devlink, enum devlink_reload_action action,
+ 				  enum devlink_reload_limit limit, u32 *actions_performed,
++>>>>>>> dc64cc7c6310 (devlink: Add devlink reload limit option)
  				  struct netlink_ext_ack *extack)
  {
  	struct mlx4_priv *priv = devlink_priv(devlink);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/devlink.c
index fcd4875639de,0016041e8779..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/devlink.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/devlink.c
@@@ -89,6 -85,8 +89,11 @@@ mlx5_devlink_info_get(struct devlink *d
  }
  
  static int mlx5_devlink_reload_down(struct devlink *devlink, bool netns_change,
++<<<<<<< HEAD
++=======
+ 				    enum devlink_reload_action action,
+ 				    enum devlink_reload_limit limit,
++>>>>>>> dc64cc7c6310 (devlink: Add devlink reload limit option)
  				    struct netlink_ext_ack *extack)
  {
  	struct mlx5_core_dev *dev = devlink_priv(devlink);
@@@ -102,7 -95,8 +107,12 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int mlx5_devlink_reload_up(struct devlink *devlink,
++=======
+ static int mlx5_devlink_reload_up(struct devlink *devlink, enum devlink_reload_action action,
+ 				  enum devlink_reload_limit limit, u32 *actions_performed,
++>>>>>>> dc64cc7c6310 (devlink: Add devlink reload limit option)
  				  struct netlink_ext_ack *extack)
  {
  	struct mlx5_core_dev *dev = devlink_priv(devlink);
diff --cc drivers/net/ethernet/mellanox/mlxsw/core.c
index 4238bb46a635,7f77c2a71d1c..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/core.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/core.c
@@@ -1421,7 -1414,8 +1421,12 @@@ mlxsw_devlink_info_get(struct devlink *
  
  static int
  mlxsw_devlink_core_bus_device_reload_down(struct devlink *devlink,
++<<<<<<< HEAD
 +					  bool netns_change,
++=======
+ 					  bool netns_change, enum devlink_reload_action action,
+ 					  enum devlink_reload_limit limit,
++>>>>>>> dc64cc7c6310 (devlink: Add devlink reload limit option)
  					  struct netlink_ext_ack *extack)
  {
  	struct mlxsw_core *mlxsw_core = devlink_priv(devlink);
@@@ -1434,7 -1428,8 +1439,12 @@@
  }
  
  static int
++<<<<<<< HEAD
 +mlxsw_devlink_core_bus_device_reload_up(struct devlink *devlink,
++=======
+ mlxsw_devlink_core_bus_device_reload_up(struct devlink *devlink, enum devlink_reload_action action,
+ 					enum devlink_reload_limit limit, u32 *actions_performed,
++>>>>>>> dc64cc7c6310 (devlink: Add devlink reload limit option)
  					struct netlink_ext_ack *extack)
  {
  	struct mlxsw_core *mlxsw_core = devlink_priv(devlink);
diff --cc drivers/net/netdevsim/dev.c
index 71cbc323653c,d07061417675..000000000000
--- a/drivers/net/netdevsim/dev.c
+++ b/drivers/net/netdevsim/dev.c
@@@ -699,6 -701,7 +699,10 @@@ static int nsim_dev_reload_create(struc
  static void nsim_dev_reload_destroy(struct nsim_dev *nsim_dev);
  
  static int nsim_dev_reload_down(struct devlink *devlink, bool netns_change,
++<<<<<<< HEAD
++=======
+ 				enum devlink_reload_action action, enum devlink_reload_limit limit,
++>>>>>>> dc64cc7c6310 (devlink: Add devlink reload limit option)
  				struct netlink_ext_ack *extack)
  {
  	struct nsim_dev *nsim_dev = devlink_priv(devlink);
@@@ -715,7 -718,8 +719,12 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int nsim_dev_reload_up(struct devlink *devlink,
++=======
+ static int nsim_dev_reload_up(struct devlink *devlink, enum devlink_reload_action action,
+ 			      enum devlink_reload_limit limit, u32 *actions_performed,
++>>>>>>> dc64cc7c6310 (devlink: Add devlink reload limit option)
  			      struct netlink_ext_ack *extack)
  {
  	struct nsim_dev *nsim_dev = devlink_priv(devlink);
diff --cc include/net/devlink.h
index 5414aff70555,9f5c37c391f8..000000000000
--- a/include/net/devlink.h
+++ b/include/net/devlink.h
@@@ -1033,9 -1144,20 +1033,26 @@@ enum devlink_trap_group_generic_id 
  	}
  
  struct devlink_ops {
++<<<<<<< HEAD
 +	int (*reload_down)(struct devlink *devlink, bool netns_change,
 +			   struct netlink_ext_ack *extack);
 +	int (*reload_up)(struct devlink *devlink,
++=======
+ 	/**
+ 	 * @supported_flash_update_params:
+ 	 * mask of parameters supported by the driver's .flash_update
+ 	 * implemementation.
+ 	 */
+ 	u32 supported_flash_update_params;
+ 	unsigned long reload_actions;
+ 	unsigned long reload_limits;
+ 	int (*reload_down)(struct devlink *devlink, bool netns_change,
+ 			   enum devlink_reload_action action,
+ 			   enum devlink_reload_limit limit,
+ 			   struct netlink_ext_ack *extack);
+ 	int (*reload_up)(struct devlink *devlink, enum devlink_reload_action action,
+ 			 enum devlink_reload_limit limit, u32 *actions_performed,
++>>>>>>> dc64cc7c6310 (devlink: Add devlink reload limit option)
  			 struct netlink_ext_ack *extack);
  	int (*port_type_set)(struct devlink_port *devlink_port,
  			     enum devlink_port_type port_type);
diff --cc include/uapi/linux/devlink.h
index f2172c34975d,82a5e66c1518..000000000000
--- a/include/uapi/linux/devlink.h
+++ b/include/uapi/linux/devlink.h
@@@ -276,6 -301,29 +276,32 @@@ enum 
  	DEVLINK_ATTR_TRAP_METADATA_TYPE_FA_COOKIE,
  };
  
++<<<<<<< HEAD
++=======
+ enum devlink_reload_action {
+ 	DEVLINK_RELOAD_ACTION_UNSPEC,
+ 	DEVLINK_RELOAD_ACTION_DRIVER_REINIT,	/* Driver entities re-instantiation */
+ 	DEVLINK_RELOAD_ACTION_FW_ACTIVATE,	/* FW activate */
+ 
+ 	/* Add new reload actions above */
+ 	__DEVLINK_RELOAD_ACTION_MAX,
+ 	DEVLINK_RELOAD_ACTION_MAX = __DEVLINK_RELOAD_ACTION_MAX - 1
+ };
+ 
+ enum devlink_reload_limit {
+ 	DEVLINK_RELOAD_LIMIT_UNSPEC,	/* unspecified, no constraints */
+ 	DEVLINK_RELOAD_LIMIT_NO_RESET,	/* No reset allowed, no down time allowed,
+ 					 * no link flap and no configuration is lost.
+ 					 */
+ 
+ 	/* Add new reload limit above */
+ 	__DEVLINK_RELOAD_LIMIT_MAX,
+ 	DEVLINK_RELOAD_LIMIT_MAX = __DEVLINK_RELOAD_LIMIT_MAX - 1
+ };
+ 
+ #define DEVLINK_RELOAD_LIMITS_VALID_MASK (BIT(__DEVLINK_RELOAD_LIMIT_MAX) - 1)
+ 
++>>>>>>> dc64cc7c6310 (devlink: Add devlink reload limit option)
  enum devlink_attr {
  	/* don't change the order or add anything between, this is ABI! */
  	DEVLINK_ATTR_UNSPEC,
@@@ -462,11 -510,15 +488,19 @@@
  	DEVLINK_ATTR_PORT_LANES,			/* u32 */
  	DEVLINK_ATTR_PORT_SPLITTABLE,			/* u8 */
  
 -	DEVLINK_ATTR_PORT_EXTERNAL,		/* u8 */
 -	DEVLINK_ATTR_PORT_CONTROLLER_NUMBER,	/* u32 */
 +	/* Not supported in RHEL, i adding reserved fields due to keep UAPI */
 +	__RH_RESERVED_DEVLINK_ATTR_PORT_EXTERNAL,		/* u8 */
 +	__RH_RESERVED_DEVLINK_ATTR_PORT_CONTROLLER_NUMBER,	/* u32 */
  
  	DEVLINK_ATTR_FLASH_UPDATE_STATUS_TIMEOUT,	/* u64 */
++<<<<<<< HEAD
++=======
+ 	DEVLINK_ATTR_FLASH_UPDATE_OVERWRITE_MASK,	/* bitfield32 */
+ 
+ 	DEVLINK_ATTR_RELOAD_ACTION,		/* u8 */
+ 	DEVLINK_ATTR_RELOAD_ACTIONS_PERFORMED,	/* bitfield32 */
+ 	DEVLINK_ATTR_RELOAD_LIMITS,		/* bitfield32 */
++>>>>>>> dc64cc7c6310 (devlink: Add devlink reload limit option)
  
  	/* add new attributes above here, update the policy in devlink.c */
  
diff --cc net/core/devlink.c
index 7ae91478c0cd,28b63faa3c6b..000000000000
--- a/net/core/devlink.c
+++ b/net/core/devlink.c
@@@ -466,6 -479,44 +466,47 @@@ static int devlink_nl_put_handle(struc
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ struct devlink_reload_combination {
+ 	enum devlink_reload_action action;
+ 	enum devlink_reload_limit limit;
+ };
+ 
+ static const struct devlink_reload_combination devlink_reload_invalid_combinations[] = {
+ 	{
+ 		/* can't reinitialize driver with no down time */
+ 		.action = DEVLINK_RELOAD_ACTION_DRIVER_REINIT,
+ 		.limit = DEVLINK_RELOAD_LIMIT_NO_RESET,
+ 	},
+ };
+ 
+ static bool
+ devlink_reload_combination_is_invalid(enum devlink_reload_action action,
+ 				      enum devlink_reload_limit limit)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(devlink_reload_invalid_combinations); i++)
+ 		if (devlink_reload_invalid_combinations[i].action == action &&
+ 		    devlink_reload_invalid_combinations[i].limit == limit)
+ 			return true;
+ 	return false;
+ }
+ 
+ static bool
+ devlink_reload_action_is_supported(struct devlink *devlink, enum devlink_reload_action action)
+ {
+ 	return test_bit(action, &devlink->ops->reload_actions);
+ }
+ 
+ static bool
+ devlink_reload_limit_is_supported(struct devlink *devlink, enum devlink_reload_limit limit)
+ {
+ 	return test_bit(limit, &devlink->ops->reload_limits);
+ }
+ 
++>>>>>>> dc64cc7c6310 (devlink: Add devlink reload limit option)
  static int devlink_nl_fill(struct sk_buff *msg, struct devlink *devlink,
  			   enum devlink_command cmd, u32 portid,
  			   u32 seq, int flags)
@@@ -2973,29 -3022,69 +3014,47 @@@ bool devlink_is_reload_failed(const str
  EXPORT_SYMBOL_GPL(devlink_is_reload_failed);
  
  static int devlink_reload(struct devlink *devlink, struct net *dest_net,
++<<<<<<< HEAD
 +			  struct netlink_ext_ack *extack)
++=======
+ 			  enum devlink_reload_action action, enum devlink_reload_limit limit,
+ 			  u32 *actions_performed, struct netlink_ext_ack *extack)
++>>>>>>> dc64cc7c6310 (devlink: Add devlink reload limit option)
  {
  	int err;
  
  	if (!devlink->reload_enabled)
  		return -EOPNOTSUPP;
  
++<<<<<<< HEAD
 +	err = devlink->ops->reload_down(devlink, !!dest_net, extack);
++=======
+ 	err = devlink->ops->reload_down(devlink, !!dest_net, action, limit, extack);
++>>>>>>> dc64cc7c6310 (devlink: Add devlink reload limit option)
  	if (err)
  		return err;
  
  	if (dest_net && !net_eq(dest_net, devlink_net(devlink)))
  		devlink_reload_netns_change(devlink, dest_net);
  
++<<<<<<< HEAD
 +	err = devlink->ops->reload_up(devlink, extack);
++=======
+ 	err = devlink->ops->reload_up(devlink, action, limit, actions_performed, extack);
++>>>>>>> dc64cc7c6310 (devlink: Add devlink reload limit option)
  	devlink_reload_failed_set(devlink, !!err);
 -	if (err)
 -		return err;
 -
 -	WARN_ON(!(*actions_performed & BIT(action)));
 -	return 0;
 -}
 -
 -static int
 -devlink_nl_reload_actions_performed_snd(struct devlink *devlink, u32 actions_performed,
 -					enum devlink_command cmd, struct genl_info *info)
 -{
 -	struct sk_buff *msg;
 -	void *hdr;
 -
 -	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
 -	if (!msg)
 -		return -ENOMEM;
 -
 -	hdr = genlmsg_put(msg, info->snd_portid, info->snd_seq, &devlink_nl_family, 0, cmd);
 -	if (!hdr)
 -		goto free_msg;
 -
 -	if (devlink_nl_put_handle(msg, devlink))
 -		goto nla_put_failure;
 -
 -	if (nla_put_bitfield32(msg, DEVLINK_ATTR_RELOAD_ACTIONS_PERFORMED, actions_performed,
 -			       actions_performed))
 -		goto nla_put_failure;
 -	genlmsg_end(msg, hdr);
 -
 -	return genlmsg_reply(msg, info);
 -
 -nla_put_failure:
 -	genlmsg_cancel(msg, hdr);
 -free_msg:
 -	nlmsg_free(msg);
 -	return -EMSGSIZE;
 +	return err;
  }
  
  static int devlink_nl_cmd_reload(struct sk_buff *skb, struct genl_info *info)
  {
  	struct devlink *devlink = info->user_ptr[0];
++<<<<<<< HEAD
++=======
+ 	enum devlink_reload_action action;
+ 	enum devlink_reload_limit limit;
++>>>>>>> dc64cc7c6310 (devlink: Add devlink reload limit option)
  	struct net *dest_net = NULL;
 -	u32 actions_performed;
  	int err;
  
  	if (!devlink_reload_supported(devlink->ops))
@@@ -3015,12 -3104,61 +3074,69 @@@
  			return PTR_ERR(dest_net);
  	}
  
++<<<<<<< HEAD
 +	err = devlink_reload(devlink, dest_net, info->extack);
++=======
+ 	if (info->attrs[DEVLINK_ATTR_RELOAD_ACTION])
+ 		action = nla_get_u8(info->attrs[DEVLINK_ATTR_RELOAD_ACTION]);
+ 	else
+ 		action = DEVLINK_RELOAD_ACTION_DRIVER_REINIT;
+ 
+ 	if (!devlink_reload_action_is_supported(devlink, action)) {
+ 		NL_SET_ERR_MSG_MOD(info->extack,
+ 				   "Requested reload action is not supported by the driver");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	limit = DEVLINK_RELOAD_LIMIT_UNSPEC;
+ 	if (info->attrs[DEVLINK_ATTR_RELOAD_LIMITS]) {
+ 		struct nla_bitfield32 limits;
+ 		u32 limits_selected;
+ 
+ 		limits = nla_get_bitfield32(info->attrs[DEVLINK_ATTR_RELOAD_LIMITS]);
+ 		limits_selected = limits.value & limits.selector;
+ 		if (!limits_selected) {
+ 			NL_SET_ERR_MSG_MOD(info->extack, "Invalid limit selected");
+ 			return -EINVAL;
+ 		}
+ 		for (limit = 0 ; limit <= DEVLINK_RELOAD_LIMIT_MAX ; limit++)
+ 			if (limits_selected & BIT(limit))
+ 				break;
+ 		/* UAPI enables multiselection, but currently it is not used */
+ 		if (limits_selected != BIT(limit)) {
+ 			NL_SET_ERR_MSG_MOD(info->extack,
+ 					   "Multiselection of limit is not supported");
+ 			return -EOPNOTSUPP;
+ 		}
+ 		if (!devlink_reload_limit_is_supported(devlink, limit)) {
+ 			NL_SET_ERR_MSG_MOD(info->extack,
+ 					   "Requested limit is not supported by the driver");
+ 			return -EOPNOTSUPP;
+ 		}
+ 		if (devlink_reload_combination_is_invalid(action, limit)) {
+ 			NL_SET_ERR_MSG_MOD(info->extack,
+ 					   "Requested limit is invalid for this action");
+ 			return -EINVAL;
+ 		}
+ 	}
+ 	err = devlink_reload(devlink, dest_net, action, limit, &actions_performed, info->extack);
++>>>>>>> dc64cc7c6310 (devlink: Add devlink reload limit option)
  
  	if (dest_net)
  		put_net(dest_net);
  
++<<<<<<< HEAD
 +	return err;
++=======
+ 	if (err)
+ 		return err;
+ 	/* For backward compatibility generate reply only if attributes used by user */
+ 	if (!info->attrs[DEVLINK_ATTR_RELOAD_ACTION] && !info->attrs[DEVLINK_ATTR_RELOAD_LIMITS])
+ 		return 0;
+ 
+ 	return devlink_nl_reload_actions_performed_snd(devlink, actions_performed,
+ 						       DEVLINK_CMD_RELOAD, info);
++>>>>>>> dc64cc7c6310 (devlink: Add devlink reload limit option)
  }
  
  static int devlink_nl_flash_update_fill(struct sk_buff *msg,
@@@ -7127,9 -7409,12 +7243,15 @@@ static const struct nla_policy devlink_
  	[DEVLINK_ATTR_TRAP_POLICER_RATE] = { .type = NLA_U64 },
  	[DEVLINK_ATTR_TRAP_POLICER_BURST] = { .type = NLA_U64 },
  	[DEVLINK_ATTR_PORT_FUNCTION] = { .type = NLA_NESTED },
++<<<<<<< HEAD
++=======
+ 	[DEVLINK_ATTR_RELOAD_ACTION] = NLA_POLICY_RANGE(NLA_U8, DEVLINK_RELOAD_ACTION_DRIVER_REINIT,
+ 							DEVLINK_RELOAD_ACTION_MAX),
+ 	[DEVLINK_ATTR_RELOAD_LIMITS] = NLA_POLICY_BITFIELD32(DEVLINK_RELOAD_LIMITS_VALID_MASK),
++>>>>>>> dc64cc7c6310 (devlink: Add devlink reload limit option)
  };
  
 -static const struct genl_small_ops devlink_nl_ops[] = {
 +static const struct genl_ops devlink_nl_ops[] = {
  	{
  		.cmd = DEVLINK_CMD_GET,
  		.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,
@@@ -7458,6 -7745,35 +7580,38 @@@ static struct genl_family devlink_nl_fa
  	.n_mcgrps	= ARRAY_SIZE(devlink_nl_mcgrps),
  };
  
++<<<<<<< HEAD
++=======
+ static bool devlink_reload_actions_valid(const struct devlink_ops *ops)
+ {
+ 	const struct devlink_reload_combination *comb;
+ 	int i;
+ 
+ 	if (!devlink_reload_supported(ops)) {
+ 		if (WARN_ON(ops->reload_actions))
+ 			return false;
+ 		return true;
+ 	}
+ 
+ 	if (WARN_ON(!ops->reload_actions ||
+ 		    ops->reload_actions & BIT(DEVLINK_RELOAD_ACTION_UNSPEC) ||
+ 		    ops->reload_actions >= BIT(__DEVLINK_RELOAD_ACTION_MAX)))
+ 		return false;
+ 
+ 	if (WARN_ON(ops->reload_limits & BIT(DEVLINK_RELOAD_LIMIT_UNSPEC) ||
+ 		    ops->reload_limits >= BIT(__DEVLINK_RELOAD_LIMIT_MAX)))
+ 		return false;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(devlink_reload_invalid_combinations); i++)  {
+ 		comb = &devlink_reload_invalid_combinations[i];
+ 		if (ops->reload_actions == BIT(comb->action) &&
+ 		    ops->reload_limits == BIT(comb->limit))
+ 			return false;
+ 	}
+ 	return true;
+ }
+ 
++>>>>>>> dc64cc7c6310 (devlink: Add devlink reload limit option)
  /**
   *	devlink_alloc - Allocate new devlink instance resources
   *
@@@ -9735,7 -10133,10 +9889,14 @@@ static void __net_exit devlink_pernet_p
  		if (net_eq(devlink_net(devlink), net)) {
  			if (WARN_ON(!devlink_reload_supported(devlink->ops)))
  				continue;
++<<<<<<< HEAD
 +			err = devlink_reload(devlink, &init_net, NULL);
++=======
+ 			err = devlink_reload(devlink, &init_net,
+ 					     DEVLINK_RELOAD_ACTION_DRIVER_REINIT,
+ 					     DEVLINK_RELOAD_LIMIT_UNSPEC,
+ 					     &actions_performed, NULL);
++>>>>>>> dc64cc7c6310 (devlink: Add devlink reload limit option)
  			if (err && err != -EOPNOTSUPP)
  				pr_warn("Failed to reload devlink instance into init_net\n");
  		}
* Unmerged path drivers/net/ethernet/mellanox/mlx4/main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/devlink.c
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/core.c
* Unmerged path drivers/net/netdevsim/dev.c
* Unmerged path include/net/devlink.h
* Unmerged path include/uapi/linux/devlink.h
* Unmerged path net/core/devlink.c
