mm/memcg: revise the using condition of lock_page_lruvec function series

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Alex Shi <alex.shi@linux.alibaba.com>
commit d7e3aba583e6d13a81932597c5ee8da3c8b6af04
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/d7e3aba5.failed

lock_page_lruvec() and its variants are safe to use under the same
conditions as commit_charge(): add lock_page_memcg() to the comment.

Polished with Hugh Dickins' suggestions, thanks!

Link: https://lkml.kernel.org/r/1608614453-10739-1-git-send-email-alex.shi@linux.alibaba.com
	Signed-off-by: Alex Shi <alex.shi@linux.alibaba.com>
	Acked-by: Hugh Dickins <hughd@google.com>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Michal Hocko <mhocko@kernel.org>
	Cc: Vladimir Davydov <vdavydov.dev@gmail.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit d7e3aba583e6d13a81932597c5ee8da3c8b6af04)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memcontrol.c
diff --cc mm/memcontrol.c
index 4d65b541b4a3,2b13b2cf5dcb..000000000000
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@@ -1314,43 -1325,75 +1314,51 @@@ int mem_cgroup_scan_tasks(struct mem_cg
  	return ret;
  }
  
 -#ifdef CONFIG_DEBUG_VM
 -void lruvec_memcg_debug(struct lruvec *lruvec, struct page *page)
 -{
 -	struct mem_cgroup *memcg;
 -
 -	if (mem_cgroup_disabled())
 -		return;
 -
 -	memcg = page_memcg(page);
 -
 -	if (!memcg)
 -		VM_BUG_ON_PAGE(lruvec_memcg(lruvec) != root_mem_cgroup, page);
 -	else
 -		VM_BUG_ON_PAGE(lruvec_memcg(lruvec) != memcg, page);
 -}
 -#endif
 -
  /**
 - * lock_page_lruvec - lock and return lruvec for a given page.
 + * mem_cgroup_page_lruvec - return lruvec for isolating/putting an LRU page
   * @page: the page
 + * @pgdat: pgdat of the page
   *
++<<<<<<< HEAD
 + * This function relies on page's memcg being stable - see the
 + * access rules in commit_charge().
++=======
+  * These functions are safe to use under any of the following conditions:
+  * - page locked
+  * - PageLRU cleared
+  * - lock_page_memcg()
+  * - page->_refcount is zero
++>>>>>>> d7e3aba583e6 (mm/memcg: revise the using condition of lock_page_lruvec function series)
   */
 -struct lruvec *lock_page_lruvec(struct page *page)
 -{
 -	struct lruvec *lruvec;
 -	struct pglist_data *pgdat = page_pgdat(page);
 -
 -	rcu_read_lock();
 -	lruvec = mem_cgroup_page_lruvec(page, pgdat);
 -	spin_lock(&lruvec->lru_lock);
 -	rcu_read_unlock();
 -
 -	lruvec_memcg_debug(lruvec, page);
 -
 -	return lruvec;
 -}
 -
 -struct lruvec *lock_page_lruvec_irq(struct page *page)
 -{
 -	struct lruvec *lruvec;
 -	struct pglist_data *pgdat = page_pgdat(page);
 -
 -	rcu_read_lock();
 -	lruvec = mem_cgroup_page_lruvec(page, pgdat);
 -	spin_lock_irq(&lruvec->lru_lock);
 -	rcu_read_unlock();
 -
 -	lruvec_memcg_debug(lruvec, page);
 -
 -	return lruvec;
 -}
 -
 -struct lruvec *lock_page_lruvec_irqsave(struct page *page, unsigned long *flags)
 +struct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)
  {
 +	struct mem_cgroup_per_node *mz;
 +	struct mem_cgroup *memcg;
  	struct lruvec *lruvec;
 -	struct pglist_data *pgdat = page_pgdat(page);
  
 -	rcu_read_lock();
 -	lruvec = mem_cgroup_page_lruvec(page, pgdat);
 -	spin_lock_irqsave(&lruvec->lru_lock, *flags);
 -	rcu_read_unlock();
 +	if (mem_cgroup_disabled()) {
 +		lruvec = &pgdat->__lruvec;
 +		goto out;
 +	}
  
 -	lruvec_memcg_debug(lruvec, page);
 +	memcg = page->mem_cgroup;
 +	/*
 +	 * Swapcache readahead pages are added to the LRU - and
 +	 * possibly migrated - before they are charged.
 +	 */
 +	if (!memcg)
 +		memcg = root_mem_cgroup;
  
 +	mz = mem_cgroup_page_nodeinfo(memcg, page);
 +	lruvec = &mz->lruvec;
 +out:
 +	/*
 +	 * Since a node can be onlined after the mem_cgroup was created,
 +	 * we have to be prepared to initialize lruvec->zone here;
 +	 * and if offlined then reonlined, we need to reinitialize it.
 +	 */
 +	if (unlikely(lruvec->pgdat != pgdat))
 +		lruvec->pgdat = pgdat;
  	return lruvec;
  }
  
* Unmerged path mm/memcontrol.c
