KVM: vmx/pmu: Fix dummy check if lbr_desc->event is created

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Like Xu <like.xu@linux.intel.com>
commit 67b45af946ec3148b64e6a3a1ee2ea8f79c5bc07
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/67b45af9.failed

If lbr_desc->event is successfully created, the intel_pmu_create_
guest_lbr_event() will return 0, otherwise it will return -ENOENT,
and then jump to LBR msrs dummy handling.

Fixes: 1b5ac3226a1a ("KVM: vmx/pmu: Pass-through LBR msrs when the guest LBR event is ACTIVE")
	Signed-off-by: Like Xu <like.xu@linux.intel.com>
Message-Id: <20210223013958.1280444-1-like.xu@linux.intel.com>
[Add "< 0" and PTR_ERR to make the code clearer. - Paolo]
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 67b45af946ec3148b64e6a3a1ee2ea8f79c5bc07)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/pmu_intel.c
diff --cc arch/x86/kvm/vmx/pmu_intel.c
index 48690db4db6a,9efc1a6b8693..000000000000
--- a/arch/x86/kvm/vmx/pmu_intel.c
+++ b/arch/x86/kvm/vmx/pmu_intel.c
@@@ -277,6 -305,49 +277,51 @@@ int intel_pmu_create_guest_lbr_event(st
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * It's safe to access LBR msrs from guest when they have not
+  * been passthrough since the host would help restore or reset
+  * the LBR msrs records when the guest LBR event is scheduled in.
+  */
+ static bool intel_pmu_handle_lbr_msrs_access(struct kvm_vcpu *vcpu,
+ 				     struct msr_data *msr_info, bool read)
+ {
+ 	struct lbr_desc *lbr_desc = vcpu_to_lbr_desc(vcpu);
+ 	u32 index = msr_info->index;
+ 
+ 	if (!intel_pmu_is_valid_lbr_msr(vcpu, index))
+ 		return false;
+ 
+ 	if (!lbr_desc->event && intel_pmu_create_guest_lbr_event(vcpu) < 0)
+ 		goto dummy;
+ 
+ 	/*
+ 	 * Disable irq to ensure the LBR feature doesn't get reclaimed by the
+ 	 * host at the time the value is read from the msr, and this avoids the
+ 	 * host LBR value to be leaked to the guest. If LBR has been reclaimed,
+ 	 * return 0 on guest reads.
+ 	 */
+ 	local_irq_disable();
+ 	if (lbr_desc->event->state == PERF_EVENT_STATE_ACTIVE) {
+ 		if (read)
+ 			rdmsrl(index, msr_info->data);
+ 		else
+ 			wrmsrl(index, msr_info->data);
+ 		__set_bit(INTEL_PMC_IDX_FIXED_VLBR, vcpu_to_pmu(vcpu)->pmc_in_use);
+ 		local_irq_enable();
+ 		return true;
+ 	}
+ 	clear_bit(INTEL_PMC_IDX_FIXED_VLBR, vcpu_to_pmu(vcpu)->pmc_in_use);
+ 	local_irq_enable();
+ 
+ dummy:
+ 	if (read)
+ 		msr_info->data = 0;
+ 	return true;
+ }
+ 
++>>>>>>> 67b45af946ec (KVM: vmx/pmu: Fix dummy check if lbr_desc->event is created)
  static int intel_pmu_get_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
  {
  	struct kvm_pmu *pmu = vcpu_to_pmu(vcpu);
* Unmerged path arch/x86/kvm/vmx/pmu_intel.c
