cifs: move smb version mount options into fs_context.c

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Ronnie Sahlberg <lsahlber@redhat.com>
commit 555782aa556af869d4f390996607abd356513ba4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/555782aa.failed

This and related patches which move mount related
code to fs_context.c has the advantage of
shriking the code in fs/cifs/connect.c (which had
the second most lines of code of any of the files
in cifs.ko and was getting harder to read due
to its size) and will also make it easier to
switch over to the new mount API in the future.

	Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
	Reviewed-by: Aurelien Aptel <aaptel@suse.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 555782aa556af869d4f390996607abd356513ba4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/connect.c
#	fs/cifs/fs_context.c
#	fs/cifs/fs_context.h
diff --cc fs/cifs/connect.c
index d324a8f1409c,c38156f324dd..000000000000
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@@ -279,66 -280,6 +279,69 @@@ static const match_table_t cifs_mount_o
  	{ Opt_err, NULL }
  };
  
++<<<<<<< HEAD
 +enum {
 +	Opt_sec_krb5, Opt_sec_krb5i, Opt_sec_krb5p,
 +	Opt_sec_ntlmsspi, Opt_sec_ntlmssp,
 +	Opt_ntlm, Opt_sec_ntlmi, Opt_sec_ntlmv2,
 +	Opt_sec_ntlmv2i, Opt_sec_lanman,
 +	Opt_sec_none,
 +
 +	Opt_sec_err
 +};
 +
 +static const match_table_t cifs_secflavor_tokens = {
 +	{ Opt_sec_krb5, "krb5" },
 +	{ Opt_sec_krb5i, "krb5i" },
 +	{ Opt_sec_krb5p, "krb5p" },
 +	{ Opt_sec_ntlmsspi, "ntlmsspi" },
 +	{ Opt_sec_ntlmssp, "ntlmssp" },
 +	{ Opt_ntlm, "ntlm" },
 +	{ Opt_sec_ntlmi, "ntlmi" },
 +	{ Opt_sec_ntlmv2, "nontlm" },
 +	{ Opt_sec_ntlmv2, "ntlmv2" },
 +	{ Opt_sec_ntlmv2i, "ntlmv2i" },
 +	{ Opt_sec_lanman, "lanman" },
 +	{ Opt_sec_none, "none" },
 +
 +	{ Opt_sec_err, NULL }
 +};
 +
 +/* cache flavors */
 +enum {
 +	Opt_cache_loose,
 +	Opt_cache_strict,
 +	Opt_cache_none,
 +	Opt_cache_ro,
 +	Opt_cache_rw,
 +	Opt_cache_err
 +};
 +
 +static const match_table_t cifs_cacheflavor_tokens = {
 +	{ Opt_cache_loose, "loose" },
 +	{ Opt_cache_strict, "strict" },
 +	{ Opt_cache_none, "none" },
 +	{ Opt_cache_ro, "ro" },
 +	{ Opt_cache_rw, "singleclient" },
 +	{ Opt_cache_err, NULL }
 +};
 +
 +static const match_table_t cifs_smb_version_tokens = {
 +	{ Smb_1, SMB1_VERSION_STRING },
 +	{ Smb_20, SMB20_VERSION_STRING},
 +	{ Smb_21, SMB21_VERSION_STRING },
 +	{ Smb_30, SMB30_VERSION_STRING },
 +	{ Smb_302, SMB302_VERSION_STRING },
 +	{ Smb_302, ALT_SMB302_VERSION_STRING },
 +	{ Smb_311, SMB311_VERSION_STRING },
 +	{ Smb_311, ALT_SMB311_VERSION_STRING },
 +	{ Smb_3any, SMB3ANY_VERSION_STRING },
 +	{ Smb_default, SMBDEFAULT_VERSION_STRING },
 +	{ Smb_version_err, NULL }
 +};
 +
++=======
++>>>>>>> 555782aa556a (cifs: move smb version mount options into fs_context.c)
  static int ip_connect(struct TCP_Server_Info *server);
  static int generic_ip_connect(struct TCP_Server_Info *server);
  static void tlink_rb_insert(struct rb_root *root, struct tcon_link *new_tlink);
@@@ -1372,177 -1313,6 +1375,180 @@@ static int get_option_gid(substring_t a
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int cifs_parse_security_flavors(char *value,
 +				       struct smb_vol *vol)
 +{
 +
 +	substring_t args[MAX_OPT_ARGS];
 +
 +	/*
 +	 * With mount options, the last one should win. Reset any existing
 +	 * settings back to default.
 +	 */
 +	vol->sectype = Unspecified;
 +	vol->sign = false;
 +
 +	switch (match_token(value, cifs_secflavor_tokens, args)) {
 +	case Opt_sec_krb5p:
 +		cifs_dbg(VFS, "sec=krb5p is not supported!\n");
 +		return 1;
 +	case Opt_sec_krb5i:
 +		vol->sign = true;
 +		/* Fallthrough */
 +	case Opt_sec_krb5:
 +		vol->sectype = Kerberos;
 +		break;
 +	case Opt_sec_ntlmsspi:
 +		vol->sign = true;
 +		/* Fallthrough */
 +	case Opt_sec_ntlmssp:
 +		vol->sectype = RawNTLMSSP;
 +		break;
 +	case Opt_sec_ntlmi:
 +		vol->sign = true;
 +		/* Fallthrough */
 +	case Opt_ntlm:
 +		vol->sectype = NTLM;
 +		break;
 +	case Opt_sec_ntlmv2i:
 +		vol->sign = true;
 +		/* Fallthrough */
 +	case Opt_sec_ntlmv2:
 +		vol->sectype = NTLMv2;
 +		break;
 +#ifdef CONFIG_CIFS_WEAK_PW_HASH
 +	case Opt_sec_lanman:
 +		vol->sectype = LANMAN;
 +		break;
 +#endif
 +	case Opt_sec_none:
 +		vol->nullauth = 1;
 +		break;
 +	default:
 +		cifs_dbg(VFS, "bad security option: %s\n", value);
 +		return 1;
 +	}
 +
 +	return 0;
 +}
 +
 +static int
 +cifs_parse_cache_flavor(char *value, struct smb_vol *vol)
 +{
 +	substring_t args[MAX_OPT_ARGS];
 +
 +	switch (match_token(value, cifs_cacheflavor_tokens, args)) {
 +	case Opt_cache_loose:
 +		vol->direct_io = false;
 +		vol->strict_io = false;
 +		vol->cache_ro = false;
 +		vol->cache_rw = false;
 +		break;
 +	case Opt_cache_strict:
 +		vol->direct_io = false;
 +		vol->strict_io = true;
 +		vol->cache_ro = false;
 +		vol->cache_rw = false;
 +		break;
 +	case Opt_cache_none:
 +		vol->direct_io = true;
 +		vol->strict_io = false;
 +		vol->cache_ro = false;
 +		vol->cache_rw = false;
 +		break;
 +	case Opt_cache_ro:
 +		vol->direct_io = false;
 +		vol->strict_io = false;
 +		vol->cache_ro = true;
 +		vol->cache_rw = false;
 +		break;
 +	case Opt_cache_rw:
 +		vol->direct_io = false;
 +		vol->strict_io = false;
 +		vol->cache_ro = false;
 +		vol->cache_rw = true;
 +		break;
 +	default:
 +		cifs_dbg(VFS, "bad cache= option: %s\n", value);
 +		return 1;
 +	}
 +	return 0;
 +}
 +
 +static int
 +cifs_parse_smb_version(char *value, struct smb_vol *vol, bool is_smb3)
 +{
 +	substring_t args[MAX_OPT_ARGS];
 +
 +	switch (match_token(value, cifs_smb_version_tokens, args)) {
 +#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY
 +	case Smb_1:
 +		if (disable_legacy_dialects) {
 +			cifs_dbg(VFS, "mount with legacy dialect disabled\n");
 +			return 1;
 +		}
 +		if (is_smb3) {
 +			cifs_dbg(VFS, "vers=1.0 (cifs) not permitted when mounting with smb3\n");
 +			return 1;
 +		}
 +		cifs_dbg(VFS, "Use of the less secure dialect vers=1.0 is not recommended unless required for access to very old servers\n");
 +		vol->ops = &smb1_operations;
 +		vol->vals = &smb1_values;
 +		break;
 +	case Smb_20:
 +		if (disable_legacy_dialects) {
 +			cifs_dbg(VFS, "mount with legacy dialect disabled\n");
 +			return 1;
 +		}
 +		if (is_smb3) {
 +			cifs_dbg(VFS, "vers=2.0 not permitted when mounting with smb3\n");
 +			return 1;
 +		}
 +		vol->ops = &smb20_operations;
 +		vol->vals = &smb20_values;
 +		break;
 +#else
 +	case Smb_1:
 +		cifs_dbg(VFS, "vers=1.0 (cifs) mount not permitted when legacy dialects disabled\n");
 +		return 1;
 +	case Smb_20:
 +		cifs_dbg(VFS, "vers=2.0 mount not permitted when legacy dialects disabled\n");
 +		return 1;
 +#endif /* CIFS_ALLOW_INSECURE_LEGACY */
 +	case Smb_21:
 +		vol->ops = &smb21_operations;
 +		vol->vals = &smb21_values;
 +		break;
 +	case Smb_30:
 +		vol->ops = &smb30_operations;
 +		vol->vals = &smb30_values;
 +		break;
 +	case Smb_302:
 +		vol->ops = &smb30_operations; /* currently identical with 3.0 */
 +		vol->vals = &smb302_values;
 +		break;
 +	case Smb_311:
 +		vol->ops = &smb311_operations;
 +		vol->vals = &smb311_values;
 +		break;
 +	case Smb_3any:
 +		vol->ops = &smb30_operations; /* currently identical with 3.0 */
 +		vol->vals = &smb3any_values;
 +		break;
 +	case Smb_default:
 +		vol->ops = &smb30_operations; /* currently identical with 3.0 */
 +		vol->vals = &smbdefault_values;
 +		break;
 +	default:
 +		cifs_dbg(VFS, "Unknown vers= option specified: %s\n", value);
 +		return 1;
 +	}
 +	return 0;
 +}
 +
++=======
++>>>>>>> 555782aa556a (cifs: move smb version mount options into fs_context.c)
  /*
   * Parse a devname into substrings and populate the vol->UNC and vol->prepath
   * fields with the result. Returns 0 on success and an error otherwise.
diff --cc fs/cifs/fs_context.c
index f50dfc2d2e44,ad6c2fed4055..000000000000
--- a/fs/cifs/fs_context.c
+++ b/fs/cifs/fs_context.c
@@@ -6,3 -6,216 +6,219 @@@
   *              David Howells <dhowells@redhat.com>
   */
  
++<<<<<<< HEAD
++=======
+ #include "cifsglob.h"
+ #include "cifs_debug.h"
+ #include "fs_context.h"
+ 
+ static const match_table_t cifs_smb_version_tokens = {
+ 	{ Smb_1, SMB1_VERSION_STRING },
+ 	{ Smb_20, SMB20_VERSION_STRING},
+ 	{ Smb_21, SMB21_VERSION_STRING },
+ 	{ Smb_30, SMB30_VERSION_STRING },
+ 	{ Smb_302, SMB302_VERSION_STRING },
+ 	{ Smb_302, ALT_SMB302_VERSION_STRING },
+ 	{ Smb_311, SMB311_VERSION_STRING },
+ 	{ Smb_311, ALT_SMB311_VERSION_STRING },
+ 	{ Smb_3any, SMB3ANY_VERSION_STRING },
+ 	{ Smb_default, SMBDEFAULT_VERSION_STRING },
+ 	{ Smb_version_err, NULL }
+ };
+ 
+ int
+ cifs_parse_smb_version(char *value, struct smb_vol *vol, bool is_smb3)
+ {
+ 	substring_t args[MAX_OPT_ARGS];
+ 
+ 	switch (match_token(value, cifs_smb_version_tokens, args)) {
+ #ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY
+ 	case Smb_1:
+ 		if (disable_legacy_dialects) {
+ 			cifs_dbg(VFS, "mount with legacy dialect disabled\n");
+ 			return 1;
+ 		}
+ 		if (is_smb3) {
+ 			cifs_dbg(VFS, "vers=1.0 (cifs) not permitted when mounting with smb3\n");
+ 			return 1;
+ 		}
+ 		cifs_dbg(VFS, "Use of the less secure dialect vers=1.0 is not recommended unless required for access to very old servers\n");
+ 		vol->ops = &smb1_operations;
+ 		vol->vals = &smb1_values;
+ 		break;
+ 	case Smb_20:
+ 		if (disable_legacy_dialects) {
+ 			cifs_dbg(VFS, "mount with legacy dialect disabled\n");
+ 			return 1;
+ 		}
+ 		if (is_smb3) {
+ 			cifs_dbg(VFS, "vers=2.0 not permitted when mounting with smb3\n");
+ 			return 1;
+ 		}
+ 		vol->ops = &smb20_operations;
+ 		vol->vals = &smb20_values;
+ 		break;
+ #else
+ 	case Smb_1:
+ 		cifs_dbg(VFS, "vers=1.0 (cifs) mount not permitted when legacy dialects disabled\n");
+ 		return 1;
+ 	case Smb_20:
+ 		cifs_dbg(VFS, "vers=2.0 mount not permitted when legacy dialects disabled\n");
+ 		return 1;
+ #endif /* CIFS_ALLOW_INSECURE_LEGACY */
+ 	case Smb_21:
+ 		vol->ops = &smb21_operations;
+ 		vol->vals = &smb21_values;
+ 		break;
+ 	case Smb_30:
+ 		vol->ops = &smb30_operations;
+ 		vol->vals = &smb30_values;
+ 		break;
+ 	case Smb_302:
+ 		vol->ops = &smb30_operations; /* currently identical with 3.0 */
+ 		vol->vals = &smb302_values;
+ 		break;
+ 	case Smb_311:
+ 		vol->ops = &smb311_operations;
+ 		vol->vals = &smb311_values;
+ 		break;
+ 	case Smb_3any:
+ 		vol->ops = &smb30_operations; /* currently identical with 3.0 */
+ 		vol->vals = &smb3any_values;
+ 		break;
+ 	case Smb_default:
+ 		vol->ops = &smb30_operations; /* currently identical with 3.0 */
+ 		vol->vals = &smbdefault_values;
+ 		break;
+ 	default:
+ 		cifs_dbg(VFS, "Unknown vers= option specified: %s\n", value);
+ 		return 1;
+ 	}
+ 	return 0;
+ }
+ 
+ static const match_table_t cifs_secflavor_tokens = {
+ 	{ Opt_sec_krb5, "krb5" },
+ 	{ Opt_sec_krb5i, "krb5i" },
+ 	{ Opt_sec_krb5p, "krb5p" },
+ 	{ Opt_sec_ntlmsspi, "ntlmsspi" },
+ 	{ Opt_sec_ntlmssp, "ntlmssp" },
+ 	{ Opt_ntlm, "ntlm" },
+ 	{ Opt_sec_ntlmi, "ntlmi" },
+ 	{ Opt_sec_ntlmv2, "nontlm" },
+ 	{ Opt_sec_ntlmv2, "ntlmv2" },
+ 	{ Opt_sec_ntlmv2i, "ntlmv2i" },
+ 	{ Opt_sec_lanman, "lanman" },
+ 	{ Opt_sec_none, "none" },
+ 
+ 	{ Opt_sec_err, NULL }
+ };
+ 
+ int cifs_parse_security_flavors(char *value, struct smb_vol *vol)
+ {
+ 
+ 	substring_t args[MAX_OPT_ARGS];
+ 
+ 	/*
+ 	 * With mount options, the last one should win. Reset any existing
+ 	 * settings back to default.
+ 	 */
+ 	vol->sectype = Unspecified;
+ 	vol->sign = false;
+ 
+ 	switch (match_token(value, cifs_secflavor_tokens, args)) {
+ 	case Opt_sec_krb5p:
+ 		cifs_dbg(VFS, "sec=krb5p is not supported!\n");
+ 		return 1;
+ 	case Opt_sec_krb5i:
+ 		vol->sign = true;
+ 		fallthrough;
+ 	case Opt_sec_krb5:
+ 		vol->sectype = Kerberos;
+ 		break;
+ 	case Opt_sec_ntlmsspi:
+ 		vol->sign = true;
+ 		fallthrough;
+ 	case Opt_sec_ntlmssp:
+ 		vol->sectype = RawNTLMSSP;
+ 		break;
+ 	case Opt_sec_ntlmi:
+ 		vol->sign = true;
+ 		fallthrough;
+ 	case Opt_ntlm:
+ 		vol->sectype = NTLM;
+ 		break;
+ 	case Opt_sec_ntlmv2i:
+ 		vol->sign = true;
+ 		fallthrough;
+ 	case Opt_sec_ntlmv2:
+ 		vol->sectype = NTLMv2;
+ 		break;
+ #ifdef CONFIG_CIFS_WEAK_PW_HASH
+ 	case Opt_sec_lanman:
+ 		vol->sectype = LANMAN;
+ 		break;
+ #endif
+ 	case Opt_sec_none:
+ 		vol->nullauth = 1;
+ 		break;
+ 	default:
+ 		cifs_dbg(VFS, "bad security option: %s\n", value);
+ 		return 1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static const match_table_t cifs_cacheflavor_tokens = {
+ 	{ Opt_cache_loose, "loose" },
+ 	{ Opt_cache_strict, "strict" },
+ 	{ Opt_cache_none, "none" },
+ 	{ Opt_cache_ro, "ro" },
+ 	{ Opt_cache_rw, "singleclient" },
+ 	{ Opt_cache_err, NULL }
+ };
+ 
+ int
+ cifs_parse_cache_flavor(char *value, struct smb_vol *vol)
+ {
+ 	substring_t args[MAX_OPT_ARGS];
+ 
+ 	switch (match_token(value, cifs_cacheflavor_tokens, args)) {
+ 	case Opt_cache_loose:
+ 		vol->direct_io = false;
+ 		vol->strict_io = false;
+ 		vol->cache_ro = false;
+ 		vol->cache_rw = false;
+ 		break;
+ 	case Opt_cache_strict:
+ 		vol->direct_io = false;
+ 		vol->strict_io = true;
+ 		vol->cache_ro = false;
+ 		vol->cache_rw = false;
+ 		break;
+ 	case Opt_cache_none:
+ 		vol->direct_io = true;
+ 		vol->strict_io = false;
+ 		vol->cache_ro = false;
+ 		vol->cache_rw = false;
+ 		break;
+ 	case Opt_cache_ro:
+ 		vol->direct_io = false;
+ 		vol->strict_io = false;
+ 		vol->cache_ro = true;
+ 		vol->cache_rw = false;
+ 		break;
+ 	case Opt_cache_rw:
+ 		vol->direct_io = false;
+ 		vol->strict_io = false;
+ 		vol->cache_ro = false;
+ 		vol->cache_rw = true;
+ 		break;
+ 	default:
+ 		cifs_dbg(VFS, "bad cache= option: %s\n", value);
+ 		return 1;
+ 	}
+ 	return 0;
+ }
++>>>>>>> 555782aa556a (cifs: move smb version mount options into fs_context.c)
diff --cc fs/cifs/fs_context.h
index 082f286f923e,886208a1b0ef..000000000000
--- a/fs/cifs/fs_context.h
+++ b/fs/cifs/fs_context.h
@@@ -9,7 -9,50 +9,52 @@@
  #ifndef _FS_CONTEXT_H
  #define _FS_CONTEXT_H
  
 -#include <linux/parser.h>
 -#include "cifsglob.h"
  
++<<<<<<< HEAD
++=======
+ enum smb_version {
+ 	Smb_1 = 1,
+ 	Smb_20,
+ 	Smb_21,
+ 	Smb_30,
+ 	Smb_302,
+ 	Smb_311,
+ 	Smb_3any,
+ 	Smb_default,
+ 	Smb_version_err
+ };
+ 
+ int cifs_parse_smb_version(char *value, struct smb_vol *vol, bool is_smb3);
+ 
+ enum {
+ 	Opt_cache_loose,
+ 	Opt_cache_strict,
+ 	Opt_cache_none,
+ 	Opt_cache_ro,
+ 	Opt_cache_rw,
+ 	Opt_cache_err
+ };
+ 
+ int cifs_parse_cache_flavor(char *value, struct smb_vol *vol);
+ 
+ enum cifs_sec_param {
+ 	Opt_sec_krb5,
+ 	Opt_sec_krb5i,
+ 	Opt_sec_krb5p,
+ 	Opt_sec_ntlmsspi,
+ 	Opt_sec_ntlmssp,
+ 	Opt_ntlm,
+ 	Opt_sec_ntlmi,
+ 	Opt_sec_ntlmv2,
+ 	Opt_sec_ntlmv2i,
+ 	Opt_sec_lanman,
+ 	Opt_sec_none,
+ 
+ 	Opt_sec_err
+ };
+ 
+ int cifs_parse_security_flavors(char *value, struct smb_vol *vol);
++>>>>>>> 555782aa556a (cifs: move smb version mount options into fs_context.c)
  
  #endif
 +
diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index a1a1a16acb38..b6925aeeb621 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -195,18 +195,6 @@ struct smb_rqst {
 	unsigned int	rq_tailsz;	/* length of last page */
 };
 
-enum smb_version {
-	Smb_1 = 1,
-	Smb_20,
-	Smb_21,
-	Smb_30,
-	Smb_302,
-	Smb_311,
-	Smb_3any,
-	Smb_default,
-	Smb_version_err
-};
-
 struct mid_q_entry;
 struct TCP_Server_Info;
 struct cifsFileInfo;
* Unmerged path fs/cifs/connect.c
* Unmerged path fs/cifs/fs_context.c
* Unmerged path fs/cifs/fs_context.h
