mm: memcontrol: fix get_active_memcg return value

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Muchun Song <songmuchun@bytedance.com>
commit 1685bde6b9af55923180a76152036c7fb7176db0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/1685bde6.failed

We use a global percpu int_active_memcg variable to store the remote memcg
when we are in the interrupt context.  But get_active_memcg always return
the current->active_memcg or root_mem_cgroup.  The remote memcg (set in
the interrupt context) is ignored.  This is not what we want.  So fix it.

Link: https://lkml.kernel.org/r/20210223091101.42150-1-songmuchun@bytedance.com
Fixes: 37d5985c003d ("mm: kmem: prepare remote memcg charging infra for interrupt contexts")
	Signed-off-by: Muchun Song <songmuchun@bytedance.com>
	Reviewed-by: Shakeel Butt <shakeelb@google.com>
	Reviewed-by: Roman Gushchin <guro@fb.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Michal Hocko <mhocko@kernel.org>
	Cc: Vladimir Davydov <vdavydov.dev@gmail.com>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 1685bde6b9af55923180a76152036c7fb7176db0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memcontrol.c
diff --cc mm/memcontrol.c
index b2ef364998e2,845eec01ef9d..000000000000
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@@ -1059,31 -1047,43 +1059,37 @@@ struct mem_cgroup *get_mem_cgroup_from_
  }
  EXPORT_SYMBOL(get_mem_cgroup_from_mm);
  
 -static __always_inline struct mem_cgroup *active_memcg(void)
 +/**
 + * get_mem_cgroup_from_page: Obtain a reference on given page's memcg.
 + * @page: page from which memcg should be extracted.
 + *
 + * Obtain a reference on page->memcg and returns it if successful. Otherwise
 + * root_mem_cgroup is returned.
 + */
 +struct mem_cgroup *get_mem_cgroup_from_page(struct page *page)
  {
 -	if (in_interrupt())
 -		return this_cpu_read(int_active_memcg);
 -	else
 -		return current->active_memcg;
 -}
 +	struct mem_cgroup *memcg = page->mem_cgroup;
  
 -static __always_inline struct mem_cgroup *get_active_memcg(void)
 -{
 -	struct mem_cgroup *memcg;
 +	if (mem_cgroup_disabled())
 +		return NULL;
  
  	rcu_read_lock();
++<<<<<<< HEAD
 +	/* Page should not get uncharged and freed memcg under us. */
 +	if (!memcg || WARN_ON_ONCE(!css_tryget(&memcg->css)))
++=======
+ 	memcg = active_memcg();
+ 	/* remote memcg must hold a ref. */
+ 	if (memcg && WARN_ON_ONCE(!css_tryget(&memcg->css)))
++>>>>>>> 1685bde6b9af (mm: memcontrol: fix get_active_memcg return value)
  		memcg = root_mem_cgroup;
  	rcu_read_unlock();
 -
  	return memcg;
  }
 -
 -static __always_inline bool memcg_kmem_bypass(void)
 -{
 -	/* Allow remote memcg charging from any context. */
 -	if (unlikely(active_memcg()))
 -		return false;
 -
 -	/* Memcg to charge can't be determined. */
 -	if (in_interrupt() || !current->mm || (current->flags & PF_KTHREAD))
 -		return true;
 -
 -	return false;
 -}
 +EXPORT_SYMBOL(get_mem_cgroup_from_page);
  
  /**
 - * If active memcg is set, do not fallback to current->mm->memcg.
 + * If current->active_memcg is non-NULL, do not fallback to current->mm->memcg.
   */
  static __always_inline struct mem_cgroup *get_mem_cgroup_from_current(void)
  {
* Unmerged path mm/memcontrol.c
