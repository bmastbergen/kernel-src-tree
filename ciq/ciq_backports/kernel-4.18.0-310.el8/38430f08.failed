block: move the NEED_PART_SCAN flag to struct gendisk

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 38430f0876fa8b9549ec434f569dce03e057c076
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/38430f08.failed

We can only scan for partitions on the whole disk, so move the flag
from struct block_device to struct gendisk.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 38430f0876fa8b9549ec434f569dce03e057c076)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/genhd.c
#	drivers/block/nbd.c
#	drivers/ide/ide-gd.c
#	fs/block_dev.c
#	include/linux/blk_types.h
diff --cc block/genhd.c
index e5a406eac921,7b56203c90a3..000000000000
--- a/block/genhd.c
+++ b/block/genhd.c
@@@ -736,7 -731,7 +736,11 @@@ static void register_disk(struct devic
  	if (!bdev)
  		goto exit;
  
++<<<<<<< HEAD
 +	bdev->bd_invalidated = 1;
++=======
+ 	set_bit(GD_NEED_PART_SCAN, &disk->state);
++>>>>>>> 38430f0876fa (block: move the NEED_PART_SCAN flag to struct gendisk)
  	err = blkdev_get(bdev, FMODE_READ, NULL);
  	if (err < 0)
  		goto exit;
@@@ -2089,6 -2090,33 +2093,36 @@@ unsigned int disk_clear_events(struct g
  	return pending;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * bdev_check_media_change - check if a removable media has been changed
+  * @bdev: block device to check
+  *
+  * Check whether a removable media has been changed, and attempt to free all
+  * dentries and inodes and invalidates all block device page cache entries in
+  * that case.
+  *
+  * Returns %true if the block device changed, or %false if not.
+  */
+ bool bdev_check_media_change(struct block_device *bdev)
+ {
+ 	unsigned int events;
+ 
+ 	events = disk_clear_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE |
+ 				   DISK_EVENT_EJECT_REQUEST);
+ 	if (!(events & DISK_EVENT_MEDIA_CHANGE))
+ 		return false;
+ 
+ 	if (__invalidate_device(bdev, true))
+ 		pr_warn("VFS: busy inodes on changed media %s\n",
+ 			bdev->bd_disk->disk_name);
+ 	set_bit(GD_NEED_PART_SCAN, &bdev->bd_disk->state);
+ 	return true;
+ }
+ EXPORT_SYMBOL(bdev_check_media_change);
+ 
++>>>>>>> 38430f0876fa (block: move the NEED_PART_SCAN flag to struct gendisk)
  /*
   * Separate this part out so that a different pointer for clearing_ptr can be
   * passed in for disk_clear_events.
diff --cc drivers/block/nbd.c
index d393d6149779,2dca0aab0a9a..000000000000
--- a/drivers/block/nbd.c
+++ b/drivers/block/nbd.c
@@@ -306,14 -309,13 +306,18 @@@ static void nbd_size_update(struct nbd_
  	}
  	blk_queue_logical_block_size(nbd->disk->queue, config->blksize);
  	blk_queue_physical_block_size(nbd->disk->queue, config->blksize);
 -	set_capacity(nbd->disk, nr_sectors);
 +	set_capacity(nbd->disk, config->bytesize >> 9);
  	if (bdev) {
  		if (bdev->bd_disk) {
 -			bd_set_nr_sectors(bdev, nr_sectors);
 -			set_blocksize(bdev, config->blksize);
 +			bd_set_size(bdev, config->bytesize);
 +			if (start)
 +				set_blocksize(bdev, config->blksize);
  		} else
++<<<<<<< HEAD
 +			bdev->bd_invalidated = 1;
++=======
+ 			set_bit(GD_NEED_PART_SCAN, &nbd->disk->state);
++>>>>>>> 38430f0876fa (block: move the NEED_PART_SCAN flag to struct gendisk)
  		bdput(bdev);
  	}
  	kobject_uevent(&nbd_to_dev(nbd)->kobj, KOBJ_CHANGE);
@@@ -1335,7 -1322,7 +1339,11 @@@ static int nbd_start_device_ioctl(struc
  		return ret;
  
  	if (max_part)
++<<<<<<< HEAD
 +		bdev->bd_invalidated = 1;
++=======
+ 		set_bit(GD_NEED_PART_SCAN, &nbd->disk->state);
++>>>>>>> 38430f0876fa (block: move the NEED_PART_SCAN flag to struct gendisk)
  	mutex_unlock(&nbd->config_lock);
  	ret = wait_event_interruptible(config->recv_wq,
  					 atomic_read(&config->recv_threads) == 0);
@@@ -1513,9 -1500,9 +1521,15 @@@ static int nbd_open(struct block_devic
  		refcount_set(&nbd->config_refs, 1);
  		refcount_inc(&nbd->refs);
  		mutex_unlock(&nbd->config_lock);
++<<<<<<< HEAD
 +		bdev->bd_invalidated = 1;
 +	} else if (nbd_disconnected(nbd->config)) {
 +		bdev->bd_invalidated = 1;
++=======
+ 		set_bit(GD_NEED_PART_SCAN, &bdev->bd_disk->state);
+ 	} else if (nbd_disconnected(nbd->config)) {
+ 		set_bit(GD_NEED_PART_SCAN, &bdev->bd_disk->state);
++>>>>>>> 38430f0876fa (block: move the NEED_PART_SCAN flag to struct gendisk)
  	}
  out:
  	mutex_unlock(&nbd_index_mutex);
diff --cc drivers/ide/ide-gd.c
index 04e008e8f6f9,e2b6c82586ce..000000000000
--- a/drivers/ide/ide-gd.c
+++ b/drivers/ide/ide-gd.c
@@@ -224,8 -225,12 +224,17 @@@ static int ide_gd_open(struct block_dev
  		 * and the door_lock is irrelevant at this point.
  		 */
  		drive->disk_ops->set_doorlock(drive, disk, 1);
++<<<<<<< HEAD
 +		drive->dev_flags |= IDE_DFLAG_MEDIA_CHANGED;
 +		check_disk_change(bdev);
++=======
+ 		if (__invalidate_device(bdev, true))
+ 			pr_warn("VFS: busy inodes on changed media %s\n",
+ 				bdev->bd_disk->disk_name);
+ 		drive->disk_ops->get_capacity(drive);
+ 		set_capacity(disk, ide_gd_capacity(drive));
+ 		set_bit(GD_NEED_PART_SCAN, &disk->state);
++>>>>>>> 38430f0876fa (block: move the NEED_PART_SCAN flag to struct gendisk)
  	} else if (drive->dev_flags & IDE_DFLAG_FORMAT_IN_PROGRESS) {
  		ret = -EBUSY;
  		goto out_put_idkp;
diff --cc fs/block_dev.c
index f19cc879b480,1a9325f43157..000000000000
--- a/fs/block_dev.c
+++ b/fs/block_dev.c
@@@ -912,9 -908,8 +912,12 @@@ struct block_device *bdget(dev_t dev
  		bdev->bd_contains = NULL;
  		bdev->bd_super = NULL;
  		bdev->bd_inode = inode;
 +		bdev->bd_block_size = i_blocksize(inode);
  		bdev->bd_part_count = 0;
++<<<<<<< HEAD
 +		bdev->bd_invalidated = 0;
++=======
++>>>>>>> 38430f0876fa (block: move the NEED_PART_SCAN flag to struct gendisk)
  		inode->i_mode = S_IFBLK;
  		inode->i_rdev = dev;
  		inode->i_bdev = bdev;
@@@ -1489,6 -1384,8 +1492,11 @@@ int bdev_disk_changed(struct block_devi
  
  	lockdep_assert_held(&bdev->bd_mutex);
  
++<<<<<<< HEAD
++=======
+ 	clear_bit(GD_NEED_PART_SCAN, &bdev->bd_disk->state);
+ 
++>>>>>>> 38430f0876fa (block: move the NEED_PART_SCAN flag to struct gendisk)
  rescan:
  	ret = blk_drop_partitions(bdev);
  	if (ret)
@@@ -1613,7 -1508,7 +1621,11 @@@ static int __blkdev_get(struct block_de
  			 * The latter is necessary to prevent ghost
  			 * partitions on a removed medium.
  			 */
++<<<<<<< HEAD
 +			if (bdev->bd_invalidated &&
++=======
+ 			if (test_bit(GD_NEED_PART_SCAN, &disk->state) &&
++>>>>>>> 38430f0876fa (block: move the NEED_PART_SCAN flag to struct gendisk)
  			    (!ret || ret == -ENOMEDIUM))
  				bdev_disk_changed(bdev, ret == -ENOMEDIUM);
  
@@@ -1650,7 -1538,7 +1662,11 @@@
  			if (bdev->bd_disk->fops->open)
  				ret = bdev->bd_disk->fops->open(bdev, mode);
  			/* the same as first opener case, read comment there */
++<<<<<<< HEAD
 +			if (bdev->bd_invalidated &&
++=======
+ 			if (test_bit(GD_NEED_PART_SCAN, &disk->state) &&
++>>>>>>> 38430f0876fa (block: move the NEED_PART_SCAN flag to struct gendisk)
  			    (!ret || ret == -ENOMEDIUM))
  				bdev_disk_changed(bdev, ret == -ENOMEDIUM);
  			if (ret)
diff --cc include/linux/blk_types.h
index 01eb143dd5ae,eb20e28184ab..000000000000
--- a/include/linux/blk_types.h
+++ b/include/linux/blk_types.h
@@@ -19,6 -17,36 +19,39 @@@ struct block_device
  struct io_context;
  struct cgroup_subsys_state;
  typedef void (bio_end_io_t) (struct bio *);
++<<<<<<< HEAD
++=======
+ struct bio_crypt_ctx;
+ 
+ struct block_device {
+ 	dev_t			bd_dev;
+ 	int			bd_openers;
+ 	struct inode *		bd_inode;	/* will die */
+ 	struct super_block *	bd_super;
+ 	struct mutex		bd_mutex;	/* open/close mutex */
+ 	void *			bd_claiming;
+ 	void *			bd_holder;
+ 	int			bd_holders;
+ 	bool			bd_write_holder;
+ #ifdef CONFIG_SYSFS
+ 	struct list_head	bd_holder_disks;
+ #endif
+ 	struct block_device *	bd_contains;
+ 	u8			bd_partno;
+ 	struct hd_struct *	bd_part;
+ 	/* number of times partitions within this device have been opened. */
+ 	unsigned		bd_part_count;
+ 
+ 	spinlock_t		bd_size_lock; /* for bd_inode->i_size updates */
+ 	struct gendisk *	bd_disk;
+ 	struct backing_dev_info *bd_bdi;
+ 
+ 	/* The counter of freeze processes */
+ 	int			bd_fsfreeze_count;
+ 	/* Mutex for freeze */
+ 	struct mutex		bd_fsfreeze_mutex;
+ } __randomize_layout;
++>>>>>>> 38430f0876fa (block: move the NEED_PART_SCAN flag to struct gendisk)
  
  /*
   * Block error status values.  See block/blk-core:blk_errors for the details.
* Unmerged path block/genhd.c
* Unmerged path drivers/block/nbd.c
* Unmerged path drivers/ide/ide-gd.c
* Unmerged path fs/block_dev.c
* Unmerged path include/linux/blk_types.h
diff --git a/include/linux/genhd.h b/include/linux/genhd.h
index 0fcca343e13b..3d7b6c8166ef 100644
--- a/include/linux/genhd.h
+++ b/include/linux/genhd.h
@@ -208,6 +208,8 @@ struct gendisk {
 	void *private_data;
 
 	int flags;
+	unsigned long state;
+#define GD_NEED_PART_SCAN		0
 	struct rw_semaphore lookup_sem;
 	struct kobject *slave_dir;
 
