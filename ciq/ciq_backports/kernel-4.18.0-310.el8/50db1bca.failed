ice: add support for flash update overwrite mask

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit 50db1bca55208d7f0528a1fa0619ce5d406a8d40
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/50db1bca.failed

Support the recently added DEVLINK_ATTR_FLASH_UPDATE_OVERWRITE_MASK
parameter in the ice flash update handler. Convert the overwrite mask
bitfield into the appropriate preservation level used by the firmware
when updating.

Because there is no equivalent preservation level for overwriting only
identifiers, this combination is rejected by the driver as not supported
with an appropriate extended ACK message.

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Reviewed-by: Jakub Kicinski <kuba@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 50db1bca55208d7f0528a1fa0619ce5d406a8d40)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_devlink.c
diff --cc drivers/net/ethernet/intel/ice/ice_devlink.c
index fcaf121d9ee1,e17b44059eae..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_devlink.c
+++ b/drivers/net/ethernet/intel/ice/ice_devlink.c
@@@ -250,11 -250,23 +250,29 @@@ ice_devlink_flash_update(struct devlin
  	struct device *dev = &pf->pdev->dev;
  	struct ice_hw *hw = &pf->hw;
  	const struct firmware *fw;
+ 	u8 preservation;
  	int err;
  
++<<<<<<< HEAD
 +	/* individual component update is not yet supported */
 +	if (component)
 +		return -EOPNOTSUPP;
++=======
+ 	if (!params->overwrite_mask) {
+ 		/* preserve all settings and identifiers */
+ 		preservation = ICE_AQC_NVM_PRESERVE_ALL;
+ 	} else if (params->overwrite_mask == DEVLINK_FLASH_OVERWRITE_SETTINGS) {
+ 		/* overwrite settings, but preserve the vital device identifiers */
+ 		preservation = ICE_AQC_NVM_PRESERVE_SELECTED;
+ 	} else if (params->overwrite_mask == (DEVLINK_FLASH_OVERWRITE_SETTINGS |
+ 					      DEVLINK_FLASH_OVERWRITE_IDENTIFIERS)) {
+ 		/* overwrite both settings and identifiers, preserve nothing */
+ 		preservation = ICE_AQC_NVM_NO_PRESERVATION;
+ 	} else {
+ 		NL_SET_ERR_MSG_MOD(extack, "Requested overwrite mask is not supported");
+ 		return -EOPNOTSUPP;
+ 	}
++>>>>>>> 50db1bca5520 (ice: add support for flash update overwrite mask)
  
  	if (!hw->dev_caps.common_cap.nvm_unified_update) {
  		NL_SET_ERR_MSG_MOD(extack, "Current firmware does not support unified update");
@@@ -272,9 -284,8 +290,14 @@@
  	}
  
  	devlink_flash_update_begin_notify(devlink);
++<<<<<<< HEAD
 +	devlink_flash_update_status_notify(devlink, "Preparing to flash",
 +					   component, 0, 0);
 +	err = ice_flash_pldm_image(pf, fw, extack);
++=======
+ 	devlink_flash_update_status_notify(devlink, "Preparing to flash", NULL, 0, 0);
+ 	err = ice_flash_pldm_image(pf, fw, preservation, extack);
++>>>>>>> 50db1bca5520 (ice: add support for flash update overwrite mask)
  	devlink_flash_update_end_notify(devlink);
  
  	release_firmware(fw);
diff --git a/Documentation/networking/devlink/ice.rst b/Documentation/networking/devlink/ice.rst
index aca5c009c0aa..b165181d5d4d 100644
--- a/Documentation/networking/devlink/ice.rst
+++ b/Documentation/networking/devlink/ice.rst
@@ -86,6 +86,37 @@ The ``ice`` driver reports the following versions
       - 0xee16ced7
       - The first 4 bytes of the hash of the netlist module contents.
 
+Flash Update
+============
+
+The ``ice`` driver implements support for flash update using the
+``devlink-flash`` interface. It supports updating the device flash using a
+combined flash image that contains the ``fw.mgmt``, ``fw.undi``, and
+``fw.netlist`` components.
+
+.. list-table:: List of supported overwrite modes
+   :widths: 5 95
+
+   * - Bits
+     - Behavior
+   * - ``DEVLINK_FLASH_OVERWRITE_SETTINGS``
+     - Do not preserve settings stored in the flash components being
+       updated. This includes overwriting the port configuration that
+       determines the number of physical functions the device will
+       initialize with.
+   * - ``DEVLINK_FLASH_OVERWRITE_SETTINGS`` and ``DEVLINK_FLASH_OVERWRITE_IDENTIFIERS``
+     - Do not preserve either settings or identifiers. Overwrite everything
+       in the flash with the contents from the provided image, without
+       performing any preservation. This includes overwriting device
+       identifying fields such as the MAC address, VPD area, and device
+       serial number. It is expected that this combination be used with an
+       image customized for the specific device.
+
+The ice hardware does not support overwriting only identifiers while
+preserving settings, and thus ``DEVLINK_FLASH_OVERWRITE_IDENTIFIERS`` on its
+own will be rejected. If no overwrite mask is provided, the firmware will be
+instructed to preserve all settings and identifying fields when updating.
+
 Regions
 =======
 
* Unmerged path drivers/net/ethernet/intel/ice/ice_devlink.c
diff --git a/drivers/net/ethernet/intel/ice/ice_fw_update.c b/drivers/net/ethernet/intel/ice/ice_fw_update.c
index 3fb66474bddb..382decb9ae91 100644
--- a/drivers/net/ethernet/intel/ice/ice_fw_update.c
+++ b/drivers/net/ethernet/intel/ice/ice_fw_update.c
@@ -631,6 +631,7 @@ static const struct pldmfw_ops ice_fwu_ops = {
  * ice_flash_pldm_image - Write a PLDM-formatted firmware image to the device
  * @pf: private device driver structure
  * @fw: firmware object pointing to the relevant firmware file
+ * @preservation: preservation level to request from firmware
  * @extack: netlink extended ACK structure
  *
  * Parse the data for a given firmware file, verifying that it is a valid PLDM
@@ -644,7 +645,7 @@ static const struct pldmfw_ops ice_fwu_ops = {
  * Returns: zero on success or a negative error code on failure.
  */
 int ice_flash_pldm_image(struct ice_pf *pf, const struct firmware *fw,
-			 struct netlink_ext_ack *extack)
+			 u8 preservation, struct netlink_ext_ack *extack)
 {
 	struct device *dev = ice_pf_to_dev(pf);
 	struct ice_hw *hw = &pf->hw;
@@ -652,13 +653,24 @@ int ice_flash_pldm_image(struct ice_pf *pf, const struct firmware *fw,
 	enum ice_status status;
 	int err;
 
+	switch (preservation) {
+	case ICE_AQC_NVM_PRESERVE_ALL:
+	case ICE_AQC_NVM_PRESERVE_SELECTED:
+	case ICE_AQC_NVM_NO_PRESERVATION:
+	case ICE_AQC_NVM_FACTORY_DEFAULT:
+		break;
+	default:
+		WARN(1, "Unexpected preservation level request %u", preservation);
+		return -EINVAL;
+	}
+
 	memset(&priv, 0, sizeof(priv));
 
 	priv.context.ops = &ice_fwu_ops;
 	priv.context.dev = dev;
 	priv.extack = extack;
 	priv.pf = pf;
-	priv.activate_flags = ICE_AQC_NVM_PRESERVE_ALL;
+	priv.activate_flags = preservation;
 
 	status = ice_acquire_nvm(hw, ICE_RES_WRITE);
 	if (status) {
diff --git a/drivers/net/ethernet/intel/ice/ice_fw_update.h b/drivers/net/ethernet/intel/ice/ice_fw_update.h
index 79472cc618b4..c6390f6851ff 100644
--- a/drivers/net/ethernet/intel/ice/ice_fw_update.h
+++ b/drivers/net/ethernet/intel/ice/ice_fw_update.h
@@ -5,7 +5,7 @@
 #define _ICE_FW_UPDATE_H_
 
 int ice_flash_pldm_image(struct ice_pf *pf, const struct firmware *fw,
-			 struct netlink_ext_ack *extack);
+			 u8 preservation, struct netlink_ext_ack *extack);
 int ice_check_for_pending_update(struct ice_pf *pf, const char *component,
 				 struct netlink_ext_ack *extack);
 
