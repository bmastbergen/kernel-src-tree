KVM/VMX/SVM: Move kvm_machine_check function to x86.h

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Uros Bizjak <ubizjak@gmail.com>
commit 3f1a18b9fa1c294802d2750d1ef6a1221b10b76b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/3f1a18b9.failed

Move kvm_machine_check to x86.h to avoid two exact copies
of the same function in kvm.c and svm.c.

	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Cc: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Uros Bizjak <ubizjak@gmail.com>
Message-Id: <20201029135600.122392-1-ubizjak@gmail.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 3f1a18b9fa1c294802d2750d1ef6a1221b10b76b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm/svm.c
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/kvm/svm/svm.c
index f5e539ff1fc8,544b6e362cf7..000000000000
--- a/arch/x86/kvm/svm/svm.c
+++ b/arch/x86/kvm/svm/svm.c
@@@ -1935,25 -1932,6 +1934,28 @@@ static bool is_erratum_383(void
  	return true;
  }
  
++<<<<<<< HEAD
 +/*
 + * Trigger machine check on the host. We assume all the MSRs are already set up
 + * by the CPU and that we still run on the same CPU as the MCE occurred on.
 + * We pass a fake environment to the machine check handler because we want
 + * the guest to be always treated like user space, no matter what context
 + * it used internally.
 + */
 +static void kvm_machine_check(void)
 +{
 +#if defined(CONFIG_X86_MCE)
 +	struct pt_regs regs = {
 +		.cs = 3, /* Fake ring 3 no matter what the guest ran on */
 +		.flags = X86_EFLAGS_IF,
 +	};
 +
 +	do_machine_check(&regs, 0);
 +#endif
 +}
 +
++=======
++>>>>>>> 3f1a18b9fa1c (KVM/VMX/SVM: Move kvm_machine_check function to x86.h)
  static void svm_handle_mce(struct vcpu_svm *svm)
  {
  	if (is_erratum_383()) {
diff --cc arch/x86/kvm/vmx/vmx.c
index f6b70e177eef,849be2a9f260..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -4715,25 -4715,6 +4714,28 @@@ static int handle_rmode_exception(struc
  	return 1;
  }
  
++<<<<<<< HEAD
 +/*
 + * Trigger machine check on the host. We assume all the MSRs are already set up
 + * by the CPU and that we still run on the same CPU as the MCE occurred on.
 + * We pass a fake environment to the machine check handler because we want
 + * the guest to be always treated like user space, no matter what context
 + * it used internally.
 + */
 +static void kvm_machine_check(void)
 +{
 +#if defined(CONFIG_X86_MCE)
 +	struct pt_regs regs = {
 +		.cs = 3, /* Fake ring 3 no matter what the guest ran on */
 +		.flags = X86_EFLAGS_IF,
 +	};
 +
 +	do_machine_check(&regs, 0);
 +#endif
 +}
 +
++=======
++>>>>>>> 3f1a18b9fa1c (KVM/VMX/SVM: Move kvm_machine_check function to x86.h)
  static int handle_machine_check(struct kvm_vcpu *vcpu)
  {
  	/* handled by vmx_vcpu_run() */
* Unmerged path arch/x86/kvm/svm/svm.c
* Unmerged path arch/x86/kvm/vmx/vmx.c
diff --git a/arch/x86/kvm/x86.h b/arch/x86/kvm/x86.h
index 55f2a775abf3..e5ed13f55eb9 100644
--- a/arch/x86/kvm/x86.h
+++ b/arch/x86/kvm/x86.h
@@ -3,6 +3,7 @@
 #define ARCH_X86_KVM_X86_H
 
 #include <linux/kvm_host.h>
+#include <asm/mce.h>
 #include <asm/pvclock.h>
 #include "kvm_cache_regs.h"
 #include "kvm_emulate.h"
@@ -368,6 +369,25 @@ static inline bool kvm_dr6_valid(u64 data)
 	return !(data >> 32);
 }
 
+/*
+ * Trigger machine check on the host. We assume all the MSRs are already set up
+ * by the CPU and that we still run on the same CPU as the MCE occurred on.
+ * We pass a fake environment to the machine check handler because we want
+ * the guest to be always treated like user space, no matter what context
+ * it used internally.
+ */
+static inline void kvm_machine_check(void)
+{
+#if defined(CONFIG_X86_MCE)
+	struct pt_regs regs = {
+		.cs = 3, /* Fake ring 3 no matter what the guest ran on */
+		.flags = X86_EFLAGS_IF,
+	};
+
+	do_machine_check(&regs);
+#endif
+}
+
 void kvm_load_guest_xsave_state(struct kvm_vcpu *vcpu);
 void kvm_load_host_xsave_state(struct kvm_vcpu *vcpu);
 
