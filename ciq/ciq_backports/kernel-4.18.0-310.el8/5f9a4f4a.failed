mm: memcontrol: add the missing numa_stat interface for cgroup v2

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Muchun Song <songmuchun@bytedance.com>
commit 5f9a4f4a709608fc15197368464a6c8ed4e3630a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/5f9a4f4a.failed

In the cgroup v1, we have a numa_stat interface.  This is useful for
providing visibility into the numa locality information within an memcg
since the pages are allowed to be allocated from any physical node.  One
of the use cases is evaluating application performance by combining this
information with the application's CPU allocation.  But the cgroup v2 does
not.  So this patch adds the missing information.

	Suggested-by: Shakeel Butt <shakeelb@google.com>
	Signed-off-by: Muchun Song <songmuchun@bytedance.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Reviewed-by: Shakeel Butt <shakeelb@google.com>
	Cc: Zefan Li <lizefan@huawei.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Michal Hocko <mhocko@kernel.org>
	Cc: Vladimir Davydov <vdavydov.dev@gmail.com>
	Cc: Roman Gushchin <guro@fb.com>
	Cc: Randy Dunlap <rdunlap@infradead.org>
Link: https://lkml.kernel.org/r/20200916100030.71698-2-songmuchun@bytedance.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 5f9a4f4a709608fc15197368464a6c8ed4e3630a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memcontrol.c
diff --cc mm/memcontrol.c
index e0c5e437cb00,e9fa32a943c5..000000000000
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@@ -1493,52 -1532,19 +1557,39 @@@ static char *memory_stat_format(struct 
  	 * Current memory state:
  	 */
  
++<<<<<<< HEAD
 +	seq_buf_printf(&s, "anon %llu\n",
 +		       (u64)memcg_page_state(memcg, NR_ANON_MAPPED) *
 +		       PAGE_SIZE);
 +	seq_buf_printf(&s, "file %llu\n",
 +		       (u64)memcg_page_state(memcg, NR_FILE_PAGES) *
 +		       PAGE_SIZE);
 +	seq_buf_printf(&s, "kernel_stack %llu\n",
 +		       (u64)memcg_page_state(memcg, MEMCG_KERNEL_STACK_KB) *
 +		       1024);
 +	seq_buf_printf(&s, "slab %llu\n",
 +		       (u64)(memcg_page_state(memcg, NR_SLAB_RECLAIMABLE_B) +
 +			     memcg_page_state(memcg, NR_SLAB_UNRECLAIMABLE_B)));
 +	seq_buf_printf(&s, "percpu %llu\n",
 +		       (u64)memcg_page_state(memcg, MEMCG_PERCPU_B));
 +	seq_buf_printf(&s, "sock %llu\n",
 +		       (u64)memcg_page_state(memcg, MEMCG_SOCK) *
 +		       PAGE_SIZE);
- 
- 	seq_buf_printf(&s, "shmem %llu\n",
- 		       (u64)memcg_page_state(memcg, NR_SHMEM) *
- 		       PAGE_SIZE);
- 	seq_buf_printf(&s, "file_mapped %llu\n",
- 		       (u64)memcg_page_state(memcg, NR_FILE_MAPPED) *
- 		       PAGE_SIZE);
- 	seq_buf_printf(&s, "file_dirty %llu\n",
- 		       (u64)memcg_page_state(memcg, NR_FILE_DIRTY) *
- 		       PAGE_SIZE);
- 	seq_buf_printf(&s, "file_writeback %llu\n",
- 		       (u64)memcg_page_state(memcg, NR_WRITEBACK) *
- 		       PAGE_SIZE);
- 
- #ifdef CONFIG_TRANSPARENT_HUGEPAGE
- 	seq_buf_printf(&s, "anon_thp %llu\n",
- 		       (u64)memcg_page_state(memcg, NR_ANON_THPS) *
- 		       HPAGE_PMD_SIZE);
- #endif
- 
- 	for (i = 0; i < NR_LRU_LISTS; i++)
- 		seq_buf_printf(&s, "%s %llu\n", lru_list_name(i),
- 			       (u64)memcg_page_state(memcg, NR_LRU_BASE + i) *
- 			       PAGE_SIZE);
- 
- 	seq_buf_printf(&s, "slab_reclaimable %llu\n",
- 		       (u64)memcg_page_state(memcg, NR_SLAB_RECLAIMABLE_B));
- 	seq_buf_printf(&s, "slab_unreclaimable %llu\n",
- 		       (u64)memcg_page_state(memcg, NR_SLAB_UNRECLAIMABLE_B));
++=======
+ 	for (i = 0; i < ARRAY_SIZE(memory_stats); i++) {
+ 		u64 size;
++>>>>>>> 5f9a4f4a7096 (mm: memcontrol: add the missing numa_stat interface for cgroup v2)
+ 
+ 		size = memcg_page_state(memcg, memory_stats[i].idx);
+ 		size *= memory_stats[i].ratio;
+ 		seq_buf_printf(&s, "%s %llu\n", memory_stats[i].name, size);
+ 
+ 		if (unlikely(memory_stats[i].idx == NR_SLAB_UNRECLAIMABLE_B)) {
+ 			size = memcg_page_state(memcg, NR_SLAB_RECLAIMABLE_B) +
+ 			       memcg_page_state(memcg, NR_SLAB_UNRECLAIMABLE_B);
+ 			seq_buf_printf(&s, "slab %llu\n", size);
+ 		}
+ 	}
  
  	/* Accumulated memory events */
  
diff --git a/Documentation/admin-guide/cgroup-v2.rst b/Documentation/admin-guide/cgroup-v2.rst
index bc0fc04d2632..0b2033b37920 100644
--- a/Documentation/admin-guide/cgroup-v2.rst
+++ b/Documentation/admin-guide/cgroup-v2.rst
@@ -1227,6 +1227,10 @@ PAGE_SIZE multiple when read back.
 	can show up in the middle. Don't rely on items remaining in a
 	fixed position; use the keys to look up specific values!
 
+	If the entry has no per-node counter(or not show in the
+	mempry.numa_stat). We use 'npn'(non-per-node) as the tag
+	to indicate that it will not show in the mempry.numa_stat.
+
 	  anon
 		Amount of memory used in anonymous mappings such as
 		brk(), sbrk(), and mmap(MAP_ANONYMOUS)
@@ -1238,15 +1242,11 @@ PAGE_SIZE multiple when read back.
 	  kernel_stack
 		Amount of memory allocated to kernel stacks.
 
-	  slab
-		Amount of memory used for storing in-kernel data
-		structures.
-
-	  percpu
+	  percpu(npn)
 		Amount of memory used for storing per-cpu kernel
 		data structures.
 
-	  sock
+	  sock(npn)
 		Amount of memory used in network transmission buffers
 
 	  shmem
@@ -1281,11 +1281,9 @@ PAGE_SIZE multiple when read back.
 		Part of "slab" that cannot be reclaimed on memory
 		pressure.
 
-	  pgfault
-		Total number of page faults incurred
-
-	  pgmajfault
-		Number of major page faults incurred
+	  slab(npn)
+		Amount of memory used for storing in-kernel data
+		structures.
 
 	  workingset_refault_anon
 		Number of refaults of previously evicted anonymous pages.
@@ -1311,37 +1309,68 @@ PAGE_SIZE multiple when read back.
 	  workingset_nodereclaim
 		Number of times a shadow node has been reclaimed
 
-	  pgrefill
+	  pgfault(npn)
+		Total number of page faults incurred
+
+	  pgmajfault(npn)
+		Number of major page faults incurred
+
+	  pgrefill(npn)
 		Amount of scanned pages (in an active LRU list)
 
-	  pgscan
+	  pgscan(npn)
 		Amount of scanned pages (in an inactive LRU list)
 
-	  pgsteal
+	  pgsteal(npn)
 		Amount of reclaimed pages
 
-	  pgactivate
+	  pgactivate(npn)
 		Amount of pages moved to the active LRU list
 
-	  pgdeactivate
+	  pgdeactivate(npn)
 		Amount of pages moved to the inactive LRU list
 
-	  pglazyfree
+	  pglazyfree(npn)
 		Amount of pages postponed to be freed under memory pressure
 
-	  pglazyfreed
+	  pglazyfreed(npn)
 		Amount of reclaimed lazyfree pages
 
-	  thp_fault_alloc
+	  thp_fault_alloc(npn)
 		Number of transparent hugepages which were allocated to satisfy
 		a page fault. This counter is not present when CONFIG_TRANSPARENT_HUGEPAGE
                 is not set.
 
-	  thp_collapse_alloc
+	  thp_collapse_alloc(npn)
 		Number of transparent hugepages which were allocated to allow
 		collapsing an existing range of pages. This counter is not
 		present when CONFIG_TRANSPARENT_HUGEPAGE is not set.
 
+  memory.numa_stat
+	A read-only nested-keyed file which exists on non-root cgroups.
+
+	This breaks down the cgroup's memory footprint into different
+	types of memory, type-specific details, and other information
+	per node on the state of the memory management system.
+
+	This is useful for providing visibility into the NUMA locality
+	information within an memcg since the pages are allowed to be
+	allocated from any physical node. One of the use case is evaluating
+	application performance by combining this information with the
+	application's CPU allocation.
+
+	All memory amounts are in bytes.
+
+	The output format of memory.numa_stat is::
+
+	  type N0=<bytes in node 0> N1=<bytes in node 1> ...
+
+	The entries are ordered to be human readable, and new entries
+	can show up in the middle. Don't rely on items remaining in a
+	fixed position; use the keys to look up specific values!
+
+	The entries can refer to the memory.stat.
+
   memory.swap.current
 	A read-only single value file which exists on non-root
 	cgroups.
* Unmerged path mm/memcontrol.c
