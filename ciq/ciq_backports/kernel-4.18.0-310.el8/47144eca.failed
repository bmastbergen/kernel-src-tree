kcsan: Show full access type in report

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Marco Elver <elver@google.com>
commit 47144eca282189afcf34ef25aee8408c168765d4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/47144eca.failed

This commit adds access-type information to KCSAN's reports as follows:
"read", "read (marked)", "write", and "write (marked)".

	Suggested-by: Paul E. McKenney <paulmck@kernel.org>
	Signed-off-by: Marco Elver <elver@google.com>
	Signed-off-by: Paul E. McKenney <paulmck@kernel.org>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 47144eca282189afcf34ef25aee8408c168765d4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/kcsan/core.c
#	kernel/kcsan/kcsan.h
#	kernel/kcsan/report.c
diff --cc kernel/kcsan/core.c
index d9410d58c93e,87bf857c8893..000000000000
--- a/kernel/kcsan/core.c
+++ b/kernel/kcsan/core.c
@@@ -260,7 -254,8 +260,12 @@@ static inline unsigned int get_delay(vo
   */
  
  static noinline void kcsan_found_watchpoint(const volatile void *ptr,
++<<<<<<< HEAD
 +					    size_t size, bool is_write,
++=======
+ 					    size_t size,
+ 					    int type,
++>>>>>>> 47144eca2821 (kcsan: Show full access type in report)
  					    atomic_long_t *watchpoint,
  					    long encoded_watchpoint)
  {
@@@ -296,9 -291,10 +301,15 @@@
  	user_access_restore(flags);
  }
  
++<<<<<<< HEAD
 +static noinline void kcsan_setup_watchpoint(const volatile void *ptr,
 +					    size_t size, bool is_write)
++=======
+ static noinline void
+ kcsan_setup_watchpoint(const volatile void *ptr, size_t size, int type)
++>>>>>>> 47144eca2821 (kcsan: Show full access type in report)
  {
+ 	const bool is_write = (type & KCSAN_ACCESS_WRITE) != 0;
  	atomic_long_t *watchpoint;
  	union {
  		u8 _1;
diff --cc kernel/kcsan/kcsan.h
index 1bb2f1c0d61e,8492da45494b..000000000000
--- a/kernel/kcsan/kcsan.h
+++ b/kernel/kcsan/kcsan.h
@@@ -102,7 -102,8 +102,12 @@@ enum kcsan_report_type 
  /*
   * Print a race report from thread that encountered the race.
   */
++<<<<<<< HEAD
 +void kcsan_report(const volatile void *ptr, size_t size, bool is_write,
 +		  bool value_change, int cpu_id, enum kcsan_report_type type);
++=======
+ extern void kcsan_report(const volatile void *ptr, size_t size, int access_type,
+ 			 bool value_change, int cpu_id, enum kcsan_report_type type);
++>>>>>>> 47144eca2821 (kcsan: Show full access type in report)
  
  #endif /* _KERNEL_KCSAN_KCSAN_H */
diff --cc kernel/kcsan/report.c
index ead5610bafa7,9f503ca2ff7a..000000000000
--- a/kernel/kcsan/report.c
+++ b/kernel/kcsan/report.c
@@@ -22,13 -22,13 +22,23 @@@
   * the reports, with reporting being in the slow-path.
   */
  static struct {
++<<<<<<< HEAD
 +	const volatile void *ptr;
 +	size_t size;
 +	bool is_write;
 +	int task_pid;
 +	int cpu_id;
 +	unsigned long stack_entries[NUM_STACK_ENTRIES];
 +	int num_stack_entries;
++=======
+ 	const volatile void	*ptr;
+ 	size_t			size;
+ 	int			access_type;
+ 	int			task_pid;
+ 	int			cpu_id;
+ 	unsigned long		stack_entries[NUM_STACK_ENTRIES];
+ 	int			num_stack_entries;
++>>>>>>> 47144eca2821 (kcsan: Show full access type in report)
  } other_info = { .ptr = NULL };
  
  /*
@@@ -40,9 -40,11 +50,16 @@@ static DEFINE_SPINLOCK(report_lock)
  /*
   * Special rules to skip reporting.
   */
++<<<<<<< HEAD
 +static bool skip_report(bool is_write, bool value_change,
 +			unsigned long top_frame)
++=======
+ static bool
+ skip_report(int access_type, bool value_change, unsigned long top_frame)
++>>>>>>> 47144eca2821 (kcsan: Show full access type in report)
  {
+ 	const bool is_write = (access_type & KCSAN_ACCESS_WRITE) != 0;
+ 
  	if (IS_ENABLED(CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY) && is_write &&
  	    !value_change) {
  		/*
@@@ -131,8 -144,8 +159,13 @@@ static bool print_report(const volatil
  		other_skipnr = get_stack_skipnr(other_info.stack_entries,
  						other_info.num_stack_entries);
  
++<<<<<<< HEAD
 +		/* value_change is only known for the other thread */
 +		if (skip_report(other_info.is_write, value_change,
++=======
+ 		/* @value_change is only known for the other thread */
+ 		if (skip_report(other_info.access_type, value_change,
++>>>>>>> 47144eca2821 (kcsan: Show full access type in report)
  				other_info.stack_entries[other_skipnr]))
  			return false;
  	}
@@@ -241,13 -254,12 +274,22 @@@ retry
  		if (other_info.ptr != NULL)
  			break; /* still in use, retry */
  
++<<<<<<< HEAD
 +		other_info.ptr = ptr;
 +		other_info.size = size;
 +		other_info.is_write = is_write;
 +		other_info.task_pid = in_task() ? task_pid_nr(current) : -1;
 +		other_info.cpu_id = cpu_id;
 +		other_info.num_stack_entries = stack_trace_save(
 +			other_info.stack_entries, NUM_STACK_ENTRIES, 1);
++=======
+ 		other_info.ptr			= ptr;
+ 		other_info.size			= size;
+ 		other_info.access_type		= access_type;
+ 		other_info.task_pid		= in_task() ? task_pid_nr(current) : -1;
+ 		other_info.cpu_id		= cpu_id;
+ 		other_info.num_stack_entries	= stack_trace_save(other_info.stack_entries, NUM_STACK_ENTRIES, 1);
++>>>>>>> 47144eca2821 (kcsan: Show full access type in report)
  
  		spin_unlock_irqrestore(&report_lock, *flags);
  
@@@ -308,10 -321,8 +350,15 @@@ void kcsan_report(const volatile void *
  	unsigned long flags = 0;
  
  	kcsan_disable_current();
++<<<<<<< HEAD
 +	if (prepare_report(&flags, ptr, size, is_write, cpu_id, type)) {
 +		if (print_report(ptr, size, is_write, value_change, cpu_id,
 +				 type) &&
 +		    panic_on_warn)
++=======
+ 	if (prepare_report(&flags, ptr, size, access_type, cpu_id, type)) {
+ 		if (print_report(ptr, size, access_type, value_change, cpu_id, type) && panic_on_warn)
++>>>>>>> 47144eca2821 (kcsan: Show full access type in report)
  			panic("panic_on_warn set ...\n");
  
  		release_report(&flags, type);
* Unmerged path kernel/kcsan/core.c
* Unmerged path kernel/kcsan/kcsan.h
* Unmerged path kernel/kcsan/report.c
