RDMA/drivers: Remove udata check from special QP

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Leon Romanovsky <leonro@nvidia.com>
commit b925c555a15de8443ecb2e147b54b1bbe9b71fe3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/b925c555.failed

GSI QP can't be created from the user space, hence the udata check is
always false (udata == NULL). Remove that check and simplify the flow.

Link: https://lore.kernel.org/r/20200926102450.2966017-9-leon@kernel.org
	Reviewed-by: Maor Gottlieb <maorg@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit b925c555a15de8443ecb2e147b54b1bbe9b71fe3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hns/hns_roce_qp.c
diff --cc drivers/infiniband/hw/hns/hns_roce_qp.c
index ed75cc0e9ed0,6e06f42be5eb..000000000000
--- a/drivers/infiniband/hw/hns/hns_roce_qp.c
+++ b/drivers/infiniband/hw/hns/hns_roce_qp.c
@@@ -858,66 -1015,34 +858,89 @@@ struct ib_qp *hns_roce_create_qp(struc
  	int ret;
  
  	switch (init_attr->qp_type) {
++<<<<<<< HEAD
 +	case IB_QPT_RC: {
 +		hr_qp = kzalloc(sizeof(*hr_qp), GFP_KERNEL);
 +		if (!hr_qp)
 +			return ERR_PTR(-ENOMEM);
 +
 +		ret = hns_roce_create_qp_common(hr_dev, pd, init_attr, udata, 0,
 +						hr_qp);
 +		if (ret) {
 +			ibdev_err(ibdev, "Create RC QP 0x%06lx failed(%d)\n",
 +				  hr_qp->qpn, ret);
 +			kfree(hr_qp);
 +			return ERR_PTR(ret);
 +		}
 +
 +		hr_qp->ibqp.qp_num = hr_qp->qpn;
 +
 +		break;
 +	}
 +	case IB_QPT_GSI: {
 +		/* Userspace is not allowed to create special QPs: */
 +		if (udata) {
 +			ibdev_err(ibdev, "not support usr space GSI\n");
 +			return ERR_PTR(-EINVAL);
 +		}
 +
 +		hr_sqp = kzalloc(sizeof(*hr_sqp), GFP_KERNEL);
 +		if (!hr_sqp)
 +			return ERR_PTR(-ENOMEM);
 +
 +		hr_qp = &hr_sqp->hr_qp;
 +		hr_qp->port = init_attr->port_num - 1;
 +		hr_qp->phy_port = hr_dev->iboe.phy_port[hr_qp->port];
 +
 +		/* when hw version is v1, the sqpn is allocated */
 +		if (hr_dev->caps.max_sq_sg <= 2)
 +			hr_qp->ibqp.qp_num = HNS_ROCE_MAX_PORTS +
 +					     hr_dev->iboe.phy_port[hr_qp->port];
 +		else
 +			hr_qp->ibqp.qp_num = 1;
 +
 +		ret = hns_roce_create_qp_common(hr_dev, pd, init_attr, udata,
 +						hr_qp->ibqp.qp_num, hr_qp);
 +		if (ret) {
 +			ibdev_err(ibdev, "Create GSI QP failed!\n");
 +			kfree(hr_sqp);
 +			return ERR_PTR(ret);
 +		}
 +
 +		break;
 +	}
 +	default:{
++=======
+ 	case IB_QPT_RC:
+ 	case IB_QPT_GSI:
+ 		break;
+ 	default:
++>>>>>>> b925c555a15d (RDMA/drivers: Remove udata check from special QP)
  		ibdev_err(ibdev, "not support QP type %d\n",
  			  init_attr->qp_type);
  		return ERR_PTR(-EOPNOTSUPP);
  	}
+ 
+ 	hr_qp = kzalloc(sizeof(*hr_qp), GFP_KERNEL);
+ 	if (!hr_qp)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	if (init_attr->qp_type == IB_QPT_GSI) {
+ 		hr_qp->port = init_attr->port_num - 1;
+ 		hr_qp->phy_port = hr_dev->iboe.phy_port[hr_qp->port];
  	}
  
+ 	ret = hns_roce_create_qp_common(hr_dev, pd, init_attr, udata, hr_qp);
+ 	if (ret) {
+ 		ibdev_err(ibdev, "Create QP type 0x%x failed(%d)\n",
+ 			  init_attr->qp_type, ret);
+ 		ibdev_err(ibdev, "Create GSI QP failed!\n");
+ 		kfree(hr_qp);
+ 		return ERR_PTR(ret);
+ 	}
  	return &hr_qp->ibqp;
  }
 +EXPORT_SYMBOL_GPL(hns_roce_create_qp);
  
  int to_hr_qp_type(int qp_type)
  {
* Unmerged path drivers/infiniband/hw/hns/hns_roce_qp.c
diff --git a/drivers/infiniband/hw/mlx4/qp.c b/drivers/infiniband/hw/mlx4/qp.c
index 7bf33a449bf7..1c729fa93e7b 100644
--- a/drivers/infiniband/hw/mlx4/qp.c
+++ b/drivers/infiniband/hw/mlx4/qp.c
@@ -1543,9 +1543,6 @@ static int _mlx4_ib_create_qp(struct ib_pd *pd, struct mlx4_ib_qp *qp,
 	{
 		int sqpn;
 
-		/* Userspace is not allowed to create special QPs: */
-		if (udata)
-			return -EINVAL;
 		if (init_attr->create_flags & MLX4_IB_QP_CREATE_ROCE_V2_GSI) {
 			int res = mlx4_qp_reserve_range(to_mdev(pd->device)->dev,
 							1, 1, &sqpn, 0,
diff --git a/drivers/infiniband/hw/mlx5/qp.c b/drivers/infiniband/hw/mlx5/qp.c
index a6560ec2d863..8c68a1ba8afe 100644
--- a/drivers/infiniband/hw/mlx5/qp.c
+++ b/drivers/infiniband/hw/mlx5/qp.c
@@ -2504,18 +2504,6 @@ static int check_valid_flow(struct mlx5_ib_dev *dev, struct ib_pd *pd,
 		return -EINVAL;
 	}
 
-	switch (attr->qp_type) {
-	case IB_QPT_SMI:
-	case MLX5_IB_QPT_HW_GSI:
-	case MLX5_IB_QPT_REG_UMR:
-	case IB_QPT_GSI:
-		mlx5_ib_dbg(dev, "Kernel doesn't support QP type %d\n",
-			    attr->qp_type);
-		return -EINVAL;
-	default:
-		break;
-	}
-
 	/*
 	 * We don't need to see this warning, it means that kernel code
 	 * missing ib_pd. Placed here to catch developer's mistakes.
diff --git a/drivers/infiniband/hw/mthca/mthca_provider.c b/drivers/infiniband/hw/mthca/mthca_provider.c
index 368e0268177f..6d432af1b71f 100644
--- a/drivers/infiniband/hw/mthca/mthca_provider.c
+++ b/drivers/infiniband/hw/mthca/mthca_provider.c
@@ -534,10 +534,6 @@ static struct ib_qp *mthca_create_qp(struct ib_pd *pd,
 	case IB_QPT_SMI:
 	case IB_QPT_GSI:
 	{
-		/* Don't allow userspace to create special QPs */
-		if (udata)
-			return ERR_PTR(-EINVAL);
-
 		qp = kzalloc(sizeof(struct mthca_sqp), GFP_KERNEL);
 		if (!qp)
 			return ERR_PTR(-ENOMEM);
diff --git a/drivers/infiniband/hw/qedr/verbs.c b/drivers/infiniband/hw/qedr/verbs.c
index 211dd1b8cc64..d780dd8a594b 100644
--- a/drivers/infiniband/hw/qedr/verbs.c
+++ b/drivers/infiniband/hw/qedr/verbs.c
@@ -1234,14 +1234,6 @@ static int qedr_check_qp_attrs(struct ib_pd *ibpd, struct qedr_dev *dev,
 		return -EINVAL;
 	}
 
-	/* Unprivileged user space cannot create special QP */
-	if (udata && attrs->qp_type == IB_QPT_GSI) {
-		DP_ERR(dev,
-		       "create qp: userspace can't create special QPs of type=0x%x\n",
-		       attrs->qp_type);
-		return -EINVAL;
-	}
-
 	/* verify consumer QPs are not trying to use GSI QP's CQ.
 	 * TGT QP isn't associated with RQ/SQ
 	 */
diff --git a/drivers/infiniband/hw/vmw_pvrdma/pvrdma_qp.c b/drivers/infiniband/hw/vmw_pvrdma/pvrdma_qp.c
index af09d9d56c4b..13f008c2ca63 100644
--- a/drivers/infiniband/hw/vmw_pvrdma/pvrdma_qp.c
+++ b/drivers/infiniband/hw/vmw_pvrdma/pvrdma_qp.c
@@ -232,8 +232,7 @@ struct ib_qp *pvrdma_create_qp(struct ib_pd *pd,
 	switch (init_attr->qp_type) {
 	case IB_QPT_GSI:
 		if (init_attr->port_num == 0 ||
-		    init_attr->port_num > pd->device->phys_port_cnt ||
-		    udata) {
+		    init_attr->port_num > pd->device->phys_port_cnt) {
 			dev_warn(&dev->pdev->dev, "invalid queuepair attrs\n");
 			ret = -EINVAL;
 			goto err_qp;
