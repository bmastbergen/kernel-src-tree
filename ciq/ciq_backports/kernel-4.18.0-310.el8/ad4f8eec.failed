kcsan: Address missing case with KCSAN_REPORT_VALUE_CHANGE_ONLY

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Marco Elver <elver@google.com>
commit ad4f8eeca8eaa24afb6059c241a2f4baf86378f3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/ad4f8eec.failed

Even with KCSAN_REPORT_VALUE_CHANGE_ONLY, KCSAN still reports data
races between reads and watchpointed writes, even if the writes wrote
values already present.  This commit causes KCSAN to unconditionally
skip reporting in this case.

	Signed-off-by: Marco Elver <elver@google.com>
	Signed-off-by: Paul E. McKenney <paulmck@kernel.org>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit ad4f8eeca8eaa24afb6059c241a2f4baf86378f3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/kcsan/report.c
diff --cc kernel/kcsan/report.c
index 94d805f88916,7cd34285df74..000000000000
--- a/kernel/kcsan/report.c
+++ b/kernel/kcsan/report.c
@@@ -41,11 -76,79 +41,34 @@@ static DEFINE_SPINLOCK(report_lock)
  /*
   * Special rules to skip reporting.
   */
++<<<<<<< HEAD
 +static bool skip_report(bool is_write, bool value_change,
 +			unsigned long top_frame)
 +{
 +	if (IS_ENABLED(CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY) && is_write &&
 +	    !value_change) {
++=======
+ static bool
+ skip_report(bool value_change, unsigned long top_frame)
+ {
+ 	/*
+ 	 * The first call to skip_report always has value_change==true, since we
+ 	 * cannot know the value written of an instrumented access. For the 2nd
+ 	 * call there are 6 cases with CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY:
+ 	 *
+ 	 * 1. read watchpoint, conflicting write (value_change==true): report;
+ 	 * 2. read watchpoint, conflicting write (value_change==false): skip;
+ 	 * 3. write watchpoint, conflicting write (value_change==true): report;
+ 	 * 4. write watchpoint, conflicting write (value_change==false): skip;
+ 	 * 5. write watchpoint, conflicting read (value_change==false): skip;
+ 	 * 6. write watchpoint, conflicting read (value_change==true): impossible;
+ 	 *
+ 	 * Cases 1-4 are intuitive and expected; case 5 ensures we do not report
+ 	 * data races where the write may have rewritten the same value; and
+ 	 * case 6 is simply impossible.
+ 	 */
+ 	if (IS_ENABLED(CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY) && !value_change) {
++>>>>>>> ad4f8eeca8ea (kcsan: Address missing case with KCSAN_REPORT_VALUE_CHANGE_ONLY)
  		/*
  		 * The access is a write, but the data value did not change.
  		 *
@@@ -125,16 -241,16 +148,25 @@@ static bool print_report(const volatil
  	/*
  	 * Must check report filter rules before starting to print.
  	 */
++<<<<<<< HEAD
 +	if (skip_report(is_write, true, stack_entries[skipnr]))
++=======
+ 	if (skip_report(true, stack_entries[skipnr]))
++>>>>>>> ad4f8eeca8ea (kcsan: Address missing case with KCSAN_REPORT_VALUE_CHANGE_ONLY)
  		return false;
  
  	if (type == KCSAN_REPORT_RACE_SIGNAL) {
  		other_skipnr = get_stack_skipnr(other_info.stack_entries,
  						other_info.num_stack_entries);
 -		other_frame = other_info.stack_entries[other_skipnr];
  
++<<<<<<< HEAD
 +		/* value_change is only known for the other thread */
 +		if (skip_report(other_info.is_write, value_change,
 +				other_info.stack_entries[other_skipnr]))
++=======
+ 		/* @value_change is only known for the other thread */
+ 		if (skip_report(value_change, other_frame))
++>>>>>>> ad4f8eeca8ea (kcsan: Address missing case with KCSAN_REPORT_VALUE_CHANGE_ONLY)
  			return false;
  	}
  
* Unmerged path kernel/kcsan/report.c
