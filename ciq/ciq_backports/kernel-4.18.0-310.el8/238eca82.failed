KVM: SVM: Allocate SEV command structures on local stack

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Sean Christopherson <seanjc@google.com>
commit 238eca821cee90e91139da84ef4f38c74d7cf0d9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/238eca82.failed

Use the local stack to "allocate" the structures used to communicate with
the PSP.  The largest struct used by KVM, sev_data_launch_secret, clocks
in at 52 bytes, well within the realm of reasonable stack usage.  The
smallest structs are a mere 4 bytes, i.e. the pointer for the allocation
is larger than the allocation itself.

Now that the PSP driver plays nice with vmalloc pointers, putting the
data on a virtually mapped stack (CONFIG_VMAP_STACK=y) will not cause
explosions.

	Cc: Brijesh Singh <brijesh.singh@amd.com>
	Cc: Tom Lendacky <thomas.lendacky@amd.com>
	Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20210406224952.4177376-9-seanjc@google.com>
	Reviewed-by: Brijesh Singh <brijesh.singh@amd.com>
	Acked-by: Tom Lendacky <thomas.lendacky@amd.com>
[Apply same treatment to PSP migration commands. - Paolo]
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 238eca821cee90e91139da84ef4f38c74d7cf0d9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm/sev.c
diff --cc arch/x86/kvm/svm/sev.c
index fbe9a30eb1a6,b4e471b0a231..000000000000
--- a/arch/x86/kvm/svm/sev.c
+++ b/arch/x86/kvm/svm/sev.c
@@@ -617,18 -597,15 +581,20 @@@ static int sev_launch_measure(struct kv
  
  	p = (void __user *)(uintptr_t)params.uaddr;
  	if (p) {
- 		if (params.len > SEV_FW_BLOB_MAX_SIZE) {
- 			ret = -EINVAL;
- 			goto e_free;
- 		}
+ 		if (params.len > SEV_FW_BLOB_MAX_SIZE)
+ 			return -EINVAL;
  
++<<<<<<< HEAD
 +		ret = -ENOMEM;
 +		blob = kmalloc(params.len, GFP_KERNEL);
++=======
+ 		blob = kmalloc(params.len, GFP_KERNEL_ACCOUNT);
++>>>>>>> 238eca821cee (KVM: SVM: Allocate SEV command structures on local stack)
  		if (!blob)
- 			goto e_free;
+ 			return -ENOMEM;
  
- 		data->address = __psp_pa(blob);
- 		data->len = params.len;
+ 		data.address = __psp_pa(blob);
+ 		data.len = params.len;
  	}
  
  cmd:
@@@ -1054,23 -1005,20 +994,25 @@@ static int sev_get_attestation_report(s
  
  	p = (void __user *)(uintptr_t)params.uaddr;
  	if (p) {
- 		if (params.len > SEV_FW_BLOB_MAX_SIZE) {
- 			ret = -EINVAL;
- 			goto e_free;
- 		}
+ 		if (params.len > SEV_FW_BLOB_MAX_SIZE)
+ 			return -EINVAL;
  
++<<<<<<< HEAD
 +		ret = -ENOMEM;
 +		blob = kmalloc(params.len, GFP_KERNEL);
++=======
+ 		blob = kmalloc(params.len, GFP_KERNEL_ACCOUNT);
++>>>>>>> 238eca821cee (KVM: SVM: Allocate SEV command structures on local stack)
  		if (!blob)
- 			goto e_free;
+ 			return -ENOMEM;
  
- 		data->address = __psp_pa(blob);
- 		data->len = params.len;
- 		memcpy(data->mnonce, params.mnonce, sizeof(params.mnonce));
+ 		data.address = __psp_pa(blob);
+ 		data.len = params.len;
+ 		memcpy(data.mnonce, params.mnonce, sizeof(params.mnonce));
  	}
  cmd:
- 	data->handle = sev->handle;
- 	ret = sev_issue_cmd(kvm, SEV_CMD_ATTESTATION_REPORT, data, &argp->error);
+ 	data.handle = sev->handle;
+ 	ret = sev_issue_cmd(kvm, SEV_CMD_ATTESTATION_REPORT, &data, &argp->error);
  	/*
  	 * If we query the session length, FW responded with expected data.
  	 */
@@@ -1221,6 -1154,291 +1148,294 @@@ e_free_session
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ /* Userspace wants to query either header or trans length. */
+ static int
+ __sev_send_update_data_query_lengths(struct kvm *kvm, struct kvm_sev_cmd *argp,
+ 				     struct kvm_sev_send_update_data *params)
+ {
+ 	struct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;
+ 	struct sev_data_send_update_data data;
+ 	int ret;
+ 
+ 	data.handle = sev->handle;
+ 	ret = sev_issue_cmd(kvm, SEV_CMD_SEND_UPDATE_DATA, &data, &argp->error);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	params->hdr_len = data.hdr_len;
+ 	params->trans_len = data.trans_len;
+ 
+ 	if (copy_to_user((void __user *)(uintptr_t)argp->data, params,
+ 			 sizeof(struct kvm_sev_send_update_data)))
+ 		ret = -EFAULT;
+ 
+ 	return ret;
+ }
+ 
+ static int sev_send_update_data(struct kvm *kvm, struct kvm_sev_cmd *argp)
+ {
+ 	struct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;
+ 	struct sev_data_send_update_data data;
+ 	struct kvm_sev_send_update_data params;
+ 	void *hdr, *trans_data;
+ 	struct page **guest_page;
+ 	unsigned long n;
+ 	int ret, offset;
+ 
+ 	if (!sev_guest(kvm))
+ 		return -ENOTTY;
+ 
+ 	if (copy_from_user(&params, (void __user *)(uintptr_t)argp->data,
+ 			sizeof(struct kvm_sev_send_update_data)))
+ 		return -EFAULT;
+ 
+ 	/* userspace wants to query either header or trans length */
+ 	if (!params.trans_len || !params.hdr_len)
+ 		return __sev_send_update_data_query_lengths(kvm, argp, &params);
+ 
+ 	if (!params.trans_uaddr || !params.guest_uaddr ||
+ 	    !params.guest_len || !params.hdr_uaddr)
+ 		return -EINVAL;
+ 
+ 	/* Check if we are crossing the page boundary */
+ 	offset = params.guest_uaddr & (PAGE_SIZE - 1);
+ 	if ((params.guest_len + offset > PAGE_SIZE))
+ 		return -EINVAL;
+ 
+ 	/* Pin guest memory */
+ 	guest_page = sev_pin_memory(kvm, params.guest_uaddr & PAGE_MASK,
+ 				    PAGE_SIZE, &n, 0);
+ 	if (!guest_page)
+ 		return -EFAULT;
+ 
+ 	/* allocate memory for header and transport buffer */
+ 	ret = -ENOMEM;
+ 	hdr = kmalloc(params.hdr_len, GFP_KERNEL_ACCOUNT);
+ 	if (!hdr)
+ 		goto e_unpin;
+ 
+ 	trans_data = kmalloc(params.trans_len, GFP_KERNEL_ACCOUNT);
+ 	if (!trans_data)
+ 		goto e_free_hdr;
+ 
+ 	memset(&data, 0, sizeof(data));
+ 	data.hdr_address = __psp_pa(hdr);
+ 	data.hdr_len = params.hdr_len;
+ 	data.trans_address = __psp_pa(trans_data);
+ 	data.trans_len = params.trans_len;
+ 
+ 	/* The SEND_UPDATE_DATA command requires C-bit to be always set. */
+ 	data.guest_address = (page_to_pfn(guest_page[0]) << PAGE_SHIFT) + offset;
+ 	data.guest_address |= sev_me_mask;
+ 	data.guest_len = params.guest_len;
+ 	data.handle = sev->handle;
+ 
+ 	ret = sev_issue_cmd(kvm, SEV_CMD_SEND_UPDATE_DATA, &data, &argp->error);
+ 
+ 	if (ret)
+ 		goto e_free_trans_data;
+ 
+ 	/* copy transport buffer to user space */
+ 	if (copy_to_user((void __user *)(uintptr_t)params.trans_uaddr,
+ 			 trans_data, params.trans_len)) {
+ 		ret = -EFAULT;
+ 		goto e_free_trans_data;
+ 	}
+ 
+ 	/* Copy packet header to userspace. */
+ 	ret = copy_to_user((void __user *)(uintptr_t)params.hdr_uaddr, hdr,
+ 				params.hdr_len);
+ 
+ e_free_trans_data:
+ 	kfree(trans_data);
+ e_free_hdr:
+ 	kfree(hdr);
+ e_unpin:
+ 	sev_unpin_memory(kvm, guest_page, n);
+ 
+ 	return ret;
+ }
+ 
+ static int sev_send_finish(struct kvm *kvm, struct kvm_sev_cmd *argp)
+ {
+ 	struct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;
+ 	struct sev_data_send_finish data;
+ 
+ 	if (!sev_guest(kvm))
+ 		return -ENOTTY;
+ 
+ 	data.handle = sev->handle;
+ 	return sev_issue_cmd(kvm, SEV_CMD_SEND_FINISH, &data, &argp->error);
+ }
+ 
+ static int sev_send_cancel(struct kvm *kvm, struct kvm_sev_cmd *argp)
+ {
+ 	struct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;
+ 	struct sev_data_send_cancel data;
+ 
+ 	if (!sev_guest(kvm))
+ 		return -ENOTTY;
+ 
+ 	data.handle = sev->handle;
+ 	return sev_issue_cmd(kvm, SEV_CMD_SEND_CANCEL, &data, &argp->error);
+ }
+ 
+ static int sev_receive_start(struct kvm *kvm, struct kvm_sev_cmd *argp)
+ {
+ 	struct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;
+ 	struct sev_data_receive_start start;
+ 	struct kvm_sev_receive_start params;
+ 	int *error = &argp->error;
+ 	void *session_data;
+ 	void *pdh_data;
+ 	int ret;
+ 
+ 	if (!sev_guest(kvm))
+ 		return -ENOTTY;
+ 
+ 	/* Get parameter from the userspace */
+ 	if (copy_from_user(&params, (void __user *)(uintptr_t)argp->data,
+ 			sizeof(struct kvm_sev_receive_start)))
+ 		return -EFAULT;
+ 
+ 	/* some sanity checks */
+ 	if (!params.pdh_uaddr || !params.pdh_len ||
+ 	    !params.session_uaddr || !params.session_len)
+ 		return -EINVAL;
+ 
+ 	pdh_data = psp_copy_user_blob(params.pdh_uaddr, params.pdh_len);
+ 	if (IS_ERR(pdh_data))
+ 		return PTR_ERR(pdh_data);
+ 
+ 	session_data = psp_copy_user_blob(params.session_uaddr,
+ 			params.session_len);
+ 	if (IS_ERR(session_data)) {
+ 		ret = PTR_ERR(session_data);
+ 		goto e_free_pdh;
+ 	}
+ 
+ 	memset(&start, 0, sizeof(start));
+ 	start.handle = params.handle;
+ 	start.policy = params.policy;
+ 	start.pdh_cert_address = __psp_pa(pdh_data);
+ 	start.pdh_cert_len = params.pdh_len;
+ 	start.session_address = __psp_pa(session_data);
+ 	start.session_len = params.session_len;
+ 
+ 	/* create memory encryption context */
+ 	ret = __sev_issue_cmd(argp->sev_fd, SEV_CMD_RECEIVE_START, &start,
+ 				error);
+ 	if (ret)
+ 		goto e_free_session;
+ 
+ 	/* Bind ASID to this guest */
+ 	ret = sev_bind_asid(kvm, start.handle, error);
+ 	if (ret)
+ 		goto e_free_session;
+ 
+ 	params.handle = start.handle;
+ 	if (copy_to_user((void __user *)(uintptr_t)argp->data,
+ 			 &params, sizeof(struct kvm_sev_receive_start))) {
+ 		ret = -EFAULT;
+ 		sev_unbind_asid(kvm, start.handle);
+ 		goto e_free_session;
+ 	}
+ 
+     	sev->handle = start.handle;
+ 	sev->fd = argp->sev_fd;
+ 
+ e_free_session:
+ 	kfree(session_data);
+ e_free_pdh:
+ 	kfree(pdh_data);
+ 
+ 	return ret;
+ }
+ 
+ static int sev_receive_update_data(struct kvm *kvm, struct kvm_sev_cmd *argp)
+ {
+ 	struct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;
+ 	struct kvm_sev_receive_update_data params;
+ 	struct sev_data_receive_update_data data;
+ 	void *hdr = NULL, *trans = NULL;
+ 	struct page **guest_page;
+ 	unsigned long n;
+ 	int ret, offset;
+ 
+ 	if (!sev_guest(kvm))
+ 		return -EINVAL;
+ 
+ 	if (copy_from_user(&params, (void __user *)(uintptr_t)argp->data,
+ 			sizeof(struct kvm_sev_receive_update_data)))
+ 		return -EFAULT;
+ 
+ 	if (!params.hdr_uaddr || !params.hdr_len ||
+ 	    !params.guest_uaddr || !params.guest_len ||
+ 	    !params.trans_uaddr || !params.trans_len)
+ 		return -EINVAL;
+ 
+ 	/* Check if we are crossing the page boundary */
+ 	offset = params.guest_uaddr & (PAGE_SIZE - 1);
+ 	if ((params.guest_len + offset > PAGE_SIZE))
+ 		return -EINVAL;
+ 
+ 	hdr = psp_copy_user_blob(params.hdr_uaddr, params.hdr_len);
+ 	if (IS_ERR(hdr))
+ 		return PTR_ERR(hdr);
+ 
+ 	trans = psp_copy_user_blob(params.trans_uaddr, params.trans_len);
+ 	if (IS_ERR(trans)) {
+ 		ret = PTR_ERR(trans);
+ 		goto e_free_hdr;
+ 	}
+ 
+ 	memset(&data, 0, sizeof(data));
+ 	data.hdr_address = __psp_pa(hdr);
+ 	data.hdr_len = params.hdr_len;
+ 	data.trans_address = __psp_pa(trans);
+ 	data.trans_len = params.trans_len;
+ 
+ 	/* Pin guest memory */
+ 	ret = -EFAULT;
+ 	guest_page = sev_pin_memory(kvm, params.guest_uaddr & PAGE_MASK,
+ 				    PAGE_SIZE, &n, 0);
+ 	if (!guest_page)
+ 		goto e_free_trans;
+ 
+ 	/* The RECEIVE_UPDATE_DATA command requires C-bit to be always set. */
+ 	data.guest_address = (page_to_pfn(guest_page[0]) << PAGE_SHIFT) + offset;
+ 	data.guest_address |= sev_me_mask;
+ 	data.guest_len = params.guest_len;
+ 	data.handle = sev->handle;
+ 
+ 	ret = sev_issue_cmd(kvm, SEV_CMD_RECEIVE_UPDATE_DATA, &data,
+ 				&argp->error);
+ 
+ 	sev_unpin_memory(kvm, guest_page, n);
+ 
+ e_free_trans:
+ 	kfree(trans);
+ e_free_hdr:
+ 	kfree(hdr);
+ 
+ 	return ret;
+ }
+ 
+ static int sev_receive_finish(struct kvm *kvm, struct kvm_sev_cmd *argp)
+ {
+ 	struct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;
+ 	struct sev_data_receive_finish data;
+ 
+ 	if (!sev_guest(kvm))
+ 		return -ENOTTY;
+ 
+ 	data.handle = sev->handle;
+ 	return sev_issue_cmd(kvm, SEV_CMD_RECEIVE_FINISH, &data, &argp->error);
+ }
+ 
++>>>>>>> 238eca821cee (KVM: SVM: Allocate SEV command structures on local stack)
  int svm_mem_enc_op(struct kvm *kvm, void __user *argp)
  {
  	struct kvm_sev_cmd sev_cmd;
* Unmerged path arch/x86/kvm/svm/sev.c
