KVM: PPC: Don't always report hash MMU capability for P9 < DD2.2

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Fabiano Rosas <farosas@linux.ibm.com>
commit a722076e947023a0d6ffca79661324c45ff30641
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/a722076e.failed

These machines don't support running both MMU types at the same time,
so remove the KVM_CAP_PPC_MMU_HASH_V3 capability when the host is
using Radix MMU.

[paulus@ozlabs.org - added defensive check on
 kvmppc_hv_ops->hash_v3_possible]

	Signed-off-by: Fabiano Rosas <farosas@linux.ibm.com>
	Signed-off-by: Paul Mackerras <paulus@ozlabs.org>
(cherry picked from commit a722076e947023a0d6ffca79661324c45ff30641)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/kvm_ppc.h
#	arch/powerpc/kvm/book3s_hv.c
diff --cc arch/powerpc/include/asm/kvm_ppc.h
index c03851cff31e,df4bda867bab..000000000000
--- a/arch/powerpc/include/asm/kvm_ppc.h
+++ b/arch/powerpc/include/asm/kvm_ppc.h
@@@ -325,6 -314,8 +325,11 @@@ struct kvmppc_ops 
  			      int size);
  	int (*enable_svm)(struct kvm *kvm);
  	int (*svm_off)(struct kvm *kvm);
++<<<<<<< HEAD
++=======
+ 	int (*enable_dawr1)(struct kvm *kvm);
+ 	bool (*hash_v3_possible)(void);
++>>>>>>> a722076e9470 (KVM: PPC: Don't always report hash MMU capability for P9 < DD2.2)
  };
  
  extern struct kvmppc_ops *kvmppc_hv_ops;
diff --cc arch/powerpc/kvm/book3s_hv.c
index f9d66873b017,f09708da216e..000000000000
--- a/arch/powerpc/kvm/book3s_hv.c
+++ b/arch/powerpc/kvm/book3s_hv.c
@@@ -5578,6 -5614,26 +5578,29 @@@ out
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int kvmhv_enable_dawr1(struct kvm *kvm)
+ {
+ 	if (!cpu_has_feature(CPU_FTR_DAWR1))
+ 		return -ENODEV;
+ 
+ 	/* kvm == NULL means the caller is testing if the capability exists */
+ 	if (kvm)
+ 		kvm->arch.dawr1_enabled = true;
+ 	return 0;
+ }
+ 
+ static bool kvmppc_hash_v3_possible(void)
+ {
+ 	if (radix_enabled() && no_mixing_hpt_and_radix)
+ 		return false;
+ 
+ 	return cpu_has_feature(CPU_FTR_ARCH_300) &&
+ 		cpu_has_feature(CPU_FTR_HVMODE);
+ }
+ 
++>>>>>>> a722076e9470 (KVM: PPC: Don't always report hash MMU capability for P9 < DD2.2)
  static struct kvmppc_ops kvm_ops_hv = {
  	.get_sregs = kvm_arch_vcpu_ioctl_get_sregs_hv,
  	.set_sregs = kvm_arch_vcpu_ioctl_set_sregs_hv,
@@@ -5621,6 -5677,8 +5644,11 @@@
  	.store_to_eaddr = kvmhv_store_to_eaddr,
  	.enable_svm = kvmhv_enable_svm,
  	.svm_off = kvmhv_svm_off,
++<<<<<<< HEAD
++=======
+ 	.enable_dawr1 = kvmhv_enable_dawr1,
+ 	.hash_v3_possible = kvmppc_hash_v3_possible,
++>>>>>>> a722076e9470 (KVM: PPC: Don't always report hash MMU capability for P9 < DD2.2)
  };
  
  static int kvm_init_subcore_bitmap(void)
* Unmerged path arch/powerpc/include/asm/kvm_ppc.h
* Unmerged path arch/powerpc/kvm/book3s_hv.c
diff --git a/arch/powerpc/kvm/powerpc.c b/arch/powerpc/kvm/powerpc.c
index a78a217a21c0..98100c4b560f 100644
--- a/arch/powerpc/kvm/powerpc.c
+++ b/arch/powerpc/kvm/powerpc.c
@@ -625,8 +625,8 @@ int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)
 		r = !!(hv_enabled && radix_enabled());
 		break;
 	case KVM_CAP_PPC_MMU_HASH_V3:
-		r = !!(hv_enabled && cpu_has_feature(CPU_FTR_ARCH_300) &&
-		       cpu_has_feature(CPU_FTR_HVMODE));
+		r = !!(hv_enabled && kvmppc_hv_ops->hash_v3_possible &&
+		       kvmppc_hv_ops->hash_v3_possible());
 		break;
 	case KVM_CAP_PPC_NESTED_HV:
 		r = !!(hv_enabled && kvmppc_hv_ops->enable_nested &&
