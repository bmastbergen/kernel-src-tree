KVM: x86/xen: register vcpu time info region

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Joao Martins <joao.m.martins@oracle.com>
commit f2340cd9e41dc463cb1189274f3db560c1dfa1f4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/f2340cd9.failed

Allow the Xen emulated guest the ability to register secondary
vcpu time information. On Xen guests this is used in order to be
mapped to userspace and hence allow vdso gettimeofday to work.

	Signed-off-by: Joao Martins <joao.m.martins@oracle.com>
	Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
(cherry picked from commit f2340cd9e41dc463cb1189274f3db560c1dfa1f4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/kvm_host.h
#	arch/x86/kvm/x86.c
#	arch/x86/kvm/xen.c
#	include/uapi/linux/kvm.h
diff --cc arch/x86/include/asm/kvm_host.h
index 3e713240c995,c6c84c4ef7b0..000000000000
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@@ -531,6 -531,15 +531,18 @@@ struct kvm_vcpu_hv 
  	cpumask_t tlb_flush;
  };
  
++<<<<<<< HEAD
++=======
+ /* Xen HVM per vcpu emulation context */
+ struct kvm_vcpu_xen {
+ 	u64 hypercall_rip;
+ 	bool vcpu_info_set;
+ 	bool vcpu_time_info_set;
+ 	struct gfn_to_hva_cache vcpu_info_cache;
+ 	struct gfn_to_hva_cache vcpu_time_info_cache;
+ };
+ 
++>>>>>>> f2340cd9e41d (KVM: x86/xen: register vcpu time info region)
  struct kvm_vcpu_arch {
  	/*
  	 * rip and regs accesses must go through
diff --cc arch/x86/kvm/x86.c
index 9ebc64032528,0f648434796f..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -2742,7 -2753,12 +2742,16 @@@ static int kvm_guest_time_update(struc
  	vcpu->hv_clock.flags = pvclock_flags;
  
  	if (vcpu->pv_time_enabled)
++<<<<<<< HEAD
 +		kvm_setup_pvclock_page(v);
++=======
+ 		kvm_setup_pvclock_page(v, &vcpu->pv_time, 0);
+ 	if (vcpu->xen.vcpu_info_set)
+ 		kvm_setup_pvclock_page(v, &vcpu->xen.vcpu_info_cache,
+ 				       offsetof(struct compat_vcpu_info, time));
+ 	if (vcpu->xen.vcpu_time_info_set)
+ 		kvm_setup_pvclock_page(v, &vcpu->xen.vcpu_time_info_cache, 0);
++>>>>>>> f2340cd9e41d (KVM: x86/xen: register vcpu time info region)
  	if (v == kvm_get_vcpu(v->kvm, 0))
  		kvm_hv_setup_tsc_page(v->kvm, &vcpu->hv_clock);
  	return 0;
diff --cc include/uapi/linux/kvm.h
index a9fa79abd23a,0f045ffd9cb6..000000000000
--- a/include/uapi/linux/kvm.h
+++ b/include/uapi/linux/kvm.h
@@@ -1556,6 -1584,44 +1556,47 @@@ struct kvm_pv_cmd 
  /* Available with KVM_CAP_X86_MSR_FILTER */
  #define KVM_X86_SET_MSR_FILTER	_IOW(KVMIO,  0xc6, struct kvm_msr_filter)
  
++<<<<<<< HEAD
++=======
+ /* Available with KVM_CAP_DIRTY_LOG_RING */
+ #define KVM_RESET_DIRTY_RINGS		_IO(KVMIO, 0xc7)
+ 
+ /* Per-VM Xen attributes */
+ #define KVM_XEN_HVM_GET_ATTR	_IOWR(KVMIO, 0xc8, struct kvm_xen_hvm_attr)
+ #define KVM_XEN_HVM_SET_ATTR	_IOW(KVMIO,  0xc9, struct kvm_xen_hvm_attr)
+ 
+ struct kvm_xen_hvm_attr {
+ 	__u16 type;
+ 	__u16 pad[3];
+ 	union {
+ 		__u8 long_mode;
+ 		struct {
+ 			__u64 gfn;
+ 		} shared_info;
+ 		__u64 pad[8];
+ 	} u;
+ };
+ 
+ #define KVM_XEN_ATTR_TYPE_LONG_MODE		0x0
+ #define KVM_XEN_ATTR_TYPE_SHARED_INFO		0x1
+ 
+ /* Per-vCPU Xen attributes */
+ #define KVM_XEN_VCPU_GET_ATTR	_IOWR(KVMIO, 0xca, struct kvm_xen_vcpu_attr)
+ #define KVM_XEN_VCPU_SET_ATTR	_IOW(KVMIO,  0xcb, struct kvm_xen_vcpu_attr)
+ 
+ struct kvm_xen_vcpu_attr {
+ 	__u16 type;
+ 	__u16 pad[3];
+ 	union {
+ 		__u64 gpa;
+ 		__u64 pad[8];
+ 	} u;
+ };
+ 
+ #define KVM_XEN_VCPU_ATTR_TYPE_VCPU_INFO	0x0
+ #define KVM_XEN_VCPU_ATTR_TYPE_VCPU_TIME_INFO	0x1
+ 
++>>>>>>> f2340cd9e41d (KVM: x86/xen: register vcpu time info region)
  /* Secure Encrypted Virtualization command */
  enum sev_cmd_id {
  	/* Guest initialization commands */
* Unmerged path arch/x86/kvm/xen.c
* Unmerged path arch/x86/include/asm/kvm_host.h
* Unmerged path arch/x86/kvm/x86.c
* Unmerged path arch/x86/kvm/xen.c
* Unmerged path include/uapi/linux/kvm.h
