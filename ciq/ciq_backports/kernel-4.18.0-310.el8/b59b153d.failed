KVM: x86: allow compiling out the Xen hypercall interface

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit b59b153d1026b73deb032d01bb9319ebba896006
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/b59b153d.failed

The Xen hypercall interface adds to the attack surface of the hypervisor
and will be used quite rarely.  Allow compiling it out.

	Suggested-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: David Woodhouse <dwmw@amazon.co.uk>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit b59b153d1026b73deb032d01bb9319ebba896006)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/x86.c
#	arch/x86/kvm/xen.h
diff --cc arch/x86/kvm/x86.c
index 5b18614d5081,4a5ce57b0bb2..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -3777,6 -3755,13 +3777,16 @@@ int kvm_vm_ioctl_check_extension(struc
  	case KVM_CAP_ENFORCE_PV_FEATURE_CPUID:
  		r = 1;
  		break;
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_KVM_XEN
+ 	case KVM_CAP_XEN_HVM:
+ 		r = KVM_XEN_HVM_CONFIG_HYPERCALL_MSR |
+ 		    KVM_XEN_HVM_CONFIG_INTERCEPT_HCALL |
+ 		    KVM_XEN_HVM_CONFIG_SHARED_INFO;
+ 		break;
+ #endif
++>>>>>>> b59b153d1026 (KVM: x86: allow compiling out the Xen hypercall interface)
  	case KVM_CAP_SYNC_REGS:
  		r = KVM_SYNC_X86_VALID_FIELDS;
  		break;
@@@ -5012,6 -5014,28 +5022,31 @@@ long kvm_arch_vcpu_ioctl(struct file *f
  	case KVM_GET_SUPPORTED_HV_CPUID:
  		r = kvm_ioctl_get_supported_hv_cpuid(vcpu, argp);
  		break;
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_KVM_XEN
+ 	case KVM_XEN_VCPU_GET_ATTR: {
+ 		struct kvm_xen_vcpu_attr xva;
+ 
+ 		r = -EFAULT;
+ 		if (copy_from_user(&xva, argp, sizeof(xva)))
+ 			goto out;
+ 		r = kvm_xen_vcpu_get_attr(vcpu, &xva);
+ 		if (!r && copy_to_user(argp, &xva, sizeof(xva)))
+ 			r = -EFAULT;
+ 		break;
+ 	}
+ 	case KVM_XEN_VCPU_SET_ATTR: {
+ 		struct kvm_xen_vcpu_attr xva;
+ 
+ 		r = -EFAULT;
+ 		if (copy_from_user(&xva, argp, sizeof(xva)))
+ 			goto out;
+ 		r = kvm_xen_vcpu_set_attr(vcpu, &xva);
+ 		break;
+ 	}
+ #endif
++>>>>>>> b59b153d1026 (KVM: x86: allow compiling out the Xen hypercall interface)
  	default:
  		r = -EINVAL;
  	}
@@@ -5617,13 -5663,30 +5653,14 @@@ set_pit2_out
  		r = -EFAULT;
  		if (copy_from_user(&xhc, argp, sizeof(xhc)))
  			goto out;
 -		r = kvm_xen_hvm_config(kvm, &xhc);
 -		break;
 -	}
 -	case KVM_XEN_HVM_GET_ATTR: {
 -		struct kvm_xen_hvm_attr xha;
 -
 -		r = -EFAULT;
 -		if (copy_from_user(&xha, argp, sizeof(xha)))
 -			goto out;
 -		r = kvm_xen_hvm_get_attr(kvm, &xha);
 -		if (!r && copy_to_user(argp, &xha, sizeof(xha)))
 -			r = -EFAULT;
 -		break;
 -	}
 -	case KVM_XEN_HVM_SET_ATTR: {
 -		struct kvm_xen_hvm_attr xha;
 -
 -		r = -EFAULT;
 -		if (copy_from_user(&xha, argp, sizeof(xha)))
 +		r = -EINVAL;
 +		if (xhc.flags)
  			goto out;
 -		r = kvm_xen_hvm_set_attr(kvm, &xha);
 +		memcpy(&kvm->arch.xen_hvm_config, &xhc, sizeof(xhc));
 +		r = 0;
  		break;
  	}
+ #endif
  	case KVM_SET_CLOCK: {
  		struct kvm_clock_data user_ns;
  		u64 now_ns;
@@@ -7982,6 -8045,22 +8019,25 @@@ void kvm_arch_exit(void
  	kvm_mmu_module_exit();
  	free_percpu(user_return_msrs);
  	kmem_cache_destroy(x86_fpu_cache);
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_KVM_XEN
+ 	static_key_deferred_flush(&kvm_xen_enabled);
+ 	WARN_ON(static_branch_unlikely(&kvm_xen_enabled.key));
+ #endif
+ }
+ 
+ static int __kvm_vcpu_halt(struct kvm_vcpu *vcpu, int state, int reason)
+ {
+ 	++vcpu->stat.halt_exits;
+ 	if (lapic_in_kernel(vcpu)) {
+ 		vcpu->arch.mp_state = state;
+ 		return 1;
+ 	} else {
+ 		vcpu->run->exit_reason = reason;
+ 		return 0;
+ 	}
++>>>>>>> b59b153d1026 (KVM: x86: allow compiling out the Xen hypercall interface)
  }
  
  int kvm_vcpu_halt(struct kvm_vcpu *vcpu)
* Unmerged path arch/x86/kvm/xen.h
diff --git a/arch/x86/kvm/Kconfig b/arch/x86/kvm/Kconfig
index 548366f40372..31831f2a2128 100644
--- a/arch/x86/kvm/Kconfig
+++ b/arch/x86/kvm/Kconfig
@@ -101,6 +101,15 @@ config KVM_AMD_SEV
 	---help---
 	Provides support for launching Encrypted VMs on AMD processors.
 
+config KVM_XEN
+	bool "Support for Xen hypercall interface"
+	depends on KVM
+	help
+	  Provides KVM support for the hosting Xen HVM guests and
+	  passing Xen hypercalls to userspace.
+
+	  If in doubt, say "N".
+
 config KVM_MMU_AUDIT
 	bool "Audit KVM MMU"
 	depends on KVM && TRACEPOINTS
diff --git a/arch/x86/kvm/Makefile b/arch/x86/kvm/Makefile
index 1d1e31917a88..24df6e4bbf48 100644
--- a/arch/x86/kvm/Makefile
+++ b/arch/x86/kvm/Makefile
@@ -18,6 +18,7 @@ kvm-y			+= x86.o emulate.o i8259.o irq.o lapic.o \
 			   hyperv.o debugfs.o mmu/mmu.o mmu/page_track.o \
 			   mmu/spte.o
 kvm-$(CONFIG_X86_64) += mmu/tdp_iter.o mmu/tdp_mmu.o
+kvm-$(CONFIG_KVM_XEN)	+= xen.o
 
 kvm-intel-y		+= vmx/vmx.o vmx/vmenter.o vmx/pmu_intel.o vmx/vmcs12.o \
 			   vmx/evmcs.o vmx/nested.o vmx/posted_intr.o
* Unmerged path arch/x86/kvm/x86.c
* Unmerged path arch/x86/kvm/xen.h
