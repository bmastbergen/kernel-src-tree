KVM: selftests: Always run vCPU thread with blocked SIG_IPI

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit bf1e15a82e3b74ee86bb119d6038b41e1ed2b319
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/bf1e15a8.failed

The main thread could start to send SIG_IPI at any time, even before signal
blocked on vcpu thread.  Therefore, start the vcpu thread with the signal
blocked.

Without this patch, on very busy cores the dirty_log_test could fail directly
on receiving a SIGUSR1 without a handler (when vcpu runs far slower than main).

	Reported-by: Peter Xu <peterx@redhat.com>
	Cc: stable@vger.kernel.org
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit bf1e15a82e3b74ee86bb119d6038b41e1ed2b319)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/kvm/dirty_log_test.c
diff --cc tools/testing/selftests/kvm/dirty_log_test.c
index 89fbe7b9d9f5,81edbd23d371..000000000000
--- a/tools/testing/selftests/kvm/dirty_log_test.c
+++ b/tools/testing/selftests/kvm/dirty_log_test.c
@@@ -867,12 -852,12 +866,21 @@@ static void help(char *name
  
  int main(int argc, char *argv[])
  {
++<<<<<<< HEAD
 +	unsigned long iterations = TEST_HOST_LOOP_N;
 +	unsigned long interval = TEST_HOST_LOOP_INTERVAL;
 +	bool mode_selected = false;
 +	uint64_t phys_offset = 0;
 +	unsigned int mode;
 +	int opt, i, j;
++=======
+ 	struct test_params p = {
+ 		.iterations = TEST_HOST_LOOP_N,
+ 		.interval = TEST_HOST_LOOP_INTERVAL,
+ 	};
+ 	int opt, i;
+ 	sigset_t sigset;
++>>>>>>> bf1e15a82e3b (KVM: selftests: Always run vCPU thread with blocked SIG_IPI)
  
  	sem_init(&sem_vcpu_stop, 0, 0);
  	sem_init(&sem_vcpu_cont, 0, 0);
@@@ -959,24 -916,21 +967,38 @@@
  
  	srandom(time(0));
  
++<<<<<<< HEAD
 +	for (i = 0; i < NUM_VM_MODES; ++i) {
 +		if (!guest_modes[i].enabled)
 +			continue;
 +		TEST_ASSERT(guest_modes[i].supported,
 +			    "Guest mode ID %d (%s) not supported.",
 +			    i, vm_guest_mode_string(i));
 +		if (host_log_mode_option == LOG_MODE_ALL) {
 +			/* Run each log mode */
 +			for (j = 0; j < LOG_MODE_NUM; j++) {
 +				pr_info("Testing Log Mode '%s'\n",
 +					log_modes[j].name);
 +				host_log_mode = j;
 +				run_test(i, iterations, interval, phys_offset);
 +			}
 +		} else {
 +			host_log_mode = host_log_mode_option;
 +			run_test(i, iterations, interval, phys_offset);
++=======
+ 	/* Ensure that vCPU threads start with SIG_IPI blocked.  */
+ 	sigemptyset(&sigset);
+ 	sigaddset(&sigset, SIG_IPI);
+ 	pthread_sigmask(SIG_BLOCK, &sigset, NULL);
+ 
+ 	if (host_log_mode_option == LOG_MODE_ALL) {
+ 		/* Run each log mode */
+ 		for (i = 0; i < LOG_MODE_NUM; i++) {
+ 			pr_info("Testing Log Mode '%s'\n", log_modes[i].name);
+ 			host_log_mode = i;
+ 			for_each_guest_mode(run_test, &p);
++>>>>>>> bf1e15a82e3b (KVM: selftests: Always run vCPU thread with blocked SIG_IPI)
  		}
 -	} else {
 -		host_log_mode = host_log_mode_option;
 -		for_each_guest_mode(run_test, &p);
  	}
  
  	return 0;
* Unmerged path tools/testing/selftests/kvm/dirty_log_test.c
