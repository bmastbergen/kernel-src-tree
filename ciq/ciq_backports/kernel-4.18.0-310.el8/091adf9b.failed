net: bridge: move default pvid init/deinit to NETDEV_REGISTER/UNREGISTER

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
commit 091adf9ba6cdb432cbcc217b47e4ffb8aa0d8865
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/091adf9b.failed

Most of the bridge device's vlan init bugs come from the fact that its
default pvid is created at the wrong time, way too early in ndo_init()
before the device is even assigned an ifindex. It introduces a bug when the
bridge's dev_addr is added as fdb during the initial default pvid creation
the notification has ifindex/NDA_MASTER both equal to 0 (see example below)
which really makes no sense for user-space[0] and is wrong.
Usually user-space software would ignore such entries, but they are
actually valid and will eventually have all necessary attributes.
It makes much more sense to send a notification *after* the device has
registered and has a proper ifindex allocated rather than before when
there's a chance that the registration might still fail or to receive
it with ifindex/NDA_MASTER == 0. Note that we can remove the fdb flush
from br_vlan_flush() since that case can no longer happen. At
NETDEV_REGISTER br->default_pvid is always == 1 as it's initialized by
br_vlan_init() before that and at NETDEV_UNREGISTER it can be anything
depending why it was called (if called due to NETDEV_REGISTER error
it'll still be == 1, otherwise it could be any value changed during the
device life time).

For the demonstration below a small change to iproute2 for printing all fdb
notifications is added, because it contained a workaround not to show
entries with ifindex == 0.
Command executed while monitoring: $ ip l add br0 type bridge
Before (both ifindex and master == 0):
$ bridge monitor fdb
36:7e:8a:b3:56:ba dev * vlan 1 master * permanent

After (proper br0 ifindex):
$ bridge monitor fdb
e6:2a:ae:7a:b7:48 dev br0 vlan 1 master br0 permanent

v4: move only the default pvid init/deinit to NETDEV_REGISTER/UNREGISTER
v3: send the correct v2 patch with all changes (stub should return 0)
v2: on error in br_vlan_init set br->vlgrp to NULL and return 0 in
    the br_vlan_bridge_event stub when bridge vlans are disabled

[0] https://bugzilla.kernel.org/show_bug.cgi?id=204389

	Reported-by: michael-dev <michael-dev@fami-braun.de>
Fixes: 5be5a2df40f0 ("bridge: Add filtering support for default_pvid")
	Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Acked-by: Roopa Prabhu <roopa@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 091adf9ba6cdb432cbcc217b47e4ffb8aa0d8865)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br.c
#	net/bridge/br_private.h
#	net/bridge/br_vlan.c
diff --cc net/bridge/br.c
index 0c516baf5f0f,8a8f9e5f264f..000000000000
--- a/net/bridge/br.c
+++ b/net/bridge/br.c
@@@ -40,12 -36,16 +40,25 @@@ static int br_device_event(struct notif
  	bool changed_addr;
  	int err;
  
++<<<<<<< HEAD
 +	/* register of bridge completed, add sysfs entries */
 +	if ((dev->priv_flags & IFF_EBRIDGE) && event == NETDEV_REGISTER) {
 +		err = br_sysfs_addbr(dev);
 +		if (err)
 +			return notifier_from_errno(err);
 +		return NOTIFY_DONE;
++=======
+ 	if (dev->priv_flags & IFF_EBRIDGE) {
+ 		err = br_vlan_bridge_event(dev, event, ptr);
+ 		if (err)
+ 			return notifier_from_errno(err);
+ 
+ 		if (event == NETDEV_REGISTER) {
+ 			/* register of bridge completed, add sysfs entries */
+ 			br_sysfs_addbr(dev);
+ 			return NOTIFY_DONE;
+ 		}
++>>>>>>> 091adf9ba6cd (net: bridge: move default pvid init/deinit to NETDEV_REGISTER/UNREGISTER)
  	}
  
  	/* not a port of a bridge */
diff --cc net/bridge/br_private.h
index d3e2546d5964,646504db0220..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -879,6 -893,9 +879,12 @@@ int nbp_vlan_init(struct net_bridge_por
  int nbp_get_num_vlan_infos(struct net_bridge_port *p, u32 filter_mask);
  void br_vlan_get_stats(const struct net_bridge_vlan *v,
  		       struct br_vlan_stats *stats);
++<<<<<<< HEAD
++=======
+ void br_vlan_port_event(struct net_bridge_port *p, unsigned long event);
+ int br_vlan_bridge_event(struct net_device *dev, unsigned long event,
+ 			 void *ptr);
++>>>>>>> 091adf9ba6cd (net: bridge: move default pvid init/deinit to NETDEV_REGISTER/UNREGISTER)
  
  static inline struct net_bridge_vlan_group *br_vlan_group(
  					const struct net_bridge *br)
@@@ -1062,6 -1079,17 +1068,20 @@@ static inline void br_vlan_get_stats(co
  				     struct br_vlan_stats *stats)
  {
  }
++<<<<<<< HEAD
++=======
+ 
+ static inline void br_vlan_port_event(struct net_bridge_port *p,
+ 				      unsigned long event)
+ {
+ }
+ 
+ static inline int br_vlan_bridge_event(struct net_device *dev,
+ 				       unsigned long event, void *ptr)
+ {
+ 	return 0;
+ }
++>>>>>>> 091adf9ba6cd (net: bridge: move default pvid init/deinit to NETDEV_REGISTER/UNREGISTER)
  #endif
  
  struct nf_br_ops {
diff --cc net/bridge/br_vlan.c
index cd9b045102e3,f5b2aeebbfe9..000000000000
--- a/net/bridge/br_vlan.c
+++ b/net/bridge/br_vlan.c
@@@ -1271,3 -1284,222 +1258,225 @@@ int br_vlan_get_info(const struct net_d
  	return 0;
  }
  EXPORT_SYMBOL_GPL(br_vlan_get_info);
++<<<<<<< HEAD
++=======
+ 
+ static int br_vlan_is_bind_vlan_dev(const struct net_device *dev)
+ {
+ 	return is_vlan_dev(dev) &&
+ 		!!(vlan_dev_priv(dev)->flags & VLAN_FLAG_BRIDGE_BINDING);
+ }
+ 
+ static int br_vlan_is_bind_vlan_dev_fn(struct net_device *dev,
+ 				       __always_unused void *data)
+ {
+ 	return br_vlan_is_bind_vlan_dev(dev);
+ }
+ 
+ static bool br_vlan_has_upper_bind_vlan_dev(struct net_device *dev)
+ {
+ 	int found;
+ 
+ 	rcu_read_lock();
+ 	found = netdev_walk_all_upper_dev_rcu(dev, br_vlan_is_bind_vlan_dev_fn,
+ 					      NULL);
+ 	rcu_read_unlock();
+ 
+ 	return !!found;
+ }
+ 
+ struct br_vlan_bind_walk_data {
+ 	u16 vid;
+ 	struct net_device *result;
+ };
+ 
+ static int br_vlan_match_bind_vlan_dev_fn(struct net_device *dev,
+ 					  void *data_in)
+ {
+ 	struct br_vlan_bind_walk_data *data = data_in;
+ 	int found = 0;
+ 
+ 	if (br_vlan_is_bind_vlan_dev(dev) &&
+ 	    vlan_dev_priv(dev)->vlan_id == data->vid) {
+ 		data->result = dev;
+ 		found = 1;
+ 	}
+ 
+ 	return found;
+ }
+ 
+ static struct net_device *
+ br_vlan_get_upper_bind_vlan_dev(struct net_device *dev, u16 vid)
+ {
+ 	struct br_vlan_bind_walk_data data = {
+ 		.vid = vid,
+ 	};
+ 
+ 	rcu_read_lock();
+ 	netdev_walk_all_upper_dev_rcu(dev, br_vlan_match_bind_vlan_dev_fn,
+ 				      &data);
+ 	rcu_read_unlock();
+ 
+ 	return data.result;
+ }
+ 
+ static bool br_vlan_is_dev_up(const struct net_device *dev)
+ {
+ 	return  !!(dev->flags & IFF_UP) && netif_oper_up(dev);
+ }
+ 
+ static void br_vlan_set_vlan_dev_state(const struct net_bridge *br,
+ 				       struct net_device *vlan_dev)
+ {
+ 	u16 vid = vlan_dev_priv(vlan_dev)->vlan_id;
+ 	struct net_bridge_vlan_group *vg;
+ 	struct net_bridge_port *p;
+ 	bool has_carrier = false;
+ 
+ 	if (!netif_carrier_ok(br->dev)) {
+ 		netif_carrier_off(vlan_dev);
+ 		return;
+ 	}
+ 
+ 	list_for_each_entry(p, &br->port_list, list) {
+ 		vg = nbp_vlan_group(p);
+ 		if (br_vlan_find(vg, vid) && br_vlan_is_dev_up(p->dev)) {
+ 			has_carrier = true;
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (has_carrier)
+ 		netif_carrier_on(vlan_dev);
+ 	else
+ 		netif_carrier_off(vlan_dev);
+ }
+ 
+ static void br_vlan_set_all_vlan_dev_state(struct net_bridge_port *p)
+ {
+ 	struct net_bridge_vlan_group *vg = nbp_vlan_group(p);
+ 	struct net_bridge_vlan *vlan;
+ 	struct net_device *vlan_dev;
+ 
+ 	list_for_each_entry(vlan, &vg->vlan_list, vlist) {
+ 		vlan_dev = br_vlan_get_upper_bind_vlan_dev(p->br->dev,
+ 							   vlan->vid);
+ 		if (vlan_dev) {
+ 			if (br_vlan_is_dev_up(p->dev)) {
+ 				if (netif_carrier_ok(p->br->dev))
+ 					netif_carrier_on(vlan_dev);
+ 			} else {
+ 				br_vlan_set_vlan_dev_state(p->br, vlan_dev);
+ 			}
+ 		}
+ 	}
+ }
+ 
+ static void br_vlan_upper_change(struct net_device *dev,
+ 				 struct net_device *upper_dev,
+ 				 bool linking)
+ {
+ 	struct net_bridge *br = netdev_priv(dev);
+ 
+ 	if (!br_vlan_is_bind_vlan_dev(upper_dev))
+ 		return;
+ 
+ 	if (linking) {
+ 		br_vlan_set_vlan_dev_state(br, upper_dev);
+ 		br_opt_toggle(br, BROPT_VLAN_BRIDGE_BINDING, true);
+ 	} else {
+ 		br_opt_toggle(br, BROPT_VLAN_BRIDGE_BINDING,
+ 			      br_vlan_has_upper_bind_vlan_dev(dev));
+ 	}
+ }
+ 
+ struct br_vlan_link_state_walk_data {
+ 	struct net_bridge *br;
+ };
+ 
+ static int br_vlan_link_state_change_fn(struct net_device *vlan_dev,
+ 					void *data_in)
+ {
+ 	struct br_vlan_link_state_walk_data *data = data_in;
+ 
+ 	if (br_vlan_is_bind_vlan_dev(vlan_dev))
+ 		br_vlan_set_vlan_dev_state(data->br, vlan_dev);
+ 
+ 	return 0;
+ }
+ 
+ static void br_vlan_link_state_change(struct net_device *dev,
+ 				      struct net_bridge *br)
+ {
+ 	struct br_vlan_link_state_walk_data data = {
+ 		.br = br
+ 	};
+ 
+ 	rcu_read_lock();
+ 	netdev_walk_all_upper_dev_rcu(dev, br_vlan_link_state_change_fn,
+ 				      &data);
+ 	rcu_read_unlock();
+ }
+ 
+ /* Must be protected by RTNL. */
+ static void nbp_vlan_set_vlan_dev_state(struct net_bridge_port *p, u16 vid)
+ {
+ 	struct net_device *vlan_dev;
+ 
+ 	if (!br_opt_get(p->br, BROPT_VLAN_BRIDGE_BINDING))
+ 		return;
+ 
+ 	vlan_dev = br_vlan_get_upper_bind_vlan_dev(p->br->dev, vid);
+ 	if (vlan_dev)
+ 		br_vlan_set_vlan_dev_state(p->br, vlan_dev);
+ }
+ 
+ /* Must be protected by RTNL. */
+ int br_vlan_bridge_event(struct net_device *dev, unsigned long event, void *ptr)
+ {
+ 	struct netdev_notifier_changeupper_info *info;
+ 	struct net_bridge *br = netdev_priv(dev);
+ 	bool changed;
+ 	int ret = 0;
+ 
+ 	switch (event) {
+ 	case NETDEV_REGISTER:
+ 		ret = br_vlan_add(br, br->default_pvid,
+ 				  BRIDGE_VLAN_INFO_PVID |
+ 				  BRIDGE_VLAN_INFO_UNTAGGED |
+ 				  BRIDGE_VLAN_INFO_BRENTRY, &changed, NULL);
+ 		break;
+ 	case NETDEV_UNREGISTER:
+ 		br_vlan_delete(br, br->default_pvid);
+ 		break;
+ 	case NETDEV_CHANGEUPPER:
+ 		info = ptr;
+ 		br_vlan_upper_change(dev, info->upper_dev, info->linking);
+ 		break;
+ 
+ 	case NETDEV_CHANGE:
+ 	case NETDEV_UP:
+ 		if (!br_opt_get(br, BROPT_VLAN_BRIDGE_BINDING))
+ 			break;
+ 		br_vlan_link_state_change(dev, br);
+ 		break;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ /* Must be protected by RTNL. */
+ void br_vlan_port_event(struct net_bridge_port *p, unsigned long event)
+ {
+ 	if (!br_opt_get(p->br, BROPT_VLAN_BRIDGE_BINDING))
+ 		return;
+ 
+ 	switch (event) {
+ 	case NETDEV_CHANGE:
+ 	case NETDEV_DOWN:
+ 	case NETDEV_UP:
+ 		br_vlan_set_all_vlan_dev_state(p);
+ 		break;
+ 	}
+ }
++>>>>>>> 091adf9ba6cd (net: bridge: move default pvid init/deinit to NETDEV_REGISTER/UNREGISTER)
* Unmerged path net/bridge/br.c
* Unmerged path net/bridge/br_private.h
* Unmerged path net/bridge/br_vlan.c
