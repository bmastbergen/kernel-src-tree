drivers core: Remove strcat uses around sysfs_emit and neaten

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Joe Perches <joe@perches.com>
commit 973c39115cb308b6b1fe64b4f342996f3eef06d0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/973c3911.failed

strcat is no longer necessary for sysfs_emit and sysfs_emit_at uses.

Convert the strcat uses to sysfs_emit calls and neaten other block
uses of direct returns to use an intermediate const char *.

	Signed-off-by: Joe Perches <joe@perches.com>
Link: https://lore.kernel.org/r/5d606519698ce4c8f1203a2b35797d8254c6050a.1600285923.git.joe@perches.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 973c39115cb308b6b1fe64b4f342996f3eef06d0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/cacheinfo.c
#	drivers/base/core.c
#	drivers/base/memory.c
#	drivers/base/power/sysfs.c
diff --cc drivers/base/cacheinfo.c
index dbd7c00c9b7a,96f8af414a48..000000000000
--- a/drivers/base/cacheinfo.c
+++ b/drivers/base/cacheinfo.c
@@@ -413,11 -408,14 +414,22 @@@ static ssize_t type_show(struct device 
  
  	switch (this_leaf->type) {
  	case CACHE_TYPE_DATA:
++<<<<<<< HEAD
 +		return sprintf(buf, "Data\n");
 +	case CACHE_TYPE_INST:
 +		return sprintf(buf, "Instruction\n");
 +	case CACHE_TYPE_UNIFIED:
 +		return sprintf(buf, "Unified\n");
++=======
+ 		output = "Data";
+ 		break;
+ 	case CACHE_TYPE_INST:
+ 		output = "Instruction";
+ 		break;
+ 	case CACHE_TYPE_UNIFIED:
+ 		output = "Unified";
+ 		break;
++>>>>>>> 973c39115cb3 (drivers core: Remove strcat uses around sysfs_emit and neaten)
  	default:
  		return -EINVAL;
  	}
@@@ -428,15 -428,18 +442,27 @@@ static ssize_t allocation_policy_show(s
  {
  	struct cacheinfo *this_leaf = dev_get_drvdata(dev);
  	unsigned int ci_attr = this_leaf->attributes;
- 	int n = 0;
+ 	const char *output;
  
  	if ((ci_attr & CACHE_READ_ALLOCATE) && (ci_attr & CACHE_WRITE_ALLOCATE))
++<<<<<<< HEAD
 +		n = sprintf(buf, "ReadWriteAllocate\n");
 +	else if (ci_attr & CACHE_READ_ALLOCATE)
 +		n = sprintf(buf, "ReadAllocate\n");
 +	else if (ci_attr & CACHE_WRITE_ALLOCATE)
 +		n = sprintf(buf, "WriteAllocate\n");
 +	return n;
++=======
+ 		output = "ReadWriteAllocate";
+ 	else if (ci_attr & CACHE_READ_ALLOCATE)
+ 		output = "ReadAllocate";
+ 	else if (ci_attr & CACHE_WRITE_ALLOCATE)
+ 		output = "WriteAllocate";
+ 	else
+ 		return 0;
+ 
+ 	return sysfs_emit(buf, "%s\n", output);
++>>>>>>> 973c39115cb3 (drivers core: Remove strcat uses around sysfs_emit and neaten)
  }
  
  static ssize_t write_policy_show(struct device *dev,
diff --cc drivers/base/core.c
index 6c57235d97e1,cfeb06f054d0..000000000000
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@@ -255,16 -268,16 +255,20 @@@ static ssize_t auto_remove_on_show(stru
  				   struct device_attribute *attr, char *buf)
  {
  	struct device_link *link = to_devlink(dev);
- 	char *str;
+ 	const char *output;
  
  	if (link->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
- 		str = "supplier unbind";
+ 		output = "supplier unbind";
  	else if (link->flags & DL_FLAG_AUTOREMOVE_CONSUMER)
- 		str = "consumer unbind";
+ 		output = "consumer unbind";
  	else
- 		str = "never";
+ 		output = "never";
  
++<<<<<<< HEAD
 +	return sprintf(buf, "%s\n", str);
++=======
+ 	return sysfs_emit(buf, "%s\n", output);
++>>>>>>> 973c39115cb3 (drivers core: Remove strcat uses around sysfs_emit and neaten)
  }
  static DEVICE_ATTR_RO(auto_remove_on);
  
diff --cc drivers/base/memory.c
index b9d6d0595d49,1e0526b6b9db..000000000000
--- a/drivers/base/memory.c
+++ b/drivers/base/memory.c
@@@ -162,22 -147,20 +162,34 @@@ static ssize_t state_show(struct devic
  	 */
  	switch (mem->state) {
  	case MEM_ONLINE:
++<<<<<<< HEAD
 +		len = sprintf(buf, "online\n");
 +		break;
 +	case MEM_OFFLINE:
 +		len = sprintf(buf, "offline\n");
 +		break;
 +	case MEM_GOING_OFFLINE:
 +		len = sprintf(buf, "going-offline\n");
 +		break;
 +	default:
 +		len = sprintf(buf, "ERROR-UNKNOWN-%ld\n",
 +				mem->state);
- 		WARN_ON(1);
++=======
+ 		output = "online";
+ 		break;
+ 	case MEM_OFFLINE:
+ 		output = "offline";
  		break;
+ 	case MEM_GOING_OFFLINE:
+ 		output = "going-offline";
+ 		break;
+ 	default:
++>>>>>>> 973c39115cb3 (drivers core: Remove strcat uses around sysfs_emit and neaten)
+ 		WARN_ON(1);
+ 		return sysfs_emit(buf, "ERROR-UNKNOWN-%ld\n", mem->state);
  	}
  
- 	return len;
+ 	return sysfs_emit(buf, "%s\n", output);
  }
  
  int memory_notify(unsigned long val, void *v)
@@@ -402,8 -339,8 +414,13 @@@ static ssize_t valid_zones_show(struct 
  		default_zone = test_pages_in_a_zone(start_pfn,
  						    start_pfn + nr_pages);
  		if (!default_zone)
++<<<<<<< HEAD
 +			return sprintf(buf, "none\n");
 +		strcat(buf, default_zone->name);
++=======
+ 			return sysfs_emit(buf, "%s\n", "none");
+ 		len += sysfs_emit_at(buf, len, "%s", default_zone->name);
++>>>>>>> 973c39115cb3 (drivers core: Remove strcat uses around sysfs_emit and neaten)
  		goto out;
  	}
  
diff --cc drivers/base/power/sysfs.c
index 1c98f76a805a,61e16786f6c5..000000000000
--- a/drivers/base/power/sysfs.c
+++ b/drivers/base/power/sysfs.c
@@@ -256,11 -255,11 +256,17 @@@ static ssize_t pm_qos_latency_tolerance
  	s32 value = dev_pm_qos_get_user_latency_tolerance(dev);
  
  	if (value < 0)
++<<<<<<< HEAD
 +		return sprintf(buf, "auto\n");
 +	if (value == PM_QOS_LATENCY_ANY)
 +		return sprintf(buf, "any\n");
++=======
+ 		return sysfs_emit(buf, "%s\n", "auto");
+ 	if (value == PM_QOS_LATENCY_ANY)
+ 		return sysfs_emit(buf, "%s\n", "any");
++>>>>>>> 973c39115cb3 (drivers core: Remove strcat uses around sysfs_emit and neaten)
  
 -	return sysfs_emit(buf, "%d\n", value);
 +	return sprintf(buf, "%d\n", value);
  }
  
  static ssize_t pm_qos_latency_tolerance_us_store(struct device *dev,
@@@ -525,13 -538,18 +531,28 @@@ static DEVICE_ATTR_RO(runtime_active_ki
  static ssize_t runtime_enabled_show(struct device *dev,
  				    struct device_attribute *attr, char *buf)
  {
++<<<<<<< HEAD
 +	if (dev->power.disable_depth && (dev->power.runtime_auto == false))
 +		return sprintf(buf, "disabled & forbidden\n");
 +	if (dev->power.disable_depth)
 +		return sprintf(buf, "disabled\n");
 +	if (dev->power.runtime_auto == false)
 +		return sprintf(buf, "forbidden\n");
 +	return sprintf(buf, "enabled\n");
++=======
+ 	const char *output;
+ 
+ 	if (dev->power.disable_depth && !dev->power.runtime_auto)
+ 		output = "disabled & forbidden";
+ 	else if (dev->power.disable_depth)
+ 		output = "disabled";
+ 	else if (!dev->power.runtime_auto)
+ 		output = "forbidden";
+ 	else
+ 		output = "enabled";
+ 
+ 	return sysfs_emit(buf, "%s\n", output);
++>>>>>>> 973c39115cb3 (drivers core: Remove strcat uses around sysfs_emit and neaten)
  }
  static DEVICE_ATTR_RO(runtime_enabled);
  
* Unmerged path drivers/base/cacheinfo.c
* Unmerged path drivers/base/core.c
* Unmerged path drivers/base/memory.c
* Unmerged path drivers/base/power/sysfs.c
