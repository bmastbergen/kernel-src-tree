mm/huge_memory: fix split assumption of page size

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Kirill A. Shutemov <kirill@shutemov.name>
commit 8cce54756806e5777069c46011c5f54f9feac717
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/8cce5475.failed

File THPs may now be of arbitrary size, and we can't rely on that size
after doing the split so remember the number of pages before we start the
split.

	Signed-off-by: Kirill A. Shutemov <kirill@shutemov.name>
	Signed-off-by: Matthew Wilcox (Oracle) <willy@infradead.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Reviewed-by: SeongJae Park <sjpark@amazon.de>
	Cc: Huang Ying <ying.huang@intel.com>
Link: https://lkml.kernel.org/r/20200908195539.25896-6-willy@infradead.org
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 8cce54756806e5777069c46011c5f54f9feac717)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/huge_memory.c
diff --cc mm/huge_memory.c
index f04171b13ff2,5934ef722e28..000000000000
--- a/mm/huge_memory.c
+++ b/mm/huge_memory.c
@@@ -2399,15 -2474,9 +2400,19 @@@ static void __split_huge_page(struct pa
  
  	spin_unlock_irqrestore(&pgdat->lru_lock, flags);
  
- 	remap_page(head);
+ 	remap_page(head, nr);
  
++<<<<<<< HEAD
 +	if (PageSwapCache(head)) {
 +		swp_entry_t entry = { .val = page_private(head) };
 +
 +		split_swap_cluster(entry);
 +	}
 +
 +	for (i = 0; i < HPAGE_PMD_NR; i++) {
++=======
+ 	for (i = 0; i < nr; i++) {
++>>>>>>> 8cce54756806 (mm/huge_memory: fix split assumption of page size)
  		struct page *subpage = head + i;
  		if (subpage == page)
  			continue;
* Unmerged path mm/huge_memory.c
