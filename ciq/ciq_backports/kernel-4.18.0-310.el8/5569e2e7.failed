KVM: SVM: Add support for KVM_SEV_SEND_CANCEL command

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Steve Rutherford <srutherford@google.com>
commit 5569e2e7a650dfffd4df7635662b2f92162d6501
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/5569e2e7.failed

After completion of SEND_START, but before SEND_FINISH, the source VMM can
issue the SEND_CANCEL command to stop a migration. This is necessary so
that a cancelled migration can restart with a new target later.

	Reviewed-by: Nathan Tempelman <natet@google.com>
	Reviewed-by: Brijesh Singh <brijesh.singh@amd.com>
	Signed-off-by: Steve Rutherford <srutherford@google.com>
Message-Id: <20210412194408.2458827-1-srutherford@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 5569e2e7a650dfffd4df7635662b2f92162d6501)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/virt/kvm/amd-memory-encryption.rst
#	arch/x86/kvm/svm/sev.c
diff --cc Documentation/virt/kvm/amd-memory-encryption.rst
index 625ce89c7706,c36a12975763..000000000000
--- a/Documentation/virt/kvm/amd-memory-encryption.rst
+++ b/Documentation/virt/kvm/amd-memory-encryption.rst
@@@ -314,6 -320,51 +314,54 @@@ Returns: 0 on success, -negative on err
                  __u32 session_len;
          };
  
++<<<<<<< HEAD
++=======
+ 12. KVM_SEV_SEND_UPDATE_DATA
+ ----------------------------
+ 
+ The KVM_SEV_SEND_UPDATE_DATA command can be used by the hypervisor to encrypt the
+ outgoing guest memory region with the encryption context creating using
+ KVM_SEV_SEND_START.
+ 
+ If hdr_len or trans_len are zero on entry, the length of the packet header and
+ transport region are written to hdr_len and trans_len respectively, and all
+ other fields are not used.
+ 
+ Parameters (in): struct kvm_sev_send_update_data
+ 
+ Returns: 0 on success, -negative on error
+ 
+ ::
+ 
+         struct kvm_sev_launch_send_update_data {
+                 __u64 hdr_uaddr;        /* userspace address containing the packet header */
+                 __u32 hdr_len;
+ 
+                 __u64 guest_uaddr;      /* the source memory region to be encrypted */
+                 __u32 guest_len;
+ 
+                 __u64 trans_uaddr;      /* the destination memory region  */
+                 __u32 trans_len;
+         };
+ 
+ 13. KVM_SEV_SEND_FINISH
+ ------------------------
+ 
+ After completion of the migration flow, the KVM_SEV_SEND_FINISH command can be
+ issued by the hypervisor to delete the encryption context.
+ 
+ Returns: 0 on success, -negative on error
+ 
+ 14. KVM_SEV_SEND_CANCEL
+ ------------------------
+ 
+ After completion of SEND_START, but before SEND_FINISH, the source VMM can issue the
+ SEND_CANCEL command to stop a migration. This is necessary so that a cancelled
+ migration can restart with a new target later.
+ 
+ Returns: 0 on success, -negative on error
+ 
++>>>>>>> 5569e2e7a650 (KVM: SVM: Add support for KVM_SEV_SEND_CANCEL command)
  References
  ==========
  
diff --cc arch/x86/kvm/svm/sev.c
index fbe9a30eb1a6,552f47787143..000000000000
--- a/arch/x86/kvm/svm/sev.c
+++ b/arch/x86/kvm/svm/sev.c
@@@ -1221,6 -1237,166 +1221,169 @@@ e_free_session
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ /* Userspace wants to query either header or trans length. */
+ static int
+ __sev_send_update_data_query_lengths(struct kvm *kvm, struct kvm_sev_cmd *argp,
+ 				     struct kvm_sev_send_update_data *params)
+ {
+ 	struct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;
+ 	struct sev_data_send_update_data *data;
+ 	int ret;
+ 
+ 	data = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);
+ 	if (!data)
+ 		return -ENOMEM;
+ 
+ 	data->handle = sev->handle;
+ 	ret = sev_issue_cmd(kvm, SEV_CMD_SEND_UPDATE_DATA, data, &argp->error);
+ 	if (ret < 0)
+ 		goto out;
+ 
+ 	params->hdr_len = data->hdr_len;
+ 	params->trans_len = data->trans_len;
+ 
+ 	if (copy_to_user((void __user *)(uintptr_t)argp->data, params,
+ 			 sizeof(struct kvm_sev_send_update_data)))
+ 		ret = -EFAULT;
+ 
+ out:
+ 	kfree(data);
+ 	return ret;
+ }
+ 
+ static int sev_send_update_data(struct kvm *kvm, struct kvm_sev_cmd *argp)
+ {
+ 	struct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;
+ 	struct sev_data_send_update_data *data;
+ 	struct kvm_sev_send_update_data params;
+ 	void *hdr, *trans_data;
+ 	struct page **guest_page;
+ 	unsigned long n;
+ 	int ret, offset;
+ 
+ 	if (!sev_guest(kvm))
+ 		return -ENOTTY;
+ 
+ 	if (copy_from_user(&params, (void __user *)(uintptr_t)argp->data,
+ 			sizeof(struct kvm_sev_send_update_data)))
+ 		return -EFAULT;
+ 
+ 	/* userspace wants to query either header or trans length */
+ 	if (!params.trans_len || !params.hdr_len)
+ 		return __sev_send_update_data_query_lengths(kvm, argp, &params);
+ 
+ 	if (!params.trans_uaddr || !params.guest_uaddr ||
+ 	    !params.guest_len || !params.hdr_uaddr)
+ 		return -EINVAL;
+ 
+ 	/* Check if we are crossing the page boundary */
+ 	offset = params.guest_uaddr & (PAGE_SIZE - 1);
+ 	if ((params.guest_len + offset > PAGE_SIZE))
+ 		return -EINVAL;
+ 
+ 	/* Pin guest memory */
+ 	guest_page = sev_pin_memory(kvm, params.guest_uaddr & PAGE_MASK,
+ 				    PAGE_SIZE, &n, 0);
+ 	if (!guest_page)
+ 		return -EFAULT;
+ 
+ 	/* allocate memory for header and transport buffer */
+ 	ret = -ENOMEM;
+ 	hdr = kmalloc(params.hdr_len, GFP_KERNEL_ACCOUNT);
+ 	if (!hdr)
+ 		goto e_unpin;
+ 
+ 	trans_data = kmalloc(params.trans_len, GFP_KERNEL_ACCOUNT);
+ 	if (!trans_data)
+ 		goto e_free_hdr;
+ 
+ 	data = kzalloc(sizeof(*data), GFP_KERNEL);
+ 	if (!data)
+ 		goto e_free_trans_data;
+ 
+ 	data->hdr_address = __psp_pa(hdr);
+ 	data->hdr_len = params.hdr_len;
+ 	data->trans_address = __psp_pa(trans_data);
+ 	data->trans_len = params.trans_len;
+ 
+ 	/* The SEND_UPDATE_DATA command requires C-bit to be always set. */
+ 	data->guest_address = (page_to_pfn(guest_page[0]) << PAGE_SHIFT) +
+ 				offset;
+ 	data->guest_address |= sev_me_mask;
+ 	data->guest_len = params.guest_len;
+ 	data->handle = sev->handle;
+ 
+ 	ret = sev_issue_cmd(kvm, SEV_CMD_SEND_UPDATE_DATA, data, &argp->error);
+ 
+ 	if (ret)
+ 		goto e_free;
+ 
+ 	/* copy transport buffer to user space */
+ 	if (copy_to_user((void __user *)(uintptr_t)params.trans_uaddr,
+ 			 trans_data, params.trans_len)) {
+ 		ret = -EFAULT;
+ 		goto e_free;
+ 	}
+ 
+ 	/* Copy packet header to userspace. */
+ 	ret = copy_to_user((void __user *)(uintptr_t)params.hdr_uaddr, hdr,
+ 				params.hdr_len);
+ 
+ e_free:
+ 	kfree(data);
+ e_free_trans_data:
+ 	kfree(trans_data);
+ e_free_hdr:
+ 	kfree(hdr);
+ e_unpin:
+ 	sev_unpin_memory(kvm, guest_page, n);
+ 
+ 	return ret;
+ }
+ 
+ static int sev_send_finish(struct kvm *kvm, struct kvm_sev_cmd *argp)
+ {
+ 	struct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;
+ 	struct sev_data_send_finish *data;
+ 	int ret;
+ 
+ 	if (!sev_guest(kvm))
+ 		return -ENOTTY;
+ 
+ 	data = kzalloc(sizeof(*data), GFP_KERNEL);
+ 	if (!data)
+ 		return -ENOMEM;
+ 
+ 	data->handle = sev->handle;
+ 	ret = sev_issue_cmd(kvm, SEV_CMD_SEND_FINISH, data, &argp->error);
+ 
+ 	kfree(data);
+ 	return ret;
+ }
+ 
+ static int sev_send_cancel(struct kvm *kvm, struct kvm_sev_cmd *argp)
+ {
+ 	struct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;
+ 	struct sev_data_send_cancel *data;
+ 	int ret;
+ 
+ 	if (!sev_guest(kvm))
+ 		return -ENOTTY;
+ 
+ 	data = kzalloc(sizeof(*data), GFP_KERNEL);
+ 	if (!data)
+ 		return -ENOMEM;
+ 
+ 	data->handle = sev->handle;
+ 	ret = sev_issue_cmd(kvm, SEV_CMD_SEND_CANCEL, data, &argp->error);
+ 
+ 	kfree(data);
+ 	return ret;
+ }
+ 
++>>>>>>> 5569e2e7a650 (KVM: SVM: Add support for KVM_SEV_SEND_CANCEL command)
  int svm_mem_enc_op(struct kvm *kvm, void __user *argp)
  {
  	struct kvm_sev_cmd sev_cmd;
@@@ -1280,6 -1462,15 +1443,18 @@@
  	case KVM_SEV_SEND_START:
  		r = sev_send_start(kvm, &sev_cmd);
  		break;
++<<<<<<< HEAD
++=======
+ 	case KVM_SEV_SEND_UPDATE_DATA:
+ 		r = sev_send_update_data(kvm, &sev_cmd);
+ 		break;
+ 	case KVM_SEV_SEND_FINISH:
+ 		r = sev_send_finish(kvm, &sev_cmd);
+ 		break;
+ 	case KVM_SEV_SEND_CANCEL:
+ 		r = sev_send_cancel(kvm, &sev_cmd);
+ 		break;
++>>>>>>> 5569e2e7a650 (KVM: SVM: Add support for KVM_SEV_SEND_CANCEL command)
  	default:
  		r = -EINVAL;
  		goto out;
* Unmerged path Documentation/virt/kvm/amd-memory-encryption.rst
* Unmerged path arch/x86/kvm/svm/sev.c
diff --git a/drivers/crypto/ccp/sev-dev.c b/drivers/crypto/ccp/sev-dev.c
index 62399b478ed3..54681b642baf 100644
--- a/drivers/crypto/ccp/sev-dev.c
+++ b/drivers/crypto/ccp/sev-dev.c
@@ -120,6 +120,7 @@ static int sev_cmd_buffer_len(int cmd)
 	case SEV_CMD_DOWNLOAD_FIRMWARE:		return sizeof(struct sev_data_download_firmware);
 	case SEV_CMD_GET_ID:			return sizeof(struct sev_data_get_id);
 	case SEV_CMD_ATTESTATION_REPORT:	return sizeof(struct sev_data_attestation_report);
+	case SEV_CMD_SEND_CANCEL:			return sizeof(struct sev_data_send_cancel);
 	default:				return 0;
 	}
 
diff --git a/include/linux/psp-sev.h b/include/linux/psp-sev.h
index d65f599d797a..845d5e618f62 100644
--- a/include/linux/psp-sev.h
+++ b/include/linux/psp-sev.h
@@ -76,6 +76,7 @@ enum sev_cmd {
 	SEV_CMD_SEND_UPDATE_DATA	= 0x041,
 	SEV_CMD_SEND_UPDATE_VMSA	= 0x042,
 	SEV_CMD_SEND_FINISH		= 0x043,
+	SEV_CMD_SEND_CANCEL		= 0x044,
 
 	/* Guest migration commands (incoming) */
 	SEV_CMD_RECEIVE_START		= 0x050,
@@ -393,6 +394,15 @@ struct sev_data_send_finish {
 	u32 handle;				/* In */
 } __packed;
 
+/**
+ * struct sev_data_send_cancel - SEND_CANCEL command parameters
+ *
+ * @handle: handle of the VM to process
+ */
+struct sev_data_send_cancel {
+	u32 handle;				/* In */
+} __packed;
+
 /**
  * struct sev_data_receive_start - RECEIVE_START command parameters
  *
diff --git a/include/uapi/linux/kvm.h b/include/uapi/linux/kvm.h
index 2c1b8b5e90f0..7aa338466eec 100644
--- a/include/uapi/linux/kvm.h
+++ b/include/uapi/linux/kvm.h
@@ -1586,6 +1586,8 @@ enum sev_cmd_id {
 	KVM_SEV_CERT_EXPORT,
 	/* Attestation report */
 	KVM_SEV_GET_ATTESTATION_REPORT,
+	/* Guest Migration Extension */
+	KVM_SEV_SEND_CANCEL,
 
 	KVM_SEV_NR_MAX,
 };
