sched/fair: Fix wrong negative conversion in find_energy_efficient_cpu()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Lukasz Luba <lukasz.luba@arm.com>
commit da0777d35f47892f359c3f73ea155870bb595700
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/da0777d3.failed

In find_energy_efficient_cpu() 'cpu_cap' could be less that 'util'.
It might be because of RT, DL (so higher sched class than CFS), irq or
thermal pressure signal, which reduce the capacity value.
In such situation the result of 'cpu_cap - util' might be negative but
stored in the unsigned long. Then it might be compared with other unsigned
long when uclamp_rq_util_with() reduced the 'util' such that is passes the
fits_capacity() check.

Prevent this situation and make the arithmetic more safe.

Fixes: 1d42509e475cd ("sched/fair: Make EAS wakeup placement consider uclamp restrictions")
	Signed-off-by: Lukasz Luba <lukasz.luba@arm.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Reviewed-by: Valentin Schneider <valentin.schneider@arm.com>
Link: https://lkml.kernel.org/r/20200810083004.26420-1-lukasz.luba@arm.com
(cherry picked from commit da0777d35f47892f359c3f73ea155870bb595700)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/fair.c
diff --cc kernel/sched/fair.c
index 80da66e74e55,90ebaa4ae16e..000000000000
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@@ -6527,9 -6592,19 +6527,23 @@@ static int find_energy_efficient_cpu(st
  			if (!cpumask_test_cpu(cpu, p->cpus_ptr))
  				continue;
  
 +			/* Skip CPUs that will be overutilized. */
  			util = cpu_util_next(cpu, p, cpu);
  			cpu_cap = capacity_of(cpu);
++<<<<<<< HEAD
++=======
+ 			spare_cap = cpu_cap;
+ 			lsub_positive(&spare_cap, util);
+ 
+ 			/*
+ 			 * Skip CPUs that cannot satisfy the capacity request.
+ 			 * IOW, placing the task there would make the CPU
+ 			 * overutilized. Take uclamp into account to see how
+ 			 * much capacity we can get out of the CPU; this is
+ 			 * aligned with schedutil_cpu_util().
+ 			 */
+ 			util = uclamp_rq_util_with(cpu_rq(cpu), util, p);
++>>>>>>> da0777d35f47 (sched/fair: Fix wrong negative conversion in find_energy_efficient_cpu())
  			if (!fits_capacity(util, cpu_cap))
  				continue;
  
* Unmerged path kernel/sched/fair.c
