mm,thp,compaction,cma: allow THP migration for CMA allocations

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Rik van Riel <riel@surriel.com>
commit 1da2f328fa643bd72197dfed0c655148af31e4eb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/1da2f328.failed

The code to implement THP migrations already exists, and the code for CMA
to clear out a region of memory already exists.

Only a few small tweaks are needed to allow CMA to move THP memory when
attempting an allocation from alloc_contig_range.

With these changes, migrating THPs from a CMA area works when allocating a
1GB hugepage from CMA memory.

[riel@surriel.com: fix hugetlbfs pages per Mike, cleanup per Vlastimil]
  Link: http://lkml.kernel.org/r/20200228104700.0af2f18d@imladris.surriel.com
	Signed-off-by: Rik van Riel <riel@surriel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Reviewed-by: Zi Yan <ziy@nvidia.com>
	Reviewed-by: Vlastimil Babka <vbabka@suse.cz>
	Cc: Michal Hocko <mhocko@kernel.org>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Cc: Mel Gorman <mgorman@techsingularity.net>
	Cc: David Rientjes <rientjes@google.com>
	Cc: Andrea Arcangeli <aarcange@redhat.com>
	Cc: Mike Kravetz <mike.kravetz@oracle.com>
	Cc: Joonsoo Kim <js1304@gmail.com>
Link: http://lkml.kernel.org/r/20200227213238.1298752-2-riel@surriel.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 1da2f328fa643bd72197dfed0c655148af31e4eb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/compaction.c
diff --cc mm/compaction.c
index 1b43ac614aea,000ade085b89..000000000000
--- a/mm/compaction.c
+++ b/mm/compaction.c
@@@ -1004,8 -988,9 +1007,14 @@@ isolate_migratepages_block(struct compa
  
  		/* Successfully isolated */
  		del_page_from_lru_list(page, lruvec, page_lru(page));
++<<<<<<< HEAD
 +		inc_node_page_state(page,
 +				NR_ISOLATED_ANON + page_is_file_lru(page));
++=======
+ 		mod_node_page_state(page_pgdat(page),
+ 				NR_ISOLATED_ANON + page_is_file_cache(page),
+ 				hpage_nr_pages(page));
++>>>>>>> 1da2f328fa64 (mm,thp,compaction,cma: allow THP migration for CMA allocations)
  
  isolate_success:
  		list_add(&page->lru, &cc->migratepages);
* Unmerged path mm/compaction.c
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index ae7a54ce3416..9d392926a99b 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -8264,15 +8264,20 @@ struct page *has_unmovable_pages(struct zone *zone, struct page *page,
 
 		/*
 		 * Hugepages are not in LRU lists, but they're movable.
+		 * THPs are on the LRU, but need to be counted as #small pages.
 		 * We need not scan over tail pages because we don't
 		 * handle each tail page individually in migration.
 		 */
-		if (PageHuge(page)) {
+		if (PageHuge(page) || PageTransCompound(page)) {
 			struct page *head = compound_head(page);
 			unsigned int skip_pages;
 
-			if (!hugepage_migration_supported(page_hstate(head)))
+			if (PageHuge(page)) {
+				if (!hugepage_migration_supported(page_hstate(head)))
+					return page;
+			} else if (!PageLRU(head) && !__PageMovable(head)) {
 				return page;
+			}
 
 			skip_pages = compound_nr(head) - (page - head);
 			iter += skip_pages - 1;
