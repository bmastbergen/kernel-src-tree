x86/hyperv: extract partition ID from Microsoft Hypervisor if necessary

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Wei Liu <wei.liu@kernel.org>
commit 99a0f46af6a7715147e81c558d558021aad4e207
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/99a0f46a.failed

We will need the partition ID for executing some hypercalls later.

	Signed-off-by: Lillian Grassin-Drake <ligrassi@microsoft.com>
Co-Developed-by: Sunil Muthuswamy <sunilmut@microsoft.com>
	Signed-off-by: Wei Liu <wei.liu@kernel.org>
	Reviewed-by: Michael Kelley <mikelley@microsoft.com>
Link: https://lore.kernel.org/r/20210203150435.27941-7-wei.liu@kernel.org
(cherry picked from commit 99a0f46af6a7715147e81c558d558021aad4e207)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/hyperv/hv_init.c
diff --cc arch/x86/hyperv/hv_init.c
index 73c835ac92d5,612c555fb9aa..000000000000
--- a/arch/x86/hyperv/hv_init.c
+++ b/arch/x86/hyperv/hv_init.c
@@@ -36,6 -28,10 +36,13 @@@
  #include <linux/syscore_ops.h>
  #include <clocksource/hyperv_timer.h>
  
++<<<<<<< HEAD
++=======
+ int hyperv_init_cpuhp;
+ u64 hv_current_partition_id = ~0ull;
+ EXPORT_SYMBOL_GPL(hv_current_partition_id);
+ 
++>>>>>>> 99a0f46af6a7 (x86/hyperv: extract partition ID from Microsoft Hypervisor if necessary)
  void *hv_hypercall_pg;
  EXPORT_SYMBOL_GPL(hv_hypercall_pg);
  
@@@ -461,6 -473,13 +486,16 @@@ void __init hyperv_init(void
  
  	register_syscore_ops(&hv_syscore_ops);
  
++<<<<<<< HEAD
++=======
+ 	hyperv_init_cpuhp = cpuhp;
+ 
+ 	if (cpuid_ebx(HYPERV_CPUID_FEATURES) & HV_ACCESS_PARTITION_ID)
+ 		hv_get_partition_id();
+ 
+ 	BUG_ON(hv_root_partition && hv_current_partition_id == ~0ull);
+ 
++>>>>>>> 99a0f46af6a7 (x86/hyperv: extract partition ID from Microsoft Hypervisor if necessary)
  	return;
  
  remove_cpuhp_state:
* Unmerged path arch/x86/hyperv/hv_init.c
diff --git a/arch/x86/include/asm/mshyperv.h b/arch/x86/include/asm/mshyperv.h
index 0d450ce090df..5561e5a36cca 100644
--- a/arch/x86/include/asm/mshyperv.h
+++ b/arch/x86/include/asm/mshyperv.h
@@ -68,6 +68,8 @@ extern void *hv_hypercall_pg;
 extern void  __percpu  **hyperv_pcpu_input_arg;
 extern void  __percpu  **hyperv_pcpu_output_arg;
 
+extern u64 hv_current_partition_id;
+
 static inline u64 hv_do_hypercall(u64 control, void *input, void *output)
 {
 	u64 input_address = input ? virt_to_phys(input) : 0;
diff --git a/include/asm-generic/hyperv-tlfs.h b/include/asm-generic/hyperv-tlfs.h
index e232ddcb0a2d..ba96bcb5c657 100644
--- a/include/asm-generic/hyperv-tlfs.h
+++ b/include/asm-generic/hyperv-tlfs.h
@@ -142,6 +142,7 @@ struct ms_hyperv_tsc_page {
 #define HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE_EX	0x0013
 #define HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST_EX	0x0014
 #define HVCALL_SEND_IPI_EX			0x0015
+#define HVCALL_GET_PARTITION_ID			0x0046
 #define HVCALL_GET_VP_REGISTERS			0x0050
 #define HVCALL_SET_VP_REGISTERS			0x0051
 #define HVCALL_POST_MESSAGE			0x005c
@@ -408,6 +409,11 @@ struct hv_tlb_flush_ex {
 	u64 gva_list[];
 } __packed;
 
+/* HvGetPartitionId hypercall (output only) */
+struct hv_get_partition_id {
+	u64 partition_id;
+} __packed;
+
 /* HvRetargetDeviceInterrupt hypercall */
 union hv_msi_entry {
 	u64 as_uint64;
