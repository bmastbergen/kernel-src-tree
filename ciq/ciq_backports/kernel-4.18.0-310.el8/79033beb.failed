KVM: x86/xen: Fix coexistence of Xen and Hyper-V hypercalls

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Joao Martins <joao.m.martins@oracle.com>
commit 79033bebf6fa3045bfa9bbe543c0eb7b43a0f4a3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/79033beb.failed

Disambiguate Xen vs. Hyper-V calls by adding 'orl $0x80000000, %eax'
at the start of the Hyper-V hypercall page when Xen hypercalls are
also enabled.

That bit is reserved in the Hyper-V ABI, and those hypercall numbers
will never be used by Xen (because it does precisely the same trick).

Switch to using kvm_vcpu_write_guest() while we're at it, instead of
open-coding it.

	Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
(cherry picked from commit 79033bebf6fa3045bfa9bbe543c0eb7b43a0f4a3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/hyperv.c
#	arch/x86/kvm/xen.c
#	tools/testing/selftests/kvm/x86_64/xen_vmcall_test.c
diff --cc arch/x86/kvm/hyperv.c
index 7e6409adef04,af7278abe16b..000000000000
--- a/arch/x86/kvm/hyperv.c
+++ b/arch/x86/kvm/hyperv.c
@@@ -1211,16 -1151,33 +1212,43 @@@ static int kvm_hv_set_msr_pw(struct kvm
  			hv->hv_hypercall = data;
  			break;
  		}
++<<<<<<< HEAD
 +		gfn = data >> HV_X64_MSR_HYPERCALL_PAGE_ADDRESS_SHIFT;
 +		addr = gfn_to_hva(kvm, gfn);
 +		if (kvm_is_error_hva(addr))
 +			return 1;
 +		kvm_x86_ops.patch_hypercall(vcpu, instructions);
 +		((unsigned char *)instructions)[3] = 0xc3; /* ret */
 +		if (__copy_to_user((void __user *)addr, instructions, 4))
++=======
+ 
+ 		/*
+ 		 * If Xen and Hyper-V hypercalls are both enabled, disambiguate
+ 		 * the same way Xen itself does, by setting the bit 31 of EAX
+ 		 * which is RsvdZ in the 32-bit Hyper-V hypercall ABI and just
+ 		 * going to be clobbered on 64-bit.
+ 		 */
+ 		if (kvm_xen_hypercall_enabled(kvm)) {
+ 			/* orl $0x80000000, %eax */
+ 			instructions[i++] = 0x0d;
+ 			instructions[i++] = 0x00;
+ 			instructions[i++] = 0x00;
+ 			instructions[i++] = 0x00;
+ 			instructions[i++] = 0x80;
+ 		}
+ 
+ 		/* vmcall/vmmcall */
+ 		static_call(kvm_x86_patch_hypercall)(vcpu, instructions + i);
+ 		i += 3;
+ 
+ 		/* ret */
+ 		((unsigned char *)instructions)[i++] = 0xc3;
+ 
+ 		addr = data & HV_X64_MSR_HYPERCALL_PAGE_ADDRESS_MASK;
+ 		if (kvm_vcpu_write_guest(vcpu, addr, instructions, i))
++>>>>>>> 79033bebf6fa (KVM: x86/xen: Fix coexistence of Xen and Hyper-V hypercalls)
  			return 1;
  		hv->hv_hypercall = data;
- 		mark_page_dirty(kvm, gfn);
  		break;
  	}
  	case HV_X64_MSR_REFERENCE_TSC:
* Unmerged path arch/x86/kvm/xen.c
* Unmerged path tools/testing/selftests/kvm/x86_64/xen_vmcall_test.c
* Unmerged path arch/x86/kvm/hyperv.c
* Unmerged path arch/x86/kvm/xen.c
* Unmerged path tools/testing/selftests/kvm/x86_64/xen_vmcall_test.c
