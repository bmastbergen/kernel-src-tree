KVM: x86: Move XSETBV emulation to common code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Sean Christopherson <seanjc@google.com>
commit 92f9895c146d7378f442dfc25a276c06150dfbd7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/92f9895c.failed

Move the entirety of XSETBV emulation to x86.c, and assign the
function directly to both VMX's and SVM's exit handlers, i.e. drop the
unnecessary trampolines.

No functional change intended.

	Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20210205005750.3841462-6-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 92f9895c146d7378f442dfc25a276c06150dfbd7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm/svm.c
#	arch/x86/kvm/vmx/vmx.c
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/svm/svm.c
index 05deab5ed2e8,57bce37d06e8..000000000000
--- a/arch/x86/kvm/svm/svm.c
+++ b/arch/x86/kvm/svm/svm.c
@@@ -2297,20 -2339,14 +2297,26 @@@ static int skinit_interception(struct v
  	return 1;
  }
  
 -static int wbinvd_interception(struct kvm_vcpu *vcpu)
 +static int wbinvd_interception(struct vcpu_svm *svm)
  {
 -	return kvm_emulate_wbinvd(vcpu);
 +	return kvm_emulate_wbinvd(&svm->vcpu);
  }
  
++<<<<<<< HEAD
 +static int xsetbv_interception(struct vcpu_svm *svm)
 +{
 +	u64 new_bv = kvm_read_edx_eax(&svm->vcpu);
 +	u32 index = kvm_rcx_read(&svm->vcpu);
 +
 +	if (kvm_set_xcr(&svm->vcpu, index, new_bv) == 0) {
 +		return kvm_skip_emulated_instruction(&svm->vcpu);
 +	}
 +
++=======
+ static int rdpru_interception(struct kvm_vcpu *vcpu)
+ {
+ 	kvm_queue_exception(vcpu, UD_VECTOR);
++>>>>>>> 92f9895c146d (KVM: x86: Move XSETBV emulation to common code)
  	return 1;
  }
  
diff --cc arch/x86/kvm/vmx/vmx.c
index 9c626d532031,f0bc4418da09..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -5208,16 -5216,6 +5208,19 @@@ static int handle_wbinvd(struct kvm_vcp
  	return kvm_emulate_wbinvd(vcpu);
  }
  
++<<<<<<< HEAD
 +static int handle_xsetbv(struct kvm_vcpu *vcpu)
 +{
 +	u64 new_bv = kvm_read_edx_eax(vcpu);
 +	u32 index = kvm_rcx_read(vcpu);
 +
 +	if (kvm_set_xcr(vcpu, index, new_bv) == 0)
 +		return kvm_skip_emulated_instruction(vcpu);
 +	return 1;
 +}
 +
++=======
++>>>>>>> 92f9895c146d (KVM: x86: Move XSETBV emulation to common code)
  static int handle_apic_access(struct kvm_vcpu *vcpu)
  {
  	if (likely(fasteoi)) {
diff --cc arch/x86/kvm/x86.c
index 703d0876830f,c545cf6ee607..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -975,16 -985,17 +975,26 @@@ static int __kvm_set_xcr(struct kvm_vcp
  	return 0;
  }
  
- int kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)
+ int kvm_emulate_xsetbv(struct kvm_vcpu *vcpu)
  {
++<<<<<<< HEAD
 +	if (kvm_x86_ops.get_cpl(vcpu) != 0 ||
 +	    __kvm_set_xcr(vcpu, index, xcr)) {
 +		kvm_inject_gp(vcpu, 0);
 +		return 1;
 +	}
 +	return 0;
++=======
+ 	if (static_call(kvm_x86_get_cpl)(vcpu) != 0 ||
+ 	    __kvm_set_xcr(vcpu, kvm_rcx_read(vcpu), kvm_read_edx_eax(vcpu))) {
+ 		kvm_inject_gp(vcpu, 0);
+ 		return 1;
+ 	}
+ 
+ 	return kvm_skip_emulated_instruction(vcpu);
++>>>>>>> 92f9895c146d (KVM: x86: Move XSETBV emulation to common code)
  }
- EXPORT_SYMBOL_GPL(kvm_set_xcr);
+ EXPORT_SYMBOL_GPL(kvm_emulate_xsetbv);
  
  bool kvm_is_valid_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)
  {
diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index b3a59b5f9bb5..0087ffb1832d 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -1551,7 +1551,7 @@ void kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val);
 unsigned long kvm_get_cr8(struct kvm_vcpu *vcpu);
 void kvm_lmsw(struct kvm_vcpu *vcpu, unsigned long msw);
 void kvm_get_cs_db_l_bits(struct kvm_vcpu *vcpu, int *db, int *l);
-int kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr);
+int kvm_emulate_xsetbv(struct kvm_vcpu *vcpu);
 
 int kvm_get_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr);
 int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr);
* Unmerged path arch/x86/kvm/svm/svm.c
* Unmerged path arch/x86/kvm/vmx/vmx.c
* Unmerged path arch/x86/kvm/x86.c
