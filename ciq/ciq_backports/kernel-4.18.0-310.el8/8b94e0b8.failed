mm/page_alloc: remove a wrapper for alloc_migration_target()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Joonsoo Kim <iamjoonsoo.kim@lge.com>
commit 8b94e0b8be360cf5460331e56a2678ba265f0694
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/8b94e0b8.failed

There is a well-defined standard migration target callback.  Use it
directly.

	Signed-off-by: Joonsoo Kim <iamjoonsoo.kim@lge.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Acked-by: Vlastimil Babka <vbabka@suse.cz>
	Cc: Christoph Hellwig <hch@infradead.org>
	Cc: Mike Kravetz <mike.kravetz@oracle.com>
	Cc: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
	Cc: Roman Gushchin <guro@fb.com>
Link: http://lkml.kernel.org/r/1594622517-20681-8-git-send-email-iamjoonsoo.kim@lge.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 8b94e0b8be360cf5460331e56a2678ba265f0694)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/page_isolation.c
diff --cc mm/page_isolation.c
index 8a5d47127662,242c03121d73..000000000000
--- a/mm/page_isolation.c
+++ b/mm/page_isolation.c
@@@ -308,10 -306,3 +308,13 @@@ int test_pages_isolated(unsigned long s
  
  	return pfn < end_pfn ? -EBUSY : 0;
  }
++<<<<<<< HEAD
 +
 +struct page *alloc_migrate_target(struct page *page, unsigned long private)
 +{
 +	int nid = page_to_nid(page);
 +
 +	return new_page_nodemask(page, nid, &node_states[N_MEMORY]);
 +}
++=======
++>>>>>>> 8b94e0b8be36 (mm/page_alloc: remove a wrapper for alloc_migration_target())
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index 65c092920ff8..a0476a38e3df 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -8323,6 +8323,10 @@ static int __alloc_contig_migrate_range(struct compact_control *cc,
 	unsigned long pfn = start;
 	unsigned int tries = 0;
 	int ret = 0;
+	struct migration_target_control mtc = {
+		.nid = zone_to_nid(cc->zone),
+		.gfp_mask = GFP_USER | __GFP_MOVABLE | __GFP_RETRY_MAYFAIL,
+	};
 
 	migrate_prep();
 
@@ -8349,8 +8353,8 @@ static int __alloc_contig_migrate_range(struct compact_control *cc,
 							&cc->migratepages);
 		cc->nr_migratepages -= nr_reclaimed;
 
-		ret = migrate_pages(&cc->migratepages, alloc_migrate_target,
-				    NULL, 0, cc->mode, MR_CONTIG_RANGE);
+		ret = migrate_pages(&cc->migratepages, alloc_migration_target,
+				NULL, (unsigned long)&mtc, cc->mode, MR_CONTIG_RANGE);
 	}
 	if (ret < 0) {
 		putback_movable_pages(&cc->migratepages);
* Unmerged path mm/page_isolation.c
