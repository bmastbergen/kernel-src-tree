ocxl: Assign a register set to a Logical Partition

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Christophe Lombard <clombard@linux.vnet.ibm.com>
commit fc1347b5feb685073ce2108c68cd8147340be016
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/fc1347b5.failed

Platform specific function to assign a register set to a Logical Partition.
The "ibm,mmio-atsd" property, provided by the firmware, contains the 16
base ATSD physical addresses (ATSD0 through ATSD15) of the set of MMIO
registers (XTS MMIO ATSDx LPARID/AVA/launch/status register).

For the time being, the ATSD0 set of registers is used by default.

	Signed-off-by: Christophe Lombard <clombard@linux.vnet.ibm.com>
	Acked-by: Frederic Barrat <fbarrat@linux.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20201125155013.39955-2-clombard@linux.vnet.ibm.com
(cherry picked from commit fc1347b5feb685073ce2108c68cd8147340be016)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/powernv/ocxl.c
diff --cc arch/powerpc/platforms/powernv/ocxl.c
index 8c65aacda9c8,57fc1062677b..000000000000
--- a/arch/powerpc/platforms/powernv/ocxl.c
+++ b/arch/powerpc/platforms/powernv/ocxl.c
@@@ -485,31 -484,47 +485,78 @@@ int pnv_ocxl_spa_remove_pe_from_cache(v
  }
  EXPORT_SYMBOL_GPL(pnv_ocxl_spa_remove_pe_from_cache);
  
++<<<<<<< HEAD
 +int pnv_ocxl_alloc_xive_irq(u32 *irq, u64 *trigger_addr)
 +{
 +	__be64 flags, trigger_page;
 +	s64 rc;
 +	u32 hwirq;
 +
 +	hwirq = xive_native_alloc_irq();
 +	if (!hwirq)
 +		return -ENOENT;
 +
 +	rc = opal_xive_get_irq_info(hwirq, &flags, NULL, &trigger_page, NULL,
 +				NULL);
 +	if (rc || !trigger_page) {
 +		xive_native_free_irq(hwirq);
 +		return -ENOENT;
 +	}
 +	*irq = hwirq;
 +	*trigger_addr = be64_to_cpu(trigger_page);
 +	return 0;
 +
 +}
 +EXPORT_SYMBOL_GPL(pnv_ocxl_alloc_xive_irq);
 +
 +void pnv_ocxl_free_xive_irq(u32 irq)
 +{
 +	xive_native_free_irq(irq);
 +}
 +EXPORT_SYMBOL_GPL(pnv_ocxl_free_xive_irq);
++=======
+ int pnv_ocxl_map_lpar(struct pci_dev *dev, uint64_t lparid,
+ 		      uint64_t lpcr, void __iomem **arva)
+ {
+ 	struct pci_controller *hose = pci_bus_to_host(dev->bus);
+ 	struct pnv_phb *phb = hose->private_data;
+ 	u64 mmio_atsd;
+ 	int rc;
+ 
+ 	/* ATSD physical address.
+ 	 * ATSD LAUNCH register: write access initiates a shoot down to
+ 	 * initiate the TLB Invalidate command.
+ 	 */
+ 	rc = of_property_read_u64_index(hose->dn, "ibm,mmio-atsd",
+ 					0, &mmio_atsd);
+ 	if (rc) {
+ 		dev_info(&dev->dev, "No available ATSD found\n");
+ 		return rc;
+ 	}
+ 
+ 	/* Assign a register set to a Logical Partition and MMIO ATSD
+ 	 * LPARID register to the required value.
+ 	 */
+ 	rc = opal_npu_map_lpar(phb->opal_id, pci_dev_id(dev),
+ 			       lparid, lpcr);
+ 	if (rc) {
+ 		dev_err(&dev->dev, "Error mapping device to LPAR: %d\n", rc);
+ 		return rc;
+ 	}
+ 
+ 	*arva = ioremap(mmio_atsd, 24);
+ 	if (!(*arva)) {
+ 		dev_warn(&dev->dev, "ioremap failed - mmio_atsd: %#llx\n", mmio_atsd);
+ 		rc = -ENOMEM;
+ 	}
+ 
+ 	return rc;
+ }
+ EXPORT_SYMBOL_GPL(pnv_ocxl_map_lpar);
+ 
+ void pnv_ocxl_unmap_lpar(void __iomem *arva)
+ {
+ 	iounmap(arva);
+ }
+ EXPORT_SYMBOL_GPL(pnv_ocxl_unmap_lpar);
++>>>>>>> fc1347b5feb6 (ocxl: Assign a register set to a Logical Partition)
diff --git a/arch/powerpc/include/asm/pnv-ocxl.h b/arch/powerpc/include/asm/pnv-ocxl.h
index 208b5503f4ed..7319ad0e5886 100644
--- a/arch/powerpc/include/asm/pnv-ocxl.h
+++ b/arch/powerpc/include/asm/pnv-ocxl.h
@@ -33,4 +33,7 @@ extern int pnv_ocxl_spa_remove_pe_from_cache(void *platform_data, int pe_handle)
 extern int pnv_ocxl_alloc_xive_irq(u32 *irq, u64 *trigger_addr);
 extern void pnv_ocxl_free_xive_irq(u32 irq);
 
+int pnv_ocxl_map_lpar(struct pci_dev *dev, uint64_t lparid,
+		      uint64_t lpcr, void __iomem **arva);
+void pnv_ocxl_unmap_lpar(void __iomem *arva);
 #endif /* _ASM_PNV_OCXL_H */
* Unmerged path arch/powerpc/platforms/powernv/ocxl.c
