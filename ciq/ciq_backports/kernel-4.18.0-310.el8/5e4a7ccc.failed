RDMA/rxe: Fix extra deref in rxe_rcv_mcast_pkt()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Bob Pearson <rpearsonhpe@gmail.com>
commit 5e4a7ccc965d951b0885875e903a32c6d4368573
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/5e4a7ccc.failed

rxe_rcv_mcast_pkt() dropped a reference to ib_device when no error
occurred causing an underflow on the reference counter.  This code is
cleaned up to be clearer and easier to read.

Fixes: 899aba891cab ("RDMA/rxe: Fix FIXME in rxe_udp_encap_recv()")
Link: https://lore.kernel.org/r/20210304192048.2958-1-rpearson@hpe.com
	Signed-off-by: Bob Pearson <rpearsonhpe@gmail.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit 5e4a7ccc965d951b0885875e903a32c6d4368573)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/sw/rxe/rxe_recv.c
diff --cc drivers/infiniband/sw/rxe/rxe_recv.c
index 5714ae334ac3,7a49e27da23a..000000000000
--- a/drivers/infiniband/sw/rxe/rxe_recv.c
+++ b/drivers/infiniband/sw/rxe/rxe_recv.c
@@@ -266,36 -269,49 +269,52 @@@ static void rxe_rcv_mcast_pkt(struct rx
  		if (err)
  			continue;
  
- 		/* for all but the last qp create a new clone of the
- 		 * skb and pass to the qp. If an error occurs in the
- 		 * checks for the last qp in the list we need to
- 		 * free the skb since it hasn't been passed on to
- 		 * rxe_rcv_pkt() which would free it later.
+ 		/* for all but the last QP create a new clone of the
+ 		 * skb and pass to the QP. Pass the original skb to
+ 		 * the last QP in the list.
  		 */
  		if (mce->qp_list.next != &mcg->qp_list) {
++<<<<<<< HEAD
 +			per_qp_skb = skb_clone(skb, GFP_ATOMIC);
++=======
+ 			struct sk_buff *cskb;
+ 			struct rxe_pkt_info *cpkt;
+ 
+ 			cskb = skb_clone(skb, GFP_ATOMIC);
+ 			if (unlikely(!cskb))
+ 				continue;
+ 
+ 			if (WARN_ON(!ib_device_try_get(&rxe->ib_dev))) {
+ 				kfree_skb(cskb);
+ 				break;
+ 			}
+ 
+ 			cpkt = SKB_TO_PKT(cskb);
+ 			cpkt->qp = qp;
+ 			rxe_add_ref(qp);
+ 			rxe_rcv_pkt(cpkt, cskb);
++>>>>>>> 5e4a7ccc965d (RDMA/rxe: Fix extra deref in rxe_rcv_mcast_pkt())
  		} else {
- 			per_qp_skb = skb;
- 			/* show we have consumed the skb */
- 			skb = NULL;
+ 			pkt->qp = qp;
+ 			rxe_add_ref(qp);
+ 			rxe_rcv_pkt(pkt, skb);
+ 			skb = NULL;	/* mark consumed */
  		}
- 
- 		if (unlikely(!per_qp_skb))
- 			continue;
- 
- 		per_qp_pkt = SKB_TO_PKT(per_qp_skb);
- 		per_qp_pkt->qp = qp;
- 		rxe_add_ref(qp);
- 		rxe_rcv_pkt(per_qp_pkt, per_qp_skb);
  	}
  
  	spin_unlock_bh(&mcg->mcg_lock);
  
  	rxe_drop_ref(mcg);	/* drop ref from rxe_pool_get_key. */
  
- err1:
- 	/* free skb if not consumed */
+ 	if (likely(!skb))
+ 		return;
+ 
+ 	/* This only occurs if one of the checks fails on the last
+ 	 * QP in the list above
+ 	 */
+ 
+ drop:
  	kfree_skb(skb);
 -	ib_device_put(&rxe->ib_dev);
  }
  
  /**
* Unmerged path drivers/infiniband/sw/rxe/rxe_recv.c
