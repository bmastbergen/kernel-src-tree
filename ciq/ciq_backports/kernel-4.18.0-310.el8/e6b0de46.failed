bus: mhi: core: Add uevent support for module autoloading

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
commit e6b0de469c5babfe29a86be289408ba2070ea44a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/e6b0de46.failed

Add uevent support to MHI bus so that the client drivers can be autoloaded
by udev when the MHI devices gets created. The client drivers are
expected to provide MODULE_DEVICE_TABLE with the MHI id_table struct so
that the alias can be exported.

	Signed-off-by: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
	Reviewed-by: Jeffrey Hugo <jhugo@codeaurora.org>
	Tested-by: Jeffrey Hugo <jhugo@codeaurora.org>
Link: https://lore.kernel.org/r/20200220095854.4804-13-manivannan.sadhasivam@linaro.org
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit e6b0de469c5babfe29a86be289408ba2070ea44a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bus/mhi/core/init.c
#	include/linux/mod_devicetable.h
#	scripts/mod/devicetable-offsets.c
#	scripts/mod/file2alias.c
diff --cc include/linux/mod_devicetable.h
index e72a43bd0482,f10e779a3fd0..000000000000
--- a/include/linux/mod_devicetable.h
+++ b/include/linux/mod_devicetable.h
@@@ -794,4 -798,40 +794,43 @@@ struct typec_device_id 
  	kernel_ulong_t driver_data;
  };
  
++<<<<<<< HEAD
++=======
+ /**
+  * struct tee_client_device_id - tee based device identifier
+  * @uuid: For TEE based client devices we use the device uuid as
+  *        the identifier.
+  */
+ struct tee_client_device_id {
+ 	uuid_t uuid;
+ };
+ 
+ /* WMI */
+ 
+ #define WMI_MODULE_PREFIX	"wmi:"
+ 
+ /**
+  * struct wmi_device_id - WMI device identifier
+  * @guid_string: 36 char string of the form fa50ff2b-f2e8-45de-83fa-65417f2f49ba
+  * @context: pointer to driver specific data
+  */
+ struct wmi_device_id {
+ 	const char guid_string[UUID_STRING_LEN+1];
+ 	const void *context;
+ };
+ 
+ #define MHI_DEVICE_MODALIAS_FMT "mhi:%s"
+ #define MHI_NAME_SIZE 32
+ 
+ /**
+  * struct mhi_device_id - MHI device identification
+  * @chan: MHI channel name
+  * @driver_data: driver data;
+  */
+ struct mhi_device_id {
+ 	const char chan[MHI_NAME_SIZE];
+ 	kernel_ulong_t driver_data;
+ };
+ 
++>>>>>>> e6b0de469c5b (bus: mhi: core: Add uevent support for module autoloading)
  #endif /* LINUX_MOD_DEVICETABLE_H */
diff --cc scripts/mod/devicetable-offsets.c
index 251793c94365,fe3f4a95cb21..000000000000
--- a/scripts/mod/devicetable-offsets.c
+++ b/scripts/mod/devicetable-offsets.c
@@@ -227,5 -225,14 +227,17 @@@ int main(void
  	DEVID_FIELD(typec_device_id, svid);
  	DEVID_FIELD(typec_device_id, mode);
  
++<<<<<<< HEAD
++=======
+ 	DEVID(tee_client_device_id);
+ 	DEVID_FIELD(tee_client_device_id, uuid);
+ 
+ 	DEVID(wmi_device_id);
+ 	DEVID_FIELD(wmi_device_id, guid_string);
+ 
+ 	DEVID(mhi_device_id);
+ 	DEVID_FIELD(mhi_device_id, chan);
+ 
++>>>>>>> e6b0de469c5b (bus: mhi: core: Add uevent support for module autoloading)
  	return 0;
  }
diff --cc scripts/mod/file2alias.c
index 54fde4db623f,cae6a4e471b5..000000000000
--- a/scripts/mod/file2alias.c
+++ b/scripts/mod/file2alias.c
@@@ -1280,6 -1299,51 +1280,54 @@@ static int do_typec_entry(const char *f
  	return 1;
  }
  
++<<<<<<< HEAD
++=======
+ /* Looks like: tee:uuid */
+ static int do_tee_entry(const char *filename, void *symval, char *alias)
+ {
+ 	DEF_FIELD(symval, tee_client_device_id, uuid);
+ 
+ 	sprintf(alias, "tee:%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
+ 		uuid.b[0], uuid.b[1], uuid.b[2], uuid.b[3], uuid.b[4],
+ 		uuid.b[5], uuid.b[6], uuid.b[7], uuid.b[8], uuid.b[9],
+ 		uuid.b[10], uuid.b[11], uuid.b[12], uuid.b[13], uuid.b[14],
+ 		uuid.b[15]);
+ 
+ 	add_wildcard(alias);
+ 	return 1;
+ }
+ 
+ /* Looks like: wmi:guid */
+ static int do_wmi_entry(const char *filename, void *symval, char *alias)
+ {
+ 	int len;
+ 	DEF_FIELD_ADDR(symval, wmi_device_id, guid_string);
+ 
+ 	if (strlen(*guid_string) != UUID_STRING_LEN) {
+ 		warn("Invalid WMI device id 'wmi:%s' in '%s'\n",
+ 				*guid_string, filename);
+ 		return 0;
+ 	}
+ 
+ 	len = snprintf(alias, ALIAS_SIZE, WMI_MODULE_PREFIX "%s", *guid_string);
+ 	if (len < 0 || len >= ALIAS_SIZE) {
+ 		warn("Could not generate all MODULE_ALIAS's in '%s'\n",
+ 				filename);
+ 		return 0;
+ 	}
+ 	return 1;
+ }
+ 
+ /* Looks like: mhi:S */
+ static int do_mhi_entry(const char *filename, void *symval, char *alias)
+ {
+ 	DEF_FIELD_ADDR(symval, mhi_device_id, chan);
+ 	sprintf(alias, MHI_DEVICE_MODALIAS_FMT, *chan);
+ 
+ 	return 1;
+ }
+ 
++>>>>>>> e6b0de469c5b (bus: mhi: core: Add uevent support for module autoloading)
  /* Does namelen bytes of name exactly match the symbol? */
  static bool sym_is(const char *name, unsigned namelen, const char *symbol)
  {
@@@ -1351,6 -1414,9 +1399,12 @@@ static const struct devtable devtable[
  	{"fslmc", SIZE_fsl_mc_device_id, do_fsl_mc_entry},
  	{"tbsvc", SIZE_tb_service_id, do_tbsvc_entry},
  	{"typec", SIZE_typec_device_id, do_typec_entry},
++<<<<<<< HEAD
++=======
+ 	{"tee", SIZE_tee_client_device_id, do_tee_entry},
+ 	{"wmi", SIZE_wmi_device_id, do_wmi_entry},
+ 	{"mhi", SIZE_mhi_device_id, do_mhi_entry},
++>>>>>>> e6b0de469c5b (bus: mhi: core: Add uevent support for module autoloading)
  };
  
  /* Create MODULE_ALIAS() statements.
* Unmerged path drivers/bus/mhi/core/init.c
* Unmerged path drivers/bus/mhi/core/init.c
* Unmerged path include/linux/mod_devicetable.h
* Unmerged path scripts/mod/devicetable-offsets.c
* Unmerged path scripts/mod/file2alias.c
