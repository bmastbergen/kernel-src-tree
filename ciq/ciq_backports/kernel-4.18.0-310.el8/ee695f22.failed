nSVM: Check addresses of MSR and IO permission maps

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-310.el8
commit-author Krish Sadhukhan <krish.sadhukhan@oracle.com>
commit ee695f22b54a4b79753fdaa78cbbff1064050d13
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-310.el8/ee695f22.failed

According to section "Canonicalization and Consistency Checks" in APM vol 2,
the following guest state is illegal:

    "The MSR or IOIO intercept tables extend to a physical address that
     is greater than or equal to the maximum supported physical address."

	Suggested-by: Paolo Bonzini <pbonzini@redhat.com>
	Signed-off-by: Krish Sadhukhan <krish.sadhukhan@oracle.com>
Message-Id: <20210412215611.110095-5-krish.sadhukhan@oracle.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit ee695f22b54a4b79753fdaa78cbbff1064050d13)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm/nested.c
diff --cc arch/x86/kvm/svm/nested.c
index 3881e4df2b71,3d8824e1448f..000000000000
--- a/arch/x86/kvm/svm/nested.c
+++ b/arch/x86/kvm/svm/nested.c
@@@ -511,10 -620,10 +530,15 @@@ int nested_svm_vmrun(struct vcpu_svm *s
  	if (WARN_ON_ONCE(!svm->nested.initialized))
  		return -EINVAL;
  
 -	nested_load_control_from_vmcb12(svm, &vmcb12->control);
 +	load_nested_vmcb_control(svm, &vmcb12->control);
  
++<<<<<<< HEAD
 +	if (!nested_vmcb_check_save(svm, vmcb12) ||
 +	    !nested_vmcb_check_controls(&svm->nested.ctl)) {
++=======
+ 	if (!nested_vmcb_valid_sregs(vcpu, &vmcb12->save) ||
+ 	    !nested_vmcb_check_controls(vcpu, &svm->nested.ctl)) {
++>>>>>>> ee695f22b54a (nSVM: Check addresses of MSR and IO permission maps)
  		vmcb12->control.exit_code    = SVM_EXIT_ERR;
  		vmcb12->control.exit_code_hi = 0;
  		vmcb12->control.exit_info_1  = 0;
* Unmerged path arch/x86/kvm/svm/nested.c
