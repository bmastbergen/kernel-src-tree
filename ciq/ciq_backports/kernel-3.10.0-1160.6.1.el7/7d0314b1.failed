net/mlx5e: Modify uplink state on interface up/down

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.6.1.el7
commit-author Ron Diskin <rondi@mellanox.com>
commit 7d0314b11cdd92bca8b89684c06953bf114605fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.6.1.el7/7d0314b1.failed

When setting the PF interface up/down, notify the firmware to update
uplink state via MODIFY_VPORT_STATE, when E-Switch is enabled.

This behavior will prevent sending traffic out on uplink port when PF is
down, such as sending traffic from a VF interface which is still up.
Currently when calling mlx5e_open/close(), the driver only sends PAOS
command to notify the firmware to set the physical port state to
up/down, however, it is not sufficient. When VF is in "auto" state, it
follows the uplink state, which was not updated on mlx5e_open/close()
before this patch.

When switchdev mode is enabled and uplink representor is first enabled,
set the uplink port state value back to its FW default "AUTO".

Fixes: 63bfd399de55 ("net/mlx5e: Send PAOS command on interface up/down")
	Signed-off-by: Ron Diskin <rondi@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Reviewed-by: Moshe Shemesh <moshe@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 7d0314b11cdd92bca8b89684c06953bf114605fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index c269711c7700,9519a61bd8ec..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -1428,7 -1002,139 +1428,135 @@@ static int mlx5e_init_rep_tx(struct mlx
  		mlx5_core_warn(priv->mdev, "create tises failed, %d\n", err);
  		return err;
  	}
 -
 -	if (rpriv->rep->vport == MLX5_VPORT_UPLINK) {
 -		err = mlx5e_init_uplink_rep_tx(rpriv);
 -		if (err)
 -			goto destroy_tises;
 -	}
 -
  	return 0;
++<<<<<<< HEAD
++=======
+ 
+ destroy_tises:
+ 	mlx5e_destroy_tises(priv);
+ 	return err;
+ }
+ 
+ static void mlx5e_cleanup_uplink_rep_tx(struct mlx5e_rep_priv *rpriv)
+ {
+ 	mlx5e_rep_tc_netdevice_event_unregister(rpriv);
+ 	mlx5e_rep_bond_cleanup(rpriv);
+ 	mlx5e_rep_tc_cleanup(rpriv);
+ }
+ 
+ static void mlx5e_cleanup_rep_tx(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5e_rep_priv *rpriv = priv->ppriv;
+ 
+ 	mlx5e_destroy_tises(priv);
+ 
+ 	if (rpriv->rep->vport == MLX5_VPORT_UPLINK)
+ 		mlx5e_cleanup_uplink_rep_tx(rpriv);
+ }
+ 
+ static void mlx5e_rep_enable(struct mlx5e_priv *priv)
+ {
+ 	mlx5e_set_netdev_mtu_boundaries(priv);
+ }
+ 
+ static int mlx5e_update_rep_rx(struct mlx5e_priv *priv)
+ {
+ 	return 0;
+ }
+ 
+ static int uplink_rep_async_event(struct notifier_block *nb, unsigned long event, void *data)
+ {
+ 	struct mlx5e_priv *priv = container_of(nb, struct mlx5e_priv, events_nb);
+ 
+ 	if (event == MLX5_EVENT_TYPE_PORT_CHANGE) {
+ 		struct mlx5_eqe *eqe = data;
+ 
+ 		switch (eqe->sub_type) {
+ 		case MLX5_PORT_CHANGE_SUBTYPE_DOWN:
+ 		case MLX5_PORT_CHANGE_SUBTYPE_ACTIVE:
+ 			queue_work(priv->wq, &priv->update_carrier_work);
+ 			break;
+ 		default:
+ 			return NOTIFY_DONE;
+ 		}
+ 
+ 		return NOTIFY_OK;
+ 	}
+ 
+ 	if (event == MLX5_DEV_EVENT_PORT_AFFINITY)
+ 		return mlx5e_rep_tc_event_port_affinity(priv);
+ 
+ 	return NOTIFY_DONE;
+ }
+ 
+ static void mlx5e_uplink_rep_enable(struct mlx5e_priv *priv)
+ {
+ 	struct net_device *netdev = priv->netdev;
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	u16 max_mtu;
+ 
+ 	netdev->min_mtu = ETH_MIN_MTU;
+ 	mlx5_query_port_max_mtu(priv->mdev, &max_mtu, 1);
+ 	netdev->max_mtu = MLX5E_HW2SW_MTU(&priv->channels.params, max_mtu);
+ 	mlx5e_set_dev_port_mtu(priv);
+ 
+ 	mlx5e_rep_tc_enable(priv);
+ 
+ 	mlx5_modify_vport_admin_state(mdev, MLX5_VPORT_STATE_OP_MOD_UPLINK,
+ 				      0, 0, MLX5_VPORT_ADMIN_STATE_AUTO);
+ 	mlx5_lag_add(mdev, netdev);
+ 	priv->events_nb.notifier_call = uplink_rep_async_event;
+ 	mlx5_notifier_register(mdev, &priv->events_nb);
+ 	mlx5e_dcbnl_initialize(priv);
+ 	mlx5e_dcbnl_init_app(priv);
+ }
+ 
+ static void mlx5e_uplink_rep_disable(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 
+ 	mlx5e_dcbnl_delete_app(priv);
+ 	mlx5_notifier_unregister(mdev, &priv->events_nb);
+ 	mlx5e_rep_tc_disable(priv);
+ 	mlx5_lag_remove(mdev);
+ }
+ 
+ static MLX5E_DEFINE_STATS_GRP(sw_rep, 0);
+ static MLX5E_DEFINE_STATS_GRP(vport_rep, MLX5E_NDO_UPDATE_STATS);
+ 
+ /* The stats groups order is opposite to the update_stats() order calls */
+ static mlx5e_stats_grp_t mlx5e_rep_stats_grps[] = {
+ 	&MLX5E_STATS_GRP(sw_rep),
+ 	&MLX5E_STATS_GRP(vport_rep),
+ };
+ 
+ static unsigned int mlx5e_rep_stats_grps_num(struct mlx5e_priv *priv)
+ {
+ 	return ARRAY_SIZE(mlx5e_rep_stats_grps);
+ }
+ 
+ /* The stats groups order is opposite to the update_stats() order calls */
+ static mlx5e_stats_grp_t mlx5e_ul_rep_stats_grps[] = {
+ 	&MLX5E_STATS_GRP(sw),
+ 	&MLX5E_STATS_GRP(qcnt),
+ 	&MLX5E_STATS_GRP(vnic_env),
+ 	&MLX5E_STATS_GRP(vport),
+ 	&MLX5E_STATS_GRP(802_3),
+ 	&MLX5E_STATS_GRP(2863),
+ 	&MLX5E_STATS_GRP(2819),
+ 	&MLX5E_STATS_GRP(phy),
+ 	&MLX5E_STATS_GRP(eth_ext),
+ 	&MLX5E_STATS_GRP(pcie),
+ 	&MLX5E_STATS_GRP(per_prio),
+ 	&MLX5E_STATS_GRP(pme),
+ 	&MLX5E_STATS_GRP(channels),
+ 	&MLX5E_STATS_GRP(per_port_buff_congest),
+ };
+ 
+ static unsigned int mlx5e_ul_rep_stats_grps_num(struct mlx5e_priv *priv)
+ {
+ 	return ARRAY_SIZE(mlx5e_ul_rep_stats_grps);
++>>>>>>> 7d0314b11cdd (net/mlx5e: Modify uplink state on interface up/down)
  }
  
  static const struct mlx5e_profile mlx5e_rep_profile = {
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index ffa3fd0ef749,71d01143c455..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -1840,26 -1823,29 +1840,34 @@@ unlock
  }
  
  int mlx5_eswitch_set_vport_state(struct mlx5_eswitch *esw,
 -				 u16 vport, int link_state)
 +				 int vport, int link_state)
  {
++<<<<<<< HEAD
 +	struct mlx5_vport *evport;
++=======
+ 	struct mlx5_vport *evport = mlx5_eswitch_get_vport(esw, vport);
+ 	int opmod = MLX5_VPORT_STATE_OP_MOD_ESW_VPORT;
+ 	int other_vport = 1;
++>>>>>>> 7d0314b11cdd (net/mlx5e: Modify uplink state on interface up/down)
  	int err = 0;
  
  	if (!ESW_ALLOWED(esw))
  		return -EPERM;
 -	if (IS_ERR(evport))
 -		return PTR_ERR(evport);
 +	if (!LEGAL_VPORT(esw, vport))
 +		return -EINVAL;
  
+ 	if (vport == MLX5_VPORT_UPLINK) {
+ 		opmod = MLX5_VPORT_STATE_OP_MOD_UPLINK;
+ 		other_vport = 0;
+ 		vport = 0;
+ 	}
  	mutex_lock(&esw->state_lock);
 +	evport = &esw->vports[vport];
  
- 	err = mlx5_modify_vport_admin_state(esw->dev,
- 					    MLX5_VPORT_STATE_OP_MOD_ESW_VPORT,
- 					    vport, 1, link_state);
+ 	err = mlx5_modify_vport_admin_state(esw->dev, opmod, vport, other_vport, link_state);
  	if (err) {
- 		mlx5_core_warn(esw->dev,
- 			       "Failed to set vport %d link state, err = %d",
- 			       vport, err);
+ 		mlx5_core_warn(esw->dev, "Failed to set vport %d link state, opmod = %d, err = %d",
+ 			       vport, opmod, err);
  		goto unlock;
  	}
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 7d67c43f8bc3,5785596f13f5..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -407,15 -676,22 +407,25 @@@ void mlx5e_tc_clean_fdb_peer_flows(stru
  /* eswitch API stubs */
  static inline int  mlx5_eswitch_init(struct mlx5_core_dev *dev) { return 0; }
  static inline void mlx5_eswitch_cleanup(struct mlx5_eswitch *esw) {}
 -static inline int mlx5_eswitch_enable(struct mlx5_eswitch *esw, int num_vfs) { return 0; }
 -static inline void mlx5_eswitch_disable(struct mlx5_eswitch *esw, bool clear_vf) {}
 +static inline void mlx5_eswitch_vport_event(struct mlx5_eswitch *esw, struct mlx5_eqe *eqe) {}
 +static inline int  mlx5_eswitch_enable_sriov(struct mlx5_eswitch *esw, int nvfs, int mode) { return 0; }
 +static inline void mlx5_eswitch_disable_sriov(struct mlx5_eswitch *esw) {}
  static inline bool mlx5_esw_lag_prereq(struct mlx5_core_dev *dev0, struct mlx5_core_dev *dev1) { return true; }
++<<<<<<< HEAD
++=======
+ static inline bool mlx5_eswitch_is_funcs_handler(struct mlx5_core_dev *dev) { return false; }
+ static inline
+ int mlx5_eswitch_set_vport_state(struct mlx5_eswitch *esw, u16 vport, int link_state) { return 0; }
+ static inline const u32 *mlx5_esw_query_functions(struct mlx5_core_dev *dev)
+ {
+ 	return ERR_PTR(-EOPNOTSUPP);
+ }
++>>>>>>> 7d0314b11cdd (net/mlx5e: Modify uplink state on interface up/down)
 +
 +#define FDB_MAX_CHAIN 1
 +#define FDB_SLOW_PATH_CHAIN (FDB_MAX_CHAIN + 1)
 +#define FDB_MAX_PRIO 1
  
 -static inline struct mlx5_flow_handle *
 -esw_add_restore_rule(struct mlx5_eswitch *esw, u32 tag)
 -{
 -	return ERR_PTR(-EOPNOTSUPP);
 -}
  #endif /* CONFIG_MLX5_ESWITCH */
  
  #endif /* __MLX5_ESWITCH_H__ */
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index bdfebfe8925d..9422ed78e1bb 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@ -2952,6 +2952,25 @@ void mlx5e_timestamp_init(struct mlx5e_priv *priv)
 	priv->tstamp.rx_filter = HWTSTAMP_FILTER_NONE;
 }
 
+static void mlx5e_modify_admin_state(struct mlx5_core_dev *mdev,
+				     enum mlx5_port_status state)
+{
+	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+	int vport_admin_state;
+
+	mlx5_set_port_admin_status(mdev, state);
+
+	if (!MLX5_ESWITCH_MANAGER(mdev) ||  mlx5_eswitch_mode(esw) == MLX5_ESWITCH_OFFLOADS)
+		return;
+
+	if (state == MLX5_PORT_UP)
+		vport_admin_state = MLX5_VPORT_ADMIN_STATE_AUTO;
+	else
+		vport_admin_state = MLX5_VPORT_ADMIN_STATE_DOWN;
+
+	mlx5_eswitch_set_vport_state(esw, MLX5_VPORT_UPLINK, vport_admin_state);
+}
+
 int mlx5e_open_locked(struct net_device *netdev)
 {
 	struct mlx5e_priv *priv = netdev_priv(netdev);
@@ -2986,7 +3005,7 @@ int mlx5e_open(struct net_device *netdev)
 	mutex_lock(&priv->state_lock);
 	err = mlx5e_open_locked(netdev);
 	if (!err)
-		mlx5_set_port_admin_status(priv->mdev, MLX5_PORT_UP);
+		mlx5e_modify_admin_state(priv->mdev, MLX5_PORT_UP);
 	mutex_unlock(&priv->state_lock);
 
 	if (mlx5_vxlan_allowed(priv->mdev->vxlan))
@@ -3023,7 +3042,7 @@ int mlx5e_close(struct net_device *netdev)
 		return -ENODEV;
 
 	mutex_lock(&priv->state_lock);
-	mlx5_set_port_admin_status(priv->mdev, MLX5_PORT_DOWN);
+	mlx5e_modify_admin_state(priv->mdev, MLX5_PORT_DOWN);
 	err = mlx5e_close_locked(netdev);
 	mutex_unlock(&priv->state_lock);
 
@@ -4972,7 +4991,7 @@ static void mlx5e_nic_enable(struct mlx5e_priv *priv)
 
 	/* Marking the link as currently not needed by the Driver */
 	if (!netif_running(netdev))
-		mlx5_set_port_admin_status(mdev, MLX5_PORT_DOWN);
+		mlx5e_modify_admin_state(mdev, MLX5_PORT_DOWN);
 
 	/* MTU range: 68 - hw-specific max */
 	netdev->extended->min_mtu = ETH_MIN_MTU;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
diff --git a/include/linux/mlx5/mlx5_ifc.h b/include/linux/mlx5/mlx5_ifc.h
index aa2d00356ede..de50303c6d57 100644
--- a/include/linux/mlx5/mlx5_ifc.h
+++ b/include/linux/mlx5/mlx5_ifc.h
@@ -3865,6 +3865,7 @@ struct mlx5_ifc_query_vport_state_out_bits {
 enum {
 	MLX5_VPORT_STATE_OP_MOD_VNIC_VPORT  = 0x0,
 	MLX5_VPORT_STATE_OP_MOD_ESW_VPORT   = 0x1,
+	MLX5_VPORT_STATE_OP_MOD_UPLINK      = 0x2,
 };
 
 struct mlx5_ifc_query_vport_state_in_bits {
