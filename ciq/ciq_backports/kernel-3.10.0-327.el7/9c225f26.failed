vfs: atomic f_pos accesses as per POSIX

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Linus Torvalds <torvalds@linux-foundation.org>
commit 9c225f2655e36a470c4f58dbbc99244c5fc7f2d4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/9c225f26.failed

Our write() system call has always been atomic in the sense that you get
the expected thread-safe contiguous write, but we haven't actually
guaranteed that concurrent writes are serialized wrt f_pos accesses, so
threads (or processes) that share a file descriptor and use "write()"
concurrently would quite likely overwrite each others data.

This violates POSIX.1-2008/SUSv4 Section XSI 2.9.7 that says:

 "2.9.7 Thread Interactions with Regular File Operations

  All of the following functions shall be atomic with respect to each
  other in the effects specified in POSIX.1-2008 when they operate on
  regular files or symbolic links: [...]"

and one of the effects is the file position update.

This unprotected file position behavior is not new behavior, and nobody
has ever cared.  Until now.  Yongzhi Pan reported unexpected behavior to
Michael Kerrisk that was due to this.

This resolves the issue with a f_pos-specific lock that is taken by
read/write/lseek on file descriptors that may be shared across threads
or processes.

	Reported-by: Yongzhi Pan <panyongzhi@gmail.com>
	Reported-by: Michael Kerrisk <mtk.manpages@gmail.com>
	Cc: Al Viro <viro@zeniv.linux.org.uk>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 9c225f2655e36a470c4f58dbbc99244c5fc7f2d4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/read_write.c
diff --cc fs/read_write.c
index 165376843836,932bb3414a96..000000000000
--- a/fs/read_write.c
+++ b/fs/read_write.c
@@@ -497,8 -530,9 +523,14 @@@ SYSCALL_DEFINE3(read, unsigned int, fd
  	if (f.file) {
  		loff_t pos = file_pos_read(f.file);
  		ret = vfs_read(f.file, buf, count, &pos);
++<<<<<<< HEAD
 +		file_pos_write(f.file, pos);
 +		fdput(f);
++=======
+ 		if (ret >= 0)
+ 			file_pos_write(f.file, pos);
+ 		fdput_pos(f);
++>>>>>>> 9c225f2655e3 (vfs: atomic f_pos accesses as per POSIX)
  	}
  	return ret;
  }
@@@ -512,8 -546,9 +544,14 @@@ SYSCALL_DEFINE3(write, unsigned int, fd
  	if (f.file) {
  		loff_t pos = file_pos_read(f.file);
  		ret = vfs_write(f.file, buf, count, &pos);
++<<<<<<< HEAD
 +		file_pos_write(f.file, pos);
 +		fdput(f);
++=======
+ 		if (ret >= 0)
+ 			file_pos_write(f.file, pos);
+ 		fdput_pos(f);
++>>>>>>> 9c225f2655e3 (vfs: atomic f_pos accesses as per POSIX)
  	}
  
  	return ret;
@@@ -800,8 -829,9 +838,14 @@@ SYSCALL_DEFINE3(readv, unsigned long, f
  	if (f.file) {
  		loff_t pos = file_pos_read(f.file);
  		ret = vfs_readv(f.file, vec, vlen, &pos);
++<<<<<<< HEAD
 +		file_pos_write(f.file, pos);
 +		fdput(f);
++=======
+ 		if (ret >= 0)
+ 			file_pos_write(f.file, pos);
+ 		fdput_pos(f);
++>>>>>>> 9c225f2655e3 (vfs: atomic f_pos accesses as per POSIX)
  	}
  
  	if (ret > 0)
@@@ -819,8 -849,9 +863,14 @@@ SYSCALL_DEFINE3(writev, unsigned long, 
  	if (f.file) {
  		loff_t pos = file_pos_read(f.file);
  		ret = vfs_writev(f.file, vec, vlen, &pos);
++<<<<<<< HEAD
 +		file_pos_write(f.file, pos);
 +		fdput(f);
++=======
+ 		if (ret >= 0)
+ 			file_pos_write(f.file, pos);
+ 		fdput_pos(f);
++>>>>>>> 9c225f2655e3 (vfs: atomic f_pos accesses as per POSIX)
  	}
  
  	if (ret > 0)
@@@ -979,8 -1002,9 +1029,14 @@@ COMPAT_SYSCALL_DEFINE3(readv, compat_ul
  		return -EBADF;
  	pos = f.file->f_pos;
  	ret = compat_readv(f.file, vec, vlen, &pos);
++<<<<<<< HEAD
 +	f.file->f_pos = pos;
 +	fdput(f);
++=======
+ 	if (ret >= 0)
+ 		f.file->f_pos = pos;
+ 	fdput_pos(f);
++>>>>>>> 9c225f2655e3 (vfs: atomic f_pos accesses as per POSIX)
  	return ret;
  }
  
@@@ -1045,8 -1069,9 +1101,14 @@@ COMPAT_SYSCALL_DEFINE3(writev, compat_u
  		return -EBADF;
  	pos = f.file->f_pos;
  	ret = compat_writev(f.file, vec, vlen, &pos);
++<<<<<<< HEAD
 +	f.file->f_pos = pos;
 +	fdput(f);
++=======
+ 	if (ret >= 0)
+ 		f.file->f_pos = pos;
+ 	fdput_pos(f);
++>>>>>>> 9c225f2655e3 (vfs: atomic f_pos accesses as per POSIX)
  	return ret;
  }
  
diff --git a/fs/file_table.c b/fs/file_table.c
index 1a14f3a84097..aa68a98f8193 100644
--- a/fs/file_table.c
+++ b/fs/file_table.c
@@ -136,6 +136,7 @@ struct file *get_empty_filp(void)
 	atomic_long_set(&f->f_count, 1);
 	rwlock_init(&f->f_owner.lock);
 	spin_lock_init(&f->f_lock);
+	mutex_init(&f->f_pos_lock);
 	eventpoll_init_file(f);
 	/* f->f_version: 0 */
 	return f;
diff --git a/fs/namei.c b/fs/namei.c
index 72c9894b9e82..db62795036cb 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -1897,7 +1897,7 @@ static int path_init(int dfd, const char *name, unsigned int flags,
 
 		nd->path = f.file->f_path;
 		if (flags & LOOKUP_RCU) {
-			if (f.need_put)
+			if (f.flags & FDPUT_FPUT)
 				*fp = f.file;
 			nd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);
 			lock_rcu_walk();
diff --git a/fs/open.c b/fs/open.c
index 5cf4cfd348d4..03e1f8060808 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -728,6 +728,10 @@ static int do_dentry_open(struct file *f,
 		return 0;
 	}
 
+	/* POSIX.1-2008/SUSv4 Section XSI 2.9.7 */
+	if (S_ISREG(inode->i_mode))
+		f->f_mode |= FMODE_ATOMIC_POS;
+
 	f->f_op = fops_get(inode->i_fop);
 
 	error = security_file_open(f, cred);
* Unmerged path fs/read_write.c
diff --git a/include/linux/file.h b/include/linux/file.h
index cbacf4faf447..f2517fa2d610 100644
--- a/include/linux/file.h
+++ b/include/linux/file.h
@@ -28,12 +28,14 @@ static inline void fput_light(struct file *file, int fput_needed)
 
 struct fd {
 	struct file *file;
-	int need_put;
+	unsigned int flags;
 };
+#define FDPUT_FPUT       1
+#define FDPUT_POS_UNLOCK 2
 
 static inline void fdput(struct fd fd)
 {
-	if (fd.need_put)
+	if (fd.flags & FDPUT_FPUT)
 		fput(fd.file);
 }
 
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 67ee418be1ff..415ea723bba7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -121,6 +121,9 @@ typedef void (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 /* File is opened with O_PATH; almost nothing can be done with it */
 #define FMODE_PATH		((__force fmode_t)0x4000)
 
+/* File needs atomic accesses to f_pos */
+#define FMODE_ATOMIC_POS	((__force fmode_t)0x8000)
+
 /* File was opened by fanotify and shouldn't generate fanotify events */
 #define FMODE_NONOTIFY		((__force fmode_t)0x1000000)
 
@@ -802,7 +805,7 @@ struct file {
 	const struct file_operations	*f_op;
 
 	/*
-	 * Protects f_ep_links, f_flags, f_pos vs i_size in lseek SEEK_CUR.
+	 * Protects f_ep_links, f_flags.
 	 * Must not be taken from IRQ context.
 	 */
 	spinlock_t		f_lock;
@@ -818,6 +821,7 @@ struct file {
 	atomic_long_t		f_count;
 	unsigned int 		f_flags;
 	fmode_t			f_mode;
+	struct mutex		f_pos_lock;
 	loff_t			f_pos;
 	struct fown_struct	f_owner;
 	const struct cred	*f_cred;
