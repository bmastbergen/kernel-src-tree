ACPI / video: Run _BCL before deciding registering backlight

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [acpi] video: Run _BCL before deciding registering backlight (Benjamin Tissoires) [1218354]
Rebuild_FUZZ: 93.81%
commit-author Aaron Lu <aaron.lu@intel.com>
commit dce4ec2e452fddb7542b5fc15d0e6b8531f6d5eb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/dce4ec2e.failed

The ASUS K53SM's ACPI table queries _OSI("Windows 2012") in the video
output device's _BCL and _BCM control method instead of the usual _INI
functions of the _SB or PCI host bridge PCI0 devices. This made our
video module thought this is a pre-Win8 system when deciding if we
should register a backlight interface for it and the end result is that
a non-working acpi_video interface is registered and user is unable to
control backlight from GUI. Solve this problem by evaluating _BCL control
method before doing the decision.

Note that for some Thinkpad systems, the _BCL is also required to be
evaluated for the hotkey event to be generated no matter if we will
register an ACPI video backlight interface for it or not. Since the
thinkpad_acpi module will do this anyway we didn't add such a thing in
the video module previously. But now with this change here, the
thinkpad_acpi module is no more necessary for those systems regarding
backlight functionality.

Link: https://bugzilla.kernel.org/show_bug.cgi?id=85051
Reported-and-tested-by: Ralf Jung <post+kernel@ralfj.de>
	Signed-off-by: Aaron Lu <aaron.lu@intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit dce4ec2e452fddb7542b5fc15d0e6b8531f6d5eb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/video.c
diff --cc drivers/acpi/video.c
index 3fbd8b48e19e,41e6b977ceb2..000000000000
--- a/drivers/acpi/video.c
+++ b/drivers/acpi/video.c
@@@ -1756,6 -1600,316 +1756,319 @@@ acpi_video_bus_match(acpi_handle handle
  	return AE_OK;
  }
  
++<<<<<<< HEAD
++=======
+ static void acpi_video_dev_register_backlight(struct acpi_video_device *device)
+ {
+ 	struct backlight_properties props;
+ 	struct pci_dev *pdev;
+ 	acpi_handle acpi_parent;
+ 	struct device *parent = NULL;
+ 	int result;
+ 	static int count;
+ 	char *name;
+ 
+ 	/*
+ 	 * Do not create backlight device for video output
+ 	 * device that is not in the enumerated list.
+ 	 */
+ 	if (!acpi_video_device_in_dod(device)) {
+ 		dev_dbg(&device->dev->dev, "not in _DOD list, ignore\n");
+ 		return;
+ 	}
+ 
+ 	result = acpi_video_init_brightness(device);
+ 	if (result)
+ 		return;
+ 	name = kasprintf(GFP_KERNEL, "acpi_video%d", count);
+ 	if (!name)
+ 		return;
+ 	count++;
+ 
+ 	acpi_get_parent(device->dev->handle, &acpi_parent);
+ 
+ 	pdev = acpi_get_pci_dev(acpi_parent);
+ 	if (pdev) {
+ 		parent = &pdev->dev;
+ 		pci_dev_put(pdev);
+ 	}
+ 
+ 	memset(&props, 0, sizeof(struct backlight_properties));
+ 	props.type = BACKLIGHT_FIRMWARE;
+ 	props.max_brightness = device->brightness->count - 3;
+ 	device->backlight = backlight_device_register(name,
+ 						      parent,
+ 						      device,
+ 						      &acpi_backlight_ops,
+ 						      &props);
+ 	kfree(name);
+ 	if (IS_ERR(device->backlight))
+ 		return;
+ 
+ 	/*
+ 	 * Save current brightness level in case we have to restore it
+ 	 * before acpi_video_device_lcd_set_level() is called next time.
+ 	 */
+ 	device->backlight->props.brightness =
+ 			acpi_video_get_brightness(device->backlight);
+ 
+ 	device->cooling_dev = thermal_cooling_device_register("LCD",
+ 				device->dev, &video_cooling_ops);
+ 	if (IS_ERR(device->cooling_dev)) {
+ 		/*
+ 		 * Set cooling_dev to NULL so we don't crash trying to free it.
+ 		 * Also, why the hell we are returning early and not attempt to
+ 		 * register video output if cooling device registration failed?
+ 		 * -- dtor
+ 		 */
+ 		device->cooling_dev = NULL;
+ 		return;
+ 	}
+ 
+ 	dev_info(&device->dev->dev, "registered as cooling_device%d\n",
+ 		 device->cooling_dev->id);
+ 	result = sysfs_create_link(&device->dev->dev.kobj,
+ 			&device->cooling_dev->device.kobj,
+ 			"thermal_cooling");
+ 	if (result)
+ 		printk(KERN_ERR PREFIX "Create sysfs link\n");
+ 	result = sysfs_create_link(&device->cooling_dev->device.kobj,
+ 			&device->dev->dev.kobj, "device");
+ 	if (result)
+ 		printk(KERN_ERR PREFIX "Create sysfs link\n");
+ }
+ 
+ static void acpi_video_run_bcl_for_osi(struct acpi_video_bus *video)
+ {
+ 	struct acpi_video_device *dev;
+ 	union acpi_object *levels;
+ 
+ 	mutex_lock(&video->device_list_lock);
+ 	list_for_each_entry(dev, &video->video_device_list, entry) {
+ 		if (!acpi_video_device_lcd_query_levels(dev, &levels))
+ 			kfree(levels);
+ 	}
+ 	mutex_unlock(&video->device_list_lock);
+ }
+ 
+ static int acpi_video_bus_register_backlight(struct acpi_video_bus *video)
+ {
+ 	struct acpi_video_device *dev;
+ 
+ 	if (video->backlight_registered)
+ 		return 0;
+ 
+ 	acpi_video_run_bcl_for_osi(video);
+ 
+ 	if (!acpi_video_verify_backlight_support())
+ 		return 0;
+ 
+ 	mutex_lock(&video->device_list_lock);
+ 	list_for_each_entry(dev, &video->video_device_list, entry)
+ 		acpi_video_dev_register_backlight(dev);
+ 	mutex_unlock(&video->device_list_lock);
+ 
+ 	video->backlight_registered = true;
+ 
+ 	video->pm_nb.notifier_call = acpi_video_resume;
+ 	video->pm_nb.priority = 0;
+ 	return register_pm_notifier(&video->pm_nb);
+ }
+ 
+ static void acpi_video_dev_unregister_backlight(struct acpi_video_device *device)
+ {
+ 	if (device->backlight) {
+ 		backlight_device_unregister(device->backlight);
+ 		device->backlight = NULL;
+ 	}
+ 	if (device->brightness) {
+ 		kfree(device->brightness->levels);
+ 		kfree(device->brightness);
+ 		device->brightness = NULL;
+ 	}
+ 	if (device->cooling_dev) {
+ 		sysfs_remove_link(&device->dev->dev.kobj, "thermal_cooling");
+ 		sysfs_remove_link(&device->cooling_dev->device.kobj, "device");
+ 		thermal_cooling_device_unregister(device->cooling_dev);
+ 		device->cooling_dev = NULL;
+ 	}
+ }
+ 
+ static int acpi_video_bus_unregister_backlight(struct acpi_video_bus *video)
+ {
+ 	struct acpi_video_device *dev;
+ 	int error;
+ 
+ 	if (!video->backlight_registered)
+ 		return 0;
+ 
+ 	error = unregister_pm_notifier(&video->pm_nb);
+ 
+ 	mutex_lock(&video->device_list_lock);
+ 	list_for_each_entry(dev, &video->video_device_list, entry)
+ 		acpi_video_dev_unregister_backlight(dev);
+ 	mutex_unlock(&video->device_list_lock);
+ 
+ 	video->backlight_registered = false;
+ 
+ 	return error;
+ }
+ 
+ static void acpi_video_dev_add_notify_handler(struct acpi_video_device *device)
+ {
+ 	acpi_status status;
+ 	struct acpi_device *adev = device->dev;
+ 
+ 	status = acpi_install_notify_handler(adev->handle, ACPI_DEVICE_NOTIFY,
+ 					     acpi_video_device_notify, device);
+ 	if (ACPI_FAILURE(status))
+ 		dev_err(&adev->dev, "Error installing notify handler\n");
+ 	else
+ 		device->flags.notify = 1;
+ }
+ 
+ static int acpi_video_bus_add_notify_handler(struct acpi_video_bus *video)
+ {
+ 	struct input_dev *input;
+ 	struct acpi_video_device *dev;
+ 	int error;
+ 
+ 	video->input = input = input_allocate_device();
+ 	if (!input) {
+ 		error = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	error = acpi_video_bus_start_devices(video);
+ 	if (error)
+ 		goto err_free_input;
+ 
+ 	snprintf(video->phys, sizeof(video->phys),
+ 			"%s/video/input0", acpi_device_hid(video->device));
+ 
+ 	input->name = acpi_device_name(video->device);
+ 	input->phys = video->phys;
+ 	input->id.bustype = BUS_HOST;
+ 	input->id.product = 0x06;
+ 	input->dev.parent = &video->device->dev;
+ 	input->evbit[0] = BIT(EV_KEY);
+ 	set_bit(KEY_SWITCHVIDEOMODE, input->keybit);
+ 	set_bit(KEY_VIDEO_NEXT, input->keybit);
+ 	set_bit(KEY_VIDEO_PREV, input->keybit);
+ 	set_bit(KEY_BRIGHTNESS_CYCLE, input->keybit);
+ 	set_bit(KEY_BRIGHTNESSUP, input->keybit);
+ 	set_bit(KEY_BRIGHTNESSDOWN, input->keybit);
+ 	set_bit(KEY_BRIGHTNESS_ZERO, input->keybit);
+ 	set_bit(KEY_DISPLAY_OFF, input->keybit);
+ 
+ 	error = input_register_device(input);
+ 	if (error)
+ 		goto err_stop_dev;
+ 
+ 	mutex_lock(&video->device_list_lock);
+ 	list_for_each_entry(dev, &video->video_device_list, entry)
+ 		acpi_video_dev_add_notify_handler(dev);
+ 	mutex_unlock(&video->device_list_lock);
+ 
+ 	return 0;
+ 
+ err_stop_dev:
+ 	acpi_video_bus_stop_devices(video);
+ err_free_input:
+ 	input_free_device(input);
+ 	video->input = NULL;
+ out:
+ 	return error;
+ }
+ 
+ static void acpi_video_dev_remove_notify_handler(struct acpi_video_device *dev)
+ {
+ 	if (dev->flags.notify) {
+ 		acpi_remove_notify_handler(dev->dev->handle, ACPI_DEVICE_NOTIFY,
+ 					   acpi_video_device_notify);
+ 		dev->flags.notify = 0;
+ 	}
+ }
+ 
+ static void acpi_video_bus_remove_notify_handler(struct acpi_video_bus *video)
+ {
+ 	struct acpi_video_device *dev;
+ 
+ 	mutex_lock(&video->device_list_lock);
+ 	list_for_each_entry(dev, &video->video_device_list, entry)
+ 		acpi_video_dev_remove_notify_handler(dev);
+ 	mutex_unlock(&video->device_list_lock);
+ 
+ 	acpi_video_bus_stop_devices(video);
+ 	input_unregister_device(video->input);
+ 	video->input = NULL;
+ }
+ 
+ static int acpi_video_backlight_notify(struct notifier_block *nb,
+ 					unsigned long val, void *bd)
+ {
+ 	struct backlight_device *backlight = bd;
+ 	struct acpi_video_bus *video;
+ 
+ 	/* acpi_video_verify_backlight_support only cares about raw devices */
+ 	if (backlight->props.type != BACKLIGHT_RAW)
+ 		return NOTIFY_DONE;
+ 
+ 	video = container_of(nb, struct acpi_video_bus, backlight_nb);
+ 
+ 	switch (val) {
+ 	case BACKLIGHT_REGISTERED:
+ 		if (!acpi_video_verify_backlight_support())
+ 			acpi_video_bus_unregister_backlight(video);
+ 		break;
+ 	case BACKLIGHT_UNREGISTERED:
+ 		acpi_video_bus_register_backlight(video);
+ 		break;
+ 	}
+ 
+ 	return NOTIFY_OK;
+ }
+ 
+ static int acpi_video_bus_add_backlight_notify_handler(
+ 						struct acpi_video_bus *video)
+ {
+ 	int error;
+ 
+ 	video->backlight_nb.notifier_call = acpi_video_backlight_notify;
+ 	video->backlight_nb.priority = 0;
+ 	error = backlight_register_notifier(&video->backlight_nb);
+ 	if (error == 0)
+ 		video->backlight_notifier_registered = true;
+ 
+ 	return error;
+ }
+ 
+ static int acpi_video_bus_remove_backlight_notify_handler(
+ 						struct acpi_video_bus *video)
+ {
+ 	if (!video->backlight_notifier_registered)
+ 		return 0;
+ 
+ 	video->backlight_notifier_registered = false;
+ 
+ 	return backlight_unregister_notifier(&video->backlight_nb);
+ }
+ 
+ static int acpi_video_bus_put_devices(struct acpi_video_bus *video)
+ {
+ 	struct acpi_video_device *dev, *next;
+ 
+ 	mutex_lock(&video->device_list_lock);
+ 	list_for_each_entry_safe(dev, next, &video->video_device_list, entry) {
+ 		list_del(&dev->entry);
+ 		kfree(dev);
+ 	}
+ 	mutex_unlock(&video->device_list_lock);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> dce4ec2e452f (ACPI / video: Run _BCL before deciding registering backlight)
  static int instance;
  
  static int acpi_video_bus_add(struct acpi_device *device)
* Unmerged path drivers/acpi/video.c
