powerpc/eeh: Replace pr_warning() with pr_warn()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [powerpc] eeh: Replace pr_warning() with pr_warn() (Steve Best) [1211945]
Rebuild_FUZZ: 90.91%
commit-author Gavin Shan <gwshan@linux.vnet.ibm.com>
commit 0dae27439acc75266d35c39970f1b5d80e0c596b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/0dae2743.failed

pr_warn() is equal to pr_warning(), but the former is a bit more
formal according to commit fc62f2f ("kernel.h: add pr_warn for
symmetry to dev_warn, netdev_warn").

The patch replaces pr_warning() with pr_warn().

	Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
	Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
(cherry picked from commit 0dae27439acc75266d35c39970f1b5d80e0c596b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/eeh.c
#	arch/powerpc/platforms/pseries/eeh_pseries.c
diff --cc arch/powerpc/kernel/eeh.c
index c8d258621ed5,02a67740b151..000000000000
--- a/arch/powerpc/kernel/eeh.c
+++ b/arch/powerpc/kernel/eeh.c
@@@ -877,11 -878,14 +877,17 @@@ int eeh_init(void
  
  	/* call platform initialization function */
  	if (!eeh_ops) {
- 		pr_warning("%s: Platform EEH operation not found\n",
+ 		pr_warn("%s: Platform EEH operation not found\n",
  			__func__);
  		return -EEXIST;
++<<<<<<< HEAD
 +	} else if ((ret = eeh_ops->init()))
++=======
+ 	} else if ((ret = eeh_ops->init())) {
+ 		pr_warn("%s: Failed to call platform init function (%d)\n",
+ 			__func__, ret);
++>>>>>>> 0dae27439acc (powerpc/eeh: Replace pr_warning() with pr_warn())
  		return ret;
 -	}
  
  	/* Initialize EEH event */
  	ret = eeh_event_init();
diff --cc arch/powerpc/platforms/pseries/eeh_pseries.c
index a919da0f7fca,b08053819d99..000000000000
--- a/arch/powerpc/platforms/pseries/eeh_pseries.c
+++ b/arch/powerpc/platforms/pseries/eeh_pseries.c
@@@ -88,14 -88,29 +88,40 @@@ static int pseries_eeh_init(void
  	 * and its variant since the old firmware probably support address
  	 * of domain/bus/slot/function for EEH RTAS operations.
  	 */
++<<<<<<< HEAD
 +	if (ibm_set_eeh_option == RTAS_UNKNOWN_SERVICE		||
 +	    ibm_set_slot_reset == RTAS_UNKNOWN_SERVICE		||
 +	    (ibm_read_slot_reset_state2 == RTAS_UNKNOWN_SERVICE &&
 +	     ibm_read_slot_reset_state == RTAS_UNKNOWN_SERVICE)	||
 +	    ibm_slot_error_detail == RTAS_UNKNOWN_SERVICE	||
 +	    (ibm_configure_pe == RTAS_UNKNOWN_SERVICE		&&
 +	     ibm_configure_bridge == RTAS_UNKNOWN_SERVICE)) {
 +		pr_info("EEH functionality not supported\n");
++=======
+ 	if (ibm_set_eeh_option == RTAS_UNKNOWN_SERVICE) {
+ 		pr_warn("%s: RTAS service <ibm,set-eeh-option> invalid\n",
+ 			__func__);
+ 		return -EINVAL;
+ 	} else if (ibm_set_slot_reset == RTAS_UNKNOWN_SERVICE) {
+ 		pr_warn("%s: RTAS service <ibm,set-slot-reset> invalid\n",
+ 			__func__);
+ 		return -EINVAL;
+ 	} else if (ibm_read_slot_reset_state2 == RTAS_UNKNOWN_SERVICE &&
+ 		   ibm_read_slot_reset_state == RTAS_UNKNOWN_SERVICE) {
+ 		pr_warn("%s: RTAS service <ibm,read-slot-reset-state2> and "
+ 			"<ibm,read-slot-reset-state> invalid\n",
+ 			__func__);
+ 		return -EINVAL;
+ 	} else if (ibm_slot_error_detail == RTAS_UNKNOWN_SERVICE) {
+ 		pr_warn("%s: RTAS service <ibm,slot-error-detail> invalid\n",
+ 			__func__);
+ 		return -EINVAL;
+ 	} else if (ibm_configure_pe == RTAS_UNKNOWN_SERVICE &&
+ 		   ibm_configure_bridge == RTAS_UNKNOWN_SERVICE) {
+ 		pr_warn("%s: RTAS service <ibm,configure-pe> and "
+ 			"<ibm,configure-bridge> invalid\n",
+ 			__func__);
++>>>>>>> 0dae27439acc (powerpc/eeh: Replace pr_warning() with pr_warn())
  		return -EINVAL;
  	}
  
@@@ -103,11 -118,11 +129,19 @@@
  	spin_lock_init(&slot_errbuf_lock);
  	eeh_error_buf_size = rtas_token("rtas-error-log-max");
  	if (eeh_error_buf_size == RTAS_UNKNOWN_SERVICE) {
++<<<<<<< HEAD
 +		pr_info("%s: unknown EEH error log size\n",
 +			__func__);
 +		eeh_error_buf_size = 1024;
 +	} else if (eeh_error_buf_size > RTAS_ERROR_LOG_MAX) {
 +		pr_info("%s: EEH error log size %d exceeds the maximal %d\n",
++=======
+ 		pr_warn("%s: unknown EEH error log size\n",
+ 			__func__);
+ 		eeh_error_buf_size = 1024;
+ 	} else if (eeh_error_buf_size > RTAS_ERROR_LOG_MAX) {
+ 		pr_warn("%s: EEH error log size %d exceeds the maximal %d\n",
++>>>>>>> 0dae27439acc (powerpc/eeh: Replace pr_warning() with pr_warn())
  			__func__, eeh_error_buf_size, RTAS_ERROR_LOG_MAX);
  		eeh_error_buf_size = RTAS_ERROR_LOG_MAX;
  	}
* Unmerged path arch/powerpc/kernel/eeh.c
diff --git a/arch/powerpc/kernel/eeh_cache.c b/arch/powerpc/kernel/eeh_cache.c
index e8c9fd546a5c..ab392ce90b49 100644
--- a/arch/powerpc/kernel/eeh_cache.c
+++ b/arch/powerpc/kernel/eeh_cache.c
@@ -143,7 +143,7 @@ eeh_addr_cache_insert(struct pci_dev *dev, unsigned long alo,
 		} else {
 			if (dev != piar->pcidev ||
 			    alo != piar->addr_lo || ahi != piar->addr_hi) {
-				pr_warning("PIAR: overlapping address range\n");
+				pr_warn("PIAR: overlapping address range\n");
 			}
 			return piar;
 		}
@@ -177,13 +177,14 @@ static void __eeh_addr_cache_insert_dev(struct pci_dev *dev)
 
 	dn = pci_device_to_OF_node(dev);
 	if (!dn) {
-		pr_warning("PCI: no pci dn found for dev=%s\n", pci_name(dev));
+		pr_warn("PCI: no pci dn found for dev=%s\n",
+			pci_name(dev));
 		return;
 	}
 
 	edev = of_node_to_eeh_dev(dn);
 	if (!edev) {
-		pr_warning("PCI: no EEH dev found for dn=%s\n",
+		pr_warn("PCI: no EEH dev found for dn=%s\n",
 			dn->full_name);
 		return;
 	}
diff --git a/arch/powerpc/kernel/eeh_dev.c b/arch/powerpc/kernel/eeh_dev.c
index 1efa28f5fc54..e5274ee9a75f 100644
--- a/arch/powerpc/kernel/eeh_dev.c
+++ b/arch/powerpc/kernel/eeh_dev.c
@@ -57,7 +57,8 @@ void *eeh_dev_init(struct device_node *dn, void *data)
 	/* Allocate EEH device */
 	edev = kzalloc(sizeof(*edev), GFP_KERNEL);
 	if (!edev) {
-		pr_warning("%s: out of memory\n", __func__);
+		pr_warn("%s: out of memory\n",
+			__func__);
 		return NULL;
 	}
 
diff --git a/arch/powerpc/kernel/eeh_driver.c b/arch/powerpc/kernel/eeh_driver.c
index 420da61d4ce0..6a0dcee8e931 100644
--- a/arch/powerpc/kernel/eeh_driver.c
+++ b/arch/powerpc/kernel/eeh_driver.c
@@ -599,7 +599,7 @@ static void eeh_handle_normal_event(struct eeh_pe *pe)
 	pe->freeze_count++;
 	if (pe->freeze_count > EEH_MAX_ALLOWED_FREEZES)
 		goto excess_failures;
-	pr_warning("EEH: This PCI device has failed %d times in the last hour\n",
+	pr_warn("EEH: This PCI device has failed %d times in the last hour\n",
 		pe->freeze_count);
 
 	/* Walk the various device drivers attached to this slot through
@@ -616,7 +616,7 @@ static void eeh_handle_normal_event(struct eeh_pe *pe)
 	 */
 	rc = eeh_ops->wait_state(pe, MAX_WAIT_FOR_RECOVERY*1000);
 	if (rc < 0 || rc == EEH_STATE_NOT_SUPPORT) {
-		pr_warning("EEH: Permanent failure\n");
+		pr_warn("EEH: Permanent failure\n");
 		goto hard_fail;
 	}
 
@@ -635,8 +635,8 @@ static void eeh_handle_normal_event(struct eeh_pe *pe)
 		pr_info("EEH: Reset with hotplug activity\n");
 		rc = eeh_reset_device(pe, frozen_bus);
 		if (rc) {
-			pr_warning("%s: Unable to reset, err=%d\n",
-				   __func__, rc);
+			pr_warn("%s: Unable to reset, err=%d\n",
+				__func__, rc);
 			goto hard_fail;
 		}
 	}
@@ -678,7 +678,7 @@ static void eeh_handle_normal_event(struct eeh_pe *pe)
 
 	/* If any device has a hard failure, then shut off everything. */
 	if (result == PCI_ERS_RESULT_DISCONNECT) {
-		pr_warning("EEH: Device driver gave up\n");
+		pr_warn("EEH: Device driver gave up\n");
 		goto hard_fail;
 	}
 
@@ -687,8 +687,8 @@ static void eeh_handle_normal_event(struct eeh_pe *pe)
 		pr_info("EEH: Reset without hotplug activity\n");
 		rc = eeh_reset_device(pe, NULL);
 		if (rc) {
-			pr_warning("%s: Cannot reset, err=%d\n",
-				   __func__, rc);
+			pr_warn("%s: Cannot reset, err=%d\n",
+				__func__, rc);
 			goto hard_fail;
 		}
 
@@ -701,7 +701,7 @@ static void eeh_handle_normal_event(struct eeh_pe *pe)
 	/* All devices should claim they have recovered by now. */
 	if ((result != PCI_ERS_RESULT_RECOVERED) &&
 	    (result != PCI_ERS_RESULT_NONE)) {
-		pr_warning("EEH: Not recovered\n");
+		pr_warn("EEH: Not recovered\n");
 		goto hard_fail;
 	}
 
diff --git a/arch/powerpc/kernel/eeh_pe.c b/arch/powerpc/kernel/eeh_pe.c
index fbd01eba4473..1e750c933244 100644
--- a/arch/powerpc/kernel/eeh_pe.c
+++ b/arch/powerpc/kernel/eeh_pe.c
@@ -179,7 +179,8 @@ void *eeh_pe_dev_traverse(struct eeh_pe *root,
 	void *ret;
 
 	if (!root) {
-		pr_warning("%s: Invalid PE %p\n", __func__, root);
+		pr_warn("%s: Invalid PE %p\n",
+			__func__, root);
 		return NULL;
 	}
 
diff --git a/arch/powerpc/platforms/powernv/eeh-ioda.c b/arch/powerpc/platforms/powernv/eeh-ioda.c
index f6abdb11ee84..5ab61b78dfc6 100644
--- a/arch/powerpc/platforms/powernv/eeh-ioda.c
+++ b/arch/powerpc/platforms/powernv/eeh-ioda.c
@@ -247,8 +247,8 @@ static void ioda_eeh_phb_diag(struct pci_controller *hose)
 	rc = opal_pci_get_phb_diag_data2(phb->opal_id, phb->diag.blob,
 					 PNV_PCI_DIAG_BUF_SIZE);
 	if (rc != OPAL_SUCCESS) {
-		pr_warning("%s: Failed to get diag-data for PHB#%x (%ld)\n",
-			    __func__, hose->global_number, rc);
+		pr_warn("%s: Failed to get diag-data for PHB#%x (%ld)\n",
+			__func__, hose->global_number, rc);
 		return;
 	}
 
@@ -627,8 +627,8 @@ static void ioda_eeh_hub_diag(struct pci_controller *hose)
 
 	rc = opal_pci_get_hub_diag_data(phb->hub_id, data, sizeof(*data));
 	if (rc != OPAL_SUCCESS) {
-		pr_warning("%s: Failed to get HUB#%llx diag-data (%ld)\n",
-			   __func__, phb->hub_id, rc);
+		pr_warn("%s: Failed to get HUB#%llx diag-data (%ld)\n",
+			__func__, phb->hub_id, rc);
 		return;
 	}
 
@@ -664,8 +664,8 @@ static void ioda_eeh_hub_diag(struct pci_controller *hose)
 		ioda_eeh_hub_diag_common(data);
 		break;
 	default:
-		pr_warning("%s: Invalid type of HUB#%llx diag-data (%d)\n",
-			   __func__, phb->hub_id, data->type);
+		pr_warn("%s: Invalid type of HUB#%llx diag-data (%d)\n",
+			__func__, phb->hub_id, data->type);
 	}
 }
 
diff --git a/arch/powerpc/platforms/powernv/eeh-powernv.c b/arch/powerpc/platforms/powernv/eeh-powernv.c
index 998bcc18a491..6f0318487771 100644
--- a/arch/powerpc/platforms/powernv/eeh-powernv.c
+++ b/arch/powerpc/platforms/powernv/eeh-powernv.c
@@ -47,7 +47,8 @@ static int powernv_eeh_init(void)
 {
 	/* We require OPALv3 */
 	if (!firmware_has_feature(FW_FEATURE_OPALv3)) {
-		pr_warning("%s: OPALv3 is required !\n", __func__);
+		pr_warn("%s: OPALv3 is required !\n",
+			__func__);
 		return -EINVAL;
 	}
 
@@ -273,8 +274,8 @@ static int powernv_eeh_wait_state(struct eeh_pe *pe, int max_wait)
 
 		max_wait -= mwait;
 		if (max_wait <= 0) {
-			pr_warning("%s: Timeout getting PE#%x's state (%d)\n",
-				   __func__, pe->addr, max_wait);
+			pr_warn("%s: Timeout getting PE#%x's state (%d)\n",
+				__func__, pe->addr, max_wait);
 			return EEH_STATE_NOT_SUPPORT;
 		}
 
* Unmerged path arch/powerpc/platforms/pseries/eeh_pseries.c
