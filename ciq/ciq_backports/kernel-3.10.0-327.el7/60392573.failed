direct-io: add flag to allow aio writes beyond i_size

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Christoph Hellwig <hch@infradead.org>
commit 6039257378e4c84da06e68230b14fef955508ce6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/60392573.failed

Some filesystems can handle direct I/O writes beyond i_size safely,
so allow them to opt into receiving them.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit 6039257378e4c84da06e68230b14fef955508ce6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/direct-io.c
#	include/linux/fs.h
diff --cc fs/direct-io.c
index dd8ae1597169,a701752dd750..000000000000
--- a/fs/direct-io.c
+++ b/fs/direct-io.c
@@@ -1133,26 -1194,46 +1133,67 @@@ do_blockdev_direct_IO(int rw, struct ki
  	}
  
  	/*
++<<<<<<< HEAD
 +	 * Will be decremented at I/O completion time. For a block device
 +	 * we don't need to protect against truncate, so don't increment
 +	 * the inode direct IO count.
 +	 */
 +	if (!(dio->flags & DIO_IGNORE_TRUNCATE))
 +		atomic_inc(&inode->i_dio_count);
 +
 +	/*
 +	 * For file extending writes updating i_size before data
 +	 * writeouts complete can expose uninitialized blocks. So
 +	 * even for AIO, we need to wait for i/o to complete before
 +	 * returning in this case.
 +	 */
 +	dio->is_async = !is_sync_kiocb(iocb) && !((rw & WRITE) &&
 +		(end > i_size_read(inode)));
++=======
+ 	 * For file extending writes updating i_size before data writeouts
+ 	 * complete can expose uninitialized blocks in dumb filesystems.
+ 	 * In that case we need to wait for I/O completion even if asked
+ 	 * for an asynchronous write.
+ 	 */
+ 	if (is_sync_kiocb(iocb))
+ 		dio->is_async = false;
+ 	else if (!(dio->flags & DIO_ASYNC_EXTEND) &&
+             (rw & WRITE) && end > i_size_read(inode))
+ 		dio->is_async = false;
+ 	else
+ 		dio->is_async = true;
+ 
+ 	dio->inode = inode;
+ 	dio->rw = rw;
+ 
+ 	/*
+ 	 * For AIO O_(D)SYNC writes we need to defer completions to a workqueue
+ 	 * so that we can call ->fsync.
+ 	 */
+ 	if (dio->is_async && (rw & WRITE) &&
+ 	    ((iocb->ki_filp->f_flags & O_DSYNC) ||
+ 	     IS_SYNC(iocb->ki_filp->f_mapping->host))) {
+ 		retval = dio_set_defer_completion(dio);
+ 		if (retval) {
+ 			/*
+ 			 * We grab i_mutex only for reads so we don't have
+ 			 * to release it here
+ 			 */
+ 			kmem_cache_free(dio_cache, dio);
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	/*
+ 	 * Will be decremented at I/O completion time.
+ 	 */
+ 	atomic_inc(&inode->i_dio_count);
++>>>>>>> 6039257378e4 (direct-io: add flag to allow aio writes beyond i_size)
  
  	retval = 0;
 +
 +	dio->inode = inode;
 +	dio->rw = rw;
  	sdio.blkbits = blkbits;
  	sdio.blkfactor = i_blkbits - blkbits;
  	sdio.block_in_file = offset >> blkbits;
diff --cc include/linux/fs.h
index 664b4d164818,f7faefcf4843..000000000000
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@@ -2636,8 -2528,8 +2636,13 @@@ enum 
  	/* filesystem does not support filling holes */
  	DIO_SKIP_HOLES	= 0x02,
  
++<<<<<<< HEAD
 +	/* inode/fs/bdev does not need truncate protection */
 +	DIO_IGNORE_TRUNCATE = 0x04,
++=======
+ 	/* filesystem can handle aio writes beyond i_size */
+ 	DIO_ASYNC_EXTEND = 0x04,
++>>>>>>> 6039257378e4 (direct-io: add flag to allow aio writes beyond i_size)
  };
  
  void dio_end_io(struct bio *bio, int error);
* Unmerged path fs/direct-io.c
* Unmerged path include/linux/fs.h
