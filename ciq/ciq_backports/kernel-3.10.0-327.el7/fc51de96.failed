i40e: Only enable TC0 for NIC partition type

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Neerav Parikh <neerav.parikh@intel.com>
commit fc51de96ed2f7fcefb99991200aac6710b769eba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/fc51de96.failed

In case of MFP mode the driver was returning incorrect number of TCs
for partitions that are not enabled for iSCSI. Though the driver does
not configure these TCs in the Tx scheduler for the NIC partitions;
it does use this map to setup the queue mappings.

This patch fixes this and keeps all the NIC partitions to the default
PF TC i.e. TC0.

Change-ID: Iede214c907e7bac1356e999049b9f642759512b3
	Signed-off-by: Neerav Parikh <neerav.parikh@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit fc51de96ed2f7fcefb99991200aac6710b769eba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_main.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_main.c
index 2c181081a1ad,31450f9ee1bf..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@@ -4088,18 -4099,23 +4088,31 @@@ static u8 i40e_pf_get_num_tc(struct i40
  	if (!(pf->flags & I40E_FLAG_DCB_ENABLED))
  		return 1;
  
 -	/* SFP mode will be enabled for all TCs on port */
 -	if (!(pf->flags & I40E_FLAG_MFP_ENABLED))
 -		return i40e_dcb_get_num_tc(dcbcfg);
 -
  	/* MFP mode return count of enabled TCs for this PF */
++<<<<<<< HEAD
 +	if (pf->flags & I40E_FLAG_MFP_ENABLED) {
 +		enabled_tc = pf->hw.func_caps.enabled_tcmap;
 +		for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {
 +			if (enabled_tc & (1 << i))
 +				num_tc++;
 +		}
 +		return num_tc;
++=======
+ 	if (pf->hw.func_caps.iscsi)
+ 		enabled_tc =  i40e_get_iscsi_tc_map(pf);
+ 	else
+ 		return 1; /* Only TC0 */
+ 
+ 	/* At least have TC0 */
+ 	enabled_tc = (enabled_tc ? enabled_tc : 0x1);
+ 	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {
+ 		if (enabled_tc & (1 << i))
+ 			num_tc++;
++>>>>>>> fc51de96ed2f (i40e: Only enable TC0 for NIC partition type)
  	}
 -	return num_tc;
 +
 +	/* SFP mode will be enabled for all TCs on port */
 +	return i40e_dcb_get_num_tc(dcbcfg);
  }
  
  /**
@@@ -4137,12 -4153,15 +4150,24 @@@ static u8 i40e_pf_get_tc_map(struct i40
  	if (!(pf->flags & I40E_FLAG_DCB_ENABLED))
  		return i40e_pf_get_default_tc(pf);
  
++<<<<<<< HEAD
 +	/* MFP mode will have enabled TCs set by FW */
 +	if (pf->flags & I40E_FLAG_MFP_ENABLED)
 +		return pf->hw.func_caps.enabled_tcmap;
 +
 +	/* SFP mode we want PF to be enabled for all TCs */
 +	return i40e_dcb_get_enabled_tc(&pf->hw.local_dcbx_config);
++=======
+ 	/* SFP mode we want PF to be enabled for all TCs */
+ 	if (!(pf->flags & I40E_FLAG_MFP_ENABLED))
+ 		return i40e_dcb_get_enabled_tc(&pf->hw.local_dcbx_config);
+ 
+ 	/* MFP enabled and iSCSI PF type */
+ 	if (pf->hw.func_caps.iscsi)
+ 		return i40e_get_iscsi_tc_map(pf);
+ 	else
+ 		return i40e_pf_get_default_tc(pf);
++>>>>>>> fc51de96ed2f (i40e: Only enable TC0 for NIC partition type)
  }
  
  /**
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_main.c
