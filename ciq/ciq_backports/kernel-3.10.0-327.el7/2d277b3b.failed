cxgb4: Added support in debugfs to display TP logic analyzer output

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Hariprasad Shenai <hariprasad@chelsio.com>
commit 2d277b3b44ede5c1812f5e49d2c8bdb7869f1661
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/2d277b3b.failed

Dump Transport Processor event trace.

	Signed-off-by: Hariprasad Shenai <hariprasad@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2d277b3b44ede5c1812f5e49d2c8bdb7869f1661)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
#	drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
#	drivers/net/ethernet/chelsio/cxgb4/t4_hw.h
diff --cc drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
index 500e399e494e,e82c0ba66d55..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
@@@ -4255,3 -4543,289 +4255,292 @@@ int t4_port_init(struct adapter *adap, 
  	}
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ 
+ /**
+  *	t4_read_cimq_cfg - read CIM queue configuration
+  *	@adap: the adapter
+  *	@base: holds the queue base addresses in bytes
+  *	@size: holds the queue sizes in bytes
+  *	@thres: holds the queue full thresholds in bytes
+  *
+  *	Returns the current configuration of the CIM queues, starting with
+  *	the IBQs, then the OBQs.
+  */
+ void t4_read_cimq_cfg(struct adapter *adap, u16 *base, u16 *size, u16 *thres)
+ {
+ 	unsigned int i, v;
+ 	int cim_num_obq = is_t4(adap->params.chip) ?
+ 				CIM_NUM_OBQ : CIM_NUM_OBQ_T5;
+ 
+ 	for (i = 0; i < CIM_NUM_IBQ; i++) {
+ 		t4_write_reg(adap, CIM_QUEUE_CONFIG_REF_A, IBQSELECT_F |
+ 			     QUENUMSELECT_V(i));
+ 		v = t4_read_reg(adap, CIM_QUEUE_CONFIG_CTRL_A);
+ 		/* value is in 256-byte units */
+ 		*base++ = CIMQBASE_G(v) * 256;
+ 		*size++ = CIMQSIZE_G(v) * 256;
+ 		*thres++ = QUEFULLTHRSH_G(v) * 8; /* 8-byte unit */
+ 	}
+ 	for (i = 0; i < cim_num_obq; i++) {
+ 		t4_write_reg(adap, CIM_QUEUE_CONFIG_REF_A, OBQSELECT_F |
+ 			     QUENUMSELECT_V(i));
+ 		v = t4_read_reg(adap, CIM_QUEUE_CONFIG_CTRL_A);
+ 		/* value is in 256-byte units */
+ 		*base++ = CIMQBASE_G(v) * 256;
+ 		*size++ = CIMQSIZE_G(v) * 256;
+ 	}
+ }
+ 
+ /**
+  *	t4_read_cim_ibq - read the contents of a CIM inbound queue
+  *	@adap: the adapter
+  *	@qid: the queue index
+  *	@data: where to store the queue contents
+  *	@n: capacity of @data in 32-bit words
+  *
+  *	Reads the contents of the selected CIM queue starting at address 0 up
+  *	to the capacity of @data.  @n must be a multiple of 4.  Returns < 0 on
+  *	error and the number of 32-bit words actually read on success.
+  */
+ int t4_read_cim_ibq(struct adapter *adap, unsigned int qid, u32 *data, size_t n)
+ {
+ 	int i, err, attempts;
+ 	unsigned int addr;
+ 	const unsigned int nwords = CIM_IBQ_SIZE * 4;
+ 
+ 	if (qid > 5 || (n & 3))
+ 		return -EINVAL;
+ 
+ 	addr = qid * nwords;
+ 	if (n > nwords)
+ 		n = nwords;
+ 
+ 	/* It might take 3-10ms before the IBQ debug read access is allowed.
+ 	 * Wait for 1 Sec with a delay of 1 usec.
+ 	 */
+ 	attempts = 1000000;
+ 
+ 	for (i = 0; i < n; i++, addr++) {
+ 		t4_write_reg(adap, CIM_IBQ_DBG_CFG_A, IBQDBGADDR_V(addr) |
+ 			     IBQDBGEN_F);
+ 		err = t4_wait_op_done(adap, CIM_IBQ_DBG_CFG_A, IBQDBGBUSY_F, 0,
+ 				      attempts, 1);
+ 		if (err)
+ 			return err;
+ 		*data++ = t4_read_reg(adap, CIM_IBQ_DBG_DATA_A);
+ 	}
+ 	t4_write_reg(adap, CIM_IBQ_DBG_CFG_A, 0);
+ 	return i;
+ }
+ 
+ /**
+  *	t4_read_cim_obq - read the contents of a CIM outbound queue
+  *	@adap: the adapter
+  *	@qid: the queue index
+  *	@data: where to store the queue contents
+  *	@n: capacity of @data in 32-bit words
+  *
+  *	Reads the contents of the selected CIM queue starting at address 0 up
+  *	to the capacity of @data.  @n must be a multiple of 4.  Returns < 0 on
+  *	error and the number of 32-bit words actually read on success.
+  */
+ int t4_read_cim_obq(struct adapter *adap, unsigned int qid, u32 *data, size_t n)
+ {
+ 	int i, err;
+ 	unsigned int addr, v, nwords;
+ 	int cim_num_obq = is_t4(adap->params.chip) ?
+ 				CIM_NUM_OBQ : CIM_NUM_OBQ_T5;
+ 
+ 	if ((qid > (cim_num_obq - 1)) || (n & 3))
+ 		return -EINVAL;
+ 
+ 	t4_write_reg(adap, CIM_QUEUE_CONFIG_REF_A, OBQSELECT_F |
+ 		     QUENUMSELECT_V(qid));
+ 	v = t4_read_reg(adap, CIM_QUEUE_CONFIG_CTRL_A);
+ 
+ 	addr = CIMQBASE_G(v) * 64;    /* muliple of 256 -> muliple of 4 */
+ 	nwords = CIMQSIZE_G(v) * 64;  /* same */
+ 	if (n > nwords)
+ 		n = nwords;
+ 
+ 	for (i = 0; i < n; i++, addr++) {
+ 		t4_write_reg(adap, CIM_OBQ_DBG_CFG_A, OBQDBGADDR_V(addr) |
+ 			     OBQDBGEN_F);
+ 		err = t4_wait_op_done(adap, CIM_OBQ_DBG_CFG_A, OBQDBGBUSY_F, 0,
+ 				      2, 1);
+ 		if (err)
+ 			return err;
+ 		*data++ = t4_read_reg(adap, CIM_OBQ_DBG_DATA_A);
+ 	}
+ 	t4_write_reg(adap, CIM_OBQ_DBG_CFG_A, 0);
+ 	return i;
+ }
+ 
+ /**
+  *	t4_cim_read - read a block from CIM internal address space
+  *	@adap: the adapter
+  *	@addr: the start address within the CIM address space
+  *	@n: number of words to read
+  *	@valp: where to store the result
+  *
+  *	Reads a block of 4-byte words from the CIM intenal address space.
+  */
+ int t4_cim_read(struct adapter *adap, unsigned int addr, unsigned int n,
+ 		unsigned int *valp)
+ {
+ 	int ret = 0;
+ 
+ 	if (t4_read_reg(adap, CIM_HOST_ACC_CTRL_A) & HOSTBUSY_F)
+ 		return -EBUSY;
+ 
+ 	for ( ; !ret && n--; addr += 4) {
+ 		t4_write_reg(adap, CIM_HOST_ACC_CTRL_A, addr);
+ 		ret = t4_wait_op_done(adap, CIM_HOST_ACC_CTRL_A, HOSTBUSY_F,
+ 				      0, 5, 2);
+ 		if (!ret)
+ 			*valp++ = t4_read_reg(adap, CIM_HOST_ACC_DATA_A);
+ 	}
+ 	return ret;
+ }
+ 
+ /**
+  *	t4_cim_write - write a block into CIM internal address space
+  *	@adap: the adapter
+  *	@addr: the start address within the CIM address space
+  *	@n: number of words to write
+  *	@valp: set of values to write
+  *
+  *	Writes a block of 4-byte words into the CIM intenal address space.
+  */
+ int t4_cim_write(struct adapter *adap, unsigned int addr, unsigned int n,
+ 		 const unsigned int *valp)
+ {
+ 	int ret = 0;
+ 
+ 	if (t4_read_reg(adap, CIM_HOST_ACC_CTRL_A) & HOSTBUSY_F)
+ 		return -EBUSY;
+ 
+ 	for ( ; !ret && n--; addr += 4) {
+ 		t4_write_reg(adap, CIM_HOST_ACC_DATA_A, *valp++);
+ 		t4_write_reg(adap, CIM_HOST_ACC_CTRL_A, addr | HOSTWRITE_F);
+ 		ret = t4_wait_op_done(adap, CIM_HOST_ACC_CTRL_A, HOSTBUSY_F,
+ 				      0, 5, 2);
+ 	}
+ 	return ret;
+ }
+ 
+ static int t4_cim_write1(struct adapter *adap, unsigned int addr,
+ 			 unsigned int val)
+ {
+ 	return t4_cim_write(adap, addr, 1, &val);
+ }
+ 
+ /**
+  *	t4_cim_read_la - read CIM LA capture buffer
+  *	@adap: the adapter
+  *	@la_buf: where to store the LA data
+  *	@wrptr: the HW write pointer within the capture buffer
+  *
+  *	Reads the contents of the CIM LA buffer with the most recent entry at
+  *	the end	of the returned data and with the entry at @wrptr first.
+  *	We try to leave the LA in the running state we find it in.
+  */
+ int t4_cim_read_la(struct adapter *adap, u32 *la_buf, unsigned int *wrptr)
+ {
+ 	int i, ret;
+ 	unsigned int cfg, val, idx;
+ 
+ 	ret = t4_cim_read(adap, UP_UP_DBG_LA_CFG_A, 1, &cfg);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (cfg & UPDBGLAEN_F) {	/* LA is running, freeze it */
+ 		ret = t4_cim_write1(adap, UP_UP_DBG_LA_CFG_A, 0);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	ret = t4_cim_read(adap, UP_UP_DBG_LA_CFG_A, 1, &val);
+ 	if (ret)
+ 		goto restart;
+ 
+ 	idx = UPDBGLAWRPTR_G(val);
+ 	if (wrptr)
+ 		*wrptr = idx;
+ 
+ 	for (i = 0; i < adap->params.cim_la_size; i++) {
+ 		ret = t4_cim_write1(adap, UP_UP_DBG_LA_CFG_A,
+ 				    UPDBGLARDPTR_V(idx) | UPDBGLARDEN_F);
+ 		if (ret)
+ 			break;
+ 		ret = t4_cim_read(adap, UP_UP_DBG_LA_CFG_A, 1, &val);
+ 		if (ret)
+ 			break;
+ 		if (val & UPDBGLARDEN_F) {
+ 			ret = -ETIMEDOUT;
+ 			break;
+ 		}
+ 		ret = t4_cim_read(adap, UP_UP_DBG_LA_DATA_A, 1, &la_buf[i]);
+ 		if (ret)
+ 			break;
+ 		idx = (idx + 1) & UPDBGLARDPTR_M;
+ 	}
+ restart:
+ 	if (cfg & UPDBGLAEN_F) {
+ 		int r = t4_cim_write1(adap, UP_UP_DBG_LA_CFG_A,
+ 				      cfg & ~UPDBGLARDEN_F);
+ 		if (!ret)
+ 			ret = r;
+ 	}
+ 	return ret;
+ }
+ 
+ /**
+  *	t4_tp_read_la - read TP LA capture buffer
+  *	@adap: the adapter
+  *	@la_buf: where to store the LA data
+  *	@wrptr: the HW write pointer within the capture buffer
+  *
+  *	Reads the contents of the TP LA buffer with the most recent entry at
+  *	the end	of the returned data and with the entry at @wrptr first.
+  *	We leave the LA in the running state we find it in.
+  */
+ void t4_tp_read_la(struct adapter *adap, u64 *la_buf, unsigned int *wrptr)
+ {
+ 	bool last_incomplete;
+ 	unsigned int i, cfg, val, idx;
+ 
+ 	cfg = t4_read_reg(adap, TP_DBG_LA_CONFIG_A) & 0xffff;
+ 	if (cfg & DBGLAENABLE_F)			/* freeze LA */
+ 		t4_write_reg(adap, TP_DBG_LA_CONFIG_A,
+ 			     adap->params.tp.la_mask | (cfg ^ DBGLAENABLE_F));
+ 
+ 	val = t4_read_reg(adap, TP_DBG_LA_CONFIG_A);
+ 	idx = DBGLAWPTR_G(val);
+ 	last_incomplete = DBGLAMODE_G(val) >= 2 && (val & DBGLAWHLF_F) == 0;
+ 	if (last_incomplete)
+ 		idx = (idx + 1) & DBGLARPTR_M;
+ 	if (wrptr)
+ 		*wrptr = idx;
+ 
+ 	val &= 0xffff;
+ 	val &= ~DBGLARPTR_V(DBGLARPTR_M);
+ 	val |= adap->params.tp.la_mask;
+ 
+ 	for (i = 0; i < TPLA_SIZE; i++) {
+ 		t4_write_reg(adap, TP_DBG_LA_CONFIG_A, DBGLARPTR_V(idx) | val);
+ 		la_buf[i] = t4_read_reg64(adap, TP_DBG_LA_DATAL_A);
+ 		idx = (idx + 1) & DBGLARPTR_M;
+ 	}
+ 
+ 	/* Wipe out last entry if it isn't valid */
+ 	if (last_incomplete)
+ 		la_buf[TPLA_SIZE - 1] = ~0ULL;
+ 
+ 	if (cfg & DBGLAENABLE_F)                    /* restore running state */
+ 		t4_write_reg(adap, TP_DBG_LA_CONFIG_A,
+ 			     cfg | adap->params.tp.la_mask);
+ }
++>>>>>>> 2d277b3b44ed (cxgb4: Added support in debugfs to display TP logic analyzer output)
diff --cc drivers/net/ethernet/chelsio/cxgb4/t4_hw.h
index c19a90e7f7d1,f0b98d7d74da..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.h
@@@ -56,6 -57,16 +56,19 @@@ enum 
  };
  
  enum {
++<<<<<<< HEAD
++=======
+ 	CIM_NUM_IBQ    = 6,     /* # of CIM IBQs */
+ 	CIM_NUM_OBQ    = 6,     /* # of CIM OBQs */
+ 	CIM_NUM_OBQ_T5 = 8,     /* # of CIM OBQs for T5 adapter */
+ 	CIMLA_SIZE     = 2048,  /* # of 32-bit words in CIM LA */
+ 	CIM_IBQ_SIZE   = 128,   /* # of 128-bit words in a CIM IBQ */
+ 	CIM_OBQ_SIZE   = 128,   /* # of 128-bit words in a CIM OBQ */
+ 	TPLA_SIZE      = 128,   /* # of 64-bit words in TP LA */
+ };
+ 
+ enum {
++>>>>>>> 2d277b3b44ed (cxgb4: Added support in debugfs to display TP logic analyzer output)
  	SF_PAGE_SIZE = 256,           /* serial flash page size */
  	SF_SEC_SIZE = 64 * 1024,      /* serial flash sector size */
  };
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
index 067eaa5ac000..f72586009ea7 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
@@ -231,6 +231,7 @@ struct sge_params {
 struct tp_params {
 	unsigned int ntxchan;        /* # of Tx channels */
 	unsigned int tre;            /* log2 of core clocks per TP tick */
+	unsigned int la_mask;        /* what events are recorded by TP LA */
 	unsigned short tx_modq_map;  /* TX modulation scheduler queue to */
 				     /* channel map */
 
@@ -1020,6 +1021,7 @@ void t4_get_port_stats(struct adapter *adap, int idx, struct port_stats *p);
 void t4_read_mtu_tbl(struct adapter *adap, u16 *mtus, u8 *mtu_log);
 void t4_tp_wr_bits_indirect(struct adapter *adap, unsigned int addr,
 			    unsigned int mask, unsigned int val);
+void t4_tp_read_la(struct adapter *adap, u64 *la_buf, unsigned int *wrptr);
 void t4_tp_get_tcp_stats(struct adapter *adap, struct tp_tcp_stats *v4,
 			 struct tp_tcp_stats *v6);
 void t4_load_mtus(struct adapter *adap, const unsigned short *mtus,
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/t4_hw.h
diff --git a/drivers/net/ethernet/chelsio/cxgb4/t4_regs.h b/drivers/net/ethernet/chelsio/cxgb4/t4_regs.h
index ca17cd6178d0..b1329229f446 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/t4_regs.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4_regs.h
@@ -640,9 +640,31 @@
 #define  RSVDSPACEINT     0x00000001U
 
 /* registers for module TP */
+#define DBGLAWHLF_S    23
+#define DBGLAWHLF_V(x) ((x) << DBGLAWHLF_S)
+#define DBGLAWHLF_F    DBGLAWHLF_V(1U)
+
+#define DBGLAWPTR_S    16
+#define DBGLAWPTR_M    0x7fU
+#define DBGLAWPTR_G(x) (((x) >> DBGLAWPTR_S) & DBGLAWPTR_M)
+
+#define DBGLAENABLE_S    12
+#define DBGLAENABLE_V(x) ((x) << DBGLAENABLE_S)
+#define DBGLAENABLE_F    DBGLAENABLE_V(1U)
+
+#define DBGLARPTR_S    0
+#define DBGLARPTR_M    0x7fU
+#define DBGLARPTR_V(x) ((x) << DBGLARPTR_S)
+
+#define TP_DBG_LA_DATAL_A	0x7ed8
+#define TP_DBG_LA_CONFIG_A	0x7ed4
 #define TP_OUT_CONFIG_A		0x7d04
 #define TP_GLOBAL_CONFIG_A	0x7d08
 
+#define DBGLAMODE_S	14
+#define DBGLAMODE_M	0x3U
+#define DBGLAMODE_G(x)	(((x) >> DBGLAMODE_S) & DBGLAMODE_M)
+
 #define FIVETUPLELOOKUP_S    17
 #define FIVETUPLELOOKUP_M    0x3U
 #define FIVETUPLELOOKUP_V(x) ((x) << FIVETUPLELOOKUP_S)
