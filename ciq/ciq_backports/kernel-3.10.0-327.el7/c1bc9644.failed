bonding: fix bond_3ad_set_carrier() RCU usage

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Veaceslav Falico <vfalico@redhat.com>
commit c1bc9644ecd1f663f918d42b33b41a508683b0ee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/c1bc9644.failed

Currently, its usage is just plainly wrong. It first gets a slave under
RCU, and, after releasing the RCU lock, continues to use it - whilst it can
be freed.

Fix this by ensuring that bond_3ad_set_carrier() holds RCU till it uses its
slave (or its agg).

Fixes: be79bd048ab ("bonding: add RCU for bond_3ad_state_machine_handler()")
CC: dingtianhong@huawei.com
CC: Jay Vosburgh <fubar@us.ibm.com>
CC: Andy Gospodarek <andy@greyhouse.net>
	Signed-off-by: Veaceslav Falico <vfalico@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c1bc9644ecd1f663f918d42b33b41a508683b0ee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_3ad.c
diff --cc drivers/net/bonding/bond_3ad.c
index dc508c87249d,da0d7c54d352..000000000000
--- a/drivers/net/bonding/bond_3ad.c
+++ b/drivers/net/bonding/bond_3ad.c
@@@ -2365,8 -2326,16 +2365,21 @@@ void bond_3ad_handle_link_change(struc
  int bond_3ad_set_carrier(struct bonding *bond)
  {
  	struct aggregator *active;
++<<<<<<< HEAD
 +
 +	active = __get_active_agg(&(SLAVE_AD_INFO(bond->first_slave).aggregator));
++=======
+ 	struct slave *first_slave;
+ 	int ret = 1;
+ 
+ 	rcu_read_lock();
+ 	first_slave = bond_first_slave_rcu(bond);
+ 	if (!first_slave) {
+ 		ret = 0;
+ 		goto out;
+ 	}
+ 	active = __get_active_agg(&(SLAVE_AD_INFO(first_slave).aggregator));
++>>>>>>> c1bc9644ecd1 (bonding: fix bond_3ad_set_carrier() RCU usage)
  	if (active) {
  		/* are enough slaves available to consider link up? */
  		if (active->num_of_ports < bond->params.min_links) {
* Unmerged path drivers/net/bonding/bond_3ad.c
