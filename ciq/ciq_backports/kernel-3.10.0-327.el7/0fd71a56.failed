mm: gup: add __get_user_pages_unlocked to customize gup_flags

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [mm] gup: add __get_user_pages_unlocked to customize gup_flags (Andrea Arcangeli) [965657]
Rebuild_FUZZ: 96.61%
commit-author Andrea Arcangeli <aarcange@redhat.com>
commit 0fd71a56f41d4ffabeda1dae9ff5ed4f34d4e935
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/0fd71a56.failed

Some callers (like KVM) may want to set the gup_flags like FOLL_HWPOSION
to get a proper -EHWPOSION retval instead of -EFAULT to take a more
appropriate action if get_user_pages runs into a memory failure.

	Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
	Reviewed-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Andres Lagar-Cavilla <andreslc@google.com>
	Cc: Peter Feiner <pfeiner@google.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 0fd71a56f41d4ffabeda1dae9ff5ed4f34d4e935)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mm.h
#	mm/gup.c
#	mm/nommu.c
diff --cc include/linux/mm.h
index 6ca7ff9955be,3696b3bd1d7e..000000000000
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@@ -1162,6 -1261,17 +1162,20 @@@ long get_user_pages(struct task_struct 
  		    unsigned long start, unsigned long nr_pages,
  		    int write, int force, struct page **pages,
  		    struct vm_area_struct **vmas);
++<<<<<<< HEAD
++=======
+ long get_user_pages_locked(struct task_struct *tsk, struct mm_struct *mm,
+ 		    unsigned long start, unsigned long nr_pages,
+ 		    int write, int force, struct page **pages,
+ 		    int *locked);
+ long __get_user_pages_unlocked(struct task_struct *tsk, struct mm_struct *mm,
+ 			       unsigned long start, unsigned long nr_pages,
+ 			       int write, int force, struct page **pages,
+ 			       unsigned int gup_flags);
+ long get_user_pages_unlocked(struct task_struct *tsk, struct mm_struct *mm,
+ 		    unsigned long start, unsigned long nr_pages,
+ 		    int write, int force, struct page **pages);
++>>>>>>> 0fd71a56f41d (mm: gup: add __get_user_pages_unlocked to customize gup_flags)
  int get_user_pages_fast(unsigned long start, int nr_pages, int write,
  			struct page **pages);
  struct kvec;
diff --cc mm/nommu.c
index a689e165e283,4d1b8a199867..000000000000
--- a/mm/nommu.c
+++ b/mm/nommu.c
@@@ -210,6 -214,39 +210,42 @@@ long get_user_pages(struct task_struct 
  }
  EXPORT_SYMBOL(get_user_pages);
  
++<<<<<<< HEAD
++=======
+ long get_user_pages_locked(struct task_struct *tsk, struct mm_struct *mm,
+ 			   unsigned long start, unsigned long nr_pages,
+ 			   int write, int force, struct page **pages,
+ 			   int *locked)
+ {
+ 	return get_user_pages(tsk, mm, start, nr_pages, write, force,
+ 			      pages, NULL);
+ }
+ EXPORT_SYMBOL(get_user_pages_locked);
+ 
+ long __get_user_pages_unlocked(struct task_struct *tsk, struct mm_struct *mm,
+ 			       unsigned long start, unsigned long nr_pages,
+ 			       int write, int force, struct page **pages,
+ 			       unsigned int gup_flags)
+ {
+ 	long ret;
+ 	down_read(&mm->mmap_sem);
+ 	ret = get_user_pages(tsk, mm, start, nr_pages, write, force,
+ 			     pages, NULL);
+ 	up_read(&mm->mmap_sem);
+ 	return ret;
+ }
+ EXPORT_SYMBOL(__get_user_pages_unlocked);
+ 
+ long get_user_pages_unlocked(struct task_struct *tsk, struct mm_struct *mm,
+ 			     unsigned long start, unsigned long nr_pages,
+ 			     int write, int force, struct page **pages)
+ {
+ 	return __get_user_pages_unlocked(tsk, mm, start, nr_pages, write,
+ 					 force, pages, 0);
+ }
+ EXPORT_SYMBOL(get_user_pages_unlocked);
+ 
++>>>>>>> 0fd71a56f41d (mm: gup: add __get_user_pages_unlocked to customize gup_flags)
  /**
   * follow_pfn - look up PFN at a user virtual address
   * @vma: memory mapping
* Unmerged path mm/gup.c
* Unmerged path include/linux/mm.h
* Unmerged path mm/gup.c
* Unmerged path mm/nommu.c
