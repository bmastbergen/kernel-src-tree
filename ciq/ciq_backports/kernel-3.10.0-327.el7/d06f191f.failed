md/raid5: introduce configuration option rmw_level

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [md] raid5: introduce configuration option rmw_level (Jes Sorensen) [1150149 1173510 1194720]
Rebuild_FUZZ: 96.91%
commit-author Markus Stockhausen <stockhausen@collogia.de>
commit d06f191f8ecaef4d524e765fdb455f96392fbd42
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/d06f191f.failed

Depending on the available coding we allow optimized rmw logic for write
operations. To support easier testing this patch allows manual control
of the rmw/rcw descision through the interface /sys/block/mdX/md/rmw_level.

The configuration can handle three levels of control.

rmw_level=0: Disable rmw for all RAID types. Hardware assisted P/Q
calculation has no implementation path yet to factor in/out chunks of
a syndrome. Enforcing this level can be benefical for slow CPUs with
hardware syndrome support and fast SSDs.

rmw_level=1: Estimate rmw IOs and rcw IOs. Execute rmw only if we will
save IOs. This equals the "old" unpatched behaviour and will be the
default.

rmw_level=2: Execute rmw even if calculated IOs for rmw and rcw are
equal. We might have higher CPU consumption because of calculating the
parity twice but it can be benefical otherwise. E.g. RAID4 with fast
dedicated parity disk/SSD. The option is implemented just to be
forward-looking and will ONLY work with this patch!

	Signed-off-by: Markus Stockhausen <stockhausen@collogia.de>
	Signed-off-by: NeilBrown <neilb@suse.de>
(cherry picked from commit d06f191f8ecaef4d524e765fdb455f96392fbd42)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/raid5.h
diff --cc drivers/md/raid5.h
index 14559becd035,6614ac5ffc0e..000000000000
--- a/drivers/md/raid5.h
+++ b/drivers/md/raid5.h
@@@ -355,6 -355,24 +355,27 @@@ enum 
  	STRIPE_OP_RECONSTRUCT,
  	STRIPE_OP_CHECK,
  };
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * RAID parity calculation preferences
+  */
+ enum {
+ 	PARITY_DISABLE_RMW = 0,
+ 	PARITY_ENABLE_RMW,
+ 	PARITY_PREFER_RMW,
+ };
+ 
+ /*
+  * Pages requested from set_syndrome_sources()
+  */
+ enum {
+ 	SYNDROME_SRC_ALL,
+ 	SYNDROME_SRC_WANT_DRAIN,
+ 	SYNDROME_SRC_WRITTEN,
+ };
++>>>>>>> d06f191f8eca (md/raid5: introduce configuration option rmw_level)
  /*
   * Plugging:
   *
diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c
index 971e6bd85606..a5c7d9933fdf 100644
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@ -5764,6 +5764,49 @@ raid5_stripecache_size = __ATTR(stripe_cache_size, S_IRUGO | S_IWUSR,
 				raid5_show_stripe_cache_size,
 				raid5_store_stripe_cache_size);
 
+static ssize_t
+raid5_show_rmw_level(struct mddev  *mddev, char *page)
+{
+	struct r5conf *conf = mddev->private;
+	if (conf)
+		return sprintf(page, "%d\n", conf->rmw_level);
+	else
+		return 0;
+}
+
+static ssize_t
+raid5_store_rmw_level(struct mddev  *mddev, const char *page, size_t len)
+{
+	struct r5conf *conf = mddev->private;
+	unsigned long new;
+
+	if (!conf)
+		return -ENODEV;
+
+	if (len >= PAGE_SIZE)
+		return -EINVAL;
+
+	if (kstrtoul(page, 10, &new))
+		return -EINVAL;
+
+	if (new != PARITY_DISABLE_RMW && !raid6_call.xor_syndrome)
+		return -EINVAL;
+
+	if (new != PARITY_DISABLE_RMW &&
+	    new != PARITY_ENABLE_RMW &&
+	    new != PARITY_PREFER_RMW)
+		return -EINVAL;
+
+	conf->rmw_level = new;
+	return len;
+}
+
+static struct md_sysfs_entry
+raid5_rmw_level = __ATTR(rmw_level, S_IRUGO | S_IWUSR,
+			 raid5_show_rmw_level,
+			 raid5_store_rmw_level);
+
+
 static ssize_t
 raid5_show_preread_threshold(struct mddev *mddev, char *page)
 {
@@ -5937,6 +5980,7 @@ static struct attribute *raid5_attrs[] =  {
 	&raid5_preread_bypass_threshold.attr,
 	&raid5_group_thread_cnt.attr,
 	&raid5_skip_copy.attr,
+	&raid5_rmw_level.attr,
 	NULL,
 };
 static struct attribute_group raid5_attrs_group = {
* Unmerged path drivers/md/raid5.h
