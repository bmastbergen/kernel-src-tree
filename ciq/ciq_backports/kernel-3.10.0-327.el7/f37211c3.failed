xfs: remove XFS_IFILESTREAM

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Christoph Hellwig <hch@lst.de>
commit f37211c336d722805493aec8b13afdbb92bbfd98
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/f37211c3.failed

We never test the flag except in xfs_inode_is_filestream, but that
function already tests the on-disk flag or filesystem wide flags,
and is used to decide if we want to set XFS_IFILESTREAM in the
first place.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit f37211c336d722805493aec8b13afdbb92bbfd98)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_filestream.c
diff --cc fs/xfs/xfs_filestream.c
index 12b6e7701985,c422110c7c43..000000000000
--- a/fs/xfs/xfs_filestream.c
+++ b/fs/xfs/xfs_filestream.c
@@@ -422,16 -424,12 +422,19 @@@ _xfs_filestream_update_ag
  /* xfs_fstrm_free_func(): callback for freeing cached stream items. */
  STATIC void
  xfs_fstrm_free_func(
 -	struct xfs_mru_cache_elem *mru)
 +	unsigned long	ino,
 +	void		*data)
  {
 -	fstrm_item_t	*item =
 -		container_of(mru, fstrm_item_t, mru);
 +	fstrm_item_t	*item  = (fstrm_item_t *)data;
  	xfs_inode_t	*ip = item->ip;
  
++<<<<<<< HEAD
 +	ASSERT(ip->i_ino == ino);
 +
 +	xfs_iflags_clear(ip, XFS_IFILESTREAM);
 +
++=======
++>>>>>>> f37211c336d7 (xfs: remove XFS_IFILESTREAM)
  	/* Drop the reference taken on the AG when the item was added. */
  	xfs_filestream_put_ag(ip->i_mount, item->ag);
  
* Unmerged path fs/xfs/xfs_filestream.c
diff --git a/fs/xfs/xfs_filestream.h b/fs/xfs/xfs_filestream.h
index 6d61dbee8564..c4fa9a0cd62f 100644
--- a/fs/xfs/xfs_filestream.h
+++ b/fs/xfs/xfs_filestream.h
@@ -63,7 +63,6 @@ xfs_inode_is_filestream(
 	struct xfs_inode	*ip)
 {
 	return (ip->i_mount->m_flags & XFS_MOUNT_FILESTREAMS) ||
-		xfs_iflags_test(ip, XFS_IFILESTREAM) ||
 		(ip->i_d.di_flags & XFS_DIFLAG_FILESTREAM);
 }
 
diff --git a/fs/xfs/xfs_inode.c b/fs/xfs/xfs_inode.c
index 5be5ff7bf7b6..f3ede064dba5 100644
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@ -847,8 +847,6 @@ xfs_ialloc(
 		error = xfs_filestream_associate(pip, ip);
 		if (error < 0)
 			return -error;
-		if (!error)
-			xfs_iflags_set(ip, XFS_IFILESTREAM);
 	}
 
 	*ipp = ip;
diff --git a/fs/xfs/xfs_inode.h b/fs/xfs/xfs_inode.h
index 5a7f81a958cd..7afdff9f8cd9 100644
--- a/fs/xfs/xfs_inode.h
+++ b/fs/xfs/xfs_inode.h
@@ -209,7 +209,6 @@ xfs_get_initial_prid(struct xfs_inode *dp)
 #define XFS_ISTALE		(1 << 1) /* inode has been staled */
 #define XFS_IRECLAIMABLE	(1 << 2) /* inode can be reclaimed */
 #define XFS_INEW		(1 << 3) /* inode has just been allocated */
-#define XFS_IFILESTREAM		(1 << 4) /* inode is in a filestream dir. */
 #define XFS_ITRUNCATED		(1 << 5) /* truncated down so flush-on-close */
 #define XFS_IDIRTY_RELEASE	(1 << 6) /* dirty release already seen */
 #define __XFS_IFLOCK_BIT	7	 /* inode is being flushed right now */
@@ -225,8 +224,7 @@ xfs_get_initial_prid(struct xfs_inode *dp)
  */
 #define XFS_IRECLAIM_RESET_FLAGS	\
 	(XFS_IRECLAIMABLE | XFS_IRECLAIM | \
-	 XFS_IDIRTY_RELEASE | XFS_ITRUNCATED | \
-	 XFS_IFILESTREAM);
+	 XFS_IDIRTY_RELEASE | XFS_ITRUNCATED)
 
 /*
  * Synchronize processes attempting to flush the in-core inode back to disk.
