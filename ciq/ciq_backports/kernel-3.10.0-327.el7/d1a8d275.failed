i40e: Strip VEB stats if they are disabled in HW

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Anjali Singhai Jain <anjali.singhai@intel.com>
commit d1a8d275340470b89fa3a3f7c47433caf1286336
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/d1a8d275.failed

Due to performance reasons, VEB stats have been disabled in the hw. This
patch adds code to check for that condition before accumulating these
stats.

Change-ID: I7d805669476fedabb073790403703798ae5d878e
	Signed-off-by: Anjali Singhai Jain <anjali.singhai@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit d1a8d275340470b89fa3a3f7c47433caf1286336)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e.h
diff --cc drivers/net/ethernet/intel/i40e/i40e.h
index c83dba47b11a,f6d97ad811bb..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e.h
+++ b/drivers/net/ethernet/intel/i40e/i40e.h
@@@ -289,35 -290,43 +289,47 @@@ struct i40e_pf 
  	struct work_struct service_task;
  
  	u64 flags;
 -#define I40E_FLAG_RX_CSUM_ENABLED		BIT_ULL(1)
 -#define I40E_FLAG_MSI_ENABLED			BIT_ULL(2)
 -#define I40E_FLAG_MSIX_ENABLED			BIT_ULL(3)
 -#define I40E_FLAG_RX_1BUF_ENABLED		BIT_ULL(4)
 -#define I40E_FLAG_RX_PS_ENABLED			BIT_ULL(5)
 -#define I40E_FLAG_RSS_ENABLED			BIT_ULL(6)
 -#define I40E_FLAG_VMDQ_ENABLED			BIT_ULL(7)
 -#define I40E_FLAG_FDIR_REQUIRES_REINIT		BIT_ULL(8)
 -#define I40E_FLAG_NEED_LINK_UPDATE		BIT_ULL(9)
 -#define I40E_FLAG_IWARP_ENABLED			BIT_ULL(10)
 +#define I40E_FLAG_RX_CSUM_ENABLED              (u64)(1 << 1)
 +#define I40E_FLAG_MSI_ENABLED                  (u64)(1 << 2)
 +#define I40E_FLAG_MSIX_ENABLED                 (u64)(1 << 3)
 +#define I40E_FLAG_RX_1BUF_ENABLED              (u64)(1 << 4)
 +#define I40E_FLAG_RX_PS_ENABLED                (u64)(1 << 5)
 +#define I40E_FLAG_RSS_ENABLED                  (u64)(1 << 6)
 +#define I40E_FLAG_VMDQ_ENABLED                 (u64)(1 << 7)
 +#define I40E_FLAG_FDIR_REQUIRES_REINIT         (u64)(1 << 8)
 +#define I40E_FLAG_NEED_LINK_UPDATE             (u64)(1 << 9)
  #ifdef I40E_FCOE
 -#define I40E_FLAG_FCOE_ENABLED			BIT_ULL(11)
 +#define I40E_FLAG_FCOE_ENABLED                 (u64)(1 << 11)
  #endif /* I40E_FCOE */
 -#define I40E_FLAG_IN_NETPOLL			BIT_ULL(12)
 -#define I40E_FLAG_16BYTE_RX_DESC_ENABLED	BIT_ULL(13)
 -#define I40E_FLAG_CLEAN_ADMINQ			BIT_ULL(14)
 -#define I40E_FLAG_FILTER_SYNC			BIT_ULL(15)
 -#define I40E_FLAG_PROCESS_MDD_EVENT		BIT_ULL(17)
 -#define I40E_FLAG_PROCESS_VFLR_EVENT		BIT_ULL(18)
 -#define I40E_FLAG_SRIOV_ENABLED			BIT_ULL(19)
 -#define I40E_FLAG_DCB_ENABLED			BIT_ULL(20)
 -#define I40E_FLAG_FD_SB_ENABLED			BIT_ULL(21)
 -#define I40E_FLAG_FD_ATR_ENABLED		BIT_ULL(22)
 -#define I40E_FLAG_PTP				BIT_ULL(25)
 -#define I40E_FLAG_MFP_ENABLED			BIT_ULL(26)
 +#define I40E_FLAG_IN_NETPOLL                   (u64)(1 << 12)
 +#define I40E_FLAG_16BYTE_RX_DESC_ENABLED       (u64)(1 << 13)
 +#define I40E_FLAG_CLEAN_ADMINQ                 (u64)(1 << 14)
 +#define I40E_FLAG_FILTER_SYNC                  (u64)(1 << 15)
 +#define I40E_FLAG_PROCESS_MDD_EVENT            (u64)(1 << 17)
 +#define I40E_FLAG_PROCESS_VFLR_EVENT           (u64)(1 << 18)
 +#define I40E_FLAG_SRIOV_ENABLED                (u64)(1 << 19)
 +#define I40E_FLAG_DCB_ENABLED                  (u64)(1 << 20)
 +#define I40E_FLAG_FD_SB_ENABLED                (u64)(1 << 21)
 +#define I40E_FLAG_FD_ATR_ENABLED               (u64)(1 << 22)
 +#define I40E_FLAG_PTP                          (u64)(1 << 25)
 +#define I40E_FLAG_MFP_ENABLED                  (u64)(1 << 26)
  #ifdef CONFIG_I40E_VXLAN
 -#define I40E_FLAG_VXLAN_FILTER_SYNC		BIT_ULL(27)
 +#define I40E_FLAG_VXLAN_FILTER_SYNC            (u64)(1 << 27)
  #endif
++<<<<<<< HEAD
 +#define I40E_FLAG_PORT_ID_VALID                (u64)(1 << 28)
 +#define I40E_FLAG_DCB_CAPABLE                  (u64)(1 << 29)
++=======
+ #define I40E_FLAG_PORT_ID_VALID			BIT_ULL(28)
+ #define I40E_FLAG_DCB_CAPABLE			BIT_ULL(29)
+ #define I40E_FLAG_RSS_AQ_CAPABLE		BIT_ULL(31)
+ #define I40E_FLAG_HW_ATR_EVICT_CAPABLE		BIT_ULL(32)
+ #define I40E_FLAG_OUTER_UDP_CSUM_CAPABLE	BIT_ULL(33)
+ #define I40E_FLAG_128_QP_RSS_CAPABLE		BIT_ULL(34)
+ #define I40E_FLAG_WB_ON_ITR_CAPABLE		BIT_ULL(35)
+ #define I40E_FLAG_VEB_STATS_ENABLED		BIT_ULL(37)
+ #define I40E_FLAG_MULTIPLE_TCP_UDP_RSS_PCTYPE	BIT_ULL(38)
++>>>>>>> d1a8d2753404 (i40e: Strip VEB stats if they are disabled in HW)
  #define I40E_FLAG_VEB_MODE_ENABLED		BIT_ULL(40)
  
  	/* tracks features that get auto disabled by errors */
* Unmerged path drivers/net/ethernet/intel/i40e/i40e.h
diff --git a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
index f35d4b08eb39..4ff32f2ff819 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
@@ -1257,7 +1257,8 @@ static int i40e_get_sset_count(struct net_device *netdev, int sset)
 		if (vsi == pf->vsi[pf->lan_vsi] && pf->hw.partition_id == 1) {
 			int len = I40E_PF_STATS_LEN(netdev);
 
-			if (pf->lan_veb != I40E_NO_VEB)
+			if ((pf->lan_veb != I40E_NO_VEB) &&
+			    (pf->flags & I40E_FLAG_VEB_STATS_ENABLED))
 				len += I40E_VEB_STATS_TOTAL;
 			return len;
 		} else {
@@ -1330,7 +1331,8 @@ static void i40e_get_ethtool_stats(struct net_device *netdev,
 	if (vsi != pf->vsi[pf->lan_vsi] || pf->hw.partition_id != 1)
 		return;
 
-	if (pf->lan_veb != I40E_NO_VEB) {
+	if ((pf->lan_veb != I40E_NO_VEB) &&
+	    (pf->flags & I40E_FLAG_VEB_STATS_ENABLED)) {
 		struct i40e_veb *veb = pf->veb[pf->lan_veb];
 		for (j = 0; j < I40E_VEB_STATS_LEN; j++) {
 			p = (char *)veb;
@@ -1403,7 +1405,8 @@ static void i40e_get_strings(struct net_device *netdev, u32 stringset,
 		if (vsi != pf->vsi[pf->lan_vsi] || pf->hw.partition_id != 1)
 			return;
 
-		if (pf->lan_veb != I40E_NO_VEB) {
+		if ((pf->lan_veb != I40E_NO_VEB) &&
+		    (pf->flags & I40E_FLAG_VEB_STATS_ENABLED)) {
 			for (i = 0; i < I40E_VEB_STATS_LEN; i++) {
 				snprintf(p, ETH_GSTRING_LEN, "veb.%s",
 					i40e_gstrings_veb_stats[i].stat_string);
diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c
index fb6e0828ac65..7db9082c64da 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@ -5820,10 +5820,12 @@ static void i40e_watchdog_subtask(struct i40e_pf *pf)
 		if (pf->vsi[i] && pf->vsi[i]->netdev)
 			i40e_update_stats(pf->vsi[i]);
 
-	/* Update the stats for the active switching components */
-	for (i = 0; i < I40E_MAX_VEB; i++)
-		if (pf->veb[i])
-			i40e_update_veb_stats(pf->veb[i]);
+	if (pf->flags & I40E_FLAG_VEB_STATS_ENABLED) {
+		/* Update the stats for the active switching components */
+		for (i = 0; i < I40E_MAX_VEB; i++)
+			if (pf->veb[i])
+				i40e_update_veb_stats(pf->veb[i]);
+	}
 
 	i40e_ptp_rx_hang(pf->vsi[pf->lan_vsi]);
 }
@@ -7807,6 +7809,9 @@ static int i40e_sw_init(struct i40e_pf *pf)
 	pf->lan_veb = I40E_NO_VEB;
 	pf->lan_vsi = I40E_NO_VSI;
 
+	/* By default FW has this off for performance reasons */
+	pf->flags &= ~I40E_FLAG_VEB_STATS_ENABLED;
+
 	/* set up queue assignment tracking */
 	size = sizeof(struct i40e_lump_tracking)
 		+ (sizeof(u16) * pf->hw.func_caps.num_tx_qp);
