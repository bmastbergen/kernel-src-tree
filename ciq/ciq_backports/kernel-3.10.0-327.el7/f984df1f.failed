blk-mq: do limited block plug for multiple queue case

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Shaohua Li <shli@fb.com>
commit f984df1f0f71ef96254411fc3576a10ae561be71
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/f984df1f.failed

plug is still helpful for workload with IO merge, but it can be harmful
otherwise especially with multiple hardware queues, as there is
(supposed) no lock contention in this case and plug can introduce
latency. For multiple queues, we do limited plug, eg plug only if there
is request merge. If a request doesn't have merge with following
request, the requet will be dispatched immediately.

V2: check blk_queue_nomerges() as suggested by Jeff.

	Cc: Jens Axboe <axboe@fb.com>
	Cc: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Shaohua Li <shli@fb.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit f984df1f0f71ef96254411fc3576a10ae561be71)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq.c
diff --cc block/blk-mq.c
index 5f9ca0666f29,902c2eb9a0e7..000000000000
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@@ -1219,30 -1291,39 +1257,57 @@@ static void blk_mq_make_request(struct 
  		goto run_queue;
  	}
  
++<<<<<<< HEAD
 +	if (is_sync) {
 +		int ret;
++=======
+ 	plug = current->plug;
+ 	/*
+ 	 * If the driver supports defer issued based on 'last', then
+ 	 * queue it up like normal since we can potentially save some
+ 	 * CPU this way.
+ 	 */
+ 	if (((plug && !blk_queue_nomerges(q)) || is_sync) &&
+ 	    !(data.hctx->flags & BLK_MQ_F_DEFER_ISSUE)) {
+ 		struct request *old_rq = NULL;
++>>>>>>> f984df1f0f71 (blk-mq: do limited block plug for multiple queue case)
  
  		blk_mq_bio_to_request(rq, bio);
  
  		/*
- 		 * For OK queue, we are done. For error, kill it. Any other
- 		 * error (busy), just add it to our list as we previously
- 		 * would have done
+ 		 * we do limited pluging. If bio can be merged, do merge.
+ 		 * Otherwise the existing request in the plug list will be
+ 		 * issued. So the plug list will have one request at most
  		 */
++<<<<<<< HEAD
 +		ret = q->mq_ops->queue_rq(data.hctx, rq, true);
 +		if (ret == BLK_MQ_RQ_QUEUE_OK)
 +			goto done;
 +		else {
 +			__blk_mq_requeue_request(rq);
 +
 +			if (ret == BLK_MQ_RQ_QUEUE_ERROR) {
 +				rq->errors = -EIO;
 +				blk_mq_end_request(rq, rq->errors);
 +				goto done;
++=======
+ 		if (plug) {
+ 			if (!list_empty(&plug->mq_list)) {
+ 				old_rq = list_first_entry(&plug->mq_list,
+ 					struct request, queuelist);
+ 				list_del_init(&old_rq->queuelist);
++>>>>>>> f984df1f0f71 (blk-mq: do limited block plug for multiple queue case)
  			}
- 			blk_mq_insert_request(rq, false, true, true);
+ 			list_add_tail(&rq->queuelist, &plug->mq_list);
+ 		} else /* is_sync */
+ 			old_rq = rq;
+ 		blk_mq_put_ctx(data.ctx);
+ 		if (!old_rq)
  			return;
- 		}
+ 		if (!blk_mq_direct_issue_request(old_rq))
+ 			return;
+ 		blk_mq_insert_request(old_rq, false, true, true);
+ 		return;
  	}
  
  	if (!blk_mq_merge_queue_io(data.hctx, data.ctx, rq, bio)) {
* Unmerged path block/blk-mq.c
