bonding: convert active_slave to use the new option API

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Nikolay Aleksandrov <nikolay@redhat.com>
commit d1fbd3ed9366904b58b1c0c30b22d51dc793de99
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/d1fbd3ed.failed

This patch adds the necessary changes so active_slave would use
the new bonding option API. Also some trivial/style fixes.

	Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d1fbd3ed9366904b58b1c0c30b22d51dc793de99)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_options.c
#	drivers/net/bonding/bond_options.h
#	drivers/net/bonding/bond_sysfs.c
#	drivers/net/bonding/bonding.h
diff --cc drivers/net/bonding/bond_sysfs.c
index 9519d678a368,181a59d7241e..000000000000
--- a/drivers/net/bonding/bond_sysfs.c
+++ b/drivers/net/bonding/bond_sysfs.c
@@@ -1282,83 -809,14 +1282,94 @@@ static ssize_t bonding_store_active_sla
  					  struct device_attribute *attr,
  					  const char *buf, size_t count)
  {
++<<<<<<< HEAD
 +	int i;
 +	struct slave *slave;
 +	struct slave *old_active = NULL;
 +	struct slave *new_active = NULL;
 +	struct bonding *bond = to_bond(d);
 +	char ifname[IFNAMSIZ];
 +
 +	if (!rtnl_trylock())
 +		return restart_syscall();
 +
 +	block_netpoll_tx();
 +	read_lock(&bond->lock);
 +	write_lock_bh(&bond->curr_slave_lock);
 +
 +	if (!USES_PRIMARY(bond->params.mode)) {
 +		pr_info("%s: Unable to change active slave; %s is in mode %d\n",
 +			bond->dev->name, bond->dev->name, bond->params.mode);
 +		goto out;
 +	}
 +
 +	sscanf(buf, "%15s", ifname); /* IFNAMSIZ */
 +
 +	/* check to see if we are clearing active */
 +	if (!strlen(ifname) || buf[0] == '\n') {
 +		pr_info("%s: Clearing current active slave.\n",
 +			bond->dev->name);
 +		bond->curr_active_slave = NULL;
 +		bond_select_active_slave(bond);
 +		goto out;
 +	}
 +
 +	bond_for_each_slave(bond, slave, i) {
 +		if (strncmp(slave->dev->name, ifname, IFNAMSIZ) == 0) {
 +			old_active = bond->curr_active_slave;
 +			new_active = slave;
 +			if (new_active == old_active) {
 +				/* do nothing */
 +				pr_info("%s: %s is already the current"
 +					" active slave.\n",
 +					bond->dev->name,
 +					slave->dev->name);
 +				goto out;
 +			} else {
 +				if ((new_active) &&
 +				    (old_active) &&
 +				    (new_active->link == BOND_LINK_UP) &&
 +				    IS_UP(new_active->dev)) {
 +					pr_info("%s: Setting %s as active"
 +						" slave.\n",
 +						bond->dev->name,
 +						slave->dev->name);
 +					bond_change_active_slave(bond,
 +								 new_active);
 +				} else {
 +					pr_info("%s: Could not set %s as"
 +						" active slave; either %s is"
 +						" down or the link is down.\n",
 +						bond->dev->name,
 +						slave->dev->name,
 +						slave->dev->name);
 +				}
 +				goto out;
 +			}
 +		}
 +	}
 +
 +	pr_info("%s: Unable to set %.*s as active slave.\n",
 +		bond->dev->name, (int)strlen(buf) - 1, buf);
 + out:
 +	write_unlock_bh(&bond->curr_slave_lock);
 +	read_unlock(&bond->lock);
 +	unblock_netpoll_tx();
 +
 +	rtnl_unlock();
 +
 +	return count;
 +
++=======
+ 	struct bonding *bond = to_bond(d);
+ 	int ret;
+ 
+ 	ret = bond_opt_tryset_rtnl(bond, BOND_OPT_ACTIVE_SLAVE, (char *)buf);
+ 	if (!ret)
+ 		ret = count;
+ 
+ 	return ret;
++>>>>>>> d1fbd3ed9366 (bonding: convert active_slave to use the new option API)
  }
  static DEVICE_ATTR(active_slave, S_IRUGO | S_IWUSR,
  		   bonding_show_active_slave, bonding_store_active_slave);
diff --cc drivers/net/bonding/bonding.h
index 6097f0c04b95,4ac79e1dd78f..000000000000
--- a/drivers/net/bonding/bonding.h
+++ b/drivers/net/bonding/bonding.h
@@@ -442,6 -452,15 +442,18 @@@ void bond_setup(struct net_device *bond
  unsigned int bond_get_num_tx_queues(void);
  int bond_netlink_init(void);
  void bond_netlink_fini(void);
++<<<<<<< HEAD
++=======
+ int bond_option_arp_ip_target_add(struct bonding *bond, __be32 target);
+ int bond_option_arp_ip_target_rem(struct bonding *bond, __be32 target);
+ int bond_option_resend_igmp_set(struct bonding *bond, int resend_igmp);
+ int bond_option_all_slaves_active_set(struct bonding *bond,
+ 				      int all_slaves_active);
+ int bond_option_lp_interval_set(struct bonding *bond, int min_links);
+ struct net_device *bond_option_active_slave_get_rcu(struct bonding *bond);
+ struct net_device *bond_option_active_slave_get(struct bonding *bond);
+ const char *bond_slave_link_status(s8 link);
++>>>>>>> d1fbd3ed9366 (bonding: convert active_slave to use the new option API)
  
  struct bond_net {
  	struct net *		net;	/* Associated network namespace */
* Unmerged path drivers/net/bonding/bond_options.c
* Unmerged path drivers/net/bonding/bond_options.h
diff --git a/drivers/net/bonding/bond_main.c b/drivers/net/bonding/bond_main.c
index 38a1c7877edd..a09a3f0a6954 100644
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@ -3462,6 +3462,7 @@ static int bond_do_ioctl(struct net_device *bond_dev, struct ifreq *ifr, int cmd
 	struct ifslave k_sinfo;
 	struct ifslave __user *u_sinfo = NULL;
 	struct mii_ioctl_data *mii = NULL;
+	struct bond_opt_value newval;
 	struct net *net;
 	int res = 0;
 
@@ -3557,7 +3558,8 @@ static int bond_do_ioctl(struct net_device *bond_dev, struct ifreq *ifr, int cmd
 		break;
 	case BOND_CHANGE_ACTIVE_OLD:
 	case SIOCBONDCHANGEACTIVE:
-		res = bond_option_active_slave_set(bond, slave_dev);
+		bond_opt_initstr(&newval, slave_dev->name);
+		res = __bond_opt_set(bond, BOND_OPT_ACTIVE_SLAVE, &newval);
 		break;
 	default:
 		res = -EOPNOTSUPP;
diff --git a/drivers/net/bonding/bond_netlink.c b/drivers/net/bonding/bond_netlink.c
index 40e7b1cb4aea..90dead6825ce 100644
--- a/drivers/net/bonding/bond_netlink.c
+++ b/drivers/net/bonding/bond_netlink.c
@@ -52,16 +52,17 @@ static int bond_changelink(struct net_device *bond_dev,
 	if (data && data[IFLA_BOND_ACTIVE_SLAVE]) {
 		int ifindex = nla_get_u32(data[IFLA_BOND_ACTIVE_SLAVE]);
 		struct net_device *slave_dev;
+		char *active_slave = "";
 
-		if (ifindex == 0) {
-			slave_dev = NULL;
-		} else {
+		if (ifindex != 0) {
 			slave_dev = __dev_get_by_index(dev_net(bond_dev),
 						       ifindex);
 			if (!slave_dev)
 				return -ENODEV;
+			active_slave = slave_dev->name;
 		}
-		err = bond_option_active_slave_set(bond, slave_dev);
+		bond_opt_initstr(&newval, active_slave);
+		err = __bond_opt_set(bond, BOND_OPT_ACTIVE_SLAVE, &newval);
 		if (err)
 			return err;
 	}
* Unmerged path drivers/net/bonding/bond_options.c
* Unmerged path drivers/net/bonding/bond_options.h
* Unmerged path drivers/net/bonding/bond_sysfs.c
* Unmerged path drivers/net/bonding/bonding.h
