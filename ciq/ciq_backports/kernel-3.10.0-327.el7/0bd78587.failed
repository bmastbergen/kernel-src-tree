powerpc/eeh: Replace device_node with pci_dn in eeh_ops

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [powerpc] eeh: Replace device_node with pci_dn in eeh_ops (Laurent Vivier) [1213675]
Rebuild_FUZZ: 92.16%
commit-author Gavin Shan <gwshan@linux.vnet.ibm.com>
commit 0bd785873c6a6c9bd50d2ae19862f69ee5759fb9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/0bd78587.failed

There are 3 EEH operations whose arguments contain device_node:
read_config(), write_config() and restore_config(). The patch
replaces device_node with pci_dn.

	Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
	Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
(cherry picked from commit 0bd785873c6a6c9bd50d2ae19862f69ee5759fb9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/eeh.c
#	arch/powerpc/platforms/powernv/eeh-powernv.c
diff --cc arch/powerpc/kernel/eeh.c
index 6021b67a433c,1fd2566c87f1..000000000000
--- a/arch/powerpc/kernel/eeh.c
+++ b/arch/powerpc/kernel/eeh.c
@@@ -664,6 -671,55 +668,58 @@@ int eeh_pci_enable(struct eeh_pe *pe, i
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ static void *eeh_disable_and_save_dev_state(void *data, void *userdata)
+ {
+ 	struct eeh_dev *edev = data;
+ 	struct pci_dev *pdev = eeh_dev_to_pci_dev(edev);
+ 	struct pci_dev *dev = userdata;
+ 
+ 	/*
+ 	 * The caller should have disabled and saved the
+ 	 * state for the specified device
+ 	 */
+ 	if (!pdev || pdev == dev)
+ 		return NULL;
+ 
+ 	/* Ensure we have D0 power state */
+ 	pci_set_power_state(pdev, PCI_D0);
+ 
+ 	/* Save device state */
+ 	pci_save_state(pdev);
+ 
+ 	/*
+ 	 * Disable device to avoid any DMA traffic and
+ 	 * interrupt from the device
+ 	 */
+ 	pci_write_config_word(pdev, PCI_COMMAND, PCI_COMMAND_INTX_DISABLE);
+ 
+ 	return NULL;
+ }
+ 
+ static void *eeh_restore_dev_state(void *data, void *userdata)
+ {
+ 	struct eeh_dev *edev = data;
+ 	struct pci_dn *pdn = eeh_dev_to_pdn(edev);
+ 	struct pci_dev *pdev = eeh_dev_to_pci_dev(edev);
+ 	struct pci_dev *dev = userdata;
+ 
+ 	if (!pdev)
+ 		return NULL;
+ 
+ 	/* Apply customization from firmware */
+ 	if (pdn && eeh_ops->restore_config)
+ 		eeh_ops->restore_config(pdn);
+ 
+ 	/* The caller should restore state for the specified device */
+ 	if (pdev != dev)
+ 		pci_save_state(pdev);
+ 
+ 	return NULL;
+ }
+ 
++>>>>>>> 0bd785873c6a (powerpc/eeh: Replace device_node with pci_dn in eeh_ops)
  /**
   * pcibios_set_pcie_slot_reset - Set PCI-E reset state
   * @dev: pci device struct
diff --cc arch/powerpc/platforms/powernv/eeh-powernv.c
index 86e8f8e66097,ce738ab3d5a9..000000000000
--- a/arch/powerpc/platforms/powernv/eeh-powernv.c
+++ b/arch/powerpc/platforms/powernv/eeh-powernv.c
@@@ -402,8 -742,171 +402,174 @@@ static int powernv_eeh_get_state(struc
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static s64 pnv_eeh_phb_poll(struct pnv_phb *phb)
+ {
+ 	s64 rc = OPAL_HARDWARE;
+ 
+ 	while (1) {
+ 		rc = opal_pci_poll(phb->opal_id);
+ 		if (rc <= 0)
+ 			break;
+ 
+ 		if (system_state < SYSTEM_RUNNING)
+ 			udelay(1000 * rc);
+ 		else
+ 			msleep(rc);
+ 	}
+ 
+ 	return rc;
+ }
+ 
+ int pnv_eeh_phb_reset(struct pci_controller *hose, int option)
+ {
+ 	struct pnv_phb *phb = hose->private_data;
+ 	s64 rc = OPAL_HARDWARE;
+ 
+ 	pr_debug("%s: Reset PHB#%x, option=%d\n",
+ 		 __func__, hose->global_number, option);
+ 
+ 	/* Issue PHB complete reset request */
+ 	if (option == EEH_RESET_FUNDAMENTAL ||
+ 	    option == EEH_RESET_HOT)
+ 		rc = opal_pci_reset(phb->opal_id,
+ 				    OPAL_RESET_PHB_COMPLETE,
+ 				    OPAL_ASSERT_RESET);
+ 	else if (option == EEH_RESET_DEACTIVATE)
+ 		rc = opal_pci_reset(phb->opal_id,
+ 				    OPAL_RESET_PHB_COMPLETE,
+ 				    OPAL_DEASSERT_RESET);
+ 	if (rc < 0)
+ 		goto out;
+ 
+ 	/*
+ 	 * Poll state of the PHB until the request is done
+ 	 * successfully. The PHB reset is usually PHB complete
+ 	 * reset followed by hot reset on root bus. So we also
+ 	 * need the PCI bus settlement delay.
+ 	 */
+ 	rc = pnv_eeh_phb_poll(phb);
+ 	if (option == EEH_RESET_DEACTIVATE) {
+ 		if (system_state < SYSTEM_RUNNING)
+ 			udelay(1000 * EEH_PE_RST_SETTLE_TIME);
+ 		else
+ 			msleep(EEH_PE_RST_SETTLE_TIME);
+ 	}
+ out:
+ 	if (rc != OPAL_SUCCESS)
+ 		return -EIO;
+ 
+ 	return 0;
+ }
+ 
+ static int pnv_eeh_root_reset(struct pci_controller *hose, int option)
+ {
+ 	struct pnv_phb *phb = hose->private_data;
+ 	s64 rc = OPAL_HARDWARE;
+ 
+ 	pr_debug("%s: Reset PHB#%x, option=%d\n",
+ 		 __func__, hose->global_number, option);
+ 
+ 	/*
+ 	 * During the reset deassert time, we needn't care
+ 	 * the reset scope because the firmware does nothing
+ 	 * for fundamental or hot reset during deassert phase.
+ 	 */
+ 	if (option == EEH_RESET_FUNDAMENTAL)
+ 		rc = opal_pci_reset(phb->opal_id,
+ 				    OPAL_RESET_PCI_FUNDAMENTAL,
+ 				    OPAL_ASSERT_RESET);
+ 	else if (option == EEH_RESET_HOT)
+ 		rc = opal_pci_reset(phb->opal_id,
+ 				    OPAL_RESET_PCI_HOT,
+ 				    OPAL_ASSERT_RESET);
+ 	else if (option == EEH_RESET_DEACTIVATE)
+ 		rc = opal_pci_reset(phb->opal_id,
+ 				    OPAL_RESET_PCI_HOT,
+ 				    OPAL_DEASSERT_RESET);
+ 	if (rc < 0)
+ 		goto out;
+ 
+ 	/* Poll state of the PHB until the request is done */
+ 	rc = pnv_eeh_phb_poll(phb);
+ 	if (option == EEH_RESET_DEACTIVATE)
+ 		msleep(EEH_PE_RST_SETTLE_TIME);
+ out:
+ 	if (rc != OPAL_SUCCESS)
+ 		return -EIO;
+ 
+ 	return 0;
+ }
+ 
+ static int pnv_eeh_bridge_reset(struct pci_dev *dev, int option)
+ {
+ 	struct pci_dn *pdn = pci_get_pdn_by_devfn(dev->bus, dev->devfn);
+ 	struct eeh_dev *edev = pdn_to_eeh_dev(pdn);
+ 	int aer = edev ? edev->aer_cap : 0;
+ 	u32 ctrl;
+ 
+ 	pr_debug("%s: Reset PCI bus %04x:%02x with option %d\n",
+ 		 __func__, pci_domain_nr(dev->bus),
+ 		 dev->bus->number, option);
+ 
+ 	switch (option) {
+ 	case EEH_RESET_FUNDAMENTAL:
+ 	case EEH_RESET_HOT:
+ 		/* Don't report linkDown event */
+ 		if (aer) {
+ 			eeh_ops->read_config(pdn, aer + PCI_ERR_UNCOR_MASK,
+ 					     4, &ctrl);
+ 			ctrl |= PCI_ERR_UNC_SURPDN;
+ 			eeh_ops->write_config(pdn, aer + PCI_ERR_UNCOR_MASK,
+ 					      4, ctrl);
+ 		}
+ 
+ 		eeh_ops->read_config(pdn, PCI_BRIDGE_CONTROL, 2, &ctrl);
+ 		ctrl |= PCI_BRIDGE_CTL_BUS_RESET;
+ 		eeh_ops->write_config(pdn, PCI_BRIDGE_CONTROL, 2, ctrl);
+ 
+ 		msleep(EEH_PE_RST_HOLD_TIME);
+ 		break;
+ 	case EEH_RESET_DEACTIVATE:
+ 		eeh_ops->read_config(pdn, PCI_BRIDGE_CONTROL, 2, &ctrl);
+ 		ctrl &= ~PCI_BRIDGE_CTL_BUS_RESET;
+ 		eeh_ops->write_config(pdn, PCI_BRIDGE_CONTROL, 2, ctrl);
+ 
+ 		msleep(EEH_PE_RST_SETTLE_TIME);
+ 
+ 		/* Continue reporting linkDown event */
+ 		if (aer) {
+ 			eeh_ops->read_config(pdn, aer + PCI_ERR_UNCOR_MASK,
+ 					     4, &ctrl);
+ 			ctrl &= ~PCI_ERR_UNC_SURPDN;
+ 			eeh_ops->write_config(pdn, aer + PCI_ERR_UNCOR_MASK,
+ 					      4, ctrl);
+ 		}
+ 
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ void pnv_pci_reset_secondary_bus(struct pci_dev *dev)
+ {
+ 	struct pci_controller *hose;
+ 
+ 	if (pci_is_root_bus(dev->bus)) {
+ 		hose = pci_bus_to_host(dev->bus);
+ 		pnv_eeh_root_reset(hose, EEH_RESET_HOT);
+ 		pnv_eeh_root_reset(hose, EEH_RESET_DEACTIVATE);
+ 	} else {
+ 		pnv_eeh_bridge_reset(dev, EEH_RESET_HOT);
+ 		pnv_eeh_bridge_reset(dev, EEH_RESET_DEACTIVATE);
+ 	}
+ }
+ 
++>>>>>>> 0bd785873c6a (powerpc/eeh: Replace device_node with pci_dn in eeh_ops)
  /**
 - * pnv_eeh_reset - Reset the specified PE
 + * powernv_eeh_reset - Reset the specified PE
   * @pe: EEH PE
   * @option: reset option
   *
@@@ -544,9 -1099,9 +710,13 @@@ static int powernv_eeh_err_inject(struc
  	return 0;
  }
  
++<<<<<<< HEAD
 +static inline bool powernv_eeh_cfg_blocked(struct device_node *dn)
++=======
+ static inline bool pnv_eeh_cfg_blocked(struct pci_dn *pdn)
++>>>>>>> 0bd785873c6a (powerpc/eeh: Replace device_node with pci_dn in eeh_ops)
  {
- 	struct eeh_dev *edev = of_node_to_eeh_dev(dn);
+ 	struct eeh_dev *edev = pdn_to_eeh_dev(pdn);
  
  	if (!edev || !edev->pe)
  		return false;
@@@ -557,51 -1112,377 +727,75 @@@
  	return false;
  }
  
++<<<<<<< HEAD
 +static int powernv_eeh_read_config(struct device_node *dn,
 +				   int where, int size, u32 *val)
 +{
 +	if (powernv_eeh_cfg_blocked(dn)) {
++=======
+ static int pnv_eeh_read_config(struct pci_dn *pdn,
+ 			       int where, int size, u32 *val)
+ {
+ 	if (!pdn)
+ 		return PCIBIOS_DEVICE_NOT_FOUND;
+ 
+ 	if (pnv_eeh_cfg_blocked(pdn)) {
++>>>>>>> 0bd785873c6a (powerpc/eeh: Replace device_node with pci_dn in eeh_ops)
  		*val = 0xFFFFFFFF;
  		return PCIBIOS_SET_FAILED;
  	}
  
 -	return pnv_pci_cfg_read(pdn, where, size, val);
 +	return pnv_pci_cfg_read(dn, where, size, val);
  }
  
++<<<<<<< HEAD
 +static int powernv_eeh_write_config(struct device_node *dn,
 +				    int where, int size, u32 val)
 +{
 +	if (powernv_eeh_cfg_blocked(dn))
++=======
+ static int pnv_eeh_write_config(struct pci_dn *pdn,
+ 				int where, int size, u32 val)
+ {
+ 	if (!pdn)
+ 		return PCIBIOS_DEVICE_NOT_FOUND;
+ 
+ 	if (pnv_eeh_cfg_blocked(pdn))
++>>>>>>> 0bd785873c6a (powerpc/eeh: Replace device_node with pci_dn in eeh_ops)
  		return PCIBIOS_SET_FAILED;
  
 -	return pnv_pci_cfg_write(pdn, where, size, val);
 -}
 -
 -static void pnv_eeh_dump_hub_diag_common(struct OpalIoP7IOCErrorData *data)
 -{
 -	/* GEM */
 -	if (data->gemXfir || data->gemRfir ||
 -	    data->gemRirqfir || data->gemMask || data->gemRwof)
 -		pr_info("  GEM: %016llx %016llx %016llx %016llx %016llx\n",
 -			be64_to_cpu(data->gemXfir),
 -			be64_to_cpu(data->gemRfir),
 -			be64_to_cpu(data->gemRirqfir),
 -			be64_to_cpu(data->gemMask),
 -			be64_to_cpu(data->gemRwof));
 -
 -	/* LEM */
 -	if (data->lemFir || data->lemErrMask ||
 -	    data->lemAction0 || data->lemAction1 || data->lemWof)
 -		pr_info("  LEM: %016llx %016llx %016llx %016llx %016llx\n",
 -			be64_to_cpu(data->lemFir),
 -			be64_to_cpu(data->lemErrMask),
 -			be64_to_cpu(data->lemAction0),
 -			be64_to_cpu(data->lemAction1),
 -			be64_to_cpu(data->lemWof));
 -}
 -
 -static void pnv_eeh_get_and_dump_hub_diag(struct pci_controller *hose)
 -{
 -	struct pnv_phb *phb = hose->private_data;
 -	struct OpalIoP7IOCErrorData *data = &phb->diag.hub_diag;
 -	long rc;
 -
 -	rc = opal_pci_get_hub_diag_data(phb->hub_id, data, sizeof(*data));
 -	if (rc != OPAL_SUCCESS) {
 -		pr_warn("%s: Failed to get HUB#%llx diag-data (%ld)\n",
 -			__func__, phb->hub_id, rc);
 -		return;
 -	}
 -
 -	switch (data->type) {
 -	case OPAL_P7IOC_DIAG_TYPE_RGC:
 -		pr_info("P7IOC diag-data for RGC\n\n");
 -		pnv_eeh_dump_hub_diag_common(data);
 -		if (data->rgc.rgcStatus || data->rgc.rgcLdcp)
 -			pr_info("  RGC: %016llx %016llx\n",
 -				be64_to_cpu(data->rgc.rgcStatus),
 -				be64_to_cpu(data->rgc.rgcLdcp));
 -		break;
 -	case OPAL_P7IOC_DIAG_TYPE_BI:
 -		pr_info("P7IOC diag-data for BI %s\n\n",
 -			data->bi.biDownbound ? "Downbound" : "Upbound");
 -		pnv_eeh_dump_hub_diag_common(data);
 -		if (data->bi.biLdcp0 || data->bi.biLdcp1 ||
 -		    data->bi.biLdcp2 || data->bi.biFenceStatus)
 -			pr_info("  BI:  %016llx %016llx %016llx %016llx\n",
 -				be64_to_cpu(data->bi.biLdcp0),
 -				be64_to_cpu(data->bi.biLdcp1),
 -				be64_to_cpu(data->bi.biLdcp2),
 -				be64_to_cpu(data->bi.biFenceStatus));
 -		break;
 -	case OPAL_P7IOC_DIAG_TYPE_CI:
 -		pr_info("P7IOC diag-data for CI Port %d\n\n",
 -			data->ci.ciPort);
 -		pnv_eeh_dump_hub_diag_common(data);
 -		if (data->ci.ciPortStatus || data->ci.ciPortLdcp)
 -			pr_info("  CI:  %016llx %016llx\n",
 -				be64_to_cpu(data->ci.ciPortStatus),
 -				be64_to_cpu(data->ci.ciPortLdcp));
 -		break;
 -	case OPAL_P7IOC_DIAG_TYPE_MISC:
 -		pr_info("P7IOC diag-data for MISC\n\n");
 -		pnv_eeh_dump_hub_diag_common(data);
 -		break;
 -	case OPAL_P7IOC_DIAG_TYPE_I2C:
 -		pr_info("P7IOC diag-data for I2C\n\n");
 -		pnv_eeh_dump_hub_diag_common(data);
 -		break;
 -	default:
 -		pr_warn("%s: Invalid type of HUB#%llx diag-data (%d)\n",
 -			__func__, phb->hub_id, data->type);
 -	}
 -}
 -
 -static int pnv_eeh_get_pe(struct pci_controller *hose,
 -			  u16 pe_no, struct eeh_pe **pe)
 -{
 -	struct pnv_phb *phb = hose->private_data;
 -	struct pnv_ioda_pe *pnv_pe;
 -	struct eeh_pe *dev_pe;
 -	struct eeh_dev edev;
 -
 -	/*
 -	 * If PHB supports compound PE, to fetch
 -	 * the master PE because slave PE is invisible
 -	 * to EEH core.
 -	 */
 -	pnv_pe = &phb->ioda.pe_array[pe_no];
 -	if (pnv_pe->flags & PNV_IODA_PE_SLAVE) {
 -		pnv_pe = pnv_pe->master;
 -		WARN_ON(!pnv_pe ||
 -			!(pnv_pe->flags & PNV_IODA_PE_MASTER));
 -		pe_no = pnv_pe->pe_number;
 -	}
 -
 -	/* Find the PE according to PE# */
 -	memset(&edev, 0, sizeof(struct eeh_dev));
 -	edev.phb = hose;
 -	edev.pe_config_addr = pe_no;
 -	dev_pe = eeh_pe_get(&edev);
 -	if (!dev_pe)
 -		return -EEXIST;
 -
 -	/* Freeze the (compound) PE */
 -	*pe = dev_pe;
 -	if (!(dev_pe->state & EEH_PE_ISOLATED))
 -		phb->freeze_pe(phb, pe_no);
 -
 -	/*
 -	 * At this point, we're sure the (compound) PE should
 -	 * have been frozen. However, we still need poke until
 -	 * hitting the frozen PE on top level.
 -	 */
 -	dev_pe = dev_pe->parent;
 -	while (dev_pe && !(dev_pe->type & EEH_PE_PHB)) {
 -		int ret;
 -		int active_flags = (EEH_STATE_MMIO_ACTIVE |
 -				    EEH_STATE_DMA_ACTIVE);
 -
 -		ret = eeh_ops->get_state(dev_pe, NULL);
 -		if (ret <= 0 || (ret & active_flags) == active_flags) {
 -			dev_pe = dev_pe->parent;
 -			continue;
 -		}
 -
 -		/* Frozen parent PE */
 -		*pe = dev_pe;
 -		if (!(dev_pe->state & EEH_PE_ISOLATED))
 -			phb->freeze_pe(phb, dev_pe->addr);
 -
 -		/* Next one */
 -		dev_pe = dev_pe->parent;
 -	}
 -
 -	return 0;
 +	return pnv_pci_cfg_write(dn, where, size, val);
  }
  
  /**
 - * pnv_eeh_next_error - Retrieve next EEH error to handle
 + * powernv_eeh_next_error - Retrieve next EEH error to handle
   * @pe: Affected PE
   *
 - * The function is expected to be called by EEH core while it gets
 - * special EEH event (without binding PE). The function calls to
 - * OPAL APIs for next error to handle. The informational error is
 - * handled internally by platform. However, the dead IOC, dead PHB,
 - * fenced PHB and frozen PE should be handled by EEH core eventually.
 + * Using OPAL API, to retrieve next EEH error for EEH core to handle
   */
 -static int pnv_eeh_next_error(struct eeh_pe **pe)
 +static int powernv_eeh_next_error(struct eeh_pe **pe)
  {
  	struct pci_controller *hose;
 -	struct pnv_phb *phb;
 -	struct eeh_pe *phb_pe, *parent_pe;
 -	__be64 frozen_pe_no;
 -	__be16 err_type, severity;
 -	int active_flags = (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE);
 -	long rc;
 -	int state, ret = EEH_NEXT_ERR_NONE;
 -
 -	/*
 -	 * While running here, it's safe to purge the event queue.
 -	 * And we should keep the cached OPAL notifier event sychronized
 -	 * between the kernel and firmware.
 -	 */
 -	eeh_remove_event(NULL, false);
 -	opal_notifier_update_evt(OPAL_EVENT_PCI_ERROR, 0x0ul);
 +	struct pnv_phb *phb = NULL;
  
  	list_for_each_entry(hose, &hose_list, list_node) {
 -		/*
 -		 * If the subordinate PCI buses of the PHB has been
 -		 * removed or is exactly under error recovery, we
 -		 * needn't take care of it any more.
 -		 */
  		phb = hose->private_data;
 -		phb_pe = eeh_phb_pe_get(hose);
 -		if (!phb_pe || (phb_pe->state & EEH_PE_ISOLATED))
 -			continue;
 -
 -		rc = opal_pci_next_error(phb->opal_id,
 -					 &frozen_pe_no, &err_type, &severity);
 -		if (rc != OPAL_SUCCESS) {
 -			pr_devel("%s: Invalid return value on "
 -				 "PHB#%x (0x%lx) from opal_pci_next_error",
 -				 __func__, hose->global_number, rc);
 -			continue;
 -		}
 -
 -		/* If the PHB doesn't have error, stop processing */
 -		if (be16_to_cpu(err_type) == OPAL_EEH_NO_ERROR ||
 -		    be16_to_cpu(severity) == OPAL_EEH_SEV_NO_ERROR) {
 -			pr_devel("%s: No error found on PHB#%x\n",
 -				 __func__, hose->global_number);
 -			continue;
 -		}
 -
 -		/*
 -		 * Processing the error. We're expecting the error with
 -		 * highest priority reported upon multiple errors on the
 -		 * specific PHB.
 -		 */
 -		pr_devel("%s: Error (%d, %d, %llu) on PHB#%x\n",
 -			__func__, be16_to_cpu(err_type),
 -			be16_to_cpu(severity), be64_to_cpu(frozen_pe_no),
 -			hose->global_number);
 -		switch (be16_to_cpu(err_type)) {
 -		case OPAL_EEH_IOC_ERROR:
 -			if (be16_to_cpu(severity) == OPAL_EEH_SEV_IOC_DEAD) {
 -				pr_err("EEH: dead IOC detected\n");
 -				ret = EEH_NEXT_ERR_DEAD_IOC;
 -			} else if (be16_to_cpu(severity) == OPAL_EEH_SEV_INF) {
 -				pr_info("EEH: IOC informative error "
 -					"detected\n");
 -				pnv_eeh_get_and_dump_hub_diag(hose);
 -				ret = EEH_NEXT_ERR_NONE;
 -			}
 -
 -			break;
 -		case OPAL_EEH_PHB_ERROR:
 -			if (be16_to_cpu(severity) == OPAL_EEH_SEV_PHB_DEAD) {
 -				*pe = phb_pe;
 -				pr_err("EEH: dead PHB#%x detected, "
 -				       "location: %s\n",
 -					hose->global_number,
 -					eeh_pe_loc_get(phb_pe));
 -				ret = EEH_NEXT_ERR_DEAD_PHB;
 -			} else if (be16_to_cpu(severity) ==
 -				   OPAL_EEH_SEV_PHB_FENCED) {
 -				*pe = phb_pe;
 -				pr_err("EEH: Fenced PHB#%x detected, "
 -				       "location: %s\n",
 -					hose->global_number,
 -					eeh_pe_loc_get(phb_pe));
 -				ret = EEH_NEXT_ERR_FENCED_PHB;
 -			} else if (be16_to_cpu(severity) == OPAL_EEH_SEV_INF) {
 -				pr_info("EEH: PHB#%x informative error "
 -					"detected, location: %s\n",
 -					hose->global_number,
 -					eeh_pe_loc_get(phb_pe));
 -				pnv_eeh_get_phb_diag(phb_pe);
 -				pnv_pci_dump_phb_diag_data(hose, phb_pe->data);
 -				ret = EEH_NEXT_ERR_NONE;
 -			}
 -
 -			break;
 -		case OPAL_EEH_PE_ERROR:
 -			/*
 -			 * If we can't find the corresponding PE, we
 -			 * just try to unfreeze.
 -			 */
 -			if (pnv_eeh_get_pe(hose,
 -				be64_to_cpu(frozen_pe_no), pe)) {
 -				/* Try best to clear it */
 -				pr_info("EEH: Clear non-existing PHB#%x-PE#%llx\n",
 -					hose->global_number, frozen_pe_no);
 -				pr_info("EEH: PHB location: %s\n",
 -					eeh_pe_loc_get(phb_pe));
 -				opal_pci_eeh_freeze_clear(phb->opal_id,
 -					frozen_pe_no,
 -					OPAL_EEH_ACTION_CLEAR_FREEZE_ALL);
 -				ret = EEH_NEXT_ERR_NONE;
 -			} else if ((*pe)->state & EEH_PE_ISOLATED ||
 -				   eeh_pe_passed(*pe)) {
 -				ret = EEH_NEXT_ERR_NONE;
 -			} else {
 -				pr_err("EEH: Frozen PE#%x "
 -				       "on PHB#%x detected\n",
 -				       (*pe)->addr,
 -					(*pe)->phb->global_number);
 -				pr_err("EEH: PE location: %s, "
 -				       "PHB location: %s\n",
 -				       eeh_pe_loc_get(*pe),
 -				       eeh_pe_loc_get(phb_pe));
 -				ret = EEH_NEXT_ERR_FROZEN_PE;
 -			}
 -
 -			break;
 -		default:
 -			pr_warn("%s: Unexpected error type %d\n",
 -				__func__, be16_to_cpu(err_type));
 -		}
 -
 -		/*
 -		 * EEH core will try recover from fenced PHB or
 -		 * frozen PE. In the time for frozen PE, EEH core
 -		 * enable IO path for that before collecting logs,
 -		 * but it ruins the site. So we have to dump the
 -		 * log in advance here.
 -		 */
 -		if ((ret == EEH_NEXT_ERR_FROZEN_PE  ||
 -		    ret == EEH_NEXT_ERR_FENCED_PHB) &&
 -		    !((*pe)->state & EEH_PE_ISOLATED)) {
 -			eeh_pe_state_mark(*pe, EEH_PE_ISOLATED);
 -			pnv_eeh_get_phb_diag(*pe);
 -
 -			if (eeh_has_flag(EEH_EARLY_DUMP_LOG))
 -				pnv_pci_dump_phb_diag_data((*pe)->phb,
 -							   (*pe)->data);
 -		}
 -
 -		/*
 -		 * We probably have the frozen parent PE out there and
 -		 * we need have to handle frozen parent PE firstly.
 -		 */
 -		if (ret == EEH_NEXT_ERR_FROZEN_PE) {
 -			parent_pe = (*pe)->parent;
 -			while (parent_pe) {
 -				/* Hit the ceiling ? */
 -				if (parent_pe->type & EEH_PE_PHB)
 -					break;
 -
 -				/* Frozen parent PE ? */
 -				state = eeh_ops->get_state(parent_pe, NULL);
 -				if (state > 0 &&
 -				    (state & active_flags) != active_flags)
 -					*pe = parent_pe;
 -
 -				/* Next parent level */
 -				parent_pe = parent_pe->parent;
 -			}
 -
 -			/* We possibly migrate to another PE */
 -			eeh_pe_state_mark(*pe, EEH_PE_ISOLATED);
 -		}
 -
 -		/*
 -		 * If we have no errors on the specific PHB or only
 -		 * informative error there, we continue poking it.
 -		 * Otherwise, we need actions to be taken by upper
 -		 * layer.
 -		 */
 -		if (ret > EEH_NEXT_ERR_INF)
 -			break;
 +		break;
  	}
  
 -	return ret;
 +	if (phb && phb->eeh_ops->next_error)
 +		return phb->eeh_ops->next_error(pe);
 +
 +	return -EEXIST;
  }
  
++<<<<<<< HEAD
 +static int powernv_eeh_restore_config(struct device_node *dn)
++=======
+ static int pnv_eeh_restore_config(struct pci_dn *pdn)
++>>>>>>> 0bd785873c6a (powerpc/eeh: Replace device_node with pci_dn in eeh_ops)
  {
- 	struct eeh_dev *edev = of_node_to_eeh_dev(dn);
+ 	struct eeh_dev *edev = pdn_to_eeh_dev(pdn);
  	struct pnv_phb *phb;
  	s64 ret;
  
diff --git a/arch/powerpc/include/asm/eeh.h b/arch/powerpc/include/asm/eeh.h
index 03a58dda020c..6a8add102d28 100644
--- a/arch/powerpc/include/asm/eeh.h
+++ b/arch/powerpc/include/asm/eeh.h
@@ -219,10 +219,10 @@ struct eeh_ops {
 	int (*configure_bridge)(struct eeh_pe *pe);
 	int (*err_inject)(struct eeh_pe *pe, int type, int func,
 			  unsigned long addr, unsigned long mask);
-	int (*read_config)(struct device_node *dn, int where, int size, u32 *val);
-	int (*write_config)(struct device_node *dn, int where, int size, u32 val);
+	int (*read_config)(struct pci_dn *pdn, int where, int size, u32 *val);
+	int (*write_config)(struct pci_dn *pdn, int where, int size, u32 val);
 	int (*next_error)(struct eeh_pe **pe);
-	int (*restore_config)(struct device_node *dn);
+	int (*restore_config)(struct pci_dn *pdn);
 };
 
 extern int eeh_subsystem_flags;
* Unmerged path arch/powerpc/kernel/eeh.c
diff --git a/arch/powerpc/kernel/eeh_pe.c b/arch/powerpc/kernel/eeh_pe.c
index 66d3a4ade05e..da695a84277b 100644
--- a/arch/powerpc/kernel/eeh_pe.c
+++ b/arch/powerpc/kernel/eeh_pe.c
@@ -258,27 +258,25 @@ struct eeh_pe *eeh_pe_get(struct eeh_dev *edev)
  */
 static struct eeh_pe *eeh_pe_get_parent(struct eeh_dev *edev)
 {
-	struct device_node *dn;
 	struct eeh_dev *parent;
+	struct pci_dn *pdn = eeh_dev_to_pdn(edev);
 
 	/*
 	 * It might have the case for the indirect parent
 	 * EEH device already having associated PE, but
 	 * the direct parent EEH device doesn't have yet.
 	 */
-	dn = edev->dn->parent;
-	while (dn) {
-		/* We're poking out of PCI territory */
-		if (!PCI_DN(dn)) return NULL;
-
-		parent = of_node_to_eeh_dev(dn);
+	pdn = pdn ? pdn->parent : NULL;
+	while (pdn) {
 		/* We're poking out of PCI territory */
-		if (!parent) return NULL;
+		parent = pdn_to_eeh_dev(pdn);
+		if (!parent)
+			return NULL;
 
 		if (parent->pe)
 			return parent->pe;
 
-		dn = dn->parent;
+		pdn = pdn->parent;
 	}
 
 	return NULL;
@@ -625,9 +623,9 @@ void eeh_pe_state_clear(struct eeh_pe *pe, int state)
  * blocked on normal path during the stage. So we need utilize
  * eeh operations, which is always permitted.
  */
-static void eeh_bridge_check_link(struct eeh_dev *edev,
-				  struct device_node *dn)
+static void eeh_bridge_check_link(struct eeh_dev *edev)
 {
+	struct pci_dn *pdn = eeh_dev_to_pdn(edev);
 	int cap;
 	uint32_t val;
 	int timeout = 0;
@@ -647,32 +645,32 @@ static void eeh_bridge_check_link(struct eeh_dev *edev,
 
 	/* Check slot status */
 	cap = edev->pcie_cap;
-	eeh_ops->read_config(dn, cap + PCI_EXP_SLTSTA, 2, &val);
+	eeh_ops->read_config(pdn, cap + PCI_EXP_SLTSTA, 2, &val);
 	if (!(val & PCI_EXP_SLTSTA_PDS)) {
 		pr_debug("  No card in the slot (0x%04x) !\n", val);
 		return;
 	}
 
 	/* Check power status if we have the capability */
-	eeh_ops->read_config(dn, cap + PCI_EXP_SLTCAP, 2, &val);
+	eeh_ops->read_config(pdn, cap + PCI_EXP_SLTCAP, 2, &val);
 	if (val & PCI_EXP_SLTCAP_PCP) {
-		eeh_ops->read_config(dn, cap + PCI_EXP_SLTCTL, 2, &val);
+		eeh_ops->read_config(pdn, cap + PCI_EXP_SLTCTL, 2, &val);
 		if (val & PCI_EXP_SLTCTL_PCC) {
 			pr_debug("  In power-off state, power it on ...\n");
 			val &= ~(PCI_EXP_SLTCTL_PCC | PCI_EXP_SLTCTL_PIC);
 			val |= (0x0100 & PCI_EXP_SLTCTL_PIC);
-			eeh_ops->write_config(dn, cap + PCI_EXP_SLTCTL, 2, val);
+			eeh_ops->write_config(pdn, cap + PCI_EXP_SLTCTL, 2, val);
 			msleep(2 * 1000);
 		}
 	}
 
 	/* Enable link */
-	eeh_ops->read_config(dn, cap + PCI_EXP_LNKCTL, 2, &val);
+	eeh_ops->read_config(pdn, cap + PCI_EXP_LNKCTL, 2, &val);
 	val &= ~PCI_EXP_LNKCTL_LD;
-	eeh_ops->write_config(dn, cap + PCI_EXP_LNKCTL, 2, val);
+	eeh_ops->write_config(pdn, cap + PCI_EXP_LNKCTL, 2, val);
 
 	/* Check link */
-	eeh_ops->read_config(dn, cap + PCI_EXP_LNKCAP, 4, &val);
+	eeh_ops->read_config(pdn, cap + PCI_EXP_LNKCAP, 4, &val);
 	if (!(val & PCI_EXP_LNKCAP_DLLLARC)) {
 		pr_debug("  No link reporting capability (0x%08x) \n", val);
 		msleep(1000);
@@ -685,7 +683,7 @@ static void eeh_bridge_check_link(struct eeh_dev *edev,
 		msleep(20);
 		timeout += 20;
 
-		eeh_ops->read_config(dn, cap + PCI_EXP_LNKSTA, 2, &val);
+		eeh_ops->read_config(pdn, cap + PCI_EXP_LNKSTA, 2, &val);
 		if (val & PCI_EXP_LNKSTA_DLLLA)
 			break;
 	}
@@ -700,9 +698,9 @@ static void eeh_bridge_check_link(struct eeh_dev *edev,
 #define BYTE_SWAP(OFF)	(8*((OFF)/4)+3-(OFF))
 #define SAVED_BYTE(OFF)	(((u8 *)(edev->config_space))[BYTE_SWAP(OFF)])
 
-static void eeh_restore_bridge_bars(struct eeh_dev *edev,
-				    struct device_node *dn)
+static void eeh_restore_bridge_bars(struct eeh_dev *edev)
 {
+	struct pci_dn *pdn = eeh_dev_to_pdn(edev);
 	int i;
 
 	/*
@@ -710,49 +708,49 @@ static void eeh_restore_bridge_bars(struct eeh_dev *edev,
 	 * Bus numbers and windows: 0x18 - 0x30
 	 */
 	for (i = 4; i < 13; i++)
-		eeh_ops->write_config(dn, i*4, 4, edev->config_space[i]);
+		eeh_ops->write_config(pdn, i*4, 4, edev->config_space[i]);
 	/* Rom: 0x38 */
-	eeh_ops->write_config(dn, 14*4, 4, edev->config_space[14]);
+	eeh_ops->write_config(pdn, 14*4, 4, edev->config_space[14]);
 
 	/* Cache line & Latency timer: 0xC 0xD */
-	eeh_ops->write_config(dn, PCI_CACHE_LINE_SIZE, 1,
+	eeh_ops->write_config(pdn, PCI_CACHE_LINE_SIZE, 1,
                 SAVED_BYTE(PCI_CACHE_LINE_SIZE));
-        eeh_ops->write_config(dn, PCI_LATENCY_TIMER, 1,
+        eeh_ops->write_config(pdn, PCI_LATENCY_TIMER, 1,
                 SAVED_BYTE(PCI_LATENCY_TIMER));
 	/* Max latency, min grant, interrupt ping and line: 0x3C */
-	eeh_ops->write_config(dn, 15*4, 4, edev->config_space[15]);
+	eeh_ops->write_config(pdn, 15*4, 4, edev->config_space[15]);
 
 	/* PCI Command: 0x4 */
-	eeh_ops->write_config(dn, PCI_COMMAND, 4, edev->config_space[1]);
+	eeh_ops->write_config(pdn, PCI_COMMAND, 4, edev->config_space[1]);
 
 	/* Check the PCIe link is ready */
-	eeh_bridge_check_link(edev, dn);
+	eeh_bridge_check_link(edev);
 }
 
-static void eeh_restore_device_bars(struct eeh_dev *edev,
-				    struct device_node *dn)
+static void eeh_restore_device_bars(struct eeh_dev *edev)
 {
+	struct pci_dn *pdn = eeh_dev_to_pdn(edev);
 	int i;
 	u32 cmd;
 
 	for (i = 4; i < 10; i++)
-		eeh_ops->write_config(dn, i*4, 4, edev->config_space[i]);
+		eeh_ops->write_config(pdn, i*4, 4, edev->config_space[i]);
 	/* 12 == Expansion ROM Address */
-	eeh_ops->write_config(dn, 12*4, 4, edev->config_space[12]);
+	eeh_ops->write_config(pdn, 12*4, 4, edev->config_space[12]);
 
-	eeh_ops->write_config(dn, PCI_CACHE_LINE_SIZE, 1,
+	eeh_ops->write_config(pdn, PCI_CACHE_LINE_SIZE, 1,
 		SAVED_BYTE(PCI_CACHE_LINE_SIZE));
-	eeh_ops->write_config(dn, PCI_LATENCY_TIMER, 1,
+	eeh_ops->write_config(pdn, PCI_LATENCY_TIMER, 1,
 		SAVED_BYTE(PCI_LATENCY_TIMER));
 
 	/* max latency, min grant, interrupt pin and line */
-	eeh_ops->write_config(dn, 15*4, 4, edev->config_space[15]);
+	eeh_ops->write_config(pdn, 15*4, 4, edev->config_space[15]);
 
 	/*
 	 * Restore PERR & SERR bits, some devices require it,
 	 * don't touch the other command bits
 	 */
-	eeh_ops->read_config(dn, PCI_COMMAND, 4, &cmd);
+	eeh_ops->read_config(pdn, PCI_COMMAND, 4, &cmd);
 	if (edev->config_space[1] & PCI_COMMAND_PARITY)
 		cmd |= PCI_COMMAND_PARITY;
 	else
@@ -761,7 +759,7 @@ static void eeh_restore_device_bars(struct eeh_dev *edev,
 		cmd |= PCI_COMMAND_SERR;
 	else
 		cmd &= ~PCI_COMMAND_SERR;
-	eeh_ops->write_config(dn, PCI_COMMAND, 4, cmd);
+	eeh_ops->write_config(pdn, PCI_COMMAND, 4, cmd);
 }
 
 /**
@@ -776,16 +774,16 @@ static void eeh_restore_device_bars(struct eeh_dev *edev,
 static void *eeh_restore_one_device_bars(void *data, void *flag)
 {
 	struct eeh_dev *edev = (struct eeh_dev *)data;
-	struct device_node *dn = eeh_dev_to_of_node(edev);
+	struct pci_dn *pdn = eeh_dev_to_pdn(edev);
 
 	/* Do special restore for bridges */
 	if (edev->mode & EEH_DEV_BRIDGE)
-		eeh_restore_bridge_bars(edev, dn);
+		eeh_restore_bridge_bars(edev);
 	else
-		eeh_restore_device_bars(edev, dn);
+		eeh_restore_device_bars(edev);
 
-	if (eeh_ops->restore_config)
-		eeh_ops->restore_config(dn);
+	if (eeh_ops->restore_config && pdn)
+		eeh_ops->restore_config(pdn);
 
 	return NULL;
 }
* Unmerged path arch/powerpc/platforms/powernv/eeh-powernv.c
diff --git a/arch/powerpc/platforms/pseries/eeh_pseries.c b/arch/powerpc/platforms/pseries/eeh_pseries.c
index 9d3d9f478692..1522aba365c5 100644
--- a/arch/powerpc/platforms/pseries/eeh_pseries.c
+++ b/arch/powerpc/platforms/pseries/eeh_pseries.c
@@ -668,37 +668,29 @@ static int pseries_eeh_configure_bridge(struct eeh_pe *pe)
 
 /**
  * pseries_eeh_read_config - Read PCI config space
- * @dn: device node
+ * @pdn: PCI device node
  * @where: PCI address
  * @size: size to read
  * @val: return value
  *
  * Read config space from the speicifed device
  */
-static int pseries_eeh_read_config(struct device_node *dn, int where, int size, u32 *val)
+static int pseries_eeh_read_config(struct pci_dn *pdn, int where, int size, u32 *val)
 {
-	struct pci_dn *pdn;
-
-	pdn = PCI_DN(dn);
-
 	return rtas_read_config(pdn, where, size, val);
 }
 
 /**
  * pseries_eeh_write_config - Write PCI config space
- * @dn: device node
+ * @pdn: PCI device node
  * @where: PCI address
  * @size: size to write
  * @val: value to be written
  *
  * Write config space to the specified device
  */
-static int pseries_eeh_write_config(struct device_node *dn, int where, int size, u32 val)
+static int pseries_eeh_write_config(struct pci_dn *pdn, int where, int size, u32 val)
 {
-	struct pci_dn *pdn;
-
-	pdn = PCI_DN(dn);
-
 	return rtas_write_config(pdn, where, size, val);
 }
 
