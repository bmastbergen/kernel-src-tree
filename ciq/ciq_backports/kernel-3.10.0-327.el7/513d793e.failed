perf/x86/intel/uncore: Register the PMU only if the uncore pci device exists

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [x86] perf/uncore: Register the PMU only if the uncore pci device exists (Jiri Olsa) [1176340]
Rebuild_FUZZ: 92.96%
commit-author Yan, Zheng <zheng.z.yan@intel.com>
commit 513d793e5fe138d779ad6c532cd20c289a6897fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/513d793e.failed

Current code registers PMUs for all possible uncore pci devices.
This is not good because, on some machines, one or more uncore pci
devices can be missing. The missing pci device make corresponding
PMU unusable. Register the PMU only if the uncore device exists.

	Signed-off-by: Yan, Zheng <zheng.z.yan@intel.com>
	Signed-off-by: Andi Kleen <ak@linux.intel.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: eranian@google.com
Link: http://lkml.kernel.org/r/1409872109-31645-3-git-send-email-andi@firstfloor.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 513d793e5fe138d779ad6c532cd20c289a6897fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/perf_event_intel_uncore.c
diff --cc arch/x86/kernel/cpu/perf_event_intel_uncore.c
index 969a74b7104d,42d00e53175d..000000000000
--- a/arch/x86/kernel/cpu/perf_event_intel_uncore.c
+++ b/arch/x86/kernel/cpu/perf_event_intel_uncore.c
@@@ -3770,8 -793,9 +3770,9 @@@ static int uncore_pci_probe(struct pci_
  	struct intel_uncore_box *box;
  	struct intel_uncore_type *type;
  	int phys_id;
+ 	bool first_box = false;
  
 -	phys_id = uncore_pcibus_to_physid[pdev->bus->number];
 +	phys_id = pcibus_to_physid[pdev->bus->number];
  	if (phys_id < 0)
  		return -ENODEV;
  
@@@ -3813,7 -842,8 +3818,12 @@@ static void uncore_pci_remove(struct pc
  {
  	struct intel_uncore_box *box = pci_get_drvdata(pdev);
  	struct intel_uncore_pmu *pmu;
++<<<<<<< HEAD
 +	int i, cpu, phys_id = pcibus_to_physid[pdev->bus->number];
++=======
+ 	int i, cpu, phys_id = uncore_pcibus_to_physid[pdev->bus->number];
+ 	bool last_box = false;
++>>>>>>> 513d793e5fe1 (perf/x86/intel/uncore: Register the PMU only if the uncore pci device exists)
  
  	box = pci_get_drvdata(pdev);
  	if (!box) {
@@@ -4204,6 -1215,36 +4219,39 @@@ static int __init uncore_cpu_init(void
  	if (ret)
  		return ret;
  
++<<<<<<< HEAD
++=======
+ 	return 0;
+ }
+ 
+ static int __init uncore_pmus_register(void)
+ {
+ 	struct intel_uncore_pmu *pmu;
+ 	struct intel_uncore_type *type;
+ 	int i, j;
+ 
+ 	for (i = 0; uncore_msr_uncores[i]; i++) {
+ 		type = uncore_msr_uncores[i];
+ 		for (j = 0; j < type->num_boxes; j++) {
+ 			pmu = &type->pmus[j];
+ 			uncore_pmu_register(pmu);
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void __init uncore_cpumask_init(void)
+ {
+ 	int cpu;
+ 
+ 	/*
+ 	 * ony invoke once from msr or pci init code
+ 	 */
+ 	if (!cpumask_empty(&uncore_cpu_mask))
+ 		return;
+ 
++>>>>>>> 513d793e5fe1 (perf/x86/intel/uncore: Register the PMU only if the uncore pci device exists)
  	cpu_notifier_register_begin();
  
  	for_each_online_cpu(cpu) {
* Unmerged path arch/x86/kernel/cpu/perf_event_intel_uncore.c
