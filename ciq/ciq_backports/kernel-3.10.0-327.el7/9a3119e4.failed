IB/iser: Release the iscsi endpoint if ep_disconnect wasn't called

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [infiniband] iser: Release the iscsi endpoint if ep_disconnect wasn't called (Amir Vadai) [1164539]
Rebuild_FUZZ: 97.67%
commit-author Ariel Nahum <arieln@mellanox.com>
commit 9a3119e4b787d8c855202eb0388b213f86f88714
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/9a3119e4.failed

In some cases, we might reach the iser connection termination without
ep_disconnect being invoked (for example if user-space daemon doesn't
exists. In this case, we need to free the iscsi endpoint when we
remove the iser connection.

	Signed-off-by: Ariel Nahum <arieln@mellanox.com>
	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Roland Dreier <roland@purestorage.com>
(cherry picked from commit 9a3119e4b787d8c855202eb0388b213f86f88714)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/iser/iser_verbs.c
diff --cc drivers/infiniband/ulp/iser/iser_verbs.c
index 4cafd44ad193,4065abe28829..000000000000
--- a/drivers/infiniband/ulp/iser/iser_verbs.c
+++ b/drivers/infiniband/ulp/iser/iser_verbs.c
@@@ -620,26 -637,29 +620,43 @@@ void iser_release_work(struct work_stru
  /**
   * Frees all conn objects and deallocs conn descriptor
   */
 -void iser_conn_release(struct iser_conn *iser_conn)
 +void iser_conn_release(struct iser_conn *ib_conn)
  {
 -	struct ib_conn *ib_conn = &iser_conn->ib_conn;
 +	struct iser_device  *device = ib_conn->device;
  
  	mutex_lock(&ig.connlist_mutex);
 -	list_del(&iser_conn->conn_list);
 +	list_del(&ib_conn->conn_list);
  	mutex_unlock(&ig.connlist_mutex);
  
++<<<<<<< HEAD
 +	mutex_lock(&ib_conn->state_mutex);
 +	BUG_ON(ib_conn->state != ISER_CONN_DOWN);
++=======
+ 	mutex_lock(&iser_conn->state_mutex);
+ 	/* In case we endup here without ep_disconnect being invoked. */
+ 	if (iser_conn->state != ISER_CONN_DOWN) {
+ 		iser_warn("iser conn %p state %d, expected state down.\n",
+ 			  iser_conn, iser_conn->state);
+ 		iscsi_destroy_endpoint(iser_conn->ep);
+ 		iser_conn->state = ISER_CONN_DOWN;
+ 	}
+ 	/*
+ 	 * In case we never got to bind stage, we still need to
+ 	 * release IB resources (which is safe to call more than once).
+ 	 */
+ 	iser_free_ib_conn_res(iser_conn, true);
+ 	mutex_unlock(&iser_conn->state_mutex);
++>>>>>>> 9a3119e4b787 (IB/iser: Release the iscsi endpoint if ep_disconnect wasn't called)
 +
 +	iser_free_rx_descriptors(ib_conn);
 +	iser_free_ib_conn_res(ib_conn);
 +	ib_conn->device = NULL;
 +	/* on EVENT_ADDR_ERROR there's no device yet for this conn */
 +	if (device != NULL)
 +		iser_device_try_release(device);
 +	mutex_unlock(&ib_conn->state_mutex);
  
 +	/* if cma handler context, the caller actually destroy the id */
  	if (ib_conn->cma_id != NULL) {
  		rdma_destroy_id(ib_conn->cma_id);
  		ib_conn->cma_id = NULL;
* Unmerged path drivers/infiniband/ulp/iser/iser_verbs.c
