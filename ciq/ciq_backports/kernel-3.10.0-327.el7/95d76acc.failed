x86, irq: Count legacy IRQs by legacy_pic->nr_legacy_irqs instead of NR_IRQS_LEGACY

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [x86] irq: Count legacy IRQs by legacy_pic->nr_legacy_irqs instead of NR_IRQS_LEGACY (Steve Best) [1231358]
Rebuild_FUZZ: 96.89%
commit-author Jiang Liu <jiang.liu@linux.intel.com>
commit 95d76acc7518d566df18d67c1343bb375b78d1f3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/95d76acc.failed

Some platforms, such as Intel MID and mshypv, do not support legacy
interrupt controllers. So count legacy IRQs by legacy_pic->nr_legacy_irqs
instead of hard-coded NR_IRQS_LEGACY.

	Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
	Cc: Tony Luck <tony.luck@intel.com>
	Cc: Joerg Roedel <joro@8bytes.org>
	Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: xen-devel@lists.xenproject.org
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Grant Likely <grant.likely@linaro.org>
	Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
	Cc: Bjorn Helgaas <bhelgaas@google.com>
	Cc: Randy Dunlap <rdunlap@infradead.org>
	Cc: Yinghai Lu <yinghai@kernel.org>
	Cc: Len Brown <len.brown@intel.com>
	Cc: Pavel Machek <pavel@ucw.cz>
	Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
	Cc: Rob Herring <rob.herring@calxeda.com>
	Cc: Michal Simek <monstr@monstr.eu>
	Cc: Tony Lindgren <tony@atomide.com>
	Acked-by: David Vrabel <david.vrabel@citrix.com>
Link: http://lkml.kernel.org/r/1402302011-23642-20-git-send-email-jiang.liu@linux.intel.com
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit 95d76acc7518d566df18d67c1343bb375b78d1f3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/acpi/boot.c
#	arch/x86/kernel/apic/io_apic.c
#	arch/x86/kernel/devicetree.c
diff --cc arch/x86/kernel/acpi/boot.c
index e90087442d73,b12976590a72..000000000000
--- a/arch/x86/kernel/acpi/boot.c
+++ b/arch/x86/kernel/acpi/boot.c
@@@ -102,12 -98,14 +103,12 @@@ static u32 isa_irq_to_gsi[NR_IRQS_LEGAC
  	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
  };
  
 -#define	ACPI_INVALID_GSI		INT_MIN
 -
  static unsigned int gsi_to_irq(unsigned int gsi)
  {
- 	unsigned int irq = gsi + NR_IRQS_LEGACY;
+ 	unsigned int irq = gsi + nr_legacy_irqs();
  	unsigned int i;
  
- 	for (i = 0; i < NR_IRQS_LEGACY; i++) {
+ 	for (i = 0; i < nr_legacy_irqs(); i++) {
  		if (isa_irq_to_gsi[i] == gsi) {
  			return i;
  		}
@@@ -334,6 -332,130 +335,133 @@@ acpi_parse_lapic_nmi(struct acpi_subtab
  #endif				/*CONFIG_X86_LOCAL_APIC */
  
  #ifdef CONFIG_X86_IO_APIC
++<<<<<<< HEAD
++=======
+ #define MP_ISA_BUS		0
+ 
+ static void __init mp_override_legacy_irq(u8 bus_irq, u8 polarity, u8 trigger,
+ 					  u32 gsi)
+ {
+ 	int ioapic;
+ 	int pin;
+ 	struct mpc_intsrc mp_irq;
+ 
+ 	/*
+ 	 * Convert 'gsi' to 'ioapic.pin'.
+ 	 */
+ 	ioapic = mp_find_ioapic(gsi);
+ 	if (ioapic < 0)
+ 		return;
+ 	pin = mp_find_ioapic_pin(ioapic, gsi);
+ 
+ 	/*
+ 	 * TBD: This check is for faulty timer entries, where the override
+ 	 *      erroneously sets the trigger to level, resulting in a HUGE
+ 	 *      increase of timer interrupts!
+ 	 */
+ 	if ((bus_irq == 0) && (trigger == 3))
+ 		trigger = 1;
+ 
+ 	mp_irq.type = MP_INTSRC;
+ 	mp_irq.irqtype = mp_INT;
+ 	mp_irq.irqflag = (trigger << 2) | polarity;
+ 	mp_irq.srcbus = MP_ISA_BUS;
+ 	mp_irq.srcbusirq = bus_irq;	/* IRQ */
+ 	mp_irq.dstapic = mpc_ioapic_id(ioapic); /* APIC ID */
+ 	mp_irq.dstirq = pin;	/* INTIN# */
+ 
+ 	mp_save_irq(&mp_irq);
+ 
+ 	/*
+ 	 * Reset default identity mapping if gsi is also an legacy IRQ,
+ 	 * otherwise there will be more than one entry with the same GSI
+ 	 * and acpi_isa_irq_to_gsi() may give wrong result.
+ 	 */
+ 	if (gsi < nr_legacy_irqs() && isa_irq_to_gsi[gsi] == gsi)
+ 		isa_irq_to_gsi[gsi] = ACPI_INVALID_GSI;
+ 	isa_irq_to_gsi[bus_irq] = gsi;
+ }
+ 
+ static int mp_config_acpi_gsi(struct device *dev, u32 gsi, int trigger,
+ 			int polarity)
+ {
+ #ifdef CONFIG_X86_MPPARSE
+ 	struct mpc_intsrc mp_irq;
+ 	struct pci_dev *pdev;
+ 	unsigned char number;
+ 	unsigned int devfn;
+ 	int ioapic;
+ 	u8 pin;
+ 
+ 	if (!acpi_ioapic)
+ 		return 0;
+ 	if (!dev || !dev_is_pci(dev))
+ 		return 0;
+ 
+ 	pdev = to_pci_dev(dev);
+ 	number = pdev->bus->number;
+ 	devfn = pdev->devfn;
+ 	pin = pdev->pin;
+ 	/* print the entry should happen on mptable identically */
+ 	mp_irq.type = MP_INTSRC;
+ 	mp_irq.irqtype = mp_INT;
+ 	mp_irq.irqflag = (trigger == ACPI_EDGE_SENSITIVE ? 4 : 0x0c) |
+ 				(polarity == ACPI_ACTIVE_HIGH ? 1 : 3);
+ 	mp_irq.srcbus = number;
+ 	mp_irq.srcbusirq = (((devfn >> 3) & 0x1f) << 2) | ((pin - 1) & 3);
+ 	ioapic = mp_find_ioapic(gsi);
+ 	mp_irq.dstapic = mpc_ioapic_id(ioapic);
+ 	mp_irq.dstirq = mp_find_ioapic_pin(ioapic, gsi);
+ 
+ 	mp_save_irq(&mp_irq);
+ #endif
+ 	return 0;
+ }
+ 
+ static int mp_register_gsi(struct device *dev, u32 gsi, int trigger,
+ 			   int polarity)
+ {
+ 	int ioapic;
+ 	int ioapic_pin;
+ 	struct io_apic_irq_attr irq_attr;
+ 	int ret;
+ 
+ 	if (acpi_irq_model != ACPI_IRQ_MODEL_IOAPIC)
+ 		return gsi;
+ 
+ 	/* Don't set up the ACPI SCI because it's already set up */
+ 	if (acpi_gbl_FADT.sci_interrupt == gsi)
+ 		return gsi;
+ 
+ 	ioapic = mp_find_ioapic(gsi);
+ 	if (ioapic < 0) {
+ 		printk(KERN_WARNING "No IOAPIC for GSI %u\n", gsi);
+ 		return gsi;
+ 	}
+ 
+ 	ioapic_pin = mp_find_ioapic_pin(ioapic, gsi);
+ 
+ 	if (ioapic_pin > MP_MAX_IOAPIC_PIN) {
+ 		printk(KERN_ERR "Invalid reference to IOAPIC pin "
+ 		       "%d-%d\n", mpc_ioapic_id(ioapic),
+ 		       ioapic_pin);
+ 		return gsi;
+ 	}
+ 
+ 	if (enable_update_mptable)
+ 		mp_config_acpi_gsi(dev, gsi, trigger, polarity);
+ 
+ 	set_io_apic_irq_attr(&irq_attr, ioapic, ioapic_pin,
+ 			     trigger == ACPI_EDGE_SENSITIVE ? 0 : 1,
+ 			     polarity == ACPI_ACTIVE_HIGH ? 0 : 1);
+ 	ret = io_apic_set_pci_routing(dev, gsi_to_irq(gsi), &irq_attr);
+ 	if (ret < 0)
+ 		gsi = ACPI_INVALID_GSI;
+ 
+ 	return gsi;
+ }
+ 
++>>>>>>> 95d76acc7518 (x86, irq: Count legacy IRQs by legacy_pic->nr_legacy_irqs instead of NR_IRQS_LEGACY)
  
  static int __init
  acpi_parse_ioapic(struct acpi_subtable_header * header, const unsigned long end)
@@@ -507,7 -629,8 +635,12 @@@ EXPORT_SYMBOL_GPL(acpi_gsi_to_irq)
  
  int acpi_isa_irq_to_gsi(unsigned isa_irq, u32 *gsi)
  {
++<<<<<<< HEAD
 +	if (isa_irq < NR_IRQS_LEGACY) {
++=======
+ 	if (isa_irq < nr_legacy_irqs() &&
+ 	    isa_irq_to_gsi[isa_irq] != ACPI_INVALID_GSI) {
++>>>>>>> 95d76acc7518 (x86, irq: Count legacy IRQs by legacy_pic->nr_legacy_irqs instead of NR_IRQS_LEGACY)
  		*gsi = isa_irq_to_gsi[isa_irq];
  		return 0;
  	}
diff --cc arch/x86/kernel/apic/io_apic.c
index 07a33b81b46c,4208ea9edc10..000000000000
--- a/arch/x86/kernel/apic/io_apic.c
+++ b/arch/x86/kernel/apic/io_apic.c
@@@ -3423,20 -3353,11 +3430,24 @@@ static int __init io_apic_get_redir_ent
  	return reg_01.bits.entries + 1;
  }
  
 -unsigned int arch_dynirq_lower_bound(unsigned int from)
 +static void __init probe_nr_irqs_gsi(void)
  {
++<<<<<<< HEAD
 +	int nr;
++=======
+ 	unsigned int min = gsi_top + nr_legacy_irqs();
++>>>>>>> 95d76acc7518 (x86, irq: Count legacy IRQs by legacy_pic->nr_legacy_irqs instead of NR_IRQS_LEGACY)
  
 -	return from < min ? min : from;
 +	nr = gsi_top + NR_IRQS_LEGACY;
 +	if (nr > nr_irqs_gsi)
 +		nr_irqs_gsi = nr;
 +
 +	printk(KERN_DEBUG "nr_irqs_gsi: %d\n", nr_irqs_gsi);
 +}
 +
 +int get_nr_irqs_gsi(void)
 +{
 +	return nr_irqs_gsi;
  }
  
  int __init arch_probe_nr_irqs(void)
@@@ -3446,12 -3367,12 +3457,20 @@@
  	if (nr_irqs > (NR_VECTORS * nr_cpu_ids))
  		nr_irqs = NR_VECTORS * nr_cpu_ids;
  
++<<<<<<< HEAD
 +	nr = nr_irqs_gsi + 8 * nr_cpu_ids;
++=======
+ 	nr = (gsi_top + nr_legacy_irqs()) + 8 * nr_cpu_ids;
++>>>>>>> 95d76acc7518 (x86, irq: Count legacy IRQs by legacy_pic->nr_legacy_irqs instead of NR_IRQS_LEGACY)
  #if defined(CONFIG_PCI_MSI) || defined(CONFIG_HT_IRQ)
  	/*
  	 * for MSI and HT dyn irq
  	 */
++<<<<<<< HEAD
 +	nr += nr_irqs_gsi * 16;
++=======
+ 	nr += gsi_top * 16;
++>>>>>>> 95d76acc7518 (x86, irq: Count legacy IRQs by legacy_pic->nr_legacy_irqs instead of NR_IRQS_LEGACY)
  #endif
  	if (nr < nr_irqs)
  		nr_irqs = nr;
diff --cc arch/x86/kernel/devicetree.c
index 442dd94a94f4,b4680058db8b..000000000000
--- a/arch/x86/kernel/devicetree.c
+++ b/arch/x86/kernel/devicetree.c
@@@ -20,6 -20,8 +20,11 @@@
  #include <asm/hpet.h>
  #include <asm/apic.h>
  #include <asm/pci_x86.h>
++<<<<<<< HEAD
++=======
+ #include <asm/setup.h>
+ #include <asm/i8259.h>
++>>>>>>> 95d76acc7518 (x86, irq: Count legacy IRQs by legacy_pic->nr_legacy_irqs instead of NR_IRQS_LEGACY)
  
  __initdata u64 initial_dtb;
  char __initdata cmd_line[COMMAND_LINE_SIZE];
@@@ -354,13 -331,11 +359,17 @@@ static void dt_add_ioapic_domain(unsign
  		 * and assigned so we can keep the 1:1 mapping which the ioapic
  		 * is having.
  		 */
++<<<<<<< HEAD
 +		ret = irq_domain_associate_many(id, 0, 0, NR_IRQS_LEGACY);
 +		if (ret)
 +			pr_err("Error mapping legacy IRQs: %d\n", ret);
++=======
+ 		irq_domain_associate_many(id, 0, 0, legacy_irqs);
++>>>>>>> 95d76acc7518 (x86, irq: Count legacy IRQs by legacy_pic->nr_legacy_irqs instead of NR_IRQS_LEGACY)
  
- 		if (num > NR_IRQS_LEGACY) {
- 			ret = irq_create_strict_mappings(id, NR_IRQS_LEGACY,
- 					NR_IRQS_LEGACY, num - NR_IRQS_LEGACY);
+ 		if (num > legacy_irqs) {
+ 			ret = irq_create_strict_mappings(id, legacy_irqs,
+ 					legacy_irqs, num - legacy_irqs);
  			if (ret)
  				pr_err("Error creating mapping for the "
  						"remaining IRQs: %d\n", ret);
diff --git a/arch/x86/include/asm/i8259.h b/arch/x86/include/asm/i8259.h
index a20365953bf8..ccffa53750a8 100644
--- a/arch/x86/include/asm/i8259.h
+++ b/arch/x86/include/asm/i8259.h
@@ -67,4 +67,9 @@ struct legacy_pic {
 extern struct legacy_pic *legacy_pic;
 extern struct legacy_pic null_legacy_pic;
 
+static inline int nr_legacy_irqs(void)
+{
+	return legacy_pic->nr_legacy_irqs;
+}
+
 #endif /* _ASM_X86_I8259_H */
* Unmerged path arch/x86/kernel/acpi/boot.c
* Unmerged path arch/x86/kernel/apic/io_apic.c
* Unmerged path arch/x86/kernel/devicetree.c
diff --git a/arch/x86/kernel/irqinit.c b/arch/x86/kernel/irqinit.c
index 7f50156542fb..a0111e91eb4b 100644
--- a/arch/x86/kernel/irqinit.c
+++ b/arch/x86/kernel/irqinit.c
@@ -78,7 +78,7 @@ void __init init_ISA_irqs(void)
 #endif
 	legacy_pic->init(0);
 
-	for (i = 0; i < legacy_pic->nr_legacy_irqs; i++)
+	for (i = 0; i < nr_legacy_irqs(); i++)
 		irq_set_chip_and_handler_name(i, chip, handle_level_irq, name);
 }
 
@@ -100,7 +100,7 @@ void __init init_IRQ(void)
 	 * then this vector space can be freed and re-used dynamically as the
 	 * irq's migrate etc.
 	 */
-	for (i = 0; i < legacy_pic->nr_legacy_irqs; i++)
+	for (i = 0; i < nr_legacy_irqs(); i++)
 		per_cpu(vector_irq, 0)[IRQ0_VECTOR + i] = i;
 
 	x86_init.irqs.intr_init();
@@ -121,7 +121,7 @@ void setup_vector_irq(int cpu)
 	 * legacy PIC, for the new cpu that is coming online, setup the static
 	 * legacy vector to irq mapping:
 	 */
-	for (irq = 0; irq < legacy_pic->nr_legacy_irqs; irq++)
+	for (irq = 0; irq < nr_legacy_irqs(); irq++)
 		per_cpu(vector_irq, cpu)[IRQ0_VECTOR + irq] = irq;
 #endif
 
diff --git a/arch/x86/pci/xen.c b/arch/x86/pci/xen.c
index cdd869f2c55d..68537b85526f 100644
--- a/arch/x86/pci/xen.c
+++ b/arch/x86/pci/xen.c
@@ -23,6 +23,7 @@
 #include <xen/features.h>
 #include <xen/events.h>
 #include <asm/xen/pci.h>
+#include <asm/i8259.h>
 
 static int xen_pcifront_enable_irq(struct pci_dev *dev)
 {
@@ -40,7 +41,7 @@ static int xen_pcifront_enable_irq(struct pci_dev *dev)
 	/* In PV DomU the Xen PCI backend puts the PIRQ in the interrupt line.*/
 	pirq = gsi;
 
-	if (gsi < NR_IRQS_LEGACY)
+	if (gsi < nr_legacy_irqs())
 		share = 0;
 
 	rc = xen_bind_pirq_gsi_to_irq(gsi, pirq, share, "pcifront");
@@ -489,7 +490,7 @@ int __init pci_xen_initial_domain(void)
 	xen_setup_acpi_sci();
 	__acpi_register_gsi = acpi_register_gsi_xen;
 	/* Pre-allocate legacy irqs */
-	for (irq = 0; irq < NR_IRQS_LEGACY; irq++) {
+	for (irq = 0; irq < nr_legacy_irqs(); irq++) {
 		int trigger, polarity;
 
 		if (acpi_get_override_irq(irq, &trigger, &polarity) == -1)
@@ -500,7 +501,7 @@ int __init pci_xen_initial_domain(void)
 			true /* Map GSI to PIRQ */);
 	}
 	if (0 == nr_ioapics) {
-		for (irq = 0; irq < NR_IRQS_LEGACY; irq++)
+		for (irq = 0; irq < nr_legacy_irqs(); irq++)
 			xen_bind_pirq_gsi_to_irq(irq, irq, 0, "xt-pic");
 	}
 	return 0;
