ALSA: hda - allow a codec to control the link power

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [alsa] hda - allow a codec to control the link power (Jaroslav Kysela) [1197064]
Rebuild_FUZZ: 93.75%
commit-author Mengdong Lin <mengdong.lin@intel.com>
commit a5e7e07c264bb76d0b7c782766989c491833de05
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/a5e7e07c.failed

A flag "link_power_control" is added to indicate whether a codec needs to
control the link power.  And a new bus ops link_power() is defined for the
codec to request to enable/disable the link power.

	Signed-off-by: Mengdong Lin <mengdong.lin@intel.com>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit a5e7e07c264bb76d0b7c782766989c491833de05)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/sound/hdaudio.h
#	sound/hda/hdac_device.c
#	sound/pci/hda/hda_codec.c
diff --cc sound/pci/hda/hda_codec.c
index d744f45d5fe3,a85242f7f973..000000000000
--- a/sound/pci/hda/hda_codec.c
+++ b/sound/pci/hda/hda_codec.c
@@@ -1234,15 -850,24 +1234,33 @@@ static bool snd_hda_codec_get_supported
  static unsigned int hda_set_power_state(struct hda_codec *codec,
  				unsigned int power_state);
  
++<<<<<<< HEAD
++=======
+ /* also called from hda_bind.c */
+ void snd_hda_codec_register(struct hda_codec *codec)
+ {
+ 	if (codec->registered)
+ 		return;
+ 	if (device_is_registered(hda_codec_dev(codec))) {
+ 		snd_hda_register_beep_device(codec);
+ 		snd_hdac_link_power(&codec->core, true);
+ 		pm_runtime_enable(hda_codec_dev(codec));
+ 		/* it was powered up in snd_hda_codec_new(), now all done */
+ 		snd_hda_power_down(codec);
+ 		codec->registered = 1;
+ 	}
+ }
+ 
++>>>>>>> a5e7e07c264b (ALSA: hda - allow a codec to control the link power)
  static int snd_hda_codec_dev_register(struct snd_device *device)
  {
 -	snd_hda_codec_register(device->device_data);
 +	struct hda_codec *codec = device->device_data;
 +
 +	snd_hda_register_beep_device(codec);
 +	if (device_is_registered(hda_codec_dev(codec))) {
 +		snd_hda_power_sync(codec);
 +		pm_runtime_enable(hda_codec_dev(codec));
 +	}
  	return 0;
  }
  
@@@ -1256,7 -881,12 +1274,16 @@@ static int snd_hda_codec_dev_disconnect
  
  static int snd_hda_codec_dev_free(struct snd_device *device)
  {
++<<<<<<< HEAD
 +	snd_hda_codec_free(device->device_data);
++=======
+ 	struct hda_codec *codec = device->device_data;
+ 
+ 	codec->in_freeing = 1;
+ 	snd_hdac_link_power(&codec->core, false);
+ 	snd_hdac_device_unregister(&codec->core);
+ 	put_device(hda_codec_dev(codec));
++>>>>>>> a5e7e07c264b (ALSA: hda - allow a codec to control the link power)
  	return 0;
  }
  
@@@ -4020,14 -3101,20 +4047,29 @@@ static int hda_codec_runtime_suspend(st
  	list_for_each_entry(pcm, &codec->pcm_list_head, list)
  		snd_pcm_suspend_all(pcm->pcm);
  	state = hda_call_codec_suspend(codec);
++<<<<<<< HEAD
 +	if (!codec->bus->power_keep_link_on && (state & AC_PWRST_CLK_STOP_OK))
 +		hda_call_pm_notify(codec, false);
++=======
+ 	if (codec_has_clkstop(codec) && codec_has_epss(codec) &&
+ 	    (state & AC_PWRST_CLK_STOP_OK))
+ 		snd_hdac_codec_link_down(&codec->core);
+ 	snd_hdac_link_power(&codec->core, false);
++>>>>>>> a5e7e07c264b (ALSA: hda - allow a codec to control the link power)
  	return 0;
  }
  
  static int hda_codec_runtime_resume(struct device *dev)
  {
++<<<<<<< HEAD
 +	hda_call_codec_resume(dev_to_hda_codec(dev));
++=======
+ 	struct hda_codec *codec = dev_to_hda_codec(dev);
+ 
+ 	snd_hdac_link_power(&codec->core, true);
+ 	snd_hdac_codec_link_up(&codec->core);
+ 	hda_call_codec_resume(codec);
++>>>>>>> a5e7e07c264b (ALSA: hda - allow a codec to control the link power)
  	pm_runtime_mark_last_busy(dev);
  	return 0;
  }
* Unmerged path include/sound/hdaudio.h
* Unmerged path sound/hda/hdac_device.c
* Unmerged path include/sound/hdaudio.h
* Unmerged path sound/hda/hdac_device.c
* Unmerged path sound/pci/hda/hda_codec.c
