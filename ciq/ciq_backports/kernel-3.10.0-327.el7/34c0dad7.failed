s390/hypfs: Add diagnose 0c support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [s390] hypfs: Add diagnose 0c support (Hendrik Brueckner) [1182292]
Rebuild_FUZZ: 92.31%
commit-author Michael Holzheu <holzheu@linux.vnet.ibm.com>
commit 34c0dad752294f373a0720840f59e186788ba227
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/34c0dad7.failed

With this feature, you can read the CPU performance metrics provided by the
z/VM diagnose 0C. This then allows to get the management time for each
online CPU of the guest where the diagnose is executed.

The new debugfs file /sys/kernel/debug/s390_hypfs/diag_0c exports the
diag0C binary data to user space via an open/read/close interface.

The binary data consists out of a header structure followed by an
array that contains the diagnose 0c data for each online CPU.

	Signed-off-by: Michael Holzheu <holzheu@linux.vnet.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 34c0dad752294f373a0720840f59e186788ba227)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/hypfs/Makefile
#	arch/s390/hypfs/hypfs.h
#	arch/s390/hypfs/inode.c
#	arch/s390/include/uapi/asm/hypfs.h
diff --cc arch/s390/hypfs/Makefile
index 2e671d5004ca,2ee25ba252d6..000000000000
--- a/arch/s390/hypfs/Makefile
+++ b/arch/s390/hypfs/Makefile
@@@ -4,4 -4,5 +4,9 @@@
  
  obj-$(CONFIG_S390_HYPFS_FS) += s390_hypfs.o
  
++<<<<<<< HEAD
 +s390_hypfs-objs := inode.o hypfs_diag.o hypfs_vm.o hypfs_dbfs.o
++=======
+ s390_hypfs-objs := inode.o hypfs_diag.o hypfs_vm.o hypfs_dbfs.o hypfs_sprp.o
+ s390_hypfs-objs += hypfs_diag0c.o
++>>>>>>> 34c0dad75229 (s390/hypfs: Add diagnose 0c support)
diff --cc arch/s390/hypfs/hypfs.h
index f41e0ef7fdf9,36d093fa9fb3..000000000000
--- a/arch/s390/hypfs/hypfs.h
+++ b/arch/s390/hypfs/hypfs.h
@@@ -37,7 -35,15 +37,19 @@@ extern int hypfs_diag_create_files(stru
  /* VM Hypervisor */
  extern int hypfs_vm_init(void);
  extern void hypfs_vm_exit(void);
++<<<<<<< HEAD
 +extern int hypfs_vm_create_files(struct super_block *sb, struct dentry *root);
++=======
+ extern int hypfs_vm_create_files(struct dentry *root);
+ 
+ /* VM diagnose 0c */
+ int hypfs_diag0c_init(void);
+ void hypfs_diag0c_exit(void);
+ 
+ /* Set Partition-Resource Parameter */
+ int hypfs_sprp_init(void);
+ void hypfs_sprp_exit(void);
++>>>>>>> 34c0dad75229 (s390/hypfs: Add diagnose 0c support)
  
  /* debugfs interface */
  struct hypfs_dbfs_file;
diff --cc arch/s390/hypfs/inode.c
index 7a539f4f5e30,4c8008dd938e..000000000000
--- a/arch/s390/hypfs/inode.c
+++ b/arch/s390/hypfs/inode.c
@@@ -482,10 -478,18 +482,25 @@@ static int __init hypfs_init(void
  		rc = -ENODATA;
  		goto fail_hypfs_diag_exit;
  	}
++<<<<<<< HEAD
 +	s390_kobj = kobject_create_and_add("s390", hypervisor_kobj);
 +	if (!s390_kobj) {
 +		rc = -ENOMEM;
 +		goto fail_hypfs_vm_exit;
++=======
+ 	if (hypfs_sprp_init()) {
+ 		rc = -ENODATA;
+ 		goto fail_hypfs_vm_exit;
+ 	}
+ 	if (hypfs_diag0c_init()) {
+ 		rc = -ENODATA;
+ 		goto fail_hypfs_sprp_exit;
+ 	}
+ 	s390_kobj = kobject_create_and_add("s390", hypervisor_kobj);
+ 	if (!s390_kobj) {
+ 		rc = -ENOMEM;
+ 		goto fail_hypfs_diag0c_exit;
++>>>>>>> 34c0dad75229 (s390/hypfs: Add diagnose 0c support)
  	}
  	rc = register_filesystem(&hypfs_type);
  	if (rc)
@@@ -494,6 -498,10 +509,13 @@@
  
  fail_filesystem:
  	kobject_put(s390_kobj);
++<<<<<<< HEAD
++=======
+ fail_hypfs_diag0c_exit:
+ 	hypfs_diag0c_exit();
+ fail_hypfs_sprp_exit:
+ 	hypfs_sprp_exit();
++>>>>>>> 34c0dad75229 (s390/hypfs: Add diagnose 0c support)
  fail_hypfs_vm_exit:
  	hypfs_vm_exit();
  fail_hypfs_diag_exit:
@@@ -506,11 -514,13 +528,19 @@@ fail_dbfs_exit
  
  static void __exit hypfs_exit(void)
  {
 +	hypfs_diag_exit();
 +	hypfs_vm_exit();
 +	hypfs_dbfs_exit();
  	unregister_filesystem(&hypfs_type);
  	kobject_put(s390_kobj);
++<<<<<<< HEAD
++=======
+ 	hypfs_diag0c_exit();
+ 	hypfs_sprp_exit();
+ 	hypfs_vm_exit();
+ 	hypfs_diag_exit();
+ 	hypfs_dbfs_exit();
++>>>>>>> 34c0dad75229 (s390/hypfs: Add diagnose 0c support)
  }
  
  module_init(hypfs_init)
* Unmerged path arch/s390/include/uapi/asm/hypfs.h
* Unmerged path arch/s390/hypfs/Makefile
* Unmerged path arch/s390/hypfs/hypfs.h
diff --git a/arch/s390/hypfs/hypfs_diag0c.c b/arch/s390/hypfs/hypfs_diag0c.c
new file mode 100644
index 000000000000..d4c0d3717543
--- /dev/null
+++ b/arch/s390/hypfs/hypfs_diag0c.c
@@ -0,0 +1,139 @@
+/*
+ * Hypervisor filesystem for Linux on s390
+ *
+ * Diag 0C implementation
+ *
+ * Copyright IBM Corp. 2014
+ */
+
+#include <linux/slab.h>
+#include <linux/cpu.h>
+#include <asm/hypfs.h>
+#include "hypfs.h"
+
+#define DBFS_D0C_HDR_VERSION 0
+
+/*
+ * Execute diagnose 0c in 31 bit mode
+ */
+static void diag0c(struct hypfs_diag0c_entry *entry)
+{
+	asm volatile (
+#ifdef CONFIG_64BIT
+		"	sam31\n"
+		"	diag	%0,%0,0x0c\n"
+		"	sam64\n"
+#else
+		"	diag %0,%0,0x0c\n"
+#endif
+		: /* no output register */
+		: "a" (entry)
+		: "memory");
+}
+
+/*
+ * Get hypfs_diag0c_entry from CPU vector and store diag0c data
+ */
+static void diag0c_fn(void *data)
+{
+	diag0c(((void **) data)[smp_processor_id()]);
+}
+
+/*
+ * Allocate buffer and store diag 0c data
+ */
+static void *diag0c_store(unsigned int *count)
+{
+	struct hypfs_diag0c_data *diag0c_data;
+	unsigned int cpu_count, cpu, i;
+	void **cpu_vec;
+
+	get_online_cpus();
+	cpu_count = num_online_cpus();
+	cpu_vec = kmalloc(sizeof(*cpu_vec) * num_possible_cpus(), GFP_KERNEL);
+	if (!cpu_vec)
+		goto fail_put_online_cpus;
+	/* Note: Diag 0c needs 8 byte alignment and real storage */
+	diag0c_data = kzalloc(sizeof(struct hypfs_diag0c_hdr) +
+			      cpu_count * sizeof(struct hypfs_diag0c_entry),
+			      GFP_KERNEL | GFP_DMA);
+	if (!diag0c_data)
+		goto fail_kfree_cpu_vec;
+	i = 0;
+	/* Fill CPU vector for each online CPU */
+	for_each_online_cpu(cpu) {
+		diag0c_data->entry[i].cpu = cpu;
+		cpu_vec[cpu] = &diag0c_data->entry[i++];
+	}
+	/* Collect data all CPUs */
+	on_each_cpu(diag0c_fn, cpu_vec, 1);
+	*count = cpu_count;
+	kfree(cpu_vec);
+	put_online_cpus();
+	return diag0c_data;
+
+fail_kfree_cpu_vec:
+	kfree(cpu_vec);
+fail_put_online_cpus:
+	put_online_cpus();
+	return ERR_PTR(-ENOMEM);
+}
+
+/*
+ * Hypfs DBFS callback: Free diag 0c data
+ */
+static void dbfs_diag0c_free(const void *data)
+{
+	kfree(data);
+}
+
+/*
+ * Hypfs DBFS callback: Create diag 0c data
+ */
+static int dbfs_diag0c_create(void **data, void **data_free_ptr, size_t *size)
+{
+	struct hypfs_diag0c_data *diag0c_data;
+	unsigned int count;
+
+	diag0c_data = diag0c_store(&count);
+	if (IS_ERR(diag0c_data))
+		return PTR_ERR(diag0c_data);
+	memset(&diag0c_data->hdr, 0, sizeof(diag0c_data->hdr));
+	get_tod_clock_ext(diag0c_data->hdr.tod_ext);
+	diag0c_data->hdr.len = count * sizeof(struct hypfs_diag0c_entry);
+	diag0c_data->hdr.version = DBFS_D0C_HDR_VERSION;
+	diag0c_data->hdr.count = count;
+	*data = diag0c_data;
+	*data_free_ptr = diag0c_data;
+	*size = diag0c_data->hdr.len + sizeof(struct hypfs_diag0c_hdr);
+	return 0;
+}
+
+/*
+ * Hypfs DBFS file structure
+ */
+static struct hypfs_dbfs_file dbfs_file_0c = {
+	.name		= "diag_0c",
+	.data_create	= dbfs_diag0c_create,
+	.data_free	= dbfs_diag0c_free,
+};
+
+/*
+ * Initialize diag 0c interface for z/VM
+ */
+int __init hypfs_diag0c_init(void)
+{
+	if (!MACHINE_IS_VM)
+		return 0;
+	return hypfs_dbfs_create_file(&dbfs_file_0c);
+}
+
+/*
+ * Shutdown diag 0c interface for z/VM
+ */
+void hypfs_diag0c_exit(void)
+{
+	if (!MACHINE_IS_VM)
+		return;
+	hypfs_dbfs_remove_file(&dbfs_file_0c);
+}
* Unmerged path arch/s390/hypfs/inode.c
* Unmerged path arch/s390/include/uapi/asm/hypfs.h
