ethtool: Support for configurable RSS hash function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Eyal Perry <eyalpe@mellanox.com>
commit 892311f66f2411b813ca631009356891a0c2b0a1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/892311f6.failed

This patch extends the set/get_rxfh ethtool-options for getting or
setting the RSS hash function.

It modifies drivers implementation of set/get_rxfh accordingly.

This change also delegates the responsibility of checking whether a
modification to a certain RX flow hash parameter is supported to the
driver implementation of set_rxfh.

User-kernel API is done through the new hfunc bitmask field in the
ethtool_rxfh struct. A bit set in the hfunc field is corresponding to an
index in the new string-set ETH_SS_RSS_HASH_FUNCS.

Got approval from most of the relevant driver maintainers that their
driver is using Toeplitz, and for the few that didn't answered, also
assumed it is Toeplitz.

	Cc: Tom Lendacky <thomas.lendacky@amd.com>
	Cc: Ariel Elior <ariel.elior@qlogic.com>
	Cc: Prashant Sreedharan <prashant@broadcom.com>
	Cc: Michael Chan <mchan@broadcom.com>
	Cc: Hariprasad S <hariprasad@chelsio.com>
	Cc: Sathya Perla <sathya.perla@emulex.com>
	Cc: Subbu Seetharaman <subbu.seetharaman@emulex.com>
	Cc: Ajit Khaparde <ajit.khaparde@emulex.com>
	Cc: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
	Cc: Jesse Brandeburg <jesse.brandeburg@intel.com>
	Cc: Bruce Allan <bruce.w.allan@intel.com>
	Cc: Carolyn Wyborny <carolyn.wyborny@intel.com>
	Cc: Don Skidmore <donald.c.skidmore@intel.com>
	Cc: Greg Rose <gregory.v.rose@intel.com>
	Cc: Matthew Vick <matthew.vick@intel.com>
	Cc: John Ronciak <john.ronciak@intel.com>
	Cc: Mitch Williams <mitch.a.williams@intel.com>
	Cc: Amir Vadai <amirv@mellanox.com>
	Cc: Solarflare linux maintainers <linux-net-drivers@solarflare.com>
	Cc: Shradha Shah <sshah@solarflare.com>
	Cc: Shreyas Bhatewara <sbhatewara@vmware.com>
	Cc: "VMware, Inc." <pv-drivers@vmware.com>
	Cc: Ben Hutchings <ben@decadent.org.uk>
	Signed-off-by: Eyal Perry <eyalpe@mellanox.com>
	Signed-off-by: Amir Vadai <amirv@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 892311f66f2411b813ca631009356891a0c2b0a1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c
#	drivers/net/ethernet/broadcom/bnx2x/bnx2x_ethtool.c
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
#	drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
#	drivers/net/ethernet/intel/igb/igb_ethtool.c
#	drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
#	drivers/net/ethernet/sfc/ethtool.c
#	drivers/net/vmxnet3/vmxnet3_ethtool.c
#	include/linux/ethtool.h
#	include/uapi/linux/ethtool.h
#	net/core/ethtool.c
diff --cc drivers/net/ethernet/broadcom/bnx2x/bnx2x_ethtool.c
index faf5d7ce7417,ffe4e003e636..000000000000
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_ethtool.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_ethtool.c
@@@ -3370,7 -3358,8 +3370,12 @@@ static u32 bnx2x_get_rxfh_indir_size(st
  	return T_ETH_INDIRECTION_TABLE_SIZE;
  }
  
++<<<<<<< HEAD
 +static int bnx2x_get_rxfh_indir(struct net_device *dev, u32 *indir)
++=======
+ static int bnx2x_get_rxfh(struct net_device *dev, u32 *indir, u8 *key,
+ 			  u8 *hfunc)
++>>>>>>> 892311f66f24 (ethtool: Support for configurable RSS hash function)
  {
  	struct bnx2x *bp = netdev_priv(dev);
  	u8 ind_table[T_ETH_INDIRECTION_TABLE_SIZE] = {0};
@@@ -3394,14 -3388,25 +3404,29 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int bnx2x_set_rxfh_indir(struct net_device *dev, const u32 *indir)
++=======
+ static int bnx2x_set_rxfh(struct net_device *dev, const u32 *indir,
+ 			  const u8 *key, const u8 hfunc)
++>>>>>>> 892311f66f24 (ethtool: Support for configurable RSS hash function)
  {
  	struct bnx2x *bp = netdev_priv(dev);
  	size_t i;
  
+ 	/* We require at least one supported parameter to be changed and no
+ 	 * change in any of the unsupported parameters
+ 	 */
+ 	if (key ||
+ 	    (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP))
+ 		return -EOPNOTSUPP;
+ 
+ 	if (!indir)
+ 		return 0;
+ 
  	for (i = 0; i < T_ETH_INDIRECTION_TABLE_SIZE; i++) {
  		/*
 -		 * The same as in bnx2x_get_rxfh: we can't use a memcpy()
 +		 * The same as in bnx2x_get_rxfh_indir: we can't use a memcpy()
  		 * as an internal storage of an indirection table is a u8 array
  		 * while indir->ring_index points to an array of u32.
  		 *
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
index 9df6656ca8da,e7342bc85026..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@@ -2847,7 -2923,7 +2847,11 @@@ static u32 get_rss_table_size(struct ne
  	return pi->rss_size;
  }
  
++<<<<<<< HEAD
 +static int get_rss_table(struct net_device *dev, u32 *p)
++=======
+ static int get_rss_table(struct net_device *dev, u32 *p, u8 *key, u8 *hfunc)
++>>>>>>> 892311f66f24 (ethtool: Support for configurable RSS hash function)
  {
  	const struct port_info *pi = netdev_priv(dev);
  	unsigned int n = pi->rss_size;
@@@ -2857,7 -2937,8 +2865,12 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int set_rss_table(struct net_device *dev, const u32 *p)
++=======
+ static int set_rss_table(struct net_device *dev, const u32 *p, const u8 *key,
+ 			 const u8 hfunc)
++>>>>>>> 892311f66f24 (ethtool: Support for configurable RSS hash function)
  {
  	unsigned int i;
  	struct port_info *pi = netdev_priv(dev);
diff --cc drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
index 196d1b8bae8e,69b97bac182c..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
@@@ -627,7 -626,9 +627,12 @@@ static u32 i40evf_get_rxfh_indir_size(s
   *
   * Reads the indirection table directly from the hardware. Always returns 0.
   **/
++<<<<<<< HEAD
 +static int i40evf_get_rxfh_indir(struct net_device *netdev, u32 *indir)
++=======
+ static int i40evf_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,
+ 			   u8 *hfunc)
++>>>>>>> 892311f66f24 (ethtool: Support for configurable RSS hash function)
  {
  	struct i40evf_adapter *adapter = netdev_priv(netdev);
  	struct i40e_hw *hw = &adapter->hw;
@@@ -652,7 -659,8 +662,12 @@@
   * Returns -EINVAL if the table specifies an inavlid queue id, otherwise
   * returns 0 after programming the table.
   **/
++<<<<<<< HEAD
 +static int i40evf_set_rxfh_indir(struct net_device *netdev, const u32 *indir)
++=======
+ static int i40evf_set_rxfh(struct net_device *netdev, const u32 *indir,
+ 			   const u8 *key, const u8 hfunc)
++>>>>>>> 892311f66f24 (ethtool: Support for configurable RSS hash function)
  {
  	struct i40evf_adapter *adapter = netdev_priv(netdev);
  	struct i40e_hw *hw = &adapter->hw;
diff --cc drivers/net/ethernet/intel/igb/igb_ethtool.c
index 0e1b8ff08d08,d5673eb90c54..000000000000
--- a/drivers/net/ethernet/intel/igb/igb_ethtool.c
+++ b/drivers/net/ethernet/intel/igb/igb_ethtool.c
@@@ -2842,7 -2842,8 +2842,12 @@@ static u32 igb_get_rxfh_indir_size(stru
  	return IGB_RETA_SIZE;
  }
  
++<<<<<<< HEAD
 +static int igb_get_rxfh_indir(struct net_device *netdev, u32 *indir)
++=======
+ static int igb_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,
+ 			u8 *hfunc)
++>>>>>>> 892311f66f24 (ethtool: Support for configurable RSS hash function)
  {
  	struct igb_adapter *adapter = netdev_priv(netdev);
  	int i;
@@@ -2888,7 -2893,8 +2897,12 @@@ void igb_write_rss_indir_tbl(struct igb
  	}
  }
  
++<<<<<<< HEAD
 +static int igb_set_rxfh_indir(struct net_device *netdev, const u32 *indir)
++=======
+ static int igb_set_rxfh(struct net_device *netdev, const u32 *indir,
+ 			const u8 *key, const u8 hfunc)
++>>>>>>> 892311f66f24 (ethtool: Support for configurable RSS hash function)
  {
  	struct igb_adapter *adapter = netdev_priv(netdev);
  	struct e1000_hw *hw = &adapter->hw;
diff --cc drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
index 12606f2da954,28c3fc5a0791..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
@@@ -972,7 -973,13 +972,17 @@@ static u32 mlx4_en_get_rxfh_indir_size(
  	return priv->rx_ring_num;
  }
  
++<<<<<<< HEAD
 +static int mlx4_en_get_rxfh_indir(struct net_device *dev, u32 *ring_index)
++=======
+ static u32 mlx4_en_get_rxfh_key_size(struct net_device *netdev)
+ {
+ 	return MLX4_EN_RSS_KEY_SIZE;
+ }
+ 
+ static int mlx4_en_get_rxfh(struct net_device *dev, u32 *ring_index, u8 *key,
+ 			    u8 *hfunc)
++>>>>>>> 892311f66f24 (ethtool: Support for configurable RSS hash function)
  {
  	struct mlx4_en_priv *priv = netdev_priv(dev);
  	struct mlx4_en_rss_map *rss_map = &priv->rss_map;
@@@ -981,17 -988,23 +991,31 @@@
  	int err = 0;
  
  	rss_rings = priv->prof->rss_rings ?: priv->rx_ring_num;
 -	rss_rings = 1 << ilog2(rss_rings);
  
  	while (n--) {
+ 		if (!ring_index)
+ 			break;
  		ring_index[n] = rss_map->qps[n % rss_rings].qpn -
  			rss_map->base_qpn;
  	}
++<<<<<<< HEAD
 +
 +	return err;
 +}
 +
 +static int mlx4_en_set_rxfh_indir(struct net_device *dev,
 +		const u32 *ring_index)
++=======
+ 	if (key)
+ 		memcpy(key, priv->rss_key, MLX4_EN_RSS_KEY_SIZE);
+ 	if (hfunc)
+ 		*hfunc = ETH_RSS_HASH_TOP;
+ 	return err;
+ }
+ 
+ static int mlx4_en_set_rxfh(struct net_device *dev, const u32 *ring_index,
+ 			    const u8 *key, const u8 hfunc)
++>>>>>>> 892311f66f24 (ethtool: Support for configurable RSS hash function)
  {
  	struct mlx4_en_priv *priv = netdev_priv(dev);
  	struct mlx4_en_dev *mdev = priv->mdev;
diff --cc drivers/net/ethernet/sfc/ethtool.c
index bcc750cd3858,4835bc0d0de8..000000000000
--- a/drivers/net/ethernet/sfc/ethtool.c
+++ b/drivers/net/ethernet/sfc/ethtool.c
@@@ -1086,7 -1086,8 +1086,12 @@@ static u32 efx_ethtool_get_rxfh_indir_s
  		0 : ARRAY_SIZE(efx->rx_indir_table));
  }
  
++<<<<<<< HEAD
 +static int efx_ethtool_get_rxfh_indir(struct net_device *net_dev, u32 *indir)
++=======
+ static int efx_ethtool_get_rxfh(struct net_device *net_dev, u32 *indir, u8 *key,
+ 				u8 *hfunc)
++>>>>>>> 892311f66f24 (ethtool: Support for configurable RSS hash function)
  {
  	struct efx_nic *efx = netdev_priv(net_dev);
  
@@@ -1094,8 -1098,8 +1102,13 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int efx_ethtool_set_rxfh_indir(struct net_device *net_dev,
 +				      const u32 *indir)
++=======
+ static int efx_ethtool_set_rxfh(struct net_device *net_dev, const u32 *indir,
+ 				const u8 *key, const u8 hfunc)
++>>>>>>> 892311f66f24 (ethtool: Support for configurable RSS hash function)
  {
  	struct efx_nic *efx = netdev_priv(net_dev);
  
diff --cc drivers/net/vmxnet3/vmxnet3_ethtool.c
index 2c52b7bbaae9,b7b53329d575..000000000000
--- a/drivers/net/vmxnet3/vmxnet3_ethtool.c
+++ b/drivers/net/vmxnet3/vmxnet3_ethtool.c
@@@ -596,7 -583,7 +596,11 @@@ vmxnet3_get_rss_indir_size(struct net_d
  }
  
  static int
++<<<<<<< HEAD
 +vmxnet3_get_rss_indir(struct net_device *netdev, u32 *p)
++=======
+ vmxnet3_get_rss(struct net_device *netdev, u32 *p, u8 *key, u8 *hfunc)
++>>>>>>> 892311f66f24 (ethtool: Support for configurable RSS hash function)
  {
  	struct vmxnet3_adapter *adapter = netdev_priv(netdev);
  	struct UPT1_RSSConf *rssConf = adapter->rss_conf;
@@@ -609,7 -600,8 +617,12 @@@
  }
  
  static int
++<<<<<<< HEAD
 +vmxnet3_set_rss_indir(struct net_device *netdev, const u32 *p)
++=======
+ vmxnet3_set_rss(struct net_device *netdev, const u32 *p, const u8 *key,
+ 		const u8 hfunc)
++>>>>>>> 892311f66f24 (ethtool: Support for configurable RSS hash function)
  {
  	unsigned int i;
  	unsigned long flags;
diff --cc include/linux/ethtool.h
index 6e8596938354,653dc9c4ebac..000000000000
--- a/include/linux/ethtool.h
+++ b/include/linux/ethtool.h
@@@ -159,21 -178,14 +179,31 @@@ static inline u32 ethtool_rxfh_indir_de
   *	Returns zero if not supported for this specific device.
   * @get_rxfh_indir_size: Get the size of the RX flow hash indirection table.
   *	Returns zero if not supported for this specific device.
++<<<<<<< HEAD
 + * @get_rxfh_indir: Get the contents of the RX flow hash indirection table.
 + *	Will not be called if @get_rxfh_indir_size returns zero.
 + * @get_rxfh: Get the contents of the RX flow hash indirection table and hash
 + *	key.
 + *	Will only be called if one or both of @get_rxfh_indir_size and
 + *	@get_rxfh_key_size are implemented and return non-zero.
 + *	Returns a negative error code or zero.
 + * @set_rxfh_indir: Set the contents of the RX flow hash indirection table.
 + *	Will not be called if @get_rxfh_indir_size returns zero.
 + * @set_rxfh: Set the contents of the RX flow hash indirection table and/or
 + *	hash key.  In case only the indirection table or hash key is to be
 + *	changed, the other argument will be %NULL.
 + *	Will only be called if one or both of @get_rxfh_indir_size and
 + *	@get_rxfh_key_size are implemented and return non-zero.
++=======
+  * @get_rxfh: Get the contents of the RX flow hash indirection table, hash key
+  *	and/or hash function.
++>>>>>>> 892311f66f24 (ethtool: Support for configurable RSS hash function)
   *	Returns a negative error code or zero.
+  * @set_rxfh: Set the contents of the RX flow hash indirection table, hash
+  *	key, and/or hash function.  Arguments which are set to %NULL or zero
+  *	will remain unchanged.
+  *	Returns a negative error code or zero. An error code must be returned
+  *	if at least one unsupported change was requested.
   * @get_channels: Get number of channels.
   * @set_channels: Set number of channels.  Returns a negative error code or
   *	zero.
@@@ -241,9 -256,12 +271,16 @@@ struct ethtool_ops 
  	int	(*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *);
  	int	(*flash_device)(struct net_device *, struct ethtool_flash *);
  	int	(*reset)(struct net_device *, u32 *);
 -	u32	(*get_rxfh_key_size)(struct net_device *);
  	u32	(*get_rxfh_indir_size)(struct net_device *);
++<<<<<<< HEAD
 +	int	(*get_rxfh_indir)(struct net_device *, u32 *);
 +	int	(*set_rxfh_indir)(struct net_device *, const u32 *);
++=======
+ 	int	(*get_rxfh)(struct net_device *, u32 *indir, u8 *key,
+ 			    u8 *hfunc);
+ 	int	(*set_rxfh)(struct net_device *, const u32 *indir,
+ 			    const u8 *key, const u8 hfunc);
++>>>>>>> 892311f66f24 (ethtool: Support for configurable RSS hash function)
  	void	(*get_channels)(struct net_device *, struct ethtool_channels *);
  	int	(*set_channels)(struct net_device *, struct ethtool_channels *);
  	int	(*get_dump_flag)(struct net_device *, struct ethtool_dump *);
diff --cc include/uapi/linux/ethtool.h
index 90014c0c97db,5f66d9c2889d..000000000000
--- a/include/uapi/linux/ethtool.h
+++ b/include/uapi/linux/ethtool.h
@@@ -349,19 -524,43 +349,35 @@@ struct ethtool_pauseparam 
  };
  
  #define ETH_GSTRING_LEN		32
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * enum ethtool_stringset - string set ID
+  * @ETH_SS_TEST: Self-test result names, for use with %ETHTOOL_TEST
+  * @ETH_SS_STATS: Statistic names, for use with %ETHTOOL_GSTATS
+  * @ETH_SS_PRIV_FLAGS: Driver private flag names, for use with
+  *	%ETHTOOL_GPFLAGS and %ETHTOOL_SPFLAGS
+  * @ETH_SS_NTUPLE_FILTERS: Previously used with %ETHTOOL_GRXNTUPLE;
+  *	now deprecated
+  * @ETH_SS_FEATURES: Device feature names
+  * @ETH_SS_RSS_HASH_FUNCS: RSS hush function names
+  */
++>>>>>>> 892311f66f24 (ethtool: Support for configurable RSS hash function)
  enum ethtool_stringset {
  	ETH_SS_TEST		= 0,
  	ETH_SS_STATS,
  	ETH_SS_PRIV_FLAGS,
 -	ETH_SS_NTUPLE_FILTERS,
 +	ETH_SS_NTUPLE_FILTERS,	/* Do not use, GRXNTUPLE is now deprecated */
  	ETH_SS_FEATURES,
+ 	ETH_SS_RSS_HASH_FUNCS,
  };
  
 -/**
 - * struct ethtool_gstrings - string set for data tagging
 - * @cmd: Command number = %ETHTOOL_GSTRINGS
 - * @string_set: String set ID; one of &enum ethtool_stringset
 - * @len: On return, the number of strings in the string set
 - * @data: Buffer for strings.  Each string is null-padded to a size of
 - *	%ETH_GSTRING_LEN.
 - *
 - * Users must use %ETHTOOL_GSSET_INFO to find the number of strings in
 - * the string set.  They must allocate a buffer of the appropriate
 - * size immediately following this structure.
 - */
 +/* for passing string sets for data tagging */
  struct ethtool_gstrings {
 -	__u32	cmd;
 -	__u32	string_set;
 -	__u32	len;
 +	__u32	cmd;		/* ETHTOOL_GSTRINGS */
 +	__u32	string_set;	/* string set id e.c. ETH_SS_TEST, etc*/
 +	__u32	len;		/* number of strings in the string set */
  	__u8	data[0];
  };
  
diff --cc net/core/ethtool.c
index b1125e9eff66,550892cd6b3f..000000000000
--- a/net/core/ethtool.c
+++ b/net/core/ethtool.c
@@@ -598,9 -630,7 +610,13 @@@ static noinline_for_stack int ethtool_g
  	if (!indir)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	ret = dev->ethtool_ops->get_rxfh ?
 +		dev->ethtool_ops->get_rxfh(dev, indir, NULL) :
 +		dev->ethtool_ops->get_rxfh_indir(dev, indir);
++=======
+ 	ret = dev->ethtool_ops->get_rxfh(dev, indir, NULL, NULL);
++>>>>>>> 892311f66f24 (ethtool: Support for configurable RSS hash function)
  	if (ret)
  		goto out;
  
@@@ -661,8 -691,7 +677,12 @@@ static noinline_for_stack int ethtool_s
  			goto out;
  	}
  
++<<<<<<< HEAD
 +	ret = ops->set_rxfh ? ops->set_rxfh(dev, indir, NULL) :
 +		ops->set_rxfh_indir(dev, indir);
++=======
+ 	ret = ops->set_rxfh(dev, indir, NULL, ETH_RSS_HASH_NO_CHANGE);
++>>>>>>> 892311f66f24 (ethtool: Support for configurable RSS hash function)
  
  out:
  	kfree(indir);
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c
* Unmerged path drivers/net/ethernet/broadcom/bnx2x/bnx2x_ethtool.c
diff --git a/drivers/net/ethernet/broadcom/tg3.c b/drivers/net/ethernet/broadcom/tg3.c
index 5ea0a589627b..f4b6795ce2aa 100644
--- a/drivers/net/ethernet/broadcom/tg3.c
+++ b/drivers/net/ethernet/broadcom/tg3.c
@@ -12562,22 +12562,38 @@ static u32 tg3_get_rxfh_indir_size(struct net_device *dev)
 	return size;
 }
 
-static int tg3_get_rxfh(struct net_device *dev, u32 *indir, u8 *key)
+static int tg3_get_rxfh(struct net_device *dev, u32 *indir, u8 *key, u8 *hfunc)
 {
 	struct tg3 *tp = netdev_priv(dev);
 	int i;
 
+	if (hfunc)
+		*hfunc = ETH_RSS_HASH_TOP;
+	if (!indir)
+		return 0;
+
 	for (i = 0; i < TG3_RSS_INDIR_TBL_SIZE; i++)
 		indir[i] = tp->rss_ind_tbl[i];
 
 	return 0;
 }
 
-static int tg3_set_rxfh(struct net_device *dev, const u32 *indir, const u8 *key)
+static int tg3_set_rxfh(struct net_device *dev, const u32 *indir, const u8 *key,
+			const u8 hfunc)
 {
 	struct tg3 *tp = netdev_priv(dev);
 	size_t i;
 
+	/* We require at least one supported parameter to be changed and no
+	 * change in any of the unsupported parameters
+	 */
+	if (key ||
+	    (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP))
+		return -EOPNOTSUPP;
+
+	if (!indir)
+		return 0;
+
 	for (i = 0; i < TG3_RSS_INDIR_TBL_SIZE; i++)
 		tp->rss_ind_tbl[i] = indir[i];
 
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
diff --git a/drivers/net/ethernet/emulex/benet/be_ethtool.c b/drivers/net/ethernet/emulex/benet/be_ethtool.c
index abdfa387832d..debae72b5418 100644
--- a/drivers/net/ethernet/emulex/benet/be_ethtool.c
+++ b/drivers/net/ethernet/emulex/benet/be_ethtool.c
@@ -1171,7 +1171,8 @@ static u32 be_get_rxfh_key_size(struct net_device *netdev)
 	return RSS_HASH_KEY_LEN;
 }
 
-static int be_get_rxfh(struct net_device *netdev, u32 *indir, u8 *hkey)
+static int be_get_rxfh(struct net_device *netdev, u32 *indir, u8 *hkey,
+		       u8 *hfunc)
 {
 	struct be_adapter *adapter = netdev_priv(netdev);
 	int i;
@@ -1185,16 +1186,23 @@ static int be_get_rxfh(struct net_device *netdev, u32 *indir, u8 *hkey)
 	if (hkey)
 		memcpy(hkey, rss->rss_hkey, RSS_HASH_KEY_LEN);
 
+	if (hfunc)
+		*hfunc = ETH_RSS_HASH_TOP;
+
 	return 0;
 }
 
 static int be_set_rxfh(struct net_device *netdev, const u32 *indir,
-		       const u8 *hkey)
+		       const u8 *hkey, const u8 hfunc)
 {
 	int rc = 0, i, j;
 	struct be_adapter *adapter = netdev_priv(netdev);
 	u8 rsstable[RSS_INDIR_TABLE_LEN];
 
+	/* We do not allow change in unsupported parameters */
+	if (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP)
+		return -EOPNOTSUPP;
+
 	if (indir) {
 		struct be_rx_obj *rxo;
 
diff --git a/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c b/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c
index a3a745ad7b75..4c194c102569 100644
--- a/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c
+++ b/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c
@@ -945,11 +945,15 @@ static u32 fm10k_get_rssrk_size(struct net_device __always_unused *netdev)
 	return FM10K_RSSRK_SIZE * FM10K_RSSRK_ENTRIES_PER_REG;
 }
 
-static int fm10k_get_rssh(struct net_device *netdev, u32 *indir, u8 *key)
+static int fm10k_get_rssh(struct net_device *netdev, u32 *indir, u8 *key,
+			  u8 *hfunc)
 {
 	struct fm10k_intfc *interface = netdev_priv(netdev);
 	int i, err;
 
+	if (hfunc)
+		*hfunc = ETH_RSS_HASH_TOP;
+
 	err = fm10k_get_reta(netdev, indir);
 	if (err || !key)
 		return err;
@@ -961,12 +965,16 @@ static int fm10k_get_rssh(struct net_device *netdev, u32 *indir, u8 *key)
 }
 
 static int fm10k_set_rssh(struct net_device *netdev, const u32 *indir,
-			  const u8 *key)
+			  const u8 *key, const u8 hfunc)
 {
 	struct fm10k_intfc *interface = netdev_priv(netdev);
 	struct fm10k_hw *hw = &interface->hw;
 	int i, err;
 
+	/* We do not allow change in unsupported parameters */
+	if (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP)
+		return -EOPNOTSUPP;
+
 	err = fm10k_set_reta(netdev, indir);
 	if (err || !key)
 		return err;
* Unmerged path drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
* Unmerged path drivers/net/ethernet/intel/igb/igb_ethtool.c
* Unmerged path drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
* Unmerged path drivers/net/ethernet/sfc/ethtool.c
* Unmerged path drivers/net/vmxnet3/vmxnet3_ethtool.c
* Unmerged path include/linux/ethtool.h
* Unmerged path include/uapi/linux/ethtool.h
* Unmerged path net/core/ethtool.c
