hpsa: add interrupt number to /proc/interrupts interrupt name

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Robert Elliott <elliott@hp.com>
commit 8b47004a55123b38ed6e8b0d4c8e6427f80a4a45
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/8b47004a.failed

Add the interrupt number to the interrupt names that
appear in /proc/interrupts, so they are unique

Also, delete the IRQ and DAC prints.  Other parts of the kernel
already print the IRQ assignments, and dual-address-cycle support
has not been interesting since the parallel PCI bus went from
32 to 64 bits wide.

	Reviewed-by: Scott Teel <scott.teel@pmcs.com>
	Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
	Reviewed-by: Tomas Henzl <thenzl@redhat.com>
	Reviewed-by: Hannes Reinecke <hare@Suse.de>
	Signed-off-by: Robert Elliott <elliott@hp.com>
	Signed-off-by: Don Brace <don.brace@pmcs.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: James Bottomley <JBottomley@Odin.com>
(cherry picked from commit 8b47004a55123b38ed6e8b0d4c8e6427f80a4a45)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/hpsa.c
diff --cc drivers/scsi/hpsa.c
index 86152e9b07dd,be837785b040..000000000000
--- a/drivers/scsi/hpsa.c
+++ b/drivers/scsi/hpsa.c
@@@ -6448,14 -7314,25 +6449,24 @@@ static int hpsa_request_irqs(struct ctl
  	} else {
  		/* Use single reply pool */
  		if (h->msix_vector > 0 || h->msi_vector) {
+ 			if (h->msix_vector)
+ 				sprintf(h->intrname[h->intr_mode],
+ 					"%s-msix", h->devname);
+ 			else
+ 				sprintf(h->intrname[h->intr_mode],
+ 					"%s-msi", h->devname);
  			rc = request_irq(h->intr[h->intr_mode],
- 				msixhandler, 0, h->devname,
+ 				msixhandler, 0,
+ 				h->intrname[h->intr_mode],
  				&h->q[h->intr_mode]);
  		} else {
+ 			sprintf(h->intrname[h->intr_mode],
+ 				"%s-intx", h->devname);
  			rc = request_irq(h->intr[h->intr_mode],
- 				intxhandler, IRQF_SHARED, h->devname,
+ 				intxhandler, IRQF_SHARED,
+ 				h->intrname[h->intr_mode],
  				&h->q[h->intr_mode]);
  		}
 -		irq_set_affinity_hint(h->intr[h->intr_mode], NULL);
  	}
  	if (rc) {
  		dev_err(&h->pdev->dev, "failed to get irq %d for %s\n",
@@@ -6805,17 -7719,18 +6816,23 @@@ reinit_after_soft_reset
  	/* make sure the board interrupts are off */
  	h->access.set_intr_mask(h, HPSA_INTR_OFF);
  
++<<<<<<< HEAD
 +	if (hpsa_request_irqs(h, do_hpsa_intr_msi, do_hpsa_intr_intx))
 +		goto clean2;
 +	dev_info(&pdev->dev, "%s: <0x%x> at IRQ %d%s using DAC\n",
 +	       h->devname, pdev->device,
 +	       h->intr[h->intr_mode], dac ? "" : " not");
++=======
+ 	rc = hpsa_request_irqs(h, do_hpsa_intr_msi, do_hpsa_intr_intx);
+ 	if (rc)
+ 		goto clean3;	/* pci, lockup, aer/h */
++>>>>>>> 8b47004a5512 (hpsa: add interrupt number to /proc/interrupts interrupt name)
  	rc = hpsa_alloc_cmd_pool(h);
  	if (rc)
 -		goto clean4;	/* irq, pci, lockup, aer/h */
 -	rc = hpsa_alloc_sg_chain_blocks(h);
 -	if (rc)
 -		goto clean5;	/* cmd, irq, pci, lockup, aer/h */
 +		goto clean2_and_free_irqs;
 +	if (hpsa_allocate_sg_chain_blocks(h))
 +		goto clean4;
  	init_waitqueue_head(&h->scan_wait_queue);
 -	init_waitqueue_head(&h->abort_cmd_wait_queue);
 -	init_waitqueue_head(&h->abort_sync_wait_queue);
  	h->scan_finished = 1; /* no scan currently in progress */
  
  	pci_set_drvdata(pdev, h);
* Unmerged path drivers/scsi/hpsa.c
diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index bb1c5c5da1f2..c8abcc3d5c2f 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -196,6 +196,7 @@ struct ctlr_info {
 	int remove_in_progress;
 	/* Address of h->q[x] is passed to intr handler to know which queue */
 	u8 q[MAX_REPLY_QUEUES];
+	char intrname[MAX_REPLY_QUEUES][16];	/* "hpsa0-msix00" names */
 	u32 TMFSupportFlags; /* cache what task mgmt funcs are supported. */
 #define HPSATMF_BITS_SUPPORTED  (1 << 0)
 #define HPSATMF_PHYS_LUN_RESET  (1 << 1)
