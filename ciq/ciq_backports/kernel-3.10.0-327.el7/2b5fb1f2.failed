cxgb4/cxgb4vf/csiostor: Cleanup macros/register defines related to port and VI

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Hariprasad Shenai <hariprasad@chelsio.com>
commit 2b5fb1f25e7b22cb96fa8662f9c8f8cf34abc109
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/2b5fb1f2.failed

This patch cleanups all port and VI related macros/register defines that are
defined in t4fw_api.h and the affected files.

	Signed-off-by: Hariprasad Shenai <hariprasad@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2b5fb1f25e7b22cb96fa8662f9c8f8cf34abc109)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_dcb.c
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_dcb.h
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
#	drivers/net/ethernet/chelsio/cxgb4/l2t.c
#	drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
#	drivers/net/ethernet/chelsio/cxgb4/t4fw_api.h
#	drivers/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c
#	drivers/scsi/csiostor/csio_mb.c
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_dcb.c
index baae6e532fe6,a35d1ec6950e..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_dcb.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_dcb.c
@@@ -175,6 -260,25 +175,28 @@@ void cxgb4_dcb_handle_fw_update(struct 
  			 ? CXGB4_DCB_STATE_FW_ALLSYNCED
  			 : CXGB4_DCB_STATE_FW_INCOMPLETE);
  
++<<<<<<< HEAD
++=======
+ 		if (dcb->dcb_version != FW_PORT_DCB_VER_UNKNOWN) {
+ 			dcb_running_version = FW_PORT_CMD_DCB_VERSION_G(
+ 				be16_to_cpu(
+ 				pcmd->u.dcb.control.dcb_version_to_app_state));
+ 			if (dcb_running_version == FW_PORT_DCB_VER_CEE1D01 ||
+ 			    dcb_running_version == FW_PORT_DCB_VER_IEEE) {
+ 				dcb->dcb_version = dcb_running_version;
+ 				dev_warn(adap->pdev_dev, "Interface %s is running %s\n",
+ 					 dev->name,
+ 					 dcb_ver_array[dcb->dcb_version]);
+ 			} else {
+ 				dev_warn(adap->pdev_dev,
+ 					 "Something screwed up, requested firmware for %s, but firmware returned %s instead\n",
+ 					 dcb_ver_array[dcb->dcb_version],
+ 					 dcb_ver_array[dcb_running_version]);
+ 				dcb->dcb_version = FW_PORT_DCB_VER_UNKNOWN;
+ 			}
+ 		}
+ 
++>>>>>>> 2b5fb1f25e7b (cxgb4/cxgb4vf/csiostor: Cleanup macros/register defines related to port and VI)
  		cxgb4_dcb_state_fsm(dev, input);
  		return;
  	}
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_dcb.h
index 1ec1d834e257,31ce425616c9..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_dcb.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_dcb.h
@@@ -42,12 -42,12 +42,19 @@@
  	do { \
  		memset(&(__pcmd), 0, sizeof(__pcmd)); \
  		(__pcmd).op_to_portid = \
++<<<<<<< HEAD
 +			cpu_to_be32(FW_CMD_OP(FW_PORT_CMD) | \
 +				    FW_CMD_REQUEST | \
 +				    FW_CMD_##__op | \
 +				    FW_PORT_CMD_PORTID(__port)); \
++=======
+ 			cpu_to_be32(FW_CMD_OP_V(FW_PORT_CMD) | \
+ 				    FW_CMD_REQUEST_F | \
+ 				    FW_CMD_##__op##_F | \
+ 				    FW_PORT_CMD_PORTID_V(__port)); \
++>>>>>>> 2b5fb1f25e7b (cxgb4/cxgb4vf/csiostor: Cleanup macros/register defines related to port and VI)
  		(__pcmd).action_to_len16 = \
- 			cpu_to_be32(FW_PORT_CMD_ACTION(__action) | \
+ 			cpu_to_be32(FW_PORT_CMD_ACTION_V(__action) | \
  				    FW_LEN16(pcmd)); \
  	} while (0)
  
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
index 0c588dc02bae,4c663cc106f1..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@@ -629,6 -690,43 +629,46 @@@ static int link_start(struct net_devic
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ int cxgb4_dcb_enabled(const struct net_device *dev)
+ {
+ #ifdef CONFIG_CHELSIO_T4_DCB
+ 	struct port_info *pi = netdev_priv(dev);
+ 
+ 	if (!pi->dcb.enabled)
+ 		return 0;
+ 
+ 	return ((pi->dcb.state == CXGB4_DCB_STATE_FW_ALLSYNCED) ||
+ 		(pi->dcb.state == CXGB4_DCB_STATE_HOST));
+ #else
+ 	return 0;
+ #endif
+ }
+ EXPORT_SYMBOL(cxgb4_dcb_enabled);
+ 
+ #ifdef CONFIG_CHELSIO_T4_DCB
+ /* Handle a Data Center Bridging update message from the firmware. */
+ static void dcb_rpl(struct adapter *adap, const struct fw_port_cmd *pcmd)
+ {
+ 	int port = FW_PORT_CMD_PORTID_G(ntohl(pcmd->op_to_portid));
+ 	struct net_device *dev = adap->port[port];
+ 	int old_dcb_enabled = cxgb4_dcb_enabled(dev);
+ 	int new_dcb_enabled;
+ 
+ 	cxgb4_dcb_handle_fw_update(adap, pcmd);
+ 	new_dcb_enabled = cxgb4_dcb_enabled(dev);
+ 
+ 	/* If the DCB has become enabled or disabled on the port then we're
+ 	 * going to need to set up/tear down DCB Priority parameters for the
+ 	 * TX Queues associated with the port.
+ 	 */
+ 	if (new_dcb_enabled != old_dcb_enabled)
+ 		dcb_tx_queue_prio_enable(dev, new_dcb_enabled);
+ }
+ #endif /* CONFIG_CHELSIO_T4_DCB */
+ 
++>>>>>>> 2b5fb1f25e7b (cxgb4/cxgb4vf/csiostor: Cleanup macros/register defines related to port and VI)
  /* Clear a filter and release any of its resources that we own.  This also
   * clears the filter's "pending" status.
   */
@@@ -733,8 -831,32 +773,37 @@@ static int fwevtq_handler(struct sge_rs
  	} else if (opcode == CPL_FW6_MSG || opcode == CPL_FW4_MSG) {
  		const struct cpl_fw6_msg *p = (void *)rsp;
  
++<<<<<<< HEAD
 +		if (p->type == 0)
 +			t4_handle_fw_rpl(q->adap, p->data);
++=======
+ #ifdef CONFIG_CHELSIO_T4_DCB
+ 		const struct fw_port_cmd *pcmd = (const void *)p->data;
+ 		unsigned int cmd = FW_CMD_OP_G(ntohl(pcmd->op_to_portid));
+ 		unsigned int action =
+ 			FW_PORT_CMD_ACTION_G(ntohl(pcmd->action_to_len16));
+ 
+ 		if (cmd == FW_PORT_CMD &&
+ 		    action == FW_PORT_ACTION_GET_PORT_INFO) {
+ 			int port = FW_PORT_CMD_PORTID_G(
+ 					be32_to_cpu(pcmd->op_to_portid));
+ 			struct net_device *dev = q->adap->port[port];
+ 			int state_input = ((pcmd->u.info.dcbxdis_pkd &
+ 					    FW_PORT_CMD_DCBXDIS_F)
+ 					   ? CXGB4_DCB_INPUT_FW_DISABLED
+ 					   : CXGB4_DCB_INPUT_FW_ENABLED);
+ 
+ 			cxgb4_dcb_state_fsm(dev, state_input);
+ 		}
+ 
+ 		if (cmd == FW_PORT_CMD &&
+ 		    action == FW_PORT_ACTION_L2_DCB_CFG)
+ 			dcb_rpl(q->adap, pcmd);
+ 		else
+ #endif
+ 			if (p->type == 0)
+ 				t4_handle_fw_rpl(q->adap, p->data);
++>>>>>>> 2b5fb1f25e7b (cxgb4/cxgb4vf/csiostor: Cleanup macros/register defines related to port and VI)
  	} else if (opcode == CPL_L2T_WRITE_RPL) {
  		const struct cpl_l2t_write_rpl *p = (void *)rsp;
  
diff --cc drivers/net/ethernet/chelsio/cxgb4/l2t.c
index 96041397ee15,a047baa9fd04..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/l2t.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/l2t.c
@@@ -435,9 -435,9 +435,15 @@@ u64 cxgb4_select_ntuple(struct net_devi
  
  	if (tp->vnic_shift >= 0) {
  		u32 viid = cxgb4_port_viid(dev);
++<<<<<<< HEAD
 +		u32 vf = FW_VIID_VIN_GET(viid);
 +		u32 pf = FW_VIID_PFN_GET(viid);
 +		u32 vld = FW_VIID_VIVLD_GET(viid);
++=======
+ 		u32 vf = FW_VIID_VIN_G(viid);
+ 		u32 pf = FW_VIID_PFN_G(viid);
+ 		u32 vld = FW_VIID_VIVLD_G(viid);
++>>>>>>> 2b5fb1f25e7b (cxgb4/cxgb4vf/csiostor: Cleanup macros/register defines related to port and VI)
  
  		ntuple |= (u64)(V_FT_VNID_ID_VF(vf) |
  				V_FT_VNID_ID_PF(pf) |
diff --cc drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
index 71d1d4fe87b2,20432e2bb17f..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
@@@ -1246,9 -1246,9 +1246,15 @@@ int t4_link_start(struct adapter *adap
  		fc |= FW_PORT_CAP_FC_TX;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_portid = htonl(FW_CMD_OP(FW_PORT_CMD) | FW_CMD_REQUEST |
 +			       FW_CMD_EXEC | FW_PORT_CMD_PORTID(port));
 +	c.action_to_len16 = htonl(FW_PORT_CMD_ACTION(FW_PORT_ACTION_L1_CFG) |
++=======
+ 	c.op_to_portid = htonl(FW_CMD_OP_V(FW_PORT_CMD) | FW_CMD_REQUEST_F |
+ 			       FW_CMD_EXEC_F | FW_PORT_CMD_PORTID_V(port));
+ 	c.action_to_len16 = htonl(FW_PORT_CMD_ACTION_V(FW_PORT_ACTION_L1_CFG) |
++>>>>>>> 2b5fb1f25e7b (cxgb4/cxgb4vf/csiostor: Cleanup macros/register defines related to port and VI)
  				  FW_LEN16(c));
  
  	if (!(lc->supported & FW_PORT_CAP_ANEG)) {
@@@ -1276,9 -1276,9 +1282,15 @@@ int t4_restart_aneg(struct adapter *ada
  	struct fw_port_cmd c;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_portid = htonl(FW_CMD_OP(FW_PORT_CMD) | FW_CMD_REQUEST |
 +			       FW_CMD_EXEC | FW_PORT_CMD_PORTID(port));
 +	c.action_to_len16 = htonl(FW_PORT_CMD_ACTION(FW_PORT_ACTION_L1_CFG) |
++=======
+ 	c.op_to_portid = htonl(FW_CMD_OP_V(FW_PORT_CMD) | FW_CMD_REQUEST_F |
+ 			       FW_CMD_EXEC_F | FW_PORT_CMD_PORTID_V(port));
+ 	c.action_to_len16 = htonl(FW_PORT_CMD_ACTION_V(FW_PORT_ACTION_L1_CFG) |
++>>>>>>> 2b5fb1f25e7b (cxgb4/cxgb4vf/csiostor: Cleanup macros/register defines related to port and VI)
  				  FW_LEN16(c));
  	c.u.l1cfg.rcap = htonl(FW_PORT_CAP_ANEG);
  	return t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);
@@@ -3373,11 -3413,11 +3385,19 @@@ int t4_alloc_vi(struct adapter *adap, u
  	struct fw_vi_cmd c;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_vfn = htonl(FW_CMD_OP(FW_VI_CMD) | FW_CMD_REQUEST |
 +			    FW_CMD_WRITE | FW_CMD_EXEC |
 +			    FW_VI_CMD_PFN(pf) | FW_VI_CMD_VFN(vf));
 +	c.alloc_to_len16 = htonl(FW_VI_CMD_ALLOC | FW_LEN16(c));
 +	c.portid_pkd = FW_VI_CMD_PORTID(port);
++=======
+ 	c.op_to_vfn = htonl(FW_CMD_OP_V(FW_VI_CMD) | FW_CMD_REQUEST_F |
+ 			    FW_CMD_WRITE_F | FW_CMD_EXEC_F |
+ 			    FW_VI_CMD_PFN_V(pf) | FW_VI_CMD_VFN_V(vf));
+ 	c.alloc_to_len16 = htonl(FW_VI_CMD_ALLOC_F | FW_LEN16(c));
+ 	c.portid_pkd = FW_VI_CMD_PORTID_V(port);
++>>>>>>> 2b5fb1f25e7b (cxgb4/cxgb4vf/csiostor: Cleanup macros/register defines related to port and VI)
  	c.nmac = nmac - 1;
  
  	ret = t4_wr_mbox(adap, mbox, &c, sizeof(c), &c);
@@@ -3426,23 -3466,23 +3446,28 @@@ int t4_set_rxmode(struct adapter *adap
  	if (mtu < 0)
  		mtu = FW_RXMODE_MTU_NO_CHG;
  	if (promisc < 0)
- 		promisc = FW_VI_RXMODE_CMD_PROMISCEN_MASK;
+ 		promisc = FW_VI_RXMODE_CMD_PROMISCEN_M;
  	if (all_multi < 0)
- 		all_multi = FW_VI_RXMODE_CMD_ALLMULTIEN_MASK;
+ 		all_multi = FW_VI_RXMODE_CMD_ALLMULTIEN_M;
  	if (bcast < 0)
- 		bcast = FW_VI_RXMODE_CMD_BROADCASTEN_MASK;
+ 		bcast = FW_VI_RXMODE_CMD_BROADCASTEN_M;
  	if (vlanex < 0)
- 		vlanex = FW_VI_RXMODE_CMD_VLANEXEN_MASK;
+ 		vlanex = FW_VI_RXMODE_CMD_VLANEXEN_M;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_viid = htonl(FW_CMD_OP(FW_VI_RXMODE_CMD) | FW_CMD_REQUEST |
 +			     FW_CMD_WRITE | FW_VI_RXMODE_CMD_VIID(viid));
++=======
+ 	c.op_to_viid = htonl(FW_CMD_OP_V(FW_VI_RXMODE_CMD) | FW_CMD_REQUEST_F |
+ 			     FW_CMD_WRITE_F | FW_VI_RXMODE_CMD_VIID_V(viid));
++>>>>>>> 2b5fb1f25e7b (cxgb4/cxgb4vf/csiostor: Cleanup macros/register defines related to port and VI)
  	c.retval_len16 = htonl(FW_LEN16(c));
- 	c.mtu_to_vlanexen = htonl(FW_VI_RXMODE_CMD_MTU(mtu) |
- 				  FW_VI_RXMODE_CMD_PROMISCEN(promisc) |
- 				  FW_VI_RXMODE_CMD_ALLMULTIEN(all_multi) |
- 				  FW_VI_RXMODE_CMD_BROADCASTEN(bcast) |
- 				  FW_VI_RXMODE_CMD_VLANEXEN(vlanex));
+ 	c.mtu_to_vlanexen = htonl(FW_VI_RXMODE_CMD_MTU_V(mtu) |
+ 				  FW_VI_RXMODE_CMD_PROMISCEN_V(promisc) |
+ 				  FW_VI_RXMODE_CMD_ALLMULTIEN_V(all_multi) |
+ 				  FW_VI_RXMODE_CMD_BROADCASTEN_V(bcast) |
+ 				  FW_VI_RXMODE_CMD_VLANEXEN_V(vlanex));
  	return t4_wr_mbox_meat(adap, mbox, &c, sizeof(c), NULL, sleep_ok);
  }
  
@@@ -3483,15 -3523,15 +3508,23 @@@ int t4_alloc_mac_filt(struct adapter *a
  		return -EINVAL;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_viid = htonl(FW_CMD_OP(FW_VI_MAC_CMD) | FW_CMD_REQUEST |
 +			     FW_CMD_WRITE | (free ? FW_CMD_EXEC : 0) |
 +			     FW_VI_MAC_CMD_VIID(viid));
 +	c.freemacs_to_len16 = htonl(FW_VI_MAC_CMD_FREEMACS(free) |
 +				    FW_CMD_LEN16((naddr + 2) / 2));
++=======
+ 	c.op_to_viid = htonl(FW_CMD_OP_V(FW_VI_MAC_CMD) | FW_CMD_REQUEST_F |
+ 			     FW_CMD_WRITE_F | (free ? FW_CMD_EXEC_F : 0) |
+ 			     FW_VI_MAC_CMD_VIID_V(viid));
+ 	c.freemacs_to_len16 = htonl(FW_VI_MAC_CMD_FREEMACS_V(free) |
+ 				    FW_CMD_LEN16_V((naddr + 2) / 2));
++>>>>>>> 2b5fb1f25e7b (cxgb4/cxgb4vf/csiostor: Cleanup macros/register defines related to port and VI)
  
  	for (i = 0, p = c.u.exact; i < naddr; i++, p++) {
- 		p->valid_to_idx = htons(FW_VI_MAC_CMD_VALID |
- 				      FW_VI_MAC_CMD_IDX(FW_VI_MAC_ADD_MAC));
+ 		p->valid_to_idx = htons(FW_VI_MAC_CMD_VALID_F |
+ 				      FW_VI_MAC_CMD_IDX_V(FW_VI_MAC_ADD_MAC));
  		memcpy(p->macaddr, addr[i], sizeof(p->macaddr));
  	}
  
@@@ -3546,12 -3586,12 +3579,21 @@@ int t4_change_mac(struct adapter *adap
  	mode = add_smt ? FW_VI_MAC_SMT_AND_MPSTCAM : FW_VI_MAC_MPS_TCAM_ENTRY;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_viid = htonl(FW_CMD_OP(FW_VI_MAC_CMD) | FW_CMD_REQUEST |
 +			     FW_CMD_WRITE | FW_VI_MAC_CMD_VIID(viid));
 +	c.freemacs_to_len16 = htonl(FW_CMD_LEN16(1));
 +	p->valid_to_idx = htons(FW_VI_MAC_CMD_VALID |
 +				FW_VI_MAC_CMD_SMAC_RESULT(mode) |
 +				FW_VI_MAC_CMD_IDX(idx));
++=======
+ 	c.op_to_viid = htonl(FW_CMD_OP_V(FW_VI_MAC_CMD) | FW_CMD_REQUEST_F |
+ 			     FW_CMD_WRITE_F | FW_VI_MAC_CMD_VIID_V(viid));
+ 	c.freemacs_to_len16 = htonl(FW_CMD_LEN16_V(1));
+ 	p->valid_to_idx = htons(FW_VI_MAC_CMD_VALID_F |
+ 				FW_VI_MAC_CMD_SMAC_RESULT_V(mode) |
+ 				FW_VI_MAC_CMD_IDX_V(idx));
++>>>>>>> 2b5fb1f25e7b (cxgb4/cxgb4vf/csiostor: Cleanup macros/register defines related to port and VI)
  	memcpy(p->macaddr, addr, sizeof(p->macaddr));
  
  	ret = t4_wr_mbox(adap, mbox, &c, sizeof(c), &c);
@@@ -3580,16 -3620,43 +3622,54 @@@ int t4_set_addr_hash(struct adapter *ad
  	struct fw_vi_mac_cmd c;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_viid = htonl(FW_CMD_OP(FW_VI_MAC_CMD) | FW_CMD_REQUEST |
 +			     FW_CMD_WRITE | FW_VI_ENABLE_CMD_VIID(viid));
 +	c.freemacs_to_len16 = htonl(FW_VI_MAC_CMD_HASHVECEN |
 +				    FW_VI_MAC_CMD_HASHUNIEN(ucast) |
 +				    FW_CMD_LEN16(1));
++=======
+ 	c.op_to_viid = htonl(FW_CMD_OP_V(FW_VI_MAC_CMD) | FW_CMD_REQUEST_F |
+ 			     FW_CMD_WRITE_F | FW_VI_ENABLE_CMD_VIID_V(viid));
+ 	c.freemacs_to_len16 = htonl(FW_VI_MAC_CMD_HASHVECEN_F |
+ 				    FW_VI_MAC_CMD_HASHUNIEN_V(ucast) |
+ 				    FW_CMD_LEN16_V(1));
++>>>>>>> 2b5fb1f25e7b (cxgb4/cxgb4vf/csiostor: Cleanup macros/register defines related to port and VI)
  	c.u.hash.hashvec = cpu_to_be64(vec);
  	return t4_wr_mbox_meat(adap, mbox, &c, sizeof(c), NULL, sleep_ok);
  }
  
  /**
++<<<<<<< HEAD
++=======
+  *      t4_enable_vi_params - enable/disable a virtual interface
+  *      @adap: the adapter
+  *      @mbox: mailbox to use for the FW command
+  *      @viid: the VI id
+  *      @rx_en: 1=enable Rx, 0=disable Rx
+  *      @tx_en: 1=enable Tx, 0=disable Tx
+  *      @dcb_en: 1=enable delivery of Data Center Bridging messages.
+  *
+  *      Enables/disables a virtual interface.  Note that setting DCB Enable
+  *      only makes sense when enabling a Virtual Interface ...
+  */
+ int t4_enable_vi_params(struct adapter *adap, unsigned int mbox,
+ 			unsigned int viid, bool rx_en, bool tx_en, bool dcb_en)
+ {
+ 	struct fw_vi_enable_cmd c;
+ 
+ 	memset(&c, 0, sizeof(c));
+ 	c.op_to_viid = htonl(FW_CMD_OP_V(FW_VI_ENABLE_CMD) | FW_CMD_REQUEST_F |
+ 			     FW_CMD_EXEC_F | FW_VI_ENABLE_CMD_VIID_V(viid));
+ 
+ 	c.ien_to_len16 = htonl(FW_VI_ENABLE_CMD_IEN_V(rx_en) |
+ 			       FW_VI_ENABLE_CMD_EEN_V(tx_en) | FW_LEN16(c) |
+ 			       FW_VI_ENABLE_CMD_DCB_INFO_V(dcb_en));
+ 	return t4_wr_mbox_ns(adap, mbox, &c, sizeof(c), NULL);
+ }
+ 
+ /**
++>>>>>>> 2b5fb1f25e7b (cxgb4/cxgb4vf/csiostor: Cleanup macros/register defines related to port and VI)
   *	t4_enable_vi - enable/disable a virtual interface
   *	@adap: the adapter
   *	@mbox: mailbox to use for the FW command
@@@ -3627,9 -3687,9 +3707,15 @@@ int t4_identify_port(struct adapter *ad
  	struct fw_vi_enable_cmd c;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_viid = htonl(FW_CMD_OP(FW_VI_ENABLE_CMD) | FW_CMD_REQUEST |
 +			     FW_CMD_EXEC | FW_VI_ENABLE_CMD_VIID(viid));
 +	c.ien_to_len16 = htonl(FW_VI_ENABLE_CMD_LED | FW_LEN16(c));
++=======
+ 	c.op_to_viid = htonl(FW_CMD_OP_V(FW_VI_ENABLE_CMD) | FW_CMD_REQUEST_F |
+ 			     FW_CMD_EXEC_F | FW_VI_ENABLE_CMD_VIID_V(viid));
+ 	c.ien_to_len16 = htonl(FW_VI_ENABLE_CMD_LED_F | FW_LEN16(c));
++>>>>>>> 2b5fb1f25e7b (cxgb4/cxgb4vf/csiostor: Cleanup macros/register defines related to port and VI)
  	c.blinkdur = htons(nblinks);
  	return t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);
  }
@@@ -4062,11 -4122,11 +4148,17 @@@ int t4_port_init(struct adapter *adap, 
  		while ((adap->params.portvec & (1 << j)) == 0)
  			j++;
  
++<<<<<<< HEAD
 +		c.op_to_portid = htonl(FW_CMD_OP(FW_PORT_CMD) |
 +				       FW_CMD_REQUEST | FW_CMD_READ |
 +				       FW_PORT_CMD_PORTID(j));
++=======
+ 		c.op_to_portid = htonl(FW_CMD_OP_V(FW_PORT_CMD) |
+ 				       FW_CMD_REQUEST_F | FW_CMD_READ_F |
+ 				       FW_PORT_CMD_PORTID_V(j));
++>>>>>>> 2b5fb1f25e7b (cxgb4/cxgb4vf/csiostor: Cleanup macros/register defines related to port and VI)
  		c.action_to_len16 = htonl(
- 			FW_PORT_CMD_ACTION(FW_PORT_ACTION_GET_PORT_INFO) |
+ 			FW_PORT_CMD_ACTION_V(FW_PORT_ACTION_GET_PORT_INFO) |
  			FW_LEN16(c));
  		ret = t4_wr_mbox(adap, mbox, &c, sizeof(c), &c);
  		if (ret)
@@@ -4084,13 -4144,13 +4176,13 @@@
  		adap->port[i]->dev_port = j;
  
  		ret = ntohl(c.u.info.lstatus_to_modtype);
- 		p->mdio_addr = (ret & FW_PORT_CMD_MDIOCAP) ?
- 			FW_PORT_CMD_MDIOADDR_GET(ret) : -1;
- 		p->port_type = FW_PORT_CMD_PTYPE_GET(ret);
+ 		p->mdio_addr = (ret & FW_PORT_CMD_MDIOCAP_F) ?
+ 			FW_PORT_CMD_MDIOADDR_G(ret) : -1;
+ 		p->port_type = FW_PORT_CMD_PTYPE_G(ret);
  		p->mod_type = FW_PORT_MOD_TYPE_NA;
  
 -		rvc.op_to_viid = htonl(FW_CMD_OP_V(FW_RSS_VI_CONFIG_CMD) |
 -				       FW_CMD_REQUEST_F | FW_CMD_READ_F |
 +		rvc.op_to_viid = htonl(FW_CMD_OP(FW_RSS_VI_CONFIG_CMD) |
 +				       FW_CMD_REQUEST | FW_CMD_READ |
  				       FW_RSS_VI_CONFIG_CMD_VIID(p->viid));
  		rvc.retval_len16 = htonl(FW_LEN16(rvc));
  		ret = t4_wr_mbox(adap, mbox, &rvc, sizeof(rvc), &rvc);
diff --cc drivers/net/ethernet/chelsio/cxgb4/t4fw_api.h
index 0487eeccb419,4c8eb875fdea..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/t4fw_api.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4fw_api.h
@@@ -1320,9 -1829,18 +1320,24 @@@ struct fw_eq_ofld_cmd 
   * Macros for VIID parsing:
   * VIID - [10:8] PFN, [7] VI Valid, [6:0] VI number
   */
++<<<<<<< HEAD
 +#define FW_VIID_PFN_GET(x) (((x) >> 8) & 0x7)
 +#define FW_VIID_VIVLD_GET(x) (((x) >> 7) & 0x1)
 +#define FW_VIID_VIN_GET(x) (((x) >> 0) & 0x7F)
++=======
+ 
+ #define FW_VIID_PFN_S           8
+ #define FW_VIID_PFN_M           0x7
+ #define FW_VIID_PFN_G(x)        (((x) >> FW_VIID_PFN_S) & FW_VIID_PFN_M)
+ 
+ #define FW_VIID_VIVLD_S		7
+ #define FW_VIID_VIVLD_M		0x1
+ #define FW_VIID_VIVLD_G(x)	(((x) >> FW_VIID_VIVLD_S) & FW_VIID_VIVLD_M)
+ 
+ #define FW_VIID_VIN_S		0
+ #define FW_VIID_VIN_M		0x7F
+ #define FW_VIID_VIN_G(x)	(((x) >> FW_VIID_VIN_S) & FW_VIID_VIN_M)
++>>>>>>> 2b5fb1f25e7b (cxgb4/cxgb4vf/csiostor: Cleanup macros/register defines related to port and VI)
  
  struct fw_vi_cmd {
  	__be32 op_to_vfn;
@@@ -1745,51 -2356,105 +1844,111 @@@ struct fw_port_cmd 
  	} u;
  };
  
- #define FW_PORT_CMD_READ (1U << 22)
+ #define FW_PORT_CMD_READ_S	22
+ #define FW_PORT_CMD_READ_V(x)	((x) << FW_PORT_CMD_READ_S)
+ #define FW_PORT_CMD_READ_F	FW_PORT_CMD_READ_V(1U)
  
- #define FW_PORT_CMD_PORTID(x) ((x) << 0)
- #define FW_PORT_CMD_PORTID_GET(x) (((x) >> 0) & 0xf)
+ #define FW_PORT_CMD_PORTID_S	0
+ #define FW_PORT_CMD_PORTID_M	0xf
+ #define FW_PORT_CMD_PORTID_V(x)	((x) << FW_PORT_CMD_PORTID_S)
+ #define FW_PORT_CMD_PORTID_G(x)	\
+ 	(((x) >> FW_PORT_CMD_PORTID_S) & FW_PORT_CMD_PORTID_M)
  
- #define FW_PORT_CMD_ACTION(x) ((x) << 16)
- #define FW_PORT_CMD_ACTION_GET(x) (((x) >> 16) & 0xffff)
+ #define FW_PORT_CMD_ACTION_S	16
+ #define FW_PORT_CMD_ACTION_M	0xffff
+ #define FW_PORT_CMD_ACTION_V(x)	((x) << FW_PORT_CMD_ACTION_S)
+ #define FW_PORT_CMD_ACTION_G(x)	\
+ 	(((x) >> FW_PORT_CMD_ACTION_S) & FW_PORT_CMD_ACTION_M)
  
- #define FW_PORT_CMD_CTLBF(x) ((x) << 10)
- #define FW_PORT_CMD_OVLAN3(x) ((x) << 7)
- #define FW_PORT_CMD_OVLAN2(x) ((x) << 6)
- #define FW_PORT_CMD_OVLAN1(x) ((x) << 5)
- #define FW_PORT_CMD_OVLAN0(x) ((x) << 4)
- #define FW_PORT_CMD_IVLAN0(x) ((x) << 3)
+ #define FW_PORT_CMD_OVLAN3_S	7
+ #define FW_PORT_CMD_OVLAN3_V(x)	((x) << FW_PORT_CMD_OVLAN3_S)
  
- #define FW_PORT_CMD_TXIPG(x) ((x) << 19)
+ #define FW_PORT_CMD_OVLAN2_S	6
+ #define FW_PORT_CMD_OVLAN2_V(x)	((x) << FW_PORT_CMD_OVLAN2_S)
  
- #define FW_PORT_CMD_LSTATUS (1U << 31)
- #define FW_PORT_CMD_LSTATUS_GET(x) (((x) >> 31) & 0x1)
- #define FW_PORT_CMD_LSPEED(x) ((x) << 24)
- #define FW_PORT_CMD_LSPEED_GET(x) (((x) >> 24) & 0x3f)
- #define FW_PORT_CMD_TXPAUSE (1U << 23)
- #define FW_PORT_CMD_RXPAUSE (1U << 22)
- #define FW_PORT_CMD_MDIOCAP (1U << 21)
- #define FW_PORT_CMD_MDIOADDR_GET(x) (((x) >> 16) & 0x1f)
- #define FW_PORT_CMD_LPTXPAUSE (1U << 15)
- #define FW_PORT_CMD_LPRXPAUSE (1U << 14)
- #define FW_PORT_CMD_PTYPE_MASK 0x1f
- #define FW_PORT_CMD_PTYPE_GET(x) (((x) >> 8) & FW_PORT_CMD_PTYPE_MASK)
- #define FW_PORT_CMD_MODTYPE_MASK 0x1f
- #define FW_PORT_CMD_MODTYPE_GET(x) (((x) >> 0) & FW_PORT_CMD_MODTYPE_MASK)
+ #define FW_PORT_CMD_OVLAN1_S	5
+ #define FW_PORT_CMD_OVLAN1_V(x)	((x) << FW_PORT_CMD_OVLAN1_S)
  
++<<<<<<< HEAD
 +#define FW_PORT_CMD_DCBXDIS (1U << 7)
 +#define FW_PORT_CMD_APPLY (1U <<  7)
 +#define FW_PORT_CMD_ALL_SYNCD (1U << 7)
- 
- #define FW_PORT_CMD_PPPEN(x) ((x) << 31)
- #define FW_PORT_CMD_TPSRC(x) ((x) << 28)
- #define FW_PORT_CMD_NCSISRC(x) ((x) << 24)
- 
- #define FW_PORT_CMD_CH0(x) ((x) << 20)
- #define FW_PORT_CMD_CH1(x) ((x) << 16)
- #define FW_PORT_CMD_CH2(x) ((x) << 12)
- #define FW_PORT_CMD_CH3(x) ((x) << 8)
- #define FW_PORT_CMD_NCSICH(x) ((x) << 4)
++=======
+ #define FW_PORT_CMD_OVLAN0_S	4
+ #define FW_PORT_CMD_OVLAN0_V(x)	((x) << FW_PORT_CMD_OVLAN0_S)
++>>>>>>> 2b5fb1f25e7b (cxgb4/cxgb4vf/csiostor: Cleanup macros/register defines related to port and VI)
+ 
+ #define FW_PORT_CMD_IVLAN0_S	3
+ #define FW_PORT_CMD_IVLAN0_V(x)	((x) << FW_PORT_CMD_IVLAN0_S)
+ 
+ #define FW_PORT_CMD_TXIPG_S	3
+ #define FW_PORT_CMD_TXIPG_V(x)	((x) << FW_PORT_CMD_TXIPG_S)
+ 
+ #define FW_PORT_CMD_LSTATUS_S           31
+ #define FW_PORT_CMD_LSTATUS_M           0x1
+ #define FW_PORT_CMD_LSTATUS_V(x)        ((x) << FW_PORT_CMD_LSTATUS_S)
+ #define FW_PORT_CMD_LSTATUS_G(x)        \
+ 	(((x) >> FW_PORT_CMD_LSTATUS_S) & FW_PORT_CMD_LSTATUS_M)
+ #define FW_PORT_CMD_LSTATUS_F   FW_PORT_CMD_LSTATUS_V(1U)
+ 
+ #define FW_PORT_CMD_LSPEED_S	24
+ #define FW_PORT_CMD_LSPEED_M	0x3f
+ #define FW_PORT_CMD_LSPEED_V(x)	((x) << FW_PORT_CMD_LSPEED_S)
+ #define FW_PORT_CMD_LSPEED_G(x)	\
+ 	(((x) >> FW_PORT_CMD_LSPEED_S) & FW_PORT_CMD_LSPEED_M)
+ 
+ #define FW_PORT_CMD_TXPAUSE_S		23
+ #define FW_PORT_CMD_TXPAUSE_V(x)	((x) << FW_PORT_CMD_TXPAUSE_S)
+ #define FW_PORT_CMD_TXPAUSE_F	FW_PORT_CMD_TXPAUSE_V(1U)
+ 
+ #define FW_PORT_CMD_RXPAUSE_S		22
+ #define FW_PORT_CMD_RXPAUSE_V(x)	((x) << FW_PORT_CMD_RXPAUSE_S)
+ #define FW_PORT_CMD_RXPAUSE_F	FW_PORT_CMD_RXPAUSE_V(1U)
+ 
+ #define FW_PORT_CMD_MDIOCAP_S		21
+ #define FW_PORT_CMD_MDIOCAP_V(x)	((x) << FW_PORT_CMD_MDIOCAP_S)
+ #define FW_PORT_CMD_MDIOCAP_F	FW_PORT_CMD_MDIOCAP_V(1U)
+ 
+ #define FW_PORT_CMD_MDIOADDR_S		16
+ #define FW_PORT_CMD_MDIOADDR_M		0x1f
+ #define FW_PORT_CMD_MDIOADDR_G(x)	\
+ 	(((x) >> FW_PORT_CMD_MDIOADDR_S) & FW_PORT_CMD_MDIOADDR_M)
+ 
+ #define FW_PORT_CMD_LPTXPAUSE_S		15
+ #define FW_PORT_CMD_LPTXPAUSE_V(x)	((x) << FW_PORT_CMD_LPTXPAUSE_S)
+ #define FW_PORT_CMD_LPTXPAUSE_F	FW_PORT_CMD_LPTXPAUSE_V(1U)
+ 
+ #define FW_PORT_CMD_LPRXPAUSE_S		14
+ #define FW_PORT_CMD_LPRXPAUSE_V(x)	((x) << FW_PORT_CMD_LPRXPAUSE_S)
+ #define FW_PORT_CMD_LPRXPAUSE_F	FW_PORT_CMD_LPRXPAUSE_V(1U)
+ 
+ #define FW_PORT_CMD_PTYPE_S	8
+ #define FW_PORT_CMD_PTYPE_M	0x1f
+ #define FW_PORT_CMD_PTYPE_G(x)	\
+ 	(((x) >> FW_PORT_CMD_PTYPE_S) & FW_PORT_CMD_PTYPE_M)
+ 
+ #define FW_PORT_CMD_MODTYPE_S		0
+ #define FW_PORT_CMD_MODTYPE_M		0x1f
+ #define FW_PORT_CMD_MODTYPE_V(x)	((x) << FW_PORT_CMD_MODTYPE_S)
+ #define FW_PORT_CMD_MODTYPE_G(x)	\
+ 	(((x) >> FW_PORT_CMD_MODTYPE_S) & FW_PORT_CMD_MODTYPE_M)
+ 
+ #define FW_PORT_CMD_DCBXDIS_S		7
+ #define FW_PORT_CMD_DCBXDIS_V(x)	((x) << FW_PORT_CMD_DCBXDIS_S)
+ #define FW_PORT_CMD_DCBXDIS_F	FW_PORT_CMD_DCBXDIS_V(1U)
+ 
+ #define FW_PORT_CMD_APPLY_S	7
+ #define FW_PORT_CMD_APPLY_V(x)	((x) << FW_PORT_CMD_APPLY_S)
+ #define FW_PORT_CMD_APPLY_F	FW_PORT_CMD_APPLY_V(1U)
+ 
+ #define FW_PORT_CMD_ALL_SYNCD_S		7
+ #define FW_PORT_CMD_ALL_SYNCD_V(x)	((x) << FW_PORT_CMD_ALL_SYNCD_S)
+ #define FW_PORT_CMD_ALL_SYNCD_F	FW_PORT_CMD_ALL_SYNCD_V(1U)
+ 
+ #define FW_PORT_CMD_DCB_VERSION_S	12
+ #define FW_PORT_CMD_DCB_VERSION_M	0x7
+ #define FW_PORT_CMD_DCB_VERSION_G(x)	\
+ 	(((x) >> FW_PORT_CMD_DCB_VERSION_S) & FW_PORT_CMD_DCB_VERSION_M)
  
  enum fw_port_type {
  	FW_PORT_TYPE_FIBER_XFI,
diff --cc drivers/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c
index 1e896b923234,960d35c6c370..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c
+++ b/drivers/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c
@@@ -287,11 -287,11 +287,11 @@@ int t4vf_port_init(struct adapter *adap
  	 * like MAC address, etc.
  	 */
  	memset(&vi_cmd, 0, sizeof(vi_cmd));
 -	vi_cmd.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_VI_CMD) |
 -				       FW_CMD_REQUEST_F |
 -				       FW_CMD_READ_F);
 +	vi_cmd.op_to_vfn = cpu_to_be32(FW_CMD_OP(FW_VI_CMD) |
 +				       FW_CMD_REQUEST |
 +				       FW_CMD_READ);
  	vi_cmd.alloc_to_len16 = cpu_to_be32(FW_LEN16(vi_cmd));
- 	vi_cmd.type_viid = cpu_to_be16(FW_VI_CMD_VIID(pi->viid));
+ 	vi_cmd.type_viid = cpu_to_be16(FW_VI_CMD_VIID_V(pi->viid));
  	v = t4vf_wr_mbox(adapter, &vi_cmd, sizeof(vi_cmd), &vi_rpl);
  	if (v)
  		return v;
@@@ -308,12 -308,12 +308,19 @@@
  		return 0;
  
  	memset(&port_cmd, 0, sizeof(port_cmd));
++<<<<<<< HEAD
 +	port_cmd.op_to_portid = cpu_to_be32(FW_CMD_OP(FW_PORT_CMD) |
 +					    FW_CMD_REQUEST |
 +					    FW_CMD_READ |
 +					    FW_PORT_CMD_PORTID(pi->port_id));
++=======
+ 	port_cmd.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PORT_CMD) |
+ 					    FW_CMD_REQUEST_F |
+ 					    FW_CMD_READ_F |
+ 					    FW_PORT_CMD_PORTID_V(pi->port_id));
++>>>>>>> 2b5fb1f25e7b (cxgb4/cxgb4vf/csiostor: Cleanup macros/register defines related to port and VI)
  	port_cmd.action_to_len16 =
- 		cpu_to_be32(FW_PORT_CMD_ACTION(FW_PORT_ACTION_GET_PORT_INFO) |
+ 		cpu_to_be32(FW_PORT_CMD_ACTION_V(FW_PORT_ACTION_GET_PORT_INFO) |
  			    FW_LEN16(port_cmd));
  	v = t4vf_wr_mbox(adapter, &port_cmd, sizeof(port_cmd), &port_rpl);
  	if (v)
@@@ -892,13 -892,13 +899,13 @@@ int t4vf_alloc_vi(struct adapter *adapt
  	 * VIID.
  	 */
  	memset(&cmd, 0, sizeof(cmd));
 -	cmd.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_VI_CMD) |
 -				    FW_CMD_REQUEST_F |
 -				    FW_CMD_WRITE_F |
 -				    FW_CMD_EXEC_F);
 +	cmd.op_to_vfn = cpu_to_be32(FW_CMD_OP(FW_VI_CMD) |
 +				    FW_CMD_REQUEST |
 +				    FW_CMD_WRITE |
 +				    FW_CMD_EXEC);
  	cmd.alloc_to_len16 = cpu_to_be32(FW_LEN16(cmd) |
- 					 FW_VI_CMD_ALLOC);
- 	cmd.portid_pkd = FW_VI_CMD_PORTID(port_id);
+ 					 FW_VI_CMD_ALLOC_F);
+ 	cmd.portid_pkd = FW_VI_CMD_PORTID_V(port_id);
  	v = t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), &rpl);
  	if (v)
  		return v;
@@@ -922,12 -922,12 +929,12 @@@ int t4vf_free_vi(struct adapter *adapte
  	 * Execute a VI command to free the Virtual Interface.
  	 */
  	memset(&cmd, 0, sizeof(cmd));
 -	cmd.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_VI_CMD) |
 -				    FW_CMD_REQUEST_F |
 -				    FW_CMD_EXEC_F);
 +	cmd.op_to_vfn = cpu_to_be32(FW_CMD_OP(FW_VI_CMD) |
 +				    FW_CMD_REQUEST |
 +				    FW_CMD_EXEC);
  	cmd.alloc_to_len16 = cpu_to_be32(FW_LEN16(cmd) |
- 					 FW_VI_CMD_FREE);
- 	cmd.type_viid = cpu_to_be16(FW_VI_CMD_VIID(viid));
+ 					 FW_VI_CMD_FREE_F);
+ 	cmd.type_viid = cpu_to_be16(FW_VI_CMD_VIID_V(viid));
  	return t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), NULL);
  }
  
@@@ -946,12 -946,12 +953,21 @@@ int t4vf_enable_vi(struct adapter *adap
  	struct fw_vi_enable_cmd cmd;
  
  	memset(&cmd, 0, sizeof(cmd));
++<<<<<<< HEAD
 +	cmd.op_to_viid = cpu_to_be32(FW_CMD_OP(FW_VI_ENABLE_CMD) |
 +				     FW_CMD_REQUEST |
 +				     FW_CMD_EXEC |
 +				     FW_VI_ENABLE_CMD_VIID(viid));
 +	cmd.ien_to_len16 = cpu_to_be32(FW_VI_ENABLE_CMD_IEN(rx_en) |
 +				       FW_VI_ENABLE_CMD_EEN(tx_en) |
++=======
+ 	cmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_ENABLE_CMD) |
+ 				     FW_CMD_REQUEST_F |
+ 				     FW_CMD_EXEC_F |
+ 				     FW_VI_ENABLE_CMD_VIID_V(viid));
+ 	cmd.ien_to_len16 = cpu_to_be32(FW_VI_ENABLE_CMD_IEN_V(rx_en) |
+ 				       FW_VI_ENABLE_CMD_EEN_V(tx_en) |
++>>>>>>> 2b5fb1f25e7b (cxgb4/cxgb4vf/csiostor: Cleanup macros/register defines related to port and VI)
  				       FW_LEN16(cmd));
  	return t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), NULL);
  }
@@@ -970,11 -970,11 +986,19 @@@ int t4vf_identify_port(struct adapter *
  	struct fw_vi_enable_cmd cmd;
  
  	memset(&cmd, 0, sizeof(cmd));
++<<<<<<< HEAD
 +	cmd.op_to_viid = cpu_to_be32(FW_CMD_OP(FW_VI_ENABLE_CMD) |
 +				     FW_CMD_REQUEST |
 +				     FW_CMD_EXEC |
 +				     FW_VI_ENABLE_CMD_VIID(viid));
 +	cmd.ien_to_len16 = cpu_to_be32(FW_VI_ENABLE_CMD_LED |
++=======
+ 	cmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_ENABLE_CMD) |
+ 				     FW_CMD_REQUEST_F |
+ 				     FW_CMD_EXEC_F |
+ 				     FW_VI_ENABLE_CMD_VIID_V(viid));
+ 	cmd.ien_to_len16 = cpu_to_be32(FW_VI_ENABLE_CMD_LED_F |
++>>>>>>> 2b5fb1f25e7b (cxgb4/cxgb4vf/csiostor: Cleanup macros/register defines related to port and VI)
  				       FW_LEN16(cmd));
  	cmd.blinkdur = cpu_to_be16(nblinks);
  	return t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), NULL);
@@@ -1001,28 -1001,28 +1025,35 @@@ int t4vf_set_rxmode(struct adapter *ada
  
  	/* convert to FW values */
  	if (mtu < 0)
- 		mtu = FW_VI_RXMODE_CMD_MTU_MASK;
+ 		mtu = FW_VI_RXMODE_CMD_MTU_M;
  	if (promisc < 0)
- 		promisc = FW_VI_RXMODE_CMD_PROMISCEN_MASK;
+ 		promisc = FW_VI_RXMODE_CMD_PROMISCEN_M;
  	if (all_multi < 0)
- 		all_multi = FW_VI_RXMODE_CMD_ALLMULTIEN_MASK;
+ 		all_multi = FW_VI_RXMODE_CMD_ALLMULTIEN_M;
  	if (bcast < 0)
- 		bcast = FW_VI_RXMODE_CMD_BROADCASTEN_MASK;
+ 		bcast = FW_VI_RXMODE_CMD_BROADCASTEN_M;
  	if (vlanex < 0)
- 		vlanex = FW_VI_RXMODE_CMD_VLANEXEN_MASK;
+ 		vlanex = FW_VI_RXMODE_CMD_VLANEXEN_M;
  
  	memset(&cmd, 0, sizeof(cmd));
++<<<<<<< HEAD
 +	cmd.op_to_viid = cpu_to_be32(FW_CMD_OP(FW_VI_RXMODE_CMD) |
 +				     FW_CMD_REQUEST |
 +				     FW_CMD_WRITE |
 +				     FW_VI_RXMODE_CMD_VIID(viid));
++=======
+ 	cmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_RXMODE_CMD) |
+ 				     FW_CMD_REQUEST_F |
+ 				     FW_CMD_WRITE_F |
+ 				     FW_VI_RXMODE_CMD_VIID_V(viid));
++>>>>>>> 2b5fb1f25e7b (cxgb4/cxgb4vf/csiostor: Cleanup macros/register defines related to port and VI)
  	cmd.retval_len16 = cpu_to_be32(FW_LEN16(cmd));
  	cmd.mtu_to_vlanexen =
- 		cpu_to_be32(FW_VI_RXMODE_CMD_MTU(mtu) |
- 			    FW_VI_RXMODE_CMD_PROMISCEN(promisc) |
- 			    FW_VI_RXMODE_CMD_ALLMULTIEN(all_multi) |
- 			    FW_VI_RXMODE_CMD_BROADCASTEN(bcast) |
- 			    FW_VI_RXMODE_CMD_VLANEXEN(vlanex));
+ 		cpu_to_be32(FW_VI_RXMODE_CMD_MTU_V(mtu) |
+ 			    FW_VI_RXMODE_CMD_PROMISCEN_V(promisc) |
+ 			    FW_VI_RXMODE_CMD_ALLMULTIEN_V(all_multi) |
+ 			    FW_VI_RXMODE_CMD_BROADCASTEN_V(bcast) |
+ 			    FW_VI_RXMODE_CMD_VLANEXEN_V(vlanex));
  	return t4vf_wr_mbox_core(adapter, &cmd, sizeof(cmd), NULL, sleep_ok);
  }
  
@@@ -1072,14 -1072,14 +1103,25 @@@ int t4vf_alloc_mac_filt(struct adapter 
  		int i;
  
  		memset(&cmd, 0, sizeof(cmd));
++<<<<<<< HEAD
 +		cmd.op_to_viid = cpu_to_be32(FW_CMD_OP(FW_VI_MAC_CMD) |
 +					     FW_CMD_REQUEST |
 +					     FW_CMD_WRITE |
 +					     (free ? FW_CMD_EXEC : 0) |
 +					     FW_VI_MAC_CMD_VIID(viid));
 +		cmd.freemacs_to_len16 =
 +			cpu_to_be32(FW_VI_MAC_CMD_FREEMACS(free) |
 +				    FW_CMD_LEN16(len16));
++=======
+ 		cmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_MAC_CMD) |
+ 					     FW_CMD_REQUEST_F |
+ 					     FW_CMD_WRITE_F |
+ 					     (free ? FW_CMD_EXEC_F : 0) |
+ 					     FW_VI_MAC_CMD_VIID_V(viid));
+ 		cmd.freemacs_to_len16 =
+ 			cpu_to_be32(FW_VI_MAC_CMD_FREEMACS_V(free) |
+ 				    FW_CMD_LEN16_V(len16));
++>>>>>>> 2b5fb1f25e7b (cxgb4/cxgb4vf/csiostor: Cleanup macros/register defines related to port and VI)
  
  		for (i = 0, p = cmd.u.exact; i < fw_naddr; i++, p++) {
  			p->valid_to_idx = cpu_to_be16(
@@@ -1161,13 -1161,13 +1203,23 @@@ int t4vf_change_mac(struct adapter *ada
  		idx = persist ? FW_VI_MAC_ADD_PERSIST_MAC : FW_VI_MAC_ADD_MAC;
  
  	memset(&cmd, 0, sizeof(cmd));
++<<<<<<< HEAD
 +	cmd.op_to_viid = cpu_to_be32(FW_CMD_OP(FW_VI_MAC_CMD) |
 +				     FW_CMD_REQUEST |
 +				     FW_CMD_WRITE |
 +				     FW_VI_MAC_CMD_VIID(viid));
 +	cmd.freemacs_to_len16 = cpu_to_be32(FW_CMD_LEN16(len16));
 +	p->valid_to_idx = cpu_to_be16(FW_VI_MAC_CMD_VALID |
 +				      FW_VI_MAC_CMD_IDX(idx));
++=======
+ 	cmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_MAC_CMD) |
+ 				     FW_CMD_REQUEST_F |
+ 				     FW_CMD_WRITE_F |
+ 				     FW_VI_MAC_CMD_VIID_V(viid));
+ 	cmd.freemacs_to_len16 = cpu_to_be32(FW_CMD_LEN16_V(len16));
+ 	p->valid_to_idx = cpu_to_be16(FW_VI_MAC_CMD_VALID_F |
+ 				      FW_VI_MAC_CMD_IDX_V(idx));
++>>>>>>> 2b5fb1f25e7b (cxgb4/cxgb4vf/csiostor: Cleanup macros/register defines related to port and VI)
  	memcpy(p->macaddr, addr, sizeof(p->macaddr));
  
  	ret = t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), &rpl);
@@@ -1198,13 -1198,13 +1250,23 @@@ int t4vf_set_addr_hash(struct adapter *
  					     u.exact[0]), 16);
  
  	memset(&cmd, 0, sizeof(cmd));
++<<<<<<< HEAD
 +	cmd.op_to_viid = cpu_to_be32(FW_CMD_OP(FW_VI_MAC_CMD) |
 +				     FW_CMD_REQUEST |
 +				     FW_CMD_WRITE |
 +				     FW_VI_ENABLE_CMD_VIID(viid));
 +	cmd.freemacs_to_len16 = cpu_to_be32(FW_VI_MAC_CMD_HASHVECEN |
 +					    FW_VI_MAC_CMD_HASHUNIEN(ucast) |
 +					    FW_CMD_LEN16(len16));
++=======
+ 	cmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_MAC_CMD) |
+ 				     FW_CMD_REQUEST_F |
+ 				     FW_CMD_WRITE_F |
+ 				     FW_VI_ENABLE_CMD_VIID_V(viid));
+ 	cmd.freemacs_to_len16 = cpu_to_be32(FW_VI_MAC_CMD_HASHVECEN_F |
+ 					    FW_VI_MAC_CMD_HASHUNIEN_V(ucast) |
+ 					    FW_CMD_LEN16_V(len16));
++>>>>>>> 2b5fb1f25e7b (cxgb4/cxgb4vf/csiostor: Cleanup macros/register defines related to port and VI)
  	cmd.u.hash.hashvec = cpu_to_be64(vec);
  	return t4vf_wr_mbox_core(adapter, &cmd, sizeof(cmd), NULL, sleep_ok);
  }
@@@ -1240,14 -1240,14 +1302,22 @@@ int t4vf_get_port_stats(struct adapter 
  		int ret;
  
  		memset(&cmd, 0, sizeof(cmd));
++<<<<<<< HEAD
 +		cmd.op_to_viid = cpu_to_be32(FW_CMD_OP(FW_VI_STATS_CMD) |
 +					     FW_VI_STATS_CMD_VIID(pi->viid) |
 +					     FW_CMD_REQUEST |
 +					     FW_CMD_READ);
 +		cmd.retval_len16 = cpu_to_be32(FW_CMD_LEN16(len16));
++=======
+ 		cmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_STATS_CMD) |
+ 					     FW_VI_STATS_CMD_VIID_V(pi->viid) |
+ 					     FW_CMD_REQUEST_F |
+ 					     FW_CMD_READ_F);
+ 		cmd.retval_len16 = cpu_to_be32(FW_CMD_LEN16_V(len16));
++>>>>>>> 2b5fb1f25e7b (cxgb4/cxgb4vf/csiostor: Cleanup macros/register defines related to port and VI)
  		cmd.u.ctl.nstats_ix =
- 			cpu_to_be16(FW_VI_STATS_CMD_IX(ix) |
- 				    FW_VI_STATS_CMD_NSTATS(nstats));
+ 			cpu_to_be16(FW_VI_STATS_CMD_IX_V(ix) |
+ 				    FW_VI_STATS_CMD_NSTATS_V(nstats));
  		ret = t4vf_wr_mbox_ns(adapter, &cmd, len, &rpl);
  		if (ret)
  			return ret;
diff --cc drivers/scsi/csiostor/csio_mb.c
index 15b635142546,829887886898..000000000000
--- a/drivers/scsi/csiostor/csio_mb.c
+++ b/drivers/scsi/csiostor/csio_mb.c
@@@ -351,21 -351,21 +351,37 @@@ csio_mb_port(struct csio_hw *hw, struc
  
  	CSIO_INIT_MBP(mbp, cmdp, tmo, hw, cbfn,  1);
  
++<<<<<<< HEAD
 +	cmdp->op_to_portid = htonl(FW_CMD_OP(FW_PORT_CMD)		|
 +				   FW_CMD_REQUEST			|
 +				   (wr ? FW_CMD_EXEC : FW_CMD_READ)	|
 +				   FW_PORT_CMD_PORTID(portid));
 +	if (!wr) {
 +		cmdp->action_to_len16 = htonl(
 +			FW_PORT_CMD_ACTION(FW_PORT_ACTION_GET_PORT_INFO) |
 +			FW_CMD_LEN16(sizeof(*cmdp) / 16));
++=======
+ 	cmdp->op_to_portid = htonl(FW_CMD_OP_V(FW_PORT_CMD)		|
+ 				   FW_CMD_REQUEST_F			|
+ 				   (wr ? FW_CMD_EXEC_F : FW_CMD_READ_F)	|
+ 				   FW_PORT_CMD_PORTID_V(portid));
+ 	if (!wr) {
+ 		cmdp->action_to_len16 = htonl(
+ 			FW_PORT_CMD_ACTION_V(FW_PORT_ACTION_GET_PORT_INFO) |
+ 			FW_CMD_LEN16_V(sizeof(*cmdp) / 16));
++>>>>>>> 2b5fb1f25e7b (cxgb4/cxgb4vf/csiostor: Cleanup macros/register defines related to port and VI)
  		return;
  	}
  
  	/* Set port */
  	cmdp->action_to_len16 = htonl(
++<<<<<<< HEAD
 +			FW_PORT_CMD_ACTION(FW_PORT_ACTION_L1_CFG) |
 +			FW_CMD_LEN16(sizeof(*cmdp) / 16));
++=======
+ 			FW_PORT_CMD_ACTION_V(FW_PORT_ACTION_L1_CFG) |
+ 			FW_CMD_LEN16_V(sizeof(*cmdp) / 16));
++>>>>>>> 2b5fb1f25e7b (cxgb4/cxgb4vf/csiostor: Cleanup macros/register defines related to port and VI)
  
  	if (fc & PAUSE_RX)
  		lfc |= FW_PORT_CAP_FC_RX;
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_dcb.c
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_dcb.h
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/l2t.c
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/t4fw_api.h
* Unmerged path drivers/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c
* Unmerged path drivers/scsi/csiostor/csio_mb.c
