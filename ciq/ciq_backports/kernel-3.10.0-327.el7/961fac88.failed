ixgbe: Add a PHY power state method

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Don Skidmore <donald.c.skidmore@intel.com>
commit 961fac889c0f2e1930092b6de00043cdd1cb2942
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/961fac88.failed

This new method will control the PHY power state.  You pass in the
state you wish to change to (ether on or off).  For cases where this
method is not used the current PHY power state behavior is maintained.

	Signed-off-by: Don Skidmore <donald.c.skidmore@intel.com>
	Tested-by: Krishneil Singh <krishneil.k.singh@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 961fac889c0f2e1930092b6de00043cdd1cb2942)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index 7c1f55ce1360,1b2bdbf5980e..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@@ -4373,6 -4877,10 +4373,13 @@@ static void ixgbe_up_complete(struct ix
  	if (hw->mac.ops.enable_tx_laser)
  		hw->mac.ops.enable_tx_laser(hw);
  
++<<<<<<< HEAD
++=======
+ 	if (hw->phy.ops.set_phy_power)
+ 		hw->phy.ops.set_phy_power(hw, true);
+ 
+ 	smp_mb__before_atomic();
++>>>>>>> 961fac889c0f (ixgbe: Add a PHY power state method)
  	clear_bit(__IXGBE_DOWN, &adapter->state);
  	ixgbe_napi_enable_all(adapter);
  
@@@ -4491,61 -4999,15 +4498,68 @@@ void ixgbe_reset(struct ixgbe_adapter *
  
  	if (test_bit(__IXGBE_PTP_RUNNING, &adapter->state))
  		ixgbe_ptp_reset(adapter);
+ 
+ 	if (hw->phy.ops.set_phy_power) {
+ 		if (!netif_running(adapter->netdev) && !adapter->wol)
+ 			hw->phy.ops.set_phy_power(hw, false);
+ 		else
+ 			hw->phy.ops.set_phy_power(hw, true);
+ 	}
  }
  
 +/**
 + * ixgbe_clean_rx_ring - Free Rx Buffers per Queue
 + * @rx_ring: ring to free buffers from
 + **/
 +static void ixgbe_clean_rx_ring(struct ixgbe_ring *rx_ring)
 +{
 +	struct device *dev = rx_ring->dev;
 +	unsigned long size;
 +	u16 i;
 +
 +	/* ring already cleared, nothing to do */
 +	if (!rx_ring->rx_buffer_info)
 +		return;
 +
 +	/* Free all the Rx ring sk_buffs */
 +	for (i = 0; i < rx_ring->count; i++) {
 +		struct ixgbe_rx_buffer *rx_buffer;
 +
 +		rx_buffer = &rx_ring->rx_buffer_info[i];
 +		if (rx_buffer->skb) {
 +			struct sk_buff *skb = rx_buffer->skb;
 +			if (IXGBE_CB(skb)->page_released) {
 +				dma_unmap_page(dev,
 +					       IXGBE_CB(skb)->dma,
 +					       ixgbe_rx_bufsz(rx_ring),
 +					       DMA_FROM_DEVICE);
 +				IXGBE_CB(skb)->page_released = false;
 +			}
 +			dev_kfree_skb(skb);
 +		}
 +		rx_buffer->skb = NULL;
 +		if (rx_buffer->dma)
 +			dma_unmap_page(dev, rx_buffer->dma,
 +				       ixgbe_rx_pg_size(rx_ring),
 +				       DMA_FROM_DEVICE);
 +		rx_buffer->dma = 0;
 +		if (rx_buffer->page)
 +			__free_pages(rx_buffer->page,
 +				     ixgbe_rx_pg_order(rx_ring));
 +		rx_buffer->page = NULL;
 +	}
 +
 +	size = sizeof(struct ixgbe_rx_buffer) * rx_ring->count;
 +	memset(rx_ring->rx_buffer_info, 0, size);
 +
 +	/* Zero out the descriptor ring */
 +	memset(rx_ring->desc, 0, rx_ring->size);
 +
 +	rx_ring->next_to_alloc = 0;
 +	rx_ring->next_to_clean = 0;
 +	rx_ring->next_to_use = 0;
 +}
 +
  /**
   * ixgbe_clean_tx_ring - Free Tx Buffers
   * @tx_ring: ring to be cleaned
@@@ -5191,7 -5686,8 +5205,12 @@@ static int ixgbe_change_mtu(struct net_
  static int ixgbe_open(struct net_device *netdev)
  {
  	struct ixgbe_adapter *adapter = netdev_priv(netdev);
++<<<<<<< HEAD
 +	int err;
++=======
+ 	struct ixgbe_hw *hw = &adapter->hw;
+ 	int err, queues;
++>>>>>>> 961fac889c0f (ixgbe: Add a PHY power state method)
  
  	/* disallow open during test */
  	if (test_bit(__IXGBE_TESTING, &adapter->state))
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c
index 7481c33b25ed..b7e56ca21cd0 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c
@@ -1347,7 +1347,7 @@ static struct ixgbe_phy_operations phy_ops_82598 = {
 	.setup_link_speed	= &ixgbe_setup_phy_link_speed_generic,
 	.read_i2c_sff8472	= &ixgbe_read_i2c_sff8472_82598,
 	.read_i2c_eeprom	= &ixgbe_read_i2c_eeprom_82598,
-	.check_overtemp   = &ixgbe_tn_check_overtemp,
+	.check_overtemp		= &ixgbe_tn_check_overtemp,
 };
 
 struct ixgbe_info ixgbe_82598_info = {
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c
index dbded7df0b49..459bd7afe207 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c
@@ -2233,3 +2233,36 @@ s32 ixgbe_tn_check_overtemp(struct ixgbe_hw *hw)
 out:
 	return status;
 }
+
+/** ixgbe_set_copper_phy_power - Control power for copper phy
+ *  @hw: pointer to hardware structure
+ *  @on: true for on, false for off
+ **/
+s32 ixgbe_set_copper_phy_power(struct ixgbe_hw *hw, bool on)
+{
+	u32 status;
+	u16 reg;
+
+	/* Bail if we don't have copper phy */
+	if (hw->mac.ops.get_media_type(hw) != ixgbe_media_type_copper)
+		return 0;
+
+	status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_VENDOR_SPECIFIC_1_CONTROL,
+				      IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,
+				      &reg);
+	if (status)
+		return status;
+
+	if (on) {
+		reg &= ~IXGBE_MDIO_PHY_SET_LOW_POWER_MODE;
+	} else {
+		if (ixgbe_check_reset_blocked(hw))
+			return 0;
+		reg |= IXGBE_MDIO_PHY_SET_LOW_POWER_MODE;
+	}
+
+	status = hw->phy.ops.write_reg(hw, IXGBE_MDIO_VENDOR_SPECIFIC_1_CONTROL,
+				       IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,
+				       reg);
+	return status;
+}
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.h b/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.h
index 86056a152e87..624bd7150642 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.h
@@ -145,6 +145,7 @@ s32 ixgbe_get_phy_firmware_version_generic(struct ixgbe_hw *hw,
                                            u16 *firmware_version);
 
 s32 ixgbe_reset_phy_nl(struct ixgbe_hw *hw);
+s32 ixgbe_set_copper_phy_power(struct ixgbe_hw *hw, bool on);
 s32 ixgbe_identify_module_generic(struct ixgbe_hw *hw);
 s32 ixgbe_identify_sfp_module_generic(struct ixgbe_hw *hw);
 s32 ixgbe_identify_qsfp_module_generic(struct ixgbe_hw *hw);
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h b/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h
index e222298e3e6c..1cec7c77da8b 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h
@@ -1190,6 +1190,8 @@ struct ixgbe_thermal_sensor_data {
 #define IXGBE_MDIO_AUTO_NEG_LP		0x13 /* AUTO_NEG LP Status Reg */
 #define IXGBE_MDIO_AUTO_NEG_EEE_ADVT	0x3C /* AUTO_NEG EEE Advt Reg */
 
+#define IXGBE_MDIO_PHY_SET_LOW_POWER_MODE	 0x0800 /* Set low power mode */
+
 #define IXGBE_MDIO_TX_VENDOR_ALARMS_3	0xCC02 /* Vendor Alarms 3 Reg */
 #define IXGBE_MDIO_TX_VENDOR_ALARMS_3_RST_MASK 0x3 /* PHY Reset Complete Mask */
 #define IXGBE_MDIO_GLOBAL_RES_PR_10 0xC479 /* Global Resv Provisioning 10 Reg */
@@ -3105,6 +3107,7 @@ struct ixgbe_phy_operations {
 	s32 (*read_i2c_combined)(struct ixgbe_hw *, u8 addr, u16 reg, u16 *val);
 	s32 (*write_i2c_combined)(struct ixgbe_hw *, u8 addr, u16 reg, u16 val);
 	s32 (*check_overtemp)(struct ixgbe_hw *);
+	s32 (*set_phy_power)(struct ixgbe_hw *, bool on);
 };
 
 struct ixgbe_eeprom_info {
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c
index e1e1c70deb2a..c8516dd284c4 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c
@@ -884,6 +884,7 @@ static struct ixgbe_phy_operations phy_ops_X540 = {
 	.read_i2c_eeprom        = &ixgbe_read_i2c_eeprom_generic,
 	.write_i2c_eeprom       = &ixgbe_write_i2c_eeprom_generic,
 	.check_overtemp         = &ixgbe_tn_check_overtemp,
+	.set_phy_power          = &ixgbe_set_copper_phy_power,
 	.get_firmware_version   = &ixgbe_get_phy_firmware_version_generic,
 };
 
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
index 6489157715ec..6a2a677d1906 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
@@ -1458,6 +1458,7 @@ static struct ixgbe_phy_operations phy_ops_X550 = {
 	.setup_link		= &ixgbe_setup_phy_link_generic,
 	.read_i2c_combined	= &ixgbe_read_i2c_combined_generic,
 	.write_i2c_combined	= &ixgbe_write_i2c_combined_generic,
+	.set_phy_power		= &ixgbe_set_copper_phy_power,
 };
 
 static struct ixgbe_phy_operations phy_ops_X550EM_x = {
