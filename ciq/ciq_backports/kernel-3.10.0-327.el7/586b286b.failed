dm crypt: constrain crypt device's max_segment_size to PAGE_SIZE

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [md] dm-crypt: constrain crypt device's max_segment_size to PAGE_SIZE (Mike Snitzer) [1252726]
Rebuild_FUZZ: 98.44%
commit-author Mike Snitzer <snitzer@redhat.com>
commit 586b286b110e94eb31840ac5afc0c24e0881fe34
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/586b286b.failed

Setting the dm-crypt device's max_segment_size to PAGE_SIZE is an
unfortunate constraint that is required to avoid the potential for
exceeding dm-crypt's underlying device's max_segments limits -- due to
crypt_alloc_buffer() possibly allocating pages for the encryption bio
that are not as physically contiguous as the original bio.

It is interesting to note that this problem was already fixed back in
2007 via commit 91e106259 ("dm crypt: use bio_add_page").  But Linux 4.0
commit cf2f1abfb ("dm crypt: don't allocate pages for a partial
request") regressed dm-crypt back to _not_ using bio_add_page().  But
given dm-crypt's cpu parallelization changes all depend on commit
cf2f1abfb's abandoning of the more complex io fragments processing that
dm-crypt previously had we cannot easily go back to using
bio_add_page().

So all said the cleanest way to resolve this issue is to fix dm-crypt to
properly constrain the original bios entering dm-crypt so the encryption
bios that dm-crypt generates from the original bios are always
compatible with the underlying device's max_segments queue limits.

It should be noted that technically Linux 4.3 does _not_ need this fix
because of the block core's new late bio-splitting capability.  But, it
is reasoned, there is little to be gained by having the block core split
the encrypted bio that is composed of PAGE_SIZE segments.  That said, in
the future we may revert this change.

Fixes: cf2f1abfb ("dm crypt: don't allocate pages for a partial request")
Fixes: https://bugzilla.kernel.org/show_bug.cgi?id=104421
	Suggested-by: Jeff Moyer <jmoyer@redhat.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
	Cc: stable@vger.kernel.org # 4.0+
(cherry picked from commit 586b286b110e94eb31840ac5afc0c24e0881fe34)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-crypt.c
diff --cc drivers/md/dm-crypt.c
index 6acf8138dba2,4b3b6f8aff0c..000000000000
--- a/drivers/md/dm-crypt.c
+++ b/drivers/md/dm-crypt.c
@@@ -961,14 -964,26 +961,31 @@@ static int crypt_convert(struct crypt_c
  	return 0;
  }
  
 -static void crypt_free_buffer_pages(struct crypt_config *cc, struct bio *clone);
 -
  /*
   * Generate a new unfragmented bio with the given size
++<<<<<<< HEAD
 + * This should never violate the device limitations
 + * May return a smaller bio when running out of pages, indicated by
 + * *out_of_pages set to 1.
++=======
+  * This should never violate the device limitations (but only because
+  * max_segment_size is being constrained to PAGE_SIZE).
+  *
+  * This function may be called concurrently. If we allocate from the mempool
+  * concurrently, there is a possibility of deadlock. For example, if we have
+  * mempool of 256 pages, two processes, each wanting 256, pages allocate from
+  * the mempool concurrently, it may deadlock in a situation where both processes
+  * have allocated 128 pages and the mempool is exhausted.
+  *
+  * In order to avoid this scenario we allocate the pages under a mutex.
+  *
+  * In order to not degrade performance with excessive locking, we try
+  * non-blocking allocations without a mutex first but on failure we fallback
+  * to blocking allocations with a mutex.
++>>>>>>> 586b286b110e (dm crypt: constrain crypt device's max_segment_size to PAGE_SIZE)
   */
 -static struct bio *crypt_alloc_buffer(struct dm_crypt_io *io, unsigned size)
 +static struct bio *crypt_alloc_buffer(struct dm_crypt_io *io, unsigned size,
 +				      unsigned *out_of_pages)
  {
  	struct crypt_config *cc = io->cc;
  	struct bio *clone;
@@@ -2011,8 -2069,8 +2039,9 @@@ static struct target_type crypt_target 
  	.preresume = crypt_preresume,
  	.resume = crypt_resume,
  	.message = crypt_message,
 +	.merge  = crypt_merge,
  	.iterate_devices = crypt_iterate_devices,
+ 	.io_hints = crypt_io_hints,
  };
  
  static int __init dm_crypt_init(void)
* Unmerged path drivers/md/dm-crypt.c
