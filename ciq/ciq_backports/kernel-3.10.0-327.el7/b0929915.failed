bonding: Fix RTNL: assertion failed at net/core/rtnetlink.c for ab arp monitor

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author dingtianhong <dingtianhong@huawei.com>
commit b0929915e0356acedf59504521c097ecada88b19
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/b0929915.failed

Veaceslav has reported and fix this problem by commit f2ebd477f141bc0
(bonding: restructure locking of bond_ab_arp_probe()). According Jay's
opinion, the current solution is not very well, because the notification
is to indicate that the interface has actually changed state in a meaningful
way, but these calls in the ab ARP monitor are internal settings of the flags
to allow the ARP monitor to search for a slave to become active when there are
no active slaves. The flag setting to active or backup is to permit the ARP
monitor's response logic to do the right thing when deciding if the test
slave (current_arp_slave) is up or not.

So the best way to fix the problem is that we should not send a notification
when the slave is in testing state, and check the state at the end of the
monitor, if the slave's state recover, avoid to send pointless notification
twice. And RTNL is really a big lock, hold it regardless the slave's state
changed or not when the current_active_slave is null will loss performance
(every 100ms), so we should hold it only when the slave's state changed and
need to notify.

I revert the old commit and add new modifications.

	Cc: Jay Vosburgh <fubar@us.ibm.com>
	Cc: Veaceslav Falico <vfalico@redhat.com>
	Cc: Andy Gospodarek <andy@greyhouse.net>
	Signed-off-by: Ding Tianhong <dingtianhong@huawei.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b0929915e0356acedf59504521c097ecada88b19)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_3ad.c
#	drivers/net/bonding/bond_main.c
diff --cc drivers/net/bonding/bond_3ad.c
index dc508c87249d,dcde56057fe1..000000000000
--- a/drivers/net/bonding/bond_3ad.c
+++ b/drivers/net/bonding/bond_3ad.c
@@@ -2166,7 -2120,19 +2166,23 @@@ void bond_3ad_state_machine_handler(str
  	}
  
  re_arm:
++<<<<<<< HEAD
 +	rtnl_unlock();
++=======
+ 	bond_for_each_slave_rcu(bond, slave, iter) {
+ 		if (slave->should_notify) {
+ 			should_notify_rtnl = BOND_SLAVE_NOTIFY_NOW;
+ 			break;
+ 		}
+ 	}
+ 	rcu_read_unlock();
+ 	read_unlock(&bond->lock);
+ 
+ 	if (should_notify_rtnl && rtnl_trylock()) {
+ 		bond_slave_state_notify(bond);
+ 		rtnl_unlock();
+ 	}
++>>>>>>> b0929915e035 (bonding: Fix RTNL: assertion failed at net/core/rtnetlink.c for ab arp monitor)
  	queue_delayed_work(bond->wq, &bond->ad_work, ad_delta_in_ticks);
  }
  
diff --cc drivers/net/bonding/bond_main.c
index a013179836f0,82b70ff1fd28..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -2917,52 -2624,46 +2917,86 @@@ do_failover
  /*
   * Send ARP probes for active-backup mode ARP monitor.
   *
++<<<<<<< HEAD
 + * Called with bond->lock held for read.
++=======
+  * Called with rcu_read_lock hold.
++>>>>>>> b0929915e035 (bonding: Fix RTNL: assertion failed at net/core/rtnetlink.c for ab arp monitor)
   */
 -static bool bond_ab_arp_probe(struct bonding *bond)
 +static void bond_ab_arp_probe(struct bonding *bond)
  {
++<<<<<<< HEAD
 +	struct slave *slave;
 +	int i;
 +
 +	read_lock(&bond->curr_slave_lock);
++=======
+ 	struct slave *slave, *before = NULL, *new_slave = NULL,
+ 		     *curr_arp_slave = rcu_dereference(bond->current_arp_slave),
+ 		     *curr_active_slave = rcu_dereference(bond->curr_active_slave);
+ 	struct list_head *iter;
+ 	bool found = false;
+ 	bool should_notify_rtnl = BOND_SLAVE_NOTIFY_LATER;
++>>>>>>> b0929915e035 (bonding: Fix RTNL: assertion failed at net/core/rtnetlink.c for ab arp monitor)
  
 -	if (curr_arp_slave && curr_active_slave)
 +	if (bond->current_arp_slave && bond->curr_active_slave)
  		pr_info("PROBE: c_arp %s && cas %s BAD\n",
 -			curr_arp_slave->dev->name,
 -			curr_active_slave->dev->name);
 +			bond->current_arp_slave->dev->name,
 +			bond->curr_active_slave->dev->name);
 +
++<<<<<<< HEAD
 +	if (bond->curr_active_slave) {
 +		bond_arp_send_all(bond, bond->curr_active_slave);
 +		read_unlock(&bond->curr_slave_lock);
 +		return;
 +	}
  
 +	read_unlock(&bond->curr_slave_lock);
++=======
+ 	if (curr_active_slave) {
+ 		bond_arp_send_all(bond, curr_active_slave);
+ 		return should_notify_rtnl;
+ 	}
++>>>>>>> b0929915e035 (bonding: Fix RTNL: assertion failed at net/core/rtnetlink.c for ab arp monitor)
  
  	/* if we don't have a curr_active_slave, search for the next available
  	 * backup slave from the current_arp_slave and make it the candidate
  	 * for becoming the curr_active_slave
  	 */
  
++<<<<<<< HEAD
 +	if (!bond->current_arp_slave) {
 +		bond->current_arp_slave = bond->first_slave;
 +		if (!bond->current_arp_slave)
 +			return;
 +	}
 +
 +	bond_set_slave_inactive_flags(bond->current_arp_slave);
 +
 +	/* search for next candidate */
 +	bond_for_each_slave_from(bond, slave, i, bond->current_arp_slave->next) {
 +		if (IS_UP(slave->dev)) {
 +			slave->link = BOND_LINK_BACK;
 +			bond_set_slave_active_flags(slave);
 +			bond_arp_send_all(bond, slave);
 +			slave->jiffies = jiffies;
 +			bond->current_arp_slave = slave;
 +			break;
 +		}
++=======
+ 	if (!curr_arp_slave) {
+ 		curr_arp_slave = bond_first_slave_rcu(bond);
+ 		if (!curr_arp_slave)
+ 			return should_notify_rtnl;
+ 	}
+ 
+ 	bond_set_slave_inactive_flags(curr_arp_slave, BOND_SLAVE_NOTIFY_LATER);
+ 
+ 	bond_for_each_slave_rcu(bond, slave, iter) {
+ 		if (!found && !before && IS_UP(slave->dev))
+ 			before = slave;
++>>>>>>> b0929915e035 (bonding: Fix RTNL: assertion failed at net/core/rtnetlink.c for ab arp monitor)
  
 -		if (found && !new_slave && IS_UP(slave->dev))
 -			new_slave = slave;
  		/* if the link state is up at this point, we
  		 * mark it down - this can happen if we have
  		 * simultaneous link failures and
@@@ -2975,32 -2676,57 +3009,74 @@@
  			if (slave->link_failure_count < UINT_MAX)
  				slave->link_failure_count++;
  
++<<<<<<< HEAD
 +			bond_set_slave_inactive_flags(slave);
++=======
+ 			bond_set_slave_inactive_flags(slave,
+ 						      BOND_SLAVE_NOTIFY_LATER);
++>>>>>>> b0929915e035 (bonding: Fix RTNL: assertion failed at net/core/rtnetlink.c for ab arp monitor)
  
  			pr_info("%s: backup interface %s is now down.\n",
  				bond->dev->name, slave->dev->name);
  		}
 -		if (slave == curr_arp_slave)
 -			found = true;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (!new_slave && before)
+ 		new_slave = before;
+ 
+ 	if (!new_slave)
+ 		goto check_state;
+ 
+ 	new_slave->link = BOND_LINK_BACK;
+ 	bond_set_slave_active_flags(new_slave, BOND_SLAVE_NOTIFY_LATER);
+ 	bond_arp_send_all(bond, new_slave);
+ 	new_slave->jiffies = jiffies;
+ 	rcu_assign_pointer(bond->current_arp_slave, new_slave);
+ 
+ check_state:
+ 	bond_for_each_slave_rcu(bond, slave, iter) {
+ 		if (slave->should_notify) {
+ 			should_notify_rtnl = BOND_SLAVE_NOTIFY_NOW;
+ 			break;
+ 		}
+ 	}
+ 	return should_notify_rtnl;
++>>>>>>> b0929915e035 (bonding: Fix RTNL: assertion failed at net/core/rtnetlink.c for ab arp monitor)
  }
  
 -static void bond_activebackup_arp_mon(struct work_struct *work)
 +void bond_activebackup_arp_mon(struct work_struct *work)
  {
  	struct bonding *bond = container_of(work, struct bonding,
  					    arp_work.work);
  	bool should_notify_peers = false;
++<<<<<<< HEAD
++=======
+ 	bool should_notify_rtnl = false;
++>>>>>>> b0929915e035 (bonding: Fix RTNL: assertion failed at net/core/rtnetlink.c for ab arp monitor)
  	int delta_in_ticks;
  
 +	read_lock(&bond->lock);
 +
  	delta_in_ticks = msecs_to_jiffies(bond->params.arp_interval);
  
 -	if (!bond_has_slaves(bond))
 +	if (bond->slave_cnt == 0)
  		goto re_arm;
  
++<<<<<<< HEAD
 +	should_notify_peers = bond_should_notify_peers(bond);
 +
 +	if (bond_ab_arp_inspect(bond, delta_in_ticks)) {
 +		read_unlock(&bond->lock);
++=======
+ 	rcu_read_lock();
+ 
+ 	should_notify_peers = bond_should_notify_peers(bond);
+ 
+ 	if (bond_ab_arp_inspect(bond)) {
+ 		rcu_read_unlock();
++>>>>>>> b0929915e035 (bonding: Fix RTNL: assertion failed at net/core/rtnetlink.c for ab arp monitor)
  
  		/* Race avoidance with bond_close flush of workqueue */
  		if (!rtnl_trylock()) {
@@@ -3010,27 -2735,29 +3086,48 @@@
  			goto re_arm;
  		}
  
++<<<<<<< HEAD
 +		read_lock(&bond->lock);
 +
 +		bond_ab_arp_commit(bond, delta_in_ticks);
 +
 +		read_unlock(&bond->lock);
 +		rtnl_unlock();
 +		read_lock(&bond->lock);
 +	}
 +
 +	bond_ab_arp_probe(bond);
++=======
+ 		bond_ab_arp_commit(bond);
+ 
+ 		rtnl_unlock();
+ 		rcu_read_lock();
+ 	}
+ 
+ 	should_notify_rtnl = bond_ab_arp_probe(bond);
+ 	rcu_read_unlock();
++>>>>>>> b0929915e035 (bonding: Fix RTNL: assertion failed at net/core/rtnetlink.c for ab arp monitor)
  
  re_arm:
  	if (bond->params.arp_interval)
  		queue_delayed_work(bond->wq, &bond->arp_work, delta_in_ticks);
  
++<<<<<<< HEAD
 +	read_unlock(&bond->lock);
 +
 +	if (should_notify_peers) {
++=======
+ 	if (should_notify_peers || should_notify_rtnl) {
++>>>>>>> b0929915e035 (bonding: Fix RTNL: assertion failed at net/core/rtnetlink.c for ab arp monitor)
  		if (!rtnl_trylock())
  			return;
- 		call_netdevice_notifiers(NETDEV_NOTIFY_PEERS, bond->dev);
+ 
+ 		if (should_notify_peers)
+ 			call_netdevice_notifiers(NETDEV_NOTIFY_PEERS,
+ 						 bond->dev);
+ 		if (should_notify_rtnl)
+ 			bond_slave_state_notify(bond);
+ 
  		rtnl_unlock();
  	}
  }
* Unmerged path drivers/net/bonding/bond_3ad.c
* Unmerged path drivers/net/bonding/bond_main.c
diff --git a/drivers/net/bonding/bonding.h b/drivers/net/bonding/bonding.h
index e1ca02f0b074..639421b7f03d 100644
--- a/drivers/net/bonding/bonding.h
+++ b/drivers/net/bonding/bonding.h
@@ -301,6 +301,19 @@ static inline void bond_set_backup_slave(struct slave *slave)
 	slave->backup = 1;
 }
 
+static inline void bond_slave_state_notify(struct bonding *bond)
+{
+	struct list_head *iter;
+	struct slave *tmp;
+
+	bond_for_each_slave(bond, tmp, iter) {
+		if (tmp->should_notify) {
+			rtmsg_ifinfo(RTM_NEWLINK, tmp->dev, 0, GFP_KERNEL);
+			tmp->should_notify = 0;
+		}
+	}
+}
+
 static inline int bond_slave_state(struct slave *slave)
 {
 	return slave->backup;
