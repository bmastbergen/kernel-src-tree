tcp: remove in_flight parameter from cong_avoid() methods

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Eric Dumazet <edumazet@google.com>
commit 249015515fe3fc9818d86cb5c83bbc92505ad7dc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/24901551.failed

Commit e114a710aa505 ("tcp: fix cwnd limited checking to improve
congestion control") obsoleted in_flight parameter from
tcp_is_cwnd_limited() and its callers.

This patch does the removal as promised.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Acked-by: Neal Cardwell <ncardwell@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 249015515fe3fc9818d86cb5c83bbc92505ad7dc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/tcp.h
#	net/ipv4/tcp_bic.c
#	net/ipv4/tcp_cong.c
#	net/ipv4/tcp_cubic.c
#	net/ipv4/tcp_highspeed.c
#	net/ipv4/tcp_htcp.c
#	net/ipv4/tcp_hybla.c
#	net/ipv4/tcp_illinois.c
#	net/ipv4/tcp_input.c
#	net/ipv4/tcp_lp.c
#	net/ipv4/tcp_output.c
#	net/ipv4/tcp_scalable.c
#	net/ipv4/tcp_vegas.c
#	net/ipv4/tcp_veno.c
#	net/ipv4/tcp_yeah.c
diff --cc include/net/tcp.h
index ba45accd7103,3c9418456640..000000000000
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@@ -796,10 -795,8 +796,14 @@@ struct tcp_congestion_ops 
  
  	/* return slow start threshold (required) */
  	u32 (*ssthresh)(struct sock *sk);
 +	/* lower bound for congestion window (optional) */
 +	u32 (*min_cwnd)(const struct sock *sk);
  	/* do new cwnd calculation (required) */
++<<<<<<< HEAD
 +	void (*cong_avoid)(struct sock *sk, u32 ack, u32 in_flight);
++=======
+ 	void (*cong_avoid)(struct sock *sk, u32 ack, u32 acked);
++>>>>>>> 249015515fe3 (tcp: remove in_flight parameter from cong_avoid() methods)
  	/* call before changing ca_state (optional) */
  	void (*set_state)(struct sock *sk, u8 new_state);
  	/* call when cwnd event occurs (optional) */
@@@ -815,24 -812,23 +819,29 @@@
  	struct module 	*owner;
  };
  
 -int tcp_register_congestion_control(struct tcp_congestion_ops *type);
 -void tcp_unregister_congestion_control(struct tcp_congestion_ops *type);
 +extern int tcp_register_congestion_control(struct tcp_congestion_ops *type);
 +extern void tcp_unregister_congestion_control(struct tcp_congestion_ops *type);
  
 -void tcp_init_congestion_control(struct sock *sk);
 -void tcp_cleanup_congestion_control(struct sock *sk);
 -int tcp_set_default_congestion_control(const char *name);
 -void tcp_get_default_congestion_control(char *name);
 -void tcp_get_available_congestion_control(char *buf, size_t len);
 -void tcp_get_allowed_congestion_control(char *buf, size_t len);
 -int tcp_set_allowed_congestion_control(char *allowed);
 -int tcp_set_congestion_control(struct sock *sk, const char *name);
 -int tcp_slow_start(struct tcp_sock *tp, u32 acked);
 -void tcp_cong_avoid_ai(struct tcp_sock *tp, u32 w);
 +extern void tcp_init_congestion_control(struct sock *sk);
 +extern void tcp_cleanup_congestion_control(struct sock *sk);
 +extern int tcp_set_default_congestion_control(const char *name);
 +extern void tcp_get_default_congestion_control(char *name);
 +extern void tcp_get_available_congestion_control(char *buf, size_t len);
 +extern void tcp_get_allowed_congestion_control(char *buf, size_t len);
 +extern int tcp_set_allowed_congestion_control(char *allowed);
 +extern int tcp_set_congestion_control(struct sock *sk, const char *name);
 +extern void tcp_slow_start(struct tcp_sock *tp);
 +extern void tcp_cong_avoid_ai(struct tcp_sock *tp, u32 w);
  
  extern struct tcp_congestion_ops tcp_init_congestion_ops;
++<<<<<<< HEAD
 +extern u32 tcp_reno_ssthresh(struct sock *sk);
 +extern void tcp_reno_cong_avoid(struct sock *sk, u32 ack, u32 in_flight);
 +extern u32 tcp_reno_min_cwnd(const struct sock *sk);
++=======
+ u32 tcp_reno_ssthresh(struct sock *sk);
+ void tcp_reno_cong_avoid(struct sock *sk, u32 ack, u32 acked);
++>>>>>>> 249015515fe3 (tcp: remove in_flight parameter from cong_avoid() methods)
  extern struct tcp_congestion_ops tcp_reno;
  
  static inline void tcp_set_ca_state(struct sock *sk, const u8 ca_state)
@@@ -978,7 -974,25 +987,29 @@@ static inline u32 tcp_wnd_end(const str
  {
  	return tp->snd_una + tp->snd_wnd;
  }
++<<<<<<< HEAD
 +extern bool tcp_is_cwnd_limited(const struct sock *sk, u32 in_flight);
++=======
+ 
+ /* We follow the spirit of RFC2861 to validate cwnd but implement a more
+  * flexible approach. The RFC suggests cwnd should not be raised unless
+  * it was fully used previously. But we allow cwnd to grow as long as the
+  * application has used half the cwnd.
+  * Example :
+  *    cwnd is 10 (IW10), but application sends 9 frames.
+  *    We allow cwnd to reach 18 when all frames are ACKed.
+  * This check is safe because it's as aggressive as slow start which already
+  * risks 100% overshoot. The advantage is that we discourage application to
+  * either send more filler packets or data to artificially blow up the cwnd
+  * usage, and allow application-limited process to probe bw more aggressively.
+  */
+ static inline bool tcp_is_cwnd_limited(const struct sock *sk)
+ {
+ 	const struct tcp_sock *tp = tcp_sk(sk);
+ 
+ 	return tp->snd_cwnd < 2 * tp->lsnd_pending;
+ }
++>>>>>>> 249015515fe3 (tcp: remove in_flight parameter from cong_avoid() methods)
  
  static inline void tcp_check_probe_timer(struct sock *sk)
  {
diff --cc net/ipv4/tcp_bic.c
index f45e1c242440,d5de69bc04f5..000000000000
--- a/net/ipv4/tcp_bic.c
+++ b/net/ipv4/tcp_bic.c
@@@ -140,7 -140,7 +140,11 @@@ static inline void bictcp_update(struc
  		ca->cnt = 1;
  }
  
++<<<<<<< HEAD
 +static void bictcp_cong_avoid(struct sock *sk, u32 ack, u32 in_flight)
++=======
+ static void bictcp_cong_avoid(struct sock *sk, u32 ack, u32 acked)
++>>>>>>> 249015515fe3 (tcp: remove in_flight parameter from cong_avoid() methods)
  {
  	struct tcp_sock *tp = tcp_sk(sk);
  	struct bictcp *ca = inet_csk_ca(sk);
diff --cc net/ipv4/tcp_cong.c
index 31e31ad03cad,7b09d8b49fa5..000000000000
--- a/net/ipv4/tcp_cong.c
+++ b/net/ipv4/tcp_cong.c
@@@ -350,7 -317,7 +350,11 @@@ EXPORT_SYMBOL_GPL(tcp_cong_avoid_ai)
  /* This is Jacobson's slow start and congestion avoidance.
   * SIGCOMM '88, p. 328.
   */
++<<<<<<< HEAD
 +void tcp_reno_cong_avoid(struct sock *sk, u32 ack, u32 in_flight)
++=======
+ void tcp_reno_cong_avoid(struct sock *sk, u32 ack, u32 acked)
++>>>>>>> 249015515fe3 (tcp: remove in_flight parameter from cong_avoid() methods)
  {
  	struct tcp_sock *tp = tcp_sk(sk);
  
diff --cc net/ipv4/tcp_cubic.c
index 894b7cea5d7b,ba2a4f3a6a1e..000000000000
--- a/net/ipv4/tcp_cubic.c
+++ b/net/ipv4/tcp_cubic.c
@@@ -304,7 -304,7 +304,11 @@@ static inline void bictcp_update(struc
  		ca->cnt = 1;
  }
  
++<<<<<<< HEAD
 +static void bictcp_cong_avoid(struct sock *sk, u32 ack, u32 in_flight)
++=======
+ static void bictcp_cong_avoid(struct sock *sk, u32 ack, u32 acked)
++>>>>>>> 249015515fe3 (tcp: remove in_flight parameter from cong_avoid() methods)
  {
  	struct tcp_sock *tp = tcp_sk(sk);
  	struct bictcp *ca = inet_csk_ca(sk);
diff --cc net/ipv4/tcp_highspeed.c
index 30f27f6b3655,1c4908280d92..000000000000
--- a/net/ipv4/tcp_highspeed.c
+++ b/net/ipv4/tcp_highspeed.c
@@@ -109,7 -109,7 +109,11 @@@ static void hstcp_init(struct sock *sk
  	tp->snd_cwnd_clamp = min_t(u32, tp->snd_cwnd_clamp, 0xffffffff/128);
  }
  
++<<<<<<< HEAD
 +static void hstcp_cong_avoid(struct sock *sk, u32 adk, u32 in_flight)
++=======
+ static void hstcp_cong_avoid(struct sock *sk, u32 ack, u32 acked)
++>>>>>>> 249015515fe3 (tcp: remove in_flight parameter from cong_avoid() methods)
  {
  	struct tcp_sock *tp = tcp_sk(sk);
  	struct hstcp *ca = inet_csk_ca(sk);
diff --cc net/ipv4/tcp_htcp.c
index c1a8175361e8,031361311a8b..000000000000
--- a/net/ipv4/tcp_htcp.c
+++ b/net/ipv4/tcp_htcp.c
@@@ -227,7 -227,7 +227,11 @@@ static u32 htcp_recalc_ssthresh(struct 
  	return max((tp->snd_cwnd * ca->beta) >> 7, 2U);
  }
  
++<<<<<<< HEAD
 +static void htcp_cong_avoid(struct sock *sk, u32 ack, u32 in_flight)
++=======
+ static void htcp_cong_avoid(struct sock *sk, u32 ack, u32 acked)
++>>>>>>> 249015515fe3 (tcp: remove in_flight parameter from cong_avoid() methods)
  {
  	struct tcp_sock *tp = tcp_sk(sk);
  	struct htcp *ca = inet_csk_ca(sk);
diff --cc net/ipv4/tcp_hybla.c
index 57bdd17dff4d,d8f8f05a4951..000000000000
--- a/net/ipv4/tcp_hybla.c
+++ b/net/ipv4/tcp_hybla.c
@@@ -85,7 -87,7 +85,11 @@@ static inline u32 hybla_fraction(u32 od
   *     o Give cwnd a new value based on the model proposed
   *     o remember increments <1
   */
++<<<<<<< HEAD
 +static void hybla_cong_avoid(struct sock *sk, u32 ack, u32 in_flight)
++=======
+ static void hybla_cong_avoid(struct sock *sk, u32 ack, u32 acked)
++>>>>>>> 249015515fe3 (tcp: remove in_flight parameter from cong_avoid() methods)
  {
  	struct tcp_sock *tp = tcp_sk(sk);
  	struct hybla *ca = inet_csk_ca(sk);
@@@ -93,16 -95,16 +97,20 @@@
  	int is_slowstart = 0;
  
  	/*  Recalculate rho only if this srtt is the lowest */
 -	if (tp->srtt_us < ca->minrtt_us) {
 +	if (tp->srtt < ca->minrtt){
  		hybla_recalc_param(sk);
 -		ca->minrtt_us = tp->srtt_us;
 +		ca->minrtt = tp->srtt;
  	}
  
- 	if (!tcp_is_cwnd_limited(sk, in_flight))
+ 	if (!tcp_is_cwnd_limited(sk))
  		return;
  
  	if (!ca->hybla_en) {
++<<<<<<< HEAD
 +		tcp_reno_cong_avoid(sk, ack, in_flight);
++=======
+ 		tcp_reno_cong_avoid(sk, ack, acked);
++>>>>>>> 249015515fe3 (tcp: remove in_flight parameter from cong_avoid() methods)
  		return;
  	}
  
diff --cc net/ipv4/tcp_illinois.c
index 834857f3c871,5999b3972e64..000000000000
--- a/net/ipv4/tcp_illinois.c
+++ b/net/ipv4/tcp_illinois.c
@@@ -256,7 -255,7 +256,11 @@@ static void tcp_illinois_state(struct s
  /*
   * Increase window in response to successful acknowledgment.
   */
++<<<<<<< HEAD
 +static void tcp_illinois_cong_avoid(struct sock *sk, u32 ack, u32 in_flight)
++=======
+ static void tcp_illinois_cong_avoid(struct sock *sk, u32 ack, u32 acked)
++>>>>>>> 249015515fe3 (tcp: remove in_flight parameter from cong_avoid() methods)
  {
  	struct tcp_sock *tp = tcp_sk(sk);
  	struct illinois *ca = inet_csk_ca(sk);
diff --cc net/ipv4/tcp_input.c
index 5c9d537a2d7a,350b2072f0ab..000000000000
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@@ -2913,14 -2934,15 +2913,22 @@@ static void tcp_synack_rtt_meas(struct 
  	/* If the ACK acks both the SYNACK and the (Fast Open'd) data packets
  	 * sent in SYN_RECV, SYNACK RTT is the smooth RTT computed in tcp_ack()
  	 */
 -	if (!tp->srtt_us)
 -		tcp_ack_update_rtt(sk, FLAG_SYN_ACKED, seq_rtt_us, -1L);
 +	if (!tp->srtt)
 +		tcp_ack_update_rtt(sk, FLAG_SYN_ACKED, seq_rtt, -1);
  }
  
++<<<<<<< HEAD
 +static void tcp_cong_avoid(struct sock *sk, u32 ack, u32 in_flight)
 +{
 +	const struct inet_connection_sock *icsk = inet_csk(sk);
 +	icsk->icsk_ca_ops->cong_avoid(sk, ack, in_flight);
++=======
+ static void tcp_cong_avoid(struct sock *sk, u32 ack, u32 acked)
+ {
+ 	const struct inet_connection_sock *icsk = inet_csk(sk);
+ 
+ 	icsk->icsk_ca_ops->cong_avoid(sk, ack, acked);
++>>>>>>> 249015515fe3 (tcp: remove in_flight parameter from cong_avoid() methods)
  	tcp_sk(sk)->snd_cwnd_stamp = tcp_time_stamp;
  }
  
@@@ -3350,7 -3365,6 +3358,10 @@@ static int tcp_ack(struct sock *sk, con
  	u32 ack_seq = TCP_SKB_CB(skb)->seq;
  	u32 ack = TCP_SKB_CB(skb)->ack_seq;
  	bool is_dupack = false;
++<<<<<<< HEAD
 +	u32 prior_in_flight, prior_cwnd = tp->snd_cwnd, prior_rtt = tp->srtt;
++=======
++>>>>>>> 249015515fe3 (tcp: remove in_flight parameter from cong_avoid() methods)
  	u32 prior_fackets;
  	int prior_packets = tp->packets_out;
  	const int prior_unsacked = tp->packets_out - tp->sacked_out;
@@@ -3437,7 -3451,7 +3447,11 @@@
  
  	/* Advance cwnd if state allows */
  	if (tcp_may_raise_cwnd(sk, flag))
++<<<<<<< HEAD
 +		tcp_cong_avoid(sk, ack, prior_in_flight);
++=======
+ 		tcp_cong_avoid(sk, ack, acked);
++>>>>>>> 249015515fe3 (tcp: remove in_flight parameter from cong_avoid() methods)
  
  	if (tcp_ack_is_dubious(sk, flag)) {
  		is_dupack = !(flag & (FLAG_SND_UNA_ADVANCED | FLAG_NOT_DUP));
diff --cc net/ipv4/tcp_lp.c
index 72f7218b03f5,1e70fa8fa793..000000000000
--- a/net/ipv4/tcp_lp.c
+++ b/net/ipv4/tcp_lp.c
@@@ -115,12 -115,12 +115,20 @@@ static void tcp_lp_init(struct sock *sk
   * Will only call newReno CA when away from inference.
   * From TCP-LP's paper, this will be handled in additive increasement.
   */
++<<<<<<< HEAD
 +static void tcp_lp_cong_avoid(struct sock *sk, u32 ack, u32 in_flight)
++=======
+ static void tcp_lp_cong_avoid(struct sock *sk, u32 ack, u32 acked)
++>>>>>>> 249015515fe3 (tcp: remove in_flight parameter from cong_avoid() methods)
  {
  	struct lp *lp = inet_csk_ca(sk);
  
  	if (!(lp->flag & LP_WITHIN_INF))
++<<<<<<< HEAD
 +		tcp_reno_cong_avoid(sk, ack, in_flight);
++=======
+ 		tcp_reno_cong_avoid(sk, ack, acked);
++>>>>>>> 249015515fe3 (tcp: remove in_flight parameter from cong_avoid() methods)
  }
  
  /**
diff --cc net/ipv4/tcp_output.c
index d009567a0b52,89277a34f2c9..000000000000
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@@ -1394,7 -1388,27 +1394,31 @@@ static void tcp_cwnd_validate(struct so
  {
  	struct tcp_sock *tp = tcp_sk(sk);
  
++<<<<<<< HEAD
 +	if (tp->packets_out >= tp->snd_cwnd) {
++=======
+ 	if (inet_csk(sk)->icsk_ca_state == TCP_CA_Open &&
+ 	    sk->sk_socket && !test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {
+ 		/* Limited by application or receiver window. */
+ 		u32 init_win = tcp_init_cwnd(tp, __sk_dst_get(sk));
+ 		u32 win_used = max(tp->snd_cwnd_used, init_win);
+ 		if (win_used < tp->snd_cwnd) {
+ 			tp->snd_ssthresh = tcp_current_ssthresh(sk);
+ 			tp->snd_cwnd = (tp->snd_cwnd + win_used) >> 1;
+ 		}
+ 		tp->snd_cwnd_used = 0;
+ 	}
+ 	tp->snd_cwnd_stamp = tcp_time_stamp;
+ }
+ 
+ static void tcp_cwnd_validate(struct sock *sk, u32 unsent_segs)
+ {
+ 	struct tcp_sock *tp = tcp_sk(sk);
+ 
+ 	tp->lsnd_pending = tp->packets_out + unsent_segs;
+ 
+ 	if (tcp_is_cwnd_limited(sk)) {
++>>>>>>> 249015515fe3 (tcp: remove in_flight parameter from cong_avoid() methods)
  		/* Network is feed fully. */
  		tp->snd_cwnd_used = 0;
  		tp->snd_cwnd_stamp = tcp_time_stamp;
diff --cc net/ipv4/tcp_scalable.c
index 8ce55b8aaec8,8250949b8853..000000000000
--- a/net/ipv4/tcp_scalable.c
+++ b/net/ipv4/tcp_scalable.c
@@@ -15,7 -15,7 +15,11 @@@
  #define TCP_SCALABLE_AI_CNT	50U
  #define TCP_SCALABLE_MD_SCALE	3
  
++<<<<<<< HEAD
 +static void tcp_scalable_cong_avoid(struct sock *sk, u32 ack, u32 in_flight)
++=======
+ static void tcp_scalable_cong_avoid(struct sock *sk, u32 ack, u32 acked)
++>>>>>>> 249015515fe3 (tcp: remove in_flight parameter from cong_avoid() methods)
  {
  	struct tcp_sock *tp = tcp_sk(sk);
  
diff --cc net/ipv4/tcp_vegas.c
index 80fa2bfd7ede,9a5e05f27f4f..000000000000
--- a/net/ipv4/tcp_vegas.c
+++ b/net/ipv4/tcp_vegas.c
@@@ -163,13 -163,13 +163,21 @@@ static inline u32 tcp_vegas_ssthresh(st
  	return  min(tp->snd_ssthresh, tp->snd_cwnd-1);
  }
  
++<<<<<<< HEAD
 +static void tcp_vegas_cong_avoid(struct sock *sk, u32 ack, u32 in_flight)
++=======
+ static void tcp_vegas_cong_avoid(struct sock *sk, u32 ack, u32 acked)
++>>>>>>> 249015515fe3 (tcp: remove in_flight parameter from cong_avoid() methods)
  {
  	struct tcp_sock *tp = tcp_sk(sk);
  	struct vegas *vegas = inet_csk_ca(sk);
  
  	if (!vegas->doing_vegas_now) {
++<<<<<<< HEAD
 +		tcp_reno_cong_avoid(sk, ack, in_flight);
++=======
+ 		tcp_reno_cong_avoid(sk, ack, acked);
++>>>>>>> 249015515fe3 (tcp: remove in_flight parameter from cong_avoid() methods)
  		return;
  	}
  
@@@ -194,7 -194,7 +202,11 @@@
  			/* We don't have enough RTT samples to do the Vegas
  			 * calculation, so we'll behave like Reno.
  			 */
++<<<<<<< HEAD
 +			tcp_reno_cong_avoid(sk, ack, in_flight);
++=======
+ 			tcp_reno_cong_avoid(sk, ack, acked);
++>>>>>>> 249015515fe3 (tcp: remove in_flight parameter from cong_avoid() methods)
  		} else {
  			u32 rtt, diff;
  			u64 target_cwnd;
diff --cc net/ipv4/tcp_veno.c
index ac43cd747bce,27b9825753d1..000000000000
--- a/net/ipv4/tcp_veno.c
+++ b/net/ipv4/tcp_veno.c
@@@ -114,13 -114,13 +114,21 @@@ static void tcp_veno_cwnd_event(struct 
  		tcp_veno_init(sk);
  }
  
++<<<<<<< HEAD
 +static void tcp_veno_cong_avoid(struct sock *sk, u32 ack, u32 in_flight)
++=======
+ static void tcp_veno_cong_avoid(struct sock *sk, u32 ack, u32 acked)
++>>>>>>> 249015515fe3 (tcp: remove in_flight parameter from cong_avoid() methods)
  {
  	struct tcp_sock *tp = tcp_sk(sk);
  	struct veno *veno = inet_csk_ca(sk);
  
  	if (!veno->doing_veno_now) {
++<<<<<<< HEAD
 +		tcp_reno_cong_avoid(sk, ack, in_flight);
++=======
+ 		tcp_reno_cong_avoid(sk, ack, acked);
++>>>>>>> 249015515fe3 (tcp: remove in_flight parameter from cong_avoid() methods)
  		return;
  	}
  
@@@ -133,7 -133,7 +141,11 @@@
  		/* We don't have enough rtt samples to do the Veno
  		 * calculation, so we'll behave like Reno.
  		 */
++<<<<<<< HEAD
 +		tcp_reno_cong_avoid(sk, ack, in_flight);
++=======
+ 		tcp_reno_cong_avoid(sk, ack, acked);
++>>>>>>> 249015515fe3 (tcp: remove in_flight parameter from cong_avoid() methods)
  	} else {
  		u64 target_cwnd;
  		u32 rtt;
diff --cc net/ipv4/tcp_yeah.c
index 05c3b6f0e8e1,599b79b8eac0..000000000000
--- a/net/ipv4/tcp_yeah.c
+++ b/net/ipv4/tcp_yeah.c
@@@ -69,7 -69,7 +69,11 @@@ static void tcp_yeah_pkts_acked(struct 
  	tcp_vegas_pkts_acked(sk, pkts_acked, rtt_us);
  }
  
++<<<<<<< HEAD
 +static void tcp_yeah_cong_avoid(struct sock *sk, u32 ack, u32 in_flight)
++=======
+ static void tcp_yeah_cong_avoid(struct sock *sk, u32 ack, u32 acked)
++>>>>>>> 249015515fe3 (tcp: remove in_flight parameter from cong_avoid() methods)
  {
  	struct tcp_sock *tp = tcp_sk(sk);
  	struct yeah *yeah = inet_csk_ca(sk);
* Unmerged path include/net/tcp.h
* Unmerged path net/ipv4/tcp_bic.c
* Unmerged path net/ipv4/tcp_cong.c
* Unmerged path net/ipv4/tcp_cubic.c
* Unmerged path net/ipv4/tcp_highspeed.c
* Unmerged path net/ipv4/tcp_htcp.c
* Unmerged path net/ipv4/tcp_hybla.c
* Unmerged path net/ipv4/tcp_illinois.c
* Unmerged path net/ipv4/tcp_input.c
* Unmerged path net/ipv4/tcp_lp.c
* Unmerged path net/ipv4/tcp_output.c
* Unmerged path net/ipv4/tcp_scalable.c
* Unmerged path net/ipv4/tcp_vegas.c
* Unmerged path net/ipv4/tcp_veno.c
* Unmerged path net/ipv4/tcp_yeah.c
