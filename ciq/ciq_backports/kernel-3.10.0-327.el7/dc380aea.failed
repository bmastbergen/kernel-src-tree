Btrfs: cleanup similar code of the buffered data data check and dio read data check

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Miao Xie <miaox@cn.fujitsu.com>
commit dc380aea5fa4636fc498a351eb720943bc644451
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/dc380aea.failed

	Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
	Signed-off-by: Chris Mason <clm@fb.com>
(cherry picked from commit dc380aea5fa4636fc498a351eb720943bc644451)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/inode.c
diff --cc fs/btrfs/inode.c
index a4bd5317d647,70eaae127181..000000000000
--- a/fs/btrfs/inode.c
+++ b/fs/btrfs/inode.c
@@@ -7189,45 -7245,26 +7198,65 @@@ unlock_err
  static void btrfs_endio_direct_read(struct bio *bio, int err)
  {
  	struct btrfs_dio_private *dip = bio->bi_private;
 -	struct bio_vec *bvec;
 +	struct bio_vec *bvec_end = bio->bi_io_vec + bio->bi_vcnt - 1;
 +	struct bio_vec *bvec = bio->bi_io_vec;
  	struct inode *inode = dip->inode;
- 	struct btrfs_root *root = BTRFS_I(inode)->root;
  	struct bio *dio_bio;
++<<<<<<< HEAD
 +	u32 *csums = (u32 *)dip->csum;
 +	int index = 0;
 +	u64 start;
++=======
+ 	struct btrfs_io_bio *io_bio = btrfs_io_bio(bio);
+ 	u64 start;
+ 	int ret;
+ 	int i;
++>>>>>>> dc380aea5fa4 (Btrfs: cleanup similar code of the buffered data data check and dio read data check)
+ 
+ 	if (err || (BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM))
+ 		goto skip_checksum;
  
  	start = dip->logical_offset;
++<<<<<<< HEAD
 +	do {
 +		if (!(BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM)) {
 +			struct page *page = bvec->bv_page;
 +			char *kaddr;
 +			u32 csum = ~(u32)0;
 +			unsigned long flags;
 +
 +			local_irq_save(flags);
 +			kaddr = kmap_atomic(page);
 +			csum = btrfs_csum_data(kaddr + bvec->bv_offset,
 +					       csum, bvec->bv_len);
 +			btrfs_csum_final(csum, (char *)&csum);
 +			kunmap_atomic(kaddr);
 +			local_irq_restore(flags);
 +
 +			flush_dcache_page(bvec->bv_page);
 +			if (csum != csums[index]) {
 +				btrfs_err(root->fs_info, "csum failed ino %llu off %llu csum %u expected csum %u",
 +					  btrfs_ino(inode), start, csum,
 +					  csums[index]);
 +				err = -EIO;
 +			}
 +		}
 +
 +		start += bvec->bv_len;
 +		bvec++;
 +		index++;
 +	} while (bvec <= bvec_end);
 +
++=======
+ 	bio_for_each_segment_all(bvec, bio, i) {
+ 		ret = __readpage_endio_check(inode, io_bio, i, bvec->bv_page,
+ 					     0, start, bvec->bv_len);
+ 		if (ret)
+ 			err = -EIO;
+ 		start += bvec->bv_len;
+ 	}
+ skip_checksum:
++>>>>>>> dc380aea5fa4 (Btrfs: cleanup similar code of the buffered data data check and dio read data check)
  	unlock_extent(&BTRFS_I(inode)->io_tree, dip->logical_offset,
  		      dip->logical_offset + dip->bytes - 1);
  	dio_bio = dip->dio_bio;
* Unmerged path fs/btrfs/inode.c
