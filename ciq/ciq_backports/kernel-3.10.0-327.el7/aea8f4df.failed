IB/iser: Use iser_warn instead of BUG_ON in iser_conn_release

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [infiniband] iser: Use iser_warn instead of BUG_ON in iser_conn_release (Amir Vadai) [1164539]
Rebuild_FUZZ: 97.48%
commit-author Ariel Nahum <arieln@mellanox.com>
commit aea8f4df6da46add468c44875348e1045bffeeb7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/aea8f4df.failed

In case iscsid was violently killed (SIGKILL) during its error
recovery stage, we may never get a connection teardown sequence for
some of the old connections.  No harm done, but when we try to unload
the module we will need to cleanup all these connections.  So we
actually may end-up here - so it's not a BUG_ON(), just give a relaxed
warning that this happened and continue with normal unload.  BUG_ON()
will cause segfault on module_exit and we don't want that.

	Signed-off-by: Ariel Nahum <arieln@mellanox.com>
	Signed-off-by: Roi Dayan <roid@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Roland Dreier <roland@purestorage.com>
(cherry picked from commit aea8f4df6da46add468c44875348e1045bffeeb7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/iser/iser_verbs.c
diff --cc drivers/infiniband/ulp/iser/iser_verbs.c
index fbf2a1e0f2e2,57b20c691367..000000000000
--- a/drivers/infiniband/ulp/iser/iser_verbs.c
+++ b/drivers/infiniband/ulp/iser/iser_verbs.c
@@@ -616,26 -618,25 +616,39 @@@ void iser_release_work(struct work_stru
  /**
   * Frees all conn objects and deallocs conn descriptor
   */
 -void iser_conn_release(struct iser_conn *iser_conn)
 +void iser_conn_release(struct iser_conn *ib_conn)
  {
 -	struct ib_conn *ib_conn = &iser_conn->ib_conn;
 +	struct iser_device  *device = ib_conn->device;
  
  	mutex_lock(&ig.connlist_mutex);
 -	list_del(&iser_conn->conn_list);
 +	list_del(&ib_conn->conn_list);
  	mutex_unlock(&ig.connlist_mutex);
  
++<<<<<<< HEAD
 +	mutex_lock(&ib_conn->state_mutex);
 +	BUG_ON(ib_conn->state != ISER_CONN_DOWN);
++=======
+ 	mutex_lock(&iser_conn->state_mutex);
+ 	if (iser_conn->state != ISER_CONN_DOWN)
+ 		iser_warn("iser conn %p state %d, expected state down.\n",
+ 			  iser_conn, iser_conn->state);
+ 	/*
+ 	 * In case we never got to bind stage, we still need to
+ 	 * release IB resources (which is safe to call more than once).
+ 	 */
+ 	iser_free_ib_conn_res(iser_conn, true);
+ 	mutex_unlock(&iser_conn->state_mutex);
++>>>>>>> aea8f4df6da4 (IB/iser: Use iser_warn instead of BUG_ON in iser_conn_release)
 +
 +	iser_free_rx_descriptors(ib_conn);
 +	iser_free_ib_conn_res(ib_conn);
 +	ib_conn->device = NULL;
 +	/* on EVENT_ADDR_ERROR there's no device yet for this conn */
 +	if (device != NULL)
 +		iser_device_try_release(device);
 +	mutex_unlock(&ib_conn->state_mutex);
  
 +	/* if cma handler context, the caller actually destroy the id */
  	if (ib_conn->cma_id != NULL) {
  		rdma_destroy_id(ib_conn->cma_id);
  		ib_conn->cma_id = NULL;
* Unmerged path drivers/infiniband/ulp/iser/iser_verbs.c
