Revert "AHCI: Optimize single IRQ interrupt processing"

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Tejun Heo <tj@kernel.org>
commit 7865f83fd2f23cbf3cd8ad0ddc2cef796f005aaf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/7865f83f.failed

This reverts commit 18dcf433f3ded61eb140a55e7048ec2fef79e723.
IRQF_ONESHOT was missing from the conversion causing screaming
interrupts problems on some setups and LKP detected measureable drop
in IO performance.  It looks like we'll first need to drop the
threaded IRQ handling first before splitting locking.

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Cc: Alexander Gordeev <agordeev@redhat.com>
	Reported-by: kernel test robot <fengguang.wu@intel.com>
	Reported-by: Marc Zyngier <marc.zyngier@arm.com>
Link: http://lkml.kernel.org/g/20141027021651.GF27038@yliu-dev.sh.intel.com
Link: http://lkml.kernel.org/g/1414082970-20775-1-git-send-email-marc.zyngier@arm.com
(cherry picked from commit 7865f83fd2f23cbf3cd8ad0ddc2cef796f005aaf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/ata/libahci.c
diff --cc drivers/ata/libahci.c
index 198a9d07a8bc,97683e45ab04..000000000000
--- a/drivers/ata/libahci.c
+++ b/drivers/ata/libahci.c
@@@ -1771,6 -1779,6 +1771,7 @@@ static void ahci_handle_port_interrupt(
  }
  
  static void ahci_port_intr(struct ata_port *ap)
++<<<<<<< HEAD
  {
  	void __iomem *port_mmio = ahci_port_base(ap);
  	u32 status;
@@@ -1781,89 -1789,37 +1782,126 @@@
  	ahci_handle_port_interrupt(ap, port_mmio, status);
  }
  
 -static irqreturn_t ahci_port_thread_fn(int irq, void *dev_instance)
 +irqreturn_t ahci_thread_fn(int irq, void *dev_instance)
  {
 +	struct ata_port *ap = dev_instance;
 +	struct ahci_port_priv *pp = ap->private_data;
 +	void __iomem *port_mmio = ahci_port_base(ap);
 +	unsigned long flags;
 +	u32 status;
 +
 +	spin_lock_irqsave(&ap->host->lock, flags);
 +	status = pp->intr_status;
 +	if (status)
 +		pp->intr_status = 0;
 +	spin_unlock_irqrestore(&ap->host->lock, flags);
 +
 +	spin_lock_bh(ap->lock);
 +	ahci_handle_port_interrupt(ap, port_mmio, status);
 +	spin_unlock_bh(ap->lock);
 +
 +	return IRQ_HANDLED;
 +}
 +EXPORT_SYMBOL_GPL(ahci_thread_fn);
 +
 +static void ahci_hw_port_interrupt(struct ata_port *ap)
++=======
++>>>>>>> 7865f83fd2f2 (Revert "AHCI: Optimize single IRQ interrupt processing")
 +{
 +	void __iomem *port_mmio = ahci_port_base(ap);
- 	struct ahci_port_priv *pp = ap->private_data;
 +	u32 status;
 +
 +	status = readl(port_mmio + PORT_IRQ_STAT);
 +	writel(status, port_mmio + PORT_IRQ_STAT);
 +
++<<<<<<< HEAD
 +	pp->intr_status |= status;
++=======
++	ahci_handle_port_interrupt(ap, port_mmio, status);
++>>>>>>> 7865f83fd2f2 (Revert "AHCI: Optimize single IRQ interrupt processing")
 +}
 +
 +irqreturn_t ahci_hw_interrupt(int irq, void *dev_instance)
 +{
++<<<<<<< HEAD
 +	struct ata_port *ap_this = dev_instance;
 +	struct ahci_port_priv *pp = ap_this->private_data;
 +	struct ata_host *host = ap_this->host;
 +	struct ahci_host_priv *hpriv = host->private_data;
 +	void __iomem *mmio = hpriv->mmio;
 +	unsigned int i;
 +	u32 irq_stat, irq_masked;
 +
 +	VPRINTK("ENTER\n");
 +
 +	spin_lock(&host->lock);
 +
 +	irq_stat = readl(mmio + HOST_IRQ_STAT);
 +
 +	if (!irq_stat) {
 +		u32 status = pp->intr_status;
 +
 +		spin_unlock(&host->lock);
 +
 +		VPRINTK("EXIT\n");
 +
 +		return status ? IRQ_WAKE_THREAD : IRQ_NONE;
 +	}
 +
 +	irq_masked = irq_stat & hpriv->port_map;
 +
 +	for (i = 0; i < host->n_ports; i++) {
 +		struct ata_port *ap;
 +
 +		if (!(irq_masked & (1 << i)))
 +			continue;
 +
 +		ap = host->ports[i];
 +		if (ap) {
 +			ahci_hw_port_interrupt(ap);
 +			VPRINTK("port %u\n", i);
 +		} else {
 +			VPRINTK("port %u (no irq)\n", i);
 +			if (ata_ratelimit())
 +				dev_warn(host->dev,
 +					 "interrupt on disabled port %u\n", i);
 +		}
 +	}
 +
 +	writel(irq_stat, mmio + HOST_IRQ_STAT);
 +
 +	spin_unlock(&host->lock);
++=======
+ 	struct ata_port *ap = dev_instance;
+ 	struct ahci_port_priv *pp = ap->private_data;
+ 	void __iomem *port_mmio = ahci_port_base(ap);
+ 	u32 status;
+ 
+ 	status = atomic_xchg(&pp->intr_status, 0);
+ 	if (!status)
+ 		return IRQ_NONE;
+ 
+ 	spin_lock_bh(ap->lock);
+ 	ahci_handle_port_interrupt(ap, port_mmio, status);
+ 	spin_unlock_bh(ap->lock);
+ 
+ 	return IRQ_HANDLED;
+ }
+ 
+ static irqreturn_t ahci_multi_irqs_intr(int irq, void *dev_instance)
+ {
+ 	struct ata_port *ap = dev_instance;
+ 	void __iomem *port_mmio = ahci_port_base(ap);
+ 	struct ahci_port_priv *pp = ap->private_data;
+ 	u32 status;
+ 
+ 	VPRINTK("ENTER\n");
+ 
+ 	status = readl(port_mmio + PORT_IRQ_STAT);
+ 	writel(status, port_mmio + PORT_IRQ_STAT);
+ 
+ 	atomic_or(status, &pp->intr_status);
++>>>>>>> 7865f83fd2f2 (Revert "AHCI: Optimize single IRQ interrupt processing")
  
  	VPRINTK("EXIT\n");
  
@@@ -2458,6 -2418,81 +2496,84 @@@ void ahci_set_em_messages(struct ahci_h
  }
  EXPORT_SYMBOL_GPL(ahci_set_em_messages);
  
++<<<<<<< HEAD
++=======
+ static int ahci_host_activate_multi_irqs(struct ata_host *host, int irq,
+ 					 struct scsi_host_template *sht)
+ {
+ 	int i, rc;
+ 
+ 	rc = ata_host_start(host);
+ 	if (rc)
+ 		return rc;
+ 
+ 	for (i = 0; i < host->n_ports; i++) {
+ 		struct ahci_port_priv *pp = host->ports[i]->private_data;
+ 
+ 		/* Do not receive interrupts sent by dummy ports */
+ 		if (!pp) {
+ 			disable_irq(irq + i);
+ 			continue;
+ 		}
+ 
+ 		rc = devm_request_threaded_irq(host->dev, irq + i,
+ 					       ahci_multi_irqs_intr,
+ 					       ahci_port_thread_fn, IRQF_SHARED,
+ 					       pp->irq_desc, host->ports[i]);
+ 		if (rc)
+ 			goto out_free_irqs;
+ 	}
+ 
+ 	for (i = 0; i < host->n_ports; i++)
+ 		ata_port_desc(host->ports[i], "irq %d", irq + i);
+ 
+ 	rc = ata_host_register(host, sht);
+ 	if (rc)
+ 		goto out_free_all_irqs;
+ 
+ 	return 0;
+ 
+ out_free_all_irqs:
+ 	i = host->n_ports;
+ out_free_irqs:
+ 	for (i--; i >= 0; i--)
+ 		devm_free_irq(host->dev, irq + i, host->ports[i]);
+ 
+ 	return rc;
+ }
+ 
+ /**
+  *	ahci_host_activate - start AHCI host, request IRQs and register it
+  *	@host: target ATA host
+  *	@irq: base IRQ number to request
+  *	@sht: scsi_host_template to use when registering the host
+  *
+  *	Similar to ata_host_activate, but requests IRQs according to AHCI-1.1
+  *	when multiple MSIs were allocated. That is one MSI per port, starting
+  *	from @irq.
+  *
+  *	LOCKING:
+  *	Inherited from calling layer (may sleep).
+  *
+  *	RETURNS:
+  *	0 on success, -errno otherwise.
+  */
+ int ahci_host_activate(struct ata_host *host, int irq,
+ 		       struct scsi_host_template *sht)
+ {
+ 	struct ahci_host_priv *hpriv = host->private_data;
+ 	int rc;
+ 
+ 	if (hpriv->flags & AHCI_HFLAG_MULTI_MSI)
+ 		rc = ahci_host_activate_multi_irqs(host, irq, sht);
+ 	else
+ 		rc = ata_host_activate(host, irq, ahci_single_irq_intr,
+ 				       IRQF_SHARED, sht);
+ 	return rc;
+ }
+ EXPORT_SYMBOL_GPL(ahci_host_activate);
+ 
++>>>>>>> 7865f83fd2f2 (Revert "AHCI: Optimize single IRQ interrupt processing")
  MODULE_AUTHOR("Jeff Garzik");
  MODULE_DESCRIPTION("Common AHCI SATA low-level routines");
  MODULE_LICENSE("GPL");
* Unmerged path drivers/ata/libahci.c
