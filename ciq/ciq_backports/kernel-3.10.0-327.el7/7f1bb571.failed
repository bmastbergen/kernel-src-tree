bonding: remove bond read lock for bond_loadbalance_arp_mon()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author dingtianhong <dingtianhong@huawei.com>
commit 7f1bb571b753ac75b6548f0b7c932dfc0bb1f970
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/7f1bb571.failed

The bond slave list may change when the monitor is running, the slave list is no longer
protected by bond->lock, only protected by rtnl lock(), so we have 3 ways to modify it:
1.add bond_master_upper_dev_link() and bond_upper_dev_unlink() in bond->lock, but it is unsafe
to call call_netdevice_notifiers() in write lock.
2.remove unused bond->lock for monitor function, only use the existing rtnl lock().
3.use rcu_read_lock() to protect it, of course, it will transform bond_for_each_slave to
bond_for_each_slave_rcu() and performance is better, but in slow path, it is ignored.
so I remove the bond->lock and add the rtnl lock to protect the whole monitor function.

	Signed-off-by: Ding Tianhong <dingtianhong@huawei.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7f1bb571b753ac75b6548f0b7c932dfc0bb1f970)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
diff --cc drivers/net/bonding/bond_main.c
index f2744db511b6,a620dfae1c82..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -2669,18 -2393,17 +2669,27 @@@ void bond_loadbalance_arp_mon(struct wo
  	struct bonding *bond = container_of(work, struct bonding,
  					    arp_work.work);
  	struct slave *slave, *oldcurrent;
 -	struct list_head *iter;
  	int do_failover = 0;
 +	int delta_in_ticks, extra_ticks;
 +	int i;
 +
++<<<<<<< HEAD
 +	read_lock(&bond->lock);
 +
 +	delta_in_ticks = msecs_to_jiffies(bond->params.arp_interval);
 +	extra_ticks = delta_in_ticks / 2;
  
 +	if (bond->slave_cnt == 0)
++=======
+ 	if (!rtnl_trylock())
++>>>>>>> 7f1bb571b753 (bonding: remove bond read lock for bond_loadbalance_arp_mon())
  		goto re_arm;
  
+ 	if (!bond_has_slaves(bond)) {
+ 		rtnl_unlock();
+ 		goto re_arm;
+ 	}
+ 
  	oldcurrent = bond->curr_active_slave;
  	/* see if any of the previous devices are up now (i.e. they have
  	 * xmt and rcv traffic). the curr_active_slave does not come into
@@@ -2772,9 -2488,8 +2782,14 @@@
  
  re_arm:
  	if (bond->params.arp_interval)
++<<<<<<< HEAD
 +		queue_delayed_work(bond->wq, &bond->arp_work, delta_in_ticks);
 +
 +	read_unlock(&bond->lock);
++=======
+ 		queue_delayed_work(bond->wq, &bond->arp_work,
+ 				   msecs_to_jiffies(bond->params.arp_interval));
++>>>>>>> 7f1bb571b753 (bonding: remove bond read lock for bond_loadbalance_arp_mon())
  }
  
  /*
* Unmerged path drivers/net/bonding/bond_main.c
