xfrm: Generate queueing routes only from route lookup functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Steffen Klassert <steffen.klassert@secunet.com>
commit b8c203b2d2fc961bafd53b41d5396bbcdec55998
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/b8c203b2.failed

Currently we genarate a queueing route if we have matching policies
but can not resolve the states and the sysctl xfrm_larval_drop is
disabled. Here we assume that dst_output() is called to kill the
queued packets. Unfortunately this assumption is not true in all
cases, so it is possible that these packets leave the system unwanted.

We fix this by generating queueing routes only from the
route lookup functions, here we can guarantee a call to
dst_output() afterwards.

Fixes: a0073fe18e71 ("xfrm: Add a state resolution packet queue")
	Reported-by: Konstantinos Kolelis <k.kolelis@sirrix.com>
	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit b8c203b2d2fc961bafd53b41d5396bbcdec55998)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/xfrm/xfrm_policy.c
diff --cc net/xfrm/xfrm_policy.c
index 8da957011964,fdde51f4271a..000000000000
--- a/net/xfrm/xfrm_policy.c
+++ b/net/xfrm/xfrm_policy.c
@@@ -39,12 -39,10 +39,19 @@@
  #define XFRM_QUEUE_TMO_MAX ((unsigned)(60*HZ))
  #define XFRM_MAX_QUEUE_LEN	100
  
++<<<<<<< HEAD
 +DEFINE_MUTEX(xfrm_cfg_mutex);
 +EXPORT_SYMBOL(xfrm_cfg_mutex);
 +
 +static DEFINE_SPINLOCK(xfrm_policy_sk_bundle_lock);
 +static struct dst_entry *xfrm_policy_sk_bundles;
 +static DEFINE_RWLOCK(xfrm_policy_lock);
++=======
+ struct xfrm_flo {
+ 	struct dst_entry *dst_orig;
+ 	u8 flags;
+ };
++>>>>>>> b8c203b2d2fc (xfrm: Generate queueing routes only from route lookup functions)
  
  static DEFINE_SPINLOCK(xfrm_policy_afinfo_lock);
  static struct xfrm_policy_afinfo __rcu *xfrm_policy_afinfo[NPROTO]
@@@ -1889,10 -1897,12 +1897,17 @@@ static struct xfrm_dst *xfrm_create_dum
  	if (IS_ERR(xdst))
  		return xdst;
  
++<<<<<<< HEAD
 +	if (net->xfrm.sysctl_larval_drop || num_xfrms <= 0 ||
 +	    (fl->flowi_flags & FLOWI_FLAG_CAN_SLEEP))
++=======
+ 	if (!(xflo->flags & XFRM_LOOKUP_QUEUE) ||
+ 	    net->xfrm.sysctl_larval_drop ||
+ 	    num_xfrms <= 0)
++>>>>>>> b8c203b2d2fc (xfrm: Generate queueing routes only from route lookup functions)
  		return xdst;
  
+ 	dst = xflo->dst_orig;
  	dst1 = &xdst->u.dst;
  	dst_hold(dst);
  	xdst->route = dst;
diff --git a/include/net/dst.h b/include/net/dst.h
index 82d356bbf71e..26e834976450 100644
--- a/include/net/dst.h
+++ b/include/net/dst.h
@@ -488,6 +488,7 @@ extern void		dst_init(void);
 /* Flags for xfrm_lookup flags argument. */
 enum {
 	XFRM_LOOKUP_ICMP = 1 << 0,
+	XFRM_LOOKUP_QUEUE = 1 << 1,
 };
 
 struct flowi;
* Unmerged path net/xfrm/xfrm_policy.c
