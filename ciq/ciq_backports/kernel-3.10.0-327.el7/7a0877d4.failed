netns: rename peernet2id() to peernet2id_alloc()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Nicolas Dichtel <nicolas.dichtel@6wind.com>
commit 7a0877d4b438886b72be61632eaa774d13262f70
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/7a0877d4.failed

In a following commit, a new function will be introduced to only lookup for
a nsid (no allocation if the nsid doesn't exist). To avoid confusion, the
existing function is renamed.

	Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
	Acked-by: Thomas Graf <tgraf@suug.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7a0877d4b438886b72be61632eaa774d13262f70)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
#	include/net/net_namespace.h
#	net/core/net_namespace.c
#	net/core/rtnetlink.c
diff --cc drivers/net/vxlan.c
index 1f7710467383,48341ae49012..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -344,6 -334,11 +344,14 @@@ static int vxlan_fdb_info(struct sk_buf
  	ndm->ndm_flags = fdb->flags;
  	ndm->ndm_type = RTN_UNICAST;
  
++<<<<<<< HEAD
++=======
+ 	if (!net_eq(dev_net(vxlan->dev), vxlan->net) &&
+ 	    nla_put_s32(skb, NDA_LINK_NETNSID,
+ 			peernet2id_alloc(dev_net(vxlan->dev), vxlan->net)))
+ 		goto nla_put_failure;
+ 
++>>>>>>> 7a0877d4b438 (netns: rename peernet2id() to peernet2id_alloc())
  	if (send_eth && nla_put(skb, NDA_LLADDR, ETH_ALEN, &fdb->eth_addr))
  		goto nla_put_failure;
  
diff --cc include/net/net_namespace.h
index 385ac027c602,6d1e2eae32fb..000000000000
--- a/include/net/net_namespace.h
+++ b/include/net/net_namespace.h
@@@ -288,6 -271,9 +288,12 @@@ static inline struct net *read_pnet(str
  #define __net_initconst	__initconst
  #endif
  
++<<<<<<< HEAD
++=======
+ int peernet2id_alloc(struct net *net, struct net *peer);
+ struct net *get_net_ns_by_id(struct net *net, int id);
+ 
++>>>>>>> 7a0877d4b438 (netns: rename peernet2id() to peernet2id_alloc())
  struct pernet_operations {
  	struct list_head list;
  	int (*init)(struct net *net);
diff --cc net/core/net_namespace.c
index 4cf6699528f0,9c806ac569f9..000000000000
--- a/net/core/net_namespace.c
+++ b/net/core/net_namespace.c
@@@ -144,6 -147,85 +144,88 @@@ static void ops_free_list(const struct 
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void rtnl_net_notifyid(struct net *net, int cmd, int id);
+ static int alloc_netid(struct net *net, struct net *peer, int reqid)
+ {
+ 	int min = 0, max = 0, id;
+ 
+ 	ASSERT_RTNL();
+ 
+ 	if (reqid >= 0) {
+ 		min = reqid;
+ 		max = reqid + 1;
+ 	}
+ 
+ 	id = idr_alloc(&net->netns_ids, peer, min, max, GFP_KERNEL);
+ 	if (id >= 0)
+ 		rtnl_net_notifyid(net, RTM_NEWNSID, id);
+ 
+ 	return id;
+ }
+ 
+ /* This function is used by idr_for_each(). If net is equal to peer, the
+  * function returns the id so that idr_for_each() stops. Because we cannot
+  * returns the id 0 (idr_for_each() will not stop), we return the magic value
+  * NET_ID_ZERO (-1) for it.
+  */
+ #define NET_ID_ZERO -1
+ static int net_eq_idr(int id, void *net, void *peer)
+ {
+ 	if (net_eq(net, peer))
+ 		return id ? : NET_ID_ZERO;
+ 	return 0;
+ }
+ 
+ static int __peernet2id(struct net *net, struct net *peer, bool alloc)
+ {
+ 	int id = idr_for_each(&net->netns_ids, net_eq_idr, peer);
+ 
+ 	ASSERT_RTNL();
+ 
+ 	/* Magic value for id 0. */
+ 	if (id == NET_ID_ZERO)
+ 		return 0;
+ 	if (id > 0)
+ 		return id;
+ 
+ 	if (alloc) {
+ 		id = alloc_netid(net, peer, -1);
+ 		return id >= 0 ? id : NETNSA_NSID_NOT_ASSIGNED;
+ 	}
+ 
+ 	return NETNSA_NSID_NOT_ASSIGNED;
+ }
+ 
+ /* This function returns the id of a peer netns. If no id is assigned, one will
+  * be allocated and returned.
+  */
+ int peernet2id_alloc(struct net *net, struct net *peer)
+ {
+ 	bool alloc = atomic_read(&peer->count) == 0 ? false : true;
+ 
+ 	return __peernet2id(net, peer, alloc);
+ }
+ EXPORT_SYMBOL(peernet2id_alloc);
+ 
+ struct net *get_net_ns_by_id(struct net *net, int id)
+ {
+ 	struct net *peer;
+ 
+ 	if (id < 0)
+ 		return NULL;
+ 
+ 	rcu_read_lock();
+ 	peer = idr_find(&net->netns_ids, id);
+ 	if (peer)
+ 		get_net(peer);
+ 	rcu_read_unlock();
+ 
+ 	return peer;
+ }
+ 
++>>>>>>> 7a0877d4b438 (netns: rename peernet2id() to peernet2id_alloc())
  /*
   * setup_net runs the initializers for the network namespace object.
   */
diff --cc net/core/rtnetlink.c
index 164916e79775,83e08323fdcd..000000000000
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@@ -1065,6 -1199,18 +1065,21 @@@ static int rtnl_fill_ifinfo(struct sk_b
  			goto nla_put_failure;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (dev->rtnl_link_ops &&
+ 	    dev->rtnl_link_ops->get_link_net) {
+ 		struct net *link_net = dev->rtnl_link_ops->get_link_net(dev);
+ 
+ 		if (!net_eq(dev_net(dev), link_net)) {
+ 			int id = peernet2id_alloc(dev_net(dev), link_net);
+ 
+ 			if (nla_put_s32(skb, IFLA_LINK_NETNSID, id))
+ 				goto nla_put_failure;
+ 		}
+ 	}
+ 
++>>>>>>> 7a0877d4b438 (netns: rename peernet2id() to peernet2id_alloc())
  	if (!(af_spec = nla_nest_start(skb, IFLA_AF_SPEC)))
  		goto nla_put_failure;
  
* Unmerged path drivers/net/vxlan.c
* Unmerged path include/net/net_namespace.h
* Unmerged path net/core/net_namespace.c
* Unmerged path net/core/rtnetlink.c
