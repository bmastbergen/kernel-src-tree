net: Call skb_get_hash in get_xps_queue and __skb_tx_hash

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] flow_dissector: Call skb_get_hash in get_xps_queue and __skb_tx_hash (Ivan Vecera) [1215920]
Rebuild_FUZZ: 89.60%
commit-author Tom Herbert <therbert@google.com>
commit 0e001614e849b68cff94cda8db8b550569d3dba6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/0e001614.failed

Call standard function to get a packet hash instead of taking this from
skb->sk->sk_hash or only using skb->protocol.

	Signed-off-by: Tom Herbert <therbert@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0e001614e849b68cff94cda8db8b550569d3dba6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
#	net/core/flow_dissector.c
diff --cc include/linux/skbuff.h
index 7d61df58cfdc,b297af70ac30..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -3166,21 -3005,17 +3166,26 @@@ static inline bool skb_rx_queue_recorde
  	return skb->queue_mapping != 0;
  }
  
++<<<<<<< HEAD
 +extern u16 __skb_tx_hash(const struct net_device *dev,
 +			 const struct sk_buff *skb,
 +			 unsigned int num_tx_queues);
++=======
+ u16 __skb_tx_hash(const struct net_device *dev, struct sk_buff *skb,
+ 		  unsigned int num_tx_queues);
++>>>>>>> 0e001614e849 (net: Call skb_get_hash in get_xps_queue and __skb_tx_hash)
  
 +#ifdef CONFIG_XFRM
  static inline struct sec_path *skb_sec_path(struct sk_buff *skb)
  {
 -#ifdef CONFIG_XFRM
  	return skb->sp;
 +}
  #else
 +static inline struct sec_path *skb_sec_path(struct sk_buff *skb)
 +{
  	return NULL;
 -#endif
  }
 +#endif
  
  /* Keeps track of mac header offset relative to skb->head.
   * It is useful for TSO of Tunneling protocol. e.g. GRE.
diff --cc net/core/flow_dissector.c
index a82ac44a3fe2,62d1cb624f53..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -174,16 -196,37 +174,46 @@@ static __always_inline u32 __flow_hash_
  	return jhash_3words(a, b, c, hashrnd);
  }
  
++<<<<<<< HEAD
 +static __always_inline u32 __flow_hash_1word(u32 a)
 +{
 +	__flow_hash_secret_init();
 +	return jhash_1word(a, hashrnd);
 +}
 +
++=======
+ static inline u32 __flow_hash_from_keys(struct flow_keys *keys)
+ {
+ 	u32 hash;
+ 
+ 	/* get a consistent hash (same value on both flow directions) */
+ 	if (((__force u32)keys->dst < (__force u32)keys->src) ||
+ 	    (((__force u32)keys->dst == (__force u32)keys->src) &&
+ 	     ((__force u16)keys->port16[1] < (__force u16)keys->port16[0]))) {
+ 		swap(keys->dst, keys->src);
+ 		swap(keys->port16[0], keys->port16[1]);
+ 	}
+ 
+ 	hash = __flow_hash_3words((__force u32)keys->dst,
+ 				  (__force u32)keys->src,
+ 				  (__force u32)keys->ports);
+ 	if (!hash)
+ 		hash = 1;
+ 
+ 	return hash;
+ }
+ 
+ u32 flow_hash_from_keys(struct flow_keys *keys)
+ {
+ 	return __flow_hash_from_keys(keys);
+ }
+ EXPORT_SYMBOL(flow_hash_from_keys);
+ 
++>>>>>>> 0e001614e849 (net: Call skb_get_hash in get_xps_queue and __skb_tx_hash)
  /*
   * __skb_get_hash: calculate a flow hash based on src/dst addresses
 - * and src/dst port numbers.  Sets hash in skb to non-zero hash value
 - * on success, zero indicates no valid hash.  Also, sets l4_hash in skb
 + * and src/dst port numbers.  Sets rxhash in skb to non-zero hash value
 + * on success, zero indicates no valid hash.  Also, sets l4_rxhash in skb
   * if hash is a canonical 4-tuple hash over transport ports.
   */
  void __skb_get_hash(struct sk_buff *skb)
@@@ -328,17 -339,10 +352,21 @@@ static inline int get_xps_queue(struct 
  		if (map) {
  			if (map->len == 1)
  				queue_index = map->queues[0];
++<<<<<<< HEAD
 +			else {
 +				u32 hash;
 +				if (skb->sk && skb->sk->sk_hash)
 +					hash = skb->sk->sk_hash;
 +				else
 +					hash = (__force u16) skb->protocol ^
 +					    skb->rxhash;
 +				hash = __flow_hash_1word(hash);
++=======
+ 			else
++>>>>>>> 0e001614e849 (net: Call skb_get_hash in get_xps_queue and __skb_tx_hash)
  				queue_index = map->queues[
- 				    ((u64)hash * map->len) >> 32];
- 			}
+ 				    ((u64)skb_get_hash(skb) * map->len) >> 32];
+ 
  			if (unlikely(queue_index >= dev->real_num_tx_queues))
  				queue_index = -1;
  		}
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index d77c2cff9dff..61e578f84e12 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -2400,7 +2400,7 @@ static inline int netif_set_xps_queue(struct net_device *dev,
  * as a distribution range limit for the returned value.
  */
 static inline u16 skb_tx_hash(const struct net_device *dev,
-			      const struct sk_buff *skb)
+			      struct sk_buff *skb)
 {
 	return __skb_tx_hash(dev, skb, dev->real_num_tx_queues);
 }
* Unmerged path include/linux/skbuff.h
* Unmerged path net/core/flow_dissector.c
