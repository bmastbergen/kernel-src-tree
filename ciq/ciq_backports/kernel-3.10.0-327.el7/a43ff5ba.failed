ALSA: hda - Pass bus io_ops directly from the top-level driver

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [alsa] hda - Pass bus io_ops directly from the top-level driver (Jaroslav Kysela) [1197064]
Rebuild_FUZZ: 94.92%
commit-author Takashi Iwai <tiwai@suse.de>
commit a43ff5baa55ff87268a67b45c6f6cb261c023db1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/a43ff5ba.failed

One less redirection again.  This also requires the change of the call
order in the toplevel divers.  Namely, the bus has to be created at
first before other initializations since the memory allocation ops are
called through bus object now.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit a43ff5baa55ff87268a67b45c6f6cb261c023db1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/hda_codec.c
#	sound/pci/hda/hda_codec.h
#	sound/pci/hda/hda_controller.c
#	sound/pci/hda/hda_controller.h
#	sound/pci/hda/hda_intel.c
#	sound/pci/hda/hda_tegra.c
diff --cc sound/pci/hda/hda_codec.c
index d744f45d5fe3,ddebe7541390..000000000000
--- a/sound/pci/hda/hda_codec.c
+++ b/sound/pci/hda/hda_codec.c
@@@ -773,6 -515,8 +773,11 @@@ static int snd_hda_bus_dev_disconnect(s
   * Returns 0 if successful, or a negative error code.
   */
  int snd_hda_bus_new(struct snd_card *card,
++<<<<<<< HEAD
++=======
+ 		    const struct hdac_bus_ops *ops,
+ 		    const struct hdac_io_ops *io_ops,
++>>>>>>> a43ff5baa55f (ALSA: hda - Pass bus io_ops directly from the top-level driver)
  		    struct hda_bus **busp)
  {
  	struct hda_bus *bus;
@@@ -789,11 -533,14 +794,20 @@@
  	if (!bus)
  		return -ENOMEM;
  
++<<<<<<< HEAD
++=======
+ 	err = snd_hdac_bus_init(&bus->core, card->dev, ops, io_ops);
+ 	if (err < 0) {
+ 		kfree(bus);
+ 		return err;
+ 	}
+ 
++>>>>>>> a43ff5baa55f (ALSA: hda - Pass bus io_ops directly from the top-level driver)
  	bus->card = card;
 +	mutex_init(&bus->cmd_mutex);
  	mutex_init(&bus->prepare_mutex);
 +	INIT_LIST_HEAD(&bus->codec_list);
 +	INIT_WORK(&bus->unsol.work, process_unsol_events);
  
  	err = snd_device_new(card, SNDRV_DEV_BUS, bus, &dev_ops);
  	if (err < 0) {
diff --cc sound/pci/hda/hda_codec.h
index 00c6f394c5ce,c8031360de90..000000000000
--- a/sound/pci/hda/hda_codec.h
+++ b/sound/pci/hda/hda_codec.h
@@@ -428,7 -326,10 +428,14 @@@ enum 
  /*
   * constructors
   */
++<<<<<<< HEAD
 +int snd_hda_bus_new(struct snd_card *card, struct hda_bus **busp);
++=======
+ int snd_hda_bus_new(struct snd_card *card,
+ 		    const struct hdac_bus_ops *ops,
+ 		    const struct hdac_io_ops *io_ops,
+ 		    struct hda_bus **busp);
++>>>>>>> a43ff5baa55f (ALSA: hda - Pass bus io_ops directly from the top-level driver)
  int snd_hda_codec_new(struct hda_bus *bus, struct snd_card *card,
  		      unsigned int codec_addr, struct hda_codec **codecp);
  int snd_hda_codec_configure(struct hda_codec *codec);
diff --cc sound/pci/hda/hda_controller.c
index 0d7233e1e418,aadce642aabc..000000000000
--- a/sound/pci/hda/hda_controller.c
+++ b/sound/pci/hda/hda_controller.c
@@@ -1842,7 -1834,7 +1842,11 @@@ int azx_bus_create(struct azx *chip, co
  	struct hda_bus *bus;
  	int err;
  
++<<<<<<< HEAD
 +	err = snd_hda_bus_new(chip->card, &bus);
++=======
+ 	err = snd_hda_bus_new(chip->card, &bus_core_ops, chip->io_ops, &bus);
++>>>>>>> a43ff5baa55f (ALSA: hda - Pass bus io_ops directly from the top-level driver)
  	if (err < 0)
  		return err;
  
diff --cc sound/pci/hda/hda_controller.h
index 2993061145a5,d6b090daa7dc..000000000000
--- a/sound/pci/hda/hda_controller.h
+++ b/sound/pci/hda/hda_controller.h
@@@ -15,10 -15,258 +15,259 @@@
  #ifndef __SOUND_HDA_CONTROLLER_H
  #define __SOUND_HDA_CONTROLLER_H
  
 -#include <linux/timecounter.h>
 -#include <linux/interrupt.h>
  #include <sound/core.h>
 -#include <sound/pcm.h>
  #include <sound/initval.h>
  #include "hda_codec.h"
++<<<<<<< HEAD
 +#include "hda_priv.h"
++=======
+ #include <sound/hda_register.h>
+ 
+ #define AZX_MAX_CODECS		HDA_MAX_CODECS
+ #define AZX_DEFAULT_CODECS	4
+ 
+ /* driver quirks (capabilities) */
+ /* bits 0-7 are used for indicating driver type */
+ #define AZX_DCAPS_NO_TCSEL	(1 << 8)	/* No Intel TCSEL bit */
+ #define AZX_DCAPS_NO_MSI	(1 << 9)	/* No MSI support */
+ #define AZX_DCAPS_SNOOP_MASK	(3 << 10)	/* snoop type mask */
+ #define AZX_DCAPS_SNOOP_OFF	(1 << 12)	/* snoop default off */
+ #define AZX_DCAPS_RIRB_DELAY	(1 << 13)	/* Long delay in read loop */
+ #define AZX_DCAPS_RIRB_PRE_DELAY (1 << 14)	/* Put a delay before read */
+ #define AZX_DCAPS_CTX_WORKAROUND (1 << 15)	/* X-Fi workaround */
+ #define AZX_DCAPS_POSFIX_LPIB	(1 << 16)	/* Use LPIB as default */
+ #define AZX_DCAPS_POSFIX_VIA	(1 << 17)	/* Use VIACOMBO as default */
+ #define AZX_DCAPS_NO_64BIT	(1 << 18)	/* No 64bit address */
+ #define AZX_DCAPS_SYNC_WRITE	(1 << 19)	/* sync each cmd write */
+ #define AZX_DCAPS_OLD_SSYNC	(1 << 20)	/* Old SSYNC reg for ICH */
+ #define AZX_DCAPS_NO_ALIGN_BUFSIZE (1 << 21)	/* no buffer size alignment */
+ /* 22 unused */
+ #define AZX_DCAPS_4K_BDLE_BOUNDARY (1 << 23)	/* BDLE in 4k boundary */
+ #define AZX_DCAPS_REVERSE_ASSIGN (1 << 24)	/* Assign devices in reverse order */
+ #define AZX_DCAPS_COUNT_LPIB_DELAY  (1 << 25)	/* Take LPIB as delay */
+ #define AZX_DCAPS_PM_RUNTIME	(1 << 26)	/* runtime PM support */
+ #define AZX_DCAPS_I915_POWERWELL (1 << 27)	/* HSW i915 powerwell support */
+ #define AZX_DCAPS_CORBRP_SELF_CLEAR (1 << 28)	/* CORBRP clears itself after reset */
+ #define AZX_DCAPS_NO_MSI64      (1 << 29)	/* Stick to 32-bit MSIs */
+ #define AZX_DCAPS_SEPARATE_STREAM_TAG	(1 << 30) /* capture and playback use separate stream tag */
+ 
+ enum {
+ 	AZX_SNOOP_TYPE_NONE,
+ 	AZX_SNOOP_TYPE_SCH,
+ 	AZX_SNOOP_TYPE_ATI,
+ 	AZX_SNOOP_TYPE_NVIDIA,
+ };
+ 
+ struct azx_dev {
+ 	struct snd_dma_buffer bdl; /* BDL buffer */
+ 	u32 *posbuf;		/* position buffer pointer */
+ 
+ 	unsigned int bufsize;	/* size of the play buffer in bytes */
+ 	unsigned int period_bytes; /* size of the period in bytes */
+ 	unsigned int frags;	/* number for period in the play buffer */
+ 	unsigned int fifo_size;	/* FIFO size */
+ 	unsigned long start_wallclk;	/* start + minimum wallclk */
+ 	unsigned long period_wallclk;	/* wallclk for period */
+ 
+ 	void __iomem *sd_addr;	/* stream descriptor pointer */
+ 
+ 	u32 sd_int_sta_mask;	/* stream int status mask */
+ 
+ 	/* pcm support */
+ 	struct snd_pcm_substream *substream;	/* assigned substream,
+ 						 * set in PCM open
+ 						 */
+ 	unsigned int format_val;	/* format value to be set in the
+ 					 * controller and the codec
+ 					 */
+ 	unsigned char stream_tag;	/* assigned stream */
+ 	unsigned char index;		/* stream index */
+ 	int assigned_key;		/* last device# key assigned to */
+ 
+ 	unsigned int opened:1;
+ 	unsigned int running:1;
+ 	unsigned int irq_pending:1;
+ 	unsigned int prepared:1;
+ 	unsigned int locked:1;
+ 	/*
+ 	 * For VIA:
+ 	 *  A flag to ensure DMA position is 0
+ 	 *  when link position is not greater than FIFO size
+ 	 */
+ 	unsigned int insufficient:1;
+ 	unsigned int wc_marked:1;
+ 	unsigned int no_period_wakeup:1;
+ 
+ 	struct timecounter  azx_tc;
+ 	struct cyclecounter azx_cc;
+ 
+ 	int delay_negative_threshold;
+ 
+ #ifdef CONFIG_SND_HDA_DSP_LOADER
+ 	/* Allows dsp load to have sole access to the playback stream. */
+ 	struct mutex dsp_mutex;
+ #endif
+ };
+ 
+ /* CORB/RIRB */
+ struct azx_rb {
+ 	u32 *buf;		/* CORB/RIRB buffer
+ 				 * Each CORB entry is 4byte, RIRB is 8byte
+ 				 */
+ 	dma_addr_t addr;	/* physical address of CORB/RIRB buffer */
+ 	/* for RIRB */
+ 	unsigned short rp, wp;	/* read/write pointers */
+ 	int cmds[AZX_MAX_CODECS];	/* number of pending requests */
+ 	u32 res[AZX_MAX_CODECS];	/* last read value */
+ };
+ 
+ struct azx;
+ 
+ /* Functions to read/write to hda registers. */
+ struct hda_controller_ops {
+ 	/* Disable msi if supported, PCI only */
+ 	int (*disable_msi_reset_irq)(struct azx *);
+ 	int (*substream_alloc_pages)(struct azx *chip,
+ 				     struct snd_pcm_substream *substream,
+ 				     size_t size);
+ 	int (*substream_free_pages)(struct azx *chip,
+ 				    struct snd_pcm_substream *substream);
+ 	void (*pcm_mmap_prepare)(struct snd_pcm_substream *substream,
+ 				 struct vm_area_struct *area);
+ 	/* Check if current position is acceptable */
+ 	int (*position_check)(struct azx *chip, struct azx_dev *azx_dev);
+ };
+ 
+ struct azx_pcm {
+ 	struct azx *chip;
+ 	struct snd_pcm *pcm;
+ 	struct hda_codec *codec;
+ 	struct hda_pcm *info;
+ 	struct list_head list;
+ };
+ 
+ typedef unsigned int (*azx_get_pos_callback_t)(struct azx *, struct azx_dev *);
+ typedef int (*azx_get_delay_callback_t)(struct azx *, struct azx_dev *, unsigned int pos);
+ 
+ struct azx {
+ 	struct snd_card *card;
+ 	struct pci_dev *pci;
+ 	int dev_index;
+ 
+ 	/* chip type specific */
+ 	int driver_type;
+ 	unsigned int driver_caps;
+ 	int playback_streams;
+ 	int playback_index_offset;
+ 	int capture_streams;
+ 	int capture_index_offset;
+ 	int num_streams;
+ 	const int *jackpoll_ms; /* per-card jack poll interval */
+ 
+ 	/* Register interaction. */
+ 	const struct hda_controller_ops *ops;
+ 	const struct hdac_io_ops *io_ops;
+ 
+ 	/* position adjustment callbacks */
+ 	azx_get_pos_callback_t get_position[2];
+ 	azx_get_delay_callback_t get_delay[2];
+ 
+ 	/* pci resources */
+ 	unsigned long addr;
+ 	void __iomem *remap_addr;
+ 	int irq;
+ 
+ 	/* locks */
+ 	spinlock_t reg_lock;
+ 	struct mutex open_mutex; /* Prevents concurrent open/close operations */
+ 
+ 	/* streams (x num_streams) */
+ 	struct azx_dev *azx_dev;
+ 
+ 	/* PCM */
+ 	struct list_head pcm_list; /* azx_pcm list */
+ 
+ 	/* HD codec */
+ 	unsigned short codec_mask;
+ 	int  codec_probe_mask; /* copied from probe_mask option */
+ 	struct hda_bus *bus;
+ 	unsigned int beep_mode;
+ 
+ 	/* CORB/RIRB */
+ 	struct azx_rb corb;
+ 	struct azx_rb rirb;
+ 
+ 	/* CORB/RIRB and position buffers */
+ 	struct snd_dma_buffer rb;
+ 	struct snd_dma_buffer posbuf;
+ 
+ #ifdef CONFIG_SND_HDA_PATCH_LOADER
+ 	const struct firmware *fw;
+ #endif
+ 
+ 	/* flags */
+ 	const int *bdl_pos_adj;
+ 	int poll_count;
+ 	unsigned int running:1;
+ 	unsigned int initialized:1;
+ 	unsigned int single_cmd:1;
+ 	unsigned int polling_mode:1;
+ 	unsigned int msi:1;
+ 	unsigned int probing:1; /* codec probing phase */
+ 	unsigned int snoop:1;
+ 	unsigned int align_buffer_size:1;
+ 	unsigned int region_requested:1;
+ 	unsigned int disabled:1; /* disabled by VGA-switcher */
+ 
+ 	/* for debugging */
+ 	unsigned int last_cmd[AZX_MAX_CODECS];
+ 
+ #ifdef CONFIG_SND_HDA_DSP_LOADER
+ 	struct azx_dev saved_azx_dev;
+ #endif
+ };
+ 
+ #define azx_bus(chip)	(&(chip)->bus->core)
+ 
+ #ifdef CONFIG_X86
+ #define azx_snoop(chip)		((chip)->snoop)
+ #else
+ #define azx_snoop(chip)		true
+ #endif
+ 
+ /*
+  * macros for easy use
+  */
+ 
+ #define azx_writel(chip, reg, value) \
+ 	((chip)->io_ops->reg_writel(value, (chip)->remap_addr + AZX_REG_##reg))
+ #define azx_readl(chip, reg) \
+ 	((chip)->io_ops->reg_readl((chip)->remap_addr + AZX_REG_##reg))
+ #define azx_writew(chip, reg, value) \
+ 	((chip)->io_ops->reg_writew(value, (chip)->remap_addr + AZX_REG_##reg))
+ #define azx_readw(chip, reg) \
+ 	((chip)->io_ops->reg_readw((chip)->remap_addr + AZX_REG_##reg))
+ #define azx_writeb(chip, reg, value) \
+ 	((chip)->io_ops->reg_writeb(value, (chip)->remap_addr + AZX_REG_##reg))
+ #define azx_readb(chip, reg) \
+ 	((chip)->io_ops->reg_readb((chip)->remap_addr + AZX_REG_##reg))
+ 
+ #define azx_sd_writel(chip, dev, reg, value) \
+ 	((chip)->io_ops->reg_writel(value, (dev)->sd_addr + AZX_REG_##reg))
+ #define azx_sd_readl(chip, dev, reg) \
+ 	((chip)->io_ops->reg_readl((dev)->sd_addr + AZX_REG_##reg))
+ #define azx_sd_writew(chip, dev, reg, value) \
+ 	((chip)->io_ops->reg_writew(value, (dev)->sd_addr + AZX_REG_##reg))
+ #define azx_sd_readw(chip, dev, reg) \
+ 	((chip)->io_ops->reg_readw((dev)->sd_addr + AZX_REG_##reg))
+ #define azx_sd_writeb(chip, dev, reg, value) \
+ 	((chip)->io_ops->reg_writeb(value, (dev)->sd_addr + AZX_REG_##reg))
+ #define azx_sd_readb(chip, dev, reg) \
+ 	((chip)->io_ops->reg_readb((dev)->sd_addr + AZX_REG_##reg))
+ 
+ #define azx_has_pm_runtime(chip) \
+ 	(!AZX_DCAPS_PM_RUNTIME || ((chip)->driver_caps & AZX_DCAPS_PM_RUNTIME))
++>>>>>>> a43ff5baa55f (ALSA: hda - Pass bus io_ops directly from the top-level driver)
  
  /* PCM setup */
  static inline struct azx_dev *get_azx_dev(struct snd_pcm_substream *substream)
diff --cc sound/pci/hda/hda_intel.c
index 8224bf75d072,7492d11fd8ff..000000000000
--- a/sound/pci/hda/hda_intel.c
+++ b/sound/pci/hda/hda_intel.c
@@@ -1807,9 -1789,7 +1816,13 @@@ static int azx_probe(struct pci_dev *pc
  		return err;
  	}
  
++<<<<<<< HEAD
 +	pci->dev.power.ignore_children = 1; /* FIXME */
 +	err = azx_create(card, pci, dev, pci_id->driver_data,
 +			 &pci_hda_ops, &chip);
++=======
+ 	err = azx_create(card, pci, dev, pci_id->driver_data, &chip);
++>>>>>>> a43ff5baa55f (ALSA: hda - Pass bus io_ops directly from the top-level driver)
  	if (err < 0)
  		goto out_free;
  	card->private_data = chip;
@@@ -1899,10 -1883,6 +1916,13 @@@ static int azx_probe_continue(struct az
  #endif
  
  	/* create codec instances */
++<<<<<<< HEAD
 +	err = azx_bus_create(chip, model[dev], power_save_addr);
 +	if (err < 0)
 +		goto out_free;
 +
++=======
++>>>>>>> a43ff5baa55f (ALSA: hda - Pass bus io_ops directly from the top-level driver)
  	err = azx_probe_codecs(chip, azx_max_codecs[chip->driver_type]);
  	if (err < 0)
  		goto out_free;
diff --cc sound/pci/hda/hda_tegra.c
index 6c19abff991c,b150cb50961c..000000000000
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@@ -497,10 -490,6 +504,13 @@@ static int hda_tegra_probe(struct platf
  		goto out_free;
  
  	/* create codec instances */
++<<<<<<< HEAD
 +	err = azx_bus_create(chip, NULL, &power_save);
 +	if (err < 0)
 +		goto out_free;
 +
++=======
++>>>>>>> a43ff5baa55f (ALSA: hda - Pass bus io_ops directly from the top-level driver)
  	err = azx_probe_codecs(chip, 0);
  	if (err < 0)
  		goto out_free;
* Unmerged path sound/pci/hda/hda_codec.c
* Unmerged path sound/pci/hda/hda_codec.h
* Unmerged path sound/pci/hda/hda_controller.c
* Unmerged path sound/pci/hda/hda_controller.h
* Unmerged path sound/pci/hda/hda_intel.c
* Unmerged path sound/pci/hda/hda_tegra.c
