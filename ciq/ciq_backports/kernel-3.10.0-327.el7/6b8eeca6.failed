drm/dp/mst: close deadlock in connector destruction.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [drm] dp/mst: close deadlock in connector destruction (Rob Clark) [1249805]
Rebuild_FUZZ: 94.95%
commit-author Dave Airlie <airlied@redhat.com>
commit 6b8eeca65b18ae77e175cc2b6571731f0ee413bf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/6b8eeca6.failed

I've only seen this once, and I failed to capture the
lockdep backtrace, but I did some investigations.

If we are calling into the MST layer from EDID probing,
we have the mode_config mutex held, if during that EDID
probing, the MST hub goes away, then we can get a deadlock
where the connector destruction function in the driver
tries to retake the mode config mutex.

This offloads connector destruction to a workqueue,
and avoid the subsequenct lock ordering issue.

	Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
	Cc: stable@vger.kernel.org
	Signed-off-by: Dave Airlie <airlied@redhat.com>
(cherry picked from commit 6b8eeca65b18ae77e175cc2b6571731f0ee413bf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/drm_dp_mst_topology.c
#	include/drm/drm_crtc.h
diff --cc drivers/gpu/drm/drm_dp_mst_topology.c
index acb90d5c6033,778bbb6425b8..000000000000
--- a/drivers/gpu/drm/drm_dp_mst_topology.c
+++ b/drivers/gpu/drm/drm_dp_mst_topology.c
@@@ -861,8 -865,18 +861,23 @@@ static void drm_dp_destroy_port(struct 
  	struct drm_dp_mst_topology_mgr *mgr = port->mgr;
  	if (!port->input) {
  		port->vcpi.num_slots = 0;
++<<<<<<< HEAD
 +		if (port->connector)
 +			(*port->mgr->cbs->destroy_connector)(mgr, port->connector);
++=======
+ 
+ 		kfree(port->cached_edid);
+ 
+ 		/* we can't destroy the connector here, as
+ 		   we might be holding the mode_config.mutex
+ 		   from an EDID retrieval */
+ 		if (port->connector) {
+ 			mutex_lock(&mgr->destroy_connector_lock);
+ 			list_add(&port->connector->destroy_list, &mgr->destroy_connector_list);
+ 			mutex_unlock(&mgr->destroy_connector_lock);
+ 			schedule_work(&mgr->destroy_connector_work);
+ 		}
++>>>>>>> 6b8eeca65b18 (drm/dp/mst: close deadlock in connector destruction.)
  		drm_dp_port_teardown_pdt(port, port->pdt);
  
  		if (!port->input && port->vcpi.vcpi > 0)
diff --cc include/drm/drm_crtc.h
index 474b37a199e4,57ca8cc383a6..000000000000
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@@ -547,6 -725,26 +547,29 @@@ struct drm_connector 
  	int audio_latency[2];
  	int null_edid_counter; /* needed to workaround some HW bugs where we get all 0s */
  	unsigned bad_edid_counter;
++<<<<<<< HEAD
++=======
+ 
+ 	/* Flag for raw EDID header corruption - used in Displayport
+ 	 * compliance testing - * Displayport Link CTS Core 1.2 rev1.1 4.2.2.6
+ 	 */
+ 	bool edid_corrupt;
+ 
+ 	struct dentry *debugfs_entry;
+ 
+ 	struct drm_connector_state *state;
+ 
+ 	/* DisplayID bits */
+ 	bool has_tile;
+ 	struct drm_tile_group *tile_group;
+ 	bool tile_is_single_monitor;
+ 
+ 	uint8_t num_h_tile, num_v_tile;
+ 	uint8_t tile_h_loc, tile_v_loc;
+ 	uint16_t tile_h_size, tile_v_size;
+ 
+ 	struct list_head destroy_list;
++>>>>>>> 6b8eeca65b18 (drm/dp/mst: close deadlock in connector destruction.)
  };
  
  /**
* Unmerged path drivers/gpu/drm/drm_dp_mst_topology.c
* Unmerged path include/drm/drm_crtc.h
diff --git a/include/drm/drm_dp_mst_helper.h b/include/drm/drm_dp_mst_helper.h
index 338fc1053835..a53591675f3d 100644
--- a/include/drm/drm_dp_mst_helper.h
+++ b/include/drm/drm_dp_mst_helper.h
@@ -461,6 +461,10 @@ struct drm_dp_mst_topology_mgr {
 	struct work_struct work;
 
 	struct work_struct tx_work;
+
+	struct list_head destroy_connector_list;
+	struct mutex destroy_connector_lock;
+	struct work_struct destroy_connector_work;
 };
 
 int drm_dp_mst_topology_mgr_init(struct drm_dp_mst_topology_mgr *mgr, struct device *dev, struct drm_dp_aux *aux, int max_dpcd_transaction_bytes, int max_payloads, int conn_base_id);
