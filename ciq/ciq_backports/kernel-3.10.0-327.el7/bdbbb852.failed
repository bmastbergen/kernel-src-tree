ipv4: tcp: get rid of ugly unicast_sock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Eric Dumazet <edumazet@google.com>
commit bdbbb8527b6f6a358dbcb70dac247034d665b8e4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/bdbbb852.failed

In commit be9f4a44e7d41 ("ipv4: tcp: remove per net tcp_sock")
I tried to address contention on a socket lock, but the solution
I chose was horrible :

commit 3a7c384ffd57e ("ipv4: tcp: unicast_sock should not land outside
of TCP stack") addressed a selinux regression.

commit 0980e56e506b ("ipv4: tcp: set unicast_sock uc_ttl to -1")
took care of another regression.

commit b5ec8eeac46 ("ipv4: fix ip_send_skb()") fixed another regression.

commit 811230cd85 ("tcp: ipv4: initialize unicast_sock sk_pacing_rate")
was another shot in the dark.

Really, just use a proper socket per cpu, and remove the skb_orphan()
call, to re-enable flow control.

This solves a serious problem with FQ packet scheduler when used in
hostile environments, as we do not want to allocate a flow structure
for every RST packet sent in response to a spoofed packet.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bdbbb8527b6f6a358dbcb70dac247034d665b8e4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ip.h
#	net/ipv4/ip_output.c
#	net/ipv4/tcp_ipv4.c
diff --cc include/net/ip.h
index 01f9ccf5f537,09cf5aebb283..000000000000
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@@ -182,8 -181,10 +182,15 @@@ static inline __u8 ip_reply_arg_flowi_f
  	return (arg->flags & IP_REPLY_ARG_NOSRCCHECK) ? FLOWI_FLAG_ANYSRC : 0;
  }
  
++<<<<<<< HEAD
 +void ip_send_unicast_reply(struct net *net, struct sk_buff *skb, __be32 daddr,
 +			   __be32 saddr, const struct ip_reply_arg *arg,
++=======
+ void ip_send_unicast_reply(struct sock *sk, struct sk_buff *skb,
+ 			   const struct ip_options *sopt,
+ 			   __be32 daddr, __be32 saddr,
+ 			   const struct ip_reply_arg *arg,
++>>>>>>> bdbbb8527b6f (ipv4: tcp: get rid of ugly unicast_sock)
  			   unsigned int len);
  
  #define IP_INC_STATS(net, field)	SNMP_INC_STATS64((net)->mib.ip_statistics, field)
diff --cc net/ipv4/ip_output.c
index ce2a34b345f4,c373c0708d97..000000000000
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@@ -1494,37 -1506,22 +1494,41 @@@ static int ip_reply_glue_bits(void *dpt
  /*
   *	Generic function to send a packet as reply to another packet.
   *	Used to send some TCP resets/acks so far.
-  *
-  *	Use a fake percpu inet socket to avoid false sharing and contention.
   */
++<<<<<<< HEAD
 +static DEFINE_PER_CPU(struct inet_sock, unicast_sock) = {
 +	.sk = {
 +		.__sk_common = {
 +			.skc_refcnt = ATOMIC_INIT(1),
 +		},
 +		.sk_wmem_alloc	= ATOMIC_INIT(1),
 +		.sk_allocation	= GFP_ATOMIC,
 +		.sk_flags	= (1UL << SOCK_USE_WRITE_QUEUE),
 +		.sk_pacing_rate = ~0U,
 +	},
 +	.pmtudisc	= IP_PMTUDISC_WANT,
 +	.uc_ttl		= -1,
 +};
 +
 +void ip_send_unicast_reply(struct net *net, struct sk_buff *skb, __be32 daddr,
 +			   __be32 saddr, const struct ip_reply_arg *arg,
++=======
+ void ip_send_unicast_reply(struct sock *sk, struct sk_buff *skb,
+ 			   const struct ip_options *sopt,
+ 			   __be32 daddr, __be32 saddr,
+ 			   const struct ip_reply_arg *arg,
++>>>>>>> bdbbb8527b6f (ipv4: tcp: get rid of ugly unicast_sock)
  			   unsigned int len)
  {
  	struct ip_options_data replyopts;
  	struct ipcm_cookie ipc;
  	struct flowi4 fl4;
  	struct rtable *rt = skb_rtable(skb);
+ 	struct net *net = sock_net(sk);
  	struct sk_buff *nskb;
- 	struct sock *sk;
- 	struct inet_sock *inet;
  	int err;
  
 -	if (__ip_options_echo(&replyopts.opt.opt, skb, sopt))
 +	if (ip_options_echo(&replyopts.opt.opt, skb))
  		return;
  
  	ipc.addr = daddr;
diff --cc net/ipv4/tcp_ipv4.c
index cf2a920676db,d22f54482bab..000000000000
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@@ -685,10 -682,11 +685,17 @@@ static void tcp_v4_send_reset(struct so
  	if (sk)
  		arg.bound_dev_if = sk->sk_bound_dev_if;
  
 +	net = dev_net(skb_dst(skb)->dev);
  	arg.tos = ip_hdr(skb)->tos;
++<<<<<<< HEAD
 +	ip_send_unicast_reply(net, skb, ip_hdr(skb)->saddr,
 +			      ip_hdr(skb)->daddr, &arg, arg.iov[0].iov_len);
++=======
+ 	ip_send_unicast_reply(*this_cpu_ptr(net->ipv4.tcp_sk),
+ 			      skb, &TCP_SKB_CB(skb)->header.h4.opt,
+ 			      ip_hdr(skb)->saddr, ip_hdr(skb)->daddr,
+ 			      &arg, arg.iov[0].iov_len);
++>>>>>>> bdbbb8527b6f (ipv4: tcp: get rid of ugly unicast_sock)
  
  	TCP_INC_STATS_BH(net, TCP_MIB_OUTSEGS);
  	TCP_INC_STATS_BH(net, TCP_MIB_OUTRSTS);
@@@ -770,8 -768,10 +777,15 @@@ static void tcp_v4_send_ack(struct sk_b
  	if (oif)
  		arg.bound_dev_if = oif;
  	arg.tos = tos;
++<<<<<<< HEAD
 +	ip_send_unicast_reply(net, skb, ip_hdr(skb)->saddr,
 +			      ip_hdr(skb)->daddr, &arg, arg.iov[0].iov_len);
++=======
+ 	ip_send_unicast_reply(*this_cpu_ptr(net->ipv4.tcp_sk),
+ 			      skb, &TCP_SKB_CB(skb)->header.h4.opt,
+ 			      ip_hdr(skb)->saddr, ip_hdr(skb)->daddr,
+ 			      &arg, arg.iov[0].iov_len);
++>>>>>>> bdbbb8527b6f (ipv4: tcp: get rid of ugly unicast_sock)
  
  	TCP_INC_STATS_BH(net, TCP_MIB_OUTSEGS);
  }
* Unmerged path include/net/ip.h
diff --git a/include/net/netns/ipv4.h b/include/net/netns/ipv4.h
index 2ba9de89e8ec..03e6378d5353 100644
--- a/include/net/netns/ipv4.h
+++ b/include/net/netns/ipv4.h
@@ -43,6 +43,7 @@ struct netns_ipv4 {
 	struct inet_peer_base	*peers;
 	struct tcpm_hash_bucket	*tcp_metrics_hash;
 	unsigned int		tcp_metrics_hash_log;
+	struct sock  * __percpu	*tcp_sk;
 	struct netns_frags	frags;
 #ifdef CONFIG_NETFILTER
 	struct xt_table		*iptable_filter;
* Unmerged path net/ipv4/ip_output.c
* Unmerged path net/ipv4/tcp_ipv4.c
