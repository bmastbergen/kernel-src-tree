scsi: Conditionally compile in constants.c

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [scsi] Conditionally compile in constants.c (Ewan Milne) [1124082]
Rebuild_FUZZ: 92.31%
commit-author Hannes Reinecke <hare@suse.de>
commit 2dd951ecd511756f405ae9324db87bb0159f6225
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/2dd951ec.failed

Instead of having constants.c littered with ifdef statements we should
be moving dummy functions into the header and condintionally compile in
constants.c if selected. And update the Kconfig description to reflect
the actual size difference.

	Suggested-by: Christoph Hellwig <hch@infradead.org>
	Tested-by: Robert Elliott <elliott@hp.com>
	Reviewed-by: Robert Elliott <elliott@hp.com>
	Signed-off-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 2dd951ecd511756f405ae9324db87bb0159f6225)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/constants.c
#	drivers/xen/xen-scsiback.c
#	include/scsi/scsi_dbg.h
diff --cc drivers/scsi/constants.c
index cd7131c88f5d,fa09d4be2b53..000000000000
--- a/drivers/scsi/constants.c
+++ b/drivers/scsi/constants.c
@@@ -18,14 -18,7 +18,12 @@@
  #include <scsi/scsi_eh.h>
  #include <scsi/scsi_dbg.h>
  
- 
- 
  /* Commands with service actions that change the command name */
 +#define SERVICE_ACTION_IN_12 0xab
 +#define SERVICE_ACTION_OUT_12 0xa9
 +#define SERVICE_ACTION_BIDIRECTIONAL 0x9d
 +#define SERVICE_ACTION_IN_16 0x9e
 +#define SERVICE_ACTION_OUT_16 0x9f
  #define THIRD_PARTY_COPY_OUT 0x83
  #define THIRD_PARTY_COPY_IN 0x84
  
@@@ -266,28 -256,8 +263,33 @@@ static struct sa_name_list sa_names_arr
  	{0, NULL, 0},
  };
  
++<<<<<<< HEAD
 +#else /* ifndef CONFIG_SCSI_CONSTANTS */
 +static const char *cdb_byte0_names[0];
 +
 +static struct sa_name_list sa_names_arr[] = {
 +	{VARIABLE_LENGTH_CMD, NULL, 0},
 +	{MAINTENANCE_IN, NULL, 0},
 +	{MAINTENANCE_OUT, NULL, 0},
 +	{PERSISTENT_RESERVE_IN, NULL, 0},
 +	{PERSISTENT_RESERVE_OUT, NULL, 0},
 +	{SERVICE_ACTION_IN_12, NULL, 0},
 +	{SERVICE_ACTION_OUT_12, NULL, 0},
 +	{SERVICE_ACTION_BIDIRECTIONAL, NULL, 0},
 +	{SERVICE_ACTION_IN_16, NULL, 0},
 +	{SERVICE_ACTION_OUT_16, NULL, 0},
 +	{THIRD_PARTY_COPY_IN, NULL, 0},
 +	{THIRD_PARTY_COPY_OUT, NULL, 0},
 +	{0, NULL, 0},
 +};
 +#endif /* CONFIG_SCSI_CONSTANTS */
 +
 +static bool scsi_opcode_sa_name(int opcode, int service_action,
 +				const char **cdb_name, const char **sa_name)
++=======
+ bool scsi_opcode_sa_name(int opcode, int service_action,
+ 			 const char **cdb_name, const char **sa_name)
++>>>>>>> 2dd951ecd511 (scsi: Conditionally compile in constants.c)
  {
  	struct sa_name_list *sa_name_ptr;
  	const struct value_name_pair *arr = NULL;
@@@ -320,81 -290,6 +322,84 @@@
  	return true;
  }
  
++<<<<<<< HEAD
 +/* attempt to guess cdb length if cdb_len==0 . No trailing linefeed. */
 +static void print_opcode_name(unsigned char * cdbp, int cdb_len)
 +{
 +	int sa, len, cdb0;
 +	const char *cdb_name = NULL, *sa_name = NULL;
 +
 +	cdb0 = cdbp[0];
 +	if (cdb0 == VARIABLE_LENGTH_CMD) {
 +		len = scsi_varlen_cdb_length(cdbp);
 +		if (len < 10) {
 +			printk("short variable length command, "
 +			       "len=%d ext_len=%d", len, cdb_len);
 +			return;
 +		}
 +		sa = (cdbp[8] << 8) + cdbp[9];
 +	} else {
 +		sa = cdbp[1] & 0x1f;
 +		len = cdb_len;
 +	}
 +
 +	if (!scsi_opcode_sa_name(cdb0, sa, &cdb_name, &sa_name)) {
 +		if (cdb_name)
 +			printk("%s", cdb_name);
 +		else if (cdb0 >= VENDOR_SPECIFIC_CDB)
 +			printk("cdb[0]=0x%x (vendor)", cdb0);
 +		else if (cdb0 >= 0x60 && cdb0 < 0x7e)
 +			printk("cdb[0]=0x%x (reserved)", cdb0);
 +		else
 +			printk("cdb[0]=0x%x", cdb0);
 +	} else {
 +		if (sa_name)
 +			printk("%s", sa_name);
 +		else if (cdb_name)
 +			printk("%s, sa=0x%x", cdb_name, sa);
 +		else
 +			printk("cdb[0]=0x%x, sa=0x%x", cdb0, sa);
 +
 +		if (cdb_len > 0 && len != cdb_len)
 +			printk(", in_cdb_len=%d, ext_len=%d", len, cdb_len);
 +	}
 +}
 +
 +void __scsi_print_command(unsigned char *cdb)
 +{
 +	int k, len;
 +
 +	print_opcode_name(cdb, 0);
 +	len = scsi_command_size(cdb);
 +	/* print out all bytes in cdb */
 +	for (k = 0; k < len; ++k)
 +		printk(" %02x", cdb[k]);
 +	printk("\n");
 +}
 +EXPORT_SYMBOL(__scsi_print_command);
 +
 +void scsi_print_command(struct scsi_cmnd *cmd)
 +{
 +	int k;
 +
 +	if (cmd->cmnd == NULL)
 +		return;
 +
 +	scmd_printk(KERN_INFO, cmd, "CDB: ");
 +	print_opcode_name(cmd->cmnd, cmd->cmd_len);
 +
 +	/* print out all bytes in cdb */
 +	printk(":");
 +	for (k = 0; k < cmd->cmd_len; ++k)
 +		printk(" %02x", cmd->cmnd[k]);
 +	printk("\n");
 +}
 +EXPORT_SYMBOL(scsi_print_command);
 +
 +#ifdef CONFIG_SCSI_CONSTANTS
 +
++=======
++>>>>>>> 2dd951ecd511 (scsi: Conditionally compile in constants.c)
  struct error_info {
  	unsigned short code12;	/* 0x0302 looks better than 0x03,0x02 */
  	const char * text;
@@@ -1274,8 -1193,8 +1276,13 @@@ EXPORT_SYMBOL(scsi_sense_key_string)
   * This string may contain a "%x" and should be printed with ascq as arg.
   */
  const char *
++<<<<<<< HEAD
 +scsi_extd_sense_format(unsigned char asc, unsigned char ascq) {
 +#ifdef CONFIG_SCSI_CONSTANTS
++=======
+ scsi_extd_sense_format(unsigned char asc, unsigned char ascq, const char **fmt)
+ {
++>>>>>>> 2dd951ecd511 (scsi: Conditionally compile in constants.c)
  	int i;
  	unsigned short code = ((asc << 8) | ascq);
  
@@@ -1286,193 -1205,15 +1293,193 @@@
  	for (i = 0; additional2[i].fmt; i++) {
  		if (additional2[i].code1 == asc &&
  		    ascq >= additional2[i].code2_min &&
 -		    ascq <= additional2[i].code2_max) {
 -			*fmt = additional2[i].fmt;
 -			return additional2[i].str;
 -		}
 +		    ascq <= additional2[i].code2_max)
 +			return additional2[i].fmt;
  	}
- #else
- 	*fmt = NULL;
- #endif
  	return NULL;
  }
  EXPORT_SYMBOL(scsi_extd_sense_format);
  
++<<<<<<< HEAD
 +void
 +scsi_show_extd_sense(unsigned char asc, unsigned char ascq)
 +{
 +        const char *extd_sense_fmt = scsi_extd_sense_format(asc, ascq);
 +
 +	if (extd_sense_fmt) {
 +		if (strstr(extd_sense_fmt, "%x")) {
 +			printk("Add. Sense: ");
 +			printk(extd_sense_fmt, ascq);
 +		} else
 +			printk("Add. Sense: %s", extd_sense_fmt);
 +	} else {
 +		if (asc >= 0x80)
 +			printk("<<vendor>> ASC=0x%x ASCQ=0x%x", asc,
 +			       ascq);
 +		if (ascq >= 0x80)
 +			printk("ASC=0x%x <<vendor>> ASCQ=0x%x", asc,
 +			       ascq);
 +		else
 +			printk("ASC=0x%x ASCQ=0x%x", asc, ascq);
 +	}
 +
 +	printk("\n");
 +}
 +EXPORT_SYMBOL(scsi_show_extd_sense);
 +
 +void
 +scsi_show_sense_hdr(struct scsi_sense_hdr *sshdr)
 +{
 +	const char *sense_txt;
 +
 +	sense_txt = scsi_sense_key_string(sshdr->sense_key);
 +	if (sense_txt)
 +		printk("Sense Key : %s ", sense_txt);
 +	else
 +		printk("Sense Key : 0x%x ", sshdr->sense_key);
 +
 +	printk("%s", scsi_sense_is_deferred(sshdr) ? "[deferred] " :
 +	       "[current] ");
 +
 +	if (sshdr->response_code >= 0x72)
 +		printk("[descriptor]");
 +
 +	printk("\n");
 +}
 +EXPORT_SYMBOL(scsi_show_sense_hdr);
 +
 +/*
 + * Print normalized SCSI sense header with a prefix.
 + */
 +void
 +scsi_print_sense_hdr(const char *name, struct scsi_sense_hdr *sshdr)
 +{
 +	printk(KERN_INFO "%s: ", name);
 +	scsi_show_sense_hdr(sshdr);
 +	printk(KERN_INFO "%s: ", name);
 +	scsi_show_extd_sense(sshdr->asc, sshdr->ascq);
 +}
 +EXPORT_SYMBOL(scsi_print_sense_hdr);
 +
 +static void
 +scsi_decode_sense_buffer(const unsigned char *sense_buffer, int sense_len,
 +		       struct scsi_sense_hdr *sshdr)
 +{
 +	int k, num, res;
 +
 +	res = scsi_normalize_sense(sense_buffer, sense_len, sshdr);
 +	if (0 == res) {
 +		/* this may be SCSI-1 sense data */
 +		num = (sense_len < 32) ? sense_len : 32;
 +		printk("Unrecognized sense data (in hex):");
 +		for (k = 0; k < num; ++k) {
 +			if (0 == (k % 16)) {
 +				printk("\n");
 +				printk(KERN_INFO "        ");
 +			}
 +			printk("%02x ", sense_buffer[k]);
 +		}
 +		printk("\n");
 +		return;
 +	}
 +}
 +
 +static void
 +scsi_decode_sense_extras(const unsigned char *sense_buffer, int sense_len,
 +			 struct scsi_sense_hdr *sshdr)
 +{
 +	int k, num, res;
 +
 +	if (sshdr->response_code < 0x72)
 +	{
 +		/* only decode extras for "fixed" format now */
 +		char buff[80];
 +		int blen, fixed_valid;
 +		unsigned int info;
 +
 +		fixed_valid = sense_buffer[0] & 0x80;
 +		info = ((sense_buffer[3] << 24) | (sense_buffer[4] << 16) |
 +			(sense_buffer[5] << 8) | sense_buffer[6]);
 +		res = 0;
 +		memset(buff, 0, sizeof(buff));
 +		blen = sizeof(buff) - 1;
 +		if (fixed_valid)
 +			res += snprintf(buff + res, blen - res,
 +					"Info fld=0x%x", info);
 +		if (sense_buffer[2] & 0x80) {
 +			/* current command has read a filemark */
 +			if (res > 0)
 +				res += snprintf(buff + res, blen - res, ", ");
 +			res += snprintf(buff + res, blen - res, "FMK");
 +		}
 +		if (sense_buffer[2] & 0x40) {
 +			/* end-of-medium condition exists */
 +			if (res > 0)
 +				res += snprintf(buff + res, blen - res, ", ");
 +			res += snprintf(buff + res, blen - res, "EOM");
 +		}
 +		if (sense_buffer[2] & 0x20) {
 +			/* incorrect block length requested */
 +			if (res > 0)
 +				res += snprintf(buff + res, blen - res, ", ");
 +			res += snprintf(buff + res, blen - res, "ILI");
 +		}
 +		if (res > 0)
 +			printk("%s\n", buff);
 +	} else if (sshdr->additional_length > 0) {
 +		/* descriptor format with sense descriptors */
 +		num = 8 + sshdr->additional_length;
 +		num = (sense_len < num) ? sense_len : num;
 +		printk("Descriptor sense data with sense descriptors "
 +		       "(in hex):");
 +		for (k = 0; k < num; ++k) {
 +			if (0 == (k % 16)) {
 +				printk("\n");
 +				printk(KERN_INFO "        ");
 +			}
 +			printk("%02x ", sense_buffer[k]);
 +		}
 +
 +		printk("\n");
 +	}
 +
 +}
 +
 +/* Normalize and print sense buffer with name prefix */
 +void __scsi_print_sense(const char *name, const unsigned char *sense_buffer,
 +			int sense_len)
 +{
 +	struct scsi_sense_hdr sshdr;
 +
 +	printk(KERN_INFO "%s: ", name);
 +	scsi_decode_sense_buffer(sense_buffer, sense_len, &sshdr);
 +	scsi_show_sense_hdr(&sshdr);
 +	scsi_decode_sense_extras(sense_buffer, sense_len, &sshdr);
 +	printk(KERN_INFO "%s: ", name);
 +	scsi_show_extd_sense(sshdr.asc, sshdr.ascq);
 +}
 +EXPORT_SYMBOL(__scsi_print_sense);
 +
 +/* Normalize and print sense buffer in SCSI command */
 +void scsi_print_sense(char *name, struct scsi_cmnd *cmd)
 +{
 +	struct scsi_sense_hdr sshdr;
 +
 +	scmd_printk(KERN_INFO, cmd, " ");
 +	scsi_decode_sense_buffer(cmd->sense_buffer, SCSI_SENSE_BUFFERSIZE,
 +				 &sshdr);
 +	scsi_show_sense_hdr(&sshdr);
 +	scsi_decode_sense_extras(cmd->sense_buffer, SCSI_SENSE_BUFFERSIZE,
 +				 &sshdr);
 +	scmd_printk(KERN_INFO, cmd, " ");
 +	scsi_show_extd_sense(sshdr.asc, sshdr.ascq);
 +}
 +EXPORT_SYMBOL(scsi_print_sense);
 +
 +#ifdef CONFIG_SCSI_CONSTANTS
 +
++=======
++>>>>>>> 2dd951ecd511 (scsi: Conditionally compile in constants.c)
  static const char * const hostbyte_table[]={
  "DID_OK", "DID_NO_CONNECT", "DID_BUS_BUSY", "DID_TIME_OUT", "DID_BAD_TARGET",
  "DID_ABORT", "DID_PARITY", "DID_ERROR", "DID_RESET", "DID_BAD_INTR",
@@@ -1512,35 -1247,28 +1513,61 @@@ const char *scsi_driverbyte_string(int 
  }
  EXPORT_SYMBOL(scsi_driverbyte_string);
  
++<<<<<<< HEAD
 +void scsi_show_result(int result)
 +{
 +	const char *hb_string = scsi_hostbyte_string(result);
 +	const char *db_string = scsi_driverbyte_string(result);
 +
 +	if (hb_string || db_string)
 +		printk("Result: hostbyte=%s driverbyte=%s\n",
 +		       hb_string ? hb_string : "invalid",
 +		       db_string ? db_string : "invalid");
 +	else
 +		printk("Result: hostbyte=0x%02x driverbyte=0x%02x\n",
 +		       host_byte(result), driver_byte(result));
++=======
+ #define scsi_mlreturn_name(result)	{ result, #result }
+ static const struct value_name_pair scsi_mlreturn_arr[] = {
+ 	scsi_mlreturn_name(NEEDS_RETRY),
+ 	scsi_mlreturn_name(SUCCESS),
+ 	scsi_mlreturn_name(FAILED),
+ 	scsi_mlreturn_name(QUEUED),
+ 	scsi_mlreturn_name(SOFT_ERROR),
+ 	scsi_mlreturn_name(ADD_TO_MLQUEUE),
+ 	scsi_mlreturn_name(TIMEOUT_ERROR),
+ 	scsi_mlreturn_name(SCSI_RETURN_NOT_HANDLED),
+ 	scsi_mlreturn_name(FAST_IO_FAIL)
+ };
+ 
+ const char *scsi_mlreturn_string(int result)
+ {
+ 	const struct value_name_pair *arr = scsi_mlreturn_arr;
+ 	int k;
+ 
+ 	for (k = 0; k < ARRAY_SIZE(scsi_mlreturn_arr); ++k, ++arr) {
+ 		if (result == arr->value)
+ 			return arr->name;
+ 	}
+ 	return NULL;
++>>>>>>> 2dd951ecd511 (scsi: Conditionally compile in constants.c)
 +}
 +EXPORT_SYMBOL(scsi_show_result);
 +
 +
 +void scsi_print_result(struct scsi_cmnd *cmd)
 +{
 +	const char *hb_string = scsi_hostbyte_string(cmd->result);
 +	const char *db_string = scsi_driverbyte_string(cmd->result);
 +
 +	if (hb_string || db_string)
 +		scmd_printk(KERN_INFO, cmd,
 +			    "Result: hostbyte=%s driverbyte=%s",
 +			    hb_string ? hb_string : "invalid",
 +			    db_string ? db_string : "invalid");
 +	else
 +		scmd_printk(KERN_INFO, cmd,
 +			    "Result: hostbyte=0x%02x driverbyte=0x%02x",
 +			    host_byte(cmd->result), driver_byte(cmd->result));
  }
 -EXPORT_SYMBOL(scsi_mlreturn_string);
 +EXPORT_SYMBOL(scsi_print_result);
diff --cc include/scsi/scsi_dbg.h
index ed755e53b4c8,f8170e90b49d..000000000000
--- a/include/scsi/scsi_dbg.h
+++ b/include/scsi/scsi_dbg.h
@@@ -2,22 -2,91 +2,98 @@@
  #define _SCSI_SCSI_DBG_H
  
  struct scsi_cmnd;
 -struct scsi_device;
  struct scsi_sense_hdr;
  
++<<<<<<< HEAD
++=======
+ #define SCSI_LOG_BUFSIZE 128
+ 
++>>>>>>> 2dd951ecd511 (scsi: Conditionally compile in constants.c)
  extern void scsi_print_command(struct scsi_cmnd *);
 -extern size_t __scsi_format_command(char *, size_t,
 -				   const unsigned char *, size_t);
 -extern void scsi_show_extd_sense(const struct scsi_device *, const char *,
 -				 unsigned char, unsigned char);
 -extern void scsi_show_sense_hdr(const struct scsi_device *, const char *,
 -				const struct scsi_sense_hdr *);
 -extern void scsi_print_sense_hdr(const struct scsi_device *, const char *,
 -				 const struct scsi_sense_hdr *);
 -extern void scsi_print_sense(const struct scsi_cmnd *);
 -extern void __scsi_print_sense(const struct scsi_device *, const char *name,
 +extern void __scsi_print_command(unsigned char *);
 +extern void scsi_show_extd_sense(unsigned char, unsigned char);
 +extern void scsi_show_sense_hdr(struct scsi_sense_hdr *);
 +extern void scsi_print_sense_hdr(const char *, struct scsi_sense_hdr *);
 +extern void scsi_print_sense(char *, struct scsi_cmnd *);
 +extern void __scsi_print_sense(const char *name,
  			       const unsigned char *sense_buffer,
  			       int sense_len);
++<<<<<<< HEAD
 +extern void scsi_show_result(int);
 +extern void scsi_print_result(struct scsi_cmnd *);
 +extern const char *scsi_hostbyte_string(int);
 +extern const char *scsi_driverbyte_string(int);
 +extern const char *scsi_sense_key_string(unsigned char);
 +extern const char *scsi_extd_sense_format(unsigned char, unsigned char);
++=======
+ extern void scsi_print_result(const struct scsi_cmnd *, const char *, int);
+ 
+ #ifdef CONFIG_SCSI_CONSTANTS
+ extern bool scsi_opcode_sa_name(int, int, const char **, const char **);
+ extern const char *scsi_sense_key_string(unsigned char);
+ extern const char *scsi_extd_sense_format(unsigned char, unsigned char,
+ 					  const char **);
+ extern const char *scsi_mlreturn_string(int);
+ extern const char *scsi_hostbyte_string(int);
+ extern const char *scsi_driverbyte_string(int);
+ #else
+ static inline bool
+ scsi_opcode_sa_name(int cmd, int sa,
+ 		    const char **cdb_name, const char **sa_name)
+ {
+ 	*cdb_name = NULL;
+ 	switch (cmd) {
+ 	case VARIABLE_LENGTH_CMD:
+ 	case MAINTENANCE_IN:
+ 	case MAINTENANCE_OUT:
+ 	case PERSISTENT_RESERVE_IN:
+ 	case PERSISTENT_RESERVE_OUT:
+ 	case SERVICE_ACTION_IN_12:
+ 	case SERVICE_ACTION_OUT_12:
+ 	case SERVICE_ACTION_BIDIRECTIONAL:
+ 	case SERVICE_ACTION_IN_16:
+ 	case SERVICE_ACTION_OUT_16:
+ 	case EXTENDED_COPY:
+ 	case RECEIVE_COPY_RESULTS:
+ 		*sa_name = NULL;
+ 		return true;
+ 	default:
+ 		return false;
+ 	}
+ }
+ 
+ static inline const char *
+ scsi_sense_key_string(unsigned char key)
+ {
+ 	return NULL;
+ }
+ 
+ static inline const char *
+ scsi_extd_sense_format(unsigned char asc, unsigned char ascq, const char **fmt)
+ {
+ 	*fmt = NULL;
+ 	return NULL;
+ }
+ 
+ static inline const char *
+ scsi_mlreturn_string(int result)
+ {
+ 	return NULL;
+ }
+ 
+ static inline const char *
+ scsi_hostbyte_string(int result)
+ {
+ 	return NULL;
+ }
+ 
+ static inline const char *
+ scsi_driverbyte_string(int result)
+ {
+ 	return NULL;
+ }
+ 
+ #endif
++>>>>>>> 2dd951ecd511 (scsi: Conditionally compile in constants.c)
  
  #endif /* _SCSI_SCSI_DBG_H */
* Unmerged path drivers/xen/xen-scsiback.c
diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
index 1348fa47d127..f53599ffde7d 100644
--- a/drivers/scsi/Kconfig
+++ b/drivers/scsi/Kconfig
@@ -212,12 +212,12 @@ config SCSI_MULTI_LUN
 	  multiple LUNs.
 
 config SCSI_CONSTANTS
-	bool "Verbose SCSI error reporting (kernel size +=12K)"
+	bool "Verbose SCSI error reporting (kernel size +=75K)"
 	depends on SCSI
 	help
 	  The error messages regarding your SCSI hardware will be easier to
 	  understand if you say Y here; it will enlarge your kernel by about
-	  12 KB. If in doubt, say Y.
+	  75 KB. If in doubt, say Y.
 
 config SCSI_LOGGING
 	bool "SCSI logging facility"
diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
index e53a67bb903e..b919227f3f7f 100644
--- a/drivers/scsi/Makefile
+++ b/drivers/scsi/Makefile
@@ -160,9 +160,9 @@ obj-$(CONFIG_SCSI_OSD_INITIATOR) += osd/
 
 # This goes last, so that "real" scsi devices probe earlier
 obj-$(CONFIG_SCSI_DEBUG)	+= scsi_debug.o
-
-scsi_mod-y			+= scsi.o hosts.o scsi_ioctl.o constants.o \
+scsi_mod-y			+= scsi.o hosts.o scsi_ioctl.o \
 				   scsicam.o scsi_error.o scsi_lib.o
+scsi_mod-$(CONFIG_SCSI_CONSTANTS) += constants.o
 scsi_mod-$(CONFIG_SCSI_DMA)	+= scsi_lib_dma.o
 scsi_mod-y			+= scsi_scan.o scsi_sysfs.o scsi_devinfo.o
 scsi_mod-$(CONFIG_SCSI_NETLINK)	+= scsi_netlink.o
* Unmerged path drivers/scsi/constants.c
* Unmerged path drivers/xen/xen-scsiback.c
* Unmerged path include/scsi/scsi_dbg.h
