x86, irq: Introduce two helper functions to support irqdomain map operation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [x86] irq: Introduce two helper functions to support irqdomain map operation (Steve Best) [1231358]
Rebuild_FUZZ: 96.55%
commit-author Jiang Liu <jiang.liu@linux.intel.com>
commit 15a3c7cc9154321fc3ed1f7738bb7bbe690af91d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/15a3c7cc.failed

Currently there are multiple entries to program IOAPIC pins, such as
io_apic_setup_irq_pin_once(), io_apic_set_pci_routing() and
setup_IO_APIC_irq_extra() etc.

This patch introduces two functions to help consolidate the code to
program IOAPIC pins. Function mp_set_pin_attr() is used to optionally
set trigger, polarity and NUMA node property for an IOAPIC pin.
If mp_set_pin_attr() is not invoked for a pin, the default configuration
from BIOS will be used.

Function mp_irqdomain_map() is an common implementation of irqdomain map()
operation. It figures out attribures for pin and then actually programs
the IOAPIC pin. We hope this will be the only entrance for programming
IOAPIC pin.

And the flow will:
1) caller such as xxx_pci_irq_enable figures out pin attributes.
2) Invoke mp_set_pin_attr() to set attributes for a pin. If the pin has
   already bin programmed,  mp_set_pin_attr() will aslo detects attribute
   confictions.
3) Invoke mp_map_pin_to_irq()
3.1) If IRQ has already been assigned, return irq_find_mapping()
3.2) Else irq_create_mapping()
		->irq_domain_associate()
			->mp_irqdomain_map()
				->io_apic_setup_irq_pin()

So every pin will only programmed once by mp_irqdomain_map(), so we
could kill io_apic_setup_irq_pin_once(), io_apic_set_pci_routing() and
setup_IO_APIC_irq_extra() etc.

	Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
	Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
	Cc: Tony Luck <tony.luck@intel.com>
	Cc: Joerg Roedel <joro@8bytes.org>
	Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Grant Likely <grant.likely@linaro.org>
	Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
	Cc: Bjorn Helgaas <bhelgaas@google.com>
	Cc: Randy Dunlap <rdunlap@infradead.org>
	Cc: Yinghai Lu <yinghai@kernel.org>
Link: http://lkml.kernel.org/r/1402302011-23642-30-git-send-email-jiang.liu@linux.intel.com
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit 15a3c7cc9154321fc3ed1f7738bb7bbe690af91d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/io_apic.h
#	arch/x86/kernel/apic/io_apic.c
diff --cc arch/x86/include/asm/io_apic.h
index 7eb3755fee9a,c53587868590..000000000000
--- a/arch/x86/include/asm/io_apic.h
+++ b/arch/x86/include/asm/io_apic.h
@@@ -168,6 -165,23 +168,26 @@@ extern int get_nr_irqs_gsi(void)
  extern void setup_ioapic_ids_from_mpc(void);
  extern void setup_ioapic_ids_from_mpc_nocheck(void);
  
++<<<<<<< HEAD
++=======
+ enum ioapic_domain_type {
+ 	IOAPIC_DOMAIN_INVALID,
+ 	IOAPIC_DOMAIN_LEGACY,
+ 	IOAPIC_DOMAIN_STRICT,
+ 	IOAPIC_DOMAIN_DYNAMIC,
+ };
+ 
+ struct device_node;
+ struct irq_domain;
+ struct irq_domain_ops;
+ 
+ struct ioapic_domain_cfg {
+ 	enum ioapic_domain_type		type;
+ 	const struct irq_domain_ops	*ops;
+ 	struct device_node		*dev;
+ };
+ 
++>>>>>>> 15a3c7cc9154 (x86, irq: Introduce two helper functions to support irqdomain map operation)
  struct mp_ioapic_gsi{
  	u32 gsi_base;
  	u32 gsi_end;
@@@ -177,7 -191,12 +197,16 @@@ extern u32 gsi_top
  extern int mp_find_ioapic(u32 gsi);
  extern int mp_find_ioapic_pin(int ioapic, u32 gsi);
  extern u32 mp_pin_to_gsi(int ioapic, int pin);
++<<<<<<< HEAD
 +extern void __init mp_register_ioapic(int id, u32 address, u32 gsi_base);
++=======
+ extern int mp_map_gsi_to_irq(u32 gsi, unsigned int flags);
+ extern void __init mp_register_ioapic(int id, u32 address, u32 gsi_base,
+ 				      struct ioapic_domain_cfg *cfg);
+ extern int mp_irqdomain_map(struct irq_domain *domain, unsigned int virq,
+ 			    irq_hw_number_t hwirq);
+ extern int mp_set_gsi_attr(u32 gsi, int trigger, int polarity, int node);
++>>>>>>> 15a3c7cc9154 (x86, irq: Introduce two helper functions to support irqdomain map operation)
  extern void __init pre_init_apic_IRQ0(void);
  
  extern void mp_save_irq(struct mpc_intsrc *m);
diff --cc arch/x86/kernel/apic/io_apic.c
index 07a33b81b46c,a602b35bcfe7..000000000000
--- a/arch/x86/kernel/apic/io_apic.c
+++ b/arch/x86/kernel/apic/io_apic.c
@@@ -86,7 -84,17 +86,15 @@@ int sis_apic_bug = -1
  
  static DEFINE_RAW_SPINLOCK(ioapic_lock);
  static DEFINE_RAW_SPINLOCK(vector_lock);
 -static DEFINE_MUTEX(ioapic_mutex);
 -static unsigned int ioapic_dynirq_base;
  
+ struct mp_pin_info {
+ 	int trigger;
+ 	int polarity;
+ 	int node;
+ 	int set;
+ 	u32 count;
+ };
+ 
  static struct ioapic {
  	/*
  	 * # of IRQ routing registers
@@@ -100,6 -108,9 +108,12 @@@
  	struct mpc_ioapic mp_config;
  	/* IO APIC gsi routing info */
  	struct mp_ioapic_gsi  gsi_config;
++<<<<<<< HEAD
++=======
+ 	struct ioapic_domain_cfg irqdomain_cfg;
+ 	struct irq_domain *irqdomain;
+ 	struct mp_pin_info *pin_info;
++>>>>>>> 15a3c7cc9154 (x86, irq: Introduce two helper functions to support irqdomain map operation)
  	DECLARE_BITMAP(pin_programmed, MP_MAX_IOAPIC_PIN + 1);
  } ioapics[MAX_IO_APICS];
  
@@@ -132,10 -143,27 +146,27 @@@ u32 mp_pin_to_gsi(int ioapic, int pin
  	return mp_ioapic_gsi_routing(ioapic)->gsi_base + pin;
  }
  
 -/*
 - * Initialize all legacy IRQs and all pins on the first IOAPIC
 - * if we have legacy interrupt controller. Kernel boot option "pirq="
 - * may rely on non-legacy pins on the first IOAPIC.
 - */
 +/* Initialize all legacy IRQs and all pins on the first IOAPIC at boot */
  static inline int mp_init_irq_at_boot(int ioapic, int irq)
  {
++<<<<<<< HEAD
 +	return ioapic == 0 || (irq >= 0 && irq < NR_IRQS_LEGACY);
++=======
+ 	if (!nr_legacy_irqs())
+ 		return 0;
+ 
+ 	return ioapic == 0 || (irq >= 0 && irq < nr_legacy_irqs());
+ }
+ 
+ static inline struct mp_pin_info *mp_pin_info(int ioapic_idx, int pin)
+ {
+ 	return ioapics[ioapic_idx].pin_info + pin;
+ }
+ 
+ static inline struct irq_domain *mp_ioapic_irqdomain(int ioapic)
+ {
+ 	return ioapics[ioapic].irqdomain;
++>>>>>>> 15a3c7cc9154 (x86, irq: Introduce two helper functions to support irqdomain map operation)
  }
  
  int nr_ioapics;
@@@ -984,11 -983,87 +1015,59 @@@ static int irq_trigger(int idx
  	return trigger;
  }
  
 -static int alloc_irq_from_domain(struct irq_domain *domain, u32 gsi, int pin)
 -{
 -	int irq = -1;
 -	int ioapic = (int)(long)domain->host_data;
 -	int type = ioapics[ioapic].irqdomain_cfg.type;
 -
 -	switch (type) {
 -	case IOAPIC_DOMAIN_LEGACY:
 -		/*
 -		 * Dynamically allocate IRQ number for non-ISA IRQs in the first 16
 -		 * GSIs on some weird platforms.
 -		 */
 -		if (gsi < nr_legacy_irqs())
 -			irq = irq_create_mapping(domain, pin);
 -		else if (irq_create_strict_mappings(domain, gsi, pin, 1) == 0)
 -			irq = gsi;
 -		break;
 -	case IOAPIC_DOMAIN_STRICT:
 -		if (irq_create_strict_mappings(domain, gsi, pin, 1) == 0)
 -			irq = gsi;
 -		break;
 -	case IOAPIC_DOMAIN_DYNAMIC:
 -		irq = irq_create_mapping(domain, pin);
 -		break;
 -	default:
 -		WARN(1, "ioapic: unknown irqdomain type %d\n", type);
 -		break;
 -	}
 -
 -	return irq > 0 ? irq : -1;
 -}
 -
 -static int mp_map_pin_to_irq(u32 gsi, int idx, int ioapic, int pin,
 -			     unsigned int flags)
 +static int pin_2_irq(int idx, int apic, int pin)
  {
  	int irq;
++<<<<<<< HEAD
 +	int bus = mp_irqs[idx].srcbus;
 +	struct mp_ioapic_gsi *gsi_cfg = mp_ioapic_gsi_routing(apic);
++=======
+ 	struct irq_domain *domain = mp_ioapic_irqdomain(ioapic);
+ 	struct mp_pin_info *info = mp_pin_info(ioapic, pin);
+ 
+ 	/*
+ 	 * Don't use irqdomain to manage ISA IRQs because there may be
+ 	 * multiple IOAPIC pins sharing the same ISA IRQ number and
+ 	 * irqdomain only supports 1:1 mapping between IOAPIC pin and
+ 	 * IRQ number. A typical IOAPIC has 24 pins, pin 0-15 are used
+ 	 * for legacy IRQs and pin 16-23 are used for PCI IRQs (PIRQ A-H).
+ 	 * When ACPI is disabled, only legacy IRQ numbers (IRQ0-15) are
+ 	 * available, and some BIOSes may use MP Interrupt Source records
+ 	 * to override IRQ numbers for PIRQs instead of reprogramming
+ 	 * the interrupt routing logic. Thus there may be multiple pins
+ 	 * sharing the same legacy IRQ number when ACPI is disabled.
+ 	 */
+ 	if (idx >= 0 && test_bit(mp_irqs[idx].srcbus, mp_bus_not_pci))
+ 		return mp_irqs[idx].srcbusirq;
+ 
+ 	if (!domain) {
+ 		/*
+ 		 * Provide an identity mapping of gsi == irq except on truly
+ 		 * weird platforms that have non isa irqs in the first 16 gsis.
+ 		 */
+ 		return gsi >= nr_legacy_irqs() ? gsi : gsi_top + gsi;
+ 	}
+ 
+ 	mutex_lock(&ioapic_mutex);
+ 	irq = irq_find_mapping(domain, pin);
+ 	if (irq <= 0 && (flags & IOAPIC_MAP_ALLOC))
+ 		irq = alloc_irq_from_domain(domain, gsi, pin);
+ 
+ 	if (flags & IOAPIC_MAP_ALLOC) {
+ 		if (irq > 0)
+ 			info->count++;
+ 		else if (info->count == 0)
+ 			info->set = 0;
+ 	}
+ 	mutex_unlock(&ioapic_mutex);
+ 
+ 	return irq > 0 ? irq : -1;
+ }
+ 
+ static int pin_2_irq(int idx, int ioapic, int pin, unsigned int flags)
+ {
+ 	u32 gsi = mp_pin_to_gsi(ioapic, pin);
++>>>>>>> 15a3c7cc9154 (x86, irq: Introduce two helper functions to support irqdomain map operation)
  
  	/*
  	 * Debugging check, we are in big trouble if this message pops up!
@@@ -2854,8 -2943,44 +2933,46 @@@ out
   */
  #define PIC_IRQS	(1UL << PIC_CASCADE_IR)
  
++<<<<<<< HEAD
++=======
+ static int mp_irqdomain_create(int ioapic)
+ {
+ 	size_t size;
+ 	int hwirqs = mp_ioapic_pin_count(ioapic);
+ 	struct ioapic *ip = &ioapics[ioapic];
+ 	struct ioapic_domain_cfg *cfg = &ip->irqdomain_cfg;
+ 	struct mp_ioapic_gsi *gsi_cfg = mp_ioapic_gsi_routing(ioapic);
+ 
+ 	size = sizeof(struct mp_pin_info) * mp_ioapic_pin_count(ioapic);
+ 	ip->pin_info = kzalloc(size, GFP_KERNEL);
+ 	if (!ip->pin_info)
+ 		return -ENOMEM;
+ 
+ 	if (cfg->type == IOAPIC_DOMAIN_INVALID)
+ 		return 0;
+ 
+ 	ip->irqdomain = irq_domain_add_linear(cfg->dev, hwirqs, cfg->ops,
+ 					      (void *)(long)ioapic);
+ 	if(!ip->irqdomain) {
+ 		kfree(ip->pin_info);
+ 		ip->pin_info = NULL;
+ 		return -ENOMEM;
+ 	}
+ 
+ 	if (cfg->type == IOAPIC_DOMAIN_LEGACY ||
+ 	    cfg->type == IOAPIC_DOMAIN_STRICT)
+ 		ioapic_dynirq_base = max(ioapic_dynirq_base,
+ 					 gsi_cfg->gsi_end + 1);
+ 
+ 	if (gsi_cfg->gsi_base == 0)
+ 		irq_set_default_host(ip->irqdomain);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 15a3c7cc9154 (x86, irq: Introduce two helper functions to support irqdomain map operation)
  void __init setup_IO_APIC(void)
  {
 -	int ioapic;
  
  	/*
  	 * calling enable_IO_APIC() is moved to setup_local_APIC for BP
* Unmerged path arch/x86/include/asm/io_apic.h
* Unmerged path arch/x86/kernel/apic/io_apic.c
