bonding: Neaten pr_<level>

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Joe Perches <joe@perches.com>
commit 90194264ceffdff809e625f54767f6f8c292a28e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/90194264.failed

Add missing terminating newlines.
Convert uses of pr_info to pr_cont in bond_check_params.
Standardize upper/lower case styles.
Typo fixes, remove unnecessary parentheses and periods.
Alignment neatening.

	Signed-off-by: Joe Perches <joe@perches.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 90194264ceffdff809e625f54767f6f8c292a28e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_3ad.c
#	drivers/net/bonding/bond_main.c
#	drivers/net/bonding/bond_netlink.c
#	drivers/net/bonding/bond_options.c
#	drivers/net/bonding/bond_procfs.c
diff --cc drivers/net/bonding/bond_3ad.c
index dc508c87249d,f6eda2d42dbe..000000000000
--- a/drivers/net/bonding/bond_3ad.c
+++ b/drivers/net/bonding/bond_3ad.c
@@@ -1127,10 -1077,12 +1127,19 @@@ static void ad_rx_machine(struct lacpd
  			break;
  		case AD_RX_CURRENT:
  			/* detect loopback situation */
++<<<<<<< HEAD
 +			if (MAC_ADDRESS_EQUAL(&(lacpdu->actor_system), &(port->actor_system))) {
 +				pr_err("%s: An illegal loopback occurred on adapter (%s).\n"
 +				       "Check the configuration to verify that all adapters are connected to 802.3ad compliant switch ports\n",
 +				       port->slave->bond->dev->name, port->slave->dev->name);
++=======
+ 			if (MAC_ADDRESS_EQUAL(&(lacpdu->actor_system),
+ 					      &(port->actor_system))) {
+ 				pr_err("%s: An illegal loopback occurred on adapter (%s)\n"
+ 				       "Check the configuration to verify that all adapters are connected to 802.3ad compliant switch ports\n",
+ 				       port->slave->bond->dev->name,
+ 				       port->slave->dev->name);
++>>>>>>> 90194264ceff (bonding: Neaten pr_<level>)
  				return;
  			}
  			__update_selected(lacpdu, port);
@@@ -2004,10 -1945,13 +2013,10 @@@ void bond_3ad_unbind_slave(struct slav
  			}
  			if (!slave_iter)
  				new_aggregator = NULL;
 -
 -			/* if new aggregator found, copy the aggregator's
 -			 * parameters and connect the related lag_ports to the
 -			 * new aggregator
 -			 */
 +			// if new aggregator found, copy the aggregator's parameters
 +			// and connect the related lag_ports to the new aggregator
  			if ((new_aggregator) && ((!new_aggregator->lag_ports) || ((new_aggregator->lag_ports == port) && !new_aggregator->lag_ports->next_port_in_aggregator))) {
- 				pr_debug("Some port(s) related to LAG %d - replaceing with LAG %d\n",
+ 				pr_debug("Some port(s) related to LAG %d - replacing with LAG %d\n",
  					 aggregator->aggregator_identifier,
  					 new_aggregator->aggregator_identifier);
  
diff --cc drivers/net/bonding/bond_main.c
index 4c3b4d213395,90994ed31eb4..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -1562,12 -1268,16 +1561,23 @@@ int bond_enslave(struct net_device *bon
  	}
  
  	if (slave_ops->ndo_set_mac_address == NULL) {
++<<<<<<< HEAD
 +		if (bond->slave_cnt == 0) {
 +			pr_warning("%s: Warning: The first slave device specified does not support setting the MAC address. Setting fail_over_mac to active.",
 +				   bond_dev->name);
 +			bond->params.fail_over_mac = BOND_FOM_ACTIVE;
++=======
+ 		if (!bond_has_slaves(bond)) {
+ 			pr_warn("%s: Warning: The first slave device specified does not support setting the MAC address\n",
+ 				bond_dev->name);
+ 			if (bond->params.mode == BOND_MODE_ACTIVEBACKUP) {
+ 				bond->params.fail_over_mac = BOND_FOM_ACTIVE;
+ 				pr_warn("%s: Setting fail_over_mac to active for active-backup mode\n",
+ 					bond_dev->name);
+ 			}
++>>>>>>> 90194264ceff (bonding: Neaten pr_<level>)
  		} else if (bond->params.fail_over_mac != BOND_FOM_ACTIVE) {
- 			pr_err("%s: Error: The slave device specified does not support setting the MAC address, but fail_over_mac is not set to active.\n",
+ 			pr_err("%s: Error: The slave device specified does not support setting the MAC address, but fail_over_mac is not set to active\n",
  			       bond_dev->name);
  			res = -EOPNOTSUPP;
  			goto err_undo_flags;
@@@ -1838,11 -1530,26 +1847,11 @@@
  		goto err_unregister;
  	}
  
 -	res = bond_sysfs_slave_add(new_slave);
 -	if (res) {
 -		pr_debug("Error %d calling bond_sysfs_slave_add\n", res);
 -		goto err_upper_unlink;
 -	}
 -
 -	bond->slave_cnt++;
 -	bond_compute_features(bond);
 -	bond_set_carrier(bond);
 -
 -	if (USES_PRIMARY(bond->params.mode)) {
 -		write_lock_bh(&bond->curr_slave_lock);
 -		bond_select_active_slave(bond);
 -		write_unlock_bh(&bond->curr_slave_lock);
 -	}
  
- 	pr_info("%s: enslaving %s as a%s interface with a%s link.\n",
+ 	pr_info("%s: Enslaving %s as %s interface with %s link\n",
  		bond_dev->name, slave_dev->name,
- 		bond_is_active_slave(new_slave) ? "n active" : " backup",
- 		new_slave->link != BOND_LINK_DOWN ? "n up" : " down");
+ 		bond_is_active_slave(new_slave) ? "an active" : "a backup",
+ 		new_slave->link != BOND_LINK_DOWN ? "an up" : "a down");
  
  	/* enslave is successful */
  	return 0;
@@@ -1961,24 -1660,13 +1970,24 @@@ static int __bond_release_one(struct ne
  	netdev_rx_handler_unregister(slave_dev);
  	write_lock_bh(&bond->lock);
  
 +	if (!all && !bond->params.fail_over_mac) {
 +		if (ether_addr_equal(bond_dev->dev_addr, slave->perm_hwaddr) &&
 +		    bond->slave_cnt > 1)
 +			pr_warning("%s: Warning: the permanent HWaddr of %s - %pM - is still in use by %s. Set the HWaddr of %s to a different address to avoid conflicts.\n",
 +				   bond_dev->name, slave_dev->name,
 +				   slave->perm_hwaddr,
 +				   bond_dev->name, slave_dev->name);
 +	}
 +
  	/* Inform AD package of unbinding of slave. */
 -	if (bond->params.mode == BOND_MODE_8023AD)
 +	if (bond->params.mode == BOND_MODE_8023AD) {
 +		/* must be called before the slave is
 +		 * detached from the list
 +		 */
  		bond_3ad_unbind_slave(slave);
 -
 -	write_unlock_bh(&bond->lock);
 +	}
  
- 	pr_info("%s: releasing %s interface %s\n",
+ 	pr_info("%s: Releasing %s interface %s\n",
  		bond_dev->name,
  		bond_is_active_slave(slave) ? "active" : "backup",
  		slave_dev->name);
@@@ -1987,8 -1675,15 +1996,20 @@@
  
  	bond->current_arp_slave = NULL;
  
++<<<<<<< HEAD
 +	/* release the slave from its bond */
 +	bond_detach_slave(bond, slave);
++=======
+ 	if (!all && (!bond->params.fail_over_mac ||
+ 		     bond->params.mode != BOND_MODE_ACTIVEBACKUP)) {
+ 		if (ether_addr_equal_64bits(bond_dev->dev_addr, slave->perm_hwaddr) &&
+ 		    bond_has_slaves(bond))
+ 			pr_warn("%s: Warning: the permanent HWaddr of %s - %pM - is still in use by %s - set the HWaddr of %s to a different address to avoid conflicts\n",
+ 				bond_dev->name, slave_dev->name,
+ 				slave->perm_hwaddr,
+ 				bond_dev->name, slave_dev->name);
+ 	}
++>>>>>>> 90194264ceff (bonding: Neaten pr_<level>)
  
  	if (bond->primary_slave == slave)
  		bond->primary_slave = NULL;
@@@ -2113,9 -1807,9 +2134,9 @@@ static int  bond_release_and_destroy(st
  	int ret;
  
  	ret = bond_release(bond_dev, slave_dev);
 -	if (ret == 0 && !bond_has_slaves(bond)) {
 +	if ((ret == 0) && (bond->slave_cnt == 0)) {
  		bond_dev->priv_flags |= IFF_DISABLE_NETPOLL;
- 		pr_info("%s: destroying bond %s.\n",
+ 		pr_info("%s: Destroying bond %s\n",
  			bond_dev->name, bond_dev->name);
  		unregister_netdevice(bond_dev);
  	}
@@@ -2988,13 -2672,32 +3008,13 @@@ static void bond_ab_arp_probe(struct bo
  
  			bond_set_slave_inactive_flags(slave);
  
- 			pr_info("%s: backup interface %s is now down.\n",
+ 			pr_info("%s: backup interface %s is now down\n",
  				bond->dev->name, slave->dev->name);
  		}
 -		if (slave == curr_arp_slave)
 -			found = true;
 -	}
 -
 -	if (!new_slave && before)
 -		new_slave = before;
 -
 -	if (!new_slave) {
 -		rtnl_unlock();
 -		return true;
  	}
 -
 -	new_slave->link = BOND_LINK_BACK;
 -	bond_set_slave_active_flags(new_slave);
 -	bond_arp_send_all(bond, new_slave);
 -	new_slave->jiffies = jiffies;
 -	rcu_assign_pointer(bond->current_arp_slave, new_slave);
 -	rtnl_unlock();
 -
 -	return true;
  }
  
 -static void bond_activebackup_arp_mon(struct work_struct *work)
 +void bond_activebackup_arp_mon(struct work_struct *work)
  {
  	struct bonding *bond = container_of(work, struct bonding,
  					    arp_work.work);
@@@ -3192,11 -2890,10 +3212,10 @@@ static int bond_slave_netdev_event(unsi
  static int bond_netdev_event(struct notifier_block *this,
  			     unsigned long event, void *ptr)
  {
 -	struct net_device *event_dev = netdev_notifier_info_to_dev(ptr);
 +	struct net_device *event_dev = (struct net_device *)ptr;
  
  	pr_debug("event_dev: %s, event: %lx\n",
- 		 event_dev ? event_dev->name : "None",
- 		 event);
+ 		 event_dev ? event_dev->name : "None", event);
  
  	if (!(event_dev->priv_flags & IFF_BONDING))
  		return NOTIFY_DONE;
@@@ -3684,12 -3344,12 +3703,12 @@@ static int bond_neigh_setup(struct net_
  static int bond_change_mtu(struct net_device *bond_dev, int new_mtu)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
 -	struct slave *slave, *rollback_slave;
 -	struct list_head *iter;
 +	struct slave *slave, *stop_at;
  	int res = 0;
 +	int i;
  
- 	pr_debug("bond=%p, name=%s, new_mtu=%d\n", bond,
- 		 (bond_dev ? bond_dev->name : "None"), new_mtu);
+ 	pr_debug("bond=%p, name=%s, new_mtu=%d\n",
+ 		 bond, bond_dev ? bond_dev->name : "None", new_mtu);
  
  	/* Can't hold bond->lock with bh disabled here since
  	 * some base drivers panic. On the other hand we can't
@@@ -3706,11 -3366,9 +3725,17 @@@
  	 * call to the base driver.
  	 */
  
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
 +		pr_debug("s %p s->p %p c_m %p\n",
 +			 slave,
 +			 slave->prev,
 +			 slave->dev->netdev_ops->ndo_change_mtu);
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
+ 		pr_debug("s %p c_m %p\n",
+ 			 slave, slave->dev->netdev_ops->ndo_change_mtu);
++>>>>>>> 90194264ceff (bonding: Neaten pr_<level>)
  
  		res = dev_set_mtu(slave->dev, new_mtu);
  
@@@ -4295,9 -3920,9 +4320,15 @@@ static void bond_uninit(struct net_devi
  	bond_netpoll_cleanup(bond_dev);
  
  	/* Release the bonded slaves */
++<<<<<<< HEAD
 +	while (bond->first_slave != NULL)
 +		__bond_release_one(bond_dev, bond->first_slave->dev, true);
 +	pr_info("%s: released all slaves\n", bond_dev->name);
++=======
+ 	bond_for_each_slave(bond, slave, iter)
+ 		__bond_release_one(bond_dev, slave->dev, true);
+ 	pr_info("%s: Released all slaves\n", bond_dev->name);
++>>>>>>> 90194264ceff (bonding: Neaten pr_<level>)
  
  	list_del(&bond->bond_list);
  
@@@ -4367,13 -4000,13 +4398,13 @@@ static int bond_check_params(struct bon
  		if ((bond_mode != BOND_MODE_XOR) &&
  		    (bond_mode != BOND_MODE_8023AD)) {
  			pr_info("xmit_hash_policy param is irrelevant in mode %s\n",
- 			       bond_mode_name(bond_mode));
+ 				bond_mode_name(bond_mode));
  		} else {
 -			bond_opt_initstr(&newval, xmit_hash_policy);
 -			valptr = bond_opt_parse(bond_opt_get(BOND_OPT_XMIT_HASH),
 -						&newval);
 -			if (!valptr) {
 +			xmit_hashtype = bond_parse_parm(xmit_hash_policy,
 +							xmit_hashtype_tbl);
 +			if (xmit_hashtype == -1) {
  				pr_err("Error: Invalid xmit_hash_policy \"%s\"\n",
 +				       xmit_hash_policy == NULL ? "NULL" :
  				       xmit_hash_policy);
  				return -EINVAL;
  			}
@@@ -4590,15 -4225,15 +4621,15 @@@
  	if (miimon) {
  		pr_info("MII link monitoring set to %d ms\n", miimon);
  	} else if (arp_interval) {
 -		valptr = bond_opt_get_val(BOND_OPT_ARP_VALIDATE,
 -					  arp_validate_value);
  		pr_info("ARP monitoring set to %d ms, validate %s, with %d target(s):",
 -			arp_interval, valptr->string, arp_ip_count);
 +			arp_interval,
 +			arp_validate_tbl[arp_validate_value].modename,
 +			arp_ip_count);
  
  		for (i = 0; i < arp_ip_count; i++)
- 			pr_info(" %s", arp_ip_target[i]);
+ 			pr_cont(" %s", arp_ip_target[i]);
  
- 		pr_info("\n");
+ 		pr_cont("\n");
  
  	} else if (max_bonds) {
  		/* miimon and arp_interval not set, we need one so things
diff --cc drivers/net/bonding/bond_netlink.c
index 40e7b1cb4aea,20659b114f24..000000000000
--- a/drivers/net/bonding/bond_netlink.c
+++ b/drivers/net/bonding/bond_netlink.c
@@@ -60,8 -138,213 +60,216 @@@ static int bond_changelink(struct net_d
  						       ifindex);
  			if (!slave_dev)
  				return -ENODEV;
 -			active_slave = slave_dev->name;
  		}
++<<<<<<< HEAD
 +		err = bond_option_active_slave_set(bond, slave_dev);
++=======
+ 		bond_opt_initstr(&newval, active_slave);
+ 		err = __bond_opt_set(bond, BOND_OPT_ACTIVE_SLAVE, &newval);
+ 		if (err)
+ 			return err;
+ 	}
+ 	if (data[IFLA_BOND_MIIMON]) {
+ 		miimon = nla_get_u32(data[IFLA_BOND_MIIMON]);
+ 
+ 		bond_opt_initval(&newval, miimon);
+ 		err = __bond_opt_set(bond, BOND_OPT_MIIMON, &newval);
+ 		if (err)
+ 			return err;
+ 	}
+ 	if (data[IFLA_BOND_UPDELAY]) {
+ 		int updelay = nla_get_u32(data[IFLA_BOND_UPDELAY]);
+ 
+ 		bond_opt_initval(&newval, updelay);
+ 		err = __bond_opt_set(bond, BOND_OPT_UPDELAY, &newval);
+ 		if (err)
+ 			return err;
+ 	}
+ 	if (data[IFLA_BOND_DOWNDELAY]) {
+ 		int downdelay = nla_get_u32(data[IFLA_BOND_DOWNDELAY]);
+ 
+ 		bond_opt_initval(&newval, downdelay);
+ 		err = __bond_opt_set(bond, BOND_OPT_DOWNDELAY, &newval);
+ 		if (err)
+ 			return err;
+ 	}
+ 	if (data[IFLA_BOND_USE_CARRIER]) {
+ 		int use_carrier = nla_get_u8(data[IFLA_BOND_USE_CARRIER]);
+ 
+ 		bond_opt_initval(&newval, use_carrier);
+ 		err = __bond_opt_set(bond, BOND_OPT_USE_CARRIER, &newval);
+ 		if (err)
+ 			return err;
+ 	}
+ 	if (data[IFLA_BOND_ARP_INTERVAL]) {
+ 		int arp_interval = nla_get_u32(data[IFLA_BOND_ARP_INTERVAL]);
+ 
+ 		if (arp_interval && miimon) {
+ 			pr_err("%s: ARP monitoring cannot be used with MII monitoring\n",
+ 			       bond->dev->name);
+ 			return -EINVAL;
+ 		}
+ 
+ 		bond_opt_initval(&newval, arp_interval);
+ 		err = __bond_opt_set(bond, BOND_OPT_ARP_INTERVAL, &newval);
+ 		if (err)
+ 			return err;
+ 	}
+ 	if (data[IFLA_BOND_ARP_IP_TARGET]) {
+ 		struct nlattr *attr;
+ 		int i = 0, rem;
+ 
+ 		bond_option_arp_ip_targets_clear(bond);
+ 		nla_for_each_nested(attr, data[IFLA_BOND_ARP_IP_TARGET], rem) {
+ 			__be32 target = nla_get_be32(attr);
+ 
+ 			bond_opt_initval(&newval, target);
+ 			err = __bond_opt_set(bond, BOND_OPT_ARP_TARGETS,
+ 					     &newval);
+ 			if (err)
+ 				break;
+ 			i++;
+ 		}
+ 		if (i == 0 && bond->params.arp_interval)
+ 			pr_warn("%s: Removing last arp target with arp_interval on\n",
+ 				bond->dev->name);
+ 		if (err)
+ 			return err;
+ 	}
+ 	if (data[IFLA_BOND_ARP_VALIDATE]) {
+ 		int arp_validate = nla_get_u32(data[IFLA_BOND_ARP_VALIDATE]);
+ 
+ 		if (arp_validate && miimon) {
+ 			pr_err("%s: ARP validating cannot be used with MII monitoring\n",
+ 			       bond->dev->name);
+ 			return -EINVAL;
+ 		}
+ 
+ 		bond_opt_initval(&newval, arp_validate);
+ 		err = __bond_opt_set(bond, BOND_OPT_ARP_VALIDATE, &newval);
+ 		if (err)
+ 			return err;
+ 	}
+ 	if (data[IFLA_BOND_ARP_ALL_TARGETS]) {
+ 		int arp_all_targets =
+ 			nla_get_u32(data[IFLA_BOND_ARP_ALL_TARGETS]);
+ 
+ 		bond_opt_initval(&newval, arp_all_targets);
+ 		err = __bond_opt_set(bond, BOND_OPT_ARP_ALL_TARGETS, &newval);
+ 		if (err)
+ 			return err;
+ 	}
+ 	if (data[IFLA_BOND_PRIMARY]) {
+ 		int ifindex = nla_get_u32(data[IFLA_BOND_PRIMARY]);
+ 		struct net_device *dev;
+ 		char *primary = "";
+ 
+ 		dev = __dev_get_by_index(dev_net(bond_dev), ifindex);
+ 		if (dev)
+ 			primary = dev->name;
+ 
+ 		bond_opt_initstr(&newval, primary);
+ 		err = __bond_opt_set(bond, BOND_OPT_PRIMARY, &newval);
+ 		if (err)
+ 			return err;
+ 	}
+ 	if (data[IFLA_BOND_PRIMARY_RESELECT]) {
+ 		int primary_reselect =
+ 			nla_get_u8(data[IFLA_BOND_PRIMARY_RESELECT]);
+ 
+ 		bond_opt_initval(&newval, primary_reselect);
+ 		err = __bond_opt_set(bond, BOND_OPT_PRIMARY_RESELECT, &newval);
+ 		if (err)
+ 			return err;
+ 	}
+ 	if (data[IFLA_BOND_FAIL_OVER_MAC]) {
+ 		int fail_over_mac =
+ 			nla_get_u8(data[IFLA_BOND_FAIL_OVER_MAC]);
+ 
+ 		bond_opt_initval(&newval, fail_over_mac);
+ 		err = __bond_opt_set(bond, BOND_OPT_FAIL_OVER_MAC, &newval);
+ 		if (err)
+ 			return err;
+ 	}
+ 	if (data[IFLA_BOND_XMIT_HASH_POLICY]) {
+ 		int xmit_hash_policy =
+ 			nla_get_u8(data[IFLA_BOND_XMIT_HASH_POLICY]);
+ 
+ 		bond_opt_initval(&newval, xmit_hash_policy);
+ 		err = __bond_opt_set(bond, BOND_OPT_XMIT_HASH, &newval);
+ 		if (err)
+ 			return err;
+ 	}
+ 	if (data[IFLA_BOND_RESEND_IGMP]) {
+ 		int resend_igmp =
+ 			nla_get_u32(data[IFLA_BOND_RESEND_IGMP]);
+ 
+ 		bond_opt_initval(&newval, resend_igmp);
+ 		err = __bond_opt_set(bond, BOND_OPT_RESEND_IGMP, &newval);
+ 		if (err)
+ 			return err;
+ 	}
+ 	if (data[IFLA_BOND_NUM_PEER_NOTIF]) {
+ 		int num_peer_notif =
+ 			nla_get_u8(data[IFLA_BOND_NUM_PEER_NOTIF]);
+ 
+ 		bond_opt_initval(&newval, num_peer_notif);
+ 		err = __bond_opt_set(bond, BOND_OPT_NUM_PEER_NOTIF, &newval);
+ 		if (err)
+ 			return err;
+ 	}
+ 	if (data[IFLA_BOND_ALL_SLAVES_ACTIVE]) {
+ 		int all_slaves_active =
+ 			nla_get_u8(data[IFLA_BOND_ALL_SLAVES_ACTIVE]);
+ 
+ 		bond_opt_initval(&newval, all_slaves_active);
+ 		err = __bond_opt_set(bond, BOND_OPT_ALL_SLAVES_ACTIVE, &newval);
+ 		if (err)
+ 			return err;
+ 	}
+ 	if (data[IFLA_BOND_MIN_LINKS]) {
+ 		int min_links =
+ 			nla_get_u32(data[IFLA_BOND_MIN_LINKS]);
+ 
+ 		bond_opt_initval(&newval, min_links);
+ 		err = __bond_opt_set(bond, BOND_OPT_MINLINKS, &newval);
+ 		if (err)
+ 			return err;
+ 	}
+ 	if (data[IFLA_BOND_LP_INTERVAL]) {
+ 		int lp_interval =
+ 			nla_get_u32(data[IFLA_BOND_LP_INTERVAL]);
+ 
+ 		bond_opt_initval(&newval, lp_interval);
+ 		err = __bond_opt_set(bond, BOND_OPT_LP_INTERVAL, &newval);
+ 		if (err)
+ 			return err;
+ 	}
+ 	if (data[IFLA_BOND_PACKETS_PER_SLAVE]) {
+ 		int packets_per_slave =
+ 			nla_get_u32(data[IFLA_BOND_PACKETS_PER_SLAVE]);
+ 
+ 		bond_opt_initval(&newval, packets_per_slave);
+ 		err = __bond_opt_set(bond, BOND_OPT_PACKETS_PER_SLAVE, &newval);
+ 		if (err)
+ 			return err;
+ 	}
+ 	if (data[IFLA_BOND_AD_LACP_RATE]) {
+ 		int lacp_rate =
+ 			nla_get_u8(data[IFLA_BOND_AD_LACP_RATE]);
+ 
+ 		bond_opt_initval(&newval, lacp_rate);
+ 		err = __bond_opt_set(bond, BOND_OPT_LACP_RATE, &newval);
+ 		if (err)
+ 			return err;
+ 	}
+ 	if (data[IFLA_BOND_AD_SELECT]) {
+ 		int ad_select =
+ 			nla_get_u8(data[IFLA_BOND_AD_SELECT]);
+ 
+ 		bond_opt_initval(&newval, ad_select);
+ 		err = __bond_opt_set(bond, BOND_OPT_AD_SELECT, &newval);
++>>>>>>> 90194264ceff (bonding: Neaten pr_<level>)
  		if (err)
  			return err;
  	}
diff --cc drivers/net/bonding/bond_procfs.c
index 4060d41f0ee7,434df7360999..000000000000
--- a/drivers/net/bonding/bond_procfs.c
+++ b/drivers/net/bonding/bond_procfs.c
@@@ -275,8 -281,8 +275,13 @@@ void __net_init bond_create_proc_dir(st
  	if (!bn->proc_dir) {
  		bn->proc_dir = proc_mkdir(DRV_NAME, bn->net->proc_net);
  		if (!bn->proc_dir)
++<<<<<<< HEAD
 +			pr_warning("Warning: cannot create /proc/net/%s\n",
 +				   DRV_NAME);
++=======
+ 			pr_warn("Warning: Cannot create /proc/net/%s\n",
+ 				DRV_NAME);
++>>>>>>> 90194264ceff (bonding: Neaten pr_<level>)
  	}
  }
  
* Unmerged path drivers/net/bonding/bond_options.c
* Unmerged path drivers/net/bonding/bond_3ad.c
* Unmerged path drivers/net/bonding/bond_main.c
* Unmerged path drivers/net/bonding/bond_netlink.c
* Unmerged path drivers/net/bonding/bond_options.c
* Unmerged path drivers/net/bonding/bond_procfs.c
diff --git a/drivers/net/bonding/bond_sysfs.c b/drivers/net/bonding/bond_sysfs.c
index 9519d678a368..400c59f8e0ae 100644
--- a/drivers/net/bonding/bond_sysfs.c
+++ b/drivers/net/bonding/bond_sysfs.c
@@ -118,9 +118,9 @@ static ssize_t bonding_store_bonds(struct class *cls,
 		rv = bond_create(bn->net, ifname);
 		if (rv) {
 			if (rv == -EEXIST)
-				pr_info("%s already exists.\n", ifname);
+				pr_info("%s already exists\n", ifname);
 			else
-				pr_info("%s creation failed.\n", ifname);
+				pr_info("%s creation failed\n", ifname);
 			res = rv;
 		}
 	} else if (command[0] == '-') {
@@ -145,7 +145,7 @@ static ssize_t bonding_store_bonds(struct class *cls,
 	return res;
 
 err_no_cmd:
-	pr_err("no command found in bonding_masters. Use +ifname or -ifname.\n");
+	pr_err("no command found in bonding_masters - use +ifname or -ifname\n");
 	return -EPERM;
 }
 
@@ -1807,7 +1807,7 @@ int bond_create_sysfs(struct bond_net *bn)
 		/* Is someone being kinky and naming a device bonding_master? */
 		if (__dev_get_by_name(bn->net,
 				      class_attr_bonding_masters.attr.name))
-			pr_err("network device named %s already exists in sysfs",
+			pr_err("network device named %s already exists in sysfs\n",
 			       class_attr_bonding_masters.attr.name);
 		ret = 0;
 	}
