sched, isolcpu: make cpu_isolated_map visible outside scheduler

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [kernel] sched: isolcpu: make cpu_isolated_map visible outside scheduler (Rik van Riel) [1194687]
Rebuild_FUZZ: 98.41%
commit-author Rik van Riel <riel@redhat.com>
commit 3fa0818b3c85e9bb55e3ac96c9523b87e44eab9e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/3fa0818b.failed

Needed by the next patch. Also makes cpu_isolated_map present
when compiled without SMP and/or with CONFIG_NR_CPUS=1, like
the other cpu masks.

At some point we may want to clean things up so cpumasks do
not exist in UP kernels. Maybe something for the CONFIG_TINY
crowd.

	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Clark Williams <williams@redhat.com>
	Cc: Li Zefan <lizefan@huawei.com>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Luiz Capitulino <lcapitulino@redhat.com>
	Cc: David Rientjes <rientjes@google.com>
	Cc: Mike Galbraith <umgwanakikbuti@gmail.com>
	Cc: cgroups@vger.kernel.org
	Signed-off-by: Rik van Riel <riel@redhat.com>
	Acked-by: Zefan Li <lizefan@huawei.com>
	Signed-off-by: Tejun Heo <tj@kernel.org>
(cherry picked from commit 3fa0818b3c85e9bb55e3ac96c9523b87e44eab9e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/core.c
diff --cc kernel/sched/core.c
index 9bae2781b329,b578bb23410b..000000000000
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@@ -314,61 -306,8 +314,66 @@@ __read_mostly int scheduler_running
   */
  int sysctl_sched_rt_runtime = 950000;
  
++<<<<<<< HEAD
 +
 +
 +/*
 + * __task_rq_lock - lock the rq @p resides on.
 + */
 +static inline struct rq *__task_rq_lock(struct task_struct *p)
 +	__acquires(rq->lock)
 +{
 +	struct rq *rq;
 +
 +	lockdep_assert_held(&p->pi_lock);
 +
 +	for (;;) {
 +		rq = task_rq(p);
 +		raw_spin_lock(&rq->lock);
 +		if (likely(rq == task_rq(p)))
 +			return rq;
 +		raw_spin_unlock(&rq->lock);
 +	}
 +}
 +
 +/*
 + * task_rq_lock - lock p->pi_lock and lock the rq @p resides on.
 + */
 +static struct rq *task_rq_lock(struct task_struct *p, unsigned long *flags)
 +	__acquires(p->pi_lock)
 +	__acquires(rq->lock)
 +{
 +	struct rq *rq;
 +
 +	for (;;) {
 +		raw_spin_lock_irqsave(&p->pi_lock, *flags);
 +		rq = task_rq(p);
 +		raw_spin_lock(&rq->lock);
 +		if (likely(rq == task_rq(p)))
 +			return rq;
 +		raw_spin_unlock(&rq->lock);
 +		raw_spin_unlock_irqrestore(&p->pi_lock, *flags);
 +	}
 +}
 +
 +static void __task_rq_unlock(struct rq *rq)
 +	__releases(rq->lock)
 +{
 +	raw_spin_unlock(&rq->lock);
 +}
 +
 +static inline void
 +task_rq_unlock(struct rq *rq, struct task_struct *p, unsigned long *flags)
 +	__releases(rq->lock)
 +	__releases(p->pi_lock)
 +{
 +	raw_spin_unlock(&rq->lock);
 +	raw_spin_unlock_irqrestore(&p->pi_lock, *flags);
 +}
++=======
+ /* cpus with isolated domains */
+ cpumask_var_t cpu_isolated_map;
++>>>>>>> 3fa0818b3c85 (sched, isolcpu: make cpu_isolated_map visible outside scheduler)
  
  /*
   * this_rq_lock - lock this runqueue and disable interrupts.
diff --git a/include/linux/sched.h b/include/linux/sched.h
index c322878af9e6..b61965b86ffe 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -229,6 +229,8 @@ extern asmlinkage void schedule_tail(struct task_struct *prev);
 extern void init_idle(struct task_struct *idle, int cpu);
 extern void init_idle_bootup_task(struct task_struct *idle);
 
+extern cpumask_var_t cpu_isolated_map;
+
 extern int runqueue_is_locked(int cpu);
 
 #if defined(CONFIG_SMP) && defined(CONFIG_NO_HZ_COMMON)
* Unmerged path kernel/sched/core.c
