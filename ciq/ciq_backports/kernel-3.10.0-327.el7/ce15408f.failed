virtio_ccw: legacy: don't negotiate rev 1/features

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [virtio] virtio-ccw: legacy: don't negotiate rev 1/features (Jason Wang) [1227339]
Rebuild_FUZZ: 98.00%
commit-author Michael S. Tsirkin <mst@redhat.com>
commit ce15408f350c4b97635618692a45aedabfdd2696
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/ce15408f.failed

Legacy balloon device doesn't pretend to support revision 1 or 64 bit
features.

But just in case someone implements a broken one that does, let's not
even try to drive legacy only devices using revision 1, and let's not
give them a chance to say they support VIRTIO_F_VERSION_1 by not reading
or writing high feature bits.

	Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
	Reviewed-by: Cornelia Huck <cornelia.huck@de.ibm.com>
(cherry picked from commit ce15408f350c4b97635618692a45aedabfdd2696)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/kvm/virtio_ccw.c
diff --cc drivers/s390/kvm/virtio_ccw.c
index a33210b204e6,c792b5fe0bc9..000000000000
--- a/drivers/s390/kvm/virtio_ccw.c
+++ b/drivers/s390/kvm/virtio_ccw.c
@@@ -733,6 -733,19 +733,22 @@@ static u32 virtio_ccw_get_features(stru
  
  	rc = le32_to_cpu(features->features);
  
++<<<<<<< HEAD
++=======
+ 	if (vcdev->revision == 0)
+ 		goto out_free;
+ 
+ 	/* Read second half of the feature bits from the host. */
+ 	features->index = 1;
+ 	ccw->cmd_code = CCW_CMD_READ_FEAT;
+ 	ccw->flags = 0;
+ 	ccw->count = sizeof(*features);
+ 	ccw->cda = (__u32)(unsigned long)features;
+ 	ret = ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_READ_FEAT);
+ 	if (ret == 0)
+ 		rc |= (u64)le32_to_cpu(features->features) << 32;
+ 
++>>>>>>> ce15408f350c (virtio_ccw: legacy: don't negotiate rev 1/features)
  out_free:
  	kfree(features);
  	kfree(ccw);
@@@ -757,19 -769,27 +773,43 @@@ static void virtio_ccw_finalize_feature
  	/* Give virtio_ring a chance to accept features. */
  	vring_transport_features(vdev);
  
++<<<<<<< HEAD
 +	for (i = 0; i < sizeof(*vdev->features) / sizeof(features->features);
 +	     i++) {
 +		int highbits = i % 2 ? 32 : 0;
 +		features->index = i;
 +		features->features = cpu_to_le32(vdev->features[i / 2]
 +						 >> highbits);
 +		/* Write the feature bits to the host. */
 +		ccw->cmd_code = CCW_CMD_WRITE_FEAT;
 +		ccw->flags = 0;
 +		ccw->count = sizeof(*features);
 +		ccw->cda = (__u32)(unsigned long)features;
 +		ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_WRITE_FEAT);
 +	}
++=======
+ 	features->index = 0;
+ 	features->features = cpu_to_le32((u32)vdev->features);
+ 	/* Write the first half of the feature bits to the host. */
+ 	ccw->cmd_code = CCW_CMD_WRITE_FEAT;
+ 	ccw->flags = 0;
+ 	ccw->count = sizeof(*features);
+ 	ccw->cda = (__u32)(unsigned long)features;
+ 	ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_WRITE_FEAT);
+ 
+ 	if (vcdev->revision == 0)
+ 		goto out_free;
+ 
+ 	features->index = 1;
+ 	features->features = cpu_to_le32(vdev->features >> 32);
+ 	/* Write the second half of the feature bits to the host. */
+ 	ccw->cmd_code = CCW_CMD_WRITE_FEAT;
+ 	ccw->flags = 0;
+ 	ccw->count = sizeof(*features);
+ 	ccw->cda = (__u32)(unsigned long)features;
+ 	ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_WRITE_FEAT);
+ 
++>>>>>>> ce15408f350c (virtio_ccw: legacy: don't negotiate rev 1/features)
  out_free:
  	kfree(features);
  	kfree(ccw);
* Unmerged path drivers/s390/kvm/virtio_ccw.c
