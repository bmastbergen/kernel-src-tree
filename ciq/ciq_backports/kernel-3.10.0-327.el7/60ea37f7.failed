ipv6: reuse rt6_need_strict

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Wang Yufen <wangyufen@huawei.com>
commit 60ea37f7a5c776be4631c535c7cdd3ce62cf4dee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/60ea37f7.failed

Move the whole rt6_need_strict as static inline into ip6_route.h,
so that it can be reused

	Signed-off-by: Wang Yufen <wangyufen@huawei.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 60ea37f7a5c776be4631c535c7cdd3ce62cf4dee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ip6_route.h
diff --cc include/net/ip6_route.h
index 71256172cd6b,3c3bb184eb8f..000000000000
--- a/include/net/ip6_route.h
+++ b/include/net/ip6_route.h
@@@ -51,66 -51,42 +51,74 @@@ static inline unsigned int rt6_flags2sr
  	return (flags >> 3) & 7;
  }
  
++<<<<<<< HEAD
 +extern void rt6_bind_peer(struct rt6_info *rt, int create);
++=======
+ static inline bool rt6_need_strict(const struct in6_addr *daddr)
+ {
+ 	return ipv6_addr_type(daddr) &
+ 		(IPV6_ADDR_MULTICAST | IPV6_ADDR_LINKLOCAL | IPV6_ADDR_LOOPBACK);
+ }
++>>>>>>> 60ea37f7a5c7 (ipv6: reuse rt6_need_strict)
  
 -void ip6_route_input(struct sk_buff *skb);
 +static inline struct inet_peer *__rt6_get_peer(struct rt6_info *rt, int create)
 +{
 +	if (rt6_has_peer(rt))
 +		return rt6_peer_ptr(rt);
 +
 +	rt6_bind_peer(rt, create);
 +	return (rt6_has_peer(rt) ? rt6_peer_ptr(rt) : NULL);
 +}
 +
 +static inline struct inet_peer *rt6_get_peer(struct rt6_info *rt)
 +{
 +	return __rt6_get_peer(rt, 0);
 +}
 +
 +static inline struct inet_peer *rt6_get_peer_create(struct rt6_info *rt)
 +{
 +	return __rt6_get_peer(rt, 1);
 +}
  
 -struct dst_entry *ip6_route_output(struct net *net, const struct sock *sk,
 -				   struct flowi6 *fl6);
 -struct dst_entry *ip6_route_lookup(struct net *net, struct flowi6 *fl6,
 -				   int flags);
 +extern void			ip6_route_input(struct sk_buff *skb);
  
 -int ip6_route_init(void);
 -void ip6_route_cleanup(void);
 +extern struct dst_entry *	ip6_route_output(struct net *net,
 +						 const struct sock *sk,
 +						 struct flowi6 *fl6);
 +extern struct dst_entry *	ip6_route_lookup(struct net *net,
 +						 struct flowi6 *fl6, int flags);
  
 -int ipv6_route_ioctl(struct net *net, unsigned int cmd, void __user *arg);
 +extern int			ip6_route_init(void);
 +extern void			ip6_route_cleanup(void);
  
 -int ip6_route_add(struct fib6_config *cfg);
 -int ip6_ins_rt(struct rt6_info *);
 -int ip6_del_rt(struct rt6_info *);
 +extern int			ipv6_route_ioctl(struct net *net,
 +						 unsigned int cmd,
 +						 void __user *arg);
  
 -int ip6_route_get_saddr(struct net *net, struct rt6_info *rt,
 -			const struct in6_addr *daddr, unsigned int prefs,
 -			struct in6_addr *saddr);
 +extern int			ip6_route_add(struct fib6_config *cfg);
 +extern int			ip6_ins_rt(struct rt6_info *);
 +extern int			ip6_del_rt(struct rt6_info *);
  
 -struct rt6_info *rt6_lookup(struct net *net, const struct in6_addr *daddr,
 -			    const struct in6_addr *saddr, int oif, int flags);
 +extern int			ip6_route_get_saddr(struct net *net,
 +						    struct rt6_info *rt,
 +						    const struct in6_addr *daddr,
 +						    unsigned int prefs,
 +						    struct in6_addr *saddr);
  
 -struct dst_entry *icmp6_dst_alloc(struct net_device *dev, struct flowi6 *fl6);
 -int icmp6_dst_gc(void);
 +extern struct rt6_info		*rt6_lookup(struct net *net,
 +					    const struct in6_addr *daddr,
 +					    const struct in6_addr *saddr,
 +					    int oif, int flags);
  
 -void fib6_force_start_gc(struct net *net);
 +extern struct dst_entry *icmp6_dst_alloc(struct net_device *dev,
 +					 struct flowi6 *fl6);
 +extern int icmp6_dst_gc(void);
  
 -struct rt6_info *addrconf_dst_alloc(struct inet6_dev *idev,
 -				    const struct in6_addr *addr, bool anycast);
 +extern void fib6_force_start_gc(struct net *net);
 +
 +extern struct rt6_info *addrconf_dst_alloc(struct inet6_dev *idev,
 +					   const struct in6_addr *addr,
 +					   bool anycast);
  
  /*
   *	support functions for ND
* Unmerged path include/net/ip6_route.h
diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index 2f320d61d648..37276f012cf8 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -359,12 +359,6 @@ static bool rt6_check_expired(const struct rt6_info *rt)
 	return false;
 }
 
-static bool rt6_need_strict(const struct in6_addr *daddr)
-{
-	return ipv6_addr_type(daddr) &
-		(IPV6_ADDR_MULTICAST | IPV6_ADDR_LINKLOCAL | IPV6_ADDR_LOOPBACK);
-}
-
 /* Multipath route selection:
  *   Hash based function using packet header and flowlabel.
  * Adapted from fib_info_hashfn()
