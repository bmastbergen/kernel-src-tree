userfaultfd: change the read API to return a uffd_msg

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Andrea Arcangeli <aarcange@redhat.com>
commit a9b85f9415fd9e529d03299e5335433f614ec1fb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/a9b85f94.failed

I had requests to return the full address (not the page aligned one) to
userland.

It's not entirely clear how the page offset could be relevant because
userfaults aren't like SIGBUS that can sigjump to a different place and it
actually skip resolving the fault depending on a page offset.  There's
currently no real way to skip the fault especially because after a
UFFDIO_COPY|ZEROPAGE, the fault is optimized to be retried within the
kernel without having to return to userland first (not even self modifying
code replacing the .text that touched the faulting address would prevent
the fault to be repeated).  Userland cannot skip repeating the fault even
more so if the fault was triggered by a KVM secondary page fault or any
get_user_pages or any copy-user inside some syscall which will return to
kernel code.  The second time FAULT_FLAG_RETRY_NOWAIT won't be set leading
to a SIGBUS being raised because the userfault can't wait if it cannot
release the mmap_map first (and FAULT_FLAG_RETRY_NOWAIT is required for
that).

Still returning userland a proper structure during the read() on the uffd,
can allow to use the current UFFD_API for the future non-cooperative
extensions too and it looks cleaner as well.  Once we get additional
fields there's no point to return the fault address page aligned anymore
to reuse the bits below PAGE_SHIFT.

The only downside is that the read() syscall will read 32bytes instead of
8bytes but that's not going to be measurable overhead.

The total number of new events that can be extended or of new future bits
for already shipped events, is limited to 64 by the features field of the
uffdio_api structure.  If more will be needed a bump of UFFD_API will be
required.

[akpm@linux-foundation.org: use __packed]
	Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
	Acked-by: Pavel Emelyanov <xemul@parallels.com>
	Cc: Sanidhya Kashyap <sanidhya.gatech@gmail.com>
	Cc: zhang.zhanghailiang@huawei.com
	Cc: "Kirill A. Shutemov" <kirill@shutemov.name>
	Cc: Andres Lagar-Cavilla <andreslc@google.com>
	Cc: Dave Hansen <dave.hansen@intel.com>
	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Mel Gorman <mgorman@suse.de>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: Peter Feiner <pfeiner@google.com>
	Cc: "Dr. David Alan Gilbert" <dgilbert@redhat.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: "Huangpeng (Peter)" <peter.huangpeng@huawei.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit a9b85f9415fd9e529d03299e5335433f614ec1fb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/userfaultfd.c
#	include/uapi/linux/userfaultfd.h
diff --cc fs/userfaultfd.c
index 9bc256d1a143,1f2ddaaf3c03..000000000000
--- a/fs/userfaultfd.c
+++ b/fs/userfaultfd.c
@@@ -883,8 -897,7 +897,12 @@@ static int userfaultfd_api(struct userf
  		ret = -EINVAL;
  		goto out;
  	}
++<<<<<<< HEAD
 +	/* careful not to leak info, we only read the first 8 bytes */
 +	uffdio_api.bits = UFFD_API_BITS;
++=======
+ 	uffdio_api.features = UFFD_API_FEATURES;
++>>>>>>> a9b85f9415fd (userfaultfd: change the read API to return a uffd_msg)
  	uffdio_api.ioctls = UFFD_API_IOCTLS;
  	ret = -EFAULT;
  	if (copy_to_user(buf, &uffdio_api, sizeof(uffdio_api)))
* Unmerged path include/uapi/linux/userfaultfd.h
diff --git a/Documentation/vm/userfaultfd.txt b/Documentation/vm/userfaultfd.txt
index 90912925425e..70a3c94d1941 100644
--- a/Documentation/vm/userfaultfd.txt
+++ b/Documentation/vm/userfaultfd.txt
@@ -46,11 +46,13 @@ is a corner case that would currently return -EBUSY).
 When first opened the userfaultfd must be enabled invoking the
 UFFDIO_API ioctl specifying a uffdio_api.api value set to UFFD_API (or
 a later API version) which will specify the read/POLLIN protocol
-userland intends to speak on the UFFD. The UFFDIO_API ioctl if
-successful (i.e. if the requested uffdio_api.api is spoken also by the
-running kernel), will return into uffdio_api.features and
-uffdio_api.ioctls two 64bit bitmasks of respectively the activated
-feature of the read(2) protocol and the generic ioctl available.
+userland intends to speak on the UFFD and the uffdio_api.features
+userland requires. The UFFDIO_API ioctl if successful (i.e. if the
+requested uffdio_api.api is spoken also by the running kernel and the
+requested features are going to be enabled) will return into
+uffdio_api.features and uffdio_api.ioctls two 64bit bitmasks of
+respectively all the available features of the read(2) protocol and
+the generic ioctl available.
 
 Once the userfaultfd has been enabled the UFFDIO_REGISTER ioctl should
 be invoked (if present in the returned uffdio_api.ioctls bitmask) to
* Unmerged path fs/userfaultfd.c
* Unmerged path include/uapi/linux/userfaultfd.h
