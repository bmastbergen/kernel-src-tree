time: Change the return type of clockevents_notify() to integer

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Preeti U Murthy <preeti@linux.vnet.ibm.com>
commit da7e6f45c34d39186b72328bacc4dd86bff60e0a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/da7e6f45.failed

The broadcast framework can potentially be made use of by archs which do not have an
external clock device as well. Then, it is required that one of the CPUs need
to handle the broadcasting of wakeup IPIs to the CPUs in deep idle. As a
result its local timers should remain functional all the time. For such
a CPU, the BROADCAST_ENTER notification has to fail indicating that its clock
device cannot be shutdown. To make way for this support, change the return
type of tick_broadcast_oneshot_control() and hence clockevents_notify() to
indicate such scenarios.

	Signed-off-by: Preeti U Murthy <preeti@linux.vnet.ibm.com>
	Cc: deepthi@linux.vnet.ibm.com
	Cc: paulmck@linux.vnet.ibm.com
	Cc: fweisbec@gmail.com
	Cc: paulus@samba.org
	Cc: srivatsa.bhat@linux.vnet.ibm.com
	Cc: svaidy@linux.vnet.ibm.com
	Cc: peterz@infradead.org
	Cc: benh@kernel.crashing.org
	Cc: rafael.j.wysocki@intel.com
	Cc: linuxppc-dev@lists.ozlabs.org
Link: http://lkml.kernel.org/r/20140207080606.17187.78306.stgit@preeti.in.ibm.com
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit da7e6f45c34d39186b72328bacc4dd86bff60e0a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/time/clockevents.c
diff --cc kernel/time/clockevents.c
index 9df0e3b19f09,ad362c260ef4..000000000000
--- a/kernel/time/clockevents.c
+++ b/kernel/time/clockevents.c
@@@ -437,13 -548,39 +438,40 @@@ int clockevents_notify(unsigned long re
  {
  	struct clock_event_device *dev, *tmp;
  	unsigned long flags;
- 	int cpu;
+ 	int cpu, ret = 0;
  
  	raw_spin_lock_irqsave(&clockevents_lock, flags);
 +	tick_notify(reason, arg);
  
  	switch (reason) {
++<<<<<<< HEAD
++=======
+ 	case CLOCK_EVT_NOTIFY_BROADCAST_ON:
+ 	case CLOCK_EVT_NOTIFY_BROADCAST_OFF:
+ 	case CLOCK_EVT_NOTIFY_BROADCAST_FORCE:
+ 		tick_broadcast_on_off(reason, arg);
+ 		break;
+ 
+ 	case CLOCK_EVT_NOTIFY_BROADCAST_ENTER:
+ 	case CLOCK_EVT_NOTIFY_BROADCAST_EXIT:
+ 		ret = tick_broadcast_oneshot_control(reason);
+ 		break;
+ 
+ 	case CLOCK_EVT_NOTIFY_CPU_DYING:
+ 		tick_handover_do_timer(arg);
+ 		break;
+ 
+ 	case CLOCK_EVT_NOTIFY_SUSPEND:
+ 		tick_suspend();
+ 		tick_suspend_broadcast();
+ 		break;
+ 
+ 	case CLOCK_EVT_NOTIFY_RESUME:
+ 		tick_resume();
+ 		break;
+ 
++>>>>>>> da7e6f45c34d (time: Change the return type of clockevents_notify() to integer)
  	case CLOCK_EVT_NOTIFY_CPU_DEAD:
 -		tick_shutdown_broadcast_oneshot(arg);
 -		tick_shutdown_broadcast(arg);
 -		tick_shutdown(arg);
  		/*
  		 * Unregister the clock event devices which were
  		 * released from the users in the notify chain.
@@@ -467,6 -604,126 +495,7 @@@
  		break;
  	}
  	raw_spin_unlock_irqrestore(&clockevents_lock, flags);
+ 	return ret;
  }
  EXPORT_SYMBOL_GPL(clockevents_notify);
 -
 -#ifdef CONFIG_SYSFS
 -struct bus_type clockevents_subsys = {
 -	.name		= "clockevents",
 -	.dev_name       = "clockevent",
 -};
 -
 -static DEFINE_PER_CPU(struct device, tick_percpu_dev);
 -static struct tick_device *tick_get_tick_dev(struct device *dev);
 -
 -static ssize_t sysfs_show_current_tick_dev(struct device *dev,
 -					   struct device_attribute *attr,
 -					   char *buf)
 -{
 -	struct tick_device *td;
 -	ssize_t count = 0;
 -
 -	raw_spin_lock_irq(&clockevents_lock);
 -	td = tick_get_tick_dev(dev);
 -	if (td && td->evtdev)
 -		count = snprintf(buf, PAGE_SIZE, "%s\n", td->evtdev->name);
 -	raw_spin_unlock_irq(&clockevents_lock);
 -	return count;
 -}
 -static DEVICE_ATTR(current_device, 0444, sysfs_show_current_tick_dev, NULL);
 -
 -/* We don't support the abomination of removable broadcast devices */
 -static ssize_t sysfs_unbind_tick_dev(struct device *dev,
 -				     struct device_attribute *attr,
 -				     const char *buf, size_t count)
 -{
 -	char name[CS_NAME_LEN];
 -	ssize_t ret = sysfs_get_uname(buf, name, count);
 -	struct clock_event_device *ce;
 -
 -	if (ret < 0)
 -		return ret;
 -
 -	ret = -ENODEV;
 -	mutex_lock(&clockevents_mutex);
 -	raw_spin_lock_irq(&clockevents_lock);
 -	list_for_each_entry(ce, &clockevent_devices, list) {
 -		if (!strcmp(ce->name, name)) {
 -			ret = __clockevents_try_unbind(ce, dev->id);
 -			break;
 -		}
 -	}
 -	raw_spin_unlock_irq(&clockevents_lock);
 -	/*
 -	 * We hold clockevents_mutex, so ce can't go away
 -	 */
 -	if (ret == -EAGAIN)
 -		ret = clockevents_unbind(ce, dev->id);
 -	mutex_unlock(&clockevents_mutex);
 -	return ret ? ret : count;
 -}
 -static DEVICE_ATTR(unbind_device, 0200, NULL, sysfs_unbind_tick_dev);
 -
 -#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST
 -static struct device tick_bc_dev = {
 -	.init_name	= "broadcast",
 -	.id		= 0,
 -	.bus		= &clockevents_subsys,
 -};
 -
 -static struct tick_device *tick_get_tick_dev(struct device *dev)
 -{
 -	return dev == &tick_bc_dev ? tick_get_broadcast_device() :
 -		&per_cpu(tick_cpu_device, dev->id);
 -}
 -
 -static __init int tick_broadcast_init_sysfs(void)
 -{
 -	int err = device_register(&tick_bc_dev);
 -
 -	if (!err)
 -		err = device_create_file(&tick_bc_dev, &dev_attr_current_device);
 -	return err;
 -}
 -#else
 -static struct tick_device *tick_get_tick_dev(struct device *dev)
 -{
 -	return &per_cpu(tick_cpu_device, dev->id);
 -}
 -static inline int tick_broadcast_init_sysfs(void) { return 0; }
  #endif
 -
 -static int __init tick_init_sysfs(void)
 -{
 -	int cpu;
 -
 -	for_each_possible_cpu(cpu) {
 -		struct device *dev = &per_cpu(tick_percpu_dev, cpu);
 -		int err;
 -
 -		dev->id = cpu;
 -		dev->bus = &clockevents_subsys;
 -		err = device_register(dev);
 -		if (!err)
 -			err = device_create_file(dev, &dev_attr_current_device);
 -		if (!err)
 -			err = device_create_file(dev, &dev_attr_unbind_device);
 -		if (err)
 -			return err;
 -	}
 -	return tick_broadcast_init_sysfs();
 -}
 -
 -static int __init clockevents_init_sysfs(void)
 -{
 -	int err = subsys_system_register(&clockevents_subsys, NULL);
 -
 -	if (!err)
 -		err = tick_init_sysfs();
 -	return err;
 -}
 -device_initcall(clockevents_init_sysfs);
 -#endif /* SYSFS */
 -
 -#endif /* GENERIC_CLOCK_EVENTS */
diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index ae1193bcf074..4bea00d7ff5f 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -184,9 +184,9 @@ static inline int tick_check_broadcast_expired(void) { return 0; }
 #endif
 
 #ifdef CONFIG_GENERIC_CLOCKEVENTS
-extern void clockevents_notify(unsigned long reason, void *arg);
+extern int clockevents_notify(unsigned long reason, void *arg);
 #else
-static inline void clockevents_notify(unsigned long reason, void *arg) {}
+static inline int clockevents_notify(unsigned long reason, void *arg) { return 0; }
 #endif
 
 #else /* CONFIG_GENERIC_CLOCKEVENTS_BUILD */
@@ -194,7 +194,7 @@ static inline void clockevents_notify(unsigned long reason, void *arg) {}
 static inline void clockevents_suspend(void) {}
 static inline void clockevents_resume(void) {}
 
-static inline void clockevents_notify(unsigned long reason, void *arg) {}
+static inline int clockevents_notify(unsigned long reason, void *arg) { return 0; }
 static inline int tick_check_broadcast_expired(void) { return 0; }
 
 #endif
* Unmerged path kernel/time/clockevents.c
diff --git a/kernel/time/tick-broadcast.c b/kernel/time/tick-broadcast.c
index 19ee339a1d0d..419afff46b89 100644
--- a/kernel/time/tick-broadcast.c
+++ b/kernel/time/tick-broadcast.c
@@ -629,14 +629,15 @@ again:
 /*
  * Powerstate information: The system enters/leaves a state, where
  * affected devices might stop
+ * Returns 0 on success, -EBUSY if the cpu is used to broadcast wakeups.
  */
-void tick_broadcast_oneshot_control(unsigned long reason)
+int tick_broadcast_oneshot_control(unsigned long reason)
 {
 	struct clock_event_device *bc, *dev;
 	struct tick_device *td;
 	unsigned long flags;
 	ktime_t now;
-	int cpu;
+	int cpu, ret = 0;
 
 	/*
 	 * Periodic mode does not care about the enter/exit of power
@@ -742,6 +743,7 @@ void tick_broadcast_oneshot_control(unsigned long reason)
 	}
 out:
 	raw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);
+	return ret;
 }
 
 /*
diff --git a/kernel/time/tick-internal.h b/kernel/time/tick-internal.h
index 60742fe6f63d..527dc4413d77 100644
--- a/kernel/time/tick-internal.h
+++ b/kernel/time/tick-internal.h
@@ -36,7 +36,7 @@ extern int tick_switch_to_oneshot(void (*handler)(struct clock_event_device *));
 extern void tick_resume_oneshot(void);
 # ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST
 extern void tick_broadcast_setup_oneshot(struct clock_event_device *bc);
-extern void tick_broadcast_oneshot_control(unsigned long reason);
+extern int tick_broadcast_oneshot_control(unsigned long reason);
 extern void tick_broadcast_switch_to_oneshot(void);
 extern void tick_shutdown_broadcast_oneshot(unsigned int *cpup);
 extern int tick_resume_broadcast_oneshot(struct clock_event_device *bc);
@@ -48,7 +48,7 @@ static inline void tick_broadcast_setup_oneshot(struct clock_event_device *bc)
 {
 	BUG();
 }
-static inline void tick_broadcast_oneshot_control(unsigned long reason) { }
+static inline int tick_broadcast_oneshot_control(unsigned long reason) { return 0; }
 static inline void tick_broadcast_switch_to_oneshot(void) { }
 static inline void tick_shutdown_broadcast_oneshot(unsigned int *cpup) { }
 static inline int tick_broadcast_oneshot_active(void) { return 0; }
@@ -77,7 +77,7 @@ static inline void tick_broadcast_setup_oneshot(struct clock_event_device *bc)
 {
 	BUG();
 }
-static inline void tick_broadcast_oneshot_control(unsigned long reason) { }
+static inline int tick_broadcast_oneshot_control(unsigned long reason) { return 0; }
 static inline void tick_shutdown_broadcast_oneshot(unsigned int *cpup) { }
 static inline int tick_resume_broadcast_oneshot(struct clock_event_device *bc)
 {
