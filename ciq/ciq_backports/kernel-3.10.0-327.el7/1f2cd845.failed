Revert "Merge branch 'bonding_monitor_locking'"

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author David S. Miller <davem@davemloft.net>
commit 1f2cd845d3827412e82bf26dde0abca332ede402
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/1f2cd845.failed

This reverts commit 4d961a101e032b4bf223b279b4b35bc77576f5a8, reversing
changes made to a00f6fcc7d0c62a91768d9c4ccba4c7d64fbbce3.

Revert bond locking changes, they cause regressions and Veaceslav Falico
doesn't like how the commit messages were done at all.

	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1f2cd845d3827412e82bf26dde0abca332ede402)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
diff --cc drivers/net/bonding/bond_main.c
index f2744db511b6,a141f406cb98..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -2396,7 -2124,7 +2396,11 @@@ void bond_mii_monitor(struct work_struc
  
  	delay = msecs_to_jiffies(bond->params.miimon);
  
++<<<<<<< HEAD
 +	if (bond->slave_cnt == 0)
++=======
+ 	if (!bond_has_slaves(bond))
++>>>>>>> 1f2cd845d382 (Revert "Merge branch 'bonding_monitor_locking'")
  		goto re_arm;
  
  	should_notify_peers = bond_should_notify_peers(bond);
@@@ -2675,10 -2418,7 +2679,14 @@@ void bond_loadbalance_arp_mon(struct wo
  
  	read_lock(&bond->lock);
  
++<<<<<<< HEAD
 +	delta_in_ticks = msecs_to_jiffies(bond->params.arp_interval);
 +	extra_ticks = delta_in_ticks / 2;
 +
 +	if (bond->slave_cnt == 0)
++=======
+ 	if (!bond_has_slaves(bond))
++>>>>>>> 1f2cd845d382 (Revert "Merge branch 'bonding_monitor_locking'")
  		goto re_arm;
  
  	oldcurrent = bond->curr_active_slave;
@@@ -2772,7 -2504,8 +2780,12 @@@
  
  re_arm:
  	if (bond->params.arp_interval)
++<<<<<<< HEAD
 +		queue_delayed_work(bond->wq, &bond->arp_work, delta_in_ticks);
++=======
+ 		queue_delayed_work(bond->wq, &bond->arp_work,
+ 				   msecs_to_jiffies(bond->params.arp_interval));
++>>>>>>> 1f2cd845d382 (Revert "Merge branch 'bonding_monitor_locking'")
  
  	read_unlock(&bond->lock);
  }
@@@ -3028,12 -2750,12 +3041,20 @@@ void bond_activebackup_arp_mon(struct w
  
  	delta_in_ticks = msecs_to_jiffies(bond->params.arp_interval);
  
++<<<<<<< HEAD
 +	if (bond->slave_cnt == 0)
++=======
+ 	if (!bond_has_slaves(bond))
++>>>>>>> 1f2cd845d382 (Revert "Merge branch 'bonding_monitor_locking'")
  		goto re_arm;
  
  	should_notify_peers = bond_should_notify_peers(bond);
  
++<<<<<<< HEAD
 +	if (bond_ab_arp_inspect(bond, delta_in_ticks)) {
++=======
+ 	if (bond_ab_arp_inspect(bond)) {
++>>>>>>> 1f2cd845d382 (Revert "Merge branch 'bonding_monitor_locking'")
  		read_unlock(&bond->lock);
  
  		/* Race avoidance with bond_close flush of workqueue */
@@@ -3046,12 -2768,12 +3067,21 @@@
  
  		read_lock(&bond->lock);
  
++<<<<<<< HEAD
 +		bond_ab_arp_commit(bond, delta_in_ticks);
 +
 +		read_unlock(&bond->lock);
 +		rtnl_unlock();
 +		read_lock(&bond->lock);
 +	}
++=======
+ 		bond_ab_arp_commit(bond);
++>>>>>>> 1f2cd845d382 (Revert "Merge branch 'bonding_monitor_locking'")
+ 
+ 		read_unlock(&bond->lock);
+ 		rtnl_unlock();
+ 		read_lock(&bond->lock);
+ 	}
  
  	bond_ab_arp_probe(bond);
  
diff --git a/drivers/net/bonding/bond_3ad.c b/drivers/net/bonding/bond_3ad.c
index e5814f7909df..466dba240756 100644
--- a/drivers/net/bonding/bond_3ad.c
+++ b/drivers/net/bonding/bond_3ad.c
@@ -2116,10 +2116,8 @@ void bond_3ad_state_machine_handler(struct work_struct *work)
 	struct port *port;
 	struct aggregator *aggregator;
 
-	if (!rtnl_trylock()) {
-		queue_delayed_work(bond->wq, &bond->ad_work, ad_delta_in_ticks);
-		return;
-	}
+	read_lock(&bond->lock);
+
 	//check if there are any slaves
 	if (bond->slave_cnt == 0)
 		goto re_arm;
@@ -2168,8 +2166,9 @@ void bond_3ad_state_machine_handler(struct work_struct *work)
 	}
 
 re_arm:
-	rtnl_unlock();
 	queue_delayed_work(bond->wq, &bond->ad_work, ad_delta_in_ticks);
+
+	read_unlock(&bond->lock);
 }
 
 /**
diff --git a/drivers/net/bonding/bond_alb.c b/drivers/net/bonding/bond_alb.c
index a54135a9a9f3..b7563cd17726 100644
--- a/drivers/net/bonding/bond_alb.c
+++ b/drivers/net/bonding/bond_alb.c
@@ -1464,13 +1464,11 @@ void bond_alb_monitor(struct work_struct *work)
 	struct slave *slave;
 	int i;
 
-	if (!rtnl_trylock())
-		goto re_arm;
+	read_lock(&bond->lock);
 
 	if (bond->slave_cnt == 0) {
 		bond_info->tx_rebalance_counter = 0;
 		bond_info->lp_counter = 0;
-		rtnl_unlock();
 		goto re_arm;
 	}
 
@@ -1520,6 +1518,16 @@ void bond_alb_monitor(struct work_struct *work)
 		if (bond_info->primary_is_promisc &&
 		    (++bond_info->rlb_promisc_timeout_counter >= RLB_PROMISC_TIMEOUT)) {
 
+			/*
+			 * dev_set_promiscuity requires rtnl and
+			 * nothing else.  Avoid race with bond_close.
+			 */
+			read_unlock(&bond->lock);
+			if (!rtnl_trylock()) {
+				read_lock(&bond->lock);
+				goto re_arm;
+			}
+
 			bond_info->rlb_promisc_timeout_counter = 0;
 
 			/* If the primary was set to promiscuous mode
@@ -1528,6 +1536,9 @@ void bond_alb_monitor(struct work_struct *work)
 			 */
 			dev_set_promiscuity(bond->curr_active_slave->dev, -1);
 			bond_info->primary_is_promisc = 0;
+
+			rtnl_unlock();
+			read_lock(&bond->lock);
 		}
 
 		if (bond_info->rlb_rebalance) {
@@ -1550,9 +1561,10 @@ void bond_alb_monitor(struct work_struct *work)
 		}
 	}
 
-	rtnl_unlock();
 re_arm:
 	queue_delayed_work(bond->wq, &bond->alb_work, alb_delta_in_ticks);
+
+	read_unlock(&bond->lock);
 }
 
 /* assumption: called before the slave is attached to the bond
* Unmerged path drivers/net/bonding/bond_main.c
