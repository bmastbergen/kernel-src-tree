perf ordered_events: Shorten function signatures

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [perf] ordered_events: Shorten function signatures (Jiri Olsa) [1222189]
Rebuild_FUZZ: 94.51%
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit b7b61cbebd789a3dbca522e3fdb727fe5c95593f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/b7b61cbe.failed

By keeping pointers to machines, evlist and tool in ordered_events.

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Borislav Petkov <bp@suse.de>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Don Zickus <dzickus@redhat.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Stephane Eranian <eranian@google.com>
Link: http://lkml.kernel.org/n/tip-0c6huyaf59mqtm2ek9pmposl@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit b7b61cbebd789a3dbca522e3fdb727fe5c95593f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-kvm.c
#	tools/perf/util/data-convert-bt.c
#	tools/perf/util/ordered-events.c
#	tools/perf/util/ordered-events.h
#	tools/perf/util/session.c
#	tools/perf/util/session.h
diff --cc tools/perf/builtin-kvm.c
index eb4f3837f938,802b8f53fa9a..000000000000
--- a/tools/perf/builtin-kvm.c
+++ b/tools/perf/builtin-kvm.c
@@@ -689,9 -730,9 +689,13 @@@ static s64 perf_kvm__mmap_read_idx(stru
  			return -1;
  		}
  
++<<<<<<< HEAD
 +		err = perf_session_queue_event(kvm->session, event, &sample, 0);
++=======
+ 		err = perf_session__queue_event(kvm->session, event, &sample, 0);
++>>>>>>> b7b61cbebd78 (perf ordered_events: Shorten function signatures)
  		/*
- 		 * FIXME: Here we can't consume the event, as perf_session_queue_event will
+ 		 * FIXME: Here we can't consume the event, as perf_session__queue_event will
  		 *        point to it, and it'll get possibly overwritten by the kernel.
  		 */
  		perf_evlist__mmap_consume(kvm->evlist, idx);
diff --cc tools/perf/util/session.c
index 647c690afe48,c6dd89f62fc4..000000000000
--- a/tools/perf/util/session.c
+++ b/tools/perf/util/session.c
@@@ -94,9 -95,6 +94,12 @@@ struct perf_session *perf_session__new(
  		goto out;
  
  	session->repipe = repipe;
++<<<<<<< HEAD
 +	INIT_LIST_HEAD(&session->ordered_events.events);
 +	INIT_LIST_HEAD(&session->ordered_events.cache);
 +	INIT_LIST_HEAD(&session->ordered_events.to_free);
++=======
++>>>>>>> b7b61cbebd78 (perf ordered_events: Shorten function signatures)
  	machines__init(&session->machines);
  
  	if (file) {
@@@ -623,107 -512,104 +627,126 @@@ static int process_finished_round(struc
  				  union perf_event *event __maybe_unused,
  				  struct perf_session *session)
  {
++<<<<<<< HEAD
 +	return ordered_events__flush(session, tool, OE_FLUSH__ROUND);
 +}
 +
 +/* The queue is ordered by time */
 +static void __queue_event(struct ordered_event *new, struct perf_session *s)
 +{
 +	struct ordered_events *oe = &s->ordered_events;
 +	struct ordered_event *last = oe->last;
 +	u64 timestamp = new->timestamp;
 +	struct list_head *p;
++=======
+ 	struct ordered_events *oe = &session->ordered_events;
+ 
+ 	return ordered_events__flush(oe, OE_FLUSH__ROUND);
+ }
+ 
+ int perf_session__queue_event(struct perf_session *s, union perf_event *event,
+ 			      struct perf_sample *sample, u64 file_offset)
+ {
+ 	struct ordered_events *oe = &s->ordered_events;
++>>>>>>> b7b61cbebd78 (perf ordered_events: Shorten function signatures)
 +
 +	++oe->nr_events;
 +	oe->last = new;
 +
 +	if (!last) {
 +		list_add(&new->list, &oe->events);
 +		oe->max_timestamp = timestamp;
 +		return;
 +	}
 +
 +	/*
 +	 * last event might point to some random place in the list as it's
 +	 * the last queued event. We expect that the new event is close to
 +	 * this.
 +	 */
 +	if (last->timestamp <= timestamp) {
 +		while (last->timestamp <= timestamp) {
 +			p = last->list.next;
 +			if (p == &oe->events) {
 +				list_add_tail(&new->list, &oe->events);
 +				oe->max_timestamp = timestamp;
 +				return;
 +			}
 +			last = list_entry(p, struct ordered_event, list);
 +		}
 +		list_add_tail(&new->list, &last->list);
 +	} else {
 +		while (last->timestamp > timestamp) {
 +			p = last->list.prev;
 +			if (p == &oe->events) {
 +				list_add(&new->list, &oe->events);
 +				return;
 +			}
 +			last = list_entry(p, struct ordered_event, list);
 +		}
 +		list_add(&new->list, &last->list);
 +	}
 +}
  
 +#define MAX_SAMPLE_BUFFER	(64 * 1024 / sizeof(struct ordered_event))
 +
 +int perf_session_queue_event(struct perf_session *s, union perf_event *event,
 +				    struct perf_sample *sample, u64 file_offset)
 +{
 +	struct ordered_events *oe = &s->ordered_events;
 +	struct list_head *cache = &oe->cache;
  	u64 timestamp = sample->time;
  	struct ordered_event *new;
  
  	if (!timestamp || timestamp == ~0ULL)
  		return -ETIME;
  
 -	if (timestamp < oe->last_flush) {
 -		pr_oe_time(timestamp,      "out of order event\n");
 -		pr_oe_time(oe->last_flush, "last flush, last_flush_type %d\n",
 -			   oe->last_flush_type);
 -
 -		s->evlist->stats.nr_unordered_events++;
 +	if (timestamp < s->ordered_events.last_flush) {
 +		printf("Warning: Timestamp below last timeslice flush\n");
 +		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	if (!list_empty(cache)) {
 +		new = list_entry(cache->next, struct ordered_event, list);
 +		list_del(&new->list);
 +	} else if (oe->buffer) {
 +		new = oe->buffer + oe->buffer_idx;
 +		if (++oe->buffer_idx == MAX_SAMPLE_BUFFER)
 +			oe->buffer = NULL;
 +	} else {
 +		oe->buffer = malloc(MAX_SAMPLE_BUFFER * sizeof(*new));
 +		if (!oe->buffer)
 +			return -ENOMEM;
 +		list_add(&oe->buffer->list, &oe->to_free);
 +		oe->buffer_idx = 2;
 +		new = oe->buffer + 1;
++=======
+ 	new = ordered_events__new(oe, timestamp, event);
+ 	if (!new) {
+ 		ordered_events__flush(oe, OE_FLUSH__HALF);
+ 		new = ordered_events__new(oe, timestamp, event);
++>>>>>>> b7b61cbebd78 (perf ordered_events: Shorten function signatures)
  	}
  
 -	if (!new)
 -		return -ENOMEM;
 -
 +	new->timestamp = timestamp;
  	new->file_offset = file_offset;
 -	return 0;
 -}
 -
 -static void callchain__lbr_callstack_printf(struct perf_sample *sample)
 -{
 -	struct ip_callchain *callchain = sample->callchain;
 -	struct branch_stack *lbr_stack = sample->branch_stack;
 -	u64 kernel_callchain_nr = callchain->nr;
 -	unsigned int i;
 -
 -	for (i = 0; i < kernel_callchain_nr; i++) {
 -		if (callchain->ips[i] == PERF_CONTEXT_USER)
 -			break;
 -	}
 -
 -	if ((i != kernel_callchain_nr) && lbr_stack->nr) {
 -		u64 total_nr;
 -		/*
 -		 * LBR callstack can only get user call chain,
 -		 * i is kernel call chain number,
 -		 * 1 is PERF_CONTEXT_USER.
 -		 *
 -		 * The user call chain is stored in LBR registers.
 -		 * LBR are pair registers. The caller is stored
 -		 * in "from" register, while the callee is stored
 -		 * in "to" register.
 -		 * For example, there is a call stack
 -		 * "A"->"B"->"C"->"D".
 -		 * The LBR registers will recorde like
 -		 * "C"->"D", "B"->"C", "A"->"B".
 -		 * So only the first "to" register and all "from"
 -		 * registers are needed to construct the whole stack.
 -		 */
 -		total_nr = i + 1 + lbr_stack->nr + 1;
 -		kernel_callchain_nr = i + 1;
 +	new->event = event;
  
 -		printf("... LBR call chain: nr:%" PRIu64 "\n", total_nr);
 +	__queue_event(new, s);
  
 -		for (i = 0; i < kernel_callchain_nr; i++)
 -			printf("..... %2d: %016" PRIx64 "\n",
 -			       i, callchain->ips[i]);
 -
 -		printf("..... %2d: %016" PRIx64 "\n",
 -		       (int)(kernel_callchain_nr), lbr_stack->entries[0].to);
 -		for (i = 0; i < lbr_stack->nr; i++)
 -			printf("..... %2d: %016" PRIx64 "\n",
 -			       (int)(i + kernel_callchain_nr + 1), lbr_stack->entries[i].from);
 -	}
 +	return 0;
  }
  
 -static void callchain__printf(struct perf_evsel *evsel,
 -			      struct perf_sample *sample)
 +static void callchain__printf(struct perf_sample *sample)
  {
  	unsigned int i;
 -	struct ip_callchain *callchain = sample->callchain;
 -
 -	if (has_branch_callstack(evsel))
 -		callchain__lbr_callstack_printf(sample);
  
 -	printf("... FP chain: nr:%" PRIu64 "\n", callchain->nr);
 +	printf("... chain: nr:%" PRIu64 "\n", sample->callchain->nr);
  
 -	for (i = 0; i < callchain->nr; i++)
 +	for (i = 0; i < sample->callchain->nr; i++)
  		printf("..... %2d: %016" PRIx64 "\n",
 -		       i, callchain->ips[i]);
 +		       i, sample->callchain->ips[i]);
  }
  
  static void branch_stack__printf(struct perf_sample *sample)
@@@ -1099,15 -983,17 +1122,21 @@@ static s64 perf_session__process_user_e
  
  int perf_session__deliver_synth_event(struct perf_session *session,
  				      union perf_event *event,
- 				      struct perf_sample *sample,
- 				      struct perf_tool *tool)
+ 				      struct perf_sample *sample)
  {
++<<<<<<< HEAD
 +	events_stats__inc(&session->stats, event->header.type);
++=======
+ 	struct perf_evlist *evlist = session->evlist;
+ 	struct perf_tool *tool = session->ordered_events.tool;
+ 
+ 	events_stats__inc(&evlist->stats, event->header.type);
++>>>>>>> b7b61cbebd78 (perf ordered_events: Shorten function signatures)
  
  	if (event->header.type >= PERF_RECORD_USER_TYPE_START)
- 		return perf_session__process_user_event(session, event, tool, 0);
+ 		return perf_session__process_user_event(session, event, 0);
  
 -	return machines__deliver_event(&session->machines, evlist, event, sample, tool, 0);
 +	return perf_session__deliver_event(session, event, sample, tool, 0);
  }
  
  static void event_swap(union perf_event *event, bool sample_id_all)
@@@ -1175,10 -1061,10 +1204,13 @@@ out_parse_sample
  }
  
  static s64 perf_session__process_event(struct perf_session *session,
- 				       union perf_event *event,
- 				       struct perf_tool *tool,
- 				       u64 file_offset)
+ 				       union perf_event *event, u64 file_offset)
  {
++<<<<<<< HEAD
++=======
+ 	struct perf_evlist *evlist = session->evlist;
+ 	struct perf_tool *tool = session->ordered_events.tool;
++>>>>>>> b7b61cbebd78 (perf ordered_events: Shorten function signatures)
  	struct perf_sample sample;
  	int ret;
  
@@@ -1188,10 -1074,10 +1220,10 @@@
  	if (event->header.type >= PERF_RECORD_HEADER_MAX)
  		return -EINVAL;
  
 -	events_stats__inc(&evlist->stats, event->header.type);
 +	events_stats__inc(&session->stats, event->header.type);
  
  	if (event->header.type >= PERF_RECORD_USER_TYPE_START)
- 		return perf_session__process_user_event(session, event, tool, file_offset);
+ 		return perf_session__process_user_event(session, event, file_offset);
  
  	/*
  	 * For all kernel events we get the sample data
@@@ -1201,8 -1087,7 +1233,12 @@@
  		return ret;
  
  	if (tool->ordered_events) {
++<<<<<<< HEAD
 +		ret = perf_session_queue_event(session, event, &sample,
 +					       file_offset);
++=======
+ 		ret = perf_session__queue_event(session, event, &sample, file_offset);
++>>>>>>> b7b61cbebd78 (perf ordered_events: Shorten function signatures)
  		if (ret != -ETIME)
  			return ret;
  	}
@@@ -1278,9 -1166,10 +1314,13 @@@ static void perf_session__warn_about_er
  
  volatile int session_done;
  
- static int __perf_session__process_pipe_events(struct perf_session *session,
- 					       struct perf_tool *tool)
+ static int __perf_session__process_pipe_events(struct perf_session *session)
  {
++<<<<<<< HEAD
++=======
+ 	struct ordered_events *oe = &session->ordered_events;
+ 	struct perf_tool *tool = oe->tool;
++>>>>>>> b7b61cbebd78 (perf ordered_events: Shorten function signatures)
  	int fd = perf_data_file__fd(session->file);
  	union perf_event *event;
  	uint32_t size, cur_size = 0;
@@@ -1360,11 -1249,11 +1400,15 @@@ more
  		goto more;
  done:
  	/* do the final flush for ordered samples */
++<<<<<<< HEAD
 +	err = ordered_events__flush(session, tool, OE_FLUSH__FINAL);
++=======
+ 	err = ordered_events__flush(oe, OE_FLUSH__FINAL);
++>>>>>>> b7b61cbebd78 (perf ordered_events: Shorten function signatures)
  out_err:
  	free(buf);
 -	perf_tool__warn_about_errors(tool, &session->evlist->stats);
 -	ordered_events__free(&session->ordered_events);
 +	perf_session__warn_about_errors(session, tool);
 +	perf_session_free_sample_buffers(session);
  	return err;
  }
  
@@@ -1410,8 -1299,10 +1454,13 @@@ fetch_mmaped_event(struct perf_session 
  
  static int __perf_session__process_events(struct perf_session *session,
  					  u64 data_offset, u64 data_size,
- 					  u64 file_size, struct perf_tool *tool)
+ 					  u64 file_size)
  {
++<<<<<<< HEAD
++=======
+ 	struct ordered_events *oe = &session->ordered_events;
+ 	struct perf_tool *tool = oe->tool;
++>>>>>>> b7b61cbebd78 (perf ordered_events: Shorten function signatures)
  	int fd = perf_data_file__fd(session->file);
  	u64 head, page_offset, file_offset, file_pos, size;
  	int err, mmap_prot, mmap_flags, map_idx = 0;
@@@ -1505,11 -1395,11 +1553,15 @@@ more
  
  out:
  	/* do the final flush for ordered samples */
++<<<<<<< HEAD
 +	err = ordered_events__flush(session, tool, OE_FLUSH__FINAL);
++=======
+ 	err = ordered_events__flush(oe, OE_FLUSH__FINAL);
++>>>>>>> b7b61cbebd78 (perf ordered_events: Shorten function signatures)
  out_err:
  	ui_progress__finish();
 -	perf_tool__warn_about_errors(tool, &session->evlist->stats);
 -	ordered_events__free(&session->ordered_events);
 +	perf_session__warn_about_errors(session, tool);
 +	perf_session_free_sample_buffers(session);
  	session->one_mmap = false;
  	return err;
  }
diff --cc tools/perf/util/session.h
index 4c0f5b098c9f,06e0777e9803..000000000000
--- a/tools/perf/util/session.h
+++ b/tools/perf/util/session.h
@@@ -62,11 -48,10 +62,15 @@@ int perf_session__peek_event(struct per
  			     union perf_event **event_ptr,
  			     struct perf_sample *sample);
  
- int perf_session__process_events(struct perf_session *session,
- 				 struct perf_tool *tool);
+ int perf_session__process_events(struct perf_session *session);
  
++<<<<<<< HEAD
 +int perf_session_queue_event(struct perf_session *s, union perf_event *event,
 +			     struct perf_sample *sample, u64 file_offset);
++=======
+ int perf_session__queue_event(struct perf_session *s, union perf_event *event,
+ 			      struct perf_sample *sample, u64 file_offset);
++>>>>>>> b7b61cbebd78 (perf ordered_events: Shorten function signatures)
  
  void perf_tool__fill_defaults(struct perf_tool *tool);
  
* Unmerged path tools/perf/util/data-convert-bt.c
* Unmerged path tools/perf/util/ordered-events.c
* Unmerged path tools/perf/util/ordered-events.h
diff --git a/tools/perf/builtin-annotate.c b/tools/perf/builtin-annotate.c
index 747f86103599..71bf7451c0ca 100644
--- a/tools/perf/builtin-annotate.c
+++ b/tools/perf/builtin-annotate.c
@@ -208,7 +208,7 @@ static int __cmd_annotate(struct perf_annotate *ann)
 			goto out;
 	}
 
-	ret = perf_session__process_events(session, &ann->tool);
+	ret = perf_session__process_events(session);
 	if (ret)
 		goto out;
 
diff --git a/tools/perf/builtin-buildid-list.c b/tools/perf/builtin-buildid-list.c
index ed3873b3e238..feb420f74c2d 100644
--- a/tools/perf/builtin-buildid-list.c
+++ b/tools/perf/builtin-buildid-list.c
@@ -74,7 +74,7 @@ static int perf_session__list_build_ids(bool force, bool with_hits)
 	 * the record stream. Buildids are stored as RECORD_HEADER_BUILD_ID
 	 */
 	if (with_hits || perf_data_file__is_pipe(&file))
-		perf_session__process_events(session, &build_id__mark_dso_hit_ops);
+		perf_session__process_events(session);
 
 	perf_session__fprintf_dsos_buildid(session, stdout, dso__skip_buildid, with_hits);
 	perf_session__delete(session);
diff --git a/tools/perf/builtin-diff.c b/tools/perf/builtin-diff.c
index 74aada554b12..f800fc95f5d7 100644
--- a/tools/perf/builtin-diff.c
+++ b/tools/perf/builtin-diff.c
@@ -747,7 +747,7 @@ static int __cmd_diff(void)
 			goto out_delete;
 		}
 
-		ret = perf_session__process_events(d->session, &tool);
+		ret = perf_session__process_events(d->session);
 		if (ret) {
 			pr_err("Failed to process %s\n", d->file.path);
 			goto out_delete;
diff --git a/tools/perf/builtin-inject.c b/tools/perf/builtin-inject.c
index a13641e066f5..2563f07ec0e5 100644
--- a/tools/perf/builtin-inject.c
+++ b/tools/perf/builtin-inject.c
@@ -359,8 +359,6 @@ static int __cmd_inject(struct perf_inject *inject)
 	} else if (inject->sched_stat) {
 		struct perf_evsel *evsel;
 
-		inject->tool.ordered_events = true;
-
 		evlist__for_each(session->evlist, evsel) {
 			const char *name = perf_evsel__name(evsel);
 
@@ -379,7 +377,7 @@ static int __cmd_inject(struct perf_inject *inject)
 	if (!file_out->is_pipe)
 		lseek(fd, session->header.data_offset, SEEK_SET);
 
-	ret = perf_session__process_events(session, &inject->tool);
+	ret = perf_session__process_events(session);
 
 	if (!file_out->is_pipe) {
 		if (inject->build_ids)
@@ -458,6 +456,8 @@ int cmd_inject(int argc, const char **argv, const char *prefix __maybe_unused)
 		return -1;
 	}
 
+	inject.tool.ordered_events = inject.sched_stat;
+
 	file.path = inject.input_name;
 	inject.session = perf_session__new(&file, true, &inject.tool);
 	if (inject.session == NULL)
diff --git a/tools/perf/builtin-kmem.c b/tools/perf/builtin-kmem.c
index f295141025bc..62f165a9fa40 100644
--- a/tools/perf/builtin-kmem.c
+++ b/tools/perf/builtin-kmem.c
@@ -426,7 +426,7 @@ static int __cmd_kmem(struct perf_session *session)
 	}
 
 	setup_pager();
-	err = perf_session__process_events(session, &perf_kmem);
+	err = perf_session__process_events(session);
 	if (err != 0)
 		goto out;
 	sort_result();
* Unmerged path tools/perf/builtin-kvm.c
diff --git a/tools/perf/builtin-lock.c b/tools/perf/builtin-lock.c
index e7ec71589da6..7893a9bba2a7 100644
--- a/tools/perf/builtin-lock.c
+++ b/tools/perf/builtin-lock.c
@@ -878,7 +878,7 @@ static int __cmd_report(bool display_info)
 	if (select_key())
 		goto out_delete;
 
-	err = perf_session__process_events(session, &eops);
+	err = perf_session__process_events(session);
 	if (err)
 		goto out_delete;
 
diff --git a/tools/perf/builtin-mem.c b/tools/perf/builtin-mem.c
index 9b5663950a4d..46c69318de84 100644
--- a/tools/perf/builtin-mem.c
+++ b/tools/perf/builtin-mem.c
@@ -141,7 +141,7 @@ static int report_raw_events(struct perf_mem *mem)
 
 	printf("# PID, TID, IP, ADDR, LOCAL WEIGHT, DSRC, SYMBOL\n");
 
-	err = perf_session__process_events(session, &mem->tool);
+	err = perf_session__process_events(session);
 	if (err)
 		return err;
 
diff --git a/tools/perf/builtin-record.c b/tools/perf/builtin-record.c
index 4fdad06d37db..5a2ff510b75b 100644
--- a/tools/perf/builtin-record.c
+++ b/tools/perf/builtin-record.c
@@ -225,7 +225,7 @@ static int process_buildids(struct record *rec)
 	 */
 	symbol_conf.ignore_vmlinux_buildid = true;
 
-	return perf_session__process_events(session, &rec->tool);
+	return perf_session__process_events(session);
 }
 
 static void perf_event__synthesize_guest_os(struct machine *machine, void *data)
@@ -343,7 +343,7 @@ static int __cmd_record(struct record *rec, int argc, const char **argv)
 	signal(SIGINT, sig_handler);
 	signal(SIGTERM, sig_handler);
 
-	session = perf_session__new(file, false, NULL);
+	session = perf_session__new(file, false, tool);
 	if (session == NULL) {
 		pr_err("Perf session creation failed.\n");
 		return -1;
diff --git a/tools/perf/builtin-report.c b/tools/perf/builtin-report.c
index 6a78134bd857..bd5bf2286880 100644
--- a/tools/perf/builtin-report.c
+++ b/tools/perf/builtin-report.c
@@ -476,7 +476,7 @@ static int __cmd_report(struct report *rep)
 	if (ret)
 		return ret;
 
-	ret = perf_session__process_events(session, &rep->tool);
+	ret = perf_session__process_events(session);
 	if (ret)
 		return ret;
 
diff --git a/tools/perf/builtin-sched.c b/tools/perf/builtin-sched.c
index 4ddce9e3dd38..bc76da0395f2 100644
--- a/tools/perf/builtin-sched.c
+++ b/tools/perf/builtin-sched.c
@@ -1467,7 +1467,7 @@ static int perf_sched__read_events(struct perf_sched *sched)
 		goto out_delete;
 
 	if (perf_session__has_traces(session, "record -R")) {
-		int err = perf_session__process_events(session, &sched->tool);
+		int err = perf_session__process_events(session);
 		if (err) {
 			pr_err("Failed to process events, error %d", err);
 			goto out_delete;
diff --git a/tools/perf/builtin-script.c b/tools/perf/builtin-script.c
index ce304dfd962a..c7e6750923ef 100644
--- a/tools/perf/builtin-script.c
+++ b/tools/perf/builtin-script.c
@@ -800,7 +800,7 @@ static int __cmd_script(struct perf_script *script)
 		script->tool.mmap2 = process_mmap2_event;
 	}
 
-	ret = perf_session__process_events(script->session, &script->tool);
+	ret = perf_session__process_events(script->session);
 
 	if (debug_mode)
 		pr_err("Misordered timestamps: %" PRIu64 "\n", nr_unordered);
diff --git a/tools/perf/builtin-timechart.c b/tools/perf/builtin-timechart.c
index f3bb1a4bf060..51440d1fc722 100644
--- a/tools/perf/builtin-timechart.c
+++ b/tools/perf/builtin-timechart.c
@@ -1623,7 +1623,7 @@ static int __cmd_timechart(struct timechart *tchart, const char *output_name)
 		goto out_delete;
 	}
 
-	ret = perf_session__process_events(session, &tchart->tool);
+	ret = perf_session__process_events(session);
 	if (ret)
 		goto out_delete;
 
diff --git a/tools/perf/builtin-trace.c b/tools/perf/builtin-trace.c
index 211614fba217..6969ba98ff2f 100644
--- a/tools/perf/builtin-trace.c
+++ b/tools/perf/builtin-trace.c
@@ -2408,7 +2408,7 @@ static int trace__replay(struct trace *trace)
 
 	setup_pager();
 
-	err = perf_session__process_events(session, &trace->tool);
+	err = perf_session__process_events(session);
 	if (err)
 		pr_err("Failed to process events, error %d", err);
 
* Unmerged path tools/perf/util/data-convert-bt.c
* Unmerged path tools/perf/util/ordered-events.c
* Unmerged path tools/perf/util/ordered-events.h
* Unmerged path tools/perf/util/session.c
* Unmerged path tools/perf/util/session.h
