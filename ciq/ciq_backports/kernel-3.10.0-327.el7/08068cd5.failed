net/mlx4: Added qos_vport QP configuration in VST mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [netdrv] mlx4: Added qos_vport QP configuration in VST mode (Amir Vadai) [1164527 1164530 1164531 1164536 1164537]
Rebuild_FUZZ: 96.15%
commit-author Ido Shamay <idos@mellanox.com>
commit 08068cd5683f11e4505aa9c8cc6ed5942f8ad299
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/08068cd5.failed

Granular QoS per VF feature introduce a new QP field, qos_vport.

PF administrator can connect VF QPs to a certain QoS Vport, to
inherit its proporties. Connecting QPs to the default QoS Vport
(defined as 0) is always allowed, even when there are no allocated VPPs.
At this point, only the default vport is connected to QPs.

	Signed-off-by: Ido Shamay <idos@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 08068cd5683f11e4505aa9c8cc6ed5942f8ad299)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx4/qp.c
#	include/linux/mlx4/qp.h
diff --cc drivers/net/ethernet/mellanox/mlx4/qp.c
index 3fe90ced81ce,b75214a80d0e..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/qp.c
+++ b/drivers/net/ethernet/mellanox/mlx4/qp.c
@@@ -443,6 -442,16 +443,19 @@@ int mlx4_update_qp(struct mlx4_dev *dev
  			cmd->qp_context.param3 |= cpu_to_be32(MLX4_STRIP_VLAN);
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (attr & MLX4_UPDATE_QP_RATE_LIMIT) {
+ 		qp_mask |= 1ULL << MLX4_UPD_QP_MASK_RATE_LIMIT;
+ 		cmd->qp_context.rate_limit_params = cpu_to_be16((params->rate_unit << 14) | params->rate_val);
+ 	}
+ 
+ 	if (attr & MLX4_UPDATE_QP_QOS_VPORT) {
+ 		qp_mask |= 1ULL << MLX4_UPD_QP_MASK_QOS_VPP;
+ 		cmd->qp_context.qos_vport = params->qos_vport;
+ 	}
+ 
++>>>>>>> 08068cd5683f (net/mlx4: Added qos_vport QP configuration in VST mode)
  	cmd->primary_addr_path_mask = cpu_to_be64(pri_addr_path_mask);
  	cmd->qp_mask = cpu_to_be64(qp_mask);
  
diff --cc include/linux/mlx4/qp.h
index 6ce99be3ebee,6fed539e5456..000000000000
--- a/include/linux/mlx4/qp.h
+++ b/include/linux/mlx4/qp.h
@@@ -204,7 -207,10 +204,14 @@@ struct mlx4_qp_context 
  	__be32			msn;
  	__be16			rq_wqe_counter;
  	__be16			sq_wqe_counter;
++<<<<<<< HEAD
 +	u32			reserved3[2];
++=======
+ 	u32			reserved3;
+ 	__be16			rate_limit_params;
+ 	u8			reserved4;
+ 	u8			qos_vport;
++>>>>>>> 08068cd5683f (net/mlx4: Added qos_vport QP configuration in VST mode)
  	__be32			param3;
  	__be32			nummmcpeers_basemkey;
  	u8			log_page_size;
@@@ -226,6 -232,8 +233,11 @@@ struct mlx4_update_qp_context 
  enum {
  	MLX4_UPD_QP_MASK_PM_STATE	= 32,
  	MLX4_UPD_QP_MASK_VSD		= 33,
++<<<<<<< HEAD
++=======
+ 	MLX4_UPD_QP_MASK_QOS_VPP	= 34,
+ 	MLX4_UPD_QP_MASK_RATE_LIMIT	= 35,
++>>>>>>> 08068cd5683f (net/mlx4: Added qos_vport QP configuration in VST mode)
  };
  
  enum {
@@@ -425,7 -433,9 +437,13 @@@ struct mlx4_wqe_inline_seg 
  enum mlx4_update_qp_attr {
  	MLX4_UPDATE_QP_SMAC		= 1 << 0,
  	MLX4_UPDATE_QP_VSD		= 1 << 1,
++<<<<<<< HEAD
 +	MLX4_UPDATE_QP_SUPPORTED_ATTRS	= (1 << 2) - 1
++=======
+ 	MLX4_UPDATE_QP_RATE_LIMIT	= 1 << 2,
+ 	MLX4_UPDATE_QP_QOS_VPORT	= 1 << 3,
+ 	MLX4_UPDATE_QP_SUPPORTED_ATTRS	= (1 << 4) - 1
++>>>>>>> 08068cd5683f (net/mlx4: Added qos_vport QP configuration in VST mode)
  };
  
  enum mlx4_update_qp_params_flags {
@@@ -434,7 -444,10 +452,8 @@@
  
  struct mlx4_update_qp_params {
  	u8	smac_index;
+ 	u8	qos_vport;
  	u32	flags;
 -	u16	rate_unit;
 -	u16	rate_val;
  };
  
  int mlx4_update_qp(struct mlx4_dev *dev, u32 qpn,
diff --git a/drivers/net/ethernet/mellanox/mlx4/cmd.c b/drivers/net/ethernet/mellanox/mlx4/cmd.c
index 9f3169a6e2cb..3f4f7e7aeab9 100644
--- a/drivers/net/ethernet/mellanox/mlx4/cmd.c
+++ b/drivers/net/ethernet/mellanox/mlx4/cmd.c
@@ -47,6 +47,7 @@
 
 #include "mlx4.h"
 #include "fw.h"
+#include "fw_qos.h"
 
 #define CMD_POLL_TOKEN 0xffff
 #define INBOX_MASK	0xffffffffffffff00ULL
@@ -1632,7 +1633,8 @@ static int mlx4_master_immediate_activate_vlan_qos(struct mlx4_priv *priv,
 
 	if (vp_oper->state.default_vlan == vp_admin->default_vlan &&
 	    vp_oper->state.default_qos == vp_admin->default_qos &&
-	    vp_oper->state.link_state == vp_admin->link_state)
+	    vp_oper->state.link_state == vp_admin->link_state &&
+	    vp_oper->state.qos_vport == vp_admin->qos_vport)
 		return 0;
 
 	if (!(priv->mfunc.master.slave_state[slave].active &&
@@ -1690,6 +1692,7 @@ static int mlx4_master_immediate_activate_vlan_qos(struct mlx4_priv *priv,
 	vp_oper->state.default_vlan = vp_admin->default_vlan;
 	vp_oper->state.default_qos = vp_admin->default_qos;
 	vp_oper->state.link_state = vp_admin->link_state;
+	vp_oper->state.qos_vport = vp_admin->qos_vport;
 
 	if (vp_admin->link_state == IFLA_VF_LINK_STATE_DISABLE)
 		work->flags |= MLX4_VF_IMMED_VLAN_FLAG_LINK_DISABLE;
@@ -1698,6 +1701,7 @@ static int mlx4_master_immediate_activate_vlan_qos(struct mlx4_priv *priv,
 	work->port = port;
 	work->slave = slave;
 	work->qos = vp_oper->state.default_qos;
+	work->qos_vport = vp_oper->state.qos_vport;
 	work->vlan_id = vp_oper->state.default_vlan;
 	work->vlan_ix = vp_oper->vlan_idx;
 	work->priv = priv;
@@ -2137,6 +2141,9 @@ int mlx4_multi_func_init(struct mlx4_dev *dev)
 				INIT_LIST_HEAD(&s_state->mcast_filters[port]);
 				admin_vport->default_vlan = MLX4_VGT;
 				oper_vport->default_vlan = MLX4_VGT;
+				admin_vport->qos_vport =
+						MLX4_VPP_DEFAULT_VPORT;
+				oper_vport->qos_vport = MLX4_VPP_DEFAULT_VPORT;
 				vf_oper->vport[port].vlan_idx = NO_INDX;
 				vf_oper->vport[port].mac_idx = NO_INDX;
 			}
diff --git a/drivers/net/ethernet/mellanox/mlx4/fw_qos.h b/drivers/net/ethernet/mellanox/mlx4/fw_qos.h
index 4a5320f79094..ac1f331878e6 100644
--- a/drivers/net/ethernet/mellanox/mlx4/fw_qos.h
+++ b/drivers/net/ethernet/mellanox/mlx4/fw_qos.h
@@ -44,6 +44,9 @@
 /* Default supported priorities for VPP allocation */
 #define MLX4_DEFAULT_QOS_PRIO (0)
 
+/* Derived from FW feature definition, 0 is the default vport fo all QPs */
+#define MLX4_VPP_DEFAULT_VPORT (0)
+
 struct mlx4_vport_qos_param {
 	u32 bw_share;
 	u32 max_avg_bw;
diff --git a/drivers/net/ethernet/mellanox/mlx4/mlx4.h b/drivers/net/ethernet/mellanox/mlx4/mlx4.h
index 693d8152c03b..256d40ed111a 100644
--- a/drivers/net/ethernet/mellanox/mlx4/mlx4.h
+++ b/drivers/net/ethernet/mellanox/mlx4/mlx4.h
@@ -490,6 +490,7 @@ struct mlx4_vport_state {
 	u32 tx_rate;
 	bool spoofchk;
 	u32 link_state;
+	u8 qos_vport;
 };
 
 struct mlx4_vf_admin_state {
@@ -629,6 +630,7 @@ struct mlx4_vf_immed_vlan_work {
 	int			orig_vlan_ix;
 	u8			port;
 	u8			qos;
+	u8                      qos_vport;
 	u16			vlan_id;
 	u16			orig_vlan_id;
 };
* Unmerged path drivers/net/ethernet/mellanox/mlx4/qp.c
diff --git a/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c b/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c
index 6d07b884c4fd..3ab6260d8594 100644
--- a/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c
+++ b/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c
@@ -755,6 +755,7 @@ static int update_vport_qp_param(struct mlx4_dev *dev,
 		qpc->pri_path.feup |= MLX4_FEUP_FORCE_ETH_UP | MLX4_FVL_FORCE_ETH_VLAN;
 		qpc->pri_path.sched_queue &= 0xC7;
 		qpc->pri_path.sched_queue |= (vp_oper->state.default_qos) << 3;
+		qpc->qos_vport = vp_oper->state.qos_vport;
 	}
 	if (vp_oper->state.spoofchk) {
 		qpc->pri_path.feup |= MLX4_FSM_FORCE_ETH_SRC_MAC;
@@ -4903,6 +4904,11 @@ void mlx4_vf_immed_vlan_work_handler(struct work_struct *_work)
 					qp->sched_queue & 0xC7;
 				upd_context->qp_context.pri_path.sched_queue |=
 					((work->qos & 0x7) << 3);
+				upd_context->qp_mask |=
+					cpu_to_be64(1ULL <<
+						    MLX4_UPD_QP_MASK_QOS_VPP);
+				upd_context->qp_context.qos_vport =
+					work->qos_vport;
 			}
 
 			err = mlx4_cmd(dev, mailbox->dma,
* Unmerged path include/linux/mlx4/qp.h
