drm/radeon: Clean up reference counting and pinning of the cursor BOs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [drm] radeon: Clean up reference counting and pinning of the cursor BOs (Rob Clark) [1249805]
Rebuild_FUZZ: 97.01%
commit-author Michel Dänzer <michel.daenzer@amd.com>
commit cd404af0c930104462aa91344f07d002cf8248ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/cd404af0.failed

Take a GEM reference for and pin the new cursor BO, unpin and drop the
GEM reference for the old cursor BO in radeon_crtc_cursor_set2, and use
radeon_crtc->cursor_addr in radeon_set_cursor.

This fixes radeon_cursor_reset accidentally incrementing the cursor BO
pin count, and cleans up the code a little.

	Cc: stable@vger.kernel.org
	Reviewed-by: Grigori Goronzy <greg@chown.ath.cx>
	Reviewed-by: Christian König <christian.koenig@amd.com>
	Signed-off-by: Michel Dänzer <michel.daenzer@amd.com>
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit cd404af0c930104462aa91344f07d002cf8248ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/radeon/radeon_cursor.c
diff --cc drivers/gpu/drm/radeon/radeon_cursor.c
index 9630e8d95fb4,fa661744a1f5..000000000000
--- a/drivers/gpu/drm/radeon/radeon_cursor.c
+++ b/drivers/gpu/drm/radeon/radeon_cursor.c
@@@ -305,10 -205,166 +305,157 @@@ int radeon_crtc_cursor_move(struct drm_
  			| (x << 16)
  			| y));
  		/* offset is from DISP(2)_BASE_ADDRESS */
- 		WREG32(RADEON_CUR_OFFSET + radeon_crtc->crtc_offset, (radeon_crtc->legacy_cursor_offset +
- 								      (yorigin * 256)));
+ 		WREG32(RADEON_CUR_OFFSET + radeon_crtc->crtc_offset,
+ 		       radeon_crtc->cursor_addr - radeon_crtc->legacy_display_base_addr +
+ 		       yorigin * 256);
  	}
 +	radeon_lock_cursor(crtc, false);
  
 -	radeon_crtc->cursor_x = x;
 -	radeon_crtc->cursor_y = y;
 -
++<<<<<<< HEAD
  	return 0;
  }
 -
 -int radeon_crtc_cursor_move(struct drm_crtc *crtc,
 -			    int x, int y)
 -{
 -	int ret;
 -
 -	radeon_lock_cursor(crtc, true);
 -	ret = radeon_cursor_move_locked(crtc, x, y);
 -	radeon_lock_cursor(crtc, false);
 -
++=======
+ 	return ret;
+ }
+ 
+ static void radeon_set_cursor(struct drm_crtc *crtc)
+ {
+ 	struct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);
+ 	struct radeon_device *rdev = crtc->dev->dev_private;
+ 
+ 	if (ASIC_IS_DCE4(rdev)) {
+ 		WREG32(EVERGREEN_CUR_SURFACE_ADDRESS_HIGH + radeon_crtc->crtc_offset,
+ 		       upper_32_bits(radeon_crtc->cursor_addr));
+ 		WREG32(EVERGREEN_CUR_SURFACE_ADDRESS + radeon_crtc->crtc_offset,
+ 		       lower_32_bits(radeon_crtc->cursor_addr));
+ 	} else if (ASIC_IS_AVIVO(rdev)) {
+ 		if (rdev->family >= CHIP_RV770) {
+ 			if (radeon_crtc->crtc_id)
+ 				WREG32(R700_D2CUR_SURFACE_ADDRESS_HIGH,
+ 				       upper_32_bits(radeon_crtc->cursor_addr));
+ 			else
+ 				WREG32(R700_D1CUR_SURFACE_ADDRESS_HIGH,
+ 				       upper_32_bits(radeon_crtc->cursor_addr));
+ 		}
+ 		WREG32(AVIVO_D1CUR_SURFACE_ADDRESS + radeon_crtc->crtc_offset,
+ 		       lower_32_bits(radeon_crtc->cursor_addr));
+ 	} else {
+ 		/* offset is from DISP(2)_BASE_ADDRESS */
+ 		WREG32(RADEON_CUR_OFFSET + radeon_crtc->crtc_offset,
+ 		       radeon_crtc->cursor_addr - radeon_crtc->legacy_display_base_addr);
+ 	}
+ }
+ 
+ int radeon_crtc_cursor_set2(struct drm_crtc *crtc,
+ 			    struct drm_file *file_priv,
+ 			    uint32_t handle,
+ 			    uint32_t width,
+ 			    uint32_t height,
+ 			    int32_t hot_x,
+ 			    int32_t hot_y)
+ {
+ 	struct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);
+ 	struct radeon_device *rdev = crtc->dev->dev_private;
+ 	struct drm_gem_object *obj;
+ 	struct radeon_bo *robj;
+ 	int ret;
+ 
+ 	if (!handle) {
+ 		/* turn off cursor */
+ 		radeon_hide_cursor(crtc);
+ 		obj = NULL;
+ 		goto unpin;
+ 	}
+ 
+ 	if ((width > radeon_crtc->max_cursor_width) ||
+ 	    (height > radeon_crtc->max_cursor_height)) {
+ 		DRM_ERROR("bad cursor width or height %d x %d\n", width, height);
+ 		return -EINVAL;
+ 	}
+ 
+ 	obj = drm_gem_object_lookup(crtc->dev, file_priv, handle);
+ 	if (!obj) {
+ 		DRM_ERROR("Cannot find cursor object %x for crtc %d\n", handle, radeon_crtc->crtc_id);
+ 		return -ENOENT;
+ 	}
+ 
+ 	robj = gem_to_radeon_bo(obj);
+ 	ret = radeon_bo_reserve(robj, false);
+ 	if (ret != 0) {
+ 		drm_gem_object_unreference_unlocked(obj);
+ 		return ret;
+ 	}
+ 	/* Only 27 bit offset for legacy cursor */
+ 	ret = radeon_bo_pin_restricted(robj, RADEON_GEM_DOMAIN_VRAM,
+ 				       ASIC_IS_AVIVO(rdev) ? 0 : 1 << 27,
+ 				       &radeon_crtc->cursor_addr);
+ 	radeon_bo_unreserve(robj);
+ 	if (ret) {
+ 		DRM_ERROR("Failed to pin new cursor BO (%d)\n", ret);
+ 		drm_gem_object_unreference_unlocked(obj);
+ 		return ret;
+ 	}
+ 
+ 	radeon_crtc->cursor_width = width;
+ 	radeon_crtc->cursor_height = height;
+ 
+ 	radeon_lock_cursor(crtc, true);
+ 
+ 	if (hot_x != radeon_crtc->cursor_hot_x ||
+ 	    hot_y != radeon_crtc->cursor_hot_y) {
+ 		int x, y;
+ 
+ 		x = radeon_crtc->cursor_x + radeon_crtc->cursor_hot_x - hot_x;
+ 		y = radeon_crtc->cursor_y + radeon_crtc->cursor_hot_y - hot_y;
+ 
+ 		radeon_cursor_move_locked(crtc, x, y);
+ 
+ 		radeon_crtc->cursor_hot_x = hot_x;
+ 		radeon_crtc->cursor_hot_y = hot_y;
+ 	}
+ 
+ 	radeon_set_cursor(crtc);
+ 	radeon_show_cursor(crtc);
+ 
+ 	radeon_lock_cursor(crtc, false);
+ 
+ unpin:
+ 	if (radeon_crtc->cursor_bo) {
+ 		struct radeon_bo *robj = gem_to_radeon_bo(radeon_crtc->cursor_bo);
+ 		ret = radeon_bo_reserve(robj, false);
+ 		if (likely(ret == 0)) {
+ 			radeon_bo_unpin(robj);
+ 			radeon_bo_unreserve(robj);
+ 		}
+ 		drm_gem_object_unreference_unlocked(radeon_crtc->cursor_bo);
+ 	}
+ 
+ 	radeon_crtc->cursor_bo = obj;
+ 	return 0;
+ }
+ 
+ /**
+  * radeon_cursor_reset - Re-set the current cursor, if any.
+  *
+  * @crtc: drm crtc
+  *
+  * If the CRTC passed in currently has a cursor assigned, this function
+  * makes sure it's visible.
+  */
+ void radeon_cursor_reset(struct drm_crtc *crtc)
+ {
+ 	struct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);
+ 
+ 	if (radeon_crtc->cursor_bo) {
+ 		radeon_lock_cursor(crtc, true);
+ 
+ 		radeon_cursor_move_locked(crtc, radeon_crtc->cursor_x,
+ 					  radeon_crtc->cursor_y);
+ 
+ 		radeon_set_cursor(crtc);
+ 		radeon_show_cursor(crtc);
+ 
+ 		radeon_lock_cursor(crtc, false);
+ 	}
+ }
++>>>>>>> cd404af0c930 (drm/radeon: Clean up reference counting and pinning of the cursor BOs)
* Unmerged path drivers/gpu/drm/radeon/radeon_cursor.c
diff --git a/drivers/gpu/drm/radeon/radeon_mode.h b/drivers/gpu/drm/radeon/radeon_mode.h
index 0592ddb0904b..fde28a1b1018 100644
--- a/drivers/gpu/drm/radeon/radeon_mode.h
+++ b/drivers/gpu/drm/radeon/radeon_mode.h
@@ -326,7 +326,6 @@ struct radeon_crtc {
 	int max_cursor_width;
 	int max_cursor_height;
 	uint32_t legacy_display_base_addr;
-	uint32_t legacy_cursor_offset;
 	enum radeon_rmx_type rmx_type;
 	u8 h_border;
 	u8 v_border;
