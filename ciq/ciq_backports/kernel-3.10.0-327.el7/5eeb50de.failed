uprobes: Change handle_trampoline() to flush the frames invalidated by longjmp()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Oleg Nesterov <oleg@redhat.com>
commit 5eeb50de42fd3251845d03c556db012267c72b3f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/5eeb50de.failed

Test-case:

	#include <stdio.h>
	#include <setjmp.h>

	jmp_buf jmp;

	void func_2(void)
	{
		longjmp(jmp, 1);
	}

	void func_1(void)
	{
		if (setjmp(jmp))
			return;
		func_2();
		printf("ERR!! I am running on the caller's stack\n");
	}

	int main(void)
	{
		func_1();
		return 0;
	}

fails if you probe func_1() and func_2() because
handle_trampoline() assumes that the probed function should must
return and hit the bp installed be prepare_uretprobe(). But in
this case func_2() does not return, so when func_1() returns the
kernel uses the no longer valid return_instance of func_2().

Change handle_trampoline() to unwind ->return_instances until we
know that the next chain is alive or NULL, this ensures that the
current chain is the last we need to report and free.

Alternatively, every return_instance could use unique
trampoline_vaddr, in this case we could use it as a key. And
this could solve the problem with sigaltstack() automatically.

But this approach needs more changes, and it puts the "hard"
limit on MAX_URETPROBE_DEPTH. Plus it can not solve another
problem partially fixed by the next patch.

Note: this change has no effect on !x86, the arch-agnostic
version of arch_uretprobe_is_alive() just returns "true".

TODO: as documented by the previous change, arch_uretprobe_is_alive()
      can be fooled by sigaltstack/etc.

	Tested-by: Pratyush Anand <panand@redhat.com>
	Signed-off-by: Oleg Nesterov <oleg@redhat.com>
	Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
	Acked-by: Anton Arapov <arapov@gmail.com>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/20150721134021.GA4773@redhat.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 5eeb50de42fd3251845d03c556db012267c72b3f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/events/uprobes.c
diff --cc kernel/events/uprobes.c
index b0b89515dd30,93d939c80cd9..000000000000
--- a/kernel/events/uprobes.c
+++ b/kernel/events/uprobes.c
@@@ -1716,8 -1761,20 +1716,13 @@@ handle_uretprobe_chain(struct return_in
  static void handle_trampoline(struct pt_regs *regs)
  {
  	struct uprobe_task *utask;
++<<<<<<< HEAD
 +	struct return_instance *ri, *tmp;
 +	bool chained;
++=======
+ 	struct return_instance *ri, *next;
+ 	bool valid;
++>>>>>>> 5eeb50de42fd (uprobes: Change handle_trampoline() to flush the frames invalidated by longjmp())
  
  	utask = current->utask;
  	if (!utask)
@@@ -1727,28 -1784,24 +1732,49 @@@
  	if (!ri)
  		goto sigill;
  
++<<<<<<< HEAD
 +	/*
 +	 * TODO: we should throw out return_instance's invalidated by
 +	 * longjmp(), currently we assume that the probed function always
 +	 * returns.
 +	 */
 +	instruction_pointer_set(regs, ri->orig_ret_vaddr);
 +
 +	for (;;) {
 +		handle_uretprobe_chain(ri, regs);
 +
 +		chained = ri->chained;
 +		put_uprobe(ri->uprobe);
 +
 +		tmp = ri;
 +		ri = ri->next;
 +		kfree(tmp);
 +		utask->depth--;
 +
 +		if (!chained)
 +			break;
 +		BUG_ON(!ri);
 +	}
++=======
+ 	do {
+ 		/*
+ 		 * We should throw out the frames invalidated by longjmp().
+ 		 * If this chain is valid, then the next one should be alive
+ 		 * or NULL; the latter case means that nobody but ri->func
+ 		 * could hit this trampoline on return. TODO: sigaltstack().
+ 		 */
+ 		next = find_next_ret_chain(ri);
+ 		valid = !next || arch_uretprobe_is_alive(next, regs);
+ 
+ 		instruction_pointer_set(regs, ri->orig_ret_vaddr);
+ 		do {
+ 			if (valid)
+ 				handle_uretprobe_chain(ri, regs);
+ 			ri = free_ret_instance(ri);
+ 			utask->depth--;
+ 		} while (ri != next);
+ 	} while (!valid);
++>>>>>>> 5eeb50de42fd (uprobes: Change handle_trampoline() to flush the frames invalidated by longjmp())
  
  	utask->return_instances = ri;
  	return;
* Unmerged path kernel/events/uprobes.c
