bonding: fix a div error caused by the slave release path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Nikolay Aleksandrov <nikolay@redhat.com>
commit ee6154e11eeccd4ae32c4881415dbd902a869592
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/ee6154e1.failed

There's a bug in the slave release function which leads the transmit
functions which use the bond->slave_cnt to a div by 0 because we might
just have released our last slave and made slave_cnt == 0 but at the same
time we may have a transmitter after the check for an empty list which will
fetch it and use it in the slave id calculation.
Fix it by moving the slave_cnt after synchronize_rcu so if this was our
last slave any new transmitters will see an empty slave list which is
checked after rcu lock but before calling the mode transmit functions
which rely on bond->slave_cnt.

Fixes: 278b208375 ("bonding: initial RCU conversion")

CC: Veaceslav Falico <vfalico@redhat.com>
CC: Andy Gospodarek <andy@greyhouse.net>
CC: Jay Vosburgh <fubar@us.ibm.com>
CC: David S. Miller <davem@davemloft.net>

	Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
	Acked-by: Veaceslav Falico <vfalico@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ee6154e11eeccd4ae32c4881415dbd902a869592)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
diff --cc drivers/net/bonding/bond_main.c
index a013179836f0,b47fa0421e01..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -1941,7 -1659,7 +1941,11 @@@ static int __bond_release_one(struct ne
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	write_unlock_bh(&bond->lock);
++=======
+ 	bond_sysfs_slave_del(slave);
++>>>>>>> ee6154e11eec (bonding: fix a div error caused by the slave release path)
  
  	bond_upper_dev_unlink(bond_dev, slave_dev);
  	/* unregister rx_handler early so bond_handle_frame wouldn't be called
@@@ -2011,19 -1724,25 +2015,24 @@@
  		bond_select_active_slave(bond);
  
  		write_unlock_bh(&bond->curr_slave_lock);
 +		read_unlock(&bond->lock);
 +		write_lock_bh(&bond->lock);
  	}
  
 -	if (!bond_has_slaves(bond)) {
 +	if (bond->slave_cnt == 0) {
  		bond_set_carrier(bond);
  		eth_hw_addr_random(bond_dev);
 -
 -		if (vlan_uses_dev(bond_dev)) {
 -			pr_warning("%s: Warning: clearing HW address of %s while it still has VLANs.\n",
 -				   bond_dev->name, bond_dev->name);
 -			pr_warning("%s: When re-adding slaves, make sure the bond's HW address matches its VLANs'.\n",
 -				   bond_dev->name);
 -		}
  	}
  
 +	write_unlock_bh(&bond->lock);
  	unblock_netpoll_tx();
++<<<<<<< HEAD
++=======
+ 	synchronize_rcu();
+ 	bond->slave_cnt--;
++>>>>>>> ee6154e11eec (bonding: fix a div error caused by the slave release path)
  
 -	if (!bond_has_slaves(bond)) {
 +	if (bond->slave_cnt == 0) {
  		call_netdevice_notifiers(NETDEV_CHANGEADDR, bond->dev);
  		call_netdevice_notifiers(NETDEV_RELEASE, bond->dev);
  	}
* Unmerged path drivers/net/bonding/bond_main.c
