bonding: make TX_QUEUE_OVERRIDE() macro an inline function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Veaceslav Falico <vfalico@gmail.com>
commit d1e2e5cd4f8ed2ac7c43ce44feeb9ebc7d27cb4b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/d1e2e5cd.failed

Also, make it accept bonding as a parameter and change the name a bit to
better reflect its scope.

CC: Jay Vosburgh <j.vosburgh@gmail.com>
CC: Andy Gospodarek <andy@greyhouse.net>
	Signed-off-by: Veaceslav Falico <vfalico@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d1e2e5cd4f8ed2ac7c43ce44feeb9ebc7d27cb4b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bonding.h
diff --cc drivers/net/bonding/bonding.h
index e1ca02f0b074,dca3dfdf42d3..000000000000
--- a/drivers/net/bonding/bonding.h
+++ b/drivers/net/bonding/bonding.h
@@@ -55,9 -60,14 +55,20 @@@
  		 ((mode) == BOND_MODE_TLB)          ||	\
  		 ((mode) == BOND_MODE_ALB))
  
++<<<<<<< HEAD
 +#define TX_QUEUE_OVERRIDE(mode)				\
 +			(((mode) == BOND_MODE_ACTIVEBACKUP) ||	\
 +			 ((mode) == BOND_MODE_ROUNDROBIN))
++=======
+ #define BOND_NO_USES_ARP(mode)				\
+ 		(((mode) == BOND_MODE_8023AD)	||	\
+ 		 ((mode) == BOND_MODE_TLB)	||	\
+ 		 ((mode) == BOND_MODE_ALB))
+ 
+ #define IS_IP_TARGET_UNUSABLE_ADDRESS(a)	\
+ 	((htonl(INADDR_BROADCAST) == a) ||	\
+ 	 ipv4_is_zeronet(a))
++>>>>>>> d1e2e5cd4f8e (bonding: make TX_QUEUE_OVERRIDE() macro an inline function)
  /*
   * Less bad way to call ioctl from within the kernel; this needs to be
   * done some other way to get the call out of interrupt context.
@@@ -285,10 -280,16 +296,16 @@@ static inline struct bonding *bond_get_
  	return slave->bond;
  }
  
+ static inline bool bond_should_override_tx_queue(struct bonding *bond)
+ {
+ 	return bond->params.mode == BOND_MODE_ACTIVEBACKUP ||
+ 	       bond->params.mode == BOND_MODE_ROUNDROBIN;
+ }
+ 
  static inline bool bond_is_lb(const struct bonding *bond)
  {
 -	return bond->params.mode == BOND_MODE_TLB ||
 -	       bond->params.mode == BOND_MODE_ALB;
 +	return (bond->params.mode == BOND_MODE_TLB ||
 +		bond->params.mode == BOND_MODE_ALB);
  }
  
  static inline void bond_set_active_slave(struct slave *slave)
diff --git a/drivers/net/bonding/bond_main.c b/drivers/net/bonding/bond_main.c
index d0eec7c786f0..885e2b1efd2a 100644
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@ -4060,10 +4060,9 @@ static netdev_tx_t __bond_start_xmit(struct sk_buff *skb, struct net_device *dev
 {
 	struct bonding *bond = netdev_priv(dev);
 
-	if (TX_QUEUE_OVERRIDE(bond->params.mode)) {
-		if (!bond_slave_override(bond, skb))
-			return NETDEV_TX_OK;
-	}
+	if (bond_should_override_tx_queue(bond) &&
+	    !bond_slave_override(bond, skb))
+		return NETDEV_TX_OK;
 
 	switch (bond->params.mode) {
 	case BOND_MODE_ROUNDROBIN:
* Unmerged path drivers/net/bonding/bonding.h
