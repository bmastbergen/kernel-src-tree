bonding: add proper __rcu annotation for curr_active_slave

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Eric Dumazet <edumazet@google.com>
commit 4740d6382790077f22c606d03804f5d9f15b90d7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/4740d638.failed

RCU was added to bonding in linux-3.12 but lacked proper sparse annotations.

Using __rcu annotation actually helps to spot all accesses to bond->curr_active_slave
are correctly protected, with LOCKDEP support.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Acked-by: Veaceslav Falico <vfalico@gmail.com>
	Reviewed-by: Nikolay Aleksandrov <nikolay@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4740d6382790077f22c606d03804f5d9f15b90d7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_alb.c
#	drivers/net/bonding/bond_main.c
#	drivers/net/bonding/bond_options.c
#	drivers/net/bonding/bonding.h
diff --cc drivers/net/bonding/bond_alb.c
index 9c9e1f0f72a6,de5bd03925b4..000000000000
--- a/drivers/net/bonding/bond_alb.c
+++ b/drivers/net/bonding/bond_alb.c
@@@ -426,7 -462,7 +428,11 @@@ static void rlb_teach_disabled_mac_on_p
  
  	bond->alb_info.rlb_promisc_timeout_counter = 0;
  
++<<<<<<< HEAD
 +	alb_send_learning_packets(bond->curr_active_slave, addr);
++=======
+ 	alb_send_learning_packets(curr_active, addr, true);
++>>>>>>> 4740d6382790 (bonding: add proper __rcu annotation for curr_active_slave)
  }
  
  /* slave being removed should not be active at this point
@@@ -650,9 -686,9 +656,15 @@@ static struct slave *rlb_choose_channel
  			 * move the old client to primary (curr_active_slave) so
  			 * that the new client can be assigned to this entry.
  			 */
++<<<<<<< HEAD
 +			if (bond->curr_active_slave &&
 +			    client_info->slave != bond->curr_active_slave) {
 +				client_info->slave = bond->curr_active_slave;
++=======
+ 			if (curr_active_slave &&
+ 			    client_info->slave != curr_active_slave) {
+ 				client_info->slave = curr_active_slave;
++>>>>>>> 4740d6382790 (bonding: add proper __rcu annotation for curr_active_slave)
  				rlb_update_client(client_info);
  			}
  		}
@@@ -1168,11 -1223,11 +1180,15 @@@ static void alb_change_hw_addr_on_detac
   */
  static int alb_handle_addr_collision_on_attach(struct bonding *bond, struct slave *slave)
  {
++<<<<<<< HEAD
++=======
+ 	struct slave *has_bond_addr = rcu_access_pointer(bond->curr_active_slave);
++>>>>>>> 4740d6382790 (bonding: add proper __rcu annotation for curr_active_slave)
  	struct slave *tmp_slave1, *free_mac_slave = NULL;
 -	struct list_head *iter;
 +	struct slave *has_bond_addr = bond->curr_active_slave;
 +	int i;
  
 -	if (!bond_has_slaves(bond)) {
 +	if (bond->slave_cnt == 0) {
  		/* this is the first slave */
  		return 0;
  	}
@@@ -1481,8 -1571,16 +1497,21 @@@ void bond_alb_monitor(struct work_struc
  		 */
  		read_lock(&bond->curr_slave_lock);
  
++<<<<<<< HEAD
 +		bond_for_each_slave(bond, slave, i) {
 +			alb_send_learning_packets(slave, slave->dev->dev_addr);
++=======
+ 		bond_for_each_slave_rcu(bond, slave, iter) {
+ 			/* If updating current_active, use all currently
+ 			 * user mac addreses (!strict_match).  Otherwise, only
+ 			 * use mac of the slave device.
+ 			 * In RLB mode, we always use strict matches.
+ 			 */
+ 			strict_match = (slave != rcu_access_pointer(bond->curr_active_slave) ||
+ 					bond_info->rlb_enabled);
+ 			alb_send_learning_packets(slave, slave->dev->dev_addr,
+ 						  strict_match);
++>>>>>>> 4740d6382790 (bonding: add proper __rcu annotation for curr_active_slave)
  		}
  
  		read_unlock(&bond->curr_slave_lock);
@@@ -1495,9 -1593,9 +1524,9 @@@
  
  		read_lock(&bond->curr_slave_lock);
  
 -		bond_for_each_slave_rcu(bond, slave, iter) {
 +		bond_for_each_slave(bond, slave, i) {
  			tlb_clear_slave(bond, slave, 1);
- 			if (slave == bond->curr_active_slave) {
+ 			if (slave == rcu_access_pointer(bond->curr_active_slave)) {
  				SLAVE_TLB_INFO(slave).load =
  					bond_info->unbalanced_load /
  						BOND_TLB_REBALANCE_INTERVAL;
@@@ -1521,8 -1627,12 +1550,9 @@@
  			 * because a slave was disabled then
  			 * it can now leave promiscuous mode.
  			 */
- 			dev_set_promiscuity(bond->curr_active_slave->dev, -1);
+ 			dev_set_promiscuity(rtnl_dereference(bond->curr_active_slave)->dev,
+ 					    -1);
  			bond_info->primary_is_promisc = 0;
 -
 -			rtnl_unlock();
 -			rcu_read_lock();
  		}
  
  		if (bond_info->rlb_rebalance) {
@@@ -1642,23 -1745,25 +1672,36 @@@ void bond_alb_handle_active_change(stru
  	__acquires(&bond->curr_slave_lock)
  {
  	struct slave *swap_slave;
+ 	struct slave *curr_active;
  
++<<<<<<< HEAD
 +	if (bond->curr_active_slave == new_slave) {
++=======
+ 	curr_active = rcu_dereference_protected(bond->curr_active_slave,
+ 						!new_slave ||
+ 						lockdep_is_held(&bond->curr_slave_lock));
+ 	if (curr_active == new_slave)
++>>>>>>> 4740d6382790 (bonding: add proper __rcu annotation for curr_active_slave)
  		return;
 +	}
  
- 	if (bond->curr_active_slave && bond->alb_info.primary_is_promisc) {
- 		dev_set_promiscuity(bond->curr_active_slave->dev, -1);
+ 	if (curr_active && bond->alb_info.primary_is_promisc) {
+ 		dev_set_promiscuity(curr_active->dev, -1);
  		bond->alb_info.primary_is_promisc = 0;
  		bond->alb_info.rlb_promisc_timeout_counter = 0;
  	}
  
++<<<<<<< HEAD
 +	swap_slave = bond->curr_active_slave;
 +	bond->curr_active_slave = new_slave;
++=======
+ 	swap_slave = curr_active;
+ 	rcu_assign_pointer(bond->curr_active_slave, new_slave);
++>>>>>>> 4740d6382790 (bonding: add proper __rcu annotation for curr_active_slave)
  
 -	if (!new_slave || !bond_has_slaves(bond))
 +	if (!new_slave || (bond->slave_cnt == 0)) {
  		return;
 +	}
  
  	/* set the new curr_active_slave to the bonds mac address
  	 * i.e. swap mac addresses of old curr_active_slave and new curr_active_slave
@@@ -1738,23 -1842,24 +1782,33 @@@ int bond_alb_set_mac_address(struct net
  	 * Otherwise we'll need to pass the new address to it and handle
  	 * duplications.
  	 */
++<<<<<<< HEAD
 +	if (!bond->curr_active_slave) {
++=======
+ 	curr_active = rtnl_dereference(bond->curr_active_slave);
+ 	if (!curr_active)
++>>>>>>> 4740d6382790 (bonding: add proper __rcu annotation for curr_active_slave)
  		return 0;
 +	}
  
  	swap_slave = bond_slave_has_mac(bond, bond_dev->dev_addr);
  
  	if (swap_slave) {
- 		alb_swap_mac_addr(swap_slave, bond->curr_active_slave);
- 		alb_fasten_mac_swap(bond, swap_slave, bond->curr_active_slave);
+ 		alb_swap_mac_addr(swap_slave, curr_active);
+ 		alb_fasten_mac_swap(bond, swap_slave, curr_active);
  	} else {
- 		alb_set_slave_mac_addr(bond->curr_active_slave, bond_dev->dev_addr);
+ 		alb_set_slave_mac_addr(curr_active, bond_dev->dev_addr);
  
  		read_lock(&bond->lock);
++<<<<<<< HEAD
 +		alb_send_learning_packets(bond->curr_active_slave, bond_dev->dev_addr);
++=======
+ 		alb_send_learning_packets(curr_active,
+ 					  bond_dev->dev_addr, false);
++>>>>>>> 4740d6382790 (bonding: add proper __rcu annotation for curr_active_slave)
  		if (bond->alb_info.rlb_enabled) {
  			/* inform clients mac address has changed */
- 			rlb_req_update_slave_clients(bond, bond->curr_active_slave);
+ 			rlb_req_update_slave_clients(bond, curr_active);
  		}
  		read_unlock(&bond->lock);
  	}
diff --cc drivers/net/bonding/bond_main.c
index aa34e1bea1e8,27ce838d45d6..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -670,17 -494,19 +670,22 @@@ static int bond_check_dev_link(struct b
   */
  static int bond_set_promiscuity(struct bonding *bond, int inc)
  {
 -	struct list_head *iter;
  	int err = 0;
++<<<<<<< HEAD
 +	if (USES_PRIMARY(bond->params.mode)) {
++=======
+ 
+ 	if (bond_uses_primary(bond)) {
+ 		struct slave *curr_active = bond_deref_active_protected(bond);
+ 
++>>>>>>> 4740d6382790 (bonding: add proper __rcu annotation for curr_active_slave)
  		/* write lock already acquired */
- 		if (bond->curr_active_slave) {
- 			err = dev_set_promiscuity(bond->curr_active_slave->dev,
- 						  inc);
- 		}
+ 		if (curr_active)
+ 			err = dev_set_promiscuity(curr_active->dev, inc);
  	} else {
  		struct slave *slave;
 -
 -		bond_for_each_slave(bond, slave, iter) {
 +		int i;
 +		bond_for_each_slave(bond, slave, i) {
  			err = dev_set_promiscuity(slave->dev, inc);
  			if (err)
  				return err;
@@@ -694,17 -520,19 +699,22 @@@
   */
  static int bond_set_allmulti(struct bonding *bond, int inc)
  {
 -	struct list_head *iter;
  	int err = 0;
++<<<<<<< HEAD
 +	if (USES_PRIMARY(bond->params.mode)) {
++=======
+ 
+ 	if (bond_uses_primary(bond)) {
+ 		struct slave *curr_active = bond_deref_active_protected(bond);
+ 
++>>>>>>> 4740d6382790 (bonding: add proper __rcu annotation for curr_active_slave)
  		/* write lock already acquired */
- 		if (bond->curr_active_slave) {
- 			err = dev_set_allmulti(bond->curr_active_slave->dev,
- 					       inc);
- 		}
+ 		if (curr_active)
+ 			err = dev_set_allmulti(curr_active->dev, inc);
  	} else {
  		struct slave *slave;
 -
 -		bond_for_each_slave(bond, slave, iter) {
 +		int i;
 +		bond_for_each_slave(bond, slave, i) {
  			err = dev_set_allmulti(slave->dev, inc);
  			if (err)
  				return err;
@@@ -1791,8 -1535,9 +1805,14 @@@ int bond_enslave(struct net_device *bon
  		 * anyway (it holds no special properties of the bond device),
  		 * so we can change it without calling change_active_interface()
  		 */
++<<<<<<< HEAD
 +		if (!bond->curr_active_slave && new_slave->link == BOND_LINK_UP)
 +			bond->curr_active_slave = new_slave;
++=======
+ 		if (!rcu_access_pointer(bond->curr_active_slave) &&
+ 		    new_slave->link == BOND_LINK_UP)
+ 			rcu_assign_pointer(bond->curr_active_slave, new_slave);
++>>>>>>> 4740d6382790 (bonding: add proper __rcu annotation for curr_active_slave)
  
  		break;
  	} /* switch(bond_mode) */
@@@ -1846,30 -1597,23 +1866,36 @@@
  err_unregister:
  	netdev_rx_handler_unregister(slave_dev);
  
 -err_detach:
 -	if (!bond_uses_primary(bond))
 -		bond_hw_addr_flush(bond_dev, slave_dev);
 +err_dest_symlinks:
 +	bond_destroy_slave_symlinks(bond_dev, slave_dev);
  
 -	vlan_vids_del_by_dev(slave_dev, bond_dev);
 +err_detach:
 +	if (!USES_PRIMARY(bond->params.mode)) {
 +		netif_addr_lock_bh(bond_dev);
 +		bond_mc_list_flush(bond_dev, slave_dev);
 +		netif_addr_unlock_bh(bond_dev);
 +	}
 +	bond_del_vlans_from_slave(bond, slave_dev);
 +	write_lock_bh(&bond->lock);
 +	bond_detach_slave(bond, new_slave);
  	if (bond->primary_slave == new_slave)
  		bond->primary_slave = NULL;
++<<<<<<< HEAD
 +	if (bond->curr_active_slave == new_slave) {
++=======
+ 	if (rcu_access_pointer(bond->curr_active_slave) == new_slave) {
+ 		block_netpoll_tx();
+ 		write_lock_bh(&bond->curr_slave_lock);
++>>>>>>> 4740d6382790 (bonding: add proper __rcu annotation for curr_active_slave)
  		bond_change_active_slave(bond, NULL);
 +		write_unlock_bh(&bond->lock);
 +		read_lock(&bond->lock);
 +		write_lock_bh(&bond->curr_slave_lock);
  		bond_select_active_slave(bond);
  		write_unlock_bh(&bond->curr_slave_lock);
 -		unblock_netpoll_tx();
 +		read_unlock(&bond->lock);
 +	} else {
 +		write_unlock_bh(&bond->lock);
  	}
  	slave_disable_netpoll(new_slave);
  
@@@ -2157,16 -1883,17 +2183,16 @@@ static int bond_slave_info_query(struc
  
  /*-------------------------------- Monitoring -------------------------------*/
  
- 
+ /* called with rcu_read_lock() */
  static int bond_miimon_inspect(struct bonding *bond)
  {
 -	int link_state, commit = 0;
 -	struct list_head *iter;
  	struct slave *slave;
 +	int i, link_state, commit = 0;
  	bool ignore_updelay;
  
- 	ignore_updelay = !bond->curr_active_slave ? true : false;
+ 	ignore_updelay = !rcu_dereference(bond->curr_active_slave);
  
 -	bond_for_each_slave_rcu(bond, slave, iter) {
 +	bond_for_each_slave(bond, slave, i) {
  		slave->new_link = BOND_LINK_NOCHANGE;
  
  		link_state = bond_check_dev_link(bond, slave->dev, 0);
@@@ -2646,24 -2413,20 +2672,30 @@@ void bond_loadbalance_arp_mon(struct wo
  	struct bonding *bond = container_of(work, struct bonding,
  					    arp_work.work);
  	struct slave *slave, *oldcurrent;
 -	struct list_head *iter;
 -	int do_failover = 0, slave_state_changed = 0;
 +	int do_failover = 0;
 +	int delta_in_ticks, extra_ticks;
 +	int i;
 +
 +	read_lock(&bond->lock);
 +
 +	delta_in_ticks = msecs_to_jiffies(bond->params.arp_interval);
 +	extra_ticks = delta_in_ticks / 2;
  
 -	if (!bond_has_slaves(bond))
 +	if (bond->slave_cnt == 0)
  		goto re_arm;
  
++<<<<<<< HEAD
 +	oldcurrent = bond->curr_active_slave;
++=======
+ 	rcu_read_lock();
+ 
+ 	oldcurrent = rcu_dereference(bond->curr_active_slave);
++>>>>>>> 4740d6382790 (bonding: add proper __rcu annotation for curr_active_slave)
  	/* see if any of the previous devices are up now (i.e. they have
  	 * xmt and rcv traffic). the curr_active_slave does not come into
 -	 * the picture unless it is null. also, slave->last_link_up is not
 -	 * needed here because we send an arp on each slave and give a slave
 -	 * as long as it needs to get the tx/rx within the delta.
 +	 * the picture unless it is null. also, slave->jiffies is not needed
 +	 * here because we send an arp on each slave and give a slave as
 +	 * long as it needs to get the tx/rx within the delta.
  	 * TODO: what about up/down delay in arp mode? it wasn't here before
  	 *       so it can wait
  	 */
@@@ -2866,11 -2612,9 +2898,17 @@@ static void bond_ab_arp_commit(struct b
  
  		case BOND_LINK_UP:
  			trans_start = dev_trans_start(slave->dev);
++<<<<<<< HEAD
 +			if ((!bond->curr_active_slave &&
 +			     time_in_range(jiffies,
 +					   trans_start - delta_in_ticks,
 +					   trans_start + delta_in_ticks + delta_in_ticks / 2)) ||
 +			    bond->curr_active_slave != slave) {
++=======
+ 			if (rtnl_dereference(bond->curr_active_slave) != slave ||
+ 			    (!rtnl_dereference(bond->curr_active_slave) &&
+ 			     bond_time_in_interval(bond, trans_start, 1))) {
++>>>>>>> 4740d6382790 (bonding: add proper __rcu annotation for curr_active_slave)
  				slave->link = BOND_LINK_UP;
  				if (bond->current_arp_slave) {
  					bond_set_slave_inactive_flags(
@@@ -2878,10 -2623,10 +2916,10 @@@
  					bond->current_arp_slave = NULL;
  				}
  
 -				pr_info("%s: link status definitely up for interface %s\n",
 +				pr_info("%s: link status definitely up for interface %s.\n",
  					bond->dev->name, slave->dev->name);
  
- 				if (!bond->curr_active_slave ||
+ 				if (!rtnl_dereference(bond->curr_active_slave) ||
  				    (slave == bond->primary_slave))
  					goto do_failover;
  
@@@ -3347,14 -3099,16 +3385,22 @@@ static int bond_open(struct net_device 
  
  	/* reset slave->backup and slave->inactive */
  	read_lock(&bond->lock);
 -	if (bond_has_slaves(bond)) {
 +	if (bond->slave_cnt > 0) {
  		read_lock(&bond->curr_slave_lock);
++<<<<<<< HEAD
 +		bond_for_each_slave(bond, slave, i) {
 +			if ((bond->params.mode == BOND_MODE_ACTIVEBACKUP)
 +				&& (slave != bond->curr_active_slave)) {
 +				bond_set_slave_inactive_flags(slave);
++=======
+ 		bond_for_each_slave(bond, slave, iter) {
+ 			if (bond_uses_primary(bond) &&
+ 			    slave != rcu_access_pointer(bond->curr_active_slave)) {
+ 				bond_set_slave_inactive_flags(slave,
+ 							      BOND_SLAVE_NOTIFY_NOW);
++>>>>>>> 4740d6382790 (bonding: add proper __rcu annotation for curr_active_slave)
  			} else {
 -				bond_set_slave_active_flags(slave,
 -							    BOND_SLAVE_NOTIFY_NOW);
 +				bond_set_slave_active_flags(slave);
  			}
  		}
  		read_unlock(&bond->curr_slave_lock);
diff --cc drivers/net/bonding/bonding.h
index 64c0cb81e478,d03d2ae4d3af..000000000000
--- a/drivers/net/bonding/bonding.h
+++ b/drivers/net/bonding/bonding.h
@@@ -216,8 -194,7 +216,12 @@@ struct slave 
   */
  struct bonding {
  	struct   net_device *dev; /* first - useful for panic debug */
++<<<<<<< HEAD
 +	struct   slave *first_slave;
 +	struct   slave *curr_active_slave;
++=======
+ 	struct   slave __rcu *curr_active_slave;
++>>>>>>> 4740d6382790 (bonding: add proper __rcu annotation for curr_active_slave)
  	struct   slave *current_arp_slave;
  	struct   slave *primary_slave;
  	bool     force_primary;
@@@ -258,6 -232,15 +262,18 @@@
  #define bond_slave_get_rtnl(dev) \
  	((struct slave *) rtnl_dereference(dev->rx_handler_data))
  
++<<<<<<< HEAD
++=======
+ #define bond_deref_active_protected(bond)				   \
+ 	rcu_dereference_protected(bond->curr_active_slave,		   \
+ 				  lockdep_is_held(&bond->curr_slave_lock))
+ 
+ struct bond_vlan_tag {
+ 	__be16		vlan_proto;
+ 	unsigned short	vlan_id;
+ };
+ 
++>>>>>>> 4740d6382790 (bonding: add proper __rcu annotation for curr_active_slave)
  /**
   * Returns NULL if the net_device does not belong to any of the bond's slaves
   *
* Unmerged path drivers/net/bonding/bond_options.c
* Unmerged path drivers/net/bonding/bond_alb.c
* Unmerged path drivers/net/bonding/bond_main.c
* Unmerged path drivers/net/bonding/bond_options.c
* Unmerged path drivers/net/bonding/bonding.h
