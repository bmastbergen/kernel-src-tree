tpm: fix raciness of PPI interface lookup

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
commit 0dc553652102c55a43eb1ab52e2049e478469f53
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/0dc55365.failed

Traversal of the ACPI device tree was not done right. PPI interface
should be looked up only from the ACPI device that is the platform
device for the TPM. This could cause problems with systems with
two TPM chips such as 4th gen Intel systems.

In addition, added the missing license and copyright platter to
the tpm_ppi.c.

	Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Reviewed-by: Jasob Gunthorpe <jason.gunthorpe@obsidianresearch.com>
	Reviewed-by: Stefan Berger <stefanb@linux.vnet.ibm.com>
	Tested-by: Scot Doyle <lkml14@scotdoyle.com>
	Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
(cherry picked from commit 0dc553652102c55a43eb1ab52e2049e478469f53)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/tpm/tpm-chip.c
#	drivers/char/tpm/tpm.h
#	drivers/char/tpm/tpm_ppi.c
#	drivers/char/tpm/tpm_tis.c
diff --cc drivers/char/tpm/tpm.h
index e638eb016b90,3409acf953f3..000000000000
--- a/drivers/char/tpm/tpm.h
+++ b/drivers/char/tpm/tpm.h
@@@ -94,6 -95,13 +95,16 @@@ struct tpm_vendor_specific 
  #define TPM_VID_WINBOND  0x1050
  #define TPM_VID_STM      0x104A
  
++<<<<<<< HEAD
++=======
+ #define TPM_PPI_VERSION_LEN		3
+ 
+ enum tpm_chip_flags {
+ 	TPM_CHIP_FLAG_REGISTERED	= BIT(0),
+ 	TPM_CHIP_FLAG_PPI		= BIT(1),
+ };
+ 
++>>>>>>> 0dc553652102 (tpm: fix raciness of PPI interface lookup)
  struct tpm_chip {
  	struct device *dev;	/* Device stuff */
  	const struct tpm_class_ops *ops;
@@@ -109,8 -118,12 +120,13 @@@
  
  	struct dentry **bios_dir;
  
+ #ifdef CONFIG_ACPI
+ 	acpi_handle acpi_dev_handle;
+ 	char ppi_version[TPM_PPI_VERSION_LEN + 1];
+ #endif /* CONFIG_ACPI */
+ 
  	struct list_head list;
 +	void (*release) (struct device *);
  };
  
  #define to_tpm_chip(n) container_of(n, struct tpm_chip, vendor)
diff --cc drivers/char/tpm/tpm_ppi.c
index 1e9cc11ac76a,af48c56f642f..000000000000
--- a/drivers/char/tpm/tpm_ppi.c
+++ b/drivers/char/tpm/tpm_ppi.c
@@@ -1,16 -1,25 +1,35 @@@
+ /*
+  * Copyright (C) 2012-2014 Intel Corporation
+  *
+  * Authors:
+  * Xiaoyan Zhang <xiaoyan.zhang@intel.com>
+  * Jiang Liu <jiang.liu@linux.intel.com>
+  * Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
+  *
+  * Maintained by: <tpmdd-devel@lists.sourceforge.net>
+  *
+  * This file contains implementation of the sysfs interface for PPI.
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; version 2
+  * of the License.
+  */
+ 
+ 
  #include <linux/acpi.h>
 +#include <acpi/acpi_drivers.h>
  #include "tpm.h"
  
 +static const u8 tpm_ppi_uuid[] = {
 +	0xA6, 0xFA, 0xDD, 0x3D,
 +	0x1B, 0x36,
 +	0xB4, 0x4E,
 +	0xA4, 0x24,
 +	0x8D, 0x10, 0x08, 0x9D, 0x16, 0x53
 +};
 +static char *tpm_device_name = "TPM";
 +
  #define TPM_PPI_REVISION_ID	1
  #define TPM_PPI_FN_VERSION	1
  #define TPM_PPI_FN_SUBREQ	2
@@@ -22,92 -31,45 +41,126 @@@
  #define PPI_TPM_REQ_MAX		22
  #define PPI_VS_REQ_START	128
  #define PPI_VS_REQ_END		255
- #define PPI_VERSION_LEN		3
  
++<<<<<<< HEAD
 +static acpi_status ppi_callback(acpi_handle handle, u32 level, void *context,
 +				void **return_value)
 +{
 +	acpi_status status = AE_OK;
 +	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 +
 +	if (ACPI_SUCCESS(acpi_get_name(handle, ACPI_SINGLE_NAME, &buffer))) {
 +		if (strstr(buffer.pointer, context) != NULL) {
 +			*return_value = handle;
 +			status = AE_CTRL_TERMINATE;
 +		}
 +		kfree(buffer.pointer);
 +	}
 +
 +	return status;
 +}
 +
 +static inline void ppi_assign_params(union acpi_object params[4],
 +				     u64 function_num)
 +{
 +	params[0].type = ACPI_TYPE_BUFFER;
 +	params[0].buffer.length = sizeof(tpm_ppi_uuid);
 +	params[0].buffer.pointer = (char *)tpm_ppi_uuid;
 +	params[1].type = ACPI_TYPE_INTEGER;
 +	params[1].integer.value = TPM_PPI_REVISION_ID;
 +	params[2].type = ACPI_TYPE_INTEGER;
 +	params[2].integer.value = function_num;
 +	params[3].type = ACPI_TYPE_PACKAGE;
 +	params[3].package.count = 0;
 +	params[3].package.elements = NULL;
++=======
+ static const u8 tpm_ppi_uuid[] = {
+ 	0xA6, 0xFA, 0xDD, 0x3D,
+ 	0x1B, 0x36,
+ 	0xB4, 0x4E,
+ 	0xA4, 0x24,
+ 	0x8D, 0x10, 0x08, 0x9D, 0x16, 0x53
+ };
+ 
+ static inline union acpi_object *
+ tpm_eval_dsm(acpi_handle ppi_handle, int func, acpi_object_type type,
+ 	     union acpi_object *argv4)
+ {
+ 	BUG_ON(!ppi_handle);
+ 	return acpi_evaluate_dsm_typed(ppi_handle, tpm_ppi_uuid,
+ 				       TPM_PPI_REVISION_ID,
+ 				       func, argv4, type);
++>>>>>>> 0dc553652102 (tpm: fix raciness of PPI interface lookup)
  }
  
  static ssize_t tpm_show_ppi_version(struct device *dev,
  				    struct device_attribute *attr, char *buf)
  {
++<<<<<<< HEAD
 +	acpi_handle handle;
 +	acpi_status status;
 +	struct acpi_object_list input;
 +	struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
 +	union acpi_object params[4];
 +	union acpi_object *obj;
 +
 +	input.count = 4;
 +	ppi_assign_params(params, TPM_PPI_FN_VERSION);
 +	input.pointer = params;
 +	status = acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
 +				     ACPI_UINT32_MAX, ppi_callback, NULL,
 +				     tpm_device_name, &handle);
 +	if (ACPI_FAILURE(status))
 +		return -ENXIO;
 +
 +	status = acpi_evaluate_object_typed(handle, "_DSM", &input, &output,
 +					 ACPI_TYPE_STRING);
 +	if (ACPI_FAILURE(status))
 +		return -ENOMEM;
 +	obj = (union acpi_object *)output.pointer;
 +	status = scnprintf(buf, PAGE_SIZE, "%s\n", obj->string.pointer);
 +	kfree(output.pointer);
 +	return status;
++=======
+ 	struct tpm_chip *chip = dev_get_drvdata(dev);
+ 
+ 	return scnprintf(buf, PAGE_SIZE, "%s\n", chip->ppi_version);
++>>>>>>> 0dc553652102 (tpm: fix raciness of PPI interface lookup)
  }
  
  static ssize_t tpm_show_ppi_request(struct device *dev,
  				    struct device_attribute *attr, char *buf)
  {
++<<<<<<< HEAD
 +	acpi_handle handle;
 +	acpi_status status;
 +	struct acpi_object_list input;
 +	struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
 +	union acpi_object params[4];
 +	union acpi_object *ret_obj;
 +
 +	input.count = 4;
 +	ppi_assign_params(params, TPM_PPI_FN_GETREQ);
 +	input.pointer = params;
 +	status = acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
 +				     ACPI_UINT32_MAX, ppi_callback, NULL,
 +				     tpm_device_name, &handle);
 +	if (ACPI_FAILURE(status))
++=======
+ 	ssize_t size = -EINVAL;
+ 	union acpi_object *obj;
+ 	struct tpm_chip *chip = dev_get_drvdata(dev);
+ 
+ 	obj = tpm_eval_dsm(chip->acpi_dev_handle, TPM_PPI_FN_GETREQ,
+ 			   ACPI_TYPE_PACKAGE, NULL);
+ 	if (!obj)
++>>>>>>> 0dc553652102 (tpm: fix raciness of PPI interface lookup)
  		return -ENXIO;
  
 +	status = acpi_evaluate_object_typed(handle, "_DSM", &input, &output,
 +					    ACPI_TYPE_PACKAGE);
 +	if (ACPI_FAILURE(status))
 +		return -ENOMEM;
  	/*
  	 * output.pointer should be of package type, including two integers.
  	 * The first is function return code, 0 means success and 1 means
@@@ -138,89 -95,70 +191,137 @@@ static ssize_t tpm_store_ppi_request(st
  				     struct device_attribute *attr,
  				     const char *buf, size_t count)
  {
 +	char version[PPI_VERSION_LEN + 1];
 +	acpi_handle handle;
 +	acpi_status status;
 +	struct acpi_object_list input;
 +	struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
 +	union acpi_object params[4];
 +	union acpi_object obj;
  	u32 req;
  	u64 ret;
++<<<<<<< HEAD
++=======
+ 	int func = TPM_PPI_FN_SUBREQ;
+ 	union acpi_object *obj, tmp;
+ 	union acpi_object argv4 = ACPI_INIT_DSM_ARGV4(1, &tmp);
+ 	struct tpm_chip *chip = dev_get_drvdata(dev);
++>>>>>>> 0dc553652102 (tpm: fix raciness of PPI interface lookup)
 +
 +	input.count = 4;
 +	ppi_assign_params(params, TPM_PPI_FN_VERSION);
 +	input.pointer = params;
 +	status = acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
 +				     ACPI_UINT32_MAX, ppi_callback, NULL,
 +				     tpm_device_name, &handle);
 +	if (ACPI_FAILURE(status))
 +		return -ENXIO;
  
 +	status = acpi_evaluate_object_typed(handle, "_DSM", &input, &output,
 +					    ACPI_TYPE_STRING);
 +	if (ACPI_FAILURE(status))
 +		return -ENOMEM;
 +	strlcpy(version,
 +		((union acpi_object *)output.pointer)->string.pointer,
 +		PPI_VERSION_LEN + 1);
 +	kfree(output.pointer);
 +	output.length = ACPI_ALLOCATE_BUFFER;
 +	output.pointer = NULL;
  	/*
  	 * the function to submit TPM operation request to pre-os environment
  	 * is updated with function index from SUBREQ to SUBREQ2 since PPI
  	 * version 1.1
  	 */
++<<<<<<< HEAD
 +	if (strcmp(version, "1.1") == -1)
 +		params[2].integer.value = TPM_PPI_FN_SUBREQ;
 +	else
 +		params[2].integer.value = TPM_PPI_FN_SUBREQ2;
++=======
+ 	if (acpi_check_dsm(chip->acpi_dev_handle, tpm_ppi_uuid,
+ 			   TPM_PPI_REVISION_ID, 1 << TPM_PPI_FN_SUBREQ2))
+ 		func = TPM_PPI_FN_SUBREQ2;
+ 
++>>>>>>> 0dc553652102 (tpm: fix raciness of PPI interface lookup)
  	/*
  	 * PPI spec defines params[3].type as ACPI_TYPE_PACKAGE. Some BIOS
  	 * accept buffer/string/integer type, but some BIOS accept buffer/
  	 * string/package type. For PPI version 1.0 and 1.1, use buffer type
  	 * for compatibility, and use package type since 1.2 according to spec.
  	 */
++<<<<<<< HEAD
 +	if (strcmp(version, "1.2") == -1) {
 +		params[3].type = ACPI_TYPE_BUFFER;
 +		params[3].buffer.length = sizeof(req);
 +		sscanf(buf, "%d", &req);
 +		params[3].buffer.pointer = (char *)&req;
 +	} else {
 +		params[3].package.count = 1;
 +		obj.type = ACPI_TYPE_INTEGER;
 +		sscanf(buf, "%llu", &obj.integer.value);
 +		params[3].package.elements = &obj;
++=======
+ 	if (strcmp(chip->ppi_version, "1.2") < 0) {
+ 		if (sscanf(buf, "%d", &req) != 1)
+ 			return -EINVAL;
+ 		argv4.type = ACPI_TYPE_BUFFER;
+ 		argv4.buffer.length = sizeof(req);
+ 		argv4.buffer.pointer = (u8 *)&req;
+ 	} else {
+ 		tmp.type = ACPI_TYPE_INTEGER;
+ 		if (sscanf(buf, "%llu", &tmp.integer.value) != 1)
+ 			return -EINVAL;
+ 	}
+ 
+ 	obj = tpm_eval_dsm(chip->acpi_dev_handle, func, ACPI_TYPE_INTEGER,
+ 			   &argv4);
+ 	if (!obj) {
+ 		return -ENXIO;
+ 	} else {
+ 		ret = obj->integer.value;
+ 		ACPI_FREE(obj);
++>>>>>>> 0dc553652102 (tpm: fix raciness of PPI interface lookup)
  	}
  
 +	status = acpi_evaluate_object_typed(handle, "_DSM", &input, &output,
 +					    ACPI_TYPE_INTEGER);
 +	if (ACPI_FAILURE(status))
 +		return -ENOMEM;
 +	ret = ((union acpi_object *)output.pointer)->integer.value;
  	if (ret == 0)
 -		return (acpi_status)count;
 -
 -	return (ret == 1) ? -EPERM : -EFAULT;
 +		status = (acpi_status)count;
 +	else if (ret == 1)
 +		status = -EPERM;
 +	else
 +		status = -EFAULT;
 +	kfree(output.pointer);
 +	return status;
  }
  
  static ssize_t tpm_show_ppi_transition_action(struct device *dev,
  					      struct device_attribute *attr,
  					      char *buf)
  {
 -	u32 ret;
 +	char version[PPI_VERSION_LEN + 1];
 +	acpi_handle handle;
  	acpi_status status;
++<<<<<<< HEAD
 +	struct acpi_object_list input;
 +	struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
 +	union acpi_object params[4];
 +	u32 ret;
 +	char *info[] = {
++=======
+ 	union acpi_object *obj = NULL;
+ 	union acpi_object tmp = {
+ 		.buffer.type = ACPI_TYPE_BUFFER,
+ 		.buffer.length = 0,
+ 		.buffer.pointer = NULL
+ 	};
+ 	struct tpm_chip *chip = dev_get_drvdata(dev);
+ 
+ 	static char *info[] = {
++>>>>>>> 0dc553652102 (tpm: fix raciness of PPI interface lookup)
  		"None",
  		"Shutdown",
  		"Reboot",
@@@ -248,20 -171,17 +349,32 @@@
  	 * (e.g. Capella with PPI 1.0) need integer/string/buffer type, so for
  	 * compatibility, define params[3].type as buffer, if PPI version < 1.2
  	 */
++<<<<<<< HEAD
 +	if (strcmp(version, "1.2") == -1) {
 +		params[3].type = ACPI_TYPE_BUFFER;
 +		params[3].buffer.length =  0;
 +		params[3].buffer.pointer = NULL;
++=======
+ 	if (strcmp(chip->ppi_version, "1.2") < 0)
+ 		obj = &tmp;
+ 	obj = tpm_eval_dsm(chip->acpi_dev_handle, TPM_PPI_FN_GETACT,
+ 			   ACPI_TYPE_INTEGER, obj);
+ 	if (!obj) {
+ 		return -ENXIO;
+ 	} else {
+ 		ret = obj->integer.value;
+ 		ACPI_FREE(obj);
++>>>>>>> 0dc553652102 (tpm: fix raciness of PPI interface lookup)
  	}
 -
 +	params[2].integer.value = TPM_PPI_FN_GETACT;
 +	kfree(output.pointer);
 +	output.length = ACPI_ALLOCATE_BUFFER;
 +	output.pointer = NULL;
 +	status = acpi_evaluate_object_typed(handle, "_DSM", &input, &output,
 +					    ACPI_TYPE_INTEGER);
 +	if (ACPI_FAILURE(status))
 +		return -ENOMEM;
 +	ret = ((union acpi_object *)output.pointer)->integer.value;
  	if (ret < ARRAY_SIZE(info) - 1)
  		status = scnprintf(buf, PAGE_SIZE, "%d: %s\n", ret, info[ret]);
  	else
@@@ -275,27 -194,16 +388,38 @@@ static ssize_t tpm_show_ppi_response(st
  				     struct device_attribute *attr,
  				     char *buf)
  {
++<<<<<<< HEAD
 +	acpi_handle handle;
 +	acpi_status status;
 +	struct acpi_object_list input;
 +	struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
 +	union acpi_object params[4];
 +	union acpi_object *ret_obj;
 +	u64 req;
 +
 +	input.count = 4;
 +	ppi_assign_params(params, TPM_PPI_FN_GETRSP);
 +	input.pointer = params;
 +	status = acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
 +				     ACPI_UINT32_MAX, ppi_callback, NULL,
 +				     tpm_device_name, &handle);
 +	if (ACPI_FAILURE(status))
++=======
+ 	acpi_status status = -EINVAL;
+ 	union acpi_object *obj, *ret_obj;
+ 	u64 req, res;
+ 	struct tpm_chip *chip = dev_get_drvdata(dev);
+ 
+ 	obj = tpm_eval_dsm(chip->acpi_dev_handle, TPM_PPI_FN_GETRSP,
+ 			   ACPI_TYPE_PACKAGE, NULL);
+ 	if (!obj)
++>>>>>>> 0dc553652102 (tpm: fix raciness of PPI interface lookup)
  		return -ENXIO;
  
 +	status = acpi_evaluate_object_typed(handle, "_DSM", &input, &output,
 +					    ACPI_TYPE_PACKAGE);
 +	if (ACPI_FAILURE(status))
 +		return -ENOMEM;
  	/*
  	 * parameter output.pointer should be of package type, including
  	 * 3 integers. The first means function return code, the second means
@@@ -351,60 -251,39 +475,73 @@@ cleanup
  	return status;
  }
  
- static ssize_t show_ppi_operations(char *buf, u32 start, u32 end)
+ static ssize_t show_ppi_operations(acpi_handle dev_handle, char *buf, u32 start,
+ 				   u32 end)
  {
 +	char *str = buf;
 +	char version[PPI_VERSION_LEN + 1];
 +	acpi_handle handle;
 +	acpi_status status;
 +	struct acpi_object_list input;
 +	struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
 +	union acpi_object params[4];
 +	union acpi_object obj;
  	int i;
  	u32 ret;
 -	char *str = buf;
 -	union acpi_object *obj, tmp;
 -	union acpi_object argv = ACPI_INIT_DSM_ARGV4(1, &tmp);
 -
 -	static char *info[] = {
 +	char *info[] = {
  		"Not implemented",
  		"BIOS only",
  		"Blocked for OS by BIOS",
  		"User required",
  		"User not required",
  	};
 +	input.count = 4;
 +	ppi_assign_params(params, TPM_PPI_FN_VERSION);
 +	input.pointer = params;
 +	status = acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
 +				     ACPI_UINT32_MAX, ppi_callback, NULL,
 +				     tpm_device_name, &handle);
 +	if (ACPI_FAILURE(status))
 +		return -ENXIO;
  
++<<<<<<< HEAD
 +	status = acpi_evaluate_object_typed(handle, "_DSM", &input, &output,
 +					 ACPI_TYPE_STRING);
 +	if (ACPI_FAILURE(status))
 +		return -ENOMEM;
 +
 +	strlcpy(version,
 +		((union acpi_object *)output.pointer)->string.pointer,
 +		PPI_VERSION_LEN + 1);
 +	kfree(output.pointer);
 +	output.length = ACPI_ALLOCATE_BUFFER;
 +	output.pointer = NULL;
 +	if (strcmp(version, "1.2") == -1)
++=======
+ 	if (!acpi_check_dsm(dev_handle, tpm_ppi_uuid, TPM_PPI_REVISION_ID,
+ 			    1 << TPM_PPI_FN_GETOPR))
++>>>>>>> 0dc553652102 (tpm: fix raciness of PPI interface lookup)
  		return -EPERM;
  
 -	tmp.integer.type = ACPI_TYPE_INTEGER;
 +	params[2].integer.value = TPM_PPI_FN_GETOPR;
 +	params[3].package.count = 1;
 +	obj.type = ACPI_TYPE_INTEGER;
 +	params[3].package.elements = &obj;
  	for (i = start; i <= end; i++) {
++<<<<<<< HEAD
 +		obj.integer.value = i;
 +		status = acpi_evaluate_object_typed(handle, "_DSM",
 +			 &input, &output, ACPI_TYPE_INTEGER);
 +		if (ACPI_FAILURE(status))
++=======
+ 		tmp.integer.value = i;
+ 		obj = tpm_eval_dsm(dev_handle, TPM_PPI_FN_GETOPR,
+ 				   ACPI_TYPE_INTEGER, &argv);
+ 		if (!obj) {
++>>>>>>> 0dc553652102 (tpm: fix raciness of PPI interface lookup)
  			return -ENOMEM;
 -		} else {
 -			ret = obj->integer.value;
 -			ACPI_FREE(obj);
 -		}
  
 +		ret = ((union acpi_object *)output.pointer)->integer.value;
  		if (ret > 0 && ret < ARRAY_SIZE(info))
  			str += scnprintf(str, PAGE_SIZE, "%d %d: %s\n",
  					 i, ret, info[ret]);
@@@ -451,12 -334,38 +594,46 @@@ static struct attribute_group ppi_attr_
  	.attrs = ppi_attrs
  };
  
- int tpm_add_ppi(struct kobject *parent)
+ int tpm_add_ppi(struct tpm_chip *chip)
  {
++<<<<<<< HEAD
 +	return sysfs_create_group(parent, &ppi_attr_grp);
++=======
+ 	union acpi_object *obj;
+ 	int rc;
+ 
+ 	if (!chip->acpi_dev_handle)
+ 		return 0;
+ 
+ 	if (!acpi_check_dsm(chip->acpi_dev_handle, tpm_ppi_uuid,
+ 			    TPM_PPI_REVISION_ID, 1 << TPM_PPI_FN_VERSION))
+ 		return 0;
+ 
+ 	/* Cache PPI version string. */
+ 	obj = acpi_evaluate_dsm_typed(chip->acpi_dev_handle, tpm_ppi_uuid,
+ 				      TPM_PPI_REVISION_ID, TPM_PPI_FN_VERSION,
+ 				      NULL, ACPI_TYPE_STRING);
+ 	if (obj) {
+ 		strlcpy(chip->ppi_version, obj->string.pointer,
+ 			sizeof(chip->ppi_version));
+ 		ACPI_FREE(obj);
+ 	}
+ 
+ 	rc = sysfs_create_group(&chip->dev->kobj, &ppi_attr_grp);
+ 
+ 	if (!rc)
+ 		chip->flags |= TPM_CHIP_FLAG_PPI;
+ 
+ 	return rc;
++>>>>>>> 0dc553652102 (tpm: fix raciness of PPI interface lookup)
  }
  
- void tpm_remove_ppi(struct kobject *parent)
+ void tpm_remove_ppi(struct tpm_chip *chip)
  {
++<<<<<<< HEAD
 +	sysfs_remove_group(parent, &ppi_attr_grp);
++=======
+ 	if (chip->flags & TPM_CHIP_FLAG_PPI)
+ 		sysfs_remove_group(&chip->dev->kobj, &ppi_attr_grp);
++>>>>>>> 0dc553652102 (tpm: fix raciness of PPI interface lookup)
  }
diff --cc drivers/char/tpm/tpm_tis.c
index 51350cd0847e,9695850d2afa..000000000000
--- a/drivers/char/tpm/tpm_tis.c
+++ b/drivers/char/tpm/tpm_tis.c
@@@ -572,8 -569,20 +572,25 @@@ static bool interrupts = true
  module_param(interrupts, bool, 0444);
  MODULE_PARM_DESC(interrupts, "Enable interrupts");
  
++<<<<<<< HEAD
 +static int tpm_tis_init(struct device *dev, resource_size_t start,
 +			resource_size_t len, unsigned int irq)
++=======
+ static void tpm_tis_remove(struct tpm_chip *chip)
+ {
+ 	iowrite32(~TPM_GLOBAL_INT_ENABLE &
+ 		  ioread32(chip->vendor.iobase +
+ 			   TPM_INT_ENABLE(chip->vendor.
+ 					  locality)),
+ 		  chip->vendor.iobase +
+ 		  TPM_INT_ENABLE(chip->vendor.locality));
+ 	release_locality(chip, chip->vendor.locality, 1);
+ }
+ 
+ static int tpm_tis_init(struct device *dev, acpi_handle acpi_dev_handle,
+ 			resource_size_t start, resource_size_t len,
+ 			unsigned int irq)
++>>>>>>> 0dc553652102 (tpm: fix raciness of PPI interface lookup)
  {
  	u32 vendor, intfcaps, intmask;
  	int rc, i, irq_s, irq_e, probe;
@@@ -583,15 -592,17 +600,16 @@@
  	priv = devm_kzalloc(dev, sizeof(struct priv_data), GFP_KERNEL);
  	if (priv == NULL)
  		return -ENOMEM;
 -
 -	chip = tpmm_chip_alloc(dev, &tpm_tis);
 -	if (IS_ERR(chip))
 -		return PTR_ERR(chip);
 -
 +	if (!(chip = tpm_register_hardware(dev, &tpm_tis)))
 +		return -ENODEV;
  	chip->vendor.priv = priv;
+ 	chip->acpi_dev_handle = acpi_dev_handle;
  
 -	chip->vendor.iobase = devm_ioremap(dev, start, len);
 -	if (!chip->vendor.iobase)
 -		return -EIO;
 +	chip->vendor.iobase = ioremap(start, len);
 +	if (!chip->vendor.iobase) {
 +		rc = -EIO;
 +		goto out_err;
 +	}
  
  	/* Default timeouts */
  	chip->vendor.timeout_a = msecs_to_jiffies(TIS_SHORT_TIMEOUT);
* Unmerged path drivers/char/tpm/tpm-chip.c
* Unmerged path drivers/char/tpm/tpm-chip.c
* Unmerged path drivers/char/tpm/tpm.h
* Unmerged path drivers/char/tpm/tpm_ppi.c
* Unmerged path drivers/char/tpm/tpm_tis.c
