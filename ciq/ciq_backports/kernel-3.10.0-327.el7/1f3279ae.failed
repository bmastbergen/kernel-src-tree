tcp: avoid retransmits of TCP packets hanging in host queues

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Eric Dumazet <edumazet@google.com>
commit 1f3279ae0c13cd742731726b0ed195d5f09b14e4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/1f3279ae.failed

In commit 0e280af026a5 ("tcp: introduce TCPSpuriousRtxHostQueues SNMP
counter") we added a logic to detect when a packet was retransmitted
while the prior clone was still in a qdisc or driver queue.

We are now confident we can do better, and catch the problem before
we fragment a TSO packet before retransmit, or in TLP path.

This patch fully exploits the logic by simply canceling the spurious
retransmit.
Original packet is in a queue and will eventually leave the host.

This helps to avoid network collapses when some events make the RTO
estimations very wrong, particularly when dealing with huge number of
sockets with synchronized blast.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: Neal Cardwell <ncardwell@google.com>
	Signed-off-by: Yuchung Cheng <ycheng@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1f3279ae0c13cd742731726b0ed195d5f09b14e4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_output.c
diff --cc net/ipv4/tcp_output.c
index d61225e4f4f2,20847de991ea..000000000000
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@@ -875,19 -878,8 +875,24 @@@ static int tcp_transmit_skb(struct soc
  	BUG_ON(!skb || !tcp_skb_pcount(skb));
  
  	if (clone_it) {
++<<<<<<< HEAD
 +		const struct sk_buff *fclone = skb + 1;
 +
 +		/* If congestion control is doing timestamping, we must
 +		 * take such a timestamp before we potentially clone/copy.
 +		 */
 +		if (icsk->icsk_ca_ops->flags & TCP_CONG_RTT_STAMP)
 +			__net_timestamp(skb);
 +
 +		if (unlikely(skb->fclone == SKB_FCLONE_ORIG &&
 +			     fclone->fclone == SKB_FCLONE_CLONE))
 +			NET_INC_STATS_BH(sock_net(sk),
 +					 LINUX_MIB_TCPSPURIOUS_RTX_HOSTQUEUES);
 +
++=======
+ 		skb_mstamp_get(&skb->skb_mstamp);
+ 
++>>>>>>> 1f3279ae0c13 (tcp: avoid retransmits of TCP packets hanging in host queues)
  		if (unlikely(skb_cloned(skb)))
  			skb = pskb_copy(skb, gfp_mask);
  		else
* Unmerged path net/ipv4/tcp_output.c
