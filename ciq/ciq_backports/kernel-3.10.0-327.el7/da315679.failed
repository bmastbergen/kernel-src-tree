net/mlx4_core: Fixed memory leak and incorrect refcount in mlx4_load_one

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [netdrv] mlx4_core: Fixed memory leak and incorrect refcount in mlx4_load_one (Amir Vadai) [1164527 1164530 1164531 1164536 1164537]
Rebuild_FUZZ: 97.14%
commit-author Matan Barak <matanb@mellanox.com>
commit da315679e80635021e98de1306ff4eee0759ba57
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/da315679.failed

The current mlx4_load_one has a memory leak as it always allocates
dev_cap, but frees it only on error.

In addition, even if VFs exist when mlx4_load_one is called,
we still need to notify probed VFs that we're loading (by
incrementing pf_loading).

Fixes: a0eacca948d2 ('net/mlx4_core: Refactor mlx4_load_one')
	Signed-off-by: Matan Barak <matanb@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit da315679e80635021e98de1306ff4eee0759ba57)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx4/main.c
diff --cc drivers/net/ethernet/mellanox/mlx4/main.c
index 794737489226,c2ef266ad7c1..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/main.c
+++ b/drivers/net/ethernet/mellanox/mlx4/main.c
@@@ -2445,6 -2605,14 +2446,17 @@@ static int mlx4_load_one(struct pci_de
  			mlx4_err(dev, "Failed to reset HCA, aborting\n");
  			goto err_sriov;
  		}
++<<<<<<< HEAD
++=======
+ 
+ 		if (total_vfs) {
+ 			dev->flags = MLX4_FLAG_MASTER;
+ 			existing_vfs = pci_num_vf(pdev);
+ 			if (existing_vfs)
+ 				dev->flags |= MLX4_FLAG_SRIOV;
+ 			dev->num_vfs = total_vfs;
+ 		}
++>>>>>>> da315679e806 (net/mlx4_core: Fixed memory leak and incorrect refcount in mlx4_load_one)
  	}
  
  slave_start:
@@@ -2476,6 -2645,59 +2488,62 @@@
  		goto err_mfunc;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (mlx4_is_master(dev)) {
+ 		/* when we hit the goto slave_start below, dev_cap already initialized */
+ 		if (!dev_cap) {
+ 			dev_cap = kzalloc(sizeof(*dev_cap), GFP_KERNEL);
+ 
+ 			if (!dev_cap) {
+ 				err = -ENOMEM;
+ 				goto err_fw;
+ 			}
+ 
+ 			err = mlx4_QUERY_DEV_CAP(dev, dev_cap);
+ 			if (err) {
+ 				mlx4_err(dev, "QUERY_DEV_CAP command failed, aborting.\n");
+ 				goto err_fw;
+ 			}
+ 
+ 			if (mlx4_check_dev_cap(dev, dev_cap, nvfs))
+ 				goto err_fw;
+ 
+ 			if (!(dev_cap->flags2 & MLX4_DEV_CAP_FLAG2_SYS_EQS)) {
+ 				u64 dev_flags = mlx4_enable_sriov(dev, pdev, total_vfs,
+ 								  existing_vfs);
+ 
+ 				mlx4_cmd_cleanup(dev, MLX4_CMD_CLEANUP_ALL);
+ 				dev->flags = dev_flags;
+ 				if (!SRIOV_VALID_STATE(dev->flags)) {
+ 					mlx4_err(dev, "Invalid SRIOV state\n");
+ 					goto err_sriov;
+ 				}
+ 				err = mlx4_reset(dev);
+ 				if (err) {
+ 					mlx4_err(dev, "Failed to reset HCA, aborting.\n");
+ 					goto err_sriov;
+ 				}
+ 				goto slave_start;
+ 			}
+ 		} else {
+ 			/* Legacy mode FW requires SRIOV to be enabled before
+ 			 * doing QUERY_DEV_CAP, since max_eq's value is different if
+ 			 * SRIOV is enabled.
+ 			 */
+ 			memset(dev_cap, 0, sizeof(*dev_cap));
+ 			err = mlx4_QUERY_DEV_CAP(dev, dev_cap);
+ 			if (err) {
+ 				mlx4_err(dev, "QUERY_DEV_CAP command failed, aborting.\n");
+ 				goto err_fw;
+ 			}
+ 
+ 			if (mlx4_check_dev_cap(dev, dev_cap, nvfs))
+ 				goto err_fw;
+ 		}
+ 	}
+ 
++>>>>>>> da315679e806 (net/mlx4_core: Fixed memory leak and incorrect refcount in mlx4_load_one)
  	err = mlx4_init_hca(dev);
  	if (err) {
  		if (err == -EACCES) {
* Unmerged path drivers/net/ethernet/mellanox/mlx4/main.c
