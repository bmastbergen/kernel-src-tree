scsi: fix memory leak with scsi-mq

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [scsi] fix memory leak with scsi-mq (Ewan Milne) [1248739]
Rebuild_FUZZ: 90.32%
commit-author Tony Battersby <tonyb@cybernetics.com>
commit 0c958ecc69c277b25f38f72bc6d18ab145e8167c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/0c958ecc.failed

Fix a memory leak with scsi-mq triggered by commands with large data
transfer length.

__sg_alloc_table() sets both table->nents and table->orig_nents to the
same value.  When the scatterlist is DMA-mapped, table->nents is
overwritten with the (possibly smaller) size of the DMA-mapped
scatterlist, while table->orig_nents retains the original size of the
allocated scatterlist.  scsi_free_sgtable() should therefore check
orig_nents instead of nents, and all code that initializes sdb->table
without calling __sg_alloc_table() should set both nents and orig_nents.

Fixes: d285203cf647 ("scsi: add support for a blk-mq based I/O path.")
	Cc: <stable@vger.kernel.org> # 3.17+
	Signed-off-by: Tony Battersby <tonyb@cybernetics.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Ewan D. Milne <emilne@redhat.com>
	Signed-off-by: James Bottomley <JBottomley@Odin.com>
(cherry picked from commit 0c958ecc69c277b25f38f72bc6d18ab145e8167c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/scsi_lib.c
diff --cc drivers/scsi/scsi_lib.c
index 4ddd184ab02c,448ebdaa3d69..000000000000
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@@ -553,22 -581,33 +553,40 @@@ static struct scatterlist *scsi_sg_allo
  	return mempool_alloc(sgp->pool, gfp_mask);
  }
  
 -static void scsi_free_sgtable(struct scsi_data_buffer *sdb, bool mq)
 +static void scsi_free_sgtable(struct scsi_data_buffer *sdb)
  {
++<<<<<<< HEAD
 +	__sg_free_table(&sdb->table, SCSI_MAX_SG_SEGMENTS, false, scsi_sg_free);
++=======
+ 	if (mq && sdb->table.orig_nents <= SCSI_MAX_SG_SEGMENTS)
+ 		return;
+ 	__sg_free_table(&sdb->table, SCSI_MAX_SG_SEGMENTS, mq, scsi_sg_free);
++>>>>>>> 0c958ecc69c2 (scsi: fix memory leak with scsi-mq)
  }
  
 -static int scsi_alloc_sgtable(struct scsi_data_buffer *sdb, int nents, bool mq)
 +static int scsi_alloc_sgtable(struct scsi_data_buffer *sdb, int nents,
 +			      gfp_t gfp_mask)
  {
 -	struct scatterlist *first_chunk = NULL;
  	int ret;
  
  	BUG_ON(!nents);
  
++<<<<<<< HEAD
++=======
+ 	if (mq) {
+ 		if (nents <= SCSI_MAX_SG_SEGMENTS) {
+ 			sdb->table.nents = sdb->table.orig_nents = nents;
+ 			sg_init_table(sdb->table.sgl, nents);
+ 			return 0;
+ 		}
+ 		first_chunk = sdb->table.sgl;
+ 	}
+ 
++>>>>>>> 0c958ecc69c2 (scsi: fix memory leak with scsi-mq)
  	ret = __sg_alloc_table(&sdb->table, nents, SCSI_MAX_SG_SEGMENTS,
 -			       first_chunk, GFP_ATOMIC, scsi_sg_alloc);
 +			       NULL, gfp_mask, scsi_sg_alloc);
  	if (unlikely(ret))
 -		scsi_free_sgtable(sdb, mq);
 +		scsi_free_sgtable(sdb);
  	return ret;
  }
  
diff --git a/drivers/scsi/scsi_error.c b/drivers/scsi/scsi_error.c
index b74813882330..f23e4ace3928 100644
--- a/drivers/scsi/scsi_error.c
+++ b/drivers/scsi/scsi_error.c
@@ -954,7 +954,7 @@ void scsi_eh_prep_cmnd(struct scsi_cmnd *scmd, struct scsi_eh_save *ses,
 			    scmd->sdb.length);
 		scmd->sdb.table.sgl = &ses->sense_sgl;
 		scmd->sc_data_direction = DMA_FROM_DEVICE;
-		scmd->sdb.table.nents = 1;
+		scmd->sdb.table.nents = scmd->sdb.table.orig_nents = 1;
 		scmd->cmnd[0] = REQUEST_SENSE;
 		scmd->cmnd[4] = scmd->sdb.length;
 		scmd->cmd_len = COMMAND_SIZE(scmd->cmnd[0]);
* Unmerged path drivers/scsi/scsi_lib.c
