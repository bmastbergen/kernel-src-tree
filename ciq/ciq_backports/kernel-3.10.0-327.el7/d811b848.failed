scsi: use sdev as argument for sense code printing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [scsi] use sdev as argument for sense code printing (Ewan Milne) [1124082]
Rebuild_FUZZ: 93.62%
commit-author Hannes Reinecke <hare@suse.de>
commit d811b848ebb78a1135658aa20a80e31994df47f7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/d811b848.failed

We should be using the standard dev_printk() variants for
sense code printing.

[hch: remove __scsi_print_sense call in xen-scsiback, Acked by Juergen]
[hch: folded bracing fix from Dan Carpenter]
	Signed-off-by: Hannes Reinecke <hare@suse.de>
	Reviewed-by: Robert Elliott <elliott@hp.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit d811b848ebb78a1135658aa20a80e31994df47f7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/ufs/ufshcd.c
#	drivers/xen/xen-scsiback.c
diff --cc drivers/scsi/ufs/ufshcd.c
index c32a478df81b,eb3997ed8e73..000000000000
--- a/drivers/scsi/ufs/ufshcd.c
+++ b/drivers/scsi/ufs/ufshcd.c
@@@ -1523,61 -4234,994 +1523,156 @@@ static struct scsi_host_template ufshcd
  	.sg_tablesize		= SG_ALL,
  	.cmd_per_lun		= UFSHCD_CMD_PER_LUN,
  	.can_queue		= UFSHCD_CAN_QUEUE,
 -	.max_host_blocked	= 1,
  };
  
 -static int ufshcd_config_vreg_load(struct device *dev, struct ufs_vreg *vreg,
 -				   int ua)
 -{
 -	int ret = 0;
 -	struct regulator *reg = vreg->reg;
 -	const char *name = vreg->name;
 -
 -	BUG_ON(!vreg);
 -
 -	ret = regulator_set_optimum_mode(reg, ua);
 -	if (ret >= 0) {
 -		/*
 -		 * regulator_set_optimum_mode() returns new regulator
 -		 * mode upon success.
 -		 */
 -		ret = 0;
 -	} else {
 -		dev_err(dev, "%s: %s set optimum mode(ua=%d) failed, err=%d\n",
 -				__func__, name, ua, ret);
 -	}
 -
 -	return ret;
 -}
 -
 -static inline int ufshcd_config_vreg_lpm(struct ufs_hba *hba,
 -					 struct ufs_vreg *vreg)
 -{
 -	return ufshcd_config_vreg_load(hba->dev, vreg, UFS_VREG_LPM_LOAD_UA);
 -}
 -
 -static inline int ufshcd_config_vreg_hpm(struct ufs_hba *hba,
 -					 struct ufs_vreg *vreg)
 -{
 -	return ufshcd_config_vreg_load(hba->dev, vreg, vreg->max_uA);
 -}
 -
 -static int ufshcd_config_vreg(struct device *dev,
 -		struct ufs_vreg *vreg, bool on)
 -{
 -	int ret = 0;
 -	struct regulator *reg = vreg->reg;
 -	const char *name = vreg->name;
 -	int min_uV, uA_load;
 -
 -	BUG_ON(!vreg);
 -
 -	if (regulator_count_voltages(reg) > 0) {
 -		min_uV = on ? vreg->min_uV : 0;
 -		ret = regulator_set_voltage(reg, min_uV, vreg->max_uV);
 -		if (ret) {
 -			dev_err(dev, "%s: %s set voltage failed, err=%d\n",
 -					__func__, name, ret);
 -			goto out;
 -		}
 -
 -		uA_load = on ? vreg->max_uA : 0;
 -		ret = ufshcd_config_vreg_load(dev, vreg, uA_load);
 -		if (ret)
 -			goto out;
 -	}
 -out:
 -	return ret;
 -}
 -
 -static int ufshcd_enable_vreg(struct device *dev, struct ufs_vreg *vreg)
 -{
 -	int ret = 0;
 -
 -	if (!vreg || vreg->enabled)
 -		goto out;
 -
 -	ret = ufshcd_config_vreg(dev, vreg, true);
 -	if (!ret)
 -		ret = regulator_enable(vreg->reg);
 -
 -	if (!ret)
 -		vreg->enabled = true;
 -	else
 -		dev_err(dev, "%s: %s enable failed, err=%d\n",
 -				__func__, vreg->name, ret);
 -out:
 -	return ret;
 -}
 -
 -static int ufshcd_disable_vreg(struct device *dev, struct ufs_vreg *vreg)
 -{
 -	int ret = 0;
 -
 -	if (!vreg || !vreg->enabled)
 -		goto out;
 -
 -	ret = regulator_disable(vreg->reg);
 -
 -	if (!ret) {
 -		/* ignore errors on applying disable config */
 -		ufshcd_config_vreg(dev, vreg, false);
 -		vreg->enabled = false;
 -	} else {
 -		dev_err(dev, "%s: %s disable failed, err=%d\n",
 -				__func__, vreg->name, ret);
 -	}
 -out:
 -	return ret;
 -}
 -
 -static int ufshcd_setup_vreg(struct ufs_hba *hba, bool on)
 -{
 -	int ret = 0;
 -	struct device *dev = hba->dev;
 -	struct ufs_vreg_info *info = &hba->vreg_info;
 -
 -	if (!info)
 -		goto out;
 -
 -	ret = ufshcd_toggle_vreg(dev, info->vcc, on);
 -	if (ret)
 -		goto out;
 -
 -	ret = ufshcd_toggle_vreg(dev, info->vccq, on);
 -	if (ret)
 -		goto out;
 -
 -	ret = ufshcd_toggle_vreg(dev, info->vccq2, on);
 -	if (ret)
 -		goto out;
 -
 -out:
 -	if (ret) {
 -		ufshcd_toggle_vreg(dev, info->vccq2, false);
 -		ufshcd_toggle_vreg(dev, info->vccq, false);
 -		ufshcd_toggle_vreg(dev, info->vcc, false);
 -	}
 -	return ret;
 -}
 -
 -static int ufshcd_setup_hba_vreg(struct ufs_hba *hba, bool on)
 -{
 -	struct ufs_vreg_info *info = &hba->vreg_info;
 -
 -	if (info)
 -		return ufshcd_toggle_vreg(hba->dev, info->vdd_hba, on);
 -
 -	return 0;
 -}
 -
 -static int ufshcd_get_vreg(struct device *dev, struct ufs_vreg *vreg)
 -{
 -	int ret = 0;
 -
 -	if (!vreg)
 -		goto out;
 -
 -	vreg->reg = devm_regulator_get(dev, vreg->name);
 -	if (IS_ERR(vreg->reg)) {
 -		ret = PTR_ERR(vreg->reg);
 -		dev_err(dev, "%s: %s get failed, err=%d\n",
 -				__func__, vreg->name, ret);
 -	}
 -out:
 -	return ret;
 -}
 -
 -static int ufshcd_init_vreg(struct ufs_hba *hba)
 -{
 -	int ret = 0;
 -	struct device *dev = hba->dev;
 -	struct ufs_vreg_info *info = &hba->vreg_info;
 -
 -	if (!info)
 -		goto out;
 -
 -	ret = ufshcd_get_vreg(dev, info->vcc);
 -	if (ret)
 -		goto out;
 -
 -	ret = ufshcd_get_vreg(dev, info->vccq);
 -	if (ret)
 -		goto out;
 -
 -	ret = ufshcd_get_vreg(dev, info->vccq2);
 -out:
 -	return ret;
 -}
 -
 -static int ufshcd_init_hba_vreg(struct ufs_hba *hba)
 -{
 -	struct ufs_vreg_info *info = &hba->vreg_info;
 -
 -	if (info)
 -		return ufshcd_get_vreg(hba->dev, info->vdd_hba);
 -
 -	return 0;
 -}
 -
 -static int __ufshcd_setup_clocks(struct ufs_hba *hba, bool on,
 -					bool skip_ref_clk)
 -{
 -	int ret = 0;
 -	struct ufs_clk_info *clki;
 -	struct list_head *head = &hba->clk_list_head;
 -	unsigned long flags;
 -
 -	if (!head || list_empty(head))
 -		goto out;
 -
 -	list_for_each_entry(clki, head, list) {
 -		if (!IS_ERR_OR_NULL(clki->clk)) {
 -			if (skip_ref_clk && !strcmp(clki->name, "ref_clk"))
 -				continue;
 -
 -			if (on && !clki->enabled) {
 -				ret = clk_prepare_enable(clki->clk);
 -				if (ret) {
 -					dev_err(hba->dev, "%s: %s prepare enable failed, %d\n",
 -						__func__, clki->name, ret);
 -					goto out;
 -				}
 -			} else if (!on && clki->enabled) {
 -				clk_disable_unprepare(clki->clk);
 -			}
 -			clki->enabled = on;
 -			dev_dbg(hba->dev, "%s: clk: %s %sabled\n", __func__,
 -					clki->name, on ? "en" : "dis");
 -		}
 -	}
 -
 -	if (hba->vops && hba->vops->setup_clocks)
 -		ret = hba->vops->setup_clocks(hba, on);
 -out:
 -	if (ret) {
 -		list_for_each_entry(clki, head, list) {
 -			if (!IS_ERR_OR_NULL(clki->clk) && clki->enabled)
 -				clk_disable_unprepare(clki->clk);
 -		}
 -	} else if (!ret && on) {
 -		spin_lock_irqsave(hba->host->host_lock, flags);
 -		hba->clk_gating.state = CLKS_ON;
 -		spin_unlock_irqrestore(hba->host->host_lock, flags);
 -	}
 -	return ret;
 -}
 -
 -static int ufshcd_setup_clocks(struct ufs_hba *hba, bool on)
 -{
 -	return  __ufshcd_setup_clocks(hba, on, false);
 -}
 -
 -static int ufshcd_init_clocks(struct ufs_hba *hba)
 -{
 -	int ret = 0;
 -	struct ufs_clk_info *clki;
 -	struct device *dev = hba->dev;
 -	struct list_head *head = &hba->clk_list_head;
 -
 -	if (!head || list_empty(head))
 -		goto out;
 -
 -	list_for_each_entry(clki, head, list) {
 -		if (!clki->name)
 -			continue;
 -
 -		clki->clk = devm_clk_get(dev, clki->name);
 -		if (IS_ERR(clki->clk)) {
 -			ret = PTR_ERR(clki->clk);
 -			dev_err(dev, "%s: %s clk get failed, %d\n",
 -					__func__, clki->name, ret);
 -			goto out;
 -		}
 -
 -		if (clki->max_freq) {
 -			ret = clk_set_rate(clki->clk, clki->max_freq);
 -			if (ret) {
 -				dev_err(hba->dev, "%s: %s clk set rate(%dHz) failed, %d\n",
 -					__func__, clki->name,
 -					clki->max_freq, ret);
 -				goto out;
 -			}
 -			clki->curr_freq = clki->max_freq;
 -		}
 -		dev_dbg(dev, "%s: clk: %s, rate: %lu\n", __func__,
 -				clki->name, clk_get_rate(clki->clk));
 -	}
 -out:
 -	return ret;
 -}
 -
 -static int ufshcd_variant_hba_init(struct ufs_hba *hba)
 -{
 -	int err = 0;
 -
 -	if (!hba->vops)
 -		goto out;
 -
 -	if (hba->vops->init) {
 -		err = hba->vops->init(hba);
 -		if (err)
 -			goto out;
 -	}
 -
 -	if (hba->vops->setup_regulators) {
 -		err = hba->vops->setup_regulators(hba, true);
 -		if (err)
 -			goto out_exit;
 -	}
 -
 -	goto out;
 -
 -out_exit:
 -	if (hba->vops->exit)
 -		hba->vops->exit(hba);
 -out:
 -	if (err)
 -		dev_err(hba->dev, "%s: variant %s init failed err %d\n",
 -			__func__, hba->vops ? hba->vops->name : "", err);
 -	return err;
 -}
 -
 -static void ufshcd_variant_hba_exit(struct ufs_hba *hba)
 -{
 -	if (!hba->vops)
 -		return;
 -
 -	if (hba->vops->setup_clocks)
 -		hba->vops->setup_clocks(hba, false);
 -
 -	if (hba->vops->setup_regulators)
 -		hba->vops->setup_regulators(hba, false);
 -
 -	if (hba->vops->exit)
 -		hba->vops->exit(hba);
 -}
 -
 -static int ufshcd_hba_init(struct ufs_hba *hba)
 -{
 -	int err;
 -
 -	/*
 -	 * Handle host controller power separately from the UFS device power
 -	 * rails as it will help controlling the UFS host controller power
 -	 * collapse easily which is different than UFS device power collapse.
 -	 * Also, enable the host controller power before we go ahead with rest
 -	 * of the initialization here.
 -	 */
 -	err = ufshcd_init_hba_vreg(hba);
 -	if (err)
 -		goto out;
 -
 -	err = ufshcd_setup_hba_vreg(hba, true);
 -	if (err)
 -		goto out;
 -
 -	err = ufshcd_init_clocks(hba);
 -	if (err)
 -		goto out_disable_hba_vreg;
 -
 -	err = ufshcd_setup_clocks(hba, true);
 -	if (err)
 -		goto out_disable_hba_vreg;
 -
 -	err = ufshcd_init_vreg(hba);
 -	if (err)
 -		goto out_disable_clks;
 -
 -	err = ufshcd_setup_vreg(hba, true);
 -	if (err)
 -		goto out_disable_clks;
 -
 -	err = ufshcd_variant_hba_init(hba);
 -	if (err)
 -		goto out_disable_vreg;
 -
 -	hba->is_powered = true;
 -	goto out;
 -
 -out_disable_vreg:
 -	ufshcd_setup_vreg(hba, false);
 -out_disable_clks:
 -	ufshcd_setup_clocks(hba, false);
 -out_disable_hba_vreg:
 -	ufshcd_setup_hba_vreg(hba, false);
 -out:
 -	return err;
 -}
 -
 -static void ufshcd_hba_exit(struct ufs_hba *hba)
 -{
 -	if (hba->is_powered) {
 -		ufshcd_variant_hba_exit(hba);
 -		ufshcd_setup_vreg(hba, false);
 -		ufshcd_setup_clocks(hba, false);
 -		ufshcd_setup_hba_vreg(hba, false);
 -		hba->is_powered = false;
 -	}
 -}
 -
 -static int
 -ufshcd_send_request_sense(struct ufs_hba *hba, struct scsi_device *sdp)
 -{
 -	unsigned char cmd[6] = {REQUEST_SENSE,
 -				0,
 -				0,
 -				0,
 -				SCSI_SENSE_BUFFERSIZE,
 -				0};
 -	char *buffer;
 -	int ret;
 -
 -	buffer = kzalloc(SCSI_SENSE_BUFFERSIZE, GFP_KERNEL);
 -	if (!buffer) {
 -		ret = -ENOMEM;
 -		goto out;
 -	}
 -
 -	ret = scsi_execute_req_flags(sdp, cmd, DMA_FROM_DEVICE, buffer,
 -				SCSI_SENSE_BUFFERSIZE, NULL,
 -				msecs_to_jiffies(1000), 3, NULL, REQ_PM);
 -	if (ret)
 -		pr_err("%s: failed with err %d\n", __func__, ret);
 -
 -	kfree(buffer);
 -out:
 -	return ret;
 -}
 -
 -/**
 - * ufshcd_set_dev_pwr_mode - sends START STOP UNIT command to set device
 - *			     power mode
 - * @hba: per adapter instance
 - * @pwr_mode: device power mode to set
 - *
 - * Returns 0 if requested power mode is set successfully
 - * Returns non-zero if failed to set the requested power mode
 - */
 -static int ufshcd_set_dev_pwr_mode(struct ufs_hba *hba,
 -				     enum ufs_dev_pwr_mode pwr_mode)
 -{
 -	unsigned char cmd[6] = { START_STOP };
 -	struct scsi_sense_hdr sshdr;
 -	struct scsi_device *sdp = hba->sdev_ufs_device;
 -	int ret;
 -
 -	if (!sdp || !scsi_device_online(sdp))
 -		return -ENODEV;
 -
 -	/*
 -	 * If scsi commands fail, the scsi mid-layer schedules scsi error-
 -	 * handling, which would wait for host to be resumed. Since we know
 -	 * we are functional while we are here, skip host resume in error
 -	 * handling context.
 -	 */
 -	hba->host->eh_noresume = 1;
 -	if (hba->wlun_dev_clr_ua) {
 -		ret = ufshcd_send_request_sense(hba, sdp);
 -		if (ret)
 -			goto out;
 -		/* Unit attention condition is cleared now */
 -		hba->wlun_dev_clr_ua = false;
 -	}
 -
 -	cmd[4] = pwr_mode << 4;
 -
 -	/*
 -	 * Current function would be generally called from the power management
 -	 * callbacks hence set the REQ_PM flag so that it doesn't resume the
 -	 * already suspended childs.
 -	 */
 -	ret = scsi_execute_req_flags(sdp, cmd, DMA_NONE, NULL, 0, &sshdr,
 -				     START_STOP_TIMEOUT, 0, NULL, REQ_PM);
 -	if (ret) {
 -		sdev_printk(KERN_WARNING, sdp,
 -			  "START_STOP failed for power mode: %d\n", pwr_mode);
 -		scsi_show_result(ret);
 -		if (driver_byte(ret) & DRIVER_SENSE) {
 -			scsi_show_sense_hdr(sdp, NULL, &sshdr);
 -			scsi_show_extd_sense(sdp, NULL, sshdr.asc, sshdr.ascq);
 -		}
 -	}
 -
 -	if (!ret)
 -		hba->curr_dev_pwr_mode = pwr_mode;
 -out:
 -	hba->host->eh_noresume = 0;
 -	return ret;
 -}
 -
 -static int ufshcd_link_state_transition(struct ufs_hba *hba,
 -					enum uic_link_state req_link_state,
 -					int check_for_bkops)
 -{
 -	int ret = 0;
 -
 -	if (req_link_state == hba->uic_link_state)
 -		return 0;
 -
 -	if (req_link_state == UIC_LINK_HIBERN8_STATE) {
 -		ret = ufshcd_uic_hibern8_enter(hba);
 -		if (!ret)
 -			ufshcd_set_link_hibern8(hba);
 -		else
 -			goto out;
 -	}
 -	/*
 -	 * If autobkops is enabled, link can't be turned off because
 -	 * turning off the link would also turn off the device.
 -	 */
 -	else if ((req_link_state == UIC_LINK_OFF_STATE) &&
 -		   (!check_for_bkops || (check_for_bkops &&
 -		    !hba->auto_bkops_enabled))) {
 -		/*
 -		 * Change controller state to "reset state" which
 -		 * should also put the link in off/reset state
 -		 */
 -		ufshcd_hba_stop(hba);
 -		/*
 -		 * TODO: Check if we need any delay to make sure that
 -		 * controller is reset
 -		 */
 -		ufshcd_set_link_off(hba);
 -	}
 -
 -out:
 -	return ret;
 -}
 -
 -static void ufshcd_vreg_set_lpm(struct ufs_hba *hba)
 -{
 -	/*
 -	 * If UFS device is either in UFS_Sleep turn off VCC rail to save some
 -	 * power.
 -	 *
 -	 * If UFS device and link is in OFF state, all power supplies (VCC,
 -	 * VCCQ, VCCQ2) can be turned off if power on write protect is not
 -	 * required. If UFS link is inactive (Hibern8 or OFF state) and device
 -	 * is in sleep state, put VCCQ & VCCQ2 rails in LPM mode.
 -	 *
 -	 * Ignore the error returned by ufshcd_toggle_vreg() as device is anyway
 -	 * in low power state which would save some power.
 -	 */
 -	if (ufshcd_is_ufs_dev_poweroff(hba) && ufshcd_is_link_off(hba) &&
 -	    !hba->dev_info.is_lu_power_on_wp) {
 -		ufshcd_setup_vreg(hba, false);
 -	} else if (!ufshcd_is_ufs_dev_active(hba)) {
 -		ufshcd_toggle_vreg(hba->dev, hba->vreg_info.vcc, false);
 -		if (!ufshcd_is_link_active(hba)) {
 -			ufshcd_config_vreg_lpm(hba, hba->vreg_info.vccq);
 -			ufshcd_config_vreg_lpm(hba, hba->vreg_info.vccq2);
 -		}
 -	}
 -}
 -
 -static int ufshcd_vreg_set_hpm(struct ufs_hba *hba)
 -{
 -	int ret = 0;
 -
 -	if (ufshcd_is_ufs_dev_poweroff(hba) && ufshcd_is_link_off(hba) &&
 -	    !hba->dev_info.is_lu_power_on_wp) {
 -		ret = ufshcd_setup_vreg(hba, true);
 -	} else if (!ufshcd_is_ufs_dev_active(hba)) {
 -		ret = ufshcd_toggle_vreg(hba->dev, hba->vreg_info.vcc, true);
 -		if (!ret && !ufshcd_is_link_active(hba)) {
 -			ret = ufshcd_config_vreg_hpm(hba, hba->vreg_info.vccq);
 -			if (ret)
 -				goto vcc_disable;
 -			ret = ufshcd_config_vreg_hpm(hba, hba->vreg_info.vccq2);
 -			if (ret)
 -				goto vccq_lpm;
 -		}
 -	}
 -	goto out;
 -
 -vccq_lpm:
 -	ufshcd_config_vreg_lpm(hba, hba->vreg_info.vccq);
 -vcc_disable:
 -	ufshcd_toggle_vreg(hba->dev, hba->vreg_info.vcc, false);
 -out:
 -	return ret;
 -}
 -
 -static void ufshcd_hba_vreg_set_lpm(struct ufs_hba *hba)
 -{
 -	if (ufshcd_is_link_off(hba))
 -		ufshcd_setup_hba_vreg(hba, false);
 -}
 -
 -static void ufshcd_hba_vreg_set_hpm(struct ufs_hba *hba)
 -{
 -	if (ufshcd_is_link_off(hba))
 -		ufshcd_setup_hba_vreg(hba, true);
 -}
 -
 -/**
 - * ufshcd_suspend - helper function for suspend operations
 - * @hba: per adapter instance
 - * @pm_op: desired low power operation type
 - *
 - * This function will try to put the UFS device and link into low power
 - * mode based on the "rpm_lvl" (Runtime PM level) or "spm_lvl"
 - * (System PM level).
 - *
 - * If this function is called during shutdown, it will make sure that
 - * both UFS device and UFS link is powered off.
 - *
 - * NOTE: UFS device & link must be active before we enter in this function.
 - *
 - * Returns 0 for success and non-zero for failure
 - */
 -static int ufshcd_suspend(struct ufs_hba *hba, enum ufs_pm_op pm_op)
 -{
 -	int ret = 0;
 -	enum ufs_pm_level pm_lvl;
 -	enum ufs_dev_pwr_mode req_dev_pwr_mode;
 -	enum uic_link_state req_link_state;
 -
 -	hba->pm_op_in_progress = 1;
 -	if (!ufshcd_is_shutdown_pm(pm_op)) {
 -		pm_lvl = ufshcd_is_runtime_pm(pm_op) ?
 -			 hba->rpm_lvl : hba->spm_lvl;
 -		req_dev_pwr_mode = ufs_get_pm_lvl_to_dev_pwr_mode(pm_lvl);
 -		req_link_state = ufs_get_pm_lvl_to_link_pwr_state(pm_lvl);
 -	} else {
 -		req_dev_pwr_mode = UFS_POWERDOWN_PWR_MODE;
 -		req_link_state = UIC_LINK_OFF_STATE;
 -	}
 -
 -	/*
 -	 * If we can't transition into any of the low power modes
 -	 * just gate the clocks.
 -	 */
 -	ufshcd_hold(hba, false);
 -	hba->clk_gating.is_suspended = true;
 -
 -	if (req_dev_pwr_mode == UFS_ACTIVE_PWR_MODE &&
 -			req_link_state == UIC_LINK_ACTIVE_STATE) {
 -		goto disable_clks;
 -	}
 -
 -	if ((req_dev_pwr_mode == hba->curr_dev_pwr_mode) &&
 -	    (req_link_state == hba->uic_link_state))
 -		goto out;
 -
 -	/* UFS device & link must be active before we enter in this function */
 -	if (!ufshcd_is_ufs_dev_active(hba) || !ufshcd_is_link_active(hba)) {
 -		ret = -EINVAL;
 -		goto out;
 -	}
 -
 -	if (ufshcd_is_runtime_pm(pm_op)) {
 -		if (ufshcd_can_autobkops_during_suspend(hba)) {
 -			/*
 -			 * The device is idle with no requests in the queue,
 -			 * allow background operations if bkops status shows
 -			 * that performance might be impacted.
 -			 */
 -			ret = ufshcd_urgent_bkops(hba);
 -			if (ret)
 -				goto enable_gating;
 -		} else {
 -			/* make sure that auto bkops is disabled */
 -			ufshcd_disable_auto_bkops(hba);
 -		}
 -	}
 -
 -	if ((req_dev_pwr_mode != hba->curr_dev_pwr_mode) &&
 -	     ((ufshcd_is_runtime_pm(pm_op) && !hba->auto_bkops_enabled) ||
 -	       !ufshcd_is_runtime_pm(pm_op))) {
 -		/* ensure that bkops is disabled */
 -		ufshcd_disable_auto_bkops(hba);
 -		ret = ufshcd_set_dev_pwr_mode(hba, req_dev_pwr_mode);
 -		if (ret)
 -			goto enable_gating;
 -	}
 -
 -	ret = ufshcd_link_state_transition(hba, req_link_state, 1);
 -	if (ret)
 -		goto set_dev_active;
 -
 -	ufshcd_vreg_set_lpm(hba);
 -
 -disable_clks:
 -	/*
 -	 * The clock scaling needs access to controller registers. Hence, Wait
 -	 * for pending clock scaling work to be done before clocks are
 -	 * turned off.
 -	 */
 -	if (ufshcd_is_clkscaling_enabled(hba)) {
 -		devfreq_suspend_device(hba->devfreq);
 -		hba->clk_scaling.window_start_t = 0;
 -	}
 +/**
 + * ufshcd_suspend - suspend power management function
 + * @hba: per adapter instance
 + * @state: power state
 + *
 + * Returns -ENOSYS
 + */
 +int ufshcd_suspend(struct ufs_hba *hba, pm_message_t state)
 +{
  	/*
 -	 * Call vendor specific suspend callback. As these callbacks may access
 -	 * vendor specific host controller register space call them before the
 -	 * host clocks are ON.
 +	 * TODO:
 +	 * 1. Block SCSI requests from SCSI midlayer
 +	 * 2. Change the internal driver state to non operational
 +	 * 3. Set UTRLRSR and UTMRLRSR bits to zero
 +	 * 4. Wait until outstanding commands are completed
 +	 * 5. Set HCE to zero to send the UFS host controller to reset state
  	 */
 -	if (hba->vops && hba->vops->suspend) {
 -		ret = hba->vops->suspend(hba, pm_op);
 -		if (ret)
 -			goto set_link_active;
 -	}
 -
 -	if (hba->vops && hba->vops->setup_clocks) {
 -		ret = hba->vops->setup_clocks(hba, false);
 -		if (ret)
 -			goto vops_resume;
 -	}
 -
 -	if (!ufshcd_is_link_active(hba))
 -		ufshcd_setup_clocks(hba, false);
 -	else
 -		/* If link is active, device ref_clk can't be switched off */
 -		__ufshcd_setup_clocks(hba, false, true);
  
 -	hba->clk_gating.state = CLKS_OFF;
 -	/*
 -	 * Disable the host irq as host controller as there won't be any
 -	 * host controller trasanction expected till resume.
 -	 */
 -	ufshcd_disable_irq(hba);
 -	/* Put the host controller in low power mode if possible */
 -	ufshcd_hba_vreg_set_lpm(hba);
 -	goto out;
 -
 -vops_resume:
 -	if (hba->vops && hba->vops->resume)
 -		hba->vops->resume(hba, pm_op);
 -set_link_active:
 -	ufshcd_vreg_set_hpm(hba);
 -	if (ufshcd_is_link_hibern8(hba) && !ufshcd_uic_hibern8_exit(hba))
 -		ufshcd_set_link_active(hba);
 -	else if (ufshcd_is_link_off(hba))
 -		ufshcd_host_reset_and_restore(hba);
 -set_dev_active:
 -	if (!ufshcd_set_dev_pwr_mode(hba, UFS_ACTIVE_PWR_MODE))
 -		ufshcd_disable_auto_bkops(hba);
 -enable_gating:
 -	hba->clk_gating.is_suspended = false;
 -	ufshcd_release(hba);
 -out:
 -	hba->pm_op_in_progress = 0;
 -	return ret;
 +	return -ENOSYS;
  }
 +EXPORT_SYMBOL_GPL(ufshcd_suspend);
  
  /**
 - * ufshcd_resume - helper function for resume operations
 + * ufshcd_resume - resume power management function
   * @hba: per adapter instance
 - * @pm_op: runtime PM or system PM
   *
 - * This function basically brings the UFS device, UniPro link and controller
 - * to active state.
 - *
 - * Returns 0 for success and non-zero for failure
 + * Returns -ENOSYS
   */
 -static int ufshcd_resume(struct ufs_hba *hba, enum ufs_pm_op pm_op)
++<<<<<<< HEAD
 +int ufshcd_resume(struct ufs_hba *hba)
++=======
++static int ufshcd_set_dev_pwr_mode(struct ufs_hba *hba,
++				     enum ufs_dev_pwr_mode pwr_mode)
+ {
++	unsigned char cmd[6] = { START_STOP };
++	struct scsi_sense_hdr sshdr;
++	struct scsi_device *sdp = hba->sdev_ufs_device;
+ 	int ret;
 -	enum uic_link_state old_link_state;
+ 
 -	hba->pm_op_in_progress = 1;
 -	old_link_state = hba->uic_link_state;
 -
 -	ufshcd_hba_vreg_set_hpm(hba);
 -	/* Make sure clocks are enabled before accessing controller */
 -	ret = ufshcd_setup_clocks(hba, true);
 -	if (ret)
 -		goto out;
 -
 -	/* enable the host irq as host controller would be active soon */
 -	ret = ufshcd_enable_irq(hba);
 -	if (ret)
 -		goto disable_irq_and_vops_clks;
 -
 -	ret = ufshcd_vreg_set_hpm(hba);
 -	if (ret)
 -		goto disable_irq_and_vops_clks;
++	if (!sdp || !scsi_device_online(sdp))
++		return -ENODEV;
+ 
+ 	/*
 -	 * Call vendor specific resume callback. As these callbacks may access
 -	 * vendor specific host controller register space call them when the
 -	 * host clocks are ON.
++	 * If scsi commands fail, the scsi mid-layer schedules scsi error-
++	 * handling, which would wait for host to be resumed. Since we know
++	 * we are functional while we are here, skip host resume in error
++	 * handling context.
+ 	 */
 -	if (hba->vops && hba->vops->resume) {
 -		ret = hba->vops->resume(hba, pm_op);
++	hba->host->eh_noresume = 1;
++	if (hba->wlun_dev_clr_ua) {
++		ret = ufshcd_send_request_sense(hba, sdp);
+ 		if (ret)
 -			goto disable_vreg;
 -	}
 -
 -	if (ufshcd_is_link_hibern8(hba)) {
 -		ret = ufshcd_uic_hibern8_exit(hba);
 -		if (!ret)
 -			ufshcd_set_link_active(hba);
 -		else
 -			goto vendor_suspend;
 -	} else if (ufshcd_is_link_off(hba)) {
 -		ret = ufshcd_host_reset_and_restore(hba);
 -		/*
 -		 * ufshcd_host_reset_and_restore() should have already
 -		 * set the link state as active
 -		 */
 -		if (ret || !ufshcd_is_link_active(hba))
 -			goto vendor_suspend;
++			goto out;
++		/* Unit attention condition is cleared now */
++		hba->wlun_dev_clr_ua = false;
+ 	}
+ 
 -	if (!ufshcd_is_ufs_dev_active(hba)) {
 -		ret = ufshcd_set_dev_pwr_mode(hba, UFS_ACTIVE_PWR_MODE);
 -		if (ret)
 -			goto set_old_link_state;
 -	}
++	cmd[4] = pwr_mode << 4;
+ 
+ 	/*
 -	 * If BKOPs operations are urgently needed at this moment then
 -	 * keep auto-bkops enabled or else disable it.
++	 * Current function would be generally called from the power management
++	 * callbacks hence set the REQ_PM flag so that it doesn't resume the
++	 * already suspended childs.
+ 	 */
 -	ufshcd_urgent_bkops(hba);
 -	hba->clk_gating.is_suspended = false;
 -
 -	if (ufshcd_is_clkscaling_enabled(hba))
 -		devfreq_resume_device(hba->devfreq);
 -
 -	/* Schedule clock gating in case of no access to UFS device yet */
 -	ufshcd_release(hba);
 -	goto out;
 -
 -set_old_link_state:
 -	ufshcd_link_state_transition(hba, old_link_state, 0);
 -vendor_suspend:
 -	if (hba->vops && hba->vops->suspend)
 -		hba->vops->suspend(hba, pm_op);
 -disable_vreg:
 -	ufshcd_vreg_set_lpm(hba);
 -disable_irq_and_vops_clks:
 -	ufshcd_disable_irq(hba);
 -	ufshcd_setup_clocks(hba, false);
++	ret = scsi_execute_req_flags(sdp, cmd, DMA_NONE, NULL, 0, &sshdr,
++				     START_STOP_TIMEOUT, 0, NULL, REQ_PM);
++	if (ret) {
++		sdev_printk(KERN_WARNING, sdp,
++			  "START_STOP failed for power mode: %d\n", pwr_mode);
++		scsi_show_result(ret);
++		if (driver_byte(ret) & DRIVER_SENSE) {
++			scsi_show_sense_hdr(sdp, NULL, &sshdr);
++			scsi_show_extd_sense(sdp, NULL, sshdr.asc, sshdr.ascq);
++		}
++	}
++
++	if (!ret)
++		hba->curr_dev_pwr_mode = pwr_mode;
+ out:
 -	hba->pm_op_in_progress = 0;
++	hba->host->eh_noresume = 0;
+ 	return ret;
+ }
+ 
 -/**
 - * ufshcd_system_suspend - system suspend routine
 - * @hba: per adapter instance
 - * @pm_op: runtime PM or system PM
 - *
 - * Check the description of ufshcd_suspend() function for more details.
 - *
 - * Returns 0 for success and non-zero for failure
 - */
 -int ufshcd_system_suspend(struct ufs_hba *hba)
++static int ufshcd_link_state_transition(struct ufs_hba *hba,
++					enum uic_link_state req_link_state,
++					int check_for_bkops)
+ {
+ 	int ret = 0;
+ 
 -	if (!hba || !hba->is_powered)
 -		goto out;
 -
 -	if (pm_runtime_suspended(hba->dev)) {
 -		if (hba->rpm_lvl == hba->spm_lvl)
 -			/*
 -			 * There is possibility that device may still be in
 -			 * active state during the runtime suspend.
 -			 */
 -			if ((ufs_get_pm_lvl_to_dev_pwr_mode(hba->spm_lvl) ==
 -			    hba->curr_dev_pwr_mode) && !hba->auto_bkops_enabled)
 -				goto out;
++	if (req_link_state == hba->uic_link_state)
++		return 0;
+ 
++	if (req_link_state == UIC_LINK_HIBERN8_STATE) {
++		ret = ufshcd_uic_hibern8_enter(hba);
++		if (!ret)
++			ufshcd_set_link_hibern8(hba);
++		else
++			goto out;
++	}
++	/*
++	 * If autobkops is enabled, link can't be turned off because
++	 * turning off the link would also turn off the device.
++	 */
++	else if ((req_link_state == UIC_LINK_OFF_STATE) &&
++		   (!check_for_bkops || (check_for_bkops &&
++		    !hba->auto_bkops_enabled))) {
++		/*
++		 * Change controller state to "reset state" which
++		 * should also put the link in off/reset state
++		 */
++		ufshcd_hba_stop(hba);
+ 		/*
 -		 * UFS device and/or UFS link low power states during runtime
 -		 * suspend seems to be different than what is expected during
 -		 * system suspend. Hence runtime resume the devic & link and
 -		 * let the system suspend low power states to take effect.
 -		 * TODO: If resume takes longer time, we might have optimize
 -		 * it in future by not resuming everything if possible.
++		 * TODO: Check if we need any delay to make sure that
++		 * controller is reset
+ 		 */
 -		ret = ufshcd_runtime_resume(hba);
 -		if (ret)
 -			goto out;
++		ufshcd_set_link_off(hba);
+ 	}
+ 
 -	ret = ufshcd_suspend(hba, UFS_SYSTEM_PM);
+ out:
 -	if (!ret)
 -		hba->is_sys_suspended = true;
+ 	return ret;
+ }
 -EXPORT_SYMBOL(ufshcd_system_suspend);
 -
 -/**
 - * ufshcd_system_resume - system resume routine
 - * @hba: per adapter instance
 - *
 - * Returns 0 for success and non-zero for failure
 - */
 -
 -int ufshcd_system_resume(struct ufs_hba *hba)
 -{
 -	if (!hba || !hba->is_powered || pm_runtime_suspended(hba->dev))
 -		/*
 -		 * Let the runtime resume take care of resuming
 -		 * if runtime suspended.
 -		 */
 -		return 0;
 -
 -	return ufshcd_resume(hba, UFS_SYSTEM_PM);
 -}
 -EXPORT_SYMBOL(ufshcd_system_resume);
 -
 -/**
 - * ufshcd_runtime_suspend - runtime suspend routine
 - * @hba: per adapter instance
 - *
 - * Check the description of ufshcd_suspend() function for more details.
 - *
 - * Returns 0 for success and non-zero for failure
 - */
 -int ufshcd_runtime_suspend(struct ufs_hba *hba)
 -{
 -	if (!hba || !hba->is_powered)
 -		return 0;
 -
 -	return ufshcd_suspend(hba, UFS_RUNTIME_PM);
 -}
 -EXPORT_SYMBOL(ufshcd_runtime_suspend);
+ 
 -/**
 - * ufshcd_runtime_resume - runtime resume routine
 - * @hba: per adapter instance
 - *
 - * This function basically brings the UFS device, UniPro link and controller
 - * to active state. Following operations are done in this function:
 - *
 - * 1. Turn on all the controller related clocks
 - * 2. Bring the UniPro link out of Hibernate state
 - * 3. If UFS device is in sleep state, turn ON VCC rail and bring the UFS device
 - *    to active state.
 - * 4. If auto-bkops is enabled on the device, disable it.
 - *
 - * So following would be the possible power state after this function return
 - * successfully:
 - *	S1: UFS device in Active state with VCC rail ON
 - *	    UniPro link in Active state
 - *	    All the UFS/UniPro controller clocks are ON
 - *
 - * Returns 0 for success and non-zero for failure
 - */
 -int ufshcd_runtime_resume(struct ufs_hba *hba)
++static void ufshcd_vreg_set_lpm(struct ufs_hba *hba)
++>>>>>>> d811b848ebb7 (scsi: use sdev as argument for sense code printing)
  {
 -	if (!hba || !hba->is_powered)
 -		return 0;
 -	else
 -		return ufshcd_resume(hba, UFS_RUNTIME_PM);
 -}
 -EXPORT_SYMBOL(ufshcd_runtime_resume);
 +	/*
 +	 * TODO:
 +	 * 1. Set HCE to 1, to start the UFS host controller
 +	 * initialization process
 +	 * 2. Set UTRLRSR and UTMRLRSR bits to 1
 +	 * 3. Change the internal driver state to operational
 +	 * 4. Unblock SCSI requests from SCSI midlayer
 +	 */
  
 -int ufshcd_runtime_idle(struct ufs_hba *hba)
 -{
 -	return 0;
 +	return -ENOSYS;
  }
 -EXPORT_SYMBOL(ufshcd_runtime_idle);
 +EXPORT_SYMBOL_GPL(ufshcd_resume);
  
  /**
 - * ufshcd_shutdown - shutdown routine
 + * ufshcd_hba_free - free allocated memory for
 + *			host memory space data structures
   * @hba: per adapter instance
 - *
 - * This function would power off both UFS device and UFS link.
 - *
 - * Returns 0 always to allow force shutdown even in case of errors.
   */
 -int ufshcd_shutdown(struct ufs_hba *hba)
 +static void ufshcd_hba_free(struct ufs_hba *hba)
  {
 -	int ret = 0;
 -
 -	if (ufshcd_is_ufs_dev_poweroff(hba) && ufshcd_is_link_off(hba))
 -		goto out;
 -
 -	if (pm_runtime_suspended(hba->dev)) {
 -		ret = ufshcd_runtime_resume(hba);
 -		if (ret)
 -			goto out;
 -	}
 -
 -	ret = ufshcd_suspend(hba, UFS_SHUTDOWN_PM);
 -out:
 -	if (ret)
 -		dev_err(hba->dev, "%s failed, err %d\n", __func__, ret);
 -	/* allow force shutdown even in case of errors */
 -	return 0;
 +	iounmap(hba->mmio_base);
 +	ufshcd_free_hba_memory(hba);
  }
 -EXPORT_SYMBOL(ufshcd_shutdown);
  
  /**
   * ufshcd_remove - de-allocate SCSI host and host memory space
* Unmerged path drivers/xen/xen-scsiback.c
diff --git a/drivers/scsi/53c700.c b/drivers/scsi/53c700.c
index a3adfb4357f5..8360afd20909 100644
--- a/drivers/scsi/53c700.c
+++ b/drivers/scsi/53c700.c
@@ -602,7 +602,7 @@ NCR_700_scsi_done(struct NCR_700_Host_Parameters *hostdata,
 #ifdef NCR_700_DEBUG
 			printk(" ORIGINAL CMD %p RETURNED %d, new return is %d sense is\n",
 			       SCp, SCp->cmnd[7], result);
-			scsi_print_sense("53c700", SCp);
+			scsi_print_sense(SCp);
 
 #endif
 			dma_unmap_single(hostdata->dev, slot->dma_handle,
diff --git a/drivers/scsi/ch.c b/drivers/scsi/ch.c
index 9f4f89b7c1a6..b47ab6e1849e 100644
--- a/drivers/scsi/ch.c
+++ b/drivers/scsi/ch.c
@@ -206,7 +206,7 @@ ch_do_scsi(scsi_changer *ch, unsigned char *cmd,
 	DPRINTK("result: 0x%x\n",result);
 	if (driver_byte(result) & DRIVER_SENSE) {
 		if (debug)
-			scsi_print_sense_hdr(ch->name, &sshdr);
+			scsi_print_sense_hdr(ch->device, ch->name, &sshdr);
 		errno = ch_find_errno(&sshdr);
 
 		switch(sshdr.sense_key) {
diff --git a/drivers/scsi/constants.c b/drivers/scsi/constants.c
index 2f447075adbb..9065b6f8f51b 100644
--- a/drivers/scsi/constants.c
+++ b/drivers/scsi/constants.c
@@ -1292,18 +1292,19 @@ static const struct error_info additional[] =
 
 struct error_info2 {
 	unsigned char code1, code2_min, code2_max;
+	const char * str;
 	const char * fmt;
 };
 
 static const struct error_info2 additional2[] =
 {
-	{0x40, 0x00, 0x7f, "Ram failure (%x)"},
-	{0x40, 0x80, 0xff, "Diagnostic failure on component (%x)"},
-	{0x41, 0x00, 0xff, "Data path failure (%x)"},
-	{0x42, 0x00, 0xff, "Power-on or self-test failure (%x)"},
-	{0x4D, 0x00, 0xff, "Tagged overlapped commands (task tag %x)"},
-	{0x70, 0x00, 0xff, "Decompression exception short algorithm id of %x"},
-	{0, 0, 0, NULL}
+	{0x40, 0x00, 0x7f, "Ram failure", ""},
+	{0x40, 0x80, 0xff, "Diagnostic failure on component", ""},
+	{0x41, 0x00, 0xff, "Data path failure", ""},
+	{0x42, 0x00, 0xff, "Power-on or self-test failure", ""},
+	{0x4D, 0x00, 0xff, "Tagged overlapped commands", "task tag "},
+	{0x70, 0x00, 0xff, "Decompression exception", "short algorithm id of "},
+	{0, 0, 0, NULL, NULL}
 };
 
 /* description of the sense key values */
@@ -1349,7 +1350,8 @@ EXPORT_SYMBOL(scsi_sense_key_string);
  * This string may contain a "%x" and should be printed with ascq as arg.
  */
 const char *
-scsi_extd_sense_format(unsigned char asc, unsigned char ascq) {
+scsi_extd_sense_format(unsigned char asc, unsigned char ascq, const char **fmt)
+{
 #ifdef CONFIG_SCSI_CONSTANTS
 	int i;
 	unsigned short code = ((asc << 8) | ascq);
@@ -1360,8 +1362,10 @@ scsi_extd_sense_format(unsigned char asc, unsigned char ascq) {
 	for (i = 0; additional2[i].fmt; i++) {
 		if (additional2[i].code1 == asc &&
 		    ascq >= additional2[i].code2_min &&
-		    ascq <= additional2[i].code2_max)
-			return additional2[i].fmt;
+		    ascq <= additional2[i].code2_max) {
+			*fmt = additional2[i].fmt;
+			return additional2[i].str;
+		}
 	}
 #endif
 	return NULL;
@@ -1369,49 +1373,53 @@ scsi_extd_sense_format(unsigned char asc, unsigned char ascq) {
 EXPORT_SYMBOL(scsi_extd_sense_format);
 
 void
-scsi_show_extd_sense(unsigned char asc, unsigned char ascq)
+scsi_show_extd_sense(const struct scsi_device *sdev, const char *name,
+		     unsigned char asc, unsigned char ascq)
 {
-        const char *extd_sense_fmt = scsi_extd_sense_format(asc, ascq);
+	const char *extd_sense_fmt = NULL;
+	const char *extd_sense_str = scsi_extd_sense_format(asc, ascq,
+							    &extd_sense_fmt);
+
+	if (extd_sense_str) {
+		if (extd_sense_fmt)
+			sdev_prefix_printk(KERN_INFO, sdev, name,
+					   "Add. Sense: %s (%s%x)",
+					   extd_sense_str, extd_sense_fmt,
+					   ascq);
+		else
+			sdev_prefix_printk(KERN_INFO, sdev, name,
+					   "Add. Sense: %s", extd_sense_str);
 
-	if (extd_sense_fmt) {
-		if (strstr(extd_sense_fmt, "%x")) {
-			printk("Add. Sense: ");
-			printk(extd_sense_fmt, ascq);
-		} else
-			printk("Add. Sense: %s", extd_sense_fmt);
 	} else {
-		if (asc >= 0x80)
-			printk("<<vendor>> ASC=0x%x ASCQ=0x%x", asc,
-			       ascq);
-		if (ascq >= 0x80)
-			printk("ASC=0x%x <<vendor>> ASCQ=0x%x", asc,
-			       ascq);
-		else
-			printk("ASC=0x%x ASCQ=0x%x", asc, ascq);
+		sdev_prefix_printk(KERN_INFO, sdev, name,
+				   "%sASC=0x%x %sASCQ=0x%x\n",
+				   asc >= 0x80 ? "<<vendor>> " : "", asc,
+				   ascq >= 0x80 ? "<<vendor>> " : "", ascq);
 	}
-
-	printk("\n");
 }
 EXPORT_SYMBOL(scsi_show_extd_sense);
 
 void
-scsi_show_sense_hdr(struct scsi_sense_hdr *sshdr)
+scsi_show_sense_hdr(const struct scsi_device *sdev, const char *name,
+		    const struct scsi_sense_hdr *sshdr)
 {
 	const char *sense_txt;
 
 	sense_txt = scsi_sense_key_string(sshdr->sense_key);
 	if (sense_txt)
-		printk("Sense Key : %s ", sense_txt);
+		sdev_prefix_printk(KERN_INFO, sdev, name,
+				   "Sense Key : %s [%s]%s\n", sense_txt,
+				   scsi_sense_is_deferred(sshdr) ?
+				   "deferred" : "current",
+				   sshdr->response_code >= 0x72 ?
+				   " [descriptor]" : "");
 	else
-		printk("Sense Key : 0x%x ", sshdr->sense_key);
-
-	printk("%s", scsi_sense_is_deferred(sshdr) ? "[deferred] " :
-	       "[current] ");
-
-	if (sshdr->response_code >= 0x72)
-		printk("[descriptor]");
-
-	printk("\n");
+		sdev_prefix_printk(KERN_INFO, sdev, name,
+				   "Sense Key : 0x%x [%s]%s", sshdr->sense_key,
+				   scsi_sense_is_deferred(sshdr) ?
+				   "deferred" : "current",
+				   sshdr->response_code >= 0x72 ?
+				   " [descriptor]" : "");
 }
 EXPORT_SYMBOL(scsi_show_sense_hdr);
 
@@ -1419,12 +1427,11 @@ EXPORT_SYMBOL(scsi_show_sense_hdr);
  * Print normalized SCSI sense header with a prefix.
  */
 void
-scsi_print_sense_hdr(const char *name, struct scsi_sense_hdr *sshdr)
+scsi_print_sense_hdr(const struct scsi_device *sdev, const char *name,
+		     const struct scsi_sense_hdr *sshdr)
 {
-	printk(KERN_INFO "%s: ", name);
-	scsi_show_sense_hdr(sshdr);
-	printk(KERN_INFO "%s: ", name);
-	scsi_show_extd_sense(sshdr->asc, sshdr->ascq);
+	scsi_show_sense_hdr(sdev, name, sshdr);
+	scsi_show_extd_sense(sdev, name, sshdr->asc, sshdr->ascq);
 }
 EXPORT_SYMBOL(scsi_print_sense_hdr);
 
@@ -1513,33 +1520,26 @@ scsi_decode_sense_extras(const unsigned char *sense_buffer, int sense_len,
 }
 
 /* Normalize and print sense buffer with name prefix */
-void __scsi_print_sense(const char *name, const unsigned char *sense_buffer,
-			int sense_len)
+void __scsi_print_sense(const struct scsi_device *sdev, const char *name,
+			const unsigned char *sense_buffer, int sense_len)
 {
 	struct scsi_sense_hdr sshdr;
 
-	printk(KERN_INFO "%s: ", name);
 	scsi_decode_sense_buffer(sense_buffer, sense_len, &sshdr);
-	scsi_show_sense_hdr(&sshdr);
+	scsi_show_sense_hdr(sdev, name, &sshdr);
 	scsi_decode_sense_extras(sense_buffer, sense_len, &sshdr);
-	printk(KERN_INFO "%s: ", name);
-	scsi_show_extd_sense(sshdr.asc, sshdr.ascq);
+	scsi_show_extd_sense(sdev, name, sshdr.asc, sshdr.ascq);
 }
 EXPORT_SYMBOL(__scsi_print_sense);
 
 /* Normalize and print sense buffer in SCSI command */
-void scsi_print_sense(char *name, struct scsi_cmnd *cmd)
+void scsi_print_sense(const struct scsi_cmnd *cmd)
 {
-	struct scsi_sense_hdr sshdr;
+	struct gendisk *disk = cmd->request->rq_disk;
+	const char *disk_name = disk ? disk->disk_name : NULL;
 
-	scmd_printk(KERN_INFO, cmd, " ");
-	scsi_decode_sense_buffer(cmd->sense_buffer, SCSI_SENSE_BUFFERSIZE,
-				 &sshdr);
-	scsi_show_sense_hdr(&sshdr);
-	scsi_decode_sense_extras(cmd->sense_buffer, SCSI_SENSE_BUFFERSIZE,
-				 &sshdr);
-	scmd_printk(KERN_INFO, cmd, " ");
-	scsi_show_extd_sense(sshdr.asc, sshdr.ascq);
+	__scsi_print_sense(cmd->device, disk_name, cmd->sense_buffer,
+			   SCSI_SENSE_BUFFERSIZE);
 }
 EXPORT_SYMBOL(scsi_print_sense);
 
diff --git a/drivers/scsi/osst.c b/drivers/scsi/osst.c
index 0727ea7cc387..4ba2a9f3b798 100644
--- a/drivers/scsi/osst.c
+++ b/drivers/scsi/osst.c
@@ -259,9 +259,10 @@ static int osst_chk_result(struct osst_tape * STp, struct osst_request * SRpnt)
 		   SRpnt->cmd[0], SRpnt->cmd[1], SRpnt->cmd[2],
 		   SRpnt->cmd[3], SRpnt->cmd[4], SRpnt->cmd[5]);
 		if (scode) printk(OSST_DEB_MSG "%s:D: Sense: %02x, ASC: %02x, ASCQ: %02x\n",
-			       	name, scode, sense[12], sense[13]);
+				  name, scode, sense[12], sense[13]);
 		if (cmdstatp->have_sense)
-			__scsi_print_sense("osst ", SRpnt->sense, SCSI_SENSE_BUFFERSIZE);
+			__scsi_print_sense(STp->device, name,
+					   SRpnt->sense, SCSI_SENSE_BUFFERSIZE);
 	}
 	else
 #endif
@@ -275,7 +276,8 @@ static int osst_chk_result(struct osst_tape * STp, struct osst_request * SRpnt)
 		 SRpnt->cmd[0] != TEST_UNIT_READY)) { /* Abnormal conditions for tape */
 		if (cmdstatp->have_sense) {
 			printk(KERN_WARNING "%s:W: Command with sense data:\n", name);
-			__scsi_print_sense("osst ", SRpnt->sense, SCSI_SENSE_BUFFERSIZE);
+			__scsi_print_sense(STp->device, name,
+					   SRpnt->sense, SCSI_SENSE_BUFFERSIZE);
 		}
 		else {
 			static	int	notyetprinted = 1;
diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
index 838f188fa5d4..831f26a9c693 100644
--- a/drivers/scsi/scsi.c
+++ b/drivers/scsi/scsi.c
@@ -592,7 +592,7 @@ void scsi_log_completion(struct scsi_cmnd *cmd, int disposition)
 			scsi_print_result(cmd);
 			scsi_print_command(cmd);
 			if (status_byte(cmd->result) & CHECK_CONDITION)
-				scsi_print_sense("", cmd);
+				scsi_print_sense(cmd);
 			if (level > 3)
 				scmd_printk(KERN_INFO, cmd,
 					    "scsi host busy %d failed %d\n",
diff --git a/drivers/scsi/scsi_error.c b/drivers/scsi/scsi_error.c
index 4ad9c19ca10c..a6e08c0746ef 100644
--- a/drivers/scsi/scsi_error.c
+++ b/drivers/scsi/scsi_error.c
@@ -1180,7 +1180,7 @@ int scsi_eh_get_sense(struct list_head *work_q,
 		SCSI_LOG_ERROR_RECOVERY(3, scmd_printk(KERN_INFO, scmd,
 			"sense requested for %p result %x\n",
 			scmd, scmd->result));
-		SCSI_LOG_ERROR_RECOVERY(3, scsi_print_sense("bh", scmd));
+		SCSI_LOG_ERROR_RECOVERY(3, scsi_print_sense(scmd));
 
 		rtn = scsi_decide_disposition(scmd);
 
diff --git a/drivers/scsi/scsi_ioctl.c b/drivers/scsi/scsi_ioctl.c
index 1aaaf43c6803..7d2de08d9c86 100644
--- a/drivers/scsi/scsi_ioctl.c
+++ b/drivers/scsi/scsi_ioctl.c
@@ -126,7 +126,7 @@ static int ioctl_internal_command(struct scsi_device *sdev, char *cmd,
 			sdev_printk(KERN_INFO, sdev,
 				    "ioctl_internal_command return code = %x\n",
 				    result);
-			scsi_print_sense_hdr("   ", &sshdr);
+			scsi_print_sense_hdr(sdev, NULL, &sshdr);
 			break;
 		}
 	}
diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index 2eb9f5889dec..18e1f46c8e21 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -762,7 +762,7 @@ void scsi_io_completion(struct scsi_cmnd *cmd, unsigned int good_bytes)
 		if ((sshdr.asc == 0x0) && (sshdr.ascq == 0x1d))
 			;
 		else if (!(req->cmd_flags & REQ_QUIET))
-			scsi_print_sense("", cmd);
+			scsi_print_sense(cmd);
 		result = 0;
 		/* BLOCK_PC may have set error */
 		error = 0;
@@ -890,7 +890,7 @@ void scsi_io_completion(struct scsi_cmnd *cmd, unsigned int good_bytes)
 		if (!(req->cmd_flags & REQ_QUIET) && __ratelimit(&rs)) {
 			scsi_print_result(cmd);
 			if (driver_byte(result) & DRIVER_SENSE)
-				scsi_print_sense("", cmd);
+				scsi_print_sense(cmd);
 			scsi_print_command(cmd);
 		}
 		if (!blk_end_request_err(req, error))
diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index 70b68764775a..07a4162b4387 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -3233,10 +3233,11 @@ module_exit(exit_sd);
 static void sd_print_sense_hdr(struct scsi_disk *sdkp,
 			       struct scsi_sense_hdr *sshdr)
 {
-	sd_printk(KERN_INFO, sdkp, " ");
-	scsi_show_sense_hdr(sshdr);
-	sd_printk(KERN_INFO, sdkp, " ");
-	scsi_show_extd_sense(sshdr->asc, sshdr->ascq);
+	scsi_show_sense_hdr(sdkp->device,
+			    sdkp->disk ? sdkp->disk->disk_name : NULL, sshdr);
+	scsi_show_extd_sense(sdkp->device,
+			     sdkp->disk ? sdkp->disk->disk_name : NULL,
+			     sshdr->asc, sshdr->ascq);
 }
 
 static void sd_print_result(struct scsi_disk *sdkp, int result)
diff --git a/drivers/scsi/sg.c b/drivers/scsi/sg.c
index d99b8913f6b1..18a368e0cc20 100644
--- a/drivers/scsi/sg.c
+++ b/drivers/scsi/sg.c
@@ -1351,7 +1351,7 @@ sg_rq_end_io(struct request *rq, int uptodate)
 		if ((sdp->sgdebug > 0) &&
 		    ((CHECK_CONDITION == srp->header.masked_status) ||
 		     (COMMAND_TERMINATED == srp->header.masked_status)))
-			__scsi_print_sense(__func__, sense,
+			__scsi_print_sense(sdp->device, __func__, sense,
 					   SCSI_SENSE_BUFFERSIZE);
 
 		/* Following if statement is a patch supplied by Eric Youngdale */
diff --git a/drivers/scsi/sr_ioctl.c b/drivers/scsi/sr_ioctl.c
index 6389fcff12ec..17e0c2b28a99 100644
--- a/drivers/scsi/sr_ioctl.c
+++ b/drivers/scsi/sr_ioctl.c
@@ -246,7 +246,7 @@ int sr_do_ioctl(Scsi_CD *cd, struct packet_command *cgc)
 					  "CDROM not ready.  Make sure there "
 					  "is a disc in the drive.\n");
 #ifdef DEBUG
-			scsi_print_sense_hdr("sr", &sshdr);
+			scsi_print_sense_hdr(cd->device, cd->cdi.name, &sshdr);
 #endif
 			err = -ENOMEDIUM;
 			break;
@@ -258,14 +258,14 @@ int sr_do_ioctl(Scsi_CD *cd, struct packet_command *cgc)
 				err = -EDRIVE_CANT_DO_THIS;
 #ifdef DEBUG
 			__scsi_print_command(cgc->cmd);
-			scsi_print_sense_hdr("sr", &sshdr);
+			scsi_print_sense_hdr(cd->device, cd->cdi.name, &sshdr);
 #endif
 			break;
 		default:
 			sr_printk(KERN_ERR, cd,
 				  "CDROM (ioctl) error, command: ");
 			__scsi_print_command(cgc->cmd);
-			scsi_print_sense_hdr("sr", &sshdr);
+			scsi_print_sense_hdr(cd->device, cd->cdi.name, &sshdr);
 			err = -EIO;
 		}
 	}
diff --git a/drivers/scsi/st.c b/drivers/scsi/st.c
index 3f45d80381ab..876529ad0aca 100644
--- a/drivers/scsi/st.c
+++ b/drivers/scsi/st.c
@@ -381,7 +381,8 @@ static int st_chk_result(struct scsi_tape *STp, struct st_request * SRpnt)
 			    SRpnt->cmd[0], SRpnt->cmd[1], SRpnt->cmd[2],
 			    SRpnt->cmd[3], SRpnt->cmd[4], SRpnt->cmd[5]);
 		if (cmdstatp->have_sense)
-			 __scsi_print_sense(name, SRpnt->sense, SCSI_SENSE_BUFFERSIZE);
+			__scsi_print_sense(STp->device, name,
+					   SRpnt->sense, SCSI_SENSE_BUFFERSIZE);
 	} ) /* end DEB */
 	if (!debugging) { /* Abnormal conditions for tape */
 		if (!cmdstatp->have_sense)
@@ -397,7 +398,8 @@ static int st_chk_result(struct scsi_tape *STp, struct st_request * SRpnt)
 			 SRpnt->cmd[0] != MODE_SENSE &&
 			 SRpnt->cmd[0] != TEST_UNIT_READY) {
 
-			__scsi_print_sense(name, SRpnt->sense, SCSI_SENSE_BUFFERSIZE);
+			__scsi_print_sense(STp->device, name,
+					   SRpnt->sense, SCSI_SENSE_BUFFERSIZE);
 		}
 	}
 
diff --git a/drivers/scsi/storvsc_drv.c b/drivers/scsi/storvsc_drv.c
index 64bd0ebaf561..98287095851c 100644
--- a/drivers/scsi/storvsc_drv.c
+++ b/drivers/scsi/storvsc_drv.c
@@ -1116,7 +1116,8 @@ static void storvsc_command_completion(struct storvsc_cmd_request *cmd_request)
 	if (scmnd->result) {
 		if (scsi_normalize_sense(scmnd->sense_buffer,
 				SCSI_SENSE_BUFFERSIZE, &sense_hdr))
-			scsi_print_sense_hdr("storvsc", &sense_hdr);
+			scsi_print_sense_hdr(scmnd->device, "storvsc",
+					     &sense_hdr);
 	}
 
 	if (vm_srb->srb_status != SRB_STATUS_SUCCESS)
* Unmerged path drivers/scsi/ufs/ufshcd.c
diff --git a/drivers/usb/storage/debug.c b/drivers/usb/storage/debug.c
index e08f64780e30..66a684a29938 100644
--- a/drivers/usb/storage/debug.c
+++ b/drivers/usb/storage/debug.c
@@ -164,10 +164,10 @@ void usb_stor_show_sense(const struct us_data *us,
 			 unsigned char asc,
 			 unsigned char ascq)
 {
-	const char *what, *keystr;
+	const char *what, *keystr, *fmt;
 
 	keystr = scsi_sense_key_string(key);
-	what = scsi_extd_sense_format(asc, ascq);
+	what = scsi_extd_sense_format(asc, ascq, &fmt);
 
 	if (keystr == NULL)
 		keystr = "(Unknown Key)";
@@ -175,8 +175,10 @@ void usb_stor_show_sense(const struct us_data *us,
 		what = "(unknown ASC/ASCQ)";
 
 	usb_stor_dbg(us, "%s: ", keystr);
-	US_DEBUGPX(what, ascq);
-	US_DEBUGPX("\n");
+	if (fmt)
+		US_DEBUGPX("%s (%s%x)\n", what, fmt, ascq);
+	else
+		US_DEBUGPX("%s\n", what);
 }
 
 int usb_stor_dbg(const struct us_data *us, const char *fmt, ...)
* Unmerged path drivers/xen/xen-scsiback.c
diff --git a/include/scsi/scsi_dbg.h b/include/scsi/scsi_dbg.h
index 5a43a4cd96c6..6cbd179a17cc 100644
--- a/include/scsi/scsi_dbg.h
+++ b/include/scsi/scsi_dbg.h
@@ -2,21 +2,26 @@
 #define _SCSI_SCSI_DBG_H
 
 struct scsi_cmnd;
+struct scsi_device;
 struct scsi_sense_hdr;
 
 extern void scsi_print_command(struct scsi_cmnd *);
 extern void __scsi_print_command(unsigned char *);
-extern void scsi_show_extd_sense(unsigned char, unsigned char);
-extern void scsi_show_sense_hdr(struct scsi_sense_hdr *);
-extern void scsi_print_sense_hdr(const char *, struct scsi_sense_hdr *);
-extern void scsi_print_sense(char *, struct scsi_cmnd *);
-extern void __scsi_print_sense(const char *name,
+extern void scsi_show_extd_sense(const struct scsi_device *, const char *,
+				 unsigned char, unsigned char);
+extern void scsi_show_sense_hdr(const struct scsi_device *, const char *,
+				const struct scsi_sense_hdr *);
+extern void scsi_print_sense_hdr(const struct scsi_device *, const char *,
+				 const struct scsi_sense_hdr *);
+extern void scsi_print_sense(const struct scsi_cmnd *);
+extern void __scsi_print_sense(const struct scsi_device *, const char *name,
 			       const unsigned char *sense_buffer,
 			       int sense_len);
 extern void scsi_show_result(int);
 extern void scsi_print_result(struct scsi_cmnd *);
 extern void scsi_print_status(unsigned char);
 extern const char *scsi_sense_key_string(unsigned char);
-extern const char *scsi_extd_sense_format(unsigned char, unsigned char);
+extern const char *scsi_extd_sense_format(unsigned char, unsigned char,
+					  const char **);
 
 #endif /* _SCSI_SCSI_DBG_H */
diff --git a/include/scsi/scsi_eh.h b/include/scsi/scsi_eh.h
index 06a8790893ef..3d720ca2d30d 100644
--- a/include/scsi/scsi_eh.h
+++ b/include/scsi/scsi_eh.h
@@ -47,7 +47,7 @@ extern int scsi_normalize_sense(const u8 *sense_buffer, int sb_len,
 extern int scsi_command_normalize_sense(struct scsi_cmnd *cmd,
 		struct scsi_sense_hdr *sshdr);
 
-static inline int scsi_sense_is_deferred(struct scsi_sense_hdr *sshdr)
+static inline int scsi_sense_is_deferred(const struct scsi_sense_hdr *sshdr)
 {
 	return ((sshdr->response_code >= 0x70) && (sshdr->response_code & 1));
 }
