e1000, e1000e: Use dma_rmb instead of rmb for descriptor read ordering

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [netdrv] e1000e: Use dma_rmb instead of rmb for descriptor read ordering (John Greene) [1173782]
Rebuild_FUZZ: 94.74%
commit-author Alexander Duyck <alexander.h.duyck@redhat.com>
commit 837a1dba0078d0bad755f6cb13a48c1623d11ff5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/837a1dba.failed

This change replaces calls to rmb with dma_rmb in the case where we want to
order all follow-on descriptor reads after the check for the descriptor
status bit.

	Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
	Acked-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 837a1dba0078d0bad755f6cb13a48c1623d11ff5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/e1000e/netdev.c
diff --cc drivers/net/ethernet/intel/e1000e/netdev.c
index e60b4d1303f2,74ec185a697f..000000000000
--- a/drivers/net/ethernet/intel/e1000e/netdev.c
+++ b/drivers/net/ethernet/intel/e1000e/netdev.c
@@@ -1232,7 -1231,8 +1232,12 @@@ static bool e1000_clean_tx_irq(struct e
  	while ((eop_desc->upper.data & cpu_to_le32(E1000_TXD_STAT_DD)) &&
  	       (count < tx_ring->count)) {
  		bool cleaned = false;
++<<<<<<< HEAD
 +		rmb();		/* read buffer_info after eop_desc */
++=======
+ 
+ 		dma_rmb();		/* read buffer_info after eop_desc */
++>>>>>>> 837a1dba0078 (e1000, e1000e: Use dma_rmb instead of rmb for descriptor read ordering)
  		for (; !cleaned; count++) {
  			tx_desc = E1000_TX_DESC(*tx_ring, i);
  			buffer_info = &tx_ring->buffer_info[i];
diff --git a/drivers/net/ethernet/intel/e1000/e1000_main.c b/drivers/net/ethernet/intel/e1000/e1000_main.c
index 445b0e1762ab..fd3c5ecfcaa5 100644
--- a/drivers/net/ethernet/intel/e1000/e1000_main.c
+++ b/drivers/net/ethernet/intel/e1000/e1000_main.c
@@ -3846,7 +3846,7 @@ static bool e1000_clean_tx_irq(struct e1000_adapter *adapter,
 	while ((eop_desc->upper.data & cpu_to_le32(E1000_TXD_STAT_DD)) &&
 	       (count < tx_ring->count)) {
 		bool cleaned = false;
-		rmb();	/* read buffer_info after eop_desc */
+		dma_rmb();	/* read buffer_info after eop_desc */
 		for ( ; !cleaned; count++) {
 			tx_desc = E1000_TX_DESC(*tx_ring, i);
 			buffer_info = &tx_ring->buffer_info[i];
@@ -4040,7 +4040,7 @@ static bool e1000_clean_jumbo_rx_irq(struct e1000_adapter *adapter,
 		if (*work_done >= work_to_do)
 			break;
 		(*work_done)++;
-		rmb(); /* read descriptor and rx_buffer_info after status DD */
+		dma_rmb(); /* read descriptor and rx_buffer_info after status DD */
 
 		status = rx_desc->status;
 		skb = buffer_info->skb;
@@ -4253,7 +4253,7 @@ static bool e1000_clean_rx_irq(struct e1000_adapter *adapter,
 		if (*work_done >= work_to_do)
 			break;
 		(*work_done)++;
-		rmb(); /* read descriptor and rx_buffer_info after status DD */
+		dma_rmb(); /* read descriptor and rx_buffer_info after status DD */
 
 		status = rx_desc->status;
 		skb = buffer_info->skb;
* Unmerged path drivers/net/ethernet/intel/e1000e/netdev.c
