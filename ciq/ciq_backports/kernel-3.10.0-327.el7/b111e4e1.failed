netns: minor cleanup in rtnl_net_getid()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Nicolas Dichtel <nicolas.dichtel@6wind.com>
commit b111e4e1112316e800dd1f1debdf017d2cf940b2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/b111e4e1.failed

No need to initialize err, it will be overridden by the value of nlmsg_parse().

	Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b111e4e1112316e800dd1f1debdf017d2cf940b2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/net_namespace.c
diff --cc net/core/net_namespace.c
index 4cf6699528f0,be28afccfbbb..000000000000
--- a/net/core/net_namespace.c
+++ b/net/core/net_namespace.c
@@@ -397,6 -479,130 +397,133 @@@ static struct pernet_operations __net_i
  	.exit = net_ns_net_exit,
  };
  
++<<<<<<< HEAD
++=======
+ static struct nla_policy rtnl_net_policy[NETNSA_MAX + 1] = {
+ 	[NETNSA_NONE]		= { .type = NLA_UNSPEC },
+ 	[NETNSA_NSID]		= { .type = NLA_S32 },
+ 	[NETNSA_PID]		= { .type = NLA_U32 },
+ 	[NETNSA_FD]		= { .type = NLA_U32 },
+ };
+ 
+ static int rtnl_net_newid(struct sk_buff *skb, struct nlmsghdr *nlh)
+ {
+ 	struct net *net = sock_net(skb->sk);
+ 	struct nlattr *tb[NETNSA_MAX + 1];
+ 	struct net *peer;
+ 	int nsid, err;
+ 
+ 	err = nlmsg_parse(nlh, sizeof(struct rtgenmsg), tb, NETNSA_MAX,
+ 			  rtnl_net_policy);
+ 	if (err < 0)
+ 		return err;
+ 	if (!tb[NETNSA_NSID])
+ 		return -EINVAL;
+ 	nsid = nla_get_s32(tb[NETNSA_NSID]);
+ 
+ 	if (tb[NETNSA_PID])
+ 		peer = get_net_ns_by_pid(nla_get_u32(tb[NETNSA_PID]));
+ 	else if (tb[NETNSA_FD])
+ 		peer = get_net_ns_by_fd(nla_get_u32(tb[NETNSA_FD]));
+ 	else
+ 		return -EINVAL;
+ 	if (IS_ERR(peer))
+ 		return PTR_ERR(peer);
+ 
+ 	if (__peernet2id(net, peer, false) >= 0) {
+ 		err = -EEXIST;
+ 		goto out;
+ 	}
+ 
+ 	err = alloc_netid(net, peer, nsid);
+ 	if (err > 0)
+ 		err = 0;
+ out:
+ 	put_net(peer);
+ 	return err;
+ }
+ 
+ static int rtnl_net_get_size(void)
+ {
+ 	return NLMSG_ALIGN(sizeof(struct rtgenmsg))
+ 	       + nla_total_size(sizeof(s32)) /* NETNSA_NSID */
+ 	       ;
+ }
+ 
+ static int rtnl_net_fill(struct sk_buff *skb, u32 portid, u32 seq, int flags,
+ 			 int cmd, struct net *net, struct net *peer)
+ {
+ 	struct nlmsghdr *nlh;
+ 	struct rtgenmsg *rth;
+ 	int id;
+ 
+ 	ASSERT_RTNL();
+ 
+ 	nlh = nlmsg_put(skb, portid, seq, cmd, sizeof(*rth), flags);
+ 	if (!nlh)
+ 		return -EMSGSIZE;
+ 
+ 	rth = nlmsg_data(nlh);
+ 	rth->rtgen_family = AF_UNSPEC;
+ 
+ 	id = __peernet2id(net, peer, false);
+ 	if  (id < 0)
+ 		id = NETNSA_NSID_NOT_ASSIGNED;
+ 	if (nla_put_s32(skb, NETNSA_NSID, id))
+ 		goto nla_put_failure;
+ 
+ 	nlmsg_end(skb, nlh);
+ 	return 0;
+ 
+ nla_put_failure:
+ 	nlmsg_cancel(skb, nlh);
+ 	return -EMSGSIZE;
+ }
+ 
+ static int rtnl_net_getid(struct sk_buff *skb, struct nlmsghdr *nlh)
+ {
+ 	struct net *net = sock_net(skb->sk);
+ 	struct nlattr *tb[NETNSA_MAX + 1];
+ 	struct sk_buff *msg;
+ 	struct net *peer;
+ 	int err;
+ 
+ 	err = nlmsg_parse(nlh, sizeof(struct rtgenmsg), tb, NETNSA_MAX,
+ 			  rtnl_net_policy);
+ 	if (err < 0)
+ 		return err;
+ 	if (tb[NETNSA_PID])
+ 		peer = get_net_ns_by_pid(nla_get_u32(tb[NETNSA_PID]));
+ 	else if (tb[NETNSA_FD])
+ 		peer = get_net_ns_by_fd(nla_get_u32(tb[NETNSA_FD]));
+ 	else
+ 		return -EINVAL;
+ 
+ 	if (IS_ERR(peer))
+ 		return PTR_ERR(peer);
+ 
+ 	msg = nlmsg_new(rtnl_net_get_size(), GFP_KERNEL);
+ 	if (!msg) {
+ 		err = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	err = rtnl_net_fill(msg, NETLINK_CB(skb).portid, nlh->nlmsg_seq, 0,
+ 			    RTM_GETNSID, net, peer);
+ 	if (err < 0)
+ 		goto err_out;
+ 
+ 	err = rtnl_unicast(msg, net, NETLINK_CB(skb).portid);
+ 	goto out;
+ 
+ err_out:
+ 	nlmsg_free(msg);
+ out:
+ 	put_net(peer);
+ 	return err;
+ }
+ 
++>>>>>>> b111e4e11123 (netns: minor cleanup in rtnl_net_getid())
  static int __init net_ns_init(void)
  {
  	struct net_generic *ng;
* Unmerged path net/core/net_namespace.c
