net: tcp: add RTAX_CC_ALGO fib handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] tcp: add RTAX_CC_ALGO fib handling (Florian Westphal) [1212624]
Rebuild_FUZZ: 93.15%
commit-author Daniel Borkmann <dborkman@redhat.com>
commit ea697639992d96da98016b8934e68a73876a2264
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/ea697639.failed

This patch adds the minimum necessary for the RTAX_CC_ALGO congestion
control metric to be set up and dumped back to user space.

While the internal representation of RTAX_CC_ALGO is handled as a u32
key, we avoided to expose this implementation detail to user space, thus
instead, we chose the netlink attribute that is being exchanged between
user space to be the actual congestion control algorithm name, similarly
as in the setsockopt(2) API in order to allow for maximum flexibility,
even for 3rd party modules.

It is a bit unfortunate that RTAX_QUICKACK used up a whole RTAX slot as
it should have been stored in RTAX_FEATURES instead, we first thought
about reusing it for the congestion control key, but it brings more
complications and/or confusion than worth it.

Joint work with Florian Westphal.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ea697639992d96da98016b8934e68a73876a2264)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/tcp.h
#	include/uapi/linux/rtnetlink.h
#	net/ipv6/route.c
diff --cc include/net/tcp.h
index 0373da38f3bc,95bb237152e0..000000000000
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@@ -828,26 -825,43 +828,47 @@@ struct tcp_congestion_ops 
  	struct module 	*owner;
  };
  
 -int tcp_register_congestion_control(struct tcp_congestion_ops *type);
 -void tcp_unregister_congestion_control(struct tcp_congestion_ops *type);
 -
 -void tcp_assign_congestion_control(struct sock *sk);
 -void tcp_init_congestion_control(struct sock *sk);
 -void tcp_cleanup_congestion_control(struct sock *sk);
 -int tcp_set_default_congestion_control(const char *name);
 -void tcp_get_default_congestion_control(char *name);
 -void tcp_get_available_congestion_control(char *buf, size_t len);
 -void tcp_get_allowed_congestion_control(char *buf, size_t len);
 -int tcp_set_allowed_congestion_control(char *allowed);
 -int tcp_set_congestion_control(struct sock *sk, const char *name);
 -void tcp_slow_start(struct tcp_sock *tp, u32 acked);
 -void tcp_cong_avoid_ai(struct tcp_sock *tp, u32 w);
 -
 -u32 tcp_reno_ssthresh(struct sock *sk);
 -void tcp_reno_cong_avoid(struct sock *sk, u32 ack, u32 acked);
 +extern int tcp_register_congestion_control(struct tcp_congestion_ops *type);
 +extern void tcp_unregister_congestion_control(struct tcp_congestion_ops *type);
 +
 +extern void tcp_init_congestion_control(struct sock *sk);
 +extern void tcp_cleanup_congestion_control(struct sock *sk);
 +extern int tcp_set_default_congestion_control(const char *name);
 +extern void tcp_get_default_congestion_control(char *name);
 +extern void tcp_get_available_congestion_control(char *buf, size_t len);
 +extern void tcp_get_allowed_congestion_control(char *buf, size_t len);
 +extern int tcp_set_allowed_congestion_control(char *allowed);
 +extern int tcp_set_congestion_control(struct sock *sk, const char *name);
 +extern void tcp_slow_start(struct tcp_sock *tp);
 +extern void tcp_cong_avoid_ai(struct tcp_sock *tp, u32 w);
 +
 +extern struct tcp_congestion_ops tcp_init_congestion_ops;
 +extern u32 tcp_reno_ssthresh(struct sock *sk);
 +extern void tcp_reno_cong_avoid(struct sock *sk, u32 ack, u32 in_flight);
 +extern u32 tcp_reno_min_cwnd(const struct sock *sk);
  extern struct tcp_congestion_ops tcp_reno;
  
++<<<<<<< HEAD
++=======
+ struct tcp_congestion_ops *tcp_ca_find_key(u32 key);
+ u32 tcp_ca_get_key_by_name(const char *name);
+ #ifdef CONFIG_INET
+ char *tcp_ca_get_name_by_key(u32 key, char *buffer);
+ #else
+ static inline char *tcp_ca_get_name_by_key(u32 key, char *buffer)
+ {
+ 	return NULL;
+ }
+ #endif
+ 
+ static inline bool tcp_ca_needs_ecn(const struct sock *sk)
+ {
+ 	const struct inet_connection_sock *icsk = inet_csk(sk);
+ 
+ 	return icsk->icsk_ca_ops->flags & TCP_CONG_NEEDS_ECN;
+ }
+ 
++>>>>>>> ea697639992d (net: tcp: add RTAX_CC_ALGO fib handling)
  static inline void tcp_set_ca_state(struct sock *sk, const u8 ca_state)
  {
  	struct inet_connection_sock *icsk = inet_csk(sk);
diff --cc include/uapi/linux/rtnetlink.h
index d072a7ae7d4b,d81f22d5b390..000000000000
--- a/include/uapi/linux/rtnetlink.h
+++ b/include/uapi/linux/rtnetlink.h
@@@ -388,14 -389,8 +388,19 @@@ enum 
  #define RTAX_INITRWND RTAX_INITRWND
  	RTAX_QUICKACK,
  #define RTAX_QUICKACK RTAX_QUICKACK
++<<<<<<< HEAD
 +	RTAX_RESERVED1,
 +	RTAX_RESERVED2,
 +	RTAX_RESERVED3,
 +	RTAX_RESERVED4,
 +	RTAX_RESERVED5,
 +	RTAX_RESERVED6,
 +	RTAX_RESERVED7,
 +	RTAX_RESERVED8,
++=======
+ 	RTAX_CC_ALGO,
+ #define RTAX_CC_ALGO RTAX_CC_ALGO
++>>>>>>> ea697639992d (net: tcp: add RTAX_CC_ALGO fib handling)
  	__RTAX_MAX
  };
  
diff --cc net/ipv6/route.c
index 2f320d61d648,34dcbb59df75..000000000000
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@@ -1452,9 -1470,51 +1452,57 @@@ out
  	return entries > rt_max_size;
  }
  
++<<<<<<< HEAD
 +/*
 + *
 + */
++=======
+ static int ip6_convert_metrics(struct mx6_config *mxc,
+ 			       const struct fib6_config *cfg)
+ {
+ 	struct nlattr *nla;
+ 	int remaining;
+ 	u32 *mp;
+ 
+ 	if (cfg->fc_mx == NULL)
+ 		return 0;
+ 
+ 	mp = kzalloc(sizeof(u32) * RTAX_MAX, GFP_KERNEL);
+ 	if (unlikely(!mp))
+ 		return -ENOMEM;
+ 
+ 	nla_for_each_attr(nla, cfg->fc_mx, cfg->fc_mx_len, remaining) {
+ 		int type = nla_type(nla);
+ 
+ 		if (type) {
+ 			u32 val;
+ 
+ 			if (unlikely(type > RTAX_MAX))
+ 				goto err;
+ 			if (type == RTAX_CC_ALGO) {
+ 				char tmp[TCP_CA_NAME_MAX];
+ 
+ 				nla_strlcpy(tmp, nla, sizeof(tmp));
+ 				val = tcp_ca_get_key_by_name(tmp);
+ 				if (val == TCP_CA_UNSPEC)
+ 					goto err;
+ 			} else {
+ 				val = nla_get_u32(nla);
+ 			}
+ 
+ 			mp[type - 1] = val;
+ 			__set_bit(type - 1, mxc->mx_valid);
+ 		}
+ 	}
+ 
+ 	mxc->mx = mp;
+ 
+ 	return 0;
+  err:
+ 	kfree(mp);
+ 	return -EINVAL;
+ }
++>>>>>>> ea697639992d (net: tcp: add RTAX_CC_ALGO fib handling)
  
  int ip6_route_add(struct fib6_config *cfg)
  {
* Unmerged path include/net/tcp.h
* Unmerged path include/uapi/linux/rtnetlink.h
diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c
index 187818c8949a..18302bf39192 100644
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@ -48,6 +48,7 @@
 #include <net/arp.h>
 #include <net/route.h>
 #include <net/udp.h>
+#include <net/tcp.h>
 #include <net/sock.h>
 #include <net/pkt_sched.h>
 #include <net/fib_rules.h>
@@ -607,9 +608,19 @@ int rtnetlink_put_metrics(struct sk_buff *skb, u32 *metrics)
 
 	for (i = 0; i < RTAX_MAX; i++) {
 		if (metrics[i]) {
+			if (i == RTAX_CC_ALGO - 1) {
+				char tmp[TCP_CA_NAME_MAX], *name;
+
+				name = tcp_ca_get_name_by_key(metrics[i], tmp);
+				if (!name)
+					continue;
+				if (nla_put_string(skb, i + 1, name))
+					goto nla_put_failure;
+			} else {
+				if (nla_put_u32(skb, i + 1, metrics[i]))
+					goto nla_put_failure;
+			}
 			valid++;
-			if (nla_put_u32(skb, i+1, metrics[i]))
-				goto nla_put_failure;
 		}
 	}
 
diff --git a/net/decnet/dn_fib.c b/net/decnet/dn_fib.c
index d332aefb0846..df4803437888 100644
--- a/net/decnet/dn_fib.c
+++ b/net/decnet/dn_fib.c
@@ -298,7 +298,8 @@ struct dn_fib_info *dn_fib_create_info(const struct rtmsg *r, struct nlattr *att
 			int type = nla_type(attr);
 
 			if (type) {
-				if (type > RTAX_MAX || nla_len(attr) < 4)
+				if (type > RTAX_MAX || type == RTAX_CC_ALGO ||
+				    nla_len(attr) < 4)
 					goto err_inval;
 
 				fi->fib_metrics[type-1] = nla_get_u32(attr);
diff --git a/net/decnet/dn_table.c b/net/decnet/dn_table.c
index 86e3807052e9..3f19fcbf126d 100644
--- a/net/decnet/dn_table.c
+++ b/net/decnet/dn_table.c
@@ -29,6 +29,7 @@
 #include <linux/route.h> /* RTF_xxx */
 #include <net/neighbour.h>
 #include <net/netlink.h>
+#include <net/tcp.h>
 #include <net/dst.h>
 #include <net/flow.h>
 #include <net/fib_rules.h>
@@ -273,7 +274,8 @@ static inline size_t dn_fib_nlmsg_size(struct dn_fib_info *fi)
 	size_t payload = NLMSG_ALIGN(sizeof(struct rtmsg))
 			 + nla_total_size(4) /* RTA_TABLE */
 			 + nla_total_size(2) /* RTA_DST */
-			 + nla_total_size(4); /* RTA_PRIORITY */
+			 + nla_total_size(4) /* RTA_PRIORITY */
+			 + nla_total_size(TCP_CA_NAME_MAX); /* RTAX_CC_ALGO */
 
 	/* space for nested metrics */
 	payload += nla_total_size((RTAX_MAX * nla_total_size(4)));
diff --git a/net/ipv4/fib_semantics.c b/net/ipv4/fib_semantics.c
index b6c8c98fb7b5..c65c00420b22 100644
--- a/net/ipv4/fib_semantics.c
+++ b/net/ipv4/fib_semantics.c
@@ -359,7 +359,8 @@ static inline size_t fib_nlmsg_size(struct fib_info *fi)
 			 + nla_total_size(4) /* RTA_TABLE */
 			 + nla_total_size(4) /* RTA_DST */
 			 + nla_total_size(4) /* RTA_PRIORITY */
-			 + nla_total_size(4); /* RTA_PREFSRC */
+			 + nla_total_size(4) /* RTA_PREFSRC */
+			 + nla_total_size(TCP_CA_NAME_MAX); /* RTAX_CC_ALGO */
 
 	/* space for nested metrics */
 	payload += nla_total_size((RTAX_MAX * nla_total_size(4)));
@@ -856,7 +857,16 @@ struct fib_info *fib_create_info(struct fib_config *cfg)
 
 				if (type > RTAX_MAX)
 					goto err_inval;
-				val = nla_get_u32(nla);
+				if (type == RTAX_CC_ALGO) {
+					char tmp[TCP_CA_NAME_MAX];
+
+					nla_strlcpy(tmp, nla, sizeof(tmp));
+					val = tcp_ca_get_key_by_name(tmp);
+					if (val == TCP_CA_UNSPEC)
+						goto err_inval;
+				} else {
+					val = nla_get_u32(nla);
+				}
 				if (type == RTAX_ADVMSS && val > 65535 - 40)
 					val = 65535 - 40;
 				if (type == RTAX_MTU && val > 65535 - 15)
* Unmerged path net/ipv6/route.c
