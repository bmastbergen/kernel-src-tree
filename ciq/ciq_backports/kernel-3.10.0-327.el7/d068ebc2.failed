ALSA: hda - Move some codes up to hdac_bus struct

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [alsa] hda - Move some codes up to hdac_bus struct (Jaroslav Kysela) [1197064]
Rebuild_FUZZ: 93.48%
commit-author Takashi Iwai <tiwai@suse.de>
commit d068ebc25e6e1360510ad8023fe7bca3dacd204e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/d068ebc2.failed

A few basic codes for communicating over HD-audio bus are moved to
struct hdac_bus now.  It has only command and get_response ops in
addition to the unsolicited event handling.

Note that the codec-side tracing support is disabled temporarily
during this transition due to the code shuffling.  It will be
re-enabled later once when all pieces are settled down.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit d068ebc25e6e1360510ad8023fe7bca3dacd204e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/sound/hdaudio.h
#	sound/hda/Makefile
#	sound/pci/hda/hda_bind.c
#	sound/pci/hda/hda_codec.c
#	sound/pci/hda/hda_intel.c
diff --cc sound/pci/hda/hda_bind.c
index a49bc45c2ea5,0b9ea70c546b..000000000000
--- a/sound/pci/hda/hda_bind.c
+++ b/sound/pci/hda/hda_bind.c
@@@ -145,13 -155,25 +154,27 @@@ static int hda_codec_driver_remove(stru
  int __hda_codec_driver_register(struct hda_codec_driver *drv, const char *name,
  			       struct module *owner)
  {
++<<<<<<< HEAD
 +	drv->driver.name = name;
 +	drv->driver.owner = owner;
 +	drv->driver.bus = &snd_hda_bus_type;
 +	drv->driver.probe = hda_codec_driver_probe;
 +	drv->driver.remove = hda_codec_driver_remove;
 +	drv->driver.pm = &hda_codec_driver_pm;
 +	return driver_register(&drv->driver);
++=======
+ 	drv->core.driver.name = name;
+ 	drv->core.driver.owner = owner;
+ 	drv->core.driver.bus = &snd_hda_bus_type;
+ 	drv->core.driver.probe = hda_codec_driver_probe;
+ 	drv->core.driver.remove = hda_codec_driver_remove;
+ 	drv->core.driver.shutdown = hda_codec_driver_shutdown;
+ 	drv->core.driver.pm = &hda_codec_driver_pm;
+ 	drv->core.type = HDA_DEV_LEGACY;
+ 	drv->core.match = hda_codec_match;
+ 	drv->core.unsol_event = hda_codec_unsol_event;
+ 	return driver_register(&drv->core.driver);
++>>>>>>> d068ebc25e6e (ALSA: hda - Move some codes up to hdac_bus struct)
  }
  EXPORT_SYMBOL_GPL(__hda_codec_driver_register);
  
diff --cc sound/pci/hda/hda_codec.c
index 05cb5f57659a,f96bff37c787..000000000000
--- a/sound/pci/hda/hda_codec.c
+++ b/sound/pci/hda/hda_codec.c
@@@ -1259,10 -1173,20 +1204,25 @@@ static int snd_hda_codec_dev_free(struc
  	return 0;
  }
  
 +/* just free the container */
  static void snd_hda_codec_dev_release(struct device *dev)
  {
++<<<<<<< HEAD
 +	kfree(dev_to_hda_codec(dev));
++=======
+ 	struct hda_codec *codec = dev_to_hda_codec(dev);
+ 
+ 	free_init_pincfgs(codec);
+ 	snd_hdac_bus_remove_device(&codec->bus->core, &codec->core);
+ 	snd_hda_sysfs_clear(codec);
+ 	free_hda_cache(&codec->amp_cache);
+ 	free_hda_cache(&codec->cmd_cache);
+ 	kfree(codec->vendor_name);
+ 	kfree(codec->chip_name);
+ 	kfree(codec->modelname);
+ 	kfree(codec->wcaps);
+ 	kfree(codec);
++>>>>>>> d068ebc25e6e (ALSA: hda - Move some codes up to hdac_bus struct)
  }
  
  /**
@@@ -1338,9 -1259,9 +1295,13 @@@ int snd_hda_codec_new(struct hda_bus *b
  
  #ifdef CONFIG_PM
  	/* snd_hda_codec_new() marks the codec as power-up, and leave it as is.
 -	 * it's powered down later in snd_hda_codec_dev_register().
 +	 * the caller has to power down appropriatley after initialization
 +	 * phase.
  	 */
++<<<<<<< HEAD
++=======
+ 	set_bit(codec->core.addr, &bus->core.codec_powered);
++>>>>>>> d068ebc25e6e (ALSA: hda - Move some codes up to hdac_bus struct)
  	pm_runtime_set_active(hda_codec_dev(codec));
  	pm_runtime_get_noresume(hda_codec_dev(codec));
  	codec->power_jiffies = jiffies;
@@@ -4016,14 -3926,17 +3974,26 @@@ static int hda_codec_runtime_suspend(st
  	list_for_each_entry(pcm, &codec->pcm_list_head, list)
  		snd_pcm_suspend_all(pcm->pcm);
  	state = hda_call_codec_suspend(codec);
++<<<<<<< HEAD
 +	if (!codec->bus->power_keep_link_on && (state & AC_PWRST_CLK_STOP_OK))
 +		hda_call_pm_notify(codec, false);
++=======
+ 	if (codec->d3_stop_clk && codec->epss && (state & AC_PWRST_CLK_STOP_OK))
+ 		clear_bit(codec->core.addr, &codec->bus->core.codec_powered);
++>>>>>>> d068ebc25e6e (ALSA: hda - Move some codes up to hdac_bus struct)
  	return 0;
  }
  
  static int hda_codec_runtime_resume(struct device *dev)
  {
++<<<<<<< HEAD
 +	hda_call_codec_resume(dev_to_hda_codec(dev));
++=======
+ 	struct hda_codec *codec = dev_to_hda_codec(dev);
+ 
+ 	set_bit(codec->core.addr, &codec->bus->core.codec_powered);
+ 	hda_call_codec_resume(codec);
++>>>>>>> d068ebc25e6e (ALSA: hda - Move some codes up to hdac_bus struct)
  	pm_runtime_mark_last_busy(dev);
  	return 0;
  }
@@@ -4778,7 -4680,22 +4748,26 @@@ void snd_hda_power_sync(struct hda_code
  		pm_runtime_forbid(dev);
  	}
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL_GPL(snd_hda_power_sync);
++=======
+ 
+ /**
+  * snd_hda_set_power_save - reprogram autosuspend for the given delay
+  * @bus: HD-audio bus
+  * @delay: autosuspend delay in msec, 0 = off
+  *
+  * Synchronize the runtime PM autosuspend state from the power_save option.
+  */
+ void snd_hda_set_power_save(struct hda_bus *bus, int delay)
+ {
+ 	struct hda_codec *c;
+ 
+ 	list_for_each_codec(c, bus)
+ 		codec_set_power_save(c, delay);
+ }
+ EXPORT_SYMBOL_GPL(snd_hda_set_power_save);
++>>>>>>> d068ebc25e6e (ALSA: hda - Move some codes up to hdac_bus struct)
  
  /**
   * snd_hda_check_amp_list_power - Check the amp list and update the power
diff --cc sound/pci/hda/hda_intel.c
index 34eb98e2793b,feebc1dda912..000000000000
--- a/sound/pci/hda/hda_intel.c
+++ b/sound/pci/hda/hda_intel.c
@@@ -922,8 -918,8 +922,13 @@@ static int azx_runtime_idle(struct devi
  	if (chip->disabled || hda->init_failed)
  		return 0;
  
++<<<<<<< HEAD
 +	if (!power_save_controller ||
 +	    !(chip->driver_caps & AZX_DCAPS_PM_RUNTIME))
++=======
+ 	if (!power_save_controller || !azx_has_pm_runtime(chip) ||
+ 	    chip->bus->core.codec_powered)
++>>>>>>> d068ebc25e6e (ALSA: hda - Move some codes up to hdac_bus struct)
  		return -EBUSY;
  
  	return 0;
* Unmerged path include/sound/hdaudio.h
* Unmerged path sound/hda/Makefile
* Unmerged path include/sound/hdaudio.h
* Unmerged path sound/hda/Makefile
diff --git a/sound/hda/hdac_bus.c b/sound/hda/hdac_bus.c
new file mode 100644
index 000000000000..364f64c0e4a3
--- /dev/null
+++ b/sound/hda/hdac_bus.c
@@ -0,0 +1,181 @@
+/*
+ * HD-audio core bus driver
+ */
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/export.h>
+#include <sound/hdaudio.h>
+
+static void process_unsol_events(struct work_struct *work);
+
+/**
+ * snd_hdac_bus_init - initialize a HD-audio bas bus
+ * @bus: the pointer to bus object
+ *
+ * Returns 0 if successful, or a negative error code.
+ */
+int snd_hdac_bus_init(struct hdac_bus *bus, struct device *dev,
+		      const struct hdac_bus_ops *ops)
+{
+	memset(bus, 0, sizeof(*bus));
+	bus->dev = dev;
+	bus->ops = ops;
+	INIT_LIST_HEAD(&bus->codec_list);
+	INIT_WORK(&bus->unsol_work, process_unsol_events);
+	mutex_init(&bus->cmd_mutex);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_bus_init);
+
+/**
+ * snd_hdac_bus_exit - clean up a HD-audio bas bus
+ * @bus: the pointer to bus object
+ */
+void snd_hdac_bus_exit(struct hdac_bus *bus)
+{
+	WARN_ON(!list_empty(&bus->codec_list));
+	cancel_work_sync(&bus->unsol_work);
+}
+EXPORT_SYMBOL_GPL(snd_hdac_bus_exit);
+
+/**
+ * snd_hdac_bus_exec_verb - execute a HD-audio verb on the given bus
+ * @bus: bus object
+ * @cmd: HD-audio encoded verb
+ * @res: pointer to store the response, NULL if performing asynchronously
+ *
+ * Returns 0 if successful, or a negative error code.
+ */
+int snd_hdac_bus_exec_verb(struct hdac_bus *bus, unsigned int addr,
+			   unsigned int cmd, unsigned int *res)
+{
+	int err;
+
+	mutex_lock(&bus->cmd_mutex);
+	err = snd_hdac_bus_exec_verb_unlocked(bus, addr, cmd, res);
+	mutex_unlock(&bus->cmd_mutex);
+	return err;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_bus_exec_verb);
+
+/**
+ * snd_hdac_bus_exec_verb_unlocked - unlocked version
+ * @bus: bus object
+ * @cmd: HD-audio encoded verb
+ * @res: pointer to store the response, NULL if performing asynchronously
+ *
+ * Returns 0 if successful, or a negative error code.
+ */
+int snd_hdac_bus_exec_verb_unlocked(struct hdac_bus *bus, unsigned int addr,
+				    unsigned int cmd, unsigned int *res)
+{
+	unsigned int tmp;
+	int err;
+
+	if (cmd == ~0)
+		return -EINVAL;
+
+	if (res)
+		*res = -1;
+	else if (bus->sync_write)
+		res = &tmp;
+	for (;;) {
+		err = bus->ops->command(bus, cmd);
+		if (err != -EAGAIN)
+			break;
+		/* process pending verbs */
+		err = bus->ops->get_response(bus, addr, &tmp);
+		if (err)
+			break;
+	}
+	if (!err && res)
+		err = bus->ops->get_response(bus, addr, res);
+	return err;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_bus_exec_verb_unlocked);
+
+/**
+ * snd_hdac_bus_queue_event - add an unsolicited event to queue
+ * @bus: the BUS
+ * @res: unsolicited event (lower 32bit of RIRB entry)
+ * @res_ex: codec addr and flags (upper 32bit or RIRB entry)
+ *
+ * Adds the given event to the queue.  The events are processed in
+ * the workqueue asynchronously.  Call this function in the interrupt
+ * hanlder when RIRB receives an unsolicited event.
+ */
+void snd_hdac_bus_queue_event(struct hdac_bus *bus, u32 res, u32 res_ex)
+{
+	unsigned int wp;
+
+	if (!bus)
+		return;
+
+	wp = (bus->unsol_wp + 1) % HDA_UNSOL_QUEUE_SIZE;
+	bus->unsol_wp = wp;
+
+	wp <<= 1;
+	bus->unsol_queue[wp] = res;
+	bus->unsol_queue[wp + 1] = res_ex;
+
+	schedule_work(&bus->unsol_work);
+}
+EXPORT_SYMBOL_GPL(snd_hdac_bus_queue_event);
+
+/*
+ * process queued unsolicited events
+ */
+static void process_unsol_events(struct work_struct *work)
+{
+	struct hdac_bus *bus = container_of(work, struct hdac_bus, unsol_work);
+	struct hdac_device *codec;
+	struct hdac_driver *drv;
+	unsigned int rp, caddr, res;
+
+	while (bus->unsol_rp != bus->unsol_wp) {
+		rp = (bus->unsol_rp + 1) % HDA_UNSOL_QUEUE_SIZE;
+		bus->unsol_rp = rp;
+		rp <<= 1;
+		res = bus->unsol_queue[rp];
+		caddr = bus->unsol_queue[rp + 1];
+		if (!(caddr & (1 << 4))) /* no unsolicited event? */
+			continue;
+		codec = bus->caddr_tbl[caddr & 0x0f];
+		if (!codec || !codec->dev.driver)
+			continue;
+		drv = drv_to_hdac_driver(codec->dev.driver);
+		if (drv->unsol_event)
+			drv->unsol_event(codec, res);
+	}
+}
+
+int snd_hdac_bus_add_device(struct hdac_bus *bus, struct hdac_device *codec)
+{
+	if (bus->caddr_tbl[codec->addr]) {
+		dev_err(bus->dev, "address 0x%x is already occupied\n",
+			codec->addr);
+		return -EBUSY;
+	}
+
+	list_add_tail(&codec->list, &bus->codec_list);
+	bus->caddr_tbl[codec->addr] = codec;
+	set_bit(codec->addr, &bus->codec_powered);
+	bus->num_codecs++;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_bus_add_device);
+
+void snd_hdac_bus_remove_device(struct hdac_bus *bus,
+				struct hdac_device *codec)
+{
+	WARN_ON(bus != codec->bus);
+	if (list_empty(&codec->list))
+		return;
+	list_del_init(&codec->list);
+	bus->caddr_tbl[codec->addr] = NULL;
+	clear_bit(codec->addr, &bus->codec_powered);
+	bus->num_codecs--;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_bus_remove_device);
* Unmerged path sound/pci/hda/hda_bind.c
* Unmerged path sound/pci/hda/hda_codec.c
diff --git a/sound/pci/hda/hda_codec.h b/sound/pci/hda/hda_codec.h
index 4f8090e5338d..4889a62c4eb9 100644
--- a/sound/pci/hda/hda_codec.h
+++ b/sound/pci/hda/hda_codec.h
@@ -101,16 +101,6 @@ struct hda_bus_ops {
 #endif
 };
 
-/* unsolicited event handler */
-#define HDA_UNSOL_QUEUE_SIZE	64
-struct hda_bus_unsolicited {
-	/* ring buffer */
-	u32 queue[HDA_UNSOL_QUEUE_SIZE * 2];
-	unsigned int rp, wp;
-	/* workqueue */
-	struct work_struct work;
-};
-
 /*
  * codec bus
  *
@@ -118,6 +108,8 @@ struct hda_bus_unsolicited {
  * A hda_bus contains several codecs in the list codec_list.
  */
 struct hda_bus {
+	struct hdac_bus core;
+
 	struct snd_card *card;
 
 	void *private_data;
@@ -126,25 +118,14 @@ struct hda_bus {
 	int *power_save;
 	struct hda_bus_ops ops;
 
-	/* codec linked list */
-	struct list_head codec_list;
-	unsigned int num_codecs;
-	/* link caddr -> codec */
-	struct hda_codec *caddr_tbl[HDA_MAX_CODEC_ADDRESS + 1];
-
-	struct mutex cmd_mutex;
 	struct mutex prepare_mutex;
 
-	/* unsolicited event queue */
-	struct hda_bus_unsolicited unsol;
-
 	/* assigned PCMs */
 	DECLARE_BITMAP(pcm_dev_bits, SNDRV_PCM_DEVICES);
 
 	/* misc op flags */
 	unsigned int needs_damn_long_delay :1;
 	unsigned int allow_bus_reset:1;	/* allow bus reset at fatal error */
-	unsigned int sync_write:1;	/* sync after verb write */
 	/* status for codec/controller */
 	unsigned int shutdown :1;	/* being unloaded */
 	unsigned int rirb_error:1;	/* error in codec communication */
@@ -285,7 +266,6 @@ struct hda_codec {
 	struct hda_bus *bus;
 	struct snd_card *card;
 	unsigned int addr;	/* codec addr*/
-	struct list_head list;	/* list point */
 
 	hda_nid_t afg;	/* AFG node id */
 	hda_nid_t mfg;	/* MFG node id */
@@ -420,6 +400,9 @@ struct hda_codec {
 
 extern struct bus_type snd_hda_bus_type;
 
+#define list_for_each_codec(c, bus) \
+	list_for_each_entry(c, &(bus)->core.codec_list, core.list)
+
 /* direction */
 enum {
 	HDA_INPUT, HDA_OUTPUT
@@ -480,7 +463,11 @@ void snd_hda_sequence_write(struct hda_codec *codec,
 			    const struct hda_verb *seq);
 
 /* unsolicited event */
-int snd_hda_queue_unsol_event(struct hda_bus *bus, u32 res, u32 res_ex);
+static inline void
+snd_hda_queue_unsol_event(struct hda_bus *bus, u32 res, u32 res_ex)
+{
+	snd_hdac_bus_queue_event(&bus->core, res, res_ex);
+}
 
 /* cached write */
 int snd_hda_codec_write_cache(struct hda_codec *codec, hda_nid_t nid,
diff --git a/sound/pci/hda/hda_controller.c b/sound/pci/hda/hda_controller.c
index 0d7233e1e418..64451859598a 100644
--- a/sound/pci/hda/hda_controller.c
+++ b/sound/pci/hda/hda_controller.c
@@ -1760,12 +1760,12 @@ static int probe_codec(struct azx *chip, int addr)
 		(AC_VERB_PARAMETERS << 8) | AC_PAR_VENDOR_ID;
 	unsigned int res;
 
-	mutex_lock(&chip->bus->cmd_mutex);
+	mutex_lock(&chip->bus->core.cmd_mutex);
 	chip->probing = 1;
 	azx_send_cmd(chip->bus, cmd);
 	res = azx_get_response(chip->bus, addr);
 	chip->probing = 0;
-	mutex_unlock(&chip->bus->cmd_mutex);
+	mutex_unlock(&chip->bus->core.cmd_mutex);
 	if (res == -1)
 		return -EIO;
 	dev_dbg(chip->card->dev, "codec #%d probed OK\n", addr);
@@ -1866,7 +1866,7 @@ int azx_bus_create(struct azx *chip, const char *model, int *power_save_to)
 	 */
 	if (chip->driver_caps & AZX_DCAPS_SYNC_WRITE) {
 		dev_dbg(chip->card->dev, "Enable sync_write for stable communication\n");
-		bus->sync_write = 1;
+		bus->core.sync_write = 1;
 		bus->allow_bus_reset = 1;
 	}
 
@@ -1931,7 +1931,7 @@ EXPORT_SYMBOL_GPL(azx_probe_codecs);
 int azx_codec_configure(struct azx *chip)
 {
 	struct hda_codec *codec;
-	list_for_each_entry(codec, &chip->bus->codec_list, list) {
+	list_for_each_codec(codec, chip->bus) {
 		snd_hda_codec_configure(codec);
 	}
 	return 0;
* Unmerged path sound/pci/hda/hda_intel.c
diff --git a/sound/pci/hda/hda_sysfs.c b/sound/pci/hda/hda_sysfs.c
index e13c75d67847..3b5ed1108f9f 100644
--- a/sound/pci/hda/hda_sysfs.c
+++ b/sound/pci/hda/hda_sysfs.c
@@ -552,7 +552,7 @@ static void parse_codec_mode(char *buf, struct hda_bus *bus,
 
 	*codecp = NULL;
 	if (sscanf(buf, "%i %i %i", &vendorid, &subid, &caddr) == 3) {
-		list_for_each_entry(codec, &bus->codec_list, list) {
+		list_for_each_codec(codec, bus) {
 			if ((vendorid <= 0 || codec->vendor_id == vendorid) &&
 			    (subid <= 0 || codec->subsystem_id == subid) &&
 			    codec->addr == caddr) {
diff --git a/sound/pci/hda/patch_conexant.c b/sound/pci/hda/patch_conexant.c
index 5aa466a13e43..142a6cf786da 100644
--- a/sound/pci/hda/patch_conexant.c
+++ b/sound/pci/hda/patch_conexant.c
@@ -919,10 +919,10 @@ static int patch_conexant_auto(struct hda_codec *codec)
 	 * which falls into the single-cmd mode.
 	 * Better to make reset, then.
 	 */
-	if (!codec->bus->sync_write) {
+	if (!codec->bus->core.sync_write) {
 		codec_info(codec,
 			   "Enable sync_write for stable communication\n");
-		codec->bus->sync_write = 1;
+		codec->bus->core.sync_write = 1;
 		codec->bus->allow_bus_reset = 1;
 	}
 
