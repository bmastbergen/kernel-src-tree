ACPI: Eliminate the DEVICE_ACPI_HANDLE() macro

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 3a83f992490f8235661b768e53bd5f14915420ac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/3a83f992.failed

Since DEVICE_ACPI_HANDLE() is now literally identical to
ACPI_HANDLE(), replace it with the latter everywhere and drop its
definition from include/acpi.h.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 3a83f992490f8235661b768e53bd5f14915420ac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/nouveau/core/subdev/mxm/base.c
#	drivers/gpu/drm/nouveau/nouveau_acpi.c
#	drivers/pci/pci-acpi.c
#	drivers/usb/core/usb-acpi.c
diff --cc drivers/gpu/drm/nouveau/core/subdev/mxm/base.c
index a3dda80c7707,129120473f6c..000000000000
--- a/drivers/gpu/drm/nouveau/core/subdev/mxm/base.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/mxm/base.c
@@@ -116,7 -116,7 +116,11 @@@ mxm_shadow_dsm(struct nouveau_mxm *mxm
  	acpi_handle handle;
  	int ret;
  
++<<<<<<< HEAD
 +	handle = ACPI_HANDLE(nv_device_base(device));
++=======
+ 	handle = ACPI_HANDLE(&device->pdev->dev);
++>>>>>>> 3a83f992490f (ACPI: Eliminate the DEVICE_ACPI_HANDLE() macro)
  	if (!handle)
  		return false;
  
diff --cc drivers/gpu/drm/nouveau/nouveau_acpi.c
index 3465ccfaedf3,d9eb65dae1f7..000000000000
--- a/drivers/gpu/drm/nouveau/nouveau_acpi.c
+++ b/drivers/gpu/drm/nouveau/nouveau_acpi.c
@@@ -423,6 -401,9 +423,12 @@@ bool nouveau_acpi_rom_supported(struct 
  	acpi_status status;
  	acpi_handle dhandle, rom_handle;
  
++<<<<<<< HEAD
++=======
+ 	if (!nouveau_dsm_priv.dsm_detected && !nouveau_dsm_priv.optimus_detected)
+ 		return false;
+ 
++>>>>>>> 3a83f992490f (ACPI: Eliminate the DEVICE_ACPI_HANDLE() macro)
  	dhandle = ACPI_HANDLE(&pdev->dev);
  	if (!dhandle)
  		return false;
diff --cc drivers/pci/pci-acpi.c
index b3a0995a271a,f166126e28d1..000000000000
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@@ -180,8 -180,7 +180,12 @@@ static bool acpi_pci_power_manageable(s
  
  static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
  {
++<<<<<<< HEAD
 +	acpi_handle handle = DEVICE_ACPI_HANDLE(&dev->dev);
 +	acpi_handle tmp;
++=======
+ 	acpi_handle handle = ACPI_HANDLE(&dev->dev);
++>>>>>>> 3a83f992490f (ACPI: Eliminate the DEVICE_ACPI_HANDLE() macro)
  	static const u8 state_conv[] = {
  		[PCI_D0] = ACPI_STATE_D0,
  		[PCI_D1] = ACPI_STATE_D1,
diff --cc drivers/usb/core/usb-acpi.c
index a42fa390293d,4e243c37f17f..000000000000
--- a/drivers/usb/core/usb-acpi.c
+++ b/drivers/usb/core/usb-acpi.c
@@@ -148,19 -148,38 +148,49 @@@ static struct acpi_device *usb_acpi_fin
  	 */
  	if (is_usb_device(dev)) {
  		udev = to_usb_device(dev);
 -		if (udev->parent) {
 -			enum usb_port_connect_type type;
 +		if (udev->parent)
 +			return NULL;
  
++<<<<<<< HEAD
 +		/* root hub is only child (_ADR=0) under its parent, the HC */
 +		adev = ACPI_COMPANION(dev->parent);
 +		return acpi_find_child_device(adev, 0, false);
++=======
+ 			/*
+ 			 * According usb port's connect type to set usb device's
+ 			 * removability.
+ 			 */
+ 			type = usb_get_hub_port_connect_type(udev->parent,
+ 				udev->portnum);
+ 			switch (type) {
+ 			case USB_PORT_CONNECT_TYPE_HOT_PLUG:
+ 				udev->removable = USB_DEVICE_REMOVABLE;
+ 				break;
+ 			case USB_PORT_CONNECT_TYPE_HARD_WIRED:
+ 				udev->removable = USB_DEVICE_FIXED;
+ 				break;
+ 			default:
+ 				udev->removable = USB_DEVICE_REMOVABLE_UNKNOWN;
+ 				break;
+ 			}
+ 
+ 			return -ENODEV;
+ 		}
+ 
+ 		/* root hub's parent is the usb hcd. */
+ 		parent_handle = ACPI_HANDLE(dev->parent);
+ 		*handle = acpi_get_child(parent_handle, udev->portnum);
+ 		if (!*handle)
+ 			return -ENODEV;
+ 		return 0;
++>>>>>>> 3a83f992490f (ACPI: Eliminate the DEVICE_ACPI_HANDLE() macro)
  	} else if (is_usb_port(dev)) {
 -		sscanf(dev_name(dev), "port%d", &port_num);
 +		struct usb_port *port_dev = to_usb_port(dev);
 +		int port1 = port_dev->portnum;
 +		struct acpi_pld_info *pld;
 +		acpi_handle *handle;
 +		acpi_status status;
 +
  		/* Get the struct usb_device point of port's hub */
  		udev = to_usb_device(dev->parent->parent);
  
@@@ -171,13 -190,14 +201,22 @@@
  		 */
  		if (!udev->parent) {
  			struct usb_hcd *hcd = bus_to_hcd(udev->bus);
 -			int raw_port_num;
 +			int raw;
  
++<<<<<<< HEAD
 +			raw = usb_hcd_find_raw_port_number(hcd, port1);
 +			adev = acpi_find_child_device(ACPI_COMPANION(&udev->dev),
 +					raw, false);
 +			if (!adev)
 +				return NULL;
++=======
+ 			raw_port_num = usb_hcd_find_raw_port_number(hcd,
+ 				port_num);
+ 			*handle = acpi_get_child(ACPI_HANDLE(&udev->dev),
+ 				raw_port_num);
+ 			if (!*handle)
+ 				return -ENODEV;
++>>>>>>> 3a83f992490f (ACPI: Eliminate the DEVICE_ACPI_HANDLE() macro)
  		} else {
  			parent_handle =
  				usb_get_hub_port_acpi_handle(udev->parent,
diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 349416a9d217..bce55ef59dce 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -564,7 +564,7 @@ static int acpi_dev_pm_get_state(struct device *dev, struct acpi_device *adev,
  */
 int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p, int d_max_in)
 {
-	acpi_handle handle = DEVICE_ACPI_HANDLE(dev);
+	acpi_handle handle = ACPI_HANDLE(dev);
 	struct acpi_device *adev;
 	int ret, d_min, d_max;
 
@@ -672,7 +672,7 @@ int acpi_pm_device_run_wake(struct device *phys_dev, bool enable)
 	if (!device_run_wake(phys_dev))
 		return -EINVAL;
 
-	handle = DEVICE_ACPI_HANDLE(phys_dev);
+	handle = ACPI_HANDLE(phys_dev);
 	if (!handle || acpi_bus_get_device(handle, &adev)) {
 		dev_dbg(phys_dev, "ACPI handle without context in %s!\n",
 			__func__);
@@ -716,7 +716,7 @@ int acpi_pm_device_sleep_wake(struct device *dev, bool enable)
 	if (!device_can_wakeup(dev))
 		return -EINVAL;
 
-	handle = DEVICE_ACPI_HANDLE(dev);
+	handle = ACPI_HANDLE(dev);
 	if (!handle || acpi_bus_get_device(handle, &adev)) {
 		dev_dbg(dev, "ACPI handle without context in %s!\n", __func__);
 		return -ENODEV;
@@ -738,7 +738,7 @@ int acpi_pm_device_sleep_wake(struct device *dev, bool enable)
  */
 struct acpi_device *acpi_dev_pm_get_node(struct device *dev)
 {
-	acpi_handle handle = DEVICE_ACPI_HANDLE(dev);
+	acpi_handle handle = ACPI_HANDLE(dev);
 	struct acpi_device *adev;
 
 	return handle && !acpi_bus_get_device(handle, &adev) ? adev : NULL;
diff --git a/drivers/gpu/drm/i915/intel_acpi.c b/drivers/gpu/drm/i915/intel_acpi.c
index 57fe1ae32a0d..3a5e768028c6 100644
--- a/drivers/gpu/drm/i915/intel_acpi.c
+++ b/drivers/gpu/drm/i915/intel_acpi.c
@@ -197,7 +197,7 @@ static bool intel_dsm_pci_probe(struct pci_dev *pdev)
 	acpi_status status;
 	int ret;
 
-	dhandle = DEVICE_ACPI_HANDLE(&pdev->dev);
+	dhandle = ACPI_HANDLE(&pdev->dev);
 	if (!dhandle)
 		return false;
 
* Unmerged path drivers/gpu/drm/nouveau/core/subdev/mxm/base.c
* Unmerged path drivers/gpu/drm/nouveau/nouveau_acpi.c
diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 29a9fefa3bb5..b31208d295e3 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -448,7 +448,7 @@ static bool radeon_atpx_pci_probe_handle(struct pci_dev *pdev)
 	acpi_handle dhandle, atpx_handle;
 	acpi_status status;
 
-	dhandle = DEVICE_ACPI_HANDLE(&pdev->dev);
+	dhandle = ACPI_HANDLE(&pdev->dev);
 	if (!dhandle)
 		return false;
 
@@ -495,7 +495,7 @@ static int radeon_atpx_init(void)
  */
 static int radeon_atpx_get_client_id(struct pci_dev *pdev)
 {
-	if (radeon_atpx_priv.dhandle == DEVICE_ACPI_HANDLE(&pdev->dev))
+	if (radeon_atpx_priv.dhandle == ACPI_HANDLE(&pdev->dev))
 		return VGA_SWITCHEROO_IGD;
 	else
 		return VGA_SWITCHEROO_DIS;
diff --git a/drivers/ide/ide-acpi.c b/drivers/ide/ide-acpi.c
index 761155399030..1ee4147bad93 100644
--- a/drivers/ide/ide-acpi.c
+++ b/drivers/ide/ide-acpi.c
@@ -138,7 +138,7 @@ static int ide_get_dev_handle(struct device *dev, acpi_handle *handle,
 
 	DEBPRINT("ENTER: pci %02x:%02x.%01x\n", bus, devnum, func);
 
-	dev_handle = DEVICE_ACPI_HANDLE(dev);
+	dev_handle = ACPI_HANDLE(dev);
 	if (!dev_handle) {
 		DEBPRINT("no acpi handle for device\n");
 		goto err;
diff --git a/drivers/pci/hotplug/acpi_pcihp.c b/drivers/pci/hotplug/acpi_pcihp.c
index f8140164ec0b..21cc412d242a 100644
--- a/drivers/pci/hotplug/acpi_pcihp.c
+++ b/drivers/pci/hotplug/acpi_pcihp.c
@@ -367,7 +367,7 @@ int acpi_get_hp_hw_control_from_firmware(struct pci_dev *pdev, u32 flags)
 		string = (struct acpi_buffer){ ACPI_ALLOCATE_BUFFER, NULL };
 	}
 
-	handle = DEVICE_ACPI_HANDLE(&pdev->dev);
+	handle = ACPI_HANDLE(&pdev->dev);
 	if (!handle) {
 		/*
 		 * This hotplug controller was not listed in the ACPI name
diff --git a/drivers/pci/hotplug/pciehp_acpi.c b/drivers/pci/hotplug/pciehp_acpi.c
index 5cbee9823bb0..20fea57d2149 100644
--- a/drivers/pci/hotplug/pciehp_acpi.c
+++ b/drivers/pci/hotplug/pciehp_acpi.c
@@ -54,7 +54,7 @@ int pciehp_acpi_slot_detection_check(struct pci_dev *dev)
 {
 	if (slot_detection_mode != PCIEHP_DETECT_ACPI)
 		return 0;
-	if (acpi_pci_detect_ejectable(DEVICE_ACPI_HANDLE(&dev->dev)))
+	if (acpi_pci_detect_ejectable(ACPI_HANDLE(&dev->dev)))
 		return 0;
 	return -ENODEV;
 }
@@ -96,7 +96,7 @@ static int __init dummy_probe(struct pcie_device *dev)
 			dup_slot_id++;
 	}
 	list_add_tail(&slot->list, &dummy_slots);
-	handle = DEVICE_ACPI_HANDLE(&pdev->dev);
+	handle = ACPI_HANDLE(&pdev->dev);
 	if (!acpi_slot_detected && acpi_pci_detect_ejectable(handle))
 		acpi_slot_detected = 1;
 	return -ENODEV;         /* dummy driver always returns error */
diff --git a/drivers/pci/ioapic.c b/drivers/pci/ioapic.c
index 7d6b157463e1..2c2930ea06ad 100644
--- a/drivers/pci/ioapic.c
+++ b/drivers/pci/ioapic.c
@@ -37,7 +37,7 @@ static int ioapic_probe(struct pci_dev *dev, const struct pci_device_id *ent)
 	char *type;
 	struct resource *res;
 
-	handle = DEVICE_ACPI_HANDLE(&dev->dev);
+	handle = ACPI_HANDLE(&dev->dev);
 	if (!handle)
 		return -EINVAL;
 
* Unmerged path drivers/pci/pci-acpi.c
diff --git a/drivers/pci/pci-label.c b/drivers/pci/pci-label.c
index 3f165c6fddef..6f5d343d251c 100644
--- a/drivers/pci/pci-label.c
+++ b/drivers/pci/pci-label.c
@@ -238,7 +238,7 @@ device_has_dsm(struct device *dev)
 	acpi_handle handle;
 	struct acpi_buffer output = {ACPI_ALLOCATE_BUFFER, NULL};
 
-	handle = DEVICE_ACPI_HANDLE(dev);
+	handle = ACPI_HANDLE(dev);
 
 	if (!handle)
 		return FALSE;
@@ -270,7 +270,7 @@ acpilabel_show(struct device *dev, struct device_attribute *attr, char *buf)
 	acpi_handle handle;
 	int length;
 
-	handle = DEVICE_ACPI_HANDLE(dev);
+	handle = ACPI_HANDLE(dev);
 
 	if (!handle)
 		return -1;
@@ -291,7 +291,7 @@ acpiindex_show(struct device *dev, struct device_attribute *attr, char *buf)
 	acpi_handle handle;
 	int length;
 
-	handle = DEVICE_ACPI_HANDLE(dev);
+	handle = ACPI_HANDLE(dev);
 
 	if (!handle)
 		return -1;
diff --git a/drivers/platform/x86/apple-gmux.c b/drivers/platform/x86/apple-gmux.c
index f74bfcbb7bad..5db179c1c579 100644
--- a/drivers/platform/x86/apple-gmux.c
+++ b/drivers/platform/x86/apple-gmux.c
@@ -515,7 +515,7 @@ static int gmux_probe(struct pnp_dev *pnp, const struct pnp_device_id *id)
 
 	gmux_data->power_state = VGA_SWITCHEROO_ON;
 
-	gmux_data->dhandle = DEVICE_ACPI_HANDLE(&pnp->dev);
+	gmux_data->dhandle = ACPI_HANDLE(&pnp->dev);
 	if (!gmux_data->dhandle) {
 		pr_err("Cannot find acpi handle for pnp device %s\n",
 		       dev_name(&pnp->dev));
diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index cb6047304034..a9d8d7453638 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -88,7 +88,7 @@ static int pnpacpi_set_resources(struct pnp_dev *dev)
 
 	pnp_dbg(&dev->dev, "set resources\n");
 
-	handle = DEVICE_ACPI_HANDLE(&dev->dev);
+	handle = ACPI_HANDLE(&dev->dev);
 	if (!handle || acpi_bus_get_device(handle, &acpi_dev)) {
 		dev_dbg(&dev->dev, "ACPI device not found in %s!\n", __func__);
 		return -ENODEV;
@@ -128,7 +128,7 @@ static int pnpacpi_disable_resources(struct pnp_dev *dev)
 
 	dev_dbg(&dev->dev, "disable resources\n");
 
-	handle = DEVICE_ACPI_HANDLE(&dev->dev);
+	handle = ACPI_HANDLE(&dev->dev);
 	if (!handle || acpi_bus_get_device(handle, &acpi_dev)) {
 		dev_dbg(&dev->dev, "ACPI device not found in %s!\n", __func__);
 		return 0;
@@ -152,7 +152,7 @@ static bool pnpacpi_can_wakeup(struct pnp_dev *dev)
 	struct acpi_device *acpi_dev;
 	acpi_handle handle;
 
-	handle = DEVICE_ACPI_HANDLE(&dev->dev);
+	handle = ACPI_HANDLE(&dev->dev);
 	if (!handle || acpi_bus_get_device(handle, &acpi_dev)) {
 		dev_dbg(&dev->dev, "ACPI device not found in %s!\n", __func__);
 		return false;
@@ -167,7 +167,7 @@ static int pnpacpi_suspend(struct pnp_dev *dev, pm_message_t state)
 	acpi_handle handle;
 	int error = 0;
 
-	handle = DEVICE_ACPI_HANDLE(&dev->dev);
+	handle = ACPI_HANDLE(&dev->dev);
 	if (!handle || acpi_bus_get_device(handle, &acpi_dev)) {
 		dev_dbg(&dev->dev, "ACPI device not found in %s!\n", __func__);
 		return 0;
@@ -202,7 +202,7 @@ static int pnpacpi_suspend(struct pnp_dev *dev, pm_message_t state)
 static int pnpacpi_resume(struct pnp_dev *dev)
 {
 	struct acpi_device *acpi_dev;
-	acpi_handle handle = DEVICE_ACPI_HANDLE(&dev->dev);
+	acpi_handle handle = ACPI_HANDLE(&dev->dev);
 	int error = 0;
 
 	if (!handle || acpi_bus_get_device(handle, &acpi_dev)) {
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 222d3110a296..3d59e4a88acb 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -5660,6 +5660,6 @@ acpi_handle usb_get_hub_port_acpi_handle(struct usb_device *hdev,
 	if (!hub)
 		return NULL;
 
-	return DEVICE_ACPI_HANDLE(&hub->ports[port1 - 1]->dev);
+	return ACPI_HANDLE(&hub->ports[port1 - 1]->dev);
 }
 #endif
* Unmerged path drivers/usb/core/usb-acpi.c
diff --git a/drivers/xen/pci.c b/drivers/xen/pci.c
index 18fff88254eb..cc86b267056f 100644
--- a/drivers/xen/pci.c
+++ b/drivers/xen/pci.c
@@ -58,12 +58,12 @@ static int xen_add_device(struct device *dev)
 			add.flags = XEN_PCI_DEV_EXTFN;
 
 #ifdef CONFIG_ACPI
-		handle = DEVICE_ACPI_HANDLE(&pci_dev->dev);
+		handle = ACPI_HANDLE(&pci_dev->dev);
 		if (!handle && pci_dev->bus->bridge)
-			handle = DEVICE_ACPI_HANDLE(pci_dev->bus->bridge);
+			handle = ACPI_HANDLE(pci_dev->bus->bridge);
 #ifdef CONFIG_PCI_IOV
 		if (!handle && pci_dev->is_virtfn)
-			handle = DEVICE_ACPI_HANDLE(physfn->bus->bridge);
+			handle = ACPI_HANDLE(physfn->bus->bridge);
 #endif
 		if (handle) {
 			acpi_status status;
diff --git a/include/linux/acpi.h b/include/linux/acpi.h
index 3ebc82e7b5ca..51ce9d2e9c4d 100644
--- a/include/linux/acpi.h
+++ b/include/linux/acpi.h
@@ -483,8 +483,6 @@ static inline bool acpi_driver_match_device(struct device *dev,
 
 #endif	/* !CONFIG_ACPI */
 
-#define DEVICE_ACPI_HANDLE(dev)	ACPI_HANDLE(dev)
-
 #ifdef CONFIG_ACPI
 void acpi_os_set_prepare_sleep(int (*func)(u8 sleep_state,
 			       u32 pm1a_ctrl,  u32 pm1b_ctrl));
diff --git a/include/linux/pci-acpi.h b/include/linux/pci-acpi.h
index 4935a1f105ac..637a608ded0b 100644
--- a/include/linux/pci-acpi.h
+++ b/include/linux/pci-acpi.h
@@ -27,7 +27,7 @@ static inline acpi_handle acpi_find_root_bridge_handle(struct pci_dev *pdev)
 	while (!pci_is_root_bus(pbus))
 		pbus = pbus->parent;
 
-	return DEVICE_ACPI_HANDLE(pbus->bridge);
+	return ACPI_HANDLE(pbus->bridge);
 }
 
 static inline acpi_handle acpi_pci_get_bridge_handle(struct pci_bus *pbus)
@@ -39,7 +39,7 @@ static inline acpi_handle acpi_pci_get_bridge_handle(struct pci_bus *pbus)
 	else
 		dev = &pbus->self->dev;
 
-	return DEVICE_ACPI_HANDLE(dev);
+	return ACPI_HANDLE(dev);
 }
 
 void acpi_pci_add_bus(struct pci_bus *bus);
