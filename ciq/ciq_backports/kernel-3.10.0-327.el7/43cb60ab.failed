powerpc/powernv/ioda2: Introduce pnv_pci_ioda2_set_window

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [powerpc] powernv/ioda2: Introduce pnv_pci_ioda2_set_window (David Gibson) [1213665]
Rebuild_FUZZ: 92.45%
commit-author Alexey Kardashevskiy <aik@ozlabs.ru>
commit 43cb60ab7f8c91b9bf5988edc318dee99ec93b9b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/43cb60ab.failed

This is a part of moving DMA window programming to an iommu_ops
callback. pnv_pci_ioda2_set_window() takes an iommu_table_group as
a first parameter (not pnv_ioda_pe) as it is going to be used as
a callback for VFIO DDW code.

This should cause no behavioural change.

	Signed-off-by: Alexey Kardashevskiy <aik@ozlabs.ru>
	Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
	Reviewed-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
	Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 43cb60ab7f8c91b9bf5988edc318dee99ec93b9b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/powernv/pci-ioda.c
diff --cc arch/powerpc/platforms/powernv/pci-ioda.c
index 109e90d84e34,552f6ac52560..000000000000
--- a/arch/powerpc/platforms/powernv/pci-ioda.c
+++ b/arch/powerpc/platforms/powernv/pci-ioda.c
@@@ -756,12 -1964,51 +756,53 @@@ static void pnv_pci_ioda_setup_dma_pe(s
  		pe->tce32_seg = -1;
  	if (tce_mem)
  		__free_pages(tce_mem, get_order(TCE32_TABLE_SIZE * segs));
 -	if (tbl) {
 -		pnv_pci_unlink_table_and_group(tbl, &pe->table_group);
 -		iommu_free_table(tbl, "pnv");
 -	}
  }
  
++<<<<<<< HEAD
 +static void pnv_pci_ioda2_set_bypass(struct iommu_table *tbl, bool enable)
++=======
+ static long pnv_pci_ioda2_set_window(struct iommu_table_group *table_group,
+ 		int num, struct iommu_table *tbl)
+ {
+ 	struct pnv_ioda_pe *pe = container_of(table_group, struct pnv_ioda_pe,
+ 			table_group);
+ 	struct pnv_phb *phb = pe->phb;
+ 	int64_t rc;
+ 	const __u64 start_addr = tbl->it_offset << tbl->it_page_shift;
+ 	const __u64 win_size = tbl->it_size << tbl->it_page_shift;
+ 
+ 	pe_info(pe, "Setting up window %llx..%llx pg=%x\n",
+ 			start_addr, start_addr + win_size - 1,
+ 			IOMMU_PAGE_SIZE(tbl));
+ 
+ 	/*
+ 	 * Map TCE table through TVT. The TVE index is the PE number
+ 	 * shifted by 1 bit for 32-bits DMA space.
+ 	 */
+ 	rc = opal_pci_map_pe_dma_window(phb->opal_id,
+ 			pe->pe_number,
+ 			pe->pe_number << 1,
+ 			1,
+ 			__pa(tbl->it_base),
+ 			tbl->it_size << 3,
+ 			IOMMU_PAGE_SIZE(tbl));
+ 	if (rc) {
+ 		pe_err(pe, "Failed to configure TCE table, err %ld\n", rc);
+ 		return rc;
+ 	}
+ 
+ 	pnv_pci_link_table_and_group(phb->hose->node, num,
+ 			tbl, &pe->table_group);
+ 	pnv_pci_ioda2_tce_invalidate_entire(pe);
+ 
+ 	return 0;
+ }
+ 
+ static void pnv_pci_ioda2_set_bypass(struct pnv_ioda_pe *pe, bool enable)
++>>>>>>> 43cb60ab7f8c (powerpc/powernv/ioda2: Introduce pnv_pci_ioda2_set_window)
  {
 +	struct pnv_ioda_pe *pe = container_of(tbl, struct pnv_ioda_pe,
 +					      tce32_table);
  	uint16_t window_id = (pe->pe_number << 1 ) + 1;
  	int64_t rc;
  
@@@ -826,62 -2135,59 +867,69 @@@ static void pnv_pci_ioda2_setup_dma_pe(
  	if (WARN_ON(pe->tce32_seg >= 0))
  		return;
  
 -	/* TVE #1 is selected by PCI address bit 59 */
 -	pe->tce_bypass_base = 1ull << 59;
 -
 -	tbl = pnv_pci_table_alloc(phb->hose->node);
 -	iommu_register_group(&pe->table_group, phb->hose->global_number,
 -			pe->pe_number);
 -	pnv_pci_link_table_and_group(phb->hose->node, 0, tbl, &pe->table_group);
 -
  	/* The PE will reserve all possible 32-bits space */
  	pe->tce32_seg = 0;
 +	end = (1 << ilog2(phb->ioda.m32_pci_base));
 +	tce_table_size = (end / 0x1000) * 8;
  	pe_info(pe, "Setting up 32-bit TCE table at 0..%08x\n",
 -		phb->ioda.m32_pci_base);
 +		end);
  
 -	/* Setup linux iommu table */
 -	rc = pnv_pci_ioda2_table_alloc_pages(pe->phb->hose->node,
 -			0, IOMMU_PAGE_SHIFT_4K, phb->ioda.m32_pci_base, tbl);
 -	if (rc) {
 -		pe_err(pe, "Failed to create 32-bit TCE table, err %ld", rc);
 +	/* Allocate TCE table */
 +	tce_mem = alloc_pages_node(phb->hose->node, GFP_KERNEL,
 +				   get_order(tce_table_size));
 +	if (!tce_mem) {
 +		pe_err(pe, "Failed to allocate a 32-bit TCE memory\n");
  		goto fail;
  	}
 +	addr = page_address(tce_mem);
 +	memset(addr, 0, tce_table_size);
  
 -	tbl->it_ops = &pnv_ioda2_iommu_ops;
 -	iommu_init_table(tbl, phb->hose->node);
 -#ifdef CONFIG_IOMMU_API
 -	pe->table_group.ops = &pnv_pci_ioda2_ops;
 -#endif
 -
++<<<<<<< HEAD
 +	/*
 +	 * Map TCE table through TVT. The TVE index is the PE number
 +	 * shifted by 1 bit for 32-bits DMA space.
 +	 */
 +	rc = opal_pci_map_pe_dma_window(phb->opal_id, pe->pe_number,
 +					pe->pe_number << 1, 1, __pa(addr),
 +					tce_table_size, 0x1000);
++=======
+ 	rc = pnv_pci_ioda2_set_window(&pe->table_group, 0, tbl);
++>>>>>>> 43cb60ab7f8c (powerpc/powernv/ioda2: Introduce pnv_pci_ioda2_set_window)
  	if (rc) {
  		pe_err(pe, "Failed to configure 32-bit TCE table,"
  		       " err %ld\n", rc);
  		goto fail;
  	}
  
++<<<<<<< HEAD
 +	/* Setup linux iommu table */
 +	tbl = &pe->tce32_table;
 +	pnv_pci_setup_iommu_table(tbl, addr, tce_table_size, 0,
 +			IOMMU_PAGE_SHIFT_4K);
 +
++=======
++>>>>>>> 43cb60ab7f8c (powerpc/powernv/ioda2: Introduce pnv_pci_ioda2_set_window)
  	/* OPAL variant of PHB3 invalidated TCEs */
 -	if (phb->ioda.tce_inval_reg)
 +	swinvp = of_get_property(phb->hose->dn, "ibm,opal-tce-kill", NULL);
 +	if (swinvp) {
 +		/* We need a couple more fields -- an address and a data
 +		 * to or.  Since the bus is only printed out on table free
 +		 * errors, and on the first pass the data will be a relative
 +		 * bus number, print that out instead.
 +		 */
 +		tbl->it_index = (unsigned long)ioremap(be64_to_cpup(swinvp), 8);
  		tbl->it_type |= (TCE_PCI_SWINV_CREATE | TCE_PCI_SWINV_FREE);
 +	}
 +	iommu_init_table(tbl, phb->hose->node);
 +	iommu_register_group(tbl, phb->hose->global_number, pe->pe_number);
  
 -	if (pe->flags & PNV_IODA_PE_DEV) {
 -		/*
 -		 * Setting table base here only for carrying iommu_group
 -		 * further down to let iommu_add_device() do the job.
 -		 * pnv_pci_ioda_dma_dev_setup will override it later anyway.
 -		 */
 -		set_iommu_table_base(&pe->pdev->dev, tbl);
 -		iommu_add_device(&pe->pdev->dev);
 -	} else if (pe->flags & (PNV_IODA_PE_BUS | PNV_IODA_PE_BUS_ALL))
 -		pnv_ioda_setup_bus_dma(pe, pe->pbus);
 +	if (pe->pdev)
 +		set_iommu_table_base_and_group(&pe->pdev->dev, tbl);
 +	else
 +		pnv_ioda_setup_bus_dma(pe, pe->pbus, true);
  
  	/* Also create a bypass window */
 -	if (!pnv_iommu_bypass_disabled)
 -		pnv_pci_ioda2_set_bypass(pe, true);
 -
 +	pnv_pci_ioda2_setup_bypass_pe(phb, pe);
  	return;
  fail:
  	if (pe->tce32_seg >= 0)
* Unmerged path arch/powerpc/platforms/powernv/pci-ioda.c
