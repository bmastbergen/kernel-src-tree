ioctx_alloc(): fix vma (and file) leak on failure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit deeb8525f9bcea60f5e86521880c1161de7a5829
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/deeb8525.failed

If we fail past the aio_setup_ring(), we need to destroy the
mapping.  We don't need to care about anybody having found ctx,
or added requests to it, since the last failure exit is exactly
the failure to make ctx visible to lookups.

Reproducer (based on one by Joe Mario <jmario@redhat.com>):

void count(char *p)
{
	char s[80];
	printf("%s: ", p);
	fflush(stdout);
	sprintf(s, "/bin/cat /proc/%d/maps|/bin/fgrep -c '/[aio] (deleted)'", getpid());
	system(s);
}

int main()
{
	io_context_t *ctx;
	int created, limit, i, destroyed;
	FILE *f;

	count("before");
	if ((f = fopen("/proc/sys/fs/aio-max-nr", "r")) == NULL)
		perror("opening aio-max-nr");
	else if (fscanf(f, "%d", &limit) != 1)
		fprintf(stderr, "can't parse aio-max-nr\n");
	else if ((ctx = calloc(limit, sizeof(io_context_t))) == NULL)
		perror("allocating aio_context_t array");
	else {
		for (i = 0, created = 0; i < limit; i++) {
			if (io_setup(1000, ctx + created) == 0)
				created++;
		}
		for (i = 0, destroyed = 0; i < created; i++)
			if (io_destroy(ctx[i]) == 0)
				destroyed++;
		printf("created %d, failed %d, destroyed %d\n",
			created, limit - created, destroyed);
		count("after");
	}
}

Found-by: Joe Mario <jmario@redhat.com>
	Cc: stable@vger.kernel.org
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit deeb8525f9bcea60f5e86521880c1161de7a5829)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/aio.c
diff --cc fs/aio.c
index 1ece5370572d,a793f7023755..000000000000
--- a/fs/aio.c
+++ b/fs/aio.c
@@@ -654,12 -728,18 +654,21 @@@ static struct kioctx *ioctx_alloc(unsig
  		 ctx, ctx->user_id, mm, ctx->nr_events);
  	return ctx;
  
++<<<<<<< HEAD
 +out_cleanup:
 +	err = -EAGAIN;
++=======
+ err_cleanup:
+ 	aio_nr_sub(ctx->max_reqs);
+ err_ctx:
+ 	atomic_set(&ctx->dead, 1);
+ 	if (ctx->mmap_size)
+ 		vm_munmap(ctx->mmap_base, ctx->mmap_size);
++>>>>>>> deeb8525f9bc (ioctx_alloc(): fix vma (and file) leak on failure)
  	aio_free_ring(ctx);
 -err:
 +out_freectx:
  	mutex_unlock(&ctx->ring_lock);
 -	free_percpu(ctx->cpu);
 -	percpu_ref_exit(&ctx->reqs);
 -	percpu_ref_exit(&ctx->users);
 +	put_aio_ring_file(ctx);
  	kmem_cache_free(kioctx_cachep, ctx);
  	pr_debug("error allocating ioctx %d\n", err);
  	return ERR_PTR(err);
* Unmerged path fs/aio.c
