i40e: Don't check operational or sync bit for App TLV

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Neerav Parikh <neerav.parikh@intel.com>
commit 7589f65b32f4465e38cc1d71490ea6f3e170c08c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/7589f65b.failed

In CEE mode the firmware does not set the operational status bit of
the application TLV status as returned from the "Get CEE DCBX Oper Cfg"
AQ command. This occurs whenever a DCBX configuration is changed.

This is a workaround to remove the check for the operational and sync bits
of the application TLV status till a firmware fix is provided.

Change-ID: I1a31ff2fcadcb06feb5b55776a33593afc6ea176
	Signed-off-by: Neerav Parikh <neerav.parikh@intel.com>
	Acked-by: Shannon Nelson <shannon.nelson@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 7589f65b32f4465e38cc1d71490ea6f3e170c08c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_dcb.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_dcb.c
index eb67091781fd,6e1466756760..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_dcb.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_dcb.c
@@@ -407,6 -407,166 +407,169 @@@ free_mem
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * i40e_cee_to_dcb_v1_config
+  * @cee_cfg: pointer to CEE v1 response configuration struct
+  * @dcbcfg: DCB configuration struct
+  *
+  * Convert CEE v1 configuration from firmware to DCB configuration
+  **/
+ static void i40e_cee_to_dcb_v1_config(
+ 			struct i40e_aqc_get_cee_dcb_cfg_v1_resp *cee_cfg,
+ 			struct i40e_dcbx_config *dcbcfg)
+ {
+ 	u16 status, tlv_status = le16_to_cpu(cee_cfg->tlv_status);
+ 	u16 app_prio = le16_to_cpu(cee_cfg->oper_app_prio);
+ 	u8 i, tc, err, sync, oper;
+ 
+ 	/* CEE PG data to ETS config */
+ 	dcbcfg->etscfg.maxtcs = cee_cfg->oper_num_tc;
+ 
+ 	for (i = 0; i < 4; i++) {
+ 		tc = (u8)((cee_cfg->oper_prio_tc[i] &
+ 			 I40E_CEE_PGID_PRIO_1_MASK) >>
+ 			 I40E_CEE_PGID_PRIO_1_SHIFT);
+ 		dcbcfg->etscfg.prioritytable[i*2] =  tc;
+ 		tc = (u8)((cee_cfg->oper_prio_tc[i] &
+ 			 I40E_CEE_PGID_PRIO_0_MASK) >>
+ 			 I40E_CEE_PGID_PRIO_0_SHIFT);
+ 		dcbcfg->etscfg.prioritytable[i*2 + 1] = tc;
+ 	}
+ 
+ 	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)
+ 		dcbcfg->etscfg.tcbwtable[i] = cee_cfg->oper_tc_bw[i];
+ 
+ 	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {
+ 		if (dcbcfg->etscfg.prioritytable[i] == I40E_CEE_PGID_STRICT) {
+ 			/* Map it to next empty TC */
+ 			dcbcfg->etscfg.prioritytable[i] =
+ 						cee_cfg->oper_num_tc - 1;
+ 			dcbcfg->etscfg.tsatable[i] = I40E_IEEE_TSA_STRICT;
+ 		} else {
+ 			dcbcfg->etscfg.tsatable[i] = I40E_IEEE_TSA_ETS;
+ 		}
+ 	}
+ 
+ 	/* CEE PFC data to ETS config */
+ 	dcbcfg->pfc.pfcenable = cee_cfg->oper_pfc_en;
+ 	dcbcfg->pfc.pfccap = I40E_MAX_TRAFFIC_CLASS;
+ 
+ 	status = (tlv_status & I40E_AQC_CEE_APP_STATUS_MASK) >>
+ 		  I40E_AQC_CEE_APP_STATUS_SHIFT;
+ 	err = (status & I40E_TLV_STATUS_ERR) ? 1 : 0;
+ 	sync = (status & I40E_TLV_STATUS_SYNC) ? 1 : 0;
+ 	oper = (status & I40E_TLV_STATUS_OPER) ? 1 : 0;
+ 	/* Add APPs if Error is False and Oper/Sync is True */
+ 	if (!err) {
+ 		/* CEE operating configuration supports FCoE/iSCSI/FIP only */
+ 		dcbcfg->numapps = I40E_CEE_OPER_MAX_APPS;
+ 
+ 		/* FCoE APP */
+ 		dcbcfg->app[0].priority =
+ 			(app_prio & I40E_AQC_CEE_APP_FCOE_MASK) >>
+ 			 I40E_AQC_CEE_APP_FCOE_SHIFT;
+ 		dcbcfg->app[0].selector = I40E_APP_SEL_ETHTYPE;
+ 		dcbcfg->app[0].protocolid = I40E_APP_PROTOID_FCOE;
+ 
+ 		/* iSCSI APP */
+ 		dcbcfg->app[1].priority =
+ 			(app_prio & I40E_AQC_CEE_APP_ISCSI_MASK) >>
+ 			 I40E_AQC_CEE_APP_ISCSI_SHIFT;
+ 		dcbcfg->app[1].selector = I40E_APP_SEL_TCPIP;
+ 		dcbcfg->app[1].protocolid = I40E_APP_PROTOID_ISCSI;
+ 
+ 		/* FIP APP */
+ 		dcbcfg->app[2].priority =
+ 			(app_prio & I40E_AQC_CEE_APP_FIP_MASK) >>
+ 			 I40E_AQC_CEE_APP_FIP_SHIFT;
+ 		dcbcfg->app[2].selector = I40E_APP_SEL_ETHTYPE;
+ 		dcbcfg->app[2].protocolid = I40E_APP_PROTOID_FIP;
+ 	}
+ }
+ 
+ /**
+  * i40e_cee_to_dcb_config
+  * @cee_cfg: pointer to CEE configuration struct
+  * @dcbcfg: DCB configuration struct
+  *
+  * Convert CEE configuration from firmware to DCB configuration
+  **/
+ static void i40e_cee_to_dcb_config(
+ 				struct i40e_aqc_get_cee_dcb_cfg_resp *cee_cfg,
+ 				struct i40e_dcbx_config *dcbcfg)
+ {
+ 	u32 status, tlv_status = le32_to_cpu(cee_cfg->tlv_status);
+ 	u16 app_prio = le16_to_cpu(cee_cfg->oper_app_prio);
+ 	u8 i, tc, err, sync, oper;
+ 
+ 	/* CEE PG data to ETS config */
+ 	dcbcfg->etscfg.maxtcs = cee_cfg->oper_num_tc;
+ 
+ 	for (i = 0; i < 4; i++) {
+ 		tc = (u8)((cee_cfg->oper_prio_tc[i] &
+ 			 I40E_CEE_PGID_PRIO_1_MASK) >>
+ 			 I40E_CEE_PGID_PRIO_1_SHIFT);
+ 		dcbcfg->etscfg.prioritytable[i*2] =  tc;
+ 		tc = (u8)((cee_cfg->oper_prio_tc[i] &
+ 			 I40E_CEE_PGID_PRIO_0_MASK) >>
+ 			 I40E_CEE_PGID_PRIO_0_SHIFT);
+ 		dcbcfg->etscfg.prioritytable[i*2 + 1] = tc;
+ 	}
+ 
+ 	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)
+ 		dcbcfg->etscfg.tcbwtable[i] = cee_cfg->oper_tc_bw[i];
+ 
+ 	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {
+ 		if (dcbcfg->etscfg.prioritytable[i] == I40E_CEE_PGID_STRICT) {
+ 			/* Map it to next empty TC */
+ 			dcbcfg->etscfg.prioritytable[i] =
+ 						cee_cfg->oper_num_tc - 1;
+ 			dcbcfg->etscfg.tsatable[i] = I40E_IEEE_TSA_STRICT;
+ 		} else {
+ 			dcbcfg->etscfg.tsatable[i] = I40E_IEEE_TSA_ETS;
+ 		}
+ 	}
+ 
+ 	/* CEE PFC data to ETS config */
+ 	dcbcfg->pfc.pfcenable = cee_cfg->oper_pfc_en;
+ 	dcbcfg->pfc.pfccap = I40E_MAX_TRAFFIC_CLASS;
+ 
+ 	status = (tlv_status & I40E_AQC_CEE_APP_STATUS_MASK) >>
+ 		  I40E_AQC_CEE_APP_STATUS_SHIFT;
+ 	err = (status & I40E_TLV_STATUS_ERR) ? 1 : 0;
+ 	sync = (status & I40E_TLV_STATUS_SYNC) ? 1 : 0;
+ 	oper = (status & I40E_TLV_STATUS_OPER) ? 1 : 0;
+ 	/* Add APPs if Error is False and Oper/Sync is True */
+ 	if (!err && sync && oper) {
+ 		/* CEE operating configuration supports FCoE/iSCSI/FIP only */
+ 		dcbcfg->numapps = I40E_CEE_OPER_MAX_APPS;
+ 
+ 		/* FCoE APP */
+ 		dcbcfg->app[0].priority =
+ 			(app_prio & I40E_AQC_CEE_APP_FCOE_MASK) >>
+ 			 I40E_AQC_CEE_APP_FCOE_SHIFT;
+ 		dcbcfg->app[0].selector = I40E_APP_SEL_ETHTYPE;
+ 		dcbcfg->app[0].protocolid = I40E_APP_PROTOID_FCOE;
+ 
+ 		/* iSCSI APP */
+ 		dcbcfg->app[1].priority =
+ 			(app_prio & I40E_AQC_CEE_APP_ISCSI_MASK) >>
+ 			 I40E_AQC_CEE_APP_ISCSI_SHIFT;
+ 		dcbcfg->app[1].selector = I40E_APP_SEL_TCPIP;
+ 		dcbcfg->app[1].protocolid = I40E_APP_PROTOID_ISCSI;
+ 
+ 		/* FIP APP */
+ 		dcbcfg->app[2].priority =
+ 			(app_prio & I40E_AQC_CEE_APP_FIP_MASK) >>
+ 			 I40E_AQC_CEE_APP_FIP_SHIFT;
+ 		dcbcfg->app[2].selector = I40E_APP_SEL_ETHTYPE;
+ 		dcbcfg->app[2].protocolid = I40E_APP_PROTOID_FIP;
+ 	}
+ }
+ 
+ /**
++>>>>>>> 7589f65b32f4 (i40e: Don't check operational or sync bit for App TLV)
   * i40e_get_dcb_config
   * @hw: pointer to the hw struct
   *
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_dcb.c
