netfilter: Use nf_hook_state in nf_queue_entry.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] netfilter: Use nf_hook_state in nf_queue_entry (Jiri Benc) [1230935]
Rebuild_FUZZ: 98.92%
commit-author David S. Miller <davem@davemloft.net>
commit 1d1de89b9a4746f1dd055a3b8d073dd2f962a3b6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/1d1de89b.failed

That way we don't have to reinstantiate another nf_hook_state
on the stack of the nf_reinject() path.

	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1d1de89b9a4746f1dd055a3b8d073dd2f962a3b6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_queue.c
diff --cc net/netfilter/nf_queue.c
index 5d24b1fdb593,d3cd37edca18..000000000000
--- a/net/netfilter/nf_queue.c
+++ b/net/netfilter/nf_queue.c
@@@ -47,12 -47,14 +47,22 @@@ EXPORT_SYMBOL(nf_unregister_queue_handl
  
  void nf_queue_entry_release_refs(struct nf_queue_entry *entry)
  {
+ 	struct nf_hook_state *state = &entry->state;
+ 
  	/* Release those devices we held, or Alexey will kill me. */
++<<<<<<< HEAD
 +	if (entry->indev)
 +		dev_put(entry->indev);
 +	if (entry->outdev)
 +		dev_put(entry->outdev);
 +#ifdef CONFIG_BRIDGE_NETFILTER
++=======
+ 	if (state->in)
+ 		dev_put(state->in);
+ 	if (state->out)
+ 		dev_put(state->out);
+ #if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
++>>>>>>> 1d1de89b9a47 (netfilter: Use nf_hook_state in nf_queue_entry.)
  	if (entry->skb->nf_bridge) {
  		struct nf_bridge_info *nf_bridge = entry->skb->nf_bridge;
  
@@@ -73,11 -77,11 +85,19 @@@ bool nf_queue_entry_get_refs(struct nf_
  	if (!try_module_get(entry->elem->owner))
  		return false;
  
++<<<<<<< HEAD
 +	if (entry->indev)
 +		dev_hold(entry->indev);
 +	if (entry->outdev)
 +		dev_hold(entry->outdev);
 +#ifdef CONFIG_BRIDGE_NETFILTER
++=======
+ 	if (state->in)
+ 		dev_hold(state->in);
+ 	if (state->out)
+ 		dev_hold(state->out);
+ #if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
++>>>>>>> 1d1de89b9a47 (netfilter: Use nf_hook_state in nf_queue_entry.)
  	if (entry->skb->nf_bridge) {
  		struct nf_bridge_info *nf_bridge = entry->skb->nf_bridge;
  		struct net_device *physdev;
@@@ -134,11 -135,7 +154,15 @@@ int nf_queue(struct sk_buff *skb
  	*entry = (struct nf_queue_entry) {
  		.skb	= skb,
  		.elem	= elem,
++<<<<<<< HEAD
 +		.pf	= pf,
 +		.hook	= hook,
 +		.indev	= indev,
 +		.outdev	= outdev,
 +		.okfn	= okfn,
++=======
+ 		.state	= *state,
++>>>>>>> 1d1de89b9a47 (netfilter: Use nf_hook_state in nf_queue_entry.)
  		.size	= sizeof(*entry) + afinfo->route_key_size,
  	};
  
@@@ -189,12 -186,12 +213,21 @@@ void nf_reinject(struct nf_queue_entry 
  			verdict = NF_DROP;
  	}
  
++<<<<<<< HEAD
 +	if (verdict == NF_ACCEPT) {
 +	next_hook:
 +		verdict = nf_iterate(&nf_hooks[entry->pf][entry->hook],
 +				     skb, entry->hook,
 +				     entry->indev, entry->outdev, &elem,
 +				     entry->okfn, INT_MIN);
++=======
+ 	entry->state.thresh = INT_MIN;
+ 
+ 	if (verdict == NF_ACCEPT) {
+ 	next_hook:
+ 		verdict = nf_iterate(&nf_hooks[entry->state.pf][entry->state.hook],
+ 				     skb, &entry->state, &elem);
++>>>>>>> 1d1de89b9a47 (netfilter: Use nf_hook_state in nf_queue_entry.)
  	}
  
  	switch (verdict & NF_VERDICT_MASK) {
@@@ -205,9 -202,8 +238,14 @@@
  		local_bh_enable();
  		break;
  	case NF_QUEUE:
++<<<<<<< HEAD
 +		err = nf_queue(skb, elem, entry->pf, entry->hook,
 +				entry->indev, entry->outdev, entry->okfn,
 +				verdict >> NF_VERDICT_QBITS);
++=======
+ 		err = nf_queue(skb, elem, &entry->state,
+ 			       verdict >> NF_VERDICT_QBITS);
++>>>>>>> 1d1de89b9a47 (netfilter: Use nf_hook_state in nf_queue_entry.)
  		if (err < 0) {
  			if (err == -ECANCELED)
  				goto next_hook;
diff --git a/include/net/netfilter/nf_queue.h b/include/net/netfilter/nf_queue.h
index 84a53d780306..d81d584157e1 100644
--- a/include/net/netfilter/nf_queue.h
+++ b/include/net/netfilter/nf_queue.h
@@ -12,12 +12,8 @@ struct nf_queue_entry {
 	unsigned int		id;
 
 	struct nf_hook_ops	*elem;
-	u_int8_t		pf;
+	struct nf_hook_state	state;
 	u16			size; /* sizeof(entry) + saved route keys */
-	unsigned int		hook;
-	struct net_device	*indev;
-	struct net_device	*outdev;
-	int			(*okfn)(struct sk_buff *);
 
 	/* extra space to store route keys */
 };
diff --git a/net/ipv4/netfilter.c b/net/ipv4/netfilter.c
index c3e0adea9c27..63d3846fc3c5 100644
--- a/net/ipv4/netfilter.c
+++ b/net/ipv4/netfilter.c
@@ -94,7 +94,7 @@ static void nf_ip_saveroute(const struct sk_buff *skb,
 {
 	struct ip_rt_info *rt_info = nf_queue_entry_reroute(entry);
 
-	if (entry->hook == NF_INET_LOCAL_OUT) {
+	if (entry->state.hook == NF_INET_LOCAL_OUT) {
 		const struct iphdr *iph = ip_hdr(skb);
 
 		rt_info->tos = iph->tos;
@@ -109,7 +109,7 @@ static int nf_ip_reroute(struct sk_buff *skb,
 {
 	const struct ip_rt_info *rt_info = nf_queue_entry_reroute(entry);
 
-	if (entry->hook == NF_INET_LOCAL_OUT) {
+	if (entry->state.hook == NF_INET_LOCAL_OUT) {
 		const struct iphdr *iph = ip_hdr(skb);
 
 		if (!(iph->tos == rt_info->tos &&
diff --git a/net/ipv6/netfilter.c b/net/ipv6/netfilter.c
index 95f3f1da0d7f..2f3f82728364 100644
--- a/net/ipv6/netfilter.c
+++ b/net/ipv6/netfilter.c
@@ -82,7 +82,7 @@ static void nf_ip6_saveroute(const struct sk_buff *skb,
 {
 	struct ip6_rt_info *rt_info = nf_queue_entry_reroute(entry);
 
-	if (entry->hook == NF_INET_LOCAL_OUT) {
+	if (entry->state.hook == NF_INET_LOCAL_OUT) {
 		const struct ipv6hdr *iph = ipv6_hdr(skb);
 
 		rt_info->daddr = iph->daddr;
@@ -96,7 +96,7 @@ static int nf_ip6_reroute(struct sk_buff *skb,
 {
 	struct ip6_rt_info *rt_info = nf_queue_entry_reroute(entry);
 
-	if (entry->hook == NF_INET_LOCAL_OUT) {
+	if (entry->state.hook == NF_INET_LOCAL_OUT) {
 		const struct ipv6hdr *iph = ipv6_hdr(skb);
 		if (!ipv6_addr_equal(&iph->daddr, &rt_info->daddr) ||
 		    !ipv6_addr_equal(&iph->saddr, &rt_info->saddr) ||
* Unmerged path net/netfilter/nf_queue.c
diff --git a/net/netfilter/nfnetlink_queue_core.c b/net/netfilter/nfnetlink_queue_core.c
index 660119acac29..b5cda594b57a 100644
--- a/net/netfilter/nfnetlink_queue_core.c
+++ b/net/netfilter/nfnetlink_queue_core.c
@@ -280,13 +280,13 @@ nfqnl_build_packet_message(struct nfqnl_instance *queue,
 	if (entskb->tstamp.tv64)
 		size += nla_total_size(sizeof(struct nfqnl_msg_packet_timestamp));
 
-	if (entry->hook <= NF_INET_FORWARD ||
-	   (entry->hook == NF_INET_POST_ROUTING && entskb->sk == NULL))
+	if (entry->state.hook <= NF_INET_FORWARD ||
+	   (entry->state.hook == NF_INET_POST_ROUTING && entskb->sk == NULL))
 		csum_verify = !skb_csum_unnecessary(entskb);
 	else
 		csum_verify = false;
 
-	outdev = entry->outdev;
+	outdev = entry->state.out;
 
 	switch ((enum nfqnl_config_mode)ACCESS_ONCE(queue->copy_mode)) {
 	case NFQNL_COPY_META:
@@ -329,23 +329,23 @@ nfqnl_build_packet_message(struct nfqnl_instance *queue,
 		return NULL;
 	}
 	nfmsg = nlmsg_data(nlh);
-	nfmsg->nfgen_family = entry->pf;
+	nfmsg->nfgen_family = entry->state.pf;
 	nfmsg->version = NFNETLINK_V0;
 	nfmsg->res_id = htons(queue->queue_num);
 
 	nla = __nla_reserve(skb, NFQA_PACKET_HDR, sizeof(*pmsg));
 	pmsg = nla_data(nla);
 	pmsg->hw_protocol	= entskb->protocol;
-	pmsg->hook		= entry->hook;
+	pmsg->hook		= entry->state.hook;
 	*packet_id_ptr		= &pmsg->packet_id;
 
-	indev = entry->indev;
+	indev = entry->state.in;
 	if (indev) {
 #ifndef CONFIG_BRIDGE_NETFILTER
 		if (nla_put_be32(skb, NFQA_IFINDEX_INDEV, htonl(indev->ifindex)))
 			goto nla_put_failure;
 #else
-		if (entry->pf == PF_BRIDGE) {
+		if (entry->state.pf == PF_BRIDGE) {
 			/* Case 1: indev is physical input device, we need to
 			 * look for bridge group (when called from
 			 * netfilter_bridge) */
@@ -375,7 +375,7 @@ nfqnl_build_packet_message(struct nfqnl_instance *queue,
 		if (nla_put_be32(skb, NFQA_IFINDEX_OUTDEV, htonl(outdev->ifindex)))
 			goto nla_put_failure;
 #else
-		if (entry->pf == PF_BRIDGE) {
+		if (entry->state.pf == PF_BRIDGE) {
 			/* Case 1: outdev is physical output device, we need to
 			 * look for bridge group (when called from
 			 * netfilter_bridge) */
@@ -589,8 +589,8 @@ nfqnl_enqueue_packet(struct nf_queue_entry *entry, unsigned int queuenum)
 	struct nfqnl_instance *queue;
 	struct sk_buff *skb, *segs;
 	int err = -ENOBUFS;
-	struct net *net = dev_net(entry->indev ?
-				  entry->indev : entry->outdev);
+	struct net *net = dev_net(entry->state.in ?
+				  entry->state.in : entry->state.out);
 	struct nfnl_queue_net *q = nfnl_queue_pernet(net);
 
 	/* rcu_read_lock()ed by nf_hook_slow() */
@@ -603,7 +603,7 @@ nfqnl_enqueue_packet(struct nf_queue_entry *entry, unsigned int queuenum)
 
 	skb = entry->skb;
 
-	switch (entry->pf) {
+	switch (entry->state.pf) {
 	case NFPROTO_IPV4:
 		skb->protocol = htons(ETH_P_IP);
 		break;
@@ -718,11 +718,11 @@ nfqnl_set_mode(struct nfqnl_instance *queue,
 static int
 dev_cmp(struct nf_queue_entry *entry, unsigned long ifindex)
 {
-	if (entry->indev)
-		if (entry->indev->ifindex == ifindex)
+	if (entry->state.in)
+		if (entry->state.in->ifindex == ifindex)
 			return 1;
-	if (entry->outdev)
-		if (entry->outdev->ifindex == ifindex)
+	if (entry->state.out)
+		if (entry->state.out->ifindex == ifindex)
 			return 1;
 #ifdef CONFIG_BRIDGE_NETFILTER
 	if (entry->skb->nf_bridge) {
