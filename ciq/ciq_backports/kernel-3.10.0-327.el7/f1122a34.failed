sfc: Store the efx_nic struct of the current VF in the VF data struct

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Shradha Shah <sshah@solarflare.com>
commit f1122a345b96713eb6e059121c592b3c0612f5be
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/f1122a34.failed

Initialised in efx_probe_vf and removal is dealt with in
efx_ef10_remove.

vf->efx is needed in future patches to change the MAC address
of the VF via the parent PF, while the driver is bound to the
VF.
Example: ip link set dev vf NUM mac LLADDR

	Signed-off-by: Shradha Shah <sshah@solarflare.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f1122a345b96713eb6e059121c592b3c0612f5be)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/sfc/ef10.c
#	drivers/net/ethernet/sfc/ef10_sriov.c
#	drivers/net/ethernet/sfc/ef10_sriov.h
diff --cc drivers/net/ethernet/sfc/ef10.c
index cd683661ffb0,78d3236a3d67..000000000000
--- a/drivers/net/ethernet/sfc/ef10.c
+++ b/drivers/net/ethernet/sfc/ef10.c
@@@ -517,6 -583,50 +536,53 @@@ static void efx_ef10_remove(struct efx_
  	kfree(nic_data);
  }
  
++<<<<<<< HEAD
++=======
+ static int efx_ef10_probe_pf(struct efx_nic *efx)
+ {
+ 	return efx_ef10_probe(efx);
+ }
+ 
+ #ifdef CONFIG_SFC_SRIOV
+ static int efx_ef10_probe_vf(struct efx_nic *efx)
+ {
+ 	int rc;
+ 
+ 	rc = efx_ef10_probe(efx);
+ 	if (rc)
+ 		return rc;
+ 
+ 	rc = efx_ef10_get_vf_index(efx);
+ 	if (rc)
+ 		goto fail;
+ 
+ 	if (efx->pci_dev->is_virtfn) {
+ 		if (efx->pci_dev->physfn) {
+ 			struct efx_nic *efx_pf =
+ 				pci_get_drvdata(efx->pci_dev->physfn);
+ 			struct efx_ef10_nic_data *nic_data_p = efx_pf->nic_data;
+ 			struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 
+ 			nic_data_p->vf[nic_data->vf_index].efx = efx;
+ 		} else
+ 			netif_info(efx, drv, efx->net_dev,
+ 				   "Could not get the PF id from VF\n");
+ 	}
+ 
+ 	return 0;
+ 
+ fail:
+ 	efx_ef10_remove(efx);
+ 	return rc;
+ }
+ #else
+ static int efx_ef10_probe_vf(struct efx_nic *efx __attribute__ ((unused)))
+ {
+ 	return 0;
+ }
+ #endif
+ 
++>>>>>>> f1122a345b96 (sfc: Store the efx_nic struct of the current VF in the VF data struct)
  static int efx_ef10_alloc_vis(struct efx_nic *efx,
  			      unsigned int min_vis, unsigned int max_vis)
  {
diff --cc drivers/net/ethernet/sfc/ef10_sriov.c
index 9e6a3e197e01,6208dd76bc2b..000000000000
--- a/drivers/net/ethernet/sfc/ef10_sriov.c
+++ b/drivers/net/ethernet/sfc/ef10_sriov.c
@@@ -13,7 -14,360 +13,364 @@@
  #include "nic.h"
  #include "mcdi_pcol.h"
  
++<<<<<<< HEAD
 +#ifdef CONFIG_SFC_SRIOV
++=======
+ static int efx_ef10_evb_port_assign(struct efx_nic *efx, unsigned int port_id,
+ 				    unsigned int vf_fn)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_EVB_PORT_ASSIGN_IN_LEN);
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 
+ 	MCDI_SET_DWORD(inbuf, EVB_PORT_ASSIGN_IN_PORT_ID, port_id);
+ 	MCDI_POPULATE_DWORD_2(inbuf, EVB_PORT_ASSIGN_IN_FUNCTION,
+ 			      EVB_PORT_ASSIGN_IN_PF, nic_data->pf_index,
+ 			      EVB_PORT_ASSIGN_IN_VF, vf_fn);
+ 
+ 	return efx_mcdi_rpc(efx, MC_CMD_EVB_PORT_ASSIGN, inbuf, sizeof(inbuf),
+ 			    NULL, 0, NULL);
+ }
+ 
+ static int efx_ef10_vport_add_mac(struct efx_nic *efx,
+ 				  unsigned int port_id, u8 *mac)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_ADD_MAC_ADDRESS_IN_LEN);
+ 
+ 	MCDI_SET_DWORD(inbuf, VPORT_ADD_MAC_ADDRESS_IN_VPORT_ID, port_id);
+ 	ether_addr_copy(MCDI_PTR(inbuf, VPORT_ADD_MAC_ADDRESS_IN_MACADDR), mac);
+ 
+ 	return efx_mcdi_rpc(efx, MC_CMD_VPORT_ADD_MAC_ADDRESS, inbuf,
+ 			    sizeof(inbuf), NULL, 0, NULL);
+ }
+ 
+ static int efx_ef10_vport_del_mac(struct efx_nic *efx,
+ 				  unsigned int port_id, u8 *mac)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_DEL_MAC_ADDRESS_IN_LEN);
+ 
+ 	MCDI_SET_DWORD(inbuf, VPORT_DEL_MAC_ADDRESS_IN_VPORT_ID, port_id);
+ 	ether_addr_copy(MCDI_PTR(inbuf, VPORT_DEL_MAC_ADDRESS_IN_MACADDR), mac);
+ 
+ 	return efx_mcdi_rpc(efx, MC_CMD_VPORT_DEL_MAC_ADDRESS, inbuf,
+ 			    sizeof(inbuf), NULL, 0, NULL);
+ }
+ 
+ static int efx_ef10_vswitch_alloc(struct efx_nic *efx, unsigned int port_id,
+ 				  unsigned int vswitch_type)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VSWITCH_ALLOC_IN_LEN);
+ 
+ 	MCDI_SET_DWORD(inbuf, VSWITCH_ALLOC_IN_UPSTREAM_PORT_ID, port_id);
+ 	MCDI_SET_DWORD(inbuf, VSWITCH_ALLOC_IN_TYPE, vswitch_type);
+ 	MCDI_SET_DWORD(inbuf, VSWITCH_ALLOC_IN_NUM_VLAN_TAGS, 0);
+ 	MCDI_POPULATE_DWORD_1(inbuf, VSWITCH_ALLOC_IN_FLAGS,
+ 			      VSWITCH_ALLOC_IN_FLAG_AUTO_PORT, 0);
+ 
+ 	return efx_mcdi_rpc(efx, MC_CMD_VSWITCH_ALLOC, inbuf, sizeof(inbuf),
+ 			    NULL, 0, NULL);
+ }
+ 
+ static int efx_ef10_vswitch_free(struct efx_nic *efx, unsigned int port_id)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VSWITCH_FREE_IN_LEN);
+ 
+ 	MCDI_SET_DWORD(inbuf, VSWITCH_FREE_IN_UPSTREAM_PORT_ID, port_id);
+ 
+ 	return efx_mcdi_rpc(efx, MC_CMD_VSWITCH_FREE, inbuf, sizeof(inbuf),
+ 			    NULL, 0, NULL);
+ }
+ 
+ static int efx_ef10_vport_alloc(struct efx_nic *efx,
+ 				unsigned int port_id_in,
+ 				unsigned int vport_type,
+ 				unsigned int *port_id_out)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_ALLOC_IN_LEN);
+ 	MCDI_DECLARE_BUF(outbuf, MC_CMD_VPORT_ALLOC_OUT_LEN);
+ 	size_t outlen;
+ 	int rc;
+ 
+ 	EFX_WARN_ON_PARANOID(!port_id_out);
+ 
+ 	MCDI_SET_DWORD(inbuf, VPORT_ALLOC_IN_UPSTREAM_PORT_ID, port_id_in);
+ 	MCDI_SET_DWORD(inbuf, VPORT_ALLOC_IN_TYPE, vport_type);
+ 	MCDI_SET_DWORD(inbuf, VPORT_ALLOC_IN_NUM_VLAN_TAGS, 0);
+ 	MCDI_POPULATE_DWORD_1(inbuf, VPORT_ALLOC_IN_FLAGS,
+ 			      VPORT_ALLOC_IN_FLAG_AUTO_PORT, 0);
+ 
+ 	rc = efx_mcdi_rpc(efx, MC_CMD_VPORT_ALLOC, inbuf, sizeof(inbuf),
+ 			  outbuf, sizeof(outbuf), &outlen);
+ 	if (rc)
+ 		return rc;
+ 	if (outlen < MC_CMD_VPORT_ALLOC_OUT_LEN)
+ 		return -EIO;
+ 
+ 	*port_id_out = MCDI_DWORD(outbuf, VPORT_ALLOC_OUT_VPORT_ID);
+ 	return 0;
+ }
+ 
+ static int efx_ef10_vport_free(struct efx_nic *efx, unsigned int port_id)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_FREE_IN_LEN);
+ 
+ 	MCDI_SET_DWORD(inbuf, VPORT_FREE_IN_VPORT_ID, port_id);
+ 
+ 	return efx_mcdi_rpc(efx, MC_CMD_VPORT_FREE, inbuf, sizeof(inbuf),
+ 			    NULL, 0, NULL);
+ }
+ 
+ static int efx_ef10_vadaptor_alloc(struct efx_nic *efx, unsigned int port_id)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VADAPTOR_ALLOC_IN_LEN);
+ 
+ 	MCDI_SET_DWORD(inbuf, VADAPTOR_ALLOC_IN_UPSTREAM_PORT_ID, port_id);
+ 	return efx_mcdi_rpc(efx, MC_CMD_VADAPTOR_ALLOC, inbuf, sizeof(inbuf),
+ 			    NULL, 0, NULL);
+ }
+ 
+ static int efx_ef10_vadaptor_free(struct efx_nic *efx, unsigned int port_id)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VADAPTOR_FREE_IN_LEN);
+ 
+ 	MCDI_SET_DWORD(inbuf, VADAPTOR_FREE_IN_UPSTREAM_PORT_ID, port_id);
+ 	return efx_mcdi_rpc(efx, MC_CMD_VADAPTOR_FREE, inbuf, sizeof(inbuf),
+ 			    NULL, 0, NULL);
+ }
+ 
+ static void efx_ef10_sriov_free_vf_vports(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	int i;
+ 
+ 	if (!nic_data->vf)
+ 		return;
+ 
+ 	for (i = 0; i < efx->vf_count; i++) {
+ 		struct ef10_vf *vf = nic_data->vf + i;
+ 
+ 		if (vf->vport_assigned) {
+ 			efx_ef10_evb_port_assign(efx, EVB_PORT_ID_NULL, i);
+ 			vf->vport_assigned = 0;
+ 		}
+ 
+ 		if (!is_zero_ether_addr(vf->mac)) {
+ 			efx_ef10_vport_del_mac(efx, vf->vport_id, vf->mac);
+ 			eth_zero_addr(vf->mac);
+ 		}
+ 
+ 		if (vf->vport_id) {
+ 			efx_ef10_vport_free(efx, vf->vport_id);
+ 			vf->vport_id = 0;
+ 		}
+ 
+ 		vf->efx = NULL;
+ 	}
+ }
+ 
+ static void efx_ef10_sriov_free_vf_vswitching(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 
+ 	efx_ef10_sriov_free_vf_vports(efx);
+ 	kfree(nic_data->vf);
+ 	nic_data->vf = NULL;
+ }
+ 
+ static int efx_ef10_sriov_assign_vf_vport(struct efx_nic *efx,
+ 					  unsigned int vf_i)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	struct ef10_vf *vf = nic_data->vf + vf_i;
+ 	int rc;
+ 
+ 	if (WARN_ON_ONCE(!nic_data->vf))
+ 		return -EOPNOTSUPP;
+ 
+ 	rc = efx_ef10_vport_alloc(efx, EVB_PORT_ID_ASSIGNED,
+ 				  MC_CMD_VPORT_ALLOC_IN_VPORT_TYPE_NORMAL,
+ 				  &vf->vport_id);
+ 	if (rc)
+ 		return rc;
+ 
+ 	rc = efx_ef10_vport_add_mac(efx, vf->vport_id, vf->mac);
+ 	if (rc) {
+ 		eth_zero_addr(vf->mac);
+ 		return rc;
+ 	}
+ 
+ 	rc =  efx_ef10_evb_port_assign(efx, vf->vport_id, vf_i);
+ 	if (rc)
+ 		return rc;
+ 
+ 	vf->vport_assigned = 1;
+ 	return 0;
+ }
+ 
+ static int efx_ef10_sriov_alloc_vf_vswitching(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	unsigned int i;
+ 	int rc;
+ 
+ 	nic_data->vf = kcalloc(efx->vf_count, sizeof(struct ef10_vf),
+ 			       GFP_KERNEL);
+ 	if (!nic_data->vf)
+ 		return -ENOMEM;
+ 
+ 	for (i = 0; i < efx->vf_count; i++) {
+ 		random_ether_addr(nic_data->vf[i].mac);
+ 		nic_data->vf[i].efx = NULL;
+ 
+ 		rc = efx_ef10_sriov_assign_vf_vport(efx, i);
+ 		if (rc)
+ 			goto fail;
+ 	}
+ 
+ 	return 0;
+ fail:
+ 	efx_ef10_sriov_free_vf_vports(efx);
+ 	kfree(nic_data->vf);
+ 	nic_data->vf = NULL;
+ 	return rc;
+ }
+ 
+ static int efx_ef10_sriov_restore_vf_vswitching(struct efx_nic *efx)
+ {
+ 	unsigned int i;
+ 	int rc;
+ 
+ 	for (i = 0; i < efx->vf_count; i++) {
+ 		rc = efx_ef10_sriov_assign_vf_vport(efx, i);
+ 		if (rc)
+ 			goto fail;
+ 	}
+ 
+ 	return 0;
+ fail:
+ 	efx_ef10_sriov_free_vf_vswitching(efx);
+ 	return rc;
+ }
+ 
+ /* On top of the default firmware vswitch setup, create a VEB vswitch and
+  * expansion vport for use by this function.
+  */
+ int efx_ef10_vswitching_probe_pf(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	struct net_device *net_dev = efx->net_dev;
+ 	int rc;
+ 
+ 	if (pci_sriov_get_totalvfs(efx->pci_dev) <= 0) {
+ 		/* vswitch not needed as we have no VFs */
+ 		efx_ef10_vadaptor_alloc(efx, nic_data->vport_id);
+ 		return 0;
+ 	}
+ 
+ 	rc = efx_ef10_vswitch_alloc(efx, EVB_PORT_ID_ASSIGNED,
+ 				    MC_CMD_VSWITCH_ALLOC_IN_VSWITCH_TYPE_VEB);
+ 	if (rc)
+ 		goto fail1;
+ 
+ 	rc = efx_ef10_vport_alloc(efx, EVB_PORT_ID_ASSIGNED,
+ 				  MC_CMD_VPORT_ALLOC_IN_VPORT_TYPE_NORMAL,
+ 				  &nic_data->vport_id);
+ 	if (rc)
+ 		goto fail2;
+ 
+ 	rc = efx_ef10_vport_add_mac(efx, nic_data->vport_id, net_dev->dev_addr);
+ 	if (rc)
+ 		goto fail3;
+ 	ether_addr_copy(nic_data->vport_mac, net_dev->dev_addr);
+ 
+ 	rc = efx_ef10_vadaptor_alloc(efx, nic_data->vport_id);
+ 	if (rc)
+ 		goto fail4;
+ 
+ 	return 0;
+ fail4:
+ 	efx_ef10_vport_del_mac(efx, nic_data->vport_id, nic_data->vport_mac);
+ 	eth_zero_addr(nic_data->vport_mac);
+ fail3:
+ 	efx_ef10_vport_free(efx, nic_data->vport_id);
+ 	nic_data->vport_id = EVB_PORT_ID_ASSIGNED;
+ fail2:
+ 	efx_ef10_vswitch_free(efx, EVB_PORT_ID_ASSIGNED);
+ fail1:
+ 	return rc;
+ }
+ 
+ int efx_ef10_vswitching_probe_vf(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 
+ 	return efx_ef10_vadaptor_alloc(efx, nic_data->vport_id);
+ }
+ 
+ int efx_ef10_vswitching_restore_pf(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	int rc;
+ 
+ 	if (!nic_data->must_probe_vswitching)
+ 		return 0;
+ 
+ 	rc = efx_ef10_vswitching_probe_pf(efx);
+ 	if (rc)
+ 		goto fail;
+ 
+ 	rc = efx_ef10_sriov_restore_vf_vswitching(efx);
+ 	if (rc)
+ 		goto fail;
+ 
+ 	nic_data->must_probe_vswitching = false;
+ fail:
+ 	return rc;
+ }
+ 
+ int efx_ef10_vswitching_restore_vf(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	int rc;
+ 
+ 	if (!nic_data->must_probe_vswitching)
+ 		return 0;
+ 
+ 	rc = efx_ef10_vadaptor_free(efx, EVB_PORT_ID_ASSIGNED);
+ 	if (rc)
+ 		return rc;
+ 
+ 	nic_data->must_probe_vswitching = false;
+ 	return 0;
+ }
+ 
+ void efx_ef10_vswitching_remove_pf(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 
+ 	efx_ef10_sriov_free_vf_vswitching(efx);
+ 
+ 	efx_ef10_vadaptor_free(efx, nic_data->vport_id);
+ 
+ 	if (nic_data->vport_id == EVB_PORT_ID_ASSIGNED)
+ 		return; /* No vswitch was ever created */
+ 
+ 	if (!is_zero_ether_addr(nic_data->vport_mac)) {
+ 		efx_ef10_vport_del_mac(efx, nic_data->vport_id,
+ 				       efx->net_dev->dev_addr);
+ 		eth_zero_addr(nic_data->vport_mac);
+ 	}
+ 	efx_ef10_vport_free(efx, nic_data->vport_id);
+ 	nic_data->vport_id = EVB_PORT_ID_ASSIGNED;
+ 
+ 	efx_ef10_vswitch_free(efx, nic_data->vport_id);
+ }
+ 
+ void efx_ef10_vswitching_remove_vf(struct efx_nic *efx)
+ {
+ 	efx_ef10_vadaptor_free(efx, EVB_PORT_ID_ASSIGNED);
+ }
+ 
++>>>>>>> f1122a345b96 (sfc: Store the efx_nic struct of the current VF in the VF data struct)
  static int efx_ef10_pci_sriov_enable(struct efx_nic *efx, int num_vfs)
  {
  	int rc = 0;
diff --cc drivers/net/ethernet/sfc/ef10_sriov.h
index 6ea115e3c3f2,6f27a0d30dac..000000000000
--- a/drivers/net/ethernet/sfc/ef10_sriov.h
+++ b/drivers/net/ethernet/sfc/ef10_sriov.h
@@@ -12,6 -12,20 +12,23 @@@
  
  #include "net_driver.h"
  
++<<<<<<< HEAD
++=======
+ /**
+  * struct ef10_vf - PF's store of VF data
+  * @efx: efx_nic struct for the current VF
+  * @vport_id: vport ID for the VF
+  * @vport_assigned: record whether the vport is currently assigned to the VF
+  * @mac: MAC address for the VF, zero when address is removed from the vport
+  */
+ struct ef10_vf {
+ 	struct efx_nic *efx;
+ 	unsigned int vport_id;
+ 	unsigned int vport_assigned;
+ 	u8 mac[ETH_ALEN];
+ };
+ 
++>>>>>>> f1122a345b96 (sfc: Store the efx_nic struct of the current VF in the VF data struct)
  static inline bool efx_ef10_sriov_wanted(struct efx_nic *efx)
  {
  	return false;
* Unmerged path drivers/net/ethernet/sfc/ef10.c
* Unmerged path drivers/net/ethernet/sfc/ef10_sriov.c
* Unmerged path drivers/net/ethernet/sfc/ef10_sriov.h
