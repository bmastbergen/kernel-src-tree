scsi: simplify scsi_log_(send|completion)

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [scsi] simplify scsi_log_(send|completion) (Ewan Milne) [1124082]
Rebuild_FUZZ: 92.11%
commit-author Hannes Reinecke <hare@suse.de>
commit c11c004b1c052fae77d3d0d14462d1f3a4e88d06
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/c11c004b.failed

Simplify scsi_log_(send|completion) by externalizing
scsi_mlreturn_string() and always print the command address.

	Signed-off-by: Hannes Reinecke <hare@suse.de>
	Reviewed-by: Robert Elliott <elliott@hp.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit c11c004b1c052fae77d3d0d14462d1f3a4e88d06)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/constants.c
#	drivers/scsi/scsi_lib.c
#	include/scsi/scsi_dbg.h
diff --cc drivers/scsi/constants.c
index 606cec57d762,0cf43f6e464b..000000000000
--- a/drivers/scsi/constants.c
+++ b/drivers/scsi/constants.c
@@@ -1509,24 -1440,39 +1509,59 @@@ const char *scsi_driverbyte_string(int 
  }
  EXPORT_SYMBOL(scsi_driverbyte_string);
  
++<<<<<<< HEAD
 +void scsi_show_result(int result)
 +{
 +	const char *hb_string = scsi_hostbyte_string(result);
 +	const char *db_string = scsi_driverbyte_string(result);
 +
 +	if (hb_string || db_string)
 +		printk("Result: hostbyte=%s driverbyte=%s\n",
 +		       hb_string ? hb_string : "invalid",
 +		       db_string ? db_string : "invalid");
 +	else
 +		printk("Result: hostbyte=0x%02x driverbyte=0x%02x\n",
 +		       host_byte(result), driver_byte(result));
 +}
 +EXPORT_SYMBOL(scsi_show_result);
 +
 +
 +void scsi_print_result(struct scsi_cmnd *cmd)
++=======
+ #ifdef CONFIG_SCSI_CONSTANTS
+ #define scsi_mlreturn_name(result)	{ result, #result }
+ static const struct value_name_pair scsi_mlreturn_arr[] = {
+ 	scsi_mlreturn_name(NEEDS_RETRY),
+ 	scsi_mlreturn_name(SUCCESS),
+ 	scsi_mlreturn_name(FAILED),
+ 	scsi_mlreturn_name(QUEUED),
+ 	scsi_mlreturn_name(SOFT_ERROR),
+ 	scsi_mlreturn_name(ADD_TO_MLQUEUE),
+ 	scsi_mlreturn_name(TIMEOUT_ERROR),
+ 	scsi_mlreturn_name(SCSI_RETURN_NOT_HANDLED),
+ 	scsi_mlreturn_name(FAST_IO_FAIL)
+ };
+ #endif
+ 
+ const char *scsi_mlreturn_string(int result)
++>>>>>>> c11c004b1c05 (scsi: simplify scsi_log_(send|completion))
+ {
+ #ifdef CONFIG_SCSI_CONSTANTS
+ 	const struct value_name_pair *arr = scsi_mlreturn_arr;
+ 	int k;
+ 
+ 	for (k = 0; k < ARRAY_SIZE(scsi_mlreturn_arr); ++k, ++arr) {
+ 		if (result == arr->value)
+ 			return arr->name;
+ 	}
+ #endif
+ 	return NULL;
+ }
+ EXPORT_SYMBOL(scsi_mlreturn_string);
+ 
+ void scsi_print_result(struct scsi_cmnd *cmd, const char *msg, int disposition)
  {
+ 	const char *mlret_string = scsi_mlreturn_string(disposition);
  	const char *hb_string = scsi_hostbyte_string(cmd->result);
  	const char *db_string = scsi_driverbyte_string(cmd->result);
  
diff --cc drivers/scsi/scsi_lib.c
index 2eb9f5889dec,26a57faf885b..000000000000
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@@ -683,12 -831,10 +683,17 @@@ void scsi_io_completion(struct scsi_cmn
  	struct request *req = cmd->request;
  	int error = 0;
  	struct scsi_sense_hdr sshdr;
++<<<<<<< HEAD
 +	int sense_valid = 0;
 +	int sense_deferred = 0;
++=======
+ 	bool sense_valid = false;
+ 	int sense_deferred = 0, level = 0;
++>>>>>>> c11c004b1c05 (scsi: simplify scsi_log_(send|completion))
  	enum {ACTION_FAIL, ACTION_REPREP, ACTION_RETRY,
  	      ACTION_DELAYED_RETRY} action;
 +	static DEFINE_RATELIMIT_STATE(rs,  DEFAULT_RATELIMIT_INTERVAL,
 +					DEFAULT_RATELIMIT_BURST);
  	unsigned long wait_for = (cmd->allowed + 1) * req->timeout;
  
  	if (result) {
@@@ -887,14 -1038,21 +892,26 @@@
  	switch (action) {
  	case ACTION_FAIL:
  		/* Give up and fail the remainder of the request */
++<<<<<<< HEAD
 +		if (!(req->cmd_flags & REQ_QUIET) && __ratelimit(&rs)) {
 +			scsi_print_result(cmd);
++=======
+ 		if (unlikely(scsi_logging_level))
+ 			level = SCSI_LOG_LEVEL(SCSI_LOG_MLQUEUE_SHIFT,
+ 					       SCSI_LOG_MLQUEUE_BITS);
+ 		/*
+ 		 * if logging is enabled the failure will be printed
+ 		 * in scsi_log_completion(), so avoid duplicate messages
+ 		 */
+ 		if (!level && !(req->cmd_flags & REQ_QUIET)) {
+ 			scsi_print_result(cmd, NULL, FAILED);
++>>>>>>> c11c004b1c05 (scsi: simplify scsi_log_(send|completion))
  			if (driver_byte(result) & DRIVER_SENSE)
 -				scsi_print_sense(cmd);
 +				scsi_print_sense("", cmd);
  			scsi_print_command(cmd);
  		}
 -		if (!scsi_end_request(req, error, blk_rq_err_bytes(req), 0))
 -			return;
 +		if (!blk_end_request_err(req, error))
 +			goto next_command;
  		/*FALLTHRU*/
  	case ACTION_REPREP:
  	requeue:
diff --cc include/scsi/scsi_dbg.h
index ed755e53b4c8,7982795df595..000000000000
--- a/include/scsi/scsi_dbg.h
+++ b/include/scsi/scsi_dbg.h
@@@ -5,19 -5,24 +5,24 @@@ struct scsi_cmnd
  struct scsi_sense_hdr;
  
  extern void scsi_print_command(struct scsi_cmnd *);
 -extern void __scsi_print_command(const unsigned char *, size_t);
 -extern void scsi_show_extd_sense(const struct scsi_device *, const char *,
 -				 unsigned char, unsigned char);
 -extern void scsi_show_sense_hdr(const struct scsi_device *, const char *,
 -				const struct scsi_sense_hdr *);
 -extern void scsi_print_sense_hdr(const struct scsi_device *, const char *,
 -				 const struct scsi_sense_hdr *);
 -extern void scsi_print_sense(const struct scsi_cmnd *);
 -extern void __scsi_print_sense(const struct scsi_device *, const char *name,
 +extern void __scsi_print_command(unsigned char *);
 +extern void scsi_show_extd_sense(unsigned char, unsigned char);
 +extern void scsi_show_sense_hdr(struct scsi_sense_hdr *);
 +extern void scsi_print_sense_hdr(const char *, struct scsi_sense_hdr *);
 +extern void scsi_print_sense(char *, struct scsi_cmnd *);
 +extern void __scsi_print_sense(const char *name,
  			       const unsigned char *sense_buffer,
  			       int sense_len);
++<<<<<<< HEAD
 +extern void scsi_show_result(int);
 +extern void scsi_print_result(struct scsi_cmnd *);
++=======
+ extern void scsi_print_result(struct scsi_cmnd *, const char *, int);
++>>>>>>> c11c004b1c05 (scsi: simplify scsi_log_(send|completion))
  extern const char *scsi_hostbyte_string(int);
  extern const char *scsi_driverbyte_string(int);
+ extern const char *scsi_mlreturn_string(int);
  extern const char *scsi_sense_key_string(unsigned char);
 -extern const char *scsi_extd_sense_format(unsigned char, unsigned char,
 -					  const char **);
 +extern const char *scsi_extd_sense_format(unsigned char, unsigned char);
  
  #endif /* _SCSI_SCSI_DBG_H */
* Unmerged path drivers/scsi/constants.c
diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
index 838f188fa5d4..965bde8336c3 100644
--- a/drivers/scsi/scsi.c
+++ b/drivers/scsi/scsi.c
@@ -513,9 +513,9 @@ void scsi_log_send(struct scsi_cmnd *cmd)
 	 *
 	 * 1: nothing (match completion)
 	 *
-	 * 2: log opcode + command of all commands
+	 * 2: log opcode + command of all commands + cmd address
 	 *
-	 * 3: same as 2 plus dump cmd address
+	 * 3: same as 2
 	 *
 	 * 4: same as 3 plus dump extra junk
 	 */
@@ -523,10 +523,8 @@ void scsi_log_send(struct scsi_cmnd *cmd)
 		level = SCSI_LOG_LEVEL(SCSI_LOG_MLQUEUE_SHIFT,
 				       SCSI_LOG_MLQUEUE_BITS);
 		if (level > 1) {
-			scmd_printk(KERN_INFO, cmd, "Send: ");
-			if (level > 2)
-				printk("0x%p ", cmd);
-			printk("\n");
+			scmd_printk(KERN_INFO, cmd,
+				    "Send: scmd 0x%p\n", cmd);
 			scsi_print_command(cmd);
 			if (level > 3) {
 				printk(KERN_INFO "buffer = 0x%p, bufflen = %d,"
@@ -551,7 +549,7 @@ void scsi_log_completion(struct scsi_cmnd *cmd, int disposition)
 	 *
 	 * 2: same as 1 but for all command completions.
 	 *
-	 * 3: same as 2 plus dump cmd address
+	 * 3: same as 2
 	 *
 	 * 4: same as 3 plus dump extra junk
 	 */
@@ -560,36 +558,7 @@ void scsi_log_completion(struct scsi_cmnd *cmd, int disposition)
 				       SCSI_LOG_MLCOMPLETE_BITS);
 		if (((level > 0) && (cmd->result || disposition != SUCCESS)) ||
 		    (level > 1)) {
-			scmd_printk(KERN_INFO, cmd, "Done: ");
-			if (level > 2)
-				printk("0x%p ", cmd);
-			/*
-			 * Dump truncated values, so we usually fit within
-			 * 80 chars.
-			 */
-			switch (disposition) {
-			case SUCCESS:
-				printk("SUCCESS\n");
-				break;
-			case NEEDS_RETRY:
-				printk("RETRY\n");
-				break;
-			case ADD_TO_MLQUEUE:
-				printk("MLQUEUE\n");
-				break;
-			case FAILED:
-				printk("FAILED\n");
-				break;
-			case TIMEOUT_ERROR:
-				/* 
-				 * If called via scsi_times_out.
-				 */
-				printk("TIMEOUT\n");
-				break;
-			default:
-				printk("UNKNOWN\n");
-			}
-			scsi_print_result(cmd);
+			scsi_print_result(cmd, "Done: ", disposition);
 			scsi_print_command(cmd);
 			if (status_byte(cmd->result) & CHECK_CONDITION)
 				scsi_print_sense("", cmd);
* Unmerged path drivers/scsi/scsi_lib.c
diff --git a/drivers/scsi/scsi_logging.h b/drivers/scsi/scsi_logging.h
index 1f65139e14f8..7fe64a847143 100644
--- a/drivers/scsi/scsi_logging.h
+++ b/drivers/scsi/scsi_logging.h
@@ -51,6 +51,7 @@ do {								\
 		} while (0);					\
 } while (0)
 #else
+#define SCSI_LOG_LEVEL(SHIFT, BITS) 0
 #define SCSI_CHECK_LOGGING(SHIFT, BITS, LEVEL, CMD)
 #endif /* CONFIG_SCSI_LOGGING */
 
* Unmerged path include/scsi/scsi_dbg.h
