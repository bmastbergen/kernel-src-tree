bonding: Fix deadlock in bonding driver when using netpoll

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author dingtianhong <dingtianhong@huawei.com>
commit f80889a5b79cae0b84465a90c21b1273a03b7973
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/f80889a5.failed

The bonding driver take write locks and spin locks that are shared
by the tx path in enslave processing and notification processing,
If the netconsole is in use, the bonding can call printk which puts
us in the netpoll tx path, if the netconsole is attached to the bonding
driver, result in deadlock.

So add protection for these place, by checking the netpoll_block_tx
state, we can defer the sending of the netconsole frames until a later
time using the retransmit feature of netpoll_send_skb that is triggered
on the return code NETDEV_TX_BUSY.

	Cc: Jay Vosburgh <fubar@us.ibm.com>
	Cc: Veaceslav Falico <vfalico@redhat.com>
	Cc: Andy Gospodarek <andy@greyhouse.net>
	Signed-off-by: Ding Tianhong <dingtianhong@huawei.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f80889a5b79cae0b84465a90c21b1273a03b7973)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
diff --cc drivers/net/bonding/bond_main.c
index 4c3b4d213395,867664918715..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -1838,6 -1532,23 +1838,26 @@@ int bond_enslave(struct net_device *bon
  		goto err_unregister;
  	}
  
++<<<<<<< HEAD
++=======
+ 	res = bond_sysfs_slave_add(new_slave);
+ 	if (res) {
+ 		pr_debug("Error %d calling bond_sysfs_slave_add\n", res);
+ 		goto err_upper_unlink;
+ 	}
+ 
+ 	bond->slave_cnt++;
+ 	bond_compute_features(bond);
+ 	bond_set_carrier(bond);
+ 
+ 	if (USES_PRIMARY(bond->params.mode)) {
+ 		block_netpoll_tx();
+ 		write_lock_bh(&bond->curr_slave_lock);
+ 		bond_select_active_slave(bond);
+ 		write_unlock_bh(&bond->curr_slave_lock);
+ 		unblock_netpoll_tx();
+ 	}
++>>>>>>> f80889a5b79c (bonding: Fix deadlock in bonding driver when using netpoll)
  
  	pr_info("%s: enslaving %s as a%s interface with a%s link.\n",
  		bond_dev->name, slave_dev->name,
@@@ -1866,15 -1573,12 +1886,24 @@@ err_detach
  	if (bond->primary_slave == new_slave)
  		bond->primary_slave = NULL;
  	if (bond->curr_active_slave == new_slave) {
++<<<<<<< HEAD
++=======
+ 		block_netpoll_tx();
+ 		write_lock_bh(&bond->curr_slave_lock);
++>>>>>>> f80889a5b79c (bonding: Fix deadlock in bonding driver when using netpoll)
  		bond_change_active_slave(bond, NULL);
 +		write_unlock_bh(&bond->lock);
 +		read_lock(&bond->lock);
 +		write_lock_bh(&bond->curr_slave_lock);
  		bond_select_active_slave(bond);
  		write_unlock_bh(&bond->curr_slave_lock);
++<<<<<<< HEAD
 +		read_unlock(&bond->lock);
 +	} else {
 +		write_unlock_bh(&bond->lock);
++=======
+ 		unblock_netpoll_tx();
++>>>>>>> f80889a5b79c (bonding: Fix deadlock in bonding driver when using netpoll)
  	}
  	slave_disable_netpoll(new_slave);
  
* Unmerged path drivers/net/bonding/bond_main.c
