be2net: remove code duplication relating to Lancer reset sequence

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Sathya Perla <sathya.perla@emulex.com>
commit 9fa465c0ce0d99f098195d7b0a550aeb1b2a8c44
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/9fa465c0.failed

The steps needed for Lancer's reset/initialization sequence are:
	a) wait for SLIPORT_STAUS RDY bit to be set
	b) set the SLIPORT_CONTROL IP bit
	c) repeat step "a"

The code needed for this sequence is already covered by the be_func_init()
routine (with minor modifications.) So, get rid of the
lancer_test_and_set_rdy_state() and lancer_provisioning_error() routines
that unnecessarily duplicate this code. Also fixed the error recovery
function to take care of these changes

	Signed-off-by: Sathya Perla <sathya.perla@emulex.com>
	Signed-off-by: Kalesh AP <kalesh.purayil@emulex.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9fa465c0ce0d99f098195d7b0a550aeb1b2a8c44)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/emulex/benet/be_main.c
diff --cc drivers/net/ethernet/emulex/benet/be_main.c
index b2184bdb8a43,4a29ff15a3cc..000000000000
--- a/drivers/net/ethernet/emulex/benet/be_main.c
+++ b/drivers/net/ethernet/emulex/benet/be_main.c
@@@ -4622,230 -4903,47 +4622,272 @@@ static void be_netdev_init(struct net_d
  	netdev->ethtool_ops = &be_ethtool_ops;
  }
  
++<<<<<<< HEAD
 +static void be_unmap_pci_bars(struct be_adapter *adapter)
 +{
 +	if (adapter->csr)
 +		pci_iounmap(adapter->pdev, adapter->csr);
 +	if (adapter->db)
 +		pci_iounmap(adapter->pdev, adapter->db);
 +}
 +
 +static int db_bar(struct be_adapter *adapter)
 +{
 +	if (lancer_chip(adapter) || !be_physfn(adapter))
 +		return 0;
 +	else
 +		return 4;
 +}
 +
 +static int be_roce_map_pci_bars(struct be_adapter *adapter)
 +{
 +	if (skyhawk_chip(adapter)) {
 +		adapter->roce_db.size = 4096;
 +		adapter->roce_db.io_addr = pci_resource_start(adapter->pdev,
 +							      db_bar(adapter));
 +		adapter->roce_db.total_size = pci_resource_len(adapter->pdev,
 +							       db_bar(adapter));
 +	}
 +	return 0;
 +}
 +
 +static int be_map_pci_bars(struct be_adapter *adapter)
 +{
 +	struct pci_dev *pdev = adapter->pdev;
 +	u8 __iomem *addr;
 +
 +	if (BEx_chip(adapter) && be_physfn(adapter)) {
 +		adapter->csr = pci_iomap(pdev, 2, 0);
 +		if (!adapter->csr)
 +			return -ENOMEM;
 +	}
 +
 +	addr = pci_iomap(pdev, db_bar(adapter), 0);
 +	if (!addr)
 +		goto pci_map_err;
 +	adapter->db = addr;
 +
 +	if (skyhawk_chip(adapter) || BEx_chip(adapter)) {
 +		if (be_physfn(adapter)) {
 +			/* PCICFG is the 2nd BAR in BE2 */
 +			addr = pci_iomap(pdev, BE2_chip(adapter) ? 1 : 0, 0);
 +			if (!addr)
 +				goto pci_map_err;
 +			adapter->pcicfg = addr;
 +		} else {
 +			adapter->pcicfg = adapter->db + SRIOV_VF_PCICFG_OFFSET;
 +		}
 +	}
 +
 +	be_roce_map_pci_bars(adapter);
 +	return 0;
 +
 +pci_map_err:
 +	dev_err(&pdev->dev, "Error in mapping PCI BARs\n");
 +	be_unmap_pci_bars(adapter);
 +	return -ENOMEM;
 +}
 +
 +static void be_ctrl_cleanup(struct be_adapter *adapter)
 +{
 +	struct be_dma_mem *mem = &adapter->mbox_mem_alloced;
 +
 +	be_unmap_pci_bars(adapter);
 +
 +	if (mem->va)
 +		dma_free_coherent(&adapter->pdev->dev, mem->size, mem->va,
 +				  mem->dma);
 +
 +	mem = &adapter->rx_filter;
 +	if (mem->va)
 +		dma_free_coherent(&adapter->pdev->dev, mem->size, mem->va,
 +				  mem->dma);
 +}
 +
 +static int be_ctrl_init(struct be_adapter *adapter)
 +{
 +	struct be_dma_mem *mbox_mem_alloc = &adapter->mbox_mem_alloced;
 +	struct be_dma_mem *mbox_mem_align = &adapter->mbox_mem;
 +	struct be_dma_mem *rx_filter = &adapter->rx_filter;
 +	u32 sli_intf;
 +	int status;
 +
 +	pci_read_config_dword(adapter->pdev, SLI_INTF_REG_OFFSET, &sli_intf);
 +	adapter->sli_family = (sli_intf & SLI_INTF_FAMILY_MASK) >>
 +				 SLI_INTF_FAMILY_SHIFT;
 +	adapter->virtfn = (sli_intf & SLI_INTF_FT_MASK) ? 1 : 0;
 +
 +	status = be_map_pci_bars(adapter);
 +	if (status)
 +		goto done;
 +
 +	mbox_mem_alloc->size = sizeof(struct be_mcc_mailbox) + 16;
 +	mbox_mem_alloc->va = dma_alloc_coherent(&adapter->pdev->dev,
 +						mbox_mem_alloc->size,
 +						&mbox_mem_alloc->dma,
 +						GFP_KERNEL);
 +	if (!mbox_mem_alloc->va) {
 +		status = -ENOMEM;
 +		goto unmap_pci_bars;
 +	}
 +	mbox_mem_align->size = sizeof(struct be_mcc_mailbox);
 +	mbox_mem_align->va = PTR_ALIGN(mbox_mem_alloc->va, 16);
 +	mbox_mem_align->dma = PTR_ALIGN(mbox_mem_alloc->dma, 16);
 +	memset(mbox_mem_align->va, 0, sizeof(struct be_mcc_mailbox));
 +
 +	rx_filter->size = sizeof(struct be_cmd_req_rx_filter);
 +	rx_filter->va = dma_zalloc_coherent(&adapter->pdev->dev,
 +					    rx_filter->size, &rx_filter->dma,
 +					    GFP_KERNEL);
 +	if (!rx_filter->va) {
 +		status = -ENOMEM;
 +		goto free_mbox;
 +	}
 +
 +	mutex_init(&adapter->mbox_lock);
 +	spin_lock_init(&adapter->mcc_lock);
 +	spin_lock_init(&adapter->mcc_cq_lock);
 +
 +	init_completion(&adapter->et_cmd_compl);
 +	pci_save_state(adapter->pdev);
 +	return 0;
 +
 +free_mbox:
 +	dma_free_coherent(&adapter->pdev->dev, mbox_mem_alloc->size,
 +			  mbox_mem_alloc->va, mbox_mem_alloc->dma);
 +
 +unmap_pci_bars:
 +	be_unmap_pci_bars(adapter);
 +
 +done:
 +	return status;
 +}
 +
 +static void be_stats_cleanup(struct be_adapter *adapter)
 +{
 +	struct be_dma_mem *cmd = &adapter->stats_cmd;
 +
 +	if (cmd->va)
 +		dma_free_coherent(&adapter->pdev->dev, cmd->size,
 +				  cmd->va, cmd->dma);
 +}
 +
 +static int be_stats_init(struct be_adapter *adapter)
 +{
 +	struct be_dma_mem *cmd = &adapter->stats_cmd;
 +
 +	if (lancer_chip(adapter))
 +		cmd->size = sizeof(struct lancer_cmd_req_pport_stats);
 +	else if (BE2_chip(adapter))
 +		cmd->size = sizeof(struct be_cmd_req_get_stats_v0);
 +	else if (BE3_chip(adapter))
 +		cmd->size = sizeof(struct be_cmd_req_get_stats_v1);
 +	else
 +		/* ALL non-BE ASICs */
 +		cmd->size = sizeof(struct be_cmd_req_get_stats_v2);
 +
 +	cmd->va = dma_zalloc_coherent(&adapter->pdev->dev, cmd->size, &cmd->dma,
 +				      GFP_KERNEL);
 +	if (!cmd->va)
 +		return -ENOMEM;
 +	return 0;
 +}
 +
 +static void be_remove(struct pci_dev *pdev)
 +{
 +	struct be_adapter *adapter = pci_get_drvdata(pdev);
 +
 +	if (!adapter)
 +		return;
 +
 +	be_roce_dev_remove(adapter);
 +	be_intr_set(adapter, false);
 +
 +	cancel_delayed_work_sync(&adapter->func_recovery_work);
 +
 +	unregister_netdev(adapter->netdev);
 +
 +	be_clear(adapter);
 +
 +	/* tell fw we're done with firing cmds */
 +	be_cmd_fw_clean(adapter);
 +
 +	be_stats_cleanup(adapter);
 +
 +	be_ctrl_cleanup(adapter);
 +
 +	pci_disable_pcie_error_reporting(pdev);
 +
 +	pci_release_regions(pdev);
 +	pci_disable_device(pdev);
 +
 +	free_netdev(adapter->netdev);
 +}
 +
 +static int be_get_initial_config(struct be_adapter *adapter)
 +{
 +	int status, level;
 +
 +	status = be_cmd_get_cntl_attributes(adapter);
 +	if (status)
 +		return status;
 +
 +	/* Must be a power of 2 or else MODULO will BUG_ON */
 +	adapter->be_get_temp_freq = 64;
 +
 +	if (BEx_chip(adapter)) {
 +		level = be_cmd_get_fw_log_level(adapter);
 +		adapter->msg_enable =
 +			level <= FW_LOG_LEVEL_DEFAULT ? NETIF_MSG_HW : 0;
 +	}
 +
 +	adapter->cfg_num_qs = netif_get_num_default_rss_queues();
 +	return 0;
 +}
 +
 +static int lancer_recover_func(struct be_adapter *adapter)
++=======
+ /* If any VFs are already enabled don't FLR the PF */
+ static bool be_reset_required(struct be_adapter *adapter)
+ {
+ 	return pci_num_vf(adapter->pdev) ? false : true;
+ }
+ 
+ /* Wait for the FW to be ready and perform the required initialization */
+ static int be_func_init(struct be_adapter *adapter)
+ {
+ 	int status;
+ 
+ 	status = be_fw_wait_ready(adapter);
+ 	if (status)
+ 		return status;
+ 
+ 	if (be_reset_required(adapter)) {
+ 		status = be_cmd_reset_function(adapter);
+ 		if (status)
+ 			return status;
+ 
+ 		/* Wait for interrupts to quiesce after an FLR */
+ 		msleep(100);
+ 
+ 		/* We can clear all errors when function reset succeeds */
+ 		be_clear_all_error(adapter);
+ 	}
+ 
+ 	/* Tell FW we're ready to fire cmds */
+ 	status = be_cmd_fw_init(adapter);
+ 	if (status)
+ 		return status;
+ 
+ 	/* Allow interrupts for other ULPs running on NIC function */
+ 	be_intr_set(adapter, true);
+ 
+ 	return 0;
+ }
+ 
+ static int be_err_recover(struct be_adapter *adapter)
++>>>>>>> 9fa465c0ce0d (be2net: remove code duplication relating to Lancer reset sequence)
  {
 -	struct net_device *netdev = adapter->netdev;
  	struct device *dev = &adapter->pdev->dev;
  	int status;
  
@@@ -4853,13 -4951,6 +4895,16 @@@
  	if (status)
  		goto err;
  
++<<<<<<< HEAD
 +	if (netif_running(adapter->netdev))
 +		be_close(adapter->netdev);
 +
 +	be_clear(adapter);
 +
 +	be_clear_all_error(adapter);
 +
++=======
++>>>>>>> 9fa465c0ce0d (be2net: remove code duplication relating to Lancer reset sequence)
  	status = be_setup(adapter);
  	if (status)
  		goto err;
@@@ -4870,13 -4961,15 +4915,19 @@@
  			goto err;
  	}
  
++<<<<<<< HEAD
 +	dev_err(dev, "Adapter recovery successful\n");
++=======
+ 	netif_device_attach(netdev);
+ 
+ 	dev_info(dev, "Adapter recovery successful\n");
++>>>>>>> 9fa465c0ce0d (be2net: remove code duplication relating to Lancer reset sequence)
  	return 0;
  err:
- 	if (status == -EAGAIN)
- 		dev_err(dev, "Waiting for resource provisioning\n");
- 	else
+ 	if (be_physfn(adapter))
  		dev_err(dev, "Adapter recovery failed\n");
+ 	else
+ 		dev_err(dev, "Re-trying adapter recovery\n");
  
  	return status;
  }
@@@ -4889,22 -4984,23 +4940,28 @@@ static void be_func_recovery_task(struc
  
  	be_detect_error(adapter);
  
 -	if (adapter->hw_error) {
 +	if (adapter->hw_error && lancer_chip(adapter)) {
  		rtnl_lock();
 -		netif_device_detach(netdev);
 -		if (netif_running(netdev))
 -			be_close(netdev);
 +		netif_device_detach(adapter->netdev);
  		rtnl_unlock();
  
 -		be_clear(adapter);
 -
 -		/* As of now error recovery support is in Lancer only */
 -		if (lancer_chip(adapter))
 -			status = be_err_recover(adapter);
 +		status = lancer_recover_func(adapter);
 +		if (!status)
 +			netif_device_attach(adapter->netdev);
  	}
  
++<<<<<<< HEAD
 +	/* In Lancer, for all errors other than provisioning error (-EAGAIN),
 +	 * no need to attempt further recovery.
 +	 */
 +	if (!status || status == -EAGAIN)
 +		schedule_delayed_work(&adapter->func_recovery_work,
 +				      msecs_to_jiffies(1000));
++=======
+ 	/* Always attempt recovery on VFs */
+ 	if (!status || be_virtfn(adapter))
+ 		be_schedule_err_detection(adapter);
++>>>>>>> 9fa465c0ce0d (be2net: remove code duplication relating to Lancer reset sequence)
  }
  
  static void be_log_sfp_info(struct be_adapter *adapter)
@@@ -4967,10 -5064,182 +5024,189 @@@ reschedule
  	schedule_delayed_work(&adapter->work, msecs_to_jiffies(1000));
  }
  
++<<<<<<< HEAD
 +/* If any VFs are already enabled don't FLR the PF */
 +static bool be_reset_required(struct be_adapter *adapter)
 +{
 +	return pci_num_vf(adapter->pdev) ? false : true;
++=======
+ static void be_unmap_pci_bars(struct be_adapter *adapter)
+ {
+ 	if (adapter->csr)
+ 		pci_iounmap(adapter->pdev, adapter->csr);
+ 	if (adapter->db)
+ 		pci_iounmap(adapter->pdev, adapter->db);
+ }
+ 
+ static int db_bar(struct be_adapter *adapter)
+ {
+ 	if (lancer_chip(adapter) || !be_physfn(adapter))
+ 		return 0;
+ 	else
+ 		return 4;
+ }
+ 
+ static int be_roce_map_pci_bars(struct be_adapter *adapter)
+ {
+ 	if (skyhawk_chip(adapter)) {
+ 		adapter->roce_db.size = 4096;
+ 		adapter->roce_db.io_addr = pci_resource_start(adapter->pdev,
+ 							      db_bar(adapter));
+ 		adapter->roce_db.total_size = pci_resource_len(adapter->pdev,
+ 							       db_bar(adapter));
+ 	}
+ 	return 0;
+ }
+ 
+ static int be_map_pci_bars(struct be_adapter *adapter)
+ {
+ 	u8 __iomem *addr;
+ 	u32 sli_intf;
+ 
+ 	pci_read_config_dword(adapter->pdev, SLI_INTF_REG_OFFSET, &sli_intf);
+ 	adapter->sli_family = (sli_intf & SLI_INTF_FAMILY_MASK) >>
+ 				SLI_INTF_FAMILY_SHIFT;
+ 	adapter->virtfn = (sli_intf & SLI_INTF_FT_MASK) ? 1 : 0;
+ 
+ 	if (BEx_chip(adapter) && be_physfn(adapter)) {
+ 		adapter->csr = pci_iomap(adapter->pdev, 2, 0);
+ 		if (!adapter->csr)
+ 			return -ENOMEM;
+ 	}
+ 
+ 	addr = pci_iomap(adapter->pdev, db_bar(adapter), 0);
+ 	if (!addr)
+ 		goto pci_map_err;
+ 	adapter->db = addr;
+ 
+ 	be_roce_map_pci_bars(adapter);
+ 	return 0;
+ 
+ pci_map_err:
+ 	dev_err(&adapter->pdev->dev, "Error in mapping PCI BARs\n");
+ 	be_unmap_pci_bars(adapter);
+ 	return -ENOMEM;
+ }
+ 
+ static void be_drv_cleanup(struct be_adapter *adapter)
+ {
+ 	struct be_dma_mem *mem = &adapter->mbox_mem_alloced;
+ 	struct device *dev = &adapter->pdev->dev;
+ 
+ 	if (mem->va)
+ 		dma_free_coherent(dev, mem->size, mem->va, mem->dma);
+ 
+ 	mem = &adapter->rx_filter;
+ 	if (mem->va)
+ 		dma_free_coherent(dev, mem->size, mem->va, mem->dma);
+ 
+ 	mem = &adapter->stats_cmd;
+ 	if (mem->va)
+ 		dma_free_coherent(dev, mem->size, mem->va, mem->dma);
+ }
+ 
+ /* Allocate and initialize various fields in be_adapter struct */
+ static int be_drv_init(struct be_adapter *adapter)
+ {
+ 	struct be_dma_mem *mbox_mem_alloc = &adapter->mbox_mem_alloced;
+ 	struct be_dma_mem *mbox_mem_align = &adapter->mbox_mem;
+ 	struct be_dma_mem *rx_filter = &adapter->rx_filter;
+ 	struct be_dma_mem *stats_cmd = &adapter->stats_cmd;
+ 	struct device *dev = &adapter->pdev->dev;
+ 	int status = 0;
+ 
+ 	mbox_mem_alloc->size = sizeof(struct be_mcc_mailbox) + 16;
+ 	mbox_mem_alloc->va = dma_alloc_coherent(dev, mbox_mem_alloc->size,
+ 						&mbox_mem_alloc->dma,
+ 						GFP_KERNEL);
+ 	if (!mbox_mem_alloc->va)
+ 		return -ENOMEM;
+ 
+ 	mbox_mem_align->size = sizeof(struct be_mcc_mailbox);
+ 	mbox_mem_align->va = PTR_ALIGN(mbox_mem_alloc->va, 16);
+ 	mbox_mem_align->dma = PTR_ALIGN(mbox_mem_alloc->dma, 16);
+ 	memset(mbox_mem_align->va, 0, sizeof(struct be_mcc_mailbox));
+ 
+ 	rx_filter->size = sizeof(struct be_cmd_req_rx_filter);
+ 	rx_filter->va = dma_zalloc_coherent(dev, rx_filter->size,
+ 					    &rx_filter->dma, GFP_KERNEL);
+ 	if (!rx_filter->va) {
+ 		status = -ENOMEM;
+ 		goto free_mbox;
+ 	}
+ 
+ 	if (lancer_chip(adapter))
+ 		stats_cmd->size = sizeof(struct lancer_cmd_req_pport_stats);
+ 	else if (BE2_chip(adapter))
+ 		stats_cmd->size = sizeof(struct be_cmd_req_get_stats_v0);
+ 	else if (BE3_chip(adapter))
+ 		stats_cmd->size = sizeof(struct be_cmd_req_get_stats_v1);
+ 	else
+ 		stats_cmd->size = sizeof(struct be_cmd_req_get_stats_v2);
+ 	stats_cmd->va = dma_zalloc_coherent(dev, stats_cmd->size,
+ 					    &stats_cmd->dma, GFP_KERNEL);
+ 	if (!stats_cmd->va) {
+ 		status = -ENOMEM;
+ 		goto free_rx_filter;
+ 	}
+ 
+ 	mutex_init(&adapter->mbox_lock);
+ 	spin_lock_init(&adapter->mcc_lock);
+ 	spin_lock_init(&adapter->mcc_cq_lock);
+ 	init_completion(&adapter->et_cmd_compl);
+ 
+ 	pci_save_state(adapter->pdev);
+ 
+ 	INIT_DELAYED_WORK(&adapter->work, be_worker);
+ 	INIT_DELAYED_WORK(&adapter->be_err_detection_work,
+ 			  be_err_detection_task);
+ 
+ 	adapter->rx_fc = true;
+ 	adapter->tx_fc = true;
+ 
+ 	/* Must be a power of 2 or else MODULO will BUG_ON */
+ 	adapter->be_get_temp_freq = 64;
+ 	adapter->cfg_num_qs = netif_get_num_default_rss_queues();
+ 
+ 	return 0;
+ 
+ free_rx_filter:
+ 	dma_free_coherent(dev, rx_filter->size, rx_filter->va, rx_filter->dma);
+ free_mbox:
+ 	dma_free_coherent(dev, mbox_mem_alloc->size, mbox_mem_alloc->va,
+ 			  mbox_mem_alloc->dma);
+ 	return status;
+ }
+ 
+ static void be_remove(struct pci_dev *pdev)
+ {
+ 	struct be_adapter *adapter = pci_get_drvdata(pdev);
+ 
+ 	if (!adapter)
+ 		return;
+ 
+ 	be_roce_dev_remove(adapter);
+ 	be_intr_set(adapter, false);
+ 
+ 	be_cancel_err_detection(adapter);
+ 
+ 	unregister_netdev(adapter->netdev);
+ 
+ 	be_clear(adapter);
+ 
+ 	/* tell fw we're done with firing cmds */
+ 	be_cmd_fw_clean(adapter);
+ 
+ 	be_unmap_pci_bars(adapter);
+ 	be_drv_cleanup(adapter);
+ 
+ 	pci_disable_pcie_error_reporting(pdev);
+ 
+ 	pci_release_regions(pdev);
+ 	pci_disable_device(pdev);
+ 
+ 	free_netdev(adapter->netdev);
++>>>>>>> 9fa465c0ce0d (be2net: remove code duplication relating to Lancer reset sequence)
  }
  
  static char *mc_name(struct be_adapter *adapter)
@@@ -5008,6 -5277,26 +5244,29 @@@ static inline char *func_name(struct be
  	return be_physfn(adapter) ? "PF" : "VF";
  }
  
++<<<<<<< HEAD
++=======
+ static inline char *nic_name(struct pci_dev *pdev)
+ {
+ 	switch (pdev->device) {
+ 	case OC_DEVICE_ID1:
+ 		return OC_NAME;
+ 	case OC_DEVICE_ID2:
+ 		return OC_NAME_BE;
+ 	case OC_DEVICE_ID3:
+ 	case OC_DEVICE_ID4:
+ 		return OC_NAME_LANCER;
+ 	case BE_DEVICE_ID2:
+ 		return BE3_NAME;
+ 	case OC_DEVICE_ID5:
+ 	case OC_DEVICE_ID6:
+ 		return OC_NAME_SH;
+ 	default:
+ 		return BE_NAME;
+ 	}
+ }
+ 
++>>>>>>> 9fa465c0ce0d (be2net: remove code duplication relating to Lancer reset sequence)
  static int be_probe(struct pci_dev *pdev, const struct pci_device_id *pdev_id)
  {
  	struct be_adapter *adapter;
diff --git a/drivers/net/ethernet/emulex/benet/be_cmds.c b/drivers/net/ethernet/emulex/benet/be_cmds.c
index 4c2df61e8122..6e42a6125232 100644
--- a/drivers/net/ethernet/emulex/benet/be_cmds.c
+++ b/drivers/net/ethernet/emulex/benet/be_cmds.c
@@ -635,73 +635,16 @@ static int lancer_wait_ready(struct be_adapter *adapter)
 	for (i = 0; i < SLIPORT_READY_TIMEOUT; i++) {
 		sliport_status = ioread32(adapter->db + SLIPORT_STATUS_OFFSET);
 		if (sliport_status & SLIPORT_STATUS_RDY_MASK)
-			break;
-
-		msleep(1000);
-	}
-
-	if (i == SLIPORT_READY_TIMEOUT)
-		return sliport_status ? : -1;
-
-	return 0;
-}
-
-static bool lancer_provisioning_error(struct be_adapter *adapter)
-{
-	u32 sliport_status = 0, sliport_err1 = 0, sliport_err2 = 0;
-
-	sliport_status = ioread32(adapter->db + SLIPORT_STATUS_OFFSET);
-	if (sliport_status & SLIPORT_STATUS_ERR_MASK) {
-		sliport_err1 = ioread32(adapter->db + SLIPORT_ERROR1_OFFSET);
-		sliport_err2 = ioread32(adapter->db + SLIPORT_ERROR2_OFFSET);
-
-		if (sliport_err1 == SLIPORT_ERROR_NO_RESOURCE1 &&
-		    sliport_err2 == SLIPORT_ERROR_NO_RESOURCE2)
-			return true;
-	}
-	return false;
-}
-
-int lancer_test_and_set_rdy_state(struct be_adapter *adapter)
-{
-	int status;
-	u32 sliport_status, err, reset_needed;
-	bool resource_error;
+			return 0;
 
-	resource_error = lancer_provisioning_error(adapter);
-	if (resource_error)
-		return -EAGAIN;
+		if (sliport_status & SLIPORT_STATUS_ERR_MASK &&
+		    !(sliport_status & SLIPORT_STATUS_RN_MASK))
+			return -EIO;
 
-	status = lancer_wait_ready(adapter);
-	if (!status) {
-		sliport_status = ioread32(adapter->db + SLIPORT_STATUS_OFFSET);
-		err = sliport_status & SLIPORT_STATUS_ERR_MASK;
-		reset_needed = sliport_status & SLIPORT_STATUS_RN_MASK;
-		if (err && reset_needed) {
-			iowrite32(SLI_PORT_CONTROL_IP_MASK,
-				  adapter->db + SLIPORT_CONTROL_OFFSET);
-
-			/* check if adapter has corrected the error */
-			status = lancer_wait_ready(adapter);
-			sliport_status = ioread32(adapter->db +
-						  SLIPORT_STATUS_OFFSET);
-			sliport_status &= (SLIPORT_STATUS_ERR_MASK |
-						SLIPORT_STATUS_RN_MASK);
-			if (status || sliport_status)
-				status = -1;
-		} else if (err || reset_needed) {
-			status = -1;
-		}
+		msleep(1000);
 	}
-	/* Stop error recovery if error is not recoverable.
-	 * No resource error is temporary errors and will go away
-	 * when PF provisions resources.
-	 */
-	resource_error = lancer_provisioning_error(adapter);
-	if (resource_error)
-		status = -EAGAIN;
 
-	return status;
+	return sliport_status ? : -1;
 }
 
 int be_fw_wait_ready(struct be_adapter *adapter)
@@ -734,7 +677,7 @@ int be_fw_wait_ready(struct be_adapter *adapter)
 
 err:
 	dev_err(dev, "POST timeout; stage=%#x\n", stage);
-	return -1;
+	return -ETIMEDOUT;
 }
 
 static inline struct be_sge *nonembedded_sgl(struct be_mcc_wrb *wrb)
@@ -2126,16 +2069,12 @@ int be_cmd_reset_function(struct be_adapter *adapter)
 	int status;
 
 	if (lancer_chip(adapter)) {
+		iowrite32(SLI_PORT_CONTROL_IP_MASK,
+			  adapter->db + SLIPORT_CONTROL_OFFSET);
 		status = lancer_wait_ready(adapter);
-		if (!status) {
-			iowrite32(SLI_PORT_CONTROL_IP_MASK,
-				  adapter->db + SLIPORT_CONTROL_OFFSET);
-			status = lancer_test_and_set_rdy_state(adapter);
-		}
-		if (status) {
+		if (status)
 			dev_err(&adapter->pdev->dev,
 				"Adapter in non recoverable error\n");
-		}
 		return status;
 	}
 
* Unmerged path drivers/net/ethernet/emulex/benet/be_main.c
