bonding: remove bond_for_each_slave_continue_reverse()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Veaceslav Falico <vfalico@redhat.com>
commit 81f23b13ac985e9a3cfb889c690695a8932e02c2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/81f23b13.failed

We only use it in rollback scenarios and can easily use the standart
bond_for_each_dev() instead.

CC: Jay Vosburgh <fubar@us.ibm.com>
CC: Andy Gospodarek <andy@greyhouse.net>
	Signed-off-by: Veaceslav Falico <vfalico@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 81f23b13ac985e9a3cfb889c690695a8932e02c2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_alb.c
#	drivers/net/bonding/bond_main.c
#	drivers/net/bonding/bonding.h
diff --cc drivers/net/bonding/bond_alb.c
index b7563cd17726,6437657375d7..000000000000
--- a/drivers/net/bonding/bond_alb.c
+++ b/drivers/net/bonding/bond_alb.c
@@@ -1248,17 -1246,15 +1248,22 @@@ static int alb_handle_addr_collision_on
   */
  static int alb_set_mac_address(struct bonding *bond, void *addr)
  {
++<<<<<<< HEAD
 +	struct sockaddr sa;
 +	struct slave *slave, *stop_at;
++=======
+ 	struct slave *slave, *rollback_slave;
+ 	struct sockaddr sa;
++>>>>>>> 81f23b13ac98 (bonding: remove bond_for_each_slave_continue_reverse())
  	char tmp_addr[ETH_ALEN];
  	int res;
 +	int i;
  
 -	if (bond->alb_info.rlb_enabled)
 +	if (bond->alb_info.rlb_enabled) {
  		return 0;
 +	}
  
 -	bond_for_each_slave(bond, slave) {
 +	bond_for_each_slave(bond, slave, i) {
  		/* save net_device's current hw address */
  		memcpy(tmp_addr, slave->dev->dev_addr, ETH_ALEN);
  
@@@ -1278,11 -1274,12 +1283,20 @@@ unwind
  	sa.sa_family = bond->dev->type;
  
  	/* unwind from head to the slave that failed */
++<<<<<<< HEAD
 +	stop_at = slave;
 +	bond_for_each_slave_from_to(bond, slave, i, bond->first_slave, stop_at) {
 +		memcpy(tmp_addr, slave->dev->dev_addr, ETH_ALEN);
 +		dev_set_mac_address(slave->dev, &sa);
 +		memcpy(slave->dev->dev_addr, tmp_addr, ETH_ALEN);
++=======
+ 	bond_for_each_slave(bond, rollback_slave) {
+ 		if (rollback_slave == slave)
+ 			break;
+ 		memcpy(tmp_addr, rollback_slave->dev->dev_addr, ETH_ALEN);
+ 		dev_set_mac_address(rollback_slave->dev, &sa);
+ 		memcpy(rollback_slave->dev->dev_addr, tmp_addr, ETH_ALEN);
++>>>>>>> 81f23b13ac98 (bonding: remove bond_for_each_slave_continue_reverse())
  	}
  
  	return res;
diff --cc drivers/net/bonding/bond_main.c
index 05a57077bb1c,d94b6c16537d..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -441,10 -332,10 +441,15 @@@ static int bond_vlan_rx_add_vid(struct 
  				__be16 proto, u16 vid)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
++<<<<<<< HEAD
 +	struct slave *slave, *stop_at;
 +	int i, res;
++=======
+ 	struct slave *slave, *rollback_slave;
+ 	int res;
++>>>>>>> 81f23b13ac98 (bonding: remove bond_for_each_slave_continue_reverse())
  
 -	bond_for_each_slave(bond, slave) {
 +	bond_for_each_slave(bond, slave, i) {
  		res = vlan_vid_add(slave->dev, proto, vid);
  		if (res)
  			goto unwind;
@@@ -460,10 -344,13 +465,20 @@@
  	return 0;
  
  unwind:
++<<<<<<< HEAD
 +	/* unwind from head to the slave that failed */
 +	stop_at = slave;
 +	bond_for_each_slave_from_to(bond, slave, i, bond->first_slave, stop_at)
 +		vlan_vid_del(slave->dev, proto, vid);
++=======
+ 	/* unwind to the slave that failed */
+ 	bond_for_each_slave(bond, rollback_slave) {
+ 		if (rollback_slave == slave)
+ 			break;
+ 
+ 		vlan_vid_del(rollback_slave->dev, proto, vid);
+ 	}
++>>>>>>> 81f23b13ac98 (bonding: remove bond_for_each_slave_continue_reverse())
  
  	return res;
  }
@@@ -3747,9 -3472,8 +3762,13 @@@ static int bond_neigh_setup(struct net_
  static int bond_change_mtu(struct net_device *bond_dev, int new_mtu)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
++<<<<<<< HEAD
 +	struct slave *slave, *stop_at;
++=======
+ 	struct slave *slave, *rollback_slave;
++>>>>>>> 81f23b13ac98 (bonding: remove bond_for_each_slave_continue_reverse())
  	int res = 0;
 +	int i;
  
  	pr_debug("bond=%p, name=%s, new_mtu=%d\n", bond,
  		 (bond_dev ? bond_dev->name : "None"), new_mtu);
@@@ -3797,14 -3521,16 +3816,21 @@@
  
  unwind:
  	/* unwind from head to the slave that failed */
++<<<<<<< HEAD
 +	stop_at = slave;
 +	bond_for_each_slave_from_to(bond, slave, i, bond->first_slave, stop_at) {
++=======
+ 	bond_for_each_slave(bond, rollback_slave) {
++>>>>>>> 81f23b13ac98 (bonding: remove bond_for_each_slave_continue_reverse())
  		int tmp_res;
  
- 		tmp_res = dev_set_mtu(slave->dev, bond_dev->mtu);
+ 		if (rollback_slave == slave)
+ 			break;
+ 
+ 		tmp_res = dev_set_mtu(rollback_slave->dev, bond_dev->mtu);
  		if (tmp_res) {
  			pr_debug("unwind err %d dev %s\n",
- 				 tmp_res, slave->dev->name);
+ 				 tmp_res, rollback_slave->dev->name);
  		}
  	}
  
@@@ -3821,10 -3547,9 +3847,14 @@@
  static int bond_set_mac_address(struct net_device *bond_dev, void *addr)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
+ 	struct slave *slave, *rollback_slave;
  	struct sockaddr *sa = addr, tmp_sa;
++<<<<<<< HEAD
 +	struct slave *slave, *stop_at;
++=======
++>>>>>>> 81f23b13ac98 (bonding: remove bond_for_each_slave_continue_reverse())
  	int res = 0;
 +	int i;
  
  	if (bond->params.mode == BOND_MODE_ALB)
  		return bond_alb_set_mac_address(bond_dev, addr);
@@@ -3889,14 -3614,16 +3919,21 @@@ unwind
  	tmp_sa.sa_family = bond_dev->type;
  
  	/* unwind from head to the slave that failed */
++<<<<<<< HEAD
 +	stop_at = slave;
 +	bond_for_each_slave_from_to(bond, slave, i, bond->first_slave, stop_at) {
++=======
+ 	bond_for_each_slave(bond, rollback_slave) {
++>>>>>>> 81f23b13ac98 (bonding: remove bond_for_each_slave_continue_reverse())
  		int tmp_res;
  
- 		tmp_res = dev_set_mac_address(slave->dev, &tmp_sa);
+ 		if (rollback_slave == slave)
+ 			break;
+ 
+ 		tmp_res = dev_set_mac_address(rollback_slave->dev, &tmp_sa);
  		if (tmp_res) {
  			pr_debug("unwind err %d dev %s\n",
- 				 tmp_res, slave->dev->name);
+ 				 tmp_res, rollback_slave->dev->name);
  		}
  	}
  
diff --cc drivers/net/bonding/bonding.h
index 788e19ed5f58,0b0c3df21a89..000000000000
--- a/drivers/net/bonding/bonding.h
+++ b/drivers/net/bonding/bonding.h
@@@ -95,23 -113,13 +95,26 @@@
   *
   * Caller must hold bond->lock
   */
 -#define bond_for_each_slave(bond, pos) \
 -	list_for_each_entry(pos, &(bond)->slave_list, list)
 +#define bond_for_each_slave_from_to(bond, pos, cnt, start, stop)	\
 +	for (cnt = 0, pos = start;					\
 +	     ((cnt < (bond)->slave_cnt) && (pos != (stop)->next));	\
 +             cnt++, pos = (pos)->next)
 +
++<<<<<<< HEAD
 +/**
 + * bond_for_each_slave - iterate the slaves list from head
 + * @bond:	the bond holding this list.
 + * @pos:	current slave.
 + * @cnt:	counter for max number of moves
 + *
 + * Caller must hold bond->lock
 + */
 +#define bond_for_each_slave(bond, pos, cnt)	\
 +		bond_for_each_slave_from(bond, pos, cnt, (bond)->first_slave)
  
 -/* Caller must have rcu_read_lock */
 -#define bond_for_each_slave_rcu(bond, pos) \
 -	list_for_each_entry_rcu(pos, &(bond)->slave_list, list)
  
++=======
++>>>>>>> 81f23b13ac98 (bonding: remove bond_for_each_slave_continue_reverse())
  #ifdef CONFIG_NET_POLL_CONTROLLER
  extern atomic_t netpoll_block_tx;
  
* Unmerged path drivers/net/bonding/bond_alb.c
* Unmerged path drivers/net/bonding/bond_main.c
* Unmerged path drivers/net/bonding/bonding.h
