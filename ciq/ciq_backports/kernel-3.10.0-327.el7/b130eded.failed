IB/iser: Get rid of struct iser_rdma_regd

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [infiniband] iser: Get rid of struct iser_rdma_regd (Amir Vadai) [1164539]
Rebuild_FUZZ: 96.20%
commit-author Sagi Grimberg <sagig@mellanox.com>
commit b130ededff03fcee9411be379fd24b5e840c5e9e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/b130eded.failed

This struct members other than struct iser_mem_reg are unused,
so remove it altogether.

This patch does not change any functionality.

	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Adir Lev <adirl@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit b130ededff03fcee9411be379fd24b5e840c5e9e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/iser/iscsi_iser.h
#	drivers/infiniband/ulp/iser/iser_initiator.c
#	drivers/infiniband/ulp/iser/iser_memory.c
diff --cc drivers/infiniband/ulp/iser/iscsi_iser.h
index e160d7ee63dc,8133678b6218..000000000000
--- a/drivers/infiniband/ulp/iser/iscsi_iser.h
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.h
@@@ -220,17 -259,8 +220,20 @@@ struct iser_mem_reg 
  	u64  va;
  	u64  len;
  	void *mem_h;
 +	int  is_mr;
 +};
 +
++<<<<<<< HEAD
 +struct iser_regd_buf {
 +	struct iser_mem_reg     reg;        /* memory registration info        */
 +	void                    *virt_addr;
 +	struct iser_device      *device;    /* device->device for dma_unmap    */
 +	enum dma_data_direction direction;  /* direction for dma_unmap	       */
 +	unsigned int            data_size;
  };
  
++=======
++>>>>>>> b130ededff03 (IB/iser: Get rid of struct iser_rdma_regd)
  enum iser_desc_type {
  	ISCSI_TX_CONTROL ,
  	ISCSI_TX_SCSI_COMMAND,
@@@ -341,35 -508,32 +344,59 @@@ struct iser_conn 
  	u64			     login_req_dma, login_resp_dma;
  	unsigned int 		     rx_desc_head;
  	struct iser_rx_desc	     *rx_descs;
 -	u32                          num_rx_descs;
 +	struct ib_recv_wr	     rx_wr[ISER_MIN_POSTED_RX];
 +	bool			     pi_support;
 +
 +	/* Connection memory registration pool */
 +	union {
 +		struct {
 +			struct ib_fmr_pool      *pool;	   /* pool of IB FMRs         */
 +			struct iser_page_vec	*page_vec; /* represents SG to fmr maps*
 +							    * maps serialized as tx is*/
 +		} fmr;
 +		struct {
 +			struct list_head	pool;
 +			int			pool_size;
 +		} fastreg;
 +	};
  };
  
++<<<<<<< HEAD
++=======
+ /**
+  * struct iscsi_iser_task - iser task context
+  *
+  * @desc:     TX descriptor
+  * @iser_conn:        link to iser connection
+  * @status:           current task status
+  * @sc:               link to scsi command
+  * @command_sent:     indicate if command was sent
+  * @dir:              iser data direction
+  * @rdma_reg:         task rdma registration desc
+  * @data:             iser data buffer desc
+  * @prot:             iser protection buffer desc
+  */
++>>>>>>> b130ededff03 (IB/iser: Get rid of struct iser_rdma_regd)
  struct iscsi_iser_task {
  	struct iser_tx_desc          desc;
 -	struct iser_conn	     *iser_conn;
 +	struct iser_conn	     *ib_conn;
  	enum iser_task_status 	     status;
  	struct scsi_cmnd	     *sc;
++<<<<<<< HEAD
 +	int                          command_sent;  /* set if command  sent  */
 +	int                          dir[ISER_DIRS_NUM];      /* set if dir use*/
 +	struct iser_regd_buf         rdma_regd[ISER_DIRS_NUM];/* regd rdma buf */
 +	struct iser_data_buf         data[ISER_DIRS_NUM];     /* orig. data des*/
 +	struct iser_data_buf         data_copy[ISER_DIRS_NUM];/* contig. copy  */
 +	struct iser_data_buf         prot[ISER_DIRS_NUM];     /* prot desc     */
 +	struct iser_data_buf         prot_copy[ISER_DIRS_NUM];/* prot copy     */
++=======
+ 	int                          command_sent;
+ 	int                          dir[ISER_DIRS_NUM];
+ 	struct iser_mem_reg          rdma_reg[ISER_DIRS_NUM];
+ 	struct iser_data_buf         data[ISER_DIRS_NUM];
+ 	struct iser_data_buf         prot[ISER_DIRS_NUM];
++>>>>>>> b130ededff03 (IB/iser: Get rid of struct iser_rdma_regd)
  };
  
  struct iser_page_vec {
diff --cc drivers/infiniband/ulp/iser/iser_initiator.c
index 065346a65b0d,420a613fe9f5..000000000000
--- a/drivers/infiniband/ulp/iser/iser_initiator.c
+++ b/drivers/infiniband/ulp/iser/iser_initiator.c
@@@ -49,8 -49,8 +49,13 @@@ static int iser_prepare_read_cmd(struc
  
  {
  	struct iscsi_iser_task *iser_task = task->dd_data;
++<<<<<<< HEAD
 +	struct iser_device  *device = iser_task->ib_conn->device;
 +	struct iser_regd_buf *regd_buf;
++=======
+ 	struct iser_device  *device = iser_task->iser_conn->ib_conn.device;
+ 	struct iser_mem_reg *mem_reg;
++>>>>>>> b130ededff03 (IB/iser: Get rid of struct iser_rdma_regd)
  	int err;
  	struct iser_hdr *hdr = &iser_task->desc.iser_header;
  	struct iser_data_buf *buf_in = &iser_task->data[ISER_DIR_IN];
@@@ -103,8 -103,8 +108,13 @@@ iser_prepare_write_cmd(struct iscsi_tas
  		       unsigned int edtl)
  {
  	struct iscsi_iser_task *iser_task = task->dd_data;
++<<<<<<< HEAD
 +	struct iser_device  *device = iser_task->ib_conn->device;
 +	struct iser_regd_buf *regd_buf;
++=======
+ 	struct iser_device  *device = iser_task->iser_conn->ib_conn.device;
+ 	struct iser_mem_reg *mem_reg;
++>>>>>>> b130ededff03 (IB/iser: Get rid of struct iser_rdma_regd)
  	int err;
  	struct iser_hdr *hdr = &iser_task->desc.iser_header;
  	struct iser_data_buf *buf_out = &iser_task->data[ISER_DIR_OUT];
@@@ -439,10 -447,10 +449,10 @@@ int iser_send_data_out(struct iscsi_con
  		       struct iscsi_task *task,
  		       struct iscsi_data *hdr)
  {
 -	struct iser_conn *iser_conn = conn->dd_data;
 +	struct iser_conn *ib_conn = conn->dd_data;
  	struct iscsi_iser_task *iser_task = task->dd_data;
  	struct iser_tx_desc *tx_desc = NULL;
- 	struct iser_regd_buf *regd_buf;
+ 	struct iser_mem_reg *mem_reg;
  	unsigned long buf_offset;
  	unsigned long data_seg_len;
  	uint32_t itt;
diff --cc drivers/infiniband/ulp/iser/iser_memory.c
index f40132fc970c,0b8656fcbc0d..000000000000
--- a/drivers/infiniband/ulp/iser/iser_memory.c
+++ b/drivers/infiniband/ulp/iser/iser_memory.c
@@@ -366,6 -362,91 +366,94 @@@ static int fall_to_bounce_buf(struct is
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * iser_reg_page_vec - Register physical memory
+  *
+  * returns: 0 on success, errno code on failure
+  */
+ static
+ int iser_reg_page_vec(struct ib_conn *ib_conn,
+ 		      struct iser_page_vec *page_vec,
+ 		      struct iser_mem_reg  *mem_reg)
+ {
+ 	struct ib_pool_fmr *mem;
+ 	u64		   io_addr;
+ 	u64		   *page_list;
+ 	int		   status;
+ 
+ 	page_list = page_vec->pages;
+ 	io_addr	  = page_list[0];
+ 
+ 	mem  = ib_fmr_pool_map_phys(ib_conn->fmr.pool,
+ 				    page_list,
+ 				    page_vec->length,
+ 				    io_addr);
+ 
+ 	if (IS_ERR(mem)) {
+ 		status = (int)PTR_ERR(mem);
+ 		iser_err("ib_fmr_pool_map_phys failed: %d\n", status);
+ 		return status;
+ 	}
+ 
+ 	mem_reg->lkey  = mem->fmr->lkey;
+ 	mem_reg->rkey  = mem->fmr->rkey;
+ 	mem_reg->len   = page_vec->data_size;
+ 	mem_reg->va    = io_addr + page_vec->offset;
+ 	mem_reg->mem_h = (void *)mem;
+ 
+ 	iser_dbg("PHYSICAL Mem.register, [PHYS p_array: 0x%p, sz: %d, "
+ 		 "entry[0]: (0x%08lx,%ld)] -> "
+ 		 "[lkey: 0x%08X mem_h: 0x%p va: 0x%08lX sz: %ld]\n",
+ 		 page_vec, page_vec->length,
+ 		 (unsigned long)page_vec->pages[0],
+ 		 (unsigned long)page_vec->data_size,
+ 		 (unsigned int)mem_reg->lkey, mem_reg->mem_h,
+ 		 (unsigned long)mem_reg->va, (unsigned long)mem_reg->len);
+ 	return 0;
+ }
+ 
+ /**
+  * Unregister (previosuly registered using FMR) memory.
+  * If memory is non-FMR does nothing.
+  */
+ void iser_unreg_mem_fmr(struct iscsi_iser_task *iser_task,
+ 			enum iser_data_dir cmd_dir)
+ {
+ 	struct iser_mem_reg *reg = &iser_task->rdma_reg[cmd_dir];
+ 	int ret;
+ 
+ 	if (!reg->mem_h)
+ 		return;
+ 
+ 	iser_dbg("PHYSICAL Mem.Unregister mem_h %p\n", reg->mem_h);
+ 
+ 	ret = ib_fmr_pool_unmap((struct ib_pool_fmr *)reg->mem_h);
+ 	if (ret)
+ 		iser_err("ib_fmr_pool_unmap failed %d\n", ret);
+ 
+ 	reg->mem_h = NULL;
+ }
+ 
+ void iser_unreg_mem_fastreg(struct iscsi_iser_task *iser_task,
+ 			    enum iser_data_dir cmd_dir)
+ {
+ 	struct iser_mem_reg *reg = &iser_task->rdma_reg[cmd_dir];
+ 	struct iser_conn *iser_conn = iser_task->iser_conn;
+ 	struct ib_conn *ib_conn = &iser_conn->ib_conn;
+ 	struct fast_reg_descriptor *desc = reg->mem_h;
+ 
+ 	if (!desc)
+ 		return;
+ 
+ 	reg->mem_h = NULL;
+ 	spin_lock_bh(&ib_conn->lock);
+ 	list_add_tail(&desc->list, &ib_conn->fastreg.pool);
+ 	spin_unlock_bh(&ib_conn->lock);
+ }
+ 
+ /**
++>>>>>>> b130ededff03 (IB/iser: Get rid of struct iser_rdma_regd)
   * iser_reg_rdma_mem_fmr - Registers memory intended for RDMA,
   * using FMR (if possible) obtaining rkey and va
   *
@@@ -400,13 -479,12 +488,20 @@@ int iser_reg_rdma_mem_fmr(struct iscsi_
  
  	/* if there a single dma entry, FMR is not needed */
  	if (mem->dma_nents == 1) {
 -		sg = mem->sg;
 -
 +		sg = (struct scatterlist *)mem->buf;
 +
++<<<<<<< HEAD
 +		regd_buf->reg.lkey = device->mr->lkey;
 +		regd_buf->reg.rkey = device->mr->rkey;
 +		regd_buf->reg.len  = ib_sg_dma_len(ibdev, &sg[0]);
 +		regd_buf->reg.va   = ib_sg_dma_address(ibdev, &sg[0]);
 +		regd_buf->reg.is_mr = 0;
++=======
+ 		mem_reg->lkey = device->mr->lkey;
+ 		mem_reg->rkey = device->mr->rkey;
+ 		mem_reg->len  = ib_sg_dma_len(ibdev, &sg[0]);
+ 		mem_reg->va   = ib_sg_dma_address(ibdev, &sg[0]);
++>>>>>>> b130ededff03 (IB/iser: Get rid of struct iser_rdma_regd)
  
  		iser_dbg("PHYSICAL Mem.register: lkey: 0x%08X rkey: 0x%08X  "
  			 "va: 0x%08lX sz: %ld]\n",
@@@ -612,8 -657,8 +707,13 @@@ static int iser_fast_reg_mr(struct iscs
  			    enum iser_reg_indicator ind,
  			    struct ib_sge *sge)
  {
++<<<<<<< HEAD
 +	struct fast_reg_descriptor *desc = regd_buf->reg.mem_h;
 +	struct iser_conn *ib_conn = iser_task->ib_conn;
++=======
+ 	struct fast_reg_descriptor *desc = mem_reg->mem_h;
+ 	struct ib_conn *ib_conn = &iser_task->iser_conn->ib_conn;
++>>>>>>> b130ededff03 (IB/iser: Get rid of struct iser_rdma_regd)
  	struct iser_device *device = ib_conn->device;
  	struct ib_device *ibdev = device->ib_device;
  	struct ib_mr *mr;
@@@ -749,10 -791,9 +849,10 @@@ int iser_reg_rdma_mem_fastreg(struct is
  					iser_err("failed to allocate bounce buffer\n");
  					return err;
  				}
 +				mem = &iser_task->prot_copy[cmd_dir];
  			}
  
- 			err = iser_fast_reg_mr(iser_task, regd_buf, mem,
+ 			err = iser_fast_reg_mr(iser_task, mem_reg, mem,
  					       ISER_PROT_KEY_VALID, &prot_sge);
  			if (err)
  				goto err_reg;
@@@ -766,23 -807,19 +866,35 @@@
  		}
  		desc->reg_indicators |= ISER_FASTREG_PROTECTED;
  
++<<<<<<< HEAD
 +		regd_buf->reg.lkey = sig_sge.lkey;
 +		regd_buf->reg.rkey = desc->pi_ctx->sig_mr->rkey;
 +		regd_buf->reg.va = sig_sge.addr;
 +		regd_buf->reg.len = sig_sge.length;
 +		regd_buf->reg.is_mr = 1;
 +	} else {
 +		if (desc) {
 +			regd_buf->reg.rkey = desc->data_mr->rkey;
 +			regd_buf->reg.is_mr = 1;
 +		} else {
 +			regd_buf->reg.rkey = device->mr->rkey;
 +			regd_buf->reg.is_mr = 0;
 +		}
- 
- 		regd_buf->reg.lkey = data_sge.lkey;
- 		regd_buf->reg.va = data_sge.addr;
- 		regd_buf->reg.len = data_sge.length;
++=======
+ 		mem_reg->lkey = sig_sge.lkey;
+ 		mem_reg->rkey = desc->pi_ctx->sig_mr->rkey;
+ 		mem_reg->va = sig_sge.addr;
+ 		mem_reg->len = sig_sge.length;
+ 	} else {
+ 		if (desc)
+ 			mem_reg->rkey = desc->data_mr->rkey;
+ 		else
+ 			mem_reg->rkey = device->mr->rkey;
++>>>>>>> b130ededff03 (IB/iser: Get rid of struct iser_rdma_regd)
+ 
+ 		mem_reg->lkey = data_sge.lkey;
+ 		mem_reg->va = data_sge.addr;
+ 		mem_reg->len = data_sge.length;
  	}
  
  	return 0;
* Unmerged path drivers/infiniband/ulp/iser/iscsi_iser.h
* Unmerged path drivers/infiniband/ulp/iser/iser_initiator.c
* Unmerged path drivers/infiniband/ulp/iser/iser_memory.c
diff --git a/drivers/infiniband/ulp/iser/iser_verbs.c b/drivers/infiniband/ulp/iser/iser_verbs.c
index 4cafd44ad193..a1cfddbd34ec 100644
--- a/drivers/infiniband/ulp/iser/iser_verbs.c
+++ b/drivers/infiniband/ulp/iser/iser_verbs.c
@@ -1207,7 +1207,7 @@ static void iser_cq_callback(struct ib_cq *cq, void *cq_context)
 u8 iser_check_task_pi_status(struct iscsi_iser_task *iser_task,
 			     enum iser_data_dir cmd_dir, sector_t *sector)
 {
-	struct iser_mem_reg *reg = &iser_task->rdma_regd[cmd_dir].reg;
+	struct iser_mem_reg *reg = &iser_task->rdma_reg[cmd_dir];
 	struct fast_reg_descriptor *desc = reg->mem_h;
 	unsigned long sector_size = iser_task->sc->device->sector_size;
 	struct ib_mr_status mr_status;
