xfs: convert dir byte/off conversion to xfs_da_geometry

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit 9b3b5522d3f55215ce51c87b0467926c57a6f182
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/9b3b5522.failed

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>


(cherry picked from commit 9b3b5522d3f55215ce51c87b0467926c57a6f182)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_dir2_priv.h
diff --cc fs/xfs/xfs_dir2_priv.h
index f3dfbc996c43,683828942de1..000000000000
--- a/fs/xfs/xfs_dir2_priv.h
+++ b/fs/xfs/xfs_dir2_priv.h
@@@ -20,6 -20,143 +20,146 @@@
  
  struct dir_context;
  
++<<<<<<< HEAD
++=======
+ /*
+  * Directory offset/block conversion functions.
+  *
+  * DB blocks here are logical directory block numbers, not filesystem blocks.
+  */
+ 
+ /*
+  * Convert dataptr to byte in file space
+  */
+ static inline xfs_dir2_off_t
+ xfs_dir2_dataptr_to_byte(xfs_dir2_dataptr_t dp)
+ {
+ 	return (xfs_dir2_off_t)dp << XFS_DIR2_DATA_ALIGN_LOG;
+ }
+ 
+ /*
+  * Convert byte in file space to dataptr.  It had better be aligned.
+  */
+ static inline xfs_dir2_dataptr_t
+ xfs_dir2_byte_to_dataptr(xfs_dir2_off_t by)
+ {
+ 	return (xfs_dir2_dataptr_t)(by >> XFS_DIR2_DATA_ALIGN_LOG);
+ }
+ 
+ /*
+  * Convert byte in space to (DB) block
+  */
+ static inline xfs_dir2_db_t
+ xfs_dir2_byte_to_db(struct xfs_mount *mp, xfs_dir2_off_t by)
+ {
+ 	return (xfs_dir2_db_t)
+ 		(by >> (mp->m_sb.sb_blocklog + mp->m_sb.sb_dirblklog));
+ }
+ 
+ /*
+  * Convert dataptr to a block number
+  */
+ static inline xfs_dir2_db_t
+ xfs_dir2_dataptr_to_db(struct xfs_mount *mp, xfs_dir2_dataptr_t dp)
+ {
+ 	return xfs_dir2_byte_to_db(mp, xfs_dir2_dataptr_to_byte(dp));
+ }
+ 
+ /*
+  * Convert byte in space to offset in a block
+  */
+ static inline xfs_dir2_data_aoff_t
+ xfs_dir2_byte_to_off(struct xfs_da_geometry *geo, xfs_dir2_off_t by)
+ {
+ 	return (xfs_dir2_data_aoff_t)(by & (geo->blksize - 1));
+ }
+ 
+ /*
+  * Convert dataptr to a byte offset in a block
+  */
+ static inline xfs_dir2_data_aoff_t
+ xfs_dir2_dataptr_to_off(struct xfs_mount *mp, xfs_dir2_dataptr_t dp)
+ {
+ 	return xfs_dir2_byte_to_off(mp->m_dir_geo, xfs_dir2_dataptr_to_byte(dp));
+ }
+ 
+ /*
+  * Convert block and offset to byte in space
+  */
+ static inline xfs_dir2_off_t
+ xfs_dir2_db_off_to_byte(struct xfs_da_geometry *geo, xfs_dir2_db_t db,
+ 			xfs_dir2_data_aoff_t o)
+ {
+ 	return ((xfs_dir2_off_t)db << geo->blklog) + o;
+ }
+ 
+ /*
+  * Convert block (DB) to block (dablk)
+  */
+ static inline xfs_dablk_t
+ xfs_dir2_db_to_da(struct xfs_mount *mp, xfs_dir2_db_t db)
+ {
+ 	return (xfs_dablk_t)(db << mp->m_sb.sb_dirblklog);
+ }
+ 
+ /*
+  * Convert byte in space to (DA) block
+  */
+ static inline xfs_dablk_t
+ xfs_dir2_byte_to_da(struct xfs_mount *mp, xfs_dir2_off_t by)
+ {
+ 	return xfs_dir2_db_to_da(mp, xfs_dir2_byte_to_db(mp, by));
+ }
+ 
+ /*
+  * Convert block and offset to dataptr
+  */
+ static inline xfs_dir2_dataptr_t
+ xfs_dir2_db_off_to_dataptr(struct xfs_mount *mp, xfs_dir2_db_t db,
+ 			   xfs_dir2_data_aoff_t o)
+ {
+ 	return xfs_dir2_byte_to_dataptr(
+ 				xfs_dir2_db_off_to_byte(mp->m_dir_geo, db, o));
+ }
+ 
+ /*
+  * Convert block (dablk) to block (DB)
+  */
+ static inline xfs_dir2_db_t
+ xfs_dir2_da_to_db(struct xfs_mount *mp, xfs_dablk_t da)
+ {
+ 	return (xfs_dir2_db_t)(da >> mp->m_sb.sb_dirblklog);
+ }
+ 
+ /*
+  * Convert block (dablk) to byte offset in space
+  */
+ static inline xfs_dir2_off_t
+ xfs_dir2_da_to_byte(struct xfs_mount *mp, xfs_dablk_t da)
+ {
+ 	return xfs_dir2_db_off_to_byte(mp->m_dir_geo,
+ 				       xfs_dir2_da_to_db(mp, da), 0);
+ }
+ 
+ /*
+  * Directory tail pointer accessor functions. Based on block geometry.
+  */
+ static inline struct xfs_dir2_block_tail *
+ xfs_dir2_block_tail_p(struct xfs_mount *mp, struct xfs_dir2_data_hdr *hdr)
+ {
+ 	return ((struct xfs_dir2_block_tail *)
+ 		((char *)hdr + mp->m_dirblksize)) - 1;
+ }
+ 
+ static inline struct xfs_dir2_leaf_tail *
+ xfs_dir2_leaf_tail_p(struct xfs_mount *mp, struct xfs_dir2_leaf *lp)
+ {
+ 	return (struct xfs_dir2_leaf_tail *)
+ 		((char *)lp + mp->m_dirblksize -
+ 		  sizeof(struct xfs_dir2_leaf_tail));
+ }
+ 
++>>>>>>> 9b3b5522d3f5 (xfs: convert dir byte/off conversion to xfs_da_geometry)
  /* xfs_dir2.c */
  extern int xfs_dir_ino_validate(struct xfs_mount *mp, xfs_ino_t ino);
  extern int xfs_dir2_grow_inode(struct xfs_da_args *args, int space,
diff --git a/fs/xfs/xfs_dir2.c b/fs/xfs/xfs_dir2.c
index b4210d6721ad..c5dee329b069 100644
--- a/fs/xfs/xfs_dir2.c
+++ b/fs/xfs/xfs_dir2.c
@@ -751,7 +751,7 @@ xfs_dir2_shrink_inode(
 	/*
 	 * If the block isn't the last one in the directory, we're done.
 	 */
-	if (dp->i_d.di_size > xfs_dir2_db_off_to_byte(mp, db + 1, 0))
+	if (dp->i_d.di_size > xfs_dir2_db_off_to_byte(args->geo, db + 1, 0))
 		return 0;
 	bno = da;
 	if ((error = xfs_bmap_last_before(tp, dp, &bno, XFS_DATA_FORK))) {
* Unmerged path fs/xfs/xfs_dir2_priv.h
diff --git a/fs/xfs/xfs_dir2_readdir.c b/fs/xfs/xfs_dir2_readdir.c
index d6645e8c5ecc..c340545c8bb6 100644
--- a/fs/xfs/xfs_dir2_readdir.c
+++ b/fs/xfs/xfs_dir2_readdir.c
@@ -570,7 +570,8 @@ xfs_dir2_leaf_getdents(
 			/*
 			 * Having done a read, we need to set a new offset.
 			 */
-			newoff = xfs_dir2_db_off_to_byte(mp, map_info->curdb, 0);
+			newoff = xfs_dir2_db_off_to_byte(mp->m_dir_geo,
+							 map_info->curdb, 0);
 			/*
 			 * Start of the current block.
 			 */
@@ -588,7 +589,7 @@ xfs_dir2_leaf_getdents(
 			 * Find our position in the block.
 			 */
 			ptr = (char *)dp->d_ops->data_entry_p(hdr);
-			byteoff = xfs_dir2_byte_to_off(mp, curoff);
+			byteoff = xfs_dir2_byte_to_off(mp->m_dir_geo, curoff);
 			/*
 			 * Skip past the header.
 			 */
@@ -617,7 +618,7 @@ xfs_dir2_leaf_getdents(
 				 * Now set our real offset.
 				 */
 				curoff =
-					xfs_dir2_db_off_to_byte(mp,
+					xfs_dir2_db_off_to_byte(mp->m_dir_geo,
 					    xfs_dir2_byte_to_db(mp, curoff),
 					    (char *)ptr - (char *)hdr);
 				if (ptr >= (char *)hdr + mp->m_dirblksize) {
