aacraid: performance improvement changes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Mahesh Rajashekhara <Mahesh.Rajashekhara@pmcs.com>
commit ef6162333a6910007c0ae2237e750ffd5bf25811
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/ef616233.failed

	Signed-off-by: Mahesh Rajashekhara <Mahesh.Rajashekhara@pmcs.com>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Reviewed-by: Murthy Bhat <Murthy.Bhat@pmcs.com>
	Signed-off-by: James Bottomley <JBottomley@Odin.com>
(cherry picked from commit ef6162333a6910007c0ae2237e750ffd5bf25811)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/aacraid/aacraid.h
#	drivers/scsi/aacraid/commsup.c
#	drivers/scsi/aacraid/linit.c
#	drivers/scsi/aacraid/src.c
diff --cc drivers/scsi/aacraid/aacraid.h
index 0b48b47d8620,2ba158b50fa2..000000000000
--- a/drivers/scsi/aacraid/aacraid.h
+++ b/drivers/scsi/aacraid/aacraid.h
@@@ -11,6 -12,55 +11,58 @@@
   *              D E F I N E S
   *----------------------------------------------------------------------------*/
  
++<<<<<<< HEAD
++=======
+ #define AAC_MAX_MSIX		8	/* vectors */
+ #define AAC_PCI_MSI_ENABLE	0x8000
+ 
+ enum {
+ 	AAC_ENABLE_INTERRUPT	= 0x0,
+ 	AAC_DISABLE_INTERRUPT,
+ 	AAC_ENABLE_MSIX,
+ 	AAC_DISABLE_MSIX,
+ 	AAC_CLEAR_AIF_BIT,
+ 	AAC_CLEAR_SYNC_BIT,
+ 	AAC_ENABLE_INTX
+ };
+ 
+ #define AAC_INT_MODE_INTX		(1<<0)
+ #define AAC_INT_MODE_MSI		(1<<1)
+ #define AAC_INT_MODE_AIF		(1<<2)
+ #define AAC_INT_MODE_SYNC		(1<<3)
+ 
+ #define AAC_INT_ENABLE_TYPE1_INTX	0xfffffffb
+ #define AAC_INT_ENABLE_TYPE1_MSIX	0xfffffffa
+ #define AAC_INT_DISABLE_ALL		0xffffffff
+ 
+ /* Bit definitions in IOA->Host Interrupt Register */
+ #define PMC_TRANSITION_TO_OPERATIONAL	(1<<31)
+ #define PMC_IOARCB_TRANSFER_FAILED	(1<<28)
+ #define PMC_IOA_UNIT_CHECK		(1<<27)
+ #define PMC_NO_HOST_RRQ_FOR_CMD_RESPONSE (1<<26)
+ #define PMC_CRITICAL_IOA_OP_IN_PROGRESS	(1<<25)
+ #define PMC_IOARRIN_LOST		(1<<4)
+ #define PMC_SYSTEM_BUS_MMIO_ERROR	(1<<3)
+ #define PMC_IOA_PROCESSOR_IN_ERROR_STATE (1<<2)
+ #define PMC_HOST_RRQ_VALID		(1<<1)
+ #define PMC_OPERATIONAL_STATUS		(1<<31)
+ #define PMC_ALLOW_MSIX_VECTOR0		(1<<0)
+ 
+ #define PMC_IOA_ERROR_INTERRUPTS	(PMC_IOARCB_TRANSFER_FAILED | \
+ 					 PMC_IOA_UNIT_CHECK | \
+ 					 PMC_NO_HOST_RRQ_FOR_CMD_RESPONSE | \
+ 					 PMC_IOARRIN_LOST | \
+ 					 PMC_SYSTEM_BUS_MMIO_ERROR | \
+ 					 PMC_IOA_PROCESSOR_IN_ERROR_STATE)
+ 
+ #define PMC_ALL_INTERRUPT_BITS		(PMC_IOA_ERROR_INTERRUPTS | \
+ 					 PMC_HOST_RRQ_VALID | \
+ 					 PMC_TRANSITION_TO_OPERATIONAL | \
+ 					 PMC_ALLOW_MSIX_VECTOR0)
+ #define	PMC_GLOBAL_INT_BIT2		0x00000004
+ #define	PMC_GLOBAL_INT_BIT0		0x00000001
+ 
++>>>>>>> ef6162333a69 (aacraid: performance improvement changes)
  #ifndef AAC_DRIVER_BUILD
  # define AAC_DRIVER_BUILD 30300
  # define AAC_DRIVER_BRANCH "-ms"
diff --cc drivers/scsi/aacraid/commsup.c
index 090ba681ff36,1a3c0e0068de..000000000000
--- a/drivers/scsi/aacraid/commsup.c
+++ b/drivers/scsi/aacraid/commsup.c
@@@ -1319,7 -1306,33 +1306,37 @@@ static int _aac_reset_adapter(struct aa
  	aac->comm_phys = 0;
  	kfree(aac->queues);
  	aac->queues = NULL;
++<<<<<<< HEAD
 +	free_irq(aac->pdev->irq, aac);
++=======
+ 	cpu = cpumask_first(cpu_online_mask);
+ 	if (aac->pdev->device == PMC_DEVICE_S6 ||
+ 	    aac->pdev->device == PMC_DEVICE_S7 ||
+ 	    aac->pdev->device == PMC_DEVICE_S8 ||
+ 	    aac->pdev->device == PMC_DEVICE_S9) {
+ 		if (aac->max_msix > 1) {
+ 			for (i = 0; i < aac->max_msix; i++) {
+ 				if (irq_set_affinity_hint(
+ 				    aac->msixentry[i].vector,
+ 				    NULL)) {
+ 					printk(KERN_ERR "%s%d: Failed to reset IRQ affinity for cpu %d\n",
+ 						aac->name,
+ 						aac->id,
+ 						cpu);
+ 				}
+ 				cpu = cpumask_next(cpu,
+ 						cpu_online_mask);
+ 				free_irq(aac->msixentry[i].vector,
+ 					 &(aac->aac_msix[i]));
+ 			}
+ 			pci_disable_msix(aac->pdev);
+ 		} else {
+ 			free_irq(aac->pdev->irq, &(aac->aac_msix[0]));
+ 		}
+ 	} else {
+ 		free_irq(aac->pdev->irq, aac);
+ 	}
++>>>>>>> ef6162333a69 (aacraid: performance improvement changes)
  	if (aac->msi)
  		pci_disable_msi(aac->pdev);
  	kfree(aac->fsa_dev);
diff --cc drivers/scsi/aacraid/linit.c
index 74c546b830f7,7bbf1b368aa8..000000000000
--- a/drivers/scsi/aacraid/linit.c
+++ b/drivers/scsi/aacraid/linit.c
@@@ -1154,6 -1072,9 +1142,12 @@@ static struct scsi_host_template aac_dr
  
  static void __aac_shutdown(struct aac_dev * aac)
  {
++<<<<<<< HEAD
++=======
+ 	int i;
+ 	int cpu;
+ 
++>>>>>>> ef6162333a69 (aacraid: performance improvement changes)
  	if (aac->aif_thread) {
  		int i;
  		/* Clear out events first */
@@@ -1167,9 -1088,37 +1161,39 @@@
  	}
  	aac_send_shutdown(aac);
  	aac_adapter_disable_int(aac);
++<<<<<<< HEAD
 +	free_irq(aac->pdev->irq, aac);
++=======
+ 	cpu = cpumask_first(cpu_online_mask);
+ 	if (aac->pdev->device == PMC_DEVICE_S6 ||
+ 	    aac->pdev->device == PMC_DEVICE_S7 ||
+ 	    aac->pdev->device == PMC_DEVICE_S8 ||
+ 	    aac->pdev->device == PMC_DEVICE_S9) {
+ 		if (aac->max_msix > 1) {
+ 			for (i = 0; i < aac->max_msix; i++) {
+ 				if (irq_set_affinity_hint(
+ 				    aac->msixentry[i].vector,
+ 				    NULL)) {
+ 					printk(KERN_ERR "%s%d: Failed to reset IRQ affinity for cpu %d\n",
+ 						aac->name,
+ 						aac->id,
+ 						cpu);
+ 				}
+ 				cpu = cpumask_next(cpu,
+ 						cpu_online_mask);
+ 				free_irq(aac->msixentry[i].vector,
+ 					 &(aac->aac_msix[i]));
+ 			}
+ 		} else {
+ 			free_irq(aac->pdev->irq,
+ 				 &(aac->aac_msix[0]));
+ 		}
+ 	} else {
+ 		free_irq(aac->pdev->irq, aac);
+ 	}
++>>>>>>> ef6162333a69 (aacraid: performance improvement changes)
  	if (aac->msi)
  		pci_disable_msi(aac->pdev);
 -	else if (aac->max_msix > 1)
 -		pci_disable_msix(aac->pdev);
  }
  
  static int aac_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
diff --cc drivers/scsi/aacraid/src.c
index 7e17107643d4,4596e9dd757c..000000000000
--- a/drivers/scsi/aacraid/src.c
+++ b/drivers/scsi/aacraid/src.c
@@@ -396,10 -449,35 +395,8 @@@ static int aac_src_deliver_message(stru
  	struct aac_fib_xporthdr *pFibX;
  	u16 hdr_size = le16_to_cpu(fib->hw_fib_va->header.Size);
  
- 	spin_lock_irqsave(q->lock, qflags);
- 	q->numpending++;
- 	spin_unlock_irqrestore(q->lock, qflags);
+ 	atomic_inc(&q->numpending);
  
 -	if (dev->msi_enabled && fib->hw_fib_va->header.Command != AifRequest &&
 -	    dev->max_msix > 1) {
 -		u_int16_t vector_no, first_choice = 0xffff;
 -
 -		vector_no = dev->fibs_pushed_no % dev->max_msix;
 -		do {
 -			vector_no += 1;
 -			if (vector_no == dev->max_msix)
 -				vector_no = 1;
 -			if (atomic_read(&dev->rrq_outstanding[vector_no]) <
 -			    dev->vector_cap)
 -				break;
 -			if (0xffff == first_choice)
 -				first_choice = vector_no;
 -			else if (vector_no == first_choice)
 -				break;
 -		} while (1);
 -		if (vector_no == first_choice)
 -			vector_no = 0;
 -		atomic_inc(&dev->rrq_outstanding[vector_no]);
 -		if (dev->fibs_pushed_no == 0xffffffff)
 -			dev->fibs_pushed_no = 0;
 -		else
 -			dev->fibs_pushed_no++;
 -		fib->hw_fib_va->header.Handle += (vector_no << 16);
 -	}
 -
  	if (dev->comm_interface == AAC_COMM_MESSAGE_TYPE2) {
  		/* Calculate the amount to the fibsize bits */
  		fibsize = (hdr_size + 127) / 128 - 1;
@@@ -688,7 -789,9 +685,8 @@@ int aac_srcv_init(struct aac_dev *dev
  	unsigned long status;
  	int restart = 0;
  	int instance = dev->id;
 -	int i, j;
  	const char *name = dev->name;
+ 	int cpu;
  
  	dev->a_ops.adapter_ioremap = aac_srcv_ioremap;
  	dev->a_ops.adapter_comm = aac_src_select_comm;
@@@ -802,14 -906,49 +800,60 @@@
  		goto error_iounmap;
  	if (dev->comm_interface != AAC_COMM_MESSAGE_TYPE2)
  		goto error_iounmap;
++<<<<<<< HEAD
 +	dev->msi = aac_msi && !pci_enable_msi(dev->pdev);
 +	if (request_irq(dev->pdev->irq, dev->a_ops.adapter_intr,
 +		IRQF_SHARED|IRQF_DISABLED, "aacraid", dev) < 0) {
 +		if (dev->msi)
 +			pci_disable_msi(dev->pdev);
 +		printk(KERN_ERR "%s%d: Interrupt unavailable.\n",
 +			name, instance);
 +		goto error_iounmap;
++=======
+ 	if (dev->msi_enabled)
+ 		aac_src_access_devreg(dev, AAC_ENABLE_MSIX);
+ 	if (!dev->sync_mode && dev->msi_enabled && dev->max_msix > 1) {
+ 		cpu = cpumask_first(cpu_online_mask);
+ 		for (i = 0; i < dev->max_msix; i++) {
+ 			dev->aac_msix[i].vector_no = i;
+ 			dev->aac_msix[i].dev = dev;
+ 
+ 			if (request_irq(dev->msixentry[i].vector,
+ 					dev->a_ops.adapter_intr,
+ 					0,
+ 					"aacraid",
+ 					&(dev->aac_msix[i]))) {
+ 				printk(KERN_ERR "%s%d: Failed to register IRQ for vector %d.\n",
+ 						name, instance, i);
+ 				for (j = 0 ; j < i ; j++)
+ 					free_irq(dev->msixentry[j].vector,
+ 						 &(dev->aac_msix[j]));
+ 				pci_disable_msix(dev->pdev);
+ 				goto error_iounmap;
+ 			}
+ 			if (irq_set_affinity_hint(
+ 			   dev->msixentry[i].vector,
+ 			   get_cpu_mask(cpu))) {
+ 				printk(KERN_ERR "%s%d: Failed to set IRQ affinity for cpu %d\n",
+ 						name, instance, cpu);
+ 			}
+ 			cpu = cpumask_next(cpu, cpu_online_mask);
+ 		}
+ 	} else {
+ 		dev->aac_msix[0].vector_no = 0;
+ 		dev->aac_msix[0].dev = dev;
+ 
+ 		if (request_irq(dev->pdev->irq, dev->a_ops.adapter_intr,
+ 				IRQF_SHARED,
+ 				"aacraid",
+ 				&(dev->aac_msix[0])) < 0) {
+ 			if (dev->msi)
+ 				pci_disable_msi(dev->pdev);
+ 			printk(KERN_ERR "%s%d: Interrupt unavailable.\n",
+ 					name, instance);
+ 			goto error_iounmap;
+ 		}
++>>>>>>> ef6162333a69 (aacraid: performance improvement changes)
  	}
  	dev->dbg_base = dev->base_start;
  	dev->dbg_base_mapped = dev->base;
* Unmerged path drivers/scsi/aacraid/aacraid.h
diff --git a/drivers/scsi/aacraid/comminit.c b/drivers/scsi/aacraid/comminit.c
index 177b094c7792..c220a7e9944d 100644
--- a/drivers/scsi/aacraid/comminit.c
+++ b/drivers/scsi/aacraid/comminit.c
@@ -51,7 +51,7 @@ static int aac_alloc_comm(struct aac_dev *dev, void **commaddr, unsigned long co
 {
 	unsigned char *base;
 	unsigned long size, align;
-	const unsigned long fibsize = 4096;
+	const unsigned long fibsize = dev->max_fib_size;
 	const unsigned long printfbufsiz = 256;
 	unsigned long host_rrq_size = 0;
 	struct aac_init *init;
@@ -179,7 +179,7 @@ static int aac_alloc_comm(struct aac_dev *dev, void **commaddr, unsigned long co
     
 static void aac_queue_init(struct aac_dev * dev, struct aac_queue * q, u32 *mem, int qsize)
 {
-	q->numpending = 0;
+	atomic_set(&q->numpending, 0);
 	q->dev = dev;
 	init_waitqueue_head(&q->cmdready);
 	INIT_LIST_HEAD(&q->cmdq);
* Unmerged path drivers/scsi/aacraid/commsup.c
diff --git a/drivers/scsi/aacraid/dpcsup.c b/drivers/scsi/aacraid/dpcsup.c
index d81b2810f0f7..65b877fe970f 100644
--- a/drivers/scsi/aacraid/dpcsup.c
+++ b/drivers/scsi/aacraid/dpcsup.c
@@ -84,7 +84,7 @@ unsigned int aac_response_normal(struct aac_queue * q)
 		 *	continue. The caller has already been notified that
 		 *	the fib timed out.
 		 */
-		dev->queues->queue[AdapNormCmdQueue].numpending--;
+		atomic_dec(&dev->queues->queue[AdapNormCmdQueue].numpending);
 
 		if (unlikely(fib->flags & FIB_CONTEXT_FLAG_TIMED_OUT)) {
 			spin_unlock_irqrestore(q->lock, flags);
@@ -354,7 +354,7 @@ unsigned int aac_intr_normal(struct aac_dev *dev, u32 index,
 		 *	continue. The caller has already been notified that
 		 *	the fib timed out.
 		 */
-		dev->queues->queue[AdapNormCmdQueue].numpending--;
+		atomic_dec(&dev->queues->queue[AdapNormCmdQueue].numpending);
 
 		if (unlikely(fib->flags & FIB_CONTEXT_FLAG_TIMED_OUT)) {
 			aac_fib_complete(fib);
* Unmerged path drivers/scsi/aacraid/linit.c
diff --git a/drivers/scsi/aacraid/rx.c b/drivers/scsi/aacraid/rx.c
index bb9917c57760..59972b0dbc12 100644
--- a/drivers/scsi/aacraid/rx.c
+++ b/drivers/scsi/aacraid/rx.c
@@ -400,16 +400,13 @@ int aac_rx_deliver_producer(struct fib * fib)
 {
 	struct aac_dev *dev = fib->dev;
 	struct aac_queue *q = &dev->queues->queue[AdapNormCmdQueue];
-	unsigned long qflags;
 	u32 Index;
 	unsigned long nointr = 0;
 
-	spin_lock_irqsave(q->lock, qflags);
 	aac_queue_get( dev, &Index, AdapNormCmdQueue, fib->hw_fib_va, 1, fib, &nointr);
 
-	q->numpending++;
+	atomic_inc(&q->numpending);
 	*(q->headers.producer) = cpu_to_le32(Index + 1);
-	spin_unlock_irqrestore(q->lock, qflags);
 	if (!(nointr & aac_config.irq_mod))
 		aac_adapter_notify(dev, AdapNormCmdQueue);
 
@@ -426,15 +423,12 @@ static int aac_rx_deliver_message(struct fib * fib)
 {
 	struct aac_dev *dev = fib->dev;
 	struct aac_queue *q = &dev->queues->queue[AdapNormCmdQueue];
-	unsigned long qflags;
 	u32 Index;
 	u64 addr;
 	volatile void __iomem *device;
 
 	unsigned long count = 10000000L; /* 50 seconds */
-	spin_lock_irqsave(q->lock, qflags);
-	q->numpending++;
-	spin_unlock_irqrestore(q->lock, qflags);
+	atomic_inc(&q->numpending);
 	for(;;) {
 		Index = rx_readl(dev, MUnit.InboundQueue);
 		if (unlikely(Index == 0xFFFFFFFFL))
@@ -442,9 +436,7 @@ static int aac_rx_deliver_message(struct fib * fib)
 		if (likely(Index != 0xFFFFFFFFL))
 			break;
 		if (--count == 0) {
-			spin_lock_irqsave(q->lock, qflags);
-			q->numpending--;
-			spin_unlock_irqrestore(q->lock, qflags);
+			atomic_dec(&q->numpending);
 			return -ETIMEDOUT;
 		}
 		udelay(5);
* Unmerged path drivers/scsi/aacraid/src.c
