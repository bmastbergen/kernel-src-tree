block: remove blk_init_flush() and its pair

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [block] remove blk_init_flush() and its pair (Jeff Moyer) [1209624]
Rebuild_FUZZ: 91.14%
commit-author Ming Lei <ming.lei@canonical.com>
commit ba483388e3058b3e412632a84e6bf1f134beaf3d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/ba483388.failed

Now mission of the two helpers is over, and just call
blk_alloc_flush_queue() and blk_free_flush_queue() directly.

	Signed-off-by: Ming Lei <ming.lei@canonical.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit ba483388e3058b3e412632a84e6bf1f134beaf3d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-core.c
#	block/blk-flush.c
#	block/blk-mq.c
#	block/blk-sysfs.c
#	block/blk.h
diff --cc block/blk-core.c
index 6c8ecd3370db,dba0a8350807..000000000000
--- a/block/blk-core.c
+++ b/block/blk-core.c
@@@ -708,8 -704,8 +708,13 @@@ blk_init_allocated_queue(struct request
  	if (!q)
  		return NULL;
  
++<<<<<<< HEAD
 +	q->flush_rq = kzalloc(sizeof(struct request), GFP_KERNEL);
 +	if (!q->flush_rq)
++=======
+ 	q->fq = blk_alloc_flush_queue(q);
+ 	if (!q->fq)
++>>>>>>> ba483388e305 (block: remove blk_init_flush() and its pair)
  		return NULL;
  
  	if (blk_init_rl(&q->root_rl, q, GFP_KERNEL))
@@@ -745,7 -741,7 +750,11 @@@
  	return q;
  
  fail:
++<<<<<<< HEAD
 +	kfree(q->flush_rq);
++=======
+ 	blk_free_flush_queue(q->fq);
++>>>>>>> ba483388e305 (block: remove blk_init_flush() and its pair)
  	return NULL;
  }
  EXPORT_SYMBOL(blk_init_allocated_queue);
diff --cc block/blk-flush.c
index 4ba98aaf2ce6,d66cbf2b2bc8..000000000000
--- a/block/blk-flush.c
+++ b/block/blk-flush.c
@@@ -490,16 -479,43 +490,53 @@@ int blkdev_issue_flush(struct block_dev
  }
  EXPORT_SYMBOL(blkdev_issue_flush);
  
++<<<<<<< HEAD
 +int blk_mq_init_flush(struct request_queue *q)
++=======
+ struct blk_flush_queue *blk_alloc_flush_queue(struct request_queue *q)
++>>>>>>> ba483388e305 (block: remove blk_init_flush() and its pair)
  {
 -	struct blk_flush_queue *fq;
 -	int rq_sz = sizeof(struct request);
 -
 -	fq = kzalloc(sizeof(*fq), GFP_KERNEL);
 -	if (!fq)
 -		goto fail;
 -
 +	struct blk_mq_tag_set *set = q->tag_set;
 +
 +	spin_lock_init(&q->mq_flush_lock);
 +
++<<<<<<< HEAD
 +	q->flush_rq = kzalloc(round_up(sizeof(struct request) +
 +				set->cmd_size, cache_line_size()),
 +				GFP_KERNEL);
 +	if (!q->flush_rq)
 +		return -ENOMEM;
 +	return 0;
++=======
+ 	if (q->mq_ops) {
+ 		spin_lock_init(&fq->mq_flush_lock);
+ 		rq_sz = round_up(rq_sz + q->tag_set->cmd_size,
+ 				cache_line_size());
+ 	}
+ 
+ 	fq->flush_rq = kzalloc(rq_sz, GFP_KERNEL);
+ 	if (!fq->flush_rq)
+ 		goto fail_rq;
+ 
+ 	INIT_LIST_HEAD(&fq->flush_queue[0]);
+ 	INIT_LIST_HEAD(&fq->flush_queue[1]);
+ 	INIT_LIST_HEAD(&fq->flush_data_in_flight);
+ 
+ 	return fq;
+ 
+  fail_rq:
+ 	kfree(fq);
+  fail:
+ 	return NULL;
+ }
+ 
+ void blk_free_flush_queue(struct blk_flush_queue *fq)
+ {
+ 	/* bio based request queue hasn't flush queue */
+ 	if (!fq)
+ 		return;
+ 
+ 	kfree(fq->flush_rq);
+ 	kfree(fq);
++>>>>>>> ba483388e305 (block: remove blk_init_flush() and its pair)
  }
diff --cc block/blk-mq.c
index 77afc91943c8,59ca79634cb9..000000000000
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@@ -1863,7 -1861,8 +1863,12 @@@ struct request_queue *blk_mq_init_queue
  
  	blk_mq_add_queue_tag_set(set, q);
  
++<<<<<<< HEAD
 +	if (blk_mq_init_flush(q))
++=======
+ 	q->fq = blk_alloc_flush_queue(q);
+ 	if (!q->fq)
++>>>>>>> ba483388e305 (block: remove blk_init_flush() and its pair)
  		goto err_hw_queues;
  
  	blk_mq_map_swqueue(q);
diff --cc block/blk-sysfs.c
index 10d2058fed92,718cffc4c678..000000000000
--- a/block/blk-sysfs.c
+++ b/block/blk-sysfs.c
@@@ -548,7 -517,10 +548,14 @@@ static void blk_release_queue(struct ko
  	if (q->queue_tags)
  		__blk_queue_free_tags(q);
  
++<<<<<<< HEAD
 +	kfree(q->flush_rq);
++=======
+ 	blk_free_flush_queue(q->fq);
+ 
+ 	if (q->mq_ops)
+ 		blk_mq_free_queue(q);
++>>>>>>> ba483388e305 (block: remove blk_init_flush() and its pair)
  
  	blk_trace_shutdown(q);
  
diff --cc block/blk.h
index e515a285d4c9,9eaa6e91b13f..000000000000
--- a/block/blk.h
+++ b/block/blk.h
@@@ -22,6 -39,9 +22,12 @@@ static inline void __blk_get_queue(stru
  	kobject_get(&q->kobj);
  }
  
++<<<<<<< HEAD
++=======
+ struct blk_flush_queue *blk_alloc_flush_queue(struct request_queue *q);
+ void blk_free_flush_queue(struct blk_flush_queue *fq);
+ 
++>>>>>>> ba483388e305 (block: remove blk_init_flush() and its pair)
  int blk_init_rl(struct request_list *rl, struct request_queue *q,
  		gfp_t gfp_mask);
  void blk_exit_rl(struct request_list *rl);
* Unmerged path block/blk-core.c
* Unmerged path block/blk-flush.c
* Unmerged path block/blk-mq.c
* Unmerged path block/blk-sysfs.c
* Unmerged path block/blk.h
