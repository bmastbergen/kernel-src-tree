assorted conversions to %p[dD]

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [misc] assorted conversions to p[dD] (Steve Best) [1182052]
Rebuild_FUZZ: 98.31%
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit a455589f181e60439c736c6c6a068bb7e6dc23f0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/a455589f.failed

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit a455589f181e60439c736c6c6a068bb7e6dc23f0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/hypfs/hypfs_dbfs.c
#	drivers/gpu/drm/armada/armada_gem.c
#	drivers/s390/char/hmcdrv_dev.c
#	fs/affs/inode.c
#	fs/affs/namei.c
#	fs/afs/dir.c
#	fs/autofs4/expire.c
#	fs/autofs4/root.c
#	fs/befs/linuxvfs.c
#	fs/cachefiles/xattr.c
#	fs/ceph/dir.c
#	fs/fuse/file.c
#	security/smack/smack_lsm.c
diff --cc arch/s390/hypfs/hypfs_dbfs.c
index bb5dd496614f,47fe1055c714..000000000000
--- a/arch/s390/hypfs/hypfs_dbfs.c
+++ b/arch/s390/hypfs/hypfs_dbfs.c
@@@ -81,6 -81,20 +81,23 @@@ static ssize_t dbfs_read(struct file *f
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ static long dbfs_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+ {
+ 	struct hypfs_dbfs_file *df = file_inode(file)->i_private;
+ 	long rc;
+ 
+ 	mutex_lock(&df->lock);
+ 	if (df->unlocked_ioctl)
+ 		rc = df->unlocked_ioctl(file, cmd, arg);
+ 	else
+ 		rc = -ENOTTY;
+ 	mutex_unlock(&df->lock);
+ 	return rc;
+ }
+ 
++>>>>>>> a455589f181e (assorted conversions to %p[dD])
  static const struct file_operations dbfs_ops = {
  	.read		= dbfs_read,
  	.llseek		= no_llseek,
diff --cc fs/affs/inode.c
index 96df91e8c334,d0609a282e1d..000000000000
--- a/fs/affs/inode.c
+++ b/fs/affs/inode.c
@@@ -350,8 -348,9 +350,14 @@@ affs_add_entry(struct inode *dir, struc
  	u32 block = 0;
  	int retval;
  
++<<<<<<< HEAD
 +	pr_debug("AFFS: add_entry(dir=%u, inode=%u, \"%*s\", type=%d)\n", (u32)dir->i_ino,
 +	         (u32)inode->i_ino, (int)dentry->d_name.len, dentry->d_name.name, type);
++=======
+ 	pr_debug("%s(dir=%u, inode=%u, \"%pd\", type=%d)\n",
+ 		 __func__, (u32)dir->i_ino,
+ 	         (u32)inode->i_ino, dentry, type);
++>>>>>>> a455589f181e (assorted conversions to %p[dD])
  
  	retval = -EIO;
  	bh = affs_bread(sb, inode->i_ino);
diff --cc fs/affs/namei.c
index c36cbb4537a2,bbc38530e924..000000000000
--- a/fs/affs/namei.c
+++ b/fs/affs/namei.c
@@@ -179,7 -190,7 +179,11 @@@ affs_find_entry(struct inode *dir, stru
  	toupper_t toupper = affs_get_toupper(sb);
  	u32 key;
  
++<<<<<<< HEAD
 +	pr_debug("AFFS: find_entry(\"%.*s\")\n", (int)dentry->d_name.len, dentry->d_name.name);
++=======
+ 	pr_debug("%s(\"%pd\")\n", __func__, dentry);
++>>>>>>> a455589f181e (assorted conversions to %p[dD])
  
  	bh = affs_bread(sb, dir->i_ino);
  	if (!bh)
@@@ -207,7 -218,7 +211,11 @@@ affs_lookup(struct inode *dir, struct d
  	struct buffer_head *bh;
  	struct inode *inode = NULL;
  
++<<<<<<< HEAD
 +	pr_debug("AFFS: lookup(\"%.*s\")\n",(int)dentry->d_name.len,dentry->d_name.name);
++=======
+ 	pr_debug("%s(\"%pd\")\n", __func__, dentry);
++>>>>>>> a455589f181e (assorted conversions to %p[dD])
  
  	affs_lock_dir(dir);
  	bh = affs_find_entry(dir, dentry);
@@@ -237,9 -248,9 +245,15 @@@
  int
  affs_unlink(struct inode *dir, struct dentry *dentry)
  {
++<<<<<<< HEAD
 +	pr_debug("AFFS: unlink(dir=%d, %lu \"%.*s\")\n", (u32)dir->i_ino,
 +		 dentry->d_inode->i_ino,
 +		 (int)dentry->d_name.len, dentry->d_name.name);
++=======
+ 	pr_debug("%s(dir=%d, %lu \"%pd\")\n",
+ 		 __func__, (u32)dir->i_ino, dentry->d_inode->i_ino,
+ 		dentry);
++>>>>>>> a455589f181e (assorted conversions to %p[dD])
  
  	return affs_remove_header(dentry);
  }
@@@ -251,8 -262,8 +265,13 @@@ affs_create(struct inode *dir, struct d
  	struct inode	*inode;
  	int		 error;
  
++<<<<<<< HEAD
 +	pr_debug("AFFS: create(%lu,\"%.*s\",0%ho)\n",dir->i_ino,(int)dentry->d_name.len,
 +		 dentry->d_name.name,mode);
++=======
+ 	pr_debug("%s(%lu,\"%pd\",0%ho)\n",
+ 		 __func__, dir->i_ino, dentry, mode);
++>>>>>>> a455589f181e (assorted conversions to %p[dD])
  
  	inode = affs_new_inode(dir);
  	if (!inode)
@@@ -280,8 -291,8 +299,13 @@@ affs_mkdir(struct inode *dir, struct de
  	struct inode		*inode;
  	int			 error;
  
++<<<<<<< HEAD
 +	pr_debug("AFFS: mkdir(%lu,\"%.*s\",0%ho)\n",dir->i_ino,
 +		 (int)dentry->d_name.len,dentry->d_name.name,mode);
++=======
+ 	pr_debug("%s(%lu,\"%pd\",0%ho)\n",
+ 		 __func__, dir->i_ino, dentry, mode);
++>>>>>>> a455589f181e (assorted conversions to %p[dD])
  
  	inode = affs_new_inode(dir);
  	if (!inode)
@@@ -306,9 -317,9 +330,15 @@@
  int
  affs_rmdir(struct inode *dir, struct dentry *dentry)
  {
++<<<<<<< HEAD
 +	pr_debug("AFFS: rmdir(dir=%u, %lu \"%.*s\")\n", (u32)dir->i_ino,
 +		 dentry->d_inode->i_ino,
 +		 (int)dentry->d_name.len, dentry->d_name.name);
++=======
+ 	pr_debug("%s(dir=%u, %lu \"%pd\")\n",
+ 		__func__, (u32)dir->i_ino, dentry->d_inode->i_ino,
+ 		 dentry);
++>>>>>>> a455589f181e (assorted conversions to %p[dD])
  
  	return affs_remove_header(dentry);
  }
@@@ -323,8 -334,8 +353,13 @@@ affs_symlink(struct inode *dir, struct 
  	int			 i, maxlen, error;
  	char			 c, lc;
  
++<<<<<<< HEAD
 +	pr_debug("AFFS: symlink(%lu,\"%.*s\" -> \"%s\")\n",dir->i_ino,
 +		 (int)dentry->d_name.len,dentry->d_name.name,symname);
++=======
+ 	pr_debug("%s(%lu,\"%pd\" -> \"%s\")\n",
+ 		 __func__, dir->i_ino, dentry, symname);
++>>>>>>> a455589f181e (assorted conversions to %p[dD])
  
  	maxlen = AFFS_SB(sb)->s_hashsize * sizeof(u32) - 1;
  	inode  = affs_new_inode(dir);
@@@ -393,8 -404,9 +428,14 @@@ affs_link(struct dentry *old_dentry, st
  {
  	struct inode *inode = old_dentry->d_inode;
  
++<<<<<<< HEAD
 +	pr_debug("AFFS: link(%u, %u, \"%.*s\")\n", (u32)inode->i_ino, (u32)dir->i_ino,
 +		 (int)dentry->d_name.len,dentry->d_name.name);
++=======
+ 	pr_debug("%s(%u, %u, \"%pd\")\n",
+ 		 __func__, (u32)inode->i_ino, (u32)dir->i_ino,
+ 		 dentry);
++>>>>>>> a455589f181e (assorted conversions to %p[dD])
  
  	return affs_add_entry(dir, inode, dentry, ST_LINKFILE);
  }
@@@ -407,11 -419,14 +448,21 @@@ affs_rename(struct inode *old_dir, stru
  	struct buffer_head *bh = NULL;
  	int retval;
  
++<<<<<<< HEAD
 +	pr_debug("AFFS: rename(old=%u,\"%*s\" to new=%u,\"%*s\")\n",
 +		 (u32)old_dir->i_ino, (int)old_dentry->d_name.len, old_dentry->d_name.name,
 +		 (u32)new_dir->i_ino, (int)new_dentry->d_name.len, new_dentry->d_name.name);
++=======
+ 	pr_debug("%s(old=%u,\"%pd\" to new=%u,\"%pd\")\n",
+ 		 __func__, (u32)old_dir->i_ino, old_dentry,
+ 		 (u32)new_dir->i_ino, new_dentry);
+ 
+ 	retval = affs_check_name(new_dentry->d_name.name,
+ 				 new_dentry->d_name.len,
+ 				 affs_nofilenametruncate(old_dentry));
++>>>>>>> a455589f181e (assorted conversions to %p[dD])
  
 +	retval = affs_check_name(new_dentry->d_name.name,new_dentry->d_name.len);
  	if (retval)
  		return retval;
  
diff --cc fs/afs/dir.c
index 7a465ed04444,4ec35e9130e1..000000000000
--- a/fs/afs/dir.c
+++ b/fs/afs/dir.c
@@@ -444,24 -426,18 +444,24 @@@ static int afs_lookup_filldir(void *_co
  static int afs_do_lookup(struct inode *dir, struct dentry *dentry,
  			 struct afs_fid *fid, struct key *key)
  {
 -	struct afs_super_info *as = dir->i_sb->s_fs_info;
 -	struct afs_lookup_cookie cookie = {
 -		.ctx.actor = afs_lookup_filldir,
 -		.name = dentry->d_name,
 -		.fid.vid = as->volume->vid
 -	};
 +	struct afs_lookup_cookie cookie;
 +	struct afs_super_info *as;
 +	unsigned fpos;
  	int ret;
  
- 	_enter("{%lu},%p{%s},", dir->i_ino, dentry, dentry->d_name.name);
+ 	_enter("{%lu},%p{%pd},", dir->i_ino, dentry, dentry);
  
 +	as = dir->i_sb->s_fs_info;
 +
  	/* search the directory */
 -	ret = afs_dir_iterate(dir, &cookie.ctx, key);
 +	cookie.name	= dentry->d_name.name;
 +	cookie.nlen	= dentry->d_name.len;
 +	cookie.fid.vid	= as->volume->vid;
 +	cookie.found	= 0;
 +
 +	fpos = 0;
 +	ret = afs_dir_iterate(dir, &fpos, &cookie, afs_lookup_filldir,
 +			      key);
  	if (ret < 0) {
  		_leave(" = %d [iter]", ret);
  		return ret;
@@@ -710,16 -682,7 +710,20 @@@ not_found
  	spin_unlock(&dentry->d_lock);
  
  out_bad:
++<<<<<<< HEAD
 +	if (dentry->d_inode) {
 +		/* don't unhash if we have submounts */
 +		if (have_submounts(dentry))
 +			goto out_skip;
 +	}
 +
 +	_debug("dropping dentry %s/%s",
 +	       parent->d_name.name, dentry->d_name.name);
 +	shrink_dcache_parent(dentry);
 +	d_drop(dentry);
++=======
+ 	_debug("dropping dentry %pd2", dentry);
++>>>>>>> a455589f181e (assorted conversions to %p[dD])
  	dput(parent);
  	key_put(key);
  
@@@ -777,13 -740,9 +781,13 @@@ static int afs_mkdir(struct inode *dir
  
  	dvnode = AFS_FS_I(dir);
  
- 	_enter("{%x:%u},{%s},%ho",
- 	       dvnode->fid.vid, dvnode->fid.vnode, dentry->d_name.name, mode);
+ 	_enter("{%x:%u},{%pd},%ho",
+ 	       dvnode->fid.vid, dvnode->fid.vnode, dentry, mode);
  
 +	ret = -ENAMETOOLONG;
 +	if (dentry->d_name.len >= AFSNAMEMAX)
 +		goto error;
 +
  	key = afs_request_key(dvnode->volume->cell);
  	if (IS_ERR(key)) {
  		ret = PTR_ERR(key);
@@@ -842,13 -801,9 +846,13 @@@ static int afs_rmdir(struct inode *dir
  
  	dvnode = AFS_FS_I(dir);
  
- 	_enter("{%x:%u},{%s}",
- 	       dvnode->fid.vid, dvnode->fid.vnode, dentry->d_name.name);
+ 	_enter("{%x:%u},{%pd}",
+ 	       dvnode->fid.vid, dvnode->fid.vnode, dentry);
  
 +	ret = -ENAMETOOLONG;
 +	if (dentry->d_name.len >= AFSNAMEMAX)
 +		goto error;
 +
  	key = afs_request_key(dvnode->volume->cell);
  	if (IS_ERR(key)) {
  		ret = PTR_ERR(key);
@@@ -962,13 -917,9 +966,13 @@@ static int afs_create(struct inode *dir
  
  	dvnode = AFS_FS_I(dir);
  
- 	_enter("{%x:%u},{%s},%ho,",
- 	       dvnode->fid.vid, dvnode->fid.vnode, dentry->d_name.name, mode);
+ 	_enter("{%x:%u},{%pd},%ho,",
+ 	       dvnode->fid.vid, dvnode->fid.vnode, dentry, mode);
  
 +	ret = -ENAMETOOLONG;
 +	if (dentry->d_name.len >= AFSNAMEMAX)
 +		goto error;
 +
  	key = afs_request_key(dvnode->volume->cell);
  	if (IS_ERR(key)) {
  		ret = PTR_ERR(key);
@@@ -1029,15 -980,11 +1033,15 @@@ static int afs_link(struct dentry *from
  	vnode = AFS_FS_I(from->d_inode);
  	dvnode = AFS_FS_I(dir);
  
- 	_enter("{%x:%u},{%x:%u},{%s}",
+ 	_enter("{%x:%u},{%x:%u},{%pd}",
  	       vnode->fid.vid, vnode->fid.vnode,
  	       dvnode->fid.vid, dvnode->fid.vnode,
- 	       dentry->d_name.name);
+ 	       dentry);
  
 +	ret = -ENAMETOOLONG;
 +	if (dentry->d_name.len >= AFSNAMEMAX)
 +		goto error;
 +
  	key = afs_request_key(dvnode->volume->cell);
  	if (IS_ERR(key)) {
  		ret = PTR_ERR(key);
@@@ -1078,14 -1025,10 +1082,14 @@@ static int afs_symlink(struct inode *di
  
  	dvnode = AFS_FS_I(dir);
  
- 	_enter("{%x:%u},{%s},%s",
- 	       dvnode->fid.vid, dvnode->fid.vnode, dentry->d_name.name,
+ 	_enter("{%x:%u},{%pd},%s",
+ 	       dvnode->fid.vid, dvnode->fid.vnode, dentry,
  	       content);
  
 +	ret = -ENAMETOOLONG;
 +	if (dentry->d_name.len >= AFSNAMEMAX)
 +		goto error;
 +
  	ret = -EINVAL;
  	if (strlen(content) >= AFSPATHMAX)
  		goto error;
@@@ -1154,12 -1097,8 +1158,12 @@@ static int afs_rename(struct inode *old
  	       orig_dvnode->fid.vid, orig_dvnode->fid.vnode,
  	       vnode->fid.vid, vnode->fid.vnode,
  	       new_dvnode->fid.vid, new_dvnode->fid.vnode,
- 	       new_dentry->d_name.name);
+ 	       new_dentry);
  
 +	ret = -ENAMETOOLONG;
 +	if (new_dentry->d_name.len >= AFSNAMEMAX)
 +		goto error;
 +
  	key = afs_request_key(orig_dvnode->volume->cell);
  	if (IS_ERR(key)) {
  		ret = PTR_ERR(key);
diff --cc fs/autofs4/expire.c
index 394e90b02c5e,bfdbaba9c2ba..000000000000
--- a/fs/autofs4/expire.c
+++ b/fs/autofs4/expire.c
@@@ -346,6 -336,87 +340,90 @@@ out
  	return NULL;
  }
  
++<<<<<<< HEAD
++=======
+ /* Check if 'dentry' should expire, or return a nearby
+  * dentry that is suitable.
+  * If returned dentry is different from arg dentry,
+  * then a dget() reference was taken, else not.
+  */
+ static struct dentry *should_expire(struct dentry *dentry,
+ 				    struct vfsmount *mnt,
+ 				    unsigned long timeout,
+ 				    int how)
+ {
+ 	int do_now = how & AUTOFS_EXP_IMMEDIATE;
+ 	int exp_leaves = how & AUTOFS_EXP_LEAVES;
+ 	struct autofs_info *ino = autofs4_dentry_ino(dentry);
+ 	unsigned int ino_count;
+ 
+ 	/* No point expiring a pending mount */
+ 	if (ino->flags & AUTOFS_INF_PENDING)
+ 		return NULL;
+ 
+ 	/*
+ 	 * Case 1: (i) indirect mount or top level pseudo direct mount
+ 	 *	   (autofs-4.1).
+ 	 *	   (ii) indirect mount with offset mount, check the "/"
+ 	 *	   offset (autofs-5.0+).
+ 	 */
+ 	if (d_mountpoint(dentry)) {
+ 		DPRINTK("checking mountpoint %p %pd", dentry, dentry);
+ 
+ 		/* Can we umount this guy */
+ 		if (autofs4_mount_busy(mnt, dentry))
+ 			return NULL;
+ 
+ 		/* Can we expire this guy */
+ 		if (autofs4_can_expire(dentry, timeout, do_now))
+ 			return dentry;
+ 		return NULL;
+ 	}
+ 
+ 	if (dentry->d_inode && S_ISLNK(dentry->d_inode->i_mode)) {
+ 		DPRINTK("checking symlink %p %pd", dentry, dentry);
+ 		/*
+ 		 * A symlink can't be "busy" in the usual sense so
+ 		 * just check last used for expire timeout.
+ 		 */
+ 		if (autofs4_can_expire(dentry, timeout, do_now))
+ 			return dentry;
+ 		return NULL;
+ 	}
+ 
+ 	if (simple_empty(dentry))
+ 		return NULL;
+ 
+ 	/* Case 2: tree mount, expire iff entire tree is not busy */
+ 	if (!exp_leaves) {
+ 		/* Path walk currently on this dentry? */
+ 		ino_count = atomic_read(&ino->count) + 1;
+ 		if (d_count(dentry) > ino_count)
+ 			return NULL;
+ 
+ 		if (!autofs4_tree_busy(mnt, dentry, timeout, do_now))
+ 			return dentry;
+ 	/*
+ 	 * Case 3: pseudo direct mount, expire individual leaves
+ 	 *	   (autofs-4.1).
+ 	 */
+ 	} else {
+ 		/* Path walk currently on this dentry? */
+ 		struct dentry *expired;
+ 		ino_count = atomic_read(&ino->count) + 1;
+ 		if (d_count(dentry) > ino_count)
+ 			return NULL;
+ 
+ 		expired = autofs4_check_leaves(mnt, dentry, timeout, do_now);
+ 		if (expired) {
+ 			if (expired == dentry)
+ 				dput(dentry);
+ 			return expired;
+ 		}
+ 	}
+ 	return NULL;
+ }
++>>>>>>> a455589f181e (assorted conversions to %p[dD])
  /*
   * Find an eligible tree to time-out
   * A tree is eligible if :-
@@@ -452,10 -471,10 +530,14 @@@ next
  	return NULL;
  
  found:
++<<<<<<< HEAD
 +	DPRINTK("returning %p %.*s",
 +		expired, (int)expired->d_name.len, expired->d_name.name);
 +	ino = autofs4_dentry_ino(expired);
++=======
+ 	DPRINTK("returning %p %pd", expired, expired);
++>>>>>>> a455589f181e (assorted conversions to %p[dD])
  	ino->flags |= AUTOFS_INF_EXPIRING;
 -	smp_mb();
 -	ino->flags &= ~AUTOFS_INF_NO_RCU;
  	init_completion(&ino->expire_complete);
  	spin_unlock(&sbi->fs_lock);
  	spin_lock(&sbi->lookup_lock);
diff --cc fs/autofs4/root.c
index 22bfeaf10e21,dbb5b7212ce1..000000000000
--- a/fs/autofs4/root.c
+++ b/fs/autofs4/root.c
@@@ -267,8 -276,9 +266,14 @@@ static int autofs4_mount_wait(struct de
  	int status = 0;
  
  	if (ino->flags & AUTOFS_INF_PENDING) {
++<<<<<<< HEAD
 +		DPRINTK("waiting for mount name=%.*s",
 +			dentry->d_name.len, dentry->d_name.name);
++=======
+ 		if (rcu_walk)
+ 			return -ECHILD;
+ 		DPRINTK("waiting for mount name=%pd", dentry);
++>>>>>>> a455589f181e (assorted conversions to %p[dD])
  		status = autofs4_wait(sbi, dentry, NFY_MOUNT);
  		DPRINTK("mount wait done status=%d", status);
  	}
diff --cc fs/befs/linuxvfs.c
index f95dddced968,b94d1cc9cd30..000000000000
--- a/fs/befs/linuxvfs.c
+++ b/fs/befs/linuxvfs.c
@@@ -171,8 -172,8 +171,13 @@@ befs_lookup(struct inode *dir, struct d
  	char *utfname;
  	const char *name = dentry->d_name.name;
  
++<<<<<<< HEAD
 +	befs_debug(sb, "---> befs_lookup() "
 +		   "name %s inode %ld", dentry->d_name.name, dir->i_ino);
++=======
+ 	befs_debug(sb, "---> %s name %pd inode %ld", __func__,
+ 		   dentry, dir->i_ino);
++>>>>>>> a455589f181e (assorted conversions to %p[dD])
  
  	/* Convert to UTF-8 */
  	if (BEFS_SB(sb)->nls) {
@@@ -190,8 -191,7 +195,12 @@@
  	}
  
  	if (ret == BEFS_BT_NOT_FOUND) {
++<<<<<<< HEAD
 +		befs_debug(sb, "<--- befs_lookup() %s not found",
 +			   dentry->d_name.name);
++=======
+ 		befs_debug(sb, "<--- %s %pd not found", __func__, dentry);
++>>>>>>> a455589f181e (assorted conversions to %p[dD])
  		return ERR_PTR(-ENOENT);
  
  	} else if (ret != BEFS_OK || offset == 0) {
@@@ -221,21 -221,18 +230,33 @@@ befs_readdir(struct file *filp, void *d
  	size_t keysize;
  	unsigned char d_type;
  	char keybuf[BEFS_NAME_LEN + 1];
++<<<<<<< HEAD
 +	char *nlsname;
 +	int nlsnamelen;
 +	const char *dirname = filp->f_path.dentry->d_name.name;
 +
 +	befs_debug(sb, "---> befs_readdir() "
 +		   "name %s, inode %ld, filp->f_pos %Ld",
 +		   dirname, inode->i_ino, filp->f_pos);
++=======
+ 
+ 	befs_debug(sb, "---> %s name %pD, inode %ld, ctx->pos %lld",
+ 		  __func__, file, inode->i_ino, ctx->pos);
++>>>>>>> a455589f181e (assorted conversions to %p[dD])
  
 -more:
 -	result = befs_btree_read(sb, ds, ctx->pos, BEFS_NAME_LEN + 1,
 +	result = befs_btree_read(sb, ds, filp->f_pos, BEFS_NAME_LEN + 1,
  				 keybuf, &keysize, &value);
  
  	if (result == BEFS_ERR) {
++<<<<<<< HEAD
 +		befs_debug(sb, "<--- befs_readdir() ERROR");
 +		befs_error(sb, "IO error reading %s (inode %lu)",
 +			   dirname, inode->i_ino);
++=======
+ 		befs_debug(sb, "<--- %s ERROR", __func__);
+ 		befs_error(sb, "IO error reading %pD (inode %lu)",
+ 			   file, inode->i_ino);
++>>>>>>> a455589f181e (assorted conversions to %p[dD])
  		return -EIO;
  
  	} else if (result == BEFS_BT_END) {
diff --cc fs/cachefiles/xattr.c
index 73b46288b54b,a8a68745e11d..000000000000
--- a/fs/cachefiles/xattr.c
+++ b/fs/cachefiles/xattr.c
@@@ -51,9 -51,8 +51,14 @@@ int cachefiles_check_object_type(struc
  	}
  
  	if (ret != -EEXIST) {
++<<<<<<< HEAD
 +		kerror("Can't set xattr on %*.*s [%lu] (err %d)",
 +		       dentry->d_name.len, dentry->d_name.len,
 +		       dentry->d_name.name, dentry->d_inode->i_ino,
++=======
+ 		pr_err("Can't set xattr on %pd [%lu] (err %d)\n",
+ 		       dentry, dentry->d_inode->i_ino,
++>>>>>>> a455589f181e (assorted conversions to %p[dD])
  		       -ret);
  		goto error;
  	}
@@@ -64,9 -63,8 +69,14 @@@
  		if (ret == -ERANGE)
  			goto bad_type_length;
  
++<<<<<<< HEAD
 +		kerror("Can't read xattr on %*.*s [%lu] (err %d)",
 +		       dentry->d_name.len, dentry->d_name.len,
 +		       dentry->d_name.name, dentry->d_inode->i_ino,
++=======
+ 		pr_err("Can't read xattr on %pd [%lu] (err %d)\n",
+ 		       dentry, dentry->d_inode->i_ino,
++>>>>>>> a455589f181e (assorted conversions to %p[dD])
  		       -ret);
  		goto error;
  	}
@@@ -92,9 -90,8 +102,14 @@@ bad_type_length
  
  bad_type:
  	xtype[2] = 0;
++<<<<<<< HEAD
 +	kerror("Cache object %*.*s [%lu] type %s not %s",
 +	       dentry->d_name.len, dentry->d_name.len,
 +	       dentry->d_name.name, dentry->d_inode->i_ino,
++=======
+ 	pr_err("Cache object %pd [%lu] type %s not %s\n",
+ 	       dentry, dentry->d_inode->i_ino,
++>>>>>>> a455589f181e (assorted conversions to %p[dD])
  	       xtype, type);
  	ret = -EIO;
  	goto error;
diff --cc fs/ceph/dir.c
index 06e9fcd47b87,766ec35f988e..000000000000
--- a/fs/ceph/dir.c
+++ b/fs/ceph/dir.c
@@@ -167,11 -166,11 +167,17 @@@ more
  		    !d_unhashed(dentry) && dentry->d_inode &&
  		    ceph_snap(dentry->d_inode) != CEPH_SNAPDIR &&
  		    ceph_ino(dentry->d_inode) != CEPH_INO_CEPH &&
 -		    fpos_cmp(ctx->pos, di->offset) <= 0)
 +		    fpos_cmp(filp->f_pos, di->offset) <= 0)
  			break;
++<<<<<<< HEAD
 +		dout(" skipping %p %.*s at %llu (%llu)%s%s\n", dentry,
 +		     dentry->d_name.len, dentry->d_name.name, di->offset,
 +		     filp->f_pos, d_unhashed(dentry) ? " unhashed" : "",
++=======
+ 		dout(" skipping %p %pd at %llu (%llu)%s%s\n", dentry,
+ 		     dentry, di->offset,
+ 		     ctx->pos, d_unhashed(dentry) ? " unhashed" : "",
++>>>>>>> a455589f181e (assorted conversions to %p[dD])
  		     !dentry->d_inode ? " null" : "");
  		spin_unlock(&dentry->d_lock);
  		p = p->prev;
@@@ -191,16 -190,13 +197,23 @@@
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	dout(" %llu (%llu) dentry %p %.*s %p\n", di->offset, filp->f_pos,
 +	     dentry, dentry->d_name.len, dentry->d_name.name, dentry->d_inode);
 +	filp->f_pos = di->offset;
 +	err = filldir(dirent, dentry->d_name.name,
 +		      dentry->d_name.len, di->offset,
++=======
+ 	dout(" %llu (%llu) dentry %p %pd %p\n", di->offset, ctx->pos,
+ 	     dentry, dentry, dentry->d_inode);
+ 	if (!dir_emit(ctx, dentry->d_name.name,
+ 		      dentry->d_name.len,
++>>>>>>> a455589f181e (assorted conversions to %p[dD])
  		      ceph_translate_ino(dentry->d_sb, dentry->d_inode->i_ino),
 -		      dentry->d_inode->i_mode >> 12)) {
 -		if (last) {
 +		      dentry->d_inode->i_mode >> 12);
 +
 +	if (last) {
 +		if (err < 0) {
  			/* remember our position */
  			fi->dentry = last;
  			fi->next_offset = fpos_off(di->offset);
diff --cc fs/fuse/file.c
index 4fafb8484bbc,bf50259012ab..000000000000
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@@ -1564,6 -1747,309 +1564,312 @@@ static int fuse_writepage(struct page *
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ struct fuse_fill_wb_data {
+ 	struct fuse_req *req;
+ 	struct fuse_file *ff;
+ 	struct inode *inode;
+ 	struct page **orig_pages;
+ };
+ 
+ static void fuse_writepages_send(struct fuse_fill_wb_data *data)
+ {
+ 	struct fuse_req *req = data->req;
+ 	struct inode *inode = data->inode;
+ 	struct fuse_conn *fc = get_fuse_conn(inode);
+ 	struct fuse_inode *fi = get_fuse_inode(inode);
+ 	int num_pages = req->num_pages;
+ 	int i;
+ 
+ 	req->ff = fuse_file_get(data->ff);
+ 	spin_lock(&fc->lock);
+ 	list_add_tail(&req->list, &fi->queued_writes);
+ 	fuse_flush_writepages(inode);
+ 	spin_unlock(&fc->lock);
+ 
+ 	for (i = 0; i < num_pages; i++)
+ 		end_page_writeback(data->orig_pages[i]);
+ }
+ 
+ static bool fuse_writepage_in_flight(struct fuse_req *new_req,
+ 				     struct page *page)
+ {
+ 	struct fuse_conn *fc = get_fuse_conn(new_req->inode);
+ 	struct fuse_inode *fi = get_fuse_inode(new_req->inode);
+ 	struct fuse_req *tmp;
+ 	struct fuse_req *old_req;
+ 	bool found = false;
+ 	pgoff_t curr_index;
+ 
+ 	BUG_ON(new_req->num_pages != 0);
+ 
+ 	spin_lock(&fc->lock);
+ 	list_del(&new_req->writepages_entry);
+ 	list_for_each_entry(old_req, &fi->writepages, writepages_entry) {
+ 		BUG_ON(old_req->inode != new_req->inode);
+ 		curr_index = old_req->misc.write.in.offset >> PAGE_CACHE_SHIFT;
+ 		if (curr_index <= page->index &&
+ 		    page->index < curr_index + old_req->num_pages) {
+ 			found = true;
+ 			break;
+ 		}
+ 	}
+ 	if (!found) {
+ 		list_add(&new_req->writepages_entry, &fi->writepages);
+ 		goto out_unlock;
+ 	}
+ 
+ 	new_req->num_pages = 1;
+ 	for (tmp = old_req; tmp != NULL; tmp = tmp->misc.write.next) {
+ 		BUG_ON(tmp->inode != new_req->inode);
+ 		curr_index = tmp->misc.write.in.offset >> PAGE_CACHE_SHIFT;
+ 		if (tmp->num_pages == 1 &&
+ 		    curr_index == page->index) {
+ 			old_req = tmp;
+ 		}
+ 	}
+ 
+ 	if (old_req->num_pages == 1 && (old_req->state == FUSE_REQ_INIT ||
+ 					old_req->state == FUSE_REQ_PENDING)) {
+ 		struct backing_dev_info *bdi = page->mapping->backing_dev_info;
+ 
+ 		copy_highpage(old_req->pages[0], page);
+ 		spin_unlock(&fc->lock);
+ 
+ 		dec_bdi_stat(bdi, BDI_WRITEBACK);
+ 		dec_zone_page_state(page, NR_WRITEBACK_TEMP);
+ 		bdi_writeout_inc(bdi);
+ 		fuse_writepage_free(fc, new_req);
+ 		fuse_request_free(new_req);
+ 		goto out;
+ 	} else {
+ 		new_req->misc.write.next = old_req->misc.write.next;
+ 		old_req->misc.write.next = new_req;
+ 	}
+ out_unlock:
+ 	spin_unlock(&fc->lock);
+ out:
+ 	return found;
+ }
+ 
+ static int fuse_writepages_fill(struct page *page,
+ 		struct writeback_control *wbc, void *_data)
+ {
+ 	struct fuse_fill_wb_data *data = _data;
+ 	struct fuse_req *req = data->req;
+ 	struct inode *inode = data->inode;
+ 	struct fuse_conn *fc = get_fuse_conn(inode);
+ 	struct page *tmp_page;
+ 	bool is_writeback;
+ 	int err;
+ 
+ 	if (!data->ff) {
+ 		err = -EIO;
+ 		data->ff = fuse_write_file_get(fc, get_fuse_inode(inode));
+ 		if (!data->ff)
+ 			goto out_unlock;
+ 	}
+ 
+ 	/*
+ 	 * Being under writeback is unlikely but possible.  For example direct
+ 	 * read to an mmaped fuse file will set the page dirty twice; once when
+ 	 * the pages are faulted with get_user_pages(), and then after the read
+ 	 * completed.
+ 	 */
+ 	is_writeback = fuse_page_is_writeback(inode, page->index);
+ 
+ 	if (req && req->num_pages &&
+ 	    (is_writeback || req->num_pages == FUSE_MAX_PAGES_PER_REQ ||
+ 	     (req->num_pages + 1) * PAGE_CACHE_SIZE > fc->max_write ||
+ 	     data->orig_pages[req->num_pages - 1]->index + 1 != page->index)) {
+ 		fuse_writepages_send(data);
+ 		data->req = NULL;
+ 	}
+ 	err = -ENOMEM;
+ 	tmp_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);
+ 	if (!tmp_page)
+ 		goto out_unlock;
+ 
+ 	/*
+ 	 * The page must not be redirtied until the writeout is completed
+ 	 * (i.e. userspace has sent a reply to the write request).  Otherwise
+ 	 * there could be more than one temporary page instance for each real
+ 	 * page.
+ 	 *
+ 	 * This is ensured by holding the page lock in page_mkwrite() while
+ 	 * checking fuse_page_is_writeback().  We already hold the page lock
+ 	 * since clear_page_dirty_for_io() and keep it held until we add the
+ 	 * request to the fi->writepages list and increment req->num_pages.
+ 	 * After this fuse_page_is_writeback() will indicate that the page is
+ 	 * under writeback, so we can release the page lock.
+ 	 */
+ 	if (data->req == NULL) {
+ 		struct fuse_inode *fi = get_fuse_inode(inode);
+ 
+ 		err = -ENOMEM;
+ 		req = fuse_request_alloc_nofs(FUSE_MAX_PAGES_PER_REQ);
+ 		if (!req) {
+ 			__free_page(tmp_page);
+ 			goto out_unlock;
+ 		}
+ 
+ 		fuse_write_fill(req, data->ff, page_offset(page), 0);
+ 		req->misc.write.in.write_flags |= FUSE_WRITE_CACHE;
+ 		req->misc.write.next = NULL;
+ 		req->in.argpages = 1;
+ 		req->background = 1;
+ 		req->num_pages = 0;
+ 		req->end = fuse_writepage_end;
+ 		req->inode = inode;
+ 
+ 		spin_lock(&fc->lock);
+ 		list_add(&req->writepages_entry, &fi->writepages);
+ 		spin_unlock(&fc->lock);
+ 
+ 		data->req = req;
+ 	}
+ 	set_page_writeback(page);
+ 
+ 	copy_highpage(tmp_page, page);
+ 	req->pages[req->num_pages] = tmp_page;
+ 	req->page_descs[req->num_pages].offset = 0;
+ 	req->page_descs[req->num_pages].length = PAGE_SIZE;
+ 
+ 	inc_bdi_stat(page->mapping->backing_dev_info, BDI_WRITEBACK);
+ 	inc_zone_page_state(tmp_page, NR_WRITEBACK_TEMP);
+ 
+ 	err = 0;
+ 	if (is_writeback && fuse_writepage_in_flight(req, page)) {
+ 		end_page_writeback(page);
+ 		data->req = NULL;
+ 		goto out_unlock;
+ 	}
+ 	data->orig_pages[req->num_pages] = page;
+ 
+ 	/*
+ 	 * Protected by fc->lock against concurrent access by
+ 	 * fuse_page_is_writeback().
+ 	 */
+ 	spin_lock(&fc->lock);
+ 	req->num_pages++;
+ 	spin_unlock(&fc->lock);
+ 
+ out_unlock:
+ 	unlock_page(page);
+ 
+ 	return err;
+ }
+ 
+ static int fuse_writepages(struct address_space *mapping,
+ 			   struct writeback_control *wbc)
+ {
+ 	struct inode *inode = mapping->host;
+ 	struct fuse_fill_wb_data data;
+ 	int err;
+ 
+ 	err = -EIO;
+ 	if (is_bad_inode(inode))
+ 		goto out;
+ 
+ 	data.inode = inode;
+ 	data.req = NULL;
+ 	data.ff = NULL;
+ 
+ 	err = -ENOMEM;
+ 	data.orig_pages = kcalloc(FUSE_MAX_PAGES_PER_REQ,
+ 				  sizeof(struct page *),
+ 				  GFP_NOFS);
+ 	if (!data.orig_pages)
+ 		goto out;
+ 
+ 	err = write_cache_pages(mapping, wbc, fuse_writepages_fill, &data);
+ 	if (data.req) {
+ 		/* Ignore errors if we can write at least one page */
+ 		BUG_ON(!data.req->num_pages);
+ 		fuse_writepages_send(&data);
+ 		err = 0;
+ 	}
+ 	if (data.ff)
+ 		fuse_file_put(data.ff, false);
+ 
+ 	kfree(data.orig_pages);
+ out:
+ 	return err;
+ }
+ 
+ /*
+  * It's worthy to make sure that space is reserved on disk for the write,
+  * but how to implement it without killing performance need more thinking.
+  */
+ static int fuse_write_begin(struct file *file, struct address_space *mapping,
+ 		loff_t pos, unsigned len, unsigned flags,
+ 		struct page **pagep, void **fsdata)
+ {
+ 	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
+ 	struct fuse_conn *fc = get_fuse_conn(file_inode(file));
+ 	struct page *page;
+ 	loff_t fsize;
+ 	int err = -ENOMEM;
+ 
+ 	WARN_ON(!fc->writeback_cache);
+ 
+ 	page = grab_cache_page_write_begin(mapping, index, flags);
+ 	if (!page)
+ 		goto error;
+ 
+ 	fuse_wait_on_page_writeback(mapping->host, page->index);
+ 
+ 	if (PageUptodate(page) || len == PAGE_CACHE_SIZE)
+ 		goto success;
+ 	/*
+ 	 * Check if the start this page comes after the end of file, in which
+ 	 * case the readpage can be optimized away.
+ 	 */
+ 	fsize = i_size_read(mapping->host);
+ 	if (fsize <= (pos & PAGE_CACHE_MASK)) {
+ 		size_t off = pos & ~PAGE_CACHE_MASK;
+ 		if (off)
+ 			zero_user_segment(page, 0, off);
+ 		goto success;
+ 	}
+ 	err = fuse_do_readpage(file, page);
+ 	if (err)
+ 		goto cleanup;
+ success:
+ 	*pagep = page;
+ 	return 0;
+ 
+ cleanup:
+ 	unlock_page(page);
+ 	page_cache_release(page);
+ error:
+ 	return err;
+ }
+ 
+ static int fuse_write_end(struct file *file, struct address_space *mapping,
+ 		loff_t pos, unsigned len, unsigned copied,
+ 		struct page *page, void *fsdata)
+ {
+ 	struct inode *inode = page->mapping->host;
+ 
+ 	if (!PageUptodate(page)) {
+ 		/* Zero any unwritten bytes at the end of the page */
+ 		size_t endoff = (pos + copied) & ~PAGE_CACHE_MASK;
+ 		if (endoff)
+ 			zero_user_segment(page, endoff, PAGE_CACHE_SIZE);
+ 		SetPageUptodate(page);
+ 	}
+ 
+ 	fuse_write_update_size(inode, pos + copied);
+ 	set_page_dirty(page);
+ 	unlock_page(page);
+ 	page_cache_release(page);
+ 
+ 	return copied;
+ }
+ 
++>>>>>>> a455589f181e (assorted conversions to %p[dD])
  static int fuse_launder_page(struct page *page)
  {
  	int err = 0;
diff --cc security/smack/smack_lsm.c
index 3af62fbedea0,433ae61e7f42..000000000000
--- a/security/smack/smack_lsm.c
+++ b/security/smack/smack_lsm.c
@@@ -45,6 -48,157 +45,160 @@@
  #define TRANS_TRUE	"TRUE"
  #define TRANS_TRUE_SIZE	4
  
++<<<<<<< HEAD
++=======
+ #define SMK_CONNECTING	0
+ #define SMK_RECEIVING	1
+ #define SMK_SENDING	2
+ 
+ LIST_HEAD(smk_ipv6_port_list);
+ 
+ #ifdef CONFIG_SECURITY_SMACK_BRINGUP
+ static void smk_bu_mode(int mode, char *s)
+ {
+ 	int i = 0;
+ 
+ 	if (mode & MAY_READ)
+ 		s[i++] = 'r';
+ 	if (mode & MAY_WRITE)
+ 		s[i++] = 'w';
+ 	if (mode & MAY_EXEC)
+ 		s[i++] = 'x';
+ 	if (mode & MAY_APPEND)
+ 		s[i++] = 'a';
+ 	if (mode & MAY_TRANSMUTE)
+ 		s[i++] = 't';
+ 	if (mode & MAY_LOCK)
+ 		s[i++] = 'l';
+ 	if (i == 0)
+ 		s[i++] = '-';
+ 	s[i] = '\0';
+ }
+ #endif
+ 
+ #ifdef CONFIG_SECURITY_SMACK_BRINGUP
+ static int smk_bu_note(char *note, struct smack_known *sskp,
+ 		       struct smack_known *oskp, int mode, int rc)
+ {
+ 	char acc[SMK_NUM_ACCESS_TYPE + 1];
+ 
+ 	if (rc <= 0)
+ 		return rc;
+ 
+ 	smk_bu_mode(mode, acc);
+ 	pr_info("Smack Bringup: (%s %s %s) %s\n",
+ 		sskp->smk_known, oskp->smk_known, acc, note);
+ 	return 0;
+ }
+ #else
+ #define smk_bu_note(note, sskp, oskp, mode, RC) (RC)
+ #endif
+ 
+ #ifdef CONFIG_SECURITY_SMACK_BRINGUP
+ static int smk_bu_current(char *note, struct smack_known *oskp,
+ 			  int mode, int rc)
+ {
+ 	struct task_smack *tsp = current_security();
+ 	char acc[SMK_NUM_ACCESS_TYPE + 1];
+ 
+ 	if (rc <= 0)
+ 		return rc;
+ 
+ 	smk_bu_mode(mode, acc);
+ 	pr_info("Smack Bringup: (%s %s %s) %s %s\n",
+ 		tsp->smk_task->smk_known, oskp->smk_known,
+ 		acc, current->comm, note);
+ 	return 0;
+ }
+ #else
+ #define smk_bu_current(note, oskp, mode, RC) (RC)
+ #endif
+ 
+ #ifdef CONFIG_SECURITY_SMACK_BRINGUP
+ static int smk_bu_task(struct task_struct *otp, int mode, int rc)
+ {
+ 	struct task_smack *tsp = current_security();
+ 	struct task_smack *otsp = task_security(otp);
+ 	char acc[SMK_NUM_ACCESS_TYPE + 1];
+ 
+ 	if (rc <= 0)
+ 		return rc;
+ 
+ 	smk_bu_mode(mode, acc);
+ 	pr_info("Smack Bringup: (%s %s %s) %s to %s\n",
+ 		tsp->smk_task->smk_known, otsp->smk_task->smk_known, acc,
+ 		current->comm, otp->comm);
+ 	return 0;
+ }
+ #else
+ #define smk_bu_task(otp, mode, RC) (RC)
+ #endif
+ 
+ #ifdef CONFIG_SECURITY_SMACK_BRINGUP
+ static int smk_bu_inode(struct inode *inode, int mode, int rc)
+ {
+ 	struct task_smack *tsp = current_security();
+ 	char acc[SMK_NUM_ACCESS_TYPE + 1];
+ 
+ 	if (rc <= 0)
+ 		return rc;
+ 
+ 	smk_bu_mode(mode, acc);
+ 	pr_info("Smack Bringup: (%s %s %s) inode=(%s %ld) %s\n",
+ 		tsp->smk_task->smk_known, smk_of_inode(inode)->smk_known, acc,
+ 		inode->i_sb->s_id, inode->i_ino, current->comm);
+ 	return 0;
+ }
+ #else
+ #define smk_bu_inode(inode, mode, RC) (RC)
+ #endif
+ 
+ #ifdef CONFIG_SECURITY_SMACK_BRINGUP
+ static int smk_bu_file(struct file *file, int mode, int rc)
+ {
+ 	struct task_smack *tsp = current_security();
+ 	struct smack_known *sskp = tsp->smk_task;
+ 	struct inode *inode = file->f_inode;
+ 	char acc[SMK_NUM_ACCESS_TYPE + 1];
+ 
+ 	if (rc <= 0)
+ 		return rc;
+ 
+ 	smk_bu_mode(mode, acc);
+ 	pr_info("Smack Bringup: (%s %s %s) file=(%s %ld %pD) %s\n",
+ 		sskp->smk_known, (char *)file->f_security, acc,
+ 		inode->i_sb->s_id, inode->i_ino, file,
+ 		current->comm);
+ 	return 0;
+ }
+ #else
+ #define smk_bu_file(file, mode, RC) (RC)
+ #endif
+ 
+ #ifdef CONFIG_SECURITY_SMACK_BRINGUP
+ static int smk_bu_credfile(const struct cred *cred, struct file *file,
+ 				int mode, int rc)
+ {
+ 	struct task_smack *tsp = cred->security;
+ 	struct smack_known *sskp = tsp->smk_task;
+ 	struct inode *inode = file->f_inode;
+ 	char acc[SMK_NUM_ACCESS_TYPE + 1];
+ 
+ 	if (rc <= 0)
+ 		return rc;
+ 
+ 	smk_bu_mode(mode, acc);
+ 	pr_info("Smack Bringup: (%s %s %s) file=(%s %ld %pD) %s\n",
+ 		sskp->smk_known, smk_of_inode(inode)->smk_known, acc,
+ 		inode->i_sb->s_id, inode->i_ino, file,
+ 		current->comm);
+ 	return 0;
+ }
+ #else
+ #define smk_bu_credfile(cred, file, mode, RC) (RC)
+ #endif
+ 
++>>>>>>> a455589f181e (assorted conversions to %p[dD])
  /**
   * smk_fetch - Fetch the smack label from a file.
   * @ip: a pointer to the inode
* Unmerged path drivers/gpu/drm/armada/armada_gem.c
* Unmerged path drivers/s390/char/hmcdrv_dev.c
diff --git a/arch/powerpc/oprofile/cell/spu_task_sync.c b/arch/powerpc/oprofile/cell/spu_task_sync.c
index 28f1af2db1f5..1c27831df1ac 100644
--- a/arch/powerpc/oprofile/cell/spu_task_sync.c
+++ b/arch/powerpc/oprofile/cell/spu_task_sync.c
@@ -331,8 +331,7 @@ get_exec_dcookie_and_offset(struct spu *spu, unsigned int *offsetp,
 
 	if (mm->exe_file) {
 		app_cookie = fast_get_dcookie(&mm->exe_file->f_path);
-		pr_debug("got dcookie for %s\n",
-			 mm->exe_file->f_dentry->d_name.name);
+		pr_debug("got dcookie for %pD\n", mm->exe_file);
 	}
 
 	for (vma = mm->mmap; vma; vma = vma->vm_next) {
@@ -342,15 +341,14 @@ get_exec_dcookie_and_offset(struct spu *spu, unsigned int *offsetp,
 		if (!vma->vm_file)
 			goto fail_no_image_cookie;
 
-		pr_debug("Found spu ELF at %X(object-id:%lx) for file %s\n",
-			 my_offset, spu_ref,
-			 vma->vm_file->f_dentry->d_name.name);
+		pr_debug("Found spu ELF at %X(object-id:%lx) for file %pD\n",
+			 my_offset, spu_ref, vma->vm_file);
 		*offsetp = my_offset;
 		break;
 	}
 
 	*spu_bin_dcookie = fast_get_dcookie(&vma->vm_file->f_path);
-	pr_debug("got dcookie for %s\n", vma->vm_file->f_dentry->d_name.name);
+	pr_debug("got dcookie for %pD\n", vma->vm_file);
 
 	up_read(&mm->mmap_sem);
 
* Unmerged path arch/s390/hypfs/hypfs_dbfs.c
diff --git a/arch/x86/ia32/ia32_aout.c b/arch/x86/ia32/ia32_aout.c
index 52ff81cce008..3e5a1f39238b 100644
--- a/arch/x86/ia32/ia32_aout.c
+++ b/arch/x86/ia32/ia32_aout.c
@@ -353,8 +353,8 @@ static int load_aout_binary(struct linux_binprm *bprm)
 			    time_after(jiffies, error_time + 5*HZ)) {
 			printk(KERN_WARNING
 			       "fd_offset is not page aligned. Please convert "
-			       "program: %s\n",
-			       bprm->file->f_path.dentry->d_name.name);
+			       "program: %pD\n",
+			       bprm->file);
 			error_time = jiffies;
 		}
 #endif
@@ -444,8 +444,8 @@ static int load_aout_library(struct file *file)
 		if (time_after(jiffies, error_time + 5*HZ)) {
 			printk(KERN_WARNING
 			       "N_TXTOFF is not page aligned. Please convert "
-			       "library: %s\n",
-			       file->f_path.dentry->d_name.name);
+			       "library: %pD\n",
+			       file);
 			error_time = jiffies;
 		}
 #endif
* Unmerged path drivers/gpu/drm/armada/armada_gem.c
diff --git a/drivers/media/pci/zoran/zoran_procfs.c b/drivers/media/pci/zoran/zoran_procfs.c
index f7ceee0cdefd..437652761093 100644
--- a/drivers/media/pci/zoran/zoran_procfs.c
+++ b/drivers/media/pci/zoran/zoran_procfs.c
@@ -157,8 +157,8 @@ static ssize_t zoran_write(struct file *file, const char __user *buffer,
 		return -EFAULT;
 	}
 	string[count] = 0;
-	dprintk(4, KERN_INFO "%s: write_proc: name=%s count=%zu zr=%p\n",
-		ZR_DEVNAME(zr), file->f_path.dentry->d_name.name, count, zr);
+	dprintk(4, KERN_INFO "%s: write_proc: name=%pD count=%zu zr=%p\n",
+		ZR_DEVNAME(zr), file, count, zr);
 	ldelim = " \t\n";
 	tdelim = "=";
 	line = strpbrk(sp, ldelim);
diff --git a/drivers/misc/genwqe/card_dev.c b/drivers/misc/genwqe/card_dev.c
index 5918586f2f76..c49d244265ec 100644
--- a/drivers/misc/genwqe/card_dev.c
+++ b/drivers/misc/genwqe/card_dev.c
@@ -395,7 +395,7 @@ static void genwqe_vma_open(struct vm_area_struct *vma)
 static void genwqe_vma_close(struct vm_area_struct *vma)
 {
 	unsigned long vsize = vma->vm_end - vma->vm_start;
-	struct inode *inode = vma->vm_file->f_dentry->d_inode;
+	struct inode *inode = file_inode(vma->vm_file);
 	struct dma_mapping *dma_map;
 	struct genwqe_dev *cd = container_of(inode->i_cdev, struct genwqe_dev,
 					    cdev_genwqe);
* Unmerged path drivers/s390/char/hmcdrv_dev.c
diff --git a/drivers/scsi/lpfc/lpfc_debugfs.c b/drivers/scsi/lpfc/lpfc_debugfs.c
index 7cc2a6df5227..1edefee6f5f1 100644
--- a/drivers/scsi/lpfc/lpfc_debugfs.c
+++ b/drivers/scsi/lpfc/lpfc_debugfs.c
@@ -968,8 +968,8 @@ lpfc_debugfs_dumpDif_open(struct inode *inode, struct file *file)
 		goto out;
 
 	/* Round to page boundary */
-	printk(KERN_ERR	"9060 BLKGRD: %s: _dump_buf_dif=0x%p file=%s\n",
-		__func__, _dump_buf_dif, file->f_dentry->d_name.name);
+	printk(KERN_ERR	"9060 BLKGRD: %s: _dump_buf_dif=0x%p file=%pD\n",
+		__func__, _dump_buf_dif, file);
 	debug->buffer = _dump_buf_dif;
 	if (!debug->buffer) {
 		kfree(debug);
diff --git a/fs/9p/vfs_inode_dotl.c b/fs/9p/vfs_inode_dotl.c
index a7c481402c46..16c5a387a593 100644
--- a/fs/9p/vfs_inode_dotl.c
+++ b/fs/9p/vfs_inode_dotl.c
@@ -838,8 +838,8 @@ v9fs_vfs_mknod_dotl(struct inode *dir, struct dentry *dentry, umode_t omode,
 	struct dentry *dir_dentry;
 	struct posix_acl *dacl = NULL, *pacl = NULL;
 
-	p9_debug(P9_DEBUG_VFS, " %lu,%s mode: %hx MAJOR: %u MINOR: %u\n",
-		 dir->i_ino, dentry->d_name.name, omode,
+	p9_debug(P9_DEBUG_VFS, " %lu,%pd mode: %hx MAJOR: %u MINOR: %u\n",
+		 dir->i_ino, dentry, omode,
 		 MAJOR(rdev), MINOR(rdev));
 
 	if (!new_valid_dev(rdev))
* Unmerged path fs/affs/inode.c
* Unmerged path fs/affs/namei.c
* Unmerged path fs/afs/dir.c
diff --git a/fs/afs/inode.c b/fs/afs/inode.c
index 2bbe60e3f0e3..f6e83f823ce0 100644
--- a/fs/afs/inode.c
+++ b/fs/afs/inode.c
@@ -462,8 +462,8 @@ int afs_setattr(struct dentry *dentry, struct iattr *attr)
 	struct key *key;
 	int ret;
 
-	_enter("{%x:%u},{n=%s},%x",
-	       vnode->fid.vid, vnode->fid.vnode, dentry->d_name.name,
+	_enter("{%x:%u},{n=%pd},%x",
+	       vnode->fid.vid, vnode->fid.vnode, dentry,
 	       attr->ia_valid);
 
 	if (!(attr->ia_valid & (ATTR_SIZE | ATTR_MODE | ATTR_UID | ATTR_GID |
diff --git a/fs/afs/mntpt.c b/fs/afs/mntpt.c
index 9682c33d5daf..938c5ab06d5a 100644
--- a/fs/afs/mntpt.c
+++ b/fs/afs/mntpt.c
@@ -106,14 +106,7 @@ static struct dentry *afs_mntpt_lookup(struct inode *dir,
 				       struct dentry *dentry,
 				       unsigned int flags)
 {
-	_enter("%p,%p{%p{%s},%s}",
-	       dir,
-	       dentry,
-	       dentry->d_parent,
-	       dentry->d_parent ?
-	       dentry->d_parent->d_name.name : (const unsigned char *) "",
-	       dentry->d_name.name);
-
+	_enter("%p,%p{%pd2}", dir, dentry, dentry);
 	return ERR_PTR(-EREMOTE);
 }
 
@@ -122,14 +115,7 @@ static struct dentry *afs_mntpt_lookup(struct inode *dir,
  */
 static int afs_mntpt_open(struct inode *inode, struct file *file)
 {
-	_enter("%p,%p{%p{%s},%s}",
-	       inode, file,
-	       file->f_path.dentry->d_parent,
-	       file->f_path.dentry->d_parent ?
-	       file->f_path.dentry->d_parent->d_name.name :
-	       (const unsigned char *) "",
-	       file->f_path.dentry->d_name.name);
-
+	_enter("%p,%p{%pD2}", inode, file, file);
 	return -EREMOTE;
 }
 
@@ -146,7 +132,7 @@ static struct vfsmount *afs_mntpt_do_automount(struct dentry *mntpt)
 	bool rwpath = false;
 	int ret;
 
-	_enter("{%s}", mntpt->d_name.name);
+	_enter("{%pd}", mntpt);
 
 	BUG_ON(!mntpt->d_inode);
 
@@ -242,7 +228,7 @@ struct vfsmount *afs_d_automount(struct path *path)
 {
 	struct vfsmount *newmnt;
 
-	_enter("{%s}", path->dentry->d_name.name);
+	_enter("{%pd}", path->dentry);
 
 	newmnt = afs_mntpt_do_automount(path->dentry);
 	if (IS_ERR(newmnt))
diff --git a/fs/afs/write.c b/fs/afs/write.c
index a890db4b9898..34f4f245f980 100644
--- a/fs/afs/write.c
+++ b/fs/afs/write.c
@@ -689,8 +689,8 @@ int afs_fsync(struct file *file, loff_t start, loff_t end, int datasync)
 	struct afs_vnode *vnode = AFS_FS_I(dentry->d_inode);
 	int ret;
 
-	_enter("{%x:%u},{n=%s},%d",
-	       vnode->fid.vid, vnode->fid.vnode, dentry->d_name.name,
+	_enter("{%x:%u},{n=%pd},%d",
+	       vnode->fid.vid, vnode->fid.vnode, dentry,
 	       datasync);
 
 	ret = filemap_write_and_wait_range(inode->i_mapping, start, end);
* Unmerged path fs/autofs4/expire.c
* Unmerged path fs/autofs4/root.c
* Unmerged path fs/befs/linuxvfs.c
diff --git a/fs/binfmt_aout.c b/fs/binfmt_aout.c
index bce87694f7b0..a9d15d1da862 100644
--- a/fs/binfmt_aout.c
+++ b/fs/binfmt_aout.c
@@ -302,8 +302,8 @@ static int load_aout_binary(struct linux_binprm * bprm)
 		if ((fd_offset & ~PAGE_MASK) != 0 && printk_ratelimit())
 		{
 			printk(KERN_WARNING 
-			       "fd_offset is not page aligned. Please convert program: %s\n",
-			       bprm->file->f_path.dentry->d_name.name);
+			       "fd_offset is not page aligned. Please convert program: %pD\n",
+			       bprm->file);
 		}
 
 		if (!bprm->file->f_op->mmap||((fd_offset & ~PAGE_MASK) != 0)) {
@@ -391,8 +391,8 @@ static int load_aout_library(struct file *file)
 		if (printk_ratelimit())
 		{
 			printk(KERN_WARNING 
-			       "N_TXTOFF is not page aligned. Please convert library: %s\n",
-			       file->f_path.dentry->d_name.name);
+			       "N_TXTOFF is not page aligned. Please convert library: %pD\n",
+			       file);
 		}
 		vm_brk(start_addr, ex.a_text + ex.a_data + ex.a_bss);
 		
diff --git a/fs/cachefiles/namei.c b/fs/cachefiles/namei.c
index 905ca65b780b..a477b0eb2d23 100644
--- a/fs/cachefiles/namei.c
+++ b/fs/cachefiles/namei.c
@@ -103,8 +103,7 @@ static void cachefiles_mark_object_buried(struct cachefiles_cache *cache,
 	struct cachefiles_object *object;
 	struct rb_node *p;
 
-	_enter(",'%*.*s'",
-	       dentry->d_name.len, dentry->d_name.len, dentry->d_name.name);
+	_enter(",'%pd'", dentry);
 
 	write_lock(&cache->active_lock);
 
@@ -278,9 +277,7 @@ static int cachefiles_bury_object(struct cachefiles_cache *cache,
 	char nbuffer[8 + 8 + 1];
 	int ret;
 
-	_enter(",'%*.*s','%*.*s'",
-	       dir->d_name.len, dir->d_name.len, dir->d_name.name,
-	       rep->d_name.len, rep->d_name.len, rep->d_name.name);
+	_enter(",'%pd','%pd'", dir, rep);
 
 	_debug("remove %p from %p", rep, dir);
 
@@ -602,8 +599,7 @@ lookup_again:
 	/* if we've found that the terminal object exists, then we need to
 	 * check its attributes and delete it if it's out of date */
 	if (!object->new) {
-		_debug("validate '%*.*s'",
-		       next->d_name.len, next->d_name.len, next->d_name.name);
+		_debug("validate '%pd'", next);
 
 		ret = cachefiles_check_object_xattr(object, auxdata);
 		if (ret == -ESTALE) {
@@ -832,8 +828,8 @@ static struct dentry *cachefiles_check_active(struct cachefiles_cache *cache,
 	unsigned long start;
 	int ret;
 
-	//_enter(",%*.*s/,%s",
-	//       dir->d_name.len, dir->d_name.len, dir->d_name.name, filename);
+	//_enter(",%pd/,%s",
+	//       dir, filename);
 
 	/* look up the victim */
 	mutex_lock_nested(&dir->d_inode->i_mutex, 1);
@@ -915,8 +911,7 @@ int cachefiles_cull(struct cachefiles_cache *cache, struct dentry *dir,
 	struct dentry *victim;
 	int ret;
 
-	_enter(",%*.*s/,%s",
-	       dir->d_name.len, dir->d_name.len, dir->d_name.name, filename);
+	_enter(",%pd/,%s", dir, filename);
 
 	victim = cachefiles_check_active(cache, dir, filename);
 	if (IS_ERR(victim))
@@ -974,8 +969,8 @@ int cachefiles_check_in_use(struct cachefiles_cache *cache, struct dentry *dir,
 {
 	struct dentry *victim;
 
-	//_enter(",%*.*s/,%s",
-	//       dir->d_name.len, dir->d_name.len, dir->d_name.name, filename);
+	//_enter(",%pd/,%s",
+	//       dir, filename);
 
 	victim = cachefiles_check_active(cache, dir, filename);
 	if (IS_ERR(victim))
* Unmerged path fs/cachefiles/xattr.c
diff --git a/fs/ceph/debugfs.c b/fs/ceph/debugfs.c
index 5d5a4c8c8496..1b2355109b9f 100644
--- a/fs/ceph/debugfs.c
+++ b/fs/ceph/debugfs.c
@@ -83,10 +83,9 @@ static int mdsc_show(struct seq_file *s, void *p)
 			if (IS_ERR(path))
 				path = NULL;
 			spin_lock(&req->r_dentry->d_lock);
-			seq_printf(s, " #%llx/%.*s (%s)",
+			seq_printf(s, " #%llx/%pd (%s)",
 				   ceph_ino(req->r_dentry->d_parent->d_inode),
-				   req->r_dentry->d_name.len,
-				   req->r_dentry->d_name.name,
+				   req->r_dentry,
 				   path ? path : "");
 			spin_unlock(&req->r_dentry->d_lock);
 			kfree(path);
@@ -103,11 +102,10 @@ static int mdsc_show(struct seq_file *s, void *p)
 			if (IS_ERR(path))
 				path = NULL;
 			spin_lock(&req->r_old_dentry->d_lock);
-			seq_printf(s, " #%llx/%.*s (%s)",
+			seq_printf(s, " #%llx/%pd (%s)",
 				   req->r_old_dentry_dir ?
 				   ceph_ino(req->r_old_dentry_dir) : 0,
-				   req->r_old_dentry->d_name.len,
-				   req->r_old_dentry->d_name.name,
+				   req->r_old_dentry,
 				   path ? path : "");
 			spin_unlock(&req->r_old_dentry->d_lock);
 			kfree(path);
@@ -150,8 +148,8 @@ static int dentry_lru_show(struct seq_file *s, void *ptr)
 	spin_lock(&mdsc->dentry_lru_lock);
 	list_for_each_entry(di, &mdsc->dentry_lru, lru) {
 		struct dentry *dentry = di->dentry;
-		seq_printf(s, "%p %p\t%.*s\n",
-			   di, dentry, dentry->d_name.len, dentry->d_name.name);
+		seq_printf(s, "%p %p\t%pd\n",
+			   di, dentry, dentry);
 	}
 	spin_unlock(&mdsc->dentry_lru_lock);
 
* Unmerged path fs/ceph/dir.c
diff --git a/fs/ceph/file.c b/fs/ceph/file.c
index f23bd8e109ef..c7b4ddba3ff1 100644
--- a/fs/ceph/file.c
+++ b/fs/ceph/file.c
@@ -220,8 +220,8 @@ int ceph_atomic_open(struct inode *dir, struct dentry *dentry,
 	struct dentry *dn;
 	int err;
 
-	dout("atomic_open %p dentry %p '%.*s' %s flags %d mode 0%o\n",
-	     dir, dentry, dentry->d_name.len, dentry->d_name.name,
+	dout("atomic_open %p dentry %p '%pd' %s flags %d mode 0%o\n",
+	     dir, dentry, dentry,
 	     d_unhashed(dentry) ? "unhashed" : "hashed", flags, mode);
 
 	if (dentry->d_name.len > NAME_MAX)
diff --git a/fs/ceph/inode.c b/fs/ceph/inode.c
index c229616c436a..356c9dcb9219 100644
--- a/fs/ceph/inode.c
+++ b/fs/ceph/inode.c
@@ -1173,20 +1173,18 @@ retry_lookup:
 			struct inode *olddir = req->r_old_dentry_dir;
 			BUG_ON(!olddir);
 
-			dout(" src %p '%.*s' dst %p '%.*s'\n",
+			dout(" src %p '%pd' dst %p '%pd'\n",
 			     req->r_old_dentry,
-			     req->r_old_dentry->d_name.len,
-			     req->r_old_dentry->d_name.name,
-			     dn, dn->d_name.len, dn->d_name.name);
+			     req->r_old_dentry,
+			     dn, dn);
 			dout("fill_trace doing d_move %p -> %p\n",
 			     req->r_old_dentry, dn);
 
 			d_move(req->r_old_dentry, dn);
-			dout(" src %p '%.*s' dst %p '%.*s'\n",
+			dout(" src %p '%pd' dst %p '%pd'\n",
+			     req->r_old_dentry,
 			     req->r_old_dentry,
-			     req->r_old_dentry->d_name.len,
-			     req->r_old_dentry->d_name.name,
-			     dn, dn->d_name.len, dn->d_name.name);
+			     dn, dn);
 
 			/* ensure target dentry is invalidated, despite
 			   rehashing bug in vfs_rename_dir */
diff --git a/fs/configfs/dir.c b/fs/configfs/dir.c
index 843953f876fd..5ab8d7fee2e7 100644
--- a/fs/configfs/dir.c
+++ b/fs/configfs/dir.c
@@ -387,7 +387,7 @@ static void remove_dir(struct dentry * d)
 	if (d->d_inode)
 		simple_rmdir(parent->d_inode,d);
 
-	pr_debug(" o %s removing done (%d)\n",d->d_name.name, d_count(d));
+	pr_debug(" o %pd removing done (%d)\n", d, d_count(d));
 
 	dput(parent);
 }
* Unmerged path fs/fuse/file.c
diff --git a/fs/jfs/namei.c b/fs/jfs/namei.c
index 25e171702de6..55f81823c7e9 100644
--- a/fs/jfs/namei.c
+++ b/fs/jfs/namei.c
@@ -84,7 +84,7 @@ static int jfs_create(struct inode *dip, struct dentry *dentry, umode_t mode,
 	struct inode *iplist[2];
 	struct tblock *tblk;
 
-	jfs_info("jfs_create: dip:0x%p name:%s", dip, dentry->d_name.name);
+	jfs_info("jfs_create: dip:0x%p name:%pd", dip, dentry);
 
 	dquot_initialize(dip);
 
@@ -216,7 +216,7 @@ static int jfs_mkdir(struct inode *dip, struct dentry *dentry, umode_t mode)
 	struct inode *iplist[2];
 	struct tblock *tblk;
 
-	jfs_info("jfs_mkdir: dip:0x%p name:%s", dip, dentry->d_name.name);
+	jfs_info("jfs_mkdir: dip:0x%p name:%pd", dip, dentry);
 
 	dquot_initialize(dip);
 
@@ -352,7 +352,7 @@ static int jfs_rmdir(struct inode *dip, struct dentry *dentry)
 	struct inode *iplist[2];
 	struct tblock *tblk;
 
-	jfs_info("jfs_rmdir: dip:0x%p name:%s", dip, dentry->d_name.name);
+	jfs_info("jfs_rmdir: dip:0x%p name:%pd", dip, dentry);
 
 	/* Init inode for quota operations. */
 	dquot_initialize(dip);
@@ -480,7 +480,7 @@ static int jfs_unlink(struct inode *dip, struct dentry *dentry)
 	s64 new_size = 0;
 	int commit_flag;
 
-	jfs_info("jfs_unlink: dip:0x%p name:%s", dip, dentry->d_name.name);
+	jfs_info("jfs_unlink: dip:0x%p name:%pd", dip, dentry);
 
 	/* Init inode for quota operations. */
 	dquot_initialize(dip);
@@ -797,8 +797,7 @@ static int jfs_link(struct dentry *old_dentry,
 	struct btstack btstack;
 	struct inode *iplist[2];
 
-	jfs_info("jfs_link: %s %s", old_dentry->d_name.name,
-		 dentry->d_name.name);
+	jfs_info("jfs_link: %pd %pd", old_dentry, dentry);
 
 	dquot_initialize(dir);
 
@@ -1082,8 +1081,7 @@ static int jfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 	int commit_flag;
 
 
-	jfs_info("jfs_rename: %s %s", old_dentry->d_name.name,
-		 new_dentry->d_name.name);
+	jfs_info("jfs_rename: %pd %pd", old_dentry, new_dentry);
 
 	dquot_initialize(old_dir);
 	dquot_initialize(new_dir);
@@ -1355,7 +1353,7 @@ static int jfs_mknod(struct inode *dir, struct dentry *dentry,
 	if (!new_valid_dev(rdev))
 		return -EINVAL;
 
-	jfs_info("jfs_mknod: %s", dentry->d_name.name);
+	jfs_info("jfs_mknod: %pd", dentry);
 
 	dquot_initialize(dir);
 
@@ -1444,7 +1442,7 @@ static struct dentry *jfs_lookup(struct inode *dip, struct dentry *dentry, unsig
 	struct component_name key;
 	int rc;
 
-	jfs_info("jfs_lookup: name = %s", dentry->d_name.name);
+	jfs_info("jfs_lookup: name = %pd", dentry);
 
 	if ((rc = get_UCSname(&key, dentry)))
 		return ERR_PTR(rc);
diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c
index 51f6625ec9fd..63cd02b75a28 100644
--- a/fs/nfs/dir.c
+++ b/fs/nfs/dir.c
@@ -133,7 +133,7 @@ out:
 static int
 nfs_closedir(struct inode *inode, struct file *filp)
 {
-	put_nfs_open_dir_context(filp->f_path.dentry->d_inode, filp->private_data);
+	put_nfs_open_dir_context(file_inode(filp), filp->private_data);
 	return 0;
 }
 
diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.c
index 00e227226703..4c4d45192a2a 100644
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@ -1859,7 +1859,7 @@ static __be32 nfsd4_encode_path(struct xdr_stream *xdr,
 			goto out_free;
 		}
 		p = xdr_encode_opaque(p, dentry->d_name.name, len);
-		dprintk("/%s", dentry->d_name.name);
+		dprintk("/%pd", dentry);
 		spin_unlock(&dentry->d_lock);
 		dput(dentry);
 		ncomponents--;
diff --git a/fs/ntfs/namei.c b/fs/ntfs/namei.c
index 436f36037e09..b3973c2fd190 100644
--- a/fs/ntfs/namei.c
+++ b/fs/ntfs/namei.c
@@ -111,8 +111,8 @@ static struct dentry *ntfs_lookup(struct inode *dir_ino, struct dentry *dent,
 	unsigned long dent_ino;
 	int uname_len;
 
-	ntfs_debug("Looking up %s in directory inode 0x%lx.",
-			dent->d_name.name, dir_ino->i_ino);
+	ntfs_debug("Looking up %pd in directory inode 0x%lx.",
+			dent, dir_ino->i_ino);
 	/* Convert the name of the dentry to Unicode. */
 	uname_len = ntfs_nlstoucs(vol, dent->d_name.name, dent->d_name.len,
 			&uname);
diff --git a/fs/ocfs2/dcache.c b/fs/ocfs2/dcache.c
index ef999729e274..950a957cac0d 100644
--- a/fs/ocfs2/dcache.c
+++ b/fs/ocfs2/dcache.c
@@ -251,8 +251,8 @@ int ocfs2_dentry_attach_lock(struct dentry *dentry,
 
 	if (dl) {
 		mlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,
-				" \"%.*s\": old parent: %llu, new: %llu\n",
-				dentry->d_name.len, dentry->d_name.name,
+				" \"%pd\": old parent: %llu, new: %llu\n",
+				dentry,
 				(unsigned long long)parent_blkno,
 				(unsigned long long)dl->dl_parent_blkno);
 		return 0;
@@ -277,8 +277,8 @@ int ocfs2_dentry_attach_lock(struct dentry *dentry,
 				(unsigned long long)OCFS2_I(inode)->ip_blkno);
 
 		mlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,
-				" \"%.*s\": old parent: %llu, new: %llu\n",
-				dentry->d_name.len, dentry->d_name.name,
+				" \"%pd\": old parent: %llu, new: %llu\n",
+				dentry,
 				(unsigned long long)parent_blkno,
 				(unsigned long long)dl->dl_parent_blkno);
 
@@ -460,17 +460,15 @@ static void ocfs2_dentry_iput(struct dentry *dentry, struct inode *inode)
 			if (inode)
 				ino = (unsigned long long)OCFS2_I(inode)->ip_blkno;
 			mlog(ML_ERROR, "Dentry is missing cluster lock. "
-			     "inode: %llu, d_flags: 0x%x, d_name: %.*s\n",
-			     ino, dentry->d_flags, dentry->d_name.len,
-			     dentry->d_name.name);
+			     "inode: %llu, d_flags: 0x%x, d_name: %pd\n",
+			     ino, dentry->d_flags, dentry);
 		}
 
 		goto out;
 	}
 
-	mlog_bug_on_msg(dl->dl_count == 0, "dentry: %.*s, count: %u\n",
-			dentry->d_name.len, dentry->d_name.name,
-			dl->dl_count);
+	mlog_bug_on_msg(dl->dl_count == 0, "dentry: %pd, count: %u\n",
+			dentry, dl->dl_count);
 
 	ocfs2_dentry_lock_put(OCFS2_SB(dentry->d_sb), dl);
 
diff --git a/fs/ocfs2/dlmfs/dlmfs.c b/fs/ocfs2/dlmfs/dlmfs.c
index 12bafb7265ce..e2ac859a79c8 100644
--- a/fs/ocfs2/dlmfs/dlmfs.c
+++ b/fs/ocfs2/dlmfs/dlmfs.c
@@ -569,8 +569,8 @@ static int dlmfs_unlink(struct inode *dir,
 	 * to acquire a lock, this basically destroys our lockres. */
 	status = user_dlm_destroy_lock(&DLMFS_I(inode)->ip_lockres);
 	if (status < 0) {
-		mlog(ML_ERROR, "unlink %.*s, error %d from destroy\n",
-		     dentry->d_name.len, dentry->d_name.name, status);
+		mlog(ML_ERROR, "unlink %pd, error %d from destroy\n",
+		     dentry, status);
 		goto bail;
 	}
 	status = simple_unlink(dir, dentry);
diff --git a/fs/ocfs2/dlmglue.c b/fs/ocfs2/dlmglue.c
index 3a44a648dae7..1e5ebd69a6bf 100644
--- a/fs/ocfs2/dlmglue.c
+++ b/fs/ocfs2/dlmglue.c
@@ -3703,8 +3703,7 @@ static int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,
 			break;
 		spin_unlock(&dentry_attach_lock);
 
-		mlog(0, "d_delete(%.*s);\n", dentry->d_name.len,
-		     dentry->d_name.name);
+		mlog(0, "d_delete(%pd);\n", dentry);
 
 		/*
 		 * The following dcache calls may do an
diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 821bcf70e467..823aec6997e4 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -197,9 +197,9 @@ fill_with_dentries(void *buf, const char *name, int namelen, loff_t offset,
 	} else if (!dentry->d_inode) {
 		/* A directory entry exists, but no file? */
 		reiserfs_error(dentry->d_sb, "xattr-20003",
-			       "Corrupted directory: xattr %s listed but "
-			       "not found for file %s.\n",
-			       dentry->d_name.name, dbuf->xadir->d_name.name);
+			       "Corrupted directory: xattr %pd listed but "
+			       "not found for file %pd.\n",
+			       dentry, dbuf->xadir);
 		dput(dentry);
 		return -EIO;
 	}
* Unmerged path security/smack/smack_lsm.c
