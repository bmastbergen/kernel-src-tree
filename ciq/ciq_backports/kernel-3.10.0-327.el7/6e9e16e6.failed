ipv6: replacing a rt6_info needs to purge possible propagated rt6_infos too

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Hannes Frederic Sowa <hannes@stressinduktion.org>
commit 6e9e16e6143b725662e47026a1d0f270721cdd24
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/6e9e16e6.failed

Lubomir Rintel reported that during replacing a route the interface
reference counter isn't correctly decremented.

To quote bug <https://bugzilla.kernel.org/show_bug.cgi?id=91941>:
| [root@rhel7-5 lkundrak]# sh -x lal
| + ip link add dev0 type dummy
| + ip link set dev0 up
| + ip link add dev1 type dummy
| + ip link set dev1 up
| + ip addr add 2001:db8:8086::2/64 dev dev0
| + ip route add 2001:db8:8086::/48 dev dev0 proto static metric 20
| + ip route add 2001:db8:8088::/48 dev dev1 proto static metric 10
| + ip route replace 2001:db8:8086::/48 dev dev1 proto static metric 20
| + ip link del dev0 type dummy
| Message from syslogd@rhel7-5 at Jan 23 10:54:41 ...
|  kernel:unregister_netdevice: waiting for dev0 to become free. Usage count = 2
|
| Message from syslogd@rhel7-5 at Jan 23 10:54:51 ...
|  kernel:unregister_netdevice: waiting for dev0 to become free. Usage count = 2

During replacement of a rt6_info we must walk all parent nodes and check
if the to be replaced rt6_info got propagated. If so, replace it with
an alive one.

Fixes: 4a287eba2de3957 ("IPv6 routing, NLM_F_* flag support: REPLACE and EXCL flags support, warn about missing CREATE flag")
	Reported-by: Lubomir Rintel <lkundrak@v3.sk>
	Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Tested-by: Lubomir Rintel <lkundrak@v3.sk>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6e9e16e6143b725662e47026a1d0f270721cdd24)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_fib.c
diff --cc net/ipv6/ip6_fib.c
index ebabac76c2ff,f1c6d5e98322..000000000000
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@@ -638,6 -630,58 +638,61 @@@ static inline bool rt6_qualify_for_ecmp
  	       RTF_GATEWAY;
  }
  
++<<<<<<< HEAD
++=======
+ static int fib6_commit_metrics(struct dst_entry *dst,
+ 			       struct nlattr *mx, int mx_len)
+ {
+ 	struct nlattr *nla;
+ 	int remaining;
+ 	u32 *mp;
+ 
+ 	if (dst->flags & DST_HOST) {
+ 		mp = dst_metrics_write_ptr(dst);
+ 	} else {
+ 		mp = kzalloc(sizeof(u32) * RTAX_MAX, GFP_ATOMIC);
+ 		if (!mp)
+ 			return -ENOMEM;
+ 		dst_init_metrics(dst, mp, 0);
+ 	}
+ 
+ 	nla_for_each_attr(nla, mx, mx_len, remaining) {
+ 		int type = nla_type(nla);
+ 
+ 		if (type) {
+ 			if (type > RTAX_MAX)
+ 				return -EINVAL;
+ 
+ 			mp[type - 1] = nla_get_u32(nla);
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
+ static void fib6_purge_rt(struct rt6_info *rt, struct fib6_node *fn,
+ 			  struct net *net)
+ {
+ 	if (atomic_read(&rt->rt6i_ref) != 1) {
+ 		/* This route is used as dummy address holder in some split
+ 		 * nodes. It is not leaked, but it still holds other resources,
+ 		 * which must be released in time. So, scan ascendant nodes
+ 		 * and replace dummy references to this route with references
+ 		 * to still alive ones.
+ 		 */
+ 		while (fn) {
+ 			if (!(fn->fn_flags & RTN_RTINFO) && fn->leaf == rt) {
+ 				fn->leaf = fib6_find_prefix(net, fn);
+ 				atomic_inc(&fn->leaf->rt6i_ref);
+ 				rt6_release(rt);
+ 			}
+ 			fn = fn->parent;
+ 		}
+ 		/* No more references are possible at this point. */
+ 		BUG_ON(atomic_read(&rt->rt6i_ref) != 1);
+ 	}
+ }
+ 
++>>>>>>> 6e9e16e6143b (ipv6: replacing a rt6_info needs to purge possible propagated rt6_infos too)
  /*
   *	Insert routing information in a node.
   */
* Unmerged path net/ipv6/ip6_fib.c
