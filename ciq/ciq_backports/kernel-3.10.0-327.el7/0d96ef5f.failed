hpsa: clean up host, channel, target, lun prints

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Webb Scales <webbnh@hp.com>
commit 0d96ef5ff4086a4143eacb036cf28affd1db0cab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/0d96ef5f.failed

We had a mix of formats used for specifying controller, bus, target,
and lun address of devices.

change to the format used by the scsi midlayer and upper layer (2:3:0:0)
so you can easily follow the information from hpsa to scsi midlayer
to sd upper layer.

Also add this information:
- product ID
- vendor ID
- RAID level
- SSD Smath Path capable and enabled
- exposure level (sg-only)

Example:
hpsa 0000:04:00.0: added scsi 2:0:0:0: Direct-Access     HP LOGICAL VOLUME   RAID-0 SSDSmartPathCap+ En+ Exp=4
scsi 2:0:0:0: Direct-Access     HP       LOGICAL VOLUME   10.0 PQ: 0 ANSI: 5
sd 2:0:0:0: [sdr] 12501713072 512-byte logical blocks: (6.40 TB/5.82 TiB)
sd 2:0:0:0: [sdr] 4096-byte physical blocks
sd 2:0:0:0: [sdr] Attached SCSI disk
sd 2:0:0:0: Attached scsi generic sg20 type 0

	Reviewed-by: Scott Teel <scott.teel@pmcs.com>
	Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
	Reviewed-by: Tomas Henzl <thenzl@redhat.com>
	Reviewed-by: Hannes Reinecke <hare@Suse.de>
	Signed-off-by: Robert Elliott <elliott@hp.com>
	Signed-off-by: Don Brace <don.brace@pmcs.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: James Bottomley <JBottomley@Odin.com>
(cherry picked from commit 0d96ef5ff4086a4143eacb036cf28affd1db0cab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/hpsa.c
diff --cc drivers/scsi/hpsa.c
index 4400efc84107,535505d5ece4..000000000000
--- a/drivers/scsi/hpsa.c
+++ b/drivers/scsi/hpsa.c
@@@ -954,17 -968,12 +971,10 @@@ lun_assigned
  
  	h->dev[n] = device;
  	h->ndevices++;
 -	device->offload_to_be_enabled = device->offload_enabled;
 -	device->offload_enabled = 0;
  	added[*nadded] = device;
  	(*nadded)++;
- 
- 	/* initially, (before registering with scsi layer) we don't
- 	 * know our hostno and we don't want to print anything first
- 	 * time anyway (the scsi layer's inquiries will show that info)
- 	 */
- 	/* if (hostno != -1) */
- 		dev_info(&h->pdev->dev, "%s device c%db%dt%dl%d added.\n",
- 			scsi_device_type(device->devtype), hostno,
- 			device->bus, device->target, device->lun);
+ 	hpsa_show_dev_msg(KERN_INFO, h, device,
+ 		device->expose_state & HPSA_SCSI_ADD ? "added" : "masked");
  	return 0;
  }
  
@@@ -978,16 -987,33 +988,20 @@@ static void hpsa_scsi_update_entry(stru
  	/* Raid level changed. */
  	h->dev[entry]->raid_level = new_entry->raid_level;
  
 -	/* Raid offload parameters changed.  Careful about the ordering. */
 -	if (new_entry->offload_config && new_entry->offload_enabled) {
 -		/*
 -		 * if drive is newly offload_enabled, we want to copy the
 -		 * raid map data first.  If previously offload_enabled and
 -		 * offload_config were set, raid map data had better be
 -		 * the same as it was before.  if raid map data is changed
 -		 * then it had better be the case that
 -		 * h->dev[entry]->offload_enabled is currently 0.
 -		 */
 -		h->dev[entry]->raid_map = new_entry->raid_map;
 -		h->dev[entry]->ioaccel_handle = new_entry->ioaccel_handle;
 -	}
 +	/* Raid offload parameters changed. */
  	h->dev[entry]->offload_config = new_entry->offload_config;
 +	h->dev[entry]->offload_enabled = new_entry->offload_enabled;
 +	h->dev[entry]->ioaccel_handle = new_entry->ioaccel_handle;
  	h->dev[entry]->offload_to_mirror = new_entry->offload_to_mirror;
 -	h->dev[entry]->queue_depth = new_entry->queue_depth;
 -
 -	/*
 -	 * We can turn off ioaccel offload now, but need to delay turning
 -	 * it on until we can update h->dev[entry]->phys_disk[], but we
 -	 * can't do that until all the devices are updated.
 -	 */
 -	h->dev[entry]->offload_to_be_enabled = new_entry->offload_enabled;
 -	if (!new_entry->offload_enabled)
 -		h->dev[entry]->offload_enabled = 0;
 +	h->dev[entry]->raid_map = new_entry->raid_map;
  
++<<<<<<< HEAD
 +	dev_info(&h->pdev->dev, "%s device c%db%dt%dl%d updated.\n",
 +		scsi_device_type(new_entry->devtype), hostno, new_entry->bus,
 +		new_entry->target, new_entry->lun);
++=======
+ 	hpsa_show_dev_msg(KERN_INFO, h, h->dev[entry], "updated");
++>>>>>>> 0d96ef5ff408 (hpsa: clean up host, channel, target, lun prints)
  }
  
  /* Replace an entry from h->dev[] array. */
@@@ -1371,20 -1493,22 +1379,39 @@@ static void adjust_hpsa_scsi_table(stru
  	sh = h->scsi_host;
  	/* Notify scsi mid layer of any removed devices */
  	for (i = 0; i < nremoved; i++) {
++<<<<<<< HEAD
 +		struct scsi_device *sdev =
 +			scsi_device_lookup(sh, removed[i]->bus,
 +				removed[i]->target, removed[i]->lun);
 +		if (sdev != NULL) {
 +			scsi_remove_device(sdev);
 +			scsi_device_put(sdev);
 +		} else {
 +			/* We don't expect to get here.
 +			 * future cmds to this device will get selection
 +			 * timeout as if the device was gone.
 +			 */
 +			dev_warn(&h->pdev->dev, "didn't find c%db%dt%dl%d "
 +				" for removal.", hostno, removed[i]->bus,
 +				removed[i]->target, removed[i]->lun);
++=======
+ 		if (removed[i]->expose_state & HPSA_SCSI_ADD) {
+ 			struct scsi_device *sdev =
+ 				scsi_device_lookup(sh, removed[i]->bus,
+ 					removed[i]->target, removed[i]->lun);
+ 			if (sdev != NULL) {
+ 				scsi_remove_device(sdev);
+ 				scsi_device_put(sdev);
+ 			} else {
+ 				/*
+ 				 * We don't expect to get here.
+ 				 * future cmds to this device will get selection
+ 				 * timeout as if the device was gone.
+ 				 */
+ 				hpsa_show_dev_msg(KERN_WARNING, h, removed[i],
+ 					"didn't find device for removal.");
+ 			}
++>>>>>>> 0d96ef5ff408 (hpsa: clean up host, channel, target, lun prints)
  		}
  		kfree(removed[i]);
  		removed[i] = NULL;
@@@ -4394,9 -4596,10 +4420,14 @@@ static int hpsa_eh_abort_handler(struc
  		return FAILED;
  
  	memset(msg, 0, sizeof(msg));
++<<<<<<< HEAD
 +	ml += sprintf(msg+ml, "ABORT REQUEST on C%d:B%d:T%d:L%d ",
++=======
+ 	ml += sprintf(msg+ml, "scsi %d:%d:%d:%llu %s",
++>>>>>>> 0d96ef5ff408 (hpsa: clean up host, channel, target, lun prints)
  		h->scsi_host->host_no, sc->device->channel,
- 		sc->device->id, sc->device->lun);
+ 		sc->device->id, sc->device->lun,
+ 		"Aborting command");
  
  	/* Find the device of the command to be aborted */
  	dev = sc->device->hostdata;
@@@ -4429,10 -4635,9 +4459,16 @@@
  	 */
  	rc = hpsa_send_abort_both_ways(h, dev->scsi3addr, abort);
  	if (rc != 0) {
++<<<<<<< HEAD
 +		dev_dbg(&h->pdev->dev, "%s Request FAILED.\n", msg);
 +		dev_warn(&h->pdev->dev, "FAILED abort on device C%d:B%d:T%d:L%d\n",
 +			h->scsi_host->host_no,
 +			dev->bus, dev->target, dev->lun);
++=======
+ 		hpsa_show_dev_msg(KERN_WARNING, h, dev,
+ 					"FAILED to abort command");
+ 		cmd_free(h, abort);
++>>>>>>> 0d96ef5ff408 (hpsa: clean up host, channel, target, lun prints)
  		return FAILED;
  	}
  	dev_info(&h->pdev->dev, "%s REQUEST SUCCEEDED.\n", msg);
* Unmerged path drivers/scsi/hpsa.c
