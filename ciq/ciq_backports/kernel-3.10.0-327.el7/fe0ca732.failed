macvlan: fix a race on port dismantle and possible skb leaks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Eric Dumazet <edumazet@google.com>
commit fe0ca7328d03d36aafecebb3af650e1bb2841c20
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/fe0ca732.failed

We need to cancel the work queue after rcu grace period,
otherwise it can be rescheduled by incoming packets.

We need to purge queue if some skbs are still in it.

We can use __skb_queue_head_init() variant in
macvlan_process_broadcast()

	Signed-off-by: Eric Dumazet <edumazet@google.com>
Fixes: 412ca1550cbec ("macvlan: Move broadcasts into a work queue")
	Cc: Herbert Xu <herbert@gondor.apana.org.au>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fe0ca7328d03d36aafecebb3af650e1bb2841c20)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/macvlan.c
diff --cc drivers/net/macvlan.c
index 6af48508e014,bfb0b6ec8c56..000000000000
--- a/drivers/net/macvlan.c
+++ b/drivers/net/macvlan.c
@@@ -180,6 -265,138 +180,141 @@@ static void macvlan_broadcast(struct sk
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void macvlan_process_broadcast(struct work_struct *w)
+ {
+ 	struct macvlan_port *port = container_of(w, struct macvlan_port,
+ 						 bc_work);
+ 	struct sk_buff *skb;
+ 	struct sk_buff_head list;
+ 
+ 	__skb_queue_head_init(&list);
+ 
+ 	spin_lock_bh(&port->bc_queue.lock);
+ 	skb_queue_splice_tail_init(&port->bc_queue, &list);
+ 	spin_unlock_bh(&port->bc_queue.lock);
+ 
+ 	while ((skb = __skb_dequeue(&list))) {
+ 		const struct macvlan_dev *src = MACVLAN_SKB_CB(skb)->src;
+ 
+ 		rcu_read_lock();
+ 
+ 		if (!src)
+ 			/* frame comes from an external address */
+ 			macvlan_broadcast(skb, port, NULL,
+ 					  MACVLAN_MODE_PRIVATE |
+ 					  MACVLAN_MODE_VEPA    |
+ 					  MACVLAN_MODE_PASSTHRU|
+ 					  MACVLAN_MODE_BRIDGE);
+ 		else if (src->mode == MACVLAN_MODE_VEPA)
+ 			/* flood to everyone except source */
+ 			macvlan_broadcast(skb, port, src->dev,
+ 					  MACVLAN_MODE_VEPA |
+ 					  MACVLAN_MODE_BRIDGE);
+ 		else
+ 			/*
+ 			 * flood only to VEPA ports, bridge ports
+ 			 * already saw the frame on the way out.
+ 			 */
+ 			macvlan_broadcast(skb, port, src->dev,
+ 					  MACVLAN_MODE_VEPA);
+ 
+ 		rcu_read_unlock();
+ 
+ 		kfree_skb(skb);
+ 	}
+ }
+ 
+ static void macvlan_broadcast_enqueue(struct macvlan_port *port,
+ 				      struct sk_buff *skb)
+ {
+ 	struct sk_buff *nskb;
+ 	int err = -ENOMEM;
+ 
+ 	nskb = skb_clone(skb, GFP_ATOMIC);
+ 	if (!nskb)
+ 		goto err;
+ 
+ 	spin_lock(&port->bc_queue.lock);
+ 	if (skb_queue_len(&port->bc_queue) < MACVLAN_BC_QUEUE_LEN) {
+ 		__skb_queue_tail(&port->bc_queue, nskb);
+ 		err = 0;
+ 	}
+ 	spin_unlock(&port->bc_queue.lock);
+ 
+ 	if (err)
+ 		goto free_nskb;
+ 
+ 	schedule_work(&port->bc_work);
+ 	return;
+ 
+ free_nskb:
+ 	kfree_skb(nskb);
+ err:
+ 	atomic_long_inc(&skb->dev->rx_dropped);
+ }
+ 
+ static void macvlan_flush_sources(struct macvlan_port *port,
+ 				  struct macvlan_dev *vlan)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < MACVLAN_HASH_SIZE; i++) {
+ 		struct hlist_node *h, *n;
+ 
+ 		hlist_for_each_safe(h, n, &port->vlan_source_hash[i]) {
+ 			struct macvlan_source_entry *entry;
+ 
+ 			entry = hlist_entry(h, struct macvlan_source_entry,
+ 					    hlist);
+ 			if (entry->vlan == vlan)
+ 				macvlan_hash_del_source(entry);
+ 		}
+ 	}
+ 	vlan->macaddr_count = 0;
+ }
+ 
+ static void macvlan_forward_source_one(struct sk_buff *skb,
+ 				       struct macvlan_dev *vlan)
+ {
+ 	struct sk_buff *nskb;
+ 	struct net_device *dev;
+ 	int len;
+ 	int ret;
+ 
+ 	dev = vlan->dev;
+ 	if (unlikely(!(dev->flags & IFF_UP)))
+ 		return;
+ 
+ 	nskb = skb_clone(skb, GFP_ATOMIC);
+ 	if (!nskb)
+ 		return;
+ 
+ 	len = nskb->len + ETH_HLEN;
+ 	nskb->dev = dev;
+ 	nskb->pkt_type = PACKET_HOST;
+ 
+ 	ret = netif_rx(nskb);
+ 	macvlan_count_rx(vlan, len, ret == NET_RX_SUCCESS, false);
+ }
+ 
+ static void macvlan_forward_source(struct sk_buff *skb,
+ 				   struct macvlan_port *port,
+ 				   const unsigned char *addr)
+ {
+ 	struct macvlan_source_entry *entry;
+ 	u32 idx = macvlan_eth_hash(addr);
+ 	struct hlist_head *h = &port->vlan_source_hash[idx];
+ 
+ 	hlist_for_each_entry_rcu(entry, h, hlist) {
+ 		if (ether_addr_equal_64bits(entry->addr, addr))
+ 			if (entry->vlan->dev->flags & IFF_UP)
+ 				macvlan_forward_source_one(skb, entry->vlan);
+ 	}
+ }
+ 
++>>>>>>> fe0ca7328d03 (macvlan: fix a race on port dismantle and possible skb leaks)
  /* called under rcu_read_lock() from netif_receive_skb */
  static rx_handler_result_t macvlan_handle_frame(struct sk_buff **pskb)
  {
* Unmerged path drivers/net/macvlan.c
