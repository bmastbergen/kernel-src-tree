ALSA: hda - Drop azx_sd_read*/write*() macros

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [alsa] hda - Drop azx_sd_read*/write*() macros (Jaroslav Kysela) [1197064]
Rebuild_FUZZ: 92.86%
commit-author Takashi Iwai <tiwai@suse.de>
commit 1604eeee8899e3b8421ba41b1abcdc48501bc0a0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/1604eeee.failed

They are no longer used (only one place which can be replaced with a
proper helper function).  Let's drop.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 1604eeee8899e3b8421ba41b1abcdc48501bc0a0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/hda_controller.h
#	sound/pci/hda/hda_intel.c
diff --cc sound/pci/hda/hda_controller.h
index 2993061145a5,407cba6577b8..000000000000
--- a/sound/pci/hda/hda_controller.h
+++ b/sound/pci/hda/hda_controller.h
@@@ -15,10 -15,178 +15,179 @@@
  #ifndef __SOUND_HDA_CONTROLLER_H
  #define __SOUND_HDA_CONTROLLER_H
  
 -#include <linux/timecounter.h>
 -#include <linux/interrupt.h>
  #include <sound/core.h>
 -#include <sound/pcm.h>
  #include <sound/initval.h>
  #include "hda_codec.h"
++<<<<<<< HEAD
 +#include "hda_priv.h"
++=======
+ #include <sound/hda_register.h>
+ 
+ #define AZX_MAX_CODECS		HDA_MAX_CODECS
+ #define AZX_DEFAULT_CODECS	4
+ 
+ /* driver quirks (capabilities) */
+ /* bits 0-7 are used for indicating driver type */
+ #define AZX_DCAPS_NO_TCSEL	(1 << 8)	/* No Intel TCSEL bit */
+ #define AZX_DCAPS_NO_MSI	(1 << 9)	/* No MSI support */
+ #define AZX_DCAPS_SNOOP_MASK	(3 << 10)	/* snoop type mask */
+ #define AZX_DCAPS_SNOOP_OFF	(1 << 12)	/* snoop default off */
+ #define AZX_DCAPS_RIRB_DELAY	(1 << 13)	/* Long delay in read loop */
+ #define AZX_DCAPS_RIRB_PRE_DELAY (1 << 14)	/* Put a delay before read */
+ #define AZX_DCAPS_CTX_WORKAROUND (1 << 15)	/* X-Fi workaround */
+ #define AZX_DCAPS_POSFIX_LPIB	(1 << 16)	/* Use LPIB as default */
+ #define AZX_DCAPS_POSFIX_VIA	(1 << 17)	/* Use VIACOMBO as default */
+ #define AZX_DCAPS_NO_64BIT	(1 << 18)	/* No 64bit address */
+ #define AZX_DCAPS_SYNC_WRITE	(1 << 19)	/* sync each cmd write */
+ #define AZX_DCAPS_OLD_SSYNC	(1 << 20)	/* Old SSYNC reg for ICH */
+ #define AZX_DCAPS_NO_ALIGN_BUFSIZE (1 << 21)	/* no buffer size alignment */
+ /* 22 unused */
+ #define AZX_DCAPS_4K_BDLE_BOUNDARY (1 << 23)	/* BDLE in 4k boundary */
+ #define AZX_DCAPS_REVERSE_ASSIGN (1 << 24)	/* Assign devices in reverse order */
+ #define AZX_DCAPS_COUNT_LPIB_DELAY  (1 << 25)	/* Take LPIB as delay */
+ #define AZX_DCAPS_PM_RUNTIME	(1 << 26)	/* runtime PM support */
+ #define AZX_DCAPS_I915_POWERWELL (1 << 27)	/* HSW i915 powerwell support */
+ #define AZX_DCAPS_CORBRP_SELF_CLEAR (1 << 28)	/* CORBRP clears itself after reset */
+ #define AZX_DCAPS_NO_MSI64      (1 << 29)	/* Stick to 32-bit MSIs */
+ #define AZX_DCAPS_SEPARATE_STREAM_TAG	(1 << 30) /* capture and playback use separate stream tag */
+ 
+ enum {
+ 	AZX_SNOOP_TYPE_NONE,
+ 	AZX_SNOOP_TYPE_SCH,
+ 	AZX_SNOOP_TYPE_ATI,
+ 	AZX_SNOOP_TYPE_NVIDIA,
+ };
+ 
+ struct azx_dev {
+ 	struct hdac_stream core;
+ 
+ 	unsigned int irq_pending:1;
+ 	unsigned int prepared:1;
+ 	/*
+ 	 * For VIA:
+ 	 *  A flag to ensure DMA position is 0
+ 	 *  when link position is not greater than FIFO size
+ 	 */
+ 	unsigned int insufficient:1;
+ 	unsigned int wc_marked:1;
+ };
+ 
+ #define azx_stream(dev)		(&(dev)->core)
+ #define stream_to_azx_dev(s)	container_of(s, struct azx_dev, core)
+ 
+ struct azx;
+ 
+ /* Functions to read/write to hda registers. */
+ struct hda_controller_ops {
+ 	/* Disable msi if supported, PCI only */
+ 	int (*disable_msi_reset_irq)(struct azx *);
+ 	int (*substream_alloc_pages)(struct azx *chip,
+ 				     struct snd_pcm_substream *substream,
+ 				     size_t size);
+ 	int (*substream_free_pages)(struct azx *chip,
+ 				    struct snd_pcm_substream *substream);
+ 	void (*pcm_mmap_prepare)(struct snd_pcm_substream *substream,
+ 				 struct vm_area_struct *area);
+ 	/* Check if current position is acceptable */
+ 	int (*position_check)(struct azx *chip, struct azx_dev *azx_dev);
+ };
+ 
+ struct azx_pcm {
+ 	struct azx *chip;
+ 	struct snd_pcm *pcm;
+ 	struct hda_codec *codec;
+ 	struct hda_pcm *info;
+ 	struct list_head list;
+ };
+ 
+ typedef unsigned int (*azx_get_pos_callback_t)(struct azx *, struct azx_dev *);
+ typedef int (*azx_get_delay_callback_t)(struct azx *, struct azx_dev *, unsigned int pos);
+ 
+ struct azx {
+ 	struct hda_bus bus;
+ 
+ 	struct snd_card *card;
+ 	struct pci_dev *pci;
+ 	int dev_index;
+ 
+ 	/* chip type specific */
+ 	int driver_type;
+ 	unsigned int driver_caps;
+ 	int playback_streams;
+ 	int playback_index_offset;
+ 	int capture_streams;
+ 	int capture_index_offset;
+ 	int num_streams;
+ 	const int *jackpoll_ms; /* per-card jack poll interval */
+ 
+ 	/* Register interaction. */
+ 	const struct hda_controller_ops *ops;
+ 
+ 	/* position adjustment callbacks */
+ 	azx_get_pos_callback_t get_position[2];
+ 	azx_get_delay_callback_t get_delay[2];
+ 
+ 	/* locks */
+ 	struct mutex open_mutex; /* Prevents concurrent open/close operations */
+ 
+ 	/* PCM */
+ 	struct list_head pcm_list; /* azx_pcm list */
+ 
+ 	/* HD codec */
+ 	int  codec_probe_mask; /* copied from probe_mask option */
+ 	unsigned int beep_mode;
+ 
+ #ifdef CONFIG_SND_HDA_PATCH_LOADER
+ 	const struct firmware *fw;
+ #endif
+ 
+ 	/* flags */
+ 	const int *bdl_pos_adj;
+ 	int poll_count;
+ 	unsigned int running:1;
+ 	unsigned int single_cmd:1;
+ 	unsigned int polling_mode:1;
+ 	unsigned int msi:1;
+ 	unsigned int probing:1; /* codec probing phase */
+ 	unsigned int snoop:1;
+ 	unsigned int align_buffer_size:1;
+ 	unsigned int region_requested:1;
+ 	unsigned int disabled:1; /* disabled by VGA-switcher */
+ 
+ #ifdef CONFIG_SND_HDA_DSP_LOADER
+ 	struct azx_dev saved_azx_dev;
+ #endif
+ };
+ 
+ #define azx_bus(chip)	(&(chip)->bus.core)
+ #define bus_to_azx(_bus)	container_of(_bus, struct azx, bus.core)
+ 
+ #ifdef CONFIG_X86
+ #define azx_snoop(chip)		((chip)->snoop)
+ #else
+ #define azx_snoop(chip)		true
+ #endif
+ 
+ /*
+  * macros for easy use
+  */
+ 
+ #define azx_writel(chip, reg, value) \
+ 	snd_hdac_chip_writel(azx_bus(chip), reg, value)
+ #define azx_readl(chip, reg) \
+ 	snd_hdac_chip_readl(azx_bus(chip), reg)
+ #define azx_writew(chip, reg, value) \
+ 	snd_hdac_chip_writew(azx_bus(chip), reg, value)
+ #define azx_readw(chip, reg) \
+ 	snd_hdac_chip_readw(azx_bus(chip), reg)
+ #define azx_writeb(chip, reg, value) \
+ 	snd_hdac_chip_writeb(azx_bus(chip), reg, value)
+ #define azx_readb(chip, reg) \
+ 	snd_hdac_chip_readb(azx_bus(chip), reg)
+ 
+ #define azx_has_pm_runtime(chip) \
+ 	(!AZX_DCAPS_PM_RUNTIME || ((chip)->driver_caps & AZX_DCAPS_PM_RUNTIME))
++>>>>>>> 1604eeee8899 (ALSA: hda - Drop azx_sd_read*/write*() macros)
  
  /* PCM setup */
  static inline struct azx_dev *get_azx_dev(struct snd_pcm_substream *substream)
diff --cc sound/pci/hda/hda_intel.c
index 8224bf75d072,2b823d4ad888..000000000000
--- a/sound/pci/hda/hda_intel.c
+++ b/sound/pci/hda/hda_intel.c
@@@ -675,8 -680,8 +675,13 @@@ static unsigned int azx_via_get_positio
  	unsigned int mod_link_pos, mod_dma_pos, mod_mini_pos;
  	unsigned int fifo_size;
  
++<<<<<<< HEAD
 +	link_pos = azx_sd_readl(chip, azx_dev, SD_LPIB);
 +	if (azx_dev->substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
++=======
+ 	link_pos = snd_hdac_stream_get_pos_lpib(azx_stream(azx_dev));
+ 	if (azx_dev->core.substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
++>>>>>>> 1604eeee8899 (ALSA: hda - Drop azx_sd_read*/write*() macros)
  		/* Playback, no problem using link position */
  		return link_pos;
  	}
* Unmerged path sound/pci/hda/hda_controller.h
* Unmerged path sound/pci/hda/hda_intel.c
