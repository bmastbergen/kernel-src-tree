dst: no need to take reference on DST_NOCACHE dsts

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Hannes Frederic Sowa <hannes@stressinduktion.org>
commit dbfc4fb7d578d4f224faa6b60deb40804dfdc1b1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/dbfc4fb7.failed

Since commit f8864972126899 ("ipv4: fix dst race in sk_dst_get()")
DST_NOCACHE dst_entries get freed by RCU. So there is no need to get a
reference on them when we are in rcu protected sections.

	Cc: Eric Dumazet <edumazet@google.com>
	Cc: Julian Anastasov <ja@ssi.bg>
	Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Reviewed-by: Julian Anastasov <ja@ssi.bg>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit dbfc4fb7d578d4f224faa6b60deb40804dfdc1b1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
diff --cc include/linux/skbuff.h
index 455a868105fd,ef64cec42804..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -706,9 -717,6 +706,12 @@@ static inline void skb_dst_set(struct s
  	skb->_skb_refdst = (unsigned long)dst;
  }
  
++<<<<<<< HEAD
 +extern void __skb_dst_set_noref(struct sk_buff *skb, struct dst_entry *dst,
 +				bool force);
 +
++=======
++>>>>>>> dbfc4fb7d578 (dst: no need to take reference on DST_NOCACHE dsts)
  /**
   * skb_dst_set_noref - sets skb dst, hopefully, without taking reference
   * @skb: buffer
* Unmerged path include/linux/skbuff.h
diff --git a/net/core/dst.c b/net/core/dst.c
index 4a1ea8899158..cf72ad440563 100644
--- a/net/core/dst.c
+++ b/net/core/dst.c
@@ -327,30 +327,6 @@ void __dst_destroy_metrics_generic(struct dst_entry *dst, unsigned long old)
 }
 EXPORT_SYMBOL(__dst_destroy_metrics_generic);
 
-/**
- * __skb_dst_set_noref - sets skb dst, without a reference
- * @skb: buffer
- * @dst: dst entry
- * @force: if force is set, use noref version even for DST_NOCACHE entries
- *
- * Sets skb dst, assuming a reference was not taken on dst
- * skb_dst_drop() should not dst_release() this dst
- */
-void __skb_dst_set_noref(struct sk_buff *skb, struct dst_entry *dst, bool force)
-{
-	WARN_ON(!rcu_read_lock_held() && !rcu_read_lock_bh_held());
-	/* If dst not in cache, we must take a reference, because
-	 * dst_release() will destroy dst as soon as its refcount becomes zero
-	 */
-	if (unlikely((dst->flags & DST_NOCACHE) && !force)) {
-		dst_hold(dst);
-		skb_dst_set(skb, dst);
-	} else {
-		skb->_skb_refdst = (unsigned long)dst | SKB_DST_NOREF;
-	}
-}
-EXPORT_SYMBOL(__skb_dst_set_noref);
-
 /* Dirty hack. We did it in 2.2 (in __dst_free),
  * we have _very_ good reasons not to repeat
  * this mistake in 2.3, but we have no choice
diff --git a/net/netfilter/ipvs/ip_vs_xmit.c b/net/netfilter/ipvs/ip_vs_xmit.c
index c47444e4cf8c..7cf60affeb00 100644
--- a/net/netfilter/ipvs/ip_vs_xmit.c
+++ b/net/netfilter/ipvs/ip_vs_xmit.c
@@ -275,7 +275,7 @@ __ip_vs_get_out_rt(struct sk_buff *skb, struct ip_vs_dest *dest,
 	skb_dst_drop(skb);
 	if (noref) {
 		if (!local)
-			skb_dst_set_noref_force(skb, &rt->dst);
+			skb_dst_set_noref(skb, &rt->dst);
 		else
 			skb_dst_set(skb, dst_clone(&rt->dst));
 	} else
@@ -454,7 +454,7 @@ __ip_vs_get_out_rt_v6(struct sk_buff *skb, struct ip_vs_dest *dest,
 	skb_dst_drop(skb);
 	if (noref) {
 		if (!local)
-			skb_dst_set_noref_force(skb, &rt->dst);
+			skb_dst_set_noref(skb, &rt->dst);
 		else
 			skb_dst_set(skb, dst_clone(&rt->dst));
 	} else
