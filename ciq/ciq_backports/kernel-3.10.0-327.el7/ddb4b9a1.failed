fib_trie: Address possible NULL pointer dereference in resize

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Alexander Duyck <alexander.h.duyck@redhat.com>
commit ddb4b9a1328ea89733133e86cf1972d23891abfc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/ddb4b9a1.failed

If the inflate call failed it would return NULL.  As a result tp would be
set to NULL and cause use to trigger a NULL pointer dereference in
should_halve if the inflate failed on the first attempt.

In order to prevent this we should decrement max_work before we actually
attempt to inflate as this will force us to exit before attempting to halve
a node we should have inflated.  In order to keep things symmetric between
inflate and halve I went ahead and also moved the decrement of max_work for
the halve case as well so we take care of that before we actually attempt
to halve the tnode.

Fixes: 88bae714 ("fib_trie: Add key vector to root, return parent key_vector in resize")
	Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
	Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ddb4b9a1328ea89733133e86cf1972d23891abfc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/fib_trie.c
diff --cc net/ipv4/fib_trie.c
index 8be89b1a8b93,83290beaf7cf..000000000000
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@@ -816,16 -830,16 +816,26 @@@ static void resize(struct trie *t, stru
  	/* Double as long as the resulting node has a number of
  	 * nonempty nodes that are above the threshold.
  	 */
++<<<<<<< HEAD
 +	while (should_inflate(tp, tn) && max_work) {
 +		if (inflate(t, tn)) {
++=======
+ 	while (should_inflate(tp, tn) && max_work--) {
+ 		tp = inflate(t, tn);
+ 		if (!tp) {
++>>>>>>> ddb4b9a1328e (fib_trie: Address possible NULL pointer dereference in resize)
  #ifdef CONFIG_IP_FIB_TRIE_STATS
 -			this_cpu_inc(stats->resize_node_skipped);
 +			this_cpu_inc(t->stats->resize_node_skipped);
  #endif
  			break;
  		}
  
++<<<<<<< HEAD
 +		max_work--;
 +		tn = rtnl_dereference(*cptr);
++=======
+ 		tn = get_child(tp, cindex);
++>>>>>>> ddb4b9a1328e (fib_trie: Address possible NULL pointer dereference in resize)
  	}
  
  	/* Return if at least one inflate is run */
@@@ -835,16 -849,16 +845,26 @@@
  	/* Halve as long as the number of empty children in this
  	 * node is above threshold.
  	 */
++<<<<<<< HEAD
 +	while (should_halve(tp, tn) && max_work) {
 +		if (halve(t, tn)) {
++=======
+ 	while (should_halve(tp, tn) && max_work--) {
+ 		tp = halve(t, tn);
+ 		if (!tp) {
++>>>>>>> ddb4b9a1328e (fib_trie: Address possible NULL pointer dereference in resize)
  #ifdef CONFIG_IP_FIB_TRIE_STATS
 -			this_cpu_inc(stats->resize_node_skipped);
 +			this_cpu_inc(t->stats->resize_node_skipped);
  #endif
  			break;
  		}
  
++<<<<<<< HEAD
 +		max_work--;
 +		tn = rtnl_dereference(*cptr);
++=======
+ 		tn = get_child(tp, cindex);
++>>>>>>> ddb4b9a1328e (fib_trie: Address possible NULL pointer dereference in resize)
  	}
  
  	/* Only one child remains */
* Unmerged path net/ipv4/fib_trie.c
