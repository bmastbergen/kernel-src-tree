ACPI / LPSS: Take I2C host controllers out of reset

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [acpi] lpss: Take I2C host controllers out of reset (Prarit Bhargava) [1178891]
Rebuild_FUZZ: 92.63%
commit-author Mika Westerberg <mika.westerberg@linux.intel.com>
commit 765bdd4e51674c1ae3a61ceb12a05706bf6b691b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/765bdd4e.failed

On Intel Baytrail, some I2C host controllers are held in reset when the OS
gets control. This causes the driver to fail to detect the hardware
properly.

Fix this so that we make sure that the I2C host controller is not in reset
when the driver gets probe'd.

	Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 765bdd4e51674c1ae3a61ceb12a05706bf6b691b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/acpi_lpss.c
diff --cc drivers/acpi/acpi_lpss.c
index ed5dc78f528a,9cb65b0e7597..000000000000
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@@ -28,6 -33,10 +28,13 @@@ ACPI_MODULE_NAME("acpi_lpss")
  #define LPSS_LTR_SIZE	0x18
  
  /* Offsets relative to LPSS_PRIVATE_OFFSET */
++<<<<<<< HEAD
++=======
+ #define LPSS_CLK_DIVIDER_DEF_MASK	(BIT(1) | BIT(16))
+ #define LPSS_RESETS			0x04
+ #define LPSS_RESETS_RESET_FUNC		BIT(0)
+ #define LPSS_RESETS_RESET_APB		BIT(1)
++>>>>>>> 765bdd4e5167 (ACPI / LPSS: Take I2C host controllers out of reset)
  #define LPSS_GENERAL			0x08
  #define LPSS_GENERAL_LTR_MODE_SW	BIT(2)
  #define LPSS_GENERAL_UART_RTS_OVRD	BIT(3)
@@@ -88,7 -102,26 +95,18 @@@ static void lpss_uart_setup(struct lpss
  	writel(reg | LPSS_GENERAL_UART_RTS_OVRD, pdata->mmio_base + offset);
  }
  
+ static void lpss_i2c_setup(struct lpss_private_data *pdata)
+ {
+ 	unsigned int offset;
+ 	u32 val;
+ 
+ 	offset = pdata->dev_desc->prv_offset + LPSS_RESETS;
+ 	val = readl(pdata->mmio_base + offset);
+ 	val |= LPSS_RESETS_RESET_APB | LPSS_RESETS_RESET_FUNC;
+ 	writel(val, pdata->mmio_base + offset);
+ }
+ 
  static struct lpss_device_desc lpt_dev_desc = {
 -	.clk_required = true,
 -	.prv_offset = 0x800,
 -	.ltr_required = true,
 -	.clk_divider = true,
 -	.clk_gate = true,
 -};
 -
 -static struct lpss_device_desc lpt_i2c_dev_desc = {
  	.clk_required = true,
  	.prv_offset = 0x800,
  	.ltr_required = true,
@@@ -146,21 -183,29 +164,22 @@@ static struct lpss_shared_clock i2c_clo
  static struct lpss_device_desc byt_i2c_dev_desc = {
  	.clk_required = true,
  	.prv_offset = 0x800,
 -	.save_ctx = true,
  	.shared_clock = &i2c_clock,
+ 	.setup = lpss_i2c_setup,
  };
  
 -#else
 -
 -#define LPSS_ADDR(desc) (0UL)
 -
 -#endif /* CONFIG_X86_INTEL_LPSS */
 -
  static const struct acpi_device_id acpi_lpss_device_ids[] = {
  	/* Generic LPSS devices */
 -	{ "INTL9C60", LPSS_ADDR(lpss_dma_desc) },
 +	{ "INTL9C60", (unsigned long)&lpss_dma_desc },
  
  	/* Lynxpoint LPSS devices */
 -	{ "INT33C0", LPSS_ADDR(lpt_dev_desc) },
 -	{ "INT33C1", LPSS_ADDR(lpt_dev_desc) },
 -	{ "INT33C2", LPSS_ADDR(lpt_i2c_dev_desc) },
 -	{ "INT33C3", LPSS_ADDR(lpt_i2c_dev_desc) },
 -	{ "INT33C4", LPSS_ADDR(lpt_uart_dev_desc) },
 -	{ "INT33C5", LPSS_ADDR(lpt_uart_dev_desc) },
 -	{ "INT33C6", LPSS_ADDR(lpt_sdio_dev_desc) },
 +	{ "INT33C0", (unsigned long)&lpt_dev_desc },
 +	{ "INT33C1", (unsigned long)&lpt_dev_desc },
 +	{ "INT33C2", (unsigned long)&lpt_dev_desc },
 +	{ "INT33C3", (unsigned long)&lpt_dev_desc },
 +	{ "INT33C4", (unsigned long)&lpt_uart_dev_desc },
 +	{ "INT33C5", (unsigned long)&lpt_uart_dev_desc },
 +	{ "INT33C6", (unsigned long)&lpt_sdio_dev_desc },
  	{ "INT33C7", },
  
  	/* BayTrail LPSS devices */
* Unmerged path drivers/acpi/acpi_lpss.c
