ALSA: hda - Update to use the new jack kctls method

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [alsa] hda - Update to use the new jack kctls method (Jaroslav Kysela) [1197064]
Rebuild_FUZZ: 93.75%
commit-author Jie Yang <yang.jie@intel.com>
commit 2ba2dfa1fcc7ce5d2bf1716ec3d32b6fa0882e68
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/2ba2dfa1.failed

Jack snd_kcontrols can now be created during snd_jack_new()
or by later calling snd_jack_add_new_kctls().

This patch creates the jacks during the initialisation stage
for both phantom and non phantom jacks.

	Signed-off-by: Jie Yang <yang.jie@intel.com>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 2ba2dfa1fcc7ce5d2bf1716ec3d32b6fa0882e68)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/sound/control.h
#	sound/core/ctljack.c
#	sound/core/jack.c
#	sound/pci/hda/hda_jack.c
diff --cc include/sound/control.h
index 75f3054023f7,21d047f229a1..000000000000
--- a/include/sound/control.h
+++ b/include/sound/control.h
@@@ -252,7 -252,7 +252,11 @@@ void snd_ctl_sync_vmaster(struct snd_kc
   * Helper functions for jack-detection controls
   */
  struct snd_kcontrol *
++<<<<<<< HEAD
 +snd_kctl_jack_new(const char *name, int idx, void *private_data);
++=======
+ snd_kctl_jack_new(const char *name, struct snd_card *card);
++>>>>>>> 2ba2dfa1fcc7 (ALSA: hda - Update to use the new jack kctls method)
  void snd_kctl_jack_report(struct snd_card *card,
  			  struct snd_kcontrol *kctl, bool status);
  
diff --cc sound/core/ctljack.c
index e4b38fbe51da,6435e82cacf9..000000000000
--- a/sound/core/ctljack.c
+++ b/sound/core/ctljack.c
@@@ -31,15 -31,46 +31,23 @@@ static struct snd_kcontrol_new jack_det
  	.get = jack_detect_kctl_get,
  };
  
 -static int get_available_index(struct snd_card *card, const char *name)
 -{
 -	struct snd_ctl_elem_id sid;
 -
 -	memset(&sid, 0, sizeof(sid));
 -
 -	sid.index = 0;
 -	sid.iface = SNDRV_CTL_ELEM_IFACE_CARD;
 -	strlcpy(sid.name, name, sizeof(sid.name));
 -
 -	while (snd_ctl_find_id(card, &sid))
 -		sid.index++;
 -
 -	return sid.index;
 -}
 -
 -static void jack_kctl_name_gen(char *name, const char *src_name, int size)
 -{
 -	size_t count = strlen(src_name);
 -	bool need_cat = true;
 -
 -	/* remove redundant " Jack" from src_name */
 -	if (count >= 5)
 -		need_cat = strncmp(&src_name[count - 5], " Jack", 5) ? true : false;
 -
 -	snprintf(name, size, need_cat ? "%s Jack" : "%s", src_name);
 -
 -}
 -
  struct snd_kcontrol *
++<<<<<<< HEAD
 +snd_kctl_jack_new(const char *name, int idx, void *private_data)
 +{
 +	struct snd_kcontrol *kctl;
 +	kctl = snd_ctl_new1(&jack_detect_kctl, private_data);
++=======
+ snd_kctl_jack_new(const char *name, struct snd_card *card)
+ {
+ 	struct snd_kcontrol *kctl;
+ 
+ 	kctl = snd_ctl_new1(&jack_detect_kctl, NULL);
++>>>>>>> 2ba2dfa1fcc7 (ALSA: hda - Update to use the new jack kctls method)
  	if (!kctl)
  		return NULL;
 -
 -	jack_kctl_name_gen(kctl->id.name, name, sizeof(kctl->id.name));
 -	kctl->id.index = get_available_index(card, name);
 +	snprintf(kctl->id.name, sizeof(kctl->id.name), "%s Jack", name);
 +	kctl->id.index = idx;
  	kctl->private_value = 0;
  	return kctl;
  }
diff --cc sound/core/jack.c
index 8658578eb584,e8b51f52e7df..000000000000
--- a/sound/core/jack.c
+++ b/sound/core/jack.c
@@@ -100,6 -113,77 +100,80 @@@ static int snd_jack_dev_register(struc
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static void snd_jack_kctl_private_free(struct snd_kcontrol *kctl)
+ {
+ 	struct snd_jack_kctl *jack_kctl;
+ 
+ 	jack_kctl = kctl->private_data;
+ 	if (jack_kctl) {
+ 		list_del(&jack_kctl->list);
+ 		kfree(jack_kctl);
+ 	}
+ }
+ 
+ static void snd_jack_kctl_add(struct snd_jack *jack, struct snd_jack_kctl *jack_kctl)
+ {
+ 	list_add_tail(&jack_kctl->list, &jack->kctl_list);
+ }
+ 
+ static struct snd_jack_kctl * snd_jack_kctl_new(struct snd_card *card, const char *name, unsigned int mask)
+ {
+ 	struct snd_kcontrol *kctl;
+ 	struct snd_jack_kctl *jack_kctl;
+ 	int err;
+ 
+ 	kctl = snd_kctl_jack_new(name, card);
+ 	if (!kctl)
+ 		return NULL;
+ 
+ 	err = snd_ctl_add(card, kctl);
+ 	if (err < 0)
+ 		return NULL;
+ 
+ 	jack_kctl = kzalloc(sizeof(*jack_kctl), GFP_KERNEL);
+ 
+ 	if (!jack_kctl)
+ 		goto error;
+ 
+ 	jack_kctl->kctl = kctl;
+ 	jack_kctl->mask_bits = mask;
+ 
+ 	kctl->private_data = jack_kctl;
+ 	kctl->private_free = snd_jack_kctl_private_free;
+ 
+ 	return jack_kctl;
+ error:
+ 	snd_ctl_free_one(kctl);
+ 	return NULL;
+ }
+ 
+ /**
+  * snd_jack_add_new_kctl - Create a new snd_jack_kctl and add it to jack
+  * @jack:  the jack instance which the kctl will attaching to
+  * @name:  the name for the snd_kcontrol object
+  * @mask:  a bitmask of enum snd_jack_type values that can be detected
+  *         by this snd_jack_kctl object.
+  *
+  * Creates a new snd_kcontrol object and adds it to the jack kctl_list.
+  *
+  * Return: Zero if successful, or a negative error code on failure.
+  */
+ int snd_jack_add_new_kctl(struct snd_jack *jack, const char * name, int mask)
+ {
+ 	struct snd_jack_kctl *jack_kctl;
+ 
+ 	jack_kctl = snd_jack_kctl_new(jack->card, name, mask);
+ 	if (!jack_kctl)
+ 		return -ENOMEM;
+ 
+ 	snd_jack_kctl_add(jack, jack_kctl);
+ 	return 0;
+ }
+ EXPORT_SYMBOL(snd_jack_add_new_kctl);
+ 
++>>>>>>> 2ba2dfa1fcc7 (ALSA: hda - Update to use the new jack kctls method)
  /**
   * snd_jack_new - Create a new jack
   * @card:  the card instance
diff --cc sound/pci/hda/hda_jack.c
index d7cfe7b8c32b,366efbf87d41..000000000000
--- a/sound/pci/hda/hda_jack.c
+++ b/sound/pci/hda/hda_jack.c
@@@ -400,31 -392,22 +392,45 @@@ static int __snd_hda_jack_add_kctl(stru
  	jack = snd_hda_jack_tbl_new(codec, nid);
  	if (!jack)
  		return 0;
- 	if (jack->kctl)
+ 	if (jack->jack)
  		return 0; /* already created */
++<<<<<<< HEAD
 +	kctl = snd_kctl_jack_new(name, idx, codec);
 +	if (!kctl)
 +		return -ENOMEM;
 +	err = snd_hda_ctl_add(codec, nid, kctl);
++=======
+ 
+ 	type = get_input_jack_type(codec, nid);
+ 	err = snd_jack_new(codec->card, name, type,
+ 			   &jack->jack, true, phantom_jack);
++>>>>>>> 2ba2dfa1fcc7 (ALSA: hda - Update to use the new jack kctls method)
  	if (err < 0)
  		return err;
- 	jack->kctl = kctl;
- 	jack->phantom_jack = !!phantom_jack;
  
+ 	jack->phantom_jack = !!phantom_jack;
+ 	jack->type = type;
+ 	jack->jack->private_data = jack;
+ 	jack->jack->private_free = hda_free_jack_priv;
  	state = snd_hda_jack_detect(codec, nid);
++<<<<<<< HEAD
 +	snd_kctl_jack_report(codec->card, kctl, state);
 +#ifdef CONFIG_SND_HDA_INPUT_JACK
 +	if (!phantom_jack) {
 +		jack->type = get_input_jack_type(codec, nid);
 +		err = snd_jack_new(codec->card, name, jack->type,
 +				   &jack->jack);
 +		if (err < 0)
 +			return err;
 +		jack->jack->private_data = jack;
 +		jack->jack->private_free = hda_free_jack_priv;
 +		snd_jack_report(jack->jack, state ? jack->type : 0);
 +	}
 +#endif
++=======
+ 	snd_jack_report(jack->jack, state ? jack->type : 0);
+ 
++>>>>>>> 2ba2dfa1fcc7 (ALSA: hda - Update to use the new jack kctls method)
  	return 0;
  }
  
* Unmerged path include/sound/control.h
* Unmerged path sound/core/ctljack.c
* Unmerged path sound/core/jack.c
* Unmerged path sound/pci/hda/hda_jack.c
diff --git a/sound/pci/hda/hda_jack.h b/sound/pci/hda/hda_jack.h
index b279e327a23b..387d30984dfe 100644
--- a/sound/pci/hda/hda_jack.h
+++ b/sound/pci/hda/hda_jack.h
@@ -39,11 +39,8 @@ struct hda_jack_tbl {
 	unsigned int block_report:1;    /* in a transitional state - do not report to userspace */
 	hda_nid_t gating_jack;		/* valid when gating jack plugged */
 	hda_nid_t gated_jack;		/* gated is dependent on this jack */
-	struct snd_kcontrol *kctl;	/* assigned kctl for jack-detection */
-#ifdef CONFIG_SND_HDA_INPUT_JACK
 	int type;
 	struct snd_jack *jack;
-#endif
 };
 
 struct hda_jack_tbl *
@@ -85,7 +82,7 @@ static inline bool snd_hda_jack_detect(struct hda_codec *codec, hda_nid_t nid)
 bool is_jack_detectable(struct hda_codec *codec, hda_nid_t nid);
 
 int snd_hda_jack_add_kctl(struct hda_codec *codec, hda_nid_t nid,
-			  const char *name, int idx);
+			  const char *name);
 int snd_hda_jack_add_kctls(struct hda_codec *codec,
 			   const struct auto_pin_cfg *cfg);
 
diff --git a/sound/pci/hda/patch_hdmi.c b/sound/pci/hda/patch_hdmi.c
index 6b5acaea2dba..8c938a90cc87 100644
--- a/sound/pci/hda/patch_hdmi.c
+++ b/sound/pci/hda/patch_hdmi.c
@@ -2082,7 +2082,7 @@ static int generic_hdmi_build_jack(struct hda_codec *codec, int pin_idx)
 		strncat(hdmi_str, " Phantom",
 			sizeof(hdmi_str) - strlen(hdmi_str) - 1);
 
-	return snd_hda_jack_add_kctl(codec, per_pin->pin_nid, hdmi_str, 0);
+	return snd_hda_jack_add_kctl(codec, per_pin->pin_nid, hdmi_str);
 }
 
 static int generic_hdmi_build_controls(struct hda_codec *codec)
