PCI: pciehp: Reduce PCIe slot_ctrl to 16 bits

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [pci] pciehp: Reduce PCIe slot_ctrl to 16 bits (Myron Stowe) [1227034]
Rebuild_FUZZ: 94.12%
commit-author Bjorn Helgaas <bhelgaas@google.com>
commit d537a3abb4b7085ebc3ce35e64acbad8ece1eece
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/d537a3ab.failed

4283c70e91dc ("PCI: pciehp: Make pcie_wait_cmd() self-contained") added
a cache of the most recent command written to the Slot Control register.
This register is only 16 bits wide, but the cache ("slot_ctrl") is 32 bits.

Reduce slot_ctrl to a u16 so it matches the register size.  No functional
change.

	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit d537a3abb4b7085ebc3ce35e64acbad8ece1eece)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/pciehp.h
#	drivers/pci/hotplug/pciehp_hpc.c
diff --cc drivers/pci/hotplug/pciehp.h
index 7bae08bc1a61,b11521953485..000000000000
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@@ -92,9 -92,10 +92,13 @@@ struct controller 
  	struct slot *slot;
  	wait_queue_head_t queue;	/* sleep & wake process */
  	u32 slot_cap;
++<<<<<<< HEAD
++=======
+ 	u16 slot_ctrl;
++>>>>>>> d537a3abb4b7 (PCI: pciehp: Reduce PCIe slot_ctrl to 16 bits)
  	struct timer_list poll_timer;
 -	unsigned long cmd_started;	/* jiffies */
  	unsigned int cmd_busy:1;
 +	unsigned int no_cmd_complete:1;
  	unsigned int link_active_reporting:1;
  	unsigned int notification_enabled:1;
  	unsigned int power_fault_detected;
diff --cc drivers/pci/hotplug/pciehp_hpc.c
index f253bb808636,9e0f4aec5f0c..000000000000
--- a/drivers/pci/hotplug/pciehp_hpc.c
+++ b/drivers/pci/hotplug/pciehp_hpc.c
@@@ -129,18 -128,52 +129,24 @@@ static int pcie_poll_cmd(struct control
  	return 0;	/* timeout */
  }
  
 -static void pcie_wait_cmd(struct controller *ctrl)
 +static void pcie_wait_cmd(struct controller *ctrl, int poll)
  {
  	unsigned int msecs = pciehp_poll_mode ? 2500 : 1000;
 -	unsigned long duration = msecs_to_jiffies(msecs);
 -	unsigned long cmd_timeout = ctrl->cmd_started + duration;
 -	unsigned long now, timeout;
 +	unsigned long timeout = msecs_to_jiffies(msecs);
  	int rc;
  
 -	/*
 -	 * If the controller does not generate notifications for command
 -	 * completions, we never need to wait between writes.
 -	 */
 -	if (NO_CMD_CMPL(ctrl))
 -		return;
 -
 -	if (!ctrl->cmd_busy)
 -		return;
 -
 -	/*
 -	 * Even if the command has already timed out, we want to call
 -	 * pcie_poll_cmd() so it can clear PCI_EXP_SLTSTA_CC.
 -	 */
 -	now = jiffies;
 -	if (time_before_eq(cmd_timeout, now))
 -		timeout = 1;
 +	if (poll)
 +		rc = pcie_poll_cmd(ctrl);
  	else
 -		timeout = cmd_timeout - now;
 -
 -	if (ctrl->slot_ctrl & PCI_EXP_SLTCTL_HPIE &&
 -	    ctrl->slot_ctrl & PCI_EXP_SLTCTL_CCIE)
  		rc = wait_event_timeout(ctrl->queue, !ctrl->cmd_busy, timeout);
 -	else
 -		rc = pcie_poll_cmd(ctrl, timeout);
 -
 -	/*
 -	 * Controllers with errata like Intel CF118 don't generate
 -	 * completion notifications unless the power/indicator/interlock
 -	 * control bits are changed.  On such controllers, we'll emit this
 -	 * timeout message when we wait for completion of commands that
 -	 * don't change those bits, e.g., commands that merely enable
 -	 * interrupts.
 -	 */
  	if (!rc)
++<<<<<<< HEAD
 +		ctrl_dbg(ctrl, "Command not completed in 1000 msec\n");
++=======
+ 		ctrl_info(ctrl, "Timeout on hotplug command %#06x (issued %u msec ago)\n",
+ 			  ctrl->slot_ctrl,
+ 			  jiffies_to_msecs(now - ctrl->cmd_started));
++>>>>>>> d537a3abb4b7 (PCI: pciehp: Reduce PCIe slot_ctrl to 16 bits)
  }
  
  /**
* Unmerged path drivers/pci/hotplug/pciehp.h
* Unmerged path drivers/pci/hotplug/pciehp_hpc.c
