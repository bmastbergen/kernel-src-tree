cxl: Fix device_node reference counting

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Ryan Grimm <grimm@linux.vnet.ibm.com>
commit 6f963ec2d6bf2476a16799eece920acb2100ff1c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/6f963ec2.failed

When unbinding and rebinding the driver on a system with a card in PHB0, this
error condition is reached after a few attempts:

ERROR: Bad of_node_put() on /pciex@3fffe40000000
CPU: 0 PID: 3040 Comm: bash Not tainted 3.18.0-rc3-12545-g3627ffe #152
Call Trace:
[c000000721acb5c0] [c00000000086ef94] .dump_stack+0x84/0xb0 (unreliable)
[c000000721acb640] [c00000000073a0a8] .of_node_release+0xd8/0xe0
[c000000721acb6d0] [c00000000044bc44] .kobject_release+0x74/0xe0
[c000000721acb760] [c0000000007394fc] .of_node_put+0x1c/0x30
[c000000721acb7d0] [c000000000545cd8] .cxl_probe+0x1a98/0x1d50
[c000000721acb900] [c0000000004845a0] .local_pci_probe+0x40/0xc0
[c000000721acb980] [c000000000484998] .pci_device_probe+0x128/0x170
[c000000721acba30] [c00000000052400c] .driver_probe_device+0xac/0x2a0
[c000000721acbad0] [c000000000522468] .bind_store+0x108/0x160
[c000000721acbb70] [c000000000521448] .drv_attr_store+0x38/0x60
[c000000721acbbe0] [c000000000293840] .sysfs_kf_write+0x60/0xa0
[c000000721acbc50] [c000000000292500] .kernfs_fop_write+0x140/0x1d0
[c000000721acbcf0] [c000000000208648] .vfs_write+0xd8/0x260
[c000000721acbd90] [c000000000208b18] .SyS_write+0x58/0x100
[c000000721acbe30] [c000000000009258] syscall_exit+0x0/0x98

We are missing a call to of_node_get(). pnv_pci_to_phb_node() should
call of_node_get() otherwise np's reference count isn't incremented and
it might go away. Rename pnv_pci_to_phb_node() to pnv_pci_get_phb_node()
so it's clear it calls of_node_get().

	Signed-off-by: Ryan Grimm <grimm@linux.vnet.ibm.com>
	Acked-by: Ian Munsie <imunsie@au1.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 6f963ec2d6bf2476a16799eece920acb2100ff1c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/pnv-pci.h
#	arch/powerpc/platforms/powernv/pci-ioda.c
diff --cc arch/powerpc/platforms/powernv/pci-ioda.c
index 2f4bac41fe49,6c9ff2b95119..000000000000
--- a/arch/powerpc/platforms/powernv/pci-ioda.c
+++ b/arch/powerpc/platforms/powernv/pci-ioda.c
@@@ -991,6 -1485,157 +991,160 @@@ static void set_msi_irq_chip(struct pnv
  	irq_set_chip(virq, &phb->ioda.irq_chip);
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_CXL_BASE
+ 
+ struct device_node *pnv_pci_get_phb_node(struct pci_dev *dev)
+ {
+ 	struct pci_controller *hose = pci_bus_to_host(dev->bus);
+ 
+ 	return of_node_get(hose->dn);
+ }
+ EXPORT_SYMBOL(pnv_pci_get_phb_node);
+ 
+ int pnv_phb_to_cxl_mode(struct pci_dev *dev, uint64_t mode)
+ {
+ 	struct pci_controller *hose = pci_bus_to_host(dev->bus);
+ 	struct pnv_phb *phb = hose->private_data;
+ 	struct pnv_ioda_pe *pe;
+ 	int rc;
+ 
+ 	pe = pnv_ioda_get_pe(dev);
+ 	if (!pe)
+ 		return -ENODEV;
+ 
+ 	pe_info(pe, "Switching PHB to CXL\n");
+ 
+ 	rc = opal_pci_set_phb_cxl_mode(phb->opal_id, mode, pe->pe_number);
+ 	if (rc)
+ 		dev_err(&dev->dev, "opal_pci_set_phb_cxl_mode failed: %i\n", rc);
+ 
+ 	return rc;
+ }
+ EXPORT_SYMBOL(pnv_phb_to_cxl_mode);
+ 
+ /* Find PHB for cxl dev and allocate MSI hwirqs?
+  * Returns the absolute hardware IRQ number
+  */
+ int pnv_cxl_alloc_hwirqs(struct pci_dev *dev, int num)
+ {
+ 	struct pci_controller *hose = pci_bus_to_host(dev->bus);
+ 	struct pnv_phb *phb = hose->private_data;
+ 	int hwirq = msi_bitmap_alloc_hwirqs(&phb->msi_bmp, num);
+ 
+ 	if (hwirq < 0) {
+ 		dev_warn(&dev->dev, "Failed to find a free MSI\n");
+ 		return -ENOSPC;
+ 	}
+ 
+ 	return phb->msi_base + hwirq;
+ }
+ EXPORT_SYMBOL(pnv_cxl_alloc_hwirqs);
+ 
+ void pnv_cxl_release_hwirqs(struct pci_dev *dev, int hwirq, int num)
+ {
+ 	struct pci_controller *hose = pci_bus_to_host(dev->bus);
+ 	struct pnv_phb *phb = hose->private_data;
+ 
+ 	msi_bitmap_free_hwirqs(&phb->msi_bmp, hwirq - phb->msi_base, num);
+ }
+ EXPORT_SYMBOL(pnv_cxl_release_hwirqs);
+ 
+ void pnv_cxl_release_hwirq_ranges(struct cxl_irq_ranges *irqs,
+ 				  struct pci_dev *dev)
+ {
+ 	struct pci_controller *hose = pci_bus_to_host(dev->bus);
+ 	struct pnv_phb *phb = hose->private_data;
+ 	int i, hwirq;
+ 
+ 	for (i = 1; i < CXL_IRQ_RANGES; i++) {
+ 		if (!irqs->range[i])
+ 			continue;
+ 		pr_devel("cxl release irq range 0x%x: offset: 0x%lx  limit: %ld\n",
+ 			 i, irqs->offset[i],
+ 			 irqs->range[i]);
+ 		hwirq = irqs->offset[i] - phb->msi_base;
+ 		msi_bitmap_free_hwirqs(&phb->msi_bmp, hwirq,
+ 				       irqs->range[i]);
+ 	}
+ }
+ EXPORT_SYMBOL(pnv_cxl_release_hwirq_ranges);
+ 
+ int pnv_cxl_alloc_hwirq_ranges(struct cxl_irq_ranges *irqs,
+ 			       struct pci_dev *dev, int num)
+ {
+ 	struct pci_controller *hose = pci_bus_to_host(dev->bus);
+ 	struct pnv_phb *phb = hose->private_data;
+ 	int i, hwirq, try;
+ 
+ 	memset(irqs, 0, sizeof(struct cxl_irq_ranges));
+ 
+ 	/* 0 is reserved for the multiplexed PSL DSI interrupt */
+ 	for (i = 1; i < CXL_IRQ_RANGES && num; i++) {
+ 		try = num;
+ 		while (try) {
+ 			hwirq = msi_bitmap_alloc_hwirqs(&phb->msi_bmp, try);
+ 			if (hwirq >= 0)
+ 				break;
+ 			try /= 2;
+ 		}
+ 		if (!try)
+ 			goto fail;
+ 
+ 		irqs->offset[i] = phb->msi_base + hwirq;
+ 		irqs->range[i] = try;
+ 		pr_devel("cxl alloc irq range 0x%x: offset: 0x%lx  limit: %li\n",
+ 			 i, irqs->offset[i], irqs->range[i]);
+ 		num -= try;
+ 	}
+ 	if (num)
+ 		goto fail;
+ 
+ 	return 0;
+ fail:
+ 	pnv_cxl_release_hwirq_ranges(irqs, dev);
+ 	return -ENOSPC;
+ }
+ EXPORT_SYMBOL(pnv_cxl_alloc_hwirq_ranges);
+ 
+ int pnv_cxl_get_irq_count(struct pci_dev *dev)
+ {
+ 	struct pci_controller *hose = pci_bus_to_host(dev->bus);
+ 	struct pnv_phb *phb = hose->private_data;
+ 
+ 	return phb->msi_bmp.irq_count;
+ }
+ EXPORT_SYMBOL(pnv_cxl_get_irq_count);
+ 
+ int pnv_cxl_ioda_msi_setup(struct pci_dev *dev, unsigned int hwirq,
+ 			   unsigned int virq)
+ {
+ 	struct pci_controller *hose = pci_bus_to_host(dev->bus);
+ 	struct pnv_phb *phb = hose->private_data;
+ 	unsigned int xive_num = hwirq - phb->msi_base;
+ 	struct pnv_ioda_pe *pe;
+ 	int rc;
+ 
+ 	if (!(pe = pnv_ioda_get_pe(dev)))
+ 		return -ENODEV;
+ 
+ 	/* Assign XIVE to PE */
+ 	rc = opal_pci_set_xive_pe(phb->opal_id, pe->pe_number, xive_num);
+ 	if (rc) {
+ 		pe_warn(pe, "%s: OPAL error %d setting msi_base 0x%x "
+ 			"hwirq 0x%x XIVE 0x%x PE\n",
+ 			pci_name(dev), rc, phb->msi_base, hwirq, xive_num);
+ 		return -EIO;
+ 	}
+ 	set_msi_irq_chip(phb, virq);
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(pnv_cxl_ioda_msi_setup);
+ #endif
+ 
++>>>>>>> 6f963ec2d6bf (cxl: Fix device_node reference counting)
  static int pnv_pci_ioda_msi_setup(struct pnv_phb *phb, struct pci_dev *dev,
  				  unsigned int hwirq, unsigned int virq,
  				  unsigned int is_64, struct msi_msg *msg)
* Unmerged path arch/powerpc/include/asm/pnv-pci.h
* Unmerged path arch/powerpc/include/asm/pnv-pci.h
* Unmerged path arch/powerpc/platforms/powernv/pci-ioda.c
diff --git a/drivers/misc/cxl/pci.c b/drivers/misc/cxl/pci.c
index 25653ed060ac..50e7ba1fd2ce 100644
--- a/drivers/misc/cxl/pci.c
+++ b/drivers/misc/cxl/pci.c
@@ -317,7 +317,7 @@ static int init_implementation_adapter_regs(struct cxl *adapter, struct pci_dev
 	u64 psl_dsnctl;
 	u64 chipid;
 
-	if (!(np = pnv_pci_to_phb_node(dev)))
+	if (!(np = pnv_pci_get_phb_node(dev)))
 		return -ENODEV;
 
 	while (np && !(prop = of_get_property(np, "ibm,chip-id", NULL)))
