IB/core: Add on demand paging caps to ib_uverbs_ex_query_device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Haggai Eran <haggaie@mellanox.com>
commit f4056bfd8ccff4475417078d6e5456dfa1962dd3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/f4056bfd.failed

Add on-demand paging capabilities reporting to the extended query device verb.

Yann Droneaud writes:

    Note: as offsetof() is used to retrieve the size of the lower chunk
    of the response, beware that it only works if the upper chunk
    is right after, without any implicit padding. And, as the size of
    the latter chunk is added to the base size, implicit padding at the
    end of the structure is not taken in account. Both point must be
    taken in account when extending the uverbs functionalities.

	Signed-off-by: Haggai Eran <haggaie@mellanox.com>
	Reviewed-by: Yann Droneaud <ydroneaud@opteya.com>
	Signed-off-by: Roland Dreier <roland@purestorage.com>
(cherry picked from commit f4056bfd8ccff4475417078d6e5456dfa1962dd3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_cmd.c
#	include/uapi/rdma/ib_user_verbs.h
diff --cc drivers/infiniband/core/uverbs_cmd.c
index 422dd8c84243,04ca04559ce5..000000000000
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@@ -3287,6 -3315,14 +3287,14 @@@ int ib_uverbs_ex_query_device(struct ib
  	if (cmd.reserved)
  		return -EINVAL;
  
++<<<<<<< HEAD
++=======
+ 	resp.response_length = offsetof(typeof(resp), odp_caps);
+ 
+ 	if (ucore->outlen < resp.response_length)
+ 		return -ENOSPC;
+ 
++>>>>>>> f4056bfd8ccf (IB/core: Add on demand paging caps to ib_uverbs_ex_query_device)
  	err = device->query_device(device, &attr);
  	if (err)
  		return err;
@@@ -3295,7 -3330,25 +3303,29 @@@
  	copy_query_dev_fields(file, &resp.base, &attr);
  	resp.comp_mask = 0;
  
++<<<<<<< HEAD
 +	err = ib_copy_to_udata(ucore, &resp, sizeof(resp));
++=======
+ 	if (ucore->outlen < resp.response_length + sizeof(resp.odp_caps))
+ 		goto end;
+ 
+ #ifdef CONFIG_INFINIBAND_ON_DEMAND_PAGING
+ 	resp.odp_caps.general_caps = attr.odp_caps.general_caps;
+ 	resp.odp_caps.per_transport_caps.rc_odp_caps =
+ 		attr.odp_caps.per_transport_caps.rc_odp_caps;
+ 	resp.odp_caps.per_transport_caps.uc_odp_caps =
+ 		attr.odp_caps.per_transport_caps.uc_odp_caps;
+ 	resp.odp_caps.per_transport_caps.ud_odp_caps =
+ 		attr.odp_caps.per_transport_caps.ud_odp_caps;
+ 	resp.odp_caps.reserved = 0;
+ #else
+ 	memset(&resp.odp_caps, 0, sizeof(resp.odp_caps));
+ #endif
+ 	resp.response_length += sizeof(resp.odp_caps);
+ 
+ end:
+ 	err = ib_copy_to_udata(ucore, &resp, resp.response_length);
++>>>>>>> f4056bfd8ccf (IB/core: Add on demand paging caps to ib_uverbs_ex_query_device)
  	if (err)
  		return err;
  
diff --cc include/uapi/rdma/ib_user_verbs.h
index e8a96071e352,b513e662d8e4..000000000000
--- a/include/uapi/rdma/ib_user_verbs.h
+++ b/include/uapi/rdma/ib_user_verbs.h
@@@ -210,7 -220,8 +220,12 @@@ struct ib_uverbs_odp_caps 
  struct ib_uverbs_ex_query_device_resp {
  	struct ib_uverbs_query_device_resp base;
  	__u32 comp_mask;
++<<<<<<< HEAD
 +	__u32 reserved;
++=======
+ 	__u32 response_length;
+ 	struct ib_uverbs_odp_caps odp_caps;
++>>>>>>> f4056bfd8ccf (IB/core: Add on demand paging caps to ib_uverbs_ex_query_device)
  };
  
  struct ib_uverbs_query_port {
* Unmerged path drivers/infiniband/core/uverbs_cmd.c
* Unmerged path include/uapi/rdma/ib_user_verbs.h
