ixgbe: cleanup ixgbe_ndo_set_vf_vlan

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Don Skidmore <donald.c.skidmore@intel.com>
commit 2b509c0cd2923f2ca6e7b13517e54b6a60e56e18
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/2b509c0c.failed

Clean up functionality in ixgbe_ndo_set_vf_vlan that will simplify later
patches.

	Signed-off-by: Don Skidmore <donald.c.skidmore@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 2b509c0cd2923f2ca6e7b13517e54b6a60e56e18)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c
index 46bd2a51b591,07d1c047d1c6..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c
@@@ -1119,51 -1137,24 +1168,64 @@@ int ixgbe_ndo_set_vf_vlan(struct net_de
  	if ((vf >= adapter->num_vfs) || (vlan > 4095) || (qos > 7))
  		return -EINVAL;
  	if (vlan || qos) {
+ 		/* Check if there is already a port VLAN set, if so
+ 		 * we have to delete the old one first before we
+ 		 * can set the new one.  The usage model had
+ 		 * previously assumed the user would delete the
+ 		 * old port VLAN before setting a new one but this
+ 		 * is not necessarily the case.
+ 		 */
  		if (adapter->vfinfo[vf].pf_vlan)
- 			err = ixgbe_set_vf_vlan(adapter, false,
- 						adapter->vfinfo[vf].pf_vlan,
- 						vf);
+ 			err = ixgbe_disable_port_vlan(adapter, vf);
  		if (err)
  			goto out;
++<<<<<<< HEAD
 +		err = ixgbe_set_vf_vlan(adapter, true, vlan, vf);
 +		if (err)
 +			goto out;
 +		ixgbe_set_vmvir(adapter, vlan, qos, vf);
 +		ixgbe_set_vmolr(hw, vf, false);
 +		if (adapter->vfinfo[vf].spoofchk_enabled)
 +			hw->mac.ops.set_vlan_anti_spoofing(hw, true, vf);
 +		adapter->vfinfo[vf].vlan_count++;
 +		
 +		/* enable hide vlan on X550 */
 +		if (hw->mac.type >= ixgbe_mac_X550)
 +			ixgbe_write_qde(adapter, vf, IXGBE_QDE_ENABLE |
 +					IXGBE_QDE_HIDE_VLAN);
 +
 +		adapter->vfinfo[vf].pf_vlan = vlan;
 +		adapter->vfinfo[vf].pf_qos = qos;
 +		dev_info(&adapter->pdev->dev,
 +			 "Setting VLAN %d, QOS 0x%x on VF %d\n", vlan, qos, vf);
 +		if (test_bit(__IXGBE_DOWN, &adapter->state)) {
 +			dev_warn(&adapter->pdev->dev,
 +				 "The VF VLAN has been set,"
 +				 " but the PF device is not up.\n");
 +			dev_warn(&adapter->pdev->dev,
 +				 "Bring the PF device up before"
 +				 " attempting to use the VF device.\n");
 +		}
 +	} else {
 +		err = ixgbe_set_vf_vlan(adapter, false,
 +					adapter->vfinfo[vf].pf_vlan, vf);
 +		ixgbe_clear_vmvir(adapter, vf);
 +		ixgbe_set_vmolr(hw, vf, true);
 +		hw->mac.ops.set_vlan_anti_spoofing(hw, false, vf);
 +		if (adapter->vfinfo[vf].vlan_count)
 +			adapter->vfinfo[vf].vlan_count--;
 +		adapter->vfinfo[vf].pf_vlan = 0;
 +		adapter->vfinfo[vf].pf_qos = 0;
 +       }
++=======
+ 		err = ixgbe_enable_port_vlan(adapter, vf, vlan, qos);
+ 	} else {
+ 		err = ixgbe_disable_port_vlan(adapter, vf);
+ 	}
+ 
++>>>>>>> 2b509c0cd292 (ixgbe: cleanup ixgbe_ndo_set_vf_vlan)
  out:
 -	return err;
 +       return err;
  }
  
  static int ixgbe_link_mbps(struct ixgbe_adapter *adapter)
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c
