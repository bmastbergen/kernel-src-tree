openvswitch: Add support for checksums on UDP tunnels.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] openvswitch: Add support for checksums on UDP tunnels (Jiri Benc) [1156461 1211348]
Rebuild_FUZZ: 99.07%
commit-author Jesse Gross <jesse@nicira.com>
commit b8693877ae016ac525d674d5d7a84ea0ea68ba60
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/b8693877.failed

Currently, it isn't possible to request checksums on the outer UDP
header of tunnels - the TUNNEL_CSUM flag is ignored. This adds
support for requesting that UDP checksums be computed on transmit
and properly reported if they are present on receive.

	Signed-off-by: Jesse Gross <jesse@nicira.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b8693877ae016ac525d674d5d7a84ea0ea68ba60)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/geneve.c
#	net/openvswitch/vport-geneve.c
#	net/openvswitch/vport-vxlan.c
diff --cc net/ipv4/geneve.c
index b59373119987,5a4828ba05ad..000000000000
--- a/net/ipv4/geneve.c
+++ b/net/ipv4/geneve.c
@@@ -142,8 -136,9 +142,14 @@@ int geneve_xmit_skb(struct geneve_sock 
  
  	skb_set_inner_protocol(skb, htons(ETH_P_TEB));
  
++<<<<<<< HEAD
 +	return udp_tunnel_xmit_skb(gs->sock, rt, skb, src, dst,
 +				   tos, ttl, df, src_port, dst_port, xnet);
++=======
+ 	return udp_tunnel_xmit_skb(rt, skb, src, dst,
+ 				   tos, ttl, df, src_port, dst_port, xnet,
+ 				   !csum);
++>>>>>>> b8693877ae01 (openvswitch: Add support for checksums on UDP tunnels.)
  }
  EXPORT_SYMBOL_GPL(geneve_xmit_skb);
  
diff --cc net/openvswitch/vport-geneve.c
index 88a010c98c05,bf02fd5808c9..000000000000
--- a/net/openvswitch/vport-geneve.c
+++ b/net/openvswitch/vport-geneve.c
@@@ -203,9 -203,16 +203,14 @@@ static int geneve_tnl_send(struct vpor
  	err = geneve_xmit_skb(geneve_port->gs, rt, skb, fl.saddr,
  			      tun_key->ipv4_dst, tun_key->ipv4_tos,
  			      tun_key->ipv4_ttl, df, sport, dport,
++<<<<<<< HEAD
 +			      tun_key->tun_flags, vni,
 +			      tun_info->options_len, (u8 *)tun_info->options,
 +			      false);
++=======
+ 			      tun_key->tun_flags, vni, opts_len, opts,
+ 			      !!(tun_key->tun_flags & TUNNEL_CSUM), false);
++>>>>>>> b8693877ae01 (openvswitch: Add support for checksums on UDP tunnels.)
  	if (err < 0)
  		ip_rt_put(rt);
  	return err;
diff --cc net/openvswitch/vport-vxlan.c
index 4ee1a688c5a7,ff07d4062d60..000000000000
--- a/net/openvswitch/vport-vxlan.c
+++ b/net/openvswitch/vport-vxlan.c
@@@ -59,12 -61,23 +59,21 @@@ static inline struct vxlan_port *vxlan_
  }
  
  /* Called with rcu_read_lock and BH disabled. */
 -static void vxlan_rcv(struct vxlan_sock *vs, struct sk_buff *skb,
 -		      struct vxlan_metadata *md)
 +static void vxlan_rcv(struct vxlan_sock *vs, struct sk_buff *skb, __be32 vx_vni)
  {
  	struct ovs_tunnel_info tun_info;
 -	struct vxlan_port *vxlan_port;
  	struct vport *vport = vs->data;
  	struct iphdr *iph;
 -	struct ovs_vxlan_opts opts = {
 -		.gbp = md->gbp,
 -	};
  	__be64 key;
++<<<<<<< HEAD
++=======
+ 	__be16 flags;
+ 
+ 	flags = TUNNEL_KEY | (udp_hdr(skb)->check != 0 ? TUNNEL_CSUM : 0);
+ 	vxlan_port = vxlan_vport(vport);
+ 	if (vxlan_port->exts & VXLAN_F_GBP)
+ 		flags |= TUNNEL_VXLAN_OPT;
++>>>>>>> b8693877ae01 (openvswitch: Add support for checksums on UDP tunnels.)
  
  	/* Save outer tunnel values */
  	iph = ip_hdr(skb);
@@@ -167,15 -247,18 +177,26 @@@ static int vxlan_tnl_send(struct vport 
  	df = tun_key->tun_flags & TUNNEL_DONT_FRAGMENT ?
  		htons(IP_DF) : 0;
  
 -	skb->ignore_df = 1;
 +	skb->local_df = 1;
  
  	src_port = udp_flow_src_port(net, skb, 0, 0, true);
++<<<<<<< HEAD
++=======
+ 	md.vni = htonl(be64_to_cpu(tun_key->tun_id) << 8);
+ 	md.gbp = vxlan_ext_gbp(skb);
+ 	vxflags = vxlan_port->exts |
+ 		      (tun_key->tun_flags & TUNNEL_CSUM ? VXLAN_F_UDP_CSUM : 0);
++>>>>>>> b8693877ae01 (openvswitch: Add support for checksums on UDP tunnels.)
  
 -	err = vxlan_xmit_skb(rt, skb, fl.saddr, tun_key->ipv4_dst,
 +	err = vxlan_xmit_skb(net, vxlan_port->vs, rt, skb,
 +			     fl.saddr, tun_key->ipv4_dst,
  			     tun_key->ipv4_tos, tun_key->ipv4_ttl, df,
  			     src_port, dst_port,
++<<<<<<< HEAD
 +			     htonl(be64_to_cpu(tun_key->tun_id) << 8));
++=======
+ 			     &md, false, vxflags);
++>>>>>>> b8693877ae01 (openvswitch: Add support for checksums on UDP tunnels.)
  	if (err < 0)
  		ip_rt_put(rt);
  	return err;
diff --git a/include/net/geneve.h b/include/net/geneve.h
index 03aa2adb5bab..14fb8d3390b4 100644
--- a/include/net/geneve.h
+++ b/include/net/geneve.h
@@ -90,7 +90,7 @@ int geneve_xmit_skb(struct geneve_sock *gs, struct rtable *rt,
 		    struct sk_buff *skb, __be32 src, __be32 dst, __u8 tos,
 		    __u8 ttl, __be16 df, __be16 src_port, __be16 dst_port,
 		    __be16 tun_flags, u8 vni[3], u8 opt_len, u8 *opt,
-		    bool xnet);
+		    bool csum, bool xnet);
 #endif /*ifdef CONFIG_INET */
 
 #endif /*ifdef__NET_GENEVE_H */
* Unmerged path net/ipv4/geneve.c
* Unmerged path net/openvswitch/vport-geneve.c
* Unmerged path net/openvswitch/vport-vxlan.c
