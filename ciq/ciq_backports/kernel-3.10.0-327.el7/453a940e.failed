net: make skb an optional parameter for__skb_flow_dissect()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] flow: make skb an optional parameter for__skb_flow_dissect() (Ivan Vecera) [1200759]
Rebuild_FUZZ: 94.12%
commit-author WANG Cong <xiyou.wangcong@gmail.com>
commit 453a940ea725d692282f9e66475cec0d1b1e12f2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/453a940e.failed

Fixes: commit 690e36e726d00d2 (net: Allow raw buffers to be passed into the flow dissector)
	Cc: David S. Miller <davem@davemloft.net>
	Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 453a940ea725d692282f9e66475cec0d1b1e12f2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/flow_keys.h
#	net/core/flow_dissector.c
diff --cc include/net/flow_keys.h
index d4fec0ba6827,9a03f73c4974..000000000000
--- a/include/net/flow_keys.h
+++ b/include/net/flow_keys.h
@@@ -27,5 -27,17 +27,21 @@@ struct flow_keys 
  	u8 ip_proto;
  };
  
++<<<<<<< HEAD
 +extern bool skb_flow_dissect(const struct sk_buff *skb, struct flow_keys *flow);
++=======
+ bool __skb_flow_dissect(const struct sk_buff *skb, struct flow_keys *flow,
+ 			void *data, __be16 proto, int nhoff, int hlen);
+ static inline bool skb_flow_dissect(const struct sk_buff *skb, struct flow_keys *flow)
+ {
+ 	return __skb_flow_dissect(skb, flow, NULL, 0, 0, 0);
+ }
+ __be32 __skb_flow_get_ports(const struct sk_buff *skb, int thoff, u8 ip_proto,
+ 			    void *data, int hlen_proto);
+ static inline __be32 skb_flow_get_ports(const struct sk_buff *skb, int thoff, u8 ip_proto)
+ {
+ 	return __skb_flow_get_ports(skb, thoff, ip_proto, NULL, 0);
+ }
+ u32 flow_hash_from_keys(struct flow_keys *keys);
++>>>>>>> 453a940ea725 (net: make skb an optional parameter for__skb_flow_dissect())
  #endif
diff --cc net/core/flow_dissector.c
index 6a5c78b76323,12f48ca7a0b0..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -25,12 -25,63 +25,58 @@@ static void iph_to_flow_copy_addrs(stru
  	memcpy(&flow->src, &iph->saddr, sizeof(flow->src) + sizeof(flow->dst));
  }
  
 -/**
 - * __skb_flow_get_ports - extract the upper layer ports and return them
 - * @skb: sk_buff to extract the ports from
 - * @thoff: transport header offset
 - * @ip_proto: protocol for which to get port offset
 - * @data: raw buffer pointer to the packet, if NULL use skb->data
 - * @hlen: packet header length, if @data is NULL use skb_headlen(skb)
 - *
 - * The function will try to retrieve the ports at offset thoff + poff where poff
 - * is the protocol port offset returned from proto_ports_offset
 - */
 -__be32 __skb_flow_get_ports(const struct sk_buff *skb, int thoff, u8 ip_proto,
 -			    void *data, int hlen)
 +bool skb_flow_dissect(const struct sk_buff *skb, struct flow_keys *flow)
  {
++<<<<<<< HEAD
 +	int poff, nhoff = skb_network_offset(skb);
++=======
+ 	int poff = proto_ports_offset(ip_proto);
+ 
+ 	if (!data) {
+ 		data = skb->data;
+ 		hlen = skb_headlen(skb);
+ 	}
+ 
+ 	if (poff >= 0) {
+ 		__be32 *ports, _ports;
+ 
+ 		ports = __skb_header_pointer(skb, thoff + poff,
+ 					     sizeof(_ports), data, hlen, &_ports);
+ 		if (ports)
+ 			return *ports;
+ 	}
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(__skb_flow_get_ports);
+ 
+ /**
+  * __skb_flow_dissect - extract the flow_keys struct and return it
+  * @skb: sk_buff to extract the flow from, can be NULL if the rest are specified
+  * @data: raw buffer pointer to the packet, if NULL use skb->data
+  * @proto: protocol for which to get the flow, if @data is NULL use skb->protocol
+  * @nhoff: network header offset, if @data is NULL use skb_network_offset(skb)
+  * @hlen: packet header length, if @data is NULL use skb_headlen(skb)
+  *
+  * The function will try to retrieve the struct flow_keys from either the skbuff
+  * or a raw buffer specified by the rest parameters
+  */
+ bool __skb_flow_dissect(const struct sk_buff *skb, struct flow_keys *flow,
+ 			void *data, __be16 proto, int nhoff, int hlen)
+ {
++>>>>>>> 453a940ea725 (net: make skb an optional parameter for__skb_flow_dissect())
  	u8 ip_proto;
- 	__be16 proto = skb->protocol;
  
++<<<<<<< HEAD
++=======
+ 	if (!data) {
+ 		data = skb->data;
+ 		proto = skb->protocol;
+ 		nhoff = skb_network_offset(skb);
+ 		hlen = skb_headlen(skb);
+ 	}
+ 
++>>>>>>> 453a940ea725 (net: make skb an optional parameter for__skb_flow_dissect())
  	memset(flow, 0, sizeof(*flow));
  
  again:
* Unmerged path include/net/flow_keys.h
* Unmerged path net/core/flow_dissector.c
