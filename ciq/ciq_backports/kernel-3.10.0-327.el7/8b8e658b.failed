macvtap/tun: cross-endian support for little-endian hosts

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Greg Kurz <gkurz@linux.vnet.ibm.com>
commit 8b8e658b16336f0f50aba733f51db636ef121f50
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/8b8e658b.failed

The VNET_LE flag was introduced to fix accesses to virtio 1.0 headers
that are always little-endian. It can also be used to handle the special
case of a legacy little-endian device implemented by a big-endian host.

Let's add a flag and ioctls for big-endian devices as well. If both flags
are set, little-endian wins.

Since this is isn't a common usecase, the feature is controlled by a kernel
config option (not set by default).

Both macvtap and tun are covered by this patch since they share the same
API with userland.

	Signed-off-by: Greg Kurz <gkurz@linux.vnet.ibm.com>

	Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
	Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
(cherry picked from commit 8b8e658b16336f0f50aba733f51db636ef121f50)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/macvtap.c
#	drivers/net/tun.c
#	include/uapi/linux/if_tun.h
diff --cc drivers/net/macvtap.c
index bcbc7e7f3396,928f3f4db629..000000000000
--- a/drivers/net/macvtap.c
+++ b/drivers/net/macvtap.c
@@@ -51,7 -100,8 +100,12 @@@ static long macvtap_set_vnet_be(struct 
  
  static inline bool macvtap_is_little_endian(struct macvtap_queue *q)
  {
++<<<<<<< HEAD
 +	return q->flags & MACVTAP_VNET_LE;
++=======
+ 	return q->flags & MACVTAP_VNET_LE ||
+ 		macvtap_legacy_is_little_endian(q);
++>>>>>>> 8b8e658b1633 (macvtap/tun: cross-endian support for little-endian hosts)
  }
  
  static inline u16 macvtap16_to_cpu(struct macvtap_queue *q, __virtio16 val)
diff --cc drivers/net/tun.c
index 96714cdadb7d,cb376b2d548a..000000000000
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@@ -107,12 -109,9 +107,18 @@@ do {								
   * overload it to mean fasync when stored there.
   */
  #define TUN_FASYNC	IFF_ATTACH_QUEUE
++<<<<<<< HEAD
 +#define TUN_NO_PI	IFF_NO_PI
 +/* This flag has no real effect */
 +#define TUN_ONE_QUEUE	IFF_ONE_QUEUE
 +#define TUN_PERSIST 	IFF_PERSIST
 +#define TUN_VNET_HDR 	IFF_VNET_HDR
 +#define TUN_TAP_MQ      IFF_MULTI_QUEUE
++=======
+ /* High bits in flags field are unused. */
+ #define TUN_VNET_LE     0x80000000
+ #define TUN_VNET_BE     0x40000000
++>>>>>>> 8b8e658b1633 (macvtap/tun: cross-endian support for little-endian hosts)
  
  #define TUN_FEATURES (IFF_NO_PI | IFF_ONE_QUEUE | IFF_VNET_HDR | \
  		      IFF_MULTI_QUEUE)
@@@ -205,6 -207,70 +211,73 @@@ struct tun_struct 
  	u32 flow_count;
  };
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_TUN_VNET_CROSS_LE
+ static inline bool tun_legacy_is_little_endian(struct tun_struct *tun)
+ {
+ 	return tun->flags & TUN_VNET_BE ? false :
+ 		virtio_legacy_is_little_endian();
+ }
+ 
+ static long tun_get_vnet_be(struct tun_struct *tun, int __user *argp)
+ {
+ 	int be = !!(tun->flags & TUN_VNET_BE);
+ 
+ 	if (put_user(be, argp))
+ 		return -EFAULT;
+ 
+ 	return 0;
+ }
+ 
+ static long tun_set_vnet_be(struct tun_struct *tun, int __user *argp)
+ {
+ 	int be;
+ 
+ 	if (get_user(be, argp))
+ 		return -EFAULT;
+ 
+ 	if (be)
+ 		tun->flags |= TUN_VNET_BE;
+ 	else
+ 		tun->flags &= ~TUN_VNET_BE;
+ 
+ 	return 0;
+ }
+ #else
+ static inline bool tun_legacy_is_little_endian(struct tun_struct *tun)
+ {
+ 	return virtio_legacy_is_little_endian();
+ }
+ 
+ static long tun_get_vnet_be(struct tun_struct *tun, int __user *argp)
+ {
+ 	return -EINVAL;
+ }
+ 
+ static long tun_set_vnet_be(struct tun_struct *tun, int __user *argp)
+ {
+ 	return -EINVAL;
+ }
+ #endif /* CONFIG_TUN_VNET_CROSS_LE */
+ 
+ static inline bool tun_is_little_endian(struct tun_struct *tun)
+ {
+ 	return tun->flags & TUN_VNET_LE ||
+ 		tun_legacy_is_little_endian(tun);
+ }
+ 
+ static inline u16 tun16_to_cpu(struct tun_struct *tun, __virtio16 val)
+ {
+ 	return __virtio16_to_cpu(tun_is_little_endian(tun), val);
+ }
+ 
+ static inline __virtio16 cpu_to_tun16(struct tun_struct *tun, u16 val)
+ {
+ 	return __cpu_to_virtio16(tun_is_little_endian(tun), val);
+ }
+ 
++>>>>>>> 8b8e658b1633 (macvtap/tun: cross-endian support for little-endian hosts)
  static inline u32 tun_hashfn(u32 rxhash)
  {
  	return rxhash & 0x3ff;
@@@ -2088,6 -2094,31 +2161,34 @@@ static long __tun_chr_ioctl(struct fil
  		tun->vnet_hdr_sz = vnet_hdr_sz;
  		break;
  
++<<<<<<< HEAD
++=======
+ 	case TUNGETVNETLE:
+ 		le = !!(tun->flags & TUN_VNET_LE);
+ 		if (put_user(le, (int __user *)argp))
+ 			ret = -EFAULT;
+ 		break;
+ 
+ 	case TUNSETVNETLE:
+ 		if (get_user(le, (int __user *)argp)) {
+ 			ret = -EFAULT;
+ 			break;
+ 		}
+ 		if (le)
+ 			tun->flags |= TUN_VNET_LE;
+ 		else
+ 			tun->flags &= ~TUN_VNET_LE;
+ 		break;
+ 
+ 	case TUNGETVNETBE:
+ 		ret = tun_get_vnet_be(tun, argp);
+ 		break;
+ 
+ 	case TUNSETVNETBE:
+ 		ret = tun_set_vnet_be(tun, argp);
+ 		break;
+ 
++>>>>>>> 8b8e658b1633 (macvtap/tun: cross-endian support for little-endian hosts)
  	case TUNATTACHFILTER:
  		/* Can be set only for TAPs */
  		ret = -EINVAL;
diff --cc include/uapi/linux/if_tun.h
index db737ba76630,3cb5e1d85ddd..000000000000
--- a/include/uapi/linux/if_tun.h
+++ b/include/uapi/linux/if_tun.h
@@@ -46,6 -46,16 +46,19 @@@
  #define TUNGETVNETHDRSZ _IOR('T', 215, int)
  #define TUNSETVNETHDRSZ _IOW('T', 216, int)
  #define TUNSETQUEUE  _IOW('T', 217, int)
++<<<<<<< HEAD
++=======
+ #define TUNSETIFINDEX	_IOW('T', 218, unsigned int)
+ #define TUNGETFILTER _IOR('T', 219, struct sock_fprog)
+ #define TUNSETVNETLE _IOW('T', 220, int)
+ #define TUNGETVNETLE _IOR('T', 221, int)
+ /* The TUNSETVNETBE and TUNGETVNETBE ioctls are for cross-endian support on
+  * little-endian hosts. Not all kernel configurations support them, but all
+  * configurations that support SET also support GET.
+  */
+ #define TUNSETVNETBE _IOW('T', 222, int)
+ #define TUNGETVNETBE _IOR('T', 223, int)
++>>>>>>> 8b8e658b1633 (macvtap/tun: cross-endian support for little-endian hosts)
  
  /* TUNSETIFF ifr flags */
  #define IFF_TUN		0x0001
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index ca8cc2d69f8d..4dde2f89f6ae 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -231,6 +231,20 @@ config TUN
 
 	  If you don't know what to use this for, you don't need it.
 
+config TUN_VNET_CROSS_LE
+	bool "Support for cross-endian vnet headers on little-endian kernels"
+	default n
+	---help---
+	  This option allows TUN/TAP and MACVTAP device drivers in a
+	  little-endian kernel to parse vnet headers that come from a
+	  big-endian legacy virtio device.
+
+	  Userspace programs can control the feature using the TUNSETVNETBE
+	  and TUNGETVNETBE ioctls.
+
+	  Unless you have a little-endian system hosting a big-endian virtual
+	  machine with a legacy virtio NIC, you should say N.
+
 config VETH
 	tristate "Virtual ethernet pair device"
 	---help---
* Unmerged path drivers/net/macvtap.c
* Unmerged path drivers/net/tun.c
* Unmerged path include/uapi/linux/if_tun.h
