powercap / RAPL: Add support for Intel Skylake processors

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [powercap] rapl: Add support for Intel Skylake processors (Steve Best) [1169598]
Rebuild_FUZZ: 89.32%
commit-author Brian Bian <brian.bian@intel.com>
commit 5fa0fa4b01cd9c52c4be0ff69ce0d922cd724812
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/5fa0fa4b.failed

	Signed-off-by: Brian Bian <brian.bian@intel.com>
	Acked-by: Jacob Pan <jacob.jun.pan@linux.intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 5fa0fa4b01cd9c52c4be0ff69ce0d922cd724812)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/powercap/intel_rapl.c
diff --cc drivers/powercap/intel_rapl.c
index 299a8496dbe2,fd243231620a..000000000000
--- a/drivers/powercap/intel_rapl.c
+++ b/drivers/powercap/intel_rapl.c
@@@ -946,16 -958,117 +946,130 @@@ static void package_power_limit_irq_res
  	wrmsr_on_cpu(cpu, MSR_IA32_PACKAGE_THERM_INTERRUPT, l, h);
  }
  
++<<<<<<< HEAD
 +static const struct x86_cpu_id rapl_ids[] = {
 +	{ X86_VENDOR_INTEL, 6, 0x2a},/* Sandy Bridge */
 +	{ X86_VENDOR_INTEL, 6, 0x2d},/* Sandy Bridge EP */
 +	{ X86_VENDOR_INTEL, 6, 0x37},/* Valleyview */
 +	{ X86_VENDOR_INTEL, 6, 0x3a},/* Ivy Bridge */
 +	{ X86_VENDOR_INTEL, 6, 0x3c},/* Haswell */
 +	{ X86_VENDOR_INTEL, 6, 0x3d},/* Broadwell */
 +	{ X86_VENDOR_INTEL, 6, 0x3f},/* Haswell */
 +	{ X86_VENDOR_INTEL, 6, 0x45},/* Haswell ULT */
 +	/* TODO: Add more CPU IDs after testing */
++=======
+ static void set_floor_freq_default(struct rapl_domain *rd, bool mode)
+ {
+ 	int nr_powerlimit = find_nr_power_limit(rd);
+ 
+ 	/* always enable clamp such that p-state can go below OS requested
+ 	 * range. power capping priority over guranteed frequency.
+ 	 */
+ 	rapl_write_data_raw(rd, PL1_CLAMP, mode);
+ 
+ 	/* some domains have pl2 */
+ 	if (nr_powerlimit > 1) {
+ 		rapl_write_data_raw(rd, PL2_ENABLE, mode);
+ 		rapl_write_data_raw(rd, PL2_CLAMP, mode);
+ 	}
+ }
+ 
+ static void set_floor_freq_atom(struct rapl_domain *rd, bool enable)
+ {
+ 	static u32 power_ctrl_orig_val;
+ 	u32 mdata;
+ 
+ 	if (!power_ctrl_orig_val)
+ 		iosf_mbi_read(BT_MBI_UNIT_PMC, BT_MBI_PMC_READ,
+ 			IOSF_CPU_POWER_BUDGET_CTL, &power_ctrl_orig_val);
+ 	mdata = power_ctrl_orig_val;
+ 	if (enable) {
+ 		mdata &= ~(0x7f << 8);
+ 		mdata |= 1 << 8;
+ 	}
+ 	iosf_mbi_write(BT_MBI_UNIT_PMC, BT_MBI_PMC_WRITE,
+ 		IOSF_CPU_POWER_BUDGET_CTL, mdata);
+ }
+ 
+ static u64 rapl_compute_time_window_core(struct rapl_package *rp, u64 value,
+ 					bool to_raw)
+ {
+ 	u64 f, y; /* fraction and exp. used for time unit */
+ 
+ 	/*
+ 	 * Special processing based on 2^Y*(1+F/4), refer
+ 	 * to Intel Software Developer's manual Vol.3B: CH 14.9.3.
+ 	 */
+ 	if (!to_raw) {
+ 		f = (value & 0x60) >> 5;
+ 		y = value & 0x1f;
+ 		value = (1 << y) * (4 + f) * rp->time_unit / 4;
+ 	} else {
+ 		do_div(value, rp->time_unit);
+ 		y = ilog2(value);
+ 		f = div64_u64(4 * (value - (1 << y)), 1 << y);
+ 		value = (y & 0x1f) | ((f & 0x3) << 5);
+ 	}
+ 	return value;
+ }
+ 
+ static u64 rapl_compute_time_window_atom(struct rapl_package *rp, u64 value,
+ 					bool to_raw)
+ {
+ 	/*
+ 	 * Atom time unit encoding is straight forward val * time_unit,
+ 	 * where time_unit is default to 1 sec. Never 0.
+ 	 */
+ 	if (!to_raw)
+ 		return (value) ? value *= rp->time_unit : rp->time_unit;
+ 	else
+ 		value = div64_u64(value, rp->time_unit);
+ 
+ 	return value;
+ }
+ 
+ static const struct rapl_defaults rapl_defaults_core = {
+ 	.check_unit = rapl_check_unit_core,
+ 	.set_floor_freq = set_floor_freq_default,
+ 	.compute_time_window = rapl_compute_time_window_core,
+ };
+ 
+ static const struct rapl_defaults rapl_defaults_hsw_server = {
+ 	.check_unit = rapl_check_unit_core,
+ 	.set_floor_freq = set_floor_freq_default,
+ 	.compute_time_window = rapl_compute_time_window_core,
+ 	.dram_domain_energy_unit = 15300,
+ };
+ 
+ static const struct rapl_defaults rapl_defaults_atom = {
+ 	.check_unit = rapl_check_unit_atom,
+ 	.set_floor_freq = set_floor_freq_atom,
+ 	.compute_time_window = rapl_compute_time_window_atom,
+ };
+ 
+ #define RAPL_CPU(_model, _ops) {			\
+ 		.vendor = X86_VENDOR_INTEL,		\
+ 		.family = 6,				\
+ 		.model = _model,			\
+ 		.driver_data = (kernel_ulong_t)&_ops,	\
+ 		}
+ 
+ static const struct x86_cpu_id rapl_ids[] __initconst = {
+ 	RAPL_CPU(0x2a, rapl_defaults_core),/* Sandy Bridge */
+ 	RAPL_CPU(0x2d, rapl_defaults_core),/* Sandy Bridge EP */
+ 	RAPL_CPU(0x37, rapl_defaults_atom),/* Valleyview */
+ 	RAPL_CPU(0x3a, rapl_defaults_core),/* Ivy Bridge */
+ 	RAPL_CPU(0x3c, rapl_defaults_core),/* Haswell */
+ 	RAPL_CPU(0x3d, rapl_defaults_core),/* Broadwell */
+ 	RAPL_CPU(0x3f, rapl_defaults_hsw_server),/* Haswell servers */
+ 	RAPL_CPU(0x4f, rapl_defaults_hsw_server),/* Broadwell servers */
+ 	RAPL_CPU(0x45, rapl_defaults_core),/* Haswell ULT */
+ 	RAPL_CPU(0x4E, rapl_defaults_core),/* Skylake */
+ 	RAPL_CPU(0x4C, rapl_defaults_atom),/* Braswell */
+ 	RAPL_CPU(0x4A, rapl_defaults_atom),/* Tangier */
+ 	RAPL_CPU(0x56, rapl_defaults_core),/* Future Xeon */
+ 	RAPL_CPU(0x5A, rapl_defaults_atom),/* Annidale */
++>>>>>>> 5fa0fa4b01cd (powercap / RAPL: Add support for Intel Skylake processors)
  	{}
  };
  MODULE_DEVICE_TABLE(x86cpu, rapl_ids);
* Unmerged path drivers/powercap/intel_rapl.c
