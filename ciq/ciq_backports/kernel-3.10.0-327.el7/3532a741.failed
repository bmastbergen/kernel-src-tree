powerpc/powernv: Use pci_dn, not device_node, in PCI config accessor

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [powerpc] powernv: Use pci_dn, not device_node, in PCI config accessor (Laurent Vivier) [1213675]
Rebuild_FUZZ: 93.75%
commit-author Gavin Shan <gwshan@linux.vnet.ibm.com>
commit 3532a741f80c3b9ca975006f93a4a477e07e2cb3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/3532a741.failed

The PCI config accessors previously relied on device_node.  Unfortunately,
VFs don't have a corresponding device_node, so change the accessors to use
pci_dn instead.

[bhelgaas: changelog]
	Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
	Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
(cherry picked from commit 3532a741f80c3b9ca975006f93a4a477e07e2cb3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/powernv/eeh-powernv.c
diff --cc arch/powerpc/platforms/powernv/eeh-powernv.c
index 86e8f8e66097,8eac8c57ee86..000000000000
--- a/arch/powerpc/platforms/powernv/eeh-powernv.c
+++ b/arch/powerpc/platforms/powernv/eeh-powernv.c
@@@ -557,49 -1035,379 +557,67 @@@ static inline bool powernv_eeh_cfg_bloc
  	return false;
  }
  
 -static int pnv_eeh_read_config(struct device_node *dn,
 -			       int where, int size, u32 *val)
 +static int powernv_eeh_read_config(struct device_node *dn,
 +				   int where, int size, u32 *val)
  {
++<<<<<<< HEAD
 +	if (powernv_eeh_cfg_blocked(dn)) {
++=======
+ 	struct pci_dn *pdn = PCI_DN(dn);
+ 
+ 	if (!pdn)
+ 		return PCIBIOS_DEVICE_NOT_FOUND;
+ 
+ 	if (pnv_eeh_cfg_blocked(dn)) {
++>>>>>>> 3532a741f80c (powerpc/powernv: Use pci_dn, not device_node, in PCI config accessor)
  		*val = 0xFFFFFFFF;
  		return PCIBIOS_SET_FAILED;
  	}
  
- 	return pnv_pci_cfg_read(dn, where, size, val);
+ 	return pnv_pci_cfg_read(pdn, where, size, val);
  }
  
 -static int pnv_eeh_write_config(struct device_node *dn,
 -				int where, int size, u32 val)
 +static int powernv_eeh_write_config(struct device_node *dn,
 +				    int where, int size, u32 val)
  {
++<<<<<<< HEAD
 +	if (powernv_eeh_cfg_blocked(dn))
++=======
+ 	struct pci_dn *pdn = PCI_DN(dn);
+ 
+ 	if (!pdn)
+ 		return PCIBIOS_DEVICE_NOT_FOUND;
+ 
+ 	if (pnv_eeh_cfg_blocked(dn))
++>>>>>>> 3532a741f80c (powerpc/powernv: Use pci_dn, not device_node, in PCI config accessor)
  		return PCIBIOS_SET_FAILED;
  
- 	return pnv_pci_cfg_write(dn, where, size, val);
+ 	return pnv_pci_cfg_write(pdn, where, size, val);
  }
  
 -static void pnv_eeh_dump_hub_diag_common(struct OpalIoP7IOCErrorData *data)
 -{
 -	/* GEM */
 -	if (data->gemXfir || data->gemRfir ||
 -	    data->gemRirqfir || data->gemMask || data->gemRwof)
 -		pr_info("  GEM: %016llx %016llx %016llx %016llx %016llx\n",
 -			be64_to_cpu(data->gemXfir),
 -			be64_to_cpu(data->gemRfir),
 -			be64_to_cpu(data->gemRirqfir),
 -			be64_to_cpu(data->gemMask),
 -			be64_to_cpu(data->gemRwof));
 -
 -	/* LEM */
 -	if (data->lemFir || data->lemErrMask ||
 -	    data->lemAction0 || data->lemAction1 || data->lemWof)
 -		pr_info("  LEM: %016llx %016llx %016llx %016llx %016llx\n",
 -			be64_to_cpu(data->lemFir),
 -			be64_to_cpu(data->lemErrMask),
 -			be64_to_cpu(data->lemAction0),
 -			be64_to_cpu(data->lemAction1),
 -			be64_to_cpu(data->lemWof));
 -}
 -
 -static void pnv_eeh_get_and_dump_hub_diag(struct pci_controller *hose)
 -{
 -	struct pnv_phb *phb = hose->private_data;
 -	struct OpalIoP7IOCErrorData *data = &phb->diag.hub_diag;
 -	long rc;
 -
 -	rc = opal_pci_get_hub_diag_data(phb->hub_id, data, sizeof(*data));
 -	if (rc != OPAL_SUCCESS) {
 -		pr_warn("%s: Failed to get HUB#%llx diag-data (%ld)\n",
 -			__func__, phb->hub_id, rc);
 -		return;
 -	}
 -
 -	switch (data->type) {
 -	case OPAL_P7IOC_DIAG_TYPE_RGC:
 -		pr_info("P7IOC diag-data for RGC\n\n");
 -		pnv_eeh_dump_hub_diag_common(data);
 -		if (data->rgc.rgcStatus || data->rgc.rgcLdcp)
 -			pr_info("  RGC: %016llx %016llx\n",
 -				be64_to_cpu(data->rgc.rgcStatus),
 -				be64_to_cpu(data->rgc.rgcLdcp));
 -		break;
 -	case OPAL_P7IOC_DIAG_TYPE_BI:
 -		pr_info("P7IOC diag-data for BI %s\n\n",
 -			data->bi.biDownbound ? "Downbound" : "Upbound");
 -		pnv_eeh_dump_hub_diag_common(data);
 -		if (data->bi.biLdcp0 || data->bi.biLdcp1 ||
 -		    data->bi.biLdcp2 || data->bi.biFenceStatus)
 -			pr_info("  BI:  %016llx %016llx %016llx %016llx\n",
 -				be64_to_cpu(data->bi.biLdcp0),
 -				be64_to_cpu(data->bi.biLdcp1),
 -				be64_to_cpu(data->bi.biLdcp2),
 -				be64_to_cpu(data->bi.biFenceStatus));
 -		break;
 -	case OPAL_P7IOC_DIAG_TYPE_CI:
 -		pr_info("P7IOC diag-data for CI Port %d\n\n",
 -			data->ci.ciPort);
 -		pnv_eeh_dump_hub_diag_common(data);
 -		if (data->ci.ciPortStatus || data->ci.ciPortLdcp)
 -			pr_info("  CI:  %016llx %016llx\n",
 -				be64_to_cpu(data->ci.ciPortStatus),
 -				be64_to_cpu(data->ci.ciPortLdcp));
 -		break;
 -	case OPAL_P7IOC_DIAG_TYPE_MISC:
 -		pr_info("P7IOC diag-data for MISC\n\n");
 -		pnv_eeh_dump_hub_diag_common(data);
 -		break;
 -	case OPAL_P7IOC_DIAG_TYPE_I2C:
 -		pr_info("P7IOC diag-data for I2C\n\n");
 -		pnv_eeh_dump_hub_diag_common(data);
 -		break;
 -	default:
 -		pr_warn("%s: Invalid type of HUB#%llx diag-data (%d)\n",
 -			__func__, phb->hub_id, data->type);
 -	}
 -}
 -
 -static int pnv_eeh_get_pe(struct pci_controller *hose,
 -			  u16 pe_no, struct eeh_pe **pe)
 -{
 -	struct pnv_phb *phb = hose->private_data;
 -	struct pnv_ioda_pe *pnv_pe;
 -	struct eeh_pe *dev_pe;
 -	struct eeh_dev edev;
 -
 -	/*
 -	 * If PHB supports compound PE, to fetch
 -	 * the master PE because slave PE is invisible
 -	 * to EEH core.
 -	 */
 -	pnv_pe = &phb->ioda.pe_array[pe_no];
 -	if (pnv_pe->flags & PNV_IODA_PE_SLAVE) {
 -		pnv_pe = pnv_pe->master;
 -		WARN_ON(!pnv_pe ||
 -			!(pnv_pe->flags & PNV_IODA_PE_MASTER));
 -		pe_no = pnv_pe->pe_number;
 -	}
 -
 -	/* Find the PE according to PE# */
 -	memset(&edev, 0, sizeof(struct eeh_dev));
 -	edev.phb = hose;
 -	edev.pe_config_addr = pe_no;
 -	dev_pe = eeh_pe_get(&edev);
 -	if (!dev_pe)
 -		return -EEXIST;
 -
 -	/* Freeze the (compound) PE */
 -	*pe = dev_pe;
 -	if (!(dev_pe->state & EEH_PE_ISOLATED))
 -		phb->freeze_pe(phb, pe_no);
 -
 -	/*
 -	 * At this point, we're sure the (compound) PE should
 -	 * have been frozen. However, we still need poke until
 -	 * hitting the frozen PE on top level.
 -	 */
 -	dev_pe = dev_pe->parent;
 -	while (dev_pe && !(dev_pe->type & EEH_PE_PHB)) {
 -		int ret;
 -		int active_flags = (EEH_STATE_MMIO_ACTIVE |
 -				    EEH_STATE_DMA_ACTIVE);
 -
 -		ret = eeh_ops->get_state(dev_pe, NULL);
 -		if (ret <= 0 || (ret & active_flags) == active_flags) {
 -			dev_pe = dev_pe->parent;
 -			continue;
 -		}
 -
 -		/* Frozen parent PE */
 -		*pe = dev_pe;
 -		if (!(dev_pe->state & EEH_PE_ISOLATED))
 -			phb->freeze_pe(phb, dev_pe->addr);
 -
 -		/* Next one */
 -		dev_pe = dev_pe->parent;
 -	}
 -
 -	return 0;
 -}
 -
  /**
 - * pnv_eeh_next_error - Retrieve next EEH error to handle
 + * powernv_eeh_next_error - Retrieve next EEH error to handle
   * @pe: Affected PE
   *
 - * The function is expected to be called by EEH core while it gets
 - * special EEH event (without binding PE). The function calls to
 - * OPAL APIs for next error to handle. The informational error is
 - * handled internally by platform. However, the dead IOC, dead PHB,
 - * fenced PHB and frozen PE should be handled by EEH core eventually.
 + * Using OPAL API, to retrieve next EEH error for EEH core to handle
   */
 -static int pnv_eeh_next_error(struct eeh_pe **pe)
 +static int powernv_eeh_next_error(struct eeh_pe **pe)
  {
  	struct pci_controller *hose;
 -	struct pnv_phb *phb;
 -	struct eeh_pe *phb_pe, *parent_pe;
 -	__be64 frozen_pe_no;
 -	__be16 err_type, severity;
 -	int active_flags = (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE);
 -	long rc;
 -	int state, ret = EEH_NEXT_ERR_NONE;
 -
 -	/*
 -	 * While running here, it's safe to purge the event queue.
 -	 * And we should keep the cached OPAL notifier event sychronized
 -	 * between the kernel and firmware.
 -	 */
 -	eeh_remove_event(NULL, false);
 -	opal_notifier_update_evt(OPAL_EVENT_PCI_ERROR, 0x0ul);
 +	struct pnv_phb *phb = NULL;
  
  	list_for_each_entry(hose, &hose_list, list_node) {
 -		/*
 -		 * If the subordinate PCI buses of the PHB has been
 -		 * removed or is exactly under error recovery, we
 -		 * needn't take care of it any more.
 -		 */
  		phb = hose->private_data;
 -		phb_pe = eeh_phb_pe_get(hose);
 -		if (!phb_pe || (phb_pe->state & EEH_PE_ISOLATED))
 -			continue;
 -
 -		rc = opal_pci_next_error(phb->opal_id,
 -					 &frozen_pe_no, &err_type, &severity);
 -		if (rc != OPAL_SUCCESS) {
 -			pr_devel("%s: Invalid return value on "
 -				 "PHB#%x (0x%lx) from opal_pci_next_error",
 -				 __func__, hose->global_number, rc);
 -			continue;
 -		}
 -
 -		/* If the PHB doesn't have error, stop processing */
 -		if (be16_to_cpu(err_type) == OPAL_EEH_NO_ERROR ||
 -		    be16_to_cpu(severity) == OPAL_EEH_SEV_NO_ERROR) {
 -			pr_devel("%s: No error found on PHB#%x\n",
 -				 __func__, hose->global_number);
 -			continue;
 -		}
 -
 -		/*
 -		 * Processing the error. We're expecting the error with
 -		 * highest priority reported upon multiple errors on the
 -		 * specific PHB.
 -		 */
 -		pr_devel("%s: Error (%d, %d, %llu) on PHB#%x\n",
 -			__func__, be16_to_cpu(err_type),
 -			be16_to_cpu(severity), be64_to_cpu(frozen_pe_no),
 -			hose->global_number);
 -		switch (be16_to_cpu(err_type)) {
 -		case OPAL_EEH_IOC_ERROR:
 -			if (be16_to_cpu(severity) == OPAL_EEH_SEV_IOC_DEAD) {
 -				pr_err("EEH: dead IOC detected\n");
 -				ret = EEH_NEXT_ERR_DEAD_IOC;
 -			} else if (be16_to_cpu(severity) == OPAL_EEH_SEV_INF) {
 -				pr_info("EEH: IOC informative error "
 -					"detected\n");
 -				pnv_eeh_get_and_dump_hub_diag(hose);
 -				ret = EEH_NEXT_ERR_NONE;
 -			}
 -
 -			break;
 -		case OPAL_EEH_PHB_ERROR:
 -			if (be16_to_cpu(severity) == OPAL_EEH_SEV_PHB_DEAD) {
 -				*pe = phb_pe;
 -				pr_err("EEH: dead PHB#%x detected, "
 -				       "location: %s\n",
 -					hose->global_number,
 -					eeh_pe_loc_get(phb_pe));
 -				ret = EEH_NEXT_ERR_DEAD_PHB;
 -			} else if (be16_to_cpu(severity) ==
 -				   OPAL_EEH_SEV_PHB_FENCED) {
 -				*pe = phb_pe;
 -				pr_err("EEH: Fenced PHB#%x detected, "
 -				       "location: %s\n",
 -					hose->global_number,
 -					eeh_pe_loc_get(phb_pe));
 -				ret = EEH_NEXT_ERR_FENCED_PHB;
 -			} else if (be16_to_cpu(severity) == OPAL_EEH_SEV_INF) {
 -				pr_info("EEH: PHB#%x informative error "
 -					"detected, location: %s\n",
 -					hose->global_number,
 -					eeh_pe_loc_get(phb_pe));
 -				pnv_eeh_get_phb_diag(phb_pe);
 -				pnv_pci_dump_phb_diag_data(hose, phb_pe->data);
 -				ret = EEH_NEXT_ERR_NONE;
 -			}
 -
 -			break;
 -		case OPAL_EEH_PE_ERROR:
 -			/*
 -			 * If we can't find the corresponding PE, we
 -			 * just try to unfreeze.
 -			 */
 -			if (pnv_eeh_get_pe(hose,
 -				be64_to_cpu(frozen_pe_no), pe)) {
 -				/* Try best to clear it */
 -				pr_info("EEH: Clear non-existing PHB#%x-PE#%llx\n",
 -					hose->global_number, frozen_pe_no);
 -				pr_info("EEH: PHB location: %s\n",
 -					eeh_pe_loc_get(phb_pe));
 -				opal_pci_eeh_freeze_clear(phb->opal_id,
 -					frozen_pe_no,
 -					OPAL_EEH_ACTION_CLEAR_FREEZE_ALL);
 -				ret = EEH_NEXT_ERR_NONE;
 -			} else if ((*pe)->state & EEH_PE_ISOLATED ||
 -				   eeh_pe_passed(*pe)) {
 -				ret = EEH_NEXT_ERR_NONE;
 -			} else {
 -				pr_err("EEH: Frozen PE#%x "
 -				       "on PHB#%x detected\n",
 -				       (*pe)->addr,
 -					(*pe)->phb->global_number);
 -				pr_err("EEH: PE location: %s, "
 -				       "PHB location: %s\n",
 -				       eeh_pe_loc_get(*pe),
 -				       eeh_pe_loc_get(phb_pe));
 -				ret = EEH_NEXT_ERR_FROZEN_PE;
 -			}
 -
 -			break;
 -		default:
 -			pr_warn("%s: Unexpected error type %d\n",
 -				__func__, be16_to_cpu(err_type));
 -		}
 -
 -		/*
 -		 * EEH core will try recover from fenced PHB or
 -		 * frozen PE. In the time for frozen PE, EEH core
 -		 * enable IO path for that before collecting logs,
 -		 * but it ruins the site. So we have to dump the
 -		 * log in advance here.
 -		 */
 -		if ((ret == EEH_NEXT_ERR_FROZEN_PE  ||
 -		    ret == EEH_NEXT_ERR_FENCED_PHB) &&
 -		    !((*pe)->state & EEH_PE_ISOLATED)) {
 -			eeh_pe_state_mark(*pe, EEH_PE_ISOLATED);
 -			pnv_eeh_get_phb_diag(*pe);
 -
 -			if (eeh_has_flag(EEH_EARLY_DUMP_LOG))
 -				pnv_pci_dump_phb_diag_data((*pe)->phb,
 -							   (*pe)->data);
 -		}
 -
 -		/*
 -		 * We probably have the frozen parent PE out there and
 -		 * we need have to handle frozen parent PE firstly.
 -		 */
 -		if (ret == EEH_NEXT_ERR_FROZEN_PE) {
 -			parent_pe = (*pe)->parent;
 -			while (parent_pe) {
 -				/* Hit the ceiling ? */
 -				if (parent_pe->type & EEH_PE_PHB)
 -					break;
 -
 -				/* Frozen parent PE ? */
 -				state = eeh_ops->get_state(parent_pe, NULL);
 -				if (state > 0 &&
 -				    (state & active_flags) != active_flags)
 -					*pe = parent_pe;
 -
 -				/* Next parent level */
 -				parent_pe = parent_pe->parent;
 -			}
 -
 -			/* We possibly migrate to another PE */
 -			eeh_pe_state_mark(*pe, EEH_PE_ISOLATED);
 -		}
 -
 -		/*
 -		 * If we have no errors on the specific PHB or only
 -		 * informative error there, we continue poking it.
 -		 * Otherwise, we need actions to be taken by upper
 -		 * layer.
 -		 */
 -		if (ret > EEH_NEXT_ERR_INF)
 -			break;
 +		break;
  	}
  
 -	return ret;
 +	if (phb && phb->eeh_ops->next_error)
 +		return phb->eeh_ops->next_error(pe);
 +
 +	return -EEXIST;
  }
  
 -static int pnv_eeh_restore_config(struct device_node *dn)
 +static int powernv_eeh_restore_config(struct device_node *dn)
  {
  	struct eeh_dev *edev = of_node_to_eeh_dev(dn);
  	struct pnv_phb *phb;
* Unmerged path arch/powerpc/platforms/powernv/eeh-powernv.c
diff --git a/arch/powerpc/platforms/powernv/pci.c b/arch/powerpc/platforms/powernv/pci.c
index 56cabf7d960c..7aa128dd8e24 100644
--- a/arch/powerpc/platforms/powernv/pci.c
+++ b/arch/powerpc/platforms/powernv/pci.c
@@ -376,9 +376,9 @@ static void pnv_pci_handle_eeh_config(struct pnv_phb *phb, u32 pe_no)
 	spin_unlock_irqrestore(&phb->lock, flags);
 }
 
-static void pnv_pci_config_check_eeh(struct pnv_phb *phb,
-				     struct device_node *dn)
+static void pnv_pci_config_check_eeh(struct pci_dn *pdn)
 {
+	struct pnv_phb *phb = pdn->phb->private_data;
 	u8	fstate;
 	__be16	pcierr;
 	int	pe_no;
@@ -389,7 +389,7 @@ static void pnv_pci_config_check_eeh(struct pnv_phb *phb,
 	 * setup that yet. So all ER errors should be mapped to
 	 * reserved PE.
 	 */
-	pe_no = PCI_DN(dn)->pe_number;
+	pe_no = pdn->pe_number;
 	if (pe_no == IODA_INVALID_PE) {
 		if (phb->type == PNV_PHB_P5IOC2)
 			pe_no = 0;
@@ -417,8 +417,7 @@ static void pnv_pci_config_check_eeh(struct pnv_phb *phb,
 	}
 
 	cfg_dbg(" -> EEH check, bdfn=%04x PE#%d fstate=%x\n",
-		(PCI_DN(dn)->busno << 8) | (PCI_DN(dn)->devfn),
-		pe_no, fstate);
+		(pdn->busno << 8) | (pdn->devfn), pe_no, fstate);
 
 	/* Clear the frozen state if applicable */
 	if (fstate == OPAL_EEH_STOPPED_MMIO_FREEZE ||
@@ -435,10 +434,9 @@ static void pnv_pci_config_check_eeh(struct pnv_phb *phb,
 	}
 }
 
-int pnv_pci_cfg_read(struct device_node *dn,
+int pnv_pci_cfg_read(struct pci_dn *pdn,
 		     int where, int size, u32 *val)
 {
-	struct pci_dn *pdn = PCI_DN(dn);
 	struct pnv_phb *phb = pdn->phb->private_data;
 	u32 bdfn = (pdn->busno << 8) | pdn->devfn;
 	s64 rc;
@@ -472,10 +470,9 @@ int pnv_pci_cfg_read(struct device_node *dn,
 	return PCIBIOS_SUCCESSFUL;
 }
 
-int pnv_pci_cfg_write(struct device_node *dn,
+int pnv_pci_cfg_write(struct pci_dn *pdn,
 		      int where, int size, u32 val)
 {
-	struct pci_dn *pdn = PCI_DN(dn);
 	struct pnv_phb *phb = pdn->phb->private_data;
 	u32 bdfn = (pdn->busno << 8) | pdn->devfn;
 
@@ -499,18 +496,17 @@ int pnv_pci_cfg_write(struct device_node *dn,
 }
 
 #if CONFIG_EEH
-static bool pnv_pci_cfg_check(struct pci_controller *hose,
-			      struct device_node *dn)
+static bool pnv_pci_cfg_check(struct pci_dn *pdn)
 {
 	struct eeh_dev *edev = NULL;
-	struct pnv_phb *phb = hose->private_data;
+	struct pnv_phb *phb = pdn->phb->private_data;
 
 	/* EEH not enabled ? */
 	if (!(phb->flags & PNV_PHB_FLAG_EEH))
 		return true;
 
 	/* PE reset or device removed ? */
-	edev = of_node_to_eeh_dev(dn);
+	edev = pdn->edev;
 	if (edev) {
 		if (edev->pe &&
 		    (edev->pe->state & EEH_PE_RESET))
@@ -523,8 +519,7 @@ static bool pnv_pci_cfg_check(struct pci_controller *hose,
 	return true;
 }
 #else
-static inline pnv_pci_cfg_check(struct pci_controller *hose,
-				struct device_node *dn)
+static inline pnv_pci_cfg_check(struct pci_dn *pdn)
 {
 	return true;
 }
@@ -534,32 +529,26 @@ static int pnv_pci_read_config(struct pci_bus *bus,
 			       unsigned int devfn,
 			       int where, int size, u32 *val)
 {
-	struct device_node *dn, *busdn = pci_bus_to_OF_node(bus);
 	struct pci_dn *pdn;
 	struct pnv_phb *phb;
-	bool found = false;
 	int ret;
 
 	*val = 0xFFFFFFFF;
-	for (dn = busdn->child; dn; dn = dn->sibling) {
-		pdn = PCI_DN(dn);
-		if (pdn && pdn->devfn == devfn) {
-			phb = pdn->phb->private_data;
-			found = true;
-			break;
-		}
-	}
+	pdn = pci_get_pdn_by_devfn(bus, devfn);
+	if (!pdn)
+		return PCIBIOS_DEVICE_NOT_FOUND;
 
-	if (!found || !pnv_pci_cfg_check(pdn->phb, dn))
+	if (!pnv_pci_cfg_check(pdn))
 		return PCIBIOS_DEVICE_NOT_FOUND;
 
-	ret = pnv_pci_cfg_read(dn, where, size, val);
-	if (phb->flags & PNV_PHB_FLAG_EEH) {
+	ret = pnv_pci_cfg_read(pdn, where, size, val);
+	phb = pdn->phb->private_data;
+	if (phb->flags & PNV_PHB_FLAG_EEH && pdn->edev) {
 		if (*val == EEH_IO_ERROR_VALUE(size) &&
-		    eeh_dev_check_failure(of_node_to_eeh_dev(dn)))
+		    eeh_dev_check_failure(pdn->edev))
                         return PCIBIOS_DEVICE_NOT_FOUND;
 	} else {
-		pnv_pci_config_check_eeh(phb, dn);
+		pnv_pci_config_check_eeh(pdn);
 	}
 
 	return ret;
@@ -569,27 +558,21 @@ static int pnv_pci_write_config(struct pci_bus *bus,
 				unsigned int devfn,
 				int where, int size, u32 val)
 {
-	struct device_node *dn, *busdn = pci_bus_to_OF_node(bus);
 	struct pci_dn *pdn;
 	struct pnv_phb *phb;
-	bool found = false;
 	int ret;
 
-	for (dn = busdn->child; dn; dn = dn->sibling) {
-		pdn = PCI_DN(dn);
-		if (pdn && pdn->devfn == devfn) {
-			phb = pdn->phb->private_data;
-			found = true;
-			break;
-		}
-	}
+	pdn = pci_get_pdn_by_devfn(bus, devfn);
+	if (!pdn)
+		return PCIBIOS_DEVICE_NOT_FOUND;
 
-	if (!found || !pnv_pci_cfg_check(pdn->phb, dn))
+	if (!pnv_pci_cfg_check(pdn))
 		return PCIBIOS_DEVICE_NOT_FOUND;
 
-	ret = pnv_pci_cfg_write(dn, where, size, val);
+	ret = pnv_pci_cfg_write(pdn, where, size, val);
+	phb = pdn->phb->private_data;
 	if (!(phb->flags & PNV_PHB_FLAG_EEH))
-		pnv_pci_config_check_eeh(phb, dn);
+		pnv_pci_config_check_eeh(pdn);
 
 	return ret;
 }
diff --git a/arch/powerpc/platforms/powernv/pci.h b/arch/powerpc/platforms/powernv/pci.h
index 5732743fe737..8fed6bb534ac 100644
--- a/arch/powerpc/platforms/powernv/pci.h
+++ b/arch/powerpc/platforms/powernv/pci.h
@@ -187,9 +187,9 @@ extern struct pnv_eeh_ops ioda_eeh_ops;
 
 void pnv_pci_dump_phb_diag_data(struct pci_controller *hose,
 				unsigned char *log_buff);
-int pnv_pci_cfg_read(struct device_node *dn,
+int pnv_pci_cfg_read(struct pci_dn *pdn,
 		     int where, int size, u32 *val);
-int pnv_pci_cfg_write(struct device_node *dn,
+int pnv_pci_cfg_write(struct pci_dn *pdn,
 		      int where, int size, u32 val);
 extern void pnv_pci_setup_iommu_table(struct iommu_table *tbl,
 				      void *tce_mem, u64 tce_size,
