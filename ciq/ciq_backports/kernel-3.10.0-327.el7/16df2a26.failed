IB/iser: Fix catastrophic error flow hang

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [infiniband] iser: Fix catastrophic error flow hang (Amir Vadai) [1164539]
Rebuild_FUZZ: 96.20%
commit-author Sagi Grimberg <sagig@mellanox.com>
commit 16df2a26fb3efb52f066098cdbd0f81c8378d861
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/16df2a26.failed

In case of the HCA going into catasrophic error flow, the
beacon post_send is likely to fail, so surely there will
be no completion for it.

In this case, use a best effort approach and don't wait for beacon
completion if we failed to post the send.

	Reported-by: Alex Tabachnik <alext@mellanox.com>
	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Roland Dreier <roland@purestorage.com>
(cherry picked from commit 16df2a26fb3efb52f066098cdbd0f81c8378d861)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/iser/iser_verbs.c
diff --cc drivers/infiniband/ulp/iser/iser_verbs.c
index fbf2a1e0f2e2,cd4acc5d94f1..000000000000
--- a/drivers/infiniband/ulp/iser/iser_verbs.c
+++ b/drivers/infiniband/ulp/iser/iser_verbs.c
@@@ -645,21 -649,47 +645,35 @@@ void iser_conn_release(struct iser_con
  
  /**
   * triggers start of the disconnect procedures and wait for them to be done
 - * Called with state mutex held
   */
 -int iser_conn_terminate(struct iser_conn *iser_conn)
 +void iser_conn_terminate(struct iser_conn *ib_conn)
  {
 -	struct ib_conn *ib_conn = &iser_conn->ib_conn;
 -	struct ib_send_wr *bad_wr;
  	int err = 0;
  
 -	/* terminate the iser conn only if the conn state is UP */
 -	if (!iser_conn_state_comp_exch(iser_conn, ISER_CONN_UP,
 -				       ISER_CONN_TERMINATING))
 -		return 0;
 -
 -	iser_info("iser_conn %p state %d\n", iser_conn, iser_conn->state);
 -
 -	/* suspend queuing of new iscsi commands */
 -	if (iser_conn->iscsi_conn)
 -		iscsi_suspend_queue(iser_conn->iscsi_conn);
 -
 -	/*
 -	 * In case we didn't already clean up the cma_id (peer initiated
 -	 * a disconnection), we need to Cause the CMA to change the QP
 -	 * state to ERROR.
 +	/* change the ib conn state only if the conn is UP, however always call
 +	 * rdma_disconnect since this is the only way to cause the CMA to change
 +	 * the QP state to ERROR
  	 */
 -	if (ib_conn->cma_id) {
 -		err = rdma_disconnect(ib_conn->cma_id);
 -		if (err)
 -			iser_err("Failed to disconnect, conn: 0x%p err %d\n",
 -				 iser_conn, err);
  
++<<<<<<< HEAD
 +	iser_conn_state_comp_exch(ib_conn, ISER_CONN_UP, ISER_CONN_TERMINATING);
 +	err = rdma_disconnect(ib_conn->cma_id);
 +	if (err)
 +		iser_err("Failed to disconnect, conn: 0x%p err %d\n",
 +			 ib_conn,err);
++=======
+ 		/* post an indication that all flush errors were consumed */
+ 		err = ib_post_send(ib_conn->qp, &ib_conn->beacon, &bad_wr);
+ 		if (err) {
+ 			iser_err("conn %p failed to post beacon", ib_conn);
+ 			return 1;
+ 		}
+ 
+ 		wait_for_completion(&ib_conn->flush_comp);
+ 	}
+ 
+ 	return 1;
++>>>>>>> 16df2a26fb3e (IB/iser: Fix catastrophic error flow hang)
  }
  
  /**
* Unmerged path drivers/infiniband/ulp/iser/iser_verbs.c
