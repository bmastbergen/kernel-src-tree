xfs: recall pNFS layouts on conflicting access

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 781355c6e5ae87908de27dec3380a34918c33eee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/781355c6.failed

Recall all outstanding pNFS layouts and truncates, writes and similar extent
list modifying operations.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit 781355c6e5ae87908de27dec3380a34918c33eee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_file.c
#	fs/xfs/xfs_ioctl.c
diff --cc fs/xfs/xfs_file.c
index 91b548987ce6,56dcfce8d7d6..000000000000
--- a/fs/xfs/xfs_file.c
+++ b/fs/xfs/xfs_file.c
@@@ -37,8 -35,8 +37,9 @@@
  #include "xfs_ioctl.h"
  #include "xfs_trace.h"
  #include "xfs_log.h"
 +#include "xfs_dinode.h"
  #include "xfs_icache.h"
+ #include "xfs_pnfs.h"
  
  #include <linux/aio.h>
  #include <linux/dcache.h>
@@@ -850,16 -825,22 +855,25 @@@ xfs_file_fallocate
  {
  	struct inode		*inode = file_inode(file);
  	struct xfs_inode	*ip = XFS_I(inode);
 +	struct xfs_trans	*tp;
  	long			error;
++<<<<<<< HEAD
++=======
+ 	enum xfs_prealloc_flags	flags = 0;
+ 	uint			iolock = XFS_IOLOCK_EXCL;
++>>>>>>> 781355c6e5ae (xfs: recall pNFS layouts on conflicting access)
  	loff_t			new_size = 0;
  
  	if (!S_ISREG(inode->i_mode))
  		return -EINVAL;
 -	if (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |
 -		     FALLOC_FL_COLLAPSE_RANGE | FALLOC_FL_ZERO_RANGE))
 +	if (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE))
  		return -EOPNOTSUPP;
  
- 	xfs_ilock(ip, XFS_IOLOCK_EXCL);
+ 	xfs_ilock(ip, iolock);
+ 	error = xfs_break_layouts(inode, &iolock);
+ 	if (error)
+ 		goto out_unlock;
+ 
  	if (mode & FALLOC_FL_PUNCH_HOLE) {
  		error = xfs_free_file_space(ip, offset, len);
  		if (error)
@@@ -914,8 -904,8 +928,13 @@@
  	}
  
  out_unlock:
++<<<<<<< HEAD
 +	xfs_iunlock(ip, XFS_IOLOCK_EXCL);
 +	return -error;
++=======
+ 	xfs_iunlock(ip, iolock);
+ 	return error;
++>>>>>>> 781355c6e5ae (xfs: recall pNFS layouts on conflicting access)
  }
  
  
diff --cc fs/xfs/xfs_ioctl.c
index c6e180d60c21,bf70a2affb05..000000000000
--- a/fs/xfs/xfs_ioctl.c
+++ b/fs/xfs/xfs_ioctl.c
@@@ -40,8 -38,8 +40,9 @@@
  #include "xfs_trace.h"
  #include "xfs_icache.h"
  #include "xfs_symlink.h"
 +#include "xfs_dinode.h"
  #include "xfs_trans.h"
+ #include "xfs_pnfs.h"
  
  #include <linux/capability.h>
  #include <linux/dcache.h>
@@@ -638,11 -607,9 +639,16 @@@ xfs_ioc_space
  	unsigned int		cmd,
  	xfs_flock64_t		*bf)
  {
 +	struct xfs_mount	*mp = ip->i_mount;
 +	struct xfs_trans	*tp;
  	struct iattr		iattr;
++<<<<<<< HEAD
 +	bool			setprealloc = false;
 +	bool			clrprealloc = false;
++=======
+ 	enum xfs_prealloc_flags	flags = 0;
+ 	uint			iolock = XFS_IOLOCK_EXCL;
++>>>>>>> 781355c6e5ae (xfs: recall pNFS layouts on conflicting access)
  	int			error;
  
  	/*
@@@ -755,37 -727,12 +764,37 @@@
  	if (error)
  		goto out_unlock;
  
 -	error = xfs_update_prealloc_flags(ip, flags);
 +	tp = xfs_trans_alloc(mp, XFS_TRANS_WRITEID);
 +	error = xfs_trans_reserve(tp, &M_RES(mp)->tr_writeid, 0, 0);
 +	if (error) {
 +		xfs_trans_cancel(tp, 0);
 +		goto out_unlock;
 +	}
 +
 +	xfs_ilock(ip, XFS_ILOCK_EXCL);
 +	xfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);
 +
 +	if (!(ioflags & IO_INVIS)) {
 +		ip->i_d.di_mode &= ~S_ISUID;
 +		if (ip->i_d.di_mode & S_IXGRP)
 +			ip->i_d.di_mode &= ~S_ISGID;
 +		xfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);
 +	}
 +
 +	if (setprealloc)
 +		ip->i_d.di_flags |= XFS_DIFLAG_PREALLOC;
 +	else if (clrprealloc)
 +		ip->i_d.di_flags &= ~XFS_DIFLAG_PREALLOC;
 +
 +	xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
 +	if (filp->f_flags & O_DSYNC)
 +		xfs_trans_set_sync(tp);
 +	error = xfs_trans_commit(tp, 0);
  
  out_unlock:
- 	xfs_iunlock(ip, XFS_IOLOCK_EXCL);
+ 	xfs_iunlock(ip, iolock);
  	mnt_drop_write_file(filp);
 -	return error;
 +	return -error;
  }
  
  STATIC int
* Unmerged path fs/xfs/xfs_file.c
* Unmerged path fs/xfs/xfs_ioctl.c
diff --git a/fs/xfs/xfs_iops.c b/fs/xfs/xfs_iops.c
index 8eaf00dae5eb..33d55b9d3864 100644
--- a/fs/xfs/xfs_iops.c
+++ b/fs/xfs/xfs_iops.c
@@ -40,6 +40,7 @@
 #include "xfs_dir2.h"
 #include "xfs_dinode.h"
 #include "xfs_trans_space.h"
+#include "xfs_pnfs.h"
 
 #include <linux/capability.h>
 #include <linux/xattr.h>
@@ -961,9 +962,13 @@ xfs_vn_setattr(
 	int			error;
 
 	if (iattr->ia_valid & ATTR_SIZE) {
-		xfs_ilock(ip, XFS_IOLOCK_EXCL);
-		error = xfs_setattr_size(ip, iattr);
-		xfs_iunlock(ip, XFS_IOLOCK_EXCL);
+		uint		iolock = XFS_IOLOCK_EXCL;
+
+		xfs_ilock(ip, iolock);
+		error = xfs_break_layouts(dentry->d_inode, &iolock);
+		if (!error)
+			error = xfs_setattr_size(ip, iattr);
+		xfs_iunlock(ip, iolock);
 	} else {
 		error = xfs_setattr_nonsize(ip, iattr, 0);
 	}
diff --git a/fs/xfs/xfs_pnfs.c b/fs/xfs/xfs_pnfs.c
index 89912b34f184..4b33ef112400 100644
--- a/fs/xfs/xfs_pnfs.c
+++ b/fs/xfs/xfs_pnfs.c
@@ -18,6 +18,36 @@
 #include "xfs_bit.h"
 #include "xfs_pnfs.h"
 
+/*
+ * Ensure that we do not have any outstanding pNFS layouts that can be used by
+ * clients to directly read from or write to this inode.  This must be called
+ * before every operation that can remove blocks from the extent map.
+ * Additionally we call it during the write operation, where aren't concerned
+ * about exposing unallocated blocks but just want to provide basic
+ * synchronization between a local writer and pNFS clients.  mmap writes would
+ * also benefit from this sort of synchronization, but due to the tricky locking
+ * rules in the page fault path we don't bother.
+ */
+int
+xfs_break_layouts(
+	struct inode		*inode,
+	uint			*iolock)
+{
+	struct xfs_inode	*ip = XFS_I(inode);
+	int			error;
+
+	ASSERT(xfs_isilocked(ip, XFS_IOLOCK_SHARED|XFS_IOLOCK_EXCL));
+
+	while ((error = break_layout(inode, false) == -EWOULDBLOCK)) {
+		xfs_iunlock(ip, *iolock);
+		error = break_layout(inode, true);
+		*iolock = XFS_IOLOCK_EXCL;
+		xfs_ilock(ip, *iolock);
+	}
+
+	return error;
+}
+
 /*
  * Get a unique ID including its location so that the client can identify
  * the exported device.
diff --git a/fs/xfs/xfs_pnfs.h b/fs/xfs/xfs_pnfs.h
index 0d91255a89ae..b7fbfce660f6 100644
--- a/fs/xfs/xfs_pnfs.h
+++ b/fs/xfs/xfs_pnfs.h
@@ -7,5 +7,12 @@ int xfs_fs_map_blocks(struct inode *inode, loff_t offset, u64 length,
 		struct iomap *iomap, bool write, u32 *device_generation);
 int xfs_fs_commit_blocks(struct inode *inode, struct iomap *maps, int nr_maps,
 		struct iattr *iattr);
+
+int xfs_break_layouts(struct inode *inode, uint *iolock);
+#else
+static inline int xfs_break_layouts(struct inode *inode, uint *iolock)
+{
+	return 0;
+}
 #endif /* CONFIG_NFSD_PNFS */
 #endif /* _XFS_PNFS_H */
