tcp: move around a few calls in tcp_v6_conn_request

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Octavian Purdila <octavian.purdila@intel.com>
commit 9403715977075c89b1dbcdd7713ab542807a04ac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/94037159.failed

Make the tcp_v6_conn_request calls flow similar with that of
tcp_v4_conn_request.

Note that want_cookie can be true only if isn is zero and that is why
we can move the if (want_cookie) block out of the if (!isn) block.

Moving security_inet_conn_request() has a couple of side effects:
missing inet_rsk(req)->ecn_ok update and the req->cookie_ts
update. However, neither SELinux nor Smack security hooks seems to
check them. This change should also avoid future different behaviour
for IPv4 and IPv6 in the security hooks.

	Signed-off-by: Octavian Purdila <octavian.purdila@intel.com>
	Acked-by: Paul Moore <paul@paul-moore.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9403715977075c89b1dbcdd7713ab542807a04ac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/tcp_ipv6.c
diff --cc net/ipv6/tcp_ipv6.c
index fdc8f8ca98c1,91b8a2e699f3..000000000000
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@@ -1015,35 -1065,21 +1015,50 @@@ static int tcp_v6_conn_request(struct s
  		tcp_clear_options(&tmp_opt);
  
  	tmp_opt.tstamp_ok = tmp_opt.saw_tstamp;
 -	tcp_openreq_init(req, &tmp_opt, skb, sk);
 +	tcp_openreq_init(req, &tmp_opt, skb);
  
  	ireq = inet_rsk(req);
++<<<<<<< HEAD
 +	ireq->ir_v6_rmt_addr = ipv6_hdr(skb)->saddr;
 +	ireq->ir_v6_loc_addr = ipv6_hdr(skb)->daddr;
 +	if (!want_cookie || tmp_opt.tstamp_ok)
 +		TCP_ECN_create_request(req, skb, sock_net(sk));
 +
 +	ireq->ir_iif = sk->sk_bound_dev_if;
 +
 +	/* So that link locals have meaning */
 +	if (!sk->sk_bound_dev_if &&
 +	    ipv6_addr_type(&ireq->ir_v6_rmt_addr) & IPV6_ADDR_LINKLOCAL)
 +		ireq->ir_iif = inet6_iif(skb);
 +
 +	if (!isn) {
 +		if (ipv6_opt_accepted(sk, skb) ||
 +		    np->rxopt.bits.rxinfo || np->rxopt.bits.rxoinfo ||
 +		    np->rxopt.bits.rxhlim || np->rxopt.bits.rxohlim) {
 +			atomic_inc(&skb->users);
 +			ireq->pktopts = skb;
 +		}
 +
 +		if (want_cookie) {
 +			isn = cookie_v6_init_sequence(sk, skb, &req->mss);
 +			req->cookie_ts = tmp_opt.tstamp_ok;
 +			goto have_isn;
 +		}
 +
++=======
+ 	af_ops->init_req(req, sk, skb);
+ 
+ 	if (security_inet_conn_request(sk, skb, req))
+ 		goto drop_and_release;
+ 
+ 	if (!want_cookie || tmp_opt.tstamp_ok)
+ 		TCP_ECN_create_request(req, skb, sock_net(sk));
+ 
+ 	if (want_cookie) {
+ 		isn = cookie_init_sequence(af_ops, sk, skb, &req->mss);
+ 		req->cookie_ts = tmp_opt.tstamp_ok;
+ 	} else if (!isn) {
++>>>>>>> 940371597707 (tcp: move around a few calls in tcp_v6_conn_request)
  		/* VJ's idea. We save last timestamp seen
  		 * from the destination in peer table, when entering
  		 * state TIME-WAIT, and check against it before
@@@ -1080,20 -1116,26 +1095,23 @@@
  
  		isn = tcp_v6_init_sequence(skb);
  	}
++<<<<<<< HEAD
 +have_isn:
 +	tcp_rsk(req)->snt_isn = isn;
  
 -	if (!dst) {
 -		dst = af_ops->route_req(sk, (struct flowi *)&fl6, req, NULL);
 -		if (!dst)
 -			goto drop_and_free;
 -	}
 +	if (security_inet_conn_request(sk, skb, req))
 +		goto drop_and_release;
++=======
++>>>>>>> 940371597707 (tcp: move around a few calls in tcp_v6_conn_request)
  
 -	tcp_rsk(req)->snt_isn = isn;
 -	tcp_openreq_init_rwin(req, sk, dst);
 -	fastopen = !want_cookie &&
 -		   tcp_try_fastopen(sk, skb, req, &foc, dst);
 -	err = tcp_v6_send_synack(sk, dst, &fl6, req,
 -				 skb_get_queue_mapping(skb), &foc);
 -	if (!fastopen) {
 -		if (err || want_cookie)
 -			goto drop_and_free;
 -
 -		tcp_rsk(req)->listener = NULL;
 -		inet6_csk_reqsk_queue_hash_add(sk, req, TCP_TIMEOUT_INIT);
 -	}
 +	if (tcp_v6_send_synack(sk, dst, &fl6, req,
 +			       skb_get_queue_mapping(skb)) ||
 +	    want_cookie)
 +		goto drop_and_free;
 +
 +	tcp_rsk(req)->snt_synack = tcp_time_stamp;
 +	tcp_rsk(req)->listener = NULL;
 +	inet6_csk_reqsk_queue_hash_add(sk, req, TCP_TIMEOUT_INIT);
  	return 0;
  
  drop_and_release:
* Unmerged path net/ipv6/tcp_ipv6.c
