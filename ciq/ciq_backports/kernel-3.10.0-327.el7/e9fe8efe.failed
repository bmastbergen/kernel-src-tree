bonding: procfs: clean bond->lock usage and use RCU

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Nikolay Aleksandrov <nikolay@redhat.com>
commit e9fe8efeeae11f19bb6fafd6153ec77deaeb4b83
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/e9fe8efe.failed

Use RCU to protect against slave release, the proc show function will sync
with the bond destruction by the proc locks and the fact that the bond is
released after NETDEV_UNREGISTER which causes the bonding to remove the
proc entry.

	Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e9fe8efeeae11f19bb6fafd6153ec77deaeb4b83)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_procfs.c
diff --cc drivers/net/bonding/bond_procfs.c
index 96f629d77b41,bb09d0442aa8..000000000000
--- a/drivers/net/bonding/bond_procfs.c
+++ b/drivers/net/bonding/bond_procfs.c
@@@ -7,24 -7,20 +7,25 @@@
  
  static void *bond_info_seq_start(struct seq_file *seq, loff_t *pos)
  	__acquires(RCU)
- 	__acquires(&bond->lock)
  {
  	struct bonding *bond = seq->private;
 -	struct list_head *iter;
 -	struct slave *slave;
  	loff_t off = 0;
 +	struct slave *slave;
 +	int i;
  
- 	/* make sure the bond won't be taken away */
  	rcu_read_lock();
- 	read_lock(&bond->lock);
  
  	if (*pos == 0)
  		return SEQ_START_TOKEN;
  
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave_rcu(bond, slave, iter)
++>>>>>>> e9fe8efeeae1 (bonding: procfs: clean bond->lock usage and use RCU)
  		if (++off == *pos)
  			return slave;
 +	}
  
  	return NULL;
  }
@@@ -36,11 -34,16 +37,24 @@@ static void *bond_info_seq_next(struct 
  
  	++*pos;
  	if (v == SEQ_START_TOKEN)
++<<<<<<< HEAD
 +		return bond->first_slave;
 +
 +	slave = slave->next;
 +
 +	return (slave == bond->first_slave) ? NULL : slave;
++=======
+ 		return bond_first_slave_rcu(bond);
+ 
+ 	bond_for_each_slave_rcu(bond, slave, iter) {
+ 		if (found)
+ 			return slave;
+ 		if (slave == v)
+ 			found = true;
+ 	}
+ 
+ 	return NULL;
++>>>>>>> e9fe8efeeae1 (bonding: procfs: clean bond->lock usage and use RCU)
  }
  
  static void bond_info_seq_stop(struct seq_file *seq, void *v)
* Unmerged path drivers/net/bonding/bond_procfs.c
