xfs: cleanup xfs_bmse_merge returns

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit 4db431f57be2d32f35f46023b0c0d9f8b6e06e26
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/4db431f5.failed

	Signed-off-by: Dave Chinner <dchinner@redhat.com>

xfs_bmse_merge() has a jump label for return that just returns the
error value. Convert all the code to just return the error directly
and use XFS_WANT_CORRUPTED_RETURN. This also allows the final call
to xfs_bmbt_update() to return directly.

Noticed while reviewing coccinelle return cleanup patches and
wondering why the same return pattern as in xfs_bmse_shift_one()
wasn't picked up by the checker pattern...

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit 4db431f57be2d32f35f46023b0c0d9f8b6e06e26)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_bmap.c
diff --cc fs/xfs/libxfs/xfs_bmap.c
index b6f15ccf3239,5a42e2ba857f..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@@ -5402,3 -5402,300 +5402,303 @@@ error0
  	}
  	return error;
  }
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * Determine whether an extent shift can be accomplished by a merge with the
+  * extent that precedes the target hole of the shift.
+  */
+ STATIC bool
+ xfs_bmse_can_merge(
+ 	struct xfs_bmbt_irec	*left,	/* preceding extent */
+ 	struct xfs_bmbt_irec	*got,	/* current extent to shift */
+ 	xfs_fileoff_t		shift)	/* shift fsb */
+ {
+ 	xfs_fileoff_t		startoff;
+ 
+ 	startoff = got->br_startoff - shift;
+ 
+ 	/*
+ 	 * The extent, once shifted, must be adjacent in-file and on-disk with
+ 	 * the preceding extent.
+ 	 */
+ 	if ((left->br_startoff + left->br_blockcount != startoff) ||
+ 	    (left->br_startblock + left->br_blockcount != got->br_startblock) ||
+ 	    (left->br_state != got->br_state) ||
+ 	    (left->br_blockcount + got->br_blockcount > MAXEXTLEN))
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ /*
+  * A bmap extent shift adjusts the file offset of an extent to fill a preceding
+  * hole in the file. If an extent shift would result in the extent being fully
+  * adjacent to the extent that currently precedes the hole, we can merge with
+  * the preceding extent rather than do the shift.
+  *
+  * This function assumes the caller has verified a shift-by-merge is possible
+  * with the provided extents via xfs_bmse_can_merge().
+  */
+ STATIC int
+ xfs_bmse_merge(
+ 	struct xfs_inode		*ip,
+ 	int				whichfork,
+ 	xfs_fileoff_t			shift,		/* shift fsb */
+ 	int				current_ext,	/* idx of gotp */
+ 	struct xfs_bmbt_rec_host	*gotp,		/* extent to shift */
+ 	struct xfs_bmbt_rec_host	*leftp,		/* preceding extent */
+ 	struct xfs_btree_cur		*cur,
+ 	int				*logflags)	/* output */
+ {
+ 	struct xfs_ifork		*ifp;
+ 	struct xfs_bmbt_irec		got;
+ 	struct xfs_bmbt_irec		left;
+ 	xfs_filblks_t			blockcount;
+ 	int				error, i;
+ 
+ 	ifp = XFS_IFORK_PTR(ip, whichfork);
+ 	xfs_bmbt_get_all(gotp, &got);
+ 	xfs_bmbt_get_all(leftp, &left);
+ 	blockcount = left.br_blockcount + got.br_blockcount;
+ 
+ 	ASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));
+ 	ASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));
+ 	ASSERT(xfs_bmse_can_merge(&left, &got, shift));
+ 
+ 	/*
+ 	 * Merge the in-core extents. Note that the host record pointers and
+ 	 * current_ext index are invalid once the extent has been removed via
+ 	 * xfs_iext_remove().
+ 	 */
+ 	xfs_bmbt_set_blockcount(leftp, blockcount);
+ 	xfs_iext_remove(ip, current_ext, 1, 0);
+ 
+ 	/*
+ 	 * Update the on-disk extent count, the btree if necessary and log the
+ 	 * inode.
+ 	 */
+ 	XFS_IFORK_NEXT_SET(ip, whichfork,
+ 			   XFS_IFORK_NEXTENTS(ip, whichfork) - 1);
+ 	*logflags |= XFS_ILOG_CORE;
+ 	if (!cur) {
+ 		*logflags |= XFS_ILOG_DEXT;
+ 		return 0;
+ 	}
+ 
+ 	/* lookup and remove the extent to merge */
+ 	error = xfs_bmbt_lookup_eq(cur, got.br_startoff, got.br_startblock,
+ 				   got.br_blockcount, &i);
+ 	if (error)
+ 		return error;
+ 	XFS_WANT_CORRUPTED_RETURN(i == 1);
+ 
+ 	error = xfs_btree_delete(cur, &i);
+ 	if (error)
+ 		return error;
+ 	XFS_WANT_CORRUPTED_RETURN(i == 1);
+ 
+ 	/* lookup and update size of the previous extent */
+ 	error = xfs_bmbt_lookup_eq(cur, left.br_startoff, left.br_startblock,
+ 				   left.br_blockcount, &i);
+ 	if (error)
+ 		return error;
+ 	XFS_WANT_CORRUPTED_RETURN(i == 1);
+ 
+ 	left.br_blockcount = blockcount;
+ 
+ 	return xfs_bmbt_update(cur, left.br_startoff, left.br_startblock,
+ 			       left.br_blockcount, left.br_state);
+ }
+ 
+ /*
+  * Shift a single extent.
+  */
+ STATIC int
+ xfs_bmse_shift_one(
+ 	struct xfs_inode		*ip,
+ 	int				whichfork,
+ 	xfs_fileoff_t			offset_shift_fsb,
+ 	int				*current_ext,
+ 	struct xfs_bmbt_rec_host	*gotp,
+ 	struct xfs_btree_cur		*cur,
+ 	int				*logflags)
+ {
+ 	struct xfs_ifork		*ifp;
+ 	xfs_fileoff_t			startoff;
+ 	struct xfs_bmbt_rec_host	*leftp;
+ 	struct xfs_bmbt_irec		got;
+ 	struct xfs_bmbt_irec		left;
+ 	int				error;
+ 	int				i;
+ 
+ 	ifp = XFS_IFORK_PTR(ip, whichfork);
+ 
+ 	xfs_bmbt_get_all(gotp, &got);
+ 	startoff = got.br_startoff - offset_shift_fsb;
+ 
+ 	/* delalloc extents should be prevented by caller */
+ 	XFS_WANT_CORRUPTED_RETURN(!isnullstartblock(got.br_startblock));
+ 
+ 	/*
+ 	 * Check for merge if we've got an extent to the left, otherwise make
+ 	 * sure there's enough room at the start of the file for the shift.
+ 	 */
+ 	if (*current_ext) {
+ 		/* grab the left extent and check for a large enough hole */
+ 		leftp = xfs_iext_get_ext(ifp, *current_ext - 1);
+ 		xfs_bmbt_get_all(leftp, &left);
+ 
+ 		if (startoff < left.br_startoff + left.br_blockcount)
+ 			return -EINVAL;
+ 
+ 		/* check whether to merge the extent or shift it down */
+ 		if (xfs_bmse_can_merge(&left, &got, offset_shift_fsb)) {
+ 			return xfs_bmse_merge(ip, whichfork, offset_shift_fsb,
+ 					      *current_ext, gotp, leftp, cur,
+ 					      logflags);
+ 		}
+ 	} else if (got.br_startoff < offset_shift_fsb)
+ 		return -EINVAL;
+ 
+ 	/*
+ 	 * Increment the extent index for the next iteration, update the start
+ 	 * offset of the in-core extent and update the btree if applicable.
+ 	 */
+ 	(*current_ext)++;
+ 	xfs_bmbt_set_startoff(gotp, startoff);
+ 	*logflags |= XFS_ILOG_CORE;
+ 	if (!cur) {
+ 		*logflags |= XFS_ILOG_DEXT;
+ 		return 0;
+ 	}
+ 
+ 	error = xfs_bmbt_lookup_eq(cur, got.br_startoff, got.br_startblock,
+ 				   got.br_blockcount, &i);
+ 	if (error)
+ 		return error;
+ 	XFS_WANT_CORRUPTED_RETURN(i == 1);
+ 
+ 	got.br_startoff = startoff;
+ 	return xfs_bmbt_update(cur, got.br_startoff, got.br_startblock,
+ 				got.br_blockcount, got.br_state);
+ }
+ 
+ /*
+  * Shift extent records to the left to cover a hole.
+  *
+  * The maximum number of extents to be shifted in a single operation is
+  * @num_exts. @start_fsb specifies the file offset to start the shift and the
+  * file offset where we've left off is returned in @next_fsb. @offset_shift_fsb
+  * is the length by which each extent is shifted. If there is no hole to shift
+  * the extents into, this will be considered invalid operation and we abort
+  * immediately.
+  */
+ int
+ xfs_bmap_shift_extents(
+ 	struct xfs_trans	*tp,
+ 	struct xfs_inode	*ip,
+ 	xfs_fileoff_t		start_fsb,
+ 	xfs_fileoff_t		offset_shift_fsb,
+ 	int			*done,
+ 	xfs_fileoff_t		*next_fsb,
+ 	xfs_fsblock_t		*firstblock,
+ 	struct xfs_bmap_free	*flist,
+ 	int			num_exts)
+ {
+ 	struct xfs_btree_cur		*cur = NULL;
+ 	struct xfs_bmbt_rec_host	*gotp;
+ 	struct xfs_bmbt_irec            got;
+ 	struct xfs_mount		*mp = ip->i_mount;
+ 	struct xfs_ifork		*ifp;
+ 	xfs_extnum_t			nexts = 0;
+ 	xfs_extnum_t			current_ext;
+ 	int				error = 0;
+ 	int				whichfork = XFS_DATA_FORK;
+ 	int				logflags = 0;
+ 	int				total_extents;
+ 
+ 	if (unlikely(XFS_TEST_ERROR(
+ 	    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&
+ 	     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),
+ 	     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {
+ 		XFS_ERROR_REPORT("xfs_bmap_shift_extents",
+ 				 XFS_ERRLEVEL_LOW, mp);
+ 		return -EFSCORRUPTED;
+ 	}
+ 
+ 	if (XFS_FORCED_SHUTDOWN(mp))
+ 		return -EIO;
+ 
+ 	ASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));
+ 	ASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));
+ 
+ 	ifp = XFS_IFORK_PTR(ip, whichfork);
+ 	if (!(ifp->if_flags & XFS_IFEXTENTS)) {
+ 		/* Read in all the extents */
+ 		error = xfs_iread_extents(tp, ip, whichfork);
+ 		if (error)
+ 			return error;
+ 	}
+ 
+ 	if (ifp->if_flags & XFS_IFBROOT) {
+ 		cur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);
+ 		cur->bc_private.b.firstblock = *firstblock;
+ 		cur->bc_private.b.flist = flist;
+ 		cur->bc_private.b.flags = 0;
+ 	}
+ 
+ 	/*
+ 	 * Look up the extent index for the fsb where we start shifting. We can
+ 	 * henceforth iterate with current_ext as extent list changes are locked
+ 	 * out via ilock.
+ 	 *
+ 	 * gotp can be null in 2 cases: 1) if there are no extents or 2)
+ 	 * start_fsb lies in a hole beyond which there are no extents. Either
+ 	 * way, we are done.
+ 	 */
+ 	gotp = xfs_iext_bno_to_ext(ifp, start_fsb, &current_ext);
+ 	if (!gotp) {
+ 		*done = 1;
+ 		goto del_cursor;
+ 	}
+ 
+ 	/*
+ 	 * There may be delalloc extents in the data fork before the range we
+ 	 * are collapsing out, so we cannot use the count of real extents here.
+ 	 * Instead we have to calculate it from the incore fork.
+ 	 */
+ 	total_extents = ifp->if_bytes / sizeof(xfs_bmbt_rec_t);
+ 	while (nexts++ < num_exts && current_ext < total_extents) {
+ 		error = xfs_bmse_shift_one(ip, whichfork, offset_shift_fsb,
+ 					&current_ext, gotp, cur, &logflags);
+ 		if (error)
+ 			goto del_cursor;
+ 
+ 		/* update total extent count and grab the next record */
+ 		total_extents = ifp->if_bytes / sizeof(xfs_bmbt_rec_t);
+ 		if (current_ext >= total_extents)
+ 			break;
+ 		gotp = xfs_iext_get_ext(ifp, current_ext);
+ 	}
+ 
+ 	/* Check if we are done */
+ 	if (current_ext == total_extents) {
+ 		*done = 1;
+ 	} else if (next_fsb) {
+ 		xfs_bmbt_get_all(gotp, &got);
+ 		*next_fsb = got.br_startoff;
+ 	}
+ 
+ del_cursor:
+ 	if (cur)
+ 		xfs_btree_del_cursor(cur,
+ 			error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);
+ 
+ 	if (logflags)
+ 		xfs_trans_log_inode(tp, ip, logflags);
+ 
+ 	return error;
+ }
++>>>>>>> 4db431f57be2 (xfs: cleanup xfs_bmse_merge returns)
* Unmerged path fs/xfs/libxfs/xfs_bmap.c
