xfs: add RENAME_WHITEOUT support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit 7dcf5c3e4527cfa2807567b00387cf2ed5e07f00
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/7dcf5c3e.failed

Whiteouts are used by overlayfs -  it has a crazy convention that a
whiteout is a character device inode with a major:minor of 0:0.
Because it's not documented anywhere, here's an example of what
RENAME_WHITEOUT does on ext4:

# echo foo > /mnt/scratch/foo
# echo bar > /mnt/scratch/bar
# ls -l /mnt/scratch
total 24
-rw-r--r-- 1 root root     4 Feb 11 20:22 bar
-rw-r--r-- 1 root root     4 Feb 11 20:22 foo
drwx------ 2 root root 16384 Feb 11 20:18 lost+found
# src/renameat2 -w /mnt/scratch/foo /mnt/scratch/bar
# ls -l /mnt/scratch
total 20
-rw-r--r-- 1 root root     4 Feb 11 20:22 bar
c--------- 1 root root  0, 0 Feb 11 20:23 foo
drwx------ 2 root root 16384 Feb 11 20:18 lost+found
# cat /mnt/scratch/bar
foo
#

In XFS rename terms, the operation that has been done is that source
(foo) has been moved to the target (bar), which is like a nomal
rename operation, but rather than the source being removed, it have
been replaced with a whiteout.

We can't allocate whiteout inodes within the rename transaction due
to allocation being a multi-commit transaction: rename needs to
be a single, atomic commit. Hence we have several options here, form
most efficient to least efficient:

    - use DT_WHT in the target dirent and do no whiteout inode
      allocation.  The main issue with this approach is that we need
      hooks in lookup to create a virtual chardev inode to present
      to userspace and in places where we might need to modify the
      dirent e.g. unlink.  Overlayfs also needs to be taught about
      DT_WHT. Most invasive change, lowest overhead.

    - create a special whiteout inode in the root directory (e.g. a
      ".wino" dirent) and then hardlink every new whiteout to it.
      This means we only need to create a single whiteout inode, and
      rename simply creates a hardlink to it. We can use DT_WHT for
      these, though using DT_CHR means we won't have to modify
      overlayfs, nor anything in userspace. Downside is we have to
      look up the whiteout inode on every operation and create it if
      it doesn't exist.

    - copy ext4: create a special whiteout chardev inode for every
      whiteout.  This is more complex than the above options because
      of the lack of atomicity between inode creation and the rename
      operation, requiring us to create a tmpfile inode and then
      linking it into the directory structure during the rename. At
      least with a tmpfile inode crashes between the create and
      rename doesn't leave unreferenced inodes or directory
      pollution around.

By far the simplest thing to do in the short term is to copy ext4.
While it is the most inefficient way of supporting whiteouts, but as
an initial implementation we can simply reuse existing functions and
add a small amount of extra code the the rename operation.

When we get full whiteout support in the VFS (via the dentry cache)
we can then look to supporting DT_WHT method outlined as the first
method of supporting whiteouts. But until then, we'll stick with
what overlayfs expects us to be: dumb and stupid.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>

(cherry picked from commit 7dcf5c3e4527cfa2807567b00387cf2ed5e07f00)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_inode.c
#	fs/xfs/xfs_iops.c
diff --cc fs/xfs/xfs_inode.c
index 0a9e226dbdb3,ded129d5ec0d..000000000000
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@@ -2742,45 -2650,234 +2742,116 @@@ xfs_sort_for_rename
  	}
  }
  
 -static int
 -xfs_finish_rename(
 -	struct xfs_trans	*tp,
 -	struct xfs_bmap_free	*free_list)
 -{
 -	int			committed = 0;
 -	int			error;
 -
 -	/*
 -	 * If this is a synchronous mount, make sure that the rename transaction
 -	 * goes to disk before returning to the user.
 -	 */
 -	if (tp->t_mountp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC))
 -		xfs_trans_set_sync(tp);
 -
 -	error = xfs_bmap_finish(&tp, free_list, &committed);
 -	if (error) {
 -		xfs_bmap_cancel(free_list);
 -		xfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);
 -		return error;
 -	}
 -
 -	return xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);
 -}
 -
 -/*
 - * xfs_cross_rename()
 - *
 - * responsible for handling RENAME_EXCHANGE flag in renameat2() sytemcall
 - */
 -STATIC int
 -xfs_cross_rename(
 -	struct xfs_trans	*tp,
 -	struct xfs_inode	*dp1,
 -	struct xfs_name		*name1,
 -	struct xfs_inode	*ip1,
 -	struct xfs_inode	*dp2,
 -	struct xfs_name		*name2,
 -	struct xfs_inode	*ip2,
 -	struct xfs_bmap_free	*free_list,
 -	xfs_fsblock_t		*first_block,
 -	int			spaceres)
 -{
 -	int		error = 0;
 -	int		ip1_flags = 0;
 -	int		ip2_flags = 0;
 -	int		dp2_flags = 0;
 -
 -	/* Swap inode number for dirent in first parent */
 -	error = xfs_dir_replace(tp, dp1, name1,
 -				ip2->i_ino,
 -				first_block, free_list, spaceres);
 -	if (error)
 -		goto out_trans_abort;
 -
 -	/* Swap inode number for dirent in second parent */
 -	error = xfs_dir_replace(tp, dp2, name2,
 -				ip1->i_ino,
 -				first_block, free_list, spaceres);
 -	if (error)
 -		goto out_trans_abort;
 -
 -	/*
 -	 * If we're renaming one or more directories across different parents,
 -	 * update the respective ".." entries (and link counts) to match the new
 -	 * parents.
 -	 */
 -	if (dp1 != dp2) {
 -		dp2_flags = XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG;
 -
 -		if (S_ISDIR(ip2->i_d.di_mode)) {
 -			error = xfs_dir_replace(tp, ip2, &xfs_name_dotdot,
 -						dp1->i_ino, first_block,
 -						free_list, spaceres);
 -			if (error)
 -				goto out_trans_abort;
 -
 -			/* transfer ip2 ".." reference to dp1 */
 -			if (!S_ISDIR(ip1->i_d.di_mode)) {
 -				error = xfs_droplink(tp, dp2);
 -				if (error)
 -					goto out_trans_abort;
 -				error = xfs_bumplink(tp, dp1);
 -				if (error)
 -					goto out_trans_abort;
 -			}
 -
 -			/*
 -			 * Although ip1 isn't changed here, userspace needs
 -			 * to be warned about the change, so that applications
 -			 * relying on it (like backup ones), will properly
 -			 * notify the change
 -			 */
 -			ip1_flags |= XFS_ICHGTIME_CHG;
 -			ip2_flags |= XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG;
 -		}
 -
 -		if (S_ISDIR(ip1->i_d.di_mode)) {
 -			error = xfs_dir_replace(tp, ip1, &xfs_name_dotdot,
 -						dp2->i_ino, first_block,
 -						free_list, spaceres);
 -			if (error)
 -				goto out_trans_abort;
 -
 -			/* transfer ip1 ".." reference to dp2 */
 -			if (!S_ISDIR(ip2->i_d.di_mode)) {
 -				error = xfs_droplink(tp, dp1);
 -				if (error)
 -					goto out_trans_abort;
 -				error = xfs_bumplink(tp, dp2);
 -				if (error)
 -					goto out_trans_abort;
 -			}
 -
 -			/*
 -			 * Although ip2 isn't changed here, userspace needs
 -			 * to be warned about the change, so that applications
 -			 * relying on it (like backup ones), will properly
 -			 * notify the change
 -			 */
 -			ip1_flags |= XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG;
 -			ip2_flags |= XFS_ICHGTIME_CHG;
 -		}
 -	}
 -
 -	if (ip1_flags) {
 -		xfs_trans_ichgtime(tp, ip1, ip1_flags);
 -		xfs_trans_log_inode(tp, ip1, XFS_ILOG_CORE);
 -	}
 -	if (ip2_flags) {
 -		xfs_trans_ichgtime(tp, ip2, ip2_flags);
 -		xfs_trans_log_inode(tp, ip2, XFS_ILOG_CORE);
 -	}
 -	if (dp2_flags) {
 -		xfs_trans_ichgtime(tp, dp2, dp2_flags);
 -		xfs_trans_log_inode(tp, dp2, XFS_ILOG_CORE);
 -	}
 -	xfs_trans_ichgtime(tp, dp1, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);
 -	xfs_trans_log_inode(tp, dp1, XFS_ILOG_CORE);
 -	return xfs_finish_rename(tp, free_list);
 -
 -out_trans_abort:
 -	xfs_bmap_cancel(free_list);
 -	xfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);
 -	return error;
 -}
 -
+ /*
+  * xfs_rename_alloc_whiteout()
+  *
+  * Return a referenced, unlinked, unlocked inode that that can be used as a
+  * whiteout in a rename transaction. We use a tmpfile inode here so that if we
+  * crash between allocating the inode and linking it into the rename transaction
+  * recovery will free the inode and we won't leak it.
+  */
+ static int
+ xfs_rename_alloc_whiteout(
+ 	struct xfs_inode	*dp,
+ 	struct xfs_inode	**wip)
+ {
+ 	struct xfs_inode	*tmpfile;
+ 	int			error;
+ 
+ 	error = xfs_create_tmpfile(dp, NULL, S_IFCHR | WHITEOUT_MODE, &tmpfile);
+ 	if (error)
+ 		return error;
+ 
+ 	/* Satisfy xfs_bumplink that this is a real tmpfile */
+ 	xfs_finish_inode_setup(tmpfile);
+ 	VFS_I(tmpfile)->i_state |= I_LINKABLE;
+ 
+ 	*wip = tmpfile;
+ 	return 0;
+ }
+ 
  /*
   * xfs_rename
   */
  int
  xfs_rename(
++<<<<<<< HEAD
 +	xfs_inode_t	*src_dp,
 +	struct xfs_name	*src_name,
 +	xfs_inode_t	*src_ip,
 +	xfs_inode_t	*target_dp,
 +	struct xfs_name	*target_name,
 +	xfs_inode_t	*target_ip)
 +{
 +	xfs_trans_t	*tp = NULL;
 +	xfs_mount_t	*mp = src_dp->i_mount;
 +	int		new_parent;		/* moving to a new dir */
 +	int		src_is_directory;	/* src_name is a directory */
 +	int		error;
 +	xfs_bmap_free_t free_list;
 +	xfs_fsblock_t   first_block;
 +	int		cancel_flags;
 +	int		committed;
 +	xfs_inode_t	*inodes[__XFS_SORT_INODES];
 +	int		num_inodes = __XFS_SORT_INODES;
 +	int		spaceres;
 +
 +	trace_xfs_rename(src_dp, target_dp, src_name, target_name);
 +
 +	new_parent = (src_dp != target_dp);
 +	src_is_directory = S_ISDIR(src_ip->i_d.di_mode);
++=======
+ 	struct xfs_inode	*src_dp,
+ 	struct xfs_name		*src_name,
+ 	struct xfs_inode	*src_ip,
+ 	struct xfs_inode	*target_dp,
+ 	struct xfs_name		*target_name,
+ 	struct xfs_inode	*target_ip,
+ 	unsigned int		flags)
+ {
+ 	struct xfs_mount	*mp = src_dp->i_mount;
+ 	struct xfs_trans	*tp;
+ 	struct xfs_bmap_free	free_list;
+ 	xfs_fsblock_t		first_block;
+ 	struct xfs_inode	*wip = NULL;		/* whiteout inode */
+ 	struct xfs_inode	*inodes[__XFS_SORT_INODES];
+ 	int			num_inodes = __XFS_SORT_INODES;
+ 	int			new_parent = (src_dp != target_dp);
+ 	int			src_is_directory = S_ISDIR(src_ip->i_d.di_mode);
+ 	int			cancel_flags = 0;
+ 	int			spaceres;
+ 	int			error;
+ 
+ 	trace_xfs_rename(src_dp, target_dp, src_name, target_name);
  
- 	xfs_sort_for_rename(src_dp, target_dp, src_ip, target_ip, NULL,
+ 	if ((flags & RENAME_EXCHANGE) && !target_ip)
+ 		return -EINVAL;
+ 
+ 	/*
+ 	 * If we are doing a whiteout operation, allocate the whiteout inode
+ 	 * we will be placing at the target and ensure the type is set
+ 	 * appropriately.
+ 	 */
+ 	if (flags & RENAME_WHITEOUT) {
+ 		ASSERT(!(flags & (RENAME_NOREPLACE | RENAME_EXCHANGE)));
+ 		error = xfs_rename_alloc_whiteout(target_dp, &wip);
+ 		if (error)
+ 			return error;
++>>>>>>> 7dcf5c3e4527 (xfs: add RENAME_WHITEOUT support)
+ 
+ 		/* setup target dirent info as whiteout */
+ 		src_name->type = XFS_DIR3_FT_CHRDEV;
+ 	}
+ 
+ 	xfs_sort_for_rename(src_dp, target_dp, src_ip, target_ip, wip,
  				inodes, &num_inodes);
  
 +	xfs_bmap_init(&free_list, &first_block);
  	tp = xfs_trans_alloc(mp, XFS_TRANS_RENAME);
 +	cancel_flags = XFS_TRANS_RELEASE_LOG_RES;
  	spaceres = XFS_RENAME_SPACE_RES(mp, target_name->len);
  	error = xfs_trans_reserve(tp, &M_RES(mp)->tr_rename, spaceres, 0);
 -	if (error == -ENOSPC) {
 +	if (error == ENOSPC) {
  		spaceres = 0;
  		error = xfs_trans_reserve(tp, &M_RES(mp)->tr_rename, 0, 0);
  	}
@@@ -2955,48 -3059,67 +3028,95 @@@
  		 */
  		error = xfs_droplink(tp, src_dp);
  		if (error)
 -			goto out_trans_abort;
 +			goto abort_return;
  	}
  
- 	error = xfs_dir_removename(tp, src_dp, src_name, src_ip->i_ino,
+ 	/*
+ 	 * For whiteouts, we only need to update the source dirent with the
+ 	 * inode number of the whiteout inode rather than removing it
+ 	 * altogether.
+ 	 */
+ 	if (wip) {
+ 		error = xfs_dir_replace(tp, src_dp, src_name, wip->i_ino,
  					&first_block, &free_list, spaceres);
+ 	} else
+ 		error = xfs_dir_removename(tp, src_dp, src_name, src_ip->i_ino,
+ 					   &first_block, &free_list, spaceres);
  	if (error)
 -		goto out_trans_abort;
 +		goto abort_return;
  
+ 	/*
+ 	 * For whiteouts, we need to bump the link count on the whiteout inode.
+ 	 * This means that failures all the way up to this point leave the inode
+ 	 * on the unlinked list and so cleanup is a simple matter of dropping
+ 	 * the remaining reference to it. If we fail here after bumping the link
+ 	 * count, we're shutting down the filesystem so we'll never see the
+ 	 * intermediate state on disk.
+ 	 */
+ 	if (wip) {
+ 		ASSERT(wip->i_d.di_nlink == 0);
+ 		error = xfs_bumplink(tp, wip);
+ 		if (error)
+ 			goto out_trans_abort;
+ 		error = xfs_iunlink_remove(tp, wip);
+ 		if (error)
+ 			goto out_trans_abort;
+ 		xfs_trans_log_inode(tp, wip, XFS_ILOG_CORE);
+ 
+ 		/*
+ 		 * Now we have a real link, clear the "I'm a tmpfile" state
+ 		 * flag from the inode so it doesn't accidentally get misused in
+ 		 * future.
+ 		 */
+ 		VFS_I(wip)->i_state &= ~I_LINKABLE;
+ 	}
+ 
  	xfs_trans_ichgtime(tp, src_dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);
  	xfs_trans_log_inode(tp, src_dp, XFS_ILOG_CORE);
  	if (new_parent)
  		xfs_trans_log_inode(tp, target_dp, XFS_ILOG_CORE);
  
++<<<<<<< HEAD
 +	/*
 +	 * If this is a synchronous mount, make sure that the
 +	 * rename transaction goes to disk before returning to
 +	 * the user.
 +	 */
 +	if (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC)) {
 +		xfs_trans_set_sync(tp);
 +	}
++=======
+ 	error = xfs_finish_rename(tp, &free_list);
+ 	if (wip)
+ 		IRELE(wip);
+ 	return error;
++>>>>>>> 7dcf5c3e4527 (xfs: add RENAME_WHITEOUT support)
  
 -out_trans_abort:
 +	error = xfs_bmap_finish(&tp, &free_list, &committed);
 +	if (error) {
 +		xfs_bmap_cancel(&free_list);
 +		xfs_trans_cancel(tp, (XFS_TRANS_RELEASE_LOG_RES |
 +				 XFS_TRANS_ABORT));
 +		goto std_return;
 +	}
 +
 +	/*
 +	 * trans_commit will unlock src_ip, target_ip & decrement
 +	 * the vnode references.
 +	 */
 +	return xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);
 +
 + abort_return:
  	cancel_flags |= XFS_TRANS_ABORT;
 -out_bmap_cancel:
 + error_return:
  	xfs_bmap_cancel(&free_list);
 -out_trans_cancel:
  	xfs_trans_cancel(tp, cancel_flags);
++<<<<<<< HEAD
 + std_return:
++=======
+ 	if (wip)
+ 		IRELE(wip);
++>>>>>>> 7dcf5c3e4527 (xfs: add RENAME_WHITEOUT support)
  	return error;
  }
  
diff --cc fs/xfs/xfs_iops.c
index 5d80201ac026,9bcad7132f75..000000000000
--- a/fs/xfs/xfs_iops.c
+++ b/fs/xfs/xfs_iops.c
@@@ -365,12 -393,20 +365,23 @@@ xfs_vn_rename
  	struct xfs_name	oname;
  	struct xfs_name	nname;
  
++<<<<<<< HEAD
 +	xfs_dentry_to_name(&oname, odentry, 0);
++=======
+ 	if (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))
+ 		return -EINVAL;
+ 
+ 	/* if we are exchanging files, we need to set i_mode of both files */
+ 	if (flags & RENAME_EXCHANGE)
+ 		omode = ndentry->d_inode->i_mode;
+ 
+ 	xfs_dentry_to_name(&oname, odentry, omode);
++>>>>>>> 7dcf5c3e4527 (xfs: add RENAME_WHITEOUT support)
  	xfs_dentry_to_name(&nname, ndentry, odentry->d_inode->i_mode);
  
 -	return xfs_rename(XFS_I(odir), &oname, XFS_I(odentry->d_inode),
 -			  XFS_I(ndir), &nname,
 -			  new_inode ? XFS_I(new_inode) : NULL, flags);
 +	return -xfs_rename(XFS_I(odir), &oname, XFS_I(odentry->d_inode),
 +			   XFS_I(ndir), &nname, new_inode ?
 +						XFS_I(new_inode) : NULL);
  }
  
  /*
* Unmerged path fs/xfs/xfs_inode.c
* Unmerged path fs/xfs/xfs_iops.c
