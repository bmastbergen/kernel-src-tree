tools/power turbostat: update parameters, documentation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [tools] turbostat: update parameters, documentation (Prarit Bhargava) [1187329]
Rebuild_FUZZ: 87.76%
commit-author Len Brown <len.brown@intel.com>
commit d8af6f5f0fca7c5271539dab0d75942ccf09d65c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/d8af6f5f.failed

Long format options added, though the short ones should still work.
eg. the new "--Counter 0x10" is the same as the old "-C 0x10"

Note this Incompatibility:
Old:
-v displayed verbose debug output

New:
-v and --version simpaly display version

Additional parameters:
-d and --debug display verbose debug output
-h and --help display a help message

Updated turbosat.8 man page accordingly.

	Signed-off-by: Len Brown <len.brown@intel.com>
(cherry picked from commit d8af6f5f0fca7c5271539dab0d75942ccf09d65c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/power/x86/turbostat/turbostat.8
#	tools/power/x86/turbostat/turbostat.c
diff --cc tools/power/x86/turbostat/turbostat.8
index 56bfb523c5bb,feea7ad9500b..000000000000
--- a/tools/power/x86/turbostat/turbostat.8
+++ b/tools/power/x86/turbostat/turbostat.8
@@@ -9,40 -9,50 +9,63 @@@ turbostat \- Report processor frequenc
  .br
  .B turbostat
  .RB [ Options ]
- .RB [ "\-i interval_sec" ]
+ .RB [ "\--interval seconds" ]
  .SH DESCRIPTION
  \fBturbostat \fP reports processor topology, frequency,
++<<<<<<< HEAD
 +idle power-state statistics, temperature and power on modern X86 processors.
 +Either \fBcommand\fP is forked and statistics are printed
 +upon its completion, or statistics are printed periodically.
 +
 +\fBturbostat \fP
 +must be run on root, and
 +minimally requires that the processor
 +supports an "invariant" TSC, plus the APERF and MPERF MSRs.
 +Additional information is reported depending on hardware counter support.
 +
++=======
+ idle power-state statistics, temperature and power on X86 processors.
+ There are two ways to invoke turbostat.
+ The first method is to supply a
+ \fBcommand\fP, which is forked and statistics are printed
+ upon its completion.
+ The second method is to omit the command,
+ and turbostat displays statistics every 5 seconds.
+ The 5-second interval can be changed using the --interval option.
+ 
+ Some information is not available on older processors.
++>>>>>>> d8af6f5f0fca (tools/power turbostat: update parameters, documentation)
  .SS Options
- The \fB-p\fP option limits output to the 1st thread in 1st core of each package.
+ \fB--Counter MSR#\fP shows the delta of the specified 64-bit MSR counter.
+ .PP
+ \fB--counter MSR#\fP shows the delta of the specified 32-bit MSR counter.
+ .PP
+ \fB--Dump\fP displays the raw counter values.
+ .PP
+ \fB--debug\fP displays additional system configuration information.  Invoking this parameter
+ more than once may also enable internal turbostat debug information.
+ .PP
+ \fB--interval seconds\fP overrides the default 5-second measurement interval.
+ .PP
+ \fB--help\fP displays usage for the most common parameters.
  .PP
- The \fB-P\fP option limits output to the 1st thread in each Package.
+ \fB--Joules\fP displays energy in Joules, rather than dividing Joules by time to print power in Watts.
  .PP
- The \fB-S\fP option limits output to a 1-line System Summary for each interval.
+ \fB--MSR MSR#\fP shows the specified 64-bit MSR value.
  .PP
- The \fB-v\fP option increases verbosity.
+ \fB--msr MSR#\fP shows the specified 32-bit MSR value.
  .PP
- The \fB-c MSR#\fP option includes the delta of the specified 32-bit MSR counter.
+ \fB--Package\fP limits output to the system summary plus the 1st thread in each Package.
  .PP
- The \fB-C MSR#\fP option includes the delta of the specified 64-bit MSR counter.
+ \fB--processor\fP limits output to the system summary plus the 1st thread in each processor of each package.  Ie. it skips hyper-threaded siblings.
  .PP
- The \fB-m MSR#\fP option includes the the specified 32-bit MSR value.
+ \fB--Summary\fP limits output to a 1-line System Summary for each interval.
  .PP
- The \fB-M MSR#\fP option includes the the specified 64-bit MSR value.
+ \fB--TCC temperature\fP sets the Thermal Control Circuit temperature for systems which do not export that value.  This is used for making sense of the Digital Thermal Sensor outputs, as they return degrees Celsius below the TCC activation temperature.
  .PP
- The \fB-i interval_sec\fP option prints statistics every \fiinterval_sec\fP seconds.
- The default is 5 seconds.
+ \fB--version\fP displays the version.
  .PP
- The \fBcommand\fP parameter forks \fBcommand\fP and upon its exit,
+ The \fBcommand\fP parameter forks \fBcommand\fP, and upon its exit,
  displays the statistics gathered since it was forked.
  .PP
  .SH FIELD DESCRIPTIONS
@@@ -184,15 -200,33 +207,42 @@@ multiple invocations of itself
  
  \fBturbostat \fP
  may work poorly on Linux-2.6.20 through 2.6.29,
 -as \fBacpi-cpufreq \fPperiodically cleared the APERF and MPERF MSRs
 +as \fBacpi-cpufreq \fPperiodically cleared the APERF and MPERF
  in those kernels.
  
++<<<<<<< HEAD
 +If the TSC column does not make sense, then
 +the other numbers will also make no sense.
 +Turbostat is lightweight, and its data collection is not atomic.
 +These issues are usually caused by an extremely short measurement
 +interval (much less than 1 second), or system activity that prevents
 +turbostat from being able to run on all CPUS to quickly collect data.
++=======
+ AVG_MHz = APERF_delta/measurement_interval.  This is the actual
+ number of elapsed cycles divided by the entire sample interval --
+ including idle time.  Note that this calculation is resilient
+ to systems lacking a non-stop TSC.
+ 
+ TSC_MHz = TSC_delta/measurement_interval.
+ On a system with an invariant TSC, this value will be constant
+ and will closely match the base frequency value shown
+ in the brand string in /proc/cpuinfo.  On a system where
+ the TSC stops in idle, TSC_MHz will drop
+ below the processor's base frequency.
+ 
+ %Busy = MPERF_delta/TSC_delta
+ 
+ Bzy_MHz = TSC_delta/APERF_delta/MPERF_delta/measurement_interval
+ 
+ Note that these calculations depend on TSC_delta, so they
+ are not reliable during intervals when TSC_MHz is not running at the base frequency.
+ 
+ Turbostat data collection is not atomic.
+ Extremely short measurement intervals (much less than 1 second),
+ or system activity that prevents turbostat from being able
+ to run on all CPUS to quickly collect data, will result in
+ inconsistent results.
++>>>>>>> d8af6f5f0fca (tools/power turbostat: update parameters, documentation)
  
  The APERF, MPERF MSRs are defined to count non-halted cycles.
  Although it is not guaranteed by the architecture, turbostat assumes
diff --cc tools/power/x86/turbostat/turbostat.c
index 4941c7e942b5,3f5a9af34f47..000000000000
--- a/tools/power/x86/turbostat/turbostat.c
+++ b/tools/power/x86/turbostat/turbostat.c
@@@ -2121,18 -2284,19 +2120,27 @@@ void check_cpuid(
  	do_ptm = eax & (1 << 6);
  	has_epb = ecx & (1 << 3);
  
++<<<<<<< HEAD
 +	if (verbose)
 +		fprintf(stderr, "CPUID(6): %s%s%s%s\n",
 +			has_aperf ? "APERF" : "No APERF!",
 +			do_dts ? ", DTS" : "",
 +			do_ptm ? ", PTM": "",
 +			has_epb ? ", EPB": "");
++=======
+ 	if (debug)
+ 		fprintf(stderr, "CPUID(6): %sAPERF, %sDTS, %sPTM, %sEPB\n",
+ 			has_aperf ? "" : "No ",
+ 			do_dts ? "" : "No ",
+ 			do_ptm ? "" : "No ",
+ 			has_epb ? "" : "No ");
++>>>>>>> d8af6f5f0fca (tools/power turbostat: update parameters, documentation)
 +
 +	if (!has_aperf)
 +		errx(-1, "No APERF");
  
 -	do_nhm_platform_info = do_nhm_cstates = do_smi = probe_nhm_msrs(family, model);
 +	do_nhm_platform_info = do_nhm_cstates = do_smi = has_nhm_msrs(family, model);
  	do_snb_cstates = has_snb_msrs(family, model);
 -	do_pc2 = do_snb_cstates && (pkg_cstate_limit >= PCL__2);
 -	do_pc3 = (pkg_cstate_limit >= PCL__3);
 -	do_pc6 = (pkg_cstate_limit >= PCL__6);
 -	do_pc7 = do_snb_cstates && (pkg_cstate_limit >= PCL__7);
  	do_c8_c9_c10 = has_hsw_msrs(family, model);
  	do_slm_cstates = is_slm(family, model);
  	bclk = discover_bclk(family, model);
@@@ -2371,13 -2551,16 +2394,20 @@@ void turbostat_init(
  
  	setup_all_buffers();
  
- 	if (verbose)
+ 	if (debug)
  		print_verbose_header();
  
- 	if (verbose)
+ 	if (debug)
  		for_all_cpus(print_epb, ODD_COUNTERS);
  
++<<<<<<< HEAD
 +	if (verbose)
++=======
+ 	if (debug)
+ 		for_all_cpus(print_perf_limit, ODD_COUNTERS);
+ 
+ 	if (debug)
++>>>>>>> d8af6f5f0fca (tools/power turbostat: update parameters, documentation)
  		for_all_cpus(print_rapl, ODD_COUNTERS);
  
  	for_all_cpus(set_temperature_target, ODD_COUNTERS);
@@@ -2505,9 -2714,8 +2561,14 @@@ int main(int argc, char **argv
  {
  	cmdline(argc, argv);
  
++<<<<<<< HEAD
 +	if (verbose)
 +		fprintf(stderr, "turbostat v3.8 14-Aug 2014"
 +			" - Len Brown <lenb@kernel.org>\n");
++=======
+ 	if (debug)
+ 		print_version();
++>>>>>>> d8af6f5f0fca (tools/power turbostat: update parameters, documentation)
  
  	turbostat_init();
  
* Unmerged path tools/power/x86/turbostat/turbostat.8
* Unmerged path tools/power/x86/turbostat/turbostat.c
