tcp: metrics: Avoid duplicate entries with the same destination-IP

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Christoph Paasch <christoph.paasch@uclouvain.be>
commit 77f99ad16a07aa062c2d30fae57b1fee456f6ef6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/77f99ad1.failed

Because the tcp-metrics is an RCU-list, it may be that two
soft-interrupts are inside __tcp_get_metrics() for the same
destination-IP at the same time. If this destination-IP is not yet part of
the tcp-metrics, both soft-interrupts will end up in tcpm_new and create
a new entry for this IP.
So, we will have two tcp-metrics with the same destination-IP in the list.

This patch checks twice __tcp_get_metrics(). First without holding the
lock, then while holding the lock. The second one is there to confirm
that the entry has not been added by another soft-irq while waiting for
the spin-lock.

Fixes: 51c5d0c4b169b (tcp: Maintain dynamic metrics in local cache.)
	Signed-off-by: Christoph Paasch <christoph.paasch@uclouvain.be>
	Reviewed-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 77f99ad16a07aa062c2d30fae57b1fee456f6ef6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_metrics.c
diff --cc net/ipv4/tcp_metrics.c
index 699a42faab9c,098b3a29f6f3..000000000000
--- a/net/ipv4/tcp_metrics.c
+++ b/net/ipv4/tcp_metrics.c
@@@ -131,11 -133,20 +134,27 @@@ static void tcpm_suck_dst(struct tcp_me
  	}
  }
  
+ #define TCP_METRICS_TIMEOUT		(60 * 60 * HZ)
+ 
+ static void tcpm_check_stamp(struct tcp_metrics_block *tm, struct dst_entry *dst)
+ {
+ 	if (tm && unlikely(time_after(jiffies, tm->tcpm_stamp + TCP_METRICS_TIMEOUT)))
+ 		tcpm_suck_dst(tm, dst, false);
+ }
+ 
+ #define TCP_METRICS_RECLAIM_DEPTH	5
+ #define TCP_METRICS_RECLAIM_PTR		(struct tcp_metrics_block *) 0x1UL
+ 
  static struct tcp_metrics_block *tcpm_new(struct dst_entry *dst,
++<<<<<<< HEAD
 +					  struct inetpeer_addr *saddr,
 +					  struct inetpeer_addr *daddr,
 +					  unsigned int hash,
 +					  bool reclaim)
++=======
+ 					  struct inetpeer_addr *addr,
+ 					  unsigned int hash)
++>>>>>>> 77f99ad16a07 (tcp: metrics: Avoid duplicate entries with the same destination-IP)
  {
  	struct tcp_metrics_block *tm;
  	struct net *net;
@@@ -292,18 -296,15 +315,17 @@@ static struct tcp_metrics_block *tcp_ge
  						 bool create)
  {
  	struct tcp_metrics_block *tm;
 -	struct inetpeer_addr addr;
 +	struct inetpeer_addr saddr, daddr;
  	unsigned int hash;
  	struct net *net;
- 	bool reclaim;
  
 -	addr.family = sk->sk_family;
 -	switch (addr.family) {
 +	saddr.family = sk->sk_family;
 +	daddr.family = sk->sk_family;
 +	switch (daddr.family) {
  	case AF_INET:
 -		addr.addr.a4 = inet_sk(sk)->inet_daddr;
 -		hash = (__force unsigned int) addr.addr.a4;
 +		saddr.addr.a4 = inet_sk(sk)->inet_saddr;
 +		daddr.addr.a4 = inet_sk(sk)->inet_daddr;
 +		hash = (__force unsigned int) daddr.addr.a4;
  		break;
  #if IS_ENABLED(CONFIG_IPV6)
  	case AF_INET6:
@@@ -319,14 -319,11 +341,22 @@@
  	net = dev_net(dst->dev);
  	hash = hash_32(hash, net->ipv4.tcp_metrics_hash_log);
  
++<<<<<<< HEAD
 +	tm = __tcp_get_metrics(&saddr, &daddr, net, hash);
 +	reclaim = false;
 +	if (tm == TCP_METRICS_RECLAIM_PTR) {
 +		reclaim = true;
++=======
+ 	tm = __tcp_get_metrics(&addr, net, hash);
+ 	if (tm == TCP_METRICS_RECLAIM_PTR)
++>>>>>>> 77f99ad16a07 (tcp: metrics: Avoid duplicate entries with the same destination-IP)
  		tm = NULL;
- 	}
  	if (!tm && create)
++<<<<<<< HEAD
 +		tm = tcpm_new(dst, &saddr, &daddr, hash, reclaim);
++=======
+ 		tm = tcpm_new(dst, &addr, hash);
++>>>>>>> 77f99ad16a07 (tcp: metrics: Avoid duplicate entries with the same destination-IP)
  	else
  		tcpm_check_stamp(tm, dst);
  
* Unmerged path net/ipv4/tcp_metrics.c
