IB/ipoib: deserialize multicast joins

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [infiniband] ipoib: deserialize multicast joins (Doug Ledford) [1183881]
Rebuild_FUZZ: 95.77%
commit-author Doug Ledford <dledford@redhat.com>
commit d2fe937ce6ce23daf5fb214e45432dbb631581b7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/d2fe937c.failed

Allow the ipoib layer to attempt to join all outstanding multicast
groups at once.  The ib_sa layer will serialize multiple attempts to
join the same group, but will process attempts to join different groups
in parallel.  Take advantage of that.

In order to make this happen, change the mcast_join_thread to loop
through all needed joins, sending a join request for each one that we
still need to join.  There are a few special cases we handle though:

1) Don't attempt to join anything but the broadcast group until the join
of the broadcast group has succeeded.
2) No longer restart the join task at the end of completion handling.
If we completed successfully, we are done.  The join task now needs kicked
either by mcast_send or mcast_restart_task or mcast_start_thread, but
should not need started anytime else except when scheduling a backoff
attempt to rejoin.
3) No longer use separate join/completion routines for regular and
sendonly joins, pass them all through the same routine and just do the
right thing based on the SENDONLY join flag.
4) Only try to join a SENDONLY join twice, then drop the packets and
quit trying.  We leave the mcast group in the list so that if we get a
new packet, all that we have to do is queue up the packet and restart
the join task and it will automatically try to join twice and then
either send or flush the queue again.

	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit d2fe937ce6ce23daf5fb214e45432dbb631581b7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/ipoib/ipoib_multicast.c
diff --cc drivers/infiniband/ulp/ipoib/ipoib_multicast.c
index ffb83b5f7e80,c670d9c2cda7..000000000000
--- a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_multicast.c
@@@ -270,89 -307,6 +270,92 @@@ static int ipoib_mcast_join_finish(stru
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int
 +ipoib_mcast_sendonly_join_complete(int status,
 +				   struct ib_sa_multicast *multicast)
 +{
 +	struct ipoib_mcast *mcast = multicast->context;
 +	struct net_device *dev = mcast->dev;
 +
 +	/* We trap for port events ourselves. */
 +	if (status == -ENETRESET)
 +		return 0;
 +
 +	if (!status)
 +		status = ipoib_mcast_join_finish(mcast, &multicast->rec);
 +
 +	if (status) {
 +		if (mcast->logcount++ < 20)
 +			ipoib_dbg_mcast(netdev_priv(dev), "multicast join failed for %pI6, status %d\n",
 +					mcast->mcmember.mgid.raw, status);
 +
 +		/* Flush out any queued packets */
 +		netif_tx_lock_bh(dev);
 +		while (!skb_queue_empty(&mcast->pkt_queue)) {
 +			++dev->stats.tx_dropped;
 +			dev_kfree_skb_any(skb_dequeue(&mcast->pkt_queue));
 +		}
 +		netif_tx_unlock_bh(dev);
 +
 +		/* Clear the busy flag so we try again */
 +		status = test_and_clear_bit(IPOIB_MCAST_FLAG_BUSY,
 +					    &mcast->flags);
 +	}
 +	return status;
 +}
 +
 +static int ipoib_mcast_sendonly_join(struct ipoib_mcast *mcast)
 +{
 +	struct net_device *dev = mcast->dev;
 +	struct ipoib_dev_priv *priv = netdev_priv(dev);
 +	struct ib_sa_mcmember_rec rec = {
 +#if 0				/* Some SMs don't support send-only yet */
 +		.join_state = 4
 +#else
 +		.join_state = 1
 +#endif
 +	};
 +	int ret = 0;
 +
 +	if (!test_bit(IPOIB_FLAG_OPER_UP, &priv->flags)) {
 +		ipoib_dbg_mcast(priv, "device shutting down, no multicast joins\n");
 +		return -ENODEV;
 +	}
 +
 +	if (test_and_set_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags)) {
 +		ipoib_dbg_mcast(priv, "multicast entry busy, skipping\n");
 +		return -EBUSY;
 +	}
 +
 +	rec.mgid     = mcast->mcmember.mgid;
 +	rec.port_gid = priv->local_gid;
 +	rec.pkey     = cpu_to_be16(priv->pkey);
 +
 +	mcast->mc = ib_sa_join_multicast(&ipoib_sa_client, priv->ca,
 +					 priv->port, &rec,
 +					 IB_SA_MCMEMBER_REC_MGID	|
 +					 IB_SA_MCMEMBER_REC_PORT_GID	|
 +					 IB_SA_MCMEMBER_REC_PKEY	|
 +					 IB_SA_MCMEMBER_REC_JOIN_STATE,
 +					 GFP_ATOMIC,
 +					 ipoib_mcast_sendonly_join_complete,
 +					 mcast);
 +	if (IS_ERR(mcast->mc)) {
 +		ret = PTR_ERR(mcast->mc);
 +		clear_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags);
 +		ipoib_warn(priv, "ib_sa_join_multicast failed (ret = %d)\n",
 +			   ret);
 +	} else {
 +		ipoib_dbg_mcast(priv, "no multicast record for %pI6, starting join\n",
 +				mcast->mcmember.mgid.raw);
 +	}
 +
 +	return ret;
 +}
 +
++=======
++>>>>>>> d2fe937ce6ce (IB/ipoib: deserialize multicast joins)
  void ipoib_mcast_carrier_on_task(struct work_struct *work)
  {
  	struct ipoib_dev_priv *priv = container_of(work, struct ipoib_dev_priv,
@@@ -382,9 -347,21 +385,11 @@@ static int ipoib_mcast_join_complete(in
  	struct net_device *dev = mcast->dev;
  	struct ipoib_dev_priv *priv = netdev_priv(dev);
  
- 	ipoib_dbg_mcast(priv, "join completion for %pI6 (status %d)\n",
+ 	ipoib_dbg_mcast(priv, "%sjoin completion for %pI6 (status %d)\n",
+ 			test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags) ?
+ 			"sendonly " : "",
  			mcast->mcmember.mgid.raw, status);
  
 -	/*
 -	 * We have to take the mutex to force mcast_join to
 -	 * return from ib_sa_multicast_join and set mcast->mc to a
 -	 * valid value.  Otherwise we were racing with ourselves in
 -	 * that we might fail here, but get a valid return from
 -	 * ib_sa_multicast_join after we had cleared mcast->mc here,
 -	 * resulting in mis-matched joins and leaves and a deadlock
 -	 */
 -	mutex_lock(&mcast_mutex);
 -
  	/* We trap for port events ourselves. */
  	if (status == -ENETRESET) {
  		status = 0;
@@@ -396,49 -373,60 +401,99 @@@
  
  	if (!status) {
  		mcast->backoff = 1;
++<<<<<<< HEAD
 +		mutex_lock(&mcast_mutex);
 +		if (test_bit(IPOIB_MCAST_RUN, &priv->flags))
 +			queue_delayed_work(ipoib_workqueue,
 +					   &priv->mcast_task, 0);
 +		mutex_unlock(&mcast_mutex);
 +
 +		/*
 +		 * Defer carrier on work to ipoib_workqueue to avoid a
 +		 * deadlock on rtnl_lock here.
 +		 */
 +		if (mcast == priv->broadcast)
 +			queue_work(ipoib_workqueue, &priv->carrier_on_task);
 +
 +		status = 0;
 +		goto out;
++=======
+ 		mcast->delay_until = jiffies;
+ 
+ 		/*
+ 		 * Defer carrier on work to priv->wq to avoid a
+ 		 * deadlock on rtnl_lock here.  Requeue our multicast
+ 		 * work too, which will end up happening right after
+ 		 * our carrier on task work and will allow us to
+ 		 * send out all of the non-broadcast joins
+ 		 */
+ 		if (mcast == priv->broadcast) {
+ 			queue_work(priv->wq, &priv->carrier_on_task);
+ 			__ipoib_mcast_schedule_join_thread(priv, NULL, 0);
+ 		}
+ 	} else {
+ 		if (mcast->logcount++ < 20) {
+ 			if (status == -ETIMEDOUT || status == -EAGAIN) {
+ 				ipoib_dbg_mcast(priv, "%smulticast join failed for %pI6, status %d\n",
+ 						test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags) ? "sendonly " : "",
+ 						mcast->mcmember.mgid.raw, status);
+ 			} else {
+ 				ipoib_warn(priv, "%smulticast join failed for %pI6, status %d\n",
+ 						test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags) ? "sendonly " : "",
+ 					   mcast->mcmember.mgid.raw, status);
+ 			}
+ 		}
+ 
+ 		if (test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags) &&
+ 		    mcast->backoff >= 2) {
+ 			/*
+ 			 * We only retry sendonly joins once before we drop
+ 			 * the packet and quit trying to deal with the
+ 			 * group.  However, we leave the group in the
+ 			 * mcast list as an unjoined group.  If we want to
+ 			 * try joining again, we simply queue up a packet
+ 			 * and restart the join thread.  The empty queue
+ 			 * is why the join thread ignores this group.
+ 			 */
+ 			mcast->backoff = 1;
+ 			netif_tx_lock_bh(dev);
+ 			while (!skb_queue_empty(&mcast->pkt_queue)) {
+ 				++dev->stats.tx_dropped;
+ 				dev_kfree_skb_any(skb_dequeue(&mcast->pkt_queue));
+ 			}
+ 			netif_tx_unlock_bh(dev);
+ 		} else
+ 			/* Requeue this join task with a backoff delay */
+ 			__ipoib_mcast_schedule_join_thread(priv, mcast, 1);
++>>>>>>> d2fe937ce6ce (IB/ipoib: deserialize multicast joins)
  	}
 +
 +	if (mcast->logcount++ < 20) {
 +		if (status == -ETIMEDOUT || status == -EAGAIN) {
 +			ipoib_dbg_mcast(priv, "multicast join failed for %pI6, status %d\n",
 +					mcast->mcmember.mgid.raw, status);
 +		} else {
 +			ipoib_warn(priv, "multicast join failed for %pI6, status %d\n",
 +				   mcast->mcmember.mgid.raw, status);
 +		}
 +	}
 +
 +	mcast->backoff *= 2;
 +	if (mcast->backoff > IPOIB_MAX_BACKOFF_SECONDS)
 +		mcast->backoff = IPOIB_MAX_BACKOFF_SECONDS;
 +
 +	/* Clear the busy flag so we try again */
 +	status = test_and_clear_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags);
 +
 +	mutex_lock(&mcast_mutex);
 +	spin_lock_irq(&priv->lock);
 +	if (test_bit(IPOIB_MCAST_RUN, &priv->flags))
 +		queue_delayed_work(ipoib_workqueue, &priv->mcast_task,
 +				   mcast->backoff * HZ);
 +	spin_unlock_irq(&priv->lock);
 +	mutex_unlock(&mcast_mutex);
  out:
 -	clear_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags);
 -	if (status)
 -		mcast->mc = NULL;
  	complete(&mcast->done);
 -	mutex_unlock(&mcast_mutex);
  	return status;
  }
  
@@@ -563,37 -552,65 +618,86 @@@ void ipoib_mcast_join_task(struct work_
  	}
  
  	if (!test_bit(IPOIB_MCAST_FLAG_ATTACHED, &priv->broadcast->flags)) {
 -		if (IS_ERR_OR_NULL(priv->broadcast->mc) &&
 -		    !test_bit(IPOIB_MCAST_FLAG_BUSY, &priv->broadcast->flags)) {
 -			mcast = priv->broadcast;
 -			create = 0;
 -			if (mcast->backoff > 1 &&
 -			    time_before(jiffies, mcast->delay_until)) {
 -				delay_until = mcast->delay_until;
 -				mcast = NULL;
 -			}
 -		}
 -		goto out;
 +		if (!test_bit(IPOIB_MCAST_FLAG_BUSY, &priv->broadcast->flags))
 +			ipoib_mcast_join(dev, priv->broadcast, 0);
 +		return;
  	}
  
++<<<<<<< HEAD
 +	while (1) {
 +		struct ipoib_mcast *mcast = NULL;
 +
 +		spin_lock_irq(&priv->lock);
 +		list_for_each_entry(mcast, &priv->multicast_list, list) {
 +			if (!test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags)
 +			    && !test_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags)
 +			    && !test_bit(IPOIB_MCAST_FLAG_ATTACHED, &mcast->flags)) {
 +				/* Found the next unjoined group */
 +				break;
 +			}
++=======
+ 	/*
+ 	 * We'll never get here until the broadcast group is both allocated
+ 	 * and attached
+ 	 */
+ 	list_for_each_entry(mcast, &priv->multicast_list, list) {
+ 		if (IS_ERR_OR_NULL(mcast->mc) &&
+ 		    !test_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags) &&
+ 		    (!test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags) ||
+ 		     !skb_queue_empty(&mcast->pkt_queue))) {
+ 			if (mcast->backoff == 1 ||
+ 			    time_after_eq(jiffies, mcast->delay_until)) {
+ 				/* Found the next unjoined group */
+ 				init_completion(&mcast->done);
+ 				set_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags);
+ 				if (test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags))
+ 					create = 0;
+ 				else
+ 					create = 1;
+ 				spin_unlock_irq(&priv->lock);
+ 				mutex_unlock(&mcast_mutex);
+ 				ipoib_mcast_join(dev, mcast, create);
+ 				mutex_lock(&mcast_mutex);
+ 				spin_lock_irq(&priv->lock);
+ 			} else if (!delay_until ||
+ 				 time_before(mcast->delay_until, delay_until))
+ 				delay_until = mcast->delay_until;
++>>>>>>> d2fe937ce6ce (IB/ipoib: deserialize multicast joins)
  		}
 +		spin_unlock_irq(&priv->lock);
 +
 +		if (&mcast->list == &priv->multicast_list) {
 +			/* All done */
 +			break;
 +		}
 +
 +		ipoib_mcast_join(dev, mcast, 1);
 +		return;
  	}
  
++<<<<<<< HEAD
 +	ipoib_dbg_mcast(priv, "successfully joined all multicast groups\n");
 +
 +	clear_bit(IPOIB_MCAST_RUN, &priv->flags);
++=======
+ 	mcast = NULL;
+ 	ipoib_dbg_mcast(priv, "successfully started all multicast joins\n");
+ 
+ out:
+ 	if (delay_until) {
+ 		cancel_delayed_work(&priv->mcast_task);
+ 		queue_delayed_work(priv->wq, &priv->mcast_task,
+ 				   delay_until - jiffies);
+ 	}
+ 	if (mcast) {
+ 		init_completion(&mcast->done);
+ 		set_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags);
+ 	}
+ 	spin_unlock_irq(&priv->lock);
+ 	mutex_unlock(&mcast_mutex);
+ 	if (mcast)
+ 		ipoib_mcast_join(dev, mcast, create);
++>>>>>>> d2fe937ce6ce (IB/ipoib: deserialize multicast joins)
  }
  
  int ipoib_mcast_start_thread(struct net_device *dev)
@@@ -667,49 -688,37 +771,67 @@@ void ipoib_mcast_send(struct net_devic
  	}
  
  	mcast = __ipoib_mcast_find(dev, mgid);
- 	if (!mcast) {
- 		/* Let's create a new send only group now */
- 		ipoib_dbg_mcast(priv, "setting up send only multicast group for %pI6\n",
- 				mgid);
- 
- 		mcast = ipoib_mcast_alloc(dev, 0);
+ 	if (!mcast || !mcast->ah) {
  		if (!mcast) {
- 			ipoib_warn(priv, "unable to allocate memory for "
- 				   "multicast structure\n");
- 			++dev->stats.tx_dropped;
- 			dev_kfree_skb_any(skb);
- 			goto out;
+ 			/* Let's create a new send only group now */
+ 			ipoib_dbg_mcast(priv, "setting up send only multicast group for %pI6\n",
+ 					mgid);
+ 
+ 			mcast = ipoib_mcast_alloc(dev, 0);
+ 			if (!mcast) {
+ 				ipoib_warn(priv, "unable to allocate memory "
+ 					   "for multicast structure\n");
+ 				++dev->stats.tx_dropped;
+ 				dev_kfree_skb_any(skb);
+ 				goto unlock;
+ 			}
+ 
+ 			set_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags);
+ 			memcpy(mcast->mcmember.mgid.raw, mgid,
+ 			       sizeof (union ib_gid));
+ 			__ipoib_mcast_add(dev, mcast);
+ 			list_add_tail(&mcast->list, &priv->multicast_list);
  		}
++<<<<<<< HEAD
 +
 +		set_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags);
 +		memcpy(mcast->mcmember.mgid.raw, mgid, sizeof (union ib_gid));
 +		__ipoib_mcast_add(dev, mcast);
 +		list_add_tail(&mcast->list, &priv->multicast_list);
 +	}
 +
 +	if (!mcast->ah) {
++=======
++>>>>>>> d2fe937ce6ce (IB/ipoib: deserialize multicast joins)
  		if (skb_queue_len(&mcast->pkt_queue) < IPOIB_MAX_MCAST_QUEUE)
  			skb_queue_tail(&mcast->pkt_queue, skb);
  		else {
  			++dev->stats.tx_dropped;
  			dev_kfree_skb_any(skb);
  		}
++<<<<<<< HEAD
 +
 +		if (test_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags))
 +			ipoib_dbg_mcast(priv, "no address vector, "
 +					"but multicast join already started\n");
 +		else if (test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags))
 +			ipoib_mcast_sendonly_join(mcast);
 +
 +		/*
 +		 * If lookup completes between here and out:, don't
 +		 * want to send packet twice.
 +		 */
 +		mcast = NULL;
 +	}
 +
 +out:
 +	if (mcast && mcast->ah) {
++=======
+ 		if (!test_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags)) {
+ 			__ipoib_mcast_schedule_join_thread(priv, NULL, 0);
+ 		}
+ 	} else {
++>>>>>>> d2fe937ce6ce (IB/ipoib: deserialize multicast joins)
  		struct ipoib_neigh *neigh;
  
  		spin_unlock_irqrestore(&priv->lock, flags);
* Unmerged path drivers/infiniband/ulp/ipoib/ipoib_multicast.c
