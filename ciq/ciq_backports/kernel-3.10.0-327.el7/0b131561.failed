net/mlx4_en: Add Flow control statistics display via ethtool

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [netdrv] mlx4_en: Add Flow control statistics display via ethtool (Amir Vadai) [1164527 1164530 1164531 1164536 1164537]
Rebuild_FUZZ: 96.55%
commit-author Matan Barak <matanb@mellanox.com>
commit 0b131561a7d639abb0a194d2d8fae839ce3b99e9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/0b131561.failed

Flow control per priority and Global pause counters are now visible via
ethtool.  The counters shows statistics regarding pauses in the device.

	Signed-off-by: Matan Barak <matanb@mellanox.com>
	Signed-off-by: Shani Michaeli <shanim@mellanox.com>
	Signed-off-by: Eran Ben Elisha <eranbe@mellanox.com>
	Signed-off-by: Hadar Hen Zion <hadarh@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0b131561a7d639abb0a194d2d8fae839ce3b99e9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
#	drivers/net/ethernet/mellanox/mlx4/en_netdev.c
#	drivers/net/ethernet/mellanox/mlx4/fw.c
#	drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
#	drivers/net/ethernet/mellanox/mlx4/mlx4_stats.h
#	include/linux/mlx4/device.h
diff --cc drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
index ecc91038e731,4fc767461b4f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
@@@ -255,30 -338,38 +297,65 @@@ static void mlx4_en_get_ethtool_stats(s
  
  	spin_lock_bh(&priv->stats_lock);
  
++<<<<<<< HEAD
 +	if (!(priv->stats_bitmap)) {
 +		for (i = 0; i < NUM_MAIN_STATS; i++)
 +			data[index++] =
 +				((unsigned long *) &priv->stats)[i];
 +		for (i = 0; i < NUM_PORT_STATS; i++)
 +			data[index++] =
 +				((unsigned long *) &priv->port_stats)[i];
 +		for (i = 0; i < NUM_PKT_STATS; i++)
 +			data[index++] =
 +				((unsigned long *) &priv->pkstats)[i];
 +	} else {
 +		for (i = 0; i < NUM_MAIN_STATS; i++) {
 +			if ((priv->stats_bitmap >> j) & 1)
 +				data[index++] =
 +				((unsigned long *) &priv->stats)[i];
 +			j++;
 +		}
 +		for (i = 0; i < NUM_PORT_STATS; i++) {
 +			if ((priv->stats_bitmap >> j) & 1)
 +				data[index++] =
 +				((unsigned long *) &priv->port_stats)[i];
 +			j++;
 +		}
 +	}
++=======
+ 	for (i = 0; i < NUM_MAIN_STATS; i++, bitmap_iterator_inc(&it))
+ 		if (bitmap_iterator_test(&it))
+ 			data[index++] = ((unsigned long *)&priv->stats)[i];
+ 
+ 	for (i = 0; i < NUM_PORT_STATS; i++, bitmap_iterator_inc(&it))
+ 		if (bitmap_iterator_test(&it))
+ 			data[index++] = ((unsigned long *)&priv->port_stats)[i];
+ 
+ 	for (i = 0; i < NUM_FLOW_PRIORITY_STATS_RX;
+ 	     i++, bitmap_iterator_inc(&it))
+ 		if (bitmap_iterator_test(&it))
+ 			data[index++] =
+ 				((u64 *)&priv->rx_priority_flowstats)[i];
+ 
+ 	for (i = 0; i < NUM_FLOW_STATS_RX; i++, bitmap_iterator_inc(&it))
+ 		if (bitmap_iterator_test(&it))
+ 			data[index++] = ((u64 *)&priv->rx_flowstats)[i];
+ 
+ 	for (i = 0; i < NUM_FLOW_PRIORITY_STATS_TX;
+ 	     i++, bitmap_iterator_inc(&it))
+ 		if (bitmap_iterator_test(&it))
+ 			data[index++] =
+ 				((u64 *)&priv->tx_priority_flowstats)[i];
+ 
+ 	for (i = 0; i < NUM_FLOW_STATS_TX; i++, bitmap_iterator_inc(&it))
+ 		if (bitmap_iterator_test(&it))
+ 			data[index++] = ((u64 *)&priv->tx_flowstats)[i];
+ 
+ 	for (i = 0; i < NUM_PKT_STATS; i++, bitmap_iterator_inc(&it))
+ 		if (bitmap_iterator_test(&it))
+ 			data[index++] = ((unsigned long *)&priv->pkstats)[i];
+ 
++>>>>>>> 0b131561a7d6 (net/mlx4_en: Add Flow control statistics display via ethtool)
  	for (i = 0; i < priv->tx_ring_num; i++) {
  		data[index++] = priv->tx_ring[i]->packets;
  		data[index++] = priv->tx_ring[i]->bytes;
@@@ -320,29 -414,30 +397,43 @@@ static void mlx4_en_get_strings(struct 
  
  	case ETH_SS_STATS:
  		/* Add main counters */
 -		for (i = 0; i < NUM_MAIN_STATS; i++, strings++,
 -		     bitmap_iterator_inc(&it))
 -			if (bitmap_iterator_test(&it))
 +		if (!priv->stats_bitmap) {
 +			for (i = 0; i < NUM_MAIN_STATS; i++)
  				strcpy(data + (index++) * ETH_GSTRING_LEN,
 -				       main_strings[strings]);
 -
 -		for (i = 0; i < NUM_PORT_STATS; i++, strings++,
 -		     bitmap_iterator_inc(&it))
 -			if (bitmap_iterator_test(&it))
 +					main_strings[i]);
 +			for (i = 0; i < NUM_PORT_STATS; i++)
  				strcpy(data + (index++) * ETH_GSTRING_LEN,
++<<<<<<< HEAD
 +					main_strings[i +
 +					NUM_MAIN_STATS]);
 +			for (i = 0; i < NUM_PKT_STATS; i++)
++=======
+ 				       main_strings[strings]);
+ 
+ 		for (i = 0; i < NUM_FLOW_STATS; i++, strings++,
+ 		     bitmap_iterator_inc(&it))
+ 			if (bitmap_iterator_test(&it))
+ 				strcpy(data + (index++) * ETH_GSTRING_LEN,
+ 				       main_strings[strings]);
+ 
+ 		for (i = 0; i < NUM_PKT_STATS; i++, strings++,
+ 		     bitmap_iterator_inc(&it))
+ 			if (bitmap_iterator_test(&it))
++>>>>>>> 0b131561a7d6 (net/mlx4_en: Add Flow control statistics display via ethtool)
  				strcpy(data + (index++) * ETH_GSTRING_LEN,
 -				       main_strings[strings]);
 -
 +					main_strings[i +
 +					NUM_MAIN_STATS +
 +					NUM_PORT_STATS]);
 +		} else
 +			for (i = 0; i < NUM_MAIN_STATS + NUM_PORT_STATS; i++) {
 +				if ((priv->stats_bitmap >> i) & 1) {
 +					strcpy(data +
 +					       (index++) * ETH_GSTRING_LEN,
 +					       main_strings[i]);
 +				}
 +				if (!(priv->stats_bitmap >> i))
 +					break;
 +			}
  		for (i = 0; i < priv->tx_ring_num; i++) {
  			sprintf(data + (index++) * ETH_GSTRING_LEN,
  				"tx%d_packets", i);
diff --cc drivers/net/ethernet/mellanox/mlx4/en_netdev.c
index 496c65027ae1,354e254b53cf..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
@@@ -2433,9 -2475,261 +2439,262 @@@ static const struct net_device_ops mlx4
  #ifdef CONFIG_MLX4_EN_VXLAN
  	.ndo_add_vxlan_port	= mlx4_en_add_vxlan_port,
  	.ndo_del_vxlan_port	= mlx4_en_del_vxlan_port,
 -	.ndo_features_check	= mlx4_en_features_check,
  #endif
 -	.ndo_set_tx_maxrate	= mlx4_en_set_tx_maxrate,
  };
  
++<<<<<<< HEAD
++=======
+ struct mlx4_en_bond {
+ 	struct work_struct work;
+ 	struct mlx4_en_priv *priv;
+ 	int is_bonded;
+ 	struct mlx4_port_map port_map;
+ };
+ 
+ static void mlx4_en_bond_work(struct work_struct *work)
+ {
+ 	struct mlx4_en_bond *bond = container_of(work,
+ 						     struct mlx4_en_bond,
+ 						     work);
+ 	int err = 0;
+ 	struct mlx4_dev *dev = bond->priv->mdev->dev;
+ 
+ 	if (bond->is_bonded) {
+ 		if (!mlx4_is_bonded(dev)) {
+ 			err = mlx4_bond(dev);
+ 			if (err)
+ 				en_err(bond->priv, "Fail to bond device\n");
+ 		}
+ 		if (!err) {
+ 			err = mlx4_port_map_set(dev, &bond->port_map);
+ 			if (err)
+ 				en_err(bond->priv, "Fail to set port map [%d][%d]: %d\n",
+ 				       bond->port_map.port1,
+ 				       bond->port_map.port2,
+ 				       err);
+ 		}
+ 	} else if (mlx4_is_bonded(dev)) {
+ 		err = mlx4_unbond(dev);
+ 		if (err)
+ 			en_err(bond->priv, "Fail to unbond device\n");
+ 	}
+ 	dev_put(bond->priv->dev);
+ 	kfree(bond);
+ }
+ 
+ static int mlx4_en_queue_bond_work(struct mlx4_en_priv *priv, int is_bonded,
+ 				   u8 v2p_p1, u8 v2p_p2)
+ {
+ 	struct mlx4_en_bond *bond = NULL;
+ 
+ 	bond = kzalloc(sizeof(*bond), GFP_ATOMIC);
+ 	if (!bond)
+ 		return -ENOMEM;
+ 
+ 	INIT_WORK(&bond->work, mlx4_en_bond_work);
+ 	bond->priv = priv;
+ 	bond->is_bonded = is_bonded;
+ 	bond->port_map.port1 = v2p_p1;
+ 	bond->port_map.port2 = v2p_p2;
+ 	dev_hold(priv->dev);
+ 	queue_work(priv->mdev->workqueue, &bond->work);
+ 	return 0;
+ }
+ 
+ int mlx4_en_netdev_event(struct notifier_block *this,
+ 			 unsigned long event, void *ptr)
+ {
+ 	struct net_device *ndev = netdev_notifier_info_to_dev(ptr);
+ 	u8 port = 0;
+ 	struct mlx4_en_dev *mdev;
+ 	struct mlx4_dev *dev;
+ 	int i, num_eth_ports = 0;
+ 	bool do_bond = true;
+ 	struct mlx4_en_priv *priv;
+ 	u8 v2p_port1 = 0;
+ 	u8 v2p_port2 = 0;
+ 
+ 	if (!net_eq(dev_net(ndev), &init_net))
+ 		return NOTIFY_DONE;
+ 
+ 	mdev = container_of(this, struct mlx4_en_dev, nb);
+ 	dev = mdev->dev;
+ 
+ 	/* Go into this mode only when two network devices set on two ports
+ 	 * of the same mlx4 device are slaves of the same bonding master
+ 	 */
+ 	mlx4_foreach_port(i, dev, MLX4_PORT_TYPE_ETH) {
+ 		++num_eth_ports;
+ 		if (!port && (mdev->pndev[i] == ndev))
+ 			port = i;
+ 		mdev->upper[i] = mdev->pndev[i] ?
+ 			netdev_master_upper_dev_get(mdev->pndev[i]) : NULL;
+ 		/* condition not met: network device is a slave */
+ 		if (!mdev->upper[i])
+ 			do_bond = false;
+ 		if (num_eth_ports < 2)
+ 			continue;
+ 		/* condition not met: same master */
+ 		if (mdev->upper[i] != mdev->upper[i-1])
+ 			do_bond = false;
+ 	}
+ 	/* condition not met: 2 salves */
+ 	do_bond = (num_eth_ports ==  2) ? do_bond : false;
+ 
+ 	/* handle only events that come with enough info */
+ 	if ((do_bond && (event != NETDEV_BONDING_INFO)) || !port)
+ 		return NOTIFY_DONE;
+ 
+ 	priv = netdev_priv(ndev);
+ 	if (do_bond) {
+ 		struct netdev_notifier_bonding_info *notifier_info = ptr;
+ 		struct netdev_bonding_info *bonding_info =
+ 			&notifier_info->bonding_info;
+ 
+ 		/* required mode 1, 2 or 4 */
+ 		if ((bonding_info->master.bond_mode != BOND_MODE_ACTIVEBACKUP) &&
+ 		    (bonding_info->master.bond_mode != BOND_MODE_XOR) &&
+ 		    (bonding_info->master.bond_mode != BOND_MODE_8023AD))
+ 			do_bond = false;
+ 
+ 		/* require exactly 2 slaves */
+ 		if (bonding_info->master.num_slaves != 2)
+ 			do_bond = false;
+ 
+ 		/* calc v2p */
+ 		if (do_bond) {
+ 			if (bonding_info->master.bond_mode ==
+ 			    BOND_MODE_ACTIVEBACKUP) {
+ 				/* in active-backup mode virtual ports are
+ 				 * mapped to the physical port of the active
+ 				 * slave */
+ 				if (bonding_info->slave.state ==
+ 				    BOND_STATE_BACKUP) {
+ 					if (port == 1) {
+ 						v2p_port1 = 2;
+ 						v2p_port2 = 2;
+ 					} else {
+ 						v2p_port1 = 1;
+ 						v2p_port2 = 1;
+ 					}
+ 				} else { /* BOND_STATE_ACTIVE */
+ 					if (port == 1) {
+ 						v2p_port1 = 1;
+ 						v2p_port2 = 1;
+ 					} else {
+ 						v2p_port1 = 2;
+ 						v2p_port2 = 2;
+ 					}
+ 				}
+ 			} else { /* Active-Active */
+ 				/* in active-active mode a virtual port is
+ 				 * mapped to the native physical port if and only
+ 				 * if the physical port is up */
+ 				__s8 link = bonding_info->slave.link;
+ 
+ 				if (port == 1)
+ 					v2p_port2 = 2;
+ 				else
+ 					v2p_port1 = 1;
+ 				if ((link == BOND_LINK_UP) ||
+ 				    (link == BOND_LINK_FAIL)) {
+ 					if (port == 1)
+ 						v2p_port1 = 1;
+ 					else
+ 						v2p_port2 = 2;
+ 				} else { /* BOND_LINK_DOWN || BOND_LINK_BACK */
+ 					if (port == 1)
+ 						v2p_port1 = 2;
+ 					else
+ 						v2p_port2 = 1;
+ 				}
+ 			}
+ 		}
+ 	}
+ 
+ 	mlx4_en_queue_bond_work(priv, do_bond,
+ 				v2p_port1, v2p_port2);
+ 
+ 	return NOTIFY_DONE;
+ }
+ 
+ void mlx4_en_update_pfc_stats_bitmap(struct mlx4_dev *dev,
+ 				     struct mlx4_en_stats_bitmap *stats_bitmap,
+ 				     u8 rx_ppp, u8 rx_pause,
+ 				     u8 tx_ppp, u8 tx_pause)
+ {
+ 	int last_i = NUM_MAIN_STATS + NUM_PORT_STATS;
+ 
+ 	if (!mlx4_is_slave(dev) &&
+ 	    (dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_FLOWSTATS_EN)) {
+ 		mutex_lock(&stats_bitmap->mutex);
+ 		bitmap_clear(stats_bitmap->bitmap, last_i, NUM_FLOW_STATS);
+ 
+ 		if (rx_ppp)
+ 			bitmap_set(stats_bitmap->bitmap, last_i,
+ 				   NUM_FLOW_PRIORITY_STATS_RX);
+ 		last_i += NUM_FLOW_PRIORITY_STATS_RX;
+ 
+ 		if (rx_pause && !(rx_ppp))
+ 			bitmap_set(stats_bitmap->bitmap, last_i,
+ 				   NUM_FLOW_STATS_RX);
+ 		last_i += NUM_FLOW_STATS_RX;
+ 
+ 		if (tx_ppp)
+ 			bitmap_set(stats_bitmap->bitmap, last_i,
+ 				   NUM_FLOW_PRIORITY_STATS_TX);
+ 		last_i += NUM_FLOW_PRIORITY_STATS_TX;
+ 
+ 		if (tx_pause && !(tx_ppp))
+ 			bitmap_set(stats_bitmap->bitmap, last_i,
+ 				   NUM_FLOW_STATS_TX);
+ 		last_i += NUM_FLOW_STATS_TX;
+ 
+ 		mutex_unlock(&stats_bitmap->mutex);
+ 	}
+ }
+ 
+ void mlx4_en_set_stats_bitmap(struct mlx4_dev *dev,
+ 			      struct mlx4_en_stats_bitmap *stats_bitmap,
+ 			      u8 rx_ppp, u8 rx_pause,
+ 			      u8 tx_ppp, u8 tx_pause)
+ {
+ 	int last_i = 0;
+ 
+ 	mutex_init(&stats_bitmap->mutex);
+ 	bitmap_zero(stats_bitmap->bitmap, NUM_ALL_STATS);
+ 
+ 	if (mlx4_is_slave(dev)) {
+ 		bitmap_set(stats_bitmap->bitmap, last_i +
+ 					 MLX4_FIND_NETDEV_STAT(rx_packets), 1);
+ 		bitmap_set(stats_bitmap->bitmap, last_i +
+ 					 MLX4_FIND_NETDEV_STAT(tx_packets), 1);
+ 		bitmap_set(stats_bitmap->bitmap, last_i +
+ 					 MLX4_FIND_NETDEV_STAT(rx_bytes), 1);
+ 		bitmap_set(stats_bitmap->bitmap, last_i +
+ 					 MLX4_FIND_NETDEV_STAT(tx_bytes), 1);
+ 		bitmap_set(stats_bitmap->bitmap, last_i +
+ 					 MLX4_FIND_NETDEV_STAT(rx_dropped), 1);
+ 		bitmap_set(stats_bitmap->bitmap, last_i +
+ 					 MLX4_FIND_NETDEV_STAT(tx_dropped), 1);
+ 	} else {
+ 		bitmap_set(stats_bitmap->bitmap, last_i, NUM_MAIN_STATS);
+ 	}
+ 	last_i += NUM_MAIN_STATS;
+ 
+ 	bitmap_set(stats_bitmap->bitmap, last_i, NUM_PORT_STATS);
+ 	last_i += NUM_PORT_STATS;
+ 
+ 	mlx4_en_update_pfc_stats_bitmap(dev, stats_bitmap,
+ 					rx_ppp, rx_pause,
+ 					tx_ppp, tx_pause);
+ 	last_i += NUM_FLOW_STATS;
+ 
+ 	if (!mlx4_is_slave(dev))
+ 		bitmap_set(stats_bitmap->bitmap, last_i, NUM_PKT_STATS);
+ }
+ 
++>>>>>>> 0b131561a7d6 (net/mlx4_en: Add Flow control statistics display via ethtool)
  int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,
  			struct mlx4_en_port_profile *prof)
  {
@@@ -2648,15 -2963,11 +2907,23 @@@
  		queue_delayed_work(mdev->workqueue, &priv->service_task,
  				   SERVICE_TASK_DELAY);
  
++<<<<<<< HEAD
 +	mlx4_set_stats_bitmap(mdev->dev, &priv->stats_bitmap);
 +
 +	err = register_netdev(dev);
 +	if (err) {
 +		en_err(priv, "Netdev registration failed for port %d\n", port);
 +		goto out;
 +	}
 +
 +	priv->registered = 1;
++=======
+ 	mlx4_en_set_stats_bitmap(mdev->dev, &priv->stats_bitmap,
+ 				 mdev->profile.prof[priv->port].rx_ppp,
+ 				 mdev->profile.prof[priv->port].rx_pause,
+ 				 mdev->profile.prof[priv->port].tx_ppp,
+ 				 mdev->profile.prof[priv->port].tx_pause);
++>>>>>>> 0b131561a7d6 (net/mlx4_en: Add Flow control statistics display via ethtool)
  
  	return 0;
  
diff --cc drivers/net/ethernet/mellanox/mlx4/fw.c
index dadc053d0183,209a6171e59b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/fw.c
+++ b/drivers/net/ethernet/mellanox/mlx4/fw.c
@@@ -138,7 -138,15 +138,19 @@@ static void dump_dev_cap_flags2(struct 
  		[13] = "Large cache line (>64B) EQE stride support",
  		[14] = "Ethernet protocol control support",
  		[15] = "Ethernet Backplane autoneg support",
++<<<<<<< HEAD
 +		[16] = "CONFIG DEV support"
++=======
+ 		[16] = "CONFIG DEV support",
+ 		[17] = "Asymmetric EQs support",
+ 		[18] = "More than 80 VFs support",
+ 		[19] = "Performance optimized for limited rule configuration flow steering support",
+ 		[20] = "Recoverable error events support",
+ 		[21] = "Port Remap support",
+ 		[22] = "QCN support",
+ 		[23] = "QP rate limiting support",
+ 		[24] = "Ethernet Flow control statistics support"
++>>>>>>> 0b131561a7d6 (net/mlx4_en: Add Flow control statistics display via ethtool)
  	};
  	int i;
  
@@@ -1092,9 -1183,18 +1109,9 @@@ int mlx4_QUERY_DEV_CAP_wrapper(struct m
  	/* turn off host side virt features (VST, FSM, etc) for guests */
  	MLX4_GET(field32, outbox->buf, QUERY_DEV_CAP_EXT_2_FLAGS_OFFSET);
  	field32 &= ~(DEV_CAP_EXT_2_FLAG_VLAN_CONTROL | DEV_CAP_EXT_2_FLAG_80_VFS |
- 		     DEV_CAP_EXT_2_FLAG_FSM);
+ 		     DEV_CAP_EXT_2_FLAG_FSM | DEV_CAP_EXT_2_FLAG_PFC_COUNTERS);
  	MLX4_PUT(outbox->buf, field32, QUERY_DEV_CAP_EXT_2_FLAGS_OFFSET);
  
 -	/* turn off QCN for guests */
 -	MLX4_GET(field, outbox->buf, QUERY_DEV_CAP_ECN_QCN_VER_OFFSET);
 -	field &= 0xfe;
 -	MLX4_PUT(outbox->buf, field, QUERY_DEV_CAP_ECN_QCN_VER_OFFSET);
 -
 -	/* turn off QP max-rate limiting for guests */
 -	field16 = 0;
 -	MLX4_PUT(outbox->buf, field16, QUERY_DEV_CAP_QP_RATE_LIMIT_NUM_OFFSET);
 -
  	return 0;
  }
  
diff --cc drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
index 29a881cbb841,67eeea244eff..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
+++ b/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
@@@ -560,8 -565,12 +560,12 @@@ struct mlx4_en_priv 
  #endif
  	struct mlx4_en_perf_stats pstats;
  	struct mlx4_en_pkt_stats pkstats;
+ 	struct mlx4_en_flow_stats_rx rx_priority_flowstats[MLX4_NUM_PRIORITIES];
+ 	struct mlx4_en_flow_stats_tx tx_priority_flowstats[MLX4_NUM_PRIORITIES];
+ 	struct mlx4_en_flow_stats_rx rx_flowstats;
+ 	struct mlx4_en_flow_stats_tx tx_flowstats;
  	struct mlx4_en_port_stats port_stats;
 -	struct mlx4_en_stats_bitmap stats_bitmap;
 +	u64 stats_bitmap;
  	struct list_head mc_list;
  	struct list_head curr_list;
  	u64 broadcast_id;
@@@ -727,6 -739,11 +731,14 @@@ int mlx4_en_init_netdev(struct mlx4_en_
  int mlx4_en_start_port(struct net_device *dev);
  void mlx4_en_stop_port(struct net_device *dev, int detach);
  
++<<<<<<< HEAD
++=======
+ void mlx4_en_set_stats_bitmap(struct mlx4_dev *dev,
+ 			      struct mlx4_en_stats_bitmap *stats_bitmap,
+ 			      u8 rx_ppp, u8 rx_pause,
+ 			      u8 tx_ppp, u8 tx_pause);
+ 
++>>>>>>> 0b131561a7d6 (net/mlx4_en: Add Flow control statistics display via ethtool)
  void mlx4_en_free_resources(struct mlx4_en_priv *priv);
  int mlx4_en_alloc_resources(struct mlx4_en_priv *priv);
  
@@@ -811,6 -829,12 +823,15 @@@ void mlx4_en_ptp_overflow_check(struct 
  int mlx4_en_reset_config(struct net_device *dev,
  			 struct hwtstamp_config ts_config,
  			 netdev_features_t new_features);
++<<<<<<< HEAD
++=======
+ void mlx4_en_update_pfc_stats_bitmap(struct mlx4_dev *dev,
+ 				     struct mlx4_en_stats_bitmap *stats_bitmap,
+ 				     u8 rx_ppp, u8 rx_pause,
+ 				     u8 tx_ppp, u8 tx_pause);
+ int mlx4_en_netdev_event(struct notifier_block *this,
+ 			 unsigned long event, void *ptr);
++>>>>>>> 0b131561a7d6 (net/mlx4_en: Add Flow control statistics display via ethtool)
  
  /*
   * Functions for time stamping
diff --cc drivers/net/ethernet/mellanox/mlx4/mlx4_stats.h
index abea7a527abf,e193680fb527..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/mlx4_stats.h
+++ b/drivers/net/ethernet/mellanox/mlx4/mlx4_stats.h
@@@ -42,6 -42,60 +42,64 @@@ struct mlx4_en_perf_stats 
  };
  
  #define NUM_MAIN_STATS	21
+ 
+ #define MLX4_NUM_PRIORITIES	8
+ 
+ struct mlx4_en_flow_stats_rx {
+ 	u64 rx_pause;
+ 	u64 rx_pause_duration;
+ 	u64 rx_pause_transition;
+ #define NUM_FLOW_STATS_RX	3
+ #define NUM_FLOW_PRIORITY_STATS_RX	(NUM_FLOW_STATS_RX * \
+ 					 MLX4_NUM_PRIORITIES)
+ };
+ 
+ struct mlx4_en_flow_stats_tx {
+ 	u64 tx_pause;
+ 	u64 tx_pause_duration;
+ 	u64 tx_pause_transition;
+ #define NUM_FLOW_STATS_TX	3
+ #define NUM_FLOW_PRIORITY_STATS_TX	(NUM_FLOW_STATS_TX * \
+ 					 MLX4_NUM_PRIORITIES)
+ };
+ 
+ #define NUM_FLOW_STATS (NUM_FLOW_STATS_RX + NUM_FLOW_STATS_TX + \
+ 			NUM_FLOW_PRIORITY_STATS_TX + \
+ 			NUM_FLOW_PRIORITY_STATS_RX)
+ 
+ struct mlx4_en_stat_out_flow_control_mbox {
+ 	/* Total number of PAUSE frames received from the far-end port */
+ 	__be64 rx_pause;
+ 	/* Total number of microseconds that far-end port requested to pause
+ 	* transmission of packets
+ 	*/
+ 	__be64 rx_pause_duration;
+ 	/* Number of received transmission from XOFF state to XON state */
+ 	__be64 rx_pause_transition;
+ 	/* Total number of PAUSE frames sent from the far-end port */
+ 	__be64 tx_pause;
+ 	/* Total time in microseconds that transmission of packets has been
+ 	* paused
+ 	*/
+ 	__be64 tx_pause_duration;
+ 	/* Number of transmitter transitions from XOFF state to XON state */
+ 	__be64 tx_pause_transition;
+ 	/* Reserverd */
+ 	__be64 reserved[2];
+ };
+ 
+ enum {
+ 	MLX4_DUMP_ETH_STATS_FLOW_CONTROL = 1 << 12
+ };
+ 
  #define NUM_ALL_STATS	(NUM_MAIN_STATS + NUM_PORT_STATS + NUM_PKT_STATS + \
++<<<<<<< HEAD
 +			 NUM_PERF_STATS)
++=======
+ 			 NUM_FLOW_STATS + NUM_PERF_STATS)
+ 
+ #define MLX4_FIND_NETDEV_STAT(n) (offsetof(struct net_device_stats, n) / \
+ 				  sizeof(((struct net_device_stats *)0)->n))
+ 
++>>>>>>> 0b131561a7d6 (net/mlx4_en: Add Flow control statistics display via ethtool)
  #endif
diff --cc include/linux/mlx4/device.h
index d69c0aafc158,ab7ebec943b8..000000000000
--- a/include/linux/mlx4/device.h
+++ b/include/linux/mlx4/device.h
@@@ -190,7 -198,15 +190,19 @@@ enum 
  	MLX4_DEV_CAP_FLAG2_EQE_STRIDE		= 1LL <<  13,
  	MLX4_DEV_CAP_FLAG2_ETH_PROT_CTRL        = 1LL <<  14,
  	MLX4_DEV_CAP_FLAG2_ETH_BACKPL_AN_REP	= 1LL <<  15,
++<<<<<<< HEAD
 +	MLX4_DEV_CAP_FLAG2_CONFIG_DEV		= 1LL <<  16
++=======
+ 	MLX4_DEV_CAP_FLAG2_CONFIG_DEV		= 1LL <<  16,
+ 	MLX4_DEV_CAP_FLAG2_SYS_EQS		= 1LL <<  17,
+ 	MLX4_DEV_CAP_FLAG2_80_VFS		= 1LL <<  18,
+ 	MLX4_DEV_CAP_FLAG2_FS_A0		= 1LL <<  19,
+ 	MLX4_DEV_CAP_FLAG2_RECOVERABLE_ERROR_EVENT = 1LL << 20,
+ 	MLX4_DEV_CAP_FLAG2_PORT_REMAP		= 1LL <<  21,
+ 	MLX4_DEV_CAP_FLAG2_QCN			= 1LL <<  22,
+ 	MLX4_DEV_CAP_FLAG2_QP_RATE_LIMIT	= 1LL <<  23,
+ 	MLX4_DEV_CAP_FLAG2_FLOWSTATS_EN         = 1LL <<  24
++>>>>>>> 0b131561a7d6 (net/mlx4_en: Add Flow control statistics display via ethtool)
  };
  
  enum {
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_dcb_nl.c b/drivers/net/ethernet/mellanox/mlx4/en_dcb_nl.c
index c95ca252187c..b4fd4023a454 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_dcb_nl.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_dcb_nl.c
@@ -183,6 +183,10 @@ static int mlx4_en_dcbnl_ieee_setpfc(struct net_device *dev,
 				    prof->rx_ppp);
 	if (err)
 		en_err(priv, "Failed setting pause params\n");
+	else
+		mlx4_en_update_pfc_stats_bitmap(mdev->dev, &priv->stats_bitmap,
+						prof->rx_ppp, prof->rx_pause,
+						prof->tx_ppp, prof->tx_pause);
 
 	return err;
 }
* Unmerged path drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
* Unmerged path drivers/net/ethernet/mellanox/mlx4/en_netdev.c
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_port.c b/drivers/net/ethernet/mellanox/mlx4/en_port.c
index 6cb80072af6c..821ae1278dc9 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_port.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_port.c
@@ -131,6 +131,7 @@ out:
 int mlx4_en_DUMP_ETH_STATS(struct mlx4_en_dev *mdev, u8 port, u8 reset)
 {
 	struct mlx4_en_stat_out_mbox *mlx4_en_stats;
+	struct mlx4_en_stat_out_flow_control_mbox *flowstats;
 	struct mlx4_en_priv *priv = netdev_priv(mdev->pndev[port]);
 	struct net_device_stats *stats = &priv->stats;
 	struct mlx4_cmd_mailbox *mailbox;
@@ -239,6 +240,55 @@ int mlx4_en_DUMP_ETH_STATS(struct mlx4_en_dev *mdev, u8 port, u8 reset)
 	priv->pkstats.tx_prio[7] = be64_to_cpu(mlx4_en_stats->TTOT_prio_7);
 	spin_unlock_bh(&priv->stats_lock);
 
+	/* 0xffs indicates invalid value */
+	memset(mailbox->buf, 0xff, sizeof(*flowstats) * MLX4_NUM_PRIORITIES);
+
+	if (mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_FLOWSTATS_EN) {
+		memset(mailbox->buf, 0,
+		       sizeof(*flowstats) * MLX4_NUM_PRIORITIES);
+		err = mlx4_cmd_box(mdev->dev, 0, mailbox->dma,
+				   in_mod | MLX4_DUMP_ETH_STATS_FLOW_CONTROL,
+				   0, MLX4_CMD_DUMP_ETH_STATS,
+				   MLX4_CMD_TIME_CLASS_B, MLX4_CMD_WRAPPED);
+		if (err)
+			goto out;
+	}
+
+	flowstats = mailbox->buf;
+
+	spin_lock_bh(&priv->stats_lock);
+
+	for (i = 0; i < MLX4_NUM_PRIORITIES; i++)	{
+		priv->rx_priority_flowstats[i].rx_pause =
+			be64_to_cpu(flowstats[i].rx_pause);
+		priv->rx_priority_flowstats[i].rx_pause_duration =
+			be64_to_cpu(flowstats[i].rx_pause_duration);
+		priv->rx_priority_flowstats[i].rx_pause_transition =
+			be64_to_cpu(flowstats[i].rx_pause_transition);
+		priv->tx_priority_flowstats[i].tx_pause =
+			be64_to_cpu(flowstats[i].tx_pause);
+		priv->tx_priority_flowstats[i].tx_pause_duration =
+			be64_to_cpu(flowstats[i].tx_pause_duration);
+		priv->tx_priority_flowstats[i].tx_pause_transition =
+			be64_to_cpu(flowstats[i].tx_pause_transition);
+	}
+
+	/* if pfc is not in use, all priorities counters have the same value */
+	priv->rx_flowstats.rx_pause =
+		be64_to_cpu(flowstats[0].rx_pause);
+	priv->rx_flowstats.rx_pause_duration =
+		be64_to_cpu(flowstats[0].rx_pause_duration);
+	priv->rx_flowstats.rx_pause_transition =
+		be64_to_cpu(flowstats[0].rx_pause_transition);
+	priv->tx_flowstats.tx_pause =
+		be64_to_cpu(flowstats[0].tx_pause);
+	priv->tx_flowstats.tx_pause_duration =
+		be64_to_cpu(flowstats[0].tx_pause_duration);
+	priv->tx_flowstats.tx_pause_transition =
+		be64_to_cpu(flowstats[0].tx_pause_transition);
+
+	spin_unlock_bh(&priv->stats_lock);
+
 out:
 	mlx4_free_cmd_mailbox(mdev->dev, mailbox);
 	return err;
* Unmerged path drivers/net/ethernet/mellanox/mlx4/fw.c
* Unmerged path drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
* Unmerged path drivers/net/ethernet/mellanox/mlx4/mlx4_stats.h
* Unmerged path include/linux/mlx4/device.h
