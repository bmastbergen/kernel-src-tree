xfs: convert directory db conversion to xfs_da_geometry

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit 30028030b14d083123c88e3ab45990a8c375abf1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/30028030.failed

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>


(cherry picked from commit 30028030b14d083123c88e3ab45990a8c375abf1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_dir2_leaf.c
#	fs/xfs/xfs_dir2_priv.h
#	fs/xfs/xfs_dir2_readdir.c
diff --cc fs/xfs/xfs_dir2_leaf.c
index 4d5097750d39,2b3ddd061d0e..000000000000
--- a/fs/xfs/xfs_dir2_leaf.c
+++ b/fs/xfs/xfs_dir2_leaf.c
@@@ -347,11 -347,11 +347,11 @@@ xfs_dir3_leaf_get_buf
  	int			error;
  
  	ASSERT(magic == XFS_DIR2_LEAF1_MAGIC || magic == XFS_DIR2_LEAFN_MAGIC);
- 	ASSERT(bno >= xfs_dir2_byte_to_db(mp, XFS_DIR2_LEAF_OFFSET) &&
- 	       bno < xfs_dir2_byte_to_db(mp, XFS_DIR2_FREE_OFFSET));
+ 	ASSERT(bno >= xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET) &&
+ 	       bno < xfs_dir2_byte_to_db(args->geo, XFS_DIR2_FREE_OFFSET));
  
 -	error = xfs_da_get_buf(tp, dp, xfs_dir2_db_to_da(args->geo, bno),
 -			       -1, &bp, XFS_DATA_FORK);
 +	error = xfs_da_get_buf(tp, dp, xfs_dir2_db_to_da(mp, bno), -1, &bp,
 +			       XFS_DATA_FORK);
  	if (error)
  		return error;
  
@@@ -403,8 -403,8 +403,13 @@@ xfs_dir2_block_to_leaf
  	if ((error = xfs_da_grow_inode(args, &blkno))) {
  		return error;
  	}
++<<<<<<< HEAD
 +	ldb = xfs_dir2_da_to_db(mp, blkno);
 +	ASSERT(ldb == xfs_dir2_byte_to_db(mp, XFS_DIR2_LEAF_OFFSET));
++=======
+ 	ldb = xfs_dir2_da_to_db(args->geo, blkno);
+ 	ASSERT(ldb == xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET));
++>>>>>>> 30028030b14d (xfs: convert directory db conversion to xfs_da_geometry)
  	/*
  	 * Initialize the leaf block, get a buffer for it.
  	 */
diff --cc fs/xfs/xfs_dir2_priv.h
index f3dfbc996c43,071b685abcbb..000000000000
--- a/fs/xfs/xfs_dir2_priv.h
+++ b/fs/xfs/xfs_dir2_priv.h
@@@ -20,6 -20,140 +20,143 @@@
  
  struct dir_context;
  
++<<<<<<< HEAD
++=======
+ /*
+  * Directory offset/block conversion functions.
+  *
+  * DB blocks here are logical directory block numbers, not filesystem blocks.
+  */
+ 
+ /*
+  * Convert dataptr to byte in file space
+  */
+ static inline xfs_dir2_off_t
+ xfs_dir2_dataptr_to_byte(xfs_dir2_dataptr_t dp)
+ {
+ 	return (xfs_dir2_off_t)dp << XFS_DIR2_DATA_ALIGN_LOG;
+ }
+ 
+ /*
+  * Convert byte in file space to dataptr.  It had better be aligned.
+  */
+ static inline xfs_dir2_dataptr_t
+ xfs_dir2_byte_to_dataptr(xfs_dir2_off_t by)
+ {
+ 	return (xfs_dir2_dataptr_t)(by >> XFS_DIR2_DATA_ALIGN_LOG);
+ }
+ 
+ /*
+  * Convert byte in space to (DB) block
+  */
+ static inline xfs_dir2_db_t
+ xfs_dir2_byte_to_db(struct xfs_da_geometry *geo, xfs_dir2_off_t by)
+ {
+ 	return (xfs_dir2_db_t)(by >> geo->blklog);
+ }
+ 
+ /*
+  * Convert dataptr to a block number
+  */
+ static inline xfs_dir2_db_t
+ xfs_dir2_dataptr_to_db(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)
+ {
+ 	return xfs_dir2_byte_to_db(geo, xfs_dir2_dataptr_to_byte(dp));
+ }
+ 
+ /*
+  * Convert byte in space to offset in a block
+  */
+ static inline xfs_dir2_data_aoff_t
+ xfs_dir2_byte_to_off(struct xfs_da_geometry *geo, xfs_dir2_off_t by)
+ {
+ 	return (xfs_dir2_data_aoff_t)(by & (geo->blksize - 1));
+ }
+ 
+ /*
+  * Convert dataptr to a byte offset in a block
+  */
+ static inline xfs_dir2_data_aoff_t
+ xfs_dir2_dataptr_to_off(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)
+ {
+ 	return xfs_dir2_byte_to_off(geo, xfs_dir2_dataptr_to_byte(dp));
+ }
+ 
+ /*
+  * Convert block and offset to byte in space
+  */
+ static inline xfs_dir2_off_t
+ xfs_dir2_db_off_to_byte(struct xfs_da_geometry *geo, xfs_dir2_db_t db,
+ 			xfs_dir2_data_aoff_t o)
+ {
+ 	return ((xfs_dir2_off_t)db << geo->blklog) + o;
+ }
+ 
+ /*
+  * Convert block (DB) to block (dablk)
+  */
+ static inline xfs_dablk_t
+ xfs_dir2_db_to_da(struct xfs_da_geometry *geo, xfs_dir2_db_t db)
+ {
+ 	return (xfs_dablk_t)(db << (geo->blklog - geo->fsblog));
+ }
+ 
+ /*
+  * Convert byte in space to (DA) block
+  */
+ static inline xfs_dablk_t
+ xfs_dir2_byte_to_da(struct xfs_da_geometry *geo, xfs_dir2_off_t by)
+ {
+ 	return xfs_dir2_db_to_da(geo, xfs_dir2_byte_to_db(geo, by));
+ }
+ 
+ /*
+  * Convert block and offset to dataptr
+  */
+ static inline xfs_dir2_dataptr_t
+ xfs_dir2_db_off_to_dataptr(struct xfs_da_geometry *geo, xfs_dir2_db_t db,
+ 			   xfs_dir2_data_aoff_t o)
+ {
+ 	return xfs_dir2_byte_to_dataptr(xfs_dir2_db_off_to_byte(geo, db, o));
+ }
+ 
+ /*
+  * Convert block (dablk) to block (DB)
+  */
+ static inline xfs_dir2_db_t
+ xfs_dir2_da_to_db(struct xfs_da_geometry *geo, xfs_dablk_t da)
+ {
+ 	return (xfs_dir2_db_t)(da >> (geo->blklog - geo->fsblog));
+ }
+ 
+ /*
+  * Convert block (dablk) to byte offset in space
+  */
+ static inline xfs_dir2_off_t
+ xfs_dir2_da_to_byte(struct xfs_da_geometry *geo, xfs_dablk_t da)
+ {
+ 	return xfs_dir2_db_off_to_byte(geo, xfs_dir2_da_to_db(geo, da), 0);
+ }
+ 
+ /*
+  * Directory tail pointer accessor functions. Based on block geometry.
+  */
+ static inline struct xfs_dir2_block_tail *
+ xfs_dir2_block_tail_p(struct xfs_mount *mp, struct xfs_dir2_data_hdr *hdr)
+ {
+ 	return ((struct xfs_dir2_block_tail *)
+ 		((char *)hdr + mp->m_dirblksize)) - 1;
+ }
+ 
+ static inline struct xfs_dir2_leaf_tail *
+ xfs_dir2_leaf_tail_p(struct xfs_mount *mp, struct xfs_dir2_leaf *lp)
+ {
+ 	return (struct xfs_dir2_leaf_tail *)
+ 		((char *)lp + mp->m_dirblksize -
+ 		  sizeof(struct xfs_dir2_leaf_tail));
+ }
+ 
++>>>>>>> 30028030b14d (xfs: convert directory db conversion to xfs_da_geometry)
  /* xfs_dir2.c */
  extern int xfs_dir_ino_validate(struct xfs_mount *mp, xfs_ino_t ino);
  extern int xfs_dir2_grow_inode(struct xfs_da_args *args, int space,
diff --cc fs/xfs/xfs_dir2_readdir.c
index d6645e8c5ecc,c2a63878d27c..000000000000
--- a/fs/xfs/xfs_dir2_readdir.c
+++ b/fs/xfs/xfs_dir2_readdir.c
@@@ -111,7 -111,7 +113,11 @@@ xfs_dir2_sf_getdents
  	/*
  	 * If the block number in the offset is out of range, we're done.
  	 */
++<<<<<<< HEAD
 +	if (xfs_dir2_dataptr_to_db(mp, *offset) > mp->m_dirdatablk)
++=======
+ 	if (xfs_dir2_dataptr_to_db(geo, ctx->pos) > mp->m_dirdatablk)
++>>>>>>> 30028030b14d (xfs: convert directory db conversion to xfs_da_geometry)
  		return 0;
  
  	/*
@@@ -153,10 -151,10 +159,10 @@@
  	for (i = 0; i < sfp->count; i++) {
  		__uint8_t filetype;
  
- 		off = xfs_dir2_db_off_to_dataptr(mp, mp->m_dirdatablk,
+ 		off = xfs_dir2_db_off_to_dataptr(geo, mp->m_dirdatablk,
  				xfs_dir2_sf_get_offset(sfep));
  
 -		if (ctx->pos > off) {
 +		if (*offset > off) {
  			sfep = dp->d_ops->sf_nextentry(sfp, sfep);
  			continue;
  		}
@@@ -172,7 -168,7 +178,11 @@@
  		sfep = dp->d_ops->sf_nextentry(sfp, sfep);
  	}
  
++<<<<<<< HEAD
 +	*offset = xfs_dir2_db_off_to_dataptr(mp, mp->m_dirdatablk + 1, 0) &
++=======
+ 	ctx->pos = xfs_dir2_db_off_to_dataptr(geo, mp->m_dirdatablk + 1, 0) &
++>>>>>>> 30028030b14d (xfs: convert directory db conversion to xfs_da_geometry)
  			0x7fffffff;
  	return 0;
  }
@@@ -203,7 -199,7 +215,11 @@@ xfs_dir2_block_getdents
  	/*
  	 * If the block number in the offset is out of range, we're done.
  	 */
++<<<<<<< HEAD
 +	if (xfs_dir2_dataptr_to_db(mp, *offset) > mp->m_dirdatablk)
++=======
+ 	if (xfs_dir2_dataptr_to_db(geo, ctx->pos) > mp->m_dirdatablk)
++>>>>>>> 30028030b14d (xfs: convert directory db conversion to xfs_da_geometry)
  		return 0;
  
  	error = xfs_dir3_block_read(NULL, dp, &bp);
@@@ -214,7 -210,7 +230,11 @@@
  	 * Extract the byte offset we start at from the seek pointer.
  	 * We'll skip entries before this.
  	 */
++<<<<<<< HEAD
 +	wantoff = xfs_dir2_dataptr_to_off(mp, *offset);
++=======
+ 	wantoff = xfs_dir2_dataptr_to_off(geo, ctx->pos);
++>>>>>>> 30028030b14d (xfs: convert directory db conversion to xfs_da_geometry)
  	hdr = bp->b_addr;
  	xfs_dir3_data_check(dp, bp);
  	/*
@@@ -252,10 -248,11 +272,10 @@@
  		if ((char *)dep - (char *)hdr < wantoff)
  			continue;
  
- 		cook = xfs_dir2_db_off_to_dataptr(mp, mp->m_dirdatablk,
+ 		cook = xfs_dir2_db_off_to_dataptr(geo, mp->m_dirdatablk,
  					    (char *)dep - (char *)hdr);
 -
 -		ctx->pos = cook & 0x7fffffff;
  		filetype = dp->d_ops->data_get_ftype(dep);
 +
  		/*
  		 * If it didn't fit, set the final offset to here & return.
  		 */
@@@ -272,7 -268,7 +292,11 @@@
  	 * Reached the end of the block.
  	 * Set the offset to a non-existent block 1 and return.
  	 */
++<<<<<<< HEAD
 +	*offset = xfs_dir2_db_off_to_dataptr(mp, mp->m_dirdatablk + 1, 0) &
++=======
+ 	ctx->pos = xfs_dir2_db_off_to_dataptr(geo, mp->m_dirdatablk + 1, 0) &
++>>>>>>> 30028030b14d (xfs: convert directory db conversion to xfs_da_geometry)
  			0x7fffffff;
  	xfs_trans_brelse(NULL, bp);
  	return 0;
@@@ -404,14 -401,14 +429,22 @@@ xfs_dir2_leaf_readbuf
  	 * No valid mappings, so no more data blocks.
  	 */
  	if (!mip->map_valid) {
++<<<<<<< HEAD
 +		*curoff = xfs_dir2_da_to_byte(mp, mip->map_off);
++=======
+ 		*curoff = xfs_dir2_da_to_byte(geo, mip->map_off);
++>>>>>>> 30028030b14d (xfs: convert directory db conversion to xfs_da_geometry)
  		goto out;
  	}
  
  	/*
  	 * Read the directory block starting at the first mapping.
  	 */
++<<<<<<< HEAD
 +	mip->curdb = xfs_dir2_da_to_db(mp, map->br_startoff);
++=======
+ 	mip->curdb = xfs_dir2_da_to_db(geo, map->br_startoff);
++>>>>>>> 30028030b14d (xfs: convert directory db conversion to xfs_da_geometry)
  	error = xfs_dir3_data_read(NULL, dp, map->br_startoff,
  			map->br_blockcount >= mp->m_dirblkfsbs ?
  			    XFS_FSB_TO_DADDR(mp, map->br_startblock) : -1, &bp);
@@@ -546,8 -543,8 +581,13 @@@ xfs_dir2_leaf_getdents
  	 * Force this conversion through db so we truncate the offset
  	 * down to get the start of the data block.
  	 */
++<<<<<<< HEAD
 +	map_info->map_off = xfs_dir2_db_to_da(mp,
 +					      xfs_dir2_byte_to_db(mp, curoff));
++=======
+ 	map_info->map_off = xfs_dir2_db_to_da(geo,
+ 					      xfs_dir2_byte_to_db(geo, curoff));
++>>>>>>> 30028030b14d (xfs: convert directory db conversion to xfs_da_geometry)
  
  	/*
  	 * Loop over directory entries until we reach the end offset.
@@@ -617,8 -615,8 +657,13 @@@
  				 * Now set our real offset.
  				 */
  				curoff =
++<<<<<<< HEAD
 +					xfs_dir2_db_off_to_byte(mp,
 +					    xfs_dir2_byte_to_db(mp, curoff),
++=======
+ 					xfs_dir2_db_off_to_byte(geo,
+ 					    xfs_dir2_byte_to_db(geo, curoff),
++>>>>>>> 30028030b14d (xfs: convert directory db conversion to xfs_da_geometry)
  					    (char *)ptr - (char *)hdr);
  				if (ptr >= (char *)hdr + mp->m_dirblksize) {
  					continue;
diff --git a/fs/xfs/xfs_da_format.c b/fs/xfs/xfs_da_format.c
index 6ba0090d4962..f18400897729 100644
--- a/fs/xfs/xfs_da_format.c
+++ b/fs/xfs/xfs_da_format.c
@@ -609,7 +609,7 @@ xfs_dir2_free_bests_p(struct xfs_dir2_free *free)
 static xfs_dir2_db_t
 xfs_dir2_db_to_fdb(struct xfs_mount *mp, xfs_dir2_db_t db)
 {
-	return xfs_dir2_byte_to_db(mp, XFS_DIR2_FREE_OFFSET) +
+	return xfs_dir2_byte_to_db(mp->m_dir_geo, XFS_DIR2_FREE_OFFSET) +
 			(db / xfs_dir2_free_max_bests(mp));
 }
 
@@ -641,7 +641,7 @@ xfs_dir3_free_bests_p(struct xfs_dir2_free *free)
 static xfs_dir2_db_t
 xfs_dir3_db_to_fdb(struct xfs_mount *mp, xfs_dir2_db_t db)
 {
-	return xfs_dir2_byte_to_db(mp, XFS_DIR2_FREE_OFFSET) +
+	return xfs_dir2_byte_to_db(mp->m_dir_geo, XFS_DIR2_FREE_OFFSET) +
 			(db / xfs_dir3_free_max_bests(mp));
 }
 
diff --git a/fs/xfs/xfs_dir2.c b/fs/xfs/xfs_dir2.c
index b4210d6721ad..1338c8ed0ef4 100644
--- a/fs/xfs/xfs_dir2.c
+++ b/fs/xfs/xfs_dir2.c
@@ -117,9 +117,14 @@ xfs_da_mount(
 	dageo->fsblog = mp->m_sb.sb_blocklog;
 	dageo->blksize = 1 << dageo->blklog;
 	dageo->fsbcount = 1 << mp->m_sb.sb_dirblklog;
-	dageo->datablk = xfs_dir2_byte_to_da(mp, XFS_DIR2_DATA_OFFSET);
-	dageo->leafblk = xfs_dir2_byte_to_da(mp, XFS_DIR2_LEAF_OFFSET);
-	dageo->freeblk = xfs_dir2_byte_to_da(mp, XFS_DIR2_FREE_OFFSET);
+
+	/*
+	 * Now we've set up the block conversion variables, we can calculate the
+	 * segment block constants using the geometry structure.
+	 */
+	dageo->datablk = xfs_dir2_byte_to_da(dageo, XFS_DIR2_DATA_OFFSET);
+	dageo->leafblk = xfs_dir2_byte_to_da(dageo, XFS_DIR2_LEAF_OFFSET);
+	dageo->freeblk = xfs_dir2_byte_to_da(dageo, XFS_DIR2_FREE_OFFSET);
 	dageo->node_ents = (dageo->blksize - nodehdr_size) /
 				(uint)sizeof(xfs_da_node_entry_t);
 	dageo->magicpct = (dageo->blksize * 37) / 100;
@@ -746,7 +751,7 @@ xfs_dir2_shrink_inode(
 	/*
 	 * If it's not a data block, we're done.
 	 */
-	if (db >= xfs_dir2_byte_to_db(mp, XFS_DIR2_LEAF_OFFSET))
+	if (db >= xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET))
 		return 0;
 	/*
 	 * If the block isn't the last one in the directory, we're done.
diff --git a/fs/xfs/xfs_dir2_block.c b/fs/xfs/xfs_dir2_block.c
index 525993902ddb..73a8166345d9 100644
--- a/fs/xfs/xfs_dir2_block.c
+++ b/fs/xfs/xfs_dir2_block.c
@@ -639,7 +639,8 @@ xfs_dir2_block_lookup(
 	 * Get the offset from the leaf entry, to point to the data.
 	 */
 	dep = (xfs_dir2_data_entry_t *)((char *)hdr +
-		xfs_dir2_dataptr_to_off(mp, be32_to_cpu(blp[ent].address)));
+			xfs_dir2_dataptr_to_off(args->geo,
+						be32_to_cpu(blp[ent].address)));
 	/*
 	 * Fill in inode number, CI name if appropriate, release the block.
 	 */
@@ -723,7 +724,7 @@ xfs_dir2_block_lookup_int(
 		 * Get pointer to the entry from the leaf.
 		 */
 		dep = (xfs_dir2_data_entry_t *)
-			((char *)hdr + xfs_dir2_dataptr_to_off(mp, addr));
+			((char *)hdr + xfs_dir2_dataptr_to_off(args->geo, addr));
 		/*
 		 * Compare name and if it's an exact match, return the index
 		 * and buffer. If it's the first case-insensitive match, store
@@ -795,8 +796,9 @@ xfs_dir2_block_removename(
 	/*
 	 * Point to the data entry using the leaf entry.
 	 */
-	dep = (xfs_dir2_data_entry_t *)
-	      ((char *)hdr + xfs_dir2_dataptr_to_off(mp, be32_to_cpu(blp[ent].address)));
+	dep = (xfs_dir2_data_entry_t *)((char *)hdr +
+			xfs_dir2_dataptr_to_off(args->geo,
+						be32_to_cpu(blp[ent].address)));
 	/*
 	 * Mark the data entry's space free.
 	 */
@@ -870,8 +872,9 @@ xfs_dir2_block_replace(
 	/*
 	 * Point to the data entry we need to change.
 	 */
-	dep = (xfs_dir2_data_entry_t *)
-	      ((char *)hdr + xfs_dir2_dataptr_to_off(mp, be32_to_cpu(blp[ent].address)));
+	dep = (xfs_dir2_data_entry_t *)((char *)hdr +
+			xfs_dir2_dataptr_to_off(args->geo,
+						be32_to_cpu(blp[ent].address)));
 	ASSERT(be64_to_cpu(dep->inumber) != args->inumber);
 	/*
 	 * Change the inode number to the new value.
diff --git a/fs/xfs/xfs_dir2_data.c b/fs/xfs/xfs_dir2_data.c
index bae8b5b8d1c2..41756e20377d 100644
--- a/fs/xfs/xfs_dir2_data.c
+++ b/fs/xfs/xfs_dir2_data.c
@@ -172,7 +172,8 @@ __xfs_dir3_data_check(
 		lastfree = 0;
 		if (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||
 		    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {
-			addr = xfs_dir2_db_off_to_dataptr(mp, mp->m_dirdatablk,
+			addr = xfs_dir2_db_off_to_dataptr(mp->m_dir_geo,
+				mp->m_dirdatablk,
 				(xfs_dir2_data_aoff_t)
 				((char *)dep - (char *)hdr));
 			name.name = dep->name;
* Unmerged path fs/xfs/xfs_dir2_leaf.c
diff --git a/fs/xfs/xfs_dir2_node.c b/fs/xfs/xfs_dir2_node.c
index 36c68e9c23d3..a7f8e90eeffd 100644
--- a/fs/xfs/xfs_dir2_node.c
+++ b/fs/xfs/xfs_dir2_node.c
@@ -315,7 +315,7 @@ xfs_dir2_leaf_to_node(
 	if ((error = xfs_dir2_grow_inode(args, XFS_DIR2_FREE_SPACE, &fdb))) {
 		return error;
 	}
-	ASSERT(fdb == xfs_dir2_byte_to_db(mp, XFS_DIR2_FREE_OFFSET));
+	ASSERT(fdb == xfs_dir2_byte_to_db(args->geo, XFS_DIR2_FREE_OFFSET));
 	/*
 	 * Get the buffer for the new freespace block.
 	 */
@@ -450,7 +450,7 @@ xfs_dir2_leafn_add(
 				       highstale, &lfloglow, &lfloghigh);
 
 	lep->hashval = cpu_to_be32(args->hashval);
-	lep->address = cpu_to_be32(xfs_dir2_db_off_to_dataptr(mp,
+	lep->address = cpu_to_be32(xfs_dir2_db_off_to_dataptr(args->geo,
 				args->blkno, args->index));
 
 	dp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);
@@ -576,7 +576,8 @@ xfs_dir2_leafn_lookup_for_addname(
 		/*
 		 * Pull the data block number from the entry.
 		 */
-		newdb = xfs_dir2_dataptr_to_db(mp, be32_to_cpu(lep->address));
+		newdb = xfs_dir2_dataptr_to_db(args->geo,
+					       be32_to_cpu(lep->address));
 		/*
 		 * For addname, we're looking for a place to put the new entry.
 		 * We want to use a data block with an entry of equal
@@ -721,7 +722,8 @@ xfs_dir2_leafn_lookup_for_entry(
 		/*
 		 * Pull the data block number from the entry.
 		 */
-		newdb = xfs_dir2_dataptr_to_db(mp, be32_to_cpu(lep->address));
+		newdb = xfs_dir2_dataptr_to_db(args->geo,
+					       be32_to_cpu(lep->address));
 		/*
 		 * Not adding a new entry, so we really want to find
 		 * the name given to us.
@@ -758,7 +760,8 @@ xfs_dir2_leafn_lookup_for_entry(
 		 * Point to the data entry.
 		 */
 		dep = (xfs_dir2_data_entry_t *)((char *)curbp->b_addr +
-			xfs_dir2_dataptr_to_off(mp, be32_to_cpu(lep->address)));
+			xfs_dir2_dataptr_to_off(args->geo,
+						be32_to_cpu(lep->address)));
 		/*
 		 * Compare the entry and if it's an exact match, return
 		 * EEXIST immediately. If it's the first case-insensitive
@@ -1193,9 +1196,9 @@ xfs_dir2_leafn_remove(
 	/*
 	 * Extract the data block and offset from the entry.
 	 */
-	db = xfs_dir2_dataptr_to_db(mp, be32_to_cpu(lep->address));
+	db = xfs_dir2_dataptr_to_db(args->geo, be32_to_cpu(lep->address));
 	ASSERT(dblk->blkno == db);
-	off = xfs_dir2_dataptr_to_off(mp, be32_to_cpu(lep->address));
+	off = xfs_dir2_dataptr_to_off(args->geo, be32_to_cpu(lep->address));
 	ASSERT(dblk->index == off);
 
 	/*
@@ -1256,7 +1259,8 @@ xfs_dir2_leafn_remove(
 		struct xfs_dir3_icfree_hdr freehdr;
 		dp->d_ops->free_hdr_from_disk(&freehdr, free);
 		ASSERT(freehdr.firstdb == dp->d_ops->free_max_bests(mp) *
-			  (fdb - xfs_dir2_byte_to_db(mp, XFS_DIR2_FREE_OFFSET)));
+			(fdb - xfs_dir2_byte_to_db(args->geo,
+						   XFS_DIR2_FREE_OFFSET)));
 	}
 #endif
 		/*
@@ -1747,7 +1751,7 @@ xfs_dir2_node_addname_int(
 			 * us a freespace block to start with.
 			 */
 			if (++fbno == 0)
-				fbno = xfs_dir2_byte_to_db(mp,
+				fbno = xfs_dir2_byte_to_db(args->geo,
 							XFS_DIR2_FREE_OFFSET);
 			/*
 			 * If it's ifbno we already looked at it.
@@ -1889,7 +1893,7 @@ xfs_dir2_node_addname_int(
 			 * Remember the first slot as our empty slot.
 			 */
 			freehdr.firstdb =
-				(fbno - xfs_dir2_byte_to_db(mp,
+				(fbno - xfs_dir2_byte_to_db(args->geo,
 							XFS_DIR2_FREE_OFFSET)) *
 					dp->d_ops->free_max_bests(mp);
 		} else {
@@ -2189,7 +2193,8 @@ xfs_dir2_node_replace(
 		       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC));
 		dep = (xfs_dir2_data_entry_t *)
 		      ((char *)hdr +
-		       xfs_dir2_dataptr_to_off(state->mp, be32_to_cpu(lep->address)));
+		       xfs_dir2_dataptr_to_off(args->geo,
+					       be32_to_cpu(lep->address)));
 		ASSERT(inum != be64_to_cpu(dep->inumber));
 		/*
 		 * Fill in the new inode number and log the entry.
* Unmerged path fs/xfs/xfs_dir2_priv.h
* Unmerged path fs/xfs/xfs_dir2_readdir.c
diff --git a/fs/xfs/xfs_dir2_sf.c b/fs/xfs/xfs_dir2_sf.c
index 7aab8ec117ad..4dc4193bdf1e 100644
--- a/fs/xfs/xfs_dir2_sf.c
+++ b/fs/xfs/xfs_dir2_sf.c
@@ -104,8 +104,8 @@ xfs_dir2_block_sfsize(
 		/*
 		 * Calculate the pointer to the entry at hand.
 		 */
-		dep = (xfs_dir2_data_entry_t *)
-		      ((char *)hdr + xfs_dir2_dataptr_to_off(mp, addr));
+		dep = (xfs_dir2_data_entry_t *)((char *)hdr +
+				xfs_dir2_dataptr_to_off(mp->m_dir_geo, addr));
 		/*
 		 * Detect . and .., so we can special-case them.
 		 * . is not included in sf directories.
