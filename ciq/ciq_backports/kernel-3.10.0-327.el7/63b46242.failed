bonding: fix incorrect lacp mux state when agg not active

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Wilson Kok <wkok@cumulusnetworks.com>
commit 63b46242f707849a1df10b70e026281bfa40e849
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/63b46242.failed

This patch attempts to fix the following problems when an actor or
partner's aggregator is not active:
    1. a slave's lacp port state is marked as AD_STATE_SYNCHRONIZATION
       even if it is attached to an inactive aggregator. LACP advertises
       this state to the partner, making the partner think he can move
       into COLLECTING_DISTRIBUTING state even though this link will not
       pass traffic on the local side

    2. a slave goes into COLLECTING_DISTRIBUTING state without checking
       if the aggregator is actually active

    3. when in COLLECTING_DISTRIBUTING state, the partner parameters may
       change, e.g. the partner_oper_port_state.SYNCHRONIZATION. The
       local mux machine is not reacting to the change and continue to
       keep the slave and bond up

    4. When bond slave leaves an inactive aggregator and joins an active
       aggregator, the actor oper port state need to update to SYNC state.

v2:
 * fix style issues in bond_3ad.c

	Cc: Andy Gospodarek <gospo@cumulusnetworks.com>
	Reviewed-by: Nikolay Aleksandrov <nikolay@redhat.com>
	Signed-off-by: Wilson Kok <wkok@cumulusnetworks.com>
	Signed-off-by: Jonathan Toppins <jtoppins@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 63b46242f707849a1df10b70e026281bfa40e849)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_3ad.c
diff --cc drivers/net/bonding/bond_3ad.c
index 65115ee7b259,e3c96b216eb8..000000000000
--- a/drivers/net/bonding/bond_3ad.c
+++ b/drivers/net/bonding/bond_3ad.c
@@@ -506,15 -461,20 +506,26 @@@ static void __record_pdu(struct lacpdu 
  		partner->key = ntohs(lacpdu->actor_key);
  		partner->port_state = lacpdu->actor_state;
  
 -		/* set actor_oper_port_state.defaulted to FALSE */
 +		// set actor_oper_port_state.defaulted to FALSE
  		port->actor_oper_port_state &= ~AD_STATE_DEFAULTED;
  
++<<<<<<< HEAD
 +		// set the partner sync. to on if the partner is sync. and the port is matched
 +		if ((port->sm_vars & AD_PORT_MATCHED)
 +		    && (lacpdu->actor_state & AD_STATE_SYNCHRONIZATION))
++=======
+ 		/* set the partner sync. to on if the partner is sync,
+ 		 * and the port is matched
+ 		 */
+ 		if ((port->sm_vars & AD_PORT_MATCHED) &&
+ 		    (lacpdu->actor_state & AD_STATE_SYNCHRONIZATION)) {
++>>>>>>> 63b46242f707 (bonding: fix incorrect lacp mux state when agg not active)
  			partner->port_state |= AD_STATE_SYNCHRONIZATION;
- 		else
+ 			pr_debug("%s partner sync=1\n", port->slave->dev->name);
+ 		} else {
  			partner->port_state &= ~AD_STATE_SYNCHRONIZATION;
+ 			pr_debug("%s partner sync=0\n", port->slave->dev->name);
+ 		}
  	}
  }
  
@@@ -931,37 -882,57 +944,67 @@@ static void ad_mux_machine(struct port 
  			    && !(--port->sm_mux_timer_counter))
  				port->sm_vars |= AD_PORT_READY_N;
  
 -			/* in order to withhold the selection logic to check
 -			 * all ports READY_N value every callback cycle to
 -			 * update ready variable, we check READY_N and update
 -			 * READY here
 -			 */
 +			// in order to withhold the selection logic to check all ports READY_N value
 +			// every callback cycle to update ready variable, we check READY_N and update READY here
  			__set_agg_ports_ready(port->aggregator, __agg_ports_are_ready(port->aggregator));
  
 -			/* if the wait_while_timer expired, and the port is
 -			 * in READY state, move to ATTACHED state
 -			 */
 +			// if the wait_while_timer expired, and the port is in READY state, move to ATTACHED state
  			if ((port->sm_vars & AD_PORT_READY)
  			    && !port->sm_mux_timer_counter)
 -				port->sm_mux_state = AD_MUX_ATTACHED;
 +				port->sm_mux_state = AD_MUX_ATTACHED;	 // next state
  			break;
  		case AD_MUX_ATTACHED:
++<<<<<<< HEAD
 +			// check also if agg_select_timer expired(so the edable port will take place only after this timer)
 +			if ((port->sm_vars & AD_PORT_SELECTED) && (port->partner_oper.port_state & AD_STATE_SYNCHRONIZATION) && !__check_agg_selection_timer(port)) {
 +				port->sm_mux_state = AD_MUX_COLLECTING_DISTRIBUTING;// next state
 +			} else if (!(port->sm_vars & AD_PORT_SELECTED) || (port->sm_vars & AD_PORT_STANDBY)) {	  // if UNSELECTED or STANDBY
++=======
+ 			/* check also if agg_select_timer expired (so the
+ 			 * edable port will take place only after this timer)
+ 			 */
+ 			if ((port->sm_vars & AD_PORT_SELECTED) &&
+ 			    (port->partner_oper.port_state & AD_STATE_SYNCHRONIZATION) &&
+ 			    !__check_agg_selection_timer(port)) {
+ 				if (port->aggregator->is_active)
+ 					port->sm_mux_state =
+ 					    AD_MUX_COLLECTING_DISTRIBUTING;
+ 			} else if (!(port->sm_vars & AD_PORT_SELECTED) ||
+ 				   (port->sm_vars & AD_PORT_STANDBY)) {
+ 				/* if UNSELECTED or STANDBY */
++>>>>>>> 63b46242f707 (bonding: fix incorrect lacp mux state when agg not active)
  				port->sm_vars &= ~AD_PORT_READY_N;
 -				/* in order to withhold the selection logic to
 -				 * check all ports READY_N value every callback
 -				 * cycle to update ready variable, we check
 -				 * READY_N and update READY here
 -				 */
 +				// in order to withhold the selection logic to check all ports READY_N value
 +				// every callback cycle to update ready variable, we check READY_N and update READY here
  				__set_agg_ports_ready(port->aggregator, __agg_ports_are_ready(port->aggregator));
++<<<<<<< HEAD
 +				port->sm_mux_state = AD_MUX_DETACHED;// next state
 +			}
 +			break;
 +		case AD_MUX_COLLECTING_DISTRIBUTING:
 +			if (!(port->sm_vars & AD_PORT_SELECTED) || (port->sm_vars & AD_PORT_STANDBY) ||
 +			    !(port->partner_oper.port_state & AD_STATE_SYNCHRONIZATION)
 +			   ) {
 +				port->sm_mux_state = AD_MUX_ATTACHED;// next state
 +
++=======
+ 				port->sm_mux_state = AD_MUX_DETACHED;
+ 			} else if (port->aggregator->is_active) {
+ 				port->actor_oper_port_state |=
+ 				    AD_STATE_SYNCHRONIZATION;
+ 			}
+ 			break;
+ 		case AD_MUX_COLLECTING_DISTRIBUTING:
+ 			if (!(port->sm_vars & AD_PORT_SELECTED) ||
+ 			    (port->sm_vars & AD_PORT_STANDBY) ||
+ 			    !(port->partner_oper.port_state & AD_STATE_SYNCHRONIZATION) ||
+ 			    !(port->actor_oper_port_state & AD_STATE_SYNCHRONIZATION)) {
+ 				port->sm_mux_state = AD_MUX_ATTACHED;
++>>>>>>> 63b46242f707 (bonding: fix incorrect lacp mux state when agg not active)
  			} else {
 -				/* if port state hasn't changed make
 -				 * sure that a collecting distributing
 -				 * port in an active aggregator is enabled
 -				 */
 +				// if port state hasn't changed make
 +				// sure that a collecting distributing
 +				// port in an active aggregator is enabled
  				if (port->aggregator &&
  				    port->aggregator->is_active &&
  				    !__port_is_enabled(port)) {
@@@ -975,10 -946,12 +1018,12 @@@
  		}
  	}
  
 -	/* check if the state machine was changed */
 +	// check if the state machine was changed
  	if (port->sm_mux_state != last_state) {
- 		pr_debug("Mux Machine: Port=%d, Last State=%d, Curr State=%d\n",
- 			 port->actor_port_number, last_state,
+ 		pr_debug("Mux Machine: Port=%d (%s), Last State=%d, Curr State=%d\n",
+ 			 port->actor_port_number,
+ 			 port->slave->dev->name,
+ 			 last_state,
  			 port->sm_mux_state);
  		switch (port->sm_mux_state) {
  		case AD_MUX_DETACHED:
@@@ -993,20 -966,27 +1038,35 @@@
  			port->sm_mux_timer_counter = __ad_timer_to_ticks(AD_WAIT_WHILE_TIMER, 0);
  			break;
  		case AD_MUX_ATTACHED:
++<<<<<<< HEAD
 +			__attach_bond_to_agg(port);
 +			port->actor_oper_port_state |= AD_STATE_SYNCHRONIZATION;
++=======
+ 			if (port->aggregator->is_active)
+ 				port->actor_oper_port_state |=
+ 				    AD_STATE_SYNCHRONIZATION;
+ 			else
+ 				port->actor_oper_port_state &=
+ 				    ~AD_STATE_SYNCHRONIZATION;
++>>>>>>> 63b46242f707 (bonding: fix incorrect lacp mux state when agg not active)
  			port->actor_oper_port_state &= ~AD_STATE_COLLECTING;
  			port->actor_oper_port_state &= ~AD_STATE_DISTRIBUTING;
 -			ad_disable_collecting_distributing(port,
 -							   update_slave_arr);
 +			ad_disable_collecting_distributing(port);
  			port->ntt = true;
  			break;
  		case AD_MUX_COLLECTING_DISTRIBUTING:
  			port->actor_oper_port_state |= AD_STATE_COLLECTING;
  			port->actor_oper_port_state |= AD_STATE_DISTRIBUTING;
++<<<<<<< HEAD
 +			ad_enable_collecting_distributing(port);
++=======
+ 			port->actor_oper_port_state |= AD_STATE_SYNCHRONIZATION;
+ 			ad_enable_collecting_distributing(port,
+ 							  update_slave_arr);
++>>>>>>> 63b46242f707 (bonding: fix incorrect lacp mux state when agg not active)
  			port->ntt = true;
  			break;
 -		default:
 +		default:    //to silence the compiler
  			break;
  		}
  	}
@@@ -1077,10 -1061,12 +1137,12 @@@ static void ad_rx_machine(struct lacpd
  		}
  	}
  
 -	/* check if the State machine was changed or new lacpdu arrived */
 +	// check if the State machine was changed or new lacpdu arrived
  	if ((port->sm_rx_state != last_state) || (lacpdu)) {
- 		pr_debug("Rx Machine: Port=%d, Last State=%d, Curr State=%d\n",
- 			 port->actor_port_number, last_state,
+ 		pr_debug("Rx Machine: Port=%d (%s), Last State=%d, Curr State=%d\n",
+ 			 port->actor_port_number,
+ 			 port->slave->dev->name,
+ 			 last_state,
  			 port->sm_rx_state);
  		switch (port->sm_rx_state) {
  		case AD_RX_INITIALIZE:
@@@ -1396,16 -1406,21 +1458,23 @@@ static void ad_port_selection_logic(str
  			       port->actor_port_number, port->slave->dev->name);
  		}
  	}
 -	/* if all aggregator's ports are READY_N == TRUE, set ready=TRUE
 -	 * in all aggregator's ports, else set ready=FALSE in all
 -	 * aggregator's ports
 -	 */
 -	__set_agg_ports_ready(port->aggregator,
 -			      __agg_ports_are_ready(port->aggregator));
 +	// if all aggregator's ports are READY_N == TRUE, set ready=TRUE in all aggregator's ports
 +	// else set ready=FALSE in all aggregator's ports
 +	__set_agg_ports_ready(port->aggregator, __agg_ports_are_ready(port->aggregator));
  
  	aggregator = __get_first_agg(port);
++<<<<<<< HEAD
 +	ad_agg_selection_logic(aggregator);
++=======
+ 	ad_agg_selection_logic(aggregator, update_slave_arr);
+ 
+ 	if (!port->aggregator->is_active)
+ 		port->actor_oper_port_state &= ~AD_STATE_SYNCHRONIZATION;
++>>>>>>> 63b46242f707 (bonding: fix incorrect lacp mux state when agg not active)
  }
  
 -/* Decide if "agg" is a better choice for the new active aggregator that
 +/*
 + * Decide if "agg" is a better choice for the new active aggregator that
   * the current best, according to the ad_select policy.
   */
  static struct aggregator *ad_agg_selection_test(struct aggregator *best,
* Unmerged path drivers/net/bonding/bond_3ad.c
