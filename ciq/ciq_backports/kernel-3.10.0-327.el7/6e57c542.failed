xfs: bulkstat main loop logic is a mess

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit 6e57c542cb7e0e580eb53ae76a77875c7d92b4b1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/6e57c542.failed

There are a bunch of variables tha tare more wildy scoped than they
need to be, obfuscated user buffer checks and tortured "next inode"
tracking. This all needs cleaning up to expose the real issues that
need fixing.

cc: <stable@vger.kernel.org> # 3.17
	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>
(cherry picked from commit 6e57c542cb7e0e580eb53ae76a77875c7d92b4b1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_itable.c
diff --cc fs/xfs/xfs_itable.c
index 00889cf40587,acae3355ab22..000000000000
--- a/fs/xfs/xfs_itable.c
+++ b/fs/xfs/xfs_itable.c
@@@ -279,28 -347,15 +279,33 @@@ xfs_bulkstat
  	xfs_agi_t		*agi;	/* agi header data */
  	xfs_agino_t		agino;	/* inode # in allocation group */
  	xfs_agnumber_t		agno;	/* allocation group number */
 +	int			chunkidx; /* current index into inode chunk */
 +	int			clustidx; /* current index into inode cluster */
  	xfs_btree_cur_t		*cur;	/* btree cursor for ialloc btree */
++<<<<<<< HEAD
 +	int			end_of_ag; /* set if we've seen the ag end */
 +	int			error;	/* error code */
 +	int                     fmterror;/* bulkstat formatter result */
 +	int			i;	/* loop index */
 +	int			icount;	/* count of inodes good in irbuf */
++=======
++>>>>>>> 6e57c542cb7e (xfs: bulkstat main loop logic is a mess)
  	size_t			irbsize; /* size of irec buffer in bytes */
- 	xfs_ino_t		ino;	/* inode number (filesystem) */
- 	xfs_inobt_rec_incore_t	*irbp;	/* current irec buffer pointer */
  	xfs_inobt_rec_incore_t	*irbuf;	/* start of irec buffer */
- 	xfs_inobt_rec_incore_t	*irbufend; /* end of good irec buffer entries */
  	xfs_ino_t		lastino; /* last inode number returned */
  	int			nirbuf;	/* size of irbuf */
  	int			rval;	/* return value error code */
 +	int			tmp;	/* result value from btree calls */
  	int			ubcount; /* size of user's buffer */
++<<<<<<< HEAD
 +	int			ubleft;	/* bytes left in user's buffer */
 +	char			__user *ubufp;	/* pointer into user's buffer */
 +	int			ubelem;	/* spaces used in user's buffer */
 +	int			ubused;	/* bytes used by formatter */
++=======
+ 	struct xfs_bulkstat_agichunk ac;
+ 	int			error = 0;
++>>>>>>> 6e57c542cb7e (xfs: bulkstat main loop logic is a mess)
  
  	/*
  	 * Get the last inode value, see if there's nothing to do.
@@@ -335,8 -389,13 +339,18 @@@
  	 * inode returned; 0 means start of the allocation group.
  	 */
  	rval = 0;
++<<<<<<< HEAD
 +	while (XFS_BULKSTAT_UBLEFT(ubleft) && agno < mp->m_sb.sb_agcount) {
 +		cond_resched();
++=======
+ 	while (agno < mp->m_sb.sb_agcount) {
+ 		struct xfs_inobt_rec_incore	*irbp = irbuf;
+ 		struct xfs_inobt_rec_incore	*irbufend = irbuf + nirbuf;
+ 		bool				end_of_ag = false;
+ 		int				icount = 0;
+ 		int				stat;
+ 
++>>>>>>> 6e57c542cb7e (xfs: bulkstat main loop logic is a mess)
  		error = xfs_ialloc_read_agi(mp, NULL, agno, &agbp);
  		if (error)
  			break;
@@@ -368,13 -423,15 +378,18 @@@
  				agino = r.ir_startino + XFS_INODES_PER_CHUNK;
  			}
  			/* Increment to the next record */
 -			error = xfs_btree_increment(cur, 0, &stat);
 +			error = xfs_btree_increment(cur, 0, &tmp);
  		} else {
  			/* Start of ag.  Lookup the first inode chunk */
 -			error = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &stat);
 +			error = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &tmp);
  		}
++<<<<<<< HEAD
 +		if (error)
++=======
+ 		if (error || stat == 0) {
+ 			end_of_ag = true;
++>>>>>>> 6e57c542cb7e (xfs: bulkstat main loop logic is a mess)
  			goto del_cursor;
 -		}
  
  		/*
  		 * Loop through inode btree records in this ag,
@@@ -383,9 -440,9 +398,15 @@@
  		while (irbp < irbufend && icount < ubcount) {
  			struct xfs_inobt_rec_incore	r;
  
++<<<<<<< HEAD
 +			error = xfs_inobt_get_rec(cur, &r, &i);
 +			if (error || i == 0) {
 +				end_of_ag = 1;
++=======
+ 			error = xfs_inobt_get_rec(cur, &r, &stat);
+ 			if (error || stat == 0) {
+ 				end_of_ag = true;
++>>>>>>> 6e57c542cb7e (xfs: bulkstat main loop logic is a mess)
  				goto del_cursor;
  			}
  
@@@ -405,9 -462,9 +426,15 @@@
  			 * Set agino to after this chunk and bump the cursor.
  			 */
  			agino = r.ir_startino + XFS_INODES_PER_CHUNK;
++<<<<<<< HEAD
 +			error = xfs_btree_increment(cur, 0, &tmp);
 +			if (error) {
 +				end_of_ag = 1;
++=======
+ 			error = xfs_btree_increment(cur, 0, &stat);
+ 			if (error || stat == 0) {
+ 				end_of_ag = true;
++>>>>>>> 6e57c542cb7e (xfs: bulkstat main loop logic is a mess)
  				goto del_cursor;
  			}
  			cond_resched();
@@@ -428,72 -485,26 +455,94 @@@ del_cursor
  		 */
  		irbufend = irbp;
  		for (irbp = irbuf;
++<<<<<<< HEAD
 +		     irbp < irbufend && XFS_BULKSTAT_UBLEFT(ubleft); irbp++) {
 +			/*
 +			 * Now process this chunk of inodes.
 +			 */
 +			for (agino = irbp->ir_startino, chunkidx = clustidx = 0;
 +			     XFS_BULKSTAT_UBLEFT(ubleft) &&
 +				irbp->ir_freecount < XFS_INODES_PER_CHUNK;
 +			     chunkidx++, clustidx++, agino++) {
 +				ASSERT(chunkidx < XFS_INODES_PER_CHUNK);
 +
 +				ino = XFS_AGINO_TO_INO(mp, agno, agino);
 +				/*
 +				 * Skip if this inode is free.
 +				 */
 +				if (XFS_INOBT_MASK(chunkidx) & irbp->ir_free) {
 +					lastino = ino;
 +					continue;
 +				}
 +				/*
 +				 * Count used inodes as free so we can tell
 +				 * when the chunk is used up.
 +				 */
 +				irbp->ir_freecount++;
 +
 +				/*
 +				 * Get the inode and fill in a single buffer.
 +				 */
 +				ubused = statstruct_size;
 +				error = formatter(mp, ino, ubufp, ubleft,
 +						  &ubused, &fmterror);
 +				if (fmterror == BULKSTAT_RV_NOTHING) {
 +					if (error && error != ENOENT &&
 +						error != EINVAL) {
 +						ubleft = 0;
 +						rval = error;
 +						break;
 +					}
 +					lastino = ino;
 +					continue;
 +				}
 +				if (fmterror == BULKSTAT_RV_GIVEUP) {
 +					ubleft = 0;
 +					ASSERT(error);
 +					rval = error;
 +					break;
 +				}
 +				if (ubufp)
 +					ubufp += ubused;
 +				ubleft -= ubused;
 +				ubelem++;
 +				lastino = ino;
 +			}
 +
 +			cond_resched();
 +		}
 +		/*
 +		 * Set up for the next loop iteration.
 +		 */
 +		if (XFS_BULKSTAT_UBLEFT(ubleft)) {
 +			if (end_of_ag) {
 +				agno++;
 +				agino = 0;
 +			} else
 +				agino = XFS_INO_TO_AGINO(mp, lastino);
 +		} else
++=======
+ 		     irbp < irbufend && ac.ac_ubleft >= statstruct_size;
+ 		     irbp++) {
+ 			error = xfs_bulkstat_ag_ichunk(mp, agno, irbp,
+ 					formatter, statstruct_size, &ac,
+ 					&lastino);
+ 			if (error)
+ 				rval = error;
+ 
+ 			cond_resched();
+ 		}
+ 
+ 		/* If we've run out of space, we are done */
+ 		if (ac.ac_ubleft < statstruct_size)
++>>>>>>> 6e57c542cb7e (xfs: bulkstat main loop logic is a mess)
  			break;
+ 
+ 		if (end_of_ag) {
+ 			agno++;
+ 			agino = 0;
+ 		} else
+ 			agino = XFS_INO_TO_AGINO(mp, lastino);
  	}
  	/*
  	 * Done, we're either out of filesystem or space to put the data.
* Unmerged path fs/xfs/xfs_itable.c
