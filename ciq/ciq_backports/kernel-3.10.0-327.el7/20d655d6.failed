pnfs/blocklayout: use the device id cache

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 20d655d6197d02e98574208839da11684dc2ad1f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/20d655d6.failed

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 20d655d6197d02e98574208839da11684dc2ad1f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/blocklayout/blocklayout.c
#	fs/nfs/blocklayout/blocklayout.h
#	fs/nfs/blocklayout/blocklayoutdev.c
#	fs/nfs/blocklayout/extent_tree.c
diff --cc fs/nfs/blocklayout/blocklayout.c
index 5b7b41d3b0f9,25ba9e0e6fff..000000000000
--- a/fs/nfs/blocklayout/blocklayout.c
+++ b/fs/nfs/blocklayout/blocklayout.c
@@@ -156,8 -131,9 +158,14 @@@ static struct bio *bl_alloc_init_bio(in
  	}
  
  	if (bio) {
++<<<<<<< HEAD
 +		bio->bi_sector = isect - be->be_f_offset + be->be_v_offset;
 +		bio->bi_bdev = be->be_mdev;
++=======
+ 		bio->bi_iter.bi_sector = isect - be->be_f_offset +
+ 			be->be_v_offset;
+ 		bio->bi_bdev = dev->d_bdev;
++>>>>>>> 20d655d6197d (pnfs/blocklayout: use the device id cache)
  		bio->bi_end_io = end_io;
  		bio->bi_private = par;
  	}
@@@ -1062,90 -514,9 +1070,9 @@@ bl_cleanup_layoutcommit(struct nfs4_lay
  	struct pnfs_layout_hdr *lo = NFS_I(lcdata->args.inode)->layout;
  
  	dprintk("%s enter\n", __func__);
 -	ext_tree_mark_committed(BLK_LO2EXT(lo), lcdata->res.status);
 +	clean_pnfs_block_layoutupdate(BLK_LO2EXT(lo), &lcdata->args, lcdata->res.status);
  }
  
- static void free_blk_mountid(struct block_mount_id *mid)
- {
- 	if (mid) {
- 		struct pnfs_block_dev *dev, *tmp;
- 
- 		/* No need to take bm_lock as we are last user freeing bm_devlist */
- 		list_for_each_entry_safe(dev, tmp, &mid->bm_devlist, bm_node) {
- 			list_del(&dev->bm_node);
- 			bl_free_block_dev(dev);
- 		}
- 		kfree(mid);
- 	}
- }
- 
- /* This is mostly copied from the filelayout_get_device_info function.
-  * It seems much of this should be at the generic pnfs level.
-  */
- static struct pnfs_block_dev *
- nfs4_blk_get_deviceinfo(struct nfs_server *server, const struct nfs_fh *fh,
- 			struct nfs4_deviceid *d_id)
- {
- 	struct pnfs_device *dev;
- 	struct pnfs_block_dev *rv;
- 	u32 max_resp_sz;
- 	int max_pages;
- 	struct page **pages = NULL;
- 	int i, rc;
- 
- 	/*
- 	 * Use the session max response size as the basis for setting
- 	 * GETDEVICEINFO's maxcount
- 	 */
- 	max_resp_sz = server->nfs_client->cl_session->fc_attrs.max_resp_sz;
- 	max_pages = nfs_page_array_len(0, max_resp_sz);
- 	dprintk("%s max_resp_sz %u max_pages %d\n",
- 		__func__, max_resp_sz, max_pages);
- 
- 	dev = kmalloc(sizeof(*dev), GFP_NOFS);
- 	if (!dev) {
- 		dprintk("%s kmalloc failed\n", __func__);
- 		return ERR_PTR(-ENOMEM);
- 	}
- 
- 	pages = kcalloc(max_pages, sizeof(struct page *), GFP_NOFS);
- 	if (pages == NULL) {
- 		kfree(dev);
- 		return ERR_PTR(-ENOMEM);
- 	}
- 	for (i = 0; i < max_pages; i++) {
- 		pages[i] = alloc_page(GFP_NOFS);
- 		if (!pages[i]) {
- 			rv = ERR_PTR(-ENOMEM);
- 			goto out_free;
- 		}
- 	}
- 
- 	memcpy(&dev->dev_id, d_id, sizeof(*d_id));
- 	dev->layout_type = LAYOUT_BLOCK_VOLUME;
- 	dev->pages = pages;
- 	dev->pgbase = 0;
- 	dev->pglen = PAGE_SIZE * max_pages;
- 	dev->mincount = 0;
- 	dev->maxcount = max_resp_sz - nfs41_maxgetdevinfo_overhead;
- 
- 	dprintk("%s: dev_id: %s\n", __func__, dev->dev_id.data);
- 	rc = nfs4_proc_getdeviceinfo(server, dev, NULL);
- 	dprintk("%s getdevice info returns %d\n", __func__, rc);
- 	if (rc) {
- 		rv = ERR_PTR(rc);
- 		goto out_free;
- 	}
- 
- 	rv = nfs4_blk_decode_device(server, dev);
-  out_free:
- 	for (i = 0; i < max_pages; i++)
- 		__free_page(pages[i]);
- 	kfree(pages);
- 	kfree(dev);
- 	return rv;
- }
- 
  static int
  bl_set_layoutdriver(struct nfs_server *server, const struct nfs_fh *fh)
  {
diff --cc fs/nfs/blocklayout/blocklayout.h
index 9838fb020473,19fae5e4c90b..000000000000
--- a/fs/nfs/blocklayout/blocklayout.h
+++ b/fs/nfs/blocklayout/blocklayout.h
@@@ -63,86 -56,29 +56,92 @@@ enum exstate4 
  	PNFS_BLOCK_NONE_DATA		= 3  /* unmapped, it's a hole */
  };
  
 +#define MY_MAX_TAGS (15) /* tag bitnums used must be less than this */
 +
 +struct my_tree {
 +	sector_t		mtt_step_size;	/* Internal sector alignment */
 +	struct list_head	mtt_stub; /* Should be a radix tree */
 +};
 +
 +struct pnfs_inval_markings {
 +	spinlock_t	im_lock;
 +	struct my_tree	im_tree;	/* Sectors that need LAYOUTCOMMIT */
 +	sector_t	im_block_size;	/* Server blocksize in sectors */
 +	struct list_head im_extents;	/* Short extents for INVAL->RW conversion */
 +};
 +
 +struct pnfs_inval_tracking {
 +	struct list_head it_link;
 +	int		 it_sector;
 +	int		 it_tags;
 +};
 +
  /* sector_t fields are all in 512-byte sectors */
  struct pnfs_block_extent {
++<<<<<<< HEAD
 +	struct kref	be_refcnt;
 +	struct list_head be_node;	/* link into lseg list */
 +	struct nfs4_deviceid be_devid;  /* FIXME: could use device cache instead */
 +	struct block_device *be_mdev;
++=======
+ 	union {
+ 		struct rb_node	be_node;
+ 		struct list_head be_list;
+ 	};
+ 	struct nfs4_deviceid_node *be_device;
++>>>>>>> 20d655d6197d (pnfs/blocklayout: use the device id cache)
  	sector_t	be_f_offset;	/* the starting offset in the file */
  	sector_t	be_length;	/* the size of the extent */
  	sector_t	be_v_offset;	/* the starting offset in the volume */
  	enum exstate4	be_state;	/* the state of this extent */
 -#define EXTENT_WRITTEN		1
 -#define EXTENT_COMMITTING	2
 -	unsigned int	be_tag;
 +	struct pnfs_inval_markings *be_inval; /* tracks INVAL->RW transition */
 +};
 +
 +/* Shortened extent used by LAYOUTCOMMIT */
 +struct pnfs_block_short_extent {
 +	struct list_head bse_node;
 +	struct nfs4_deviceid bse_devid;
 +	struct block_device *bse_mdev;
 +	sector_t	bse_f_offset;	/* the starting offset in the file */
 +	sector_t	bse_length;	/* the size of the extent */
  };
  
 +static inline void
 +BL_INIT_INVAL_MARKS(struct pnfs_inval_markings *marks, sector_t blocksize)
 +{
 +	spin_lock_init(&marks->im_lock);
 +	INIT_LIST_HEAD(&marks->im_tree.mtt_stub);
 +	INIT_LIST_HEAD(&marks->im_extents);
 +	marks->im_block_size = blocksize;
 +	marks->im_tree.mtt_step_size = min((sector_t)PAGE_CACHE_SECTORS,
 +					   blocksize);
 +}
 +
 +enum extentclass4 {
 +	RW_EXTENT       = 0, /* READWRTE and INVAL */
 +	RO_EXTENT       = 1, /* READ and NONE */
 +	EXTENT_LISTS    = 2,
 +};
 +
 +static inline int bl_choose_list(enum exstate4 state)
 +{
 +	if (state == PNFS_BLOCK_READ_DATA || state == PNFS_BLOCK_NONE_DATA)
 +		return RO_EXTENT;
 +	else
 +		return RW_EXTENT;
 +}
 +
  struct pnfs_block_layout {
 -	struct pnfs_layout_hdr	bl_layout;
 -	struct rb_root		bl_ext_rw;
 -	struct rb_root		bl_ext_ro;
 +	struct pnfs_layout_hdr bl_layout;
 +	struct pnfs_inval_markings bl_inval; /* tracks INVAL->RW transition */
  	spinlock_t		bl_ext_lock;   /* Protects list manipulation */
 +	struct list_head	bl_extents[EXTENT_LISTS]; /* R and RW extents */
 +	struct list_head	bl_commit;	/* Needs layout commit */
 +	struct list_head	bl_committing;	/* Layout committing */
 +	unsigned int		bl_count;	/* entries in bl_commit */
 +	sector_t		bl_blocksize;  /* Server blocksize in sectors */
  };
  
- #define BLK_ID(lo) ((struct block_mount_id *)(NFS_SERVER(lo->plh_inode)->pnfs_ld_data))
- 
  static inline struct pnfs_block_layout *
  BLK_LO2EXT(struct pnfs_layout_hdr *lo)
  {
@@@ -177,35 -113,24 +176,36 @@@ void bl_pipe_destroy_msg(struct rpc_pip
  int nfs4_blk_process_layoutget(struct pnfs_layout_hdr *lo,
  				struct nfs4_layoutget_res *lgr, gfp_t gfp_flags);
  
+ struct nfs4_deviceid_node *bl_alloc_deviceid_node(struct nfs_server *server,
+ 		struct pnfs_device *pdev, gfp_t gfp_mask);
+ void bl_free_deviceid_node(struct nfs4_deviceid_node *d);
+ 
  /* blocklayoutdm.c */
- void bl_free_block_dev(struct pnfs_block_dev *bdev);
+ void bl_dm_remove(struct net *net, dev_t dev);
  
 -/* extent_tree.c */
 -int ext_tree_insert(struct pnfs_block_layout *bl,
 -		struct pnfs_block_extent *new);
 -int ext_tree_remove(struct pnfs_block_layout *bl, bool rw, sector_t start,
 -		sector_t end);
 -int ext_tree_mark_written(struct pnfs_block_layout *bl, sector_t start,
 -		sector_t len);
 -bool ext_tree_lookup(struct pnfs_block_layout *bl, sector_t isect,
 -		struct pnfs_block_extent *ret, bool rw);
 -int ext_tree_encode_commit(struct pnfs_block_layout *bl,
 -		struct xdr_stream *xdr);
 -void ext_tree_mark_committed(struct pnfs_block_layout *bl, int status);
 +/* extents.c */
 +struct pnfs_block_extent *
 +bl_find_get_extent(struct pnfs_block_layout *bl, sector_t isect,
 +		struct pnfs_block_extent **cow_read);
 +int bl_mark_sectors_init(struct pnfs_inval_markings *marks,
 +			     sector_t offset, sector_t length);
 +void bl_put_extent(struct pnfs_block_extent *be);
 +struct pnfs_block_extent *bl_alloc_extent(void);
 +int bl_is_sector_init(struct pnfs_inval_markings *marks, sector_t isect);
 +int encode_pnfs_block_layoutupdate(struct pnfs_block_layout *bl,
 +				   struct xdr_stream *xdr,
 +				   const struct nfs4_layoutcommit_args *arg);
 +void clean_pnfs_block_layoutupdate(struct pnfs_block_layout *bl,
 +				   const struct nfs4_layoutcommit_args *arg,
 +				   int status);
 +int bl_add_merge_extent(struct pnfs_block_layout *bl,
 +			 struct pnfs_block_extent *new);
 +int bl_mark_for_commit(struct pnfs_block_extent *be,
 +			sector_t offset, sector_t length,
 +			struct pnfs_block_short_extent *new);
 +int bl_push_one_short_extent(struct pnfs_inval_markings *marks);
 +struct pnfs_block_short_extent *
 +bl_pop_one_short_extent(struct pnfs_inval_markings *marks);
 +void bl_free_short_extents(struct pnfs_inval_markings *marks, int num_to_free);
  
  #endif /* FS_NFS_NFS4BLOCKLAYOUT_H */
diff --cc fs/nfs/blocklayout/blocklayoutdev.c
index 63f77925aa87,d6527d20c508..000000000000
--- a/fs/nfs/blocklayout/blocklayoutdev.c
+++ b/fs/nfs/blocklayout/blocklayoutdev.c
@@@ -309,7 -284,9 +284,13 @@@ nfs4_blk_process_layoutget(struct pnfs_
  	 * recovery easier.
  	 */
  	for (i = 0; i < count; i++) {
++<<<<<<< HEAD
 +		be = bl_alloc_extent();
++=======
+ 		struct nfs4_deviceid id;
+ 
+ 		be = kzalloc(sizeof(struct pnfs_block_extent), GFP_NOFS);
++>>>>>>> 20d655d6197d (pnfs/blocklayout: use the device id cache)
  		if (!be) {
  			status = -ENOMEM;
  			goto out_err;
@@@ -374,12 -344,15 +358,24 @@@
  	return status;
  
   out_err:
++<<<<<<< HEAD
 +	bl_put_extent(be);
 +	while (!list_empty(&extents)) {
 +		be = list_first_entry(&extents, struct pnfs_block_extent,
 +				      be_node);
 +		list_del(&be->be_node);
 +		bl_put_extent(be);
++=======
+ 	nfs4_put_deviceid_node(be->be_device);
+ 	kfree(be);
+  out_free_list:
+ 	while (!list_empty(&extents)) {
+ 		be = list_first_entry(&extents, struct pnfs_block_extent,
+ 				      be_list);
+ 		list_del(&be->be_list);
+ 		nfs4_put_deviceid_node(be->be_device);
+ 		kfree(be);
++>>>>>>> 20d655d6197d (pnfs/blocklayout: use the device id cache)
  	}
  	goto out;
  }
* Unmerged path fs/nfs/blocklayout/extent_tree.c
* Unmerged path fs/nfs/blocklayout/blocklayout.c
* Unmerged path fs/nfs/blocklayout/blocklayout.h
* Unmerged path fs/nfs/blocklayout/blocklayoutdev.c
diff --git a/fs/nfs/blocklayout/blocklayoutdm.c b/fs/nfs/blocklayout/blocklayoutdm.c
index 8999cfddd866..abc2e9e45610 100644
--- a/fs/nfs/blocklayout/blocklayoutdm.c
+++ b/fs/nfs/blocklayout/blocklayoutdm.c
@@ -38,7 +38,7 @@
 
 #define NFSDBG_FACILITY         NFSDBG_PNFS_LD
 
-static void dev_remove(struct net *net, dev_t dev)
+void bl_dm_remove(struct net *net, dev_t dev)
 {
 	struct bl_pipe_msg bl_pipe_msg;
 	struct rpc_pipe_msg *msg = &bl_pipe_msg.msg;
@@ -82,27 +82,3 @@ static void dev_remove(struct net *net, dev_t dev)
 out:
 	kfree(msg->data);
 }
-
-/*
- * Release meta device
- */
-static void nfs4_blk_metadev_release(struct pnfs_block_dev *bdev)
-{
-	dprintk("%s Releasing\n", __func__);
-	nfs4_blkdev_put(bdev->bm_mdev);
-	dev_remove(bdev->net, bdev->bm_mdev->bd_dev);
-}
-
-void bl_free_block_dev(struct pnfs_block_dev *bdev)
-{
-	if (bdev) {
-		if (bdev->bm_mdev) {
-			dprintk("%s Removing DM device: %d:%d\n",
-				__func__,
-				MAJOR(bdev->bm_mdev->bd_dev),
-				MINOR(bdev->bm_mdev->bd_dev));
-			nfs4_blk_metadev_release(bdev);
-		}
-		kfree(bdev);
-	}
-}
* Unmerged path fs/nfs/blocklayout/extent_tree.c
