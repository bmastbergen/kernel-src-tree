md/raid5: separate out the easy conditions in need_this_block.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [md] raid5: separate out the easy conditions in need_this_block (Jes Sorensen) [1150149 1173510 1194720]
Rebuild_FUZZ: 96.67%
commit-author NeilBrown <neilb@suse.de>
commit a79cfe12c619aa0fc401f9148d78faa6fc61a331
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/a79cfe12.failed

Some of the conditions in need_this_block have very straight
forward motivation.  Separate those out and document them.

	Signed-off-by: NeilBrown <neilb@suse.de>
(cherry picked from commit a79cfe12c619aa0fc401f9148d78faa6fc61a331)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/raid5.c
diff --cc drivers/md/raid5.c
index 7648d382ecbd,21c1e796a0d6..000000000000
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@@ -2908,18 -2903,54 +2908,69 @@@ static int fetch_block(struct stripe_he
  	struct r5dev *fdev[2] = { &sh->dev[s->failed_num[0]],
  				  &sh->dev[s->failed_num[1]] };
  
++<<<<<<< HEAD
 +	/* is the data in this block needed, and can we get it? */
 +	if (!test_bit(R5_LOCKED, &dev->flags) &&
 +	    !test_bit(R5_UPTODATE, &dev->flags) &&
 +	    (dev->toread ||
 +	     (dev->towrite && !test_bit(R5_OVERWRITE, &dev->flags)) ||
 +	     s->syncing || s->expanding ||
 +	     (s->replacing && want_replace(sh, disk_idx)) ||
 +	     (s->failed >= 1 && fdev[0]->toread) ||
 +	     (s->failed >= 2 && fdev[1]->toread) ||
++=======
+ 
+ 	if (test_bit(R5_LOCKED, &dev->flags) ||
+ 	    test_bit(R5_UPTODATE, &dev->flags))
+ 		/* No point reading this as we already have it or have
+ 		 * decided to get it.
+ 		 */
+ 		return 0;
+ 
+ 	if (dev->toread ||
+ 	    (dev->towrite && !test_bit(R5_OVERWRITE, &dev->flags)))
+ 		/* We need this block to directly satisfy a request */
+ 		return 1;
+ 
+ 	if (s->syncing || s->expanding ||
+ 	    (s->replacing && want_replace(sh, disk_idx)))
+ 		/* When syncing, or expanding we read everything.
+ 		 * When replacing, we need the replaced block.
+ 		 */
+ 		return 1;
+ 
+ 	if ((s->failed >= 1 && fdev[0]->toread) ||
+ 	    (s->failed >= 2 && fdev[1]->toread))
+ 		/* If we want to read from a failed device, then
+ 		 * we need to actually read every other device.
+ 		 */
+ 		return 1;
+ 
+ 	if (
++>>>>>>> a79cfe12c619 (md/raid5: separate out the easy conditions in need_this_block.)
  	     (sh->raid_conf->level <= 5 && s->failed && fdev[0]->towrite &&
 -	      (!test_bit(R5_Insync, &dev->flags) || test_bit(STRIPE_PREREAD_ACTIVE, &sh->state)) &&
  	      !test_bit(R5_OVERWRITE, &fdev[0]->flags)) ||
++<<<<<<< HEAD
 +	     (sh->raid_conf->level == 6 && s->failed && s->to_write))) {
++=======
+ 	     ((sh->raid_conf->level == 6 ||
+ 	       sh->sector >= sh->raid_conf->mddev->recovery_cp)
+ 	      && s->failed && s->to_write &&
+ 	      (s->to_write - s->non_overwrite <
+ 	       sh->raid_conf->raid_disks - sh->raid_conf->max_degraded) &&
+ 	      (!test_bit(R5_Insync, &dev->flags) || test_bit(STRIPE_PREREAD_ACTIVE, &sh->state))))
+ 		return 1;
+ 	return 0;
+ }
+ 
+ static int fetch_block(struct stripe_head *sh, struct stripe_head_state *s,
+ 		       int disk_idx, int disks)
+ {
+ 	struct r5dev *dev = &sh->dev[disk_idx];
+ 
+ 	/* is the data in this block needed, and can we get it? */
+ 	if (need_this_block(sh, s, disk_idx, disks)) {
++>>>>>>> a79cfe12c619 (md/raid5: separate out the easy conditions in need_this_block.)
  		/* we would like to get this block, possibly by computing it,
  		 * otherwise read it if the backing disk is insync
  		 */
* Unmerged path drivers/md/raid5.c
