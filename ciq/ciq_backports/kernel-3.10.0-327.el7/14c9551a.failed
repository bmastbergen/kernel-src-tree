bonding: Implement port churn-machine (AD standard 43.4.17).

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] bonding: Implement port churn-machine (AD standard 43.4.17) (Nikolay Aleksandrov) [1166647]
Rebuild_FUZZ: 99.16%
commit-author Mahesh Bandewar <maheshb@google.com>
commit 14c9551a32eba086c9f20c9d6a8e378481f15333
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/14c9551a.failed

The Churn Detection machines detect the situation where a port is operable,
but the Actor and Partner have not attached the link to an Aggregator and
brought the link into operation within a bound time period. Under normal
operation of the LACP, agreement between Actor and Partner should be reached
very rapidly. Continued failure to reach agreement can be symptomatic of
device failure.

Actor-churn-detection state-machine
	Reviewed-by: Nikolay Aleksandrov <nikolay@redhat.com>

===================================

BEGIN=True + PortEnable=False
           |
           v
 +------------------------+   ActorPort.Sync=True  +------------------+
 |   ACTOR_CHURN_MONITOR  | ---------------------> |  NO_ACTOR_CHURN  |
 |========================|                        |==================|
 |    ActorChurn=False    |  ActorPort.Sync=False  | ActorChurn=False |
 | ActorChurn.Timer=Start | <--------------------- |                  |
 +------------------------+                        +------------------+
           |                                                ^
           |                                                |
  ActorChurn.Timer=Expired                                  |
           |                                       ActorPort.Sync=True
           |                                                |
           |                +-----------------+             |
           |                |   ACTOR_CHURN   |             |
           |                |=================|             |
           +--------------> | ActorChurn=True | ------------+
                            |                 |
                            +-----------------+

Similar for the Partner-churn-detection.

	Signed-off-by: Mahesh Bandewar <maheshb@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 14c9551a32eba086c9f20c9d6a8e378481f15333)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_3ad.c
#	drivers/net/bonding/bond_procfs.c
diff --cc drivers/net/bonding/bond_3ad.c
index bcdd7c7dd6ad,f61b2870cddf..000000000000
--- a/drivers/net/bonding/bond_3ad.c
+++ b/drivers/net/bonding/bond_3ad.c
@@@ -38,8 -38,9 +38,9 @@@
  #define AD_STANDBY                 0x2
  #define AD_MAX_TX_IN_SECOND        3
  #define AD_COLLECTOR_MAX_DELAY     0
+ #define AD_MONITOR_CHURNED         0x1000
  
 -/* Timer definitions (43.4.4 in the 802.3ad standard) */
 +// Timer definitions(43.4.4 in the 802.3ad standard)
  #define AD_FAST_PERIODIC_TIME      1
  #define AD_SLOW_PERIODIC_TIME      30
  #define AD_SHORT_TIMEOUT_TIME      (3*AD_FAST_PERIODIC_TIME)
@@@ -1025,34 -1006,41 +1026,55 @@@ static void ad_rx_machine(struct lacpd
  {
  	rx_states_t last_state;
  
 -	/* keep current State Machine state to compare later if it was
 -	 * changed
 -	 */
 +	// keep current State Machine state to compare later if it was changed
  	last_state = port->sm_rx_state;
  
++<<<<<<< HEAD
 +	// check if state machine should change state
 +	// first, check if port was reinitialized
 +	if (port->sm_vars & AD_PORT_BEGIN)
 +		/* next state */
 +		port->sm_rx_state = AD_RX_INITIALIZE;
 +	// check if port is not enabled
 +	else if (!(port->sm_vars & AD_PORT_BEGIN)
++=======
+ 	/* check if state machine should change state */
+ 
+ 	/* first, check if port was reinitialized */
+ 	if (port->sm_vars & AD_PORT_BEGIN) {
+ 		port->sm_rx_state = AD_RX_INITIALIZE;
+ 		port->sm_vars |= AD_MONITOR_CHURNED;
+ 	/* check if port is not enabled */
+ 	} else if (!(port->sm_vars & AD_PORT_BEGIN)
++>>>>>>> 14c9551a32eb (bonding: Implement port churn-machine (AD standard 43.4.17).)
  		 && !port->is_enabled && !(port->sm_vars & AD_PORT_MOVED))
 +		/* next state */
  		port->sm_rx_state = AD_RX_PORT_DISABLED;
++<<<<<<< HEAD
 +	// check if new lacpdu arrived
 +	else if (lacpdu && ((port->sm_rx_state == AD_RX_EXPIRED) || (port->sm_rx_state == AD_RX_DEFAULTED) || (port->sm_rx_state == AD_RX_CURRENT))) {
 +		port->sm_rx_timer_counter = 0; // zero timer
++=======
+ 	/* check if new lacpdu arrived */
+ 	else if (lacpdu && ((port->sm_rx_state == AD_RX_EXPIRED) ||
+ 		 (port->sm_rx_state == AD_RX_DEFAULTED) ||
+ 		 (port->sm_rx_state == AD_RX_CURRENT))) {
+ 		if (port->sm_rx_state != AD_RX_CURRENT)
+ 			port->sm_vars |= AD_MONITOR_CHURNED;
+ 		port->sm_rx_timer_counter = 0;
++>>>>>>> 14c9551a32eb (bonding: Implement port churn-machine (AD standard 43.4.17).)
  		port->sm_rx_state = AD_RX_CURRENT;
  	} else {
 -		/* if timer is on, and if it is expired */
 -		if (port->sm_rx_timer_counter &&
 -		    !(--port->sm_rx_timer_counter)) {
 +		// if timer is on, and if it is expired
 +		if (port->sm_rx_timer_counter && !(--port->sm_rx_timer_counter)) {
  			switch (port->sm_rx_state) {
  			case AD_RX_EXPIRED:
 -				port->sm_rx_state = AD_RX_DEFAULTED;
 +				port->sm_rx_state = AD_RX_DEFAULTED;		// next state
  				break;
  			case AD_RX_CURRENT:
 -				port->sm_rx_state = AD_RX_EXPIRED;
 +				port->sm_rx_state = AD_RX_EXPIRED;	    // next state
  				break;
 -			default:
 +			default:    //to silence the compiler
  				break;
  			}
  		} else {
@@@ -1107,15 -1096,19 +1129,21 @@@
  			port->actor_oper_port_state &= ~AD_STATE_EXPIRED;
  			break;
  		case AD_RX_EXPIRED:
 -			/* Reset of the Synchronization flag (Standard 43.4.12)
 -			 * This reset cause to disable this port in the
 -			 * COLLECTING_DISTRIBUTING state of the mux machine in
 -			 * case of EXPIRED even if LINK_DOWN didn't arrive for
 -			 * the port.
 -			 */
 +			//Reset of the Synchronization flag. (Standard 43.4.12)
 +			//This reset cause to disable this port in the COLLECTING_DISTRIBUTING state of the
 +			//mux machine in case of EXPIRED even if LINK_DOWN didn't arrive for the port.
  			port->partner_oper.port_state &= ~AD_STATE_SYNCHRONIZATION;
  			port->sm_vars &= ~AD_PORT_MATCHED;
++<<<<<<< HEAD
 +			port->partner_oper.port_state |=
 +				AD_STATE_LACP_ACTIVITY;
++=======
+ 			port->partner_oper.port_state |= AD_STATE_LACP_TIMEOUT;
+ 			port->partner_oper.port_state |= AD_STATE_LACP_ACTIVITY;
++>>>>>>> 14c9551a32eb (bonding: Implement port churn-machine (AD standard 43.4.17).)
  			port->sm_rx_timer_counter = __ad_timer_to_ticks(AD_CURRENT_WHILE_TIMER, (u16)(AD_SHORT_TIMEOUT));
  			port->actor_oper_port_state |= AD_STATE_EXPIRED;
+ 			port->sm_vars |= AD_MONITOR_CHURNED;
  			break;
  		case AD_RX_DEFAULTED:
  			__update_default_selected(port);
@@@ -2144,27 -2211,35 +2218,28 @@@ void bond_3ad_state_machine_handler(str
  			goto re_arm;
  		}
  
 +		/* Lock around state machines to protect data accessed
 +		 * by all (e.g., port->sm_vars).  ad_rx_machine may run
 +		 * concurrently due to incoming LACPDU.
 +		 */
 +		__get_state_machine_lock(port);
 +
  		ad_rx_machine(NULL, port);
  		ad_periodic_machine(port);
 -		ad_port_selection_logic(port, &update_slave_arr);
 -		ad_mux_machine(port, &update_slave_arr);
 +		ad_port_selection_logic(port);
 +		ad_mux_machine(port);
  		ad_tx_machine(port);
+ 		ad_churn_machine(port);
  
 -		/* turn off the BEGIN bit, since we already handled it */
 +		// turn off the BEGIN bit, since we already handled it
  		if (port->sm_vars & AD_PORT_BEGIN)
  			port->sm_vars &= ~AD_PORT_BEGIN;
 -	}
  
 -re_arm:
 -	bond_for_each_slave_rcu(bond, slave, iter) {
 -		if (slave->should_notify) {
 -			should_notify_rtnl = BOND_SLAVE_NOTIFY_NOW;
 -			break;
 -		}
 +		__release_state_machine_lock(port);
  	}
 -	rcu_read_unlock();
 -	spin_unlock_bh(&bond->mode_lock);
 -
 -	if (update_slave_arr)
 -		bond_slave_arr_work_rearm(bond, 0);
  
 -	if (should_notify_rtnl && rtnl_trylock()) {
 -		bond_slave_state_notify(bond);
 -		rtnl_unlock();
 -	}
 +re_arm:
 +	rtnl_unlock();
  	queue_delayed_work(bond->wq, &bond->ad_work, ad_delta_in_ticks);
  }
  
diff --cc drivers/net/bonding/bond_procfs.c
index 96f629d77b41,62694cfc05b6..000000000000
--- a/drivers/net/bonding/bond_procfs.c
+++ b/drivers/net/bonding/bond_procfs.c
@@@ -181,18 -176,51 +181,57 @@@ static void bond_info_show_slave(struc
  		   slave->link_failure_count);
  
  	seq_printf(seq, "Permanent HW addr: %pM\n", slave->perm_hwaddr);
+ 	seq_printf(seq, "Slave queue ID: %d\n", slave->queue_id);
  
++<<<<<<< HEAD
 +	if (bond->params.mode == BOND_MODE_8023AD) {
 +		const struct aggregator *agg
 +			= SLAVE_AD_INFO(slave).port.aggregator;
++=======
+ 	if (BOND_MODE(bond) == BOND_MODE_8023AD) {
+ 		const struct port *port = &SLAVE_AD_INFO(slave)->port;
+ 		const struct aggregator *agg = port->aggregator;
++>>>>>>> 14c9551a32eb (bonding: Implement port churn-machine (AD standard 43.4.17).)
  
- 		if (agg)
+ 		if (agg) {
  			seq_printf(seq, "Aggregator ID: %d\n",
  				   agg->aggregator_identifier);
- 		else
+ 			seq_printf(seq, "Actor Churn State: %s\n",
+ 				   bond_3ad_churn_desc(port->sm_churn_actor_state));
+ 			seq_printf(seq, "Partner Churn State: %s\n",
+ 				   bond_3ad_churn_desc(port->sm_churn_partner_state));
+ 			seq_printf(seq, "Actor Churned Count: %d\n",
+ 				   port->churn_actor_count);
+ 			seq_printf(seq, "Partner Churned Count: %d\n",
+ 				   port->churn_partner_count);
+ 
+ 			seq_puts(seq, "details actor lacp pdu:\n");
+ 			seq_printf(seq, "    system priority: %d\n",
+ 				   port->actor_system_priority);
+ 			seq_printf(seq, "    port key: %d\n",
+ 				   port->actor_oper_port_key);
+ 			seq_printf(seq, "    port priority: %d\n",
+ 				   port->actor_port_priority);
+ 			seq_printf(seq, "    port number: %d\n",
+ 				   port->actor_port_number);
+ 			seq_printf(seq, "    port state: %d\n",
+ 				   port->actor_oper_port_state);
+ 
+ 			seq_puts(seq, "details partner lacp pdu:\n");
+ 			seq_printf(seq, "    system priority: %d\n",
+ 				   port->partner_oper.system_priority);
+ 			seq_printf(seq, "    oper key: %d\n",
+ 				   port->partner_oper.key);
+ 			seq_printf(seq, "    port priority: %d\n",
+ 				   port->partner_oper.port_priority);
+ 			seq_printf(seq, "    port number: %d\n",
+ 				   port->partner_oper.port_number);
+ 			seq_printf(seq, "    port state: %d\n",
+ 				   port->partner_oper.port_state);
+ 		} else {
  			seq_puts(seq, "Aggregator ID: N/A\n");
+ 		}
  	}
- 	seq_printf(seq, "Slave queue ID: %d\n", slave->queue_id);
  }
  
  static int bond_info_seq_show(struct seq_file *seq, void *v)
* Unmerged path drivers/net/bonding/bond_3ad.c
diff --git a/drivers/net/bonding/bond_3ad.h b/drivers/net/bonding/bond_3ad.h
index 3b97fe487dca..3ed8bda8fe80 100644
--- a/drivers/net/bonding/bond_3ad.h
+++ b/drivers/net/bonding/bond_3ad.h
@@ -82,6 +82,13 @@ typedef enum {
 	AD_TRANSMIT		/* tx Machine */
 } tx_states_t;
 
+/* churn machine states(43.4.17 in the 802.3ad standard) */
+typedef enum {
+	 AD_CHURN_MONITOR, /* monitoring for churn */
+	 AD_CHURN,         /* churn detected (error) */
+	 AD_NO_CHURN       /* no churn (no error) */
+} churn_state_t;
+
 /* rx indication types */
 typedef enum {
 	AD_TYPE_LACPDU = 1,	/* type lacpdu */
@@ -229,6 +236,12 @@ typedef struct port {
 	u16 sm_mux_timer_counter;	/* state machine mux timer counter */
 	tx_states_t sm_tx_state;	/* state machine tx state */
 	u16 sm_tx_timer_counter;	/* state machine tx timer counter(allways on - enter to transmit state 3 time per second) */
+	u16 sm_churn_actor_timer_counter;
+	u16 sm_churn_partner_timer_counter;
+	u32 churn_actor_count;
+	u32 churn_partner_count;
+	churn_state_t sm_churn_actor_state;
+	churn_state_t sm_churn_partner_state;
 	struct slave *slave;		/* pointer to the bond slave that this port belongs to */
 	struct aggregator *aggregator;	/* pointer to an aggregator that this port related to */
 	struct port *next_port_in_aggregator;	/* Next port on the linked list of the parent aggregator */
@@ -262,6 +275,22 @@ struct ad_slave_info {
 	u16 id;
 };
 
+static inline const char *bond_3ad_churn_desc(churn_state_t state)
+{
+	static const char *const churn_description[] = {
+		"monitoring",
+		"churned",
+		"none",
+		"unknown"
+	};
+	int max_size = sizeof(churn_description) / sizeof(churn_description[0]);
+
+	if (state >= max_size)
+		state = max_size - 1;
+
+	return churn_description[state];
+}
+
 /* ========== AD Exported functions to the main bonding code ========== */
 void bond_3ad_initialize(struct bonding *bond, u16 tick_resolution);
 void bond_3ad_bind_slave(struct slave *slave);
* Unmerged path drivers/net/bonding/bond_procfs.c
