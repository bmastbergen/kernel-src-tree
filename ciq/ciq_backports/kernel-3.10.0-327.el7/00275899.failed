xfs: track bulkstat progress by agino

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit 002758992693ae63c04122603ea9261a0a58d728
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/00275899.failed

The bulkstat main loop progress is tracked by the "lastino"
variable, which is a full 64 bit inode. However, the loop actually
works on agno/agino pairs, and so there's a significant disconnect
between the rest of the loop and the main cursor. Convert this to
use the agino, and pass the agino into the chunk formatting function
and convert it too.

This gets rid of the inconsistency in the loop processing, and
finally makes it simple for us to skip inodes at any point in the
loop simply by incrementing the agino cursor.

cc: <stable@vger.kernel.org> # 3.17
	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>
(cherry picked from commit 002758992693ae63c04122603ea9261a0a58d728)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_itable.c
diff --cc fs/xfs/xfs_itable.c
index 00889cf40587,894924a5129b..000000000000
--- a/fs/xfs/xfs_itable.c
+++ b/fs/xfs/xfs_itable.c
@@@ -262,6 -264,80 +262,83 @@@ xfs_bulkstat_grab_ichunk
  
  #define XFS_BULKSTAT_UBLEFT(ubleft)	((ubleft) >= statstruct_size)
  
++<<<<<<< HEAD
++=======
+ struct xfs_bulkstat_agichunk {
+ 	char		__user **ac_ubuffer;/* pointer into user's buffer */
+ 	int		ac_ubleft;	/* bytes left in user's buffer */
+ 	int		ac_ubelem;	/* spaces used in user's buffer */
+ };
+ 
+ /*
+  * Process inodes in chunk with a pointer to a formatter function
+  * that will iget the inode and fill in the appropriate structure.
+  */
+ static int
+ xfs_bulkstat_ag_ichunk(
+ 	struct xfs_mount		*mp,
+ 	xfs_agnumber_t			agno,
+ 	struct xfs_inobt_rec_incore	*irbp,
+ 	bulkstat_one_pf			formatter,
+ 	size_t				statstruct_size,
+ 	struct xfs_bulkstat_agichunk	*acp,
+ 	xfs_agino_t			*last_agino)
+ {
+ 	char				__user **ubufp = acp->ac_ubuffer;
+ 	int				chunkidx;
+ 	int				error = 0;
+ 	xfs_agino_t			agino = irbp->ir_startino;
+ 
+ 	for (chunkidx = 0; chunkidx < XFS_INODES_PER_CHUNK;
+ 	     chunkidx++, agino++) {
+ 		int		fmterror;
+ 		int		ubused;
+ 
+ 		/* inode won't fit in buffer, we are done */
+ 		if (acp->ac_ubleft < statstruct_size)
+ 			break;
+ 
+ 		/* Skip if this inode is free */
+ 		if (XFS_INOBT_MASK(chunkidx) & irbp->ir_free)
+ 			continue;
+ 
+ 		/* Get the inode and fill in a single buffer */
+ 		ubused = statstruct_size;
+ 		error = formatter(mp, XFS_AGINO_TO_INO(mp, agno, agino),
+ 				  *ubufp, acp->ac_ubleft, &ubused, &fmterror);
+ 
+ 		if (fmterror == BULKSTAT_RV_GIVEUP ||
+ 		    (error && error != -ENOENT && error != -EINVAL)) {
+ 			acp->ac_ubleft = 0;
+ 			ASSERT(error);
+ 			break;
+ 		}
+ 
+ 		/* be careful not to leak error if at end of chunk */
+ 		if (fmterror == BULKSTAT_RV_NOTHING || error) {
+ 			error = 0;
+ 			continue;
+ 		}
+ 
+ 		*ubufp += ubused;
+ 		acp->ac_ubleft -= ubused;
+ 		acp->ac_ubelem++;
+ 	}
+ 
+ 	/*
+ 	 * Post-update *last_agino. At this point, agino will always point one
+ 	 * inode past the last inode we processed successfully. Hence we
+ 	 * substract that inode when setting the *last_agino cursor so that we
+ 	 * return the correct cookie to userspace. On the next bulkstat call,
+ 	 * the inode under the lastino cookie will be skipped as we have already
+ 	 * processed it here.
+ 	 */
+ 	*last_agino = agino - 1;
+ 
+ 	return error;
+ }
+ 
++>>>>>>> 002758992693 (xfs: track bulkstat progress by agino)
  /*
   * Return stat information in bulk (by-inode) for the filesystem.
   */
@@@ -279,38 -355,21 +356,48 @@@ xfs_bulkstat
  	xfs_agi_t		*agi;	/* agi header data */
  	xfs_agino_t		agino;	/* inode # in allocation group */
  	xfs_agnumber_t		agno;	/* allocation group number */
 +	int			chunkidx; /* current index into inode chunk */
 +	int			clustidx; /* current index into inode cluster */
  	xfs_btree_cur_t		*cur;	/* btree cursor for ialloc btree */
 +	int			end_of_ag; /* set if we've seen the ag end */
 +	int			error;	/* error code */
 +	int                     fmterror;/* bulkstat formatter result */
 +	int			i;	/* loop index */
 +	int			icount;	/* count of inodes good in irbuf */
  	size_t			irbsize; /* size of irec buffer in bytes */
 +	xfs_ino_t		ino;	/* inode number (filesystem) */
 +	xfs_inobt_rec_incore_t	*irbp;	/* current irec buffer pointer */
  	xfs_inobt_rec_incore_t	*irbuf;	/* start of irec buffer */
++<<<<<<< HEAD
 +	xfs_inobt_rec_incore_t	*irbufend; /* end of good irec buffer entries */
 +	xfs_ino_t		lastino; /* last inode number returned */
++=======
++>>>>>>> 002758992693 (xfs: track bulkstat progress by agino)
  	int			nirbuf;	/* size of irbuf */
 +	int			rval;	/* return value error code */
 +	int			tmp;	/* result value from btree calls */
  	int			ubcount; /* size of user's buffer */
 -	struct xfs_bulkstat_agichunk ac;
 -	int			error = 0;
 +	int			ubleft;	/* bytes left in user's buffer */
 +	char			__user *ubufp;	/* pointer into user's buffer */
 +	int			ubelem;	/* spaces used in user's buffer */
 +	int			ubused;	/* bytes used by formatter */
  
  	/*
  	 * Get the last inode value, see if there's nothing to do.
  	 */
++<<<<<<< HEAD
 +	ino = (xfs_ino_t)*lastinop;
 +	lastino = ino;
 +	agno = XFS_INO_TO_AGNO(mp, ino);
 +	agino = XFS_INO_TO_AGINO(mp, ino);
 +	if (agno >= mp->m_sb.sb_agcount ||
 +	    ino != XFS_AGINO_TO_INO(mp, agno, agino)) {
++=======
+ 	agno = XFS_INO_TO_AGNO(mp, *lastinop);
+ 	agino = XFS_INO_TO_AGINO(mp, *lastinop);
+ 	if (agno >= mp->m_sb.sb_agcount ||
+ 	    *lastinop != XFS_AGINO_TO_INO(mp, agno, agino)) {
++>>>>>>> 002758992693 (xfs: track bulkstat progress by agino)
  		*done = 1;
  		*ubcountp = 0;
  		return 0;
@@@ -365,16 -424,17 +452,15 @@@
  				irbp->ir_freecount = r.ir_freecount;
  				irbp->ir_free = r.ir_free;
  				irbp++;
- 				agino = r.ir_startino + XFS_INODES_PER_CHUNK;
  			}
  			/* Increment to the next record */
 -			error = xfs_btree_increment(cur, 0, &stat);
 +			error = xfs_btree_increment(cur, 0, &tmp);
  		} else {
  			/* Start of ag.  Lookup the first inode chunk */
 -			error = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &stat);
 +			error = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &tmp);
  		}
 -		if (error || stat == 0) {
 -			end_of_ag = true;
 +		if (error)
  			goto del_cursor;
 -		}
  
  		/*
  		 * Loop through inode btree records in this ag,
@@@ -401,13 -461,9 +487,19 @@@
  				irbp++;
  				icount += XFS_INODES_PER_CHUNK - r.ir_freecount;
  			}
++<<<<<<< HEAD
 +			/*
 +			 * Set agino to after this chunk and bump the cursor.
 +			 */
 +			agino = r.ir_startino + XFS_INODES_PER_CHUNK;
 +			error = xfs_btree_increment(cur, 0, &tmp);
 +			if (error) {
 +				end_of_ag = 1;
++=======
+ 			error = xfs_btree_increment(cur, 0, &stat);
+ 			if (error || stat == 0) {
+ 				end_of_ag = true;
++>>>>>>> 002758992693 (xfs: track bulkstat progress by agino)
  				goto del_cursor;
  			}
  			cond_resched();
@@@ -428,143 -486,54 +522,173 @@@ del_cursor
  		 */
  		irbufend = irbp;
  		for (irbp = irbuf;
++<<<<<<< HEAD
 +		     irbp < irbufend && XFS_BULKSTAT_UBLEFT(ubleft); irbp++) {
 +			/*
 +			 * Now process this chunk of inodes.
 +			 */
 +			for (agino = irbp->ir_startino, chunkidx = clustidx = 0;
 +			     XFS_BULKSTAT_UBLEFT(ubleft) &&
 +				irbp->ir_freecount < XFS_INODES_PER_CHUNK;
 +			     chunkidx++, clustidx++, agino++) {
 +				ASSERT(chunkidx < XFS_INODES_PER_CHUNK);
 +
 +				ino = XFS_AGINO_TO_INO(mp, agno, agino);
 +				/*
 +				 * Skip if this inode is free.
 +				 */
 +				if (XFS_INOBT_MASK(chunkidx) & irbp->ir_free) {
 +					lastino = ino;
 +					continue;
 +				}
 +				/*
 +				 * Count used inodes as free so we can tell
 +				 * when the chunk is used up.
 +				 */
 +				irbp->ir_freecount++;
 +
 +				/*
 +				 * Get the inode and fill in a single buffer.
 +				 */
 +				ubused = statstruct_size;
 +				error = formatter(mp, ino, ubufp, ubleft,
 +						  &ubused, &fmterror);
 +				if (fmterror == BULKSTAT_RV_NOTHING) {
 +					if (error && error != ENOENT &&
 +						error != EINVAL) {
 +						ubleft = 0;
 +						rval = error;
 +						break;
 +					}
 +					lastino = ino;
 +					continue;
 +				}
 +				if (fmterror == BULKSTAT_RV_GIVEUP) {
 +					ubleft = 0;
 +					ASSERT(error);
 +					rval = error;
 +					break;
 +				}
 +				if (ubufp)
 +					ubufp += ubused;
 +				ubleft -= ubused;
 +				ubelem++;
 +				lastino = ino;
 +			}
++=======
+ 		     irbp < irbufend && ac.ac_ubleft >= statstruct_size;
+ 		     irbp++) {
+ 			error = xfs_bulkstat_ag_ichunk(mp, agno, irbp,
+ 					formatter, statstruct_size, &ac,
+ 					&agino);
+ 			if (error)
+ 				break;
++>>>>>>> 002758992693 (xfs: track bulkstat progress by agino)
  
  			cond_resched();
  		}
 -
  		/*
 -		 * If we've run out of space or had a formatting error, we
 -		 * are now done
 +		 * Set up for the next loop iteration.
  		 */
++<<<<<<< HEAD
 +		if (XFS_BULKSTAT_UBLEFT(ubleft)) {
 +			if (end_of_ag) {
 +				agno++;
 +				agino = 0;
 +			} else
 +				agino = XFS_INO_TO_AGINO(mp, lastino);
 +		} else
 +			break;
++=======
+ 		if (ac.ac_ubleft < statstruct_size || error)
+ 			break;
+ 
+ 		if (end_of_ag) {
+ 			agno++;
+ 			agino = 0;
+ 		}
++>>>>>>> 002758992693 (xfs: track bulkstat progress by agino)
  	}
  	/*
  	 * Done, we're either out of filesystem or space to put the data.
  	 */
  	kmem_free(irbuf);
 -	*ubcountp = ac.ac_ubelem;
 -
 +	*ubcountp = ubelem;
  	/*
 -	 * We found some inodes, so clear the error status and return them.
 -	 * The lastino pointer will point directly at the inode that triggered
 -	 * any error that occurred, so on the next call the error will be
 -	 * triggered again and propagated to userspace as there will be no
 -	 * formatted inodes in the buffer.
 +	 * Found some inodes, return them now and return the error next time.
  	 */
++<<<<<<< HEAD
 +	if (ubelem)
 +		rval = 0;
 +	if (agno >= mp->m_sb.sb_agcount) {
 +		/*
 +		 * If we ran out of filesystem, mark lastino as off
 +		 * the end of the filesystem, so the next call
 +		 * will return immediately.
 +		 */
 +		*lastinop = (xfs_ino_t)XFS_AGINO_TO_INO(mp, agno, 0);
++=======
+ 	if (ac.ac_ubelem)
+ 		error = 0;
+ 
+ 	/*
+ 	 * If we ran out of filesystem, lastino will point off the end of
+ 	 * the filesystem so the next call will return immediately.
+ 	 */
+ 	*lastinop = XFS_AGINO_TO_INO(mp, agno, agino);
+ 	if (agno >= mp->m_sb.sb_agcount)
++>>>>>>> 002758992693 (xfs: track bulkstat progress by agino)
  		*done = 1;
- 	} else
- 		*lastinop = (xfs_ino_t)lastino;
  
 -	return error;
 +	return rval;
 +}
 +
 +/*
 + * Return stat information in bulk (by-inode) for the filesystem.
 + * Special case for non-sequential one inode bulkstat.
 + */
 +int					/* error status */
 +xfs_bulkstat_single(
 +	xfs_mount_t		*mp,	/* mount point for filesystem */
 +	xfs_ino_t		*lastinop, /* inode to return */
 +	char			__user *buffer, /* buffer with inode stats */
 +	int			*done)	/* 1 if there are more stats to get */
 +{
 +	int			count;	/* count value for bulkstat call */
 +	int			error;	/* return value */
 +	xfs_ino_t		ino;	/* filesystem inode number */
 +	int			res;	/* result from bs1 */
 +
 +	/*
 +	 * note that requesting valid inode numbers which are not allocated
 +	 * to inodes will most likely cause xfs_imap_to_bp to generate warning
 +	 * messages about bad magic numbers. This is ok. The fact that
 +	 * the inode isn't actually an inode is handled by the
 +	 * error check below. Done this way to make the usual case faster
 +	 * at the expense of the error case.
 +	 */
 +
 +	ino = *lastinop;
 +	error = xfs_bulkstat_one(mp, ino, buffer, sizeof(xfs_bstat_t),
 +				 NULL, &res);
 +	if (error) {
 +		/*
 +		 * Special case way failed, do it the "long" way
 +		 * to see if that works.
 +		 */
 +		(*lastinop)--;
 +		count = 1;
 +		if (xfs_bulkstat(mp, lastinop, &count, xfs_bulkstat_one,
 +				sizeof(xfs_bstat_t), buffer, done))
 +			return error;
 +		if (count == 0 || (xfs_ino_t)*lastinop != ino)
 +			return error == EFSCORRUPTED ?
 +				XFS_ERROR(EINVAL) : error;
 +		else
 +			return 0;
 +	}
 +	*done = 0;
 +	return 0;
  }
  
  int
* Unmerged path fs/xfs/xfs_itable.c
