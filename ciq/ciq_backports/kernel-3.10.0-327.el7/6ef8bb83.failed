IB/iser: Pass struct iser_mem_reg to iser_fast_reg_mr and iser_reg_sig_mr

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [infiniband] iser: Pass struct iser_mem_reg to iser_fast_reg_mr and iser_reg_sig_mr (Amir Vadai) [1164539]
Rebuild_FUZZ: 97.90%
commit-author Sagi Grimberg <sagig@mellanox.com>
commit 6ef8bb837dd7e60f078084d4842a43fd163fb4a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/6ef8bb83.failed

Instead of passing ib_sge as output variable, we pass the mem_reg
pointer to have the routines fill the rkey as well. This reduces
code duplication and extra assignments. This is a preparation step
to unify some registration logics together. Also, pass iser_fast_reg_mr
the fastreg descriptor directly.

This patch does not change any functionality.

	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Adir Lev <adirl@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 6ef8bb837dd7e60f078084d4842a43fd163fb4a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/iser/iser_memory.c
diff --cc drivers/infiniband/ulp/iser/iser_memory.c
index f40132fc970c,0575052d9f8f..000000000000
--- a/drivers/infiniband/ulp/iser/iser_memory.c
+++ b/drivers/infiniband/ulp/iser/iser_memory.c
@@@ -541,10 -590,12 +541,12 @@@ iser_inv_rkey(struct ib_send_wr *inv_wr
  
  static int
  iser_reg_sig_mr(struct iscsi_iser_task *iser_task,
- 		struct fast_reg_descriptor *desc, struct ib_sge *data_sge,
- 		struct ib_sge *prot_sge, struct ib_sge *sig_sge)
+ 		struct fast_reg_descriptor *desc,
+ 		struct iser_mem_reg *data_reg,
+ 		struct iser_mem_reg *prot_reg,
+ 		struct iser_mem_reg *sig_reg)
  {
 -	struct ib_conn *ib_conn = &iser_task->iser_conn->ib_conn;
 +	struct iser_conn *ib_conn = iser_task->ib_conn;
  	struct iser_pi_context *pi_ctx = desc->pi_ctx;
  	struct ib_send_wr sig_wr, inv_wr;
  	struct ib_send_wr *bad_wr, *wr = NULL;
@@@ -590,30 -639,25 +592,45 @@@
  	}
  	desc->reg_indicators &= ~ISER_SIG_KEY_VALID;
  
++<<<<<<< HEAD
 +	sig_sge->lkey = pi_ctx->sig_mr->lkey;
 +	sig_sge->addr = 0;
 +	sig_sge->length = data_sge->length + prot_sge->length;
 +	if (scsi_get_prot_op(iser_task->sc) == SCSI_PROT_WRITE_INSERT ||
 +	    scsi_get_prot_op(iser_task->sc) == SCSI_PROT_READ_STRIP) {
 +		sig_sge->length += (data_sge->length /
 +				   iser_task->sc->device->sector_size) * 8;
 +	}
- 
- 	iser_dbg("sig_sge: addr: 0x%llx  length: %u lkey: 0x%x\n",
- 		 sig_sge->addr, sig_sge->length,
- 		 sig_sge->lkey);
++=======
+ 	sig_reg->sge.lkey = pi_ctx->sig_mr->lkey;
+ 	sig_reg->rkey = pi_ctx->sig_mr->rkey;
+ 	sig_reg->sge.addr = 0;
+ 	sig_reg->sge.length = scsi_transfer_length(iser_task->sc);
++>>>>>>> 6ef8bb837dd7 (IB/iser: Pass struct iser_mem_reg to iser_fast_reg_mr and iser_reg_sig_mr)
+ 
+ 	iser_dbg("sig_sge: lkey: 0x%x, rkey: 0x%x, addr: 0x%llx, length: %u\n",
+ 		 sig_reg->sge.lkey, sig_reg->rkey, sig_reg->sge.addr,
+ 		 sig_reg->sge.length);
  err:
  	return ret;
  }
  
  static int iser_fast_reg_mr(struct iscsi_iser_task *iser_task,
++<<<<<<< HEAD
 +			    struct iser_regd_buf *regd_buf,
++=======
++>>>>>>> 6ef8bb837dd7 (IB/iser: Pass struct iser_mem_reg to iser_fast_reg_mr and iser_reg_sig_mr)
  			    struct iser_data_buf *mem,
+ 			    struct fast_reg_descriptor *desc,
  			    enum iser_reg_indicator ind,
- 			    struct ib_sge *sge)
+ 			    struct iser_mem_reg *reg)
  {
++<<<<<<< HEAD
 +	struct fast_reg_descriptor *desc = regd_buf->reg.mem_h;
 +	struct iser_conn *ib_conn = iser_task->ib_conn;
++=======
+ 	struct ib_conn *ib_conn = &iser_task->iser_conn->ib_conn;
++>>>>>>> 6ef8bb837dd7 (IB/iser: Pass struct iser_mem_reg to iser_fast_reg_mr and iser_reg_sig_mr)
  	struct iser_device *device = ib_conn->device;
  	struct ib_device *ibdev = device->ib_device;
  	struct ib_mr *mr;
@@@ -624,14 -668,15 +641,15 @@@
  
  	/* if there a single dma entry, dma mr suffices */
  	if (mem->dma_nents == 1) {
 -		struct scatterlist *sg = mem->sg;
 +		struct scatterlist *sg = (struct scatterlist *)mem->buf;
  
- 		sge->lkey = device->mr->lkey;
- 		sge->addr   = ib_sg_dma_address(ibdev, &sg[0]);
- 		sge->length  = ib_sg_dma_len(ibdev, &sg[0]);
+ 		reg->sge.lkey = device->mr->lkey;
+ 		reg->rkey = device->mr->rkey;
+ 		reg->sge.addr = ib_sg_dma_address(ibdev, &sg[0]);
+ 		reg->sge.length = ib_sg_dma_len(ibdev, &sg[0]);
  
  		iser_dbg("Single DMA entry: lkey=0x%x, addr=0x%llx, length=0x%x\n",
- 			 sge->lkey, sge->addr, sge->length);
+ 			 reg->sge.lkey, reg->sge.addr, reg->sge.length);
  		return 0;
  	}
  
@@@ -701,11 -747,9 +720,10 @@@ int iser_reg_rdma_mem_fastreg(struct is
  	struct iser_device *device = ib_conn->device;
  	struct ib_device *ibdev = device->ib_device;
  	struct iser_data_buf *mem = &iser_task->data[cmd_dir];
 -	struct iser_mem_reg *mem_reg = &iser_task->rdma_reg[cmd_dir];
 +	struct iser_regd_buf *regd_buf = &iser_task->rdma_regd[cmd_dir];
  	struct fast_reg_descriptor *desc = NULL;
- 	struct ib_sge data_sge;
  	int err, aligned_len;
 +	unsigned long flags;
  
  	aligned_len = iser_data_buf_aligned_len(mem, ibdev);
  	if (aligned_len != mem->dma_nents) {
@@@ -721,16 -763,12 +739,21 @@@
  
  	if (mem->dma_nents != 1 ||
  	    scsi_get_prot_op(iser_task->sc) != SCSI_PROT_NORMAL) {
 -		desc = iser_reg_desc_get(ib_conn);
 -		mem_reg->mem_h = desc;
 +		spin_lock_irqsave(&ib_conn->lock, flags);
 +		desc = list_first_entry(&ib_conn->fastreg.pool,
 +					struct fast_reg_descriptor, list);
 +		list_del(&desc->list);
 +		spin_unlock_irqrestore(&ib_conn->lock, flags);
 +		regd_buf->reg.mem_h = desc;
  	}
  
++<<<<<<< HEAD
 +	err = iser_fast_reg_mr(iser_task, regd_buf, mem,
 +			       ISER_DATA_KEY_VALID, &data_sge);
++=======
+ 	err = iser_fast_reg_mr(iser_task, mem, desc,
+ 			       ISER_DATA_KEY_VALID, mem_reg);
++>>>>>>> 6ef8bb837dd7 (IB/iser: Pass struct iser_mem_reg to iser_fast_reg_mr and iser_reg_sig_mr)
  	if (err)
  		goto err_reg;
  
@@@ -749,11 -786,10 +772,16 @@@
  					iser_err("failed to allocate bounce buffer\n");
  					return err;
  				}
 +				mem = &iser_task->prot_copy[cmd_dir];
  			}
  
++<<<<<<< HEAD
 +			err = iser_fast_reg_mr(iser_task, regd_buf, mem,
 +					       ISER_PROT_KEY_VALID, &prot_sge);
++=======
+ 			err = iser_fast_reg_mr(iser_task, mem, desc,
+ 					       ISER_PROT_KEY_VALID, &prot_reg);
++>>>>>>> 6ef8bb837dd7 (IB/iser: Pass struct iser_mem_reg to iser_fast_reg_mr and iser_reg_sig_mr)
  			if (err)
  				goto err_reg;
  		}
@@@ -765,24 -801,6 +793,27 @@@
  			return err;
  		}
  		desc->reg_indicators |= ISER_FASTREG_PROTECTED;
++<<<<<<< HEAD
 +
 +		regd_buf->reg.lkey = sig_sge.lkey;
 +		regd_buf->reg.rkey = desc->pi_ctx->sig_mr->rkey;
 +		regd_buf->reg.va = sig_sge.addr;
 +		regd_buf->reg.len = sig_sge.length;
 +		regd_buf->reg.is_mr = 1;
 +	} else {
 +		if (desc) {
 +			regd_buf->reg.rkey = desc->data_mr->rkey;
 +			regd_buf->reg.is_mr = 1;
 +		} else {
 +			regd_buf->reg.rkey = device->mr->rkey;
 +			regd_buf->reg.is_mr = 0;
 +		}
 +
 +		regd_buf->reg.lkey = data_sge.lkey;
 +		regd_buf->reg.va = data_sge.addr;
 +		regd_buf->reg.len = data_sge.length;
++=======
++>>>>>>> 6ef8bb837dd7 (IB/iser: Pass struct iser_mem_reg to iser_fast_reg_mr and iser_reg_sig_mr)
  	}
  
  	return 0;
* Unmerged path drivers/infiniband/ulp/iser/iser_memory.c
