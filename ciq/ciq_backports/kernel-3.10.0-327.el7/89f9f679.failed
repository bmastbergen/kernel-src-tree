hv: vmbus_post_msg: retry the hypercall on some transient errors

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [hv] vmbus_post_msg: retry the hypercall on some transient errors (Vitaly Kuznetsov) [1211914]
Rebuild_FUZZ: 96.77%
commit-author Dexuan Cui <decui@microsoft.com>
commit 89f9f6796d41e10e224b0cb0027ddd78cb881f65
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/89f9f679.failed

I got HV_STATUS_INVALID_CONNECTION_ID on Hyper-V 2008 R2 when keeping running
"rmmod hv_netvsc; modprobe hv_netvsc; rmmod hv_utils; modprobe hv_utils"
in a Linux guest. Looks the host has some kind of throttling mechanism if
some kinds of hypercalls are sent too frequently.
Without the patch, the driver can occasionally fail to load.

Also let's retry HV_STATUS_INSUFFICIENT_MEMORY, though we didn't get it
before.

Removed 'case -ENOMEM', since the hypervisor doesn't return this.

CC: "K. Y. Srinivasan" <kys@microsoft.com>
	Reviewed-by: Jason Wang <jasowang@redhat.com>
	Signed-off-by: Dexuan Cui <decui@microsoft.com>
	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 89f9f6796d41e10e224b0cb0027ddd78cb881f65)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/connection.c
diff --cc drivers/hv/connection.c
index cad8295c2bdf,af2388fdc6b9..000000000000
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@@ -428,12 -436,30 +428,31 @@@ int vmbus_post_msg(void *buffer, size_
  	 * insufficient resources. Retry the operation a couple of
  	 * times before giving up.
  	 */
++<<<<<<< HEAD
 +	while (retries < 3) {
 +		ret =  hv_post_message(conn_id, 1, buffer, buflen);
 +		if (ret != HV_STATUS_INSUFFICIENT_BUFFERS)
++=======
+ 	while (retries < 10) {
+ 		ret = hv_post_message(conn_id, 1, buffer, buflen);
+ 
+ 		switch (ret) {
+ 		case HV_STATUS_INVALID_CONNECTION_ID:
+ 			/*
+ 			 * We could get this if we send messages too
+ 			 * frequently.
+ 			 */
+ 			ret = -EAGAIN;
+ 			break;
+ 		case HV_STATUS_INSUFFICIENT_MEMORY:
+ 		case HV_STATUS_INSUFFICIENT_BUFFERS:
+ 			ret = -ENOMEM;
+ 			break;
+ 		case HV_STATUS_SUCCESS:
++>>>>>>> 89f9f6796d41 (hv: vmbus_post_msg: retry the hypercall on some transient errors)
  			return ret;
 -		default:
 -			pr_err("hv_post_msg() failed; error code:%d\n", ret);
 -			return -EINVAL;
 -		}
 -
  		retries++;
- 		msleep(100);
+ 		msleep(1000);
  	}
  	return ret;
  }
diff --git a/arch/x86/include/uapi/asm/hyperv.h b/arch/x86/include/uapi/asm/hyperv.h
index 462efe746d77..7c6634dd42c6 100644
--- a/arch/x86/include/uapi/asm/hyperv.h
+++ b/arch/x86/include/uapi/asm/hyperv.h
@@ -214,6 +214,8 @@
 #define HV_STATUS_INVALID_HYPERCALL_CODE	2
 #define HV_STATUS_INVALID_HYPERCALL_INPUT	3
 #define HV_STATUS_INVALID_ALIGNMENT		4
+#define HV_STATUS_INSUFFICIENT_MEMORY		11
+#define HV_STATUS_INVALID_CONNECTION_ID		18
 #define HV_STATUS_INSUFFICIENT_BUFFERS		19
 
 typedef struct _HV_REFERENCE_TSC_PAGE {
* Unmerged path drivers/hv/connection.c
