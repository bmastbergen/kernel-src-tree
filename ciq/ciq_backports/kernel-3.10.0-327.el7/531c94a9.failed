tcp: don't include Fast Open option in SYN-ACK on pure SYN-data

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Yuchung Cheng <ycheng@google.com>
commit 531c94a9681b8c253fd0490a4ca8bbe01a38c78b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/531c94a9.failed

If a server has enabled Fast Open and it receives a pure SYN-data
packet (without a Fast Open option), it won't accept the data but it
incorrectly returns a SYN-ACK with a Fast Open cookie and also
increments the SNMP stat LINUX_MIB_TCPFASTOPENPASSIVEFAIL.

This patch makes the server include a Fast Open cookie in SYN-ACK
only if the SYN has some Fast Open option (i.e., when client
requests or presents a cookie).

	Signed-off-by: Yuchung Cheng <ycheng@google.com>
	Acked-by: Neal Cardwell <ncardwell@google.com>
	Acked-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 531c94a9681b8c253fd0490a4ca8bbe01a38c78b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_fastopen.c
diff --cc net/ipv4/tcp_fastopen.c
index ab7bd35bb312,53db2c309572..000000000000
--- a/net/ipv4/tcp_fastopen.c
+++ b/net/ipv4/tcp_fastopen.c
@@@ -73,19 -83,216 +73,192 @@@ void tcp_fastopen_cookie_gen(__be32 src
  	rcu_read_lock();
  	ctx = rcu_dereference(tcp_fastopen_ctx);
  	if (ctx) {
 -		crypto_cipher_encrypt_one(ctx->tfm, foc->val, path);
 +		crypto_cipher_encrypt_one(ctx->tfm, foc->val, (__u8 *)path);
  		foc->len = TCP_FASTOPEN_COOKIE_SIZE;
 -		ok = true;
  	}
  	rcu_read_unlock();
 -	return ok;
  }
  
 -/* Generate the fastopen cookie by doing aes128 encryption on both
 - * the source and destination addresses. Pad 0s for IPv4 or IPv4-mapped-IPv6
 - * addresses. For the longer IPv6 addresses use CBC-MAC.
 - *
 - * XXX (TFO) - refactor when TCP_FASTOPEN_COOKIE_SIZE != AES_BLOCK_SIZE.
 - */
 -static bool tcp_fastopen_cookie_gen(struct request_sock *req,
 -				    struct sk_buff *syn,
 -				    struct tcp_fastopen_cookie *foc)
 +static int __init tcp_fastopen_init(void)
  {
 -	if (req->rsk_ops->family == AF_INET) {
 -		const struct iphdr *iph = ip_hdr(syn);
 -
 -		__be32 path[4] = { iph->saddr, iph->daddr, 0, 0 };
 -		return __tcp_fastopen_cookie_gen(path, foc);
 -	}
 -
 -#if IS_ENABLED(CONFIG_IPV6)
 -	if (req->rsk_ops->family == AF_INET6) {
 -		const struct ipv6hdr *ip6h = ipv6_hdr(syn);
 -		struct tcp_fastopen_cookie tmp;
 +	__u8 key[TCP_FASTOPEN_KEY_LENGTH];
  
 -		if (__tcp_fastopen_cookie_gen(&ip6h->saddr, &tmp)) {
 -			struct in6_addr *buf = (struct in6_addr *) tmp.val;
 -			int i;
 -
 -			for (i = 0; i < 4; i++)
 -				buf->s6_addr32[i] ^= ip6h->daddr.s6_addr32[i];
 -			return __tcp_fastopen_cookie_gen(buf, foc);
 -		}
 -	}
 -#endif
 -	return false;
 +	get_random_bytes(key, sizeof(key));
 +	tcp_fastopen_reset_cipher(key, sizeof(key));
 +	return 0;
  }
  
++<<<<<<< HEAD
 +late_initcall(tcp_fastopen_init);
++=======
+ static bool tcp_fastopen_create_child(struct sock *sk,
+ 				      struct sk_buff *skb,
+ 				      struct dst_entry *dst,
+ 				      struct request_sock *req)
+ {
+ 	struct tcp_sock *tp;
+ 	struct request_sock_queue *queue = &inet_csk(sk)->icsk_accept_queue;
+ 	struct sock *child;
+ 
+ 	req->num_retrans = 0;
+ 	req->num_timeout = 0;
+ 	req->sk = NULL;
+ 
+ 	child = inet_csk(sk)->icsk_af_ops->syn_recv_sock(sk, skb, req, NULL);
+ 	if (child == NULL)
+ 		return false;
+ 
+ 	spin_lock(&queue->fastopenq->lock);
+ 	queue->fastopenq->qlen++;
+ 	spin_unlock(&queue->fastopenq->lock);
+ 
+ 	/* Initialize the child socket. Have to fix some values to take
+ 	 * into account the child is a Fast Open socket and is created
+ 	 * only out of the bits carried in the SYN packet.
+ 	 */
+ 	tp = tcp_sk(child);
+ 
+ 	tp->fastopen_rsk = req;
+ 	/* Do a hold on the listner sk so that if the listener is being
+ 	 * closed, the child that has been accepted can live on and still
+ 	 * access listen_lock.
+ 	 */
+ 	sock_hold(sk);
+ 	tcp_rsk(req)->listener = sk;
+ 
+ 	/* RFC1323: The window in SYN & SYN/ACK segments is never
+ 	 * scaled. So correct it appropriately.
+ 	 */
+ 	tp->snd_wnd = ntohs(tcp_hdr(skb)->window);
+ 
+ 	/* Activate the retrans timer so that SYNACK can be retransmitted.
+ 	 * The request socket is not added to the SYN table of the parent
+ 	 * because it's been added to the accept queue directly.
+ 	 */
+ 	inet_csk_reset_xmit_timer(child, ICSK_TIME_RETRANS,
+ 				  TCP_TIMEOUT_INIT, TCP_RTO_MAX);
+ 
+ 	/* Add the child socket directly into the accept queue */
+ 	inet_csk_reqsk_queue_add(sk, req, child);
+ 
+ 	/* Now finish processing the fastopen child socket. */
+ 	inet_csk(child)->icsk_af_ops->rebuild_header(child);
+ 	tcp_init_congestion_control(child);
+ 	tcp_mtup_init(child);
+ 	tcp_init_metrics(child);
+ 	tcp_init_buffer_space(child);
+ 
+ 	/* Queue the data carried in the SYN packet. We need to first
+ 	 * bump skb's refcnt because the caller will attempt to free it.
+ 	 *
+ 	 * XXX (TFO) - we honor a zero-payload TFO request for now,
+ 	 * (any reason not to?) but no need to queue the skb since
+ 	 * there is no data. How about SYN+FIN?
+ 	 */
+ 	if (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq + 1) {
+ 		skb = skb_get(skb);
+ 		skb_dst_drop(skb);
+ 		__skb_pull(skb, tcp_hdr(skb)->doff * 4);
+ 		skb_set_owner_r(skb, child);
+ 		__skb_queue_tail(&child->sk_receive_queue, skb);
+ 		tp->syn_data_acked = 1;
+ 	}
+ 	tcp_rsk(req)->rcv_nxt = tp->rcv_nxt = TCP_SKB_CB(skb)->end_seq;
+ 	sk->sk_data_ready(sk);
+ 	bh_unlock_sock(child);
+ 	sock_put(child);
+ 	WARN_ON(req->sk == NULL);
+ 	return true;
+ }
+ EXPORT_SYMBOL(tcp_fastopen_create_child);
+ 
+ static bool tcp_fastopen_queue_check(struct sock *sk)
+ {
+ 	struct fastopen_queue *fastopenq;
+ 
+ 	/* Make sure the listener has enabled fastopen, and we don't
+ 	 * exceed the max # of pending TFO requests allowed before trying
+ 	 * to validating the cookie in order to avoid burning CPU cycles
+ 	 * unnecessarily.
+ 	 *
+ 	 * XXX (TFO) - The implication of checking the max_qlen before
+ 	 * processing a cookie request is that clients can't differentiate
+ 	 * between qlen overflow causing Fast Open to be disabled
+ 	 * temporarily vs a server not supporting Fast Open at all.
+ 	 */
+ 	fastopenq = inet_csk(sk)->icsk_accept_queue.fastopenq;
+ 	if (fastopenq == NULL || fastopenq->max_qlen == 0)
+ 		return false;
+ 
+ 	if (fastopenq->qlen >= fastopenq->max_qlen) {
+ 		struct request_sock *req1;
+ 		spin_lock(&fastopenq->lock);
+ 		req1 = fastopenq->rskq_rst_head;
+ 		if ((req1 == NULL) || time_after(req1->expires, jiffies)) {
+ 			spin_unlock(&fastopenq->lock);
+ 			NET_INC_STATS_BH(sock_net(sk),
+ 					 LINUX_MIB_TCPFASTOPENLISTENOVERFLOW);
+ 			return false;
+ 		}
+ 		fastopenq->rskq_rst_head = req1->dl_next;
+ 		fastopenq->qlen--;
+ 		spin_unlock(&fastopenq->lock);
+ 		reqsk_free(req1);
+ 	}
+ 	return true;
+ }
+ 
+ /* Returns true if we should perform Fast Open on the SYN. The cookie (foc)
+  * may be updated and return the client in the SYN-ACK later. E.g., Fast Open
+  * cookie request (foc->len == 0).
+  */
+ bool tcp_try_fastopen(struct sock *sk, struct sk_buff *skb,
+ 		      struct request_sock *req,
+ 		      struct tcp_fastopen_cookie *foc,
+ 		      struct dst_entry *dst)
+ {
+ 	struct tcp_fastopen_cookie valid_foc = { .len = -1 };
+ 	bool syn_data = TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq + 1;
+ 
+ 	if (foc->len == 0) /* Client requests a cookie */
+ 		NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPFASTOPENCOOKIEREQD);
+ 
+ 	if (!((sysctl_tcp_fastopen & TFO_SERVER_ENABLE) &&
+ 	      (syn_data || foc->len >= 0) &&
+ 	      tcp_fastopen_queue_check(sk))) {
+ 		foc->len = -1;
+ 		return false;
+ 	}
+ 
+ 	if (syn_data && (sysctl_tcp_fastopen & TFO_SERVER_COOKIE_NOT_REQD))
+ 		goto fastopen;
+ 
+ 	if (foc->len >= 0 &&  /* Client presents or requests a cookie */
+ 	    tcp_fastopen_cookie_gen(req, skb, &valid_foc) &&
+ 	    foc->len == TCP_FASTOPEN_COOKIE_SIZE &&
+ 	    foc->len == valid_foc.len &&
+ 	    !memcmp(foc->val, valid_foc.val, foc->len)) {
+ 		/* Cookie is valid. Create a (full) child socket to accept
+ 		 * the data in SYN before returning a SYN-ACK to ack the
+ 		 * data. If we fail to create the socket, fall back and
+ 		 * ack the ISN only but includes the same cookie.
+ 		 *
+ 		 * Note: Data-less SYN with valid cookie is allowed to send
+ 		 * data in SYN_RECV state.
+ 		 */
+ fastopen:
+ 		if (tcp_fastopen_create_child(sk, skb, dst, req)) {
+ 			foc->len = -1;
+ 			NET_INC_STATS_BH(sock_net(sk),
+ 					 LINUX_MIB_TCPFASTOPENPASSIVE);
+ 			return true;
+ 		}
+ 		NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPFASTOPENPASSIVEFAIL);
+ 	} else if (foc->len > 0) /* Client presents an invalid cookie */
+ 		NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPFASTOPENPASSIVEFAIL);
+ 
+ 	*foc = valid_foc;
+ 	return false;
+ }
+ EXPORT_SYMBOL(tcp_try_fastopen);
++>>>>>>> 531c94a9681b (tcp: don't include Fast Open option in SYN-ACK on pure SYN-data)
* Unmerged path net/ipv4/tcp_fastopen.c
