fib_trie: Add key vector to root, return parent key_vector in resize

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Alexander Duyck <alexander.h.duyck@redhat.com>
commit 88bae7149a5e980dc5a7488fba2fcb41286fd82e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/88bae714.failed

This change makes it so that the root of the trie contains a key_vector, by
doing this we make room to essentially collapse the entire trie by at least
one cache line as we can store the information about the tnode or leaf that
is pointed to in the root.

	Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 88bae7149a5e980dc5a7488fba2fcb41286fd82e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/fib_trie.c
diff --cc net/ipv4/fib_trie.c
index 8be89b1a8b93,90955455884e..000000000000
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@@ -88,27 -89,20 +88,28 @@@
  
  typedef unsigned int t_key;
  
- #define IS_TNODE(n) ((n)->bits)
- #define IS_LEAF(n) (!(n)->bits)
+ #define IS_TRIE(n)	((n)->pos >= KEYLENGTH)
+ #define IS_TNODE(n)	((n)->bits)
+ #define IS_LEAF(n)	(!(n)->bits)
  
 -struct key_vector {
 +#define get_index(_key, _kv) (((_key) ^ (_kv)->key) >> (_kv)->pos)
 +
 +struct tnode {
  	t_key key;
 -	unsigned char pos;		/* 2log(KEYLENGTH) bits needed */
  	unsigned char bits;		/* 2log(KEYLENGTH) bits needed */
 +	unsigned char pos;		/* 2log(KEYLENGTH) bits needed */
  	unsigned char slen;
 +	struct tnode __rcu *parent;
 +	struct rcu_head rcu;
  	union {
 -		/* This list pointer if valid if (pos | bits) == 0 (LEAF) */
 -		struct hlist_head leaf;
 -		/* This array is valid if (pos | bits) > 0 (TNODE) */
 -		struct key_vector __rcu *tnode[0];
 +		/* The fields in this struct are valid if bits > 0 (TNODE) */
 +		struct {
 +			t_key empty_children; /* KEYLENGTH bits needed */
 +			t_key full_children;  /* KEYLENGTH bits needed */
 +			struct tnode __rcu *child[0];
 +		};
 +		/* This list pointer if valid if bits == 0 (LEAF) */
 +		struct hlist_head list;
  	};
  };
  
@@@ -142,13 -140,13 +143,21 @@@ struct trie_stat 
  };
  
  struct trie {
++<<<<<<< HEAD
 +	struct tnode __rcu *trie;
++=======
+ 	struct key_vector kv[1];
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  #ifdef CONFIG_IP_FIB_TRIE_STATS
  	struct trie_use_stats __percpu *stats;
  #endif
  };
  
++<<<<<<< HEAD
 +static void resize(struct trie *t, struct tnode *tn);
++=======
+ static struct key_vector *resize(struct trie *t, struct key_vector *tn);
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  static size_t tnode_free_size;
  
  /*
@@@ -184,18 -189,16 +193,31 @@@ static inline unsigned long tnode_child
  	return (1ul << tn->bits) & ~(1ul);
  }
  
++<<<<<<< HEAD
 +/* caller must hold RTNL */
 +static inline struct tnode *tnode_get_child(const struct tnode *tn,
 +					    unsigned long i)
++=======
+ #define get_cindex(key, kv) (((key) ^ (kv)->key) >> (kv)->pos)
+ 
+ static inline unsigned long get_index(t_key key, struct key_vector *kv)
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  {
 -	unsigned long index = key ^ kv->key;
 +	return rtnl_dereference(tn->child[i]);
 +}
  
++<<<<<<< HEAD
 +/* caller must hold RCU read lock or RTNL */
 +static inline struct tnode *tnode_get_child_rcu(const struct tnode *tn,
 +						unsigned long i)
 +{
 +	return rcu_dereference_rtnl(tn->child[i]);
++=======
+ 	if ((BITS_PER_LONG <= KEYLENGTH) && (KEYLENGTH == kv->pos))
+ 		return 0;
+ 
+ 	return index >> kv->pos;
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  }
  
  /* To understand this stuff, an understanding of keys and all their bits is
@@@ -431,29 -433,30 +453,38 @@@ static void update_children(struct tnod
  	}
  }
  
++<<<<<<< HEAD
 +static inline void put_child_root(struct tnode *tp, struct trie *t,
 +				  t_key key, struct tnode *n)
++=======
+ static inline void put_child_root(struct key_vector *tp, t_key key,
+ 				  struct key_vector *n)
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  {
- 	if (tp)
- 		put_child(tp, get_index(key, tp), n);
+ 	if (IS_TRIE(tp))
+ 		rcu_assign_pointer(tp->tnode[0], n);
  	else
++<<<<<<< HEAD
 +		rcu_assign_pointer(t->trie, n);
++=======
+ 		put_child(tp, get_index(key, tp), n);
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  }
  
 -static inline void tnode_free_init(struct key_vector *tn)
 +static inline void tnode_free_init(struct tnode *tn)
  {
 -	tn_info(tn)->rcu.next = NULL;
 +	tn->rcu.next = NULL;
  }
  
 -static inline void tnode_free_append(struct key_vector *tn,
 -				     struct key_vector *n)
 +static inline void tnode_free_append(struct tnode *tn, struct tnode *n)
  {
 -	tn_info(n)->rcu.next = tn_info(tn)->rcu.next;
 -	tn_info(tn)->rcu.next = &tn_info(n)->rcu;
 +	n->rcu.next = tn->rcu.next;
 +	tn->rcu.next = &n->rcu;
  }
  
 -static void tnode_free(struct key_vector *tn)
 +static void tnode_free(struct tnode *tn)
  {
 -	struct callback_head *head = &tn_info(tn)->rcu;
 +	struct callback_head *head = &tn->rcu;
  
  	while (head) {
  		head = head->next;
@@@ -469,9 -472,11 +500,17 @@@
  	}
  }
  
++<<<<<<< HEAD
 +static void replace(struct trie *t, struct tnode *oldtnode, struct tnode *tn)
 +{
 +	struct tnode *tp = node_parent(oldtnode);
++=======
+ static struct key_vector *replace(struct trie *t,
+ 				  struct key_vector *oldtnode,
+ 				  struct key_vector *tn)
+ {
+ 	struct key_vector *tp = node_parent(oldtnode);
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  	unsigned long i;
  
  	/* setup the parent pointer out of and back into this node */
@@@ -490,13 -495,16 +529,22 @@@
  
  		/* resize child node */
  		if (tnode_full(tn, inode))
- 			resize(t, inode);
+ 			tn = resize(t, inode);
  	}
++<<<<<<< HEAD
 +}
 +
 +static int inflate(struct trie *t, struct tnode *oldtnode)
++=======
+ 
+ 	return tp;
+ }
+ 
+ static struct key_vector *inflate(struct trie *t,
+ 				  struct key_vector *oldtnode)
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  {
 -	struct key_vector *tn;
 +	struct tnode *tn;
  	unsigned long i;
  	t_key m;
  
@@@ -587,12 -593,14 +635,17 @@@
  nomem:
  	/* all pointers should be clean so we are done */
  	tnode_free(tn);
 -notnode:
 -	return NULL;
 +	return -ENOMEM;
  }
  
++<<<<<<< HEAD
 +static int halve(struct trie *t, struct tnode *oldtnode)
++=======
+ static struct key_vector *halve(struct trie *t,
+ 				struct key_vector *oldtnode)
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  {
 -	struct key_vector *tn;
 +	struct tnode *tn;
  	unsigned long i;
  
  	pr_debug("In halve\n");
@@@ -638,14 -644,18 +691,19 @@@
  	}
  
  	/* setup the parent pointers into and out of this node */
 -	return replace(t, oldtnode, tn);
 -nomem:
 -	/* all pointers should be clean so we are done */
 -	tnode_free(tn);
 -notnode:
 -	return NULL;
 +	replace(t, oldtnode, tn);
 +
 +	return 0;
  }
  
++<<<<<<< HEAD
 +static void collapse(struct trie *t, struct tnode *oldtnode)
++=======
+ static struct key_vector *collapse(struct trie *t,
+ 				   struct key_vector *oldtnode)
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  {
 -	struct key_vector *n, *tp;
 +	struct tnode *n, *tp;
  	unsigned long i;
  
  	/* scan the tnode looking for that one child that might still exist */
@@@ -659,9 -669,11 +717,11 @@@
  
  	/* drop dead node */
  	node_free(oldtnode);
+ 
+ 	return tp;
  }
  
 -static unsigned char update_suffix(struct key_vector *tn)
 +static unsigned char update_suffix(struct tnode *tn)
  {
  	unsigned char slen = tn->pos;
  	unsigned long stride, i;
@@@ -759,9 -771,9 +819,15 @@@ static bool should_inflate(const struc
  	unsigned long threshold = used;
  
  	/* Keep root node larger */
++<<<<<<< HEAD
 +	threshold *= tp ? inflate_threshold : inflate_threshold_root;
 +	used -= tn->empty_children;
 +	used += tn->full_children;
++=======
+ 	threshold *= IS_TRIE(tp) ? inflate_threshold_root : inflate_threshold;
+ 	used -= tn_info(tn)->empty_children;
+ 	used += tn_info(tn)->full_children;
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  
  	/* if bits == KEYLENGTH then pos = 0, and will fail below */
  
@@@ -774,8 -786,8 +840,13 @@@ static bool should_halve(const struct t
  	unsigned long threshold = used;
  
  	/* Keep root node larger */
++<<<<<<< HEAD
 +	threshold *= tp ? halve_threshold : halve_threshold_root;
 +	used -= tn->empty_children;
++=======
+ 	threshold *= IS_TRIE(tp) ? halve_threshold_root : halve_threshold;
+ 	used -= tn_info(tn)->empty_children;
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  
  	/* if bits == KEYLENGTH then used = 100% on wrap, and will fail below */
  
@@@ -797,10 -809,13 +868,20 @@@ static bool should_collapse(const struc
  }
  
  #define MAX_WORK 10
++<<<<<<< HEAD
 +static void resize(struct trie *t, struct tnode *tn)
 +{
 +	struct tnode *tp = node_parent(tn);
 +	struct tnode __rcu **cptr;
++=======
+ static struct key_vector *resize(struct trie *t, struct key_vector *tn)
+ {
+ #ifdef CONFIG_IP_FIB_TRIE_STATS
+ 	struct trie_use_stats __percpu *stats = t->stats;
+ #endif
+ 	struct key_vector *tp = node_parent(tn);
+ 	unsigned long cindex = get_index(tn->key, tp);
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  	int max_work = MAX_WORK;
  
  	pr_debug("In tnode_resize %p inflate_threshold=%d threshold=%d\n",
@@@ -810,92 -825,69 +891,139 @@@
  	 * doing it ourselves.  This way we can let RCU fully do its
  	 * thing without us interfering
  	 */
++<<<<<<< HEAD
 +	cptr = tp ? &tp->child[get_index(tn->key, tp)] : &t->trie;
 +	BUG_ON(tn != rtnl_dereference(*cptr));
++=======
+ 	BUG_ON(tn != get_child(tp, cindex));
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  
  	/* Double as long as the resulting node has a number of
  	 * nonempty nodes that are above the threshold.
  	 */
  	while (should_inflate(tp, tn) && max_work) {
++<<<<<<< HEAD
 +		if (inflate(t, tn)) {
++=======
+ 		tp = inflate(t, tn);
+ 		if (!tp) {
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  #ifdef CONFIG_IP_FIB_TRIE_STATS
 -			this_cpu_inc(stats->resize_node_skipped);
 +			this_cpu_inc(t->stats->resize_node_skipped);
  #endif
  			break;
  		}
  
  		max_work--;
++<<<<<<< HEAD
 +		tn = rtnl_dereference(*cptr);
++=======
+ 		tn = get_child(tp, cindex);
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  	}
  
  	/* Return if at least one inflate is run */
  	if (max_work != MAX_WORK)
++<<<<<<< HEAD
 +		return;
++=======
+ 		return node_parent(tn);
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  
  	/* Halve as long as the number of empty children in this
  	 * node is above threshold.
  	 */
  	while (should_halve(tp, tn) && max_work) {
++<<<<<<< HEAD
 +		if (halve(t, tn)) {
++=======
+ 		tp = halve(t, tn);
+ 		if (!tp) {
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  #ifdef CONFIG_IP_FIB_TRIE_STATS
 -			this_cpu_inc(stats->resize_node_skipped);
 +			this_cpu_inc(t->stats->resize_node_skipped);
  #endif
  			break;
  		}
  
  		max_work--;
++<<<<<<< HEAD
 +		tn = rtnl_dereference(*cptr);
 +	}
 +
 +	/* Only one child remains */
 +	if (should_collapse(tn)) {
 +		collapse(t, tn);
 +		return;
 +	}
 +
 +	/* Return if at least one deflate was run */
 +	if (max_work != MAX_WORK)
 +		return;
++=======
+ 		tn = get_child(tp, cindex);
+ 	}
+ 
+ 	/* Only one child remains */
+ 	if (should_collapse(tn))
+ 		return collapse(t, tn);
+ 
+ 	/* update parent in case inflate or halve failed */
+ 	tp = node_parent(tn);
+ 
+ 	/* Return if at least one deflate was run */
+ 	if (max_work != MAX_WORK)
+ 		return tp;
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  
  	/* push the suffix length to the parent node */
  	if (tn->slen > tn->pos) {
  		unsigned char slen = update_suffix(tn);
  
- 		if (tp && (slen > tp->slen))
+ 		if (slen > tp->slen)
  			tp->slen = slen;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	return tp;
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  }
  
 -static void leaf_pull_suffix(struct key_vector *tp, struct key_vector *l)
 +/* readside must use rcu_read_lock currently dump routines
 + via get_fa_head and dump */
 +
 +static struct leaf_info *find_leaf_info(struct tnode *l, int plen)
  {
++<<<<<<< HEAD
 +	struct hlist_head *head = &l->list;
 +	struct leaf_info *li;
 +
 +	hlist_for_each_entry_rcu(li, head, hlist)
 +		if (li->plen == plen)
 +			return li;
 +
 +	return NULL;
 +}
 +
 +static inline struct list_head *get_fa_head(struct tnode *l, int plen)
 +{
 +	struct leaf_info *li = find_leaf_info(l, plen);
 +
 +	if (!li)
 +		return NULL;
 +
 +	return &li->falh;
 +}
 +
 +static void leaf_pull_suffix(struct tnode *l)
 +{
 +	struct tnode *tp = node_parent(l);
 +
 +	while (tp && (tp->slen > tp->pos) && (tp->slen > l->slen)) {
++=======
+ 	while ((tp->slen > tp->pos) && (tp->slen > l->slen)) {
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  		if (update_suffix(tp) > l->slen)
  			break;
  		tp = node_parent(tp);
@@@ -915,58 -905,21 +1043,69 @@@ static void leaf_push_suffix(struct tno
  	}
  }
  
 +static void remove_leaf_info(struct tnode *l, struct leaf_info *old)
 +{
++<<<<<<< HEAD
 +	/* record the location of the previous list_info entry */
 +	struct hlist_node **pprev = old->hlist.pprev;
 +	struct leaf_info *li = hlist_entry(pprev, typeof(*li), hlist.next);
 +
 +	/* remove the leaf info from the list */
 +	hlist_del_rcu(&old->hlist);
 +
 +	/* only access li if it is pointing at the last valid hlist_node */
 +	if (hlist_empty(&l->list) || (*pprev))
 +		return;
 +
 +	/* update the trie with the latest suffix length */
 +	l->slen = KEYLENGTH - li->plen;
 +	leaf_pull_suffix(l);
 +}
 +
 +static void insert_leaf_info(struct tnode *l, struct leaf_info *new)
 +{
 +	struct hlist_head *head = &l->list;
 +	struct leaf_info *li = NULL, *last = NULL;
 +
 +	if (hlist_empty(head)) {
 +		hlist_add_head_rcu(&new->hlist, head);
 +	} else {
 +		hlist_for_each_entry(li, head, hlist) {
 +			if (new->plen > li->plen)
 +				break;
 +
 +			last = li;
 +		}
 +		if (last)
 +			hlist_add_after_rcu(&last->hlist, &new->hlist);
 +		else
 +			hlist_add_before_rcu(&new->hlist, &li->hlist);
 +	}
 +
 +	/* if we added to the tail node then we need to update slen */
 +	if (l->slen < (KEYLENGTH - new->plen)) {
 +		l->slen = KEYLENGTH - new->plen;
 +		leaf_push_suffix(l);
 +	}
 +}
 +
  /* rcu_read_lock needs to be hold by caller from readside */
 -static struct key_vector *fib_find_node(struct trie *t,
 -					struct key_vector **tp, u32 key)
 +static struct tnode *fib_find_node(struct trie *t, u32 key)
  {
 +	struct tnode *n = rcu_dereference_rtnl(t->trie);
++=======
+ 	struct key_vector *pn, *n = t->kv;
+ 	unsigned long index = 0;
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  
- 	while (n) {
- 		unsigned long index = get_index(key, n);
+ 	do {
+ 		pn = n;
+ 		n = get_child_rcu(n, index);
+ 
+ 		if (!n)
+ 			break;
+ 
+ 		index = get_cindex(key, n);
  
  		/* This bit of code is a bit tricky but it combines multiple
  		 * checks into a single check.  The prefix consists of the
@@@ -977,91 -930,66 +1116,119 @@@
  		 *     we have a mismatch in skip bits and failed
  		 *   else
  		 *     we know the value is cindex
 -		 *
 -		 * This check is safe even if bits == KEYLENGTH due to the
 -		 * fact that we can only allocate a node with 32 bits if a
 -		 * long is greater than 32 bits.
  		 */
 -		if (index >= (1ul << n->bits)) {
 -			n = NULL;
 +		if (index & (~0ul << n->bits))
 +			return NULL;
 +
++<<<<<<< HEAD
 +		/* we have found a leaf. Prefixes have already been compared */
 +		if (IS_LEAF(n))
  			break;
 -		}
  
 +		n = tnode_get_child_rcu(n, index);
 +	}
++=======
+ 		/* keep searching until we find a perfect match leaf or NULL */
+ 	} while (IS_TNODE(n));
 -
 -	*tp = pn;
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  
  	return n;
  }
  
 -/* Return the first fib alias matching TOS with
 - * priority less than or equal to PRIO.
 - */
 -static struct fib_alias *fib_find_alias(struct hlist_head *fah, u8 slen,
 -					u8 tos, u32 prio)
 +static void trie_rebalance(struct trie *t, struct tnode *tn)
  {
 -	struct fib_alias *fa;
 +	struct tnode *tp;
 +
 +	while ((tp = node_parent(tn)) != NULL) {
 +		resize(t, tn);
 +		tn = tp;
 +	}
 +
 +	/* Handle last (top) tnode */
 +	if (IS_TNODE(tn))
 +		resize(t, tn);
 +}
 +
 +/* only used from updater-side */
  
 -	if (!fah)
 +static struct list_head *fib_insert_node(struct trie *t, u32 key, int plen)
 +{
 +	struct list_head *fa_head = NULL;
 +	struct tnode *l, *n, *tp = NULL;
 +	struct leaf_info *li;
 +
 +	li = leaf_info_new(plen);
 +	if (!li)
  		return NULL;
 +	fa_head = &li->falh;
  
 -	hlist_for_each_entry(fa, fah, fa_list) {
 -		if (fa->fa_slen < slen)
 -			continue;
 -		if (fa->fa_slen != slen)
 +	n = rtnl_dereference(t->trie);
 +
 +	/* If we point to NULL, stop. Either the tree is empty and we should
 +	 * just put a new leaf in if, or we have reached an empty child slot,
 +	 * and we should just put our new leaf in that.
 +	 *
 +	 * If we hit a node with a key that does't match then we should stop
 +	 * and create a new tnode to replace that node and insert ourselves
 +	 * and the other node into the new tnode.
 +	 */
 +	while (n) {
 +		unsigned long index = get_index(key, n);
 +
 +		/* This bit of code is a bit tricky but it combines multiple
 +		 * checks into a single check.  The prefix consists of the
 +		 * prefix plus zeros for the "bits" in the prefix. The index
 +		 * is the difference between the key and this value.  From
 +		 * this we can actually derive several pieces of data.
 +		 *   if !(index >> bits)
 +		 *     we know the value is child index
 +		 *   else
 +		 *     we have a mismatch in skip bits and failed
 +		 */
 +		if (index >> n->bits)
  			break;
 -		if (fa->fa_tos > tos)
 -			continue;
 -		if (fa->fa_info->fib_priority >= prio || fa->fa_tos < tos)
 -			return fa;
 +
 +		/* we have found a leaf. Prefixes have already been compared */
 +		if (IS_LEAF(n)) {
 +			/* Case 1: n is a leaf, and prefixes match*/
 +			insert_leaf_info(n, li);
 +			return fa_head;
 +		}
 +
 +		tp = n;
 +		n = tnode_get_child_rcu(n, index);
 +	}
 +
++<<<<<<< HEAD
 +	l = leaf_new(key);
 +	if (!l) {
 +		free_leaf_info(li);
 +		return NULL;
  	}
  
 +	insert_leaf_info(l, li);
++=======
+ 	return NULL;
+ }
+ 
+ static void trie_rebalance(struct trie *t, struct key_vector *tn)
+ {
+ 	while (!IS_TRIE(tn))
+ 		tn = resize(t, tn);
+ }
+ 
+ static int fib_insert_node(struct trie *t, struct key_vector *tp,
+ 			   struct fib_alias *new, t_key key)
+ {
+ 	struct key_vector *n, *l;
+ 
+ 	l = leaf_new(key, new);
+ 	if (!l)
+ 		goto noleaf;
+ 
+ 	/* retrieve child from parent node */
+ 	n = get_child(tp, get_index(key, tp));
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  
  	/* Case 2: n is a LEAF or a TNODE and the key doesn't match.
  	 *
@@@ -1092,33 -1017,64 +1259,56 @@@
  	}
  
  	/* Case 3: n is NULL, and will just insert a new leaf */
++<<<<<<< HEAD
 +	if (tp) {
 +		NODE_INIT_PARENT(l, tp);
 +		put_child(tp, get_index(key, tp), l);
 +		trie_rebalance(t, tp);
++=======
+ 	NODE_INIT_PARENT(l, tp);
+ 	put_child_root(tp, key, l);
+ 	trie_rebalance(t, tp);
+ 
+ 	return 0;
+ notnode:
+ 	node_free(l);
+ noleaf:
+ 	return -ENOMEM;
+ }
+ 
+ static int fib_insert_alias(struct trie *t, struct key_vector *tp,
+ 			    struct key_vector *l, struct fib_alias *new,
+ 			    struct fib_alias *fa, t_key key)
+ {
+ 	if (!l)
+ 		return fib_insert_node(t, tp, new, key);
+ 
+ 	if (fa) {
+ 		hlist_add_before_rcu(&new->fa_list, &fa->fa_list);
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  	} else {
 -		struct fib_alias *last;
 -
 -		hlist_for_each_entry(last, &l->leaf, fa_list) {
 -			if (new->fa_slen < last->fa_slen)
 -				break;
 -			fa = last;
 -		}
 -
 -		if (fa)
 -			hlist_add_behind_rcu(&new->fa_list, &fa->fa_list);
 -		else
 -			hlist_add_head_rcu(&new->fa_list, &l->leaf);
 -	}
 -
 -	/* if we added to the tail node then we need to update slen */
 -	if (l->slen < new->fa_slen) {
 -		l->slen = new->fa_slen;
 -		leaf_push_suffix(tp, l);
 +		rcu_assign_pointer(t->trie, l);
  	}
  
 -	return 0;
 +	return fa_head;
  }
  
 -/* Caller must hold RTNL. */
 +/*
 + * Caller must hold RTNL.
 + */
  int fib_table_insert(struct fib_table *tb, struct fib_config *cfg)
  {
 -	struct trie *t = (struct trie *)tb->tb_data;
 +	struct trie *t = (struct trie *) tb->tb_data;
  	struct fib_alias *fa, *new_fa;
 -	struct key_vector *l, *tp;
 +	struct list_head *fa_head = NULL;
  	struct fib_info *fi;
 -	u8 plen = cfg->fc_dst_len;
 -	u8 slen = KEYLENGTH - plen;
 +	int plen = cfg->fc_dst_len;
  	u8 tos = cfg->fc_tos;
 -	u32 key;
 +	u32 key, mask;
  	int err;
 +	struct tnode *l;
  
 -	if (plen > KEYLENGTH)
 +	if (plen > 32)
  		return -EINVAL;
  
  	key = ntohl(cfg->fc_dst);
@@@ -1289,11 -1247,15 +1479,18 @@@ int fib_table_lookup(struct fib_table *
  	struct trie_use_stats __percpu *stats = t->stats;
  #endif
  	const t_key key = ntohl(flp->daddr);
 -	struct key_vector *n, *pn;
 -	struct fib_alias *fa;
 -	unsigned long index;
 +	struct tnode *n, *pn;
 +	struct leaf_info *li;
  	t_key cindex;
  
++<<<<<<< HEAD
 +	n = rcu_dereference(t->trie);
++=======
+ 	pn = t->kv;
+ 	cindex = 0;
+ 
+ 	n = get_child_rcu(pn, cindex);
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  	if (!n)
  		return -EAGAIN;
  
@@@ -1301,12 -1263,9 +1498,13 @@@
  	this_cpu_inc(stats->gets);
  #endif
  
- 	pn = n;
- 	cindex = 0;
- 
  	/* Step 1: Travel to the longest prefix match in the trie */
  	for (;;) {
++<<<<<<< HEAD
 +		unsigned long index = get_index(key, n);
++=======
+ 		index = get_cindex(key, n);
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  
  		/* This bit of code is a bit tricky but it combines multiple
  		 * checks into a single check.  The prefix consists of the
@@@ -1452,28 -1417,36 +1654,37 @@@ found
  }
  EXPORT_SYMBOL_GPL(fib_table_lookup);
  
 -static void fib_remove_alias(struct trie *t, struct key_vector *tp,
 -			     struct key_vector *l, struct fib_alias *old)
 +/*
 + * Remove the leaf and return parent.
 + */
 +static void trie_leaf_remove(struct trie *t, struct tnode *l)
  {
 -	/* record the location of the previous list_info entry */
 -	struct hlist_node **pprev = old->fa_list.pprev;
 -	struct fib_alias *fa = hlist_entry(pprev, typeof(*fa), fa_list.next);
 +	struct tnode *tp = node_parent(l);
  
 -	/* remove the fib_alias from the list */
 -	hlist_del_rcu(&old->fa_list);
 +	pr_debug("entering trie_leaf_remove(%p)\n", l);
  
++<<<<<<< HEAD
 +	if (tp) {
 +		put_child(tp, get_index(l->key, tp), NULL);
++=======
+ 	/* if we emptied the list this leaf will be freed and we can sort
+ 	 * out parent suffix lengths as a part of trie_rebalance
+ 	 */
+ 	if (hlist_empty(&l->leaf)) {
+ 		put_child_root(tp, l->key, NULL);
+ 		node_free(l);
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  		trie_rebalance(t, tp);
 -		return;
 +	} else {
 +		RCU_INIT_POINTER(t->trie, NULL);
  	}
  
 -	/* only access fa if it is pointing at the last valid hlist_node */
 -	if (*pprev)
 -		return;
 -
 -	/* update the trie with the latest suffix length */
 -	l->slen = fa->fa_slen;
 -	leaf_pull_suffix(tp, l);
 +	node_free(l);
  }
  
 -/* Caller must hold RTNL. */
 +/*
 + * Caller must hold RTNL.
 + */
  int fib_table_delete(struct fib_table *tb, struct fib_config *cfg)
  {
  	struct trie *t = (struct trie *) tb->tb_data;
@@@ -1562,141 -1517,189 +1773,324 @@@
  	return 0;
  }
  
 -/* Scan for the next leaf starting at the provided key value */
 -static struct key_vector *leaf_walk_rcu(struct key_vector **tn, t_key key)
 +static int trie_flush_list(struct list_head *head)
 +{
++<<<<<<< HEAD
 +	struct fib_alias *fa, *fa_node;
 +	int found = 0;
 +
 +	list_for_each_entry_safe(fa, fa_node, head, fa_list) {
 +		struct fib_info *fi = fa->fa_info;
 +
 +		if (fi && (fi->fib_flags & RTNH_F_DEAD)) {
 +			list_del_rcu(&fa->fa_list);
 +			fib_release_info(fa->fa_info);
 +			alias_free_mem_rcu(fa);
 +			found++;
 +		}
 +	}
 +	return found;
 +}
 +
 +static int trie_flush_leaf(struct tnode *l)
 +{
 +	int found = 0;
 +	struct hlist_head *lih = &l->list;
 +	struct hlist_node *tmp;
 +	struct leaf_info *li = NULL;
 +	unsigned char plen = KEYLENGTH;
 +
 +	hlist_for_each_entry_safe(li, tmp, lih, hlist) {
 +		found += trie_flush_list(&li->falh);
 +
 +		if (list_empty(&li->falh)) {
 +			hlist_del_rcu(&li->hlist);
 +			free_leaf_info(li);
 +			continue;
 +		}
 +
 +		plen = li->plen;
 +	}
 +
 +	l->slen = KEYLENGTH - plen;
 +
 +	return found;
 +}
 +
 +/*
 + * Scan for the next right leaf starting at node p->child[idx]
 + * Since we have back pointer, no recursion necessary.
 + */
 +static struct tnode *leaf_walk_rcu(struct tnode *p, struct tnode *c)
 +{
 +	do {
 +		unsigned long idx = c ? idx = get_index(c->key, p) + 1 : 0;
 +
 +		while (idx < tnode_child_length(p)) {
 +			c = tnode_get_child_rcu(p, idx++);
 +			if (!c)
 +				continue;
 +
 +			if (IS_LEAF(c))
 +				return c;
 +
 +			/* Rescan start scanning in new node */
 +			p = c;
 +			idx = 0;
 +		}
 +
 +		/* Node empty, walk back up to parent */
 +		c = p;
 +	} while ((p = node_parent_rcu(c)) != NULL);
 +
 +	return NULL; /* Root of trie */
 +}
 +
 +static struct tnode *trie_firstleaf(struct trie *t)
 +{
 +	struct tnode *n = rcu_dereference_rtnl(t->trie);
 +
 +	if (!n)
 +		return NULL;
 +
 +	if (IS_LEAF(n))          /* trie is just a leaf */
 +		return n;
 +
 +	return leaf_walk_rcu(n, NULL);
 +}
 +
 +static struct tnode *trie_nextleaf(struct tnode *l)
 +{
 +	struct tnode *p = node_parent_rcu(l);
 +
 +	if (!p)
 +		return NULL;	/* trie with just one leaf */
 +
 +	return leaf_walk_rcu(p, l);
 +}
 +
 +static struct tnode *trie_leafindex(struct trie *t, int index)
 +{
 +	struct tnode *l = trie_firstleaf(t);
 +
 +	while (l && index-- > 0)
 +		l = trie_nextleaf(l);
 +
 +	return l;
 +}
 +
 +
 +/*
 + * Caller must hold RTNL.
 + */
 +int fib_table_flush(struct fib_table *tb)
  {
 +	struct trie *t = (struct trie *) tb->tb_data;
 +	struct tnode *l, *ll = NULL;
 +	int found = 0;
 +
 +	for (l = trie_firstleaf(t); l; l = trie_nextleaf(l)) {
 +		found += trie_flush_leaf(l);
 +
 +		if (ll) {
 +			if (hlist_empty(&ll->list))
 +				trie_leaf_remove(t, ll);
 +			else
 +				leaf_pull_suffix(ll);
 +		}
 +
 +		ll = l;
 +	}
 +
 +	if (ll) {
 +		if (hlist_empty(&ll->list))
 +			trie_leaf_remove(t, ll);
 +		else
 +			leaf_pull_suffix(ll);
 +	}
 +
++=======
+ 	struct key_vector *pn, *n = *tn;
+ 	unsigned long cindex;
+ 
+ 	/* this loop is meant to try and find the key in the trie */
+ 	do {
+ 		/* record parent and next child index */
+ 		pn = n;
+ 		cindex = get_index(key, pn);
+ 
+ 		if (cindex >> pn->bits)
+ 			break;
+ 
+ 		/* descend into the next child */
+ 		n = get_child_rcu(pn, cindex++);
+ 		if (!n)
+ 			break;
+ 
+ 		/* guarantee forward progress on the keys */
+ 		if (IS_LEAF(n) && (n->key >= key))
+ 			goto found;
+ 	} while (IS_TNODE(n));
+ 
+ 	/* this loop will search for the next leaf with a greater key */
+ 	while (!IS_TRIE(pn)) {
+ 		/* if we exhausted the parent node we will need to climb */
+ 		if (cindex >= (1ul << pn->bits)) {
+ 			t_key pkey = pn->key;
+ 
+ 			pn = node_parent_rcu(pn);
+ 			cindex = get_index(pkey, pn) + 1;
+ 			continue;
+ 		}
+ 
+ 		/* grab the next available node */
+ 		n = get_child_rcu(pn, cindex++);
+ 		if (!n)
+ 			continue;
+ 
+ 		/* no need to compare keys since we bumped the index */
+ 		if (IS_LEAF(n))
+ 			goto found;
+ 
+ 		/* Rescan start scanning in new node */
+ 		pn = n;
+ 		cindex = 0;
+ 	}
+ 
+ 	*tn = pn;
+ 	return NULL; /* Root of trie */
+ found:
+ 	/* if we are at the limit for keys just return NULL for the tnode */
+ 	*tn = pn;
+ 	return n;
+ }
+ 
+ /* Caller must hold RTNL */
+ void fib_table_flush_external(struct fib_table *tb)
+ {
+ 	struct trie *t = (struct trie *)tb->tb_data;
+ 	struct key_vector *pn = t->kv;
+ 	unsigned long cindex = 1;
+ 	struct hlist_node *tmp;
+ 	struct fib_alias *fa;
+ 
+ 	/* walk trie in reverse order */
+ 	for (;;) {
+ 		struct key_vector *n;
+ 
+ 		if (!(cindex--)) {
+ 			t_key pkey = pn->key;
+ 
+ 			/* cannot resize the trie vector */
+ 			if (IS_TRIE(pn))
+ 				break;
+ 
+ 			/* no need to resize like in flush below */
+ 			pn = node_parent(pn);
+ 			cindex = get_index(pkey, pn);
+ 
+ 			continue;
+ 		}
+ 
+ 		/* grab the next available node */
+ 		n = get_child(pn, cindex);
+ 		if (!n)
+ 			continue;
+ 
+ 		if (IS_TNODE(n)) {
+ 			/* record pn and cindex for leaf walking */
+ 			pn = n;
+ 			cindex = 1ul << n->bits;
+ 
+ 			continue;
+ 		}
+ 
+ 		hlist_for_each_entry_safe(fa, tmp, &n->leaf, fa_list) {
+ 			struct fib_info *fi = fa->fa_info;
+ 
+ 			if (!fi || !(fi->fib_flags & RTNH_F_EXTERNAL))
+ 				continue;
+ 
+ 			netdev_switch_fib_ipv4_del(n->key,
+ 						   KEYLENGTH - fa->fa_slen,
+ 						   fi, fa->fa_tos,
+ 						   fa->fa_type, tb->tb_id);
+ 		}
+ 	}
+ }
+ 
+ /* Caller must hold RTNL. */
+ int fib_table_flush(struct fib_table *tb)
+ {
+ 	struct trie *t = (struct trie *)tb->tb_data;
+ 	struct key_vector *pn = t->kv;
+ 	unsigned long cindex = 1;
+ 	struct hlist_node *tmp;
+ 	struct fib_alias *fa;
+ 	int found = 0;
+ 
+ 	/* walk trie in reverse order */
+ 	for (;;) {
+ 		unsigned char slen = 0;
+ 		struct key_vector *n;
+ 
+ 		if (!(cindex--)) {
+ 			t_key pkey = pn->key;
+ 
+ 			/* cannot resize the trie vector */
+ 			if (IS_TRIE(pn))
+ 				break;
+ 
+ 			/* resize completed node */
+ 			pn = resize(t, pn);
+ 			cindex = get_index(pkey, pn);
+ 
+ 			continue;
+ 		}
+ 
+ 		/* grab the next available node */
+ 		n = get_child(pn, cindex);
+ 		if (!n)
+ 			continue;
+ 
+ 		if (IS_TNODE(n)) {
+ 			/* record pn and cindex for leaf walking */
+ 			pn = n;
+ 			cindex = 1ul << n->bits;
+ 
+ 			continue;
+ 		}
+ 
+ 		hlist_for_each_entry_safe(fa, tmp, &n->leaf, fa_list) {
+ 			struct fib_info *fi = fa->fa_info;
+ 
+ 			if (!fi || !(fi->fib_flags & RTNH_F_DEAD)) {
+ 				slen = fa->fa_slen;
+ 				continue;
+ 			}
+ 
+ 			netdev_switch_fib_ipv4_del(n->key,
+ 						   KEYLENGTH - fa->fa_slen,
+ 						   fi, fa->fa_tos,
+ 						   fa->fa_type, tb->tb_id);
+ 			hlist_del_rcu(&fa->fa_list);
+ 			fib_release_info(fa->fa_info);
+ 			alias_free_mem_rcu(fa);
+ 			found++;
+ 		}
+ 
+ 		/* update leaf slen */
+ 		n->slen = slen;
+ 
+ 		if (hlist_empty(&n->leaf)) {
+ 			put_child_root(pn, n->key, NULL);
+ 			node_free(n);
+ 		} else {
+ 			leaf_pull_suffix(pn, n);
+ 		}
+ 	}
+ 
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  	pr_debug("trie_flush found=%d\n", found);
  	return found;
  }
@@@ -1784,31 -1759,19 +2178,40 @@@ static int fn_trie_dump_leaf(struct tno
  int fib_table_dump(struct fib_table *tb, struct sk_buff *skb,
  		   struct netlink_callback *cb)
  {
++<<<<<<< HEAD
 +	struct tnode *l;
 +	struct trie *t = (struct trie *) tb->tb_data;
 +	t_key key = cb->args[2];
 +	int count = cb->args[3];
 +
 +	rcu_read_lock();
++=======
+ 	struct trie *t = (struct trie *)tb->tb_data;
+ 	struct key_vector *l, *tp = t->kv;
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  	/* Dump starting at last key.
  	 * Note: 0.0.0.0/0 (ie default) is first key.
  	 */
 -	int count = cb->args[2];
 -	t_key key = cb->args[3];
 +	if (count == 0)
 +		l = trie_firstleaf(t);
 +	else {
 +		/* Normally, continue from last key, but if that is missing
 +		 * fallback to using slow rescan
 +		 */
 +		l = fib_find_node(t, key);
 +		if (!l)
 +			l = trie_leafindex(t, count);
 +	}
  
++<<<<<<< HEAD
 +	while (l) {
 +		cb->args[2] = l->key;
++=======
+ 	while ((l = leaf_walk_rcu(&tp, key)) != NULL) {
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  		if (fn_trie_dump_leaf(l, tb, skb, cb) < 0) {
 -			cb->args[3] = key;
 -			cb->args[2] = count;
 +			cb->args[3] = count;
 +			rcu_read_unlock();
  			return -1;
  		}
  
@@@ -1851,7 -1817,8 +2252,12 @@@ struct fib_table *fib_trie_table(u32 id
  	tb->tb_num_default = 0;
  
  	t = (struct trie *) tb->tb_data;
++<<<<<<< HEAD
 +	RCU_INIT_POINTER(t->trie, NULL);
++=======
+ 	t->kv[0].pos = KEYLENGTH;
+ 	t->kv[0].slen = KEYLENGTH;
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  #ifdef CONFIG_IP_FIB_TRIE_STATS
  	t->stats = alloc_percpu(struct trie_use_stats);
  	if (!t->stats) {
@@@ -1873,26 -1840,25 +2279,40 @@@ struct fib_trie_iter 
  	unsigned int depth;
  };
  
 -static struct key_vector *fib_trie_get_next(struct fib_trie_iter *iter)
 +static struct tnode *fib_trie_get_next(struct fib_trie_iter *iter)
  {
  	unsigned long cindex = iter->index;
++<<<<<<< HEAD
 +	struct tnode *tn = iter->tnode;
 +	struct tnode *p;
 +
 +	/* A single entry routing table */
 +	if (!tn)
 +		return NULL;
 +
 +	pr_debug("get_next iter={node=%p index=%d depth=%d}\n",
 +		 iter->tnode, iter->index, iter->depth);
 +rescan:
 +	while (cindex < tnode_child_length(tn)) {
 +		struct tnode *n = tnode_get_child_rcu(tn, cindex);
++=======
+ 	struct key_vector *pn = iter->tnode;
+ 	t_key pkey;
+ 
+ 	pr_debug("get_next iter={node=%p index=%d depth=%d}\n",
+ 		 iter->tnode, iter->index, iter->depth);
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
+ 
+ 	while (!IS_TRIE(pn)) {
+ 		while (cindex < child_length(pn)) {
+ 			struct key_vector *n = get_child_rcu(pn, cindex++);
+ 
+ 			if (!n)
+ 				continue;
  
- 		if (n) {
  			if (IS_LEAF(n)) {
- 				iter->tnode = tn;
- 				iter->index = cindex + 1;
+ 				iter->tnode = pn;
+ 				iter->index = cindex;
  			} else {
  				/* push down one level */
  				iter->tnode = n;
@@@ -1918,15 -1883,15 +2337,23 @@@
  	return NULL;
  }
  
 -static struct key_vector *fib_trie_get_first(struct fib_trie_iter *iter,
 -					     struct trie *t)
 +static struct tnode *fib_trie_get_first(struct fib_trie_iter *iter,
 +				       struct trie *t)
  {
++<<<<<<< HEAD
 +	struct tnode *n;
++=======
+ 	struct key_vector *n, *pn = t->kv;
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  
  	if (!t)
  		return NULL;
  
++<<<<<<< HEAD
 +	n = rcu_dereference(t->trie);
++=======
+ 	n = rcu_dereference(pn->tnode[0]);
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  	if (!n)
  		return NULL;
  
@@@ -2230,9 -2195,9 +2657,9 @@@ static inline const char *rtn_type(cha
  static int fib_trie_seq_show(struct seq_file *seq, void *v)
  {
  	const struct fib_trie_iter *iter = seq->private;
 -	struct key_vector *n = v;
 +	struct tnode *n = v;
  
- 	if (!node_parent_rcu(n))
+ 	if (IS_TRIE(node_parent_rcu(n)))
  		fib_table_print(seq, iter->tb);
  
  	if (IS_TNODE(n)) {
@@@ -2299,22 -2263,37 +2726,29 @@@ struct fib_route_iter 
  	t_key	key;
  };
  
 -static struct key_vector *fib_route_get_idx(struct fib_route_iter *iter,
 -					    loff_t pos)
 +static struct tnode *fib_route_get_idx(struct fib_route_iter *iter, loff_t pos)
  {
 -	struct fib_table *tb = iter->main_tb;
 -	struct key_vector *l, **tp = &iter->tnode;
 -	struct trie *t;
 -	t_key key;
 +	struct tnode *l = NULL;
 +	struct trie *t = iter->main_trie;
  
 -	/* use cache location of next-to-find key */
 -	if (iter->pos > 0 && pos >= iter->pos) {
 +	/* use cache location of last found key */
 +	if (iter->pos > 0 && pos >= iter->pos && (l = fib_find_node(t, iter->key)))
  		pos -= iter->pos;
++<<<<<<< HEAD
 +	else {
++=======
+ 		key = iter->key;
+ 	} else {
+ 		t = (struct trie *)tb->tb_data;
+ 		iter->tnode = t->kv;
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  		iter->pos = 0;
 -		key = 0;
 +		l = trie_firstleaf(t);
  	}
  
 -	while ((l = leaf_walk_rcu(tp, key)) != NULL) {
 -		key = l->key + 1;
 +	while (l && pos-- > 0) {
  		iter->pos++;
 -
 -		if (pos-- <= 0)
 -			break;
 -
 -		l = NULL;
 -
 -		/* handle unlikely case of a key wrap */
 -		if (!key)
 -			break;
 +		l = trie_nextleaf(l);
  	}
  
  	if (l)
@@@ -2336,11 -2317,17 +2770,25 @@@ static void *fib_route_seq_start(struc
  	if (!tb)
  		return NULL;
  
++<<<<<<< HEAD
 +	iter->main_trie = (struct trie *) tb->tb_data;
 +	if (*pos == 0)
 +		return SEQ_START_TOKEN;
 +	else
 +		return fib_route_get_idx(iter, *pos - 1);
++=======
+ 	iter->main_tb = tb;
+ 
+ 	if (*pos != 0)
+ 		return fib_route_get_idx(iter, *pos);
+ 
+ 	t = (struct trie *)tb->tb_data;
+ 	iter->tnode = t->kv;
+ 	iter->pos = 0;
+ 	iter->key = 0;
+ 
+ 	return SEQ_START_TOKEN;
++>>>>>>> 88bae7149a5e (fib_trie: Add key vector to root, return parent key_vector in resize)
  }
  
  static void *fib_route_seq_next(struct seq_file *seq, void *v, loff_t *pos)
* Unmerged path net/ipv4/fib_trie.c
