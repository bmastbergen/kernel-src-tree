xfs: fix error handling at xfs_inumbers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Jie Liu <jeff.liu@oracle.com>
commit c7cb51dcb0a38624d42eeabb38502fa54a4d774b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/c7cb51dc.failed

From: Jie Liu <jeff.liu@oracle.com>

To fetch the file system number tables, we currently just ignore the
errors and proceed to loop over the next AG or bump agino to the next
chunk in case of btree operations failed, that is not properly because
those errors might hint us potential file system problems.

This patch rework xfs_inumbers() to handle the btree operation errors
as well as the loop conditions.

	Signed-off-by: Jie Liu <jeff.liu@oracle.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit c7cb51dcb0a38624d42eeabb38502fa54a4d774b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_itable.c
diff --cc fs/xfs/xfs_itable.c
index 2e7b3970ae2e,ed042fff9337..000000000000
--- a/fs/xfs/xfs_itable.c
+++ b/fs/xfs/xfs_itable.c
@@@ -575,118 -527,93 +575,180 @@@ xfs_inumbers_fmt
   */
  int					/* error status */
  xfs_inumbers(
 -	struct xfs_mount	*mp,/* mount point for filesystem */
 -	xfs_ino_t		*lastino,/* last inode returned */
 -	int			*count,/* size of buffer/count returned */
 -	void			__user *ubuffer,/* buffer with inode descriptions */
 -	inumbers_fmt_pf		formatter)
 +	xfs_mount_t	*mp,		/* mount point for filesystem */
 +	xfs_ino_t	*lastino,	/* last inode returned */
 +	int		*count,		/* size of buffer/count returned */
 +	void		__user *ubuffer,/* buffer with inode descriptions */
 +	inumbers_fmt_pf	formatter)
  {
++<<<<<<< HEAD
 +	xfs_buf_t	*agbp;
 +	xfs_agino_t	agino;
 +	xfs_agnumber_t	agno;
 +	int		bcount;
 +	xfs_inogrp_t	*buffer;
 +	int		bufidx;
 +	xfs_btree_cur_t	*cur;
 +	int		error;
 +	xfs_inobt_rec_incore_t r;
 +	int		i;
 +	xfs_ino_t	ino;
 +	int		left;
 +	int		tmp;
++=======
+ 	xfs_agnumber_t		agno = XFS_INO_TO_AGNO(mp, *lastino);
+ 	xfs_agino_t		agino = XFS_INO_TO_AGINO(mp, *lastino);
+ 	struct xfs_btree_cur	*cur = NULL;
+ 	struct xfs_buf		*agbp = NULL;
+ 	struct xfs_inogrp	*buffer;
+ 	int			bcount;
+ 	int			left = *count;
+ 	int			bufidx = 0;
+ 	int			error = 0;
++>>>>>>> c7cb51dcb0a3 (xfs: fix error handling at xfs_inumbers)
  
 +	ino = (xfs_ino_t)*lastino;
 +	agno = XFS_INO_TO_AGNO(mp, ino);
 +	agino = XFS_INO_TO_AGINO(mp, ino);
 +	left = *count;
  	*count = 0;
 -	if (agno >= mp->m_sb.sb_agcount ||
 -	    *lastino != XFS_AGINO_TO_INO(mp, agno, agino))
 -		return error;
 -
  	bcount = MIN(left, (int)(PAGE_SIZE / sizeof(*buffer)));
  	buffer = kmem_alloc(bcount * sizeof(*buffer), KM_SLEEP);
++<<<<<<< HEAD
 +	error = bufidx = 0;
 +	cur = NULL;
 +	agbp = NULL;
 +	while (left > 0 && agno < mp->m_sb.sb_agcount) {
 +		if (agbp == NULL) {
++=======
+ 	do {
+ 		struct xfs_inobt_rec_incore	r;
+ 		int				stat;
+ 
+ 		if (!agbp) {
++>>>>>>> c7cb51dcb0a3 (xfs: fix error handling at xfs_inumbers)
  			error = xfs_ialloc_read_agi(mp, NULL, agno, &agbp);
- 			if (error) {
- 				/*
- 				 * If we can't read the AGI of this ag,
- 				 * then just skip to the next one.
- 				 */
- 				ASSERT(cur == NULL);
- 				agbp = NULL;
- 				agno++;
- 				agino = 0;
- 				continue;
- 			}
+ 			if (error)
+ 				break;
+ 
  			cur = xfs_inobt_init_cursor(mp, NULL, agbp, agno,
  						    XFS_BTNUM_INO);
  			error = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_GE,
++<<<<<<< HEAD
 +						 &tmp);
 +			if (error) {
 +				xfs_btree_del_cursor(cur, XFS_BTREE_ERROR);
 +				cur = NULL;
 +				xfs_buf_relse(agbp);
 +				agbp = NULL;
 +				/*
 +				 * Move up the last inode in the current
 +				 * chunk.  The lookup_ge will always get
 +				 * us the first inode in the next chunk.
 +				 */
 +				agino += XFS_INODES_PER_CHUNK - 1;
 +				continue;
 +			}
 +		}
 +		error = xfs_inobt_get_rec(cur, &r, &i);
 +		if (error || i == 0) {
 +			xfs_buf_relse(agbp);
 +			agbp = NULL;
 +			xfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);
 +			cur = NULL;
 +			agno++;
 +			agino = 0;
 +			continue;
 +		}
++=======
+ 						 &stat);
+ 			if (error)
+ 				break;
+ 			if (!stat)
+ 				goto next_ag;
+ 		}
+ 
+ 		error = xfs_inobt_get_rec(cur, &r, &stat);
+ 		if (error)
+ 			break;
+ 		if (!stat)
+ 			goto next_ag;
+ 
++>>>>>>> c7cb51dcb0a3 (xfs: fix error handling at xfs_inumbers)
  		agino = r.ir_startino + XFS_INODES_PER_CHUNK - 1;
  		buffer[bufidx].xi_startino =
  			XFS_AGINO_TO_INO(mp, agno, r.ir_startino);
  		buffer[bufidx].xi_alloccount =
  			XFS_INODES_PER_CHUNK - r.ir_freecount;
  		buffer[bufidx].xi_allocmask = ~r.ir_free;
++<<<<<<< HEAD
 +		bufidx++;
 +		left--;
 +		if (bufidx == bcount) {
 +			long written;
 +			if (formatter(ubuffer, buffer, bufidx, &written)) {
 +				error = XFS_ERROR(EFAULT);
++=======
+ 		if (++bufidx == bcount) {
+ 			long	written;
+ 
+ 			error = formatter(ubuffer, buffer, bufidx, &written);
+ 			if (error)
++>>>>>>> c7cb51dcb0a3 (xfs: fix error handling at xfs_inumbers)
  				break;
 +			}
  			ubuffer += written;
  			*count += bufidx;
  			bufidx = 0;
  		}
++<<<<<<< HEAD
 +		if (left) {
 +			error = xfs_btree_increment(cur, 0, &tmp);
 +			if (error) {
 +				xfs_btree_del_cursor(cur, XFS_BTREE_ERROR);
 +				cur = NULL;
 +				xfs_buf_relse(agbp);
 +				agbp = NULL;
 +				/*
 +				 * The agino value has already been bumped.
 +				 * Just try to skip up to it.
 +				 */
 +				agino += XFS_INODES_PER_CHUNK;
 +				continue;
 +			}
 +		}
 +	}
 +	if (!error) {
 +		if (bufidx) {
 +			long written;
 +			if (formatter(ubuffer, buffer, bufidx, &written))
 +				error = XFS_ERROR(EFAULT);
 +			else
++=======
+ 		if (!--left)
+ 			break;
+ 
+ 		error = xfs_btree_increment(cur, 0, &stat);
+ 		if (error)
+ 			break;
+ 		if (stat)
+ 			continue;
+ 
+ next_ag:
+ 		xfs_btree_del_cursor(cur, XFS_BTREE_ERROR);
+ 		cur = NULL;
+ 		xfs_buf_relse(agbp);
+ 		agbp = NULL;
+ 		agino = 0;
+ 	} while (++agno < mp->m_sb.sb_agcount);
+ 
+ 	if (!error) {
+ 		if (bufidx) {
+ 			long	written;
+ 
+ 			error = formatter(ubuffer, buffer, bufidx, &written);
+ 			if (!error)
++>>>>>>> c7cb51dcb0a3 (xfs: fix error handling at xfs_inumbers)
  				*count += bufidx;
  		}
  		*lastino = XFS_AGINO_TO_INO(mp, agno, agino);
* Unmerged path fs/xfs/xfs_itable.c
