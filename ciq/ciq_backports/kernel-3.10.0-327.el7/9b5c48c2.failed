hpsa: clean up aborts

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Stephen Cameron <stephenmcameron@gmail.com>
commit 9b5c48c28f5651f5e36150131bd7b29cc85a3512
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/9b5c48c2.failed

Do not send aborts to logical devices that do not support aborts

Instead of relying on what the Smart Array claims for supporting logical
drives, simply try an abort and see how it responds at device discovery
time.  This way devices that do support aborts (e.g. MSA2000) can work
and we do not waste time trying to send aborts to logical drives that do
not support them (important for high IOPS devices.)

While rescanning devices only test whether devices support aborts
the first time we encounter a device rather than every time.

Some Smart Arrays required aborts to be sent with tags in
the wrong endian byte order.  To avoid having to know about
this, we would send two aborts with tags with each endian order.
On high IOPS devices, this turns out to be not such a hot idea.
So we now have a list of the devices that got the tag backwards,
and we only send it one way.

If all available commands are outstanding and the abort handler
is invoked, the abort handler may not be able to allocate a command
and may busy-wait excessivly.  Reserve a small number of commands
for the abort handler and limit the number of concurrent abort
requests to the number of reserved commands.

	Reviewed-by: Scott Teel <scott.teel@pmcs.com>
	Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
	Reviewed-by: Tomas Henzl <thenzl@redhat.com>
	Reviewed-by: Hannes Reinecke <hare@Suse.de>
	Signed-off-by: Don Brace <don.brace@pmcs.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: James Bottomley <JBottomley@Odin.com>
(cherry picked from commit 9b5c48c28f5651f5e36150131bd7b29cc85a3512)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/hpsa.c
#	drivers/scsi/hpsa.h
diff --cc drivers/scsi/hpsa.c
index 4400efc84107,ae9d9e17da37..000000000000
--- a/drivers/scsi/hpsa.c
+++ b/drivers/scsi/hpsa.c
@@@ -4221,7 -4622,7 +4305,11 @@@ static void hpsa_get_tag(struct ctlr_in
  }
  
  static int hpsa_send_abort(struct ctlr_info *h, unsigned char *scsi3addr,
++<<<<<<< HEAD
 +	struct CommandList *abort, int swizzle)
++=======
+ 	struct CommandList *abort, int reply_queue)
++>>>>>>> 9b5c48c28f56 (hpsa: clean up aborts)
  {
  	int rc = IO_OK;
  	struct CommandList *c;
@@@ -4235,13 -4636,13 +4323,13 @@@
  	}
  
  	/* fill_cmd can't fail here, no buffer to map */
- 	(void) fill_cmd(c, HPSA_ABORT_MSG, h, abort,
+ 	(void) fill_cmd(c, HPSA_ABORT_MSG, h, &abort->Header.tag,
  		0, 0, scsi3addr, TYPE_MSG);
- 	if (swizzle)
+ 	if (h->needs_abort_tags_swizzled)
  		swizzle_abort_tag(&c->Request.CDB[4]);
 -	(void) hpsa_scsi_do_simple_cmd(h, c, reply_queue, NO_TIMEOUT);
 +	hpsa_scsi_do_simple_cmd_core(h, c);
  	hpsa_get_tag(h, abort, &taglower, &tagupper);
 -	dev_dbg(&h->pdev->dev, "%s: Tag:0x%08x:%08x: do_simple_cmd(abort) completed.\n",
 +	dev_dbg(&h->pdev->dev, "%s: Tag:0x%08x:%08x: do_simple_cmd_core completed.\n",
  		__func__, tagupper, taglower);
  	/* no unmap needed here because no data xfer. */
  
@@@ -4342,14 -4744,8 +4430,8 @@@ static int hpsa_send_reset_as_abort_ioa
  	return rc; /* success */
  }
  
- /* Some Smart Arrays need the abort tag swizzled, and some don't.  It's hard to
-  * tell which kind we're dealing with, so we send the abort both ways.  There
-  * shouldn't be any collisions between swizzled and unswizzled tags due to the
-  * way we construct our tags but we check anyway in case the assumptions which
-  * make this true someday become false.
-  */
  static int hpsa_send_abort_both_ways(struct ctlr_info *h,
 -	unsigned char *scsi3addr, struct CommandList *abort, int reply_queue)
 +	unsigned char *scsi3addr, struct CommandList *abort)
  {
  	/* ioccelerator mode 2 commands should be aborted via the
  	 * accelerated path, since RAID path is unaware of these commands,
@@@ -4357,10 -4753,30 +4439,37 @@@
  	 * Change abort to physical device reset.
  	 */
  	if (abort->cmd_type == CMD_IOACCEL2)
++<<<<<<< HEAD
 +		return hpsa_send_reset_as_abort_ioaccel2(h, scsi3addr, abort);
 +
 +	return hpsa_send_abort(h, scsi3addr, abort, 0) &&
 +			hpsa_send_abort(h, scsi3addr, abort, 1);
++=======
+ 		return hpsa_send_reset_as_abort_ioaccel2(h, scsi3addr,
+ 							abort, reply_queue);
+ 	return hpsa_send_abort(h, scsi3addr, abort, reply_queue);
+ }
+ 
+ /* Find out which reply queue a command was meant to return on */
+ static int hpsa_extract_reply_queue(struct ctlr_info *h,
+ 					struct CommandList *c)
+ {
+ 	if (c->cmd_type == CMD_IOACCEL2)
+ 		return h->ioaccel2_cmd_pool[c->cmdindex].reply_queue;
+ 	return c->Header.ReplyQueue;
++>>>>>>> 9b5c48c28f56 (hpsa: clean up aborts)
+ }
+ 
+ /*
+  * Limit concurrency of abort commands to prevent
+  * over-subscription of commands
+  */
+ static inline int wait_for_available_abort_cmd(struct ctlr_info *h)
+ {
+ #define ABORT_CMD_WAIT_MSECS 5000
+ 	return !wait_event_timeout(h->abort_cmd_wait_queue,
+ 			atomic_dec_if_positive(&h->abort_cmds_available) >= 0,
+ 			msecs_to_jiffies(ABORT_CMD_WAIT_MSECS));
  }
  
  /* Send an abort for the specified command.
@@@ -4378,15 -4794,40 +4487,17 @@@ static int hpsa_eh_abort_handler(struc
  	char msg[256];		/* For debug messaging. */
  	int ml = 0;
  	__le32 tagupper, taglower;
 -	int refcount, reply_queue;
 -
 -	if (sc == NULL)
 -		return FAILED;
  
+ 	if (sc->device == NULL)
+ 		return FAILED;
+ 
  	/* Find the controller of the command to be aborted */
  	h = sdev_to_hba(sc->device);
- 	if (WARN(h == NULL,
- 			"ABORT REQUEST FAILED, Controller lookup failed.\n"))
+ 	if (h == NULL)
  		return FAILED;
  
 -	/* Find the device of the command to be aborted */
 -	dev = sc->device->hostdata;
 -	if (!dev) {
 -		dev_err(&h->pdev->dev, "%s FAILED, Device lookup failed.\n",
 -				msg);
 -		return FAILED;
 -	}
 -
 -	/* If controller locked up, we can guarantee command won't complete */
 -	if (lockup_detected(h)) {
 -		hpsa_show_dev_msg(KERN_WARNING, h, dev,
 -					"ABORT FAILED, lockup detected");
 -		return FAILED;
 -	}
 -
 -	/* This is a good time to check if controller lockup has occurred */
 -	if (detect_controller_lockup(h)) {
 -		hpsa_show_dev_msg(KERN_WARNING, h, dev,
 -					"ABORT FAILED, new lockup detected");
 +	if (lockup_detected(h))
  		return FAILED;
 -	}
  
  	/* Check that controller supports some kind of task abort */
  	if (!(HPSATMF_PHYS_TASK_ABORT & h->TMFSupportFlags) &&
@@@ -4409,13 -4843,26 +4520,21 @@@
  	/* Get SCSI command to be aborted */
  	abort = (struct CommandList *) sc->host_scribble;
  	if (abort == NULL) {
 -		/* This can happen if the command already completed. */
 -		return SUCCESS;
 -	}
 -	refcount = atomic_inc_return(&abort->refcount);
 -	if (refcount == 1) { /* Command is done already. */
 -		cmd_free(h, abort);
 -		return SUCCESS;
 +		dev_err(&h->pdev->dev, "%s FAILED, Command to abort is NULL.\n",
 +				msg);
 +		return FAILED;
  	}
+ 
+ 	/* Don't bother trying the abort if we know it won't work. */
+ 	if (abort->cmd_type != CMD_IOACCEL2 &&
+ 		abort->cmd_type != CMD_IOACCEL1 && !dev->supports_aborts) {
+ 		cmd_free(h, abort);
+ 		return FAILED;
+ 	}
+ 
  	hpsa_get_tag(h, abort, &taglower, &tagupper);
 -	reply_queue = hpsa_extract_reply_queue(h, abort);
  	ml += sprintf(msg+ml, "Tag:0x%08x:%08x ", tagupper, taglower);
 -	as  = abort->scsi_cmd;
 +	as  = (struct scsi_cmnd *) abort->scsi_cmd;
  	if (as != NULL)
  		ml += sprintf(msg+ml, "Command:0x%x SN:0x%lx ",
  			as->cmnd[0], as->serial_number);
@@@ -4427,12 -4873,19 +4546,24 @@@
  	 * by the firmware (but not to the scsi mid layer) but we can't
  	 * distinguish which.  Send the abort down.
  	 */
++<<<<<<< HEAD
 +	rc = hpsa_send_abort_both_ways(h, dev->scsi3addr, abort);
++=======
+ 	if (wait_for_available_abort_cmd(h)) {
+ 		dev_warn(&h->pdev->dev,
+ 			"Timed out waiting for an abort command to become available.\n");
+ 		cmd_free(h, abort);
+ 		return FAILED;
+ 	}
+ 	rc = hpsa_send_abort_both_ways(h, dev->scsi3addr, abort, reply_queue);
+ 	atomic_inc(&h->abort_cmds_available);
+ 	wake_up_all(&h->abort_cmd_wait_queue);
++>>>>>>> 9b5c48c28f56 (hpsa: clean up aborts)
  	if (rc != 0) {
 -		hpsa_show_dev_msg(KERN_WARNING, h, dev,
 -					"FAILED to abort command");
 -		cmd_free(h, abort);
 +		dev_dbg(&h->pdev->dev, "%s Request FAILED.\n", msg);
 +		dev_warn(&h->pdev->dev, "FAILED abort on device C%d:B%d:T%d:L%d\n",
 +			h->scsi_host->host_no,
 +			dev->bus, dev->target, dev->lun);
  		return FAILED;
  	}
  	dev_info(&h->pdev->dev, "%s REQUEST SUCCEEDED.\n", msg);
@@@ -6713,7 -7156,20 +6846,24 @@@ reinit_after_soft_reset
  	spin_lock_init(&h->lock);
  	spin_lock_init(&h->offline_device_lock);
  	spin_lock_init(&h->scan_lock);
++<<<<<<< HEAD
 +	spin_lock_init(&h->passthru_count_lock);
++=======
+ 	atomic_set(&h->passthru_cmds_avail, HPSA_MAX_CONCURRENT_PASSTHRUS);
+ 	atomic_set(&h->abort_cmds_available, HPSA_CMDS_RESERVED_FOR_ABORTS);
+ 
+ 	h->rescan_ctlr_wq = hpsa_create_controller_wq(h, "rescan");
+ 	if (!h->rescan_ctlr_wq) {
+ 		rc = -ENOMEM;
+ 		goto clean1;
+ 	}
+ 
+ 	h->resubmit_wq = hpsa_create_controller_wq(h, "resubmit");
+ 	if (!h->resubmit_wq) {
+ 		rc = -ENOMEM;
+ 		goto clean1;
+ 	}
++>>>>>>> 9b5c48c28f56 (hpsa: clean up aborts)
  
  	/* Allocate and clear per-cpu variable lockup_detected */
  	h->lockup_detected = alloc_percpu(u32);
diff --cc drivers/scsi/hpsa.h
index bb1c5c5da1f2,df2468cd72cf..000000000000
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@@ -54,6 -60,21 +54,24 @@@ struct hpsa_scsi_dev_t 
  					 */
  	struct raid_map_data raid_map;	/* I/O accelerator RAID map */
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * Pointers from logical drive map indices to the phys drives that
+ 	 * make those logical drives.  Note, multiple logical drives may
+ 	 * share physical drives.  You can have for instance 5 physical
+ 	 * drives with 3 logical drives each using those same 5 physical
+ 	 * disks. We need these pointers for counting i/o's out to physical
+ 	 * devices in order to honor physical device queue depth limits.
+ 	 */
+ 	struct hpsa_scsi_dev_t *phys_disk[RAID_MAP_MAX_ENTRIES];
+ 	int supports_aborts;
+ #define HPSA_DO_NOT_EXPOSE	0x0
+ #define HPSA_SG_ATTACH		0x1
+ #define HPSA_ULD_ATTACH		0x2
+ #define HPSA_SCSI_ADD		(HPSA_SG_ATTACH | HPSA_ULD_ATTACH)
+ 	u8 expose_state;
++>>>>>>> 9b5c48c28f56 (hpsa: clean up aborts)
  };
  
  struct reply_queue_buffer {
@@@ -236,6 -258,11 +254,14 @@@ struct ctlr_info 
  	struct list_head offline_device_list;
  	int	acciopath_status;
  	int	raid_offload_debug;
++<<<<<<< HEAD
++=======
+ 	int	needs_abort_tags_swizzled;
+ 	struct workqueue_struct *resubmit_wq;
+ 	struct workqueue_struct *rescan_ctlr_wq;
+ 	atomic_t abort_cmds_available;
+ 	wait_queue_head_t abort_cmd_wait_queue;
++>>>>>>> 9b5c48c28f56 (hpsa: clean up aborts)
  };
  
  struct offline_device_entry {
* Unmerged path drivers/scsi/hpsa.c
* Unmerged path drivers/scsi/hpsa.h
