xfs: convert m_dirblkfsbs to xfs_da_geometry

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit d6cf13051f31bf1a54b65643d0e578b3ca2f0692
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/d6cf1305.failed

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>


(cherry picked from commit d6cf13051f31bf1a54b65643d0e578b3ca2f0692)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_da_btree.c
#	fs/xfs/xfs_dir2.c
#	fs/xfs/xfs_mount.h
diff --cc fs/xfs/xfs_da_btree.c
index 4db5102d403a,70b934392f73..000000000000
--- a/fs/xfs/xfs_da_btree.c
+++ b/fs/xfs/xfs_da_btree.c
@@@ -2095,15 -2094,8 +2094,20 @@@ xfs_da_grow_inode
  
  	trace_xfs_da_grow_inode(args);
  
++<<<<<<< HEAD
 +	if (args->whichfork == XFS_DATA_FORK) {
 +		bno = args->dp->i_mount->m_dirleafblk;
 +		count = args->dp->i_mount->m_dirblkfsbs;
 +	} else {
 +		bno = 0;
 +		count = 1;
 +	}
 +
 +	error = xfs_da_grow_inode_int(args, &bno, count);
++=======
+ 	bno = args->geo->leafblk;
+ 	error = xfs_da_grow_inode_int(args, &bno, args->geo->fsbcount);
++>>>>>>> d6cf13051f31 (xfs: convert m_dirblkfsbs to xfs_da_geometry)
  	if (!error)
  		*new_blkno = (xfs_dablk_t)bno;
  	return error;
diff --cc fs/xfs/xfs_dir2.c
index b4210d6721ad,3fbf0110eeb3..000000000000
--- a/fs/xfs/xfs_dir2.c
+++ b/fs/xfs/xfs_dir2.c
@@@ -141,10 -146,6 +141,13 @@@ xfs_da_mount
  
  	/* XXX: these are to be removed as code is converted to use geo */
  	mp->m_dirblksize = mp->m_dir_geo->blksize;
++<<<<<<< HEAD
 +	mp->m_dirblkfsbs = mp->m_dir_geo->fsbcount;
 +	mp->m_dirdatablk = mp->m_dir_geo->datablk;
 +	mp->m_dirleafblk = mp->m_dir_geo->leafblk;
 +	mp->m_dirfreeblk = mp->m_dir_geo->freeblk;
++=======
++>>>>>>> d6cf13051f31 (xfs: convert m_dirblkfsbs to xfs_da_geometry)
  	mp->m_dir_node_ents = mp->m_dir_geo->node_ents;
  	mp->m_dir_magicpct = mp->m_dir_geo->magicpct;
  	mp->m_attr_node_ents = mp->m_attr_geo->node_ents;
diff --cc fs/xfs/xfs_mount.h
index 2f4a123357f9,a23e7b63d420..000000000000
--- a/fs/xfs/xfs_mount.h
+++ b/fs/xfs/xfs_mount.h
@@@ -155,10 -155,6 +155,13 @@@ typedef struct xfs_mount 
  	const struct xfs_dir_ops *m_dir_inode_ops; /* vector of dir inode ops */
  	const struct xfs_dir_ops *m_nondir_inode_ops; /* !dir inode ops */
  	int			m_dirblksize;	/* directory block sz--bytes */
++<<<<<<< HEAD
 +	int			m_dirblkfsbs;	/* directory block sz--fsbs */
 +	xfs_dablk_t		m_dirdatablk;	/* blockno of dir data v2 */
 +	xfs_dablk_t		m_dirleafblk;	/* blockno of dir non-data v2 */
 +	xfs_dablk_t		m_dirfreeblk;	/* blockno of dirfreeindex v2 */
++=======
++>>>>>>> d6cf13051f31 (xfs: convert m_dirblkfsbs to xfs_da_geometry)
  	uint			m_chsize;	/* size of next field */
  	atomic_t		m_active_trans;	/* number trans frozen */
  #ifdef HAVE_PERCPU_SB
diff --git a/fs/xfs/xfs_bmap.c b/fs/xfs/xfs_bmap.c
index b6f15ccf3239..13c9139919a4 100644
--- a/fs/xfs/xfs_bmap.c
+++ b/fs/xfs/xfs_bmap.c
@@ -1098,10 +1098,11 @@ xfs_bmap_add_attrfork_local(
 
 	if (S_ISDIR(ip->i_d.di_mode)) {
 		memset(&dargs, 0, sizeof(dargs));
+		dargs.geo = ip->i_mount->m_dir_geo;
 		dargs.dp = ip;
 		dargs.firstblock = firstblock;
 		dargs.flist = flist;
-		dargs.total = ip->i_mount->m_dirblkfsbs;
+		dargs.total = dargs.geo->fsbcount;
 		dargs.whichfork = XFS_DATA_FORK;
 		dargs.trans = tp;
 		return xfs_dir2_sf_to_block(&dargs);
* Unmerged path fs/xfs/xfs_da_btree.c
* Unmerged path fs/xfs/xfs_dir2.c
diff --git a/fs/xfs/xfs_dir2_leaf.c b/fs/xfs/xfs_dir2_leaf.c
index 4d5097750d39..8c63af4a46a0 100644
--- a/fs/xfs/xfs_dir2_leaf.c
+++ b/fs/xfs/xfs_dir2_leaf.c
@@ -1711,7 +1711,7 @@ xfs_dir2_node_to_leaf(
 	if ((error = xfs_bmap_last_offset(tp, dp, &fo, XFS_DATA_FORK))) {
 		return error;
 	}
-	fo -= mp->m_dirblkfsbs;
+	fo -= args->geo->fsbcount;
 	/*
 	 * If there are freespace blocks other than the first one,
 	 * take this opportunity to remove trailing empty freespace blocks
@@ -1723,7 +1723,7 @@ xfs_dir2_node_to_leaf(
 			return error;
 		}
 		if (rval)
-			fo -= mp->m_dirblkfsbs;
+			fo -= args->geo->fsbcount;
 		else
 			return 0;
 	}
diff --git a/fs/xfs/xfs_dir2_readdir.c b/fs/xfs/xfs_dir2_readdir.c
index d6645e8c5ecc..dbe56ba3aee1 100644
--- a/fs/xfs/xfs_dir2_readdir.c
+++ b/fs/xfs/xfs_dir2_readdir.c
@@ -317,12 +317,12 @@ xfs_dir2_leaf_readbuf(
 	if (bp) {
 		xfs_trans_brelse(NULL, bp);
 		bp = NULL;
-		mip->map_blocks -= mp->m_dirblkfsbs;
+		mip->map_blocks -= geo->fsbcount;
 		/*
 		 * Loop to get rid of the extents for the
 		 * directory block.
 		 */
-		for (i = mp->m_dirblkfsbs; i > 0; ) {
+		for (i = geo->fsbcount; i > 0; ) {
 			j = min_t(int, map->br_blockcount, i);
 			map->br_blockcount -= j;
 			map->br_startblock += j;
@@ -413,7 +413,7 @@ xfs_dir2_leaf_readbuf(
 	 */
 	mip->curdb = xfs_dir2_da_to_db(mp, map->br_startoff);
 	error = xfs_dir3_data_read(NULL, dp, map->br_startoff,
-			map->br_blockcount >= mp->m_dirblkfsbs ?
+			map->br_blockcount >= geo->fsbcount ?
 			    XFS_FSB_TO_DADDR(mp, map->br_startblock) : -1, &bp);
 
 	/*
@@ -427,7 +427,7 @@ xfs_dir2_leaf_readbuf(
 	 * was previously ra.
 	 */
 	if (mip->ra_current)
-		mip->ra_current -= mp->m_dirblkfsbs;
+		mip->ra_current -= geo->fsbcount;
 
 	/*
 	 * Do we need more readahead?
@@ -435,13 +435,13 @@ xfs_dir2_leaf_readbuf(
 	blk_start_plug(&plug);
 	for (mip->ra_index = mip->ra_offset = i = 0;
 	     mip->ra_want > mip->ra_current && i < mip->map_blocks;
-	     i += mp->m_dirblkfsbs) {
+	     i += geo->fsbcount) {
 		ASSERT(mip->ra_index < mip->map_valid);
 		/*
 		 * Read-ahead a contiguous directory block.
 		 */
 		if (i > mip->ra_current &&
-		    map[mip->ra_index].br_blockcount >= mp->m_dirblkfsbs) {
+		    map[mip->ra_index].br_blockcount >= geo->fsbcount) {
 			xfs_dir3_data_readahead(dp,
 				map[mip->ra_index].br_startoff + mip->ra_offset,
 				XFS_FSB_TO_DADDR(mp,
@@ -464,12 +464,12 @@ xfs_dir2_leaf_readbuf(
 		/*
 		 * Advance offset through the mapping table.
 		 */
-		for (j = 0; j < mp->m_dirblkfsbs; j += length ) {
+		for (j = 0; j < geo->fsbcount; j += length ) {
 			/*
 			 * The rest of this extent but not more than a dir
 			 * block.
 			 */
-			length = min_t(int, mp->m_dirblkfsbs,
+			length = min_t(int, geo->fsbcount,
 					map[mip->ra_index].br_blockcount -
 							mip->ra_offset);
 			mip->ra_offset += length;
* Unmerged path fs/xfs/xfs_mount.h
diff --git a/fs/xfs/xfs_symlink.c b/fs/xfs/xfs_symlink.c
index 0816b4018dfc..d69363c833e1 100644
--- a/fs/xfs/xfs_symlink.c
+++ b/fs/xfs/xfs_symlink.c
@@ -27,6 +27,7 @@
 #include "xfs_ag.h"
 #include "xfs_mount.h"
 #include "xfs_da_format.h"
+#include "xfs_da_btree.h"
 #include "xfs_dir2.h"
 #include "xfs_inode.h"
 #include "xfs_ialloc.h"
diff --git a/fs/xfs/xfs_trans_resv.c b/fs/xfs/xfs_trans_resv.c
index be8e370802d6..e978ae0bb76b 100644
--- a/fs/xfs/xfs_trans_resv.c
+++ b/fs/xfs/xfs_trans_resv.c
@@ -26,6 +26,7 @@
 #include "xfs_ag.h"
 #include "xfs_mount.h"
 #include "xfs_da_format.h"
+#include "xfs_da_btree.h"
 #include "xfs_inode.h"
 #include "xfs_bmap_btree.h"
 #include "xfs_ialloc.h"
diff --git a/fs/xfs/xfs_trans_space.h b/fs/xfs/xfs_trans_space.h
index df4c1f81884c..bf9c4579334d 100644
--- a/fs/xfs/xfs_trans_space.h
+++ b/fs/xfs/xfs_trans_space.h
@@ -28,7 +28,8 @@
 	(((b + XFS_MAX_CONTIG_EXTENTS_PER_BLOCK(mp) - 1) / \
 	  XFS_MAX_CONTIG_EXTENTS_PER_BLOCK(mp)) * \
 	  XFS_EXTENTADD_SPACE_RES(mp,w))
-#define	XFS_DAENTER_1B(mp,w)	((w) == XFS_DATA_FORK ? (mp)->m_dirblkfsbs : 1)
+#define	XFS_DAENTER_1B(mp,w)	\
+	((w) == XFS_DATA_FORK ? (mp)->m_dir_geo->fsbcount : 1)
 #define	XFS_DAENTER_DBS(mp,w)	\
 	(XFS_DA_NODE_MAXDEPTH + (((w) == XFS_DATA_FORK) ? 2 : 0))
 #define	XFS_DAENTER_BLOCKS(mp,w)	\
@@ -55,7 +56,7 @@
  * Space reservation values for various transactions.
  */
 #define	XFS_ADDAFORK_SPACE_RES(mp)	\
-	((mp)->m_dirblkfsbs + XFS_DAENTER_BMAP1B(mp, XFS_DATA_FORK))
+	((mp)->m_dir_geo->fsbcount + XFS_DAENTER_BMAP1B(mp, XFS_DATA_FORK))
 #define	XFS_ATTRRM_SPACE_RES(mp)	\
 	XFS_DAREMOVE_SPACE_RES(mp, XFS_ATTR_FORK)
 /* This macro is not used - see inline code in xfs_attr_set */
