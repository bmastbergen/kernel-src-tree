ALSA: hda - Make snd_hda_bus_type public

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [alsa] hda - Make snd_hda_bus_type public (Jaroslav Kysela) [1197064]
Rebuild_FUZZ: 91.89%
commit-author Takashi Iwai <tiwai@suse.de>
commit e3d280fc6d42017b2379503fbda83655a05294fe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/e3d280fc.failed

Define the common hd-audio driver and device types to bind over
snd_hda_bus_type publicly.  This allows to implement other type of
device and driver code over hd-audio bus.

Now both struct hda_codec and struct hda_codec_driver inherit these
new struct hdac_device and struct hdac_driver, respectively.

The bus registration is done in subsys_initcall() to assure it
before any other driver registrations.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit e3d280fc6d42017b2379503fbda83655a05294fe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/hda_bind.c
diff --cc sound/pci/hda/hda_bind.c
index a49bc45c2ea5,e3bd2807b644..000000000000
--- a/sound/pci/hda/hda_bind.c
+++ b/sound/pci/hda/hda_bind.c
@@@ -145,13 -146,24 +145,26 @@@ static int hda_codec_driver_remove(stru
  int __hda_codec_driver_register(struct hda_codec_driver *drv, const char *name,
  			       struct module *owner)
  {
++<<<<<<< HEAD
 +	drv->driver.name = name;
 +	drv->driver.owner = owner;
 +	drv->driver.bus = &snd_hda_bus_type;
 +	drv->driver.probe = hda_codec_driver_probe;
 +	drv->driver.remove = hda_codec_driver_remove;
 +	drv->driver.pm = &hda_codec_driver_pm;
 +	return driver_register(&drv->driver);
++=======
+ 	drv->core.driver.name = name;
+ 	drv->core.driver.owner = owner;
+ 	drv->core.driver.bus = &snd_hda_bus_type;
+ 	drv->core.driver.probe = hda_codec_driver_probe;
+ 	drv->core.driver.remove = hda_codec_driver_remove;
+ 	drv->core.driver.shutdown = hda_codec_driver_shutdown;
+ 	drv->core.driver.pm = &hda_codec_driver_pm;
+ 	drv->core.type = HDA_DEV_LEGACY;
+ 	drv->core.match = hda_codec_match;
+ 	return driver_register(&drv->core.driver);
++>>>>>>> e3d280fc6d42 (ALSA: hda - Make snd_hda_bus_type public)
  }
  EXPORT_SYMBOL_GPL(__hda_codec_driver_register);
  
diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
new file mode 100644
index 000000000000..2381509bee9f
--- /dev/null
+++ b/include/sound/hdaudio.h
@@ -0,0 +1,42 @@
+/*
+ * HD-audio core stuff
+ */
+
+#ifndef __SOUND_HDAUDIO_H
+#define __SOUND_HDAUDIO_H
+
+#include <linux/device.h>
+
+/*
+ * exported bus type
+ */
+extern struct bus_type snd_hda_bus_type;
+
+/*
+ * HD-audio codec base device
+ */
+struct hdac_device {
+	struct device dev;
+	int type;
+};
+
+/* device/driver type used for matching */
+enum {
+	HDA_DEV_CORE,
+	HDA_DEV_LEGACY,
+};
+
+#define dev_to_hdac_dev(_dev)	container_of(_dev, struct hdac_device, dev)
+
+/*
+ * HD-audio codec base driver
+ */
+struct hdac_driver {
+	struct device_driver driver;
+	int type;
+	int (*match)(struct hdac_device *dev, struct hdac_driver *drv);
+};
+
+#define drv_to_hdac_driver(_drv) container_of(_drv, struct hdac_driver, driver)
+
+#endif /* __SOUND_HDAUDIO_H */
diff --git a/sound/Kconfig b/sound/Kconfig
index c710ce2c5c37..5a240e050ae6 100644
--- a/sound/Kconfig
+++ b/sound/Kconfig
@@ -76,6 +76,8 @@ source "sound/isa/Kconfig"
 
 source "sound/pci/Kconfig"
 
+source "sound/hda/Kconfig"
+
 source "sound/ppc/Kconfig"
 
 source "sound/aoa/Kconfig"
diff --git a/sound/Makefile b/sound/Makefile
index ce9132b1c395..77320709fd26 100644
--- a/sound/Makefile
+++ b/sound/Makefile
@@ -6,7 +6,7 @@ obj-$(CONFIG_SOUND_PRIME) += sound_firmware.o
 obj-$(CONFIG_SOUND_PRIME) += oss/
 obj-$(CONFIG_DMASOUND) += oss/
 obj-$(CONFIG_SND) += core/ i2c/ drivers/ isa/ pci/ ppc/ arm/ sh/ synth/ usb/ \
-	firewire/ sparc/ spi/ parisc/ pcmcia/ mips/ soc/ atmel/
+	firewire/ sparc/ spi/ parisc/ pcmcia/ mips/ soc/ atmel/ hda/
 obj-$(CONFIG_SND_AOA) += aoa/
 
 # This one must be compilable even if sound is configured out
diff --git a/sound/hda/Kconfig b/sound/hda/Kconfig
new file mode 100644
index 000000000000..4f428ccf64ad
--- /dev/null
+++ b/sound/hda/Kconfig
@@ -0,0 +1,2 @@
+config SND_HDA_CORE
+	tristate
diff --git a/sound/hda/Makefile b/sound/hda/Makefile
new file mode 100644
index 000000000000..59c8d1feb5aa
--- /dev/null
+++ b/sound/hda/Makefile
@@ -0,0 +1,3 @@
+snd-hda-core-objs := hda_bus_type.o
+
+obj-$(CONFIG_SND_HDA_CORE) += snd-hda-core.o
diff --git a/sound/hda/hda_bus_type.c b/sound/hda/hda_bus_type.c
new file mode 100644
index 000000000000..519914a12e8a
--- /dev/null
+++ b/sound/hda/hda_bus_type.c
@@ -0,0 +1,42 @@
+/*
+ * HD-audio bus
+ */
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/export.h>
+#include <sound/hdaudio.h>
+
+MODULE_DESCRIPTION("HD-audio bus");
+MODULE_LICENSE("GPL");
+
+static int hda_bus_match(struct device *dev, struct device_driver *drv)
+{
+	struct hdac_device *hdev = dev_to_hdac_dev(dev);
+	struct hdac_driver *hdrv = drv_to_hdac_driver(drv);
+
+	if (hdev->type != hdrv->type)
+		return 0;
+	if (hdrv->match)
+		return hdrv->match(hdev, hdrv);
+	return 1;
+}
+
+struct bus_type snd_hda_bus_type = {
+	.name = "hdaudio",
+	.match = hda_bus_match,
+};
+EXPORT_SYMBOL_GPL(snd_hda_bus_type);
+
+static int __init hda_bus_init(void)
+{
+	return bus_register(&snd_hda_bus_type);
+}
+
+static void __exit hda_bus_exit(void)
+{
+	bus_unregister(&snd_hda_bus_type);
+}
+
+subsys_initcall(hda_bus_init);
+module_exit(hda_bus_exit);
diff --git a/sound/pci/hda/Kconfig b/sound/pci/hda/Kconfig
index 7f0f2c5a4e97..a5ed1c181784 100644
--- a/sound/pci/hda/Kconfig
+++ b/sound/pci/hda/Kconfig
@@ -5,6 +5,7 @@ config SND_HDA
 	select SND_PCM
 	select SND_VMASTER
 	select SND_KCTL_JACK
+	select SND_HDA_CORE
 
 config SND_HDA_INTEL
 	tristate "HD Audio PCI"
* Unmerged path sound/pci/hda/hda_bind.c
diff --git a/sound/pci/hda/hda_codec.c b/sound/pci/hda/hda_codec.c
index 05cb5f57659a..221f9cac830a 100644
--- a/sound/pci/hda/hda_codec.c
+++ b/sound/pci/hda/hda_codec.c
@@ -1312,6 +1312,7 @@ int snd_hda_codec_new(struct hda_bus *bus, struct snd_card *card,
 	dev_set_name(dev, "hdaudioC%dD%d", card->number, codec_addr);
 	dev_set_drvdata(dev, codec); /* for sysfs */
 	device_enable_async_suspend(dev);
+	codec->core.type = HDA_DEV_LEGACY;
 
 	codec->bus = bus;
 	codec->card = card;
diff --git a/sound/pci/hda/hda_codec.h b/sound/pci/hda/hda_codec.h
index 4f8090e5338d..24f8a7094d9d 100644
--- a/sound/pci/hda/hda_codec.h
+++ b/sound/pci/hda/hda_codec.h
@@ -26,6 +26,7 @@
 #include <sound/control.h>
 #include <sound/pcm.h>
 #include <sound/hwdep.h>
+#include <sound/hdaudio.h>
 #include <sound/hda_verbs.h>
 
 /*
@@ -177,7 +178,7 @@ struct hda_codec_preset {
 #define HDA_CODEC_ID_GENERIC		0x00000201
 
 struct hda_codec_driver {
-	struct device_driver driver;
+	struct hdac_driver core;
 	const struct hda_codec_preset *preset;
 };
 
@@ -281,7 +282,7 @@ struct hda_pcm {
 
 /* codec information */
 struct hda_codec {
-	struct device dev;
+	struct hdac_device core;
 	struct hda_bus *bus;
 	struct snd_card *card;
 	unsigned int addr;	/* codec addr*/
@@ -415,10 +416,8 @@ struct hda_codec {
 	struct snd_array verbs;
 };
 
-#define dev_to_hda_codec(_dev)	container_of(_dev, struct hda_codec, dev)
-#define hda_codec_dev(_dev)	(&(_dev)->dev)
-
-extern struct bus_type snd_hda_bus_type;
+#define dev_to_hda_codec(_dev)	container_of(_dev, struct hda_codec, core.dev)
+#define hda_codec_dev(_dev)	(&(_dev)->core.dev)
 
 /* direction */
 enum {
