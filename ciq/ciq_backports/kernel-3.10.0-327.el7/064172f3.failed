nfs41: allow LD to choose DS connection auth flavor

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Peng Tao <tao.peng@primarydata.com>
commit 064172f3459a914277aa309b2afd3bd5d1c3289a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/064172f3.failed

flexfile layout may use different auth flavor as specified by MDS.

	Reviewed-by: Jeff Layton <jlayton@primarydata.com>
	Signed-off-by: Peng Tao <tao.peng@primarydata.com>
	Signed-off-by: Tom Haynes <Thomas.Haynes@primarydata.com>
(cherry picked from commit 064172f3459a914277aa309b2afd3bd5d1c3289a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/filelayout/filelayoutdev.c
#	fs/nfs/pnfs.h
#	fs/nfs/pnfs_nfs.c
diff --cc fs/nfs/filelayout/filelayoutdev.c
index b394f8c6697b,5e4b0cea84c8..000000000000
--- a/fs/nfs/filelayout/filelayoutdev.c
+++ b/fs/nfs/filelayout/filelayoutdev.c
@@@ -716,18 -277,10 +716,24 @@@ nfs4_fl_prepare_ds(struct pnfs_layout_s
  	if (ds->ds_clp)
  		goto out_test_devid;
  
++<<<<<<< HEAD
 +	if (test_and_set_bit(NFS4DS_CONNECTING, &ds->ds_state) == 0) {
 +		struct nfs_server *s = NFS_SERVER(lseg->pls_layout->plh_inode);
 +		int err;
++=======
+ 	nfs4_pnfs_ds_connect(s, ds, devid, dataserver_timeo,
+ 			     dataserver_retrans,
+ 			     s->nfs_client->cl_rpcclient->cl_auth->au_flavor);
 -
++>>>>>>> 064172f3459a (nfs41: allow LD to choose DS connection auth flavor)
 +
 +		err = nfs4_ds_connect(s, ds);
 +		if (err)
 +			nfs4_mark_deviceid_unavailable(devid);
 +		nfs4_clear_ds_conn_bit(ds);
 +	} else {
 +		/* Either ds is connected, or ds is NULL */
 +		nfs4_wait_ds_connect(ds);
 +	}
  out_test_devid:
  	if (filelayout_test_devid_unavailable(devid))
  		ret = NULL;
diff --cc fs/nfs/pnfs.h
index 959dfb9c2be3,2ea9e9a7d85e..000000000000
--- a/fs/nfs/pnfs.h
+++ b/fs/nfs/pnfs.h
@@@ -277,8 -292,32 +277,37 @@@ bool nfs4_put_deviceid_node(struct nfs4
  void nfs4_mark_deviceid_unavailable(struct nfs4_deviceid_node *node);
  bool nfs4_test_deviceid_unavailable(struct nfs4_deviceid_node *node);
  void nfs4_deviceid_purge_client(const struct nfs_client *);
++<<<<<<< HEAD
 +int nfs4_deviceid_getdevicelist(struct nfs_server *server,
 +		const struct nfs_fh *fh);
++=======
+ 
+ /* pnfs_nfs.c */
+ void pnfs_generic_clear_request_commit(struct nfs_page *req,
+ 				       struct nfs_commit_info *cinfo);
+ void pnfs_generic_commit_release(void *calldata);
+ void pnfs_generic_prepare_to_resend_writes(struct nfs_commit_data *data);
+ void pnfs_generic_rw_release(void *data);
+ void pnfs_generic_recover_commit_reqs(struct list_head *dst,
+ 				      struct nfs_commit_info *cinfo);
+ int pnfs_generic_commit_pagelist(struct inode *inode,
+ 				 struct list_head *mds_pages,
+ 				 int how,
+ 				 struct nfs_commit_info *cinfo,
+ 				 int (*initiate_commit)(struct nfs_commit_data *data,
+ 							int how));
+ int pnfs_generic_scan_commit_lists(struct nfs_commit_info *cinfo, int max);
+ void pnfs_generic_write_commit_done(struct rpc_task *task, void *data);
+ void nfs4_pnfs_ds_put(struct nfs4_pnfs_ds *ds);
+ struct nfs4_pnfs_ds *nfs4_pnfs_ds_add(struct list_head *dsaddrs,
+ 				      gfp_t gfp_flags);
+ void nfs4_pnfs_ds_connect(struct nfs_server *mds_srv, struct nfs4_pnfs_ds *ds,
+ 			  struct nfs4_deviceid_node *devid, unsigned int timeo,
+ 			  unsigned int retrans, rpc_authflavor_t au_flavor);
+ struct nfs4_pnfs_ds_addr *nfs4_decode_mp_ds_addr(struct net *net,
+ 						 struct xdr_stream *xdr,
+ 						 gfp_t gfp_flags);
++>>>>>>> 064172f3459a (nfs41: allow LD to choose DS connection auth flavor)
  
  static inline struct nfs4_deviceid_node *
  nfs4_get_deviceid(struct nfs4_deviceid_node *d)
* Unmerged path fs/nfs/pnfs_nfs.c
* Unmerged path fs/nfs/filelayout/filelayoutdev.c
diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 8d3539215946..16b5692e6d64 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -189,7 +189,8 @@ extern struct nfs_client *nfs4_set_ds_client(struct nfs_client* mds_clp,
 					     const struct sockaddr *ds_addr,
 					     int ds_addrlen, int ds_proto,
 					     unsigned int ds_timeo,
-					     unsigned int ds_retrans);
+					     unsigned int ds_retrans,
+					     rpc_authflavor_t au_flavor);
 extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,
 						struct inode *);
 #ifdef CONFIG_PROC_FS
diff --git a/fs/nfs/nfs4client.c b/fs/nfs/nfs4client.c
index 4a5c6e09b628..3231f62d7848 100644
--- a/fs/nfs/nfs4client.c
+++ b/fs/nfs/nfs4client.c
@@ -845,7 +845,8 @@ error:
  */
 struct nfs_client *nfs4_set_ds_client(struct nfs_client* mds_clp,
 		const struct sockaddr *ds_addr, int ds_addrlen,
-		int ds_proto, unsigned int ds_timeo, unsigned int ds_retrans)
+		int ds_proto, unsigned int ds_timeo, unsigned int ds_retrans,
+		rpc_authflavor_t au_flavor)
 {
 	struct nfs_client_initdata cl_init = {
 		.addr = ds_addr,
@@ -870,7 +871,7 @@ struct nfs_client *nfs4_set_ds_client(struct nfs_client* mds_clp,
 	 */
 	nfs_init_timeout_values(&ds_timeout, ds_proto, ds_timeo, ds_retrans);
 	clp = nfs_get_client(&cl_init, &ds_timeout, mds_clp->cl_ipaddr,
-			     mds_clp->cl_rpcclient->cl_auth->au_flavor);
+			     au_flavor);
 
 	dprintk("<-- %s %p\n", __func__, clp);
 	return clp;
* Unmerged path fs/nfs/pnfs.h
* Unmerged path fs/nfs/pnfs_nfs.c
