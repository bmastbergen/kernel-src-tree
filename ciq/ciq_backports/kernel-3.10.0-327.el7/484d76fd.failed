be2net: refactor adapter resource initialzation sequence into be_resume()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Kalesh AP <kalesh.purayil@emulex.com>
commit 484d76fd5154d7d7dcc8e5928a947deb9cc0b94c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/484d76fd.failed

Most of the adapter initialisation sequences performed in be_resume(),
be_eeh_resume() and be_err_recover() are same. Renamed be_resume() to
be_pci_resume() and moved the common code to a new routine be_resume() to
avoid code duplication.

	Signed-off-by: Kalesh AP <kalesh.purayil@emulex.com>
	Signed-off-by: Sathya Perla <sathya.perla@emulex.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 484d76fd5154d7d7dcc8e5928a947deb9cc0b94c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/emulex/benet/be_main.c
diff --cc drivers/net/ethernet/emulex/benet/be_main.c
index b2184bdb8a43,80a0aabfbcf8..000000000000
--- a/drivers/net/ethernet/emulex/benet/be_main.c
+++ b/drivers/net/ethernet/emulex/benet/be_main.c
@@@ -4622,261 -4903,84 +4622,285 @@@ static void be_netdev_init(struct net_d
  	netdev->ethtool_ops = &be_ethtool_ops;
  }
  
 -/* If any VFs are already enabled don't FLR the PF */
 -static bool be_reset_required(struct be_adapter *adapter)
 +static void be_unmap_pci_bars(struct be_adapter *adapter)
  {
 -	return pci_num_vf(adapter->pdev) ? false : true;
 +	if (adapter->csr)
 +		pci_iounmap(adapter->pdev, adapter->csr);
 +	if (adapter->db)
 +		pci_iounmap(adapter->pdev, adapter->db);
  }
  
 -/* Wait for the FW to be ready and perform the required initialization */
 -static int be_func_init(struct be_adapter *adapter)
 +static int db_bar(struct be_adapter *adapter)
  {
 -	int status;
 -
 -	status = be_fw_wait_ready(adapter);
 -	if (status)
 -		return status;
 +	if (lancer_chip(adapter) || !be_physfn(adapter))
 +		return 0;
 +	else
 +		return 4;
 +}
  
 -	if (be_reset_required(adapter)) {
 -		status = be_cmd_reset_function(adapter);
 -		if (status)
 -			return status;
 +static int be_roce_map_pci_bars(struct be_adapter *adapter)
 +{
 +	if (skyhawk_chip(adapter)) {
 +		adapter->roce_db.size = 4096;
 +		adapter->roce_db.io_addr = pci_resource_start(adapter->pdev,
 +							      db_bar(adapter));
 +		adapter->roce_db.total_size = pci_resource_len(adapter->pdev,
 +							       db_bar(adapter));
 +	}
 +	return 0;
 +}
  
 -		/* Wait for interrupts to quiesce after an FLR */
 -		msleep(100);
++<<<<<<< HEAD
 +static int be_map_pci_bars(struct be_adapter *adapter)
 +{
 +	struct pci_dev *pdev = adapter->pdev;
 +	u8 __iomem *addr;
  
 -		/* We can clear all errors when function reset succeeds */
 -		be_clear_all_error(adapter);
 +	if (BEx_chip(adapter) && be_physfn(adapter)) {
 +		adapter->csr = pci_iomap(pdev, 2, 0);
 +		if (!adapter->csr)
 +			return -ENOMEM;
  	}
  
 -	/* Tell FW we're ready to fire cmds */
 -	status = be_cmd_fw_init(adapter);
 -	if (status)
 -		return status;
 +	addr = pci_iomap(pdev, db_bar(adapter), 0);
 +	if (!addr)
 +		goto pci_map_err;
 +	adapter->db = addr;
  
 -	/* Allow interrupts for other ULPs running on NIC function */
 -	be_intr_set(adapter, true);
 +	if (skyhawk_chip(adapter) || BEx_chip(adapter)) {
 +		if (be_physfn(adapter)) {
 +			/* PCICFG is the 2nd BAR in BE2 */
 +			addr = pci_iomap(pdev, BE2_chip(adapter) ? 1 : 0, 0);
 +			if (!addr)
 +				goto pci_map_err;
 +			adapter->pcicfg = addr;
 +		} else {
 +			adapter->pcicfg = adapter->db + SRIOV_VF_PCICFG_OFFSET;
 +		}
 +	}
  
 +	be_roce_map_pci_bars(adapter);
  	return 0;
 -}
  
 +pci_map_err:
 +	dev_err(&pdev->dev, "Error in mapping PCI BARs\n");
 +	be_unmap_pci_bars(adapter);
 +	return -ENOMEM;
 +}
 +
 +static void be_ctrl_cleanup(struct be_adapter *adapter)
 +{
 +	struct be_dma_mem *mem = &adapter->mbox_mem_alloced;
 +
 +	be_unmap_pci_bars(adapter);
 +
 +	if (mem->va)
 +		dma_free_coherent(&adapter->pdev->dev, mem->size, mem->va,
 +				  mem->dma);
 +
 +	mem = &adapter->rx_filter;
 +	if (mem->va)
 +		dma_free_coherent(&adapter->pdev->dev, mem->size, mem->va,
 +				  mem->dma);
 +}
 +
 +static int be_ctrl_init(struct be_adapter *adapter)
 +{
 +	struct be_dma_mem *mbox_mem_alloc = &adapter->mbox_mem_alloced;
 +	struct be_dma_mem *mbox_mem_align = &adapter->mbox_mem;
 +	struct be_dma_mem *rx_filter = &adapter->rx_filter;
 +	u32 sli_intf;
 +	int status;
 +
 +	pci_read_config_dword(adapter->pdev, SLI_INTF_REG_OFFSET, &sli_intf);
 +	adapter->sli_family = (sli_intf & SLI_INTF_FAMILY_MASK) >>
 +				 SLI_INTF_FAMILY_SHIFT;
 +	adapter->virtfn = (sli_intf & SLI_INTF_FT_MASK) ? 1 : 0;
 +
 +	status = be_map_pci_bars(adapter);
 +	if (status)
 +		goto done;
 +
 +	mbox_mem_alloc->size = sizeof(struct be_mcc_mailbox) + 16;
 +	mbox_mem_alloc->va = dma_alloc_coherent(&adapter->pdev->dev,
 +						mbox_mem_alloc->size,
 +						&mbox_mem_alloc->dma,
 +						GFP_KERNEL);
 +	if (!mbox_mem_alloc->va) {
 +		status = -ENOMEM;
 +		goto unmap_pci_bars;
 +	}
 +	mbox_mem_align->size = sizeof(struct be_mcc_mailbox);
 +	mbox_mem_align->va = PTR_ALIGN(mbox_mem_alloc->va, 16);
 +	mbox_mem_align->dma = PTR_ALIGN(mbox_mem_alloc->dma, 16);
 +	memset(mbox_mem_align->va, 0, sizeof(struct be_mcc_mailbox));
 +
 +	rx_filter->size = sizeof(struct be_cmd_req_rx_filter);
 +	rx_filter->va = dma_zalloc_coherent(&adapter->pdev->dev,
 +					    rx_filter->size, &rx_filter->dma,
 +					    GFP_KERNEL);
 +	if (!rx_filter->va) {
 +		status = -ENOMEM;
 +		goto free_mbox;
 +	}
 +
 +	mutex_init(&adapter->mbox_lock);
 +	spin_lock_init(&adapter->mcc_lock);
 +	spin_lock_init(&adapter->mcc_cq_lock);
 +
 +	init_completion(&adapter->et_cmd_compl);
 +	pci_save_state(adapter->pdev);
 +	return 0;
 +
 +free_mbox:
 +	dma_free_coherent(&adapter->pdev->dev, mbox_mem_alloc->size,
 +			  mbox_mem_alloc->va, mbox_mem_alloc->dma);
 +
 +unmap_pci_bars:
 +	be_unmap_pci_bars(adapter);
 +
 +done:
 +	return status;
 +}
 +
 +static void be_stats_cleanup(struct be_adapter *adapter)
 +{
 +	struct be_dma_mem *cmd = &adapter->stats_cmd;
 +
 +	if (cmd->va)
 +		dma_free_coherent(&adapter->pdev->dev, cmd->size,
 +				  cmd->va, cmd->dma);
 +}
 +
 +static int be_stats_init(struct be_adapter *adapter)
 +{
 +	struct be_dma_mem *cmd = &adapter->stats_cmd;
 +
 +	if (lancer_chip(adapter))
 +		cmd->size = sizeof(struct lancer_cmd_req_pport_stats);
 +	else if (BE2_chip(adapter))
 +		cmd->size = sizeof(struct be_cmd_req_get_stats_v0);
 +	else if (BE3_chip(adapter))
 +		cmd->size = sizeof(struct be_cmd_req_get_stats_v1);
 +	else
 +		/* ALL non-BE ASICs */
 +		cmd->size = sizeof(struct be_cmd_req_get_stats_v2);
 +
 +	cmd->va = dma_zalloc_coherent(&adapter->pdev->dev, cmd->size, &cmd->dma,
 +				      GFP_KERNEL);
 +	if (!cmd->va)
 +		return -ENOMEM;
 +	return 0;
 +}
 +
 +static void be_remove(struct pci_dev *pdev)
 +{
 +	struct be_adapter *adapter = pci_get_drvdata(pdev);
 +
 +	if (!adapter)
 +		return;
 +
 +	be_roce_dev_remove(adapter);
 +	be_intr_set(adapter, false);
 +
 +	cancel_delayed_work_sync(&adapter->func_recovery_work);
 +
 +	unregister_netdev(adapter->netdev);
 +
 +	be_clear(adapter);
 +
 +	/* tell fw we're done with firing cmds */
 +	be_cmd_fw_clean(adapter);
 +
 +	be_stats_cleanup(adapter);
 +
 +	be_ctrl_cleanup(adapter);
 +
 +	pci_disable_pcie_error_reporting(pdev);
 +
 +	pci_release_regions(pdev);
 +	pci_disable_device(pdev);
 +
 +	free_netdev(adapter->netdev);
 +}
 +
 +static int be_get_initial_config(struct be_adapter *adapter)
 +{
 +	int status, level;
 +
 +	status = be_cmd_get_cntl_attributes(adapter);
 +	if (status)
 +		return status;
 +
 +	/* Must be a power of 2 or else MODULO will BUG_ON */
 +	adapter->be_get_temp_freq = 64;
 +
 +	if (BEx_chip(adapter)) {
 +		level = be_cmd_get_fw_log_level(adapter);
 +		adapter->msg_enable =
 +			level <= FW_LOG_LEVEL_DEFAULT ? NETIF_MSG_HW : 0;
 +	}
 +
 +	adapter->cfg_num_qs = netif_get_num_default_rss_queues();
 +	return 0;
 +}
 +
 +static int lancer_recover_func(struct be_adapter *adapter)
 +{
 +	struct device *dev = &adapter->pdev->dev;
++=======
+ static int be_resume(struct be_adapter *adapter)
+ {
+ 	struct net_device *netdev = adapter->netdev;
++>>>>>>> 484d76fd5154 (be2net: refactor adapter resource initialzation sequence into be_resume())
  	int status;
  
 -	status = be_func_init(adapter);
 +	status = lancer_test_and_set_rdy_state(adapter);
  	if (status)
- 		goto err;
+ 		return status;
  
 +	if (netif_running(adapter->netdev))
 +		be_close(adapter->netdev);
 +
 +	be_clear(adapter);
 +
 +	be_clear_all_error(adapter);
 +
  	status = be_setup(adapter);
  	if (status)
- 		goto err;
+ 		return status;
  
 -	if (netif_running(netdev)) {
 -		status = be_open(netdev);
 +	if (netif_running(adapter->netdev)) {
 +		status = be_open(adapter->netdev);
  		if (status)
- 			goto err;
+ 			return status;
  	}
  
++<<<<<<< HEAD
 +	dev_err(dev, "Adapter recovery successful\n");
++=======
+ 	netif_device_attach(netdev);
+ 
+ 	return 0;
+ }
+ 
+ static int be_err_recover(struct be_adapter *adapter)
+ {
+ 	struct device *dev = &adapter->pdev->dev;
+ 	int status;
+ 
+ 	status = be_resume(adapter);
+ 	if (status)
+ 		goto err;
+ 
+ 	dev_info(dev, "Adapter recovery successful\n");
++>>>>>>> 484d76fd5154 (be2net: refactor adapter resource initialzation sequence into be_resume())
  	return 0;
  err:
 -	if (be_physfn(adapter))
 -		dev_err(dev, "Adapter recovery failed\n");
 +	if (status == -EAGAIN)
 +		dev_err(dev, "Waiting for resource provisioning\n");
  	else
 -		dev_err(dev, "Re-trying adapter recovery\n");
 +		dev_err(dev, "Adapter recovery failed\n");
  
  	return status;
  }
@@@ -5168,30 -5435,11 +5189,38 @@@ static int be_pci_resume(struct pci_de
  	pci_set_power_state(pdev, PCI_D0);
  	pci_restore_state(pdev);
  
++<<<<<<< HEAD
 +	status = be_fw_wait_ready(adapter);
 +	if (status)
 +		return status;
 +
 +	status = be_cmd_reset_function(adapter);
 +	if (status)
 +		return status;
 +
 +	be_intr_set(adapter, true);
 +	/* tell fw we're ready to fire cmds */
 +	status = be_cmd_fw_init(adapter);
 +	if (status)
 +		return status;
 +
 +	be_setup(adapter);
 +	if (netif_running(netdev)) {
 +		rtnl_lock();
 +		be_open(netdev);
 +		rtnl_unlock();
 +	}
 +
 +	schedule_delayed_work(&adapter->func_recovery_work,
 +			      msecs_to_jiffies(1000));
 +	netif_device_attach(netdev);
++=======
+ 	status = be_resume(adapter);
+ 	if (status)
+ 		return status;
+ 
+ 	be_schedule_err_detection(adapter);
++>>>>>>> 484d76fd5154 (be2net: refactor adapter resource initialzation sequence into be_resume())
  
  	if (adapter->wol_en)
  		be_setup_wol(adapter, false);
@@@ -5296,34 -5543,11 +5324,42 @@@ static void be_eeh_resume(struct pci_de
  
  	pci_save_state(pdev);
  
++<<<<<<< HEAD
 +	status = be_cmd_reset_function(adapter);
 +	if (status)
 +		goto err;
 +
 +	/* On some BE3 FW versions, after a HW reset,
 +	 * interrupts will remain disabled for each function.
 +	 * So, explicitly enable interrupts
 +	 */
 +	be_intr_set(adapter, true);
 +
 +	/* tell fw we're ready to fire cmds */
 +	status = be_cmd_fw_init(adapter);
 +	if (status)
 +		goto err;
 +
 +	status = be_setup(adapter);
 +	if (status)
 +		goto err;
 +
 +	if (netif_running(netdev)) {
 +		status = be_open(netdev);
 +		if (status)
 +			goto err;
 +	}
 +
 +	schedule_delayed_work(&adapter->func_recovery_work,
 +			      msecs_to_jiffies(1000));
 +	netif_device_attach(netdev);
++=======
+ 	status = be_resume(adapter);
+ 	if (status)
+ 		goto err;
+ 
+ 	be_schedule_err_detection(adapter);
++>>>>>>> 484d76fd5154 (be2net: refactor adapter resource initialzation sequence into be_resume())
  	return;
  err:
  	dev_err(&adapter->pdev->dev, "EEH resume failed\n");
* Unmerged path drivers/net/ethernet/emulex/benet/be_main.c
