regcache-rbtree: Fix reg_stride != 1

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Lars-Peter Clausen <lars@metafoo.de>
commit b6752123ccef4eec3c70c20dbdfc05d1674319c5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/b6752123.failed

There are a couple of calculations, which convert between register addresses and
block indices, in regcache_rbtree_sync() and regcache_rbtree_node_alloc() which
assume that reg_stride is 1. This will break the rb cache for configurations
which do not use a reg_stride of 1.

Also rename 'base' in regcache_rbtree_sync() to 'start' to avoid confusion with
'base_reg'.

	Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
	Signed-off-by: Mark Brown <broonie@linaro.org>
(cherry picked from commit b6752123ccef4eec3c70c20dbdfc05d1674319c5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/regmap/regcache-rbtree.c
diff --cc drivers/base/regmap/regcache-rbtree.c
index bb8c3bbc7812,f2384a816cc4..000000000000
--- a/drivers/base/regmap/regcache-rbtree.c
+++ b/drivers/base/regmap/regcache-rbtree.c
@@@ -304,6 -304,48 +304,51 @@@ static int regcache_rbtree_insert_to_bl
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static struct regcache_rbtree_node *
+ regcache_rbtree_node_alloc(struct regmap *map, unsigned int reg)
+ {
+ 	struct regcache_rbtree_node *rbnode;
+ 	const struct regmap_range *range;
+ 	int i;
+ 
+ 	rbnode = kzalloc(sizeof(*rbnode), GFP_KERNEL);
+ 	if (!rbnode)
+ 		return NULL;
+ 
+ 	/* If there is a read table then use it to guess at an allocation */
+ 	if (map->rd_table) {
+ 		for (i = 0; i < map->rd_table->n_yes_ranges; i++) {
+ 			if (regmap_reg_in_range(reg,
+ 						&map->rd_table->yes_ranges[i]))
+ 				break;
+ 		}
+ 
+ 		if (i != map->rd_table->n_yes_ranges) {
+ 			range = &map->rd_table->yes_ranges[i];
+ 			rbnode->blklen = (range->range_max - range->range_min) /
+ 				map->reg_stride	+ 1;
+ 			rbnode->base_reg = range->range_min;
+ 		}
+ 	}
+ 
+ 	if (!rbnode->blklen) {
+ 		rbnode->blklen = sizeof(*rbnode);
+ 		rbnode->base_reg = reg;
+ 	}
+ 
+ 	rbnode->block = kmalloc(rbnode->blklen * map->cache_word_size,
+ 				GFP_KERNEL);
+ 	if (!rbnode->block) {
+ 		kfree(rbnode);
+ 		return NULL;
+ 	}
+ 
+ 	return rbnode;
+ }
+ 
++>>>>>>> b6752123ccef (regcache-rbtree: Fix reg_stride != 1)
  static int regcache_rbtree_write(struct regmap *map, unsigned int reg,
  				 unsigned int value)
  {
* Unmerged path drivers/base/regmap/regcache-rbtree.c
