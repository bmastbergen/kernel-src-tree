ovl: Warn on copy up if a process has a R/O fd open to the lower file

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [fs] overlayfs: Warn on copy up if a process has a R/O fd open to the lower file (David Howells) [1226346]
Rebuild_FUZZ: 95.83%
commit-author David Howells <dhowells@redhat.com>
commit fb5bb2c3b73df060d588b6521de5ab03589283f7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/fb5bb2c3.failed

Print a warning when overlayfs copies up a file if the process that
triggered the copy up has a R/O fd open to the lower file being copied up.

This can help catch applications that do things like the following:

	fd1 = open("foo", O_RDONLY);
	fd2 = open("foo", O_RDWR);

where they expect fd1 and fd2 to refer to the same file - which will no
longer be the case post-copy up.

With this patch, the following commands:

	bash 5</mnt/a/foo128
	6<>/mnt/a/foo128

assuming /mnt/a/foo128 to be an un-copied up file on an overlay will
produce the following warning in the kernel log:

	overlayfs: Copying up foo129, but open R/O on fd 5 which will cease
	to be coherent [pid=3818 bash]

This is enabled by setting:

	/sys/module/overlay/parameters/check_copy_up

to 1.

The warnings are ratelimited and are also limited to one warning per file -
assuming the copy up completes in each case.

	Signed-off-by: David Howells <dhowells@redhat.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit fb5bb2c3b73df060d588b6521de5ab03589283f7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/copy_up.c
diff --cc fs/overlayfs/copy_up.c
index 24f640441bd9,959bdcf2f9e8..000000000000
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@@ -20,11 -23,40 +23,40 @@@
  
  #define OVL_COPY_UP_CHUNK_SIZE (1 << 20)
  
+ static bool __read_mostly ovl_check_copy_up;
+ module_param_named(check_copy_up, ovl_check_copy_up, bool,
+ 		   S_IWUSR | S_IRUGO);
+ MODULE_PARM_DESC(ovl_check_copy_up,
+ 		 "Warn on copy-up when causing process also has a R/O fd open");
+ 
+ static int ovl_check_fd(const void *data, struct file *f, unsigned int fd)
+ {
+ 	const struct dentry *dentry = data;
+ 
+ 	if (f->f_inode == d_inode(dentry))
+ 		pr_warn_ratelimited("overlayfs: Warning: Copying up %pD, but open R/O on fd %u which will cease to be coherent [pid=%d %s]\n",
+ 				    f, fd, current->pid, current->comm);
+ 	return 0;
+ }
+ 
+ /*
+  * Check the fds open by this process and warn if something like the following
+  * scenario is about to occur:
+  *
+  *	fd1 = open("foo", O_RDONLY);
+  *	fd2 = open("foo", O_RDWR);
+  */
+ static void ovl_do_check_copy_up(struct dentry *dentry)
+ {
+ 	if (ovl_check_copy_up)
+ 		iterate_fd(current->files, 0, ovl_check_fd, dentry);
+ }
+ 
  int ovl_copy_xattr(struct dentry *old, struct dentry *new)
  {
 -	ssize_t list_size, size, value_size = 0;
 -	char *buf, *name, *value = NULL;
 -	int uninitialized_var(error);
 +	ssize_t list_size, size;
 +	char *buf, *name, *value;
 +	int error;
  
  	if (!old->d_inode->i_op->getxattr ||
  	    !new->d_inode->i_op->getxattr)
@@@ -299,6 -338,11 +331,14 @@@ int ovl_copy_up_one(struct dentry *pare
  	struct cred *override_cred;
  	char *link = NULL;
  
++<<<<<<< HEAD
++=======
+ 	if (WARN_ON(!workdir))
+ 		return -EROFS;
+ 
+ 	ovl_do_check_copy_up(lowerpath->dentry);
+ 
++>>>>>>> fb5bb2c3b73d (ovl: Warn on copy up if a process has a R/O fd open to the lower file)
  	ovl_path_upper(parent, &parentpath);
  	upperdir = parentpath.dentry;
  
* Unmerged path fs/overlayfs/copy_up.c
