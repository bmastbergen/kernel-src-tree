bonding: trivial: style and comment fixes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Nikolay Aleksandrov <nikolay@redhat.com>
commit 547942cace50e536dcda9ce8397792bc992291d6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/547942ca.failed

First adjust a couple of locking comments that were left inaccurate,
then adjust comments to use the netdev styling and remove extra new
lines where necessary and add a couple of new lines between declarations
and code. These are all trivial styling changes, no functional change.
Also removed a couple of outdated or obvious comments.
This patch is by no means a complete fix of all netdev style violations
but it gets the bonding closer.

	Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 547942cace50e536dcda9ce8397792bc992291d6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_3ad.c
#	drivers/net/bonding/bond_alb.c
#	drivers/net/bonding/bond_main.c
#	drivers/net/bonding/bonding.h
diff --cc drivers/net/bonding/bond_3ad.c
index 65115ee7b259,7e9e522fd476..000000000000
--- a/drivers/net/bonding/bond_3ad.c
+++ b/drivers/net/bonding/bond_3ad.c
@@@ -361,14 -297,14 +361,20 @@@ static u16 __get_link_speed(struct por
  static u8 __get_duplex(struct port *port)
  {
  	struct slave *slave = port->slave;
- 
  	u8 retval;
  
++<<<<<<< HEAD
 +	//  handling a special case: when the configuration starts with
 +	// link down, it sets the duplex to 0.
 +	if (slave->link != BOND_LINK_UP)
++=======
+ 	/* handling a special case: when the configuration starts with
+ 	 * link down, it sets the duplex to 0.
+ 	 */
+ 	if (slave->link != BOND_LINK_UP) {
++>>>>>>> 547942cace50 (bonding: trivial: style and comment fixes)
  		retval = 0x0;
- 	else {
+ 	} else {
  		switch (slave->duplex) {
  		case DUPLEX_FULL:
  			retval = 0x1;
diff --cc drivers/net/bonding/bond_alb.c
index 06a8df1ef842,615f3bebd019..000000000000
--- a/drivers/net/bonding/bond_alb.c
+++ b/drivers/net/bonding/bond_alb.c
@@@ -286,9 -266,10 +286,14 @@@ static struct slave *tlb_choose_channel
  	 * tlb_choose_channel() is only called by bond_alb_xmit()
  	 * which already has softirq disabled.
  	 */
 -	spin_lock(&bond->mode_lock);
 +	_lock_tx_hashtbl(bond);
  	tx_slave = __tlb_choose_channel(bond, hash_index, skb_len);
++<<<<<<< HEAD
 +	_unlock_tx_hashtbl(bond);
++=======
+ 	spin_unlock(&bond->mode_lock);
+ 
++>>>>>>> 547942cace50 (bonding: trivial: style and comment fixes)
  	return tx_slave;
  }
  
@@@ -594,11 -567,10 +599,11 @@@ static void rlb_req_update_subnet_clien
  		client_info = &(bond_info->rx_hashtbl[hash_index]);
  
  		if (!client_info->slave) {
 -			netdev_err(bond->dev, "found a client with no channel in the client's hash table\n");
 +			pr_err("%s: Error: found a client with no channel in the client's hash table\n",
 +			       bond->dev->name);
  			continue;
  		}
- 		/*update all clients using this src_ip, that are not assigned
+ 		/* update all clients using this src_ip, that are not assigned
  		 * to the team's address (curr_active_slave) and have a known
  		 * unicast mac address.
  		 */
@@@ -723,14 -696,11 +728,12 @@@ static struct slave *rlb_arp_xmit(struc
  		return NULL;
  
  	if (arp->op_code == htons(ARPOP_REPLY)) {
- 		/* the arp must be sent on the selected
- 		* rx channel
- 		*/
+ 		/* the arp must be sent on the selected rx channel */
  		tx_slave = rlb_choose_channel(skb, bond);
 -		if (tx_slave)
 -			ether_addr_copy(arp->mac_src, tx_slave->dev->dev_addr);
 -		netdev_dbg(bond->dev, "Server sent ARP Reply packet\n");
 +		if (tx_slave) {
 +			memcpy(arp->mac_src, tx_slave->dev->dev_addr, ETH_ALEN);
 +		}
 +		pr_debug("Server sent ARP Reply packet\n");
  	} else if (arp->op_code == htons(ARPOP_REQUEST)) {
  		/* Create an entry in the rx_hashtbl for this client as a
  		 * place holder.
@@@ -781,13 -750,12 +784,13 @@@ static void rlb_rebalance(struct bondin
  	}
  
  	/* update the team's flag only after the whole iteration */
 -	if (ntt)
 +	if (ntt) {
  		bond_info->rx_ntt = 1;
 -	spin_unlock_bh(&bond->mode_lock);
 +	}
 +	_unlock_rx_hashtbl_bh(bond);
  }
  
- /* Caller must hold rx_hashtbl lock */
+ /* Caller must hold mode_lock */
  static void rlb_init_table_entry_dst(struct rlb_client_info *entry)
  {
  	entry->used_next = RLB_NULL_INDEX;
@@@ -1313,9 -1297,109 +1313,25 @@@ void bond_alb_deinitialize(struct bondi
  
  	tlb_deinitialize(bond);
  
 -	if (bond_info->rlb_enabled)
 +	if (bond_info->rlb_enabled) {
  		rlb_deinitialize(bond);
++<<<<<<< HEAD
++=======
+ }
+ 
+ static int bond_do_alb_xmit(struct sk_buff *skb, struct bonding *bond,
+ 			    struct slave *tx_slave)
+ {
+ 	struct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));
+ 	struct ethhdr *eth_data = eth_hdr(skb);
+ 
+ 	if (!tx_slave) {
+ 		/* unbalanced or unassigned, send through primary */
+ 		tx_slave = rcu_dereference(bond->curr_active_slave);
+ 		if (bond->params.tlb_dynamic_lb)
+ 			bond_info->unbalanced_load += skb->len;
++>>>>>>> 547942cace50 (bonding: trivial: style and comment fixes)
  	}
 -
 -	if (tx_slave && bond_slave_can_tx(tx_slave)) {
 -		if (tx_slave != rcu_access_pointer(bond->curr_active_slave)) {
 -			ether_addr_copy(eth_data->h_source,
 -					tx_slave->dev->dev_addr);
 -		}
 -
 -		bond_dev_queue_xmit(bond, skb, tx_slave->dev);
 -		goto out;
 -	}
 -
 -	if (tx_slave && bond->params.tlb_dynamic_lb) {
 -		spin_lock(&bond->mode_lock);
 -		__tlb_clear_slave(bond, tx_slave, 0);
 -		spin_unlock(&bond->mode_lock);
 -	}
 -
 -	/* no suitable interface, frame not sent */
 -	dev_kfree_skb_any(skb);
 -out:
 -	return NETDEV_TX_OK;
 -}
 -
 -static int bond_tlb_update_slave_arr(struct bonding *bond,
 -				     struct slave *skipslave)
 -{
 -	struct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));
 -	struct slave *tx_slave;
 -	struct list_head *iter;
 -	struct tlb_up_slave *new_arr, *old_arr;
 -
 -	new_arr = kzalloc(offsetof(struct tlb_up_slave, arr[bond->slave_cnt]),
 -			  GFP_ATOMIC);
 -	if (!new_arr)
 -		return -ENOMEM;
 -
 -	bond_for_each_slave(bond, tx_slave, iter) {
 -		if (!bond_slave_can_tx(tx_slave))
 -			continue;
 -		if (skipslave == tx_slave)
 -			continue;
 -		new_arr->arr[new_arr->count++] = tx_slave;
 -	}
 -
 -	old_arr = rtnl_dereference(bond_info->slave_arr);
 -	rcu_assign_pointer(bond_info->slave_arr, new_arr);
 -	if (old_arr)
 -		kfree_rcu(old_arr, rcu);
 -
 -	return 0;
 -}
 -
 -int bond_tlb_xmit(struct sk_buff *skb, struct net_device *bond_dev)
 -{
 -	struct bonding *bond = netdev_priv(bond_dev);
 -	struct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));
 -	struct ethhdr *eth_data;
 -	struct slave *tx_slave = NULL;
 -	u32 hash_index;
 -
 -	skb_reset_mac_header(skb);
 -	eth_data = eth_hdr(skb);
 -
 -	/* Do not TX balance any multicast or broadcast */
 -	if (!is_multicast_ether_addr(eth_data->h_dest)) {
 -		switch (skb->protocol) {
 -		case htons(ETH_P_IP):
 -		case htons(ETH_P_IPX):
 -		    /* In case of IPX, it will falback to L2 hash */
 -		case htons(ETH_P_IPV6):
 -			hash_index = bond_xmit_hash(bond, skb);
 -			if (bond->params.tlb_dynamic_lb) {
 -				tx_slave = tlb_choose_channel(bond,
 -							      hash_index & 0xFF,
 -							      skb->len);
 -			} else {
 -				struct tlb_up_slave *slaves;
 -
 -				slaves = rcu_dereference(bond_info->slave_arr);
 -				if (slaves && slaves->count)
 -					tx_slave = slaves->arr[hash_index %
 -							       slaves->count];
 -			}
 -			break;
 -		}
 -	}
 -	return bond_do_alb_xmit(skb, bond, tx_slave);
  }
  
  int bond_alb_xmit(struct sk_buff *skb, struct net_device *bond_dev)
@@@ -1513,6 -1554,13 +1528,16 @@@ void bond_alb_monitor(struct work_struc
  		if (bond_info->primary_is_promisc &&
  		    (++bond_info->rlb_promisc_timeout_counter >= RLB_PROMISC_TIMEOUT)) {
  
++<<<<<<< HEAD
++=======
+ 			/* dev_set_promiscuity requires rtnl and
+ 			 * nothing else.  Avoid race with bond_close.
+ 			 */
+ 			rcu_read_unlock();
+ 			if (!rtnl_trylock())
+ 				goto re_arm;
+ 
++>>>>>>> 547942cace50 (bonding: trivial: style and comment fixes)
  			bond_info->rlb_promisc_timeout_counter = 0;
  
  			/* If the primary was set to promiscuous mode
diff --cc drivers/net/bonding/bond_main.c
index b4cb8784d691,943a899fbfde..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -489,37 -323,9 +488,36 @@@ static int bond_vlan_rx_kill_vid(struc
  	return 0;
  }
  
 +static void bond_add_vlans_on_slave(struct bonding *bond, struct net_device *slave_dev)
 +{
 +	struct vlan_entry *vlan;
 +	int res;
 +
 +	list_for_each_entry(vlan, &bond->vlan_list, vlan_list) {
 +		res = vlan_vid_add(slave_dev, htons(ETH_P_8021Q),
 +				   vlan->vlan_id);
 +		if (res)
 +			pr_warning("%s: Failed to add vlan id %d to device %s\n",
 +				   bond->dev->name, vlan->vlan_id,
 +				   slave_dev->name);
 +	}
 +}
 +
 +static void bond_del_vlans_from_slave(struct bonding *bond,
 +				      struct net_device *slave_dev)
 +{
 +	struct vlan_entry *vlan;
 +
 +	list_for_each_entry(vlan, &bond->vlan_list, vlan_list) {
 +		if (!vlan->vlan_id)
 +			continue;
 +		vlan_vid_del(slave_dev, htons(ETH_P_8021Q), vlan->vlan_id);
 +	}
 +}
 +
  /*------------------------------- Link status -------------------------------*/
  
- /*
-  * Set the carrier state for the master according to the state of its
+ /* Set the carrier state for the master according to the state of its
   * slaves.  If any slaves are up, the master is up.  In 802.3ad mode,
   * do special 802.3ad magic.
   *
@@@ -592,8 -397,23 +589,28 @@@ static void bond_update_speed_duplex(st
  	return;
  }
  
++<<<<<<< HEAD
 +/*
 + * if <dev> supports MII link status reporting, check its link status.
++=======
+ const char *bond_slave_link_status(s8 link)
+ {
+ 	switch (link) {
+ 	case BOND_LINK_UP:
+ 		return "up";
+ 	case BOND_LINK_FAIL:
+ 		return "going down";
+ 	case BOND_LINK_DOWN:
+ 		return "down";
+ 	case BOND_LINK_BACK:
+ 		return "going back";
+ 	default:
+ 		return "unknown";
+ 	}
+ }
+ 
+ /* if <dev> supports MII link status reporting, check its link status.
++>>>>>>> 547942cace50 (bonding: trivial: style and comment fixes)
   *
   * We either do MII/ETHTOOL ioctls, or check netif_carrier_ok(),
   * depending upon the setting of the use_carrier parameter.
@@@ -663,22 -482,21 +679,20 @@@ static int bond_check_dev_link(struct b
  
  /*----------------------------- Multicast list ------------------------------*/
  
- /*
-  * Push the promiscuity flag down to appropriate slaves
-  */
+ /* Push the promiscuity flag down to appropriate slaves */
  static int bond_set_promiscuity(struct bonding *bond, int inc)
  {
 -	struct list_head *iter;
  	int err = 0;
 -
 -	if (bond_uses_primary(bond)) {
 -		struct slave *curr_active = rtnl_dereference(bond->curr_active_slave);
 -
 -		if (curr_active)
 -			err = dev_set_promiscuity(curr_active->dev, inc);
 +	if (USES_PRIMARY(bond->params.mode)) {
 +		/* write lock already acquired */
 +		if (bond->curr_active_slave) {
 +			err = dev_set_promiscuity(bond->curr_active_slave->dev,
 +						  inc);
 +		}
  	} else {
  		struct slave *slave;
 -
 -		bond_for_each_slave(bond, slave, iter) {
 +		int i;
 +		bond_for_each_slave(bond, slave, i) {
  			err = dev_set_promiscuity(slave->dev, inc);
  			if (err)
  				return err;
@@@ -687,22 -505,21 +701,20 @@@
  	return err;
  }
  
- /*
-  * Push the allmulti flag down to all slaves
-  */
+ /* Push the allmulti flag down to all slaves */
  static int bond_set_allmulti(struct bonding *bond, int inc)
  {
 -	struct list_head *iter;
  	int err = 0;
 -
 -	if (bond_uses_primary(bond)) {
 -		struct slave *curr_active = rtnl_dereference(bond->curr_active_slave);
 -
 -		if (curr_active)
 -			err = dev_set_allmulti(curr_active->dev, inc);
 +	if (USES_PRIMARY(bond->params.mode)) {
 +		/* write lock already acquired */
 +		if (bond->curr_active_slave) {
 +			err = dev_set_allmulti(bond->curr_active_slave->dev,
 +					       inc);
 +		}
  	} else {
  		struct slave *slave;
 -
 -		bond_for_each_slave(bond, slave, iter) {
 +		int i;
 +		bond_for_each_slave(bond, slave, i) {
  			err = dev_set_allmulti(slave->dev, inc);
  			if (err)
  				return err;
@@@ -711,47 -528,7 +723,51 @@@
  	return err;
  }
  
++<<<<<<< HEAD
 +/*
 + * Add a Multicast address to slaves
 + * according to mode
 + */
 +static void bond_mc_add(struct bonding *bond, void *addr)
 +{
 +	if (USES_PRIMARY(bond->params.mode)) {
 +		/* write lock already acquired */
 +		if (bond->curr_active_slave)
 +			dev_mc_add(bond->curr_active_slave->dev, addr);
 +	} else {
 +		struct slave *slave;
 +		int i;
 +
 +		bond_for_each_slave(bond, slave, i)
 +			dev_mc_add(slave->dev, addr);
 +	}
 +}
 +
 +/*
 + * Remove a multicast address from slave
 + * according to mode
 + */
 +static void bond_mc_del(struct bonding *bond, void *addr)
 +{
 +	if (USES_PRIMARY(bond->params.mode)) {
 +		/* write lock already acquired */
 +		if (bond->curr_active_slave)
 +			dev_mc_del(bond->curr_active_slave->dev, addr);
 +	} else {
 +		struct slave *slave;
 +		int i;
 +		bond_for_each_slave(bond, slave, i) {
 +			dev_mc_del(slave->dev, addr);
 +		}
 +	}
 +}
 +
 +
 +/*
 + * Retrieve the list of registered multicast addresses for the bonding
++=======
+ /* Retrieve the list of registered multicast addresses for the bonding
++>>>>>>> 547942cace50 (bonding: trivial: style and comment fixes)
   * device and retransmit an IGMP JOIN request to the current active
   * slave.
   */
@@@ -773,10 -550,8 +789,15 @@@ static void bond_resend_igmp_join_reque
  	rtnl_unlock();
  }
  
++<<<<<<< HEAD
 +/*
 + * flush all members of flush->mc_list from device dev->mc_list
 + */
 +static void bond_mc_list_flush(struct net_device *bond_dev,
++=======
+ /* Flush bond's hardware addresses from slave */
+ static void bond_hw_addr_flush(struct net_device *bond_dev,
++>>>>>>> 547942cace50 (bonding: trivial: style and comment fixes)
  			       struct net_device *slave_dev)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
@@@ -875,15 -637,11 +895,14 @@@ static void bond_do_fail_over_mac(struc
  
  	switch (bond->params.fail_over_mac) {
  	case BOND_FOM_ACTIVE:
 -		if (new_active)
 +		if (new_active) {
 +			write_unlock_bh(&bond->curr_slave_lock);
  			bond_set_dev_addr(bond->dev, new_active->dev);
 +			write_lock_bh(&bond->curr_slave_lock);
 +		}
  		break;
  	case BOND_FOM_FOLLOW:
- 		/*
- 		 * if new_active && old_active, swap them
+ 		/* if new_active && old_active, swap them
  		 * if just old_active, do nothing (going to no active slave)
  		 * if just new_active, set new_active to bond's MAC
  		 */
@@@ -1106,10 -850,11 +1125,11 @@@ void bond_change_active_slave(struct bo
  	/* resend IGMP joins since active slave has changed or
  	 * all were sent on curr_active_slave.
  	 * resend only if bond is brought up with the affected
- 	 * bonding modes and the retransmission is enabled */
+ 	 * bonding modes and the retransmission is enabled
+ 	 */
  	if (netif_running(bond->dev) && (bond->params.resend_igmp > 0) &&
 -	    ((bond_uses_primary(bond) && new_active) ||
 -	     BOND_MODE(bond) == BOND_MODE_ROUNDROBIN)) {
 +	    ((USES_PRIMARY(bond->params.mode) && new_active) ||
 +	     bond->params.mode == BOND_MODE_ROUNDROBIN)) {
  		bond->igmp_retrans = bond->params.resend_igmp;
  		queue_delayed_work(bond->wq, &bond->mcast_work, 1);
  	}
@@@ -1482,22 -1201,23 +1502,21 @@@ int bond_enslave(struct net_device *bon
  	/* vlan challenged mutual exclusion */
  	/* no need to lock since we're protected by rtnl_lock */
  	if (slave_dev->features & NETIF_F_VLAN_CHALLENGED) {
 -		netdev_dbg(bond_dev, "%s is NETIF_F_VLAN_CHALLENGED\n",
 -			   slave_dev->name);
 +		pr_debug("%s: NETIF_F_VLAN_CHALLENGED\n", slave_dev->name);
  		if (vlan_uses_dev(bond_dev)) {
 -			netdev_err(bond_dev, "Error: cannot enslave VLAN challenged slave %s on VLAN enabled bond %s\n",
 -				   slave_dev->name, bond_dev->name);
 +			pr_err("%s: Error: cannot enslave VLAN challenged slave %s on VLAN enabled bond %s\n",
 +			       bond_dev->name, slave_dev->name, bond_dev->name);
  			return -EPERM;
  		} else {
 -			netdev_warn(bond_dev, "enslaved VLAN challenged slave %s. Adding VLANs will be blocked as long as %s is part of bond %s\n",
 -				    slave_dev->name, slave_dev->name,
 -				    bond_dev->name);
 +			pr_warning("%s: Warning: enslaved VLAN challenged slave %s. Adding VLANs will be blocked as long as %s is part of bond %s\n",
 +				   bond_dev->name, slave_dev->name,
 +				   slave_dev->name, bond_dev->name);
  		}
  	} else {
 -		netdev_dbg(bond_dev, "%s is !NETIF_F_VLAN_CHALLENGED\n",
 -			   slave_dev->name);
 +		pr_debug("%s: ! NETIF_F_VLAN_CHALLENGED\n", slave_dev->name);
  	}
  
- 	/*
- 	 * Old ifenslave binaries are no longer supported.  These can
+ 	/* Old ifenslave binaries are no longer supported.  These can
  	 * be identified with moderate accuracy by the state of the slave:
  	 * the current ifenslave will set the interface down prior to
  	 * enslaving it; the old ifenslave will not.
@@@ -1570,11 -1289,13 +1589,18 @@@
  	call_netdevice_notifiers(NETDEV_JOIN, slave_dev);
  
  	/* If this is the first slave, then we need to set the master's hardware
++<<<<<<< HEAD
 +	 * address to be the same as the slave's. */
 +	if (!bond->slave_cnt && bond->dev->addr_assign_type == NET_ADDR_RANDOM)
++=======
+ 	 * address to be the same as the slave's.
+ 	 */
+ 	if (!bond_has_slaves(bond) &&
+ 	    bond->dev->addr_assign_type == NET_ADDR_RANDOM)
++>>>>>>> 547942cace50 (bonding: trivial: style and comment fixes)
  		bond_set_dev_addr(bond->dev, slave_dev);
  
 -	new_slave = bond_alloc_slave(bond);
 +	new_slave = kzalloc(sizeof(struct slave), GFP_KERNEL);
  	if (!new_slave) {
  		res = -ENOMEM;
  		goto err_undo_flags;
@@@ -1601,11 -1320,11 +1625,17 @@@
  	 * that need it, and for restoring it upon release, and then
  	 * set it to the master's address
  	 */
 -	ether_addr_copy(new_slave->perm_hwaddr, slave_dev->dev_addr);
 +	memcpy(new_slave->perm_hwaddr, slave_dev->dev_addr, ETH_ALEN);
  
++<<<<<<< HEAD
 +	if (!bond->params.fail_over_mac) {
 +		/*
 +		 * Set slave to master's mac address.  The application already
++=======
+ 	if (!bond->params.fail_over_mac ||
+ 	    BOND_MODE(bond) != BOND_MODE_ACTIVEBACKUP) {
+ 		/* Set slave to master's mac address.  The application already
++>>>>>>> 547942cace50 (bonding: trivial: style and comment fixes)
  		 * set the master's mac address to that of the first slave
  		 */
  		memcpy(addr.sa_data, bond_dev->dev_addr, bond_dev->addr_len);
@@@ -1902,10 -1610,9 +1931,9 @@@ err_undo_flags
  	return res;
  }
  
- /*
-  * Try to release the slave device <slave> from the bond device <master>
+ /* Try to release the slave device <slave> from the bond device <master>
   * It is legal to access curr_active_slave without a lock because all the function
 - * is RTNL-locked. If "all" is true it means that the function is being called
 + * is write-locked. If "all" is true it means that the function is being called
   * while destroying a bond interface and all slaves are being released.
   *
   * The rules for slave state should be:
@@@ -2001,10 -1694,9 +2029,9 @@@ static int __bond_release_one(struct ne
  	}
  
  	if (all) {
 -		RCU_INIT_POINTER(bond->curr_active_slave, NULL);
 +		bond->curr_active_slave = NULL;
  	} else if (oldcurrent == slave) {
- 		/*
- 		 * Note that we hold RTNL over this sequence, so there
+ 		/* Note that we hold RTNL over this sequence, so there
  		 * is no concern that another slave add/remove event
  		 * will interfere.
  		 */
@@@ -2035,19 -1720,15 +2062,26 @@@
  	bond_compute_features(bond);
  	if (!(bond_dev->features & NETIF_F_VLAN_CHALLENGED) &&
  	    (old_features & NETIF_F_VLAN_CHALLENGED))
 -		netdev_info(bond_dev, "last VLAN challenged slave %s left bond %s - VLAN blocking is removed\n",
 -			    slave_dev->name, bond_dev->name);
 +		pr_info("%s: last VLAN challenged slave %s left bond %s. VLAN blocking is removed\n",
 +			bond_dev->name, slave_dev->name, bond_dev->name);
 +
++<<<<<<< HEAD
 +	/* must do this from outside any spinlocks */
 +	bond_destroy_slave_symlinks(bond_dev, slave_dev);
 +
 +	bond_del_vlans_from_slave(bond, slave_dev);
  
 +	/* If the mode USES_PRIMARY, then we should only remove its
 +	 * promisc and mc settings if it was the curr_active_slave, but that was
 +	 * already taken care of above when we detached the slave
++=======
+ 	vlan_vids_del_by_dev(slave_dev, bond_dev);
+ 
+ 	/* If the mode uses primary, then this case was handled above by
+ 	 * bond_change_active_slave(..., NULL)
++>>>>>>> 547942cace50 (bonding: trivial: style and comment fixes)
  	 */
 -	if (!bond_uses_primary(bond)) {
 +	if (!USES_PRIMARY(bond->params.mode)) {
  		/* unset promiscuity level from slave
  		 * NOTE: The NETDEV_CHANGEADDR call above may change the value
  		 * of the IFF_PROMISC flag in the bond_dev, but we need the
@@@ -2084,9 -1763,9 +2118,9 @@@
  
  	slave_dev->priv_flags &= ~IFF_BONDING;
  
 -	bond_free_slave(slave);
 +	kfree(slave);
  
- 	return 0;  /* deletion OK */
+ 	return 0;
  }
  
  /* A wrapper used because of ndo_del_link */
@@@ -2119,12 -1797,9 +2152,15 @@@ static int bond_info_query(struct net_d
  {
  	struct bonding *bond = netdev_priv(bond_dev);
  
 -	info->bond_mode = BOND_MODE(bond);
 +	info->bond_mode = bond->params.mode;
  	info->miimon = bond->params.miimon;
++<<<<<<< HEAD
 +
 +	read_lock(&bond->lock);
++=======
++>>>>>>> 547942cace50 (bonding: trivial: style and comment fixes)
  	info->num_slaves = bond->slave_cnt;
 +	read_unlock(&bond->lock);
  
  	return 0;
  }
@@@ -2189,16 -1861,13 +2225,14 @@@ static int bond_miimon_inspect(struct b
  			/*FALLTHRU*/
  		case BOND_LINK_FAIL:
  			if (link_state) {
- 				/*
- 				 * recovered before downdelay expired
- 				 */
+ 				/* recovered before downdelay expired */
  				slave->link = BOND_LINK_UP;
 -				slave->last_link_up = jiffies;
 -				netdev_info(bond->dev, "link status up again after %d ms for interface %s\n",
 -					    (bond->params.downdelay - slave->delay) *
 -					    bond->params.miimon,
 -					    slave->dev->name);
 +				slave->jiffies = jiffies;
 +				pr_info("%s: link status up again after %d ms for interface %s.\n",
 +					bond->dev->name,
 +					(bond->params.downdelay - slave->delay) *
 +					bond->params.miimon,
 +					slave->dev->name);
  				continue;
  			}
  
@@@ -2601,13 -2305,14 +2633,12 @@@ int bond_arp_rcv(const struct sk_buff *
  	arp_ptr += 4 + bond->dev->addr_len;
  	memcpy(&tip, arp_ptr, 4);
  
 -	netdev_dbg(bond->dev, "bond_arp_rcv: %s/%d av %d sv %d sip %pI4 tip %pI4\n",
 -		   slave->dev->name, bond_slave_state(slave),
 -		     bond->params.arp_validate, slave_do_arp_validate(bond, slave),
 -		     &sip, &tip);
 -
 -	curr_active_slave = rcu_dereference(bond->curr_active_slave);
 +	pr_debug("bond_arp_rcv: %s %s/%d av %d sv %d sip %pI4 tip %pI4\n",
 +		 bond->dev->name, slave->dev->name, bond_slave_state(slave),
 +		 bond->params.arp_validate, slave_do_arp_validate(bond, slave),
 +		 &sip, &tip);
  
- 	/*
- 	 * Backup slaves won't see the ARP reply, but do come through
+ 	/* Backup slaves won't see the ARP reply, but do come through
  	 * here for each ARP probe (so we swap the sip/tip to validate
  	 * the probe).  In a "redundant switch, common router" type of
  	 * configuration, the ARP probe will (hopefully) travel from
@@@ -2632,8 -2338,21 +2663,26 @@@ out_unlock
  	return RX_HANDLER_ANOTHER;
  }
  
++<<<<<<< HEAD
 +/*
 + * this function is called regularly to monitor each slave's link
++=======
+ /* function to verify if we're in the arp_interval timeslice, returns true if
+  * (last_act - arp_interval) <= jiffies <= (last_act + mod * arp_interval +
+  * arp_interval/2) . the arp_interval/2 is needed for really fast networks.
+  */
+ static bool bond_time_in_interval(struct bonding *bond, unsigned long last_act,
+ 				  int mod)
+ {
+ 	int delta_in_ticks = msecs_to_jiffies(bond->params.arp_interval);
+ 
+ 	return time_in_range(jiffies,
+ 			     last_act - delta_in_ticks,
+ 			     last_act + mod * delta_in_ticks + delta_in_ticks/2);
+ }
+ 
+ /* This function is called regularly to monitor each slave's link
++>>>>>>> 547942cace50 (bonding: trivial: style and comment fixes)
   * ensuring that traffic is being sent and received when arp monitoring
   * is used in load-balancing mode. if the adapter has been dormant, then an
   * arp is transmitted to generate traffic. see activebackup_arp_monitor for
@@@ -2747,13 -2457,11 +2796,12 @@@ void bond_loadbalance_arp_mon(struct wo
  
  re_arm:
  	if (bond->params.arp_interval)
 -		queue_delayed_work(bond->wq, &bond->arp_work,
 -				   msecs_to_jiffies(bond->params.arp_interval));
 +		queue_delayed_work(bond->wq, &bond->arp_work, delta_in_ticks);
 +
 +	read_unlock(&bond->lock);
  }
  
- /*
-  * Called to inspect slaves for active-backup mode ARP monitor link state
+ /* Called to inspect slaves for active-backup mode ARP monitor link state
   * changes.  Sets new_link in slaves to specify what action should take
   * place for the slave.  Returns 0 if no changes are found, >0 if changes
   * to link states must be committed.
@@@ -2794,13 -2491,10 +2841,12 @@@ static int bond_ab_arp_inspect(struct b
  		 * active.  This avoids bouncing, as the last receive
  		 * times need a full ARP monitor cycle to be updated.
  		 */
 -		if (bond_time_in_interval(bond, slave->last_link_up, 2))
 +		if (time_in_range(jiffies,
 +				  slave->jiffies - delta_in_ticks,
 +				  slave->jiffies + 2 * delta_in_ticks + extra_ticks))
  			continue;
  
- 		/*
- 		 * Backup slave is down if:
+ 		/* Backup slave is down if:
  		 * - No current_arp_slave AND
  		 * - more than 3*delta since last receive AND
  		 * - the bond has an IP address
@@@ -2845,19 -2530,18 +2890,18 @@@
  	return commit;
  }
  
- /*
-  * Called to commit link state changes noted by inspection step of
+ /* Called to commit link state changes noted by inspection step of
   * active-backup mode ARP monitor.
   *
 - * Called with RTNL hold.
 + * Called with RTNL and bond->lock for read.
   */
 -static void bond_ab_arp_commit(struct bonding *bond)
 +static void bond_ab_arp_commit(struct bonding *bond, int delta_in_ticks)
  {
 -	unsigned long trans_start;
 -	struct list_head *iter;
  	struct slave *slave;
 +	int i;
 +	unsigned long trans_start;
  
 -	bond_for_each_slave(bond, slave, iter) {
 +	bond_for_each_slave(bond, slave, i) {
  		switch (slave->new_link) {
  		case BOND_LINK_NOCHANGE:
  			continue;
@@@ -2923,31 -2607,29 +2967,30 @@@ do_failover
  	bond_set_carrier(bond);
  }
  
- /*
-  * Send ARP probes for active-backup mode ARP monitor.
+ /* Send ARP probes for active-backup mode ARP monitor.
   *
 - * Called with rcu_read_lock held.
 + * Called with bond->lock held for read.
   */
 -static bool bond_ab_arp_probe(struct bonding *bond)
 +static void bond_ab_arp_probe(struct bonding *bond)
  {
 -	struct slave *slave, *before = NULL, *new_slave = NULL,
 -		     *curr_arp_slave = rcu_dereference(bond->current_arp_slave),
 -		     *curr_active_slave = rcu_dereference(bond->curr_active_slave);
 -	struct list_head *iter;
 -	bool found = false;
 -	bool should_notify_rtnl = BOND_SLAVE_NOTIFY_LATER;
 +	struct slave *slave;
 +	int i;
  
 -	if (curr_arp_slave && curr_active_slave)
 -		netdev_info(bond->dev, "PROBE: c_arp %s && cas %s BAD\n",
 -			    curr_arp_slave->dev->name,
 -			    curr_active_slave->dev->name);
 +	read_lock(&bond->curr_slave_lock);
  
 -	if (curr_active_slave) {
 -		bond_arp_send_all(bond, curr_active_slave);
 -		return should_notify_rtnl;
 +	if (bond->current_arp_slave && bond->curr_active_slave)
 +		pr_info("PROBE: c_arp %s && cas %s BAD\n",
 +			bond->current_arp_slave->dev->name,
 +			bond->curr_active_slave->dev->name);
 +
 +	if (bond->curr_active_slave) {
 +		bond_arp_send_all(bond, bond->curr_active_slave);
 +		read_unlock(&bond->curr_slave_lock);
 +		return;
  	}
  
 +	read_unlock(&bond->curr_slave_lock);
 +
  	/* if we don't have a curr_active_slave, search for the next available
  	 * backup slave from the current_arp_slave and make it the candidate
  	 * for becoming the curr_active_slave
@@@ -3589,36 -3243,26 +3623,51 @@@ static void bond_change_rx_flags(struc
  				  bond_dev->flags & IFF_ALLMULTI ? 1 : -1);
  }
  
 -static void bond_set_rx_mode(struct net_device *bond_dev)
 +static void bond_set_multicast_list(struct net_device *bond_dev)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
 -	struct list_head *iter;
 -	struct slave *slave;
 -
 +	struct netdev_hw_addr *ha;
 +	bool found;
 +
++<<<<<<< HEAD
 +	read_lock(&bond->lock);
 +
 +	/* looking for addresses to add to slaves' mc list */
 +	netdev_for_each_mc_addr(ha, bond_dev) {
 +		found = bond_addr_in_mc_list(ha->addr, &bond->mc_list,
 +					     bond_dev->addr_len);
 +		if (!found)
 +			bond_mc_add(bond, ha->addr);
++=======
+ 	rcu_read_lock();
+ 	if (bond_uses_primary(bond)) {
+ 		slave = rcu_dereference(bond->curr_active_slave);
+ 		if (slave) {
+ 			dev_uc_sync(slave->dev, bond_dev);
+ 			dev_mc_sync(slave->dev, bond_dev);
+ 		}
+ 	} else {
+ 		bond_for_each_slave_rcu(bond, slave, iter) {
+ 			dev_uc_sync_multiple(slave->dev, bond_dev);
+ 			dev_mc_sync_multiple(slave->dev, bond_dev);
+ 		}
++>>>>>>> 547942cace50 (bonding: trivial: style and comment fixes)
  	}
 -	rcu_read_unlock();
 +
 +	/* looking for addresses to delete from slaves' list */
 +	netdev_hw_addr_list_for_each(ha, &bond->mc_list) {
 +		found = bond_addr_in_mc_list(ha->addr, &bond_dev->mc,
 +					     bond_dev->addr_len);
 +		if (!found)
 +			bond_mc_del(bond, ha->addr);
 +	}
 +
 +	/* save master's multicast list */
 +	__hw_addr_flush(&bond->mc_list);
 +	__hw_addr_add_multiple(&bond->mc_list, &bond_dev->mc,
 +			       bond_dev->addr_len, NETDEV_HW_ADDR_T_MULTICAST);
 +
 +	read_unlock(&bond->lock);
  }
  
  static int bond_neigh_init(struct neighbour *n)
@@@ -3892,9 -3540,7 +3936,13 @@@ out
  	return NETDEV_TX_OK;
  }
  
++<<<<<<< HEAD
 +
 +/*
 + * in active-backup mode, we know that bond->curr_active_slave is always valid if
++=======
+ /* In active-backup mode, we know that bond->curr_active_slave is always valid if
++>>>>>>> 547942cace50 (bonding: trivial: style and comment fixes)
   * the bond has a usable interface.
   */
  static int bond_xmit_activebackup(struct sk_buff *skb, struct net_device *bond_dev)
@@@ -3985,25 -3602,7 +4033,29 @@@ static int bond_xmit_broadcast(struct s
  
  /*------------------------- Device initialization ---------------------------*/
  
++<<<<<<< HEAD
 +static void bond_set_xmit_hash_policy(struct bonding *bond)
 +{
 +	switch (bond->params.xmit_policy) {
 +	case BOND_XMIT_POLICY_LAYER23:
 +		bond->xmit_hash_policy = bond_xmit_hash_policy_l23;
 +		break;
 +	case BOND_XMIT_POLICY_LAYER34:
 +		bond->xmit_hash_policy = bond_xmit_hash_policy_l34;
 +		break;
 +	case BOND_XMIT_POLICY_LAYER2:
 +	default:
 +		bond->xmit_hash_policy = bond_xmit_hash_policy_l2;
 +		break;
 +	}
 +}
 +
 +/*
 + * Lookup the slave that corresponds to a qid
 + */
++=======
+ /* Lookup the slave that corresponds to a qid */
++>>>>>>> 547942cace50 (bonding: trivial: style and comment fixes)
  static inline int bond_slave_override(struct bonding *bond,
  				      struct sk_buff *skb)
  {
@@@ -4032,10 -3628,10 +4084,9 @@@
  }
  
  
 -static u16 bond_select_queue(struct net_device *dev, struct sk_buff *skb,
 -			     void *accel_priv, select_queue_fallback_t fallback)
 +static u16 bond_select_queue(struct net_device *dev, struct sk_buff *skb)
  {
- 	/*
- 	 * This helper function exists to help dev_pick_tx get the correct
+ 	/* This helper function exists to help dev_pick_tx get the correct
  	 * destination queue.  Using a helper function skips a call to
  	 * skb_tx_hash and will put the skbs in the queue we expect on their
  	 * way down to the bonding driver.
@@@ -4093,21 -3686,18 +4142,20 @@@ static netdev_tx_t bond_start_xmit(stru
  	struct bonding *bond = netdev_priv(dev);
  	netdev_tx_t ret = NETDEV_TX_OK;
  
- 	/*
- 	 * If we risk deadlock from transmitting this in the
+ 	/* If we risk deadlock from transmitting this in the
  	 * netpoll path, tell netpoll to queue the frame for later tx
  	 */
 -	if (unlikely(is_netpoll_tx_blocked(dev)))
 +	if (is_netpoll_tx_blocked(dev))
  		return NETDEV_TX_BUSY;
  
 -	rcu_read_lock();
 -	if (bond_has_slaves(bond))
 +	read_lock(&bond->lock);
 +
 +	if (bond->slave_cnt)
  		ret = __bond_start_xmit(skb, dev);
  	else
 -		dev_kfree_skb_any(skb);
 -	rcu_read_unlock();
 +		kfree_skb(skb);
 +
 +	read_unlock(&bond->lock);
  
  	return ret;
  }
@@@ -4347,18 -3859,19 +4393,16 @@@ int bond_parse_parm(const char *buf, co
  static int bond_check_params(struct bond_params *params)
  {
  	int arp_validate_value, fail_over_mac_value, primary_reselect_value, i;
 -	struct bond_opt_value newval;
 -	const struct bond_opt_value *valptr;
  	int arp_all_targets_value;
  
- 	/*
- 	 * Convert string parameters.
- 	 */
+ 	/* Convert string parameters. */
  	if (mode) {
 -		bond_opt_initstr(&newval, mode);
 -		valptr = bond_opt_parse(bond_opt_get(BOND_OPT_MODE), &newval);
 -		if (!valptr) {
 -			pr_err("Error: Invalid bonding mode \"%s\"\n", mode);
 +		bond_mode = bond_parse_parm(mode, bond_mode_tbl);
 +		if (bond_mode == -1) {
 +			pr_err("Error: Invalid bonding mode \"%s\"\n",
 +			       mode == NULL ? "NULL" : mode);
  			return -EINVAL;
  		}
 -		bond_mode = valptr->value;
  	}
  
  	if (xmit_hash_policy) {
@@@ -4529,13 -4040,13 +4573,13 @@@
  
  	for (arp_ip_count = 0, i = 0;
  	     (arp_ip_count < BOND_MAX_ARP_TARGETS) && arp_ip_target[i]; i++) {
- 		/* not complete check, but should be good enough to
- 		   catch mistakes */
  		__be32 ip;
+ 
+ 		/* not a complete check, but good enough to catch mistakes */
  		if (!in4_pton(arp_ip_target[i], -1, (u8 *)&ip, -1, NULL) ||
 -		    !bond_is_ip_target_ok(ip)) {
 -			pr_warn("Warning: bad arp_ip_target module parameter (%s), ARP monitoring will not be performed\n",
 -				arp_ip_target[i]);
 +		    IS_IP_TARGET_UNUSABLE_ADDRESS(ip)) {
 +			pr_warning("Warning: bad arp_ip_target module parameter (%s), ARP monitoring will not be performed\n",
 +				   arp_ip_target[i]);
  			arp_interval = 0;
  		} else {
  			if (bond_get_targets_ip(arp_target, ip) == -1)
diff --cc drivers/net/bonding/bonding.h
index 64c0cb81e478,6140bf0264a4..000000000000
--- a/drivers/net/bonding/bonding.h
+++ b/drivers/net/bonding/bonding.h
@@@ -224,8 -195,14 +224,19 @@@ struct bonding 
  	s32      slave_cnt; /* never change this value outside the attach/detach wrappers */
  	int     (*recv_probe)(const struct sk_buff *, struct bonding *,
  			      struct slave *);
++<<<<<<< HEAD
 +	rwlock_t lock;
 +	rwlock_t curr_slave_lock;
++=======
+ 	/* mode_lock is used for mode-specific locking needs, currently used by:
+ 	 * 3ad mode (4) - protect against running bond_3ad_unbind_slave() and
+ 	 *                bond_3ad_state_machine_handler() concurrently and also
+ 	 *                the access to the state machine shared variables.
+ 	 * TLB mode (5) - to sync the use and modifications of its hash table
+ 	 * ALB mode (6) - to sync the use and modifications of its hash table
+ 	 */
+ 	spinlock_t mode_lock;
++>>>>>>> 547942cace50 (bonding: trivial: style and comment fixes)
  	u8	 send_peer_notif;
  	u8       igmp_retrans;
  #ifdef CONFIG_PROC_FS
* Unmerged path drivers/net/bonding/bond_3ad.c
* Unmerged path drivers/net/bonding/bond_alb.c
diff --git a/drivers/net/bonding/bond_debugfs.c b/drivers/net/bonding/bond_debugfs.c
index 5fc4c2351478..3b51fc2b23c0 100644
--- a/drivers/net/bonding/bond_debugfs.c
+++ b/drivers/net/bonding/bond_debugfs.c
@@ -13,9 +13,7 @@
 
 static struct dentry *bonding_debug_root;
 
-/*
- *  Show RLB hash table
- */
+/* Show RLB hash table */
 static int bond_debug_rlb_hash_show(struct seq_file *m, void *v)
 {
 	struct bonding *bond = m->private;
* Unmerged path drivers/net/bonding/bond_main.c
diff --git a/drivers/net/bonding/bond_sysfs.c b/drivers/net/bonding/bond_sysfs.c
index c7fd44189961..f5f767318f0c 100644
--- a/drivers/net/bonding/bond_sysfs.c
+++ b/drivers/net/bonding/bond_sysfs.c
@@ -94,7 +94,6 @@ static struct net_device *bond_get_by_name(struct bond_net *bn, const char *ifna
  * creates and deletes entire bonds.
  *
  * The class parameter is ignored.
- *
  */
 
 static ssize_t bonding_store_bonds(struct class *cls,
* Unmerged path drivers/net/bonding/bonding.h
