clk: wrap I/O access for improved portability

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Gerhard Sittig <gsi@denx.de>
commit aa514ce34b65e3dc01f95a0b470b39bbb7e09998
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/aa514ce3.failed

the common clock drivers were motivated/initiated by ARM development
and apparently assume little endian peripherals

wrap register/peripherals access in the common code (div, gate, mux)
in preparation of adding COMMON_CLK support for other platforms

	Signed-off-by: Gerhard Sittig <gsi@denx.de>
	Signed-off-by: Mike Turquette <mturquette@linaro.org>
(cherry picked from commit aa514ce34b65e3dc01f95a0b470b39bbb7e09998)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/clk/clk-divider.c
#	drivers/clk/clk-gate.c
#	drivers/clk/clk-mux.c
#	include/linux/clk-provider.h
diff --cc drivers/clk/clk-divider.c
index 6d9674160430,8d3009e44fba..000000000000
--- a/drivers/clk/clk-divider.c
+++ b/drivers/clk/clk-divider.c
@@@ -217,10 -227,14 +217,19 @@@ static int clk_divider_set_rate(struct 
  	if (divider->lock)
  		spin_lock_irqsave(divider->lock, flags);
  
++<<<<<<< HEAD
 +	val = readl(divider->reg);
 +	val &= ~(div_mask(divider) << divider->shift);
++=======
+ 	if (divider->flags & CLK_DIVIDER_HIWORD_MASK) {
+ 		val = div_mask(divider) << (divider->shift + 16);
+ 	} else {
+ 		val = clk_readl(divider->reg);
+ 		val &= ~(div_mask(divider) << divider->shift);
+ 	}
++>>>>>>> aa514ce34b65 (clk: wrap I/O access for improved portability)
  	val |= value << divider->shift;
- 	writel(val, divider->reg);
+ 	clk_writel(val, divider->reg);
  
  	if (divider->lock)
  		spin_unlock_irqrestore(divider->lock, flags);
diff --cc drivers/clk/clk-gate.c
index 15114febfd92,4a58c55255bd..000000000000
--- a/drivers/clk/clk-gate.c
+++ b/drivers/clk/clk-gate.c
@@@ -53,14 -53,20 +53,23 @@@ static void clk_gate_endisable(struct c
  	if (gate->lock)
  		spin_lock_irqsave(gate->lock, flags);
  
++<<<<<<< HEAD
 +	reg = readl(gate->reg);
++=======
+ 	if (gate->flags & CLK_GATE_HIWORD_MASK) {
+ 		reg = BIT(gate->bit_idx + 16);
+ 		if (set)
+ 			reg |= BIT(gate->bit_idx);
+ 	} else {
+ 		reg = clk_readl(gate->reg);
++>>>>>>> aa514ce34b65 (clk: wrap I/O access for improved portability)
  
 -		if (set)
 -			reg |= BIT(gate->bit_idx);
 -		else
 -			reg &= ~BIT(gate->bit_idx);
 -	}
 +	if (set)
 +		reg |= BIT(gate->bit_idx);
 +	else
 +		reg &= ~BIT(gate->bit_idx);
  
- 	writel(reg, gate->reg);
+ 	clk_writel(reg, gate->reg);
  
  	if (gate->lock)
  		spin_unlock_irqrestore(gate->lock, flags);
diff --cc drivers/clk/clk-mux.c
index 25b1734560d0,4f96ff3ba728..000000000000
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@@ -86,10 -86,14 +86,19 @@@ static int clk_mux_set_parent(struct cl
  	if (mux->lock)
  		spin_lock_irqsave(mux->lock, flags);
  
++<<<<<<< HEAD
 +	val = readl(mux->reg);
 +	val &= ~(mux->mask << mux->shift);
++=======
+ 	if (mux->flags & CLK_MUX_HIWORD_MASK) {
+ 		val = mux->mask << (mux->shift + 16);
+ 	} else {
+ 		val = clk_readl(mux->reg);
+ 		val &= ~(mux->mask << mux->shift);
+ 	}
++>>>>>>> aa514ce34b65 (clk: wrap I/O access for improved portability)
  	val |= index << mux->shift;
- 	writel(val, mux->reg);
+ 	clk_writel(val, mux->reg);
  
  	if (mux->lock)
  		spin_unlock_irqrestore(mux->lock, flags);
diff --cc include/linux/clk-provider.h
index 11860985fecb,73bdb69f0c08..000000000000
--- a/include/linux/clk-provider.h
+++ b/include/linux/clk-provider.h
@@@ -439,10 -476,50 +440,56 @@@ const char *of_clk_get_parent_name(stru
  
  void of_clk_init(const struct of_device_id *matches);
  
 -#else /* !CONFIG_OF */
 +#define CLK_OF_DECLARE(name, compat, fn)			\
 +	static const struct of_device_id __clk_of_table_##name	\
 +		__used __section(__clk_of_table)		\
 +		= { .compatible = compat, .data = fn };
  
++<<<<<<< HEAD
++=======
+ static inline int of_clk_add_provider(struct device_node *np,
+ 			struct clk *(*clk_src_get)(struct of_phandle_args *args,
+ 						   void *data),
+ 			void *data)
+ {
+ 	return 0;
+ }
+ #define of_clk_del_provider(np) \
+ 	{ while (0); }
+ static inline struct clk *of_clk_src_simple_get(
+ 	struct of_phandle_args *clkspec, void *data)
+ {
+ 	return ERR_PTR(-ENOENT);
+ }
+ static inline struct clk *of_clk_src_onecell_get(
+ 	struct of_phandle_args *clkspec, void *data)
+ {
+ 	return ERR_PTR(-ENOENT);
+ }
+ static inline const char *of_clk_get_parent_name(struct device_node *np,
+ 						 int index)
+ {
+ 	return NULL;
+ }
+ #define of_clk_init(matches) \
+ 	{ while (0); }
+ #endif /* CONFIG_OF */
+ 
+ /*
+  * wrap access to peripherals in accessor routines
+  * for improved portability across platforms
+  */
+ 
+ static inline u32 clk_readl(u32 __iomem *reg)
+ {
+ 	return readl(reg);
+ }
+ 
+ static inline void clk_writel(u32 val, u32 __iomem *reg)
+ {
+ 	writel(val, reg);
+ }
+ 
++>>>>>>> aa514ce34b65 (clk: wrap I/O access for improved portability)
  #endif /* CONFIG_COMMON_CLK */
  #endif /* CLK_PROVIDER_H */
* Unmerged path drivers/clk/clk-divider.c
* Unmerged path drivers/clk/clk-gate.c
* Unmerged path drivers/clk/clk-mux.c
* Unmerged path include/linux/clk-provider.h
