ALSA: hda - Migrate more hdac_stream codes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [alsa] hda - Migrate more hdac_stream codes (Jaroslav Kysela) [1197064]
Rebuild_FUZZ: 92.31%
commit-author Takashi Iwai <tiwai@suse.de>
commit ccc98865aa44184e34de8df96dc837726c978949
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/ccc98865.failed

... including dsp loader helpers.  Lots of codes removed.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit ccc98865aa44184e34de8df96dc837726c978949)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/hda_controller.c
diff --cc sound/pci/hda/hda_controller.c
index 0d7233e1e418,32f98f71c1e6..000000000000
--- a/sound/pci/hda/hda_controller.c
+++ b/sound/pci/hda/hda_controller.c
@@@ -27,146 -27,15 +27,149 @@@
  #include <linux/module.h>
  #include <linux/pm_runtime.h>
  #include <linux/slab.h>
 +#include <linux/reboot.h>
  #include <sound/core.h>
  #include <sound/initval.h>
 +#include "hda_priv.h"
  #include "hda_controller.h"
  
 +#define CREATE_TRACE_POINTS
 +#include "hda_intel_trace.h"
 +
  /* DSP lock helpers */
 -#define dsp_lock(dev)		snd_hdac_dsp_lock(azx_stream(dev))
 -#define dsp_unlock(dev)		snd_hdac_dsp_unlock(azx_stream(dev))
 -#define dsp_is_locked(dev)	snd_hdac_stream_is_locked(azx_stream(dev))
 +#ifdef CONFIG_SND_HDA_DSP_LOADER
 +#define dsp_lock_init(dev)	mutex_init(&(dev)->dsp_mutex)
 +#define dsp_lock(dev)		mutex_lock(&(dev)->dsp_mutex)
 +#define dsp_unlock(dev)		mutex_unlock(&(dev)->dsp_mutex)
 +#define dsp_is_locked(dev)	((dev)->locked)
 +#else
 +#define dsp_lock_init(dev)	do {} while (0)
 +#define dsp_lock(dev)		do {} while (0)
 +#define dsp_unlock(dev)		do {} while (0)
 +#define dsp_is_locked(dev)	0
 +#endif
 +
++<<<<<<< HEAD
 +/*
 + * AZX stream operations.
 + */
 +
 +/* start a stream */
 +static void azx_stream_start(struct azx *chip, struct azx_dev *azx_dev)
 +{
 +	/*
 +	 * Before stream start, initialize parameter
 +	 */
 +	azx_dev->insufficient = 1;
 +
 +	/* enable SIE */
 +	azx_writel(chip, INTCTL,
 +		   azx_readl(chip, INTCTL) | (1 << azx_dev->index));
 +	/* set DMA start and interrupt mask */
 +	azx_sd_writeb(chip, azx_dev, SD_CTL,
 +		      azx_sd_readb(chip, azx_dev, SD_CTL) |
 +		      SD_CTL_DMA_START | SD_INT_MASK);
 +}
 +
 +/* stop DMA */
 +static void azx_stream_clear(struct azx *chip, struct azx_dev *azx_dev)
 +{
 +	azx_sd_writeb(chip, azx_dev, SD_CTL,
 +		      azx_sd_readb(chip, azx_dev, SD_CTL) &
 +		      ~(SD_CTL_DMA_START | SD_INT_MASK));
 +	azx_sd_writeb(chip, azx_dev, SD_STS, SD_INT_MASK); /* to be sure */
 +}
  
 +/* stop a stream */
 +void azx_stream_stop(struct azx *chip, struct azx_dev *azx_dev)
 +{
 +	azx_stream_clear(chip, azx_dev);
 +	/* disable SIE */
 +	azx_writel(chip, INTCTL,
 +		   azx_readl(chip, INTCTL) & ~(1 << azx_dev->index));
 +}
 +EXPORT_SYMBOL_GPL(azx_stream_stop);
 +
 +/* reset stream */
 +static void azx_stream_reset(struct azx *chip, struct azx_dev *azx_dev)
 +{
 +	unsigned char val;
 +	int timeout;
 +
 +	azx_stream_clear(chip, azx_dev);
 +
 +	azx_sd_writeb(chip, azx_dev, SD_CTL,
 +		      azx_sd_readb(chip, azx_dev, SD_CTL) |
 +		      SD_CTL_STREAM_RESET);
 +	udelay(3);
 +	timeout = 300;
 +	while (!((val = azx_sd_readb(chip, azx_dev, SD_CTL)) &
 +		 SD_CTL_STREAM_RESET) && --timeout)
 +		;
 +	val &= ~SD_CTL_STREAM_RESET;
 +	azx_sd_writeb(chip, azx_dev, SD_CTL, val);
 +	udelay(3);
 +
 +	timeout = 300;
 +	/* waiting for hardware to report that the stream is out of reset */
 +	while (((val = azx_sd_readb(chip, azx_dev, SD_CTL)) &
 +		SD_CTL_STREAM_RESET) && --timeout)
 +		;
 +
 +	/* reset first position - may not be synced with hw at this time */
 +	*azx_dev->posbuf = 0;
 +}
 +
 +/*
 + * set up the SD for streaming
 + */
 +static int azx_setup_controller(struct azx *chip, struct azx_dev *azx_dev)
 +{
 +	unsigned int val;
 +	/* make sure the run bit is zero for SD */
 +	azx_stream_clear(chip, azx_dev);
 +	/* program the stream_tag */
 +	val = azx_sd_readl(chip, azx_dev, SD_CTL);
 +	val = (val & ~SD_CTL_STREAM_TAG_MASK) |
 +		(azx_dev->stream_tag << SD_CTL_STREAM_TAG_SHIFT);
 +	if (!azx_snoop(chip))
 +		val |= SD_CTL_TRAFFIC_PRIO;
 +	azx_sd_writel(chip, azx_dev, SD_CTL, val);
 +
 +	/* program the length of samples in cyclic buffer */
 +	azx_sd_writel(chip, azx_dev, SD_CBL, azx_dev->bufsize);
 +
 +	/* program the stream format */
 +	/* this value needs to be the same as the one programmed */
 +	azx_sd_writew(chip, azx_dev, SD_FORMAT, azx_dev->format_val);
 +
 +	/* program the stream LVI (last valid index) of the BDL */
 +	azx_sd_writew(chip, azx_dev, SD_LVI, azx_dev->frags - 1);
 +
 +	/* program the BDL address */
 +	/* lower BDL address */
 +	azx_sd_writel(chip, azx_dev, SD_BDLPL, (u32)azx_dev->bdl.addr);
 +	/* upper BDL address */
 +	azx_sd_writel(chip, azx_dev, SD_BDLPU,
 +		      upper_32_bits(azx_dev->bdl.addr));
 +
 +	/* enable the position buffer */
 +	if (chip->get_position[0] != azx_get_pos_lpib ||
 +	    chip->get_position[1] != azx_get_pos_lpib) {
 +		if (!(azx_readl(chip, DPLBASE) & AZX_DPLBASE_ENABLE))
 +			azx_writel(chip, DPLBASE,
 +				(u32)chip->posbuf.addr | AZX_DPLBASE_ENABLE);
 +	}
 +
 +	/* set the interrupt enable bits in the descriptor control register */
 +	azx_sd_writel(chip, azx_dev, SD_CTL,
 +		      azx_sd_readl(chip, azx_dev, SD_CTL) | SD_INT_MASK);
 +
 +	return 0;
 +}
 +
++=======
++>>>>>>> ccc98865aa44 (ALSA: hda - Migrate more hdac_stream codes)
  /* assign a stream for the PCM */
  static inline struct azx_dev *
  azx_assign_device(struct azx *chip, struct snd_pcm_substream *substream)
@@@ -212,51 -51,14 +215,59 @@@
  /* release the assigned stream */
  static inline void azx_release_device(struct azx_dev *azx_dev)
  {
 -	snd_hdac_stream_release(azx_stream(azx_dev));
 +	azx_dev->opened = 0;
  }
  
++<<<<<<< HEAD
 +static cycle_t azx_cc_read(const struct cyclecounter *cc)
 +{
 +	struct azx_dev *azx_dev = container_of(cc, struct azx_dev, azx_cc);
 +	struct snd_pcm_substream *substream = azx_dev->substream;
 +	struct azx_pcm *apcm = snd_pcm_substream_chip(substream);
 +	struct azx *chip = apcm->chip;
 +
 +	return azx_readl(chip, WALLCLK);
 +}
 +
 +static void azx_timecounter_init(struct snd_pcm_substream *substream,
 +				bool force, cycle_t last)
 +{
 +	struct azx_dev *azx_dev = get_azx_dev(substream);
 +	struct timecounter *tc = &azx_dev->azx_tc;
 +	struct cyclecounter *cc = &azx_dev->azx_cc;
 +	u64 nsec;
 +
 +	cc->read = azx_cc_read;
 +	cc->mask = CLOCKSOURCE_MASK(32);
 +
 +	/*
 +	 * Converting from 24 MHz to ns means applying a 125/3 factor.
 +	 * To avoid any saturation issues in intermediate operations,
 +	 * the 125 factor is applied first. The division is applied
 +	 * last after reading the timecounter value.
 +	 * Applying the 1/3 factor as part of the multiplication
 +	 * requires at least 20 bits for a decent precision, however
 +	 * overflows occur after about 4 hours or less, not a option.
 +	 */
 +
 +	cc->mult = 125; /* saturation after 195 years */
 +	cc->shift = 0;
 +
 +	nsec = 0; /* audio time is elapsed time since trigger */
 +	timecounter_init(tc, cc, nsec);
 +	if (force)
 +		/*
 +		 * force timecounter to use predefined value,
 +		 * used for synchronized starts
 +		 */
 +		tc->cycle_last = last;
++=======
+ static inline struct hda_pcm_stream *
+ to_hda_pcm_stream(struct snd_pcm_substream *substream)
+ {
+ 	struct azx_pcm *apcm = snd_pcm_substream_chip(substream);
+ 	return &apcm->info->stream[substream->stream];
++>>>>>>> ccc98865aa44 (ALSA: hda - Migrate more hdac_stream codes)
  }
  
  static u64 azx_adjust_codec_delay(struct snd_pcm_substream *substream,
@@@ -280,135 -82,17 +291,140 @@@
  }
  
  /*
++<<<<<<< HEAD
 + * set up a BDL entry
 + */
 +static int setup_bdle(struct azx *chip,
 +		      struct snd_dma_buffer *dmab,
 +		      struct azx_dev *azx_dev, u32 **bdlp,
 +		      int ofs, int size, int with_ioc)
 +{
 +	u32 *bdl = *bdlp;
 +
 +	while (size > 0) {
 +		dma_addr_t addr;
 +		int chunk;
 +
 +		if (azx_dev->frags >= AZX_MAX_BDL_ENTRIES)
 +			return -EINVAL;
 +
 +		addr = snd_sgbuf_get_addr(dmab, ofs);
 +		/* program the address field of the BDL entry */
 +		bdl[0] = cpu_to_le32((u32)addr);
 +		bdl[1] = cpu_to_le32(upper_32_bits(addr));
 +		/* program the size field of the BDL entry */
 +		chunk = snd_sgbuf_get_chunk_size(dmab, ofs, size);
 +		/* one BDLE cannot cross 4K boundary on CTHDA chips */
 +		if (chip->driver_caps & AZX_DCAPS_4K_BDLE_BOUNDARY) {
 +			u32 remain = 0x1000 - (ofs & 0xfff);
 +			if (chunk > remain)
 +				chunk = remain;
 +		}
 +		bdl[2] = cpu_to_le32(chunk);
 +		/* program the IOC to enable interrupt
 +		 * only when the whole fragment is processed
 +		 */
 +		size -= chunk;
 +		bdl[3] = (size || !with_ioc) ? 0 : cpu_to_le32(0x01);
 +		bdl += 4;
 +		azx_dev->frags++;
 +		ofs += chunk;
 +	}
 +	*bdlp = bdl;
 +	return ofs;
 +}
 +
 +/*
 + * set up BDL entries
 + */
 +static int azx_setup_periods(struct azx *chip,
 +			     struct snd_pcm_substream *substream,
 +			     struct azx_dev *azx_dev)
 +{
 +	u32 *bdl;
 +	int i, ofs, periods, period_bytes;
 +	int pos_adj = 0;
 +
 +	/* reset BDL address */
 +	azx_sd_writel(chip, azx_dev, SD_BDLPL, 0);
 +	azx_sd_writel(chip, azx_dev, SD_BDLPU, 0);
 +
 +	period_bytes = azx_dev->period_bytes;
 +	periods = azx_dev->bufsize / period_bytes;
 +
 +	/* program the initial BDL entries */
 +	bdl = (u32 *)azx_dev->bdl.area;
 +	ofs = 0;
 +	azx_dev->frags = 0;
 +
 +	if (chip->bdl_pos_adj)
 +		pos_adj = chip->bdl_pos_adj[chip->dev_index];
 +	if (!azx_dev->no_period_wakeup && pos_adj > 0) {
 +		struct snd_pcm_runtime *runtime = substream->runtime;
 +		int pos_align = pos_adj;
 +		pos_adj = (pos_adj * runtime->rate + 47999) / 48000;
 +		if (!pos_adj)
 +			pos_adj = pos_align;
 +		else
 +			pos_adj = ((pos_adj + pos_align - 1) / pos_align) *
 +				pos_align;
 +		pos_adj = frames_to_bytes(runtime, pos_adj);
 +		if (pos_adj >= period_bytes) {
 +			dev_warn(chip->card->dev,"Too big adjustment %d\n",
 +				 pos_adj);
 +			pos_adj = 0;
 +		} else {
 +			ofs = setup_bdle(chip, snd_pcm_get_dma_buf(substream),
 +					 azx_dev,
 +					 &bdl, ofs, pos_adj, true);
 +			if (ofs < 0)
 +				goto error;
 +		}
 +	} else
 +		pos_adj = 0;
 +
 +	for (i = 0; i < periods; i++) {
 +		if (i == periods - 1 && pos_adj)
 +			ofs = setup_bdle(chip, snd_pcm_get_dma_buf(substream),
 +					 azx_dev, &bdl, ofs,
 +					 period_bytes - pos_adj, 0);
 +		else
 +			ofs = setup_bdle(chip, snd_pcm_get_dma_buf(substream),
 +					 azx_dev, &bdl, ofs,
 +					 period_bytes,
 +					 !azx_dev->no_period_wakeup);
 +		if (ofs < 0)
 +			goto error;
 +	}
 +	return 0;
 +
 + error:
 +	dev_err(chip->card->dev, "Too many BDL entries: buffer=%d, period=%d\n",
 +		azx_dev->bufsize, period_bytes);
 +	return -EINVAL;
 +}
 +
 +/*
++=======
++>>>>>>> ccc98865aa44 (ALSA: hda - Migrate more hdac_stream codes)
   * PCM ops
   */
  
  static int azx_pcm_close(struct snd_pcm_substream *substream)
  {
  	struct azx_pcm *apcm = snd_pcm_substream_chip(substream);
 -	struct hda_pcm_stream *hinfo = to_hda_pcm_stream(substream);
 +	struct hda_pcm_stream *hinfo = apcm->hinfo[substream->stream];
  	struct azx *chip = apcm->chip;
  	struct azx_dev *azx_dev = get_azx_dev(substream);
- 	unsigned long flags;
  
  	mutex_lock(&chip->open_mutex);
++<<<<<<< HEAD
 +	spin_lock_irqsave(&chip->reg_lock, flags);
 +	azx_dev->substream = NULL;
 +	azx_dev->running = 0;
 +	spin_unlock_irqrestore(&chip->reg_lock, flags);
++=======
++>>>>>>> ccc98865aa44 (ALSA: hda - Migrate more hdac_stream codes)
  	azx_release_device(azx_dev);
  	if (hinfo->ops.close)
  		hinfo->ops.close(hinfo, apcm->codec, substream);
@@@ -448,14 -132,8 +464,19 @@@ static int azx_pcm_hw_free(struct snd_p
  
  	/* reset BDL address */
  	dsp_lock(azx_dev);
++<<<<<<< HEAD
 +	if (!dsp_is_locked(azx_dev)) {
 +		azx_sd_writel(chip, azx_dev, SD_BDLPL, 0);
 +		azx_sd_writel(chip, azx_dev, SD_BDLPU, 0);
 +		azx_sd_writel(chip, azx_dev, SD_CTL, 0);
 +		azx_dev->bufsize = 0;
 +		azx_dev->period_bytes = 0;
 +		azx_dev->format_val = 0;
 +	}
++=======
+ 	if (!dsp_is_locked(azx_dev))
+ 		snd_hdac_stream_cleanup(azx_stream(azx_dev));
++>>>>>>> ccc98865aa44 (ALSA: hda - Migrate more hdac_stream codes)
  
  	snd_hda_codec_cleanup(apcm->codec, hinfo, substream);
  
@@@ -505,39 -183,22 +526,55 @@@ static int azx_pcm_prepare(struct snd_p
  	dev_dbg(chip->card->dev, "azx_pcm_prepare: bufsize=0x%x, format=0x%x\n",
  		bufsize, format_val);
  
++<<<<<<< HEAD
 +	if (bufsize != azx_dev->bufsize ||
 +	    period_bytes != azx_dev->period_bytes ||
 +	    format_val != azx_dev->format_val ||
 +	    runtime->no_period_wakeup != azx_dev->no_period_wakeup) {
 +		azx_dev->bufsize = bufsize;
 +		azx_dev->period_bytes = period_bytes;
 +		azx_dev->format_val = format_val;
 +		azx_dev->no_period_wakeup = runtime->no_period_wakeup;
 +		err = azx_setup_periods(chip, substream, azx_dev);
++=======
+ 	if (bufsize != azx_dev->core.bufsize ||
+ 	    period_bytes != azx_dev->core.period_bytes ||
+ 	    format_val != azx_dev->core.format_val ||
+ 	    runtime->no_period_wakeup != azx_dev->core.no_period_wakeup) {
+ 		azx_dev->core.bufsize = bufsize;
+ 		azx_dev->core.period_bytes = period_bytes;
+ 		azx_dev->core.format_val = format_val;
+ 		azx_dev->core.no_period_wakeup = runtime->no_period_wakeup;
+ 		err = snd_hdac_stream_setup_periods(azx_stream(azx_dev));
++>>>>>>> ccc98865aa44 (ALSA: hda - Migrate more hdac_stream codes)
  		if (err < 0)
  			goto unlock;
  	}
  
++<<<<<<< HEAD
 +	/* when LPIB delay correction gives a small negative value,
 +	 * we ignore it; currently set the threshold statically to
 +	 * 64 frames
 +	 */
 +	if (runtime->period_size > 64)
 +		azx_dev->delay_negative_threshold = -frames_to_bytes(runtime, 64);
 +	else
 +		azx_dev->delay_negative_threshold = 0;
 +
 +	/* wallclk has 24Mhz clock source */
 +	azx_dev->period_wallclk = (((runtime->period_size * 24000) /
 +						runtime->rate) * 1000);
 +	azx_setup_controller(chip, azx_dev);
 +	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 +		azx_dev->fifo_size =
 +			azx_sd_readw(chip, azx_dev, SD_FIFOSIZE) + 1;
 +	else
 +		azx_dev->fifo_size = 0;
++=======
+ 	snd_hdac_stream_setup(azx_stream(azx_dev));
++>>>>>>> ccc98865aa44 (ALSA: hda - Migrate more hdac_stream codes)
  
 -	stream_tag = azx_dev->core.stream_tag;
 +	stream_tag = azx_dev->stream_tag;
  	/* CA-IBG chips need the playback stream starting from 1 */
  	if ((chip->driver_caps & AZX_DCAPS_CTX_WORKAROUND) &&
  	    stream_tag > chip->capture_streams)
@@@ -558,11 -219,17 +595,21 @@@ static int azx_pcm_trigger(struct snd_p
  	struct azx *chip = apcm->chip;
  	struct azx_dev *azx_dev;
  	struct snd_pcm_substream *s;
- 	int rstart = 0, start, nsync = 0, sbits = 0;
- 	int nwait, timeout;
+ 	struct hdac_stream *hstr;
+ 	bool start;
+ 	int sbits = 0;
+ 	int sync_reg;
  
  	azx_dev = get_azx_dev(substream);
++<<<<<<< HEAD
 +	trace_azx_pcm_trigger(chip, azx_dev, cmd);
++=======
+ 	hstr = azx_stream(azx_dev);
+ 	if (chip->driver_caps & AZX_DCAPS_OLD_SSYNC)
+ 		sync_reg = AZX_REG_OLD_SSYNC;
+ 	else
+ 		sync_reg = AZX_REG_SSYNC;
++>>>>>>> ccc98865aa44 (ALSA: hda - Migrate more hdac_stream codes)
  
  	if (dsp_is_locked(azx_dev) || !azx_dev->prepared)
  		return -EPIPE;
@@@ -587,8 -253,7 +633,12 @@@
  		if (s->pcm->card != substream->pcm->card)
  			continue;
  		azx_dev = get_azx_dev(s);
++<<<<<<< HEAD
 +		sbits |= 1 << azx_dev->index;
 +		nsync++;
++=======
+ 		sbits |= 1 << azx_dev->core.index;
++>>>>>>> ccc98865aa44 (ALSA: hda - Migrate more hdac_stream codes)
  		snd_pcm_trigger_done(s, substream);
  	}
  
@@@ -606,76 -267,21 +652,52 @@@
  			continue;
  		azx_dev = get_azx_dev(s);
  		if (start) {
 -			azx_dev->insufficient = 1;
 -			snd_hdac_stream_start(azx_stream(azx_dev), true);
 +			azx_dev->start_wallclk = azx_readl(chip, WALLCLK);
 +			if (!rstart)
 +				azx_dev->start_wallclk -=
 +						azx_dev->period_wallclk;
 +			azx_stream_start(chip, azx_dev);
  		} else {
 -			snd_hdac_stream_stop(azx_stream(azx_dev));
 +			azx_stream_stop(chip, azx_dev);
  		}
 +		azx_dev->running = start;
  	}
  	spin_unlock(&chip->reg_lock);
- 	if (start) {
- 		/* wait until all FIFOs get ready */
- 		for (timeout = 5000; timeout; timeout--) {
- 			nwait = 0;
- 			snd_pcm_group_for_each_entry(s, substream) {
- 				if (s->pcm->card != substream->pcm->card)
- 					continue;
- 				azx_dev = get_azx_dev(s);
- 				if (!(azx_sd_readb(chip, azx_dev, SD_STS) &
- 				      SD_STS_FIFO_READY))
- 					nwait++;
- 			}
- 			if (!nwait)
- 				break;
- 			cpu_relax();
- 		}
- 	} else {
- 		/* wait until all RUN bits are cleared */
- 		for (timeout = 5000; timeout; timeout--) {
- 			nwait = 0;
- 			snd_pcm_group_for_each_entry(s, substream) {
- 				if (s->pcm->card != substream->pcm->card)
- 					continue;
- 				azx_dev = get_azx_dev(s);
- 				if (azx_sd_readb(chip, azx_dev, SD_CTL) &
- 				    SD_CTL_DMA_START)
- 					nwait++;
- 			}
- 			if (!nwait)
- 				break;
- 			cpu_relax();
- 		}
- 	}
+ 
+ 	snd_hdac_stream_sync(hstr, start, sbits);
+ 
  	spin_lock(&chip->reg_lock);
  	/* reset SYNC bits */
++<<<<<<< HEAD
 +	if (chip->driver_caps & AZX_DCAPS_OLD_SSYNC)
 +		azx_writel(chip, OLD_SSYNC,
 +			azx_readl(chip, OLD_SSYNC) & ~sbits);
 +	else
 +		azx_writel(chip, SSYNC, azx_readl(chip, SSYNC) & ~sbits);
 +	if (start) {
 +		azx_timecounter_init(substream, 0, 0);
 +		snd_pcm_gettime(substream->runtime, &substream->runtime->trigger_tstamp);
 +		substream->runtime->trigger_tstamp_latched = true;
 +
 +		if (nsync > 1) {
 +			cycle_t cycle_last;
 +
 +			/* same start cycle for master and group */
 +			azx_dev = get_azx_dev(substream);
 +			cycle_last = azx_dev->azx_tc.cycle_last;
 +
 +			snd_pcm_group_for_each_entry(s, substream) {
 +				if (s->pcm->card != substream->pcm->card)
 +					continue;
 +				azx_timecounter_init(s, 1, cycle_last);
 +			}
 +		}
 +	}
++=======
+ 	snd_hdac_stream_sync_trigger(hstr, false, sbits, sync_reg);
+ 	if (start)
+ 		snd_hdac_stream_timecounter_init(hstr, sbits);
++>>>>>>> ccc98865aa44 (ALSA: hda - Migrate more hdac_stream codes)
  	spin_unlock(&chip->reg_lock);
  	return 0;
  }
@@@ -869,12 -474,6 +891,15 @@@ static int azx_pcm_open(struct snd_pcm_
  		runtime->hw.info &= ~SNDRV_PCM_INFO_HAS_LINK_ATIME;
  	}
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&chip->reg_lock, flags);
 +	azx_dev->substream = substream;
 +	azx_dev->running = 0;
 +	spin_unlock_irqrestore(&chip->reg_lock, flags);
 +
 +	runtime->private_data = azx_dev;
++=======
++>>>>>>> ccc98865aa44 (ALSA: hda - Migrate more hdac_stream codes)
  	snd_pcm_set_sync(substream);
  	mutex_unlock(&chip->open_mutex);
  	return 0;
@@@ -1372,54 -985,24 +1398,73 @@@ static int azx_load_dsp_prepare(struct 
  	int err;
  
  	azx_dev = azx_get_dsp_loader_dev(chip);
- 
- 	dsp_lock(azx_dev);
+ 	hstr = azx_stream(azx_dev);
  	spin_lock_irq(&chip->reg_lock);
++<<<<<<< HEAD
 +	if (azx_dev->running || azx_dev->locked) {
 +		spin_unlock_irq(&chip->reg_lock);
 +		err = -EBUSY;
 +		goto unlock;
++=======
+ 	if (hstr->opened) {
+ 		chip->saved_azx_dev = *azx_dev;
+ 		saved = true;
++>>>>>>> ccc98865aa44 (ALSA: hda - Migrate more hdac_stream codes)
+ 	}
+ 	spin_unlock_irq(&chip->reg_lock);
+ 
+ 	err = snd_hdac_dsp_prepare(hstr, format, byte_size, bufp);
+ 	if (err < 0) {
+ 		spin_lock_irq(&chip->reg_lock);
+ 		if (saved)
+ 			*azx_dev = chip->saved_azx_dev;
+ 		spin_unlock_irq(&chip->reg_lock);
+ 		return err;
  	}
+ 
  	azx_dev->prepared = 0;
++<<<<<<< HEAD
 +	chip->saved_azx_dev = *azx_dev;
 +	azx_dev->locked = 1;
 +	spin_unlock_irq(&chip->reg_lock);
 +
 +	err = chip->ops->dma_alloc_pages(chip, SNDRV_DMA_TYPE_DEV_SG,
 +					 byte_size, bufp);
 +	if (err < 0)
 +		goto err_alloc;
 +
 +	azx_dev->bufsize = byte_size;
 +	azx_dev->period_bytes = byte_size;
 +	azx_dev->format_val = format;
 +
 +	azx_stream_reset(chip, azx_dev);
 +
 +	/* reset BDL address */
 +	azx_sd_writel(chip, azx_dev, SD_BDLPL, 0);
 +	azx_sd_writel(chip, azx_dev, SD_BDLPU, 0);
 +
 +	azx_dev->frags = 0;
 +	bdl = (u32 *)azx_dev->bdl.area;
 +	err = setup_bdle(chip, bufp, azx_dev, &bdl, 0, byte_size, 0);
 +	if (err < 0)
 +		goto error;
 +
 +	azx_setup_controller(chip, azx_dev);
 +	dsp_unlock(azx_dev);
 +	return azx_dev->stream_tag;
 +
 + error:
 +	chip->ops->dma_free_pages(chip, bufp);
 + err_alloc:
 +	spin_lock_irq(&chip->reg_lock);
 +	if (azx_dev->opened)
 +		*azx_dev = chip->saved_azx_dev;
 +	azx_dev->locked = 0;
 +	spin_unlock_irq(&chip->reg_lock);
 + unlock:
 +	dsp_unlock(azx_dev);
++=======
++>>>>>>> ccc98865aa44 (ALSA: hda - Migrate more hdac_stream codes)
  	return err;
  }
  
@@@ -1428,11 -1011,7 +1473,15 @@@ static void azx_load_dsp_trigger(struc
  	struct azx *chip = bus->private_data;
  	struct azx_dev *azx_dev = azx_get_dsp_loader_dev(chip);
  
++<<<<<<< HEAD
 +	if (start)
 +		azx_stream_start(chip, azx_dev);
 +	else
 +		azx_stream_stop(chip, azx_dev);
 +	azx_dev->running = start;
++=======
+ 	snd_hdac_dsp_trigger(azx_stream(azx_dev), start);
++>>>>>>> ccc98865aa44 (ALSA: hda - Migrate more hdac_stream codes)
  }
  
  static void azx_load_dsp_cleanup(struct hda_bus *bus,
@@@ -1440,28 -1019,17 +1489,36 @@@
  {
  	struct azx *chip = bus->private_data;
  	struct azx_dev *azx_dev = azx_get_dsp_loader_dev(chip);
+ 	struct hdac_stream *hstr = azx_stream(azx_dev);
  
 -	if (!dmab->area || !azx_dev->core.locked)
 +	if (!dmab->area || !azx_dev->locked)
  		return;
  
++<<<<<<< HEAD
 +	dsp_lock(azx_dev);
 +	/* reset BDL address */
 +	azx_sd_writel(chip, azx_dev, SD_BDLPL, 0);
 +	azx_sd_writel(chip, azx_dev, SD_BDLPU, 0);
 +	azx_sd_writel(chip, azx_dev, SD_CTL, 0);
 +	azx_dev->bufsize = 0;
 +	azx_dev->period_bytes = 0;
 +	azx_dev->format_val = 0;
 +
 +	chip->ops->dma_free_pages(chip, dmab);
 +	dmab->area = NULL;
 +
 +	spin_lock_irq(&chip->reg_lock);
 +	if (azx_dev->opened)
 +		*azx_dev = chip->saved_azx_dev;
 +	azx_dev->locked = 0;
++=======
+ 	snd_hdac_dsp_cleanup(hstr, dmab);
+ 	spin_lock_irq(&chip->reg_lock);
+ 	if (hstr->opened)
+ 		*azx_dev = chip->saved_azx_dev;
+ 	hstr->locked = false;
++>>>>>>> ccc98865aa44 (ALSA: hda - Migrate more hdac_stream codes)
  	spin_unlock_irq(&chip->reg_lock);
- 	dsp_unlock(azx_dev);
  }
  #endif /* CONFIG_SND_HDA_DSP_LOADER */
  
@@@ -1851,9 -1406,12 +1908,18 @@@ int azx_bus_create(struct azx *chip, co
  	bus->pci = chip->pci;
  	bus->modelname = model;
  	bus->ops = bus_ops;
++<<<<<<< HEAD
 +#ifdef CONFIG_PM
 +	bus->power_save = power_save_to;
 +#endif
++=======
+ 	bus->core.snoop = azx_snoop(chip);
+ 	if (chip->get_position[0] != azx_get_pos_lpib ||
+ 	    chip->get_position[1] != azx_get_pos_lpib)
+ 		bus->core.use_posbuf = true;
+ 	if (chip->bdl_pos_adj)
+ 		bus->core.bdl_pos_adj = chip->bdl_pos_adj[chip->dev_index];
++>>>>>>> ccc98865aa44 (ALSA: hda - Migrate more hdac_stream codes)
  
  	if (chip->driver_caps & AZX_DCAPS_RIRB_DELAY) {
  		dev_dbg(chip->card->dev, "Enable delay in RIRB handling\n");
* Unmerged path sound/pci/hda/hda_controller.c
diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c
index 8224bf75d072..09a3b3b562d0 100644
--- a/sound/pci/hda/hda_intel.c
+++ b/sound/pci/hda/hda_intel.c
@@ -573,6 +573,9 @@ static int azx_position_ok(struct azx *chip, struct azx_dev *azx_dev)
 			dev_info(chip->card->dev,
 				 "Invalid position buffer, using LPIB read method instead.\n");
 			chip->get_position[stream] = azx_get_pos_lpib;
+			if (chip->get_position[0] == azx_get_pos_lpib &&
+			    chip->get_position[1] == azx_get_pos_lpib)
+				azx_bus(chip)->use_posbuf = false;
 			pos = azx_get_pos_lpib(chip, azx_dev);
 			chip->get_delay[stream] = NULL;
 		} else {
@@ -1486,6 +1489,7 @@ static int azx_first_init(struct azx *chip)
 		dev_err(card->dev, "ioremap error\n");
 		return -ENXIO;
 	}
+	azx_bus(chip)->remap_addr = chip->remap_addr; /* FIXME */
 
 	if (chip->msi) {
 		if (chip->driver_caps & AZX_DCAPS_NO_MSI64) {
diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 6c19abff991c..314190df11ea 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -327,6 +327,7 @@ static int hda_tegra_init_chip(struct azx *chip, struct platform_device *pdev)
 		return PTR_ERR(hda->regs);
 
 	chip->remap_addr = hda->regs + HDA_BAR0;
+	azx_bus(chip)->remap_addr = chip->remap_addr; /* FIXME */
 	chip->addr = res->start + HDA_BAR0;
 
 	err = hda_tegra_enable_clocks(hda);
