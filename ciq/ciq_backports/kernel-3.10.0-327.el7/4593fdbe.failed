blk-mq: fix sysfs registration/unregistration race

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Akinobu Mita <akinobu.mita@gmail.com>
commit 4593fdbe7a2f44d5e64c627c715dd0bcec9bdf14
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/4593fdbe.failed

There is a race between cpu hotplug handling and adding/deleting
gendisk for blk-mq, where both are trying to register and unregister
the same sysfs entries.

null_add_dev
    --> blk_mq_init_queue
        --> blk_mq_init_allocated_queue
            --> add to 'all_q_list' (*)
    --> add_disk
        --> blk_register_queue
            --> blk_mq_register_disk (++)

null_del_dev
    --> del_gendisk
        --> blk_unregister_queue
            --> blk_mq_unregister_disk (--)
    --> blk_cleanup_queue
        --> blk_mq_free_queue
            --> del from 'all_q_list' (*)

blk_mq_queue_reinit
    --> blk_mq_sysfs_unregister (-)
    --> blk_mq_sysfs_register (+)

While the request queue is added to 'all_q_list' (*),
blk_mq_queue_reinit() can be called for the queue anytime by CPU
hotplug callback.  But blk_mq_sysfs_unregister (-) and
blk_mq_sysfs_register (+) in blk_mq_queue_reinit must not be called
before blk_mq_register_disk (++) and after blk_mq_unregister_disk (--)
is finished.  Because '/sys/block/*/mq/' is not exists.

There has already been BLK_MQ_F_SYSFS_UP flag in hctx->flags which can
be used to track these sysfs stuff, but it is only fixing this issue
partially.

In order to fix it completely, we just need per-queue flag instead of
per-hctx flag with appropriate locking.  So this introduces
q->mq_sysfs_init_done which is properly protected with all_q_mutex.

Also, we need to ensure that blk_mq_map_swqueue() is called with
all_q_mutex is held.  Since hctx->nr_ctx is reset temporarily and
updated in blk_mq_map_swqueue(), so we should avoid
blk_mq_register_hctx() seeing the temporary hctx->nr_ctx value
in CPU hotplug handling or adding/deleting gendisk .

	Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
	Reviewed-by: Ming Lei <tom.leiming@gmail.com>
	Cc: Ming Lei <tom.leiming@gmail.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 4593fdbe7a2f44d5e64c627c715dd0bcec9bdf14)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq.c
#	include/linux/blk-mq.h
#	include/linux/blkdev.h
diff --cc block/blk-mq.c
index c84efe52e26a,0262131ac5f2..000000000000
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@@ -1894,25 -2032,18 +1894,29 @@@ struct request_queue *blk_mq_init_queue
  	blk_mq_init_cpu_queues(q, set->nr_hw_queues);
  
  	if (blk_mq_init_hw_queues(q, set))
 -		goto err_hctxs;
 +		goto err_hw;
  
  	mutex_lock(&all_q_mutex);
- 	list_add_tail(&q->all_q_node, &all_q_list);
- 	mutex_unlock(&all_q_mutex);
  
+ 	list_add_tail(&q->all_q_node, &all_q_list);
  	blk_mq_add_queue_tag_set(set, q);
++<<<<<<< HEAD
 +
 +	if (blk_mq_init_flush(q))
 +		goto err_hw_queues;
 +
++=======
++>>>>>>> 4593fdbe7a2f (blk-mq: fix sysfs registration/unregistration race)
  	blk_mq_map_swqueue(q);
  
+ 	mutex_unlock(&all_q_mutex);
+ 
  	return q;
  
 +err_hw_queues:
 +	blk_mq_exit_hw_queues(q, set, set->nr_hw_queues);
 +err_hw:
 +	blk_cleanup_queue(q);
  err_hctxs:
  	kfree(map);
  	for (i = 0; i < set->nr_hw_queues; i++) {
diff --cc include/linux/blk-mq.h
index a58379f22a1c,b80ba4572a31..000000000000
--- a/include/linux/blk-mq.h
+++ b/include/linux/blk-mq.h
@@@ -176,10 -143,11 +176,18 @@@ enum 
  	BLK_MQ_RQ_QUEUE_ERROR	= 2,	/* end IO with error */
  
  	BLK_MQ_F_SHOULD_MERGE	= 1 << 0,
++<<<<<<< HEAD
 +	BLK_MQ_F_SHOULD_SORT	= 1 << 1,
 +	BLK_MQ_F_TAG_SHARED	= 1 << 2,
 +	BLK_MQ_F_SG_MERGE	= 1 << 3,
 +	BLK_MQ_F_SYSFS_UP	= 1 << 4,
++=======
+ 	BLK_MQ_F_TAG_SHARED	= 1 << 1,
+ 	BLK_MQ_F_SG_MERGE	= 1 << 2,
+ 	BLK_MQ_F_DEFER_ISSUE	= 1 << 4,
+ 	BLK_MQ_F_ALLOC_POLICY_START_BIT = 8,
+ 	BLK_MQ_F_ALLOC_POLICY_BITS = 1,
++>>>>>>> 4593fdbe7a2f (blk-mq: fix sysfs registration/unregistration race)
  
  	BLK_MQ_S_STOPPED	= 0,
  	BLK_MQ_S_TAG_ACTIVE	= 1,
diff --cc include/linux/blkdev.h
index a4de9d2c30c0,19c2e947d4d1..000000000000
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@@ -507,15 -453,11 +507,23 @@@ struct request_queue 
  	struct percpu_ref	mq_usage_counter;
  	struct list_head	all_q_node;
  
++<<<<<<< HEAD
 +	RH_KABI_EXTEND(unprep_rq_fn		*unprep_rq_fn)
 +
 +	RH_KABI_EXTEND(struct blk_mq_tag_set	*tag_set)
 +	RH_KABI_EXTEND(struct list_head		tag_set_list)
 +
 +	RH_KABI_EXTEND(struct list_head		requeue_list)
 +	RH_KABI_EXTEND(spinlock_t			requeue_lock)
 +	RH_KABI_EXTEND(struct work_struct		requeue_work)
 +	RH_KABI_EXTEND(int				mq_freeze_depth)
++=======
+ 	struct blk_mq_tag_set	*tag_set;
+ 	struct list_head	tag_set_list;
+ 	struct bio_set		*bio_split;
+ 
+ 	bool			mq_sysfs_init_done;
++>>>>>>> 4593fdbe7a2f (blk-mq: fix sysfs registration/unregistration race)
  };
  
  #define QUEUE_FLAG_QUEUED	1	/* uses generic tag queueing */
diff --git a/block/blk-mq-sysfs.c b/block/blk-mq-sysfs.c
index e0fb3f4a628f..ce1742e57c19 100644
--- a/block/blk-mq-sysfs.c
+++ b/block/blk-mq-sysfs.c
@@ -332,7 +332,7 @@ static void blk_mq_unregister_hctx(struct blk_mq_hw_ctx *hctx)
 	struct blk_mq_ctx *ctx;
 	int i;
 
-	if (!hctx->nr_ctx || !(hctx->flags & BLK_MQ_F_SYSFS_UP))
+	if (!hctx->nr_ctx)
 		return;
 
 	hctx_for_each_ctx(hctx, ctx, i)
@@ -347,7 +347,7 @@ static int blk_mq_register_hctx(struct blk_mq_hw_ctx *hctx)
 	struct blk_mq_ctx *ctx;
 	int i, ret;
 
-	if (!hctx->nr_ctx || !(hctx->flags & BLK_MQ_F_SYSFS_UP))
+	if (!hctx->nr_ctx)
 		return 0;
 
 	ret = kobject_add(&hctx->kobj, &q->mq_kobj, "%u", hctx->queue_num);
@@ -370,6 +370,8 @@ void blk_mq_unregister_disk(struct gendisk *disk)
 	struct blk_mq_ctx *ctx;
 	int i, j;
 
+	blk_mq_disable_hotplug();
+
 	queue_for_each_hw_ctx(q, hctx, i) {
 		blk_mq_unregister_hctx(hctx);
 
@@ -384,6 +386,9 @@ void blk_mq_unregister_disk(struct gendisk *disk)
 	kobject_put(&q->mq_kobj);
 
 	kobject_put(&disk_to_dev(disk)->kobj);
+
+	q->mq_sysfs_init_done = false;
+	blk_mq_enable_hotplug();
 }
 
 static void blk_mq_sysfs_init(struct request_queue *q)
@@ -408,27 +413,30 @@ int blk_mq_register_disk(struct gendisk *disk)
 	struct blk_mq_hw_ctx *hctx;
 	int ret, i;
 
+	blk_mq_disable_hotplug();
+
 	blk_mq_sysfs_init(q);
 
 	ret = kobject_add(&q->mq_kobj, kobject_get(&dev->kobj), "%s", "mq");
 	if (ret < 0)
-		return ret;
+		goto out;
 
 	kobject_uevent(&q->mq_kobj, KOBJ_ADD);
 
 	queue_for_each_hw_ctx(q, hctx, i) {
-		hctx->flags |= BLK_MQ_F_SYSFS_UP;
 		ret = blk_mq_register_hctx(hctx);
 		if (ret)
 			break;
 	}
 
-	if (ret) {
+	if (ret)
 		blk_mq_unregister_disk(disk);
-		return ret;
-	}
+	else
+		q->mq_sysfs_init_done = true;
+out:
+	blk_mq_enable_hotplug();
 
-	return 0;
+	return ret;
 }
 
 void blk_mq_sysfs_unregister(struct request_queue *q)
@@ -436,6 +444,9 @@ void blk_mq_sysfs_unregister(struct request_queue *q)
 	struct blk_mq_hw_ctx *hctx;
 	int i;
 
+	if (!q->mq_sysfs_init_done)
+		return;
+
 	queue_for_each_hw_ctx(q, hctx, i)
 		blk_mq_unregister_hctx(hctx);
 }
@@ -445,6 +456,9 @@ int blk_mq_sysfs_register(struct request_queue *q)
 	struct blk_mq_hw_ctx *hctx;
 	int i, ret = 0;
 
+	if (!q->mq_sysfs_init_done)
+		return ret;
+
 	queue_for_each_hw_ctx(q, hctx, i) {
 		ret = blk_mq_register_hctx(hctx);
 		if (ret)
* Unmerged path block/blk-mq.c
* Unmerged path include/linux/blk-mq.h
* Unmerged path include/linux/blkdev.h
