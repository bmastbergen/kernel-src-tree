net/mlx4_core: Capping number of requested MSIXs to MAX_MSIX

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [netdrv] mlx4_core: Capping number of requested MSIXs to MAX_MSIX (Amir Vadai) [1260507]
Rebuild_FUZZ: 96.55%
commit-author Carol L Soto <clsoto@linux.vnet.ibm.com>
commit 9293267a3e2a7a2555d8ddc8f9301525e5b03b1b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/9293267a.failed

We currently manage IRQs in pool_bm which is a bit field
of MAX_MSIX bits. Thus, allocating more than MAX_MSIX
interrupts can't be managed in pool_bm.
Fixing this by capping number of requested MSIXs to
MAX_MSIX.

	Signed-off-by: Matan Barak <matanb@mellanox.com>
	Signed-off-by: Carol L Soto <clsoto@linux.vnet.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9293267a3e2a7a2555d8ddc8f9301525e5b03b1b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx4/main.c
diff --cc drivers/net/ethernet/mellanox/mlx4/main.c
index 79d4da7f5aff,006757f80988..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/main.c
+++ b/drivers/net/ethernet/mellanox/mlx4/main.c
@@@ -2274,14 -2664,19 +2274,24 @@@ static void mlx4_enable_msi_x(struct ml
  {
  	struct mlx4_priv *priv = mlx4_priv(dev);
  	struct msix_entry *entries;
 +	int nreq = min_t(int, dev->caps.num_ports *
 +			 min_t(int, num_online_cpus() + 1,
 +			       MAX_MSIX_P_PORT) + MSIX_LEGACY_SZ, MAX_MSIX);
  	int i;
 -	int port = 0;
  
  	if (msi_x) {
++<<<<<<< HEAD
++=======
+ 		int nreq = dev->caps.num_ports * num_online_cpus() + 1;
+ 		bool shared_ports = false;
+ 
++>>>>>>> 9293267a3e2a (net/mlx4_core: Capping number of requested MSIXs to MAX_MSIX)
  		nreq = min_t(int, dev->caps.num_eqs - dev->caps.reserved_eqs,
  			     nreq);
+ 		if (nreq > MAX_MSIX) {
+ 			nreq = MAX_MSIX;
+ 			shared_ports = true;
+ 		}
  
  		entries = kcalloc(nreq, sizeof *entries, GFP_KERNEL);
  		if (!entries)
@@@ -2290,22 -2685,61 +2300,73 @@@
  		for (i = 0; i < nreq; ++i)
  			entries[i].entry = i;
  
 -		nreq = pci_enable_msix_range(dev->persist->pdev, entries, 2,
 -					     nreq);
 +		nreq = pci_enable_msix_range(dev->pdev, entries, 2, nreq);
  
 -		if (nreq < 0 || nreq < MLX4_EQ_ASYNC) {
 +		if (nreq < 0) {
  			kfree(entries);
  			goto no_msi;
 +		} else if (nreq < MSIX_LEGACY_SZ +
 +			   dev->caps.num_ports * MIN_MSIX_P_PORT) {
 +			/*Working in legacy mode , all EQ's shared*/
 +			dev->caps.comp_pool           = 0;
 +			dev->caps.num_comp_vectors = nreq - 1;
 +		} else {
 +			dev->caps.comp_pool           = nreq - MSIX_LEGACY_SZ;
 +			dev->caps.num_comp_vectors = MSIX_LEGACY_SZ - 1;
  		}
++<<<<<<< HEAD
 +		for (i = 0; i < nreq; ++i)
 +			priv->eq_table.eq[i].irq = entries[i].vector;
++=======
+ 		/* 1 is reserved for events (asyncrounous EQ) */
+ 		dev->caps.num_comp_vectors = nreq - 1;
+ 
+ 		priv->eq_table.eq[MLX4_EQ_ASYNC].irq = entries[0].vector;
+ 		bitmap_zero(priv->eq_table.eq[MLX4_EQ_ASYNC].actv_ports.ports,
+ 			    dev->caps.num_ports);
+ 
+ 		if (MLX4_IS_LEGACY_EQ_MODE(dev->caps))
+ 			shared_ports = true;
+ 
+ 		for (i = 0; i < dev->caps.num_comp_vectors + 1; i++) {
+ 			if (i == MLX4_EQ_ASYNC)
+ 				continue;
+ 
+ 			priv->eq_table.eq[i].irq =
+ 				entries[i + 1 - !!(i > MLX4_EQ_ASYNC)].vector;
+ 
+ 			if (shared_ports) {
+ 				bitmap_fill(priv->eq_table.eq[i].actv_ports.ports,
+ 					    dev->caps.num_ports);
+ 				/* We don't set affinity hint when there
+ 				 * aren't enough EQs
+ 				 */
+ 			} else {
+ 				set_bit(port,
+ 					priv->eq_table.eq[i].actv_ports.ports);
+ 				if (mlx4_init_affinity_hint(dev, port + 1, i))
+ 					mlx4_warn(dev, "Couldn't init hint cpumask for EQ %d\n",
+ 						  i);
+ 			}
+ 			/* We divide the Eqs evenly between the two ports.
+ 			 * (dev->caps.num_comp_vectors / dev->caps.num_ports)
+ 			 * refers to the number of Eqs per port
+ 			 * (i.e eqs_per_port). Theoretically, we would like to
+ 			 * write something like (i + 1) % eqs_per_port == 0.
+ 			 * However, since there's an asynchronous Eq, we have
+ 			 * to skip over it by comparing this condition to
+ 			 * !!((i + 1) > MLX4_EQ_ASYNC).
+ 			 */
+ 			if ((dev->caps.num_comp_vectors > dev->caps.num_ports) &&
+ 			    ((i + 1) %
+ 			     (dev->caps.num_comp_vectors / dev->caps.num_ports)) ==
+ 			    !!((i + 1) > MLX4_EQ_ASYNC))
+ 				/* If dev->caps.num_comp_vectors < dev->caps.num_ports,
+ 				 * everything is shared anyway.
+ 				 */
+ 				port++;
+ 		}
++>>>>>>> 9293267a3e2a (net/mlx4_core: Capping number of requested MSIXs to MAX_MSIX)
  
  		dev->flags |= MLX4_FLAG_MSI_X;
  
* Unmerged path drivers/net/ethernet/mellanox/mlx4/main.c
