md/raid5: avoid reading parity blocks for full-stripe write to degraded array

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [md] raid5: avoid reading parity blocks for full-stripe write to degraded array (Jes Sorensen) [1150149 1173510 1194720]
Rebuild_FUZZ: 98.01%
commit-author NeilBrown <neilb@suse.de>
commit 10d82c5f0d167ef75a2d8d7d4eed9ee43d3369c9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/10d82c5f.failed

When performing a reconstruct write, we need to read all blocks
that are not being over-written .. except the parity (P and Q) blocks.

The code currently reads these (as they are not being over-written!)
unnecessarily.

	Signed-off-by: NeilBrown <neilb@suse.de>
Fixes: ea664c8245f3 ("md/raid5: need_this_block: tidy/fix last condition.")
(cherry picked from commit 10d82c5f0d167ef75a2d8d7d4eed9ee43d3369c9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/raid5.c
diff --cc drivers/md/raid5.c
index 03380c4aa832,85dc0e67fb88..000000000000
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@@ -3156,6 -3201,97 +3156,100 @@@ static int want_replace(struct stripe_h
   * Returns 1 when no more member devices need to be checked, otherwise returns
   * 0 to tell the loop in handle_stripe_fill to continue
   */
++<<<<<<< HEAD
++=======
+ 
+ static int need_this_block(struct stripe_head *sh, struct stripe_head_state *s,
+ 			   int disk_idx, int disks)
+ {
+ 	struct r5dev *dev = &sh->dev[disk_idx];
+ 	struct r5dev *fdev[2] = { &sh->dev[s->failed_num[0]],
+ 				  &sh->dev[s->failed_num[1]] };
+ 	int i;
+ 
+ 
+ 	if (test_bit(R5_LOCKED, &dev->flags) ||
+ 	    test_bit(R5_UPTODATE, &dev->flags))
+ 		/* No point reading this as we already have it or have
+ 		 * decided to get it.
+ 		 */
+ 		return 0;
+ 
+ 	if (dev->toread ||
+ 	    (dev->towrite && !test_bit(R5_OVERWRITE, &dev->flags)))
+ 		/* We need this block to directly satisfy a request */
+ 		return 1;
+ 
+ 	if (s->syncing || s->expanding ||
+ 	    (s->replacing && want_replace(sh, disk_idx)))
+ 		/* When syncing, or expanding we read everything.
+ 		 * When replacing, we need the replaced block.
+ 		 */
+ 		return 1;
+ 
+ 	if ((s->failed >= 1 && fdev[0]->toread) ||
+ 	    (s->failed >= 2 && fdev[1]->toread))
+ 		/* If we want to read from a failed device, then
+ 		 * we need to actually read every other device.
+ 		 */
+ 		return 1;
+ 
+ 	/* Sometimes neither read-modify-write nor reconstruct-write
+ 	 * cycles can work.  In those cases we read every block we
+ 	 * can.  Then the parity-update is certain to have enough to
+ 	 * work with.
+ 	 * This can only be a problem when we need to write something,
+ 	 * and some device has failed.  If either of those tests
+ 	 * fail we need look no further.
+ 	 */
+ 	if (!s->failed || !s->to_write)
+ 		return 0;
+ 
+ 	if (test_bit(R5_Insync, &dev->flags) &&
+ 	    !test_bit(STRIPE_PREREAD_ACTIVE, &sh->state))
+ 		/* Pre-reads at not permitted until after short delay
+ 		 * to gather multiple requests.  However if this
+ 		 * device is no Insync, the block could only be be computed
+ 		 * and there is no need to delay that.
+ 		 */
+ 		return 0;
+ 
+ 	for (i = 0; i < s->failed; i++) {
+ 		if (fdev[i]->towrite &&
+ 		    !test_bit(R5_UPTODATE, &fdev[i]->flags) &&
+ 		    !test_bit(R5_OVERWRITE, &fdev[i]->flags))
+ 			/* If we have a partial write to a failed
+ 			 * device, then we will need to reconstruct
+ 			 * the content of that device, so all other
+ 			 * devices must be read.
+ 			 */
+ 			return 1;
+ 	}
+ 
+ 	/* If we are forced to do a reconstruct-write, either because
+ 	 * the current RAID6 implementation only supports that, or
+ 	 * or because parity cannot be trusted and we are currently
+ 	 * recovering it, there is extra need to be careful.
+ 	 * If one of the devices that we would need to read, because
+ 	 * it is not being overwritten (and maybe not written at all)
+ 	 * is missing/faulty, then we need to read everything we can.
+ 	 */
+ 	if (sh->raid_conf->level != 6 &&
+ 	    sh->sector < sh->raid_conf->mddev->recovery_cp)
+ 		/* reconstruct-write isn't being forced */
+ 		return 0;
+ 	for (i = 0; i < s->failed; i++) {
+ 		if (s->failed_num[i] != sh->pd_idx &&
+ 		    s->failed_num[i] != sh->qd_idx &&
+ 		    !test_bit(R5_UPTODATE, &fdev[i]->flags) &&
+ 		    !test_bit(R5_OVERWRITE, &fdev[i]->flags))
+ 			return 1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 10d82c5f0d16 (md/raid5: avoid reading parity blocks for full-stripe write to degraded array)
  static int fetch_block(struct stripe_head *sh, struct stripe_head_state *s,
  		       int disk_idx, int disks)
  {
* Unmerged path drivers/md/raid5.c
