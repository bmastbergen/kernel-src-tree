flowcache: restore a single flow_cache kmem_cache

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Eric Dumazet <edumazet@google.com>
commit d32d9bb85c65f52bed99a0149b47e9f6578c44c5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/d32d9bb8.failed

It is not legal to create multiple kmem_cache having the same name.

flowcache can use a single kmem_cache, no need for a per netns
one.

Fixes: ca925cf1534e ("flowcache: Make flow cache name space aware")
	Reported-by: Jakub Kicinski <moorray3@wp.pl>
	Tested-by: Jakub Kicinski <moorray3@wp.pl>
	Tested-by: Fan Du <fan.du@windriver.com>
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d32d9bb85c65f52bed99a0149b47e9f6578c44c5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netns/xfrm.h
#	net/core/flow.c
diff --cc include/net/netns/xfrm.h
index 5299e69a32af,3492434baf88..000000000000
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@@ -59,6 -58,18 +59,21 @@@ struct netns_xfrm 
  #if IS_ENABLED(CONFIG_IPV6)
  	struct dst_ops		xfrm6_dst_ops;
  #endif
++<<<<<<< HEAD
++=======
+ 	spinlock_t xfrm_state_lock;
+ 	rwlock_t xfrm_policy_lock;
+ 	struct mutex xfrm_cfg_mutex;
+ 
+ 	/* flow cache part */
+ 	struct flow_cache	flow_cache_global;
+ 	atomic_t		flow_cache_genid;
+ 	struct list_head	flow_cache_gc_list;
+ 	spinlock_t		flow_cache_gc_lock;
+ 	struct work_struct	flow_cache_gc_work;
+ 	struct work_struct	flow_cache_flush_work;
+ 	struct mutex		flow_flush_sem;
++>>>>>>> d32d9bb85c65 (flowcache: restore a single flow_cache kmem_cache)
  };
  
  #endif
diff --cc net/core/flow.c
index dfa602ceb8cd,102f8ea2eb6e..000000000000
--- a/net/core/flow.c
+++ b/net/core/flow.c
@@@ -52,23 -45,8 +52,28 @@@ struct flow_flush_info 
  	struct completion		completion;
  };
  
++<<<<<<< HEAD
 +struct flow_cache {
 +	u32				hash_shift;
 +	struct flow_cache_percpu __percpu *percpu;
 +	struct notifier_block		hotcpu_notifier;
 +	int				low_watermark;
 +	int				high_watermark;
 +	struct timer_list		rnd_timer;
 +};
 +
 +atomic_t flow_cache_genid = ATOMIC_INIT(0);
 +EXPORT_SYMBOL(flow_cache_genid);
 +static struct flow_cache flow_cache_global;
  static struct kmem_cache *flow_cachep __read_mostly;
  
 +static DEFINE_SPINLOCK(flow_cache_gc_lock);
 +static LIST_HEAD(flow_cache_gc_list);
 +
++=======
++static struct kmem_cache *flow_cachep __read_mostly;
++
++>>>>>>> d32d9bb85c65 (flowcache: restore a single flow_cache kmem_cache)
  #define flow_cache_hash_size(cache)	(1 << (cache)->hash_shift)
  #define FLOW_HASH_RND_PERIOD		(10 * 60 * HZ)
  
@@@ -444,9 -432,20 +449,23 @@@ static int flow_cache_cpu(struct notifi
  	return NOTIFY_OK;
  }
  
 -int flow_cache_init(struct net *net)
 +static int __init flow_cache_init(struct flow_cache *fc)
  {
  	int i;
++<<<<<<< HEAD
++=======
+ 	struct flow_cache *fc = &net->xfrm.flow_cache_global;
+ 
+ 	if (!flow_cachep)
+ 		flow_cachep = kmem_cache_create("flow_cache",
+ 						sizeof(struct flow_cache_entry),
+ 						0, SLAB_PANIC, NULL);
+ 	spin_lock_init(&net->xfrm.flow_cache_gc_lock);
+ 	INIT_LIST_HEAD(&net->xfrm.flow_cache_gc_list);
+ 	INIT_WORK(&net->xfrm.flow_cache_gc_work, flow_cache_gc_task);
+ 	INIT_WORK(&net->xfrm.flow_cache_flush_work, flow_cache_flush_task);
+ 	mutex_init(&net->xfrm.flow_flush_sem);
++>>>>>>> d32d9bb85c65 (flowcache: restore a single flow_cache kmem_cache)
  
  	fc->hash_shift = 10;
  	fc->low_watermark = 2 * flow_cache_hash_size(fc);
* Unmerged path include/net/netns/xfrm.h
* Unmerged path net/core/flow.c
