nfsd: Remove the cache_hash list

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit 11acf6ef3b58abd1c5eb94eaa38ed3b9dbc387f7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/11acf6ef.failed

Now that the lru list is per-bucket, we don't need a second list for
searches.

	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit 11acf6ef3b58abd1c5eb94eaa38ed3b9dbc387f7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfscache.c
diff --cc fs/nfsd/nfscache.c
index dfe380798466,8abec475f80f..000000000000
--- a/fs/nfsd/nfscache.c
+++ b/fs/nfsd/nfscache.c
@@@ -28,7 -28,7 +28,11 @@@
  #define TARGET_BUCKET_SIZE	64
  
  struct nfsd_drc_bucket {
++<<<<<<< HEAD
 +	struct hlist_head cache_hash;
++=======
+ 	struct list_head lru_head;
++>>>>>>> 11acf6ef3b58 (nfsd: Remove the cache_hash list)
  };
  
  static struct nfsd_drc_bucket	*drc_hashtbl;
@@@ -221,26 -229,13 +222,31 @@@ lru_put_end(struct svc_cacherep *rp
  	schedule_delayed_work(&cache_cleaner, RC_EXPIRE);
  }
  
++<<<<<<< HEAD
 +/*
 + * Move a cache entry from one hash list to another
 + */
 +static void
 +hash_refile(struct nfsd_drc_bucket *b, struct svc_cacherep *rp)
 +{
 +	hlist_del_init(&rp->c_hash);
 +	hlist_add_head(&rp->c_hash, &b->cache_hash);
 +}
 +
 +/*
 + * Walk the LRU list and prune off entries that are older than RC_EXPIRE.
 + * Also prune the oldest ones when the total exceeds the max number of entries.
 + */
 +static void
 +prune_cache_entries(void)
++=======
+ static long
+ prune_bucket(struct nfsd_drc_bucket *b)
++>>>>>>> 11acf6ef3b58 (nfsd: Remove the cache_hash list)
  {
  	struct svc_cacherep *rp, *tmp;
 -	long freed = 0;
  
 -	list_for_each_entry_safe(rp, tmp, &b->lru_head, c_lru) {
 +	list_for_each_entry_safe(rp, tmp, &lru_head, c_lru) {
  		/*
  		 * Don't free entries attached to calls that are still
  		 * in-progress, but do keep scanning the list.
@@@ -443,8 -465,7 +449,12 @@@ nfsd_cache_lookup(struct svc_rqst *rqst
  	rp->c_len = rqstp->rq_arg.len;
  	rp->c_csum = csum;
  
++<<<<<<< HEAD
 +	hash_refile(b, rp);
 +	lru_put_end(rp);
++=======
+ 	lru_put_end(b, rp);
++>>>>>>> 11acf6ef3b58 (nfsd: Remove the cache_hash list)
  
  	/* release any buffer */
  	if (rp->c_type == RC_REPLBUFF) {
diff --git a/fs/nfsd/cache.h b/fs/nfsd/cache.h
index b582f9ab6b2a..dd96a3830004 100644
--- a/fs/nfsd/cache.h
+++ b/fs/nfsd/cache.h
@@ -18,7 +18,6 @@
  * is much larger than a sockaddr_in6.
  */
 struct svc_cacherep {
-	struct hlist_node	c_hash;
 	struct list_head	c_lru;
 
 	unsigned char		c_state,	/* unused, inprog, done */
* Unmerged path fs/nfsd/nfscache.c
