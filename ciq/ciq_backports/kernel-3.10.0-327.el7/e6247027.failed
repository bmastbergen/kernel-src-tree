net: introduce dev_consume_skb_any()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] introduce dev_consume_skb_any() (Ivan Vecera) [1200759]
Rebuild_FUZZ: 92.54%
commit-author Eric Dumazet <edumazet@google.com>
commit e6247027e5173c00efb2084d688d06ff835bc3b0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/e6247027.failed

Some network drivers use dev_kfree_skb_any() and dev_kfree_skb_irq()
helpers to free skbs, both for dropped packets and TX completed ones.

We need to separate the two causes to get better diagnostics
given by dropwatch or "perf record -e skb:kfree_skb"

This patch provides two new helpers, dev_consume_skb_any() and
dev_consume_skb_irq() to be used for consumed skbs.

__dev_kfree_skb_irq() is slightly optimized to remove one
atomic_dec_and_test() in fast path, and use this_cpu_{r|w} accessors.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e6247027e5173c00efb2084d688d06ff835bc3b0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
diff --cc include/linux/netdevice.h
index d77c2cff9dff,9d55e5188b96..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -2448,30 -2366,62 +2448,77 @@@ static inline int netif_copy_real_num_q
  }
  
  #define DEFAULT_MAX_NUM_RSS_QUEUES	(8)
 -int netif_get_num_default_rss_queues(void);
 +extern int netif_get_num_default_rss_queues(void);
  
++<<<<<<< HEAD
 +/* Use this variant when it is known for sure that it
 + * is executing from hardware interrupt context or with hardware interrupts
 + * disabled.
 + */
 +extern void dev_kfree_skb_irq(struct sk_buff *skb);
++=======
+ enum skb_free_reason {
+ 	SKB_REASON_CONSUMED,
+ 	SKB_REASON_DROPPED,
+ };
++>>>>>>> e6247027e517 (net: introduce dev_consume_skb_any())
+ 
+ void __dev_kfree_skb_irq(struct sk_buff *skb, enum skb_free_reason reason);
+ void __dev_kfree_skb_any(struct sk_buff *skb, enum skb_free_reason reason);
  
- /* Use this variant in places where it could be invoked
-  * from either hardware interrupt or other context, with hardware interrupts
-  * either disabled or enabled.
+ /*
+  * It is not allowed to call kfree_skb() or consume_skb() from hardware
+  * interrupt context or with hardware interrupts being disabled.
+  * (in_irq() || irqs_disabled())
+  *
+  * We provide four helpers that can be used in following contexts :
+  *
+  * dev_kfree_skb_irq(skb) when caller drops a packet from irq context,
+  *  replacing kfree_skb(skb)
+  *
+  * dev_consume_skb_irq(skb) when caller consumes a packet from irq context.
+  *  Typically used in place of consume_skb(skb) in TX completion path
+  *
+  * dev_kfree_skb_any(skb) when caller doesn't know its current irq context,
+  *  replacing kfree_skb(skb)
+  *
+  * dev_consume_skb_any(skb) when caller doesn't know its current irq context,
+  *  and consumed a packet. Used in place of consume_skb(skb)
   */
++<<<<<<< HEAD
 +extern void dev_kfree_skb_any(struct sk_buff *skb);
++=======
+ static inline void dev_kfree_skb_irq(struct sk_buff *skb)
+ {
+ 	__dev_kfree_skb_irq(skb, SKB_REASON_DROPPED);
+ }
+ 
+ static inline void dev_consume_skb_irq(struct sk_buff *skb)
+ {
+ 	__dev_kfree_skb_irq(skb, SKB_REASON_CONSUMED);
+ }
+ 
+ static inline void dev_kfree_skb_any(struct sk_buff *skb)
+ {
+ 	__dev_kfree_skb_any(skb, SKB_REASON_DROPPED);
+ }
+ 
+ static inline void dev_consume_skb_any(struct sk_buff *skb)
+ {
+ 	__dev_kfree_skb_any(skb, SKB_REASON_CONSUMED);
+ }
++>>>>>>> e6247027e517 (net: introduce dev_consume_skb_any())
  
 -int netif_rx(struct sk_buff *skb);
 -int netif_rx_ni(struct sk_buff *skb);
 -int netif_receive_skb(struct sk_buff *skb);
 -gro_result_t napi_gro_receive(struct napi_struct *napi, struct sk_buff *skb);
 -void napi_gro_flush(struct napi_struct *napi, bool flush_old);
 -struct sk_buff *napi_get_frags(struct napi_struct *napi);
 -gro_result_t napi_gro_frags(struct napi_struct *napi);
 +extern int		netif_rx(struct sk_buff *skb);
 +extern int		netif_rx_ni(struct sk_buff *skb);
 +extern int		netif_receive_skb(struct sk_buff *skb);
 +extern gro_result_t	napi_gro_receive(struct napi_struct *napi,
 +					 struct sk_buff *skb);
 +extern void		napi_gro_flush(struct napi_struct *napi, bool flush_old);
 +extern struct sk_buff *	napi_get_frags(struct napi_struct *napi);
 +extern gro_result_t	napi_gro_frags(struct napi_struct *napi);
 +struct packet_offload *gro_find_receive_by_type(__be16 type);
 +struct packet_offload *gro_find_complete_by_type(__be16 type);
  
  static inline void napi_free_frags(struct napi_struct *napi)
  {
* Unmerged path include/linux/netdevice.h
diff --git a/net/core/dev.c b/net/core/dev.c
index 9a2bea4eeeee..e2089060ccfb 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -2112,30 +2112,42 @@ void __netif_schedule(struct Qdisc *q)
 }
 EXPORT_SYMBOL(__netif_schedule);
 
-void dev_kfree_skb_irq(struct sk_buff *skb)
+struct dev_kfree_skb_cb {
+	enum skb_free_reason reason;
+};
+
+static struct dev_kfree_skb_cb *get_kfree_skb_cb(const struct sk_buff *skb)
+{
+	return (struct dev_kfree_skb_cb *)skb->cb;
+}
+
+void __dev_kfree_skb_irq(struct sk_buff *skb, enum skb_free_reason reason)
 {
-	if (atomic_dec_and_test(&skb->users)) {
-		struct softnet_data *sd;
-		unsigned long flags;
+	unsigned long flags;
 
-		local_irq_save(flags);
-		sd = &__get_cpu_var(softnet_data);
-		skb->next = sd->completion_queue;
-		sd->completion_queue = skb;
-		raise_softirq_irqoff(NET_TX_SOFTIRQ);
-		local_irq_restore(flags);
+	if (likely(atomic_read(&skb->users) == 1)) {
+		smp_rmb();
+		atomic_set(&skb->users, 0);
+	} else if (likely(!atomic_dec_and_test(&skb->users))) {
+		return;
 	}
+	get_kfree_skb_cb(skb)->reason = reason;
+	local_irq_save(flags);
+	skb->next = __this_cpu_read(softnet_data.completion_queue);
+	__this_cpu_write(softnet_data.completion_queue, skb);
+	raise_softirq_irqoff(NET_TX_SOFTIRQ);
+	local_irq_restore(flags);
 }
-EXPORT_SYMBOL(dev_kfree_skb_irq);
+EXPORT_SYMBOL(__dev_kfree_skb_irq);
 
-void dev_kfree_skb_any(struct sk_buff *skb)
+void __dev_kfree_skb_any(struct sk_buff *skb, enum skb_free_reason reason)
 {
 	if (in_irq() || irqs_disabled())
-		dev_kfree_skb_irq(skb);
+		__dev_kfree_skb_irq(skb, reason);
 	else
 		dev_kfree_skb(skb);
 }
-EXPORT_SYMBOL(dev_kfree_skb_any);
+EXPORT_SYMBOL(__dev_kfree_skb_any);
 
 
 /**
@@ -3212,7 +3224,10 @@ static void net_tx_action(struct softirq_action *h)
 			clist = clist->next;
 
 			WARN_ON(atomic_read(&skb->users));
-			trace_kfree_skb(skb, net_tx_action);
+			if (likely(get_kfree_skb_cb(skb)->reason == SKB_REASON_CONSUMED))
+				trace_consume_skb(skb);
+			else
+				trace_kfree_skb(skb, net_tx_action);
 			__kfree_skb(skb);
 		}
 	}
