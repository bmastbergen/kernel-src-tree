powerpc/iommu/powernv: Get rid of set_iommu_table_base_and_group

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [powerpc] iommu/powernv: Get rid of set_iommu_table_base_and_group (David Gibson) [1213665]
Rebuild_FUZZ: 93.33%
commit-author Alexey Kardashevskiy <aik@ozlabs.ru>
commit 4617082ec049d92a797e8be0b4ba2ba6b59d90d1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/4617082e.failed

The set_iommu_table_base_and_group() name suggests that the function
sets table base and add a device to an IOMMU group.

The actual purpose for table base setting is to put some reference
into a device so later iommu_add_device() can get the IOMMU group
reference and the device to the group.

At the moment a group cannot be explicitly passed to iommu_add_device()
as we want it to work from the bus notifier, we can fix it later and
remove confusing calls of set_iommu_table_base().

This replaces set_iommu_table_base_and_group() with a couple of
set_iommu_table_base() + iommu_add_device() which makes reading the code
easier.

This adds few comments why set_iommu_table_base() and iommu_add_device()
are called where they are called.

For IODA1/2, this essentially removes iommu_add_device() call from
the pnv_pci_ioda_dma_dev_setup() as it will always fail at this particular
place:
- for physical PE, the device is already attached by iommu_add_device()
in pnv_pci_ioda_setup_dma_pe();
- for virtual PE, the sysfs entries are not ready to create all symlinks
so actual adding is happening in tce_iommu_bus_notifier.

	Signed-off-by: Alexey Kardashevskiy <aik@ozlabs.ru>
	Reviewed-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
	Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 4617082ec049d92a797e8be0b4ba2ba6b59d90d1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/iommu.h
#	arch/powerpc/platforms/powernv/pci-ioda.c
diff --cc arch/powerpc/include/asm/iommu.h
index 5b51ca28425e,8353c865db6f..000000000000
--- a/arch/powerpc/include/asm/iommu.h
+++ b/arch/powerpc/include/asm/iommu.h
@@@ -136,20 -140,16 +136,33 @@@ static inline int __init tce_iommu_bus_
  }
  #endif /* !CONFIG_IOMMU_API */
  
++<<<<<<< HEAD
 +static inline void set_iommu_table_base_and_group(struct device *dev,
 +						  void *base)
 +{
 +	set_iommu_table_base(dev, base);
 +	iommu_add_device(dev);
 +}
 +
 +extern int iommu_map_sg(struct device *dev, struct iommu_table *tbl,
 +			struct scatterlist *sglist, int nelems,
 +			unsigned long mask, enum dma_data_direction direction,
 +			struct dma_attrs *attrs);
 +extern void iommu_unmap_sg(struct iommu_table *tbl, struct scatterlist *sglist,
 +			   int nelems, enum dma_data_direction direction,
 +			   struct dma_attrs *attrs);
++=======
+ extern int ppc_iommu_map_sg(struct device *dev, struct iommu_table *tbl,
+ 			    struct scatterlist *sglist, int nelems,
+ 			    unsigned long mask,
+ 			    enum dma_data_direction direction,
+ 			    struct dma_attrs *attrs);
+ extern void ppc_iommu_unmap_sg(struct iommu_table *tbl,
+ 			       struct scatterlist *sglist,
+ 			       int nelems,
+ 			       enum dma_data_direction direction,
+ 			       struct dma_attrs *attrs);
++>>>>>>> 4617082ec049 (powerpc/iommu/powernv: Get rid of set_iommu_table_base_and_group)
  
  extern void *iommu_alloc_coherent(struct device *dev, struct iommu_table *tbl,
  				  size_t size, dma_addr_t *dma_handle,
diff --cc arch/powerpc/platforms/powernv/pci-ioda.c
index 109e90d84e34,fd594b28fce1..000000000000
--- a/arch/powerpc/platforms/powernv/pci-ioda.c
+++ b/arch/powerpc/platforms/powernv/pci-ioda.c
@@@ -537,12 -1598,19 +537,22 @@@ static void pnv_pci_ioda_dma_dev_setup(
  
  	pe = &phb->ioda.pe_array[pdn->pe_number];
  	WARN_ON(get_dma_ops(&pdev->dev) != &dma_iommu_ops);
++<<<<<<< HEAD
 +	set_iommu_table_base_and_group(&pdev->dev, &pe->tce32_table);
++=======
+ 	set_iommu_table_base(&pdev->dev, pe->tce32_table);
+ 	/*
+ 	 * Note: iommu_add_device() will fail here as
+ 	 * for physical PE: the device is already added by now;
+ 	 * for virtual PE: sysfs entries are not ready yet and
+ 	 * tce_iommu_bus_notifier will add the device to a group later.
+ 	 */
++>>>>>>> 4617082ec049 (powerpc/iommu/powernv: Get rid of set_iommu_table_base_and_group)
  }
  
 -static int pnv_pci_ioda_dma_set_mask(struct pci_dev *pdev, u64 dma_mask)
 +static int pnv_pci_ioda_dma_set_mask(struct pnv_phb *phb,
 +				     struct pci_dev *pdev, u64 dma_mask)
  {
 -	struct pci_controller *hose = pci_bus_to_host(pdev->bus);
 -	struct pnv_phb *phb = hose->private_data;
  	struct pci_dn *pdn = pci_get_pdn(pdev);
  	struct pnv_ioda_pe *pe;
  	uint64_t top;
@@@ -576,15 -1666,11 +586,20 @@@ static void pnv_ioda_setup_bus_dma(stru
  	struct pci_dev *dev;
  
  	list_for_each_entry(dev, &bus->devices, bus_list) {
++<<<<<<< HEAD
 +		if (add_to_iommu_group)
 +			set_iommu_table_base_and_group(&dev->dev,
 +						       &pe->tce32_table);
 +		else
 +			set_iommu_table_base(&dev->dev, &pe->tce32_table);
++=======
+ 		set_iommu_table_base(&dev->dev, pe->tce32_table);
+ 		iommu_add_device(&dev->dev);
++>>>>>>> 4617082ec049 (powerpc/iommu/powernv: Get rid of set_iommu_table_base_and_group)
  
  		if (dev->subordinate)
 -			pnv_ioda_setup_bus_dma(pe, dev->subordinate);
 +			pnv_ioda_setup_bus_dma(pe, dev->subordinate,
 +					       add_to_iommu_group);
  	}
  }
  
@@@ -742,12 -1839,25 +757,33 @@@ static void pnv_pci_ioda_setup_dma_pe(s
  				 TCE_PCI_SWINV_PAIR);
  	}
  	iommu_init_table(tbl, phb->hose->node);
 +	iommu_register_group(tbl, phb->hose->global_number, pe->pe_number);
  
++<<<<<<< HEAD
 +	if (pe->pdev)
 +		set_iommu_table_base_and_group(&pe->pdev->dev, tbl);
 +	else
 +		pnv_ioda_setup_bus_dma(pe, pe->pbus, true);
++=======
+ 	if (pe->flags & PNV_IODA_PE_DEV) {
+ 		iommu_register_group(tbl, phb->hose->global_number,
+ 				     pe->pe_number);
+ 		/*
+ 		 * Setting table base here only for carrying iommu_group
+ 		 * further down to let iommu_add_device() do the job.
+ 		 * pnv_pci_ioda_dma_dev_setup will override it later anyway.
+ 		 */
+ 		set_iommu_table_base(&pe->pdev->dev, tbl);
+ 		iommu_add_device(&pe->pdev->dev);
+ 	} else if (pe->flags & (PNV_IODA_PE_BUS | PNV_IODA_PE_BUS_ALL)) {
+ 		iommu_register_group(tbl, phb->hose->global_number,
+ 				     pe->pe_number);
+ 		pnv_ioda_setup_bus_dma(pe, pe->pbus);
+ 	} else if (pe->flags & PNV_IODA_PE_VF) {
+ 		iommu_register_group(tbl, phb->hose->global_number,
+ 				     pe->pe_number);
+ 	}
++>>>>>>> 4617082ec049 (powerpc/iommu/powernv: Get rid of set_iommu_table_base_and_group)
  
  	return;
   fail:
@@@ -873,15 -1973,30 +909,36 @@@ static void pnv_pci_ioda2_setup_dma_pe(
  		tbl->it_type |= (TCE_PCI_SWINV_CREATE | TCE_PCI_SWINV_FREE);
  	}
  	iommu_init_table(tbl, phb->hose->node);
 +	iommu_register_group(tbl, phb->hose->global_number, pe->pe_number);
  
++<<<<<<< HEAD
 +	if (pe->pdev)
 +		set_iommu_table_base_and_group(&pe->pdev->dev, tbl);
 +	else
 +		pnv_ioda_setup_bus_dma(pe, pe->pbus, true);
++=======
+ 	if (pe->flags & PNV_IODA_PE_DEV) {
+ 		iommu_register_group(tbl, phb->hose->global_number,
+ 				     pe->pe_number);
+ 		/*
+ 		 * Setting table base here only for carrying iommu_group
+ 		 * further down to let iommu_add_device() do the job.
+ 		 * pnv_pci_ioda_dma_dev_setup will override it later anyway.
+ 		 */
+ 		set_iommu_table_base(&pe->pdev->dev, tbl);
+ 		iommu_add_device(&pe->pdev->dev);
+ 	} else if (pe->flags & (PNV_IODA_PE_BUS | PNV_IODA_PE_BUS_ALL)) {
+ 		iommu_register_group(tbl, phb->hose->global_number,
+ 				     pe->pe_number);
+ 		pnv_ioda_setup_bus_dma(pe, pe->pbus);
+ 	} else if (pe->flags & PNV_IODA_PE_VF) {
+ 		iommu_register_group(tbl, phb->hose->global_number,
+ 				     pe->pe_number);
+ 	}
++>>>>>>> 4617082ec049 (powerpc/iommu/powernv: Get rid of set_iommu_table_base_and_group)
  
  	/* Also create a bypass window */
 -	if (!pnv_iommu_bypass_disabled)
 -		pnv_pci_ioda2_setup_bypass_pe(phb, pe);
 -
 +	pnv_pci_ioda2_setup_bypass_pe(phb, pe);
  	return;
  fail:
  	if (pe->tce32_seg >= 0)
* Unmerged path arch/powerpc/include/asm/iommu.h
* Unmerged path arch/powerpc/platforms/powernv/pci-ioda.c
diff --git a/arch/powerpc/platforms/powernv/pci-p5ioc2.c b/arch/powerpc/platforms/powernv/pci-p5ioc2.c
index 94ce3481490b..bd5ee959df27 100644
--- a/arch/powerpc/platforms/powernv/pci-p5ioc2.c
+++ b/arch/powerpc/platforms/powernv/pci-p5ioc2.c
@@ -92,7 +92,8 @@ static void pnv_pci_p5ioc2_dma_dev_setup(struct pnv_phb *phb,
 				pci_domain_nr(phb->hose->bus), phb->opal_id);
 	}
 
-	set_iommu_table_base_and_group(&pdev->dev, &phb->p5ioc2.iommu_table);
+	set_iommu_table_base(&pdev->dev, &phb->p5ioc2.iommu_table);
+	iommu_add_device(&pdev->dev);
 }
 
 static void __init pnv_pci_init_p5ioc2_phb(struct device_node *np, u64 hub_id,
diff --git a/arch/powerpc/platforms/pseries/iommu.c b/arch/powerpc/platforms/pseries/iommu.c
index 1edda98be625..b7446f98b671 100644
--- a/arch/powerpc/platforms/pseries/iommu.c
+++ b/arch/powerpc/platforms/pseries/iommu.c
@@ -689,8 +689,8 @@ static void pci_dma_dev_setup_pSeries(struct pci_dev *dev)
 		iommu_table_setparms(phb, dn, tbl);
 		PCI_DN(dn)->iommu_table = iommu_init_table(tbl, phb->node);
 		iommu_register_group(tbl, pci_domain_nr(phb->bus), 0);
-		set_iommu_table_base_and_group(&dev->dev,
-					       PCI_DN(dn)->iommu_table);
+		set_iommu_table_base(&dev->dev, tbl);
+		iommu_add_device(&dev->dev);
 		return;
 	}
 
@@ -701,10 +701,10 @@ static void pci_dma_dev_setup_pSeries(struct pci_dev *dev)
 	while (dn && PCI_DN(dn) && PCI_DN(dn)->iommu_table == NULL)
 		dn = dn->parent;
 
-	if (dn && PCI_DN(dn))
-		set_iommu_table_base_and_group(&dev->dev,
-					       PCI_DN(dn)->iommu_table);
-	else
+	if (dn && PCI_DN(dn)) {
+		set_iommu_table_base(&dev->dev, PCI_DN(dn)->iommu_table);
+		iommu_add_device(&dev->dev);
+	} else
 		printk(KERN_WARNING "iommu: Device %s has no iommu table\n",
 		       pci_name(dev));
 }
@@ -1110,7 +1110,8 @@ static void pci_dma_dev_setup_pSeriesLP(struct pci_dev *dev)
 		pr_debug("  found DMA window, table: %p\n", pci->iommu_table);
 	}
 
-	set_iommu_table_base_and_group(&dev->dev, pci->iommu_table);
+	set_iommu_table_base(&dev->dev, pci->iommu_table);
+	iommu_add_device(&dev->dev);
 }
 
 static int dma_set_mask_pSeriesLP(struct device *dev, u64 dma_mask)
