netfilter: Pass nf_hook_state through ipt_do_table().

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] netfilter: Pass nf_hook_state through ipt_do_table() (Jiri Benc) [1230935]
Rebuild_FUZZ: 99.05%
commit-author David S. Miller <davem@davemloft.net>
commit 1c491ba2592f621f21a693d43fab06302527fc0f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/1c491ba2.failed

	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1c491ba2592f621f21a693d43fab06302527fc0f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/netfilter/iptable_filter.c
#	net/ipv4/netfilter/iptable_mangle.c
#	net/ipv4/netfilter/iptable_nat.c
#	net/ipv4/netfilter/iptable_raw.c
#	net/ipv4/netfilter/iptable_security.c
diff --cc net/ipv4/netfilter/iptable_filter.c
index 7433962b7193,a0f3beca52d2..000000000000
--- a/net/ipv4/netfilter/iptable_filter.c
+++ b/net/ipv4/netfilter/iptable_filter.c
@@@ -45,9 -44,8 +45,14 @@@ iptable_filter_hook(const struct nf_hoo
  		/* root is playing with raw sockets. */
  		return NF_ACCEPT;
  
++<<<<<<< HEAD
 +	net = dev_net((in != NULL) ? in : out);
 +	return ipt_do_table(skb, ops->hooknum, in, out,
 +			    net->ipv4.iptable_filter);
++=======
+ 	net = dev_net(state->in ? state->in : state->out);
+ 	return ipt_do_table(skb, ops->hooknum, state, net->ipv4.iptable_filter);
++>>>>>>> 1c491ba2592f (netfilter: Pass nf_hook_state through ipt_do_table().)
  }
  
  static struct nf_hook_ops *filter_ops __read_mostly;
diff --cc net/ipv4/netfilter/iptable_mangle.c
index 75cf06a58ec0,62cbb8c5f4a8..000000000000
--- a/net/ipv4/netfilter/iptable_mangle.c
+++ b/net/ipv4/netfilter/iptable_mangle.c
@@@ -81,18 -82,16 +82,28 @@@ ipt_mangle_out(struct sk_buff *skb, con
  static unsigned int
  iptable_mangle_hook(const struct nf_hook_ops *ops,
  		     struct sk_buff *skb,
 -		     const struct nf_hook_state *state)
 +		     const struct net_device *in,
 +		     const struct net_device *out,
 +		     int (*okfn)(struct sk_buff *))
  {
  	if (ops->hooknum == NF_INET_LOCAL_OUT)
++<<<<<<< HEAD
 +		return ipt_mangle_out(skb, out);
 +	if (ops->hooknum == NF_INET_POST_ROUTING)
 +		return ipt_do_table(skb, ops->hooknum, in, out,
 +				    dev_net(out)->ipv4.iptable_mangle);
 +	/* PREROUTING/INPUT/FORWARD: */
 +	return ipt_do_table(skb, ops->hooknum, in, out,
 +			    dev_net(in)->ipv4.iptable_mangle);
++=======
+ 		return ipt_mangle_out(skb, state);
+ 	if (ops->hooknum == NF_INET_POST_ROUTING)
+ 		return ipt_do_table(skb, ops->hooknum, state,
+ 				    dev_net(state->out)->ipv4.iptable_mangle);
+ 	/* PREROUTING/INPUT/FORWARD: */
+ 	return ipt_do_table(skb, ops->hooknum, state,
+ 			    dev_net(state->in)->ipv4.iptable_mangle);
++>>>>>>> 1c491ba2592f (netfilter: Pass nf_hook_state through ipt_do_table().)
  }
  
  static struct nf_hook_ops *mangle_ops __read_mostly;
diff --cc net/ipv4/netfilter/iptable_nat.c
index 2b6df3a92f3e,0d4d9cdf98a4..000000000000
--- a/net/ipv4/netfilter/iptable_nat.c
+++ b/net/ipv4/netfilter/iptable_nat.c
@@@ -36,7 -35,7 +36,11 @@@ static unsigned int iptable_nat_do_chai
  {
  	struct net *net = nf_ct_net(ct);
  
++<<<<<<< HEAD
 +	return ipt_do_table(skb, ops->hooknum, in, out, net->ipv4.nat_table);
++=======
+ 	return ipt_do_table(skb, ops->hooknum, state, net->ipv4.nat_table);
++>>>>>>> 1c491ba2592f (netfilter: Pass nf_hook_state through ipt_do_table().)
  }
  
  static unsigned int iptable_nat_ipv4_fn(const struct nf_hook_ops *ops,
diff --cc net/ipv4/netfilter/iptable_raw.c
index 44b8fc1e6c50,0356e6da4bb7..000000000000
--- a/net/ipv4/netfilter/iptable_raw.c
+++ b/net/ipv4/netfilter/iptable_raw.c
@@@ -32,8 -31,8 +32,13 @@@ iptable_raw_hook(const struct nf_hook_o
  		/* root is playing with raw sockets. */
  		return NF_ACCEPT;
  
++<<<<<<< HEAD
 +	net = dev_net((in != NULL) ? in : out);
 +	return ipt_do_table(skb, ops->hooknum, in, out, net->ipv4.iptable_raw);
++=======
+ 	net = dev_net(state->in ? state->in : state->out);
+ 	return ipt_do_table(skb, ops->hooknum, state, net->ipv4.iptable_raw);
++>>>>>>> 1c491ba2592f (netfilter: Pass nf_hook_state through ipt_do_table().)
  }
  
  static struct nf_hook_ops *rawtable_ops __read_mostly;
diff --cc net/ipv4/netfilter/iptable_security.c
index dc45b3821807,4bce3980ccd9..000000000000
--- a/net/ipv4/netfilter/iptable_security.c
+++ b/net/ipv4/netfilter/iptable_security.c
@@@ -50,8 -48,8 +50,13 @@@ iptable_security_hook(const struct nf_h
  		/* Somebody is playing with raw sockets. */
  		return NF_ACCEPT;
  
++<<<<<<< HEAD
 +	net = dev_net((in != NULL) ? in : out);
 +	return ipt_do_table(skb, ops->hooknum, in, out,
++=======
+ 	net = dev_net(state->in ? state->in : state->out);
+ 	return ipt_do_table(skb, ops->hooknum, state,
++>>>>>>> 1c491ba2592f (netfilter: Pass nf_hook_state through ipt_do_table().)
  			    net->ipv4.iptable_security);
  }
  
diff --git a/include/linux/netfilter_ipv4/ip_tables.h b/include/linux/netfilter_ipv4/ip_tables.h
index 901e84db847d..4073510da485 100644
--- a/include/linux/netfilter_ipv4/ip_tables.h
+++ b/include/linux/netfilter_ipv4/ip_tables.h
@@ -65,8 +65,7 @@ struct ipt_error {
 extern void *ipt_alloc_initial_table(const struct xt_table *);
 extern unsigned int ipt_do_table(struct sk_buff *skb,
 				 unsigned int hook,
-				 const struct net_device *in,
-				 const struct net_device *out,
+				 const struct nf_hook_state *state,
 				 struct xt_table *table);
 
 #ifdef CONFIG_COMPAT
diff --git a/net/ipv4/netfilter/ip_tables.c b/net/ipv4/netfilter/ip_tables.c
index a313f787fae4..947426f3fa84 100644
--- a/net/ipv4/netfilter/ip_tables.c
+++ b/net/ipv4/netfilter/ip_tables.c
@@ -286,8 +286,7 @@ struct ipt_entry *ipt_next_entry(const struct ipt_entry *entry)
 unsigned int
 ipt_do_table(struct sk_buff *skb,
 	     unsigned int hook,
-	     const struct net_device *in,
-	     const struct net_device *out,
+	     const struct nf_hook_state *state,
 	     struct xt_table *table)
 {
 	static const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));
@@ -304,8 +303,8 @@ ipt_do_table(struct sk_buff *skb,
 
 	/* Initialization */
 	ip = ip_hdr(skb);
-	indev = in ? in->name : nulldevname;
-	outdev = out ? out->name : nulldevname;
+	indev = state->in ? state->in->name : nulldevname;
+	outdev = state->out ? state->out->name : nulldevname;
 	/* We handle fragments by dealing with the first fragment as
 	 * if it was a normal packet.  All other fragments are treated
 	 * normally, except that they will NEVER match rules that ask
@@ -315,8 +314,8 @@ ipt_do_table(struct sk_buff *skb,
 	acpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;
 	acpar.thoff   = ip_hdrlen(skb);
 	acpar.hotdrop = false;
-	acpar.in      = in;
-	acpar.out     = out;
+	acpar.in      = state->in;
+	acpar.out     = state->out;
 	acpar.family  = NFPROTO_IPV4;
 	acpar.hooknum = hook;
 
@@ -370,7 +369,7 @@ ipt_do_table(struct sk_buff *skb,
 #if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)
 		/* The packet is traced: log it */
 		if (unlikely(skb->nf_trace))
-			trace_packet(skb, hook, in, out,
+			trace_packet(skb, hook, state->in, state->out,
 				     table->name, private, e);
 #endif
 		/* Standard target? */
* Unmerged path net/ipv4/netfilter/iptable_filter.c
* Unmerged path net/ipv4/netfilter/iptable_mangle.c
* Unmerged path net/ipv4/netfilter/iptable_nat.c
* Unmerged path net/ipv4/netfilter/iptable_raw.c
* Unmerged path net/ipv4/netfilter/iptable_security.c
