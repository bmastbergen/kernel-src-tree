cxgb4/cxgb4vf: function and argument name cleanup

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Hariprasad Shenai <hariprasad@chelsio.com>
commit b261272276777f0af94fa3da07a64ece9e4626e3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/b2612722.failed

This patch changes variable name 'fn' to 'pf' of structure adapter.
A 'fn' usually stands for PCI function which could be a PF or a VF.
However, the use of this particular variable is explicitly limited to PF
only. So, be specific about it in the variable name.

Also corrects arguments passed for fn t4_ofld_eq_free, t4_ctrl_eq_free,
t4_eth_eq_free, t4_iq_free, t4_alloc_vi, t4_fw_hello, t4_wr_mbox and
t4_cfg_pfvf function.

Also renames cxgb4_t4_bar2_sge_qregs to t4_bar2_sge_qregs and renames
the latter function name in cxgb4vf driver to t4vf_bar2_sge_qregs to
avoid conflicts. Also fixes alignment for these function.

	Signed-off-by: Hariprasad Shenai <hariprasad@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b261272276777f0af94fa3da07a64ece9e4626e3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_ethtool.c
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
#	drivers/net/ethernet/chelsio/cxgb4/sge.c
#	drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
#	drivers/net/ethernet/chelsio/cxgb4vf/sge.c
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
index 2a3e5627b439,4f69b5237129..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@@ -484,6 -296,46 +484,49 @@@ static void link_report(struct net_devi
  	}
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_CHELSIO_T4_DCB
+ /* Set up/tear down Data Center Bridging Priority mapping for a net device. */
+ static void dcb_tx_queue_prio_enable(struct net_device *dev, int enable)
+ {
+ 	struct port_info *pi = netdev_priv(dev);
+ 	struct adapter *adap = pi->adapter;
+ 	struct sge_eth_txq *txq = &adap->sge.ethtxq[pi->first_qset];
+ 	int i;
+ 
+ 	/* We use a simple mapping of Port TX Queue Index to DCB
+ 	 * Priority when we're enabling DCB.
+ 	 */
+ 	for (i = 0; i < pi->nqsets; i++, txq++) {
+ 		u32 name, value;
+ 		int err;
+ 
+ 		name = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DMAQ) |
+ 			FW_PARAMS_PARAM_X_V(
+ 				FW_PARAMS_PARAM_DMAQ_EQ_DCBPRIO_ETH) |
+ 			FW_PARAMS_PARAM_YZ_V(txq->q.cntxt_id));
+ 		value = enable ? i : 0xffffffff;
+ 
+ 		/* Since we can be called while atomic (from "interrupt
+ 		 * level") we need to issue the Set Parameters Commannd
+ 		 * without sleeping (timeout < 0).
+ 		 */
+ 		err = t4_set_params_timeout(adap, adap->mbox, adap->pf, 0, 1,
+ 					    &name, &value,
+ 					    -FW_CMD_MAX_TIMEOUT);
+ 
+ 		if (err)
+ 			dev_err(adap->pdev_dev,
+ 				"Can't %s DCB Priority on port %d, TX Queue %d: err=%d\n",
+ 				enable ? "set" : "unset", pi->port_id, i, -err);
+ 		else
+ 			txq->dcb_prio = value;
+ 	}
+ }
+ #endif /* CONFIG_CHELSIO_T4_DCB */
+ 
++>>>>>>> b26127227677 (cxgb4/cxgb4vf: function and argument name cleanup)
  void t4_os_link_changed(struct adapter *adapter, int port_id, int link_stat)
  {
  	struct net_device *dev = adapter->port[port_id];
@@@ -950,10 -877,23 +993,14 @@@ static int write_rss(const struct port_
  
  	/* map the queue indices to queue ids */
  	for (i = 0; i < pi->rss_size; i++, queues++)
 -		rss[i] = rxq[*queues].rspq.abs_id;
 +		rss[i] = q[*queues].rspq.abs_id;
  
++<<<<<<< HEAD
 +	err = t4_config_rss_range(pi->adapter, pi->adapter->fn, pi->viid, 0,
++=======
+ 	err = t4_config_rss_range(adapter, adapter->pf, pi->viid, 0,
++>>>>>>> b26127227677 (cxgb4/cxgb4vf: function and argument name cleanup)
  				  pi->rss_size, rss, pi->rss_size);
 -	/* If Tunnel All Lookup isn't specified in the global RSS
 -	 * Configuration, then we need to specify a default Ingress
 -	 * Queue for any ingress packets which aren't hashed.  We'll
 -	 * use our first ingress queue ...
 -	 */
 -	if (!err)
 -		err = t4_config_vi_rss(adapter, adapter->mbox, pi->viid,
 -				       FW_RSS_VI_CONFIG_CMD_IP6FOURTUPEN_F |
 -				       FW_RSS_VI_CONFIG_CMD_IP6TWOTUPEN_F |
 -				       FW_RSS_VI_CONFIG_CMD_IP4FOURTUPEN_F |
 -				       FW_RSS_VI_CONFIG_CMD_IP4TWOTUPEN_F |
 -				       FW_RSS_VI_CONFIG_CMD_UDPEN_F,
 -				       rss[0]);
  	kfree(rss);
  	return err;
  }
@@@ -2586,11 -1412,12 +2633,20 @@@ static int set_rspq_intr_params(struct 
  		new_idx = closest_thres(&adap->sge, cnt);
  		if (q->desc && q->pktcnt_idx != new_idx) {
  			/* the queue has already been created, update it */
++<<<<<<< HEAD
 +			v = FW_PARAMS_MNEM(FW_PARAMS_MNEM_DMAQ) |
 +			    FW_PARAMS_PARAM_X(FW_PARAMS_PARAM_DMAQ_IQ_INTCNTTHRESH) |
 +			    FW_PARAMS_PARAM_YZ(q->cntxt_id);
 +			err = t4_set_params(adap, adap->fn, adap->fn, 0, 1, &v,
 +					    &new_idx);
++=======
+ 			v = FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DMAQ) |
+ 			    FW_PARAMS_PARAM_X_V(
+ 					FW_PARAMS_PARAM_DMAQ_IQ_INTCNTTHRESH) |
+ 			    FW_PARAMS_PARAM_YZ_V(q->cntxt_id);
+ 			err = t4_set_params(adap, adap->mbox, adap->pf, 0, 1,
+ 					    &v, &new_idx);
++>>>>>>> b26127227677 (cxgb4/cxgb4vf: function and argument name cleanup)
  			if (err)
  				return err;
  		}
@@@ -3833,6 -2169,22 +3889,25 @@@ u64 cxgb4_read_sge_timestamp(struct net
  }
  EXPORT_SYMBOL(cxgb4_read_sge_timestamp);
  
++<<<<<<< HEAD
++=======
+ int cxgb4_bar2_sge_qregs(struct net_device *dev,
+ 			 unsigned int qid,
+ 			 enum cxgb4_bar2_qtype qtype,
+ 			 u64 *pbar2_qoffset,
+ 			 unsigned int *pbar2_qid)
+ {
+ 	return t4_bar2_sge_qregs(netdev2adap(dev),
+ 				 qid,
+ 				 (qtype == CXGB4_BAR2_QTYPE_EGRESS
+ 				  ? T4_BAR2_QTYPE_EGRESS
+ 				  : T4_BAR2_QTYPE_INGRESS),
+ 				 pbar2_qoffset,
+ 				 pbar2_qid);
+ }
+ EXPORT_SYMBOL(cxgb4_bar2_sge_qregs);
+ 
++>>>>>>> b26127227677 (cxgb4/cxgb4vf: function and argument name cleanup)
  static struct pci_driver cxgb4_driver;
  
  static void check_neigh_update(struct neighbour *neigh)
@@@ -4015,31 -2373,18 +4090,42 @@@ static void process_db_drop(struct work
  		u32 dropped_db = t4_read_reg(adap, 0x010ac);
  		u16 qid = (dropped_db >> 15) & 0x1ffff;
  		u16 pidx_inc = dropped_db & 0x1fff;
 -		u64 bar2_qoffset;
 -		unsigned int bar2_qid;
 -		int ret;
 +		unsigned int s_qpp;
 +		unsigned short udb_density;
 +		unsigned long qpshift;
 +		int page;
 +		u32 udb;
  
++<<<<<<< HEAD
 +		dev_warn(adap->pdev_dev,
 +			 "Dropped DB 0x%x qid %d bar2 %d coalesce %d pidx %d\n",
 +			 dropped_db, qid,
 +			 (dropped_db >> 14) & 1,
 +			 (dropped_db >> 13) & 1,
 +			 pidx_inc);
 +
 +		drain_db_fifo(adap, 1);
 +
 +		s_qpp = QUEUESPERPAGEPF1 * adap->fn;
 +		udb_density = 1 << QUEUESPERPAGEPF0_GET(t4_read_reg(adap,
 +				SGE_EGRESS_QUEUES_PER_PAGE_PF) >> s_qpp);
 +		qpshift = PAGE_SHIFT - ilog2(udb_density);
 +		udb = qid << qpshift;
 +		udb &= PAGE_MASK;
 +		page = udb / PAGE_SIZE;
 +		udb += (qid - (page * udb_density)) * 128;
 +
 +		writel(PIDX(pidx_inc),  adap->bar2 + udb + 8);
++=======
+ 		ret = t4_bar2_sge_qregs(adap, qid, T4_BAR2_QTYPE_EGRESS,
+ 					&bar2_qoffset, &bar2_qid);
+ 		if (ret)
+ 			dev_err(adap->pdev_dev, "doorbell drop recovery: "
+ 				"qid=%d, pidx_inc=%d\n", qid, pidx_inc);
+ 		else
+ 			writel(PIDX_T5_V(pidx_inc) | QID_V(bar2_qid),
+ 			       adap->bar2 + bar2_qoffset + SGE_UDB_KDOORBELL);
++>>>>>>> b26127227677 (cxgb4/cxgb4vf: function and argument name cleanup)
  
  		/* Re-enable BAR2 WC */
  		t4_set_reg_field(adap, 0x10b0, 1<<15, 1<<15);
@@@ -4914,10 -3097,10 +5000,10 @@@ static int adap_init1(struct adapter *a
  
  	/* get device capabilities */
  	memset(c, 0, sizeof(*c));
 -	c->op_to_write = htonl(FW_CMD_OP_V(FW_CAPS_CONFIG_CMD) |
 -			       FW_CMD_REQUEST_F | FW_CMD_READ_F);
 +	c->op_to_write = htonl(FW_CMD_OP(FW_CAPS_CONFIG_CMD) |
 +			       FW_CMD_REQUEST | FW_CMD_READ);
  	c->cfvalid_to_len16 = htonl(FW_LEN16(*c));
- 	ret = t4_wr_mbox(adap, adap->fn, c, sizeof(*c), c);
+ 	ret = t4_wr_mbox(adap, adap->mbox, c, sizeof(*c), c);
  	if (ret < 0)
  		return ret;
  
@@@ -4931,21 -3114,22 +5017,33 @@@
  		dev_err(adap->pdev_dev, "virtualization ACLs not supported");
  		return ret;
  	}
++<<<<<<< HEAD
 +	c->op_to_write = htonl(FW_CMD_OP(FW_CAPS_CONFIG_CMD) |
 +			       FW_CMD_REQUEST | FW_CMD_WRITE);
 +	ret = t4_wr_mbox(adap, adap->fn, c, sizeof(*c), NULL);
++=======
+ 	c->op_to_write = htonl(FW_CMD_OP_V(FW_CAPS_CONFIG_CMD) |
+ 			       FW_CMD_REQUEST_F | FW_CMD_WRITE_F);
+ 	ret = t4_wr_mbox(adap, adap->mbox, c, sizeof(*c), NULL);
++>>>>>>> b26127227677 (cxgb4/cxgb4vf: function and argument name cleanup)
  	if (ret < 0)
  		return ret;
  
- 	ret = t4_config_glbl_rss(adap, adap->fn,
+ 	ret = t4_config_glbl_rss(adap, adap->pf,
  				 FW_RSS_GLB_CONFIG_CMD_MODE_BASICVIRTUAL,
 -				 FW_RSS_GLB_CONFIG_CMD_TNLMAPEN_F |
 -				 FW_RSS_GLB_CONFIG_CMD_TNLALLLKP_F);
 +				 FW_RSS_GLB_CONFIG_CMD_TNLMAPEN |
 +				 FW_RSS_GLB_CONFIG_CMD_TNLALLLKP);
  	if (ret < 0)
  		return ret;
  
++<<<<<<< HEAD
 +	ret = t4_cfg_pfvf(adap, adap->fn, adap->fn, 0, MAX_EGRQ, 64, MAX_INGQ,
 +			  0, 0, 4, 0xf, 0xf, 16, FW_CMD_CAP_PF, FW_CMD_CAP_PF);
++=======
+ 	ret = t4_cfg_pfvf(adap, adap->mbox, adap->pf, 0, adap->sge.egr_sz, 64,
+ 			  MAX_INGQ, 0, 0, 4, 0xf, 0xf, 16, FW_CMD_CAP_PF,
+ 			  FW_CMD_CAP_PF);
++>>>>>>> b26127227677 (cxgb4/cxgb4vf: function and argument name cleanup)
  	if (ret < 0)
  		return ret;
  
@@@ -5101,10 -3431,10 +5199,10 @@@ static int adap_init0_config(struct ada
  		if (cf->size >= FLASH_CFG_MAX_SIZE)
  			ret = -ENOMEM;
  		else {
 -			params[0] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |
 -			     FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_CF));
 +			params[0] = (FW_PARAMS_MNEM(FW_PARAMS_MNEM_DEV) |
 +			     FW_PARAMS_PARAM_X(FW_PARAMS_PARAM_DEV_CF));
  			ret = t4_query_params(adapter, adapter->mbox,
- 					      adapter->fn, 0, 1, params, val);
+ 					      adapter->pf, 0, 1, params, val);
  			if (ret == 0) {
  				/*
  				 * For t4_memory_rw() below addresses and
@@@ -5630,9 -3721,9 +5728,15 @@@ static int adap_init0(struct adapter *a
  	 * and portvec ...
  	 */
  	v =
++<<<<<<< HEAD
 +	    FW_PARAMS_MNEM(FW_PARAMS_MNEM_DEV) |
 +	    FW_PARAMS_PARAM_X(FW_PARAMS_PARAM_DEV_PORTVEC);
 +	ret = t4_query_params(adap, adap->mbox, adap->fn, 0, 1, &v, &port_vec);
++=======
+ 	    FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |
+ 	    FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_PORTVEC);
+ 	ret = t4_query_params(adap, adap->mbox, adap->pf, 0, 1, &v, &port_vec);
++>>>>>>> b26127227677 (cxgb4/cxgb4vf: function and argument name cleanup)
  	if (ret < 0)
  		goto bye;
  
@@@ -5654,57 -3741,36 +5758,64 @@@
  		dev_info(adap->pdev_dev, "Coming up as MASTER: "\
  			 "Initializing adapter\n");
  
 -		/* Find out whether we're dealing with a version of the
 -		 * firmware which has configuration file support.
 +		/*
 +		 * If the firmware doesn't support Configuration
 +		 * Files warn user and exit,
  		 */
++<<<<<<< HEAD
 +		if (ret < 0)
 +			dev_warn(adap->pdev_dev, "Firmware doesn't support "
 +				 "configuration file.\n");
 +		if (force_old_init)
 +			ret = adap_init0_no_config(adap, reset);
 +		else {
 +			/*
 +			 * Find out whether we're dealing with a version of
 +			 * the firmware which has configuration file support.
 +			 */
 +			params[0] = (FW_PARAMS_MNEM(FW_PARAMS_MNEM_DEV) |
 +				     FW_PARAMS_PARAM_X(FW_PARAMS_PARAM_DEV_CF));
 +			ret = t4_query_params(adap, adap->mbox, adap->fn, 0, 1,
 +					      params, val);
++=======
+ 		params[0] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |
+ 			     FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_CF));
+ 		ret = t4_query_params(adap, adap->mbox, adap->pf, 0, 1,
+ 				      params, val);
++>>>>>>> b26127227677 (cxgb4/cxgb4vf: function and argument name cleanup)
 +
 +			/*
 +			 * If the firmware doesn't support Configuration
 +			 * Files, use the old Driver-based, hard-wired
 +			 * initialization.  Otherwise, try using the
 +			 * Configuration File support and fall back to the
 +			 * Driver-based initialization if there's no
 +			 * Configuration File found.
 +			 */
 +			if (ret < 0)
 +				ret = adap_init0_no_config(adap, reset);
 +			else {
 +				/*
 +				 * The firmware provides us with a memory
 +				 * buffer where we can load a Configuration
 +				 * File from the host if we want to override
 +				 * the Configuration File in flash.
 +				 */
  
 -		/* If the firmware doesn't support Configuration Files,
 -		 * return an error.
 -		 */
 -		if (ret < 0) {
 -			dev_err(adap->pdev_dev, "firmware doesn't support "
 -				"Firmware Configuration Files\n");
 -			goto bye;
 -		}
 -
 -		/* The firmware provides us with a memory buffer where we can
 -		 * load a Configuration File from the host if we want to
 -		 * override the Configuration File in flash.
 -		 */
 -		ret = adap_init0_config(adap, reset);
 -		if (ret == -ENOENT) {
 -			dev_err(adap->pdev_dev, "no Configuration File "
 -				"present on adapter.\n");
 -			goto bye;
 +				ret = adap_init0_config(adap, reset);
 +				if (ret == -ENOENT) {
 +					dev_info(adap->pdev_dev,
 +					    "No Configuration File present "
 +					    "on adapter. Using hard-wired "
 +					    "configuration parameters.\n");
 +					ret = adap_init0_no_config(adap, reset);
 +				}
 +			}
  		}
  		if (ret < 0) {
 -			dev_err(adap->pdev_dev, "could not initialize "
 -				"adapter, error %d\n", -ret);
 +			dev_err(adap->pdev_dev,
 +				"could not initialize adapter, error %d\n",
 +				-ret);
  			goto bye;
  		}
  	}
@@@ -5754,6 -3815,68 +5865,71 @@@
  	adap->tids.nftids = val[4] - val[3] + 1;
  	adap->sge.ingr_start = val[5];
  
++<<<<<<< HEAD
++=======
+ 	/* qids (ingress/egress) returned from firmware can be anywhere
+ 	 * in the range from EQ(IQFLINT)_START to EQ(IQFLINT)_END.
+ 	 * Hence driver needs to allocate memory for this range to
+ 	 * store the queue info. Get the highest IQFLINT/EQ index returned
+ 	 * in FW_EQ_*_CMD.alloc command.
+ 	 */
+ 	params[0] = FW_PARAM_PFVF(EQ_END);
+ 	params[1] = FW_PARAM_PFVF(IQFLINT_END);
+ 	ret = t4_query_params(adap, adap->mbox, adap->pf, 0, 2, params, val);
+ 	if (ret < 0)
+ 		goto bye;
+ 	adap->sge.egr_sz = val[0] - adap->sge.egr_start + 1;
+ 	adap->sge.ingr_sz = val[1] - adap->sge.ingr_start + 1;
+ 
+ 	adap->sge.egr_map = kcalloc(adap->sge.egr_sz,
+ 				    sizeof(*adap->sge.egr_map), GFP_KERNEL);
+ 	if (!adap->sge.egr_map) {
+ 		ret = -ENOMEM;
+ 		goto bye;
+ 	}
+ 
+ 	adap->sge.ingr_map = kcalloc(adap->sge.ingr_sz,
+ 				     sizeof(*adap->sge.ingr_map), GFP_KERNEL);
+ 	if (!adap->sge.ingr_map) {
+ 		ret = -ENOMEM;
+ 		goto bye;
+ 	}
+ 
+ 	/* Allocate the memory for the vaious egress queue bitmaps
+ 	 * ie starving_fl, txq_maperr and blocked_fl.
+ 	 */
+ 	adap->sge.starving_fl =	kcalloc(BITS_TO_LONGS(adap->sge.egr_sz),
+ 					sizeof(long), GFP_KERNEL);
+ 	if (!adap->sge.starving_fl) {
+ 		ret = -ENOMEM;
+ 		goto bye;
+ 	}
+ 
+ 	adap->sge.txq_maperr = kcalloc(BITS_TO_LONGS(adap->sge.egr_sz),
+ 				       sizeof(long), GFP_KERNEL);
+ 	if (!adap->sge.txq_maperr) {
+ 		ret = -ENOMEM;
+ 		goto bye;
+ 	}
+ 
+ #ifdef CONFIG_DEBUG_FS
+ 	adap->sge.blocked_fl = kcalloc(BITS_TO_LONGS(adap->sge.egr_sz),
+ 				       sizeof(long), GFP_KERNEL);
+ 	if (!adap->sge.blocked_fl) {
+ 		ret = -ENOMEM;
+ 		goto bye;
+ 	}
+ #endif
+ 
+ 	params[0] = FW_PARAM_PFVF(CLIP_START);
+ 	params[1] = FW_PARAM_PFVF(CLIP_END);
+ 	ret = t4_query_params(adap, adap->mbox, adap->pf, 0, 2, params, val);
+ 	if (ret < 0)
+ 		goto bye;
+ 	adap->clipt_start = val[0];
+ 	adap->clipt_end = val[1];
+ 
++>>>>>>> b26127227677 (cxgb4/cxgb4vf: function and argument name cleanup)
  	/* query params related to active filter region */
  	params[0] = FW_PARAM_PFVF(ACTIVE_FILTER_START);
  	params[1] = FW_PARAM_PFVF(ACTIVE_FILTER_END);
@@@ -6453,9 -4647,11 +6629,17 @@@ static int init_one(struct pci_dev *pde
  
  
  	if (!is_t4(adapter->params.chip)) {
++<<<<<<< HEAD
 +		s_qpp = QUEUESPERPAGEPF1 * adapter->fn;
 +		qpp = 1 << QUEUESPERPAGEPF0_GET(t4_read_reg(adapter,
 +		      SGE_EGRESS_QUEUES_PER_PAGE_PF) >> s_qpp);
++=======
+ 		s_qpp = (QUEUESPERPAGEPF0_S +
+ 			(QUEUESPERPAGEPF1_S - QUEUESPERPAGEPF0_S) *
+ 			adapter->pf);
+ 		qpp = 1 << QUEUESPERPAGEPF0_G(t4_read_reg(adapter,
+ 		      SGE_EGRESS_QUEUES_PER_PAGE_PF_A) >> s_qpp);
++>>>>>>> b26127227677 (cxgb4/cxgb4vf: function and argument name cleanup)
  		num_seg = PAGE_SIZE / SEGMENT_SIZE;
  
  		/* Each segment size is 128B. Write coalescing is enabled only
diff --cc drivers/net/ethernet/chelsio/cxgb4/sge.c
index 9797215ec30f,f9c889e14634..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/sge.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/sge.c
@@@ -1177,23 -1244,28 +1177,29 @@@ out_free:	dev_kfree_skb_any(skb)
  		q->tx_cso += ssi->gso_segs;
  	} else {
  		len += sizeof(*cpl);
 -		wr->op_immdlen = htonl(FW_WR_OP_V(FW_ETH_TX_PKT_WR) |
 -				       FW_WR_IMMDLEN_V(len));
 +		wr->op_immdlen = htonl(FW_WR_OP(FW_ETH_TX_PKT_WR) |
 +				       FW_WR_IMMDLEN(len));
  		cpl = (void *)(wr + 1);
  		if (skb->ip_summed == CHECKSUM_PARTIAL) {
 -			cntrl = hwcsum(skb) | TXPKT_IPCSUM_DIS_F;
 +			cntrl = hwcsum(skb) | TXPKT_IPCSUM_DIS;
  			q->tx_cso++;
 -		}
 +		} else
 +			cntrl = TXPKT_L4CSUM_DIS | TXPKT_IPCSUM_DIS;
  	}
  
 -	if (skb_vlan_tag_present(skb)) {
 +	if (vlan_tx_tag_present(skb)) {
  		q->vlan_ins++;
 -		cntrl |= TXPKT_VLAN_VLD_F | TXPKT_VLAN_V(skb_vlan_tag_get(skb));
 -#ifdef CONFIG_CHELSIO_T4_FCOE
 -		if (skb->protocol == htons(ETH_P_FCOE))
 -			cntrl |= TXPKT_VLAN_V(
 -				 ((skb->priority & 0x7) << VLAN_PRIO_SHIFT));
 -#endif /* CONFIG_CHELSIO_T4_FCOE */
 +		cntrl |= TXPKT_VLAN_VLD | TXPKT_VLAN(vlan_tx_tag_get(skb));
  	}
  
++<<<<<<< HEAD
 +	cpl->ctrl0 = htonl(TXPKT_OPCODE(CPL_TX_PKT_XT) |
 +			   TXPKT_INTF(pi->tx_chan) | TXPKT_PF(adap->fn));
++=======
+ 	cpl->ctrl0 = htonl(TXPKT_OPCODE_V(CPL_TX_PKT_XT) |
+ 			   TXPKT_INTF_V(pi->tx_chan) |
+ 			   TXPKT_PF_V(adap->pf));
++>>>>>>> b26127227677 (cxgb4/cxgb4vf: function and argument name cleanup)
  	cpl->pack = htons(0);
  	cpl->len = htons(skb->len);
  	cpl->ctrl1 = cpu_to_be64(cntrl);
@@@ -2275,53 -2370,40 +2281,60 @@@ static void sge_tx_timer_cb(unsigned lo
  }
  
  /**
 - *	bar2_address - return the BAR2 address for an SGE Queue's Registers
 - *	@adapter: the adapter
 - *	@qid: the SGE Queue ID
 - *	@qtype: the SGE Queue Type (Egress or Ingress)
 - *	@pbar2_qid: BAR2 Queue ID or 0 for Queue ID inferred SGE Queues
 + *      udb_address - return the BAR2 User Doorbell address for a Queue
 + *      @adap: the adapter
 + *      @cntxt_id: the Queue Context ID
 + *      @qpp: Queues Per Page (for all PFs)
   *
 - *	Returns the BAR2 address for the SGE Queue Registers associated with
 - *	@qid.  If BAR2 SGE Registers aren't available, returns NULL.  Also
 - *	returns the BAR2 Queue ID to be used with writes to the BAR2 SGE
 - *	Queue Registers.  If the BAR2 Queue ID is 0, then "Inferred Queue ID"
 - *	Registers are supported (e.g. the Write Combining Doorbell Buffer).
 - */
 -static void __iomem *bar2_address(struct adapter *adapter,
 -				  unsigned int qid,
 -				  enum t4_bar2_qtype qtype,
 -				  unsigned int *pbar2_qid)
 -{
 -	u64 bar2_qoffset;
 -	int ret;
 -
 + *      Returns the BAR2 address of the user Doorbell associated with the
 + *      indicated Queue Context ID.  Note that this is only applicable
 + *      for T5 and later.
 + */
 +static u64 udb_address(struct adapter *adap, unsigned int cntxt_id,
 +		       unsigned int qpp)
 +{
 +	u64 udb;
 +	unsigned int s_qpp;
 +	unsigned short udb_density;
 +	unsigned long qpshift;
 +	int page;
 +
++<<<<<<< HEAD
 +	BUG_ON(is_t4(adap->params.chip));
++=======
+ 	ret = t4_bar2_sge_qregs(adapter, qid, qtype,
+ 				&bar2_qoffset, pbar2_qid);
+ 	if (ret)
+ 		return NULL;
++>>>>>>> b26127227677 (cxgb4/cxgb4vf: function and argument name cleanup)
 +
 +	s_qpp = (QUEUESPERPAGEPF0 +
 +		(QUEUESPERPAGEPF1 - QUEUESPERPAGEPF0) * adap->fn);
 +	udb_density = 1 << ((qpp >> s_qpp) & QUEUESPERPAGEPF0_MASK);
 +	qpshift = PAGE_SHIFT - ilog2(udb_density);
 +	udb = cntxt_id << qpshift;
 +	udb &= PAGE_MASK;
 +	page = udb / PAGE_SIZE;
 +	udb += (cntxt_id - (page * udb_density)) * SGE_UDB_SIZE;
  
 -	return adapter->bar2 + bar2_qoffset;
 +	return udb;
 +}
 +
 +static u64 udb_address_eq(struct adapter *adap, unsigned int cntxt_id)
 +{
 +	return udb_address(adap, cntxt_id,
 +			   t4_read_reg(adap, SGE_EGRESS_QUEUES_PER_PAGE_PF));
 +}
 +
 +static u64 udb_address_iq(struct adapter *adap, unsigned int cntxt_id)
 +{
 +	return udb_address(adap, cntxt_id,
 +			   t4_read_reg(adap, SGE_INGRESS_QUEUES_PER_PAGE_PF));
  }
  
 -/* @intr_idx: MSI/MSI-X vector if >=0, -(absolute qid + 1) if < 0
 - * @cong: < 0 -> no congestion feedback, >= 0 -> congestion channel map
 - */
  int t4_sge_alloc_rxq(struct adapter *adap, struct sge_rspq *iq, bool fwevtq,
  		     struct net_device *dev, int intr_idx,
 -		     struct sge_fl *fl, rspq_handler_t hnd, int cong)
 +		     struct sge_fl *fl, rspq_handler_t hnd)
  {
  	int ret, flsz = 0;
  	struct fw_iq_cmd c;
@@@ -2337,22 -2419,25 +2350,29 @@@
  		return -ENOMEM;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_vfn = htonl(FW_CMD_OP(FW_IQ_CMD) | FW_CMD_REQUEST |
 +			    FW_CMD_WRITE | FW_CMD_EXEC |
 +			    FW_IQ_CMD_PFN(adap->fn) | FW_IQ_CMD_VFN(0));
 +	c.alloc_to_len16 = htonl(FW_IQ_CMD_ALLOC | FW_IQ_CMD_IQSTART(1) |
++=======
+ 	c.op_to_vfn = htonl(FW_CMD_OP_V(FW_IQ_CMD) | FW_CMD_REQUEST_F |
+ 			    FW_CMD_WRITE_F | FW_CMD_EXEC_F |
+ 			    FW_IQ_CMD_PFN_V(adap->pf) | FW_IQ_CMD_VFN_V(0));
+ 	c.alloc_to_len16 = htonl(FW_IQ_CMD_ALLOC_F | FW_IQ_CMD_IQSTART_F |
++>>>>>>> b26127227677 (cxgb4/cxgb4vf: function and argument name cleanup)
  				 FW_LEN16(c));
 -	c.type_to_iqandstindex = htonl(FW_IQ_CMD_TYPE_V(FW_IQ_TYPE_FL_INT_CAP) |
 -		FW_IQ_CMD_IQASYNCH_V(fwevtq) | FW_IQ_CMD_VIID_V(pi->viid) |
 -		FW_IQ_CMD_IQANDST_V(intr_idx < 0) |
 -		FW_IQ_CMD_IQANUD_V(UPDATEDELIVERY_INTERRUPT_X) |
 -		FW_IQ_CMD_IQANDSTINDEX_V(intr_idx >= 0 ? intr_idx :
 +	c.type_to_iqandstindex = htonl(FW_IQ_CMD_TYPE(FW_IQ_TYPE_FL_INT_CAP) |
 +		FW_IQ_CMD_IQASYNCH(fwevtq) | FW_IQ_CMD_VIID(pi->viid) |
 +		FW_IQ_CMD_IQANDST(intr_idx < 0) | FW_IQ_CMD_IQANUD(1) |
 +		FW_IQ_CMD_IQANDSTINDEX(intr_idx >= 0 ? intr_idx :
  							-intr_idx - 1));
 -	c.iqdroprss_to_iqesize = htons(FW_IQ_CMD_IQPCIECH_V(pi->tx_chan) |
 -		FW_IQ_CMD_IQGTSMODE_F |
 -		FW_IQ_CMD_IQINTCNTTHRESH_V(iq->pktcnt_idx) |
 -		FW_IQ_CMD_IQESIZE_V(ilog2(iq->iqe_len) - 4));
 +	c.iqdroprss_to_iqesize = htons(FW_IQ_CMD_IQPCIECH(pi->tx_chan) |
 +		FW_IQ_CMD_IQGTSMODE |
 +		FW_IQ_CMD_IQINTCNTTHRESH(iq->pktcnt_idx) |
 +		FW_IQ_CMD_IQESIZE(ilog2(iq->iqe_len) - 4));
  	c.iqsize = htons(iq->size);
  	c.iqaddr = cpu_to_be64(iq->phys_addr);
 -	if (cong >= 0)
 -		c.iqns_to_fl0congen = htonl(FW_IQ_CMD_IQFLINTCONGEN_F);
  
  	if (fl) {
  		/* Allocate the ring for the hardware free list (with space
@@@ -2411,13 -2505,50 +2431,51 @@@
  		fl->alloc_failed = fl->large_alloc_failed = fl->starving = 0;
  		adap->sge.egr_map[fl->cntxt_id - adap->sge.egr_start] = fl;
  
 -		/* Note, we must initialize the BAR2 Free List User Doorbell
 -		 * information before refilling the Free List!
 +		/* Note, we must initialize the Free List User Doorbell
 +		 * address before refilling the Free List!
  		 */
 -		fl->bar2_addr = bar2_address(adap,
 -					     fl->cntxt_id,
 -					     T4_BAR2_QTYPE_EGRESS,
 -					     &fl->bar2_qid);
 +		if (!is_t4(adap->params.chip))
 +			fl->udb = udb_address_eq(adap, fl->cntxt_id);
  		refill_fl(adap, fl, fl_cap(fl), GFP_KERNEL);
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	/* For T5 and later we attempt to set up the Congestion Manager values
+ 	 * of the new RX Ethernet Queue.  This should really be handled by
+ 	 * firmware because it's more complex than any host driver wants to
+ 	 * get involved with and it's different per chip and this is almost
+ 	 * certainly wrong.  Firmware would be wrong as well, but it would be
+ 	 * a lot easier to fix in one place ...  For now we do something very
+ 	 * simple (and hopefully less wrong).
+ 	 */
+ 	if (!is_t4(adap->params.chip) && cong >= 0) {
+ 		u32 param, val;
+ 		int i;
+ 
+ 		param = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DMAQ) |
+ 			 FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DMAQ_CONM_CTXT) |
+ 			 FW_PARAMS_PARAM_YZ_V(iq->cntxt_id));
+ 		if (cong == 0) {
+ 			val = CONMCTXT_CNGTPMODE_V(CONMCTXT_CNGTPMODE_QUEUE_X);
+ 		} else {
+ 			val =
+ 			    CONMCTXT_CNGTPMODE_V(CONMCTXT_CNGTPMODE_CHANNEL_X);
+ 			for (i = 0; i < 4; i++) {
+ 				if (cong & (1 << i))
+ 					val |=
+ 					     CONMCTXT_CNGCHMAP_V(1 << (i << 2));
+ 			}
+ 		}
+ 		ret = t4_set_params(adap, adap->mbox, adap->pf, 0, 1,
+ 				    &param, &val);
+ 		if (ret)
+ 			dev_warn(adap->pdev_dev, "Failed to set Congestion"
+ 				 " Manager Context for Ingress Queue %d: %d\n",
+ 				 iq->cntxt_id, -ret);
+ 	}
+ 
++>>>>>>> b26127227677 (cxgb4/cxgb4vf: function and argument name cleanup)
  	return 0;
  
  fl_nomem:
@@@ -2472,24 -2604,26 +2530,44 @@@ int t4_sge_alloc_eth_txq(struct adapte
  		return -ENOMEM;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_vfn = htonl(FW_CMD_OP(FW_EQ_ETH_CMD) | FW_CMD_REQUEST |
 +			    FW_CMD_WRITE | FW_CMD_EXEC |
 +			    FW_EQ_ETH_CMD_PFN(adap->fn) | FW_EQ_ETH_CMD_VFN(0));
 +	c.alloc_to_len16 = htonl(FW_EQ_ETH_CMD_ALLOC |
 +				 FW_EQ_ETH_CMD_EQSTART | FW_LEN16(c));
 +	c.viid_pkd = htonl(FW_EQ_ETH_CMD_AUTOEQUEQE |
 +			   FW_EQ_ETH_CMD_VIID(pi->viid));
 +	c.fetchszm_to_iqid = htonl(FW_EQ_ETH_CMD_HOSTFCMODE(2) |
 +				   FW_EQ_ETH_CMD_PCIECHN(pi->tx_chan) |
 +				   FW_EQ_ETH_CMD_FETCHRO(1) |
 +				   FW_EQ_ETH_CMD_IQID(iqid));
 +	c.dcaen_to_eqsize = htonl(FW_EQ_ETH_CMD_FBMIN(2) |
 +				  FW_EQ_ETH_CMD_FBMAX(3) |
 +				  FW_EQ_ETH_CMD_CIDXFTHRESH(5) |
 +				  FW_EQ_ETH_CMD_EQSIZE(nentries));
++=======
+ 	c.op_to_vfn = htonl(FW_CMD_OP_V(FW_EQ_ETH_CMD) | FW_CMD_REQUEST_F |
+ 			    FW_CMD_WRITE_F | FW_CMD_EXEC_F |
+ 			    FW_EQ_ETH_CMD_PFN_V(adap->pf) |
+ 			    FW_EQ_ETH_CMD_VFN_V(0));
+ 	c.alloc_to_len16 = htonl(FW_EQ_ETH_CMD_ALLOC_F |
+ 				 FW_EQ_ETH_CMD_EQSTART_F | FW_LEN16(c));
+ 	c.viid_pkd = htonl(FW_EQ_ETH_CMD_AUTOEQUEQE_F |
+ 			   FW_EQ_ETH_CMD_VIID_V(pi->viid));
+ 	c.fetchszm_to_iqid =
+ 		htonl(FW_EQ_ETH_CMD_HOSTFCMODE_V(HOSTFCMODE_STATUS_PAGE_X) |
+ 		      FW_EQ_ETH_CMD_PCIECHN_V(pi->tx_chan) |
+ 		      FW_EQ_ETH_CMD_FETCHRO_F | FW_EQ_ETH_CMD_IQID_V(iqid));
+ 	c.dcaen_to_eqsize =
+ 		htonl(FW_EQ_ETH_CMD_FBMIN_V(FETCHBURSTMIN_64B_X) |
+ 		      FW_EQ_ETH_CMD_FBMAX_V(FETCHBURSTMAX_512B_X) |
+ 		      FW_EQ_ETH_CMD_CIDXFTHRESH_V(CIDXFLUSHTHRESH_32_X) |
+ 		      FW_EQ_ETH_CMD_EQSIZE_V(nentries));
++>>>>>>> b26127227677 (cxgb4/cxgb4vf: function and argument name cleanup)
  	c.eqaddr = cpu_to_be64(txq->q.phys_addr);
  
- 	ret = t4_wr_mbox(adap, adap->fn, &c, sizeof(c), &c);
+ 	ret = t4_wr_mbox(adap, adap->mbox, &c, sizeof(c), &c);
  	if (ret) {
  		kfree(txq->q.sdesc);
  		txq->q.sdesc = NULL;
@@@ -2525,25 -2659,26 +2603,35 @@@ int t4_sge_alloc_ctrl_txq(struct adapte
  	if (!txq->q.desc)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	c.op_to_vfn = htonl(FW_CMD_OP(FW_EQ_CTRL_CMD) | FW_CMD_REQUEST |
 +			    FW_CMD_WRITE | FW_CMD_EXEC |
 +			    FW_EQ_CTRL_CMD_PFN(adap->fn) |
 +			    FW_EQ_CTRL_CMD_VFN(0));
 +	c.alloc_to_len16 = htonl(FW_EQ_CTRL_CMD_ALLOC |
 +				 FW_EQ_CTRL_CMD_EQSTART | FW_LEN16(c));
 +	c.cmpliqid_eqid = htonl(FW_EQ_CTRL_CMD_CMPLIQID(cmplqid));
++=======
+ 	c.op_to_vfn = htonl(FW_CMD_OP_V(FW_EQ_CTRL_CMD) | FW_CMD_REQUEST_F |
+ 			    FW_CMD_WRITE_F | FW_CMD_EXEC_F |
+ 			    FW_EQ_CTRL_CMD_PFN_V(adap->pf) |
+ 			    FW_EQ_CTRL_CMD_VFN_V(0));
+ 	c.alloc_to_len16 = htonl(FW_EQ_CTRL_CMD_ALLOC_F |
+ 				 FW_EQ_CTRL_CMD_EQSTART_F | FW_LEN16(c));
+ 	c.cmpliqid_eqid = htonl(FW_EQ_CTRL_CMD_CMPLIQID_V(cmplqid));
++>>>>>>> b26127227677 (cxgb4/cxgb4vf: function and argument name cleanup)
  	c.physeqid_pkd = htonl(0);
 -	c.fetchszm_to_iqid =
 -		htonl(FW_EQ_CTRL_CMD_HOSTFCMODE_V(HOSTFCMODE_STATUS_PAGE_X) |
 -		      FW_EQ_CTRL_CMD_PCIECHN_V(pi->tx_chan) |
 -		      FW_EQ_CTRL_CMD_FETCHRO_F | FW_EQ_CTRL_CMD_IQID_V(iqid));
 -	c.dcaen_to_eqsize =
 -		htonl(FW_EQ_CTRL_CMD_FBMIN_V(FETCHBURSTMIN_64B_X) |
 -		      FW_EQ_CTRL_CMD_FBMAX_V(FETCHBURSTMAX_512B_X) |
 -		      FW_EQ_CTRL_CMD_CIDXFTHRESH_V(CIDXFLUSHTHRESH_32_X) |
 -		      FW_EQ_CTRL_CMD_EQSIZE_V(nentries));
 +	c.fetchszm_to_iqid = htonl(FW_EQ_CTRL_CMD_HOSTFCMODE(2) |
 +				   FW_EQ_CTRL_CMD_PCIECHN(pi->tx_chan) |
 +				   FW_EQ_CTRL_CMD_FETCHRO |
 +				   FW_EQ_CTRL_CMD_IQID(iqid));
 +	c.dcaen_to_eqsize = htonl(FW_EQ_CTRL_CMD_FBMIN(2) |
 +				  FW_EQ_CTRL_CMD_FBMAX(3) |
 +				  FW_EQ_CTRL_CMD_CIDXFTHRESH(5) |
 +				  FW_EQ_CTRL_CMD_EQSIZE(nentries));
  	c.eqaddr = cpu_to_be64(txq->q.phys_addr);
  
- 	ret = t4_wr_mbox(adap, adap->fn, &c, sizeof(c), &c);
+ 	ret = t4_wr_mbox(adap, adap->mbox, &c, sizeof(c), &c);
  	if (ret) {
  		dma_free_coherent(adap->pdev_dev,
  				  nentries * sizeof(struct tx_desc),
@@@ -2579,23 -2714,24 +2667,41 @@@ int t4_sge_alloc_ofld_txq(struct adapte
  		return -ENOMEM;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_vfn = htonl(FW_CMD_OP(FW_EQ_OFLD_CMD) | FW_CMD_REQUEST |
 +			    FW_CMD_WRITE | FW_CMD_EXEC |
 +			    FW_EQ_OFLD_CMD_PFN(adap->fn) |
 +			    FW_EQ_OFLD_CMD_VFN(0));
 +	c.alloc_to_len16 = htonl(FW_EQ_OFLD_CMD_ALLOC |
 +				 FW_EQ_OFLD_CMD_EQSTART | FW_LEN16(c));
 +	c.fetchszm_to_iqid = htonl(FW_EQ_OFLD_CMD_HOSTFCMODE(2) |
 +				   FW_EQ_OFLD_CMD_PCIECHN(pi->tx_chan) |
 +				   FW_EQ_OFLD_CMD_FETCHRO(1) |
 +				   FW_EQ_OFLD_CMD_IQID(iqid));
 +	c.dcaen_to_eqsize = htonl(FW_EQ_OFLD_CMD_FBMIN(2) |
 +				  FW_EQ_OFLD_CMD_FBMAX(3) |
 +				  FW_EQ_OFLD_CMD_CIDXFTHRESH(5) |
 +				  FW_EQ_OFLD_CMD_EQSIZE(nentries));
++=======
+ 	c.op_to_vfn = htonl(FW_CMD_OP_V(FW_EQ_OFLD_CMD) | FW_CMD_REQUEST_F |
+ 			    FW_CMD_WRITE_F | FW_CMD_EXEC_F |
+ 			    FW_EQ_OFLD_CMD_PFN_V(adap->pf) |
+ 			    FW_EQ_OFLD_CMD_VFN_V(0));
+ 	c.alloc_to_len16 = htonl(FW_EQ_OFLD_CMD_ALLOC_F |
+ 				 FW_EQ_OFLD_CMD_EQSTART_F | FW_LEN16(c));
+ 	c.fetchszm_to_iqid =
+ 		htonl(FW_EQ_OFLD_CMD_HOSTFCMODE_V(HOSTFCMODE_STATUS_PAGE_X) |
+ 		      FW_EQ_OFLD_CMD_PCIECHN_V(pi->tx_chan) |
+ 		      FW_EQ_OFLD_CMD_FETCHRO_F | FW_EQ_OFLD_CMD_IQID_V(iqid));
+ 	c.dcaen_to_eqsize =
+ 		htonl(FW_EQ_OFLD_CMD_FBMIN_V(FETCHBURSTMIN_64B_X) |
+ 		      FW_EQ_OFLD_CMD_FBMAX_V(FETCHBURSTMAX_512B_X) |
+ 		      FW_EQ_OFLD_CMD_CIDXFTHRESH_V(CIDXFLUSHTHRESH_32_X) |
+ 		      FW_EQ_OFLD_CMD_EQSIZE_V(nentries));
++>>>>>>> b26127227677 (cxgb4/cxgb4vf: function and argument name cleanup)
  	c.eqaddr = cpu_to_be64(txq->q.phys_addr);
  
- 	ret = t4_wr_mbox(adap, adap->fn, &c, sizeof(c), &c);
+ 	ret = t4_wr_mbox(adap, adap->mbox, &c, sizeof(c), &c);
  	if (ret) {
  		kfree(txq->q.sdesc);
  		txq->q.sdesc = NULL;
diff --cc drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
index 4234b8c917e7,36a858c24305..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
@@@ -150,13 -150,13 +150,17 @@@ void t4_write_indirect(struct adapter *
   */
  void t4_hw_pci_read_cfg4(struct adapter *adap, int reg, u32 *val)
  {
++<<<<<<< HEAD
 +	u32 req = ENABLE | FUNCTION(adap->fn) | reg;
++=======
+ 	u32 req = ENABLE_F | FUNCTION_V(adap->pf) | REGISTER_V(reg);
++>>>>>>> b26127227677 (cxgb4/cxgb4vf: function and argument name cleanup)
  
  	if (is_t4(adap->params.chip))
 -		req |= LOCALCFG_F;
 +		req |= F_LOCALCFG;
  
 -	t4_write_reg(adap, PCIE_CFG_SPACE_REQ_A, req);
 -	*val = t4_read_reg(adap, PCIE_CFG_SPACE_DATA_A);
 +	t4_write_reg(adap, PCIE_CFG_SPACE_REQ, req);
 +	*val = t4_read_reg(adap, PCIE_CFG_SPACE_DATA);
  
  	/* Reset ENABLE to 0 so reads of PCIE_CFG_SPACE_DATA won't cause a
  	 * Configuration Space read.  (None of the other fields matter when
@@@ -507,13 -406,13 +511,17 @@@ int t4_memory_rw(struct adapter *adap, 
  	 * the address is relative to BAR0.
  	 */
  	mem_reg = t4_read_reg(adap,
 -			      PCIE_MEM_ACCESS_REG(PCIE_MEM_ACCESS_BASE_WIN_A,
 +			      PCIE_MEM_ACCESS_REG(PCIE_MEM_ACCESS_BASE_WIN,
  						  win));
 -	mem_aperture = 1 << (WINDOW_G(mem_reg) + WINDOW_SHIFT_X);
 -	mem_base = PCIEOFST_G(mem_reg) << PCIEOFST_SHIFT_X;
 +	mem_aperture = 1 << (GET_WINDOW(mem_reg) + 10);
 +	mem_base = GET_PCIEOFST(mem_reg) << 10;
  	if (is_t4(adap->params.chip))
  		mem_base -= adap->t4_bar0;
++<<<<<<< HEAD
 +	win_pf = is_t4(adap->params.chip) ? 0 : V_PFNUM(adap->fn);
++=======
+ 	win_pf = is_t4(adap->params.chip) ? 0 : PFNUM_V(adap->pf);
++>>>>>>> b26127227677 (cxgb4/cxgb4vf: function and argument name cleanup)
  
  	/* Calculate our initial PCI-E Memory Window Position and Offset into
  	 * that Window.
@@@ -624,6 -523,843 +632,846 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /* Return the specified PCI-E Configuration Space register from our Physical
+  * Function.  We try first via a Firmware LDST Command since we prefer to let
+  * the firmware own all of these registers, but if that fails we go for it
+  * directly ourselves.
+  */
+ u32 t4_read_pcie_cfg4(struct adapter *adap, int reg)
+ {
+ 	u32 val, ldst_addrspace;
+ 
+ 	/* If fw_attach != 0, construct and send the Firmware LDST Command to
+ 	 * retrieve the specified PCI-E Configuration Space register.
+ 	 */
+ 	struct fw_ldst_cmd ldst_cmd;
+ 	int ret;
+ 
+ 	memset(&ldst_cmd, 0, sizeof(ldst_cmd));
+ 	ldst_addrspace = FW_LDST_CMD_ADDRSPACE_V(FW_LDST_ADDRSPC_FUNC_PCIE);
+ 	ldst_cmd.op_to_addrspace = cpu_to_be32(FW_CMD_OP_V(FW_LDST_CMD) |
+ 					       FW_CMD_REQUEST_F |
+ 					       FW_CMD_READ_F |
+ 					       ldst_addrspace);
+ 	ldst_cmd.cycles_to_len16 = cpu_to_be32(FW_LEN16(ldst_cmd));
+ 	ldst_cmd.u.pcie.select_naccess = FW_LDST_CMD_NACCESS_V(1);
+ 	ldst_cmd.u.pcie.ctrl_to_fn =
+ 		(FW_LDST_CMD_LC_F | FW_LDST_CMD_FN_V(adap->pf));
+ 	ldst_cmd.u.pcie.r = reg;
+ 
+ 	/* If the LDST Command succeeds, return the result, otherwise
+ 	 * fall through to reading it directly ourselves ...
+ 	 */
+ 	ret = t4_wr_mbox(adap, adap->mbox, &ldst_cmd, sizeof(ldst_cmd),
+ 			 &ldst_cmd);
+ 	if (ret == 0)
+ 		val = be32_to_cpu(ldst_cmd.u.pcie.data[0]);
+ 	else
+ 		/* Read the desired Configuration Space register via the PCI-E
+ 		 * Backdoor mechanism.
+ 		 */
+ 		t4_hw_pci_read_cfg4(adap, reg, &val);
+ 	return val;
+ }
+ 
+ /* Get the window based on base passed to it.
+  * Window aperture is currently unhandled, but there is no use case for it
+  * right now
+  */
+ static u32 t4_get_window(struct adapter *adap, u32 pci_base, u64 pci_mask,
+ 			 u32 memwin_base)
+ {
+ 	u32 ret;
+ 
+ 	if (is_t4(adap->params.chip)) {
+ 		u32 bar0;
+ 
+ 		/* Truncation intentional: we only read the bottom 32-bits of
+ 		 * the 64-bit BAR0/BAR1 ...  We use the hardware backdoor
+ 		 * mechanism to read BAR0 instead of using
+ 		 * pci_resource_start() because we could be operating from
+ 		 * within a Virtual Machine which is trapping our accesses to
+ 		 * our Configuration Space and we need to set up the PCI-E
+ 		 * Memory Window decoders with the actual addresses which will
+ 		 * be coming across the PCI-E link.
+ 		 */
+ 		bar0 = t4_read_pcie_cfg4(adap, pci_base);
+ 		bar0 &= pci_mask;
+ 		adap->t4_bar0 = bar0;
+ 
+ 		ret = bar0 + memwin_base;
+ 	} else {
+ 		/* For T5, only relative offset inside the PCIe BAR is passed */
+ 		ret = memwin_base;
+ 	}
+ 	return ret;
+ }
+ 
+ /* Get the default utility window (win0) used by everyone */
+ u32 t4_get_util_window(struct adapter *adap)
+ {
+ 	return t4_get_window(adap, PCI_BASE_ADDRESS_0,
+ 			     PCI_BASE_ADDRESS_MEM_MASK, MEMWIN0_BASE);
+ }
+ 
+ /* Set up memory window for accessing adapter memory ranges.  (Read
+  * back MA register to ensure that changes propagate before we attempt
+  * to use the new values.)
+  */
+ void t4_setup_memwin(struct adapter *adap, u32 memwin_base, u32 window)
+ {
+ 	t4_write_reg(adap,
+ 		     PCIE_MEM_ACCESS_REG(PCIE_MEM_ACCESS_BASE_WIN_A, window),
+ 		     memwin_base | BIR_V(0) |
+ 		     WINDOW_V(ilog2(MEMWIN0_APERTURE) - WINDOW_SHIFT_X));
+ 	t4_read_reg(adap,
+ 		    PCIE_MEM_ACCESS_REG(PCIE_MEM_ACCESS_BASE_WIN_A, window));
+ }
+ 
+ /**
+  *	t4_get_regs_len - return the size of the chips register set
+  *	@adapter: the adapter
+  *
+  *	Returns the size of the chip's BAR0 register space.
+  */
+ unsigned int t4_get_regs_len(struct adapter *adapter)
+ {
+ 	unsigned int chip_version = CHELSIO_CHIP_VERSION(adapter->params.chip);
+ 
+ 	switch (chip_version) {
+ 	case CHELSIO_T4:
+ 		return T4_REGMAP_SIZE;
+ 
+ 	case CHELSIO_T5:
+ 		return T5_REGMAP_SIZE;
+ 	}
+ 
+ 	dev_err(adapter->pdev_dev,
+ 		"Unsupported chip version %d\n", chip_version);
+ 	return 0;
+ }
+ 
+ /**
+  *	t4_get_regs - read chip registers into provided buffer
+  *	@adap: the adapter
+  *	@buf: register buffer
+  *	@buf_size: size (in bytes) of register buffer
+  *
+  *	If the provided register buffer isn't large enough for the chip's
+  *	full register range, the register dump will be truncated to the
+  *	register buffer's size.
+  */
+ void t4_get_regs(struct adapter *adap, void *buf, size_t buf_size)
+ {
+ 	static const unsigned int t4_reg_ranges[] = {
+ 		0x1008, 0x1108,
+ 		0x1180, 0x11b4,
+ 		0x11fc, 0x123c,
+ 		0x1300, 0x173c,
+ 		0x1800, 0x18fc,
+ 		0x3000, 0x305c,
+ 		0x3068, 0x30d8,
+ 		0x30e0, 0x5924,
+ 		0x5960, 0x59d4,
+ 		0x5a00, 0x5af8,
+ 		0x6000, 0x6098,
+ 		0x6100, 0x6150,
+ 		0x6200, 0x6208,
+ 		0x6240, 0x6248,
+ 		0x6280, 0x6338,
+ 		0x6370, 0x638c,
+ 		0x6400, 0x643c,
+ 		0x6500, 0x6524,
+ 		0x6a00, 0x6a38,
+ 		0x6a60, 0x6a78,
+ 		0x6b00, 0x6b84,
+ 		0x6bf0, 0x6c84,
+ 		0x6cf0, 0x6d84,
+ 		0x6df0, 0x6e84,
+ 		0x6ef0, 0x6f84,
+ 		0x6ff0, 0x7084,
+ 		0x70f0, 0x7184,
+ 		0x71f0, 0x7284,
+ 		0x72f0, 0x7384,
+ 		0x73f0, 0x7450,
+ 		0x7500, 0x7530,
+ 		0x7600, 0x761c,
+ 		0x7680, 0x76cc,
+ 		0x7700, 0x7798,
+ 		0x77c0, 0x77fc,
+ 		0x7900, 0x79fc,
+ 		0x7b00, 0x7c38,
+ 		0x7d00, 0x7efc,
+ 		0x8dc0, 0x8e1c,
+ 		0x8e30, 0x8e78,
+ 		0x8ea0, 0x8f6c,
+ 		0x8fc0, 0x9074,
+ 		0x90fc, 0x90fc,
+ 		0x9400, 0x9458,
+ 		0x9600, 0x96bc,
+ 		0x9800, 0x9808,
+ 		0x9820, 0x983c,
+ 		0x9850, 0x9864,
+ 		0x9c00, 0x9c6c,
+ 		0x9c80, 0x9cec,
+ 		0x9d00, 0x9d6c,
+ 		0x9d80, 0x9dec,
+ 		0x9e00, 0x9e6c,
+ 		0x9e80, 0x9eec,
+ 		0x9f00, 0x9f6c,
+ 		0x9f80, 0x9fec,
+ 		0xd004, 0xd03c,
+ 		0xdfc0, 0xdfe0,
+ 		0xe000, 0xea7c,
+ 		0xf000, 0x11110,
+ 		0x11118, 0x11190,
+ 		0x19040, 0x1906c,
+ 		0x19078, 0x19080,
+ 		0x1908c, 0x19124,
+ 		0x19150, 0x191b0,
+ 		0x191d0, 0x191e8,
+ 		0x19238, 0x1924c,
+ 		0x193f8, 0x19474,
+ 		0x19490, 0x194f8,
+ 		0x19800, 0x19f4c,
+ 		0x1a000, 0x1a06c,
+ 		0x1a0b0, 0x1a120,
+ 		0x1a128, 0x1a138,
+ 		0x1a190, 0x1a1c4,
+ 		0x1a1fc, 0x1a1fc,
+ 		0x1e040, 0x1e04c,
+ 		0x1e284, 0x1e28c,
+ 		0x1e2c0, 0x1e2c0,
+ 		0x1e2e0, 0x1e2e0,
+ 		0x1e300, 0x1e384,
+ 		0x1e3c0, 0x1e3c8,
+ 		0x1e440, 0x1e44c,
+ 		0x1e684, 0x1e68c,
+ 		0x1e6c0, 0x1e6c0,
+ 		0x1e6e0, 0x1e6e0,
+ 		0x1e700, 0x1e784,
+ 		0x1e7c0, 0x1e7c8,
+ 		0x1e840, 0x1e84c,
+ 		0x1ea84, 0x1ea8c,
+ 		0x1eac0, 0x1eac0,
+ 		0x1eae0, 0x1eae0,
+ 		0x1eb00, 0x1eb84,
+ 		0x1ebc0, 0x1ebc8,
+ 		0x1ec40, 0x1ec4c,
+ 		0x1ee84, 0x1ee8c,
+ 		0x1eec0, 0x1eec0,
+ 		0x1eee0, 0x1eee0,
+ 		0x1ef00, 0x1ef84,
+ 		0x1efc0, 0x1efc8,
+ 		0x1f040, 0x1f04c,
+ 		0x1f284, 0x1f28c,
+ 		0x1f2c0, 0x1f2c0,
+ 		0x1f2e0, 0x1f2e0,
+ 		0x1f300, 0x1f384,
+ 		0x1f3c0, 0x1f3c8,
+ 		0x1f440, 0x1f44c,
+ 		0x1f684, 0x1f68c,
+ 		0x1f6c0, 0x1f6c0,
+ 		0x1f6e0, 0x1f6e0,
+ 		0x1f700, 0x1f784,
+ 		0x1f7c0, 0x1f7c8,
+ 		0x1f840, 0x1f84c,
+ 		0x1fa84, 0x1fa8c,
+ 		0x1fac0, 0x1fac0,
+ 		0x1fae0, 0x1fae0,
+ 		0x1fb00, 0x1fb84,
+ 		0x1fbc0, 0x1fbc8,
+ 		0x1fc40, 0x1fc4c,
+ 		0x1fe84, 0x1fe8c,
+ 		0x1fec0, 0x1fec0,
+ 		0x1fee0, 0x1fee0,
+ 		0x1ff00, 0x1ff84,
+ 		0x1ffc0, 0x1ffc8,
+ 		0x20000, 0x2002c,
+ 		0x20100, 0x2013c,
+ 		0x20190, 0x201c8,
+ 		0x20200, 0x20318,
+ 		0x20400, 0x20528,
+ 		0x20540, 0x20614,
+ 		0x21000, 0x21040,
+ 		0x2104c, 0x21060,
+ 		0x210c0, 0x210ec,
+ 		0x21200, 0x21268,
+ 		0x21270, 0x21284,
+ 		0x212fc, 0x21388,
+ 		0x21400, 0x21404,
+ 		0x21500, 0x21518,
+ 		0x2152c, 0x2153c,
+ 		0x21550, 0x21554,
+ 		0x21600, 0x21600,
+ 		0x21608, 0x21628,
+ 		0x21630, 0x2163c,
+ 		0x21700, 0x2171c,
+ 		0x21780, 0x2178c,
+ 		0x21800, 0x21c38,
+ 		0x21c80, 0x21d7c,
+ 		0x21e00, 0x21e04,
+ 		0x22000, 0x2202c,
+ 		0x22100, 0x2213c,
+ 		0x22190, 0x221c8,
+ 		0x22200, 0x22318,
+ 		0x22400, 0x22528,
+ 		0x22540, 0x22614,
+ 		0x23000, 0x23040,
+ 		0x2304c, 0x23060,
+ 		0x230c0, 0x230ec,
+ 		0x23200, 0x23268,
+ 		0x23270, 0x23284,
+ 		0x232fc, 0x23388,
+ 		0x23400, 0x23404,
+ 		0x23500, 0x23518,
+ 		0x2352c, 0x2353c,
+ 		0x23550, 0x23554,
+ 		0x23600, 0x23600,
+ 		0x23608, 0x23628,
+ 		0x23630, 0x2363c,
+ 		0x23700, 0x2371c,
+ 		0x23780, 0x2378c,
+ 		0x23800, 0x23c38,
+ 		0x23c80, 0x23d7c,
+ 		0x23e00, 0x23e04,
+ 		0x24000, 0x2402c,
+ 		0x24100, 0x2413c,
+ 		0x24190, 0x241c8,
+ 		0x24200, 0x24318,
+ 		0x24400, 0x24528,
+ 		0x24540, 0x24614,
+ 		0x25000, 0x25040,
+ 		0x2504c, 0x25060,
+ 		0x250c0, 0x250ec,
+ 		0x25200, 0x25268,
+ 		0x25270, 0x25284,
+ 		0x252fc, 0x25388,
+ 		0x25400, 0x25404,
+ 		0x25500, 0x25518,
+ 		0x2552c, 0x2553c,
+ 		0x25550, 0x25554,
+ 		0x25600, 0x25600,
+ 		0x25608, 0x25628,
+ 		0x25630, 0x2563c,
+ 		0x25700, 0x2571c,
+ 		0x25780, 0x2578c,
+ 		0x25800, 0x25c38,
+ 		0x25c80, 0x25d7c,
+ 		0x25e00, 0x25e04,
+ 		0x26000, 0x2602c,
+ 		0x26100, 0x2613c,
+ 		0x26190, 0x261c8,
+ 		0x26200, 0x26318,
+ 		0x26400, 0x26528,
+ 		0x26540, 0x26614,
+ 		0x27000, 0x27040,
+ 		0x2704c, 0x27060,
+ 		0x270c0, 0x270ec,
+ 		0x27200, 0x27268,
+ 		0x27270, 0x27284,
+ 		0x272fc, 0x27388,
+ 		0x27400, 0x27404,
+ 		0x27500, 0x27518,
+ 		0x2752c, 0x2753c,
+ 		0x27550, 0x27554,
+ 		0x27600, 0x27600,
+ 		0x27608, 0x27628,
+ 		0x27630, 0x2763c,
+ 		0x27700, 0x2771c,
+ 		0x27780, 0x2778c,
+ 		0x27800, 0x27c38,
+ 		0x27c80, 0x27d7c,
+ 		0x27e00, 0x27e04,
+ 	};
+ 
+ 	static const unsigned int t5_reg_ranges[] = {
+ 		0x1008, 0x1148,
+ 		0x1180, 0x11b4,
+ 		0x11fc, 0x123c,
+ 		0x1280, 0x173c,
+ 		0x1800, 0x18fc,
+ 		0x3000, 0x3028,
+ 		0x3068, 0x30d8,
+ 		0x30e0, 0x30fc,
+ 		0x3140, 0x357c,
+ 		0x35a8, 0x35cc,
+ 		0x35ec, 0x35ec,
+ 		0x3600, 0x5624,
+ 		0x56cc, 0x575c,
+ 		0x580c, 0x5814,
+ 		0x5890, 0x58bc,
+ 		0x5940, 0x59dc,
+ 		0x59fc, 0x5a18,
+ 		0x5a60, 0x5a9c,
+ 		0x5b94, 0x5bfc,
+ 		0x6000, 0x6040,
+ 		0x6058, 0x614c,
+ 		0x7700, 0x7798,
+ 		0x77c0, 0x78fc,
+ 		0x7b00, 0x7c54,
+ 		0x7d00, 0x7efc,
+ 		0x8dc0, 0x8de0,
+ 		0x8df8, 0x8e84,
+ 		0x8ea0, 0x8f84,
+ 		0x8fc0, 0x90f8,
+ 		0x9400, 0x9470,
+ 		0x9600, 0x96f4,
+ 		0x9800, 0x9808,
+ 		0x9820, 0x983c,
+ 		0x9850, 0x9864,
+ 		0x9c00, 0x9c6c,
+ 		0x9c80, 0x9cec,
+ 		0x9d00, 0x9d6c,
+ 		0x9d80, 0x9dec,
+ 		0x9e00, 0x9e6c,
+ 		0x9e80, 0x9eec,
+ 		0x9f00, 0x9f6c,
+ 		0x9f80, 0xa020,
+ 		0xd004, 0xd03c,
+ 		0xdfc0, 0xdfe0,
+ 		0xe000, 0x11088,
+ 		0x1109c, 0x11110,
+ 		0x11118, 0x1117c,
+ 		0x11190, 0x11204,
+ 		0x19040, 0x1906c,
+ 		0x19078, 0x19080,
+ 		0x1908c, 0x19124,
+ 		0x19150, 0x191b0,
+ 		0x191d0, 0x191e8,
+ 		0x19238, 0x19290,
+ 		0x193f8, 0x19474,
+ 		0x19490, 0x194cc,
+ 		0x194f0, 0x194f8,
+ 		0x19c00, 0x19c60,
+ 		0x19c94, 0x19e10,
+ 		0x19e50, 0x19f34,
+ 		0x19f40, 0x19f50,
+ 		0x19f90, 0x19fe4,
+ 		0x1a000, 0x1a06c,
+ 		0x1a0b0, 0x1a120,
+ 		0x1a128, 0x1a138,
+ 		0x1a190, 0x1a1c4,
+ 		0x1a1fc, 0x1a1fc,
+ 		0x1e008, 0x1e00c,
+ 		0x1e040, 0x1e04c,
+ 		0x1e284, 0x1e290,
+ 		0x1e2c0, 0x1e2c0,
+ 		0x1e2e0, 0x1e2e0,
+ 		0x1e300, 0x1e384,
+ 		0x1e3c0, 0x1e3c8,
+ 		0x1e408, 0x1e40c,
+ 		0x1e440, 0x1e44c,
+ 		0x1e684, 0x1e690,
+ 		0x1e6c0, 0x1e6c0,
+ 		0x1e6e0, 0x1e6e0,
+ 		0x1e700, 0x1e784,
+ 		0x1e7c0, 0x1e7c8,
+ 		0x1e808, 0x1e80c,
+ 		0x1e840, 0x1e84c,
+ 		0x1ea84, 0x1ea90,
+ 		0x1eac0, 0x1eac0,
+ 		0x1eae0, 0x1eae0,
+ 		0x1eb00, 0x1eb84,
+ 		0x1ebc0, 0x1ebc8,
+ 		0x1ec08, 0x1ec0c,
+ 		0x1ec40, 0x1ec4c,
+ 		0x1ee84, 0x1ee90,
+ 		0x1eec0, 0x1eec0,
+ 		0x1eee0, 0x1eee0,
+ 		0x1ef00, 0x1ef84,
+ 		0x1efc0, 0x1efc8,
+ 		0x1f008, 0x1f00c,
+ 		0x1f040, 0x1f04c,
+ 		0x1f284, 0x1f290,
+ 		0x1f2c0, 0x1f2c0,
+ 		0x1f2e0, 0x1f2e0,
+ 		0x1f300, 0x1f384,
+ 		0x1f3c0, 0x1f3c8,
+ 		0x1f408, 0x1f40c,
+ 		0x1f440, 0x1f44c,
+ 		0x1f684, 0x1f690,
+ 		0x1f6c0, 0x1f6c0,
+ 		0x1f6e0, 0x1f6e0,
+ 		0x1f700, 0x1f784,
+ 		0x1f7c0, 0x1f7c8,
+ 		0x1f808, 0x1f80c,
+ 		0x1f840, 0x1f84c,
+ 		0x1fa84, 0x1fa90,
+ 		0x1fac0, 0x1fac0,
+ 		0x1fae0, 0x1fae0,
+ 		0x1fb00, 0x1fb84,
+ 		0x1fbc0, 0x1fbc8,
+ 		0x1fc08, 0x1fc0c,
+ 		0x1fc40, 0x1fc4c,
+ 		0x1fe84, 0x1fe90,
+ 		0x1fec0, 0x1fec0,
+ 		0x1fee0, 0x1fee0,
+ 		0x1ff00, 0x1ff84,
+ 		0x1ffc0, 0x1ffc8,
+ 		0x30000, 0x30030,
+ 		0x30100, 0x30144,
+ 		0x30190, 0x301d0,
+ 		0x30200, 0x30318,
+ 		0x30400, 0x3052c,
+ 		0x30540, 0x3061c,
+ 		0x30800, 0x30834,
+ 		0x308c0, 0x30908,
+ 		0x30910, 0x309ac,
+ 		0x30a00, 0x30a2c,
+ 		0x30a44, 0x30a50,
+ 		0x30a74, 0x30c24,
+ 		0x30d00, 0x30d00,
+ 		0x30d08, 0x30d14,
+ 		0x30d1c, 0x30d20,
+ 		0x30d3c, 0x30d50,
+ 		0x31200, 0x3120c,
+ 		0x31220, 0x31220,
+ 		0x31240, 0x31240,
+ 		0x31600, 0x3160c,
+ 		0x31a00, 0x31a1c,
+ 		0x31e00, 0x31e20,
+ 		0x31e38, 0x31e3c,
+ 		0x31e80, 0x31e80,
+ 		0x31e88, 0x31ea8,
+ 		0x31eb0, 0x31eb4,
+ 		0x31ec8, 0x31ed4,
+ 		0x31fb8, 0x32004,
+ 		0x32200, 0x32200,
+ 		0x32208, 0x32240,
+ 		0x32248, 0x32280,
+ 		0x32288, 0x322c0,
+ 		0x322c8, 0x322fc,
+ 		0x32600, 0x32630,
+ 		0x32a00, 0x32abc,
+ 		0x32b00, 0x32b70,
+ 		0x33000, 0x33048,
+ 		0x33060, 0x3309c,
+ 		0x330f0, 0x33148,
+ 		0x33160, 0x3319c,
+ 		0x331f0, 0x332e4,
+ 		0x332f8, 0x333e4,
+ 		0x333f8, 0x33448,
+ 		0x33460, 0x3349c,
+ 		0x334f0, 0x33548,
+ 		0x33560, 0x3359c,
+ 		0x335f0, 0x336e4,
+ 		0x336f8, 0x337e4,
+ 		0x337f8, 0x337fc,
+ 		0x33814, 0x33814,
+ 		0x3382c, 0x3382c,
+ 		0x33880, 0x3388c,
+ 		0x338e8, 0x338ec,
+ 		0x33900, 0x33948,
+ 		0x33960, 0x3399c,
+ 		0x339f0, 0x33ae4,
+ 		0x33af8, 0x33b10,
+ 		0x33b28, 0x33b28,
+ 		0x33b3c, 0x33b50,
+ 		0x33bf0, 0x33c10,
+ 		0x33c28, 0x33c28,
+ 		0x33c3c, 0x33c50,
+ 		0x33cf0, 0x33cfc,
+ 		0x34000, 0x34030,
+ 		0x34100, 0x34144,
+ 		0x34190, 0x341d0,
+ 		0x34200, 0x34318,
+ 		0x34400, 0x3452c,
+ 		0x34540, 0x3461c,
+ 		0x34800, 0x34834,
+ 		0x348c0, 0x34908,
+ 		0x34910, 0x349ac,
+ 		0x34a00, 0x34a2c,
+ 		0x34a44, 0x34a50,
+ 		0x34a74, 0x34c24,
+ 		0x34d00, 0x34d00,
+ 		0x34d08, 0x34d14,
+ 		0x34d1c, 0x34d20,
+ 		0x34d3c, 0x34d50,
+ 		0x35200, 0x3520c,
+ 		0x35220, 0x35220,
+ 		0x35240, 0x35240,
+ 		0x35600, 0x3560c,
+ 		0x35a00, 0x35a1c,
+ 		0x35e00, 0x35e20,
+ 		0x35e38, 0x35e3c,
+ 		0x35e80, 0x35e80,
+ 		0x35e88, 0x35ea8,
+ 		0x35eb0, 0x35eb4,
+ 		0x35ec8, 0x35ed4,
+ 		0x35fb8, 0x36004,
+ 		0x36200, 0x36200,
+ 		0x36208, 0x36240,
+ 		0x36248, 0x36280,
+ 		0x36288, 0x362c0,
+ 		0x362c8, 0x362fc,
+ 		0x36600, 0x36630,
+ 		0x36a00, 0x36abc,
+ 		0x36b00, 0x36b70,
+ 		0x37000, 0x37048,
+ 		0x37060, 0x3709c,
+ 		0x370f0, 0x37148,
+ 		0x37160, 0x3719c,
+ 		0x371f0, 0x372e4,
+ 		0x372f8, 0x373e4,
+ 		0x373f8, 0x37448,
+ 		0x37460, 0x3749c,
+ 		0x374f0, 0x37548,
+ 		0x37560, 0x3759c,
+ 		0x375f0, 0x376e4,
+ 		0x376f8, 0x377e4,
+ 		0x377f8, 0x377fc,
+ 		0x37814, 0x37814,
+ 		0x3782c, 0x3782c,
+ 		0x37880, 0x3788c,
+ 		0x378e8, 0x378ec,
+ 		0x37900, 0x37948,
+ 		0x37960, 0x3799c,
+ 		0x379f0, 0x37ae4,
+ 		0x37af8, 0x37b10,
+ 		0x37b28, 0x37b28,
+ 		0x37b3c, 0x37b50,
+ 		0x37bf0, 0x37c10,
+ 		0x37c28, 0x37c28,
+ 		0x37c3c, 0x37c50,
+ 		0x37cf0, 0x37cfc,
+ 		0x38000, 0x38030,
+ 		0x38100, 0x38144,
+ 		0x38190, 0x381d0,
+ 		0x38200, 0x38318,
+ 		0x38400, 0x3852c,
+ 		0x38540, 0x3861c,
+ 		0x38800, 0x38834,
+ 		0x388c0, 0x38908,
+ 		0x38910, 0x389ac,
+ 		0x38a00, 0x38a2c,
+ 		0x38a44, 0x38a50,
+ 		0x38a74, 0x38c24,
+ 		0x38d00, 0x38d00,
+ 		0x38d08, 0x38d14,
+ 		0x38d1c, 0x38d20,
+ 		0x38d3c, 0x38d50,
+ 		0x39200, 0x3920c,
+ 		0x39220, 0x39220,
+ 		0x39240, 0x39240,
+ 		0x39600, 0x3960c,
+ 		0x39a00, 0x39a1c,
+ 		0x39e00, 0x39e20,
+ 		0x39e38, 0x39e3c,
+ 		0x39e80, 0x39e80,
+ 		0x39e88, 0x39ea8,
+ 		0x39eb0, 0x39eb4,
+ 		0x39ec8, 0x39ed4,
+ 		0x39fb8, 0x3a004,
+ 		0x3a200, 0x3a200,
+ 		0x3a208, 0x3a240,
+ 		0x3a248, 0x3a280,
+ 		0x3a288, 0x3a2c0,
+ 		0x3a2c8, 0x3a2fc,
+ 		0x3a600, 0x3a630,
+ 		0x3aa00, 0x3aabc,
+ 		0x3ab00, 0x3ab70,
+ 		0x3b000, 0x3b048,
+ 		0x3b060, 0x3b09c,
+ 		0x3b0f0, 0x3b148,
+ 		0x3b160, 0x3b19c,
+ 		0x3b1f0, 0x3b2e4,
+ 		0x3b2f8, 0x3b3e4,
+ 		0x3b3f8, 0x3b448,
+ 		0x3b460, 0x3b49c,
+ 		0x3b4f0, 0x3b548,
+ 		0x3b560, 0x3b59c,
+ 		0x3b5f0, 0x3b6e4,
+ 		0x3b6f8, 0x3b7e4,
+ 		0x3b7f8, 0x3b7fc,
+ 		0x3b814, 0x3b814,
+ 		0x3b82c, 0x3b82c,
+ 		0x3b880, 0x3b88c,
+ 		0x3b8e8, 0x3b8ec,
+ 		0x3b900, 0x3b948,
+ 		0x3b960, 0x3b99c,
+ 		0x3b9f0, 0x3bae4,
+ 		0x3baf8, 0x3bb10,
+ 		0x3bb28, 0x3bb28,
+ 		0x3bb3c, 0x3bb50,
+ 		0x3bbf0, 0x3bc10,
+ 		0x3bc28, 0x3bc28,
+ 		0x3bc3c, 0x3bc50,
+ 		0x3bcf0, 0x3bcfc,
+ 		0x3c000, 0x3c030,
+ 		0x3c100, 0x3c144,
+ 		0x3c190, 0x3c1d0,
+ 		0x3c200, 0x3c318,
+ 		0x3c400, 0x3c52c,
+ 		0x3c540, 0x3c61c,
+ 		0x3c800, 0x3c834,
+ 		0x3c8c0, 0x3c908,
+ 		0x3c910, 0x3c9ac,
+ 		0x3ca00, 0x3ca2c,
+ 		0x3ca44, 0x3ca50,
+ 		0x3ca74, 0x3cc24,
+ 		0x3cd00, 0x3cd00,
+ 		0x3cd08, 0x3cd14,
+ 		0x3cd1c, 0x3cd20,
+ 		0x3cd3c, 0x3cd50,
+ 		0x3d200, 0x3d20c,
+ 		0x3d220, 0x3d220,
+ 		0x3d240, 0x3d240,
+ 		0x3d600, 0x3d60c,
+ 		0x3da00, 0x3da1c,
+ 		0x3de00, 0x3de20,
+ 		0x3de38, 0x3de3c,
+ 		0x3de80, 0x3de80,
+ 		0x3de88, 0x3dea8,
+ 		0x3deb0, 0x3deb4,
+ 		0x3dec8, 0x3ded4,
+ 		0x3dfb8, 0x3e004,
+ 		0x3e200, 0x3e200,
+ 		0x3e208, 0x3e240,
+ 		0x3e248, 0x3e280,
+ 		0x3e288, 0x3e2c0,
+ 		0x3e2c8, 0x3e2fc,
+ 		0x3e600, 0x3e630,
+ 		0x3ea00, 0x3eabc,
+ 		0x3eb00, 0x3eb70,
+ 		0x3f000, 0x3f048,
+ 		0x3f060, 0x3f09c,
+ 		0x3f0f0, 0x3f148,
+ 		0x3f160, 0x3f19c,
+ 		0x3f1f0, 0x3f2e4,
+ 		0x3f2f8, 0x3f3e4,
+ 		0x3f3f8, 0x3f448,
+ 		0x3f460, 0x3f49c,
+ 		0x3f4f0, 0x3f548,
+ 		0x3f560, 0x3f59c,
+ 		0x3f5f0, 0x3f6e4,
+ 		0x3f6f8, 0x3f7e4,
+ 		0x3f7f8, 0x3f7fc,
+ 		0x3f814, 0x3f814,
+ 		0x3f82c, 0x3f82c,
+ 		0x3f880, 0x3f88c,
+ 		0x3f8e8, 0x3f8ec,
+ 		0x3f900, 0x3f948,
+ 		0x3f960, 0x3f99c,
+ 		0x3f9f0, 0x3fae4,
+ 		0x3faf8, 0x3fb10,
+ 		0x3fb28, 0x3fb28,
+ 		0x3fb3c, 0x3fb50,
+ 		0x3fbf0, 0x3fc10,
+ 		0x3fc28, 0x3fc28,
+ 		0x3fc3c, 0x3fc50,
+ 		0x3fcf0, 0x3fcfc,
+ 		0x40000, 0x4000c,
+ 		0x40040, 0x40068,
+ 		0x4007c, 0x40144,
+ 		0x40180, 0x4018c,
+ 		0x40200, 0x40298,
+ 		0x402ac, 0x4033c,
+ 		0x403f8, 0x403fc,
+ 		0x41304, 0x413c4,
+ 		0x41400, 0x4141c,
+ 		0x41480, 0x414d0,
+ 		0x44000, 0x44078,
+ 		0x440c0, 0x44278,
+ 		0x442c0, 0x44478,
+ 		0x444c0, 0x44678,
+ 		0x446c0, 0x44878,
+ 		0x448c0, 0x449fc,
+ 		0x45000, 0x45068,
+ 		0x45080, 0x45084,
+ 		0x450a0, 0x450b0,
+ 		0x45200, 0x45268,
+ 		0x45280, 0x45284,
+ 		0x452a0, 0x452b0,
+ 		0x460c0, 0x460e4,
+ 		0x47000, 0x4708c,
+ 		0x47200, 0x47250,
+ 		0x47400, 0x47420,
+ 		0x47600, 0x47618,
+ 		0x47800, 0x47814,
+ 		0x48000, 0x4800c,
+ 		0x48040, 0x48068,
+ 		0x4807c, 0x48144,
+ 		0x48180, 0x4818c,
+ 		0x48200, 0x48298,
+ 		0x482ac, 0x4833c,
+ 		0x483f8, 0x483fc,
+ 		0x49304, 0x493c4,
+ 		0x49400, 0x4941c,
+ 		0x49480, 0x494d0,
+ 		0x4c000, 0x4c078,
+ 		0x4c0c0, 0x4c278,
+ 		0x4c2c0, 0x4c478,
+ 		0x4c4c0, 0x4c678,
+ 		0x4c6c0, 0x4c878,
+ 		0x4c8c0, 0x4c9fc,
+ 		0x4d000, 0x4d068,
+ 		0x4d080, 0x4d084,
+ 		0x4d0a0, 0x4d0b0,
+ 		0x4d200, 0x4d268,
+ 		0x4d280, 0x4d284,
+ 		0x4d2a0, 0x4d2b0,
+ 		0x4e0c0, 0x4e0e4,
+ 		0x4f000, 0x4f08c,
+ 		0x4f200, 0x4f250,
+ 		0x4f400, 0x4f420,
+ 		0x4f600, 0x4f618,
+ 		0x4f800, 0x4f814,
+ 		0x50000, 0x500cc,
+ 		0x50400, 0x50400,
+ 		0x50800, 0x508cc,
+ 		0x50c00, 0x50c00,
+ 		0x51000, 0x5101c,
+ 		0x51300, 0x51308,
+ 	};
+ 
+ 	u32 *buf_end = (u32 *)((char *)buf + buf_size);
+ 	const unsigned int *reg_ranges;
+ 	int reg_ranges_size, range;
+ 	unsigned int chip_version = CHELSIO_CHIP_VERSION(adap->params.chip);
+ 
+ 	/* Select the right set of register ranges to dump depending on the
+ 	 * adapter chip type.
+ 	 */
+ 	switch (chip_version) {
+ 	case CHELSIO_T4:
+ 		reg_ranges = t4_reg_ranges;
+ 		reg_ranges_size = ARRAY_SIZE(t4_reg_ranges);
+ 		break;
+ 
+ 	case CHELSIO_T5:
+ 		reg_ranges = t5_reg_ranges;
+ 		reg_ranges_size = ARRAY_SIZE(t5_reg_ranges);
+ 		break;
+ 
+ 	default:
+ 		dev_err(adap->pdev_dev,
+ 			"Unsupported chip version %d\n", chip_version);
+ 		return;
+ 	}
+ 
+ 	/* Clear the register buffer and insert the appropriate register
+ 	 * values selected by the above register ranges.
+ 	 */
+ 	memset(buf, 0, buf_size);
+ 	for (range = 0; range < reg_ranges_size; range += 2) {
+ 		unsigned int reg = reg_ranges[range];
+ 		unsigned int last_reg = reg_ranges[range + 1];
+ 		u32 *bufp = (u32 *)((char *)buf + reg);
+ 
+ 		/* Iterate across the register range filling in the register
+ 		 * buffer but don't write past the end of the register buffer.
+ 		 */
+ 		while (reg <= last_reg && bufp < buf_end) {
+ 			*bufp++ = t4_read_reg(adap, reg);
+ 			reg += sizeof(u32);
+ 		}
+ 	}
+ }
+ 
++>>>>>>> b26127227677 (cxgb4/cxgb4vf: function and argument name cleanup)
  #define EEPROM_STAT_ADDR   0x7bfc
  #define VPD_BASE           0x400
  #define VPD_BASE_OLD       0
@@@ -1275,6 -2045,186 +2123,189 @@@ out
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  *	t4_phy_fw_ver - return current PHY firmware version
+  *	@adap: the adapter
+  *	@phy_fw_ver: return value buffer for PHY firmware version
+  *
+  *	Returns the current version of external PHY firmware on the
+  *	adapter.
+  */
+ int t4_phy_fw_ver(struct adapter *adap, int *phy_fw_ver)
+ {
+ 	u32 param, val;
+ 	int ret;
+ 
+ 	param = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |
+ 		 FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_PHYFW) |
+ 		 FW_PARAMS_PARAM_Y_V(adap->params.portvec) |
+ 		 FW_PARAMS_PARAM_Z_V(FW_PARAMS_PARAM_DEV_PHYFW_VERSION));
+ 	ret = t4_query_params(adap, adap->mbox, adap->pf, 0, 1,
+ 			      &param, &val);
+ 	if (ret < 0)
+ 		return ret;
+ 	*phy_fw_ver = val;
+ 	return 0;
+ }
+ 
+ /**
+  *	t4_load_phy_fw - download port PHY firmware
+  *	@adap: the adapter
+  *	@win: the PCI-E Memory Window index to use for t4_memory_rw()
+  *	@win_lock: the lock to use to guard the memory copy
+  *	@phy_fw_version: function to check PHY firmware versions
+  *	@phy_fw_data: the PHY firmware image to write
+  *	@phy_fw_size: image size
+  *
+  *	Transfer the specified PHY firmware to the adapter.  If a non-NULL
+  *	@phy_fw_version is supplied, then it will be used to determine if
+  *	it's necessary to perform the transfer by comparing the version
+  *	of any existing adapter PHY firmware with that of the passed in
+  *	PHY firmware image.  If @win_lock is non-NULL then it will be used
+  *	around the call to t4_memory_rw() which transfers the PHY firmware
+  *	to the adapter.
+  *
+  *	A negative error number will be returned if an error occurs.  If
+  *	version number support is available and there's no need to upgrade
+  *	the firmware, 0 will be returned.  If firmware is successfully
+  *	transferred to the adapter, 1 will be retured.
+  *
+  *	NOTE: some adapters only have local RAM to store the PHY firmware.  As
+  *	a result, a RESET of the adapter would cause that RAM to lose its
+  *	contents.  Thus, loading PHY firmware on such adapters must happen
+  *	after any FW_RESET_CMDs ...
+  */
+ int t4_load_phy_fw(struct adapter *adap,
+ 		   int win, spinlock_t *win_lock,
+ 		   int (*phy_fw_version)(const u8 *, size_t),
+ 		   const u8 *phy_fw_data, size_t phy_fw_size)
+ {
+ 	unsigned long mtype = 0, maddr = 0;
+ 	u32 param, val;
+ 	int cur_phy_fw_ver = 0, new_phy_fw_vers = 0;
+ 	int ret;
+ 
+ 	/* If we have version number support, then check to see if the adapter
+ 	 * already has up-to-date PHY firmware loaded.
+ 	 */
+ 	 if (phy_fw_version) {
+ 		new_phy_fw_vers = phy_fw_version(phy_fw_data, phy_fw_size);
+ 		ret = t4_phy_fw_ver(adap, &cur_phy_fw_ver);
+ 		if (ret < 0)
+ 			return ret;
+ 
+ 		if (cur_phy_fw_ver >= new_phy_fw_vers) {
+ 			CH_WARN(adap, "PHY Firmware already up-to-date, "
+ 				"version %#x\n", cur_phy_fw_ver);
+ 			return 0;
+ 		}
+ 	}
+ 
+ 	/* Ask the firmware where it wants us to copy the PHY firmware image.
+ 	 * The size of the file requires a special version of the READ coommand
+ 	 * which will pass the file size via the values field in PARAMS_CMD and
+ 	 * retrieve the return value from firmware and place it in the same
+ 	 * buffer values
+ 	 */
+ 	param = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |
+ 		 FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_PHYFW) |
+ 		 FW_PARAMS_PARAM_Y_V(adap->params.portvec) |
+ 		 FW_PARAMS_PARAM_Z_V(FW_PARAMS_PARAM_DEV_PHYFW_DOWNLOAD));
+ 	val = phy_fw_size;
+ 	ret = t4_query_params_rw(adap, adap->mbox, adap->pf, 0, 1,
+ 				 &param, &val, 1);
+ 	if (ret < 0)
+ 		return ret;
+ 	mtype = val >> 8;
+ 	maddr = (val & 0xff) << 16;
+ 
+ 	/* Copy the supplied PHY Firmware image to the adapter memory location
+ 	 * allocated by the adapter firmware.
+ 	 */
+ 	if (win_lock)
+ 		spin_lock_bh(win_lock);
+ 	ret = t4_memory_rw(adap, win, mtype, maddr,
+ 			   phy_fw_size, (__be32 *)phy_fw_data,
+ 			   T4_MEMORY_WRITE);
+ 	if (win_lock)
+ 		spin_unlock_bh(win_lock);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* Tell the firmware that the PHY firmware image has been written to
+ 	 * RAM and it can now start copying it over to the PHYs.  The chip
+ 	 * firmware will RESET the affected PHYs as part of this operation
+ 	 * leaving them running the new PHY firmware image.
+ 	 */
+ 	param = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |
+ 		 FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_PHYFW) |
+ 		 FW_PARAMS_PARAM_Y_V(adap->params.portvec) |
+ 		 FW_PARAMS_PARAM_Z_V(FW_PARAMS_PARAM_DEV_PHYFW_DOWNLOAD));
+ 	ret = t4_set_params_timeout(adap, adap->mbox, adap->pf, 0, 1,
+ 				    &param, &val, 30000);
+ 
+ 	/* If we have version number support, then check to see that the new
+ 	 * firmware got loaded properly.
+ 	 */
+ 	if (phy_fw_version) {
+ 		ret = t4_phy_fw_ver(adap, &cur_phy_fw_ver);
+ 		if (ret < 0)
+ 			return ret;
+ 
+ 		if (cur_phy_fw_ver != new_phy_fw_vers) {
+ 			CH_WARN(adap, "PHY Firmware did not update: "
+ 				"version on adapter %#x, "
+ 				"version flashed %#x\n",
+ 				cur_phy_fw_ver, new_phy_fw_vers);
+ 			return -ENXIO;
+ 		}
+ 	}
+ 
+ 	return 1;
+ }
+ 
+ /**
+  *	t4_fwcache - firmware cache operation
+  *	@adap: the adapter
+  *	@op  : the operation (flush or flush and invalidate)
+  */
+ int t4_fwcache(struct adapter *adap, enum fw_params_param_dev_fwcache op)
+ {
+ 	struct fw_params_cmd c;
+ 
+ 	memset(&c, 0, sizeof(c));
+ 	c.op_to_vfn =
+ 		cpu_to_be32(FW_CMD_OP_V(FW_PARAMS_CMD) |
+ 			    FW_CMD_REQUEST_F | FW_CMD_WRITE_F |
+ 			    FW_PARAMS_CMD_PFN_V(adap->pf) |
+ 			    FW_PARAMS_CMD_VFN_V(0));
+ 	c.retval_len16 = cpu_to_be32(FW_LEN16(c));
+ 	c.param[0].mnem =
+ 		cpu_to_be32(FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |
+ 			    FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_FWCACHE));
+ 	c.param[0].val = (__force __be32)op;
+ 
+ 	return t4_wr_mbox(adap, adap->mbox, &c, sizeof(c), NULL);
+ }
+ 
+ void t4_ulprx_read_la(struct adapter *adap, u32 *la_buf)
+ {
+ 	unsigned int i, j;
+ 
+ 	for (i = 0; i < 8; i++) {
+ 		u32 *p = la_buf + i;
+ 
+ 		t4_write_reg(adap, ULP_RX_LA_CTL_A, i);
+ 		j = t4_read_reg(adap, ULP_RX_LA_WRPTR_A);
+ 		t4_write_reg(adap, ULP_RX_LA_RDPTR_A, j);
+ 		for (j = 0; j < ULPRX_LA_SIZE; j++, p += 8)
+ 			*p = t4_read_reg(adap, ULP_RX_LA_RDDATA_A);
+ 	}
+ }
+ 
++>>>>>>> b26127227677 (cxgb4/cxgb4vf: function and argument name cleanup)
  #define ADVERT_MASK (FW_PORT_CAP_SPEED_100M | FW_PORT_CAP_SPEED_1G |\
  		     FW_PORT_CAP_SPEED_10G | FW_PORT_CAP_SPEED_40G | \
  		     FW_PORT_CAP_ANEG)
@@@ -4111,19 -5455,19 +5142,27 @@@ int t4_init_sge_params(struct adapter *
  
  	/* Extract the SGE Page Size for our PF.
  	 */
 -	hps = t4_read_reg(adapter, SGE_HOST_PAGE_SIZE_A);
 +	hps = t4_read_reg(adapter, SGE_HOST_PAGE_SIZE);
  	s_hps = (HOSTPAGESIZEPF0_S +
- 		 (HOSTPAGESIZEPF1_S - HOSTPAGESIZEPF0_S) * adapter->fn);
+ 		 (HOSTPAGESIZEPF1_S - HOSTPAGESIZEPF0_S) * adapter->pf);
  	sge_params->hps = ((hps >> s_hps) & HOSTPAGESIZEPF0_M);
  
  	/* Extract the SGE Egress and Ingess Queues Per Page for our PF.
  	 */
  	s_qpp = (QUEUESPERPAGEPF0_S +
++<<<<<<< HEAD
 +		(QUEUESPERPAGEPF1_S - QUEUESPERPAGEPF0_S) * adapter->fn);
 +	qpp = t4_read_reg(adapter, SGE_EGRESS_QUEUES_PER_PAGE_PF);
 +	sge_params->eq_qpp = ((qpp >> s_qpp) & QUEUESPERPAGEPF0_MASK);
 +	qpp = t4_read_reg(adapter, SGE_INGRESS_QUEUES_PER_PAGE_PF);
 +	sge_params->iq_qpp = ((qpp >> s_qpp) & QUEUESPERPAGEPF0_MASK);
++=======
+ 		(QUEUESPERPAGEPF1_S - QUEUESPERPAGEPF0_S) * adapter->pf);
+ 	qpp = t4_read_reg(adapter, SGE_EGRESS_QUEUES_PER_PAGE_PF_A);
+ 	sge_params->eq_qpp = ((qpp >> s_qpp) & QUEUESPERPAGEPF0_M);
+ 	qpp = t4_read_reg(adapter, SGE_INGRESS_QUEUES_PER_PAGE_PF_A);
+ 	sge_params->iq_qpp = ((qpp >> s_qpp) & QUEUESPERPAGEPF0_M);
++>>>>>>> b26127227677 (cxgb4/cxgb4vf: function and argument name cleanup)
  
  	return 0;
  }
diff --cc drivers/net/ethernet/chelsio/cxgb4vf/sge.c
index 8c552f8bc3c3,be4ab09d11d7..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4vf/sge.c
+++ b/drivers/net/ethernet/chelsio/cxgb4vf/sge.c
@@@ -2035,6 -2142,35 +2035,38 @@@ static void sge_tx_timer_cb(unsigned lo
  }
  
  /**
++<<<<<<< HEAD
++=======
+  *	bar2_address - return the BAR2 address for an SGE Queue's Registers
+  *	@adapter: the adapter
+  *	@qid: the SGE Queue ID
+  *	@qtype: the SGE Queue Type (Egress or Ingress)
+  *	@pbar2_qid: BAR2 Queue ID or 0 for Queue ID inferred SGE Queues
+  *
+  *	Returns the BAR2 address for the SGE Queue Registers associated with
+  *	@qid.  If BAR2 SGE Registers aren't available, returns NULL.  Also
+  *	returns the BAR2 Queue ID to be used with writes to the BAR2 SGE
+  *	Queue Registers.  If the BAR2 Queue ID is 0, then "Inferred Queue ID"
+  *	Registers are supported (e.g. the Write Combining Doorbell Buffer).
+  */
+ static void __iomem *bar2_address(struct adapter *adapter,
+ 				  unsigned int qid,
+ 				  enum t4_bar2_qtype qtype,
+ 				  unsigned int *pbar2_qid)
+ {
+ 	u64 bar2_qoffset;
+ 	int ret;
+ 
+ 	ret = t4vf_bar2_sge_qregs(adapter, qid, qtype,
+ 				  &bar2_qoffset, pbar2_qid);
+ 	if (ret)
+ 		return NULL;
+ 
+ 	return adapter->bar2 + bar2_qoffset;
+ }
+ 
+ /**
++>>>>>>> b26127227677 (cxgb4/cxgb4vf: function and argument name cleanup)
   *	t4vf_sge_alloc_rxq - allocate an SGE RX Queue
   *	@adapter: the adapter
   *	@rspq: pointer to to the new rxq's Response Queue to be filled in
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_ethtool.c
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
index dddf17cba9bf..3de209722030 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
@@ -621,7 +621,7 @@ struct adapter {
 	struct pci_dev *pdev;
 	struct device *pdev_dev;
 	unsigned int mbox;
-	unsigned int fn;
+	unsigned int pf;
 	unsigned int flags;
 	enum chip_type chip;
 
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_ethtool.c
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/sge.c
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
* Unmerged path drivers/net/ethernet/chelsio/cxgb4vf/sge.c
diff --git a/drivers/net/ethernet/chelsio/cxgb4vf/t4vf_common.h b/drivers/net/ethernet/chelsio/cxgb4vf/t4vf_common.h
index ab20ef94e14d..a8cebab3790e 100644
--- a/drivers/net/ethernet/chelsio/cxgb4vf/t4vf_common.h
+++ b/drivers/net/ethernet/chelsio/cxgb4vf/t4vf_common.h
@@ -284,11 +284,11 @@ int t4vf_fw_reset(struct adapter *);
 int t4vf_set_params(struct adapter *, unsigned int, const u32 *, const u32 *);
 
 enum t4_bar2_qtype { T4_BAR2_QTYPE_EGRESS, T4_BAR2_QTYPE_INGRESS };
-int t4_bar2_sge_qregs(struct adapter *adapter,
-		      unsigned int qid,
-		      enum t4_bar2_qtype qtype,
-		      u64 *pbar2_qoffset,
-		      unsigned int *pbar2_qid);
+int t4vf_bar2_sge_qregs(struct adapter *adapter,
+			unsigned int qid,
+			enum t4_bar2_qtype qtype,
+			u64 *pbar2_qoffset,
+			unsigned int *pbar2_qid);
 
 int t4vf_get_sge_params(struct adapter *);
 int t4vf_get_vpd_params(struct adapter *);
diff --git a/drivers/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c b/drivers/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c
index 871625f6cdbf..a2ef39127bed 100644
--- a/drivers/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c
+++ b/drivers/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c
@@ -430,7 +430,7 @@ int t4vf_set_params(struct adapter *adapter, unsigned int nparams,
 }
 
 /**
- *	t4_bar2_sge_qregs - return BAR2 SGE Queue register information
+ *	t4vf_bar2_sge_qregs - return BAR2 SGE Queue register information
  *	@adapter: the adapter
  *	@qid: the Queue ID
  *	@qtype: the Ingress or Egress type for @qid
@@ -454,11 +454,11 @@ int t4vf_set_params(struct adapter *adapter, unsigned int nparams,
  *	Write Combining Doorbell Buffer. If the BAR2 Queue ID is not 0,
  *	then these "Inferred Queue ID" register may not be used.
  */
-int t4_bar2_sge_qregs(struct adapter *adapter,
-		      unsigned int qid,
-		      enum t4_bar2_qtype qtype,
-		      u64 *pbar2_qoffset,
-		      unsigned int *pbar2_qid)
+int t4vf_bar2_sge_qregs(struct adapter *adapter,
+			unsigned int qid,
+			enum t4_bar2_qtype qtype,
+			u64 *pbar2_qoffset,
+			unsigned int *pbar2_qid)
 {
 	unsigned int page_shift, page_size, qpp_shift, qpp_mask;
 	u64 bar2_page_offset, bar2_qoffset;
