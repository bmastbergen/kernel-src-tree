net: Add vxlan_gso_check() helper

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] vxlan: Add vxlan_gso_check() helper (Marcelo Leitner) [1206570]
Rebuild_FUZZ: 91.18%
commit-author Joe Stringer <joestringer@nicira.com>
commit 23e62de33d179e229e4c1dfd93f90a3c7355c519
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/23e62de3.failed

Most NICs that report NETIF_F_GSO_UDP_TUNNEL support VXLAN, and not
other UDP-based encapsulation protocols where the format and size of the
header differs. This patch implements a generic ndo_gso_check() for
VXLAN which will only advertise GSO support when the skb looks like it
contains VXLAN (or no UDP tunnelling at all).

Implementation shamelessly stolen from Tom Herbert:
http://thread.gmane.org/gmane.linux.network/332428/focus=333111

	Signed-off-by: Joe Stringer <joestringer@nicira.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 23e62de33d179e229e4c1dfd93f90a3c7355c519)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index 4d5ed907f617,6b658638b456..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1570,15 -1571,21 +1570,30 @@@ static bool route_shortcircuit(struct n
  	return false;
  }
  
++<<<<<<< HEAD
 +static inline struct sk_buff *vxlan_handle_offloads(struct sk_buff *skb,
 +						    bool udp_csum)
 +{
 +	int type = udp_csum ? SKB_GSO_UDP_TUNNEL_CSUM : SKB_GSO_UDP_TUNNEL;
 +	return iptunnel_handle_offloads(skb, udp_csum, type);
 +}
++=======
+ bool vxlan_gso_check(struct sk_buff *skb)
+ {
+ 	if ((skb_shinfo(skb)->gso_type & SKB_GSO_UDP_TUNNEL) &&
+ 	    (skb->inner_protocol_type != ENCAP_TYPE_ETHER ||
+ 	     skb->inner_protocol != htons(ETH_P_TEB) ||
+ 	     (skb_inner_mac_header(skb) - skb_transport_header(skb) !=
+ 	      sizeof(struct udphdr) + sizeof(struct vxlanhdr))))
+ 		return false;
+ 
+ 	return true;
+ }
+ EXPORT_SYMBOL_GPL(vxlan_gso_check);
++>>>>>>> 23e62de33d17 (net: Add vxlan_gso_check() helper)
  
  #if IS_ENABLED(CONFIG_IPV6)
 -static int vxlan6_xmit_skb(struct vxlan_sock *vs,
 +static int vxlan6_xmit_skb(struct net *net, struct vxlan_sock *vs,
  			   struct dst_entry *dst, struct sk_buff *skb,
  			   struct net_device *dev, struct in6_addr *saddr,
  			   struct in6_addr *daddr, __u8 prio, __u8 ttl,
* Unmerged path drivers/net/vxlan.c
diff --git a/include/net/vxlan.h b/include/net/vxlan.h
index 1ddc74769f81..227dc4f01ee9 100644
--- a/include/net/vxlan.h
+++ b/include/net/vxlan.h
@@ -45,6 +45,8 @@ int vxlan_xmit_skb(struct net *net, struct vxlan_sock *vs,
 		   __be32 src, __be32 dst, __u8 tos, __u8 ttl, __be16 df,
 		   __be16 src_port, __be16 dst_port, __be32 vni);
 
+bool vxlan_gso_check(struct sk_buff *skb);
+
 /* IP header + UDP + VXLAN + Ethernet header */
 #define VXLAN_HEADROOM (20 + 8 + 8 + 14)
 /* IPv6 header + UDP + VXLAN + Ethernet header */
