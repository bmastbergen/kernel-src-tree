rtnetlink: put "BOND" into nl attribute names which are related to bonding

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Jiri Pirko <jiri@resnulli.us>
commit df7dbcbbafc0b8f3fb31a40c6f3c4a7e15cb0b40
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/df7dbcbb.failed

	Signed-off-by: Jiri Pirko <jiri@resnulli.us>
	Acked-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit df7dbcbbafc0b8f3fb31a40c6f3c4a7e15cb0b40)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_netlink.c
#	include/uapi/linux/if_link.h
#	net/core/rtnetlink.c
diff --cc drivers/net/bonding/bond_netlink.c
index 40e7b1cb4aea,549eb8702ebb..000000000000
--- a/drivers/net/bonding/bond_netlink.c
+++ b/drivers/net/bonding/bond_netlink.c
@@@ -20,6 -21,42 +20,45 @@@
  #include <net/rtnetlink.h>
  #include "bonding.h"
  
++<<<<<<< HEAD
++=======
+ int bond_get_slave(struct net_device *slave_dev, struct sk_buff *skb)
+ {
+ 	struct slave *slave = bond_slave_get_rtnl(slave_dev);
+ 	const struct aggregator *agg;
+ 
+ 	if (nla_put_u8(skb, IFLA_BOND_SLAVE_STATE, bond_slave_state(slave)))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u8(skb, IFLA_BOND_SLAVE_MII_STATUS, slave->link))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u32(skb, IFLA_BOND_SLAVE_LINK_FAILURE_COUNT,
+ 			slave->link_failure_count))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put(skb, IFLA_BOND_SLAVE_PERM_HWADDR,
+ 		    slave_dev->addr_len, slave->perm_hwaddr))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u16(skb, IFLA_BOND_SLAVE_QUEUE_ID, slave->queue_id))
+ 		goto nla_put_failure;
+ 
+ 	if (slave->bond->params.mode == BOND_MODE_8023AD) {
+ 		agg = SLAVE_AD_INFO(slave).port.aggregator;
+ 		if (agg)
+ 			if (nla_put_u16(skb, IFLA_BOND_SLAVE_AD_AGGREGATOR_ID,
+ 					agg->aggregator_identifier))
+ 				goto nla_put_failure;
+ 	}
+ 
+ 	return 0;
+ 
+ nla_put_failure:
+ 	return -EMSGSIZE;
+ }
+ 
++>>>>>>> df7dbcbbafc0 (rtnetlink: put "BOND" into nl attribute names which are related to bonding)
  static const struct nla_policy bond_policy[IFLA_BOND_MAX + 1] = {
  	[IFLA_BOND_MODE]		= { .type = NLA_U8 },
  	[IFLA_BOND_ACTIVE_SLAVE]	= { .type = NLA_U32 },
diff --cc include/uapi/linux/if_link.h
index 4efe6bcb6e67,1f30b85ebf9d..000000000000
--- a/include/uapi/linux/if_link.h
+++ b/include/uapi/linux/if_link.h
@@@ -144,6 -144,7 +144,10 @@@ enum 
  	IFLA_NUM_RX_QUEUES,
  	IFLA_CARRIER,
  	IFLA_PHYS_PORT_ID,
++<<<<<<< HEAD
++=======
+ 	IFLA_BOND_SLAVE,
++>>>>>>> df7dbcbbafc0 (rtnetlink: put "BOND" into nl attribute names which are related to bonding)
  	__IFLA_MAX
  };
  
@@@ -345,6 -358,30 +349,33 @@@ enum 
  
  #define IFLA_BOND_MAX	(__IFLA_BOND_MAX - 1)
  
++<<<<<<< HEAD
++=======
+ enum {
+ 	IFLA_BOND_AD_INFO_AGGREGATOR,
+ 	IFLA_BOND_AD_INFO_NUM_PORTS,
+ 	IFLA_BOND_AD_INFO_ACTOR_KEY,
+ 	IFLA_BOND_AD_INFO_PARTNER_KEY,
+ 	IFLA_BOND_AD_INFO_PARTNER_MAC,
+ 	__IFLA_BOND_AD_INFO_MAX,
+ };
+ 
+ #define IFLA_BOND_AD_INFO_MAX	(__IFLA_BOND_AD_INFO_MAX - 1)
+ 
+ enum {
+ 	IFLA_BOND_SLAVE_UNSPEC,
+ 	IFLA_BOND_SLAVE_STATE,
+ 	IFLA_BOND_SLAVE_MII_STATUS,
+ 	IFLA_BOND_SLAVE_LINK_FAILURE_COUNT,
+ 	IFLA_BOND_SLAVE_PERM_HWADDR,
+ 	IFLA_BOND_SLAVE_QUEUE_ID,
+ 	IFLA_BOND_SLAVE_AD_AGGREGATOR_ID,
+ 	__IFLA_BOND_SLAVE_MAX,
+ };
+ 
+ #define IFLA_BOND_SLAVE_MAX	(__IFLA_BOND_SLAVE_MAX - 1)
+ 
++>>>>>>> df7dbcbbafc0 (rtnetlink: put "BOND" into nl attribute names which are related to bonding)
  /* SR-IOV virtual function management section */
  
  enum {
diff --cc net/core/rtnetlink.c
index 46e91a591c6a,cace14962234..000000000000
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@@ -778,6 -721,28 +778,31 @@@ static size_t rtnl_port_size(const stru
  		return port_self_size;
  }
  
++<<<<<<< HEAD
++=======
+ static size_t rtnl_bond_slave_size(const struct net_device *dev)
+ {
+ 	struct net_device *bond;
+ 	size_t slave_size =
+ 		nla_total_size(sizeof(struct nlattr)) +	/* IFLA_BOND_SLAVE */
+ 		nla_total_size(1) +	/* IFLA_BOND_SLAVE_STATE */
+ 		nla_total_size(1) +	/* IFLA_BOND_SLAVE_MII_STATUS */
+ 		nla_total_size(4) +	/* IFLA_BOND_SLAVE_LINK_FAILURE_COUNT */
+ 		nla_total_size(MAX_ADDR_LEN) +	/* IFLA_BOND_SLAVE_PERM_HWADDR */
+ 		nla_total_size(2) +	/* IFLA_BOND_SLAVE_QUEUE_ID */
+ 		nla_total_size(2) +	/* IFLA_BOND_SLAVE_AD_AGGREGATOR_ID */
+ 		0;
+ 
+ 	if (netif_is_bond_slave((struct net_device *)dev)) {
+ 		bond = netdev_master_upper_dev_get((struct net_device *)dev);
+ 		if (bond && bond->netdev_ops->ndo_get_slave)
+ 			return slave_size;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> df7dbcbbafc0 (rtnetlink: put "BOND" into nl attribute names which are related to bonding)
  static noinline size_t if_nlmsg_size(const struct net_device *dev,
  				     u32 ext_filter_mask)
  {
@@@ -906,6 -870,34 +931,37 @@@ static int rtnl_phys_port_id_fill(struc
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static size_t rtnl_bond_slave_fill(struct sk_buff *skb, struct net_device *dev)
+ {
+ 	struct net_device *bond;
+ 	struct nlattr *nest;
+ 	int err;
+ 
+ 	if (!netif_is_bond_slave(dev))
+ 		return 0;
+ 
+ 	bond = netdev_master_upper_dev_get(dev);
+ 	if (!bond || !bond->netdev_ops->ndo_get_slave)
+ 		return 0;
+ 
+ 	nest = nla_nest_start(skb, IFLA_BOND_SLAVE);
+ 	if (!nest)
+ 		return -EMSGSIZE;
+ 
+ 	err = bond->netdev_ops->ndo_get_slave(dev, skb);
+ 	if (err) {
+ 		nla_nest_cancel(skb, nest);
+ 		return (err == -EMSGSIZE) ? err : 0;
+ 	}
+ 
+ 	nla_nest_end(skb, nest);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> df7dbcbbafc0 (rtnetlink: put "BOND" into nl attribute names which are related to bonding)
  static int rtnl_fill_ifinfo(struct sk_buff *skb, struct net_device *dev,
  			    int type, u32 pid, u32 seq, u32 change,
  			    unsigned int flags, u32 ext_filter_mask)
* Unmerged path drivers/net/bonding/bond_netlink.c
* Unmerged path include/uapi/linux/if_link.h
* Unmerged path net/core/rtnetlink.c
