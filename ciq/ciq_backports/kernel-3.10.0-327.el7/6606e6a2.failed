IB/iser: Fix memory regions possible leak

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [infiniband] iser: Fix memory regions possible leak (Amir Vadai) [1164539]
Rebuild_FUZZ: 96.20%
commit-author Sagi Grimberg <sagig@mellanox.com>
commit 6606e6a2ff2710b473838b291dc533cd8fc1471f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/6606e6a2.failed

When teardown process starts during live IO, we need to keep the
memory regions pool (frmr/fmr) until all in-flight tasks are properly
released, since each task may return a memory region to the pool. In
order to do this, we pass a destroy flag to iser_free_ib_conn_res to
indicate we can destroy the device and the memory regions
pool. iser_conn_release will pass it as true and also DEVICE_REMOVAL
event (we need to let the device to properly remove).

Also, Since we conditionally call iser_free_rx_descriptors,
remove the extra check on iser_conn->rx_descs.

Fixes: 5426b1711fd0 ("IB/iser: Collapse cleanup and disconnect handlers")
	Reported-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Roland Dreier <roland@purestorage.com>
(cherry picked from commit 6606e6a2ff2710b473838b291dc533cd8fc1471f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/iser/iser_initiator.c
#	drivers/infiniband/ulp/iser/iser_verbs.c
diff --cc drivers/infiniband/ulp/iser/iser_initiator.c
index 8d44a4060634,20e859a6f1a6..000000000000
--- a/drivers/infiniband/ulp/iser/iser_initiator.c
+++ b/drivers/infiniband/ulp/iser/iser_initiator.c
@@@ -312,24 -317,21 +312,31 @@@ void iser_free_rx_descriptors(struct is
  {
  	int i;
  	struct iser_rx_desc *rx_desc;
 -	struct ib_conn *ib_conn = &iser_conn->ib_conn;
  	struct iser_device *device = ib_conn->device;
  
++<<<<<<< HEAD
 +	if (!ib_conn->rx_descs)
 +		goto free_login_buf;
 +
++=======
++>>>>>>> 6606e6a2ff27 (IB/iser: Fix memory regions possible leak)
  	if (device->iser_free_rdma_reg_res)
  		device->iser_free_rdma_reg_res(ib_conn);
  
 -	rx_desc = iser_conn->rx_descs;
 -	for (i = 0; i < iser_conn->qp_max_recv_dtos; i++, rx_desc++)
 +	rx_desc = ib_conn->rx_descs;
 +	for (i = 0; i < ib_conn->qp_max_recv_dtos; i++, rx_desc++)
  		ib_dma_unmap_single(device->ib_device, rx_desc->dma_addr,
  				    ISER_RX_PAYLOAD_SIZE, DMA_FROM_DEVICE);
 -	kfree(iser_conn->rx_descs);
 +	kfree(ib_conn->rx_descs);
  	/* make sure we never redo any unmapping */
 -	iser_conn->rx_descs = NULL;
 +	ib_conn->rx_descs = NULL;
  
++<<<<<<< HEAD
 +free_login_buf:
 +	iser_free_login_buf(ib_conn);
++=======
+ 	iser_free_login_buf(iser_conn);
++>>>>>>> 6606e6a2ff27 (IB/iser: Fix memory regions possible leak)
  }
  
  static int iser_post_rx_bufs(struct iscsi_conn *conn, struct iscsi_hdr *req)
diff --cc drivers/infiniband/ulp/iser/iser_verbs.c
index 4cafd44ad193,f3e21abc20a6..000000000000
--- a/drivers/infiniband/ulp/iser/iser_verbs.c
+++ b/drivers/infiniband/ulp/iser/iser_verbs.c
@@@ -595,26 -581,57 +595,64 @@@ static int iser_conn_state_comp_exch(st
  
  void iser_release_work(struct work_struct *work)
  {
 -	struct iser_conn *iser_conn;
 +	struct iser_conn *ib_conn;
 +	int rc;
  
 -	iser_conn = container_of(work, struct iser_conn, release_work);
 +	ib_conn = container_of(work, struct iser_conn, release_work);
  
 -	/* Wait for conn_stop to complete */
 -	wait_for_completion(&iser_conn->stop_completion);
 -	/* Wait for IB resouces cleanup to complete */
 -	wait_for_completion(&iser_conn->ib_completion);
 +	/* wait for .conn_stop callback */
 +	rc = wait_for_completion_timeout(&ib_conn->stop_completion, 30 * HZ);
 +	WARN_ON(rc == 0);
  
 -	mutex_lock(&iser_conn->state_mutex);
 -	iser_conn->state = ISER_CONN_DOWN;
 -	mutex_unlock(&iser_conn->state_mutex);
 +	/* wait for the qp`s post send and post receive buffers to empty */
 +	rc = wait_for_completion_timeout(&ib_conn->flush_completion, 30 * HZ);
 +	WARN_ON(rc == 0);
  
 -	iser_conn_release(iser_conn);
 -}
 +	ib_conn->state = ISER_CONN_DOWN;
  
++<<<<<<< HEAD
 +	mutex_lock(&ib_conn->state_mutex);
 +	ib_conn->state = ISER_CONN_DOWN;
 +	mutex_unlock(&ib_conn->state_mutex);
 +
 +	iser_conn_release(ib_conn);
++=======
+ /**
+  * iser_free_ib_conn_res - release IB related resources
+  * @iser_conn: iser connection struct
+  * @destroy: indicator if we need to try to release the
+  *     iser device and memory regoins pool (only iscsi
+  *     shutdown and DEVICE_REMOVAL will use this).
+  *
+  * This routine is called with the iser state mutex held
+  * so the cm_id removal is out of here. It is Safe to
+  * be invoked multiple times.
+  */
+ static void iser_free_ib_conn_res(struct iser_conn *iser_conn,
+ 				  bool destroy)
+ {
+ 	struct ib_conn *ib_conn = &iser_conn->ib_conn;
+ 	struct iser_device *device = ib_conn->device;
+ 
+ 	iser_info("freeing conn %p cma_id %p qp %p\n",
+ 		  iser_conn, ib_conn->cma_id, ib_conn->qp);
+ 
+ 	if (ib_conn->qp != NULL) {
+ 		ib_conn->comp->active_qps--;
+ 		rdma_destroy_qp(ib_conn->cma_id);
+ 		ib_conn->qp = NULL;
+ 	}
+ 
+ 	if (destroy) {
+ 		if (iser_conn->rx_descs)
+ 			iser_free_rx_descriptors(iser_conn);
+ 
+ 		if (device != NULL) {
+ 			iser_device_try_release(device);
+ 			ib_conn->device = NULL;
+ 		}
+ 	}
++>>>>>>> 6606e6a2ff27 (IB/iser: Fix memory regions possible leak)
  }
  
  /**
@@@ -796,16 -840,22 +834,33 @@@ static void iser_disconnected_handler(s
  		else
  			iser_err("iscsi_iser connection isn't bound\n");
  	}
 -}
  
++<<<<<<< HEAD
 +	/* Complete the termination process if no posts are pending. This code
 +	 * block also exists in iser_handle_comp_error(), but it is needed here
 +	 * for cases of no flushes at all, e.g. discovery over rdma.
 +	 */
 +	if (ib_conn->post_recv_buf_count == 0 &&
 +	    (atomic_read(&ib_conn->post_send_buf_count) == 0)) {
 +		complete(&ib_conn->flush_completion);
 +	}
 +}
++=======
+ static void iser_cleanup_handler(struct rdma_cm_id *cma_id,
+ 				 bool destroy)
+ {
+ 	struct iser_conn *iser_conn = (struct iser_conn *)cma_id->context;
+ 
+ 	/*
+ 	 * We are not guaranteed that we visited disconnected_handler
+ 	 * by now, call it here to be safe that we handle CM drep
+ 	 * and flush errors.
+ 	 */
+ 	iser_disconnected_handler(cma_id);
+ 	iser_free_ib_conn_res(iser_conn, destroy);
+ 	complete(&iser_conn->ib_completion);
+ };
++>>>>>>> 6606e6a2ff27 (IB/iser: Fix memory regions possible leak)
  
  static int iser_cma_handler(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)
  {
* Unmerged path drivers/infiniband/ulp/iser/iser_initiator.c
* Unmerged path drivers/infiniband/ulp/iser/iser_verbs.c
