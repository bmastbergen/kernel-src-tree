bonding: factor out slave id tx code and simplify xmit paths

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Nikolay Aleksandrov <razor@BlackWall.org>
commit 15077228cab68e5e8c3cbf26a7f6ebacfac4c829
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/15077228.failed

I factored out the tx xmit code which relies on slave id in
bond_xmit_slave_id. It is global because later it can be used also in
3ad mode xmit. Unnecessary obvious comments are removed. Active-backup
mode is simplified because bond_dev_queue_xmit always consumes the skb.
bond_xmit_xor becomes one line because of bond_xmit_slave_id.
bond_for_each_slave_from is not used in bond_xmit_slave_id because later
when RCU is used we can avoid important race condition by using standard
rculist routines.

	Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 15077228cab68e5e8c3cbf26a7f6ebacfac4c829)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
diff --cc drivers/net/bonding/bond_main.c
index ef8213746e65,5eee95c3b172..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -3928,40 -3847,15 +3966,46 @@@ static int bond_xmit_roundrobin(struct 
  	 * send the join/membership reports.  The curr_active_slave found
  	 * will send all of this type of traffic.
  	 */
- 	if ((iph->protocol == IPPROTO_IGMP) &&
- 	    (skb->protocol == htons(ETH_P_IP))) {
+ 	if (iph->protocol == IPPROTO_IGMP && skb->protocol == htons(ETH_P_IP)) {
  		slave = bond->curr_active_slave;
- 		if (!slave)
- 			goto out;
+ 		if (slave && slave_can_tx(slave))
+ 			bond_dev_queue_xmit(bond, skb, slave->dev);
+ 		else
+ 			bond_xmit_slave_id(bond, skb, 0);
  	} else {
++<<<<<<< HEAD
 +		/*
 +		 * Concurrent TX may collide on rr_tx_counter; we accept
 +		 * that as being rare enough not to justify using an
 +		 * atomic op here.
 +		 */
 +		slave_no = bond->rr_tx_counter++ % bond->slave_cnt;
 +
 +		bond_for_each_slave(bond, slave, i) {
 +			slave_no--;
 +			if (slave_no < 0)
 +				break;
 +		}
 +	}
 +
 +	start_at = slave;
 +	bond_for_each_slave_from(bond, slave, i, start_at) {
 +		if (IS_UP(slave->dev) &&
 +		    (slave->link == BOND_LINK_UP) &&
 +		    bond_is_active_slave(slave)) {
 +			res = bond_dev_queue_xmit(bond, skb, slave->dev);
 +			break;
 +		}
 +	}
 +
 +out:
 +	if (res) {
 +		/* no suitable interface, frame not sent */
 +		kfree_skb(skb);
++=======
+ 		bond_xmit_slave_id(bond, skb,
+ 				   bond->rr_tx_counter++ % bond->slave_cnt);
++>>>>>>> 15077228cab6 (bonding: factor out slave id tx code and simplify xmit paths)
  	}
  
  	return NETDEV_TX_OK;
@@@ -3997,34 -3887,9 +4037,35 @@@ static int bond_xmit_activebackup(struc
  static int bond_xmit_xor(struct sk_buff *skb, struct net_device *bond_dev)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
- 	struct slave *slave, *start_at;
- 	int slave_no;
- 	int i;
- 	int res = 1;
  
++<<<<<<< HEAD
 +	slave_no = bond->xmit_hash_policy(skb, bond->slave_cnt);
 +
 +	bond_for_each_slave(bond, slave, i) {
 +		slave_no--;
 +		if (slave_no < 0)
 +			break;
 +	}
 +
 +	start_at = slave;
 +
 +	bond_for_each_slave_from(bond, slave, i, start_at) {
 +		if (IS_UP(slave->dev) &&
 +		    (slave->link == BOND_LINK_UP) &&
 +		    bond_is_active_slave(slave)) {
 +			res = bond_dev_queue_xmit(bond, skb, slave->dev);
 +			break;
 +		}
 +	}
 +
 +	if (res) {
 +		/* no suitable interface, frame not sent */
 +		kfree_skb(skb);
 +	}
++=======
+ 	bond_xmit_slave_id(bond, skb,
+ 			   bond->xmit_hash_policy(skb, bond->slave_cnt));
++>>>>>>> 15077228cab6 (bonding: factor out slave id tx code and simplify xmit paths)
  
  	return NETDEV_TX_OK;
  }
* Unmerged path drivers/net/bonding/bond_main.c
diff --git a/drivers/net/bonding/bonding.h b/drivers/net/bonding/bonding.h
index 4bb1446618e2..f01e127b53e9 100644
--- a/drivers/net/bonding/bonding.h
+++ b/drivers/net/bonding/bonding.h
@@ -417,10 +417,20 @@ static inline __be32 bond_confirm_addr(struct net_device *dev, __be32 dst, __be3
 	return addr;
 }
 
+static inline bool slave_can_tx(struct slave *slave)
+{
+	if (IS_UP(slave->dev) && slave->link == BOND_LINK_UP &&
+	    bond_is_active_slave(slave))
+		return true;
+	else
+		return false;
+}
+
 struct bond_net;
 
 struct vlan_entry *bond_next_vlan(struct bonding *bond, struct vlan_entry *curr);
 int bond_dev_queue_xmit(struct bonding *bond, struct sk_buff *skb, struct net_device *slave_dev);
+void bond_xmit_slave_id(struct bonding *bond, struct sk_buff *skb, int slave_id);
 int bond_create(struct net *net, const char *name);
 int bond_create_sysfs(struct bond_net *net);
 void bond_destroy_sysfs(struct bond_net *net);
