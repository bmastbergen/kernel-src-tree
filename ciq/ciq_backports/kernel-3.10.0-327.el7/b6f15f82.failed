fib_trie: Fix regression in handling of inflate/halve failure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Alexander Duyck <alexander.h.duyck@redhat.com>
commit b6f15f828d4b624a2e4306dabbbb20a581bece37
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/b6f15f82.failed

When I updated the code to address a possible null pointer dereference in
resize I ended up reverting an exception handling fix for the suffix length
in the event that inflate or halve failed.  This change is meant to correct
that by reverting the earlier fix and instead simply getting the parent
again after inflate has been completed to avoid the possible null pointer
issue.

Fixes: ddb4b9a13 ("fib_trie: Address possible NULL pointer dereference in resize")
	Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b6f15f828d4b624a2e4306dabbbb20a581bece37)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/fib_trie.c
diff --cc net/ipv4/fib_trie.c
index 8be89b1a8b93,2c7c299ee2b9..000000000000
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@@ -817,41 -831,47 +817,74 @@@ static void resize(struct trie *t, stru
  	 * nonempty nodes that are above the threshold.
  	 */
  	while (should_inflate(tp, tn) && max_work) {
++<<<<<<< HEAD
 +		if (inflate(t, tn)) {
++=======
+ 		tp = inflate(t, tn);
+ 		if (!tp) {
++>>>>>>> b6f15f828d4b (fib_trie: Fix regression in handling of inflate/halve failure)
  #ifdef CONFIG_IP_FIB_TRIE_STATS
 -			this_cpu_inc(stats->resize_node_skipped);
 +			this_cpu_inc(t->stats->resize_node_skipped);
  #endif
  			break;
  		}
  
  		max_work--;
++<<<<<<< HEAD
 +		tn = rtnl_dereference(*cptr);
++=======
+ 		tn = get_child(tp, cindex);
++>>>>>>> b6f15f828d4b (fib_trie: Fix regression in handling of inflate/halve failure)
  	}
  
+ 	/* update parent in case inflate failed */
+ 	tp = node_parent(tn);
+ 
  	/* Return if at least one inflate is run */
  	if (max_work != MAX_WORK)
++<<<<<<< HEAD
 +		return;
++=======
+ 		return tp;
++>>>>>>> b6f15f828d4b (fib_trie: Fix regression in handling of inflate/halve failure)
  
  	/* Halve as long as the number of empty children in this
  	 * node is above threshold.
  	 */
  	while (should_halve(tp, tn) && max_work) {
++<<<<<<< HEAD
 +		if (halve(t, tn)) {
++=======
+ 		tp = halve(t, tn);
+ 		if (!tp) {
++>>>>>>> b6f15f828d4b (fib_trie: Fix regression in handling of inflate/halve failure)
  #ifdef CONFIG_IP_FIB_TRIE_STATS
 -			this_cpu_inc(stats->resize_node_skipped);
 +			this_cpu_inc(t->stats->resize_node_skipped);
  #endif
  			break;
  		}
  
  		max_work--;
++<<<<<<< HEAD
 +		tn = rtnl_dereference(*cptr);
 +	}
 +
 +	/* Only one child remains */
 +	if (should_collapse(tn)) {
 +		collapse(t, tn);
 +		return;
 +	}
++=======
+ 		tn = get_child(tp, cindex);
+ 	}
+ 
+ 	/* Only one child remains */
+ 	if (should_collapse(tn))
+ 		return collapse(t, tn);
+ 
+ 	/* update parent in case halve failed */
+ 	tp = node_parent(tn);
++>>>>>>> b6f15f828d4b (fib_trie: Fix regression in handling of inflate/halve failure)
  
  	/* Return if at least one deflate was run */
  	if (max_work != MAX_WORK)
* Unmerged path net/ipv4/fib_trie.c
