bonding: fail_over_mac should only affect AB mode at enslave and removal processing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author dingtianhong <dingtianhong@huawei.com>
commit 00503b6f702eaf23e7257d6287da72805d7d014c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/00503b6f.failed

According to bonding.txt, the fail_over_ma should only affect active-backup mode,
but I found that the fail_over_mac could be set to active or follow in all
modes, this will cause new slave could not be set to bond's MAC address at
enslave processing and restore its own MAC address at removal processing.

The correct way to fix the problem is that we should not add restrictions when
setting options, just need to modify the bond enslave and removal processing
to check the mode in addition to fail_over_mac when setting a slave's MAC during
enslavement. The change active slave processing already only calls the fail_over_mac
function when in active-backup mode.

Thanks for Jay's suggestion.

The patch also modify the pr_warning() to pr_warn().

	Cc: Jay Vosburgh <fubar@us.ibm.com>
	Cc: Veaceslav Falico <vfalico@redhat.com>
	Cc: Andy Gospodarek <andy@greyhouse.net>
	Signed-off-by: Ding Tianhong <dingtianhong@huawei.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 00503b6f702eaf23e7257d6287da72805d7d014c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
diff --cc drivers/net/bonding/bond_main.c
index 102682489f45,8e6dd13b3607..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -1562,10 -1269,14 +1562,21 @@@ int bond_enslave(struct net_device *bon
  	}
  
  	if (slave_ops->ndo_set_mac_address == NULL) {
++<<<<<<< HEAD
 +		if (bond->slave_cnt == 0) {
 +			pr_warning("%s: Warning: The first slave device specified does not support setting the MAC address. Setting fail_over_mac to active.",
 +				   bond_dev->name);
 +			bond->params.fail_over_mac = BOND_FOM_ACTIVE;
++=======
+ 		if (!bond_has_slaves(bond)) {
+ 			pr_warn("%s: Warning: The first slave device specified does not support setting the MAC address.\n",
+ 				bond_dev->name);
+ 			if (bond->params.mode == BOND_MODE_ACTIVEBACKUP) {
+ 				bond->params.fail_over_mac = BOND_FOM_ACTIVE;
+ 				pr_warn("%s: Setting fail_over_mac to active for active-backup mode.\n",
+ 					bond_dev->name);
+ 			}
++>>>>>>> 00503b6f702e (bonding: fail_over_mac should only affect AB mode at enslave and removal processing)
  		} else if (bond->params.fail_over_mac != BOND_FOM_ACTIVE) {
  			pr_err("%s: Error: The slave device specified does not support setting the MAC address, but fail_over_mac is not set to active.\n",
  			       bond_dev->name);
@@@ -1988,8 -1678,15 +2001,20 @@@ static int __bond_release_one(struct ne
  
  	bond->current_arp_slave = NULL;
  
++<<<<<<< HEAD
 +	/* release the slave from its bond */
 +	bond_detach_slave(bond, slave);
++=======
+ 	if (!all && (!bond->params.fail_over_mac ||
+ 		     bond->params.mode != BOND_MODE_ACTIVEBACKUP)) {
+ 		if (ether_addr_equal_64bits(bond_dev->dev_addr, slave->perm_hwaddr) &&
+ 		    bond_has_slaves(bond))
+ 			pr_warn("%s: Warning: the permanent HWaddr of %s - %pM - is still in use by %s. Set the HWaddr of %s to a different address to avoid conflicts.\n",
+ 				   bond_dev->name, slave_dev->name,
+ 				   slave->perm_hwaddr,
+ 				   bond_dev->name, slave_dev->name);
+ 	}
++>>>>>>> 00503b6f702e (bonding: fail_over_mac should only affect AB mode at enslave and removal processing)
  
  	if (bond->primary_slave == slave)
  		bond->primary_slave = NULL;
* Unmerged path drivers/net/bonding/bond_main.c
