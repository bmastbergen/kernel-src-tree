KVM: x86: fix some sparse warnings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [kvm] x86: fix some sparse warnings (Bandan Das) [1209995]
Rebuild_FUZZ: 92.06%
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 48d89b92609a66bc41f479c560640bc413add3b4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/48d89b92.failed

Sparse reports the following easily fixed warnings:

   arch/x86/kvm/vmx.c:8795:48: sparse: Using plain integer as NULL pointer
   arch/x86/kvm/vmx.c:2138:5: sparse: symbol vmx_read_l1_tsc was not declared. Should it be static?
   arch/x86/kvm/vmx.c:6151:48: sparse: Using plain integer as NULL pointer
   arch/x86/kvm/vmx.c:8851:6: sparse: symbol vmx_sched_in was not declared. Should it be static?

   arch/x86/kvm/svm.c:2162:5: sparse: symbol svm_read_l1_tsc was not declared. Should it be static?

	Cc: Radim Krčmář <rkrcmar@redhat.com>
	Signed-off-by: Fengguang Wu <fengguang.wu@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 48d89b92609a66bc41f479c560640bc413add3b4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index ccfe5bb586e5,d70550d0bcff..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -6260,8 -6246,12 +6260,15 @@@ static void free_nested(struct vcpu_vm
  	/* Unpin physical memory we referred to in current vmcs02 */
  	if (vmx->nested.apic_access_page) {
  		nested_release_page(vmx->nested.apic_access_page);
- 		vmx->nested.apic_access_page = 0;
+ 		vmx->nested.apic_access_page = NULL;
  	}
++<<<<<<< HEAD
++=======
+ 	if (vmx->nested.virtual_apic_page) {
+ 		nested_release_page(vmx->nested.virtual_apic_page);
+ 		vmx->nested.virtual_apic_page = NULL;
+ 	}
++>>>>>>> 48d89b92609a (KVM: x86: fix some sparse warnings)
  
  	nested_free_all_saved_vmcss(vmx);
  }
@@@ -8944,14 -8950,12 +8951,21 @@@ static void nested_vmx_vmexit(struct kv
  	/* Unpin physical memory we referred to in vmcs02 */
  	if (vmx->nested.apic_access_page) {
  		nested_release_page(vmx->nested.apic_access_page);
- 		vmx->nested.apic_access_page = 0;
+ 		vmx->nested.apic_access_page = NULL;
  	}
++<<<<<<< HEAD
 +
 +	/*
 +	 * We are now running in L2, mmu_notifier will force to reload the
 +	 * page's hpa for L2 vmcs. Need to reload it for L1 before entering L1.
 +	 */
 +	kvm_vcpu_reload_apic_access_page(vcpu);
++=======
+ 	if (vmx->nested.virtual_apic_page) {
+ 		nested_release_page(vmx->nested.virtual_apic_page);
+ 		vmx->nested.virtual_apic_page = NULL;
+ 	}
++>>>>>>> 48d89b92609a (KVM: x86: fix some sparse warnings)
  
  	/*
  	 * Exiting from L2 to L1, we're now back to L1 which thinks it just
diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c
index 4a9be9dfca9d..14ec7b82fd76 100644
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@ -3032,7 +3032,7 @@ static int cr8_write_interception(struct vcpu_svm *svm)
 	return 0;
 }
 
-u64 svm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)
+static u64 svm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)
 {
 	struct vmcb *vmcb = get_host_vmcb(to_svm(vcpu));
 	return vmcb->control.tsc_offset +
* Unmerged path arch/x86/kvm/vmx.c
