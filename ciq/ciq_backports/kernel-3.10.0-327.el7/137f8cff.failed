mm/zpool: use prefixed module loading

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [mm] zpool: use prefixed module loading (Seth Jennings) [1141434]
Rebuild_FUZZ: 95.77%
commit-author Kees Cook <keescook@chromium.org>
commit 137f8cff505ace6251dc442c7aa973d60c801a79
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/137f8cff.failed

To avoid potential format string expansion via module parameters, do not
use the zpool type directly in request_module() without a format string.
Additionally, to avoid arbitrary modules being loaded via zpool API
(e.g.  via the zswap_zpool_type module parameter) add a "zpool-" prefix
to the requested module, as well as module aliases for the existing
zpool types (zbud and zsmalloc).

	Signed-off-by: Kees Cook <keescook@chromium.org>
	Cc: Seth Jennings <sjennings@variantweb.net>
	Cc: Minchan Kim <minchan@kernel.org>
	Cc: Nitin Gupta <ngupta@vflare.org>
	Acked-by: Dan Streetman <ddstreet@ieee.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 137f8cff505ace6251dc442c7aa973d60c801a79)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/zsmalloc/zsmalloc-main.c
#	mm/zbud.c
#	mm/zpool.c
diff --cc drivers/staging/zsmalloc/zsmalloc-main.c
index f7a7fbefbc2f,94f38fac5e81..000000000000
--- a/drivers/staging/zsmalloc/zsmalloc-main.c
+++ b/drivers/staging/zsmalloc/zsmalloc-main.c
@@@ -242,6 -241,82 +242,85 @@@ struct mapping_area 
  	enum zs_mapmode vm_mm; /* mapping mode */
  };
  
++<<<<<<< HEAD:drivers/staging/zsmalloc/zsmalloc-main.c
++=======
+ /* zpool driver */
+ 
+ #ifdef CONFIG_ZPOOL
+ 
+ static void *zs_zpool_create(gfp_t gfp, struct zpool_ops *zpool_ops)
+ {
+ 	return zs_create_pool(gfp);
+ }
+ 
+ static void zs_zpool_destroy(void *pool)
+ {
+ 	zs_destroy_pool(pool);
+ }
+ 
+ static int zs_zpool_malloc(void *pool, size_t size, gfp_t gfp,
+ 			unsigned long *handle)
+ {
+ 	*handle = zs_malloc(pool, size);
+ 	return *handle ? 0 : -1;
+ }
+ static void zs_zpool_free(void *pool, unsigned long handle)
+ {
+ 	zs_free(pool, handle);
+ }
+ 
+ static int zs_zpool_shrink(void *pool, unsigned int pages,
+ 			unsigned int *reclaimed)
+ {
+ 	return -EINVAL;
+ }
+ 
+ static void *zs_zpool_map(void *pool, unsigned long handle,
+ 			enum zpool_mapmode mm)
+ {
+ 	enum zs_mapmode zs_mm;
+ 
+ 	switch (mm) {
+ 	case ZPOOL_MM_RO:
+ 		zs_mm = ZS_MM_RO;
+ 		break;
+ 	case ZPOOL_MM_WO:
+ 		zs_mm = ZS_MM_WO;
+ 		break;
+ 	case ZPOOL_MM_RW: /* fallthru */
+ 	default:
+ 		zs_mm = ZS_MM_RW;
+ 		break;
+ 	}
+ 
+ 	return zs_map_object(pool, handle, zs_mm);
+ }
+ static void zs_zpool_unmap(void *pool, unsigned long handle)
+ {
+ 	zs_unmap_object(pool, handle);
+ }
+ 
+ static u64 zs_zpool_total_size(void *pool)
+ {
+ 	return zs_get_total_size_bytes(pool);
+ }
+ 
+ static struct zpool_driver zs_zpool_driver = {
+ 	.type =		"zsmalloc",
+ 	.owner =	THIS_MODULE,
+ 	.create =	zs_zpool_create,
+ 	.destroy =	zs_zpool_destroy,
+ 	.malloc =	zs_zpool_malloc,
+ 	.free =		zs_zpool_free,
+ 	.shrink =	zs_zpool_shrink,
+ 	.map =		zs_zpool_map,
+ 	.unmap =	zs_zpool_unmap,
+ 	.total_size =	zs_zpool_total_size,
+ };
+ 
+ MODULE_ALIAS("zpool-zsmalloc");
+ #endif /* CONFIG_ZPOOL */
++>>>>>>> 137f8cff505a (mm/zpool: use prefixed module loading):mm/zsmalloc.c
  
  /* per-cpu VM mapping areas for zspage accesses that cross page boundaries */
  static DEFINE_PER_CPU(struct mapping_area, zs_map_area);
diff --cc mm/zbud.c
index d01226117b8d,f26e7fcc7fa2..000000000000
--- a/mm/zbud.c
+++ b/mm/zbud.c
@@@ -113,6 -114,91 +113,94 @@@ struct zbud_header 
  };
  
  /*****************
++<<<<<<< HEAD
++=======
+  * zpool
+  ****************/
+ 
+ #ifdef CONFIG_ZPOOL
+ 
+ static int zbud_zpool_evict(struct zbud_pool *pool, unsigned long handle)
+ {
+ 	return zpool_evict(pool, handle);
+ }
+ 
+ static struct zbud_ops zbud_zpool_ops = {
+ 	.evict =	zbud_zpool_evict
+ };
+ 
+ static void *zbud_zpool_create(gfp_t gfp, struct zpool_ops *zpool_ops)
+ {
+ 	return zbud_create_pool(gfp, &zbud_zpool_ops);
+ }
+ 
+ static void zbud_zpool_destroy(void *pool)
+ {
+ 	zbud_destroy_pool(pool);
+ }
+ 
+ static int zbud_zpool_malloc(void *pool, size_t size, gfp_t gfp,
+ 			unsigned long *handle)
+ {
+ 	return zbud_alloc(pool, size, gfp, handle);
+ }
+ static void zbud_zpool_free(void *pool, unsigned long handle)
+ {
+ 	zbud_free(pool, handle);
+ }
+ 
+ static int zbud_zpool_shrink(void *pool, unsigned int pages,
+ 			unsigned int *reclaimed)
+ {
+ 	unsigned int total = 0;
+ 	int ret = -EINVAL;
+ 
+ 	while (total < pages) {
+ 		ret = zbud_reclaim_page(pool, 8);
+ 		if (ret < 0)
+ 			break;
+ 		total++;
+ 	}
+ 
+ 	if (reclaimed)
+ 		*reclaimed = total;
+ 
+ 	return ret;
+ }
+ 
+ static void *zbud_zpool_map(void *pool, unsigned long handle,
+ 			enum zpool_mapmode mm)
+ {
+ 	return zbud_map(pool, handle);
+ }
+ static void zbud_zpool_unmap(void *pool, unsigned long handle)
+ {
+ 	zbud_unmap(pool, handle);
+ }
+ 
+ static u64 zbud_zpool_total_size(void *pool)
+ {
+ 	return zbud_get_pool_size(pool) * PAGE_SIZE;
+ }
+ 
+ static struct zpool_driver zbud_zpool_driver = {
+ 	.type =		"zbud",
+ 	.owner =	THIS_MODULE,
+ 	.create =	zbud_zpool_create,
+ 	.destroy =	zbud_zpool_destroy,
+ 	.malloc =	zbud_zpool_malloc,
+ 	.free =		zbud_zpool_free,
+ 	.shrink =	zbud_zpool_shrink,
+ 	.map =		zbud_zpool_map,
+ 	.unmap =	zbud_zpool_unmap,
+ 	.total_size =	zbud_zpool_total_size,
+ };
+ 
+ MODULE_ALIAS("zpool-zbud");
+ #endif /* CONFIG_ZPOOL */
+ 
+ /*****************
++>>>>>>> 137f8cff505a (mm/zpool: use prefixed module loading)
   * Helpers
  *****************/
  /* Just to make the code easier to read */
* Unmerged path mm/zpool.c
* Unmerged path drivers/staging/zsmalloc/zsmalloc-main.c
* Unmerged path mm/zbud.c
* Unmerged path mm/zpool.c
