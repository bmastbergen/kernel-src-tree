KVM: x86: count actual tlb flushes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [kvm] x86: count actual tlb flushes (Bandan Das) [1209995]
Rebuild_FUZZ: 92.06%
commit-author Radim Krčmář <rkrcmar@redhat.com>
commit a70656b63a82d639b0cec54861bf8faf16ad74e6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/a70656b6.failed

- we count KVM_REQ_TLB_FLUSH requests, not actual flushes
  (KVM can have multiple requests for one flush)
- flushes from kvm_flush_remote_tlbs aren't counted
- it's easy to make a direct request by mistake

Solve these by postponing the counting to kvm_check_request().

	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
	Signed-off-by: Liang Chen <liangchen.linux@gmail.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit a70656b63a82d639b0cec54861bf8faf16ad74e6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/x86.c
index a1a351c51f69,65b97d5567fe..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -6063,36 -6019,10 +6063,43 @@@ static void vcpu_scan_ioapic(struct kvm
  	kvm_apic_update_tmr(vcpu, tmr);
  }
  
++<<<<<<< HEAD
 +void kvm_vcpu_reload_apic_access_page(struct kvm_vcpu *vcpu)
 +{
 +	struct page *page = NULL;
 +
 +	if (!irqchip_in_kernel(vcpu->kvm))
 +		return;
 +
 +	if (!kvm_x86_ops->set_apic_access_page_addr)
 +		return;
 +
 +	page = gfn_to_page(vcpu->kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);
 +	kvm_x86_ops->set_apic_access_page_addr(vcpu, page_to_phys(page));
 +
 +	/*
 +	 * Do not pin apic access page in memory, the MMU notifier
 +	 * will call us again if it is migrated or swapped out.
 +	 */
 +	put_page(page);
 +}
 +EXPORT_SYMBOL_GPL(kvm_vcpu_reload_apic_access_page);
 +
 +void kvm_arch_mmu_notifier_invalidate_page(struct kvm *kvm,
 +					   unsigned long address)
 +{
 +	/*
 +	 * The physical address of apic access page is stored in the VMCS.
 +	 * Update it when it becomes invalid.
 +	 */
 +	if (address == gfn_to_hva(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT))
 +		kvm_make_all_cpus_request(kvm, KVM_REQ_APIC_PAGE_RELOAD);
++=======
+ static void kvm_vcpu_flush_tlb(struct kvm_vcpu *vcpu)
+ {
+ 	++vcpu->stat.tlb_flush;
+ 	kvm_x86_ops->tlb_flush(vcpu);
++>>>>>>> a70656b63a82 (KVM: x86: count actual tlb flushes)
  }
  
  /*
diff --git a/arch/x86/kvm/mmu.c b/arch/x86/kvm/mmu.c
index 9db8bda172f9..4f01cae4af2b 100644
--- a/arch/x86/kvm/mmu.c
+++ b/arch/x86/kvm/mmu.c
@@ -3446,7 +3446,6 @@ static void nonpaging_init_context(struct kvm_vcpu *vcpu,
 
 void kvm_mmu_flush_tlb(struct kvm_vcpu *vcpu)
 {
-	++vcpu->stat.tlb_flush;
 	kvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);
 }
 EXPORT_SYMBOL_GPL(kvm_mmu_flush_tlb);
* Unmerged path arch/x86/kvm/x86.c
