macvlan: implement ndo_get_iflink

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Nicolas Dichtel <nicolas.dichtel@6wind.com>
commit ef5fa6bc46ee516f732d1171323cf3b8524bb8c2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/ef5fa6bc.failed

Don't use dev->iflink anymore.

CC: Patrick McHardy <kaber@trash.net>
	Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ef5fa6bc46ee516f732d1171323cf3b8524bb8c2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/macvlan.c
diff --cc drivers/net/macvlan.c
index de90f272ae85,b227a13f6473..000000000000
--- a/drivers/net/macvlan.c
+++ b/drivers/net/macvlan.c
@@@ -501,9 -783,9 +501,8 @@@ static int macvlan_init(struct net_devi
  				  (lowerdev->state & MACVLAN_STATE_MASK);
  	dev->features 		= lowerdev->features & MACVLAN_FEATURES;
  	dev->features		|= ALWAYS_ON_FEATURES;
 -	dev->hw_features	|= NETIF_F_LRO;
  	dev->vlan_features	= lowerdev->vlan_features & MACVLAN_FEATURES;
  	dev->gso_max_size	= lowerdev->gso_max_size;
- 	dev->iflink		= lowerdev->ifindex;
  	dev->hard_header_len	= lowerdev->hard_header_len;
  
  	macvlan_set_lockdep_class(dev);
@@@ -663,6 -950,57 +662,60 @@@ static netdev_features_t macvlan_fix_fe
  	return features;
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_NET_POLL_CONTROLLER
+ static void macvlan_dev_poll_controller(struct net_device *dev)
+ {
+ 	return;
+ }
+ 
+ static int macvlan_dev_netpoll_setup(struct net_device *dev, struct netpoll_info *npinfo)
+ {
+ 	struct macvlan_dev *vlan = netdev_priv(dev);
+ 	struct net_device *real_dev = vlan->lowerdev;
+ 	struct netpoll *netpoll;
+ 	int err = 0;
+ 
+ 	netpoll = kzalloc(sizeof(*netpoll), GFP_KERNEL);
+ 	err = -ENOMEM;
+ 	if (!netpoll)
+ 		goto out;
+ 
+ 	err = __netpoll_setup(netpoll, real_dev);
+ 	if (err) {
+ 		kfree(netpoll);
+ 		goto out;
+ 	}
+ 
+ 	vlan->netpoll = netpoll;
+ 
+ out:
+ 	return err;
+ }
+ 
+ static void macvlan_dev_netpoll_cleanup(struct net_device *dev)
+ {
+ 	struct macvlan_dev *vlan = netdev_priv(dev);
+ 	struct netpoll *netpoll = vlan->netpoll;
+ 
+ 	if (!netpoll)
+ 		return;
+ 
+ 	vlan->netpoll = NULL;
+ 
+ 	__netpoll_free_async(netpoll);
+ }
+ #endif	/* CONFIG_NET_POLL_CONTROLLER */
+ 
+ static int macvlan_dev_get_iflink(const struct net_device *dev)
+ {
+ 	struct macvlan_dev *vlan = netdev_priv(dev);
+ 
+ 	return vlan->lowerdev->ifindex;
+ }
+ 
++>>>>>>> ef5fa6bc46ee (macvlan: implement ndo_get_iflink)
  static const struct ethtool_ops macvlan_ethtool_ops = {
  	.get_link		= ethtool_op_get_link,
  	.get_settings		= macvlan_ethtool_get_settings,
@@@ -687,6 -1025,13 +740,16 @@@ static const struct net_device_ops macv
  	.ndo_fdb_add		= macvlan_fdb_add,
  	.ndo_fdb_del		= macvlan_fdb_del,
  	.ndo_fdb_dump		= ndo_dflt_fdb_dump,
++<<<<<<< HEAD
++=======
+ 	.ndo_get_lock_subclass  = macvlan_get_nest_level,
+ #ifdef CONFIG_NET_POLL_CONTROLLER
+ 	.ndo_poll_controller	= macvlan_dev_poll_controller,
+ 	.ndo_netpoll_setup	= macvlan_dev_netpoll_setup,
+ 	.ndo_netpoll_cleanup	= macvlan_dev_netpoll_cleanup,
+ #endif
+ 	.ndo_get_iflink		= macvlan_dev_get_iflink,
++>>>>>>> ef5fa6bc46ee (macvlan: implement ndo_get_iflink)
  };
  
  void macvlan_common_setup(struct net_device *dev)
* Unmerged path drivers/net/macvlan.c
