net/mlx4_en: Show PF own statistics via ethtool

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [netdrv] mlx4_en: Show PF own statistics via ethtool (Amir Vadai) [1164527 1164530 1164531 1164536 1164537]
Rebuild_FUZZ: 95.56%
commit-author Eran Ben Elisha <eranbe@mellanox.com>
commit b42de4d01264fa84d8c9e04a18753a6c255567b5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/b42de4d0.failed

Allow the user to observe the PF own statistics using ethtool with pf_
prefixed counter names.

Those counters are the PF statistics out of the overall port statistics.
Every PF QP is attached to a counter and the summary of those counters
is the PF statistics.

	Signed-off-by: Eran Ben Elisha <eranbe@mellanox.com>
	Signed-off-by: Hadar Hen Zion <hadarh@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b42de4d01264fa84d8c9e04a18753a6c255567b5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
#	drivers/net/ethernet/mellanox/mlx4/en_netdev.c
#	drivers/net/ethernet/mellanox/mlx4/en_port.c
#	drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
#	drivers/net/ethernet/mellanox/mlx4/mlx4_stats.h
diff --cc drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
index 1b8da57abd19,99ba1c50e585..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
@@@ -117,6 -119,54 +117,57 @@@ static const char main_strings[][ETH_GS
  	"queue_stopped", "wake_queue", "tx_timeout", "rx_alloc_failed",
  	"rx_csum_good", "rx_csum_none", "rx_csum_complete", "tx_chksum_offload",
  
++<<<<<<< HEAD
++=======
+ 	/* pf statistics */
+ 	"pf_rx_packets",
+ 	"pf_rx_bytes",
+ 	"pf_tx_packets",
+ 	"pf_tx_bytes",
+ 
+ 	/* priority flow control statistics rx */
+ 	"rx_pause_prio_0", "rx_pause_duration_prio_0",
+ 	"rx_pause_transition_prio_0",
+ 	"rx_pause_prio_1", "rx_pause_duration_prio_1",
+ 	"rx_pause_transition_prio_1",
+ 	"rx_pause_prio_2", "rx_pause_duration_prio_2",
+ 	"rx_pause_transition_prio_2",
+ 	"rx_pause_prio_3", "rx_pause_duration_prio_3",
+ 	"rx_pause_transition_prio_3",
+ 	"rx_pause_prio_4", "rx_pause_duration_prio_4",
+ 	"rx_pause_transition_prio_4",
+ 	"rx_pause_prio_5", "rx_pause_duration_prio_5",
+ 	"rx_pause_transition_prio_5",
+ 	"rx_pause_prio_6", "rx_pause_duration_prio_6",
+ 	"rx_pause_transition_prio_6",
+ 	"rx_pause_prio_7", "rx_pause_duration_prio_7",
+ 	"rx_pause_transition_prio_7",
+ 
+ 	/* flow control statistics rx */
+ 	"rx_pause", "rx_pause_duration", "rx_pause_transition",
+ 
+ 	/* priority flow control statistics tx */
+ 	"tx_pause_prio_0", "tx_pause_duration_prio_0",
+ 	"tx_pause_transition_prio_0",
+ 	"tx_pause_prio_1", "tx_pause_duration_prio_1",
+ 	"tx_pause_transition_prio_1",
+ 	"tx_pause_prio_2", "tx_pause_duration_prio_2",
+ 	"tx_pause_transition_prio_2",
+ 	"tx_pause_prio_3", "tx_pause_duration_prio_3",
+ 	"tx_pause_transition_prio_3",
+ 	"tx_pause_prio_4", "tx_pause_duration_prio_4",
+ 	"tx_pause_transition_prio_4",
+ 	"tx_pause_prio_5", "tx_pause_duration_prio_5",
+ 	"tx_pause_transition_prio_5",
+ 	"tx_pause_prio_6", "tx_pause_duration_prio_6",
+ 	"tx_pause_transition_prio_6",
+ 	"tx_pause_prio_7", "tx_pause_duration_prio_7",
+ 	"tx_pause_transition_prio_7",
+ 
+ 	/* flow control statistics tx */
+ 	"tx_pause", "tx_pause_duration", "tx_pause_transition",
+ 
++>>>>>>> b42de4d01264 (net/mlx4_en: Show PF own statistics via ethtool)
  	/* packet statistics */
  	"rx_multicast_packets",
  	"rx_broadcast_packets",
@@@ -277,30 -366,43 +328,49 @@@ static void mlx4_en_get_ethtool_stats(s
  
  	spin_lock_bh(&priv->stats_lock);
  
++<<<<<<< HEAD
 +	if (!(priv->stats_bitmap)) {
 +		for (i = 0; i < NUM_MAIN_STATS; i++)
++=======
+ 	for (i = 0; i < NUM_MAIN_STATS; i++, bitmap_iterator_inc(&it))
+ 		if (bitmap_iterator_test(&it))
+ 			data[index++] = ((unsigned long *)&priv->stats)[i];
+ 
+ 	for (i = 0; i < NUM_PORT_STATS; i++, bitmap_iterator_inc(&it))
+ 		if (bitmap_iterator_test(&it))
+ 			data[index++] = ((unsigned long *)&priv->port_stats)[i];
+ 
+ 	for (i = 0; i < NUM_PF_STATS; i++, bitmap_iterator_inc(&it))
+ 		if (bitmap_iterator_test(&it))
+ 			data[index++] =
+ 				((unsigned long *)&priv->pf_stats)[i];
+ 
+ 	for (i = 0; i < NUM_FLOW_PRIORITY_STATS_RX;
+ 	     i++, bitmap_iterator_inc(&it))
+ 		if (bitmap_iterator_test(&it))
++>>>>>>> b42de4d01264 (net/mlx4_en: Show PF own statistics via ethtool)
  			data[index++] =
 -				((u64 *)&priv->rx_priority_flowstats)[i];
 -
 -	for (i = 0; i < NUM_FLOW_STATS_RX; i++, bitmap_iterator_inc(&it))
 -		if (bitmap_iterator_test(&it))
 -			data[index++] = ((u64 *)&priv->rx_flowstats)[i];
 -
 -	for (i = 0; i < NUM_FLOW_PRIORITY_STATS_TX;
 -	     i++, bitmap_iterator_inc(&it))
 -		if (bitmap_iterator_test(&it))
 +				((unsigned long *) &priv->stats)[i];
 +		for (i = 0; i < NUM_PORT_STATS; i++)
  			data[index++] =
 -				((u64 *)&priv->tx_priority_flowstats)[i];
 -
 -	for (i = 0; i < NUM_FLOW_STATS_TX; i++, bitmap_iterator_inc(&it))
 -		if (bitmap_iterator_test(&it))
 -			data[index++] = ((u64 *)&priv->tx_flowstats)[i];
 -
 -	for (i = 0; i < NUM_PKT_STATS; i++, bitmap_iterator_inc(&it))
 -		if (bitmap_iterator_test(&it))
 -			data[index++] = ((unsigned long *)&priv->pkstats)[i];
 -
 +				((unsigned long *) &priv->port_stats)[i];
 +		for (i = 0; i < NUM_PKT_STATS; i++)
 +			data[index++] =
 +				((unsigned long *) &priv->pkstats)[i];
 +	} else {
 +		for (i = 0; i < NUM_MAIN_STATS; i++) {
 +			if ((priv->stats_bitmap >> j) & 1)
 +				data[index++] =
 +				((unsigned long *) &priv->stats)[i];
 +			j++;
 +		}
 +		for (i = 0; i < NUM_PORT_STATS; i++) {
 +			if ((priv->stats_bitmap >> j) & 1)
 +				data[index++] =
 +				((unsigned long *) &priv->port_stats)[i];
 +			j++;
 +		}
 +	}
  	for (i = 0; i < priv->tx_ring_num; i++) {
  		data[index++] = priv->tx_ring[i]->packets;
  		data[index++] = priv->tx_ring[i]->bytes;
@@@ -342,29 -447,36 +412,43 @@@ static void mlx4_en_get_strings(struct 
  
  	case ETH_SS_STATS:
  		/* Add main counters */
 -		for (i = 0; i < NUM_MAIN_STATS; i++, strings++,
 -		     bitmap_iterator_inc(&it))
 -			if (bitmap_iterator_test(&it))
 +		if (!priv->stats_bitmap) {
 +			for (i = 0; i < NUM_MAIN_STATS; i++)
  				strcpy(data + (index++) * ETH_GSTRING_LEN,
 -				       main_strings[strings]);
 -
 -		for (i = 0; i < NUM_PORT_STATS; i++, strings++,
 -		     bitmap_iterator_inc(&it))
 -			if (bitmap_iterator_test(&it))
 +					main_strings[i]);
 +			for (i = 0; i < NUM_PORT_STATS; i++)
  				strcpy(data + (index++) * ETH_GSTRING_LEN,
++<<<<<<< HEAD
 +					main_strings[i +
 +					NUM_MAIN_STATS]);
 +			for (i = 0; i < NUM_PKT_STATS; i++)
++=======
+ 				       main_strings[strings]);
+ 
+ 		for (i = 0; i < NUM_PF_STATS; i++, strings++,
+ 		     bitmap_iterator_inc(&it))
+ 			if (bitmap_iterator_test(&it))
+ 				strcpy(data + (index++) * ETH_GSTRING_LEN,
+ 				       main_strings[strings]);
+ 
+ 		for (i = 0; i < NUM_FLOW_STATS; i++, strings++,
+ 		     bitmap_iterator_inc(&it))
+ 			if (bitmap_iterator_test(&it))
++>>>>>>> b42de4d01264 (net/mlx4_en: Show PF own statistics via ethtool)
  				strcpy(data + (index++) * ETH_GSTRING_LEN,
 -				       main_strings[strings]);
 -
 -		for (i = 0; i < NUM_PKT_STATS; i++, strings++,
 -		     bitmap_iterator_inc(&it))
 -			if (bitmap_iterator_test(&it))
 -				strcpy(data + (index++) * ETH_GSTRING_LEN,
 -				       main_strings[strings]);
 -
 +					main_strings[i +
 +					NUM_MAIN_STATS +
 +					NUM_PORT_STATS]);
 +		} else
 +			for (i = 0; i < NUM_MAIN_STATS + NUM_PORT_STATS; i++) {
 +				if ((priv->stats_bitmap >> i) & 1) {
 +					strcpy(data +
 +					       (index++) * ETH_GSTRING_LEN,
 +					       main_strings[i]);
 +				}
 +				if (!(priv->stats_bitmap >> i))
 +					break;
 +			}
  		for (i = 0; i < priv->tx_ring_num; i++) {
  			sprintf(data + (index++) * ETH_GSTRING_LEN,
  				"tx%d_packets", i);
diff --cc drivers/net/ethernet/mellanox/mlx4/en_netdev.c
index 9a988b45c844,f9142f22d630..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
@@@ -1885,6 -1889,13 +1885,16 @@@ static void mlx4_en_clear_stats(struct 
  	memset(&priv->pstats, 0, sizeof(priv->pstats));
  	memset(&priv->pkstats, 0, sizeof(priv->pkstats));
  	memset(&priv->port_stats, 0, sizeof(priv->port_stats));
++<<<<<<< HEAD
++=======
+ 	memset(&priv->rx_flowstats, 0, sizeof(priv->rx_flowstats));
+ 	memset(&priv->tx_flowstats, 0, sizeof(priv->tx_flowstats));
+ 	memset(&priv->rx_priority_flowstats, 0,
+ 	       sizeof(priv->rx_priority_flowstats));
+ 	memset(&priv->tx_priority_flowstats, 0,
+ 	       sizeof(priv->tx_priority_flowstats));
+ 	memset(&priv->pf_stats, 0, sizeof(priv->pf_stats));
++>>>>>>> b42de4d01264 (net/mlx4_en: Show PF own statistics via ethtool)
  
  	for (i = 0; i < priv->tx_ring_num; i++) {
  		priv->tx_ring[i]->bytes = 0;
@@@ -2442,9 -2502,266 +2452,267 @@@ static const struct net_device_ops mlx4
  #ifdef CONFIG_MLX4_EN_VXLAN
  	.ndo_add_vxlan_port	= mlx4_en_add_vxlan_port,
  	.ndo_del_vxlan_port	= mlx4_en_del_vxlan_port,
 -	.ndo_features_check	= mlx4_en_features_check,
  #endif
 -	.ndo_set_tx_maxrate	= mlx4_en_set_tx_maxrate,
  };
  
++<<<<<<< HEAD
++=======
+ struct mlx4_en_bond {
+ 	struct work_struct work;
+ 	struct mlx4_en_priv *priv;
+ 	int is_bonded;
+ 	struct mlx4_port_map port_map;
+ };
+ 
+ static void mlx4_en_bond_work(struct work_struct *work)
+ {
+ 	struct mlx4_en_bond *bond = container_of(work,
+ 						     struct mlx4_en_bond,
+ 						     work);
+ 	int err = 0;
+ 	struct mlx4_dev *dev = bond->priv->mdev->dev;
+ 
+ 	if (bond->is_bonded) {
+ 		if (!mlx4_is_bonded(dev)) {
+ 			err = mlx4_bond(dev);
+ 			if (err)
+ 				en_err(bond->priv, "Fail to bond device\n");
+ 		}
+ 		if (!err) {
+ 			err = mlx4_port_map_set(dev, &bond->port_map);
+ 			if (err)
+ 				en_err(bond->priv, "Fail to set port map [%d][%d]: %d\n",
+ 				       bond->port_map.port1,
+ 				       bond->port_map.port2,
+ 				       err);
+ 		}
+ 	} else if (mlx4_is_bonded(dev)) {
+ 		err = mlx4_unbond(dev);
+ 		if (err)
+ 			en_err(bond->priv, "Fail to unbond device\n");
+ 	}
+ 	dev_put(bond->priv->dev);
+ 	kfree(bond);
+ }
+ 
+ static int mlx4_en_queue_bond_work(struct mlx4_en_priv *priv, int is_bonded,
+ 				   u8 v2p_p1, u8 v2p_p2)
+ {
+ 	struct mlx4_en_bond *bond = NULL;
+ 
+ 	bond = kzalloc(sizeof(*bond), GFP_ATOMIC);
+ 	if (!bond)
+ 		return -ENOMEM;
+ 
+ 	INIT_WORK(&bond->work, mlx4_en_bond_work);
+ 	bond->priv = priv;
+ 	bond->is_bonded = is_bonded;
+ 	bond->port_map.port1 = v2p_p1;
+ 	bond->port_map.port2 = v2p_p2;
+ 	dev_hold(priv->dev);
+ 	queue_work(priv->mdev->workqueue, &bond->work);
+ 	return 0;
+ }
+ 
+ int mlx4_en_netdev_event(struct notifier_block *this,
+ 			 unsigned long event, void *ptr)
+ {
+ 	struct net_device *ndev = netdev_notifier_info_to_dev(ptr);
+ 	u8 port = 0;
+ 	struct mlx4_en_dev *mdev;
+ 	struct mlx4_dev *dev;
+ 	int i, num_eth_ports = 0;
+ 	bool do_bond = true;
+ 	struct mlx4_en_priv *priv;
+ 	u8 v2p_port1 = 0;
+ 	u8 v2p_port2 = 0;
+ 
+ 	if (!net_eq(dev_net(ndev), &init_net))
+ 		return NOTIFY_DONE;
+ 
+ 	mdev = container_of(this, struct mlx4_en_dev, nb);
+ 	dev = mdev->dev;
+ 
+ 	/* Go into this mode only when two network devices set on two ports
+ 	 * of the same mlx4 device are slaves of the same bonding master
+ 	 */
+ 	mlx4_foreach_port(i, dev, MLX4_PORT_TYPE_ETH) {
+ 		++num_eth_ports;
+ 		if (!port && (mdev->pndev[i] == ndev))
+ 			port = i;
+ 		mdev->upper[i] = mdev->pndev[i] ?
+ 			netdev_master_upper_dev_get(mdev->pndev[i]) : NULL;
+ 		/* condition not met: network device is a slave */
+ 		if (!mdev->upper[i])
+ 			do_bond = false;
+ 		if (num_eth_ports < 2)
+ 			continue;
+ 		/* condition not met: same master */
+ 		if (mdev->upper[i] != mdev->upper[i-1])
+ 			do_bond = false;
+ 	}
+ 	/* condition not met: 2 salves */
+ 	do_bond = (num_eth_ports ==  2) ? do_bond : false;
+ 
+ 	/* handle only events that come with enough info */
+ 	if ((do_bond && (event != NETDEV_BONDING_INFO)) || !port)
+ 		return NOTIFY_DONE;
+ 
+ 	priv = netdev_priv(ndev);
+ 	if (do_bond) {
+ 		struct netdev_notifier_bonding_info *notifier_info = ptr;
+ 		struct netdev_bonding_info *bonding_info =
+ 			&notifier_info->bonding_info;
+ 
+ 		/* required mode 1, 2 or 4 */
+ 		if ((bonding_info->master.bond_mode != BOND_MODE_ACTIVEBACKUP) &&
+ 		    (bonding_info->master.bond_mode != BOND_MODE_XOR) &&
+ 		    (bonding_info->master.bond_mode != BOND_MODE_8023AD))
+ 			do_bond = false;
+ 
+ 		/* require exactly 2 slaves */
+ 		if (bonding_info->master.num_slaves != 2)
+ 			do_bond = false;
+ 
+ 		/* calc v2p */
+ 		if (do_bond) {
+ 			if (bonding_info->master.bond_mode ==
+ 			    BOND_MODE_ACTIVEBACKUP) {
+ 				/* in active-backup mode virtual ports are
+ 				 * mapped to the physical port of the active
+ 				 * slave */
+ 				if (bonding_info->slave.state ==
+ 				    BOND_STATE_BACKUP) {
+ 					if (port == 1) {
+ 						v2p_port1 = 2;
+ 						v2p_port2 = 2;
+ 					} else {
+ 						v2p_port1 = 1;
+ 						v2p_port2 = 1;
+ 					}
+ 				} else { /* BOND_STATE_ACTIVE */
+ 					if (port == 1) {
+ 						v2p_port1 = 1;
+ 						v2p_port2 = 1;
+ 					} else {
+ 						v2p_port1 = 2;
+ 						v2p_port2 = 2;
+ 					}
+ 				}
+ 			} else { /* Active-Active */
+ 				/* in active-active mode a virtual port is
+ 				 * mapped to the native physical port if and only
+ 				 * if the physical port is up */
+ 				__s8 link = bonding_info->slave.link;
+ 
+ 				if (port == 1)
+ 					v2p_port2 = 2;
+ 				else
+ 					v2p_port1 = 1;
+ 				if ((link == BOND_LINK_UP) ||
+ 				    (link == BOND_LINK_FAIL)) {
+ 					if (port == 1)
+ 						v2p_port1 = 1;
+ 					else
+ 						v2p_port2 = 2;
+ 				} else { /* BOND_LINK_DOWN || BOND_LINK_BACK */
+ 					if (port == 1)
+ 						v2p_port1 = 2;
+ 					else
+ 						v2p_port2 = 1;
+ 				}
+ 			}
+ 		}
+ 	}
+ 
+ 	mlx4_en_queue_bond_work(priv, do_bond,
+ 				v2p_port1, v2p_port2);
+ 
+ 	return NOTIFY_DONE;
+ }
+ 
+ void mlx4_en_update_pfc_stats_bitmap(struct mlx4_dev *dev,
+ 				     struct mlx4_en_stats_bitmap *stats_bitmap,
+ 				     u8 rx_ppp, u8 rx_pause,
+ 				     u8 tx_ppp, u8 tx_pause)
+ {
+ 	int last_i = NUM_MAIN_STATS + NUM_PORT_STATS + NUM_PF_STATS;
+ 
+ 	if (!mlx4_is_slave(dev) &&
+ 	    (dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_FLOWSTATS_EN)) {
+ 		mutex_lock(&stats_bitmap->mutex);
+ 		bitmap_clear(stats_bitmap->bitmap, last_i, NUM_FLOW_STATS);
+ 
+ 		if (rx_ppp)
+ 			bitmap_set(stats_bitmap->bitmap, last_i,
+ 				   NUM_FLOW_PRIORITY_STATS_RX);
+ 		last_i += NUM_FLOW_PRIORITY_STATS_RX;
+ 
+ 		if (rx_pause && !(rx_ppp))
+ 			bitmap_set(stats_bitmap->bitmap, last_i,
+ 				   NUM_FLOW_STATS_RX);
+ 		last_i += NUM_FLOW_STATS_RX;
+ 
+ 		if (tx_ppp)
+ 			bitmap_set(stats_bitmap->bitmap, last_i,
+ 				   NUM_FLOW_PRIORITY_STATS_TX);
+ 		last_i += NUM_FLOW_PRIORITY_STATS_TX;
+ 
+ 		if (tx_pause && !(tx_ppp))
+ 			bitmap_set(stats_bitmap->bitmap, last_i,
+ 				   NUM_FLOW_STATS_TX);
+ 		last_i += NUM_FLOW_STATS_TX;
+ 
+ 		mutex_unlock(&stats_bitmap->mutex);
+ 	}
+ }
+ 
+ void mlx4_en_set_stats_bitmap(struct mlx4_dev *dev,
+ 			      struct mlx4_en_stats_bitmap *stats_bitmap,
+ 			      u8 rx_ppp, u8 rx_pause,
+ 			      u8 tx_ppp, u8 tx_pause)
+ {
+ 	int last_i = 0;
+ 
+ 	mutex_init(&stats_bitmap->mutex);
+ 	bitmap_zero(stats_bitmap->bitmap, NUM_ALL_STATS);
+ 
+ 	if (mlx4_is_slave(dev)) {
+ 		bitmap_set(stats_bitmap->bitmap, last_i +
+ 					 MLX4_FIND_NETDEV_STAT(rx_packets), 1);
+ 		bitmap_set(stats_bitmap->bitmap, last_i +
+ 					 MLX4_FIND_NETDEV_STAT(tx_packets), 1);
+ 		bitmap_set(stats_bitmap->bitmap, last_i +
+ 					 MLX4_FIND_NETDEV_STAT(rx_bytes), 1);
+ 		bitmap_set(stats_bitmap->bitmap, last_i +
+ 					 MLX4_FIND_NETDEV_STAT(tx_bytes), 1);
+ 		bitmap_set(stats_bitmap->bitmap, last_i +
+ 					 MLX4_FIND_NETDEV_STAT(rx_dropped), 1);
+ 		bitmap_set(stats_bitmap->bitmap, last_i +
+ 					 MLX4_FIND_NETDEV_STAT(tx_dropped), 1);
+ 	} else {
+ 		bitmap_set(stats_bitmap->bitmap, last_i, NUM_MAIN_STATS);
+ 	}
+ 	last_i += NUM_MAIN_STATS;
+ 
+ 	bitmap_set(stats_bitmap->bitmap, last_i, NUM_PORT_STATS);
+ 	last_i += NUM_PORT_STATS;
+ 
+ 	if (mlx4_is_master(dev))
+ 		bitmap_set(stats_bitmap->bitmap, last_i,
+ 			   NUM_PF_STATS);
+ 	last_i += NUM_PF_STATS;
+ 
+ 	mlx4_en_update_pfc_stats_bitmap(dev, stats_bitmap,
+ 					rx_ppp, rx_pause,
+ 					tx_ppp, tx_pause);
+ 	last_i += NUM_FLOW_STATS;
+ 
+ 	if (!mlx4_is_slave(dev))
+ 		bitmap_set(stats_bitmap->bitmap, last_i, NUM_PKT_STATS);
+ }
+ 
++>>>>>>> b42de4d01264 (net/mlx4_en: Show PF own statistics via ethtool)
  int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,
  			struct mlx4_en_port_profile *prof)
  {
diff --cc drivers/net/ethernet/mellanox/mlx4/en_port.c
index b8264e54b15e,73f6277d9ac1..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/en_port.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_port.c
@@@ -149,7 -149,9 +149,8 @@@ static unsigned long en_stats_adder(__b
  
  int mlx4_en_DUMP_ETH_STATS(struct mlx4_en_dev *mdev, u8 port, u8 reset)
  {
+ 	struct mlx4_counter tmp_counter_stats;
  	struct mlx4_en_stat_out_mbox *mlx4_en_stats;
 -	struct mlx4_en_stat_out_flow_control_mbox *flowstats;
  	struct mlx4_en_priv *priv = netdev_priv(mdev->pndev[port]);
  	struct net_device_stats *stats = &priv->stats;
  	struct mlx4_cmd_mailbox *mailbox;
@@@ -295,6 -297,67 +296,70 @@@
  
  	spin_unlock_bh(&priv->stats_lock);
  
++<<<<<<< HEAD
++=======
+ 	memset(&tmp_counter_stats, 0, sizeof(tmp_counter_stats));
+ 	counter_index = mlx4_get_default_counter_index(mdev->dev, port);
+ 	err = mlx4_get_counter_stats(mdev->dev, counter_index,
+ 				     &tmp_counter_stats, reset);
+ 
+ 	/* 0xffs indicates invalid value */
+ 	memset(mailbox->buf, 0xff, sizeof(*flowstats) * MLX4_NUM_PRIORITIES);
+ 
+ 	if (mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_FLOWSTATS_EN) {
+ 		memset(mailbox->buf, 0,
+ 		       sizeof(*flowstats) * MLX4_NUM_PRIORITIES);
+ 		err = mlx4_cmd_box(mdev->dev, 0, mailbox->dma,
+ 				   in_mod | MLX4_DUMP_ETH_STATS_FLOW_CONTROL,
+ 				   0, MLX4_CMD_DUMP_ETH_STATS,
+ 				   MLX4_CMD_TIME_CLASS_B, MLX4_CMD_WRAPPED);
+ 		if (err)
+ 			goto out;
+ 	}
+ 
+ 	flowstats = mailbox->buf;
+ 
+ 	spin_lock_bh(&priv->stats_lock);
+ 
+ 	if (tmp_counter_stats.counter_mode == 0) {
+ 		priv->pf_stats.rx_bytes   = be64_to_cpu(tmp_counter_stats.rx_bytes);
+ 		priv->pf_stats.tx_bytes   = be64_to_cpu(tmp_counter_stats.tx_bytes);
+ 		priv->pf_stats.rx_packets = be64_to_cpu(tmp_counter_stats.rx_frames);
+ 		priv->pf_stats.tx_packets = be64_to_cpu(tmp_counter_stats.tx_frames);
+ 	}
+ 
+ 	for (i = 0; i < MLX4_NUM_PRIORITIES; i++)	{
+ 		priv->rx_priority_flowstats[i].rx_pause =
+ 			be64_to_cpu(flowstats[i].rx_pause);
+ 		priv->rx_priority_flowstats[i].rx_pause_duration =
+ 			be64_to_cpu(flowstats[i].rx_pause_duration);
+ 		priv->rx_priority_flowstats[i].rx_pause_transition =
+ 			be64_to_cpu(flowstats[i].rx_pause_transition);
+ 		priv->tx_priority_flowstats[i].tx_pause =
+ 			be64_to_cpu(flowstats[i].tx_pause);
+ 		priv->tx_priority_flowstats[i].tx_pause_duration =
+ 			be64_to_cpu(flowstats[i].tx_pause_duration);
+ 		priv->tx_priority_flowstats[i].tx_pause_transition =
+ 			be64_to_cpu(flowstats[i].tx_pause_transition);
+ 	}
+ 
+ 	/* if pfc is not in use, all priorities counters have the same value */
+ 	priv->rx_flowstats.rx_pause =
+ 		be64_to_cpu(flowstats[0].rx_pause);
+ 	priv->rx_flowstats.rx_pause_duration =
+ 		be64_to_cpu(flowstats[0].rx_pause_duration);
+ 	priv->rx_flowstats.rx_pause_transition =
+ 		be64_to_cpu(flowstats[0].rx_pause_transition);
+ 	priv->tx_flowstats.tx_pause =
+ 		be64_to_cpu(flowstats[0].tx_pause);
+ 	priv->tx_flowstats.tx_pause_duration =
+ 		be64_to_cpu(flowstats[0].tx_pause_duration);
+ 	priv->tx_flowstats.tx_pause_transition =
+ 		be64_to_cpu(flowstats[0].tx_pause_transition);
+ 
+ 	spin_unlock_bh(&priv->stats_lock);
+ 
++>>>>>>> b42de4d01264 (net/mlx4_en: Show PF own statistics via ethtool)
  out:
  	mlx4_free_cmd_mailbox(mdev->dev, mailbox);
  	return err;
diff --cc drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
index 16811bfb94e5,d5f9adb6a784..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
+++ b/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
@@@ -560,8 -566,13 +560,16 @@@ struct mlx4_en_priv 
  #endif
  	struct mlx4_en_perf_stats pstats;
  	struct mlx4_en_pkt_stats pkstats;
++<<<<<<< HEAD
++=======
+ 	struct mlx4_en_counter_stats pf_stats;
+ 	struct mlx4_en_flow_stats_rx rx_priority_flowstats[MLX4_NUM_PRIORITIES];
+ 	struct mlx4_en_flow_stats_tx tx_priority_flowstats[MLX4_NUM_PRIORITIES];
+ 	struct mlx4_en_flow_stats_rx rx_flowstats;
+ 	struct mlx4_en_flow_stats_tx tx_flowstats;
++>>>>>>> b42de4d01264 (net/mlx4_en: Show PF own statistics via ethtool)
  	struct mlx4_en_port_stats port_stats;
 -	struct mlx4_en_stats_bitmap stats_bitmap;
 +	u64 stats_bitmap;
  	struct list_head mc_list;
  	struct list_head curr_list;
  	u64 broadcast_id;
diff --cc drivers/net/ethernet/mellanox/mlx4/mlx4_stats.h
index 8a56611cd79a,c5c1de9cf2ce..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/mlx4_stats.h
+++ b/drivers/net/ethernet/mellanox/mlx4/mlx4_stats.h
@@@ -48,6 -56,61 +56,60 @@@ struct mlx4_en_perf_stats 
  };
  
  #define NUM_MAIN_STATS	21
++<<<<<<< HEAD
++=======
+ 
+ #define MLX4_NUM_PRIORITIES	8
+ 
+ struct mlx4_en_flow_stats_rx {
+ 	u64 rx_pause;
+ 	u64 rx_pause_duration;
+ 	u64 rx_pause_transition;
+ #define NUM_FLOW_STATS_RX	3
+ #define NUM_FLOW_PRIORITY_STATS_RX	(NUM_FLOW_STATS_RX * \
+ 					 MLX4_NUM_PRIORITIES)
+ };
+ 
+ struct mlx4_en_flow_stats_tx {
+ 	u64 tx_pause;
+ 	u64 tx_pause_duration;
+ 	u64 tx_pause_transition;
+ #define NUM_FLOW_STATS_TX	3
+ #define NUM_FLOW_PRIORITY_STATS_TX	(NUM_FLOW_STATS_TX * \
+ 					 MLX4_NUM_PRIORITIES)
+ };
+ 
+ #define NUM_FLOW_STATS (NUM_FLOW_STATS_RX + NUM_FLOW_STATS_TX + \
+ 			NUM_FLOW_PRIORITY_STATS_TX + \
+ 			NUM_FLOW_PRIORITY_STATS_RX + \
+ 			NUM_PF_STATS)
+ 
+ struct mlx4_en_stat_out_flow_control_mbox {
+ 	/* Total number of PAUSE frames received from the far-end port */
+ 	__be64 rx_pause;
+ 	/* Total number of microseconds that far-end port requested to pause
+ 	* transmission of packets
+ 	*/
+ 	__be64 rx_pause_duration;
+ 	/* Number of received transmission from XOFF state to XON state */
+ 	__be64 rx_pause_transition;
+ 	/* Total number of PAUSE frames sent from the far-end port */
+ 	__be64 tx_pause;
+ 	/* Total time in microseconds that transmission of packets has been
+ 	* paused
+ 	*/
+ 	__be64 tx_pause_duration;
+ 	/* Number of transmitter transitions from XOFF state to XON state */
+ 	__be64 tx_pause_transition;
+ 	/* Reserverd */
+ 	__be64 reserved[2];
+ };
+ 
+ enum {
+ 	MLX4_DUMP_ETH_STATS_FLOW_CONTROL = 1 << 12
+ };
+ 
++>>>>>>> b42de4d01264 (net/mlx4_en: Show PF own statistics via ethtool)
  #define NUM_ALL_STATS	(NUM_MAIN_STATS + NUM_PORT_STATS + NUM_PKT_STATS + \
 -			 NUM_FLOW_STATS + NUM_PERF_STATS)
 -
 -#define MLX4_FIND_NETDEV_STAT(n) (offsetof(struct net_device_stats, n) / \
 -				  sizeof(((struct net_device_stats *)0)->n))
 -
 +			 NUM_PERF_STATS)
  #endif
* Unmerged path drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
* Unmerged path drivers/net/ethernet/mellanox/mlx4/en_netdev.c
* Unmerged path drivers/net/ethernet/mellanox/mlx4/en_port.c
* Unmerged path drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
* Unmerged path drivers/net/ethernet/mellanox/mlx4/mlx4_stats.h
