fib_trie: Return pointer to tnode pointer in resize/inflate/halve

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Alexander Duyck <alexander.h.duyck@redhat.com>
commit 8d8e810ca8ec2541f30af916f0de1b41ac86ec4a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/8d8e810c.failed

Resize related functions now all return a pointer to the pointer that
references the object that was resized.

	Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8d8e810ca8ec2541f30af916f0de1b41ac86ec4a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/fib_trie.c
diff --cc net/ipv4/fib_trie.c
index 8be89b1a8b93,752520747056..000000000000
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@@ -810,8 -820,7 +821,12 @@@ static struct tnode __rcu **resize(stru
  	 * doing it ourselves.  This way we can let RCU fully do its
  	 * thing without us interfering
  	 */
++<<<<<<< HEAD
 +	cptr = tp ? &tp->child[get_index(tn->key, tp)] : &t->trie;
 +	BUG_ON(tn != rtnl_dereference(*cptr));
++=======
+ 	BUG_ON(tn != rtnl_dereference(cptr[cindex]));
++>>>>>>> 8d8e810ca8ec (fib_trie: Return pointer to tnode pointer in resize/inflate/halve)
  
  	/* Double as long as the resulting node has a number of
  	 * nonempty nodes that are above the threshold.
@@@ -864,37 -879,12 +885,39 @@@
  		if (tp && (slen > tp->slen))
  			tp->slen = slen;
  	}
+ 
+ 	return cptr;
  }
  
 -static void leaf_pull_suffix(struct tnode *tp, struct tnode *l)
 +/* readside must use rcu_read_lock currently dump routines
 + via get_fa_head and dump */
 +
 +static struct leaf_info *find_leaf_info(struct tnode *l, int plen)
 +{
 +	struct hlist_head *head = &l->list;
 +	struct leaf_info *li;
 +
 +	hlist_for_each_entry_rcu(li, head, hlist)
 +		if (li->plen == plen)
 +			return li;
 +
 +	return NULL;
 +}
 +
 +static inline struct list_head *get_fa_head(struct tnode *l, int plen)
  {
 +	struct leaf_info *li = find_leaf_info(l, plen);
 +
 +	if (!li)
 +		return NULL;
 +
 +	return &li->falh;
 +}
 +
 +static void leaf_pull_suffix(struct tnode *l)
 +{
 +	struct tnode *tp = node_parent(l);
 +
  	while (tp && (tp->slen > tp->pos) && (tp->slen > l->slen)) {
  		if (update_suffix(tp) > l->slen)
  			break;
@@@ -991,77 -941,61 +1014,98 @@@ static struct tnode *fib_find_node(stru
  	return n;
  }
  
 -/* Return the first fib alias matching TOS with
 - * priority less than or equal to PRIO.
 - */
 -static struct fib_alias *fib_find_alias(struct hlist_head *fah, u8 slen,
 -					u8 tos, u32 prio)
 -{
 -	struct fib_alias *fa;
 -
 -	if (!fah)
 -		return NULL;
 -
 -	hlist_for_each_entry(fa, fah, fa_list) {
 -		if (fa->fa_slen < slen)
 -			continue;
 -		if (fa->fa_slen != slen)
 -			break;
 -		if (fa->fa_tos > tos)
 -			continue;
 -		if (fa->fa_info->fib_priority >= prio || fa->fa_tos < tos)
 -			return fa;
 -	}
 -
 -	return NULL;
 -}
 -
  static void trie_rebalance(struct trie *t, struct tnode *tn)
  {
- 	struct tnode *tp;
+ 	struct tnode __rcu **cptr = &t->trie;
  
++<<<<<<< HEAD
 +	while ((tp = node_parent(tn)) != NULL) {
 +		resize(t, tn);
 +		tn = tp;
++=======
+ 	while (tn) {
+ 		struct tnode *tp = node_parent(tn);
+ 
+ 		cptr = resize(t, tn);
+ 		if (!tp)
+ 			break;
+ 		tn = container_of(cptr, struct tnode, tnode[0]);
++>>>>>>> 8d8e810ca8ec (fib_trie: Return pointer to tnode pointer in resize/inflate/halve)
  	}
 +
 +	/* Handle last (top) tnode */
 +	if (IS_TNODE(tn))
 +		resize(t, tn);
  }
  
++<<<<<<< HEAD
 +/* only used from updater-side */
 +
 +static struct list_head *fib_insert_node(struct trie *t, u32 key, int plen)
++=======
+ static int fib_insert_node(struct trie *t, struct tnode *tp,
+ 			   struct fib_alias *new, t_key key)
++>>>>>>> 8d8e810ca8ec (fib_trie: Return pointer to tnode pointer in resize/inflate/halve)
  {
 -	struct tnode *n, *l;
 +	struct list_head *fa_head = NULL;
 +	struct tnode *l, *n, *tp = NULL;
 +	struct leaf_info *li;
  
++<<<<<<< HEAD
 +	li = leaf_info_new(plen);
 +	if (!li)
 +		return NULL;
 +	fa_head = &li->falh;
++=======
+ 	l = leaf_new(key, new);
+ 	if (!l)
+ 		goto noleaf;
++>>>>>>> 8d8e810ca8ec (fib_trie: Return pointer to tnode pointer in resize/inflate/halve)
  
 -	/* retrieve child from parent node */
 -	if (tp)
 -		n = tnode_get_child(tp, get_index(key, tp));
 -	else
 -		n = rcu_dereference_rtnl(t->trie);
 +	n = rtnl_dereference(t->trie);
 +
 +	/* If we point to NULL, stop. Either the tree is empty and we should
 +	 * just put a new leaf in if, or we have reached an empty child slot,
 +	 * and we should just put our new leaf in that.
 +	 *
 +	 * If we hit a node with a key that does't match then we should stop
 +	 * and create a new tnode to replace that node and insert ourselves
 +	 * and the other node into the new tnode.
 +	 */
 +	while (n) {
 +		unsigned long index = get_index(key, n);
 +
 +		/* This bit of code is a bit tricky but it combines multiple
 +		 * checks into a single check.  The prefix consists of the
 +		 * prefix plus zeros for the "bits" in the prefix. The index
 +		 * is the difference between the key and this value.  From
 +		 * this we can actually derive several pieces of data.
 +		 *   if !(index >> bits)
 +		 *     we know the value is child index
 +		 *   else
 +		 *     we have a mismatch in skip bits and failed
 +		 */
 +		if (index >> n->bits)
 +			break;
 +
 +		/* we have found a leaf. Prefixes have already been compared */
 +		if (IS_LEAF(n)) {
 +			/* Case 1: n is a leaf, and prefixes match*/
 +			insert_leaf_info(n, li);
 +			return fa_head;
 +		}
 +
 +		tp = n;
 +		n = tnode_get_child_rcu(n, index);
 +	}
 +
 +	l = leaf_new(key);
 +	if (!l) {
 +		free_leaf_info(li);
 +		return NULL;
 +	}
 +
 +	insert_leaf_info(l, li);
  
  	/* Case 2: n is a LEAF or a TNODE and the key doesn't match.
  	 *
@@@ -1073,11 -1007,8 +1117,16 @@@
  		struct tnode *tn;
  
  		tn = tnode_new(key, __fls(key ^ n->key), 1);
++<<<<<<< HEAD
 +		if (!tn) {
 +			free_leaf_info(li);
 +			node_free(l);
 +			return NULL;
 +		}
++=======
+ 		if (!tn)
+ 			goto notnode;
++>>>>>>> 8d8e810ca8ec (fib_trie: Return pointer to tnode pointer in resize/inflate/halve)
  
  		/* initialize routes out of node */
  		NODE_INIT_PARENT(tn, tp);
@@@ -1092,33 -1023,64 +1141,56 @@@
  	}
  
  	/* Case 3: n is NULL, and will just insert a new leaf */
++<<<<<<< HEAD
 +	if (tp) {
 +		NODE_INIT_PARENT(l, tp);
 +		put_child(tp, get_index(key, tp), l);
 +		trie_rebalance(t, tp);
++=======
+ 	NODE_INIT_PARENT(l, tp);
+ 	put_child_root(tp, t, key, l);
+ 	trie_rebalance(t, tp);
+ 
+ 	return 0;
+ notnode:
+ 	node_free(l);
+ noleaf:
+ 	return -ENOMEM;
+ }
+ 
+ static int fib_insert_alias(struct trie *t, struct tnode *tp,
+ 			    struct tnode *l, struct fib_alias *new,
+ 			    struct fib_alias *fa, t_key key)
+ {
+ 	if (!l)
+ 		return fib_insert_node(t, tp, new, key);
+ 
+ 	if (fa) {
+ 		hlist_add_before_rcu(&new->fa_list, &fa->fa_list);
++>>>>>>> 8d8e810ca8ec (fib_trie: Return pointer to tnode pointer in resize/inflate/halve)
  	} else {
 -		struct fib_alias *last;
 -
 -		hlist_for_each_entry(last, &l->leaf, fa_list) {
 -			if (new->fa_slen < last->fa_slen)
 -				break;
 -			fa = last;
 -		}
 -
 -		if (fa)
 -			hlist_add_behind_rcu(&new->fa_list, &fa->fa_list);
 -		else
 -			hlist_add_head_rcu(&new->fa_list, &l->leaf);
 +		rcu_assign_pointer(t->trie, l);
  	}
  
 -	/* if we added to the tail node then we need to update slen */
 -	if (l->slen < new->fa_slen) {
 -		l->slen = new->fa_slen;
 -		leaf_push_suffix(tp, l);
 -	}
 -
 -	return 0;
 +	return fa_head;
  }
  
 -/* Caller must hold RTNL. */
 +/*
 + * Caller must hold RTNL.
 + */
  int fib_table_insert(struct fib_table *tb, struct fib_config *cfg)
  {
 -	struct trie *t = (struct trie *)tb->tb_data;
 +	struct trie *t = (struct trie *) tb->tb_data;
  	struct fib_alias *fa, *new_fa;
 -	struct tnode *l, *tp;
 +	struct list_head *fa_head = NULL;
  	struct fib_info *fi;
 -	u8 plen = cfg->fc_dst_len;
 -	u8 slen = KEYLENGTH - plen;
 +	int plen = cfg->fc_dst_len;
  	u8 tos = cfg->fc_tos;
 -	u32 key;
 +	u32 key, mask;
  	int err;
 +	struct tnode *l;
  
 -	if (plen > KEYLENGTH)
 +	if (plen > 32)
  		return -EINVAL;
  
  	key = ntohl(cfg->fc_dst);
@@@ -1546,28 -1509,187 +1618,72 @@@ int fib_table_delete(struct fib_table *
  	if (!plen)
  		tb->tb_num_default--;
  
 -	fib_remove_alias(t, tp, l, fa_to_delete);
 -
 -	if (fa_to_delete->fa_state & FA_S_ACCESSED)
 -		rt_cache_flush(cfg->fc_nlinfo.nl_net);
 -
 -	fib_release_info(fa_to_delete->fa_info);
 -	alias_free_mem_rcu(fa_to_delete);
 -	return 0;
 -}
 -
 -/* Scan for the next leaf starting at the provided key value */
 -static struct tnode *leaf_walk_rcu(struct tnode **tn, t_key key)
 -{
 -	struct tnode *pn, *n = *tn;
 -	unsigned long cindex;
 -
 -	/* record parent node for backtracing */
 -	pn = n;
 -	cindex = n ? get_index(key, n) : 0;
 -
 -	/* this loop is meant to try and find the key in the trie */
 -	while (n) {
 -		unsigned long idx = get_index(key, n);
 -
 -		/* guarantee forward progress on the keys */
 -		if (IS_LEAF(n) && (n->key >= key))
 -			goto found;
 -		if (idx >= (1ul << n->bits))
 -			break;
 -
 -		/* record parent and next child index */
 -		pn = n;
 -		cindex = idx;
 -
 -		/* descend into the next child */
 -		n = tnode_get_child_rcu(pn, cindex++);
 +	if (list_empty(fa_head)) {
 +		remove_leaf_info(l, li);
 +		free_leaf_info(li);
  	}
  
 -	/* this loop will search for the next leaf with a greater key */
 -	while (pn) {
 -		/* if we exhausted the parent node we will need to climb */
 -		if (cindex >= (1ul << pn->bits)) {
 -			t_key pkey = pn->key;
 -
 -			pn = node_parent_rcu(pn);
 -			if (!pn)
 -				break;
 -
 -			cindex = get_index(pkey, pn) + 1;
 -			continue;
 -		}
 +	if (hlist_empty(&l->list))
 +		trie_leaf_remove(t, l);
  
 -		/* grab the next available node */
 -		n = tnode_get_child_rcu(pn, cindex++);
 -		if (!n)
 -			continue;
 -
 -		/* no need to compare keys since we bumped the index */
 -		if (IS_LEAF(n))
 -			goto found;
 -
 -		/* Rescan start scanning in new node */
 -		pn = n;
 -		cindex = 0;
 -	}
 -
 -	*tn = pn;
 -	return NULL; /* Root of trie */
 -found:
 -	/* if we are at the limit for keys just return NULL for the tnode */
 -	*tn = (n->key == KEY_MAX) ? NULL : pn;
 -	return n;
 -}
 -
 -/* Caller must hold RTNL */
 -void fib_table_flush_external(struct fib_table *tb)
 -{
 -	struct trie *t = (struct trie *)tb->tb_data;
 -	struct fib_alias *fa;
 -	struct tnode *n, *pn;
 -	unsigned long cindex;
 -
 -	n = rcu_dereference(t->trie);
 -	if (!n)
 -		return;
 -
 -	pn = NULL;
 -	cindex = 0;
 -
 -	while (IS_TNODE(n)) {
 -		/* record pn and cindex for leaf walking */
 -		pn = n;
 -		cindex = 1ul << n->bits;
 -backtrace:
 -		/* walk trie in reverse order */
 -		do {
 -			while (!(cindex--)) {
 -				t_key pkey = pn->key;
 -
 -				/* if we got the root we are done */
 -				pn = node_parent(pn);
 -				if (!pn)
 -					return;
 -
 -				cindex = get_index(pkey, pn);
 -			}
 -
 -			/* grab the next available node */
 -			n = tnode_get_child(pn, cindex);
 -		} while (!n);
 -	}
 -
 -	hlist_for_each_entry(fa, &n->leaf, fa_list) {
 -		struct fib_info *fi = fa->fa_info;
 -
 -		if (!fi || !(fi->fib_flags & RTNH_F_EXTERNAL))
 -			continue;
 -
 -		netdev_switch_fib_ipv4_del(n->key,
 -					   KEYLENGTH - fa->fa_slen,
 -					   fi, fa->fa_tos,
 -					   fa->fa_type, tb->tb_id);
 -	}
 +	if (fa->fa_state & FA_S_ACCESSED)
 +		rt_cache_flush(cfg->fc_nlinfo.nl_net);
  
 -	/* if trie is leaf only loop is completed */
 -	if (pn)
 -		goto backtrace;
 +	fib_release_info(fa->fa_info);
 +	alias_free_mem_rcu(fa);
 +	return 0;
  }
  
 -/* Caller must hold RTNL. */
 -int fib_table_flush(struct fib_table *tb)
 +static int trie_flush_list(struct list_head *head)
  {
 -	struct trie *t = (struct trie *)tb->tb_data;
 -	struct hlist_node *tmp;
 -	struct fib_alias *fa;
 -	struct tnode *n, *pn;
 -	unsigned long cindex;
 -	unsigned char slen;
 +	struct fib_alias *fa, *fa_node;
  	int found = 0;
  
++<<<<<<< HEAD
 +	list_for_each_entry_safe(fa, fa_node, head, fa_list) {
++=======
+ 	n = rcu_dereference(t->trie);
+ 	if (!n)
+ 		goto flush_complete;
+ 
+ 	pn = NULL;
+ 	cindex = 0;
+ 
+ 	while (IS_TNODE(n)) {
+ 		/* record pn and cindex for leaf walking */
+ 		pn = n;
+ 		cindex = 1ul << n->bits;
+ backtrace:
+ 		/* walk trie in reverse order */
+ 		do {
+ 			while (!(cindex--)) {
+ 				struct tnode __rcu **cptr;
+ 				t_key pkey = pn->key;
+ 
+ 				n = pn;
+ 				pn = node_parent(n);
+ 
+ 				/* resize completed node */
+ 				cptr = resize(t, n);
+ 
+ 				/* if we got the root we are done */
+ 				if (!pn)
+ 					goto flush_complete;
+ 
+ 				pn = container_of(cptr, struct tnode, tnode[0]);
+ 				cindex = get_index(pkey, pn);
+ 			}
+ 
+ 			/* grab the next available node */
+ 			n = tnode_get_child(pn, cindex);
+ 		} while (!n);
+ 	}
+ 
+ 	/* track slen in case any prefixes survive */
+ 	slen = 0;
+ 
+ 	hlist_for_each_entry_safe(fa, tmp, &n->leaf, fa_list) {
++>>>>>>> 8d8e810ca8ec (fib_trie: Return pointer to tnode pointer in resize/inflate/halve)
  		struct fib_info *fi = fa->fa_info;
  
  		if (fi && (fi->fib_flags & RTNH_F_DEAD)) {
* Unmerged path net/ipv4/fib_trie.c
