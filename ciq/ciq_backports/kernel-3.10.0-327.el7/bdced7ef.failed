bridge: support for multiple vlans and vlan ranges in setlink and dellink requests

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Roopa Prabhu <roopa@cumulusnetworks.com>
commit bdced7ef7838c1c4aebe9f295e44b7f0dcae2109
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/bdced7ef.failed

This patch changes bridge IFLA_AF_SPEC netlink attribute parser to
look for more than one IFLA_BRIDGE_VLAN_INFO attribute. This allows
userspace to pack more than one vlan in the setlink msg.

The dumps were already sending more than one vlan info in the getlink msg.

This patch also adds bridge_vlan_info flags BRIDGE_VLAN_INFO_RANGE_BEGIN and
BRIDGE_VLAN_INFO_RANGE_END to indicate start and end of vlan range

This patch also deletes unused ifla_br_policy.

	Signed-off-by: Roopa Prabhu <roopa@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bdced7ef7838c1c4aebe9f295e44b7f0dcae2109)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_netlink.c
diff --cc net/bridge/br_netlink.c
index 12e6d5e60e99,6f616a2df0b4..000000000000
--- a/net/bridge/br_netlink.c
+++ b/net/bridge/br_netlink.c
@@@ -231,48 -257,50 +258,73 @@@ static int br_afspec(struct net_bridge 
  		     struct nlattr *af_spec,
  		     int cmd)
  {
- 	struct nlattr *tb[IFLA_BRIDGE_MAX+1];
+ 	struct bridge_vlan_info *vinfo_start = NULL;
+ 	struct bridge_vlan_info *vinfo = NULL;
+ 	struct nlattr *attr;
  	int err = 0;
+ 	int rem;
  
- 	err = nla_parse_nested(tb, IFLA_BRIDGE_MAX, af_spec, ifla_br_policy);
- 	if (err)
- 		return err;
+ 	nla_for_each_nested(attr, af_spec, rem) {
+ 		if (nla_type(attr) != IFLA_BRIDGE_VLAN_INFO)
+ 			continue;
+ 		if (nla_len(attr) != sizeof(struct bridge_vlan_info))
+ 			return -EINVAL;
+ 		vinfo = nla_data(attr);
+ 		if (vinfo->flags & BRIDGE_VLAN_INFO_RANGE_BEGIN) {
+ 			if (vinfo_start)
+ 				return -EINVAL;
+ 			vinfo_start = vinfo;
+ 			continue;
+ 		}
  
- 	if (tb[IFLA_BRIDGE_VLAN_INFO]) {
- 		struct bridge_vlan_info *vinfo;
+ 		if (vinfo_start) {
+ 			struct bridge_vlan_info tmp_vinfo;
+ 			int v;
  
- 		vinfo = nla_data(tb[IFLA_BRIDGE_VLAN_INFO]);
+ 			if (!(vinfo->flags & BRIDGE_VLAN_INFO_RANGE_END))
+ 				return -EINVAL;
  
- 		if (!vinfo->vid || vinfo->vid >= VLAN_VID_MASK)
- 			return -EINVAL;
+ 			if (vinfo->vid <= vinfo_start->vid)
+ 				return -EINVAL;
  
- 		switch (cmd) {
- 		case RTM_SETLINK:
- 			if (p) {
- 				err = nbp_vlan_add(p, vinfo->vid, vinfo->flags);
+ 			memcpy(&tmp_vinfo, vinfo_start,
+ 			       sizeof(struct bridge_vlan_info));
+ 
+ 			for (v = vinfo_start->vid; v <= vinfo->vid; v++) {
+ 				tmp_vinfo.vid = v;
+ 				err = br_vlan_info(br, p, cmd, &tmp_vinfo);
  				if (err)
  					break;
++<<<<<<< HEAD
 +
 +				if (vinfo->flags & BRIDGE_VLAN_INFO_MASTER)
 +					err = br_vlan_add(p->br, vinfo->vid,
 +							  vinfo->flags);
 +			} else
 +				err = br_vlan_add(br, vinfo->vid, vinfo->flags);
 +
 +			if (err)
 +				break;
 +
 +			break;
 +
 +		case RTM_DELLINK:
 +			if (p) {
 +				nbp_vlan_delete(p, vinfo->vid);
 +				if (vinfo->flags & BRIDGE_VLAN_INFO_MASTER)
 +					br_vlan_delete(p->br, vinfo->vid);
 +			} else
 +				br_vlan_delete(br, vinfo->vid);
 +			break;
++=======
+ 			}
+ 			vinfo_start = NULL;
+ 		} else {
+ 			err = br_vlan_info(br, p, cmd, vinfo);
++>>>>>>> bdced7ef7838 (bridge: support for multiple vlans and vlan ranges in setlink and dellink requests)
  		}
+ 		if (err)
+ 			break;
  	}
  
  	return err;
diff --git a/include/uapi/linux/if_bridge.h b/include/uapi/linux/if_bridge.h
index 2d70d79ce2fd..96465542a75a 100644
--- a/include/uapi/linux/if_bridge.h
+++ b/include/uapi/linux/if_bridge.h
@@ -122,6 +122,8 @@ enum {
 #define BRIDGE_VLAN_INFO_MASTER	(1<<0)	/* Operate on Bridge device as well */
 #define BRIDGE_VLAN_INFO_PVID	(1<<1)	/* VLAN is PVID, ingress untagged */
 #define BRIDGE_VLAN_INFO_UNTAGGED	(1<<2)	/* VLAN egresses untagged */
+#define BRIDGE_VLAN_INFO_RANGE_BEGIN	(1<<3) /* VLAN is start of vlan range */
+#define BRIDGE_VLAN_INFO_RANGE_END	(1<<4) /* VLAN is end of vlan range */
 
 struct bridge_vlan_info {
 	__u16 flags;
* Unmerged path net/bridge/br_netlink.c
