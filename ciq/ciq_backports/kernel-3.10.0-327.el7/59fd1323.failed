KVM: x86: keep track of LVT0 changes under APICv

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [x86] kvm: keep track of LVT0 changes under APICv (Radim Krcmar) [1236434]
Rebuild_FUZZ: 94.51%
commit-author Radim Krčmář <rkrcmar@redhat.com>
commit 59fd132340b3e37b83179d2fcb673980035edf62
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/59fd1323.failed

Memory-mapped LVT0 register already contains the new value when APICv
traps so we can't directly detect a change.
Memorize a bit we are interested in to enable legacy NMI watchdog.

	Suggested-by: Yoshida Nobuo <yoshida.nb@ncos.nec.co.jp>
	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 59fd132340b3e37b83179d2fcb673980035edf62)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/lapic.c
diff --cc arch/x86/kvm/lapic.c
index 3b33363e0cac,954e98a8c2e3..000000000000
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@@ -1522,8 -1595,10 +1523,15 @@@ void kvm_lapic_reset(struct kvm_vcpu *v
  	for (i = 0; i < APIC_LVT_NUM; i++)
  		apic_set_reg(apic, APIC_LVTT + 0x10 * i, APIC_LVT_MASKED);
  	apic_update_lvtt(apic);
++<<<<<<< HEAD
 +	apic_set_reg(apic, APIC_LVT0,
 +		     SET_APIC_DELIVERY_MODE(0, APIC_MODE_EXTINT));
++=======
+ 	if (!(vcpu->kvm->arch.disabled_quirks & KVM_QUIRK_LINT0_REENABLED))
+ 		apic_set_reg(apic, APIC_LVT0,
+ 			     SET_APIC_DELIVERY_MODE(0, APIC_MODE_EXTINT));
+ 	apic_manage_nmi_watchdog(apic, kvm_apic_get_reg(apic, APIC_LVT0));
++>>>>>>> 59fd132340b3 (KVM: x86: keep track of LVT0 changes under APICv)
  
  	apic_set_reg(apic, APIC_DFR, 0xffffffffU);
  	apic_set_spiv(apic, 0xff);
* Unmerged path arch/x86/kvm/lapic.c
diff --git a/arch/x86/kvm/lapic.h b/arch/x86/kvm/lapic.h
index d3d6e92764fd..a1a7fbb56042 100644
--- a/arch/x86/kvm/lapic.h
+++ b/arch/x86/kvm/lapic.h
@@ -25,6 +25,7 @@ struct kvm_lapic {
 	struct kvm_vcpu *vcpu;
 	bool sw_enabled;
 	bool irr_pending;
+	bool lvt0_in_nmi_mode;
 	/* Number of bits set in ISR. */
 	s16 isr_count;
 	/* The highest vector set in ISR; if -1 - invalid, must scan ISR. */
