net/mlx4_en: Add interface identify support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [netdrv] mlx4_en: Add interface identify support (Amir Vadai) [1164527 1164530 1164531 1164536 1164537]
Rebuild_FUZZ: 95.12%
commit-author Ido Shamay <idos@mellanox.com>
commit 51af33cfed248dc8f36fa82df06b85e10038a01e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/51af33cf.failed

Add support for the interface ethtool identify feature.

Make the physical port LED to blink with green and yellow colors.

The device handles the LED blink by itself (synchrous use of
set_phys_id), by returning 0 to ETHTOOL_ID_ACTIVE command.

	Signed-off-by: Eyal Grossman <eyalgr@mellanox.com>
	Signed-off-by: Ido Shamay <idos@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 51af33cfed248dc8f36fa82df06b85e10038a01e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx4/fw.c
#	include/linux/mlx4/device.h
diff --cc drivers/net/ethernet/mellanox/mlx4/fw.c
index 8976ba4929d3,6317844b291f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/fw.c
+++ b/drivers/net/ethernet/mellanox/mlx4/fw.c
@@@ -139,7 -139,18 +139,22 @@@ static void dump_dev_cap_flags2(struct 
  		[13] = "Large cache line (>64B) EQE stride support",
  		[14] = "Ethernet protocol control support",
  		[15] = "Ethernet Backplane autoneg support",
++<<<<<<< HEAD
 +		[16] = "CONFIG DEV support"
++=======
+ 		[16] = "CONFIG DEV support",
+ 		[17] = "Asymmetric EQs support",
+ 		[18] = "More than 80 VFs support",
+ 		[19] = "Performance optimized for limited rule configuration flow steering support",
+ 		[20] = "Recoverable error events support",
+ 		[21] = "Port Remap support",
+ 		[22] = "QCN support",
+ 		[23] = "QP rate limiting support",
+ 		[24] = "Ethernet Flow control statistics support",
+ 		[25] = "Granular QoS per VF support",
+ 		[26] = "Port ETS Scheduler support",
+ 		[27] = "Port beacon support",
++>>>>>>> 51af33cfed24 (net/mlx4_en: Add interface identify support)
  	};
  	int i;
  
@@@ -1064,11 -1165,16 +1083,16 @@@ int mlx4_QUERY_DEV_CAP_wrapper(struct m
  	field &= 0x7f;
  	MLX4_PUT(outbox->buf, field, QUERY_DEV_CAP_CQ_TS_SUPPORT_OFFSET);
  
 -	/* For guests, disable vxlan tunneling and QoS support */
 +	/* For guests, disable vxlan tunneling */
  	MLX4_GET(field, outbox->buf, QUERY_DEV_CAP_VXLAN);
 -	field &= 0xd7;
 +	field &= 0xf7;
  	MLX4_PUT(outbox->buf, field, QUERY_DEV_CAP_VXLAN);
  
+ 	/* For guests, disable port BEACON */
+ 	MLX4_GET(field, outbox->buf, QUERY_DEV_CAP_PORT_BEACON_OFFSET);
+ 	field &= 0x7f;
+ 	MLX4_PUT(outbox->buf, field, QUERY_DEV_CAP_PORT_BEACON_OFFSET);
+ 
  	/* For guests, report Blueflame disabled */
  	MLX4_GET(field, outbox->buf, QUERY_DEV_CAP_BF_OFFSET);
  	field &= 0x7f;
diff --cc include/linux/mlx4/device.h
index 7c7eeeb434eb,b761be7c88c8..000000000000
--- a/include/linux/mlx4/device.h
+++ b/include/linux/mlx4/device.h
@@@ -189,7 -197,18 +189,22 @@@ enum 
  	MLX4_DEV_CAP_FLAG2_EQE_STRIDE		= 1LL <<  13,
  	MLX4_DEV_CAP_FLAG2_ETH_PROT_CTRL        = 1LL <<  14,
  	MLX4_DEV_CAP_FLAG2_ETH_BACKPL_AN_REP	= 1LL <<  15,
++<<<<<<< HEAD
 +	MLX4_DEV_CAP_FLAG2_CONFIG_DEV		= 1LL <<  16
++=======
+ 	MLX4_DEV_CAP_FLAG2_CONFIG_DEV		= 1LL <<  16,
+ 	MLX4_DEV_CAP_FLAG2_SYS_EQS		= 1LL <<  17,
+ 	MLX4_DEV_CAP_FLAG2_80_VFS		= 1LL <<  18,
+ 	MLX4_DEV_CAP_FLAG2_FS_A0		= 1LL <<  19,
+ 	MLX4_DEV_CAP_FLAG2_RECOVERABLE_ERROR_EVENT = 1LL << 20,
+ 	MLX4_DEV_CAP_FLAG2_PORT_REMAP		= 1LL <<  21,
+ 	MLX4_DEV_CAP_FLAG2_QCN			= 1LL <<  22,
+ 	MLX4_DEV_CAP_FLAG2_QP_RATE_LIMIT	= 1LL <<  23,
+ 	MLX4_DEV_CAP_FLAG2_FLOWSTATS_EN         = 1LL <<  24,
+ 	MLX4_DEV_CAP_FLAG2_QOS_VPP		= 1LL <<  25,
+ 	MLX4_DEV_CAP_FLAG2_ETS_CFG		= 1LL <<  26,
+ 	MLX4_DEV_CAP_FLAG2_PORT_BEACON		= 1LL <<  27,
++>>>>>>> 51af33cfed24 (net/mlx4_en: Add interface identify support)
  };
  
  enum {
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
index 1b8da57abd19..742a5f029624 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
@@ -1753,6 +1753,32 @@ static int mlx4_en_get_module_eeprom(struct net_device *dev,
 	return 0;
 }
 
+static int mlx4_en_set_phys_id(struct net_device *dev,
+			       enum ethtool_phys_id_state state)
+{
+	int err;
+	u16 beacon_duration;
+	struct mlx4_en_priv *priv = netdev_priv(dev);
+	struct mlx4_en_dev *mdev = priv->mdev;
+
+	if (!(mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_PORT_BEACON))
+		return -EOPNOTSUPP;
+
+	switch (state) {
+	case ETHTOOL_ID_ACTIVE:
+		beacon_duration = PORT_BEACON_MAX_LIMIT;
+		break;
+	case ETHTOOL_ID_INACTIVE:
+		beacon_duration = 0;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	err = mlx4_SET_PORT_BEACON(mdev->dev, priv->port, beacon_duration);
+	return err;
+}
+
 const struct ethtool_ops mlx4_en_ethtool_ops = {
 	.get_drvinfo = mlx4_en_get_drvinfo,
 	.get_settings = mlx4_en_get_settings,
@@ -1762,6 +1788,7 @@ const struct ethtool_ops mlx4_en_ethtool_ops = {
 	.get_sset_count = mlx4_en_get_sset_count,
 	.get_ethtool_stats = mlx4_en_get_ethtool_stats,
 	.self_test = mlx4_en_self_test,
+	.set_phys_id = mlx4_en_set_phys_id,
 	.get_wol = mlx4_en_get_wol,
 	.set_wol = mlx4_en_set_wol,
 	.get_msglevel = mlx4_en_get_msglevel,
* Unmerged path drivers/net/ethernet/mellanox/mlx4/fw.c
diff --git a/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h b/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
index 29a881cbb841..654898208eb7 100644
--- a/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
+++ b/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
@@ -482,6 +482,7 @@ enum {
 	MLX4_EN_FLAG_RX_CSUM_NON_TCP_UDP	= (1 << 5),
 };
 
+#define PORT_BEACON_MAX_LIMIT (65535)
 #define MLX4_EN_MAC_HASH_SIZE (1 << BITS_PER_BYTE)
 #define MLX4_EN_MAC_HASH_IDX 5
 
diff --git a/drivers/net/ethernet/mellanox/mlx4/port.c b/drivers/net/ethernet/mellanox/mlx4/port.c
index feb223aa98f5..ad374babe7b6 100644
--- a/drivers/net/ethernet/mellanox/mlx4/port.c
+++ b/drivers/net/ethernet/mellanox/mlx4/port.c
@@ -840,6 +840,12 @@ static int mlx4_common_set_port(struct mlx4_dev *dev, int slave, u32 in_mod,
 				MLX4_CMD_NATIVE);
 	}
 
+	/* Slaves are not allowed to SET_PORT beacon (LED) blink */
+	if (op_mod == MLX4_SET_PORT_BEACON_OPCODE) {
+		mlx4_warn(dev, "denying SET_PORT Beacon slave:%d\n", slave);
+		return -EPERM;
+	}
+
 	/* For IB, we only consider:
 	 * - The capability mask, which is set to the aggregate of all
 	 *   slave function capabilities
@@ -1069,6 +1075,26 @@ int mlx4_SET_PORT_VXLAN(struct mlx4_dev *dev, u8 port, u8 steering, int enable)
 }
 EXPORT_SYMBOL(mlx4_SET_PORT_VXLAN);
 
+int mlx4_SET_PORT_BEACON(struct mlx4_dev *dev, u8 port, u16 time)
+{
+	int err;
+	struct mlx4_cmd_mailbox *mailbox;
+
+	mailbox = mlx4_alloc_cmd_mailbox(dev);
+	if (IS_ERR(mailbox))
+		return PTR_ERR(mailbox);
+
+	*((__be32 *)mailbox->buf) = cpu_to_be32(time);
+
+	err = mlx4_cmd(dev, mailbox->dma, port, MLX4_SET_PORT_BEACON_OPCODE,
+		       MLX4_CMD_SET_PORT, MLX4_CMD_TIME_CLASS_B,
+		       MLX4_CMD_NATIVE);
+
+	mlx4_free_cmd_mailbox(dev, mailbox);
+	return err;
+}
+EXPORT_SYMBOL(mlx4_SET_PORT_BEACON);
+
 int mlx4_SET_MCAST_FLTR_wrapper(struct mlx4_dev *dev, int slave,
 				struct mlx4_vhcr *vhcr,
 				struct mlx4_cmd_mailbox *inbox,
diff --git a/include/linux/mlx4/cmd.h b/include/linux/mlx4/cmd.h
index 0aa19a3dabb9..684924870606 100644
--- a/include/linux/mlx4/cmd.h
+++ b/include/linux/mlx4/cmd.h
@@ -181,6 +181,7 @@ enum {
 	/* Set port opcode modifiers */
 	MLX4_SET_PORT_IB_OPCODE		= 0x0,
 	MLX4_SET_PORT_ETH_OPCODE	= 0x1,
+	MLX4_SET_PORT_BEACON_OPCODE	= 0x4,
 };
 
 enum {
* Unmerged path include/linux/mlx4/device.h
