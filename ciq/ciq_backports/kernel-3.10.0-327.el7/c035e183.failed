cxgb4: Initialize RSS mode for all Ports

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Hariprasad Shenai <hariprasad@chelsio.com>
commit c035e183ebfe6905dd0d31f7fe356cc3cfe00893
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/c035e183.failed

Implements t4_init_rss_mode() to initialize the rss_mode for all the ports. If
Tunnel All Lookup isn't specified in the global RSS Configuration, then we need
to specify a default Ingress Queue for any ingress packets which aren't hashed.
We'll use our first ingress queue.

	Signed-off-by: Hariprasad Shenai <hariprasad@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c035e183ebfe6905dd0d31f7fe356cc3cfe00893)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
#	drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
index dddf17cba9bf,932ab3b72a4d..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
@@@ -1011,6 -1208,18 +1012,21 @@@ int t4_config_rss_range(struct adapter 
  			int start, int n, const u16 *rspq, unsigned int nrspq);
  int t4_config_glbl_rss(struct adapter *adapter, int mbox, unsigned int mode,
  		       unsigned int flags);
++<<<<<<< HEAD
++=======
+ int t4_config_vi_rss(struct adapter *adapter, int mbox, unsigned int viid,
+ 		     unsigned int flags, unsigned int defq);
+ int t4_read_rss(struct adapter *adapter, u16 *entries);
+ void t4_read_rss_key(struct adapter *adapter, u32 *key);
+ void t4_write_rss_key(struct adapter *adap, const u32 *key, int idx);
+ void t4_read_rss_pf_config(struct adapter *adapter, unsigned int index,
+ 			   u32 *valp);
+ void t4_read_rss_vf_config(struct adapter *adapter, unsigned int index,
+ 			   u32 *vfl, u32 *vfh);
+ u32 t4_read_rss_pf_map(struct adapter *adapter);
+ u32 t4_read_rss_pf_mask(struct adapter *adapter);
+ 
++>>>>>>> c035e183ebfe (cxgb4: Initialize RSS mode for all Ports)
  int t4_mc_read(struct adapter *adap, int idx, u32 addr, __be32 *data,
  	       u64 *parity);
  int t4_edc_read(struct adapter *adap, int idx, u32 addr, __be32 *data,
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
index 2a3e5627b439,223995e7b643..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@@ -937,8 -856,9 +937,9 @@@ static void free_msix_queue_irqs(struc
   *
   *	Sets up the portion of the HW RSS table for the port's VI to distribute
   *	packets to the Rx queues in @queues.
+  *	Should never be called before setting up sge eth rx queues
   */
 -int cxgb4_write_rss(const struct port_info *pi, const u16 *queues)
 +static int write_rss(const struct port_info *pi, const u16 *queues)
  {
  	u16 *rss;
  	int i, err;
@@@ -971,7 -906,11 +987,15 @@@ static int setup_rss(struct adapter *ad
  	for_each_port(adap, i) {
  		const struct port_info *pi = adap2pinfo(adap, i);
  
++<<<<<<< HEAD
 +		err = write_rss(pi, pi->rss);
++=======
+ 		/* Fill default values with equal distribution */
+ 		for (j = 0; j < pi->rss_size; j++)
+ 			pi->rss[j] = j % pi->nqsets;
+ 
+ 		err = cxgb4_write_rss(pi, pi->rss);
++>>>>>>> c035e183ebfe (cxgb4: Initialize RSS mode for all Ports)
  		if (err)
  			return err;
  	}
diff --cc drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
index 4234b8c917e7,c626252e51d4..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
@@@ -2204,6 -3014,172 +2204,175 @@@ int t4_config_glbl_rss(struct adapter *
  	return t4_wr_mbox(adapter, mbox, &c, sizeof(c), NULL);
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  *	t4_config_vi_rss - configure per VI RSS settings
+  *	@adapter: the adapter
+  *	@mbox: mbox to use for the FW command
+  *	@viid: the VI id
+  *	@flags: RSS flags
+  *	@defq: id of the default RSS queue for the VI.
+  *
+  *	Configures VI-specific RSS properties.
+  */
+ int t4_config_vi_rss(struct adapter *adapter, int mbox, unsigned int viid,
+ 		     unsigned int flags, unsigned int defq)
+ {
+ 	struct fw_rss_vi_config_cmd c;
+ 
+ 	memset(&c, 0, sizeof(c));
+ 	c.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_RSS_VI_CONFIG_CMD) |
+ 				   FW_CMD_REQUEST_F | FW_CMD_WRITE_F |
+ 				   FW_RSS_VI_CONFIG_CMD_VIID_V(viid));
+ 	c.retval_len16 = cpu_to_be32(FW_LEN16(c));
+ 	c.u.basicvirtual.defaultq_to_udpen = cpu_to_be32(flags |
+ 					FW_RSS_VI_CONFIG_CMD_DEFAULTQ_V(defq));
+ 	return t4_wr_mbox(adapter, mbox, &c, sizeof(c), NULL);
+ }
+ 
+ /* Read an RSS table row */
+ static int rd_rss_row(struct adapter *adap, int row, u32 *val)
+ {
+ 	t4_write_reg(adap, TP_RSS_LKP_TABLE_A, 0xfff00000 | row);
+ 	return t4_wait_op_done_val(adap, TP_RSS_LKP_TABLE_A, LKPTBLROWVLD_F, 1,
+ 				   5, 0, val);
+ }
+ 
+ /**
+  *	t4_read_rss - read the contents of the RSS mapping table
+  *	@adapter: the adapter
+  *	@map: holds the contents of the RSS mapping table
+  *
+  *	Reads the contents of the RSS hash->queue mapping table.
+  */
+ int t4_read_rss(struct adapter *adapter, u16 *map)
+ {
+ 	u32 val;
+ 	int i, ret;
+ 
+ 	for (i = 0; i < RSS_NENTRIES / 2; ++i) {
+ 		ret = rd_rss_row(adapter, i, &val);
+ 		if (ret)
+ 			return ret;
+ 		*map++ = LKPTBLQUEUE0_G(val);
+ 		*map++ = LKPTBLQUEUE1_G(val);
+ 	}
+ 	return 0;
+ }
+ 
+ /**
+  *	t4_read_rss_key - read the global RSS key
+  *	@adap: the adapter
+  *	@key: 10-entry array holding the 320-bit RSS key
+  *
+  *	Reads the global 320-bit RSS key.
+  */
+ void t4_read_rss_key(struct adapter *adap, u32 *key)
+ {
+ 	t4_read_indirect(adap, TP_PIO_ADDR_A, TP_PIO_DATA_A, key, 10,
+ 			 TP_RSS_SECRET_KEY0_A);
+ }
+ 
+ /**
+  *	t4_write_rss_key - program one of the RSS keys
+  *	@adap: the adapter
+  *	@key: 10-entry array holding the 320-bit RSS key
+  *	@idx: which RSS key to write
+  *
+  *	Writes one of the RSS keys with the given 320-bit value.  If @idx is
+  *	0..15 the corresponding entry in the RSS key table is written,
+  *	otherwise the global RSS key is written.
+  */
+ void t4_write_rss_key(struct adapter *adap, const u32 *key, int idx)
+ {
+ 	t4_write_indirect(adap, TP_PIO_ADDR_A, TP_PIO_DATA_A, key, 10,
+ 			  TP_RSS_SECRET_KEY0_A);
+ 	if (idx >= 0 && idx < 16)
+ 		t4_write_reg(adap, TP_RSS_CONFIG_VRT_A,
+ 			     KEYWRADDR_V(idx) | KEYWREN_F);
+ }
+ 
+ /**
+  *	t4_read_rss_pf_config - read PF RSS Configuration Table
+  *	@adapter: the adapter
+  *	@index: the entry in the PF RSS table to read
+  *	@valp: where to store the returned value
+  *
+  *	Reads the PF RSS Configuration Table at the specified index and returns
+  *	the value found there.
+  */
+ void t4_read_rss_pf_config(struct adapter *adapter, unsigned int index,
+ 			   u32 *valp)
+ {
+ 	t4_read_indirect(adapter, TP_PIO_ADDR_A, TP_PIO_DATA_A,
+ 			 valp, 1, TP_RSS_PF0_CONFIG_A + index);
+ }
+ 
+ /**
+  *	t4_read_rss_vf_config - read VF RSS Configuration Table
+  *	@adapter: the adapter
+  *	@index: the entry in the VF RSS table to read
+  *	@vfl: where to store the returned VFL
+  *	@vfh: where to store the returned VFH
+  *
+  *	Reads the VF RSS Configuration Table at the specified index and returns
+  *	the (VFL, VFH) values found there.
+  */
+ void t4_read_rss_vf_config(struct adapter *adapter, unsigned int index,
+ 			   u32 *vfl, u32 *vfh)
+ {
+ 	u32 vrt, mask, data;
+ 
+ 	mask = VFWRADDR_V(VFWRADDR_M);
+ 	data = VFWRADDR_V(index);
+ 
+ 	/* Request that the index'th VF Table values be read into VFL/VFH.
+ 	 */
+ 	vrt = t4_read_reg(adapter, TP_RSS_CONFIG_VRT_A);
+ 	vrt &= ~(VFRDRG_F | VFWREN_F | KEYWREN_F | mask);
+ 	vrt |= data | VFRDEN_F;
+ 	t4_write_reg(adapter, TP_RSS_CONFIG_VRT_A, vrt);
+ 
+ 	/* Grab the VFL/VFH values ...
+ 	 */
+ 	t4_read_indirect(adapter, TP_PIO_ADDR_A, TP_PIO_DATA_A,
+ 			 vfl, 1, TP_RSS_VFL_CONFIG_A);
+ 	t4_read_indirect(adapter, TP_PIO_ADDR_A, TP_PIO_DATA_A,
+ 			 vfh, 1, TP_RSS_VFH_CONFIG_A);
+ }
+ 
+ /**
+  *	t4_read_rss_pf_map - read PF RSS Map
+  *	@adapter: the adapter
+  *
+  *	Reads the PF RSS Map register and returns its value.
+  */
+ u32 t4_read_rss_pf_map(struct adapter *adapter)
+ {
+ 	u32 pfmap;
+ 
+ 	t4_read_indirect(adapter, TP_PIO_ADDR_A, TP_PIO_DATA_A,
+ 			 &pfmap, 1, TP_RSS_PF_MAP_A);
+ 	return pfmap;
+ }
+ 
+ /**
+  *	t4_read_rss_pf_mask - read PF RSS Mask
+  *	@adapter: the adapter
+  *
+  *	Reads the PF RSS Mask register and returns its value.
+  */
+ u32 t4_read_rss_pf_mask(struct adapter *adapter)
+ {
+ 	u32 pfmask;
+ 
+ 	t4_read_indirect(adapter, TP_PIO_ADDR_A, TP_PIO_DATA_A,
+ 			 &pfmask, 1, TP_RSS_PF_MSK_A);
+ 	return pfmask;
+ }
+ 
++>>>>>>> c035e183ebfe (cxgb4: Initialize RSS mode for all Ports)
  /**
   *	t4_tp_get_tcp_stats - read TP's TCP MIB counters
   *	@adap: the adapter
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
