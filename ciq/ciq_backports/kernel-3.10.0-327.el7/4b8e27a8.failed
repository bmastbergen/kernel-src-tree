cxgb4: Allocate dynamic mem. for egress and ingress queue maps

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Hariprasad Shenai <hariprasad@chelsio.com>
commit 4b8e27a86d209063d8aacfb918668bbb75e56019
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/4b8e27a8.failed

QIDs (egress/ingress) from firmware in FW_*_CMD.alloc command
can be anywhere in the range from EQ(IQFLINT)_START to EQ(IQFLINT)_END.
For eg, in the first load eqid can be from 100 to 300.
In the next load it can be from 301 to 500 (assume eq_start is 100 and eq_end is
1000).

The driver was assuming them to always start from EQ(IQFLINT)_START till
MAX_EGRQ(INGQ). This was causing stack overflow and subsequent crash.

Fixed it by dynamically allocating memory (of qsize (x_END - x_START + 1)) for
these structures.

Based on original work by Santosh Rastapur <santosh@chelsio.com>

	Signed-off-by: Hariprasad Shenai <hariprasad@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4b8e27a86d209063d8aacfb918668bbb75e56019)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
index 6b10b0dc9878,b9b5a7b1a116..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@@ -994,11 -920,17 +994,11 @@@ static void quiesce_rx(struct adapter *
  {
  	int i;
  
- 	for (i = 0; i < ARRAY_SIZE(adap->sge.ingr_map); i++) {
+ 	for (i = 0; i < adap->sge.ingr_sz; i++) {
  		struct sge_rspq *q = adap->sge.ingr_map[i];
  
 -		if (q && q->handler) {
 +		if (q && q->handler)
  			napi_disable(&q->napi);
 -			local_bh_disable();
 -			while (!cxgb_poll_lock_napi(q))
 -				mdelay(1);
 -			local_bh_enable();
 -		}
 -
  	}
  }
  
@@@ -5736,6 -5307,59 +5750,62 @@@ static int adap_init0(struct adapter *a
  	adap->tids.nftids = val[4] - val[3] + 1;
  	adap->sge.ingr_start = val[5];
  
++<<<<<<< HEAD
++=======
+ 	/* qids (ingress/egress) returned from firmware can be anywhere
+ 	 * in the range from EQ(IQFLINT)_START to EQ(IQFLINT)_END.
+ 	 * Hence driver needs to allocate memory for this range to
+ 	 * store the queue info. Get the highest IQFLINT/EQ index returned
+ 	 * in FW_EQ_*_CMD.alloc command.
+ 	 */
+ 	params[0] = FW_PARAM_PFVF(EQ_END);
+ 	params[1] = FW_PARAM_PFVF(IQFLINT_END);
+ 	ret = t4_query_params(adap, adap->mbox, adap->fn, 0, 2, params, val);
+ 	if (ret < 0)
+ 		goto bye;
+ 	adap->sge.egr_sz = val[0] - adap->sge.egr_start + 1;
+ 	adap->sge.ingr_sz = val[1] - adap->sge.ingr_start + 1;
+ 
+ 	adap->sge.egr_map = kcalloc(adap->sge.egr_sz,
+ 				    sizeof(*adap->sge.egr_map), GFP_KERNEL);
+ 	if (!adap->sge.egr_map) {
+ 		ret = -ENOMEM;
+ 		goto bye;
+ 	}
+ 
+ 	adap->sge.ingr_map = kcalloc(adap->sge.ingr_sz,
+ 				     sizeof(*adap->sge.ingr_map), GFP_KERNEL);
+ 	if (!adap->sge.ingr_map) {
+ 		ret = -ENOMEM;
+ 		goto bye;
+ 	}
+ 
+ 	/* Allocate the memory for the vaious egress queue bitmaps
+ 	 * ie starving_fl and txq_maperr.
+ 	 */
+ 	adap->sge.starving_fl =	kcalloc(BITS_TO_LONGS(adap->sge.egr_sz),
+ 					sizeof(long), GFP_KERNEL);
+ 	if (!adap->sge.starving_fl) {
+ 		ret = -ENOMEM;
+ 		goto bye;
+ 	}
+ 
+ 	adap->sge.txq_maperr = kcalloc(BITS_TO_LONGS(adap->sge.egr_sz),
+ 				       sizeof(long), GFP_KERNEL);
+ 	if (!adap->sge.txq_maperr) {
+ 		ret = -ENOMEM;
+ 		goto bye;
+ 	}
+ 
+ 	params[0] = FW_PARAM_PFVF(CLIP_START);
+ 	params[1] = FW_PARAM_PFVF(CLIP_END);
+ 	ret = t4_query_params(adap, adap->mbox, adap->fn, 0, 2, params, val);
+ 	if (ret < 0)
+ 		goto bye;
+ 	adap->clipt_start = val[0];
+ 	adap->clipt_end = val[1];
+ 
++>>>>>>> 4b8e27a86d20 (cxgb4: Allocate dynamic mem. for egress and ingress queue maps)
  	/* query params related to active filter region */
  	params[0] = FW_PARAM_PFVF(ACTIVE_FILTER_START);
  	params[1] = FW_PARAM_PFVF(ACTIVE_FILTER_END);
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
index dddf17cba9bf..4df7a06a9e2c 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
@@ -375,8 +375,6 @@ enum {
 enum {
 	INGQ_EXTRAS = 2,        /* firmware event queue and */
 				/*   forwarded interrupts */
-	MAX_EGRQ = MAX_ETH_QSETS*2 + MAX_OFLD_QSETS*2
-		   + MAX_CTRL_QUEUES + MAX_RDMA_QUEUES + MAX_ISCSI_QUEUES,
 	MAX_INGQ = MAX_ETH_QSETS + MAX_OFLD_QSETS + MAX_RDMA_QUEUES
 		   + MAX_RDMA_CIQS + MAX_ISCSI_QUEUES + INGQ_EXTRAS,
 };
@@ -588,11 +586,13 @@ struct sge {
 	unsigned int idma_qid[2];   /* SGE IDMA Hung Ingress Queue ID */
 
 	unsigned int egr_start;
+	unsigned int egr_sz;
 	unsigned int ingr_start;
-	void *egr_map[MAX_EGRQ];    /* qid->queue egress queue map */
-	struct sge_rspq *ingr_map[MAX_INGQ]; /* qid->queue ingress queue map */
-	DECLARE_BITMAP(starving_fl, MAX_EGRQ);
-	DECLARE_BITMAP(txq_maperr, MAX_EGRQ);
+	unsigned int ingr_sz;
+	void **egr_map;    /* qid->queue egress queue map */
+	struct sge_rspq **ingr_map; /* qid->queue ingress queue map */
+	unsigned long *starving_fl;
+	unsigned long *txq_maperr;
 	struct timer_list rx_timer; /* refills starving FLs */
 	struct timer_list tx_timer; /* checks Tx queues */
 };
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
diff --git a/drivers/net/ethernet/chelsio/cxgb4/sge.c b/drivers/net/ethernet/chelsio/cxgb4/sge.c
index b5afc3f0dd91..8e50ae3600fd 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/sge.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/sge.c
@@ -2109,7 +2109,7 @@ static void sge_rx_timer_cb(unsigned long data)
 	struct adapter *adap = (struct adapter *)data;
 	struct sge *s = &adap->sge;
 
-	for (i = 0; i < ARRAY_SIZE(s->starving_fl); i++)
+	for (i = 0; i < BITS_TO_LONGS(s->egr_sz); i++)
 		for (m = s->starving_fl[i]; m; m &= m - 1) {
 			struct sge_eth_rxq *rxq;
 			unsigned int id = __ffs(m) + i * BITS_PER_LONG;
@@ -2197,7 +2197,7 @@ static void sge_tx_timer_cb(unsigned long data)
 	struct adapter *adap = (struct adapter *)data;
 	struct sge *s = &adap->sge;
 
-	for (i = 0; i < ARRAY_SIZE(s->txq_maperr); i++)
+	for (i = 0; i < BITS_TO_LONGS(s->egr_sz); i++)
 		for (m = s->txq_maperr[i]; m; m &= m - 1) {
 			unsigned long id = __ffs(m) + i * BITS_PER_LONG;
 			struct sge_ofld_txq *txq = s->egr_map[id];
@@ -2687,7 +2687,8 @@ void t4_free_sge_resources(struct adapter *adap)
 		free_rspq_fl(adap, &adap->sge.intrq, NULL);
 
 	/* clear the reverse egress queue map */
-	memset(adap->sge.egr_map, 0, sizeof(adap->sge.egr_map));
+	memset(adap->sge.egr_map, 0,
+	       adap->sge.egr_sz * sizeof(*adap->sge.egr_map));
 }
 
 void t4_sge_start(struct adapter *adap)
