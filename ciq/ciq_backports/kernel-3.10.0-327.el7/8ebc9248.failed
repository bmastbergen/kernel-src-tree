hpsa: refactor duplicated scan completion code into a new routine

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Webb Scales <webbnh@hp.com>
commit 8ebc92483211f49ee5f072d2e51de3e70ca05fc1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/8ebc9248.failed

Hoist the conditional out of do_not_scan_if_controller_locked_up() and
place it in the caller (this improves the code structure, making it
more consistent with other uses and enabling tail-call optimization);
rename the function to hpsa_scan_complete(), and use it at the end of
hpsa_scan_start() as well.

	Reviewed-by: Scott Teel <scott.teel@pmcs.com>
	Signed-off-by: Webb Scales <webbnh@hp.com>
	Signed-off-by: Don Brace <don.brace@pmcs.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 8ebc92483211f49ee5f072d2e51de3e70ca05fc1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/hpsa.c
diff --cc drivers/scsi/hpsa.c
index ab6d9cd2a03c,a92653a18bd2..000000000000
--- a/drivers/scsi/hpsa.c
+++ b/drivers/scsi/hpsa.c
@@@ -3945,25 -4055,108 +3945,112 @@@ static int hpsa_scsi_queue_command(stru
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int do_not_scan_if_controller_locked_up(struct ctlr_info *h)
++=======
+ static void hpsa_command_resubmit_worker(struct work_struct *work)
  {
- 	unsigned long flags;
+ 	struct scsi_cmnd *cmd;
+ 	struct hpsa_scsi_dev_t *dev;
+ 	struct CommandList *c =
+ 			container_of(work, struct CommandList, work);
+ 
+ 	cmd = c->scsi_cmd;
+ 	dev = cmd->device->hostdata;
+ 	if (!dev) {
+ 		cmd->result = DID_NO_CONNECT << 16;
+ 		cmd->scsi_done(cmd);
+ 		return;
+ 	}
+ 	if (hpsa_ciss_submit(c->h, c, cmd, dev->scsi3addr)) {
+ 		/*
+ 		 * If we get here, it means dma mapping failed. Try
+ 		 * again via scsi mid layer, which will then get
+ 		 * SCSI_MLQUEUE_HOST_BUSY.
+ 		 */
+ 		cmd->result = DID_IMM_RETRY << 16;
+ 		cmd->scsi_done(cmd);
+ 	}
+ }
+ 
+ /* Running in struct Scsi_Host->host_lock less mode */
+ static int hpsa_scsi_queue_command(struct Scsi_Host *sh, struct scsi_cmnd *cmd)
+ {
+ 	struct ctlr_info *h;
+ 	struct hpsa_scsi_dev_t *dev;
+ 	unsigned char scsi3addr[8];
+ 	struct CommandList *c;
+ 	int rc = 0;
+ 
+ 	/* Get the ptr to our adapter structure out of cmd->host. */
+ 	h = sdev_to_hba(cmd->device);
+ 	dev = cmd->device->hostdata;
+ 	if (!dev) {
+ 		cmd->result = DID_NO_CONNECT << 16;
+ 		cmd->scsi_done(cmd);
+ 		return 0;
+ 	}
+ 	memcpy(scsi3addr, dev->scsi3addr, sizeof(scsi3addr));
+ 
+ 	if (unlikely(lockup_detected(h))) {
+ 		cmd->result = DID_ERROR << 16;
+ 		cmd->scsi_done(cmd);
+ 		return 0;
+ 	}
+ 	c = cmd_alloc(h);
+ 	if (c == NULL) {			/* trouble... */
+ 		dev_err(&h->pdev->dev, "cmd_alloc returned NULL!\n");
+ 		return SCSI_MLQUEUE_HOST_BUSY;
+ 	}
+ 	if (unlikely(lockup_detected(h))) {
+ 		cmd->result = DID_ERROR << 16;
+ 		cmd_free(h, c);
+ 		cmd->scsi_done(cmd);
+ 		return 0;
+ 	}
  
  	/*
- 	 * Don't let rescans be initiated on a controller known
- 	 * to be locked up.  If the controller locks up *during*
- 	 * a rescan, that thread is probably hosed, but at least
- 	 * we can prevent new rescan threads from piling up on a
- 	 * locked up controller.
+ 	 * Call alternate submit routine for I/O accelerated commands.
+ 	 * Retries always go down the normal I/O path.
  	 */
- 	if (unlikely(lockup_detected(h))) {
- 		spin_lock_irqsave(&h->scan_lock, flags);
- 		h->scan_finished = 1;
- 		wake_up_all(&h->scan_wait_queue);
- 		spin_unlock_irqrestore(&h->scan_lock, flags);
- 		return 1;
+ 	if (likely(cmd->retries == 0 &&
+ 		cmd->request->cmd_type == REQ_TYPE_FS &&
+ 		h->acciopath_status)) {
+ 
+ 		cmd->host_scribble = (unsigned char *) c;
+ 		c->cmd_type = CMD_SCSI;
+ 		c->scsi_cmd = cmd;
+ 
+ 		if (dev->offload_enabled) {
+ 			rc = hpsa_scsi_ioaccel_raid_map(h, c);
+ 			if (rc == 0)
+ 				return 0; /* Sent on ioaccel path */
+ 			if (rc < 0) {   /* scsi_dma_map failed. */
+ 				cmd_free(h, c);
+ 				return SCSI_MLQUEUE_HOST_BUSY;
+ 			}
+ 		} else if (dev->ioaccel_handle) {
+ 			rc = hpsa_scsi_ioaccel_direct_map(h, c);
+ 			if (rc == 0)
+ 				return 0; /* Sent on direct map path */
+ 			if (rc < 0) {   /* scsi_dma_map failed. */
+ 				cmd_free(h, c);
+ 				return SCSI_MLQUEUE_HOST_BUSY;
+ 			}
+ 		}
  	}
- 	return 0;
+ 	return hpsa_ciss_submit(h, c, cmd, scsi3addr);
+ }
+ 
+ static void hpsa_scan_complete(struct ctlr_info *h)
++>>>>>>> 8ebc92483211 (hpsa: refactor duplicated scan completion code into a new routine)
+ {
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&h->scan_lock, flags);
+ 	h->scan_finished = 1;
+ 	wake_up_all(&h->scan_wait_queue);
+ 	spin_unlock_irqrestore(&h->scan_lock, flags);
  }
  
  static void hpsa_scan_start(struct Scsi_Host *sh)
@@@ -3995,12 -4194,24 +4088,9 @@@
  
  	hpsa_update_scsi_devices(h, h->scsi_host->host_no);
  
- 	spin_lock_irqsave(&h->scan_lock, flags);
- 	h->scan_finished = 1; /* mark scan as finished. */
- 	wake_up_all(&h->scan_wait_queue);
- 	spin_unlock_irqrestore(&h->scan_lock, flags);
+ 	hpsa_scan_complete(h);
  }
  
 -static int hpsa_change_queue_depth(struct scsi_device *sdev, int qdepth)
 -{
 -	struct hpsa_scsi_dev_t *logical_drive = sdev->hostdata;
 -
 -	if (!logical_drive)
 -		return -ENODEV;
 -
 -	if (qdepth < 1)
 -		qdepth = 1;
 -	else if (qdepth > logical_drive->queue_depth)
 -		qdepth = logical_drive->queue_depth;
 -
 -	return scsi_change_queue_depth(sdev, qdepth);
 -}
 -
  static int hpsa_scan_finished(struct Scsi_Host *sh,
  	unsigned long elapsed_time)
  {
* Unmerged path drivers/scsi/hpsa.c
