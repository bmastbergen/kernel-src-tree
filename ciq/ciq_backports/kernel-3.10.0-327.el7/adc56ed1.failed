perf tools: Add ordered_events__free function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [tools] perf: Add ordered_events__free function (Jiri Olsa) [1169436]
Rebuild_FUZZ: 92.86%
commit-author Jiri Olsa <jolsa@kernel.org>
commit adc56ed1e01f1c43fc7bf75340f11f4ad5e11145
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/adc56ed1.failed

Adding ordered_events__free function to release all the struct
ordered_events data. It's replacement for former
perf_session_free_sample_buffers function.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Acked-by: David Ahern <dsahern@gmail.com>
	Cc: Corey Ashford <cjashfor@linux.vnet.ibm.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: Jean Pihet <jean.pihet@linaro.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lkml.kernel.org/n/tip-urraa8ccay4o14wambjraws7@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit adc56ed1e01f1c43fc7bf75340f11f4ad5e11145)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/ordered-events.c
#	tools/perf/util/ordered-events.h
#	tools/perf/util/session.c
diff --cc tools/perf/util/session.c
index 8f2eedc2c5c3,7d8dbf213d64..000000000000
--- a/tools/perf/util/session.c
+++ b/tools/perf/util/session.c
@@@ -444,116 -442,6 +444,119 @@@ static perf_event__swap_op perf_event__
  	[PERF_RECORD_HEADER_MAX]	  = NULL,
  };
  
++<<<<<<< HEAD
 +struct ordered_event {
 +	u64			timestamp;
 +	u64			file_offset;
 +	union perf_event	*event;
 +	struct list_head	list;
 +};
 +
 +enum oe_flush {
 +	OE_FLUSH__FINAL,
 +	OE_FLUSH__ROUND,
 +};
 +
 +static void perf_session_free_sample_buffers(struct perf_session *session)
 +{
 +	struct ordered_events *oe = &session->ordered_events;
 +
 +	while (!list_empty(&oe->to_free)) {
 +		struct ordered_event *event;
 +
 +		event = list_entry(oe->to_free.next, struct ordered_event, list);
 +		list_del(&event->list);
 +		free(event);
 +	}
 +}
 +
 +static int perf_session_deliver_event(struct perf_session *session,
 +				      union perf_event *event,
 +				      struct perf_sample *sample,
 +				      struct perf_tool *tool,
 +				      u64 file_offset);
 +
 +static int __ordered_events__flush(struct perf_session *s,
 +				   struct perf_tool *tool)
 +{
 +	struct ordered_events *oe = &s->ordered_events;
 +	struct list_head *head = &oe->events;
 +	struct ordered_event *tmp, *iter;
 +	struct perf_sample sample;
 +	u64 limit = oe->next_flush;
 +	u64 last_ts = oe->last ? oe->last->timestamp : 0ULL;
 +	bool show_progress = limit == ULLONG_MAX;
 +	struct ui_progress prog;
 +	int ret;
 +
 +	if (!tool->ordered_events || !limit)
 +		return 0;
 +
 +	if (show_progress)
 +		ui_progress__init(&prog, oe->nr_events, "Processing time ordered events...");
 +
 +	list_for_each_entry_safe(iter, tmp, head, list) {
 +		if (session_done())
 +			return 0;
 +
 +		if (iter->timestamp > limit)
 +			break;
 +
 +		ret = perf_evlist__parse_sample(s->evlist, iter->event, &sample);
 +		if (ret)
 +			pr_err("Can't parse sample, err = %d\n", ret);
 +		else {
 +			ret = perf_session_deliver_event(s, iter->event, &sample, tool,
 +							 iter->file_offset);
 +			if (ret)
 +				return ret;
 +		}
 +
 +		oe->last_flush = iter->timestamp;
 +		list_del(&iter->list);
 +		list_add(&iter->list, &oe->cache);
 +		oe->nr_events--;
 +
 +		if (show_progress)
 +			ui_progress__update(&prog, 1);
 +	}
 +
 +	if (list_empty(head))
 +		oe->last = NULL;
 +	else if (last_ts <= limit)
 +		oe->last = list_entry(head->prev, struct ordered_event, list);
 +
 +	return 0;
 +}
 +
 +static int ordered_events__flush(struct perf_session *s, struct perf_tool *tool,
 +				 enum oe_flush how)
 +{
 +	struct ordered_events *oe = &s->ordered_events;
 +	int err;
 +
 +	switch (how) {
 +	case OE_FLUSH__FINAL:
 +		oe->next_flush = ULLONG_MAX;
 +		break;
 +
 +	case OE_FLUSH__ROUND:
 +	default:
 +		break;
 +	};
 +
 +	err = __ordered_events__flush(s, tool);
 +
 +	if (!err) {
 +		if (how == OE_FLUSH__ROUND)
 +			oe->next_flush = oe->max_timestamp;
 +	}
 +
 +	return err;
 +}
 +
++=======
++>>>>>>> adc56ed1e01f (perf tools: Add ordered_events__free function)
  /*
   * When perf record finishes a pass on every buffers, it records this pseudo
   * event.
* Unmerged path tools/perf/util/ordered-events.c
* Unmerged path tools/perf/util/ordered-events.h
* Unmerged path tools/perf/util/ordered-events.c
* Unmerged path tools/perf/util/ordered-events.h
* Unmerged path tools/perf/util/session.c
