ipv6: drop ipv6_sk_mc_lock in mcast

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author WANG Cong <xiyou.wangcong@gmail.com>
commit b5350916bfd49f737d73c4c512fbea1b3537c703
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/b5350916.failed

Similarly the code is already protected by rtnl lock.

	Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b5350916bfd49f737d73c4c512fbea1b3537c703)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/mcast.c
diff --cc net/ipv6/mcast.c
index 8c315d7cece8,27ca0b741ccc..000000000000
--- a/net/ipv6/mcast.c
+++ b/net/ipv6/mcast.c
@@@ -207,12 -198,11 +204,10 @@@ int ipv6_sock_mc_join(struct sock *sk, 
  		return err;
  	}
  
- 	spin_lock(&ipv6_sk_mc_lock);
  	mc_lst->next = np->ipv6_mc_list;
  	rcu_assign_pointer(np->ipv6_mc_list, mc_lst);
- 	spin_unlock(&ipv6_sk_mc_lock);
  
  	rcu_read_unlock();
 -	rtnl_unlock();
  
  	return 0;
  }
@@@ -230,10 -220,9 +225,16 @@@ int ipv6_sock_mc_drop(struct sock *sk, 
  	if (!ipv6_addr_is_multicast(addr))
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	spin_lock(&ipv6_sk_mc_lock);
 +	for (lnk = &np->ipv6_mc_list;
 +	     (mc_lst = rcu_dereference_protected(*lnk,
 +			lockdep_is_held(&ipv6_sk_mc_lock))) !=NULL ;
++=======
+ 	rtnl_lock();
+ 	for (lnk = &np->ipv6_mc_list;
+ 	     (mc_lst = rtnl_dereference(*lnk)) != NULL;
++>>>>>>> b5350916bfd4 (ipv6: drop ipv6_sk_mc_lock in mcast)
  	      lnk = &mc_lst->next) {
  		if ((ifindex == 0 || mc_lst->ifindex == ifindex) &&
  		    ipv6_addr_equal(&mc_lst->addr, addr)) {
@@@ -258,7 -248,7 +258,11 @@@
  			return 0;
  		}
  	}
++<<<<<<< HEAD
 +	spin_unlock(&ipv6_sk_mc_lock);
++=======
+ 	rtnl_unlock();
++>>>>>>> b5350916bfd4 (ipv6: drop ipv6_sk_mc_lock in mcast)
  
  	return -EADDRNOTAVAIL;
  }
@@@ -303,9 -293,8 +307,14 @@@ void ipv6_sock_mc_close(struct sock *sk
  	if (!rcu_access_pointer(np->ipv6_mc_list))
  		return;
  
++<<<<<<< HEAD
 +	spin_lock(&ipv6_sk_mc_lock);
 +	while ((mc_lst = rcu_dereference_protected(np->ipv6_mc_list,
 +				lockdep_is_held(&ipv6_sk_mc_lock))) != NULL) {
++=======
+ 	rtnl_lock();
+ 	while ((mc_lst = rtnl_dereference(np->ipv6_mc_list)) != NULL) {
++>>>>>>> b5350916bfd4 (ipv6: drop ipv6_sk_mc_lock in mcast)
  		struct net_device *dev;
  
  		np->ipv6_mc_list = mc_lst->next;
@@@ -326,9 -314,8 +334,12 @@@
  		atomic_sub(sizeof(*mc_lst), &sk->sk_omem_alloc);
  		kfree_rcu(mc_lst, rcu);
  
- 		spin_lock(&ipv6_sk_mc_lock);
  	}
++<<<<<<< HEAD
 +	spin_unlock(&ipv6_sk_mc_lock);
++=======
+ 	rtnl_unlock();
++>>>>>>> b5350916bfd4 (ipv6: drop ipv6_sk_mc_lock in mcast)
  }
  
  int ip6_mc_source(int add, int omode, struct sock *sk,
* Unmerged path net/ipv6/mcast.c
