powerpc: add real mode support for dma operations on powernv

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [powerpc] add real mode support for dma operations on powernv (David Gibson) [1232550]
Rebuild_FUZZ: 91.89%
commit-author Alexey Kardashevskiy <aik@ozlabs.ru>
commit 8e0a1611cb891e72a9affc4a8ee4795c634896a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/8e0a1611.failed

The existing TCE machine calls (tce_build and tce_free) only support
virtual mode as they call __raw_writeq for TCE invalidation what
fails in real mode.

This introduces tce_build_rm and tce_free_rm real mode versions
which do mostly the same but use "Store Doubleword Caching Inhibited
Indexed" instruction for TCE invalidation.

This new feature is going to be utilized by real mode support of VFIO.

	Signed-off-by: Alexey Kardashevskiy <aik@ozlabs.ru>
	Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
(cherry picked from commit 8e0a1611cb891e72a9affc4a8ee4795c634896a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/powernv/pci-ioda.c
#	arch/powerpc/platforms/powernv/pci.h
diff --cc arch/powerpc/platforms/powernv/pci-ioda.c
index 4437177399f5,307015d9cd99..000000000000
--- a/arch/powerpc/platforms/powernv/pci-ioda.c
+++ b/arch/powerpc/platforms/powernv/pci-ioda.c
@@@ -503,10 -464,13 +513,20 @@@ static void pnv_ioda_setup_bus_dma(stru
  	}
  }
  
++<<<<<<< HEAD
 +static void pnv_pci_ioda1_tce_invalidate(struct iommu_table *tbl,
 +					 __be64 *startp, __be64 *endp)
 +{
 +	__be64 __iomem *invalidate = (__be64 __iomem *)tbl->it_index;
++=======
+ static void pnv_pci_ioda1_tce_invalidate(struct pnv_ioda_pe *pe,
+ 					 struct iommu_table *tbl,
+ 					 u64 *startp, u64 *endp, bool rm)
+ {
+ 	u64 __iomem *invalidate = rm ?
+ 		(u64 __iomem *)pe->tce_inval_reg_phys :
+ 		(u64 __iomem *)tbl->it_index;
++>>>>>>> 8e0a1611cb89 (powerpc: add real mode support for dma operations on powernv)
  	unsigned long start, end, inc;
  
  	start = __pa(startp);
@@@ -533,7 -497,10 +553,14 @@@
  
          mb(); /* Ensure above stores are visible */
          while (start <= end) {
++<<<<<<< HEAD
 +                __raw_writeq(cpu_to_be64(start), invalidate);
++=======
+ 		if (rm)
+ 			__raw_rm_writeq(start, invalidate);
+ 		else
+ 			__raw_writeq(start, invalidate);
++>>>>>>> 8e0a1611cb89 (powerpc: add real mode support for dma operations on powernv)
                  start += inc;
          }
  
@@@ -545,10 -512,12 +572,19 @@@
  
  static void pnv_pci_ioda2_tce_invalidate(struct pnv_ioda_pe *pe,
  					 struct iommu_table *tbl,
++<<<<<<< HEAD
 +					 __be64 *startp, __be64 *endp)
 +{
 +	unsigned long start, end, inc;
 +	__be64 __iomem *invalidate = (__be64 __iomem *)tbl->it_index;
++=======
+ 					 u64 *startp, u64 *endp, bool rm)
+ {
+ 	unsigned long start, end, inc;
+ 	u64 __iomem *invalidate = rm ?
+ 		(u64 __iomem *)pe->tce_inval_reg_phys :
+ 		(u64 __iomem *)tbl->it_index;
++>>>>>>> 8e0a1611cb89 (powerpc: add real mode support for dma operations on powernv)
  
  	/* We'll invalidate DMA address in PE scope */
  	start = 0x2ul << 60;
@@@ -564,13 -533,16 +600,24 @@@
  	mb();
  
  	while (start <= end) {
++<<<<<<< HEAD
 +		__raw_writeq(cpu_to_be64(start), invalidate);
++=======
+ 		if (rm)
+ 			__raw_rm_writeq(start, invalidate);
+ 		else
+ 			__raw_writeq(start, invalidate);
++>>>>>>> 8e0a1611cb89 (powerpc: add real mode support for dma operations on powernv)
  		start += inc;
  	}
  }
  
  void pnv_pci_ioda_tce_invalidate(struct iommu_table *tbl,
++<<<<<<< HEAD
 +				 __be64 *startp, __be64 *endp)
++=======
+ 				 u64 *startp, u64 *endp, bool rm)
++>>>>>>> 8e0a1611cb89 (powerpc: add real mode support for dma operations on powernv)
  {
  	struct pnv_ioda_pe *pe = container_of(tbl, struct pnv_ioda_pe,
  					      tce32_table);
@@@ -651,18 -623,20 +698,27 @@@ static void pnv_pci_ioda_setup_dma_pe(s
  		 * errors, and on the first pass the data will be a relative
  		 * bus number, print that out instead.
  		 */
++<<<<<<< HEAD
 +		tbl->it_index = (unsigned long)ioremap(be64_to_cpup(swinvp), 8);
 +		tbl->it_type |= (TCE_PCI_SWINV_CREATE |
 +				 TCE_PCI_SWINV_FREE   |
 +				 TCE_PCI_SWINV_PAIR);
++=======
+ 		tbl->it_busno = 0;
+ 		pe->tce_inval_reg_phys = be64_to_cpup(swinvp);
+ 		tbl->it_index = (unsigned long)ioremap(pe->tce_inval_reg_phys,
+ 				8);
+ 		tbl->it_type = TCE_PCI_SWINV_CREATE | TCE_PCI_SWINV_FREE |
+ 			       TCE_PCI_SWINV_PAIR;
++>>>>>>> 8e0a1611cb89 (powerpc: add real mode support for dma operations on powernv)
  	}
  	iommu_init_table(tbl, phb->hose->node);
 -	iommu_register_group(tbl, pci_domain_nr(pe->pbus), pe->pe_number);
 +	iommu_register_group(tbl, phb->hose->global_number, pe->pe_number);
  
  	if (pe->pdev)
 -		set_iommu_table_base(&pe->pdev->dev, tbl);
 +		set_iommu_table_base_and_group(&pe->pdev->dev, tbl);
  	else
 -		pnv_ioda_setup_bus_dma(pe, pe->pbus);
 +		pnv_ioda_setup_bus_dma(pe, pe->pbus, true);
  
  	return;
   fail:
@@@ -784,19 -703,19 +840,27 @@@ static void pnv_pci_ioda2_setup_dma_pe(
  		 * errors, and on the first pass the data will be a relative
  		 * bus number, print that out instead.
  		 */
++<<<<<<< HEAD
 +		tbl->it_index = (unsigned long)ioremap(be64_to_cpup(swinvp), 8);
 +		tbl->it_type |= (TCE_PCI_SWINV_CREATE | TCE_PCI_SWINV_FREE);
++=======
+ 		tbl->it_busno = 0;
+ 		pe->tce_inval_reg_phys = be64_to_cpup(swinvp);
+ 		tbl->it_index = (unsigned long)ioremap(pe->tce_inval_reg_phys,
+ 				8);
+ 		tbl->it_type = TCE_PCI_SWINV_CREATE | TCE_PCI_SWINV_FREE;
++>>>>>>> 8e0a1611cb89 (powerpc: add real mode support for dma operations on powernv)
  	}
  	iommu_init_table(tbl, phb->hose->node);
 +	iommu_register_group(tbl, phb->hose->global_number, pe->pe_number);
  
  	if (pe->pdev)
 -		set_iommu_table_base(&pe->pdev->dev, tbl);
 +		set_iommu_table_base_and_group(&pe->pdev->dev, tbl);
  	else
 -		pnv_ioda_setup_bus_dma(pe, pe->pbus);
 +		pnv_ioda_setup_bus_dma(pe, pe->pbus, true);
  
 +	/* Also create a bypass window */
 +	pnv_pci_ioda2_setup_bypass_pe(phb, pe);
  	return;
  fail:
  	if (pe->tce32_seg >= 0)
diff --cc arch/powerpc/platforms/powernv/pci.h
index 6092ce3351f9,170dd98629d7..000000000000
--- a/arch/powerpc/platforms/powernv/pci.h
+++ b/arch/powerpc/platforms/powernv/pci.h
@@@ -52,10 -52,9 +52,11 @@@ struct pnv_ioda_pe 
  	int			tce32_seg;
  	int			tce32_segcount;
  	struct iommu_table	tce32_table;
+ 	phys_addr_t		tce_inval_reg_phys;
  
 -	/* XXX TODO: Add support for additional 64-bit iommus */
 +	/* 64-bit TCE bypass region */
 +	bool			tce_bypass_enabled;
 +	uint64_t		tce_bypass_base;
  
  	/* MSIs. MVE index is identical for for 32 and 64 bit MSI
  	 * and -1 if not supported. (It's actually identical to the
@@@ -198,8 -194,6 +199,12 @@@ extern void pnv_pci_init_p5ioc2_hub(str
  extern void pnv_pci_init_ioda_hub(struct device_node *np);
  extern void pnv_pci_init_ioda2_phb(struct device_node *np);
  extern void pnv_pci_ioda_tce_invalidate(struct iommu_table *tbl,
++<<<<<<< HEAD
 +					__be64 *startp, __be64 *endp);
 +extern void pnv_pci_reset_secondary_bus(struct pci_dev *dev);
 +extern int ioda_eeh_phb_reset(struct pci_controller *hose, int option);
++=======
+ 					u64 *startp, u64 *endp, bool rm);
++>>>>>>> 8e0a1611cb89 (powerpc: add real mode support for dma operations on powernv)
  
  #endif /* __POWERNV_PCI_H */
diff --git a/arch/powerpc/include/asm/machdep.h b/arch/powerpc/include/asm/machdep.h
index 9f35b2435997..8dcb721d03d8 100644
--- a/arch/powerpc/include/asm/machdep.h
+++ b/arch/powerpc/include/asm/machdep.h
@@ -78,6 +78,18 @@ struct machdep_calls {
 				    long index);
 	void		(*tce_flush)(struct iommu_table *tbl);
 
+	/* _rm versions are for real mode use only */
+	int		(*tce_build_rm)(struct iommu_table *tbl,
+				     long index,
+				     long npages,
+				     unsigned long uaddr,
+				     enum dma_data_direction direction,
+				     struct dma_attrs *attrs);
+	void		(*tce_free_rm)(struct iommu_table *tbl,
+				    long index,
+				    long npages);
+	void		(*tce_flush_rm)(struct iommu_table *tbl);
+
 	void __iomem *	(*ioremap)(phys_addr_t addr, unsigned long size,
 				   unsigned long flags, void *caller);
 	void		(*iounmap)(volatile void __iomem *token);
* Unmerged path arch/powerpc/platforms/powernv/pci-ioda.c
diff --git a/arch/powerpc/platforms/powernv/pci.c b/arch/powerpc/platforms/powernv/pci.c
index 31c98c24f999..3646f27724cf 100644
--- a/arch/powerpc/platforms/powernv/pci.c
+++ b/arch/powerpc/platforms/powernv/pci.c
@@ -601,7 +601,7 @@ struct pci_ops pnv_pci_ops = {
 
 static int pnv_tce_build(struct iommu_table *tbl, long index, long npages,
 			 unsigned long uaddr, enum dma_data_direction direction,
-			 struct dma_attrs *attrs)
+			 struct dma_attrs *attrs, bool rm)
 {
 	u64 proto_tce;
 	__be64 *tcep, *tces;
@@ -623,12 +623,22 @@ static int pnv_tce_build(struct iommu_table *tbl, long index, long npages,
 	 * of flags if that becomes the case
 	 */
 	if (tbl->it_type & TCE_PCI_SWINV_CREATE)
-		pnv_pci_ioda_tce_invalidate(tbl, tces, tcep - 1);
+		pnv_pci_ioda_tce_invalidate(tbl, tces, tcep - 1, rm);
 
 	return 0;
 }
 
-static void pnv_tce_free(struct iommu_table *tbl, long index, long npages)
+static int pnv_tce_build_vm(struct iommu_table *tbl, long index, long npages,
+			    unsigned long uaddr,
+			    enum dma_data_direction direction,
+			    struct dma_attrs *attrs)
+{
+	return pnv_tce_build(tbl, index, npages, uaddr, direction, attrs,
+			false);
+}
+
+static void pnv_tce_free(struct iommu_table *tbl, long index, long npages,
+		bool rm)
 {
 	__be64 *tcep, *tces;
 
@@ -638,7 +648,12 @@ static void pnv_tce_free(struct iommu_table *tbl, long index, long npages)
 		*(tcep++) = cpu_to_be64(0);
 
 	if (tbl->it_type & TCE_PCI_SWINV_FREE)
-		pnv_pci_ioda_tce_invalidate(tbl, tces, tcep - 1);
+		pnv_pci_ioda_tce_invalidate(tbl, tces, tcep - 1, rm);
+}
+
+static void pnv_tce_free_vm(struct iommu_table *tbl, long index, long npages)
+{
+	pnv_tce_free(tbl, index, npages, false);
 }
 
 static unsigned long pnv_tce_get(struct iommu_table *tbl, long index)
@@ -646,6 +661,19 @@ static unsigned long pnv_tce_get(struct iommu_table *tbl, long index)
 	return ((u64 *)tbl->it_base)[index - tbl->it_offset];
 }
 
+static int pnv_tce_build_rm(struct iommu_table *tbl, long index, long npages,
+			    unsigned long uaddr,
+			    enum dma_data_direction direction,
+			    struct dma_attrs *attrs)
+{
+	return pnv_tce_build(tbl, index, npages, uaddr, direction, attrs, true);
+}
+
+static void pnv_tce_free_rm(struct iommu_table *tbl, long index, long npages)
+{
+	pnv_tce_free(tbl, index, npages, true);
+}
+
 void pnv_pci_setup_iommu_table(struct iommu_table *tbl,
 			       void *tce_mem, u64 tce_size,
 			       u64 dma_offset, unsigned page_shift)
@@ -821,8 +849,10 @@ void __init pnv_pci_init(void)
 
 	/* Configure IOMMU DMA hooks */
 	ppc_md.pci_dma_dev_setup = pnv_pci_dma_dev_setup;
-	ppc_md.tce_build = pnv_tce_build;
-	ppc_md.tce_free = pnv_tce_free;
+	ppc_md.tce_build = pnv_tce_build_vm;
+	ppc_md.tce_free = pnv_tce_free_vm;
+	ppc_md.tce_build_rm = pnv_tce_build_rm;
+	ppc_md.tce_free_rm = pnv_tce_free_rm;
 	ppc_md.tce_get = pnv_tce_get;
 	ppc_md.pci_probe_mode = pnv_pci_probe_mode;
 	set_pci_dma_ops(&dma_iommu_ops);
* Unmerged path arch/powerpc/platforms/powernv/pci.h
