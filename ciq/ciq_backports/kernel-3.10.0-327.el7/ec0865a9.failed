bonding: make USES_PRIMARY inline functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Veaceslav Falico <vfalico@gmail.com>
commit ec0865a94991d1819d4f99866a2492af8df5c882
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/ec0865a9.failed

Change the name a bit to better reflect its scope, and update some
comments. Two functions added - one which takes bond as a param and the
other which takes the mode.

CC: Jay Vosburgh <j.vosburgh@gmail.com>
CC: Andy Gospodarek <andy@greyhouse.net>
	Signed-off-by: Veaceslav Falico <vfalico@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ec0865a94991d1819d4f99866a2492af8df5c882)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
#	drivers/net/bonding/bond_options.c
#	drivers/net/bonding/bonding.h
diff --cc drivers/net/bonding/bond_main.c
index d0eec7c786f0,48bea62fb4d0..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -670,8 -494,10 +670,13 @@@ static int bond_check_dev_link(struct b
   */
  static int bond_set_promiscuity(struct bonding *bond, int inc)
  {
 -	struct list_head *iter;
  	int err = 0;
++<<<<<<< HEAD
 +	if (USES_PRIMARY(bond->params.mode)) {
++=======
+ 
+ 	if (bond_uses_primary(bond)) {
++>>>>>>> ec0865a94991 (bonding: make USES_PRIMARY inline functions)
  		/* write lock already acquired */
  		if (bond->curr_active_slave) {
  			err = dev_set_promiscuity(bond->curr_active_slave->dev,
@@@ -694,8 -520,10 +699,13 @@@
   */
  static int bond_set_allmulti(struct bonding *bond, int inc)
  {
 -	struct list_head *iter;
  	int err = 0;
++<<<<<<< HEAD
 +	if (USES_PRIMARY(bond->params.mode)) {
++=======
+ 
+ 	if (bond_uses_primary(bond)) {
++>>>>>>> ec0865a94991 (bonding: make USES_PRIMARY inline functions)
  		/* write lock already acquired */
  		if (bond->curr_active_slave) {
  			err = dev_set_allmulti(bond->curr_active_slave->dev,
@@@ -797,21 -584,15 +807,28 @@@ static void bond_mc_list_flush(struct n
  
  /*--------------------------- Active slave change ---------------------------*/
  
++<<<<<<< HEAD
 +/*
 + * Update the mc list and multicast-related flags for the new and
 + * old active slaves (if any) according to the multicast mode, and
 + * promiscuous flags unconditionally.
++=======
+ /* Update the hardware address list and promisc/allmulti for the new and
+  * old active slaves (if any).  Modes that are not using primary keep all
+  * slaves up date at all times; only the modes that use primary need to call
+  * this function to swap these settings during a failover.
++>>>>>>> ec0865a94991 (bonding: make USES_PRIMARY inline functions)
   */
 -static void bond_hw_addr_swap(struct bonding *bond, struct slave *new_active,
 -			      struct slave *old_active)
 +static void bond_mc_swap(struct bonding *bond, struct slave *new_active,
 +			 struct slave *old_active)
  {
 -	ASSERT_RTNL();
 +	struct netdev_hw_addr *ha;
 +
 +	if (!USES_PRIMARY(bond->params.mode))
 +		/* nothing to do -  mc list is already up-to-date on
 +		 * all slaves
 +		 */
 +		return;
  
  	if (old_active) {
  		if (bond->dev->flags & IFF_PROMISC)
@@@ -1036,11 -798,11 +1053,16 @@@ void bond_change_active_slave(struct bo
  		return;
  
  	if (new_active) {
 -		new_active->last_link_up = jiffies;
 +		new_active->jiffies = jiffies;
  
  		if (new_active->link == BOND_LINK_BACK) {
++<<<<<<< HEAD
 +			if (USES_PRIMARY(bond->params.mode)) {
 +				pr_info("%s: making interface %s the new active one %d ms earlier.\n",
++=======
+ 			if (bond_uses_primary(bond)) {
+ 				pr_info("%s: making interface %s the new active one %d ms earlier\n",
++>>>>>>> ec0865a94991 (bonding: make USES_PRIMARY inline functions)
  					bond->dev->name, new_active->dev->name,
  					(bond->params.updelay - new_active->delay) * bond->params.miimon);
  			}
@@@ -1054,15 -816,15 +1076,25 @@@
  			if (bond_is_lb(bond))
  				bond_alb_handle_link_change(bond, new_active, BOND_LINK_UP);
  		} else {
++<<<<<<< HEAD
 +			if (USES_PRIMARY(bond->params.mode)) {
 +				pr_info("%s: making interface %s the new active one.\n",
++=======
+ 			if (bond_uses_primary(bond)) {
+ 				pr_info("%s: making interface %s the new active one\n",
++>>>>>>> ec0865a94991 (bonding: make USES_PRIMARY inline functions)
  					bond->dev->name, new_active->dev->name);
  			}
  		}
  	}
  
++<<<<<<< HEAD
 +	if (USES_PRIMARY(bond->params.mode))
 +		bond_mc_swap(bond, new_active, old_active);
++=======
+ 	if (bond_uses_primary(bond))
+ 		bond_hw_addr_swap(bond, new_active, old_active);
++>>>>>>> ec0865a94991 (bonding: make USES_PRIMARY inline functions)
  
  	if (bond_is_lb(bond)) {
  		bond_alb_handle_active_change(bond, new_active);
@@@ -1636,12 -1381,10 +1668,17 @@@ int bond_enslave(struct net_device *bon
  			goto err_close;
  	}
  
++<<<<<<< HEAD
 +	/* If the mode USES_PRIMARY, then the new slave gets the
 +	 * master's promisc (and mc) settings only if it becomes the
 +	 * curr_active_slave, and that is taken care of later when calling
 +	 * bond_change_active()
++=======
+ 	/* If the mode uses primary, then the following is handled by
+ 	 * bond_change_active_slave().
++>>>>>>> ec0865a94991 (bonding: make USES_PRIMARY inline functions)
  	 */
- 	if (!USES_PRIMARY(bond->params.mode)) {
+ 	if (!bond_uses_primary(bond)) {
  		/* set promiscuity level to new slave */
  		if (bond_dev->flags & IFF_PROMISC) {
  			res = dev_set_promiscuity(slave_dev, 1);
@@@ -1734,12 -1475,12 +1771,12 @@@
  	}
  
  	if (new_slave->link != BOND_LINK_DOWN)
 -		new_slave->last_link_up = jiffies;
 +		new_slave->jiffies = jiffies;
  	pr_debug("Initial state of slave_dev is BOND_LINK_%s\n",
 -		 new_slave->link == BOND_LINK_DOWN ? "DOWN" :
 -		 (new_slave->link == BOND_LINK_UP ? "UP" : "BACK"));
 +		new_slave->link == BOND_LINK_DOWN ? "DOWN" :
 +			(new_slave->link == BOND_LINK_UP ? "UP" : "BACK"));
  
- 	if (USES_PRIMARY(bond->params.mode) && bond->params.primary[0]) {
+ 	if (bond_uses_primary(bond) && bond->params.primary[0]) {
  		/* if there is a primary slave, remember it */
  		if (strcmp(bond->params.primary, new_slave->dev->name) == 0) {
  			bond->primary_slave = new_slave;
@@@ -1832,11 -1559,28 +1869,27 @@@
  		goto err_unregister;
  	}
  
 -	res = bond_sysfs_slave_add(new_slave);
 -	if (res) {
 -		pr_debug("Error %d calling bond_sysfs_slave_add\n", res);
 -		goto err_upper_unlink;
 -	}
  
++<<<<<<< HEAD
 +	pr_info("%s: enslaving %s as a%s interface with a%s link.\n",
++=======
+ 	bond->slave_cnt++;
+ 	bond_compute_features(bond);
+ 	bond_set_carrier(bond);
+ 
+ 	if (bond_uses_primary(bond)) {
+ 		block_netpoll_tx();
+ 		write_lock_bh(&bond->curr_slave_lock);
+ 		bond_select_active_slave(bond);
+ 		write_unlock_bh(&bond->curr_slave_lock);
+ 		unblock_netpoll_tx();
+ 	}
+ 
+ 	pr_info("%s: Enslaving %s as %s interface with %s link\n",
++>>>>>>> ec0865a94991 (bonding: make USES_PRIMARY inline functions)
  		bond_dev->name, slave_dev->name,
 -		bond_is_active_slave(new_slave) ? "an active" : "a backup",
 -		new_slave->link != BOND_LINK_DOWN ? "an up" : "a down");
 +		bond_is_active_slave(new_slave) ? "n active" : " backup",
 +		new_slave->link != BOND_LINK_DOWN ? "n up" : " down");
  
  	/* enslave is successful */
  	return 0;
@@@ -1845,18 -1589,14 +1898,24 @@@
  err_unregister:
  	netdev_rx_handler_unregister(slave_dev);
  
++<<<<<<< HEAD
 +err_dest_symlinks:
 +	bond_destroy_slave_symlinks(bond_dev, slave_dev);
++=======
+ err_detach:
+ 	if (!bond_uses_primary(bond))
+ 		bond_hw_addr_flush(bond_dev, slave_dev);
++>>>>>>> ec0865a94991 (bonding: make USES_PRIMARY inline functions)
  
 -	vlan_vids_del_by_dev(slave_dev, bond_dev);
 +err_detach:
 +	if (!USES_PRIMARY(bond->params.mode)) {
 +		netif_addr_lock_bh(bond_dev);
 +		bond_mc_list_flush(bond_dev, slave_dev);
 +		netif_addr_unlock_bh(bond_dev);
 +	}
 +	bond_del_vlans_from_slave(bond, slave_dev);
 +	write_lock_bh(&bond->lock);
 +	bond_detach_slave(bond, new_slave);
  	if (bond->primary_slave == new_slave)
  		bond->primary_slave = NULL;
  	if (bond->curr_active_slave == new_slave) {
@@@ -2040,15 -1776,12 +2099,20 @@@ static int __bond_release_one(struct ne
  			bond_dev->name, slave_dev->name, bond_dev->name);
  
  	/* must do this from outside any spinlocks */
 -	vlan_vids_del_by_dev(slave_dev, bond_dev);
 +	bond_destroy_slave_symlinks(bond_dev, slave_dev);
 +
++<<<<<<< HEAD
 +	bond_del_vlans_from_slave(bond, slave_dev);
  
 +	/* If the mode USES_PRIMARY, then we should only remove its
 +	 * promisc and mc settings if it was the curr_active_slave, but that was
 +	 * already taken care of above when we detached the slave
++=======
+ 	/* If the mode uses primary, then this cases was handled above by
+ 	 * bond_change_active_slave(..., NULL)
++>>>>>>> ec0865a94991 (bonding: make USES_PRIMARY inline functions)
  	 */
- 	if (!USES_PRIMARY(bond->params.mode)) {
+ 	if (!bond_uses_primary(bond)) {
  		/* unset promiscuity level from slave
  		 * NOTE: The NETDEV_CHANGEADDR call above may change the value
  		 * of the IFF_PROMISC flag in the bond_dev, but we need the
@@@ -3346,14 -3102,16 +3410,19 @@@ static int bond_open(struct net_device 
  
  	/* reset slave->backup and slave->inactive */
  	read_lock(&bond->lock);
 -	if (bond_has_slaves(bond)) {
 +	if (bond->slave_cnt > 0) {
  		read_lock(&bond->curr_slave_lock);
++<<<<<<< HEAD
 +		bond_for_each_slave(bond, slave, i) {
 +			if ((bond->params.mode == BOND_MODE_ACTIVEBACKUP)
++=======
+ 		bond_for_each_slave(bond, slave, iter) {
+ 			if (bond_uses_primary(bond)
++>>>>>>> ec0865a94991 (bonding: make USES_PRIMARY inline functions)
  				&& (slave != bond->curr_active_slave)) {
 -				bond_set_slave_inactive_flags(slave,
 -							      BOND_SLAVE_NOTIFY_NOW);
 +				bond_set_slave_inactive_flags(slave);
  			} else {
 -				bond_set_slave_active_flags(slave,
 -							    BOND_SLAVE_NOTIFY_NOW);
 +				bond_set_slave_active_flags(slave);
  			}
  		}
  		read_unlock(&bond->curr_slave_lock);
@@@ -3590,36 -3335,27 +3659,51 @@@ static void bond_change_rx_flags(struc
  				  bond_dev->flags & IFF_ALLMULTI ? 1 : -1);
  }
  
 -static void bond_set_rx_mode(struct net_device *bond_dev)
 +static void bond_set_multicast_list(struct net_device *bond_dev)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
 -	struct list_head *iter;
 -	struct slave *slave;
 +	struct netdev_hw_addr *ha;
 +	bool found;
  
 +	read_lock(&bond->lock);
  
++<<<<<<< HEAD
 +	/* looking for addresses to add to slaves' mc list */
 +	netdev_for_each_mc_addr(ha, bond_dev) {
 +		found = bond_addr_in_mc_list(ha->addr, &bond->mc_list,
 +					     bond_dev->addr_len);
 +		if (!found)
 +			bond_mc_add(bond, ha->addr);
++=======
+ 	rcu_read_lock();
+ 	if (bond_uses_primary(bond)) {
+ 		slave = rcu_dereference(bond->curr_active_slave);
+ 		if (slave) {
+ 			dev_uc_sync(slave->dev, bond_dev);
+ 			dev_mc_sync(slave->dev, bond_dev);
+ 		}
+ 	} else {
+ 		bond_for_each_slave_rcu(bond, slave, iter) {
+ 			dev_uc_sync_multiple(slave->dev, bond_dev);
+ 			dev_mc_sync_multiple(slave->dev, bond_dev);
+ 		}
++>>>>>>> ec0865a94991 (bonding: make USES_PRIMARY inline functions)
  	}
 -	rcu_read_unlock();
 +
 +	/* looking for addresses to delete from slaves' list */
 +	netdev_hw_addr_list_for_each(ha, &bond->mc_list) {
 +		found = bond_addr_in_mc_list(ha->addr, &bond_dev->mc,
 +					     bond_dev->addr_len);
 +		if (!found)
 +			bond_mc_del(bond, ha->addr);
 +	}
 +
 +	/* save master's multicast list */
 +	__hw_addr_flush(&bond->mc_list);
 +	__hw_addr_add_multiple(&bond->mc_list, &bond_dev->mc,
 +			       bond_dev->addr_len, NETDEV_HW_ADDR_T_MULTICAST);
 +
 +	read_unlock(&bond->lock);
  }
  
  static int bond_neigh_init(struct neighbour *n)
@@@ -4603,10 -4265,10 +4687,10 @@@ static int bond_check_params(struct bon
  		/* miimon and arp_interval not set, we need one so things
  		 * work as expected, see bonding.txt for details
  		 */
 -		pr_debug("Warning: either miimon or arp_interval and arp_ip_target module parameters must be specified, otherwise bonding will not detect link failures! see bonding.txt for details\n");
 +		pr_debug("Warning: either miimon or arp_interval and arp_ip_target module parameters must be specified, otherwise bonding will not detect link failures! see bonding.txt for details.\n");
  	}
  
- 	if (primary && !USES_PRIMARY(bond_mode)) {
+ 	if (primary && !bond_mode_uses_primary(bond_mode)) {
  		/* currently, using a primary only makes sense
  		 * in active backup, TLB or ALB modes
  		 */
diff --cc drivers/net/bonding/bonding.h
index e1ca02f0b074,1a27c18be21c..000000000000
--- a/drivers/net/bonding/bonding.h
+++ b/drivers/net/bonding/bonding.h
@@@ -49,15 -54,9 +49,21 @@@
  		     ((slave)->link == BOND_LINK_UP) && \
  		     bond_is_active_slave(slave))
  
++<<<<<<< HEAD
 +
 +#define USES_PRIMARY(mode)				\
 +		(((mode) == BOND_MODE_ACTIVEBACKUP) ||	\
 +		 ((mode) == BOND_MODE_TLB)          ||	\
 +		 ((mode) == BOND_MODE_ALB))
 +
 +#define TX_QUEUE_OVERRIDE(mode)				\
 +			(((mode) == BOND_MODE_ACTIVEBACKUP) ||	\
 +			 ((mode) == BOND_MODE_ROUNDROBIN))
++=======
+ #define IS_IP_TARGET_UNUSABLE_ADDRESS(a)	\
+ 	((htonl(INADDR_BROADCAST) == a) ||	\
+ 	 ipv4_is_zeronet(a))
++>>>>>>> ec0865a94991 (bonding: make USES_PRIMARY inline functions)
  /*
   * Less bad way to call ioctl from within the kernel; this needs to be
   * done some other way to get the call out of interrupt context.
@@@ -285,15 -269,41 +291,26 @@@ static inline struct bonding *bond_get_
  	return slave->bond;
  }
  
 -static inline bool bond_should_override_tx_queue(struct bonding *bond)
 -{
 -	return bond->params.mode == BOND_MODE_ACTIVEBACKUP ||
 -	       bond->params.mode == BOND_MODE_ROUNDROBIN;
 -}
 -
  static inline bool bond_is_lb(const struct bonding *bond)
  {
 -	return bond->params.mode == BOND_MODE_TLB ||
 -	       bond->params.mode == BOND_MODE_ALB;
 -}
 -
 -static inline bool bond_mode_uses_arp(int mode)
 -{
 -	return mode != BOND_MODE_8023AD && mode != BOND_MODE_TLB &&
 -	       mode != BOND_MODE_ALB;
 +	return (bond->params.mode == BOND_MODE_TLB ||
 +		bond->params.mode == BOND_MODE_ALB);
  }
  
+ static inline bool bond_mode_uses_primary(int mode)
+ {
+ 	return mode == BOND_MODE_ACTIVEBACKUP || mode == BOND_MODE_TLB ||
+ 	       mode == BOND_MODE_ALB;
+ }
+ 
+ static inline bool bond_uses_primary(struct bonding *bond)
+ {
+ 	return bond_mode_uses_primary(bond->params.mode);
+ }
+ 
  static inline void bond_set_active_slave(struct slave *slave)
  {
 -	if (slave->backup) {
 -		slave->backup = 0;
 -		rtmsg_ifinfo(RTM_NEWLINK, slave->dev, 0, GFP_ATOMIC);
 -	}
 +	slave->backup = 0;
  }
  
  static inline void bond_set_backup_slave(struct slave *slave)
* Unmerged path drivers/net/bonding/bond_options.c
* Unmerged path drivers/net/bonding/bond_main.c
* Unmerged path drivers/net/bonding/bond_options.c
diff --git a/drivers/net/bonding/bond_procfs.c b/drivers/net/bonding/bond_procfs.c
index 96f629d77b41..4b6163229d05 100644
--- a/drivers/net/bonding/bond_procfs.c
+++ b/drivers/net/bonding/bond_procfs.c
@@ -78,7 +78,7 @@ static void bond_info_show_master(struct seq_file *seq)
 			bond->params.xmit_policy);
 	}
 
-	if (USES_PRIMARY(bond->params.mode)) {
+	if (bond_uses_primary(bond)) {
 		seq_printf(seq, "Primary Slave: %s",
 			   (bond->primary_slave) ?
 			   bond->primary_slave->dev->name : "None");
* Unmerged path drivers/net/bonding/bonding.h
