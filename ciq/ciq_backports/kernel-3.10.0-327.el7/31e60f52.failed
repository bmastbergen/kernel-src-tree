nfsd: convert num_drc_entries to an atomic_t

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit 31e60f52224197dc989a82237905dfe643183f7c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/31e60f52.failed

...so we can remove the spinlocking around it.

	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit 31e60f52224197dc989a82237905dfe643183f7c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfscache.c
diff --cc fs/nfsd/nfscache.c
index dfe380798466,dc909091349b..000000000000
--- a/fs/nfsd/nfscache.c
+++ b/fs/nfsd/nfscache.c
@@@ -145,10 -147,8 +145,10 @@@ nfsd_reply_cache_free_locked(struct svc
  		drc_mem_usage -= rp->c_replvec.iov_len;
  		kfree(rp->c_replvec.iov_base);
  	}
 +	if (!hlist_unhashed(&rp->c_hash))
 +		hlist_del(&rp->c_hash);
  	list_del(&rp->c_lru);
- 	--num_drc_entries;
+ 	atomic_dec(&num_drc_entries);
  	drc_mem_usage -= sizeof(*rp);
  	kmem_cache_free(drc_slab, rp);
  }
@@@ -164,10 -164,10 +164,10 @@@ nfsd_reply_cache_free(struct svc_cacher
  int nfsd_reply_cache_init(void)
  {
  	unsigned int hashsize;
 -	unsigned int i;
  
 +	INIT_LIST_HEAD(&lru_head);
  	max_drc_entries = nfsd_cache_size_limit();
- 	num_drc_entries = 0;
+ 	atomic_set(&num_drc_entries, 0);
  	hashsize = nfsd_hashsize(max_drc_entries);
  	maskbits = ilog2(hashsize);
  
@@@ -273,20 -287,22 +273,24 @@@ cache_cleaner_func(struct work_struct *
  	spin_unlock(&cache_lock);
  }
  
 -static unsigned long
 -nfsd_reply_cache_count(struct shrinker *shrink, struct shrink_control *sc)
 -{
 -	return atomic_read(&num_drc_entries);
 -}
 -
 -static unsigned long
 -nfsd_reply_cache_scan(struct shrinker *shrink, struct shrink_control *sc)
 +static int
 +nfsd_reply_cache_shrink(struct shrinker *shrink, struct shrink_control *sc)
  {
 -	unsigned long freed;
++<<<<<<< HEAD
 +	unsigned int num;
  
  	spin_lock(&cache_lock);
 -	freed = prune_cache_entries();
 +	if (sc->nr_to_scan)
 +		prune_cache_entries();
 +	num = num_drc_entries;
  	spin_unlock(&cache_lock);
 -	return freed;
 +
 +	return num;
++=======
++	return atomic_read(&num_drc_entries);
++>>>>>>> 31e60f522241 (nfsd: convert num_drc_entries to an atomic_t)
  }
 +
  /*
   * Walk an xdr_buf and get a CRC for at most the first RC_CSUMLEN bytes
   */
* Unmerged path fs/nfsd/nfscache.c
