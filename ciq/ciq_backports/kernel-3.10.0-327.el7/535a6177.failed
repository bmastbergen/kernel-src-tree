sfc: suppress handled MCDI failures when changing the MAC address

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Daniel Pieczko <dpieczko@solarflare.com>
commit 535a61777f44eebcb71f2a6866f95b17ee0f13c7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/535a6177.failed

	Signed-off-by: Shradha Shah <sshah@solarflare.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 535a61777f44eebcb71f2a6866f95b17ee0f13c7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/sfc/ef10.c
diff --cc drivers/net/ethernet/sfc/ef10.c
index 95f33d51af2f,605cc8948594..000000000000
--- a/drivers/net/ethernet/sfc/ef10.c
+++ b/drivers/net/ethernet/sfc/ef10.c
@@@ -3353,6 -3851,149 +3353,152 @@@ static void efx_ef10_filter_sync_rx_mod
  	WARN_ON(remove_failed);
  }
  
++<<<<<<< HEAD
++=======
+ static int efx_ef10_vport_set_mac_address(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	u8 mac_old[ETH_ALEN];
+ 	int rc, rc2;
+ 
+ 	/* Only reconfigure a PF-created vport */
+ 	if (is_zero_ether_addr(nic_data->vport_mac))
+ 		return 0;
+ 
+ 	efx_device_detach_sync(efx);
+ 	efx_net_stop(efx->net_dev);
+ 	down_write(&efx->filter_sem);
+ 	efx_ef10_filter_table_remove(efx);
+ 	up_write(&efx->filter_sem);
+ 
+ 	rc = efx_ef10_vadaptor_free(efx, nic_data->vport_id);
+ 	if (rc)
+ 		goto restore_filters;
+ 
+ 	ether_addr_copy(mac_old, nic_data->vport_mac);
+ 	rc = efx_ef10_vport_del_mac(efx, nic_data->vport_id,
+ 				    nic_data->vport_mac);
+ 	if (rc)
+ 		goto restore_vadaptor;
+ 
+ 	rc = efx_ef10_vport_add_mac(efx, nic_data->vport_id,
+ 				    efx->net_dev->dev_addr);
+ 	if (!rc) {
+ 		ether_addr_copy(nic_data->vport_mac, efx->net_dev->dev_addr);
+ 	} else {
+ 		rc2 = efx_ef10_vport_add_mac(efx, nic_data->vport_id, mac_old);
+ 		if (rc2) {
+ 			/* Failed to add original MAC, so clear vport_mac */
+ 			eth_zero_addr(nic_data->vport_mac);
+ 			goto reset_nic;
+ 		}
+ 	}
+ 
+ restore_vadaptor:
+ 	rc2 = efx_ef10_vadaptor_alloc(efx, nic_data->vport_id);
+ 	if (rc2)
+ 		goto reset_nic;
+ restore_filters:
+ 	down_write(&efx->filter_sem);
+ 	rc2 = efx_ef10_filter_table_probe(efx);
+ 	up_write(&efx->filter_sem);
+ 	if (rc2)
+ 		goto reset_nic;
+ 
+ 	rc2 = efx_net_open(efx->net_dev);
+ 	if (rc2)
+ 		goto reset_nic;
+ 
+ 	netif_device_attach(efx->net_dev);
+ 
+ 	return rc;
+ 
+ reset_nic:
+ 	netif_err(efx, drv, efx->net_dev,
+ 		  "Failed to restore when changing MAC address - scheduling reset\n");
+ 	efx_schedule_reset(efx, RESET_TYPE_DATAPATH);
+ 
+ 	return rc ? rc : rc2;
+ }
+ 
+ static int efx_ef10_set_mac_address(struct efx_nic *efx)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VADAPTOR_SET_MAC_IN_LEN);
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	bool was_enabled = efx->port_enabled;
+ 	int rc;
+ 
+ 	efx_device_detach_sync(efx);
+ 	efx_net_stop(efx->net_dev);
+ 	down_write(&efx->filter_sem);
+ 	efx_ef10_filter_table_remove(efx);
+ 
+ 	ether_addr_copy(MCDI_PTR(inbuf, VADAPTOR_SET_MAC_IN_MACADDR),
+ 			efx->net_dev->dev_addr);
+ 	MCDI_SET_DWORD(inbuf, VADAPTOR_SET_MAC_IN_UPSTREAM_PORT_ID,
+ 		       nic_data->vport_id);
+ 	rc = efx_mcdi_rpc_quiet(efx, MC_CMD_VADAPTOR_SET_MAC, inbuf,
+ 				sizeof(inbuf), NULL, 0, NULL);
+ 
+ 	efx_ef10_filter_table_probe(efx);
+ 	up_write(&efx->filter_sem);
+ 	if (was_enabled)
+ 		efx_net_open(efx->net_dev);
+ 	netif_device_attach(efx->net_dev);
+ 
+ #ifdef CONFIG_SFC_SRIOV
+ 	if (efx->pci_dev->is_virtfn && efx->pci_dev->physfn) {
+ 		struct pci_dev *pci_dev_pf = efx->pci_dev->physfn;
+ 
+ 		if (rc == -EPERM) {
+ 			struct efx_nic *efx_pf;
+ 
+ 			/* Switch to PF and change MAC address on vport */
+ 			efx_pf = pci_get_drvdata(pci_dev_pf);
+ 
+ 			rc = efx_ef10_sriov_set_vf_mac(efx_pf,
+ 						       nic_data->vf_index,
+ 						       efx->net_dev->dev_addr);
+ 		} else if (!rc) {
+ 			struct efx_nic *efx_pf = pci_get_drvdata(pci_dev_pf);
+ 			struct efx_ef10_nic_data *nic_data = efx_pf->nic_data;
+ 			unsigned int i;
+ 
+ 			/* MAC address successfully changed by VF (with MAC
+ 			 * spoofing) so update the parent PF if possible.
+ 			 */
+ 			for (i = 0; i < efx_pf->vf_count; ++i) {
+ 				struct ef10_vf *vf = nic_data->vf + i;
+ 
+ 				if (vf->efx == efx) {
+ 					ether_addr_copy(vf->mac,
+ 							efx->net_dev->dev_addr);
+ 					return 0;
+ 				}
+ 			}
+ 		}
+ 	} else
+ #endif
+ 	if (rc == -EPERM) {
+ 		netif_err(efx, drv, efx->net_dev,
+ 			  "Cannot change MAC address; use sfboot to enable"
+ 			  " mac-spoofing on this interface\n");
+ 	} else if (rc == -ENOSYS && !efx_ef10_is_vf(efx)) {
+ 		/* If the active MCFW does not support MC_CMD_VADAPTOR_SET_MAC
+ 		 * fall-back to the method of changing the MAC address on the
+ 		 * vport.  This only applies to PFs because such versions of
+ 		 * MCFW do not support VFs.
+ 		 */
+ 		rc = efx_ef10_vport_set_mac_address(efx);
+ 	} else {
+ 		efx_mcdi_display_error(efx, MC_CMD_VADAPTOR_SET_MAC,
+ 				       sizeof(inbuf), NULL, 0, rc);
+ 	}
+ 
+ 	return rc;
+ }
+ 
++>>>>>>> 535a61777f44 (sfc: suppress handled MCDI failures when changing the MAC address)
  static int efx_ef10_mac_reconfigure(struct efx_nic *efx)
  {
  	efx_ef10_filter_sync_rx_mode(efx);
* Unmerged path drivers/net/ethernet/sfc/ef10.c
