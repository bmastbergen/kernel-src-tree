ipv6: Add a receive path hook for vti6 in xfrm6_mode_tunnel.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] ipv6: Add a receive path hook for vti6 in xfrm6_mode_tunnel (Alexander Duyck) [1129761]
Rebuild_FUZZ: 99.16%
commit-author Steffen Klassert <steffen.klassert@secunet.com>
commit 212e560112598cfa8a3061237dd9db5f2252e48c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/212e5601.failed

Add a receive path hook for the IPsec vritual tunnel interface.

	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit 212e560112598cfa8a3061237dd9db5f2252e48c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/xfrm.h
diff --cc include/net/xfrm.h
index 5211203ed953,6b82fdf4ba71..000000000000
--- a/include/net/xfrm.h
+++ b/include/net/xfrm.h
@@@ -1512,44 -1496,43 +1512,76 @@@ extern int xfrm4_rcv(struct sk_buff *sk
  
  static inline int xfrm4_rcv_spi(struct sk_buff *skb, int nexthdr, __be32 spi)
  {
 -	return xfrm4_rcv_encap(skb, nexthdr, spi, 0);
 -}
 -
 +	XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4 = NULL;
 +	XFRM_SPI_SKB_CB(skb)->family = AF_INET;
 +	XFRM_SPI_SKB_CB(skb)->daddroff = offsetof(struct iphdr, daddr);
 +	return xfrm_input(skb, nexthdr, spi, 0);
 +}
 +
++<<<<<<< HEAD
 +extern int xfrm4_extract_output(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm4_prepare_output(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm4_output(struct sock *sk, struct sk_buff *skb);
 +extern int xfrm4_output_finish(struct sk_buff *skb);
 +extern int xfrm4_rcv_cb(struct sk_buff *skb, u8 protocol, int err);
 +extern int xfrm4_protocol_register(struct xfrm4_protocol *handler, unsigned char protocol);
 +extern int xfrm4_protocol_deregister(struct xfrm4_protocol *handler, unsigned char protocol);
 +extern int xfrm4_tunnel_register(struct xfrm_tunnel *handler, unsigned short family);
 +extern int xfrm4_tunnel_deregister(struct xfrm_tunnel *handler, unsigned short family);
 +extern int xfrm4_mode_tunnel_input_register(struct xfrm_tunnel_notifier *handler);
 +extern int xfrm4_mode_tunnel_input_deregister(struct xfrm_tunnel_notifier *handler);
 +extern int xfrm6_extract_header(struct sk_buff *skb);
 +extern int xfrm6_extract_input(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm6_rcv_spi(struct sk_buff *skb, int nexthdr, __be32 spi);
 +extern int xfrm6_transport_finish(struct sk_buff *skb, int async);
 +extern int xfrm6_rcv(struct sk_buff *skb);
 +extern int xfrm6_input_addr(struct sk_buff *skb, xfrm_address_t *daddr,
 +			    xfrm_address_t *saddr, u8 proto);
 +extern int xfrm6_tunnel_register(struct xfrm6_tunnel *handler, unsigned short family);
 +extern int xfrm6_tunnel_deregister(struct xfrm6_tunnel *handler, unsigned short family);
 +extern __be32 xfrm6_tunnel_alloc_spi(struct net *net, xfrm_address_t *saddr);
 +extern __be32 xfrm6_tunnel_spi_lookup(struct net *net, const xfrm_address_t *saddr);
 +extern int xfrm6_extract_output(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm6_prepare_output(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm6_output(struct sock *sk, struct sk_buff *skb);
 +extern int xfrm6_output_finish(struct sk_buff *skb);
 +extern int xfrm6_find_1stfragopt(struct xfrm_state *x, struct sk_buff *skb,
 +				 u8 **prevhdr);
++=======
+ int xfrm4_extract_output(struct xfrm_state *x, struct sk_buff *skb);
+ int xfrm4_prepare_output(struct xfrm_state *x, struct sk_buff *skb);
+ int xfrm4_output(struct sk_buff *skb);
+ int xfrm4_output_finish(struct sk_buff *skb);
+ int xfrm4_tunnel_register(struct xfrm_tunnel *handler, unsigned short family);
+ int xfrm4_tunnel_deregister(struct xfrm_tunnel *handler, unsigned short family);
+ void xfrm4_local_error(struct sk_buff *skb, u32 mtu);
+ int xfrm4_mode_tunnel_input_register(struct xfrm_tunnel_notifier *handler);
+ int xfrm4_mode_tunnel_input_deregister(struct xfrm_tunnel_notifier *handler);
+ int xfrm6_mode_tunnel_input_register(struct xfrm_tunnel_notifier *handler);
+ int xfrm6_mode_tunnel_input_deregister(struct xfrm_tunnel_notifier *handler);
+ int xfrm6_extract_header(struct sk_buff *skb);
+ int xfrm6_extract_input(struct xfrm_state *x, struct sk_buff *skb);
+ int xfrm6_rcv_spi(struct sk_buff *skb, int nexthdr, __be32 spi);
+ int xfrm6_transport_finish(struct sk_buff *skb, int async);
+ int xfrm6_rcv(struct sk_buff *skb);
+ int xfrm6_input_addr(struct sk_buff *skb, xfrm_address_t *daddr,
+ 		     xfrm_address_t *saddr, u8 proto);
+ void xfrm6_local_error(struct sk_buff *skb, u32 mtu);
+ int xfrm6_tunnel_register(struct xfrm6_tunnel *handler, unsigned short family);
+ int xfrm6_tunnel_deregister(struct xfrm6_tunnel *handler, unsigned short family);
+ __be32 xfrm6_tunnel_alloc_spi(struct net *net, xfrm_address_t *saddr);
+ __be32 xfrm6_tunnel_spi_lookup(struct net *net, const xfrm_address_t *saddr);
+ int xfrm6_extract_output(struct xfrm_state *x, struct sk_buff *skb);
+ int xfrm6_prepare_output(struct xfrm_state *x, struct sk_buff *skb);
+ int xfrm6_output(struct sk_buff *skb);
+ int xfrm6_output_finish(struct sk_buff *skb);
+ int xfrm6_find_1stfragopt(struct xfrm_state *x, struct sk_buff *skb,
+ 			  u8 **prevhdr);
++>>>>>>> 212e56011259 (ipv6: Add a receive path hook for vti6 in xfrm6_mode_tunnel.)
  
  #ifdef CONFIG_XFRM
 -int xfrm4_udp_encap_rcv(struct sock *sk, struct sk_buff *skb);
 -int xfrm_user_policy(struct sock *sk, int optname,
 -		     u8 __user *optval, int optlen);
 +extern int xfrm4_udp_encap_rcv(struct sock *sk, struct sk_buff *skb);
 +extern int xfrm_user_policy(struct sock *sk, int optname, u8 __user *optval, int optlen);
  #else
  static inline int xfrm_user_policy(struct sock *sk, int optname, u8 __user *optval, int optlen)
  {
* Unmerged path include/net/xfrm.h
diff --git a/net/ipv6/xfrm6_mode_tunnel.c b/net/ipv6/xfrm6_mode_tunnel.c
index 4770d515c2c8..cb04f7a16b5e 100644
--- a/net/ipv6/xfrm6_mode_tunnel.c
+++ b/net/ipv6/xfrm6_mode_tunnel.c
@@ -18,6 +18,65 @@
 #include <net/ipv6.h>
 #include <net/xfrm.h>
 
+/* Informational hook. The decap is still done here. */
+static struct xfrm_tunnel_notifier __rcu *rcv_notify_handlers __read_mostly;
+static DEFINE_MUTEX(xfrm6_mode_tunnel_input_mutex);
+
+int xfrm6_mode_tunnel_input_register(struct xfrm_tunnel_notifier *handler)
+{
+	struct xfrm_tunnel_notifier __rcu **pprev;
+	struct xfrm_tunnel_notifier *t;
+	int ret = -EEXIST;
+	int priority = handler->priority;
+
+	mutex_lock(&xfrm6_mode_tunnel_input_mutex);
+
+	for (pprev = &rcv_notify_handlers;
+	     (t = rcu_dereference_protected(*pprev,
+	     lockdep_is_held(&xfrm6_mode_tunnel_input_mutex))) != NULL;
+	     pprev = &t->next) {
+		if (t->priority > priority)
+			break;
+		if (t->priority == priority)
+			goto err;
+
+	}
+
+	handler->next = *pprev;
+	rcu_assign_pointer(*pprev, handler);
+
+	ret = 0;
+
+err:
+	mutex_unlock(&xfrm6_mode_tunnel_input_mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(xfrm6_mode_tunnel_input_register);
+
+int xfrm6_mode_tunnel_input_deregister(struct xfrm_tunnel_notifier *handler)
+{
+	struct xfrm_tunnel_notifier __rcu **pprev;
+	struct xfrm_tunnel_notifier *t;
+	int ret = -ENOENT;
+
+	mutex_lock(&xfrm6_mode_tunnel_input_mutex);
+	for (pprev = &rcv_notify_handlers;
+	     (t = rcu_dereference_protected(*pprev,
+	     lockdep_is_held(&xfrm6_mode_tunnel_input_mutex))) != NULL;
+	     pprev = &t->next) {
+		if (t == handler) {
+			*pprev = handler->next;
+			ret = 0;
+			break;
+		}
+	}
+	mutex_unlock(&xfrm6_mode_tunnel_input_mutex);
+	synchronize_net();
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(xfrm6_mode_tunnel_input_deregister);
+
 static inline void ipip6_ecn_decapsulate(struct sk_buff *skb)
 {
 	const struct ipv6hdr *outer_iph = ipv6_hdr(skb);
@@ -63,8 +122,15 @@ static int xfrm6_mode_tunnel_output(struct xfrm_state *x, struct sk_buff *skb)
 	return 0;
 }
 
+#define for_each_input_rcu(head, handler)	\
+	for (handler = rcu_dereference(head);	\
+	     handler != NULL;			\
+	     handler = rcu_dereference(handler->next))
+
+
 static int xfrm6_mode_tunnel_input(struct xfrm_state *x, struct sk_buff *skb)
 {
+	struct xfrm_tunnel_notifier *handler;
 	int err = -EINVAL;
 
 	if (XFRM_MODE_SKB_CB(skb)->protocol != IPPROTO_IPV6)
@@ -72,6 +138,9 @@ static int xfrm6_mode_tunnel_input(struct xfrm_state *x, struct sk_buff *skb)
 	if (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))
 		goto out;
 
+	for_each_input_rcu(rcv_notify_handlers, handler)
+		handler->handler(skb);
+
 	err = skb_unclone(skb, GFP_ATOMIC);
 	if (err)
 		goto out;
