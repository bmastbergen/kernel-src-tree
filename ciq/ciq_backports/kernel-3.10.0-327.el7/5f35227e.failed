net: Generalize ndo_gso_check to ndo_features_check

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] Generalize ndo_gso_check to ndo_features_check (Ivan Vecera) [1200759]
Rebuild_FUZZ: 94.85%
commit-author Jesse Gross <jesse@nicira.com>
commit 5f35227ea34bb616c436d9da47fc325866c428f3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/5f35227e.failed

GSO isn't the only offload feature with restrictions that
potentially can't be expressed with the current features mechanism.
Checksum is another although it's a general issue that could in
theory apply to anything. Even if it may be possible to
implement these restrictions in other ways, it can result in
duplicate code or inefficient per-packet behavior.

This generalizes ndo_gso_check so that drivers can remove any
features that don't make sense for a given packet, similar to
netif_skb_features(). It also converts existing driver
restrictions to the new format, completing the work that was
done to support tunnel protocols since the issues apply to
checksums as well.

By actually removing features from the set that are used to do
offloading, it solves another problem with the existing
interface. In these cases, GSO would run with the original set
of features and not do anything because it appears that
segmentation is not required.

CC: Tom Herbert <therbert@google.com>
CC: Joe Stringer <joestringer@nicira.com>
CC: Eric Dumazet <edumazet@google.com>
CC: Hayes Wang <hayeswang@realtek.com>
	Signed-off-by: Jesse Gross <jesse@nicira.com>
	Acked-by:  Tom Herbert <therbert@google.com>
Fixes: 04ffcb255f22 ("net: Add ndo_gso_check")
	Tested-by: Hayes Wang <hayeswang@realtek.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5f35227ea34bb616c436d9da47fc325866c428f3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx4/en_netdev.c
#	include/linux/netdevice.h
#	include/net/vxlan.h
#	net/core/dev.c
diff --cc drivers/net/ethernet/mellanox/mlx4/en_netdev.c
index 6d30799d466a,d0d6dc1b8e46..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
@@@ -2432,6 -2436,7 +2434,10 @@@ static const struct net_device_ops mlx4
  #ifdef CONFIG_MLX4_EN_VXLAN
  	.ndo_add_vxlan_port	= mlx4_en_add_vxlan_port,
  	.ndo_del_vxlan_port	= mlx4_en_del_vxlan_port,
++<<<<<<< HEAD
++=======
+ 	.ndo_features_check	= mlx4_en_features_check,
++>>>>>>> 5f35227ea34b (net: Generalize ndo_gso_check to ndo_features_check)
  #endif
  };
  
diff --cc include/linux/netdevice.h
index d77c2cff9dff,679e6e90aa4c..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -963,6 -993,43 +963,46 @@@ struct netdev_phys_port_id 
   *	Called by vxlan to notify the driver about a UDP port and socket
   *	address family that vxlan is not listening to anymore. The operation
   *	is protected by the vxlan_net->sock_lock.
++<<<<<<< HEAD
++=======
+  *
+  * void* (*ndo_dfwd_add_station)(struct net_device *pdev,
+  *				 struct net_device *dev)
+  *	Called by upper layer devices to accelerate switching or other
+  *	station functionality into hardware. 'pdev is the lowerdev
+  *	to use for the offload and 'dev' is the net device that will
+  *	back the offload. Returns a pointer to the private structure
+  *	the upper layer will maintain.
+  * void (*ndo_dfwd_del_station)(struct net_device *pdev, void *priv)
+  *	Called by upper layer device to delete the station created
+  *	by 'ndo_dfwd_add_station'. 'pdev' is the net device backing
+  *	the station and priv is the structure returned by the add
+  *	operation.
+  * netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff *skb,
+  *				      struct net_device *dev,
+  *				      void *priv);
+  *	Callback to use for xmit over the accelerated station. This
+  *	is used in place of ndo_start_xmit on accelerated net
+  *	devices.
+  * netdev_features_t (*ndo_features_check) (struct sk_buff *skb,
+  *					    struct net_device *dev
+  *					    netdev_features_t features);
+  *	Called by core transmit path to determine if device is capable of
+  *	performing offload operations on a given packet. This is to give
+  *	the device an opportunity to implement any restrictions that cannot
+  *	be otherwise expressed by feature flags. The check is called with
+  *	the set of features that the stack has calculated and it returns
+  *	those the driver believes to be appropriate.
+  *
+  * int (*ndo_switch_parent_id_get)(struct net_device *dev,
+  *				   struct netdev_phys_item_id *psid);
+  *	Called to get an ID of the switch chip this port is part of.
+  *	If driver implements this, it indicates that it represents a port
+  *	of a switch chip.
+  * int (*ndo_switch_port_stp_update)(struct net_device *dev, u8 state);
+  *	Called to notify switch device port of bridge port STP
+  *	state change.
++>>>>>>> 5f35227ea34b (net: Generalize ndo_gso_check to ndo_features_check)
   */
  struct net_device_ops {
  	int			(*ndo_init)(struct net_device *dev);
@@@ -1100,36 -1172,318 +1140,57 @@@
  						      sa_family_t sa_family,
  						      __be16 port);
  
++<<<<<<< HEAD
 +	/* RHEL SPECIFIC
 +	 *
 +	 * The following padding has been inserted before ABI freeze to
 +	 * allow extending the structure while preserve ABI. Feel free
 +	 * to replace reserved slots with required structure field
 +	 * additions of your backport.
 +	 */
 +	RH_KABI_RESERVE_P(1)
 +	RH_KABI_RESERVE_P(2)
 +	RH_KABI_RESERVE_P(3)
 +	RH_KABI_RESERVE_P(4)
 +	RH_KABI_RESERVE_P(5)
 +	RH_KABI_RESERVE_P(6)
 +	RH_KABI_RESERVE_P(7)
 +	RH_KABI_RESERVE_P(8)
 +	RH_KABI_RESERVE_P(9)
 +	RH_KABI_RESERVE_P(10)
 +	RH_KABI_RESERVE_P(11)
 +	RH_KABI_RESERVE_P(12)
 +	RH_KABI_RESERVE_P(13)
 +	RH_KABI_RESERVE_P(14)
 +	RH_KABI_RESERVE_P(15)
 +	RH_KABI_RESERVE_P(16)
++=======
+ 	void*			(*ndo_dfwd_add_station)(struct net_device *pdev,
+ 							struct net_device *dev);
+ 	void			(*ndo_dfwd_del_station)(struct net_device *pdev,
+ 							void *priv);
+ 
+ 	netdev_tx_t		(*ndo_dfwd_start_xmit) (struct sk_buff *skb,
+ 							struct net_device *dev,
+ 							void *priv);
+ 	int			(*ndo_get_lock_subclass)(struct net_device *dev);
+ 	netdev_features_t	(*ndo_features_check) (struct sk_buff *skb,
+ 						       struct net_device *dev,
+ 						       netdev_features_t features);
+ #ifdef CONFIG_NET_SWITCHDEV
+ 	int			(*ndo_switch_parent_id_get)(struct net_device *dev,
+ 							    struct netdev_phys_item_id *psid);
+ 	int			(*ndo_switch_port_stp_update)(struct net_device *dev,
+ 							      u8 state);
+ #endif
++>>>>>>> 5f35227ea34b (net: Generalize ndo_gso_check to ndo_features_check)
  };
  
 -/**
 - * enum net_device_priv_flags - &struct net_device priv_flags
 - *
 - * These are the &struct net_device, they are only set internally
 - * by drivers and used in the kernel. These flags are invisible to
 - * userspace, this means that the order of these flags can change
 - * during any kernel release.
 - *
 - * You should have a pretty good reason to be extending these flags.
 - *
 - * @IFF_802_1Q_VLAN: 802.1Q VLAN device
 - * @IFF_EBRIDGE: Ethernet bridging device
 - * @IFF_SLAVE_INACTIVE: bonding slave not the curr. active
 - * @IFF_MASTER_8023AD: bonding master, 802.3ad
 - * @IFF_MASTER_ALB: bonding master, balance-alb
 - * @IFF_BONDING: bonding master or slave
 - * @IFF_SLAVE_NEEDARP: need ARPs for validation
 - * @IFF_ISATAP: ISATAP interface (RFC4214)
 - * @IFF_MASTER_ARPMON: bonding master, ARP mon in use
 - * @IFF_WAN_HDLC: WAN HDLC device
 - * @IFF_XMIT_DST_RELEASE: dev_hard_start_xmit() is allowed to
 - *	release skb->dst
 - * @IFF_DONT_BRIDGE: disallow bridging this ether dev
 - * @IFF_DISABLE_NETPOLL: disable netpoll at run-time
 - * @IFF_MACVLAN_PORT: device used as macvlan port
 - * @IFF_BRIDGE_PORT: device used as bridge port
 - * @IFF_OVS_DATAPATH: device used as Open vSwitch datapath port
 - * @IFF_TX_SKB_SHARING: The interface supports sharing skbs on transmit
 - * @IFF_UNICAST_FLT: Supports unicast filtering
 - * @IFF_TEAM_PORT: device used as team port
 - * @IFF_SUPP_NOFCS: device supports sending custom FCS
 - * @IFF_LIVE_ADDR_CHANGE: device supports hardware address
 - *	change when it's running
 - * @IFF_MACVLAN: Macvlan device
 - */
 -enum netdev_priv_flags {
 -	IFF_802_1Q_VLAN			= 1<<0,
 -	IFF_EBRIDGE			= 1<<1,
 -	IFF_SLAVE_INACTIVE		= 1<<2,
 -	IFF_MASTER_8023AD		= 1<<3,
 -	IFF_MASTER_ALB			= 1<<4,
 -	IFF_BONDING			= 1<<5,
 -	IFF_SLAVE_NEEDARP		= 1<<6,
 -	IFF_ISATAP			= 1<<7,
 -	IFF_MASTER_ARPMON		= 1<<8,
 -	IFF_WAN_HDLC			= 1<<9,
 -	IFF_XMIT_DST_RELEASE		= 1<<10,
 -	IFF_DONT_BRIDGE			= 1<<11,
 -	IFF_DISABLE_NETPOLL		= 1<<12,
 -	IFF_MACVLAN_PORT		= 1<<13,
 -	IFF_BRIDGE_PORT			= 1<<14,
 -	IFF_OVS_DATAPATH		= 1<<15,
 -	IFF_TX_SKB_SHARING		= 1<<16,
 -	IFF_UNICAST_FLT			= 1<<17,
 -	IFF_TEAM_PORT			= 1<<18,
 -	IFF_SUPP_NOFCS			= 1<<19,
 -	IFF_LIVE_ADDR_CHANGE		= 1<<20,
 -	IFF_MACVLAN			= 1<<21,
 -	IFF_XMIT_DST_RELEASE_PERM	= 1<<22,
 -	IFF_IPVLAN_MASTER		= 1<<23,
 -	IFF_IPVLAN_SLAVE		= 1<<24,
 -};
 -
 -#define IFF_802_1Q_VLAN			IFF_802_1Q_VLAN
 -#define IFF_EBRIDGE			IFF_EBRIDGE
 -#define IFF_SLAVE_INACTIVE		IFF_SLAVE_INACTIVE
 -#define IFF_MASTER_8023AD		IFF_MASTER_8023AD
 -#define IFF_MASTER_ALB			IFF_MASTER_ALB
 -#define IFF_BONDING			IFF_BONDING
 -#define IFF_SLAVE_NEEDARP		IFF_SLAVE_NEEDARP
 -#define IFF_ISATAP			IFF_ISATAP
 -#define IFF_MASTER_ARPMON		IFF_MASTER_ARPMON
 -#define IFF_WAN_HDLC			IFF_WAN_HDLC
 -#define IFF_XMIT_DST_RELEASE		IFF_XMIT_DST_RELEASE
 -#define IFF_DONT_BRIDGE			IFF_DONT_BRIDGE
 -#define IFF_DISABLE_NETPOLL		IFF_DISABLE_NETPOLL
 -#define IFF_MACVLAN_PORT		IFF_MACVLAN_PORT
 -#define IFF_BRIDGE_PORT			IFF_BRIDGE_PORT
 -#define IFF_OVS_DATAPATH		IFF_OVS_DATAPATH
 -#define IFF_TX_SKB_SHARING		IFF_TX_SKB_SHARING
 -#define IFF_UNICAST_FLT			IFF_UNICAST_FLT
 -#define IFF_TEAM_PORT			IFF_TEAM_PORT
 -#define IFF_SUPP_NOFCS			IFF_SUPP_NOFCS
 -#define IFF_LIVE_ADDR_CHANGE		IFF_LIVE_ADDR_CHANGE
 -#define IFF_MACVLAN			IFF_MACVLAN
 -#define IFF_XMIT_DST_RELEASE_PERM	IFF_XMIT_DST_RELEASE_PERM
 -#define IFF_IPVLAN_MASTER		IFF_IPVLAN_MASTER
 -#define IFF_IPVLAN_SLAVE		IFF_IPVLAN_SLAVE
 -
 -/**
 - *	struct net_device - The DEVICE structure.
 - *		Actually, this whole structure is a big mistake.  It mixes I/O
 - *		data with strictly "high-level" data, and it has to know about
 - *		almost every data structure used in the INET module.
 - *
 - *	@name:	This is the first field of the "visible" part of this structure
 - *		(i.e. as seen by users in the "Space.c" file).  It is the name
 - *	 	of the interface.
 - *
 - *	@name_hlist: 	Device name hash chain, please keep it close to name[]
 - *	@ifalias:	SNMP alias
 - *	@mem_end:	Shared memory end
 - *	@mem_start:	Shared memory start
 - *	@base_addr:	Device I/O address
 - *	@irq:		Device IRQ number
 - *
 - *	@state:		Generic network queuing layer state, see netdev_state_t
 - *	@dev_list:	The global list of network devices
 - *	@napi_list:	List entry, that is used for polling napi devices
 - *	@unreg_list:	List entry, that is used, when we are unregistering the
 - *			device, see the function unregister_netdev
 - *	@close_list:	List entry, that is used, when we are closing the device
 - *
 - *	@adj_list:	Directly linked devices, like slaves for bonding
 - *	@all_adj_list:	All linked devices, *including* neighbours
 - *	@features:	Currently active device features
 - *	@hw_features:	User-changeable features
 - *
 - *	@wanted_features:	User-requested features
 - *	@vlan_features:		Mask of features inheritable by VLAN devices
 - *
 - *	@hw_enc_features:	Mask of features inherited by encapsulating devices
 - *				This field indicates what encapsulation
 - *				offloads the hardware is capable of doing,
 - *				and drivers will need to set them appropriately.
 - *
 - *	@mpls_features:	Mask of features inheritable by MPLS
 - *
 - *	@ifindex:	interface index
 - *	@iflink:	unique device identifier
 - *
 - *	@stats:		Statistics struct, which was left as a legacy, use
 - *			rtnl_link_stats64 instead
 - *
 - *	@rx_dropped:	Dropped packets by core network,
 - *			do not use this in drivers
 - *	@tx_dropped:	Dropped packets by core network,
 - *			do not use this in drivers
 - *
 - *	@carrier_changes:	Stats to monitor carrier on<->off transitions
 - *
 - *	@wireless_handlers:	List of functions to handle Wireless Extensions,
 - *				instead of ioctl,
 - *				see <net/iw_handler.h> for details.
 - *	@wireless_data:	Instance data managed by the core of wireless extensions
 - *
 - *	@netdev_ops:	Includes several pointers to callbacks,
 - *			if one wants to override the ndo_*() functions
 - *	@ethtool_ops:	Management operations
 - *	@fwd_ops:	Management operations
 - *	@header_ops:	Includes callbacks for creating,parsing,rebuilding,etc
 - *			of Layer 2 headers.
 - *
 - *	@flags:		Interface flags (a la BSD)
 - *	@priv_flags:	Like 'flags' but invisible to userspace,
 - *			see if.h for the definitions
 - *	@gflags:	Global flags ( kept as legacy )
 - *	@padded:	How much padding added by alloc_netdev()
 - *	@operstate:	RFC2863 operstate
 - *	@link_mode:	Mapping policy to operstate
 - *	@if_port:	Selectable AUI, TP, ...
 - *	@dma:		DMA channel
 - *	@mtu:		Interface MTU value
 - *	@type:		Interface hardware type
 - *	@hard_header_len: Hardware header length
 - *
 - *	@needed_headroom: Extra headroom the hardware may need, but not in all
 - *			  cases can this be guaranteed
 - *	@needed_tailroom: Extra tailroom the hardware may need, but not in all
 - *			  cases can this be guaranteed. Some cases also use
 - *			  LL_MAX_HEADER instead to allocate the skb
 - *
 - *	interface address info:
 - *
 - * 	@perm_addr:		Permanent hw address
 - * 	@addr_assign_type:	Hw address assignment type
 - * 	@addr_len:		Hardware address length
 - * 	@neigh_priv_len;	Used in neigh_alloc(),
 - * 				initialized only in atm/clip.c
 - * 	@dev_id:		Used to differentiate devices that share
 - * 				the same link layer address
 - * 	@dev_port:		Used to differentiate devices that share
 - * 				the same function
 - *	@addr_list_lock:	XXX: need comments on this one
 - *	@uc:			unicast mac addresses
 - *	@mc:			multicast mac addresses
 - *	@dev_addrs:		list of device hw addresses
 - *	@queues_kset:		Group of all Kobjects in the Tx and RX queues
 - *	@uc_promisc:		Counter, that indicates, that promiscuous mode
 - *				has been enabled due to the need to listen to
 - *				additional unicast addresses in a device that
 - *				does not implement ndo_set_rx_mode()
 - *	@promiscuity:		Number of times, the NIC is told to work in
 - *				Promiscuous mode, if it becomes 0 the NIC will
 - *				exit from working in Promiscuous mode
 - *	@allmulti:		Counter, enables or disables allmulticast mode
 - *
 - *	@vlan_info:	VLAN info
 - *	@dsa_ptr:	dsa specific data
 - *	@tipc_ptr:	TIPC specific data
 - *	@atalk_ptr:	AppleTalk link
 - *	@ip_ptr:	IPv4 specific data
 - *	@dn_ptr:	DECnet specific data
 - *	@ip6_ptr:	IPv6 specific data
 - *	@ax25_ptr:	AX.25 specific data
 - *	@ieee80211_ptr:	IEEE 802.11 specific data, assign before registering
 - *
 - *	@last_rx:	Time of last Rx
 - *	@dev_addr:	Hw address (before bcast,
 - *			because most packets are unicast)
 - *
 - *	@_rx:			Array of RX queues
 - *	@num_rx_queues:		Number of RX queues
 - *				allocated at register_netdev() time
 - *	@real_num_rx_queues: 	Number of RX queues currently active in device
 - *
 - *	@rx_handler:		handler for received packets
 - *	@rx_handler_data: 	XXX: need comments on this one
 - *	@ingress_queue:		XXX: need comments on this one
 - *	@broadcast:		hw bcast address
 - *
 - *	@_tx:			Array of TX queues
 - *	@num_tx_queues:		Number of TX queues allocated at alloc_netdev_mq() time
 - *	@real_num_tx_queues: 	Number of TX queues currently active in device
 - *	@qdisc:			Root qdisc from userspace point of view
 - *	@tx_queue_len:		Max frames per queue allowed
 - *	@tx_global_lock: 	XXX: need comments on this one
 - *
 - *	@xps_maps:	XXX: need comments on this one
 - *
 - *	@rx_cpu_rmap:	CPU reverse-mapping for RX completion interrupts,
 - *			indexed by RX queue number. Assigned by driver.
 - *			This must only be set if the ndo_rx_flow_steer
 - *			operation is defined
 - *
 - *	@trans_start:		Time (in jiffies) of last Tx
 - *	@watchdog_timeo:	Represents the timeout that is used by
 - *				the watchdog ( see dev_watchdog() )
 - *	@watchdog_timer:	List of timers
 - *
 - *	@pcpu_refcnt:		Number of references to this device
 - *	@todo_list:		Delayed register/unregister
 - *	@index_hlist:		Device index hash chain
 - *	@link_watch_list:	XXX: need comments on this one
 - *
 - *	@reg_state:		Register/unregister state machine
 - *	@dismantle:		Device is going to be freed
 - *	@rtnl_link_state:	This enum represents the phases of creating
 - *				a new link
 - *
 - *	@destructor:		Called from unregister,
 - *				can be used to call free_netdev
 - *	@npinfo:		XXX: need comments on this one
 - * 	@nd_net:		Network namespace this network device is inside
 - *
 - * 	@ml_priv:	Mid-layer private
 - * 	@lstats:	Loopback statistics
 - * 	@tstats:	Tunnel statistics
 - * 	@dstats:	Dummy statistics
 - * 	@vstats:	Virtual ethernet statistics
 - *
 - *	@garp_port:	GARP
 - *	@mrp_port:	MRP
 - *
 - *	@dev:		Class/net/name entry
 - *	@sysfs_groups:	Space for optional device, statistics and wireless
 - *			sysfs groups
 - *
 - *	@sysfs_rx_queue_group:	Space for optional per-rx queue attributes
 - *	@rtnl_link_ops:	Rtnl_link_ops
 - *
 - *	@gso_max_size:	Maximum size of generic segmentation offload
 - *	@gso_max_segs:	Maximum number of segments that can be passed to the
 - *			NIC for GSO
 - *	@gso_min_segs:	Minimum number of segments that can be passed to the
 - *			NIC for GSO
 - *
 - *	@dcbnl_ops:	Data Center Bridging netlink ops
 - *	@num_tc:	Number of traffic classes in the net device
 - *	@tc_to_txq:	XXX: need comments on this one
 - *	@prio_tc_map	XXX: need comments on this one
 - *
 - *	@fcoe_ddp_xid:	Max exchange id for FCoE LRO by ddp
 - *
 - *	@priomap:	XXX: need comments on this one
 - *	@phydev:	Physical device may attach itself
 - *			for hardware timestamping
 - *
 - *	@qdisc_tx_busylock:	XXX: need comments on this one
 - *
 - *	@group:		The group, that the device belongs to
 - *	@pm_qos_req:	Power Management QoS object
 +/*
 + *	The DEVICE structure.
 + *	Actually, this whole structure is a big mistake.  It mixes I/O
 + *	data with strictly "high-level" data, and it has to know about
 + *	almost every data structure used in the INET module.
   *
   *	FIXME: cleanup struct net_device such that network protocol info
   *	moves out.
diff --cc include/net/vxlan.h
index 1ddc74769f81,903461aa5644..000000000000
--- a/include/net/vxlan.h
+++ b/include/net/vxlan.h
@@@ -40,10 -49,39 +43,43 @@@ struct vxlan_sock *vxlan_sock_add(struc
  
  void vxlan_sock_release(struct vxlan_sock *vs);
  
 -int vxlan_xmit_skb(struct vxlan_sock *vs,
 +int vxlan_xmit_skb(struct net *net, struct vxlan_sock *vs,
  		   struct rtable *rt, struct sk_buff *skb,
  		   __be32 src, __be32 dst, __u8 tos, __u8 ttl, __be16 df,
++<<<<<<< HEAD
 +		   __be16 src_port, __be16 dst_port, __be32 vni);
++=======
+ 		   __be16 src_port, __be16 dst_port, __be32 vni, bool xnet);
+ 
+ static inline netdev_features_t vxlan_features_check(struct sk_buff *skb,
+ 						     netdev_features_t features)
+ {
+ 	u8 l4_hdr = 0;
+ 
+ 	if (!skb->encapsulation)
+ 		return features;
+ 
+ 	switch (vlan_get_protocol(skb)) {
+ 	case htons(ETH_P_IP):
+ 		l4_hdr = ip_hdr(skb)->protocol;
+ 		break;
+ 	case htons(ETH_P_IPV6):
+ 		l4_hdr = ipv6_hdr(skb)->nexthdr;
+ 		break;
+ 	default:
+ 		return features;;
+ 	}
+ 
+ 	if ((l4_hdr == IPPROTO_UDP) &&
+ 	    (skb->inner_protocol_type != ENCAP_TYPE_ETHER ||
+ 	     skb->inner_protocol != htons(ETH_P_TEB) ||
+ 	     (skb_inner_mac_header(skb) - skb_transport_header(skb) !=
+ 	      sizeof(struct udphdr) + sizeof(struct vxlanhdr))))
+ 		return features & ~(NETIF_F_ALL_CSUM | NETIF_F_GSO_MASK);
+ 
+ 	return features;
+ }
++>>>>>>> 5f35227ea34b (net: Generalize ndo_gso_check to ndo_features_check)
  
  /* IP header + UDP + VXLAN + Ethernet header */
  #define VXLAN_HEADROOM (20 + 8 + 8 + 14)
diff --cc net/core/dev.c
index 9a2bea4eeeee,683d493aa1bf..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -2460,12 -2563,21 +2460,25 @@@ static netdev_features_t harmonize_feat
  
  netdev_features_t netif_skb_features(struct sk_buff *skb)
  {
++<<<<<<< HEAD
++=======
+ 	struct net_device *dev = skb->dev;
+ 	netdev_features_t features = dev->features;
+ 	u16 gso_segs = skb_shinfo(skb)->gso_segs;
++>>>>>>> 5f35227ea34b (net: Generalize ndo_gso_check to ndo_features_check)
  	__be16 protocol = skb->protocol;
 +	netdev_features_t features = skb->dev->features;
  
 -	if (gso_segs > dev->gso_max_segs || gso_segs < dev->gso_min_segs)
 +	if (skb_shinfo(skb)->gso_segs > skb->dev->gso_max_segs)
  		features &= ~NETIF_F_GSO_MASK;
  
+ 	/* If encapsulation offload request, verify we are testing
+ 	 * hardware encapsulation features instead of standard
+ 	 * features for the netdev
+ 	 */
+ 	if (skb->encapsulation)
+ 		features &= dev->hw_enc_features;
+ 
  	if (!vlan_tx_tag_present(skb)) {
  		if (unlikely(protocol == htons(ETH_P_8021Q) ||
  			     protocol == htons(ETH_P_8021AD))) {
@@@ -2494,115 -2611,137 +2512,176 @@@ finalize
  }
  EXPORT_SYMBOL(netif_skb_features);
  
 -static int xmit_one(struct sk_buff *skb, struct net_device *dev,
 -		    struct netdev_queue *txq, bool more)
 -{
 -	unsigned int len;
 -	int rc;
 -
 -	if (!list_empty(&ptype_all))
 -		dev_queue_xmit_nit(skb, dev);
 -
 -	len = skb->len;
 -	trace_net_dev_start_xmit(skb, dev);
 -	rc = netdev_start_xmit(skb, dev, txq, more);
 -	trace_net_dev_xmit(skb, rc, dev, len);
 -
 -	return rc;
 -}
 -
 -struct sk_buff *dev_hard_start_xmit(struct sk_buff *first, struct net_device *dev,
 -				    struct netdev_queue *txq, int *ret)
 +int dev_hard_start_xmit(struct sk_buff *skb, struct net_device *dev,
 +			struct netdev_queue *txq)
  {
 -	struct sk_buff *skb = first;
 +	const struct net_device_ops *ops = dev->netdev_ops;
  	int rc = NETDEV_TX_OK;
 +	unsigned int skb_len;
  
 -	while (skb) {
 -		struct sk_buff *next = skb->next;
 +	if (likely(!skb->next)) {
 +		netdev_features_t features;
  
++<<<<<<< HEAD
 +		/*
 +		 * If device doesn't need skb->dst, release it right now while
 +		 * its hot in this cpu cache
++=======
+ 		skb->next = NULL;
+ 		rc = xmit_one(skb, dev, txq, next != NULL);
+ 		if (unlikely(!dev_xmit_complete(rc))) {
+ 			skb->next = next;
+ 			goto out;
+ 		}
+ 
+ 		skb = next;
+ 		if (netif_xmit_stopped(txq) && skb) {
+ 			rc = NETDEV_TX_BUSY;
+ 			break;
+ 		}
+ 	}
+ 
+ out:
+ 	*ret = rc;
+ 	return skb;
+ }
+ 
+ static struct sk_buff *validate_xmit_vlan(struct sk_buff *skb,
+ 					  netdev_features_t features)
+ {
+ 	if (vlan_tx_tag_present(skb) &&
+ 	    !vlan_hw_offload_capable(features, skb->vlan_proto))
+ 		skb = __vlan_hwaccel_push_inside(skb);
+ 	return skb;
+ }
+ 
+ static struct sk_buff *validate_xmit_skb(struct sk_buff *skb, struct net_device *dev)
+ {
+ 	netdev_features_t features;
+ 
+ 	if (skb->next)
+ 		return skb;
+ 
+ 	features = netif_skb_features(skb);
+ 	skb = validate_xmit_vlan(skb, features);
+ 	if (unlikely(!skb))
+ 		goto out_null;
+ 
+ 	if (netif_needs_gso(dev, skb, features)) {
+ 		struct sk_buff *segs;
+ 
+ 		segs = skb_gso_segment(skb, features);
+ 		if (IS_ERR(segs)) {
+ 			goto out_kfree_skb;
+ 		} else if (segs) {
+ 			consume_skb(skb);
+ 			skb = segs;
+ 		}
+ 	} else {
+ 		if (skb_needs_linearize(skb, features) &&
+ 		    __skb_linearize(skb))
+ 			goto out_kfree_skb;
+ 
+ 		/* If packet is not checksummed and device does not
+ 		 * support checksumming for this protocol, complete
+ 		 * checksumming here.
++>>>>>>> 5f35227ea34b (net: Generalize ndo_gso_check to ndo_features_check)
  		 */
 -		if (skb->ip_summed == CHECKSUM_PARTIAL) {
 -			if (skb->encapsulation)
 -				skb_set_inner_transport_header(skb,
 -							       skb_checksum_start_offset(skb));
 -			else
 -				skb_set_transport_header(skb,
 -							 skb_checksum_start_offset(skb));
 -			if (!(features & NETIF_F_ALL_CSUM) &&
 -			    skb_checksum_help(skb))
 -				goto out_kfree_skb;
 +		if (dev->priv_flags & IFF_XMIT_DST_RELEASE)
 +			skb_dst_drop(skb);
 +
 +		features = netif_skb_features(skb);
 +
 +		if (vlan_tx_tag_present(skb) &&
 +		    !vlan_hw_offload_capable(features, skb->vlan_proto)) {
 +			skb = __vlan_put_tag(skb, skb->vlan_proto,
 +					     vlan_tx_tag_get(skb));
 +			if (unlikely(!skb))
 +				goto out;
 +
 +			skb->vlan_tci = 0;
  		}
 -	}
  
 -	return skb;
 +		/* If encapsulation offload request, verify we are testing
 +		 * hardware encapsulation features instead of standard
 +		 * features for the netdev
 +		 */
 +		if (skb->encapsulation)
 +			features &= dev->hw_enc_features;
  
 -out_kfree_skb:
 -	kfree_skb(skb);
 -out_null:
 -	return NULL;
 -}
 +		if (netif_needs_gso(skb, features)) {
 +			if (unlikely(dev_gso_segment(skb, features)))
 +				goto out_kfree_skb;
 +			if (skb->next)
 +				goto gso;
 +		} else {
 +			if (skb_needs_linearize(skb, features) &&
 +			    __skb_linearize(skb))
 +				goto out_kfree_skb;
  
 -struct sk_buff *validate_xmit_skb_list(struct sk_buff *skb, struct net_device *dev)
 -{
 -	struct sk_buff *next, *head = NULL, *tail;
 +			/* If packet is not checksummed and device does not
 +			 * support checksumming for this protocol, complete
 +			 * checksumming here.
 +			 */
 +			if (skb->ip_summed == CHECKSUM_PARTIAL) {
 +				if (skb->encapsulation)
 +					skb_set_inner_transport_header(skb,
 +						skb_checksum_start_offset(skb));
 +				else
 +					skb_set_transport_header(skb,
 +						skb_checksum_start_offset(skb));
 +				if (!(features & NETIF_F_ALL_CSUM) &&
 +				     skb_checksum_help(skb))
 +					goto out_kfree_skb;
 +			}
 +		}
  
 -	for (; skb != NULL; skb = next) {
 -		next = skb->next;
 -		skb->next = NULL;
 +		if (!list_empty(&ptype_all))
 +			dev_queue_xmit_nit(skb, dev);
  
 -		/* in case skb wont be segmented, point to itself */
 -		skb->prev = skb;
 +		skb_len = skb->len;
 +		rc = ops->ndo_start_xmit(skb, dev);
 +		trace_net_dev_xmit(skb, rc, dev, skb_len);
 +		if (rc == NETDEV_TX_OK)
 +			txq_trans_update(txq);
 +		return rc;
 +	}
  
 -		skb = validate_xmit_skb(skb, dev);
 -		if (!skb)
 -			continue;
 +gso:
 +	do {
 +		struct sk_buff *nskb = skb->next;
  
 -		if (!head)
 -			head = skb;
 -		else
 -			tail->next = skb;
 -		/* If skb was segmented, skb->prev points to
 -		 * the last segment. If not, it still contains skb.
 -		 */
 -		tail = skb->prev;
 +		skb->next = nskb->next;
 +		nskb->next = NULL;
 +
 +		if (!list_empty(&ptype_all))
 +			dev_queue_xmit_nit(nskb, dev);
 +
 +		skb_len = nskb->len;
 +		rc = ops->ndo_start_xmit(nskb, dev);
 +		trace_net_dev_xmit(nskb, rc, dev, skb_len);
 +		if (unlikely(rc != NETDEV_TX_OK)) {
 +			if (rc & ~NETDEV_TX_MASK)
 +				goto out_kfree_gso_skb;
 +			nskb->next = skb->next;
 +			skb->next = nskb;
 +			return rc;
 +		}
 +		txq_trans_update(txq);
 +		if (unlikely(netif_xmit_stopped(txq) && skb->next))
 +			return NETDEV_TX_BUSY;
 +	} while (skb->next);
 +
 +out_kfree_gso_skb:
 +	if (likely(skb->next == NULL)) {
 +		skb->destructor = DEV_GSO_CB(skb)->destructor;
 +		consume_skb(skb);
 +		return rc;
  	}
 -	return head;
 +out_kfree_skb:
 +	kfree_skb(skb);
 +out:
 +	return rc;
  }
  
  static void qdisc_pkt_len_init(struct sk_buff *skb)
diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
index a4f4584b14c4..cf9268c39a32 100644
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
@@ -12439,9 +12439,11 @@ static int bnx2x_get_phys_port_id(struct net_device *netdev,
 	return 0;
 }
 
-static bool bnx2x_gso_check(struct sk_buff *skb, struct net_device *dev)
+static netdev_features_t bnx2x_features_check(struct sk_buff *skb,
+					      struct net_device *dev,
+					      netdev_features_t features)
 {
-	return vxlan_gso_check(skb);
+	return vxlan_features_check(skb, features);
 }
 
 static const struct net_device_ops bnx2x_netdev_ops = {
@@ -12475,7 +12477,7 @@ static const struct net_device_ops bnx2x_netdev_ops = {
 #endif
 	.ndo_get_phys_port_id	= bnx2x_get_phys_port_id,
 	.ndo_set_vf_link_state	= bnx2x_set_vf_link_state,
-	.ndo_gso_check		= bnx2x_gso_check,
+	.ndo_features_check	= bnx2x_features_check,
 };
 
 static int bnx2x_set_coherency_mask(struct bnx2x *bp)
diff --git a/drivers/net/ethernet/emulex/benet/be_main.c b/drivers/net/ethernet/emulex/benet/be_main.c
index 504f5524604a..4c79c5711bed 100644
--- a/drivers/net/ethernet/emulex/benet/be_main.c
+++ b/drivers/net/ethernet/emulex/benet/be_main.c
@@ -4416,9 +4416,11 @@ static void be_del_vxlan_port(struct net_device *netdev, sa_family_t sa_family,
 		 be16_to_cpu(port));
 }
 
-static bool be_gso_check(struct sk_buff *skb, struct net_device *dev)
+static netdev_features_t be_features_check(struct sk_buff *skb,
+					   struct net_device *dev,
+					   netdev_features_t features)
 {
-	return vxlan_gso_check(skb);
+	return vxlan_features_check(skb, features);
 }
 #endif
 
@@ -4449,7 +4451,7 @@ static const struct net_device_ops be_netdev_ops = {
 #ifdef CONFIG_BE2NET_VXLAN
 	.ndo_add_vxlan_port	= be_add_vxlan_port,
 	.ndo_del_vxlan_port	= be_del_vxlan_port,
-	.ndo_gso_check		= be_gso_check,
+	.ndo_features_check	= be_features_check,
 #endif
 };
 
* Unmerged path drivers/net/ethernet/mellanox/mlx4/en_netdev.c
diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
index 5b17fe84fe01..315714b31e56 100644
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
@@ -498,9 +498,11 @@ static void qlcnic_del_vxlan_port(struct net_device *netdev,
 	adapter->flags |= QLCNIC_DEL_VXLAN_PORT;
 }
 
-static bool qlcnic_gso_check(struct sk_buff *skb, struct net_device *dev)
+static netdev_features_t qlcnic_features_check(struct sk_buff *skb,
+					       struct net_device *dev,
+					       netdev_features_t features)
 {
-	return vxlan_gso_check(skb);
+	return vxlan_features_check(skb, features);
 }
 #endif
 
@@ -525,7 +527,7 @@ static const struct net_device_ops qlcnic_netdev_ops = {
 #ifdef CONFIG_QLCNIC_VXLAN
 	.ndo_add_vxlan_port	= qlcnic_add_vxlan_port,
 	.ndo_del_vxlan_port	= qlcnic_del_vxlan_port,
-	.ndo_gso_check		= qlcnic_gso_check,
+	.ndo_features_check	= qlcnic_features_check,
 #endif
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	.ndo_poll_controller = qlcnic_poll_controller,
* Unmerged path include/linux/netdevice.h
* Unmerged path include/net/vxlan.h
* Unmerged path net/core/dev.c
