xfs: add filestream allocator tracepoints

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Christoph Hellwig <hch@lst.de>
commit b94acd4786dce4379e986e6d58bdd74f8986af2f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/b94acd47.failed

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit b94acd4786dce4379e986e6d58bdd74f8986af2f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_filestream.c
diff --cc fs/xfs/xfs_filestream.c
index 12b6e7701985,8ec81bed7992..000000000000
--- a/fs/xfs/xfs_filestream.c
+++ b/fs/xfs/xfs_filestream.c
@@@ -32,96 -33,16 +32,104 @@@
  #include "xfs_filestream.h"
  #include "xfs_trace.h"
  
++<<<<<<< HEAD
 +#ifdef XFS_FILESTREAMS_TRACE
 +
 +ktrace_t *xfs_filestreams_trace_buf;
 +
 +STATIC void
 +xfs_filestreams_trace(
 +	xfs_mount_t	*mp,	/* mount point */
 +	int		type,	/* type of trace */
 +	const char	*func,	/* source function */
 +	int		line,	/* source line number */
 +	__psunsigned_t	arg0,
 +	__psunsigned_t	arg1,
 +	__psunsigned_t	arg2,
 +	__psunsigned_t	arg3,
 +	__psunsigned_t	arg4,
 +	__psunsigned_t	arg5)
 +{
 +	ktrace_enter(xfs_filestreams_trace_buf,
 +		(void *)(__psint_t)(type | (line << 16)),
 +		(void *)func,
 +		(void *)(__psunsigned_t)current_pid(),
 +		(void *)mp,
 +		(void *)(__psunsigned_t)arg0,
 +		(void *)(__psunsigned_t)arg1,
 +		(void *)(__psunsigned_t)arg2,
 +		(void *)(__psunsigned_t)arg3,
 +		(void *)(__psunsigned_t)arg4,
 +		(void *)(__psunsigned_t)arg5,
 +		NULL, NULL, NULL, NULL, NULL, NULL);
 +}
 +
 +#define TRACE0(mp,t)			TRACE6(mp,t,0,0,0,0,0,0)
 +#define TRACE1(mp,t,a0)			TRACE6(mp,t,a0,0,0,0,0,0)
 +#define TRACE2(mp,t,a0,a1)		TRACE6(mp,t,a0,a1,0,0,0,0)
 +#define TRACE3(mp,t,a0,a1,a2)		TRACE6(mp,t,a0,a1,a2,0,0,0)
 +#define TRACE4(mp,t,a0,a1,a2,a3)	TRACE6(mp,t,a0,a1,a2,a3,0,0)
 +#define TRACE5(mp,t,a0,a1,a2,a3,a4)	TRACE6(mp,t,a0,a1,a2,a3,a4,0)
 +#define TRACE6(mp,t,a0,a1,a2,a3,a4,a5) \
 +	xfs_filestreams_trace(mp, t, __func__, __LINE__, \
 +				(__psunsigned_t)a0, (__psunsigned_t)a1, \
 +				(__psunsigned_t)a2, (__psunsigned_t)a3, \
 +				(__psunsigned_t)a4, (__psunsigned_t)a5)
 +
 +#define TRACE_AG_SCAN(mp, ag, ag2) \
 +		TRACE2(mp, XFS_FSTRM_KTRACE_AGSCAN, ag, ag2);
 +#define TRACE_AG_PICK1(mp, max_ag, maxfree) \
 +		TRACE2(mp, XFS_FSTRM_KTRACE_AGPICK1, max_ag, maxfree);
 +#define TRACE_AG_PICK2(mp, ag, ag2, cnt, free, scan, flag) \
 +		TRACE6(mp, XFS_FSTRM_KTRACE_AGPICK2, ag, ag2, \
 +			 cnt, free, scan, flag)
 +#define TRACE_UPDATE(mp, ip, ag, cnt, ag2, cnt2) \
 +		TRACE5(mp, XFS_FSTRM_KTRACE_UPDATE, ip, ag, cnt, ag2, cnt2)
 +#define TRACE_FREE(mp, ip, pip, ag, cnt) \
 +		TRACE4(mp, XFS_FSTRM_KTRACE_FREE, ip, pip, ag, cnt)
 +#define TRACE_LOOKUP(mp, ip, pip, ag, cnt) \
 +		TRACE4(mp, XFS_FSTRM_KTRACE_ITEM_LOOKUP, ip, pip, ag, cnt)
 +#define TRACE_ASSOCIATE(mp, ip, pip, ag, cnt) \
 +		TRACE4(mp, XFS_FSTRM_KTRACE_ASSOCIATE, ip, pip, ag, cnt)
 +#define TRACE_MOVEAG(mp, ip, pip, oag, ocnt, nag, ncnt) \
 +		TRACE6(mp, XFS_FSTRM_KTRACE_MOVEAG, ip, pip, oag, ocnt, nag, ncnt)
 +#define TRACE_ORPHAN(mp, ip, ag) \
 +		TRACE2(mp, XFS_FSTRM_KTRACE_ORPHAN, ip, ag);
 +
 +
 +#else
 +#define TRACE_AG_SCAN(mp, ag, ag2)
 +#define TRACE_AG_PICK1(mp, max_ag, maxfree)
 +#define TRACE_AG_PICK2(mp, ag, ag2, cnt, free, scan, flag)
 +#define TRACE_UPDATE(mp, ip, ag, cnt, ag2, cnt2)
 +#define TRACE_FREE(mp, ip, pip, ag, cnt)
 +#define TRACE_LOOKUP(mp, ip, pip, ag, cnt)
 +#define TRACE_ASSOCIATE(mp, ip, pip, ag, cnt)
 +#define TRACE_MOVEAG(mp, ip, pip, oag, ocnt, nag, ncnt)
 +#define TRACE_ORPHAN(mp, ip, ag)
 +#endif
 +
 +static kmem_zone_t *item_zone;
++=======
+ struct xfs_fstrm_item {
+ 	struct xfs_mru_cache_elem	mru;
+ 	struct xfs_inode		*ip;
+ 	xfs_agnumber_t			ag; /* AG in use for this directory */
+ };
++>>>>>>> b94acd4786dc (xfs: add filestream allocator tracepoints)
  
 -enum xfs_fstrm_alloc {
 -	XFS_PICK_USERDATA = 1,
 -	XFS_PICK_LOWSPACE = 2,
 -};
 +/*
 + * Structure for associating a file or a directory with an allocation group.
 + * The parent directory pointer is only needed for files, but since there will
 + * generally be vastly more files than directories in the cache, using the same
 + * data structure simplifies the code with very little memory overhead.
 + */
 +typedef struct fstrm_item
 +{
 +	xfs_agnumber_t	ag;	/* AG currently in use for the file/directory. */
 +	xfs_inode_t	*ip;	/* inode self-pointer. */
 +	xfs_inode_t	*pip;	/* Parent directory inode pointer. */
 +} fstrm_item_t;
  
  /*
   * Allocation group filestream associations are tracked with per-ag atomic
@@@ -200,23 -121,40 +208,51 @@@ xfs_filestream_put_ag
  	xfs_perag_put(pag);
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ xfs_fstrm_free_func(
+ 	struct xfs_mru_cache_elem *mru)
+ {
+ 	struct xfs_fstrm_item	*item =
+ 		container_of(mru, struct xfs_fstrm_item, mru);
+ 
+ 	xfs_filestream_put_ag(item->ip->i_mount, item->ag);
+ 
+ 	trace_xfs_filestream_free(item->ip, item->ag);
+ 
+ 	kmem_free(item);
+ }
+ 
++>>>>>>> b94acd4786dc (xfs: add filestream allocator tracepoints)
  /*
   * Scan the AGs starting at startag looking for an AG that isn't in use and has
   * at least minlen blocks free.
   */
  static int
 -xfs_filestream_pick_ag(
 -	struct xfs_inode	*ip,
 -	xfs_agnumber_t		startag,
 -	xfs_agnumber_t		*agp,
 -	int			flags,
 -	xfs_extlen_t		minlen)
 +_xfs_filestream_pick_ag(
 +	xfs_mount_t	*mp,
 +	xfs_agnumber_t	startag,
 +	xfs_agnumber_t	*agp,
 +	int		flags,
 +	xfs_extlen_t	minlen)
  {
++<<<<<<< HEAD
 +	int		streams, max_streams;
 +	int		err, trylock, nscan;
 +	xfs_extlen_t	longest, free, minfree, maxfree = 0;
 +	xfs_agnumber_t	ag, max_ag = NULLAGNUMBER;
 +	struct xfs_perag *pag;
++=======
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct xfs_fstrm_item	*item;
+ 	struct xfs_perag	*pag;
+ 	xfs_extlen_t		longest, free = 0, minfree, maxfree = 0;
+ 	xfs_agnumber_t		ag, max_ag = NULLAGNUMBER;
+ 	int			err, trylock, nscan;
+ 
+ 	ASSERT(S_ISDIR(ip->i_d.di_mode));
++>>>>>>> b94acd4786dc (xfs: add filestream allocator tracepoints)
  
  	/* 2% of an AG's blocks must be free for it to be chosen. */
  	minfree = mp->m_sb.sb_agblocks / 50;
@@@ -318,305 -253,88 +351,343 @@@ next_ag
  		return 0;
  	}
  
- 	TRACE_AG_PICK2(mp, startag, *agp, streams, free, nscan, flags);
+ 	trace_xfs_filestream_pick(ip, *agp, free, nscan);
  
 -	if (*agp == NULLAGNUMBER)
 +	return 0;
 +}
 +
 +/*
 + * Set the allocation group number for a file or a directory, updating inode
 + * references and per-AG references as appropriate.
 + */
 +static int
 +_xfs_filestream_update_ag(
 +	xfs_inode_t	*ip,
 +	xfs_inode_t	*pip,
 +	xfs_agnumber_t	ag)
 +{
 +	int		err = 0;
 +	xfs_mount_t	*mp;
 +	xfs_mru_cache_t	*cache;
 +	fstrm_item_t	*item;
 +	xfs_agnumber_t	old_ag;
 +	xfs_inode_t	*old_pip;
 +
 +	/*
 +	 * Either ip is a regular file and pip is a directory, or ip is a
 +	 * directory and pip is NULL.
 +	 */
 +	ASSERT(ip && ((S_ISREG(ip->i_d.di_mode) && pip &&
 +	               S_ISDIR(pip->i_d.di_mode)) ||
 +	              (S_ISDIR(ip->i_d.di_mode) && !pip)));
 +
 +	mp = ip->i_mount;
 +	cache = mp->m_filestream;
 +
 +	item = xfs_mru_cache_lookup(cache, ip->i_ino);
 +	if (item) {
 +		ASSERT(item->ip == ip);
 +		old_ag = item->ag;
 +		item->ag = ag;
 +		old_pip = item->pip;
 +		item->pip = pip;
 +		xfs_mru_cache_done(cache);
 +
 +		/*
 +		 * If the AG has changed, drop the old ref and take a new one,
 +		 * effectively transferring the reference from old to new AG.
 +		 */
 +		if (ag != old_ag) {
 +			xfs_filestream_put_ag(mp, old_ag);
 +			xfs_filestream_get_ag(mp, ag);
 +		}
 +
 +		/*
 +		 * If ip is a file and its pip has changed, drop the old ref and
 +		 * take a new one.
 +		 */
 +		if (pip && pip != old_pip) {
 +			IRELE(old_pip);
 +			IHOLD(pip);
 +		}
 +
 +		TRACE_UPDATE(mp, ip, old_ag, xfs_filestream_peek_ag(mp, old_ag),
 +				ag, xfs_filestream_peek_ag(mp, ag));
  		return 0;
 +	}
  
 -	err = ENOMEM;
 -	item = kmem_alloc(sizeof(*item), KM_MAYFAIL);
 +	item = kmem_zone_zalloc(item_zone, KM_MAYFAIL);
  	if (!item)
 -		goto out_put_ag;
 +		return ENOMEM;
  
 -	item->ag = *agp;
 +	item->ag = ag;
  	item->ip = ip;
 +	item->pip = pip;
  
 -	err = xfs_mru_cache_insert(mp->m_filestream, ip->i_ino, &item->mru);
 +	err = xfs_mru_cache_insert(cache, ip->i_ino, item);
  	if (err) {
 -		if (err == EEXIST)
 -			err = 0;
 -		goto out_free_item;
 +		kmem_zone_free(item_zone, item);
 +		return err;
  	}
  
 -	return 0;
 +	/* Take a reference on the AG. */
 +	xfs_filestream_get_ag(mp, ag);
  
 -out_free_item:
 -	kmem_free(item);
 -out_put_ag:
 -	xfs_filestream_put_ag(mp, *agp);
 -	return err;
 +	/*
 +	 * Take a reference on the inode itself regardless of whether it's a
 +	 * regular file or a directory.
 +	 */
 +	IHOLD(ip);
 +
 +	/*
 +	 * In the case of a regular file, take a reference on the parent inode
 +	 * as well to ensure it remains in-core.
 +	 */
 +	if (pip)
 +		IHOLD(pip);
 +
 +	TRACE_UPDATE(mp, ip, ag, xfs_filestream_peek_ag(mp, ag),
 +			ag, xfs_filestream_peek_ag(mp, ag));
 +
 +	return 0;
  }
  
 -static struct xfs_inode *
 -xfs_filestream_get_parent(
 -	struct xfs_inode	*ip)
 +/* xfs_fstrm_free_func(): callback for freeing cached stream items. */
 +STATIC void
 +xfs_fstrm_free_func(
 +	unsigned long	ino,
 +	void		*data)
  {
 -	struct inode		*inode = VFS_I(ip), *dir = NULL;
 -	struct dentry		*dentry, *parent;
 +	fstrm_item_t	*item  = (fstrm_item_t *)data;
 +	xfs_inode_t	*ip = item->ip;
  
 -	dentry = d_find_alias(inode);
 -	if (!dentry)
 -		goto out;
 +	ASSERT(ip->i_ino == ino);
  
 -	parent = dget_parent(dentry);
 -	if (!parent)
 -		goto out_dput;
 +	xfs_iflags_clear(ip, XFS_IFILESTREAM);
  
 -	dir = igrab(parent->d_inode);
 -	dput(parent);
 +	/* Drop the reference taken on the AG when the item was added. */
 +	xfs_filestream_put_ag(ip->i_mount, item->ag);
  
++<<<<<<< HEAD
 +	TRACE_FREE(ip->i_mount, ip, item->pip, item->ag,
 +		xfs_filestream_peek_ag(ip->i_mount, item->ag));
++=======
+ out_dput:
+ 	dput(dentry);
+ out:
+ 	return dir ? XFS_I(dir) : NULL;
+ }
+ 
+ /*
+  * Find the right allocation group for a file, either by finding an
+  * existing file stream or creating a new one.
+  *
+  * Returns NULLAGNUMBER in case of an error.
+  */
+ xfs_agnumber_t
+ xfs_filestream_lookup_ag(
+ 	struct xfs_inode	*ip)
+ {
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct xfs_inode	*pip = NULL;
+ 	xfs_agnumber_t		startag, ag = NULLAGNUMBER;
+ 	struct xfs_mru_cache_elem *mru;
+ 
+ 	ASSERT(S_ISREG(ip->i_d.di_mode));
+ 
+ 	pip = xfs_filestream_get_parent(ip);
+ 	if (!pip)
+ 		goto out;
+ 
+ 	mru = xfs_mru_cache_lookup(mp->m_filestream, pip->i_ino);
+ 	if (mru) {
+ 		ag = container_of(mru, struct xfs_fstrm_item, mru)->ag;
+ 		xfs_mru_cache_done(mp->m_filestream);
+ 
+ 		trace_xfs_filestream_lookup(ip, ag);
+ 		goto out;
+ 	}
++>>>>>>> b94acd4786dc (xfs: add filestream allocator tracepoints)
 +
 +	/*
 +	 * _xfs_filestream_update_ag() always takes a reference on the inode
 +	 * itself, whether it's a file or a directory.  Release it here.
 +	 * This can result in the inode being freed and so we must
 +	 * not hold any inode locks when freeing filesstreams objects
 +	 * otherwise we can deadlock here.
 +	 */
 +	IRELE(ip);
 +
 +	/*
 +	 * In the case of a regular file, _xfs_filestream_update_ag() also
 +	 * takes a ref on the parent inode to keep it in-core.  Release that
 +	 * too.
 +	 */
 +	if (item->pip)
 +		IRELE(item->pip);
 +
 +	/* Finally, free the memory allocated for the item. */
 +	kmem_zone_free(item_zone, item);
 +}
 +
 +/*
 + * xfs_filestream_init() is called at xfs initialisation time to set up the
 + * memory zone that will be used for filestream data structure allocation.
 + */
 +int
 +xfs_filestream_init(void)
 +{
 +	item_zone = kmem_zone_init(sizeof(fstrm_item_t), "fstrm_item");
 +	if (!item_zone)
 +		return -ENOMEM;
 +
 +	return 0;
 +}
 +
 +/*
 + * xfs_filestream_uninit() is called at xfs termination time to destroy the
 + * memory zone that was used for filestream data structure allocation.
 + */
 +void
 +xfs_filestream_uninit(void)
 +{
 +	kmem_zone_destroy(item_zone);
 +}
 +
 +/*
 + * xfs_filestream_mount() is called when a file system is mounted with the
 + * filestream option.  It is responsible for allocating the data structures
 + * needed to track the new file system's file streams.
 + */
 +int
 +xfs_filestream_mount(
 +	xfs_mount_t	*mp)
 +{
 +	int		err;
 +	unsigned int	lifetime, grp_count;
 +
 +	/*
 +	 * The filestream timer tunable is currently fixed within the range of
 +	 * one second to four minutes, with five seconds being the default.  The
 +	 * group count is somewhat arbitrary, but it'd be nice to adhere to the
 +	 * timer tunable to within about 10 percent.  This requires at least 10
 +	 * groups.
 +	 */
 +	lifetime  = xfs_fstrm_centisecs * 10;
 +	grp_count = 10;
 +
 +	err = xfs_mru_cache_create(&mp->m_filestream, lifetime, grp_count,
 +	                     xfs_fstrm_free_func);
 +
 +	return err;
 +}
 +
 +/*
 + * xfs_filestream_unmount() is called when a file system that was mounted with
 + * the filestream option is unmounted.  It drains the data structures created
 + * to track the file system's file streams and frees all the memory that was
 + * allocated.
 + */
 +void
 +xfs_filestream_unmount(
 +	xfs_mount_t	*mp)
 +{
 +	xfs_mru_cache_destroy(mp->m_filestream);
 +}
 +
 +/*
 + * Return the AG of the filestream the file or directory belongs to, or
 + * NULLAGNUMBER otherwise.
 + */
 +xfs_agnumber_t
 +xfs_filestream_lookup_ag(
 +	xfs_inode_t	*ip)
 +{
 +	xfs_mru_cache_t	*cache;
 +	fstrm_item_t	*item;
 +	xfs_agnumber_t	ag;
 +	int		ref;
 +
 +	if (!S_ISREG(ip->i_d.di_mode) && !S_ISDIR(ip->i_d.di_mode)) {
 +		ASSERT(0);
 +		return NULLAGNUMBER;
 +	}
 +
 +	cache = ip->i_mount->m_filestream;
 +	item = xfs_mru_cache_lookup(cache, ip->i_ino);
 +	if (!item) {
 +		TRACE_LOOKUP(ip->i_mount, ip, NULL, NULLAGNUMBER, 0);
 +		return NULLAGNUMBER;
 +	}
 +
 +	ASSERT(ip == item->ip);
 +	ag = item->ag;
 +	ref = xfs_filestream_peek_ag(ip->i_mount, ag);
 +	xfs_mru_cache_done(cache);
 +
 +	TRACE_LOOKUP(ip->i_mount, ip, item->pip, ag, ref);
 +	return ag;
 +}
 +
 +/*
 + * xfs_filestream_associate() should only be called to associate a regular file
 + * with its parent directory.  Calling it with a child directory isn't
 + * appropriate because filestreams don't apply to entire directory hierarchies.
 + * Creating a file in a child directory of an existing filestream directory
 + * starts a new filestream with its own allocation group association.
 + *
 + * Returns < 0 on error, 0 if successful association occurred, > 0 if
 + * we failed to get an association because of locking issues.
 + */
 +int
 +xfs_filestream_associate(
 +	xfs_inode_t	*pip,
 +	xfs_inode_t	*ip)
 +{
 +	xfs_mount_t	*mp;
 +	xfs_mru_cache_t	*cache;
 +	fstrm_item_t	*item;
 +	xfs_agnumber_t	ag, rotorstep, startag;
 +	int		err = 0;
 +
 +	ASSERT(S_ISDIR(pip->i_d.di_mode));
 +	ASSERT(S_ISREG(ip->i_d.di_mode));
 +	if (!S_ISDIR(pip->i_d.di_mode) || !S_ISREG(ip->i_d.di_mode))
 +		return -EINVAL;
 +
 +	mp = pip->i_mount;
 +	cache = mp->m_filestream;
 +
 +	/*
 +	 * We have a problem, Houston.
 +	 *
 +	 * Taking the iolock here violates inode locking order - we already
 +	 * hold the ilock. Hence if we block getting this lock we may never
 +	 * wake. Unfortunately, that means if we can't get the lock, we're
 +	 * screwed in terms of getting a stream association - we can't spin
 +	 * waiting for the lock because someone else is waiting on the lock we
 +	 * hold and we cannot drop that as we are in a transaction here.
 +	 *
 +	 * Lucky for us, this inversion is not a problem because it's a
 +	 * directory inode that we are trying to lock here.
 +	 *
 +	 * So, if we can't get the iolock without sleeping then just give up
 +	 */
 +	if (!xfs_ilock_nowait(pip, XFS_IOLOCK_EXCL))
 +		return 1;
 +
 +	/* If the parent directory is already in the cache, use its AG. */
 +	item = xfs_mru_cache_lookup(cache, pip->i_ino);
 +	if (item) {
 +		ASSERT(item->ip == pip);
 +		ag = item->ag;
 +		xfs_mru_cache_done(cache);
 +
 +		TRACE_LOOKUP(mp, pip, pip, ag, xfs_filestream_peek_ag(mp, ag));
 +		err = _xfs_filestream_update_ag(ip, pip, ag);
 +
 +		goto exit;
 +	}
  
  	/*
  	 * Set the starting AG using the rotor for inode32, otherwise
* Unmerged path fs/xfs/xfs_filestream.c
diff --git a/fs/xfs/xfs_filestream.h b/fs/xfs/xfs_filestream.h
index 6d61dbee8564..9c2a0738ab42 100644
--- a/fs/xfs/xfs_filestream.h
+++ b/fs/xfs/xfs_filestream.h
@@ -55,6 +55,7 @@ xfs_agnumber_t xfs_filestream_lookup_ag(struct xfs_inode *ip);
 int xfs_filestream_associate(struct xfs_inode *dip, struct xfs_inode *ip);
 void xfs_filestream_deassociate(struct xfs_inode *ip);
 int xfs_filestream_new_ag(struct xfs_bmalloca *ap, xfs_agnumber_t *agp);
+int xfs_filestream_peek_ag(struct xfs_mount *mp, xfs_agnumber_t agno);
 
 
 /* filestreams for the inode? */
diff --git a/fs/xfs/xfs_trace.c b/fs/xfs/xfs_trace.c
index dee3279c095e..1e85bcd0e418 100644
--- a/fs/xfs/xfs_trace.c
+++ b/fs/xfs/xfs_trace.c
@@ -46,6 +46,7 @@
 #include "xfs_log_recover.h"
 #include "xfs_inode_item.h"
 #include "xfs_bmap_btree.h"
+#include "xfs_filestream.h"
 
 /*
  * We include this last to have the helpers above available for the trace
diff --git a/fs/xfs/xfs_trace.h b/fs/xfs/xfs_trace.h
index 27fdd8bb499c..b1e8480467f1 100644
--- a/fs/xfs/xfs_trace.h
+++ b/fs/xfs/xfs_trace.h
@@ -538,6 +538,64 @@ DEFINE_BUF_ITEM_EVENT(xfs_trans_bhold_release);
 DEFINE_BUF_ITEM_EVENT(xfs_trans_binval);
 DEFINE_BUF_ITEM_EVENT(xfs_trans_buf_ordered);
 
+DECLARE_EVENT_CLASS(xfs_filestream_class,
+	TP_PROTO(struct xfs_inode *ip, xfs_agnumber_t agno),
+	TP_ARGS(ip, agno),
+	TP_STRUCT__entry(
+		__field(dev_t, dev)
+		__field(xfs_ino_t, ino)
+		__field(xfs_agnumber_t, agno)
+		__field(int, streams)
+	),
+	TP_fast_assign(
+		__entry->dev = VFS_I(ip)->i_sb->s_dev;
+		__entry->ino = ip->i_ino;
+		__entry->agno = agno;
+		__entry->streams = xfs_filestream_peek_ag(ip->i_mount, agno);
+	),
+	TP_printk("dev %d:%d ino 0x%llx agno %u streams %d",
+		  MAJOR(__entry->dev), MINOR(__entry->dev),
+		  __entry->ino,
+		  __entry->agno,
+		  __entry->streams)
+)
+#define DEFINE_FILESTREAM_EVENT(name) \
+DEFINE_EVENT(xfs_filestream_class, name, \
+	TP_PROTO(struct xfs_inode *ip, xfs_agnumber_t agno), \
+	TP_ARGS(ip, agno))
+DEFINE_FILESTREAM_EVENT(xfs_filestream_free);
+DEFINE_FILESTREAM_EVENT(xfs_filestream_lookup);
+DEFINE_FILESTREAM_EVENT(xfs_filestream_scan);
+
+TRACE_EVENT(xfs_filestream_pick,
+	TP_PROTO(struct xfs_inode *ip, xfs_agnumber_t agno,
+		 xfs_extlen_t free, int nscan),
+	TP_ARGS(ip, agno, free, nscan),
+	TP_STRUCT__entry(
+		__field(dev_t, dev)
+		__field(xfs_ino_t, ino)
+		__field(xfs_agnumber_t, agno)
+		__field(int, streams)
+		__field(xfs_extlen_t, free)
+		__field(int, nscan)
+	),
+	TP_fast_assign(
+		__entry->dev = VFS_I(ip)->i_sb->s_dev;
+		__entry->ino = ip->i_ino;
+		__entry->agno = agno;
+		__entry->streams = xfs_filestream_peek_ag(ip->i_mount, agno);
+		__entry->free = free;
+		__entry->nscan = nscan;
+	),
+	TP_printk("dev %d:%d ino 0x%llx agno %u streams %d free %d nscan %d",
+		  MAJOR(__entry->dev), MINOR(__entry->dev),
+		  __entry->ino,
+		  __entry->agno,
+		  __entry->streams,
+		  __entry->free,
+		  __entry->nscan)
+);
+
 DECLARE_EVENT_CLASS(xfs_lock_class,
 	TP_PROTO(struct xfs_inode *ip, unsigned lock_flags,
 		 unsigned long caller_ip),
