perf tools: Allow out of order messages in forced flush

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [tools] perf: Allow out of order messages in forced flush (Jiri Olsa) [1169436]
Rebuild_FUZZ: 94.23%
commit-author Jiri Olsa <jolsa@kernel.org>
commit b0a45203a75a800015828ac89f2945981019b65b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/b0a45203.failed

In forced flush (OE_FLUSH__HALF) we break the rules of the flush
timestamp via PERF_RECORD_FINISHED_ROUND event, so we could get out of
order event.

Do not force error in this case plus changing the output warning to use
WARN_ONCE.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Acked-by: David Ahern <dsahern@gmail.com>
	Cc: Corey Ashford <cjashfor@linux.vnet.ibm.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: Jean Pihet <jean.pihet@linaro.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lkml.kernel.org/n/tip-8q8794a8nlmpd1u8xrqmcyd2@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit b0a45203a75a800015828ac89f2945981019b65b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/ordered-events.c
#	tools/perf/util/ordered-events.h
#	tools/perf/util/session.c
diff --cc tools/perf/util/session.c
index 8f2eedc2c5c3,7e27f1eb260c..000000000000
--- a/tools/perf/util/session.c
+++ b/tools/perf/util/session.c
@@@ -659,33 -500,29 +660,46 @@@ int perf_session_queue_event(struct per
  	if (!timestamp || timestamp == ~0ULL)
  		return -ETIME;
  
++<<<<<<< HEAD
 +	if (timestamp < s->ordered_events.last_flush) {
 +		printf("Warning: Timestamp below last timeslice flush\n");
 +		return -EINVAL;
++=======
+ 	if (timestamp < oe->last_flush) {
+ 		WARN_ONCE(1, "Timestamp below last timeslice flush\n");
+ 
+ 		pr_oe_time(timestamp,      "out of order event");
+ 		pr_oe_time(oe->last_flush, "last flush, last_flush_type %d\n",
+ 			   oe->last_flush_type);
+ 
+ 		/* We could get out of order messages after forced flush. */
+ 		if (oe->last_flush_type != OE_FLUSH__HALF)
+ 			return -EINVAL;
++>>>>>>> b0a45203a75a (perf tools: Allow out of order messages in forced flush)
  	}
  
 -	new = ordered_events__new(oe, timestamp);
 -	if (!new) {
 -		ordered_events__flush(s, tool, OE_FLUSH__HALF);
 -		new = ordered_events__new(oe, timestamp);
 +	if (!list_empty(cache)) {
 +		new = list_entry(cache->next, struct ordered_event, list);
 +		list_del(&new->list);
 +	} else if (oe->buffer) {
 +		new = oe->buffer + oe->buffer_idx;
 +		if (++oe->buffer_idx == MAX_SAMPLE_BUFFER)
 +			oe->buffer = NULL;
 +	} else {
 +		oe->buffer = malloc(MAX_SAMPLE_BUFFER * sizeof(*new));
 +		if (!oe->buffer)
 +			return -ENOMEM;
 +		list_add(&oe->buffer->list, &oe->to_free);
 +		oe->buffer_idx = 2;
 +		new = oe->buffer + 1;
  	}
  
 -	if (!new)
 -		return -ENOMEM;
 -
 +	new->timestamp = timestamp;
  	new->file_offset = file_offset;
  	new->event = event;
 +
 +	__queue_event(new, s);
 +
  	return 0;
  }
  
* Unmerged path tools/perf/util/ordered-events.c
* Unmerged path tools/perf/util/ordered-events.h
* Unmerged path tools/perf/util/ordered-events.c
* Unmerged path tools/perf/util/ordered-events.h
* Unmerged path tools/perf/util/session.c
