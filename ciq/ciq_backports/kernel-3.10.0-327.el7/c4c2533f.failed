ALSA: hda - Fix possible runtime PM refcount unbalance

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [alsa] hda - Fix possible runtime PM refcount unbalance (Jaroslav Kysela) [1197064]
Rebuild_FUZZ: 94.12%
commit-author Takashi Iwai <tiwai@suse.de>
commit c4c2533f802d6877803c4d778def43d8a122f27b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/c4c2533f.failed

When the driver is unloaded before the codec is bound, it still keeps
the runtime PM refcount up, and results in the unbalance.  This patch
covers these cases by introducing a flag indicating the runtime PM
initialization and handling the codec registration procedure more
properly.  It also fixes the missing input beep device as a gratis,
too.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit c4c2533f802d6877803c4d778def43d8a122f27b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/hda/hdac_device.c
#	sound/pci/hda/hda_codec.c
diff --cc sound/pci/hda/hda_codec.c
index 05cb5f57659a,145cae7903b6..000000000000
--- a/sound/pci/hda/hda_codec.c
+++ b/sound/pci/hda/hda_codec.c
@@@ -1233,15 -950,23 +1240,33 @@@ static bool snd_hda_codec_get_supported
  static unsigned int hda_set_power_state(struct hda_codec *codec,
  				unsigned int power_state);
  
+ /* also called from hda_bind.c */
+ void snd_hda_codec_register(struct hda_codec *codec)
+ {
+ 	if (codec->registered)
+ 		return;
+ 	if (device_is_registered(hda_codec_dev(codec))) {
+ 		snd_hda_register_beep_device(codec);
+ 		pm_runtime_enable(hda_codec_dev(codec));
+ 		/* it was powered up in snd_hda_codec_new(), now all done */
+ 		snd_hda_power_down(codec);
+ 		codec->registered = 1;
+ 	}
+ }
+ 
  static int snd_hda_codec_dev_register(struct snd_device *device)
  {
++<<<<<<< HEAD
 +	struct hda_codec *codec = device->device_data;
 +
 +	snd_hda_register_beep_device(codec);
 +	if (device_is_registered(hda_codec_dev(codec))) {
 +		snd_hda_power_sync(codec);
 +		pm_runtime_enable(hda_codec_dev(codec));
 +	}
++=======
+ 	snd_hda_codec_register(device->device_data);
++>>>>>>> c4c2533f802d (ALSA: hda - Fix possible runtime PM refcount unbalance)
  	return 0;
  }
  
@@@ -1428,7 -1109,7 +1453,11 @@@ int snd_hda_codec_new(struct hda_bus *b
  	return 0;
  
   error:
++<<<<<<< HEAD
 +	snd_hda_codec_free(codec);
++=======
+ 	put_device(hda_codec_dev(codec));
++>>>>>>> c4c2533f802d (ALSA: hda - Fix possible runtime PM refcount unbalance)
  	return err;
  }
  EXPORT_SYMBOL_GPL(snd_hda_codec_new);
* Unmerged path sound/hda/hdac_device.c
* Unmerged path sound/hda/hdac_device.c
diff --git a/sound/pci/hda/hda_bind.c b/sound/pci/hda/hda_bind.c
index a49bc45c2ea5..a8a81747512d 100644
--- a/sound/pci/hda/hda_bind.c
+++ b/sound/pci/hda/hda_bind.c
@@ -119,6 +119,7 @@ static int hda_codec_driver_probe(struct device *dev)
 		err = snd_card_register(codec->card);
 		if (err < 0)
 			goto error_module;
+		snd_hda_codec_register(codec);
 	}
 
 	return 0;
* Unmerged path sound/pci/hda/hda_codec.c
diff --git a/sound/pci/hda/hda_codec.h b/sound/pci/hda/hda_codec.h
index 4f8090e5338d..535810cae8ec 100644
--- a/sound/pci/hda/hda_codec.h
+++ b/sound/pci/hda/hda_codec.h
@@ -355,6 +355,7 @@ struct hda_codec {
 
 	/* misc flags */
 	unsigned int in_freeing:1; /* being released */
+	unsigned int registered:1; /* codec was registered */
 	unsigned int spdif_status_reset :1; /* needs to toggle SPDIF for each
 					     * status change
 					     * (e.g. Realtek codecs)
diff --git a/sound/pci/hda/hda_local.h b/sound/pci/hda/hda_local.h
index 1d001647fc47..65ae729400ab 100644
--- a/sound/pci/hda/hda_local.h
+++ b/sound/pci/hda/hda_local.h
@@ -150,6 +150,7 @@ int __snd_hda_add_vmaster(struct hda_codec *codec, char *name,
 #define snd_hda_add_vmaster(codec, name, tlv, slaves, suffix) \
 	__snd_hda_add_vmaster(codec, name, tlv, slaves, suffix, true, NULL)
 int snd_hda_codec_reset(struct hda_codec *codec);
+void snd_hda_codec_register(struct hda_codec *codec);
 void snd_hda_codec_cleanup_for_unbind(struct hda_codec *codec);
 
 enum {
