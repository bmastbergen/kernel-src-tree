xfs: kill xfs_ioctl_setattr behaviour mask

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit fd179b9c3bdab682ae5bb3e10380a31853be179a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/fd179b9c.failed

Now there is only one caller to xfs_ioctl_setattr that uses all the
functionality of the function we can kill the behviour mask and
start cleaning up the code.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit fd179b9c3bdab682ae5bb3e10380a31853be179a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_ioctl.c
diff --cc fs/xfs/xfs_ioctl.c
index c6e180d60c21,a1f285411b74..000000000000
--- a/fs/xfs/xfs_ioctl.c
+++ b/fs/xfs/xfs_ioctl.c
@@@ -1045,9 -1013,90 +1045,96 @@@ xfs_diflags_to_linux
  		inode->i_flags &= ~S_NOATIME;
  }
  
++<<<<<<< HEAD
 +#define FSX_PROJID	1
 +#define FSX_EXTSIZE	2
 +#define FSX_XFLAGS	4
++=======
+ static int
+ xfs_ioctl_setattr_xflags(
+ 	struct xfs_trans	*tp,
+ 	struct xfs_inode	*ip,
+ 	struct fsxattr		*fa)
+ {
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 
+ 	/* Can't change realtime flag if any extents are allocated. */
+ 	if ((ip->i_d.di_nextents || ip->i_delayed_blks) &&
+ 	    XFS_IS_REALTIME_INODE(ip) != (fa->fsx_xflags & XFS_XFLAG_REALTIME))
+ 		return -EINVAL;
+ 
+ 	/* If realtime flag is set then must have realtime device */
+ 	if (fa->fsx_xflags & XFS_XFLAG_REALTIME) {
+ 		if (mp->m_sb.sb_rblocks == 0 || mp->m_sb.sb_rextsize == 0 ||
+ 		    (ip->i_d.di_extsize % mp->m_sb.sb_rextsize))
+ 			return -EINVAL;
+ 	}
+ 
+ 	/*
+ 	 * Can't modify an immutable/append-only file unless
+ 	 * we have appropriate permission.
+ 	 */
+ 	if (((ip->i_d.di_flags & (XFS_DIFLAG_IMMUTABLE | XFS_DIFLAG_APPEND)) ||
+ 	     (fa->fsx_xflags & (XFS_XFLAG_IMMUTABLE | XFS_XFLAG_APPEND))) &&
+ 	    !capable(CAP_LINUX_IMMUTABLE))
+ 		return -EPERM;
+ 
+ 	xfs_set_diflags(ip, fa->fsx_xflags);
+ 	xfs_diflags_to_linux(ip);
+ 	xfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);
+ 	xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
+ 	XFS_STATS_INC(xs_ig_attrchg);
+ 	return 0;
+ }
+ 
+ /*
+  * Set up the transaction structure for the setattr operation, checking that we
+  * have permission to do so. On success, return a clean transaction and the
+  * inode locked exclusively ready for further operation specific checks. On
+  * failure, return an error without modifying or locking the inode.
+  */
+ static struct xfs_trans *
+ xfs_ioctl_setattr_get_trans(
+ 	struct xfs_inode	*ip)
+ {
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct xfs_trans	*tp;
+ 	int			error;
+ 
+ 	if (mp->m_flags & XFS_MOUNT_RDONLY)
+ 		return ERR_PTR(-EROFS);
+ 	if (XFS_FORCED_SHUTDOWN(mp))
+ 		return ERR_PTR(-EIO);
+ 
+ 	tp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_NOT_SIZE);
+ 	error = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);
+ 	if (error)
+ 		goto out_cancel;
+ 
+ 	xfs_ilock(ip, XFS_ILOCK_EXCL);
+ 	xfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);
+ 
+ 	/*
+ 	 * CAP_FOWNER overrides the following restrictions:
+ 	 *
+ 	 * The user ID of the calling process must be equal to the file owner
+ 	 * ID, except in cases where the CAP_FSETID capability is applicable.
+ 	 */
+ 	if (!inode_owner_or_capable(VFS_I(ip))) {
+ 		error = -EPERM;
+ 		goto out_cancel;
+ 	}
+ 
+ 	if (mp->m_flags & XFS_MOUNT_WSYNC)
+ 		xfs_trans_set_sync(tp);
+ 
+ 	return tp;
+ 
+ out_cancel:
+ 	xfs_trans_cancel(tp, 0);
+ 	return ERR_PTR(error);
+ }
++>>>>>>> fd179b9c3bda (xfs: kill xfs_ioctl_setattr behaviour mask)
  
  STATIC int
  xfs_ioctl_setattr(
@@@ -1073,9 -1115,9 +1159,15 @@@
  	/*
  	 * Disallow 32bit project ids when projid32bit feature is not enabled.
  	 */
++<<<<<<< HEAD
 +	if ((mask & FSX_PROJID) && (fa->fsx_projid > (__uint16_t)-1) &&
 +			!xfs_sb_version_hasprojid32bit(&ip->i_mount->m_sb))
 +		return XFS_ERROR(EINVAL);
++=======
+ 	if (fa->fsx_projid > (__uint16_t)-1 &&
+ 	    !xfs_sb_version_hasprojid32bit(&ip->i_mount->m_sb))
+ 		return -EINVAL;
++>>>>>>> fd179b9c3bda (xfs: kill xfs_ioctl_setattr behaviour mask)
  
  	/*
  	 * If disk quotas is on, we make sure that the dquots do exist on disk,
@@@ -1122,188 -1146,93 +1214,252 @@@
  	 * Only allow changing of projid from init_user_ns since it is a
  	 * non user namespace aware identifier.
  	 */
++<<<<<<< HEAD
 +	if (mask & FSX_PROJID) {
 +		if (current_user_ns() != &init_user_ns) {
 +			code = XFS_ERROR(EINVAL);
 +			goto error_return;
 +		}
 +
 +		if (XFS_IS_QUOTA_RUNNING(mp) &&
 +		    XFS_IS_PQUOTA_ON(mp) &&
 +		    xfs_get_projid(ip) != fa->fsx_projid) {
 +			ASSERT(tp);
 +			code = xfs_qm_vop_chown_reserve(tp, ip, udqp, NULL,
 +						pdqp, capable(CAP_FOWNER) ?
 +						XFS_QMOPT_FORCE_RES : 0);
 +			if (code)	/* out of quota */
 +				goto error_return;
 +		}
 +	}
 +
 +	if (mask & FSX_EXTSIZE) {
 +		/*
 +		 * Can't change extent size if any extents are allocated.
 +		 */
 +		if (ip->i_d.di_nextents &&
 +		    ((ip->i_d.di_extsize << mp->m_sb.sb_blocklog) !=
 +		     fa->fsx_extsize)) {
 +			code = XFS_ERROR(EINVAL);	/* EFBIG? */
++=======
+ 	if (current_user_ns() != &init_user_ns) {
+ 		code = -EINVAL;
+ 		goto error_return;
+ 	}
+ 
+ 	if (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_PQUOTA_ON(mp) &&
+ 	    xfs_get_projid(ip) != fa->fsx_projid) {
+ 		code = xfs_qm_vop_chown_reserve(tp, ip, udqp, NULL, pdqp,
+ 				capable(CAP_FOWNER) ?  XFS_QMOPT_FORCE_RES : 0);
+ 		if (code)	/* out of quota */
++>>>>>>> fd179b9c3bda (xfs: kill xfs_ioctl_setattr behaviour mask)
  			goto error_return;
+ 	}
+ 
+ 	/* Can't change extent size if any extents are allocated. */
+ 	code = -EINVAL;
+ 	if (ip->i_d.di_nextents &&
+ 	    ((ip->i_d.di_extsize << mp->m_sb.sb_blocklog) != fa->fsx_extsize))
+ 		goto error_return;
+ 
+ 	/*
+ 	 * Extent size must be a multiple of the appropriate block size, if set
+ 	 * at all. It must also be smaller than the maximum extent size
+ 	 * supported by the filesystem.
+ 	 *
+ 	 * Also, for non-realtime files, limit the extent size hint to half the
+ 	 * size of the AGs in the filesystem so alignment doesn't result in
+ 	 * extents larger than an AG.
+ 	 */
+ 	if (fa->fsx_extsize != 0) {
+ 		xfs_extlen_t    size;
+ 		xfs_fsblock_t   extsize_fsb;
+ 
+ 		extsize_fsb = XFS_B_TO_FSB(mp, fa->fsx_extsize);
+ 		if (extsize_fsb > MAXEXTLEN)
+ 			goto error_return;
+ 
+ 		if (XFS_IS_REALTIME_INODE(ip) ||
+ 		    (fa->fsx_xflags & XFS_XFLAG_REALTIME)) {
+ 			size = mp->m_sb.sb_rextsize << mp->m_sb.sb_blocklog;
+ 		} else {
+ 			size = mp->m_sb.sb_blocksize;
+ 			if (extsize_fsb > mp->m_sb.sb_agblocks / 2)
+ 				goto error_return;
  		}
  
++<<<<<<< HEAD
 +		/*
 +		 * Extent size must be a multiple of the appropriate block
 +		 * size, if set at all. It must also be smaller than the
 +		 * maximum extent size supported by the filesystem.
 +		 *
 +		 * Also, for non-realtime files, limit the extent size hint to
 +		 * half the size of the AGs in the filesystem so alignment
 +		 * doesn't result in extents larger than an AG.
 +		 */
 +		if (fa->fsx_extsize != 0) {
 +			xfs_extlen_t    size;
 +			xfs_fsblock_t   extsize_fsb;
 +
 +			extsize_fsb = XFS_B_TO_FSB(mp, fa->fsx_extsize);
 +			if (extsize_fsb > MAXEXTLEN) {
 +				code = XFS_ERROR(EINVAL);
 +				goto error_return;
 +			}
 +
 +			if (XFS_IS_REALTIME_INODE(ip) ||
 +			    ((mask & FSX_XFLAGS) &&
 +			    (fa->fsx_xflags & XFS_XFLAG_REALTIME))) {
 +				size = mp->m_sb.sb_rextsize <<
 +				       mp->m_sb.sb_blocklog;
 +			} else {
 +				size = mp->m_sb.sb_blocksize;
 +				if (extsize_fsb > mp->m_sb.sb_agblocks / 2) {
 +					code = XFS_ERROR(EINVAL);
 +					goto error_return;
 +				}
 +			}
 +
 +			if (fa->fsx_extsize % size) {
 +				code = XFS_ERROR(EINVAL);
 +				goto error_return;
 +			}
 +		}
++=======
+ 		if (fa->fsx_extsize % size)
+ 			goto error_return;
++>>>>>>> fd179b9c3bda (xfs: kill xfs_ioctl_setattr behaviour mask)
  	}
  
  
 -	code = xfs_ioctl_setattr_xflags(tp, ip, fa);
 -	if (code)
 -		goto error_return;
 +	if (mask & FSX_XFLAGS) {
 +		/*
 +		 * Can't change realtime flag if any extents are allocated.
 +		 */
 +		if ((ip->i_d.di_nextents || ip->i_delayed_blks) &&
 +		    (XFS_IS_REALTIME_INODE(ip)) !=
 +		    (fa->fsx_xflags & XFS_XFLAG_REALTIME)) {
 +			code = XFS_ERROR(EINVAL);	/* EFBIG? */
 +			goto error_return;
 +		}
 +
 +		/*
 +		 * If realtime flag is set then must have realtime data.
 +		 */
 +		if ((fa->fsx_xflags & XFS_XFLAG_REALTIME)) {
 +			if ((mp->m_sb.sb_rblocks == 0) ||
 +			    (mp->m_sb.sb_rextsize == 0) ||
 +			    (ip->i_d.di_extsize % mp->m_sb.sb_rextsize)) {
 +				code = XFS_ERROR(EINVAL);
 +				goto error_return;
 +			}
 +		}
 +
 +		/*
 +		 * Can't modify an immutable/append-only file unless
 +		 * we have appropriate permission.
 +		 */
 +		if ((ip->i_d.di_flags &
 +				(XFS_DIFLAG_IMMUTABLE|XFS_DIFLAG_APPEND) ||
 +		     (fa->fsx_xflags &
 +				(XFS_XFLAG_IMMUTABLE | XFS_XFLAG_APPEND))) &&
 +		    !capable(CAP_LINUX_IMMUTABLE)) {
 +			code = XFS_ERROR(EPERM);
 +			goto error_return;
 +		}
 +	}
 +
 +	xfs_trans_ijoin(tp, ip, 0);
  
  	/*
- 	 * Change file ownership.  Must be the owner or privileged.
+ 	 * Change file ownership.  Must be the owner or privileged.  CAP_FSETID
+ 	 * overrides the following restrictions:
+ 	 *
+ 	 * The set-user-ID and set-group-ID bits of a file will be cleared upon
+ 	 * successful return from chown()
  	 */
++<<<<<<< HEAD
 +	if (mask & FSX_PROJID) {
 +		/*
 +		 * CAP_FSETID overrides the following restrictions:
 +		 *
 +		 * The set-user-ID and set-group-ID bits of a file will be
 +		 * cleared upon successful return from chown()
 +		 */
 +		if ((ip->i_d.di_mode & (S_ISUID|S_ISGID)) &&
 +		    !inode_capable(VFS_I(ip), CAP_FSETID))
 +			ip->i_d.di_mode &= ~(S_ISUID|S_ISGID);
 +
 +		/*
 +		 * Change the ownerships and register quota modifications
 +		 * in the transaction.
 +		 */
 +		if (xfs_get_projid(ip) != fa->fsx_projid) {
 +			if (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_PQUOTA_ON(mp)) {
 +				olddquot = xfs_qm_vop_chown(tp, ip,
 +							&ip->i_pdquot, pdqp);
 +			}
 +			xfs_set_projid(ip, fa->fsx_projid);
 +
 +			/*
 +			 * We may have to rev the inode as well as
 +			 * the superblock version number since projids didn't
 +			 * exist before DINODE_VERSION_2 and SB_VERSION_NLINK.
 +			 */
 +			if (ip->i_d.di_version == 1)
 +				xfs_bump_ino_vers2(tp, ip);
++=======
+ 
+ 	if ((ip->i_d.di_mode & (S_ISUID|S_ISGID)) &&
+ 	    !capable_wrt_inode_uidgid(VFS_I(ip), CAP_FSETID))
+ 		ip->i_d.di_mode &= ~(S_ISUID|S_ISGID);
+ 
+ 	/* Change the ownerships and register project quota modifications */
+ 	if (xfs_get_projid(ip) != fa->fsx_projid) {
+ 		if (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_PQUOTA_ON(mp)) {
+ 			olddquot = xfs_qm_vop_chown(tp, ip,
+ 						&ip->i_pdquot, pdqp);
++>>>>>>> fd179b9c3bda (xfs: kill xfs_ioctl_setattr behaviour mask)
  		}
- 
+ 		ASSERT(ip->i_d.di_version > 1);
+ 		xfs_set_projid(ip, fa->fsx_projid);
  	}
  
 +	if (mask & FSX_XFLAGS) {
 +		xfs_set_diflags(ip, fa->fsx_xflags);
 +		xfs_diflags_to_linux(ip);
 +	}
 +
  	/*
  	 * Only set the extent size hint if we've already determined that the
  	 * extent size hint should be set on the inode. If no extent size flags
  	 * are set on the inode then unconditionally clear the extent size hint.
  	 */
- 	if (mask & FSX_EXTSIZE) {
- 		int	extsize = 0;
- 
- 		if (ip->i_d.di_flags &
- 				(XFS_DIFLAG_EXTSIZE | XFS_DIFLAG_EXTSZINHERIT))
- 			extsize = fa->fsx_extsize >> mp->m_sb.sb_blocklog;
- 		ip->i_d.di_extsize = extsize;
- 	}
+ 	if (ip->i_d.di_flags & (XFS_DIFLAG_EXTSIZE | XFS_DIFLAG_EXTSZINHERIT))
+ 		ip->i_d.di_extsize = fa->fsx_extsize >> mp->m_sb.sb_blocklog;
+ 	else
+ 		ip->i_d.di_extsize = 0;
  
 +	xfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);
 +	xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
 +
 +	XFS_STATS_INC(xs_ig_attrchg);
 +
 +	/*
 +	 * If this is a synchronous mount, make sure that the
 +	 * transaction goes to disk before returning to the user.
 +	 * This is slightly sub-optimal in that truncates require
 +	 * two sync transactions instead of one for wsync filesystems.
 +	 * One for the truncate and one for the timestamps since we
 +	 * don't want to change the timestamps unless we're sure the
 +	 * truncate worked.  Truncates are less than 1% of the laddis
 +	 * mix so this probably isn't worth the trouble to optimize.
 +	 */
 +	if (mp->m_flags & XFS_MOUNT_WSYNC)
 +		xfs_trans_set_sync(tp);
  	code = xfs_trans_commit(tp, 0);
 +	xfs_iunlock(ip, lock_flags);
  
  	/*
  	 * Release any dquot(s) the inode had kept before chown.
@@@ -1339,11 -1266,9 +1494,9 @@@ xfs_ioc_fssetxattr
  	error = mnt_want_write_file(filp);
  	if (error)
  		return error;
- 	error = xfs_ioctl_setattr(ip, &fa, mask);
+ 	error = xfs_ioctl_setattr(ip, &fa);
  	mnt_drop_write_file(filp);
 -	return error;
 +	return -error;
  }
  
  STATIC int
* Unmerged path fs/xfs/xfs_ioctl.c
