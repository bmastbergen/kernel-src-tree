bonding: convert bond_3ad.c to use netdev_printk instead of pr_

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Veaceslav Falico <vfalico@gmail.com>
commit d4471f5e23a75c9a94d339b5a83f89b21e7c852a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/d4471f5e.failed

Several functions left out cause we might not have at that time a valid
bond/slave/port.

Also, converted severa pr_ratelimited into net_ratelimited.

CC: Jay Vosburgh <j.vosburgh@gmail.com>
CC: Andy Gospodarek <andy@greyhouse.net>
	Signed-off-by: Veaceslav Falico <vfalico@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d4471f5e23a75c9a94d339b5a83f89b21e7c852a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_3ad.c
diff --cc drivers/net/bonding/bond_3ad.c
index dc508c87249d,159c451324ce..000000000000
--- a/drivers/net/bonding/bond_3ad.c
+++ b/drivers/net/bonding/bond_3ad.c
@@@ -1127,10 -1077,11 +1127,18 @@@ static void ad_rx_machine(struct lacpd
  			break;
  		case AD_RX_CURRENT:
  			/* detect loopback situation */
++<<<<<<< HEAD
 +			if (MAC_ADDRESS_EQUAL(&(lacpdu->actor_system), &(port->actor_system))) {
 +				pr_err("%s: An illegal loopback occurred on adapter (%s).\n"
 +				       "Check the configuration to verify that all adapters are connected to 802.3ad compliant switch ports\n",
 +				       port->slave->bond->dev->name, port->slave->dev->name);
++=======
+ 			if (MAC_ADDRESS_EQUAL(&(lacpdu->actor_system),
+ 					      &(port->actor_system))) {
+ 				netdev_err(port->slave->bond->dev, "An illegal loopback occurred on adapter (%s)\n"
+ 				       "Check the configuration to verify that all adapters are connected to 802.3ad compliant switch ports\n",
+ 				       port->slave->dev->name);
++>>>>>>> d4471f5e23a7 (bonding: convert bond_3ad.c to use netdev_printk instead of pr_)
  				return;
  			}
  			__update_selected(lacpdu, port);
@@@ -1303,28 -1268,33 +1311,49 @@@ static void ad_port_selection_logic(str
  				port->next_port_in_aggregator = NULL;
  				port->actor_port_aggregator_identifier = 0;
  
++<<<<<<< HEAD
 +				pr_debug("Port %d left LAG %d\n",
 +					 port->actor_port_number,
 +					 temp_aggregator->aggregator_identifier);
 +				// if the aggregator is empty, clear its parameters, and set it ready to be attached
++=======
+ 				netdev_dbg(bond->dev, "Port %d left LAG %d\n",
+ 					   port->actor_port_number,
+ 					   temp_aggregator->aggregator_identifier);
+ 				/* if the aggregator is empty, clear its
+ 				 * parameters, and set it ready to be attached
+ 				 */
++>>>>>>> d4471f5e23a7 (bonding: convert bond_3ad.c to use netdev_printk instead of pr_)
  				if (!temp_aggregator->lag_ports)
  					ad_clear_agg(temp_aggregator);
  				break;
  			}
  		}
++<<<<<<< HEAD
 +		if (!curr_port) { // meaning: the port was related to an aggregator but was not on the aggregator port list
 +			pr_warning("%s: Warning: Port %d (on %s) was related to aggregator %d but was not on its port list\n",
 +				   port->slave->bond->dev->name,
 +				   port->actor_port_number,
 +				   port->slave->dev->name,
 +				   port->aggregator->aggregator_identifier);
++=======
+ 		if (!curr_port) {
+ 			/* meaning: the port was related to an aggregator
+ 			 * but was not on the aggregator port list
+ 			 */
+ 			net_warn_ratelimited("%s: Warning: Port %d (on %s) was related to aggregator %d but was not on its port list\n",
+ 					     port->slave->bond->dev->name,
+ 					     port->actor_port_number,
+ 					     port->slave->dev->name,
+ 					     port->aggregator->aggregator_identifier);
++>>>>>>> d4471f5e23a7 (bonding: convert bond_3ad.c to use netdev_printk instead of pr_)
  		}
  	}
 -	/* search on all aggregators for a suitable aggregator for this port */
 +	// search on all aggregators for a suitable aggregator for this port
  	bond_for_each_slave(bond, slave, iter) {
 -		aggregator = &(SLAVE_AD_INFO(slave)->aggregator);
 +		aggregator = &(SLAVE_AD_INFO(slave).aggregator);
  
 -		/* keep a free aggregator for later use(if needed) */
 +		// keep a free aggregator for later use(if needed)
  		if (!aggregator->lag_ports) {
  			if (!free_aggregator)
  				free_aggregator = aggregator;
@@@ -1347,11 -1317,11 +1376,11 @@@
  			port->next_port_in_aggregator = aggregator->lag_ports;
  			port->aggregator->num_of_ports++;
  			aggregator->lag_ports = port;
- 			pr_debug("Port %d joined LAG %d(existing LAG)\n",
- 				 port->actor_port_number,
- 				 port->aggregator->aggregator_identifier);
+ 			netdev_dbg(bond->dev, "Port %d joined LAG %d(existing LAG)\n",
+ 				   port->actor_port_number,
+ 				   port->aggregator->aggregator_identifier);
  
 -			/* mark this port as selected */
 +			// mark this port as selected
  			port->sm_vars |= AD_PORT_SELECTED;
  			found = 1;
  			break;
@@@ -1386,15 -1359,14 +1415,14 @@@
  			port->aggregator->lag_ports = port;
  			port->aggregator->num_of_ports++;
  
 -			/* mark this port as selected */
 +			// mark this port as selected
  			port->sm_vars |= AD_PORT_SELECTED;
  
- 			pr_debug("Port %d joined LAG %d(new LAG)\n",
- 				 port->actor_port_number,
- 				 port->aggregator->aggregator_identifier);
+ 			netdev_dbg(bond->dev, "Port %d joined LAG %d(new LAG)\n",
+ 				   port->actor_port_number,
+ 				   port->aggregator->aggregator_identifier);
  		} else {
- 			pr_err("%s: Port %d (on %s) did not find a suitable aggregator\n",
- 			       port->slave->bond->dev->name,
+ 			netdev_err(bond->dev, "Port %d (on %s) did not find a suitable aggregator\n",
  			       port->actor_port_number, port->slave->dev->name);
  		}
  	}
@@@ -1470,9 -1443,9 +1498,15 @@@ static struct aggregator *ad_agg_select
  		break;
  
  	default:
++<<<<<<< HEAD
 +		pr_warning("%s: Impossible agg select mode %d\n",
 +			   curr->slave->bond->dev->name,
 +			   __get_agg_selection_mode(curr->lag_ports));
++=======
+ 		net_warn_ratelimited("%s: Impossible agg select mode %d\n",
+ 				     curr->slave->bond->dev->name,
+ 				     __get_agg_selection_mode(curr->lag_ports));
++>>>>>>> d4471f5e23a7 (bonding: convert bond_3ad.c to use netdev_printk instead of pr_)
  		break;
  	}
  
@@@ -1559,43 -1535,46 +1593,49 @@@ static void ad_agg_selection_logic(stru
  		active->is_active = 1;
  	}
  
 -	/* if there is new best aggregator, activate it */
 +	// if there is new best aggregator, activate it
  	if (best) {
- 		pr_debug("best Agg=%d; P=%d; a k=%d; p k=%d; Ind=%d; Act=%d\n",
- 			 best->aggregator_identifier, best->num_of_ports,
- 			 best->actor_oper_aggregator_key,
- 			 best->partner_oper_aggregator_key,
- 			 best->is_individual, best->is_active);
- 		pr_debug("best ports %p slave %p %s\n",
- 			 best->lag_ports, best->slave,
- 			 best->slave ? best->slave->dev->name : "NULL");
+ 		netdev_dbg(bond->dev, "best Agg=%d; P=%d; a k=%d; p k=%d; Ind=%d; Act=%d\n",
+ 			   best->aggregator_identifier, best->num_of_ports,
+ 			   best->actor_oper_aggregator_key,
+ 			   best->partner_oper_aggregator_key,
+ 			   best->is_individual, best->is_active);
+ 		netdev_dbg(bond->dev, "best ports %p slave %p %s\n",
+ 			   best->lag_ports, best->slave,
+ 			   best->slave ? best->slave->dev->name : "NULL");
  
 -		bond_for_each_slave_rcu(bond, slave, iter) {
 -			agg = &(SLAVE_AD_INFO(slave)->aggregator);
 +		bond_for_each_slave(bond, slave, iter) {
 +			agg = &(SLAVE_AD_INFO(slave).aggregator);
  
- 			pr_debug("Agg=%d; P=%d; a k=%d; p k=%d; Ind=%d; Act=%d\n",
- 				 agg->aggregator_identifier, agg->num_of_ports,
- 				 agg->actor_oper_aggregator_key,
- 				 agg->partner_oper_aggregator_key,
- 				 agg->is_individual, agg->is_active);
+ 			netdev_dbg(bond->dev, "Agg=%d; P=%d; a k=%d; p k=%d; Ind=%d; Act=%d\n",
+ 				   agg->aggregator_identifier, agg->num_of_ports,
+ 				   agg->actor_oper_aggregator_key,
+ 				   agg->partner_oper_aggregator_key,
+ 				   agg->is_individual, agg->is_active);
  		}
  
 -		/* check if any partner replys */
 +		// check if any partner replys
  		if (best->is_individual) {
++<<<<<<< HEAD
 +			pr_warning("%s: Warning: No 802.3ad response from the link partner for any adapters in the bond\n",
 +				   best->slave ? best->slave->bond->dev->name : "NULL");
++=======
+ 			net_warn_ratelimited("%s: Warning: No 802.3ad response from the link partner for any adapters in the bond\n",
+ 					     best->slave ?
+ 					     best->slave->bond->dev->name : "NULL");
++>>>>>>> d4471f5e23a7 (bonding: convert bond_3ad.c to use netdev_printk instead of pr_)
  		}
  
  		best->is_active = 1;
- 		pr_debug("LAG %d chosen as the active LAG\n",
- 			 best->aggregator_identifier);
- 		pr_debug("Agg=%d; P=%d; a k=%d; p k=%d; Ind=%d; Act=%d\n",
- 			 best->aggregator_identifier, best->num_of_ports,
- 			 best->actor_oper_aggregator_key,
- 			 best->partner_oper_aggregator_key,
- 			 best->is_individual, best->is_active);
+ 		netdev_dbg(bond->dev, "LAG %d chosen as the active LAG\n",
+ 			   best->aggregator_identifier);
+ 		netdev_dbg(bond->dev, "Agg=%d; P=%d; a k=%d; p k=%d; Ind=%d; Act=%d\n",
+ 			   best->aggregator_identifier, best->num_of_ports,
+ 			   best->actor_oper_aggregator_key,
+ 			   best->partner_oper_aggregator_key,
+ 			   best->is_individual, best->is_active);
  
 -		/* disable the ports that were related to the former
 -		 * active_aggregator
 -		 */
 +		// disable the ports that were related to the former active_aggregator
  		if (active) {
  			for (port = active->lag_ports; port;
  			     port = port->next_port_in_aggregator) {
@@@ -1966,16 -1901,13 +2006,21 @@@ void bond_3ad_unbind_slave(struct slav
  	struct slave *slave_iter;
  	struct list_head *iter;
  
 -	aggregator = &(SLAVE_AD_INFO(slave)->aggregator);
 -	port = &(SLAVE_AD_INFO(slave)->port);
 +	// find the aggregator related to this slave
 +	aggregator = &(SLAVE_AD_INFO(slave).aggregator);
  
 -	/* if slave is null, the whole port is not initialized */
 +	// find the port related to this slave
 +	port = &(SLAVE_AD_INFO(slave).port);
 +
 +	// if slave is null, the whole port is not initialized
  	if (!port->slave) {
++<<<<<<< HEAD
 +		pr_warning("Warning: %s: Trying to unbind an uninitialized port on %s\n",
 +			   slave->bond->dev->name, slave->dev->name);
++=======
+ 		netdev_warn(bond->dev, "Trying to unbind an uninitialized port on %s\n",
+ 			    slave->dev->name);
++>>>>>>> d4471f5e23a7 (bonding: convert bond_3ad.c to use netdev_printk instead of pr_)
  		return;
  	}
  
@@@ -2004,17 -1941,19 +2049,27 @@@
  			}
  			if (!slave_iter)
  				new_aggregator = NULL;
 -
 -			/* if new aggregator found, copy the aggregator's
 -			 * parameters and connect the related lag_ports to the
 -			 * new aggregator
 -			 */
 +			// if new aggregator found, copy the aggregator's parameters
 +			// and connect the related lag_ports to the new aggregator
  			if ((new_aggregator) && ((!new_aggregator->lag_ports) || ((new_aggregator->lag_ports == port) && !new_aggregator->lag_ports->next_port_in_aggregator))) {
++<<<<<<< HEAD
 +				pr_debug("Some port(s) related to LAG %d - replaceing with LAG %d\n",
 +					 aggregator->aggregator_identifier,
 +					 new_aggregator->aggregator_identifier);
 +
 +				if ((new_aggregator->lag_ports == port) && new_aggregator->is_active) {
 +					pr_info("%s: Removing an active aggregator\n",
 +						aggregator->slave->bond->dev->name);
 +					// select new active aggregator
++=======
+ 				netdev_dbg(bond->dev, "Some port(s) related to LAG %d - replacing with LAG %d\n",
+ 					   aggregator->aggregator_identifier,
+ 					   new_aggregator->aggregator_identifier);
+ 
+ 				if ((new_aggregator->lag_ports == port) &&
+ 				    new_aggregator->is_active) {
+ 					netdev_info(bond->dev, "Removing an active aggregator\n");
++>>>>>>> d4471f5e23a7 (bonding: convert bond_3ad.c to use netdev_printk instead of pr_)
  					 select_new_active_agg = 1;
  				}
  
@@@ -2043,17 -1983,17 +2098,26 @@@
  				if (select_new_active_agg)
  					ad_agg_selection_logic(__get_first_agg(port));
  			} else {
++<<<<<<< HEAD
 +				pr_warning("%s: Warning: unbinding aggregator, and could not find a new aggregator for its ports\n",
 +					   slave->bond->dev->name);
++=======
+ 				netdev_warn(bond->dev, "unbinding aggregator, and could not find a new aggregator for its ports\n");
++>>>>>>> d4471f5e23a7 (bonding: convert bond_3ad.c to use netdev_printk instead of pr_)
  			}
 -		} else {
 -			/* in case that the only port related to this
 -			 * aggregator is the one we want to remove
 -			 */
 +		} else { // in case that the only port related to this aggregator is the one we want to remove
  			select_new_active_agg = aggregator->is_active;
 +			// clear the aggregator
  			ad_clear_agg(aggregator);
  			if (select_new_active_agg) {
++<<<<<<< HEAD
 +				pr_info("%s: Removing an active aggregator\n",
 +					slave->bond->dev->name);
 +				// select new active aggregator
++=======
+ 				netdev_info(bond->dev, "Removing an active aggregator\n");
+ 				/* select new active aggregator */
++>>>>>>> d4471f5e23a7 (bonding: convert bond_3ad.c to use netdev_printk instead of pr_)
  				temp_aggregator = __get_first_agg(port);
  				if (temp_aggregator)
  					ad_agg_selection_logic(temp_aggregator);
@@@ -2061,16 -2001,20 +2125,22 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	pr_debug("Unbinding port %d\n", port->actor_port_number);
 +	// find the aggregator that this port is connected to
++=======
+ 	netdev_dbg(bond->dev, "Unbinding port %d\n", port->actor_port_number);
+ 
+ 	/* find the aggregator that this port is connected to */
++>>>>>>> d4471f5e23a7 (bonding: convert bond_3ad.c to use netdev_printk instead of pr_)
  	bond_for_each_slave(bond, slave_iter, iter) {
 -		temp_aggregator = &(SLAVE_AD_INFO(slave_iter)->aggregator);
 +		temp_aggregator = &(SLAVE_AD_INFO(slave_iter).aggregator);
  		prev_port = NULL;
 -		/* search the port in the aggregator's related ports */
 +		// search the port in the aggregator's related ports
  		for (temp_port = temp_aggregator->lag_ports; temp_port;
  		     prev_port = temp_port,
 -		     temp_port = temp_port->next_port_in_aggregator) {
 -			if (temp_port == port) {
 -				/* the aggregator found - detach the port from
 -				 * this aggregator
 -				 */
 +			     temp_port = temp_port->next_port_in_aggregator) {
 +			if (temp_port == port) { // the aggregator found - detach the port from this aggregator
  				if (prev_port)
  					prev_port->next_port_in_aggregator = temp_port->next_port_in_aggregator;
  				else
@@@ -2078,12 -2022,10 +2148,17 @@@
  				temp_aggregator->num_of_ports--;
  				if (temp_aggregator->num_of_ports == 0) {
  					select_new_active_agg = temp_aggregator->is_active;
 +					// clear the aggregator
  					ad_clear_agg(temp_aggregator);
  					if (select_new_active_agg) {
++<<<<<<< HEAD
 +						pr_info("%s: Removing an active aggregator\n",
 +							slave->bond->dev->name);
 +						// select new active aggregator
++=======
+ 						netdev_info(bond->dev, "Removing an active aggregator\n");
+ 						/* select new active aggregator */
++>>>>>>> d4471f5e23a7 (bonding: convert bond_3ad.c to use netdev_printk instead of pr_)
  						ad_agg_selection_logic(__get_first_agg(port));
  					}
  				}
@@@ -2111,24 -2053,30 +2186,29 @@@ void bond_3ad_state_machine_handler(str
  {
  	struct bonding *bond = container_of(work, struct bonding,
  					    ad_work.work);
 -	struct aggregator *aggregator;
 -	struct list_head *iter;
 -	struct slave *slave;
  	struct port *port;
 -	bool should_notify_rtnl = BOND_SLAVE_NOTIFY_LATER;
 -
 -	read_lock(&bond->lock);
 -	rcu_read_lock();
 +	struct aggregator *aggregator;
  
 -	/* check if there are any slaves */
 -	if (!bond_has_slaves(bond))
 +	if (!rtnl_trylock()) {
 +		queue_delayed_work(bond->wq, &bond->ad_work, ad_delta_in_ticks);
 +		return;
 +	}
 +	//check if there are any slaves
 +	if (bond->slave_cnt == 0)
  		goto re_arm;
  
 -	/* check if agg_select_timer timer after initialize is timed out */
 -	if (BOND_AD_INFO(bond).agg_select_timer &&
 -	    !(--BOND_AD_INFO(bond).agg_select_timer)) {
 -		slave = bond_first_slave_rcu(bond);
 -		port = slave ? &(SLAVE_AD_INFO(slave)->port) : NULL;
 -
 -		/* select the active aggregator for the bond */
 -		if (port) {
 +	// check if agg_select_timer timer after initialize is timed out
 +	if (BOND_AD_INFO(bond).agg_select_timer && !(--BOND_AD_INFO(bond).agg_select_timer)) {
 +		// select the active aggregator for the bond
 +		if ((port = __get_first_port(bond))) {
  			if (!port->slave) {
++<<<<<<< HEAD
 +				pr_warning("%s: Warning: bond's first port is uninitialized\n",
 +					   bond->dev->name);
++=======
+ 				net_warn_ratelimited("%s: Warning: bond's first port is uninitialized\n",
+ 						     bond->dev->name);
++>>>>>>> d4471f5e23a7 (bonding: convert bond_3ad.c to use netdev_printk instead of pr_)
  				goto re_arm;
  			}
  
@@@ -2138,11 -2086,12 +2218,16 @@@
  		bond_3ad_set_carrier(bond);
  	}
  
 -	/* for each port run the state machines */
 -	bond_for_each_slave_rcu(bond, slave, iter) {
 -		port = &(SLAVE_AD_INFO(slave)->port);
 +	// for each port run the state machines
 +	for (port = __get_first_port(bond); port; port = __get_next_port(port)) {
  		if (!port->slave) {
++<<<<<<< HEAD
 +			pr_warning("%s: Warning: Found an uninitialized port\n",
 +				   bond->dev->name);
++=======
+ 			net_warn_ratelimited("%s: Warning: Found an uninitialized port\n",
+ 					    bond->dev->name);
++>>>>>>> d4471f5e23a7 (bonding: convert bond_3ad.c to use netdev_printk instead of pr_)
  			goto re_arm;
  		}
  
@@@ -2187,11 -2149,11 +2272,16 @@@ static int bond_3ad_rx_indication(struc
  
  	if (length >= sizeof(struct lacpdu)) {
  
 -		port = &(SLAVE_AD_INFO(slave)->port);
 +		port = &(SLAVE_AD_INFO(slave).port);
  
  		if (!port->slave) {
++<<<<<<< HEAD
 +			pr_warning("%s: Warning: port of slave %s is uninitialized\n",
 +				   slave->dev->name, slave->bond->dev->name);
++=======
+ 			net_warn_ratelimited("%s: Warning: port of slave %s is uninitialized\n",
+ 					     slave->dev->name, slave->bond->dev->name);
++>>>>>>> d4471f5e23a7 (bonding: convert bond_3ad.c to use netdev_printk instead of pr_)
  			return ret;
  		}
  
@@@ -2246,8 -2210,8 +2336,13 @@@ void bond_3ad_adapter_speed_changed(str
  
  	/* if slave is null, the whole port is not initialized */
  	if (!port->slave) {
++<<<<<<< HEAD
 +		pr_warning("Warning: %s: speed changed for uninitialized port on %s\n",
 +			   slave->bond->dev->name, slave->dev->name);
++=======
+ 		netdev_warn(slave->bond->dev, "speed changed for uninitialized port on %s\n",
+ 			    slave->dev->name);
++>>>>>>> d4471f5e23a7 (bonding: convert bond_3ad.c to use netdev_printk instead of pr_)
  		return;
  	}
  
@@@ -2279,8 -2243,8 +2374,13 @@@ void bond_3ad_adapter_duplex_changed(st
  
  	/* if slave is null, the whole port is not initialized */
  	if (!port->slave) {
++<<<<<<< HEAD
 +		pr_warning("%s: Warning: duplex changed for uninitialized port on %s\n",
 +			   slave->bond->dev->name, slave->dev->name);
++=======
+ 		netdev_warn(slave->bond->dev, "duplex changed for uninitialized port on %s\n",
+ 			    slave->dev->name);
++>>>>>>> d4471f5e23a7 (bonding: convert bond_3ad.c to use netdev_printk instead of pr_)
  		return;
  	}
  
@@@ -2313,8 -2277,8 +2413,13 @@@ void bond_3ad_handle_link_change(struc
  
  	/* if slave is null, the whole port is not initialized */
  	if (!port->slave) {
++<<<<<<< HEAD
 +		pr_warning("Warning: %s: link status changed for uninitialized port on %s\n",
 +			   slave->bond->dev->name, slave->dev->name);
++=======
+ 		netdev_warn(slave->bond->dev, "link status changed for uninitialized port on %s\n",
+ 			    slave->dev->name);
++>>>>>>> d4471f5e23a7 (bonding: convert bond_3ad.c to use netdev_printk instead of pr_)
  		return;
  	}
  
@@@ -2341,9 -2305,9 +2446,15 @@@
  		port->actor_oper_port_key = (port->actor_admin_port_key &=
  					     ~AD_SPEED_KEY_BITS);
  	}
++<<<<<<< HEAD
 +	pr_debug("Port %d changed link status to %s",
 +		port->actor_port_number,
 +		(link == BOND_LINK_UP) ? "UP" : "DOWN");
++=======
+ 	netdev_dbg(slave->bond->dev, "Port %d changed link status to %s\n",
+ 		   port->actor_port_number,
+ 		   link == BOND_LINK_UP ? "UP" : "DOWN");
++>>>>>>> d4471f5e23a7 (bonding: convert bond_3ad.c to use netdev_printk instead of pr_)
  	/* there is no need to reselect a new aggregator, just signal the
  	 * state machines to reinitialize
  	 */
@@@ -2435,70 -2411,69 +2546,86 @@@ int bond_3ad_get_active_agg_info(struc
  
  int bond_3ad_xmit_xor(struct sk_buff *skb, struct net_device *dev)
  {
 +	struct slave *slave, *start_at;
  	struct bonding *bond = netdev_priv(dev);
 -	struct slave *slave, *first_ok_slave;
 -	struct aggregator *agg;
 -	struct ad_info ad_info;
 -	struct list_head *iter;
 -	int slaves_in_agg;
  	int slave_agg_no;
 +	int slaves_in_agg;
  	int agg_id;
 +	int i;
 +	struct ad_info ad_info;
 +	int res = 1;
  
  	if (__bond_3ad_get_active_agg_info(bond, &ad_info)) {
++<<<<<<< HEAD
 +		pr_debug("%s: Error: __bond_3ad_get_active_agg_info failed\n",
 +			 dev->name);
 +		goto out;
++=======
+ 		netdev_dbg(dev, "__bond_3ad_get_active_agg_info failed\n");
+ 		goto err_free;
++>>>>>>> d4471f5e23a7 (bonding: convert bond_3ad.c to use netdev_printk instead of pr_)
  	}
  
  	slaves_in_agg = ad_info.ports;
  	agg_id = ad_info.aggregator_id;
  
  	if (slaves_in_agg == 0) {
++<<<<<<< HEAD
 +		/*the aggregator is empty*/
 +		pr_debug("%s: Error: active aggregator is empty\n", dev->name);
 +		goto out;
++=======
+ 		netdev_dbg(dev, "active aggregator is empty\n");
+ 		goto err_free;
++>>>>>>> d4471f5e23a7 (bonding: convert bond_3ad.c to use netdev_printk instead of pr_)
  	}
  
 -	slave_agg_no = bond_xmit_hash(bond, skb) % slaves_in_agg;
 -	first_ok_slave = NULL;
 +	slave_agg_no = bond->xmit_hash_policy(skb, slaves_in_agg);
  
 -	bond_for_each_slave_rcu(bond, slave, iter) {
 -		agg = SLAVE_AD_INFO(slave)->port.aggregator;
 -		if (!agg || agg->aggregator_identifier != agg_id)
 -			continue;
 +	bond_for_each_slave(bond, slave, i) {
 +		struct aggregator *agg = SLAVE_AD_INFO(slave).port.aggregator;
  
 -		if (slave_agg_no >= 0) {
 -			if (!first_ok_slave && bond_slave_can_tx(slave))
 -				first_ok_slave = slave;
 +		if (agg && (agg->aggregator_identifier == agg_id)) {
  			slave_agg_no--;
 -			continue;
 -		}
 -
 -		if (bond_slave_can_tx(slave)) {
 -			bond_dev_queue_xmit(bond, skb, slave->dev);
 -			goto out;
 +			if (slave_agg_no < 0)
 +				break;
  		}
  	}
  
  	if (slave_agg_no >= 0) {
++<<<<<<< HEAD
 +		pr_err("%s: Error: Couldn't find a slave to tx on for aggregator ID %d\n",
 +		       dev->name, agg_id);
 +		goto out;
++=======
+ 		netdev_err(dev, "Couldn't find a slave to tx on for aggregator ID %d\n",
+ 			   agg_id);
+ 		goto err_free;
++>>>>>>> d4471f5e23a7 (bonding: convert bond_3ad.c to use netdev_printk instead of pr_)
  	}
  
 -	/* we couldn't find any suitable slave after the agg_no, so use the
 -	 * first suitable found, if found.
 -	 */
 -	if (first_ok_slave)
 -		bond_dev_queue_xmit(bond, skb, first_ok_slave->dev);
 -	else
 -		goto err_free;
 +	start_at = slave;
 +
 +	bond_for_each_slave_from(bond, slave, i, start_at) {
 +		int slave_agg_id = 0;
 +		struct aggregator *agg = SLAVE_AD_INFO(slave).port.aggregator;
 +
 +		if (agg)
 +			slave_agg_id = agg->aggregator_identifier;
 +
 +		if (SLAVE_IS_OK(slave) && agg && (slave_agg_id == agg_id)) {
 +			res = bond_dev_queue_xmit(bond, skb, slave->dev);
 +			break;
 +		}
 +	}
  
  out:
 +	if (res) {
 +		/* no suitable interface, frame not sent */
 +		kfree_skb(skb);
 +	}
 +
  	return NETDEV_TX_OK;
 -err_free:
 -	/* no suitable interface, frame not sent */
 -	dev_kfree_skb_any(skb);
 -	goto out;
  }
  
  int bond_3ad_lacpdu_recv(const struct sk_buff *skb, struct bonding *bond,
* Unmerged path drivers/net/bonding/bond_3ad.c
