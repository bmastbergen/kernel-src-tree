ALSA: hda - Use regmap for command verb caches, too

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [alsa] hda - Use regmap for command verb caches, too (Jaroslav Kysela) [1197064]
Rebuild_FUZZ: 93.75%
commit-author Takashi Iwai <tiwai@suse.de>
commit a551d91473e5e3a591f6fe86ac5a5fb460c3f96a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/a551d914.failed

Like the previous patches, this patch converts also to the regmap, at
this time, the cached verb writes are the target.  But this conversion
needs a bit more caution than before.

- In the old code, we just record any verbs as is, and restore them at
  resume.  For the regmap scheme, this doesn't work, since a few verbs
  like AMP or DIGI_CONVERT are asymmetrical.  Such verbs are converted
  either to the dedicated function (snd_hda_regmap_xxx_amp()) or
  changed to the unified verb.

- Some verbs have to be declared as vendor-specific ones before
  accessing via regmap.

Also, the minor optimization with codec->cached_write flag is dropped
in a few places, as this would confuse the operation.  Further
optimizations will be brought in the later patches, if any.

This conversion ends up with a drop of significant amount of codes,
mostly the helper codes that are no longer used.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit a551d91473e5e3a591f6fe86ac5a5fb460c3f96a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/hda_codec.c
#	sound/pci/hda/hda_codec.h
#	sound/pci/hda/patch_hdmi.c
#	sound/pci/hda/patch_realtek.c
diff --cc sound/pci/hda/hda_codec.c
index 05cb5f57659a,41851f9b48c1..000000000000
--- a/sound/pci/hda/hda_codec.c
+++ b/sound/pci/hda/hda_codec.c
@@@ -1187,11 -925,6 +1183,14 @@@ void snd_hda_codec_cleanup_for_unbind(s
  	codec->proc_widget_hook = NULL;
  	codec->spec = NULL;
  
++<<<<<<< HEAD
 +	free_hda_cache(&codec->amp_cache);
 +	free_hda_cache(&codec->cmd_cache);
 +	init_hda_cache(&codec->amp_cache, sizeof(struct hda_amp_info));
 +	init_hda_cache(&codec->cmd_cache, sizeof(struct hda_cache_head));
 +
++=======
++>>>>>>> a551d91473e5 (ALSA: hda - Use regmap for command verb caches, too)
  	/* free only driver_pins so that init_pins + user_pins are restored */
  	snd_array_free(&codec->driver_pins);
  	snd_array_free(&codec->cvt_setups);
@@@ -1259,10 -980,16 +1258,21 @@@ static int snd_hda_codec_dev_free(struc
  	return 0;
  }
  
 +/* just free the container */
  static void snd_hda_codec_dev_release(struct device *dev)
  {
++<<<<<<< HEAD
 +	kfree(dev_to_hda_codec(dev));
++=======
+ 	struct hda_codec *codec = dev_to_hda_codec(dev);
+ 
+ 	free_init_pincfgs(codec);
+ 	snd_hdac_device_exit(&codec->core);
+ 	snd_hda_sysfs_clear(codec);
+ 	kfree(codec->modelname);
+ 	kfree(codec->wcaps);
+ 	kfree(codec);
++>>>>>>> a551d91473e5 (ALSA: hda - Use regmap for command verb caches, too)
  }
  
  /**
@@@ -1318,9 -1039,6 +1328,12 @@@ int snd_hda_codec_new(struct hda_bus *b
  	codec->addr = codec_addr;
  	mutex_init(&codec->spdif_mutex);
  	mutex_init(&codec->control_mutex);
++<<<<<<< HEAD
 +	mutex_init(&codec->hash_mutex);
 +	init_hda_cache(&codec->amp_cache, sizeof(struct hda_amp_info));
 +	init_hda_cache(&codec->cmd_cache, sizeof(struct hda_cache_head));
++=======
++>>>>>>> a551d91473e5 (ALSA: hda - Use regmap for command verb caches, too)
  	snd_array_init(&codec->mixers, sizeof(struct hda_nid_item), 32);
  	snd_array_init(&codec->nids, sizeof(struct hda_nid_item), 32);
  	snd_array_init(&codec->init_pins, sizeof(struct hda_pincfg), 16);
@@@ -1634,127 -1306,6 +1647,130 @@@ static void hda_cleanup_all_streams(str
   * amp access functions
   */
  
++<<<<<<< HEAD
 +/* FIXME: more better hash key? */
 +#define HDA_HASH_KEY(nid, dir, idx) (u32)((nid) + ((idx) << 16) + ((dir) << 24))
 +#define HDA_HASH_PINCAP_KEY(nid) (u32)((nid) + (0x02 << 24))
 +#define HDA_HASH_PARPCM_KEY(nid) (u32)((nid) + (0x03 << 24))
 +#define HDA_HASH_PARSTR_KEY(nid) (u32)((nid) + (0x04 << 24))
 +#define INFO_AMP_CAPS	(1<<0)
 +#define INFO_AMP_VOL(ch)	(1 << (1 + (ch)))
 +
 +/* initialize the hash table */
 +static void init_hda_cache(struct hda_cache_rec *cache,
 +				     unsigned int record_size)
 +{
 +	memset(cache, 0, sizeof(*cache));
 +	memset(cache->hash, 0xff, sizeof(cache->hash));
 +	snd_array_init(&cache->buf, record_size, 64);
 +}
 +
 +static void free_hda_cache(struct hda_cache_rec *cache)
 +{
 +	snd_array_free(&cache->buf);
 +}
 +
 +/* query the hash.  allocate an entry if not found. */
 +static struct hda_cache_head  *get_hash(struct hda_cache_rec *cache, u32 key)
 +{
 +	u16 idx = key % (u16)ARRAY_SIZE(cache->hash);
 +	u16 cur = cache->hash[idx];
 +	struct hda_cache_head *info;
 +
 +	while (cur != 0xffff) {
 +		info = snd_array_elem(&cache->buf, cur);
 +		if (info->key == key)
 +			return info;
 +		cur = info->next;
 +	}
 +	return NULL;
 +}
 +
 +/* query the hash.  allocate an entry if not found. */
 +static struct hda_cache_head  *get_alloc_hash(struct hda_cache_rec *cache,
 +					      u32 key)
 +{
 +	struct hda_cache_head *info = get_hash(cache, key);
 +	if (!info) {
 +		u16 idx, cur;
 +		/* add a new hash entry */
 +		info = snd_array_new(&cache->buf);
 +		if (!info)
 +			return NULL;
 +		cur = snd_array_index(&cache->buf, info);
 +		info->key = key;
 +		info->val = 0;
 +		info->dirty = 0;
 +		idx = key % (u16)ARRAY_SIZE(cache->hash);
 +		info->next = cache->hash[idx];
 +		cache->hash[idx] = cur;
 +	}
 +	return info;
 +}
 +
 +/* query and allocate an amp hash entry */
 +static inline struct hda_amp_info *
 +get_alloc_amp_hash(struct hda_codec *codec, u32 key)
 +{
 +	return (struct hda_amp_info *)get_alloc_hash(&codec->amp_cache, key);
 +}
 +
 +/* overwrite the value with the key in the caps hash */
 +static int write_caps_hash(struct hda_codec *codec, u32 key, unsigned int val)
 +{
 +	struct hda_amp_info *info;
 +
 +	mutex_lock(&codec->hash_mutex);
 +	info = get_alloc_amp_hash(codec, key);
 +	if (!info) {
 +		mutex_unlock(&codec->hash_mutex);
 +		return -EINVAL;
 +	}
 +	info->amp_caps = val;
 +	info->head.val |= INFO_AMP_CAPS;
 +	mutex_unlock(&codec->hash_mutex);
 +	return 0;
 +}
 +
 +/* query the value from the caps hash; if not found, fetch the current
 + * value from the given function and store in the hash
 + */
 +static unsigned int
 +query_caps_hash(struct hda_codec *codec, hda_nid_t nid, int dir, u32 key,
 +		unsigned int (*func)(struct hda_codec *, hda_nid_t, int))
 +{
 +	struct hda_amp_info *info;
 +	unsigned int val;
 +
 +	mutex_lock(&codec->hash_mutex);
 +	info = get_alloc_amp_hash(codec, key);
 +	if (!info) {
 +		mutex_unlock(&codec->hash_mutex);
 +		return 0;
 +	}
 +	if (!(info->head.val & INFO_AMP_CAPS)) {
 +		mutex_unlock(&codec->hash_mutex); /* for reentrance */
 +		val = func(codec, nid, dir);
 +		write_caps_hash(codec, key, val);
 +	} else {
 +		val = info->amp_caps;
 +		mutex_unlock(&codec->hash_mutex);
 +	}
 +	return val;
 +}
 +
 +static unsigned int read_amp_cap(struct hda_codec *codec, hda_nid_t nid,
 +				 int direction)
 +{
 +	if (!(get_wcaps(codec, nid) & AC_WCAP_AMP_OVRD))
 +		nid = codec->afg;
 +	return snd_hda_param_read(codec, nid,
 +				  direction == HDA_OUTPUT ?
 +				  AC_PAR_AMP_OUT_CAP : AC_PAR_AMP_IN_CAP);
 +}
 +
++=======
++>>>>>>> a551d91473e5 (ALSA: hda - Use regmap for command verb caches, too)
  /**
   * query_amp_caps - query AMP capabilities
   * @codec: the HD-auio codec
@@@ -3591,153 -2949,6 +3620,156 @@@ int snd_hda_create_spdif_in_ctls(struc
  }
  EXPORT_SYMBOL_GPL(snd_hda_create_spdif_in_ctls);
  
++<<<<<<< HEAD
 +/*
 + * command cache
 + */
 +
 +/* build a 31bit cache key with the widget id and the command parameter */
 +#define build_cmd_cache_key(nid, verb)	((verb << 8) | nid)
 +#define get_cmd_cache_nid(key)		((key) & 0xff)
 +#define get_cmd_cache_cmd(key)		(((key) >> 8) & 0xffff)
 +
 +/**
 + * snd_hda_codec_write_cache - send a single command with caching
 + * @codec: the HDA codec
 + * @nid: NID to send the command
 + * @flags: optional bit flags
 + * @verb: the verb to send
 + * @parm: the parameter for the verb
 + *
 + * Send a single command without waiting for response.
 + *
 + * Returns 0 if successful, or a negative error code.
 + */
 +int snd_hda_codec_write_cache(struct hda_codec *codec, hda_nid_t nid,
 +			      int flags, unsigned int verb, unsigned int parm)
 +{
 +	int err;
 +	struct hda_cache_head *c;
 +	u32 key;
 +	unsigned int cache_only;
 +
 +	cache_only = codec->cached_write;
 +	if (!cache_only) {
 +		err = snd_hda_codec_write(codec, nid, flags, verb, parm);
 +		if (err < 0)
 +			return err;
 +	}
 +
 +	/* parm may contain the verb stuff for get/set amp */
 +	verb = verb | (parm >> 8);
 +	parm &= 0xff;
 +	key = build_cmd_cache_key(nid, verb);
 +	mutex_lock(&codec->bus->cmd_mutex);
 +	c = get_alloc_hash(&codec->cmd_cache, key);
 +	if (c) {
 +		c->val = parm;
 +		c->dirty = cache_only;
 +	}
 +	mutex_unlock(&codec->bus->cmd_mutex);
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(snd_hda_codec_write_cache);
 +
 +/**
 + * snd_hda_codec_update_cache - check cache and write the cmd only when needed
 + * @codec: the HDA codec
 + * @nid: NID to send the command
 + * @flags: optional bit flags
 + * @verb: the verb to send
 + * @parm: the parameter for the verb
 + *
 + * This function works like snd_hda_codec_write_cache(), but it doesn't send
 + * command if the parameter is already identical with the cached value.
 + * If not, it sends the command and refreshes the cache.
 + *
 + * Returns 0 if successful, or a negative error code.
 + */
 +int snd_hda_codec_update_cache(struct hda_codec *codec, hda_nid_t nid,
 +			       int flags, unsigned int verb, unsigned int parm)
 +{
 +	struct hda_cache_head *c;
 +	u32 key;
 +
 +	/* parm may contain the verb stuff for get/set amp */
 +	verb = verb | (parm >> 8);
 +	parm &= 0xff;
 +	key = build_cmd_cache_key(nid, verb);
 +	mutex_lock(&codec->bus->cmd_mutex);
 +	c = get_hash(&codec->cmd_cache, key);
 +	if (c && c->val == parm) {
 +		mutex_unlock(&codec->bus->cmd_mutex);
 +		return 0;
 +	}
 +	mutex_unlock(&codec->bus->cmd_mutex);
 +	return snd_hda_codec_write_cache(codec, nid, flags, verb, parm);
 +}
 +EXPORT_SYMBOL_GPL(snd_hda_codec_update_cache);
 +
 +/**
 + * snd_hda_codec_resume_cache - Resume the all commands from the cache
 + * @codec: HD-audio codec
 + *
 + * Execute all verbs recorded in the command caches to resume.
 + */
 +void snd_hda_codec_resume_cache(struct hda_codec *codec)
 +{
 +	int i;
 +
 +	mutex_lock(&codec->hash_mutex);
 +	codec->cached_write = 0;
 +	for (i = 0; i < codec->cmd_cache.buf.used; i++) {
 +		struct hda_cache_head *buffer;
 +		u32 key;
 +
 +		buffer = snd_array_elem(&codec->cmd_cache.buf, i);
 +		key = buffer->key;
 +		if (!key)
 +			continue;
 +		if (!buffer->dirty)
 +			continue;
 +		buffer->dirty = 0;
 +		mutex_unlock(&codec->hash_mutex);
 +		snd_hda_codec_write(codec, get_cmd_cache_nid(key), 0,
 +				    get_cmd_cache_cmd(key), buffer->val);
 +		mutex_lock(&codec->hash_mutex);
 +	}
 +	mutex_unlock(&codec->hash_mutex);
 +}
 +EXPORT_SYMBOL_GPL(snd_hda_codec_resume_cache);
 +
 +/**
 + * snd_hda_sequence_write_cache - sequence writes with caching
 + * @codec: the HDA codec
 + * @seq: VERB array to send
 + *
 + * Send the commands sequentially from the given array.
 + * Thte commands are recorded on cache for power-save and resume.
 + * The array must be terminated with NID=0.
 + */
 +void snd_hda_sequence_write_cache(struct hda_codec *codec,
 +				  const struct hda_verb *seq)
 +{
 +	for (; seq->nid; seq++)
 +		snd_hda_codec_write_cache(codec, seq->nid, 0, seq->verb,
 +					  seq->param);
 +}
 +EXPORT_SYMBOL_GPL(snd_hda_sequence_write_cache);
 +
 +/**
 + * snd_hda_codec_flush_cache - Execute all pending (cached) amps / verbs
 + * @codec: HD-audio codec
 + */
 +void snd_hda_codec_flush_cache(struct hda_codec *codec)
 +{
 +	snd_hda_codec_resume_amp(codec);
 +	snd_hda_codec_resume_cache(codec);
 +}
 +EXPORT_SYMBOL_GPL(snd_hda_codec_flush_cache);
 +
++=======
++>>>>>>> a551d91473e5 (ALSA: hda - Use regmap for command verb caches, too)
  /**
   * snd_hda_codec_set_power_to_all - Set the power state to all widgets
   * @codec: the HDA codec
@@@ -3957,34 -3149,17 +3989,40 @@@ static unsigned int hda_call_codec_susp
  	return state;
  }
  
++<<<<<<< HEAD
 +/* mark all entries of cmd and amp caches dirty */
 +static void hda_mark_cmd_cache_dirty(struct hda_codec *codec)
 +{
 +	int i;
 +	for (i = 0; i < codec->cmd_cache.buf.used; i++) {
 +		struct hda_cache_head *cmd;
 +		cmd = snd_array_elem(&codec->cmd_cache.buf, i);
 +		cmd->dirty = 1;
 +	}
 +	for (i = 0; i < codec->amp_cache.buf.used; i++) {
 +		struct hda_amp_info *amp;
 +		amp = snd_array_elem(&codec->amp_cache.buf, i);
 +		amp->head.dirty = 1;
 +	}
 +}
 +
++=======
++>>>>>>> a551d91473e5 (ALSA: hda - Use regmap for command verb caches, too)
  /*
   * kick up codec; used both from PM and power-save
   */
  static void hda_call_codec_resume(struct hda_codec *codec)
  {
 -	atomic_inc(&codec->core.in_pm);
 +	atomic_inc(&codec->in_pm);
  
 -	if (codec->core.regmap)
 -		regcache_mark_dirty(codec->core.regmap);
++<<<<<<< HEAD
 +	trace_hda_power_up(codec);
 +	hda_mark_cmd_cache_dirty(codec);
  
++=======
++>>>>>>> a551d91473e5 (ALSA: hda - Use regmap for command verb caches, too)
  	codec->power_jiffies = jiffies;
 +	hda_call_pm_notify(codec, true);
  
  	hda_set_power_state(codec, AC_PWRST_D0);
  	restore_shutup_pins(codec);
@@@ -3995,8 -3170,8 +4033,13 @@@
  	else {
  		if (codec->patch_ops.init)
  			codec->patch_ops.init(codec);
++<<<<<<< HEAD
 +		snd_hda_codec_resume_amp(codec);
 +		snd_hda_codec_resume_cache(codec);
++=======
+ 		if (codec->core.regmap)
+ 			regcache_sync(codec->core.regmap);
++>>>>>>> a551d91473e5 (ALSA: hda - Use regmap for command verb caches, too)
  	}
  
  	if (codec->jackpoll_interval)
diff --cc sound/pci/hda/hda_codec.h
index 4f8090e5338d,26cbb1fa9729..000000000000
--- a/sound/pci/hda/hda_codec.h
+++ b/sound/pci/hda/hda_codec.h
@@@ -208,25 -155,6 +208,28 @@@ struct hda_codec_ops 
  	void (*stream_pm)(struct hda_codec *codec, hda_nid_t nid, bool on);
  };
  
++<<<<<<< HEAD
 +/* record for amp information cache */
 +struct hda_cache_head {
 +	u32 key:31;		/* hash key */
 +	u32 dirty:1;
 +	u16 val;		/* assigned value */
 +	u16 next;
 +};
 +
 +struct hda_amp_info {
 +	struct hda_cache_head head;
 +	u32 amp_caps;		/* amp capabilities */
 +	u16 vol[2];		/* current volume & mute */
 +};
 +
 +struct hda_cache_rec {
 +	u16 hash[64];			/* hash table for index */
 +	struct snd_array buf;		/* record entries */
 +};
 +
++=======
++>>>>>>> a551d91473e5 (ALSA: hda - Use regmap for command verb caches, too)
  /* PCM callbacks */
  struct hda_pcm_ops {
  	int (*open)(struct hda_pcm_stream *info, struct hda_codec *codec,
@@@ -327,9 -238,6 +330,12 @@@ struct hda_codec 
  	struct snd_array mixers;	/* list of assigned mixer elements */
  	struct snd_array nids;		/* list of mapped mixer elements */
  
++<<<<<<< HEAD
 +	struct hda_cache_rec amp_cache;	/* cache for amp access */
 +	struct hda_cache_rec cmd_cache;	/* cache for other commands */
 +
++=======
++>>>>>>> a551d91473e5 (ALSA: hda - Use regmap for command verb caches, too)
  	struct list_head conn_list;	/* linked-list of connection-list */
  
  	struct mutex spdif_mutex;
@@@ -480,18 -383,22 +485,18 @@@ void snd_hda_sequence_write(struct hda_
  			    const struct hda_verb *seq);
  
  /* unsolicited event */
 -static inline void
 -snd_hda_queue_unsol_event(struct hda_bus *bus, u32 res, u32 res_ex)
 -{
 -	snd_hdac_bus_queue_event(&bus->core, res, res_ex);
 -}
 +int snd_hda_queue_unsol_event(struct hda_bus *bus, u32 res, u32 res_ex);
  
  /* cached write */
- int snd_hda_codec_write_cache(struct hda_codec *codec, hda_nid_t nid,
- 			      int flags, unsigned int verb, unsigned int parm);
- void snd_hda_sequence_write_cache(struct hda_codec *codec,
- 				  const struct hda_verb *seq);
- int snd_hda_codec_update_cache(struct hda_codec *codec, hda_nid_t nid,
- 			      int flags, unsigned int verb, unsigned int parm);
- void snd_hda_codec_resume_cache(struct hda_codec *codec);
- /* both for cmd & amp caches */
- void snd_hda_codec_flush_cache(struct hda_codec *codec);
+ static inline int
+ snd_hda_codec_write_cache(struct hda_codec *codec, hda_nid_t nid,
+ 			  int flags, unsigned int verb, unsigned int parm)
+ {
+ 	return snd_hdac_regmap_write(&codec->core, nid, verb, parm);
+ }
+ 
+ #define snd_hda_codec_update_cache(codec, nid, flags, verb, parm) \
+ 	snd_hda_codec_write_cache(codec, nid, flags, verb, parm)
  
  /* the struct for codec->pin_configs */
  struct hda_pincfg {
diff --cc sound/pci/hda/patch_hdmi.c
index 7e9ff7b16e56,ca0c05e1c42e..000000000000
--- a/sound/pci/hda/patch_hdmi.c
+++ b/sound/pci/hda/patch_hdmi.c
@@@ -2212,8 -2211,7 +2212,12 @@@ static int generic_hdmi_resume(struct h
  	int pin_idx;
  
  	codec->patch_ops.init(codec);
++<<<<<<< HEAD
 +	snd_hda_codec_resume_amp(codec);
 +	snd_hda_codec_resume_cache(codec);
++=======
+ 	regcache_sync(codec->core.regmap);
++>>>>>>> a551d91473e5 (ALSA: hda - Use regmap for command verb caches, too)
  
  	for (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {
  		struct hdmi_spec_per_pin *per_pin = get_pin(spec, pin_idx);
diff --cc sound/pci/hda/patch_realtek.c
index 124eacf67fc4,d44cb7e37094..000000000000
--- a/sound/pci/hda/patch_realtek.c
+++ b/sound/pci/hda/patch_realtek.c
@@@ -799,8 -799,7 +799,12 @@@ static int alc_resume(struct hda_codec 
  	if (!spec->no_depop_delay)
  		msleep(150); /* to avoid pop noise */
  	codec->patch_ops.init(codec);
++<<<<<<< HEAD
 +	snd_hda_codec_resume_amp(codec);
 +	snd_hda_codec_resume_cache(codec);
++=======
+ 	regcache_sync(codec->core.regmap);
++>>>>>>> a551d91473e5 (ALSA: hda - Use regmap for command verb caches, too)
  	hda_call_check_power_status(codec, 0x01);
  	return 0;
  }
@@@ -3058,8 -3057,7 +3062,12 @@@ static int alc269_resume(struct hda_cod
  		msleep(200);
  	}
  
++<<<<<<< HEAD
 +	snd_hda_codec_resume_amp(codec);
 +	snd_hda_codec_resume_cache(codec);
++=======
+ 	regcache_sync(codec->core.regmap);
++>>>>>>> a551d91473e5 (ALSA: hda - Use regmap for command verb caches, too)
  	hda_call_check_power_status(codec, 0x01);
  
  	/* on some machine, the BIOS will clear the codec gpio data when enter
* Unmerged path sound/pci/hda/hda_codec.c
* Unmerged path sound/pci/hda/hda_codec.h
diff --git a/sound/pci/hda/hda_generic.c b/sound/pci/hda/hda_generic.c
index 0ef2459cd05f..6a4acd132403 100644
--- a/sound/pci/hda/hda_generic.c
+++ b/sound/pci/hda/hda_generic.c
@@ -3383,11 +3383,6 @@ static int cap_put_caller(struct snd_kcontrol *kcontrol,
 	imux = &spec->input_mux;
 	adc_idx = kcontrol->id.index;
 	mutex_lock(&codec->control_mutex);
-	/* we use the cache-only update at first since multiple input paths
-	 * may shared the same amp; by updating only caches, the redundant
-	 * writes to hardware can be reduced.
-	 */
-	codec->cached_write = 1;
 	for (i = 0; i < imux->num_items; i++) {
 		path = get_input_path(codec, adc_idx, i);
 		if (!path || !path->ctls[type])
@@ -3395,12 +3390,9 @@ static int cap_put_caller(struct snd_kcontrol *kcontrol,
 		kcontrol->private_value = path->ctls[type];
 		err = func(kcontrol, ucontrol);
 		if (err < 0)
-			goto error;
+			break;
 	}
- error:
-	codec->cached_write = 0;
 	mutex_unlock(&codec->control_mutex);
-	snd_hda_codec_flush_cache(codec); /* flush the updates */
 	if (err >= 0 && spec->cap_sync_hook)
 		spec->cap_sync_hook(codec, kcontrol, ucontrol);
 	return err;
@@ -5763,8 +5755,6 @@ int snd_hda_gen_init(struct hda_codec *codec)
 
 	snd_hda_apply_verbs(codec);
 
-	codec->cached_write = 1;
-
 	init_multi_out(codec);
 	init_extra_out(codec);
 	init_multi_io(codec);
@@ -5780,7 +5770,7 @@ int snd_hda_gen_init(struct hda_codec *codec)
 	/* call init functions of standard auto-mute helpers */
 	update_automute_all(codec);
 
-	snd_hda_codec_flush_cache(codec);
+	regcache_sync(codec->core.regmap);
 
 	if (spec->vmaster_mute.sw_kctl && spec->vmaster_mute.hook)
 		snd_hda_sync_vmaster_hook(&spec->vmaster_mute);
diff --git a/sound/pci/hda/patch_analog.c b/sound/pci/hda/patch_analog.c
index af4c7be86c27..24a6e040d66c 100644
--- a/sound/pci/hda/patch_analog.c
+++ b/sound/pci/hda/patch_analog.c
@@ -777,7 +777,6 @@ static int ad1988_auto_smux_enum_put(struct snd_kcontrol *kcontrol,
 		return 0;
 
 	mutex_lock(&codec->control_mutex);
-	codec->cached_write = 1;
 	path = snd_hda_get_path_from_idx(codec,
 					 spec->smux_paths[spec->cur_smux]);
 	if (path)
@@ -786,9 +785,7 @@ static int ad1988_auto_smux_enum_put(struct snd_kcontrol *kcontrol,
 	if (path)
 		snd_hda_activate_path(codec, path, true, true);
 	spec->cur_smux = val;
-	codec->cached_write = 0;
 	mutex_unlock(&codec->control_mutex);
-	snd_hda_codec_flush_cache(codec); /* flush the updates */
 	return 1;
 }
 
@@ -1004,18 +1001,17 @@ static void ad1884_fixup_hp_eapd(struct hda_codec *codec,
 				 const struct hda_fixup *fix, int action)
 {
 	struct ad198x_spec *spec = codec->spec;
-	static const struct hda_verb gpio_init_verbs[] = {
-		{0x01, AC_VERB_SET_GPIO_MASK, 0x02},
-		{0x01, AC_VERB_SET_GPIO_DIRECTION, 0x02},
-		{0x01, AC_VERB_SET_GPIO_DATA, 0x02},
-		{},
-	};
 
 	switch (action) {
 	case HDA_FIXUP_ACT_PRE_PROBE:
 		spec->gen.vmaster_mute.hook = ad1884_vmaster_hp_gpio_hook;
 		spec->gen.own_eapd_ctl = 1;
-		snd_hda_sequence_write_cache(codec, gpio_init_verbs);
+		snd_hda_codec_write_cache(codec, 0x01, 0,
+					  AC_VERB_SET_GPIO_MASK, 0x02);
+		snd_hda_codec_write_cache(codec, 0x01, 0,
+					  AC_VERB_SET_GPIO_DIRECTION, 0x02);
+		snd_hda_codec_write_cache(codec, 0x01, 0,
+					  AC_VERB_SET_GPIO_DATA, 0x02);
 		break;
 	case HDA_FIXUP_ACT_PROBE:
 		if (spec->gen.autocfg.line_out_type == AUTO_PIN_SPEAKER_OUT)
diff --git a/sound/pci/hda/patch_conexant.c b/sound/pci/hda/patch_conexant.c
index 5aa466a13e43..1c07ac03b6dc 100644
--- a/sound/pci/hda/patch_conexant.c
+++ b/sound/pci/hda/patch_conexant.c
@@ -304,6 +304,7 @@ static void cxt_fixup_headphone_mic(struct hda_codec *codec,
 	switch (action) {
 	case HDA_FIXUP_ACT_PRE_PROBE:
 		spec->parse_flags |= HDA_PINCFG_HEADPHONE_MIC;
+		snd_hdac_regmap_add_vendor_verb(&codec->core, 0x410);
 		break;
 	case HDA_FIXUP_ACT_PROBE:
 		spec->gen.cap_sync_hook = cxt_update_headset_mode_hook;
@@ -411,15 +412,11 @@ static void olpc_xo_automic(struct hda_codec *codec,
 			    struct hda_jack_callback *jack)
 {
 	struct conexant_spec *spec = codec->spec;
-	int saved_cached_write = codec->cached_write;
 
-	codec->cached_write = 1;
 	/* in DC mode, we don't handle automic */
 	if (!spec->dc_enable)
 		snd_hda_gen_mic_autoswitch(codec, jack);
 	olpc_xo_update_mic_pins(codec);
-	snd_hda_codec_flush_cache(codec);
-	codec->cached_write = saved_cached_write;
 	if (spec->dc_enable)
 		olpc_xo_update_mic_boost(codec);
 }
* Unmerged path sound/pci/hda/patch_hdmi.c
* Unmerged path sound/pci/hda/patch_realtek.c
diff --git a/sound/pci/hda/patch_si3054.c b/sound/pci/hda/patch_si3054.c
index df243134baa8..0a3c2f64bb35 100644
--- a/sound/pci/hda/patch_si3054.c
+++ b/sound/pci/hda/patch_si3054.c
@@ -222,6 +222,10 @@ static int si3054_init(struct hda_codec *codec)
 	unsigned wait_count;
 	u16 val;
 
+	if (snd_hdac_regmap_add_vendor_verb(&codec->core,
+					    SI3054_VERB_WRITE_NODE))
+		return -ENOMEM;
+
 	snd_hda_codec_write(codec, AC_NODE_ROOT, 0, AC_VERB_SET_CODEC_RESET, 0);
 	snd_hda_codec_write(codec, codec->mfg, 0, AC_VERB_SET_STREAM_FORMAT, 0);
 	SET_REG(codec, SI3054_LINE_RATE, 9600);
diff --git a/sound/pci/hda/patch_sigmatel.c b/sound/pci/hda/patch_sigmatel.c
index d94c989bd60d..c9b8df65b13c 100644
--- a/sound/pci/hda/patch_sigmatel.c
+++ b/sound/pci/hda/patch_sigmatel.c
@@ -1048,12 +1048,9 @@ static const struct hda_verb stac92hd71bxx_core_init[] = {
 	{}
 };
 
-static const struct hda_verb stac92hd71bxx_unmute_core_init[] = {
+static const hda_nid_t stac92hd71bxx_unmute_nids[] = {
 	/* unmute right and left channels for nodes 0x0f, 0xa, 0x0d */
-	{ 0x0f, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
-	{ 0x0a, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
-	{ 0x0d, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
-	{}
+	0x0f, 0x0a, 0x0d, 0
 };
 
 static const struct hda_verb stac925x_core_init[] = {
@@ -4265,6 +4262,10 @@ static int stac_parse_auto_config(struct hda_codec *codec)
 
 	if (spec->aloopback_ctl &&
 	    snd_hda_get_bool_hint(codec, "loopback") == 1) {
+		unsigned int wr_verb =
+			spec->aloopback_ctl->private_value >> 16;
+		if (snd_hdac_regmap_add_vendor_verb(&codec->core, wr_verb))
+			return -ENOMEM;
 		if (!snd_hda_gen_add_kctl(&spec->gen, NULL, spec->aloopback_ctl))
 			return -ENOMEM;
 	}
@@ -4682,7 +4683,7 @@ static int patch_stac92hd95(struct hda_codec *codec)
 static int patch_stac92hd71bxx(struct hda_codec *codec)
 {
 	struct sigmatel_spec *spec;
-	const struct hda_verb *unmute_init = stac92hd71bxx_unmute_core_init;
+	const hda_nid_t *unmute_nids = stac92hd71bxx_unmute_nids;
 	int err;
 
 	err = alloc_stac_spec(codec);
@@ -4707,7 +4708,7 @@ static int patch_stac92hd71bxx(struct hda_codec *codec)
 	switch (codec->vendor_id) {
 	case 0x111d76b6: /* 4 Port without Analog Mixer */
 	case 0x111d76b7:
-		unmute_init++;
+		unmute_nids++;
 		break;
 	case 0x111d7608: /* 5 Port with Analog Mixer */
 		if ((codec->revision_id & 0xf) == 0 ||
@@ -4715,7 +4716,7 @@ static int patch_stac92hd71bxx(struct hda_codec *codec)
 			spec->stream_delay = 40; /* 40 milliseconds */
 
 		/* disable VSW */
-		unmute_init++;
+		unmute_nids++;
 		snd_hda_codec_set_pincfg(codec, 0x0f, 0x40f000f0);
 		snd_hda_codec_set_pincfg(codec, 0x19, 0x40f000f3);
 		break;
@@ -4729,8 +4730,12 @@ static int patch_stac92hd71bxx(struct hda_codec *codec)
 	if (get_wcaps_type(get_wcaps(codec, 0x28)) == AC_WID_VOL_KNB)
 		snd_hda_add_verbs(codec, stac92hd71bxx_core_init);
 
-	if (get_wcaps(codec, 0xa) & AC_WCAP_IN_AMP)
-		snd_hda_sequence_write_cache(codec, unmute_init);
+	if (get_wcaps(codec, 0xa) & AC_WCAP_IN_AMP) {
+		const hda_nid_t *p;
+		for (p = unmute_nids; *p; p++)
+			snd_hda_codec_amp_init_stereo(codec, *p, HDA_INPUT, 0,
+						      0xff, 0x00);
+	}
 
 	spec->aloopback_ctl = &stac92hd71bxx_loopback;
 	spec->aloopback_mask = 0x50;
