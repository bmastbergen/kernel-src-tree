scsi: do not decode sense extras

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [scsi] do not decode sense extras (Ewan Milne) [1124082]
Rebuild_FUZZ: 89.66%
commit-author Hannes Reinecke <hare@suse.de>
commit 15c75f8a6d570e1d22594fe7f1cdb45360651a60
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/15c75f8a.failed

Currently we're only decoding sense extras for tape devices.
And even there only for fixed format sense formats.
As this is of rather limited use in the general case we should
be stop trying to decode sense extras; the tape driver does
its own decoding anyway.

	Signed-off-by: Hannes Reinecke <hare@suse.de>
	Reviewed-by: Robert Elliott <elliott@hp.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 15c75f8a6d570e1d22594fe7f1cdb45360651a60)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/constants.c
diff --cc drivers/scsi/constants.c
index 2f447075adbb,94c0642e2874..000000000000
--- a/drivers/scsi/constants.c
+++ b/drivers/scsi/constants.c
@@@ -1429,101 -1436,35 +1429,49 @@@ scsi_print_sense_hdr(const char *name, 
  EXPORT_SYMBOL(scsi_print_sense_hdr);
  
  static void
 -scsi_dump_sense_buffer(const unsigned char *sense_buffer, int sense_len)
 +scsi_decode_sense_buffer(const unsigned char *sense_buffer, int sense_len,
 +		       struct scsi_sense_hdr *sshdr)
  {
 -	int k, num;
 -
 -	num = (sense_len < 32) ? sense_len : 32;
 -	printk("Unrecognized sense data (in hex):");
 -	for (k = 0; k < num; ++k) {
 -		if (0 == (k % 16)) {
 -			printk("\n");
 -			printk(KERN_INFO "        ");
 +	int k, num, res;
 +
 +	res = scsi_normalize_sense(sense_buffer, sense_len, sshdr);
 +	if (0 == res) {
 +		/* this may be SCSI-1 sense data */
 +		num = (sense_len < 32) ? sense_len : 32;
 +		printk("Unrecognized sense data (in hex):");
 +		for (k = 0; k < num; ++k) {
 +			if (0 == (k % 16)) {
 +				printk("\n");
 +				printk(KERN_INFO "        ");
 +			}
 +			printk("%02x ", sense_buffer[k]);
  		}
 -		printk("%02x ", sense_buffer[k]);
 +		printk("\n");
 +		return;
  	}
 -	printk("\n");
 -	return;
  }
  
- static void
- scsi_decode_sense_extras(const unsigned char *sense_buffer, int sense_len,
- 			 struct scsi_sense_hdr *sshdr)
- {
- 	int k, num, res;
- 
- 	if (sshdr->response_code < 0x72)
- 	{
- 		/* only decode extras for "fixed" format now */
- 		char buff[80];
- 		int blen, fixed_valid;
- 		unsigned int info;
- 
- 		fixed_valid = sense_buffer[0] & 0x80;
- 		info = ((sense_buffer[3] << 24) | (sense_buffer[4] << 16) |
- 			(sense_buffer[5] << 8) | sense_buffer[6]);
- 		res = 0;
- 		memset(buff, 0, sizeof(buff));
- 		blen = sizeof(buff) - 1;
- 		if (fixed_valid)
- 			res += snprintf(buff + res, blen - res,
- 					"Info fld=0x%x", info);
- 		if (sense_buffer[2] & 0x80) {
- 			/* current command has read a filemark */
- 			if (res > 0)
- 				res += snprintf(buff + res, blen - res, ", ");
- 			res += snprintf(buff + res, blen - res, "FMK");
- 		}
- 		if (sense_buffer[2] & 0x40) {
- 			/* end-of-medium condition exists */
- 			if (res > 0)
- 				res += snprintf(buff + res, blen - res, ", ");
- 			res += snprintf(buff + res, blen - res, "EOM");
- 		}
- 		if (sense_buffer[2] & 0x20) {
- 			/* incorrect block length requested */
- 			if (res > 0)
- 				res += snprintf(buff + res, blen - res, ", ");
- 			res += snprintf(buff + res, blen - res, "ILI");
- 		}
- 		if (res > 0)
- 			printk("%s\n", buff);
- 	} else if (sshdr->additional_length > 0) {
- 		/* descriptor format with sense descriptors */
- 		num = 8 + sshdr->additional_length;
- 		num = (sense_len < num) ? sense_len : num;
- 		printk("Descriptor sense data with sense descriptors "
- 		       "(in hex):");
- 		for (k = 0; k < num; ++k) {
- 			if (0 == (k % 16)) {
- 				printk("\n");
- 				printk(KERN_INFO "        ");
- 			}
- 			printk("%02x ", sense_buffer[k]);
- 		}
- 
- 		printk("\n");
- 	}
- 
- }
- 
  /* Normalize and print sense buffer with name prefix */
 -void __scsi_print_sense(const struct scsi_device *sdev, const char *name,
 -			const unsigned char *sense_buffer, int sense_len)
 +void __scsi_print_sense(const char *name, const unsigned char *sense_buffer,
 +			int sense_len)
  {
  	struct scsi_sense_hdr sshdr;
  
++<<<<<<< HEAD
 +	printk(KERN_INFO "%s: ", name);
 +	scsi_decode_sense_buffer(sense_buffer, sense_len, &sshdr);
 +	scsi_show_sense_hdr(&sshdr);
 +	scsi_decode_sense_extras(sense_buffer, sense_len, &sshdr);
 +	printk(KERN_INFO "%s: ", name);
 +	scsi_show_extd_sense(sshdr.asc, sshdr.ascq);
++=======
+ 	if (!scsi_normalize_sense(sense_buffer, sense_len, &sshdr)) {
+ 		scsi_dump_sense_buffer(sense_buffer, sense_len);
+ 		return;
+ 	}
+ 	scsi_show_sense_hdr(sdev, name, &sshdr);
+ 	scsi_show_extd_sense(sdev, name, sshdr.asc, sshdr.ascq);
++>>>>>>> 15c75f8a6d57 (scsi: do not decode sense extras)
  }
  EXPORT_SYMBOL(__scsi_print_sense);
  
* Unmerged path drivers/scsi/constants.c
