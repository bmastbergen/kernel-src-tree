d_walk() might skip too much

jira LE-1907
cve CVE-2014-8559
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [fs] dcache: d_walk() might skip too much (Denys Vlasenko) [1173813] {CVE-2014-8559}
Rebuild_FUZZ: 87.50%
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 2159184ea01e4ae7d15f2017e296d4bc82d5aeb0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/2159184e.failed

when we find that a child has died while we'd been trying to ascend,
we should go into the first live sibling itself, rather than its sibling.

Off-by-one in question had been introduced in "deal with deadlock in
d_walk()" and the fix needs to be backported to all branches this one
has been backported to.

	Cc: stable@vger.kernel.org # 3.2 and later
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 2159184ea01e4ae7d15f2017e296d4bc82d5aeb0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dcache.c
diff --cc fs/dcache.c
index 3af919733a87,37b5afdaf698..000000000000
--- a/fs/dcache.c
+++ b/fs/dcache.c
@@@ -1121,18 -1227,31 +1121,29 @@@ resume
  	/*
  	 * All done at this level ... ascend and resume the search.
  	 */
 -	rcu_read_lock();
 -ascend:
  	if (this_parent != parent) {
  		struct dentry *child = this_parent;
 -		this_parent = child->d_parent;
 -
 -		spin_unlock(&child->d_lock);
 -		spin_lock(&this_parent->d_lock);
 -
 -		/* might go back up the wrong parent if we have had a rename. */
 -		if (need_seqretry(&rename_lock, seq))
 +		this_parent = try_to_ascend(this_parent, seq);
 +		if (!this_parent)
  			goto rename_retry;
++<<<<<<< HEAD
 +		next = child->d_u.d_child.next;
++=======
+ 		/* go into the first sibling still alive */
+ 		do {
+ 			next = child->d_child.next;
+ 			if (next == &this_parent->d_subdirs)
+ 				goto ascend;
+ 			child = list_entry(next, struct dentry, d_child);
+ 		} while (unlikely(child->d_flags & DCACHE_DENTRY_KILLED));
+ 		rcu_read_unlock();
++>>>>>>> 2159184ea01e (d_walk() might skip too much)
  		goto resume;
  	}
 -	if (need_seqretry(&rename_lock, seq))
 +	if (need_seqretry(&rename_lock, seq)) {
 +		spin_unlock(&this_parent->d_lock);
  		goto rename_retry;
 -	rcu_read_unlock();
 +	}
  	if (finish)
  		finish(data);
  
* Unmerged path fs/dcache.c
