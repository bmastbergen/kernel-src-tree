iw_cxgb4/cxgb4/cxgb4i: Cleanup register defines/MACROS related to CM CPL messages

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Hariprasad Shenai <hariprasad@chelsio.com>
commit 6c53e938a81c0b31f9f6a31690c3be601aa8fa60
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/6c53e938.failed

This patch cleanups all macros/register define related to connection management
CPL messages that are defined in t4_msg.h and the affected files

	Signed-off-by: Anish Bhatt <anish@chelsio.com>
	Signed-off-by: Hariprasad Shenai <hariprasad@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6c53e938a81c0b31f9f6a31690c3be601aa8fa60)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/cxgb4/cm.c
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
#	drivers/net/ethernet/chelsio/cxgb4/t4_msg.h
diff --cc drivers/infiniband/hw/cxgb4/cm.c
index bd8c0f1864d7,87872795c94f..000000000000
--- a/drivers/infiniband/hw/cxgb4/cm.c
+++ b/drivers/infiniband/hw/cxgb4/cm.c
@@@ -649,31 -649,31 +649,48 @@@ static int send_connect(struct c4iw_ep 
  	 * remainder will be specified in the rx_data_ack.
  	 */
  	win = ep->rcv_win >> 10;
 -	if (win > RCV_BUFSIZ_M)
 -		win = RCV_BUFSIZ_M;
 -
 +	if (win > RCV_BUFSIZ_MASK)
 +		win = RCV_BUFSIZ_MASK;
 +
++<<<<<<< HEAD
 +	opt0 = (nocong ? NO_CONG(1) : 0) |
 +	       KEEP_ALIVE(1) |
 +	       DELACK(1) |
 +	       WND_SCALE(wscale) |
 +	       MSS_IDX(mtu_idx) |
 +	       L2T_IDX(ep->l2t->idx) |
 +	       TX_CHAN(ep->tx_chan) |
 +	       SMAC_SEL(ep->smac_idx) |
 +	       DSCP(ep->tos) |
 +	       ULP_MODE(ULP_MODE_TCPDDP) |
 +	       RCV_BUFSIZ(win);
 +	opt2 = RX_CHANNEL(0) |
 +	       CCTRL_ECN(enable_ecn) |
 +	       RSS_QUEUE_VALID | RSS_QUEUE(ep->rss_qid);
++=======
+ 	opt0 = (nocong ? NO_CONG_F : 0) |
+ 	       KEEP_ALIVE_F |
+ 	       DELACK_F |
+ 	       WND_SCALE_V(wscale) |
+ 	       MSS_IDX_V(mtu_idx) |
+ 	       L2T_IDX_V(ep->l2t->idx) |
+ 	       TX_CHAN_V(ep->tx_chan) |
+ 	       SMAC_SEL_V(ep->smac_idx) |
+ 	       DSCP_V(ep->tos) |
+ 	       ULP_MODE_V(ULP_MODE_TCPDDP) |
+ 	       RCV_BUFSIZ_V(win);
+ 	opt2 = RX_CHANNEL_V(0) |
+ 	       CCTRL_ECN_V(enable_ecn) |
+ 	       RSS_QUEUE_VALID_F | RSS_QUEUE_V(ep->rss_qid);
++>>>>>>> 6c53e938a81c (iw_cxgb4/cxgb4/cxgb4i: Cleanup register defines/MACROS related to CM CPL messages)
  	if (enable_tcp_timestamps)
- 		opt2 |= TSTAMPS_EN(1);
+ 		opt2 |= TSTAMPS_EN_F;
  	if (enable_tcp_sack)
- 		opt2 |= SACK_EN(1);
+ 		opt2 |= SACK_EN_F;
  	if (wscale && enable_tcp_window_scaling)
 -		opt2 |= WND_SCALE_EN_F;
 +		opt2 |= WND_SCALE_EN(1);
  	if (is_t5(ep->com.dev->rdev.lldi.adapter_type)) {
 -		opt2 |= T5_OPT_2_VALID_F;
 +		opt2 |= T5_OPT_2_VALID;
  		opt2 |= V_CONG_CNTRL(CONG_ALG_TAHOE);
  		opt2 |= CONG_CNTRL_VALID; /* OPT_2_ISS for T5 */
  	}
@@@ -1750,8 -1751,8 +1767,13 @@@ static void send_fw_act_open_req(struc
  	skb = get_skb(NULL, sizeof(*req), GFP_KERNEL);
  	req = (struct fw_ofld_connection_wr *)__skb_put(skb, sizeof(*req));
  	memset(req, 0, sizeof(*req));
++<<<<<<< HEAD
 +	req->op_compl = htonl(V_WR_OP(FW_OFLD_CONNECTION_WR));
 +	req->len16_pkd = htonl(FW_WR_LEN16(DIV_ROUND_UP(sizeof(*req), 16)));
++=======
+ 	req->op_compl = htonl(WR_OP_V(FW_OFLD_CONNECTION_WR));
+ 	req->len16_pkd = htonl(FW_WR_LEN16_V(DIV_ROUND_UP(sizeof(*req), 16)));
++>>>>>>> 6c53e938a81c (iw_cxgb4/cxgb4/cxgb4i: Cleanup register defines/MACROS related to CM CPL messages)
  	req->le.filter = cpu_to_be32(cxgb4_select_ntuple(
  				     ep->com.dev->rdev.lldi.ports[0],
  				     ep->l2t));
@@@ -1778,34 -1779,34 +1800,58 @@@
  	 * remainder will be specified in the rx_data_ack.
  	 */
  	win = ep->rcv_win >> 10;
 -	if (win > RCV_BUFSIZ_M)
 -		win = RCV_BUFSIZ_M;
 -
 +	if (win > RCV_BUFSIZ_MASK)
 +		win = RCV_BUFSIZ_MASK;
 +
++<<<<<<< HEAD
 +	req->tcb.opt0 = (__force __be64) (TCAM_BYPASS(1) |
 +		(nocong ? NO_CONG(1) : 0) |
 +		KEEP_ALIVE(1) |
 +		DELACK(1) |
 +		WND_SCALE(wscale) |
 +		MSS_IDX(mtu_idx) |
 +		L2T_IDX(ep->l2t->idx) |
 +		TX_CHAN(ep->tx_chan) |
 +		SMAC_SEL(ep->smac_idx) |
 +		DSCP(ep->tos) |
 +		ULP_MODE(ULP_MODE_TCPDDP) |
 +		RCV_BUFSIZ(win));
 +	req->tcb.opt2 = (__force __be32) (PACE(1) |
 +		TX_QUEUE(ep->com.dev->rdev.lldi.tx_modq[ep->tx_chan]) |
 +		RX_CHANNEL(0) |
 +		CCTRL_ECN(enable_ecn) |
 +		RSS_QUEUE_VALID | RSS_QUEUE(ep->rss_qid));
 +	if (enable_tcp_timestamps)
 +		req->tcb.opt2 |= (__force __be32) TSTAMPS_EN(1);
 +	if (enable_tcp_sack)
 +		req->tcb.opt2 |= (__force __be32) SACK_EN(1);
++=======
+ 	req->tcb.opt0 = (__force __be64) (TCAM_BYPASS_F |
+ 		(nocong ? NO_CONG_F : 0) |
+ 		KEEP_ALIVE_F |
+ 		DELACK_F |
+ 		WND_SCALE_V(wscale) |
+ 		MSS_IDX_V(mtu_idx) |
+ 		L2T_IDX_V(ep->l2t->idx) |
+ 		TX_CHAN_V(ep->tx_chan) |
+ 		SMAC_SEL_V(ep->smac_idx) |
+ 		DSCP_V(ep->tos) |
+ 		ULP_MODE_V(ULP_MODE_TCPDDP) |
+ 		RCV_BUFSIZ_V(win));
+ 	req->tcb.opt2 = (__force __be32) (PACE_V(1) |
+ 		TX_QUEUE_V(ep->com.dev->rdev.lldi.tx_modq[ep->tx_chan]) |
+ 		RX_CHANNEL_V(0) |
+ 		CCTRL_ECN_V(enable_ecn) |
+ 		RSS_QUEUE_VALID_F | RSS_QUEUE_V(ep->rss_qid));
+ 	if (enable_tcp_timestamps)
+ 		req->tcb.opt2 |= (__force __be32)TSTAMPS_EN_F;
+ 	if (enable_tcp_sack)
+ 		req->tcb.opt2 |= (__force __be32)SACK_EN_F;
++>>>>>>> 6c53e938a81c (iw_cxgb4/cxgb4/cxgb4i: Cleanup register defines/MACROS related to CM CPL messages)
  	if (wscale && enable_tcp_window_scaling)
 -		req->tcb.opt2 |= (__force __be32)WND_SCALE_EN_F;
 -	req->tcb.opt0 = cpu_to_be64((__force u64)req->tcb.opt0);
 -	req->tcb.opt2 = cpu_to_be32((__force u32)req->tcb.opt2);
 +		req->tcb.opt2 |= (__force __be32) WND_SCALE_EN(1);
 +	req->tcb.opt0 = cpu_to_be64((__force u64) req->tcb.opt0);
 +	req->tcb.opt2 = cpu_to_be32((__force u32) req->tcb.opt2);
  	set_wr_txq(skb, CPL_PRIORITY_CONTROL, ep->ctrlq_idx);
  	set_bit(ACT_OFLD_CONN, &ep->com.history);
  	c4iw_l2t_send(&ep->com.dev->rdev, skb, ep->l2t);
@@@ -2177,28 -2179,28 +2223,46 @@@ static void accept_cr(struct c4iw_ep *e
  	 * remainder will be specified in the rx_data_ack.
  	 */
  	win = ep->rcv_win >> 10;
++<<<<<<< HEAD
 +	if (win > RCV_BUFSIZ_MASK)
 +		win = RCV_BUFSIZ_MASK;
 +	opt0 = (nocong ? NO_CONG(1) : 0) |
 +	       KEEP_ALIVE(1) |
 +	       DELACK(1) |
 +	       WND_SCALE(wscale) |
 +	       MSS_IDX(mtu_idx) |
 +	       L2T_IDX(ep->l2t->idx) |
 +	       TX_CHAN(ep->tx_chan) |
 +	       SMAC_SEL(ep->smac_idx) |
 +	       DSCP(ep->tos >> 2) |
 +	       ULP_MODE(ULP_MODE_TCPDDP) |
 +	       RCV_BUFSIZ(win);
 +	opt2 = RX_CHANNEL(0) |
 +	       RSS_QUEUE_VALID | RSS_QUEUE(ep->rss_qid);
++=======
+ 	if (win > RCV_BUFSIZ_M)
+ 		win = RCV_BUFSIZ_M;
+ 	opt0 = (nocong ? NO_CONG_F : 0) |
+ 	       KEEP_ALIVE_F |
+ 	       DELACK_F |
+ 	       WND_SCALE_V(wscale) |
+ 	       MSS_IDX_V(mtu_idx) |
+ 	       L2T_IDX_V(ep->l2t->idx) |
+ 	       TX_CHAN_V(ep->tx_chan) |
+ 	       SMAC_SEL_V(ep->smac_idx) |
+ 	       DSCP_V(ep->tos >> 2) |
+ 	       ULP_MODE_V(ULP_MODE_TCPDDP) |
+ 	       RCV_BUFSIZ_V(win);
+ 	opt2 = RX_CHANNEL_V(0) |
+ 	       RSS_QUEUE_VALID_F | RSS_QUEUE_V(ep->rss_qid);
++>>>>>>> 6c53e938a81c (iw_cxgb4/cxgb4/cxgb4i: Cleanup register defines/MACROS related to CM CPL messages)
  
  	if (enable_tcp_timestamps && req->tcpopt.tstamp)
- 		opt2 |= TSTAMPS_EN(1);
+ 		opt2 |= TSTAMPS_EN_F;
  	if (enable_tcp_sack && req->tcpopt.sack)
- 		opt2 |= SACK_EN(1);
+ 		opt2 |= SACK_EN_F;
  	if (wscale && enable_tcp_window_scaling)
 -		opt2 |= WND_SCALE_EN_F;
 +		opt2 |= WND_SCALE_EN(1);
  	if (enable_ecn) {
  		const struct tcphdr *tcph;
  		u32 hlen = ntohl(req->hdr_len);
@@@ -3536,9 -3542,9 +3600,15 @@@ static void send_fw_pass_open_req(struc
  	req_skb = alloc_skb(sizeof(struct fw_ofld_connection_wr), GFP_KERNEL);
  	req = (struct fw_ofld_connection_wr *)__skb_put(req_skb, sizeof(*req));
  	memset(req, 0, sizeof(*req));
++<<<<<<< HEAD
 +	req->op_compl = htonl(V_WR_OP(FW_OFLD_CONNECTION_WR) | FW_WR_COMPL(1));
 +	req->len16_pkd = htonl(FW_WR_LEN16(DIV_ROUND_UP(sizeof(*req), 16)));
 +	req->le.version_cpl = htonl(F_FW_OFLD_CONNECTION_WR_CPL);
++=======
+ 	req->op_compl = htonl(WR_OP_V(FW_OFLD_CONNECTION_WR) | FW_WR_COMPL_F);
+ 	req->len16_pkd = htonl(FW_WR_LEN16_V(DIV_ROUND_UP(sizeof(*req), 16)));
+ 	req->le.version_cpl = htonl(FW_OFLD_CONNECTION_WR_CPL_F);
++>>>>>>> 6c53e938a81c (iw_cxgb4/cxgb4/cxgb4i: Cleanup register defines/MACROS related to CM CPL messages)
  	req->le.filter = (__force __be32) filter;
  	req->le.lport = lport;
  	req->le.pport = rport;
@@@ -3547,10 -3553,10 +3617,17 @@@
  	req->tcb.rcv_nxt = htonl(rcv_isn + 1);
  	req->tcb.rcv_adv = htons(window);
  	req->tcb.t_state_to_astid =
++<<<<<<< HEAD
 +		 htonl(V_FW_OFLD_CONNECTION_WR_T_STATE(TCP_SYN_RECV) |
 +			V_FW_OFLD_CONNECTION_WR_RCV_SCALE(cpl->tcpopt.wsf) |
 +			V_FW_OFLD_CONNECTION_WR_ASTID(
 +			GET_PASS_OPEN_TID(ntohl(cpl->tos_stid))));
++=======
+ 		 htonl(FW_OFLD_CONNECTION_WR_T_STATE_V(TCP_SYN_RECV) |
+ 			FW_OFLD_CONNECTION_WR_RCV_SCALE_V(cpl->tcpopt.wsf) |
+ 			FW_OFLD_CONNECTION_WR_ASTID_V(
+ 			PASS_OPEN_TID_G(ntohl(cpl->tos_stid))));
++>>>>>>> 6c53e938a81c (iw_cxgb4/cxgb4/cxgb4i: Cleanup register defines/MACROS related to CM CPL messages)
  
  	/*
  	 * We store the qid in opt2 which will be used by the firmware
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
index eacea363ec4e,2897f956bb21..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@@ -3412,9 -3415,9 +3412,15 @@@ int cxgb4_create_server(const struct ne
  	req->local_ip = sip;
  	req->peer_ip = htonl(0);
  	chan = rxq_to_chan(&adap->sge, queue);
++<<<<<<< HEAD
 +	req->opt0 = cpu_to_be64(TX_CHAN(chan));
 +	req->opt1 = cpu_to_be64(CONN_POLICY_ASK |
 +				SYN_RSS_ENABLE | SYN_RSS_QUEUE(queue));
++=======
+ 	req->opt0 = cpu_to_be64(TX_CHAN_V(chan));
+ 	req->opt1 = cpu_to_be64(CONN_POLICY_V(CPL_CONN_POLICY_ASK) |
+ 				SYN_RSS_ENABLE_F | SYN_RSS_QUEUE_V(queue));
++>>>>>>> 6c53e938a81c (iw_cxgb4/cxgb4/cxgb4i: Cleanup register defines/MACROS related to CM CPL messages)
  	ret = t4_mgmt_tx(adap, skb);
  	return net_xmit_eval(ret);
  }
@@@ -3455,9 -3458,9 +3461,15 @@@ int cxgb4_create_server6(const struct n
  	req->peer_ip_hi = cpu_to_be64(0);
  	req->peer_ip_lo = cpu_to_be64(0);
  	chan = rxq_to_chan(&adap->sge, queue);
++<<<<<<< HEAD
 +	req->opt0 = cpu_to_be64(TX_CHAN(chan));
 +	req->opt1 = cpu_to_be64(CONN_POLICY_ASK |
 +				SYN_RSS_ENABLE | SYN_RSS_QUEUE(queue));
++=======
+ 	req->opt0 = cpu_to_be64(TX_CHAN_V(chan));
+ 	req->opt1 = cpu_to_be64(CONN_POLICY_V(CPL_CONN_POLICY_ASK) |
+ 				SYN_RSS_ENABLE_F | SYN_RSS_QUEUE_V(queue));
++>>>>>>> 6c53e938a81c (iw_cxgb4/cxgb4/cxgb4i: Cleanup register defines/MACROS related to CM CPL messages)
  	ret = t4_mgmt_tx(adap, skb);
  	return net_xmit_eval(ret);
  }
diff --cc drivers/net/ethernet/chelsio/cxgb4/t4_msg.h
index 5f4db2398c71,15e72063fc95..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/t4_msg.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4_msg.h
@@@ -224,26 -289,42 +243,59 @@@ struct cpl_pass_open_req 
  	__be32 local_ip;
  	__be32 peer_ip;
  	__be64 opt0;
++<<<<<<< HEAD
 +#define TX_CHAN(x)    ((x) << 2)
 +#define NO_CONG(x)    ((x) << 4)
 +#define DELACK(x)     ((x) << 5)
 +#define ULP_MODE(x)   ((x) << 8)
 +#define RCV_BUFSIZ(x) ((x) << 12)
 +#define RCV_BUFSIZ_MASK 0x3FFU
 +#define DSCP(x)       ((x) << 22)
 +#define SMAC_SEL(x)   ((u64)(x) << 28)
 +#define L2T_IDX(x)    ((u64)(x) << 36)
 +#define TCAM_BYPASS(x) ((u64)(x) << 48)
 +#define NAGLE(x)      ((u64)(x) << 49)
 +#define WND_SCALE(x)  ((u64)(x) << 50)
 +#define KEEP_ALIVE(x) ((u64)(x) << 54)
 +#define MSS_IDX(x)    ((u64)(x) << 60)
++=======
++>>>>>>> 6c53e938a81c (iw_cxgb4/cxgb4/cxgb4i: Cleanup register defines/MACROS related to CM CPL messages)
  	__be64 opt1;
- #define SYN_RSS_ENABLE   (1 << 0)
- #define SYN_RSS_QUEUE(x) ((x) << 2)
- #define CONN_POLICY_ASK  (1 << 22)
  };
  
+ /* option 0 fields */
+ #define NO_CONG_S    4
+ #define NO_CONG_V(x) ((x) << NO_CONG_S)
+ #define NO_CONG_F    NO_CONG_V(1U)
+ 
+ #define DELACK_S    5
+ #define DELACK_V(x) ((x) << DELACK_S)
+ #define DELACK_F    DELACK_V(1U)
+ 
+ #define DSCP_S    22
+ #define DSCP_M    0x3F
+ #define DSCP_V(x) ((x) << DSCP_S)
+ #define DSCP_G(x) (((x) >> DSCP_S) & DSCP_M)
+ 
+ #define TCAM_BYPASS_S    48
+ #define TCAM_BYPASS_V(x) ((__u64)(x) << TCAM_BYPASS_S)
+ #define TCAM_BYPASS_F    TCAM_BYPASS_V(1ULL)
+ 
+ #define NAGLE_S    49
+ #define NAGLE_V(x) ((__u64)(x) << NAGLE_S)
+ #define NAGLE_F    NAGLE_V(1ULL)
+ 
+ /* option 1 fields */
+ #define SYN_RSS_ENABLE_S    0
+ #define SYN_RSS_ENABLE_V(x) ((x) << SYN_RSS_ENABLE_S)
+ #define SYN_RSS_ENABLE_F    SYN_RSS_ENABLE_V(1U)
+ 
+ #define SYN_RSS_QUEUE_S    2
+ #define SYN_RSS_QUEUE_V(x) ((x) << SYN_RSS_QUEUE_S)
+ 
+ #define CONN_POLICY_S    22
+ #define CONN_POLICY_V(x) ((x) << CONN_POLICY_S)
+ 
  struct cpl_pass_open_req6 {
  	WR_HDR;
  	union opcode_tid ot;
@@@ -267,20 -348,6 +319,23 @@@ struct cpl_pass_accept_rpl 
  	WR_HDR;
  	union opcode_tid ot;
  	__be32 opt2;
++<<<<<<< HEAD
 +#define RSS_QUEUE(x)         ((x) << 0)
 +#define RSS_QUEUE_VALID      (1 << 10)
 +#define RX_COALESCE_VALID(x) ((x) << 11)
 +#define RX_COALESCE(x)       ((x) << 12)
 +#define PACE(x)	      ((x) << 16)
 +#define RX_FC_VALID	     ((1U) << 19)
 +#define RX_FC_DISABLE	     ((1U) << 20)
 +#define TX_QUEUE(x)          ((x) << 23)
 +#define RX_CHANNEL(x)        ((x) << 26)
 +#define CCTRL_ECN(x)         ((x) << 27)
 +#define WND_SCALE_EN(x)      ((x) << 28)
 +#define TSTAMPS_EN(x)        ((x) << 29)
 +#define SACK_EN(x)           ((x) << 30)
 +#define T5_OPT_2_VALID	     ((1U) << 31)
++=======
++>>>>>>> 6c53e938a81c (iw_cxgb4/cxgb4/cxgb4i: Cleanup register defines/MACROS related to CM CPL messages)
  	__be64 opt0;
  };
  
* Unmerged path drivers/infiniband/hw/cxgb4/cm.c
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
diff --git a/drivers/net/ethernet/chelsio/cxgb4/l2t.c b/drivers/net/ethernet/chelsio/cxgb4/l2t.c
index 96041397ee15..3133384054cf 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/l2t.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/l2t.c
@@ -150,7 +150,7 @@ static int write_l2e(struct adapter *adap, struct l2t_entry *e, int sync)
 
 	OPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_L2T_WRITE_REQ,
 					e->idx | (sync ? F_SYNC_WR : 0) |
-					TID_QID(adap->sge.fw_evtq.abs_id)));
+					TID_QID_V(adap->sge.fw_evtq.abs_id)));
 	req->params = htons(L2T_W_PORT(e->lport) | L2T_W_NOREPLY(!sync));
 	req->l2t_idx = htons(e->idx);
 	req->vlan = htons(e->vlan);
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/t4_msg.h
diff --git a/drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c b/drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c
index 0b0c9434b272..1e3756bc8a63 100644
--- a/drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c
@@ -417,7 +417,7 @@ static int fwevtq_handler(struct sge_rspq *rspq, const __be64 *rsp,
 		/* FW can send EGR_UPDATEs encapsulated in a CPL_FW4_MSG.
 		 */
 		const struct cpl_sge_egr_update *p = (void *)(rsp + 3);
-		opcode = G_CPL_OPCODE(ntohl(p->opcode_qid));
+		opcode = CPL_OPCODE_G(ntohl(p->opcode_qid));
 		if (opcode != CPL_SGE_EGR_UPDATE) {
 			dev_err(adapter->pdev_dev, "unexpected FW4/CPL %#x on FW event queue\n"
 				, opcode);
diff --git a/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c b/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c
index 626b1b374c9d..557cc0219834 100644
--- a/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c
+++ b/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c
@@ -701,7 +701,7 @@ static void do_act_establish(struct cxgbi_device *cdev, struct sk_buff *skb)
 	struct cpl_act_establish *req = (struct cpl_act_establish *)skb->data;
 	unsigned short tcp_opt = ntohs(req->tcp_opt);
 	unsigned int tid = GET_TID(req);
-	unsigned int atid = GET_TID_TID(ntohl(req->tos_atid));
+	unsigned int atid = TID_TID_G(ntohl(req->tos_atid));
 	struct cxgb4_lld_info *lldi = cxgbi_cdev_priv(cdev);
 	struct tid_info *t = lldi->tids;
 	u32 rcv_isn = be32_to_cpu(req->rcv_isn);
@@ -749,15 +749,15 @@ static void do_act_establish(struct cxgbi_device *cdev, struct sk_buff *skb)
 	if (cxgb4i_rcv_win > (RCV_BUFSIZ_MASK << 10))
 		csk->rcv_wup -= cxgb4i_rcv_win - (RCV_BUFSIZ_MASK << 10);
 
-	csk->advmss = lldi->mtus[GET_TCPOPT_MSS(tcp_opt)] - 40;
-	if (GET_TCPOPT_TSTAMP(tcp_opt))
+	csk->advmss = lldi->mtus[TCPOPT_MSS_G(tcp_opt)] - 40;
+	if (TCPOPT_TSTAMP_G(tcp_opt))
 		csk->advmss -= 12;
 	if (csk->advmss < 128)
 		csk->advmss = 128;
 
 	log_debug(1 << CXGBI_DBG_TOE | 1 << CXGBI_DBG_SOCK,
 		"csk 0x%p, mss_idx %u, advmss %u.\n",
-			csk, GET_TCPOPT_MSS(tcp_opt), csk->advmss);
+			csk, TCPOPT_MSS_G(tcp_opt), csk->advmss);
 
 	cxgbi_sock_established(csk, ntohl(req->snd_isn), ntohs(req->tcp_opt));
 
@@ -853,8 +853,8 @@ static void do_act_open_rpl(struct cxgbi_device *cdev, struct sk_buff *skb)
 	struct cpl_act_open_rpl *rpl = (struct cpl_act_open_rpl *)skb->data;
 	unsigned int tid = GET_TID(rpl);
 	unsigned int atid =
-		GET_TID_TID(GET_AOPEN_ATID(be32_to_cpu(rpl->atid_status)));
-	unsigned int status = GET_AOPEN_STATUS(be32_to_cpu(rpl->atid_status));
+		TID_TID_G(AOPEN_ATID_G(be32_to_cpu(rpl->atid_status)));
+	unsigned int status = AOPEN_STATUS_G(be32_to_cpu(rpl->atid_status));
 	struct cxgb4_lld_info *lldi = cxgbi_cdev_priv(cdev);
 	struct tid_info *t = lldi->tids;
 
