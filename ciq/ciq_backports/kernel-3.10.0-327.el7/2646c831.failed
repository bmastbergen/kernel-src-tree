tcp: RFC7413 option support for Fast Open client

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Daniel Lee <Longinus00@gmail.com>
commit 2646c831c00c5d22aa72b79d24069c1b412cda7c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/2646c831.failed

Fast Open has been using an experimental option with a magic number
(RFC6994). This patch makes the client by default use the RFC7413
option (34) to get and send Fast Open cookies.  This patch makes
the client solicit cookies from a given server first with the
RFC7413 option. If that fails to elicit a cookie, then it tries
the RFC6994 experimental option. If that also fails, it uses the
RFC7413 option on all subsequent connect attempts.  If the server
returns a Fast Open cookie then the client caches the form of the
option that successfully elicited a cookie, and uses that form on
later connects when it presents that cookie.

The idea is to gradually obsolete the use of experimental options as
the servers and clients upgrade, while keeping the interoperability
meanwhile.

	Signed-off-by: Daniel Lee <Longinus00@gmail.com>
	Signed-off-by: Yuchung Cheng <ycheng@google.com>
	Signed-off-by: Neal Cardwell <ncardwell@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2646c831c00c5d22aa72b79d24069c1b412cda7c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/tcp.h
#	include/net/tcp.h
diff --cc include/linux/tcp.h
index 0ea024b94b21,0caa3a2d4106..000000000000
--- a/include/linux/tcp.h
+++ b/include/linux/tcp.h
@@@ -199,7 -189,9 +199,13 @@@ struct tcp_sock 
  	u8	do_early_retrans:1,/* Enable RFC5827 early-retransmit  */
  		syn_data:1,	/* SYN includes data */
  		syn_fastopen:1,	/* SYN includes Fast Open option */
++<<<<<<< HEAD
 +		syn_data_acked:1;/* data in SYN is acked by SYN-ACK */
++=======
+ 		syn_fastopen_exp:1,/* SYN includes Fast Open exp. option */
+ 		syn_data_acked:1,/* data in SYN is acked by SYN-ACK */
+ 		is_cwnd_limited:1;/* forward progress limited by snd_cwnd? */
++>>>>>>> 2646c831c00c (tcp: RFC7413 option support for Fast Open client)
  	u32	tlp_high_seq;	/* snd_nxt at the time of TLP retransmit. */
  
  /* RTT measurement */
diff --cc include/net/tcp.h
index aff4173509ce,9598871485ce..000000000000
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@@ -1302,19 -1328,19 +1302,28 @@@ static inline void tcp_put_md5sig_pool(
  	local_bh_enable();
  }
  
 -int tcp_md5_hash_header(struct tcp_md5sig_pool *, const struct tcphdr *);
 -int tcp_md5_hash_skb_data(struct tcp_md5sig_pool *, const struct sk_buff *,
 -			  unsigned int header_len);
 -int tcp_md5_hash_key(struct tcp_md5sig_pool *hp,
 -		     const struct tcp_md5sig_key *key);
 +extern int tcp_md5_hash_header(struct tcp_md5sig_pool *, const struct tcphdr *);
 +extern int tcp_md5_hash_skb_data(struct tcp_md5sig_pool *, const struct sk_buff *,
 +				 unsigned int header_len);
 +extern int tcp_md5_hash_key(struct tcp_md5sig_pool *hp,
 +			    const struct tcp_md5sig_key *key);
  
  /* From tcp_fastopen.c */
++<<<<<<< HEAD
 +extern void tcp_fastopen_cache_get(struct sock *sk, u16 *mss,
 +				   struct tcp_fastopen_cookie *cookie,
 +				   int *syn_loss, unsigned long *last_syn_loss);
 +extern void tcp_fastopen_cache_set(struct sock *sk, u16 mss,
 +				   struct tcp_fastopen_cookie *cookie,
 +				   bool syn_lost);
++=======
+ void tcp_fastopen_cache_get(struct sock *sk, u16 *mss,
+ 			    struct tcp_fastopen_cookie *cookie, int *syn_loss,
+ 			    unsigned long *last_syn_loss);
+ void tcp_fastopen_cache_set(struct sock *sk, u16 mss,
+ 			    struct tcp_fastopen_cookie *cookie, bool syn_lost,
+ 			    u16 try_exp);
++>>>>>>> 2646c831c00c (tcp: RFC7413 option support for Fast Open client)
  struct tcp_fastopen_request {
  	/* Fast Open cookie. Size 0 means a cookie request */
  	struct tcp_fastopen_cookie	cookie;
* Unmerged path include/linux/tcp.h
* Unmerged path include/net/tcp.h
diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
index ef845c96b4d4..75c94413bbf6 100644
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -5297,8 +5297,8 @@ static bool tcp_rcv_fastopen_synack(struct sock *sk, struct sk_buff *synack,
 {
 	struct tcp_sock *tp = tcp_sk(sk);
 	struct sk_buff *data = tp->syn_data ? tcp_write_queue_head(sk) : NULL;
-	u16 mss = tp->rx_opt.mss_clamp;
-	bool syn_drop;
+	u16 mss = tp->rx_opt.mss_clamp, try_exp = 0;
+	bool syn_drop = false;
 
 	if (mss == tp->rx_opt.user_mss) {
 		struct tcp_options_received opt;
@@ -5310,16 +5310,25 @@ static bool tcp_rcv_fastopen_synack(struct sock *sk, struct sk_buff *synack,
 		mss = opt.mss_clamp;
 	}
 
-	if (!tp->syn_fastopen)  /* Ignore an unsolicited cookie */
+	if (!tp->syn_fastopen) {
+		/* Ignore an unsolicited cookie */
 		cookie->len = -1;
+	} else if (tp->total_retrans) {
+		/* SYN timed out and the SYN-ACK neither has a cookie nor
+		 * acknowledges data. Presumably the remote received only
+		 * the retransmitted (regular) SYNs: either the original
+		 * SYN-data or the corresponding SYN-ACK was dropped.
+		 */
+		syn_drop = (cookie->len < 0 && data);
+	} else if (cookie->len < 0 && !tp->syn_data) {
+		/* We requested a cookie but didn't get it. If we did not use
+		 * the (old) exp opt format then try so next time (try_exp=1).
+		 * Otherwise we go back to use the RFC7413 opt (try_exp=2).
+		 */
+		try_exp = tp->syn_fastopen_exp ? 2 : 1;
+	}
 
-	/* The SYN-ACK neither has cookie nor acknowledges the data. Presumably
-	 * the remote receives only the retransmitted (regular) SYNs: either
-	 * the original SYN-data or the corresponding SYN-ACK is lost.
-	 */
-	syn_drop = (cookie->len <= 0 && data && tp->total_retrans);
-
-	tcp_fastopen_cache_set(sk, mss, cookie, syn_drop);
+	tcp_fastopen_cache_set(sk, mss, cookie, syn_drop, try_exp);
 
 	if (data) { /* Retransmit unacked data in SYN */
 		tcp_for_write_queue_from(data, sk) {
diff --git a/net/ipv4/tcp_metrics.c b/net/ipv4/tcp_metrics.c
index 8f0699bcdb4b..b930ae7daa61 100644
--- a/net/ipv4/tcp_metrics.c
+++ b/net/ipv4/tcp_metrics.c
@@ -24,7 +24,8 @@ int sysctl_tcp_nometrics_save __read_mostly;
 
 struct tcp_fastopen_metrics {
 	u16	mss;
-	u16	syn_loss:10;		/* Recurring Fast Open SYN losses */
+	u16	syn_loss:10,		/* Recurring Fast Open SYN losses */
+		try_exp:2;		/* Request w/ exp. option (once) */
 	unsigned long	last_syn_loss;	/* Last Fast Open SYN loss */
 	struct	tcp_fastopen_cookie	cookie;
 };
@@ -127,6 +128,8 @@ static void tcpm_suck_dst(struct tcp_metrics_block *tm, struct dst_entry *dst,
 	if (fastopen_clear) {
 		tm->tcpm_fastopen.mss = 0;
 		tm->tcpm_fastopen.syn_loss = 0;
+		tm->tcpm_fastopen.try_exp = 0;
+		tm->tcpm_fastopen.cookie.exp = false;
 		tm->tcpm_fastopen.cookie.len = 0;
 	}
 }
@@ -685,6 +688,8 @@ void tcp_fastopen_cache_get(struct sock *sk, u16 *mss,
 			if (tfom->mss)
 				*mss = tfom->mss;
 			*cookie = tfom->cookie;
+			if (cookie->len <= 0 && tfom->try_exp == 1)
+				cookie->exp = true;
 			*syn_loss = tfom->syn_loss;
 			*last_syn_loss = *syn_loss ? tfom->last_syn_loss : 0;
 		} while (read_seqretry(&fastopen_seqlock, seq));
@@ -693,7 +698,8 @@ void tcp_fastopen_cache_get(struct sock *sk, u16 *mss,
 }
 
 void tcp_fastopen_cache_set(struct sock *sk, u16 mss,
-			    struct tcp_fastopen_cookie *cookie, bool syn_lost)
+			    struct tcp_fastopen_cookie *cookie, bool syn_lost,
+			    u16 try_exp)
 {
 	struct dst_entry *dst = __sk_dst_get(sk);
 	struct tcp_metrics_block *tm;
@@ -710,6 +716,9 @@ void tcp_fastopen_cache_set(struct sock *sk, u16 mss,
 			tfom->mss = mss;
 		if (cookie && cookie->len > 0)
 			tfom->cookie = *cookie;
+		else if (try_exp > tfom->try_exp &&
+			 tfom->cookie.len <= 0 && !tfom->cookie.exp)
+			tfom->try_exp = try_exp;
 		if (syn_lost) {
 			++tfom->syn_loss;
 			tfom->last_syn_loss = jiffies;
diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c
index 074c9a68acbd..22b7c281038a 100644
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@ -563,13 +563,17 @@ static unsigned int tcp_syn_options(struct sock *sk, struct sk_buff *skb,
 	}
 
 	if (fastopen && fastopen->cookie.len >= 0) {
-		u32 need = TCPOLEN_EXP_FASTOPEN_BASE + fastopen->cookie.len;
+		u32 need = fastopen->cookie.len;
+
+		need += fastopen->cookie.exp ? TCPOLEN_EXP_FASTOPEN_BASE :
+					       TCPOLEN_FASTOPEN_BASE;
 		need = (need + 3) & ~3U;  /* Align to 32 bits */
 		if (remaining >= need) {
 			opts->options |= OPTION_FAST_OPEN_COOKIE;
 			opts->fastopen_cookie = &fastopen->cookie;
 			remaining -= need;
 			tp->syn_fastopen = 1;
+			tp->syn_fastopen_exp = fastopen->cookie.exp ? 1 : 0;
 		}
 	}
 
diff --git a/net/ipv4/tcp_timer.c b/net/ipv4/tcp_timer.c
index 65aaf75e8299..ea3f31ffd5f0 100644
--- a/net/ipv4/tcp_timer.c
+++ b/net/ipv4/tcp_timer.c
@@ -164,7 +164,7 @@ static int tcp_write_timeout(struct sock *sk)
 		if (icsk->icsk_retransmits) {
 			dst_negative_advice(sk);
 			if (tp->syn_fastopen || tp->syn_data)
-				tcp_fastopen_cache_set(sk, 0, NULL, true);
+				tcp_fastopen_cache_set(sk, 0, NULL, true, 0);
 			if (tp->syn_data)
 				NET_INC_STATS_BH(sock_net(sk),
 						 LINUX_MIB_TCPFASTOPENACTIVEFAIL);
