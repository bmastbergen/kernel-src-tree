bonding: convert IS_UP(slave->dev) to inline function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Veaceslav Falico <vfalico@gmail.com>
commit b6adc610f183061bd607d965857870e618d229a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/b6adc610.failed

Also, remove the IFF_UP verification cause we can't be netif_running() with
being also IFF_UP.

CC: Jay Vosburgh <j.vosburgh@gmail.com>
CC: Andy Gospodarek <andy@greyhouse.net>
	Signed-off-by: Veaceslav Falico <vfalico@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b6adc610f183061bd607d965857870e618d229a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_3ad.c
#	drivers/net/bonding/bond_main.c
#	drivers/net/bonding/bond_options.c
#	drivers/net/bonding/bonding.h
diff --cc drivers/net/bonding/bond_3ad.c
index dc508c87249d,7997a1e7cfd0..000000000000
--- a/drivers/net/bonding/bond_3ad.c
+++ b/drivers/net/bonding/bond_3ad.c
@@@ -236,8 -192,8 +236,13 @@@ static inline void __enable_port(struc
  {
  	struct slave *slave = port->slave;
  
++<<<<<<< HEAD
 +	if ((slave->link == BOND_LINK_UP) && IS_UP(slave->dev))
 +		bond_set_slave_active_flags(slave);
++=======
+ 	if ((slave->link == BOND_LINK_UP) && bond_slave_is_up(slave))
+ 		bond_set_slave_active_flags(slave, BOND_SLAVE_NOTIFY_LATER);
++>>>>>>> b6adc610f183 (bonding: convert IS_UP(slave->dev) to inline function)
  }
  
  /**
diff --cc drivers/net/bonding/bond_main.c
index d0eec7c786f0,db323e6cb314..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -960,39 -736,21 +960,49 @@@ static bool bond_should_change_active(s
   */
  static struct slave *bond_find_best_slave(struct bonding *bond)
  {
 -	struct slave *slave, *bestslave = NULL;
 -	struct list_head *iter;
 +	struct slave *new_active, *old_active;
 +	struct slave *bestslave = NULL;
  	int mintime = bond->params.updelay;
 +	int i;
 +
 +	new_active = bond->curr_active_slave;
  
 -	if (bond->primary_slave && bond->primary_slave->link == BOND_LINK_UP &&
 -	    bond_should_change_active(bond))
 -		return bond->primary_slave;
++<<<<<<< HEAD
 +	if (!new_active) { /* there were no active slaves left */
 +		if (bond->slave_cnt > 0)   /* found one slave */
 +			new_active = bond->first_slave;
 +		else
 +			return NULL; /* still no slave, return NULL */
 +	}
 +
 +	if ((bond->primary_slave) &&
 +	    bond->primary_slave->link == BOND_LINK_UP &&
 +	    bond_should_change_active(bond)) {
 +		new_active = bond->primary_slave;
 +	}
  
 +	/* remember where to stop iterating over the slaves */
 +	old_active = new_active;
 +
 +	bond_for_each_slave_from(bond, new_active, i, old_active) {
 +		if (new_active->link == BOND_LINK_UP) {
 +			return new_active;
 +		} else if (new_active->link == BOND_LINK_BACK &&
 +			   IS_UP(new_active->dev)) {
 +			/* link up, but waiting for stabilization */
 +			if (new_active->delay < mintime) {
 +				mintime = new_active->delay;
 +				bestslave = new_active;
 +			}
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
+ 		if (slave->link == BOND_LINK_UP)
+ 			return slave;
+ 		if (slave->link == BOND_LINK_BACK && bond_slave_is_up(slave) &&
+ 		    slave->delay < mintime) {
+ 			mintime = slave->delay;
+ 			bestslave = slave;
++>>>>>>> b6adc610f183 (bonding: convert IS_UP(slave->dev) to inline function)
  		}
  	}
  
@@@ -1242,11 -954,11 +1252,16 @@@ static void bond_poll_controller(struc
  static void bond_netpoll_cleanup(struct net_device *bond_dev)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
 -	struct list_head *iter;
  	struct slave *slave;
 +	int i;
  
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i)
 +		if (IS_UP(slave->dev))
++=======
+ 	bond_for_each_slave(bond, slave, iter)
+ 		if (bond_slave_is_up(slave))
++>>>>>>> b6adc610f183 (bonding: convert IS_UP(slave->dev) to inline function)
  			slave_disable_netpoll(slave);
  }
  
@@@ -2954,25 -2703,20 +2969,34 @@@ static void bond_ab_arp_probe(struct bo
  	 * for becoming the curr_active_slave
  	 */
  
 -	if (!curr_arp_slave) {
 -		curr_arp_slave = bond_first_slave_rcu(bond);
 -		if (!curr_arp_slave)
 -			return should_notify_rtnl;
 +	if (!bond->current_arp_slave) {
 +		bond->current_arp_slave = bond->first_slave;
 +		if (!bond->current_arp_slave)
 +			return;
  	}
  
 -	bond_set_slave_inactive_flags(curr_arp_slave, BOND_SLAVE_NOTIFY_LATER);
 +	bond_set_slave_inactive_flags(bond->current_arp_slave);
  
++<<<<<<< HEAD
 +	/* search for next candidate */
 +	bond_for_each_slave_from(bond, slave, i, bond->current_arp_slave->next) {
 +		if (IS_UP(slave->dev)) {
 +			slave->link = BOND_LINK_BACK;
 +			bond_set_slave_active_flags(slave);
 +			bond_arp_send_all(bond, slave);
 +			slave->jiffies = jiffies;
 +			bond->current_arp_slave = slave;
 +			break;
 +		}
 +
++=======
+ 	bond_for_each_slave_rcu(bond, slave, iter) {
+ 		if (!found && !before && bond_slave_is_up(slave))
+ 			before = slave;
+ 
+ 		if (found && !new_slave && bond_slave_is_up(slave))
+ 			new_slave = slave;
++>>>>>>> b6adc610f183 (bonding: convert IS_UP(slave->dev) to inline function)
  		/* if the link state is up at this point, we
  		 * mark it down - this can happen if we have
  		 * simultaneous link failures and
@@@ -2980,7 -2724,7 +3004,11 @@@
  		 * one the current slave so it is still marked
  		 * up when it is actually down
  		 */
++<<<<<<< HEAD
 +		if (slave->link == BOND_LINK_UP) {
++=======
+ 		if (!bond_slave_is_up(slave) && slave->link == BOND_LINK_UP) {
++>>>>>>> b6adc610f183 (bonding: convert IS_UP(slave->dev) to inline function)
  			slave->link = BOND_LINK_DOWN;
  			if (slave->link_failure_count < UINT_MAX)
  				slave->link_failure_count++;
@@@ -3960,11 -3705,12 +3988,11 @@@ static int bond_xmit_broadcast(struct s
  {
  	struct bonding *bond = netdev_priv(bond_dev);
  	struct slave *slave = NULL;
 -	struct list_head *iter;
  
 -	bond_for_each_slave_rcu(bond, slave, iter) {
 +	bond_for_each_slave(bond, slave) {
  		if (bond_is_last_slave(bond, slave))
  			break;
- 		if (IS_UP(slave->dev) && slave->link == BOND_LINK_UP) {
+ 		if (bond_slave_is_up(slave) && slave->link == BOND_LINK_UP) {
  			struct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);
  
  			if (!skb2) {
@@@ -3976,10 -3722,10 +4004,10 @@@
  			bond_dev_queue_xmit(bond, skb2, slave->dev);
  		}
  	}
- 	if (slave && IS_UP(slave->dev) && slave->link == BOND_LINK_UP)
+ 	if (slave && bond_slave_is_up(slave) && slave->link == BOND_LINK_UP)
  		bond_dev_queue_xmit(bond, skb, slave->dev);
  	else
 -		dev_kfree_skb_any(skb);
 +		kfree_skb(skb);
  
  	return NETDEV_TX_OK;
  }
diff --cc drivers/net/bonding/bonding.h
index e1ca02f0b074,6a5393b52ae0..000000000000
--- a/drivers/net/bonding/bonding.h
+++ b/drivers/net/bonding/bonding.h
@@@ -35,10 -38,7 +35,14 @@@
  
  #define BOND_MAX_ARP_TARGETS	16
  
++<<<<<<< HEAD
 +#define IS_UP(dev)					   \
 +	      ((((dev)->flags & IFF_UP) == IFF_UP)	&& \
 +	       netif_running(dev)			&& \
 +	       netif_carrier_ok(dev))
++=======
+ #define BOND_DEFAULT_MIIMON	100
++>>>>>>> b6adc610f183 (bonding: convert IS_UP(slave->dev) to inline function)
  
  /*
   * Checks whether slave is ready for transmit.
@@@ -285,15 -263,46 +289,20 @@@ static inline struct bonding *bond_get_
  	return slave->bond;
  }
  
 -static inline bool bond_should_override_tx_queue(struct bonding *bond)
 -{
 -	return BOND_MODE(bond) == BOND_MODE_ACTIVEBACKUP ||
 -	       BOND_MODE(bond) == BOND_MODE_ROUNDROBIN;
 -}
 -
  static inline bool bond_is_lb(const struct bonding *bond)
  {
 -	return BOND_MODE(bond) == BOND_MODE_TLB ||
 -	       BOND_MODE(bond) == BOND_MODE_ALB;
 -}
 -
 -static inline bool bond_mode_uses_arp(int mode)
 -{
 -	return mode != BOND_MODE_8023AD && mode != BOND_MODE_TLB &&
 -	       mode != BOND_MODE_ALB;
 -}
 -
 -static inline bool bond_mode_uses_primary(int mode)
 -{
 -	return mode == BOND_MODE_ACTIVEBACKUP || mode == BOND_MODE_TLB ||
 -	       mode == BOND_MODE_ALB;
 -}
 -
 -static inline bool bond_uses_primary(struct bonding *bond)
 -{
 -	return bond_mode_uses_primary(BOND_MODE(bond));
 +	return (bond->params.mode == BOND_MODE_TLB ||
 +		bond->params.mode == BOND_MODE_ALB);
  }
  
+ static inline bool bond_slave_is_up(struct slave *slave)
+ {
+ 	return netif_running(slave->dev) && netif_carrier_ok(slave->dev);
+ }
+ 
  static inline void bond_set_active_slave(struct slave *slave)
  {
 -	if (slave->backup) {
 -		slave->backup = 0;
 -		rtmsg_ifinfo(RTM_NEWLINK, slave->dev, 0, GFP_ATOMIC);
 -	}
 +	slave->backup = 0;
  }
  
  static inline void bond_set_backup_slave(struct slave *slave)
@@@ -409,7 -485,23 +418,27 @@@ static inline __be32 bond_confirm_addr(
  	return addr;
  }
  
++<<<<<<< HEAD
 +struct bond_net;
++=======
+ static inline bool slave_can_tx(struct slave *slave)
+ {
+ 	if (bond_slave_is_up(slave) && slave->link == BOND_LINK_UP &&
+ 	    bond_is_active_slave(slave))
+ 		return true;
+ 	else
+ 		return false;
+ }
+ 
+ struct bond_net {
+ 	struct net		*net;	/* Associated network namespace */
+ 	struct list_head	dev_list;
+ #ifdef CONFIG_PROC_FS
+ 	struct proc_dir_entry	*proc_dir;
+ #endif
+ 	struct class_attribute	class_attr_bonding_masters;
+ };
++>>>>>>> b6adc610f183 (bonding: convert IS_UP(slave->dev) to inline function)
  
  int bond_arp_rcv(const struct sk_buff *skb, struct bonding *bond, struct slave *slave);
  void bond_dev_queue_xmit(struct bonding *bond, struct sk_buff *skb, struct net_device *slave_dev);
* Unmerged path drivers/net/bonding/bond_options.c
* Unmerged path drivers/net/bonding/bond_3ad.c
* Unmerged path drivers/net/bonding/bond_main.c
* Unmerged path drivers/net/bonding/bond_options.c
* Unmerged path drivers/net/bonding/bonding.h
