nfs41: allow LD to choose DS connection version/minor_version

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Peng Tao <tao.peng@primarydata.com>
commit 30626f9c32f0ad5e2c4173f10fb4b1358bbba6ec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/30626f9c.failed

flexfile layout may need to set such when making DS connections.

	Signed-off-by: Peng Tao <tao.peng@primarydata.com>
	Signed-off-by: Tom Haynes <Thomas.Haynes@primarydata.com>
(cherry picked from commit 30626f9c32f0ad5e2c4173f10fb4b1358bbba6ec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/filelayout/filelayoutdev.c
#	fs/nfs/internal.h
#	fs/nfs/nfs4client.c
#	fs/nfs/pnfs.h
#	fs/nfs/pnfs_nfs.c
diff --cc fs/nfs/filelayout/filelayoutdev.c
index b394f8c6697b,4f372e224603..000000000000
--- a/fs/nfs/filelayout/filelayoutdev.c
+++ b/fs/nfs/filelayout/filelayoutdev.c
@@@ -716,18 -277,11 +716,25 @@@ nfs4_fl_prepare_ds(struct pnfs_layout_s
  	if (ds->ds_clp)
  		goto out_test_devid;
  
++<<<<<<< HEAD
 +	if (test_and_set_bit(NFS4DS_CONNECTING, &ds->ds_state) == 0) {
 +		struct nfs_server *s = NFS_SERVER(lseg->pls_layout->plh_inode);
 +		int err;
++=======
+ 	nfs4_pnfs_ds_connect(s, ds, devid, dataserver_timeo,
+ 			     dataserver_retrans, 4,
+ 			     s->nfs_client->cl_minorversion,
+ 			     s->nfs_client->cl_rpcclient->cl_auth->au_flavor);
 -
++>>>>>>> 30626f9c32f0 (nfs41: allow LD to choose DS connection version/minor_version)
 +
 +		err = nfs4_ds_connect(s, ds);
 +		if (err)
 +			nfs4_mark_deviceid_unavailable(devid);
 +		nfs4_clear_ds_conn_bit(ds);
 +	} else {
 +		/* Either ds is connected, or ds is NULL */
 +		nfs4_wait_ds_connect(ds);
 +	}
  out_test_devid:
  	if (filelayout_test_devid_unavailable(devid))
  		ret = NULL;
diff --cc fs/nfs/internal.h
index 8d3539215946,5543850268d2..000000000000
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@@ -189,9 -189,15 +189,15 @@@ extern struct nfs_client *nfs4_set_ds_c
  					     const struct sockaddr *ds_addr,
  					     int ds_addrlen, int ds_proto,
  					     unsigned int ds_timeo,
++<<<<<<< HEAD
 +					     unsigned int ds_retrans);
++=======
+ 					     unsigned int ds_retrans,
+ 					     u32 minor_version,
+ 					     rpc_authflavor_t au_flavor);
++>>>>>>> 30626f9c32f0 (nfs41: allow LD to choose DS connection version/minor_version)
  extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,
  						struct inode *);
 -extern struct nfs_client *nfs3_set_ds_client(struct nfs_client *mds_clp,
 -			const struct sockaddr *ds_addr, int ds_addrlen,
 -			int ds_proto, unsigned int ds_timeo,
 -			unsigned int ds_retrans, rpc_authflavor_t au_flavor);
  #ifdef CONFIG_PROC_FS
  extern int __init nfs_fs_proc_init(void);
  extern void nfs_fs_proc_exit(void);
diff --cc fs/nfs/nfs4client.c
index 4a5c6e09b628,102d96777d42..000000000000
--- a/fs/nfs/nfs4client.c
+++ b/fs/nfs/nfs4client.c
@@@ -845,7 -849,8 +845,12 @@@ error
   */
  struct nfs_client *nfs4_set_ds_client(struct nfs_client* mds_clp,
  		const struct sockaddr *ds_addr, int ds_addrlen,
++<<<<<<< HEAD
 +		int ds_proto, unsigned int ds_timeo, unsigned int ds_retrans)
++=======
+ 		int ds_proto, unsigned int ds_timeo, unsigned int ds_retrans,
+ 		u32 minor_version, rpc_authflavor_t au_flavor)
++>>>>>>> 30626f9c32f0 (nfs41: allow LD to choose DS connection version/minor_version)
  {
  	struct nfs_client_initdata cl_init = {
  		.addr = ds_addr,
diff --cc fs/nfs/pnfs.h
index 0a704d8b0cf0,70ffec135696..000000000000
--- a/fs/nfs/pnfs.h
+++ b/fs/nfs/pnfs.h
@@@ -288,8 -303,33 +288,38 @@@ bool nfs4_put_deviceid_node(struct nfs4
  void nfs4_mark_deviceid_unavailable(struct nfs4_deviceid_node *node);
  bool nfs4_test_deviceid_unavailable(struct nfs4_deviceid_node *node);
  void nfs4_deviceid_purge_client(const struct nfs_client *);
++<<<<<<< HEAD
 +int nfs4_deviceid_getdevicelist(struct nfs_server *server,
 +		const struct nfs_fh *fh);
++=======
+ 
+ /* pnfs_nfs.c */
+ void pnfs_generic_clear_request_commit(struct nfs_page *req,
+ 				       struct nfs_commit_info *cinfo);
+ void pnfs_generic_commit_release(void *calldata);
+ void pnfs_generic_prepare_to_resend_writes(struct nfs_commit_data *data);
+ void pnfs_generic_rw_release(void *data);
+ void pnfs_generic_recover_commit_reqs(struct list_head *dst,
+ 				      struct nfs_commit_info *cinfo);
+ int pnfs_generic_commit_pagelist(struct inode *inode,
+ 				 struct list_head *mds_pages,
+ 				 int how,
+ 				 struct nfs_commit_info *cinfo,
+ 				 int (*initiate_commit)(struct nfs_commit_data *data,
+ 							int how));
+ int pnfs_generic_scan_commit_lists(struct nfs_commit_info *cinfo, int max);
+ void pnfs_generic_write_commit_done(struct rpc_task *task, void *data);
+ void nfs4_pnfs_ds_put(struct nfs4_pnfs_ds *ds);
+ struct nfs4_pnfs_ds *nfs4_pnfs_ds_add(struct list_head *dsaddrs,
+ 				      gfp_t gfp_flags);
+ void nfs4_pnfs_ds_connect(struct nfs_server *mds_srv, struct nfs4_pnfs_ds *ds,
+ 			  struct nfs4_deviceid_node *devid, unsigned int timeo,
+ 			  unsigned int retrans, u32 versoin, u32 minor_version,
+ 			  rpc_authflavor_t au_flavor);
+ struct nfs4_pnfs_ds_addr *nfs4_decode_mp_ds_addr(struct net *net,
+ 						 struct xdr_stream *xdr,
+ 						 gfp_t gfp_flags);
++>>>>>>> 30626f9c32f0 (nfs41: allow LD to choose DS connection version/minor_version)
  
  static inline struct nfs4_deviceid_node *
  nfs4_get_deviceid(struct nfs4_deviceid_node *d)
* Unmerged path fs/nfs/pnfs_nfs.c
* Unmerged path fs/nfs/filelayout/filelayoutdev.c
* Unmerged path fs/nfs/internal.h
* Unmerged path fs/nfs/nfs4client.c
* Unmerged path fs/nfs/pnfs.h
* Unmerged path fs/nfs/pnfs_nfs.c
