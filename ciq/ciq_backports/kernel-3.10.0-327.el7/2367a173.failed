ixgbe: flush when in xmit_more mode and under descriptor pressure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Daniel Borkmann <dborkman@redhat.com>
commit 2367a17390138f68b3aa28f2f220b8d7ff8d91f4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/2367a173.failed

When xmit_more mode is being used and the ring is about to
become full or the stack has stopped the ring, enforce a tail
pointer write to the hw. Otherwise, we could risk a TX hang.

Code suggested by Alexander Duyck.

	Signed-off-by: Alexander Duyck <alexander.h.duyck@intel.com>
	Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2367a17390138f68b3aa28f2f220b8d7ff8d91f4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index b0a004972e7a,53fbf0641533..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@@ -6734,35 -7101,11 +6767,42 @@@ static void ixgbe_atr(struct ixgbe_rin
  					      input, common, ring->queue_index);
  }
  
++<<<<<<< HEAD
 +static int __ixgbe_maybe_stop_tx(struct ixgbe_ring *tx_ring, u16 size)
 +{
 +	netif_stop_subqueue(tx_ring->netdev, tx_ring->queue_index);
 +	/* Herbert's original patch had:
 +	 *  smp_mb__after_netif_stop_queue();
 +	 * but since that doesn't exist yet, just open code it. */
 +	smp_mb();
 +
 +	/* We need to check again in a case another CPU has just
 +	 * made room available. */
 +	if (likely(ixgbe_desc_unused(tx_ring) < size))
 +		return -EBUSY;
 +
 +	/* A reprieve! - use start_queue because it doesn't call schedule */
 +	netif_start_subqueue(tx_ring->netdev, tx_ring->queue_index);
 +	++tx_ring->tx_stats.restart_queue;
 +	return 0;
 +}
 +
 +static inline int ixgbe_maybe_stop_tx(struct ixgbe_ring *tx_ring, u16 size)
 +{
 +	if (likely(ixgbe_desc_unused(tx_ring) >= size))
 +		return 0;
 +	return __ixgbe_maybe_stop_tx(tx_ring, size);
 +}
 +
++=======
+ static u16 ixgbe_select_queue(struct net_device *dev, struct sk_buff *skb,
+ 			      void *accel_priv, select_queue_fallback_t fallback)
+ {
+ 	struct ixgbe_fwd_adapter *fwd_adapter = accel_priv;
++>>>>>>> 2367a1739013 (ixgbe: flush when in xmit_more mode and under descriptor pressure)
  #ifdef IXGBE_FCOE
 +static u16 ixgbe_select_queue(struct net_device *dev, struct sk_buff *skb)
 +{
  	struct ixgbe_adapter *adapter;
  	struct ixgbe_ring_feature *f;
  	int txq;
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
