ixgbe: Refactor the RSS configuration code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Vlad Zolotarov <vladz@cloudius-systems.com>
commit dfaf891dd3e1e2e4531c4fd800bd6d8e3079ed72
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/dfaf891d.failed

This patch is a preparation for enablement of ethtool RSS indirection
table and hash key querying. We don't want to read registers every time
the RSS info is queried. Therefore we will store its current content in the
arrays in the adapter struct and will read it from there (instead of from
registers) when requested.

Will change the code that writes the indirection table and hash key into
the HW registers to take its content from these arrays. This will also
simplify the indirection table updating ethtool callback implementation
in the future.

	Signed-off-by: Vlad Zolotarov <vladz@cloudius-systems.com>
	Tested-by: Phil Schmitt <phillip.j.schmitt@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit dfaf891dd3e1e2e4531c4fd800bd6d8e3079ed72)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ixgbe/ixgbe.h
#	drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe.h
index dcedeeeaac8b,d13ab87dfc3a..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe.h
@@@ -774,8 -765,33 +774,21 @@@ struct ixgbe_adapter 
  #endif /*CONFIG_DEBUG_FS*/
  
  	u8 default_up;
++<<<<<<< HEAD
++=======
+ 	unsigned long fwd_bitmask; /* Bitmask indicating in use pools */
+ 
+ /* maximum number of RETA entries among all devices supported by ixgbe
+  * driver: currently it's x550 device in non-SRIOV mode
+  */
+ #define IXGBE_MAX_RETA_ENTRIES 512
+ 	u8 rss_indir_tbl[IXGBE_MAX_RETA_ENTRIES];
+ 
+ #define IXGBE_RSS_KEY_SIZE     40  /* size of RSS Hash Key in bytes */
+ 	u32 rss_key[IXGBE_RSS_KEY_SIZE / sizeof(u32)];
++>>>>>>> dfaf891dd3e1 (ixgbe: Refactor the RSS configuration code)
  };
  
 -static inline u8 ixgbe_max_rss_indices(struct ixgbe_adapter *adapter)
 -{
 -	switch (adapter->hw.mac.type) {
 -	case ixgbe_mac_82598EB:
 -	case ixgbe_mac_82599EB:
 -	case ixgbe_mac_X540:
 -		return IXGBE_MAX_RSS_INDICES;
 -	case ixgbe_mac_X550:
 -	case ixgbe_mac_X550EM_x:
 -		return IXGBE_MAX_RSS_INDICES_X550;
 -	default:
 -		return 0;
 -	}
 -}
 -
  struct ixgbe_fdir_filter {
  	struct hlist_node fdir_node;
  	union ixgbe_atr_input filter;
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index be14b10f1d85,57a3ec459ef7..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@@ -3209,15 -3228,98 +3209,103 @@@ static void ixgbe_configure_srrctl(stru
  	IXGBE_WRITE_REG(hw, IXGBE_SRRCTL(reg_idx), srrctl);
  }
  
- static void ixgbe_setup_reta(struct ixgbe_adapter *adapter, const u32 *seed)
+ /**
+  * Return a number of entries in the RSS indirection table
+  *
+  * @adapter: device handle
+  *
+  *  - 82598/82599/X540:     128
+  *  - X550(non-SRIOV mode): 512
+  *  - X550(SRIOV mode):     64
+  */
+ static u32 ixgbe_rss_indir_tbl_entries(struct ixgbe_adapter *adapter)
  {
+ 	if (adapter->hw.mac.type < ixgbe_mac_X550)
+ 		return 128;
+ 	else if (adapter->flags & IXGBE_FLAG_SRIOV_ENABLED)
+ 		return 64;
+ 	else
+ 		return 512;
+ }
+ 
+ /**
+  * Write the RETA table to HW
+  *
+  * @adapter: device handle
+  *
+  * Write the RSS redirection table stored in adapter.rss_indir_tbl[] to HW.
+  */
+ static void ixgbe_store_reta(struct ixgbe_adapter *adapter)
+ {
+ 	u32 i, reta_entries = ixgbe_rss_indir_tbl_entries(adapter);
  	struct ixgbe_hw *hw = &adapter->hw;
  	u32 reta = 0;
++<<<<<<< HEAD
 +	int i, j;
 +	u16 rss_i = adapter->ring_feature[RING_F_RSS].indices;
++=======
+ 	u32 indices_multi;
+ 	u8 *indir_tbl = adapter->rss_indir_tbl;
++>>>>>>> dfaf891dd3e1 (ixgbe: Refactor the RSS configuration code)
+ 
+ 	/* Fill out the redirection table as follows:
+ 	 *  - 82598:      8 bit wide entries containing pair of 4 bit RSS
+ 	 *    indices.
+ 	 *  - 82599/X540: 8 bit wide entries containing 4 bit RSS index
+ 	 *  - X550:       8 bit wide entries containing 6 bit RSS index
+ 	 */
+ 	if (adapter->hw.mac.type == ixgbe_mac_82598EB)
+ 		indices_multi = 0x11;
+ 	else
+ 		indices_multi = 0x1;
+ 
+ 	/* Write redirection table to HW */
+ 	for (i = 0; i < reta_entries; i++) {
+ 		reta |= indices_multi * indir_tbl[i] << (i & 0x3) * 8;
+ 		if ((i & 3) == 3) {
+ 			if (i < 128)
+ 				IXGBE_WRITE_REG(hw, IXGBE_RETA(i >> 2), reta);
+ 			else
+ 				IXGBE_WRITE_REG(hw, IXGBE_ERETA((i >> 2) - 32),
+ 						reta);
+ 			reta = 0;
+ 		}
+ 	}
+ }
  
- 	/*
- 	 * Program table for at least 2 queues w/ SR-IOV so that VFs can
+ /**
+  * Write the RETA table to HW (for x550 devices in SRIOV mode)
+  *
+  * @adapter: device handle
+  *
+  * Write the RSS redirection table stored in adapter.rss_indir_tbl[] to HW.
+  */
+ static void ixgbe_store_vfreta(struct ixgbe_adapter *adapter)
+ {
+ 	u32 i, reta_entries = ixgbe_rss_indir_tbl_entries(adapter);
+ 	struct ixgbe_hw *hw = &adapter->hw;
+ 	u32 vfreta = 0;
+ 	unsigned int pf_pool = adapter->num_vfs;
+ 
+ 	/* Write redirection table to HW */
+ 	for (i = 0; i < reta_entries; i++) {
+ 		vfreta |= (u32)adapter->rss_indir_tbl[i] << (i & 0x3) * 8;
+ 		if ((i & 3) == 3) {
+ 			IXGBE_WRITE_REG(hw, IXGBE_PFVFRETA(i >> 2, pf_pool),
+ 					vfreta);
+ 			vfreta = 0;
+ 		}
+ 	}
+ }
+ 
+ static void ixgbe_setup_reta(struct ixgbe_adapter *adapter)
+ {
+ 	struct ixgbe_hw *hw = &adapter->hw;
+ 	u32 i, j;
+ 	u32 reta_entries = ixgbe_rss_indir_tbl_entries(adapter);
+ 	u16 rss_i = adapter->ring_feature[RING_F_RSS].indices;
+ 
+ 	/* Program table for at least 2 queues w/ SR-IOV so that VFs can
  	 * make full use of any rings they may have.  We will use the
  	 * PSRTYPE register to control how many rings we use within the PF.
  	 */
@@@ -3226,25 -3328,48 +3314,67 @@@
  
  	/* Fill out hash function seeds */
  	for (i = 0; i < 10; i++)
++<<<<<<< HEAD
 +		IXGBE_WRITE_REG(hw, IXGBE_RSSRK(i), seed[i]);
 +
 +	/* Fill out redirection table */
 +	for (i = 0, j = 0; i < 128; i++, j++) {
 +		if (j == rss_i)
 +			j = 0;
 +		/* reta = 4-byte sliding window of
 +		 * 0x00..(indices-1)(indices-1)00..etc. */
 +		reta = (reta << 8) | (j * 0x11);
 +		if ((i & 3) == 3)
 +			IXGBE_WRITE_REG(hw, IXGBE_RETA(i >> 2), reta);
++=======
+ 		IXGBE_WRITE_REG(hw, IXGBE_RSSRK(i), adapter->rss_key[i]);
+ 
+ 	/* Fill out redirection table */
+ 	memset(adapter->rss_indir_tbl, 0, sizeof(adapter->rss_indir_tbl));
+ 
+ 	for (i = 0, j = 0; i < reta_entries; i++, j++) {
+ 		if (j == rss_i)
+ 			j = 0;
+ 
+ 		adapter->rss_indir_tbl[i] = j;
+ 	}
+ 
+ 	ixgbe_store_reta(adapter);
+ }
+ 
+ static void ixgbe_setup_vfreta(struct ixgbe_adapter *adapter)
+ {
+ 	struct ixgbe_hw *hw = &adapter->hw;
+ 	u16 rss_i = adapter->ring_feature[RING_F_RSS].indices;
+ 	unsigned int pf_pool = adapter->num_vfs;
+ 	int i, j;
+ 
+ 	/* Fill out hash function seeds */
+ 	for (i = 0; i < 10; i++)
+ 		IXGBE_WRITE_REG(hw, IXGBE_PFVFRSSRK(i, pf_pool),
+ 				adapter->rss_key[i]);
+ 
+ 	/* Fill out the redirection table */
+ 	for (i = 0, j = 0; i < 64; i++, j++) {
+ 		if (j == rss_i)
+ 			j = 0;
+ 
+ 		adapter->rss_indir_tbl[i] = j;
++>>>>>>> dfaf891dd3e1 (ixgbe: Refactor the RSS configuration code)
  	}
+ 
+ 	ixgbe_store_vfreta(adapter);
  }
  
  static void ixgbe_setup_mrqc(struct ixgbe_adapter *adapter)
  {
  	struct ixgbe_hw *hw = &adapter->hw;
++<<<<<<< HEAD
 +	u32 mrqc = 0, rss_field = 0;
 +	u32 rss_key[10];
++=======
+ 	u32 mrqc = 0, rss_field = 0, vfmrqc = 0;
++>>>>>>> dfaf891dd3e1 (ixgbe: Refactor the RSS configuration code)
  	u32 rxcsum;
  
  	/* Disable indicating checksum in descriptor, enables RSS hash */
@@@ -3288,10 -3413,25 +3418,32 @@@
  	if (adapter->flags2 & IXGBE_FLAG2_RSS_FIELD_IPV6_UDP)
  		rss_field |= IXGBE_MRQC_RSS_FIELD_IPV6_UDP;
  
++<<<<<<< HEAD
 +	netdev_rss_key_fill(rss_key, sizeof(rss_key));
 +	ixgbe_setup_reta(adapter, rss_key);
 +	mrqc |= rss_field;
 +	IXGBE_WRITE_REG(hw, IXGBE_MRQC, mrqc);
++=======
+ 	netdev_rss_key_fill(adapter->rss_key, sizeof(adapter->rss_key));
+ 	if ((hw->mac.type >= ixgbe_mac_X550) &&
+ 	    (adapter->flags & IXGBE_FLAG_SRIOV_ENABLED)) {
+ 		unsigned int pf_pool = adapter->num_vfs;
+ 
+ 		/* Enable VF RSS mode */
+ 		mrqc |= IXGBE_MRQC_MULTIPLE_RSS;
+ 		IXGBE_WRITE_REG(hw, IXGBE_MRQC, mrqc);
+ 
+ 		/* Setup RSS through the VF registers */
+ 		ixgbe_setup_vfreta(adapter);
+ 		vfmrqc = IXGBE_MRQC_RSSEN;
+ 		vfmrqc |= rss_field;
+ 		IXGBE_WRITE_REG(hw, IXGBE_PFVFMRQC(pf_pool), vfmrqc);
+ 	} else {
+ 		ixgbe_setup_reta(adapter);
+ 		mrqc |= rss_field;
+ 		IXGBE_WRITE_REG(hw, IXGBE_MRQC, mrqc);
+ 	}
++>>>>>>> dfaf891dd3e1 (ixgbe: Refactor the RSS configuration code)
  }
  
  /**
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe.h
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
