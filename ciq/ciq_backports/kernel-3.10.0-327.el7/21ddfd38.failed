percpu: renew the max_contig if we merge the head and previous block

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Jianyu Zhan <nasa4836@gmail.com>
commit 21ddfd38ee9aac804d22beaceed4c7b903cca234
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/21ddfd38.failed

During pcpu_alloc_area(), we might merge the current head with the
previous block. Since we have calculated the max_contig using the
size of previous block before we skip it, and now we update the size
of previous block, so we should renew the max_contig.

	Signed-off-by: Jianyu Zhan <nasa4836@gmail.com>
	Signed-off-by: Tejun Heo <tj@kernel.org>
(cherry picked from commit 21ddfd38ee9aac804d22beaceed4c7b903cca234)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/percpu.c
diff --cc mm/percpu.c
index 89e586173340,63e24fb4387b..000000000000
--- a/mm/percpu.c
+++ b/mm/percpu.c
@@@ -513,10 -472,12 +513,19 @@@ static int pcpu_alloc_area(struct pcpu_
  		 * than sizeof(int), which is very small but isn't too
  		 * uncommon for percpu allocations.
  		 */
++<<<<<<< HEAD
 +		if (head && (head < sizeof(int) || !(chunk->map[i - 1] & 1))) {
 +			if (chunk->map[i - 1] & 1)
 +				chunk->free_size -= head;
 +			chunk->map[i] = off += head;
++=======
+ 		if (head && (head < sizeof(int) || !(p[-1] & 1))) {
+ 			*p = off += head;
+ 			if (p[-1] & 1)
+ 				chunk->free_size -= head;
+ 			else
+ 				max_contig = max(*p - p[-1], max_contig);
++>>>>>>> 21ddfd38ee9a (percpu: renew the max_contig if we merge the head and previous block)
  			this_size -= head;
  			head = 0;
  		}
* Unmerged path mm/percpu.c
