fib_trie: replace tnode_get_child functions with get_child macros

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Alexander Duyck <alexander.h.duyck@redhat.com>
commit 754baf8decce722db6d02bb0db745402f8cbc16f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/754baf8d.failed

I am replacing the tnode_get_child call with get_child since we are
techically pulling the child out of a key_vector now and not a tnode.

	Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 754baf8decce722db6d02bb0db745402f8cbc16f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/fib_trie.c
diff --cc net/ipv4/fib_trie.c
index 8be89b1a8b93,b9e2a6195572..000000000000
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@@ -166,9 -163,10 +167,10 @@@ static struct kmem_cache *trie_leaf_kme
  
  /* caller must hold RCU read lock or RTNL */
  #define node_parent_rcu(n) rcu_dereference_rtnl((n)->parent)
+ #define get_child_rcu(tn, i) rcu_dereference_rtnl((tn)->tnode[i])
  
  /* wrapper for rcu_assign_pointer */
 -static inline void node_set_parent(struct key_vector *n, struct key_vector *tp)
 +static inline void node_set_parent(struct tnode *n, struct tnode *tp)
  {
  	if (n)
  		rcu_assign_pointer(n->parent, tp);
@@@ -184,18 -182,11 +186,26 @@@ static inline unsigned long tnode_child
  	return (1ul << tn->bits) & ~(1ul);
  }
  
++<<<<<<< HEAD
 +/* caller must hold RTNL */
 +static inline struct tnode *tnode_get_child(const struct tnode *tn,
 +					    unsigned long i)
 +{
 +	return rtnl_dereference(tn->child[i]);
 +}
 +
 +/* caller must hold RCU read lock or RTNL */
 +static inline struct tnode *tnode_get_child_rcu(const struct tnode *tn,
 +						unsigned long i)
 +{
 +	return rcu_dereference_rtnl(tn->child[i]);
++=======
+ static inline struct fib_table *trie_get_table(struct trie *t)
+ {
+ 	unsigned long *tb_data = (unsigned long *)t;
+ 
+ 	return container_of(tb_data, struct fib_table, tb_data[0]);
++>>>>>>> 754baf8decce (fib_trie: replace tnode_get_child functions with get_child macros)
  }
  
  /* To understand this stuff, an understanding of keys and all their bits is
@@@ -381,9 -368,10 +391,13 @@@ static inline int tnode_full(const stru
  /* Add a child at position i overwriting the old value.
   * Update the value of full_children and empty_children.
   */
 -static void put_child(struct key_vector *tn, unsigned long i,
 -		      struct key_vector *n)
 +static void put_child(struct tnode *tn, unsigned long i, struct tnode *n)
  {
++<<<<<<< HEAD
 +	struct tnode *chi = tnode_get_child(tn, i);
++=======
+ 	struct key_vector *chi = get_child(tn, i);
++>>>>>>> 754baf8decce (fib_trie: replace tnode_get_child functions with get_child macros)
  	int isfull, wasfull;
  
  	BUG_ON(i >= tnode_child_length(tn));
@@@ -415,7 -403,7 +429,11 @@@ static void update_children(struct tnod
  
  	/* update all of the child parent pointers */
  	for (i = tnode_child_length(tn); i;) {
++<<<<<<< HEAD
 +		struct tnode *inode = tnode_get_child(tn, --i);
++=======
+ 		struct key_vector *inode = get_child(tn, --i);
++>>>>>>> 754baf8decce (fib_trie: replace tnode_get_child functions with get_child macros)
  
  		if (!inode)
  			continue;
@@@ -484,9 -476,12 +502,13 @@@ static void replace(struct trie *t, str
  	/* all pointers should be clean so we are done */
  	tnode_free(oldtnode);
  
 -	/* record the pointer that is pointing to this node */
 -	cptr = tp ? tp->tnode : t->tnode;
 -
  	/* resize children now that oldtnode is freed */
  	for (i = tnode_child_length(tn); i;) {
++<<<<<<< HEAD
 +		struct tnode *inode = tnode_get_child(tn, --i);
++=======
+ 		struct key_vector *inode = get_child(tn, --i);
++>>>>>>> 754baf8decce (fib_trie: replace tnode_get_child functions with get_child macros)
  
  		/* resize child node */
  		if (tnode_full(tn, inode))
@@@ -515,8 -513,8 +537,13 @@@ static int inflate(struct trie *t, stru
  	 * nodes.
  	 */
  	for (i = tnode_child_length(oldtnode), m = 1u << tn->pos; i;) {
++<<<<<<< HEAD
 +		struct tnode *inode = tnode_get_child(oldtnode, --i);
 +		struct tnode *node0, *node1;
++=======
+ 		struct key_vector *inode = get_child(oldtnode, --i);
+ 		struct key_vector *node0, *node1;
++>>>>>>> 754baf8decce (fib_trie: replace tnode_get_child functions with get_child macros)
  		unsigned long j, k;
  
  		/* An empty child */
@@@ -610,9 -608,9 +637,15 @@@ static int halve(struct trie *t, struc
  	 * nodes.
  	 */
  	for (i = tnode_child_length(oldtnode); i;) {
++<<<<<<< HEAD
 +		struct tnode *node1 = tnode_get_child(oldtnode, --i);
 +		struct tnode *node0 = tnode_get_child(oldtnode, --i);
 +		struct tnode *inode;
++=======
+ 		struct key_vector *node1 = get_child(oldtnode, --i);
+ 		struct key_vector *node0 = get_child(oldtnode, --i);
+ 		struct key_vector *inode;
++>>>>>>> 754baf8decce (fib_trie: replace tnode_get_child functions with get_child macros)
  
  		/* At least one of the children is empty */
  		if (!node1 || !node0) {
@@@ -672,7 -671,7 +705,11 @@@ static unsigned char update_suffix(stru
  	 * represent the nodes with suffix length equal to tn->pos
  	 */
  	for (i = 0, stride = 0x2ul ; i < tnode_child_length(tn); i += stride) {
++<<<<<<< HEAD
 +		struct tnode *n = tnode_get_child(tn, i);
++=======
+ 		struct key_vector *n = get_child(tn, i);
++>>>>>>> 754baf8decce (fib_trie: replace tnode_get_child functions with get_child macros)
  
  		if (!n || (n->slen <= slen))
  			continue;
@@@ -985,83 -929,68 +1022,105 @@@ static struct tnode *fib_find_node(stru
  		if (IS_LEAF(n))
  			break;
  
++<<<<<<< HEAD
 +		n = tnode_get_child_rcu(n, index);
++=======
+ 		pn = n;
+ 		n = get_child_rcu(n, index);
++>>>>>>> 754baf8decce (fib_trie: replace tnode_get_child functions with get_child macros)
  	}
  
 -	*tp = pn;
 -
  	return n;
  }
  
 -/* Return the first fib alias matching TOS with
 - * priority less than or equal to PRIO.
 - */
 -static struct fib_alias *fib_find_alias(struct hlist_head *fah, u8 slen,
 -					u8 tos, u32 prio)
 +static void trie_rebalance(struct trie *t, struct tnode *tn)
  {
 -	struct fib_alias *fa;
 -
 -	if (!fah)
 -		return NULL;
 +	struct tnode *tp;
  
 -	hlist_for_each_entry(fa, fah, fa_list) {
 -		if (fa->fa_slen < slen)
 -			continue;
 -		if (fa->fa_slen != slen)
 -			break;
 -		if (fa->fa_tos > tos)
 -			continue;
 -		if (fa->fa_info->fib_priority >= prio || fa->fa_tos < tos)
 -			return fa;
 +	while ((tp = node_parent(tn)) != NULL) {
 +		resize(t, tn);
 +		tn = tp;
  	}
  
 -	return NULL;
 +	/* Handle last (top) tnode */
 +	if (IS_TNODE(tn))
 +		resize(t, tn);
  }
  
 -static void trie_rebalance(struct trie *t, struct key_vector *tn)
 +/* only used from updater-side */
 +
 +static struct list_head *fib_insert_node(struct trie *t, u32 key, int plen)
  {
 -	struct key_vector __rcu **cptr = t->tnode;
 +	struct list_head *fa_head = NULL;
 +	struct tnode *l, *n, *tp = NULL;
 +	struct leaf_info *li;
  
 -	while (tn) {
 -		struct key_vector *tp = node_parent(tn);
 +	li = leaf_info_new(plen);
 +	if (!li)
 +		return NULL;
 +	fa_head = &li->falh;
 +
 +	n = rtnl_dereference(t->trie);
 +
 +	/* If we point to NULL, stop. Either the tree is empty and we should
 +	 * just put a new leaf in if, or we have reached an empty child slot,
 +	 * and we should just put our new leaf in that.
 +	 *
 +	 * If we hit a node with a key that does't match then we should stop
 +	 * and create a new tnode to replace that node and insert ourselves
 +	 * and the other node into the new tnode.
 +	 */
 +	while (n) {
 +		unsigned long index = get_index(key, n);
  
 -		cptr = resize(t, tn);
 -		if (!tp)
 +		/* This bit of code is a bit tricky but it combines multiple
 +		 * checks into a single check.  The prefix consists of the
 +		 * prefix plus zeros for the "bits" in the prefix. The index
 +		 * is the difference between the key and this value.  From
 +		 * this we can actually derive several pieces of data.
 +		 *   if !(index >> bits)
 +		 *     we know the value is child index
 +		 *   else
 +		 *     we have a mismatch in skip bits and failed
 +		 */
 +		if (index >> n->bits)
  			break;
 -		tn = container_of(cptr, struct key_vector, tnode[0]);
 +
 +		/* we have found a leaf. Prefixes have already been compared */
 +		if (IS_LEAF(n)) {
 +			/* Case 1: n is a leaf, and prefixes match*/
 +			insert_leaf_info(n, li);
 +			return fa_head;
 +		}
 +
 +		tp = n;
 +		n = tnode_get_child_rcu(n, index);
  	}
 -}
  
 +	l = leaf_new(key);
 +	if (!l) {
 +		free_leaf_info(li);
 +		return NULL;
 +	}
 +
++<<<<<<< HEAD
 +	insert_leaf_info(l, li);
++=======
+ static int fib_insert_node(struct trie *t, struct key_vector *tp,
+ 			   struct fib_alias *new, t_key key)
+ {
+ 	struct key_vector *n, *l;
+ 
+ 	l = leaf_new(key, new);
+ 	if (!l)
+ 		goto noleaf;
+ 
+ 	/* retrieve child from parent node */
+ 	if (tp)
+ 		n = get_child(tp, get_index(key, tp));
+ 	else
+ 		n = rcu_dereference_rtnl(t->tnode[0]);
++>>>>>>> 754baf8decce (fib_trie: replace tnode_get_child functions with get_child macros)
  
  	/* Case 2: n is a LEAF or a TNODE and the key doesn't match.
  	 *
@@@ -1562,12 -1514,178 +1621,184 @@@ int fib_table_delete(struct fib_table *
  	return 0;
  }
  
 -/* Scan for the next leaf starting at the provided key value */
 -static struct key_vector *leaf_walk_rcu(struct key_vector **tn, t_key key)
 +static int trie_flush_list(struct list_head *head)
  {
++<<<<<<< HEAD
 +	struct fib_alias *fa, *fa_node;
 +	int found = 0;
 +
 +	list_for_each_entry_safe(fa, fa_node, head, fa_list) {
++=======
+ 	struct key_vector *pn, *n = *tn;
+ 	unsigned long cindex;
+ 
+ 	/* record parent node for backtracing */
+ 	pn = n;
+ 	cindex = n ? get_index(key, n) : 0;
+ 
+ 	/* this loop is meant to try and find the key in the trie */
+ 	while (n) {
+ 		unsigned long idx = get_index(key, n);
+ 
+ 		/* guarantee forward progress on the keys */
+ 		if (IS_LEAF(n) && (n->key >= key))
+ 			goto found;
+ 		if (idx >= (1ul << n->bits))
+ 			break;
+ 
+ 		/* record parent and next child index */
+ 		pn = n;
+ 		cindex = idx;
+ 
+ 		/* descend into the next child */
+ 		n = get_child_rcu(pn, cindex++);
+ 	}
+ 
+ 	/* this loop will search for the next leaf with a greater key */
+ 	while (pn) {
+ 		/* if we exhausted the parent node we will need to climb */
+ 		if (cindex >= (1ul << pn->bits)) {
+ 			t_key pkey = pn->key;
+ 
+ 			pn = node_parent_rcu(pn);
+ 			if (!pn)
+ 				break;
+ 
+ 			cindex = get_index(pkey, pn) + 1;
+ 			continue;
+ 		}
+ 
+ 		/* grab the next available node */
+ 		n = get_child_rcu(pn, cindex++);
+ 		if (!n)
+ 			continue;
+ 
+ 		/* no need to compare keys since we bumped the index */
+ 		if (IS_LEAF(n))
+ 			goto found;
+ 
+ 		/* Rescan start scanning in new node */
+ 		pn = n;
+ 		cindex = 0;
+ 	}
+ 
+ 	*tn = pn;
+ 	return NULL; /* Root of trie */
+ found:
+ 	/* if we are at the limit for keys just return NULL for the tnode */
+ 	*tn = (n->key == KEY_MAX) ? NULL : pn;
+ 	return n;
+ }
+ 
+ /* Caller must hold RTNL */
+ void fib_table_flush_external(struct fib_table *tb)
+ {
+ 	struct trie *t = (struct trie *)tb->tb_data;
+ 	struct fib_alias *fa;
+ 	struct key_vector *n, *pn;
+ 	unsigned long cindex;
+ 
+ 	n = rcu_dereference(t->tnode[0]);
+ 	if (!n)
+ 		return;
+ 
+ 	pn = NULL;
+ 	cindex = 0;
+ 
+ 	while (IS_TNODE(n)) {
+ 		/* record pn and cindex for leaf walking */
+ 		pn = n;
+ 		cindex = 1ul << n->bits;
+ backtrace:
+ 		/* walk trie in reverse order */
+ 		do {
+ 			while (!(cindex--)) {
+ 				t_key pkey = pn->key;
+ 
+ 				/* if we got the root we are done */
+ 				pn = node_parent(pn);
+ 				if (!pn)
+ 					return;
+ 
+ 				cindex = get_index(pkey, pn);
+ 			}
+ 
+ 			/* grab the next available node */
+ 			n = get_child(pn, cindex);
+ 		} while (!n);
+ 	}
+ 
+ 	hlist_for_each_entry(fa, &n->leaf, fa_list) {
+ 		struct fib_info *fi = fa->fa_info;
+ 
+ 		if (!fi || !(fi->fib_flags & RTNH_F_EXTERNAL))
+ 			continue;
+ 
+ 		netdev_switch_fib_ipv4_del(n->key,
+ 					   KEYLENGTH - fa->fa_slen,
+ 					   fi, fa->fa_tos,
+ 					   fa->fa_type, tb->tb_id);
+ 	}
+ 
+ 	/* if trie is leaf only loop is completed */
+ 	if (pn)
+ 		goto backtrace;
+ }
+ 
+ /* Caller must hold RTNL. */
+ int fib_table_flush(struct fib_table *tb)
+ {
+ 	struct trie *t = (struct trie *)tb->tb_data;
+ 	struct key_vector *n, *pn;
+ 	struct hlist_node *tmp;
+ 	struct fib_alias *fa;
+ 	unsigned long cindex;
+ 	unsigned char slen;
+ 	int found = 0;
+ 
+ 	n = rcu_dereference(t->tnode[0]);
+ 	if (!n)
+ 		goto flush_complete;
+ 
+ 	pn = NULL;
+ 	cindex = 0;
+ 
+ 	while (IS_TNODE(n)) {
+ 		/* record pn and cindex for leaf walking */
+ 		pn = n;
+ 		cindex = 1ul << n->bits;
+ backtrace:
+ 		/* walk trie in reverse order */
+ 		do {
+ 			while (!(cindex--)) {
+ 				struct key_vector __rcu **cptr;
+ 				t_key pkey = pn->key;
+ 
+ 				n = pn;
+ 				pn = node_parent(n);
+ 
+ 				/* resize completed node */
+ 				cptr = resize(t, n);
+ 
+ 				/* if we got the root we are done */
+ 				if (!pn)
+ 					goto flush_complete;
+ 
+ 				pn = container_of(cptr, struct key_vector,
+ 						  tnode[0]);
+ 				cindex = get_index(pkey, pn);
+ 			}
+ 
+ 			/* grab the next available node */
+ 			n = get_child(pn, cindex);
+ 		} while (!n);
+ 	}
+ 
+ 	/* track slen in case any prefixes survive */
+ 	slen = 0;
+ 
+ 	hlist_for_each_entry_safe(fa, tmp, &n->leaf, fa_list) {
++>>>>>>> 754baf8decce (fib_trie: replace tnode_get_child functions with get_child macros)
  		struct fib_info *fi = fa->fa_info;
  
  		if (fi && (fi->fib_flags & RTNH_F_DEAD)) {
@@@ -1887,7 -1875,7 +2118,11 @@@ static struct tnode *fib_trie_get_next(
  		 iter->tnode, iter->index, iter->depth);
  rescan:
  	while (cindex < tnode_child_length(tn)) {
++<<<<<<< HEAD
 +		struct tnode *n = tnode_get_child_rcu(tn, cindex);
++=======
+ 		struct key_vector *n = get_child_rcu(tn, cindex);
++>>>>>>> 754baf8decce (fib_trie: replace tnode_get_child functions with get_child macros)
  
  		if (n) {
  			if (IS_LEAF(n)) {
* Unmerged path net/ipv4/fib_trie.c
