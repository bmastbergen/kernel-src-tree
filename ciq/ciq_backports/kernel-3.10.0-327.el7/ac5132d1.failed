vxlan: Only bind to sockets with compatible flags enabled

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Thomas Graf <tgraf@suug.ch>
commit ac5132d1a03fe1ebbefb2382b36e829dff056283
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/ac5132d1.failed

A VXLAN net_device looking for an appropriate socket may only consider
a socket which has a matching set of flags/extensions enabled. If
incompatible flags are enabled, return a conflict to have the caller
create a distinct socket with distinct port.

The OVS VXLAN port is kept unaware of extensions at this point.

	Signed-off-by: Thomas Graf <tgraf@suug.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ac5132d1a03fe1ebbefb2382b36e829dff056283)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index 3440d933b3ec,6b6b45622a0a..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1777,8 -1961,9 +1782,14 @@@ static void vxlan_xmit_one(struct sk_bu
  			struct vxlan_dev *dst_vxlan;
  
  			ip_rt_put(rt);
++<<<<<<< HEAD
 +			dst_vxlan = vxlan_find_vni(dev_net(dev), vni,
 +						   dst->sa.sa_family, dst_port);
++=======
+ 			dst_vxlan = vxlan_find_vni(vxlan->net, vni,
+ 						   dst->sa.sa_family, dst_port,
+ 						   vxlan->flags);
++>>>>>>> ac5132d1a03f (vxlan: Only bind to sockets with compatible flags enabled)
  			if (!dst_vxlan)
  				goto tx_error;
  			vxlan_encap_bypass(skb, vxlan, dst_vxlan);
@@@ -1831,8 -2021,9 +1842,14 @@@
  			struct vxlan_dev *dst_vxlan;
  
  			dst_release(ndst);
++<<<<<<< HEAD
 +			dst_vxlan = vxlan_find_vni(dev_net(dev), vni,
 +						   dst->sa.sa_family, dst_port);
++=======
+ 			dst_vxlan = vxlan_find_vni(vxlan->net, vni,
+ 						   dst->sa.sa_family, dst_port,
+ 						   vxlan->flags);
++>>>>>>> ac5132d1a03f (vxlan: Only bind to sockets with compatible flags enabled)
  			if (!dst_vxlan)
  				goto tx_error;
  			vxlan_encap_bypass(skb, vxlan, dst_vxlan);
@@@ -1997,8 -2192,8 +2014,13 @@@ static int vxlan_init(struct net_devic
  		return -ENOMEM;
  
  	spin_lock(&vn->sock_lock);
++<<<<<<< HEAD
 +	vs = vxlan_find_sock(dev_net(dev), ipv6 ? AF_INET6 : AF_INET,
 +			     vxlan->dst_port);
++=======
+ 	vs = vxlan_find_sock(vxlan->net, ipv6 ? AF_INET6 : AF_INET,
+ 			     vxlan->dst_port, vxlan->flags);
++>>>>>>> ac5132d1a03f (vxlan: Only bind to sockets with compatible flags enabled)
  	if (vs && atomic_add_unless(&vs->refcnt, 1, 0)) {
  		/* If we have a socket with same port already, reuse it */
  		vxlan_vs_add_dev(vs, vxlan);
@@@ -2566,8 -2756,19 +2588,8 @@@ static int vxlan_newlink(struct net *ne
  	    nla_get_u8(data[IFLA_VXLAN_UDP_ZERO_CSUM6_RX]))
  		vxlan->flags |= VXLAN_F_UDP_ZERO_CSUM6_RX;
  
 -	if (data[IFLA_VXLAN_REMCSUM_TX] &&
 -	    nla_get_u8(data[IFLA_VXLAN_REMCSUM_TX]))
 -		vxlan->flags |= VXLAN_F_REMCSUM_TX;
 -
 -	if (data[IFLA_VXLAN_REMCSUM_RX] &&
 -	    nla_get_u8(data[IFLA_VXLAN_REMCSUM_RX]))
 -		vxlan->flags |= VXLAN_F_REMCSUM_RX;
 -
 -	if (data[IFLA_VXLAN_GBP])
 -		vxlan->flags |= VXLAN_F_GBP;
 -
  	if (vxlan_find_vni(net, vni, use_ipv6 ? AF_INET6 : AF_INET,
- 			   vxlan->dst_port)) {
+ 			   vxlan->dst_port, vxlan->flags)) {
  		pr_info("duplicate VNI %u\n", vni);
  		return -EEXIST;
  	}
* Unmerged path drivers/net/vxlan.c
diff --git a/include/net/vxlan.h b/include/net/vxlan.h
index 1ddc74769f81..1dfef1f448b6 100644
--- a/include/net/vxlan.h
+++ b/include/net/vxlan.h
@@ -34,6 +34,9 @@ struct vxlan_sock {
 #define VXLAN_F_UDP_ZERO_CSUM6_TX	0x80
 #define VXLAN_F_UDP_ZERO_CSUM6_RX	0x100
 
+/* These flags must match in order for a socket to be shareable */
+#define VXLAN_F_UNSHAREABLE		VXLAN_F_GBP
+
 struct vxlan_sock *vxlan_sock_add(struct net *net, __be16 port,
 				  vxlan_rcv_t *rcv, void *data,
 				  bool no_share, u32 flags);
