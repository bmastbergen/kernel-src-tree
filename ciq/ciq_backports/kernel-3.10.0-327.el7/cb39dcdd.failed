ACPI / LPSS: add all LPSS devices to the specific power domain

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [acpi] lpss: add all LPSS devices to the specific power domain (Prarit Bhargava) [1178891]
Rebuild_FUZZ: 94.02%
commit-author Andy Shevchenko <andriy.shevchenko@linux.intel.com>
commit cb39dcdd4ef6a31028ecd663768b99e6230d3ee6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/cb39dcdd.failed

Currently the LPSS devices are located in the different power domains depends
on LPSS_SAVE_CTX flag. We would like to use the specific power domain for all
LPSS devices.

The LPSS DMA controller has no knobs to control its power state. The specific
power domain implementation will handle this case. The patch does a preparation
for that.

	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Tested-by: Scott Ashcroft <scott.ashcroft@talk21.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit cb39dcdd4ef6a31028ecd663768b99e6230d3ee6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/acpi_lpss.c
diff --cc drivers/acpi/acpi_lpss.c
index 65baff6911fd,f6b71afb80ea..000000000000
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@@ -437,6 -495,144 +437,147 @@@ static void acpi_lpss_set_ltr(struct de
  	}
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_PM
+ /**
+  * acpi_lpss_save_ctx() - Save the private registers of LPSS device
+  * @dev: LPSS device
+  * @pdata: pointer to the private data of the LPSS device
+  *
+  * Most LPSS devices have private registers which may loose their context when
+  * the device is powered down. acpi_lpss_save_ctx() saves those registers into
+  * prv_reg_ctx array.
+  */
+ static void acpi_lpss_save_ctx(struct device *dev,
+ 			       struct lpss_private_data *pdata)
+ {
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < LPSS_PRV_REG_COUNT; i++) {
+ 		unsigned long offset = i * sizeof(u32);
+ 
+ 		pdata->prv_reg_ctx[i] = __lpss_reg_read(pdata, offset);
+ 		dev_dbg(dev, "saving 0x%08x from LPSS reg at offset 0x%02lx\n",
+ 			pdata->prv_reg_ctx[i], offset);
+ 	}
+ }
+ 
+ /**
+  * acpi_lpss_restore_ctx() - Restore the private registers of LPSS device
+  * @dev: LPSS device
+  * @pdata: pointer to the private data of the LPSS device
+  *
+  * Restores the registers that were previously stored with acpi_lpss_save_ctx().
+  */
+ static void acpi_lpss_restore_ctx(struct device *dev,
+ 				  struct lpss_private_data *pdata)
+ {
+ 	unsigned int i;
+ 
+ 	/*
+ 	 * The following delay is needed or the subsequent write operations may
+ 	 * fail. The LPSS devices are actually PCI devices and the PCI spec
+ 	 * expects 10ms delay before the device can be accessed after D3 to D0
+ 	 * transition.
+ 	 */
+ 	msleep(10);
+ 
+ 	for (i = 0; i < LPSS_PRV_REG_COUNT; i++) {
+ 		unsigned long offset = i * sizeof(u32);
+ 
+ 		__lpss_reg_write(pdata->prv_reg_ctx[i], pdata, offset);
+ 		dev_dbg(dev, "restoring 0x%08x to LPSS reg at offset 0x%02lx\n",
+ 			pdata->prv_reg_ctx[i], offset);
+ 	}
+ }
+ 
+ #ifdef CONFIG_PM_SLEEP
+ static int acpi_lpss_suspend_late(struct device *dev)
+ {
+ 	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
+ 	int ret;
+ 
+ 	ret = pm_generic_suspend_late(dev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (pdata->dev_desc->flags & LPSS_SAVE_CTX)
+ 		acpi_lpss_save_ctx(dev, pdata);
+ 
+ 	return acpi_dev_suspend_late(dev);
+ }
+ 
+ static int acpi_lpss_resume_early(struct device *dev)
+ {
+ 	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
+ 	int ret;
+ 
+ 	ret = acpi_dev_resume_early(dev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (pdata->dev_desc->flags & LPSS_SAVE_CTX)
+ 		acpi_lpss_restore_ctx(dev, pdata);
+ 
+ 	return pm_generic_resume_early(dev);
+ }
+ #endif /* CONFIG_PM_SLEEP */
+ 
+ #ifdef CONFIG_PM_RUNTIME
+ static int acpi_lpss_runtime_suspend(struct device *dev)
+ {
+ 	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
+ 	int ret;
+ 
+ 	ret = pm_generic_runtime_suspend(dev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (pdata->dev_desc->flags & LPSS_SAVE_CTX)
+ 		acpi_lpss_save_ctx(dev, pdata);
+ 
+ 	return acpi_dev_runtime_suspend(dev);
+ }
+ 
+ static int acpi_lpss_runtime_resume(struct device *dev)
+ {
+ 	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
+ 	int ret;
+ 
+ 	ret = acpi_dev_runtime_resume(dev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (pdata->dev_desc->flags & LPSS_SAVE_CTX)
+ 		acpi_lpss_restore_ctx(dev, pdata);
+ 
+ 	return pm_generic_runtime_resume(dev);
+ }
+ #endif /* CONFIG_PM_RUNTIME */
+ #endif /* CONFIG_PM */
+ 
+ static struct dev_pm_domain acpi_lpss_pm_domain = {
+ 	.ops = {
+ #ifdef CONFIG_PM_SLEEP
+ 		.prepare = acpi_subsys_prepare,
+ 		.complete = acpi_subsys_complete,
+ 		.suspend = acpi_subsys_suspend,
+ 		.suspend_late = acpi_lpss_suspend_late,
+ 		.resume_early = acpi_lpss_resume_early,
+ 		.freeze = acpi_subsys_freeze,
+ 		.poweroff = acpi_subsys_suspend,
+ 		.poweroff_late = acpi_lpss_suspend_late,
+ 		.restore_early = acpi_lpss_resume_early,
+ #endif
+ #ifdef CONFIG_PM_RUNTIME
+ 		.runtime_suspend = acpi_lpss_runtime_suspend,
+ 		.runtime_resume = acpi_lpss_runtime_resume,
+ #endif
+ 	},
+ };
+ 
++>>>>>>> cb39dcdd4ef6 (ACPI / LPSS: add all LPSS devices to the specific power domain)
  static int acpi_lpss_platform_notify(struct notifier_block *nb,
  				     unsigned long action, void *data)
  {
@@@ -454,20 -649,34 +595,45 @@@
  		return 0;
  
  	pdata = acpi_driver_data(adev);
++<<<<<<< HEAD
 +	if (!pdata || !pdata->mmio_base || !pdata->dev_desc->ltr_required)
++=======
+ 	if (!pdata)
++>>>>>>> cb39dcdd4ef6 (ACPI / LPSS: add all LPSS devices to the specific power domain)
  		return 0;
  
- 	if (pdata->mmio_size < pdata->dev_desc->prv_offset + LPSS_LTR_SIZE) {
+ 	if (pdata->mmio_base &&
+ 	    pdata->mmio_size < pdata->dev_desc->prv_offset + LPSS_LTR_SIZE) {
  		dev_err(&pdev->dev, "MMIO size insufficient to access LTR\n");
  		return 0;
  	}
  
++<<<<<<< HEAD
 +	if (action == BUS_NOTIFY_ADD_DEVICE)
 +		ret = sysfs_create_group(&pdev->dev.kobj, &lpss_attr_group);
 +	else if (action == BUS_NOTIFY_DEL_DEVICE)
 +		sysfs_remove_group(&pdev->dev.kobj, &lpss_attr_group);
++=======
+ 	switch (action) {
+ 	case BUS_NOTIFY_BOUND_DRIVER:
+ 		pdev->dev.pm_domain = &acpi_lpss_pm_domain;
+ 		break;
+ 	case BUS_NOTIFY_UNBOUND_DRIVER:
+ 		pdev->dev.pm_domain = NULL;
+ 		break;
+ 	case BUS_NOTIFY_ADD_DEVICE:
+ 		if (pdata->dev_desc->flags & LPSS_LTR)
+ 			return sysfs_create_group(&pdev->dev.kobj,
+ 						  &lpss_attr_group);
+ 	case BUS_NOTIFY_DEL_DEVICE:
+ 		if (pdata->dev_desc->flags & LPSS_LTR)
+ 			sysfs_remove_group(&pdev->dev.kobj, &lpss_attr_group);
+ 	default:
+ 		break;
+ 	}
++>>>>>>> cb39dcdd4ef6 (ACPI / LPSS: add all LPSS devices to the specific power domain)
  
 -	return 0;
 +	return ret;
  }
  
  static struct notifier_block acpi_lpss_nb = {
* Unmerged path drivers/acpi/acpi_lpss.c
