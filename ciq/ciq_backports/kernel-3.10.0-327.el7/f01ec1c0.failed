vxlan: add x-netns support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Nicolas Dichtel <nicolas.dichtel@6wind.com>
commit f01ec1c017dead42092997a2b8684fcab4cbf126
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/f01ec1c0.failed

This patch allows to switch the netns when packet is encapsulated or
decapsulated.
The vxlan socket is openned into the i/o netns, ie into the netns where
encapsulated packets are received. The socket lookup is done into this netns to
find the corresponding vxlan tunnel. After decapsulation, the packet is
injecting into the corresponding interface which may stand to another netns.

When one of the two netns is removed, the tunnel is destroyed.

Configuration example:
ip netns add netns1
ip netns exec netns1 ip link set lo up
ip link add vxlan10 type vxlan id 10 group 239.0.0.10 dev eth0 dstport 0
ip link set vxlan10 netns netns1
ip netns exec netns1 ip addr add 192.168.0.249/24 broadcast 192.168.0.255 dev vxlan10
ip netns exec netns1 ip link set vxlan10 up

	Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f01ec1c017dead42092997a2b8684fcab4cbf126)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
#	net/openvswitch/vport-vxlan.c
diff --cc drivers/net/vxlan.c
index 8aca95b53bbd,1dfee9a7fbf7..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1191,12 -1204,11 +1192,13 @@@ static void vxlan_rcv(struct vxlan_soc
  
  	remote_ip = &vxlan->default_dst.remote_ip;
  	skb_reset_mac_header(skb);
+ 	skb_scrub_packet(skb, !net_eq(vxlan->net, dev_net(vxlan->dev)));
  	skb->protocol = eth_type_trans(skb, vxlan->dev);
 +	skb_postpull_rcsum(skb, eth_hdr(skb), ETH_HLEN);
  
  	/* Ignore packet loops (and multicast echo) */
 -	if (ether_addr_equal(eth_hdr(skb)->h_source, vxlan->dev->dev_addr))
 +	if (compare_ether_addr(eth_hdr(skb)->h_source,
 +			       vxlan->dev->dev_addr) == 0)
  		goto drop;
  
  	/* Re-examine inner Ethernet packet */
@@@ -1590,9 -1629,12 +1593,18 @@@ static int vxlan6_xmit_skb(struct net *
  	int min_headroom;
  	int err;
  
++<<<<<<< HEAD
 +	skb = vxlan_handle_offloads(skb, !udp_get_no_check6_tx(vs->sock->sk));
 +	if (IS_ERR(skb))
 +		return -EINVAL;
++=======
+ 	if (!skb->encapsulation) {
+ 		skb_reset_inner_headers(skb);
+ 		skb->encapsulation = 1;
+ 	}
+ 
+ 	skb_scrub_packet(skb, xnet);
++>>>>>>> f01ec1c017de (vxlan: add x-netns support)
  
  	min_headroom = LL_RESERVED_SPACE(dst->dev) + dst->header_len
  			+ VXLAN_HLEN + sizeof(struct ipv6hdr)
@@@ -1653,10 -1711,10 +1665,10 @@@
  }
  #endif
  
 -int vxlan_xmit_skb(struct vxlan_sock *vs,
 +int vxlan_xmit_skb(struct net *net, struct vxlan_sock *vs,
  		   struct rtable *rt, struct sk_buff *skb,
  		   __be32 src, __be32 dst, __u8 tos, __u8 ttl, __be16 df,
- 		   __be16 src_port, __be16 dst_port, __be32 vni)
+ 		   __be16 src_port, __be16 dst_port, __be32 vni, bool xnet)
  {
  	struct vxlanhdr *vxh;
  	struct udphdr *uh;
@@@ -1697,12 -1756,14 +1709,16 @@@
  	uh->source = src_port;
  
  	uh->len = htons(skb->len);
 -	uh->check = 0;
  
 -	err = handle_offloads(skb);
 -	if (err)
 -		return err;
 +	udp_set_csum(vs->sock->sk->sk_no_check_tx, skb,
 +		     src, dst, skb->len);
  
  	return iptunnel_xmit(vs->sock->sk, rt, skb, src, dst, IPPROTO_UDP,
++<<<<<<< HEAD
 +			     tos, ttl, df);
++=======
+ 			     tos, ttl, df, xnet);
++>>>>>>> f01ec1c017de (vxlan: add x-netns support)
  }
  EXPORT_SYMBOL_GPL(vxlan_xmit_skb);
  
@@@ -1816,8 -1877,7 +1832,12 @@@ static void vxlan_xmit_one(struct sk_bu
  			struct vxlan_dev *dst_vxlan;
  
  			ip_rt_put(rt);
++<<<<<<< HEAD
 +			dst_vxlan = vxlan_find_vni(dev_net(dev), vni,
 +						   dst->sa.sa_family, dst_port);
++=======
+ 			dst_vxlan = vxlan_find_vni(vxlan->net, vni, dst_port);
++>>>>>>> f01ec1c017de (vxlan: add x-netns support)
  			if (!dst_vxlan)
  				goto tx_error;
  			vxlan_encap_bypass(skb, vxlan, dst_vxlan);
@@@ -1827,10 -1887,11 +1847,11 @@@
  		tos = ip_tunnel_ecn_encap(tos, old_iph, skb);
  		ttl = ttl ? : ip4_dst_hoplimit(&rt->dst);
  
 -		err = vxlan_xmit_skb(vxlan->vn_sock, rt, skb,
 +		err = vxlan_xmit_skb(dev_net(dev), vxlan->vn_sock, rt, skb,
  				     fl4.saddr, dst->sin.sin_addr.s_addr,
  				     tos, ttl, df, src_port, dst_port,
- 				     htonl(vni << 8));
+ 				     htonl(vni << 8),
+ 				     !net_eq(vxlan->net, dev_net(vxlan->dev)));
  
  		if (err < 0)
  			goto rt_tx_error;
@@@ -1870,8 -1931,7 +1891,12 @@@
  			struct vxlan_dev *dst_vxlan;
  
  			dst_release(ndst);
++<<<<<<< HEAD
 +			dst_vxlan = vxlan_find_vni(dev_net(dev), vni,
 +						   dst->sa.sa_family, dst_port);
++=======
+ 			dst_vxlan = vxlan_find_vni(vxlan->net, vni, dst_port);
++>>>>>>> f01ec1c017de (vxlan: add x-netns support)
  			if (!dst_vxlan)
  				goto tx_error;
  			vxlan_encap_bypass(skb, vxlan, dst_vxlan);
@@@ -1880,9 -1940,10 +1905,10 @@@
  
  		ttl = ttl ? : ip6_dst_hoplimit(ndst);
  
 -		err = vxlan6_xmit_skb(vxlan->vn_sock, ndst, skb,
 +		err = vxlan6_xmit_skb(dev_net(dev), vxlan->vn_sock, ndst, skb,
  				      dev, &fl6.saddr, &fl6.daddr, 0, ttl,
- 				      src_port, dst_port, htonl(vni << 8));
+ 				      src_port, dst_port, htonl(vni << 8),
+ 				      !net_eq(vxlan->net, dev_net(vxlan->dev)));
  #endif
  	}
  
@@@ -2026,17 -2087,15 +2052,21 @@@ static void vxlan_vs_add_dev(struct vxl
  static int vxlan_init(struct net_device *dev)
  {
  	struct vxlan_dev *vxlan = netdev_priv(dev);
- 	struct vxlan_net *vn = net_generic(dev_net(dev), vxlan_net_id);
+ 	struct vxlan_net *vn = net_generic(vxlan->net, vxlan_net_id);
  	struct vxlan_sock *vs;
 +	bool ipv6 = vxlan->flags & VXLAN_F_IPV6;
  
 -	dev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);
 +	dev->tstats = alloc_percpu(struct pcpu_tstats);
  	if (!dev->tstats)
  		return -ENOMEM;
  
  	spin_lock(&vn->sock_lock);
++<<<<<<< HEAD
 +	vs = vxlan_find_sock(dev_net(dev), ipv6 ? AF_INET6 : AF_INET,
 +			     vxlan->dst_port);
++=======
+ 	vs = vxlan_find_sock(vxlan->net, vxlan->dst_port);
++>>>>>>> f01ec1c017de (vxlan: add x-netns support)
  	if (vs) {
  		/* If we have a socket with same port already, reuse it */
  		atomic_inc(&vs->refcnt);
diff --cc net/openvswitch/vport-vxlan.c
index 64e0d2e57017,21cceb3bdf78..000000000000
--- a/net/openvswitch/vport-vxlan.c
+++ b/net/openvswitch/vport-vxlan.c
@@@ -172,13 -172,16 +172,18 @@@ static int vxlan_tnl_send(struct vport 
  
  	skb->local_df = 1;
  
 -	inet_get_local_port_range(net, &port_min, &port_max);
 -	src_port = vxlan_src_port(port_min, port_max, skb);
 +	src_port = udp_flow_src_port(net, skb, 0, 0, true);
  
 -	err = vxlan_xmit_skb(vxlan_port->vs, rt, skb,
 -			     fl.saddr, OVS_CB(skb)->tun_key->ipv4_dst,
 -			     OVS_CB(skb)->tun_key->ipv4_tos,
 -			     OVS_CB(skb)->tun_key->ipv4_ttl, df,
 +	err = vxlan_xmit_skb(net, vxlan_port->vs, rt, skb,
 +			     fl.saddr, tun_key->ipv4_dst,
 +			     tun_key->ipv4_tos, tun_key->ipv4_ttl, df,
  			     src_port, dst_port,
++<<<<<<< HEAD
 +			     htonl(be64_to_cpu(tun_key->tun_id) << 8));
++=======
+ 			     htonl(be64_to_cpu(OVS_CB(skb)->tun_key->tun_id) << 8),
+ 			     false);
++>>>>>>> f01ec1c017de (vxlan: add x-netns support)
  	if (err < 0)
  		ip_rt_put(rt);
  error:
* Unmerged path drivers/net/vxlan.c
diff --git a/include/net/vxlan.h b/include/net/vxlan.h
index 1ddc74769f81..3c793b9a5331 100644
--- a/include/net/vxlan.h
+++ b/include/net/vxlan.h
@@ -43,7 +43,7 @@ void vxlan_sock_release(struct vxlan_sock *vs);
 int vxlan_xmit_skb(struct net *net, struct vxlan_sock *vs,
 		   struct rtable *rt, struct sk_buff *skb,
 		   __be32 src, __be32 dst, __u8 tos, __u8 ttl, __be16 df,
-		   __be16 src_port, __be16 dst_port, __be32 vni);
+		   __be16 src_port, __be16 dst_port, __be32 vni, bool xnet);
 
 /* IP header + UDP + VXLAN + Ethernet header */
 #define VXLAN_HEADROOM (20 + 8 + 8 + 14)
* Unmerged path net/openvswitch/vport-vxlan.c
