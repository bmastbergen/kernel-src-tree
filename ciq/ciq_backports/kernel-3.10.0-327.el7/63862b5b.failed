net: replace macros net_random and net_srandom with direct calls to prandom

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] openvswitch: replace macros net_random and net_srandom with direct calls to prandom (Jiri Benc) [1156461 1211348]
Rebuild_FUZZ: 93.67%
commit-author Aruna-Hewapathirane <aruna.hewapathirane@gmail.com>
commit 63862b5bef7349dd1137e4c70702c67d77565785
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/63862b5b.failed

This patch removes the net_random and net_srandom macros and replaces
them with direct calls to the prandom ones. As new commits only seem to
use prandom_u32 there is no use to keep them around.
This change makes it easier to grep for users of prandom_u32.

	Signed-off-by: Aruna-Hewapathirane <aruna.hewapathirane@gmail.com>
	Suggested-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 63862b5bef7349dd1137e4c70702c67d77565785)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/net.h
#	net/sched/sch_hhf.c
#	net/sched/sch_netem.c
#	net/sched/sch_pie.c
#	net/xfrm/xfrm_state.c
diff --cc include/linux/net.h
index 6822d99f6b2e,94734a6259a4..000000000000
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@@ -252,35 -245,52 +252,40 @@@ do {								
  #define net_dbg_ratelimited(fmt, ...)				\
  	net_ratelimited_function(pr_debug, fmt, ##__VA_ARGS__)
  
++<<<<<<< HEAD
 +#define net_random()		prandom_u32()
 +#define net_srandom(seed)	prandom_seed((__force u32)(seed))
 +
 +extern int   	     kernel_sendmsg(struct socket *sock, struct msghdr *msg,
 +				    struct kvec *vec, size_t num, size_t len);
 +extern int   	     kernel_recvmsg(struct socket *sock, struct msghdr *msg,
 +				    struct kvec *vec, size_t num,
 +				    size_t len, int flags);
++=======
+ bool __net_get_random_once(void *buf, int nbytes, bool *done,
+ 			   struct static_key *done_key);
 -
 -#ifdef HAVE_JUMP_LABEL
 -#define ___NET_RANDOM_STATIC_KEY_INIT ((struct static_key) \
 -		{ .enabled = ATOMIC_INIT(0), .entries = (void *)1 })
 -#else /* !HAVE_JUMP_LABEL */
 -#define ___NET_RANDOM_STATIC_KEY_INIT STATIC_KEY_INIT_FALSE
 -#endif /* HAVE_JUMP_LABEL */
 -
 -#define net_get_random_once(buf, nbytes)				\
 -	({								\
 -		bool ___ret = false;					\
 -		static bool ___done = false;				\
 -		static struct static_key ___done_key =			\
 -			___NET_RANDOM_STATIC_KEY_INIT;			\
 -		if (!static_key_true(&___done_key))			\
 -			___ret = __net_get_random_once(buf,		\
 -						       nbytes,		\
 -						       &___done,	\
 -						       &___done_key);	\
 -		___ret;							\
 -	})
 -
 -int kernel_sendmsg(struct socket *sock, struct msghdr *msg, struct kvec *vec,
 -		   size_t num, size_t len);
 -int kernel_recvmsg(struct socket *sock, struct msghdr *msg, struct kvec *vec,
 -		   size_t num, size_t len, int flags);
 -
 -int kernel_bind(struct socket *sock, struct sockaddr *addr, int addrlen);
 -int kernel_listen(struct socket *sock, int backlog);
 -int kernel_accept(struct socket *sock, struct socket **newsock, int flags);
 -int kernel_connect(struct socket *sock, struct sockaddr *addr, int addrlen,
 -		   int flags);
 -int kernel_getsockname(struct socket *sock, struct sockaddr *addr,
 -		       int *addrlen);
 -int kernel_getpeername(struct socket *sock, struct sockaddr *addr,
 -		       int *addrlen);
 -int kernel_getsockopt(struct socket *sock, int level, int optname, char *optval,
 -		      int *optlen);
 -int kernel_setsockopt(struct socket *sock, int level, int optname, char *optval,
 -		      unsigned int optlen);
 -int kernel_sendpage(struct socket *sock, struct page *page, int offset,
 -		    size_t size, int flags);
 -int kernel_sock_ioctl(struct socket *sock, int cmd, unsigned long arg);
 -int kernel_sock_shutdown(struct socket *sock, enum sock_shutdown_cmd how);
++>>>>>>> 63862b5bef73 (net: replace macros net_random and net_srandom with direct calls to prandom)
 +
 +extern int kernel_bind(struct socket *sock, struct sockaddr *addr,
 +		       int addrlen);
 +extern int kernel_listen(struct socket *sock, int backlog);
 +extern int kernel_accept(struct socket *sock, struct socket **newsock,
 +			 int flags);
 +extern int kernel_connect(struct socket *sock, struct sockaddr *addr,
 +			  int addrlen, int flags);
 +extern int kernel_getsockname(struct socket *sock, struct sockaddr *addr,
 +			      int *addrlen);
 +extern int kernel_getpeername(struct socket *sock, struct sockaddr *addr,
 +			      int *addrlen);
 +extern int kernel_getsockopt(struct socket *sock, int level, int optname,
 +			     char *optval, int *optlen);
 +extern int kernel_setsockopt(struct socket *sock, int level, int optname,
 +			     char *optval, unsigned int optlen);
 +extern int kernel_sendpage(struct socket *sock, struct page *page, int offset,
 +			   size_t size, int flags);
 +extern int kernel_sock_ioctl(struct socket *sock, int cmd, unsigned long arg);
 +extern int kernel_sock_shutdown(struct socket *sock,
 +				enum sock_shutdown_cmd how);
  
  #define MODULE_ALIAS_NETPROTO(proto) \
  	MODULE_ALIAS("net-pf-" __stringify(proto))
diff --cc net/sched/sch_netem.c
index bcfe93ffecd7,3019c10d6c56..000000000000
--- a/net/sched/sch_netem.c
+++ b/net/sched/sch_netem.c
@@@ -238,14 -264,15 +238,18 @@@ static bool loss_gilb_ell(struct netem_
  
  	switch (clg->state) {
  	case 1:
- 		if (net_random() < clg->a1)
+ 		if (prandom_u32() < clg->a1)
  			clg->state = 2;
- 		if (net_random() < clg->a4)
+ 		if (prandom_u32() < clg->a4)
  			return true;
 -		break;
  	case 2:
- 		if (net_random() < clg->a2)
+ 		if (prandom_u32() < clg->a2)
  			clg->state = 1;
++<<<<<<< HEAD
 +		if (clg->a3 > net_random())
++=======
+ 		if (prandom_u32() > clg->a3)
++>>>>>>> 63862b5bef73 (net: replace macros net_random and net_srandom with direct calls to prandom)
  			return true;
  	}
  
diff --cc net/xfrm/xfrm_state.c
index 966fad6f7859,8d11d28991a4..000000000000
--- a/net/xfrm/xfrm_state.c
+++ b/net/xfrm/xfrm_state.c
@@@ -1525,8 -1564,8 +1525,13 @@@ int xfrm_alloc_spi(struct xfrm_state *x
  		x->id.spi = minspi;
  	} else {
  		u32 spi = 0;
++<<<<<<< HEAD
 +		for (h=0; h<high-low+1; h++) {
 +			spi = low + net_random()%(high-low+1);
++=======
+ 		for (h = 0; h < high-low+1; h++) {
+ 			spi = low + prandom_u32()%(high-low+1);
++>>>>>>> 63862b5bef73 (net: replace macros net_random and net_srandom with direct calls to prandom)
  			x0 = xfrm_state_lookup(net, mark, &x->id.daddr, htonl(spi), x->id.proto, x->props.family);
  			if (x0 == NULL) {
  				x->id.spi = htonl(spi);
* Unmerged path net/sched/sch_hhf.c
* Unmerged path net/sched/sch_pie.c
diff --git a/drivers/infiniband/core/cma.c b/drivers/infiniband/core/cma.c
index ff4330398975..ba2598706778 100644
--- a/drivers/infiniband/core/cma.c
+++ b/drivers/infiniband/core/cma.c
@@ -2348,7 +2348,7 @@ static int cma_alloc_any_port(struct idr *ps, struct rdma_id_private *id_priv)
 
 	inet_get_local_port_range(&low, &high);
 	remaining = (high - low) + 1;
-	rover = net_random() % remaining + low;
+	rover = prandom_u32() % remaining + low;
 retry:
 	if (last_used_port != rover &&
 	    !idr_find(ps, (unsigned short) rover)) {
* Unmerged path include/linux/net.h
diff --git a/include/net/red.h b/include/net/red.h
index fe36ac594d18..76e0b5f922c6 100644
--- a/include/net/red.h
+++ b/include/net/red.h
@@ -304,7 +304,7 @@ static inline unsigned long red_calc_qavg(const struct red_parms *p,
 
 static inline u32 red_random(const struct red_parms *p)
 {
-	return reciprocal_divide(net_random(), p->max_P_reciprocal);
+	return reciprocal_divide(prandom_u32(), p->max_P_reciprocal);
 }
 
 static inline int red_mark_probability(const struct red_parms *p,
diff --git a/net/802/garp.c b/net/802/garp.c
index 5d9630a0eb93..b38ee6dcba45 100644
--- a/net/802/garp.c
+++ b/net/802/garp.c
@@ -397,7 +397,7 @@ static void garp_join_timer_arm(struct garp_applicant *app)
 {
 	unsigned long delay;
 
-	delay = (u64)msecs_to_jiffies(garp_join_time) * net_random() >> 32;
+	delay = (u64)msecs_to_jiffies(garp_join_time) * prandom_u32() >> 32;
 	mod_timer(&app->join_timer, jiffies + delay);
 }
 
diff --git a/net/802/mrp.c b/net/802/mrp.c
index 1eb05d80b07b..f47f120b0987 100644
--- a/net/802/mrp.c
+++ b/net/802/mrp.c
@@ -578,7 +578,7 @@ static void mrp_join_timer_arm(struct mrp_applicant *app)
 {
 	unsigned long delay;
 
-	delay = (u64)msecs_to_jiffies(mrp_join_time) * net_random() >> 32;
+	delay = (u64)msecs_to_jiffies(mrp_join_time) * prandom_u32() >> 32;
 	mod_timer(&app->join_timer, jiffies + delay);
 }
 
diff --git a/net/core/neighbour.c b/net/core/neighbour.c
index 71092bad43dc..8fc6b6a2a1eb 100644
--- a/net/core/neighbour.c
+++ b/net/core/neighbour.c
@@ -117,7 +117,7 @@ static void neigh_cleanup_and_release(struct neighbour *neigh)
 
 unsigned long neigh_rand_reach_time(unsigned long base)
 {
-	return base ? (net_random() % base) + (base >> 1) : 0;
+	return base ? (prandom_u32() % base) + (base >> 1) : 0;
 }
 EXPORT_SYMBOL(neigh_rand_reach_time);
 
@@ -1415,7 +1415,8 @@ void pneigh_enqueue(struct neigh_table *tbl, struct neigh_parms *p,
 		    struct sk_buff *skb)
 {
 	unsigned long now = jiffies;
-	unsigned long sched_next = now + (net_random() %
+
+	unsigned long sched_next = now + (prandom_u32() %
 					  NEIGH_VAR(p, PROXY_DELAY));
 
 	if (tbl->proxy_queue.qlen > NEIGH_VAR(p, PROXY_QLEN)) {
diff --git a/net/core/stream.c b/net/core/stream.c
index f5df85dcd20b..6881f0c0805e 100644
--- a/net/core/stream.c
+++ b/net/core/stream.c
@@ -122,7 +122,7 @@ int sk_stream_wait_memory(struct sock *sk, long *timeo_p)
 	DEFINE_WAIT(wait);
 
 	if (sk_stream_memory_free(sk))
-		current_timeo = vm_wait = (net_random() % (HZ / 5)) + 2;
+		current_timeo = vm_wait = (prandom_u32() % (HZ / 5)) + 2;
 
 	while (1) {
 		set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);
diff --git a/net/ipv4/devinet.c b/net/ipv4/devinet.c
index 0da4dc8f4743..11b01333a44c 100644
--- a/net/ipv4/devinet.c
+++ b/net/ipv4/devinet.c
@@ -459,7 +459,7 @@ static int __inet_insert_ifa(struct in_ifaddr *ifa, struct nlmsghdr *nlh,
 	}
 
 	if (!(ifa->ifa_flags & IFA_F_SECONDARY)) {
-		net_srandom(ifa->ifa_local);
+		prandom_seed((__force u32) ifa->ifa_local);
 		ifap = last_primary;
 	}
 
diff --git a/net/ipv4/igmp.c b/net/ipv4/igmp.c
index b15ffcfd3055..2b75ad8520d0 100644
--- a/net/ipv4/igmp.c
+++ b/net/ipv4/igmp.c
@@ -187,7 +187,7 @@ static void igmp_stop_timer(struct ip_mc_list *im)
 /* It must be called with locked im->lock */
 static void igmp_start_timer(struct ip_mc_list *im, int max_delay)
 {
-	int tv = net_random() % max_delay;
+	int tv = prandom_u32() % max_delay;
 
 	im->tm_running = 1;
 	if (!mod_timer(&im->timer, jiffies+tv+2))
@@ -196,7 +196,7 @@ static void igmp_start_timer(struct ip_mc_list *im, int max_delay)
 
 static void igmp_gq_start_timer(struct in_device *in_dev)
 {
-	int tv = net_random() % in_dev->mr_maxdelay;
+	int tv = prandom_u32() % in_dev->mr_maxdelay;
 
 	in_dev->mr_gq_running = 1;
 	if (!mod_timer(&in_dev->mr_gq_timer, jiffies+tv+2))
@@ -205,7 +205,7 @@ static void igmp_gq_start_timer(struct in_device *in_dev)
 
 static void igmp_ifc_start_timer(struct in_device *in_dev, int delay)
 {
-	int tv = net_random() % delay;
+	int tv = prandom_u32() % delay;
 
 	if (!mod_timer(&in_dev->mr_ifc_timer, jiffies+tv+2))
 		in_dev_hold(in_dev);
diff --git a/net/ipv4/inet_connection_sock.c b/net/ipv4/inet_connection_sock.c
index 07622a4e3fa4..96b01665b9cd 100644
--- a/net/ipv4/inet_connection_sock.c
+++ b/net/ipv4/inet_connection_sock.c
@@ -117,7 +117,7 @@ int inet_csk_get_port(struct sock *sk, unsigned short snum)
 again:
 		inet_get_local_port_range(&low, &high);
 		remaining = (high - low) + 1;
-		smallest_rover = rover = net_random() % remaining + low;
+		smallest_rover = rover = prandom_u32() % remaining + low;
 
 		smallest_size = -1;
 		do {
diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index 8d174c3136c6..d1d1706992a5 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -223,7 +223,7 @@ int udp_lib_get_port(struct sock *sk, unsigned short snum,
 		inet_get_local_port_range(&low, &high);
 		remaining = (high - low) + 1;
 
-		rand = net_random();
+		rand = prandom_u32();
 		first = (((u64)rand * remaining) >> 32) + low;
 		/*
 		 * force rand to be an odd multiple of UDP_HTABLE_SIZE
diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c
index 59933e5a5db9..5297c4735a60 100644
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@ -3173,7 +3173,7 @@ static void addrconf_dad_kick(struct inet6_ifaddr *ifp)
 	if (ifp->flags & IFA_F_OPTIMISTIC)
 		rand_num = 0;
 	else
-		rand_num = net_random() % (idev->cnf.rtr_solicit_delay ? : 1);
+		rand_num = prandom_u32() % (idev->cnf.rtr_solicit_delay ? : 1);
 
 	ifp->dad_probes = idev->cnf.dad_transmits;
 	addrconf_mod_dad_work(ifp, rand_num);
@@ -3186,7 +3186,7 @@ static void addrconf_dad_begin(struct inet6_ifaddr *ifp)
 
 	addrconf_join_solict(dev, &ifp->addr);
 
-	net_srandom(ifp->addr.s6_addr32[3]);
+	prandom_seed((__force u32) ifp->addr.s6_addr32[3]);
 
 	read_lock_bh(&idev->lock);
 	spin_lock(&ifp->lock);
diff --git a/net/ipv6/ip6_flowlabel.c b/net/ipv6/ip6_flowlabel.c
index 76fb26cd1d8c..dee856073350 100644
--- a/net/ipv6/ip6_flowlabel.c
+++ b/net/ipv6/ip6_flowlabel.c
@@ -210,7 +210,7 @@ static struct ip6_flowlabel *fl_intern(struct net *net,
 	spin_lock_bh(&ip6_fl_lock);
 	if (label == 0) {
 		for (;;) {
-			fl->label = htonl(net_random())&IPV6_FLOWLABEL_MASK;
+			fl->label = htonl(prandom_u32())&IPV6_FLOWLABEL_MASK;
 			if (fl->label) {
 				lfl = __fl_lookup(net, fl->label);
 				if (lfl == NULL)
diff --git a/net/ipv6/mcast.c b/net/ipv6/mcast.c
index 8c315d7cece8..13097f9806bd 100644
--- a/net/ipv6/mcast.c
+++ b/net/ipv6/mcast.c
@@ -1000,7 +1000,7 @@ bool ipv6_chk_mcast_addr(struct net_device *dev, const struct in6_addr *group,
 
 static void mld_gq_start_timer(struct inet6_dev *idev)
 {
-	unsigned long tv = net_random() % idev->mc_maxdelay;
+	unsigned long tv = prandom_u32() % idev->mc_maxdelay;
 
 	idev->mc_gq_running = 1;
 	if (!mod_timer(&idev->mc_gq_timer, jiffies+tv+2))
@@ -1016,7 +1016,7 @@ static void mld_gq_stop_timer(struct inet6_dev *idev)
 
 static void mld_ifc_start_timer(struct inet6_dev *idev, unsigned long delay)
 {
-	unsigned long tv = net_random() % delay;
+	unsigned long tv = prandom_u32() % delay;
 
 	if (!mod_timer(&idev->mc_ifc_timer, jiffies+tv+2))
 		in6_dev_hold(idev);
@@ -1031,7 +1031,7 @@ static void mld_ifc_stop_timer(struct inet6_dev *idev)
 
 static void mld_dad_start_timer(struct inet6_dev *idev, unsigned long delay)
 {
-	unsigned long tv = net_random() % delay;
+	unsigned long tv = prandom_u32() % delay;
 
 	if (!mod_timer(&idev->mc_dad_timer, jiffies+tv+2))
 		in6_dev_hold(idev);
@@ -1062,7 +1062,7 @@ static void igmp6_group_queried(struct ifmcaddr6 *ma, unsigned long resptime)
 	}
 
 	if (delay >= resptime)
-		delay = net_random() % resptime;
+		delay = prandom_u32() % resptime;
 
 	ma->mca_timer.expires = jiffies + delay;
 	if (!mod_timer(&ma->mca_timer, jiffies + delay))
@@ -2370,7 +2370,7 @@ static void igmp6_join_group(struct ifmcaddr6 *ma)
 
 	igmp6_send(&ma->mca_addr, ma->idev->dev, ICMPV6_MGM_REPORT);
 
-	delay = net_random() % unsolicited_report_interval(ma->idev);
+	delay = prandom_u32() % unsolicited_report_interval(ma->idev);
 
 	spin_lock_bh(&ma->mca_lock);
 	if (del_timer(&ma->mca_timer)) {
diff --git a/net/netfilter/ipvs/ip_vs_conn.c b/net/netfilter/ipvs/ip_vs_conn.c
index e884d1767626..7eb88a3a6214 100644
--- a/net/netfilter/ipvs/ip_vs_conn.c
+++ b/net/netfilter/ipvs/ip_vs_conn.c
@@ -1210,7 +1210,7 @@ void ip_vs_random_dropentry(struct net *net)
 	 * Randomly scan 1/32 of the whole table every second
 	 */
 	for (idx = 0; idx < (ip_vs_conn_tab_size>>5); idx++) {
-		unsigned int hash = net_random() & ip_vs_conn_tab_mask;
+		unsigned int hash = prandom_u32() & ip_vs_conn_tab_mask;
 
 		/*
 		 *  Lock is actually needed in this loop.
diff --git a/net/netfilter/xt_statistic.c b/net/netfilter/xt_statistic.c
index 4fe4fb4276d0..11de55e7a868 100644
--- a/net/netfilter/xt_statistic.c
+++ b/net/netfilter/xt_statistic.c
@@ -37,7 +37,7 @@ statistic_mt(const struct sk_buff *skb, struct xt_action_param *par)
 
 	switch (info->mode) {
 	case XT_STATISTIC_MODE_RANDOM:
-		if ((net_random() & 0x7FFFFFFF) < info->u.random.probability)
+		if ((prandom_u32() & 0x7FFFFFFF) < info->u.random.probability)
 			ret = !ret;
 		break;
 	case XT_STATISTIC_MODE_NTH:
diff --git a/net/openvswitch/actions.c b/net/openvswitch/actions.c
index e6e6d775efa0..6932a42e41a2 100644
--- a/net/openvswitch/actions.c
+++ b/net/openvswitch/actions.c
@@ -520,7 +520,7 @@ static int sample(struct datapath *dp, struct sk_buff *skb,
 		 a = nla_next(a, &rem)) {
 		switch (nla_type(a)) {
 		case OVS_SAMPLE_ATTR_PROBABILITY:
-			if (net_random() >= nla_get_u32(a))
+			if (prandom_u32() >= nla_get_u32(a))
 				return 0;
 			break;
 
diff --git a/net/rds/bind.c b/net/rds/bind.c
index b5ad65a0067e..a2e6562da751 100644
--- a/net/rds/bind.c
+++ b/net/rds/bind.c
@@ -117,7 +117,7 @@ static int rds_add_bound(struct rds_sock *rs, __be32 addr, __be16 *port)
 		rover = be16_to_cpu(*port);
 		last = rover;
 	} else {
-		rover = max_t(u16, net_random(), 2);
+		rover = max_t(u16, prandom_u32(), 2);
 		last = rover - 1;
 	}
 
diff --git a/net/sched/act_gact.c b/net/sched/act_gact.c
index fd2b3cff5fa2..1f9a6ac7b8eb 100644
--- a/net/sched/act_gact.c
+++ b/net/sched/act_gact.c
@@ -37,7 +37,7 @@ static struct tcf_hashinfo gact_hash_info = {
 #ifdef CONFIG_GACT_PROB
 static int gact_net_rand(struct tcf_gact *gact)
 {
-	if (!gact->tcfg_pval || net_random() % gact->tcfg_pval)
+	if (!gact->tcfg_pval || prandom_u32() % gact->tcfg_pval)
 		return gact->tcf_action;
 	return gact->tcfg_paction;
 }
diff --git a/net/sched/sch_fq_codel.c b/net/sched/sch_fq_codel.c
index 55786283a3df..ba5bc929eac7 100644
--- a/net/sched/sch_fq_codel.c
+++ b/net/sched/sch_fq_codel.c
@@ -390,7 +390,7 @@ static int fq_codel_init(struct Qdisc *sch, struct nlattr *opt)
 	sch->limit = 10*1024;
 	q->flows_cnt = 1024;
 	q->quantum = psched_mtu(qdisc_dev(sch));
-	q->perturbation = net_random();
+	q->perturbation = prandom_u32();
 	INIT_LIST_HEAD(&q->new_flows);
 	INIT_LIST_HEAD(&q->old_flows);
 	codel_params_init(&q->cparams);
* Unmerged path net/sched/sch_hhf.c
* Unmerged path net/sched/sch_netem.c
* Unmerged path net/sched/sch_pie.c
diff --git a/net/sched/sch_sfb.c b/net/sched/sch_sfb.c
index 30ea4674cabd..9b0f7093d970 100644
--- a/net/sched/sch_sfb.c
+++ b/net/sched/sch_sfb.c
@@ -220,7 +220,7 @@ static u32 sfb_compute_qlen(u32 *prob_r, u32 *avgpm_r, const struct sfb_sched_da
 
 static void sfb_init_perturbation(u32 slot, struct sfb_sched_data *q)
 {
-	q->bins[slot].perturbation = net_random();
+	q->bins[slot].perturbation = prandom_u32();
 }
 
 static void sfb_swap_slot(struct sfb_sched_data *q)
@@ -381,7 +381,7 @@ static int sfb_enqueue(struct sk_buff *skb, struct Qdisc *sch)
 		goto enqueue;
 	}
 
-	r = net_random() & SFB_MAX_PROB;
+	r = prandom_u32() & SFB_MAX_PROB;
 
 	if (unlikely(r < p_min)) {
 		if (unlikely(p_min > SFB_MAX_PROB / 2)) {
diff --git a/net/sched/sch_sfq.c b/net/sched/sch_sfq.c
index d3a1bc26dbfc..921130e69be4 100644
--- a/net/sched/sch_sfq.c
+++ b/net/sched/sch_sfq.c
@@ -627,7 +627,7 @@ static void sfq_perturbation(unsigned long arg)
 	spinlock_t *root_lock = qdisc_lock(qdisc_root_sleeping(sch));
 
 	spin_lock(root_lock);
-	q->perturbation = net_random();
+	q->perturbation = prandom_u32();
 	if (!q->filter_list && q->tail)
 		sfq_rehash(sch);
 	spin_unlock(root_lock);
@@ -696,7 +696,7 @@ static int sfq_change(struct Qdisc *sch, struct nlattr *opt)
 	del_timer(&q->perturb_timer);
 	if (q->perturb_period) {
 		mod_timer(&q->perturb_timer, jiffies + q->perturb_period);
-		q->perturbation = net_random();
+		q->perturbation = prandom_u32();
 	}
 	sch_tree_unlock(sch);
 	kfree(p);
@@ -757,7 +757,7 @@ static int sfq_init(struct Qdisc *sch, struct nlattr *opt)
 	q->quantum = psched_mtu(qdisc_dev(sch));
 	q->scaled_quantum = SFQ_ALLOT_SIZE(q->quantum);
 	q->perturb_period = 0;
-	q->perturbation = net_random();
+	q->perturbation = prandom_u32();
 
 	if (opt) {
 		int err = sfq_change(sch, opt);
diff --git a/net/sctp/socket.c b/net/sctp/socket.c
index 3f52f2a398da..d2024c96bb1e 100644
--- a/net/sctp/socket.c
+++ b/net/sctp/socket.c
@@ -5929,7 +5929,7 @@ static long sctp_get_port_local(struct sock *sk, union sctp_addr *addr)
 
 		inet_get_local_port_range(&low, &high);
 		remaining = (high - low) + 1;
-		rover = net_random() % remaining + low;
+		rover = prandom_u32() % remaining + low;
 
 		do {
 			rover++;
diff --git a/net/sunrpc/cache.c b/net/sunrpc/cache.c
index a72de074172d..e521d20e1970 100644
--- a/net/sunrpc/cache.c
+++ b/net/sunrpc/cache.c
@@ -619,7 +619,7 @@ static void cache_limit_defers(void)
 
 	/* Consider removing either the first or the last */
 	if (cache_defer_cnt > DFR_MAX) {
-		if (net_random() & 1)
+		if (prandom_u32() & 1)
 			discard = list_entry(cache_defer_list.next,
 					     struct cache_deferred_req, recent);
 		else
diff --git a/net/sunrpc/xprt.c b/net/sunrpc/xprt.c
index dc83880236d8..6e6b4c90edc5 100644
--- a/net/sunrpc/xprt.c
+++ b/net/sunrpc/xprt.c
@@ -1184,7 +1184,7 @@ static inline __be32 xprt_alloc_xid(struct rpc_xprt *xprt)
 
 static inline void xprt_init_xid(struct rpc_xprt *xprt)
 {
-	xprt->xid = net_random();
+	xprt->xid = prandom_u32();
 }
 
 static void xprt_request_init(struct rpc_task *task, struct rpc_xprt *xprt)
diff --git a/net/sunrpc/xprtsock.c b/net/sunrpc/xprtsock.c
index d6c816543368..e3a6c6dab643 100644
--- a/net/sunrpc/xprtsock.c
+++ b/net/sunrpc/xprtsock.c
@@ -1713,7 +1713,7 @@ static void xs_udp_timer(struct rpc_xprt *xprt, struct rpc_task *task)
 static unsigned short xs_get_random_port(void)
 {
 	unsigned short range = xprt_max_resvport - xprt_min_resvport;
-	unsigned short rand = (unsigned short) net_random() % range;
+	unsigned short rand = (unsigned short) prandom_u32() % range;
 	return rand + xprt_min_resvport;
 }
 
* Unmerged path net/xfrm/xfrm_state.c
