sfc: Ensure down_write(&filter_sem) and up_write() are matched before calling efx_net_open()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Shradha Shah <sshah@solarflare.com>
commit 671b53eec2edcbfac3e53d02cf3d0c6d9ecc07de
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/671b53ee.failed

This patch avoids the double up_write to filter_sem if
efx_net_open() fails.

Resolves: 2d432f20d27c1813a2746008e16dd6ce12a14dc1

	Signed-off-by: Shradha Shah <sshah@solarflare.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 671b53eec2edcbfac3e53d02cf3d0c6d9ecc07de)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/sfc/ef10_sriov.c
diff --cc drivers/net/ethernet/sfc/ef10_sriov.c
index 9e6a3e197e01,3c17f274e802..000000000000
--- a/drivers/net/ethernet/sfc/ef10_sriov.c
+++ b/drivers/net/ethernet/sfc/ef10_sriov.c
@@@ -41,12 -401,346 +41,353 @@@ static int efx_ef10_pci_sriov_disable(s
  
  int efx_ef10_sriov_configure(struct efx_nic *efx, int num_vfs)
  {
 +#ifdef CONFIG_SFC_SRIOV
  	if (num_vfs == 0)
 -		return efx_ef10_pci_sriov_disable(efx, false);
 +		return efx_ef10_pci_sriov_disable(efx);
  	else
  		return efx_ef10_pci_sriov_enable(efx, num_vfs);
++<<<<<<< HEAD
 +#else
 +	return -EOPNOTSUPP;
 +#endif
++=======
+ }
+ 
+ int efx_ef10_sriov_init(struct efx_nic *efx)
+ {
+ 	return 0;
+ }
+ 
+ void efx_ef10_sriov_fini(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	unsigned int i;
+ 	int rc;
+ 
+ 	if (!nic_data->vf) {
+ 		/* Remove any un-assigned orphaned VFs */
+ 		if (pci_num_vf(efx->pci_dev) && !pci_vfs_assigned(efx->pci_dev))
+ 			pci_disable_sriov(efx->pci_dev);
+ 		return;
+ 	}
+ 
+ 	/* Remove any VFs in the host */
+ 	for (i = 0; i < efx->vf_count; ++i) {
+ 		struct efx_nic *vf_efx = nic_data->vf[i].efx;
+ 
+ 		if (vf_efx)
+ 			vf_efx->pci_dev->driver->remove(vf_efx->pci_dev);
+ 	}
+ 
+ 	rc = efx_ef10_pci_sriov_disable(efx, true);
+ 	if (rc)
+ 		netif_dbg(efx, drv, efx->net_dev,
+ 			  "Disabling SRIOV was not successful rc=%d\n", rc);
+ 	else
+ 		netif_dbg(efx, drv, efx->net_dev, "SRIOV disabled\n");
+ }
+ 
+ static int efx_ef10_vport_del_vf_mac(struct efx_nic *efx, unsigned int port_id,
+ 				     u8 *mac)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_DEL_MAC_ADDRESS_IN_LEN);
+ 	MCDI_DECLARE_BUF_ERR(outbuf);
+ 	size_t outlen;
+ 	int rc;
+ 
+ 	MCDI_SET_DWORD(inbuf, VPORT_DEL_MAC_ADDRESS_IN_VPORT_ID, port_id);
+ 	ether_addr_copy(MCDI_PTR(inbuf, VPORT_DEL_MAC_ADDRESS_IN_MACADDR), mac);
+ 
+ 	rc = efx_mcdi_rpc(efx, MC_CMD_VPORT_DEL_MAC_ADDRESS, inbuf,
+ 			  sizeof(inbuf), outbuf, sizeof(outbuf), &outlen);
+ 
+ 	return rc;
+ }
+ 
+ int efx_ef10_sriov_set_vf_mac(struct efx_nic *efx, int vf_i, u8 *mac)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	struct ef10_vf *vf;
+ 	int rc;
+ 
+ 	if (!nic_data->vf)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (vf_i >= efx->vf_count)
+ 		return -EINVAL;
+ 	vf = nic_data->vf + vf_i;
+ 
+ 	if (vf->efx) {
+ 		efx_device_detach_sync(vf->efx);
+ 		efx_net_stop(vf->efx->net_dev);
+ 
+ 		down_write(&vf->efx->filter_sem);
+ 		vf->efx->type->filter_table_remove(vf->efx);
+ 
+ 		rc = efx_ef10_vadaptor_free(vf->efx, EVB_PORT_ID_ASSIGNED);
+ 		if (rc) {
+ 			up_write(&vf->efx->filter_sem);
+ 			return rc;
+ 		}
+ 	}
+ 
+ 	rc = efx_ef10_evb_port_assign(efx, EVB_PORT_ID_NULL, vf_i);
+ 	if (rc)
+ 		return rc;
+ 
+ 	if (!is_zero_ether_addr(vf->mac)) {
+ 		rc = efx_ef10_vport_del_vf_mac(efx, vf->vport_id, vf->mac);
+ 		if (rc)
+ 			return rc;
+ 	}
+ 
+ 	if (!is_zero_ether_addr(mac)) {
+ 		rc = efx_ef10_vport_add_mac(efx, vf->vport_id, mac);
+ 		if (rc) {
+ 			eth_zero_addr(vf->mac);
+ 			goto fail;
+ 		}
+ 		if (vf->efx)
+ 			ether_addr_copy(vf->efx->net_dev->dev_addr, mac);
+ 	}
+ 
+ 	ether_addr_copy(vf->mac, mac);
+ 
+ 	rc = efx_ef10_evb_port_assign(efx, vf->vport_id, vf_i);
+ 	if (rc)
+ 		goto fail;
+ 
+ 	if (vf->efx) {
+ 		/* VF cannot use the vport_id that the PF created */
+ 		rc = efx_ef10_vadaptor_alloc(vf->efx, EVB_PORT_ID_ASSIGNED);
+ 		if (rc) {
+ 			up_write(&vf->efx->filter_sem);
+ 			return rc;
+ 		}
+ 		vf->efx->type->filter_table_probe(vf->efx);
+ 		up_write(&vf->efx->filter_sem);
+ 		efx_net_open(vf->efx->net_dev);
+ 		netif_device_attach(vf->efx->net_dev);
+ 	}
+ 
+ 	return 0;
+ 
+ fail:
+ 	memset(vf->mac, 0, ETH_ALEN);
+ 	return rc;
+ }
+ 
+ int efx_ef10_sriov_set_vf_vlan(struct efx_nic *efx, int vf_i, u16 vlan,
+ 			       u8 qos)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	struct ef10_vf *vf;
+ 	u16 old_vlan, new_vlan;
+ 	int rc = 0, rc2 = 0;
+ 
+ 	if (vf_i >= efx->vf_count)
+ 		return -EINVAL;
+ 	if (qos != 0)
+ 		return -EINVAL;
+ 
+ 	vf = nic_data->vf + vf_i;
+ 
+ 	new_vlan = (vlan == 0) ? EFX_EF10_NO_VLAN : vlan;
+ 	if (new_vlan == vf->vlan)
+ 		return 0;
+ 
+ 	if (vf->efx) {
+ 		efx_device_detach_sync(vf->efx);
+ 		efx_net_stop(vf->efx->net_dev);
+ 
+ 		down_write(&vf->efx->filter_sem);
+ 		vf->efx->type->filter_table_remove(vf->efx);
+ 
+ 		rc = efx_ef10_vadaptor_free(vf->efx, EVB_PORT_ID_ASSIGNED);
+ 		if (rc)
+ 			goto restore_filters;
+ 	}
+ 
+ 	if (vf->vport_assigned) {
+ 		rc = efx_ef10_evb_port_assign(efx, EVB_PORT_ID_NULL, vf_i);
+ 		if (rc) {
+ 			netif_warn(efx, drv, efx->net_dev,
+ 				   "Failed to change vlan on VF %d.\n", vf_i);
+ 			netif_warn(efx, drv, efx->net_dev,
+ 				   "This is likely because the VF is bound to a driver in a VM.\n");
+ 			netif_warn(efx, drv, efx->net_dev,
+ 				   "Please unload the driver in the VM.\n");
+ 			goto restore_vadaptor;
+ 		}
+ 		vf->vport_assigned = 0;
+ 	}
+ 
+ 	if (!is_zero_ether_addr(vf->mac)) {
+ 		rc = efx_ef10_vport_del_mac(efx, vf->vport_id, vf->mac);
+ 		if (rc)
+ 			goto restore_evb_port;
+ 	}
+ 
+ 	if (vf->vport_id) {
+ 		rc = efx_ef10_vport_free(efx, vf->vport_id);
+ 		if (rc)
+ 			goto restore_mac;
+ 		vf->vport_id = 0;
+ 	}
+ 
+ 	/* Do the actual vlan change */
+ 	old_vlan = vf->vlan;
+ 	vf->vlan = new_vlan;
+ 
+ 	/* Restore everything in reverse order */
+ 	rc = efx_ef10_vport_alloc(efx, EVB_PORT_ID_ASSIGNED,
+ 				  MC_CMD_VPORT_ALLOC_IN_VPORT_TYPE_NORMAL,
+ 				  vf->vlan, &vf->vport_id);
+ 	if (rc)
+ 		goto reset_nic_up_write;
+ 
+ restore_mac:
+ 	if (!is_zero_ether_addr(vf->mac)) {
+ 		rc2 = efx_ef10_vport_add_mac(efx, vf->vport_id, vf->mac);
+ 		if (rc2) {
+ 			eth_zero_addr(vf->mac);
+ 			goto reset_nic_up_write;
+ 		}
+ 	}
+ 
+ restore_evb_port:
+ 	rc2 = efx_ef10_evb_port_assign(efx, vf->vport_id, vf_i);
+ 	if (rc2)
+ 		goto reset_nic_up_write;
+ 	else
+ 		vf->vport_assigned = 1;
+ 
+ restore_vadaptor:
+ 	if (vf->efx) {
+ 		rc2 = efx_ef10_vadaptor_alloc(vf->efx, EVB_PORT_ID_ASSIGNED);
+ 		if (rc2)
+ 			goto reset_nic_up_write;
+ 	}
+ 
+ restore_filters:
+ 	if (vf->efx) {
+ 		rc2 = vf->efx->type->filter_table_probe(vf->efx);
+ 		if (rc2)
+ 			goto reset_nic_up_write;
+ 
+ 		up_write(&vf->efx->filter_sem);
+ 
+ 		up_write(&vf->efx->filter_sem);
+ 
+ 		rc2 = efx_net_open(vf->efx->net_dev);
+ 		if (rc2)
+ 			goto reset_nic;
+ 
+ 		netif_device_attach(vf->efx->net_dev);
+ 	}
+ 	return rc;
+ 
+ reset_nic_up_write:
+ 	if (vf->efx)
+ 		up_write(&vf->efx->filter_sem);
+ 
+ reset_nic:
+ 	if (vf->efx) {
+ 		netif_err(efx, drv, efx->net_dev,
+ 			  "Failed to restore VF - scheduling reset.\n");
+ 		efx_schedule_reset(vf->efx, RESET_TYPE_DATAPATH);
+ 	} else {
+ 		netif_err(efx, drv, efx->net_dev,
+ 			  "Failed to restore the VF and cannot reset the VF "
+ 			  "- VF is not functional.\n");
+ 		netif_err(efx, drv, efx->net_dev,
+ 			  "Please reload the driver attached to the VF.\n");
+ 	}
+ 
+ 	return rc ? rc : rc2;
+ }
+ 
+ int efx_ef10_sriov_set_vf_spoofchk(struct efx_nic *efx, int vf_i,
+ 				   bool spoofchk)
+ {
+ 	return spoofchk ? -EOPNOTSUPP : 0;
+ }
+ 
+ int efx_ef10_sriov_set_vf_link_state(struct efx_nic *efx, int vf_i,
+ 				     int link_state)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_LINK_STATE_MODE_IN_LEN);
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 
+ 	BUILD_BUG_ON(IFLA_VF_LINK_STATE_AUTO !=
+ 		     MC_CMD_LINK_STATE_MODE_IN_LINK_STATE_AUTO);
+ 	BUILD_BUG_ON(IFLA_VF_LINK_STATE_ENABLE !=
+ 		     MC_CMD_LINK_STATE_MODE_IN_LINK_STATE_UP);
+ 	BUILD_BUG_ON(IFLA_VF_LINK_STATE_DISABLE !=
+ 		     MC_CMD_LINK_STATE_MODE_IN_LINK_STATE_DOWN);
+ 	MCDI_POPULATE_DWORD_2(inbuf, LINK_STATE_MODE_IN_FUNCTION,
+ 			      LINK_STATE_MODE_IN_FUNCTION_PF,
+ 			      nic_data->pf_index,
+ 			      LINK_STATE_MODE_IN_FUNCTION_VF, vf_i);
+ 	MCDI_SET_DWORD(inbuf, LINK_STATE_MODE_IN_NEW_MODE, link_state);
+ 	return efx_mcdi_rpc(efx, MC_CMD_LINK_STATE_MODE, inbuf, sizeof(inbuf),
+ 			    NULL, 0, NULL); /* don't care what old mode was */
+ }
+ 
+ int efx_ef10_sriov_get_vf_config(struct efx_nic *efx, int vf_i,
+ 				 struct ifla_vf_info *ivf)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_LINK_STATE_MODE_IN_LEN);
+ 	MCDI_DECLARE_BUF(outbuf, MC_CMD_LINK_STATE_MODE_OUT_LEN);
+ 
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	struct ef10_vf *vf;
+ 	size_t outlen;
+ 	int rc;
+ 
+ 	if (vf_i >= efx->vf_count)
+ 		return -EINVAL;
+ 
+ 	if (!nic_data->vf)
+ 		return -EOPNOTSUPP;
+ 
+ 	vf = nic_data->vf + vf_i;
+ 
+ 	ivf->vf = vf_i;
+ 	ivf->min_tx_rate = 0;
+ 	ivf->max_tx_rate = 0;
+ 	ether_addr_copy(ivf->mac, vf->mac);
+ 	ivf->vlan = (vf->vlan == EFX_EF10_NO_VLAN) ? 0 : vf->vlan;
+ 	ivf->qos = 0;
+ 
+ 	MCDI_POPULATE_DWORD_2(inbuf, LINK_STATE_MODE_IN_FUNCTION,
+ 			      LINK_STATE_MODE_IN_FUNCTION_PF,
+ 			      nic_data->pf_index,
+ 			      LINK_STATE_MODE_IN_FUNCTION_VF, vf_i);
+ 	MCDI_SET_DWORD(inbuf, LINK_STATE_MODE_IN_NEW_MODE,
+ 		       MC_CMD_LINK_STATE_MODE_IN_DO_NOT_CHANGE);
+ 	rc = efx_mcdi_rpc(efx, MC_CMD_LINK_STATE_MODE, inbuf, sizeof(inbuf),
+ 			  outbuf, sizeof(outbuf), &outlen);
+ 	if (rc)
+ 		return rc;
+ 	if (outlen < MC_CMD_LINK_STATE_MODE_OUT_LEN)
+ 		return -EIO;
+ 	ivf->linkstate = MCDI_DWORD(outbuf, LINK_STATE_MODE_OUT_OLD_MODE);
+ 
+ 	return 0;
+ }
+ 
+ int efx_ef10_sriov_get_phys_port_id(struct efx_nic *efx,
+ 				    struct netdev_phys_item_id *ppid)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 
+ 	if (!is_valid_ether_addr(nic_data->port_id))
+ 		return -EOPNOTSUPP;
+ 
+ 	ppid->id_len = ETH_ALEN;
+ 	memcpy(ppid->id, nic_data->port_id, ppid->id_len);
+ 
+ 	return 0;
++>>>>>>> 671b53eec2ed (sfc: Ensure down_write(&filter_sem) and up_write() are matched before calling efx_net_open())
  }
* Unmerged path drivers/net/ethernet/sfc/ef10_sriov.c
