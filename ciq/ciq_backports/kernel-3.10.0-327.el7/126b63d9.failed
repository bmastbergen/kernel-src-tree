i40e: Fix a memory leak in X722 rss config path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Anjali Singhai <anjali.singhai@intel.com>
commit 126b63d9d3aa99a90381ed168a885989dd33cf15
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/126b63d9.failed

In any case free the memory allocated before exiting.

	Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
	Signed-off-by: Anjali Singhai Jain <anjali.singhai@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 126b63d9d3aa99a90381ed168a885989dd33cf15)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_main.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_main.c
index bce80bf85e15,5646ee885db2..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@@ -7492,6 -7595,107 +7492,110 @@@ static int i40e_setup_misc_vector(struc
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * i40e_config_rss_aq - Prepare for RSS using AQ commands
+  * @vsi: vsi structure
+  * @seed: RSS hash seed
+  **/
+ static int i40e_config_rss_aq(struct i40e_vsi *vsi, const u8 *seed)
+ {
+ 	struct i40e_aqc_get_set_rss_key_data rss_key;
+ 	struct i40e_pf *pf = vsi->back;
+ 	struct i40e_hw *hw = &pf->hw;
+ 	bool pf_lut = false;
+ 	u8 *rss_lut;
+ 	int ret, i;
+ 
+ 	memset(&rss_key, 0, sizeof(rss_key));
+ 	memcpy(&rss_key, seed, sizeof(rss_key));
+ 
+ 	rss_lut = kzalloc(pf->rss_table_size, GFP_KERNEL);
+ 	if (!rss_lut)
+ 		return -ENOMEM;
+ 
+ 	/* Populate the LUT with max no. of queues in round robin fashion */
+ 	for (i = 0; i < vsi->rss_table_size; i++)
+ 		rss_lut[i] = i % vsi->rss_size;
+ 
+ 	ret = i40e_aq_set_rss_key(hw, vsi->id, &rss_key);
+ 	if (ret) {
+ 		dev_info(&pf->pdev->dev,
+ 			 "Cannot set RSS key, err %s aq_err %s\n",
+ 			 i40e_stat_str(&pf->hw, ret),
+ 			 i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));
+ 		goto config_rss_aq_out;
+ 	}
+ 
+ 	if (vsi->type == I40E_VSI_MAIN)
+ 		pf_lut = true;
+ 
+ 	ret = i40e_aq_set_rss_lut(hw, vsi->id, pf_lut, rss_lut,
+ 				  vsi->rss_table_size);
+ 	if (ret)
+ 		dev_info(&pf->pdev->dev,
+ 			 "Cannot set RSS lut, err %s aq_err %s\n",
+ 			 i40e_stat_str(&pf->hw, ret),
+ 			 i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));
+ 
+ config_rss_aq_out:
+ 	kfree(rss_lut);
+ 	return ret;
+ }
+ 
+ /**
+  * i40e_vsi_config_rss - Prepare for VSI(VMDq) RSS if used
+  * @vsi: VSI structure
+  **/
+ static int i40e_vsi_config_rss(struct i40e_vsi *vsi)
+ {
+ 	u8 seed[I40E_HKEY_ARRAY_SIZE];
+ 	struct i40e_pf *pf = vsi->back;
+ 
+ 	netdev_rss_key_fill((void *)seed, I40E_HKEY_ARRAY_SIZE);
+ 	vsi->rss_size = min_t(int, pf->rss_size, vsi->num_queue_pairs);
+ 
+ 	if (pf->flags & I40E_FLAG_RSS_AQ_CAPABLE)
+ 		return i40e_config_rss_aq(vsi, seed);
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * i40e_config_rss_reg - Prepare for RSS if used
+  * @pf: board private structure
+  * @seed: RSS hash seed
+  **/
+ static int i40e_config_rss_reg(struct i40e_pf *pf, const u8 *seed)
+ {
+ 	struct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];
+ 	struct i40e_hw *hw = &pf->hw;
+ 	u32 *seed_dw = (u32 *)seed;
+ 	u32 current_queue = 0;
+ 	u32 lut = 0;
+ 	int i, j;
+ 
+ 	/* Fill out hash function seed */
+ 	for (i = 0; i <= I40E_PFQF_HKEY_MAX_INDEX; i++)
+ 		wr32(hw, I40E_PFQF_HKEY(i), seed_dw[i]);
+ 
+ 	for (i = 0; i <= I40E_PFQF_HLUT_MAX_INDEX; i++) {
+ 		lut = 0;
+ 		for (j = 0; j < 4; j++) {
+ 			if (current_queue == vsi->rss_size)
+ 				current_queue = 0;
+ 			lut |= ((current_queue) << (8 * j));
+ 			current_queue++;
+ 		}
+ 		wr32(&pf->hw, I40E_PFQF_HLUT(i), lut);
+ 	}
+ 	i40e_flush(hw);
+ 
+ 	return 0;
+ }
+ 
+ /**
++>>>>>>> 126b63d9d3aa (i40e: Fix a memory leak in X722 rss config path)
   * i40e_config_rss - Prepare for RSS if used
   * @pf: board private structure
   **/
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_main.c
