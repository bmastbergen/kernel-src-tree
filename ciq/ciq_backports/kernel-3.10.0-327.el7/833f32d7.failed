time: Prevent early expiry of hrtimers[CLOCK_REALTIME] at the leap second edge

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [kernel] time: Prevent early expiry of hrtimers[CLOCK_REALTIME] at the leap second edge (Prarit Bhargava) [1250754]
Rebuild_FUZZ: 87.77%
commit-author John Stultz <john.stultz@linaro.org>
commit 833f32d763028c1bb371c64f457788b933773b3e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/833f32d7.failed

Currently, leapsecond adjustments are done at tick time. As a result,
the leapsecond was applied at the first timer tick *after* the
leapsecond (~1-10ms late depending on HZ), rather then exactly on the
second edge.

This was in part historical from back when we were always tick based,
but correcting this since has been avoided since it adds extra
conditional checks in the gettime fastpath, which has performance
overhead.

However, it was recently pointed out that ABS_TIME CLOCK_REALTIME
timers set for right after the leapsecond could fire a second early,
since some timers may be expired before we trigger the timekeeping
timer, which then applies the leapsecond.

This isn't quite as bad as it sounds, since behaviorally it is similar
to what is possible w/ ntpd made leapsecond adjustments done w/o using
the kernel discipline. Where due to latencies, timers may fire just
prior to the settimeofday call. (Also, one should note that all
applications using CLOCK_REALTIME timers should always be careful,
since they are prone to quirks from settimeofday() disturbances.)

However, the purpose of having the kernel do the leap adjustment is to
avoid such latencies, so I think this is worth fixing.

So in order to properly keep those timers from firing a second early,
this patch modifies the ntp and timekeeping logic so that we keep
enough state so that the update_base_offsets_now accessor, which
provides the hrtimer core the current time, can check and apply the
leapsecond adjustment on the second edge. This prevents the hrtimer
core from expiring timers too early.

This patch does not modify any other time read path, so no additional
overhead is incurred. However, this also means that the leap-second
continues to be applied at tick time for all other read-paths.

Apologies to Richard Cochran, who pushed for similar changes years
ago, which I resisted due to the concerns about the performance
overhead.

While I suspect this isn't extremely critical, folks who care about
strict leap-second correctness will likely want to watch
this. Potentially a -stable candidate eventually.

Originally-suggested-by: Richard Cochran <richardcochran@gmail.com>
	Reported-by: Daniel Bristot de Oliveira <bristot@redhat.com>
	Reported-by: Prarit Bhargava <prarit@redhat.com>
	Signed-off-by: John Stultz <john.stultz@linaro.org>
	Cc: Richard Cochran <richardcochran@gmail.com>
	Cc: Jan Kara <jack@suse.cz>
	Cc: Jiri Bohac <jbohac@suse.cz>
	Cc: Shuah Khan <shuahkh@osg.samsung.com>
	Cc: Ingo Molnar <mingo@kernel.org>
Link: http://lkml.kernel.org/r/1434063297-28657-4-git-send-email-john.stultz@linaro.org
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit 833f32d763028c1bb371c64f457788b933773b3e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/timekeeper_internal.h
#	kernel/time/timekeeping.c
diff --cc include/linux/timekeeper_internal.h
index 4e31044f893e,25247220b4b7..000000000000
--- a/include/linux/timekeeper_internal.h
+++ b/include/linux/timekeeper_internal.h
@@@ -10,65 -10,95 +10,153 @@@
  #include <linux/jiffies.h>
  #include <linux/time.h>
  
++<<<<<<< HEAD
 +/* Structure holding internal timekeeping values. */
 +struct timekeeper {
 +	/* Current clocksource used for timekeeping. */
 +	struct clocksource	*clock;
 +	/* NTP adjusted clock multiplier */
 +	u32			mult;
 +	/* The shift value of the current clocksource. */
 +	u32			shift;
 +	/* Number of clock cycles in one NTP interval. */
++=======
+ /**
+  * struct tk_read_base - base structure for timekeeping readout
+  * @clock:	Current clocksource used for timekeeping.
+  * @read:	Read function of @clock
+  * @mask:	Bitmask for two's complement subtraction of non 64bit clocks
+  * @cycle_last: @clock cycle value at last update
+  * @mult:	(NTP adjusted) multiplier for scaled math conversion
+  * @shift:	Shift value for scaled math conversion
+  * @xtime_nsec: Shifted (fractional) nano seconds offset for readout
+  * @base:	ktime_t (nanoseconds) base time for readout
+  *
+  * This struct has size 56 byte on 64 bit. Together with a seqcount it
+  * occupies a single 64byte cache line.
+  *
+  * The struct is separate from struct timekeeper as it is also used
+  * for a fast NMI safe accessors.
+  */
+ struct tk_read_base {
+ 	struct clocksource	*clock;
+ 	cycle_t			(*read)(struct clocksource *cs);
+ 	cycle_t			mask;
+ 	cycle_t			cycle_last;
+ 	u32			mult;
+ 	u32			shift;
+ 	u64			xtime_nsec;
+ 	ktime_t			base;
+ };
+ 
+ /**
+  * struct timekeeper - Structure holding internal timekeeping values.
+  * @tkr_mono:		The readout base structure for CLOCK_MONOTONIC
+  * @tkr_raw:		The readout base structure for CLOCK_MONOTONIC_RAW
+  * @xtime_sec:		Current CLOCK_REALTIME time in seconds
+  * @ktime_sec:		Current CLOCK_MONOTONIC time in seconds
+  * @wall_to_monotonic:	CLOCK_REALTIME to CLOCK_MONOTONIC offset
+  * @offs_real:		Offset clock monotonic -> clock realtime
+  * @offs_boot:		Offset clock monotonic -> clock boottime
+  * @offs_tai:		Offset clock monotonic -> clock tai
+  * @tai_offset:		The current UTC to TAI offset in seconds
+  * @clock_was_set_seq:	The sequence number of clock was set events
+  * @next_leap_ktime:	CLOCK_MONOTONIC time value of a pending leap-second
+  * @raw_time:		Monotonic raw base time in timespec64 format
+  * @cycle_interval:	Number of clock cycles in one NTP interval
+  * @xtime_interval:	Number of clock shifted nano seconds in one NTP
+  *			interval.
+  * @xtime_remainder:	Shifted nano seconds left over when rounding
+  *			@cycle_interval
+  * @raw_interval:	Raw nano seconds accumulated per NTP interval.
+  * @ntp_error:		Difference between accumulated time and NTP time in ntp
+  *			shifted nano seconds.
+  * @ntp_error_shift:	Shift conversion between clock shifted nano seconds and
+  *			ntp shifted nano seconds.
+  * @last_warning:	Warning ratelimiter (DEBUG_TIMEKEEPING)
+  * @underflow_seen:	Underflow warning flag (DEBUG_TIMEKEEPING)
+  * @overflow_seen:	Overflow warning flag (DEBUG_TIMEKEEPING)
+  *
+  * Note: For timespec(64) based interfaces wall_to_monotonic is what
+  * we need to add to xtime (or xtime corrected for sub jiffie times)
+  * to get to monotonic time.  Monotonic is pegged at zero at system
+  * boot time, so wall_to_monotonic will be negative, however, we will
+  * ALWAYS keep the tv_nsec part positive so we can use the usual
+  * normalization.
+  *
+  * wall_to_monotonic is moved after resume from suspend for the
+  * monotonic time not to jump. We need to add total_sleep_time to
+  * wall_to_monotonic to get the real boot based time offset.
+  *
+  * wall_to_monotonic is no longer the boot time, getboottime must be
+  * used instead.
+  */
+ struct timekeeper {
+ 	struct tk_read_base	tkr_mono;
+ 	struct tk_read_base	tkr_raw;
+ 	u64			xtime_sec;
+ 	unsigned long		ktime_sec;
+ 	struct timespec64	wall_to_monotonic;
+ 	ktime_t			offs_real;
+ 	ktime_t			offs_boot;
+ 	ktime_t			offs_tai;
+ 	s32			tai_offset;
+ 	unsigned int		clock_was_set_seq;
+ 	ktime_t			next_leap_ktime;
+ 	struct timespec64	raw_time;
+ 
+ 	/* The following members are for timekeeping internal use */
++>>>>>>> 833f32d76302 (time: Prevent early expiry of hrtimers[CLOCK_REALTIME] at the leap second edge)
  	cycle_t			cycle_interval;
 +	/* Last cycle value (also stored in clock->cycle_last) */
 +	cycle_t			cycle_last;
 +	/* Number of clock shifted nano seconds in one NTP interval. */
  	u64			xtime_interval;
 +	/* shifted nano seconds left over when rounding cycle_interval */
  	s64			xtime_remainder;
 +	/* Raw nano seconds accumulated per NTP interval. */
  	u32			raw_interval;
 +
 +	/* Current CLOCK_REALTIME time in seconds */
 +	u64			xtime_sec;
 +	/* Clock shifted nano seconds */
 +	u64			xtime_nsec;
 +
 +	/* Difference between accumulated time and NTP time in ntp
 +	 * shifted nano seconds. */
 +	s64			ntp_error;
 +	/* Shift conversion between clock shifted nano seconds and
 +	 * ntp shifted nano seconds. */
 +	u32			ntp_error_shift;
 +
 +	/*
 +	 * wall_to_monotonic is what we need to add to xtime (or xtime corrected
 +	 * for sub jiffie times) to get to monotonic time.  Monotonic is pegged
 +	 * at zero at system boot time, so wall_to_monotonic will be negative,
 +	 * however, we will ALWAYS keep the tv_nsec part positive so we can use
 +	 * the usual normalization.
 +	 *
 +	 * wall_to_monotonic is moved after resume from suspend for the
 +	 * monotonic time not to jump. We need to add total_sleep_time to
 +	 * wall_to_monotonic to get the real boot based time offset.
 +	 *
 +	 * - wall_to_monotonic is no longer the boot time, getboottime must be
 +	 * used instead.
 +	 */
 +	struct timespec		wall_to_monotonic;
 +	/* Offset clock monotonic -> clock realtime */
 +	ktime_t			offs_real;
 +	/* time spent in suspend */
 +	struct timespec		total_sleep_time;
 +	/* Offset clock monotonic -> clock boottime */
 +	ktime_t			offs_boot;
 +	/* The raw monotonic time for the CLOCK_MONOTONIC_RAW posix clock. */
 +	struct timespec		raw_time;
 +	/* The current UTC to TAI offset in seconds */
 +	s32			tai_offset;
 +	/* Offset clock monotonic -> clock tai */
 +	ktime_t			offs_tai;
 +
  	/* The ntp_tick_length() value currently being used.
  	 * This cached copy ensures we consistently apply the tick
  	 * length for an entire tick, as ntp_tick_length may change
diff --cc kernel/time/timekeeping.c
index a690422a076b,5d67ffb7e317..000000000000
--- a/kernel/time/timekeeping.c
+++ b/kernel/time/timekeeping.c
@@@ -247,6 -539,50 +247,53 @@@ int pvclock_gtod_unregister_notifier(st
  }
  EXPORT_SYMBOL_GPL(pvclock_gtod_unregister_notifier);
  
++<<<<<<< HEAD
++=======
+ /*
+  * tk_update_leap_state - helper to update the next_leap_ktime
+  */
+ static inline void tk_update_leap_state(struct timekeeper *tk)
+ {
+ 	tk->next_leap_ktime = ntp_get_next_leap();
+ 	if (tk->next_leap_ktime.tv64 != KTIME_MAX)
+ 		/* Convert to monotonic time */
+ 		tk->next_leap_ktime = ktime_sub(tk->next_leap_ktime, tk->offs_real);
+ }
+ 
+ /*
+  * Update the ktime_t based scalar nsec members of the timekeeper
+  */
+ static inline void tk_update_ktime_data(struct timekeeper *tk)
+ {
+ 	u64 seconds;
+ 	u32 nsec;
+ 
+ 	/*
+ 	 * The xtime based monotonic readout is:
+ 	 *	nsec = (xtime_sec + wtm_sec) * 1e9 + wtm_nsec + now();
+ 	 * The ktime based monotonic readout is:
+ 	 *	nsec = base_mono + now();
+ 	 * ==> base_mono = (xtime_sec + wtm_sec) * 1e9 + wtm_nsec
+ 	 */
+ 	seconds = (u64)(tk->xtime_sec + tk->wall_to_monotonic.tv_sec);
+ 	nsec = (u32) tk->wall_to_monotonic.tv_nsec;
+ 	tk->tkr_mono.base = ns_to_ktime(seconds * NSEC_PER_SEC + nsec);
+ 
+ 	/* Update the monotonic raw base */
+ 	tk->tkr_raw.base = timespec64_to_ktime(tk->raw_time);
+ 
+ 	/*
+ 	 * The sum of the nanoseconds portions of xtime and
+ 	 * wall_to_monotonic can be greater/equal one second. Take
+ 	 * this into account before updating tk->ktime_sec.
+ 	 */
+ 	nsec += (u32)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);
+ 	if (nsec >= NSEC_PER_SEC)
+ 		seconds++;
+ 	tk->ktime_sec = seconds;
+ }
+ 
++>>>>>>> 833f32d76302 (time: Prevent early expiry of hrtimers[CLOCK_REALTIME] at the leap second edge)
  /* must hold timekeeper_lock */
  static void timekeeping_update(struct timekeeper *tk, unsigned int action)
  {
@@@ -254,6 -590,10 +301,13 @@@
  		tk->ntp_error = 0;
  		ntp_clear();
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	tk_update_leap_state(tk);
+ 	tk_update_ktime_data(tk);
+ 
++>>>>>>> 833f32d76302 (time: Prevent early expiry of hrtimers[CLOCK_REALTIME] at the leap second edge)
  	update_vsyscall(tk);
  	update_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);
  
@@@ -1554,83 -1949,43 +1608,104 @@@ void do_timer(unsigned long ticks
   * @offs_boot:	pointer to storage for monotonic -> boottime offset
   * @offs_tai:	pointer to storage for monotonic -> clock tai offset
   *
 - * Returns current monotonic time and updates the offsets if the
 - * sequence number in @cwsseq and timekeeper.clock_was_set_seq are
 - * different.
 - *
 - * Called from hrtimer_interrupt() or retrigger_next_event()
 + * Returns monotonic time at last tick and various offsets
   */
 -ktime_t ktime_get_update_offsets_now(unsigned int *cwsseq, ktime_t *offs_real,
 -				     ktime_t *offs_boot, ktime_t *offs_tai)
 +ktime_t ktime_get_update_offsets_tick(ktime_t *offs_real, ktime_t *offs_boot,
 +							ktime_t *offs_tai)
  {
 -	struct timekeeper *tk = &tk_core.timekeeper;
 +	struct timekeeper *tk = &timekeeper;
 +	struct timespec ts;
 +	ktime_t now;
  	unsigned int seq;
 -	ktime_t base;
 -	u64 nsecs;
  
  	do {
 -		seq = read_seqcount_begin(&tk_core.seq);
 +		seq = read_seqcount_begin(&timekeeper_seq);
 +
++<<<<<<< HEAD
 +		ts = tk_xtime(tk);
  
 +		*offs_real = tk->offs_real;
 +		*offs_boot = tk->offs_boot;
 +		*offs_tai = tk->offs_tai;
 +	} while (read_seqcount_retry(&timekeeper_seq, seq));
 +
 +	now = ktime_set(ts.tv_sec, ts.tv_nsec);
 +	now = ktime_sub(now, *offs_real);
 +	return now;
++=======
+ 		base = tk->tkr_mono.base;
+ 		nsecs = timekeeping_get_ns(&tk->tkr_mono);
+ 		base = ktime_add_ns(base, nsecs);
+ 
+ 		if (*cwsseq != tk->clock_was_set_seq) {
+ 			*cwsseq = tk->clock_was_set_seq;
+ 			*offs_real = tk->offs_real;
+ 			*offs_boot = tk->offs_boot;
+ 			*offs_tai = tk->offs_tai;
+ 		}
+ 
+ 		/* Handle leapsecond insertion adjustments */
+ 		if (unlikely(base.tv64 >= tk->next_leap_ktime.tv64))
+ 			*offs_real = ktime_sub(tk->offs_real, ktime_set(1, 0));
+ 
+ 	} while (read_seqcount_retry(&tk_core.seq, seq));
+ 
+ 	return base;
++>>>>>>> 833f32d76302 (time: Prevent early expiry of hrtimers[CLOCK_REALTIME] at the leap second edge)
  }
  
 +#ifdef CONFIG_HIGH_RES_TIMERS
 +/**
 + * ktime_get_update_offsets_now - hrtimer helper
 + * @offs_real:	pointer to storage for monotonic -> realtime offset
 + * @offs_boot:	pointer to storage for monotonic -> boottime offset
 + *
 + * Returns current monotonic time and updates the offsets
 + * Called from hrtimer_interupt() or retrigger_next_event()
 + */
 +ktime_t ktime_get_update_offsets_now(ktime_t *offs_real, ktime_t *offs_boot,
 +							ktime_t *offs_tai)
 +{
 +	struct timekeeper *tk = &timekeeper;
 +	ktime_t now;
 +	unsigned int seq;
 +	u64 secs, nsecs;
 +
 +	do {
 +		seq = read_seqcount_begin(&timekeeper_seq);
 +
 +		secs = tk->xtime_sec;
 +		nsecs = timekeeping_get_ns(tk);
 +
 +		*offs_real = tk->offs_real;
 +		*offs_boot = tk->offs_boot;
 +		*offs_tai = tk->offs_tai;
 +	} while (read_seqcount_retry(&timekeeper_seq, seq));
 +
 +	now = ktime_add_ns(ktime_set(secs, 0), nsecs);
 +	now = ktime_sub(now, *offs_real);
 +	return now;
 +}
 +#endif
 +
 +/**
 + * ktime_get_monotonic_offset() - get wall_to_monotonic in ktime_t format
 + */
 +ktime_t ktime_get_monotonic_offset(void)
 +{
 +	struct timekeeper *tk = &timekeeper;
 +	unsigned long seq;
 +	struct timespec wtom;
 +
 +	do {
 +		seq = read_seqcount_begin(&timekeeper_seq);
 +		wtom = tk->wall_to_monotonic;
 +	} while (read_seqcount_retry(&timekeeper_seq, seq));
 +
 +	return timespec_to_ktime(wtom);
 +}
 +EXPORT_SYMBOL_GPL(ktime_get_monotonic_offset);
 +
  /**
   * do_adjtimex() - Accessor function to NTP __do_adjtimex function
   */
@@@ -1670,7 -2025,9 +1745,13 @@@ int do_adjtimex(struct timex *txc
  		__timekeeping_set_tai_offset(tk, tai);
  		timekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);
  	}
++<<<<<<< HEAD
 +	write_seqcount_end(&timekeeper_seq);
++=======
+ 	tk_update_leap_state(tk);
+ 
+ 	write_seqcount_end(&tk_core.seq);
++>>>>>>> 833f32d76302 (time: Prevent early expiry of hrtimers[CLOCK_REALTIME] at the leap second edge)
  	raw_spin_unlock_irqrestore(&timekeeper_lock, flags);
  
  	if (tai != orig_tai)
diff --git a/include/linux/time64.h b/include/linux/time64.h
index a3831478d9cf..ff46e87b926a 100644
--- a/include/linux/time64.h
+++ b/include/linux/time64.h
@@ -28,6 +28,7 @@ struct timespec64 {
 #define FSEC_PER_SEC	1000000000000000LL
 
 /* Located here for timespec[64]_valid_strict */
+#define TIME64_MAX			((s64)~((u64)1 << 63))
 #define KTIME_MAX			((s64)~((u64)1 << 63))
 #define KTIME_SEC_MAX			(KTIME_MAX / NSEC_PER_SEC)
 
* Unmerged path include/linux/timekeeper_internal.h
diff --git a/kernel/time/ntp.c b/kernel/time/ntp.c
index d167ce2786c9..ed1ee75c6b65 100644
--- a/kernel/time/ntp.c
+++ b/kernel/time/ntp.c
@@ -78,6 +78,9 @@ static long			time_adjust;
 /* constant (boot-param configurable) NTP tick adjustment (upscaled)	*/
 static s64			ntp_tick_adj;
 
+/* second value of the next pending leapsecond, or TIME64_MAX if no leap */
+static time64_t			ntp_next_leap_sec = TIME64_MAX;
+
 #ifdef CONFIG_NTP_PPS
 
 /*
@@ -351,6 +354,7 @@ void ntp_clear(void)
 	tick_length	= tick_length_base;
 	time_offset	= 0;
 
+	ntp_next_leap_sec = TIME64_MAX;
 	/* Clear PPS state variables */
 	pps_clear();
 }
@@ -361,6 +365,21 @@ u64 ntp_tick_length(void)
 	return tick_length;
 }
 
+/**
+ * ntp_get_next_leap - Returns the next leapsecond in CLOCK_REALTIME ktime_t
+ *
+ * Provides the time of the next leapsecond against CLOCK_REALTIME in
+ * a ktime_t format. Returns KTIME_MAX if no leapsecond is pending.
+ */
+ktime_t ntp_get_next_leap(void)
+{
+	ktime_t ret;
+
+	if ((time_state == TIME_INS) && (time_status & STA_INS))
+		return ktime_set(ntp_next_leap_sec, 0);
+	ret.tv64 = KTIME_MAX;
+	return ret;
+}
 
 /*
  * this routine handles the overflow of the microsecond field
@@ -384,15 +403,21 @@ int second_overflow(unsigned long secs)
 	 */
 	switch (time_state) {
 	case TIME_OK:
-		if (time_status & STA_INS)
+		if (time_status & STA_INS) {
 			time_state = TIME_INS;
-		else if (time_status & STA_DEL)
+			ntp_next_leap_sec = secs + SECS_PER_DAY -
+						(secs % SECS_PER_DAY);
+		} else if (time_status & STA_DEL) {
 			time_state = TIME_DEL;
+			ntp_next_leap_sec = secs + SECS_PER_DAY -
+						 ((secs+1) % SECS_PER_DAY);
+		}
 		break;
 	case TIME_INS:
-		if (!(time_status & STA_INS))
+		if (!(time_status & STA_INS)) {
+			ntp_next_leap_sec = TIME64_MAX;
 			time_state = TIME_OK;
-		else if (secs % SECS_PER_DAY == 0) {
+		} else if (secs % SECS_PER_DAY == 0) {
 			leap = -1;
 			time_state = TIME_OOP;
 			printk(KERN_NOTICE
@@ -400,19 +425,21 @@ int second_overflow(unsigned long secs)
 		}
 		break;
 	case TIME_DEL:
-		if (!(time_status & STA_DEL))
+		if (!(time_status & STA_DEL)) {
+			ntp_next_leap_sec = TIME64_MAX;
 			time_state = TIME_OK;
-		else if ((secs + 1) % SECS_PER_DAY == 0) {
+		} else if ((secs + 1) % SECS_PER_DAY == 0) {
 			leap = 1;
+			ntp_next_leap_sec = TIME64_MAX;
 			time_state = TIME_WAIT;
 			printk(KERN_NOTICE
 				"Clock: deleting leap second 23:59:59 UTC\n");
 		}
 		break;
 	case TIME_OOP:
+		ntp_next_leap_sec = TIME64_MAX;
 		time_state = TIME_WAIT;
 		break;
-
 	case TIME_WAIT:
 		if (!(time_status & (STA_INS | STA_DEL)))
 			time_state = TIME_OK;
@@ -536,6 +563,7 @@ static inline void process_adj_status(struct timex *txc, struct timespec *ts)
 	if ((time_status & STA_PLL) && !(txc->status & STA_PLL)) {
 		time_state = TIME_OK;
 		time_status = STA_UNSYNC;
+		ntp_next_leap_sec = TIME64_MAX;
 		/* restart PPS frequency calibration */
 		pps_reset_freq_interval();
 	}
diff --git a/kernel/time/ntp_internal.h b/kernel/time/ntp_internal.h
index 1950cb4ca2a4..91bc004ce712 100644
--- a/kernel/time/ntp_internal.h
+++ b/kernel/time/ntp_internal.h
@@ -5,6 +5,7 @@ extern void ntp_init(void);
 extern void ntp_clear(void);
 /* Returns how long ticks are at present, in ns / 2^NTP_SCALE_SHIFT. */
 extern u64 ntp_tick_length(void);
+extern ktime_t ntp_get_next_leap(void);
 extern int second_overflow(unsigned long secs);
 extern int ntp_validate_timex(struct timex *);
 extern int __do_adjtimex(struct timex *, struct timespec *, s32 *);
* Unmerged path kernel/time/timekeeping.c
