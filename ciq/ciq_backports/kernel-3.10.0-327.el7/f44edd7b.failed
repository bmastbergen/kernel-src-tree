ALSA: line6/toneport: Implement LED controls via LED class

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [alsa] line6/toneport: Implement LED controls via LED class (Jaroslav Kysela) [1197064]
Rebuild_FUZZ: 94.55%
commit-author Takashi Iwai <tiwai@suse.de>
commit f44edd7b2bbeddef602fe84d3b175818024d7fce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/f44edd7b.failed

Instead of non-standard sysfs, reimplement the LED controls on
TonePort as LED class devices.

	Tested-by: Chris Rorvick <chris@rorvick.com>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit f44edd7b2bbeddef602fe84d3b175818024d7fce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/line6/toneport.c
#	sound/usb/line6/Kconfig
diff --cc drivers/staging/line6/toneport.c
index 4f8fc09cde1e,9a769463f7bf..000000000000
--- a/drivers/staging/line6/toneport.c
+++ b/drivers/staging/line6/toneport.c
@@@ -11,13 -11,71 +11,79 @@@
   */
  
  #include <linux/wait.h>
++<<<<<<< HEAD:drivers/staging/line6/toneport.c
++=======
+ #include <linux/usb.h>
+ #include <linux/slab.h>
+ #include <linux/module.h>
+ #include <linux/leds.h>
+ #include <sound/core.h>
++>>>>>>> f44edd7b2bbe (ALSA: line6/toneport: Implement LED controls via LED class):sound/usb/line6/toneport.c
  #include <sound/control.h>
  
 +#include "audio.h"
  #include "capture.h"
  #include "driver.h"
  #include "playback.h"
++<<<<<<< HEAD:drivers/staging/line6/toneport.c
 +#include "toneport.h"
++=======
+ #include "usbdefs.h"
+ 
+ enum line6_device_type {
+ 	LINE6_GUITARPORT,
+ 	LINE6_PODSTUDIO_GX,
+ 	LINE6_PODSTUDIO_UX1,
+ 	LINE6_PODSTUDIO_UX2,
+ 	LINE6_TONEPORT_GX,
+ 	LINE6_TONEPORT_UX1,
+ 	LINE6_TONEPORT_UX2,
+ };
+ 
+ struct usb_line6_toneport;
+ 
+ struct toneport_led {
+ 	struct led_classdev dev;
+ 	char name[64];
+ 	struct usb_line6_toneport *toneport;
+ 	bool registered;
+ };
+ 
+ struct usb_line6_toneport {
+ 	/**
+ 		Generic Line 6 USB data.
+ 	*/
+ 	struct usb_line6 line6;
+ 
+ 	/**
+ 		Source selector.
+ 	*/
+ 	int source;
+ 
+ 	/**
+ 		Serial number of device.
+ 	*/
+ 	int serial_number;
+ 
+ 	/**
+ 		Firmware version (x 100).
+ 	*/
+ 	int firmware_version;
+ 
+ 	/**
+ 		 Timer for delayed PCM startup.
+ 	*/
+ 	struct timer_list timer;
+ 
+ 	/**
+ 		 Device type.
+ 	*/
+ 	enum line6_device_type type;
+ 
+ 	/* LED instances */
+ 	struct toneport_led leds[2];
+ };
++>>>>>>> f44edd7b2bbe (ALSA: line6/toneport: Implement LED controls via LED class):sound/usb/line6/toneport.c
  
  static int toneport_send_cmd(struct usb_device *usbdev, int cmd1, int cmd2);
  
@@@ -91,62 -140,6 +148,65 @@@ static const struct 
  	{"Inst & Mic", 0x0901}
  };
  
++<<<<<<< HEAD:drivers/staging/line6/toneport.c
 +static bool toneport_has_led(short product)
 +{
 +	return
 +	    (product == LINE6_DEVID_GUITARPORT) ||
 +	    (product == LINE6_DEVID_TONEPORT_GX);
 +	/* add your device here if you are missing support for the LEDs */
 +}
 +
 +static void toneport_update_led(struct device *dev)
 +{
 +	struct usb_interface *interface = to_usb_interface(dev);
 +	struct usb_line6_toneport *tp = usb_get_intfdata(interface);
 +	struct usb_line6 *line6;
 +
 +	if (!tp)
 +		return;
 +
 +	line6 = &tp->line6;
 +	if (line6)
 +		toneport_send_cmd(line6->usbdev, (led_red << 8) | 0x0002,
 +				  led_green);
 +}
 +
 +static ssize_t toneport_set_led_red(struct device *dev,
 +				    struct device_attribute *attr,
 +				    const char *buf, size_t count)
 +{
 +	int retval;
 +
 +	retval = kstrtoint(buf, 10, &led_red);
 +	if (retval)
 +		return retval;
 +
 +	toneport_update_led(dev);
 +	return count;
 +}
 +
 +static ssize_t toneport_set_led_green(struct device *dev,
 +				      struct device_attribute *attr,
 +				      const char *buf, size_t count)
 +{
 +	int retval;
 +
 +	retval = kstrtoint(buf, 10, &led_green);
 +	if (retval)
 +		return retval;
 +
 +	toneport_update_led(dev);
 +	return count;
 +}
 +
 +static DEVICE_ATTR(led_red, S_IWUSR | S_IRUGO, line6_nop_read,
 +		   toneport_set_led_red);
 +static DEVICE_ATTR(led_green, S_IWUSR | S_IRUGO, line6_nop_read,
 +		   toneport_set_led_green);
 +
++=======
++>>>>>>> f44edd7b2bbe (ALSA: line6/toneport: Implement LED controls via LED class):sound/usb/line6/toneport.c
  static int toneport_send_cmd(struct usb_device *usbdev, int cmd1, int cmd2)
  {
  	int ret;
@@@ -278,15 -278,75 +338,87 @@@ static struct snd_kcontrol_new toneport
  };
  
  /*
++<<<<<<< HEAD:drivers/staging/line6/toneport.c
 +	Toneport destructor.
 +*/
 +static void toneport_destruct(struct usb_interface *interface)
 +{
 +	struct usb_line6_toneport *toneport = usb_get_intfdata(interface);
 +
 +	if (toneport == NULL)
 +		return;
 +	line6_cleanup_audio(&toneport->line6);
++=======
+ 	For the led on Guitarport.
+ 	Brightness goes from 0x00 to 0x26. Set a value above this to have led
+ 	blink.
+ 	(void cmd_0x02(byte red, byte green)
+ */
+ 
+ static bool toneport_has_led(enum line6_device_type type)
+ {
+ 	return
+ 	    (type == LINE6_GUITARPORT) ||
+ 	    (type == LINE6_TONEPORT_GX);
+ 	/* add your device here if you are missing support for the LEDs */
+ }
+ 
+ static const char * const led_colors[2] = { "red", "green" };
+ static const int led_init_vals[2] = { 0x00, 0x26 };
+ 
+ static void toneport_update_led(struct usb_line6_toneport *toneport)
+ {
+ 	toneport_send_cmd(toneport->line6.usbdev,
+ 			  (toneport->leds[0].dev.brightness << 8) | 0x0002,
+ 			  toneport->leds[1].dev.brightness);
+ }
+ 
+ static void toneport_led_brightness_set(struct led_classdev *led_cdev,
+ 					enum led_brightness brightness)
+ {
+ 	struct toneport_led *leds =
+ 		container_of(led_cdev, struct toneport_led, dev);
+ 	toneport_update_led(leds->toneport);
+ }
+ 
+ static int toneport_init_leds(struct usb_line6_toneport *toneport)
+ {
+ 	struct device *dev = &toneport->line6.usbdev->dev;
+ 	int i, err;
+ 
+ 	for (i = 0; i < 2; i++) {
+ 		struct toneport_led *led = &toneport->leds[i];
+ 		struct led_classdev *leddev = &led->dev;
+ 
+ 		led->toneport = toneport;
+ 		snprintf(led->name, sizeof(led->name), "%s::%s",
+ 			 dev_name(dev), led_colors[i]);
+ 		leddev->name = led->name;
+ 		leddev->brightness = led_init_vals[i];
+ 		leddev->max_brightness = 0x26;
+ 		leddev->brightness_set = toneport_led_brightness_set;
+ 		err = led_classdev_register(dev, leddev);
+ 		if (err)
+ 			return err;
+ 		led->registered = true;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void toneport_remove_leds(struct usb_line6_toneport *toneport)
+ {
+ 	struct toneport_led *led;
+ 	int i;
+ 
+ 	for (i = 0; i < 2; i++) {
+ 		led = &toneport->leds[i];
+ 		if (!led->registered)
+ 			break;
+ 		led_classdev_unregister(&led->dev);
+ 		led->registered = false;
+ 	}
++>>>>>>> f44edd7b2bbe (ALSA: line6/toneport: Implement LED controls via LED class):sound/usb/line6/toneport.c
  }
  
  /*
@@@ -314,29 -374,44 +446,54 @@@ static void toneport_setup(struct usb_l
  		toneport_send_cmd(usbdev,
  				  toneport_source_info[toneport->source].code,
  				  0x0000);
 -	default:
 -		break;
  	}
  
++<<<<<<< HEAD:drivers/staging/line6/toneport.c
 +	if (toneport_has_led(usbdev->descriptor.idProduct))
 +		toneport_update_led(&usbdev->dev);
 +}
 +
 +/*
++=======
+ 	if (toneport_has_led(toneport->type))
+ 		toneport_update_led(toneport);
+ 
+ 	mod_timer(&toneport->timer, jiffies + TONEPORT_PCM_DELAY * HZ);
+ }
+ 
+ /*
+ 	Toneport device disconnected.
+ */
+ static void line6_toneport_disconnect(struct usb_interface *interface)
+ {
+ 	struct usb_line6_toneport *toneport;
+ 
+ 	toneport = usb_get_intfdata(interface);
+ 	del_timer_sync(&toneport->timer);
+ 
+ 	if (toneport_has_led(toneport->type))
+ 		toneport_remove_leds(toneport);
+ }
+ 
+ 
+ /*
++>>>>>>> f44edd7b2bbe (ALSA: line6/toneport: Implement LED controls via LED class):sound/usb/line6/toneport.c
  	 Try to init Toneport device.
  */
 -static int toneport_init(struct usb_interface *interface,
 -			 struct usb_line6 *line6)
 +static int toneport_try_init(struct usb_interface *interface,
 +			     struct usb_line6_toneport *toneport)
  {
  	int err;
 -	struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;
 +	struct usb_line6 *line6 = &toneport->line6;
 +	struct usb_device *usbdev = line6->usbdev;
  
 -	setup_timer(&toneport->timer, toneport_start_pcm,
 -		    (unsigned long)toneport);
 +	if ((interface == NULL) || (toneport == NULL))
 +		return -ENODEV;
  
 -	line6->disconnect = line6_toneport_disconnect;
 +	/* initialize audio system: */
 +	err = line6_init_audio(line6);
 +	if (err < 0)
 +		return err;
  
  	/* initialize PCM subsystem: */
  	err = line6_init_pcm(line6, &toneport_pcm_properties);
@@@ -372,11 -445,10 +529,18 @@@
  	line6_read_serial_number(line6, &toneport->serial_number);
  	line6_read_data(line6, 0x80c2, &toneport->firmware_version, 1);
  
++<<<<<<< HEAD:drivers/staging/line6/toneport.c
 +	if (toneport_has_led(usbdev->descriptor.idProduct)) {
 +		CHECK_RETURN(device_create_file
 +			     (&interface->dev, &dev_attr_led_red));
 +		CHECK_RETURN(device_create_file
 +			     (&interface->dev, &dev_attr_led_green));
++=======
+ 	if (toneport_has_led(toneport->type)) {
+ 		err = toneport_init_leds(toneport);
+ 		if (err < 0)
+ 			return err;
++>>>>>>> f44edd7b2bbe (ALSA: line6/toneport: Implement LED controls via LED class):sound/usb/line6/toneport.c
  	}
  
  	toneport_setup(toneport);
* Unmerged path sound/usb/line6/Kconfig
* Unmerged path drivers/staging/line6/toneport.c
* Unmerged path sound/usb/line6/Kconfig
