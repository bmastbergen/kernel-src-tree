Btrfs: cleanup the read failure record after write or when the inode is freeing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Miao Xie <miaox@cn.fujitsu.com>
commit f612496bca664bff6a09a99a9a7506410b6e876e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/f612496b.failed

After the data is written successfully, we should cleanup the read failure record
in that range because
- If we set data COW for the file, the range that the failure record pointed to is
  mapped to a new place, so it is invalid.
- If we set no data COW for the file, and if there is no error during writting,
  the corrupted data is corrected, so the failure record can be removed. And if
  some errors happen on the mirrors, we also needn't worry about it because the
  failure record will be recreated if we read the same place again.

Sometimes, we may fail to correct the data, so the failure records will be left
in the tree, we need free them when we free the inode or the memory leak happens.

	Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
	Signed-off-by: Chris Mason <clm@fb.com>
(cherry picked from commit f612496bca664bff6a09a99a9a7506410b6e876e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/extent_io.c
#	fs/btrfs/extent_io.h
diff --cc fs/btrfs/extent_io.c
index ef4a66010819,78229007f99e..000000000000
--- a/fs/btrfs/extent_io.c
+++ b/fs/btrfs/extent_io.c
@@@ -2158,21 -2139,45 +2158,59 @@@ out
  }
  
  /*
++<<<<<<< HEAD
 + * this is a generic handler for readpage errors (default
 + * readpage_io_failed_hook). if other copies exist, read those and write back
 + * good data to the failed position. does not investigate in remapping the
 + * failed extent elsewhere, hoping the device will be smart enough to do this as
 + * needed
 + */
 +
 +static int bio_readpage_error(struct bio *failed_bio, u64 phy_offset,
 +			      struct page *page, u64 start, u64 end,
 +			      int failed_mirror)
++=======
+  * Can be called when
+  * - hold extent lock
+  * - under ordered extent
+  * - the inode is freeing
+  */
+ void btrfs_free_io_failure_record(struct inode *inode, u64 start, u64 end)
+ {
+ 	struct extent_io_tree *failure_tree = &BTRFS_I(inode)->io_failure_tree;
+ 	struct io_failure_record *failrec;
+ 	struct extent_state *state, *next;
+ 
+ 	if (RB_EMPTY_ROOT(&failure_tree->state))
+ 		return;
+ 
+ 	spin_lock(&failure_tree->lock);
+ 	state = find_first_extent_bit_state(failure_tree, start, EXTENT_DIRTY);
+ 	while (state) {
+ 		if (state->start > end)
+ 			break;
+ 
+ 		ASSERT(state->end <= end);
+ 
+ 		next = next_state(state);
+ 
+ 		failrec = (struct io_failure_record *)state->private;
+ 		free_extent_state(state);
+ 		kfree(failrec);
+ 
+ 		state = next;
+ 	}
+ 	spin_unlock(&failure_tree->lock);
+ }
+ 
+ int btrfs_get_io_failure_record(struct inode *inode, u64 start, u64 end,
+ 				struct io_failure_record **failrec_ret)
++>>>>>>> f612496bca66 (Btrfs: cleanup the read failure record after write or when the inode is freeing)
  {
 -	struct io_failure_record *failrec;
 +	struct io_failure_record *failrec = NULL;
  	u64 private;
  	struct extent_map *em;
 +	struct inode *inode = page->mapping->host;
  	struct extent_io_tree *failure_tree = &BTRFS_I(inode)->io_failure_tree;
  	struct extent_io_tree *tree = &BTRFS_I(inode)->io_tree;
  	struct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;
diff --cc fs/btrfs/extent_io.h
index c1d5f491439f,5e91fb9d1764..000000000000
--- a/fs/btrfs/extent_io.h
+++ b/fs/btrfs/extent_io.h
@@@ -344,6 -344,38 +344,39 @@@ int repair_io_failure(struct inode *ino
  int end_extent_writepage(struct page *page, int err, u64 start, u64 end);
  int repair_eb_io_failure(struct btrfs_root *root, struct extent_buffer *eb,
  			 int mirror_num);
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * When IO fails, either with EIO or csum verification fails, we
+  * try other mirrors that might have a good copy of the data.  This
+  * io_failure_record is used to record state as we go through all the
+  * mirrors.  If another mirror has good data, the page is set up to date
+  * and things continue.  If a good mirror can't be found, the original
+  * bio end_io callback is called to indicate things have failed.
+  */
+ struct io_failure_record {
+ 	struct page *page;
+ 	u64 start;
+ 	u64 len;
+ 	u64 logical;
+ 	unsigned long bio_flags;
+ 	int this_mirror;
+ 	int failed_mirror;
+ 	int in_validation;
+ };
+ 
+ void btrfs_free_io_failure_record(struct inode *inode, u64 start, u64 end);
+ int btrfs_get_io_failure_record(struct inode *inode, u64 start, u64 end,
+ 				struct io_failure_record **failrec_ret);
+ int btrfs_check_repairable(struct inode *inode, struct bio *failed_bio,
+ 			   struct io_failure_record *failrec, int fail_mirror);
+ struct bio *btrfs_create_repair_bio(struct inode *inode, struct bio *failed_bio,
+ 				    struct io_failure_record *failrec,
+ 				    struct page *page, int pg_offset, int icsum,
+ 				    bio_end_io_t *endio_func, void *data);
+ int free_io_failure(struct inode *inode, struct io_failure_record *rec);
++>>>>>>> f612496bca66 (Btrfs: cleanup the read failure record after write or when the inode is freeing)
  #ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS
  noinline u64 find_lock_delalloc_range(struct inode *inode,
  				      struct extent_io_tree *tree,
* Unmerged path fs/btrfs/extent_io.c
* Unmerged path fs/btrfs/extent_io.h
diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c
index a4bd5317d647..4cc5e105a64d 100644
--- a/fs/btrfs/inode.c
+++ b/fs/btrfs/inode.c
@@ -2703,6 +2703,10 @@ static int btrfs_finish_ordered_io(struct btrfs_ordered_extent *ordered_extent)
 		goto out;
 	}
 
+	btrfs_free_io_failure_record(inode, ordered_extent->file_offset,
+				     ordered_extent->file_offset +
+				     ordered_extent->len - 1);
+
 	if (test_bit(BTRFS_ORDERED_TRUNCATED, &ordered_extent->flags)) {
 		truncated = true;
 		logical_len = ordered_extent->truncated_len;
@@ -4788,6 +4792,8 @@ void btrfs_evict_inode(struct inode *inode)
 	/* do we really want it for ->i_nlink > 0 and zero btrfs_root_refs? */
 	btrfs_wait_ordered_range(inode, 0, (u64)-1);
 
+	btrfs_free_io_failure_record(inode, 0, (u64)-1);
+
 	if (root->fs_info->log_root_recovering) {
 		BUG_ON(test_bit(BTRFS_INODE_HAS_ORPHAN_ITEM,
 				 &BTRFS_I(inode)->runtime_flags));
