bonding: change the bond's vlan syncing functions with the standard ones

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author nikolay@redhat.com <nikolay@redhat.com>
commit 1ff412ad7714f6952f76ffd77f0a7f2f563288a1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/1ff412ad.failed

Now we have vlan_vids_add/del_by_dev() which serve the same purpose as
bond's bond_add/del_vlans_on_slave() with the good side effect of
reverting the changes if one of the additions fails.
There's only 1 change in the behaviour of enslave: if adding of the
vlans to the slave fails, we'll fail the enslaving because otherwise we
might delete some vlan that wasn't added by the bonding.
The only way this may happen is with ENOMEM currently, so we're in trouble
anyway.

	Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
	Acked-by: Veaceslav Falico <vfalico@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1ff412ad7714f6952f76ffd77f0a7f2f563288a1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
diff --cc drivers/net/bonding/bond_main.c
index ef8213746e65,78b0aeb13545..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -1874,12 -1780,10 +1851,19 @@@ err_dest_symlinks
  	bond_destroy_slave_symlinks(bond_dev, slave_dev);
  
  err_detach:
++<<<<<<< HEAD
 +	if (!USES_PRIMARY(bond->params.mode)) {
 +		netif_addr_lock_bh(bond_dev);
 +		bond_mc_list_flush(bond_dev, slave_dev);
 +		netif_addr_unlock_bh(bond_dev);
 +	}
 +	bond_del_vlans_from_slave(bond, slave_dev);
++=======
+ 	if (!USES_PRIMARY(bond->params.mode))
+ 		bond_hw_addr_flush(bond_dev, slave_dev);
+ 
+ 	vlan_vids_del_by_dev(slave_dev, bond_dev);
++>>>>>>> 1ff412ad7714 (bonding: change the bond's vlan syncing functions with the standard ones)
  	write_lock_bh(&bond->lock);
  	bond_detach_slave(bond, new_slave);
  	if (bond->primary_slave == new_slave)
@@@ -2068,21 -1979,14 +2052,21 @@@ static int __bond_release_one(struct ne
  	/* must do this from outside any spinlocks */
  	bond_destroy_slave_symlinks(bond_dev, slave_dev);
  
- 	bond_del_vlans_from_slave(bond, slave_dev);
+ 	vlan_vids_del_by_dev(slave_dev, bond_dev);
  
 -	/* If the mode USES_PRIMARY, then this cases was handled above by
 -	 * bond_change_active_slave(..., NULL)
 +	/* If the mode USES_PRIMARY, then we should only remove its
 +	 * promisc and mc settings if it was the curr_active_slave, but that was
 +	 * already taken care of above when we detached the slave
  	 */
  	if (!USES_PRIMARY(bond->params.mode)) {
 -		/* unset promiscuity level from slave */
 -		if (bond_dev->flags & IFF_PROMISC)
 +		/* unset promiscuity level from slave
 +		 * NOTE: The NETDEV_CHANGEADDR call above may change the value
 +		 * of the IFF_PROMISC flag in the bond_dev, but we need the
 +		 * value of that flag before that change, as that was the value
 +		 * when this slave was attached, so we cache at the start of the
 +		 * function and use it here. Same goes for ALLMULTI below
 +		 */
 +		if (old_flags & IFF_PROMISC)
  			dev_set_promiscuity(slave_dev, -1);
  
  		/* unset allmulti level from slave */
* Unmerged path drivers/net/bonding/bond_main.c
