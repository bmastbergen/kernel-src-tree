timekeeping: Convert timekeeping core to use timespec64s

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author John Stultz <john.stultz@linaro.org>
commit 7d489d15ce4be5310ca60e5896df833f9b3b4088
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/7d489d15.failed

Convert the core timekeeping logic to use timespec64s. This moves the
2038 issues out of the core logic and into all of the accessor
functions.

Future changes will need to push the timespec64s out to all
timekeeping users, but that can be done interface by interface.

	Signed-off-by: John Stultz <john.stultz@linaro.org>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: John Stultz <john.stultz@linaro.org>
(cherry picked from commit 7d489d15ce4be5310ca60e5896df833f9b3b4088)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/time/timekeeping.c
#	kernel/time/timekeeping_debug.c
#	kernel/time/timekeeping_internal.h
diff --cc kernel/time/timekeeping.c
index 129b1a43892d,84a2075c3eb4..000000000000
--- a/kernel/time/timekeeping.c
+++ b/kernel/time/timekeeping.c
@@@ -71,22 -72,22 +71,28 @@@ static void tk_set_wall_to_mono(struct 
  	 * Verify consistency of: offset_real = -wall_to_monotonic
  	 * before modifying anything
  	 */
- 	set_normalized_timespec(&tmp, -tk->wall_to_monotonic.tv_sec,
+ 	set_normalized_timespec64(&tmp, -tk->wall_to_monotonic.tv_sec,
  					-tk->wall_to_monotonic.tv_nsec);
- 	WARN_ON_ONCE(tk->offs_real.tv64 != timespec_to_ktime(tmp).tv64);
+ 	WARN_ON_ONCE(tk->offs_real.tv64 != timespec64_to_ktime(tmp).tv64);
  	tk->wall_to_monotonic = wtm;
++<<<<<<< HEAD
 +	set_normalized_timespec(&tmp, -wtm.tv_sec, -wtm.tv_nsec);
 +	tk->offs_real = timespec_to_ktime(tmp);
 +	tk->offs_tai = ktime_sub(tk->offs_real, ktime_set(tk->tai_offset, 0));
++=======
+ 	set_normalized_timespec64(&tmp, -wtm.tv_sec, -wtm.tv_nsec);
+ 	tk->offs_real = timespec64_to_ktime(tmp);
+ 	tk->offs_tai = ktime_add(tk->offs_real, ktime_set(tk->tai_offset, 0));
++>>>>>>> 7d489d15ce4b (timekeeping: Convert timekeeping core to use timespec64s)
  }
  
- static void tk_set_sleep_time(struct timekeeper *tk, struct timespec t)
+ static void tk_set_sleep_time(struct timekeeper *tk, struct timespec64 t)
  {
  	/* Verify consistency before modifying */
- 	WARN_ON_ONCE(tk->offs_boot.tv64 != timespec_to_ktime(tk->total_sleep_time).tv64);
+ 	WARN_ON_ONCE(tk->offs_boot.tv64 != timespec64_to_ktime(tk->total_sleep_time).tv64);
  
  	tk->total_sleep_time	= t;
- 	tk->offs_boot		= timespec_to_ktime(t);
+ 	tk->offs_boot		= timespec64_to_ktime(t);
  }
  
  /**
@@@ -286,8 -280,8 +292,13 @@@ static void timekeeping_forward_now(str
  
  	tk_normalize_xtime(tk);
  
++<<<<<<< HEAD
 +	nsec = clocksource_cyc2ns(delta, clock->mult, clock->shift);
 +	timespec_add_ns(&tk->raw_time, nsec);
++=======
+ 	nsec = clocksource_cyc2ns(cycle_delta, clock->mult, clock->shift);
+ 	timespec64_add_ns(&tk->raw_time, nsec);
++>>>>>>> 7d489d15ce4b (timekeeping: Convert timekeeping core to use timespec64s)
  }
  
  /**
@@@ -839,16 -850,18 +860,29 @@@ static struct timespec64 timekeeping_su
   * adds the sleep offset to the timekeeping variables.
   */
  static void __timekeeping_inject_sleeptime(struct timekeeper *tk,
- 							struct timespec *delta)
+ 					   struct timespec64 *delta)
  {
++<<<<<<< HEAD
 +	if (!timespec_valid_strict(delta)) {
 +		printk(KERN_WARNING "__timekeeping_inject_sleeptime: Invalid "
 +					"sleep delta value!\n");
 +		return;
 +	}
 +	tk_xtime_add(tk, delta);
 +	tk_set_wall_to_mono(tk, timespec_sub(tk->wall_to_monotonic, *delta));
 +	tk_set_sleep_time(tk, timespec_add(tk->total_sleep_time, *delta));
++=======
+ 	if (!timespec64_valid_strict(delta)) {
+ 		printk_deferred(KERN_WARNING
+ 				"__timekeeping_inject_sleeptime: Invalid "
+ 				"sleep delta value!\n");
+ 		return;
+ 	}
+ 	tk_xtime_add(tk, delta);
+ 	tk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, *delta));
+ 	tk_set_sleep_time(tk, timespec64_add(tk->total_sleep_time, *delta));
+ 	tk_debug_account_sleep_time(delta);
++>>>>>>> 7d489d15ce4b (timekeeping: Convert timekeeping core to use timespec64s)
  }
  
  /**
@@@ -1014,8 -1032,10 +1054,8 @@@ static int timekeeping_suspend(void
  	} else {
  		/* Otherwise try to adjust old_system to compensate */
  		timekeeping_suspend_time =
- 			timespec_add(timekeeping_suspend_time, delta_delta);
+ 			timespec64_add(timekeeping_suspend_time, delta_delta);
  	}
 -
 -	timekeeping_update(tk, TK_MIRROR);
  	write_seqcount_end(&timekeeper_seq);
  	raw_spin_unlock_irqrestore(&timekeeper_lock, flags);
  
@@@ -1549,24 -1599,33 +1594,38 @@@ void do_timer(unsigned long ticks
  }
  
  /**
 - * ktime_get_update_offsets_tick - hrtimer helper
 - * @offs_real:	pointer to storage for monotonic -> realtime offset
 - * @offs_boot:	pointer to storage for monotonic -> boottime offset
 - * @offs_tai:	pointer to storage for monotonic -> clock tai offset
 - *
 - * Returns monotonic time at last tick and various offsets
 + * get_xtime_and_monotonic_and_sleep_offset() - get xtime, wall_to_monotonic,
 + *    and sleep offsets.
 + * @xtim:	pointer to timespec to be set with xtime
 + * @wtom:	pointer to timespec to be set with wall_to_monotonic
 + * @sleep:	pointer to timespec to be set with time in suspend
   */
 -ktime_t ktime_get_update_offsets_tick(ktime_t *offs_real, ktime_t *offs_boot,
 -							ktime_t *offs_tai)
 +void get_xtime_and_monotonic_and_sleep_offset(struct timespec *xtim,
 +				struct timespec *wtom, struct timespec *sleep)
  {
  	struct timekeeper *tk = &timekeeper;
++<<<<<<< HEAD
 +	unsigned long seq;
 +
 +	do {
 +		seq = read_seqcount_begin(&timekeeper_seq);
 +		*xtim = tk_xtime(tk);
 +		*wtom = tk->wall_to_monotonic;
 +		*sleep = tk->total_sleep_time;
++=======
+ 	struct timespec64 ts;
+ 	ktime_t now;
+ 	unsigned int seq;
+ 
+ 	do {
+ 		seq = read_seqcount_begin(&timekeeper_seq);
+ 
+ 		ts = tk_xtime(tk);
+ 		*offs_real = tk->offs_real;
+ 		*offs_boot = tk->offs_boot;
+ 		*offs_tai = tk->offs_tai;
++>>>>>>> 7d489d15ce4b (timekeeping: Convert timekeeping core to use timespec64s)
  	} while (read_seqcount_retry(&timekeeper_seq, seq));
 -
 -	now = ktime_set(ts.tv_sec, ts.tv_nsec);
 -	now = ktime_sub(now, *offs_real);
 -	return now;
  }
  
  #ifdef CONFIG_HIGH_RES_TIMERS
diff --cc kernel/time/timekeeping_internal.h
index 676947b97c42,e3d28ad236f9..000000000000
--- a/kernel/time/timekeeping_internal.h
+++ b/kernel/time/timekeeping_internal.h
@@@ -4,20 -4,11 +4,25 @@@
   * timekeeping debug functions
   */
  #include <linux/time.h>
 +#include <linux/clocksource.h>
  
++<<<<<<< HEAD
 +#ifdef CONFIG_CLOCKSOURCE_VALIDATE_LAST_CYCLE
 +static inline cycle_t clocksource_delta(cycle_t now, cycle_t last, cycle_t mask)
 +{
 +	cycle_t ret = (now - last) & mask;
 +
 +	return (s64) ret > 0 ? ret : 0;
 +}
++=======
+ #ifdef CONFIG_DEBUG_FS
+ extern void tk_debug_account_sleep_time(struct timespec64 *t);
++>>>>>>> 7d489d15ce4b (timekeeping: Convert timekeeping core to use timespec64s)
  #else
 -#define tk_debug_account_sleep_time(x)
 +static inline cycle_t clocksource_delta(cycle_t now, cycle_t last, cycle_t mask)
 +{
 +	return (now - last) & mask;
 +}
  #endif
  
  #endif /* _TIMEKEEPING_INTERNAL_H */
* Unmerged path kernel/time/timekeeping_debug.c
diff --git a/include/linux/timekeeper_internal.h b/include/linux/timekeeper_internal.h
index 4e31044f893e..0931faa496ec 100644
--- a/include/linux/timekeeper_internal.h
+++ b/include/linux/timekeeper_internal.h
@@ -55,15 +55,15 @@ struct timekeeper {
 	 * - wall_to_monotonic is no longer the boot time, getboottime must be
 	 * used instead.
 	 */
-	struct timespec		wall_to_monotonic;
+	struct timespec64	wall_to_monotonic;
 	/* Offset clock monotonic -> clock realtime */
 	ktime_t			offs_real;
 	/* time spent in suspend */
-	struct timespec		total_sleep_time;
+	struct timespec64	total_sleep_time;
 	/* Offset clock monotonic -> clock boottime */
 	ktime_t			offs_boot;
 	/* The raw monotonic time for the CLOCK_MONOTONIC_RAW posix clock. */
-	struct timespec		raw_time;
+	struct timespec64	raw_time;
 	/* The current UTC to TAI offset in seconds */
 	s32			tai_offset;
 	/* Offset clock monotonic -> clock tai */
@@ -79,9 +79,9 @@ struct timekeeper {
 	u32			ntp_err_mult;
 };
 
-static inline struct timespec tk_xtime(struct timekeeper *tk)
+static inline struct timespec64 tk_xtime(struct timekeeper *tk)
 {
-	struct timespec ts;
+	struct timespec64 ts;
 
 	ts.tv_sec = tk->xtime_sec;
 	ts.tv_nsec = (long)(tk->xtime_nsec >> tk->shift);
diff --git a/kernel/time/ntp.c b/kernel/time/ntp.c
index af8d1d4f3d55..02eb93aa8431 100644
--- a/kernel/time/ntp.c
+++ b/kernel/time/ntp.c
@@ -530,7 +530,7 @@ void ntp_notify_cmos_timer(void) { }
 /*
  * Propagate a new txc->status value into the NTP state:
  */
-static inline void process_adj_status(struct timex *txc, struct timespec *ts)
+static inline void process_adj_status(struct timex *txc, struct timespec64 *ts)
 {
 	if ((time_status & STA_PLL) && !(txc->status & STA_PLL)) {
 		time_state = TIME_OK;
@@ -553,7 +553,7 @@ static inline void process_adj_status(struct timex *txc, struct timespec *ts)
 
 
 static inline void process_adjtimex_modes(struct timex *txc,
-						struct timespec *ts,
+						struct timespec64 *ts,
 						s32 *time_tai)
 {
 	if (txc->modes & ADJ_STATUS)
@@ -639,7 +639,7 @@ int ntp_validate_timex(struct timex *txc)
  * adjtimex mainly allows reading (and writing, if superuser) of
  * kernel time-keeping variables. used by xntpd.
  */
-int __do_adjtimex(struct timex *txc, struct timespec *ts, s32 *time_tai)
+int __do_adjtimex(struct timex *txc, struct timespec64 *ts, s32 *time_tai)
 {
 	int result;
 
@@ -683,7 +683,7 @@ int __do_adjtimex(struct timex *txc, struct timespec *ts, s32 *time_tai)
 	/* fill PPS status fields */
 	pps_fill_timex(txc);
 
-	txc->time.tv_sec = ts->tv_sec;
+	txc->time.tv_sec = (time_t)ts->tv_sec;
 	txc->time.tv_usec = ts->tv_nsec;
 	if (!(time_status & STA_NANO))
 		txc->time.tv_usec /= NSEC_PER_USEC;
diff --git a/kernel/time/ntp_internal.h b/kernel/time/ntp_internal.h
index 1950cb4ca2a4..bbd102ad9df7 100644
--- a/kernel/time/ntp_internal.h
+++ b/kernel/time/ntp_internal.h
@@ -7,6 +7,6 @@ extern void ntp_clear(void);
 extern u64 ntp_tick_length(void);
 extern int second_overflow(unsigned long secs);
 extern int ntp_validate_timex(struct timex *);
-extern int __do_adjtimex(struct timex *, struct timespec *, s32 *);
+extern int __do_adjtimex(struct timex *, struct timespec64 *, s32 *);
 extern void __hardpps(const struct timespec *, const struct timespec *);
 #endif /* _LINUX_NTP_INTERNAL_H */
* Unmerged path kernel/time/timekeeping.c
* Unmerged path kernel/time/timekeeping_debug.c
* Unmerged path kernel/time/timekeeping_internal.h
