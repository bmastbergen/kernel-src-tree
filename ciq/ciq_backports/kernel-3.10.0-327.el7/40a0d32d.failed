fork: unify and tighten up CLONE_NEWUSER/CLONE_NEWPID checks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Oleg Nesterov <oleg@redhat.com>
commit 40a0d32d1eaffe6aac7324ca92604b6b3977eb0e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/40a0d32d.failed

do_fork() denies CLONE_THREAD | CLONE_PARENT if NEWUSER | NEWPID.

Then later copy_process() denies CLONE_SIGHAND if the new process will
be in a different pid namespace (task_active_pid_ns() doesn't match
current->nsproxy->pid_ns).

This looks confusing and inconsistent.  CLONE_NEWPID is very similar to
the case when ->pid_ns was already unshared, we want the same
restrictions so copy_process() should also nack CLONE_PARENT.

And it would be better to deny CLONE_NEWUSER && CLONE_SIGHAND as well
just for consistency.

Kill the "CLONE_NEWUSER | CLONE_NEWPID" check in do_fork() and change
copy_process() to do the same check along with ->pid_ns check we already
have.

	Signed-off-by: Oleg Nesterov <oleg@redhat.com>
	Acked-by: Andy Lutomirski <luto@amacapital.net>
	Cc: "Eric W. Biederman" <ebiederm@xmission.com>
	Cc: Colin Walters <walters@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 40a0d32d1eaffe6aac7324ca92604b6b3977eb0e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/fork.c
diff --cc kernel/fork.c
index 0b12f8b68265,84703db06cf3..000000000000
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@@ -1186,13 -1173,16 +1186,22 @@@ static struct task_struct *copy_process
  		return ERR_PTR(-EINVAL);
  
  	/*
- 	 * If the new process will be in a different pid namespace don't
- 	 * allow it to share a thread group or signal handlers with the
- 	 * forking task.
+ 	 * If the new process will be in a different pid or user namespace
+ 	 * do not allow it to share a thread group or signal handlers or
+ 	 * parent with the forking task.
  	 */
++<<<<<<< HEAD
 +	if ((clone_flags & (CLONE_SIGHAND | CLONE_NEWPID)) &&
 +	    (task_active_pid_ns(current) != current->nsproxy->pid_ns))
 +		return ERR_PTR(-EINVAL);
++=======
+ 	if (clone_flags & (CLONE_SIGHAND | CLONE_PARENT)) {
+ 		if ((clone_flags & (CLONE_NEWUSER | CLONE_NEWPID)) ||
+ 		    (task_active_pid_ns(current) !=
+ 				current->nsproxy->pid_ns_for_children))
+ 			return ERR_PTR(-EINVAL);
+ 	}
++>>>>>>> 40a0d32d1eaf (fork: unify and tighten up CLONE_NEWUSER/CLONE_NEWPID checks)
  
  	retval = security_task_create(clone_flags);
  	if (retval)
* Unmerged path kernel/fork.c
