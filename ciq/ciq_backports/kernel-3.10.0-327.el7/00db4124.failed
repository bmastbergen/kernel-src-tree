ipv4: coding style: comparison for inequality with NULL

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] geneve: coding style: comparison for inequality with NULL (Jiri Benc) [1156461 1211348]
Rebuild_FUZZ: 92.86%
commit-author Ian Morris <ipm@chirality.org.uk>
commit 00db41243e8d5032c2e0f5bf6063bb19324bfdb3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/00db4124.failed

The ipv4 code uses a mixture of coding styles. In some instances check
for non-NULL pointer is done as x != NULL and sometimes as x. x is
preferred according to checkpatch and this patch makes the code
consistent by adopting the latter form.

No changes detected by objdiff.

	Signed-off-by: Ian Morris <ipm@chirality.org.uk>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 00db41243e8d5032c2e0f5bf6063bb19324bfdb3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/devinet.c
#	net/ipv4/fib_trie.c
#	net/ipv4/inet_hashtables.c
#	net/ipv4/ping.c
#	net/ipv4/route.c
#	net/ipv4/tcp.c
#	net/ipv4/tcp_output.c
#	net/ipv4/udp.c
diff --cc net/ipv4/devinet.c
index 0da4dc8f4743,419d23c53ec7..000000000000
--- a/net/ipv4/devinet.c
+++ b/net/ipv4/devinet.c
@@@ -1248,12 -1289,10 +1248,16 @@@ __be32 inet_confirm_addr(struct in_devi
  {
  	__be32 addr = 0;
  	struct net_device *dev;
 +	struct net *net;
  
++<<<<<<< HEAD
 +	if (scope != RT_SCOPE_LINK)
++=======
+ 	if (in_dev)
++>>>>>>> 00db41243e8d (ipv4: coding style: comparison for inequality with NULL)
  		return confirm_addr_indev(in_dev, dst, local, scope);
  
 +	net = dev_net(in_dev->dev);
  	rcu_read_lock();
  	for_each_netdev_rcu(net, dev) {
  		in_dev = __in_dev_get_rcu(dev);
diff --cc net/ipv4/fib_trie.c
index 8be89b1a8b93,e13fcc602da2..000000000000
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@@ -381,17 -382,18 +381,23 @@@ static inline int tnode_full(const stru
  /* Add a child at position i overwriting the old value.
   * Update the value of full_children and empty_children.
   */
 -static void put_child(struct key_vector *tn, unsigned long i,
 -		      struct key_vector *n)
 +static void put_child(struct tnode *tn, unsigned long i, struct tnode *n)
  {
 -	struct key_vector *chi = get_child(tn, i);
 +	struct tnode *chi = tnode_get_child(tn, i);
  	int isfull, wasfull;
  
 -	BUG_ON(i >= child_length(tn));
 +	BUG_ON(i >= tnode_child_length(tn));
  
  	/* update emptyChildren, overflow into fullChildren */
++<<<<<<< HEAD
 +	if (n == NULL && chi != NULL)
 +		empty_child_inc(tn);
 +	if (n != NULL && chi == NULL)
++=======
+ 	if (!n && chi)
+ 		empty_child_inc(tn);
+ 	if (n && !chi)
++>>>>>>> 00db41243e8d (ipv4: coding style: comparison for inequality with NULL)
  		empty_child_dec(tn);
  
  	/* update fullChildren */
diff --cc net/ipv4/inet_hashtables.c
index fba2f42a1b6c,d4630bf2d9aa..000000000000
--- a/net/ipv4/inet_hashtables.c
+++ b/net/ipv4/inet_hashtables.c
@@@ -35,8 -64,8 +35,13 @@@ struct inet_bind_bucket *inet_bind_buck
  {
  	struct inet_bind_bucket *tb = kmem_cache_alloc(cachep, GFP_ATOMIC);
  
++<<<<<<< HEAD
 +	if (tb != NULL) {
 +		write_pnet(&tb->ib_net, hold_net(net));
++=======
+ 	if (tb) {
+ 		write_pnet(&tb->ib_net, net);
++>>>>>>> 00db41243e8d (ipv4: coding style: comparison for inequality with NULL)
  		tb->port      = snum;
  		tb->fastreuse = 0;
  		tb->fastreuseport = 0;
diff --cc net/ipv4/ping.c
index f0a2419ebdac,a93f260cf24c..000000000000
--- a/net/ipv4/ping.c
+++ b/net/ipv4/ping.c
@@@ -720,13 -970,15 +720,20 @@@ void ping_rcv(struct sk_buff *skb
  	/* Push ICMP header back */
  	skb_push(skb, skb->data - (u8 *)icmph);
  
++<<<<<<< HEAD
 +	sk = ping_v4_lookup(net, saddr, daddr, ntohs(icmph->un.echo.id),
 +			    skb->dev->ifindex);
 +	if (sk != NULL) {
++=======
+ 	sk = ping_lookup(net, skb, ntohs(icmph->un.echo.id));
+ 	if (sk) {
+ 		struct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);
+ 
++>>>>>>> 00db41243e8d (ipv4: coding style: comparison for inequality with NULL)
  		pr_debug("rcv on socket %p\n", sk);
 -		if (skb2)
 -			ping_queue_rcv_skb(sk, skb2);
 +		ping_queue_rcv_skb(sk, skb_get(skb));
  		sock_put(sk);
 -		return true;
 +		return;
  	}
  	pr_debug("no socket, dropping\n");
  
diff --cc net/ipv4/route.c
index e5dadb183261,a78540f28276..000000000000
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@@ -1535,8 -1589,13 +1535,16 @@@ static int __mkroute_input(struct sk_bu
  		}
  	}
  
 -	fnhe = find_exception(&FIB_RES_NH(*res), daddr);
  	if (do_cache) {
++<<<<<<< HEAD
 +		rth = rcu_dereference(FIB_RES_NH(*res).nh_rth_input);
++=======
+ 		if (fnhe)
+ 			rth = rcu_dereference(fnhe->fnhe_rth_input);
+ 		else
+ 			rth = rcu_dereference(FIB_RES_NH(*res).nh_rth_input);
+ 
++>>>>>>> 00db41243e8d (ipv4: coding style: comparison for inequality with NULL)
  		if (rt_cache_valid(rth)) {
  			skb_dst_set_noref(skb, &rth->dst);
  			goto out;
diff --cc net/ipv4/tcp.c
index 82001502275d,094a6822c71d..000000000000
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@@ -2787,6 -2774,14 +2787,17 @@@ static int do_tcp_getsockopt(struct soc
  	case TCP_USER_TIMEOUT:
  		val = jiffies_to_msecs(icsk->icsk_user_timeout);
  		break;
++<<<<<<< HEAD
++=======
+ 
+ 	case TCP_FASTOPEN:
+ 		if (icsk->icsk_accept_queue.fastopenq)
+ 			val = icsk->icsk_accept_queue.fastopenq->max_qlen;
+ 		else
+ 			val = 0;
+ 		break;
+ 
++>>>>>>> 00db41243e8d (ipv4: coding style: comparison for inequality with NULL)
  	case TCP_TIMESTAMP:
  		val = tcp_time_stamp + tp->tsoffset;
  		break;
diff --cc net/ipv4/tcp_output.c
index 074c9a68acbd,7404e5238e00..000000000000
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@@ -624,7 -641,7 +624,11 @@@ static unsigned int tcp_synack_options(
  		if (unlikely(!ireq->tstamp_ok))
  			remaining -= TCPOLEN_SACKPERM_ALIGNED;
  	}
++<<<<<<< HEAD
 +	if (foc != NULL) {
++=======
+ 	if (foc && foc->len >= 0) {
++>>>>>>> 00db41243e8d (ipv4: coding style: comparison for inequality with NULL)
  		u32 need = TCPOLEN_EXP_FASTOPEN_BASE + foc->len;
  		need = (need + 3) & ~3U;  /* Align to 32 bits */
  		if (remaining >= need) {
diff --cc net/ipv4/udp.c
index 8d174c3136c6,2162fc6ce1c1..000000000000
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@@ -1733,13 -1779,30 +1733,17 @@@ int __udp4_lib_rcv(struct sk_buff *skb
  	if (udp4_csum_init(skb, uh, proto))
  		goto csum_error;
  
 -	sk = skb_steal_sock(skb);
 -	if (sk) {
 -		struct dst_entry *dst = skb_dst(skb);
 -		int ret;
 -
 -		if (unlikely(sk->sk_rx_dst != dst))
 -			udp_sk_rx_dst_set(sk, dst);
 -
 -		ret = udp_queue_rcv_skb(sk, skb);
 -		sock_put(sk);
 -		/* a return value > 0 means to resubmit the input, but
 -		 * it wants the return to be -protocol, or 0
 -		 */
 -		if (ret > 0)
 -			return -ret;
 -		return 0;
 -	}
 -
  	if (rt->rt_flags & (RTCF_BROADCAST|RTCF_MULTICAST))
  		return __udp4_lib_mcast_deliver(net, skb, uh,
 -						saddr, daddr, udptable, proto);
 +				saddr, daddr, udptable);
  
  	sk = __udp4_lib_lookup_skb(skb, uh->source, uh->dest, udptable);
++<<<<<<< HEAD
 +
 +	if (sk != NULL) {
++=======
+ 	if (sk) {
++>>>>>>> 00db41243e8d (ipv4: coding style: comparison for inequality with NULL)
  		int ret;
  
  		if (inet_get_convert_csum(sk) && uh->check && !IS_UDPLITE(sk))
diff --git a/net/ipv4/af_inet.c b/net/ipv4/af_inet.c
index 7da79adb81ec..e040e3e4f791 100644
--- a/net/ipv4/af_inet.c
+++ b/net/ipv4/af_inet.c
@@ -1337,7 +1337,7 @@ static struct sk_buff *inet_gso_segment(struct sk_buff *skb,
 		if (udpfrag) {
 			iph->id = htons(id);
 			iph->frag_off = htons(offset >> 3);
-			if (skb->next != NULL)
+			if (skb->next)
 				iph->frag_off |= htons(IP_MF);
 			offset += skb->len - nhoff - ihl;
 		} else {
diff --git a/net/ipv4/arp.c b/net/ipv4/arp.c
index d2b96c3354dc..044292401ac3 100644
--- a/net/ipv4/arp.c
+++ b/net/ipv4/arp.c
@@ -661,7 +661,7 @@ struct sk_buff *arp_create(int type, int ptype, __be32 dest_ip,
 		break;
 #endif
 	default:
-		if (target_hw != NULL)
+		if (target_hw)
 			memcpy(arp_ptr, target_hw, dev->addr_len);
 		else
 			memset(arp_ptr, 0, dev->addr_len);
diff --git a/net/ipv4/cipso_ipv4.c b/net/ipv4/cipso_ipv4.c
index 1c46d73c8f2c..c2c50a9f481f 100644
--- a/net/ipv4/cipso_ipv4.c
+++ b/net/ipv4/cipso_ipv4.c
@@ -503,7 +503,7 @@ int cipso_v4_doi_add(struct cipso_v4_doi *doi_def,
 	atomic_set(&doi_def->refcount, 1);
 
 	spin_lock(&cipso_v4_doi_list_lock);
-	if (cipso_v4_doi_search(doi_def->doi) != NULL) {
+	if (cipso_v4_doi_search(doi_def->doi)) {
 		spin_unlock(&cipso_v4_doi_list_lock);
 		ret_val = -EEXIST;
 		goto doi_add_return;
@@ -514,7 +514,7 @@ int cipso_v4_doi_add(struct cipso_v4_doi *doi_def,
 
 doi_add_return:
 	audit_buf = netlbl_audit_start(AUDIT_MAC_CIPSOV4_ADD, audit_info);
-	if (audit_buf != NULL) {
+	if (audit_buf) {
 		const char *type_str;
 		switch (doi_type) {
 		case CIPSO_V4_MAP_TRANS:
@@ -618,7 +618,7 @@ int cipso_v4_doi_remove(u32 doi, struct netlbl_audit *audit_info)
 
 doi_remove_return:
 	audit_buf = netlbl_audit_start(AUDIT_MAC_CIPSOV4_DEL, audit_info);
-	if (audit_buf != NULL) {
+	if (audit_buf) {
 		audit_log_format(audit_buf,
 				 " cipso_doi=%u res=%u",
 				 doi, ret_val == 0 ? 1 : 0);
* Unmerged path net/ipv4/devinet.c
* Unmerged path net/ipv4/fib_trie.c
diff --git a/net/ipv4/geneve.c b/net/ipv4/geneve.c
index 6c1d8cbeb11d..85a5022134ce 100644
--- a/net/ipv4/geneve.c
+++ b/net/ipv4/geneve.c
@@ -231,7 +231,7 @@ static int geneve_gro_complete(struct sk_buff *skb, int nhoff,
 
 	rcu_read_lock();
 	ptype = gro_find_complete_by_type(type);
-	if (ptype != NULL)
+	if (ptype)
 		err = ptype->callbacks.gro_complete(skb, nhoff + gh_len);
 
 	rcu_read_unlock();
diff --git a/net/ipv4/gre_offload.c b/net/ipv4/gre_offload.c
index 5771ffc8da3d..9355709ffbb0 100644
--- a/net/ipv4/gre_offload.c
+++ b/net/ipv4/gre_offload.c
@@ -247,7 +247,7 @@ static int gre_gro_complete(struct sk_buff *skb, int nhoff)
 
 	rcu_read_lock();
 	ptype = gro_find_complete_by_type(type);
-	if (ptype != NULL)
+	if (ptype)
 		err = ptype->callbacks.gro_complete(skb, nhoff + grehlen);
 
 	rcu_read_unlock();
diff --git a/net/ipv4/igmp.c b/net/ipv4/igmp.c
index b15ffcfd3055..99039bc7ec3d 100644
--- a/net/ipv4/igmp.c
+++ b/net/ipv4/igmp.c
@@ -2319,7 +2319,7 @@ void ip_mc_drop_socket(struct sock *sk)
 		inet->mc_list = iml->next_rcu;
 		in_dev = inetdev_by_index(net, iml->multi.imr_ifindex);
 		(void) ip_mc_leave_src(sk, iml, in_dev);
-		if (in_dev != NULL)
+		if (in_dev)
 			ip_mc_dec_group(in_dev, iml->multi.imr_multiaddr.s_addr);
 		/* decrease mem now to avoid the memleak warning */
 		atomic_sub(sizeof(*iml), &sk->sk_omem_alloc);
@@ -2526,10 +2526,10 @@ static inline struct ip_sf_list *igmp_mcf_get_first(struct seq_file *seq)
 		if (unlikely(idev == NULL))
 			continue;
 		im = rcu_dereference(idev->mc_list);
-		if (likely(im != NULL)) {
+		if (likely(im)) {
 			spin_lock_bh(&im->lock);
 			psf = im->sources;
-			if (likely(psf != NULL)) {
+			if (likely(psf)) {
 				state->im = im;
 				state->idev = idev;
 				break;
@@ -2599,7 +2599,7 @@ static void igmp_mcf_seq_stop(struct seq_file *seq, void *v)
 	__releases(rcu)
 {
 	struct igmp_mcf_iter_state *state = igmp_mcf_seq_private(seq);
-	if (likely(state->im != NULL)) {
+	if (likely(state->im)) {
 		spin_unlock_bh(&state->im->lock);
 		state->im = NULL;
 	}
diff --git a/net/ipv4/inet_connection_sock.c b/net/ipv4/inet_connection_sock.c
index 07622a4e3fa4..fc9a479fb1c2 100644
--- a/net/ipv4/inet_connection_sock.c
+++ b/net/ipv4/inet_connection_sock.c
@@ -677,7 +677,7 @@ struct sock *inet_csk_clone_lock(const struct sock *sk,
 {
 	struct sock *newsk = sk_clone_lock(sk, priority);
 
-	if (newsk != NULL) {
+	if (newsk) {
 		struct inet_connection_sock *newicsk = inet_csk(newsk);
 
 		newsk->sk_state = TCP_SYN_RECV;
@@ -846,7 +846,7 @@ void inet_csk_listen_stop(struct sock *sk)
 		sk_acceptq_removed(sk);
 		__reqsk_free(req);
 	}
-	if (queue->fastopenq != NULL) {
+	if (queue->fastopenq) {
 		/* Free all the reqs queued in rskq_rst_head. */
 		spin_lock_bh(&queue->fastopenq->lock);
 		acc_req = queue->fastopenq->rskq_rst_head;
@@ -878,7 +878,7 @@ int inet_csk_compat_getsockopt(struct sock *sk, int level, int optname,
 {
 	const struct inet_connection_sock *icsk = inet_csk(sk);
 
-	if (icsk->icsk_af_ops->compat_getsockopt != NULL)
+	if (icsk->icsk_af_ops->compat_getsockopt)
 		return icsk->icsk_af_ops->compat_getsockopt(sk, level, optname,
 							    optval, optlen);
 	return icsk->icsk_af_ops->getsockopt(sk, level, optname,
@@ -891,7 +891,7 @@ int inet_csk_compat_setsockopt(struct sock *sk, int level, int optname,
 {
 	const struct inet_connection_sock *icsk = inet_csk(sk);
 
-	if (icsk->icsk_af_ops->compat_setsockopt != NULL)
+	if (icsk->icsk_af_ops->compat_setsockopt)
 		return icsk->icsk_af_ops->compat_setsockopt(sk, level, optname,
 							    optval, optlen);
 	return icsk->icsk_af_ops->setsockopt(sk, level, optname,
* Unmerged path net/ipv4/inet_hashtables.c
diff --git a/net/ipv4/inet_timewait_sock.c b/net/ipv4/inet_timewait_sock.c
index 6d592f8555fb..a5f55d7d54fc 100644
--- a/net/ipv4/inet_timewait_sock.c
+++ b/net/ipv4/inet_timewait_sock.c
@@ -174,7 +174,7 @@ struct inet_timewait_sock *inet_twsk_alloc(const struct sock *sk, const int stat
 	struct inet_timewait_sock *tw =
 		kmem_cache_alloc(sk->sk_prot_creator->twsk_prot->twsk_slab,
 				 GFP_ATOMIC);
-	if (tw != NULL) {
+	if (tw) {
 		const struct inet_sock *inet = inet_sk(sk);
 
 		kmemcheck_annotate_bitfield(tw, flags);
diff --git a/net/ipv4/ip_fragment.c b/net/ipv4/ip_fragment.c
index 049a0fac430a..67171c6dad3a 100644
--- a/net/ipv4/ip_fragment.c
+++ b/net/ipv4/ip_fragment.c
@@ -657,7 +657,8 @@ int ip_defrag(struct sk_buff *skb, u32 user)
 	ip_evictor(net);
 
 	/* Lookup (or create) queue header */
-	if ((qp = ip_find(net, ip_hdr(skb), user)) != NULL) {
+	qp = ip_find(net, ip_hdr(skb), user);
+	if (qp) {
 		int ret;
 
 		spin_lock(&qp->q.lock);
diff --git a/net/ipv4/ip_input.c b/net/ipv4/ip_input.c
index 3d4da2c16b6a..2c93be3ccdad 100644
--- a/net/ipv4/ip_input.c
+++ b/net/ipv4/ip_input.c
@@ -203,7 +203,7 @@ static int ip_local_deliver_finish(struct sk_buff *skb)
 		raw = raw_local_deliver(skb, protocol);
 
 		ipprot = rcu_dereference(inet_protos[protocol]);
-		if (ipprot != NULL) {
+		if (ipprot) {
 			int ret;
 
 			if (!ipprot->no_policy) {
diff --git a/net/ipv4/ip_options.c b/net/ipv4/ip_options.c
index ec7264514a82..56eb535d7722 100644
--- a/net/ipv4/ip_options.c
+++ b/net/ipv4/ip_options.c
@@ -266,7 +266,7 @@ int ip_options_compile(struct net *net,
 	unsigned char *iph;
 	int optlen, l;
 
-	if (skb != NULL) {
+	if (skb) {
 		rt = skb_rtable(skb);
 		optptr = (unsigned char *)&(ip_hdr(skb)[1]);
 	} else
diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index 8c66d61254bb..591ec30494cb 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -255,7 +255,7 @@ static int ip_finish_output(struct sk_buff *skb)
 {
 #if defined(CONFIG_NETFILTER) && defined(CONFIG_XFRM)
 	/* Policy lookup after SNAT yielded a new policy */
-	if (skb_dst(skb)->xfrm != NULL) {
+	if (skb_dst(skb)->xfrm) {
 		IPCB(skb)->flags |= IPSKB_REROUTED;
 		return dst_output(skb);
 	}
@@ -374,7 +374,7 @@ int ip_queue_xmit(struct sk_buff *skb, struct flowi *fl)
 	inet_opt = rcu_dereference(inet->inet_opt);
 	fl4 = &fl->u.ip4;
 	rt = skb_rtable(skb);
-	if (rt != NULL)
+	if (rt)
 		goto packet_routed;
 
 	/* Make sure we can route this packet. */
@@ -587,7 +587,7 @@ int ip_fragment(struct sk_buff *skb, int (*output)(struct sk_buff *))
 					ip_options_fragment(frag);
 				offset += skb->len - hlen;
 				iph->frag_off = htons(offset>>3);
-				if (frag->next != NULL)
+				if (frag->next)
 					iph->frag_off |= htons(IP_MF);
 				/* Ready, complete checksum */
 				ip_send_check(iph);
diff --git a/net/ipv4/ip_sockglue.c b/net/ipv4/ip_sockglue.c
index ed7a5765c117..e59848741d6d 100644
--- a/net/ipv4/ip_sockglue.c
+++ b/net/ipv4/ip_sockglue.c
@@ -338,7 +338,7 @@ void ip_icmp_error(struct sock *sk, struct sk_buff *skb, int err,
 				   skb_network_header(skb);
 	serr->port = port;
 
-	if (skb_pull(skb, payload - skb->data) != NULL) {
+	if (skb_pull(skb, payload - skb->data)) {
 		skb_reset_transport_header(skb);
 		if (sock_queue_err_skb(sk, skb) == 0)
 			return;
diff --git a/net/ipv4/ip_tunnel.c b/net/ipv4/ip_tunnel.c
index 1129aec53c2c..d6cb3a6496d4 100644
--- a/net/ipv4/ip_tunnel.c
+++ b/net/ipv4/ip_tunnel.c
@@ -755,7 +755,7 @@ int ip_tunnel_ioctl(struct net_device *dev, struct ip_tunnel_parm *p, int cmd)
 			break;
 		}
 		if (dev != itn->fb_tunnel_dev && cmd == SIOCCHGTUNNEL) {
-			if (t != NULL) {
+			if (t) {
 				if (t->dev != dev) {
 					err = -EEXIST;
 					break;
diff --git a/net/ipv4/ip_vti.c b/net/ipv4/ip_vti.c
index 25200c49e205..68f136b26409 100644
--- a/net/ipv4/ip_vti.c
+++ b/net/ipv4/ip_vti.c
@@ -60,7 +60,7 @@ static int vti_input(struct sk_buff *skb, int nexthdr, __be32 spi,
 
 	tunnel = ip_tunnel_lookup(itn, skb->dev->ifindex, TUNNEL_NO_KEY,
 				  iph->saddr, iph->daddr, 0);
-	if (tunnel != NULL) {
+	if (tunnel) {
 		if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))
 			goto drop;
 
diff --git a/net/ipv4/ipmr.c b/net/ipv4/ipmr.c
index ca997b6766ed..760a327ea7ba 100644
--- a/net/ipv4/ipmr.c
+++ b/net/ipv4/ipmr.c
@@ -315,7 +315,7 @@ static struct mr_table *ipmr_new_table(struct net *net, u32 id)
 	unsigned int i;
 
 	mrt = ipmr_get_table(net, id);
-	if (mrt != NULL)
+	if (mrt)
 		return mrt;
 
 	mrt = kzalloc(sizeof(*mrt), GFP_KERNEL);
* Unmerged path net/ipv4/ping.c
diff --git a/net/ipv4/raw.c b/net/ipv4/raw.c
index aa890cf77afa..8bc1fa17fe2b 100644
--- a/net/ipv4/raw.c
+++ b/net/ipv4/raw.c
@@ -278,7 +278,7 @@ void raw_icmp_error(struct sk_buff *skb, int protocol, u32 info)
 
 	read_lock(&raw_v4_hashinfo.lock);
 	raw_sk = sk_head(&raw_v4_hashinfo.ht[hash]);
-	if (raw_sk != NULL) {
+	if (raw_sk) {
 		iph = (const struct iphdr *)skb->data;
 		net = dev_net(skb->dev);
 
@@ -846,7 +846,7 @@ static int raw_ioctl(struct sock *sk, int cmd, unsigned long arg)
 
 		spin_lock_bh(&sk->sk_receive_queue.lock);
 		skb = skb_peek(&sk->sk_receive_queue);
-		if (skb != NULL)
+		if (skb)
 			amount = skb->len;
 		spin_unlock_bh(&sk->sk_receive_queue.lock);
 		return put_user(amount, (int __user *)arg);
* Unmerged path net/ipv4/route.c
* Unmerged path net/ipv4/tcp.c
diff --git a/net/ipv4/tcp_diag.c b/net/ipv4/tcp_diag.c
index ed3f2ad42e0f..97a1fac8737e 100644
--- a/net/ipv4/tcp_diag.c
+++ b/net/ipv4/tcp_diag.c
@@ -30,7 +30,7 @@ static void tcp_diag_get_info(struct sock *sk, struct inet_diag_msg *r,
 		r->idiag_rqueue = max_t(int, tp->rcv_nxt - tp->copied_seq, 0);
 		r->idiag_wqueue = tp->write_seq - tp->snd_una;
 	}
-	if (info != NULL)
+	if (info)
 		tcp_get_info(sk, info);
 }
 
diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
index ef845c96b4d4..dcc0d2b85c93 100644
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -1245,7 +1245,7 @@ static u8 tcp_sacktag_one(struct sock *sk,
 		fack_count += pcount;
 
 		/* Lost marker hint past SACKed? Tweak RFC3517 cnt */
-		if (!tcp_is_fack(tp) && (tp->lost_skb_hint != NULL) &&
+		if (!tcp_is_fack(tp) && tp->lost_skb_hint &&
 		    before(start_seq, TCP_SKB_CB(tp->lost_skb_hint)->seq))
 			tp->lost_cnt_hint += pcount;
 
@@ -1524,7 +1524,7 @@ static struct sk_buff *tcp_sacktag_walk(struct sk_buff *skb, struct sock *sk,
 		if (!before(TCP_SKB_CB(skb)->seq, end_seq))
 			break;
 
-		if ((next_dup != NULL) &&
+		if (next_dup  &&
 		    before(TCP_SKB_CB(skb)->seq, next_dup->end_seq)) {
 			in_sack = tcp_match_skb_to_sack(sk, skb,
 							next_dup->start_seq,
@@ -1540,7 +1540,7 @@ static struct sk_buff *tcp_sacktag_walk(struct sk_buff *skb, struct sock *sk,
 		if (in_sack <= 0) {
 			tmp = tcp_shift_skb_data(sk, skb, state,
 						 start_seq, end_seq, dup_sack);
-			if (tmp != NULL) {
+			if (tmp) {
 				if (tmp != skb) {
 					skb = tmp;
 					continue;
@@ -5259,7 +5259,7 @@ void tcp_finish_connect(struct sock *sk, struct sk_buff *skb)
 
 	tcp_set_state(sk, TCP_ESTABLISHED);
 
-	if (skb != NULL) {
+	if (skb) {
 		icsk->icsk_af_ops->sk_rx_dst_set(sk, skb);
 		security_inet_conn_established(sk, skb);
 	}
@@ -5628,7 +5628,7 @@ int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
 	}
 
 	req = tp->fastopen_rsk;
-	if (req != NULL) {
+	if (req) {
 		WARN_ON_ONCE(sk->sk_state != TCP_SYN_RECV &&
 		    sk->sk_state != TCP_FIN_WAIT1);
 
@@ -5718,7 +5718,7 @@ int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
 		 * ACK we have received, this would have acknowledged
 		 * our SYNACK so stop the SYNACK timer.
 		 */
-		if (req != NULL) {
+		if (req) {
 			/* Return RST if ack_seq is invalid.
 			 * Note that RFC793 only says to generate a
 			 * DUPACK for it but for TCP Fast Open it seems
diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c
index cf2a920676db..e02da6895dcb 100644
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@ -1677,7 +1677,7 @@ struct sock *tcp_v4_syn_recv_sock(struct sock *sk, struct sk_buff *skb,
 	/* Copy over the MD5 key from the original socket */
 	key = tcp_md5_do_lookup(sk, (union tcp_md5_addr *)&newinet->inet_daddr,
 				AF_INET);
-	if (key != NULL) {
+	if (key) {
 		/*
 		 * We're using one, so create a matching key
 		 * on the newsk structure. If we fail to get
@@ -2154,7 +2154,7 @@ void tcp_v4_destroy_sock(struct sock *sk)
 	if (inet_csk(sk)->icsk_bind_hash)
 		inet_put_port(sk);
 
-	BUG_ON(tp->fastopen_rsk != NULL);
+	BUG_ON(tp->fastopen_rsk);
 
 	/* If socket is aborted during connect operation */
 	tcp_free_fastopen_req(tp);
diff --git a/net/ipv4/tcp_minisocks.c b/net/ipv4/tcp_minisocks.c
index 6c69a4574ad0..d96097077f58 100644
--- a/net/ipv4/tcp_minisocks.c
+++ b/net/ipv4/tcp_minisocks.c
@@ -294,7 +294,7 @@ void tcp_time_wait(struct sock *sk, int state, int timeo)
 	if (tcp_death_row.tw_count < tcp_death_row.sysctl_max_tw_buckets)
 		tw = inet_twsk_alloc(sk, state);
 
-	if (tw != NULL) {
+	if (tw) {
 		struct tcp_timewait_sock *tcptw = tcp_twsk((struct sock *)tw);
 		const int rto = (icsk->icsk_rto << 2) - (icsk->icsk_rto >> 1);
 		struct inet_sock *inet = inet_sk(sk);
@@ -332,7 +332,7 @@ void tcp_time_wait(struct sock *sk, int state, int timeo)
 			struct tcp_md5sig_key *key;
 			tcptw->tw_md5_key = NULL;
 			key = tp->af_specific->md5_lookup(sk, sk);
-			if (key != NULL) {
+			if (key) {
 				tcptw->tw_md5_key = kmemdup(key, sizeof(*key), GFP_ATOMIC);
 				if (tcptw->tw_md5_key && !tcp_alloc_md5sig_pool())
 					BUG();
@@ -397,7 +397,7 @@ struct sock *tcp_create_openreq_child(struct sock *sk, struct request_sock *req,
 {
 	struct sock *newsk = inet_csk_clone_lock(sk, req, GFP_ATOMIC);
 
-	if (newsk != NULL) {
+	if (newsk) {
 		const struct inet_request_sock *ireq = inet_rsk(req);
 		struct tcp_request_sock *treq = tcp_rsk(req);
 		struct inet_connection_sock *newicsk = inet_csk(newsk);
* Unmerged path net/ipv4/tcp_output.c
* Unmerged path net/ipv4/udp.c
diff --git a/net/ipv4/udp_offload.c b/net/ipv4/udp_offload.c
index 9fc430330a3f..6c81bd0cc4c7 100644
--- a/net/ipv4/udp_offload.c
+++ b/net/ipv4/udp_offload.c
@@ -140,7 +140,7 @@ void udp_del_offload(struct udp_offload *uo)
 	pr_warn("udp_del_offload: didn't find offload for port %d\n", ntohs(uo->port));
 unlock:
 	spin_unlock(&udp_offload_lock);
-	if (uo_priv != NULL)
+	if (uo_priv)
 		call_rcu(&uo_priv->rcu, udp_offload_free_routine);
 }
 EXPORT_SYMBOL(udp_del_offload);
@@ -249,7 +249,7 @@ int udp_gro_complete(struct sk_buff *skb, int nhoff)
 			break;
 	}
 
-	if (uo_priv != NULL) {
+	if (uo_priv) {
 		NAPI_GRO_CB(skb)->proto = uo_priv->offload->ipproto;
 		err = uo_priv->offload->callbacks.gro_complete(skb,
 				nhoff + sizeof(struct udphdr),
