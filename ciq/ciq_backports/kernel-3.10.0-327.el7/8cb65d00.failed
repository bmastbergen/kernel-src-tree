net: Move check for multiple vlans to drivers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] vlan: Move check for multiple vlans to drivers (Ivan Vecera) [1200759]
Rebuild_FUZZ: 94.51%
commit-author Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
commit 8cb65d00086bfba22bac87ff18b751432fc74003
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/8cb65d00.failed

To allow drivers to handle the features check for multiple tags,
move the check to ndo_features_check().
As no drivers currently handle multiple tagged TSO, introduce
dflt_features_check() and call it if the driver does not have
ndo_features_check().

	Signed-off-by: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8cb65d00086bfba22bac87ff18b751432fc74003)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
#	drivers/net/ethernet/mellanox/mlx4/en_netdev.c
#	drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
#	include/linux/if_vlan.h
#	net/core/dev.c
diff --cc drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
index a4f4584b14c4,039b0c1f480e..000000000000
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
@@@ -12439,9 -12553,12 +12439,14 @@@ static int bnx2x_get_phys_port_id(struc
  	return 0;
  }
  
 -static netdev_features_t bnx2x_features_check(struct sk_buff *skb,
 -					      struct net_device *dev,
 -					      netdev_features_t features)
 +static bool bnx2x_gso_check(struct sk_buff *skb, struct net_device *dev)
  {
++<<<<<<< HEAD
 +	return vxlan_gso_check(skb);
++=======
+ 	features = vlan_features_check(skb, features);
+ 	return vxlan_features_check(skb, features);
++>>>>>>> 8cb65d00086b (net: Move check for multiple vlans to drivers)
  }
  
  static const struct net_device_ops bnx2x_netdev_ops = {
diff --cc drivers/net/ethernet/mellanox/mlx4/en_netdev.c
index 6d30799d466a,ebc93a101c93..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
@@@ -2363,9 -2369,12 +2363,14 @@@ static void mlx4_en_del_vxlan_port(stru
  	queue_work(priv->mdev->workqueue, &priv->vxlan_del_task);
  }
  
 -static netdev_features_t mlx4_en_features_check(struct sk_buff *skb,
 -						struct net_device *dev,
 -						netdev_features_t features)
 +static bool mlx4_en_gso_check(struct sk_buff *skb, struct net_device *dev)
  {
++<<<<<<< HEAD
 +	return vxlan_gso_check(skb);
++=======
+ 	features = vlan_features_check(skb, features);
+ 	return vxlan_features_check(skb, features);
++>>>>>>> 8cb65d00086b (net: Move check for multiple vlans to drivers)
  }
  #endif
  
diff --cc drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
index 5b17fe84fe01,367f3976df56..000000000000
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
@@@ -498,9 -503,12 +498,14 @@@ static void qlcnic_del_vxlan_port(struc
  	adapter->flags |= QLCNIC_DEL_VXLAN_PORT;
  }
  
 -static netdev_features_t qlcnic_features_check(struct sk_buff *skb,
 -					       struct net_device *dev,
 -					       netdev_features_t features)
 +static bool qlcnic_gso_check(struct sk_buff *skb, struct net_device *dev)
  {
++<<<<<<< HEAD
 +	return vxlan_gso_check(skb);
++=======
+ 	features = vlan_features_check(skb, features);
+ 	return vxlan_features_check(skb, features);
++>>>>>>> 8cb65d00086b (net: Move check for multiple vlans to drivers)
  }
  #endif
  
diff --cc include/linux/if_vlan.h
index 978291b95d4e,920e4457ce6e..000000000000
--- a/include/linux/if_vlan.h
+++ b/include/linux/if_vlan.h
@@@ -477,4 -560,72 +477,75 @@@ static inline void vlan_set_encap_proto
  		 */
  		skb->protocol = htons(ETH_P_802_2);
  }
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * skb_vlan_tagged - check if skb is vlan tagged.
+  * @skb: skbuff to query
+  *
+  * Returns true if the skb is tagged, regardless of whether it is hardware
+  * accelerated or not.
+  */
+ static inline bool skb_vlan_tagged(const struct sk_buff *skb)
+ {
+ 	if (!skb_vlan_tag_present(skb) &&
+ 	    likely(skb->protocol != htons(ETH_P_8021Q) &&
+ 		   skb->protocol != htons(ETH_P_8021AD)))
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ /**
+  * skb_vlan_tagged_multi - check if skb is vlan tagged with multiple headers.
+  * @skb: skbuff to query
+  *
+  * Returns true if the skb is tagged with multiple vlan headers, regardless
+  * of whether it is hardware accelerated or not.
+  */
+ static inline bool skb_vlan_tagged_multi(const struct sk_buff *skb)
+ {
+ 	__be16 protocol = skb->protocol;
+ 
+ 	if (!skb_vlan_tag_present(skb)) {
+ 		struct vlan_ethhdr *veh;
+ 
+ 		if (likely(protocol != htons(ETH_P_8021Q) &&
+ 			   protocol != htons(ETH_P_8021AD)))
+ 			return false;
+ 
+ 		veh = (struct vlan_ethhdr *)skb->data;
+ 		protocol = veh->h_vlan_encapsulated_proto;
+ 	}
+ 
+ 	if (protocol != htons(ETH_P_8021Q) && protocol != htons(ETH_P_8021AD))
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ /**
+  * vlan_features_check - drop unsafe features for skb with multiple tags.
+  * @skb: skbuff to query
+  * @features: features to be checked
+  *
+  * Returns features without unsafe ones if the skb has multiple tags.
+  */
+ static inline netdev_features_t vlan_features_check(const struct sk_buff *skb,
+ 						    netdev_features_t features)
+ {
+ 	if (skb_vlan_tagged_multi(skb))
+ 		features = netdev_intersect_features(features,
+ 						     NETIF_F_SG |
+ 						     NETIF_F_HIGHDMA |
+ 						     NETIF_F_FRAGLIST |
+ 						     NETIF_F_GEN_CSUM |
+ 						     NETIF_F_HW_VLAN_CTAG_TX |
+ 						     NETIF_F_HW_VLAN_STAG_TX);
+ 
+ 	return features;
+ }
+ 
++>>>>>>> 8cb65d00086b (net: Move check for multiple vlans to drivers)
  #endif /* !(_LINUX_IF_VLAN_H_) */
diff --cc net/core/dev.c
index 9a2bea4eeeee,cb46badbef5a..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -2458,37 -2562,40 +2458,58 @@@ static netdev_features_t harmonize_feat
  	return features;
  }
  
+ static netdev_features_t dflt_features_check(const struct sk_buff *skb,
+ 					     struct net_device *dev,
+ 					     netdev_features_t features)
+ {
+ 	return vlan_features_check(skb, features);
+ }
+ 
  netdev_features_t netif_skb_features(struct sk_buff *skb)
  {
 -	struct net_device *dev = skb->dev;
 -	netdev_features_t features = dev->features;
 -	u16 gso_segs = skb_shinfo(skb)->gso_segs;
 +	__be16 protocol = skb->protocol;
 +	netdev_features_t features = skb->dev->features;
  
 -	if (gso_segs > dev->gso_max_segs || gso_segs < dev->gso_min_segs)
 +	if (skb_shinfo(skb)->gso_segs > skb->dev->gso_max_segs)
  		features &= ~NETIF_F_GSO_MASK;
  
 -	/* If encapsulation offload request, verify we are testing
 -	 * hardware encapsulation features instead of standard
 -	 * features for the netdev
 -	 */
 -	if (skb->encapsulation)
 -		features &= dev->hw_enc_features;
 +	if (!vlan_tx_tag_present(skb)) {
 +		if (unlikely(protocol == htons(ETH_P_8021Q) ||
 +			     protocol == htons(ETH_P_8021AD))) {
 +			struct vlan_ethhdr *veh = (struct vlan_ethhdr *)skb->data;
 +			protocol = veh->h_vlan_encapsulated_proto;
 +		} else {
 +			return harmonize_features(skb, features);
 +		}
 +	}
 +
++<<<<<<< HEAD
 +	features = netdev_intersect_features(features,
 +					     skb->dev->vlan_features |
 +					     NETIF_F_HW_VLAN_CTAG_TX |
 +					     NETIF_F_HW_VLAN_STAG_TX);
  
 +	if (protocol == htons(ETH_P_8021Q) || protocol == htons(ETH_P_8021AD))
 +		features = netdev_intersect_features(features,
 +						     NETIF_F_SG |
 +						     NETIF_F_HIGHDMA |
 +						     NETIF_F_FRAGLIST |
 +						     NETIF_F_GEN_CSUM |
 +						     NETIF_F_HW_VLAN_CTAG_TX |
 +						     NETIF_F_HW_VLAN_STAG_TX);
++=======
+ 	if (skb_vlan_tagged(skb))
+ 		features = netdev_intersect_features(features,
+ 						     dev->vlan_features |
+ 						     NETIF_F_HW_VLAN_CTAG_TX |
+ 						     NETIF_F_HW_VLAN_STAG_TX);
+ 
+ 	if (dev->netdev_ops->ndo_features_check)
+ 		features &= dev->netdev_ops->ndo_features_check(skb, dev,
+ 								features);
+ 	else
+ 		features &= dflt_features_check(skb, dev, features);
++>>>>>>> 8cb65d00086b (net: Move check for multiple vlans to drivers)
  
  	return harmonize_features(skb, features);
  }
* Unmerged path drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx4/en_netdev.c
* Unmerged path drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
* Unmerged path include/linux/if_vlan.h
* Unmerged path net/core/dev.c
