mm/memory-failure: introduce get_hwpoison_page() for consistent refcount handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [mm] memory-failure: introduce get_hwpoison_page() for consistent refcount handling (Tomoaki Nishimura) [1226196]
Rebuild_FUZZ: 98.11%
commit-author Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
commit ead07f6a867b5b1b41cf703735e8b39094987a7d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/ead07f6a.failed

memory_failure() can run in 2 different mode (specified by
MF_COUNT_INCREASED) in page refcount perspective.  When
MF_COUNT_INCREASED is set, memory_failure() assumes that the caller
takes a refcount of the target page.  And if cleared, memory_failure()
takes it in it's own.

In current code, however, refcounting is done differently in each caller.
For example, madvise_hwpoison() uses get_user_pages_fast() and
hwpoison_inject() uses get_page_unless_zero().  So this inconsistent
refcounting causes refcount failure especially for thp tail pages.
Typical user visible effects are like memory leak or
VM_BUG_ON_PAGE(!page_count(page)) in isolate_lru_page().

To fix this refcounting issue, this patch introduces get_hwpoison_page()
to handle thp tail pages in the same manner for each caller of hwpoison
code.

memory_failure() might fail to split thp and in such case it returns
without completing page isolation.  This is not good because PageHWPoison
on the thp is still set and there's no easy way to unpoison such thps.  So
this patch try to roll back any action to the thp in "non anonymous thp"
case and "thp split failed" case, expecting an MCE(SRAR) generated by
later access afterward will properly free such thps.

[akpm@linux-foundation.org: fix CONFIG_HWPOISON_INJECT=m]
	Signed-off-by: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
	Cc: Andi Kleen <andi@firstfloor.org>
	Cc: Tony Luck <tony.luck@intel.com>
	Cc: "Kirill A. Shutemov" <kirill@shutemov.name>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit ead07f6a867b5b1b41cf703735e8b39094987a7d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memory-failure.c
diff --cc mm/memory-failure.c
index 96911c114194,a810ab1519f0..000000000000
--- a/mm/memory-failure.c
+++ b/mm/memory-failure.c
@@@ -1117,10 -1130,9 +1150,9 @@@ int memory_failure(unsigned long pfn, i
  	 * In fact it's dangerous to directly bump up page count from 0,
  	 * that may make page_freeze_refs()/page_unfreeze_refs() mismatch.
  	 */
- 	if (!(flags & MF_COUNT_INCREASED) &&
- 		!get_page_unless_zero(hpage)) {
+ 	if (!(flags & MF_COUNT_INCREASED) && !get_hwpoison_page(p)) {
  		if (is_free_buddy_page(p)) {
 -			action_result(pfn, MSG_BUDDY, DELAYED);
 +			action_result(pfn, "free buddy", DELAYED);
  			return 0;
  		} else if (PageHuge(hpage)) {
  			/*
@@@ -1147,6 -1159,29 +1179,32 @@@
  		}
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (!PageHuge(p) && PageTransHuge(hpage)) {
+ 		if (!PageAnon(hpage)) {
+ 			pr_err("MCE: %#lx: non anonymous thp\n", pfn);
+ 			if (TestClearPageHWPoison(p))
+ 				atomic_long_sub(nr_pages, &num_poisoned_pages);
+ 			put_page(p);
+ 			if (p != hpage)
+ 				put_page(hpage);
+ 			return -EBUSY;
+ 		}
+ 		if (unlikely(split_huge_page(hpage))) {
+ 			pr_err("MCE: %#lx: thp split failed\n", pfn);
+ 			if (TestClearPageHWPoison(p))
+ 				atomic_long_sub(nr_pages, &num_poisoned_pages);
+ 			put_page(p);
+ 			if (p != hpage)
+ 				put_page(hpage);
+ 			return -EBUSY;
+ 		}
+ 		VM_BUG_ON_PAGE(!page_count(p), p);
+ 		hpage = compound_head(p);
+ 	}
+ 
++>>>>>>> ead07f6a867b (mm/memory-failure: introduce get_hwpoison_page() for consistent refcount handling)
  	/*
  	 * We ignore non-LRU pages for good reasons.
  	 * - PG_locked is only well defined for LRU pages and a few others
diff --git a/include/linux/mm.h b/include/linux/mm.h
index 6ca7ff9955be..083ab251e713 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -2045,6 +2045,7 @@ enum mf_flags {
 extern int memory_failure(unsigned long pfn, int trapno, int flags);
 extern void memory_failure_queue(unsigned long pfn, int trapno, int flags);
 extern int unpoison_memory(unsigned long pfn);
+extern int get_hwpoison_page(struct page *page);
 extern int sysctl_memory_failure_early_kill;
 extern int sysctl_memory_failure_recovery;
 extern void shake_page(struct page *p, int access);
diff --git a/mm/hwpoison-inject.c b/mm/hwpoison-inject.c
index b1470040dae1..337cc4d7a739 100644
--- a/mm/hwpoison-inject.c
+++ b/mm/hwpoison-inject.c
@@ -28,7 +28,7 @@ static int hwpoison_inject(void *data, u64 val)
 	/*
 	 * This implies unable to support free buddy pages.
 	 */
-	if (!get_page_unless_zero(hpage))
+	if (!get_hwpoison_page(p))
 		return 0;
 
 	if (!hwpoison_filter_enable)
@@ -58,7 +58,7 @@ inject:
 	printk(KERN_INFO "Injecting memory failure at pfn %lx\n", pfn);
 	return memory_failure(pfn, 18, MF_COUNT_INCREASED);
 put_out:
-	put_page(hpage);
+	put_page(p);
 	return 0;
 }
 
* Unmerged path mm/memory-failure.c
