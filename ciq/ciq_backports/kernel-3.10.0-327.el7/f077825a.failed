KVM: x86: API changes for SMM support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [kvm] x86: API changes for SMM support (Paolo Bonzini) [1202825]
Rebuild_FUZZ: 92.75%
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit f077825a8758d79838a757dafb79adcdd047ef3a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/f077825a.failed

This patch includes changes to the external API for SMM support.
Userspace can predicate the availability of the new fields and
ioctls on a new capability, KVM_CAP_X86_SMM, which is added at the end
of the patch series.

	Reviewed-by: Radim Krčmář <rkrcmar@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit f077825a8758d79838a757dafb79adcdd047ef3a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/virtual/kvm/api.txt
#	arch/x86/kvm/lapic.h
#	include/uapi/linux/kvm.h
diff --cc Documentation/virtual/kvm/api.txt
index 63d448f87c08,2ddefd58b1aa..000000000000
--- a/Documentation/virtual/kvm/api.txt
+++ b/Documentation/virtual/kvm/api.txt
@@@ -2570,6 -2771,237 +2583,240 @@@ The fields in each entry are defined a
     eax, ebx, ecx, edx: the values returned by the cpuid instruction for
           this function/index combination
  
++<<<<<<< HEAD
++=======
+ 4.89 KVM_S390_MEM_OP
+ 
+ Capability: KVM_CAP_S390_MEM_OP
+ Architectures: s390
+ Type: vcpu ioctl
+ Parameters: struct kvm_s390_mem_op (in)
+ Returns: = 0 on success,
+          < 0 on generic error (e.g. -EFAULT or -ENOMEM),
+          > 0 if an exception occurred while walking the page tables
+ 
+ Read or write data from/to the logical (virtual) memory of a VPCU.
+ 
+ Parameters are specified via the following structure:
+ 
+ struct kvm_s390_mem_op {
+ 	__u64 gaddr;		/* the guest address */
+ 	__u64 flags;		/* flags */
+ 	__u32 size;		/* amount of bytes */
+ 	__u32 op;		/* type of operation */
+ 	__u64 buf;		/* buffer in userspace */
+ 	__u8 ar;		/* the access register number */
+ 	__u8 reserved[31];	/* should be set to 0 */
+ };
+ 
+ The type of operation is specified in the "op" field. It is either
+ KVM_S390_MEMOP_LOGICAL_READ for reading from logical memory space or
+ KVM_S390_MEMOP_LOGICAL_WRITE for writing to logical memory space. The
+ KVM_S390_MEMOP_F_CHECK_ONLY flag can be set in the "flags" field to check
+ whether the corresponding memory access would create an access exception
+ (without touching the data in the memory at the destination). In case an
+ access exception occurred while walking the MMU tables of the guest, the
+ ioctl returns a positive error number to indicate the type of exception.
+ This exception is also raised directly at the corresponding VCPU if the
+ flag KVM_S390_MEMOP_F_INJECT_EXCEPTION is set in the "flags" field.
+ 
+ The start address of the memory region has to be specified in the "gaddr"
+ field, and the length of the region in the "size" field. "buf" is the buffer
+ supplied by the userspace application where the read data should be written
+ to for KVM_S390_MEMOP_LOGICAL_READ, or where the data that should be written
+ is stored for a KVM_S390_MEMOP_LOGICAL_WRITE. "buf" is unused and can be NULL
+ when KVM_S390_MEMOP_F_CHECK_ONLY is specified. "ar" designates the access
+ register number to be used.
+ 
+ The "reserved" field is meant for future extensions. It is not used by
+ KVM with the currently defined set of flags.
+ 
+ 4.90 KVM_S390_GET_SKEYS
+ 
+ Capability: KVM_CAP_S390_SKEYS
+ Architectures: s390
+ Type: vm ioctl
+ Parameters: struct kvm_s390_skeys
+ Returns: 0 on success, KVM_S390_GET_KEYS_NONE if guest is not using storage
+          keys, negative value on error
+ 
+ This ioctl is used to get guest storage key values on the s390
+ architecture. The ioctl takes parameters via the kvm_s390_skeys struct.
+ 
+ struct kvm_s390_skeys {
+ 	__u64 start_gfn;
+ 	__u64 count;
+ 	__u64 skeydata_addr;
+ 	__u32 flags;
+ 	__u32 reserved[9];
+ };
+ 
+ The start_gfn field is the number of the first guest frame whose storage keys
+ you want to get.
+ 
+ The count field is the number of consecutive frames (starting from start_gfn)
+ whose storage keys to get. The count field must be at least 1 and the maximum
+ allowed value is defined as KVM_S390_SKEYS_ALLOC_MAX. Values outside this range
+ will cause the ioctl to return -EINVAL.
+ 
+ The skeydata_addr field is the address to a buffer large enough to hold count
+ bytes. This buffer will be filled with storage key data by the ioctl.
+ 
+ 4.91 KVM_S390_SET_SKEYS
+ 
+ Capability: KVM_CAP_S390_SKEYS
+ Architectures: s390
+ Type: vm ioctl
+ Parameters: struct kvm_s390_skeys
+ Returns: 0 on success, negative value on error
+ 
+ This ioctl is used to set guest storage key values on the s390
+ architecture. The ioctl takes parameters via the kvm_s390_skeys struct.
+ See section on KVM_S390_GET_SKEYS for struct definition.
+ 
+ The start_gfn field is the number of the first guest frame whose storage keys
+ you want to set.
+ 
+ The count field is the number of consecutive frames (starting from start_gfn)
+ whose storage keys to get. The count field must be at least 1 and the maximum
+ allowed value is defined as KVM_S390_SKEYS_ALLOC_MAX. Values outside this range
+ will cause the ioctl to return -EINVAL.
+ 
+ The skeydata_addr field is the address to a buffer containing count bytes of
+ storage keys. Each byte in the buffer will be set as the storage key for a
+ single frame starting at start_gfn for count frames.
+ 
+ Note: If any architecturally invalid key value is found in the given data then
+ the ioctl will return -EINVAL.
+ 
+ 4.92 KVM_S390_IRQ
+ 
+ Capability: KVM_CAP_S390_INJECT_IRQ
+ Architectures: s390
+ Type: vcpu ioctl
+ Parameters: struct kvm_s390_irq (in)
+ Returns: 0 on success, -1 on error
+ Errors:
+   EINVAL: interrupt type is invalid
+           type is KVM_S390_SIGP_STOP and flag parameter is invalid value
+           type is KVM_S390_INT_EXTERNAL_CALL and code is bigger
+             than the maximum of VCPUs
+   EBUSY:  type is KVM_S390_SIGP_SET_PREFIX and vcpu is not stopped
+           type is KVM_S390_SIGP_STOP and a stop irq is already pending
+           type is KVM_S390_INT_EXTERNAL_CALL and an external call interrupt
+             is already pending
+ 
+ Allows to inject an interrupt to the guest.
+ 
+ Using struct kvm_s390_irq as a parameter allows
+ to inject additional payload which is not
+ possible via KVM_S390_INTERRUPT.
+ 
+ Interrupt parameters are passed via kvm_s390_irq:
+ 
+ struct kvm_s390_irq {
+ 	__u64 type;
+ 	union {
+ 		struct kvm_s390_io_info io;
+ 		struct kvm_s390_ext_info ext;
+ 		struct kvm_s390_pgm_info pgm;
+ 		struct kvm_s390_emerg_info emerg;
+ 		struct kvm_s390_extcall_info extcall;
+ 		struct kvm_s390_prefix_info prefix;
+ 		struct kvm_s390_stop_info stop;
+ 		struct kvm_s390_mchk_info mchk;
+ 		char reserved[64];
+ 	} u;
+ };
+ 
+ type can be one of the following:
+ 
+ KVM_S390_SIGP_STOP - sigp stop; parameter in .stop
+ KVM_S390_PROGRAM_INT - program check; parameters in .pgm
+ KVM_S390_SIGP_SET_PREFIX - sigp set prefix; parameters in .prefix
+ KVM_S390_RESTART - restart; no parameters
+ KVM_S390_INT_CLOCK_COMP - clock comparator interrupt; no parameters
+ KVM_S390_INT_CPU_TIMER - CPU timer interrupt; no parameters
+ KVM_S390_INT_EMERGENCY - sigp emergency; parameters in .emerg
+ KVM_S390_INT_EXTERNAL_CALL - sigp external call; parameters in .extcall
+ KVM_S390_MCHK - machine check interrupt; parameters in .mchk
+ 
+ 
+ Note that the vcpu ioctl is asynchronous to vcpu execution.
+ 
+ 4.94 KVM_S390_GET_IRQ_STATE
+ 
+ Capability: KVM_CAP_S390_IRQ_STATE
+ Architectures: s390
+ Type: vcpu ioctl
+ Parameters: struct kvm_s390_irq_state (out)
+ Returns: >= number of bytes copied into buffer,
+          -EINVAL if buffer size is 0,
+          -ENOBUFS if buffer size is too small to fit all pending interrupts,
+          -EFAULT if the buffer address was invalid
+ 
+ This ioctl allows userspace to retrieve the complete state of all currently
+ pending interrupts in a single buffer. Use cases include migration
+ and introspection. The parameter structure contains the address of a
+ userspace buffer and its length:
+ 
+ struct kvm_s390_irq_state {
+ 	__u64 buf;
+ 	__u32 flags;
+ 	__u32 len;
+ 	__u32 reserved[4];
+ };
+ 
+ Userspace passes in the above struct and for each pending interrupt a
+ struct kvm_s390_irq is copied to the provided buffer.
+ 
+ If -ENOBUFS is returned the buffer provided was too small and userspace
+ may retry with a bigger buffer.
+ 
+ 4.95 KVM_S390_SET_IRQ_STATE
+ 
+ Capability: KVM_CAP_S390_IRQ_STATE
+ Architectures: s390
+ Type: vcpu ioctl
+ Parameters: struct kvm_s390_irq_state (in)
+ Returns: 0 on success,
+          -EFAULT if the buffer address was invalid,
+          -EINVAL for an invalid buffer length (see below),
+          -EBUSY if there were already interrupts pending,
+          errors occurring when actually injecting the
+           interrupt. See KVM_S390_IRQ.
+ 
+ This ioctl allows userspace to set the complete state of all cpu-local
+ interrupts currently pending for the vcpu. It is intended for restoring
+ interrupt state after a migration. The input parameter is a userspace buffer
+ containing a struct kvm_s390_irq_state:
+ 
+ struct kvm_s390_irq_state {
+ 	__u64 buf;
+ 	__u32 len;
+ 	__u32 pad;
+ };
+ 
+ The userspace memory referenced by buf contains a struct kvm_s390_irq
+ for each interrupt to be injected into the guest.
+ If one of the interrupts could not be injected for some reason the
+ ioctl aborts.
+ 
+ len must be a multiple of sizeof(struct kvm_s390_irq). It must be > 0
+ and it must not exceed (max_vcpus + 32) * sizeof(struct kvm_s390_irq),
+ which is the maximum number of possibly pending cpu-local interrupts.
+ 
+ 4.90 KVM_SMI
+ 
+ Capability: KVM_CAP_X86_SMM
+ Architectures: x86
+ Type: vcpu ioctl
+ Parameters: none
+ Returns: 0 on success, -1 on error
+ 
+ Queues an SMI on the thread's vcpu.
+ 
++>>>>>>> f077825a8758 (KVM: x86: API changes for SMM support)
  5. The kvm_run structure
  ------------------------
  
diff --cc arch/x86/kvm/lapic.h
index d3d6e92764fd,f2f4e10ab772..000000000000
--- a/arch/x86/kvm/lapic.h
+++ b/arch/x86/kvm/lapic.h
@@@ -168,6 -153,19 +168,20 @@@ static inline bool kvm_apic_has_events(
  	return kvm_vcpu_has_lapic(vcpu) && vcpu->arch.apic->pending_events;
  }
  
++<<<<<<< HEAD
++=======
+ static inline bool kvm_lowest_prio_delivery(struct kvm_lapic_irq *irq)
+ {
+ 	return (irq->delivery_mode == APIC_DM_LOWEST ||
+ 			irq->msi_redir_hint);
+ }
+ 
+ static inline int kvm_lapic_latched_init(struct kvm_vcpu *vcpu)
+ {
+ 	return kvm_vcpu_has_lapic(vcpu) && test_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);
+ }
+ 
++>>>>>>> f077825a8758 (KVM: x86: API changes for SMM support)
  bool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector);
  
 -void wait_lapic_expire(struct kvm_vcpu *vcpu);
 -
  #endif
diff --cc include/uapi/linux/kvm.h
index 7d851dae2791,eace8babd227..000000000000
--- a/include/uapi/linux/kvm.h
+++ b/include/uapi/linux/kvm.h
@@@ -665,9 -797,25 +665,25 @@@ struct kvm_ppc_smmu_info 
  #define KVM_CAP_HYPERV_TIME 96
  #define KVM_CAP_IOAPIC_POLARITY_IGNORED 97
  #define KVM_CAP_ENABLE_CAP_VM 98
 -#define KVM_CAP_S390_IRQCHIP 99
  #define KVM_CAP_IOEVENTFD_NO_LENGTH 100
 -#define KVM_CAP_VM_ATTRIBUTES 101
 -#define KVM_CAP_ARM_PSCI_0_2 102
  #define KVM_CAP_PPC_FIXUP_HCALL 103
  #define KVM_CAP_PPC_ENABLE_HCALL 104
++<<<<<<< HEAD
++=======
+ #define KVM_CAP_CHECK_EXTENSION_VM 105
+ #define KVM_CAP_S390_USER_SIGP 106
+ #define KVM_CAP_S390_VECTOR_REGISTERS 107
+ #define KVM_CAP_S390_MEM_OP 108
+ #define KVM_CAP_S390_USER_STSI 109
+ #define KVM_CAP_S390_SKEYS 110
+ #define KVM_CAP_MIPS_FPU 111
+ #define KVM_CAP_MIPS_MSA 112
+ #define KVM_CAP_S390_INJECT_IRQ 113
+ #define KVM_CAP_S390_IRQ_STATE 114
+ #define KVM_CAP_PPC_HWRNG 115
+ #define KVM_CAP_DISABLE_QUIRKS 116
+ #define KVM_CAP_X86_SMM 117
++>>>>>>> f077825a8758 (KVM: x86: API changes for SMM support)
  
  #ifdef KVM_CAP_IRQ_ROUTING
  
@@@ -1016,7 -1189,20 +1032,22 @@@ struct kvm_s390_ucas_mapping 
  /* VM is being stopped by host */
  #define KVM_KVMCLOCK_CTRL	  _IO(KVMIO,   0xad)
  #define KVM_ARM_VCPU_INIT	  _IOW(KVMIO,  0xae, struct kvm_vcpu_init)
 -#define KVM_ARM_PREFERRED_TARGET  _IOR(KVMIO,  0xaf, struct kvm_vcpu_init)
  #define KVM_GET_REG_LIST	  _IOWR(KVMIO, 0xb0, struct kvm_reg_list)
++<<<<<<< HEAD
++=======
+ /* Available with KVM_CAP_S390_MEM_OP */
+ #define KVM_S390_MEM_OP		  _IOW(KVMIO,  0xb1, struct kvm_s390_mem_op)
+ /* Available with KVM_CAP_S390_SKEYS */
+ #define KVM_S390_GET_SKEYS      _IOW(KVMIO, 0xb2, struct kvm_s390_skeys)
+ #define KVM_S390_SET_SKEYS      _IOW(KVMIO, 0xb3, struct kvm_s390_skeys)
+ /* Available with KVM_CAP_S390_INJECT_IRQ */
+ #define KVM_S390_IRQ              _IOW(KVMIO,  0xb4, struct kvm_s390_irq)
+ /* Available with KVM_CAP_S390_IRQ_STATE */
+ #define KVM_S390_SET_IRQ_STATE	  _IOW(KVMIO, 0xb5, struct kvm_s390_irq_state)
+ #define KVM_S390_GET_IRQ_STATE	  _IOW(KVMIO, 0xb6, struct kvm_s390_irq_state)
+ /* Available with KVM_CAP_X86_SMM */
+ #define KVM_SMI                   _IO(KVMIO,   0xb7)
++>>>>>>> f077825a8758 (KVM: x86: API changes for SMM support)
  
  #define KVM_DEV_ASSIGN_ENABLE_IOMMU	(1 << 0)
  #define KVM_DEV_ASSIGN_PCI_2_3		(1 << 1)
* Unmerged path Documentation/virtual/kvm/api.txt
diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 1442e6fbe132..d421f9d785cb 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -465,6 +465,7 @@ struct kvm_vcpu_arch {
 	atomic_t nmi_queued;  /* unprocessed asynchronous NMIs */
 	unsigned nmi_pending; /* NMI queued after currently running handler */
 	bool nmi_injected;    /* Trying to inject an NMI this entry */
+	bool smi_pending;    /* SMI queued after currently running handler */
 
 	struct mtrr_state_type mtrr_state;
 	u64 pat;
@@ -1059,6 +1060,8 @@ enum {
 #define HF_NMI_MASK		(1 << 3)
 #define HF_IRET_MASK		(1 << 4)
 #define HF_GUEST_MASK		(1 << 5) /* VCPU is in guest-mode */
+#define HF_SMM_MASK		(1 << 6)
+#define HF_SMM_INSIDE_NMI_MASK	(1 << 7)
 
 /*
  * Hardware virtualization extension instructions may fault if a
diff --git a/arch/x86/include/uapi/asm/kvm.h b/arch/x86/include/uapi/asm/kvm.h
index d3a87780c70b..bb8cb06bd10d 100644
--- a/arch/x86/include/uapi/asm/kvm.h
+++ b/arch/x86/include/uapi/asm/kvm.h
@@ -103,6 +103,8 @@ struct kvm_ioapic_state {
 #define KVM_IRQCHIP_IOAPIC       2
 #define KVM_NR_IRQCHIPS          3
 
+#define KVM_RUN_X86_SMM		 (1 << 0)
+
 /* for KVM_GET_REGS and KVM_SET_REGS */
 struct kvm_regs {
 	/* out (KVM_GET_REGS) / in (KVM_SET_REGS) */
@@ -278,6 +280,7 @@ struct kvm_reinject_control {
 #define KVM_VCPUEVENT_VALID_NMI_PENDING	0x00000001
 #define KVM_VCPUEVENT_VALID_SIPI_VECTOR	0x00000002
 #define KVM_VCPUEVENT_VALID_SHADOW	0x00000004
+#define KVM_VCPUEVENT_VALID_SMM		0x00000008
 
 /* Interrupt shadow states */
 #define KVM_X86_SHADOW_INT_MOV_SS	0x01
@@ -306,7 +309,13 @@ struct kvm_vcpu_events {
 	} nmi;
 	__u32 sipi_vector;
 	__u32 flags;
-	__u32 reserved[10];
+	struct {
+		__u8 smm;
+		__u8 pending;
+		__u8 smm_inside_nmi;
+		__u8 latched_init;
+	} smi;
+	__u32 reserved[9];
 };
 
 /* for KVM_GET/SET_DEBUGREGS */
diff --git a/arch/x86/kvm/kvm_cache_regs.h b/arch/x86/kvm/kvm_cache_regs.h
index 544076c4f44b..e1e89ee4af75 100644
--- a/arch/x86/kvm/kvm_cache_regs.h
+++ b/arch/x86/kvm/kvm_cache_regs.h
@@ -99,4 +99,9 @@ static inline bool is_guest_mode(struct kvm_vcpu *vcpu)
 	return vcpu->arch.hflags & HF_GUEST_MASK;
 }
 
+static inline bool is_smm(struct kvm_vcpu *vcpu)
+{
+	return vcpu->arch.hflags & HF_SMM_MASK;
+}
+
 #endif
* Unmerged path arch/x86/kvm/lapic.h
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 44ac86d26f9f..29d9b7efcbf0 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -3003,6 +3003,11 @@ static int kvm_vcpu_ioctl_nmi(struct kvm_vcpu *vcpu)
 	return 0;
 }
 
+static int kvm_vcpu_ioctl_smi(struct kvm_vcpu *vcpu)
+{
+	return 0;
+}
+
 static int vcpu_ioctl_tpr_access_reporting(struct kvm_vcpu *vcpu,
 					   struct kvm_tpr_access_ctl *tac)
 {
@@ -3108,8 +3113,15 @@ static void kvm_vcpu_ioctl_x86_get_vcpu_events(struct kvm_vcpu *vcpu,
 
 	events->sipi_vector = 0; /* never valid when reporting to user space */
 
+	events->smi.smm = is_smm(vcpu);
+	events->smi.pending = vcpu->arch.smi_pending;
+	events->smi.smm_inside_nmi =
+		!!(vcpu->arch.hflags & HF_SMM_INSIDE_NMI_MASK);
+	events->smi.latched_init = kvm_lapic_latched_init(vcpu);
+
 	events->flags = (KVM_VCPUEVENT_VALID_NMI_PENDING
-			 | KVM_VCPUEVENT_VALID_SHADOW);
+			 | KVM_VCPUEVENT_VALID_SHADOW
+			 | KVM_VCPUEVENT_VALID_SMM);
 	memset(&events->reserved, 0, sizeof(events->reserved));
 }
 
@@ -3118,7 +3130,8 @@ static int kvm_vcpu_ioctl_x86_set_vcpu_events(struct kvm_vcpu *vcpu,
 {
 	if (events->flags & ~(KVM_VCPUEVENT_VALID_NMI_PENDING
 			      | KVM_VCPUEVENT_VALID_SIPI_VECTOR
-			      | KVM_VCPUEVENT_VALID_SHADOW))
+			      | KVM_VCPUEVENT_VALID_SHADOW
+			      | KVM_VCPUEVENT_VALID_SMM))
 		return -EINVAL;
 
 	process_nmi(vcpu);
@@ -3143,6 +3156,24 @@ static int kvm_vcpu_ioctl_x86_set_vcpu_events(struct kvm_vcpu *vcpu,
 	    kvm_vcpu_has_lapic(vcpu))
 		vcpu->arch.apic->sipi_vector = events->sipi_vector;
 
+	if (events->flags & KVM_VCPUEVENT_VALID_SMM) {
+		if (events->smi.smm)
+			vcpu->arch.hflags |= HF_SMM_MASK;
+		else
+			vcpu->arch.hflags &= ~HF_SMM_MASK;
+		vcpu->arch.smi_pending = events->smi.pending;
+		if (events->smi.smm_inside_nmi)
+			vcpu->arch.hflags |= HF_SMM_INSIDE_NMI_MASK;
+		else
+			vcpu->arch.hflags &= ~HF_SMM_INSIDE_NMI_MASK;
+		if (kvm_vcpu_has_lapic(vcpu)) {
+			if (events->smi.latched_init)
+				set_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);
+			else
+				clear_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);
+		}
+	}
+
 	kvm_make_request(KVM_REQ_EVENT, vcpu);
 
 	return 0;
@@ -3328,6 +3359,10 @@ long kvm_arch_vcpu_ioctl(struct file *filp,
 		r = kvm_vcpu_ioctl_nmi(vcpu);
 		break;
 	}
+	case KVM_SMI: {
+		r = kvm_vcpu_ioctl_smi(vcpu);
+		break;
+	}
 	case KVM_SET_CPUID: {
 		struct kvm_cpuid __user *cpuid_arg = argp;
 		struct kvm_cpuid cpuid;
@@ -5943,6 +5978,7 @@ static void post_kvm_run_save(struct kvm_vcpu *vcpu)
 	struct kvm_run *kvm_run = vcpu->run;
 
 	kvm_run->if_flag = (kvm_get_rflags(vcpu) & X86_EFLAGS_IF) != 0;
+	kvm_run->flags = is_smm(vcpu) ? KVM_RUN_X86_SMM : 0;
 	kvm_run->cr8 = kvm_get_cr8(vcpu);
 	kvm_run->apic_base = kvm_get_apic_base(vcpu);
 	if (irqchip_in_kernel(vcpu->kvm))
* Unmerged path include/uapi/linux/kvm.h
