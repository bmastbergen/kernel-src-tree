cifs: switch to ->write_iter()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 3dae8750c368f8ac11c3c8c2a28f56dcee865c01
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/3dae8750.failed

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 3dae8750c368f8ac11c3c8c2a28f56dcee865c01)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/cifsfs.c
#	fs/cifs/cifsfs.h
#	fs/cifs/file.c
diff --cc fs/cifs/cifsfs.c
index 35309d1d74d2,496b520934e0..000000000000
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@@ -888,10 -887,10 +887,17 @@@ const struct inode_operations cifs_syml
  };
  
  const struct file_operations cifs_file_ops = {
++<<<<<<< HEAD
 +	.read = do_sync_read,
 +	.write = do_sync_write,
 +	.aio_read = generic_file_aio_read,
 +	.aio_write = cifs_file_aio_write,
++=======
+ 	.read = new_sync_read,
+ 	.write = new_sync_write,
+ 	.read_iter = generic_file_read_iter,
+ 	.write_iter = cifs_file_write_iter,
++>>>>>>> 3dae8750c368 (cifs: switch to ->write_iter())
  	.open = cifs_open,
  	.release = cifs_close,
  	.lock = cifs_lock,
@@@ -907,10 -906,10 +913,17 @@@
  };
  
  const struct file_operations cifs_file_strict_ops = {
++<<<<<<< HEAD
 +	.read = do_sync_read,
 +	.write = do_sync_write,
 +	.aio_read = cifs_strict_readv,
 +	.aio_write = cifs_strict_writev,
++=======
+ 	.read = new_sync_read,
+ 	.write = new_sync_write,
+ 	.read_iter = cifs_strict_readv,
+ 	.write_iter = cifs_strict_writev,
++>>>>>>> 3dae8750c368 (cifs: switch to ->write_iter())
  	.open = cifs_open,
  	.release = cifs_close,
  	.lock = cifs_lock,
@@@ -927,10 -926,10 +940,17 @@@
  
  const struct file_operations cifs_file_direct_ops = {
  	/* BB reevaluate whether they can be done with directio, no cache */
++<<<<<<< HEAD
 +	.read = do_sync_read,
 +	.write = do_sync_write,
 +	.aio_read = cifs_user_readv,
 +	.aio_write = cifs_user_writev,
++=======
+ 	.read = new_sync_read,
+ 	.write = new_sync_write,
+ 	.read_iter = cifs_user_readv,
+ 	.write_iter = cifs_user_writev,
++>>>>>>> 3dae8750c368 (cifs: switch to ->write_iter())
  	.open = cifs_open,
  	.release = cifs_close,
  	.lock = cifs_lock,
@@@ -946,10 -945,10 +966,17 @@@
  };
  
  const struct file_operations cifs_file_nobrl_ops = {
++<<<<<<< HEAD
 +	.read = do_sync_read,
 +	.write = do_sync_write,
 +	.aio_read = generic_file_aio_read,
 +	.aio_write = cifs_file_aio_write,
++=======
+ 	.read = new_sync_read,
+ 	.write = new_sync_write,
+ 	.read_iter = generic_file_read_iter,
+ 	.write_iter = cifs_file_write_iter,
++>>>>>>> 3dae8750c368 (cifs: switch to ->write_iter())
  	.open = cifs_open,
  	.release = cifs_close,
  	.fsync = cifs_fsync,
@@@ -964,10 -963,10 +991,17 @@@
  };
  
  const struct file_operations cifs_file_strict_nobrl_ops = {
++<<<<<<< HEAD
 +	.read = do_sync_read,
 +	.write = do_sync_write,
 +	.aio_read = cifs_strict_readv,
 +	.aio_write = cifs_strict_writev,
++=======
+ 	.read = new_sync_read,
+ 	.write = new_sync_write,
+ 	.read_iter = cifs_strict_readv,
+ 	.write_iter = cifs_strict_writev,
++>>>>>>> 3dae8750c368 (cifs: switch to ->write_iter())
  	.open = cifs_open,
  	.release = cifs_close,
  	.fsync = cifs_strict_fsync,
@@@ -983,10 -982,10 +1017,17 @@@
  
  const struct file_operations cifs_file_direct_nobrl_ops = {
  	/* BB reevaluate whether they can be done with directio, no cache */
++<<<<<<< HEAD
 +	.read = do_sync_read,
 +	.write = do_sync_write,
 +	.aio_read = cifs_user_readv,
 +	.aio_write = cifs_user_writev,
++=======
+ 	.read = new_sync_read,
+ 	.write = new_sync_write,
+ 	.read_iter = cifs_user_readv,
+ 	.write_iter = cifs_user_writev,
++>>>>>>> 3dae8750c368 (cifs: switch to ->write_iter())
  	.open = cifs_open,
  	.release = cifs_close,
  	.fsync = cifs_fsync,
diff --cc fs/cifs/cifsfs.h
index e9c35e2ef148,c9e91886f0cf..000000000000
--- a/fs/cifs/cifsfs.h
+++ b/fs/cifs/cifsfs.h
@@@ -95,14 -85,10 +95,21 @@@ extern const struct file_operations cif
  extern int cifs_open(struct inode *inode, struct file *file);
  extern int cifs_close(struct inode *inode, struct file *file);
  extern int cifs_closedir(struct inode *inode, struct file *file);
++<<<<<<< HEAD
 +extern ssize_t cifs_user_readv(struct kiocb *iocb, const struct iovec *iov,
 +			       unsigned long nr_segs, loff_t pos);
 +extern ssize_t cifs_strict_readv(struct kiocb *iocb, const struct iovec *iov,
 +				 unsigned long nr_segs, loff_t pos);
 +extern ssize_t cifs_user_writev(struct kiocb *iocb, const struct iovec *iov,
 +				unsigned long nr_segs, loff_t pos);
 +extern ssize_t cifs_strict_writev(struct kiocb *iocb, const struct iovec *iov,
 +				  unsigned long nr_segs, loff_t pos);
++=======
+ extern ssize_t cifs_user_readv(struct kiocb *iocb, struct iov_iter *to);
+ extern ssize_t cifs_strict_readv(struct kiocb *iocb, struct iov_iter *to);
+ extern ssize_t cifs_user_writev(struct kiocb *iocb, struct iov_iter *from);
+ extern ssize_t cifs_strict_writev(struct kiocb *iocb, struct iov_iter *from);
++>>>>>>> 3dae8750c368 (cifs: switch to ->write_iter())
  extern int cifs_lock(struct file *, int, struct file_lock *);
  extern int cifs_fsync(struct file *, loff_t, loff_t, int);
  extern int cifs_strict_fsync(struct file *, loff_t, loff_t, int);
diff --cc fs/cifs/file.c
index 0a9decae6d5c,60e9b5fa2212..000000000000
--- a/fs/cifs/file.c
+++ b/fs/cifs/file.c
@@@ -2428,7 -2424,6 +2428,10 @@@ cifs_iovec_write(struct file *file, str
  	else
  		pid = current->tgid;
  
++<<<<<<< HEAD
 +	iov_iter_init(&it, iov, nr_segs, len, 0);
++=======
++>>>>>>> 3dae8750c368 (cifs: switch to ->write_iter())
  	do {
  		size_t save_len;
  
@@@ -2448,11 -2443,10 +2451,17 @@@
  
  		save_len = cur_len;
  		for (i = 0; i < nr_pages; i++) {
++<<<<<<< HEAD
 +			bytes = min_t(const size_t, cur_len, PAGE_SIZE);
 +			copied = iov_iter_copy_from_user(wdata->pages[i], &it,
 +							 0, bytes);
++=======
+ 			bytes = min_t(size_t, cur_len, PAGE_SIZE);
+ 			copied = copy_page_from_iter(wdata->pages[i], 0, bytes,
+ 						     from);
++>>>>>>> 3dae8750c368 (cifs: switch to ->write_iter())
  			cur_len -= copied;
 +			iov_iter_advance(&it, copied);
  			/*
  			 * If we didn't copy as much as we expected, then that
  			 * may mean we trod into an unmapped area. Stop copying
@@@ -2564,9 -2558,9 +2573,9 @@@ ssize_t cifs_user_writev(struct kiocb *
  	 * write request.
  	 */
  
- 	written = cifs_iovec_write(iocb->ki_filp, iov, nr_segs, &pos);
+ 	written = cifs_iovec_write(iocb->ki_filp, from, &pos);
  	if (written > 0) {
 -		CIFS_I(inode)->invalid_mapping = true;
 +		set_bit(CIFS_INO_INVALID_MAPPING, &CIFS_I(inode)->flags);
  		iocb->ki_pos = pos;
  	}
  
@@@ -2593,11 -2586,10 +2601,15 @@@ cifs_writev(struct kiocb *iocb, struct 
  	mutex_lock(&inode->i_mutex);
  	if (file->f_flags & O_APPEND)
  		lock_pos = i_size_read(inode);
- 	if (!cifs_find_lock_conflict(cfile, lock_pos, iov_length(iov, nr_segs),
+ 	if (!cifs_find_lock_conflict(cfile, lock_pos, iov_iter_count(from),
  				     server->vals->exclusive_lock_type, NULL,
  				     CIFS_WRITE_OP)) {
++<<<<<<< HEAD
 +		rc = __generic_file_aio_write(iocb, iov, nr_segs,
 +						&iocb->ki_pos);
++=======
+ 		rc = __generic_file_write_iter(iocb, from);
++>>>>>>> 3dae8750c368 (cifs: switch to ->write_iter())
  		mutex_unlock(&inode->i_mutex);
  
  		if (rc > 0) {
* Unmerged path fs/cifs/cifsfs.c
* Unmerged path fs/cifs/cifsfs.h
* Unmerged path fs/cifs/file.c
