net: Remove gso_send_check as an offload callback

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] Remove gso_send_check as an offload callback (Marcelo Leitner) [1206570]
Rebuild_FUZZ: 94.62%
commit-author Tom Herbert <therbert@google.com>
commit 53e50398968d43338c4d932114e68bc099fc5fbd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/53e50398.failed

The send_check logic was only interesting in cases of TCP offload and
UDP UFO where the checksum needed to be initialized to the pseudo
header checksum. Now we've moved that logic into the related
gso_segment functions so gso_send_check is no longer needed.

	Signed-off-by: Tom Herbert <therbert@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 53e50398968d43338c4d932114e68bc099fc5fbd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_offload.c
#	net/ipv4/udp_offload.c
#	net/ipv6/tcpv6_offload.c
diff --cc net/ipv4/tcp_offload.c
index 7cdeac54cee6,5b90f2f447a5..000000000000
--- a/net/ipv4/tcp_offload.c
+++ b/net/ipv4/tcp_offload.c
@@@ -251,23 -288,6 +251,26 @@@ int tcp_gro_complete(struct sk_buff *sk
  }
  EXPORT_SYMBOL(tcp_gro_complete);
  
++<<<<<<< HEAD
 +static int tcp_v4_gso_send_check(struct sk_buff *skb)
 +{
 +	const struct iphdr *iph;
 +	struct tcphdr *th;
 +
 +	if (!pskb_may_pull(skb, sizeof(*th)))
 +		return -EINVAL;
 +
 +	iph = ip_hdr(skb);
 +	th = tcp_hdr(skb);
 +
 +	th->check = 0;
 +	skb->ip_summed = CHECKSUM_PARTIAL;
 +	__tcp_v4_send_check(skb, iph->saddr, iph->daddr);
 +	return 0;
 +}
 +
++=======
++>>>>>>> 53e50398968d (net: Remove gso_send_check as an offload callback)
  static struct sk_buff **tcp4_gro_receive(struct sk_buff **head, struct sk_buff *skb)
  {
  	/* Don't bother verifying checksum if we're going to flush anyway. */
@@@ -295,8 -315,7 +298,12 @@@ static int tcp4_gro_complete(struct sk_
  
  static const struct net_offload tcpv4_offload = {
  	.callbacks = {
++<<<<<<< HEAD
 +		.gso_send_check	=	tcp_v4_gso_send_check,
 +		.gso_segment	=	tcp_gso_segment,
++=======
+ 		.gso_segment	=	tcp4_gso_segment,
++>>>>>>> 53e50398968d (net: Remove gso_send_check as an offload callback)
  		.gro_receive	=	tcp4_gro_receive,
  		.gro_complete	=	tcp4_gro_complete,
  	},
diff --cc net/ipv4/udp_offload.c
index cc9bad87f4e1,19ebe6a39ddc..000000000000
--- a/net/ipv4/udp_offload.c
+++ b/net/ipv4/udp_offload.c
@@@ -25,9 -25,80 +25,86 @@@ struct udp_offload_priv 
  	struct udp_offload_priv __rcu *next;
  };
  
++<<<<<<< HEAD
 +static int udp4_ufo_send_check(struct sk_buff *skb)
 +{
 +	return 0;
++=======
+ struct sk_buff *skb_udp_tunnel_segment(struct sk_buff *skb,
+ 				       netdev_features_t features)
+ {
+ 	struct sk_buff *segs = ERR_PTR(-EINVAL);
+ 	u16 mac_offset = skb->mac_header;
+ 	int mac_len = skb->mac_len;
+ 	int tnl_hlen = skb_inner_mac_header(skb) - skb_transport_header(skb);
+ 	__be16 protocol = skb->protocol;
+ 	netdev_features_t enc_features;
+ 	int udp_offset, outer_hlen;
+ 	unsigned int oldlen;
+ 	bool need_csum;
+ 
+ 	oldlen = (u16)~skb->len;
+ 
+ 	if (unlikely(!pskb_may_pull(skb, tnl_hlen)))
+ 		goto out;
+ 
+ 	skb->encapsulation = 0;
+ 	__skb_pull(skb, tnl_hlen);
+ 	skb_reset_mac_header(skb);
+ 	skb_set_network_header(skb, skb_inner_network_offset(skb));
+ 	skb->mac_len = skb_inner_network_offset(skb);
+ 	skb->protocol = htons(ETH_P_TEB);
+ 
+ 	need_csum = !!(skb_shinfo(skb)->gso_type & SKB_GSO_UDP_TUNNEL_CSUM);
+ 	if (need_csum)
+ 		skb->encap_hdr_csum = 1;
+ 
+ 	/* segment inner packet. */
+ 	enc_features = skb->dev->hw_enc_features & netif_skb_features(skb);
+ 	segs = skb_mac_gso_segment(skb, enc_features);
+ 	if (IS_ERR_OR_NULL(segs)) {
+ 		skb_gso_error_unwind(skb, protocol, tnl_hlen, mac_offset,
+ 				     mac_len);
+ 		goto out;
+ 	}
+ 
+ 	outer_hlen = skb_tnl_header_len(skb);
+ 	udp_offset = outer_hlen - tnl_hlen;
+ 	skb = segs;
+ 	do {
+ 		struct udphdr *uh;
+ 		int len;
+ 
+ 		skb_reset_inner_headers(skb);
+ 		skb->encapsulation = 1;
+ 
+ 		skb->mac_len = mac_len;
+ 
+ 		skb_push(skb, outer_hlen);
+ 		skb_reset_mac_header(skb);
+ 		skb_set_network_header(skb, mac_len);
+ 		skb_set_transport_header(skb, udp_offset);
+ 		len = skb->len - udp_offset;
+ 		uh = udp_hdr(skb);
+ 		uh->len = htons(len);
+ 
+ 		if (need_csum) {
+ 			__be32 delta = htonl(oldlen + len);
+ 
+ 			uh->check = ~csum_fold((__force __wsum)
+ 					       ((__force u32)uh->check +
+ 						(__force u32)delta));
+ 			uh->check = gso_make_checksum(skb, ~uh->check);
+ 
+ 			if (uh->check == 0)
+ 				uh->check = CSUM_MANGLED_0;
+ 		}
+ 
+ 		skb->protocol = protocol;
+ 	} while ((skb = skb->next));
+ out:
+ 	return segs;
++>>>>>>> 53e50398968d (net: Remove gso_send_check as an offload callback)
  }
  
  static struct sk_buff *udp4_ufo_fragment(struct sk_buff *skb,
diff --cc net/ipv6/tcpv6_offload.c
index dbb3d9262bf6,c1ab77105b4c..000000000000
--- a/net/ipv6/tcpv6_offload.c
+++ b/net/ipv6/tcpv6_offload.c
@@@ -15,23 -15,6 +15,26 @@@
  #include <net/ip6_checksum.h>
  #include "ip6_offload.h"
  
++<<<<<<< HEAD
 +static int tcp_v6_gso_send_check(struct sk_buff *skb)
 +{
 +	const struct ipv6hdr *ipv6h;
 +	struct tcphdr *th;
 +
 +	if (!pskb_may_pull(skb, sizeof(*th)))
 +		return -EINVAL;
 +
 +	ipv6h = ipv6_hdr(skb);
 +	th = tcp_hdr(skb);
 +
 +	th->check = 0;
 +	skb->ip_summed = CHECKSUM_PARTIAL;
 +	__tcp_v6_send_check(skb, &ipv6h->saddr, &ipv6h->daddr);
 +	return 0;
 +}
 +
++=======
++>>>>>>> 53e50398968d (net: Remove gso_send_check as an offload callback)
  static struct sk_buff **tcp6_gro_receive(struct sk_buff **head,
  					 struct sk_buff *skb)
  {
@@@ -58,10 -41,32 +61,14 @@@ static int tcp6_gro_complete(struct sk_
  	return tcp_gro_complete(skb);
  }
  
 -struct sk_buff *tcp6_gso_segment(struct sk_buff *skb,
 -				 netdev_features_t features)
 -{
 -	struct tcphdr *th;
 -
 -	if (!pskb_may_pull(skb, sizeof(*th)))
 -		return ERR_PTR(-EINVAL);
 -
 -	if (unlikely(skb->ip_summed != CHECKSUM_PARTIAL)) {
 -		const struct ipv6hdr *ipv6h = ipv6_hdr(skb);
 -		struct tcphdr *th = tcp_hdr(skb);
 -
 -		/* Set up pseudo header, usually expect stack to have done
 -		 * this.
 -		 */
 -
 -		th->check = 0;
 -		skb->ip_summed = CHECKSUM_PARTIAL;
 -		__tcp_v6_send_check(skb, &ipv6h->saddr, &ipv6h->daddr);
 -	}
 -
 -	return tcp_gso_segment(skb, features);
 -}
  static const struct net_offload tcpv6_offload = {
  	.callbacks = {
++<<<<<<< HEAD
 +		.gso_send_check	=	tcp_v6_gso_send_check,
 +		.gso_segment	=	tcp_gso_segment,
++=======
+ 		.gso_segment	=	tcp6_gso_segment,
++>>>>>>> 53e50398968d (net: Remove gso_send_check as an offload callback)
  		.gro_receive	=	tcp6_gro_receive,
  		.gro_complete	=	tcp6_gro_complete,
  	},
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index 6d06bb4aa1d0..6c8e663f5de4 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -1689,7 +1689,6 @@ struct packet_type {
 struct offload_callbacks {
 	struct sk_buff		*(*gso_segment)(struct sk_buff *skb,
 						netdev_features_t features);
-	int			(*gso_send_check)(struct sk_buff *skb);
 	struct sk_buff		**(*gro_receive)(struct sk_buff **head,
 					       struct sk_buff *skb);
 	int			(*gro_complete)(struct sk_buff *skb, int nhoff);
diff --git a/net/core/dev.c b/net/core/dev.c
index 1924c9647d47..eb731dc72550 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -2287,16 +2287,6 @@ struct sk_buff *skb_mac_gso_segment(struct sk_buff *skb,
 	rcu_read_lock();
 	list_for_each_entry_rcu(ptype, &offload_base, list) {
 		if (ptype->type == type && ptype->callbacks.gso_segment) {
-			if (unlikely(skb->ip_summed != CHECKSUM_PARTIAL)) {
-				int err;
-
-				err = ptype->callbacks.gso_send_check(skb);
-				segs = ERR_PTR(err);
-				if (err || skb_gso_ok(skb, features))
-					break;
-				__skb_push(skb, (skb->data -
-						 skb_network_header(skb)));
-			}
 			segs = ptype->callbacks.gso_segment(skb, features);
 			break;
 		}
diff --git a/net/ipv4/af_inet.c b/net/ipv4/af_inet.c
index 7da79adb81ec..3e86411dec17 100644
--- a/net/ipv4/af_inet.c
+++ b/net/ipv4/af_inet.c
@@ -1228,40 +1228,6 @@ int inet_sk_rebuild_header(struct sock *sk)
 }
 EXPORT_SYMBOL(inet_sk_rebuild_header);
 
-static int inet_gso_send_check(struct sk_buff *skb)
-{
-	const struct net_offload *ops;
-	const struct iphdr *iph;
-	int proto;
-	int ihl;
-	int err = -EINVAL;
-
-	if (unlikely(!pskb_may_pull(skb, sizeof(*iph))))
-		goto out;
-
-	iph = ip_hdr(skb);
-	ihl = iph->ihl * 4;
-	if (ihl < sizeof(*iph))
-		goto out;
-
-	proto = iph->protocol;
-
-	/* Warning: after this point, iph might be no longer valid */
-	if (unlikely(!pskb_may_pull(skb, ihl)))
-		goto out;
-	__skb_pull(skb, ihl);
-
-	skb_reset_transport_header(skb);
-	err = -EPROTONOSUPPORT;
-
-	ops = rcu_dereference(inet_offloads[proto]);
-	if (likely(ops && ops->callbacks.gso_send_check))
-		err = ops->callbacks.gso_send_check(skb);
-
-out:
-	return err;
-}
-
 static struct sk_buff *inet_gso_segment(struct sk_buff *skb,
 					netdev_features_t features)
 {
@@ -1668,7 +1634,6 @@ static int ipv4_proc_init(void);
 static struct packet_offload ip_packet_offload __read_mostly = {
 	.type = cpu_to_be16(ETH_P_IP),
 	.callbacks = {
-		.gso_send_check = inet_gso_send_check,
 		.gso_segment = inet_gso_segment,
 		.gro_receive = inet_gro_receive,
 		.gro_complete = inet_gro_complete,
@@ -1677,7 +1642,6 @@ static struct packet_offload ip_packet_offload __read_mostly = {
 
 static const struct net_offload ipip_offload = {
 	.callbacks = {
-		.gso_send_check = inet_gso_send_check,
 		.gso_segment	= inet_gso_segment,
 	},
 };
diff --git a/net/ipv4/gre_offload.c b/net/ipv4/gre_offload.c
index 5771ffc8da3d..bb5947b0ce2d 100644
--- a/net/ipv4/gre_offload.c
+++ b/net/ipv4/gre_offload.c
@@ -15,13 +15,6 @@
 #include <net/protocol.h>
 #include <net/gre.h>
 
-static int gre_gso_send_check(struct sk_buff *skb)
-{
-	if (!skb->encapsulation)
-		return -EINVAL;
-	return 0;
-}
-
 static struct sk_buff *gre_gso_segment(struct sk_buff *skb,
 				       netdev_features_t features)
 {
@@ -46,6 +39,9 @@ static struct sk_buff *gre_gso_segment(struct sk_buff *skb,
 				  SKB_GSO_IPIP)))
 		goto out;
 
+	if (!skb->encapsulation)
+		goto out;
+
 	if (unlikely(!pskb_may_pull(skb, sizeof(*greh))))
 		goto out;
 
@@ -256,7 +252,6 @@ static int gre_gro_complete(struct sk_buff *skb, int nhoff)
 
 static const struct net_offload gre_offload = {
 	.callbacks = {
-		.gso_send_check = gre_gso_send_check,
 		.gso_segment = gre_gso_segment,
 		.gro_receive = gre_gro_receive,
 		.gro_complete = gre_gro_complete,
* Unmerged path net/ipv4/tcp_offload.c
* Unmerged path net/ipv4/udp_offload.c
diff --git a/net/ipv6/ip6_offload.c b/net/ipv6/ip6_offload.c
index 8f4bf8d4e2f6..4abd74f6abde 100644
--- a/net/ipv6/ip6_offload.c
+++ b/net/ipv6/ip6_offload.c
@@ -53,31 +53,6 @@ static int ipv6_gso_pull_exthdrs(struct sk_buff *skb, int proto)
 	return proto;
 }
 
-static int ipv6_gso_send_check(struct sk_buff *skb)
-{
-	const struct ipv6hdr *ipv6h;
-	const struct net_offload *ops;
-	int err = -EINVAL;
-
-	if (unlikely(!pskb_may_pull(skb, sizeof(*ipv6h))))
-		goto out;
-
-	ipv6h = ipv6_hdr(skb);
-	__skb_pull(skb, sizeof(*ipv6h));
-	err = -EPROTONOSUPPORT;
-
-	ops = rcu_dereference(inet6_offloads[
-		ipv6_gso_pull_exthdrs(skb, ipv6h->nexthdr)]);
-
-	if (likely(ops && ops->callbacks.gso_send_check)) {
-		skb_reset_transport_header(skb);
-		err = ops->callbacks.gso_send_check(skb);
-	}
-
-out:
-	return err;
-}
-
 static struct sk_buff *ipv6_gso_segment(struct sk_buff *skb,
 	netdev_features_t features)
 {
@@ -304,7 +279,6 @@ out_unlock:
 static struct packet_offload ipv6_packet_offload __read_mostly = {
 	.type = cpu_to_be16(ETH_P_IPV6),
 	.callbacks = {
-		.gso_send_check = ipv6_gso_send_check,
 		.gso_segment = ipv6_gso_segment,
 		.gro_receive = ipv6_gro_receive,
 		.gro_complete = ipv6_gro_complete,
@@ -313,7 +287,6 @@ static struct packet_offload ipv6_packet_offload __read_mostly = {
 
 static const struct net_offload sit_offload = {
 	.callbacks = {
-		.gso_send_check = ipv6_gso_send_check,
 		.gso_segment	= ipv6_gso_segment,
 	},
 };
* Unmerged path net/ipv6/tcpv6_offload.c
diff --git a/net/ipv6/udp_offload.c b/net/ipv6/udp_offload.c
index 5df577b7a269..f303ac4f4cc6 100644
--- a/net/ipv6/udp_offload.c
+++ b/net/ipv6/udp_offload.c
@@ -17,11 +17,6 @@
 #include <net/ip6_checksum.h>
 #include "ip6_offload.h"
 
-static int udp6_ufo_send_check(struct sk_buff *skb)
-{
-	return 0;
-}
-
 static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,
 					 netdev_features_t features)
 {
@@ -166,7 +161,6 @@ int udp6_gro_complete(struct sk_buff *skb, int nhoff)
 
 static const struct net_offload udpv6_offload = {
 	.callbacks = {
-		.gso_send_check =	udp6_ufo_send_check,
 		.gso_segment	=	udp6_ufo_fragment,
 		.gro_receive	=	udp6_gro_receive,
 		.gro_complete	=	udp6_gro_complete,
diff --git a/net/mpls/mpls_gso.c b/net/mpls/mpls_gso.c
index fefda6cc61fa..f0f5309a2d72 100644
--- a/net/mpls/mpls_gso.c
+++ b/net/mpls/mpls_gso.c
@@ -65,15 +65,9 @@ out:
 	return segs;
 }
 
-static int mpls_gso_send_check(struct sk_buff *skb)
-{
-	return 0;
-}
-
 static struct packet_offload mpls_mc_offload = {
 	.type = cpu_to_be16(ETH_P_MPLS_MC),
 	.callbacks = {
-		.gso_send_check =	mpls_gso_send_check,
 		.gso_segment    =	mpls_gso_segment,
 	},
 };
@@ -81,7 +75,6 @@ static struct packet_offload mpls_mc_offload = {
 static struct packet_offload mpls_uc_offload = {
 	.type = cpu_to_be16(ETH_P_MPLS_UC),
 	.callbacks = {
-		.gso_send_check =	mpls_gso_send_check,
 		.gso_segment    =	mpls_gso_segment,
 	},
 };
