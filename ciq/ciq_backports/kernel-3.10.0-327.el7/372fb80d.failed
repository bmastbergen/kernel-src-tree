powerpc/powernv: Fetch frozen PE on top level

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [powerpc] powernv: Fetch frozen PE on top level (Laurent Vivier) [1213675]
Rebuild_FUZZ: 90.24%
commit-author Gavin Shan <gwshan@linux.vnet.ibm.com>
commit 372fb80db93af5d85c750515526d731856e1890c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/372fb80d.failed

It should have been part of commit 1ad7a72c5 ("powerpc/eeh: Report
frozen parent PE prior to child PE"). There are 2 ways to report
EEH errors: proactively polling because of 0xFF's returned from
PCI config or IO read, or interrupt driven event. We missed to
report and handle parent frozen PE prior to child frozen PE for
the later case on PowerNV platform.

	Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 372fb80db93af5d85c750515526d731856e1890c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/powernv/eeh-ioda.c
diff --cc arch/powerpc/platforms/powernv/eeh-ioda.c
index 47d55b12a81e,426814a2ede3..000000000000
--- a/arch/powerpc/platforms/powernv/eeh-ioda.c
+++ b/arch/powerpc/platforms/powernv/eeh-ioda.c
@@@ -805,22 -876,63 +805,77 @@@ static void ioda_eeh_hub_diag(struct pc
  static int ioda_eeh_get_pe(struct pci_controller *hose,
  			   u16 pe_no, struct eeh_pe **pe)
  {
 -	struct pnv_phb *phb = hose->private_data;
 -	struct pnv_ioda_pe *pnv_pe;
 -	struct eeh_pe *dev_pe;
 -	struct eeh_dev edev;
 +	struct eeh_pe *phb_pe, *dev_pe;
 +	struct eeh_dev dev;
 +
++<<<<<<< HEAD
 +	/* Find the PHB PE */
 +	phb_pe = eeh_phb_pe_get(hose);
 +	if (!phb_pe)
 +		return -EEXIST;
  
 +	/* Find the PE according to PE# */
 +	memset(&dev, 0, sizeof(struct eeh_dev));
 +	dev.phb = hose;
 +	dev.pe_config_addr = pe_no;
 +	dev_pe = eeh_pe_get(&dev);
 +	if (!dev_pe) return -EEXIST;
 +
 +	*pe = dev_pe;
++=======
+ 	/*
+ 	 * If PHB supports compound PE, to fetch
+ 	 * the master PE because slave PE is invisible
+ 	 * to EEH core.
+ 	 */
+ 	pnv_pe = &phb->ioda.pe_array[pe_no];
+ 	if (pnv_pe->flags & PNV_IODA_PE_SLAVE) {
+ 		pnv_pe = pnv_pe->master;
+ 		WARN_ON(!pnv_pe ||
+ 			!(pnv_pe->flags & PNV_IODA_PE_MASTER));
+ 		pe_no = pnv_pe->pe_number;
+ 	}
+ 
+ 	/* Find the PE according to PE# */
+ 	memset(&edev, 0, sizeof(struct eeh_dev));
+ 	edev.phb = hose;
+ 	edev.pe_config_addr = pe_no;
+ 	dev_pe = eeh_pe_get(&edev);
+ 	if (!dev_pe)
+ 		return -EEXIST;
+ 
+ 	/* Freeze the (compound) PE */
+ 	*pe = dev_pe;
+ 	if (!(dev_pe->state & EEH_PE_ISOLATED))
+ 		phb->freeze_pe(phb, pe_no);
+ 
+ 	/*
+ 	 * At this point, we're sure the (compound) PE should
+ 	 * have been frozen. However, we still need poke until
+ 	 * hitting the frozen PE on top level.
+ 	 */
+ 	dev_pe = dev_pe->parent;
+ 	while (dev_pe && !(dev_pe->type & EEH_PE_PHB)) {
+ 		int ret;
+ 		int active_flags = (EEH_STATE_MMIO_ACTIVE |
+ 				    EEH_STATE_DMA_ACTIVE);
+ 
+ 		ret = eeh_ops->get_state(dev_pe, NULL);
+ 		if (ret <= 0 || (ret & active_flags) == active_flags) {
+ 			dev_pe = dev_pe->parent;
+ 			continue;
+ 		}
+ 
+ 		/* Frozen parent PE */
+ 		*pe = dev_pe;
+ 		if (!(dev_pe->state & EEH_PE_ISOLATED))
+ 			phb->freeze_pe(phb, dev_pe->addr);
+ 
+ 		/* Next one */
+ 		dev_pe = dev_pe->parent;
+ 	}
+ 
++>>>>>>> 372fb80db93a (powerpc/powernv: Fetch frozen PE on top level)
  	return 0;
  }
  
* Unmerged path arch/powerpc/platforms/powernv/eeh-ioda.c
