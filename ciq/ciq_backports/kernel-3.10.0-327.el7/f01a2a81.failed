virtio_ccw: finalize_features error handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [virtio] virtio-ccw: finalize_features error handling (Jason Wang) [1227339]
Rebuild_FUZZ: 97.73%
commit-author Cornelia Huck <cornelia.huck@de.ibm.com>
commit f01a2a811ae04124fc9382925038fcbbd2f0b7c8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/f01a2a81.failed

We previously tried to use device even if finalize_features failed, but
that's wrong since driver and device are now out of sync.

Fail probe if we detect failures during finalize_features.

	Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
	Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
(cherry picked from commit f01a2a811ae04124fc9382925038fcbbd2f0b7c8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/kvm/virtio_ccw.c
diff --cc drivers/s390/kvm/virtio_ccw.c
index f5f80e7ec38c,71d7802aa8b4..000000000000
--- a/drivers/s390/kvm/virtio_ccw.c
+++ b/drivers/s390/kvm/virtio_ccw.c
@@@ -743,8 -756,8 +743,9 @@@ static void virtio_ccw_finalize_feature
  {
  	struct virtio_ccw_device *vcdev = to_vc_device(vdev);
  	struct virtio_feature_desc *features;
 +	int i;
  	struct ccw1 *ccw;
+ 	int ret;
  
  	if (vcdev->revision >= 1 &&
  	    !__virtio_test_bit(vdev, VIRTIO_F_VERSION_1)) {
@@@ -755,31 -768,44 +756,67 @@@
  
  	ccw = kzalloc(sizeof(*ccw), GFP_DMA | GFP_KERNEL);
  	if (!ccw)
++<<<<<<< HEAD
 +		return;
++=======
+ 		return -ENOMEM;
++>>>>>>> f01a2a811ae0 (virtio_ccw: finalize_features error handling)
  
  	features = kzalloc(sizeof(*features), GFP_DMA | GFP_KERNEL);
- 	if (!features)
+ 	if (!features) {
+ 		ret = -ENOMEM;
  		goto out_free;
- 
+ 	}
  	/* Give virtio_ring a chance to accept features. */
  	vring_transport_features(vdev);
  
++<<<<<<< HEAD
 +	for (i = 0; i < sizeof(*vdev->features) / sizeof(features->features);
 +	     i++) {
 +		int highbits = i % 2 ? 32 : 0;
 +		features->index = i;
 +		features->features = cpu_to_le32(vdev->features[i / 2]
 +						 >> highbits);
 +		/* Write the feature bits to the host. */
 +		ccw->cmd_code = CCW_CMD_WRITE_FEAT;
 +		ccw->flags = 0;
 +		ccw->count = sizeof(*features);
 +		ccw->cda = (__u32)(unsigned long)features;
 +		ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_WRITE_FEAT);
 +	}
 +out_free:
 +	kfree(features);
 +	kfree(ccw);
++=======
+ 	features->index = 0;
+ 	features->features = cpu_to_le32((u32)vdev->features);
+ 	/* Write the first half of the feature bits to the host. */
+ 	ccw->cmd_code = CCW_CMD_WRITE_FEAT;
+ 	ccw->flags = 0;
+ 	ccw->count = sizeof(*features);
+ 	ccw->cda = (__u32)(unsigned long)features;
+ 	ret = ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_WRITE_FEAT);
+ 	if (ret)
+ 		goto out_free;
+ 
+ 	if (vcdev->revision == 0)
+ 		goto out_free;
+ 
+ 	features->index = 1;
+ 	features->features = cpu_to_le32(vdev->features >> 32);
+ 	/* Write the second half of the feature bits to the host. */
+ 	ccw->cmd_code = CCW_CMD_WRITE_FEAT;
+ 	ccw->flags = 0;
+ 	ccw->count = sizeof(*features);
+ 	ccw->cda = (__u32)(unsigned long)features;
+ 	ret = ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_WRITE_FEAT);
+ 
+ out_free:
+ 	kfree(features);
+ 	kfree(ccw);
+ 
+ 	return ret;
++>>>>>>> f01a2a811ae0 (virtio_ccw: finalize_features error handling)
  }
  
  static void virtio_ccw_get_config(struct virtio_device *vdev,
* Unmerged path drivers/s390/kvm/virtio_ccw.c
