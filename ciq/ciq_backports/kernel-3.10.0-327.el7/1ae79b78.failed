powerpc/eeh: Fix race condition in pcibios_set_pcie_reset_state()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [powerpc] eeh: Fix race condition in pcibios_set_pcie_reset_state() (Laurent Vivier) [1213675]
Rebuild_FUZZ: 93.44%
commit-author Gavin Shan <gwshan@linux.vnet.ibm.com>
commit 1ae79b78bc52b910a224f3795122538516e07b5f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/1ae79b78.failed

When asserting reset in pcibios_set_pcie_reset_state(), the PE
is enforced to (hardware) frozen state in order to drop unexpected
PCI transactions (except PCI config read/write) automatically by
hardware during reset, which would cause recursive EEH error.
However, the (software) frozen state EEH_PE_ISOLATED is missed.
When users get 0xFF from PCI config or MMIO read, EEH_PE_ISOLATED
is set in PE state retrival backend. Unfortunately, nobody (the
reset handler or the EEH recovery functinality in host) will clear
EEH_PE_ISOLATED when the PE has been passed through to guest.

The patch sets and clears EEH_PE_ISOLATED properly during reset
in function pcibios_set_pcie_reset_state() to fix the issue.

Fixes: 28158cd ("Enhance pcibios_set_pcie_reset_state()")
	Reported-by: Carol L. Soto <clsoto@us.ibm.com>
	Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
	Tested-by: Carol L. Soto <clsoto@us.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 1ae79b78bc52b910a224f3795122538516e07b5f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/eeh.c
diff --cc arch/powerpc/kernel/eeh.c
index 6021b67a433c,fa046ca6d0fa..000000000000
--- a/arch/powerpc/kernel/eeh.c
+++ b/arch/powerpc/kernel/eeh.c
@@@ -686,18 -746,27 +686,42 @@@ int pcibios_set_pcie_reset_state(struc
  	switch (state) {
  	case pcie_deassert_reset:
  		eeh_ops->reset(pe, EEH_RESET_DEACTIVATE);
++<<<<<<< HEAD
 +		eeh_pe_state_clear(pe, EEH_PE_RESET);
 +		break;
 +	case pcie_hot_reset:
 +		eeh_pe_state_mark(pe, EEH_PE_RESET);
 +		eeh_ops->reset(pe, EEH_RESET_HOT);
 +		break;
 +	case pcie_warm_reset:
 +		eeh_pe_state_mark(pe, EEH_PE_RESET);
 +		eeh_ops->reset(pe, EEH_RESET_FUNDAMENTAL);
 +		break;
 +	default:
 +		eeh_pe_state_clear(pe, EEH_PE_RESET);
++=======
+ 		eeh_unfreeze_pe(pe, false);
+ 		eeh_pe_state_clear(pe, EEH_PE_CFG_BLOCKED);
+ 		eeh_pe_dev_traverse(pe, eeh_restore_dev_state, dev);
+ 		eeh_pe_state_clear(pe, EEH_PE_ISOLATED);
+ 		break;
+ 	case pcie_hot_reset:
+ 		eeh_pe_state_mark(pe, EEH_PE_ISOLATED);
+ 		eeh_ops->set_option(pe, EEH_OPT_FREEZE_PE);
+ 		eeh_pe_dev_traverse(pe, eeh_disable_and_save_dev_state, dev);
+ 		eeh_pe_state_mark(pe, EEH_PE_CFG_BLOCKED);
+ 		eeh_ops->reset(pe, EEH_RESET_HOT);
+ 		break;
+ 	case pcie_warm_reset:
+ 		eeh_pe_state_mark(pe, EEH_PE_ISOLATED);
+ 		eeh_ops->set_option(pe, EEH_OPT_FREEZE_PE);
+ 		eeh_pe_dev_traverse(pe, eeh_disable_and_save_dev_state, dev);
+ 		eeh_pe_state_mark(pe, EEH_PE_CFG_BLOCKED);
+ 		eeh_ops->reset(pe, EEH_RESET_FUNDAMENTAL);
+ 		break;
+ 	default:
+ 		eeh_pe_state_clear(pe, EEH_PE_ISOLATED | EEH_PE_CFG_BLOCKED);
++>>>>>>> 1ae79b78bc52 (powerpc/eeh: Fix race condition in pcibios_set_pcie_reset_state())
  		return -EINVAL;
  	};
  
* Unmerged path arch/powerpc/kernel/eeh.c
