vfio: powerpc/spapr/iommu/powernv/ioda2: Rework IOMMU ownership control

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Alexey Kardashevskiy <aik@ozlabs.ru>
commit f87a88642e660edd8912ad39fe77848c6f9927a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/f87a8864.failed

This adds tce_iommu_take_ownership() and tce_iommu_release_ownership
which call in a loop iommu_take_ownership()/iommu_release_ownership()
for every table on the group. As there is just one now, no change in
behaviour is expected.

At the moment the iommu_table struct has a set_bypass() which enables/
disables DMA bypass on IODA2 PHB. This is exposed to POWERPC IOMMU code
which calls this callback when external IOMMU users such as VFIO are
about to get over a PHB.

The set_bypass() callback is not really an iommu_table function but
IOMMU/PE function. This introduces a iommu_table_group_ops struct and
adds take_ownership()/release_ownership() callbacks to it which are
called when an external user takes/releases control over the IOMMU.

This replaces set_bypass() with ownership callbacks as it is not
necessarily just bypass enabling, it can be something else/more
so let's give it more generic name.

The callbacks is implemented for IODA2 only. Other platforms (P5IOC2,
IODA1) will use the old iommu_take_ownership/iommu_release_ownership API.
The following patches will replace iommu_take_ownership/
iommu_release_ownership calls in IODA2 with full IOMMU table release/
create.

As we here and touching bypass control, this removes
pnv_pci_ioda2_setup_bypass_pe() as it does not do much
more compared to pnv_pci_ioda2_set_bypass. This moves tce_bypass_base
initialization to pnv_pci_ioda2_setup_dma_pe.

	Signed-off-by: Alexey Kardashevskiy <aik@ozlabs.ru>
[aw: for the vfio related changes]
	Acked-by: Alex Williamson <alex.williamson@redhat.com>
	Reviewed-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
	Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit f87a88642e660edd8912ad39fe77848c6f9927a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/iommu.h
#	arch/powerpc/platforms/powernv/pci-ioda.c
#	drivers/vfio/vfio_iommu_spapr_tce.c
diff --cc arch/powerpc/include/asm/iommu.h
index 2d866433cb3d,489133cf7c5e..000000000000
--- a/arch/powerpc/include/asm/iommu.h
+++ b/arch/powerpc/include/asm/iommu.h
@@@ -74,10 -91,8 +74,15 @@@ struct iommu_table 
  	struct iommu_pool pools[IOMMU_NR_POOLS];
  	unsigned long *it_map;       /* A simple allocation bitmap for now */
  	unsigned long  it_page_shift;/* table iommu page size */
++<<<<<<< HEAD
 +#ifdef CONFIG_IOMMU_API
 +	struct iommu_group *it_group;
 +#endif
 +	void (*set_bypass)(struct iommu_table *tbl, bool enable);
++=======
+ 	struct list_head it_group_list;/* List of iommu_table_group_link */
+ 	struct iommu_table_ops *it_ops;
++>>>>>>> f87a88642e66 (vfio: powerpc/spapr/iommu/powernv/ioda2: Rework IOMMU ownership control)
  };
  
  /* Pure 2^n version of get_order */
@@@ -108,8 -123,32 +113,34 @@@ extern void iommu_free_table(struct iom
   */
  extern struct iommu_table *iommu_init_table(struct iommu_table * tbl,
  					    int nid);
++<<<<<<< HEAD
++=======
+ #define IOMMU_TABLE_GROUP_MAX_TABLES	1
+ 
+ struct iommu_table_group;
+ 
+ struct iommu_table_group_ops {
+ 	/* Switch ownership from platform code to external user (e.g. VFIO) */
+ 	void (*take_ownership)(struct iommu_table_group *table_group);
+ 	/* Switch ownership from external user (e.g. VFIO) back to core */
+ 	void (*release_ownership)(struct iommu_table_group *table_group);
+ };
+ 
+ struct iommu_table_group_link {
+ 	struct list_head next;
+ 	struct rcu_head rcu;
+ 	struct iommu_table_group *table_group;
+ };
+ 
+ struct iommu_table_group {
+ 	struct iommu_group *group;
+ 	struct iommu_table *tables[IOMMU_TABLE_GROUP_MAX_TABLES];
+ 	struct iommu_table_group_ops *ops;
+ };
+ 
++>>>>>>> f87a88642e66 (vfio: powerpc/spapr/iommu/powernv/ioda2: Rework IOMMU ownership control)
  #ifdef CONFIG_IOMMU_API
 -
 -extern void iommu_register_group(struct iommu_table_group *table_group,
 +extern void iommu_register_group(struct iommu_table *tbl,
  				 int pci_domain_number, unsigned long pe_num);
  extern int iommu_add_device(struct device *dev);
  extern void iommu_del_device(struct device *dev);
diff --cc arch/powerpc/platforms/powernv/pci-ioda.c
index 109e90d84e34,17a77522ea0d..000000000000
--- a/arch/powerpc/platforms/powernv/pci-ioda.c
+++ b/arch/powerpc/platforms/powernv/pci-ioda.c
@@@ -756,12 -1913,14 +756,15 @@@ static void pnv_pci_ioda_setup_dma_pe(s
  		pe->tce32_seg = -1;
  	if (tce_mem)
  		__free_pages(tce_mem, get_order(TCE32_TABLE_SIZE * segs));
 -	if (tbl) {
 -		pnv_pci_unlink_table_and_group(tbl, &pe->table_group);
 -		iommu_free_table(tbl, "pnv");
 -	}
  }
  
- static void pnv_pci_ioda2_set_bypass(struct iommu_table *tbl, bool enable)
+ static void pnv_pci_ioda2_set_bypass(struct pnv_ioda_pe *pe, bool enable)
  {
++<<<<<<< HEAD
 +	struct pnv_ioda_pe *pe = container_of(tbl, struct pnv_ioda_pe,
 +					      tce32_table);
++=======
++>>>>>>> f87a88642e66 (vfio: powerpc/spapr/iommu/powernv/ioda2: Rework IOMMU ownership control)
  	uint16_t window_id = (pe->pe_number << 1 ) + 1;
  	int64_t rc;
  
@@@ -799,19 -1947,31 +802,39 @@@
  		pe->tce_bypass_enabled = enable;
  }
  
- static void pnv_pci_ioda2_setup_bypass_pe(struct pnv_phb *phb,
- 					  struct pnv_ioda_pe *pe)
+ #ifdef CONFIG_IOMMU_API
+ static void pnv_ioda2_take_ownership(struct iommu_table_group *table_group)
  {
- 	/* TVE #1 is selected by PCI address bit 59 */
- 	pe->tce_bypass_base = 1ull << 59;
+ 	struct pnv_ioda_pe *pe = container_of(table_group, struct pnv_ioda_pe,
+ 						table_group);
  
++<<<<<<< HEAD
 +	/* Install set_bypass callback for VFIO */
 +	pe->tce32_table.set_bypass = pnv_pci_ioda2_set_bypass;
 +
 +	/* Enable bypass by default */
 +	pnv_pci_ioda2_set_bypass(&pe->tce32_table, true);
++=======
+ 	iommu_take_ownership(table_group->tables[0]);
+ 	pnv_pci_ioda2_set_bypass(pe, false);
++>>>>>>> f87a88642e66 (vfio: powerpc/spapr/iommu/powernv/ioda2: Rework IOMMU ownership control)
+ }
+ 
+ static void pnv_ioda2_release_ownership(struct iommu_table_group *table_group)
+ {
+ 	struct pnv_ioda_pe *pe = container_of(table_group, struct pnv_ioda_pe,
+ 						table_group);
+ 
+ 	iommu_release_ownership(table_group->tables[0]);
+ 	pnv_pci_ioda2_set_bypass(pe, true);
  }
  
+ static struct iommu_table_group_ops pnv_pci_ioda2_ops = {
+ 	.take_ownership = pnv_ioda2_take_ownership,
+ 	.release_ownership = pnv_ioda2_release_ownership,
+ };
+ #endif
+ 
  static void pnv_pci_ioda2_setup_dma_pe(struct pnv_phb *phb,
  				       struct pnv_ioda_pe *pe)
  {
@@@ -826,6 -1986,14 +849,17 @@@
  	if (WARN_ON(pe->tce32_seg >= 0))
  		return;
  
++<<<<<<< HEAD
++=======
+ 	/* TVE #1 is selected by PCI address bit 59 */
+ 	pe->tce_bypass_base = 1ull << 59;
+ 
+ 	tbl = pnv_pci_table_alloc(phb->hose->node);
+ 	iommu_register_group(&pe->table_group, phb->hose->global_number,
+ 			pe->pe_number);
+ 	pnv_pci_link_table_and_group(phb->hose->node, 0, tbl, &pe->table_group);
+ 
++>>>>>>> f87a88642e66 (vfio: powerpc/spapr/iommu/powernv/ioda2: Rework IOMMU ownership control)
  	/* The PE will reserve all possible 32-bits space */
  	pe->tce32_seg = 0;
  	end = (1 << ilog2(phb->ioda.m32_pci_base));
@@@ -869,19 -2036,32 +903,31 @@@
  		 * errors, and on the first pass the data will be a relative
  		 * bus number, print that out instead.
  		 */
 -		pe->tce_inval_reg_phys = be64_to_cpup(swinvp);
 -		tbl->it_index = (unsigned long)ioremap(pe->tce_inval_reg_phys,
 -				8);
 +		tbl->it_index = (unsigned long)ioremap(be64_to_cpup(swinvp), 8);
  		tbl->it_type |= (TCE_PCI_SWINV_CREATE | TCE_PCI_SWINV_FREE);
  	}
 -	tbl->it_ops = &pnv_ioda2_iommu_ops;
  	iommu_init_table(tbl, phb->hose->node);
++<<<<<<< HEAD
 +	iommu_register_group(tbl, phb->hose->global_number, pe->pe_number);
++=======
+ #ifdef CONFIG_IOMMU_API
+ 	pe->table_group.ops = &pnv_pci_ioda2_ops;
+ #endif
++>>>>>>> f87a88642e66 (vfio: powerpc/spapr/iommu/powernv/ioda2: Rework IOMMU ownership control)
  
 -	if (pe->flags & PNV_IODA_PE_DEV) {
 -		/*
 -		 * Setting table base here only for carrying iommu_group
 -		 * further down to let iommu_add_device() do the job.
 -		 * pnv_pci_ioda_dma_dev_setup will override it later anyway.
 -		 */
 -		set_iommu_table_base(&pe->pdev->dev, tbl);
 -		iommu_add_device(&pe->pdev->dev);
 -	} else if (pe->flags & (PNV_IODA_PE_BUS | PNV_IODA_PE_BUS_ALL))
 -		pnv_ioda_setup_bus_dma(pe, pe->pbus);
 +	if (pe->pdev)
 +		set_iommu_table_base_and_group(&pe->pdev->dev, tbl);
 +	else
 +		pnv_ioda_setup_bus_dma(pe, pe->pbus, true);
  
  	/* Also create a bypass window */
++<<<<<<< HEAD
 +	pnv_pci_ioda2_setup_bypass_pe(phb, pe);
++=======
+ 	if (!pnv_iommu_bypass_disabled)
+ 		pnv_pci_ioda2_set_bypass(pe, true);
+ 
++>>>>>>> f87a88642e66 (vfio: powerpc/spapr/iommu/powernv/ioda2: Rework IOMMU ownership control)
  	return;
  fail:
  	if (pe->tce32_seg >= 0)
diff --cc drivers/vfio/vfio_iommu_spapr_tce.c
index e65bc73cc8a8,9c720de46c33..000000000000
--- a/drivers/vfio/vfio_iommu_spapr_tce.c
+++ b/drivers/vfio/vfio_iommu_spapr_tce.c
@@@ -470,9 -567,20 +525,24 @@@ static int tce_iommu_attach_group(void 
  		goto unlock_exit;
  	}
  
++<<<<<<< HEAD
 +	ret = iommu_take_ownership(tbl);
++=======
+ 	table_group = iommu_group_get_iommudata(iommu_group);
+ 	if (!table_group) {
+ 		ret = -ENXIO;
+ 		goto unlock_exit;
+ 	}
+ 
+ 	if (!table_group->ops || !table_group->ops->take_ownership ||
+ 			!table_group->ops->release_ownership)
+ 		ret = tce_iommu_take_ownership(container, table_group);
+ 	else
+ 		ret = tce_iommu_take_ownership_ddw(container, table_group);
+ 
++>>>>>>> f87a88642e66 (vfio: powerpc/spapr/iommu/powernv/ioda2: Rework IOMMU ownership control)
  	if (!ret)
 -		container->grp = iommu_group;
 +		container->tbl = tbl;
  
  unlock_exit:
  	mutex_unlock(&container->lock);
@@@ -484,14 -592,13 +554,18 @@@ static void tce_iommu_detach_group(voi
  		struct iommu_group *iommu_group)
  {
  	struct tce_container *container = iommu_data;
++<<<<<<< HEAD
 +	struct iommu_table *tbl = iommu_group_get_iommudata(iommu_group);
++=======
+ 	struct iommu_table_group *table_group;
++>>>>>>> f87a88642e66 (vfio: powerpc/spapr/iommu/powernv/ioda2: Rework IOMMU ownership control)
  
 +	BUG_ON(!tbl);
  	mutex_lock(&container->lock);
 -	if (iommu_group != container->grp) {
 +	if (tbl != container->tbl) {
  		pr_warn("tce_vfio: detaching group #%u, expected group is #%u\n",
  				iommu_group_id(iommu_group),
 -				iommu_group_id(container->grp));
 +				iommu_group_id(tbl->it_group));
  		goto unlock_exit;
  	}
  
@@@ -503,9 -610,15 +577,21 @@@
  
  	/* pr_debug("tce_vfio: detaching group #%u from iommu %p\n",
  	   iommu_group_id(iommu_group), iommu_group); */
++<<<<<<< HEAD
 +	container->tbl = NULL;
 +	tce_iommu_clear(container, tbl, tbl->it_offset, tbl->it_size);
 +	iommu_release_ownership(tbl);
++=======
+ 	container->grp = NULL;
+ 
+ 	table_group = iommu_group_get_iommudata(iommu_group);
+ 	BUG_ON(!table_group);
+ 
+ 	if (!table_group->ops || !table_group->ops->release_ownership)
+ 		tce_iommu_release_ownership(container, table_group);
+ 	else
+ 		tce_iommu_release_ownership_ddw(container, table_group);
++>>>>>>> f87a88642e66 (vfio: powerpc/spapr/iommu/powernv/ioda2: Rework IOMMU ownership control)
  
  unlock_exit:
  	mutex_unlock(&container->lock);
* Unmerged path arch/powerpc/include/asm/iommu.h
diff --git a/arch/powerpc/kernel/iommu.c b/arch/powerpc/kernel/iommu.c
index a8ba9f468d1a..10df144bdbf3 100644
--- a/arch/powerpc/kernel/iommu.c
+++ b/arch/powerpc/kernel/iommu.c
@@ -1051,14 +1051,6 @@ int iommu_take_ownership(struct iommu_table *tbl)
 
 	memset(tbl->it_map, 0xff, sz);
 
-	/*
-	 * Disable iommu bypass, otherwise the user can DMA to all of
-	 * our physical memory via the bypass window instead of just
-	 * the pages that has been explicitly mapped into the iommu
-	 */
-	if (tbl->set_bypass)
-		tbl->set_bypass(tbl, false);
-
 	return 0;
 }
 EXPORT_SYMBOL_GPL(iommu_take_ownership);
@@ -1072,10 +1064,6 @@ void iommu_release_ownership(struct iommu_table *tbl)
 	/* Restore bit#0 set by iommu_init_table() */
 	if (tbl->it_offset == 0)
 		set_bit(0, tbl->it_map);
-
-	/* The kernel owns the device now, we can restore the iommu bypass */
-	if (tbl->set_bypass)
-		tbl->set_bypass(tbl, true);
 }
 EXPORT_SYMBOL_GPL(iommu_release_ownership);
 
* Unmerged path arch/powerpc/platforms/powernv/pci-ioda.c
* Unmerged path drivers/vfio/vfio_iommu_spapr_tce.c
