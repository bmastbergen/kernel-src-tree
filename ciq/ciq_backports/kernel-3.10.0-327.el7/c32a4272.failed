kvm: Documentation: remove ia64

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [kvm] documentation: remove ia64 (Bandan Das) [1209995]
Rebuild_FUZZ: 91.23%
commit-author Tiejun Chen <tiejun.chen@intel.com>
commit c32a42721ce67594e4481a961aa149055de9c1d9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/c32a4272.failed

kvm/ia64 is gone, clean up Documentation too.

	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit c32a42721ce67594e4481a961aa149055de9c1d9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/virtual/kvm/api.txt
diff --cc Documentation/virtual/kvm/api.txt
index 5989c6a5ea91,80bfe59fc992..000000000000
--- a/Documentation/virtual/kvm/api.txt
+++ b/Documentation/virtual/kvm/api.txt
@@@ -589,8 -606,8 +589,13 @@@ struct kvm_fpu 
  
  4.24 KVM_CREATE_IRQCHIP
  
++<<<<<<< HEAD
 +Capability: KVM_CAP_IRQCHIP
 +Architectures: x86, ia64, ARM
++=======
+ Capability: KVM_CAP_IRQCHIP, KVM_CAP_S390_IRQCHIP (s390)
+ Architectures: x86, ARM, arm64, s390
++>>>>>>> c32a42721ce6 (kvm: Documentation: remove ia64)
  Type: vm ioctl
  Parameters: none
  Returns: 0 on success, -1 on error
@@@ -598,14 -615,17 +603,26 @@@
  Creates an interrupt controller model in the kernel.  On x86, creates a virtual
  ioapic, a virtual PIC (two PICs, nested), and sets up future vcpus to have a
  local APIC.  IRQ routing for GSIs 0-15 is set to both PIC and IOAPIC; GSI 16-23
++<<<<<<< HEAD
 +only go to the IOAPIC.  On ia64, a IOSAPIC is created. On ARM, a GIC is
 +created.
++=======
+ only go to the IOAPIC.  On ARM/arm64, a GIC is
+ created. On s390, a dummy irq routing table is created.
+ 
+ Note that on s390 the KVM_CAP_S390_IRQCHIP vm capability needs to be enabled
+ before KVM_CREATE_IRQCHIP can be used.
++>>>>>>> c32a42721ce6 (kvm: Documentation: remove ia64)
  
  
  4.25 KVM_IRQ_LINE
  
  Capability: KVM_CAP_IRQCHIP
++<<<<<<< HEAD
 +Architectures: x86, ia64, arm
++=======
+ Architectures: x86, arm, arm64
++>>>>>>> c32a42721ce6 (kvm: Documentation: remove ia64)
  Type: vm ioctl
  Parameters: struct kvm_irq_level
  Returns: 0 on success, -1 on error
@@@ -973,7 -994,7 +990,11 @@@ for vm-wide capabilities
  4.38 KVM_GET_MP_STATE
  
  Capability: KVM_CAP_MP_STATE
++<<<<<<< HEAD
 +Architectures: x86, ia64
++=======
+ Architectures: x86, s390
++>>>>>>> c32a42721ce6 (kvm: Documentation: remove ia64)
  Type: vcpu ioctl
  Parameters: struct kvm_mp_state (out)
  Returns: 0 on success; -1 on error
@@@ -987,24 -1008,31 +1008,50 @@@ uniprocessor guests)
  
  Possible values are:
  
++<<<<<<< HEAD
 + - KVM_MP_STATE_RUNNABLE:        the vcpu is currently running
 + - KVM_MP_STATE_UNINITIALIZED:   the vcpu is an application processor (AP)
 +                                 which has not yet received an INIT signal
 + - KVM_MP_STATE_INIT_RECEIVED:   the vcpu has received an INIT signal, and is
 +                                 now ready for a SIPI
 + - KVM_MP_STATE_HALTED:          the vcpu has executed a HLT instruction and
 +                                 is waiting for an interrupt
 + - KVM_MP_STATE_SIPI_RECEIVED:   the vcpu has just received a SIPI (vector
 +                                 accessible via KVM_GET_VCPU_EVENTS)
 +
 +This ioctl is only useful after KVM_CREATE_IRQCHIP.  Without an in-kernel
 +irqchip, the multiprocessing state must be maintained by userspace.
++=======
+  - KVM_MP_STATE_RUNNABLE:        the vcpu is currently running [x86]
+  - KVM_MP_STATE_UNINITIALIZED:   the vcpu is an application processor (AP)
+                                  which has not yet received an INIT signal [x86]
+  - KVM_MP_STATE_INIT_RECEIVED:   the vcpu has received an INIT signal, and is
+                                  now ready for a SIPI [x86]
+  - KVM_MP_STATE_HALTED:          the vcpu has executed a HLT instruction and
+                                  is waiting for an interrupt [x86]
+  - KVM_MP_STATE_SIPI_RECEIVED:   the vcpu has just received a SIPI (vector
+                                  accessible via KVM_GET_VCPU_EVENTS) [x86]
+  - KVM_MP_STATE_STOPPED:         the vcpu is stopped [s390]
+  - KVM_MP_STATE_CHECK_STOP:      the vcpu is in a special error state [s390]
+  - KVM_MP_STATE_OPERATING:       the vcpu is operating (running or halted)
+                                  [s390]
+  - KVM_MP_STATE_LOAD:            the vcpu is in a special load/startup state
+                                  [s390]
+ 
+ On x86, this ioctl is only useful after KVM_CREATE_IRQCHIP. Without an
+ in-kernel irqchip, the multiprocessing state must be maintained by userspace on
+ these architectures.
++>>>>>>> c32a42721ce6 (kvm: Documentation: remove ia64)
  
  
  4.39 KVM_SET_MP_STATE
  
  Capability: KVM_CAP_MP_STATE
++<<<<<<< HEAD
 +Architectures: x86, ia64
++=======
+ Architectures: x86, s390
++>>>>>>> c32a42721ce6 (kvm: Documentation: remove ia64)
  Type: vcpu ioctl
  Parameters: struct kvm_mp_state (in)
  Returns: 0 on success; -1 on error
@@@ -1012,8 -1040,9 +1059,14 @@@
  Sets the vcpu's current "multiprocessing state"; see KVM_GET_MP_STATE for
  arguments.
  
++<<<<<<< HEAD
 +This ioctl is only useful after KVM_CREATE_IRQCHIP.  Without an in-kernel
 +irqchip, the multiprocessing state must be maintained by userspace.
++=======
+ On x86, this ioctl is only useful after KVM_CREATE_IRQCHIP. Without an
+ in-kernel irqchip, the multiprocessing state must be maintained by userspace on
+ these architectures.
++>>>>>>> c32a42721ce6 (kvm: Documentation: remove ia64)
  
  
  4.40 KVM_SET_IDENTITY_MAP_ADDR
@@@ -1355,7 -1384,7 +1408,11 @@@ KVM_ASSIGN_DEV_IRQ. Partial deassignmen
  4.52 KVM_SET_GSI_ROUTING
  
  Capability: KVM_CAP_IRQ_ROUTING
++<<<<<<< HEAD
 +Architectures: x86 ia64
++=======
+ Architectures: x86 s390
++>>>>>>> c32a42721ce6 (kvm: Documentation: remove ia64)
  Type: vm ioctl
  Parameters: struct kvm_irq_routing (in)
  Returns: 0 on success, -1 on error
diff --git a/Documentation/ia64/kvm.txt b/Documentation/ia64/kvm.txt
deleted file mode 100644
index ffb5c80bec3e..000000000000
--- a/Documentation/ia64/kvm.txt
+++ /dev/null
@@ -1,83 +0,0 @@
-Currently, kvm module is in EXPERIMENTAL stage on IA64. This means that
-interfaces are not stable enough to use. So, please don't run critical
-applications in virtual machine.
-We will try our best to improve it in future versions!
-
-				Guide: How to boot up guests on kvm/ia64
-
-This guide is to describe how to enable kvm support for IA-64 systems.
-
-1. Get the kvm source from git.kernel.org.
-	Userspace source:
-		git clone git://git.kernel.org/pub/scm/virt/kvm/kvm-userspace.git
-	Kernel Source:
-		git clone git://git.kernel.org/pub/scm/linux/kernel/git/xiantao/kvm-ia64.git
-
-2. Compile the source code.
-	2.1 Compile userspace code:
-		(1)cd ./kvm-userspace
-		(2)./configure
-		(3)cd kernel
-		(4)make sync LINUX= $kernel_dir (kernel_dir is the directory of kernel source.)
-		(5)cd ..
-		(6)make qemu
-		(7)cd qemu; make install
-
-	2.2 Compile kernel source code:
-		(1) cd ./$kernel_dir
-		(2) Make menuconfig
-		(3) Enter into virtualization option, and choose kvm.
-		(4) make
-		(5) Once (4) done, make modules_install
-		(6) Make initrd, and use new kernel to reboot up host machine.
-		(7) Once (6) done, cd $kernel_dir/arch/ia64/kvm
-		(8) insmod kvm.ko; insmod kvm-intel.ko
-
-Note: For step 2, please make sure that host page size == TARGET_PAGE_SIZE of qemu, otherwise, may fail.
-
-3. Get Guest Firmware named as Flash.fd, and put it under right place:
-	(1) If you have the guest firmware (binary) released by Intel Corp for Xen, use it directly.
-
-	(2) If you have no firmware at hand, Please download its source from
-		hg clone http://xenbits.xensource.com/ext/efi-vfirmware.hg
-	    you can get the firmware's binary in the directory of efi-vfirmware.hg/binaries.
-
-	(3) Rename the firmware you owned to Flash.fd, and copy it to /usr/local/share/qemu
-
-4. Boot up Linux or Windows guests:
-	4.1 Create or install a image for guest boot. If you have xen experience, it should be easy.
-
-	4.2 Boot up guests use the following command.
-		/usr/local/bin/qemu-system-ia64 -smp xx -m 512 -hda $your_image
-		(xx is the number of virtual processors for the guest, now the maximum value is 4)
-
-5. Known possible issue on some platforms with old Firmware.
-
-In the event of strange host crash issues, try to solve it through either of the following ways:
-
-(1): Upgrade your Firmware to the latest one.
-
-(2): Applying the below patch to kernel source.
-diff --git a/arch/ia64/kernel/pal.S b/arch/ia64/kernel/pal.S
-index 0b53344..f02b0f7 100644
---- a/arch/ia64/kernel/pal.S
-+++ b/arch/ia64/kernel/pal.S
-@@ -84,7 +84,8 @@ GLOBAL_ENTRY(ia64_pal_call_static)
-	mov ar.pfs = loc1
-	mov rp = loc0
-	;;
--	srlz.d				// serialize restoration of psr.l
-+	srlz.i			// serialize restoration of psr.l
-+	;;
-	br.ret.sptk.many b0
- END(ia64_pal_call_static)
-
-6. Bug report:
-	If you found any issues when use kvm/ia64, Please post the bug info to kvm-ia64-devel mailing list.
-	https://lists.sourceforge.net/lists/listinfo/kvm-ia64-devel/
-
-Thanks for your interest! Let's work together, and make kvm/ia64 stronger and stronger!
-
-
-								Xiantao Zhang <xiantao.zhang@intel.com>
-											2008.3.10
* Unmerged path Documentation/virtual/kvm/api.txt
