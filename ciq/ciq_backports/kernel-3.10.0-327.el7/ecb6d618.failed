KVM: PPC: Book3S HV: Endian fix for accessing VPA yield count

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [kvm] ppc: book3s hv: Endian fix for accessing VPA yield count (Thomas Huth) [1226884 1227323]
Rebuild_FUZZ: 95.73%
commit-author Paul Mackerras <paulus@samba.org>
commit ecb6d6185b3ae40067330eb889977bf2a51f7429
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/ecb6d618.failed

The VPA (virtual processor area) is defined by PAPR and is therefore
big-endian, so we need a be32_to_cpu when reading it in
kvmppc_get_yield_count().  Without this, H_CONFER always fails on a
little-endian host, causing SMP guests to waste time spinning on
spinlocks.

	Signed-off-by: Paul Mackerras <paulus@samba.org>
	Signed-off-by: Alexander Graf <agraf@suse.de>
(cherry picked from commit ecb6d6185b3ae40067330eb889977bf2a51f7429)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kvm/book3s_hv.c
diff --cc arch/powerpc/kvm/book3s_hv.c
index 68c809978734,de747563d29d..000000000000
--- a/arch/powerpc/kvm/book3s_hv.c
+++ b/arch/powerpc/kvm/book3s_hv.c
@@@ -607,6 -607,40 +607,43 @@@ static int kvmppc_h_set_mode(struct kvm
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static int kvm_arch_vcpu_yield_to(struct kvm_vcpu *target)
+ {
+ 	struct kvmppc_vcore *vcore = target->arch.vcore;
+ 
+ 	/*
+ 	 * We expect to have been called by the real mode handler
+ 	 * (kvmppc_rm_h_confer()) which would have directly returned
+ 	 * H_SUCCESS if the source vcore wasn't idle (e.g. if it may
+ 	 * have useful work to do and should not confer) so we don't
+ 	 * recheck that here.
+ 	 */
+ 
+ 	spin_lock(&vcore->lock);
+ 	if (target->arch.state == KVMPPC_VCPU_RUNNABLE &&
+ 	    vcore->vcore_state != VCORE_INACTIVE)
+ 		target = vcore->runner;
+ 	spin_unlock(&vcore->lock);
+ 
+ 	return kvm_vcpu_yield_to(target);
+ }
+ 
+ static int kvmppc_get_yield_count(struct kvm_vcpu *vcpu)
+ {
+ 	int yield_count = 0;
+ 	struct lppaca *lppaca;
+ 
+ 	spin_lock(&vcpu->arch.vpa_update_lock);
+ 	lppaca = (struct lppaca *)vcpu->arch.vpa.pinned_addr;
+ 	if (lppaca)
+ 		yield_count = be32_to_cpu(lppaca->yield_count);
+ 	spin_unlock(&vcpu->arch.vpa_update_lock);
+ 	return yield_count;
+ }
+ 
++>>>>>>> ecb6d6185b3a (KVM: PPC: Book3S HV: Endian fix for accessing VPA yield count)
  int kvmppc_pseries_do_hcall(struct kvm_vcpu *vcpu)
  {
  	unsigned long req = kvmppc_get_gpr(vcpu, 3);
* Unmerged path arch/powerpc/kvm/book3s_hv.c
