ipv6: Allow sending packets through tunnels with wildcard endpoints

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] ip6_tunnel: Allow sending packets through tunnels with wildcard endpoints (Marcelo Leitner) [1206570]
Rebuild_FUZZ: 94.29%
commit-author Steffen Klassert <steffen.klassert@secunet.com>
commit d50051407f136028108cfda068d55ef053a54fe1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/d5005140.failed

Currently we need the IP6_TNL_F_CAP_XMIT capabiltiy to transmit
packets through an ipv6 tunnel. This capability is set when the
tunnel gets configured, based on the tunnel endpoint addresses.

On tunnels with wildcard tunnel endpoints, we need to do the
capabiltiy checking on a per packet basis like it is done in
the receive path.

This patch extends ip6_tnl_xmit_ctl() to take local and remote
addresses as parameters to allow for per packet capabiltiy
checking.

	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d50051407f136028108cfda068d55ef053a54fe1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_vti.c
diff --cc net/ipv6/ip6_vti.c
index 5a55b551fa72,0e8e97e0d38b..000000000000
--- a/net/ipv6/ip6_vti.c
+++ b/net/ipv6/ip6_vti.c
@@@ -382,19 -415,10 +382,20 @@@ static int vti6_xmit(struct sk_buff *sk
  	struct ip6_tnl *t = netdev_priv(dev);
  	struct net_device_stats *stats = &t->dev->stats;
  	struct dst_entry *dst = skb_dst(skb);
 +	struct flowi fl;
 +	struct ipv6hdr *ipv6h = ipv6_hdr(skb);
  	struct net_device *tdev;
+ 	struct xfrm_state *x;
  	int err = -1;
  
 +	if ((t->parms.proto != IPPROTO_IPV6 && t->parms.proto != 0) ||
 +	    !ip6_tnl_xmit_ctl(t) || vti6_addr_conflict(t, ipv6h))
 +		return err;
 +
 +	memset(&fl, 0, sizeof(fl));
 +	skb->mark = be32_to_cpu(t->parms.o_key);
 +	xfrm_decode_session(skb, &fl, AF_INET6);
 +
  	if (!dst)
  		goto tx_err_link_failure;
  
@@@ -440,11 -478,27 +446,26 @@@ vti6_tnl_xmit(struct sk_buff *skb, stru
  {
  	struct ip6_tnl *t = netdev_priv(dev);
  	struct net_device_stats *stats = &t->dev->stats;
 -	struct ipv6hdr *ipv6h;
 -	struct flowi fl;
  	int ret;
  
 -	memset(&fl, 0, sizeof(fl));
 -	skb->mark = be32_to_cpu(t->parms.o_key);
 -
  	switch (skb->protocol) {
  	case htons(ETH_P_IPV6):
++<<<<<<< HEAD
 +		ret = vti6_xmit(skb, dev);
++=======
+ 		ipv6h = ipv6_hdr(skb);
+ 
+ 		if ((t->parms.proto != IPPROTO_IPV6 && t->parms.proto != 0) ||
+ 		    vti6_addr_conflict(t, ipv6h))
+ 			goto tx_err;
+ 
+ 		xfrm_decode_session(skb, &fl, AF_INET6);
+ 		memset(IP6CB(skb), 0, sizeof(*IP6CB(skb)));
+ 		break;
+ 	case htons(ETH_P_IP):
+ 		xfrm_decode_session(skb, &fl, AF_INET);
+ 		memset(IPCB(skb), 0, sizeof(*IPCB(skb)));
++>>>>>>> d50051407f13 (ipv6: Allow sending packets through tunnels with wildcard endpoints)
  		break;
  	default:
  		goto tx_err;
diff --git a/include/net/ip6_tunnel.h b/include/net/ip6_tunnel.h
index 2265b0bf97e5..cf3e3bfeef9a 100644
--- a/include/net/ip6_tunnel.h
+++ b/include/net/ip6_tunnel.h
@@ -65,7 +65,8 @@ void ip6_tnl_dst_reset(struct ip6_tnl *t);
 void ip6_tnl_dst_store(struct ip6_tnl *t, struct dst_entry *dst);
 int ip6_tnl_rcv_ctl(struct ip6_tnl *t, const struct in6_addr *laddr,
 		const struct in6_addr *raddr);
-int ip6_tnl_xmit_ctl(struct ip6_tnl *t);
+int ip6_tnl_xmit_ctl(struct ip6_tnl *t, const struct in6_addr *laddr,
+		     const struct in6_addr *raddr);
 __u16 ip6_tnl_parse_tlv_enc_lim(struct sk_buff *skb, __u8 *raw);
 __u32 ip6_tnl_get_cap(struct ip6_tnl *t, const struct in6_addr *laddr,
 			     const struct in6_addr *raddr);
diff --git a/net/ipv6/ip6_gre.c b/net/ipv6/ip6_gre.c
index 06aadf812d65..e28e389aba73 100644
--- a/net/ipv6/ip6_gre.c
+++ b/net/ipv6/ip6_gre.c
@@ -905,7 +905,7 @@ static netdev_tx_t ip6gre_tunnel_xmit(struct sk_buff *skb,
 	struct net_device_stats *stats = &t->dev->stats;
 	int ret;
 
-	if (!ip6_tnl_xmit_ctl(t))
+	if (!ip6_tnl_xmit_ctl(t, &t->parms.laddr, &t->parms.raddr))
 		goto tx_err;
 
 	switch (skb->protocol) {
diff --git a/net/ipv6/ip6_tunnel.c b/net/ipv6/ip6_tunnel.c
index 3e2a790fd5f7..a7458395bfef 100644
--- a/net/ipv6/ip6_tunnel.c
+++ b/net/ipv6/ip6_tunnel.c
@@ -928,24 +928,28 @@ ip6_tnl_addr_conflict(const struct ip6_tnl *t, const struct ipv6hdr *hdr)
 	return ipv6_addr_equal(&t->parms.raddr, &hdr->saddr);
 }
 
-int ip6_tnl_xmit_ctl(struct ip6_tnl *t)
+int ip6_tnl_xmit_ctl(struct ip6_tnl *t,
+		     const struct in6_addr *laddr,
+		     const struct in6_addr *raddr)
 {
 	struct __ip6_tnl_parm *p = &t->parms;
 	int ret = 0;
 	struct net *net = t->net;
 
-	if (p->flags & IP6_TNL_F_CAP_XMIT) {
+	if ((p->flags & IP6_TNL_F_CAP_XMIT) ||
+	    ((p->flags & IP6_TNL_F_CAP_PER_PACKET) &&
+	     (ip6_tnl_get_cap(t, laddr, raddr) & IP6_TNL_F_CAP_XMIT))) {
 		struct net_device *ldev = NULL;
 
 		rcu_read_lock();
 		if (p->link)
 			ldev = dev_get_by_index_rcu(net, p->link);
 
-		if (unlikely(!ipv6_chk_addr(net, &p->laddr, ldev, 0)))
+		if (unlikely(!ipv6_chk_addr(net, laddr, ldev, 0)))
 			pr_warn("%s xmit: Local address not yet configured!\n",
 				p->name);
-		else if (!ipv6_addr_is_multicast(&p->raddr) &&
-			 unlikely(ipv6_chk_addr(net, &p->raddr, NULL, 0)))
+		else if (!ipv6_addr_is_multicast(raddr) &&
+			 unlikely(ipv6_chk_addr(net, raddr, NULL, 0)))
 			pr_warn("%s xmit: Routing loop! Remote address found on this node!\n",
 				p->name);
 		else
@@ -1018,6 +1022,10 @@ static int ip6_tnl_xmit2(struct sk_buff *skb,
 		neigh_release(neigh);
 	} else if (!fl6->flowi6_mark)
 		dst = ip6_tnl_dst_check(t);
+
+	if (!ip6_tnl_xmit_ctl(t, &fl6->saddr, &fl6->daddr))
+		goto tx_err_link_failure;
+
 	if (!dst) {
 		ndst = ip6_route_output(net, NULL, fl6);
 
@@ -1128,8 +1136,7 @@ ip4ip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev)
 	int err;
 
 	tproto = ACCESS_ONCE(t->parms.proto);
-	if ((tproto != IPPROTO_IPIP && tproto != 0) ||
-	    !ip6_tnl_xmit_ctl(t))
+	if (tproto != IPPROTO_IPIP && tproto != 0)
 		return -1;
 
 	if (!(t->parms.flags & IP6_TNL_F_IGN_ENCAP_LIMIT))
@@ -1173,7 +1180,7 @@ ip6ip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	tproto = ACCESS_ONCE(t->parms.proto);
 	if ((tproto != IPPROTO_IPV6 && tproto != 0) ||
-	    !ip6_tnl_xmit_ctl(t) || ip6_tnl_addr_conflict(t, ipv6h))
+	    ip6_tnl_addr_conflict(t, ipv6h))
 		return -1;
 
 	offset = ip6_tnl_parse_tlv_enc_lim(skb, skb_network_header(skb));
* Unmerged path net/ipv6/ip6_vti.c
