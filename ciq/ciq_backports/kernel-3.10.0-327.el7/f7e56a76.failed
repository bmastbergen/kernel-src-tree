tcp: make local functions static

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author stephen hemminger <stephen@networkplumber.org>
commit f7e56a76acf642d21a8e7bd587e270ae7addc4db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/f7e56a76.failed

The following are only used in one file:
  tcp_connect_init
  tcp_set_rto

	Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f7e56a76acf642d21a8e7bd587e270ae7addc4db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/tcp.h
diff --cc include/net/tcp.h
index 0e2c3b74c450,56fc366da6d5..000000000000
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@@ -450,24 -452,22 +450,23 @@@ extern const u8 *tcp_parse_md5sig_optio
   *	TCP v4 functions exported for the inet6 API
   */
  
 -void tcp_v4_send_check(struct sock *sk, struct sk_buff *skb);
 -int tcp_v4_conn_request(struct sock *sk, struct sk_buff *skb);
 -struct sock *tcp_create_openreq_child(struct sock *sk,
 -				      struct request_sock *req,
 -				      struct sk_buff *skb);
 -struct sock *tcp_v4_syn_recv_sock(struct sock *sk, struct sk_buff *skb,
 -				  struct request_sock *req,
 -				  struct dst_entry *dst);
 -int tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb);
 -int tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len);
 -int tcp_connect(struct sock *sk);
 -struct sk_buff *tcp_make_synack(struct sock *sk, struct dst_entry *dst,
 -				struct request_sock *req,
 -				struct tcp_fastopen_cookie *foc);
 -int tcp_disconnect(struct sock *sk, int flags);
 +extern void tcp_v4_send_check(struct sock *sk, struct sk_buff *skb);
 +extern int tcp_v4_conn_request(struct sock *sk, struct sk_buff *skb);
 +extern struct sock * tcp_create_openreq_child(struct sock *sk,
 +					      struct request_sock *req,
 +					      struct sk_buff *skb);
 +extern struct sock * tcp_v4_syn_recv_sock(struct sock *sk, struct sk_buff *skb,
 +					  struct request_sock *req,
 +					  struct dst_entry *dst);
 +extern int tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb);
 +extern int tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr,
 +			  int addr_len);
 +extern int tcp_connect(struct sock *sk);
 +extern struct sk_buff * tcp_make_synack(struct sock *sk, struct dst_entry *dst,
 +					struct request_sock *req,
 +					struct tcp_fastopen_cookie *foc);
 +extern int tcp_disconnect(struct sock *sk, int flags);
  
- void tcp_connect_init(struct sock *sk);
  void tcp_finish_connect(struct sock *sk, struct sk_buff *skb);
  int tcp_send_rcvq(struct sock *sk, struct msghdr *msg, size_t size);
  void inet_sk_rx_dst_set(struct sock *sk, const struct sk_buff *skb);
@@@ -625,8 -622,6 +624,11 @@@ static inline u32 __tcp_set_rto(const s
  	return (tp->srtt >> 3) + tp->rttvar;
  }
  
++<<<<<<< HEAD
 +extern void tcp_set_rto(struct sock *sk);
 +
++=======
++>>>>>>> f7e56a76acf6 (tcp: make local functions static)
  static inline void __tcp_fast_path_on(struct tcp_sock *tp, u32 snd_wnd)
  {
  	tp->pred_flags = htonl((tp->tcp_header_len << 26) |
* Unmerged path include/net/tcp.h
diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
index b4e792f990d1..99664457a3ea 100644
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -760,7 +760,7 @@ static void tcp_update_pacing_rate(struct sock *sk)
 /* Calculate rto without backoff.  This is the second half of Van Jacobson's
  * routine referred to above.
  */
-void tcp_set_rto(struct sock *sk)
+static void tcp_set_rto(struct sock *sk)
 {
 	const struct tcp_sock *tp = tcp_sk(sk);
 	/* Old crap is replaced with new one. 8)
diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c
index bee442e8df3f..752abd096d75 100644
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@ -2784,7 +2784,7 @@ struct sk_buff *tcp_make_synack(struct sock *sk, struct dst_entry *dst,
 EXPORT_SYMBOL(tcp_make_synack);
 
 /* Do all connect socket setups that can be done AF independent. */
-void tcp_connect_init(struct sock *sk)
+static void tcp_connect_init(struct sock *sk)
 {
 	const struct dst_entry *dst = __sk_dst_get(sk);
 	struct tcp_sock *tp = tcp_sk(sk);
