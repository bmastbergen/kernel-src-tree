netns: notify netns id events

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Nicolas Dichtel <nicolas.dichtel@6wind.com>
commit 9a9634545c7051f567096117d417e9c3be24706d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/9a963454.failed

With this patch, netns ids that are created and deleted are advertised into the
group RTNLGRP_NSID.

Because callers of rtnl_net_notifyid() already know the id of the peer, there is
no need to call __peernet2id() in rtnl_net_fill().

	Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9a9634545c7051f567096117d417e9c3be24706d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/rtnetlink.h
#	net/core/net_namespace.c
diff --cc include/uapi/linux/rtnetlink.h
index d072a7ae7d4b,974db03f7b1a..000000000000
--- a/include/uapi/linux/rtnetlink.h
+++ b/include/uapi/linux/rtnetlink.h
@@@ -132,6 -132,13 +132,16 @@@ enum 
  	RTM_GETMDB = 86,
  #define RTM_GETMDB RTM_GETMDB
  
++<<<<<<< HEAD
++=======
+ 	RTM_NEWNSID = 88,
+ #define RTM_NEWNSID RTM_NEWNSID
+ 	RTM_DELNSID = 89,
+ #define RTM_DELNSID RTM_DELNSID
+ 	RTM_GETNSID = 90,
+ #define RTM_GETNSID RTM_GETNSID
+ 
++>>>>>>> 9a9634545c70 (netns: notify netns id events)
  	__RTM_MAX,
  #define RTM_MAX		(((__RTM_MAX + 3) & ~3) - 1)
  };
@@@ -623,6 -635,10 +633,13 @@@ enum rtnetlink_groups 
  #define RTNLGRP_IPV6_NETCONF	RTNLGRP_IPV6_NETCONF
  	RTNLGRP_MDB,
  #define RTNLGRP_MDB		RTNLGRP_MDB
++<<<<<<< HEAD
++=======
+ 	RTNLGRP_MPLS_ROUTE,
+ #define RTNLGRP_MPLS_ROUTE	RTNLGRP_MPLS_ROUTE
+ 	RTNLGRP_NSID,
+ #define RTNLGRP_NSID		RTNLGRP_NSID
++>>>>>>> 9a9634545c70 (netns: notify netns id events)
  	__RTNLGRP_MAX
  };
  #define RTNLGRP_MAX	(__RTNLGRP_MAX - 1)
diff --cc net/core/net_namespace.c
index 4cf6699528f0,b3b5f22f0e90..000000000000
--- a/net/core/net_namespace.c
+++ b/net/core/net_namespace.c
@@@ -144,6 -148,86 +144,89 @@@ static void ops_free_list(const struct 
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void rtnl_net_notifyid(struct net *net, struct net *peer, int cmd,
+ 			      int id);
+ static int alloc_netid(struct net *net, struct net *peer, int reqid)
+ {
+ 	int min = 0, max = 0, id;
+ 
+ 	ASSERT_RTNL();
+ 
+ 	if (reqid >= 0) {
+ 		min = reqid;
+ 		max = reqid + 1;
+ 	}
+ 
+ 	id = idr_alloc(&net->netns_ids, peer, min, max, GFP_KERNEL);
+ 	if (id >= 0)
+ 		rtnl_net_notifyid(net, peer, RTM_NEWNSID, id);
+ 
+ 	return id;
+ }
+ 
+ /* This function is used by idr_for_each(). If net is equal to peer, the
+  * function returns the id so that idr_for_each() stops. Because we cannot
+  * returns the id 0 (idr_for_each() will not stop), we return the magic value
+  * NET_ID_ZERO (-1) for it.
+  */
+ #define NET_ID_ZERO -1
+ static int net_eq_idr(int id, void *net, void *peer)
+ {
+ 	if (net_eq(net, peer))
+ 		return id ? : NET_ID_ZERO;
+ 	return 0;
+ }
+ 
+ static int __peernet2id(struct net *net, struct net *peer, bool alloc)
+ {
+ 	int id = idr_for_each(&net->netns_ids, net_eq_idr, peer);
+ 
+ 	ASSERT_RTNL();
+ 
+ 	/* Magic value for id 0. */
+ 	if (id == NET_ID_ZERO)
+ 		return 0;
+ 	if (id > 0)
+ 		return id;
+ 
+ 	if (alloc)
+ 		return alloc_netid(net, peer, -1);
+ 
+ 	return -ENOENT;
+ }
+ 
+ /* This function returns the id of a peer netns. If no id is assigned, one will
+  * be allocated and returned.
+  */
+ int peernet2id(struct net *net, struct net *peer)
+ {
+ 	bool alloc = atomic_read(&peer->count) == 0 ? false : true;
+ 	int id;
+ 
+ 	id = __peernet2id(net, peer, alloc);
+ 	return id >= 0 ? id : NETNSA_NSID_NOT_ASSIGNED;
+ }
+ EXPORT_SYMBOL(peernet2id);
+ 
+ struct net *get_net_ns_by_id(struct net *net, int id)
+ {
+ 	struct net *peer;
+ 
+ 	if (id < 0)
+ 		return NULL;
+ 
+ 	rcu_read_lock();
+ 	peer = idr_find(&net->netns_ids, id);
+ 	if (peer)
+ 		get_net(peer);
+ 	rcu_read_unlock();
+ 
+ 	return peer;
+ }
+ 
++>>>>>>> 9a9634545c70 (netns: notify netns id events)
  /*
   * setup_net runs the initializers for the network namespace object.
   */
@@@ -288,6 -362,16 +371,19 @@@ static void cleanup_net(struct work_str
  	list_for_each_entry(net, &net_kill_list, cleanup_list) {
  		list_del_rcu(&net->list);
  		list_add_tail(&net->exit_list, &net_exit_list);
++<<<<<<< HEAD
++=======
+ 		for_each_net(tmp) {
+ 			int id = __peernet2id(tmp, net, false);
+ 
+ 			if (id >= 0) {
+ 				rtnl_net_notifyid(tmp, net, RTM_DELNSID, id);
+ 				idr_remove(&tmp->netns_ids, id);
+ 			}
+ 		}
+ 		idr_destroy(&net->netns_ids);
+ 
++>>>>>>> 9a9634545c70 (netns: notify netns id events)
  	}
  	rtnl_unlock();
  
@@@ -397,6 -487,158 +493,161 @@@ static struct pernet_operations __net_i
  	.exit = net_ns_net_exit,
  };
  
++<<<<<<< HEAD
++=======
+ static struct nla_policy rtnl_net_policy[NETNSA_MAX + 1] = {
+ 	[NETNSA_NONE]		= { .type = NLA_UNSPEC },
+ 	[NETNSA_NSID]		= { .type = NLA_S32 },
+ 	[NETNSA_PID]		= { .type = NLA_U32 },
+ 	[NETNSA_FD]		= { .type = NLA_U32 },
+ };
+ 
+ static int rtnl_net_newid(struct sk_buff *skb, struct nlmsghdr *nlh)
+ {
+ 	struct net *net = sock_net(skb->sk);
+ 	struct nlattr *tb[NETNSA_MAX + 1];
+ 	struct net *peer;
+ 	int nsid, err;
+ 
+ 	err = nlmsg_parse(nlh, sizeof(struct rtgenmsg), tb, NETNSA_MAX,
+ 			  rtnl_net_policy);
+ 	if (err < 0)
+ 		return err;
+ 	if (!tb[NETNSA_NSID])
+ 		return -EINVAL;
+ 	nsid = nla_get_s32(tb[NETNSA_NSID]);
+ 
+ 	if (tb[NETNSA_PID])
+ 		peer = get_net_ns_by_pid(nla_get_u32(tb[NETNSA_PID]));
+ 	else if (tb[NETNSA_FD])
+ 		peer = get_net_ns_by_fd(nla_get_u32(tb[NETNSA_FD]));
+ 	else
+ 		return -EINVAL;
+ 	if (IS_ERR(peer))
+ 		return PTR_ERR(peer);
+ 
+ 	if (__peernet2id(net, peer, false) >= 0) {
+ 		err = -EEXIST;
+ 		goto out;
+ 	}
+ 
+ 	err = alloc_netid(net, peer, nsid);
+ 	if (err > 0)
+ 		err = 0;
+ out:
+ 	put_net(peer);
+ 	return err;
+ }
+ 
+ static int rtnl_net_get_size(void)
+ {
+ 	return NLMSG_ALIGN(sizeof(struct rtgenmsg))
+ 	       + nla_total_size(sizeof(s32)) /* NETNSA_NSID */
+ 	       ;
+ }
+ 
+ static int rtnl_net_fill(struct sk_buff *skb, u32 portid, u32 seq, int flags,
+ 			 int cmd, struct net *net, struct net *peer,
+ 			 int nsid)
+ {
+ 	struct nlmsghdr *nlh;
+ 	struct rtgenmsg *rth;
+ 	int id;
+ 
+ 	ASSERT_RTNL();
+ 
+ 	nlh = nlmsg_put(skb, portid, seq, cmd, sizeof(*rth), flags);
+ 	if (!nlh)
+ 		return -EMSGSIZE;
+ 
+ 	rth = nlmsg_data(nlh);
+ 	rth->rtgen_family = AF_UNSPEC;
+ 
+ 	if (nsid >= 0) {
+ 		id = nsid;
+ 	} else {
+ 		id = __peernet2id(net, peer, false);
+ 		if  (id < 0)
+ 			id = NETNSA_NSID_NOT_ASSIGNED;
+ 	}
+ 	if (nla_put_s32(skb, NETNSA_NSID, id))
+ 		goto nla_put_failure;
+ 
+ 	nlmsg_end(skb, nlh);
+ 	return 0;
+ 
+ nla_put_failure:
+ 	nlmsg_cancel(skb, nlh);
+ 	return -EMSGSIZE;
+ }
+ 
+ static int rtnl_net_getid(struct sk_buff *skb, struct nlmsghdr *nlh)
+ {
+ 	struct net *net = sock_net(skb->sk);
+ 	struct nlattr *tb[NETNSA_MAX + 1];
+ 	struct sk_buff *msg;
+ 	struct net *peer;
+ 	int err;
+ 
+ 	err = nlmsg_parse(nlh, sizeof(struct rtgenmsg), tb, NETNSA_MAX,
+ 			  rtnl_net_policy);
+ 	if (err < 0)
+ 		return err;
+ 	if (tb[NETNSA_PID])
+ 		peer = get_net_ns_by_pid(nla_get_u32(tb[NETNSA_PID]));
+ 	else if (tb[NETNSA_FD])
+ 		peer = get_net_ns_by_fd(nla_get_u32(tb[NETNSA_FD]));
+ 	else
+ 		return -EINVAL;
+ 
+ 	if (IS_ERR(peer))
+ 		return PTR_ERR(peer);
+ 
+ 	msg = nlmsg_new(rtnl_net_get_size(), GFP_KERNEL);
+ 	if (!msg) {
+ 		err = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	err = rtnl_net_fill(msg, NETLINK_CB(skb).portid, nlh->nlmsg_seq, 0,
+ 			    RTM_GETNSID, net, peer, -1);
+ 	if (err < 0)
+ 		goto err_out;
+ 
+ 	err = rtnl_unicast(msg, net, NETLINK_CB(skb).portid);
+ 	goto out;
+ 
+ err_out:
+ 	nlmsg_free(msg);
+ out:
+ 	put_net(peer);
+ 	return err;
+ }
+ 
+ static void rtnl_net_notifyid(struct net *net, struct net *peer, int cmd,
+ 			      int id)
+ {
+ 	struct sk_buff *msg;
+ 	int err = -ENOMEM;
+ 
+ 	msg = nlmsg_new(rtnl_net_get_size(), GFP_KERNEL);
+ 	if (!msg)
+ 		goto out;
+ 
+ 	err = rtnl_net_fill(msg, 0, 0, 0, cmd, net, peer, id);
+ 	if (err < 0)
+ 		goto err_out;
+ 
+ 	rtnl_notify(msg, net, 0, RTNLGRP_NSID, NULL, 0);
+ 	return;
+ 
+ err_out:
+ 	nlmsg_free(msg);
+ out:
+ 	rtnl_set_sk_err(net, RTNLGRP_NSID, err);
+ }
+ 
++>>>>>>> 9a9634545c70 (netns: notify netns id events)
  static int __init net_ns_init(void)
  {
  	struct net_generic *ng;
* Unmerged path include/uapi/linux/rtnetlink.h
* Unmerged path net/core/net_namespace.c
