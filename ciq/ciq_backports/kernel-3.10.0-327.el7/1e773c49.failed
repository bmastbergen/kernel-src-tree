xfs: introduce xfs_bulkstat_ag_ichunk

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Jie Liu <jeff.liu@oracle.com>
commit 1e773c4989d2dfe08332b4c18f7e1d7ad633015c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/1e773c49.failed

Introduce xfs_bulkstat_ag_ichunk() to process inodes in chunk with a
pointer to a formatter function that will iget the inode and fill in
the appropriate structure.

Refactor xfs_bulkstat() with it.

	Signed-off-by: Jie Liu <jeff.liu@oracle.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit 1e773c4989d2dfe08332b4c18f7e1d7ad633015c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_itable.c
diff --cc fs/xfs/xfs_itable.c
index 8b51c4e93b7b,f71be9c68017..000000000000
--- a/fs/xfs/xfs_itable.c
+++ b/fs/xfs/xfs_itable.c
@@@ -421,57 -489,20 +491,51 @@@ xfs_bulkstat
  		irbufend = irbp;
  		for (irbp = irbuf;
  		     irbp < irbufend && XFS_BULKSTAT_UBLEFT(ubleft); irbp++) {
- 			/*
- 			 * Now process this chunk of inodes.
- 			 */
- 			for (agino = irbp->ir_startino, chunkidx = clustidx = 0;
- 			     XFS_BULKSTAT_UBLEFT(ubleft) &&
- 				irbp->ir_freecount < XFS_INODES_PER_CHUNK;
- 			     chunkidx++, clustidx++, agino++) {
- 				ASSERT(chunkidx < XFS_INODES_PER_CHUNK);
- 
- 				ino = XFS_AGINO_TO_INO(mp, agno, agino);
- 				/*
- 				 * Skip if this inode is free.
- 				 */
- 				if (XFS_INOBT_MASK(chunkidx) & irbp->ir_free) {
- 					lastino = ino;
- 					continue;
- 				}
- 				/*
- 				 * Count used inodes as free so we can tell
- 				 * when the chunk is used up.
- 				 */
- 				irbp->ir_freecount++;
+ 			struct xfs_bulkstat_agichunk ac;
+ 
+ 			ac.ac_lastino = lastino;
+ 			ac.ac_ubuffer = &ubuffer;
+ 			ac.ac_ubleft = ubleft;
+ 			ac.ac_ubelem = ubelem;
+ 			error = xfs_bulkstat_ag_ichunk(mp, agno, irbp,
+ 					formatter, statstruct_size, &ac);
+ 			if (error)
+ 				rval = error;
  
++<<<<<<< HEAD
 +				/*
 +				 * Get the inode and fill in a single buffer.
 +				 */
 +				ubused = statstruct_size;
 +				error = formatter(mp, ino, ubufp, ubleft,
 +						  &ubused, &fmterror);
 +				if (fmterror == BULKSTAT_RV_NOTHING) {
 +					if (error && error != ENOENT &&
 +						error != EINVAL) {
 +						ubleft = 0;
 +						rval = error;
 +						break;
 +					}
 +					lastino = ino;
 +					continue;
 +				}
 +				if (fmterror == BULKSTAT_RV_GIVEUP) {
 +					ubleft = 0;
 +					ASSERT(error);
 +					rval = error;
 +					break;
 +				}
 +				if (ubufp)
 +					ubufp += ubused;
 +				ubleft -= ubused;
 +				ubelem++;
 +				lastino = ino;
 +			}
++=======
+ 			lastino = ac.ac_lastino;
+ 			ubleft = ac.ac_ubleft;
+ 			ubelem = ac.ac_ubelem;
++>>>>>>> 1e773c4989d2 (xfs: introduce xfs_bulkstat_ag_ichunk)
  
  			cond_resched();
  		}
* Unmerged path fs/xfs/xfs_itable.c
diff --git a/fs/xfs/xfs_itable.h b/fs/xfs/xfs_itable.h
index 97295d91d170..0133d112f413 100644
--- a/fs/xfs/xfs_itable.h
+++ b/fs/xfs/xfs_itable.h
@@ -30,6 +30,22 @@ typedef int (*bulkstat_one_pf)(struct xfs_mount	*mp,
 			       int		*ubused,
 			       int		*stat);
 
+struct xfs_bulkstat_agichunk {
+	xfs_ino_t	ac_lastino;	/* last inode returned */
+	char		__user **ac_ubuffer;/* pointer into user's buffer */
+	int		ac_ubleft;	/* bytes left in user's buffer */
+	int		ac_ubelem;	/* spaces used in user's buffer */
+};
+
+int
+xfs_bulkstat_ag_ichunk(
+	struct xfs_mount		*mp,
+	xfs_agnumber_t			agno,
+	struct xfs_inobt_rec_incore	*irbp,
+	bulkstat_one_pf			formatter,
+	size_t				statstruct_size,
+	struct xfs_bulkstat_agichunk	*acp);
+
 /*
  * Values for stat return value.
  */
