tcp: refactor undo functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Yuchung Cheng <ycheng@google.com>
commit 6a63df46a7363833a0dc0c431027f522b3487972
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/6a63df46.failed

Refactor and relocate various functions or variables to prepare the
undo fix.  Remove some unused function arguments. Rename tcp_undo_cwr
to tcp_undo_cwnd_reduction to be consistent with the rest of
CWR related function names.

	Signed-off-by: Yuchung Cheng <ycheng@google.com>
	Acked-by: Neal Cardwell <ncardwell@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6a63df46a7363833a0dc0c431027f522b3487972)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_input.c
diff --cc net/ipv4/tcp_input.c
index a5777ec6c24c,fcb668d1860d..000000000000
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@@ -2376,34 -2329,33 +2390,64 @@@ static void tcp_try_undo_dsack(struct s
  	}
  }
  
++<<<<<<< HEAD
 +/* Undo during fast recovery after partial ACK. */
 +
 +static int tcp_try_undo_partial(struct sock *sk, int acked)
 +{
 +	struct tcp_sock *tp = tcp_sk(sk);
 +	/* Partial ACK arrived. Force Hoe's retransmit. */
 +	int failed = tcp_is_reno(tp) || (tcp_fackets_out(tp) > tp->reordering);
 +
 +	if (tcp_may_undo(tp)) {
 +		/* Plain luck! Hole if filled with delayed
 +		 * packet, rather than with a retransmit.
 +		 */
 +		if (!tcp_any_retrans_done(sk))
 +			tp->retrans_stamp = 0;
 +
 +		tcp_update_reordering(sk, tcp_fackets_out(tp) + acked, 1);
 +
 +		DBGUNDO(sk, "Hoe");
 +		tcp_undo_cwr(sk, false);
 +		NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPPARTIALUNDO);
 +
 +		/* So... Do not make Hoe's retransmit yet.
 +		 * If the first packet was delayed, the rest
 +		 * ones are most probably delayed as well.
 +		 */
 +		failed = 0;
 +	}
 +	return failed;
++=======
+ /* We can clear retrans_stamp when there are no retransmissions in the
+  * window. It would seem that it is trivially available for us in
+  * tp->retrans_out, however, that kind of assumptions doesn't consider
+  * what will happen if errors occur when sending retransmission for the
+  * second time. ...It could the that such segment has only
+  * TCPCB_EVER_RETRANS set at the present time. It seems that checking
+  * the head skb is enough except for some reneging corner cases that
+  * are not worth the effort.
+  *
+  * Main reason for all this complexity is the fact that connection dying
+  * time now depends on the validity of the retrans_stamp, in particular,
+  * that successive retransmissions of a segment must not advance
+  * retrans_stamp under any conditions.
+  */
+ static bool tcp_any_retrans_done(const struct sock *sk)
+ {
+ 	const struct tcp_sock *tp = tcp_sk(sk);
+ 	struct sk_buff *skb;
+ 
+ 	if (tp->retrans_out)
+ 		return true;
+ 
+ 	skb = tcp_write_queue_head(sk);
+ 	if (unlikely(skb && TCP_SKB_CB(skb)->sacked & TCPCB_EVER_RETRANS))
+ 		return true;
+ 
+ 	return false;
++>>>>>>> 6a63df46a736 (tcp: refactor undo functions)
  }
  
  /* Undo during loss recovery after partial ACK or using F-RTO. */
* Unmerged path net/ipv4/tcp_input.c
