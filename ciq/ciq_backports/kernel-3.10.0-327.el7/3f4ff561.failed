regmap: rbtree: Make cache_present bitmap per node

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Lars-Peter Clausen <lars@metafoo.de>
commit 3f4ff561bc88b074d5e868dde4012d89cbb06c87
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/3f4ff561.failed

With devices which have a dense and small register map but placed at a large
offset the global cache_present bitmap imposes a huge memory overhead. Making
the cache_present per rbtree node avoids the issue and easily reduces the memory
footprint by a factor of ten. For devices with a more sparse map or without a
large base register offset the memory usage might increase slightly by a few
bytes, but not significantly. E.g. for a device which has ~50 registers at
offset 0x4000 the memory footprint of the register cache goes down form 2496
bytes to 175 bytes.

Moving the bitmap to a per node basis means that the handling of the bitmap is
now cache implementation specific and can no longer be managed by the core. The
regcache_sync_block() function is extended by a additional parameter so that the
cache implementation can tell the core which registers in the block are set and
which are not. The parameter is optional and if NULL the core assumes that all
registers are set. The rbtree cache also needs to implement its own drop
callback instead of relying on the core to handle this.

	Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
	Signed-off-by: Mark Brown <broonie@linaro.org>
(cherry picked from commit 3f4ff561bc88b074d5e868dde4012d89cbb06c87)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/regmap/internal.h
#	drivers/base/regmap/regcache-rbtree.c
diff --cc drivers/base/regmap/internal.h
index b33a4ff67adf,57f777835d97..000000000000
--- a/drivers/base/regmap/internal.h
+++ b/drivers/base/regmap/internal.h
@@@ -209,16 -216,6 +207,19 @@@ unsigned int regcache_get_val(struct re
  bool regcache_set_val(struct regmap *map, void *base, unsigned int idx,
  		      unsigned int val);
  int regcache_lookup_reg(struct regmap *map, unsigned int reg);
++<<<<<<< HEAD
 +int regcache_set_reg_present(struct regmap *map, unsigned int reg);
 +
 +static inline bool regcache_reg_present(struct regmap *map, unsigned int reg)
 +{
 +	if (!map->cache_present)
 +		return true;
 +	if (reg > map->cache_present_nbits)
 +		return false;
 +	return map->cache_present[BIT_WORD(reg)] & BIT_MASK(reg);
 +}
++=======
++>>>>>>> 3f4ff561bc88 (regmap: rbtree: Make cache_present bitmap per node)
  
  int _regmap_raw_write(struct regmap *map, unsigned int reg,
  		      const void *val, size_t val_len, bool async);
diff --cc drivers/base/regmap/regcache-rbtree.c
index 1c02c0706128,e9a2261a383b..000000000000
--- a/drivers/base/regmap/regcache-rbtree.c
+++ b/drivers/base/regmap/regcache-rbtree.c
@@@ -311,6 -326,57 +326,60 @@@ static int regcache_rbtree_insert_to_bl
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static struct regcache_rbtree_node *
+ regcache_rbtree_node_alloc(struct regmap *map, unsigned int reg)
+ {
+ 	struct regcache_rbtree_node *rbnode;
+ 	const struct regmap_range *range;
+ 	int i;
+ 
+ 	rbnode = kzalloc(sizeof(*rbnode), GFP_KERNEL);
+ 	if (!rbnode)
+ 		return NULL;
+ 
+ 	/* If there is a read table then use it to guess at an allocation */
+ 	if (map->rd_table) {
+ 		for (i = 0; i < map->rd_table->n_yes_ranges; i++) {
+ 			if (regmap_reg_in_range(reg,
+ 						&map->rd_table->yes_ranges[i]))
+ 				break;
+ 		}
+ 
+ 		if (i != map->rd_table->n_yes_ranges) {
+ 			range = &map->rd_table->yes_ranges[i];
+ 			rbnode->blklen = (range->range_max - range->range_min) /
+ 				map->reg_stride	+ 1;
+ 			rbnode->base_reg = range->range_min;
+ 		}
+ 	}
+ 
+ 	if (!rbnode->blklen) {
+ 		rbnode->blklen = sizeof(*rbnode);
+ 		rbnode->base_reg = reg;
+ 	}
+ 
+ 	rbnode->block = kmalloc(rbnode->blklen * map->cache_word_size,
+ 				GFP_KERNEL);
+ 	if (!rbnode->block)
+ 		goto err_free;
+ 
+ 	rbnode->cache_present = kzalloc(BITS_TO_LONGS(rbnode->blklen) *
+ 		sizeof(*rbnode->cache_present), GFP_KERNEL);
+ 	if (!rbnode->cache_present)
+ 		goto err_free_block;
+ 
+ 	return rbnode;
+ 
+ err_free_block:
+ 	kfree(rbnode->block);
+ err_free:
+ 	kfree(rbnode);
+ 	return NULL;
+ }
+ 
++>>>>>>> 3f4ff561bc88 (regmap: rbtree: Make cache_present bitmap per node)
  static int regcache_rbtree_write(struct regmap *map, unsigned int reg,
  				 unsigned int value)
  {
@@@ -424,8 -481,9 +489,14 @@@ static int regcache_rbtree_sync(struct 
  		else
  			end = rbnode->blklen;
  
++<<<<<<< HEAD
 +		ret = regcache_sync_block(map, rbnode->block, rbnode->base_reg,
 +					  base, end);
++=======
+ 		ret = regcache_sync_block(map, rbnode->block,
+ 					  rbnode->cache_present,
+ 					  rbnode->base_reg, start, end);
++>>>>>>> 3f4ff561bc88 (regmap: rbtree: Make cache_present bitmap per node)
  		if (ret != 0)
  			return ret;
  	}
* Unmerged path drivers/base/regmap/internal.h
* Unmerged path drivers/base/regmap/regcache-rbtree.c
diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index 03be2d066007..4c89da3abb50 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -121,8 +121,6 @@ int regcache_init(struct regmap *map, const struct regmap_config *config)
 	map->reg_defaults_raw = config->reg_defaults_raw;
 	map->cache_word_size = DIV_ROUND_UP(config->val_bits, 8);
 	map->cache_size_raw = map->cache_word_size * config->num_reg_defaults_raw;
-	map->cache_present = NULL;
-	map->cache_present_nbits = 0;
 
 	map->cache = NULL;
 	map->cache_ops = cache_types[i];
@@ -181,7 +179,6 @@ void regcache_exit(struct regmap *map)
 
 	BUG_ON(!map->cache_ops);
 
-	kfree(map->cache_present);
 	kfree(map->reg_defaults);
 	if (map->cache_free)
 		kfree(map->reg_defaults_raw);
@@ -372,22 +369,16 @@ EXPORT_SYMBOL_GPL(regcache_sync_region);
 int regcache_drop_region(struct regmap *map, unsigned int min,
 			 unsigned int max)
 {
-	unsigned int reg;
 	int ret = 0;
 
-	if (!map->cache_present && !(map->cache_ops && map->cache_ops->drop))
+	if (!map->cache_ops || !map->cache_ops->drop)
 		return -EINVAL;
 
 	map->lock(map);
 
 	trace_regcache_drop_region(map->dev, min, max);
 
-	if (map->cache_present)
-		for (reg = min; reg < max + 1; reg++)
-			clear_bit(reg, map->cache_present);
-
-	if (map->cache_ops && map->cache_ops->drop)
-		ret = map->cache_ops->drop(map, min, max);
+	ret = map->cache_ops->drop(map, min, max);
 
 	map->unlock(map);
 
@@ -455,42 +446,6 @@ void regcache_cache_bypass(struct regmap *map, bool enable)
 }
 EXPORT_SYMBOL_GPL(regcache_cache_bypass);
 
-int regcache_set_reg_present(struct regmap *map, unsigned int reg)
-{
-	unsigned long *cache_present;
-	unsigned int cache_present_size;
-	unsigned int nregs;
-	int i;
-
-	nregs = reg + 1;
-	cache_present_size = BITS_TO_LONGS(nregs);
-	cache_present_size *= sizeof(long);
-
-	if (!map->cache_present) {
-		cache_present = kmalloc(cache_present_size, GFP_KERNEL);
-		if (!cache_present)
-			return -ENOMEM;
-		bitmap_zero(cache_present, nregs);
-		map->cache_present = cache_present;
-		map->cache_present_nbits = nregs;
-	}
-
-	if (nregs > map->cache_present_nbits) {
-		cache_present = krealloc(map->cache_present,
-					 cache_present_size, GFP_KERNEL);
-		if (!cache_present)
-			return -ENOMEM;
-		for (i = 0; i < nregs; i++)
-			if (i >= map->cache_present_nbits)
-				clear_bit(i, cache_present);
-		map->cache_present = cache_present;
-		map->cache_present_nbits = nregs;
-	}
-
-	set_bit(reg, map->cache_present);
-	return 0;
-}
-
 bool regcache_set_val(struct regmap *map, void *base, unsigned int idx,
 		      unsigned int val)
 {
@@ -582,7 +537,16 @@ int regcache_lookup_reg(struct regmap *map, unsigned int reg)
 		return -ENOENT;
 }
 
+static bool regcache_reg_present(unsigned long *cache_present, unsigned int idx)
+{
+	if (!cache_present)
+		return true;
+
+	return test_bit(idx, cache_present);
+}
+
 static int regcache_sync_block_single(struct regmap *map, void *block,
+				      unsigned long *cache_present,
 				      unsigned int block_base,
 				      unsigned int start, unsigned int end)
 {
@@ -592,7 +556,7 @@ static int regcache_sync_block_single(struct regmap *map, void *block,
 	for (i = start; i < end; i++) {
 		regtmp = block_base + (i * map->reg_stride);
 
-		if (!regcache_reg_present(map, regtmp))
+		if (!regcache_reg_present(cache_present, i))
 			continue;
 
 		val = regcache_get_val(map, block, i);
@@ -643,6 +607,7 @@ static int regcache_sync_block_raw_flush(struct regmap *map, const void **data,
 }
 
 static int regcache_sync_block_raw(struct regmap *map, void *block,
+			    unsigned long *cache_present,
 			    unsigned int block_base, unsigned int start,
 			    unsigned int end)
 {
@@ -655,7 +620,7 @@ static int regcache_sync_block_raw(struct regmap *map, void *block,
 	for (i = start; i < end; i++) {
 		regtmp = block_base + (i * map->reg_stride);
 
-		if (!regcache_reg_present(map, regtmp)) {
+		if (!regcache_reg_present(cache_present, i)) {
 			ret = regcache_sync_block_raw_flush(map, &data,
 							    base, regtmp);
 			if (ret != 0)
@@ -686,13 +651,14 @@ static int regcache_sync_block_raw(struct regmap *map, void *block,
 }
 
 int regcache_sync_block(struct regmap *map, void *block,
+			unsigned long *cache_present,
 			unsigned int block_base, unsigned int start,
 			unsigned int end)
 {
 	if (regmap_can_raw_write(map))
-		return regcache_sync_block_raw(map, block, block_base,
-					       start, end);
+		return regcache_sync_block_raw(map, block, cache_present,
+					       block_base, start, end);
 	else
-		return regcache_sync_block_single(map, block, block_base,
-						  start, end);
+		return regcache_sync_block_single(map, block, cache_present,
+						  block_base, start, end);
 }
