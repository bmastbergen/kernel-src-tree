ipv4: off-by-one in continuation handling in /proc/net/route

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Andy Whitcroft <apw@canonical.com>
commit 25b97c016b26039982daaa2c11d83979f93b71ab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/25b97c01.failed

When generating /proc/net/route we emit a header followed by a line for
each route.  When a short read is performed we will restart this process
based on the open file descriptor.  When calculating the start point we
fail to take into account that the 0th entry is the header.  This leads
us to skip the first entry when doing a continuation read.

This can be easily seen with the comparison below:

  while read l; do echo "$l"; done </proc/net/route >A
  cat /proc/net/route >B
  diff -bu A B | grep '^[+-]'

On my example machine I have approximatly 10KB of route output.  There we
see the very first non-title element is lost in the while read case,
and an entry around the 8K mark in the cat case:

  +wlan0 00000000 02021EAC 0003 0 0 400 00000000 0 0 0
  -tun1  00C0AC0A 00000000 0001 0 0 950 00C0FFFF 0 0 0

Fix up the off-by-one when reaquiring position on continuation.

Fixes: 8be33e955cb9 ("fib_trie: Fib walk rcu should take a tnode and key instead of a trie and a leaf")
BugLink: http://bugs.launchpad.net/bugs/1483440
	Acked-by: Alexander Duyck <alexander.h.duyck@redhat.com>
	Signed-off-by: Andy Whitcroft <apw@canonical.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 25b97c016b26039982daaa2c11d83979f93b71ab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/fib_trie.c
diff --cc net/ipv4/fib_trie.c
index 8be89b1a8b93,b0c6258ffb79..000000000000
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@@ -2299,22 -2442,37 +2299,34 @@@ struct fib_route_iter 
  	t_key	key;
  };
  
 -static struct key_vector *fib_route_get_idx(struct fib_route_iter *iter,
 -					    loff_t pos)
 +static struct tnode *fib_route_get_idx(struct fib_route_iter *iter, loff_t pos)
  {
 -	struct fib_table *tb = iter->main_tb;
 -	struct key_vector *l, **tp = &iter->tnode;
 -	struct trie *t;
 -	t_key key;
 +	struct tnode *l = NULL;
 +	struct trie *t = iter->main_trie;
  
 -	/* use cache location of next-to-find key */
 -	if (iter->pos > 0 && pos >= iter->pos) {
 +	/* use cache location of last found key */
 +	if (iter->pos > 0 && pos >= iter->pos && (l = fib_find_node(t, iter->key)))
  		pos -= iter->pos;
 -		key = iter->key;
 -	} else {
 -		t = (struct trie *)tb->tb_data;
 -		iter->tnode = t->kv;
 +	else {
  		iter->pos = 0;
 -		key = 0;
 +		l = trie_firstleaf(t);
  	}
  
 -	while ((l = leaf_walk_rcu(tp, key)) != NULL) {
 -		key = l->key + 1;
 +	while (l && pos-- > 0) {
  		iter->pos++;
++<<<<<<< HEAD
 +		l = trie_nextleaf(l);
++=======
+ 
+ 		if (--pos <= 0)
+ 			break;
+ 
+ 		l = NULL;
+ 
+ 		/* handle unlikely case of a key wrap */
+ 		if (!key)
+ 			break;
++>>>>>>> 25b97c016b26 (ipv4: off-by-one in continuation handling in /proc/net/route)
  	}
  
  	if (l)
* Unmerged path net/ipv4/fib_trie.c
