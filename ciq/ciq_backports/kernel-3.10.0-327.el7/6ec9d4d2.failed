IB/iser: Fix possible SQ overflow

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [infiniband] iser: Fix possible SQ overflow (Amir Vadai) [1164539]
Rebuild_FUZZ: 95.24%
commit-author Max Gurtovoy <maxg@mellanox.com>
commit 6ec9d4d2310e8fc54fc638e4454271d1fcaefa95
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/6ec9d4d2.failed

Fix a regression was introduced in commit 6df5a128f0fd ("IB/iser:
Suppress scsi command send completions").

The sig_count was wrongly set to be static variable, thus it is
possible that we won't reach to (sig_count % ISER_SIGNAL_BATCH) == 0
condition (due to races) and the send queue will be overflowed.

Instead keep sig_count per connection. We don't need it to be atomic
as we are safe under the iscsi session frwd_lock taken by libiscsi on
the queuecommand path.

Fixes: 6df5a128f0fd ("IB/iser: Suppress scsi command send completions")
	Signed-off-by: Max Gurtovoy <maxg@mellanox.com>
	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Roland Dreier <roland@purestorage.com>
(cherry picked from commit 6ec9d4d2310e8fc54fc638e4454271d1fcaefa95)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/iser/iscsi_iser.h
#	drivers/infiniband/ulp/iser/iser_initiator.c
diff --cc drivers/infiniband/ulp/iser/iscsi_iser.h
index 50ec84465483,8a5663dae87a..000000000000
--- a/drivers/infiniband/ulp/iser/iscsi_iser.h
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.h
@@@ -317,27 -431,98 +317,106 @@@ struct fast_reg_descriptor 
  	u8				  reg_indicators;
  };
  
++<<<<<<< HEAD
++=======
+ /**
+  * struct ib_conn - Infiniband related objects
+  *
+  * @cma_id:              rdma_cm connection maneger handle
+  * @qp:                  Connection Queue-pair
+  * @post_recv_buf_count: post receive counter
+  * @sig_count:           send work request signal count
+  * @rx_wr:               receive work request for batch posts
+  * @device:              reference to iser device
+  * @comp:                iser completion context
+  * @pi_support:          Indicate device T10-PI support
+  * @beacon:              beacon send wr to signal all flush errors were drained
+  * @flush_comp:          completes when all connection completions consumed
+  * @lock:                protects fmr/fastreg pool
+  * @union.fmr:
+  *     @pool:            FMR pool for fast registrations
+  *     @page_vec:        page vector to hold mapped commands pages
+  *                       used for registration
+  * @union.fastreg:
+  *     @pool:            Fast registration descriptors pool for fast
+  *                       registrations
+  *     @pool_size:       Size of pool
+  */
+ struct ib_conn {
+ 	struct rdma_cm_id           *cma_id;
+ 	struct ib_qp	            *qp;
+ 	int                          post_recv_buf_count;
+ 	u8                           sig_count;
+ 	struct ib_recv_wr	     rx_wr[ISER_MIN_POSTED_RX];
+ 	struct iser_device          *device;
+ 	struct iser_comp	    *comp;
+ 	bool			     pi_support;
+ 	struct ib_send_wr	     beacon;
+ 	struct completion	     flush_comp;
+ 	spinlock_t		     lock;
+ 	union {
+ 		struct {
+ 			struct ib_fmr_pool      *pool;
+ 			struct iser_page_vec	*page_vec;
+ 		} fmr;
+ 		struct {
+ 			struct list_head	 pool;
+ 			int			 pool_size;
+ 		} fastreg;
+ 	};
+ };
+ 
+ /**
+  * struct iser_conn - iSER connection context
+  *
+  * @ib_conn:          connection RDMA resources
+  * @iscsi_conn:       link to matching iscsi connection
+  * @ep:               transport handle
+  * @state:            connection logical state
+  * @qp_max_recv_dtos: maximum number of data outs, corresponds
+  *                    to max number of post recvs
+  * @qp_max_recv_dtos_mask: (qp_max_recv_dtos - 1)
+  * @min_posted_rx:    (qp_max_recv_dtos >> 2)
+  * @max_cmds:         maximum cmds allowed for this connection
+  * @name:             connection peer portal
+  * @release_work:     deffered work for release job
+  * @state_mutex:      protects iser onnection state
+  * @stop_completion:  conn_stop completion
+  * @ib_completion:    RDMA cleanup completion
+  * @up_completion:    connection establishment completed
+  *                    (state is ISER_CONN_UP)
+  * @conn_list:        entry in ig conn list
+  * @login_buf:        login data buffer (stores login parameters)
+  * @login_req_buf:    login request buffer
+  * @login_req_dma:    login request buffer dma address
+  * @login_resp_buf:   login response buffer
+  * @login_resp_dma:   login response buffer dma address
+  * @rx_desc_head:     head of rx_descs cyclic buffer
+  * @rx_descs:         rx buffers array (cyclic buffer)
+  * @num_rx_descs:     number of rx descriptors
+  */
++>>>>>>> 6ec9d4d2310e (IB/iser: Fix possible SQ overflow)
  struct iser_conn {
 -	struct ib_conn		     ib_conn;
  	struct iscsi_conn	     *iscsi_conn;
  	struct iscsi_endpoint	     *ep;
 -	enum iser_conn_state	     state;
 -	unsigned		     qp_max_recv_dtos;
 -	unsigned		     qp_max_recv_dtos_mask;
 -	unsigned		     min_posted_rx;
 -	u16                          max_cmds;
 +	enum iser_ib_conn_state	     state;	    /* rdma connection state   */
 +	atomic_t		     refcount;
 +	spinlock_t		     lock;	    /* used for state changes  */
 +	struct iser_device           *device;       /* device context          */
 +	struct rdma_cm_id            *cma_id;       /* CMA ID		       */
 +	struct ib_qp	             *qp;           /* QP 		       */
 +	unsigned		     qp_max_recv_dtos; /* num of rx buffers */
 +	unsigned		     qp_max_recv_dtos_mask; /* above minus 1 */
 +	unsigned		     min_posted_rx; /* qp_max_recv_dtos >> 2 */
 +	int                          post_recv_buf_count; /* posted rx count  */
 +	atomic_t                     post_send_buf_count; /* posted tx count   */
  	char 			     name[ISER_OBJECT_NAME_SIZE];
  	struct work_struct	     release_work;
 -	struct mutex		     state_mutex;
  	struct completion	     stop_completion;
 -	struct completion	     ib_completion;
 +	struct mutex		     state_mutex;
 +	struct completion	     flush_completion;
  	struct completion	     up_completion;
 -	struct list_head	     conn_list;
 +	struct list_head	     conn_list;       /* entry in ig conn list */
  
  	char  			     *login_buf;
  	char			     *login_req_buf, *login_resp_buf;
diff --cc drivers/infiniband/ulp/iser/iser_initiator.c
index 8d44a4060634,3821633f1065..000000000000
--- a/drivers/infiniband/ulp/iser/iser_initiator.c
+++ b/drivers/infiniband/ulp/iser/iser_initiator.c
@@@ -364,6 -369,11 +364,14 @@@ static int iser_post_rx_bufs(struct isc
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static inline bool iser_signal_comp(u8 sig_count)
+ {
+ 	return ((sig_count % ISER_SIGNAL_CMD_COUNT) == 0);
+ }
+ 
++>>>>>>> 6ec9d4d2310e (IB/iser: Fix possible SQ overflow)
  /**
   * iser_send_command - send command PDU
   */
@@@ -378,6 -388,7 +386,10 @@@ int iser_send_command(struct iscsi_con
  	struct iscsi_scsi_req *hdr = (struct iscsi_scsi_req *)task->hdr;
  	struct scsi_cmnd *sc  =  task->sc;
  	struct iser_tx_desc *tx_desc = &iser_task->desc;
++<<<<<<< HEAD
++=======
+ 	u8 sig_count = ++iser_conn->ib_conn.sig_count;
++>>>>>>> 6ec9d4d2310e (IB/iser: Fix possible SQ overflow)
  
  	edtl = ntohl(hdr->data_length);
  
@@@ -423,7 -434,8 +435,12 @@@
  
  	iser_task->status = ISER_TASK_STATUS_STARTED;
  
++<<<<<<< HEAD
 +	err = iser_post_send(ib_conn, tx_desc);
++=======
+ 	err = iser_post_send(&iser_conn->ib_conn, tx_desc,
+ 			     iser_signal_comp(sig_count));
++>>>>>>> 6ec9d4d2310e (IB/iser: Fix possible SQ overflow)
  	if (!err)
  		return 0;
  
* Unmerged path drivers/infiniband/ulp/iser/iscsi_iser.h
* Unmerged path drivers/infiniband/ulp/iser/iser_initiator.c
