PM / QoS: Introcuce latency tolerance device PM QoS type

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [acpi] pm: qos: Introcuce latency tolerance device PM QoS type (Prarit Bhargava) [1178891]
Rebuild_FUZZ: 97.30%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 2d984ad132a87ca2112f81f21039493176a8bca0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/2d984ad1.failed

Add a new latency tolerance device PM QoS type to be use for
specifying active state (RPM_ACTIVE) memory access (DMA) latency
tolerance requirements for devices.  It may be used to prevent
hardware from choosing overly aggressive energy-saving operation
modes (causing too much latency to appear) for the whole platform.

This feature reqiures hardware support, so it only will be
available for devices having a new .set_latency_tolerance()
callback in struct dev_pm_info populated, in which case the
routine pointed to by it should implement whatever is necessary
to transfer the effective requirement value to the hardware.

Whenever the effective latency tolerance changes for the device,
its .set_latency_tolerance() callback will be executed and the
effective value will be passed to it.  If that value is negative,
which means that the list of latency tolerance requirements for
the device is empty, the callback is expected to switch the
underlying hardware latency tolerance control mechanism to an
autonomous mode if available.  If that value is PM_QOS_LATENCY_ANY,
in turn, and the hardware supports a special "no requirement"
setting, the callback is expected to use it.  That allows software
to prevent the hardware from automatically updating the device's
latency tolerance in response to its power state changes (e.g. during
transitions from D3cold to D0), which generally may be done in the
autonomous latency tolerance control mode.

If .set_latency_tolerance() is present for the device, a new
pm_qos_latency_tolerance_us attribute will be present in the
devivce's power directory in sysfs.  Then, user space can use
that attribute to specify its latency tolerance requirement for
the device, if any.  Writing "any" to it means "no requirement, but
do not let the hardware control latency tolerance" and writing
"auto" to it allows the hardware to be switched to the autonomous
mode if there are no other requirements from the kernel side in the
device's list.

This changeset includes a fix from Mika Westerberg.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 2d984ad132a87ca2112f81f21039493176a8bca0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/power/pm_qos_interface.txt
#	drivers/base/power/qos.c
#	include/linux/pm_qos.h
diff --cc Documentation/power/pm_qos_interface.txt
index 483632087788,ed743bbad87c..000000000000
--- a/Documentation/power/pm_qos_interface.txt
+++ b/Documentation/power/pm_qos_interface.txt
@@@ -88,17 -88,19 +88,33 @@@ node
  
  2. PM QoS per-device latency and flags framework
  
++<<<<<<< HEAD
 +For each device, there are two lists of PM QoS requests. One is maintained
 +along with the aggregated target of latency value and the other is for PM QoS
 +flags. Values are updated in response to changes of the request list.
 +
 +Target latency value is simply the minimum of the request values held in the
 +parameter list elements.  The PM QoS flags aggregate value is a gather (bitwise
 +OR) of all list elements' values. Two device PM QoS flags are defined currently:
 +PM_QOS_FLAG_NO_POWER_OFF and PM_QOS_FLAG_REMOTE_WAKEUP.
 +
 +Note: the aggregated target value is implemented as an atomic variable so that
 +reading the aggregated value does not require any locking mechanism.
++=======
+ For each device, there are three lists of PM QoS requests. Two of them are
+ maintained along with the aggregated targets of resume latency and active
+ state latency tolerance (in microseconds) and the third one is for PM QoS flags.
+ Values are updated in response to changes of the request list.
+ 
+ The target values of resume latency and active state latency tolerance are
+ simply the minimum of the request values held in the parameter list elements.
+ The PM QoS flags aggregate value is a gather (bitwise OR) of all list elements'
+ values.  Two device PM QoS flags are defined currently: PM_QOS_FLAG_NO_POWER_OFF
+ and PM_QOS_FLAG_REMOTE_WAKEUP.
+ 
+ Note: The aggregated target values are implemented in such a way that reading
+ the aggregated value does not require any locking mechanism.
++>>>>>>> 2d984ad132a8 (PM / QoS: Introcuce latency tolerance device PM QoS type)
  
  
  From kernel mode the use of this interface is the following:
@@@ -178,7 -181,40 +194,47 @@@ Removes the notification callback funct
  of the framework.
  
  
++<<<<<<< HEAD
 +From user mode:
 +No API for user space access to the per-device latency constraints is provided
 +yet - still under discussion.
 +
++=======
+ Active state latency tolerance
+ 
+ This device PM QoS type is used to support systems in which hardware may switch
+ to energy-saving operation modes on the fly.  In those systems, if the operation
+ mode chosen by the hardware attempts to save energy in an overly aggressive way,
+ it may cause excess latencies to be visible to software, causing it to miss
+ certain protocol requirements or target frame or sample rates etc.
+ 
+ If there is a latency tolerance control mechanism for a given device available
+ to software, the .set_latency_tolerance callback in that device's dev_pm_info
+ structure should be populated.  The routine pointed to by it is should implement
+ whatever is necessary to transfer the effective requirement value to the
+ hardware.
+ 
+ Whenever the effective latency tolerance changes for the device, its
+ .set_latency_tolerance() callback will be executed and the effective value will
+ be passed to it.  If that value is negative, which means that the list of
+ latency tolerance requirements for the device is empty, the callback is expected
+ to switch the underlying hardware latency tolerance control mechanism to an
+ autonomous mode if available.  If that value is PM_QOS_LATENCY_ANY, in turn, and
+ the hardware supports a special "no requirement" setting, the callback is
+ expected to use it.  That allows software to prevent the hardware from
+ automatically updating the device's latency tolerance in response to its power
+ state changes (e.g. during transitions from D3cold to D0), which generally may
+ be done in the autonomous latency tolerance control mode.
+ 
+ If .set_latency_tolerance() is present for the device, sysfs attribute
+ pm_qos_latency_tolerance_us will be present in the devivce's power directory.
+ Then, user space can use that attribute to specify its latency tolerance
+ requirement for the device, if any.  Writing "any" to it means "no requirement,
+ but do not let the hardware control latency tolerance" and writing "auto" to it
+ allows the hardware to be switched to the autonomous mode if there are no other
+ requirements from the kernel side in the device's list.
+ 
+ Kernel code can use the functions described above along with the
+ DEV_PM_QOS_LATENCY_TOLERANCE device PM QoS type to add, remove and update
+ latency tolerance requirements for devices.
++>>>>>>> 2d984ad132a8 (PM / QoS: Introcuce latency tolerance device PM QoS type)
diff --cc drivers/base/power/qos.c
index 5c1361a9e5dd,84756f7f09d9..000000000000
--- a/drivers/base/power/qos.c
+++ b/drivers/base/power/qos.c
@@@ -341,7 -376,8 +375,12 @@@ static int __dev_pm_qos_update_request(
  		return -ENODEV;
  
  	switch(req->type) {
++<<<<<<< HEAD
 +	case DEV_PM_QOS_LATENCY:
++=======
+ 	case DEV_PM_QOS_RESUME_LATENCY:
+ 	case DEV_PM_QOS_LATENCY_TOLERANCE:
++>>>>>>> 2d984ad132a8 (PM / QoS: Introcuce latency tolerance device PM QoS type)
  		curr_value = req->data.pnode.prio;
  		break;
  	case DEV_PM_QOS_FLAGS:
@@@ -559,10 -594,14 +598,14 @@@ static void __dev_pm_qos_drop_user_requ
  	struct dev_pm_qos_request *req = NULL;
  
  	switch(type) {
 -	case DEV_PM_QOS_RESUME_LATENCY:
 -		req = dev->power.qos->resume_latency_req;
 -		dev->power.qos->resume_latency_req = NULL;
 +	case DEV_PM_QOS_LATENCY:
 +		req = dev->power.qos->latency_req;
 +		dev->power.qos->latency_req = NULL;
  		break;
+ 	case DEV_PM_QOS_LATENCY_TOLERANCE:
+ 		req = dev->power.qos->latency_tolerance_req;
+ 		dev->power.qos->latency_tolerance_req = NULL;
+ 		break;
  	case DEV_PM_QOS_FLAGS:
  		req = dev->power.qos->flags_req;
  		dev->power.qos->flags_req = NULL;
diff --cc include/linux/pm_qos.h
index 5a95013905c8,0b476019be55..000000000000
--- a/include/linux/pm_qos.h
+++ b/include/linux/pm_qos.h
@@@ -32,7 -32,10 +32,14 @@@ enum pm_qos_flags_status 
  #define PM_QOS_CPU_DMA_LAT_DEFAULT_VALUE	(2000 * USEC_PER_SEC)
  #define PM_QOS_NETWORK_LAT_DEFAULT_VALUE	(2000 * USEC_PER_SEC)
  #define PM_QOS_NETWORK_THROUGHPUT_DEFAULT_VALUE	0
++<<<<<<< HEAD
 +#define PM_QOS_DEV_LAT_DEFAULT_VALUE		0
++=======
+ #define PM_QOS_RESUME_LATENCY_DEFAULT_VALUE	0
+ #define PM_QOS_LATENCY_TOLERANCE_DEFAULT_VALUE	0
+ #define PM_QOS_LATENCY_TOLERANCE_NO_CONSTRAINT	(-1)
+ #define PM_QOS_LATENCY_ANY			((s32)(~(__u32)0 >> 1))
++>>>>>>> 2d984ad132a8 (PM / QoS: Introcuce latency tolerance device PM QoS type)
  
  #define PM_QOS_FLAG_NO_POWER_OFF	(1 << 0)
  #define PM_QOS_FLAG_REMOTE_WAKEUP	(1 << 1)
@@@ -49,7 -52,8 +56,12 @@@ struct pm_qos_flags_request 
  };
  
  enum dev_pm_qos_req_type {
++<<<<<<< HEAD
 +	DEV_PM_QOS_LATENCY = 1,
++=======
+ 	DEV_PM_QOS_RESUME_LATENCY = 1,
+ 	DEV_PM_QOS_LATENCY_TOLERANCE,
++>>>>>>> 2d984ad132a8 (PM / QoS: Introcuce latency tolerance device PM QoS type)
  	DEV_PM_QOS_FLAGS,
  };
  
@@@ -87,9 -92,11 +99,17 @@@ struct pm_qos_flags 
  };
  
  struct dev_pm_qos {
++<<<<<<< HEAD
 +	struct pm_qos_constraints latency;
 +	struct pm_qos_flags flags;
 +	struct dev_pm_qos_request *latency_req;
++=======
+ 	struct pm_qos_constraints resume_latency;
+ 	struct pm_qos_constraints latency_tolerance;
+ 	struct pm_qos_flags flags;
+ 	struct dev_pm_qos_request *resume_latency_req;
+ 	struct dev_pm_qos_request *latency_tolerance_req;
++>>>>>>> 2d984ad132a8 (PM / QoS: Introcuce latency tolerance device PM QoS type)
  	struct dev_pm_qos_request *flags_req;
  };
  
@@@ -195,10 -202,12 +215,12 @@@ void dev_pm_qos_hide_latency_limit(stru
  int dev_pm_qos_expose_flags(struct device *dev, s32 value);
  void dev_pm_qos_hide_flags(struct device *dev);
  int dev_pm_qos_update_flags(struct device *dev, s32 mask, bool set);
+ s32 dev_pm_qos_get_user_latency_tolerance(struct device *dev);
+ int dev_pm_qos_update_user_latency_tolerance(struct device *dev, s32 val);
  
 -static inline s32 dev_pm_qos_requested_resume_latency(struct device *dev)
 +static inline s32 dev_pm_qos_requested_latency(struct device *dev)
  {
 -	return dev->power.qos->resume_latency_req->data.pnode.prio;
 +	return dev->power.qos->latency_req->data.pnode.prio;
  }
  
  static inline s32 dev_pm_qos_requested_flags(struct device *dev)
@@@ -214,8 -223,12 +236,12 @@@ static inline int dev_pm_qos_expose_fla
  static inline void dev_pm_qos_hide_flags(struct device *dev) {}
  static inline int dev_pm_qos_update_flags(struct device *dev, s32 m, bool set)
  			{ return 0; }
+ static inline s32 dev_pm_qos_get_user_latency_tolerance(struct device *dev)
+ 			{ return PM_QOS_LATENCY_TOLERANCE_NO_CONSTRAINT; }
+ static inline int dev_pm_qos_update_user_latency_tolerance(struct device *dev, s32 val)
+ 			{ return 0; }
  
 -static inline s32 dev_pm_qos_requested_resume_latency(struct device *dev) { return 0; }
 +static inline s32 dev_pm_qos_requested_latency(struct device *dev) { return 0; }
  static inline s32 dev_pm_qos_requested_flags(struct device *dev) { return 0; }
  #endif
  
diff --git a/Documentation/ABI/testing/sysfs-devices-power b/Documentation/ABI/testing/sysfs-devices-power
index 9d43e7670841..17379a19dab6 100644
--- a/Documentation/ABI/testing/sysfs-devices-power
+++ b/Documentation/ABI/testing/sysfs-devices-power
@@ -187,7 +187,7 @@ Description:
 		Not all drivers support this attribute.  If it isn't supported,
 		attempts to read or write it will yield I/O errors.
 
-What:		/sys/devices/.../power/pm_qos_latency_us
+What:		/sys/devices/.../power/pm_qos_resume_latency_us
 Date:		March 2012
 Contact:	Rafael J. Wysocki <rjw@sisk.pl>
 Description:
@@ -205,6 +205,31 @@ Description:
 		This attribute has no effect on system-wide suspend/resume and
 		hibernation.
 
+What:		/sys/devices/.../power/pm_qos_latency_tolerance_us
+Date:		January 2014
+Contact:	Rafael J. Wysocki <rjw@rjwysocki.net>
+Description:
+		The /sys/devices/.../power/pm_qos_latency_tolerance_us attribute
+		contains the PM QoS active state latency tolerance limit for the
+		given device in microseconds.  That is the maximum memory access
+		latency the device can suffer without any visible adverse
+		effects on user space functionality.  If that value is the
+		string "any", the latency does not matter to user space at all,
+		but hardware should not be allowed to set the latency tolerance
+		for the device automatically.
+
+		Reading "auto" from this file means that the maximum memory
+		access latency for the device may be determined automatically
+		by the hardware as needed.  Writing "auto" to it allows the
+		hardware to be switched to this mode if there are no other
+		latency tolerance requirements from the kernel side.
+
+		This attribute is only present if the feature controlled by it
+		is supported by the hardware.
+
+		This attribute has no effect on runtime suspend and resume of
+		devices and on system-wide suspend/resume and hibernation.
+
 What:		/sys/devices/.../power/pm_qos_no_power_off
 Date:		September 2012
 Contact:	Rafael J. Wysocki <rjw@sisk.pl>
* Unmerged path Documentation/power/pm_qos_interface.txt
* Unmerged path drivers/base/power/qos.c
diff --git a/drivers/base/power/sysfs.c b/drivers/base/power/sysfs.c
index 03e089ade5ce..b00c6f116422 100644
--- a/drivers/base/power/sysfs.c
+++ b/drivers/base/power/sysfs.c
@@ -244,6 +244,40 @@ static ssize_t pm_qos_latency_store(struct device *dev,
 static DEVICE_ATTR(pm_qos_resume_latency_us, 0644,
 		   pm_qos_latency_show, pm_qos_latency_store);
 
+static ssize_t pm_qos_latency_tolerance_show(struct device *dev,
+					     struct device_attribute *attr,
+					     char *buf)
+{
+	s32 value = dev_pm_qos_get_user_latency_tolerance(dev);
+
+	if (value < 0)
+		return sprintf(buf, "auto\n");
+	else if (value == PM_QOS_LATENCY_ANY)
+		return sprintf(buf, "any\n");
+
+	return sprintf(buf, "%d\n", value);
+}
+
+static ssize_t pm_qos_latency_tolerance_store(struct device *dev,
+					      struct device_attribute *attr,
+					      const char *buf, size_t n)
+{
+	s32 value;
+	int ret;
+
+	if (kstrtos32(buf, 0, &value)) {
+		if (!strcmp(buf, "auto") || !strcmp(buf, "auto\n"))
+			value = PM_QOS_LATENCY_TOLERANCE_NO_CONSTRAINT;
+		else if (!strcmp(buf, "any") || !strcmp(buf, "any\n"))
+			value = PM_QOS_LATENCY_ANY;
+	}
+	ret = dev_pm_qos_update_user_latency_tolerance(dev, value);
+	return ret < 0 ? ret : n;
+}
+
+static DEVICE_ATTR(pm_qos_latency_tolerance_us, 0644,
+		   pm_qos_latency_tolerance_show, pm_qos_latency_tolerance_store);
+
 static ssize_t pm_qos_no_power_off_show(struct device *dev,
 					struct device_attribute *attr,
 					char *buf)
@@ -629,6 +663,17 @@ static struct attribute_group pm_qos_latency_attr_group = {
 	.attrs	= pm_qos_latency_attrs,
 };
 
+static struct attribute *pm_qos_latency_tolerance_attrs[] = {
+#ifdef CONFIG_PM_RUNTIME
+	&dev_attr_pm_qos_latency_tolerance_us.attr,
+#endif /* CONFIG_PM_RUNTIME */
+	NULL,
+};
+static struct attribute_group pm_qos_latency_tolerance_attr_group = {
+	.name	= power_group_name,
+	.attrs	= pm_qos_latency_tolerance_attrs,
+};
+
 static struct attribute *pm_qos_flags_attrs[] = {
 #ifdef CONFIG_PM_RUNTIME
 	&dev_attr_pm_qos_no_power_off.attr,
@@ -654,18 +699,23 @@ int dpm_sysfs_add(struct device *dev)
 		if (rc)
 			goto err_out;
 	}
-
 	if (device_can_wakeup(dev)) {
 		rc = sysfs_merge_group(&dev->kobj, &pm_wakeup_attr_group);
-		if (rc) {
-			if (pm_runtime_callbacks_present(dev))
-				sysfs_unmerge_group(&dev->kobj,
-						    &pm_runtime_attr_group);
-			goto err_out;
-		}
+		if (rc)
+			goto err_runtime;
+	}
+	if (dev->power.set_latency_tolerance) {
+		rc = sysfs_merge_group(&dev->kobj,
+				       &pm_qos_latency_tolerance_attr_group);
+		if (rc)
+			goto err_wakeup;
 	}
 	return 0;
 
+ err_wakeup:
+	sysfs_unmerge_group(&dev->kobj, &pm_wakeup_attr_group);
+ err_runtime:
+	sysfs_unmerge_group(&dev->kobj, &pm_runtime_attr_group);
  err_out:
 	sysfs_remove_group(&dev->kobj, &pm_attr_group);
 	return rc;
@@ -708,6 +758,7 @@ void rpm_sysfs_remove(struct device *dev)
 
 void dpm_sysfs_remove(struct device *dev)
 {
+	sysfs_unmerge_group(&dev->kobj, &pm_qos_latency_tolerance_attr_group);
 	dev_pm_qos_constraints_destroy(dev);
 	rpm_sysfs_remove(dev);
 	sysfs_unmerge_group(&dev->kobj, &pm_wakeup_attr_group);
diff --git a/include/linux/pm.h b/include/linux/pm.h
index a224c7f5c377..b05d8b60ba99 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -561,6 +561,7 @@ struct dev_pm_info {
 	unsigned long		accounting_timestamp;
 #endif
 	struct pm_subsys_data	*subsys_data;  /* Owned by the subsystem. */
+	void (*set_latency_tolerance)(struct device *, s32);
 	struct dev_pm_qos	*qos;
 };
 
* Unmerged path include/linux/pm_qos.h
diff --git a/kernel/power/qos.c b/kernel/power/qos.c
index 4b849c968ee7..fc87acab23fb 100644
--- a/kernel/power/qos.c
+++ b/kernel/power/qos.c
@@ -170,6 +170,7 @@ int pm_qos_update_target(struct pm_qos_constraints *c, struct plist_node *node,
 {
 	unsigned long flags;
 	int prev_value, curr_value, new_value;
+	int ret;
 
 	spin_lock_irqsave(&pm_qos_lock, flags);
 	prev_value = pm_qos_get_value(c);
@@ -205,13 +206,15 @@ int pm_qos_update_target(struct pm_qos_constraints *c, struct plist_node *node,
 
 	trace_pm_qos_update_target(action, prev_value, curr_value);
 	if (prev_value != curr_value) {
-		blocking_notifier_call_chain(c->notifiers,
-					     (unsigned long)curr_value,
-					     NULL);
-		return 1;
+		ret = 1;
+		if (c->notifiers)
+			blocking_notifier_call_chain(c->notifiers,
+						     (unsigned long)curr_value,
+						     NULL);
 	} else {
-		return 0;
+		ret = 0;
 	}
+	return ret;
 }
 
 /**
