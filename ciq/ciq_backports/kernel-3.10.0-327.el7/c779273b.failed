iwlwifi: mvm: fix ROC reference accounting

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Eliad Peller <eliad@wizery.com>
commit c779273b37bec14c33feeab11c4d457a24bc64e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/c779273b.failed

commit b112889c5af8124 ("iwlwifi: mvm: add Aux ROC request/response flow")
added aux ROC flow in addition to the existing ROC flow. While doing
it, it moved the ROC reference release to a common work item, which
is being called for both the ROC and aux ROC flows.

This resulted in invalid reference accounting, as no reference was
taken in case of aux ROC, while a reference was released on completion.

Fix it by adding a reference for the aux ROC as well, and release
only the relevant references on completion (according to the set bits).

While at it, convert cancel_work_sync() to flush_work(), in order
to make sure the references are being cleaned properly.

Fixes: b112889c5af8 ("iwlwifi: mvm: add Aux ROC request/response flow")
	Signed-off-by: Eliad Peller <eliadx.peller@intel.com>
	Reviewed-by: Johannes Berg <johannes.berg@intel.com>
	Signed-off-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
(cherry picked from commit c779273b37bec14c33feeab11c4d457a24bc64e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/iwlwifi/mvm/debugfs.c
#	drivers/net/wireless/iwlwifi/mvm/time-event.c
diff --cc drivers/net/wireless/iwlwifi/mvm/debugfs.c
index 29ca72695eaa,8c17b943cc6f..000000000000
--- a/drivers/net/wireless/iwlwifi/mvm/debugfs.c
+++ b/drivers/net/wireless/iwlwifi/mvm/debugfs.c
@@@ -6,6 -6,7 +6,10 @@@
   * GPL LICENSE SUMMARY
   *
   * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
++<<<<<<< HEAD
++=======
+  * Copyright(c) 2013 - 2015 Intel Mobile Communications GmbH
++>>>>>>> c779273b37be (iwlwifi: mvm: fix ROC reference accounting)
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of version 2 of the GNU General Public License as
@@@ -31,6 -32,7 +35,10 @@@
   * BSD LICENSE
   *
   * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
++<<<<<<< HEAD
++=======
+  * Copyright(c) 2013 - 2015 Intel Mobile Communications GmbH
++>>>>>>> c779273b37be (iwlwifi: mvm: fix ROC reference accounting)
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
diff --cc drivers/net/wireless/iwlwifi/mvm/time-event.c
index 80100f6cc12a,a7448cf01688..000000000000
--- a/drivers/net/wireless/iwlwifi/mvm/time-event.c
+++ b/drivers/net/wireless/iwlwifi/mvm/time-event.c
@@@ -6,6 -6,7 +6,10 @@@
   * GPL LICENSE SUMMARY
   *
   * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
++<<<<<<< HEAD
++=======
+  * Copyright(c) 2013 - 2015 Intel Mobile Communications GmbH
++>>>>>>> c779273b37be (iwlwifi: mvm: fix ROC reference accounting)
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of version 2 of the GNU General Public License as
@@@ -31,6 -32,7 +35,10 @@@
   * BSD LICENSE
   *
   * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
++<<<<<<< HEAD
++=======
+  * Copyright(c) 2013 - 2015 Intel Mobile Communications GmbH
++>>>>>>> c779273b37be (iwlwifi: mvm: fix ROC reference accounting)
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
@@@ -100,6 -99,23 +108,26 @@@ void iwl_mvm_te_clear_data(struct iwl_m
  void iwl_mvm_roc_done_wk(struct work_struct *wk)
  {
  	struct iwl_mvm *mvm = container_of(wk, struct iwl_mvm, roc_done_wk);
++<<<<<<< HEAD
++=======
+ 	u32 queues = 0;
+ 
+ 	/*
+ 	 * Clear the ROC_RUNNING /ROC_AUX_RUNNING status bit.
+ 	 * This will cause the TX path to drop offchannel transmissions.
+ 	 * That would also be done by mac80211, but it is racy, in particular
+ 	 * in the case that the time event actually completed in the firmware
+ 	 * (which is handled in iwl_mvm_te_handle_notif).
+ 	 */
+ 	if (test_and_clear_bit(IWL_MVM_STATUS_ROC_RUNNING, &mvm->status)) {
+ 		queues |= BIT(IWL_MVM_OFFCHANNEL_QUEUE);
+ 		iwl_mvm_unref(mvm, IWL_MVM_REF_ROC);
+ 	}
+ 	if (test_and_clear_bit(IWL_MVM_STATUS_ROC_AUX_RUNNING, &mvm->status)) {
+ 		queues |= BIT(mvm->aux_queue);
+ 		iwl_mvm_unref(mvm, IWL_MVM_REF_ROC_AUX);
+ 	}
++>>>>>>> c779273b37be (iwlwifi: mvm: fix ROC reference accounting)
  
  	synchronize_net();
  
@@@ -220,6 -351,63 +248,66 @@@ static void iwl_mvm_te_handle_notif(str
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Handle A Aux ROC time event
+  */
+ static int iwl_mvm_aux_roc_te_handle_notif(struct iwl_mvm *mvm,
+ 					   struct iwl_time_event_notif *notif)
+ {
+ 	struct iwl_mvm_time_event_data *te_data, *tmp;
+ 	bool aux_roc_te = false;
+ 
+ 	list_for_each_entry_safe(te_data, tmp, &mvm->aux_roc_te_list, list) {
+ 		if (le32_to_cpu(notif->unique_id) == te_data->uid) {
+ 			aux_roc_te = true;
+ 			break;
+ 		}
+ 	}
+ 	if (!aux_roc_te) /* Not a Aux ROC time event */
+ 		return -EINVAL;
+ 
+ 	iwl_mvm_te_check_trigger(mvm, notif, te_data);
+ 
+ 	if (!le32_to_cpu(notif->status)) {
+ 		IWL_DEBUG_TE(mvm,
+ 			     "ERROR: Aux ROC Time Event %s notification failure\n",
+ 			     (le32_to_cpu(notif->action) &
+ 			      TE_V2_NOTIF_HOST_EVENT_START) ? "start" : "end");
+ 		return -EINVAL;
+ 	}
+ 
+ 	IWL_DEBUG_TE(mvm,
+ 		     "Aux ROC time event notification  - UID = 0x%x action %d\n",
+ 		     le32_to_cpu(notif->unique_id),
+ 		     le32_to_cpu(notif->action));
+ 
+ 	if (le32_to_cpu(notif->action) == TE_V2_NOTIF_HOST_EVENT_END) {
+ 		/* End TE, notify mac80211 */
+ 		ieee80211_remain_on_channel_expired(mvm->hw);
+ 		iwl_mvm_roc_finished(mvm); /* flush aux queue */
+ 		list_del(&te_data->list); /* remove from list */
+ 		te_data->running = false;
+ 		te_data->vif = NULL;
+ 		te_data->uid = 0;
+ 		te_data->id = TE_MAX;
+ 	} else if (le32_to_cpu(notif->action) == TE_V2_NOTIF_HOST_EVENT_START) {
+ 		set_bit(IWL_MVM_STATUS_ROC_AUX_RUNNING, &mvm->status);
+ 		te_data->running = true;
+ 		iwl_mvm_ref(mvm, IWL_MVM_REF_ROC_AUX);
+ 		ieee80211_ready_on_channel(mvm->hw); /* Start TE */
+ 	} else {
+ 		IWL_DEBUG_TE(mvm,
+ 			     "ERROR: Unknown Aux ROC Time Event (action = %d)\n",
+ 			     le32_to_cpu(notif->action));
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /*
++>>>>>>> c779273b37be (iwlwifi: mvm: fix ROC reference accounting)
   * The Rx handler for time event notifications
   */
  int iwl_mvm_rx_time_event_notif(struct iwl_mvm *mvm,
* Unmerged path drivers/net/wireless/iwlwifi/mvm/debugfs.c
diff --git a/drivers/net/wireless/iwlwifi/mvm/mac80211.c b/drivers/net/wireless/iwlwifi/mvm/mac80211.c
index 08572e212d8f..19bf5ceb011d 100644
--- a/drivers/net/wireless/iwlwifi/mvm/mac80211.c
+++ b/drivers/net/wireless/iwlwifi/mvm/mac80211.c
@@ -732,7 +732,7 @@ static void iwl_mvm_mac_stop(struct ieee80211_hw *hw)
 	 * The work item could be running or queued if the
 	 * ROC time event stops just as we get here.
 	 */
-	cancel_work_sync(&mvm->roc_done_wk);
+	flush_work(&mvm->roc_done_wk);
 
 	iwl_trans_stop_device(mvm->trans);
 
diff --git a/drivers/net/wireless/iwlwifi/mvm/mvm.h b/drivers/net/wireless/iwlwifi/mvm/mvm.h
index a20f882af758..ca76094d1524 100644
--- a/drivers/net/wireless/iwlwifi/mvm/mvm.h
+++ b/drivers/net/wireless/iwlwifi/mvm/mvm.h
@@ -225,6 +225,7 @@ enum iwl_mvm_ref_type {
 	IWL_MVM_REF_UCODE_DOWN,
 	IWL_MVM_REF_SCAN,
 	IWL_MVM_REF_ROC,
+	IWL_MVM_REF_ROC_AUX,
 	IWL_MVM_REF_P2P_CLIENT,
 	IWL_MVM_REF_AP_IBSS,
 	IWL_MVM_REF_USER,
* Unmerged path drivers/net/wireless/iwlwifi/mvm/time-event.c
