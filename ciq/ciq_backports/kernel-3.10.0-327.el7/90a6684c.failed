IB/iser: Modify struct iser_mem_reg members

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [infiniband] iser: Modify struct iser_mem_reg members (Amir Vadai) [1164539]
Rebuild_FUZZ: 96.39%
commit-author Sagi Grimberg <sagig@mellanox.com>
commit 90a6684c30918786446fd062c7422a4098926891
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/90a6684c.failed

No need to keep lkey, va, len variables, we can keep
them as struct ib_sge. This will help when we change the
memory registration logic.

This patch does not change any functionality.

	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Adir Lev <adirl@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 90a6684c30918786446fd062c7422a4098926891)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/iser/iscsi_iser.h
#	drivers/infiniband/ulp/iser/iser_initiator.c
#	drivers/infiniband/ulp/iser/iser_memory.c
diff --cc drivers/infiniband/ulp/iser/iscsi_iser.h
index e160d7ee63dc,5fd09636fbee..000000000000
--- a/drivers/infiniband/ulp/iser/iscsi_iser.h
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.h
@@@ -214,21 -244,17 +214,35 @@@ struct iser_cq_desc
  struct iscsi_iser_task;
  struct iscsi_endpoint;
  
++<<<<<<< HEAD
 +struct iser_mem_reg {
 +	u32  lkey;
 +	u32  rkey;
 +	u64  va;
 +	u64  len;
 +	void *mem_h;
 +	int  is_mr;
 +};
 +
 +struct iser_regd_buf {
 +	struct iser_mem_reg     reg;        /* memory registration info        */
 +	void                    *virt_addr;
 +	struct iser_device      *device;    /* device->device for dma_unmap    */
 +	enum dma_data_direction direction;  /* direction for dma_unmap	       */
 +	unsigned int            data_size;
++=======
+ /**
+  * struct iser_mem_reg - iSER memory registration info
+  *
+  * @sge:          memory region sg element
+  * @rkey:         memory region remote key
+  * @mem_h:        pointer to registration context (FMR/Fastreg)
+  */
+ struct iser_mem_reg {
+ 	struct ib_sge	 sge;
+ 	u32		 rkey;
+ 	void		*mem_h;
++>>>>>>> 90a6684c3091 (IB/iser: Modify struct iser_mem_reg members)
  };
  
  enum iser_desc_type {
diff --cc drivers/infiniband/ulp/iser/iser_initiator.c
index 065346a65b0d,b2e3b77340b5..000000000000
--- a/drivers/infiniband/ulp/iser/iser_initiator.c
+++ b/drivers/infiniband/ulp/iser/iser_initiator.c
@@@ -78,15 -78,15 +78,24 @@@ static int iser_prepare_read_cmd(struc
  		iser_err("Failed to set up Data-IN RDMA\n");
  		return err;
  	}
 -	mem_reg = &iser_task->rdma_reg[ISER_DIR_IN];
 +	regd_buf = &iser_task->rdma_regd[ISER_DIR_IN];
  
  	hdr->flags    |= ISER_RSV;
++<<<<<<< HEAD
 +	hdr->read_stag = cpu_to_be32(regd_buf->reg.rkey);
 +	hdr->read_va   = cpu_to_be64(regd_buf->reg.va);
 +
 +	iser_dbg("Cmd itt:%d READ tags RKEY:%#.4X VA:%#llX\n",
 +		 task->itt, regd_buf->reg.rkey,
 +		 (unsigned long long)regd_buf->reg.va);
++=======
+ 	hdr->read_stag = cpu_to_be32(mem_reg->rkey);
+ 	hdr->read_va   = cpu_to_be64(mem_reg->sge.addr);
+ 
+ 	iser_dbg("Cmd itt:%d READ tags RKEY:%#.4X VA:%#llX\n",
+ 		 task->itt, mem_reg->rkey,
+ 		 (unsigned long long)mem_reg->sge.addr);
++>>>>>>> 90a6684c3091 (IB/iser: Modify struct iser_mem_reg members)
  
  	return 0;
  }
@@@ -138,21 -138,21 +147,37 @@@ iser_prepare_write_cmd(struct iscsi_tas
  
  	if (unsol_sz < edtl) {
  		hdr->flags     |= ISER_WSV;
++<<<<<<< HEAD
 +		hdr->write_stag = cpu_to_be32(regd_buf->reg.rkey);
 +		hdr->write_va   = cpu_to_be64(regd_buf->reg.va + unsol_sz);
 +
 +		iser_dbg("Cmd itt:%d, WRITE tags, RKEY:%#.4X "
 +			 "VA:%#llX + unsol:%d\n",
 +			 task->itt, regd_buf->reg.rkey,
 +			 (unsigned long long)regd_buf->reg.va, unsol_sz);
++=======
+ 		hdr->write_stag = cpu_to_be32(mem_reg->rkey);
+ 		hdr->write_va   = cpu_to_be64(mem_reg->sge.addr + unsol_sz);
+ 
+ 		iser_dbg("Cmd itt:%d, WRITE tags, RKEY:%#.4X "
+ 			 "VA:%#llX + unsol:%d\n",
+ 			 task->itt, mem_reg->rkey,
+ 			 (unsigned long long)mem_reg->sge.addr, unsol_sz);
++>>>>>>> 90a6684c3091 (IB/iser: Modify struct iser_mem_reg members)
  	}
  
  	if (imm_sz > 0) {
  		iser_dbg("Cmd itt:%d, WRITE, adding imm.data sz: %d\n",
  			 task->itt, imm_sz);
++<<<<<<< HEAD
 +		tx_dsg->addr   = regd_buf->reg.va;
 +		tx_dsg->length = imm_sz;
 +		tx_dsg->lkey   = regd_buf->reg.lkey;
++=======
+ 		tx_dsg->addr = mem_reg->sge.addr;
+ 		tx_dsg->length = imm_sz;
+ 		tx_dsg->lkey = mem_reg->sge.lkey;
++>>>>>>> 90a6684c3091 (IB/iser: Modify struct iser_mem_reg members)
  		iser_task->desc.num_sge = 2;
  	}
  
@@@ -469,11 -477,11 +494,17 @@@ int iser_send_data_out(struct iscsi_con
  	/* build the tx desc */
  	iser_initialize_task_headers(task, tx_desc);
  
 -	mem_reg = &iser_task->rdma_reg[ISER_DIR_OUT];
 +	regd_buf = &iser_task->rdma_regd[ISER_DIR_OUT];
  	tx_dsg = &tx_desc->tx_sg[1];
++<<<<<<< HEAD
 +	tx_dsg->addr    = regd_buf->reg.va + buf_offset;
 +	tx_dsg->length  = data_seg_len;
 +	tx_dsg->lkey    = regd_buf->reg.lkey;
++=======
+ 	tx_dsg->addr = mem_reg->sge.addr + buf_offset;
+ 	tx_dsg->length = data_seg_len;
+ 	tx_dsg->lkey = mem_reg->sge.lkey;
++>>>>>>> 90a6684c3091 (IB/iser: Modify struct iser_mem_reg members)
  	tx_desc->num_sge = 2;
  
  	if (buf_offset + data_seg_len > iser_task->data[ISER_DIR_OUT].data_len) {
diff --cc drivers/infiniband/ulp/iser/iser_memory.c
index f40132fc970c,40d22d5c3fac..000000000000
--- a/drivers/infiniband/ulp/iser/iser_memory.c
+++ b/drivers/infiniband/ulp/iser/iser_memory.c
@@@ -366,6 -363,88 +366,91 @@@ static int fall_to_bounce_buf(struct is
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * iser_reg_page_vec - Register physical memory
+  *
+  * returns: 0 on success, errno code on failure
+  */
+ static
+ int iser_reg_page_vec(struct iscsi_iser_task *iser_task,
+ 		      struct iser_data_buf *mem,
+ 		      struct iser_page_vec *page_vec,
+ 		      struct iser_mem_reg *mem_reg)
+ {
+ 	struct ib_conn *ib_conn = &iser_task->iser_conn->ib_conn;
+ 	struct iser_device *device = ib_conn->device;
+ 	struct ib_pool_fmr *fmr;
+ 	int ret, plen;
+ 
+ 	plen = iser_sg_to_page_vec(mem, device->ib_device,
+ 				   page_vec->pages,
+ 				   &page_vec->offset,
+ 				   &page_vec->data_size);
+ 	page_vec->length = plen;
+ 	if (plen * SIZE_4K < page_vec->data_size) {
+ 		iser_err("page vec too short to hold this SG\n");
+ 		iser_data_buf_dump(mem, device->ib_device);
+ 		iser_dump_page_vec(page_vec);
+ 		return -EINVAL;
+ 	}
+ 
+ 	fmr  = ib_fmr_pool_map_phys(ib_conn->fmr.pool,
+ 				    page_vec->pages,
+ 				    page_vec->length,
+ 				    page_vec->pages[0]);
+ 	if (IS_ERR(fmr)) {
+ 		ret = PTR_ERR(fmr);
+ 		iser_err("ib_fmr_pool_map_phys failed: %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	mem_reg->sge.lkey = fmr->fmr->lkey;
+ 	mem_reg->rkey = fmr->fmr->rkey;
+ 	mem_reg->sge.addr = page_vec->pages[0] + page_vec->offset;
+ 	mem_reg->sge.length = page_vec->data_size;
+ 	mem_reg->mem_h = fmr;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * Unregister (previosuly registered using FMR) memory.
+  * If memory is non-FMR does nothing.
+  */
+ void iser_unreg_mem_fmr(struct iscsi_iser_task *iser_task,
+ 			enum iser_data_dir cmd_dir)
+ {
+ 	struct iser_mem_reg *reg = &iser_task->rdma_reg[cmd_dir];
+ 	int ret;
+ 
+ 	if (!reg->mem_h)
+ 		return;
+ 
+ 	iser_dbg("PHYSICAL Mem.Unregister mem_h %p\n", reg->mem_h);
+ 
+ 	ret = ib_fmr_pool_unmap((struct ib_pool_fmr *)reg->mem_h);
+ 	if (ret)
+ 		iser_err("ib_fmr_pool_unmap failed %d\n", ret);
+ 
+ 	reg->mem_h = NULL;
+ }
+ 
+ void iser_unreg_mem_fastreg(struct iscsi_iser_task *iser_task,
+ 			    enum iser_data_dir cmd_dir)
+ {
+ 	struct iser_mem_reg *reg = &iser_task->rdma_reg[cmd_dir];
+ 
+ 	if (!reg->mem_h)
+ 		return;
+ 
+ 	iser_reg_desc_put(&iser_task->iser_conn->ib_conn,
+ 			  reg->mem_h);
+ 	reg->mem_h = NULL;
+ }
+ 
+ /**
++>>>>>>> 90a6684c3091 (IB/iser: Modify struct iser_mem_reg members)
   * iser_reg_rdma_mem_fmr - Registers memory intended for RDMA,
   * using FMR (if possible) obtaining rkey and va
   *
@@@ -400,24 -477,22 +485,38 @@@ int iser_reg_rdma_mem_fmr(struct iscsi_
  
  	/* if there a single dma entry, FMR is not needed */
  	if (mem->dma_nents == 1) {
 -		sg = mem->sg;
 +		sg = (struct scatterlist *)mem->buf;
  
++<<<<<<< HEAD
 +		regd_buf->reg.lkey = device->mr->lkey;
 +		regd_buf->reg.rkey = device->mr->rkey;
 +		regd_buf->reg.len  = ib_sg_dma_len(ibdev, &sg[0]);
 +		regd_buf->reg.va   = ib_sg_dma_address(ibdev, &sg[0]);
 +		regd_buf->reg.is_mr = 0;
 +
 +		iser_dbg("PHYSICAL Mem.register: lkey: 0x%08X rkey: 0x%08X  "
 +			 "va: 0x%08lX sz: %ld]\n",
 +			 (unsigned int)regd_buf->reg.lkey,
 +			 (unsigned int)regd_buf->reg.rkey,
 +			 (unsigned long)regd_buf->reg.va,
 +			 (unsigned long)regd_buf->reg.len);
++=======
+ 		mem_reg->sge.lkey = device->mr->lkey;
+ 		mem_reg->rkey = device->mr->rkey;
+ 		mem_reg->sge.length = ib_sg_dma_len(ibdev, &sg[0]);
+ 		mem_reg->sge.addr = ib_sg_dma_address(ibdev, &sg[0]);
+ 
+ 		iser_dbg("PHYSICAL Mem.register: lkey: 0x%08X rkey: 0x%08X  "
+ 			 "va: 0x%08lX sz: %ld]\n",
+ 			 (unsigned int)mem_reg->sge.lkey,
+ 			 (unsigned int)mem_reg->rkey,
+ 			 (unsigned long)mem_reg->sge.addr,
+ 			 (unsigned long)mem_reg->sge.length);
++>>>>>>> 90a6684c3091 (IB/iser: Modify struct iser_mem_reg members)
  	} else { /* use FMR for multiple dma entries */
 -		err = iser_reg_page_vec(iser_task, mem, ib_conn->fmr.page_vec,
 -					mem_reg);
 +		iser_page_vec_build(mem, ib_conn->fmr.page_vec, ibdev);
 +		err = iser_reg_page_vec(ib_conn, ib_conn->fmr.page_vec,
 +					&regd_buf->reg);
  		if (err && err != -EAGAIN) {
  			iser_data_buf_dump(mem, ibdev);
  			iser_err("mem->dma_nents = %d (dlength = 0x%x)\n",
@@@ -766,23 -799,19 +865,36 @@@ int iser_reg_rdma_mem_fastreg(struct is
  		}
  		desc->reg_indicators |= ISER_FASTREG_PROTECTED;
  
++<<<<<<< HEAD
 +		regd_buf->reg.lkey = sig_sge.lkey;
 +		regd_buf->reg.rkey = desc->pi_ctx->sig_mr->rkey;
 +		regd_buf->reg.va = sig_sge.addr;
 +		regd_buf->reg.len = sig_sge.length;
 +		regd_buf->reg.is_mr = 1;
++=======
+ 		mem_reg->sge.lkey = sig_sge.lkey;
+ 		mem_reg->rkey = desc->pi_ctx->sig_mr->rkey;
+ 		mem_reg->sge.addr = sig_sge.addr;
+ 		mem_reg->sge.length = sig_sge.length;
++>>>>>>> 90a6684c3091 (IB/iser: Modify struct iser_mem_reg members)
  	} else {
 -		if (desc)
 -			mem_reg->rkey = desc->data_mr->rkey;
 -		else
 -			mem_reg->rkey = device->mr->rkey;
 +		if (desc) {
 +			regd_buf->reg.rkey = desc->data_mr->rkey;
 +			regd_buf->reg.is_mr = 1;
 +		} else {
 +			regd_buf->reg.rkey = device->mr->rkey;
 +			regd_buf->reg.is_mr = 0;
 +		}
  
++<<<<<<< HEAD
 +		regd_buf->reg.lkey = data_sge.lkey;
 +		regd_buf->reg.va = data_sge.addr;
 +		regd_buf->reg.len = data_sge.length;
++=======
+ 		mem_reg->sge.lkey = data_sge.lkey;
+ 		mem_reg->sge.addr = data_sge.addr;
+ 		mem_reg->sge.length = data_sge.length;
++>>>>>>> 90a6684c3091 (IB/iser: Modify struct iser_mem_reg members)
  	}
  
  	return 0;
* Unmerged path drivers/infiniband/ulp/iser/iscsi_iser.h
* Unmerged path drivers/infiniband/ulp/iser/iser_initiator.c
* Unmerged path drivers/infiniband/ulp/iser/iser_memory.c
