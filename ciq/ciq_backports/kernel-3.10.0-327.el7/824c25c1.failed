IB/mlx4: Always use the correct port for mirrored multicast attachments

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [infiniband] mlx4: Always use the correct port for mirrored multicast attachments (Amir Vadai) [1164527 1164530 1164531 1164536 1164537]
Rebuild_FUZZ: 97.84%
commit-author Moni Shoua <monis@mellanox.com>
commit 824c25c1abe70a527646056f6911d181facde9cc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/824c25c1.failed

When attaching a QP to a multicast address in bonded mode, there was an
assumption that the port of the QP must be #1. This assumption isn't the
case under the flow which enables maximal usage of the physical ports.

Fix it by always checking the port of the original flow and create the
mirrored flow on the other port.

Fixes: c6215745b66a ('IB/mlx4: Load balance ports in port aggregation mode')
	Signed-off-by: Moni Shoua <monis@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 824c25c1abe70a527646056f6911d181facde9cc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx4/main.c
diff --cc drivers/infiniband/hw/mlx4/main.c
index 56b15ae417f3,3140da518a07..000000000000
--- a/drivers/infiniband/hw/mlx4/main.c
+++ b/drivers/infiniband/hw/mlx4/main.c
@@@ -1183,6 -1185,20 +1183,23 @@@ static struct ib_flow *mlx4_ib_create_f
  		if (err)
  			goto err_create_flow;
  		i++;
++<<<<<<< HEAD
++=======
+ 		if (is_bonded) {
+ 			/* Application always sees one port so the mirror rule
+ 			 * must be on port #2
+ 			 */
+ 			flow_attr->port = 2;
+ 			err = __mlx4_ib_create_flow(qp, flow_attr,
+ 						    domain, type[j],
+ 						    &mflow->reg_id[j].mirror);
+ 			flow_attr->port = 1;
+ 			if (err)
+ 				goto err_create_flow;
+ 			j++;
+ 		}
+ 
++>>>>>>> 824c25c1abe7 (IB/mlx4: Always use the correct port for mirrored multicast attachments)
  	}
  
  	if (i < ARRAY_SIZE(type) && flow_attr->type == IB_FLOW_ATTR_NORMAL) {
@@@ -1241,10 -1283,19 +1258,23 @@@ static int mlx4_ib_mcg_attach(struct ib
  	err = mlx4_multicast_attach(mdev->dev, &mqp->mqp, gid->raw, mqp->port,
  				    !!(mqp->flags &
  				       MLX4_IB_QP_BLOCK_MULTICAST_LOOPBACK),
 -				    prot, &reg_id.id);
 -	if (err)
 +				    prot, &reg_id);
 +	if (err) {
 +		pr_err("multicast attach op failed, err %d\n", err);
  		goto err_malloc;
++<<<<<<< HEAD
++=======
+ 
+ 	reg_id.mirror = 0;
+ 	if (mlx4_is_bonded(dev)) {
+ 		err = mlx4_multicast_attach(mdev->dev, &mqp->mqp, gid->raw,
+ 					    (mqp->port == 1) ? 2 : 1,
+ 					    !!(mqp->flags &
+ 					    MLX4_IB_QP_BLOCK_MULTICAST_LOOPBACK),
+ 					    prot, &reg_id.mirror);
+ 		if (err)
+ 			goto err_add;
++>>>>>>> 824c25c1abe7 (IB/mlx4: Always use the correct port for mirrored multicast attachments)
  	}
  
  	err = add_gid_entry(ibqp, gid);
* Unmerged path drivers/infiniband/hw/mlx4/main.c
