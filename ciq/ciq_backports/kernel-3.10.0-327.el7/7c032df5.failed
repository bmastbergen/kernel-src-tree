timekeeping: Provide internal ktime_t based data

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 7c032df5570388044b4efda3d9f4d2ffb96a3116
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/7c032df5.failed

The ktime_t based interfaces are used a lot in performance critical
code pathes. Add ktime_t based data so the interfaces don't have to
convert from the xtime/timespec based data.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: John Stultz <john.stultz@linaro.org>
(cherry picked from commit 7c032df5570388044b4efda3d9f4d2ffb96a3116)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/timekeeper_internal.h
diff --cc include/linux/timekeeper_internal.h
index 4e31044f893e,87e0992564f2..000000000000
--- a/include/linux/timekeeper_internal.h
+++ b/include/linux/timekeeper_internal.h
@@@ -18,6 -33,32 +18,35 @@@ struct timekeeper 
  	u32			mult;
  	/* The shift value of the current clocksource. */
  	u32			shift;
++<<<<<<< HEAD
++=======
+ 	/* Clock shifted nano seconds */
+ 	u64			xtime_nsec;
+ 
+ 	/* Monotonic base time */
+ 	ktime_t			base_mono;
+ 
+ 	/* Current CLOCK_REALTIME time in seconds */
+ 	u64			xtime_sec;
+ 	/* CLOCK_REALTIME to CLOCK_MONOTONIC offset */
+ 	struct timespec64	wall_to_monotonic;
+ 
+ 	/* Offset clock monotonic -> clock realtime */
+ 	ktime_t			offs_real;
+ 	/* Offset clock monotonic -> clock boottime */
+ 	ktime_t			offs_boot;
+ 	/* Offset clock monotonic -> clock tai */
+ 	ktime_t			offs_tai;
+ 
+ 	/* time spent in suspend */
+ 	struct timespec64	total_sleep_time;
+ 	/* The current UTC to TAI offset in seconds */
+ 	s32			tai_offset;
+ 
+ 	/* The raw monotonic time for the CLOCK_MONOTONIC_RAW posix clock. */
+ 	struct timespec64	raw_time;
+ 
++>>>>>>> 7c032df55703 (timekeeping: Provide internal ktime_t based data)
  	/* Number of clock cycles in one NTP interval. */
  	cycle_t			cycle_interval;
  	/* Last cycle value (also stored in clock->cycle_last) */
* Unmerged path include/linux/timekeeper_internal.h
diff --git a/kernel/time/timekeeping.c b/kernel/time/timekeeping.c
index ee61723d1a46..84c44674c26f 100644
--- a/kernel/time/timekeeping.c
+++ b/kernel/time/timekeeping.c
@@ -247,6 +247,26 @@ int pvclock_gtod_unregister_notifier(struct notifier_block *nb)
 }
 EXPORT_SYMBOL_GPL(pvclock_gtod_unregister_notifier);
 
+/*
+ * Update the ktime_t based scalar nsec members of the timekeeper
+ */
+static inline void tk_update_ktime_data(struct timekeeper *tk)
+{
+	s64 nsec;
+
+	/*
+	 * The xtime based monotonic readout is:
+	 *	nsec = (xtime_sec + wtm_sec) * 1e9 + wtm_nsec + now();
+	 * The ktime based monotonic readout is:
+	 *	nsec = base_mono + now();
+	 * ==> base_mono = (xtime_sec + wtm_sec) * 1e9 + wtm_nsec
+	 */
+	nsec = (s64)(tk->xtime_sec + tk->wall_to_monotonic.tv_sec);
+	nsec *= NSEC_PER_SEC;
+	nsec += tk->wall_to_monotonic.tv_nsec;
+	tk->base_mono = ns_to_ktime(nsec);
+}
+
 /* must hold timekeeper_lock */
 static void timekeeping_update(struct timekeeper *tk, unsigned int action)
 {
@@ -257,6 +277,8 @@ static void timekeeping_update(struct timekeeper *tk, unsigned int action)
 	update_vsyscall(tk);
 	update_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);
 
+	tk_update_ktime_data(tk);
+
 	if (action & TK_MIRROR)
 		memcpy(&shadow_timekeeper, &timekeeper, sizeof(timekeeper));
 }
