kvm: vmx: fix oops with explicit flexpriority=0 option

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit ad15a296471d40703be647b11ddc56df0f1c0cdd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/ad15a296.failed

A function pointer was not NULLed, causing kvm_vcpu_reload_apic_access_page to
go down the wrong path and OOPS when doing put_page(NULL).

This did not happen on old processors, only when setting the module option
explicitly.

	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit ad15a296471d40703be647b11ddc56df0f1c0cdd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index d826cfd07c86,81152a070b1f..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -5768,6 -5794,220 +5768,223 @@@ static void update_ple_window_actual_ma
  			                    ple_window_grow, INT_MIN);
  }
  
++<<<<<<< HEAD
++=======
+ static __init int hardware_setup(void)
+ {
+ 	int r = -ENOMEM, i, msr;
+ 
+ 	rdmsrl_safe(MSR_EFER, &host_efer);
+ 
+ 	for (i = 0; i < ARRAY_SIZE(vmx_msr_index); ++i)
+ 		kvm_define_shared_msr(i, vmx_msr_index[i]);
+ 
+ 	vmx_io_bitmap_a = (unsigned long *)__get_free_page(GFP_KERNEL);
+ 	if (!vmx_io_bitmap_a)
+ 		return r;
+ 
+ 	vmx_io_bitmap_b = (unsigned long *)__get_free_page(GFP_KERNEL);
+ 	if (!vmx_io_bitmap_b)
+ 		goto out;
+ 
+ 	vmx_msr_bitmap_legacy = (unsigned long *)__get_free_page(GFP_KERNEL);
+ 	if (!vmx_msr_bitmap_legacy)
+ 		goto out1;
+ 
+ 	vmx_msr_bitmap_legacy_x2apic =
+ 				(unsigned long *)__get_free_page(GFP_KERNEL);
+ 	if (!vmx_msr_bitmap_legacy_x2apic)
+ 		goto out2;
+ 
+ 	vmx_msr_bitmap_longmode = (unsigned long *)__get_free_page(GFP_KERNEL);
+ 	if (!vmx_msr_bitmap_longmode)
+ 		goto out3;
+ 
+ 	vmx_msr_bitmap_longmode_x2apic =
+ 				(unsigned long *)__get_free_page(GFP_KERNEL);
+ 	if (!vmx_msr_bitmap_longmode_x2apic)
+ 		goto out4;
+ 	vmx_vmread_bitmap = (unsigned long *)__get_free_page(GFP_KERNEL);
+ 	if (!vmx_vmread_bitmap)
+ 		goto out5;
+ 
+ 	vmx_vmwrite_bitmap = (unsigned long *)__get_free_page(GFP_KERNEL);
+ 	if (!vmx_vmwrite_bitmap)
+ 		goto out6;
+ 
+ 	memset(vmx_vmread_bitmap, 0xff, PAGE_SIZE);
+ 	memset(vmx_vmwrite_bitmap, 0xff, PAGE_SIZE);
+ 
+ 	/*
+ 	 * Allow direct access to the PC debug port (it is often used for I/O
+ 	 * delays, but the vmexits simply slow things down).
+ 	 */
+ 	memset(vmx_io_bitmap_a, 0xff, PAGE_SIZE);
+ 	clear_bit(0x80, vmx_io_bitmap_a);
+ 
+ 	memset(vmx_io_bitmap_b, 0xff, PAGE_SIZE);
+ 
+ 	memset(vmx_msr_bitmap_legacy, 0xff, PAGE_SIZE);
+ 	memset(vmx_msr_bitmap_longmode, 0xff, PAGE_SIZE);
+ 
+ 	if (setup_vmcs_config(&vmcs_config) < 0) {
+ 		r = -EIO;
+ 		goto out7;
+ 	}
+ 
+ 	if (boot_cpu_has(X86_FEATURE_NX))
+ 		kvm_enable_efer_bits(EFER_NX);
+ 
+ 	if (!cpu_has_vmx_vpid())
+ 		enable_vpid = 0;
+ 	if (!cpu_has_vmx_shadow_vmcs())
+ 		enable_shadow_vmcs = 0;
+ 	if (enable_shadow_vmcs)
+ 		init_vmcs_shadow_fields();
+ 
+ 	if (!cpu_has_vmx_ept() ||
+ 	    !cpu_has_vmx_ept_4levels()) {
+ 		enable_ept = 0;
+ 		enable_unrestricted_guest = 0;
+ 		enable_ept_ad_bits = 0;
+ 	}
+ 
+ 	if (!cpu_has_vmx_ept_ad_bits())
+ 		enable_ept_ad_bits = 0;
+ 
+ 	if (!cpu_has_vmx_unrestricted_guest())
+ 		enable_unrestricted_guest = 0;
+ 
+ 	if (!cpu_has_vmx_flexpriority())
+ 		flexpriority_enabled = 0;
+ 
+ 	/*
+ 	 * set_apic_access_page_addr() is used to reload apic access
+ 	 * page upon invalidation.  No need to do anything if not
+ 	 * using the APIC_ACCESS_ADDR VMCS field.
+ 	 */
+ 	if (!flexpriority_enabled)
+ 		kvm_x86_ops->set_apic_access_page_addr = NULL;
+ 
+ 	if (!cpu_has_vmx_tpr_shadow())
+ 		kvm_x86_ops->update_cr8_intercept = NULL;
+ 
+ 	if (enable_ept && !cpu_has_vmx_ept_2m_page())
+ 		kvm_disable_largepages();
+ 
+ 	if (!cpu_has_vmx_ple())
+ 		ple_gap = 0;
+ 
+ 	if (!cpu_has_vmx_apicv())
+ 		enable_apicv = 0;
+ 
+ 	if (enable_apicv)
+ 		kvm_x86_ops->update_cr8_intercept = NULL;
+ 	else {
+ 		kvm_x86_ops->hwapic_irr_update = NULL;
+ 		kvm_x86_ops->hwapic_isr_update = NULL;
+ 		kvm_x86_ops->deliver_posted_interrupt = NULL;
+ 		kvm_x86_ops->test_posted_interrupt = NULL;
+ 		kvm_x86_ops->sync_pir_to_irr = vmx_sync_pir_to_irr_dummy;
+ 	}
+ 
+ 	if (nested)
+ 		nested_vmx_setup_ctls_msrs();
+ 
+ 	vmx_disable_intercept_for_msr(MSR_FS_BASE, false);
+ 	vmx_disable_intercept_for_msr(MSR_GS_BASE, false);
+ 	vmx_disable_intercept_for_msr(MSR_KERNEL_GS_BASE, true);
+ 	vmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_CS, false);
+ 	vmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_ESP, false);
+ 	vmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_EIP, false);
+ 	vmx_disable_intercept_for_msr(MSR_IA32_BNDCFGS, true);
+ 
+ 	memcpy(vmx_msr_bitmap_legacy_x2apic,
+ 			vmx_msr_bitmap_legacy, PAGE_SIZE);
+ 	memcpy(vmx_msr_bitmap_longmode_x2apic,
+ 			vmx_msr_bitmap_longmode, PAGE_SIZE);
+ 
+ 	if (enable_apicv) {
+ 		for (msr = 0x800; msr <= 0x8ff; msr++)
+ 			vmx_disable_intercept_msr_read_x2apic(msr);
+ 
+ 		/* According SDM, in x2apic mode, the whole id reg is used.
+ 		 * But in KVM, it only use the highest eight bits. Need to
+ 		 * intercept it */
+ 		vmx_enable_intercept_msr_read_x2apic(0x802);
+ 		/* TMCCT */
+ 		vmx_enable_intercept_msr_read_x2apic(0x839);
+ 		/* TPR */
+ 		vmx_disable_intercept_msr_write_x2apic(0x808);
+ 		/* EOI */
+ 		vmx_disable_intercept_msr_write_x2apic(0x80b);
+ 		/* SELF-IPI */
+ 		vmx_disable_intercept_msr_write_x2apic(0x83f);
+ 	}
+ 
+ 	if (enable_ept) {
+ 		kvm_mmu_set_mask_ptes(0ull,
+ 			(enable_ept_ad_bits) ? VMX_EPT_ACCESS_BIT : 0ull,
+ 			(enable_ept_ad_bits) ? VMX_EPT_DIRTY_BIT : 0ull,
+ 			0ull, VMX_EPT_EXECUTABLE_MASK);
+ 		ept_set_mmio_spte_mask();
+ 		kvm_enable_tdp();
+ 	} else
+ 		kvm_disable_tdp();
+ 
+ 	update_ple_window_actual_max();
+ 
+ 	/*
+ 	 * Only enable PML when hardware supports PML feature, and both EPT
+ 	 * and EPT A/D bit features are enabled -- PML depends on them to work.
+ 	 */
+ 	if (!enable_ept || !enable_ept_ad_bits || !cpu_has_vmx_pml())
+ 		enable_pml = 0;
+ 
+ 	if (!enable_pml) {
+ 		kvm_x86_ops->slot_enable_log_dirty = NULL;
+ 		kvm_x86_ops->slot_disable_log_dirty = NULL;
+ 		kvm_x86_ops->flush_log_dirty = NULL;
+ 		kvm_x86_ops->enable_log_dirty_pt_masked = NULL;
+ 	}
+ 
+ 	return alloc_kvm_area();
+ 
+ out7:
+ 	free_page((unsigned long)vmx_vmwrite_bitmap);
+ out6:
+ 	free_page((unsigned long)vmx_vmread_bitmap);
+ out5:
+ 	free_page((unsigned long)vmx_msr_bitmap_longmode_x2apic);
+ out4:
+ 	free_page((unsigned long)vmx_msr_bitmap_longmode);
+ out3:
+ 	free_page((unsigned long)vmx_msr_bitmap_legacy_x2apic);
+ out2:
+ 	free_page((unsigned long)vmx_msr_bitmap_legacy);
+ out1:
+ 	free_page((unsigned long)vmx_io_bitmap_b);
+ out:
+ 	free_page((unsigned long)vmx_io_bitmap_a);
+ 
+     return r;
+ }
+ 
+ static __exit void hardware_unsetup(void)
+ {
+ 	free_page((unsigned long)vmx_msr_bitmap_legacy_x2apic);
+ 	free_page((unsigned long)vmx_msr_bitmap_longmode_x2apic);
+ 	free_page((unsigned long)vmx_msr_bitmap_legacy);
+ 	free_page((unsigned long)vmx_msr_bitmap_longmode);
+ 	free_page((unsigned long)vmx_io_bitmap_b);
+ 	free_page((unsigned long)vmx_io_bitmap_a);
+ 	free_page((unsigned long)vmx_vmwrite_bitmap);
+ 	free_page((unsigned long)vmx_vmread_bitmap);
+ 
+ 	free_kvm_area();
+ }
+ 
++>>>>>>> ad15a296471d (kvm: vmx: fix oops with explicit flexpriority=0 option)
  /*
   * Indicate a busy-waiting vcpu in spinlock. We do not enable the PAUSE
   * exiting, so only get here on cpu with PAUSE-Loop-Exiting.
* Unmerged path arch/x86/kvm/vmx.c
