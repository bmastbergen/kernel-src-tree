ACPI / video: Don't register acpi_video_resume notifier without backlight devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [acpi] video: Don't register acpi_video_resume notifier without backlight devices (Benjamin Tissoires) [1218354]
Rebuild_FUZZ: 95.48%
commit-author Hans de Goede <hdegoede@redhat.com>
commit 99678ed73a50d2df8b5f3c801e29e9b7a3e5aa85
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/99678ed7.failed

If we're not going to be registering any backlight devices then
acpi_video_resume is always nop, so don't register it in that case.

	Signed-off-by: Hans de Goede <hdegoede@redhat.com>
	Reviewed-by: Aaron Lu <aaron.lu@intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 99678ed73a50d2df8b5f3c801e29e9b7a3e5aa85)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/video.c
diff --cc drivers/acpi/video.c
index 6648fcea3723,ff79dff371fd..000000000000
--- a/drivers/acpi/video.c
+++ b/drivers/acpi/video.c
@@@ -1707,6 -1665,239 +1708,242 @@@ acpi_video_bus_match(acpi_handle handle
  	return AE_OK;
  }
  
++<<<<<<< HEAD
++=======
+ static void acpi_video_dev_register_backlight(struct acpi_video_device *device)
+ {
+ 	struct backlight_properties props;
+ 	struct pci_dev *pdev;
+ 	acpi_handle acpi_parent;
+ 	struct device *parent = NULL;
+ 	int result;
+ 	static int count;
+ 	char *name;
+ 
+ 	result = acpi_video_init_brightness(device);
+ 	if (result)
+ 		return;
+ 	name = kasprintf(GFP_KERNEL, "acpi_video%d", count);
+ 	if (!name)
+ 		return;
+ 	count++;
+ 
+ 	acpi_get_parent(device->dev->handle, &acpi_parent);
+ 
+ 	pdev = acpi_get_pci_dev(acpi_parent);
+ 	if (pdev) {
+ 		parent = &pdev->dev;
+ 		pci_dev_put(pdev);
+ 	}
+ 
+ 	memset(&props, 0, sizeof(struct backlight_properties));
+ 	props.type = BACKLIGHT_FIRMWARE;
+ 	props.max_brightness = device->brightness->count - 3;
+ 	device->backlight = backlight_device_register(name,
+ 						      parent,
+ 						      device,
+ 						      &acpi_backlight_ops,
+ 						      &props);
+ 	kfree(name);
+ 	if (IS_ERR(device->backlight))
+ 		return;
+ 
+ 	/*
+ 	 * Save current brightness level in case we have to restore it
+ 	 * before acpi_video_device_lcd_set_level() is called next time.
+ 	 */
+ 	device->backlight->props.brightness =
+ 			acpi_video_get_brightness(device->backlight);
+ 
+ 	device->cooling_dev = thermal_cooling_device_register("LCD",
+ 				device->dev, &video_cooling_ops);
+ 	if (IS_ERR(device->cooling_dev)) {
+ 		/*
+ 		 * Set cooling_dev to NULL so we don't crash trying to free it.
+ 		 * Also, why the hell we are returning early and not attempt to
+ 		 * register video output if cooling device registration failed?
+ 		 * -- dtor
+ 		 */
+ 		device->cooling_dev = NULL;
+ 		return;
+ 	}
+ 
+ 	dev_info(&device->dev->dev, "registered as cooling_device%d\n",
+ 		 device->cooling_dev->id);
+ 	result = sysfs_create_link(&device->dev->dev.kobj,
+ 			&device->cooling_dev->device.kobj,
+ 			"thermal_cooling");
+ 	if (result)
+ 		printk(KERN_ERR PREFIX "Create sysfs link\n");
+ 	result = sysfs_create_link(&device->cooling_dev->device.kobj,
+ 			&device->dev->dev.kobj, "device");
+ 	if (result)
+ 		printk(KERN_ERR PREFIX "Create sysfs link\n");
+ }
+ 
+ static int acpi_video_bus_register_backlight(struct acpi_video_bus *video)
+ {
+ 	struct acpi_video_device *dev;
+ 
+ 	if (!acpi_video_verify_backlight_support())
+ 		return 0;
+ 
+ 	mutex_lock(&video->device_list_lock);
+ 	list_for_each_entry(dev, &video->video_device_list, entry)
+ 		acpi_video_dev_register_backlight(dev);
+ 	mutex_unlock(&video->device_list_lock);
+ 
+ 	video->backlight_registered = true;
+ 
+ 	video->pm_nb.notifier_call = acpi_video_resume;
+ 	video->pm_nb.priority = 0;
+ 	return register_pm_notifier(&video->pm_nb);
+ }
+ 
+ static void acpi_video_dev_unregister_backlight(struct acpi_video_device *device)
+ {
+ 	if (device->backlight) {
+ 		backlight_device_unregister(device->backlight);
+ 		device->backlight = NULL;
+ 	}
+ 	if (device->brightness) {
+ 		kfree(device->brightness->levels);
+ 		kfree(device->brightness);
+ 		device->brightness = NULL;
+ 	}
+ 	if (device->cooling_dev) {
+ 		sysfs_remove_link(&device->dev->dev.kobj, "thermal_cooling");
+ 		sysfs_remove_link(&device->cooling_dev->device.kobj, "device");
+ 		thermal_cooling_device_unregister(device->cooling_dev);
+ 		device->cooling_dev = NULL;
+ 	}
+ }
+ 
+ static int acpi_video_bus_unregister_backlight(struct acpi_video_bus *video)
+ {
+ 	struct acpi_video_device *dev;
+ 	int error;
+ 
+ 	if (!video->backlight_registered)
+ 		return 0;
+ 
+ 	error = unregister_pm_notifier(&video->pm_nb);
+ 
+ 	mutex_lock(&video->device_list_lock);
+ 	list_for_each_entry(dev, &video->video_device_list, entry)
+ 		acpi_video_dev_unregister_backlight(dev);
+ 	mutex_unlock(&video->device_list_lock);
+ 
+ 	video->backlight_registered = false;
+ 
+ 	return error;
+ }
+ 
+ static void acpi_video_dev_add_notify_handler(struct acpi_video_device *device)
+ {
+ 	acpi_status status;
+ 	struct acpi_device *adev = device->dev;
+ 
+ 	status = acpi_install_notify_handler(adev->handle, ACPI_DEVICE_NOTIFY,
+ 					     acpi_video_device_notify, device);
+ 	if (ACPI_FAILURE(status))
+ 		dev_err(&adev->dev, "Error installing notify handler\n");
+ 	else
+ 		device->flags.notify = 1;
+ }
+ 
+ static int acpi_video_bus_add_notify_handler(struct acpi_video_bus *video)
+ {
+ 	struct input_dev *input;
+ 	struct acpi_video_device *dev;
+ 	int error;
+ 
+ 	video->input = input = input_allocate_device();
+ 	if (!input) {
+ 		error = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	error = acpi_video_bus_start_devices(video);
+ 	if (error)
+ 		goto err_free_input;
+ 
+ 	snprintf(video->phys, sizeof(video->phys),
+ 			"%s/video/input0", acpi_device_hid(video->device));
+ 
+ 	input->name = acpi_device_name(video->device);
+ 	input->phys = video->phys;
+ 	input->id.bustype = BUS_HOST;
+ 	input->id.product = 0x06;
+ 	input->dev.parent = &video->device->dev;
+ 	input->evbit[0] = BIT(EV_KEY);
+ 	set_bit(KEY_SWITCHVIDEOMODE, input->keybit);
+ 	set_bit(KEY_VIDEO_NEXT, input->keybit);
+ 	set_bit(KEY_VIDEO_PREV, input->keybit);
+ 	set_bit(KEY_BRIGHTNESS_CYCLE, input->keybit);
+ 	set_bit(KEY_BRIGHTNESSUP, input->keybit);
+ 	set_bit(KEY_BRIGHTNESSDOWN, input->keybit);
+ 	set_bit(KEY_BRIGHTNESS_ZERO, input->keybit);
+ 	set_bit(KEY_DISPLAY_OFF, input->keybit);
+ 
+ 	error = input_register_device(input);
+ 	if (error)
+ 		goto err_stop_dev;
+ 
+ 	mutex_lock(&video->device_list_lock);
+ 	list_for_each_entry(dev, &video->video_device_list, entry)
+ 		acpi_video_dev_add_notify_handler(dev);
+ 	mutex_unlock(&video->device_list_lock);
+ 
+ 	return 0;
+ 
+ err_stop_dev:
+ 	acpi_video_bus_stop_devices(video);
+ err_free_input:
+ 	input_free_device(input);
+ 	video->input = NULL;
+ out:
+ 	return error;
+ }
+ 
+ static void acpi_video_dev_remove_notify_handler(struct acpi_video_device *dev)
+ {
+ 	if (dev->flags.notify) {
+ 		acpi_remove_notify_handler(dev->dev->handle, ACPI_DEVICE_NOTIFY,
+ 					   acpi_video_device_notify);
+ 		dev->flags.notify = 0;
+ 	}
+ }
+ 
+ static void acpi_video_bus_remove_notify_handler(struct acpi_video_bus *video)
+ {
+ 	struct acpi_video_device *dev;
+ 
+ 	mutex_lock(&video->device_list_lock);
+ 	list_for_each_entry(dev, &video->video_device_list, entry)
+ 		acpi_video_dev_remove_notify_handler(dev);
+ 	mutex_unlock(&video->device_list_lock);
+ 
+ 	acpi_video_bus_stop_devices(video);
+ 	input_unregister_device(video->input);
+ 	video->input = NULL;
+ }
+ 
+ static int acpi_video_bus_put_devices(struct acpi_video_bus *video)
+ {
+ 	struct acpi_video_device *dev, *next;
+ 
+ 	mutex_lock(&video->device_list_lock);
+ 	list_for_each_entry_safe(dev, next, &video->video_device_list, entry) {
+ 		list_del(&dev->entry);
+ 		kfree(dev);
+ 	}
+ 	mutex_unlock(&video->device_list_lock);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 99678ed73a50 (ACPI / video: Don't register acpi_video_resume notifier without backlight devices)
  static int instance;
  
  static int acpi_video_bus_add(struct acpi_device *device)
* Unmerged path drivers/acpi/video.c
