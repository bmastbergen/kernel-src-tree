openvswitch: Add support for OVS_FLOW_ATTR_PROBE.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] openvswitch: Add support for OVS_FLOW_ATTR_PROBE (Jiri Benc) [1156461 1211348]
Rebuild_FUZZ: 98.97%
commit-author Jarno Rajahalme <jrajahalme@nicira.com>
commit 05da5898a96c05e32aa9850c9cd89eef29471b13
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/05da5898.failed

This new flag is useful for suppressing error logging while probing
for datapath features using flow commands.  For backwards
compatibility reasons the commands are executed normally, but error
logging is suppressed.

	Signed-off-by: Jarno Rajahalme <jrajahalme@nicira.com>
	Signed-off-by: Pravin B Shelar <pshelar@nicira.com>
(cherry picked from commit 05da5898a96c05e32aa9850c9cd89eef29471b13)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/openvswitch/datapath.c
#	net/openvswitch/flow_netlink.c
#	net/openvswitch/flow_netlink.h
diff --cc net/openvswitch/datapath.c
index 4b2e0eb68aa2,ab141d49bb9d..000000000000
--- a/net/openvswitch/datapath.c
+++ b/net/openvswitch/datapath.c
@@@ -563,13 -564,8 +564,17 @@@ static int ovs_packet_cmd_execute(struc
  	if (err)
  		goto err_flow_free;
  
 +	acts = ovs_nla_alloc_flow_actions(nla_len(a[OVS_PACKET_ATTR_ACTIONS]));
 +	err = PTR_ERR(acts);
 +	if (IS_ERR(acts))
 +		goto err_flow_free;
 +
  	err = ovs_nla_copy_actions(a[OVS_PACKET_ATTR_ACTIONS],
++<<<<<<< HEAD
 +				   &flow->key, 0, &acts);
++=======
+ 				   &flow->key, &acts, log);
++>>>>>>> 05da5898a96c (openvswitch: Add support for OVS_FLOW_ATTR_PROBE.)
  	if (err)
  		goto err_flow_free;
  
@@@ -892,16 -888,11 +898,23 @@@ static int ovs_flow_cmd_new(struct sk_b
  	ovs_flow_mask_key(&new_flow->key, &new_flow->unmasked_key, &mask);
  
  	/* Validate actions. */
 +	acts = ovs_nla_alloc_flow_actions(nla_len(a[OVS_FLOW_ATTR_ACTIONS]));
 +	error = PTR_ERR(acts);
 +	if (IS_ERR(acts))
 +		goto err_kfree_flow;
 +
  	error = ovs_nla_copy_actions(a[OVS_FLOW_ATTR_ACTIONS], &new_flow->key,
++<<<<<<< HEAD
 +				     0, &acts);
 +	if (error) {
 +		OVS_NLERR("Flow actions may not be safe on all matching packets.\n");
 +		goto err_kfree_acts;
++=======
+ 				     &acts, log);
+ 	if (error) {
+ 		OVS_NLERR(log, "Flow actions may not be safe on all matching packets.");
+ 		goto err_kfree_flow;
++>>>>>>> 05da5898a96c (openvswitch: Add support for OVS_FLOW_ATTR_PROBE.)
  	}
  
  	reply = ovs_flow_cmd_alloc_info(acts, info, false);
@@@ -992,23 -984,21 +1006,31 @@@ error
  	return error;
  }
  
 -/* Factor out action copy to avoid "Wframe-larger-than=1024" warning. */
  static struct sw_flow_actions *get_flow_actions(const struct nlattr *a,
  						const struct sw_flow_key *key,
- 						const struct sw_flow_mask *mask)
+ 						const struct sw_flow_mask *mask,
+ 						bool log)
  {
  	struct sw_flow_actions *acts;
  	struct sw_flow_key masked_key;
  	int error;
  
 +	acts = ovs_nla_alloc_flow_actions(nla_len(a));
 +	if (IS_ERR(acts))
 +		return acts;
 +
  	ovs_flow_mask_key(&masked_key, key, mask);
++<<<<<<< HEAD
 +	error = ovs_nla_copy_actions(a, &masked_key, 0, &acts);
 +	if (error) {
 +		OVS_NLERR("Flow actions may not be safe on all matching packets.\n");
 +		kfree(acts);
++=======
+ 	error = ovs_nla_copy_actions(a, &masked_key, &acts, log);
+ 	if (error) {
+ 		OVS_NLERR(log,
+ 			  "Actions may not be safe on all matching packets");
++>>>>>>> 05da5898a96c (openvswitch: Add support for OVS_FLOW_ATTR_PROBE.)
  		return ERR_PTR(error);
  	}
  
diff --cc net/openvswitch/flow_netlink.c
index 6ce84384128b,c0d066def228..000000000000
--- a/net/openvswitch/flow_netlink.c
+++ b/net/openvswitch/flow_netlink.c
@@@ -1289,7 -1341,7 +1314,11 @@@ nla_put_failure
  
  #define MAX_ACTIONS_BUFSIZE	(32 * 1024)
  
++<<<<<<< HEAD
 +struct sw_flow_actions *ovs_nla_alloc_flow_actions(int size)
++=======
+ static struct sw_flow_actions *nla_alloc_flow_actions(int size, bool log)
++>>>>>>> 05da5898a96c (openvswitch: Add support for OVS_FLOW_ATTR_PROBE.)
  {
  	struct sw_flow_actions *sfa;
  
@@@ -1334,7 -1386,7 +1363,11 @@@ static struct nlattr *reserve_sfa_size(
  		new_acts_size = MAX_ACTIONS_BUFSIZE;
  	}
  
++<<<<<<< HEAD
 +	acts = ovs_nla_alloc_flow_actions(new_acts_size);
++=======
+ 	acts = nla_alloc_flow_actions(new_acts_size, log);
++>>>>>>> 05da5898a96c (openvswitch: Add support for OVS_FLOW_ATTR_PROBE.)
  	if (IS_ERR(acts))
  		return (void *)acts;
  
@@@ -1401,9 -1453,15 +1434,21 @@@ static inline void add_nested_action_en
  	a->nla_len = sfa->actions_len - st_offset;
  }
  
++<<<<<<< HEAD
 +static int validate_and_copy_sample(const struct nlattr *attr,
 +				    const struct sw_flow_key *key, int depth,
 +				    struct sw_flow_actions **sfa)
++=======
+ static int __ovs_nla_copy_actions(const struct nlattr *attr,
+ 				  const struct sw_flow_key *key,
+ 				  int depth, struct sw_flow_actions **sfa,
+ 				  __be16 eth_type, __be16 vlan_tci, bool log);
+ 
+ static int validate_and_copy_sample(const struct nlattr *attr,
+ 				    const struct sw_flow_key *key, int depth,
+ 				    struct sw_flow_actions **sfa,
+ 				    __be16 eth_type, __be16 vlan_tci, bool log)
++>>>>>>> 05da5898a96c (openvswitch: Add support for OVS_FLOW_ATTR_PROBE.)
  {
  	const struct nlattr *attrs[OVS_SAMPLE_ATTR_MAX + 1];
  	const struct nlattr *probability, *actions;
@@@ -1440,7 -1498,8 +1485,12 @@@
  	if (st_acts < 0)
  		return st_acts;
  
++<<<<<<< HEAD
 +	err = ovs_nla_copy_actions(actions, key, depth + 1, sfa);
++=======
+ 	err = __ovs_nla_copy_actions(actions, key, depth + 1, sfa,
+ 				     eth_type, vlan_tci, log);
++>>>>>>> 05da5898a96c (openvswitch: Add support for OVS_FLOW_ATTR_PROBE.)
  	if (err)
  		return err;
  
@@@ -1548,7 -1607,7 +1598,11 @@@ static int validate_and_copy_set_tun(co
  static int validate_set(const struct nlattr *a,
  			const struct sw_flow_key *flow_key,
  			struct sw_flow_actions **sfa,
++<<<<<<< HEAD
 +			bool *set_tun)
++=======
+ 			bool *set_tun, __be16 eth_type, bool log)
++>>>>>>> 05da5898a96c (openvswitch: Add support for OVS_FLOW_ATTR_PROBE.)
  {
  	const struct nlattr *ovs_key = nla_data(a);
  	int key_type = nla_type(ovs_key);
@@@ -1573,8 -1632,11 +1627,8 @@@
  		break;
  
  	case OVS_KEY_ATTR_TUNNEL:
 -		if (eth_p_mpls(eth_type))
 -			return -EINVAL;
 -
  		*set_tun = true;
- 		err = validate_and_copy_set_tun(a, sfa);
+ 		err = validate_and_copy_set_tun(a, sfa, log);
  		if (err)
  			return err;
  		break;
@@@ -1675,12 -1742,13 +1729,19 @@@ static int copy_action(const struct nla
  	return 0;
  }
  
++<<<<<<< HEAD
 +int ovs_nla_copy_actions(const struct nlattr *attr,
 +			 const struct sw_flow_key *key,
 +			 int depth,
 +			 struct sw_flow_actions **sfa)
++=======
+ static int __ovs_nla_copy_actions(const struct nlattr *attr,
+ 				  const struct sw_flow_key *key,
+ 				  int depth, struct sw_flow_actions **sfa,
+ 				  __be16 eth_type, __be16 vlan_tci, bool log)
++>>>>>>> 05da5898a96c (openvswitch: Add support for OVS_FLOW_ATTR_PROBE.)
  {
  	const struct nlattr *a;
 -	bool out_tnl_port = false;
  	int rem, err;
  
  	if (depth >= SAMPLE_ACTION_DEPTH)
@@@ -1750,14 -1824,60 +1811,24 @@@
  		case OVS_ACTION_ATTR_RECIRC:
  			break;
  
 -		case OVS_ACTION_ATTR_PUSH_MPLS: {
 -			const struct ovs_action_push_mpls *mpls = nla_data(a);
 -
 -			/* Networking stack do not allow simultaneous Tunnel
 -			 * and MPLS GSO.
 -			 */
 -			if (out_tnl_port)
 -				return -EINVAL;
 -
 -			if (!eth_p_mpls(mpls->mpls_ethertype))
 -				return -EINVAL;
 -			/* Prohibit push MPLS other than to a white list
 -			 * for packets that have a known tag order.
 -			 */
 -			if (vlan_tci & htons(VLAN_TAG_PRESENT) ||
 -			    (eth_type != htons(ETH_P_IP) &&
 -			     eth_type != htons(ETH_P_IPV6) &&
 -			     eth_type != htons(ETH_P_ARP) &&
 -			     eth_type != htons(ETH_P_RARP) &&
 -			     !eth_p_mpls(eth_type)))
 -				return -EINVAL;
 -			eth_type = mpls->mpls_ethertype;
 -			break;
 -		}
 -
 -		case OVS_ACTION_ATTR_POP_MPLS:
 -			if (vlan_tci & htons(VLAN_TAG_PRESENT) ||
 -			    !eth_p_mpls(eth_type))
 -				return -EINVAL;
 -
 -			/* Disallow subsequent L2.5+ set and mpls_pop actions
 -			 * as there is no check here to ensure that the new
 -			 * eth_type is valid and thus set actions could
 -			 * write off the end of the packet or otherwise
 -			 * corrupt it.
 -			 *
 -			 * Support for these actions is planned using packet
 -			 * recirculation.
 -			 */
 -			eth_type = htons(0);
 -			break;
 -
  		case OVS_ACTION_ATTR_SET:
++<<<<<<< HEAD
 +			err = validate_set(a, key, sfa, &skip_copy);
++=======
+ 			err = validate_set(a, key, sfa,
+ 					   &out_tnl_port, eth_type, log);
++>>>>>>> 05da5898a96c (openvswitch: Add support for OVS_FLOW_ATTR_PROBE.)
  			if (err)
  				return err;
 -
 -			skip_copy = out_tnl_port;
  			break;
  
  		case OVS_ACTION_ATTR_SAMPLE:
++<<<<<<< HEAD
 +			err = validate_and_copy_sample(a, key, depth, sfa);
++=======
+ 			err = validate_and_copy_sample(a, key, depth, sfa,
+ 						       eth_type, vlan_tci, log);
++>>>>>>> 05da5898a96c (openvswitch: Add support for OVS_FLOW_ATTR_PROBE.)
  			if (err)
  				return err;
  			skip_copy = true;
@@@ -1780,6 -1900,24 +1851,27 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ int ovs_nla_copy_actions(const struct nlattr *attr,
+ 			 const struct sw_flow_key *key,
+ 			 struct sw_flow_actions **sfa, bool log)
+ {
+ 	int err;
+ 
+ 	*sfa = nla_alloc_flow_actions(nla_len(attr), log);
+ 	if (IS_ERR(*sfa))
+ 		return PTR_ERR(*sfa);
+ 
+ 	err = __ovs_nla_copy_actions(attr, key, 0, sfa, key->eth.type,
+ 				     key->eth.tci, log);
+ 	if (err)
+ 		kfree(*sfa);
+ 
+ 	return err;
+ }
+ 
++>>>>>>> 05da5898a96c (openvswitch: Add support for OVS_FLOW_ATTR_PROBE.)
  static int sample_action_to_attr(const struct nlattr *attr, struct sk_buff *skb)
  {
  	const struct nlattr *a;
diff --cc net/openvswitch/flow_netlink.h
index fa24e1dc958c,577f12be3459..000000000000
--- a/net/openvswitch/flow_netlink.h
+++ b/net/openvswitch/flow_netlink.h
@@@ -54,8 -54,8 +54,13 @@@ int ovs_nla_put_egress_tunnel_key(struc
  				  const struct ovs_tunnel_info *);
  
  int ovs_nla_copy_actions(const struct nlattr *attr,
++<<<<<<< HEAD
 +			 const struct sw_flow_key *key, int depth,
 +			 struct sw_flow_actions **sfa);
++=======
+ 			 const struct sw_flow_key *key,
+ 			 struct sw_flow_actions **sfa, bool log);
++>>>>>>> 05da5898a96c (openvswitch: Add support for OVS_FLOW_ATTR_PROBE.)
  int ovs_nla_put_actions(const struct nlattr *attr,
  			int len, struct sk_buff *skb);
  
diff --git a/include/uapi/linux/openvswitch.h b/include/uapi/linux/openvswitch.h
index 0d7501a221c7..142f14321fe9 100644
--- a/include/uapi/linux/openvswitch.h
+++ b/include/uapi/linux/openvswitch.h
@@ -450,6 +450,8 @@ enum ovs_flow_attr {
 	OVS_FLOW_ATTR_USED,      /* u64 msecs last used in monotonic time. */
 	OVS_FLOW_ATTR_CLEAR,     /* Flag to clear stats, tcp_flags, used. */
 	OVS_FLOW_ATTR_MASK,      /* Sequence of OVS_KEY_ATTR_* attributes. */
+	OVS_FLOW_ATTR_PROBE,     /* Flow operation is a feature probe, error
+				  * logging should be suppressed. */
 	__OVS_FLOW_ATTR_MAX
 };
 
* Unmerged path net/openvswitch/datapath.c
diff --git a/net/openvswitch/datapath.h b/net/openvswitch/datapath.h
index 8389c1d68e57..3ece94563079 100644
--- a/net/openvswitch/datapath.h
+++ b/net/openvswitch/datapath.h
@@ -199,9 +199,9 @@ void ovs_dp_notify_wq(struct work_struct *work);
 int action_fifos_init(void);
 void action_fifos_exit(void);
 
-#define OVS_NLERR(fmt, ...)					\
+#define OVS_NLERR(logging_allowed, fmt, ...)			\
 do {								\
-	if (net_ratelimit())					\
-		pr_info("netlink: " fmt, ##__VA_ARGS__);	\
+	if (logging_allowed && net_ratelimit())			\
+		pr_info("netlink: " fmt "\n", ##__VA_ARGS__);	\
 } while (0)
 #endif /* datapath.h */
diff --git a/net/openvswitch/flow.c b/net/openvswitch/flow.c
index a11bded3c4b5..9208d40ccf1e 100644
--- a/net/openvswitch/flow.c
+++ b/net/openvswitch/flow.c
@@ -682,12 +682,12 @@ int ovs_flow_key_extract(const struct ovs_tunnel_info *tun_info,
 
 int ovs_flow_key_extract_userspace(const struct nlattr *attr,
 				   struct sk_buff *skb,
-				   struct sw_flow_key *key)
+				   struct sw_flow_key *key, bool log)
 {
 	int err;
 
 	/* Extract metadata from netlink attributes. */
-	err = ovs_nla_get_flow_metadata(attr, key);
+	err = ovs_nla_get_flow_metadata(attr, key, log);
 	if (err)
 		return err;
 
diff --git a/net/openvswitch/flow.h b/net/openvswitch/flow.h
index 07a475fcc682..b5135201fdba 100644
--- a/net/openvswitch/flow.h
+++ b/net/openvswitch/flow.h
@@ -252,6 +252,6 @@ int ovs_flow_key_extract(const struct ovs_tunnel_info *tun_info,
 /* Extract key from packet coming from userspace. */
 int ovs_flow_key_extract_userspace(const struct nlattr *attr,
 				   struct sk_buff *skb,
-				   struct sw_flow_key *key);
+				   struct sw_flow_key *key, bool log);
 
 #endif /* flow.h */
* Unmerged path net/openvswitch/flow_netlink.c
* Unmerged path net/openvswitch/flow_netlink.h
