i40e: get rid of unused locals

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Jesse Brandeburg <jesse.brandeburg@intel.com>
commit 0f575bf3382d5bdb58ba571b1fd573b994bb11ba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/0f575bf3.failed

These changes just remove unused variables and any code that uses them
as the results of storing into these variables doesn't have any
side effects that I can see or provide any benefit.

Change-ID: I8a5ec7132ff1443d23aae729cef94beaaaf19e3a
	Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
	Tested-by: Jim Young <james.m.young@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 0f575bf3382d5bdb58ba571b1fd573b994bb11ba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_dcb.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_dcb.c
index eb67091781fd,2547aa21b2ca..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_dcb.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_dcb.c
@@@ -407,6 -407,164 +407,167 @@@ free_mem
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * i40e_cee_to_dcb_v1_config
+  * @cee_cfg: pointer to CEE v1 response configuration struct
+  * @dcbcfg: DCB configuration struct
+  *
+  * Convert CEE v1 configuration from firmware to DCB configuration
+  **/
+ static void i40e_cee_to_dcb_v1_config(
+ 			struct i40e_aqc_get_cee_dcb_cfg_v1_resp *cee_cfg,
+ 			struct i40e_dcbx_config *dcbcfg)
+ {
+ 	u16 status, tlv_status = le16_to_cpu(cee_cfg->tlv_status);
+ 	u16 app_prio = le16_to_cpu(cee_cfg->oper_app_prio);
+ 	u8 i, tc, err;
+ 
+ 	/* CEE PG data to ETS config */
+ 	dcbcfg->etscfg.maxtcs = cee_cfg->oper_num_tc;
+ 
+ 	for (i = 0; i < 4; i++) {
+ 		tc = (u8)((cee_cfg->oper_prio_tc[i] &
+ 			 I40E_CEE_PGID_PRIO_1_MASK) >>
+ 			 I40E_CEE_PGID_PRIO_1_SHIFT);
+ 		dcbcfg->etscfg.prioritytable[i*2] =  tc;
+ 		tc = (u8)((cee_cfg->oper_prio_tc[i] &
+ 			 I40E_CEE_PGID_PRIO_0_MASK) >>
+ 			 I40E_CEE_PGID_PRIO_0_SHIFT);
+ 		dcbcfg->etscfg.prioritytable[i*2 + 1] = tc;
+ 	}
+ 
+ 	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)
+ 		dcbcfg->etscfg.tcbwtable[i] = cee_cfg->oper_tc_bw[i];
+ 
+ 	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {
+ 		if (dcbcfg->etscfg.prioritytable[i] == I40E_CEE_PGID_STRICT) {
+ 			/* Map it to next empty TC */
+ 			dcbcfg->etscfg.prioritytable[i] =
+ 						cee_cfg->oper_num_tc - 1;
+ 			dcbcfg->etscfg.tsatable[i] = I40E_IEEE_TSA_STRICT;
+ 		} else {
+ 			dcbcfg->etscfg.tsatable[i] = I40E_IEEE_TSA_ETS;
+ 		}
+ 	}
+ 
+ 	/* CEE PFC data to ETS config */
+ 	dcbcfg->pfc.pfcenable = cee_cfg->oper_pfc_en;
+ 	dcbcfg->pfc.pfccap = I40E_MAX_TRAFFIC_CLASS;
+ 
+ 	status = (tlv_status & I40E_AQC_CEE_APP_STATUS_MASK) >>
+ 		  I40E_AQC_CEE_APP_STATUS_SHIFT;
+ 	err = (status & I40E_TLV_STATUS_ERR) ? 1 : 0;
+ 	/* Add APPs if Error is False */
+ 	if (!err) {
+ 		/* CEE operating configuration supports FCoE/iSCSI/FIP only */
+ 		dcbcfg->numapps = I40E_CEE_OPER_MAX_APPS;
+ 
+ 		/* FCoE APP */
+ 		dcbcfg->app[0].priority =
+ 			(app_prio & I40E_AQC_CEE_APP_FCOE_MASK) >>
+ 			 I40E_AQC_CEE_APP_FCOE_SHIFT;
+ 		dcbcfg->app[0].selector = I40E_APP_SEL_ETHTYPE;
+ 		dcbcfg->app[0].protocolid = I40E_APP_PROTOID_FCOE;
+ 
+ 		/* iSCSI APP */
+ 		dcbcfg->app[1].priority =
+ 			(app_prio & I40E_AQC_CEE_APP_ISCSI_MASK) >>
+ 			 I40E_AQC_CEE_APP_ISCSI_SHIFT;
+ 		dcbcfg->app[1].selector = I40E_APP_SEL_TCPIP;
+ 		dcbcfg->app[1].protocolid = I40E_APP_PROTOID_ISCSI;
+ 
+ 		/* FIP APP */
+ 		dcbcfg->app[2].priority =
+ 			(app_prio & I40E_AQC_CEE_APP_FIP_MASK) >>
+ 			 I40E_AQC_CEE_APP_FIP_SHIFT;
+ 		dcbcfg->app[2].selector = I40E_APP_SEL_ETHTYPE;
+ 		dcbcfg->app[2].protocolid = I40E_APP_PROTOID_FIP;
+ 	}
+ }
+ 
+ /**
+  * i40e_cee_to_dcb_config
+  * @cee_cfg: pointer to CEE configuration struct
+  * @dcbcfg: DCB configuration struct
+  *
+  * Convert CEE configuration from firmware to DCB configuration
+  **/
+ static void i40e_cee_to_dcb_config(
+ 				struct i40e_aqc_get_cee_dcb_cfg_resp *cee_cfg,
+ 				struct i40e_dcbx_config *dcbcfg)
+ {
+ 	u32 status, tlv_status = le32_to_cpu(cee_cfg->tlv_status);
+ 	u16 app_prio = le16_to_cpu(cee_cfg->oper_app_prio);
+ 	u8 i, tc, err, sync, oper;
+ 
+ 	/* CEE PG data to ETS config */
+ 	dcbcfg->etscfg.maxtcs = cee_cfg->oper_num_tc;
+ 
+ 	for (i = 0; i < 4; i++) {
+ 		tc = (u8)((cee_cfg->oper_prio_tc[i] &
+ 			 I40E_CEE_PGID_PRIO_1_MASK) >>
+ 			 I40E_CEE_PGID_PRIO_1_SHIFT);
+ 		dcbcfg->etscfg.prioritytable[i*2] =  tc;
+ 		tc = (u8)((cee_cfg->oper_prio_tc[i] &
+ 			 I40E_CEE_PGID_PRIO_0_MASK) >>
+ 			 I40E_CEE_PGID_PRIO_0_SHIFT);
+ 		dcbcfg->etscfg.prioritytable[i*2 + 1] = tc;
+ 	}
+ 
+ 	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)
+ 		dcbcfg->etscfg.tcbwtable[i] = cee_cfg->oper_tc_bw[i];
+ 
+ 	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {
+ 		if (dcbcfg->etscfg.prioritytable[i] == I40E_CEE_PGID_STRICT) {
+ 			/* Map it to next empty TC */
+ 			dcbcfg->etscfg.prioritytable[i] =
+ 						cee_cfg->oper_num_tc - 1;
+ 			dcbcfg->etscfg.tsatable[i] = I40E_IEEE_TSA_STRICT;
+ 		} else {
+ 			dcbcfg->etscfg.tsatable[i] = I40E_IEEE_TSA_ETS;
+ 		}
+ 	}
+ 
+ 	/* CEE PFC data to ETS config */
+ 	dcbcfg->pfc.pfcenable = cee_cfg->oper_pfc_en;
+ 	dcbcfg->pfc.pfccap = I40E_MAX_TRAFFIC_CLASS;
+ 
+ 	status = (tlv_status & I40E_AQC_CEE_APP_STATUS_MASK) >>
+ 		  I40E_AQC_CEE_APP_STATUS_SHIFT;
+ 	err = (status & I40E_TLV_STATUS_ERR) ? 1 : 0;
+ 	sync = (status & I40E_TLV_STATUS_SYNC) ? 1 : 0;
+ 	oper = (status & I40E_TLV_STATUS_OPER) ? 1 : 0;
+ 	/* Add APPs if Error is False and Oper/Sync is True */
+ 	if (!err && sync && oper) {
+ 		/* CEE operating configuration supports FCoE/iSCSI/FIP only */
+ 		dcbcfg->numapps = I40E_CEE_OPER_MAX_APPS;
+ 
+ 		/* FCoE APP */
+ 		dcbcfg->app[0].priority =
+ 			(app_prio & I40E_AQC_CEE_APP_FCOE_MASK) >>
+ 			 I40E_AQC_CEE_APP_FCOE_SHIFT;
+ 		dcbcfg->app[0].selector = I40E_APP_SEL_ETHTYPE;
+ 		dcbcfg->app[0].protocolid = I40E_APP_PROTOID_FCOE;
+ 
+ 		/* iSCSI APP */
+ 		dcbcfg->app[1].priority =
+ 			(app_prio & I40E_AQC_CEE_APP_ISCSI_MASK) >>
+ 			 I40E_AQC_CEE_APP_ISCSI_SHIFT;
+ 		dcbcfg->app[1].selector = I40E_APP_SEL_TCPIP;
+ 		dcbcfg->app[1].protocolid = I40E_APP_PROTOID_ISCSI;
+ 
+ 		/* FIP APP */
+ 		dcbcfg->app[2].priority =
+ 			(app_prio & I40E_AQC_CEE_APP_FIP_MASK) >>
+ 			 I40E_AQC_CEE_APP_FIP_SHIFT;
+ 		dcbcfg->app[2].selector = I40E_APP_SEL_ETHTYPE;
+ 		dcbcfg->app[2].protocolid = I40E_APP_PROTOID_FIP;
+ 	}
+ }
+ 
+ /**
++>>>>>>> 0f575bf3382d (i40e: get rid of unused locals)
   * i40e_get_dcb_config
   * @hw: pointer to the hw struct
   *
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_dcb.c
diff --git a/drivers/net/ethernet/intel/i40e/i40e_nvm.c b/drivers/net/ethernet/intel/i40e/i40e_nvm.c
index cd1be0c4f47a..a2c867c75b4f 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_nvm.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_nvm.c
@@ -814,13 +814,12 @@ static enum i40e_nvmupd_cmd i40e_nvmupd_validate_command(struct i40e_hw *hw,
 						 int *errno)
 {
 	enum i40e_nvmupd_cmd upd_cmd;
-	u8 transaction, module;
+	u8 transaction;
 
 	/* anything that doesn't match a recognized case is an error */
 	upd_cmd = I40E_NVMUPD_INVALID;
 
 	transaction = i40e_nvmupd_get_transaction(cmd->config);
-	module = i40e_nvmupd_get_module(cmd->config);
 
 	/* limits on data size */
 	if ((cmd->data_size < 1) ||
