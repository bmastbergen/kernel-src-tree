bonding: display xmit_hash_policy for non-dynamic-tlb mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Mahesh Bandewar <maheshb@google.com>
commit d7021325a2ea5aaf4458097341c988f9dc93491f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/d7021325.failed

It's a trivial fix to display xmit_hash_policy for this new TLB mode
since it uses transmit-hash-poilicy as part of bonding-master info
(/proc/net/bonding/<bonding-interface).

	Signed-off-by: Mahesh Bandewar <maheshb@google.com>
	Reviewed-by: Nikolay Aleksandrov <nikolay@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d7021325a2ea5aaf4458097341c988f9dc93491f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_procfs.c
#	drivers/net/bonding/bonding.h
diff --cc drivers/net/bonding/bond_procfs.c
index 96f629d77b41,a3948f8d1e53..000000000000
--- a/drivers/net/bonding/bond_procfs.c
+++ b/drivers/net/bonding/bond_procfs.c
@@@ -71,20 -73,23 +71,26 @@@ static void bond_info_show_master(struc
  
  	seq_printf(seq, "\n");
  
++<<<<<<< HEAD
 +	if (bond->params.mode == BOND_MODE_XOR ||
 +		bond->params.mode == BOND_MODE_8023AD) {
++=======
+ 	if (bond_mode_uses_xmit_hash(bond)) {
+ 		optval = bond_opt_get_val(BOND_OPT_XMIT_HASH,
+ 					  bond->params.xmit_policy);
++>>>>>>> d7021325a2ea (bonding: display xmit_hash_policy for non-dynamic-tlb mode)
  		seq_printf(seq, "Transmit Hash Policy: %s (%d)\n",
 -			   optval->string, bond->params.xmit_policy);
 +			xmit_hashtype_tbl[bond->params.xmit_policy].modename,
 +			bond->params.xmit_policy);
  	}
  
 -	if (bond_uses_primary(bond)) {
 -		primary = rcu_dereference(bond->primary_slave);
 +	if (USES_PRIMARY(bond->params.mode)) {
  		seq_printf(seq, "Primary Slave: %s",
 -			   primary ? primary->dev->name : "None");
 -		if (primary) {
 -			optval = bond_opt_get_val(BOND_OPT_PRIMARY_RESELECT,
 -						  bond->params.primary_reselect);
 +			   (bond->primary_slave) ?
 +			   bond->primary_slave->dev->name : "None");
 +		if (bond->primary_slave)
  			seq_printf(seq, " (primary_reselect %s)",
 -				   optval->string);
 -		}
 +		   pri_reselect_tbl[bond->params.primary_reselect].modename);
  
  		seq_printf(seq, "\nCurrently Active Slave: %s\n",
  			   (curr) ? curr->dev->name : "None");
diff --cc drivers/net/bonding/bonding.h
index 64c0cb81e478,5b022da9cad2..000000000000
--- a/drivers/net/bonding/bonding.h
+++ b/drivers/net/bonding/bonding.h
@@@ -283,10 -256,51 +283,50 @@@ static inline struct bonding *bond_get_
  	return slave->bond;
  }
  
 -static inline bool bond_should_override_tx_queue(struct bonding *bond)
 -{
 -	return BOND_MODE(bond) == BOND_MODE_ACTIVEBACKUP ||
 -	       BOND_MODE(bond) == BOND_MODE_ROUNDROBIN;
 -}
 -
  static inline bool bond_is_lb(const struct bonding *bond)
  {
++<<<<<<< HEAD
 +	return (bond->params.mode == BOND_MODE_TLB ||
 +		bond->params.mode == BOND_MODE_ALB);
++=======
+ 	return BOND_MODE(bond) == BOND_MODE_TLB ||
+ 	       BOND_MODE(bond) == BOND_MODE_ALB;
+ }
+ 
+ static inline bool bond_is_nondyn_tlb(const struct bonding *bond)
+ {
+ 	return (BOND_MODE(bond) == BOND_MODE_TLB)  &&
+ 	       (bond->params.tlb_dynamic_lb == 0);
+ }
+ 
+ static inline bool bond_mode_uses_xmit_hash(const struct bonding *bond)
+ {
+ 	return (BOND_MODE(bond) == BOND_MODE_8023AD ||
+ 		BOND_MODE(bond) == BOND_MODE_XOR ||
+ 		bond_is_nondyn_tlb(bond));
+ }
+ 
+ static inline bool bond_mode_uses_arp(int mode)
+ {
+ 	return mode != BOND_MODE_8023AD && mode != BOND_MODE_TLB &&
+ 	       mode != BOND_MODE_ALB;
+ }
+ 
+ static inline bool bond_mode_uses_primary(int mode)
+ {
+ 	return mode == BOND_MODE_ACTIVEBACKUP || mode == BOND_MODE_TLB ||
+ 	       mode == BOND_MODE_ALB;
+ }
+ 
+ static inline bool bond_uses_primary(struct bonding *bond)
+ {
+ 	return bond_mode_uses_primary(BOND_MODE(bond));
+ }
+ 
+ static inline bool bond_slave_is_up(struct slave *slave)
+ {
+ 	return netif_running(slave->dev) && netif_carrier_ok(slave->dev);
++>>>>>>> d7021325a2ea (bonding: display xmit_hash_policy for non-dynamic-tlb mode)
  }
  
  static inline void bond_set_active_slave(struct slave *slave)
* Unmerged path drivers/net/bonding/bond_procfs.c
* Unmerged path drivers/net/bonding/bonding.h
