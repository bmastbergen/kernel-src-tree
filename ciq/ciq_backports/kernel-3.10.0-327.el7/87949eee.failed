sd: split sd_init_command

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 87949eee7e15471a42f06ae534847264a41be647
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/87949eee.failed

Factor out a function to initialize regular read/write commands and leave
sd_init_command as a simple dispatcher to the different prepare routines.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
(cherry picked from commit 87949eee7e15471a42f06ae534847264a41be647)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/sd.c
diff --cc drivers/scsi/sd.c
index 2f9493976e5a,3663e38ba4df..000000000000
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@@ -856,32 -868,23 +856,36 @@@ static int sd_setup_write_same_cmnd(str
  	return ret;
  }
  
 -static int sd_setup_flush_cmnd(struct scsi_cmnd *cmd)
 +static int scsi_setup_flush_cmnd(struct scsi_device *sdp, struct request *rq)
  {
 -	struct request *rq = cmd->request;
 +	rq->timeout = rq->q->rq_timeout * SD_FLUSH_TIMEOUT_MULTIPLIER;
 +	rq->retries = SD_MAX_RETRIES;
 +	rq->cmd[0] = SYNCHRONIZE_CACHE;
 +	rq->cmd_len = 10;
  
 -	/* flush requests don't perform I/O, zero the S/G table */
 -	memset(&cmd->sdb, 0, sizeof(cmd->sdb));
 +	return scsi_setup_blk_pc_cmnd(sdp, rq);
 +}
  
 -	cmd->cmnd[0] = SYNCHRONIZE_CACHE;
 -	cmd->cmd_len = 10;
 -	cmd->transfersize = 0;
 -	cmd->allowed = SD_MAX_RETRIES;
++<<<<<<< HEAD
 +static void sd_uninit_command(struct scsi_cmnd *SCpnt)
 +{
 +	struct request *rq = SCpnt->request;
  
 -	rq->timeout *= SD_FLUSH_TIMEOUT_MULTIPLIER;
 -	return BLKPREP_OK;
 +	if (rq->cmd_flags & REQ_DISCARD) {
 +		free_page((unsigned long)rq->buffer);
 +		rq->buffer = NULL;
 +	}
 +	if (SCpnt->cmnd != rq->cmd) {
 +		mempool_free(SCpnt->cmnd, sd_cdb_pool);
 +		SCpnt->cmnd = NULL;
 +		SCpnt->cmd_len = 0;
 +	}
  }
  
 +static int sd_init_command(struct scsi_cmnd *SCpnt)
++=======
+ static int sd_setup_read_write_cmnd(struct scsi_cmnd *SCpnt)
++>>>>>>> 87949eee7e15 (sd: split sd_init_command)
  {
  	struct request *rq = SCpnt->request;
  	struct scsi_device *sdp = SCpnt->device;
@@@ -893,20 -896,6 +897,23 @@@
  	int ret, host_dif;
  	unsigned char protect;
  
++<<<<<<< HEAD
 +	/*
 +	 * Discard request come in as REQ_TYPE_FS but we turn them into
 +	 * block PC requests to make life easier.
 +	 */
 +	if (rq->cmd_flags & REQ_DISCARD) {
 +		ret = sd_setup_discard_cmnd(sdp, rq);
 +		goto out;
 +	} else if (rq->cmd_flags & REQ_WRITE_SAME) {
 +		ret = sd_setup_write_same_cmnd(SCpnt);
 +		goto out;
 +	} else if (rq->cmd_flags & REQ_FLUSH) {
 +		ret = scsi_setup_flush_cmnd(sdp, rq);
 +		goto out;
 +	}
++=======
++>>>>>>> 87949eee7e15 (sd: split sd_init_command)
  	ret = scsi_init_io(SCpnt, GFP_ATOMIC);
  	if (ret != BLKPREP_OK)
  		goto out;
* Unmerged path drivers/scsi/sd.c
