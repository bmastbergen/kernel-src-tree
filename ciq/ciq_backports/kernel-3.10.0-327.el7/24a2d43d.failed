ipv4: rename ip_options_echo to __ip_options_echo()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Eric Dumazet <edumazet@google.com>
commit 24a2d43d8886f5a29c3cf108927f630c545a9a38
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/24a2d43d.failed

ip_options_echo() assumes struct ip_options is provided in &IPCB(skb)->opt
Lets break this assumption, but provide a helper to not change all call points.

ip_send_unicast_reply() gets a new struct ip_options pointer.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 24a2d43d8886f5a29c3cf108927f630c545a9a38)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ip.h
diff --cc include/net/ip.h
index 01f9ccf5f537,0bb620702929..000000000000
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@@ -503,19 -511,26 +505,42 @@@ extern int ip_forward(struct sk_buff *s
   *	Functions provided by ip_options.c
   */
   
++<<<<<<< HEAD
 +extern void ip_options_build(struct sk_buff *skb, struct ip_options *opt,
 +			     __be32 daddr, struct rtable *rt, int is_frag);
 +extern int ip_options_echo(struct ip_options *dopt, struct sk_buff *skb);
 +extern void ip_options_fragment(struct sk_buff *skb);
 +extern int ip_options_compile(struct net *net,
 +			      struct ip_options *opt, struct sk_buff *skb);
 +extern int ip_options_get(struct net *net, struct ip_options_rcu **optp,
 +			  unsigned char *data, int optlen);
 +extern int ip_options_get_from_user(struct net *net, struct ip_options_rcu **optp,
 +				    unsigned char __user *data, int optlen);
 +extern void ip_options_undo(struct ip_options * opt);
 +extern void ip_forward_options(struct sk_buff *skb);
 +extern int ip_options_rcv_srr(struct sk_buff *skb);
++=======
+ void ip_options_build(struct sk_buff *skb, struct ip_options *opt,
+ 		      __be32 daddr, struct rtable *rt, int is_frag);
+ 
+ int __ip_options_echo(struct ip_options *dopt, struct sk_buff *skb,
+ 		      const struct ip_options *sopt);
+ static inline int ip_options_echo(struct ip_options *dopt, struct sk_buff *skb)
+ {
+ 	return __ip_options_echo(dopt, skb, &IPCB(skb)->opt);
+ }
+ 
+ void ip_options_fragment(struct sk_buff *skb);
+ int ip_options_compile(struct net *net, struct ip_options *opt,
+ 		       struct sk_buff *skb);
+ int ip_options_get(struct net *net, struct ip_options_rcu **optp,
+ 		   unsigned char *data, int optlen);
+ int ip_options_get_from_user(struct net *net, struct ip_options_rcu **optp,
+ 			     unsigned char __user *data, int optlen);
+ void ip_options_undo(struct ip_options *opt);
+ void ip_forward_options(struct sk_buff *skb);
+ int ip_options_rcv_srr(struct sk_buff *skb);
++>>>>>>> 24a2d43d8886 (ipv4: rename ip_options_echo to __ip_options_echo())
  
  /*
   *	Functions provided by ip_sockglue.c
* Unmerged path include/net/ip.h
diff --git a/net/ipv4/ip_options.c b/net/ipv4/ip_options.c
index ec7264514a82..9596ba3f3d62 100644
--- a/net/ipv4/ip_options.c
+++ b/net/ipv4/ip_options.c
@@ -87,17 +87,15 @@ void ip_options_build(struct sk_buff *skb, struct ip_options *opt,
  * NOTE: dopt cannot point to skb.
  */
 
-int ip_options_echo(struct ip_options *dopt, struct sk_buff *skb)
+int __ip_options_echo(struct ip_options *dopt, struct sk_buff *skb,
+		      const struct ip_options *sopt)
 {
-	const struct ip_options *sopt;
 	unsigned char *sptr, *dptr;
 	int soffset, doffset;
 	int	optlen;
 
 	memset(dopt, 0, sizeof(struct ip_options));
 
-	sopt = &(IPCB(skb)->opt);
-
 	if (sopt->optlen == 0)
 		return 0;
 
diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index 68949525ed08..1d2e355c2ed1 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -1511,8 +1511,10 @@ static DEFINE_PER_CPU(struct inet_sock, unicast_sock) = {
 	.uc_ttl		= -1,
 };
 
-void ip_send_unicast_reply(struct net *net, struct sk_buff *skb, __be32 daddr,
-			   __be32 saddr, const struct ip_reply_arg *arg,
+void ip_send_unicast_reply(struct net *net, struct sk_buff *skb,
+			   const struct ip_options *sopt,
+			   __be32 daddr, __be32 saddr,
+			   const struct ip_reply_arg *arg,
 			   unsigned int len)
 {
 	struct ip_options_data replyopts;
@@ -1523,7 +1525,7 @@ void ip_send_unicast_reply(struct net *net, struct sk_buff *skb, __be32 daddr,
 	struct sock *sk;
 	struct inet_sock *inet;
 
-	if (ip_options_echo(&replyopts.opt.opt, skb))
+	if (__ip_options_echo(&replyopts.opt.opt, skb, sopt))
 		return;
 
 	ipc.addr = daddr;
diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c
index cf2a920676db..70e5c2be7fc1 100644
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@ -687,8 +687,9 @@ static void tcp_v4_send_reset(struct sock *sk, struct sk_buff *skb)
 
 	net = dev_net(skb_dst(skb)->dev);
 	arg.tos = ip_hdr(skb)->tos;
-	ip_send_unicast_reply(net, skb, ip_hdr(skb)->saddr,
-			      ip_hdr(skb)->daddr, &arg, arg.iov[0].iov_len);
+	ip_send_unicast_reply(net, skb, &TCP_SKB_CB(skb)->header.h4.opt,
+			      ip_hdr(skb)->saddr, ip_hdr(skb)->daddr,
+			      &arg, arg.iov[0].iov_len);
 
 	TCP_INC_STATS_BH(net, TCP_MIB_OUTSEGS);
 	TCP_INC_STATS_BH(net, TCP_MIB_OUTRSTS);
@@ -770,8 +771,9 @@ static void tcp_v4_send_ack(struct sk_buff *skb, u32 seq, u32 ack,
 	if (oif)
 		arg.bound_dev_if = oif;
 	arg.tos = tos;
-	ip_send_unicast_reply(net, skb, ip_hdr(skb)->saddr,
-			      ip_hdr(skb)->daddr, &arg, arg.iov[0].iov_len);
+	ip_send_unicast_reply(net, skb, &TCP_SKB_CB(skb)->header.h4.opt,
+			      ip_hdr(skb)->saddr, ip_hdr(skb)->daddr,
+			      &arg, arg.iov[0].iov_len);
 
 	TCP_INC_STATS_BH(net, TCP_MIB_OUTSEGS);
 }
