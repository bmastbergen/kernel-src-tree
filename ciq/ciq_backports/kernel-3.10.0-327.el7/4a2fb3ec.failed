Bluetooth: Always wait for a connection on RFCOMM open()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [bluetooth] Always wait for a connection on RFCOMM open() (Lubomir Rintel) [1241844]
Rebuild_FUZZ: 89.11%
commit-author Gianluca Anzolin <gianluca@sottospazio.it>
commit 4a2fb3ecc7467c775b154813861f25a0ddc11aa0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/4a2fb3ec.failed

This patch fixes two regressions introduced with the recent rfcomm tty
rework.

The current code uses the carrier_raised() method to wait for the
bluetooth connection when a process opens the tty.

However processes may open the port with the O_NONBLOCK flag or set the
CLOCAL termios flag: in these cases the open() syscall returns
immediately without waiting for the bluetooth connection to
complete.

This behaviour confuses userspace which expects an established bluetooth
connection.

The patch restores the old behaviour by waiting for the connection in
rfcomm_dev_activate() and removes carrier_raised() from the tty_port ops.

As a side effect the new code also fixes the case in which the rfcomm
tty device is created with the flag RFCOMM_REUSE_DLC: the old code
didn't call device_move() and ModemManager skipped the detection
probe. Now device_move() is always called inside rfcomm_dev_activate().

	Signed-off-by: Gianluca Anzolin <gianluca@sottospazio.it>
	Reported-by: Andrey Vihrov <andrey.vihrov@gmail.com>
	Reported-by: Beson Chow <blc+bluez@mail.vanade.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 4a2fb3ecc7467c775b154813861f25a0ddc11aa0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bluetooth/rfcomm/tty.c
diff --cc net/bluetooth/rfcomm/tty.c
index 62bd75eda078,aeabadeef82b..000000000000
--- a/net/bluetooth/rfcomm/tty.c
+++ b/net/bluetooth/rfcomm/tty.c
@@@ -58,7 -58,7 +58,11 @@@ struct rfcomm_dev 
  	uint			modem_status;
  
  	struct rfcomm_dlc	*dlc;
++<<<<<<< HEAD
 +	wait_queue_head_t       wait;
++=======
+ 	wait_queue_head_t       conn_wait;
++>>>>>>> 4a2fb3ecc746 (Bluetooth: Always wait for a connection on RFCOMM open())
  
  	struct device		*tty_dev;
  
@@@ -104,8 -104,86 +108,91 @@@ static void rfcomm_dev_destruct(struct 
  	module_put(THIS_MODULE);
  }
  
++<<<<<<< HEAD
 +static const struct tty_port_operations rfcomm_port_ops = {
 +	.destruct = rfcomm_dev_destruct,
++=======
+ static struct device *rfcomm_get_device(struct rfcomm_dev *dev)
+ {
+ 	struct hci_dev *hdev;
+ 	struct hci_conn *conn;
+ 
+ 	hdev = hci_get_route(&dev->dst, &dev->src);
+ 	if (!hdev)
+ 		return NULL;
+ 
+ 	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &dev->dst);
+ 
+ 	hci_dev_put(hdev);
+ 
+ 	return conn ? &conn->dev : NULL;
+ }
+ 
+ /* device-specific initialization: open the dlc */
+ static int rfcomm_dev_activate(struct tty_port *port, struct tty_struct *tty)
+ {
+ 	struct rfcomm_dev *dev = container_of(port, struct rfcomm_dev, port);
+ 	DEFINE_WAIT(wait);
+ 	int err;
+ 
+ 	err = rfcomm_dlc_open(dev->dlc, &dev->src, &dev->dst, dev->channel);
+ 	if (err)
+ 		return err;
+ 
+ 	while (1) {
+ 		prepare_to_wait(&dev->conn_wait, &wait, TASK_INTERRUPTIBLE);
+ 
+ 		if (dev->dlc->state == BT_CLOSED) {
+ 			err = -dev->err;
+ 			break;
+ 		}
+ 
+ 		if (dev->dlc->state == BT_CONNECTED)
+ 			break;
+ 
+ 		if (signal_pending(current)) {
+ 			err = -ERESTARTSYS;
+ 			break;
+ 		}
+ 
+ 		tty_unlock(tty);
+ 		schedule();
+ 		tty_lock(tty);
+ 	}
+ 	finish_wait(&dev->conn_wait, &wait);
+ 
+ 	if (!err)
+ 		device_move(dev->tty_dev, rfcomm_get_device(dev),
+ 			    DPM_ORDER_DEV_AFTER_PARENT);
+ 
+ 	return err;
+ }
+ 
+ /* we block the open until the dlc->state becomes BT_CONNECTED */
+ static int rfcomm_dev_carrier_raised(struct tty_port *port)
+ {
+ 	struct rfcomm_dev *dev = container_of(port, struct rfcomm_dev, port);
+ 
+ 	return (dev->dlc->state == BT_CONNECTED);
+ }
+ 
+ /* device-specific cleanup: close the dlc */
+ static void rfcomm_dev_shutdown(struct tty_port *port)
+ {
+ 	struct rfcomm_dev *dev = container_of(port, struct rfcomm_dev, port);
+ 
+ 	if (dev->tty_dev->parent)
+ 		device_move(dev->tty_dev, NULL, DPM_ORDER_DEV_LAST);
+ 
+ 	/* close the dlc */
+ 	rfcomm_dlc_close(dev->dlc, 0);
+ }
+ 
+ static const struct tty_port_operations rfcomm_port_ops = {
+ 	.destruct = rfcomm_dev_destruct,
+ 	.activate = rfcomm_dev_activate,
+ 	.shutdown = rfcomm_dev_shutdown,
++>>>>>>> 4a2fb3ecc746 (Bluetooth: Always wait for a connection on RFCOMM open())
  };
  
  static struct rfcomm_dev *__rfcomm_dev_get(int id)
@@@ -228,7 -290,7 +315,11 @@@ static int rfcomm_dev_add(struct rfcomm
  
  	tty_port_init(&dev->port);
  	dev->port.ops = &rfcomm_port_ops;
++<<<<<<< HEAD
 +	init_waitqueue_head(&dev->wait);
++=======
+ 	init_waitqueue_head(&dev->conn_wait);
++>>>>>>> 4a2fb3ecc746 (Bluetooth: Always wait for a connection on RFCOMM open())
  
  	skb_queue_head_init(&dev->pending);
  
@@@ -559,31 -609,10 +650,38 @@@ static void rfcomm_dev_state_change(str
  	BT_DBG("dlc %p dev %p err %d", dlc, dev, err);
  
  	dev->err = err;
++<<<<<<< HEAD
 +	wake_up_interruptible(&dev->wait);
 +
 +	if (dlc->state == BT_CLOSED) {
 +		if (!dev->port.tty) {
 +			if (test_bit(RFCOMM_RELEASE_ONHUP, &dev->flags)) {
 +				/* Drop DLC lock here to avoid deadlock
 +				 * 1. rfcomm_dev_get will take rfcomm_dev_lock
 +				 *    but in rfcomm_dev_add there's lock order:
 +				 *    rfcomm_dev_lock -> dlc lock
 +				 * 2. tty_port_put will deadlock if it's
 +				 *    the last reference
 +				 */
 +				rfcomm_dlc_unlock(dlc);
 +				if (rfcomm_dev_get(dev->id) == NULL) {
 +					rfcomm_dlc_lock(dlc);
 +					return;
 +				}
 +
 +				rfcomm_dev_del(dev);
 +				tty_port_put(&dev->port);
 +				rfcomm_dlc_lock(dlc);
 +			}
 +		} else
 +			tty_hangup(dev->port.tty);
 +	}
++=======
+ 	wake_up_interruptible(&dev->conn_wait);
+ 
+ 	if (dlc->state == BT_CLOSED)
+ 		tty_port_tty_hangup(&dev->port, false);
++>>>>>>> 4a2fb3ecc746 (Bluetooth: Always wait for a connection on RFCOMM open())
  }
  
  static void rfcomm_dev_modem_status(struct rfcomm_dlc *dlc, u8 v24_sig)
* Unmerged path net/bluetooth/rfcomm/tty.c
