scsi: use per-cpu buffer for formatting scsi_print_result()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [scsi] use per-cpu buffer for formatting scsi_print_result() (Ewan Milne) [1124082]
Rebuild_FUZZ: 94.64%
commit-author Hannes Reinecke <hare@suse.de>
commit 026f8da8da4ce3423bf89e8e9091f55ae3863eda
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/026f8da8.failed

Convert scsi_print_result() to use the per-cpu buffer for decoding the
command result and disposition.

	Tested-by: Robert Elliott <elliott@hp.com>
	Reviewed-by: Robert Elliott <elliott@hp.com>
	Signed-off-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 026f8da8da4ce3423bf89e8e9091f55ae3863eda)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/constants.c
#	drivers/scsi/scsi.c
#	drivers/scsi/scsi_logging.c
#	include/scsi/scsi_dbg.h
diff --cc drivers/scsi/constants.c
index cd7131c88f5d,956fbdd38681..000000000000
--- a/drivers/scsi/constants.c
+++ b/drivers/scsi/constants.c
@@@ -1512,35 -1287,32 +1512,39 @@@ const char *scsi_driverbyte_string(int 
  }
  EXPORT_SYMBOL(scsi_driverbyte_string);
  
 -#ifdef CONFIG_SCSI_CONSTANTS
 -#define scsi_mlreturn_name(result)	{ result, #result }
 -static const struct value_name_pair scsi_mlreturn_arr[] = {
 -	scsi_mlreturn_name(NEEDS_RETRY),
 -	scsi_mlreturn_name(SUCCESS),
 -	scsi_mlreturn_name(FAILED),
 -	scsi_mlreturn_name(QUEUED),
 -	scsi_mlreturn_name(SOFT_ERROR),
 -	scsi_mlreturn_name(ADD_TO_MLQUEUE),
 -	scsi_mlreturn_name(TIMEOUT_ERROR),
 -	scsi_mlreturn_name(SCSI_RETURN_NOT_HANDLED),
 -	scsi_mlreturn_name(FAST_IO_FAIL)
 -};
 -#endif
 -
 -const char *scsi_mlreturn_string(int result)
 +void scsi_show_result(int result)
  {
 -#ifdef CONFIG_SCSI_CONSTANTS
 -	const struct value_name_pair *arr = scsi_mlreturn_arr;
 -	int k;
 +	const char *hb_string = scsi_hostbyte_string(result);
 +	const char *db_string = scsi_driverbyte_string(result);
 +
 +	if (hb_string || db_string)
 +		printk("Result: hostbyte=%s driverbyte=%s\n",
 +		       hb_string ? hb_string : "invalid",
 +		       db_string ? db_string : "invalid");
 +	else
 +		printk("Result: hostbyte=0x%02x driverbyte=0x%02x\n",
 +		       host_byte(result), driver_byte(result));
 +}
++<<<<<<< HEAD
 +EXPORT_SYMBOL(scsi_show_result);
  
 -	for (k = 0; k < ARRAY_SIZE(scsi_mlreturn_arr); ++k, ++arr) {
 -		if (result == arr->value)
 -			return arr->name;
 -	}
 -#endif
 -	return NULL;
 +
 +void scsi_print_result(struct scsi_cmnd *cmd)
 +{
 +	const char *hb_string = scsi_hostbyte_string(cmd->result);
 +	const char *db_string = scsi_driverbyte_string(cmd->result);
 +
 +	if (hb_string || db_string)
 +		scmd_printk(KERN_INFO, cmd,
 +			    "Result: hostbyte=%s driverbyte=%s",
 +			    hb_string ? hb_string : "invalid",
 +			    db_string ? db_string : "invalid");
 +	else
 +		scmd_printk(KERN_INFO, cmd,
 +			    "Result: hostbyte=0x%02x driverbyte=0x%02x",
 +			    host_byte(cmd->result), driver_byte(cmd->result));
  }
 +EXPORT_SYMBOL(scsi_print_result);
++=======
+ EXPORT_SYMBOL(scsi_mlreturn_string);
++>>>>>>> 026f8da8da4c (scsi: use per-cpu buffer for formatting scsi_print_result())
diff --cc drivers/scsi/scsi.c
index 838f188fa5d4,7f028cb1d099..000000000000
--- a/drivers/scsi/scsi.c
+++ b/drivers/scsi/scsi.c
@@@ -560,39 -572,10 +560,43 @@@ void scsi_log_completion(struct scsi_cm
  				       SCSI_LOG_MLCOMPLETE_BITS);
  		if (((level > 0) && (cmd->result || disposition != SUCCESS)) ||
  		    (level > 1)) {
++<<<<<<< HEAD
 +			scmd_printk(KERN_INFO, cmd, "Done: ");
 +			if (level > 2)
 +				printk("0x%p ", cmd);
 +			/*
 +			 * Dump truncated values, so we usually fit within
 +			 * 80 chars.
 +			 */
 +			switch (disposition) {
 +			case SUCCESS:
 +				printk("SUCCESS\n");
 +				break;
 +			case NEEDS_RETRY:
 +				printk("RETRY\n");
 +				break;
 +			case ADD_TO_MLQUEUE:
 +				printk("MLQUEUE\n");
 +				break;
 +			case FAILED:
 +				printk("FAILED\n");
 +				break;
 +			case TIMEOUT_ERROR:
 +				/* 
 +				 * If called via scsi_times_out.
 +				 */
 +				printk("TIMEOUT\n");
 +				break;
 +			default:
 +				printk("UNKNOWN\n");
 +			}
 +			scsi_print_result(cmd);
++=======
+ 			scsi_print_result(cmd, "Done", disposition);
++>>>>>>> 026f8da8da4c (scsi: use per-cpu buffer for formatting scsi_print_result())
  			scsi_print_command(cmd);
  			if (status_byte(cmd->result) & CHECK_CONDITION)
 -				scsi_print_sense(cmd);
 +				scsi_print_sense("", cmd);
  			if (level > 3)
  				scmd_printk(KERN_INFO, cmd,
  					    "scsi host busy %d failed %d\n",
diff --cc drivers/scsi/scsi_logging.c
index 4d20132c897d,6128303f9c50..000000000000
--- a/drivers/scsi/scsi_logging.c
+++ b/drivers/scsi/scsi_logging.c
@@@ -126,3 -148,342 +126,345 @@@ int scmd_printk(const char *level, cons
  	return ret;
  }
  EXPORT_SYMBOL(scmd_printk);
++<<<<<<< HEAD
++=======
+ 
+ static size_t scsi_format_opcode_name(char *buffer, size_t buf_len,
+ 				      const unsigned char *cdbp)
+ {
+ 	int sa, cdb0;
+ 	const char *cdb_name = NULL, *sa_name = NULL;
+ 	size_t off;
+ 
+ 	cdb0 = cdbp[0];
+ 	if (cdb0 == VARIABLE_LENGTH_CMD) {
+ 		int len = scsi_varlen_cdb_length(cdbp);
+ 
+ 		if (len < 10) {
+ 			off = scnprintf(buffer, buf_len,
+ 					"short variable length command, len=%d",
+ 					len);
+ 			return off;
+ 		}
+ 		sa = (cdbp[8] << 8) + cdbp[9];
+ 	} else
+ 		sa = cdbp[1] & 0x1f;
+ 
+ 	if (!scsi_opcode_sa_name(cdb0, sa, &cdb_name, &sa_name)) {
+ 		if (cdb_name)
+ 			off = scnprintf(buffer, buf_len, "%s", cdb_name);
+ 		else {
+ 			off = scnprintf(buffer, buf_len, "opcode=0x%x", cdb0);
+ 			if (WARN_ON(off >= buf_len))
+ 				return off;
+ 			if (cdb0 >= VENDOR_SPECIFIC_CDB)
+ 				off += scnprintf(buffer + off, buf_len - off,
+ 						 " (vendor)");
+ 			else if (cdb0 >= 0x60 && cdb0 < 0x7e)
+ 				off += scnprintf(buffer + off, buf_len - off,
+ 						 " (reserved)");
+ 		}
+ 	} else {
+ 		if (sa_name)
+ 			off = scnprintf(buffer, buf_len, "%s", sa_name);
+ 		else if (cdb_name)
+ 			off = scnprintf(buffer, buf_len, "%s, sa=0x%x",
+ 					cdb_name, sa);
+ 		else
+ 			off = scnprintf(buffer, buf_len,
+ 					"opcode=0x%x, sa=0x%x", cdb0, sa);
+ 	}
+ 	WARN_ON(off >= buf_len);
+ 	return off;
+ }
+ 
+ size_t __scsi_format_command(char *logbuf, size_t logbuf_len,
+ 			     const unsigned char *cdb, size_t cdb_len)
+ {
+ 	int len, k;
+ 	size_t off;
+ 
+ 	off = scsi_format_opcode_name(logbuf, logbuf_len, cdb);
+ 	if (off >= logbuf_len)
+ 		return off;
+ 	len = scsi_command_size(cdb);
+ 	if (cdb_len < len)
+ 		len = cdb_len;
+ 	/* print out all bytes in cdb */
+ 	for (k = 0; k < len; ++k) {
+ 		if (off > logbuf_len - 3)
+ 			break;
+ 		off += scnprintf(logbuf + off, logbuf_len - off,
+ 				 " %02x", cdb[k]);
+ 	}
+ 	return off;
+ }
+ EXPORT_SYMBOL(__scsi_format_command);
+ 
+ void scsi_print_command(struct scsi_cmnd *cmd)
+ {
+ 	int k;
+ 	char *logbuf;
+ 	size_t off, logbuf_len;
+ 
+ 	if (!cmd->cmnd)
+ 		return;
+ 
+ 	logbuf = scsi_log_reserve_buffer(&logbuf_len);
+ 	if (!logbuf)
+ 		return;
+ 
+ 	off = sdev_format_header(logbuf, logbuf_len,
+ 				 scmd_name(cmd), cmd->request->tag);
+ 	if (off >= logbuf_len)
+ 		goto out_printk;
+ 	off += scnprintf(logbuf + off, logbuf_len - off, "CDB: ");
+ 	if (WARN_ON(off >= logbuf_len))
+ 		goto out_printk;
+ 
+ 	off += scsi_format_opcode_name(logbuf + off, logbuf_len - off,
+ 				       cmd->cmnd);
+ 	if (off >= logbuf_len)
+ 		goto out_printk;
+ 
+ 	/* print out all bytes in cdb */
+ 	if (cmd->cmd_len > 16) {
+ 		/* Print opcode in one line and use separate lines for CDB */
+ 		off += scnprintf(logbuf + off, logbuf_len - off, "\n");
+ 		dev_printk(KERN_INFO, &cmd->device->sdev_gendev, logbuf);
+ 		scsi_log_release_buffer(logbuf);
+ 		for (k = 0; k < cmd->cmd_len; k += 16) {
+ 			size_t linelen = min(cmd->cmd_len - k, 16);
+ 
+ 			logbuf = scsi_log_reserve_buffer(&logbuf_len);
+ 			if (!logbuf)
+ 				break;
+ 			off = sdev_format_header(logbuf, logbuf_len,
+ 						 scmd_name(cmd),
+ 						 cmd->request->tag);
+ 			if (!WARN_ON(off > logbuf_len - 58)) {
+ 				off += scnprintf(logbuf + off, logbuf_len - off,
+ 						 "CDB[%02x]: ", k);
+ 				hex_dump_to_buffer(&cmd->cmnd[k], linelen,
+ 						   16, 1, logbuf + off,
+ 						   logbuf_len - off, false);
+ 			}
+ 			dev_printk(KERN_INFO, &cmd->device->sdev_gendev,
+ 				   logbuf);
+ 			scsi_log_release_buffer(logbuf);
+ 		}
+ 		return;
+ 	}
+ 	if (!WARN_ON(off > logbuf_len - 49)) {
+ 		off += scnprintf(logbuf + off, logbuf_len - off, " ");
+ 		hex_dump_to_buffer(cmd->cmnd, cmd->cmd_len, 16, 1,
+ 				   logbuf + off, logbuf_len - off,
+ 				   false);
+ 	}
+ out_printk:
+ 	dev_printk(KERN_INFO, &cmd->device->sdev_gendev, logbuf);
+ 	scsi_log_release_buffer(logbuf);
+ }
+ EXPORT_SYMBOL(scsi_print_command);
+ 
+ static size_t
+ scsi_format_extd_sense(char *buffer, size_t buf_len,
+ 		       unsigned char asc, unsigned char ascq)
+ {
+ 	size_t off = 0;
+ 	const char *extd_sense_fmt = NULL;
+ 	const char *extd_sense_str = scsi_extd_sense_format(asc, ascq,
+ 							    &extd_sense_fmt);
+ 
+ 	if (extd_sense_str) {
+ 		off = scnprintf(buffer, buf_len, "Add. Sense: %s",
+ 				extd_sense_str);
+ 		if (extd_sense_fmt)
+ 			off += scnprintf(buffer + off, buf_len - off,
+ 					 "(%s%x)", extd_sense_fmt, ascq);
+ 	} else {
+ 		if (asc >= 0x80)
+ 			off = scnprintf(buffer, buf_len, "<<vendor>>");
+ 		off += scnprintf(buffer + off, buf_len - off,
+ 				 "ASC=0x%x ", asc);
+ 		if (ascq >= 0x80)
+ 			off += scnprintf(buffer + off, buf_len - off,
+ 					 "<<vendor>>");
+ 		off += scnprintf(buffer + off, buf_len - off,
+ 				 "ASCQ=0x%x ", ascq);
+ 	}
+ 	return off;
+ }
+ 
+ static size_t
+ scsi_format_sense_hdr(char *buffer, size_t buf_len,
+ 		      const struct scsi_sense_hdr *sshdr)
+ {
+ 	const char *sense_txt;
+ 	size_t off;
+ 
+ 	off = scnprintf(buffer, buf_len, "Sense Key : ");
+ 	sense_txt = scsi_sense_key_string(sshdr->sense_key);
+ 	if (sense_txt)
+ 		off += scnprintf(buffer + off, buf_len - off,
+ 				 "%s ", sense_txt);
+ 	else
+ 		off += scnprintf(buffer + off, buf_len - off,
+ 				 "0x%x ", sshdr->sense_key);
+ 	off += scnprintf(buffer + off, buf_len - off,
+ 		scsi_sense_is_deferred(sshdr) ? "[deferred] " : "[current] ");
+ 
+ 	if (sshdr->response_code >= 0x72)
+ 		off += scnprintf(buffer + off, buf_len - off, "[descriptor] ");
+ 	return off;
+ }
+ 
+ static void
+ scsi_log_dump_sense(const struct scsi_device *sdev, const char *name, int tag,
+ 		    const unsigned char *sense_buffer, int sense_len)
+ {
+ 	char *logbuf;
+ 	size_t logbuf_len;
+ 	int i;
+ 
+ 	logbuf = scsi_log_reserve_buffer(&logbuf_len);
+ 	if (!logbuf)
+ 		return;
+ 
+ 	for (i = 0; i < sense_len; i += 16) {
+ 		int len = min(sense_len - i, 16);
+ 		size_t off;
+ 
+ 		off = sdev_format_header(logbuf, logbuf_len,
+ 					 name, tag);
+ 		hex_dump_to_buffer(&sense_buffer[i], len, 16, 1,
+ 				   logbuf + off, logbuf_len - off,
+ 				   false);
+ 		dev_printk(KERN_INFO, &sdev->sdev_gendev, logbuf);
+ 	}
+ 	scsi_log_release_buffer(logbuf);
+ }
+ 
+ static void
+ scsi_log_print_sense_hdr(const struct scsi_device *sdev, const char *name,
+ 			 int tag, const struct scsi_sense_hdr *sshdr)
+ {
+ 	char *logbuf;
+ 	size_t off, logbuf_len;
+ 
+ 	logbuf = scsi_log_reserve_buffer(&logbuf_len);
+ 	if (!logbuf)
+ 		return;
+ 	off = sdev_format_header(logbuf, logbuf_len, name, tag);
+ 	off += scsi_format_sense_hdr(logbuf + off, logbuf_len - off, sshdr);
+ 	dev_printk(KERN_INFO, &sdev->sdev_gendev, logbuf);
+ 	scsi_log_release_buffer(logbuf);
+ 
+ 	logbuf = scsi_log_reserve_buffer(&logbuf_len);
+ 	if (!logbuf)
+ 		return;
+ 	off = sdev_format_header(logbuf, logbuf_len, name, tag);
+ 	off += scsi_format_extd_sense(logbuf + off, logbuf_len - off,
+ 				      sshdr->asc, sshdr->ascq);
+ 	dev_printk(KERN_INFO, &sdev->sdev_gendev, logbuf);
+ 	scsi_log_release_buffer(logbuf);
+ }
+ 
+ static void
+ scsi_log_print_sense(const struct scsi_device *sdev, const char *name, int tag,
+ 		     const unsigned char *sense_buffer, int sense_len)
+ {
+ 	struct scsi_sense_hdr sshdr;
+ 
+ 	if (scsi_normalize_sense(sense_buffer, sense_len, &sshdr))
+ 		scsi_log_print_sense_hdr(sdev, name, tag, &sshdr);
+ 	else
+ 		scsi_log_dump_sense(sdev, name, tag, sense_buffer, sense_len);
+ }
+ 
+ /*
+  * Print normalized SCSI sense header with a prefix.
+  */
+ void
+ scsi_print_sense_hdr(const struct scsi_device *sdev, const char *name,
+ 		     const struct scsi_sense_hdr *sshdr)
+ {
+ 	scsi_log_print_sense_hdr(sdev, name, -1, sshdr);
+ }
+ EXPORT_SYMBOL(scsi_print_sense_hdr);
+ 
+ /* Normalize and print sense buffer with name prefix */
+ void __scsi_print_sense(const struct scsi_device *sdev, const char *name,
+ 			const unsigned char *sense_buffer, int sense_len)
+ {
+ 	scsi_log_print_sense(sdev, name, -1, sense_buffer, sense_len);
+ }
+ EXPORT_SYMBOL(__scsi_print_sense);
+ 
+ /* Normalize and print sense buffer in SCSI command */
+ void scsi_print_sense(const struct scsi_cmnd *cmd)
+ {
+ 	scsi_log_print_sense(cmd->device, scmd_name(cmd), cmd->request->tag,
+ 			     cmd->sense_buffer, SCSI_SENSE_BUFFERSIZE);
+ }
+ EXPORT_SYMBOL(scsi_print_sense);
+ 
+ void scsi_print_result(const struct scsi_cmnd *cmd, const char *msg,
+ 		       int disposition)
+ {
+ 	char *logbuf;
+ 	size_t off, logbuf_len;
+ 	const char *mlret_string = scsi_mlreturn_string(disposition);
+ 	const char *hb_string = scsi_hostbyte_string(cmd->result);
+ 	const char *db_string = scsi_driverbyte_string(cmd->result);
+ 
+ 	logbuf = scsi_log_reserve_buffer(&logbuf_len);
+ 	if (!logbuf)
+ 		return;
+ 
+ 	off = sdev_format_header(logbuf, logbuf_len,
+ 				 scmd_name(cmd), cmd->request->tag);
+ 
+ 	if (off >= logbuf_len)
+ 		goto out_printk;
+ 
+ 	if (msg) {
+ 		off += scnprintf(logbuf + off, logbuf_len - off,
+ 				 "%s: ", msg);
+ 		if (WARN_ON(off >= logbuf_len))
+ 			goto out_printk;
+ 	}
+ 	if (mlret_string)
+ 		off += scnprintf(logbuf + off, logbuf_len - off,
+ 				 "%s ", mlret_string);
+ 	else
+ 		off += scnprintf(logbuf + off, logbuf_len - off,
+ 				 "UNKNOWN(0x%02x) ", disposition);
+ 	if (WARN_ON(off >= logbuf_len))
+ 		goto out_printk;
+ 
+ 	off += scnprintf(logbuf + off, logbuf_len - off, "Result: ");
+ 	if (WARN_ON(off >= logbuf_len))
+ 		goto out_printk;
+ 
+ 	if (hb_string)
+ 		off += scnprintf(logbuf + off, logbuf_len - off,
+ 				 "hostbyte=%s ", hb_string);
+ 	else
+ 		off += scnprintf(logbuf + off, logbuf_len - off,
+ 				 "hostbyte=0x%02x ", host_byte(cmd->result));
+ 	if (WARN_ON(off >= logbuf_len))
+ 		goto out_printk;
+ 
+ 	if (db_string)
+ 		off += scnprintf(logbuf + off, logbuf_len - off,
+ 				 "driverbyte=%s", db_string);
+ 	else
+ 		off += scnprintf(logbuf + off, logbuf_len - off,
+ 				 "driverbyte=0x%02x", driver_byte(cmd->result));
+ out_printk:
+ 	dev_printk(KERN_INFO, &cmd->device->sdev_gendev, logbuf);
+ 	scsi_log_release_buffer(logbuf);
+ }
+ EXPORT_SYMBOL(scsi_print_result);
++>>>>>>> 026f8da8da4c (scsi: use per-cpu buffer for formatting scsi_print_result())
diff --cc include/scsi/scsi_dbg.h
index ed755e53b4c8,365b6745dc10..000000000000
--- a/include/scsi/scsi_dbg.h
+++ b/include/scsi/scsi_dbg.h
@@@ -2,22 -2,31 +2,26 @@@
  #define _SCSI_SCSI_DBG_H
  
  struct scsi_cmnd;
 -struct scsi_device;
  struct scsi_sense_hdr;
  
 -#define SCSI_LOG_BUFSIZE 128
 -
 -extern bool scsi_opcode_sa_name(int, int, const char **, const char **);
  extern void scsi_print_command(struct scsi_cmnd *);
 -extern size_t __scsi_format_command(char *, size_t,
 -				   const unsigned char *, size_t);
 -extern void scsi_show_extd_sense(const struct scsi_device *, const char *,
 -				 unsigned char, unsigned char);
 -extern void scsi_show_sense_hdr(const struct scsi_device *, const char *,
 -				const struct scsi_sense_hdr *);
 -extern void scsi_print_sense_hdr(const struct scsi_device *, const char *,
 -				 const struct scsi_sense_hdr *);
 -extern void scsi_print_sense(const struct scsi_cmnd *);
 -extern void __scsi_print_sense(const struct scsi_device *, const char *name,
 +extern void __scsi_print_command(unsigned char *);
 +extern void scsi_show_extd_sense(unsigned char, unsigned char);
 +extern void scsi_show_sense_hdr(struct scsi_sense_hdr *);
 +extern void scsi_print_sense_hdr(const char *, struct scsi_sense_hdr *);
 +extern void scsi_print_sense(char *, struct scsi_cmnd *);
 +extern void __scsi_print_sense(const char *name,
  			       const unsigned char *sense_buffer,
  			       int sense_len);
++<<<<<<< HEAD
 +extern void scsi_show_result(int);
 +extern void scsi_print_result(struct scsi_cmnd *);
++=======
+ extern void scsi_print_result(const struct scsi_cmnd *, const char *, int);
++>>>>>>> 026f8da8da4c (scsi: use per-cpu buffer for formatting scsi_print_result())
  extern const char *scsi_hostbyte_string(int);
  extern const char *scsi_driverbyte_string(int);
 -extern const char *scsi_mlreturn_string(int);
  extern const char *scsi_sense_key_string(unsigned char);
 -extern const char *scsi_extd_sense_format(unsigned char, unsigned char,
 -					  const char **);
 +extern const char *scsi_extd_sense_format(unsigned char, unsigned char);
  
  #endif /* _SCSI_SCSI_DBG_H */
* Unmerged path drivers/scsi/constants.c
* Unmerged path drivers/scsi/scsi.c
* Unmerged path drivers/scsi/scsi_logging.c
* Unmerged path include/scsi/scsi_dbg.h
