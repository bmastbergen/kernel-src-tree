ipv6: Allow for partial checksums on non-ufo packets

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Vlad Yasevich <vyasevich@gmail.com>
commit 32dce968dd987adfb0c00946d78dad9154f64759
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/32dce968.failed

Currntly, if we are not doing UFO on the packet, all UDP
packets will start with CHECKSUM_NONE and thus perform full
checksum computations in software even if device support
IPv6 checksum offloading.

Let's start start with CHECKSUM_PARTIAL if the device
supports it and we are sending only a single packet at
or below mtu size.

	Signed-off-by: Vladislav Yasevich <vyasevic@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 32dce968dd987adfb0c00946d78dad9154f64759)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_output.c
diff --cc net/ipv6/ip6_output.c
index 524b4ad02d70,1a036f35d833..000000000000
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@@ -1195,30 -1224,17 +1195,37 @@@ int ip6_append_data(struct sock *sk, in
  	int err;
  	int offset = 0;
  	__u8 tx_flags = 0;
++<<<<<<< HEAD
++=======
+ 	u32 tskey = 0;
+ 	struct rt6_info *rt = (struct rt6_info *)cork->dst;
+ 	struct ipv6_txoptions *opt = v6_cork->opt;
+ 	int csummode = CHECKSUM_NONE;
++>>>>>>> 32dce968dd98 (ipv6: Allow for partial checksums on non-ufo packets)
  
 -	skb = skb_peek_tail(queue);
 -	if (!skb) {
 -		exthdrlen = opt ? opt->opt_flen : 0;
 +	if (flags&MSG_PROBE)
 +		return 0;
 +	cork = &inet->cork.base;
 +	if (skb_queue_empty(&sk->sk_write_queue)) {
 +		/*
 +		 * setup for corking
 +		 */
 +		err = ip6_setup_cork(sk, &inet->cork, &np->cork, hlimit,
 +				     tclass, opt, rt, fl6);
 +		if (err)
 +			return err;
 +		exthdrlen = (opt ? opt->opt_flen : 0);
 +		length += exthdrlen;
 +		transhdrlen += exthdrlen;
  		dst_exthdrlen = rt->dst.header_len - rt->rt6i_nfheader_len;
 +	} else {
 +		rt = (struct rt6_info *)cork->dst;
 +		fl6 = &inet->cork.fl.u.ip6;
 +		opt = np->cork.opt;
 +		transhdrlen = 0;
 +		exthdrlen = 0;
 +		dst_exthdrlen = 0;
  	}
 -
  	mtu = cork->fragsize;
  	orig_mtu = mtu;
  
@@@ -1261,10 -1277,21 +1268,18 @@@ emsgsize
  		}
  	}
  
 -	if (sk->sk_type == SOCK_DGRAM || sk->sk_type == SOCK_RAW) {
 +	/* For UDP, check if TX timestamp is enabled */
 +	if (sk->sk_type == SOCK_DGRAM)
  		sock_tx_timestamp(sk, &tx_flags);
 -		if (tx_flags & SKBTX_ANY_SW_TSTAMP &&
 -		    sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID)
 -			tskey = sk->sk_tskey++;
 -	}
  
+ 	/* If this is the first and only packet and device
+ 	 * supports checksum offloading, let's use it.
+ 	 */
+ 	if (!skb &&
+ 	    length + fragheaderlen < mtu &&
+ 	    rt->dst.dev->features & NETIF_F_V6_CSUM &&
+ 	    !exthdrlen)
+ 		csummode = CHECKSUM_PARTIAL;
  	/*
  	 * Let's try using as much space as possible.
  	 * Use MTU if total length of the message fits into the MTU.
@@@ -1383,7 -1403,8 +1398,12 @@@ alloc_new_skb
  			/*
  			 *	Fill in the control structures
  			 */
++<<<<<<< HEAD
 +			skb->ip_summed = CHECKSUM_NONE;
++=======
+ 			skb->protocol = htons(ETH_P_IPV6);
+ 			skb->ip_summed = csummode;
++>>>>>>> 32dce968dd98 (ipv6: Allow for partial checksums on non-ufo packets)
  			skb->csum = 0;
  			/* reserve for fragmentation and ipsec header */
  			skb_reserve(skb, hh_len + sizeof(struct frag_hdr) +
* Unmerged path net/ipv6/ip6_output.c
