virtio_scsi: v1.0 support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [virtio] virtio-scsi: v1.0 support (Jason Wang) [1227339]
Rebuild_FUZZ: 96.00%
commit-author Michael S. Tsirkin <mst@redhat.com>
commit d75dff39dfb86b0b8925f10b1f13fc353ae9f1b0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/d75dff39.failed

Note: for consistency, and to avoid sparse errors,
  convert all fields, even those no longer in use
  for virtio v1.0.

	Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
	Acked-by: Paolo Bonzini <pbonzini@redhat.com>




(cherry picked from commit d75dff39dfb86b0b8925f10b1f13fc353ae9f1b0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/virtio_scsi.c
#	include/linux/virtio_scsi.h
diff --cc drivers/scsi/virtio_scsi.c
index 84bc50f340b4,d9ec80698d63..000000000000
--- a/drivers/scsi/virtio_scsi.c
+++ b/drivers/scsi/virtio_scsi.c
@@@ -504,6 -487,44 +509,47 @@@ static int virtscsi_kick_cmd(struct vir
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static void virtio_scsi_init_hdr(struct virtio_device *vdev,
+ 				 struct virtio_scsi_cmd_req *cmd,
+ 				 struct scsi_cmnd *sc)
+ {
+ 	cmd->lun[0] = 1;
+ 	cmd->lun[1] = sc->device->id;
+ 	cmd->lun[2] = (sc->device->lun >> 8) | 0x40;
+ 	cmd->lun[3] = sc->device->lun & 0xff;
+ 	cmd->tag = cpu_to_virtio64(vdev, (unsigned long)sc);
+ 	cmd->task_attr = VIRTIO_SCSI_S_SIMPLE;
+ 	cmd->prio = 0;
+ 	cmd->crn = 0;
+ }
+ 
+ static void virtio_scsi_init_hdr_pi(struct virtio_device *vdev,
+ 				    struct virtio_scsi_cmd_req_pi *cmd_pi,
+ 				    struct scsi_cmnd *sc)
+ {
+ 	struct request *rq = sc->request;
+ 	struct blk_integrity *bi;
+ 
+ 	virtio_scsi_init_hdr(vdev, (struct virtio_scsi_cmd_req *)cmd_pi, sc);
+ 
+ 	if (!rq || !scsi_prot_sg_count(sc))
+ 		return;
+ 
+ 	bi = blk_get_integrity(rq->rq_disk);
+ 
+ 	if (sc->sc_data_direction == DMA_TO_DEVICE)
+ 		cmd_pi->pi_bytesout = cpu_to_virtio32(vdev,
+ 							blk_rq_sectors(rq) *
+ 							bi->tuple_size);
+ 	else if (sc->sc_data_direction == DMA_FROM_DEVICE)
+ 		cmd_pi->pi_bytesin = cpu_to_virtio32(vdev,
+ 						       blk_rq_sectors(rq) *
+ 						       bi->tuple_size);
+ }
+ 
++>>>>>>> d75dff39dfb8 (virtio_scsi: v1.0 support)
  static int virtscsi_queuecommand(struct virtio_scsi *vscsi,
  				 struct virtio_scsi_vq *req_vq,
  				 struct scsi_cmnd *sc)
@@@ -520,35 -541,24 +566,47 @@@
  	dev_dbg(&sc->device->sdev_gendev,
  		"cmd %p CDB: %#02x\n", sc, sc->cmnd[0]);
  
 +	ret = SCSI_MLQUEUE_HOST_BUSY;
 +	cmd = mempool_alloc(virtscsi_cmd_pool, GFP_ATOMIC);
 +	if (!cmd)
 +		goto out;
 +
  	memset(cmd, 0, sizeof(*cmd));
  	cmd->sc = sc;
 +	cmd->req.cmd = (struct virtio_scsi_cmd_req){
 +		.lun[0] = 1,
 +		.lun[1] = sc->device->id,
 +		.lun[2] = (sc->device->lun >> 8) | 0x40,
 +		.lun[3] = sc->device->lun & 0xff,
 +		.tag = (unsigned long)sc,
 +		.task_attr = VIRTIO_SCSI_S_SIMPLE,
 +		.prio = 0,
 +		.crn = 0,
 +	};
  
  	BUG_ON(sc->cmd_len > VIRTIO_SCSI_CDB_SIZE);
 +	memcpy(cmd->req.cmd.cdb, sc->cmnd, sc->cmd_len);
  
++<<<<<<< HEAD
 +	if (virtscsi_kick_cmd(req_vq, cmd,
 +			      sizeof cmd->req.cmd, sizeof cmd->resp.cmd) == 0)
 +		ret = 0;
 +	else
 +		mempool_free(cmd, virtscsi_cmd_pool);
++=======
+ 	if (virtio_has_feature(vscsi->vdev, VIRTIO_SCSI_F_T10_PI)) {
+ 		virtio_scsi_init_hdr_pi(vscsi->vdev, &cmd->req.cmd_pi, sc);
+ 		memcpy(cmd->req.cmd_pi.cdb, sc->cmnd, sc->cmd_len);
+ 		req_size = sizeof(cmd->req.cmd_pi);
+ 	} else {
+ 		virtio_scsi_init_hdr(vscsi->vdev, &cmd->req.cmd, sc);
+ 		memcpy(cmd->req.cmd.cdb, sc->cmnd, sc->cmd_len);
+ 		req_size = sizeof(cmd->req.cmd);
+ 	}
++>>>>>>> d75dff39dfb8 (virtio_scsi: v1.0 support)
  
 -	if (virtscsi_kick_cmd(req_vq, cmd, req_size, sizeof(cmd->resp.cmd)) != 0)
 -		return SCSI_MLQUEUE_HOST_BUSY;
 -	return 0;
 +out:
 +	return ret;
  }
  
  static int virtscsi_queuecommand_single(struct Scsi_Host *sh,
@@@ -1024,6 -1084,8 +1083,11 @@@ static struct virtio_device_id id_table
  static unsigned int features[] = {
  	VIRTIO_SCSI_F_HOTPLUG,
  	VIRTIO_SCSI_F_CHANGE,
++<<<<<<< HEAD
++=======
+ 	VIRTIO_SCSI_F_T10_PI,
+ 	VIRTIO_F_VERSION_1,
++>>>>>>> d75dff39dfb8 (virtio_scsi: v1.0 support)
  };
  
  static struct virtio_driver virtio_scsi_driver = {
diff --cc include/linux/virtio_scsi.h
index 4195b97a3def,af448649a975..000000000000
--- a/include/linux/virtio_scsi.h
+++ b/include/linux/virtio_scsi.h
@@@ -33,18 -35,30 +35,33 @@@
  /* SCSI command request, followed by data-out */
  struct virtio_scsi_cmd_req {
  	u8 lun[8];		/* Logical Unit Number */
- 	u64 tag;		/* Command identifier */
+ 	__virtio64 tag;		/* Command identifier */
  	u8 task_attr;		/* Task attribute */
 -	u8 prio;		/* SAM command priority field */
 +	u8 prio;
  	u8 crn;
  	u8 cdb[VIRTIO_SCSI_CDB_SIZE];
  } __packed;
  
++<<<<<<< HEAD
++=======
+ /* SCSI command request, followed by protection information */
+ struct virtio_scsi_cmd_req_pi {
+ 	u8 lun[8];		/* Logical Unit Number */
+ 	__virtio64 tag;		/* Command identifier */
+ 	u8 task_attr;		/* Task attribute */
+ 	u8 prio;		/* SAM command priority field */
+ 	u8 crn;
+ 	__virtio32 pi_bytesout;	/* DataOUT PI Number of bytes */
+ 	__virtio32 pi_bytesin;		/* DataIN PI Number of bytes */
+ 	u8 cdb[VIRTIO_SCSI_CDB_SIZE];
+ } __packed;
+ 
++>>>>>>> d75dff39dfb8 (virtio_scsi: v1.0 support)
  /* Response, followed by sense data and data-in */
  struct virtio_scsi_cmd_resp {
- 	u32 sense_len;		/* Sense data length */
- 	u32 resid;		/* Residual bytes in data buffer */
- 	u16 status_qualifier;	/* Status qualifier */
+ 	__virtio32 sense_len;		/* Sense data length */
+ 	__virtio32 resid;		/* Residual bytes in data buffer */
+ 	__virtio16 status_qualifier;	/* Status qualifier */
  	u8 status;		/* Command completion status */
  	u8 response;		/* Response values */
  	u8 sense[VIRTIO_SCSI_SENSE_SIZE];
* Unmerged path drivers/scsi/virtio_scsi.c
* Unmerged path include/linux/virtio_scsi.h
