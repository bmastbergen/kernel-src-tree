bonding: add bond_has_slaves() and use it

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Veaceslav Falico <vfalico@redhat.com>
commit 0965a1f3f8757a2c20a16a83bc18279009d79a26
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/0965a1f3.failed

Currently we verify if we have slaves by checking if bond->slave_list is
empty. Create a define bond_has_slaves() and use it, a bit more readable
and easier to change in the future.

CC: Jay Vosburgh <fubar@us.ibm.com>
CC: Andy Gospodarek <andy@greyhouse.net>
	Signed-off-by: Veaceslav Falico <vfalico@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0965a1f3f8757a2c20a16a83bc18279009d79a26)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_3ad.c
#	drivers/net/bonding/bond_alb.c
#	drivers/net/bonding/bond_main.c
#	drivers/net/bonding/bond_sysfs.c
#	drivers/net/bonding/bonding.h
diff --cc drivers/net/bonding/bond_3ad.c
index 390061d09693,1337eafe4311..000000000000
--- a/drivers/net/bonding/bond_3ad.c
+++ b/drivers/net/bonding/bond_3ad.c
@@@ -2110,7 -2117,7 +2110,11 @@@ void bond_3ad_state_machine_handler(str
  	read_lock(&bond->lock);
  
  	//check if there are any slaves
++<<<<<<< HEAD
 +	if (bond->slave_cnt == 0)
++=======
+ 	if (!bond_has_slaves(bond))
++>>>>>>> 0965a1f3f875 (bonding: add bond_has_slaves() and use it)
  		goto re_arm;
  
  	// check if agg_select_timer timer after initialize is timed out
diff --cc drivers/net/bonding/bond_alb.c
index b7563cd17726,e96041816b5b..000000000000
--- a/drivers/net/bonding/bond_alb.c
+++ b/drivers/net/bonding/bond_alb.c
@@@ -1173,11 -1174,11 +1173,15 @@@ static void alb_change_hw_addr_on_detac
   */
  static int alb_handle_addr_collision_on_attach(struct bonding *bond, struct slave *slave)
  {
 -	struct slave *has_bond_addr = bond->curr_active_slave;
  	struct slave *tmp_slave1, *free_mac_slave = NULL;
 -	struct list_head *iter;
 +	struct slave *has_bond_addr = bond->curr_active_slave;
 +	int i;
  
++<<<<<<< HEAD
 +	if (bond->slave_cnt == 0) {
++=======
+ 	if (!bond_has_slaves(bond)) {
++>>>>>>> 0965a1f3f875 (bonding: add bond_has_slaves() and use it)
  		/* this is the first slave */
  		return 0;
  	}
@@@ -1466,7 -1469,7 +1470,11 @@@ void bond_alb_monitor(struct work_struc
  
  	read_lock(&bond->lock);
  
++<<<<<<< HEAD
 +	if (bond->slave_cnt == 0) {
++=======
+ 	if (!bond_has_slaves(bond)) {
++>>>>>>> 0965a1f3f875 (bonding: add bond_has_slaves() and use it)
  		bond_info->tx_rebalance_counter = 0;
  		bond_info->lp_counter = 0;
  		goto re_arm;
@@@ -1604,9 -1606,8 +1612,13 @@@ int bond_alb_init_slave(struct bonding 
   */
  void bond_alb_deinit_slave(struct bonding *bond, struct slave *slave)
  {
++<<<<<<< HEAD
 +	if (bond->slave_cnt > 1) {
++=======
+ 	if (bond_has_slaves(bond))
++>>>>>>> 0965a1f3f875 (bonding: add bond_has_slaves() and use it)
  		alb_change_hw_addr_on_detach(bond, slave);
 +	}
  
  	tlb_clear_slave(bond, slave, 0);
  
@@@ -1674,11 -1674,10 +1686,15 @@@ void bond_alb_handle_active_change(stru
  	}
  
  	swap_slave = bond->curr_active_slave;
 -	rcu_assign_pointer(bond->curr_active_slave, new_slave);
 +	bond->curr_active_slave = new_slave;
  
++<<<<<<< HEAD
 +	if (!new_slave || (bond->slave_cnt == 0)) {
++=======
+ 	if (!new_slave || !bond_has_slaves(bond))
++>>>>>>> 0965a1f3f875 (bonding: add bond_has_slaves() and use it)
  		return;
 +	}
  
  	/* set the new curr_active_slave to the bonds mac address
  	 * i.e. swap mac addresses of old curr_active_slave and new curr_active_slave
diff --cc drivers/net/bonding/bond_main.c
index 05a57077bb1c,06ffc8ace54c..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -531,10 -388,10 +531,14 @@@ static void bond_del_vlans_from_slave(s
   */
  static int bond_set_carrier(struct bonding *bond)
  {
 -	struct list_head *iter;
  	struct slave *slave;
 +	int i;
  
++<<<<<<< HEAD
 +	if (bond->slave_cnt == 0)
++=======
+ 	if (!bond_has_slaves(bond))
++>>>>>>> 0965a1f3f875 (bonding: add bond_has_slaves() and use it)
  		goto down;
  
  	if (bond->params.mode == BOND_MODE_8023AD)
@@@ -1311,14 -1078,18 +1315,22 @@@ static void bond_netpoll_cleanup(struc
  /*---------------------------------- IOCTL ----------------------------------*/
  
  static netdev_features_t bond_fix_features(struct net_device *dev,
 -					   netdev_features_t features)
 +	netdev_features_t features)
  {
 +	struct slave *slave;
  	struct bonding *bond = netdev_priv(dev);
 -	struct list_head *iter;
  	netdev_features_t mask;
 -	struct slave *slave;
 +	int i;
  
++<<<<<<< HEAD
 +	read_lock(&bond->lock);
++=======
+ 	if (!bond_has_slaves(bond)) {
+ 		/* Disable adding VLANs to empty bond. But why? --mq */
+ 		features |= NETIF_F_VLAN_CHALLENGED;
+ 		return features;
+ 	}
++>>>>>>> 0965a1f3f875 (bonding: add bond_has_slaves() and use it)
  
  	mask = features;
  	features &= ~NETIF_F_ONE_FOR_ALL;
@@@ -1347,15 -1119,11 +1359,19 @@@ static void bond_compute_features(struc
  	unsigned short max_hard_header_len = ETH_HLEN;
  	unsigned int gso_max_size = GSO_MAX_SIZE;
  	u16 gso_max_segs = GSO_MAX_SEGS;
 +	int i;
 +	unsigned int flags, dst_release_flag = IFF_XMIT_DST_RELEASE;
 +
++<<<<<<< HEAD
 +	read_lock(&bond->lock);
  
 +	if (!bond->first_slave)
++=======
+ 	if (!bond_has_slaves(bond))
++>>>>>>> 0965a1f3f875 (bonding: add bond_has_slaves() and use it)
  		goto done;
  
 -	bond_for_each_slave(bond, slave, iter) {
 +	bond_for_each_slave(bond, slave, i) {
  		vlan_features = netdev_increment_features(vlan_features,
  			slave->dev->vlan_features, BOND_VLAN_FEATURES);
  
@@@ -1545,7 -1310,7 +1561,11 @@@ int bond_enslave(struct net_device *bon
  	 * bond ether type mutual exclusion - don't allow slaves of dissimilar
  	 * ether type (eg ARPHRD_ETHER and ARPHRD_INFINIBAND) share the same bond
  	 */
++<<<<<<< HEAD
 +	if (bond->slave_cnt == 0) {
++=======
+ 	if (!bond_has_slaves(bond)) {
++>>>>>>> 0965a1f3f875 (bonding: add bond_has_slaves() and use it)
  		if (bond_dev->type != slave_dev->type) {
  			pr_debug("%s: change device type from %d to %d\n",
  				 bond_dev->name,
@@@ -1584,7 -1349,7 +1604,11 @@@
  	}
  
  	if (slave_ops->ndo_set_mac_address == NULL) {
++<<<<<<< HEAD
 +		if (bond->slave_cnt == 0) {
++=======
+ 		if (!bond_has_slaves(bond)) {
++>>>>>>> 0965a1f3f875 (bonding: add bond_has_slaves() and use it)
  			pr_warning("%s: Warning: The first slave device specified does not support setting the MAC address. Setting fail_over_mac to active.",
  				   bond_dev->name);
  			bond->params.fail_over_mac = BOND_FOM_ACTIVE;
@@@ -1600,7 -1365,8 +1624,12 @@@
  
  	/* If this is the first slave, then we need to set the master's hardware
  	 * address to be the same as the slave's. */
++<<<<<<< HEAD
 +	if (!bond->slave_cnt && bond->dev->addr_assign_type == NET_ADDR_RANDOM)
++=======
+ 	if (!bond_has_slaves(bond) &&
+ 	    bond->dev->addr_assign_type == NET_ADDR_RANDOM)
++>>>>>>> 0965a1f3f875 (bonding: add bond_has_slaves() and use it)
  		bond_set_dev_addr(bond->dev, slave_dev);
  
  	new_slave = kzalloc(sizeof(struct slave), GFP_KERNEL);
@@@ -1925,7 -1696,7 +1954,11 @@@ err_free
  err_undo_flags:
  	bond_compute_features(bond);
  	/* Enslave of first slave has failed and we need to fix master's mac */
++<<<<<<< HEAD
 +	if (bond->slave_cnt == 0 &&
++=======
+ 	if (!bond_has_slaves(bond) &&
++>>>>>>> 0965a1f3f875 (bonding: add bond_has_slaves() and use it)
  	    ether_addr_equal(bond_dev->dev_addr, slave_dev->dev_addr))
  		eth_hw_addr_random(bond_dev);
  
@@@ -2013,6 -1774,15 +2046,18 @@@ static int __bond_release_one(struct ne
  	/* release the slave from its bond */
  	bond_detach_slave(bond, slave);
  
++<<<<<<< HEAD
++=======
+ 	if (!all && !bond->params.fail_over_mac) {
+ 		if (ether_addr_equal(bond_dev->dev_addr, slave->perm_hwaddr) &&
+ 		    bond_has_slaves(bond))
+ 			pr_warn("%s: Warning: the permanent HWaddr of %s - %pM - is still in use by %s. Set the HWaddr of %s to a different address to avoid conflicts.\n",
+ 				   bond_dev->name, slave_dev->name,
+ 				   slave->perm_hwaddr,
+ 				   bond_dev->name, slave_dev->name);
+ 	}
+ 
++>>>>>>> 0965a1f3f875 (bonding: add bond_has_slaves() and use it)
  	if (bond->primary_slave == slave)
  		bond->primary_slave = NULL;
  
@@@ -2049,15 -1819,23 +2094,23 @@@
  		write_lock_bh(&bond->lock);
  	}
  
++<<<<<<< HEAD
 +	if (bond->slave_cnt == 0) {
++=======
+ 	if (!bond_has_slaves(bond)) {
++>>>>>>> 0965a1f3f875 (bonding: add bond_has_slaves() and use it)
  		bond_set_carrier(bond);
  		eth_hw_addr_random(bond_dev);
 -
 -		if (vlan_uses_dev(bond_dev)) {
 -			pr_warning("%s: Warning: clearing HW address of %s while it still has VLANs.\n",
 -				   bond_dev->name, bond_dev->name);
 -			pr_warning("%s: When re-adding slaves, make sure the bond's HW address matches its VLANs'.\n",
 -				   bond_dev->name);
 -		}
  	}
  
  	write_unlock_bh(&bond->lock);
  	unblock_netpoll_tx();
 -	synchronize_rcu();
  
++<<<<<<< HEAD
 +	if (bond->slave_cnt == 0) {
++=======
+ 	if (!bond_has_slaves(bond)) {
++>>>>>>> 0965a1f3f875 (bonding: add bond_has_slaves() and use it)
  		call_netdevice_notifiers(NETDEV_CHANGEADDR, bond->dev);
  		call_netdevice_notifiers(NETDEV_RELEASE, bond->dev);
  	}
@@@ -2136,7 -1904,7 +2189,11 @@@ static int  bond_release_and_destroy(st
  	int ret;
  
  	ret = bond_release(bond_dev, slave_dev);
++<<<<<<< HEAD
 +	if ((ret == 0) && (bond->slave_cnt == 0)) {
++=======
+ 	if (ret == 0 && !bond_has_slaves(bond)) {
++>>>>>>> 0965a1f3f875 (bonding: add bond_has_slaves() and use it)
  		bond_dev->priv_flags |= IFF_DISABLE_NETPOLL;
  		pr_info("%s: destroying bond %s.\n",
  			bond_dev->name, bond_dev->name);
@@@ -2451,7 -2219,7 +2508,11 @@@ void bond_mii_monitor(struct work_struc
  
  	delay = msecs_to_jiffies(bond->params.miimon);
  
++<<<<<<< HEAD
 +	if (bond->slave_cnt == 0)
++=======
+ 	if (!bond_has_slaves(bond))
++>>>>>>> 0965a1f3f875 (bonding: add bond_has_slaves() and use it)
  		goto re_arm;
  
  	should_notify_peers = bond_should_notify_peers(bond);
@@@ -2730,10 -2513,7 +2791,14 @@@ void bond_loadbalance_arp_mon(struct wo
  
  	read_lock(&bond->lock);
  
++<<<<<<< HEAD
 +	delta_in_ticks = msecs_to_jiffies(bond->params.arp_interval);
 +	extra_ticks = delta_in_ticks / 2;
 +
 +	if (bond->slave_cnt == 0)
++=======
+ 	if (!bond_has_slaves(bond))
++>>>>>>> 0965a1f3f875 (bonding: add bond_has_slaves() and use it)
  		goto re_arm;
  
  	oldcurrent = bond->curr_active_slave;
@@@ -3083,7 -2845,7 +3148,11 @@@ void bond_activebackup_arp_mon(struct w
  
  	delta_in_ticks = msecs_to_jiffies(bond->params.arp_interval);
  
++<<<<<<< HEAD
 +	if (bond->slave_cnt == 0)
++=======
+ 	if (!bond_has_slaves(bond))
++>>>>>>> 0965a1f3f875 (bonding: add bond_has_slaves() and use it)
  		goto re_arm;
  
  	should_notify_peers = bond_should_notify_peers(bond);
@@@ -3407,9 -3169,9 +3476,13 @@@ static int bond_open(struct net_device 
  
  	/* reset slave->backup and slave->inactive */
  	read_lock(&bond->lock);
++<<<<<<< HEAD
 +	if (bond->slave_cnt > 0) {
++=======
+ 	if (bond_has_slaves(bond)) {
++>>>>>>> 0965a1f3f875 (bonding: add bond_has_slaves() and use it)
  		read_lock(&bond->curr_slave_lock);
 -		bond_for_each_slave(bond, slave, iter) {
 +		bond_for_each_slave(bond, slave, i) {
  			if ((bond->params.mode == BOND_MODE_ACTIVEBACKUP)
  				&& (slave != bond->curr_active_slave)) {
  				bond_set_slave_inactive_flags(slave);
@@@ -4164,9 -3891,8 +4237,14 @@@ static netdev_tx_t bond_start_xmit(stru
  	if (is_netpoll_tx_blocked(dev))
  		return NETDEV_TX_BUSY;
  
++<<<<<<< HEAD
 +	read_lock(&bond->lock);
 +
 +	if (bond->slave_cnt)
++=======
+ 	rcu_read_lock();
+ 	if (bond_has_slaves(bond))
++>>>>>>> 0965a1f3f875 (bonding: add bond_has_slaves() and use it)
  		ret = __bond_start_xmit(skb, dev);
  	else
  		kfree_skb(skb);
diff --cc drivers/net/bonding/bond_sysfs.c
index 739d4dbe8629,04d95d6f6c63..000000000000
--- a/drivers/net/bonding/bond_sysfs.c
+++ b/drivers/net/bonding/bond_sysfs.c
@@@ -325,7 -327,7 +325,11 @@@ static ssize_t bonding_store_mode(struc
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	if (bond->slave_cnt > 0) {
++=======
+ 	if (bond_has_slaves(bond)) {
++>>>>>>> 0965a1f3f875 (bonding: add bond_has_slaves() and use it)
  		pr_err("unable to update mode of %s because it has slaves.\n",
  			bond->dev->name);
  		ret = -EPERM;
@@@ -521,7 -523,7 +525,11 @@@ static ssize_t bonding_store_fail_over_
  	if (!rtnl_trylock())
  		return restart_syscall();
  
++<<<<<<< HEAD
 +	if (bond->slave_cnt != 0) {
++=======
+ 	if (bond_has_slaves(bond)) {
++>>>>>>> 0965a1f3f875 (bonding: add bond_has_slaves() and use it)
  		pr_err("%s: Can't alter fail_over_mac with slaves in bond.\n",
  		       bond->dev->name);
  		ret = -EPERM;
diff --cc drivers/net/bonding/bonding.h
index 788e19ed5f58,bcef15ec3459..000000000000
--- a/drivers/net/bonding/bonding.h
+++ b/drivers/net/bonding/bonding.h
@@@ -71,12 -71,35 +71,39 @@@
  	set_fs(fs);			\
  	res; })
  
++<<<<<<< HEAD
++=======
+ /* slave list primitives */
+ #define bond_has_slaves(bond) !list_empty(&(bond)->slave_list)
+ 
+ #define bond_to_slave(ptr) list_entry(ptr, struct slave, list)
+ 
+ /* IMPORTANT: bond_first/last_slave can return NULL in case of an empty list */
+ #define bond_first_slave(bond) \
+ 	list_first_entry_or_null(&(bond)->slave_list, struct slave, list)
+ #define bond_last_slave(bond) \
+ 	(list_empty(&(bond)->slave_list) ? NULL : \
+ 					   bond_to_slave((bond)->slave_list.prev))
+ 
+ #define bond_is_first_slave(bond, pos) ((pos)->list.prev == &(bond)->slave_list)
+ #define bond_is_last_slave(bond, pos) ((pos)->list.next == &(bond)->slave_list)
+ 
+ /* Since bond_first/last_slave can return NULL, these can return NULL too */
+ #define bond_next_slave(bond, pos) \
+ 	(bond_is_last_slave(bond, pos) ? bond_first_slave(bond) : \
+ 					 bond_to_slave((pos)->list.next))
+ 
+ #define bond_prev_slave(bond, pos) \
+ 	(bond_is_first_slave(bond, pos) ? bond_last_slave(bond) : \
+ 					  bond_to_slave((pos)->list.prev))
+ 
++>>>>>>> 0965a1f3f875 (bonding: add bond_has_slaves() and use it)
  /**
 - * bond_for_each_slave - iterate over all slaves
 - * @bond:	the bond holding this list
 - * @pos:	current slave
 - * @iter:	list_head * iterator
 + * bond_for_each_slave_from - iterate the slaves list from a starting point
 + * @bond:	the bond holding this list.
 + * @pos:	current slave.
 + * @cnt:	counter for max number of moves
 + * @start:	starting point.
   *
   * Caller must hold bond->lock
   */
* Unmerged path drivers/net/bonding/bond_3ad.c
* Unmerged path drivers/net/bonding/bond_alb.c
* Unmerged path drivers/net/bonding/bond_main.c
* Unmerged path drivers/net/bonding/bond_sysfs.c
* Unmerged path drivers/net/bonding/bonding.h
