drm/nouveau/drm/nv04-nv40/instmem: protect access to priv->heap by mutex

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [drm] nouveau/drm/nv04-nv40/instmem: protect access to priv->heap by mutex (Rob Clark) [1249805]
Rebuild_FUZZ: 97.14%
commit-author Kamil Dudka <kdudka@redhat.com>
commit 7512223b1ece29a5968ed8b67ccb891d21b7834b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/7512223b.failed

This fixes the list_del corruption reported
at <https://bugzilla.redhat.com/1205985>.

	Signed-off-by: Kamil Dudka <kdudka@redhat.com>
(cherry picked from commit 7512223b1ece29a5968ed8b67ccb891d21b7834b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/nouveau/core/subdev/instmem/nv04.c
diff --cc drivers/gpu/drm/nouveau/core/subdev/instmem/nv04.c
index 7b64befee48f,282143f49d72..000000000000
--- a/drivers/gpu/drm/nouveau/core/subdev/instmem/nv04.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/instmem/nv04.c
@@@ -43,22 -46,28 +43,37 @@@ nv04_instobj_wr32(struct nouveau_objec
  }
  
  static void
 -nv04_instobj_dtor(struct nvkm_object *object)
 +nv04_instobj_dtor(struct nouveau_object *object)
  {
 -	struct nv04_instmem_priv *priv = (void *)nvkm_instmem(object);
 +	struct nv04_instmem_priv *priv = (void *)object->engine;
  	struct nv04_instobj_priv *node = (void *)object;
++<<<<<<< HEAD:drivers/gpu/drm/nouveau/core/subdev/instmem/nv04.c
 +	nouveau_mm_free(&priv->heap, &node->mem);
 +	nouveau_instobj_destroy(&node->base);
++=======
+ 	struct nvkm_subdev *subdev = (void *)priv;
+ 
+ 	mutex_lock(&subdev->mutex);
+ 	nvkm_mm_free(&priv->heap, &node->mem);
+ 	mutex_unlock(&subdev->mutex);
+ 
+ 	nvkm_instobj_destroy(&node->base);
++>>>>>>> 7512223b1ece (drm/nouveau/drm/nv04-nv40/instmem: protect access to priv->heap by mutex):drivers/gpu/drm/nouveau/nvkm/subdev/instmem/nv04.c
  }
  
  static int
 -nv04_instobj_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 -		  struct nvkm_oclass *oclass, void *data, u32 size,
 -		  struct nvkm_object **pobject)
 +nv04_instobj_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
 +		  struct nouveau_oclass *oclass, void *data, u32 size,
 +		  struct nouveau_object **pobject)
  {
 -	struct nv04_instmem_priv *priv = (void *)nvkm_instmem(parent);
 +	struct nv04_instmem_priv *priv = (void *)engine;
  	struct nv04_instobj_priv *node;
++<<<<<<< HEAD:drivers/gpu/drm/nouveau/core/subdev/instmem/nv04.c
 +	struct nouveau_instobj_args *args = data;
++=======
+ 	struct nvkm_instobj_args *args = data;
+ 	struct nvkm_subdev *subdev = (void *)priv;
++>>>>>>> 7512223b1ece (drm/nouveau/drm/nv04-nv40/instmem: protect access to priv->heap by mutex):drivers/gpu/drm/nouveau/nvkm/subdev/instmem/nv04.c
  	int ret;
  
  	if (!args->align)
@@@ -69,8 -78,10 +84,15 @@@
  	if (ret)
  		return ret;
  
++<<<<<<< HEAD:drivers/gpu/drm/nouveau/core/subdev/instmem/nv04.c
 +	ret = nouveau_mm_head(&priv->heap, 1, args->size, args->size,
 +			      args->align, &node->mem);
++=======
+ 	mutex_lock(&subdev->mutex);
+ 	ret = nvkm_mm_head(&priv->heap, 0, 1, args->size, args->size,
+ 			   args->align, &node->mem);
+ 	mutex_unlock(&subdev->mutex);
++>>>>>>> 7512223b1ece (drm/nouveau/drm/nv04-nv40/instmem: protect access to priv->heap by mutex):drivers/gpu/drm/nouveau/nvkm/subdev/instmem/nv04.c
  	if (ret)
  		return ret;
  
* Unmerged path drivers/gpu/drm/nouveau/core/subdev/instmem/nv04.c
