IB/iser: Remove a redundant struct iser_data_buf

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [infiniband] iser: Remove a redundant struct iser_data_buf (Amir Vadai) [1164539]
Rebuild_FUZZ: 96.77%
commit-author Sagi Grimberg <sagig@mellanox.com>
commit e3784bd1d9f1039f28dff2c0c0d17daabb3d6761
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/e3784bd1.failed

No need to keep two iser_data_buf structures just in case we use
mem copy. We can avoid that just by adding a pointer to the original
sg. So keep only two iser_data_buf per command (data and protection)
and pass the relevant data_buf to bounce buffer routine.

This patch does not change any functionality.

	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Adir Lev <adirl@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit e3784bd1d9f1039f28dff2c0c0d17daabb3d6761)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/iser/iscsi_iser.h
#	drivers/infiniband/ulp/iser/iser_memory.c
diff --cc drivers/infiniband/ulp/iser/iscsi_iser.h
index e160d7ee63dc,5c7036c90766..000000000000
--- a/drivers/infiniband/ulp/iser/iscsi_iser.h
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.h
@@@ -197,15 -215,28 +197,40 @@@ enum iser_data_dir 
  	ISER_DIRS_NUM
  };
  
++<<<<<<< HEAD
 +struct iser_data_buf {
 +	void               *buf;      /* pointer to the sg list               */
 +	unsigned int       size;      /* num entries of this sg               */
 +	unsigned long      data_len;  /* total data len                       */
 +	unsigned int       dma_nents; /* returned by dma_map_sg               */
 +	char       	   *copy_buf; /* allocated copy buf for SGs unaligned *
 +	                               * for rdma which are copied            */
 +	struct scatterlist sg_single; /* SG-ified clone of a non SG SC or     *
 +				       * unaligned SG                         */
++=======
+ /**
+  * struct iser_data_buf - iSER data buffer
+  *
+  * @sg:           pointer to the sg list
+  * @size:         num entries of this sg
+  * @data_len:     total beffer byte len
+  * @dma_nents:    returned by dma_map_sg
+  * @copy_buf:     allocated copy buf for SGs unaligned
+  *                for rdma which are copied
+  * @orig_sg:      pointer to the original sg list (in case
+  *                we used a copy)
+  * @sg_single:    SG-ified clone of a non SG SC or
+  *                unaligned SG
+  */
+ struct iser_data_buf {
+ 	struct scatterlist *sg;
+ 	unsigned int       size;
+ 	unsigned long      data_len;
+ 	unsigned int       dma_nents;
+ 	struct scatterlist *orig_sg;
+ 	char               *copy_buf;
+ 	struct scatterlist sg_single;
++>>>>>>> e3784bd1d9f1 (IB/iser: Remove a redundant struct iser_data_buf)
    };
  
  /* fwd declarations */
@@@ -341,35 -525,32 +366,59 @@@ struct iser_conn 
  	u64			     login_req_dma, login_resp_dma;
  	unsigned int 		     rx_desc_head;
  	struct iser_rx_desc	     *rx_descs;
 -	u32                          num_rx_descs;
 +	struct ib_recv_wr	     rx_wr[ISER_MIN_POSTED_RX];
 +	bool			     pi_support;
 +
 +	/* Connection memory registration pool */
 +	union {
 +		struct {
 +			struct ib_fmr_pool      *pool;	   /* pool of IB FMRs         */
 +			struct iser_page_vec	*page_vec; /* represents SG to fmr maps*
 +							    * maps serialized as tx is*/
 +		} fmr;
 +		struct {
 +			struct list_head	pool;
 +			int			pool_size;
 +		} fastreg;
 +	};
  };
  
++<<<<<<< HEAD
++=======
+ /**
+  * struct iscsi_iser_task - iser task context
+  *
+  * @desc:     TX descriptor
+  * @iser_conn:        link to iser connection
+  * @status:           current task status
+  * @sc:               link to scsi command
+  * @command_sent:     indicate if command was sent
+  * @dir:              iser data direction
+  * @rdma_regd:        task rdma registration desc
+  * @data:             iser data buffer desc
+  * @prot:             iser protection buffer desc
+  */
++>>>>>>> e3784bd1d9f1 (IB/iser: Remove a redundant struct iser_data_buf)
  struct iscsi_iser_task {
  	struct iser_tx_desc          desc;
 -	struct iser_conn	     *iser_conn;
 +	struct iser_conn	     *ib_conn;
  	enum iser_task_status 	     status;
  	struct scsi_cmnd	     *sc;
++<<<<<<< HEAD
 +	int                          command_sent;  /* set if command  sent  */
 +	int                          dir[ISER_DIRS_NUM];      /* set if dir use*/
 +	struct iser_regd_buf         rdma_regd[ISER_DIRS_NUM];/* regd rdma buf */
 +	struct iser_data_buf         data[ISER_DIRS_NUM];     /* orig. data des*/
 +	struct iser_data_buf         data_copy[ISER_DIRS_NUM];/* contig. copy  */
 +	struct iser_data_buf         prot[ISER_DIRS_NUM];     /* prot desc     */
 +	struct iser_data_buf         prot_copy[ISER_DIRS_NUM];/* prot copy     */
++=======
+ 	int                          command_sent;
+ 	int                          dir[ISER_DIRS_NUM];
+ 	struct iser_regd_buf         rdma_regd[ISER_DIRS_NUM];
+ 	struct iser_data_buf         data[ISER_DIRS_NUM];
+ 	struct iser_data_buf         prot[ISER_DIRS_NUM];
++>>>>>>> e3784bd1d9f1 (IB/iser: Remove a redundant struct iser_data_buf)
  };
  
  struct iser_page_vec {
diff --cc drivers/infiniband/ulp/iser/iser_memory.c
index f40132fc970c,beeabd0e05c1..000000000000
--- a/drivers/infiniband/ulp/iser/iser_memory.c
+++ b/drivers/infiniband/ulp/iser/iser_memory.c
@@@ -46,11 -46,10 +46,15 @@@
   */
  static int iser_start_rdma_unaligned_sg(struct iscsi_iser_task *iser_task,
  					struct iser_data_buf *data,
- 					struct iser_data_buf *data_copy,
  					enum iser_data_dir cmd_dir)
  {
++<<<<<<< HEAD
 +	struct ib_device *dev = iser_task->ib_conn->device->ib_device;
 +	struct scatterlist *sgl = (struct scatterlist *)data->buf;
++=======
+ 	struct ib_device *dev = iser_task->iser_conn->ib_conn.device->ib_device;
+ 	struct scatterlist *sgl = data->sg;
++>>>>>>> e3784bd1d9f1 (IB/iser: Remove a redundant struct iser_data_buf)
  	struct scatterlist *sg;
  	char *mem = NULL;
  	unsigned long  cmd_data_len = data->data_len;
@@@ -70,10 -69,9 +74,10 @@@
  
  	if (cmd_dir == ISER_DIR_OUT) {
  		/* copy the unaligned sg the buffer which is used for RDMA */
 +		int i;
  		char *p, *from;
  
- 		sgl = (struct scatterlist *)data->buf;
+ 		sgl = data->sg;
  		p = mem;
  		for_each_sg(sgl, sg, data->size, i) {
  			from = kmap_atomic(sg_page(sg));
@@@ -113,9 -108,9 +114,9 @@@ void iser_finalize_rdma_unaligned_sg(st
  	struct ib_device *dev;
  	unsigned long  cmd_data_len;
  
 -	dev = iser_task->iser_conn->ib_conn.device->ib_device;
 +	dev = iser_task->ib_conn->device->ib_device;
  
- 	ib_dma_unmap_sg(dev, &data_copy->sg_single, 1,
+ 	ib_dma_unmap_sg(dev, data->sg, 1,
  			(cmd_dir == ISER_DIR_OUT) ?
  			DMA_TO_DEVICE : DMA_FROM_DEVICE);
  
@@@ -319,9 -313,9 +319,9 @@@ int iser_dma_map_task_data(struct iscsi
  	struct ib_device *dev;
  
  	iser_task->dir[iser_dir] = 1;
 -	dev = iser_task->iser_conn->ib_conn.device->ib_device;
 +	dev = iser_task->ib_conn->device->ib_device;
  
- 	data->dma_nents = ib_dma_map_sg(dev, data->buf, data->size, dma_dir);
+ 	data->dma_nents = ib_dma_map_sg(dev, data->sg, data->size, dma_dir);
  	if (data->dma_nents == 0) {
  		iser_err("dma_map_sg failed!!!\n");
  		return -EINVAL;
@@@ -334,8 -329,8 +334,13 @@@ void iser_dma_unmap_task_data(struct is
  {
  	struct ib_device *dev;
  
++<<<<<<< HEAD
 +	dev = iser_task->ib_conn->device->ib_device;
 +	ib_dma_unmap_sg(dev, data->buf, data->size, DMA_FROM_DEVICE);
++=======
+ 	dev = iser_task->iser_conn->ib_conn.device->ib_device;
+ 	ib_dma_unmap_sg(dev, data->sg, data->size, dir);
++>>>>>>> e3784bd1d9f1 (IB/iser: Remove a redundant struct iser_data_buf)
  }
  
  static int fall_to_bounce_buf(struct iscsi_iser_task *iser_task,
* Unmerged path drivers/infiniband/ulp/iser/iscsi_iser.h
diff --git a/drivers/infiniband/ulp/iser/iser_initiator.c b/drivers/infiniband/ulp/iser/iser_initiator.c
index 065346a65b0d..9b00cea7a904 100644
--- a/drivers/infiniband/ulp/iser/iser_initiator.c
+++ b/drivers/infiniband/ulp/iser/iser_initiator.c
@@ -394,13 +394,13 @@ int iser_send_command(struct iscsi_conn *conn,
 	}
 
 	if (scsi_sg_count(sc)) { /* using a scatter list */
-		data_buf->buf  = scsi_sglist(sc);
+		data_buf->sg = scsi_sglist(sc);
 		data_buf->size = scsi_sg_count(sc);
 	}
 	data_buf->data_len = scsi_bufflen(sc);
 
 	if (scsi_prot_sg_count(sc)) {
-		prot_buf->buf  = scsi_prot_sglist(sc);
+		prot_buf->sg  = scsi_prot_sglist(sc);
 		prot_buf->size = scsi_prot_sg_count(sc);
 		prot_buf->data_len = (data_buf->data_len >>
 				     ilog2(sc->device->sector_size)) * 8;
@@ -666,35 +666,31 @@ void iser_task_rdma_finalize(struct iscsi_iser_task *iser_task)
 	/* if we were reading, copy back to unaligned sglist,
 	 * anyway dma_unmap and free the copy
 	 */
-	if (iser_task->data_copy[ISER_DIR_IN].copy_buf != NULL) {
+	if (iser_task->data[ISER_DIR_IN].copy_buf) {
 		is_rdma_data_aligned = 0;
 		iser_finalize_rdma_unaligned_sg(iser_task,
 						&iser_task->data[ISER_DIR_IN],
-						&iser_task->data_copy[ISER_DIR_IN],
 						ISER_DIR_IN);
 	}
 
-	if (iser_task->data_copy[ISER_DIR_OUT].copy_buf != NULL) {
+	if (iser_task->data[ISER_DIR_OUT].copy_buf) {
 		is_rdma_data_aligned = 0;
 		iser_finalize_rdma_unaligned_sg(iser_task,
 						&iser_task->data[ISER_DIR_OUT],
-						&iser_task->data_copy[ISER_DIR_OUT],
 						ISER_DIR_OUT);
 	}
 
-	if (iser_task->prot_copy[ISER_DIR_IN].copy_buf != NULL) {
+	if (iser_task->prot[ISER_DIR_IN].copy_buf) {
 		is_rdma_prot_aligned = 0;
 		iser_finalize_rdma_unaligned_sg(iser_task,
 						&iser_task->prot[ISER_DIR_IN],
-						&iser_task->prot_copy[ISER_DIR_IN],
 						ISER_DIR_IN);
 	}
 
-	if (iser_task->prot_copy[ISER_DIR_OUT].copy_buf != NULL) {
+	if (iser_task->prot[ISER_DIR_OUT].copy_buf) {
 		is_rdma_prot_aligned = 0;
 		iser_finalize_rdma_unaligned_sg(iser_task,
 						&iser_task->prot[ISER_DIR_OUT],
-						&iser_task->prot_copy[ISER_DIR_OUT],
 						ISER_DIR_OUT);
 	}
 
* Unmerged path drivers/infiniband/ulp/iser/iser_memory.c
