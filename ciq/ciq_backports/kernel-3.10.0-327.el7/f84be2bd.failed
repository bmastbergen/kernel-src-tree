net: make net_get_random_once irq safe

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] make net_get_random_once irq safe (Ivan Vecera) [1200759]
Rebuild_FUZZ: 92.96%
commit-author Hannes Frederic Sowa <hannes@stressinduktion.org>
commit f84be2bd96a108b09c8440263fa3adb3fb225fa3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/f84be2bd.failed

I initial build non irq safe version of net_get_random_once because I
would liked to have the freedom to defer even the extraction process of
get_random_bytes until the nonblocking pool is fully seeded.

I don't think this is a good idea anymore and thus this patch makes
net_get_random_once irq safe. Now someone using net_get_random_once does
not need to care from where it is called.

	Cc: David S. Miller <davem@davemloft.net>
	Cc: Eric Dumazet <edumazet@google.com>
	Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f84be2bd96a108b09c8440263fa3adb3fb225fa3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/net.h
#	net/core/utils.c
diff --cc include/linux/net.h
index 6822d99f6b2e,b292a0435571..000000000000
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@@ -255,32 -240,52 +255,78 @@@ do {								
  #define net_random()		prandom_u32()
  #define net_srandom(seed)	prandom_seed((__force u32)(seed))
  
 -bool __net_get_random_once(void *buf, int nbytes, bool *done,
 -			   struct static_key *done_key);
 -
 +extern int   	     kernel_sendmsg(struct socket *sock, struct msghdr *msg,
 +				    struct kvec *vec, size_t num, size_t len);
 +extern int   	     kernel_recvmsg(struct socket *sock, struct msghdr *msg,
 +				    struct kvec *vec, size_t num,
 +				    size_t len, int flags);
 +
++<<<<<<< HEAD
 +extern int kernel_bind(struct socket *sock, struct sockaddr *addr,
 +		       int addrlen);
 +extern int kernel_listen(struct socket *sock, int backlog);
 +extern int kernel_accept(struct socket *sock, struct socket **newsock,
 +			 int flags);
 +extern int kernel_connect(struct socket *sock, struct sockaddr *addr,
 +			  int addrlen, int flags);
 +extern int kernel_getsockname(struct socket *sock, struct sockaddr *addr,
 +			      int *addrlen);
 +extern int kernel_getpeername(struct socket *sock, struct sockaddr *addr,
 +			      int *addrlen);
 +extern int kernel_getsockopt(struct socket *sock, int level, int optname,
 +			     char *optval, int *optlen);
 +extern int kernel_setsockopt(struct socket *sock, int level, int optname,
 +			     char *optval, unsigned int optlen);
 +extern int kernel_sendpage(struct socket *sock, struct page *page, int offset,
 +			   size_t size, int flags);
 +extern int kernel_sock_ioctl(struct socket *sock, int cmd, unsigned long arg);
 +extern int kernel_sock_shutdown(struct socket *sock,
 +				enum sock_shutdown_cmd how);
++=======
+ #ifdef HAVE_JUMP_LABEL
+ #define ___NET_RANDOM_STATIC_KEY_INIT ((struct static_key) \
+ 		{ .enabled = ATOMIC_INIT(0), .entries = (void *)1 })
+ #else /* !HAVE_JUMP_LABEL */
+ #define ___NET_RANDOM_STATIC_KEY_INIT STATIC_KEY_INIT_FALSE
+ #endif /* HAVE_JUMP_LABEL */
+ 
+ #define net_get_random_once(buf, nbytes)				\
+ 	({								\
+ 		bool ___ret = false;					\
+ 		static bool ___done = false;				\
+ 		static struct static_key ___done_key =			\
+ 			___NET_RANDOM_STATIC_KEY_INIT;			\
+ 		if (!static_key_true(&___done_key))			\
+ 			___ret = __net_get_random_once(buf,		\
+ 						       nbytes,		\
+ 						       &___done,	\
+ 						       &___done_key);	\
+ 		___ret;							\
+ 	})
+ 
+ int kernel_sendmsg(struct socket *sock, struct msghdr *msg, struct kvec *vec,
+ 		   size_t num, size_t len);
+ int kernel_recvmsg(struct socket *sock, struct msghdr *msg, struct kvec *vec,
+ 		   size_t num, size_t len, int flags);
+ 
+ int kernel_bind(struct socket *sock, struct sockaddr *addr, int addrlen);
+ int kernel_listen(struct socket *sock, int backlog);
+ int kernel_accept(struct socket *sock, struct socket **newsock, int flags);
+ int kernel_connect(struct socket *sock, struct sockaddr *addr, int addrlen,
+ 		   int flags);
+ int kernel_getsockname(struct socket *sock, struct sockaddr *addr,
+ 		       int *addrlen);
+ int kernel_getpeername(struct socket *sock, struct sockaddr *addr,
+ 		       int *addrlen);
+ int kernel_getsockopt(struct socket *sock, int level, int optname, char *optval,
+ 		      int *optlen);
+ int kernel_setsockopt(struct socket *sock, int level, int optname, char *optval,
+ 		      unsigned int optlen);
+ int kernel_sendpage(struct socket *sock, struct page *page, int offset,
+ 		    size_t size, int flags);
+ int kernel_sock_ioctl(struct socket *sock, int cmd, unsigned long arg);
+ int kernel_sock_shutdown(struct socket *sock, enum sock_shutdown_cmd how);
++>>>>>>> f84be2bd96a1 (net: make net_get_random_once irq safe)
  
  #define MODULE_ALIAS_NETPROTO(proto) \
  	MODULE_ALIAS("net-pf-" __stringify(proto))
diff --cc net/core/utils.c
index 3c7f5b51b979,2f737bf90b3f..000000000000
--- a/net/core/utils.c
+++ b/net/core/utils.c
@@@ -339,24 -339,51 +339,55 @@@ void inet_proto_csum_replace16(__sum16 
  }
  EXPORT_SYMBOL(inet_proto_csum_replace16);
  
 -struct __net_random_once_work {
 -	struct work_struct work;
 -	struct static_key *key;
 -};
 -
 -static void __net_random_once_deferred(struct work_struct *w)
 -{
 -	struct __net_random_once_work *work =
 -		container_of(w, struct __net_random_once_work, work);
 -	if (!static_key_enabled(work->key))
 -		static_key_slow_inc(work->key);
 -	kfree(work);
 -}
 -
 -static void __net_random_once_disable_jump(struct static_key *key)
 +int mac_pton(const char *s, u8 *mac)
  {
 -	struct __net_random_once_work *w;
 +	int i;
  
 +	/* XX:XX:XX:XX:XX:XX */
 +	if (strlen(s) < 3 * ETH_ALEN - 1)
 +		return 0;
 +
++<<<<<<< HEAD
 +	/* Don't dirty result unless string is valid MAC. */
 +	for (i = 0; i < ETH_ALEN; i++) {
 +		if (!isxdigit(s[i * 3]) || !isxdigit(s[i * 3 + 1]))
 +			return 0;
 +		if (i != ETH_ALEN - 1 && s[i * 3 + 2] != ':')
 +			return 0;
 +	}
 +	for (i = 0; i < ETH_ALEN; i++) {
 +		mac[i] = (hex_to_bin(s[i * 3]) << 4) | hex_to_bin(s[i * 3 + 1]);
 +	}
 +	return 1;
++=======
+ 	w = kmalloc(sizeof(*w), GFP_ATOMIC);
+ 	if (!w)
+ 		return;
+ 
+ 	INIT_WORK(&w->work, __net_random_once_deferred);
+ 	w->key = key;
+ 	schedule_work(&w->work);
+ }
+ 
+ bool __net_get_random_once(void *buf, int nbytes, bool *done,
+ 			   struct static_key *done_key)
+ {
+ 	static DEFINE_SPINLOCK(lock);
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&lock, flags);
+ 	if (*done) {
+ 		spin_unlock_irqrestore(&lock, flags);
+ 		return false;
+ 	}
+ 
+ 	get_random_bytes(buf, nbytes);
+ 	*done = true;
+ 	spin_unlock_irqrestore(&lock, flags);
+ 
+ 	__net_random_once_disable_jump(done_key);
+ 
+ 	return true;
++>>>>>>> f84be2bd96a1 (net: make net_get_random_once irq safe)
  }
 -EXPORT_SYMBOL(__net_get_random_once);
 +EXPORT_SYMBOL(mac_pton);
* Unmerged path include/linux/net.h
* Unmerged path net/core/utils.c
