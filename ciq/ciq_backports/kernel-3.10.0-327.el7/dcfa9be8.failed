ACPI / PCI: Fix sysfs acpi_index and label errors

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [pci] pci: Fix sysfs acpi_index and label errors (Myron Stowe) [1223472]
Rebuild_FUZZ: 92.31%
commit-author Simone Gotti <simone.gotti@gmail.com>
commit dcfa9be83866e28fcb8b7e22b4eeb4ba63bd3174
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/dcfa9be8.failed

Fix errors in handling "device label" _DSM return values.

If _DSM returns a Unicode string, the ACPI type is ACPI_TYPE_BUFFER, not
ACPI_TYPE_STRING.  Fix dsm_label_utf16s_to_utf8s() to convert UTF-16 from
acpi_object->buffer instead of acpi_object->string.

Prior to v3.14, we accepted Unicode labels (ACPI_TYPE_BUFFER return
values).  But after 1d0fcef73283, we accepted only ASCII (ACPI_TYPE_STRING)
(and we incorrectly tried to convert those ASCII labels from UTF-16 to
UTF-8).

Rejecting Unicode labels made us return -EPERM when reading sysfs
"acpi_index" or "label" files, which in turn caused on-board network
interfaces on a Dell PowerEdge E420 to be renamed (by udev net_id internal)
from eno1/eno2 to enp2s0f0/enp2s0f1.

Fix this by accepting either ACPI_TYPE_STRING (and treating it as ASCII) or
ACPI_TYPE_BUFFER (and converting from UTF-16 to UTF-8).

[bhelgaas: changelog]
Fixes: 1d0fcef73283 ("ACPI / PCI: replace open-coded _DSM code with helper functions")
	Signed-off-by: Simone Gotti <simone.gotti@gmail.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Reviewed-by: Jiang Liu <jiang.liu@linux.intel.com>
CC: stable@vger.kernel.org	# v3.14+
(cherry picked from commit dcfa9be83866e28fcb8b7e22b4eeb4ba63bd3174)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/pci-label.c
diff --cc drivers/pci/pci-label.c
index b62523cdf57a,2ab1b47c7651..000000000000
--- a/drivers/pci/pci-label.c
+++ b/drivers/pci/pci-label.c
@@@ -170,84 -161,70 +170,117 @@@ enum acpi_attr_enum 
  static void dsm_label_utf16s_to_utf8s(union acpi_object *obj, char *buf)
  {
  	int len;
++<<<<<<< HEAD
 +	len = utf16s_to_utf8s((const wchar_t *)obj->
 +			      package.elements[1].string.pointer,
 +			      obj->package.elements[1].string.length,
++=======
+ 	len = utf16s_to_utf8s((const wchar_t *)obj->buffer.pointer,
+ 			      obj->buffer.length,
++>>>>>>> dcfa9be83866 (ACPI / PCI: Fix sysfs acpi_index and label errors)
  			      UTF16_LITTLE_ENDIAN,
  			      buf, PAGE_SIZE);
  	buf[len] = '\n';
  }
  
 -static int dsm_get_label(struct device *dev, char *buf,
 -			 enum acpi_attr_enum attr)
 +static int
 +dsm_get_label(acpi_handle handle, int func,
 +	      struct acpi_buffer *output,
 +	      char *buf, enum acpi_attr_enum attribute)
  {
 -	acpi_handle handle;
 -	union acpi_object *obj, *tmp;
 -	int len = -1;
 -
 -	handle = ACPI_HANDLE(dev);
 -	if (!handle)
 +	struct acpi_object_list input;
 +	union acpi_object params[4];
 +	union acpi_object *obj;
 +	int len = 0;
 +
 +	int err;
 +
 +	input.count = 4;
 +	input.pointer = params;
 +	params[0].type = ACPI_TYPE_BUFFER;
 +	params[0].buffer.length = sizeof(device_label_dsm_uuid);
 +	params[0].buffer.pointer = (char *)device_label_dsm_uuid;
 +	params[1].type = ACPI_TYPE_INTEGER;
 +	params[1].integer.value = 0x02;
 +	params[2].type = ACPI_TYPE_INTEGER;
 +	params[2].integer.value = func;
 +	params[3].type = ACPI_TYPE_PACKAGE;
 +	params[3].package.count = 0;
 +	params[3].package.elements = NULL;
 +
 +	err = acpi_evaluate_object(handle, "_DSM", &input, output);
 +	if (err)
  		return -1;
  
++<<<<<<< HEAD
 +	obj = (union acpi_object *)output->pointer;
 +	if (obj->type == ACPI_TYPE_PACKAGE && obj->package.count == 2) {
 +		len = obj->package.elements[0].integer.value;
 +		if (buf) {
 +			if (attribute == ACPI_ATTR_INDEX_SHOW)
 +				scnprintf(buf, PAGE_SIZE, "%llu\n",
 +				obj->package.elements[0].integer.value);
 +			else if (attribute == ACPI_ATTR_LABEL_SHOW)
 +				dsm_label_utf16s_to_utf8s(obj, buf);
 +			kfree(output->pointer);
 +			return strlen(buf);
 +		}
 +		kfree(output->pointer);
 +		return len;
++=======
+ 	obj = acpi_evaluate_dsm(handle, device_label_dsm_uuid, 0x2,
+ 				DEVICE_LABEL_DSM, NULL);
+ 	if (!obj)
+ 		return -1;
+ 
+ 	tmp = obj->package.elements;
+ 	if (obj->type == ACPI_TYPE_PACKAGE && obj->package.count == 2 &&
+ 	    tmp[0].type == ACPI_TYPE_INTEGER &&
+ 	    (tmp[1].type == ACPI_TYPE_STRING ||
+ 	     tmp[1].type == ACPI_TYPE_BUFFER)) {
+ 		/*
+ 		 * The second string element is optional even when
+ 		 * this _DSM is implemented; when not implemented,
+ 		 * this entry must return a null string.
+ 		 */
+ 		if (attr == ACPI_ATTR_INDEX_SHOW) {
+ 			scnprintf(buf, PAGE_SIZE, "%llu\n", tmp->integer.value);
+ 		} else if (attr == ACPI_ATTR_LABEL_SHOW) {
+ 			if (tmp[1].type == ACPI_TYPE_STRING)
+ 				scnprintf(buf, PAGE_SIZE, "%s\n",
+ 					  tmp[1].string.pointer);
+ 			else if (tmp[1].type == ACPI_TYPE_BUFFER)
+ 				dsm_label_utf16s_to_utf8s(tmp + 1, buf);
+ 		}
+ 		len = strlen(buf) > 0 ? strlen(buf) : -1;
++>>>>>>> dcfa9be83866 (ACPI / PCI: Fix sysfs acpi_index and label errors)
  	}
  
 -	ACPI_FREE(obj);
 +	kfree(output->pointer);
  
 -	return len;
 +	return -1;
  }
  
 -static bool device_has_dsm(struct device *dev)
 +static bool
 +device_has_dsm(struct device *dev)
  {
  	acpi_handle handle;
 +	struct acpi_buffer output = {ACPI_ALLOCATE_BUFFER, NULL};
 +
 +	handle = DEVICE_ACPI_HANDLE(dev);
  
 -	handle = ACPI_HANDLE(dev);
  	if (!handle)
 -		return false;
 +		return FALSE;
 +
 +	if (dsm_get_label(handle, DEVICE_LABEL_DSM, &output, NULL,
 +			  ACPI_ATTR_NONE) > 0)
 +		return TRUE;
  
 -	return !!acpi_check_dsm(handle, device_label_dsm_uuid, 0x2,
 -				1 << DEVICE_LABEL_DSM);
 +	return FALSE;
  }
  
 -static umode_t acpi_index_string_exist(struct kobject *kobj,
 -				       struct attribute *attr, int n)
 +static umode_t
 +acpi_index_string_exist(struct kobject *kobj, struct attribute *attr, int n)
  {
  	struct device *dev;
  
* Unmerged path drivers/pci/pci-label.c
