netfilter: Add socket pointer to nf_hook_state.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] netfilter: Add socket pointer to nf_hook_state (Jiri Benc) [1230935]
Rebuild_FUZZ: 98.92%
commit-author David Miller <davem@davemloft.net>
commit 1c984f8a5df085bcf35364a8a870bd4db4da4ed3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/1c984f8a.failed

It is currently always set to NULL, but nf_queue is adjusted to be
prepared for it being set to a real socket by taking and releasing a
reference to that socket when necessary.

	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1c984f8a5df085bcf35364a8a870bd4db4da4ed3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netfilter.h
#	net/netfilter/nf_queue.c
diff --cc include/linux/netfilter.h
index 3c0221f8945f,f8f58fab2402..000000000000
--- a/include/linux/netfilter.h
+++ b/include/linux/netfilter.h
@@@ -43,11 -44,39 +43,44 @@@ int netfilter_init(void)
  struct sk_buff;
  
  struct nf_hook_ops;
++<<<<<<< HEAD
++=======
+ 
+ struct sock;
+ 
+ struct nf_hook_state {
+ 	unsigned int hook;
+ 	int thresh;
+ 	u_int8_t pf;
+ 	struct net_device *in;
+ 	struct net_device *out;
+ 	struct sock *sk;
+ 	int (*okfn)(struct sk_buff *);
+ };
+ 
+ static inline void nf_hook_state_init(struct nf_hook_state *p,
+ 				      unsigned int hook,
+ 				      int thresh, u_int8_t pf,
+ 				      struct net_device *indev,
+ 				      struct net_device *outdev,
+ 				      struct sock *sk,
+ 				      int (*okfn)(struct sk_buff *))
+ {
+ 	p->hook = hook;
+ 	p->thresh = thresh;
+ 	p->pf = pf;
+ 	p->in = indev;
+ 	p->out = outdev;
+ 	p->sk = sk;
+ 	p->okfn = okfn;
+ }
+ 
++>>>>>>> 1c984f8a5df0 (netfilter: Add socket pointer to nf_hook_state.)
  typedef unsigned int nf_hookfn(const struct nf_hook_ops *ops,
  			       struct sk_buff *skb,
 -			       const struct nf_hook_state *state);
 +			       const struct net_device *in,
 +			       const struct net_device *out,
 +			       int (*okfn)(struct sk_buff *));
  
  struct nf_hook_ops {
  	struct list_head list;
@@@ -141,8 -161,13 +174,18 @@@ static inline int nf_hook_thresh(u_int8
  				 struct net_device *outdev,
  				 int (*okfn)(struct sk_buff *), int thresh)
  {
++<<<<<<< HEAD
 +	if (nf_hooks_active(pf, hook))
 +		return nf_hook_slow(pf, hook, skb, indev, outdev, okfn, thresh);
++=======
+ 	if (nf_hooks_active(pf, hook)) {
+ 		struct nf_hook_state state;
+ 
+ 		nf_hook_state_init(&state, hook, thresh, pf,
+ 				   indev, outdev, NULL, okfn);
+ 		return nf_hook_slow(skb, &state);
+ 	}
++>>>>>>> 1c984f8a5df0 (netfilter: Add socket pointer to nf_hook_state.)
  	return 1;
  }
  
diff --cc net/netfilter/nf_queue.c
index 5d24b1fdb593,c4a706678f88..000000000000
--- a/net/netfilter/nf_queue.c
+++ b/net/netfilter/nf_queue.c
@@@ -47,12 -47,16 +47,22 @@@ EXPORT_SYMBOL(nf_unregister_queue_handl
  
  void nf_queue_entry_release_refs(struct nf_queue_entry *entry)
  {
 -	struct nf_hook_state *state = &entry->state;
 -
  	/* Release those devices we held, or Alexey will kill me. */
++<<<<<<< HEAD
 +	if (entry->indev)
 +		dev_put(entry->indev);
 +	if (entry->outdev)
 +		dev_put(entry->outdev);
 +#ifdef CONFIG_BRIDGE_NETFILTER
++=======
+ 	if (state->in)
+ 		dev_put(state->in);
+ 	if (state->out)
+ 		dev_put(state->out);
+ 	if (state->sk)
+ 		sock_put(state->sk);
+ #if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
++>>>>>>> 1c984f8a5df0 (netfilter: Add socket pointer to nf_hook_state.)
  	if (entry->skb->nf_bridge) {
  		struct nf_bridge_info *nf_bridge = entry->skb->nf_bridge;
  
@@@ -73,11 -77,15 +83,21 @@@ bool nf_queue_entry_get_refs(struct nf_
  	if (!try_module_get(entry->elem->owner))
  		return false;
  
++<<<<<<< HEAD
 +	if (entry->indev)
 +		dev_hold(entry->indev);
 +	if (entry->outdev)
 +		dev_hold(entry->outdev);
 +#ifdef CONFIG_BRIDGE_NETFILTER
++=======
+ 	if (state->in)
+ 		dev_hold(state->in);
+ 	if (state->out)
+ 		dev_hold(state->out);
+ 	if (state->sk)
+ 		sock_hold(state->sk);
+ #if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
++>>>>>>> 1c984f8a5df0 (netfilter: Add socket pointer to nf_hook_state.)
  	if (entry->skb->nf_bridge) {
  		struct nf_bridge_info *nf_bridge = entry->skb->nf_bridge;
  		struct net_device *physdev;
* Unmerged path include/linux/netfilter.h
* Unmerged path net/netfilter/nf_queue.c
