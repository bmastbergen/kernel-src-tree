ovl: check lowerdir amount for non-upper mount

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author hujianyang <hujianyang@huawei.com>
commit 6be4506e34cf6075a1307b646e0a6c46c1c9010d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/6be4506e.failed

Recently multi-lower layer mount support allow upperdir and workdir
to be omitted, then cause overlayfs can be mount with only one
lowerdir directory. This action make no sense and have potential risk.

This patch check the total number of lower directories to prevent
mounting overlayfs with only one directory.

Also, an error message is added to indicate lower directories exceed
OVL_MAX_STACK limit.

	Signed-off-by: hujianyang <hujianyang@huawei.com>
	Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
(cherry picked from commit 6be4506e34cf6075a1307b646e0a6c46c1c9010d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/super.c
diff --cc fs/overlayfs/super.c
index 247af4499a61,edbb3ebcdaad..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -698,104 -836,111 +698,117 @@@ static int ovl_fill_super(struct super_
  		goto out_free_config;
  	}
  
 -	sb->s_stack_depth = 0;
 -	if (ufs->config.upperdir) {
 -		/* FIXME: workdir is not needed for a R/O mount */
 -		if (!ufs->config.workdir) {
 -			pr_err("overlayfs: missing 'workdir'\n");
 -			goto out_free_config;
 -		}
 -
 -		err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
 -		if (err)
 -			goto out_free_config;
 -
 -		err = ovl_mount_dir(ufs->config.workdir, &workpath);
 -		if (err)
 -			goto out_put_upperpath;
 -
 -		err = -EINVAL;
 -		if (upperpath.mnt != workpath.mnt) {
 -			pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
 -			goto out_put_workpath;
 -		}
 -		if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
 -			pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
 -			goto out_put_workpath;
 -		}
 -		sb->s_stack_depth = upperpath.mnt->mnt_sb->s_stack_depth;
 -	}
  	err = -ENOMEM;
 -	lowertmp = kstrdup(ufs->config.lowerdir, GFP_KERNEL);
 -	if (!lowertmp)
 -		goto out_put_workpath;
 +	oe = ovl_alloc_entry();
 +	if (oe == NULL)
 +		goto out_free_config;
  
++<<<<<<< HEAD
 +	err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
 +	if (err)
 +		goto out_free_oe;
++=======
+ 	err = -EINVAL;
+ 	stacklen = ovl_split_lowerdirs(lowertmp);
+ 	if (stacklen > OVL_MAX_STACK) {
+ 		pr_err("overlayfs: too many lower directries, limit is %d\n",
+ 		       OVL_MAX_STACK);
+ 		goto out_free_lowertmp;
+ 	} else if (!ufs->config.upperdir && stacklen == 1) {
+ 		pr_err("overlayfs: at least 2 lowerdir are needed while upperdir nonexistent\n");
+ 		goto out_free_lowertmp;
+ 	}
++>>>>>>> 6be4506e34cf (ovl: check lowerdir amount for non-upper mount)
  
 -	stack = kcalloc(stacklen, sizeof(struct path), GFP_KERNEL);
 -	if (!stack)
 -		goto out_free_lowertmp;
 +	err = ovl_mount_dir(ufs->config.lowerdir, &lowerpath);
 +	if (err)
 +		goto out_put_upperpath;
  
 -	lower = lowertmp;
 -	for (numlower = 0; numlower < stacklen; numlower++) {
 -		err = ovl_lower_dir(lower, &stack[numlower],
 -				    &ufs->lower_namelen, &sb->s_stack_depth);
 -		if (err)
 -			goto out_put_lowerpath;
 +	err = ovl_mount_dir(ufs->config.workdir, &workpath);
 +	if (err)
 +		goto out_put_lowerpath;
  
 -		lower = strchr(lower, '\0') + 1;
 +	err = -EINVAL;
 +	if (!S_ISDIR(upperpath.dentry->d_inode->i_mode) ||
 +	    !S_ISDIR(lowerpath.dentry->d_inode->i_mode) ||
 +	    !S_ISDIR(workpath.dentry->d_inode->i_mode)) {
 +		pr_err("overlayfs: upperdir or lowerdir or workdir not a directory\n");
 +		goto out_put_workpath;
 +	}
 +
 +	if (upperpath.mnt != workpath.mnt) {
 +		pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
 +		goto out_put_workpath;
 +	}
 +	if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
 +		pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
 +		goto out_put_workpath;
  	}
  
 +	if (!ovl_is_allowed_fs_type(upperpath.dentry)) {
 +		pr_err("overlayfs: filesystem of upperdir is not supported\n");
 +		goto out_put_workpath;
 +	}
 +
 +	if (!ovl_is_allowed_fs_type(lowerpath.dentry)) {
 +		pr_err("overlayfs: filesystem of lowerdir is not supported\n");
 +		goto out_put_workpath;
 +	}
 +
 +	err = vfs_statfs(&lowerpath, &statfs);
 +	if (err) {
 +		pr_err("overlayfs: statfs failed on lowerpath\n");
 +		goto out_put_workpath;
 +	}
 +	ufs->lower_namelen = statfs.f_namelen;
 +
 +	upper_stack_depth = get_s_stack_depth(upperpath.mnt->mnt_sb);
 +	lower_stack_depth = get_s_stack_depth(lowerpath.mnt->mnt_sb);
 +	overlay_stack_depth = get_s_stack_depth(sb);
 +	err = -EOPNOTSUPP;
 +	if (!upper_stack_depth || !lower_stack_depth || !overlay_stack_depth) {
 +		pr_err("overlayfs: superblock missing extension wrapper (old kernel?)\n");
 +		goto out_put_workpath;
 +	}
 +
 +	*overlay_stack_depth = max(*upper_stack_depth, *lower_stack_depth) + 1;
 +
  	err = -EINVAL;
 -	sb->s_stack_depth++;
 -	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
 +	if (*overlay_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
  		pr_err("overlayfs: maximum fs stacking depth exceeded\n");
 -		goto out_put_lowerpath;
 +		goto out_put_workpath;
  	}
  
 -	if (ufs->config.upperdir) {
 -		ufs->upper_mnt = clone_private_mount(&upperpath);
 -		err = PTR_ERR(ufs->upper_mnt);
 -		if (IS_ERR(ufs->upper_mnt)) {
 -			pr_err("overlayfs: failed to clone upperpath\n");
 -			goto out_put_lowerpath;
 -		}
 -
 -		ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
 -		err = PTR_ERR(ufs->workdir);
 -		if (IS_ERR(ufs->workdir)) {
 -			pr_err("overlayfs: failed to create directory %s/%s\n",
 -			       ufs->config.workdir, OVL_WORKDIR_NAME);
 -			goto out_put_upper_mnt;
 -		}
 +	ufs->upper_mnt = clone_private_mount(&upperpath);
 +	err = PTR_ERR(ufs->upper_mnt);
 +	if (IS_ERR(ufs->upper_mnt)) {
 +		pr_err("overlayfs: failed to clone upperpath\n");
 +		goto out_put_workpath;
  	}
  
 -	err = -ENOMEM;
 -	ufs->lower_mnt = kcalloc(numlower, sizeof(struct vfsmount *), GFP_KERNEL);
 -	if (ufs->lower_mnt == NULL)
 -		goto out_put_workdir;
 -	for (i = 0; i < numlower; i++) {
 -		struct vfsmount *mnt = clone_private_mount(&stack[i]);
 +	ufs->lower_mnt = clone_private_mount(&lowerpath);
 +	err = PTR_ERR(ufs->lower_mnt);
 +	if (IS_ERR(ufs->lower_mnt)) {
 +		pr_err("overlayfs: failed to clone lowerpath\n");
 +		goto out_put_upper_mnt;
 +	}
  
 -		err = PTR_ERR(mnt);
 -		if (IS_ERR(mnt)) {
 -			pr_err("overlayfs: failed to clone lowerpath\n");
 -			goto out_put_lower_mnt;
 -		}
 -		/*
 -		 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
 -		 * will fail instead of modifying lower fs.
 -		 */
 -		mnt->mnt_flags |= MNT_READONLY;
 -
 -		ufs->lower_mnt[ufs->numlower] = mnt;
 -		ufs->numlower++;
 +	ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
 +	err = PTR_ERR(ufs->workdir);
 +	if (IS_ERR(ufs->workdir)) {
 +		pr_err("overlayfs: failed to create directory %s/%s\n",
 +		       ufs->config.workdir, OVL_WORKDIR_NAME);
 +		goto out_put_lower_mnt;
  	}
  
 -	/* If the upper fs is r/o or nonexistent, we mark overlayfs r/o too */
 -	if (!ufs->upper_mnt || (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY))
 +	/*
 +	 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
 +	 * will fail instead of modifying lower fs.
 +	 */
 +	ufs->lower_mnt->mnt_flags |= MNT_READONLY;
 +
 +	/* If the upper fs is r/o, we mark overlayfs r/o too */
 +	if (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)
  		sb->s_flags |= MS_RDONLY;
  
  	sb->s_d_op = &ovl_dentry_operations;
* Unmerged path fs/overlayfs/super.c
