xfs: check xfs_buf_read_uncached returns correctly

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit ba3726742c1712c43c5a18245476f3fe9fe74773
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/ba372674.failed

xfs_buf_read_uncached() has two failure modes. If can either return
NULL or bp->b_error != 0 depending on the type of failure, and not
all callers check for both. Fix it so that xfs_buf_read_uncached()
always returns the error status, and the buffer is returned as a
function parameter. The buffer will only be returned on success.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit ba3726742c1712c43c5a18245476f3fe9fe74773)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_buf.c
#	fs/xfs/xfs_fsops.c
#	fs/xfs/xfs_mount.c
#	fs/xfs/xfs_rtalloc.c
diff --cc fs/xfs/xfs_buf.c
index 84e0417dc6f7,6fbcbbfb4d1a..000000000000
--- a/fs/xfs/xfs_buf.c
+++ b/fs/xfs/xfs_buf.c
@@@ -759,13 -712,15 +762,25 @@@ xfs_buf_read_uncached
  	bp->b_flags |= XBF_READ;
  	bp->b_ops = ops;
  
++<<<<<<< HEAD
 +	if (XFS_FORCED_SHUTDOWN(target->bt_mount)) {
 +		xfs_buf_relse(bp);
 +		return NULL;
 +	}
 +	xfs_buf_iorequest(bp);
 +	xfs_buf_iowait(bp);
 +	return bp;
++=======
+ 	xfs_buf_submit_wait(bp);
+ 	if (bp->b_error) {
+ 		int	error = bp->b_error;
+ 		xfs_buf_relse(bp);
+ 		return error;
+ 	}
+ 
+ 	*bpp = bp;
+ 	return 0;
++>>>>>>> ba3726742c17 (xfs: check xfs_buf_read_uncached returns correctly)
  }
  
  /*
diff --cc fs/xfs/xfs_fsops.c
index 3445ead7c1fc,c05ac8b70fa9..000000000000
--- a/fs/xfs/xfs_fsops.c
+++ b/fs/xfs/xfs_fsops.c
@@@ -175,16 -172,11 +175,20 @@@ xfs_growfs_data_private
  	if ((error = xfs_sb_validate_fsb_count(&mp->m_sb, nb)))
  		return error;
  	dpct = pct - mp->m_sb.sb_imax_pct;
- 	bp = xfs_buf_read_uncached(mp->m_ddev_targp,
+ 	error = xfs_buf_read_uncached(mp->m_ddev_targp,
  				XFS_FSB_TO_BB(mp, nb) - XFS_FSS_TO_BB(mp, 1),
++<<<<<<< HEAD
 +				XFS_FSS_TO_BB(mp, 1), 0, NULL);
 +	if (!bp)
 +		return EIO;
 +	if (bp->b_error) {
 +		error = bp->b_error;
 +		xfs_buf_relse(bp);
++=======
+ 				XFS_FSS_TO_BB(mp, 1), 0, &bp, NULL);
+ 	if (error)
++>>>>>>> ba3726742c17 (xfs: check xfs_buf_read_uncached returns correctly)
  		return error;
- 	}
  	xfs_buf_relse(bp);
  
  	new = nb;	/* use new as a temporary here */
diff --cc fs/xfs/xfs_mount.c
index 1f0460bd27b8,142c460fc64e..000000000000
--- a/fs/xfs/xfs_mount.c
+++ b/fs/xfs/xfs_mount.c
@@@ -305,21 -302,15 +305,33 @@@ xfs_readsb
  	 * access to the superblock.
  	 */
  reread:
++<<<<<<< HEAD
 +	bp = xfs_buf_read_uncached(mp->m_ddev_targp, XFS_SB_DADDR,
 +				   BTOBB(sector_size), 0, buf_ops);
 +	if (!bp) {
 +		if (loud)
 +			xfs_warn(mp, "SB buffer read failed");
 +		return EIO;
 +	}
 +	if (bp->b_error) {
 +		error = bp->b_error;
 +		if (loud)
 +			xfs_warn(mp, "SB validate failed with error %d.", error);
 +		/* bad CRC means corrupted metadata */
 +		if (error == EFSBADCRC)
 +			error = EFSCORRUPTED;
 +		goto release_buf;
++=======
+ 	error = xfs_buf_read_uncached(mp->m_ddev_targp, XFS_SB_DADDR,
+ 				   BTOBB(sector_size), 0, &bp, buf_ops);
+ 	if (error) {
+ 		if (loud)
+ 			xfs_warn(mp, "SB validate failed with error %d.", error);
+ 		/* bad CRC means corrupted metadata */
+ 		if (error == -EFSBADCRC)
+ 			error = -EFSCORRUPTED;
+ 		return error;
++>>>>>>> ba3726742c17 (xfs: check xfs_buf_read_uncached returns correctly)
  	}
  
  	/*
@@@ -557,32 -550,33 +571,54 @@@ xfs_check_sizes
  	d = (xfs_daddr_t)XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks);
  	if (XFS_BB_TO_FSB(mp, d) != mp->m_sb.sb_dblocks) {
  		xfs_warn(mp, "filesystem size mismatch detected");
 -		return -EFBIG;
 +		return XFS_ERROR(EFBIG);
  	}
- 	bp = xfs_buf_read_uncached(mp->m_ddev_targp,
+ 	error = xfs_buf_read_uncached(mp->m_ddev_targp,
  					d - XFS_FSS_TO_BB(mp, 1),
- 					XFS_FSS_TO_BB(mp, 1), 0, NULL);
- 	if (!bp) {
+ 					XFS_FSS_TO_BB(mp, 1), 0, &bp, NULL);
+ 	if (error) {
  		xfs_warn(mp, "last sector read failed");
++<<<<<<< HEAD
 +		return EIO;
 +	}
 +	xfs_buf_relse(bp);
 +
 +	if (mp->m_logdev_targp != mp->m_ddev_targp) {
 +		d = (xfs_daddr_t)XFS_FSB_TO_BB(mp, mp->m_sb.sb_logblocks);
 +		if (XFS_BB_TO_FSB(mp, d) != mp->m_sb.sb_logblocks) {
 +			xfs_warn(mp, "log size mismatch detected");
 +			return XFS_ERROR(EFBIG);
 +		}
 +		bp = xfs_buf_read_uncached(mp->m_logdev_targp,
 +					d - XFS_FSB_TO_BB(mp, 1),
 +					XFS_FSB_TO_BB(mp, 1), 0, NULL);
 +		if (!bp) {
 +			xfs_warn(mp, "log device read failed");
 +			return EIO;
 +		}
 +		xfs_buf_relse(bp);
++=======
+ 		return error;
+ 	}
+ 	xfs_buf_relse(bp);
+ 
+ 	if (mp->m_logdev_targp == mp->m_ddev_targp)
+ 		return 0;
+ 
+ 	d = (xfs_daddr_t)XFS_FSB_TO_BB(mp, mp->m_sb.sb_logblocks);
+ 	if (XFS_BB_TO_FSB(mp, d) != mp->m_sb.sb_logblocks) {
+ 		xfs_warn(mp, "log size mismatch detected");
+ 		return -EFBIG;
++>>>>>>> ba3726742c17 (xfs: check xfs_buf_read_uncached returns correctly)
  	}
+ 	error = xfs_buf_read_uncached(mp->m_logdev_targp,
+ 					d - XFS_FSB_TO_BB(mp, 1),
+ 					XFS_FSB_TO_BB(mp, 1), 0, &bp, NULL);
+ 	if (error) {
+ 		xfs_warn(mp, "log device read failed");
+ 		return error;
+ 	}
+ 	xfs_buf_relse(bp);
  	return 0;
  }
  
diff --cc fs/xfs/xfs_rtalloc.c
index ca93d78b75bf,1ad00937b485..000000000000
--- a/fs/xfs/xfs_rtalloc.c
+++ b/fs/xfs/xfs_rtalloc.c
@@@ -921,16 -972,11 +921,20 @@@ xfs_growfs_rt
  	/*
  	 * Read in the last block of the device, make sure it exists.
  	 */
- 	bp = xfs_buf_read_uncached(mp->m_rtdev_targp,
+ 	error = xfs_buf_read_uncached(mp->m_rtdev_targp,
  				XFS_FSB_TO_BB(mp, nrblocks - 1),
++<<<<<<< HEAD
 +				XFS_FSB_TO_BB(mp, 1), 0, NULL);
 +	if (!bp)
 +		return EIO;
 +	if (bp->b_error) {
 +		error = bp->b_error;
 +		xfs_buf_relse(bp);
++=======
+ 				XFS_FSB_TO_BB(mp, 1), 0, &bp, NULL);
+ 	if (error)
++>>>>>>> ba3726742c17 (xfs: check xfs_buf_read_uncached returns correctly)
  		return error;
- 	}
  	xfs_buf_relse(bp);
  
  	/*
@@@ -1212,16 -1259,14 +1217,20 @@@ xfs_rtmount_init
  		xfs_warn(mp, "realtime mount -- %llu != %llu",
  			(unsigned long long) XFS_BB_TO_FSB(mp, d),
  			(unsigned long long) mp->m_sb.sb_rblocks);
 -		return -EFBIG;
 +		return XFS_ERROR(EFBIG);
  	}
- 	bp = xfs_buf_read_uncached(mp->m_rtdev_targp,
+ 	error = xfs_buf_read_uncached(mp->m_rtdev_targp,
  					d - XFS_FSB_TO_BB(mp, 1),
- 					XFS_FSB_TO_BB(mp, 1), 0, NULL);
- 	if (!bp || bp->b_error) {
+ 					XFS_FSB_TO_BB(mp, 1), 0, &bp, NULL);
+ 	if (error) {
  		xfs_warn(mp, "realtime device size check failed");
++<<<<<<< HEAD
 +		if (bp)
 +			xfs_buf_relse(bp);
 +		return EIO;
++=======
+ 		return error;
++>>>>>>> ba3726742c17 (xfs: check xfs_buf_read_uncached returns correctly)
  	}
  	xfs_buf_relse(bp);
  	return 0;
* Unmerged path fs/xfs/xfs_buf.c
diff --git a/fs/xfs/xfs_buf.h b/fs/xfs/xfs_buf.h
index 75e98ced9b68..b49c716887cd 100644
--- a/fs/xfs/xfs_buf.h
+++ b/fs/xfs/xfs_buf.h
@@ -265,9 +265,9 @@ int xfs_buf_associate_memory(struct xfs_buf *bp, void *mem, size_t length);
 
 struct xfs_buf *xfs_buf_get_uncached(struct xfs_buftarg *target, size_t numblks,
 				int flags);
-struct xfs_buf *xfs_buf_read_uncached(struct xfs_buftarg *target,
-				xfs_daddr_t daddr, size_t numblks, int flags,
-				const struct xfs_buf_ops *ops);
+int xfs_buf_read_uncached(struct xfs_buftarg *target, xfs_daddr_t daddr,
+			  size_t numblks, int flags, struct xfs_buf **bpp,
+			  const struct xfs_buf_ops *ops);
 void xfs_buf_hold(struct xfs_buf *bp);
 
 /* Releasing Buffers */
* Unmerged path fs/xfs/xfs_fsops.c
* Unmerged path fs/xfs/xfs_mount.c
* Unmerged path fs/xfs/xfs_rtalloc.c
