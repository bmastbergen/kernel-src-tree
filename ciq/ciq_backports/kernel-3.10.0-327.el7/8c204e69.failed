IB/iser: Signal iSCSI layer that transport is broken in error completions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [infiniband] iser: Signal iSCSI layer that transport is broken in error completions (Amir Vadai) [1164539]
Rebuild_FUZZ: 97.90%
commit-author Sagi Grimberg <sagig@mellanox.com>
commit 8c204e69ced1a8c0d74f8b6d7a1393d055c5c4fa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/8c204e69.failed

Previously we notified iscsi layer about the connection layer when
we consumed all of our flush errors. This was racy as there
was no guarentee that iscsi_conn wasn't terminated by then (which ends
up in an invalid memory access). In case we got a non FLUSH error
completion, we are guarenteed that iscsi_conn is still alive. We should
notify iSCSI layer with iscsi_conn_failure to initiate error handling.

While we are at it, add a nice kernel-doc style documentation.

	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Ariel Nahum <arieln@mellanox.com>
	Signed-off-by: Roi Dayan <roid@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Roland Dreier <roland@purestorage.com>
(cherry picked from commit 8c204e69ced1a8c0d74f8b6d7a1393d055c5c4fa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/iser/iser_verbs.c
diff --cc drivers/infiniband/ulp/iser/iser_verbs.c
index fbf2a1e0f2e2,35f53a3fdf21..000000000000
--- a/drivers/infiniband/ulp/iser/iser_verbs.c
+++ b/drivers/infiniband/ulp/iser/iser_verbs.c
@@@ -1090,28 -1159,32 +1090,54 @@@ int iser_post_send(struct iser_conn *ib
  	return ib_ret;
  }
  
++<<<<<<< HEAD
 +static void iser_handle_comp_error(struct iser_tx_desc *desc,
 +				struct iser_conn *ib_conn)
++=======
+ /**
+  * iser_handle_comp_error() - Handle error completion
+  * @desc:      iser TX descriptor
+  * @ib_conn:   connection RDMA resources
+  * @wc:        work completion
+  *
+  * Notes: We may handle a FLUSH error completion and in this case
+  *        we only cleanup in case TX type was DATAOUT. For non-FLUSH
+  *        error completion we should also notify iscsi layer that
+  *        connection is failed (in case we passed bind stage).
+  */
+ static void
+ iser_handle_comp_error(struct iser_tx_desc *desc,
+ 		       struct ib_conn *ib_conn,
+ 		       struct ib_wc *wc)
++>>>>>>> 8c204e69ced1 (IB/iser: Signal iSCSI layer that transport is broken in error completions)
  {
+ 	struct iser_conn *iser_conn = container_of(ib_conn, struct iser_conn,
+ 						   ib_conn);
+ 
+ 	if (wc->status != IB_WC_WR_FLUSH_ERR)
+ 		if (iser_conn->iscsi_conn)
+ 			iscsi_conn_failure(iser_conn->iscsi_conn,
+ 					   ISCSI_ERR_CONN_FAILED);
+ 
  	if (desc && desc->type == ISCSI_TX_DATAOUT)
  		kmem_cache_free(ig.desc_cache, desc);
 +
 +	if (ib_conn->post_recv_buf_count == 0 &&
 +	    atomic_read(&ib_conn->post_send_buf_count) == 0) {
 +		/**
 +		 * getting here when the state is UP means that the conn is
 +		 * being terminated asynchronously from the iSCSI layer's
 +		 * perspective. It is safe to peek at the connection state
 +		 * since iscsi_conn_failure is allowed to be called twice.
 +		 **/
 +		if (ib_conn->state == ISER_CONN_UP)
 +			iscsi_conn_failure(ib_conn->iscsi_conn,
 +					   ISCSI_ERR_CONN_FAILED);
 +
 +		/* no more non completed posts to the QP, complete the
 +		 * termination process w.o worrying on disconnect event */
 +		complete(&ib_conn->flush_completion);
 +	}
  }
  
  static int iser_drain_tx_cq(struct iser_device  *device, int cq_index)
* Unmerged path drivers/infiniband/ulp/iser/iser_verbs.c
