PCI: Mark Atheros AR93xx to avoid bus reset

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [pci] Mark Atheros AR93xx to avoid bus reset (Myron Stowe) [1171802]
Rebuild_FUZZ: 93.83%
commit-author Alex Williamson <alex.williamson@redhat.com>
commit c3e59ee4e76686b0c84ca8faa1011d10cd4ca1b8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/c3e59ee4.failed

Reports against the TL-WDN4800 card indicate that PCI bus reset of this
Atheros device cause system lock-ups and resets.  I've also been able to
confirm this behavior on multiple systems.  The device never returns from
reset and attempts to access config space of the device after reset result
in hangs.  Blacklist bus reset for the device to avoid this issue.

[bhelgaas: This regression appeared in v3.14.  Andreas bisected it to
425c1b223dac ("PCI: Add Virtual Channel to save/restore support"), but we
don't understand the mechanism by which that commit affects the reset
path.]

[bhelgaas: changelog, references]
Link: http://lkml.kernel.org/r/20140923210318.498dacbd@dualc.maya.org
	Reported-by: Andreas Hartmann <andihartmann@freenet.de>
	Tested-by: Andreas Hartmann <andihartmann@freenet.de>
	Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
CC: stable@vger.kernel.org	# v3.14+
(cherry picked from commit c3e59ee4e76686b0c84ca8faa1011d10cd4ca1b8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/quirks.c
diff --cc drivers/pci/quirks.c
index 198ddcbe8322,e52356aa09b8..000000000000
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@@ -3027,6 -3028,117 +3027,120 @@@ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_
  DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MELLANOX, PCI_ANY_ID,
  			 quirk_broken_intx_masking);
  
++<<<<<<< HEAD
++=======
+ static void quirk_no_bus_reset(struct pci_dev *dev)
+ {
+ 	dev->dev_flags |= PCI_DEV_FLAGS_NO_BUS_RESET;
+ }
+ 
+ /*
+  * Atheros AR93xx chips do not behave after a bus reset.  The device will
+  * throw a Link Down error on AER-capable systems and regardless of AER,
+  * config space of the device is never accessible again and typically
+  * causes the system to hang or reset when access is attempted.
+  * http://www.spinics.net/lists/linux-pci/msg34797.html
+  */
+ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x0030, quirk_no_bus_reset);
+ 
+ #ifdef CONFIG_ACPI
+ /*
+  * Apple: Shutdown Cactus Ridge Thunderbolt controller.
+  *
+  * On Apple hardware the Cactus Ridge Thunderbolt controller needs to be
+  * shutdown before suspend. Otherwise the native host interface (NHI) will not
+  * be present after resume if a device was plugged in before suspend.
+  *
+  * The thunderbolt controller consists of a pcie switch with downstream
+  * bridges leading to the NHI and to the tunnel pci bridges.
+  *
+  * This quirk cuts power to the whole chip. Therefore we have to apply it
+  * during suspend_noirq of the upstream bridge.
+  *
+  * Power is automagically restored before resume. No action is needed.
+  */
+ static void quirk_apple_poweroff_thunderbolt(struct pci_dev *dev)
+ {
+ 	acpi_handle bridge, SXIO, SXFP, SXLV;
+ 
+ 	if (!dmi_match(DMI_BOARD_VENDOR, "Apple Inc."))
+ 		return;
+ 	if (pci_pcie_type(dev) != PCI_EXP_TYPE_UPSTREAM)
+ 		return;
+ 	bridge = ACPI_HANDLE(&dev->dev);
+ 	if (!bridge)
+ 		return;
+ 	/*
+ 	 * SXIO and SXLV are present only on machines requiring this quirk.
+ 	 * TB bridges in external devices might have the same device id as those
+ 	 * on the host, but they will not have the associated ACPI methods. This
+ 	 * implicitly checks that we are at the right bridge.
+ 	 */
+ 	if (ACPI_FAILURE(acpi_get_handle(bridge, "DSB0.NHI0.SXIO", &SXIO))
+ 	    || ACPI_FAILURE(acpi_get_handle(bridge, "DSB0.NHI0.SXFP", &SXFP))
+ 	    || ACPI_FAILURE(acpi_get_handle(bridge, "DSB0.NHI0.SXLV", &SXLV)))
+ 		return;
+ 	dev_info(&dev->dev, "quirk: cutting power to thunderbolt controller...\n");
+ 
+ 	/* magic sequence */
+ 	acpi_execute_simple_method(SXIO, NULL, 1);
+ 	acpi_execute_simple_method(SXFP, NULL, 0);
+ 	msleep(300);
+ 	acpi_execute_simple_method(SXLV, NULL, 0);
+ 	acpi_execute_simple_method(SXIO, NULL, 0);
+ 	acpi_execute_simple_method(SXLV, NULL, 0);
+ }
+ DECLARE_PCI_FIXUP_SUSPEND_LATE(PCI_VENDOR_ID_INTEL, 0x1547,
+ 			       quirk_apple_poweroff_thunderbolt);
+ 
+ /*
+  * Apple: Wait for the thunderbolt controller to reestablish pci tunnels.
+  *
+  * During suspend the thunderbolt controller is reset and all pci
+  * tunnels are lost. The NHI driver will try to reestablish all tunnels
+  * during resume. We have to manually wait for the NHI since there is
+  * no parent child relationship between the NHI and the tunneled
+  * bridges.
+  */
+ static void quirk_apple_wait_for_thunderbolt(struct pci_dev *dev)
+ {
+ 	struct pci_dev *sibling = NULL;
+ 	struct pci_dev *nhi = NULL;
+ 
+ 	if (!dmi_match(DMI_BOARD_VENDOR, "Apple Inc."))
+ 		return;
+ 	if (pci_pcie_type(dev) != PCI_EXP_TYPE_DOWNSTREAM)
+ 		return;
+ 	/*
+ 	 * Find the NHI and confirm that we are a bridge on the tb host
+ 	 * controller and not on a tb endpoint.
+ 	 */
+ 	sibling = pci_get_slot(dev->bus, 0x0);
+ 	if (sibling == dev)
+ 		goto out; /* we are the downstream bridge to the NHI */
+ 	if (!sibling || !sibling->subordinate)
+ 		goto out;
+ 	nhi = pci_get_slot(sibling->subordinate, 0x0);
+ 	if (!nhi)
+ 		goto out;
+ 	if (nhi->vendor != PCI_VENDOR_ID_INTEL
+ 			|| (nhi->device != 0x1547 && nhi->device != 0x156c)
+ 			|| nhi->subsystem_vendor != 0x2222
+ 			|| nhi->subsystem_device != 0x1111)
+ 		goto out;
+ 	dev_info(&dev->dev, "quirk: wating for thunderbolt to reestablish pci tunnels...\n");
+ 	device_pm_wait_for_dev(&dev->dev, &nhi->dev);
+ out:
+ 	pci_dev_put(nhi);
+ 	pci_dev_put(sibling);
+ }
+ DECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_INTEL, 0x1547,
+ 			       quirk_apple_wait_for_thunderbolt);
+ DECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_INTEL, 0x156d,
+ 			       quirk_apple_wait_for_thunderbolt);
+ #endif
+ 
++>>>>>>> c3e59ee4e766 (PCI: Mark Atheros AR93xx to avoid bus reset)
  static void pci_do_fixups(struct pci_dev *dev, struct pci_fixup *f,
  			  struct pci_fixup *end)
  {
* Unmerged path drivers/pci/quirks.c
