netfilter: Pass nf_hook_state through nft_set_pktinfo*().

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] netfilter: Pass nf_hook_state through nft_set_pktinfo*() (Jiri Benc) [1230935]
Rebuild_FUZZ: 99.12%
commit-author David S. Miller <davem@davemloft.net>
commit 073bfd56860446a2cb349bcf282fc17a36ca386c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/073bfd56.failed

	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 073bfd56860446a2cb349bcf282fc17a36ca386c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/netfilter/nf_tables_bridge.c
#	net/ipv4/netfilter/nf_tables_arp.c
#	net/ipv4/netfilter/nf_tables_ipv4.c
#	net/ipv4/netfilter/nft_chain_nat_ipv4.c
#	net/ipv4/netfilter/nft_chain_route_ipv4.c
#	net/ipv6/netfilter/nf_tables_ipv6.c
#	net/ipv6/netfilter/nft_chain_nat_ipv6.c
#	net/ipv6/netfilter/nft_chain_route_ipv6.c
diff --cc net/bridge/netfilter/nf_tables_bridge.c
index da17a5eab8b4,a343e62442b1..000000000000
--- a/net/bridge/netfilter/nf_tables_bridge.c
+++ b/net/bridge/netfilter/nf_tables_bridge.c
@@@ -13,6 -13,80 +13,83 @@@
  #include <linux/module.h>
  #include <linux/netfilter_bridge.h>
  #include <net/netfilter/nf_tables.h>
++<<<<<<< HEAD
++=======
+ #include <net/netfilter/nf_tables_bridge.h>
+ #include <linux/ip.h>
+ #include <linux/ipv6.h>
+ #include <net/netfilter/nf_tables_ipv4.h>
+ #include <net/netfilter/nf_tables_ipv6.h>
+ 
+ int nft_bridge_iphdr_validate(struct sk_buff *skb)
+ {
+ 	struct iphdr *iph;
+ 	u32 len;
+ 
+ 	if (!pskb_may_pull(skb, sizeof(struct iphdr)))
+ 		return 0;
+ 
+ 	iph = ip_hdr(skb);
+ 	if (iph->ihl < 5 || iph->version != 4)
+ 		return 0;
+ 
+ 	len = ntohs(iph->tot_len);
+ 	if (skb->len < len)
+ 		return 0;
+ 	else if (len < (iph->ihl*4))
+ 		return 0;
+ 
+ 	if (!pskb_may_pull(skb, iph->ihl*4))
+ 		return 0;
+ 
+ 	return 1;
+ }
+ EXPORT_SYMBOL_GPL(nft_bridge_iphdr_validate);
+ 
+ int nft_bridge_ip6hdr_validate(struct sk_buff *skb)
+ {
+ 	struct ipv6hdr *hdr;
+ 	u32 pkt_len;
+ 
+ 	if (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))
+ 		return 0;
+ 
+ 	hdr = ipv6_hdr(skb);
+ 	if (hdr->version != 6)
+ 		return 0;
+ 
+ 	pkt_len = ntohs(hdr->payload_len);
+ 	if (pkt_len + sizeof(struct ipv6hdr) > skb->len)
+ 		return 0;
+ 
+ 	return 1;
+ }
+ EXPORT_SYMBOL_GPL(nft_bridge_ip6hdr_validate);
+ 
+ static inline void nft_bridge_set_pktinfo_ipv4(struct nft_pktinfo *pkt,
+ 					       const struct nf_hook_ops *ops,
+ 					       struct sk_buff *skb,
+ 					       const struct nf_hook_state *state)
+ {
+ 	if (nft_bridge_iphdr_validate(skb))
+ 		nft_set_pktinfo_ipv4(pkt, ops, skb, state);
+ 	else
+ 		nft_set_pktinfo(pkt, ops, skb, state);
+ }
+ 
+ static inline void nft_bridge_set_pktinfo_ipv6(struct nft_pktinfo *pkt,
+ 					       const struct nf_hook_ops *ops,
+ 					       struct sk_buff *skb,
+ 					       const struct nf_hook_state *state)
+ {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	if (nft_bridge_ip6hdr_validate(skb) &&
+ 	    nft_set_pktinfo_ipv6(pkt, ops, skb, state) == 0)
+ 		return;
+ #endif
+ 	nft_set_pktinfo(pkt, ops, skb, state);
+ }
++>>>>>>> 073bfd568604 (netfilter: Pass nf_hook_state through nft_set_pktinfo*().)
  
  static unsigned int
  nft_do_chain_bridge(const struct nf_hook_ops *ops,
@@@ -23,7 -95,17 +100,21 @@@
  {
  	struct nft_pktinfo pkt;
  
++<<<<<<< HEAD
 +	nft_set_pktinfo(&pkt, ops, skb, in, out);
++=======
+ 	switch (eth_hdr(skb)->h_proto) {
+ 	case htons(ETH_P_IP):
+ 		nft_bridge_set_pktinfo_ipv4(&pkt, ops, skb, state);
+ 		break;
+ 	case htons(ETH_P_IPV6):
+ 		nft_bridge_set_pktinfo_ipv6(&pkt, ops, skb, state);
+ 		break;
+ 	default:
+ 		nft_set_pktinfo(&pkt, ops, skb, state);
+ 		break;
+ 	}
++>>>>>>> 073bfd568604 (netfilter: Pass nf_hook_state through nft_set_pktinfo*().)
  
  	return nft_do_chain(&pkt, ops);
  }
diff --cc net/ipv4/netfilter/nf_tables_arp.c
index 19412a4063fb,8412268bbad1..000000000000
--- a/net/ipv4/netfilter/nf_tables_arp.c
+++ b/net/ipv4/netfilter/nf_tables_arp.c
@@@ -23,7 -21,7 +23,11 @@@ nft_do_chain_arp(const struct nf_hook_o
  {
  	struct nft_pktinfo pkt;
  
++<<<<<<< HEAD
 +	nft_set_pktinfo(&pkt, ops, skb, in, out);
++=======
+ 	nft_set_pktinfo(&pkt, ops, skb, state);
++>>>>>>> 073bfd568604 (netfilter: Pass nf_hook_state through nft_set_pktinfo*().)
  
  	return nft_do_chain(&pkt, ops);
  }
diff --cc net/ipv4/netfilter/nf_tables_ipv4.c
index 6820c8c40842,aa180d3a69a5..000000000000
--- a/net/ipv4/netfilter/nf_tables_ipv4.c
+++ b/net/ipv4/netfilter/nf_tables_ipv4.c
@@@ -26,7 -24,7 +26,11 @@@ static unsigned int nft_do_chain_ipv4(c
  {
  	struct nft_pktinfo pkt;
  
++<<<<<<< HEAD
 +	nft_set_pktinfo_ipv4(&pkt, ops, skb, in, out);
++=======
+ 	nft_set_pktinfo_ipv4(&pkt, ops, skb, state);
++>>>>>>> 073bfd568604 (netfilter: Pass nf_hook_state through nft_set_pktinfo*().)
  
  	return nft_do_chain(&pkt, ops);
  }
diff --cc net/ipv4/netfilter/nft_chain_nat_ipv4.c
index df547bf50078,bf5c30ae14e4..000000000000
--- a/net/ipv4/netfilter/nft_chain_nat_ipv4.c
+++ b/net/ipv4/netfilter/nft_chain_nat_ipv4.c
@@@ -34,7 -33,7 +34,11 @@@ static unsigned int nft_nat_do_chain(co
  {
  	struct nft_pktinfo pkt;
  
++<<<<<<< HEAD
 +	nft_set_pktinfo_ipv4(&pkt, ops, skb, in, out);
++=======
+ 	nft_set_pktinfo_ipv4(&pkt, ops, skb, state);
++>>>>>>> 073bfd568604 (netfilter: Pass nf_hook_state through nft_set_pktinfo*().)
  
  	return nft_do_chain(&pkt, ops);
  }
diff --cc net/ipv4/netfilter/nft_chain_route_ipv4.c
index 125b66766c0a,e335b0afdaf3..000000000000
--- a/net/ipv4/netfilter/nft_chain_route_ipv4.c
+++ b/net/ipv4/netfilter/nft_chain_route_ipv4.c
@@@ -39,7 -37,7 +39,11 @@@ static unsigned int nf_route_table_hook
  	    ip_hdrlen(skb) < sizeof(struct iphdr))
  		return NF_ACCEPT;
  
++<<<<<<< HEAD
 +	nft_set_pktinfo_ipv4(&pkt, ops, skb, in, out);
++=======
+ 	nft_set_pktinfo_ipv4(&pkt, ops, skb, state);
++>>>>>>> 073bfd568604 (netfilter: Pass nf_hook_state through nft_set_pktinfo*().)
  
  	mark = skb->mark;
  	iph = ip_hdr(skb);
diff --cc net/ipv6/netfilter/nf_tables_ipv6.c
index 0d812b31277d,c8148ba76d1a..000000000000
--- a/net/ipv6/netfilter/nf_tables_ipv6.c
+++ b/net/ipv6/netfilter/nf_tables_ipv6.c
@@@ -25,7 -23,7 +25,11 @@@ static unsigned int nft_do_chain_ipv6(c
  	struct nft_pktinfo pkt;
  
  	/* malformed packet, drop it */
++<<<<<<< HEAD
 +	if (nft_set_pktinfo_ipv6(&pkt, ops, skb, in, out) < 0)
++=======
+ 	if (nft_set_pktinfo_ipv6(&pkt, ops, skb, state) < 0)
++>>>>>>> 073bfd568604 (netfilter: Pass nf_hook_state through nft_set_pktinfo*().)
  		return NF_DROP;
  
  	return nft_do_chain(&pkt, ops);
diff --cc net/ipv6/netfilter/nft_chain_nat_ipv6.c
index 1c4b75dd425b,951bb458b7bd..000000000000
--- a/net/ipv6/netfilter/nft_chain_nat_ipv6.c
+++ b/net/ipv6/netfilter/nft_chain_nat_ipv6.c
@@@ -32,7 -31,7 +32,11 @@@ static unsigned int nft_nat_do_chain(co
  {
  	struct nft_pktinfo pkt;
  
++<<<<<<< HEAD
 +	nft_set_pktinfo_ipv6(&pkt, ops, skb, in, out);
++=======
+ 	nft_set_pktinfo_ipv6(&pkt, ops, skb, state);
++>>>>>>> 073bfd568604 (netfilter: Pass nf_hook_state through nft_set_pktinfo*().)
  
  	return nft_do_chain(&pkt, ops);
  }
diff --cc net/ipv6/netfilter/nft_chain_route_ipv6.c
index 42031299585e,0dafdaac5e17..000000000000
--- a/net/ipv6/netfilter/nft_chain_route_ipv6.c
+++ b/net/ipv6/netfilter/nft_chain_route_ipv6.c
@@@ -35,7 -33,7 +35,11 @@@ static unsigned int nf_route_table_hook
  	u32 mark, flowlabel;
  
  	/* malformed packet, drop it */
++<<<<<<< HEAD
 +	if (nft_set_pktinfo_ipv6(&pkt, ops, skb, in, out) < 0)
++=======
+ 	if (nft_set_pktinfo_ipv6(&pkt, ops, skb, state) < 0)
++>>>>>>> 073bfd568604 (netfilter: Pass nf_hook_state through nft_set_pktinfo*().)
  		return NF_DROP;
  
  	/* save source/dest address, mark, hoplimit, flowlabel, priority */
diff --git a/include/net/netfilter/nf_tables.h b/include/net/netfilter/nf_tables.h
index 3d7292392fac..9bcfca9b48a1 100644
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@ -26,12 +26,11 @@ struct nft_pktinfo {
 static inline void nft_set_pktinfo(struct nft_pktinfo *pkt,
 				   const struct nf_hook_ops *ops,
 				   struct sk_buff *skb,
-				   const struct net_device *in,
-				   const struct net_device *out)
+				   const struct nf_hook_state *state)
 {
 	pkt->skb = skb;
-	pkt->in = pkt->xt.in = in;
-	pkt->out = pkt->xt.out = out;
+	pkt->in = pkt->xt.in = state->in;
+	pkt->out = pkt->xt.out = state->out;
 	pkt->ops = ops;
 	pkt->xt.hooknum = ops->hooknum;
 	pkt->xt.family = ops->pf;
diff --git a/include/net/netfilter/nf_tables_ipv4.h b/include/net/netfilter/nf_tables_ipv4.h
index cba143fbd2e4..2df7f96902ee 100644
--- a/include/net/netfilter/nf_tables_ipv4.h
+++ b/include/net/netfilter/nf_tables_ipv4.h
@@ -8,12 +8,11 @@ static inline void
 nft_set_pktinfo_ipv4(struct nft_pktinfo *pkt,
 		     const struct nf_hook_ops *ops,
 		     struct sk_buff *skb,
-		     const struct net_device *in,
-		     const struct net_device *out)
+		     const struct nf_hook_state *state)
 {
 	struct iphdr *ip;
 
-	nft_set_pktinfo(pkt, ops, skb, in, out);
+	nft_set_pktinfo(pkt, ops, skb, state);
 
 	ip = ip_hdr(pkt->skb);
 	pkt->tprot = ip->protocol;
diff --git a/include/net/netfilter/nf_tables_ipv6.h b/include/net/netfilter/nf_tables_ipv6.h
index 74d976137658..97db2e3a5e65 100644
--- a/include/net/netfilter/nf_tables_ipv6.h
+++ b/include/net/netfilter/nf_tables_ipv6.h
@@ -8,13 +8,12 @@ static inline int
 nft_set_pktinfo_ipv6(struct nft_pktinfo *pkt,
 		     const struct nf_hook_ops *ops,
 		     struct sk_buff *skb,
-		     const struct net_device *in,
-		     const struct net_device *out)
+		     const struct nf_hook_state *state)
 {
 	int protohdr, thoff = 0;
 	unsigned short frag_off;
 
-	nft_set_pktinfo(pkt, ops, skb, in, out);
+	nft_set_pktinfo(pkt, ops, skb, state);
 
 	protohdr = ipv6_find_hdr(pkt->skb, &thoff, -1, &frag_off, NULL);
 	/* If malformed, drop it */
* Unmerged path net/bridge/netfilter/nf_tables_bridge.c
* Unmerged path net/ipv4/netfilter/nf_tables_arp.c
* Unmerged path net/ipv4/netfilter/nf_tables_ipv4.c
* Unmerged path net/ipv4/netfilter/nft_chain_nat_ipv4.c
* Unmerged path net/ipv4/netfilter/nft_chain_route_ipv4.c
* Unmerged path net/ipv6/netfilter/nf_tables_ipv6.c
* Unmerged path net/ipv6/netfilter/nft_chain_nat_ipv6.c
* Unmerged path net/ipv6/netfilter/nft_chain_route_ipv6.c
