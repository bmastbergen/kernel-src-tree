ACPI / video: Unregister the backlight device if a raw one shows up later

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [acpi] video: Unregister the backlight device if a raw one shows up later (Benjamin Tissoires) [1218354]
Rebuild_FUZZ: 94.96%
commit-author Hans de Goede <hdegoede@redhat.com>
commit 53a92ba7e3762154df01c4f4f5d871df0587c96b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/53a92ba7.failed

When video.use_native_backlight=1 and non intel gfx are in use, the raw
backlight device of the gfx driver will show up after acpi-video has done its
acpi_video_verify_backlight_support() check.

This causes video.use_native_backlight=1 to not have the desired result.

This patch fixes this by adding a backlight notifier and when a raw
backlight is registered or unregistered re-doing the
acpi_video_verify_backlight_support() check.

	Signed-off-by: Hans de Goede <hdegoede@redhat.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 53a92ba7e3762154df01c4f4f5d871df0587c96b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/video.c
diff --cc drivers/acpi/video.c
index e28ad28032c6,d40c04cbb422..000000000000
--- a/drivers/acpi/video.c
+++ b/drivers/acpi/video.c
@@@ -148,6 -150,8 +148,11 @@@ struct acpi_video_enumerated_device 
  
  struct acpi_video_bus {
  	struct acpi_device *device;
++<<<<<<< HEAD
++=======
+ 	bool backlight_registered;
+ 	bool backlight_notifier_registered;
++>>>>>>> 53a92ba7e376 (ACPI / video: Unregister the backlight device if a raw one shows up later)
  	u8 dos_setting;
  	struct acpi_video_enumerated_device *attached_array;
  	u8 attached_count;
@@@ -1707,6 -1659,292 +1713,295 @@@ acpi_video_bus_match(acpi_handle handle
  	return AE_OK;
  }
  
++<<<<<<< HEAD
++=======
+ static void acpi_video_dev_register_backlight(struct acpi_video_device *device)
+ {
+ 	struct backlight_properties props;
+ 	struct pci_dev *pdev;
+ 	acpi_handle acpi_parent;
+ 	struct device *parent = NULL;
+ 	int result;
+ 	static int count;
+ 	char *name;
+ 
+ 	result = acpi_video_init_brightness(device);
+ 	if (result)
+ 		return;
+ 	name = kasprintf(GFP_KERNEL, "acpi_video%d", count);
+ 	if (!name)
+ 		return;
+ 	count++;
+ 
+ 	acpi_get_parent(device->dev->handle, &acpi_parent);
+ 
+ 	pdev = acpi_get_pci_dev(acpi_parent);
+ 	if (pdev) {
+ 		parent = &pdev->dev;
+ 		pci_dev_put(pdev);
+ 	}
+ 
+ 	memset(&props, 0, sizeof(struct backlight_properties));
+ 	props.type = BACKLIGHT_FIRMWARE;
+ 	props.max_brightness = device->brightness->count - 3;
+ 	device->backlight = backlight_device_register(name,
+ 						      parent,
+ 						      device,
+ 						      &acpi_backlight_ops,
+ 						      &props);
+ 	kfree(name);
+ 	if (IS_ERR(device->backlight))
+ 		return;
+ 
+ 	/*
+ 	 * Save current brightness level in case we have to restore it
+ 	 * before acpi_video_device_lcd_set_level() is called next time.
+ 	 */
+ 	device->backlight->props.brightness =
+ 			acpi_video_get_brightness(device->backlight);
+ 
+ 	device->cooling_dev = thermal_cooling_device_register("LCD",
+ 				device->dev, &video_cooling_ops);
+ 	if (IS_ERR(device->cooling_dev)) {
+ 		/*
+ 		 * Set cooling_dev to NULL so we don't crash trying to free it.
+ 		 * Also, why the hell we are returning early and not attempt to
+ 		 * register video output if cooling device registration failed?
+ 		 * -- dtor
+ 		 */
+ 		device->cooling_dev = NULL;
+ 		return;
+ 	}
+ 
+ 	dev_info(&device->dev->dev, "registered as cooling_device%d\n",
+ 		 device->cooling_dev->id);
+ 	result = sysfs_create_link(&device->dev->dev.kobj,
+ 			&device->cooling_dev->device.kobj,
+ 			"thermal_cooling");
+ 	if (result)
+ 		printk(KERN_ERR PREFIX "Create sysfs link\n");
+ 	result = sysfs_create_link(&device->cooling_dev->device.kobj,
+ 			&device->dev->dev.kobj, "device");
+ 	if (result)
+ 		printk(KERN_ERR PREFIX "Create sysfs link\n");
+ }
+ 
+ static int acpi_video_bus_register_backlight(struct acpi_video_bus *video)
+ {
+ 	struct acpi_video_device *dev;
+ 
+ 	if (video->backlight_registered)
+ 		return 0;
+ 
+ 	if (!acpi_video_verify_backlight_support())
+ 		return 0;
+ 
+ 	mutex_lock(&video->device_list_lock);
+ 	list_for_each_entry(dev, &video->video_device_list, entry)
+ 		acpi_video_dev_register_backlight(dev);
+ 	mutex_unlock(&video->device_list_lock);
+ 
+ 	video->backlight_registered = true;
+ 
+ 	video->pm_nb.notifier_call = acpi_video_resume;
+ 	video->pm_nb.priority = 0;
+ 	return register_pm_notifier(&video->pm_nb);
+ }
+ 
+ static void acpi_video_dev_unregister_backlight(struct acpi_video_device *device)
+ {
+ 	if (device->backlight) {
+ 		backlight_device_unregister(device->backlight);
+ 		device->backlight = NULL;
+ 	}
+ 	if (device->brightness) {
+ 		kfree(device->brightness->levels);
+ 		kfree(device->brightness);
+ 		device->brightness = NULL;
+ 	}
+ 	if (device->cooling_dev) {
+ 		sysfs_remove_link(&device->dev->dev.kobj, "thermal_cooling");
+ 		sysfs_remove_link(&device->cooling_dev->device.kobj, "device");
+ 		thermal_cooling_device_unregister(device->cooling_dev);
+ 		device->cooling_dev = NULL;
+ 	}
+ }
+ 
+ static int acpi_video_bus_unregister_backlight(struct acpi_video_bus *video)
+ {
+ 	struct acpi_video_device *dev;
+ 	int error;
+ 
+ 	if (!video->backlight_registered)
+ 		return 0;
+ 
+ 	error = unregister_pm_notifier(&video->pm_nb);
+ 
+ 	mutex_lock(&video->device_list_lock);
+ 	list_for_each_entry(dev, &video->video_device_list, entry)
+ 		acpi_video_dev_unregister_backlight(dev);
+ 	mutex_unlock(&video->device_list_lock);
+ 
+ 	video->backlight_registered = false;
+ 
+ 	return error;
+ }
+ 
+ static void acpi_video_dev_add_notify_handler(struct acpi_video_device *device)
+ {
+ 	acpi_status status;
+ 	struct acpi_device *adev = device->dev;
+ 
+ 	status = acpi_install_notify_handler(adev->handle, ACPI_DEVICE_NOTIFY,
+ 					     acpi_video_device_notify, device);
+ 	if (ACPI_FAILURE(status))
+ 		dev_err(&adev->dev, "Error installing notify handler\n");
+ 	else
+ 		device->flags.notify = 1;
+ }
+ 
+ static int acpi_video_bus_add_notify_handler(struct acpi_video_bus *video)
+ {
+ 	struct input_dev *input;
+ 	struct acpi_video_device *dev;
+ 	int error;
+ 
+ 	video->input = input = input_allocate_device();
+ 	if (!input) {
+ 		error = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	error = acpi_video_bus_start_devices(video);
+ 	if (error)
+ 		goto err_free_input;
+ 
+ 	snprintf(video->phys, sizeof(video->phys),
+ 			"%s/video/input0", acpi_device_hid(video->device));
+ 
+ 	input->name = acpi_device_name(video->device);
+ 	input->phys = video->phys;
+ 	input->id.bustype = BUS_HOST;
+ 	input->id.product = 0x06;
+ 	input->dev.parent = &video->device->dev;
+ 	input->evbit[0] = BIT(EV_KEY);
+ 	set_bit(KEY_SWITCHVIDEOMODE, input->keybit);
+ 	set_bit(KEY_VIDEO_NEXT, input->keybit);
+ 	set_bit(KEY_VIDEO_PREV, input->keybit);
+ 	set_bit(KEY_BRIGHTNESS_CYCLE, input->keybit);
+ 	set_bit(KEY_BRIGHTNESSUP, input->keybit);
+ 	set_bit(KEY_BRIGHTNESSDOWN, input->keybit);
+ 	set_bit(KEY_BRIGHTNESS_ZERO, input->keybit);
+ 	set_bit(KEY_DISPLAY_OFF, input->keybit);
+ 
+ 	error = input_register_device(input);
+ 	if (error)
+ 		goto err_stop_dev;
+ 
+ 	mutex_lock(&video->device_list_lock);
+ 	list_for_each_entry(dev, &video->video_device_list, entry)
+ 		acpi_video_dev_add_notify_handler(dev);
+ 	mutex_unlock(&video->device_list_lock);
+ 
+ 	return 0;
+ 
+ err_stop_dev:
+ 	acpi_video_bus_stop_devices(video);
+ err_free_input:
+ 	input_free_device(input);
+ 	video->input = NULL;
+ out:
+ 	return error;
+ }
+ 
+ static void acpi_video_dev_remove_notify_handler(struct acpi_video_device *dev)
+ {
+ 	if (dev->flags.notify) {
+ 		acpi_remove_notify_handler(dev->dev->handle, ACPI_DEVICE_NOTIFY,
+ 					   acpi_video_device_notify);
+ 		dev->flags.notify = 0;
+ 	}
+ }
+ 
+ static void acpi_video_bus_remove_notify_handler(struct acpi_video_bus *video)
+ {
+ 	struct acpi_video_device *dev;
+ 
+ 	mutex_lock(&video->device_list_lock);
+ 	list_for_each_entry(dev, &video->video_device_list, entry)
+ 		acpi_video_dev_remove_notify_handler(dev);
+ 	mutex_unlock(&video->device_list_lock);
+ 
+ 	acpi_video_bus_stop_devices(video);
+ 	input_unregister_device(video->input);
+ 	video->input = NULL;
+ }
+ 
+ static int acpi_video_backlight_notify(struct notifier_block *nb,
+ 					unsigned long val, void *bd)
+ {
+ 	struct backlight_device *backlight = bd;
+ 	struct acpi_video_bus *video;
+ 
+ 	/* acpi_video_verify_backlight_support only cares about raw devices */
+ 	if (backlight->props.type != BACKLIGHT_RAW)
+ 		return NOTIFY_DONE;
+ 
+ 	video = container_of(nb, struct acpi_video_bus, backlight_nb);
+ 
+ 	switch (val) {
+ 	case BACKLIGHT_REGISTERED:
+ 		if (!acpi_video_verify_backlight_support())
+ 			acpi_video_bus_unregister_backlight(video);
+ 		break;
+ 	case BACKLIGHT_UNREGISTERED:
+ 		acpi_video_bus_register_backlight(video);
+ 		break;
+ 	}
+ 
+ 	return NOTIFY_OK;
+ }
+ 
+ static int acpi_video_bus_add_backlight_notify_handler(
+ 						struct acpi_video_bus *video)
+ {
+ 	int error;
+ 
+ 	video->backlight_nb.notifier_call = acpi_video_backlight_notify;
+ 	video->backlight_nb.priority = 0;
+ 	error = backlight_register_notifier(&video->backlight_nb);
+ 	if (error == 0)
+ 		video->backlight_notifier_registered = true;
+ 
+ 	return error;
+ }
+ 
+ static int acpi_video_bus_remove_backlight_notify_handler(
+ 						struct acpi_video_bus *video)
+ {
+ 	if (!video->backlight_notifier_registered)
+ 		return 0;
+ 
+ 	video->backlight_notifier_registered = false;
+ 
+ 	return backlight_unregister_notifier(&video->backlight_nb);
+ }
+ 
+ static int acpi_video_bus_put_devices(struct acpi_video_bus *video)
+ {
+ 	struct acpi_video_device *dev, *next;
+ 
+ 	mutex_lock(&video->device_list_lock);
+ 	list_for_each_entry_safe(dev, next, &video->video_device_list, entry) {
+ 		list_del(&dev->entry);
+ 		kfree(dev);
+ 	}
+ 	mutex_unlock(&video->device_list_lock);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 53a92ba7e376 (ACPI / video: Unregister the backlight device if a raw one shows up later)
  static int instance;
  
  static int acpi_video_bus_add(struct acpi_device *device)
@@@ -1797,16 -2006,13 +2092,22 @@@
  	       video->flags.multihead ? "yes" : "no",
  	       video->flags.rom ? "yes" : "no",
  	       video->flags.post ? "yes" : "no");
 -	mutex_lock(&video_list_lock);
 -	list_add_tail(&video->entry, &video_bus_head);
 -	mutex_unlock(&video_list_lock);
  
++<<<<<<< HEAD
 +	video->pm_nb.notifier_call = acpi_video_resume;
 +	video->pm_nb.priority = 0;
 +	error = register_pm_notifier(&video->pm_nb);
 +	if (error)
 +		goto err_stop_video;
 +
 +	error = input_register_device(input);
 +	if (error)
 +		goto err_unregister_pm_notifier;
++=======
+ 	acpi_video_bus_register_backlight(video);
+ 	acpi_video_bus_add_notify_handler(video);
+ 	acpi_video_bus_add_backlight_notify_handler(video);
++>>>>>>> 53a92ba7e376 (ACPI / video: Unregister the backlight device if a raw one shows up later)
  
  	return 0;
  
@@@ -1836,12 -2036,15 +2137,18 @@@ static int acpi_video_bus_remove(struc
  
  	video = acpi_driver_data(device);
  
++<<<<<<< HEAD
 +	unregister_pm_notifier(&video->pm_nb);
 +
 +	acpi_video_bus_stop_devices(video);
++=======
+ 	acpi_video_bus_remove_backlight_notify_handler(video);
+ 	acpi_video_bus_remove_notify_handler(video);
+ 	acpi_video_bus_unregister_backlight(video);
++>>>>>>> 53a92ba7e376 (ACPI / video: Unregister the backlight device if a raw one shows up later)
  	acpi_video_bus_put_devices(video);
  
 -	mutex_lock(&video_list_lock);
 -	list_del(&video->entry);
 -	mutex_unlock(&video_list_lock);
 -
 +	input_unregister_device(video->input);
  	kfree(video->attached_array);
  	kfree(video);
  
* Unmerged path drivers/acpi/video.c
