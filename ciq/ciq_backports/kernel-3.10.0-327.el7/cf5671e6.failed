be2net: Add a few inline functions to test TXQ conditions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Sriharsha Basavapatna <sriharsha.basavapatna@emulex.com>
commit cf5671e6999829933aa4b9b8eefc7d3b8b85c5cb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/cf5671e6.failed

- Check qfull condition
- Check qwake condition
- Check pkts pending completion

	Signed-off-by: Sriharsha Basavapatna <sriharsha.basavapatna@emulex.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit cf5671e6999829933aa4b9b8eefc7d3b8b85c5cb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/emulex/benet/be_main.c
diff --cc drivers/net/ethernet/emulex/benet/be_main.c
index b2184bdb8a43,c1553fba7916..000000000000
--- a/drivers/net/ethernet/emulex/benet/be_main.c
+++ b/drivers/net/ethernet/emulex/benet/be_main.c
@@@ -728,24 -727,35 +728,45 @@@ static u16 skb_ip_proto(struct sk_buff 
  		ip_hdr(skb)->protocol : ipv6_hdr(skb)->nexthdr;
  }
  
++<<<<<<< HEAD
 +static void wrb_fill_hdr(struct be_adapter *adapter, struct be_eth_hdr_wrb *hdr,
 +			 struct sk_buff *skb, u32 wrb_cnt, u32 len,
 +			 bool skip_hw_vlan)
++=======
+ static inline bool be_is_txq_full(struct be_tx_obj *txo)
+ {
+ 	return atomic_read(&txo->q.used) + BE_MAX_TX_FRAG_COUNT >= txo->q.len;
+ }
+ 
+ static inline bool be_can_txq_wake(struct be_tx_obj *txo)
+ {
+ 	return atomic_read(&txo->q.used) < txo->q.len / 2;
+ }
+ 
+ static inline bool be_is_tx_compl_pending(struct be_tx_obj *txo)
+ {
+ 	return atomic_read(&txo->q.used) > txo->pend_wrb_cnt;
+ }
+ 
+ static void be_get_wrb_params_from_skb(struct be_adapter *adapter,
+ 				       struct sk_buff *skb,
+ 				       struct be_wrb_params *wrb_params)
++>>>>>>> cf5671e69998 (be2net: Add a few inline functions to test TXQ conditions)
  {
 -	u16 proto;
 +	u16 vlan_tag, proto;
 +
 +	memset(hdr, 0, sizeof(*hdr));
 +
 +	SET_TX_WRB_HDR_BITS(crc, hdr, 1);
  
  	if (skb_is_gso(skb)) {
 -		BE_WRB_F_SET(wrb_params->features, LSO, 1);
 -		wrb_params->lso_mss = skb_shinfo(skb)->gso_size;
 +		SET_TX_WRB_HDR_BITS(lso, hdr, 1);
 +		SET_TX_WRB_HDR_BITS(lso_mss, hdr, skb_shinfo(skb)->gso_size);
  		if (skb_is_gso_v6(skb) && !lancer_chip(adapter))
 -			BE_WRB_F_SET(wrb_params->features, LSO6, 1);
 +			SET_TX_WRB_HDR_BITS(lso6, hdr, 1);
  	} else if (skb->ip_summed == CHECKSUM_PARTIAL) {
  		if (skb->encapsulation) {
 -			BE_WRB_F_SET(wrb_params->features, IPCS, 1);
 +			SET_TX_WRB_HDR_BITS(ipcs, hdr, 1);
  			proto = skb_inner_ip_proto(skb);
  		} else {
  			proto = skb_ip_proto(skb);
@@@ -1058,10 -1148,11 +1079,15 @@@ static netdev_tx_t be_xmit(struct sk_bu
  	struct be_adapter *adapter = netdev_priv(netdev);
  	u16 q_idx = skb_get_queue_mapping(skb);
  	struct be_tx_obj *txo = &adapter->tx_obj[q_idx];
++<<<<<<< HEAD
 +	struct be_queue_info *txq = &txo->q;
++=======
+ 	struct be_wrb_params wrb_params = { 0 };
+ 	bool flush = !skb->xmit_more;
++>>>>>>> cf5671e69998 (be2net: Add a few inline functions to test TXQ conditions)
  	u16 wrb_cnt;
  
 -	skb = be_xmit_workarounds(adapter, skb, &wrb_params);
 +	skb = be_xmit_workarounds(adapter, skb, &skip_hw_vlan);
  	if (unlikely(!skb))
  		goto drop;
  
* Unmerged path drivers/net/ethernet/emulex/benet/be_main.c
