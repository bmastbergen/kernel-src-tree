bonding: fix bond_open() don't always set slave active flag

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Wilson Kok <wkok@cumulusnetworks.com>
commit 8bbe71a5956f833ec0d940419d1d368de5f1b58b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/8bbe71a5.failed

Mode 802.3ad, fix incorrect bond slave active state when slave is not in
active aggregator. During bond_open(), the bonding driver always sets
the slave active flag to true if the bond is not in active-backup, alb,
or tlb modes. Bonding should let the aggregator selection logic set the
active flag when in 802.3ad mode.

	Cc: Andy Gospodarek <gospo@cumulusnetworks.com>
	Reviewed-by: Nikolay Aleksandrov <nikolay@redhat.com>
	Signed-off-by: Wilson Kok <wkok@cumulusnetworks.com>
	Signed-off-by: Jonathan Toppins <jtoppins@cumulusnetworks.com>
	Signed-off-by: Jay Vosburgh <jay.vosburgh@canonical.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8bbe71a5956f833ec0d940419d1d368de5f1b58b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
diff --cc drivers/net/bonding/bond_main.c
index 723c3d160745,beff00e7e110..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -3340,24 -3056,22 +3340,36 @@@ static void bond_work_cancel_all(struc
  static int bond_open(struct net_device *bond_dev)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
 -	struct list_head *iter;
  	struct slave *slave;
 +	int i;
  
  	/* reset slave->backup and slave->inactive */
++<<<<<<< HEAD
 +	read_lock(&bond->lock);
 +	if (bond->slave_cnt > 0) {
 +		read_lock(&bond->curr_slave_lock);
 +		bond_for_each_slave(bond, slave, i) {
 +			if ((bond->params.mode == BOND_MODE_ACTIVEBACKUP)
 +				&& (slave != bond->curr_active_slave)) {
 +				bond_set_slave_inactive_flags(slave);
 +			} else {
 +				bond_set_slave_active_flags(slave);
++=======
+ 	if (bond_has_slaves(bond)) {
+ 		bond_for_each_slave(bond, slave, iter) {
+ 			if (bond_uses_primary(bond) &&
+ 			    slave != rcu_access_pointer(bond->curr_active_slave)) {
+ 				bond_set_slave_inactive_flags(slave,
+ 							      BOND_SLAVE_NOTIFY_NOW);
+ 			} else if (BOND_MODE(bond) != BOND_MODE_8023AD) {
+ 				bond_set_slave_active_flags(slave,
+ 							    BOND_SLAVE_NOTIFY_NOW);
++>>>>>>> 8bbe71a5956f (bonding: fix bond_open() don't always set slave active flag)
  			}
  		}
 +		read_unlock(&bond->curr_slave_lock);
  	}
 +	read_unlock(&bond->lock);
  
  	bond_work_init_all(bond);
  
* Unmerged path drivers/net/bonding/bond_main.c
