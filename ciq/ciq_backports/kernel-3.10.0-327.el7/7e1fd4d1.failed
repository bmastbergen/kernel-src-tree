IB/iser: Remove redundant is_mr indicator

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [infiniband] iser: Remove redundant is_mr indicator (Amir Vadai) [1164539]
Rebuild_FUZZ: 96.20%
commit-author Sagi Grimberg <sagig@mellanox.com>
commit 7e1fd4d1e3c801a07609300e03912524b3abb5cb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/7e1fd4d1.failed

It is enough to check mem_h pointer assignment, mem_h == NULL will
indicate that buffer is not registered using mr.

	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Roland Dreier <roland@purestorage.com>
(cherry picked from commit 7e1fd4d1e3c801a07609300e03912524b3abb5cb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/iser/iscsi_iser.h
diff --cc drivers/infiniband/ulp/iser/iscsi_iser.h
index 50ec84465483,e34263cbecc3..000000000000
--- a/drivers/infiniband/ulp/iser/iscsi_iser.h
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.h
@@@ -217,20 -244,37 +217,31 @@@ struct iser_cq_desc
  struct iscsi_iser_task;
  struct iscsi_endpoint;
  
++<<<<<<< HEAD
++=======
+ /**
+  * struct iser_mem_reg - iSER memory registration info
+  *
+  * @lkey:         MR local key
+  * @rkey:         MR remote key
+  * @va:           MR start address (buffer va)
+  * @len:          MR length
+  * @mem_h:        pointer to registration context (FMR/Fastreg)
+  */
++>>>>>>> 7e1fd4d1e3c8 (IB/iser: Remove redundant is_mr indicator)
  struct iser_mem_reg {
  	u32  lkey;
  	u32  rkey;
  	u64  va;
  	u64  len;
  	void *mem_h;
- 	int  is_mr;
  };
  
 -/**
 - * struct iser_regd_buf - iSER buffer registration desc
 - *
 - * @reg:          memory registration info
 - * @virt_addr:    virtual address of buffer
 - * @device:       reference to iser device
 - * @direction:    dma direction (for dma_unmap)
 - * @data_size:    data buffer size in bytes
 - */
  struct iser_regd_buf {
 -	struct iser_mem_reg     reg;
 +	struct iser_mem_reg     reg;        /* memory registration info        */
  	void                    *virt_addr;
 -	struct iser_device      *device;
 -	enum dma_data_direction direction;
 +	struct iser_device      *device;    /* device->device for dma_unmap    */
 +	enum dma_data_direction direction;  /* direction for dma_unmap	       */
  	unsigned int            data_size;
  };
  
* Unmerged path drivers/infiniband/ulp/iser/iscsi_iser.h
diff --git a/drivers/infiniband/ulp/iser/iser_memory.c b/drivers/infiniband/ulp/iser/iser_memory.c
index ae4cb9b6edf7..76b1de3d35a6 100644
--- a/drivers/infiniband/ulp/iser/iser_memory.c
+++ b/drivers/infiniband/ulp/iser/iser_memory.c
@@ -409,7 +409,6 @@ int iser_reg_rdma_mem_fmr(struct iscsi_iser_task *iser_task,
 		regd_buf->reg.rkey = device->mr->rkey;
 		regd_buf->reg.len  = ib_sg_dma_len(ibdev, &sg[0]);
 		regd_buf->reg.va   = ib_sg_dma_address(ibdev, &sg[0]);
-		regd_buf->reg.is_mr = 0;
 
 		iser_dbg("PHYSICAL Mem.register: lkey: 0x%08X rkey: 0x%08X  "
 			 "va: 0x%08lX sz: %ld]\n",
@@ -773,15 +772,11 @@ int iser_reg_rdma_mem_fastreg(struct iscsi_iser_task *iser_task,
 		regd_buf->reg.rkey = desc->pi_ctx->sig_mr->rkey;
 		regd_buf->reg.va = sig_sge.addr;
 		regd_buf->reg.len = sig_sge.length;
-		regd_buf->reg.is_mr = 1;
 	} else {
-		if (desc) {
+		if (desc)
 			regd_buf->reg.rkey = desc->data_mr->rkey;
-			regd_buf->reg.is_mr = 1;
-		} else {
+		else
 			regd_buf->reg.rkey = device->mr->rkey;
-			regd_buf->reg.is_mr = 0;
-		}
 
 		regd_buf->reg.lkey = data_sge.lkey;
 		regd_buf->reg.va = data_sge.addr;
diff --git a/drivers/infiniband/ulp/iser/iser_verbs.c b/drivers/infiniband/ulp/iser/iser_verbs.c
index 4cafd44ad193..d8e66ae6996b 100644
--- a/drivers/infiniband/ulp/iser/iser_verbs.c
+++ b/drivers/infiniband/ulp/iser/iser_verbs.c
@@ -954,7 +954,6 @@ int iser_reg_page_vec(struct iser_conn     *ib_conn,
 	mem_reg->rkey  = mem->fmr->rkey;
 	mem_reg->len   = page_vec->length * SIZE_4K;
 	mem_reg->va    = io_addr;
-	mem_reg->is_mr = 1;
 	mem_reg->mem_h = (void *)mem;
 
 	mem_reg->va   += page_vec->offset;
@@ -981,7 +980,7 @@ void iser_unreg_mem_fmr(struct iscsi_iser_task *iser_task,
 	struct iser_mem_reg *reg = &iser_task->rdma_regd[cmd_dir].reg;
 	int ret;
 
-	if (!reg->is_mr)
+	if (!reg->mem_h)
 		return;
 
 	iser_dbg("PHYSICAL Mem.Unregister mem_h %p\n",reg->mem_h);
@@ -1000,11 +999,10 @@ void iser_unreg_mem_fastreg(struct iscsi_iser_task *iser_task,
 	struct iser_conn *ib_conn = iser_task->ib_conn;
 	struct fast_reg_descriptor *desc = reg->mem_h;
 
-	if (!reg->is_mr)
+	if (!desc)
 		return;
 
 	reg->mem_h = NULL;
-	reg->is_mr = 0;
 	spin_lock_bh(&ib_conn->lock);
 	list_add_tail(&desc->list, &ib_conn->fastreg.pool);
 	spin_unlock_bh(&ib_conn->lock);
