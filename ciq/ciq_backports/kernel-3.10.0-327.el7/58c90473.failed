xfs: inodes are new until the dentry cache is set up

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit 58c904734cd0917cd0953067dd68003572407c7b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/58c90473.failed

Al Viro noticed a generic set of issues to do with filehandle lookup
racing with dentry cache setup. They involve a filehandle lookup
occurring while an inode is being created and the filehandle lookup
racing with the dentry creation for the real file. This can lead to
multiple dentries for the one path being instantiated. There are a
host of other issues around this same set of paths.

The underlying cause is that file handle lookup only waits on inode
cache instantiation rather than full dentry cache instantiation. XFS
is mostly immune to the problems discovered due to it's own internal
inode cache, but there are a couple of corner cases where races can
happen.

We currently clear the XFS_INEW flag when the inode is fully set up
after insertion into the cache. Newly allocated inodes are inserted
locked and so aren't usable until the allocation transaction
commits. This, however, occurs before the dentry and security
information is fully initialised and hence the inode is unlocked and
available for lookups to find too early.

To solve the problem, only clear the XFS_INEW flag for newly created
inodes once the dentry is fully instantiated. This means lookups
will retry until the XFS_INEW flag is removed from the inode and
hence avoids the race conditions in questions.

THis also means that xfs_create(), xfs_create_tmpfile() and
xfs_symlink() need to finish the setup of the inode in their error
paths if we had allocated the inode but failed later in the creation
process. xfs_symlink(), in particular, needed a lot of help to make
it's error handling match that of xfs_create().

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit 58c904734cd0917cd0953067dd68003572407c7b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_iops.c
#	fs/xfs/xfs_symlink.c
diff --cc fs/xfs/xfs_iops.c
index 5d80201ac026,d7782ae1af3c..000000000000
--- a/fs/xfs/xfs_iops.c
+++ b/fs/xfs/xfs_iops.c
@@@ -172,22 -169,49 +172,50 @@@ xfs_vn_mknod
  	if (unlikely(error))
  		goto out_cleanup_inode;
  
 -#ifdef CONFIG_XFS_POSIX_ACL
  	if (default_acl) {
 -		error = xfs_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);
 -		if (error)
 -			goto out_cleanup_inode;
 -	}
 -	if (acl) {
 -		error = xfs_set_acl(inode, acl, ACL_TYPE_ACCESS);
 -		if (error)
 +		error = -xfs_inherit_acl(inode, default_acl);
 +		default_acl = NULL;
 +		if (unlikely(error))
  			goto out_cleanup_inode;
  	}
 -#endif
  
 -	if (tmpfile)
 -		d_tmpfile(dentry, inode);
 -	else
 -		d_instantiate(dentry, inode);
  
++<<<<<<< HEAD
 +	d_instantiate(dentry, inode);
 +	return -error;
 +
 + out_cleanup_inode:
 +	xfs_cleanup_inode(dir, inode, dentry);
 + out_free_acl:
 +	posix_acl_release(default_acl);
 +	return -error;
++=======
+ 	xfs_finish_inode_setup(ip);
+ 
+  out_free_acl:
+ 	if (default_acl)
+ 		posix_acl_release(default_acl);
+ 	if (acl)
+ 		posix_acl_release(acl);
+ 	return error;
+ 
+  out_cleanup_inode:
+ 	xfs_finish_inode_setup(ip);
+ 	if (!tmpfile)
+ 		xfs_cleanup_inode(dir, inode, dentry);
+ 	iput(inode);
+ 	goto out_free_acl;
+ }
+ 
+ STATIC int
+ xfs_vn_mknod(
+ 	struct inode	*dir,
+ 	struct dentry	*dentry,
+ 	umode_t		mode,
+ 	dev_t		rdev)
+ {
+ 	return xfs_generic_create(dir, dentry, mode, rdev, false);
++>>>>>>> 58c904734cd0 (xfs: inodes are new until the dentry cache is set up)
  }
  
  STATIC int
@@@ -349,9 -374,11 +378,10 @@@ xfs_vn_symlink
  	return 0;
  
   out_cleanup_inode:
+ 	xfs_finish_inode_setup(cip);
  	xfs_cleanup_inode(dir, inode, dentry);
 -	iput(inode);
   out:
 -	return error;
 +	return -error;
  }
  
  STATIC int
diff --cc fs/xfs/xfs_symlink.c
index 64967a095e37,3df411eadb86..000000000000
--- a/fs/xfs/xfs_symlink.c
+++ b/fs/xfs/xfs_symlink.c
@@@ -253,8 -251,8 +253,13 @@@ xfs_symlink
  	 * Check whether the directory allows new symlinks or not.
  	 */
  	if (dp->i_d.di_flags & XFS_DIFLAG_NOSYMLINKS) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(EPERM);
 +		goto error_return;
++=======
+ 		error = -EPERM;
+ 		goto out_trans_cancel;
++>>>>>>> 58c904734cd0 (xfs: inodes are new until the dentry cache is set up)
  	}
  
  	/*
@@@ -284,15 -282,14 +289,22 @@@
  	 */
  	error = xfs_dir_ialloc(&tp, dp, S_IFLNK | (mode & ~S_IFMT), 1, 0,
  			       prid, resblks > 0, &ip, NULL);
++<<<<<<< HEAD
 +	if (error) {
 +		if (error == ENOSPC)
 +			goto error_return;
 +		goto error1;
 +	}
++=======
+ 	if (error)
+ 		goto out_trans_cancel;
++>>>>>>> 58c904734cd0 (xfs: inodes are new until the dentry cache is set up)
  
  	/*
- 	 * An error after we've joined dp to the transaction will result in the
- 	 * transaction cancel unlocking dp so don't do it explicitly in the
+ 	 * Now we join the directory inode to the transaction.  We do not do it
+ 	 * earlier because xfs_dir_ialloc might commit the previous transaction
+ 	 * (and release all the locks).  An error from here on will result in
+ 	 * the transaction cancel unlocking dp so don't do it explicitly in the
  	 * error path.
  	 */
  	xfs_trans_ijoin(tp, dp, XFS_ILOCK_EXCL);
@@@ -349,8 -346,8 +361,13 @@@
  			bp = xfs_trans_get_buf(tp, mp->m_ddev_targp, d,
  					       BTOBB(byte_cnt), 0);
  			if (!bp) {
++<<<<<<< HEAD
 +				error = ENOMEM;
 +				goto error2;
++=======
+ 				error = -ENOMEM;
+ 				goto out_bmap_cancel;
++>>>>>>> 58c904734cd0 (xfs: inodes are new until the dentry cache is set up)
  			}
  			bp->b_ops = &xfs_symlink_buf_ops;
  
diff --git a/fs/xfs/xfs_icache.c b/fs/xfs/xfs_icache.c
index db41a6d1d14d..348db0b8eb46 100644
--- a/fs/xfs/xfs_icache.c
+++ b/fs/xfs/xfs_icache.c
@@ -441,11 +441,11 @@ again:
 	*ipp = ip;
 
 	/*
-	 * If we have a real type for an on-disk inode, we can set ops(&unlock)
+	 * If we have a real type for an on-disk inode, we can setup the inode
 	 * now.	 If it's a new inode being created, xfs_ialloc will handle it.
 	 */
 	if (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)
-		xfs_setup_inode(ip);
+		xfs_setup_existing_inode(ip);
 	return 0;
 
 out_error_or_again:
diff --git a/fs/xfs/xfs_inode.c b/fs/xfs/xfs_inode.c
index 096aa5cafd1b..8796cf9227ff 100644
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@ -839,7 +839,7 @@ xfs_ialloc(
 	xfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);
 	xfs_trans_log_inode(tp, ip, flags);
 
-	/* now that we have an i_mode we can setup inode ops and unlock */
+	/* now that we have an i_mode we can setup the inode structure */
 	xfs_setup_inode(ip);
 
 	/* now we have set up the vfs inode we can associate the filestream */
@@ -1315,12 +1315,14 @@ xfs_create(
 	xfs_trans_cancel(tp, cancel_flags);
  out_release_inode:
 	/*
-	 * Wait until after the current transaction is aborted to
-	 * release the inode.  This prevents recursive transactions
-	 * and deadlocks from xfs_inactive.
+	 * Wait until after the current transaction is aborted to finish the
+	 * setup of the inode and release the inode.  This prevents recursive
+	 * transactions and deadlocks from xfs_inactive.
 	 */
-	if (ip)
+	if (ip) {
+		xfs_finish_inode_setup(ip);
 		IRELE(ip);
+	}
 
 	xfs_qm_dqrele(udqp);
 	xfs_qm_dqrele(gdqp);
@@ -1425,12 +1427,14 @@ xfs_create_tmpfile(
 	xfs_trans_cancel(tp, cancel_flags);
  out_release_inode:
 	/*
-	 * Wait until after the current transaction is aborted to
-	 * release the inode.  This prevents recursive transactions
-	 * and deadlocks from xfs_inactive.
+	 * Wait until after the current transaction is aborted to finish the
+	 * setup of the inode and release the inode.  This prevents recursive
+	 * transactions and deadlocks from xfs_inactive.
 	 */
-	if (ip)
+	if (ip) {
+		xfs_finish_inode_setup(ip);
 		IRELE(ip);
+	}
 
 	xfs_qm_dqrele(udqp);
 	xfs_qm_dqrele(gdqp);
diff --git a/fs/xfs/xfs_inode.h b/fs/xfs/xfs_inode.h
index 85531c2ab2b9..08fa01af8006 100644
--- a/fs/xfs/xfs_inode.h
+++ b/fs/xfs/xfs_inode.h
@@ -386,6 +386,28 @@ int		xfs_zero_eof(struct xfs_inode *, xfs_off_t, xfs_fsize_t);
 int		xfs_iozero(struct xfs_inode *, loff_t, size_t);
 
 
+/* from xfs_iops.c */
+/*
+ * When setting up a newly allocated inode, we need to call
+ * xfs_finish_inode_setup() once the inode is fully instantiated at
+ * the VFS level to prevent the rest of the world seeing the inode
+ * before we've completed instantiation. Otherwise we can do it
+ * the moment the inode lookup is complete.
+ */
+extern void xfs_setup_inode(struct xfs_inode *ip);
+static inline void xfs_finish_inode_setup(struct xfs_inode *ip)
+{
+	xfs_iflags_clear(ip, XFS_INEW);
+	barrier();
+	unlock_new_inode(VFS_I(ip));
+}
+
+static inline void xfs_setup_existing_inode(struct xfs_inode *ip)
+{
+	xfs_setup_inode(ip);
+	xfs_finish_inode_setup(ip);
+}
+
 #define IHOLD(ip) \
 do { \
 	ASSERT(atomic_read(&VFS_I(ip)->i_count) > 0) ; \
* Unmerged path fs/xfs/xfs_iops.c
diff --git a/fs/xfs/xfs_iops.h b/fs/xfs/xfs_iops.h
index d2c5057b5cc4..afbe794d532d 100644
--- a/fs/xfs/xfs_iops.h
+++ b/fs/xfs/xfs_iops.h
@@ -25,8 +25,6 @@ extern const struct file_operations xfs_dir_file_operations;
 
 extern ssize_t xfs_vn_listxattr(struct dentry *, char *data, size_t size);
 
-extern void xfs_setup_inode(struct xfs_inode *);
-
 /*
  * Internal setattr interfaces.
  */
diff --git a/fs/xfs/xfs_qm.c b/fs/xfs/xfs_qm.c
index cf4f87e96c1f..dfec36001887 100644
--- a/fs/xfs/xfs_qm.c
+++ b/fs/xfs/xfs_qm.c
@@ -750,6 +750,7 @@ xfs_qm_qino_alloc(
 	xfs_trans_t	*tp;
 	int		error;
 	int		committed;
+	bool		need_alloc = true;
 
 	*ip = NULL;
 	/*
@@ -778,6 +779,7 @@ xfs_qm_qino_alloc(
 				return error;
 			mp->m_sb.sb_gquotino = NULLFSINO;
 			mp->m_sb.sb_pquotino = NULLFSINO;
+			need_alloc = false;
 		}
 	}
 
@@ -789,7 +791,7 @@ xfs_qm_qino_alloc(
 		return error;
 	}
 
-	if (!*ip) {
+	if (need_alloc) {
 		error = xfs_dir_ialloc(&tp, NULL, S_IFREG, 1, 0, 0, 1, ip,
 								&committed);
 		if (error) {
@@ -830,11 +832,14 @@ xfs_qm_qino_alloc(
 	spin_unlock(&mp->m_sb_lock);
 	xfs_mod_sb(tp, sbfields);
 
-	if ((error = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES))) {
+	error = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);
+	if (error) {
+		ASSERT(XFS_FORCED_SHUTDOWN(mp));
 		xfs_alert(mp, "%s failed (error %d)!", __func__, error);
-		return error;
 	}
-	return 0;
+	if (need_alloc)
+		xfs_finish_inode_setup(*ip);
+	return error;
 }
 
 
* Unmerged path fs/xfs/xfs_symlink.c
