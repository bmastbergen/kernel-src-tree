IB/mlx5: Avoid using the MAD_IFC command under ISSI > 0 mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [infiniband] mlx5: Avoid using the MAD_IFC command under ISSI > 0 mode (Amir Vadai) [1164527 1164530 1164531 1164536 1164537]
Rebuild_FUZZ: 97.44%
commit-author Majd Dibbiny <majd@mellanox.com>
commit 1b5daf11b015123108686a9060ee6de705a03e76
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/1b5daf11.failed

In ISSI > 0 mode, most of the MAD_IFC command features are deprecated, and can't
be used. Therefore, when in that mode, we replace all of them with other commands
that provide the required functionality.

	Signed-off-by: Majd Dibbiny <majd@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1b5daf11b015123108686a9060ee6de705a03e76)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/main.c
diff --cc drivers/infiniband/hw/mlx5/main.c
index bb7f718adc11,a117e27b424a..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -66,28 -207,24 +207,47 @@@ static int mlx5_ib_query_device(struct 
  				struct ib_device_attr *props)
  {
  	struct mlx5_ib_dev *dev = to_mdev(ibdev);
++<<<<<<< HEAD
 +	struct ib_smp *in_mad  = NULL;
 +	struct ib_smp *out_mad = NULL;
 +	struct mlx5_general_caps *gen;
++=======
+ 	struct mlx5_core_dev *mdev = dev->mdev;
++>>>>>>> 1b5daf11b015 (IB/mlx5: Avoid using the MAD_IFC command under ISSI > 0 mode)
  	int err = -ENOMEM;
  	int max_rq_sg;
  	int max_sq_sg;
 +	u64 flags;
  
++<<<<<<< HEAD
 +	gen = &dev->mdev->caps.gen;
 +	in_mad  = kzalloc(sizeof(*in_mad), GFP_KERNEL);
 +	out_mad = kmalloc(sizeof(*out_mad), GFP_KERNEL);
 +	if (!in_mad || !out_mad)
 +		goto out;
 +
 +	init_query_mad(in_mad);
 +	in_mad->attr_id = IB_SMP_ATTR_NODE_INFO;
 +
 +	err = mlx5_MAD_IFC(to_mdev(ibdev), 1, 1, 1, NULL, NULL, in_mad, out_mad);
 +	if (err)
 +		goto out;
 +
++=======
++>>>>>>> 1b5daf11b015 (IB/mlx5: Avoid using the MAD_IFC command under ISSI > 0 mode)
  	memset(props, 0, sizeof(*props));
+ 	err = mlx5_query_system_image_guid(ibdev,
+ 					   &props->sys_image_guid);
+ 	if (err)
+ 		return err;
+ 
+ 	err = mlx5_query_max_pkeys(ibdev, &props->max_pkeys);
+ 	if (err)
+ 		return err;
+ 
+ 	err = mlx5_query_vendor_id(ibdev, &props->vendor_id);
+ 	if (err)
+ 		return err;
  
  	props->fw_ver = ((u64)fw_rev_maj(dev->mdev) << 32) |
  		(fw_rev_min(dev->mdev) << 16) |
@@@ -116,41 -253,38 +276,43 @@@
  		props->sig_guard_cap = IB_GUARD_T10DIF_CRC |
  				       IB_GUARD_T10DIF_CSUM;
  	}
 -	if (MLX5_CAP_GEN(mdev, block_lb_mc))
 +	if (flags & MLX5_DEV_CAP_FLAG_BLOCK_MCAST)
  		props->device_cap_flags |= IB_DEVICE_BLOCK_MULTICAST_LOOPBACK;
  
- 	props->vendor_id	   = be32_to_cpup((__be32 *)(out_mad->data + 36)) &
- 		0xffffff;
- 	props->vendor_part_id	   = be16_to_cpup((__be16 *)(out_mad->data + 30));
- 	props->hw_ver		   = be32_to_cpup((__be32 *)(out_mad->data + 32));
- 	memcpy(&props->sys_image_guid, out_mad->data +	4, 8);
+ 	props->vendor_part_id	   = mdev->pdev->device;
+ 	props->hw_ver		   = mdev->pdev->revision;
  
  	props->max_mr_size	   = ~0ull;
 -	props->page_size_cap	   = 1ull << MLX5_CAP_GEN(mdev, log_pg_sz);
 -	props->max_qp		   = 1 << MLX5_CAP_GEN(mdev, log_max_qp);
 -	props->max_qp_wr	   = 1 << MLX5_CAP_GEN(mdev, log_max_qp_sz);
 -	max_rq_sg =  MLX5_CAP_GEN(mdev, max_wqe_sz_rq) /
 -		     sizeof(struct mlx5_wqe_data_seg);
 -	max_sq_sg = (MLX5_CAP_GEN(mdev, max_wqe_sz_sq) -
 -		     sizeof(struct mlx5_wqe_ctrl_seg)) /
 -		     sizeof(struct mlx5_wqe_data_seg);
 +	props->page_size_cap	   = gen->min_page_sz;
 +	props->max_qp		   = 1 << gen->log_max_qp;
 +	props->max_qp_wr	   = gen->max_wqes;
 +	max_rq_sg = gen->max_rq_desc_sz / sizeof(struct mlx5_wqe_data_seg);
 +	max_sq_sg = (gen->max_sq_desc_sz - sizeof(struct mlx5_wqe_ctrl_seg)) /
 +		sizeof(struct mlx5_wqe_data_seg);
  	props->max_sge = min(max_rq_sg, max_sq_sg);
 -	props->max_cq		   = 1 << MLX5_CAP_GEN(mdev, log_max_cq);
 -	props->max_cqe = (1 << MLX5_CAP_GEN(mdev, log_max_eq_sz)) - 1;
 -	props->max_mr		   = 1 << MLX5_CAP_GEN(mdev, log_max_mkey);
 -	props->max_pd		   = 1 << MLX5_CAP_GEN(mdev, log_max_pd);
 -	props->max_qp_rd_atom	   = 1 << MLX5_CAP_GEN(mdev, log_max_ra_req_qp);
 -	props->max_qp_init_rd_atom = 1 << MLX5_CAP_GEN(mdev, log_max_ra_res_qp);
 -	props->max_srq		   = 1 << MLX5_CAP_GEN(mdev, log_max_srq);
 -	props->max_srq_wr = (1 << MLX5_CAP_GEN(mdev, log_max_srq_sz)) - 1;
 -	props->local_ca_ack_delay  = MLX5_CAP_GEN(mdev, local_ca_ack_delay);
 +	props->max_cq		   = 1 << gen->log_max_cq;
 +	props->max_cqe		   = gen->max_cqes - 1;
 +	props->max_mr		   = 1 << gen->log_max_mkey;
 +	props->max_pd		   = 1 << gen->log_max_pd;
 +	props->max_qp_rd_atom	   = 1 << gen->log_max_ra_req_qp;
 +	props->max_qp_init_rd_atom = 1 << gen->log_max_ra_res_qp;
 +	props->max_srq		   = 1 << gen->log_max_srq;
 +	props->max_srq_wr	   = gen->max_srq_wqes - 1;
 +	props->local_ca_ack_delay  = gen->local_ca_ack_delay;
  	props->max_res_rd_atom	   = props->max_qp_rd_atom * props->max_qp;
  	props->max_srq_sge	   = max_rq_sg - 1;
  	props->max_fast_reg_page_list_len = (unsigned int)-1;
 +	props->local_ca_ack_delay  = gen->local_ca_ack_delay;
  	props->atomic_cap	   = IB_ATOMIC_NONE;
  	props->masked_atomic_cap   = IB_ATOMIC_NONE;
++<<<<<<< HEAD
 +	props->max_pkeys	   = be16_to_cpup((__be16 *)(out_mad->data + 28));
 +	props->max_mcast_grp	   = 1 << gen->log_max_mcg;
 +	props->max_mcast_qp_attach = gen->max_qp_mcg;
++=======
+ 	props->max_mcast_grp	   = 1 << MLX5_CAP_GEN(mdev, log_max_mcg);
+ 	props->max_mcast_qp_attach = MLX5_CAP_GEN(mdev, max_qp_mcg);
++>>>>>>> 1b5daf11b015 (IB/mlx5: Avoid using the MAD_IFC command under ISSI > 0 mode)
  	props->max_total_mcast_qp_attach = props->max_mcast_qp_attach *
  					   props->max_mcast_grp;
  	props->max_map_per_fmr = INT_MAX; /* no limit in ConnectIB */
@@@ -171,95 -472,16 +500,108 @@@ out
  int mlx5_ib_query_port(struct ib_device *ibdev, u8 port,
  		       struct ib_port_attr *props)
  {
++<<<<<<< HEAD
 +	struct mlx5_ib_dev *dev = to_mdev(ibdev);
 +	struct ib_smp *in_mad  = NULL;
 +	struct ib_smp *out_mad = NULL;
 +	struct mlx5_general_caps *gen;
 +	int ext_active_speed;
 +	int err = -ENOMEM;
 +
 +	gen = &dev->mdev->caps.gen;
 +	if (port < 1 || port > gen->num_ports) {
 +		mlx5_ib_warn(dev, "invalid port number %d\n", port);
 +		return -EINVAL;
 +	}
 +
 +	in_mad  = kzalloc(sizeof(*in_mad), GFP_KERNEL);
 +	out_mad = kmalloc(sizeof(*out_mad), GFP_KERNEL);
 +	if (!in_mad || !out_mad)
 +		goto out;
 +
 +	memset(props, 0, sizeof(*props));
 +
 +	init_query_mad(in_mad);
 +	in_mad->attr_id  = IB_SMP_ATTR_PORT_INFO;
 +	in_mad->attr_mod = cpu_to_be32(port);
 +
 +	err = mlx5_MAD_IFC(dev, 1, 1, port, NULL, NULL, in_mad, out_mad);
 +	if (err) {
 +		mlx5_ib_warn(dev, "err %d\n", err);
 +		goto out;
 +	}
 +
 +
 +	props->lid		= be16_to_cpup((__be16 *)(out_mad->data + 16));
 +	props->lmc		= out_mad->data[34] & 0x7;
 +	props->sm_lid		= be16_to_cpup((__be16 *)(out_mad->data + 18));
 +	props->sm_sl		= out_mad->data[36] & 0xf;
 +	props->state		= out_mad->data[32] & 0xf;
 +	props->phys_state	= out_mad->data[33] >> 4;
 +	props->port_cap_flags	= be32_to_cpup((__be32 *)(out_mad->data + 20));
 +	props->gid_tbl_len	= out_mad->data[50];
 +	props->max_msg_sz	= 1 << gen->log_max_msg;
 +	props->pkey_tbl_len	= gen->port[port - 1].pkey_table_len;
 +	props->bad_pkey_cntr	= be16_to_cpup((__be16 *)(out_mad->data + 46));
 +	props->qkey_viol_cntr	= be16_to_cpup((__be16 *)(out_mad->data + 48));
 +	props->active_width	= out_mad->data[31] & 0xf;
 +	props->active_speed	= out_mad->data[35] >> 4;
 +	props->max_mtu		= out_mad->data[41] & 0xf;
 +	props->active_mtu	= out_mad->data[36] >> 4;
 +	props->subnet_timeout	= out_mad->data[51] & 0x1f;
 +	props->max_vl_num	= out_mad->data[37] >> 4;
 +	props->init_type_reply	= out_mad->data[41] >> 4;
 +
 +	/* Check if extended speeds (EDR/FDR/...) are supported */
 +	if (props->port_cap_flags & IB_PORT_EXTENDED_SPEEDS_SUP) {
 +		ext_active_speed = out_mad->data[62] >> 4;
 +
 +		switch (ext_active_speed) {
 +		case 1:
 +			props->active_speed = 16; /* FDR */
 +			break;
 +		case 2:
 +			props->active_speed = 32; /* EDR */
 +			break;
 +		}
 +	}
 +
 +	/* If reported active speed is QDR, check if is FDR-10 */
 +	if (props->active_speed == 4) {
 +		if (gen->ext_port_cap[port - 1] &
 +		    MLX_EXT_PORT_CAP_FLAG_EXTENDED_PORT_INFO) {
 +			init_query_mad(in_mad);
 +			in_mad->attr_id = MLX5_ATTR_EXTENDED_PORT_INFO;
 +			in_mad->attr_mod = cpu_to_be32(port);
 +
 +			err = mlx5_MAD_IFC(dev, 1, 1, port,
 +					   NULL, NULL, in_mad, out_mad);
 +			if (err)
 +				goto out;
 +
 +			/* Checking LinkSpeedActive for FDR-10 */
 +			if (out_mad->data[15] & 0x1)
 +				props->active_speed = 8;
 +		}
 +	}
 +
 +out:
 +	kfree(in_mad);
 +	kfree(out_mad);
 +
 +	return err;
++=======
+ 	switch (mlx5_get_vport_access_method(ibdev)) {
+ 	case MLX5_VPORT_ACCESS_METHOD_MAD:
+ 		return mlx5_query_mad_ifc_port(ibdev, port, props);
+ 
+ 	case MLX5_VPORT_ACCESS_METHOD_HCA:
+ 		return mlx5_query_hca_port(ibdev, port, props);
+ 
+ 	default:
+ 		return -EINVAL;
+ 	}
++>>>>>>> 1b5daf11b015 (IB/mlx5: Avoid using the MAD_IFC command under ISSI > 0 mode)
  }
  
  static int mlx5_ib_query_gid(struct ib_device *ibdev, u8 port, int index,
diff --git a/drivers/infiniband/hw/mlx5/mad.c b/drivers/infiniband/hw/mlx5/mad.c
index 8e45714fa369..8e82504a8f6a 100644
--- a/drivers/infiniband/hw/mlx5/mad.c
+++ b/drivers/infiniband/hw/mlx5/mad.c
@@ -144,3 +144,300 @@ out:
 	kfree(out_mad);
 	return err;
 }
+
+int mlx5_query_mad_ifc_smp_attr_node_info(struct ib_device *ibdev,
+					  struct ib_smp *out_mad)
+{
+	struct ib_smp *in_mad = NULL;
+	int err = -ENOMEM;
+
+	in_mad = kzalloc(sizeof(*in_mad), GFP_KERNEL);
+	if (!in_mad)
+		return -ENOMEM;
+
+	init_query_mad(in_mad);
+	in_mad->attr_id = IB_SMP_ATTR_NODE_INFO;
+
+	err = mlx5_MAD_IFC(to_mdev(ibdev), 1, 1, 1, NULL, NULL, in_mad,
+			   out_mad);
+
+	kfree(in_mad);
+	return err;
+}
+
+int mlx5_query_mad_ifc_system_image_guid(struct ib_device *ibdev,
+					 __be64 *sys_image_guid)
+{
+	struct ib_smp *out_mad = NULL;
+	int err = -ENOMEM;
+
+	out_mad = kmalloc(sizeof(*out_mad), GFP_KERNEL);
+	if (!out_mad)
+		return -ENOMEM;
+
+	err = mlx5_query_mad_ifc_smp_attr_node_info(ibdev, out_mad);
+	if (err)
+		goto out;
+
+	memcpy(sys_image_guid, out_mad->data + 4, 8);
+
+out:
+	kfree(out_mad);
+
+	return err;
+}
+
+int mlx5_query_mad_ifc_max_pkeys(struct ib_device *ibdev,
+				 u16 *max_pkeys)
+{
+	struct ib_smp *out_mad = NULL;
+	int err = -ENOMEM;
+
+	out_mad = kmalloc(sizeof(*out_mad), GFP_KERNEL);
+	if (!out_mad)
+		return -ENOMEM;
+
+	err = mlx5_query_mad_ifc_smp_attr_node_info(ibdev, out_mad);
+	if (err)
+		goto out;
+
+	*max_pkeys = be16_to_cpup((__be16 *)(out_mad->data + 28));
+
+out:
+	kfree(out_mad);
+
+	return err;
+}
+
+int mlx5_query_mad_ifc_vendor_id(struct ib_device *ibdev,
+				 u32 *vendor_id)
+{
+	struct ib_smp *out_mad = NULL;
+	int err = -ENOMEM;
+
+	out_mad = kmalloc(sizeof(*out_mad), GFP_KERNEL);
+	if (!out_mad)
+		return -ENOMEM;
+
+	err = mlx5_query_mad_ifc_smp_attr_node_info(ibdev, out_mad);
+	if (err)
+		goto out;
+
+	*vendor_id = be32_to_cpup((__be32 *)(out_mad->data + 36)) & 0xffff;
+
+out:
+	kfree(out_mad);
+
+	return err;
+}
+
+int mlx5_query_mad_ifc_node_desc(struct mlx5_ib_dev *dev, char *node_desc)
+{
+	struct ib_smp *in_mad  = NULL;
+	struct ib_smp *out_mad = NULL;
+	int err = -ENOMEM;
+
+	in_mad  = kzalloc(sizeof(*in_mad), GFP_KERNEL);
+	out_mad = kmalloc(sizeof(*out_mad), GFP_KERNEL);
+	if (!in_mad || !out_mad)
+		goto out;
+
+	init_query_mad(in_mad);
+	in_mad->attr_id = IB_SMP_ATTR_NODE_DESC;
+
+	err = mlx5_MAD_IFC(dev, 1, 1, 1, NULL, NULL, in_mad, out_mad);
+	if (err)
+		goto out;
+
+	memcpy(node_desc, out_mad->data, 64);
+out:
+	kfree(in_mad);
+	kfree(out_mad);
+	return err;
+}
+
+int mlx5_query_mad_ifc_node_guid(struct mlx5_ib_dev *dev, __be64 *node_guid)
+{
+	struct ib_smp *in_mad  = NULL;
+	struct ib_smp *out_mad = NULL;
+	int err = -ENOMEM;
+
+	in_mad  = kzalloc(sizeof(*in_mad), GFP_KERNEL);
+	out_mad = kmalloc(sizeof(*out_mad), GFP_KERNEL);
+	if (!in_mad || !out_mad)
+		goto out;
+
+	init_query_mad(in_mad);
+	in_mad->attr_id = IB_SMP_ATTR_NODE_INFO;
+
+	err = mlx5_MAD_IFC(dev, 1, 1, 1, NULL, NULL, in_mad, out_mad);
+	if (err)
+		goto out;
+
+	memcpy(node_guid, out_mad->data + 12, 8);
+out:
+	kfree(in_mad);
+	kfree(out_mad);
+	return err;
+}
+
+int mlx5_query_mad_ifc_pkey(struct ib_device *ibdev, u8 port, u16 index,
+			    u16 *pkey)
+{
+	struct ib_smp *in_mad  = NULL;
+	struct ib_smp *out_mad = NULL;
+	int err = -ENOMEM;
+
+	in_mad  = kzalloc(sizeof(*in_mad), GFP_KERNEL);
+	out_mad = kmalloc(sizeof(*out_mad), GFP_KERNEL);
+	if (!in_mad || !out_mad)
+		goto out;
+
+	init_query_mad(in_mad);
+	in_mad->attr_id  = IB_SMP_ATTR_PKEY_TABLE;
+	in_mad->attr_mod = cpu_to_be32(index / 32);
+
+	err = mlx5_MAD_IFC(to_mdev(ibdev), 1, 1, port, NULL, NULL, in_mad,
+			   out_mad);
+	if (err)
+		goto out;
+
+	*pkey = be16_to_cpu(((__be16 *)out_mad->data)[index % 32]);
+
+out:
+	kfree(in_mad);
+	kfree(out_mad);
+	return err;
+}
+
+int mlx5_query_mad_ifc_gids(struct ib_device *ibdev, u8 port, int index,
+			    union ib_gid *gid)
+{
+	struct ib_smp *in_mad  = NULL;
+	struct ib_smp *out_mad = NULL;
+	int err = -ENOMEM;
+
+	in_mad  = kzalloc(sizeof(*in_mad), GFP_KERNEL);
+	out_mad = kmalloc(sizeof(*out_mad), GFP_KERNEL);
+	if (!in_mad || !out_mad)
+		goto out;
+
+	init_query_mad(in_mad);
+	in_mad->attr_id  = IB_SMP_ATTR_PORT_INFO;
+	in_mad->attr_mod = cpu_to_be32(port);
+
+	err = mlx5_MAD_IFC(to_mdev(ibdev), 1, 1, port, NULL, NULL, in_mad,
+			   out_mad);
+	if (err)
+		goto out;
+
+	memcpy(gid->raw, out_mad->data + 8, 8);
+
+	init_query_mad(in_mad);
+	in_mad->attr_id  = IB_SMP_ATTR_GUID_INFO;
+	in_mad->attr_mod = cpu_to_be32(index / 8);
+
+	err = mlx5_MAD_IFC(to_mdev(ibdev), 1, 1, port, NULL, NULL, in_mad,
+			   out_mad);
+	if (err)
+		goto out;
+
+	memcpy(gid->raw + 8, out_mad->data + (index % 8) * 8, 8);
+
+out:
+	kfree(in_mad);
+	kfree(out_mad);
+	return err;
+}
+
+int mlx5_query_mad_ifc_port(struct ib_device *ibdev, u8 port,
+			    struct ib_port_attr *props)
+{
+	struct mlx5_ib_dev *dev = to_mdev(ibdev);
+	struct mlx5_core_dev *mdev = dev->mdev;
+	struct ib_smp *in_mad  = NULL;
+	struct ib_smp *out_mad = NULL;
+	int ext_active_speed;
+	int err = -ENOMEM;
+
+	if (port < 1 || port > MLX5_CAP_GEN(mdev, num_ports)) {
+		mlx5_ib_warn(dev, "invalid port number %d\n", port);
+		return -EINVAL;
+	}
+
+	in_mad  = kzalloc(sizeof(*in_mad), GFP_KERNEL);
+	out_mad = kmalloc(sizeof(*out_mad), GFP_KERNEL);
+	if (!in_mad || !out_mad)
+		goto out;
+
+	memset(props, 0, sizeof(*props));
+
+	init_query_mad(in_mad);
+	in_mad->attr_id  = IB_SMP_ATTR_PORT_INFO;
+	in_mad->attr_mod = cpu_to_be32(port);
+
+	err = mlx5_MAD_IFC(dev, 1, 1, port, NULL, NULL, in_mad, out_mad);
+	if (err) {
+		mlx5_ib_warn(dev, "err %d\n", err);
+		goto out;
+	}
+
+	props->lid		= be16_to_cpup((__be16 *)(out_mad->data + 16));
+	props->lmc		= out_mad->data[34] & 0x7;
+	props->sm_lid		= be16_to_cpup((__be16 *)(out_mad->data + 18));
+	props->sm_sl		= out_mad->data[36] & 0xf;
+	props->state		= out_mad->data[32] & 0xf;
+	props->phys_state	= out_mad->data[33] >> 4;
+	props->port_cap_flags	= be32_to_cpup((__be32 *)(out_mad->data + 20));
+	props->gid_tbl_len	= out_mad->data[50];
+	props->max_msg_sz	= 1 << MLX5_CAP_GEN(mdev, log_max_msg);
+	props->pkey_tbl_len	= mdev->port_caps[port - 1].pkey_table_len;
+	props->bad_pkey_cntr	= be16_to_cpup((__be16 *)(out_mad->data + 46));
+	props->qkey_viol_cntr	= be16_to_cpup((__be16 *)(out_mad->data + 48));
+	props->active_width	= out_mad->data[31] & 0xf;
+	props->active_speed	= out_mad->data[35] >> 4;
+	props->max_mtu		= out_mad->data[41] & 0xf;
+	props->active_mtu	= out_mad->data[36] >> 4;
+	props->subnet_timeout	= out_mad->data[51] & 0x1f;
+	props->max_vl_num	= out_mad->data[37] >> 4;
+	props->init_type_reply	= out_mad->data[41] >> 4;
+
+	/* Check if extended speeds (EDR/FDR/...) are supported */
+	if (props->port_cap_flags & IB_PORT_EXTENDED_SPEEDS_SUP) {
+		ext_active_speed = out_mad->data[62] >> 4;
+
+		switch (ext_active_speed) {
+		case 1:
+			props->active_speed = 16; /* FDR */
+			break;
+		case 2:
+			props->active_speed = 32; /* EDR */
+			break;
+		}
+	}
+
+	/* If reported active speed is QDR, check if is FDR-10 */
+	if (props->active_speed == 4) {
+		if (mdev->port_caps[port - 1].ext_port_cap &
+		    MLX_EXT_PORT_CAP_FLAG_EXTENDED_PORT_INFO) {
+			init_query_mad(in_mad);
+			in_mad->attr_id = MLX5_ATTR_EXTENDED_PORT_INFO;
+			in_mad->attr_mod = cpu_to_be32(port);
+
+			err = mlx5_MAD_IFC(dev, 1, 1, port,
+					   NULL, NULL, in_mad, out_mad);
+			if (err)
+				goto out;
+
+			/* Checking LinkSpeedActive for FDR-10 */
+			if (out_mad->data[15] & 0x1)
+				props->active_speed = 8;
+		}
+	}
+
+out:
+	kfree(in_mad);
+	kfree(out_mad);
+
+	return err;
+}
* Unmerged path drivers/infiniband/hw/mlx5/main.c
diff --git a/drivers/infiniband/hw/mlx5/mlx5_ib.h b/drivers/infiniband/hw/mlx5/mlx5_ib.h
index 1013944d3180..f5a3fc36b814 100644
--- a/drivers/infiniband/hw/mlx5/mlx5_ib.h
+++ b/drivers/infiniband/hw/mlx5/mlx5_ib.h
@@ -596,6 +596,22 @@ struct ib_xrcd *mlx5_ib_alloc_xrcd(struct ib_device *ibdev,
 int mlx5_ib_dealloc_xrcd(struct ib_xrcd *xrcd);
 int mlx5_ib_get_buf_offset(u64 addr, int page_shift, u32 *offset);
 int mlx5_query_ext_port_caps(struct mlx5_ib_dev *dev, u8 port);
+int mlx5_query_mad_ifc_smp_attr_node_info(struct ib_device *ibdev,
+					  struct ib_smp *out_mad);
+int mlx5_query_mad_ifc_system_image_guid(struct ib_device *ibdev,
+					 __be64 *sys_image_guid);
+int mlx5_query_mad_ifc_max_pkeys(struct ib_device *ibdev,
+				 u16 *max_pkeys);
+int mlx5_query_mad_ifc_vendor_id(struct ib_device *ibdev,
+				 u32 *vendor_id);
+int mlx5_query_mad_ifc_node_desc(struct mlx5_ib_dev *dev, char *node_desc);
+int mlx5_query_mad_ifc_node_guid(struct mlx5_ib_dev *dev, __be64 *node_guid);
+int mlx5_query_mad_ifc_pkey(struct ib_device *ibdev, u8 port, u16 index,
+			    u16 *pkey);
+int mlx5_query_mad_ifc_gids(struct ib_device *ibdev, u8 port, int index,
+			    union ib_gid *gid);
+int mlx5_query_mad_ifc_port(struct ib_device *ibdev, u8 port,
+			    struct ib_port_attr *props);
 int mlx5_ib_query_port(struct ib_device *ibdev, u8 port,
 		       struct ib_port_attr *props);
 int mlx5_ib_init_fmr(struct mlx5_ib_dev *dev);
