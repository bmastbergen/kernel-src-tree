tcp: tcp_v[46]_conn_request: fix snt_synack initialization

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Octavian Purdila <octavian.purdila@intel.com>
commit aa27fc501850030fb5d1ee705feb836ee6a21f2a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/aa27fc50.failed

Commit 016818d07 (tcp: TCP Fast Open Server - take SYNACK RTT after
completing 3WHS) changes the code to only take a snt_synack timestamp
when a SYNACK transmit or retransmit succeeds. This behaviour is later
broken by commit 843f4a55e (tcp: use tcp_v4_send_synack on first
SYN-ACK), as snt_synack is now updated even if tcp_v4_send_synack
fails.

Also, commit 3a19ce0ee (tcp: IPv6 support for fastopen server) misses
the required IPv6 updates for 016818d07.

This patch makes sure that snt_synack is updated only when the SYNACK
trasnmit/retransmit succeeds, for both IPv4 and IPv6.

	Cc: Cardwell <ncardwell@google.com>
	Cc: Daniel Lee <longinus00@gmail.com>
	Cc: Yuchung Cheng <ycheng@google.com>

	Signed-off-by: Octavian Purdila <octavian.purdila@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit aa27fc501850030fb5d1ee705feb836ee6a21f2a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_ipv4.c
#	net/ipv6/tcp_ipv6.c
diff --cc net/ipv4/tcp_ipv4.c
index 7c1eb4426934,145f6402c560..000000000000
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@@ -1549,52 -1366,22 +1549,61 @@@ int tcp_v4_conn_request(struct sock *sk
  
  		isn = tcp_v4_init_sequence(skb);
  	}
 -	if (!dst && (dst = inet_csk_route_req(sk, &fl4, req)) == NULL)
 +	tcp_rsk(req)->snt_isn = isn;
 +
 +	if (dst == NULL) {
 +		dst = inet_csk_route_req(sk, &fl4, req);
 +		if (dst == NULL)
 +			goto drop_and_free;
 +	}
 +	do_fastopen = tcp_fastopen_check(sk, skb, req, &foc, &valid_foc);
 +
 +	/* We don't call tcp_v4_send_synack() directly because we need
 +	 * to make sure a child socket can be created successfully before
 +	 * sending back synack!
 +	 *
 +	 * XXX (TFO) - Ideally one would simply call tcp_v4_send_synack()
 +	 * (or better yet, call tcp_send_synack() in the child context
 +	 * directly, but will have to fix bunch of other code first)
 +	 * after syn_recv_sock() except one will need to first fix the
 +	 * latter to remove its dependency on the current implementation
 +	 * of tcp_v4_send_synack()->tcp_select_initial_window().
 +	 */
 +	skb_synack = tcp_make_synack(sk, dst, req,
 +	    fastopen_cookie_present(&valid_foc) ? &valid_foc : NULL);
 +
 +	if (skb_synack) {
 +		__tcp_v4_send_check(skb_synack, ireq->ir_loc_addr, ireq->ir_rmt_addr);
 +		skb_set_queue_mapping(skb_synack, skb_get_queue_mapping(skb));
 +	} else
  		goto drop_and_free;
  
++<<<<<<< HEAD
 +	if (likely(!do_fastopen)) {
 +		int err;
 +		err = ip_build_and_send_pkt(skb_synack, sk, ireq->ir_loc_addr,
 +		     ireq->ir_rmt_addr, ireq->opt);
 +		err = net_xmit_eval(err);
++=======
+ 	tcp_rsk(req)->snt_isn = isn;
+ 	tcp_openreq_init_rwin(req, sk, dst);
+ 	fastopen = !want_cookie &&
+ 		   tcp_try_fastopen(sk, skb, req, &foc, dst);
+ 	err = tcp_v4_send_synack(sk, dst, req,
+ 				 skb_get_queue_mapping(skb), &foc);
+ 	if (!fastopen) {
++>>>>>>> aa27fc501850 (tcp: tcp_v[46]_conn_request: fix snt_synack initialization)
  		if (err || want_cookie)
  			goto drop_and_free;
  
- 		tcp_rsk(req)->snt_synack = tcp_time_stamp;
  		tcp_rsk(req)->listener = NULL;
 +		/* Add the request_sock to the SYN table */
  		inet_csk_reqsk_queue_hash_add(sk, req, TCP_TIMEOUT_INIT);
 -	}
 +		if (fastopen_cookie_present(&foc) && foc.len != 0)
 +			NET_INC_STATS_BH(sock_net(sk),
 +			    LINUX_MIB_TCPFASTOPENPASSIVEFAIL);
 +	} else if (tcp_v4_conn_req_fastopen(sk, skb, skb_synack, req))
 +		goto drop_and_free;
  
  	return 0;
  
diff --cc net/ipv6/tcp_ipv6.c
index fdc8f8ca98c1,a962455471ba..000000000000
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@@ -1086,14 -1098,22 +1088,30 @@@ have_isn
  	if (security_inet_conn_request(sk, skb, req))
  		goto drop_and_release;
  
 -	if (!dst && (dst = inet6_csk_route_req(sk, &fl6, req)) == NULL)
 +	if (tcp_v6_send_synack(sk, dst, &fl6, req,
 +			       skb_get_queue_mapping(skb)) ||
 +	    want_cookie)
  		goto drop_and_free;
  
++<<<<<<< HEAD
 +	tcp_rsk(req)->snt_synack = tcp_time_stamp;
 +	tcp_rsk(req)->listener = NULL;
 +	inet6_csk_reqsk_queue_hash_add(sk, req, TCP_TIMEOUT_INIT);
++=======
+ 	tcp_rsk(req)->snt_isn = isn;
+ 	tcp_openreq_init_rwin(req, sk, dst);
+ 	fastopen = !want_cookie &&
+ 		   tcp_try_fastopen(sk, skb, req, &foc, dst);
+ 	err = tcp_v6_send_synack(sk, dst, &fl6, req,
+ 				 skb_get_queue_mapping(skb), &foc);
+ 	if (!fastopen) {
+ 		if (err || want_cookie)
+ 			goto drop_and_free;
+ 
+ 		tcp_rsk(req)->listener = NULL;
+ 		inet6_csk_reqsk_queue_hash_add(sk, req, TCP_TIMEOUT_INIT);
+ 	}
++>>>>>>> aa27fc501850 (tcp: tcp_v[46]_conn_request: fix snt_synack initialization)
  	return 0;
  
  drop_and_release:
* Unmerged path net/ipv4/tcp_ipv4.c
* Unmerged path net/ipv6/tcp_ipv6.c
