cxgb4: Force uninitialized state if FW in adapter is unsupported

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Hariprasad Shenai <hariprasad@chelsio.com>
commit a69265e9f65a6747c27b01b4030ad85d71aa11ba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/a69265e9.failed

Forcing uninitialized state allows us to upgrade and reinitialize
the adapter.

    FW_VERSION_T4 = 1.4.0.0
    FW_VERSION_T5 = 0.0.0.0
    FW_VERSION_T6 = 0.0.0.0
At this point driver supports above and greater than above version.

If FW in adapter < min FW_VERSION driver supports tries to upgrade the FW
If FW in adapter >= FW_VERSION driver supports then it follows normal path

	Signed-off-by: Hariprasad Shenai <hariprasad@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a69265e9f65a6747c27b01b4030ad85d71aa11ba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
#	drivers/net/ethernet/mellanox/mlx5/core/vport.h
diff --cc drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
index 4234b8c917e7,44806253c178..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
@@@ -36,7 -35,9 +36,8 @@@
  #include <linux/delay.h>
  #include "cxgb4.h"
  #include "t4_regs.h"
 -#include "t4_values.h"
  #include "t4fw_api.h"
+ #include "t4fw_version.h"
  
  /**
   *	t4_wait_op_done_val - wait until an operation is completed
@@@ -984,6 -2130,98 +985,101 @@@ int t4_get_tp_version(struct adapter *a
  			     1, vers, 0);
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  *	t4_get_exprom_version - return the Expansion ROM version (if any)
+  *	@adapter: the adapter
+  *	@vers: where to place the version
+  *
+  *	Reads the Expansion ROM header from FLASH and returns the version
+  *	number (if present) through the @vers return value pointer.  We return
+  *	this in the Firmware Version Format since it's convenient.  Return
+  *	0 on success, -ENOENT if no Expansion ROM is present.
+  */
+ int t4_get_exprom_version(struct adapter *adap, u32 *vers)
+ {
+ 	struct exprom_header {
+ 		unsigned char hdr_arr[16];	/* must start with 0x55aa */
+ 		unsigned char hdr_ver[4];	/* Expansion ROM version */
+ 	} *hdr;
+ 	u32 exprom_header_buf[DIV_ROUND_UP(sizeof(struct exprom_header),
+ 					   sizeof(u32))];
+ 	int ret;
+ 
+ 	ret = t4_read_flash(adap, FLASH_EXP_ROM_START,
+ 			    ARRAY_SIZE(exprom_header_buf), exprom_header_buf,
+ 			    0);
+ 	if (ret)
+ 		return ret;
+ 
+ 	hdr = (struct exprom_header *)exprom_header_buf;
+ 	if (hdr->hdr_arr[0] != 0x55 || hdr->hdr_arr[1] != 0xaa)
+ 		return -ENOENT;
+ 
+ 	*vers = (FW_HDR_FW_VER_MAJOR_V(hdr->hdr_ver[0]) |
+ 		 FW_HDR_FW_VER_MINOR_V(hdr->hdr_ver[1]) |
+ 		 FW_HDR_FW_VER_MICRO_V(hdr->hdr_ver[2]) |
+ 		 FW_HDR_FW_VER_BUILD_V(hdr->hdr_ver[3]));
+ 	return 0;
+ }
+ 
+ /**
+  *	t4_check_fw_version - check if the FW is supported with this driver
+  *	@adap: the adapter
+  *
+  *	Checks if an adapter's FW is compatible with the driver.  Returns 0
+  *	if there's exact match, a negative error if the version could not be
+  *	read or there's a major version mismatch
+  */
+ int t4_check_fw_version(struct adapter *adap)
+ {
+ 	int ret, major, minor, micro;
+ 	int exp_major, exp_minor, exp_micro;
+ 	unsigned int chip_version = CHELSIO_CHIP_VERSION(adap->params.chip);
+ 
+ 	ret = t4_get_fw_version(adap, &adap->params.fw_vers);
+ 	if (ret)
+ 		return ret;
+ 
+ 	major = FW_HDR_FW_VER_MAJOR_G(adap->params.fw_vers);
+ 	minor = FW_HDR_FW_VER_MINOR_G(adap->params.fw_vers);
+ 	micro = FW_HDR_FW_VER_MICRO_G(adap->params.fw_vers);
+ 
+ 	switch (chip_version) {
+ 	case CHELSIO_T4:
+ 		exp_major = T4FW_MIN_VERSION_MAJOR;
+ 		exp_minor = T4FW_MIN_VERSION_MINOR;
+ 		exp_micro = T4FW_MIN_VERSION_MICRO;
+ 		break;
+ 	case CHELSIO_T5:
+ 		exp_major = T5FW_MIN_VERSION_MAJOR;
+ 		exp_minor = T5FW_MIN_VERSION_MINOR;
+ 		exp_micro = T5FW_MIN_VERSION_MICRO;
+ 		break;
+ 	case CHELSIO_T6:
+ 		exp_major = T6FW_MIN_VERSION_MAJOR;
+ 		exp_minor = T6FW_MIN_VERSION_MINOR;
+ 		exp_micro = T6FW_MIN_VERSION_MICRO;
+ 		break;
+ 	default:
+ 		dev_err(adap->pdev_dev, "Unsupported chip type, %x\n",
+ 			adap->chip);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (major < exp_major || (major == exp_major && minor < exp_minor) ||
+ 	    (major == exp_major && minor == exp_minor && micro < exp_micro)) {
+ 		dev_err(adap->pdev_dev,
+ 			"Card has firmware version %u.%u.%u, minimum "
+ 			"supported firmware is %u.%u.%u.\n", major, minor,
+ 			micro, exp_major, exp_minor, exp_micro);
+ 		return -EFAULT;
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> a69265e9f65a (cxgb4: Force uninitialized state if FW in adapter is unsupported)
  /* Is the given firmware API compatible with the one the driver was compiled
   * with?
   */
diff --cc drivers/net/ethernet/mellanox/mlx5/core/vport.h
index c05ca2c3419d,92bafa793de6..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/vport.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/vport.h
@@@ -30,12 -32,33 +30,37 @@@
   * SOFTWARE.
   */
  
 -#ifndef __T4FW_VERSION_H__
 -#define __T4FW_VERSION_H__
 +#ifndef __MLX5_VPORT_H__
 +#define __MLX5_VPORT_H__
 +
 +#include <linux/mlx5/driver.h>
  
 -#define T4FW_VERSION_MAJOR 0x01
 -#define T4FW_VERSION_MINOR 0x0D
 -#define T4FW_VERSION_MICRO 0x20
 -#define T4FW_VERSION_BUILD 0x00
++<<<<<<< HEAD:drivers/net/ethernet/mellanox/mlx5/core/vport.h
 +u8 mlx5_query_vport_state(struct mlx5_core_dev *mdev, u8 opmod);
 +void mlx5_query_vport_mac_address(struct mlx5_core_dev *mdev, u8 *addr);
  
 +#endif /* __MLX5_VPORT_H__ */
++=======
+ #define T4FW_MIN_VERSION_MAJOR 0x01
+ #define T4FW_MIN_VERSION_MINOR 0x04
+ #define T4FW_MIN_VERSION_MICRO 0x00
+ 
+ #define T5FW_VERSION_MAJOR 0x01
+ #define T5FW_VERSION_MINOR 0x0D
+ #define T5FW_VERSION_MICRO 0x20
+ #define T5FW_VERSION_BUILD 0x00
+ 
+ #define T5FW_MIN_VERSION_MAJOR 0x00
+ #define T5FW_MIN_VERSION_MINOR 0x00
+ #define T5FW_MIN_VERSION_MICRO 0x00
+ 
+ #define T6FW_VERSION_MAJOR 0x01
+ #define T6FW_VERSION_MINOR 0x0D
+ #define T6FW_VERSION_MICRO 0x2D
+ #define T6FW_VERSION_BUILD 0x00
+ 
+ #define T6FW_MIN_VERSION_MAJOR 0x00
+ #define T6FW_MIN_VERSION_MINOR 0x00
+ #define T6FW_MIN_VERSION_MICRO 0x00
+ #endif
++>>>>>>> a69265e9f65a (cxgb4: Force uninitialized state if FW in adapter is unsupported):drivers/net/ethernet/chelsio/cxgb4/t4fw_version.h
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
index dddf17cba9bf..9f403fc8a04e 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
@@ -988,6 +988,7 @@ int t4_load_fw(struct adapter *adapter, const u8 *fw_data, unsigned int size);
 int t4_fw_upgrade(struct adapter *adap, unsigned int mbox,
 		  const u8 *fw_data, unsigned int size, int force);
 unsigned int t4_flash_cfg_addr(struct adapter *adapter);
+int t4_check_fw_version(struct adapter *adap);
 int t4_get_fw_version(struct adapter *adapter, u32 *vers);
 int t4_get_tp_version(struct adapter *adapter, u32 *vers);
 int t4_prep_fw(struct adapter *adap, struct fw_info *fw_info,
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
index 2a3e5627b439..ceaa20a46a32 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@ -5566,6 +5566,10 @@ static int adap_init0(struct adapter *adap)
 	 */
 	t4_get_fw_version(adap, &adap->params.fw_vers);
 	t4_get_tp_version(adap, &adap->params.tp_vers);
+	ret = t4_check_fw_version(adap);
+	/* If firmware is too old (not supported by driver) force an update. */
+	if (ret == -EFAULT)
+		state = DEV_STATE_UNINIT;
 	if ((adap->flags & MASTER_PF) && state != DEV_STATE_INIT) {
 		struct fw_info *fw_info;
 		struct fw_hdr *card_fw;
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/vport.h
