tcp: RFC7413 option support for Fast Open server

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Daniel Lee <Longinus00@gmail.com>
commit 7f9b838b71eb78a27de27a12ca5de8542fac3115
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/7f9b838b.failed

Fast Open has been using the experimental option with a magic number
(RFC6994) to request and grant Fast Open cookies. This patch enables
the server to support the official IANA option 34 in RFC7413 in
addition.

The change has passed all existing Fast Open tests with both
old and new options at Google.

	Signed-off-by: Daniel Lee <Longinus00@gmail.com>
	Signed-off-by: Yuchung Cheng <ycheng@google.com>
	Signed-off-by: Neal Cardwell <ncardwell@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7f9b838b71eb78a27de27a12ca5de8542fac3115)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_fastopen.c
#	net/ipv4/tcp_input.c
#	net/ipv4/tcp_output.c
diff --cc net/ipv4/tcp_fastopen.c
index ab7bd35bb312,e3d87aca6be8..000000000000
--- a/net/ipv4/tcp_fastopen.c
+++ b/net/ipv4/tcp_fastopen.c
@@@ -73,19 -83,228 +73,204 @@@ void tcp_fastopen_cookie_gen(__be32 src
  	rcu_read_lock();
  	ctx = rcu_dereference(tcp_fastopen_ctx);
  	if (ctx) {
 -		crypto_cipher_encrypt_one(ctx->tfm, foc->val, path);
 +		crypto_cipher_encrypt_one(ctx->tfm, foc->val, (__u8 *)path);
  		foc->len = TCP_FASTOPEN_COOKIE_SIZE;
 -		ok = true;
  	}
  	rcu_read_unlock();
 -	return ok;
  }
  
 -/* Generate the fastopen cookie by doing aes128 encryption on both
 - * the source and destination addresses. Pad 0s for IPv4 or IPv4-mapped-IPv6
 - * addresses. For the longer IPv6 addresses use CBC-MAC.
 - *
 - * XXX (TFO) - refactor when TCP_FASTOPEN_COOKIE_SIZE != AES_BLOCK_SIZE.
 - */
 -static bool tcp_fastopen_cookie_gen(struct request_sock *req,
 -				    struct sk_buff *syn,
 -				    struct tcp_fastopen_cookie *foc)
 +static int __init tcp_fastopen_init(void)
  {
 -	if (req->rsk_ops->family == AF_INET) {
 -		const struct iphdr *iph = ip_hdr(syn);
 -
 -		__be32 path[4] = { iph->saddr, iph->daddr, 0, 0 };
 -		return __tcp_fastopen_cookie_gen(path, foc);
 -	}
 -
 -#if IS_ENABLED(CONFIG_IPV6)
 -	if (req->rsk_ops->family == AF_INET6) {
 -		const struct ipv6hdr *ip6h = ipv6_hdr(syn);
 -		struct tcp_fastopen_cookie tmp;
 +	__u8 key[TCP_FASTOPEN_KEY_LENGTH];
  
 -		if (__tcp_fastopen_cookie_gen(&ip6h->saddr, &tmp)) {
 -			struct in6_addr *buf = (struct in6_addr *) tmp.val;
 -			int i;
 -
 -			for (i = 0; i < 4; i++)
 -				buf->s6_addr32[i] ^= ip6h->daddr.s6_addr32[i];
 -			return __tcp_fastopen_cookie_gen(buf, foc);
 -		}
 -	}
 -#endif
 -	return false;
 +	get_random_bytes(key, sizeof(key));
 +	tcp_fastopen_reset_cipher(key, sizeof(key));
 +	return 0;
  }
  
++<<<<<<< HEAD
 +late_initcall(tcp_fastopen_init);
++=======
+ static bool tcp_fastopen_create_child(struct sock *sk,
+ 				      struct sk_buff *skb,
+ 				      struct dst_entry *dst,
+ 				      struct request_sock *req)
+ {
+ 	struct tcp_sock *tp;
+ 	struct request_sock_queue *queue = &inet_csk(sk)->icsk_accept_queue;
+ 	struct sock *child;
+ 	u32 end_seq;
+ 
+ 	req->num_retrans = 0;
+ 	req->num_timeout = 0;
+ 	req->sk = NULL;
+ 
+ 	child = inet_csk(sk)->icsk_af_ops->syn_recv_sock(sk, skb, req, NULL);
+ 	if (!child)
+ 		return false;
+ 
+ 	spin_lock(&queue->fastopenq->lock);
+ 	queue->fastopenq->qlen++;
+ 	spin_unlock(&queue->fastopenq->lock);
+ 
+ 	/* Initialize the child socket. Have to fix some values to take
+ 	 * into account the child is a Fast Open socket and is created
+ 	 * only out of the bits carried in the SYN packet.
+ 	 */
+ 	tp = tcp_sk(child);
+ 
+ 	tp->fastopen_rsk = req;
+ 	tcp_rsk(req)->tfo_listener = true;
+ 
+ 	/* RFC1323: The window in SYN & SYN/ACK segments is never
+ 	 * scaled. So correct it appropriately.
+ 	 */
+ 	tp->snd_wnd = ntohs(tcp_hdr(skb)->window);
+ 
+ 	/* Activate the retrans timer so that SYNACK can be retransmitted.
+ 	 * The request socket is not added to the SYN table of the parent
+ 	 * because it's been added to the accept queue directly.
+ 	 */
+ 	inet_csk_reset_xmit_timer(child, ICSK_TIME_RETRANS,
+ 				  TCP_TIMEOUT_INIT, TCP_RTO_MAX);
+ 
+ 	atomic_set(&req->rsk_refcnt, 1);
+ 	/* Add the child socket directly into the accept queue */
+ 	inet_csk_reqsk_queue_add(sk, req, child);
+ 
+ 	/* Now finish processing the fastopen child socket. */
+ 	inet_csk(child)->icsk_af_ops->rebuild_header(child);
+ 	tcp_init_congestion_control(child);
+ 	tcp_mtup_init(child);
+ 	tcp_init_metrics(child);
+ 	tcp_init_buffer_space(child);
+ 
+ 	/* Queue the data carried in the SYN packet. We need to first
+ 	 * bump skb's refcnt because the caller will attempt to free it.
+ 	 * Note that IPv6 might also have used skb_get() trick
+ 	 * in tcp_v6_conn_request() to keep this SYN around (treq->pktopts)
+ 	 * So we need to eventually get a clone of the packet,
+ 	 * before inserting it in sk_receive_queue.
+ 	 *
+ 	 * XXX (TFO) - we honor a zero-payload TFO request for now,
+ 	 * (any reason not to?) but no need to queue the skb since
+ 	 * there is no data. How about SYN+FIN?
+ 	 */
+ 	end_seq = TCP_SKB_CB(skb)->end_seq;
+ 	if (end_seq != TCP_SKB_CB(skb)->seq + 1) {
+ 		struct sk_buff *skb2;
+ 
+ 		if (unlikely(skb_shared(skb)))
+ 			skb2 = skb_clone(skb, GFP_ATOMIC);
+ 		else
+ 			skb2 = skb_get(skb);
+ 
+ 		if (likely(skb2)) {
+ 			skb_dst_drop(skb2);
+ 			__skb_pull(skb2, tcp_hdrlen(skb));
+ 			skb_set_owner_r(skb2, child);
+ 			__skb_queue_tail(&child->sk_receive_queue, skb2);
+ 			tp->syn_data_acked = 1;
+ 		} else {
+ 			end_seq = TCP_SKB_CB(skb)->seq + 1;
+ 		}
+ 	}
+ 	tcp_rsk(req)->rcv_nxt = tp->rcv_nxt = end_seq;
+ 	sk->sk_data_ready(sk);
+ 	bh_unlock_sock(child);
+ 	sock_put(child);
+ 	WARN_ON(!req->sk);
+ 	return true;
+ }
+ 
+ static bool tcp_fastopen_queue_check(struct sock *sk)
+ {
+ 	struct fastopen_queue *fastopenq;
+ 
+ 	/* Make sure the listener has enabled fastopen, and we don't
+ 	 * exceed the max # of pending TFO requests allowed before trying
+ 	 * to validating the cookie in order to avoid burning CPU cycles
+ 	 * unnecessarily.
+ 	 *
+ 	 * XXX (TFO) - The implication of checking the max_qlen before
+ 	 * processing a cookie request is that clients can't differentiate
+ 	 * between qlen overflow causing Fast Open to be disabled
+ 	 * temporarily vs a server not supporting Fast Open at all.
+ 	 */
+ 	fastopenq = inet_csk(sk)->icsk_accept_queue.fastopenq;
+ 	if (!fastopenq || fastopenq->max_qlen == 0)
+ 		return false;
+ 
+ 	if (fastopenq->qlen >= fastopenq->max_qlen) {
+ 		struct request_sock *req1;
+ 		spin_lock(&fastopenq->lock);
+ 		req1 = fastopenq->rskq_rst_head;
+ 		if (!req1 || time_after(req1->rsk_timer.expires, jiffies)) {
+ 			spin_unlock(&fastopenq->lock);
+ 			NET_INC_STATS_BH(sock_net(sk),
+ 					 LINUX_MIB_TCPFASTOPENLISTENOVERFLOW);
+ 			return false;
+ 		}
+ 		fastopenq->rskq_rst_head = req1->dl_next;
+ 		fastopenq->qlen--;
+ 		spin_unlock(&fastopenq->lock);
+ 		reqsk_put(req1);
+ 	}
+ 	return true;
+ }
+ 
+ /* Returns true if we should perform Fast Open on the SYN. The cookie (foc)
+  * may be updated and return the client in the SYN-ACK later. E.g., Fast Open
+  * cookie request (foc->len == 0).
+  */
+ bool tcp_try_fastopen(struct sock *sk, struct sk_buff *skb,
+ 		      struct request_sock *req,
+ 		      struct tcp_fastopen_cookie *foc,
+ 		      struct dst_entry *dst)
+ {
+ 	struct tcp_fastopen_cookie valid_foc = { .len = -1 };
+ 	bool syn_data = TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq + 1;
+ 
+ 	if (foc->len == 0) /* Client requests a cookie */
+ 		NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPFASTOPENCOOKIEREQD);
+ 
+ 	if (!((sysctl_tcp_fastopen & TFO_SERVER_ENABLE) &&
+ 	      (syn_data || foc->len >= 0) &&
+ 	      tcp_fastopen_queue_check(sk))) {
+ 		foc->len = -1;
+ 		return false;
+ 	}
+ 
+ 	if (syn_data && (sysctl_tcp_fastopen & TFO_SERVER_COOKIE_NOT_REQD))
+ 		goto fastopen;
+ 
+ 	if (foc->len >= 0 &&  /* Client presents or requests a cookie */
+ 	    tcp_fastopen_cookie_gen(req, skb, &valid_foc) &&
+ 	    foc->len == TCP_FASTOPEN_COOKIE_SIZE &&
+ 	    foc->len == valid_foc.len &&
+ 	    !memcmp(foc->val, valid_foc.val, foc->len)) {
+ 		/* Cookie is valid. Create a (full) child socket to accept
+ 		 * the data in SYN before returning a SYN-ACK to ack the
+ 		 * data. If we fail to create the socket, fall back and
+ 		 * ack the ISN only but includes the same cookie.
+ 		 *
+ 		 * Note: Data-less SYN with valid cookie is allowed to send
+ 		 * data in SYN_RECV state.
+ 		 */
+ fastopen:
+ 		if (tcp_fastopen_create_child(sk, skb, dst, req)) {
+ 			foc->len = -1;
+ 			NET_INC_STATS_BH(sock_net(sk),
+ 					 LINUX_MIB_TCPFASTOPENPASSIVE);
+ 			return true;
+ 		}
+ 		NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPFASTOPENPASSIVEFAIL);
+ 	} else if (foc->len > 0) /* Client presents an invalid cookie */
+ 		NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPFASTOPENPASSIVEFAIL);
+ 
+ 	valid_foc.exp = foc->exp;
+ 	*foc = valid_foc;
+ 	return false;
+ }
+ EXPORT_SYMBOL(tcp_try_fastopen);
++>>>>>>> 7f9b838b71eb (tcp: RFC7413 option support for Fast Open server)
diff --cc net/ipv4/tcp_input.c
index ef845c96b4d4,24f1630b2afb..000000000000
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@@ -3611,21 -3709,22 +3628,35 @@@ void tcp_parse_options(const struct sk_
  				 */
  				break;
  #endif
+ 			case TCPOPT_FASTOPEN:
+ 				tcp_parse_fastopen_option(
+ 					opsize - TCPOLEN_FASTOPEN_BASE,
+ 					ptr, th->syn, foc, false);
+ 				break;
+ 
  			case TCPOPT_EXP:
  				/* Fast Open option shares code 254 using a
- 				 * 16 bits magic number. It's valid only in
- 				 * SYN or SYN-ACK with an even size.
+ 				 * 16 bits magic number.
  				 */
++<<<<<<< HEAD
 +				if (opsize < TCPOLEN_EXP_FASTOPEN_BASE ||
 +				    get_unaligned_be16(ptr) != TCPOPT_FASTOPEN_MAGIC ||
 +				    foc == NULL || !th->syn || (opsize & 1))
 +					break;
 +				foc->len = opsize - TCPOLEN_EXP_FASTOPEN_BASE;
 +				if (foc->len >= TCP_FASTOPEN_COOKIE_MIN &&
 +				    foc->len <= TCP_FASTOPEN_COOKIE_MAX)
 +					memcpy(foc->val, ptr + 2, foc->len);
 +				else if (foc->len != 0)
 +					foc->len = -1;
++=======
+ 				if (opsize >= TCPOLEN_EXP_FASTOPEN_BASE &&
+ 				    get_unaligned_be16(ptr) ==
+ 				    TCPOPT_FASTOPEN_MAGIC)
+ 					tcp_parse_fastopen_option(opsize -
+ 						TCPOLEN_EXP_FASTOPEN_BASE,
+ 						ptr + 2, th->syn, foc, true);
++>>>>>>> 7f9b838b71eb (tcp: RFC7413 option support for Fast Open server)
  				break;
  
  			}
diff --cc net/ipv4/tcp_output.c
index 074c9a68acbd,464bd8c5de69..000000000000
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@@ -624,8 -650,11 +633,16 @@@ static unsigned int tcp_synack_options(
  		if (unlikely(!ireq->tstamp_ok))
  			remaining -= TCPOLEN_SACKPERM_ALIGNED;
  	}
++<<<<<<< HEAD
 +	if (foc != NULL) {
 +		u32 need = TCPOLEN_EXP_FASTOPEN_BASE + foc->len;
++=======
+ 	if (foc != NULL && foc->len >= 0) {
+ 		u32 need = foc->len;
+ 
+ 		need += foc->exp ? TCPOLEN_EXP_FASTOPEN_BASE :
+ 				   TCPOLEN_FASTOPEN_BASE;
++>>>>>>> 7f9b838b71eb (tcp: RFC7413 option support for Fast Open server)
  		need = (need + 3) & ~3U;  /* Align to 32 bits */
  		if (remaining >= need) {
  			opts->options |= OPTION_FAST_OPEN_COOKIE;
diff --git a/include/linux/tcp.h b/include/linux/tcp.h
index 0ea024b94b21..91456e203408 100644
--- a/include/linux/tcp.h
+++ b/include/linux/tcp.h
@@ -60,6 +60,7 @@ static inline unsigned int tcp_optlen(const struct sk_buff *skb)
 struct tcp_fastopen_cookie {
 	s8	len;
 	u8	val[TCP_FASTOPEN_COOKIE_MAX];
+	bool	exp;	/* In RFC6994 experimental option format */
 };
 
 /* This defines a selective acknowledgement block. */
diff --git a/include/net/tcp.h b/include/net/tcp.h
index aff4173509ce..6e95afddac46 100644
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@ -175,6 +175,7 @@ extern void tcp_time_wait(struct sock *sk, int state, int timeo);
 #define TCPOPT_SACK             5       /* SACK Block */
 #define TCPOPT_TIMESTAMP	8	/* Better RTT estimations/PAWS */
 #define TCPOPT_MD5SIG		19	/* MD5 Signature (RFC2385) */
+#define TCPOPT_FASTOPEN		34	/* Fast open (RFC7413) */
 #define TCPOPT_EXP		254	/* Experimental */
 /* Magic number to be after the option value for sharing TCP
  * experimental options. See draft-ietf-tcpm-experimental-options-00.txt
@@ -190,6 +191,7 @@ extern void tcp_time_wait(struct sock *sk, int state, int timeo);
 #define TCPOLEN_SACK_PERM      2
 #define TCPOLEN_TIMESTAMP      10
 #define TCPOLEN_MD5SIG         18
+#define TCPOLEN_FASTOPEN_BASE  2
 #define TCPOLEN_EXP_FASTOPEN_BASE  4
 
 /* But this is what stacks really send out. */
* Unmerged path net/ipv4/tcp_fastopen.c
* Unmerged path net/ipv4/tcp_input.c
* Unmerged path net/ipv4/tcp_output.c
