ipv6: invert join/leave anycast rtnl/socket locking order

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
commit c4a6853d8fb2b122686bc6a7c472956e87090f4e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/c4a6853d.failed

Commit baf606d9c9b1 ("ipv4,ipv6: grab rtnl before locking the socket")
missed to update two setsockopt options, IPV6_JOIN_ANYCAST and
IPV6_LEAVE_ANYCAST, causing a lock inverstion regarding to the updated ones.

As ipv6_sock_ac_join and ipv6_sock_ac_leave are only called from
do_ipv6_setsockopt, we are good to just move the rtnl lock upper.

Fixes: baf606d9c9b1 ("ipv4,ipv6: grab rtnl before locking the socket")
	Reported-by: Ying Huang <ying.huang@intel.com>
	Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c4a6853d8fb2b122686bc6a7c472956e87090f4e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/anycast.c
diff --cc net/ipv6/anycast.c
index 5a80f15a9de2,9e6b0ee563f0..000000000000
--- a/net/ipv6/anycast.c
+++ b/net/ipv6/anycast.c
@@@ -77,7 -75,6 +79,10 @@@ int ipv6_sock_ac_join(struct sock *sk, 
  	pac->acl_next = NULL;
  	pac->acl_addr = *addr;
  
++<<<<<<< HEAD
 +	rcu_read_lock();
++=======
++>>>>>>> c4a6853d8fb2 (ipv6: invert join/leave anycast rtnl/socket locking order)
  	if (ifindex == 0) {
  		struct rt6_info *rt;
  
@@@ -136,7 -131,6 +141,10 @@@
  	}
  
  error:
++<<<<<<< HEAD
 +	rcu_read_unlock();
++=======
++>>>>>>> c4a6853d8fb2 (ipv6: invert join/leave anycast rtnl/socket locking order)
  	if (pac)
  		sock_kfree_s(sk, pac, sizeof(*pac));
  	return err;
@@@ -152,7 -146,8 +160,12 @@@ int ipv6_sock_ac_drop(struct sock *sk, 
  	struct ipv6_ac_socklist *pac, *prev_pac;
  	struct net *net = sock_net(sk);
  
++<<<<<<< HEAD
 +	spin_lock_bh(&ipv6_sk_ac_lock);
++=======
+ 	ASSERT_RTNL();
+ 
++>>>>>>> c4a6853d8fb2 (ipv6: invert join/leave anycast rtnl/socket locking order)
  	prev_pac = NULL;
  	for (pac = np->ipv6_ac_list; pac; pac = pac->acl_next) {
  		if ((ifindex == 0 || pac->acl_ifindex == ifindex) &&
@@@ -160,22 -155,16 +173,28 @@@
  			break;
  		prev_pac = pac;
  	}
++<<<<<<< HEAD
 +	if (!pac) {
 +		spin_unlock_bh(&ipv6_sk_ac_lock);
++=======
+ 	if (!pac)
++>>>>>>> c4a6853d8fb2 (ipv6: invert join/leave anycast rtnl/socket locking order)
  		return -ENOENT;
- 	}
  	if (prev_pac)
  		prev_pac->acl_next = pac->acl_next;
  	else
  		np->ipv6_ac_list = pac->acl_next;
  
 -	dev = __dev_get_by_index(net, pac->acl_ifindex);
 +	spin_unlock_bh(&ipv6_sk_ac_lock);
 +
 +	rcu_read_lock();
 +	dev = dev_get_by_index_rcu(net, pac->acl_ifindex);
  	if (dev)
  		ipv6_dev_ac_dec(dev, &pac->acl_addr);
++<<<<<<< HEAD
 +	rcu_read_unlock();
++=======
++>>>>>>> c4a6853d8fb2 (ipv6: invert join/leave anycast rtnl/socket locking order)
  
  	sock_kfree_s(sk, pac, sizeof(*pac));
  	return 0;
* Unmerged path net/ipv6/anycast.c
diff --git a/net/ipv6/ipv6_sockglue.c b/net/ipv6/ipv6_sockglue.c
index d53dcbf19bb6..65583d49d5f5 100644
--- a/net/ipv6/ipv6_sockglue.c
+++ b/net/ipv6/ipv6_sockglue.c
@@ -126,6 +126,8 @@ static bool setsockopt_needs_rtnl(int optname)
 	switch (optname) {
 	case IPV6_ADD_MEMBERSHIP:
 	case IPV6_DROP_MEMBERSHIP:
+	case IPV6_JOIN_ANYCAST:
+	case IPV6_LEAVE_ANYCAST:
 	case MCAST_JOIN_GROUP:
 	case MCAST_LEAVE_GROUP:
 		return true;
