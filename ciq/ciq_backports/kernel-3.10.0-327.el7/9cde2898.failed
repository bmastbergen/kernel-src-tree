gfs2: limit quota log messages

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Abhi Das <adas@redhat.com>
commit 9cde2898d04595c3bf24828822b3ea7acff181dd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/9cde2898.failed

This patch makes the quota subsystem only report once that a
particular user/group has exceeded their allotted quota.

Previously, it was possible for a program to continuously try
exceeding quota (despite receiving EDQUOT) and in turn trigger
gfs2 to issue a kernel log message about quota exceed. In theory,
this could get out of hand and flood the log and the filesystem
hosting the log files.

	Signed-off-by: Abhi Das <adas@redhat.com>
	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit 9cde2898d04595c3bf24828822b3ea7acff181dd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/quota.c
diff --cc fs/gfs2/quota.c
index aa355fb96cc9,dcd598aa2691..000000000000
--- a/fs/gfs2/quota.c
+++ b/fs/gfs2/quota.c
@@@ -1111,18 -1182,27 +1113,39 @@@ int gfs2_quota_check(struct gfs2_inode 
  		value += qd->qd_change;
  		spin_unlock(&qd_lock);
  
++<<<<<<< HEAD
 +		if (be64_to_cpu(qd->qd_qb.qb_limit) && (s64)be64_to_cpu(qd->qd_qb.qb_limit) < value) {
 +			print_message(qd, "exceeded");
 +			quota_send_warning(qd->qd_id,
 +					   sdp->sd_vfs->s_dev, QUOTA_NL_BHARDWARN);
 +
 +			error = -EDQUOT;
 +			break;
 +		} else if (be64_to_cpu(qd->qd_qb.qb_warn) &&
 +			   (s64)be64_to_cpu(qd->qd_qb.qb_warn) < value &&
++=======
+ 		if (limit > 0 && (limit - value) < ap->allowed)
+ 			ap->allowed = limit - value;
+ 		/* If we can't meet the target */
+ 		if (limit && limit < (value + (s64)ap->target)) {
+ 			/* If no min_target specified or we don't meet
+ 			 * min_target, return -EDQUOT */
+ 			if (!ap->min_target || ap->min_target > ap->allowed) {
+ 				if (!test_and_set_bit(QDF_QMSG_QUIET,
+ 						      &qd->qd_flags)) {
+ 					print_message(qd, "exceeded");
+ 					quota_send_warning(qd->qd_id,
+ 							   sdp->sd_vfs->s_dev,
+ 							   QUOTA_NL_BHARDWARN);
+ 				}
+ 				error = -EDQUOT;
+ 				break;
+ 			}
+ 		} else if (warn && warn < value &&
++>>>>>>> 9cde2898d045 (gfs2: limit quota log messages)
  			   time_after_eq(jiffies, qd->qd_last_warn +
 -					 gfs2_tune_get(sdp, gt_quota_warn_period)
 -					 * HZ)) {
 +					 gfs2_tune_get(sdp,
 +						gt_quota_warn_period) * HZ)) {
  			quota_send_warning(qd->qd_id,
  					   sdp->sd_vfs->s_dev, QUOTA_NL_BSOFTWARN);
  			error = print_message(qd, "warning");
diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 0b1540793164..843892c9ee6c 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -412,6 +412,7 @@ enum {
 	QDF_CHANGE		= 1,
 	QDF_LOCKED		= 2,
 	QDF_REFRESH		= 3,
+	QDF_QMSG_QUIET          = 4,
 };
 
 struct gfs2_quota_data {
* Unmerged path fs/gfs2/quota.c
