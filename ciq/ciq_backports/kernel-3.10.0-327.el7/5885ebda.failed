xfs: ensure truncate forces zeroed blocks to disk

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit 5885ebda878b47c4b4602d4b0410cb4b282af024
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/5885ebda.failed

A new fsync vs power fail test in xfstests indicated that XFS can
have unreliable data consistency when doing extending truncates that
require block zeroing. The blocks beyond EOF get zeroed in memory,
but we never force those changes to disk before we run the
transaction that extends the file size and exposes those blocks to
userspace. This can result in the blocks not being correctly zeroed
after a crash.

Because in-memory behaviour is correct, tools like fsx don't pick up
any coherency problems - it's not until the filesystem is shutdown
or the system crashes after writing the truncate transaction to the
journal but before the zeroed data in the page cache is flushed that
the issue is exposed.

Fix this by also flushing the dirty data in memory region between
the old size and new size when we've found blocks that need zeroing
in the truncate process.

	Reported-by: Liu Bo <bo.li.liu@oracle.com>
cc: <stable@vger.kernel.org>
	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit 5885ebda878b47c4b4602d4b0410cb4b282af024)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_file.c
#	fs/xfs/xfs_inode.h
#	fs/xfs/xfs_iops.c
diff --cc fs/xfs/xfs_file.c
index 91b548987ce6,a2e1cb8a568b..000000000000
--- a/fs/xfs/xfs_file.c
+++ b/fs/xfs/xfs_file.c
@@@ -583,7 -579,7 +589,11 @@@ restart
  			xfs_rw_ilock(ip, *iolock);
  			goto restart;
  		}
++<<<<<<< HEAD
 +		error = -xfs_zero_eof(ip, *pos, i_size_read(inode));
++=======
+ 		error = xfs_zero_eof(ip, *pos, i_size_read(inode), &zero);
++>>>>>>> 5885ebda878b (xfs: ensure truncate forces zeroed blocks to disk)
  		if (error)
  			return error;
  	}
diff --cc fs/xfs/xfs_inode.h
index 567fdb09b64d,a1cd55f3f351..000000000000
--- a/fs/xfs/xfs_inode.h
+++ b/fs/xfs/xfs_inode.h
@@@ -394,11 -375,20 +394,26 @@@ int		xfs_dir_ialloc(struct xfs_trans **
  			       struct xfs_inode **, int *);
  int		xfs_droplink(struct xfs_trans *, struct xfs_inode *);
  int		xfs_bumplink(struct xfs_trans *, struct xfs_inode *);
 +void		xfs_bump_ino_vers2(struct xfs_trans *, struct xfs_inode *);
  
  /* from xfs_file.c */
++<<<<<<< HEAD
 +int		xfs_zero_eof(struct xfs_inode *, xfs_off_t, xfs_fsize_t);
 +int		xfs_iozero(struct xfs_inode *, loff_t, size_t);
++=======
+ enum xfs_prealloc_flags {
+ 	XFS_PREALLOC_SET	= (1 << 1),
+ 	XFS_PREALLOC_CLEAR	= (1 << 2),
+ 	XFS_PREALLOC_SYNC	= (1 << 3),
+ 	XFS_PREALLOC_INVISIBLE	= (1 << 4),
+ };
+ 
+ int	xfs_update_prealloc_flags(struct xfs_inode *ip,
+ 				  enum xfs_prealloc_flags flags);
+ int	xfs_zero_eof(struct xfs_inode *ip, xfs_off_t offset,
+ 		     xfs_fsize_t isize, bool *did_zeroing);
+ int	xfs_iozero(struct xfs_inode *ip, loff_t pos, size_t count);
++>>>>>>> 5885ebda878b (xfs: ensure truncate forces zeroed blocks to disk)
  
  
  #define IHOLD(ip) \
diff --cc fs/xfs/xfs_iops.c
index 4f197837766a,e53a90331422..000000000000
--- a/fs/xfs/xfs_iops.c
+++ b/fs/xfs/xfs_iops.c
@@@ -798,15 -814,12 +795,17 @@@ xfs_setattr_size
  	 * any previous writes that are beyond the on disk EOF and the new
  	 * EOF that have not been written out need to be written here.  If we
  	 * do not write the data out, we expose ourselves to the null files
- 	 * problem.
- 	 *
- 	 * Only flush from the on disk size to the smaller of the in memory
- 	 * file size or the new size as that's the range we really care about
- 	 * here and prevents waiting for other data not within the range we
- 	 * care about here.
+ 	 * problem. Note that this includes any block zeroing we did above;
+ 	 * otherwise those blocks may not be zeroed after a crash.
  	 */
++<<<<<<< HEAD
 +	if (oldsize != ip->i_d.di_size && newsize > ip->i_d.di_size) {
 +		error = -filemap_write_and_wait_range(VFS_I(ip)->i_mapping,
++=======
+ 	if (newsize > ip->i_d.di_size &&
+ 	    (oldsize != ip->i_d.di_size || did_zeroing)) {
+ 		error = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,
++>>>>>>> 5885ebda878b (xfs: ensure truncate forces zeroed blocks to disk)
  						      ip->i_d.di_size, newsize);
  		if (error)
  			return error;
* Unmerged path fs/xfs/xfs_file.c
* Unmerged path fs/xfs/xfs_inode.h
* Unmerged path fs/xfs/xfs_iops.c
