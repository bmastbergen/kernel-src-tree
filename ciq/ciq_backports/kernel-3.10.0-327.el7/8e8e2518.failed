md: Close race when setting 'action' to 'idle'.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [md] Close race when setting 'action' to 'idle' (Jes Sorensen) [1173510 1231997]
Rebuild_FUZZ: 94.38%
commit-author NeilBrown <neilb@suse.de>
commit 8e8e2518fceca407bb8fc2a6710d19d2e217892e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/8e8e2518.failed

Checking ->sync_thread without holding the mddev_lock()
isn't really safe, even after flushing the workqueue which
ensures md_start_sync() has been run.

While this code is waiting for the lock, md_check_recovery could reap
the thread itself, and then start another thread (e.g. recovery might
finish, then reshape starts).  When this thread gets the lock
md_start_sync() hasn't run so it doesn't get reaped, but
MD_RECOVERY_RUNNING gets cleared.  This allows two threads to start
which leads to confusion.

So don't both if MD_RECOVERY_RUNNING isn't set, but if it is do
the flush and the test and the reap all under the mddev_lock to
avoid any race with md_check_recovery.

	Signed-off-by: NeilBrown <neilb@suse.de>
Fixes: 6791875e2e53 ("md: make reconfig_mutex optional for writes to md sysfs files.")
	Cc: stable@vger.kernel.org (v4.0+)
(cherry picked from commit 8e8e2518fceca407bb8fc2a6710d19d2e217892e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/md.c
diff --cc drivers/md/md.c
index 12c52aceb5eb,8d4408baa428..000000000000
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@@ -4206,16 -4211,20 +4206,31 @@@ action_store(struct mddev *mddev, cons
  	if (!mddev->pers || !mddev->pers->sync_request)
  		return -EINVAL;
  
 +	if (cmd_match(page, "frozen"))
 +		set_bit(MD_RECOVERY_FROZEN, &mddev->recovery);
 +	else
 +		clear_bit(MD_RECOVERY_FROZEN, &mddev->recovery);
  
  	if (cmd_match(page, "idle") || cmd_match(page, "frozen")) {
++<<<<<<< HEAD
 +		flush_workqueue(md_misc_wq);
 +		if (mddev->sync_thread) {
 +			set_bit(MD_RECOVERY_INTR, &mddev->recovery);
 +			md_reap_sync_thread(mddev);
++=======
+ 		if (cmd_match(page, "frozen"))
+ 			set_bit(MD_RECOVERY_FROZEN, &mddev->recovery);
+ 		else
+ 			clear_bit(MD_RECOVERY_FROZEN, &mddev->recovery);
+ 		if (test_bit(MD_RECOVERY_RUNNING, &mddev->recovery) &&
+ 		    mddev_lock(mddev) == 0) {
+ 			flush_workqueue(md_misc_wq);
+ 			if (mddev->sync_thread) {
+ 				set_bit(MD_RECOVERY_INTR, &mddev->recovery);
+ 				md_reap_sync_thread(mddev);
+ 			}
+ 			mddev_unlock(mddev);
++>>>>>>> 8e8e2518fcec (md: Close race when setting 'action' to 'idle'.)
  		}
  	} else if (test_bit(MD_RECOVERY_RUNNING, &mddev->recovery) ||
  		   test_bit(MD_RECOVERY_NEEDED, &mddev->recovery))
* Unmerged path drivers/md/md.c
