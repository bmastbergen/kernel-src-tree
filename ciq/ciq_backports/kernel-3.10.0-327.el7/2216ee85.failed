mm/Kconfig: fix URL for zsmalloc benchmark

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [mm] Kconfig: fix URL for zsmalloc benchmark (Seth Jennings) [1141434]
Rebuild_FUZZ: 96.30%
commit-author Ben Hutchings <ben@decadent.org.uk>
commit 2216ee853017f9c9371106c5c02d4fe42f61cbfa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/2216ee85.failed

The help text for CONFIG_PGTABLE_MAPPING has an incorrect URL.  While
we're at it, remove the unnecessary footnote notation.

	Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
	Acked-by: Minchan Kim <minchan@kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 2216ee853017f9c9371106c5c02d4fe42f61cbfa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/Kconfig
diff --cc mm/Kconfig
index 229c9742ecb3,2888024e0b0a..000000000000
--- a/mm/Kconfig
+++ b/mm/Kconfig
@@@ -540,3 -540,40 +540,43 @@@ config ZSWA
  	  interactions don't cause any known issues on simple memory setups,
  	  they have not be fully explored on the large set of potential
  	  configurations and workloads that exist.
++<<<<<<< HEAD
++=======
+ 
+ config MEM_SOFT_DIRTY
+ 	bool "Track memory changes"
+ 	depends on CHECKPOINT_RESTORE && HAVE_ARCH_SOFT_DIRTY && PROC_FS
+ 	select PROC_PAGE_MONITOR
+ 	help
+ 	  This option enables memory changes tracking by introducing a
+ 	  soft-dirty bit on pte-s. This bit it set when someone writes
+ 	  into a page just as regular dirty bit, but unlike the latter
+ 	  it can be cleared by hands.
+ 
+ 	  See Documentation/vm/soft-dirty.txt for more details.
+ 
+ config ZSMALLOC
+ 	bool "Memory allocator for compressed pages"
+ 	depends on MMU
+ 	default n
+ 	help
+ 	  zsmalloc is a slab-based memory allocator designed to store
+ 	  compressed RAM pages.  zsmalloc uses virtual memory mapping
+ 	  in order to reduce fragmentation.  However, this results in a
+ 	  non-standard allocator interface where a handle, not a pointer, is
+ 	  returned by an alloc().  This handle must be mapped in order to
+ 	  access the allocated space.
+ 
+ config PGTABLE_MAPPING
+ 	bool "Use page table mapping to access object in zsmalloc"
+ 	depends on ZSMALLOC
+ 	help
+ 	  By default, zsmalloc uses a copy-based object mapping method to
+ 	  access allocations that span two pages. However, if a particular
+ 	  architecture (ex, ARM) performs VM mapping faster than copying,
+ 	  then you should select this. This causes zsmalloc to use page table
+ 	  mapping rather than copying for object mapping.
+ 
+ 	  You can check speed with zsmalloc benchmark:
+ 	  https://github.com/spartacus06/zsmapbench
++>>>>>>> 2216ee853017 (mm/Kconfig: fix URL for zsmalloc benchmark)
* Unmerged path mm/Kconfig
