AHCI: Optimize single IRQ interrupt processing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Alexander Gordeev <agordeev@redhat.com>
commit 18dcf433f3ded61eb140a55e7048ec2fef79e723
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/18dcf433.failed

Split interrupt service routine into hardware context handler
and threaded context handler. That allows to protect ports with
individual locks rather than with a single host-wide lock and
move port interrupts handling out of the hardware interrupt
context.

Testing was done by transferring 8GB on two hard drives in
parallel using command 'dd if=/dev/sd{a,b} of=/dev/null'. With
lock_stat statistics I measured access times to ata_host::lock
spinlock (since interrupt handler code is fully embraced with
this lock). The average lock's holdtime decreased eight times
while average waittime decreased two times.

Both before and after the change the transfer time is the same,
while 'perf record -e cycles:k ...' shows 1%-4% CPU time spent
in ahci_single_irq_intr() routine before the update and not even
sampled/shown ahci_single_irq_intr() after the update.

	Signed-off-by: Alexander Gordeev <agordeev@redhat.com>
	Signed-off-by: Tejun Heo <tj@kernel.org>
	Cc: linux-ide@vger.kernel.org
(cherry picked from commit 18dcf433f3ded61eb140a55e7048ec2fef79e723)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/ata/libahci.c
diff --cc drivers/ata/libahci.c
index 198a9d07a8bc,3ce3d23e4f97..000000000000
--- a/drivers/ata/libahci.c
+++ b/drivers/ata/libahci.c
@@@ -1778,10 -1787,10 +1779,10 @@@ static void ahci_update_intr_status(str
  	status = readl(port_mmio + PORT_IRQ_STAT);
  	writel(status, port_mmio + PORT_IRQ_STAT);
  
- 	ahci_handle_port_interrupt(ap, port_mmio, status);
+ 	atomic_or(status, &pp->intr_status);
  }
  
 -static irqreturn_t ahci_port_thread_fn(int irq, void *dev_instance)
 +irqreturn_t ahci_thread_fn(int irq, void *dev_instance)
  {
  	struct ata_port *ap = dev_instance;
  	struct ahci_port_priv *pp = ap->private_data;
@@@ -1801,10 -1807,38 +1802,42 @@@
  
  	return IRQ_HANDLED;
  }
 +EXPORT_SYMBOL_GPL(ahci_thread_fn);
  
++<<<<<<< HEAD
 +static void ahci_hw_port_interrupt(struct ata_port *ap)
++=======
+ irqreturn_t ahci_thread_fn(int irq, void *dev_instance)
+ {
+ 	struct ata_host *host = dev_instance;
+ 	struct ahci_host_priv *hpriv = host->private_data;
+ 	u32 irq_masked = hpriv->port_map;
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < host->n_ports; i++) {
+ 		struct ata_port *ap;
+ 
+ 		if (!(irq_masked & (1 << i)))
+ 			continue;
+ 
+ 		ap = host->ports[i];
+ 		if (ap) {
+ 			ahci_port_thread_fn(irq, ap);
+ 			VPRINTK("port %u\n", i);
+ 		} else {
+ 			VPRINTK("port %u (no irq)\n", i);
+ 			if (ata_ratelimit())
+ 				dev_warn(host->dev,
+ 					 "interrupt on disabled port %u\n", i);
+ 		}
+ 	}
+ 
+ 	return IRQ_HANDLED;
+ }
+ 
+ static irqreturn_t ahci_multi_irqs_intr(int irq, void *dev_instance)
++>>>>>>> 18dcf433f3de (AHCI: Optimize single IRQ interrupt processing)
  {
 -	struct ata_port *ap = dev_instance;
  	void __iomem *port_mmio = ahci_port_base(ap);
  	struct ahci_port_priv *pp = ap->private_data;
  	u32 status;
@@@ -1928,9 -1912,8 +1961,9 @@@ irqreturn_t ahci_interrupt(int irq, voi
  
  	VPRINTK("EXIT\n");
  
- 	return IRQ_RETVAL(handled);
+ 	return handled ? IRQ_WAKE_THREAD : IRQ_NONE;
  }
 +EXPORT_SYMBOL_GPL(ahci_interrupt);
  
  unsigned int ahci_qc_issue(struct ata_queued_cmd *qc)
  {
@@@ -2458,6 -2442,105 +2486,108 @@@ void ahci_set_em_messages(struct ahci_h
  }
  EXPORT_SYMBOL_GPL(ahci_set_em_messages);
  
++<<<<<<< HEAD
++=======
+ static int ahci_host_activate_multi_irqs(struct ata_host *host, int irq,
+ 					 struct scsi_host_template *sht)
+ {
+ 	int i, rc;
+ 
+ 	rc = ata_host_start(host);
+ 	if (rc)
+ 		return rc;
+ 
+ 	for (i = 0; i < host->n_ports; i++) {
+ 		struct ahci_port_priv *pp = host->ports[i]->private_data;
+ 
+ 		/* Do not receive interrupts sent by dummy ports */
+ 		if (!pp) {
+ 			disable_irq(irq + i);
+ 			continue;
+ 		}
+ 
+ 		rc = devm_request_threaded_irq(host->dev, irq + i,
+ 					       ahci_multi_irqs_intr,
+ 					       ahci_port_thread_fn, IRQF_SHARED,
+ 					       pp->irq_desc, host->ports[i]);
+ 		if (rc)
+ 			goto out_free_irqs;
+ 	}
+ 
+ 	for (i = 0; i < host->n_ports; i++)
+ 		ata_port_desc(host->ports[i], "irq %d", irq + i);
+ 
+ 	rc = ata_host_register(host, sht);
+ 	if (rc)
+ 		goto out_free_all_irqs;
+ 
+ 	return 0;
+ 
+ out_free_all_irqs:
+ 	i = host->n_ports;
+ out_free_irqs:
+ 	for (i--; i >= 0; i--)
+ 		devm_free_irq(host->dev, irq + i, host->ports[i]);
+ 
+ 	return rc;
+ }
+ 
+ static int ahci_host_activate_single_irq(struct ata_host *host, int irq,
+ 					 struct scsi_host_template *sht)
+ {
+ 	int i, rc;
+ 
+ 	rc = ata_host_start(host);
+ 	if (rc)
+ 		return rc;
+ 
+ 	rc = devm_request_threaded_irq(host->dev, irq, ahci_single_irq_intr,
+ 				       ahci_thread_fn, IRQF_SHARED,
+ 				       dev_driver_string(host->dev), host);
+ 	if (rc)
+ 		return rc;
+ 
+ 	for (i = 0; i < host->n_ports; i++)
+ 		ata_port_desc(host->ports[i], "irq %d", irq);
+ 
+ 	rc = ata_host_register(host, sht);
+ 	if (rc)
+ 		devm_free_irq(host->dev, irq, host);
+ 
+ 	return rc;
+ }
+ 
+ /**
+  *	ahci_host_activate - start AHCI host, request IRQs and register it
+  *	@host: target ATA host
+  *	@irq: base IRQ number to request
+  *	@sht: scsi_host_template to use when registering the host
+  *
+  *	Similar to ata_host_activate, but requests IRQs according to AHCI-1.1
+  *	when multiple MSIs were allocated. That is one MSI per port, starting
+  *	from @irq.
+  *
+  *	LOCKING:
+  *	Inherited from calling layer (may sleep).
+  *
+  *	RETURNS:
+  *	0 on success, -errno otherwise.
+  */
+ int ahci_host_activate(struct ata_host *host, int irq,
+ 		       struct scsi_host_template *sht)
+ {
+ 	struct ahci_host_priv *hpriv = host->private_data;
+ 	int rc;
+ 
+ 	if (hpriv->flags & AHCI_HFLAG_MULTI_MSI)
+ 		rc = ahci_host_activate_multi_irqs(host, irq, sht);
+ 	else
+ 		rc = ahci_host_activate_single_irq(host, irq, sht);
+ 	return rc;
+ }
+ EXPORT_SYMBOL_GPL(ahci_host_activate);
+ 
++>>>>>>> 18dcf433f3de (AHCI: Optimize single IRQ interrupt processing)
  MODULE_AUTHOR("Jeff Garzik");
  MODULE_DESCRIPTION("Common AHCI SATA low-level routines");
  MODULE_LICENSE("GPL");
* Unmerged path drivers/ata/libahci.c
