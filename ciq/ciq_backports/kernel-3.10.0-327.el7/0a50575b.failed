ALSA: hda - Replace hda_bus_ops with static binding

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [alsa] hda - Replace hda_bus_ops with static binding (Jaroslav Kysela) [1197064]
Rebuild_FUZZ: 93.75%
commit-author Takashi Iwai <tiwai@suse.de>
commit 0a50575b64ee365bba4960756c394a28ed0710a4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/0a50575b.failed

Originally hda_bus takes its own ops (hda_bus_ops) to allow different
controller drivers giving individual implementations of PCM
attachment, etc.  But this never happened and we finally merged both
codec and controller helper codes.  Thus there is no merit to keep the
indirect accesses to functions via hda_bus_ops.

This patch replaces these calls with the direct local function calls
for simplification.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 0a50575b64ee365bba4960756c394a28ed0710a4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/hda_codec.c
#	sound/pci/hda/hda_codec.h
#	sound/pci/hda/hda_controller.c
diff --cc sound/pci/hda/hda_codec.c
index d744f45d5fe3,2d8883fbde2b..000000000000
--- a/sound/pci/hda/hda_codec.c
+++ b/sound/pci/hda/hda_codec.c
@@@ -196,8 -150,7 +196,12 @@@ static int codec_exec_verb(struct hda_c
  		if (bus->response_reset) {
  			codec_dbg(codec,
  				  "resetting BUS due to fatal communication error\n");
++<<<<<<< HEAD
 +			trace_hda_bus_reset(bus);
 +			bus->ops.bus_reset(bus);
++=======
+ 			snd_hda_bus_reset(bus);
++>>>>>>> 0a50575b64ee (ALSA: hda - Replace hda_bus_ops with static binding)
  		}
  		goto again;
  	}
@@@ -5395,54 -4108,7 +5396,53 @@@ void snd_hda_bus_reset_codecs(struct hd
  #endif
  	}
  }
- EXPORT_SYMBOL_GPL(snd_hda_bus_reset);
  
 +/*
 + * generic arrays
 + */
 +
 +/**
 + * snd_array_new - get a new element from the given array
 + * @array: the array object
 + *
 + * Get a new element from the given array.  If it exceeds the
 + * pre-allocated array size, re-allocate the array.
 + *
 + * Returns NULL if allocation failed.
 + */
 +void *snd_array_new(struct snd_array *array)
 +{
 +	if (snd_BUG_ON(!array->elem_size))
 +		return NULL;
 +	if (array->used >= array->alloced) {
 +		int num = array->alloced + array->alloc_align;
 +		int size = (num + 1) * array->elem_size;
 +		void *nlist;
 +		if (snd_BUG_ON(num >= 4096))
 +			return NULL;
 +		nlist = krealloc(array->list, size, GFP_KERNEL | __GFP_ZERO);
 +		if (!nlist)
 +			return NULL;
 +		array->list = nlist;
 +		array->alloced = num;
 +	}
 +	return snd_array_elem(array, array->used++);
 +}
 +EXPORT_SYMBOL_GPL(snd_array_new);
 +
 +/**
 + * snd_array_free - free the given array elements
 + * @array: the array object
 + */
 +void snd_array_free(struct snd_array *array)
 +{
 +	kfree(array->list);
 +	array->used = 0;
 +	array->alloced = 0;
 +	array->list = NULL;
 +}
 +EXPORT_SYMBOL_GPL(snd_array_free);
 +
  /**
   * snd_print_pcm_bits - Print the supported PCM fmt bits to the string buffer
   * @pcm: PCM caps bits
diff --cc sound/pci/hda/hda_codec.h
index 00c6f394c5ce,0f8b6b5812e6..000000000000
--- a/sound/pci/hda/hda_codec.h
+++ b/sound/pci/hda/hda_codec.h
@@@ -68,46 -40,6 +68,49 @@@ struct hda_codec
  struct hda_pcm;
  struct hda_pcm_stream;
  
++<<<<<<< HEAD
 +/* bus operators */
 +struct hda_bus_ops {
 +	/* send a single command */
 +	int (*command)(struct hda_bus *bus, unsigned int cmd);
 +	/* get a response from the last command */
 +	unsigned int (*get_response)(struct hda_bus *bus, unsigned int addr);
 +	/* free the private data */
 +	void (*private_free)(struct hda_bus *);
 +	/* attach a PCM stream */
 +	int (*attach_pcm)(struct hda_bus *bus, struct hda_codec *codec,
 +			  struct hda_pcm *pcm);
 +	/* reset bus for retry verb */
 +	void (*bus_reset)(struct hda_bus *bus);
 +#ifdef CONFIG_PM
 +	/* notify power-up/down from codec to controller */
 +	void (*pm_notify)(struct hda_bus *bus, bool power_up);
 +#endif
 +#ifdef CONFIG_SND_HDA_DSP_LOADER
 +	/* prepare DSP transfer */
 +	int (*load_dsp_prepare)(struct hda_bus *bus, unsigned int format,
 +				unsigned int byte_size,
 +				struct snd_dma_buffer *bufp);
 +	/* start/stop DSP transfer */
 +	void (*load_dsp_trigger)(struct hda_bus *bus, bool start);
 +	/* clean up DSP transfer */
 +	void (*load_dsp_cleanup)(struct hda_bus *bus,
 +				 struct snd_dma_buffer *dmab);
 +#endif
 +};
 +
 +/* unsolicited event handler */
 +#define HDA_UNSOL_QUEUE_SIZE	64
 +struct hda_bus_unsolicited {
 +	/* ring buffer */
 +	u32 queue[HDA_UNSOL_QUEUE_SIZE * 2];
 +	unsigned int rp, wp;
 +	/* workqueue */
 +	struct work_struct work;
 +};
 +
++=======
++>>>>>>> 0a50575b64ee (ALSA: hda - Replace hda_bus_ops with static binding)
  /*
   * codec bus
   *
@@@ -115,26 -47,15 +118,29 @@@
   * A hda_bus contains several codecs in the list codec_list.
   */
  struct hda_bus {
 -	struct hdac_bus core;
 -
  	struct snd_card *card;
  
 +	void *private_data;
  	struct pci_dev *pci;
  	const char *modelname;
 -
++<<<<<<< HEAD
 +	int *power_save;
 +	struct hda_bus_ops ops;
++=======
++>>>>>>> 0a50575b64ee (ALSA: hda - Replace hda_bus_ops with static binding)
 +
 +	/* codec linked list */
 +	struct list_head codec_list;
 +	unsigned int num_codecs;
 +	/* link caddr -> codec */
 +	struct hda_codec *caddr_tbl[HDA_MAX_CODEC_ADDRESS + 1];
 +
 +	struct mutex cmd_mutex;
  	struct mutex prepare_mutex;
  
 +	/* unsolicited event queue */
 +	struct hda_bus_unsolicited unsol;
 +
  	/* assigned PCMs */
  	DECLARE_BITMAP(pcm_dev_bits, SNDRV_PCM_DEVICES);
  
diff --cc sound/pci/hda/hda_controller.c
index 0d7233e1e418,9bc8eaf0e5ac..000000000000
--- a/sound/pci/hda/hda_controller.c
+++ b/sound/pci/hda/hda_controller.c
@@@ -922,10 -532,11 +922,15 @@@ static void azx_pcm_free(struct snd_pc
  
  #define MAX_PREALLOC_SIZE	(32 * 1024 * 1024)
  
++<<<<<<< HEAD
 +static int azx_attach_pcm_stream(struct hda_bus *bus, struct hda_codec *codec,
 +				 struct hda_pcm *cpcm)
++=======
+ int snd_hda_attach_pcm_stream(struct hda_bus *_bus, struct hda_codec *codec,
+ 			      struct hda_pcm *cpcm)
++>>>>>>> 0a50575b64ee (ALSA: hda - Replace hda_bus_ops with static binding)
  {
 -	struct hdac_bus *bus = &_bus->core;
 -	struct azx *chip = bus_to_azx(bus);
 +	struct azx *chip = bus->private_data;
  	struct snd_pcm *pcm;
  	struct azx_pcm *apcm;
  	int pcm_dev = cpcm->device;
@@@ -1359,332 -804,127 +1364,363 @@@ static unsigned int azx_get_response(st
  static struct azx_dev *
  azx_get_dsp_loader_dev(struct azx *chip)
  {
 -	struct hdac_bus *bus = azx_bus(chip);
 -	struct hdac_stream *s;
 -
 -	list_for_each_entry(s, &bus->stream_list, list)
 -		if (s->index == chip->playback_index_offset)
 -			return stream_to_azx_dev(s);
 -
 -	return NULL;
 +	return &chip->azx_dev[chip->playback_index_offset];
  }
  
++<<<<<<< HEAD
 +static int azx_load_dsp_prepare(struct hda_bus *bus, unsigned int format,
 +				unsigned int byte_size,
 +				struct snd_dma_buffer *bufp)
 +{
 +	u32 *bdl;
 +	struct azx *chip = bus->private_data;
++=======
+ int snd_hda_codec_load_dsp_prepare(struct hda_codec *codec, unsigned int format,
+ 				   unsigned int byte_size,
+ 				   struct snd_dma_buffer *bufp)
+ {
+ 	struct hdac_bus *bus = &codec->bus->core;
+ 	struct azx *chip = bus_to_azx(bus);
++>>>>>>> 0a50575b64ee (ALSA: hda - Replace hda_bus_ops with static binding)
  	struct azx_dev *azx_dev;
 -	struct hdac_stream *hstr;
 -	bool saved = false;
  	int err;
  
  	azx_dev = azx_get_dsp_loader_dev(chip);
 -	hstr = azx_stream(azx_dev);
 -	spin_lock_irq(&bus->reg_lock);
 -	if (hstr->opened) {
 -		chip->saved_azx_dev = *azx_dev;
 -		saved = true;
 -	}
 -	spin_unlock_irq(&bus->reg_lock);
  
 -	err = snd_hdac_dsp_prepare(hstr, format, byte_size, bufp);
 -	if (err < 0) {
 -		spin_lock_irq(&bus->reg_lock);
 -		if (saved)
 -			*azx_dev = chip->saved_azx_dev;
 -		spin_unlock_irq(&bus->reg_lock);
 -		return err;
 +	dsp_lock(azx_dev);
 +	spin_lock_irq(&chip->reg_lock);
 +	if (azx_dev->running || azx_dev->locked) {
 +		spin_unlock_irq(&chip->reg_lock);
 +		err = -EBUSY;
 +		goto unlock;
  	}
 -
  	azx_dev->prepared = 0;
 +	chip->saved_azx_dev = *azx_dev;
 +	azx_dev->locked = 1;
 +	spin_unlock_irq(&chip->reg_lock);
 +
 +	err = chip->ops->dma_alloc_pages(chip, SNDRV_DMA_TYPE_DEV_SG,
 +					 byte_size, bufp);
 +	if (err < 0)
 +		goto err_alloc;
 +
 +	azx_dev->bufsize = byte_size;
 +	azx_dev->period_bytes = byte_size;
 +	azx_dev->format_val = format;
 +
 +	azx_stream_reset(chip, azx_dev);
 +
 +	/* reset BDL address */
 +	azx_sd_writel(chip, azx_dev, SD_BDLPL, 0);
 +	azx_sd_writel(chip, azx_dev, SD_BDLPU, 0);
 +
 +	azx_dev->frags = 0;
 +	bdl = (u32 *)azx_dev->bdl.area;
 +	err = setup_bdle(chip, bufp, azx_dev, &bdl, 0, byte_size, 0);
 +	if (err < 0)
 +		goto error;
 +
 +	azx_setup_controller(chip, azx_dev);
 +	dsp_unlock(azx_dev);
 +	return azx_dev->stream_tag;
 +
 + error:
 +	chip->ops->dma_free_pages(chip, bufp);
 + err_alloc:
 +	spin_lock_irq(&chip->reg_lock);
 +	if (azx_dev->opened)
 +		*azx_dev = chip->saved_azx_dev;
 +	azx_dev->locked = 0;
 +	spin_unlock_irq(&chip->reg_lock);
 + unlock:
 +	dsp_unlock(azx_dev);
  	return err;
  }
+ EXPORT_SYMBOL_GPL(snd_hda_codec_load_dsp_prepare);
  
++<<<<<<< HEAD
 +static void azx_load_dsp_trigger(struct hda_bus *bus, bool start)
 +{
 +	struct azx *chip = bus->private_data;
++=======
+ void snd_hda_codec_load_dsp_trigger(struct hda_codec *codec, bool start)
+ {
+ 	struct hdac_bus *bus = &codec->bus->core;
+ 	struct azx *chip = bus_to_azx(bus);
++>>>>>>> 0a50575b64ee (ALSA: hda - Replace hda_bus_ops with static binding)
  	struct azx_dev *azx_dev = azx_get_dsp_loader_dev(chip);
  
 -	snd_hdac_dsp_trigger(azx_stream(azx_dev), start);
 +	if (start)
 +		azx_stream_start(chip, azx_dev);
 +	else
 +		azx_stream_stop(chip, azx_dev);
 +	azx_dev->running = start;
  }
+ EXPORT_SYMBOL_GPL(snd_hda_codec_load_dsp_trigger);
  
++<<<<<<< HEAD
 +static void azx_load_dsp_cleanup(struct hda_bus *bus,
 +				 struct snd_dma_buffer *dmab)
 +{
 +	struct azx *chip = bus->private_data;
++=======
+ void snd_hda_codec_load_dsp_cleanup(struct hda_codec *codec,
+ 				    struct snd_dma_buffer *dmab)
+ {
+ 	struct hdac_bus *bus = &codec->bus->core;
+ 	struct azx *chip = bus_to_azx(bus);
++>>>>>>> 0a50575b64ee (ALSA: hda - Replace hda_bus_ops with static binding)
  	struct azx_dev *azx_dev = azx_get_dsp_loader_dev(chip);
 -	struct hdac_stream *hstr = azx_stream(azx_dev);
  
++<<<<<<< HEAD
 +	if (!dmab->area || !azx_dev->locked)
++=======
+ 	if (!dmab->area || !hstr->locked)
++>>>>>>> 0a50575b64ee (ALSA: hda - Replace hda_bus_ops with static binding)
  		return;
  
 -	snd_hdac_dsp_cleanup(hstr, dmab);
 -	spin_lock_irq(&bus->reg_lock);
 -	if (hstr->opened)
 +	dsp_lock(azx_dev);
 +	/* reset BDL address */
 +	azx_sd_writel(chip, azx_dev, SD_BDLPL, 0);
 +	azx_sd_writel(chip, azx_dev, SD_BDLPU, 0);
 +	azx_sd_writel(chip, azx_dev, SD_CTL, 0);
 +	azx_dev->bufsize = 0;
 +	azx_dev->period_bytes = 0;
 +	azx_dev->format_val = 0;
 +
 +	chip->ops->dma_free_pages(chip, dmab);
 +	dmab->area = NULL;
 +
 +	spin_lock_irq(&chip->reg_lock);
 +	if (azx_dev->opened)
  		*azx_dev = chip->saved_azx_dev;
 -	hstr->locked = false;
 -	spin_unlock_irq(&bus->reg_lock);
 +	azx_dev->locked = 0;
 +	spin_unlock_irq(&chip->reg_lock);
 +	dsp_unlock(azx_dev);
  }
+ EXPORT_SYMBOL_GPL(snd_hda_codec_load_dsp_cleanup);
  #endif /* CONFIG_SND_HDA_DSP_LOADER */
  
 +int azx_alloc_stream_pages(struct azx *chip)
 +{
 +	int i, err;
 +
 +	for (i = 0; i < chip->num_streams; i++) {
 +		dsp_lock_init(&chip->azx_dev[i]);
 +		/* allocate memory for the BDL for each stream */
 +		err = chip->ops->dma_alloc_pages(chip, SNDRV_DMA_TYPE_DEV,
 +						 BDL_SIZE,
 +						 &chip->azx_dev[i].bdl);
 +		if (err < 0)
 +			return -ENOMEM;
 +	}
 +	/* allocate memory for the position buffer */
 +	err = chip->ops->dma_alloc_pages(chip, SNDRV_DMA_TYPE_DEV,
 +					 chip->num_streams * 8, &chip->posbuf);
 +	if (err < 0)
 +		return -ENOMEM;
 +
 +	/* allocate CORB/RIRB */
 +	err = azx_alloc_cmd_io(chip);
 +	if (err < 0)
 +		return err;
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(azx_alloc_stream_pages);
 +
 +void azx_free_stream_pages(struct azx *chip)
 +{
 +	int i;
 +	if (chip->azx_dev) {
 +		for (i = 0; i < chip->num_streams; i++)
 +			if (chip->azx_dev[i].bdl.area)
 +				chip->ops->dma_free_pages(
 +					chip, &chip->azx_dev[i].bdl);
 +	}
 +	if (chip->rb.area)
 +		chip->ops->dma_free_pages(chip, &chip->rb);
 +	if (chip->posbuf.area)
 +		chip->ops->dma_free_pages(chip, &chip->posbuf);
 +}
 +EXPORT_SYMBOL_GPL(azx_free_stream_pages);
 +
  /*
 - * reset and start the controller registers
 + * Lowlevel interface
   */
 -void azx_init_chip(struct azx *chip, bool full_reset)
 +
 +/* enter link reset */
 +void azx_enter_link_reset(struct azx *chip)
 +{
 +	unsigned long timeout;
 +
 +	/* reset controller */
 +	azx_writel(chip, GCTL, azx_readl(chip, GCTL) & ~AZX_GCTL_RESET);
 +
 +	timeout = jiffies + msecs_to_jiffies(100);
 +	while ((azx_readb(chip, GCTL) & AZX_GCTL_RESET) &&
 +			time_before(jiffies, timeout))
 +		usleep_range(500, 1000);
 +}
 +EXPORT_SYMBOL_GPL(azx_enter_link_reset);
 +
 +/* exit link reset */
 +static void azx_exit_link_reset(struct azx *chip)
 +{
 +	unsigned long timeout;
 +
 +	azx_writeb(chip, GCTL, azx_readb(chip, GCTL) | AZX_GCTL_RESET);
 +
 +	timeout = jiffies + msecs_to_jiffies(100);
 +	while (!azx_readb(chip, GCTL) &&
 +			time_before(jiffies, timeout))
 +		usleep_range(500, 1000);
 +}
 +
 +/* reset codec link */
 +static int azx_reset(struct azx *chip, bool full_reset)
  {
 -	if (snd_hdac_bus_init_chip(azx_bus(chip), full_reset)) {
 -		/* correct RINTCNT for CXT */
 -		if (chip->driver_caps & AZX_DCAPS_CTX_WORKAROUND)
 -			azx_writew(chip, RINTCNT, 0xc0);
 +	if (!full_reset)
 +		goto __skip;
 +
 +	/* clear STATESTS */
 +	azx_writew(chip, STATESTS, STATESTS_INT_MASK);
 +
 +	/* reset controller */
 +	azx_enter_link_reset(chip);
 +
 +	/* delay for >= 100us for codec PLL to settle per spec
 +	 * Rev 0.9 section 5.5.1
 +	 */
 +	usleep_range(500, 1000);
 +
 +	/* Bring controller out of reset */
 +	azx_exit_link_reset(chip);
 +
 +	/* Brent Chartrand said to wait >= 540us for codecs to initialize */
 +	usleep_range(1000, 1200);
 +
 +      __skip:
 +	/* check to see if controller is ready */
 +	if (!azx_readb(chip, GCTL)) {
 +		dev_dbg(chip->card->dev, "azx_reset: controller not ready!\n");
 +		return -EBUSY;
  	}
 +
 +	/* Accept unsolicited responses */
 +	if (!chip->single_cmd)
 +		azx_writel(chip, GCTL, azx_readl(chip, GCTL) |
 +			   AZX_GCTL_UNSOL);
 +
 +	/* detect codecs */
 +	if (!chip->codec_mask) {
 +		chip->codec_mask = azx_readw(chip, STATESTS);
 +		dev_dbg(chip->card->dev, "codec_mask = 0x%x\n",
 +			chip->codec_mask);
 +	}
 +
 +	return 0;
  }
 -EXPORT_SYMBOL_GPL(azx_init_chip);
  
 -void azx_stop_all_streams(struct azx *chip)
 +/* enable interrupts */
 +static void azx_int_enable(struct azx *chip)
  {
 -	struct hdac_bus *bus = azx_bus(chip);
 -	struct hdac_stream *s;
 +	/* enable controller CIE and GIE */
 +	azx_writel(chip, INTCTL, azx_readl(chip, INTCTL) |
 +		   AZX_INT_CTRL_EN | AZX_INT_GLOBAL_EN);
 +}
  
 -	list_for_each_entry(s, &bus->stream_list, list)
 -		snd_hdac_stream_stop(s);
 +/* disable interrupts */
 +static void azx_int_disable(struct azx *chip)
 +{
 +	int i;
 +
 +	/* disable interrupts in stream descriptor */
 +	for (i = 0; i < chip->num_streams; i++) {
 +		struct azx_dev *azx_dev = &chip->azx_dev[i];
 +		azx_sd_writeb(chip, azx_dev, SD_CTL,
 +			      azx_sd_readb(chip, azx_dev, SD_CTL) &
 +					~SD_INT_MASK);
 +	}
 +
 +	/* disable SIE for all streams */
 +	azx_writeb(chip, INTCTL, 0);
 +
 +	/* disable controller CIE and GIE */
 +	azx_writel(chip, INTCTL, azx_readl(chip, INTCTL) &
 +		   ~(AZX_INT_CTRL_EN | AZX_INT_GLOBAL_EN));
  }
 -EXPORT_SYMBOL_GPL(azx_stop_all_streams);
  
 -void azx_stop_chip(struct azx *chip)
 +/* clear interrupts */
 +static void azx_int_clear(struct azx *chip)
  {
 -	snd_hdac_bus_stop_chip(azx_bus(chip));
 +	int i;
 +
 +	/* clear stream status */
 +	for (i = 0; i < chip->num_streams; i++) {
 +		struct azx_dev *azx_dev = &chip->azx_dev[i];
 +		azx_sd_writeb(chip, azx_dev, SD_STS, SD_INT_MASK);
 +	}
 +
 +	/* clear STATESTS */
 +	azx_writew(chip, STATESTS, STATESTS_INT_MASK);
 +
 +	/* clear rirb status */
 +	azx_writeb(chip, RIRBSTS, RIRB_INT_MASK);
 +
 +	/* clear int status */
 +	azx_writel(chip, INTSTS, AZX_INT_CTRL_EN | AZX_INT_ALL_STREAM);
  }
 -EXPORT_SYMBOL_GPL(azx_stop_chip);
  
  /*
 - * interrupt handler
 + * reset and start the controller registers
   */
 -static void stream_update(struct hdac_bus *bus, struct hdac_stream *s)
 +void azx_init_chip(struct azx *chip, bool full_reset)
  {
 -	struct azx *chip = bus_to_azx(bus);
 -	struct azx_dev *azx_dev = stream_to_azx_dev(s);
 -
 -	/* check whether this IRQ is really acceptable */
 -	if (!chip->ops->position_check ||
 -	    chip->ops->position_check(chip, azx_dev)) {
 -		spin_unlock(&bus->reg_lock);
 -		snd_pcm_period_elapsed(azx_stream(azx_dev)->substream);
 -		spin_lock(&bus->reg_lock);
 -	}
 +	if (chip->initialized)
 +		return;
 +
 +	/* reset controller */
 +	azx_reset(chip, full_reset);
 +
 +	/* initialize interrupts */
 +	azx_int_clear(chip);
 +	azx_int_enable(chip);
 +
 +	/* initialize the codec command I/O */
 +	if (!chip->single_cmd)
 +		azx_init_cmd_io(chip);
 +
 +	/* program the position buffer */
 +	azx_writel(chip, DPLBASE, (u32)chip->posbuf.addr);
 +	azx_writel(chip, DPUBASE, upper_32_bits(chip->posbuf.addr));
 +
 +	chip->initialized = 1;
 +}
 +EXPORT_SYMBOL_GPL(azx_init_chip);
 +
 +void azx_stop_chip(struct azx *chip)
 +{
 +	if (!chip->initialized)
 +		return;
 +
 +	/* disable interrupts */
 +	azx_int_disable(chip);
 +	azx_int_clear(chip);
 +
 +	/* disable CORB/RIRB */
 +	azx_free_cmd_io(chip);
 +
 +	/* disable position buffer */
 +	azx_writel(chip, DPLBASE, 0);
 +	azx_writel(chip, DPUBASE, 0);
 +
 +	chip->initialized = 0;
  }
 +EXPORT_SYMBOL_GPL(azx_stop_chip);
  
 +/*
 + * interrupt handler
 + */
  irqreturn_t azx_interrupt(int irq, void *dev_id)
  {
  	struct azx *chip = dev_id;
@@@ -1772,15 -996,15 +1808,20 @@@ static int probe_codec(struct azx *chip
  	return 0;
  }
  
- static void azx_bus_reset(struct hda_bus *bus)
+ void snd_hda_bus_reset(struct hda_bus *bus)
  {
 -	struct azx *chip = bus_to_azx(&bus->core);
 +	struct azx *chip = bus->private_data;
  
  	bus->in_reset = 1;
  	azx_stop_chip(chip);
  	azx_init_chip(chip, true);
++<<<<<<< HEAD
 +	if (chip->initialized)
 +		snd_hda_bus_reset(chip->bus);
++=======
+ 	if (bus->core.chip_init)
+ 		snd_hda_bus_reset_codecs(bus);
++>>>>>>> 0a50575b64ee (ALSA: hda - Replace hda_bus_ops with static binding)
  	bus->in_reset = 0;
  }
  
@@@ -1821,39 -1029,30 +1862,53 @@@ static int get_jackpoll_interval(struc
  	return j;
  }
  
++<<<<<<< HEAD
 +static struct hda_bus_ops bus_ops = {
 +	.command = azx_send_cmd,
 +	.get_response = azx_get_response,
 +	.attach_pcm = azx_attach_pcm_stream,
 +	.bus_reset = azx_bus_reset,
 +#ifdef CONFIG_PM
 +	.pm_notify = azx_power_notify,
 +#endif
 +#ifdef CONFIG_SND_HDA_DSP_LOADER
 +	.load_dsp_prepare = azx_load_dsp_prepare,
 +	.load_dsp_trigger = azx_load_dsp_trigger,
 +	.load_dsp_cleanup = azx_load_dsp_cleanup,
 +#endif
 +};
 +
++=======
++>>>>>>> 0a50575b64ee (ALSA: hda - Replace hda_bus_ops with static binding)
  /* HD-audio bus initialization */
 -int azx_bus_init(struct azx *chip, const char *model,
 -		 const struct hdac_io_ops *io_ops)
 +int azx_bus_create(struct azx *chip, const char *model, int *power_save_to)
  {
 -	struct hda_bus *bus = &chip->bus;
 +	struct hda_bus *bus;
  	int err;
  
 -	err = snd_hdac_bus_init(&bus->core, chip->card->dev, &bus_core_ops,
 -				io_ops);
 +	err = snd_hda_bus_new(chip->card, &bus);
  	if (err < 0)
  		return err;
  
 -	bus->card = chip->card;
 -	mutex_init(&bus->prepare_mutex);
 +	chip->bus = bus;
 +	bus->private_data = chip;
  	bus->pci = chip->pci;
  	bus->modelname = model;
++<<<<<<< HEAD
 +	bus->ops = bus_ops;
 +#ifdef CONFIG_PM
 +	bus->power_save = power_save_to;
 +#endif
++=======
+ 	bus->core.snoop = azx_snoop(chip);
+ 	if (chip->get_position[0] != azx_get_pos_lpib ||
+ 	    chip->get_position[1] != azx_get_pos_lpib)
+ 		bus->core.use_posbuf = true;
+ 	if (chip->bdl_pos_adj)
+ 		bus->core.bdl_pos_adj = chip->bdl_pos_adj[chip->dev_index];
+ 	if (chip->driver_caps & AZX_DCAPS_CORBRP_SELF_CLEAR)
+ 		bus->core.corbrp_self_clear = true;
++>>>>>>> 0a50575b64ee (ALSA: hda - Replace hda_bus_ops with static binding)
  
  	if (chip->driver_caps & AZX_DCAPS_RIRB_DELAY) {
  		dev_dbg(chip->card->dev, "Enable delay in RIRB handling\n");
* Unmerged path sound/pci/hda/hda_codec.c
* Unmerged path sound/pci/hda/hda_codec.h
* Unmerged path sound/pci/hda/hda_controller.c
