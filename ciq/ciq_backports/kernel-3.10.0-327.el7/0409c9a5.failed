net: fib6: fib6_commit_metrics: fix potential NULL pointer dereference

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] fib6: fib6_commit_metrics: fix potential NULL pointer dereference (Florian Westphal) [1212624]
Rebuild_FUZZ: 96.30%
commit-author Daniel Borkmann <dborkman@redhat.com>
commit 0409c9a5a7546043d32e8c46df0dcaf65f97f659
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/0409c9a5.failed

When IPv6 host routes with metrics attached are being added, we fetch
the metrics store from the dst via COW through dst_metrics_write_ptr(),
added through commit e5fd387ad5b3.

One remaining problem here is that we actually call into inet_getpeer()
and may end up allocating/creating a new peer from the kmemcache, which
may fail.

Example trace from perf probe (inet_getpeer:41) where create is 1:

ip 6877 [002] 4221.391591: probe:inet_getpeer: (ffffffff8165e293)
  85e294 inet_getpeer.part.7 (<- kmem_cache_alloc())
  85e578 inet_getpeer
  8eb333 ipv6_cow_metrics
  8f10ff fib6_commit_metrics

Therefore, a check for NULL on the return of dst_metrics_write_ptr()
is necessary here.

Joint work with Florian Westphal.

Fixes: e5fd387ad5b3 ("ipv6: do not overwrite inetpeer metrics prematurely")
	Cc: Michal Kubeček <mkubecek@suse.cz>
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0409c9a5a7546043d32e8c46df0dcaf65f97f659)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_fib.c
diff --cc net/ipv6/ip6_fib.c
index ebabac76c2ff,db4984e13f2f..000000000000
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@@ -638,6 -630,34 +638,37 @@@ static inline bool rt6_qualify_for_ecmp
  	       RTF_GATEWAY;
  }
  
++<<<<<<< HEAD
++=======
+ static int fib6_commit_metrics(struct dst_entry *dst,
+ 			       struct nlattr *mx, int mx_len)
+ {
+ 	bool dst_host = dst->flags & DST_HOST;
+ 	struct nlattr *nla;
+ 	int remaining;
+ 	u32 *mp;
+ 
+ 	mp = dst_host ? dst_metrics_write_ptr(dst) :
+ 			kzalloc(sizeof(u32) * RTAX_MAX, GFP_ATOMIC);
+ 	if (unlikely(!mp))
+ 		return -ENOMEM;
+ 	if (!dst_host)
+ 		dst_init_metrics(dst, mp, 0);
+ 
+ 	nla_for_each_attr(nla, mx, mx_len, remaining) {
+ 		int type = nla_type(nla);
+ 
+ 		if (type) {
+ 			if (type > RTAX_MAX)
+ 				return -EINVAL;
+ 
+ 			mp[type - 1] = nla_get_u32(nla);
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> 0409c9a5a754 (net: fib6: fib6_commit_metrics: fix potential NULL pointer dereference)
  /*
   *	Insert routing information in a node.
   */
* Unmerged path net/ipv6/ip6_fib.c
