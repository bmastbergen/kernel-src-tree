AHCI: Cleanup checking of multiple MSIs/SLM modes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Alexander Gordeev <agordeev@redhat.com>
commit c3ebd6a9b614ef1fbb5a44a3a33cd639ff4694bf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/c3ebd6a9.failed

Sharing Last Message (SLM) mode is currently checked in two
functions: ahci_host_activate() and ahci_init_interrupts().
This update consolidates SLM mode check with activation of
multiple MSIs mode.

	Signed-off-by: Alexander Gordeev <agordeev@redhat.com>
	Signed-off-by: Tejun Heo <tj@kernel.org>
	Cc: linux-ide@vger.kernel.org
(cherry picked from commit c3ebd6a9b614ef1fbb5a44a3a33cd639ff4694bf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/ata/ahci.h
diff --cc drivers/ata/ahci.h
index 16b1c42fa23e,a074c7301504..000000000000
--- a/drivers/ata/ahci.h
+++ b/drivers/ata/ahci.h
@@@ -370,7 -392,8 +370,12 @@@ irqreturn_t ahci_interrupt(int irq, voi
  irqreturn_t ahci_hw_interrupt(int irq, void *dev_instance);
  irqreturn_t ahci_thread_fn(int irq, void *dev_instance);
  void ahci_print_info(struct ata_host *host, const char *scc_s);
++<<<<<<< HEAD
 +int ahci_host_activate(struct ata_host *host, int irq, unsigned int n_msis);
++=======
+ int ahci_host_activate(struct ata_host *host, int irq);
+ void ahci_error_handler(struct ata_port *ap);
++>>>>>>> c3ebd6a9b614 (AHCI: Cleanup checking of multiple MSIs/SLM modes)
  
  static inline void __iomem *__ahci_port_base(struct ata_host *host,
  					     unsigned int port_no)
diff --git a/drivers/ata/ahci.c b/drivers/ata/ahci.c
index 2fc38f7d1744..0f035728b5bc 100644
--- a/drivers/ata/ahci.c
+++ b/drivers/ata/ahci.c
@@ -1150,6 +1150,9 @@ static int ahci_init_interrupts(struct pci_dev *pdev, unsigned int n_ports,
 		goto single_msi;
 	}
 
+	if (nvec > 1)
+		hpriv->flags |= AHCI_HFLAG_MULTI_MSI;
+
 	return nvec;
 
 single_msi:
@@ -1166,7 +1169,6 @@ intx:
  *	ahci_host_activate - start AHCI host, request IRQs and register it
  *	@host: target ATA host
  *	@irq: base IRQ number to request
- *	@n_msis: number of MSIs allocated for this host
  *	@irq_handler: irq_handler used when requesting IRQs
  *	@irq_flags: irq_flags used when requesting IRQs
  *
@@ -1180,14 +1182,10 @@ intx:
  *	RETURNS:
  *	0 on success, -errno otherwise.
  */
-int ahci_host_activate(struct ata_host *host, int irq, unsigned int n_msis)
+int ahci_host_activate(struct ata_host *host, int irq)
 {
 	int i, rc;
 
-	/* Sharing Last Message among several ports is not supported */
-	if (n_msis < host->n_ports)
-		return -EINVAL;
-
 	rc = ata_host_start(host);
 	if (rc)
 		return rc;
@@ -1235,7 +1233,7 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 	struct device *dev = &pdev->dev;
 	struct ahci_host_priv *hpriv;
 	struct ata_host *host;
-	int n_ports, n_msis, i, rc;
+	int n_ports, i, rc;
 	int ahci_pci_bar = AHCI_PCI_BAR_STANDARD;
 
 	VPRINTK("ENTER\n");
@@ -1390,9 +1388,7 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 	 */
 	n_ports = max(ahci_nr_ports(hpriv->cap), fls(hpriv->port_map));
 
-	n_msis = ahci_init_interrupts(pdev, n_ports, hpriv);
-	if (n_msis > 1)
-		hpriv->flags |= AHCI_HFLAG_MULTI_MSI;
+	ahci_init_interrupts(pdev, n_ports, hpriv);
 
 	host = ata_host_alloc_pinfo(&pdev->dev, ppi, n_ports);
 	if (!host)
@@ -1445,7 +1441,7 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 	pci_set_master(pdev);
 
 	if (hpriv->flags & AHCI_HFLAG_MULTI_MSI)
-		return ahci_host_activate(host, pdev->irq, n_msis);
+		return ahci_host_activate(host, pdev->irq);
 
 	return ata_host_activate(host, pdev->irq, ahci_interrupt, IRQF_SHARED,
 				 &ahci_sht);
* Unmerged path drivers/ata/ahci.h
