treewide: Fix typo in printk messages

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [scsi] be2iscsi: treewide: Fix typo in printk messages (Rob Evers) [1183800]
Rebuild_FUZZ: 88.10%
commit-author Masanari Iida <standby24x7@gmail.com>
commit f42cf8d6a3ec934551ac0f20f4654dccb11fa30d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/f42cf8d6.failed

This patch fix spelling typo in printk messages.

	Signed-off-by: Masanari Iida <standby24x7@gmail.com>
	Acked-by: Randy Dunlap <rdunlap@infradead.org>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit f42cf8d6a3ec934551ac0f20f4654dccb11fa30d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/mmc.c
#	drivers/mmc/core/sd.c
#	drivers/mtd/nand/gpmi-nand/gpmi-lib.c
#	drivers/net/phy/dp83640.c
#	drivers/net/wireless/ath/wcn36xx/smd.c
#	sound/soc/soc-core.c
diff --cc drivers/mmc/core/mmc.c
index 0cbd1effe960,b212239750af..000000000000
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@@ -1441,13 -1752,94 +1441,41 @@@ static int mmc_resume(struct mmc_host *
  	BUG_ON(!host);
  	BUG_ON(!host->card);
  
++<<<<<<< HEAD
  	mmc_claim_host(host);
 -
 -	if (!mmc_card_suspended(host->card))
 -		goto out;
 -
 -	mmc_power_up(host, host->card->ocr);
 -	err = mmc_init_card(host, host->card->ocr, host->card);
 -	mmc_card_clr_suspended(host->card);
 -
 -out:
 +	err = mmc_init_card(host, host->ocr, host->card);
  	mmc_release_host(host);
 -	return err;
 -}
 -
 -/*
 - * Shutdown callback
 - */
 -static int mmc_shutdown(struct mmc_host *host)
 -{
 -	int err = 0;
 -
 -	/*
 -	 * In a specific case for poweroff notify, we need to resume the card
 -	 * before we can shutdown it properly.
 -	 */
 -	if (mmc_can_poweroff_notify(host->card) &&
 -		!(host->caps2 & MMC_CAP2_FULL_PWR_CYCLE))
 -		err = _mmc_resume(host);
 -
 -	if (!err)
 -		err = _mmc_suspend(host, false);
 -
 -	return err;
 -}
 -
 -/*
 - * Callback for resume.
 - */
 -static int mmc_resume(struct mmc_host *host)
 -{
 -	int err = 0;
 -
 -	if (!(host->caps & MMC_CAP_RUNTIME_RESUME)) {
 -		err = _mmc_resume(host);
 -		pm_runtime_set_active(&host->card->dev);
 -		pm_runtime_mark_last_busy(&host->card->dev);
 -	}
 -	pm_runtime_enable(&host->card->dev);
 -
 -	return err;
 -}
 -
 -/*
 - * Callback for runtime_suspend.
 - */
 -static int mmc_runtime_suspend(struct mmc_host *host)
 -{
 -	int err;
 -
 -	if (!(host->caps & MMC_CAP_AGGRESSIVE_PM))
 -		return 0;
 -
++=======
+ 	err = _mmc_suspend(host, true);
+ 	if (err)
+ 		pr_err("%s: error %d doing aggressive suspend\n",
+ 			mmc_hostname(host), err);
++>>>>>>> f42cf8d6a3ec (treewide: Fix typo in printk messages)
  
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Callback for runtime_resume.
+  */
+ static int mmc_runtime_resume(struct mmc_host *host)
+ {
+ 	int err;
+ 
+ 	if (!(host->caps & (MMC_CAP_AGGRESSIVE_PM | MMC_CAP_RUNTIME_RESUME)))
+ 		return 0;
+ 
+ 	err = _mmc_resume(host);
+ 	if (err)
+ 		pr_err("%s: error %d doing aggressive resume\n",
+ 			mmc_hostname(host), err);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> f42cf8d6a3ec (treewide: Fix typo in printk messages)
  static int mmc_power_restore(struct mmc_host *host)
  {
  	int ret;
diff --cc drivers/mmc/core/sd.c
index 9e645e19cec6,c2cddfd99c7c..000000000000
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@@ -1088,13 -1113,73 +1088,41 @@@ static int mmc_sd_resume(struct mmc_hos
  	BUG_ON(!host);
  	BUG_ON(!host->card);
  
++<<<<<<< HEAD
  	mmc_claim_host(host);
 -
 -	if (!mmc_card_suspended(host->card))
 -		goto out;
 -
 -	mmc_power_up(host, host->card->ocr);
 -	err = mmc_sd_init_card(host, host->card->ocr, host->card);
 -	mmc_card_clr_suspended(host->card);
 -
 -out:
 +	err = mmc_sd_init_card(host, host->ocr, host->card);
  	mmc_release_host(host);
 -	return err;
 -}
 -
 -/*
 - * Callback for resume
 - */
 -static int mmc_sd_resume(struct mmc_host *host)
 -{
 -	int err = 0;
 -
 -	if (!(host->caps & MMC_CAP_RUNTIME_RESUME)) {
 -		err = _mmc_sd_resume(host);
 -		pm_runtime_set_active(&host->card->dev);
 -		pm_runtime_mark_last_busy(&host->card->dev);
 -	}
 -	pm_runtime_enable(&host->card->dev);
 -
 -	return err;
 -}
 -
 -/*
 - * Callback for runtime_suspend.
 - */
 -static int mmc_sd_runtime_suspend(struct mmc_host *host)
 -{
 -	int err;
 -
 -	if (!(host->caps & MMC_CAP_AGGRESSIVE_PM))
 -		return 0;
 -
++=======
+ 	err = _mmc_sd_suspend(host);
+ 	if (err)
+ 		pr_err("%s: error %d doing aggressive suspend\n",
+ 			mmc_hostname(host), err);
++>>>>>>> f42cf8d6a3ec (treewide: Fix typo in printk messages)
  
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Callback for runtime_resume.
+  */
+ static int mmc_sd_runtime_resume(struct mmc_host *host)
+ {
+ 	int err;
+ 
+ 	if (!(host->caps & (MMC_CAP_AGGRESSIVE_PM | MMC_CAP_RUNTIME_RESUME)))
+ 		return 0;
+ 
+ 	err = _mmc_sd_resume(host);
+ 	if (err)
+ 		pr_err("%s: error %d doing aggressive resume\n",
+ 			mmc_hostname(host), err);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> f42cf8d6a3ec (treewide: Fix typo in printk messages)
  static int mmc_sd_power_restore(struct mmc_host *host)
  {
  	int ret;
diff --cc drivers/mtd/nand/gpmi-nand/gpmi-lib.c
index 4f8857fa48a7,2788af980086..000000000000
--- a/drivers/mtd/nand/gpmi-nand/gpmi-lib.c
+++ b/drivers/mtd/nand/gpmi-nand/gpmi-lib.c
@@@ -1077,7 -1105,7 +1077,11 @@@ int gpmi_is_ready(struct gpmi_nand_dat
  		mask = MX28_BF_GPMI_STAT_READY_BUSY(1 << chip);
  		reg = readl(r->gpmi_regs + HW_GPMI_STAT);
  	} else
++<<<<<<< HEAD
 +		pr_err("unknow arch.\n");
++=======
+ 		dev_err(this->dev, "unknown arch.\n");
++>>>>>>> f42cf8d6a3ec (treewide: Fix typo in printk messages)
  	return reg & mask;
  }
  
diff --cc drivers/net/phy/dp83640.c
index 7490b6c866e6,4c2b5a80f17c..000000000000
--- a/drivers/net/phy/dp83640.c
+++ b/drivers/net/phy/dp83640.c
@@@ -541,7 -612,11 +541,15 @@@ static void recalibrate(struct dp83640_
  	u16 cal_gpio, cfg0, evnt, ptp_trig, trigger, val;
  
  	trigger = CAL_TRIGGER;
++<<<<<<< HEAD
 +	cal_gpio = gpio_tab[CALIBRATE_GPIO];
++=======
+ 	cal_gpio = 1 + ptp_find_pin(clock->ptp_clock, PTP_PF_PHYSYNC, 0);
+ 	if (cal_gpio < 1) {
+ 		pr_err("PHY calibration pin not available - PHY is not calibrated.");
+ 		return;
+ 	}
++>>>>>>> f42cf8d6a3ec (treewide: Fix typo in printk messages)
  
  	mutex_lock(&clock->extreg_lock);
  
diff --cc sound/soc/soc-core.c
index 5b2749caddd2,69e655e1ce11..000000000000
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@@ -3887,18 -3938,181 +3887,163 @@@ err
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static void snd_soc_component_seq_notifier(struct snd_soc_dapm_context *dapm,
+ 	enum snd_soc_dapm_type type, int subseq)
+ {
+ 	struct snd_soc_component *component = dapm->component;
+ 
+ 	component->driver->seq_notifier(component, type, subseq);
+ }
+ 
+ static int snd_soc_component_stream_event(struct snd_soc_dapm_context *dapm,
+ 	int event)
+ {
+ 	struct snd_soc_component *component = dapm->component;
+ 
+ 	return component->driver->stream_event(component, event);
+ }
+ 
+ static int snd_soc_component_initialize(struct snd_soc_component *component,
+ 	const struct snd_soc_component_driver *driver, struct device *dev)
+ {
+ 	struct snd_soc_dapm_context *dapm;
+ 
+ 	component->name = fmt_single_name(dev, &component->id);
+ 	if (!component->name) {
+ 		dev_err(dev, "ASoC: Failed to allocate name\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	component->dev = dev;
+ 	component->driver = driver;
+ 	component->probe = component->driver->probe;
+ 	component->remove = component->driver->remove;
+ 
+ 	if (!component->dapm_ptr)
+ 		component->dapm_ptr = &component->dapm;
+ 
+ 	dapm = component->dapm_ptr;
+ 	dapm->dev = dev;
+ 	dapm->component = component;
+ 	dapm->bias_level = SND_SOC_BIAS_OFF;
+ 	dapm->idle_bias_off = true;
+ 	if (driver->seq_notifier)
+ 		dapm->seq_notifier = snd_soc_component_seq_notifier;
+ 	if (driver->stream_event)
+ 		dapm->stream_event = snd_soc_component_stream_event;
+ 
+ 	component->controls = driver->controls;
+ 	component->num_controls = driver->num_controls;
+ 	component->dapm_widgets = driver->dapm_widgets;
+ 	component->num_dapm_widgets = driver->num_dapm_widgets;
+ 	component->dapm_routes = driver->dapm_routes;
+ 	component->num_dapm_routes = driver->num_dapm_routes;
+ 
+ 	INIT_LIST_HEAD(&component->dai_list);
+ 	mutex_init(&component->io_mutex);
+ 
+ 	return 0;
+ }
+ 
+ static void snd_soc_component_init_regmap(struct snd_soc_component *component)
+ {
+ 	if (!component->regmap)
+ 		component->regmap = dev_get_regmap(component->dev, NULL);
+ 	if (component->regmap) {
+ 		int val_bytes = regmap_get_val_bytes(component->regmap);
+ 		/* Errors are legitimate for non-integer byte multiples */
+ 		if (val_bytes > 0)
+ 			component->val_bytes = val_bytes;
+ 	}
+ }
+ 
+ static void snd_soc_component_add_unlocked(struct snd_soc_component *component)
+ {
+ 	if (!component->write && !component->read)
+ 		snd_soc_component_init_regmap(component);
+ 
+ 	list_add(&component->list, &component_list);
+ }
+ 
+ static void snd_soc_component_add(struct snd_soc_component *component)
+ {
+ 	mutex_lock(&client_mutex);
+ 	snd_soc_component_add_unlocked(component);
+ 	mutex_unlock(&client_mutex);
+ }
+ 
+ static void snd_soc_component_cleanup(struct snd_soc_component *component)
+ {
+ 	snd_soc_unregister_dais(component);
+ 	kfree(component->name);
+ }
+ 
+ static void snd_soc_component_del_unlocked(struct snd_soc_component *component)
+ {
+ 	list_del(&component->list);
+ }
+ 
+ static void snd_soc_component_del(struct snd_soc_component *component)
+ {
+ 	mutex_lock(&client_mutex);
+ 	snd_soc_component_del_unlocked(component);
+ 	mutex_unlock(&client_mutex);
+ }
+ 
+ int snd_soc_register_component(struct device *dev,
+ 			       const struct snd_soc_component_driver *cmpnt_drv,
+ 			       struct snd_soc_dai_driver *dai_drv,
+ 			       int num_dai)
+ {
+ 	struct snd_soc_component *cmpnt;
+ 	int ret;
+ 
+ 	cmpnt = kzalloc(sizeof(*cmpnt), GFP_KERNEL);
+ 	if (!cmpnt) {
+ 		dev_err(dev, "ASoC: Failed to allocate memory\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	ret = snd_soc_component_initialize(cmpnt, cmpnt_drv, dev);
+ 	if (ret)
+ 		goto err_free;
+ 
+ 	cmpnt->ignore_pmdown_time = true;
+ 	cmpnt->registered_as_component = true;
+ 
+ 	ret = snd_soc_register_dais(cmpnt, dai_drv, num_dai, true);
+ 	if (ret < 0) {
+ 		dev_err(dev, "ASoC: Failed to register DAIs: %d\n", ret);
+ 		goto err_cleanup;
+ 	}
+ 
+ 	snd_soc_component_add(cmpnt);
+ 
+ 	return 0;
+ 
+ err_cleanup:
+ 	snd_soc_component_cleanup(cmpnt);
+ err_free:
+ 	kfree(cmpnt);
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(snd_soc_register_component);
+ 
++>>>>>>> f42cf8d6a3ec (treewide: Fix typo in printk messages)
  /**
 - * snd_soc_unregister_component - Unregister a component from the ASoC core
 + * snd_soc_unregister_dais - Unregister multiple DAIs from the ASoC core
   *
 + * @dai: Array of DAIs to unregister
 + * @count: Number of DAIs
   */
 -void snd_soc_unregister_component(struct device *dev)
 +static void snd_soc_unregister_dais(struct device *dev, size_t count)
  {
 -	struct snd_soc_component *cmpnt;
 -
 -	list_for_each_entry(cmpnt, &component_list, list) {
 -		if (dev == cmpnt->dev && cmpnt->registered_as_component)
 -			goto found;
 -	}
 -	return;
 -
 -found:
 -	snd_soc_component_del(cmpnt);
 -	snd_soc_component_cleanup(cmpnt);
 -	kfree(cmpnt);
 -}
 -EXPORT_SYMBOL_GPL(snd_soc_unregister_component);
 -
 -static int snd_soc_platform_drv_probe(struct snd_soc_component *component)
 -{
 -	struct snd_soc_platform *platform = snd_soc_component_to_platform(component);
 -
 -	return platform->driver->probe(platform);
 -}
 -
 -static void snd_soc_platform_drv_remove(struct snd_soc_component *component)
 -{
 -	struct snd_soc_platform *platform = snd_soc_component_to_platform(component);
 +	int i;
  
 -	platform->driver->remove(platform);
 +	for (i = 0; i < count; i++)
 +		snd_soc_unregister_dai(dev);
  }
  
  /**
@@@ -4121,7 -4377,17 +4266,19 @@@ int snd_soc_register_codec(struct devic
  		fixup_codec_formats(&dai_drv[i].capture);
  	}
  
++<<<<<<< HEAD
++=======
+ 	ret = snd_soc_register_dais(&codec->component, dai_drv, num_dai, false);
+ 	if (ret < 0) {
+ 		dev_err(dev, "ASoC: Failed to register DAIs: %d\n", ret);
+ 		goto err_cleanup;
+ 	}
+ 
+ 	list_for_each_entry(dai, &codec->component.dai_list, list)
+ 		dai->codec = codec;
+ 
++>>>>>>> f42cf8d6a3ec (treewide: Fix typo in printk messages)
  	mutex_lock(&client_mutex);
 -	snd_soc_component_add_unlocked(&codec->component);
  	list_add(&codec->list, &codec_list);
  	mutex_unlock(&client_mutex);
  
* Unmerged path drivers/net/wireless/ath/wcn36xx/smd.c
diff --git a/arch/powerpc/perf/hv-24x7.c b/arch/powerpc/perf/hv-24x7.c
index 08e01f8eccc7..42ae0650e91c 100644
--- a/arch/powerpc/perf/hv-24x7.c
+++ b/arch/powerpc/perf/hv-24x7.c
@@ -360,7 +360,7 @@ static int h_24x7_event_init(struct perf_event *event)
 	/* PHYSICAL domains & other lpars require extra capabilities */
 	if (!caps.collect_privileged && (is_physical_domain(domain) ||
 		(event_get_lpar(event) != event_get_lpar_max()))) {
-		pr_devel("hv permisions disallow: is_physical_domain:%d, lpar=0x%llx\n",
+		pr_devel("hv permissions disallow: is_physical_domain:%d, lpar=0x%llx\n",
 				is_physical_domain(domain),
 				event_get_lpar(event));
 		return -EACCES;
diff --git a/drivers/mfd/si476x-i2c.c b/drivers/mfd/si476x-i2c.c
index f5bc8e4bd4bf..4b20204a6ed1 100644
--- a/drivers/mfd/si476x-i2c.c
+++ b/drivers/mfd/si476x-i2c.c
@@ -766,7 +766,7 @@ static int si476x_core_probe(struct i2c_client *client,
 			   sizeof(struct v4l2_rds_data),
 			   GFP_KERNEL);
 	if (rval) {
-		dev_err(&client->dev, "Could not alloate the FIFO\n");
+		dev_err(&client->dev, "Could not allocate the FIFO\n");
 		goto free_gpio;
 	}
 	mutex_init(&core->rds_drainer_status_lock);
* Unmerged path drivers/mmc/core/mmc.c
* Unmerged path drivers/mmc/core/sd.c
* Unmerged path drivers/mtd/nand/gpmi-nand/gpmi-lib.c
* Unmerged path drivers/net/phy/dp83640.c
diff --git a/drivers/net/wireless/airo.c b/drivers/net/wireless/airo.c
index 6125adb520a3..02e785530416 100644
--- a/drivers/net/wireless/airo.c
+++ b/drivers/net/wireless/airo.c
@@ -3209,7 +3209,7 @@ static void airo_print_status(const char *devname, u16 status)
 			airo_print_dbg(devname, "link lost (TSF sync lost)");
 			break;
 		default:
-			airo_print_dbg(devname, "unknow status %x\n", status);
+			airo_print_dbg(devname, "unknown status %x\n", status);
 			break;
 		}
 		break;
@@ -3231,7 +3231,7 @@ static void airo_print_status(const char *devname, u16 status)
 	case STAT_REASSOC:
 		break;
 	default:
-		airo_print_dbg(devname, "unknow status %x\n", status);
+		airo_print_dbg(devname, "unknown status %x\n", status);
 		break;
 	}
 }
* Unmerged path drivers/net/wireless/ath/wcn36xx/smd.c
diff --git a/drivers/pinctrl/pinctrl-abx500.c b/drivers/pinctrl/pinctrl-abx500.c
index 6d4532702f80..4daba52000a5 100644
--- a/drivers/pinctrl/pinctrl-abx500.c
+++ b/drivers/pinctrl/pinctrl-abx500.c
@@ -374,7 +374,7 @@ static int abx500_set_mode(struct pinctrl_dev *pctldev, struct gpio_chip *chip,
 		break;
 
 	default:
-		dev_dbg(pct->dev, "unknow alt_setting %d\n", alt_setting);
+		dev_dbg(pct->dev, "unknown alt_setting %d\n", alt_setting);
 
 		return -EINVAL;
 	}
diff --git a/drivers/scsi/ch.c b/drivers/scsi/ch.c
index 9f4f89b7c1a6..ead1dda2f60c 100644
--- a/drivers/scsi/ch.c
+++ b/drivers/scsi/ch.c
@@ -344,7 +344,7 @@ ch_readconfig(scsi_changer *ch)
 			ch->firsts[CHET_DT],
 			ch->counts[CHET_DT]);
 	} else {
-		VPRINTK(KERN_INFO, "reading element address assigment page failed!\n");
+		VPRINTK(KERN_INFO, "reading element address assignment page failed!\n");
 	}
 
 	/* vendor specific element types */
diff --git a/fs/jffs2/xattr.c b/fs/jffs2/xattr.c
index 3034e970eb9a..2f674fd49f8c 100644
--- a/fs/jffs2/xattr.c
+++ b/fs/jffs2/xattr.c
@@ -194,7 +194,7 @@ static int do_verify_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_dat
 	/* unchecked xdatum is chained with c->xattr_unchecked */
 	list_del_init(&xd->xindex);
 
-	dbg_xattr("success on verfying xdatum (xid=%u, version=%u)\n",
+	dbg_xattr("success on verifying xdatum (xid=%u, version=%u)\n",
 		  xd->xid, xd->version);
 
 	return 0;
diff --git a/net/atm/mpoa_proc.c b/net/atm/mpoa_proc.c
index 5bdd300db0f7..2df34eb5d65f 100644
--- a/net/atm/mpoa_proc.c
+++ b/net/atm/mpoa_proc.c
@@ -272,7 +272,7 @@ static int parse_qos(const char *buff)
 	qos.rxtp.max_pcr = rx_pcr;
 	qos.rxtp.max_sdu = rx_sdu;
 	qos.aal = ATM_AAL5;
-	dprintk("parse_qos(): setting qos paramameters to tx=%d,%d rx=%d,%d\n",
+	dprintk("parse_qos(): setting qos parameters to tx=%d,%d rx=%d,%d\n",
 		qos.txtp.max_pcr, qos.txtp.max_sdu,
 		qos.rxtp.max_pcr, qos.rxtp.max_sdu);
 
* Unmerged path sound/soc/soc-core.c
