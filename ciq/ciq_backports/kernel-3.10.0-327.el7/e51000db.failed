be2net: Replace dma/pci_alloc_coherent() calls with dma_zalloc_coherent()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Sriharsha Basavapatna <sriharsha.basavapatna@avagotech.com>
commit e51000db4c880165eab06ec0990605f24e75203f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/e51000db.failed

There are several places in the driver (all in control paths) where
coherent dma memory is being allocated using either dma_alloc_coherent()
or the deprecated pci_alloc_consistent(). All these calls should be
changed to use dma_zalloc_coherent() to avoid uninitialized fields in
data structures backed by this memory.

	Reported-by: Joerg Roedel <jroedel@suse.de>
	Tested-by: Joerg Roedel <jroedel@suse.de>
	Signed-off-by: Sriharsha Basavapatna <sriharsha.basavapatna@avagotech.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e51000db4c880165eab06ec0990605f24e75203f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/emulex/benet/be_main.c
diff --cc drivers/net/ethernet/emulex/benet/be_main.c
index 4e5ddaa87095,e43cc8a73ea7..000000000000
--- a/drivers/net/ethernet/emulex/benet/be_main.c
+++ b/drivers/net/ethernet/emulex/benet/be_main.c
@@@ -5107,10 -5192,193 +5107,198 @@@ reschedule
  	schedule_delayed_work(&adapter->work, msecs_to_jiffies(1000));
  }
  
 -static void be_unmap_pci_bars(struct be_adapter *adapter)
 +/* If any VFs are already enabled don't FLR the PF */
 +static bool be_reset_required(struct be_adapter *adapter)
  {
++<<<<<<< HEAD
 +	return pci_num_vf(adapter->pdev) ? false : true;
++=======
+ 	if (adapter->csr)
+ 		pci_iounmap(adapter->pdev, adapter->csr);
+ 	if (adapter->db)
+ 		pci_iounmap(adapter->pdev, adapter->db);
+ }
+ 
+ static int db_bar(struct be_adapter *adapter)
+ {
+ 	if (lancer_chip(adapter) || !be_physfn(adapter))
+ 		return 0;
+ 	else
+ 		return 4;
+ }
+ 
+ static int be_roce_map_pci_bars(struct be_adapter *adapter)
+ {
+ 	if (skyhawk_chip(adapter)) {
+ 		adapter->roce_db.size = 4096;
+ 		adapter->roce_db.io_addr = pci_resource_start(adapter->pdev,
+ 							      db_bar(adapter));
+ 		adapter->roce_db.total_size = pci_resource_len(adapter->pdev,
+ 							       db_bar(adapter));
+ 	}
+ 	return 0;
+ }
+ 
+ static int be_map_pci_bars(struct be_adapter *adapter)
+ {
+ 	struct pci_dev *pdev = adapter->pdev;
+ 	u8 __iomem *addr;
+ 	u32 sli_intf;
+ 
+ 	pci_read_config_dword(adapter->pdev, SLI_INTF_REG_OFFSET, &sli_intf);
+ 	adapter->sli_family = (sli_intf & SLI_INTF_FAMILY_MASK) >>
+ 				SLI_INTF_FAMILY_SHIFT;
+ 	adapter->virtfn = (sli_intf & SLI_INTF_FT_MASK) ? 1 : 0;
+ 
+ 	if (BEx_chip(adapter) && be_physfn(adapter)) {
+ 		adapter->csr = pci_iomap(pdev, 2, 0);
+ 		if (!adapter->csr)
+ 			return -ENOMEM;
+ 	}
+ 
+ 	addr = pci_iomap(pdev, db_bar(adapter), 0);
+ 	if (!addr)
+ 		goto pci_map_err;
+ 	adapter->db = addr;
+ 
+ 	if (skyhawk_chip(adapter) || BEx_chip(adapter)) {
+ 		if (be_physfn(adapter)) {
+ 			/* PCICFG is the 2nd BAR in BE2 */
+ 			addr = pci_iomap(pdev, BE2_chip(adapter) ? 1 : 0, 0);
+ 			if (!addr)
+ 				goto pci_map_err;
+ 			adapter->pcicfg = addr;
+ 		} else {
+ 			adapter->pcicfg = adapter->db + SRIOV_VF_PCICFG_OFFSET;
+ 		}
+ 	}
+ 
+ 	be_roce_map_pci_bars(adapter);
+ 	return 0;
+ 
+ pci_map_err:
+ 	dev_err(&pdev->dev, "Error in mapping PCI BARs\n");
+ 	be_unmap_pci_bars(adapter);
+ 	return -ENOMEM;
+ }
+ 
+ static void be_drv_cleanup(struct be_adapter *adapter)
+ {
+ 	struct be_dma_mem *mem = &adapter->mbox_mem_alloced;
+ 	struct device *dev = &adapter->pdev->dev;
+ 
+ 	if (mem->va)
+ 		dma_free_coherent(dev, mem->size, mem->va, mem->dma);
+ 
+ 	mem = &adapter->rx_filter;
+ 	if (mem->va)
+ 		dma_free_coherent(dev, mem->size, mem->va, mem->dma);
+ 
+ 	mem = &adapter->stats_cmd;
+ 	if (mem->va)
+ 		dma_free_coherent(dev, mem->size, mem->va, mem->dma);
+ }
+ 
+ /* Allocate and initialize various fields in be_adapter struct */
+ static int be_drv_init(struct be_adapter *adapter)
+ {
+ 	struct be_dma_mem *mbox_mem_alloc = &adapter->mbox_mem_alloced;
+ 	struct be_dma_mem *mbox_mem_align = &adapter->mbox_mem;
+ 	struct be_dma_mem *rx_filter = &adapter->rx_filter;
+ 	struct be_dma_mem *stats_cmd = &adapter->stats_cmd;
+ 	struct device *dev = &adapter->pdev->dev;
+ 	int status = 0;
+ 
+ 	mbox_mem_alloc->size = sizeof(struct be_mcc_mailbox) + 16;
+ 	mbox_mem_alloc->va = dma_zalloc_coherent(dev, mbox_mem_alloc->size,
+ 						 &mbox_mem_alloc->dma,
+ 						 GFP_KERNEL);
+ 	if (!mbox_mem_alloc->va)
+ 		return -ENOMEM;
+ 
+ 	mbox_mem_align->size = sizeof(struct be_mcc_mailbox);
+ 	mbox_mem_align->va = PTR_ALIGN(mbox_mem_alloc->va, 16);
+ 	mbox_mem_align->dma = PTR_ALIGN(mbox_mem_alloc->dma, 16);
+ 
+ 	rx_filter->size = sizeof(struct be_cmd_req_rx_filter);
+ 	rx_filter->va = dma_zalloc_coherent(dev, rx_filter->size,
+ 					    &rx_filter->dma, GFP_KERNEL);
+ 	if (!rx_filter->va) {
+ 		status = -ENOMEM;
+ 		goto free_mbox;
+ 	}
+ 
+ 	if (lancer_chip(adapter))
+ 		stats_cmd->size = sizeof(struct lancer_cmd_req_pport_stats);
+ 	else if (BE2_chip(adapter))
+ 		stats_cmd->size = sizeof(struct be_cmd_req_get_stats_v0);
+ 	else if (BE3_chip(adapter))
+ 		stats_cmd->size = sizeof(struct be_cmd_req_get_stats_v1);
+ 	else
+ 		stats_cmd->size = sizeof(struct be_cmd_req_get_stats_v2);
+ 	stats_cmd->va = dma_zalloc_coherent(dev, stats_cmd->size,
+ 					    &stats_cmd->dma, GFP_KERNEL);
+ 	if (!stats_cmd->va) {
+ 		status = -ENOMEM;
+ 		goto free_rx_filter;
+ 	}
+ 
+ 	mutex_init(&adapter->mbox_lock);
+ 	spin_lock_init(&adapter->mcc_lock);
+ 	spin_lock_init(&adapter->mcc_cq_lock);
+ 	init_completion(&adapter->et_cmd_compl);
+ 
+ 	pci_save_state(adapter->pdev);
+ 
+ 	INIT_DELAYED_WORK(&adapter->work, be_worker);
+ 	INIT_DELAYED_WORK(&adapter->be_err_detection_work,
+ 			  be_err_detection_task);
+ 
+ 	adapter->rx_fc = true;
+ 	adapter->tx_fc = true;
+ 
+ 	/* Must be a power of 2 or else MODULO will BUG_ON */
+ 	adapter->be_get_temp_freq = 64;
+ 
+ 	return 0;
+ 
+ free_rx_filter:
+ 	dma_free_coherent(dev, rx_filter->size, rx_filter->va, rx_filter->dma);
+ free_mbox:
+ 	dma_free_coherent(dev, mbox_mem_alloc->size, mbox_mem_alloc->va,
+ 			  mbox_mem_alloc->dma);
+ 	return status;
+ }
+ 
+ static void be_remove(struct pci_dev *pdev)
+ {
+ 	struct be_adapter *adapter = pci_get_drvdata(pdev);
+ 
+ 	if (!adapter)
+ 		return;
+ 
+ 	be_roce_dev_remove(adapter);
+ 	be_intr_set(adapter, false);
+ 
+ 	be_cancel_err_detection(adapter);
+ 
+ 	unregister_netdev(adapter->netdev);
+ 
+ 	be_clear(adapter);
+ 
+ 	/* tell fw we're done with firing cmds */
+ 	be_cmd_fw_clean(adapter);
+ 
+ 	be_unmap_pci_bars(adapter);
+ 	be_drv_cleanup(adapter);
+ 
+ 	pci_disable_pcie_error_reporting(pdev);
+ 
+ 	pci_release_regions(pdev);
+ 	pci_disable_device(pdev);
+ 
+ 	free_netdev(adapter->netdev);
++>>>>>>> e51000db4c88 (be2net: Replace dma/pci_alloc_coherent() calls with dma_zalloc_coherent())
  }
  
  static char *mc_name(struct be_adapter *adapter)
diff --git a/drivers/net/ethernet/emulex/benet/be_cmds.c b/drivers/net/ethernet/emulex/benet/be_cmds.c
index faa193e12fa0..5a2260e3b26e 100644
--- a/drivers/net/ethernet/emulex/benet/be_cmds.c
+++ b/drivers/net/ethernet/emulex/benet/be_cmds.c
@@ -1774,9 +1774,9 @@ int be_cmd_get_regs(struct be_adapter *adapter, u32 buf_len, void *buf)
 	total_size = buf_len;
 
 	get_fat_cmd.size = sizeof(struct be_cmd_req_get_fat) + 60*1024;
-	get_fat_cmd.va = pci_alloc_consistent(adapter->pdev,
-					      get_fat_cmd.size,
-					      &get_fat_cmd.dma);
+	get_fat_cmd.va = dma_zalloc_coherent(&adapter->pdev->dev,
+					     get_fat_cmd.size,
+					     &get_fat_cmd.dma, GFP_ATOMIC);
 	if (!get_fat_cmd.va) {
 		dev_err(&adapter->pdev->dev,
 			"Memory allocation failure while reading FAT data\n");
@@ -1821,8 +1821,8 @@ int be_cmd_get_regs(struct be_adapter *adapter, u32 buf_len, void *buf)
 		log_offset += buf_size;
 	}
 err:
-	pci_free_consistent(adapter->pdev, get_fat_cmd.size,
-			    get_fat_cmd.va, get_fat_cmd.dma);
+	dma_free_coherent(&adapter->pdev->dev, get_fat_cmd.size,
+			  get_fat_cmd.va, get_fat_cmd.dma);
 	spin_unlock_bh(&adapter->mcc_lock);
 	return status;
 }
@@ -2273,12 +2273,12 @@ int be_cmd_read_port_transceiver_data(struct be_adapter *adapter,
 		return -EINVAL;
 
 	cmd.size = sizeof(struct be_cmd_resp_port_type);
-	cmd.va = pci_alloc_consistent(adapter->pdev, cmd.size, &cmd.dma);
+	cmd.va = dma_zalloc_coherent(&adapter->pdev->dev, cmd.size, &cmd.dma,
+				     GFP_ATOMIC);
 	if (!cmd.va) {
 		dev_err(&adapter->pdev->dev, "Memory allocation failed\n");
 		return -ENOMEM;
 	}
-	memset(cmd.va, 0, cmd.size);
 
 	spin_lock_bh(&adapter->mcc_lock);
 
@@ -2303,7 +2303,7 @@ int be_cmd_read_port_transceiver_data(struct be_adapter *adapter,
 	}
 err:
 	spin_unlock_bh(&adapter->mcc_lock);
-	pci_free_consistent(adapter->pdev, cmd.size, cmd.va, cmd.dma);
+	dma_free_coherent(&adapter->pdev->dev, cmd.size, cmd.va, cmd.dma);
 	return status;
 }
 
@@ -2778,7 +2778,8 @@ int be_cmd_get_phy_info(struct be_adapter *adapter)
 		goto err;
 	}
 	cmd.size = sizeof(struct be_cmd_req_get_phy_info);
-	cmd.va = pci_alloc_consistent(adapter->pdev, cmd.size, &cmd.dma);
+	cmd.va = dma_zalloc_coherent(&adapter->pdev->dev, cmd.size, &cmd.dma,
+				     GFP_ATOMIC);
 	if (!cmd.va) {
 		dev_err(&adapter->pdev->dev, "Memory alloc failure\n");
 		status = -ENOMEM;
@@ -2812,7 +2813,7 @@ int be_cmd_get_phy_info(struct be_adapter *adapter)
 				BE_SUPPORTED_SPEED_1GBPS;
 		}
 	}
-	pci_free_consistent(adapter->pdev, cmd.size, cmd.va, cmd.dma);
+	dma_free_coherent(&adapter->pdev->dev, cmd.size, cmd.va, cmd.dma);
 err:
 	spin_unlock_bh(&adapter->mcc_lock);
 	return status;
@@ -2863,8 +2864,9 @@ int be_cmd_get_cntl_attributes(struct be_adapter *adapter)
 
 	memset(&attribs_cmd, 0, sizeof(struct be_dma_mem));
 	attribs_cmd.size = sizeof(struct be_cmd_resp_cntl_attribs);
-	attribs_cmd.va = pci_alloc_consistent(adapter->pdev, attribs_cmd.size,
-					      &attribs_cmd.dma);
+	attribs_cmd.va = dma_zalloc_coherent(&adapter->pdev->dev,
+					     attribs_cmd.size,
+					     &attribs_cmd.dma, GFP_ATOMIC);
 	if (!attribs_cmd.va) {
 		dev_err(&adapter->pdev->dev, "Memory allocation failure\n");
 		status = -ENOMEM;
@@ -2891,8 +2893,8 @@ int be_cmd_get_cntl_attributes(struct be_adapter *adapter)
 err:
 	mutex_unlock(&adapter->mbox_lock);
 	if (attribs_cmd.va)
-		pci_free_consistent(adapter->pdev, attribs_cmd.size,
-				    attribs_cmd.va, attribs_cmd.dma);
+		dma_free_coherent(&adapter->pdev->dev, attribs_cmd.size,
+				  attribs_cmd.va, attribs_cmd.dma);
 	return status;
 }
 
@@ -3030,9 +3032,10 @@ int be_cmd_get_mac_from_list(struct be_adapter *adapter, u8 *mac,
 
 	memset(&get_mac_list_cmd, 0, sizeof(struct be_dma_mem));
 	get_mac_list_cmd.size = sizeof(struct be_cmd_resp_get_mac_list);
-	get_mac_list_cmd.va = pci_alloc_consistent(adapter->pdev,
-						   get_mac_list_cmd.size,
-						   &get_mac_list_cmd.dma);
+	get_mac_list_cmd.va = dma_zalloc_coherent(&adapter->pdev->dev,
+						  get_mac_list_cmd.size,
+						  &get_mac_list_cmd.dma,
+						  GFP_ATOMIC);
 
 	if (!get_mac_list_cmd.va) {
 		dev_err(&adapter->pdev->dev,
@@ -3105,8 +3108,8 @@ int be_cmd_get_mac_from_list(struct be_adapter *adapter, u8 *mac,
 
 out:
 	spin_unlock_bh(&adapter->mcc_lock);
-	pci_free_consistent(adapter->pdev, get_mac_list_cmd.size,
-			    get_mac_list_cmd.va, get_mac_list_cmd.dma);
+	dma_free_coherent(&adapter->pdev->dev, get_mac_list_cmd.size,
+			  get_mac_list_cmd.va, get_mac_list_cmd.dma);
 	return status;
 }
 
@@ -3159,8 +3162,8 @@ int be_cmd_set_mac_list(struct be_adapter *adapter, u8 *mac_array,
 
 	memset(&cmd, 0, sizeof(struct be_dma_mem));
 	cmd.size = sizeof(struct be_cmd_req_set_mac_list);
-	cmd.va = dma_alloc_coherent(&adapter->pdev->dev, cmd.size,
-				    &cmd.dma, GFP_KERNEL);
+	cmd.va = dma_zalloc_coherent(&adapter->pdev->dev, cmd.size, &cmd.dma,
+				     GFP_KERNEL);
 	if (!cmd.va)
 		return -ENOMEM;
 
@@ -3343,7 +3346,8 @@ int be_cmd_get_acpi_wol_cap(struct be_adapter *adapter)
 
 	memset(&cmd, 0, sizeof(struct be_dma_mem));
 	cmd.size = sizeof(struct be_cmd_resp_acpi_wol_magic_config_v1);
-	cmd.va = pci_alloc_consistent(adapter->pdev, cmd.size, &cmd.dma);
+	cmd.va = dma_zalloc_coherent(&adapter->pdev->dev, cmd.size, &cmd.dma,
+				     GFP_ATOMIC);
 	if (!cmd.va) {
 		dev_err(&adapter->pdev->dev, "Memory allocation failure\n");
 		status = -ENOMEM;
@@ -3378,7 +3382,8 @@ int be_cmd_get_acpi_wol_cap(struct be_adapter *adapter)
 err:
 	mutex_unlock(&adapter->mbox_lock);
 	if (cmd.va)
-		pci_free_consistent(adapter->pdev, cmd.size, cmd.va, cmd.dma);
+		dma_free_coherent(&adapter->pdev->dev, cmd.size, cmd.va,
+				  cmd.dma);
 	return status;
 
 }
@@ -3392,8 +3397,9 @@ int be_cmd_set_fw_log_level(struct be_adapter *adapter, u32 level)
 
 	memset(&extfat_cmd, 0, sizeof(struct be_dma_mem));
 	extfat_cmd.size = sizeof(struct be_cmd_resp_get_ext_fat_caps);
-	extfat_cmd.va = pci_alloc_consistent(adapter->pdev, extfat_cmd.size,
-					     &extfat_cmd.dma);
+	extfat_cmd.va = dma_zalloc_coherent(&adapter->pdev->dev,
+					    extfat_cmd.size, &extfat_cmd.dma,
+					    GFP_ATOMIC);
 	if (!extfat_cmd.va)
 		return -ENOMEM;
 
@@ -3415,8 +3421,8 @@ int be_cmd_set_fw_log_level(struct be_adapter *adapter, u32 level)
 
 	status = be_cmd_set_ext_fat_capabilites(adapter, &extfat_cmd, cfgs);
 err:
-	pci_free_consistent(adapter->pdev, extfat_cmd.size, extfat_cmd.va,
-			    extfat_cmd.dma);
+	dma_free_coherent(&adapter->pdev->dev, extfat_cmd.size, extfat_cmd.va,
+			  extfat_cmd.dma);
 	return status;
 }
 
@@ -3429,8 +3435,9 @@ int be_cmd_get_fw_log_level(struct be_adapter *adapter)
 
 	memset(&extfat_cmd, 0, sizeof(struct be_dma_mem));
 	extfat_cmd.size = sizeof(struct be_cmd_resp_get_ext_fat_caps);
-	extfat_cmd.va = pci_alloc_consistent(adapter->pdev, extfat_cmd.size,
-					     &extfat_cmd.dma);
+	extfat_cmd.va = dma_zalloc_coherent(&adapter->pdev->dev,
+					    extfat_cmd.size, &extfat_cmd.dma,
+					    GFP_ATOMIC);
 
 	if (!extfat_cmd.va) {
 		dev_err(&adapter->pdev->dev, "%s: Memory allocation failure\n",
@@ -3448,8 +3455,8 @@ int be_cmd_get_fw_log_level(struct be_adapter *adapter)
 				level = cfgs->module[0].trace_lvl[j].dbg_lvl;
 		}
 	}
-	pci_free_consistent(adapter->pdev, extfat_cmd.size, extfat_cmd.va,
-			    extfat_cmd.dma);
+	dma_free_coherent(&adapter->pdev->dev, extfat_cmd.size, extfat_cmd.va,
+			  extfat_cmd.dma);
 err:
 	return level;
 }
@@ -3647,7 +3654,8 @@ int be_cmd_get_func_config(struct be_adapter *adapter, struct be_resources *res)
 
 	memset(&cmd, 0, sizeof(struct be_dma_mem));
 	cmd.size = sizeof(struct be_cmd_resp_get_func_config);
-	cmd.va = pci_alloc_consistent(adapter->pdev, cmd.size, &cmd.dma);
+	cmd.va = dma_zalloc_coherent(&adapter->pdev->dev, cmd.size, &cmd.dma,
+				     GFP_ATOMIC);
 	if (!cmd.va) {
 		dev_err(&adapter->pdev->dev, "Memory alloc failure\n");
 		status = -ENOMEM;
@@ -3687,7 +3695,8 @@ int be_cmd_get_func_config(struct be_adapter *adapter, struct be_resources *res)
 err:
 	mutex_unlock(&adapter->mbox_lock);
 	if (cmd.va)
-		pci_free_consistent(adapter->pdev, cmd.size, cmd.va, cmd.dma);
+		dma_free_coherent(&adapter->pdev->dev, cmd.size, cmd.va,
+				  cmd.dma);
 	return status;
 }
 
@@ -3708,7 +3717,8 @@ int be_cmd_get_profile_config(struct be_adapter *adapter,
 
 	memset(&cmd, 0, sizeof(struct be_dma_mem));
 	cmd.size = sizeof(struct be_cmd_resp_get_profile_config);
-	cmd.va = pci_alloc_consistent(adapter->pdev, cmd.size, &cmd.dma);
+	cmd.va = dma_zalloc_coherent(&adapter->pdev->dev, cmd.size, &cmd.dma,
+				     GFP_ATOMIC);
 	if (!cmd.va)
 		return -ENOMEM;
 
@@ -3754,7 +3764,8 @@ int be_cmd_get_profile_config(struct be_adapter *adapter,
 		res->vf_if_cap_flags = vf_res->cap_flags;
 err:
 	if (cmd.va)
-		pci_free_consistent(adapter->pdev, cmd.size, cmd.va, cmd.dma);
+		dma_free_coherent(&adapter->pdev->dev, cmd.size, cmd.va,
+				  cmd.dma);
 	return status;
 }
 
@@ -3769,7 +3780,8 @@ static int be_cmd_set_profile_config(struct be_adapter *adapter, void *desc,
 
 	memset(&cmd, 0, sizeof(struct be_dma_mem));
 	cmd.size = sizeof(struct be_cmd_req_set_profile_config);
-	cmd.va = pci_alloc_consistent(adapter->pdev, cmd.size, &cmd.dma);
+	cmd.va = dma_zalloc_coherent(&adapter->pdev->dev, cmd.size, &cmd.dma,
+				     GFP_ATOMIC);
 	if (!cmd.va)
 		return -ENOMEM;
 
@@ -3785,7 +3797,8 @@ static int be_cmd_set_profile_config(struct be_adapter *adapter, void *desc,
 	status = be_cmd_notify_wait(adapter, &wrb);
 
 	if (cmd.va)
-		pci_free_consistent(adapter->pdev, cmd.size, cmd.va, cmd.dma);
+		dma_free_coherent(&adapter->pdev->dev, cmd.size, cmd.va,
+				  cmd.dma);
 	return status;
 }
 
diff --git a/drivers/net/ethernet/emulex/benet/be_ethtool.c b/drivers/net/ethernet/emulex/benet/be_ethtool.c
index abdfa387832d..634b94cb68a9 100644
--- a/drivers/net/ethernet/emulex/benet/be_ethtool.c
+++ b/drivers/net/ethernet/emulex/benet/be_ethtool.c
@@ -264,8 +264,8 @@ static int lancer_cmd_read_file(struct be_adapter *adapter, u8 *file_name,
 	int status = 0;
 
 	read_cmd.size = LANCER_READ_FILE_CHUNK;
-	read_cmd.va = pci_alloc_consistent(adapter->pdev, read_cmd.size,
-					   &read_cmd.dma);
+	read_cmd.va = dma_zalloc_coherent(&adapter->pdev->dev, read_cmd.size,
+					  &read_cmd.dma, GFP_ATOMIC);
 
 	if (!read_cmd.va) {
 		dev_err(&adapter->pdev->dev,
@@ -289,8 +289,8 @@ static int lancer_cmd_read_file(struct be_adapter *adapter, u8 *file_name,
 			break;
 		}
 	}
-	pci_free_consistent(adapter->pdev, read_cmd.size, read_cmd.va,
-			    read_cmd.dma);
+	dma_free_coherent(&adapter->pdev->dev, read_cmd.size, read_cmd.va,
+			  read_cmd.dma);
 
 	return status;
 }
@@ -818,8 +818,9 @@ static int be_test_ddr_dma(struct be_adapter *adapter)
 	};
 
 	ddrdma_cmd.size = sizeof(struct be_cmd_req_ddrdma_test);
-	ddrdma_cmd.va = dma_alloc_coherent(&adapter->pdev->dev, ddrdma_cmd.size,
-					   &ddrdma_cmd.dma, GFP_KERNEL);
+	ddrdma_cmd.va = dma_zalloc_coherent(&adapter->pdev->dev,
+					    ddrdma_cmd.size, &ddrdma_cmd.dma,
+					    GFP_KERNEL);
 	if (!ddrdma_cmd.va)
 		return -ENOMEM;
 
@@ -941,8 +942,9 @@ static int be_read_eeprom(struct net_device *netdev,
 
 	memset(&eeprom_cmd, 0, sizeof(struct be_dma_mem));
 	eeprom_cmd.size = sizeof(struct be_cmd_req_seeprom_read);
-	eeprom_cmd.va = dma_alloc_coherent(&adapter->pdev->dev, eeprom_cmd.size,
-					   &eeprom_cmd.dma, GFP_KERNEL);
+	eeprom_cmd.va = dma_zalloc_coherent(&adapter->pdev->dev,
+					    eeprom_cmd.size, &eeprom_cmd.dma,
+					    GFP_KERNEL);
 
 	if (!eeprom_cmd.va)
 		return -ENOMEM;
* Unmerged path drivers/net/ethernet/emulex/benet/be_main.c
