tcp: use TCP_SKB_CB(skb)->tcp_flags in input path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Eric Dumazet <edumazet@google.com>
commit e11ecddf5128011c936cc5360780190cbc901fdc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/e11ecddf.failed

Input path of TCP do not currently uses TCP_SKB_CB(skb)->tcp_flags,
which is only used in output path.

tcp_recvmsg(), looks at tcp_hdr(skb)->syn for every skb found in receive queue,
and its unfortunate because this bit is located in a cache line right before
the payload.

We can simplify TCP by copying tcp flags into TCP_SKB_CB(skb)->tcp_flags.

This patch does so, and avoids the cache line miss in tcp_recvmsg()

Following patches will
- allow a segment with FIN being coalesced in tcp_try_coalesce()
- simplify tcp_collapse() by not copying the headers.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Acked-by: Neal Cardwell <ncardwell@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e11ecddf5128011c936cc5360780190cbc901fdc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp.c
#	net/ipv4/tcp_ipv4.c
#	net/ipv6/tcp_ipv6.c
diff --cc net/ipv4/tcp.c
index 889b9a57db7a,070aeff1b131..000000000000
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@@ -1534,8 -1585,8 +1534,13 @@@ int tcp_read_sock(struct sock *sk, read
  			if (offset + 1 != skb->len)
  				continue;
  		}
++<<<<<<< HEAD
 +		if (tcp_hdr(skb)->fin) {
 +			sk_eat_skb(sk, skb);
++=======
+ 		if (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN) {
+ 			sk_eat_skb(sk, skb, false);
++>>>>>>> e11ecddf5128 (tcp: use TCP_SKB_CB(skb)->tcp_flags in input path)
  			++seq;
  			break;
  		}
@@@ -1837,10 -1959,12 +1842,10 @@@ skip_copy
  		if (used + offset < skb->len)
  			continue;
  
- 		if (tcp_hdr(skb)->fin)
+ 		if (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN)
  			goto found_fin_ok;
 -		if (!(flags & MSG_PEEK)) {
 -			sk_eat_skb(sk, skb, copied_early);
 -			copied_early = false;
 -		}
 +		if (!(flags & MSG_PEEK))
 +			sk_eat_skb(sk, skb);
  		continue;
  
  	found_fin_ok:
diff --cc net/ipv4/tcp_ipv4.c
index c8ee0750a071,006b045716d8..000000000000
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@@ -1950,7 -1638,8 +1950,12 @@@ int tcp_v4_rcv(struct sk_buff *skb
  	TCP_SKB_CB(skb)->end_seq = (TCP_SKB_CB(skb)->seq + th->syn + th->fin +
  				    skb->len - th->doff * 4);
  	TCP_SKB_CB(skb)->ack_seq = ntohl(th->ack_seq);
++<<<<<<< HEAD
 +	TCP_SKB_CB(skb)->when	 = 0;
++=======
+ 	TCP_SKB_CB(skb)->tcp_flags = tcp_flag_byte(th);
+ 	TCP_SKB_CB(skb)->tcp_tw_isn = 0;
++>>>>>>> e11ecddf5128 (tcp: use TCP_SKB_CB(skb)->tcp_flags in input path)
  	TCP_SKB_CB(skb)->ip_dsfield = ipv4_get_dsfield(iph);
  	TCP_SKB_CB(skb)->sacked	 = 0;
  
diff --cc net/ipv6/tcp_ipv6.c
index 3d041bf232b7,de51a88bec6f..000000000000
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@@ -1479,7 -1415,8 +1479,12 @@@ static int tcp_v6_rcv(struct sk_buff *s
  	TCP_SKB_CB(skb)->end_seq = (TCP_SKB_CB(skb)->seq + th->syn + th->fin +
  				    skb->len - th->doff*4);
  	TCP_SKB_CB(skb)->ack_seq = ntohl(th->ack_seq);
++<<<<<<< HEAD
 +	TCP_SKB_CB(skb)->when = 0;
++=======
+ 	TCP_SKB_CB(skb)->tcp_flags = tcp_flag_byte(th);
+ 	TCP_SKB_CB(skb)->tcp_tw_isn = 0;
++>>>>>>> e11ecddf5128 (tcp: use TCP_SKB_CB(skb)->tcp_flags in input path)
  	TCP_SKB_CB(skb)->ip_dsfield = ipv6_get_dsfield(hdr);
  	TCP_SKB_CB(skb)->sacked = 0;
  
* Unmerged path net/ipv4/tcp.c
diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
index 6394ffe428d8..8f40fcf3fcf6 100644
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -4070,7 +4070,7 @@ static void tcp_ofo_queue(struct sock *sk)
 		__skb_unlink(skb, &tp->out_of_order_queue);
 		__skb_queue_tail(&sk->sk_receive_queue, skb);
 		tp->rcv_nxt = TCP_SKB_CB(skb)->end_seq;
-		if (tcp_hdr(skb)->fin)
+		if (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN)
 			tcp_fin(sk);
 	}
 }
@@ -4490,7 +4490,7 @@ restart:
 		 * - bloated or contains data before "start" or
 		 *   overlaps to the next one.
 		 */
-		if (!tcp_hdr(skb)->syn && !tcp_hdr(skb)->fin &&
+		if (!(TCP_SKB_CB(skb)->tcp_flags & (TCPHDR_SYN | TCPHDR_FIN)) &&
 		    (tcp_win_from_space(skb->truesize) > skb->len ||
 		     before(TCP_SKB_CB(skb)->seq, start))) {
 			end_of_skbs = false;
@@ -4509,7 +4509,8 @@ restart:
 		/* Decided to skip this, advance start seq. */
 		start = TCP_SKB_CB(skb)->end_seq;
 	}
-	if (end_of_skbs || tcp_hdr(skb)->syn || tcp_hdr(skb)->fin)
+	if (end_of_skbs ||
+	    (TCP_SKB_CB(skb)->tcp_flags & (TCPHDR_SYN | TCPHDR_FIN)))
 		return;
 
 	while (before(start, end)) {
@@ -4556,8 +4557,7 @@ restart:
 				skb = tcp_collapse_one(sk, skb, list);
 				if (!skb ||
 				    skb == tail ||
-				    tcp_hdr(skb)->syn ||
-				    tcp_hdr(skb)->fin)
+				    (TCP_SKB_CB(skb)->tcp_flags & (TCPHDR_SYN | TCPHDR_FIN)))
 					return;
 			}
 		}
* Unmerged path net/ipv4/tcp_ipv4.c
* Unmerged path net/ipv6/tcp_ipv6.c
