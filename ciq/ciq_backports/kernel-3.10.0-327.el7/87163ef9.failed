bonding: remove last users of bond->lock and bond->lock itself

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Nikolay Aleksandrov <nikolay@redhat.com>
commit 87163ef9cda7617f8afdb549de191706641003c0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/87163ef9.failed

The usage of bond->lock in bond_main.c was completely unnecessary as it
didn't help to sync with anything, most of the spots already had RTNL.
Since there're no more users of bond->lock, remove it.

	Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 87163ef9cda7617f8afdb549de191706641003c0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
diff --cc drivers/net/bonding/bond_main.c
index f10f65fec93b,b43b2df9e5d1..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -3340,19 -3101,20 +3340,23 @@@ static void bond_work_cancel_all(struc
  static int bond_open(struct net_device *bond_dev)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
 -	struct list_head *iter;
  	struct slave *slave;
 +	int i;
  
  	/* reset slave->backup and slave->inactive */
++<<<<<<< HEAD
 +	read_lock(&bond->lock);
 +	if (bond->slave_cnt > 0) {
++=======
+ 	if (bond_has_slaves(bond)) {
++>>>>>>> 87163ef9cda7 (bonding: remove last users of bond->lock and bond->lock itself)
  		read_lock(&bond->curr_slave_lock);
 -		bond_for_each_slave(bond, slave, iter) {
 -			if (bond_uses_primary(bond) &&
 -			    slave != rcu_access_pointer(bond->curr_active_slave)) {
 -				bond_set_slave_inactive_flags(slave,
 -							      BOND_SLAVE_NOTIFY_NOW);
 +		bond_for_each_slave(bond, slave, i) {
 +			if ((bond->params.mode == BOND_MODE_ACTIVEBACKUP)
 +				&& (slave != bond->curr_active_slave)) {
 +				bond_set_slave_inactive_flags(slave);
  			} else {
 -				bond_set_slave_active_flags(slave,
 -							    BOND_SLAVE_NOTIFY_NOW);
 +				bond_set_slave_active_flags(slave);
  			}
  		}
  		read_unlock(&bond->curr_slave_lock);
@@@ -3412,9 -3173,7 +3415,13 @@@ static struct rtnl_link_stats64 *bond_g
  
  	memset(stats, 0, sizeof(*stats));
  
++<<<<<<< HEAD
 +	read_lock_bh(&bond->lock);
 +
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 87163ef9cda7 (bonding: remove last users of bond->lock and bond->lock itself)
  		const struct rtnl_link_stats64 *sstats =
  			dev_get_stats(slave->dev, &temp);
  
@@@ -3444,8 -3203,6 +3451,11 @@@
  		stats->tx_heartbeat_errors += sstats->tx_heartbeat_errors;
  		stats->tx_window_errors += sstats->tx_window_errors;
  	}
++<<<<<<< HEAD
 +
 +	read_unlock_bh(&bond->lock);
++=======
++>>>>>>> 87163ef9cda7 (bonding: remove last users of bond->lock and bond->lock itself)
  
  	return stats;
  }
@@@ -3682,33 -3416,15 +3690,39 @@@ static int bond_neigh_setup(struct net_
  static int bond_change_mtu(struct net_device *bond_dev, int new_mtu)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
 -	struct slave *slave, *rollback_slave;
 -	struct list_head *iter;
 +	struct slave *slave, *stop_at;
  	int res = 0;
 +	int i;
  
 -	netdev_dbg(bond_dev, "bond=%p, new_mtu=%d\n", bond, new_mtu);
 +	pr_debug("bond=%p, name=%s, new_mtu=%d\n", bond,
 +		 (bond_dev ? bond_dev->name : "None"), new_mtu);
 +
++<<<<<<< HEAD
 +	/* Can't hold bond->lock with bh disabled here since
 +	 * some base drivers panic. On the other hand we can't
 +	 * hold bond->lock without bh disabled because we'll
 +	 * deadlock. The only solution is to rely on the fact
 +	 * that we're under rtnl_lock here, and the slaves
 +	 * list won't change. This doesn't solve the problem
 +	 * of setting the slave's MTU while it is
 +	 * transmitting, but the assumption is that the base
 +	 * driver can handle that.
 +	 *
 +	 * TODO: figure out a way to safely iterate the slaves
 +	 * list, but without holding a lock around the actual
 +	 * call to the base driver.
 +	 */
  
 +	bond_for_each_slave(bond, slave, i) {
 +		pr_debug("s %p s->p %p c_m %p\n",
 +			 slave,
 +			 slave->prev,
 +			 slave->dev->netdev_ops->ndo_change_mtu);
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
+ 		netdev_dbg(bond_dev, "s %p c_m %p\n",
+ 			   slave, slave->dev->netdev_ops->ndo_change_mtu);
++>>>>>>> 87163ef9cda7 (bonding: remove last users of bond->lock and bond->lock itself)
  
  		res = dev_set_mtu(slave->dev, new_mtu);
  
@@@ -3778,31 -3496,8 +3792,36 @@@ static int bond_set_mac_address(struct 
  	if (!is_valid_ether_addr(sa->sa_data))
  		return -EADDRNOTAVAIL;
  
++<<<<<<< HEAD
 +	/* Can't hold bond->lock with bh disabled here since
 +	 * some base drivers panic. On the other hand we can't
 +	 * hold bond->lock without bh disabled because we'll
 +	 * deadlock. The only solution is to rely on the fact
 +	 * that we're under rtnl_lock here, and the slaves
 +	 * list won't change. This doesn't solve the problem
 +	 * of setting the slave's hw address while it is
 +	 * transmitting, but the assumption is that the base
 +	 * driver can handle that.
 +	 *
 +	 * TODO: figure out a way to safely iterate the slaves
 +	 * list, but without holding a lock around the actual
 +	 * call to the base driver.
 +	 */
 +
 +	bond_for_each_slave(bond, slave, i) {
 +		const struct net_device_ops *slave_ops = slave->dev->netdev_ops;
 +		pr_debug("slave %p %s\n", slave, slave->dev->name);
 +
 +		if (slave_ops->ndo_set_mac_address == NULL) {
 +			res = -EOPNOTSUPP;
 +			pr_debug("EOPNOTSUPP %s\n", slave->dev->name);
 +			goto unwind;
 +		}
 +
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
+ 		netdev_dbg(bond_dev, "slave %p %s\n", slave, slave->dev->name);
++>>>>>>> 87163ef9cda7 (bonding: remove last users of bond->lock and bond->lock itself)
  		res = dev_set_mac_address(slave->dev, addr);
  		if (res) {
  			/* TODO: consider downing the slave
@@@ -4160,9 -3821,8 +4179,14 @@@ static int bond_ethtool_get_settings(st
  	 * the true receive or transmit bandwidth (not all modes are symmetric)
  	 * this is an accurate maximum.
  	 */
++<<<<<<< HEAD
 +	read_lock(&bond->lock);
 +	bond_for_each_slave(bond, slave, i) {
 +		if (SLAVE_IS_OK(slave)) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
+ 		if (bond_slave_can_tx(slave)) {
++>>>>>>> 87163ef9cda7 (bonding: remove last users of bond->lock and bond->lock itself)
  			if (slave->speed != SPEED_UNKNOWN)
  				speed += slave->speed;
  			if (ecmd->duplex == DUPLEX_UNKNOWN &&
@@@ -4171,7 -3831,7 +4195,11 @@@
  		}
  	}
  	ethtool_cmd_speed_set(ecmd, speed ? : SPEED_UNKNOWN);
++<<<<<<< HEAD
 +	read_unlock(&bond->lock);
++=======
+ 
++>>>>>>> 87163ef9cda7 (bonding: remove last users of bond->lock and bond->lock itself)
  	return 0;
  }
  
@@@ -4233,9 -3893,7 +4261,8 @@@ void bond_setup(struct net_device *bond
  	struct bonding *bond = netdev_priv(bond_dev);
  
  	/* initialize rwlocks */
- 	rwlock_init(&bond->lock);
  	rwlock_init(&bond->curr_slave_lock);
 +
  	bond->params = bonding_defaults;
  
  	/* Initialize pointers */
* Unmerged path drivers/net/bonding/bond_main.c
diff --git a/drivers/net/bonding/bonding.h b/drivers/net/bonding/bonding.h
index 64c0cb81e478..a00b91bfcd70 100644
--- a/drivers/net/bonding/bonding.h
+++ b/drivers/net/bonding/bonding.h
@@ -78,7 +78,7 @@
  * @cnt:	counter for max number of moves
  * @start:	starting point.
  *
- * Caller must hold bond->lock
+ * Caller must hold RTNL
  */
 #define bond_for_each_slave_from(bond, pos, cnt, start)	\
 	for (cnt = 0, pos = start;				\
@@ -208,11 +208,8 @@ struct slave {
 /*
  * Here are the locking policies for the two bonding locks:
  *
- * 1) Get bond->lock when reading/writing slave list.
+ * 1) Get rcu_read_lock when reading or RTNL when writing slave list.
  * 2) Get bond->curr_slave_lock when reading/writing bond->curr_active_slave.
- *    (It is unnecessary when the write-lock is put with bond->lock.)
- * 3) When we lock with bond->curr_slave_lock, we must lock with bond->lock
- *    beforehand.
  */
 struct bonding {
 	struct   net_device *dev; /* first - useful for panic debug */
@@ -224,7 +221,6 @@ struct bonding {
 	s32      slave_cnt; /* never change this value outside the attach/detach wrappers */
 	int     (*recv_probe)(const struct sk_buff *, struct bonding *,
 			      struct slave *);
-	rwlock_t lock;
 	rwlock_t curr_slave_lock;
 	u8	 send_peer_notif;
 	u8       igmp_retrans;
