bonding: make bond_for_each_slave() use lower neighbour's private

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Veaceslav Falico <vfalico@redhat.com>
commit 9caff1e7b761c28018bf1858f6661439b4055f51
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/9caff1e7.failed

It needs a list_head *iter, so add it wherever needed. Use both non-rcu and
rcu variants.

CC: Jay Vosburgh <fubar@us.ibm.com>
CC: Andy Gospodarek <andy@greyhouse.net>
CC: Dimitris Michailidis <dm@chelsio.com>
	Signed-off-by: Veaceslav Falico <vfalico@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9caff1e7b761c28018bf1858f6661439b4055f51)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_3ad.c
#	drivers/net/bonding/bond_alb.c
#	drivers/net/bonding/bond_main.c
#	drivers/net/bonding/bond_procfs.c
#	drivers/net/bonding/bond_sysfs.c
#	drivers/net/bonding/bonding.h
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
diff --cc drivers/net/bonding/bond_3ad.c
index 390061d09693,3847aee34968..000000000000
--- a/drivers/net/bonding/bond_3ad.c
+++ b/drivers/net/bonding/bond_3ad.c
@@@ -2432,7 -2445,7 +2433,11 @@@ int bond_3ad_xmit_xor(struct sk_buff *s
  
  	slave_agg_no = bond->xmit_hash_policy(skb, slaves_in_agg);
  
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		struct aggregator *agg = SLAVE_AD_INFO(slave).port.aggregator;
  
  		if (agg && (agg->aggregator_identifier == agg_id)) {
@@@ -2501,18 -2515,14 +2506,27 @@@ int bond_3ad_lacpdu_recv(const struct s
   */
  void bond_3ad_update_lacp_rate(struct bonding *bond)
  {
++<<<<<<< HEAD
 +	int i;
++=======
+ 	struct port *port = NULL;
+ 	struct list_head *iter;
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  	struct slave *slave;
 +	struct port *port = NULL;
  	int lacp_fast;
  
 +	write_lock_bh(&bond->lock);
  	lacp_fast = bond->params.lacp_fast;
++<<<<<<< HEAD
 +
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		port = &(SLAVE_AD_INFO(slave).port);
 +		if (port->slave == NULL)
 +			continue;
  		__get_state_machine_lock(port);
  		if (lacp_fast)
  			port->actor_oper_port_state |= AD_STATE_LACP_TIMEOUT;
diff --cc drivers/net/bonding/bond_alb.c
index b7563cd17726,f4929cee21a6..000000000000
--- a/drivers/net/bonding/bond_alb.c
+++ b/drivers/net/bonding/bond_alb.c
@@@ -223,14 -223,14 +223,19 @@@ static long long compute_gap(struct sla
  static struct slave *tlb_get_least_loaded_slave(struct bonding *bond)
  {
  	struct slave *slave, *least_loaded;
+ 	struct list_head *iter;
  	long long max_gap;
 +	int i;
  
  	least_loaded = NULL;
  	max_gap = LLONG_MIN;
  
  	/* Find the slave with the largest gap */
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		if (SLAVE_IS_OK(slave)) {
  			long long gap = compute_gap(slave);
  
@@@ -1173,11 -1173,11 +1178,15 @@@ static void alb_change_hw_addr_on_detac
   */
  static int alb_handle_addr_collision_on_attach(struct bonding *bond, struct slave *slave)
  {
- 	struct slave *tmp_slave1, *free_mac_slave = NULL;
  	struct slave *has_bond_addr = bond->curr_active_slave;
++<<<<<<< HEAD
 +	int i;
++=======
+ 	struct slave *tmp_slave1, *free_mac_slave = NULL;
+ 	struct list_head *iter;
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  
 -	if (list_empty(&bond->slave_list)) {
 +	if (bond->slave_cnt == 0) {
  		/* this is the first slave */
  		return 0;
  	}
@@@ -1198,7 -1198,7 +1207,11 @@@
  	/* The slave's address is equal to the address of the bond.
  	 * Search for a spare address in the bond for this slave.
  	 */
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, tmp_slave1, i) {
++=======
+ 	bond_for_each_slave(bond, tmp_slave1, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		if (!bond_slave_has_mac(bond, tmp_slave1->perm_hwaddr)) {
  			/* no slave has tmp_slave1's perm addr
  			 * as its curr addr
@@@ -1248,17 -1248,16 +1261,26 @@@
   */
  static int alb_set_mac_address(struct bonding *bond, void *addr)
  {
++<<<<<<< HEAD
++=======
+ 	struct slave *slave, *rollback_slave;
+ 	struct list_head *iter;
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  	struct sockaddr sa;
 +	struct slave *slave, *stop_at;
  	char tmp_addr[ETH_ALEN];
  	int res;
 +	int i;
  
 -	if (bond->alb_info.rlb_enabled)
 +	if (bond->alb_info.rlb_enabled) {
  		return 0;
 +	}
  
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		/* save net_device's current hw address */
  		memcpy(tmp_addr, slave->dev->dev_addr, ETH_ALEN);
  
@@@ -1278,11 -1277,12 +1300,20 @@@ unwind
  	sa.sa_family = bond->dev->type;
  
  	/* unwind from head to the slave that failed */
++<<<<<<< HEAD
 +	stop_at = slave;
 +	bond_for_each_slave_from_to(bond, slave, i, bond->first_slave, stop_at) {
 +		memcpy(tmp_addr, slave->dev->dev_addr, ETH_ALEN);
 +		dev_set_mac_address(slave->dev, &sa);
 +		memcpy(slave->dev->dev_addr, tmp_addr, ETH_ALEN);
++=======
+ 	bond_for_each_slave(bond, rollback_slave, iter) {
+ 		if (rollback_slave == slave)
+ 			break;
+ 		memcpy(tmp_addr, rollback_slave->dev->dev_addr, ETH_ALEN);
+ 		dev_set_mac_address(rollback_slave->dev, &sa);
+ 		memcpy(rollback_slave->dev->dev_addr, tmp_addr, ETH_ALEN);
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  	}
  
  	return res;
@@@ -1461,8 -1463,8 +1492,9 @@@ void bond_alb_monitor(struct work_struc
  	struct bonding *bond = container_of(work, struct bonding,
  					    alb_work.work);
  	struct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));
+ 	struct list_head *iter;
  	struct slave *slave;
 +	int i;
  
  	read_lock(&bond->lock);
  
@@@ -1484,9 -1486,8 +1516,13 @@@
  		 */
  		read_lock(&bond->curr_slave_lock);
  
++<<<<<<< HEAD
 +		bond_for_each_slave(bond, slave, i) {
++=======
+ 		bond_for_each_slave(bond, slave, iter)
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  			alb_send_learning_packets(slave, slave->dev->dev_addr);
 +		}
  
  		read_unlock(&bond->curr_slave_lock);
  
@@@ -1498,7 -1499,7 +1534,11 @@@
  
  		read_lock(&bond->curr_slave_lock);
  
++<<<<<<< HEAD
 +		bond_for_each_slave(bond, slave, i) {
++=======
+ 		bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  			tlb_clear_slave(bond, slave, 1);
  			if (slave == bond->curr_active_slave) {
  				SLAVE_TLB_INFO(slave).load =
diff --cc drivers/net/bonding/bond_main.c
index 05a57077bb1c,9064e24de35a..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -441,10 -332,11 +441,18 @@@ static int bond_vlan_rx_add_vid(struct 
  				__be16 proto, u16 vid)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
++<<<<<<< HEAD
 +	struct slave *slave, *stop_at;
 +	int i, res;
 +
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	struct slave *slave, *rollback_slave;
+ 	struct list_head *iter;
+ 	int res;
+ 
+ 	bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		res = vlan_vid_add(slave->dev, proto, vid);
  		if (res)
  			goto unwind;
@@@ -460,10 -345,13 +468,20 @@@
  	return 0;
  
  unwind:
++<<<<<<< HEAD
 +	/* unwind from head to the slave that failed */
 +	stop_at = slave;
 +	bond_for_each_slave_from_to(bond, slave, i, bond->first_slave, stop_at)
 +		vlan_vid_del(slave->dev, proto, vid);
++=======
+ 	/* unwind to the slave that failed */
+ 	bond_for_each_slave(bond, rollback_slave, iter) {
+ 		if (rollback_slave == slave)
+ 			break;
+ 
+ 		vlan_vid_del(rollback_slave->dev, proto, vid);
+ 	}
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  
  	return res;
  }
@@@ -477,18 -365,14 +495,23 @@@ static int bond_vlan_rx_kill_vid(struc
  				 __be16 proto, u16 vid)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
+ 	struct list_head *iter;
  	struct slave *slave;
 +	int i, res;
  
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i)
++=======
+ 	bond_for_each_slave(bond, slave, iter)
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		vlan_vid_del(slave->dev, proto, vid);
  
 -	if (bond_is_lb(bond))
 -		bond_alb_clear_vlan(bond, vid);
 +	res = bond_del_vlan(bond, vid);
 +	if (res) {
 +		pr_err("%s: Error: Failed to remove vlan id %d\n",
 +		       bond_dev->name, vid);
 +		return res;
 +	}
  
  	return 0;
  }
@@@ -531,16 -388,16 +554,21 @@@ static void bond_del_vlans_from_slave(s
   */
  static int bond_set_carrier(struct bonding *bond)
  {
+ 	struct list_head *iter;
  	struct slave *slave;
 +	int i;
  
 -	if (list_empty(&bond->slave_list))
 +	if (bond->slave_cnt == 0)
  		goto down;
  
  	if (bond->params.mode == BOND_MODE_8023AD)
  		return bond_3ad_set_carrier(bond);
  
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		if (slave->link == BOND_LINK_UP) {
  			if (!netif_carrier_ok(bond->dev)) {
  				netif_carrier_on(bond->dev);
@@@ -681,8 -540,8 +711,13 @@@ static int bond_set_promiscuity(struct 
  		}
  	} else {
  		struct slave *slave;
++<<<<<<< HEAD
 +		int i;
 +		bond_for_each_slave(bond, slave, i) {
++=======
+ 
+ 		bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  			err = dev_set_promiscuity(slave->dev, inc);
  			if (err)
  				return err;
@@@ -705,8 -566,8 +742,13 @@@ static int bond_set_allmulti(struct bon
  		}
  	} else {
  		struct slave *slave;
++<<<<<<< HEAD
 +		int i;
 +		bond_for_each_slave(bond, slave, i) {
++=======
+ 
+ 		bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  			err = dev_set_allmulti(slave->dev, inc);
  			if (err)
  				return err;
@@@ -1272,10 -1057,10 +1314,15 @@@ static void bond_poll_controller(struc
  static void bond_netpoll_cleanup(struct net_device *bond_dev)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
+ 	struct list_head *iter;
  	struct slave *slave;
 +	int i;
  
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i)
++=======
+ 	bond_for_each_slave(bond, slave, iter)
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		if (IS_UP(slave->dev))
  			slave_disable_netpoll(slave);
  }
@@@ -1283,10 -1068,11 +1330,15 @@@
  static int bond_netpoll_setup(struct net_device *dev, struct netpoll_info *ni, gfp_t gfp)
  {
  	struct bonding *bond = netdev_priv(dev);
+ 	struct list_head *iter;
  	struct slave *slave;
 -	int err = 0;
 +	int i, err = 0;
  
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		err = slave_enable_netpoll(slave);
  		if (err) {
  			bond_netpoll_cleanup(dev);
@@@ -1311,20 -1097,24 +1363,25 @@@ static void bond_netpoll_cleanup(struc
  /*---------------------------------- IOCTL ----------------------------------*/
  
  static netdev_features_t bond_fix_features(struct net_device *dev,
 -					   netdev_features_t features)
 +	netdev_features_t features)
  {
 +	struct slave *slave;
  	struct bonding *bond = netdev_priv(dev);
+ 	struct list_head *iter;
  	netdev_features_t mask;
 -	struct slave *slave;
 +	int i;
  
 -	if (list_empty(&bond->slave_list)) {
 -		/* Disable adding VLANs to empty bond. But why? --mq */
 -		features |= NETIF_F_VLAN_CHALLENGED;
 -		return features;
 -	}
 +	read_lock(&bond->lock);
  
  	mask = features;
  	features &= ~NETIF_F_ONE_FOR_ALL;
  	features |= NETIF_F_ALL_FOR_ALL;
  
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		features = netdev_increment_features(features,
  						     slave->dev->features,
  						     mask);
@@@ -1341,21 -1130,19 +1398,31 @@@
  
  static void bond_compute_features(struct bonding *bond)
  {
 -	unsigned int flags, dst_release_flag = IFF_XMIT_DST_RELEASE;
 +	struct slave *slave;
 +	struct net_device *bond_dev = bond->dev;
  	netdev_features_t vlan_features = BOND_VLAN_FEATURES;
+ 	struct net_device *bond_dev = bond->dev;
+ 	struct list_head *iter;
+ 	struct slave *slave;
  	unsigned short max_hard_header_len = ETH_HLEN;
  	unsigned int gso_max_size = GSO_MAX_SIZE;
  	u16 gso_max_segs = GSO_MAX_SEGS;
++<<<<<<< HEAD
 +	int i;
 +	unsigned int flags, dst_release_flag = IFF_XMIT_DST_RELEASE;
++=======
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
 +
 +	read_lock(&bond->lock);
  
 -	if (list_empty(&bond->slave_list))
 +	if (!bond->first_slave)
  		goto done;
  
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		vlan_features = netdev_increment_features(vlan_features,
  			slave->dev->vlan_features, BOND_VLAN_FEATURES);
  
@@@ -2217,13 -2004,13 +2284,23 @@@ static int bond_info_query(struct net_d
  static int bond_slave_info_query(struct net_device *bond_dev, struct ifslave *info)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
++<<<<<<< HEAD
++=======
+ 	struct list_head *iter;
+ 	int i = 0, res = -ENODEV;
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  	struct slave *slave;
 +	int i, res = -ENODEV;
  
  	read_lock(&bond->lock);
++<<<<<<< HEAD
 +
 +	bond_for_each_slave(bond, slave, i) {
 +		if (i == (int)info->slave_id) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
+ 		if (i++ == (int)info->slave_id) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  			res = 0;
  			strcpy(info->slave_name, slave->dev->name);
  			info->link = slave->link;
@@@ -2243,13 -2029,14 +2320,22 @@@
  
  static int bond_miimon_inspect(struct bonding *bond)
  {
++<<<<<<< HEAD
++=======
+ 	int link_state, commit = 0;
+ 	struct list_head *iter;
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  	struct slave *slave;
 +	int i, link_state, commit = 0;
  	bool ignore_updelay;
  
  	ignore_updelay = !bond->curr_active_slave ? true : false;
  
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		slave->new_link = BOND_LINK_NOCHANGE;
  
  		link_state = bond_check_dev_link(bond, slave->dev, 0);
@@@ -2343,10 -2130,10 +2429,15 @@@
  
  static void bond_miimon_commit(struct bonding *bond)
  {
+ 	struct list_head *iter;
  	struct slave *slave;
 +	int i;
  
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		switch (slave->new_link) {
  		case BOND_LINK_NOCHANGE:
  			continue;
@@@ -2724,9 -2527,8 +2815,10 @@@ void bond_loadbalance_arp_mon(struct wo
  	struct bonding *bond = container_of(work, struct bonding,
  					    arp_work.work);
  	struct slave *slave, *oldcurrent;
+ 	struct list_head *iter;
  	int do_failover = 0;
 +	int delta_in_ticks, extra_ticks;
 +	int i;
  
  	read_lock(&bond->lock);
  
@@@ -2745,7 -2544,7 +2837,11 @@@
  	 * TODO: what about up/down delay in arp mode? it wasn't here before
  	 *       so it can wait
  	 */
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		unsigned long trans_start = dev_trans_start(slave->dev);
  
  		if (slave->link != BOND_LINK_UP) {
@@@ -2840,28 -2632,19 +2936,37 @@@ re_arm
   *
   * Called with bond->lock held for read.
   */
 -static int bond_ab_arp_inspect(struct bonding *bond)
 +static int bond_ab_arp_inspect(struct bonding *bond, int delta_in_ticks)
  {
++<<<<<<< HEAD
++=======
+ 	unsigned long trans_start, last_rx;
+ 	struct list_head *iter;
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  	struct slave *slave;
 -	int commit = 0;
 +	int i, commit = 0;
 +	unsigned long trans_start;
 +	int extra_ticks;
  
++<<<<<<< HEAD
 +	/* All the time comparisons below need some extra time. Otherwise, on
 +	 * fast networks the ARP probe/reply may arrive within the same jiffy
 +	 * as it was sent.  Then, the next time the ARP monitor is run, one
 +	 * arp_interval will already have passed in the comparisons.
 +	 */
 +	extra_ticks = delta_in_ticks / 2;
 +
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		slave->new_link = BOND_LINK_NOCHANGE;
 -		last_rx = slave_last_rx(bond, slave);
  
  		if (slave->link != BOND_LINK_UP) {
 -			if (bond_time_in_interval(bond, last_rx, 1)) {
 +			if (time_in_range(jiffies,
 +				slave_last_rx(bond, slave) - delta_in_ticks,
 +				slave_last_rx(bond, slave) + delta_in_ticks + extra_ticks)) {
 +
  				slave->new_link = BOND_LINK_UP;
  				commit++;
  			}
@@@ -2931,13 -2703,13 +3036,22 @@@
   *
   * Called with RTNL and bond->lock for read.
   */
 -static void bond_ab_arp_commit(struct bonding *bond)
 +static void bond_ab_arp_commit(struct bonding *bond, int delta_in_ticks)
  {
++<<<<<<< HEAD
++=======
+ 	unsigned long trans_start;
+ 	struct list_head *iter;
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  	struct slave *slave;
 +	int i;
 +	unsigned long trans_start;
  
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		switch (slave->new_link) {
  		case BOND_LINK_NOCHANGE:
  			continue;
@@@ -3402,14 -3173,14 +3516,19 @@@ static void bond_work_cancel_all(struc
  static int bond_open(struct net_device *bond_dev)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
+ 	struct list_head *iter;
  	struct slave *slave;
 +	int i;
  
  	/* reset slave->backup and slave->inactive */
  	read_lock(&bond->lock);
 -	if (!list_empty(&bond->slave_list)) {
 +	if (bond->slave_cnt > 0) {
  		read_lock(&bond->curr_slave_lock);
++<<<<<<< HEAD
 +		bond_for_each_slave(bond, slave, i) {
++=======
+ 		bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  			if ((bond->params.mode == BOND_MODE_ACTIVEBACKUP)
  				&& (slave != bond->curr_active_slave)) {
  				bond_set_slave_inactive_flags(slave);
@@@ -3469,14 -3240,13 +3588,19 @@@ static struct rtnl_link_stats64 *bond_g
  {
  	struct bonding *bond = netdev_priv(bond_dev);
  	struct rtnl_link_stats64 temp;
+ 	struct list_head *iter;
  	struct slave *slave;
 +	int i;
  
  	memset(stats, 0, sizeof(*stats));
  
  	read_lock_bh(&bond->lock);
++<<<<<<< HEAD
 +
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		const struct rtnl_link_stats64 *sstats =
  			dev_get_stats(slave->dev, &temp);
  
@@@ -3654,36 -3410,26 +3778,55 @@@ static void bond_change_rx_flags(struc
  				  bond_dev->flags & IFF_ALLMULTI ? 1 : -1);
  }
  
 -static void bond_set_rx_mode(struct net_device *bond_dev)
 +static void bond_set_multicast_list(struct net_device *bond_dev)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
++<<<<<<< HEAD
 +	struct netdev_hw_addr *ha;
 +	bool found;
++=======
+ 	struct list_head *iter;
+ 	struct slave *slave;
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  
 -	ASSERT_RTNL();
 +	read_lock(&bond->lock);
  
++<<<<<<< HEAD
 +	/* looking for addresses to add to slaves' mc list */
 +	netdev_for_each_mc_addr(ha, bond_dev) {
 +		found = bond_addr_in_mc_list(ha->addr, &bond->mc_list,
 +					     bond_dev->addr_len);
 +		if (!found)
 +			bond_mc_add(bond, ha->addr);
++=======
+ 	if (USES_PRIMARY(bond->params.mode)) {
+ 		slave = rtnl_dereference(bond->curr_active_slave);
+ 		if (slave) {
+ 			dev_uc_sync(slave->dev, bond_dev);
+ 			dev_mc_sync(slave->dev, bond_dev);
+ 		}
+ 	} else {
+ 		bond_for_each_slave(bond, slave, iter) {
+ 			dev_uc_sync_multiple(slave->dev, bond_dev);
+ 			dev_mc_sync_multiple(slave->dev, bond_dev);
+ 		}
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  	}
 +
 +	/* looking for addresses to delete from slaves' list */
 +	netdev_hw_addr_list_for_each(ha, &bond->mc_list) {
 +		found = bond_addr_in_mc_list(ha->addr, &bond_dev->mc,
 +					     bond_dev->addr_len);
 +		if (!found)
 +			bond_mc_del(bond, ha->addr);
 +	}
 +
 +	/* save master's multicast list */
 +	__hw_addr_flush(&bond->mc_list);
 +	__hw_addr_add_multiple(&bond->mc_list, &bond_dev->mc,
 +			       bond_dev->addr_len, NETDEV_HW_ADDR_T_MULTICAST);
 +
 +	read_unlock(&bond->lock);
  }
  
  static int bond_neigh_init(struct neighbour *n)
@@@ -3747,9 -3492,9 +3890,14 @@@ static int bond_neigh_setup(struct net_
  static int bond_change_mtu(struct net_device *bond_dev, int new_mtu)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
++<<<<<<< HEAD
 +	struct slave *slave, *stop_at;
++=======
+ 	struct slave *slave, *rollback_slave;
+ 	struct list_head *iter;
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  	int res = 0;
 +	int i;
  
  	pr_debug("bond=%p, name=%s, new_mtu=%d\n", bond,
  		 (bond_dev ? bond_dev->name : "None"), new_mtu);
@@@ -3769,10 -3514,10 +3917,14 @@@
  	 * call to the base driver.
  	 */
  
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		pr_debug("s %p s->p %p c_m %p\n",
  			 slave,
 -			 bond_prev_slave(bond, slave),
 +			 slave->prev,
  			 slave->dev->netdev_ops->ndo_change_mtu);
  
  		res = dev_set_mtu(slave->dev, new_mtu);
@@@ -3797,14 -3542,16 +3949,18 @@@
  
  unwind:
  	/* unwind from head to the slave that failed */
++<<<<<<< HEAD
 +	stop_at = slave;
 +	bond_for_each_slave_from_to(bond, slave, i, bond->first_slave, stop_at) {
++=======
+ 	bond_for_each_slave(bond, rollback_slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		int tmp_res;
  
 -		if (rollback_slave == slave)
 -			break;
 -
 -		tmp_res = dev_set_mtu(rollback_slave->dev, bond_dev->mtu);
 +		tmp_res = dev_set_mtu(slave->dev, bond_dev->mtu);
  		if (tmp_res) {
  			pr_debug("unwind err %d dev %s\n",
 -				 tmp_res, rollback_slave->dev->name);
 +				 tmp_res, slave->dev->name);
  		}
  	}
  
@@@ -3821,10 -3568,10 +3977,14 @@@
  static int bond_set_mac_address(struct net_device *bond_dev, void *addr)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
 -	struct slave *slave, *rollback_slave;
  	struct sockaddr *sa = addr, tmp_sa;
++<<<<<<< HEAD
 +	struct slave *slave, *stop_at;
++=======
+ 	struct list_head *iter;
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  	int res = 0;
 +	int i;
  
  	if (bond->params.mode == BOND_MODE_ALB)
  		return bond_alb_set_mac_address(bond_dev, addr);
@@@ -3857,7 -3604,7 +4017,11 @@@
  	 * call to the base driver.
  	 */
  
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		const struct net_device_ops *slave_ops = slave->dev->netdev_ops;
  		pr_debug("slave %p %s\n", slave, slave->dev->name);
  
@@@ -3889,20 -3636,62 +4053,67 @@@ unwind
  	tmp_sa.sa_family = bond_dev->type;
  
  	/* unwind from head to the slave that failed */
++<<<<<<< HEAD
 +	stop_at = slave;
 +	bond_for_each_slave_from_to(bond, slave, i, bond->first_slave, stop_at) {
++=======
+ 	bond_for_each_slave(bond, rollback_slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		int tmp_res;
  
 -		if (rollback_slave == slave)
 -			break;
 -
 -		tmp_res = dev_set_mac_address(rollback_slave->dev, &tmp_sa);
 +		tmp_res = dev_set_mac_address(slave->dev, &tmp_sa);
  		if (tmp_res) {
  			pr_debug("unwind err %d dev %s\n",
 -				 tmp_res, rollback_slave->dev->name);
 +				 tmp_res, slave->dev->name);
  		}
  	}
  
  	return res;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * bond_xmit_slave_id - transmit skb through slave with slave_id
+  * @bond: bonding device that is transmitting
+  * @skb: buffer to transmit
+  * @slave_id: slave id up to slave_cnt-1 through which to transmit
+  *
+  * This function tries to transmit through slave with slave_id but in case
+  * it fails, it tries to find the first available slave for transmission.
+  * The skb is consumed in all cases, thus the function is void.
+  */
+ void bond_xmit_slave_id(struct bonding *bond, struct sk_buff *skb, int slave_id)
+ {
+ 	struct list_head *iter;
+ 	struct slave *slave;
+ 	int i = slave_id;
+ 
+ 	/* Here we start from the slave with slave_id */
+ 	bond_for_each_slave_rcu(bond, slave, iter) {
+ 		if (--i < 0) {
+ 			if (slave_can_tx(slave)) {
+ 				bond_dev_queue_xmit(bond, skb, slave->dev);
+ 				return;
+ 			}
+ 		}
+ 	}
+ 
+ 	/* Here we start from the first slave up to slave_id */
+ 	i = slave_id;
+ 	bond_for_each_slave_rcu(bond, slave, iter) {
+ 		if (--i < 0)
+ 			break;
+ 		if (slave_can_tx(slave)) {
+ 			bond_dev_queue_xmit(bond, skb, slave->dev);
+ 			return;
+ 		}
+ 	}
+ 	/* no slave that can tx has been found */
+ 	kfree_skb(skb);
+ }
+ 
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  static int bond_xmit_roundrobin(struct sk_buff *skb, struct net_device *bond_dev)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
@@@ -4023,8 -3757,9 +4234,13 @@@ static int bond_xmit_broadcast(struct s
  {
  	struct bonding *bond = netdev_priv(bond_dev);
  	struct slave *slave = NULL;
+ 	struct list_head *iter;
  
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave) {
++=======
+ 	bond_for_each_slave_rcu(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		if (bond_is_last_slave(bond, slave))
  			break;
  		if (IS_UP(slave->dev) && slave->link == BOND_LINK_UP) {
@@@ -4071,15 -3806,16 +4287,24 @@@ static void bond_set_xmit_hash_policy(s
  static inline int bond_slave_override(struct bonding *bond,
  				      struct sk_buff *skb)
  {
 +	int i, res = 1;
  	struct slave *slave = NULL;
  	struct slave *check_slave;
++<<<<<<< HEAD
++=======
+ 	struct list_head *iter;
+ 	int res = 1;
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  
  	if (!skb->queue_mapping)
  		return 1;
  
  	/* Find out if any slaves have the same mapping as this skb. */
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, check_slave, i) {
++=======
+ 	bond_for_each_slave_rcu(bond, check_slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		if (check_slave->queue_id == skb->queue_mapping) {
  			slave = check_slave;
  			break;
@@@ -4212,9 -3946,9 +4437,14 @@@ static int bond_ethtool_get_settings(st
  				     struct ethtool_cmd *ecmd)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
++<<<<<<< HEAD
++=======
+ 	unsigned long speed = 0;
+ 	struct list_head *iter;
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  	struct slave *slave;
 +	int i;
 +	unsigned long speed = 0;
  
  	ecmd->duplex = DUPLEX_UNKNOWN;
  	ecmd->port = PORT_OTHER;
@@@ -4225,7 -3959,7 +4455,11 @@@
  	 * this is an accurate maximum.
  	 */
  	read_lock(&bond->lock);
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		if (SLAVE_IS_OK(slave)) {
  			if (slave->speed != SPEED_UNKNOWN)
  				speed += slave->speed;
diff --cc drivers/net/bonding/bond_procfs.c
index 4060d41f0ee7,7af5646e4410..000000000000
--- a/drivers/net/bonding/bond_procfs.c
+++ b/drivers/net/bonding/bond_procfs.c
@@@ -10,9 -10,9 +10,13 @@@ static void *bond_info_seq_start(struc
  	__acquires(&bond->lock)
  {
  	struct bonding *bond = seq->private;
- 	loff_t off = 0;
+ 	struct list_head *iter;
  	struct slave *slave;
++<<<<<<< HEAD
 +	int i;
++=======
+ 	loff_t off = 0;
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  
  	/* make sure the bond won't be taken away */
  	rcu_read_lock();
@@@ -21,10 -21,9 +25,14 @@@
  	if (*pos == 0)
  		return SEQ_START_TOKEN;
  
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave(bond, slave, iter)
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		if (++off == *pos)
  			return slave;
 +	}
  
  	return NULL;
  }
diff --cc drivers/net/bonding/bond_sysfs.c
index 739d4dbe8629,e747415b5cb0..000000000000
--- a/drivers/net/bonding/bond_sysfs.c
+++ b/drivers/net/bonding/bond_sysfs.c
@@@ -209,12 -209,13 +209,21 @@@ void bond_destroy_slave_symlinks(struc
  static ssize_t bonding_show_slaves(struct device *d,
  				   struct device_attribute *attr, char *buf)
  {
++<<<<<<< HEAD
++=======
+ 	struct bonding *bond = to_bond(d);
+ 	struct list_head *iter;
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  	struct slave *slave;
 -	int res = 0;
 +	int i, res = 0;
 +	struct bonding *bond = to_bond(d);
  
  	read_lock(&bond->lock);
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		if (res > (PAGE_SIZE - IFNAMSIZ)) {
  			/* not enough space for another interface name */
  			if ((PAGE_SIZE - res) > 10)
@@@ -688,7 -690,7 +698,11 @@@ static ssize_t bonding_store_arp_target
  			 &newtarget);
  		/* not to race with bond_arp_rcv */
  		write_lock_bh(&bond->lock);
++<<<<<<< HEAD
 +		bond_for_each_slave(bond, slave, i)
++=======
+ 		bond_for_each_slave(bond, slave, iter)
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  			slave->target_last_arp_rx[ind] = jiffies;
  		targets[ind] = newtarget;
  		write_unlock_bh(&bond->lock);
@@@ -714,7 -716,7 +728,11 @@@
  			&newtarget);
  
  		write_lock_bh(&bond->lock);
++<<<<<<< HEAD
 +		bond_for_each_slave(bond, slave, i) {
++=======
+ 		bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  			targets_rx = slave->target_last_arp_rx;
  			j = ind;
  			for (; (j < BOND_MAX_ARP_TARGETS-1) && targets[j+1]; j++)
@@@ -1111,10 -1112,10 +1129,11 @@@ static ssize_t bonding_store_primary(st
  				     struct device_attribute *attr,
  				     const char *buf, size_t count)
  {
 +	int i;
 +	struct slave *slave;
  	struct bonding *bond = to_bond(d);
+ 	struct list_head *iter;
  	char ifname[IFNAMSIZ];
 -	struct slave *slave;
  
  	if (!rtnl_trylock())
  		return restart_syscall();
@@@ -1140,7 -1141,7 +1159,11 @@@
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		if (strncmp(slave->dev->name, ifname, IFNAMSIZ) == 0) {
  			pr_info("%s: Setting %s as primary slave.\n",
  				bond->dev->name, slave->dev->name);
@@@ -1286,11 -1287,9 +1309,12 @@@ static ssize_t bonding_store_active_sla
  					  struct device_attribute *attr,
  					  const char *buf, size_t count)
  {
 -	struct slave *slave, *old_active, *new_active;
 +	int i;
 +	struct slave *slave;
 +	struct slave *old_active = NULL;
 +	struct slave *new_active = NULL;
  	struct bonding *bond = to_bond(d);
+ 	struct list_head *iter;
  	char ifname[IFNAMSIZ];
  
  	if (!rtnl_trylock())
@@@ -1317,7 -1317,7 +1341,11 @@@
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		if (strncmp(slave->dev->name, ifname, IFNAMSIZ) == 0) {
  			old_active = bond->curr_active_slave;
  			new_active = slave;
@@@ -1501,15 -1496,16 +1529,24 @@@ static ssize_t bonding_show_queue_id(st
  				     struct device_attribute *attr,
  				     char *buf)
  {
++<<<<<<< HEAD
++=======
+ 	struct bonding *bond = to_bond(d);
+ 	struct list_head *iter;
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  	struct slave *slave;
 -	int res = 0;
 +	int i, res = 0;
 +	struct bonding *bond = to_bond(d);
  
  	if (!rtnl_trylock())
  		return restart_syscall();
  
  	read_lock(&bond->lock);
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		if (res > (PAGE_SIZE - IFNAMSIZ - 6)) {
  			/* not enough space for another interface_name:queue_id pair */
  			if ((PAGE_SIZE - res) > 10)
@@@ -1537,8 -1534,9 +1574,9 @@@ static ssize_t bonding_store_queue_id(s
  {
  	struct slave *slave, *update_slave;
  	struct bonding *bond = to_bond(d);
+ 	struct list_head *iter;
  	u16 qid;
 -	int ret = count;
 +	int i, ret = count;
  	char *delim;
  	struct net_device *sdev = NULL;
  
@@@ -1573,7 -1571,7 +1611,11 @@@
  
  	/* Search for thes slave and check for duplicate qids */
  	update_slave = NULL;
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		if (sdev == slave->dev)
  			/*
  			 * We don't need to check the matching
@@@ -1625,8 -1623,9 +1667,13 @@@ static ssize_t bonding_store_slaves_act
  					   struct device_attribute *attr,
  					   const char *buf, size_t count)
  {
 +	int i, new_value, ret = count;
  	struct bonding *bond = to_bond(d);
++<<<<<<< HEAD
++=======
+ 	int new_value, ret = count;
+ 	struct list_head *iter;
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  	struct slave *slave;
  
  	if (sscanf(buf, "%d", &new_value) != 1) {
@@@ -1649,7 -1648,7 +1696,11 @@@
  	}
  
  	read_lock(&bond->lock);
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		if (!bond_is_active_slave(slave)) {
  			if (new_value)
  				slave->inactive = 0;
diff --cc drivers/net/bonding/bonding.h
index 788e19ed5f58,96f571dd0bb6..000000000000
--- a/drivers/net/bonding/bonding.h
+++ b/drivers/net/bonding/bonding.h
@@@ -80,37 -102,24 +80,53 @@@
   *
   * Caller must hold bond->lock
   */
 -#define bond_for_each_slave_from(bond, pos, cnt, start) \
 -	for (cnt = 0, pos = start; pos && cnt < (bond)->slave_cnt; \
 -	     cnt++, pos = bond_next_slave(bond, pos))
 +#define bond_for_each_slave_from(bond, pos, cnt, start)	\
 +	for (cnt = 0, pos = start;				\
 +	     cnt < (bond)->slave_cnt;				\
 +             cnt++, pos = (pos)->next)
 +
 +/**
++<<<<<<< HEAD
 + * bond_for_each_slave_from_to - iterate the slaves list from start point to stop point
 + * @bond:	the bond holding this list.
 + * @pos:	current slave.
 + * @cnt:	counter for number max of moves
 + * @start:	start point.
 + * @stop:	stop point.
 + *
 + * Caller must hold bond->lock
 + */
 +#define bond_for_each_slave_from_to(bond, pos, cnt, start, stop)	\
 +	for (cnt = 0, pos = start;					\
 +	     ((cnt < (bond)->slave_cnt) && (pos != (stop)->next));	\
 +             cnt++, pos = (pos)->next)
  
  /**
 + * bond_for_each_slave - iterate the slaves list from head
 + * @bond:	the bond holding this list.
 + * @pos:	current slave.
 + * @cnt:	counter for max number of moves
 + *
 + * Caller must hold bond->lock
 + */
 +#define bond_for_each_slave(bond, pos, cnt)	\
 +		bond_for_each_slave_from(bond, pos, cnt, (bond)->first_slave)
 +
++=======
+  * bond_for_each_slave - iterate over all slaves
+  * @bond:	the bond holding this list
+  * @pos:	current slave
+  * @iter:	list_head * iterator
+  *
+  * Caller must hold bond->lock
+  */
+ #define bond_for_each_slave(bond, pos, iter) \
+ 	netdev_for_each_lower_private((bond)->dev, pos, iter)
+ 
+ /* Caller must have rcu_read_lock */
+ #define bond_for_each_slave_rcu(bond, pos, iter) \
+ 	netdev_for_each_lower_private_rcu((bond)->dev, pos, iter)
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  
  #ifdef CONFIG_NET_POLL_CONTROLLER
  extern atomic_t netpoll_block_tx;
@@@ -475,10 -477,10 +491,17 @@@ static inline void bond_destroy_proc_di
  static inline struct slave *bond_slave_has_mac(struct bonding *bond,
  					       const u8 *mac)
  {
++<<<<<<< HEAD
 +	int i = 0;
 +	struct slave *tmp;
 +
 +	bond_for_each_slave(bond, tmp, i)
++=======
+ 	struct list_head *iter;
+ 	struct slave *tmp;
+ 
+ 	bond_for_each_slave(bond, tmp, iter)
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  		if (ether_addr_equal_64bits(mac, tmp->dev->dev_addr))
  			return tmp;
  
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
index 9df6656ca8da,85d0cda5fbfa..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@@ -4259,8 -3982,8 +4259,9 @@@ static int cxgb4_inet6addr_handler(stru
  	struct inet6_ifaddr *ifa = data;
  	struct net_device *event_dev;
  	int ret = NOTIFY_DONE;
 +	int cnt;
  	struct bonding *bond = netdev_priv(ifa->idev->dev);
+ 	struct list_head *iter;
  	struct slave *slave;
  	struct pci_dev *first_pdev = NULL;
  
@@@ -4273,7 -3996,7 +4274,11 @@@
  		 * in all of them only once.
  		 */
  		read_lock(&bond->lock);
++<<<<<<< HEAD
 +		bond_for_each_slave(bond, slave, cnt) {
++=======
+ 		bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 9caff1e7b761 (bonding: make bond_for_each_slave() use lower neighbour's private)
  			if (!first_pdev) {
  				ret = clip_add(slave->dev, ifa, event);
  				/* If clip_add is success then only initialize
* Unmerged path drivers/net/bonding/bond_3ad.c
* Unmerged path drivers/net/bonding/bond_alb.c
* Unmerged path drivers/net/bonding/bond_main.c
* Unmerged path drivers/net/bonding/bond_procfs.c
* Unmerged path drivers/net/bonding/bond_sysfs.c
* Unmerged path drivers/net/bonding/bonding.h
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
