xfrm.h: Remove extern from function prototypes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] xfrm: Remove extern from function prototypes (Phil Sutter) [1243591]
Rebuild_FUZZ: 97.78%
commit-author Joe Perches <joe@perches.com>
commit d511337a1eda35ac9d8e373e1cca17d6182a75b7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/d511337a.failed

There are a mix of function prototypes with and without extern
in the kernel sources.  Standardize on not using extern for
function prototypes.

Function prototypes don't need to be written with extern.
extern is assumed by the compiler.  Its use is as unnecessary as
using auto to declare automatic/local variables in a block.

	Signed-off-by: Joe Perches <joe@perches.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d511337a1eda35ac9d8e373e1cca17d6182a75b7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/xfrm.h
diff --cc include/net/xfrm.h
index 3060c2bd32b0,765746192724..000000000000
--- a/include/net/xfrm.h
+++ b/include/net/xfrm.h
@@@ -344,12 -343,15 +346,19 @@@ struct xfrm_state_afinfo 
  						  struct sk_buff *skb);
  	int			(*transport_finish)(struct sk_buff *skb,
  						    int async);
 -	void			(*local_error)(struct sk_buff *skb, u32 mtu);
  };
  
++<<<<<<< HEAD
 +extern int xfrm_state_register_afinfo(struct xfrm_state_afinfo *afinfo);
 +extern int xfrm_state_unregister_afinfo(struct xfrm_state_afinfo *afinfo);
++=======
+ int xfrm_state_register_afinfo(struct xfrm_state_afinfo *afinfo);
+ int xfrm_state_unregister_afinfo(struct xfrm_state_afinfo *afinfo);
+ struct xfrm_state_afinfo *xfrm_state_get_afinfo(unsigned int family);
+ void xfrm_state_put_afinfo(struct xfrm_state_afinfo *afinfo);
++>>>>>>> d511337a1eda (xfrm.h: Remove extern from function prototypes)
  
- extern void xfrm_state_delete_tunnel(struct xfrm_state *x);
+ void xfrm_state_delete_tunnel(struct xfrm_state *x);
  
  struct xfrm_type {
  	char			*description;
@@@ -595,23 -597,9 +604,23 @@@ struct xfrm_mgr 
  					   const struct xfrm_kmaddress *k);
  };
  
- extern int xfrm_register_km(struct xfrm_mgr *km);
- extern int xfrm_unregister_km(struct xfrm_mgr *km);
+ int xfrm_register_km(struct xfrm_mgr *km);
+ int xfrm_unregister_km(struct xfrm_mgr *km);
  
 +struct xfrm_tunnel_skb_cb {
 +	union {
 +		struct inet_skb_parm h4;
 +		struct inet6_skb_parm h6;
 +	} header;
 +
 +	union {
 +		struct ip_tunnel *ip4;
 +		struct ip6_tnl *ip6;
 +	} tunnel;
 +};
 +
 +#define XFRM_TUNNEL_SKB_CB(__skb) ((struct xfrm_tunnel_skb_cb *)&((__skb)->cb[0]))
 +
  /*
   * This structure is used for the duration where packets are being
   * transformed by IPsec.  As soon as the packet leaves IPsec the
@@@ -1485,71 -1464,68 +1494,129 @@@ struct xfrmk_spdinfo 
  	u32 spdhmcnt;
  };
  
++<<<<<<< HEAD
 +extern struct xfrm_state *xfrm_find_acq_byseq(struct net *net, u32 mark,
 +					      u32 seq);
 +extern int xfrm_state_delete(struct xfrm_state *x);
 +extern int xfrm_state_flush(struct net *net, u8 proto, struct xfrm_audit *audit_info);
 +extern void xfrm_sad_getinfo(struct net *net, struct xfrmk_sadinfo *si);
 +extern void xfrm_spd_getinfo(struct net *net, struct xfrmk_spdinfo *si);
 +extern u32 xfrm_replay_seqhi(struct xfrm_state *x, __be32 net_seq);
 +extern int xfrm_init_replay(struct xfrm_state *x);
 +extern int xfrm_state_mtu(struct xfrm_state *x, int mtu);
 +extern int __xfrm_init_state(struct xfrm_state *x, bool init_replay);
 +extern int xfrm_init_state(struct xfrm_state *x);
 +extern int xfrm_prepare_input(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm_input(struct sk_buff *skb, int nexthdr, __be32 spi,
 +		      int encap_type);
 +extern int xfrm_input_resume(struct sk_buff *skb, int nexthdr);
 +extern int xfrm_output_resume(struct sk_buff *skb, int err);
 +extern int xfrm_output(struct sk_buff *skb);
 +extern int xfrm_inner_extract_output(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm4_extract_header(struct sk_buff *skb);
 +extern int xfrm4_extract_input(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm4_rcv_encap(struct sk_buff *skb, int nexthdr, __be32 spi,
 +			   int encap_type);
 +extern int xfrm4_transport_finish(struct sk_buff *skb, int async);
 +extern int xfrm4_rcv(struct sk_buff *skb);
++=======
+ struct xfrm_state *xfrm_find_acq_byseq(struct net *net, u32 mark, u32 seq);
+ int xfrm_state_delete(struct xfrm_state *x);
+ int xfrm_state_flush(struct net *net, u8 proto, struct xfrm_audit *audit_info);
+ void xfrm_sad_getinfo(struct net *net, struct xfrmk_sadinfo *si);
+ void xfrm_spd_getinfo(struct net *net, struct xfrmk_spdinfo *si);
+ u32 xfrm_replay_seqhi(struct xfrm_state *x, __be32 net_seq);
+ int xfrm_init_replay(struct xfrm_state *x);
+ int xfrm_state_mtu(struct xfrm_state *x, int mtu);
+ int __xfrm_init_state(struct xfrm_state *x, bool init_replay);
+ int xfrm_init_state(struct xfrm_state *x);
+ int xfrm_prepare_input(struct xfrm_state *x, struct sk_buff *skb);
+ int xfrm_input(struct sk_buff *skb, int nexthdr, __be32 spi, int encap_type);
+ int xfrm_input_resume(struct sk_buff *skb, int nexthdr);
+ int xfrm_output_resume(struct sk_buff *skb, int err);
+ int xfrm_output(struct sk_buff *skb);
+ int xfrm_inner_extract_output(struct xfrm_state *x, struct sk_buff *skb);
+ void xfrm_local_error(struct sk_buff *skb, int mtu);
+ int xfrm4_extract_header(struct sk_buff *skb);
+ int xfrm4_extract_input(struct xfrm_state *x, struct sk_buff *skb);
+ int xfrm4_rcv_encap(struct sk_buff *skb, int nexthdr, __be32 spi,
+ 		    int encap_type);
+ int xfrm4_transport_finish(struct sk_buff *skb, int async);
+ int xfrm4_rcv(struct sk_buff *skb);
++>>>>>>> d511337a1eda (xfrm.h: Remove extern from function prototypes)
  
  static inline int xfrm4_rcv_spi(struct sk_buff *skb, int nexthdr, __be32 spi)
  {
 -	return xfrm4_rcv_encap(skb, nexthdr, spi, 0);
 -}
 -
 +	XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4 = NULL;
 +	XFRM_SPI_SKB_CB(skb)->family = AF_INET;
 +	XFRM_SPI_SKB_CB(skb)->daddroff = offsetof(struct iphdr, daddr);
 +	return xfrm_input(skb, nexthdr, spi, 0);
 +}
 +
++<<<<<<< HEAD
 +extern int xfrm4_extract_output(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm4_prepare_output(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm4_output(struct sock *sk, struct sk_buff *skb);
 +extern int xfrm4_output_finish(struct sk_buff *skb);
 +extern int xfrm4_rcv_cb(struct sk_buff *skb, u8 protocol, int err);
 +extern int xfrm4_protocol_register(struct xfrm4_protocol *handler, unsigned char protocol);
 +extern int xfrm4_protocol_deregister(struct xfrm4_protocol *handler, unsigned char protocol);
 +extern int xfrm4_tunnel_register(struct xfrm_tunnel *handler, unsigned short family);
 +extern int xfrm4_tunnel_deregister(struct xfrm_tunnel *handler, unsigned short family);
 +extern int xfrm4_mode_tunnel_input_register(struct xfrm_tunnel_notifier *handler);
 +extern int xfrm4_mode_tunnel_input_deregister(struct xfrm_tunnel_notifier *handler);
 +extern int xfrm6_extract_header(struct sk_buff *skb);
 +extern int xfrm6_extract_input(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm6_rcv_spi(struct sk_buff *skb, int nexthdr, __be32 spi);
 +extern int xfrm6_transport_finish(struct sk_buff *skb, int async);
 +extern int xfrm6_rcv(struct sk_buff *skb);
 +extern int xfrm6_input_addr(struct sk_buff *skb, xfrm_address_t *daddr,
 +			    xfrm_address_t *saddr, u8 proto);
 +extern int xfrm6_tunnel_register(struct xfrm6_tunnel *handler, unsigned short family);
 +extern int xfrm6_tunnel_deregister(struct xfrm6_tunnel *handler, unsigned short family);
 +extern __be32 xfrm6_tunnel_alloc_spi(struct net *net, xfrm_address_t *saddr);
 +extern __be32 xfrm6_tunnel_spi_lookup(struct net *net, const xfrm_address_t *saddr);
 +extern int xfrm6_extract_output(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm6_prepare_output(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm6_output(struct sock *sk, struct sk_buff *skb);
 +extern int xfrm6_output_finish(struct sk_buff *skb);
 +extern int xfrm6_find_1stfragopt(struct xfrm_state *x, struct sk_buff *skb,
 +				 u8 **prevhdr);
++=======
+ int xfrm4_extract_output(struct xfrm_state *x, struct sk_buff *skb);
+ int xfrm4_prepare_output(struct xfrm_state *x, struct sk_buff *skb);
+ int xfrm4_output(struct sk_buff *skb);
+ int xfrm4_output_finish(struct sk_buff *skb);
+ int xfrm4_tunnel_register(struct xfrm_tunnel *handler, unsigned short family);
+ int xfrm4_tunnel_deregister(struct xfrm_tunnel *handler, unsigned short family);
+ int xfrm4_mode_tunnel_input_register(struct xfrm_tunnel *handler);
+ int xfrm4_mode_tunnel_input_deregister(struct xfrm_tunnel *handler);
+ void xfrm4_local_error(struct sk_buff *skb, u32 mtu);
+ int xfrm6_extract_header(struct sk_buff *skb);
+ int xfrm6_extract_input(struct xfrm_state *x, struct sk_buff *skb);
+ int xfrm6_rcv_spi(struct sk_buff *skb, int nexthdr, __be32 spi);
+ int xfrm6_transport_finish(struct sk_buff *skb, int async);
+ int xfrm6_rcv(struct sk_buff *skb);
+ int xfrm6_input_addr(struct sk_buff *skb, xfrm_address_t *daddr,
+ 		     xfrm_address_t *saddr, u8 proto);
+ int xfrm6_tunnel_register(struct xfrm6_tunnel *handler, unsigned short family);
+ int xfrm6_tunnel_deregister(struct xfrm6_tunnel *handler,
+ 			    unsigned short family);
+ __be32 xfrm6_tunnel_alloc_spi(struct net *net, xfrm_address_t *saddr);
+ __be32 xfrm6_tunnel_spi_lookup(struct net *net, const xfrm_address_t *saddr);
+ int xfrm6_extract_output(struct xfrm_state *x, struct sk_buff *skb);
+ int xfrm6_prepare_output(struct xfrm_state *x, struct sk_buff *skb);
+ int xfrm6_output(struct sk_buff *skb);
+ int xfrm6_output_finish(struct sk_buff *skb);
+ int xfrm6_find_1stfragopt(struct xfrm_state *x, struct sk_buff *skb,
+ 			  u8 **prevhdr);
+ void xfrm6_local_error(struct sk_buff *skb, u32 mtu);
++>>>>>>> d511337a1eda (xfrm.h: Remove extern from function prototypes)
  
  #ifdef CONFIG_XFRM
- extern int xfrm4_udp_encap_rcv(struct sock *sk, struct sk_buff *skb);
- extern int xfrm_user_policy(struct sock *sk, int optname, u8 __user *optval, int optlen);
+ int xfrm4_udp_encap_rcv(struct sock *sk, struct sk_buff *skb);
+ int xfrm_user_policy(struct sock *sk, int optname,
+ 		     u8 __user *optval, int optlen);
  #else
  static inline int xfrm_user_policy(struct sock *sk, int optname, u8 __user *optval, int optlen)
  {
* Unmerged path include/net/xfrm.h
