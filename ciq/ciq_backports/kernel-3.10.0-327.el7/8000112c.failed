crypto: nx - Check for bogus firmware properties

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [crypto] nx - Check for bogus firmware properties (Herbert Xu) [1190103]
Rebuild_FUZZ: 90.91%
commit-author Herbert Xu <herbert@gondor.apana.org.au>
commit 8000112cedb8743bad67997a96dc94877a36ce0f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/8000112c.failed

The nx driver reads two crucial paramters from the firmware for
each crypto algorithm, the maximum SG list length and byte limit.
Unfortunately those two parameters may be bogus, or worse they
may be absent altogether.  When this happens the algorithms will
still register successfully but will fail when used or tested.

This patch adds checks to report any firmware entries which are
found to be bogus, and avoid registering algorithms which have
bogus parameters.  A warning is also printed when an algorithm
is not registered because of this as there may have been no firmware
entries for it at all.

	Reported-by: Ondrej Mori≈° <omoris@redhat.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit 8000112cedb8743bad67997a96dc94877a36ce0f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/nx/nx.c
diff --cc drivers/crypto/nx/nx.c
index 5533fe31c90d,f6198f29a4a8..000000000000
--- a/drivers/crypto/nx/nx.c
+++ b/drivers/crypto/nx/nx.c
@@@ -469,11 -604,11 +543,19 @@@ static int nx_register_algs(void
  	if (rc)
  		goto out_unreg_ctr;
  
++<<<<<<< HEAD
 +	rc = crypto_register_alg(&nx_gcm_aes_alg);
 +	if (rc)
 +		goto out_unreg_ctr3686;
 +
 +	rc = crypto_register_alg(&nx_gcm4106_aes_alg);
++=======
+ 	rc = nx_register_aead(&nx_gcm_aes_alg, NX_FC_AES, NX_MODE_AES_GCM);
+ 	if (rc)
+ 		goto out_unreg_ctr3686;
+ 
+ 	rc = nx_register_aead(&nx_gcm4106_aes_alg, NX_FC_AES, NX_MODE_AES_GCM);
++>>>>>>> 8000112cedb8 (crypto: nx - Check for bogus firmware properties)
  	if (rc)
  		goto out_unreg_gcm;
  
@@@ -500,25 -638,27 +585,33 @@@
  	goto out;
  
  out_unreg_s512:
- 	crypto_unregister_shash(&nx_shash_sha512_alg);
+ 	nx_unregister_shash(&nx_shash_sha512_alg, NX_FC_SHA, NX_MODE_SHA,
+ 			    NX_PROPS_SHA512);
  out_unreg_s256:
- 	crypto_unregister_shash(&nx_shash_sha256_alg);
+ 	nx_unregister_shash(&nx_shash_sha256_alg, NX_FC_SHA, NX_MODE_SHA,
+ 			    NX_PROPS_SHA256);
  out_unreg_ccm4309:
- 	crypto_unregister_alg(&nx_ccm4309_aes_alg);
+ 	nx_unregister_alg(&nx_ccm4309_aes_alg, NX_FC_AES, NX_MODE_AES_CCM);
  out_unreg_ccm:
- 	crypto_unregister_alg(&nx_ccm_aes_alg);
+ 	nx_unregister_alg(&nx_ccm_aes_alg, NX_FC_AES, NX_MODE_AES_CCM);
  out_unreg_gcm4106:
++<<<<<<< HEAD
 +	crypto_unregister_alg(&nx_gcm4106_aes_alg);
 +out_unreg_gcm:
 +	crypto_unregister_alg(&nx_gcm_aes_alg);
++=======
+ 	nx_unregister_aead(&nx_gcm4106_aes_alg, NX_FC_AES, NX_MODE_AES_GCM);
+ out_unreg_gcm:
+ 	nx_unregister_aead(&nx_gcm_aes_alg, NX_FC_AES, NX_MODE_AES_GCM);
++>>>>>>> 8000112cedb8 (crypto: nx - Check for bogus firmware properties)
  out_unreg_ctr3686:
- 	crypto_unregister_alg(&nx_ctr3686_aes_alg);
+ 	nx_unregister_alg(&nx_ctr3686_aes_alg, NX_FC_AES, NX_MODE_AES_CTR);
  out_unreg_ctr:
- 	crypto_unregister_alg(&nx_ctr_aes_alg);
+ 	nx_unregister_alg(&nx_ctr_aes_alg, NX_FC_AES, NX_MODE_AES_CTR);
  out_unreg_cbc:
- 	crypto_unregister_alg(&nx_cbc_aes_alg);
+ 	nx_unregister_alg(&nx_cbc_aes_alg, NX_FC_AES, NX_MODE_AES_CBC);
  out_unreg_ecb:
- 	crypto_unregister_alg(&nx_ecb_aes_alg);
+ 	nx_unregister_alg(&nx_ecb_aes_alg, NX_FC_AES, NX_MODE_AES_ECB);
  out:
  	return rc;
  }
@@@ -657,17 -804,24 +750,38 @@@ static int nx_remove(struct vio_dev *vi
  	if (nx_driver.of.status == NX_OKAY) {
  		NX_DEBUGFS_FINI(&nx_driver);
  
++<<<<<<< HEAD
 +		crypto_unregister_alg(&nx_ccm_aes_alg);
 +		crypto_unregister_alg(&nx_ccm4309_aes_alg);
 +		crypto_unregister_alg(&nx_gcm_aes_alg);
 +		crypto_unregister_alg(&nx_gcm4106_aes_alg);
 +		crypto_unregister_alg(&nx_ctr_aes_alg);
 +		crypto_unregister_alg(&nx_ctr3686_aes_alg);
 +		crypto_unregister_alg(&nx_cbc_aes_alg);
 +		crypto_unregister_alg(&nx_ecb_aes_alg);
 +		crypto_unregister_shash(&nx_shash_sha256_alg);
 +		crypto_unregister_shash(&nx_shash_sha512_alg);
 +		crypto_unregister_shash(&nx_shash_aes_xcbc_alg);
++=======
+ 		nx_unregister_shash(&nx_shash_aes_xcbc_alg,
+ 				    NX_FC_AES, NX_MODE_AES_XCBC_MAC, -1);
+ 		nx_unregister_shash(&nx_shash_sha512_alg,
+ 				    NX_FC_SHA, NX_MODE_SHA, NX_PROPS_SHA256);
+ 		nx_unregister_shash(&nx_shash_sha256_alg,
+ 				    NX_FC_SHA, NX_MODE_SHA, NX_PROPS_SHA512);
+ 		nx_unregister_alg(&nx_ccm4309_aes_alg,
+ 				  NX_FC_AES, NX_MODE_AES_CCM);
+ 		nx_unregister_alg(&nx_ccm_aes_alg, NX_FC_AES, NX_MODE_AES_CCM);
+ 		nx_unregister_aead(&nx_gcm4106_aes_alg,
+ 				   NX_FC_AES, NX_MODE_AES_GCM);
+ 		nx_unregister_aead(&nx_gcm_aes_alg,
+ 				   NX_FC_AES, NX_MODE_AES_GCM);
+ 		nx_unregister_alg(&nx_ctr3686_aes_alg,
+ 				  NX_FC_AES, NX_MODE_AES_CTR);
+ 		nx_unregister_alg(&nx_ctr_aes_alg, NX_FC_AES, NX_MODE_AES_CTR);
+ 		nx_unregister_alg(&nx_cbc_aes_alg, NX_FC_AES, NX_MODE_AES_CBC);
+ 		nx_unregister_alg(&nx_ecb_aes_alg, NX_FC_AES, NX_MODE_AES_ECB);
++>>>>>>> 8000112cedb8 (crypto: nx - Check for bogus firmware properties)
  	}
  
  	return 0;
* Unmerged path drivers/crypto/nx/nx.c
