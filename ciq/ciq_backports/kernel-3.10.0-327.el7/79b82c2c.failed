megaraid_sas: Chip reset if driver fails to get IOC ready

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [scsi] megaraid_sas: Chip reset if driver fail to bring ioc ready (Tomas Henzl) [1257604]
Rebuild_FUZZ: 93.91%
commit-author sumit.saxena@avagotech.com <sumit.saxena@avagotech.com>
commit 79b82c2c560025afbb88ba7ad5cddb9c2203cf2e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/79b82c2c.failed

Fix the issue reported at:

	http://marc.info/?l=linux-scsi&m=143694494104544&w=2

Try to do chip reset at driver load time. If firmware fails to reach
ready state, try chip reset using adp_reset() callback. For Fusion
adapters the call back was previously void. Provide a suitable reset
function.

	Signed-off-by: Sumit Saxena <sumit.saxena@avagotech.com>
	Signed-off-by: Kashyap Desai <kashyap.desai@avagotech.com>
	Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 79b82c2c560025afbb88ba7ad5cddb9c2203cf2e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/megaraid/megaraid_sas_fusion.c
diff --cc drivers/scsi/megaraid/megaraid_sas_fusion.c
index 8b61bbd4b86c,8d0a88f092c2..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c
+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c
@@@ -2610,8 -2742,9 +2674,8 @@@ int megasas_reset_fusion(struct Scsi_Ho
  	struct megasas_instance *instance;
  	struct megasas_cmd_fusion *cmd_fusion;
  	struct fusion_context *fusion;
- 	u32 host_diag, abs_state, status_reg, reset_adapter;
+ 	u32 abs_state, status_reg, reset_adapter;
  	u32 io_timeout_in_crash_mode = 0;
 -	struct scsi_cmnd *scmd_local = NULL;
  
  	instance = (struct megasas_instance *)shost->hostdata;
  	fusion = instance->ctrl_context;
@@@ -2762,85 -2896,14 +2826,78 @@@
  
  		/* Now try to reset the chip */
  		for (i = 0; i < MEGASAS_FUSION_MAX_RESET_TRIES; i++) {
- 			writel(MPI2_WRSEQ_FLUSH_KEY_VALUE,
- 			       &instance->reg_set->fusion_seq_offset);
- 			writel(MPI2_WRSEQ_1ST_KEY_VALUE,
- 			       &instance->reg_set->fusion_seq_offset);
- 			writel(MPI2_WRSEQ_2ND_KEY_VALUE,
- 			       &instance->reg_set->fusion_seq_offset);
- 			writel(MPI2_WRSEQ_3RD_KEY_VALUE,
- 			       &instance->reg_set->fusion_seq_offset);
- 			writel(MPI2_WRSEQ_4TH_KEY_VALUE,
- 			       &instance->reg_set->fusion_seq_offset);
- 			writel(MPI2_WRSEQ_5TH_KEY_VALUE,
- 			       &instance->reg_set->fusion_seq_offset);
- 			writel(MPI2_WRSEQ_6TH_KEY_VALUE,
- 			       &instance->reg_set->fusion_seq_offset);
  
++<<<<<<< HEAD
 +			/* Check that the diag write enable (DRWE) bit is on */
 +			host_diag = readl(&instance->reg_set->fusion_host_diag);
 +			retry = 0;
 +			while (!(host_diag & HOST_DIAG_WRITE_ENABLE)) {
 +				msleep(100);
 +				host_diag =
 +				readl(&instance->reg_set->fusion_host_diag);
 +				if (retry++ == 100) {
 +					printk(KERN_WARNING "megaraid_sas: "
 +					       "Host diag unlock failed! "
 +					       "for scsi%d\n",
 +						instance->host->host_no);
 +					break;
 +				}
 +			}
 +			if (!(host_diag & HOST_DIAG_WRITE_ENABLE))
 +				continue;
 +
 +			/* Send chip reset command */
 +			writel(host_diag | HOST_DIAG_RESET_ADAPTER,
 +			       &instance->reg_set->fusion_host_diag);
 +			msleep(3000);
 +
 +			/* Make sure reset adapter bit is cleared */
 +			host_diag = readl(&instance->reg_set->fusion_host_diag);
 +			retry = 0;
 +			while (host_diag & HOST_DIAG_RESET_ADAPTER) {
 +				msleep(100);
 +				host_diag =
 +				readl(&instance->reg_set->fusion_host_diag);
 +				if (retry++ == 1000) {
 +					printk(KERN_WARNING "megaraid_sas: "
 +					       "Diag reset adapter never "
 +					       "cleared for scsi%d!\n",
 +						instance->host->host_no);
 +					break;
 +				}
 +			}
 +			if (host_diag & HOST_DIAG_RESET_ADAPTER)
 +				continue;
 +
 +			abs_state =
 +				instance->instancet->read_fw_status_reg(
 +					instance->reg_set) & MFI_STATE_MASK;
 +			retry = 0;
 +
 +			while ((abs_state <= MFI_STATE_FW_INIT) &&
 +			       (retry++ < 1000)) {
 +				msleep(100);
 +				abs_state =
 +				instance->instancet->read_fw_status_reg(
 +					instance->reg_set) & MFI_STATE_MASK;
 +			}
 +			if (abs_state <= MFI_STATE_FW_INIT) {
 +				printk(KERN_WARNING "megaraid_sas: firmware "
 +				       "state < MFI_STATE_FW_INIT, state = "
 +				       "0x%x for scsi%d\n", abs_state,
 +					instance->host->host_no);
 +				continue;
 +			}
 +
++=======
+ 			if (instance->instancet->adp_reset
+ 				(instance, instance->reg_set))
+ 				continue;
+ 
++>>>>>>> 79b82c2c5600 (megaraid_sas: Chip reset if driver fails to get IOC ready)
  			/* Wait for FW to become ready */
  			if (megasas_transition_to_ready(instance, 1)) {
 -				dev_warn(&instance->pdev->dev, "Failed to "
 +				printk(KERN_WARNING "megaraid_sas: Failed to "
  				       "transition controller to ready "
  				       "for scsi%d.\n",
  				       instance->host->host_no);
* Unmerged path drivers/scsi/megaraid/megaraid_sas_fusion.c
