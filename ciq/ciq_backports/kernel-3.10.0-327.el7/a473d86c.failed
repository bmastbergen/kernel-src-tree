hpsa: print accurate SSD Smart Path Enabled status

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Robert Elliott <elliott@hp.com>
commit a473d86cc9f5a4d4ac758d86bd526c8dce1f7906
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/a473d86c.failed

offload_enabled changes are deferred until after the
added/updated prints occur, so the values are incorrect.

defer printing SSD Smart Path Enabled status information until the
information is correct

	Reviewed-by: Scott Teel <scott.teel@pmcs.com>
	Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
	Reviewed-by: Tomas Henzl <thenzl@redhat.com>
	Reviewed-by: Hannes Reinecke <hare@Suse.de>
	Signed-off-by: Robert Elliott <elliott@hp.com>
	Signed-off-by: Don Brace <don.brace@pmcs.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: James Bottomley <JBottomley@Odin.com>
(cherry picked from commit a473d86cc9f5a4d4ac758d86bd526c8dce1f7906)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/hpsa.c
diff --cc drivers/scsi/hpsa.c
index 12c02e8d4ce8,2fadf6aa965d..000000000000
--- a/drivers/scsi/hpsa.c
+++ b/drivers/scsi/hpsa.c
@@@ -973,15 -1062,10 +973,22 @@@ lun_assigned
  	h->ndevices++;
  	added[*nadded] = device;
  	(*nadded)++;
++<<<<<<< HEAD
 +
 +	/* initially, (before registering with scsi layer) we don't
 +	 * know our hostno and we don't want to print anything first
 +	 * time anyway (the scsi layer's inquiries will show that info)
 +	 */
 +	/* if (hostno != -1) */
 +		dev_info(&h->pdev->dev, "%s device c%db%dt%dl%d added.\n",
 +			scsi_device_type(device->devtype), hostno,
 +			device->bus, device->target, device->lun);
++=======
+ 	hpsa_show_dev_msg(KERN_INFO, h, device,
+ 		device->expose_state & HPSA_SCSI_ADD ? "added" : "masked");
+ 	device->offload_to_be_enabled = device->offload_enabled;
+ 	device->offload_enabled = 0;
++>>>>>>> a473d86cc9f5 (hpsa: print accurate SSD Smart Path Enabled status)
  	return 0;
  }
  
@@@ -995,16 -1080,36 +1003,32 @@@ static void hpsa_scsi_update_entry(stru
  	/* Raid level changed. */
  	h->dev[entry]->raid_level = new_entry->raid_level;
  
 -	/* Raid offload parameters changed.  Careful about the ordering. */
 -	if (new_entry->offload_config && new_entry->offload_enabled) {
 -		/*
 -		 * if drive is newly offload_enabled, we want to copy the
 -		 * raid map data first.  If previously offload_enabled and
 -		 * offload_config were set, raid map data had better be
 -		 * the same as it was before.  if raid map data is changed
 -		 * then it had better be the case that
 -		 * h->dev[entry]->offload_enabled is currently 0.
 -		 */
 -		h->dev[entry]->raid_map = new_entry->raid_map;
 -		h->dev[entry]->ioaccel_handle = new_entry->ioaccel_handle;
 -	}
 +	/* Raid offload parameters changed. */
  	h->dev[entry]->offload_config = new_entry->offload_config;
 +	h->dev[entry]->offload_enabled = new_entry->offload_enabled;
 +	h->dev[entry]->ioaccel_handle = new_entry->ioaccel_handle;
  	h->dev[entry]->offload_to_mirror = new_entry->offload_to_mirror;
 -	h->dev[entry]->queue_depth = new_entry->queue_depth;
 +	h->dev[entry]->raid_map = new_entry->raid_map;
  
++<<<<<<< HEAD
 +	dev_info(&h->pdev->dev, "%s device c%db%dt%dl%d updated.\n",
 +		scsi_device_type(new_entry->devtype), hostno, new_entry->bus,
 +		new_entry->target, new_entry->lun);
++=======
+ 	/*
+ 	 * We can turn off ioaccel offload now, but need to delay turning
+ 	 * it on until we can update h->dev[entry]->phys_disk[], but we
+ 	 * can't do that until all the devices are updated.
+ 	 */
+ 	h->dev[entry]->offload_to_be_enabled = new_entry->offload_enabled;
+ 	if (!new_entry->offload_enabled)
+ 		h->dev[entry]->offload_enabled = 0;
+ 
+ 	offload_enabled = h->dev[entry]->offload_enabled;
+ 	h->dev[entry]->offload_enabled = h->dev[entry]->offload_to_be_enabled;
+ 	hpsa_show_dev_msg(KERN_INFO, h, h->dev[entry], "updated");
+ 	h->dev[entry]->offload_enabled = offload_enabled;
++>>>>>>> a473d86cc9f5 (hpsa: print accurate SSD Smart Path Enabled status)
  }
  
  /* Replace an entry from h->dev[] array. */
@@@ -1030,9 -1135,9 +1054,15 @@@ static void hpsa_scsi_replace_entry(str
  	h->dev[entry] = new_entry;
  	added[*nadded] = new_entry;
  	(*nadded)++;
++<<<<<<< HEAD
 +	dev_info(&h->pdev->dev, "%s device c%db%dt%dl%d changed.\n",
 +		scsi_device_type(new_entry->devtype), hostno, new_entry->bus,
 +			new_entry->target, new_entry->lun);
++=======
+ 	hpsa_show_dev_msg(KERN_INFO, h, new_entry, "replaced");
+ 	new_entry->offload_to_be_enabled = new_entry->offload_enabled;
+ 	new_entry->offload_enabled = 0;
++>>>>>>> a473d86cc9f5 (hpsa: print accurate SSD Smart Path Enabled status)
  }
  
  /* Remove an entry from h->dev[] array. */
* Unmerged path drivers/scsi/hpsa.c
