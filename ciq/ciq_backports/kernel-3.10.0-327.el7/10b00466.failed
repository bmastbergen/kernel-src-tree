cxgb4: IEEE fixes for DCBx state machine

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Anish Bhatt <anish@chelsio.com>
commit 10b0046685ab410847f420d740acf604c8cb4eec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/10b00466.failed

* Changes required due to 16eecd9be4b05 ("dcbnl : Fix misleading
  dcb_app->priority explanation")
* Driver was previously not aware of what DCBx version was negotiated by
  firmware, this could lead to DCB app table  in kernel or in firmware being
  populated wrong  since IEEE/CEE used different formats made clear by above
  mentioned commit
* Driver was missing a couple of state transitions that could be caused
  by other drivers that use chelsio hardware, resulting in incorrect behaviour
  (the change that addresses this also flips the state machine to switch on
   state instead of transition, hope this is okay in current window)
* Prio queue info & tsa is no longer thrown away

v2: Print DCBx state transition messages only when debug is enabled

	Signed-off-by: Anish Bhatt <anish@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 10b0046685ab410847f420d740acf604c8cb4eec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_dcb.c
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_dcb.c
index a8b1073e6373,8edf0f5bd679..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_dcb.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_dcb.c
@@@ -648,26 -734,17 +734,31 @@@ static int __cxgb4_getapp(struct net_de
  }
  
  /* Return the Application User Priority Map associated with the specified
 - * Application ID.
 + * Application ID.  Since this routine is prototyped to return "u8" we can't
 + * return errors ...
   */
 -static int cxgb4_getapp(struct net_device *dev, u8 app_idtype, u16 app_id)
 +static u8 cxgb4_getapp(struct net_device *dev, u8 app_idtype, u16 app_id)
  {
 -	return __cxgb4_getapp(dev, app_idtype, app_id, 0);
 +	int result = __cxgb4_getapp(dev, app_idtype, app_id, 0);
 +
 +	if (result < 0)
 +		result = 0;
 +
 +	return result;
  }
  
 -/* Write a new Application User Priority Map for the specified Application ID
 +/* Write a new Application User Priority Map for the specified Application ID.
 + * This routine is prototyped to return "u8" but other instantiations of the
 + * DCB NetLink Operations "setapp" routines return negative errnos for errors.
 + * We follow their lead.
   */
++<<<<<<< HEAD
 +static u8 cxgb4_setapp(struct net_device *dev, u8 app_idtype, u16 app_id,
 +		       u8 app_prio)
++=======
+ static int __cxgb4_setapp(struct net_device *dev, u8 app_idtype, u16 app_id,
+ 			  u8 app_prio)
++>>>>>>> 10b0046685ab (cxgb4: IEEE fixes for DCBx state machine)
  {
  	struct fw_port_cmd pcmd;
  	struct port_info *pi = netdev2pinfo(dev);
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
index 0c588dc02bae,a62d3f468c52..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@@ -484,6 -490,44 +484,47 @@@ static void link_report(struct net_devi
  	}
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_CHELSIO_T4_DCB
+ /* Set up/tear down Data Center Bridging Priority mapping for a net device. */
+ static void dcb_tx_queue_prio_enable(struct net_device *dev, int enable)
+ {
+ 	struct port_info *pi = netdev_priv(dev);
+ 	struct adapter *adap = pi->adapter;
+ 	struct sge_eth_txq *txq = &adap->sge.ethtxq[pi->first_qset];
+ 	int i;
+ 
+ 	/* We use a simple mapping of Port TX Queue Index to DCB
+ 	 * Priority when we're enabling DCB.
+ 	 */
+ 	for (i = 0; i < pi->nqsets; i++, txq++) {
+ 		u32 name, value;
+ 		int err;
+ 
+ 		name = (FW_PARAMS_MNEM(FW_PARAMS_MNEM_DMAQ) |
+ 			FW_PARAMS_PARAM_X(FW_PARAMS_PARAM_DMAQ_EQ_DCBPRIO_ETH) |
+ 			FW_PARAMS_PARAM_YZ(txq->q.cntxt_id));
+ 		value = enable ? i : 0xffffffff;
+ 
+ 		/* Since we can be called while atomic (from "interrupt
+ 		 * level") we need to issue the Set Parameters Commannd
+ 		 * without sleeping (timeout < 0).
+ 		 */
+ 		err = t4_set_params_nosleep(adap, adap->mbox, adap->fn, 0, 1,
+ 					    &name, &value);
+ 
+ 		if (err)
+ 			dev_err(adap->pdev_dev,
+ 				"Can't %s DCB Priority on port %d, TX Queue %d: err=%d\n",
+ 				enable ? "set" : "unset", pi->port_id, i, -err);
+ 		else
+ 			txq->dcb_prio = value;
+ 	}
+ }
+ #endif /* CONFIG_CHELSIO_T4_DCB */
+ 
++>>>>>>> 10b0046685ab (cxgb4: IEEE fixes for DCBx state machine)
  void t4_os_link_changed(struct adapter *adapter, int port_id, int link_stat)
  {
  	struct net_device *dev = adapter->port[port_id];
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
index a59f88e4e1aa..24eddf195457 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
@@ -520,6 +520,9 @@ struct sge_txq {
 struct sge_eth_txq {                /* state for an SGE Ethernet Tx queue */
 	struct sge_txq q;
 	struct netdev_queue *txq;   /* associated netdev TX queue */
+#ifdef CONFIG_CHELSIO_T4_DCB
+	u8 dcb_prio;		    /* DCB Priority bound to queue */
+#endif
 	unsigned long tso;          /* # of TSO requests */
 	unsigned long tx_cso;       /* # of Tx checksum offloads */
 	unsigned long vlan_ins;     /* # of Tx VLAN insertions */
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_dcb.c
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_dcb.h b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_dcb.h
index 1ec1d834e257..2a6aa88984f4 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_dcb.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_dcb.h
@@ -63,6 +63,13 @@
 #define INIT_PORT_DCB_WRITE_CMD(__pcmd, __port) \
 	INIT_PORT_DCB_CMD(__pcmd, __port, EXEC, FW_PORT_ACTION_L2_DCB_CFG)
 
+#define IEEE_FAUX_SYNC(__dev, __dcb) \
+	do { \
+		if ((__dcb)->dcb_version == FW_PORT_DCB_VER_IEEE) \
+			cxgb4_dcb_state_fsm((__dev), \
+					    CXGB4_DCB_STATE_FW_ALLSYNCED); \
+	} while (0)
+
 /* States we can be in for a port's Data Center Bridging.
  */
 enum cxgb4_dcb_state {
@@ -108,11 +115,13 @@ struct port_dcb_info {
 	 * Native Endian format).
 	 */
 	u32	pgid;			/* Priority Group[0..7] */
+	u8	dcb_version;		/* Running DCBx version */
 	u8	pfcen;			/* Priority Flow Control[0..7] */
 	u8	pg_num_tcs_supported;	/* max PG Traffic Classes */
 	u8	pfc_num_tcs_supported;	/* max PFC Traffic Classes */
 	u8	pgrate[8];		/* Priority Group Rate[0..7] */
 	u8	priorate[8];		/* Priority Rate[0..7] */
+	u8	tsa[8];			/* TSA Algorithm[0..7] */
 	struct app_priority { /* Application Information */
 		u8	user_prio_map;	/* Priority Map bitfield */
 		u8	sel_field;	/* Protocol ID interpretation */
@@ -121,6 +130,7 @@ struct port_dcb_info {
 };
 
 void cxgb4_dcb_state_init(struct net_device *);
+void cxgb4_dcb_version_init(struct net_device *);
 void cxgb4_dcb_state_fsm(struct net_device *, enum cxgb4_dcb_state_input);
 void cxgb4_dcb_handle_fw_update(struct adapter *, const struct fw_port_cmd *);
 void cxgb4_dcb_set_caps(struct adapter *, const struct fw_port_cmd *);
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
diff --git a/drivers/net/ethernet/chelsio/cxgb4/t4fw_api.h b/drivers/net/ethernet/chelsio/cxgb4/t4fw_api.h
index 0487eeccb419..743a35018f0b 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/t4fw_api.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4fw_api.h
@@ -1631,6 +1631,14 @@ enum fw_port_l2cfg_ctlbf {
 	FW_PORT_L2_CTLBF_TXIPG	= 0x20
 };
 
+enum fw_port_dcb_versions {
+	FW_PORT_DCB_VER_UNKNOWN,
+	FW_PORT_DCB_VER_CEE1D0,
+	FW_PORT_DCB_VER_CEE1D01,
+	FW_PORT_DCB_VER_IEEE,
+	FW_PORT_DCB_VER_AUTO = 7
+};
+
 enum fw_port_dcb_cfg {
 	FW_PORT_DCB_CFG_PG	= 0x01,
 	FW_PORT_DCB_CFG_PFC	= 0x02,
@@ -1711,6 +1719,7 @@ struct fw_port_cmd {
 				__u8   r10_lo[5];
 				__u8   num_tcs_supported;
 				__u8   pgrate[8];
+				__u8   tsa[8];
 			} pgrate;
 			struct fw_port_dcb_priorate {
 				__u8   type;
@@ -1737,7 +1746,7 @@ struct fw_port_cmd {
 			struct fw_port_dcb_control {
 				__u8   type;
 				__u8   all_syncd_pkd;
-				__be16 pfc_state_to_app_state;
+				__be16 dcb_version_to_app_state;
 				__be32 r11;
 				__be64 r12;
 			} control;
@@ -1780,6 +1789,7 @@ struct fw_port_cmd {
 #define FW_PORT_CMD_DCBXDIS (1U << 7)
 #define FW_PORT_CMD_APPLY (1U <<  7)
 #define FW_PORT_CMD_ALL_SYNCD (1U << 7)
+#define FW_PORT_CMD_DCB_VERSION_GET(x) (((x) >> 8) & 0xf)
 
 #define FW_PORT_CMD_PPPEN(x) ((x) << 31)
 #define FW_PORT_CMD_TPSRC(x) ((x) << 28)
