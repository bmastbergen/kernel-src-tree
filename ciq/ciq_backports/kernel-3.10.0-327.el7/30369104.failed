bonding: cleanup and remove dead code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Jonathan Toppins <jtoppins@cumulusnetworks.com>
commit 303691042d2fc996125f479cf01bd5ead8b90a16
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/30369104.failed

fix sparse warning about non-static function

drivers/net/bonding/bond_main.c:3737:5: warning: symbol
'bond_3ad_xor_xmit' was not declared. Should it be static?

	Reviewed-by: Nikolay Aleksandrov <nikolay@redhat.com>
	Signed-off-by: Jonathan Toppins <jtoppins@cumulusnetworks.com>
	Signed-off-by: Jay Vosburgh <jay.vosburgh@canonical.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 303691042d2fc996125f479cf01bd5ead8b90a16)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
diff --cc drivers/net/bonding/bond_main.c
index 723c3d160745,e229a8657de8..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -3901,54 -3598,156 +3901,75 @@@ static int bond_xmit_activebackup(struc
  {
  	struct bonding *bond = netdev_priv(bond_dev);
  	struct slave *slave;
 +	int res = 1;
  
 -	slave = rcu_dereference(bond->curr_active_slave);
 +	slave = bond->curr_active_slave;
  	if (slave)
 -		bond_dev_queue_xmit(bond, skb, slave->dev);
 -	else
 -		bond_tx_drop(bond_dev, skb);
 -
 -	return NETDEV_TX_OK;
 -}
 -
 -/* Use this to update slave_array when (a) it's not appropriate to update
 - * slave_array right away (note that update_slave_array() may sleep)
 - * and / or (b) RTNL is not held.
 - */
 -void bond_slave_arr_work_rearm(struct bonding *bond, unsigned long delay)
 -{
 -	queue_delayed_work(bond->wq, &bond->slave_arr_work, delay);
 -}
 -
 -/* Slave array work handler. Holds only RTNL */
 -static void bond_slave_arr_handler(struct work_struct *work)
 -{
 -	struct bonding *bond = container_of(work, struct bonding,
 -					    slave_arr_work.work);
 -	int ret;
 +		res = bond_dev_queue_xmit(bond, skb, slave->dev);
  
 -	if (!rtnl_trylock())
 -		goto err;
 -
 -	ret = bond_update_slave_arr(bond, NULL);
 -	rtnl_unlock();
 -	if (ret) {
 -		pr_warn_ratelimited("Failed to update slave array from WT\n");
 -		goto err;
 -	}
 -	return;
 +	if (res)
 +		/* no suitable interface, frame not sent */
 +		kfree_skb(skb);
  
 -err:
 -	bond_slave_arr_work_rearm(bond, 1);
 +	return NETDEV_TX_OK;
  }
  
 -/* Build the usable slaves array in control path for modes that use xmit-hash
 - * to determine the slave interface -
 - * (a) BOND_MODE_8023AD
 - * (b) BOND_MODE_XOR
 - * (c) BOND_MODE_TLB && tlb_dynamic_lb == 0
 - *
 - * The caller is expected to hold RTNL only and NO other lock!
 +/*
 + * In bond_xmit_xor() , we determine the output device by using a pre-
 + * determined xmit_hash_policy(), If the selected device is not enabled,
 + * find the next active slave.
   */
 -int bond_update_slave_arr(struct bonding *bond, struct slave *skipslave)
 +static int bond_xmit_xor(struct sk_buff *skb, struct net_device *bond_dev)
  {
 -	struct slave *slave;
 -	struct list_head *iter;
 -	struct bond_up_slave *new_arr, *old_arr;
 -	int slaves_in_agg;
 -	int agg_id = 0;
 -	int ret = 0;
 -
 -#ifdef CONFIG_LOCKDEP
 -	WARN_ON(lockdep_is_held(&bond->mode_lock));
 -#endif
 +	struct bonding *bond = netdev_priv(bond_dev);
 +	struct slave *slave, *start_at;
 +	int slave_no;
 +	int i;
 +	int res = 1;
  
 -	new_arr = kzalloc(offsetof(struct bond_up_slave, arr[bond->slave_cnt]),
 -			  GFP_KERNEL);
 -	if (!new_arr) {
 -		ret = -ENOMEM;
 -		pr_err("Failed to build slave-array.\n");
 -		goto out;
 -	}
 -	if (BOND_MODE(bond) == BOND_MODE_8023AD) {
 -		struct ad_info ad_info;
 +	slave_no = bond->xmit_hash_policy(skb, bond->slave_cnt);
  
 -		if (bond_3ad_get_active_agg_info(bond, &ad_info)) {
 -			pr_debug("bond_3ad_get_active_agg_info failed\n");
 -			kfree_rcu(new_arr, rcu);
 -			/* No active aggragator means it's not safe to use
 -			 * the previous array.
 -			 */
 -			old_arr = rtnl_dereference(bond->slave_arr);
 -			if (old_arr) {
 -				RCU_INIT_POINTER(bond->slave_arr, NULL);
 -				kfree_rcu(old_arr, rcu);
 -			}
 -			goto out;
 -		}
 -		slaves_in_agg = ad_info.ports;
 -		agg_id = ad_info.aggregator_id;
 +	bond_for_each_slave(bond, slave, i) {
 +		slave_no--;
 +		if (slave_no < 0)
 +			break;
  	}
 -	bond_for_each_slave(bond, slave, iter) {
 -		if (BOND_MODE(bond) == BOND_MODE_8023AD) {
 -			struct aggregator *agg;
  
 -			agg = SLAVE_AD_INFO(slave)->port.aggregator;
 -			if (!agg || agg->aggregator_identifier != agg_id)
 -				continue;
 -		}
 -		if (!bond_slave_can_tx(slave))
 -			continue;
 -		if (skipslave == slave)
 -			continue;
 -		new_arr->arr[new_arr->count++] = slave;
 -	}
 +	start_at = slave;
  
 -	old_arr = rtnl_dereference(bond->slave_arr);
 -	rcu_assign_pointer(bond->slave_arr, new_arr);
 -	if (old_arr)
 -		kfree_rcu(old_arr, rcu);
 -out:
 -	if (ret != 0 && skipslave) {
 -		int idx;
 -
 -		/* Rare situation where caller has asked to skip a specific
 -		 * slave but allocation failed (most likely!). BTW this is
 -		 * only possible when the call is initiated from
 -		 * __bond_release_one(). In this situation; overwrite the
 -		 * skipslave entry in the array with the last entry from the
 -		 * array to avoid a situation where the xmit path may choose
 -		 * this to-be-skipped slave to send a packet out.
 -		 */
 -		old_arr = rtnl_dereference(bond->slave_arr);
 -		for (idx = 0; idx < old_arr->count; idx++) {
 -			if (skipslave == old_arr->arr[idx]) {
 -				old_arr->arr[idx] =
 -				    old_arr->arr[old_arr->count-1];
 -				old_arr->count--;
 -				break;
 -			}
 +	bond_for_each_slave_from(bond, slave, i, start_at) {
 +		if (IS_UP(slave->dev) &&
 +		    (slave->link == BOND_LINK_UP) &&
 +		    bond_is_active_slave(slave)) {
 +			res = bond_dev_queue_xmit(bond, skb, slave->dev);
 +			break;
  		}
  	}
 -	return ret;
 -}
  
++<<<<<<< HEAD
 +	if (res) {
 +		/* no suitable interface, frame not sent */
 +		kfree_skb(skb);
++=======
+ /* Use this Xmit function for 3AD as well as XOR modes. The current
+  * usable slave array is formed in the control path. The xmit function
+  * just calculates hash and sends the packet out.
+  */
+ static int bond_3ad_xor_xmit(struct sk_buff *skb, struct net_device *dev)
+ {
+ 	struct bonding *bond = netdev_priv(dev);
+ 	struct slave *slave;
+ 	struct bond_up_slave *slaves;
+ 	unsigned int count;
+ 
+ 	slaves = rcu_dereference(bond->slave_arr);
+ 	count = slaves ? ACCESS_ONCE(slaves->count) : 0;
+ 	if (likely(count)) {
+ 		slave = slaves->arr[bond_xmit_hash(bond, skb) % count];
+ 		bond_dev_queue_xmit(bond, skb, slave->dev);
+ 	} else {
+ 		bond_tx_drop(dev, skb);
++>>>>>>> 303691042d2f (bonding: cleanup and remove dead code)
  	}
  
  	return NETDEV_TX_OK;
diff --git a/drivers/net/bonding/bond_3ad.h b/drivers/net/bonding/bond_3ad.h
index 3b97fe487dca..b60a48105a7a 100644
--- a/drivers/net/bonding/bond_3ad.h
+++ b/drivers/net/bonding/bond_3ad.h
@@ -274,7 +274,6 @@ void bond_3ad_handle_link_change(struct slave *slave, char link);
 int  bond_3ad_get_active_agg_info(struct bonding *bond, struct ad_info *ad_info);
 int  __bond_3ad_get_active_agg_info(struct bonding *bond,
 				    struct ad_info *ad_info);
-int bond_3ad_xmit_xor(struct sk_buff *skb, struct net_device *dev);
 int bond_3ad_lacpdu_recv(const struct sk_buff *skb, struct bonding *bond,
 			 struct slave *slave);
 int bond_3ad_set_carrier(struct bonding *bond);
* Unmerged path drivers/net/bonding/bond_main.c
