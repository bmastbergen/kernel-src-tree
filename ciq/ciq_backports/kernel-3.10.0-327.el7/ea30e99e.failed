powerpc/eeh/ioda2: Use device::iommu_group to check IOMMU group

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [powerpc] eeh/ioda2: Use device::iommu_group to check IOMMU group (David Gibson) [1213665]
Rebuild_FUZZ: 93.22%
commit-author Alexey Kardashevskiy <aik@ozlabs.ru>
commit ea30e99e8eccb684490f40d011ea534ecd937e98
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/ea30e99e.failed

This relies on the fact that a PCI device always has an IOMMU table
which may not be the case when we get dynamic DMA windows so
let's use more reliable check for IOMMU group here.

As we do not rely on the table presence here, remove the workaround
from pnv_pci_ioda2_set_bypass(); also remove the @add_to_iommu_group
parameter from pnv_ioda_setup_bus_dma().

	Signed-off-by: Alexey Kardashevskiy <aik@ozlabs.ru>
	Acked-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
	Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit ea30e99e8eccb684490f40d011ea534ecd937e98)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/powernv/pci-ioda.c
diff --cc arch/powerpc/platforms/powernv/pci-ioda.c
index 109e90d84e34,5491d2f0e192..000000000000
--- a/arch/powerpc/platforms/powernv/pci-ioda.c
+++ b/arch/powerpc/platforms/powernv/pci-ioda.c
@@@ -569,22 -1631,39 +569,24 @@@ static int pnv_pci_ioda_dma_set_mask(st
  	return 0;
  }
  
 -static u64 pnv_pci_ioda_dma_get_required_mask(struct pnv_phb *phb,
 -					      struct pci_dev *pdev)
 -{
 -	struct pci_dn *pdn = pci_get_pdn(pdev);
 -	struct pnv_ioda_pe *pe;
 -	u64 end, mask;
 -
 -	if (WARN_ON(!pdn || pdn->pe_number == IODA_INVALID_PE))
 -		return 0;
 -
 -	pe = &phb->ioda.pe_array[pdn->pe_number];
 -	if (!pe->tce_bypass_enabled)
 -		return __dma_get_required_mask(&pdev->dev);
 -
 -
 -	end = pe->tce_bypass_base + memblock_end_of_DRAM();
 -	mask = 1ULL << (fls64(end) - 1);
 -	mask += mask - 1;
 -
 -	return mask;
 -}
 -
  static void pnv_ioda_setup_bus_dma(struct pnv_ioda_pe *pe,
- 				   struct pci_bus *bus,
- 				   bool add_to_iommu_group)
+ 				   struct pci_bus *bus)
  {
  	struct pci_dev *dev;
  
  	list_for_each_entry(dev, &bus->devices, bus_list) {
++<<<<<<< HEAD
 +		if (add_to_iommu_group)
 +			set_iommu_table_base_and_group(&dev->dev,
 +						       &pe->tce32_table);
 +		else
 +			set_iommu_table_base(&dev->dev, &pe->tce32_table);
++=======
+ 		set_iommu_table_base_and_group(&dev->dev, pe->tce32_table);
++>>>>>>> ea30e99e8ecc (powerpc/eeh/ioda2: Use device::iommu_group to check IOMMU group)
  
  		if (dev->subordinate)
- 			pnv_ioda_setup_bus_dma(pe, dev->subordinate,
- 					       add_to_iommu_group);
+ 			pnv_ioda_setup_bus_dma(pe, dev->subordinate);
  	}
  }
  
@@@ -742,12 -1832,19 +744,23 @@@ static void pnv_pci_ioda_setup_dma_pe(s
  				 TCE_PCI_SWINV_PAIR);
  	}
  	iommu_init_table(tbl, phb->hose->node);
 +	iommu_register_group(tbl, phb->hose->global_number, pe->pe_number);
  
 -	if (pe->flags & PNV_IODA_PE_DEV) {
 -		iommu_register_group(tbl, phb->hose->global_number,
 -				     pe->pe_number);
 +	if (pe->pdev)
  		set_iommu_table_base_and_group(&pe->pdev->dev, tbl);
++<<<<<<< HEAD
 +	else
 +		pnv_ioda_setup_bus_dma(pe, pe->pbus, true);
++=======
+ 	} else if (pe->flags & (PNV_IODA_PE_BUS | PNV_IODA_PE_BUS_ALL)) {
+ 		iommu_register_group(tbl, phb->hose->global_number,
+ 				     pe->pe_number);
+ 		pnv_ioda_setup_bus_dma(pe, pe->pbus);
+ 	} else if (pe->flags & PNV_IODA_PE_VF) {
+ 		iommu_register_group(tbl, phb->hose->global_number,
+ 				     pe->pe_number);
+ 	}
++>>>>>>> ea30e99e8ecc (powerpc/eeh/ioda2: Use device::iommu_group to check IOMMU group)
  
  	return;
   fail:
@@@ -873,15 -1960,24 +875,26 @@@ static void pnv_pci_ioda2_setup_dma_pe(
  		tbl->it_type |= (TCE_PCI_SWINV_CREATE | TCE_PCI_SWINV_FREE);
  	}
  	iommu_init_table(tbl, phb->hose->node);
 +	iommu_register_group(tbl, phb->hose->global_number, pe->pe_number);
  
 -	if (pe->flags & PNV_IODA_PE_DEV) {
 -		iommu_register_group(tbl, phb->hose->global_number,
 -				     pe->pe_number);
 +	if (pe->pdev)
  		set_iommu_table_base_and_group(&pe->pdev->dev, tbl);
++<<<<<<< HEAD
 +	else
 +		pnv_ioda_setup_bus_dma(pe, pe->pbus, true);
++=======
+ 	} else if (pe->flags & (PNV_IODA_PE_BUS | PNV_IODA_PE_BUS_ALL)) {
+ 		iommu_register_group(tbl, phb->hose->global_number,
+ 				     pe->pe_number);
+ 		pnv_ioda_setup_bus_dma(pe, pe->pbus);
+ 	} else if (pe->flags & PNV_IODA_PE_VF) {
+ 		iommu_register_group(tbl, phb->hose->global_number,
+ 				     pe->pe_number);
+ 	}
++>>>>>>> ea30e99e8ecc (powerpc/eeh/ioda2: Use device::iommu_group to check IOMMU group)
  
  	/* Also create a bypass window */
 -	if (!pnv_iommu_bypass_disabled)
 -		pnv_pci_ioda2_setup_bypass_pe(phb, pe);
 -
 +	pnv_pci_ioda2_setup_bypass_pe(phb, pe);
  	return;
  fail:
  	if (pe->tce32_seg >= 0)
diff --git a/arch/powerpc/kernel/eeh.c b/arch/powerpc/kernel/eeh.c
index 6021b67a433c..09794e46a5f7 100644
--- a/arch/powerpc/kernel/eeh.c
+++ b/arch/powerpc/kernel/eeh.c
@@ -1298,13 +1298,11 @@ static int dev_has_iommu_table(struct device *dev, void *data)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
 	struct pci_dev **ppdev = data;
-	struct iommu_table *tbl;
 
 	if (!dev)
 		return 0;
 
-	tbl = get_iommu_table_base(dev);
-	if (tbl && tbl->it_group) {
+	if (dev->iommu_group) {
 		*ppdev = pdev;
 		return 1;
 	}
* Unmerged path arch/powerpc/platforms/powernv/pci-ioda.c
