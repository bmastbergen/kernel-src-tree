powerpc/pci: Trace more information from pci_dn

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [powerpc] pci: Trace more information from pci_dn (Laurent Vivier) [1213675]
Rebuild_FUZZ: 90.70%
commit-author Gavin Shan <gwshan@linux.vnet.ibm.com>
commit c035ff1d2eaa03ab40839041e955a86a8e412eb4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/c035ff1d.failed

Originally, EEH probes on device_node or pci_dev and populates the
corresponding eeh_dev. In the subsequent patches, EEH will probes
on pci_dn and populates the corresponding eeh_dev. So we have to
cache some information in pci_dn, either from device_node or SRIOV
PF's enablement platform hook, to populate the eeh_dev properly.

The motivation to probe pci_dn, instead of device node or pci_dev,
to populate eeh_dev is SRIOV VFs are dynamically created and we
don't have the corresponding device nodes for them.

	Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
	Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
(cherry picked from commit c035ff1d2eaa03ab40839041e955a86a8e412eb4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/pci_dn.c
diff --cc arch/powerpc/kernel/pci_dn.c
index 83df3075d3df,d139f72ff9d5..000000000000
--- a/arch/powerpc/kernel/pci_dn.c
+++ b/arch/powerpc/kernel/pci_dn.c
@@@ -69,7 -166,25 +69,16 @@@ void *update_dn_pci_info(struct device_
  		pdn->devfn = (addr >> 8) & 0xff;
  	}
  
+ 	/* vendor/device IDs and class code */
+ 	regs = of_get_property(dn, "vendor-id", NULL);
+ 	pdn->vendor_id = regs ? of_read_number(regs, 1) : 0;
+ 	regs = of_get_property(dn, "device-id", NULL);
+ 	pdn->device_id = regs ? of_read_number(regs, 1) : 0;
+ 	regs = of_get_property(dn, "class-code", NULL);
+ 	pdn->class_code = regs ? of_read_number(regs, 1) : 0;
+ 
+ 	/* Extended config space */
  	pdn->pci_ext_config_space = (type && of_read_number(type, 1) == 1);
 -
 -	/* Attach to parent node */
 -	INIT_LIST_HEAD(&pdn->child_list);
 -	INIT_LIST_HEAD(&pdn->list);
 -	parent = of_get_parent(dn);
 -	pdn->parent = parent ? PCI_DN(parent) : NULL;
 -	if (pdn->parent)
 -		list_add_tail(&pdn->list, &pdn->parent->child_list);
 -
  	return NULL;
  }
  
@@@ -147,8 -262,12 +156,15 @@@ void pci_devs_phb_init_dynamic(struct p
  	/* PHB nodes themselves must not match */
  	update_dn_pci_info(dn, phb);
  	pdn = dn->data;
 -	if (pdn) {
 +	if (pdn)
  		pdn->devfn = pdn->busno = -1;
++<<<<<<< HEAD
++=======
+ 		pdn->vendor_id = pdn->device_id = pdn->class_code = 0;
+ 		pdn->phb = phb;
+ 		phb->pci_data = pdn;
+ 	}
++>>>>>>> c035ff1d2eaa (powerpc/pci: Trace more information from pci_dn)
  
  	/* Update dn->phb ptrs for new phb and children devices */
  	traverse_pci_devices(dn, update_dn_pci_info, phb);
diff --git a/arch/powerpc/include/asm/pci-bridge.h b/arch/powerpc/include/asm/pci-bridge.h
index 4ca90a39d6d0..f6d307a3277e 100644
--- a/arch/powerpc/include/asm/pci-bridge.h
+++ b/arch/powerpc/include/asm/pci-bridge.h
@@ -152,6 +152,9 @@ struct iommu_table;
 struct pci_dn {
 	int	busno;			/* pci bus number */
 	int	devfn;			/* pci device and function number */
+	int	vendor_id;		/* Vendor ID */
+	int	device_id;		/* Device ID */
+	int	class_code;		/* Device class code */
 
 	struct  pci_controller *phb;	/* for pci devices */
 	struct	iommu_table *iommu_table;	/* for phb's or bridges */
* Unmerged path arch/powerpc/kernel/pci_dn.c
