xfs: refactor shift-by-merge into xfs_bmse_merge() helper

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Brian Foster <bfoster@redhat.com>
commit ddb19e3180fa42362a04e86771d758be1de0bb13
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/ddb19e31.failed

The extent shift mechanism in xfs_bmap_shift_extents() is complicated
and handles several different, non-deterministic scenarios. These
include extent shifts, extent merges and potential btree updates in
either of the former scenarios.

Refactor the code to be more linear and readable. The loop logic in
xfs_bmap_shift_extents() and some initial error checking is adjusted
slightly. The associated btree lookup and update/delete operations are
condensed into single blocks of code. This reduces the number of
btree-specific blocks and facilitates the separation of the merge
operation into a new xfs_bmse_merge() and xfs_bmse_can_merge() helpers.

This is a code refactor only. The behavior of extent shift and collapse
range is not modified.

	Signed-off-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit ddb19e3180fa42362a04e86771d758be1de0bb13)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_bmap.c
diff --cc fs/xfs/libxfs/xfs_bmap.c
index b6f15ccf3239,532c4aab20f2..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@@ -5402,3 -5402,298 +5402,301 @@@ error0
  	}
  	return error;
  }
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * Determine whether an extent shift can be accomplished by a merge with the
+  * extent that precedes the target hole of the shift.
+  */
+ STATIC bool
+ xfs_bmse_can_merge(
+ 	struct xfs_bmbt_irec	*left,	/* preceding extent */
+ 	struct xfs_bmbt_irec	*got,	/* current extent to shift */
+ 	xfs_fileoff_t		shift)	/* shift fsb */
+ {
+ 	xfs_fileoff_t		startoff;
+ 
+ 	startoff = got->br_startoff - shift;
+ 
+ 	/*
+ 	 * The extent, once shifted, must be adjacent in-file and on-disk with
+ 	 * the preceding extent.
+ 	 */
+ 	if ((left->br_startoff + left->br_blockcount != startoff) ||
+ 	    (left->br_startblock + left->br_blockcount != got->br_startblock) ||
+ 	    (left->br_state != got->br_state) ||
+ 	    (left->br_blockcount + got->br_blockcount > MAXEXTLEN))
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ /*
+  * A bmap extent shift adjusts the file offset of an extent to fill a preceding
+  * hole in the file. If an extent shift would result in the extent being fully
+  * adjacent to the extent that currently precedes the hole, we can merge with
+  * the preceding extent rather than do the shift.
+  *
+  * This function assumes the caller has verified a shift-by-merge is possible
+  * with the provided extents via xfs_bmse_can_merge().
+  */
+ STATIC int
+ xfs_bmse_merge(
+ 	struct xfs_inode		*ip,
+ 	int				whichfork,
+ 	xfs_fileoff_t			shift,		/* shift fsb */
+ 	int				current_ext,	/* idx of gotp */
+ 	struct xfs_bmbt_rec_host	*gotp,		/* extent to shift */
+ 	struct xfs_bmbt_rec_host	*leftp,		/* preceding extent */
+ 	struct xfs_btree_cur		*cur,
+ 	int				*logflags)	/* output */
+ {
+ 	struct xfs_ifork		*ifp;
+ 	struct xfs_bmbt_irec		got;
+ 	struct xfs_bmbt_irec		left;
+ 	xfs_filblks_t			blockcount;
+ 	int				error, i;
+ 
+ 	ifp = XFS_IFORK_PTR(ip, whichfork);
+ 	xfs_bmbt_get_all(gotp, &got);
+ 	xfs_bmbt_get_all(leftp, &left);
+ 	blockcount = left.br_blockcount + got.br_blockcount;
+ 
+ 	ASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));
+ 	ASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));
+ 	ASSERT(xfs_bmse_can_merge(&left, &got, shift));
+ 
+ 	/*
+ 	 * Merge the in-core extents. Note that the host record pointers and
+ 	 * current_ext index are invalid once the extent has been removed via
+ 	 * xfs_iext_remove().
+ 	 */
+ 	xfs_bmbt_set_blockcount(leftp, blockcount);
+ 	xfs_iext_remove(ip, current_ext, 1, 0);
+ 
+ 	/*
+ 	 * Update the on-disk extent count, the btree if necessary and log the
+ 	 * inode.
+ 	 */
+ 	XFS_IFORK_NEXT_SET(ip, whichfork,
+ 			   XFS_IFORK_NEXTENTS(ip, whichfork) - 1);
+ 	*logflags |= XFS_ILOG_CORE;
+ 	if (!cur) {
+ 		*logflags |= XFS_ILOG_DEXT;
+ 		return 0;
+ 	}
+ 
+ 	/* lookup and remove the extent to merge */
+ 	error = xfs_bmbt_lookup_eq(cur, got.br_startoff, got.br_startblock,
+ 				   got.br_blockcount, &i);
+ 	if (error)
+ 		goto out_error;
+ 	XFS_WANT_CORRUPTED_GOTO(i == 1, out_error);
+ 
+ 	error = xfs_btree_delete(cur, &i);
+ 	if (error)
+ 		goto out_error;
+ 	XFS_WANT_CORRUPTED_GOTO(i == 1, out_error);
+ 
+ 	/* lookup and update size of the previous extent */
+ 	error = xfs_bmbt_lookup_eq(cur, left.br_startoff, left.br_startblock,
+ 				   left.br_blockcount, &i);
+ 	if (error)
+ 		goto out_error;
+ 	XFS_WANT_CORRUPTED_GOTO(i == 1, out_error);
+ 
+ 	left.br_blockcount = blockcount;
+ 
+ 	error = xfs_bmbt_update(cur, left.br_startoff, left.br_startblock,
+ 				left.br_blockcount, left.br_state);
+ 	if (error)
+ 		goto out_error;
+ 
+ 	return 0;
+ 
+ out_error:
+ 	return error;
+ }
+ 
+ /*
+  * Shift extent records to the left to cover a hole.
+  *
+  * The maximum number of extents to be shifted in a single operation is
+  * @num_exts. @start_fsb specifies the file offset to start the shift and the
+  * file offset where we've left off is returned in @next_fsb. @offset_shift_fsb
+  * is the length by which each extent is shifted. If there is no hole to shift
+  * the extents into, this will be considered invalid operation and we abort
+  * immediately.
+  */
+ int
+ xfs_bmap_shift_extents(
+ 	struct xfs_trans	*tp,
+ 	struct xfs_inode	*ip,
+ 	xfs_fileoff_t		start_fsb,
+ 	xfs_fileoff_t		offset_shift_fsb,
+ 	int			*done,
+ 	xfs_fileoff_t		*next_fsb,
+ 	xfs_fsblock_t		*firstblock,
+ 	struct xfs_bmap_free	*flist,
+ 	int			num_exts)
+ {
+ 	struct xfs_btree_cur		*cur = NULL;
+ 	struct xfs_bmbt_rec_host	*gotp;
+ 	struct xfs_bmbt_rec_host	*leftp;
+ 	struct xfs_bmbt_irec            got;
+ 	struct xfs_bmbt_irec		left;
+ 	struct xfs_mount		*mp = ip->i_mount;
+ 	struct xfs_ifork		*ifp;
+ 	xfs_extnum_t			nexts = 0;
+ 	xfs_extnum_t			current_ext;
+ 	xfs_fileoff_t			startoff;
+ 	int				error = 0;
+ 	int				i;
+ 	int				whichfork = XFS_DATA_FORK;
+ 	int				logflags = 0;
+ 	int				total_extents;
+ 
+ 	if (unlikely(XFS_TEST_ERROR(
+ 	    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&
+ 	     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),
+ 	     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {
+ 		XFS_ERROR_REPORT("xfs_bmap_shift_extents",
+ 				 XFS_ERRLEVEL_LOW, mp);
+ 		return -EFSCORRUPTED;
+ 	}
+ 
+ 	if (XFS_FORCED_SHUTDOWN(mp))
+ 		return -EIO;
+ 
+ 	ASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));
+ 	ASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));
+ 
+ 	ifp = XFS_IFORK_PTR(ip, whichfork);
+ 	if (!(ifp->if_flags & XFS_IFEXTENTS)) {
+ 		/* Read in all the extents */
+ 		error = xfs_iread_extents(tp, ip, whichfork);
+ 		if (error)
+ 			return error;
+ 	}
+ 
+ 	if (ifp->if_flags & XFS_IFBROOT) {
+ 		cur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);
+ 		cur->bc_private.b.firstblock = *firstblock;
+ 		cur->bc_private.b.flist = flist;
+ 		cur->bc_private.b.flags = 0;
+ 	}
+ 
+ 	/*
+ 	 * Look up the extent index for the fsb where we start shifting. We can
+ 	 * henceforth iterate with current_ext as extent list changes are locked
+ 	 * out via ilock.
+ 	 *
+ 	 * gotp can be null in 2 cases: 1) if there are no extents or 2)
+ 	 * start_fsb lies in a hole beyond which there are no extents. Either
+ 	 * way, we are done.
+ 	 */
+ 	gotp = xfs_iext_bno_to_ext(ifp, start_fsb, &current_ext);
+ 	if (!gotp) {
+ 		*done = 1;
+ 		goto del_cursor;
+ 	}
+ 	xfs_bmbt_get_all(gotp, &got);
+ 
+ 	/*
+ 	 * If the first extent is shifted, offset_shift_fsb cannot be larger
+ 	 * than the starting offset of the first extent.
+ 	 */
+ 	if (current_ext == 0 && got.br_startoff < offset_shift_fsb) {
+ 		error = -EINVAL;
+ 		goto del_cursor;
+ 	}
+ 
+ 	/*
+ 	 * There may be delalloc extents in the data fork before the range we
+ 	 * are collapsing out, so we cannot use the count of real extents here.
+ 	 * Instead we have to calculate it from the incore fork.
+ 	 */
+ 	total_extents = ifp->if_bytes / sizeof(xfs_bmbt_rec_t);
+ 	while (nexts++ < num_exts && current_ext < total_extents) {
+ 		startoff = got.br_startoff - offset_shift_fsb;
+ 
+ 		/* grab the left extent and check for a potential merge */
+ 		if (current_ext > 0) {
+ 			leftp = xfs_iext_get_ext(ifp, current_ext - 1);
+ 			xfs_bmbt_get_all(leftp, &left);
+ 
+ 			/* make sure hole is large enough for shift */
+ 			if (startoff < left.br_startoff + left.br_blockcount) {
+ 				error = -EINVAL;
+ 				goto del_cursor;
+ 			}
+ 
+ 			if (xfs_bmse_can_merge(&left, &got, offset_shift_fsb)) {
+ 				error = xfs_bmse_merge(ip, whichfork,
+ 						offset_shift_fsb, current_ext, gotp,
+ 						leftp, cur, &logflags);
+ 				if (error)
+ 					goto del_cursor;
+ 
+ 				/*
+ 				 * The extent was merged so adjust the extent
+ 				 * index and move onto the next.
+ 				 */
+ 				current_ext--;
+ 				goto next;
+ 			}
+ 		}
+ 
+ 		/*
+ 		 * We didn't merge the extent so do the shift. Update the start
+ 		 * offset in the in-core extent and btree, if necessary.
+ 		 */
+ 		xfs_bmbt_set_startoff(gotp, startoff);
+ 		logflags |= XFS_ILOG_CORE;
+ 		if (cur) {
+ 			error = xfs_bmbt_lookup_eq(cur, got.br_startoff,
+ 						   got.br_startblock,
+ 						   got.br_blockcount,
+ 						   &i);
+ 			if (error)
+ 				goto del_cursor;
+ 			XFS_WANT_CORRUPTED_GOTO(i == 1, del_cursor);
+ 
+ 			got.br_startoff = startoff;
+ 			error = xfs_bmbt_update(cur, got.br_startoff,
+ 						got.br_startblock,
+ 						got.br_blockcount,
+ 						got.br_state);
+ 			if (error)
+ 				goto del_cursor;
+ 		} else {
+ 			logflags |= XFS_ILOG_DEXT;
+ 		}
+ 
+ next:
+ 		/* update total extent count and grab the next record */
+ 		total_extents = ifp->if_bytes / sizeof(xfs_bmbt_rec_t);
+ 		if (++current_ext >= total_extents)
+ 			break;
+ 		gotp = xfs_iext_get_ext(ifp, current_ext);
+ 		xfs_bmbt_get_all(gotp, &got);
+ 	}
+ 
+ 	/* Check if we are done */
+ 	if (current_ext == total_extents)
+ 		*done = 1;
+ 	else if (next_fsb)
+ 		*next_fsb = got.br_startoff;
+ 
+ del_cursor:
+ 	if (cur)
+ 		xfs_btree_del_cursor(cur,
+ 			error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);
+ 
+ 	if (logflags)
+ 		xfs_trans_log_inode(tp, ip, logflags);
+ 
+ 	return error;
+ }
++>>>>>>> ddb19e3180fa (xfs: refactor shift-by-merge into xfs_bmse_merge() helper)
* Unmerged path fs/xfs/libxfs/xfs_bmap.c
