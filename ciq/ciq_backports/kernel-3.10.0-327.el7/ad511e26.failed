crypto: qat - Fix incorrect uses of memzero_explicit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [crypto] qat - Fix incorrect uses of memzero_explicit (Nikolay Aleksandrov) [1173791]
Rebuild_FUZZ: 91.67%
commit-author Herbert Xu <herbert@gondor.apana.org.au>
commit ad511e260a27b8e35d273cc0ecfe5a8ff9543181
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/ad511e26.failed

memzero_explicit should only be used on stack variables that get
zapped just before they go out of scope.

This patch replaces all unnecessary uses of memzero_explicit with
memset, removes two memzero_explicit calls altogether as the tfm
context comes pre-zeroed, and adds a missing memzero_explicit of
the stack variable buff in qat_alg_do_precomputes.  The memzeros
on ipad/opad + digest_size/auth_keylen are also removed as the
entire auth_state is already zeroed on entry.

	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
	Acked-by: Tadeusz Struk <tadeusz.struk@intel.com>
(cherry picked from commit ad511e260a27b8e35d273cc0ecfe5a8ff9543181)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/qat/qat_common/qat_algs.c
diff --cc drivers/crypto/qat/qat_common/qat_algs.c
index 5d93760fdd84,a0d95f329094..000000000000
--- a/drivers/crypto/qat/qat_common/qat_algs.c
+++ b/drivers/crypto/qat/qat_common/qat_algs.c
@@@ -161,7 -173,7 +161,11 @@@ static int qat_alg_do_precomputes(struc
  	__be64 *hash512_state_out;
  	int i, offset;
  
++<<<<<<< HEAD
 +	memset(auth_state.data, '\0', MAX_AUTH_STATE_SIZE + 64);
++=======
+ 	memset(auth_state.data, 0, sizeof(auth_state.data));
++>>>>>>> ad511e260a27 (crypto: qat - Fix incorrect uses of memzero_explicit)
  	shash->tfm = ctx->hash_tfm;
  	shash->flags = 0x0;
  
@@@ -174,13 -186,10 +178,20 @@@
  
  		memcpy(ipad, buff, digest_size);
  		memcpy(opad, buff, digest_size);
++<<<<<<< HEAD
 +		memset(ipad + digest_size, 0, block_size - digest_size);
 +		memset(opad + digest_size, 0, block_size - digest_size);
 +	} else {
 +		memcpy(ipad, auth_key, auth_keylen);
 +		memcpy(opad, auth_key, auth_keylen);
 +		memset(ipad + auth_keylen, 0, block_size - auth_keylen);
 +		memset(opad + auth_keylen, 0, block_size - auth_keylen);
++=======
+ 		memzero_explicit(buff, sizeof(buff));
+ 	} else {
+ 		memcpy(ipad, auth_key, auth_keylen);
+ 		memcpy(opad, auth_key, auth_keylen);
++>>>>>>> ad511e260a27 (crypto: qat - Fix incorrect uses of memzero_explicit)
  	}
  
  	for (i = 0; i < block_size; i++) {
@@@ -492,12 -579,10 +503,19 @@@ static int qat_alg_setkey(struct crypto
  	if (ctx->enc_cd) {
  		/* rekeying */
  		dev = &GET_DEV(ctx->inst->accel_dev);
++<<<<<<< HEAD
 +		memset(ctx->enc_cd, 0, sizeof(struct qat_alg_cd));
 +		memset(ctx->dec_cd, 0, sizeof(struct qat_alg_cd));
 +		memset(&ctx->enc_fw_req_tmpl, 0,
 +		       sizeof(struct icp_qat_fw_la_bulk_req));
 +		memset(&ctx->dec_fw_req_tmpl, 0,
 +		       sizeof(struct icp_qat_fw_la_bulk_req));
++=======
+ 		memset(ctx->enc_cd, 0, sizeof(*ctx->enc_cd));
+ 		memset(ctx->dec_cd, 0, sizeof(*ctx->dec_cd));
+ 		memset(&ctx->enc_fw_req, 0, sizeof(ctx->enc_fw_req));
+ 		memset(&ctx->dec_fw_req, 0, sizeof(ctx->dec_fw_req));
++>>>>>>> ad511e260a27 (crypto: qat - Fix incorrect uses of memzero_explicit)
  	} else {
  		/* new key */
  		int node = get_current_node();
@@@ -534,10 -617,12 +552,18 @@@
  	return 0;
  
  out_free_all:
++<<<<<<< HEAD
++=======
+ 	memset(ctx->dec_cd, 0, sizeof(struct qat_alg_cd));
++>>>>>>> ad511e260a27 (crypto: qat - Fix incorrect uses of memzero_explicit)
  	dma_free_coherent(dev, sizeof(struct qat_alg_cd),
  			  ctx->dec_cd, ctx->dec_cd_paddr);
  	ctx->dec_cd = NULL;
  out_free_enc:
++<<<<<<< HEAD
++=======
+ 	memset(ctx->enc_cd, 0, sizeof(struct qat_alg_cd));
++>>>>>>> ad511e260a27 (crypto: qat - Fix incorrect uses of memzero_explicit)
  	dma_free_coherent(dev, sizeof(struct qat_alg_cd),
  			  ctx->enc_cd, ctx->enc_cd_paddr);
  	ctx->enc_cd = NULL;
@@@ -843,15 -952,152 +869,154 @@@ static int qat_alg_genivenc(struct aead
  	seq = cpu_to_be64(req->seq);
  	memcpy(req->giv + AES_BLOCK_SIZE - sizeof(uint64_t),
  	       &seq, sizeof(uint64_t));
 -	return qat_alg_aead_enc_internal(&req->areq, req->giv, 1);
 +	return qat_alg_enc_internal(&req->areq, req->giv, 1);
  }
  
 -static int qat_alg_ablkcipher_setkey(struct crypto_ablkcipher *tfm,
 -				     const uint8_t *key,
 -				     unsigned int keylen)
 +static int qat_alg_init(struct crypto_tfm *tfm,
 +			enum icp_qat_hw_auth_algo hash, const char *hash_name)
  {
 -	struct qat_alg_ablkcipher_ctx *ctx = crypto_ablkcipher_ctx(tfm);
 -	struct device *dev;
 +	struct qat_alg_session_ctx *ctx = crypto_tfm_ctx(tfm);
  
++<<<<<<< HEAD
 +	memset(ctx, '\0', sizeof(*ctx));
++=======
+ 	spin_lock(&ctx->lock);
+ 	if (ctx->enc_cd) {
+ 		/* rekeying */
+ 		dev = &GET_DEV(ctx->inst->accel_dev);
+ 		memset(ctx->enc_cd, 0, sizeof(*ctx->enc_cd));
+ 		memset(ctx->dec_cd, 0, sizeof(*ctx->dec_cd));
+ 		memset(&ctx->enc_fw_req, 0, sizeof(ctx->enc_fw_req));
+ 		memset(&ctx->dec_fw_req, 0, sizeof(ctx->dec_fw_req));
+ 	} else {
+ 		/* new key */
+ 		int node = get_current_node();
+ 		struct qat_crypto_instance *inst =
+ 				qat_crypto_get_instance_node(node);
+ 		if (!inst) {
+ 			spin_unlock(&ctx->lock);
+ 			return -EINVAL;
+ 		}
+ 
+ 		dev = &GET_DEV(inst->accel_dev);
+ 		ctx->inst = inst;
+ 		ctx->enc_cd = dma_zalloc_coherent(dev, sizeof(*ctx->enc_cd),
+ 						  &ctx->enc_cd_paddr,
+ 						  GFP_ATOMIC);
+ 		if (!ctx->enc_cd) {
+ 			spin_unlock(&ctx->lock);
+ 			return -ENOMEM;
+ 		}
+ 		ctx->dec_cd = dma_zalloc_coherent(dev, sizeof(*ctx->dec_cd),
+ 						  &ctx->dec_cd_paddr,
+ 						  GFP_ATOMIC);
+ 		if (!ctx->dec_cd) {
+ 			spin_unlock(&ctx->lock);
+ 			goto out_free_enc;
+ 		}
+ 	}
+ 	spin_unlock(&ctx->lock);
+ 	if (qat_alg_ablkcipher_init_sessions(ctx, key, keylen))
+ 		goto out_free_all;
+ 
+ 	return 0;
+ 
+ out_free_all:
+ 	memset(ctx->dec_cd, 0, sizeof(*ctx->enc_cd));
+ 	dma_free_coherent(dev, sizeof(*ctx->enc_cd),
+ 			  ctx->dec_cd, ctx->dec_cd_paddr);
+ 	ctx->dec_cd = NULL;
+ out_free_enc:
+ 	memset(ctx->enc_cd, 0, sizeof(*ctx->dec_cd));
+ 	dma_free_coherent(dev, sizeof(*ctx->dec_cd),
+ 			  ctx->enc_cd, ctx->enc_cd_paddr);
+ 	ctx->enc_cd = NULL;
+ 	return -ENOMEM;
+ }
+ 
+ static int qat_alg_ablkcipher_encrypt(struct ablkcipher_request *req)
+ {
+ 	struct crypto_ablkcipher *atfm = crypto_ablkcipher_reqtfm(req);
+ 	struct crypto_tfm *tfm = crypto_ablkcipher_tfm(atfm);
+ 	struct qat_alg_ablkcipher_ctx *ctx = crypto_tfm_ctx(tfm);
+ 	struct qat_crypto_request *qat_req = ablkcipher_request_ctx(req);
+ 	struct icp_qat_fw_la_cipher_req_params *cipher_param;
+ 	struct icp_qat_fw_la_bulk_req *msg;
+ 	int ret, ctr = 0;
+ 
+ 	ret = qat_alg_sgl_to_bufl(ctx->inst, NULL, req->src, req->dst,
+ 				  NULL, 0, qat_req);
+ 	if (unlikely(ret))
+ 		return ret;
+ 
+ 	msg = &qat_req->req;
+ 	*msg = ctx->enc_fw_req;
+ 	qat_req->ablkcipher_ctx = ctx;
+ 	qat_req->ablkcipher_req = req;
+ 	qat_req->cb = qat_ablkcipher_alg_callback;
+ 	qat_req->req.comn_mid.opaque_data = (uint64_t)(__force long)qat_req;
+ 	qat_req->req.comn_mid.src_data_addr = qat_req->buf.blp;
+ 	qat_req->req.comn_mid.dest_data_addr = qat_req->buf.bloutp;
+ 	cipher_param = (void *)&qat_req->req.serv_specif_rqpars;
+ 	cipher_param->cipher_length = req->nbytes;
+ 	cipher_param->cipher_offset = 0;
+ 	memcpy(cipher_param->u.cipher_IV_array, req->info, AES_BLOCK_SIZE);
+ 	do {
+ 		ret = adf_send_message(ctx->inst->sym_tx, (uint32_t *)msg);
+ 	} while (ret == -EAGAIN && ctr++ < 10);
+ 
+ 	if (ret == -EAGAIN) {
+ 		qat_alg_free_bufl(ctx->inst, qat_req);
+ 		return -EBUSY;
+ 	}
+ 	return -EINPROGRESS;
+ }
+ 
+ static int qat_alg_ablkcipher_decrypt(struct ablkcipher_request *req)
+ {
+ 	struct crypto_ablkcipher *atfm = crypto_ablkcipher_reqtfm(req);
+ 	struct crypto_tfm *tfm = crypto_ablkcipher_tfm(atfm);
+ 	struct qat_alg_ablkcipher_ctx *ctx = crypto_tfm_ctx(tfm);
+ 	struct qat_crypto_request *qat_req = ablkcipher_request_ctx(req);
+ 	struct icp_qat_fw_la_cipher_req_params *cipher_param;
+ 	struct icp_qat_fw_la_bulk_req *msg;
+ 	int ret, ctr = 0;
+ 
+ 	ret = qat_alg_sgl_to_bufl(ctx->inst, NULL, req->src, req->dst,
+ 				  NULL, 0, qat_req);
+ 	if (unlikely(ret))
+ 		return ret;
+ 
+ 	msg = &qat_req->req;
+ 	*msg = ctx->dec_fw_req;
+ 	qat_req->ablkcipher_ctx = ctx;
+ 	qat_req->ablkcipher_req = req;
+ 	qat_req->cb = qat_ablkcipher_alg_callback;
+ 	qat_req->req.comn_mid.opaque_data = (uint64_t)(__force long)qat_req;
+ 	qat_req->req.comn_mid.src_data_addr = qat_req->buf.blp;
+ 	qat_req->req.comn_mid.dest_data_addr = qat_req->buf.bloutp;
+ 	cipher_param = (void *)&qat_req->req.serv_specif_rqpars;
+ 	cipher_param->cipher_length = req->nbytes;
+ 	cipher_param->cipher_offset = 0;
+ 	memcpy(cipher_param->u.cipher_IV_array, req->info, AES_BLOCK_SIZE);
+ 	do {
+ 		ret = adf_send_message(ctx->inst->sym_tx, (uint32_t *)msg);
+ 	} while (ret == -EAGAIN && ctr++ < 10);
+ 
+ 	if (ret == -EAGAIN) {
+ 		qat_alg_free_bufl(ctx->inst, qat_req);
+ 		return -EBUSY;
+ 	}
+ 	return -EINPROGRESS;
+ }
+ 
+ static int qat_alg_aead_init(struct crypto_tfm *tfm,
+ 			     enum icp_qat_hw_auth_algo hash,
+ 			     const char *hash_name)
+ {
+ 	struct qat_alg_aead_ctx *ctx = crypto_tfm_ctx(tfm);
+ 
++>>>>>>> ad511e260a27 (crypto: qat - Fix incorrect uses of memzero_explicit)
  	ctx->hash_tfm = crypto_alloc_shash(hash_name, 0, 0);
  	if (IS_ERR(ctx->hash_tfm))
  		return -EFAULT;
@@@ -891,12 -1137,54 +1056,63 @@@ static void qat_alg_exit(struct crypto_
  		return;
  
  	dev = &GET_DEV(inst->accel_dev);
++<<<<<<< HEAD
 +	if (ctx->enc_cd)
 +		dma_free_coherent(dev, sizeof(struct qat_alg_cd),
 +				  ctx->enc_cd, ctx->enc_cd_paddr);
 +	if (ctx->dec_cd)
 +		dma_free_coherent(dev, sizeof(struct qat_alg_cd),
 +				  ctx->dec_cd, ctx->dec_cd_paddr);
++=======
+ 	if (ctx->enc_cd) {
+ 		memset(ctx->enc_cd, 0, sizeof(struct qat_alg_cd));
+ 		dma_free_coherent(dev, sizeof(struct qat_alg_cd),
+ 				  ctx->enc_cd, ctx->enc_cd_paddr);
+ 	}
+ 	if (ctx->dec_cd) {
+ 		memset(ctx->dec_cd, 0, sizeof(struct qat_alg_cd));
+ 		dma_free_coherent(dev, sizeof(struct qat_alg_cd),
+ 				  ctx->dec_cd, ctx->dec_cd_paddr);
+ 	}
+ 	qat_crypto_put_instance(inst);
+ }
+ 
+ static int qat_alg_ablkcipher_init(struct crypto_tfm *tfm)
+ {
+ 	struct qat_alg_ablkcipher_ctx *ctx = crypto_tfm_ctx(tfm);
+ 
+ 	spin_lock_init(&ctx->lock);
+ 	tfm->crt_ablkcipher.reqsize = sizeof(struct ablkcipher_request) +
+ 					sizeof(struct qat_crypto_request);
+ 	ctx->tfm = tfm;
+ 	return 0;
+ }
+ 
+ static void qat_alg_ablkcipher_exit(struct crypto_tfm *tfm)
+ {
+ 	struct qat_alg_ablkcipher_ctx *ctx = crypto_tfm_ctx(tfm);
+ 	struct qat_crypto_instance *inst = ctx->inst;
+ 	struct device *dev;
+ 
+ 	if (!inst)
+ 		return;
+ 
+ 	dev = &GET_DEV(inst->accel_dev);
+ 	if (ctx->enc_cd) {
+ 		memset(ctx->enc_cd, 0,
+ 		       sizeof(struct icp_qat_hw_cipher_algo_blk));
+ 		dma_free_coherent(dev,
+ 				  sizeof(struct icp_qat_hw_cipher_algo_blk),
+ 				  ctx->enc_cd, ctx->enc_cd_paddr);
+ 	}
+ 	if (ctx->dec_cd) {
+ 		memset(ctx->dec_cd, 0,
+ 		       sizeof(struct icp_qat_hw_cipher_algo_blk));
+ 		dma_free_coherent(dev,
+ 				  sizeof(struct icp_qat_hw_cipher_algo_blk),
+ 				  ctx->dec_cd, ctx->dec_cd_paddr);
+ 	}
++>>>>>>> ad511e260a27 (crypto: qat - Fix incorrect uses of memzero_explicit)
  	qat_crypto_put_instance(inst);
  }
  
* Unmerged path drivers/crypto/qat/qat_common/qat_algs.c
