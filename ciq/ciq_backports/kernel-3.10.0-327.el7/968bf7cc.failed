ipmi: Fix handling of BMC flags

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Corey Minyard <cminyard@mvista.com>
commit 968bf7cc47bff66966149c14ad6c7024d67534aa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/968bf7cc.failed

The handling of BMC flags wasn't quite right in a few places, mainly
around enabling and disabling interrupts in the BMC.  Clean up the
code and fix the handling of the flags.

	Signed-off-by: Corey Minyard <cminyard@mvista.com>
(cherry picked from commit 968bf7cc47bff66966149c14ad6c7024d67534aa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/ipmi/ipmi_si_intf.c
diff --cc drivers/char/ipmi/ipmi_si_intf.c
index f73439915954,e36487db0e94..000000000000
--- a/drivers/char/ipmi/ipmi_si_intf.c
+++ b/drivers/char/ipmi/ipmi_si_intf.c
@@@ -445,18 -482,41 +474,51 @@@ static inline bool disable_si_irq(struc
  {
  	if ((smi_info->irq) && (!smi_info->interrupt_disabled)) {
  		start_disable_irq(smi_info);
++<<<<<<< HEAD
 +		smi_info->interrupt_disabled = 1;
 +		if (!atomic_read(&smi_info->stop_operation))
 +			smi_mod_timer(smi_info, jiffies + SI_TIMEOUT_JIFFIES);
++=======
+ 		smi_info->interrupt_disabled = true;
+ 		return true;
++>>>>>>> 968bf7cc47bf (ipmi: Fix handling of BMC flags)
  	}
+ 	return false;
  }
  
- static inline void enable_si_irq(struct smi_info *smi_info)
+ static inline bool enable_si_irq(struct smi_info *smi_info)
  {
  	if ((smi_info->irq) && (smi_info->interrupt_disabled)) {
  		start_enable_irq(smi_info);
++<<<<<<< HEAD
 +		smi_info->interrupt_disabled = 0;
++=======
+ 		smi_info->interrupt_disabled = false;
+ 		return true;
++>>>>>>> 968bf7cc47bf (ipmi: Fix handling of BMC flags)
+ 	}
+ 	return false;
+ }
+ 
+ /*
+  * Allocate a message.  If unable to allocate, start the interrupt
+  * disable process and return NULL.  If able to allocate but
+  * interrupts are disabled, free the message and return NULL after
+  * starting the interrupt enable process.
+  */
+ static struct ipmi_smi_msg *alloc_msg_handle_irq(struct smi_info *smi_info)
+ {
+ 	struct ipmi_smi_msg *msg;
+ 
+ 	msg = ipmi_alloc_smi_msg();
+ 	if (!msg) {
+ 		if (!disable_si_irq(smi_info))
+ 			smi_info->si_state = SI_NORMAL;
+ 	} else if (enable_si_irq(smi_info)) {
+ 		ipmi_free_smi_msg(msg);
+ 		msg = NULL;
  	}
+ 	return msg;
  }
  
  static void handle_flags(struct smi_info *smi_info)
@@@ -700,8 -737,10 +739,15 @@@ static void handle_transaction_done(str
  			dev_warn(smi_info->dev,
  				 "Maybe ok, but ipmi might run very slowly.\n");
  		} else
++<<<<<<< HEAD
 +			smi_info->interrupt_disabled = 0;
 +		smi_info->si_state = SI_NORMAL;
++=======
+ 			smi_info->interrupt_disabled = false;
+ 
+ 		/* We enabled interrupts, flags may be pending. */
+ 		handle_flags(smi_info);
++>>>>>>> 968bf7cc47bf (ipmi: Fix handling of BMC flags)
  		break;
  	}
  
* Unmerged path drivers/char/ipmi/ipmi_si_intf.c
