bonding: remove locking from bond_set_rx_mode()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Veaceslav Falico <vfalico@redhat.com>
commit 7864a1adf7291993d74923fdd0a45459ce9da27e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/7864a1ad.failed

We're already protected by RTNL lock, so nothing can happen to bond/its
slaves, and thus the locking is useless here (both bond->lock and
bond->curr_active_slave).

Also, add ASSERT_RTNL() both to bond_set_rx_mode() and bond_hw_addr_swap()
to catch possible uses of it without RTNL locking.

This patch also saves us from a lockdep false-positive in
bond_set_rx_mode() vs bond_hw_addr_swap().

CC: Jay Vosburgh <fubar@us.ibm.com>
CC: Andy Gospodarek <andy@greyhouse.net>
CC: Nikolay Aleksandrov <nikolay@redhat.com>
	Signed-off-by: Veaceslav Falico <vfalico@redhat.com>
	Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7864a1adf7291993d74923fdd0a45459ce9da27e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
diff --cc drivers/net/bonding/bond_main.c
index ef8213746e65,5697043eafbd..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -810,21 -768,15 +810,25 @@@ static void bond_mc_list_flush(struct n
  
  /*--------------------------- Active slave change ---------------------------*/
  
 -/* Update the hardware address list and promisc/allmulti for the new and
 - * old active slaves (if any).  Modes that are !USES_PRIMARY keep all
 - * slaves up date at all times; only the USES_PRIMARY modes need to call
 - * this function to swap these settings during a failover.
 +/*
 + * Update the mc list and multicast-related flags for the new and
 + * old active slaves (if any) according to the multicast mode, and
 + * promiscuous flags unconditionally.
   */
 -static void bond_hw_addr_swap(struct bonding *bond, struct slave *new_active,
 -			      struct slave *old_active)
 +static void bond_mc_swap(struct bonding *bond, struct slave *new_active,
 +			 struct slave *old_active)
  {
++<<<<<<< HEAD
 +	struct netdev_hw_addr *ha;
 +
 +	if (!USES_PRIMARY(bond->params.mode))
 +		/* nothing to do -  mc list is already up-to-date on
 +		 * all slaves
 +		 */
 +		return;
++=======
+ 	ASSERT_RTNL();
++>>>>>>> 7864a1adf729 (bonding: remove locking from bond_set_rx_mode())
  
  	if (old_active) {
  		if (bond->dev->flags & IFF_PROMISC)
@@@ -3665,36 -3548,25 +3669,51 @@@ static void bond_change_rx_flags(struc
  				  bond_dev->flags & IFF_ALLMULTI ? 1 : -1);
  }
  
 -static void bond_set_rx_mode(struct net_device *bond_dev)
 +static void bond_set_multicast_list(struct net_device *bond_dev)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
 -	struct slave *slave;
 +	struct netdev_hw_addr *ha;
 +	bool found;
  
- 	read_lock(&bond->lock);
+ 	ASSERT_RTNL();
  
++<<<<<<< HEAD
 +	/* looking for addresses to add to slaves' mc list */
 +	netdev_for_each_mc_addr(ha, bond_dev) {
 +		found = bond_addr_in_mc_list(ha->addr, &bond->mc_list,
 +					     bond_dev->addr_len);
 +		if (!found)
 +			bond_mc_add(bond, ha->addr);
 +	}
 +
 +	/* looking for addresses to delete from slaves' list */
 +	netdev_hw_addr_list_for_each(ha, &bond->mc_list) {
 +		found = bond_addr_in_mc_list(ha->addr, &bond_dev->mc,
 +					     bond_dev->addr_len);
 +		if (!found)
 +			bond_mc_del(bond, ha->addr);
 +	}
 +
 +	/* save master's multicast list */
 +	__hw_addr_flush(&bond->mc_list);
 +	__hw_addr_add_multiple(&bond->mc_list, &bond_dev->mc,
 +			       bond_dev->addr_len, NETDEV_HW_ADDR_T_MULTICAST);
 +
 +	read_unlock(&bond->lock);
++=======
+ 	if (USES_PRIMARY(bond->params.mode)) {
+ 		slave = rtnl_dereference(bond->curr_active_slave);
+ 		if (slave) {
+ 			dev_uc_sync(slave->dev, bond_dev);
+ 			dev_mc_sync(slave->dev, bond_dev);
+ 		}
+ 	} else {
+ 		bond_for_each_slave(bond, slave) {
+ 			dev_uc_sync_multiple(slave->dev, bond_dev);
+ 			dev_mc_sync_multiple(slave->dev, bond_dev);
+ 		}
+ 	}
++>>>>>>> 7864a1adf729 (bonding: remove locking from bond_set_rx_mode())
  }
  
  static int bond_neigh_init(struct neighbour *n)
* Unmerged path drivers/net/bonding/bond_main.c
