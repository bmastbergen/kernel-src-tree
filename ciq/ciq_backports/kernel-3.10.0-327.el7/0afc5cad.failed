perf build: Separate feature make support into config/Makefile.feature

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [perf] build: Separate feature make support into config/Makefile.feature (Jiri Olsa) [1222189]
Rebuild_FUZZ: 96.30%
commit-author Jiri Olsa <jolsa@kernel.org>
commit 0afc5cad387db56054b09bb14baf0e6e49df2fd2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/0afc5cad.failed

Move feature related code into separate makefile. The new
Makefile.feature is included from config/Makefile. It will be moved
later into tools/build.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Corey Ashford <cjashfor@linux.vnet.ibm.com>
	Cc: David Ahern <david.ahern@oracle.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/n/tip-kj76wphg05x83n6d5ff85ybx@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 0afc5cad387db56054b09bb14baf0e6e49df2fd2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/config/Makefile
diff --cc tools/perf/config/Makefile
index 49715ac798cd,01278429965a..000000000000
--- a/tools/perf/config/Makefile
+++ b/tools/perf/config/Makefile
@@@ -170,104 -176,7 +170,108 @@@ LDFLAGS += -Wl,-z,noexecstac
  
  EXTLIBS = -lpthread -lrt -lm -ldl
  
++<<<<<<< HEAD
 +ifneq ($(OUTPUT),)
 +  OUTPUT_FEATURES = $(OUTPUT)config/feature-checks/
 +  $(shell mkdir -p $(OUTPUT_FEATURES))
 +endif
 +
 +feature_check = $(eval $(feature_check_code))
 +define feature_check_code
 +  feature-$(1) := $(shell $(MAKE) OUTPUT=$(OUTPUT_FEATURES) CFLAGS="$(EXTRA_CFLAGS) $(FEATURE_CHECK_CFLAGS-$(1))" LDFLAGS="$(LDFLAGS) $(FEATURE_CHECK_LDFLAGS-$(1))" -C config/feature-checks test-$1.bin >/dev/null 2>/dev/null && echo 1 || echo 0)
 +endef
 +
 +feature_set = $(eval $(feature_set_code))
 +define feature_set_code
 +  feature-$(1) := 1
 +endef
 +
 +#
 +# Build the feature check binaries in parallel, ignore errors, ignore return value and suppress output:
 +#
 +
 +#
 +# Note that this is not a complete list of all feature tests, just
 +# those that are typically built on a fully configured system.
 +#
 +# [ Feature tests not mentioned here have to be built explicitly in
 +#   the rule that uses them - an example for that is the 'bionic'
 +#   feature check. ]
 +#
 +FEATURE_TESTS =			\
 +	backtrace			\
 +	dwarf				\
 +	fortify-source			\
 +	sync-compare-and-swap		\
 +	glibc				\
 +	gtk2				\
 +	gtk2-infobar			\
 +	libaudit			\
 +	libbfd				\
 +	libelf				\
 +	libelf-getphdrnum		\
 +	libelf-mmap			\
 +	libnuma				\
 +	libperl				\
 +	libpython			\
 +	libpython-version		\
 +	libslang			\
 +	libunwind			\
 +	pthread-attr-setaffinity-np	\
 +	stackprotector-all		\
 +	timerfd				\
 +	libdw-dwarf-unwind		\
 +	libbabeltrace			\
 +	zlib
 +
 +FEATURE_DISPLAY =			\
 +	dwarf				\
 +	glibc				\
 +	gtk2				\
 +	libaudit			\
 +	libbfd				\
 +	libelf				\
 +	libnuma				\
 +	libperl				\
 +	libpython			\
 +	libslang			\
 +	libunwind			\
 +	libdw-dwarf-unwind		\
 +	libbabeltrace			\
 +	zlib
 +
 +# Set FEATURE_CHECK_(C|LD)FLAGS-all for all FEATURE_TESTS features.
 +# If in the future we need per-feature checks/flags for features not
 +# mentioned in this list we need to refactor this ;-).
 +set_test_all_flags = $(eval $(set_test_all_flags_code))
 +define set_test_all_flags_code
 +  FEATURE_CHECK_CFLAGS-all  += $(FEATURE_CHECK_CFLAGS-$(1))
 +  FEATURE_CHECK_LDFLAGS-all += $(FEATURE_CHECK_LDFLAGS-$(1))
 +endef
 +
 +$(foreach feat,$(FEATURE_TESTS),$(call set_test_all_flags,$(feat)))
 +
 +#
 +# Special fast-path for the 'all features are available' case:
 +#
 +$(call feature_check,all,$(MSG))
 +
 +#
 +# Just in case the build freshly failed, make sure we print the
 +# feature matrix:
 +#
 +ifeq ($(feature-all), 1)
 +  #
 +  # test-all.c passed - just set all the core feature flags to 1:
 +  #
 +  $(foreach feat,$(FEATURE_TESTS),$(call feature_set,$(feat)))
 +else
 +  $(shell $(MAKE) OUTPUT=$(OUTPUT_FEATURES) CFLAGS="$(EXTRA_CFLAGS)" LDFLAGS=$(LDFLAGS) -i -j -C config/feature-checks $(addsuffix .bin,$(FEATURE_TESTS)) >/dev/null 2>&1)
 +  $(foreach feat,$(FEATURE_TESTS),$(call feature_check,$(feat)))
 +endif
++=======
+ include $(src-perf)/config/Makefile.feature
++>>>>>>> 0afc5cad387d (perf build: Separate feature make support into config/Makefile.feature)
  
  ifeq ($(feature-stackprotector-all), 1)
    CFLAGS += -fstack-protector-all
@@@ -767,62 -673,7 +758,43 @@@ define print_var_cod
      MSG = $(shell printf '...%30s: %s' $(1) $($(1)))
  endef
  
++<<<<<<< HEAD
 +feature_print_text = $(eval $(feature_print_text_code)) $(info $(MSG))
 +define feature_print_text_code
 +    MSG = $(shell printf '...%30s: %s' $(1) $(2))
 +endef
 +
 +PERF_FEATURES := $(foreach feat,$(FEATURE_DISPLAY),feature-$(feat)($(feature-$(feat))))
 +PERF_FEATURES_FILE := $(shell touch $(OUTPUT)PERF-FEATURES; cat $(OUTPUT)PERF-FEATURES)
 +
 +ifeq ($(dwarf-post-unwind),1)
 +  PERF_FEATURES += dwarf-post-unwind($(dwarf-post-unwind-text))
 +endif
 +
 +# The $(feature_display) controls the default detection message
 +# output. It's set if:
 +# - detected features differes from stored features from
 +#   last build (in PERF-FEATURES file)
 +# - one of the $(FEATURE_DISPLAY) is not detected
 +# - VF is enabled
 +
 +ifneq ("$(PERF_FEATURES)","$(PERF_FEATURES_FILE)")
 +  $(shell echo "$(PERF_FEATURES)" > $(OUTPUT)PERF-FEATURES)
 +  feature_display := 1
 +endif
 +
 +feature_display_check = $(eval $(feature_check_code))
 +define feature_display_check_code
 +  ifneq ($(feature-$(1)), 1)
 +    feature_display := 1
 +  endif
 +endef
 +
 +$(foreach feat,$(FEATURE_DISPLAY),$(call feature_display_check,$(feat)))
 +
++=======
++>>>>>>> 0afc5cad387d (perf build: Separate feature make support into config/Makefile.feature)
  ifeq ($(VF),1)
-   feature_display := 1
-   feature_verbose := 1
- endif
- 
- ifeq ($(feature_display),1)
-   $(info )
-   $(info Auto-detecting system features:)
-   $(foreach feat,$(FEATURE_DISPLAY),$(call feature_print_status,$(feat),))
- 
-   ifeq ($(dwarf-post-unwind),1)
-     $(call feature_print_text,"DWARF post unwind library", $(dwarf-post-unwind-text))
-   endif
- 
-   ifneq ($(feature_verbose),1)
-     $(info )
-   endif
- endif
- 
- ifeq ($(feature_verbose),1)
-   TMP := $(filter-out $(FEATURE_DISPLAY),$(FEATURE_TESTS))
-   $(foreach feat,$(TMP),$(call feature_print_status,$(feat),))
-   $(info )
    $(call print_var,prefix)
    $(call print_var,bindir)
    $(call print_var,libdir)
* Unmerged path tools/perf/config/Makefile
diff --git a/tools/perf/config/Makefile.feature b/tools/perf/config/Makefile.feature
new file mode 100644
index 000000000000..8c98bbce6031
--- /dev/null
+++ b/tools/perf/config/Makefile.feature
@@ -0,0 +1,167 @@
+ifneq ($(OUTPUT),)
+  OUTPUT_FEATURES = $(OUTPUT)config/feature-checks/
+  $(shell mkdir -p $(OUTPUT_FEATURES))
+endif
+
+feature_check = $(eval $(feature_check_code))
+define feature_check_code
+  feature-$(1) := $(shell $(MAKE) OUTPUT=$(OUTPUT_FEATURES) CFLAGS="$(EXTRA_CFLAGS) $(FEATURE_CHECK_CFLAGS-$(1))" LDFLAGS="$(LDFLAGS) $(FEATURE_CHECK_LDFLAGS-$(1))" -C config/feature-checks test-$1.bin >/dev/null 2>/dev/null && echo 1 || echo 0)
+endef
+
+feature_set = $(eval $(feature_set_code))
+define feature_set_code
+  feature-$(1) := 1
+endef
+
+#
+# Build the feature check binaries in parallel, ignore errors, ignore return value and suppress output:
+#
+
+#
+# Note that this is not a complete list of all feature tests, just
+# those that are typically built on a fully configured system.
+#
+# [ Feature tests not mentioned here have to be built explicitly in
+#   the rule that uses them - an example for that is the 'bionic'
+#   feature check. ]
+#
+FEATURE_TESTS =			\
+	backtrace			\
+	dwarf				\
+	fortify-source			\
+	sync-compare-and-swap		\
+	glibc				\
+	gtk2				\
+	gtk2-infobar			\
+	libaudit			\
+	libbfd				\
+	libelf				\
+	libelf-getphdrnum		\
+	libelf-mmap			\
+	libnuma				\
+	libperl				\
+	libpython			\
+	libpython-version		\
+	libslang			\
+	libunwind			\
+	pthread-attr-setaffinity-np	\
+	stackprotector-all		\
+	timerfd				\
+	libdw-dwarf-unwind		\
+	zlib
+
+FEATURE_DISPLAY =			\
+	dwarf				\
+	glibc				\
+	gtk2				\
+	libaudit			\
+	libbfd				\
+	libelf				\
+	libnuma				\
+	libperl				\
+	libpython			\
+	libslang			\
+	libunwind			\
+	libdw-dwarf-unwind		\
+	zlib
+
+# Set FEATURE_CHECK_(C|LD)FLAGS-all for all FEATURE_TESTS features.
+# If in the future we need per-feature checks/flags for features not
+# mentioned in this list we need to refactor this ;-).
+set_test_all_flags = $(eval $(set_test_all_flags_code))
+define set_test_all_flags_code
+  FEATURE_CHECK_CFLAGS-all  += $(FEATURE_CHECK_CFLAGS-$(1))
+  FEATURE_CHECK_LDFLAGS-all += $(FEATURE_CHECK_LDFLAGS-$(1))
+endef
+
+$(foreach feat,$(FEATURE_TESTS),$(call set_test_all_flags,$(feat)))
+
+#
+# Special fast-path for the 'all features are available' case:
+#
+$(call feature_check,all,$(MSG))
+
+#
+# Just in case the build freshly failed, make sure we print the
+# feature matrix:
+#
+ifeq ($(feature-all), 1)
+  #
+  # test-all.c passed - just set all the core feature flags to 1:
+  #
+  $(foreach feat,$(FEATURE_TESTS),$(call feature_set,$(feat)))
+else
+  $(shell $(MAKE) OUTPUT=$(OUTPUT_FEATURES) CFLAGS="$(EXTRA_CFLAGS)" LDFLAGS=$(LDFLAGS) -i -j -C config/feature-checks $(addsuffix .bin,$(FEATURE_TESTS)) >/dev/null 2>&1)
+  $(foreach feat,$(FEATURE_TESTS),$(call feature_check,$(feat)))
+endif
+
+#
+# Print the result of the feature test:
+#
+feature_print_status = $(eval $(feature_print_status_code)) $(info $(MSG))
+
+define feature_print_status_code
+  ifeq ($(feature-$(1)), 1)
+    MSG = $(shell printf '...%30s: [ \033[32mon\033[m  ]' $(1))
+  else
+    MSG = $(shell printf '...%30s: [ \033[31mOFF\033[m ]' $(1))
+  endif
+endef
+
+feature_print_text = $(eval $(feature_print_text_code)) $(info $(MSG))
+define feature_print_text_code
+    MSG = $(shell printf '...%30s: %s' $(1) $(2))
+endef
+
+FEATURE_DUMP := $(foreach feat,$(FEATURE_DISPLAY),feature-$(feat)($(feature-$(feat))))
+FEATURE_DUMP_FILE := $(shell touch $(OUTPUT)FEATURE-DUMP; cat $(OUTPUT)FEATURE-DUMP)
+
+ifeq ($(dwarf-post-unwind),1)
+  FEATURE_DUMP += dwarf-post-unwind($(dwarf-post-unwind-text))
+endif
+
+# The $(feature_display) controls the default detection message
+# output. It's set if:
+# - detected features differes from stored features from
+#   last build (in FEATURE-DUMP file)
+# - one of the $(FEATURE_DISPLAY) is not detected
+# - VF is enabled
+
+ifneq ("$(FEATURE_DUMP)","$(FEATURE_DUMP_FILE)")
+  $(shell echo "$(FEATURE_DUMP)" > $(OUTPUT)FEATURE-DUMP)
+  feature_display := 1
+endif
+
+feature_display_check = $(eval $(feature_check_code))
+define feature_display_check_code
+  ifneq ($(feature-$(1)), 1)
+    feature_display := 1
+  endif
+endef
+
+$(foreach feat,$(FEATURE_DISPLAY),$(call feature_display_check,$(feat)))
+
+ifeq ($(VF),1)
+  feature_display := 1
+  feature_verbose := 1
+endif
+
+ifeq ($(feature_display),1)
+  $(info )
+  $(info Auto-detecting system features:)
+  $(foreach feat,$(FEATURE_DISPLAY),$(call feature_print_status,$(feat),))
+
+  ifeq ($(dwarf-post-unwind),1)
+    $(call feature_print_text,"DWARF post unwind library", $(dwarf-post-unwind-text))
+  endif
+
+  ifneq ($(feature_verbose),1)
+    $(info )
+  endif
+endif
+
+ifeq ($(feature_verbose),1)
+  TMP := $(filter-out $(FEATURE_DISPLAY),$(FEATURE_TESTS))
+  $(foreach feat,$(TMP),$(call feature_print_status,$(feat),))
+  $(info )
+endif
