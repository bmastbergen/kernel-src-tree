sfc: Add sysfs entry for flags (link control and primary)

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Shradha Shah <sshah@solarflare.com>
commit 0f5c0845882745bc5fde9dbbf553926435efe887
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/0f5c0845.failed

On  every adapter there will be one primary PF per adaptor and
one link control PF per port.

	Signed-off-by: Shradha Shah <sshah@solarflare.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0f5c0845882745bc5fde9dbbf553926435efe887)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/sfc/ef10.c
diff --cc drivers/net/ethernet/sfc/ef10.c
index 64db1d0e1c7a,e659da818c6c..000000000000
--- a/drivers/net/ethernet/sfc/ef10.c
+++ b/drivers/net/ethernet/sfc/ef10.c
@@@ -175,6 -218,62 +175,65 @@@ static int efx_ef10_get_mac_address(str
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int efx_ef10_get_mac_address_vf(struct efx_nic *efx, u8 *mac_address)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_GET_MAC_ADDRESSES_IN_LEN);
+ 	MCDI_DECLARE_BUF(outbuf, MC_CMD_VPORT_GET_MAC_ADDRESSES_OUT_LENMAX);
+ 	size_t outlen;
+ 	int num_addrs, rc;
+ 
+ 	MCDI_SET_DWORD(inbuf, VPORT_GET_MAC_ADDRESSES_IN_VPORT_ID,
+ 		       EVB_PORT_ID_ASSIGNED);
+ 	rc = efx_mcdi_rpc(efx, MC_CMD_VPORT_GET_MAC_ADDRESSES, inbuf,
+ 			  sizeof(inbuf), outbuf, sizeof(outbuf), &outlen);
+ 
+ 	if (rc)
+ 		return rc;
+ 	if (outlen < MC_CMD_VPORT_GET_MAC_ADDRESSES_OUT_LENMIN)
+ 		return -EIO;
+ 
+ 	num_addrs = MCDI_DWORD(outbuf,
+ 			       VPORT_GET_MAC_ADDRESSES_OUT_MACADDR_COUNT);
+ 
+ 	WARN_ON(num_addrs != 1);
+ 
+ 	ether_addr_copy(mac_address,
+ 			MCDI_PTR(outbuf, VPORT_GET_MAC_ADDRESSES_OUT_MACADDR));
+ 
+ 	return 0;
+ }
+ 
+ static ssize_t efx_ef10_show_link_control_flag(struct device *dev,
+ 					       struct device_attribute *attr,
+ 					       char *buf)
+ {
+ 	struct efx_nic *efx = pci_get_drvdata(to_pci_dev(dev));
+ 
+ 	return sprintf(buf, "%d\n",
+ 		       ((efx->mcdi->fn_flags) &
+ 			(1 << MC_CMD_DRV_ATTACH_EXT_OUT_FLAG_LINKCTRL))
+ 		       ? 1 : 0);
+ }
+ 
+ static ssize_t efx_ef10_show_primary_flag(struct device *dev,
+ 					  struct device_attribute *attr,
+ 					  char *buf)
+ {
+ 	struct efx_nic *efx = pci_get_drvdata(to_pci_dev(dev));
+ 
+ 	return sprintf(buf, "%d\n",
+ 		       ((efx->mcdi->fn_flags) &
+ 			(1 << MC_CMD_DRV_ATTACH_EXT_OUT_FLAG_PRIMARY))
+ 		       ? 1 : 0);
+ }
+ 
+ static DEVICE_ATTR(link_control_flag, 0444, efx_ef10_show_link_control_flag,
+ 		   NULL);
+ static DEVICE_ATTR(primary_flag, 0444, efx_ef10_show_primary_flag, NULL);
+ 
++>>>>>>> 0f5c08458827 (sfc: Add sysfs entry for flags (link control and primary))
  static int efx_ef10_probe(struct efx_nic *efx)
  {
  	struct efx_ef10_nic_data *nic_data;
@@@ -244,9 -343,22 +303,25 @@@
  	if (rc)
  		goto fail3;
  
++<<<<<<< HEAD
++=======
+ 	rc = device_create_file(&efx->pci_dev->dev,
+ 				&dev_attr_link_control_flag);
+ 	if (rc)
+ 		goto fail3;
+ 
+ 	rc = device_create_file(&efx->pci_dev->dev, &dev_attr_primary_flag);
+ 	if (rc)
+ 		goto fail4;
+ 
+ 	rc = efx_ef10_get_pf_index(efx);
+ 	if (rc)
+ 		goto fail5;
+ 
++>>>>>>> 0f5c08458827 (sfc: Add sysfs entry for flags (link control and primary))
  	rc = efx_ef10_init_datapath_caps(efx);
  	if (rc < 0)
- 		goto fail3;
+ 		goto fail5;
  
  	efx->rx_packet_len_offset =
  		ES_DZ_RX_PREFIX_PKTLEN_OFST - ES_DZ_RX_PREFIX_SIZE;
@@@ -257,9 -369,9 +332,9 @@@
  	efx->port_num = rc;
  	net_dev->dev_port = rc;
  
 -	rc = efx->type->get_mac_address(efx, efx->net_dev->perm_addr);
 +	rc = efx_ef10_get_mac_address(efx, efx->net_dev->perm_addr);
  	if (rc)
- 		goto fail3;
+ 		goto fail5;
  
  	rc = efx_ef10_get_sysclk_freq(efx);
  	if (rc < 0)
* Unmerged path drivers/net/ethernet/sfc/ef10.c
