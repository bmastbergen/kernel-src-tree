KVM: PPC: Book3S: Take the kvm->srcu lock in kvmppc_h_logical_ci_load/store()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [powerpc] kvm: Take the kvm->srcu lock in kvmppc_h_logical_ci_load/store() (Thomas Huth) [1263577]
Rebuild_FUZZ: 90.78%
commit-author Thomas Huth <thuth@redhat.com>
commit 3eb4ee68254235e4f47bc0410538fcdaede39589
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/3eb4ee68.failed

Access to the kvm->buses (like with the kvm_io_bus_read() and -write()
functions) has to be protected via the kvm->srcu lock.
The kvmppc_h_logical_ci_load() and -store() functions are missing
this lock so far, so let's add it there, too.
This fixes the problem that the kernel reports "suspicious RCU usage"
when lock debugging is enabled.

	Cc: stable@vger.kernel.org # v4.1+
Fixes: 99342cf8044420eebdf9297ca03a14cb6a7085a1
	Signed-off-by: Thomas Huth <thuth@redhat.com>
	Signed-off-by: Paul Mackerras <paulus@samba.org>
(cherry picked from commit 3eb4ee68254235e4f47bc0410538fcdaede39589)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kvm/book3s.c
diff --cc arch/powerpc/kvm/book3s.c
index 0813f1479c26,099c79d8c160..000000000000
--- a/arch/powerpc/kvm/book3s.c
+++ b/arch/powerpc/kvm/book3s.c
@@@ -960,6 -824,88 +960,91 @@@ void kvmppc_core_destroy_vm(struct kvm 
  #endif
  }
  
++<<<<<<< HEAD
++=======
+ int kvmppc_h_logical_ci_load(struct kvm_vcpu *vcpu)
+ {
+ 	unsigned long size = kvmppc_get_gpr(vcpu, 4);
+ 	unsigned long addr = kvmppc_get_gpr(vcpu, 5);
+ 	u64 buf;
+ 	int srcu_idx;
+ 	int ret;
+ 
+ 	if (!is_power_of_2(size) || (size > sizeof(buf)))
+ 		return H_TOO_HARD;
+ 
+ 	srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);
+ 	ret = kvm_io_bus_read(vcpu, KVM_MMIO_BUS, addr, size, &buf);
+ 	srcu_read_unlock(&vcpu->kvm->srcu, srcu_idx);
+ 	if (ret != 0)
+ 		return H_TOO_HARD;
+ 
+ 	switch (size) {
+ 	case 1:
+ 		kvmppc_set_gpr(vcpu, 4, *(u8 *)&buf);
+ 		break;
+ 
+ 	case 2:
+ 		kvmppc_set_gpr(vcpu, 4, be16_to_cpu(*(__be16 *)&buf));
+ 		break;
+ 
+ 	case 4:
+ 		kvmppc_set_gpr(vcpu, 4, be32_to_cpu(*(__be32 *)&buf));
+ 		break;
+ 
+ 	case 8:
+ 		kvmppc_set_gpr(vcpu, 4, be64_to_cpu(*(__be64 *)&buf));
+ 		break;
+ 
+ 	default:
+ 		BUG();
+ 	}
+ 
+ 	return H_SUCCESS;
+ }
+ EXPORT_SYMBOL_GPL(kvmppc_h_logical_ci_load);
+ 
+ int kvmppc_h_logical_ci_store(struct kvm_vcpu *vcpu)
+ {
+ 	unsigned long size = kvmppc_get_gpr(vcpu, 4);
+ 	unsigned long addr = kvmppc_get_gpr(vcpu, 5);
+ 	unsigned long val = kvmppc_get_gpr(vcpu, 6);
+ 	u64 buf;
+ 	int srcu_idx;
+ 	int ret;
+ 
+ 	switch (size) {
+ 	case 1:
+ 		*(u8 *)&buf = val;
+ 		break;
+ 
+ 	case 2:
+ 		*(__be16 *)&buf = cpu_to_be16(val);
+ 		break;
+ 
+ 	case 4:
+ 		*(__be32 *)&buf = cpu_to_be32(val);
+ 		break;
+ 
+ 	case 8:
+ 		*(__be64 *)&buf = cpu_to_be64(val);
+ 		break;
+ 
+ 	default:
+ 		return H_TOO_HARD;
+ 	}
+ 
+ 	srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);
+ 	ret = kvm_io_bus_write(vcpu, KVM_MMIO_BUS, addr, size, &buf);
+ 	srcu_read_unlock(&vcpu->kvm->srcu, srcu_idx);
+ 	if (ret != 0)
+ 		return H_TOO_HARD;
+ 
+ 	return H_SUCCESS;
+ }
+ EXPORT_SYMBOL_GPL(kvmppc_h_logical_ci_store);
+ 
++>>>>>>> 3eb4ee682542 (KVM: PPC: Book3S: Take the kvm->srcu lock in kvmppc_h_logical_ci_load/store())
  int kvmppc_core_check_processor_compat(void)
  {
  	/*
* Unmerged path arch/powerpc/kvm/book3s.c
