iw_cxgb4: 32b platform fixes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Hariprasad S <hariprasad@chelsio.com>
commit 6198dd8d7a6a7f40dc4599cb0676101d9cb82776
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/6198dd8d.failed

- get_dma_mr() was using ~0UL which is should be ~0ULL.  This causes the
DMA MR to get setup incorrectly in hardware.

- wr_log_show() needed a 64b divide function div64_u64() instead of
  doing
division directly.

- fixed warnings about recasting a pointer to a u64

	Signed-off-by: Steve Wise <swise@opengridcomputing.com>
	Signed-off-by: Hariprasad Shenai <hariprasad@chelsio.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 6198dd8d7a6a7f40dc4599cb0676101d9cb82776)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/cxgb4/cm.c
#	drivers/infiniband/hw/cxgb4/mem.c
#	drivers/infiniband/hw/cxgb4/qp.c
diff --cc drivers/infiniband/hw/cxgb4/cm.c
index dbfa05fcb4a7,6fb31bacd5b4..000000000000
--- a/drivers/infiniband/hw/cxgb4/cm.c
+++ b/drivers/infiniband/hw/cxgb4/cm.c
@@@ -3571,8 -3570,8 +3571,13 @@@ static void send_fw_pass_open_req(struc
  	 * TCB picks up the correct value. If this was 0
  	 * TP will ignore any value > 0 for MSS index.
  	 */
++<<<<<<< HEAD
 +	req->tcb.opt0 = cpu_to_be64(V_MSS_IDX(0xF));
 +	req->cookie = (unsigned long)skb;
++=======
+ 	req->tcb.opt0 = cpu_to_be64(MSS_IDX_V(0xF));
+ 	req->cookie = (uintptr_t)skb;
++>>>>>>> 6198dd8d7a6a (iw_cxgb4: 32b platform fixes)
  
  	set_wr_txq(req_skb, CPL_PRIORITY_CONTROL, port_id);
  	ret = cxgb4_ofld_send(dev->rdev.lldi.ports[0], req_skb);
diff --cc drivers/infiniband/hw/cxgb4/mem.c
index 797c01936a1d,cff815b91707..000000000000
--- a/drivers/infiniband/hw/cxgb4/mem.c
+++ b/drivers/infiniband/hw/cxgb4/mem.c
@@@ -135,16 -142,16 +135,22 @@@ static int _c4iw_write_mem_inline(struc
  		INIT_ULPTX_WR(req, wr_len, 0, 0);
  
  		if (i == (num_wqe-1)) {
++<<<<<<< HEAD
 +			req->wr.wr_hi = cpu_to_be32(FW_WR_OP(FW_ULPTX_WR) |
 +						    FW_WR_COMPL(1));
 +			req->wr.wr_lo = (__force __be64)(unsigned long) &wr_wait;
++=======
+ 			req->wr.wr_hi = cpu_to_be32(FW_WR_OP_V(FW_ULPTX_WR) |
+ 						    FW_WR_COMPL_F);
+ 			req->wr.wr_lo = (__force __be64)&wr_wait;
++>>>>>>> 6198dd8d7a6a (iw_cxgb4: 32b platform fixes)
  		} else
 -			req->wr.wr_hi = cpu_to_be32(FW_WR_OP_V(FW_ULPTX_WR));
 +			req->wr.wr_hi = cpu_to_be32(FW_WR_OP(FW_ULPTX_WR));
  		req->wr.wr_mid = cpu_to_be32(
 -				       FW_WR_LEN16_V(DIV_ROUND_UP(wr_len, 16)));
 +				       FW_WR_LEN16(DIV_ROUND_UP(wr_len, 16)));
  
  		req->cmd = cmd;
 -		req->dlen = cpu_to_be32(ULP_MEMIO_DATA_LEN_V(
 +		req->dlen = cpu_to_be32(ULP_MEMIO_DATA_LEN(
  				DIV_ROUND_UP(copy_len, T4_ULPTX_MIN_IO)));
  		req->len16 = cpu_to_be32(DIV_ROUND_UP(wr_len-sizeof(req->wr),
  						      16));
diff --cc drivers/infiniband/hw/cxgb4/qp.c
index 41cd6882b648,389ced335bc5..000000000000
--- a/drivers/infiniband/hw/cxgb4/qp.c
+++ b/drivers/infiniband/hw/cxgb4/qp.c
@@@ -271,11 -271,11 +271,11 @@@ static int create_qp(struct c4iw_rdev *
  	res_wr = (struct fw_ri_res_wr *)__skb_put(skb, wr_len);
  	memset(res_wr, 0, wr_len);
  	res_wr->op_nres = cpu_to_be32(
 -			FW_WR_OP_V(FW_RI_RES_WR) |
 -			FW_RI_RES_WR_NRES_V(2) |
 -			FW_WR_COMPL_F);
 +			FW_WR_OP(FW_RI_RES_WR) |
 +			V_FW_RI_RES_WR_NRES(2) |
 +			FW_WR_COMPL(1));
  	res_wr->len16_pkd = cpu_to_be32(DIV_ROUND_UP(wr_len, 16));
- 	res_wr->cookie = (unsigned long) &wr_wait;
+ 	res_wr->cookie = (uintptr_t)&wr_wait;
  	res = res_wr->res;
  	res->u.sqrq.restype = FW_RI_RES_TYPE_SQ;
  	res->u.sqrq.op = FW_RI_RES_OP_WRITE;
@@@ -1204,12 -1204,12 +1204,18 @@@ static int rdma_fini(struct c4iw_dev *r
  	wqe = (struct fw_ri_wr *)__skb_put(skb, sizeof(*wqe));
  	memset(wqe, 0, sizeof *wqe);
  	wqe->op_compl = cpu_to_be32(
 -		FW_WR_OP_V(FW_RI_INIT_WR) |
 -		FW_WR_COMPL_F);
 +		FW_WR_OP(FW_RI_INIT_WR) |
 +		FW_WR_COMPL(1));
  	wqe->flowid_len16 = cpu_to_be32(
++<<<<<<< HEAD
 +		FW_WR_FLOWID(ep->hwtid) |
 +		FW_WR_LEN16(DIV_ROUND_UP(sizeof *wqe, 16)));
 +	wqe->cookie = (unsigned long) &ep->com.wr_wait;
++=======
+ 		FW_WR_FLOWID_V(ep->hwtid) |
+ 		FW_WR_LEN16_V(DIV_ROUND_UP(sizeof(*wqe), 16)));
+ 	wqe->cookie = (uintptr_t)&ep->com.wr_wait;
++>>>>>>> 6198dd8d7a6a (iw_cxgb4: 32b platform fixes)
  
  	wqe->u.fini.type = FW_RI_TYPE_FINI;
  	ret = c4iw_ofld_send(&rhp->rdev, skb);
@@@ -1273,13 -1273,13 +1279,13 @@@ static int rdma_init(struct c4iw_dev *r
  	wqe = (struct fw_ri_wr *)__skb_put(skb, sizeof(*wqe));
  	memset(wqe, 0, sizeof *wqe);
  	wqe->op_compl = cpu_to_be32(
 -		FW_WR_OP_V(FW_RI_INIT_WR) |
 -		FW_WR_COMPL_F);
 +		FW_WR_OP(FW_RI_INIT_WR) |
 +		FW_WR_COMPL(1));
  	wqe->flowid_len16 = cpu_to_be32(
 -		FW_WR_FLOWID_V(qhp->ep->hwtid) |
 -		FW_WR_LEN16_V(DIV_ROUND_UP(sizeof(*wqe), 16)));
 +		FW_WR_FLOWID(qhp->ep->hwtid) |
 +		FW_WR_LEN16(DIV_ROUND_UP(sizeof *wqe, 16)));
  
- 	wqe->cookie = (unsigned long) &qhp->ep->com.wr_wait;
+ 	wqe->cookie = (uintptr_t)&qhp->ep->com.wr_wait;
  
  	wqe->u.init.type = FW_RI_TYPE_INIT;
  	wqe->u.init.mpareqbit_p2ptype =
* Unmerged path drivers/infiniband/hw/cxgb4/cm.c
diff --git a/drivers/infiniband/hw/cxgb4/cq.c b/drivers/infiniband/hw/cxgb4/cq.c
index 0f773e78e080..c9f349c16b05 100644
--- a/drivers/infiniband/hw/cxgb4/cq.c
+++ b/drivers/infiniband/hw/cxgb4/cq.c
@@ -55,7 +55,7 @@ static int destroy_cq(struct c4iw_rdev *rdev, struct t4_cq *cq,
 			V_FW_RI_RES_WR_NRES(1) |
 			FW_WR_COMPL(1));
 	res_wr->len16_pkd = cpu_to_be32(DIV_ROUND_UP(wr_len, 16));
-	res_wr->cookie = (unsigned long) &wr_wait;
+	res_wr->cookie = (uintptr_t)&wr_wait;
 	res = res_wr->res;
 	res->u.cq.restype = FW_RI_RES_TYPE_CQ;
 	res->u.cq.op = FW_RI_RES_OP_RESET;
@@ -125,7 +125,7 @@ static int create_cq(struct c4iw_rdev *rdev, struct t4_cq *cq,
 			V_FW_RI_RES_WR_NRES(1) |
 			FW_WR_COMPL(1));
 	res_wr->len16_pkd = cpu_to_be32(DIV_ROUND_UP(wr_len, 16));
-	res_wr->cookie = (unsigned long) &wr_wait;
+	res_wr->cookie = (uintptr_t)&wr_wait;
 	res = res_wr->res;
 	res->u.cq.restype = FW_RI_RES_TYPE_CQ;
 	res->u.cq.op = FW_RI_RES_OP_WRITE;
@@ -970,8 +970,7 @@ struct ib_cq *c4iw_create_cq(struct ib_device *ibdev, int entries,
 	}
 	PDBG("%s cqid 0x%0x chp %p size %u memsize %zu, dma_addr 0x%0llx\n",
 	     __func__, chp->cq.cqid, chp, chp->cq.size,
-	     chp->cq.memsize,
-	     (unsigned long long) chp->cq.dma_addr);
+	     chp->cq.memsize, (unsigned long long) chp->cq.dma_addr);
 	return &chp->ibcq;
 err5:
 	kfree(mm2);
diff --git a/drivers/infiniband/hw/cxgb4/device.c b/drivers/infiniband/hw/cxgb4/device.c
index 7a1840903e2c..5739f2babfbf 100644
--- a/drivers/infiniband/hw/cxgb4/device.c
+++ b/drivers/infiniband/hw/cxgb4/device.c
@@ -151,7 +151,7 @@ static int wr_log_show(struct seq_file *seq, void *v)
 	int prev_ts_set = 0;
 	int idx, end;
 
-#define ts2ns(ts) div64_ul((ts) * dev->rdev.lldi.cclk_ps, 1000)
+#define ts2ns(ts) div64_u64((ts) * dev->rdev.lldi.cclk_ps, 1000)
 
 	idx = atomic_read(&dev->rdev.wr_log_idx) &
 		(dev->rdev.wr_log_size - 1);
@@ -827,10 +827,10 @@ static int c4iw_rdev_open(struct c4iw_rdev *rdev)
 	     rdev->lldi.vr->qp.size,
 	     rdev->lldi.vr->cq.start,
 	     rdev->lldi.vr->cq.size);
-	PDBG("udb len 0x%x udb base %llx db_reg %p gts_reg %p qpshift %lu "
+	PDBG("udb len 0x%x udb base %p db_reg %p gts_reg %p qpshift %lu "
 	     "qpmask 0x%x cqshift %lu cqmask 0x%x\n",
 	     (unsigned)pci_resource_len(rdev->lldi.pdev, 2),
-	     (u64)pci_resource_start(rdev->lldi.pdev, 2),
+	     (void *)pci_resource_start(rdev->lldi.pdev, 2),
 	     rdev->lldi.db_reg,
 	     rdev->lldi.gts_reg,
 	     rdev->qpshift, rdev->qpmask,
* Unmerged path drivers/infiniband/hw/cxgb4/mem.c
* Unmerged path drivers/infiniband/hw/cxgb4/qp.c
