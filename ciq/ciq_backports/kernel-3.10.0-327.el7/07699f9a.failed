bonding: add sysfs /slave dir for bond slave devices.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] bonding: add sysfs /slave dir for bond slave devices (Nikolay Aleksandrov) [1166647]
Rebuild_FUZZ: 99.05%
commit-author sfeldma@cumulusnetworks.com <sfeldma@cumulusnetworks.com>
commit 07699f9a7c8d1002e07011d5aa382cd63241eea8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/07699f9a.failed

Add sub-directory under /sys/class/net/<interface>/slave with
read-only attributes for slave.  Directory only appears when
<interface> is a slave.

$ tree /sys/class/net/eth2/slave/
/sys/class/net/eth2/slave/
├── ad_aggregator_id
├── link_failure_count
├── mii_status
├── perm_hwaddr
├── queue_id
└── state

$ cat /sys/class/net/eth2/slave/*
2
0
up
40:02:10:ef:06:01
0
active

	Signed-off-by: Scott Feldman <sfeldma@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 07699f9a7c8d1002e07011d5aa382cd63241eea8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/Makefile
#	drivers/net/bonding/bond_main.c
#	drivers/net/bonding/bonding.h
diff --cc drivers/net/bonding/Makefile
index 09e8b2c83afe,6f4e80853ed4..000000000000
--- a/drivers/net/bonding/Makefile
+++ b/drivers/net/bonding/Makefile
@@@ -4,7 -4,7 +4,11 @@@
  
  obj-$(CONFIG_BONDING) += bonding.o
  
++<<<<<<< HEAD
 +bonding-objs := bond_main.o bond_3ad.o bond_alb.o bond_sysfs.o bond_debugfs.o bond_netlink.o
++=======
+ bonding-objs := bond_main.o bond_3ad.o bond_alb.o bond_sysfs.o bond_sysfs_slave.o bond_debugfs.o bond_netlink.o bond_options.o
++>>>>>>> 07699f9a7c8d (bonding: add sysfs /slave dir for bond slave devices.)
  
  proc-$(CONFIG_PROC_FS) += bond_procfs.o
  bonding-objs += $(proc-y)
diff --cc drivers/net/bonding/bond_main.c
index 38a1c7877edd,df85cec3e5d9..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -1839,6 -1592,21 +1855,24 @@@ int bond_enslave(struct net_device *bon
  		goto err_unregister;
  	}
  
++<<<<<<< HEAD
++=======
+ 	res = bond_sysfs_slave_add(new_slave);
+ 	if (res) {
+ 		pr_debug("Error %d calling bond_sysfs_slave_add\n", res);
+ 		goto err_upper_unlink;
+ 	}
+ 
+ 	bond->slave_cnt++;
+ 	bond_compute_features(bond);
+ 	bond_set_carrier(bond);
+ 
+ 	if (USES_PRIMARY(bond->params.mode)) {
+ 		write_lock_bh(&bond->curr_slave_lock);
+ 		bond_select_active_slave(bond);
+ 		write_unlock_bh(&bond->curr_slave_lock);
+ 	}
++>>>>>>> 07699f9a7c8d (bonding: add sysfs /slave dir for bond slave devices.)
  
  	pr_info("%s: enslaving %s as a%s interface with a%s link.\n",
  		bond_dev->name, slave_dev->name,
@@@ -1953,8 -1709,11 +1990,10 @@@ static int __bond_release_one(struct ne
  		return -EINVAL;
  	}
  
 -	/* release the slave from its bond */
 -	bond->slave_cnt--;
 +	write_unlock_bh(&bond->lock);
  
+ 	bond_sysfs_slave_del(slave);
+ 
  	bond_upper_dev_unlink(bond_dev, slave_dev);
  	/* unregister rx_handler early so bond_handle_frame wouldn't be called
  	 * for this slave anymore.
diff --cc drivers/net/bonding/bonding.h
index 6097f0c04b95,309757d8482b..000000000000
--- a/drivers/net/bonding/bonding.h
+++ b/drivers/net/bonding/bonding.h
@@@ -421,15 -422,13 +422,20 @@@ int bond_create(struct net *net, const 
  int bond_create_sysfs(struct bond_net *net);
  void bond_destroy_sysfs(struct bond_net *net);
  void bond_prepare_sysfs_group(struct bonding *bond);
++<<<<<<< HEAD
 +int bond_create_slave_symlinks(struct net_device *master, struct net_device *slave);
 +void bond_destroy_slave_symlinks(struct net_device *master, struct net_device *slave);
++=======
+ int bond_sysfs_slave_add(struct slave *slave);
+ void bond_sysfs_slave_del(struct slave *slave);
++>>>>>>> 07699f9a7c8d (bonding: add sysfs /slave dir for bond slave devices.)
  int bond_enslave(struct net_device *bond_dev, struct net_device *slave_dev);
  int bond_release(struct net_device *bond_dev, struct net_device *slave_dev);
 -int bond_xmit_hash(struct bonding *bond, struct sk_buff *skb, int count);
 +void bond_mii_monitor(struct work_struct *);
 +void bond_loadbalance_arp_mon(struct work_struct *);
 +void bond_activebackup_arp_mon(struct work_struct *);
 +void bond_set_mode_ops(struct bonding *bond, int mode);
  int bond_parse_parm(const char *mode_arg, const struct bond_parm_tbl *tbl);
 -int bond_parm_tbl_lookup(int mode, const struct bond_parm_tbl *tbl);
  void bond_select_active_slave(struct bonding *bond);
  void bond_change_active_slave(struct bonding *bond, struct slave *new_active);
  void bond_create_debugfs(void);
@@@ -442,6 -441,38 +448,41 @@@ void bond_setup(struct net_device *bond
  unsigned int bond_get_num_tx_queues(void);
  int bond_netlink_init(void);
  void bond_netlink_fini(void);
++<<<<<<< HEAD
++=======
+ int bond_option_mode_set(struct bonding *bond, int mode);
+ int bond_option_active_slave_set(struct bonding *bond, struct net_device *slave_dev);
+ int bond_option_miimon_set(struct bonding *bond, int miimon);
+ int bond_option_updelay_set(struct bonding *bond, int updelay);
+ int bond_option_downdelay_set(struct bonding *bond, int downdelay);
+ int bond_option_use_carrier_set(struct bonding *bond, int use_carrier);
+ int bond_option_arp_interval_set(struct bonding *bond, int arp_interval);
+ int bond_option_arp_ip_targets_set(struct bonding *bond, __be32 *targets,
+ 				   int count);
+ int bond_option_arp_ip_target_add(struct bonding *bond, __be32 target);
+ int bond_option_arp_ip_target_rem(struct bonding *bond, __be32 target);
+ int bond_option_arp_validate_set(struct bonding *bond, int arp_validate);
+ int bond_option_arp_all_targets_set(struct bonding *bond, int arp_all_targets);
+ int bond_option_primary_set(struct bonding *bond, const char *primary);
+ int bond_option_primary_reselect_set(struct bonding *bond,
+ 				     int primary_reselect);
+ int bond_option_fail_over_mac_set(struct bonding *bond, int fail_over_mac);
+ int bond_option_xmit_hash_policy_set(struct bonding *bond,
+ 				     int xmit_hash_policy);
+ int bond_option_resend_igmp_set(struct bonding *bond, int resend_igmp);
+ int bond_option_num_peer_notif_set(struct bonding *bond, int num_peer_notif);
+ int bond_option_all_slaves_active_set(struct bonding *bond,
+ 				      int all_slaves_active);
+ int bond_option_min_links_set(struct bonding *bond, int min_links);
+ int bond_option_lp_interval_set(struct bonding *bond, int min_links);
+ int bond_option_packets_per_slave_set(struct bonding *bond,
+ 				      int packets_per_slave);
+ int bond_option_lacp_rate_set(struct bonding *bond, int lacp_rate);
+ int bond_option_ad_select_set(struct bonding *bond, int ad_select);
+ struct net_device *bond_option_active_slave_get_rcu(struct bonding *bond);
+ struct net_device *bond_option_active_slave_get(struct bonding *bond);
+ const char *bond_slave_link_status(s8 link);
++>>>>>>> 07699f9a7c8d (bonding: add sysfs /slave dir for bond slave devices.)
  
  struct bond_net {
  	struct net *		net;	/* Associated network namespace */
* Unmerged path drivers/net/bonding/Makefile
* Unmerged path drivers/net/bonding/bond_main.c
diff --git a/drivers/net/bonding/bond_procfs.c b/drivers/net/bonding/bond_procfs.c
index 4060d41f0ee7..0383f12e6c90 100644
--- a/drivers/net/bonding/bond_procfs.c
+++ b/drivers/net/bonding/bond_procfs.c
@@ -150,18 +150,6 @@ static void bond_info_show_master(struct seq_file *seq)
 	}
 }
 
-static const char *bond_slave_link_status(s8 link)
-{
-	static const char * const status[] = {
-		[BOND_LINK_UP] = "up",
-		[BOND_LINK_FAIL] = "going down",
-		[BOND_LINK_DOWN] = "down",
-		[BOND_LINK_BACK] = "going back",
-	};
-
-	return status[link];
-}
-
 static void bond_info_show_slave(struct seq_file *seq,
 				 const struct slave *slave)
 {
diff --git a/drivers/net/bonding/bond_sysfs_slave.c b/drivers/net/bonding/bond_sysfs_slave.c
new file mode 100644
index 000000000000..7cb97de3cf63
--- /dev/null
+++ b/drivers/net/bonding/bond_sysfs_slave.c
@@ -0,0 +1,144 @@
+/*	Sysfs attributes of bond slaves
+ *
+ *      Copyright (c) 2014 Scott Feldman <sfeldma@cumulusnetworks.com>
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/capability.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+
+#include "bonding.h"
+
+struct slave_attribute {
+	struct attribute attr;
+	ssize_t (*show)(struct slave *, char *);
+};
+
+#define SLAVE_ATTR(_name, _mode, _show)				\
+const struct slave_attribute slave_attr_##_name = {		\
+	.attr = {.name = __stringify(_name),			\
+		 .mode = _mode },				\
+	.show	= _show,					\
+};
+#define SLAVE_ATTR_RO(_name) \
+	SLAVE_ATTR(_name, S_IRUGO, _name##_show)
+
+static ssize_t state_show(struct slave *slave, char *buf)
+{
+	switch (bond_slave_state(slave)) {
+	case BOND_STATE_ACTIVE:
+		return sprintf(buf, "active\n");
+	case BOND_STATE_BACKUP:
+		return sprintf(buf, "backup\n");
+	default:
+		return sprintf(buf, "UNKONWN\n");
+	}
+}
+static SLAVE_ATTR_RO(state);
+
+static ssize_t mii_status_show(struct slave *slave, char *buf)
+{
+	return sprintf(buf, "%s\n", bond_slave_link_status(slave->link));
+}
+static SLAVE_ATTR_RO(mii_status);
+
+static ssize_t link_failure_count_show(struct slave *slave, char *buf)
+{
+	return sprintf(buf, "%d\n", slave->link_failure_count);
+}
+static SLAVE_ATTR_RO(link_failure_count);
+
+static ssize_t perm_hwaddr_show(struct slave *slave, char *buf)
+{
+	return sprintf(buf, "%pM\n", slave->perm_hwaddr);
+}
+static SLAVE_ATTR_RO(perm_hwaddr);
+
+static ssize_t queue_id_show(struct slave *slave, char *buf)
+{
+	return sprintf(buf, "%d\n", slave->queue_id);
+}
+static SLAVE_ATTR_RO(queue_id);
+
+static ssize_t ad_aggregator_id_show(struct slave *slave, char *buf)
+{
+	const struct aggregator *agg;
+
+	if (slave->bond->params.mode == BOND_MODE_8023AD) {
+		agg = SLAVE_AD_INFO(slave).port.aggregator;
+		if (agg)
+			return sprintf(buf, "%d\n",
+				       agg->aggregator_identifier);
+	}
+
+	return sprintf(buf, "N/A\n");
+}
+static SLAVE_ATTR_RO(ad_aggregator_id);
+
+static const struct slave_attribute *slave_attrs[] = {
+	&slave_attr_state,
+	&slave_attr_mii_status,
+	&slave_attr_link_failure_count,
+	&slave_attr_perm_hwaddr,
+	&slave_attr_queue_id,
+	&slave_attr_ad_aggregator_id,
+	NULL
+};
+
+#define to_slave_attr(_at) container_of(_at, struct slave_attribute, attr)
+#define to_slave(obj)	container_of(obj, struct slave, kobj)
+
+static ssize_t slave_show(struct kobject *kobj,
+			  struct attribute *attr, char *buf)
+{
+	struct slave_attribute *slave_attr = to_slave_attr(attr);
+	struct slave *slave = to_slave(kobj);
+
+	return slave_attr->show(slave, buf);
+}
+
+const struct sysfs_ops slave_sysfs_ops = {
+	.show = slave_show,
+};
+
+static struct kobj_type slave_ktype = {
+#ifdef CONFIG_SYSFS
+	.sysfs_ops = &slave_sysfs_ops,
+#endif
+};
+
+int bond_sysfs_slave_add(struct slave *slave)
+{
+	const struct slave_attribute **a;
+	int err;
+
+	err = kobject_init_and_add(&slave->kobj, &slave_ktype,
+				   &(slave->dev->dev.kobj), "slave");
+	if (err)
+		return err;
+
+	for (a = slave_attrs; *a; ++a) {
+		err = sysfs_create_file(&slave->kobj, &((*a)->attr));
+		if (err) {
+			kobject_del(&slave->kobj);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+void bond_sysfs_slave_del(struct slave *slave)
+{
+	const struct slave_attribute **a;
+
+	for (a = slave_attrs; *a; ++a)
+		sysfs_remove_file(&slave->kobj, &((*a)->attr));
+
+	kobject_del(&slave->kobj);
+}
* Unmerged path drivers/net/bonding/bonding.h
