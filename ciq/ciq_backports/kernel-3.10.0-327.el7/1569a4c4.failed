ACPI / TPM: detect PPI features by checking availability of _DSM functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [char] tpm: detect PPI features by checking availability of _DSM functions (Jarod Wilson) [1182709]
Rebuild_FUZZ: 95.04%
commit-author Jiang Liu <jiang.liu@linux.intel.com>
commit 1569a4c4cebaf358eff12633830baeaf6507fed0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/1569a4c4.failed

Detecting physical presence interface features by checking availbility
of corresponding ACPI _DSM functions, it should be more accurate than
checking TPM version number.

	Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 1569a4c4cebaf358eff12633830baeaf6507fed0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/tpm/tpm_ppi.c
diff --cc drivers/char/tpm/tpm_ppi.c
index 1e9cc11ac76a,117fab6daf39..000000000000
--- a/drivers/char/tpm/tpm_ppi.c
+++ b/drivers/char/tpm/tpm_ppi.c
@@@ -24,36 -15,47 +24,66 @@@ static char *tpm_device_name = "TPM"
  #define PPI_VS_REQ_END		255
  #define PPI_VERSION_LEN		3
  
++<<<<<<< HEAD
++=======
+ static const u8 tpm_ppi_uuid[] = {
+ 	0xA6, 0xFA, 0xDD, 0x3D,
+ 	0x1B, 0x36,
+ 	0xB4, 0x4E,
+ 	0xA4, 0x24,
+ 	0x8D, 0x10, 0x08, 0x9D, 0x16, 0x53
+ };
+ 
+ static char tpm_ppi_version[PPI_VERSION_LEN + 1];
+ static acpi_handle tpm_ppi_handle;
+ 
++>>>>>>> 1569a4c4ceba (ACPI / TPM: detect PPI features by checking availability of _DSM functions)
  static acpi_status ppi_callback(acpi_handle handle, u32 level, void *context,
  				void **return_value)
  {
- 	acpi_status status = AE_OK;
- 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+ 	union acpi_object *obj;
  
++<<<<<<< HEAD
 +	if (ACPI_SUCCESS(acpi_get_name(handle, ACPI_SINGLE_NAME, &buffer))) {
 +		if (strstr(buffer.pointer, context) != NULL) {
 +			*return_value = handle;
 +			status = AE_CTRL_TERMINATE;
 +		}
 +		kfree(buffer.pointer);
++=======
+ 	if (!acpi_check_dsm(handle, tpm_ppi_uuid, TPM_PPI_REVISION_ID,
+ 			    1 << TPM_PPI_FN_VERSION))
+ 		return AE_OK;
+ 
+ 	/* Cache version string */
+ 	obj = acpi_evaluate_dsm_typed(handle, tpm_ppi_uuid,
+ 				      TPM_PPI_REVISION_ID, TPM_PPI_FN_VERSION,
+ 				      NULL, ACPI_TYPE_STRING);
+ 	if (obj) {
+ 		strlcpy(tpm_ppi_version, obj->string.pointer,
+ 			PPI_VERSION_LEN + 1);
+ 		ACPI_FREE(obj);
++>>>>>>> 1569a4c4ceba (ACPI / TPM: detect PPI features by checking availability of _DSM functions)
  	}
  
- 	return status;
+ 	*return_value = handle;
+ 
+ 	return AE_CTRL_TERMINATE;
  }
  
 -static inline union acpi_object *
 -tpm_eval_dsm(int func, acpi_object_type type, union acpi_object *argv4)
 +static inline void ppi_assign_params(union acpi_object params[4],
 +				     u64 function_num)
  {
 -	BUG_ON(!tpm_ppi_handle);
 -	return acpi_evaluate_dsm_typed(tpm_ppi_handle, tpm_ppi_uuid,
 -				       TPM_PPI_REVISION_ID, func, argv4, type);
 +	params[0].type = ACPI_TYPE_BUFFER;
 +	params[0].buffer.length = sizeof(tpm_ppi_uuid);
 +	params[0].buffer.pointer = (char *)tpm_ppi_uuid;
 +	params[1].type = ACPI_TYPE_INTEGER;
 +	params[1].integer.value = TPM_PPI_REVISION_ID;
 +	params[2].type = ACPI_TYPE_INTEGER;
 +	params[2].integer.value = function_num;
 +	params[3].type = ACPI_TYPE_PACKAGE;
 +	params[3].package.count = 0;
 +	params[3].package.elements = NULL;
  }
  
  static ssize_t tpm_show_ppi_version(struct device *dev,
@@@ -172,10 -110,10 +202,17 @@@ static ssize_t tpm_store_ppi_request(st
  	 * is updated with function index from SUBREQ to SUBREQ2 since PPI
  	 * version 1.1
  	 */
++<<<<<<< HEAD
 +	if (strcmp(version, "1.1") == -1)
 +		params[2].integer.value = TPM_PPI_FN_SUBREQ;
 +	else
 +		params[2].integer.value = TPM_PPI_FN_SUBREQ2;
++=======
+ 	if (acpi_check_dsm(tpm_ppi_handle, tpm_ppi_uuid, TPM_PPI_REVISION_ID,
+ 			   1 << TPM_PPI_FN_SUBREQ2))
+ 		func = TPM_PPI_FN_SUBREQ2;
+ 
++>>>>>>> 1569a4c4ceba (ACPI / TPM: detect PPI features by checking availability of _DSM functions)
  	/*
  	 * PPI spec defines params[3].type as ACPI_TYPE_PACKAGE. Some BIOS
  	 * accept buffer/string/integer type, but some BIOS accept buffer/
@@@ -370,41 -264,22 +407,46 @@@ static ssize_t show_ppi_operations(cha
  		"User required",
  		"User not required",
  	};
 +	input.count = 4;
 +	ppi_assign_params(params, TPM_PPI_FN_VERSION);
 +	input.pointer = params;
 +	status = acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
 +				     ACPI_UINT32_MAX, ppi_callback, NULL,
 +				     tpm_device_name, &handle);
 +	if (ACPI_FAILURE(status))
 +		return -ENXIO;
  
++<<<<<<< HEAD
 +	status = acpi_evaluate_object_typed(handle, "_DSM", &input, &output,
 +					 ACPI_TYPE_STRING);
 +	if (ACPI_FAILURE(status))
 +		return -ENOMEM;
 +
 +	strlcpy(version,
 +		((union acpi_object *)output.pointer)->string.pointer,
 +		PPI_VERSION_LEN + 1);
 +	kfree(output.pointer);
 +	output.length = ACPI_ALLOCATE_BUFFER;
 +	output.pointer = NULL;
 +	if (strcmp(version, "1.2") == -1)
++=======
+ 	if (!acpi_check_dsm(tpm_ppi_handle, tpm_ppi_uuid, TPM_PPI_REVISION_ID,
+ 			    1 << TPM_PPI_FN_GETOPR))
++>>>>>>> 1569a4c4ceba (ACPI / TPM: detect PPI features by checking availability of _DSM functions)
  		return -EPERM;
  
 -	tmp.integer.type = ACPI_TYPE_INTEGER;
 +	params[2].integer.value = TPM_PPI_FN_GETOPR;
 +	params[3].package.count = 1;
 +	obj.type = ACPI_TYPE_INTEGER;
 +	params[3].package.elements = &obj;
  	for (i = start; i <= end; i++) {
 -		tmp.integer.value = i;
 -		obj = tpm_eval_dsm(TPM_PPI_FN_GETOPR, ACPI_TYPE_INTEGER, &argv);
 -		if (!obj) {
 +		obj.integer.value = i;
 +		status = acpi_evaluate_object_typed(handle, "_DSM",
 +			 &input, &output, ACPI_TYPE_INTEGER);
 +		if (ACPI_FAILURE(status))
  			return -ENOMEM;
 -		} else {
 -			ret = obj->integer.value;
 -			ACPI_FREE(obj);
 -		}
  
 +		ret = ((union acpi_object *)output.pointer)->integer.value;
  		if (ret > 0 && ret < ARRAY_SIZE(info))
  			str += scnprintf(str, PAGE_SIZE, "%d %d: %s\n",
  					 i, ret, info[ret]);
@@@ -453,6 -326,12 +495,15 @@@ static struct attribute_group ppi_attr_
  
  int tpm_add_ppi(struct kobject *parent)
  {
++<<<<<<< HEAD
++=======
+ 	/* Cache TPM ACPI handle and version string */
+ 	acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
+ 			    ppi_callback, NULL, NULL, &tpm_ppi_handle);
+ 	if (tpm_ppi_handle == NULL)
+ 		return -ENODEV;
+ 
++>>>>>>> 1569a4c4ceba (ACPI / TPM: detect PPI features by checking availability of _DSM functions)
  	return sysfs_create_group(parent, &ppi_attr_grp);
  }
  
* Unmerged path drivers/char/tpm/tpm_ppi.c
