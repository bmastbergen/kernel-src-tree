ext4: fix partial cluster initialization

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Eric Whitney <enwlinux@gmail.com>
commit f4226d9ea400e7124120571b1e89504c79f2e953
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/f4226d9e.failed

The partial_cluster variable is not always initialized correctly when
hole punching on bigalloc file systems.  Although commit c06344939422
("ext4: fix partial cluster handling for bigalloc file systems")
addressed the case where the right edge of the punched region and the
next extent to its right were within the same leaf, it didn't handle
the case where the next extent to its right is in the next leaf.  This
causes xfstest generic/300 to fail.

Fix this by replacing the code in c0634493922 with a more general
solution that can continue the search for the first cluster to the
right of the punched region into the next leaf if present.  If found,
partial_cluster is initialized to this cluster's negative value.
There's no need to determine if that cluster is actually shared;  we
simply record it so its blocks won't be freed in the event it does
happen to be shared.

Also, minimize the burden on non-bigalloc file systems with some minor
code simplification.

	Signed-off-by: Eric Whitney <enwlinux@gmail.com>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
(cherry picked from commit f4226d9ea400e7124120571b1e89504c79f2e953)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/extents.c
diff --cc fs/ext4/extents.c
index 80760fd2bdf3,57794a7a435c..000000000000
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@@ -2821,10 -2826,11 +2802,16 @@@ again
  	 */
  	if (end < EXT_MAX_BLOCKS - 1) {
  		struct ext4_extent *ex;
- 		ext4_lblk_t ee_block;
+ 		ext4_lblk_t ee_block, ex_end, lblk;
+ 		ext4_fsblk_t pblk;
  
++<<<<<<< HEAD
 +		/* find extent for this block */
 +		path = ext4_ext_find_extent(inode, end, NULL, EXT4_EX_NOCACHE);
++=======
+ 		/* find extent for or closest extent to this block */
+ 		path = ext4_find_extent(inode, end, NULL, EXT4_EX_NOCACHE);
++>>>>>>> f4226d9ea400 (ext4: fix partial cluster initialization)
  		if (IS_ERR(path)) {
  			ext4_journal_stop(handle);
  			return PTR_ERR(path);
@@@ -2850,13 -2857,18 +2838,28 @@@
  		 * tail of the first part of the split extent in
  		 * ext4_ext_rm_leaf().
  		 */
++<<<<<<< HEAD
 +		if (end >= ee_block &&
 +		    end < ee_block + ext4_ext_get_actual_len(ex) - 1) {
 +			int split_flag = 0;
 +
 +			if (ext4_ext_is_unwritten(ex))
 +				split_flag = EXT4_EXT_MARK_UNWRIT1 |
 +					     EXT4_EXT_MARK_UNWRIT2;
++=======
+ 		if (end >= ee_block && end < ex_end) {
+ 
+ 			/*
+ 			 * If we're going to split the extent, note that
+ 			 * the cluster containing the block after 'end' is
+ 			 * in use to avoid freeing it when removing blocks.
+ 			 */
+ 			if (sbi->s_cluster_ratio > 1) {
+ 				pblk = ext4_ext_pblock(ex) + end - ee_block + 2;
+ 				partial_cluster =
+ 					-(long long) EXT4_B2C(sbi, pblk);
+ 			}
++>>>>>>> f4226d9ea400 (ext4: fix partial cluster initialization)
  
  			/*
  			 * Split the extent in two so that 'end' is the last
@@@ -2864,14 -2876,28 +2867,32 @@@
  			 * fail removing space due to ENOSPC so try to use
  			 * reserved block if that happens.
  			 */
 -			err = ext4_force_split_extent_at(handle, inode, &path,
 -							 end + 1, 1);
 +			err = ext4_split_extent_at(handle, inode, path,
 +					end + 1, split_flag,
 +					EXT4_EX_NOCACHE |
 +					EXT4_GET_BLOCKS_PRE_IO |
 +					EXT4_GET_BLOCKS_METADATA_NOFAIL);
 +
  			if (err < 0)
  				goto out;
+ 
+ 		} else if (sbi->s_cluster_ratio > 1 && end >= ex_end) {
+ 			/*
+ 			 * If there's an extent to the right its first cluster
+ 			 * contains the immediate right boundary of the
+ 			 * truncated/punched region.  Set partial_cluster to
+ 			 * its negative value so it won't be freed if shared
+ 			 * with the current extent.  The end < ee_block case
+ 			 * is handled in ext4_ext_rm_leaf().
+ 			 */
+ 			lblk = ex_end + 1;
+ 			err = ext4_ext_search_right(inode, path, &lblk, &pblk,
+ 						    &ex);
+ 			if (err)
+ 				goto out;
+ 			if (pblk)
+ 				partial_cluster =
+ 					-(long long) EXT4_B2C(sbi, pblk);
  		}
  	}
  	/*
* Unmerged path fs/ext4/extents.c
