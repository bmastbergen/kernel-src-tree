i40e/i40evf: add get AQ result command to nvmupdate utility

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Shannon Nelson <shannon.nelson@intel.com>
commit b72dc7b19398b238698fbc5954a3c3de6cbc815d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/b72dc7b1.failed

Add a facility to recover the result of a previously run AQ command.

Change-ID: I21afec2c20c1a5e6ba60c7fbfcbedfff78c10e45
	Signed-off-by: Shannon Nelson <shannon.nelson@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit b72dc7b19398b238698fbc5954a3c3de6cbc815d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_nvm.c
#	drivers/net/ethernet/intel/i40e/i40e_type.h
#	drivers/net/ethernet/intel/i40evf/i40e_type.h
diff --cc drivers/net/ethernet/intel/i40e/i40e_nvm.c
index bc4977277193,d0288ad4e9b2..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_nvm.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_nvm.c
@@@ -610,6 -615,12 +610,15 @@@ static i40e_status i40e_nvmupd_nvm_writ
  static i40e_status i40e_nvmupd_nvm_read(struct i40e_hw *hw,
  					struct i40e_nvm_access *cmd,
  					u8 *bytes, int *perrno);
++<<<<<<< HEAD
++=======
+ static i40e_status i40e_nvmupd_exec_aq(struct i40e_hw *hw,
+ 				       struct i40e_nvm_access *cmd,
+ 				       u8 *bytes, int *perrno);
+ static i40e_status i40e_nvmupd_get_aq_result(struct i40e_hw *hw,
+ 					     struct i40e_nvm_access *cmd,
+ 					     u8 *bytes, int *perrno);
++>>>>>>> b72dc7b19398 (i40e/i40evf: add get AQ result command to nvmupdate utility)
  static inline u8 i40e_nvmupd_get_module(u32 val)
  {
  	return (u8)(val & I40E_NVM_MOD_PNT_MASK);
@@@ -633,6 -644,9 +642,12 @@@ static char *i40e_nvm_update_state_str[
  	"I40E_NVMUPD_CSUM_CON",
  	"I40E_NVMUPD_CSUM_SA",
  	"I40E_NVMUPD_CSUM_LCB",
++<<<<<<< HEAD
++=======
+ 	"I40E_NVMUPD_STATUS",
+ 	"I40E_NVMUPD_EXEC_AQ",
+ 	"I40E_NVMUPD_GET_AQ_RESULT",
++>>>>>>> b72dc7b19398 (i40e/i40evf: add get AQ result command to nvmupdate utility)
  };
  
  /**
@@@ -794,6 -832,14 +809,17 @@@ static i40e_status i40e_nvmupd_state_in
  		}
  		break;
  
++<<<<<<< HEAD
++=======
+ 	case I40E_NVMUPD_EXEC_AQ:
+ 		status = i40e_nvmupd_exec_aq(hw, cmd, bytes, perrno);
+ 		break;
+ 
+ 	case I40E_NVMUPD_GET_AQ_RESULT:
+ 		status = i40e_nvmupd_get_aq_result(hw, cmd, bytes, perrno);
+ 		break;
+ 
++>>>>>>> b72dc7b19398 (i40e/i40evf: add get AQ result command to nvmupdate utility)
  	default:
  		i40e_debug(hw, I40E_DEBUG_NVM,
  			   "NVMUPD: bad cmd %s in init state\n",
@@@ -1006,6 -1052,12 +1032,15 @@@ static enum i40e_nvmupd_cmd i40e_nvmupd
  		case I40E_NVM_SA:
  			upd_cmd = I40E_NVMUPD_READ_SA;
  			break;
++<<<<<<< HEAD
++=======
+ 		case I40E_NVM_EXEC:
+ 			if (module == 0xf)
+ 				upd_cmd = I40E_NVMUPD_STATUS;
+ 			else if (module == 0)
+ 				upd_cmd = I40E_NVMUPD_GET_AQ_RESULT;
+ 			break;
++>>>>>>> b72dc7b19398 (i40e/i40evf: add get AQ result command to nvmupdate utility)
  		}
  		break;
  
@@@ -1053,6 -1099,146 +1088,149 @@@
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * i40e_nvmupd_exec_aq - Run an AQ command
+  * @hw: pointer to hardware structure
+  * @cmd: pointer to nvm update command buffer
+  * @bytes: pointer to the data buffer
+  * @perrno: pointer to return error code
+  *
+  * cmd structure contains identifiers and data buffer
+  **/
+ static i40e_status i40e_nvmupd_exec_aq(struct i40e_hw *hw,
+ 				       struct i40e_nvm_access *cmd,
+ 				       u8 *bytes, int *perrno)
+ {
+ 	struct i40e_asq_cmd_details cmd_details;
+ 	i40e_status status;
+ 	struct i40e_aq_desc *aq_desc;
+ 	u32 buff_size = 0;
+ 	u8 *buff = NULL;
+ 	u32 aq_desc_len;
+ 	u32 aq_data_len;
+ 
+ 	i40e_debug(hw, I40E_DEBUG_NVM, "NVMUPD: %s\n", __func__);
+ 	memset(&cmd_details, 0, sizeof(cmd_details));
+ 	cmd_details.wb_desc = &hw->nvm_wb_desc;
+ 
+ 	aq_desc_len = sizeof(struct i40e_aq_desc);
+ 	memset(&hw->nvm_wb_desc, 0, aq_desc_len);
+ 
+ 	/* get the aq descriptor */
+ 	if (cmd->data_size < aq_desc_len) {
+ 		i40e_debug(hw, I40E_DEBUG_NVM,
+ 			   "NVMUPD: not enough aq desc bytes for exec, size %d < %d\n",
+ 			   cmd->data_size, aq_desc_len);
+ 		*perrno = -EINVAL;
+ 		return I40E_ERR_PARAM;
+ 	}
+ 	aq_desc = (struct i40e_aq_desc *)bytes;
+ 
+ 	/* if data buffer needed, make sure it's ready */
+ 	aq_data_len = cmd->data_size - aq_desc_len;
+ 	buff_size = max_t(u32, aq_data_len, le16_to_cpu(aq_desc->datalen));
+ 	if (buff_size) {
+ 		if (!hw->nvm_buff.va) {
+ 			status = i40e_allocate_virt_mem(hw, &hw->nvm_buff,
+ 							hw->aq.asq_buf_size);
+ 			if (status)
+ 				i40e_debug(hw, I40E_DEBUG_NVM,
+ 					   "NVMUPD: i40e_allocate_virt_mem for exec buff failed, %d\n",
+ 					   status);
+ 		}
+ 
+ 		if (hw->nvm_buff.va) {
+ 			buff = hw->nvm_buff.va;
+ 			memcpy(buff, &bytes[aq_desc_len], aq_data_len);
+ 		}
+ 	}
+ 
+ 	/* and away we go! */
+ 	status = i40e_asq_send_command(hw, aq_desc, buff,
+ 				       buff_size, &cmd_details);
+ 	if (status) {
+ 		i40e_debug(hw, I40E_DEBUG_NVM,
+ 			   "i40e_nvmupd_exec_aq err %s aq_err %s\n",
+ 			   i40e_stat_str(hw, status),
+ 			   i40e_aq_str(hw, hw->aq.asq_last_status));
+ 		*perrno = i40e_aq_rc_to_posix(status, hw->aq.asq_last_status);
+ 	}
+ 
+ 	return status;
+ }
+ 
+ /**
+  * i40e_nvmupd_get_aq_result - Get the results from the previous exec_aq
+  * @hw: pointer to hardware structure
+  * @cmd: pointer to nvm update command buffer
+  * @bytes: pointer to the data buffer
+  * @perrno: pointer to return error code
+  *
+  * cmd structure contains identifiers and data buffer
+  **/
+ static i40e_status i40e_nvmupd_get_aq_result(struct i40e_hw *hw,
+ 					     struct i40e_nvm_access *cmd,
+ 					     u8 *bytes, int *perrno)
+ {
+ 	u32 aq_total_len;
+ 	u32 aq_desc_len;
+ 	int remainder;
+ 	u8 *buff;
+ 
+ 	i40e_debug(hw, I40E_DEBUG_NVM, "NVMUPD: %s\n", __func__);
+ 
+ 	aq_desc_len = sizeof(struct i40e_aq_desc);
+ 	aq_total_len = aq_desc_len + le16_to_cpu(hw->nvm_wb_desc.datalen);
+ 
+ 	/* check offset range */
+ 	if (cmd->offset > aq_total_len) {
+ 		i40e_debug(hw, I40E_DEBUG_NVM, "%s: offset too big %d > %d\n",
+ 			   __func__, cmd->offset, aq_total_len);
+ 		*perrno = -EINVAL;
+ 		return I40E_ERR_PARAM;
+ 	}
+ 
+ 	/* check copylength range */
+ 	if (cmd->data_size > (aq_total_len - cmd->offset)) {
+ 		int new_len = aq_total_len - cmd->offset;
+ 
+ 		i40e_debug(hw, I40E_DEBUG_NVM, "%s: copy length %d too big, trimming to %d\n",
+ 			   __func__, cmd->data_size, new_len);
+ 		cmd->data_size = new_len;
+ 	}
+ 
+ 	remainder = cmd->data_size;
+ 	if (cmd->offset < aq_desc_len) {
+ 		u32 len = aq_desc_len - cmd->offset;
+ 
+ 		len = min(len, cmd->data_size);
+ 		i40e_debug(hw, I40E_DEBUG_NVM, "%s: aq_desc bytes %d to %d\n",
+ 			   __func__, cmd->offset, cmd->offset + len);
+ 
+ 		buff = ((u8 *)&hw->nvm_wb_desc) + cmd->offset;
+ 		memcpy(bytes, buff, len);
+ 
+ 		bytes += len;
+ 		remainder -= len;
+ 		buff = hw->nvm_buff.va;
+ 	} else {
+ 		buff = hw->nvm_buff.va + (cmd->offset - aq_desc_len);
+ 	}
+ 
+ 	if (remainder > 0) {
+ 		int start_byte = buff - (u8 *)hw->nvm_buff.va;
+ 
+ 		i40e_debug(hw, I40E_DEBUG_NVM, "%s: databuf bytes %d to %d\n",
+ 			   __func__, start_byte, start_byte + remainder);
+ 		memcpy(bytes, buff, remainder);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
++>>>>>>> b72dc7b19398 (i40e/i40evf: add get AQ result command to nvmupdate utility)
   * i40e_nvmupd_nvm_read - Read NVM
   * @hw: pointer to hardware structure
   * @cmd: pointer to nvm update command buffer
diff --cc drivers/net/ethernet/intel/i40e/i40e_type.h
index f65183243a02,af4829065af6..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_type.h
+++ b/drivers/net/ethernet/intel/i40e/i40e_type.h
@@@ -305,6 -305,9 +305,12 @@@ enum i40e_nvmupd_cmd 
  	I40E_NVMUPD_CSUM_CON,
  	I40E_NVMUPD_CSUM_SA,
  	I40E_NVMUPD_CSUM_LCB,
++<<<<<<< HEAD
++=======
+ 	I40E_NVMUPD_STATUS,
+ 	I40E_NVMUPD_EXEC_AQ,
+ 	I40E_NVMUPD_GET_AQ_RESULT,
++>>>>>>> b72dc7b19398 (i40e/i40evf: add get AQ result command to nvmupdate utility)
  };
  
  enum i40e_nvmupd_state {
diff --cc drivers/net/ethernet/intel/i40evf/i40e_type.h
index f0f29b3edffe,ed7166693e5f..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40e_type.h
+++ b/drivers/net/ethernet/intel/i40evf/i40e_type.h
@@@ -304,6 -304,9 +304,12 @@@ enum i40e_nvmupd_cmd 
  	I40E_NVMUPD_CSUM_CON,
  	I40E_NVMUPD_CSUM_SA,
  	I40E_NVMUPD_CSUM_LCB,
++<<<<<<< HEAD
++=======
+ 	I40E_NVMUPD_STATUS,
+ 	I40E_NVMUPD_EXEC_AQ,
+ 	I40E_NVMUPD_GET_AQ_RESULT,
++>>>>>>> b72dc7b19398 (i40e/i40evf: add get AQ result command to nvmupdate utility)
  };
  
  enum i40e_nvmupd_state {
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_nvm.c
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_type.h
* Unmerged path drivers/net/ethernet/intel/i40evf/i40e_type.h
