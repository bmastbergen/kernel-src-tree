tcp: improve undo on timeout

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Yuchung Cheng <ycheng@google.com>
commit 989e04c5bc3ff77d65e1f0d87bf7904dfa30d41c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/989e04c5.failed

Upon timeout, undo (via both timestamps/Eifel and DSACKs) was
disabled if any retransmits were still in flight.  The concern was
perhaps that spurious retransmission sent in a previous recovery
episode may trigger DSACKs to falsely undo the current recovery.

However, this inadvertently misses undo opportunities (using either
TCP timestamps or DSACKs) when timeout occurs during a loss episode,
i.e.  recurring timeouts or timeout during fast recovery. In these
cases some retransmissions will be in flight but we should allow
undo. Furthermore, we should only reset undo_marker and undo_retrans
upon timeout if we are starting a new recovery episode. Finally,
when we do reset our undo state, we now do so in a manner similar
to tcp_enter_recovery(), so that we require a DSACK for each of
the outstsanding retransmissions. This will achieve the original
goal by requiring that we receive the same number of DSACKs as
retransmissions.

This patch increases the undo events by 50% on Google servers.

	Signed-off-by: Yuchung Cheng <ycheng@google.com>
	Signed-off-by: Neal Cardwell <ncardwell@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 989e04c5bc3ff77d65e1f0d87bf7904dfa30d41c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_input.c
diff --cc net/ipv4/tcp_input.c
index 6394ffe428d8,aba4926ca095..000000000000
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@@ -1899,7 -1898,14 +1892,18 @@@ void tcp_clear_retrans(struct tcp_sock 
  	tp->sacked_out = 0;
  }
  
++<<<<<<< HEAD
 +/* Enter Loss state. If "how" is not zero, forget all SACK information
++=======
+ static inline void tcp_init_undo(struct tcp_sock *tp)
+ {
+ 	tp->undo_marker = tp->snd_una;
+ 	/* Retransmission still in flight may cause DSACKs later. */
+ 	tp->undo_retrans = tp->retrans_out ? : -1;
+ }
+ 
+ /* Enter Loss state. If we detect SACK reneging, forget all SACK information
++>>>>>>> 989e04c5bc3f (tcp: improve undo on timeout)
   * and reset tags completely, otherwise preserve SACKs. If receiver
   * dropped its ofo queue, we will know this due to reneging detection.
   */
@@@ -1928,8 -1937,10 +1934,15 @@@ void tcp_enter_loss(struct sock *sk, in
  	if (tcp_is_reno(tp))
  		tcp_reset_reno_sack(tp);
  
++<<<<<<< HEAD
 +	tp->undo_marker = tp->snd_una;
 +	if (how) {
++=======
+ 	skb = tcp_write_queue_head(sk);
+ 	is_reneg = skb && (TCP_SKB_CB(skb)->sacked & TCPCB_SACKED_ACKED);
+ 	if (is_reneg) {
+ 		NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPSACKRENEGING);
++>>>>>>> 989e04c5bc3f (tcp: improve undo on timeout)
  		tp->sacked_out = 0;
  		tp->fackets_out = 0;
  	}
@@@ -1939,11 -1950,8 +1952,8 @@@
  		if (skb == tcp_send_head(sk))
  			break;
  
- 		if (TCP_SKB_CB(skb)->sacked & TCPCB_SACKED_RETRANS)
- 			tp->undo_marker = 0;
- 
  		TCP_SKB_CB(skb)->sacked &= (~TCPCB_TAGBITS)|TCPCB_SACKED_ACKED;
 -		if (!(TCP_SKB_CB(skb)->sacked&TCPCB_SACKED_ACKED) || is_reneg) {
 +		if (!(TCP_SKB_CB(skb)->sacked&TCPCB_SACKED_ACKED) || how) {
  			TCP_SKB_CB(skb)->sacked &= ~TCPCB_SACKED_ACKED;
  			TCP_SKB_CB(skb)->sacked |= TCPCB_LOST;
  			tp->lost_out += tcp_skb_pcount(skb);
diff --git a/include/linux/tcp.h b/include/linux/tcp.h
index f022e6a239f4..451c1366373d 100644
--- a/include/linux/tcp.h
+++ b/include/linux/tcp.h
@@ -275,7 +275,7 @@ struct tcp_sock {
 	u32	retrans_stamp;	/* Timestamp of the last retransmit,
 				 * also used in SYN-SENT to remember stamp of
 				 * the first SYN. */
-	u32	undo_marker;	/* tracking retrans started here. */
+	u32	undo_marker;	/* snd_una upon a new recovery episode. */
 	int	undo_retrans;	/* number of undoable retransmissions. */
 	u32	total_retrans;	/* Total retransmits for entire connection */
 
* Unmerged path net/ipv4/tcp_input.c
