KVM: Allow KVM_CHECK_EXTENSION on the vm fd

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [kvm] Allow KVM_CHECK_EXTENSION on the vm fd (Bandan Das) [1209995]
Rebuild_FUZZ: 93.83%
commit-author Alexander Graf <agraf@suse.de>
commit 92b591a4c46b103ebd3fc0d03a084e1efd331253
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/92b591a4.failed

The KVM_CHECK_EXTENSION is only available on the kvm fd today. Unfortunately
on PPC some of the capabilities change depending on the way a VM was created.

So instead we need a way to expose capabilities as VM ioctl, so that we can
see which VM type we're using (HV or PR). To enable this, add the
KVM_CHECK_EXTENSION ioctl to our vm ioctl portfolio.

	Signed-off-by: Alexander Graf <agraf@suse.de>
	Acked-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 92b591a4c46b103ebd3fc0d03a084e1efd331253)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	virt/kvm/kvm_main.c
diff --cc virt/kvm/kvm_main.c
index 435e170df91e,1b95cc926cfc..000000000000
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@@ -2568,33 -2602,6 +2599,36 @@@ static int kvm_dev_ioctl_create_vm(unsi
  	return r;
  }
  
++<<<<<<< HEAD
 +static long kvm_vm_ioctl_check_extension_generic(struct kvm *kvm, long arg)
 +{
 +	switch (arg) {
 +	case KVM_CAP_USER_MEMORY:
 +	case KVM_CAP_DESTROY_MEMORY_REGION_WORKS:
 +	case KVM_CAP_JOIN_MEMORY_REGIONS_WORKS:
 +#ifdef CONFIG_KVM_APIC_ARCHITECTURE
 +	case KVM_CAP_SET_BOOT_CPU_ID:
 +#endif
 +	case KVM_CAP_INTERNAL_ERROR_DATA:
 +#ifdef CONFIG_HAVE_KVM_MSI
 +	case KVM_CAP_SIGNAL_MSI:
 +#endif
 +#ifdef CONFIG_HAVE_KVM_IRQFD
 +	case KVM_CAP_IRQFD_RESAMPLE:
 +#endif
 +		return 1;
 +#ifdef CONFIG_HAVE_KVM_IRQ_ROUTING
 +	case KVM_CAP_IRQ_ROUTING:
 +		return KVM_MAX_IRQ_ROUTES;
 +#endif
 +	default:
 +		break;
 +	}
 +	return kvm_vm_ioctl_check_extension(kvm, arg);
 +}
 +
++=======
++>>>>>>> 92b591a4c46b (KVM: Allow KVM_CHECK_EXTENSION on the vm fd)
  static long kvm_dev_ioctl(struct file *filp,
  			  unsigned int ioctl, unsigned long arg)
  {
diff --git a/Documentation/virtual/kvm/api.txt b/Documentation/virtual/kvm/api.txt
index 455e552b4a5e..f4f52153f558 100644
--- a/Documentation/virtual/kvm/api.txt
+++ b/Documentation/virtual/kvm/api.txt
@@ -148,9 +148,9 @@ of banks, as set via the KVM_X86_SETUP_MCE ioctl.
 
 4.4 KVM_CHECK_EXTENSION
 
-Capability: basic
+Capability: basic, KVM_CAP_CHECK_EXTENSION_VM for vm ioctl
 Architectures: all
-Type: system ioctl
+Type: system ioctl, vm ioctl
 Parameters: extension identifier (KVM_CAP_*)
 Returns: 0 if unsupported; 1 (or some other positive integer) if supported
 
@@ -160,6 +160,9 @@ receives an integer that describes the extension availability.
 Generally 0 means no and 1 means yes, but some extensions may report
 additional information in the integer return value.
 
+Based on their initialization different VMs may have different capabilities.
+It is thus encouraged to use the vm ioctl to query for capabilities (available
+with KVM_CAP_CHECK_EXTENSION_VM on the vm fd)
 
 4.5 KVM_GET_VCPU_MMAP_SIZE
 
diff --git a/include/uapi/linux/kvm.h b/include/uapi/linux/kvm.h
index b6f604cf40dd..9d1667cf7a20 100644
--- a/include/uapi/linux/kvm.h
+++ b/include/uapi/linux/kvm.h
@@ -680,6 +680,7 @@ struct kvm_ppc_smmu_info {
 #define KVM_CAP_IOEVENTFD_NO_LENGTH 100
 #define KVM_CAP_PPC_FIXUP_HCALL 103
 #define KVM_CAP_PPC_ENABLE_HCALL 104
+#define KVM_CAP_CHECK_EXTENSION_VM 105
 
 #ifdef KVM_CAP_IRQ_ROUTING
 
* Unmerged path virt/kvm/kvm_main.c
