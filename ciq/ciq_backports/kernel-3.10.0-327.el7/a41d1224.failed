ALSA: hda - Embed bus into controller object

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [alsa] hda - Embed bus into controller object (Jaroslav Kysela) [1197064]
Rebuild_FUZZ: 92.68%
commit-author Takashi Iwai <tiwai@suse.de>
commit a41d122449bea303ada415ef5fb2bf434f5481f9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/a41d1224.failed

... and replace with the existing hda-core helper codes.
This reduces lots of lines, finally.

Since struct hda_bus is now embedded into struct azx,
snd_hda_bus_new() is moved and expanded from hda_codec.c to
hda_controller.c, accordingly.  Also private_free bus ops and
private_data field are removed because we no longer need to point azx
object from bus (we can use container_of())

The spin locks are consolidated into the single one, bus->reg_lock.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit a41d122449bea303ada415ef5fb2bf434f5481f9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/hda_codec.c
#	sound/pci/hda/hda_codec.h
#	sound/pci/hda/hda_controller.c
#	sound/pci/hda/hda_controller.h
#	sound/pci/hda/hda_intel.c
#	sound/pci/hda/hda_tegra.c
diff --cc sound/pci/hda/hda_codec.c
index d744f45d5fe3,2abf9f95dcbb..000000000000
--- a/sound/pci/hda/hda_codec.c
+++ b/sound/pci/hda/hda_codec.c
@@@ -678,164 -481,7 +678,167 @@@ int snd_hda_get_devices(struct hda_code
  	return devices;
  }
  
 +/**
 + * snd_hda_queue_unsol_event - add an unsolicited event to queue
 + * @bus: the BUS
 + * @res: unsolicited event (lower 32bit of RIRB entry)
 + * @res_ex: codec addr and flags (upper 32bit or RIRB entry)
 + *
 + * Adds the given event to the queue.  The events are processed in
 + * the workqueue asynchronously.  Call this function in the interrupt
 + * hanlder when RIRB receives an unsolicited event.
 + *
 + * Returns 0 if successful, or a negative error code.
 + */
 +int snd_hda_queue_unsol_event(struct hda_bus *bus, u32 res, u32 res_ex)
 +{
 +	struct hda_bus_unsolicited *unsol;
 +	unsigned int wp;
 +
 +	if (!bus)
 +		return 0;
 +
 +	trace_hda_unsol_event(bus, res, res_ex);
 +	unsol = &bus->unsol;
 +	wp = (unsol->wp + 1) % HDA_UNSOL_QUEUE_SIZE;
 +	unsol->wp = wp;
 +
 +	wp <<= 1;
 +	unsol->queue[wp] = res;
 +	unsol->queue[wp + 1] = res_ex;
 +
 +	schedule_work(&unsol->work);
 +
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(snd_hda_queue_unsol_event);
 +
 +/*
 + * process queued unsolicited events
 + */
 +static void process_unsol_events(struct work_struct *work)
 +{
 +	struct hda_bus *bus = container_of(work, struct hda_bus, unsol.work);
 +	struct hda_bus_unsolicited *unsol = &bus->unsol;
 +	struct hda_codec *codec;
 +	unsigned int rp, caddr, res;
 +
 +	while (unsol->rp != unsol->wp) {
 +		rp = (unsol->rp + 1) % HDA_UNSOL_QUEUE_SIZE;
 +		unsol->rp = rp;
 +		rp <<= 1;
 +		res = unsol->queue[rp];
 +		caddr = unsol->queue[rp + 1];
 +		if (!(caddr & (1 << 4))) /* no unsolicited event? */
 +			continue;
 +		codec = bus->caddr_tbl[caddr & 0x0f];
 +		if (codec && codec->patch_ops.unsol_event)
 +			codec->patch_ops.unsol_event(codec, res);
 +	}
 +}
 +
 +/*
++<<<<<<< HEAD
 + * destructor
 + */
 +static void snd_hda_bus_free(struct hda_bus *bus)
 +{
 +	if (!bus)
 +		return;
 +
 +	WARN_ON(!list_empty(&bus->codec_list));
 +	cancel_work_sync(&bus->unsol.work);
 +	if (bus->ops.private_free)
 +		bus->ops.private_free(bus);
 +	kfree(bus);
 +}
 +
 +static int snd_hda_bus_dev_free(struct snd_device *device)
 +{
 +	snd_hda_bus_free(device->device_data);
 +	return 0;
 +}
 +
 +static int snd_hda_bus_dev_disconnect(struct snd_device *device)
 +{
 +	struct hda_bus *bus = device->device_data;
 +	bus->shutdown = 1;
 +	return 0;
 +}
 +
 +/**
 + * snd_hda_bus_new - create a HDA bus
 + * @card: the card entry
 + * @busp: the pointer to store the created bus instance
 + *
 + * Returns 0 if successful, or a negative error code.
 + */
 +int snd_hda_bus_new(struct snd_card *card,
 +		    struct hda_bus **busp)
 +{
 +	struct hda_bus *bus;
 +	int err;
 +	static struct snd_device_ops dev_ops = {
 +		.dev_disconnect = snd_hda_bus_dev_disconnect,
 +		.dev_free = snd_hda_bus_dev_free,
 +	};
 +
 +	if (busp)
 +		*busp = NULL;
 +
 +	bus = kzalloc(sizeof(*bus), GFP_KERNEL);
 +	if (!bus)
 +		return -ENOMEM;
 +
 +	bus->card = card;
 +	mutex_init(&bus->cmd_mutex);
 +	mutex_init(&bus->prepare_mutex);
 +	INIT_LIST_HEAD(&bus->codec_list);
 +	INIT_WORK(&bus->unsol.work, process_unsol_events);
 +
 +	err = snd_device_new(card, SNDRV_DEV_BUS, bus, &dev_ops);
 +	if (err < 0) {
 +		snd_hda_bus_free(bus);
 +		return err;
 +	}
 +	if (busp)
 +		*busp = bus;
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(snd_hda_bus_new);
 +
 +/*
 + * look for an AFG and MFG nodes
 + */
 +static void setup_fg_nodes(struct hda_codec *codec)
 +{
 +	int i, total_nodes, function_id;
 +	hda_nid_t nid;
 +
 +	total_nodes = snd_hda_get_sub_nodes(codec, AC_NODE_ROOT, &nid);
 +	for (i = 0; i < total_nodes; i++, nid++) {
 +		function_id = snd_hda_param_read(codec, nid,
 +						AC_PAR_FUNCTION_TYPE);
 +		switch (function_id & 0xff) {
 +		case AC_GRP_AUDIO_FUNCTION:
 +			codec->afg = nid;
 +			codec->afg_function_id = function_id & 0xff;
 +			codec->afg_unsol = (function_id >> 8) & 1;
 +			break;
 +		case AC_GRP_MODEM_FUNCTION:
 +			codec->mfg = nid;
 +			codec->mfg_function_id = function_id & 0xff;
 +			codec->mfg_unsol = (function_id >> 8) & 1;
 +			break;
 +		default:
 +			break;
 +		}
 +	}
 +}
 +
  /*
++=======
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
   * read widget caps for each widget and store in cache
   */
  static int read_widget_caps(struct hda_codec *codec, hda_nid_t fg_node)
diff --cc sound/pci/hda/hda_codec.h
index 00c6f394c5ce,57b9aa0f36c1..000000000000
--- a/sound/pci/hda/hda_codec.h
+++ b/sound/pci/hda/hda_codec.h
@@@ -70,12 -42,6 +70,15 @@@ struct hda_pcm_stream
  
  /* bus operators */
  struct hda_bus_ops {
++<<<<<<< HEAD
 +	/* send a single command */
 +	int (*command)(struct hda_bus *bus, unsigned int cmd);
 +	/* get a response from the last command */
 +	unsigned int (*get_response)(struct hda_bus *bus, unsigned int addr);
 +	/* free the private data */
 +	void (*private_free)(struct hda_bus *);
++=======
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  	/* attach a PCM stream */
  	int (*attach_pcm)(struct hda_bus *bus, struct hda_codec *codec,
  			  struct hda_pcm *pcm);
@@@ -115,26 -67,16 +118,25 @@@ struct hda_bus_unsolicited 
   * A hda_bus contains several codecs in the list codec_list.
   */
  struct hda_bus {
 -	struct hdac_bus core;
 -
  	struct snd_card *card;
  
- 	void *private_data;
  	struct pci_dev *pci;
  	const char *modelname;
 +	int *power_save;
  	struct hda_bus_ops ops;
  
 +	/* codec linked list */
 +	struct list_head codec_list;
 +	unsigned int num_codecs;
 +	/* link caddr -> codec */
 +	struct hda_codec *caddr_tbl[HDA_MAX_CODEC_ADDRESS + 1];
 +
 +	struct mutex cmd_mutex;
  	struct mutex prepare_mutex;
  
 +	/* unsolicited event queue */
 +	struct hda_bus_unsolicited unsol;
 +
  	/* assigned PCMs */
  	DECLARE_BITMAP(pcm_dev_bits, SNDRV_PCM_DEVICES);
  
diff --cc sound/pci/hda/hda_controller.c
index 0d7233e1e418,21058b41b2c6..000000000000
--- a/sound/pci/hda/hda_controller.c
+++ b/sound/pci/hda/hda_controller.c
@@@ -556,13 -217,20 +556,14 @@@ static int azx_pcm_trigger(struct snd_p
  {
  	struct azx_pcm *apcm = snd_pcm_substream_chip(substream);
  	struct azx *chip = apcm->chip;
+ 	struct hdac_bus *bus = azx_bus(chip);
  	struct azx_dev *azx_dev;
  	struct snd_pcm_substream *s;
 -	struct hdac_stream *hstr;
 -	bool start;
 -	int sbits = 0;
 -	int sync_reg;
 +	int rstart = 0, start, nsync = 0, sbits = 0;
 +	int nwait, timeout;
  
  	azx_dev = get_azx_dev(substream);
 -	hstr = azx_stream(azx_dev);
 -	if (chip->driver_caps & AZX_DCAPS_OLD_SSYNC)
 -		sync_reg = AZX_REG_OLD_SSYNC;
 -	else
 -		sync_reg = AZX_REG_SSYNC;
 +	trace_azx_pcm_trigger(chip, azx_dev, cmd);
  
  	if (dsp_is_locked(azx_dev) || !azx_dev->prepared)
  		return -EPIPE;
@@@ -592,91 -258,32 +593,104 @@@
  		snd_pcm_trigger_done(s, substream);
  	}
  
- 	spin_lock(&chip->reg_lock);
+ 	spin_lock(&bus->reg_lock);
  
  	/* first, set SYNC bits of corresponding streams */
 -	snd_hdac_stream_sync_trigger(hstr, true, sbits, sync_reg);
 +	if (chip->driver_caps & AZX_DCAPS_OLD_SSYNC)
 +		azx_writel(chip, OLD_SSYNC,
 +			azx_readl(chip, OLD_SSYNC) | sbits);
 +	else
 +		azx_writel(chip, SSYNC, azx_readl(chip, SSYNC) | sbits);
  
  	snd_pcm_group_for_each_entry(s, substream) {
  		if (s->pcm->card != substream->pcm->card)
  			continue;
  		azx_dev = get_azx_dev(s);
  		if (start) {
 -			azx_dev->insufficient = 1;
 -			snd_hdac_stream_start(azx_stream(azx_dev), true);
 +			azx_dev->start_wallclk = azx_readl(chip, WALLCLK);
 +			if (!rstart)
 +				azx_dev->start_wallclk -=
 +						azx_dev->period_wallclk;
 +			azx_stream_start(chip, azx_dev);
  		} else {
 -			snd_hdac_stream_stop(azx_stream(azx_dev));
 +			azx_stream_stop(chip, azx_dev);
  		}
 +		azx_dev->running = start;
  	}
++<<<<<<< HEAD
 +	spin_unlock(&chip->reg_lock);
 +	if (start) {
 +		/* wait until all FIFOs get ready */
 +		for (timeout = 5000; timeout; timeout--) {
 +			nwait = 0;
 +			snd_pcm_group_for_each_entry(s, substream) {
 +				if (s->pcm->card != substream->pcm->card)
 +					continue;
 +				azx_dev = get_azx_dev(s);
 +				if (!(azx_sd_readb(chip, azx_dev, SD_STS) &
 +				      SD_STS_FIFO_READY))
 +					nwait++;
 +			}
 +			if (!nwait)
 +				break;
 +			cpu_relax();
 +		}
 +	} else {
 +		/* wait until all RUN bits are cleared */
 +		for (timeout = 5000; timeout; timeout--) {
 +			nwait = 0;
 +			snd_pcm_group_for_each_entry(s, substream) {
 +				if (s->pcm->card != substream->pcm->card)
 +					continue;
 +				azx_dev = get_azx_dev(s);
 +				if (azx_sd_readb(chip, azx_dev, SD_CTL) &
 +				    SD_CTL_DMA_START)
 +					nwait++;
 +			}
 +			if (!nwait)
 +				break;
 +			cpu_relax();
 +		}
 +	}
 +	spin_lock(&chip->reg_lock);
 +	/* reset SYNC bits */
 +	if (chip->driver_caps & AZX_DCAPS_OLD_SSYNC)
 +		azx_writel(chip, OLD_SSYNC,
 +			azx_readl(chip, OLD_SSYNC) & ~sbits);
 +	else
 +		azx_writel(chip, SSYNC, azx_readl(chip, SSYNC) & ~sbits);
 +	if (start) {
 +		azx_timecounter_init(substream, 0, 0);
 +		snd_pcm_gettime(substream->runtime, &substream->runtime->trigger_tstamp);
 +		substream->runtime->trigger_tstamp_latched = true;
 +
 +		if (nsync > 1) {
 +			cycle_t cycle_last;
 +
 +			/* same start cycle for master and group */
 +			azx_dev = get_azx_dev(substream);
 +			cycle_last = azx_dev->azx_tc.cycle_last;
 +
 +			snd_pcm_group_for_each_entry(s, substream) {
 +				if (s->pcm->card != substream->pcm->card)
 +					continue;
 +				azx_timecounter_init(s, 1, cycle_last);
 +			}
 +		}
 +	}
 +	spin_unlock(&chip->reg_lock);
++=======
+ 	spin_unlock(&bus->reg_lock);
+ 
+ 	snd_hdac_stream_sync(hstr, start, sbits);
+ 
+ 	spin_lock(&bus->reg_lock);
+ 	/* reset SYNC bits */
+ 	snd_hdac_stream_sync_trigger(hstr, false, sbits, sync_reg);
+ 	if (start)
+ 		snd_hdac_stream_timecounter_init(hstr, sbits);
+ 	spin_unlock(&bus->reg_lock);
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  	return 0;
  }
  
@@@ -975,89 -575,6 +990,92 @@@ static int azx_attach_pcm_stream(struc
  	return 0;
  }
  
++<<<<<<< HEAD
 +/*
 + * CORB / RIRB interface
 + */
 +static int azx_alloc_cmd_io(struct azx *chip)
 +{
 +	/* single page (at least 4096 bytes) must suffice for both ringbuffes */
 +	return chip->ops->dma_alloc_pages(chip, SNDRV_DMA_TYPE_DEV,
 +					  PAGE_SIZE, &chip->rb);
 +}
 +
 +static void azx_init_cmd_io(struct azx *chip)
 +{
 +	int timeout;
 +
 +	spin_lock_irq(&chip->reg_lock);
 +	/* CORB set up */
 +	chip->corb.addr = chip->rb.addr;
 +	chip->corb.buf = (u32 *)chip->rb.area;
 +	azx_writel(chip, CORBLBASE, (u32)chip->corb.addr);
 +	azx_writel(chip, CORBUBASE, upper_32_bits(chip->corb.addr));
 +
 +	/* set the corb size to 256 entries (ULI requires explicitly) */
 +	azx_writeb(chip, CORBSIZE, 0x02);
 +	/* set the corb write pointer to 0 */
 +	azx_writew(chip, CORBWP, 0);
 +
 +	/* reset the corb hw read pointer */
 +	azx_writew(chip, CORBRP, AZX_CORBRP_RST);
 +	if (!(chip->driver_caps & AZX_DCAPS_CORBRP_SELF_CLEAR)) {
 +		for (timeout = 1000; timeout > 0; timeout--) {
 +			if ((azx_readw(chip, CORBRP) & AZX_CORBRP_RST) == AZX_CORBRP_RST)
 +				break;
 +			udelay(1);
 +		}
 +		if (timeout <= 0)
 +			dev_err(chip->card->dev, "CORB reset timeout#1, CORBRP = %d\n",
 +				azx_readw(chip, CORBRP));
 +
 +		azx_writew(chip, CORBRP, 0);
 +		for (timeout = 1000; timeout > 0; timeout--) {
 +			if (azx_readw(chip, CORBRP) == 0)
 +				break;
 +			udelay(1);
 +		}
 +		if (timeout <= 0)
 +			dev_err(chip->card->dev, "CORB reset timeout#2, CORBRP = %d\n",
 +				azx_readw(chip, CORBRP));
 +	}
 +
 +	/* enable corb dma */
 +	azx_writeb(chip, CORBCTL, AZX_CORBCTL_RUN);
 +
 +	/* RIRB set up */
 +	chip->rirb.addr = chip->rb.addr + 2048;
 +	chip->rirb.buf = (u32 *)(chip->rb.area + 2048);
 +	chip->rirb.wp = chip->rirb.rp = 0;
 +	memset(chip->rirb.cmds, 0, sizeof(chip->rirb.cmds));
 +	azx_writel(chip, RIRBLBASE, (u32)chip->rirb.addr);
 +	azx_writel(chip, RIRBUBASE, upper_32_bits(chip->rirb.addr));
 +
 +	/* set the rirb size to 256 entries (ULI requires explicitly) */
 +	azx_writeb(chip, RIRBSIZE, 0x02);
 +	/* reset the rirb hw write pointer */
 +	azx_writew(chip, RIRBWP, AZX_RIRBWP_RST);
 +	/* set N=1, get RIRB response interrupt for new entry */
 +	if (chip->driver_caps & AZX_DCAPS_CTX_WORKAROUND)
 +		azx_writew(chip, RINTCNT, 0xc0);
 +	else
 +		azx_writew(chip, RINTCNT, 1);
 +	/* enable rirb dma and response irq */
 +	azx_writeb(chip, RIRBCTL, AZX_RBCTL_DMA_EN | AZX_RBCTL_IRQ_EN);
 +	spin_unlock_irq(&chip->reg_lock);
 +}
 +
 +static void azx_free_cmd_io(struct azx *chip)
 +{
 +	spin_lock_irq(&chip->reg_lock);
 +	/* disable ringbuffer DMAs */
 +	azx_writeb(chip, RIRBCTL, 0);
 +	azx_writeb(chip, CORBCTL, 0);
 +	spin_unlock_irq(&chip->reg_lock);
 +}
 +
++=======
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  static unsigned int azx_command_addr(u32 cmd)
  {
  	unsigned int addr = cmd >> 28;
@@@ -1070,92 -587,12 +1088,17 @@@
  	return addr;
  }
  
- /* send a command */
- static int azx_corb_send_cmd(struct hda_bus *bus, u32 val)
- {
- 	struct azx *chip = bus->private_data;
- 	unsigned int addr = azx_command_addr(val);
- 	unsigned int wp, rp;
- 
- 	spin_lock_irq(&chip->reg_lock);
- 
- 	/* add command to corb */
- 	wp = azx_readw(chip, CORBWP);
- 	if (wp == 0xffff) {
- 		/* something wrong, controller likely turned to D3 */
- 		spin_unlock_irq(&chip->reg_lock);
- 		return -EIO;
- 	}
- 	wp++;
- 	wp %= AZX_MAX_CORB_ENTRIES;
- 
- 	rp = azx_readw(chip, CORBRP);
- 	if (wp == rp) {
- 		/* oops, it's full */
- 		spin_unlock_irq(&chip->reg_lock);
- 		return -EAGAIN;
- 	}
- 
- 	chip->rirb.cmds[addr]++;
- 	chip->corb.buf[wp] = cpu_to_le32(val);
- 	azx_writew(chip, CORBWP, wp);
- 
- 	spin_unlock_irq(&chip->reg_lock);
- 
- 	return 0;
- }
- 
- #define AZX_RIRB_EX_UNSOL_EV	(1<<4)
- 
- /* retrieve RIRB entry - called from interrupt handler */
- static void azx_update_rirb(struct azx *chip)
- {
- 	unsigned int rp, wp;
- 	unsigned int addr;
- 	u32 res, res_ex;
- 
- 	wp = azx_readw(chip, RIRBWP);
- 	if (wp == 0xffff) {
- 		/* something wrong, controller likely turned to D3 */
- 		return;
- 	}
- 
- 	if (wp == chip->rirb.wp)
- 		return;
- 	chip->rirb.wp = wp;
- 
- 	while (chip->rirb.rp != wp) {
- 		chip->rirb.rp++;
- 		chip->rirb.rp %= AZX_MAX_RIRB_ENTRIES;
- 
- 		rp = chip->rirb.rp << 1; /* an RIRB entry is 8-bytes */
- 		res_ex = le32_to_cpu(chip->rirb.buf[rp + 1]);
- 		res = le32_to_cpu(chip->rirb.buf[rp]);
- 		addr = res_ex & 0xf;
- 		if ((addr >= AZX_MAX_CODECS) || !(chip->codec_mask & (1 << addr))) {
- 			dev_err(chip->card->dev, "spurious response %#x:%#x, rp = %d, wp = %d",
- 				res, res_ex,
- 				chip->rirb.rp, wp);
- 			snd_BUG();
- 		} else if (res_ex & AZX_RIRB_EX_UNSOL_EV)
- 			snd_hda_queue_unsol_event(chip->bus, res, res_ex);
- 		else if (chip->rirb.cmds[addr]) {
- 			chip->rirb.res[addr] = res;
- 			smp_wmb();
- 			chip->rirb.cmds[addr]--;
- 		} else if (printk_ratelimit()) {
- 			dev_err(chip->card->dev, "spurious response %#x:%#x, last cmd=%#08x\n",
- 				res, res_ex,
- 				chip->last_cmd[addr]);
- 		}
- 	}
- }
- 
  /* receive a response */
++<<<<<<< HEAD
 +static unsigned int azx_rirb_get_response(struct hda_bus *bus,
 +					  unsigned int addr)
++=======
+ static int azx_rirb_get_response(struct hdac_bus *bus, unsigned int addr,
+ 				 unsigned int *res)
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  {
- 	struct azx *chip = bus->private_data;
+ 	struct azx *chip = bus_to_azx(bus);
+ 	struct hda_bus *hbus = &chip->bus;
  	unsigned long timeout;
  	unsigned long loopcounter;
  	int do_poll = 0;
@@@ -1164,22 -601,21 +1107,36 @@@
  	timeout = jiffies + msecs_to_jiffies(1000);
  
  	for (loopcounter = 0;; loopcounter++) {
++<<<<<<< HEAD
 +		if (chip->polling_mode || do_poll) {
 +			spin_lock_irq(&chip->reg_lock);
 +			azx_update_rirb(chip);
 +			spin_unlock_irq(&chip->reg_lock);
 +		}
 +		if (!chip->rirb.cmds[addr]) {
 +			smp_rmb();
 +			bus->rirb_error = 0;
 +
 +			if (!do_poll)
 +				chip->poll_count = 0;
 +			return chip->rirb.res[addr]; /* the last value */
++=======
+ 		spin_lock_irq(&bus->reg_lock);
+ 		if (chip->polling_mode || do_poll)
+ 			snd_hdac_bus_update_rirb(bus);
+ 		if (!bus->rirb.cmds[addr]) {
+ 			if (!do_poll)
+ 				chip->poll_count = 0;
+ 			if (res)
+ 				*res = bus->rirb.res[addr]; /* the last value */
+ 			spin_unlock_irq(&bus->reg_lock);
+ 			return 0;
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  		}
+ 		spin_unlock_irq(&bus->reg_lock);
  		if (time_after(jiffies, timeout))
  			break;
- 		if (bus->needs_damn_long_delay || loopcounter > 3000)
+ 		if (hbus->needs_damn_long_delay || loopcounter > 3000)
  			msleep(2); /* temporary workaround */
  		else {
  			udelay(10);
@@@ -1187,8 -623,8 +1144,13 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	if (bus->no_response_fallback)
 +		return -1;
++=======
+ 	if (hbus->no_response_fallback)
+ 		return -EIO;
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  
  	if (!chip->polling_mode && chip->poll_count < 2) {
  		dev_dbg(chip->card->dev,
@@@ -1211,12 -647,10 +1173,19 @@@
  	if (chip->msi) {
  		dev_warn(chip->card->dev,
  			 "No response from codec, disabling MSI: last cmd=0x%08x\n",
++<<<<<<< HEAD
 +			 chip->last_cmd[addr]);
 +		if (chip->ops->disable_msi_reset_irq(chip) &&
 +		    chip->ops->disable_msi_reset_irq(chip) < 0) {
 +			bus->rirb_error = 1;
 +			return -1;
 +		}
++=======
+ 			 bus->last_cmd[addr]);
+ 		if (chip->ops->disable_msi_reset_irq &&
+ 		    chip->ops->disable_msi_reset_irq(chip) < 0)
+ 			return -EIO;
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  		goto again;
  	}
  
@@@ -1231,22 -665,18 +1200,34 @@@
  	/* a fatal communication error; need either to reset or to fallback
  	 * to the single_cmd mode
  	 */
++<<<<<<< HEAD
 +	bus->rirb_error = 1;
 +	if (bus->allow_bus_reset && !bus->response_reset && !bus->in_reset) {
 +		bus->response_reset = 1;
 +		return -1; /* give a chance to retry */
++=======
+ 	if (hbus->allow_bus_reset && !hbus->response_reset && !hbus->in_reset) {
+ 		hbus->response_reset = 1;
+ 		return -EAGAIN; /* give a chance to retry */
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  	}
  
  	dev_err(chip->card->dev,
  		"azx_get_response timeout, switching to single_cmd mode: last cmd=0x%08x\n",
- 		chip->last_cmd[addr]);
+ 		bus->last_cmd[addr]);
  	chip->single_cmd = 1;
++<<<<<<< HEAD
 +	bus->response_reset = 0;
 +	/* release CORB/RIRB */
 +	azx_free_cmd_io(chip);
 +	/* disable unsolicited responses */
 +	azx_writel(chip, GCTL, azx_readl(chip, GCTL) & ~AZX_GCTL_UNSOL);
 +	return -1;
++=======
+ 	hbus->response_reset = 0;
+ 	snd_hdac_bus_stop_cmd_io(bus);
+ 	return -EIO;
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  }
  
  /*
@@@ -1287,7 -717,7 +1268,11 @@@ static int azx_single_send_cmd(struct h
  	unsigned int addr = azx_command_addr(val);
  	int timeout = 50;
  
++<<<<<<< HEAD
 +	bus->rirb_error = 0;
++=======
+ 	bus->last_cmd[azx_command_addr(val)] = val;
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  	while (timeout--) {
  		/* check ICB busy bit */
  		if (!((azx_readw(chip, IRS) & AZX_IRS_BUSY))) {
@@@ -1309,11 -739,12 +1294,20 @@@
  }
  
  /* receive a response */
++<<<<<<< HEAD
 +static unsigned int azx_single_get_response(struct hda_bus *bus,
 +					    unsigned int addr)
 +{
 +	struct azx *chip = bus->private_data;
 +	return chip->rirb.res[addr];
++=======
+ static int azx_single_get_response(struct hdac_bus *bus, unsigned int addr,
+ 				   unsigned int *res)
+ {
+ 	if (res)
+ 		*res = bus->rirb.res[addr];
+ 	return 0;
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  }
  
  /*
@@@ -1324,9 -755,9 +1318,15 @@@
   */
  
  /* send a command */
++<<<<<<< HEAD
 +static int azx_send_cmd(struct hda_bus *bus, unsigned int val)
 +{
 +	struct azx *chip = bus->private_data;
++=======
+ static int azx_send_cmd(struct hdac_bus *bus, unsigned int val)
+ {
+ 	struct azx *chip = bus_to_azx(bus);
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  
  	if (chip->disabled)
  		return 0;
@@@ -1338,10 -768,11 +1337,18 @@@
  }
  
  /* get a response */
++<<<<<<< HEAD
 +static unsigned int azx_get_response(struct hda_bus *bus,
 +				     unsigned int addr)
 +{
 +	struct azx *chip = bus->private_data;
++=======
+ static int azx_get_response(struct hdac_bus *bus, unsigned int addr,
+ 			    unsigned int *res)
+ {
+ 	struct azx *chip = bus_to_azx(bus);
+ 
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  	if (chip->disabled)
  		return 0;
  	if (chip->single_cmd)
@@@ -1359,282 -795,78 +1366,320 @@@
  static struct azx_dev *
  azx_get_dsp_loader_dev(struct azx *chip)
  {
 -	struct hdac_bus *bus = azx_bus(chip);
 -	struct hdac_stream *s;
 -
 -	list_for_each_entry(s, &bus->stream_list, list)
 -		if (s->index == chip->playback_index_offset)
 -			return stream_to_azx_dev(s);
 -
 -	return NULL;
 +	return &chip->azx_dev[chip->playback_index_offset];
  }
  
- static int azx_load_dsp_prepare(struct hda_bus *bus, unsigned int format,
+ static int azx_load_dsp_prepare(struct hda_bus *_bus, unsigned int format,
  				unsigned int byte_size,
  				struct snd_dma_buffer *bufp)
  {
++<<<<<<< HEAD
 +	u32 *bdl;
 +	struct azx *chip = bus->private_data;
++=======
+ 	struct hdac_bus *bus = &_bus->core;
+ 	struct azx *chip = bus_to_azx(bus);
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  	struct azx_dev *azx_dev;
 -	struct hdac_stream *hstr;
 -	bool saved = false;
  	int err;
  
  	azx_dev = azx_get_dsp_loader_dev(chip);
++<<<<<<< HEAD
 +
 +	dsp_lock(azx_dev);
 +	spin_lock_irq(&chip->reg_lock);
 +	if (azx_dev->running || azx_dev->locked) {
 +		spin_unlock_irq(&chip->reg_lock);
 +		err = -EBUSY;
 +		goto unlock;
 +	}
 +	azx_dev->prepared = 0;
 +	chip->saved_azx_dev = *azx_dev;
 +	azx_dev->locked = 1;
 +	spin_unlock_irq(&chip->reg_lock);
 +
 +	err = chip->ops->dma_alloc_pages(chip, SNDRV_DMA_TYPE_DEV_SG,
 +					 byte_size, bufp);
 +	if (err < 0)
 +		goto err_alloc;
++=======
+ 	hstr = azx_stream(azx_dev);
+ 	spin_lock_irq(&bus->reg_lock);
+ 	if (hstr->opened) {
+ 		chip->saved_azx_dev = *azx_dev;
+ 		saved = true;
+ 	}
+ 	spin_unlock_irq(&bus->reg_lock);
+ 
+ 	err = snd_hdac_dsp_prepare(hstr, format, byte_size, bufp);
+ 	if (err < 0) {
+ 		spin_lock_irq(&bus->reg_lock);
+ 		if (saved)
+ 			*azx_dev = chip->saved_azx_dev;
+ 		spin_unlock_irq(&bus->reg_lock);
+ 		return err;
+ 	}
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  
 -	azx_dev->prepared = 0;
 +	azx_dev->bufsize = byte_size;
 +	azx_dev->period_bytes = byte_size;
 +	azx_dev->format_val = format;
 +
 +	azx_stream_reset(chip, azx_dev);
 +
 +	/* reset BDL address */
 +	azx_sd_writel(chip, azx_dev, SD_BDLPL, 0);
 +	azx_sd_writel(chip, azx_dev, SD_BDLPU, 0);
 +
 +	azx_dev->frags = 0;
 +	bdl = (u32 *)azx_dev->bdl.area;
 +	err = setup_bdle(chip, bufp, azx_dev, &bdl, 0, byte_size, 0);
 +	if (err < 0)
 +		goto error;
 +
 +	azx_setup_controller(chip, azx_dev);
 +	dsp_unlock(azx_dev);
 +	return azx_dev->stream_tag;
 +
 + error:
 +	chip->ops->dma_free_pages(chip, bufp);
 + err_alloc:
 +	spin_lock_irq(&chip->reg_lock);
 +	if (azx_dev->opened)
 +		*azx_dev = chip->saved_azx_dev;
 +	azx_dev->locked = 0;
 +	spin_unlock_irq(&chip->reg_lock);
 + unlock:
 +	dsp_unlock(azx_dev);
  	return err;
  }
  
- static void azx_load_dsp_trigger(struct hda_bus *bus, bool start)
+ static void azx_load_dsp_trigger(struct hda_bus *_bus, bool start)
  {
- 	struct azx *chip = bus->private_data;
+ 	struct hdac_bus *bus = &_bus->core;
+ 	struct azx *chip = bus_to_azx(bus);
  	struct azx_dev *azx_dev = azx_get_dsp_loader_dev(chip);
  
 -	snd_hdac_dsp_trigger(azx_stream(azx_dev), start);
 +	if (start)
 +		azx_stream_start(chip, azx_dev);
 +	else
 +		azx_stream_stop(chip, azx_dev);
 +	azx_dev->running = start;
  }
  
- static void azx_load_dsp_cleanup(struct hda_bus *bus,
+ static void azx_load_dsp_cleanup(struct hda_bus *_bus,
  				 struct snd_dma_buffer *dmab)
  {
- 	struct azx *chip = bus->private_data;
+ 	struct hdac_bus *bus = &_bus->core;
+ 	struct azx *chip = bus_to_azx(bus);
  	struct azx_dev *azx_dev = azx_get_dsp_loader_dev(chip);
 -	struct hdac_stream *hstr = azx_stream(azx_dev);
  
 -	if (!dmab->area || !azx_dev->core.locked)
 +	if (!dmab->area || !azx_dev->locked)
  		return;
  
++<<<<<<< HEAD
 +	dsp_lock(azx_dev);
 +	/* reset BDL address */
 +	azx_sd_writel(chip, azx_dev, SD_BDLPL, 0);
 +	azx_sd_writel(chip, azx_dev, SD_BDLPU, 0);
 +	azx_sd_writel(chip, azx_dev, SD_CTL, 0);
 +	azx_dev->bufsize = 0;
 +	azx_dev->period_bytes = 0;
 +	azx_dev->format_val = 0;
 +
 +	chip->ops->dma_free_pages(chip, dmab);
 +	dmab->area = NULL;
 +
 +	spin_lock_irq(&chip->reg_lock);
 +	if (azx_dev->opened)
 +		*azx_dev = chip->saved_azx_dev;
 +	azx_dev->locked = 0;
 +	spin_unlock_irq(&chip->reg_lock);
 +	dsp_unlock(azx_dev);
 +}
 +#endif /* CONFIG_SND_HDA_DSP_LOADER */
 +
 +int azx_alloc_stream_pages(struct azx *chip)
 +{
 +	int i, err;
 +
 +	for (i = 0; i < chip->num_streams; i++) {
 +		dsp_lock_init(&chip->azx_dev[i]);
 +		/* allocate memory for the BDL for each stream */
 +		err = chip->ops->dma_alloc_pages(chip, SNDRV_DMA_TYPE_DEV,
 +						 BDL_SIZE,
 +						 &chip->azx_dev[i].bdl);
 +		if (err < 0)
 +			return -ENOMEM;
 +	}
 +	/* allocate memory for the position buffer */
 +	err = chip->ops->dma_alloc_pages(chip, SNDRV_DMA_TYPE_DEV,
 +					 chip->num_streams * 8, &chip->posbuf);
 +	if (err < 0)
 +		return -ENOMEM;
 +
 +	/* allocate CORB/RIRB */
 +	err = azx_alloc_cmd_io(chip);
 +	if (err < 0)
 +		return err;
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(azx_alloc_stream_pages);
 +
 +void azx_free_stream_pages(struct azx *chip)
 +{
 +	int i;
 +	if (chip->azx_dev) {
 +		for (i = 0; i < chip->num_streams; i++)
 +			if (chip->azx_dev[i].bdl.area)
 +				chip->ops->dma_free_pages(
 +					chip, &chip->azx_dev[i].bdl);
 +	}
 +	if (chip->rb.area)
 +		chip->ops->dma_free_pages(chip, &chip->rb);
 +	if (chip->posbuf.area)
 +		chip->ops->dma_free_pages(chip, &chip->posbuf);
 +}
 +EXPORT_SYMBOL_GPL(azx_free_stream_pages);
 +
 +/*
 + * Lowlevel interface
 + */
 +
 +/* enter link reset */
 +void azx_enter_link_reset(struct azx *chip)
 +{
 +	unsigned long timeout;
 +
 +	/* reset controller */
 +	azx_writel(chip, GCTL, azx_readl(chip, GCTL) & ~AZX_GCTL_RESET);
 +
 +	timeout = jiffies + msecs_to_jiffies(100);
 +	while ((azx_readb(chip, GCTL) & AZX_GCTL_RESET) &&
 +			time_before(jiffies, timeout))
 +		usleep_range(500, 1000);
 +}
 +EXPORT_SYMBOL_GPL(azx_enter_link_reset);
 +
 +/* exit link reset */
 +static void azx_exit_link_reset(struct azx *chip)
 +{
 +	unsigned long timeout;
 +
 +	azx_writeb(chip, GCTL, azx_readb(chip, GCTL) | AZX_GCTL_RESET);
 +
 +	timeout = jiffies + msecs_to_jiffies(100);
 +	while (!azx_readb(chip, GCTL) &&
 +			time_before(jiffies, timeout))
 +		usleep_range(500, 1000);
 +}
 +
 +/* reset codec link */
 +static int azx_reset(struct azx *chip, bool full_reset)
 +{
 +	if (!full_reset)
 +		goto __skip;
 +
 +	/* clear STATESTS */
 +	azx_writew(chip, STATESTS, STATESTS_INT_MASK);
 +
 +	/* reset controller */
 +	azx_enter_link_reset(chip);
 +
 +	/* delay for >= 100us for codec PLL to settle per spec
 +	 * Rev 0.9 section 5.5.1
 +	 */
 +	usleep_range(500, 1000);
 +
 +	/* Bring controller out of reset */
 +	azx_exit_link_reset(chip);
 +
 +	/* Brent Chartrand said to wait >= 540us for codecs to initialize */
 +	usleep_range(1000, 1200);
 +
 +      __skip:
 +	/* check to see if controller is ready */
 +	if (!azx_readb(chip, GCTL)) {
 +		dev_dbg(chip->card->dev, "azx_reset: controller not ready!\n");
 +		return -EBUSY;
 +	}
 +
 +	/* Accept unsolicited responses */
 +	if (!chip->single_cmd)
 +		azx_writel(chip, GCTL, azx_readl(chip, GCTL) |
 +			   AZX_GCTL_UNSOL);
 +
 +	/* detect codecs */
 +	if (!chip->codec_mask) {
 +		chip->codec_mask = azx_readw(chip, STATESTS);
 +		dev_dbg(chip->card->dev, "codec_mask = 0x%x\n",
 +			chip->codec_mask);
 +	}
 +
 +	return 0;
 +}
 +
 +/* enable interrupts */
 +static void azx_int_enable(struct azx *chip)
 +{
 +	/* enable controller CIE and GIE */
 +	azx_writel(chip, INTCTL, azx_readl(chip, INTCTL) |
 +		   AZX_INT_CTRL_EN | AZX_INT_GLOBAL_EN);
 +}
 +
 +/* disable interrupts */
 +static void azx_int_disable(struct azx *chip)
 +{
 +	int i;
 +
 +	/* disable interrupts in stream descriptor */
 +	for (i = 0; i < chip->num_streams; i++) {
 +		struct azx_dev *azx_dev = &chip->azx_dev[i];
 +		azx_sd_writeb(chip, azx_dev, SD_CTL,
 +			      azx_sd_readb(chip, azx_dev, SD_CTL) &
 +					~SD_INT_MASK);
 +	}
 +
 +	/* disable SIE for all streams */
 +	azx_writeb(chip, INTCTL, 0);
 +
 +	/* disable controller CIE and GIE */
 +	azx_writel(chip, INTCTL, azx_readl(chip, INTCTL) &
 +		   ~(AZX_INT_CTRL_EN | AZX_INT_GLOBAL_EN));
 +}
 +
 +/* clear interrupts */
 +static void azx_int_clear(struct azx *chip)
 +{
 +	int i;
 +
 +	/* clear stream status */
 +	for (i = 0; i < chip->num_streams; i++) {
 +		struct azx_dev *azx_dev = &chip->azx_dev[i];
 +		azx_sd_writeb(chip, azx_dev, SD_STS, SD_INT_MASK);
 +	}
 +
 +	/* clear STATESTS */
 +	azx_writew(chip, STATESTS, STATESTS_INT_MASK);
 +
 +	/* clear rirb status */
 +	azx_writeb(chip, RIRBSTS, RIRB_INT_MASK);
 +
 +	/* clear int status */
 +	azx_writel(chip, INTSTS, AZX_INT_CTRL_EN | AZX_INT_ALL_STREAM);
 +}
 +
++=======
+ 	snd_hdac_dsp_cleanup(hstr, dmab);
+ 	spin_lock_irq(&bus->reg_lock);
+ 	if (hstr->opened)
+ 		*azx_dev = chip->saved_azx_dev;
+ 	hstr->locked = false;
+ 	spin_unlock_irq(&bus->reg_lock);
+ }
+ #endif /* CONFIG_SND_HDA_DSP_LOADER */
+ 
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  /*
   * reset and start the controller registers
   */
@@@ -1662,29 -880,39 +1693,32 @@@ void azx_init_chip(struct azx *chip, bo
  }
  EXPORT_SYMBOL_GPL(azx_init_chip);
  
 -void azx_stop_all_streams(struct azx *chip)
 -{
 -	struct hdac_bus *bus = azx_bus(chip);
 -	struct hdac_stream *s;
 -
 -	list_for_each_entry(s, &bus->stream_list, list)
 -		snd_hdac_stream_stop(s);
 -}
 -EXPORT_SYMBOL_GPL(azx_stop_all_streams);
 -
  void azx_stop_chip(struct azx *chip)
  {
- 	if (!chip->initialized)
- 		return;
- 
- 	/* disable interrupts */
- 	azx_int_disable(chip);
- 	azx_int_clear(chip);
- 
- 	/* disable CORB/RIRB */
- 	azx_free_cmd_io(chip);
- 
- 	/* disable position buffer */
- 	azx_writel(chip, DPLBASE, 0);
- 	azx_writel(chip, DPUBASE, 0);
- 
- 	chip->initialized = 0;
+ 	snd_hdac_bus_stop_chip(azx_bus(chip));
  }
  EXPORT_SYMBOL_GPL(azx_stop_chip);
  
  /*
   * interrupt handler
   */
++<<<<<<< HEAD
++=======
+ static void stream_update(struct hdac_bus *bus, struct hdac_stream *s)
+ {
+ 	struct azx *chip = bus_to_azx(bus);
+ 	struct azx_dev *azx_dev = stream_to_azx_dev(s);
+ 
+ 	/* check whether this IRQ is really acceptable */
+ 	if (!chip->ops->position_check ||
+ 	    chip->ops->position_check(chip, azx_dev)) {
+ 		spin_unlock(&bus->reg_lock);
+ 		snd_pcm_period_elapsed(azx_stream(azx_dev)->substream);
+ 		spin_lock(&bus->reg_lock);
+ 	}
+ }
+ 
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  irqreturn_t azx_interrupt(int irq, void *dev_id)
  {
  	struct azx *chip = dev_id;
@@@ -1758,15 -968,17 +1792,21 @@@ static int probe_codec(struct azx *chip
  {
  	unsigned int cmd = (addr << 28) | (AC_NODE_ROOT << 20) |
  		(AC_VERB_PARAMETERS << 8) | AC_PAR_VENDOR_ID;
++<<<<<<< HEAD
 +	unsigned int res;
++=======
+ 	struct hdac_bus *bus = azx_bus(chip);
+ 	int err;
+ 	unsigned int res = -1;
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  
 -	mutex_lock(&bus->cmd_mutex);
 +	mutex_lock(&chip->bus->cmd_mutex);
  	chip->probing = 1;
 -	azx_send_cmd(bus, cmd);
 -	err = azx_get_response(bus, addr, &res);
 +	azx_send_cmd(chip->bus, cmd);
 +	res = azx_get_response(chip->bus, addr);
  	chip->probing = 0;
 -	mutex_unlock(&bus->cmd_mutex);
 -	if (err < 0 || res == -1)
 +	mutex_unlock(&chip->bus->cmd_mutex);
 +	if (res == -1)
  		return -EIO;
  	dev_dbg(chip->card->dev, "codec #%d probed OK\n", addr);
  	return 0;
@@@ -1837,12 -1028,14 +1877,22 @@@ static struct hda_bus_ops bus_ops = 
  };
  
  /* HD-audio bus initialization */
++<<<<<<< HEAD
 +int azx_bus_create(struct azx *chip, const char *model, int *power_save_to)
++=======
+ int azx_bus_init(struct azx *chip, const char *model,
+ 		 const struct hdac_io_ops *io_ops)
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  {
- 	struct hda_bus *bus;
+ 	struct hda_bus *bus = &chip->bus;
  	int err;
  
++<<<<<<< HEAD
 +	err = snd_hda_bus_new(chip->card, &bus);
++=======
+ 	err = snd_hdac_bus_init(&bus->core, chip->card->dev, &bus_core_ops,
+ 				io_ops);
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  	if (err < 0)
  		return err;
  
@@@ -1851,9 -1044,14 +1901,20 @@@
  	bus->pci = chip->pci;
  	bus->modelname = model;
  	bus->ops = bus_ops;
++<<<<<<< HEAD
 +#ifdef CONFIG_PM
 +	bus->power_save = power_save_to;
 +#endif
++=======
+ 	bus->core.snoop = azx_snoop(chip);
+ 	if (chip->get_position[0] != azx_get_pos_lpib ||
+ 	    chip->get_position[1] != azx_get_pos_lpib)
+ 		bus->core.use_posbuf = true;
+ 	if (chip->bdl_pos_adj)
+ 		bus->core.bdl_pos_adj = chip->bdl_pos_adj[chip->dev_index];
+ 	if (chip->driver_caps & AZX_DCAPS_CORBRP_SELF_CLEAR)
+ 		bus->core.corbrp_self_clear = true;
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  
  	if (chip->driver_caps & AZX_DCAPS_RIRB_DELAY) {
  		dev_dbg(chip->card->dev, "Enable delay in RIRB handling\n");
@@@ -1931,7 -1129,7 +1992,11 @@@ EXPORT_SYMBOL_GPL(azx_probe_codecs)
  int azx_codec_configure(struct azx *chip)
  {
  	struct hda_codec *codec;
++<<<<<<< HEAD
 +	list_for_each_entry(codec, &chip->bus->codec_list, list) {
++=======
+ 	list_for_each_codec(codec, &chip->bus) {
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  		snd_hda_codec_configure(codec);
  	}
  	return 0;
@@@ -1946,11 -1145,10 +2011,11 @@@ static bool is_input_stream(struct azx 
  }
  
  /* initialize SD streams */
- int azx_init_stream(struct azx *chip)
+ int azx_init_streams(struct azx *chip)
  {
  	int i;
 -	int stream_tags[2] = { 0, 0 };
 +	int in_stream_tag = 0;
 +	int out_stream_tag = 0;
  
  	/* initialize each stream (aka device)
  	 * assign the starting bdl address to each stream (device)
@@@ -1982,32 -1178,17 +2047,49 @@@
  
  	return 0;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL_GPL(azx_init_stream);
 +
 +/*
 + * reboot notifier for hang-up problem at power-down
 + */
 +static int azx_halt(struct notifier_block *nb, unsigned long event, void *buf)
 +{
 +	struct azx *chip = container_of(nb, struct azx, reboot_notifier);
 +	snd_hda_bus_reboot_notify(chip->bus);
 +	azx_stop_chip(chip);
 +	return NOTIFY_OK;
 +}
 +
 +void azx_notifier_register(struct azx *chip)
 +{
 +	chip->reboot_notifier.notifier_call = azx_halt;
 +	register_reboot_notifier(&chip->reboot_notifier);
 +}
 +EXPORT_SYMBOL_GPL(azx_notifier_register);
 +
 +void azx_notifier_unregister(struct azx *chip)
 +{
 +	if (chip->reboot_notifier.notifier_call)
 +		unregister_reboot_notifier(&chip->reboot_notifier);
 +}
 +EXPORT_SYMBOL_GPL(azx_notifier_unregister);
 +
 +MODULE_LICENSE("GPL");
 +MODULE_DESCRIPTION("Common HDA driver functions");
++=======
+ EXPORT_SYMBOL_GPL(azx_init_streams);
+ 
+ void azx_free_streams(struct azx *chip)
+ {
+ 	struct hdac_bus *bus = azx_bus(chip);
+ 	struct hdac_stream *s;
+ 
+ 	while (!list_empty(&bus->stream_list)) {
+ 		s = list_first_entry(&bus->stream_list, struct hdac_stream, list);
+ 		list_del(&s->list);
+ 		kfree(stream_to_azx_dev(s));
+ 	}
+ }
+ EXPORT_SYMBOL_GPL(azx_free_streams);
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
diff --cc sound/pci/hda/hda_controller.h
index 2993061145a5,e8edb02c12d3..000000000000
--- a/sound/pci/hda/hda_controller.h
+++ b/sound/pci/hda/hda_controller.h
@@@ -15,10 -15,191 +15,192 @@@
  #ifndef __SOUND_HDA_CONTROLLER_H
  #define __SOUND_HDA_CONTROLLER_H
  
 -#include <linux/timecounter.h>
 -#include <linux/interrupt.h>
  #include <sound/core.h>
 -#include <sound/pcm.h>
  #include <sound/initval.h>
  #include "hda_codec.h"
++<<<<<<< HEAD
 +#include "hda_priv.h"
++=======
+ #include <sound/hda_register.h>
+ 
+ #define AZX_MAX_CODECS		HDA_MAX_CODECS
+ #define AZX_DEFAULT_CODECS	4
+ 
+ /* driver quirks (capabilities) */
+ /* bits 0-7 are used for indicating driver type */
+ #define AZX_DCAPS_NO_TCSEL	(1 << 8)	/* No Intel TCSEL bit */
+ #define AZX_DCAPS_NO_MSI	(1 << 9)	/* No MSI support */
+ #define AZX_DCAPS_SNOOP_MASK	(3 << 10)	/* snoop type mask */
+ #define AZX_DCAPS_SNOOP_OFF	(1 << 12)	/* snoop default off */
+ #define AZX_DCAPS_RIRB_DELAY	(1 << 13)	/* Long delay in read loop */
+ #define AZX_DCAPS_RIRB_PRE_DELAY (1 << 14)	/* Put a delay before read */
+ #define AZX_DCAPS_CTX_WORKAROUND (1 << 15)	/* X-Fi workaround */
+ #define AZX_DCAPS_POSFIX_LPIB	(1 << 16)	/* Use LPIB as default */
+ #define AZX_DCAPS_POSFIX_VIA	(1 << 17)	/* Use VIACOMBO as default */
+ #define AZX_DCAPS_NO_64BIT	(1 << 18)	/* No 64bit address */
+ #define AZX_DCAPS_SYNC_WRITE	(1 << 19)	/* sync each cmd write */
+ #define AZX_DCAPS_OLD_SSYNC	(1 << 20)	/* Old SSYNC reg for ICH */
+ #define AZX_DCAPS_NO_ALIGN_BUFSIZE (1 << 21)	/* no buffer size alignment */
+ /* 22 unused */
+ #define AZX_DCAPS_4K_BDLE_BOUNDARY (1 << 23)	/* BDLE in 4k boundary */
+ #define AZX_DCAPS_REVERSE_ASSIGN (1 << 24)	/* Assign devices in reverse order */
+ #define AZX_DCAPS_COUNT_LPIB_DELAY  (1 << 25)	/* Take LPIB as delay */
+ #define AZX_DCAPS_PM_RUNTIME	(1 << 26)	/* runtime PM support */
+ #define AZX_DCAPS_I915_POWERWELL (1 << 27)	/* HSW i915 powerwell support */
+ #define AZX_DCAPS_CORBRP_SELF_CLEAR (1 << 28)	/* CORBRP clears itself after reset */
+ #define AZX_DCAPS_NO_MSI64      (1 << 29)	/* Stick to 32-bit MSIs */
+ #define AZX_DCAPS_SEPARATE_STREAM_TAG	(1 << 30) /* capture and playback use separate stream tag */
+ 
+ enum {
+ 	AZX_SNOOP_TYPE_NONE,
+ 	AZX_SNOOP_TYPE_SCH,
+ 	AZX_SNOOP_TYPE_ATI,
+ 	AZX_SNOOP_TYPE_NVIDIA,
+ };
+ 
+ struct azx_dev {
+ 	struct hdac_stream core;
+ 
+ 	unsigned int irq_pending:1;
+ 	unsigned int prepared:1;
+ 	/*
+ 	 * For VIA:
+ 	 *  A flag to ensure DMA position is 0
+ 	 *  when link position is not greater than FIFO size
+ 	 */
+ 	unsigned int insufficient:1;
+ 	unsigned int wc_marked:1;
+ };
+ 
+ #define azx_stream(dev)		(&(dev)->core)
+ #define stream_to_azx_dev(s)	container_of(s, struct azx_dev, core)
+ 
+ struct azx;
+ 
+ /* Functions to read/write to hda registers. */
+ struct hda_controller_ops {
+ 	/* Disable msi if supported, PCI only */
+ 	int (*disable_msi_reset_irq)(struct azx *);
+ 	int (*substream_alloc_pages)(struct azx *chip,
+ 				     struct snd_pcm_substream *substream,
+ 				     size_t size);
+ 	int (*substream_free_pages)(struct azx *chip,
+ 				    struct snd_pcm_substream *substream);
+ 	void (*pcm_mmap_prepare)(struct snd_pcm_substream *substream,
+ 				 struct vm_area_struct *area);
+ 	/* Check if current position is acceptable */
+ 	int (*position_check)(struct azx *chip, struct azx_dev *azx_dev);
+ };
+ 
+ struct azx_pcm {
+ 	struct azx *chip;
+ 	struct snd_pcm *pcm;
+ 	struct hda_codec *codec;
+ 	struct hda_pcm *info;
+ 	struct list_head list;
+ };
+ 
+ typedef unsigned int (*azx_get_pos_callback_t)(struct azx *, struct azx_dev *);
+ typedef int (*azx_get_delay_callback_t)(struct azx *, struct azx_dev *, unsigned int pos);
+ 
+ struct azx {
+ 	struct hda_bus bus;
+ 
+ 	struct snd_card *card;
+ 	struct pci_dev *pci;
+ 	int dev_index;
+ 
+ 	/* chip type specific */
+ 	int driver_type;
+ 	unsigned int driver_caps;
+ 	int playback_streams;
+ 	int playback_index_offset;
+ 	int capture_streams;
+ 	int capture_index_offset;
+ 	int num_streams;
+ 	const int *jackpoll_ms; /* per-card jack poll interval */
+ 
+ 	/* Register interaction. */
+ 	const struct hda_controller_ops *ops;
+ 
+ 	/* position adjustment callbacks */
+ 	azx_get_pos_callback_t get_position[2];
+ 	azx_get_delay_callback_t get_delay[2];
+ 
+ 	/* locks */
+ 	struct mutex open_mutex; /* Prevents concurrent open/close operations */
+ 
+ 	/* PCM */
+ 	struct list_head pcm_list; /* azx_pcm list */
+ 
+ 	/* HD codec */
+ 	int  codec_probe_mask; /* copied from probe_mask option */
+ 	unsigned int beep_mode;
+ 
+ #ifdef CONFIG_SND_HDA_PATCH_LOADER
+ 	const struct firmware *fw;
+ #endif
+ 
+ 	/* flags */
+ 	const int *bdl_pos_adj;
+ 	int poll_count;
+ 	unsigned int running:1;
+ 	unsigned int single_cmd:1;
+ 	unsigned int polling_mode:1;
+ 	unsigned int msi:1;
+ 	unsigned int probing:1; /* codec probing phase */
+ 	unsigned int snoop:1;
+ 	unsigned int align_buffer_size:1;
+ 	unsigned int region_requested:1;
+ 	unsigned int disabled:1; /* disabled by VGA-switcher */
+ 
+ #ifdef CONFIG_SND_HDA_DSP_LOADER
+ 	struct azx_dev saved_azx_dev;
+ #endif
+ };
+ 
+ #define azx_bus(chip)	(&(chip)->bus.core)
+ #define bus_to_azx(_bus)	container_of(_bus, struct azx, bus.core)
+ 
+ #ifdef CONFIG_X86
+ #define azx_snoop(chip)		((chip)->snoop)
+ #else
+ #define azx_snoop(chip)		true
+ #endif
+ 
+ /*
+  * macros for easy use
+  */
+ 
+ #define azx_writel(chip, reg, value) \
+ 	snd_hdac_chip_writel(azx_bus(chip), reg, value)
+ #define azx_readl(chip, reg) \
+ 	snd_hdac_chip_readl(azx_bus(chip), reg)
+ #define azx_writew(chip, reg, value) \
+ 	snd_hdac_chip_writew(azx_bus(chip), reg, value)
+ #define azx_readw(chip, reg) \
+ 	snd_hdac_chip_readw(azx_bus(chip), reg)
+ #define azx_writeb(chip, reg, value) \
+ 	snd_hdac_chip_writeb(azx_bus(chip), reg, value)
+ #define azx_readb(chip, reg) \
+ 	snd_hdac_chip_readb(azx_bus(chip), reg)
+ 
+ #define azx_sd_writel(chip, dev, reg, value) \
+ 	snd_hdac_stream_writel(&(dev)->core, reg, value)
+ #define azx_sd_readl(chip, dev, reg) \
+ 	snd_hdac_stream_readl(&(dev)->core, reg)
+ #define azx_sd_writew(chip, dev, reg, value) \
+ 	snd_hdac_stream_writew(&(dev)->core, reg, value)
+ #define azx_sd_readw(chip, dev, reg) \
+ 	snd_hdac_stream_readw(&(dev)->core, reg)
+ #define azx_sd_writeb(chip, dev, reg, value) \
+ 	snd_hdac_stream_writeb(&(dev)->core, reg, value)
+ #define azx_sd_readb(chip, dev, reg) \
+ 	snd_hdac_stream_readb(&(dev)->core, reg)
+ 
+ #define azx_has_pm_runtime(chip) \
+ 	(!AZX_DCAPS_PM_RUNTIME || ((chip)->driver_caps & AZX_DCAPS_PM_RUNTIME))
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  
  /* PCM setup */
  static inline struct azx_dev *get_azx_dev(struct snd_pcm_substream *substream)
@@@ -30,11 -211,13 +212,13 @@@ unsigned int azx_get_pos_lpib(struct az
  unsigned int azx_get_pos_posbuf(struct azx *chip, struct azx_dev *azx_dev);
  
  /* Stream control. */
 -void azx_stop_all_streams(struct azx *chip);
 +void azx_stream_stop(struct azx *chip, struct azx_dev *azx_dev);
  
  /* Allocation functions. */
- int azx_alloc_stream_pages(struct azx *chip);
- void azx_free_stream_pages(struct azx *chip);
+ #define azx_alloc_stream_pages(chip) \
+ 	snd_hdac_bus_alloc_stream_pages(azx_bus(chip))
+ #define azx_free_stream_pages(chip) \
+ 	snd_hdac_bus_free_stream_pages(azx_bus(chip))
  
  /* Low level azx interface */
  void azx_init_chip(struct azx *chip, bool full_reset);
@@@ -43,12 -227,11 +228,18 @@@ void azx_stop_chip(struct azx *chip)
  irqreturn_t azx_interrupt(int irq, void *dev_id);
  
  /* Codec interface */
++<<<<<<< HEAD
 +int azx_bus_create(struct azx *chip, const char *model, int *power_save_to);
++=======
+ int azx_bus_init(struct azx *chip, const char *model,
+ 		 const struct hdac_io_ops *io_ops);
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  int azx_probe_codecs(struct azx *chip, unsigned int max_slots);
  int azx_codec_configure(struct azx *chip);
- int azx_init_stream(struct azx *chip);
+ int azx_init_streams(struct azx *chip);
+ void azx_free_streams(struct azx *chip);
  
 +void azx_notifier_register(struct azx *chip);
 +void azx_notifier_unregister(struct azx *chip);
 +
  #endif /* __SOUND_HDA_CONTROLLER_H */
diff --cc sound/pci/hda/hda_intel.c
index 8224bf75d072,9dff693005ea..000000000000
--- a/sound/pci/hda/hda_intel.c
+++ b/sound/pci/hda/hda_intel.c
@@@ -614,19 -614,19 +614,31 @@@ static void azx_irq_pending_work(struc
  
  	for (;;) {
  		pending = 0;
++<<<<<<< HEAD
 +		spin_lock_irq(&chip->reg_lock);
 +		for (i = 0; i < chip->num_streams; i++) {
 +			struct azx_dev *azx_dev = &chip->azx_dev[i];
++=======
+ 		spin_lock_irq(&bus->reg_lock);
+ 		list_for_each_entry(s, &bus->stream_list, list) {
+ 			struct azx_dev *azx_dev = stream_to_azx_dev(s);
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  			if (!azx_dev->irq_pending ||
 -			    !s->substream ||
 -			    !s->running)
 +			    !azx_dev->substream ||
 +			    !azx_dev->running)
  				continue;
  			ok = azx_position_ok(chip, azx_dev);
  			if (ok > 0) {
  				azx_dev->irq_pending = 0;
++<<<<<<< HEAD
 +				spin_unlock(&chip->reg_lock);
 +				snd_pcm_period_elapsed(azx_dev->substream);
 +				spin_lock(&chip->reg_lock);
++=======
+ 				spin_unlock(&bus->reg_lock);
+ 				snd_pcm_period_elapsed(s->substream);
+ 				spin_lock(&bus->reg_lock);
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  			} else if (ok < 0) {
  				pending = 0;	/* too early */
  			} else
@@@ -642,12 -642,15 +654,21 @@@
  /* clear irq_pending flags and assure no on-going workq */
  static void azx_clear_irq_pending(struct azx *chip)
  {
 -	struct hdac_bus *bus = azx_bus(chip);
 -	struct hdac_stream *s;
 -
 +	int i;
 +
++<<<<<<< HEAD
 +	spin_lock_irq(&chip->reg_lock);
 +	for (i = 0; i < chip->num_streams; i++)
 +		chip->azx_dev[i].irq_pending = 0;
 +	spin_unlock_irq(&chip->reg_lock);
++=======
+ 	spin_lock_irq(&bus->reg_lock);
+ 	list_for_each_entry(s, &bus->stream_list, list) {
+ 		struct azx_dev *azx_dev = stream_to_azx_dev(s);
+ 		azx_dev->irq_pending = 0;
+ 	}
+ 	spin_unlock_irq(&bus->reg_lock);
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  }
  
  static int azx_acquire_irq(struct azx *chip, int do_disconnect)
@@@ -758,10 -763,9 +782,14 @@@ static int param_set_xint(const char *v
  	mutex_lock(&card_list_lock);
  	list_for_each_entry(hda, &card_list, list) {
  		chip = &hda->chip;
- 		if (!chip->bus || chip->disabled)
+ 		if (!hda->probe_continued || chip->disabled)
  			continue;
++<<<<<<< HEAD
 +		list_for_each_entry(c, &chip->bus->codec_list, list)
 +			snd_hda_power_sync(c);
++=======
+ 		snd_hda_set_power_save(&chip->bus, power_save * 1000);
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  	}
  	mutex_unlock(&card_list_lock);
  	return 0;
@@@ -900,9 -905,8 +929,14 @@@ static int azx_runtime_resume(struct de
  	azx_init_pci(chip);
  	azx_init_chip(chip, true);
  
++<<<<<<< HEAD
 +	bus = chip->bus;
 +	if (status && bus) {
 +		list_for_each_entry(codec, &bus->codec_list, list)
++=======
+ 	if (status) {
+ 		list_for_each_codec(codec, &chip->bus)
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  			if (status & (1 << codec->addr))
  				schedule_delayed_work(&codec->jackpoll_work,
  						      codec->jackpoll_interval);
@@@ -929,8 -933,8 +963,13 @@@ static int azx_runtime_idle(struct devi
  	if (chip->disabled || hda->init_failed)
  		return 0;
  
++<<<<<<< HEAD
 +	if (!power_save_controller ||
 +	    !(chip->driver_caps & AZX_DCAPS_PM_RUNTIME))
++=======
+ 	if (!power_save_controller || !azx_has_pm_runtime(chip) ||
+ 	    azx_bus(chip)->codec_powered)
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  		return -EBUSY;
  
  	return 0;
@@@ -1073,10 -1074,9 +1112,14 @@@ static int azx_free(struct azx *chip
  {
  	struct pci_dev *pci = chip->pci;
  	struct hda_intel *hda = container_of(chip, struct hda_intel, chip);
++<<<<<<< HEAD
 +	int i;
++=======
+ 	struct hdac_bus *bus = azx_bus(chip);
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  
 -	if (azx_has_pm_runtime(chip) && chip->running)
 +	if ((chip->driver_caps & AZX_DCAPS_PM_RUNTIME)
 +			&& chip->running)
  		pm_runtime_get_noresume(&pci->dev);
  
  	azx_del_card_list(chip);
@@@ -1093,25 -1091,26 +1136,34 @@@
  			vga_switcheroo_unregister_client(chip->pci);
  	}
  
- 	if (chip->initialized) {
+ 	if (bus->chip_init) {
  		azx_clear_irq_pending(chip);
 -		azx_stop_all_streams(chip);
 +		for (i = 0; i < chip->num_streams; i++)
 +			azx_stream_stop(chip, &chip->azx_dev[i]);
  		azx_stop_chip(chip);
  	}
  
++<<<<<<< HEAD
 +	pci->dev.power.ignore_children = 0; /* FIXME */
 +	if (chip->irq >= 0)
 +		free_irq(chip->irq, (void*)chip);
++=======
+ 	if (bus->irq >= 0)
+ 		free_irq(bus->irq, (void*)chip);
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  	if (chip->msi)
  		pci_disable_msi(chip->pci);
- 	iounmap(chip->remap_addr);
+ 	iounmap(bus->remap_addr);
  
  	azx_free_stream_pages(chip);
+ 	azx_free_streams(chip);
+ 	snd_hdac_bus_exit(bus);
+ 
  	if (chip->region_requested)
  		pci_release_regions(chip->pci);
+ 
  	pci_disable_device(chip->pci);
 +	kfree(chip->azx_dev);
  #ifdef CONFIG_SND_HDA_PATCH_LOADER
  	release_firmware(chip->fw);
  #endif
@@@ -1407,9 -1417,7 +1468,12 @@@ static int azx_create(struct snd_card *
  	mutex_init(&chip->open_mutex);
  	chip->card = card;
  	chip->pci = pci;
++<<<<<<< HEAD
 +	chip->ops = hda_ops;
 +	chip->irq = -1;
++=======
+ 	chip->ops = &pci_hda_ops;
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  	chip->driver_caps = driver_caps;
  	chip->driver_type = driver_caps & 0xff;
  	check_msi(chip);
@@@ -1577,12 -1593,9 +1649,13 @@@ static int azx_first_init(struct azx *c
  	chip->capture_index_offset = 0;
  	chip->playback_index_offset = chip->capture_streams;
  	chip->num_streams = chip->playback_streams + chip->capture_streams;
 +	chip->azx_dev = kcalloc(chip->num_streams, sizeof(*chip->azx_dev),
 +				GFP_KERNEL);
 +	if (!chip->azx_dev)
 +		return -ENOMEM;
  
- 	err = azx_alloc_stream_pages(chip);
+ 	/* initialize streams */
+ 	err = azx_init_streams(chip);
  	if (err < 0)
  		return err;
  
@@@ -1713,6 -1715,7 +1788,10 @@@ static int dma_alloc_pages(struct azx *
  			   size_t size,
  			   struct snd_dma_buffer *buf)
  {
++<<<<<<< HEAD
++=======
+ 	struct azx *chip = bus_to_azx(bus);
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  	int err;
  
  	err = snd_dma_alloc_pages(type,
@@@ -1724,8 -1727,10 +1803,13 @@@
  	return 0;
  }
  
 -static void dma_free_pages(struct hdac_bus *bus, struct snd_dma_buffer *buf)
 +static void dma_free_pages(struct azx *chip, struct snd_dma_buffer *buf)
  {
++<<<<<<< HEAD
++=======
+ 	struct azx *chip = bus_to_azx(bus);
+ 
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  	mark_pages_wc(chip, buf, false);
  	snd_dma_free_pages(buf);
  }
@@@ -1930,10 -1933,9 +2015,15 @@@ static int azx_probe_continue(struct az
  		goto out_free;
  
  	chip->running = 1;
 +	power_down_all_codecs(chip);
 +	azx_notifier_register(chip);
  	azx_add_card_list(chip);
++<<<<<<< HEAD
 +	if ((chip->driver_caps & AZX_DCAPS_PM_RUNTIME) || hda->use_vga_switcheroo)
++=======
+ 	snd_hda_set_power_save(&chip->bus, power_save * 1000);
+ 	if (azx_has_pm_runtime(chip) || hda->use_vga_switcheroo)
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  		pm_runtime_put_noidle(&pci->dev);
  
  out_free:
diff --cc sound/pci/hda/hda_tegra.c
index 6c19abff991c,397e1821020f..000000000000
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@@ -288,14 -298,10 +296,19 @@@ static int hda_tegra_dev_disconnect(str
   */
  static int hda_tegra_dev_free(struct snd_device *device)
  {
 +	int i;
  	struct azx *chip = device->device_data;
  
++<<<<<<< HEAD
 +	azx_notifier_unregister(chip);
 +
 +	if (chip->initialized) {
 +		for (i = 0; i < chip->num_streams; i++)
 +			azx_stream_stop(chip, &chip->azx_dev[i]);
++=======
+ 	if (azx_bus(chip)->chip_init) {
+ 		azx_stop_all_streams(chip);
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  		azx_stop_chip(chip);
  	}
  
@@@ -326,8 -335,8 +342,13 @@@ static int hda_tegra_init_chip(struct a
  	if (IS_ERR(hda->regs))
  		return PTR_ERR(hda->regs);
  
++<<<<<<< HEAD
 +	chip->remap_addr = hda->regs + HDA_BAR0;
 +	chip->addr = res->start + HDA_BAR0;
++=======
+ 	bus->remap_addr = hda->regs + HDA_BAR0;
+ 	bus->addr = res->start + HDA_BAR0;
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  
  	err = hda_tegra_enable_clocks(hda);
  	if (err)
@@@ -338,19 -347,9 +359,20 @@@
  	return 0;
  }
  
 +/*
 + * The codecs were powered up in snd_hda_codec_new().
 + * Now all initialization done, so turn them down if possible
 + */
 +static void power_down_all_codecs(struct azx *chip)
 +{
 +	struct hda_codec *codec;
 +	list_for_each_entry(codec, &chip->bus->codec_list, list)
 +		snd_hda_power_down(codec);
 +}
 +
  static int hda_tegra_first_init(struct azx *chip, struct platform_device *pdev)
  {
+ 	struct hdac_bus *bus = azx_bus(chip);
  	struct snd_card *card = chip->card;
  	int err;
  	unsigned short gcap;
@@@ -388,12 -387,9 +410,13 @@@
  	chip->capture_index_offset = 0;
  	chip->playback_index_offset = chip->capture_streams;
  	chip->num_streams = chip->playback_streams + chip->capture_streams;
 +	chip->azx_dev = devm_kcalloc(card->dev, chip->num_streams,
 +				     sizeof(*chip->azx_dev), GFP_KERNEL);
 +	if (!chip->azx_dev)
 +		return -ENOMEM;
  
- 	err = azx_alloc_stream_pages(chip);
+ 	/* initialize streams */
+ 	err = azx_init_streams(chip);
  	if (err < 0)
  		return err;
  
@@@ -434,11 -431,9 +459,14 @@@ static int hda_tegra_create(struct snd_
  
  	chip = &hda->chip;
  
- 	spin_lock_init(&chip->reg_lock);
  	mutex_init(&chip->open_mutex);
  	chip->card = card;
++<<<<<<< HEAD
 +	chip->ops = hda_ops;
 +	chip->irq = -1;
++=======
+ 	chip->ops = &hda_tegra_ops;
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  	chip->driver_caps = driver_caps;
  	chip->driver_type = driver_caps & 0xff;
  	chip->dev_index = 0;
@@@ -485,7 -480,11 +513,15 @@@ static int hda_tegra_probe(struct platf
  		return err;
  	}
  
++<<<<<<< HEAD
 +	err = hda_tegra_create(card, driver_flags, &hda_tegra_ops, hda);
++=======
+ 	err = azx_bus_init(chip, NULL, &hda_tegra_io_ops);
+ 	if (err < 0)
+ 		goto out_free;
+ 
+ 	err = hda_tegra_create(card, driver_flags, hda);
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  	if (err < 0)
  		goto out_free;
  	card->private_data = chip;
@@@ -514,8 -509,7 +550,12 @@@
  		goto out_free;
  
  	chip->running = 1;
++<<<<<<< HEAD
 +	power_down_all_codecs(chip);
 +	azx_notifier_register(chip);
++=======
+ 	snd_hda_set_power_save(&chip->bus, power_save * 1000);
++>>>>>>> a41d122449be (ALSA: hda - Embed bus into controller object)
  
  	return 0;
  
* Unmerged path sound/pci/hda/hda_codec.c
* Unmerged path sound/pci/hda/hda_codec.h
* Unmerged path sound/pci/hda/hda_controller.c
* Unmerged path sound/pci/hda/hda_controller.h
* Unmerged path sound/pci/hda/hda_intel.c
diff --git a/sound/pci/hda/hda_intel.h b/sound/pci/hda/hda_intel.h
index 348611835476..ddf573be3650 100644
--- a/sound/pci/hda/hda_intel.h
+++ b/sound/pci/hda/hda_intel.h
@@ -34,6 +34,7 @@ struct hda_intel {
 
 	/* extra flags */
 	unsigned int irq_pending_warned:1;
+	unsigned int probe_continued:1;
 
 	/* VGA-switcheroo setup */
 	unsigned int use_vga_switcheroo:1;
* Unmerged path sound/pci/hda/hda_tegra.c
