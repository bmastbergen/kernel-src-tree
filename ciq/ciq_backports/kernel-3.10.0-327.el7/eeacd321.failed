xfs: make xfs_cross_rename() complete fully

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit eeacd3217b8fa8143f5dc27ded405790c74f01e8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/eeacd321.failed

Now that xfs_finish_rename() exists, there is no reason for
xfs_cross_rename() to return to xfs_rename() to finish off the
rename transaction. Drive the completion code into
xfs_cross_rename() and handle all errors there so as to simplify
the xfs_rename() code.

Further, push the rename exchange target_ip check to early in the
rename code so as to make the error handling easy and obviously
correct.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Eric Sandeen <sandeen@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit eeacd3217b8fa8143f5dc27ded405790c74f01e8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_inode.c
diff --cc fs/xfs/xfs_inode.c
index 0a9e226dbdb3,b376ebe5fad9..000000000000
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@@ -2742,6 -2650,153 +2742,156 @@@ xfs_sort_for_rename
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static int
+ xfs_finish_rename(
+ 	struct xfs_trans	*tp,
+ 	struct xfs_bmap_free	*free_list)
+ {
+ 	int			committed = 0;
+ 	int			error;
+ 
+ 	/*
+ 	 * If this is a synchronous mount, make sure that the rename transaction
+ 	 * goes to disk before returning to the user.
+ 	 */
+ 	if (tp->t_mountp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC))
+ 		xfs_trans_set_sync(tp);
+ 
+ 	error = xfs_bmap_finish(&tp, free_list, &committed);
+ 	if (error) {
+ 		xfs_bmap_cancel(free_list);
+ 		xfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);
+ 		return error;
+ 	}
+ 
+ 	return xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);
+ }
+ 
+ /*
+  * xfs_cross_rename()
+  *
+  * responsible for handling RENAME_EXCHANGE flag in renameat2() sytemcall
+  */
+ STATIC int
+ xfs_cross_rename(
+ 	struct xfs_trans	*tp,
+ 	struct xfs_inode	*dp1,
+ 	struct xfs_name		*name1,
+ 	struct xfs_inode	*ip1,
+ 	struct xfs_inode	*dp2,
+ 	struct xfs_name		*name2,
+ 	struct xfs_inode	*ip2,
+ 	struct xfs_bmap_free	*free_list,
+ 	xfs_fsblock_t		*first_block,
+ 	int			spaceres)
+ {
+ 	int		error = 0;
+ 	int		ip1_flags = 0;
+ 	int		ip2_flags = 0;
+ 	int		dp2_flags = 0;
+ 
+ 	/* Swap inode number for dirent in first parent */
+ 	error = xfs_dir_replace(tp, dp1, name1,
+ 				ip2->i_ino,
+ 				first_block, free_list, spaceres);
+ 	if (error)
+ 		goto out_trans_abort;
+ 
+ 	/* Swap inode number for dirent in second parent */
+ 	error = xfs_dir_replace(tp, dp2, name2,
+ 				ip1->i_ino,
+ 				first_block, free_list, spaceres);
+ 	if (error)
+ 		goto out_trans_abort;
+ 
+ 	/*
+ 	 * If we're renaming one or more directories across different parents,
+ 	 * update the respective ".." entries (and link counts) to match the new
+ 	 * parents.
+ 	 */
+ 	if (dp1 != dp2) {
+ 		dp2_flags = XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG;
+ 
+ 		if (S_ISDIR(ip2->i_d.di_mode)) {
+ 			error = xfs_dir_replace(tp, ip2, &xfs_name_dotdot,
+ 						dp1->i_ino, first_block,
+ 						free_list, spaceres);
+ 			if (error)
+ 				goto out_trans_abort;
+ 
+ 			/* transfer ip2 ".." reference to dp1 */
+ 			if (!S_ISDIR(ip1->i_d.di_mode)) {
+ 				error = xfs_droplink(tp, dp2);
+ 				if (error)
+ 					goto out_trans_abort;
+ 				error = xfs_bumplink(tp, dp1);
+ 				if (error)
+ 					goto out_trans_abort;
+ 			}
+ 
+ 			/*
+ 			 * Although ip1 isn't changed here, userspace needs
+ 			 * to be warned about the change, so that applications
+ 			 * relying on it (like backup ones), will properly
+ 			 * notify the change
+ 			 */
+ 			ip1_flags |= XFS_ICHGTIME_CHG;
+ 			ip2_flags |= XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG;
+ 		}
+ 
+ 		if (S_ISDIR(ip1->i_d.di_mode)) {
+ 			error = xfs_dir_replace(tp, ip1, &xfs_name_dotdot,
+ 						dp2->i_ino, first_block,
+ 						free_list, spaceres);
+ 			if (error)
+ 				goto out_trans_abort;
+ 
+ 			/* transfer ip1 ".." reference to dp2 */
+ 			if (!S_ISDIR(ip2->i_d.di_mode)) {
+ 				error = xfs_droplink(tp, dp1);
+ 				if (error)
+ 					goto out_trans_abort;
+ 				error = xfs_bumplink(tp, dp2);
+ 				if (error)
+ 					goto out_trans_abort;
+ 			}
+ 
+ 			/*
+ 			 * Although ip2 isn't changed here, userspace needs
+ 			 * to be warned about the change, so that applications
+ 			 * relying on it (like backup ones), will properly
+ 			 * notify the change
+ 			 */
+ 			ip1_flags |= XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG;
+ 			ip2_flags |= XFS_ICHGTIME_CHG;
+ 		}
+ 	}
+ 
+ 	if (ip1_flags) {
+ 		xfs_trans_ichgtime(tp, ip1, ip1_flags);
+ 		xfs_trans_log_inode(tp, ip1, XFS_ILOG_CORE);
+ 	}
+ 	if (ip2_flags) {
+ 		xfs_trans_ichgtime(tp, ip2, ip2_flags);
+ 		xfs_trans_log_inode(tp, ip2, XFS_ILOG_CORE);
+ 	}
+ 	if (dp2_flags) {
+ 		xfs_trans_ichgtime(tp, dp2, dp2_flags);
+ 		xfs_trans_log_inode(tp, dp2, XFS_ILOG_CORE);
+ 	}
+ 	xfs_trans_ichgtime(tp, dp1, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);
+ 	xfs_trans_log_inode(tp, dp1, XFS_ILOG_CORE);
+ 	return xfs_finish_rename(tp, free_list);
+ 
+ out_trans_abort:
+ 	xfs_bmap_cancel(free_list);
+ 	xfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);
+ 	return error;
+ }
+ 
++>>>>>>> eeacd3217b8f (xfs: make xfs_cross_rename() complete fully)
  /*
   * xfs_rename
   */
@@@ -2825,9 -2878,17 +2978,23 @@@ xfs_rename
  	 */
  	if (unlikely((target_dp->i_d.di_flags & XFS_DIFLAG_PROJINHERIT) &&
  		     (xfs_get_projid(target_dp) != xfs_get_projid(src_ip)))) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(EXDEV);
 +		goto error_return;
 +	}
++=======
+ 		error = -EXDEV;
+ 		goto out_trans_cancel;
+ 	}
+ 
+ 	xfs_bmap_init(&free_list, &first_block);
+ 
+ 	/* RENAME_EXCHANGE is unique from here on. */
+ 	if (flags & RENAME_EXCHANGE)
+ 		return xfs_cross_rename(tp, src_dp, src_name, src_ip,
+ 					target_dp, target_name, target_ip,
+ 					&free_list, &first_block, spaceres);
++>>>>>>> eeacd3217b8f (xfs: make xfs_cross_rename() complete fully)
  
  	/*
  	 * Set up the target.
* Unmerged path fs/xfs/xfs_inode.c
