ipv6: drop useless rcu_read_lock() in anycast

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author WANG Cong <xiyou.wangcong@gmail.com>
commit 6c555490e0ce885a9caf0a045db69382a3ccbc9c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/6c555490.failed

These code is now protected by rtnl lock, rcu read lock
is useless now.

	Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6c555490e0ce885a9caf0a045db69382a3ccbc9c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
#	net/ipv6/anycast.c
diff --cc include/linux/netdevice.h
index 80813de117ba,ee38b948d9a0..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -1817,34 -2071,33 +1817,52 @@@ static inline struct net_device *first_
  	return lh == &net->dev_base_head ? NULL : net_device_entry(lh);
  }
  
 -int netdev_boot_setup_check(struct net_device *dev);
 -unsigned long netdev_boot_base(const char *prefix, int unit);
 -struct net_device *dev_getbyhwaddr_rcu(struct net *net, unsigned short type,
 -				       const char *hwaddr);
 -struct net_device *dev_getfirstbyhwtype(struct net *net, unsigned short type);
 -struct net_device *__dev_getfirstbyhwtype(struct net *net, unsigned short type);
 -void dev_add_pack(struct packet_type *pt);
 -void dev_remove_pack(struct packet_type *pt);
 -void __dev_remove_pack(struct packet_type *pt);
 -void dev_add_offload(struct packet_offload *po);
 -void dev_remove_offload(struct packet_offload *po);
 -
 +extern int 			netdev_boot_setup_check(struct net_device *dev);
 +extern unsigned long		netdev_boot_base(const char *prefix, int unit);
 +extern struct net_device *dev_getbyhwaddr_rcu(struct net *net, unsigned short type,
 +					      const char *hwaddr);
 +extern struct net_device *dev_getfirstbyhwtype(struct net *net, unsigned short type);
 +extern struct net_device *__dev_getfirstbyhwtype(struct net *net, unsigned short type);
 +extern void		dev_add_pack(struct packet_type *pt);
 +extern void		dev_remove_pack(struct packet_type *pt);
 +extern void		__dev_remove_pack(struct packet_type *pt);
 +extern void		dev_add_offload(struct packet_offload *po);
 +extern void		dev_remove_offload(struct packet_offload *po);
 +extern void		__dev_remove_offload(struct packet_offload *po);
 +
++<<<<<<< HEAD
 +extern struct net_device	*dev_get_by_flags_rcu(struct net *net, unsigned short flags,
 +						      unsigned short mask);
 +extern struct net_device	*dev_get_by_name(struct net *net, const char *name);
 +extern struct net_device	*dev_get_by_name_rcu(struct net *net, const char *name);
 +extern struct net_device	*__dev_get_by_name(struct net *net, const char *name);
 +extern int		dev_alloc_name(struct net_device *dev, const char *name);
 +extern int		dev_open(struct net_device *dev);
 +extern int		dev_close(struct net_device *dev);
 +extern void		dev_disable_lro(struct net_device *dev);
 +extern int		dev_loopback_xmit(struct sk_buff *newskb);
 +extern int		dev_queue_xmit(struct sk_buff *skb);
 +extern int		register_netdevice(struct net_device *dev);
 +extern void		unregister_netdevice_queue(struct net_device *dev,
 +						   struct list_head *head);
 +extern void		unregister_netdevice_many(struct list_head *head);
++=======
+ struct net_device *__dev_get_by_flags(struct net *net, unsigned short flags,
+ 				      unsigned short mask);
+ struct net_device *dev_get_by_name(struct net *net, const char *name);
+ struct net_device *dev_get_by_name_rcu(struct net *net, const char *name);
+ struct net_device *__dev_get_by_name(struct net *net, const char *name);
+ int dev_alloc_name(struct net_device *dev, const char *name);
+ int dev_open(struct net_device *dev);
+ int dev_close(struct net_device *dev);
+ void dev_disable_lro(struct net_device *dev);
+ int dev_loopback_xmit(struct sk_buff *newskb);
+ int dev_queue_xmit(struct sk_buff *skb);
+ int dev_queue_xmit_accel(struct sk_buff *skb, void *accel_priv);
+ int register_netdevice(struct net_device *dev);
+ void unregister_netdevice_queue(struct net_device *dev, struct list_head *head);
+ void unregister_netdevice_many(struct list_head *head);
++>>>>>>> 6c555490e0ce (ipv6: drop useless rcu_read_lock() in anycast)
  static inline void unregister_netdevice(struct net_device *dev)
  {
  	unregister_netdevice_queue(dev, NULL);
diff --cc net/ipv6/anycast.c
index 5a80f15a9de2,3b0429bc6b5a..000000000000
--- a/net/ipv6/anycast.c
+++ b/net/ipv6/anycast.c
@@@ -77,7 -77,7 +77,11 @@@ int ipv6_sock_ac_join(struct sock *sk, 
  	pac->acl_next = NULL;
  	pac->acl_addr = *addr;
  
++<<<<<<< HEAD
 +	rcu_read_lock();
++=======
+ 	rtnl_lock();
++>>>>>>> 6c555490e0ce (ipv6: drop useless rcu_read_lock() in anycast)
  	if (ifindex == 0) {
  		struct rt6_info *rt;
  
@@@ -136,7 -136,7 +140,11 @@@
  	}
  
  error:
++<<<<<<< HEAD
 +	rcu_read_unlock();
++=======
+ 	rtnl_unlock();
++>>>>>>> 6c555490e0ce (ipv6: drop useless rcu_read_lock() in anycast)
  	if (pac)
  		sock_kfree_s(sk, pac, sizeof(*pac));
  	return err;
@@@ -171,11 -171,11 +179,19 @@@ int ipv6_sock_ac_drop(struct sock *sk, 
  
  	spin_unlock_bh(&ipv6_sk_ac_lock);
  
++<<<<<<< HEAD
 +	rcu_read_lock();
 +	dev = dev_get_by_index_rcu(net, pac->acl_ifindex);
 +	if (dev)
 +		ipv6_dev_ac_dec(dev, &pac->acl_addr);
 +	rcu_read_unlock();
++=======
+ 	rtnl_lock();
+ 	dev = __dev_get_by_index(net, pac->acl_ifindex);
+ 	if (dev)
+ 		ipv6_dev_ac_dec(dev, &pac->acl_addr);
+ 	rtnl_unlock();
++>>>>>>> 6c555490e0ce (ipv6: drop useless rcu_read_lock() in anycast)
  
  	sock_kfree_s(sk, pac, sizeof(*pac));
  	return 0;
@@@ -198,7 -198,7 +214,11 @@@ void ipv6_sock_ac_close(struct sock *sk
  	spin_unlock_bh(&ipv6_sk_ac_lock);
  
  	prev_index = 0;
++<<<<<<< HEAD
 +	rcu_read_lock();
++=======
+ 	rtnl_lock();
++>>>>>>> 6c555490e0ce (ipv6: drop useless rcu_read_lock() in anycast)
  	while (pac) {
  		struct ipv6_ac_socklist *next = pac->acl_next;
  
@@@ -211,7 -211,7 +231,11 @@@
  		sock_kfree_s(sk, pac, sizeof(*pac));
  		pac = next;
  	}
++<<<<<<< HEAD
 +	rcu_read_unlock();
++=======
+ 	rtnl_unlock();
++>>>>>>> 6c555490e0ce (ipv6: drop useless rcu_read_lock() in anycast)
  }
  
  static void aca_put(struct ifacaddr6 *ac)
* Unmerged path include/linux/netdevice.h
diff --git a/net/core/dev.c b/net/core/dev.c
index 1924c9647d47..dbedbaa0f51d 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -890,23 +890,25 @@ struct net_device *dev_getfirstbyhwtype(struct net *net, unsigned short type)
 EXPORT_SYMBOL(dev_getfirstbyhwtype);
 
 /**
- *	dev_get_by_flags_rcu - find any device with given flags
+ *	__dev_get_by_flags - find any device with given flags
  *	@net: the applicable net namespace
  *	@if_flags: IFF_* values
  *	@mask: bitmask of bits in if_flags to check
  *
  *	Search for any interface with the given flags. Returns NULL if a device
  *	is not found or a pointer to the device. Must be called inside
- *	rcu_read_lock(), and result refcount is unchanged.
+ *	rtnl_lock(), and result refcount is unchanged.
  */
 
-struct net_device *dev_get_by_flags_rcu(struct net *net, unsigned short if_flags,
-				    unsigned short mask)
+struct net_device *__dev_get_by_flags(struct net *net, unsigned short if_flags,
+				      unsigned short mask)
 {
 	struct net_device *dev, *ret;
 
+	ASSERT_RTNL();
+
 	ret = NULL;
-	for_each_netdev_rcu(net, dev) {
+	for_each_netdev(net, dev) {
 		if (((dev->flags ^ if_flags) & mask) == 0) {
 			ret = dev;
 			break;
@@ -914,7 +916,7 @@ struct net_device *dev_get_by_flags_rcu(struct net *net, unsigned short if_flags
 	}
 	return ret;
 }
-EXPORT_SYMBOL(dev_get_by_flags_rcu);
+EXPORT_SYMBOL(__dev_get_by_flags);
 
 /**
  *	dev_valid_name - check if name is okay for network device
* Unmerged path net/ipv6/anycast.c
