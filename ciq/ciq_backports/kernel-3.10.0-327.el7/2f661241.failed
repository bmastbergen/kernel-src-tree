xfs: pass attr geometry to attr leaf header conversion functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Brian Foster <bfoster@redhat.com>
commit 2f6612415436bab4d923a61d8df399b134247810
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/2f661241.failed

The firstused field of the xfs_attr3_leaf_hdr structure is subject to an
overflow when fs blocksize is 64k. In preparation to handle this
overflow in the header conversion functions, pass the attribute geometry
to the functions that convert the in-core structure to and from the
on-disk structure.

	Signed-off-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit 2f6612415436bab4d923a61d8df399b134247810)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_attr_leaf.c
diff --cc fs/xfs/libxfs/xfs_attr_leaf.c
index e210c280e72a,3337516feeb0..000000000000
--- a/fs/xfs/libxfs/xfs_attr_leaf.c
+++ b/fs/xfs/libxfs/xfs_attr_leaf.c
@@@ -806,14 -808,14 +809,14 @@@ xfs_attr3_leaf_to_shortform
  
  	trace_xfs_attr_leaf_to_sf(args);
  
 -	tmpbuffer = kmem_alloc(args->geo->blksize, KM_SLEEP);
 +	tmpbuffer = kmem_alloc(XFS_LBSIZE(dp->i_mount), KM_SLEEP);
  	if (!tmpbuffer)
 -		return -ENOMEM;
 +		return ENOMEM;
  
 -	memcpy(tmpbuffer, bp->b_addr, args->geo->blksize);
 +	memcpy(tmpbuffer, bp->b_addr, XFS_LBSIZE(dp->i_mount));
  
  	leaf = (xfs_attr_leafblock_t *)tmpbuffer;
- 	xfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);
+ 	xfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr, leaf);
  	entry = xfs_attr3_leaf_entryp(leaf);
  
  	/* XXX (dgc): buffer is about to be marked stale - why zero it? */
@@@ -989,8 -991,8 +992,13 @@@ xfs_attr3_leaf_create
  	}
  	ichdr.freemap[0].size = ichdr.firstused - ichdr.freemap[0].base;
  
++<<<<<<< HEAD
 +	xfs_attr3_leaf_hdr_to_disk(leaf, &ichdr);
 +	xfs_trans_log_buf(args->trans, bp, 0, XFS_LBSIZE(mp) - 1);
++=======
+ 	xfs_attr3_leaf_hdr_to_disk(args->geo, leaf, &ichdr);
+ 	xfs_trans_log_buf(args->trans, bp, 0, args->geo->blksize - 1);
++>>>>>>> 2f6612415436 (xfs: pass attr geometry to attr leaf header conversion functions)
  
  	*bpp = bp;
  	return 0;
@@@ -1074,10 -1076,9 +1082,10 @@@ xfs_attr3_leaf_add
  	trace_xfs_attr_leaf_add(args);
  
  	leaf = bp->b_addr;
- 	xfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);
+ 	xfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr, leaf);
  	ASSERT(args->index >= 0 && args->index <= ichdr.count);
 -	entsize = xfs_attr_leaf_newentsize(args, NULL);
 +	entsize = xfs_attr_leaf_newentsize(args->namelen, args->valuelen,
 +			   args->trans->t_mountp->m_sb.sb_blocksize, NULL);
  
  	/*
  	 * Search through freemap for first-fit on new name length.
@@@ -1492,14 -1490,14 +1501,21 @@@ xfs_attr3_leaf_rebalance
  		/*
  		 * Move low entries from leaf2 to high end of leaf1.
  		 */
 -		xfs_attr3_leaf_moveents(args, leaf2, &ichdr2, 0, leaf1, &ichdr1,
 -					ichdr1.count, count);
 +		xfs_attr3_leaf_moveents(leaf2, &ichdr2, 0, leaf1, &ichdr1,
 +					ichdr1.count, count, state->mp);
  	}
  
++<<<<<<< HEAD
 +	xfs_attr3_leaf_hdr_to_disk(leaf1, &ichdr1);
 +	xfs_attr3_leaf_hdr_to_disk(leaf2, &ichdr2);
 +	xfs_trans_log_buf(args->trans, blk1->bp, 0, state->blocksize-1);
 +	xfs_trans_log_buf(args->trans, blk2->bp, 0, state->blocksize-1);
++=======
+ 	xfs_attr3_leaf_hdr_to_disk(state->args->geo, leaf1, &ichdr1);
+ 	xfs_attr3_leaf_hdr_to_disk(state->args->geo, leaf2, &ichdr2);
+ 	xfs_trans_log_buf(args->trans, blk1->bp, 0, args->geo->blksize - 1);
+ 	xfs_trans_log_buf(args->trans, blk2->bp, 0, args->geo->blksize - 1);
++>>>>>>> 2f6612415436 (xfs: pass attr geometry to attr leaf header conversion functions)
  
  	/*
  	 * Copy out last hashval in each block for B-tree code.
@@@ -1754,9 -1744,10 +1770,9 @@@ xfs_attr3_leaf_toosmall
  		if (error)
  			return error;
  
- 		xfs_attr3_leaf_hdr_from_disk(&ichdr2, bp->b_addr);
+ 		xfs_attr3_leaf_hdr_from_disk(state->args->geo, &ichdr2, bp->b_addr);
  
 -		bytes = state->args->geo->blksize -
 -			(state->args->geo->blksize >> 2) -
 +		bytes = state->blocksize - (state->blocksize >> 2) -
  			ichdr.usedbytes - ichdr2.usedbytes -
  			((ichdr.count + ichdr2.count) *
  					sizeof(xfs_attr_leaf_entry_t)) -
@@@ -1819,9 -1809,9 +1835,9 @@@ xfs_attr3_leaf_remove
  	trace_xfs_attr_leaf_remove(args);
  
  	leaf = bp->b_addr;
- 	xfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);
+ 	xfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr, leaf);
  
 -	ASSERT(ichdr.count > 0 && ichdr.count < args->geo->blksize / 8);
 +	ASSERT(ichdr.count > 0 && ichdr.count < XFS_LBSIZE(mp) / 8);
  	ASSERT(args->index >= 0 && args->index < ichdr.count);
  	ASSERT(ichdr.firstused >= ichdr.count * sizeof(*entry) +
  					xfs_attr3_leaf_hdr_size(leaf));
@@@ -2022,10 -2013,10 +2038,10 @@@ xfs_attr3_leaf_unbalance
  		tmphdr.magic = savehdr.magic;
  		tmphdr.forw = savehdr.forw;
  		tmphdr.back = savehdr.back;
 -		tmphdr.firstused = state->args->geo->blksize;
 +		tmphdr.firstused = state->blocksize;
  
  		/* write the header to the temp buffer to initialise it */
- 		xfs_attr3_leaf_hdr_to_disk(tmp_leaf, &tmphdr);
+ 		xfs_attr3_leaf_hdr_to_disk(state->args->geo, tmp_leaf, &tmphdr);
  
  		if (xfs_attr3_leaf_order(save_blk->bp, &savehdr,
  					 drop_blk->bp, &drophdr)) {
@@@ -2048,9 -2043,9 +2064,9 @@@
  		kmem_free(tmp_leaf);
  	}
  
- 	xfs_attr3_leaf_hdr_to_disk(save_leaf, &savehdr);
+ 	xfs_attr3_leaf_hdr_to_disk(state->args->geo, save_leaf, &savehdr);
  	xfs_trans_log_buf(state->args->trans, save_blk->bp, 0,
 -					   state->args->geo->blksize - 1);
 +					   state->blocksize - 1);
  
  	/*
  	 * Copy out last hashval in each block for B-tree code.
@@@ -2094,9 -2089,9 +2110,9 @@@ xfs_attr3_leaf_lookup_int
  	trace_xfs_attr_leaf_lookup(args);
  
  	leaf = bp->b_addr;
- 	xfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);
+ 	xfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr, leaf);
  	entries = xfs_attr3_leaf_entryp(leaf);
 -	ASSERT(ichdr.count < args->geo->blksize / 8);
 +	ASSERT(ichdr.count < XFS_LBSIZE(args->dp->i_mount) / 8);
  
  	/*
  	 * Binary search.  (note: small blocks will skip this loop)
@@@ -2199,8 -2194,8 +2215,13 @@@ xfs_attr3_leaf_getvalue
  	int			valuelen;
  
  	leaf = bp->b_addr;
++<<<<<<< HEAD
 +	xfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);
 +	ASSERT(ichdr.count < XFS_LBSIZE(args->dp->i_mount) / 8);
++=======
+ 	xfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr, leaf);
+ 	ASSERT(ichdr.count < args->geo->blksize / 8);
++>>>>>>> 2f6612415436 (xfs: pass attr geometry to attr leaf header conversion functions)
  	ASSERT(args->index < ichdr.count);
  
  	entry = &xfs_attr3_leaf_entryp(leaf)[args->index];
* Unmerged path fs/xfs/libxfs/xfs_attr_leaf.c
diff --git a/fs/xfs/libxfs/xfs_attr_leaf.h b/fs/xfs/libxfs/xfs_attr_leaf.h
index 3ec5ec0b8678..25399ed7fc8a 100644
--- a/fs/xfs/libxfs/xfs_attr_leaf.h
+++ b/fs/xfs/libxfs/xfs_attr_leaf.h
@@ -101,9 +101,11 @@ int	xfs_attr_leaf_newentsize(int namelen, int valuelen, int blocksize,
 int	xfs_attr3_leaf_read(struct xfs_trans *tp, struct xfs_inode *dp,
 			xfs_dablk_t bno, xfs_daddr_t mappedbno,
 			struct xfs_buf **bpp);
-void	xfs_attr3_leaf_hdr_from_disk(struct xfs_attr3_icleaf_hdr *to,
+void	xfs_attr3_leaf_hdr_from_disk(struct xfs_da_geometry *geo,
+				     struct xfs_attr3_icleaf_hdr *to,
 				     struct xfs_attr_leafblock *from);
-void	xfs_attr3_leaf_hdr_to_disk(struct xfs_attr_leafblock *to,
+void	xfs_attr3_leaf_hdr_to_disk(struct xfs_da_geometry *geo,
+				   struct xfs_attr_leafblock *to,
 				   struct xfs_attr3_icleaf_hdr *from);
 
 #endif	/* __XFS_ATTR_LEAF_H__ */
diff --git a/fs/xfs/xfs_attr_inactive.c b/fs/xfs/xfs_attr_inactive.c
index b39e58823085..d4c5bc57e8e8 100644
--- a/fs/xfs/xfs_attr_inactive.c
+++ b/fs/xfs/xfs_attr_inactive.c
@@ -135,9 +135,10 @@ xfs_attr3_leaf_inactive(
 	int			size;
 	int			tmp;
 	int			i;
+	struct xfs_mount	*mp = bp->b_target->bt_mount;
 
 	leaf = bp->b_addr;
-	xfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);
+	xfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &ichdr, leaf);
 
 	/*
 	 * Count the number of "remote" value extents.
diff --git a/fs/xfs/xfs_attr_list.c b/fs/xfs/xfs_attr_list.c
index 2d5487b6194c..6ad8a31b1a2d 100644
--- a/fs/xfs/xfs_attr_list.c
+++ b/fs/xfs/xfs_attr_list.c
@@ -228,6 +228,7 @@ xfs_attr_node_list(xfs_attr_list_context_t *context)
 	int error, i;
 	struct xfs_buf *bp;
 	struct xfs_inode	*dp = context->dp;
+	struct xfs_mount	*mp = dp->i_mount;
 
 	trace_xfs_attr_node_list(context);
 
@@ -259,7 +260,8 @@ xfs_attr_node_list(xfs_attr_list_context_t *context)
 			case XFS_ATTR_LEAF_MAGIC:
 			case XFS_ATTR3_LEAF_MAGIC:
 				leaf = bp->b_addr;
-				xfs_attr3_leaf_hdr_from_disk(&leafhdr, leaf);
+				xfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo,
+							     &leafhdr, leaf);
 				entries = xfs_attr3_leaf_entryp(leaf);
 				if (cursor->hashval > be32_to_cpu(
 						entries[leafhdr.count - 1].hashval)) {
@@ -343,7 +345,7 @@ xfs_attr_node_list(xfs_attr_list_context_t *context)
 			xfs_trans_brelse(NULL, bp);
 			return error;
 		}
-		xfs_attr3_leaf_hdr_from_disk(&leafhdr, leaf);
+		xfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &leafhdr, leaf);
 		if (context->seen_enough || leafhdr.forw == 0)
 			break;
 		cursor->blkno = leafhdr.forw;
@@ -371,11 +373,12 @@ xfs_attr3_leaf_list_int(
 	struct xfs_attr_leaf_entry	*entry;
 	int				retval;
 	int				i;
+	struct xfs_mount		*mp = context->dp->i_mount;
 
 	trace_xfs_attr_list_leaf(context);
 
 	leaf = bp->b_addr;
-	xfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);
+	xfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &ichdr, leaf);
 	entries = xfs_attr3_leaf_entryp(leaf);
 
 	cursor = context->cursor;
