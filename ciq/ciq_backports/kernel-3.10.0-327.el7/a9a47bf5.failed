scsi: repurpose the last argument from print_opcode_name()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [scsi] repurpose the last argument from print_opcode_name() (Ewan Milne) [1124082]
Rebuild_FUZZ: 94.55%
commit-author Hannes Reinecke <hare@suse.de>
commit a9a47bf58ac1d5525ae99922e055d8de87eeae78
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/a9a47bf5.failed

print_opcode_name() was only ever called with a '0' argument
from LLDDs and ULDs which were _not_ supporting variable length
CDBs, so the 'if' clause was never triggered.
Instead we should be using the last argument to specify
the cdb length to avoid accidental overflow when reading
the cdb buffer.

	Signed-off-by: Hannes Reinecke <hare@suse.de>
	Reviewed-by: Robert Elliott <elliott@hp.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit a9a47bf58ac1d5525ae99922e055d8de87eeae78)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/ch.c
#	drivers/scsi/sr_ioctl.c
#	include/scsi/scsi_dbg.h
diff --cc drivers/scsi/ch.c
index 9f4f89b7c1a6,226ef771efff..000000000000
--- a/drivers/scsi/ch.c
+++ b/drivers/scsi/ch.c
@@@ -286,8 -287,8 +287,13 @@@ ch_init_elem(scsi_changer *ch
  	VPRINTK(KERN_INFO, "INITIALIZE ELEMENT STATUS, may take some time ...\n");
  	memset(cmd,0,sizeof(cmd));
  	cmd[0] = INITIALIZE_ELEMENT_STATUS;
++<<<<<<< HEAD
 +	cmd[1] = ch->device->lun << 5;
 +	err = ch_do_scsi(ch, cmd, NULL, 0, DMA_NONE);
++=======
+ 	cmd[1] = (ch->device->lun & 0x7) << 5;
+ 	err = ch_do_scsi(ch, cmd, 6, NULL, 0, DMA_NONE);
++>>>>>>> a9a47bf58ac1 (scsi: repurpose the last argument from print_opcode_name())
  	VPRINTK(KERN_INFO, "... finished\n");
  	return err;
  }
@@@ -306,13 -307,13 +312,13 @@@ ch_readconfig(scsi_changer *ch
  
  	memset(cmd,0,sizeof(cmd));
  	cmd[0] = MODE_SENSE;
 -	cmd[1] = (ch->device->lun & 0x7) << 5;
 +	cmd[1] = ch->device->lun << 5;
  	cmd[2] = 0x1d;
  	cmd[4] = 255;
- 	result = ch_do_scsi(ch, cmd, buffer, 255, DMA_FROM_DEVICE);
+ 	result = ch_do_scsi(ch, cmd, 10, buffer, 255, DMA_FROM_DEVICE);
  	if (0 != result) {
  		cmd[1] |= (1<<3);
- 		result  = ch_do_scsi(ch, cmd, buffer, 255, DMA_FROM_DEVICE);
+ 		result  = ch_do_scsi(ch, cmd, 10, buffer, 255, DMA_FROM_DEVICE);
  	}
  	if (0 == result) {
  		ch->firsts[CHET_MT] =
diff --cc drivers/scsi/sr_ioctl.c
index 6389fcff12ec,fb929fac22ba..000000000000
--- a/drivers/scsi/sr_ioctl.c
+++ b/drivers/scsi/sr_ioctl.c
@@@ -257,15 -257,15 +257,25 @@@ int sr_do_ioctl(Scsi_CD *cd, struct pac
  				/* sense: Invalid command operation code */
  				err = -EDRIVE_CANT_DO_THIS;
  #ifdef DEBUG
++<<<<<<< HEAD
 +			__scsi_print_command(cgc->cmd);
 +			scsi_print_sense_hdr("sr", &sshdr);
++=======
+ 			__scsi_print_command(cgc->cmd, CDROM_PACKET_SIZE);
+ 			scsi_print_sense_hdr(cd->device, cd->cdi.name, &sshdr);
++>>>>>>> a9a47bf58ac1 (scsi: repurpose the last argument from print_opcode_name())
  #endif
  			break;
  		default:
  			sr_printk(KERN_ERR, cd,
  				  "CDROM (ioctl) error, command: ");
++<<<<<<< HEAD
 +			__scsi_print_command(cgc->cmd);
 +			scsi_print_sense_hdr("sr", &sshdr);
++=======
+ 			__scsi_print_command(cgc->cmd, CDROM_PACKET_SIZE);
+ 			scsi_print_sense_hdr(cd->device, cd->cdi.name, &sshdr);
++>>>>>>> a9a47bf58ac1 (scsi: repurpose the last argument from print_opcode_name())
  			err = -EIO;
  		}
  	}
diff --cc include/scsi/scsi_dbg.h
index f7420d8a395b,81d041822229..000000000000
--- a/include/scsi/scsi_dbg.h
+++ b/include/scsi/scsi_dbg.h
@@@ -5,12 -5,16 +5,24 @@@ struct scsi_cmnd
  struct scsi_sense_hdr;
  
  extern void scsi_print_command(struct scsi_cmnd *);
++<<<<<<< HEAD
 +extern void __scsi_print_command(unsigned char *);
 +extern void scsi_show_extd_sense(unsigned char, unsigned char);
 +extern void scsi_show_sense_hdr(struct scsi_sense_hdr *);
 +extern void scsi_print_sense_hdr(const char *, struct scsi_sense_hdr *);
 +extern void scsi_print_sense(char *, struct scsi_cmnd *);
 +extern void __scsi_print_sense(const char *name,
++=======
+ extern void __scsi_print_command(const unsigned char *, size_t);
+ extern void scsi_show_extd_sense(const struct scsi_device *, const char *,
+ 				 unsigned char, unsigned char);
+ extern void scsi_show_sense_hdr(const struct scsi_device *, const char *,
+ 				const struct scsi_sense_hdr *);
+ extern void scsi_print_sense_hdr(const struct scsi_device *, const char *,
+ 				 const struct scsi_sense_hdr *);
+ extern void scsi_print_sense(const struct scsi_cmnd *);
+ extern void __scsi_print_sense(const struct scsi_device *, const char *name,
++>>>>>>> a9a47bf58ac1 (scsi: repurpose the last argument from print_opcode_name())
  			       const unsigned char *sense_buffer,
  			       int sense_len);
  extern void scsi_show_result(int);
diff --git a/drivers/scsi/arm/fas216.c b/drivers/scsi/arm/fas216.c
index 58b554f95b18..1d20e80afd16 100644
--- a/drivers/scsi/arm/fas216.c
+++ b/drivers/scsi/arm/fas216.c
@@ -2421,7 +2421,7 @@ int fas216_eh_abort(struct scsi_cmnd *SCpnt)
 	info->stats.aborts += 1;
 
 	printk(KERN_WARNING "scsi%d: abort command ", info->host->host_no);
-	__scsi_print_command(SCpnt->cmnd);
+	__scsi_print_command(SCpnt->cmnd, SCpnt->cmd_len);
 
 	print_debug_list();
 	fas216_dumpstate(info);
* Unmerged path drivers/scsi/ch.c
diff --git a/drivers/scsi/constants.c b/drivers/scsi/constants.c
index 59e04c70ae0b..9bf0f38c3dae 100644
--- a/drivers/scsi/constants.c
+++ b/drivers/scsi/constants.c
@@ -320,25 +320,21 @@ static bool scsi_opcode_sa_name(int opcode, int service_action,
 	return true;
 }
 
-/* attempt to guess cdb length if cdb_len==0 . No trailing linefeed. */
-static void print_opcode_name(unsigned char * cdbp, int cdb_len)
+static void print_opcode_name(const unsigned char *cdbp, size_t cdb_len)
 {
-	int sa, len, cdb0;
+	int sa, cdb0;
 	const char *cdb_name = NULL, *sa_name = NULL;
 
 	cdb0 = cdbp[0];
 	if (cdb0 == VARIABLE_LENGTH_CMD) {
-		len = scsi_varlen_cdb_length(cdbp);
-		if (len < 10) {
-			printk("short variable length command, "
-			       "len=%d ext_len=%d", len, cdb_len);
+		if (cdb_len < 10) {
+			printk("short variable length command, len=%zu",
+			       cdb_len);
 			return;
 		}
 		sa = (cdbp[8] << 8) + cdbp[9];
-	} else {
+	} else
 		sa = cdbp[1] & 0x1f;
-		len = cdb_len;
-	}
 
 	if (!scsi_opcode_sa_name(cdb0, sa, &cdb_name, &sa_name)) {
 		if (cdb_name)
@@ -356,18 +352,17 @@ static void print_opcode_name(unsigned char * cdbp, int cdb_len)
 			printk("%s, sa=0x%x", cdb_name, sa);
 		else
 			printk("cdb[0]=0x%x, sa=0x%x", cdb0, sa);
-
-		if (cdb_len > 0 && len != cdb_len)
-			printk(", in_cdb_len=%d, ext_len=%d", len, cdb_len);
 	}
 }
 
-void __scsi_print_command(unsigned char *cdb)
+void __scsi_print_command(const unsigned char *cdb, size_t cdb_len)
 {
 	int k, len;
 
-	print_opcode_name(cdb, 0);
+	print_opcode_name(cdb, cdb_len);
 	len = scsi_command_size(cdb);
+	if (cdb_len < len)
+		len = cdb_len;
 	/* print out all bytes in cdb */
 	for (k = 0; k < len; ++k)
 		printk(" %02x", cdb[k]);
* Unmerged path drivers/scsi/sr_ioctl.c
* Unmerged path include/scsi/scsi_dbg.h
