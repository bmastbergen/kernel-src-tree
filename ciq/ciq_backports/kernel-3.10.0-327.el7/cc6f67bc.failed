ovl: mount read-only if workdir can't be created

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Miklos Szeredi <mszeredi@suse.cz>
commit cc6f67bcafcb6bbbb2d1be1603dcd95125a52800
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/cc6f67bc.failed

OpenWRT folks reported that overlayfs fails to mount if upper fs is full,
because workdir can't be created.  Wordir creation can fail for various
other reasons too.

There's no reason that the mount itself should fail, overlayfs can work
fine without a workdir, as long as the overlay isn't modified.

So mount it read-only and don't allow remounting read-write.

Add a couple of WARN_ON()s for the impossible case of workdir being used
despite being read-only.

	Reported-by: Bastian Bittorf <bittorf@bluebottle.com> 
	Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
	Cc: <stable@vger.kernel.org> # v3.18+
(cherry picked from commit cc6f67bcafcb6bbbb2d1be1603dcd95125a52800)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/super.c
diff --cc fs/overlayfs/super.c
index 247af4499a61,bf8537c7f455..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -461,8 -529,7 +461,12 @@@ static int ovl_remount(struct super_blo
  {
  	struct ovl_fs *ufs = sb->s_fs_info;
  
++<<<<<<< HEAD
 +	if (!(*flags & MS_RDONLY) &&
 +	    (!ufs->upper_mnt || (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)))
++=======
+ 	if (!(*flags & MS_RDONLY) && (!ufs->upper_mnt || !ufs->workdir))
++>>>>>>> cc6f67bcafcb (ovl: mount read-only if workdir can't be created)
  		return -EROFS;
  
  	return 0;
@@@ -698,104 -844,118 +702,123 @@@ static int ovl_fill_super(struct super_
  		goto out_free_config;
  	}
  
 -	sb->s_stack_depth = 0;
 -	if (ufs->config.upperdir) {
 -		if (!ufs->config.workdir) {
 -			pr_err("overlayfs: missing 'workdir'\n");
 -			goto out_free_config;
 -		}
 -
 -		err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
 -		if (err)
 -			goto out_free_config;
 -
 -		/* Upper fs should not be r/o */
 -		if (upperpath.mnt->mnt_sb->s_flags & MS_RDONLY) {
 -			pr_err("overlayfs: upper fs is r/o, try multi-lower layers mount\n");
 -			err = -EINVAL;
 -			goto out_put_upperpath;
 -		}
 -
 -		err = ovl_mount_dir(ufs->config.workdir, &workpath);
 -		if (err)
 -			goto out_put_upperpath;
 -
 -		err = -EINVAL;
 -		if (upperpath.mnt != workpath.mnt) {
 -			pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
 -			goto out_put_workpath;
 -		}
 -		if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
 -			pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
 -			goto out_put_workpath;
 -		}
 -		sb->s_stack_depth = upperpath.mnt->mnt_sb->s_stack_depth;
 -	}
  	err = -ENOMEM;
 -	lowertmp = kstrdup(ufs->config.lowerdir, GFP_KERNEL);
 -	if (!lowertmp)
 -		goto out_put_workpath;
 -
 -	err = -EINVAL;
 -	stacklen = ovl_split_lowerdirs(lowertmp);
 -	if (stacklen > OVL_MAX_STACK) {
 -		pr_err("overlayfs: too many lower directries, limit is %d\n",
 -		       OVL_MAX_STACK);
 -		goto out_free_lowertmp;
 -	} else if (!ufs->config.upperdir && stacklen == 1) {
 -		pr_err("overlayfs: at least 2 lowerdir are needed while upperdir nonexistent\n");
 -		goto out_free_lowertmp;
 -	}
 +	oe = ovl_alloc_entry();
 +	if (oe == NULL)
 +		goto out_free_config;
  
 -	stack = kcalloc(stacklen, sizeof(struct path), GFP_KERNEL);
 -	if (!stack)
 -		goto out_free_lowertmp;
 +	err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
 +	if (err)
 +		goto out_free_oe;
  
 -	lower = lowertmp;
 -	for (numlower = 0; numlower < stacklen; numlower++) {
 -		err = ovl_lower_dir(lower, &stack[numlower],
 -				    &ufs->lower_namelen, &sb->s_stack_depth);
 -		if (err)
 -			goto out_put_lowerpath;
 +	err = ovl_mount_dir(ufs->config.lowerdir, &lowerpath);
 +	if (err)
 +		goto out_put_upperpath;
  
 -		lower = strchr(lower, '\0') + 1;
 -	}
 +	err = ovl_mount_dir(ufs->config.workdir, &workpath);
 +	if (err)
 +		goto out_put_lowerpath;
  
  	err = -EINVAL;
 -	sb->s_stack_depth++;
 -	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
 -		pr_err("overlayfs: maximum fs stacking depth exceeded\n");
 -		goto out_put_lowerpath;
 +	if (!S_ISDIR(upperpath.dentry->d_inode->i_mode) ||
 +	    !S_ISDIR(lowerpath.dentry->d_inode->i_mode) ||
 +	    !S_ISDIR(workpath.dentry->d_inode->i_mode)) {
 +		pr_err("overlayfs: upperdir or lowerdir or workdir not a directory\n");
 +		goto out_put_workpath;
  	}
  
++<<<<<<< HEAD
 +	if (upperpath.mnt != workpath.mnt) {
 +		pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
 +		goto out_put_workpath;
 +	}
 +	if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
 +		pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
 +		goto out_put_workpath;
++=======
+ 	if (ufs->config.upperdir) {
+ 		ufs->upper_mnt = clone_private_mount(&upperpath);
+ 		err = PTR_ERR(ufs->upper_mnt);
+ 		if (IS_ERR(ufs->upper_mnt)) {
+ 			pr_err("overlayfs: failed to clone upperpath\n");
+ 			goto out_put_lowerpath;
+ 		}
+ 
+ 		ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
+ 		err = PTR_ERR(ufs->workdir);
+ 		if (IS_ERR(ufs->workdir)) {
+ 			pr_warn("overlayfs: failed to create directory %s/%s (errno: %i); mounting read-only\n",
+ 				ufs->config.workdir, OVL_WORKDIR_NAME, -err);
+ 			sb->s_flags |= MS_RDONLY;
+ 			ufs->workdir = NULL;
+ 		}
++>>>>>>> cc6f67bcafcb (ovl: mount read-only if workdir can't be created)
  	}
  
 -	err = -ENOMEM;
 -	ufs->lower_mnt = kcalloc(numlower, sizeof(struct vfsmount *), GFP_KERNEL);
 -	if (ufs->lower_mnt == NULL)
 -		goto out_put_workdir;
 -	for (i = 0; i < numlower; i++) {
 -		struct vfsmount *mnt = clone_private_mount(&stack[i]);
 +	if (!ovl_is_allowed_fs_type(upperpath.dentry)) {
 +		pr_err("overlayfs: filesystem of upperdir is not supported\n");
 +		goto out_put_workpath;
 +	}
  
 -		err = PTR_ERR(mnt);
 -		if (IS_ERR(mnt)) {
 -			pr_err("overlayfs: failed to clone lowerpath\n");
 -			goto out_put_lower_mnt;
 -		}
 -		/*
 -		 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
 -		 * will fail instead of modifying lower fs.
 -		 */
 -		mnt->mnt_flags |= MNT_READONLY;
 -
 -		ufs->lower_mnt[ufs->numlower] = mnt;
 -		ufs->numlower++;
 +	if (!ovl_is_allowed_fs_type(lowerpath.dentry)) {
 +		pr_err("overlayfs: filesystem of lowerdir is not supported\n");
 +		goto out_put_workpath;
 +	}
 +
 +	err = vfs_statfs(&lowerpath, &statfs);
 +	if (err) {
 +		pr_err("overlayfs: statfs failed on lowerpath\n");
 +		goto out_put_workpath;
 +	}
 +	ufs->lower_namelen = statfs.f_namelen;
 +
 +	upper_stack_depth = get_s_stack_depth(upperpath.mnt->mnt_sb);
 +	lower_stack_depth = get_s_stack_depth(lowerpath.mnt->mnt_sb);
 +	overlay_stack_depth = get_s_stack_depth(sb);
 +	err = -EOPNOTSUPP;
 +	if (!upper_stack_depth || !lower_stack_depth || !overlay_stack_depth) {
 +		pr_err("overlayfs: superblock missing extension wrapper (old kernel?)\n");
 +		goto out_put_workpath;
 +	}
 +
 +	*overlay_stack_depth = max(*upper_stack_depth, *lower_stack_depth) + 1;
 +
 +	err = -EINVAL;
 +	if (*overlay_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
 +		pr_err("overlayfs: maximum fs stacking depth exceeded\n");
 +		goto out_put_workpath;
 +	}
 +
 +	ufs->upper_mnt = clone_private_mount(&upperpath);
 +	err = PTR_ERR(ufs->upper_mnt);
 +	if (IS_ERR(ufs->upper_mnt)) {
 +		pr_err("overlayfs: failed to clone upperpath\n");
 +		goto out_put_workpath;
 +	}
 +
 +	ufs->lower_mnt = clone_private_mount(&lowerpath);
 +	err = PTR_ERR(ufs->lower_mnt);
 +	if (IS_ERR(ufs->lower_mnt)) {
 +		pr_err("overlayfs: failed to clone lowerpath\n");
 +		goto out_put_upper_mnt;
 +	}
 +
 +	ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
 +	err = PTR_ERR(ufs->workdir);
 +	if (IS_ERR(ufs->workdir)) {
 +		pr_err("overlayfs: failed to create directory %s/%s\n",
 +		       ufs->config.workdir, OVL_WORKDIR_NAME);
 +		goto out_put_lower_mnt;
  	}
  
 -	/* If the upper fs is nonexistent, we mark overlayfs r/o too */
 -	if (!ufs->upper_mnt)
 +	/*
 +	 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
 +	 * will fail instead of modifying lower fs.
 +	 */
 +	ufs->lower_mnt->mnt_flags |= MNT_READONLY;
 +
 +	/* If the upper fs is r/o, we mark overlayfs r/o too */
 +	if (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)
  		sb->s_flags |= MS_RDONLY;
  
  	sb->s_d_op = &ovl_dentry_operations;
@@@ -825,20 -990,25 +848,23 @@@
  
  	return 0;
  
 -out_free_oe:
 -	kfree(oe);
 -out_put_lower_mnt:
 -	for (i = 0; i < ufs->numlower; i++)
 -		mntput(ufs->lower_mnt[i]);
 -	kfree(ufs->lower_mnt);
  out_put_workdir:
  	dput(ufs->workdir);
++<<<<<<< HEAD
 +out_put_lower_mnt:
 +	mntput(ufs->lower_mnt);
 +out_put_upper_mnt:
++=======
++>>>>>>> cc6f67bcafcb (ovl: mount read-only if workdir can't be created)
  	mntput(ufs->upper_mnt);
 -out_put_lowerpath:
 -	for (i = 0; i < numlower; i++)
 -		path_put(&stack[i]);
 -	kfree(stack);
 -out_free_lowertmp:
 -	kfree(lowertmp);
  out_put_workpath:
  	path_put(&workpath);
 +out_put_lowerpath:
 +	path_put(&lowerpath);
  out_put_upperpath:
  	path_put(&upperpath);
 +out_free_oe:
 +	kfree(oe);
  out_free_config:
  	kfree(ufs->config.lowerdir);
  	kfree(ufs->config.upperdir);
diff --git a/fs/overlayfs/copy_up.c b/fs/overlayfs/copy_up.c
index 24f640441bd9..84d693d37428 100644
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@ -299,6 +299,9 @@ int ovl_copy_up_one(struct dentry *parent, struct dentry *dentry,
 	struct cred *override_cred;
 	char *link = NULL;
 
+	if (WARN_ON(!workdir))
+		return -EROFS;
+
 	ovl_path_upper(parent, &parentpath);
 	upperdir = parentpath.dentry;
 
diff --git a/fs/overlayfs/dir.c b/fs/overlayfs/dir.c
index 5e9e52ca51ce..23287001d996 100644
--- a/fs/overlayfs/dir.c
+++ b/fs/overlayfs/dir.c
@@ -222,6 +222,9 @@ static struct dentry *ovl_clear_empty(struct dentry *dentry,
 	struct kstat stat;
 	int err;
 
+	if (WARN_ON(!workdir))
+		return ERR_PTR(-EROFS);
+
 	err = ovl_lock_rename_workdir(workdir, upperdir);
 	if (err)
 		goto out;
@@ -322,6 +325,9 @@ static int ovl_create_over_whiteout(struct dentry *dentry, struct inode *inode,
 	struct dentry *newdentry;
 	int err;
 
+	if (WARN_ON(!workdir))
+		return -EROFS;
+
 	err = ovl_lock_rename_workdir(workdir, upperdir);
 	if (err)
 		goto out;
@@ -506,6 +512,9 @@ static int ovl_remove_and_whiteout(struct dentry *dentry, bool is_dir)
 	struct dentry *opaquedir = NULL;
 	int err;
 
+	if (WARN_ON(!workdir))
+		return -EROFS;
+
 	if (is_dir) {
 		if (OVL_TYPE_MERGE_OR_LOWER(ovl_path_type(dentry))) {
 			opaquedir = ovl_check_empty_and_clear(dentry);
* Unmerged path fs/overlayfs/super.c
