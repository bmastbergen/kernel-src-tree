be2net: make hwmon interface optional

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Arnd Bergmann <arnd@arndb.de>
commit 9a03259c3d30d4b1b582072211dc571a68340054
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/9a03259c.failed

The hwmon interface in the be2net driver causes a link error when
be2net is built-in while the hwmon subsystem is a loadable module:

drivers/built-in.o: In function `be_probe':
drivers/net/ethernet/emulex/benet/be_main.c:5761: undefined reference to `devm_hwmon_device_register_with_groups'

This adds a new Kconfig symbol, following the example of multiple
other drivers that have the same problem. The new CONFIG_BE2NET_HWMON
will not be available when (BE2NET=y && HWMON=m) to avoid this
problem.

We have to also mark be_hwmon_show_temp as 'static' to ensure the
compiler can optimize out all the unused code.

	Signed-off-by: Arnd Bergmann <arnd@arndb.de>
Fixes: 29e9122b3a ("be2net: Export board temperature using hwmon-sysfs interface.")
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9a03259c3d30d4b1b582072211dc571a68340054)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/emulex/benet/be_main.c
diff --cc drivers/net/ethernet/emulex/benet/be_main.c
index 4e5ddaa87095,75696d4f9ed0..000000000000
--- a/drivers/net/ethernet/emulex/benet/be_main.c
+++ b/drivers/net/ethernet/emulex/benet/be_main.c
@@@ -4963,155 -5612,29 +4963,161 @@@ static void be_remove(struct pci_dev *p
  	free_netdev(adapter->netdev);
  }
  
++<<<<<<< HEAD
 +static int be_get_initial_config(struct be_adapter *adapter)
++=======
+ static ssize_t be_hwmon_show_temp(struct device *dev,
+ 				  struct device_attribute *dev_attr,
+ 				  char *buf)
++>>>>>>> 9a03259c3d30 (be2net: make hwmon interface optional)
  {
 -	struct be_adapter *adapter = dev_get_drvdata(dev);
 +	int status, level;
  
 -	/* Unit: millidegree Celsius */
 -	if (adapter->hwmon_info.be_on_die_temp == BE_INVALID_DIE_TEMP)
 -		return -EIO;
 +	status = be_cmd_get_cntl_attributes(adapter);
 +	if (status)
 +		return status;
 +
 +	/* Must be a power of 2 or else MODULO will BUG_ON */
 +	adapter->be_get_temp_freq = 64;
 +
 +	if (BEx_chip(adapter)) {
 +		level = be_cmd_get_fw_log_level(adapter);
 +		adapter->msg_enable =
 +			level <= FW_LOG_LEVEL_DEFAULT ? NETIF_MSG_HW : 0;
 +	}
 +
 +	adapter->cfg_num_qs = netif_get_num_default_rss_queues();
 +	return 0;
 +}
 +
 +static int lancer_recover_func(struct be_adapter *adapter)
 +{
 +	struct device *dev = &adapter->pdev->dev;
 +	int status;
 +
 +	status = lancer_test_and_set_rdy_state(adapter);
 +	if (status)
 +		goto err;
 +
 +	if (netif_running(adapter->netdev))
 +		be_close(adapter->netdev);
 +
 +	be_clear(adapter);
 +
 +	be_clear_all_error(adapter);
 +
 +	status = be_setup(adapter);
 +	if (status)
 +		goto err;
 +
 +	if (netif_running(adapter->netdev)) {
 +		status = be_open(adapter->netdev);
 +		if (status)
 +			goto err;
 +	}
 +
 +	dev_err(dev, "Adapter recovery successful\n");
 +	return 0;
 +err:
 +	if (status == -EAGAIN)
 +		dev_err(dev, "Waiting for resource provisioning\n");
  	else
 -		return sprintf(buf, "%u\n",
 -			       adapter->hwmon_info.be_on_die_temp * 1000);
 +		dev_err(dev, "Adapter recovery failed\n");
 +
 +	return status;
  }
  
 -static SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO,
 -			  be_hwmon_show_temp, NULL, 1);
 +static void be_func_recovery_task(struct work_struct *work)
 +{
 +	struct be_adapter *adapter =
 +		container_of(work, struct be_adapter,  func_recovery_work.work);
 +	int status = 0;
  
 -static struct attribute *be_hwmon_attrs[] = {
 -	&sensor_dev_attr_temp1_input.dev_attr.attr,
 -	NULL
 -};
 +	be_detect_error(adapter);
 +
 +	if (adapter->hw_error && lancer_chip(adapter)) {
 +		rtnl_lock();
 +		netif_device_detach(adapter->netdev);
 +		rtnl_unlock();
 +
 +		status = lancer_recover_func(adapter);
 +		if (!status)
 +			netif_device_attach(adapter->netdev);
 +	}
 +
 +	/* In Lancer, for all errors other than provisioning error (-EAGAIN),
 +	 * no need to attempt further recovery.
 +	 */
 +	if (!status || status == -EAGAIN)
 +		schedule_delayed_work(&adapter->func_recovery_work,
 +				      msecs_to_jiffies(1000));
 +}
 +
 +static void be_log_sfp_info(struct be_adapter *adapter)
 +{
 +	int status;
 +
 +	status = be_cmd_query_sfp_info(adapter);
 +	if (!status) {
 +		dev_err(&adapter->pdev->dev,
 +			"Unqualified SFP+ detected on %c from %s part no: %s",
 +			adapter->port_name, adapter->phy.vendor_name,
 +			adapter->phy.vendor_pn);
 +	}
 +	adapter->flags &= ~BE_FLAGS_EVT_INCOMPATIBLE_SFP;
 +}
 +
 +static void be_worker(struct work_struct *work)
 +{
 +	struct be_adapter *adapter =
 +		container_of(work, struct be_adapter, work.work);
 +	struct be_rx_obj *rxo;
 +	int i;
 +
 +	/* when interrupts are not yet enabled, just reap any pending
 +	* mcc completions */
 +	if (!netif_running(adapter->netdev)) {
 +		local_bh_disable();
 +		be_process_mcc(adapter);
 +		local_bh_enable();
 +		goto reschedule;
 +	}
 +
 +	if (!adapter->stats_cmd_sent) {
 +		if (lancer_chip(adapter))
 +			lancer_cmd_get_pport_stats(adapter,
 +						   &adapter->stats_cmd);
 +		else
 +			be_cmd_get_stats(adapter, &adapter->stats_cmd);
 +	}
 +
 +	if (be_physfn(adapter) &&
 +	    MODULO(adapter->work_counter, adapter->be_get_temp_freq) == 0)
 +		be_cmd_get_die_temperature(adapter);
  
 -ATTRIBUTE_GROUPS(be_hwmon);
 +	for_all_rx_queues(adapter, rxo, i) {
 +		/* Replenish RX-queues starved due to memory
 +		 * allocation failures.
 +		 */
 +		if (rxo->rx_post_starved)
 +			be_post_rx_frags(rxo, GFP_KERNEL, MAX_RX_POST);
 +	}
 +
 +	be_eqd_update(adapter);
 +
 +	if (adapter->flags & BE_FLAGS_EVT_INCOMPATIBLE_SFP)
 +		be_log_sfp_info(adapter);
 +
 +reschedule:
 +	adapter->work_counter++;
 +	schedule_delayed_work(&adapter->work, msecs_to_jiffies(1000));
 +}
 +
 +/* If any VFs are already enabled don't FLR the PF */
 +static bool be_reset_required(struct be_adapter *adapter)
 +{
 +	return pci_num_vf(adapter->pdev) ? false : true;
 +}
  
  static char *mc_name(struct be_adapter *adapter)
  {
@@@ -5243,8 -5753,17 +5249,22 @@@ static int be_probe(struct pci_dev *pde
  
  	be_roce_dev_add(adapter);
  
++<<<<<<< HEAD
 +	schedule_delayed_work(&adapter->func_recovery_work,
 +			      msecs_to_jiffies(1000));
++=======
+ 	be_schedule_err_detection(adapter);
+ 
+ 	/* On Die temperature not supported for VF. */
+ 	if (be_physfn(adapter) && IS_ENABLED(CONFIG_BE2NET_HWMON)) {
+ 		adapter->hwmon_info.hwmon_dev =
+ 			devm_hwmon_device_register_with_groups(&pdev->dev,
+ 							       DRV_NAME,
+ 							       adapter,
+ 							       be_hwmon_groups);
+ 		adapter->hwmon_info.be_on_die_temp = BE_INVALID_DIE_TEMP;
+ 	}
++>>>>>>> 9a03259c3d30 (be2net: make hwmon interface optional)
  
  	dev_info(&pdev->dev, "%s: %s %s port %c\n", nic_name(pdev),
  		 func_name(adapter), mc_name(adapter), adapter->port_name);
diff --git a/drivers/net/ethernet/emulex/benet/Kconfig b/drivers/net/ethernet/emulex/benet/Kconfig
index ea94a8eb6b35..7108563260ae 100644
--- a/drivers/net/ethernet/emulex/benet/Kconfig
+++ b/drivers/net/ethernet/emulex/benet/Kconfig
@@ -5,6 +5,15 @@ config BE2NET
 	  This driver implements the NIC functionality for ServerEngines'
 	  10Gbps network adapter - BladeEngine.
 
+config BE2NET_HWMON
+	bool "HWMON support for be2net driver"
+	depends on BE2NET && HWMON
+	depends on !(BE2NET=y && HWMON=m)
+	default y
+	---help---
+	  Say Y here if you want to expose thermal sensor data on
+	  be2net network adapter.
+
 config BE2NET_VXLAN
         bool "VXLAN offload support on be2net driver"
         default y
* Unmerged path drivers/net/ethernet/emulex/benet/be_main.c
