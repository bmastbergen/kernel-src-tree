ALSA: hda - Move hda_i915.c from sound/pci/hda to sound/hda

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [alsa] hda - Move hda_i915.c from sound/pci/hda to sound/hda (Jaroslav Kysela) [1197064]
Rebuild_FUZZ: 94.64%
commit-author Mengdong Lin <mengdong.lin@intel.com>
commit 98d8fc6c5d3652e91c61d78941e0fa6f94771d67
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/98d8fc6c.failed

The file is moved to hda core and renamed to hdac_i915.c, so can be used
by both legacy HDA driver and new Skylake audio driver.

- Add snd_hdac_ prefix to the public APIs.
- The i915 audio component is moved to core bus and dynamically allocated.
- A static pointer hdac_acomp is used to help bind/unbind callbacks to get
  this component, because the sound card's private_data is used by the azx
  chip pointer, which is a legacy structure. It could be removed if private
  _data changes to some core structure which can be extended to find the
  bus.
- snd_hdac_get_display_clk() is added to get the display core clock for
  HSW/BDW.
- haswell_set_bclk() is moved to hda_intel.c because it needs to write the
  controller registers EM4/EM5, and only legacy HD-A needs it for HSW/BDW.
- Move definition of HSW/BDW-specific registers EM4/EM5 to hda_register.h
  and rename them to HSW_EM4/HSW_EM5, because other HD-A controllers have
  different layout for the extended mode registers.

	Signed-off-by: Mengdong Lin <mengdong.lin@intel.com>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 98d8fc6c5d3652e91c61d78941e0fa6f94771d67)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/sound/hda_register.h
#	include/sound/hdaudio.h
#	sound/hda/Kconfig
#	sound/hda/Makefile
#	sound/pci/hda/hda_i915.c
#	sound/pci/hda/hda_intel.c
#	sound/pci/hda/hda_intel.h
diff --cc sound/pci/hda/hda_intel.c
index e1c964381edc,391e4f834436..000000000000
--- a/sound/pci/hda/hda_intel.c
+++ b/sound/pci/hda/hda_intel.c
@@@ -556,6 -559,14 +558,17 @@@ static int azx_position_check(struct az
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /* Enable/disable i915 display power for the link */
+ static int azx_intel_link_power(struct azx *chip, bool enable)
+ {
+ 	struct hdac_bus *bus = azx_bus(chip);
+ 
+ 	return snd_hdac_display_power(bus, enable);
+ }
+ 
++>>>>>>> 98d8fc6c5d36 (ALSA: hda - Move hda_i915.c from sound/pci/hda to sound/hda)
  /*
   * Check whether the current DMA position is acceptable for updating
   * periods.  Returns non-zero if it's OK.
@@@ -811,8 -877,11 +868,16 @@@ static int azx_suspend(struct device *d
  
  	if (chip->msi)
  		pci_disable_msi(chip->pci);
++<<<<<<< HEAD
 +	if (chip->driver_caps & AZX_DCAPS_I915_POWERWELL)
 +		hda_display_power(hda, false);
++=======
+ 	if (chip->driver_caps & AZX_DCAPS_I915_POWERWELL
+ 		&& hda->need_i915_power)
+ 		snd_hdac_display_power(bus, false);
+ 
+ 	trace_azx_suspend(chip);
++>>>>>>> 98d8fc6c5d36 (ALSA: hda - Move hda_i915.c from sound/pci/hda to sound/hda)
  	return 0;
  }
  
@@@ -831,8 -900,9 +896,14 @@@ static int azx_resume(struct device *de
  	if (chip->disabled || hda->init_failed)
  		return 0;
  
++<<<<<<< HEAD
 +	if (chip->driver_caps & AZX_DCAPS_I915_POWERWELL) {
 +		hda_display_power(hda, true);
++=======
+ 	if (chip->driver_caps & AZX_DCAPS_I915_POWERWELL
+ 		&& hda->need_i915_power) {
+ 		snd_hdac_display_power(azx_bus(chip), true);
++>>>>>>> 98d8fc6c5d36 (ALSA: hda - Move hda_i915.c from sound/pci/hda to sound/hda)
  		haswell_set_bclk(hda);
  	}
  	if (chip->msi)
@@@ -874,9 -946,11 +945,15 @@@ static int azx_runtime_suspend(struct d
  	azx_stop_chip(chip);
  	azx_enter_link_reset(chip);
  	azx_clear_irq_pending(chip);
++<<<<<<< HEAD
 +	if (chip->driver_caps & AZX_DCAPS_I915_POWERWELL)
 +		hda_display_power(hda, false);
++=======
+ 	if (chip->driver_caps & AZX_DCAPS_I915_POWERWELL
+ 		&& hda->need_i915_power)
+ 		snd_hdac_display_power(azx_bus(chip), false);
++>>>>>>> 98d8fc6c5d36 (ALSA: hda - Move hda_i915.c from sound/pci/hda to sound/hda)
  
 -	trace_azx_runtime_suspend(chip);
  	return 0;
  }
  
@@@ -885,7 -959,7 +962,11 @@@ static int azx_runtime_resume(struct de
  	struct snd_card *card = dev_get_drvdata(dev);
  	struct azx *chip;
  	struct hda_intel *hda;
++<<<<<<< HEAD
 +	struct hda_bus *bus;
++=======
+ 	struct hdac_bus *bus;
++>>>>>>> 98d8fc6c5d36 (ALSA: hda - Move hda_i915.c from sound/pci/hda to sound/hda)
  	struct hda_codec *codec;
  	int status;
  
@@@ -897,15 -971,17 +978,22 @@@
  	if (chip->disabled || hda->init_failed)
  		return 0;
  
 -	if (!azx_has_pm_runtime(chip))
 +	if (!(chip->driver_caps & AZX_DCAPS_PM_RUNTIME))
  		return 0;
  
++<<<<<<< HEAD
 +	if (chip->driver_caps & AZX_DCAPS_I915_POWERWELL) {
 +		hda_display_power(hda, true);
++=======
+ 	if (chip->driver_caps & AZX_DCAPS_I915_POWERWELL
+ 		&& hda->need_i915_power) {
+ 		bus =  azx_bus(chip);
+ 		snd_hdac_display_power(bus, true);
++>>>>>>> 98d8fc6c5d36 (ALSA: hda - Move hda_i915.c from sound/pci/hda to sound/hda)
  		haswell_set_bclk(hda);
  		/* toggle codec wakeup bit for STATESTS read */
- 		hda_set_codec_wakeup(hda, true);
- 		hda_set_codec_wakeup(hda, false);
+ 		snd_hdac_set_codec_wakeup(bus, true);
+ 		snd_hdac_set_codec_wakeup(bus, false);
  	}
  
  	/* Read STATESTS before controller reset */
@@@ -1129,9 -1200,11 +1217,16 @@@ static int azx_free(struct azx *chip
  #ifdef CONFIG_SND_HDA_PATCH_LOADER
  	release_firmware(chip->fw);
  #endif
+ 
  	if (chip->driver_caps & AZX_DCAPS_I915_POWERWELL) {
++<<<<<<< HEAD
 +		hda_display_power(hda, false);
 +		hda_i915_exit(hda);
++=======
+ 		if (hda->need_i915_power)
+ 			snd_hdac_display_power(bus, false);
+ 		snd_hdac_i915_exit(bus);
++>>>>>>> 98d8fc6c5d36 (ALSA: hda - Move hda_i915.c from sound/pci/hda to sound/hda)
  	}
  	kfree(hda);
  
@@@ -1889,13 -1968,23 +1985,25 @@@ static int azx_probe_continue(struct az
  	int dev = chip->dev_index;
  	int err;
  
 -	hda->probe_continued = 1;
 -
 -	/* Request display power well for the HDA controller or codec. For
 -	 * Haswell/Broadwell, both the display HDA controller and codec need
 -	 * this power. For other platforms, like Baytrail/Braswell, only the
 -	 * display codec needs the power and it can be released after probe.
 -	 */
 +	/* Request power well for Haswell HDA controller and codec */
  	if (chip->driver_caps & AZX_DCAPS_I915_POWERWELL) {
++<<<<<<< HEAD
 +#ifdef CONFIG_SND_HDA_I915
 +		err = hda_i915_init(hda);
 +		if (err < 0)
 +			goto out_free;
 +		err = hda_display_power(hda, true);
++=======
+ 		/* Baytral/Braswell controllers don't need this power */
+ 		if (pci->device != 0x0f04 && pci->device != 0x2284)
+ 			hda->need_i915_power = 1;
+ 
+ 		err = snd_hdac_i915_init(bus);
+ 		if (err < 0)
+ 			goto i915_power_fail;
+ 
+ 		err = snd_hdac_display_power(bus, true);
++>>>>>>> 98d8fc6c5d36 (ALSA: hda - Move hda_i915.c from sound/pci/hda to sound/hda)
  		if (err < 0) {
  			dev_err(chip->card->dev,
  				"Cannot turn on display power on i915\n");
@@@ -1951,6 -2034,11 +2059,14 @@@
  		pm_runtime_put_noidle(&pci->dev);
  
  out_free:
++<<<<<<< HEAD
++=======
+ 	if (chip->driver_caps & AZX_DCAPS_I915_POWERWELL
+ 		&& !hda->need_i915_power)
+ 		snd_hdac_display_power(bus, false);
+ 
+ i915_power_fail:
++>>>>>>> 98d8fc6c5d36 (ALSA: hda - Move hda_i915.c from sound/pci/hda to sound/hda)
  	if (err < 0)
  		hda->init_failed = 1;
  	complete_all(&hda->probe_wait);
diff --cc sound/pci/hda/hda_intel.h
index b7f3c4225a4a,354f0bbed833..000000000000
--- a/sound/pci/hda/hda_intel.h
+++ b/sound/pci/hda/hda_intel.h
@@@ -16,8 -16,7 +16,12 @@@
  #ifndef __SOUND_HDA_INTEL_H
  #define __SOUND_HDA_INTEL_H
  
++<<<<<<< HEAD
 +#include <drm/i915_component.h>
 +#include "hda_priv.h"
++=======
+ #include "hda_controller.h"
++>>>>>>> 98d8fc6c5d36 (ALSA: hda - Move hda_i915.c from sound/pci/hda to sound/hda)
  
  struct hda_intel {
  	struct azx chip;
@@@ -43,35 -43,7 +47,41 @@@
  	/* secondary power domain for hdmi audio under vga device */
  	struct dev_pm_domain hdmi_pm_domain;
  
++<<<<<<< HEAD
 +	/* i915 component interface */
 +	struct i915_audio_component audio_component;
 +	int i915_power_refcount;
 +};
 +
 +#ifdef CONFIG_SND_HDA_I915
 +int hda_set_codec_wakeup(struct hda_intel *hda, bool enable);
 +int hda_display_power(struct hda_intel *hda, bool enable);
 +void haswell_set_bclk(struct hda_intel *hda);
 +int hda_i915_init(struct hda_intel *hda);
 +int hda_i915_exit(struct hda_intel *hda);
 +#else
 +static inline int hda_set_codec_wakeup(struct hda_intel *hda, bool enable)
 +{
 +	return 0;
 +}
 +static inline int hda_display_power(struct hda_intel *hda, bool enable)
 +{
 +	return 0;
 +}
 +static inline void haswell_set_bclk(struct hda_intel *hda) { return; }
 +static inline int hda_i915_init(struct hda_intel *hda)
 +{
 +	return -ENODEV;
 +}
 +static inline int hda_i915_exit(struct hda_intel *hda)
 +{
 +	return 0;
 +}
 +#endif
 +
++=======
+ 	bool need_i915_power:1; /* the hda controller needs i915 power */
+ };
+ 
++>>>>>>> 98d8fc6c5d36 (ALSA: hda - Move hda_i915.c from sound/pci/hda to sound/hda)
  #endif
* Unmerged path include/sound/hda_register.h
* Unmerged path include/sound/hdaudio.h
* Unmerged path sound/hda/Kconfig
* Unmerged path sound/hda/Makefile
* Unmerged path sound/pci/hda/hda_i915.c
diff --git a/include/sound/hda_i915.h b/include/sound/hda_i915.h
new file mode 100644
index 000000000000..adb5ba5cbd9d
--- /dev/null
+++ b/include/sound/hda_i915.h
@@ -0,0 +1,36 @@
+/*
+ * HD-Audio helpers to sync with i915 driver
+ */
+#ifndef __SOUND_HDA_I915_H
+#define __SOUND_HDA_I915_H
+
+#ifdef CONFIG_SND_HDA_I915
+int snd_hdac_set_codec_wakeup(struct hdac_bus *bus, bool enable);
+int snd_hdac_display_power(struct hdac_bus *bus, bool enable);
+int snd_hdac_get_display_clk(struct hdac_bus *bus);
+int snd_hdac_i915_init(struct hdac_bus *bus);
+int snd_hdac_i915_exit(struct hdac_bus *bus);
+#else
+static int snd_hdac_set_codec_wakeup(struct hdac_bus *bus, bool enable)
+{
+	return 0;
+}
+static inline int snd_hdac_display_power(struct hdac_bus *bus, bool enable)
+{
+	return 0;
+}
+static inline int snd_hdac_get_display_clk(struct hdac_bus *bus)
+{
+	return 0;
+}
+static inline int snd_hdac_i915_init(struct hdac_bus *bus)
+{
+	return -ENODEV;
+}
+static inline int snd_hdac_i915_exit(struct hdac_bus *bus)
+{
+	return 0;
+}
+#endif
+
+#endif /* __SOUND_HDA_I915_H */
* Unmerged path include/sound/hda_register.h
* Unmerged path include/sound/hdaudio.h
* Unmerged path sound/hda/Kconfig
* Unmerged path sound/hda/Makefile
diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c
new file mode 100644
index 000000000000..cb78c25585ac
--- /dev/null
+++ b/sound/hda/hdac_i915.c
@@ -0,0 +1,193 @@
+/*
+ *  hdac_i915.c - routines for sync between HD-A core and i915 display driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ *  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/component.h>
+#include <drm/i915_component.h>
+#include <sound/core.h>
+#include <sound/hdaudio.h>
+#include <sound/hda_i915.h>
+
+static struct i915_audio_component *hdac_acomp;
+
+int snd_hdac_set_codec_wakeup(struct hdac_bus *bus, bool enable)
+{
+	struct i915_audio_component *acomp = bus->audio_component;
+
+	if (!acomp->ops)
+		return -ENODEV;
+
+	if (!acomp->ops->codec_wake_override) {
+		dev_warn(bus->dev,
+			"Invalid codec wake callback\n");
+		return 0;
+	}
+
+	dev_dbg(bus->dev, "%s codec wakeup\n",
+		enable ? "enable" : "disable");
+
+	acomp->ops->codec_wake_override(acomp->dev, enable);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_set_codec_wakeup);
+
+int snd_hdac_display_power(struct hdac_bus *bus, bool enable)
+{
+	struct i915_audio_component *acomp = bus->audio_component;
+
+	if (!acomp->ops)
+		return -ENODEV;
+
+	dev_dbg(bus->dev, "display power %s\n",
+		enable ? "enable" : "disable");
+
+	if (enable) {
+		if (!bus->i915_power_refcount++)
+			acomp->ops->get_power(acomp->dev);
+	} else {
+		WARN_ON(!bus->i915_power_refcount);
+		if (!--bus->i915_power_refcount)
+			acomp->ops->put_power(acomp->dev);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_display_power);
+
+int snd_hdac_get_display_clk(struct hdac_bus *bus)
+{
+	struct i915_audio_component *acomp = bus->audio_component;
+
+	if (!acomp->ops)
+		return -ENODEV;
+
+	return acomp->ops->get_cdclk_freq(acomp->dev);
+}
+EXPORT_SYMBOL_GPL(snd_hdac_get_display_clk);
+
+static int hdac_component_master_bind(struct device *dev)
+{
+	struct i915_audio_component *acomp = hdac_acomp;
+	int ret;
+
+	ret = component_bind_all(dev, acomp);
+	if (ret < 0)
+		return ret;
+
+	if (WARN_ON(!(acomp->dev && acomp->ops && acomp->ops->get_power &&
+		      acomp->ops->put_power && acomp->ops->get_cdclk_freq))) {
+		ret = -EINVAL;
+		goto out_unbind;
+	}
+
+	/*
+	 * Atm, we don't support dynamic unbinding initiated by the child
+	 * component, so pin its containing module until we unbind.
+	 */
+	if (!try_module_get(acomp->ops->owner)) {
+		ret = -ENODEV;
+		goto out_unbind;
+	}
+
+	return 0;
+
+out_unbind:
+	component_unbind_all(dev, acomp);
+
+	return ret;
+}
+
+static void hdac_component_master_unbind(struct device *dev)
+{
+	struct i915_audio_component *acomp = hdac_acomp;
+
+	module_put(acomp->ops->owner);
+	component_unbind_all(dev, acomp);
+	WARN_ON(acomp->ops || acomp->dev);
+}
+
+static const struct component_master_ops hdac_component_master_ops = {
+	.bind = hdac_component_master_bind,
+	.unbind = hdac_component_master_unbind,
+};
+
+static int hdac_component_master_match(struct device *dev, void *data)
+{
+	/* i915 is the only supported component */
+	return !strcmp(dev->driver->name, "i915");
+}
+
+int snd_hdac_i915_init(struct hdac_bus *bus)
+{
+	struct component_match *match = NULL;
+	struct device *dev = bus->dev;
+	struct i915_audio_component *acomp;
+	int ret;
+
+	acomp = kzalloc(sizeof(*acomp), GFP_KERNEL);
+	if (!acomp)
+		return -ENOMEM;
+	bus->audio_component = acomp;
+	hdac_acomp = acomp;
+
+	component_match_add(dev, &match, hdac_component_master_match, bus);
+	ret = component_master_add_with_match(dev, &hdac_component_master_ops,
+					      match);
+	if (ret < 0)
+		goto out_err;
+
+	/*
+	 * Atm, we don't support deferring the component binding, so make sure
+	 * i915 is loaded and that the binding successfully completes.
+	 */
+	request_module("i915");
+
+	if (!acomp->ops) {
+		ret = -ENODEV;
+		goto out_master_del;
+	}
+	dev_dbg(dev, "bound to i915 component master\n");
+
+	return 0;
+out_master_del:
+	component_master_del(dev, &hdac_component_master_ops);
+out_err:
+	kfree(acomp);
+	bus->audio_component = NULL;
+	dev_err(dev, "failed to add i915 component master (%d)\n", ret);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_i915_init);
+
+int snd_hdac_i915_exit(struct hdac_bus *bus)
+{
+	struct device *dev = bus->dev;
+	struct i915_audio_component *acomp = bus->audio_component;
+
+	WARN_ON(bus->i915_power_refcount);
+	if (bus->i915_power_refcount > 0 && acomp && acomp->ops)
+		acomp->ops->put_power(acomp->dev);
+
+	component_master_del(dev, &hdac_component_master_ops);
+
+	kfree(acomp);
+	bus->audio_component = NULL;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_i915_exit);
diff --git a/sound/pci/hda/Kconfig b/sound/pci/hda/Kconfig
index 7f0f2c5a4e97..a7667a908350 100644
--- a/sound/pci/hda/Kconfig
+++ b/sound/pci/hda/Kconfig
@@ -155,11 +155,6 @@ config SND_HDA_CODEC_HDMI
 comment "Set to Y if you want auto-loading the codec driver"
 	depends on SND_HDA=y && SND_HDA_CODEC_HDMI=m
 
-config SND_HDA_I915
-	bool
-	default y
-	depends on DRM_I915
-
 config SND_HDA_CODEC_CIRRUS
 	tristate "Build Cirrus Logic codec support"
 	select SND_HDA_GENERIC
diff --git a/sound/pci/hda/Makefile b/sound/pci/hda/Makefile
index 96caaebfc19d..3f5eac5932c2 100644
--- a/sound/pci/hda/Makefile
+++ b/sound/pci/hda/Makefile
@@ -1,8 +1,6 @@
 snd-hda-intel-objs := hda_intel.o
 snd-hda-controller-objs := hda_controller.o
 snd-hda-tegra-objs := hda_tegra.o
-# for haswell power well
-snd-hda-intel-$(CONFIG_SND_HDA_I915) +=	hda_i915.o
 
 snd-hda-codec-y := hda_bind.o hda_codec.o hda_jack.o hda_auto_parser.o hda_sysfs.o
 snd-hda-codec-$(CONFIG_PROC_FS) += hda_proc.o
* Unmerged path sound/pci/hda/hda_i915.c
* Unmerged path sound/pci/hda/hda_intel.c
* Unmerged path sound/pci/hda/hda_intel.h
