bonding: remove unwanted lock for bond enslave and release

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author dingtianhong <dingtianhong@huawei.com>
commit c8517035445834350b8d498723b68f4e81286110
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/c8517035.failed

The bond_change_active_slave() and bond_select_active_slave()
do't need bond lock anymore, so remove the unwanted bond lock
for these two functions.

The bond_select_active_slave() will release and acquire
curr_slave_lock, so the curr_slave_lock need to protect
the function.

In bond enslave and bond release, the bond slave list is also
protected by RTNL, so bond lock is no need to exist, remove
the lock and clean the functions.

	Suggested-by: Jay Vosburgh <fubar@us.ibm.com>
	Suggested-by: Veaceslav Falico <vfalico@redhat.com>
	Signed-off-by: Ding Tianhong <dingtianhong@huawei.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c8517035445834350b8d498723b68f4e81286110)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
diff --cc drivers/net/bonding/bond_main.c
index b9b7314b42bb,1b1dd01fbf72..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -1852,6 -1584,15 +1852,18 @@@ int bond_enslave(struct net_device *bon
  		goto err_unregister;
  	}
  
++<<<<<<< HEAD
++=======
+ 	bond->slave_cnt++;
+ 	bond_compute_features(bond);
+ 	bond_set_carrier(bond);
+ 
+ 	if (USES_PRIMARY(bond->params.mode)) {
+ 		write_lock_bh(&bond->curr_slave_lock);
+ 		bond_select_active_slave(bond);
+ 		write_unlock_bh(&bond->curr_slave_lock);
+ 	}
++>>>>>>> c85170354458 (bonding: remove unwanted lock for bond enslave and release)
  
  	pr_info("%s: enslaving %s as a%s interface with a%s link.\n",
  		bond_dev->name, slave_dev->name,
@@@ -1865,18 -1606,11 +1877,22 @@@
  err_unregister:
  	netdev_rx_handler_unregister(slave_dev);
  
 -err_detach:
 -	if (!USES_PRIMARY(bond->params.mode))
 -		bond_hw_addr_flush(bond_dev, slave_dev);
 +err_dest_symlinks:
 +	bond_destroy_slave_symlinks(bond_dev, slave_dev);
  
++<<<<<<< HEAD
 +err_detach:
 +	if (!USES_PRIMARY(bond->params.mode)) {
 +		netif_addr_lock_bh(bond_dev);
 +		bond_mc_list_flush(bond_dev, slave_dev);
 +		netif_addr_unlock_bh(bond_dev);
 +	}
 +	bond_del_vlans_from_slave(bond, slave_dev);
 +	write_lock_bh(&bond->lock);
 +	bond_detach_slave(bond, new_slave);
++=======
+ 	vlan_vids_del_by_dev(slave_dev, bond_dev);
++>>>>>>> c85170354458 (bonding: remove unwanted lock for bond enslave and release)
  	if (bond->primary_slave == new_slave)
  		bond->primary_slave = NULL;
  	if (bond->curr_active_slave == new_slave) {
@@@ -1966,7 -1692,8 +1975,12 @@@ static int __bond_release_one(struct ne
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	write_unlock_bh(&bond->lock);
++=======
+ 	/* release the slave from its bond */
+ 	bond->slave_cnt--;
++>>>>>>> c85170354458 (bonding: remove unwanted lock for bond enslave and release)
  
  	bond_upper_dev_unlink(bond_dev, slave_dev);
  	/* unregister rx_handler early so bond_handle_frame wouldn't be called
@@@ -2036,19 -1760,24 +2050,16 @@@
  		bond_select_active_slave(bond);
  
  		write_unlock_bh(&bond->curr_slave_lock);
- 		read_unlock(&bond->lock);
- 		write_lock_bh(&bond->lock);
  	}
  
 -	if (!bond_has_slaves(bond)) {
 +	if (bond->slave_cnt == 0) {
  		bond_set_carrier(bond);
  		eth_hw_addr_random(bond_dev);
 -
 -		if (vlan_uses_dev(bond_dev)) {
 -			pr_warning("%s: Warning: clearing HW address of %s while it still has VLANs.\n",
 -				   bond_dev->name, bond_dev->name);
 -			pr_warning("%s: When re-adding slaves, make sure the bond's HW address matches its VLANs'.\n",
 -				   bond_dev->name);
 -		}
  	}
  
- 	write_unlock_bh(&bond->lock);
  	unblock_netpoll_tx();
 -	synchronize_rcu();
  
 -	if (!bond_has_slaves(bond)) {
 +	if (bond->slave_cnt == 0) {
  		call_netdevice_notifiers(NETDEV_CHANGEADDR, bond->dev);
  		call_netdevice_notifiers(NETDEV_RELEASE, bond->dev);
  	}
* Unmerged path drivers/net/bonding/bond_main.c
