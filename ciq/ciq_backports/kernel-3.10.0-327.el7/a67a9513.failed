NVMe: Meta data handling through submit io ioctl

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Keith Busch <keith.busch@intel.com>
commit a67a95134ffddd0ca4527c77e86375c3deb2938f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/a67a9513.failed

This adds support for the extended metadata formats through the submit
IO ioctl, and simplifies the rest when using a separate metadata format.

	Signed-off-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit a67a95134ffddd0ca4527c77e86375c3deb2938f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/nvme-core.c
#	include/linux/nvme.h
diff --cc drivers/block/nvme-core.c
index 29d2b5fb1975,e919de48ff25..000000000000
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@@ -1712,75 -1810,21 +1739,48 @@@ static int nvme_submit_io(struct nvme_n
  	c.rw.reftag = cpu_to_le32(io.reftag);
  	c.rw.apptag = cpu_to_le16(io.apptag);
  	c.rw.appmask = cpu_to_le16(io.appmask);
- 
- 	if (meta_len) {
- 		meta_iod = nvme_map_user_pages(dev, io.opcode & 1, io.metadata,
- 								meta_len);
- 		if (IS_ERR(meta_iod)) {
- 			status = PTR_ERR(meta_iod);
- 			meta_iod = NULL;
- 			goto unmap;
- 		}
- 
- 		meta_mem = dma_alloc_coherent(&dev->pci_dev->dev, meta_len,
- 						&meta_dma_addr, GFP_KERNEL);
- 		if (!meta_mem) {
- 			status = -ENOMEM;
- 			goto unmap;
- 		}
- 
- 		if (io.opcode & 1) {
- 			int meta_offset = 0;
- 
- 			for (i = 0; i < meta_iod->nents; i++) {
- 				meta = kmap_atomic(sg_page(&meta_iod->sg[i])) +
- 						meta_iod->sg[i].offset;
- 				memcpy(meta_mem + meta_offset, meta,
- 						meta_iod->sg[i].length);
- 				kunmap_atomic(meta);
- 				meta_offset += meta_iod->sg[i].length;
- 			}
- 		}
- 
- 		c.rw.metadata = cpu_to_le64(meta_dma_addr);
- 	}
- 
- 	length = nvme_setup_prps(dev, iod, length, GFP_KERNEL);
  	c.rw.prp1 = cpu_to_le64(sg_dma_address(iod->sg));
  	c.rw.prp2 = cpu_to_le64(iod->first_dma);
++<<<<<<< HEAD
 +
 +	if (length != (io.nblocks + 1) << ns->lba_shift)
 +		status = -ENOMEM;
 +	else
 +		status = nvme_submit_io_cmd(dev, &c, NULL);
 +
 +	if (meta_len) {
 +		if (status == NVME_SC_SUCCESS && !(io.opcode & 1)) {
 +			int meta_offset = 0;
 +
 +			for (i = 0; i < meta_iod->nents; i++) {
 +				meta = kmap_atomic(sg_page(&meta_iod->sg[i])) +
 +						meta_iod->sg[i].offset;
 +				memcpy(meta, meta_mem + meta_offset,
 +						meta_iod->sg[i].length);
 +				kunmap_atomic(meta);
 +				meta_offset += meta_iod->sg[i].length;
 +			}
 +		}
 +
 +		dma_free_coherent(&dev->pci_dev->dev, meta_len, meta_mem,
 +								meta_dma_addr);
 +	}
 +
++=======
+ 	c.rw.metadata = cpu_to_le64(meta_dma);
+ 	status = nvme_submit_io_cmd(dev, ns, &c, NULL);
++>>>>>>> a67a95134ffd (NVMe: Meta data handling through submit io ioctl)
   unmap:
- 	nvme_unmap_user_pages(dev, io.opcode & 1, iod);
+ 	nvme_unmap_user_pages(dev, write, iod);
  	nvme_free_iod(dev, iod);
- 
- 	if (meta_iod) {
- 		nvme_unmap_user_pages(dev, io.opcode & 1, meta_iod);
- 		nvme_free_iod(dev, meta_iod);
+ 	if (meta) {
+ 		if (status == NVME_SC_SUCCESS && !write) {
+ 			if (copy_to_user((void __user *)io.metadata, meta,
+ 								meta_len))
+ 				status = -EFAULT;
+ 		}
+ 		dma_free_coherent(&dev->pci_dev->dev, meta_len, meta, meta_dma);
  	}
- 
  	return status;
  }
  
@@@ -1923,7 -1987,9 +1923,13 @@@ static int nvme_revalidate_disk(struct 
  	struct nvme_dev *dev = ns->dev;
  	struct nvme_id_ns *id;
  	dma_addr_t dma_addr;
++<<<<<<< HEAD
 +	int lbaf;
++=======
+ 	u8 lbaf, pi_type;
+ 	u16 old_ms;
+ 	unsigned short bs;
++>>>>>>> a67a95134ffd (NVMe: Meta data handling through submit io ioctl)
  
  	id = dma_alloc_coherent(&dev->pci_dev->dev, 4096, &dma_addr,
  								GFP_KERNEL);
@@@ -1932,16 -1998,52 +1938,54 @@@
  								__func__);
  		return 0;
  	}
 -	if (nvme_identify(dev, ns->ns_id, 0, dma_addr)) {
 -		dev_warn(&dev->pci_dev->dev,
 -			"identify failed ns:%d, setting capacity to 0\n",
 -			ns->ns_id);
 -		memset(id, 0, sizeof(*id));
 -	}
  
 -	old_ms = ns->ms;
 -	lbaf = id->flbas & NVME_NS_FLBAS_LBA_MASK;
 +	if (nvme_identify(dev, ns->ns_id, 0, dma_addr))
 +		goto free;
 +
 +	lbaf = id->flbas & 0xf;
  	ns->lba_shift = id->lbaf[lbaf].ds;
++<<<<<<< HEAD
++=======
+ 	ns->ms = le16_to_cpu(id->lbaf[lbaf].ms);
+ 	ns->ext = ns->ms && (id->flbas & NVME_NS_FLBAS_META_EXT);
+ 
+ 	/*
+ 	 * If identify namespace failed, use default 512 byte block size so
+ 	 * block layer can use before failing read/write for 0 capacity.
+ 	 */
+ 	if (ns->lba_shift == 0)
+ 		ns->lba_shift = 9;
+ 	bs = 1 << ns->lba_shift;
+ 
+ 	/* XXX: PI implementation requires metadata equal t10 pi tuple size */
+ 	pi_type = ns->ms == sizeof(struct t10_pi_tuple) ?
+ 					id->dps & NVME_NS_DPS_PI_MASK : 0;
+ 
+ 	if (blk_get_integrity(disk) && (ns->pi_type != pi_type ||
+ 				ns->ms != old_ms ||
+ 				bs != queue_logical_block_size(disk->queue) ||
+ 				(ns->ms && ns->ext)))
+ 		blk_integrity_unregister(disk);
+ 
+ 	ns->pi_type = pi_type;
+ 	blk_queue_logical_block_size(ns->queue, bs);
+ 
+ 	if (ns->ms && !blk_get_integrity(disk) && (disk->flags & GENHD_FL_UP) &&
+ 								!ns->ext)
+ 		nvme_init_integrity(ns);
+ 
+ 	if (id->ncap == 0 || (ns->ms && !blk_get_integrity(disk)))
+ 		set_capacity(disk, 0);
+ 	else
+ 		set_capacity(disk, le64_to_cpup(&id->nsze) << (ns->lba_shift - 9));
+ 
+ 	if (dev->oncs & NVME_CTRL_ONCS_DSM)
+ 		nvme_config_discard(ns);
++>>>>>>> a67a95134ffd (NVMe: Meta data handling through submit io ioctl)
  
 +	blk_queue_logical_block_size(ns->queue, 1 << ns->lba_shift);
 +	set_capacity(disk, le64_to_cpup(&id->nsze) << (ns->lba_shift - 9));
 + free:
  	dma_free_coherent(&dev->pci_dev->dev, 4096, id, dma_addr);
  	return 0;
  }
diff --cc include/linux/nvme.h
index 0ee15565532d,8dbd05e70f09..000000000000
--- a/include/linux/nvme.h
+++ b/include/linux/nvme.h
@@@ -113,7 -117,9 +113,13 @@@ struct nvme_ns 
  
  	unsigned ns_id;
  	int lba_shift;
++<<<<<<< HEAD
 +	int ms;
++=======
+ 	u16 ms;
+ 	bool ext;
+ 	u8 pi_type;
++>>>>>>> a67a95134ffd (NVMe: Meta data handling through submit io ioctl)
  	u64 mode_select_num_blocks;
  	u32 mode_select_block_len;
  };
* Unmerged path drivers/block/nvme-core.c
* Unmerged path include/linux/nvme.h
