scsi: fix the {host,target,device}_blocked counter mess

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [scsi] fix the host/target/device_blocked counter mess (Ewan Milne) [1109348]
Rebuild_FUZZ: 88.24%
commit-author Christoph Hellwig <hch@lst.de>
commit cd9070c9c512ff7995f9019392e0ae548df3a088
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/cd9070c9.failed

Seems like these counters are missing any sort of synchronization for
updates, as a over 10 year old comment from me noted.  Fix this by
using atomic counters, and while we're at it also make sure they are
in the same cacheline as the _busy counters and not needlessly stored
to in every I/O completion.

With the new model the _busy counters can temporarily go negative,
so all the readers are updated to check for > 0 values.  Longer
term every successful I/O completion will reset the counters to zero,
so the temporarily negative values will not cause any harm.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
	Reviewed-by: Webb Scales <webbnh@hp.com>
	Acked-by: Jens Axboe <axboe@kernel.dk>
	Tested-by: Bart Van Assche <bvanassche@acm.org>
	Tested-by: Robert Elliott <elliott@hp.com>
(cherry picked from commit cd9070c9c512ff7995f9019392e0ae548df3a088)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/scsi_lib.c
#	drivers/scsi/scsi_sysfs.c
#	include/scsi/scsi_device.h
#	include/scsi/scsi_host.h
diff --cc drivers/scsi/scsi_lib.c
index 3970c9519e29,69da4cb5cb13..000000000000
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@@ -351,28 -353,35 +353,50 @@@ static void scsi_single_lun_run(struct 
  	spin_unlock_irqrestore(shost->host_lock, flags);
  }
  
- static inline int scsi_device_is_busy(struct scsi_device *sdev)
+ static inline bool scsi_device_is_busy(struct scsi_device *sdev)
  {
++<<<<<<< HEAD
 +	if (sdev->device_busy >= sdev->queue_depth || sdev->device_blocked)
 +		return 1;
 +
 +	return 0;
++=======
+ 	if (atomic_read(&sdev->device_busy) >= sdev->queue_depth)
+ 		return true;
+ 	if (atomic_read(&sdev->device_blocked) > 0)
+ 		return true;
+ 	return false;
++>>>>>>> cd9070c9c512 (scsi: fix the {host,target,device}_blocked counter mess)
  }
  
- static inline int scsi_target_is_busy(struct scsi_target *starget)
+ static inline bool scsi_target_is_busy(struct scsi_target *starget)
  {
- 	return ((starget->can_queue > 0 &&
- 		 atomic_read(&starget->target_busy) >= starget->can_queue) ||
- 		 starget->target_blocked);
+ 	if (starget->can_queue > 0 &&
+ 	    atomic_read(&starget->target_busy) >= starget->can_queue)
+ 		return true;
+ 	if (atomic_read(&starget->target_blocked) > 0)
+ 		return true;
+ 	return false;
  }
  
- static inline int scsi_host_is_busy(struct Scsi_Host *shost)
+ static inline bool scsi_host_is_busy(struct Scsi_Host *shost)
  {
++<<<<<<< HEAD
 +	if ((shost->can_queue > 0 && shost->host_busy >= shost->can_queue) ||
 +	    shost->host_blocked || shost->host_self_blocked)
 +		return 1;
 +
 +	return 0;
++=======
+ 	if (shost->can_queue > 0 &&
+ 	    atomic_read(&shost->host_busy) >= shost->can_queue)
+ 		return true;
+ 	if (atomic_read(&shost->host_blocked) > 0)
+ 		return true;
+ 	if (shost->host_self_blocked)
+ 		return true;
+ 	return false;
++>>>>>>> cd9070c9c512 (scsi: fix the {host,target,device}_blocked counter mess)
  }
  
  static void scsi_starved_list_run(struct Scsi_Host *shost)
@@@ -1260,26 -1261,33 +1284,44 @@@ static void scsi_unprep_fn(struct reque
  static inline int scsi_dev_queue_ready(struct request_queue *q,
  				  struct scsi_device *sdev)
  {
++<<<<<<< HEAD
 +	if (sdev->device_busy == 0 && sdev->device_blocked) {
 +		/*
 +		 * unblock after device_blocked iterates to zero
 +		 */
 +		if (--sdev->device_blocked == 0) {
 +			SCSI_LOG_MLQUEUE(3,
 +				   sdev_printk(KERN_INFO, sdev,
++=======
+ 	unsigned int busy;
+ 
+ 	busy = atomic_inc_return(&sdev->device_busy) - 1;
+ 	if (atomic_read(&sdev->device_blocked)) {
+ 		if (busy)
+ 			goto out_dec;
+ 
+ 		/*
+ 		 * unblock after device_blocked iterates to zero
+ 		 */
+ 		if (atomic_dec_return(&sdev->device_blocked) > 0) {
+ 			blk_delay_queue(q, SCSI_QUEUE_DELAY);
+ 			goto out_dec;
+ 		}
+ 		SCSI_LOG_MLQUEUE(3, sdev_printk(KERN_INFO, sdev,
++>>>>>>> cd9070c9c512 (scsi: fix the {host,target,device}_blocked counter mess)
  				   "unblocking device at zero depth\n"));
 +		} else {
 +			blk_delay_queue(q, SCSI_QUEUE_DELAY);
 +			return 0;
 +		}
  	}
 -
 -	if (busy >= sdev->queue_depth)
 -		goto out_dec;
 +	if (scsi_device_is_busy(sdev))
 +		return 0;
  
  	return 1;
 -out_dec:
 -	atomic_dec(&sdev->device_busy);
 -	return 0;
  }
  
 +
  /*
   * scsi_target_queue_ready: checks if there we can send commands to target
   * @sdev: scsi device on starget to check.
@@@ -1343,18 -1347,21 +1381,33 @@@ static inline int scsi_host_queue_ready
  				   struct Scsi_Host *shost,
  				   struct scsi_device *sdev)
  {
 -	unsigned int busy;
 +	int ret = 0;
 +
 +	spin_lock_irq(shost->host_lock);
  
  	if (scsi_host_in_recovery(shost))
++<<<<<<< HEAD
 +		goto out;
 +	if (shost->host_busy == 0 && shost->host_blocked) {
 +		/*
 +		 * unblock after host_blocked iterates to zero
 +		 */
 +		if (--shost->host_blocked != 0)
 +			goto out;
++=======
+ 		return 0;
+ 
+ 	busy = atomic_inc_return(&shost->host_busy) - 1;
+ 	if (atomic_read(&shost->host_blocked) > 0) {
+ 		if (busy)
+ 			goto starved;
+ 
+ 		/*
+ 		 * unblock after host_blocked iterates to zero
+ 		 */
+ 		if (atomic_dec_return(&shost->host_blocked) > 0)
+ 			goto out_dec;
++>>>>>>> cd9070c9c512 (scsi: fix the {host,target,device}_blocked counter mess)
  
  		SCSI_LOG_MLQUEUE(3,
  			shost_printk(KERN_INFO, shost,
diff --cc drivers/scsi/scsi_sysfs.c
index bf9f0637b768,209cae3097ea..000000000000
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@@ -582,14 -584,30 +582,38 @@@ static int scsi_sdev_check_buf_bit(cons
  /*
   * Create the actual show/store functions and data structures.
   */
++<<<<<<< HEAD
 +sdev_rd_attr (device_blocked, "%d\n");
 +sdev_rd_attr (device_busy, "%d\n");
++=======
++>>>>>>> cd9070c9c512 (scsi: fix the {host,target,device}_blocked counter mess)
  sdev_rd_attr (type, "%d\n");
  sdev_rd_attr (scsi_level, "%d\n");
  sdev_rd_attr (vendor, "%.8s\n");
  sdev_rd_attr (model, "%.16s\n");
  sdev_rd_attr (rev, "%.4s\n");
  
++<<<<<<< HEAD
++=======
+ static ssize_t
+ sdev_show_device_busy(struct device *dev, struct device_attribute *attr,
+ 		char *buf)
+ {
+ 	struct scsi_device *sdev = to_scsi_device(dev);
+ 	return snprintf(buf, 20, "%d\n", atomic_read(&sdev->device_busy));
+ }
+ static DEVICE_ATTR(device_busy, S_IRUGO, sdev_show_device_busy, NULL);
+ 
+ static ssize_t
+ sdev_show_device_blocked(struct device *dev, struct device_attribute *attr,
+ 		char *buf)
+ {
+ 	struct scsi_device *sdev = to_scsi_device(dev);
+ 	return snprintf(buf, 20, "%d\n", atomic_read(&sdev->device_blocked));
+ }
+ static DEVICE_ATTR(device_blocked, S_IRUGO, sdev_show_device_blocked, NULL);
+ 
++>>>>>>> cd9070c9c512 (scsi: fix the {host,target,device}_blocked counter mess)
  /*
   * TODO: can we make these symlinks to the block layer ones?
   */
diff --cc include/scsi/scsi_device.h
index 6f98072b7c27,0f853f2c9dc7..000000000000
--- a/include/scsi/scsi_device.h
+++ b/include/scsi/scsi_device.h
@@@ -83,9 -81,9 +83,15 @@@ struct scsi_device 
  	struct list_head    siblings;   /* list of all devices on this host */
  	struct list_head    same_target_siblings; /* just the devices sharing same target id */
  
++<<<<<<< HEAD
 +	/* this is now protected by the request_queue->queue_lock */
 +	unsigned int device_busy;	/* commands actually active on
 +					 * low-level. protected by queue_lock. */
++=======
+ 	atomic_t device_busy;		/* commands actually active on LLDD */
+ 	atomic_t device_blocked;	/* Device returned QUEUE_FULL. */
+ 
++>>>>>>> cd9070c9c512 (scsi: fix the {host,target,device}_blocked counter mess)
  	spinlock_t list_lock;
  	struct list_head cmd_list;	/* queue of in use SCSI Command structures */
  	struct list_head starved_entry;
diff --cc include/scsi/scsi_host.h
index ade595fc29cc,5e8ebc1ac12b..000000000000
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@@ -617,13 -582,11 +617,21 @@@ struct Scsi_Host 
  	 */
  	struct blk_queue_tag	*bqt;
  
++<<<<<<< HEAD
 +	/*
 +	 * The following two fields are protected with host_lock;
 +	 * however, eh routines can safely access during eh processing
 +	 * without acquiring the lock.
 +	 */
 +	unsigned int host_busy;		   /* commands actually active on low-level */
 +	unsigned int host_failed;	   /* commands that failed. */
++=======
+ 	atomic_t host_busy;		   /* commands actually active on low-level */
+ 	atomic_t host_blocked;
+ 
+ 	unsigned int host_failed;	   /* commands that failed.
+ 					      protected by host_lock */
++>>>>>>> cd9070c9c512 (scsi: fix the {host,target,device}_blocked counter mess)
  	unsigned int host_eh_scheduled;    /* EH scheduled without command */
      
  	unsigned int host_no;  /* Used for IOCTL_GET_IDLUN, /proc/scsi et al. */
diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
index 7501822c879a..73f4727ba034 100644
--- a/drivers/scsi/scsi.c
+++ b/drivers/scsi/scsi.c
@@ -713,17 +713,16 @@ void scsi_finish_command(struct scsi_cmnd *cmd)
 
 	scsi_device_unbusy(sdev);
 
-        /*
-         * Clear the flags which say that the device/host is no longer
-         * capable of accepting new commands.  These are set in scsi_queue.c
-         * for both the queue full condition on a device, and for a
-         * host full condition on the host.
-	 *
-	 * XXX(hch): What about locking?
-         */
-        shost->host_blocked = 0;
-	starget->target_blocked = 0;
-        sdev->device_blocked = 0;
+	/*
+	 * Clear the flags that say that the device/target/host is no longer
+	 * capable of accepting new commands.
+	 */
+	if (atomic_read(&shost->host_blocked))
+		atomic_set(&shost->host_blocked, 0);
+	if (atomic_read(&starget->target_blocked))
+		atomic_set(&starget->target_blocked, 0);
+	if (atomic_read(&sdev->device_blocked))
+		atomic_set(&sdev->device_blocked, 0);
 
 	/*
 	 * If we have valid sense information, then some kind of recovery
* Unmerged path drivers/scsi/scsi_lib.c
* Unmerged path drivers/scsi/scsi_sysfs.c
* Unmerged path include/scsi/scsi_device.h
* Unmerged path include/scsi/scsi_host.h
