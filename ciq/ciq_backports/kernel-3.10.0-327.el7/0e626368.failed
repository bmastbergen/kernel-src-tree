blk-mq: fix q->mq_usage_counter access race

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Akinobu Mita <akinobu.mita@gmail.com>
commit 0e6263682014d480b8d7b8c10287f4536066b54f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/0e626368.failed

CPU hotplug handling for blk-mq (blk_mq_queue_reinit) accesses
q->mq_usage_counter while freezing all request queues in all_q_list.
On the other hand, q->mq_usage_counter is deinitialized in
blk_mq_free_queue() before deleting the queue from all_q_list.

So if CPU hotplug event occurs in the window, percpu_ref_kill() is
called with q->mq_usage_counter which has already been marked dead,
and it triggers warning.  Fix it by deleting the queue from all_q_list
earlier than destroying q->mq_usage_counter.

	Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
	Reviewed-by: Ming Lei <tom.leiming@gmail.com>
	Cc: Ming Lei <tom.leiming@gmail.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 0e6263682014d480b8d7b8c10287f4536066b54f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq.c
diff --cc block/blk-mq.c
index c84efe52e26a,3a39184e82e5..000000000000
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@@ -1939,18 -2077,6 +1943,21 @@@ void blk_mq_free_queue(struct request_q
  	blk_mq_free_hw_queues(q, set);
  
  	percpu_ref_exit(&q->mq_usage_counter);
++<<<<<<< HEAD
 +
 +	free_percpu(q->queue_ctx);
 +	kfree(q->queue_hw_ctx);
 +	kfree(q->mq_map);
 +
 +	q->queue_ctx = NULL;
 +	q->queue_hw_ctx = NULL;
 +	q->mq_map = NULL;
 +
 +	mutex_lock(&all_q_mutex);
 +	list_del_init(&q->all_q_node);
 +	mutex_unlock(&all_q_mutex);
++=======
++>>>>>>> 0e6263682014 (blk-mq: fix q->mq_usage_counter access race)
  }
  
  /* Basically redo blk_mq_init_queue with queue frozen */
* Unmerged path block/blk-mq.c
