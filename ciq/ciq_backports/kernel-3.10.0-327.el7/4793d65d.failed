vfio: powerpc/spapr: powerpc/powernv/ioda: Define and implement DMA windows API

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Alexey Kardashevskiy <aik@ozlabs.ru>
commit 4793d65d1ac056d92b594d05c6aab3c040d913dd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/4793d65d.failed

This extends iommu_table_group_ops by a set of callbacks to support
dynamic DMA windows management.

create_table() creates a TCE table with specific parameters.
it receives iommu_table_group to know nodeid in order to allocate
TCE table memory closer to the PHB. The exact format of allocated
multi-level table might be also specific to the PHB model (not
the case now though).
This callback calculated the DMA window offset on a PCI bus from @num
and stores it in a just created table.

set_window() sets the window at specified TVT index + @num on PHB.

unset_window() unsets the window from specified TVT.

This adds a free() callback to iommu_table_ops to free the memory
(potentially a tree of tables) allocated for the TCE table.

create_table() and free() are supposed to be called once per
VFIO container and set_window()/unset_window() are supposed to be
called for every group in a container.

This adds IOMMU capabilities to iommu_table_group such as default
32bit window parameters and others. This makes use of new values in
vfio_iommu_spapr_tce. IODA1/P5IOC2 do not support DDW so they do not
advertise pagemasks to the userspace.

	Signed-off-by: Alexey Kardashevskiy <aik@ozlabs.ru>
	Acked-by: Alex Williamson <alex.williamson@redhat.com>
	Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 4793d65d1ac056d92b594d05c6aab3c040d913dd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/iommu.h
#	arch/powerpc/platforms/powernv/pci-ioda.c
#	arch/powerpc/platforms/powernv/pci-p5ioc2.c
#	drivers/vfio/vfio_iommu_spapr_tce.c
diff --cc arch/powerpc/include/asm/iommu.h
index 2d866433cb3d,e5541759a37d..000000000000
--- a/arch/powerpc/include/asm/iommu.h
+++ b/arch/powerpc/include/asm/iommu.h
@@@ -43,6 -44,39 +43,42 @@@
  extern int iommu_is_off;
  extern int iommu_force_on;
  
++<<<<<<< HEAD
++=======
+ struct iommu_table_ops {
+ 	/*
+ 	 * When called with direction==DMA_NONE, it is equal to clear().
+ 	 * uaddr is a linear map address.
+ 	 */
+ 	int (*set)(struct iommu_table *tbl,
+ 			long index, long npages,
+ 			unsigned long uaddr,
+ 			enum dma_data_direction direction,
+ 			struct dma_attrs *attrs);
+ #ifdef CONFIG_IOMMU_API
+ 	/*
+ 	 * Exchanges existing TCE with new TCE plus direction bits;
+ 	 * returns old TCE and DMA direction mask.
+ 	 * @tce is a physical address.
+ 	 */
+ 	int (*exchange)(struct iommu_table *tbl,
+ 			long index,
+ 			unsigned long *hpa,
+ 			enum dma_data_direction *direction);
+ #endif
+ 	void (*clear)(struct iommu_table *tbl,
+ 			long index, long npages);
+ 	/* get() returns a physical address */
+ 	unsigned long (*get)(struct iommu_table *tbl, long index);
+ 	void (*flush)(struct iommu_table *tbl);
+ 	void (*free)(struct iommu_table *tbl);
+ };
+ 
+ /* These are used by VIO */
+ extern struct iommu_table_ops iommu_table_lpar_multi_ops;
+ extern struct iommu_table_ops iommu_table_pseries_ops;
+ 
++>>>>>>> 4793d65d1ac0 (vfio: powerpc/spapr: powerpc/powernv/ioda: Define and implement DMA windows API)
  /*
   * IOMAP_MAX_ORDER defines the largest contiguous block
   * of dma space we can get.  IOMAP_MAX_ORDER = 13
@@@ -108,8 -142,50 +144,52 @@@ extern void iommu_free_table(struct iom
   */
  extern struct iommu_table *iommu_init_table(struct iommu_table * tbl,
  					    int nid);
++<<<<<<< HEAD
++=======
+ #define IOMMU_TABLE_GROUP_MAX_TABLES	1
+ 
+ struct iommu_table_group;
+ 
+ struct iommu_table_group_ops {
+ 	long (*create_table)(struct iommu_table_group *table_group,
+ 			int num,
+ 			__u32 page_shift,
+ 			__u64 window_size,
+ 			__u32 levels,
+ 			struct iommu_table **ptbl);
+ 	long (*set_window)(struct iommu_table_group *table_group,
+ 			int num,
+ 			struct iommu_table *tblnew);
+ 	long (*unset_window)(struct iommu_table_group *table_group,
+ 			int num);
+ 	/* Switch ownership from platform code to external user (e.g. VFIO) */
+ 	void (*take_ownership)(struct iommu_table_group *table_group);
+ 	/* Switch ownership from external user (e.g. VFIO) back to core */
+ 	void (*release_ownership)(struct iommu_table_group *table_group);
+ };
+ 
+ struct iommu_table_group_link {
+ 	struct list_head next;
+ 	struct rcu_head rcu;
+ 	struct iommu_table_group *table_group;
+ };
+ 
+ struct iommu_table_group {
+ 	/* IOMMU properties */
+ 	__u32 tce32_start;
+ 	__u32 tce32_size;
+ 	__u64 pgsizes; /* Bitmap of supported page sizes */
+ 	__u32 max_dynamic_windows_supported;
+ 	__u32 max_levels;
+ 
+ 	struct iommu_group *group;
+ 	struct iommu_table *tables[IOMMU_TABLE_GROUP_MAX_TABLES];
+ 	struct iommu_table_group_ops *ops;
+ };
+ 
++>>>>>>> 4793d65d1ac0 (vfio: powerpc/spapr: powerpc/powernv/ioda: Define and implement DMA windows API)
  #ifdef CONFIG_IOMMU_API
 -
 -extern void iommu_register_group(struct iommu_table_group *table_group,
 +extern void iommu_register_group(struct iommu_table *tbl,
  				 int pci_domain_number, unsigned long pe_num);
  extern int iommu_add_device(struct device *dev);
  extern void iommu_del_device(struct device *dev);
diff --cc arch/powerpc/platforms/powernv/pci-ioda.c
index 109e90d84e34,ee3e643c16bb..000000000000
--- a/arch/powerpc/platforms/powernv/pci-ioda.c
+++ b/arch/powerpc/platforms/powernv/pci-ioda.c
@@@ -23,6 -23,9 +23,12 @@@
  #include <linux/io.h>
  #include <linux/msi.h>
  #include <linux/memblock.h>
++<<<<<<< HEAD
++=======
+ #include <linux/iommu.h>
+ #include <linux/rculist.h>
+ #include <linux/sizes.h>
++>>>>>>> 4793d65d1ac0 (vfio: powerpc/spapr: powerpc/powernv/ioda: Define and implement DMA windows API)
  
  #include <asm/sections.h>
  #include <asm/io.h>
@@@ -654,19 -1816,77 +660,75 @@@ static void pnv_pci_ioda2_tce_invalidat
  	}
  }
  
 -static void pnv_pci_ioda2_tce_invalidate(struct iommu_table *tbl,
 -		unsigned long index, unsigned long npages, bool rm)
 +void pnv_pci_ioda_tce_invalidate(struct iommu_table *tbl,
 +				 __be64 *startp, __be64 *endp)
  {
 -	struct iommu_table_group_link *tgl;
 -
 -	list_for_each_entry_rcu(tgl, &tbl->it_group_list, next) {
 -		struct pnv_ioda_pe *pe = container_of(tgl->table_group,
 -				struct pnv_ioda_pe, table_group);
 -		__be64 __iomem *invalidate = rm ?
 -			(__be64 __iomem *)pe->phb->ioda.tce_inval_reg_phys :
 -			pe->phb->ioda.tce_inval_reg;
 -
 -		pnv_pci_ioda2_do_tce_invalidate(pe->pe_number, rm,
 -			invalidate, tbl->it_page_shift,
 -			index, npages);
 -	}
 +	struct pnv_ioda_pe *pe = container_of(tbl, struct pnv_ioda_pe,
 +					      tce32_table);
 +	struct pnv_phb *phb = pe->phb;
 +
 +	if (phb->type == PNV_PHB_IODA1)
 +		pnv_pci_ioda1_tce_invalidate(tbl, startp, endp);
 +	else
 +		pnv_pci_ioda2_tce_invalidate(pe, tbl, startp, endp);
  }
  
++<<<<<<< HEAD
++=======
+ static int pnv_ioda2_tce_build(struct iommu_table *tbl, long index,
+ 		long npages, unsigned long uaddr,
+ 		enum dma_data_direction direction,
+ 		struct dma_attrs *attrs)
+ {
+ 	int ret = pnv_tce_build(tbl, index, npages, uaddr, direction,
+ 			attrs);
+ 
+ 	if (!ret && (tbl->it_type & TCE_PCI_SWINV_CREATE))
+ 		pnv_pci_ioda2_tce_invalidate(tbl, index, npages, false);
+ 
+ 	return ret;
+ }
+ 
+ #ifdef CONFIG_IOMMU_API
+ static int pnv_ioda2_tce_xchg(struct iommu_table *tbl, long index,
+ 		unsigned long *hpa, enum dma_data_direction *direction)
+ {
+ 	long ret = pnv_tce_xchg(tbl, index, hpa, direction);
+ 
+ 	if (!ret && (tbl->it_type &
+ 			(TCE_PCI_SWINV_CREATE | TCE_PCI_SWINV_FREE)))
+ 		pnv_pci_ioda2_tce_invalidate(tbl, index, 1, false);
+ 
+ 	return ret;
+ }
+ #endif
+ 
+ static void pnv_ioda2_tce_free(struct iommu_table *tbl, long index,
+ 		long npages)
+ {
+ 	pnv_tce_free(tbl, index, npages);
+ 
+ 	if (tbl->it_type & TCE_PCI_SWINV_FREE)
+ 		pnv_pci_ioda2_tce_invalidate(tbl, index, npages, false);
+ }
+ 
+ static void pnv_ioda2_table_free(struct iommu_table *tbl)
+ {
+ 	pnv_pci_ioda2_table_free_pages(tbl);
+ 	iommu_free_table(tbl, "pnv");
+ }
+ 
+ static struct iommu_table_ops pnv_ioda2_iommu_ops = {
+ 	.set = pnv_ioda2_tce_build,
+ #ifdef CONFIG_IOMMU_API
+ 	.exchange = pnv_ioda2_tce_xchg,
+ #endif
+ 	.clear = pnv_ioda2_tce_free,
+ 	.get = pnv_tce_get,
+ 	.free = pnv_ioda2_table_free,
+ };
+ 
++>>>>>>> 4793d65d1ac0 (vfio: powerpc/spapr: powerpc/powernv/ioda: Define and implement DMA windows API)
  static void pnv_pci_ioda_setup_dma_pe(struct pnv_phb *phb,
  				      struct pnv_ioda_pe *pe, unsigned int base,
  				      unsigned int segs)
@@@ -740,14 -1953,22 +802,21 @@@
  		tbl->it_type |= (TCE_PCI_SWINV_CREATE |
  				 TCE_PCI_SWINV_FREE   |
  				 TCE_PCI_SWINV_PAIR);
++<<<<<<< HEAD
 +	}
++=======
+ 
+ 	tbl->it_ops = &pnv_ioda1_iommu_ops;
+ 	pe->table_group.tce32_start = tbl->it_offset << tbl->it_page_shift;
+ 	pe->table_group.tce32_size = tbl->it_size << tbl->it_page_shift;
++>>>>>>> 4793d65d1ac0 (vfio: powerpc/spapr: powerpc/powernv/ioda: Define and implement DMA windows API)
  	iommu_init_table(tbl, phb->hose->node);
 +	iommu_register_group(tbl, phb->hose->global_number, pe->pe_number);
  
 -	if (pe->flags & PNV_IODA_PE_DEV) {
 -		/*
 -		 * Setting table base here only for carrying iommu_group
 -		 * further down to let iommu_add_device() do the job.
 -		 * pnv_pci_ioda_dma_dev_setup will override it later anyway.
 -		 */
 -		set_iommu_table_base(&pe->pdev->dev, tbl);
 -		iommu_add_device(&pe->pdev->dev);
 -	} else if (pe->flags & (PNV_IODA_PE_BUS | PNV_IODA_PE_BUS_ALL))
 -		pnv_ioda_setup_bus_dma(pe, pe->pbus);
 +	if (pe->pdev)
 +		set_iommu_table_base_and_group(&pe->pdev->dev, tbl);
 +	else
 +		pnv_ioda_setup_bus_dma(pe, pe->pbus, true);
  
  	return;
   fail:
@@@ -756,12 -1977,53 +825,55 @@@
  		pe->tce32_seg = -1;
  	if (tce_mem)
  		__free_pages(tce_mem, get_order(TCE32_TABLE_SIZE * segs));
 -	if (tbl) {
 -		pnv_pci_unlink_table_and_group(tbl, &pe->table_group);
 -		iommu_free_table(tbl, "pnv");
 -	}
  }
  
++<<<<<<< HEAD
 +static void pnv_pci_ioda2_set_bypass(struct iommu_table *tbl, bool enable)
++=======
+ static long pnv_pci_ioda2_set_window(struct iommu_table_group *table_group,
+ 		int num, struct iommu_table *tbl)
+ {
+ 	struct pnv_ioda_pe *pe = container_of(table_group, struct pnv_ioda_pe,
+ 			table_group);
+ 	struct pnv_phb *phb = pe->phb;
+ 	int64_t rc;
+ 	const unsigned long size = tbl->it_indirect_levels ?
+ 			tbl->it_level_size : tbl->it_size;
+ 	const __u64 start_addr = tbl->it_offset << tbl->it_page_shift;
+ 	const __u64 win_size = tbl->it_size << tbl->it_page_shift;
+ 
+ 	pe_info(pe, "Setting up window#%d %llx..%llx pg=%x\n", num,
+ 			start_addr, start_addr + win_size - 1,
+ 			IOMMU_PAGE_SIZE(tbl));
+ 
+ 	/*
+ 	 * Map TCE table through TVT. The TVE index is the PE number
+ 	 * shifted by 1 bit for 32-bits DMA space.
+ 	 */
+ 	rc = opal_pci_map_pe_dma_window(phb->opal_id,
+ 			pe->pe_number,
+ 			(pe->pe_number << 1) + num,
+ 			tbl->it_indirect_levels + 1,
+ 			__pa(tbl->it_base),
+ 			size << 3,
+ 			IOMMU_PAGE_SIZE(tbl));
+ 	if (rc) {
+ 		pe_err(pe, "Failed to configure TCE table, err %ld\n", rc);
+ 		return rc;
+ 	}
+ 
+ 	pnv_pci_link_table_and_group(phb->hose->node, num,
+ 			tbl, &pe->table_group);
+ 	pnv_pci_ioda2_tce_invalidate_entire(pe);
+ 
+ 	return 0;
+ }
+ 
+ static void pnv_pci_ioda2_set_bypass(struct pnv_ioda_pe *pe, bool enable)
++>>>>>>> 4793d65d1ac0 (vfio: powerpc/spapr: powerpc/powernv/ioda: Define and implement DMA windows API)
  {
 +	struct pnv_ioda_pe *pe = container_of(tbl, struct pnv_ioda_pe,
 +					      tce32_table);
  	uint16_t window_id = (pe->pe_number << 1 ) + 1;
  	int64_t rc;
  
@@@ -799,57 -2050,286 +911,320 @@@
  		pe->tce_bypass_enabled = enable;
  }
  
++<<<<<<< HEAD
 +static void pnv_pci_ioda2_setup_bypass_pe(struct pnv_phb *phb,
 +					  struct pnv_ioda_pe *pe)
++=======
+ static long pnv_pci_ioda2_table_alloc_pages(int nid, __u64 bus_offset,
+ 		__u32 page_shift, __u64 window_size, __u32 levels,
+ 		struct iommu_table *tbl);
+ 
+ static long pnv_pci_ioda2_create_table(struct iommu_table_group *table_group,
+ 		int num, __u32 page_shift, __u64 window_size, __u32 levels,
+ 		struct iommu_table **ptbl)
+ {
+ 	struct pnv_ioda_pe *pe = container_of(table_group, struct pnv_ioda_pe,
+ 			table_group);
+ 	int nid = pe->phb->hose->node;
+ 	__u64 bus_offset = num ? pe->tce_bypass_base : table_group->tce32_start;
+ 	long ret;
+ 	struct iommu_table *tbl;
+ 
+ 	tbl = pnv_pci_table_alloc(nid);
+ 	if (!tbl)
+ 		return -ENOMEM;
+ 
+ 	ret = pnv_pci_ioda2_table_alloc_pages(nid,
+ 			bus_offset, page_shift, window_size,
+ 			levels, tbl);
+ 	if (ret) {
+ 		iommu_free_table(tbl, "pnv");
+ 		return ret;
+ 	}
+ 
+ 	tbl->it_ops = &pnv_ioda2_iommu_ops;
+ 	if (pe->phb->ioda.tce_inval_reg)
+ 		tbl->it_type |= (TCE_PCI_SWINV_CREATE | TCE_PCI_SWINV_FREE);
+ 
+ 	*ptbl = tbl;
+ 
+ 	return 0;
+ }
+ 
+ #ifdef CONFIG_IOMMU_API
+ static long pnv_pci_ioda2_unset_window(struct iommu_table_group *table_group,
+ 		int num)
+ {
+ 	struct pnv_ioda_pe *pe = container_of(table_group, struct pnv_ioda_pe,
+ 			table_group);
+ 	struct pnv_phb *phb = pe->phb;
+ 	long ret;
+ 
+ 	pe_info(pe, "Removing DMA window #%d\n", num);
+ 
+ 	ret = opal_pci_map_pe_dma_window(phb->opal_id, pe->pe_number,
+ 			(pe->pe_number << 1) + num,
+ 			0/* levels */, 0/* table address */,
+ 			0/* table size */, 0/* page size */);
+ 	if (ret)
+ 		pe_warn(pe, "Unmapping failed, ret = %ld\n", ret);
+ 	else
+ 		pnv_pci_ioda2_tce_invalidate_entire(pe);
+ 
+ 	pnv_pci_unlink_table_and_group(table_group->tables[num], table_group);
+ 
+ 	return ret;
+ }
+ 
+ static void pnv_ioda2_take_ownership(struct iommu_table_group *table_group)
++>>>>>>> 4793d65d1ac0 (vfio: powerpc/spapr: powerpc/powernv/ioda: Define and implement DMA windows API)
  {
 -	struct pnv_ioda_pe *pe = container_of(table_group, struct pnv_ioda_pe,
 -						table_group);
 +	/* TVE #1 is selected by PCI address bit 59 */
 +	pe->tce_bypass_base = 1ull << 59;
  
 -	iommu_take_ownership(table_group->tables[0]);
 -	pnv_pci_ioda2_set_bypass(pe, false);
 -}
 +	/* Install set_bypass callback for VFIO */
 +	pe->tce32_table.set_bypass = pnv_pci_ioda2_set_bypass;
  
++<<<<<<< HEAD
 +	/* Enable bypass by default */
 +	pnv_pci_ioda2_set_bypass(&pe->tce32_table, true);
++=======
+ static void pnv_ioda2_release_ownership(struct iommu_table_group *table_group)
+ {
+ 	struct pnv_ioda_pe *pe = container_of(table_group, struct pnv_ioda_pe,
+ 						table_group);
+ 
+ 	iommu_release_ownership(table_group->tables[0]);
+ 	pnv_pci_ioda2_set_bypass(pe, true);
+ }
+ 
+ static struct iommu_table_group_ops pnv_pci_ioda2_ops = {
+ 	.create_table = pnv_pci_ioda2_create_table,
+ 	.set_window = pnv_pci_ioda2_set_window,
+ 	.unset_window = pnv_pci_ioda2_unset_window,
+ 	.take_ownership = pnv_ioda2_take_ownership,
+ 	.release_ownership = pnv_ioda2_release_ownership,
+ };
+ #endif
+ 
+ static void pnv_pci_ioda_setup_opal_tce_kill(struct pnv_phb *phb)
+ {
+ 	const __be64 *swinvp;
+ 
+ 	/* OPAL variant of PHB3 invalidated TCEs */
+ 	swinvp = of_get_property(phb->hose->dn, "ibm,opal-tce-kill", NULL);
+ 	if (!swinvp)
+ 		return;
+ 
+ 	phb->ioda.tce_inval_reg_phys = be64_to_cpup(swinvp);
+ 	phb->ioda.tce_inval_reg = ioremap(phb->ioda.tce_inval_reg_phys, 8);
+ }
+ 
+ static __be64 *pnv_pci_ioda2_table_do_alloc_pages(int nid, unsigned shift,
+ 		unsigned levels, unsigned long limit,
+ 		unsigned long *current_offset)
+ {
+ 	struct page *tce_mem = NULL;
+ 	__be64 *addr, *tmp;
+ 	unsigned order = max_t(unsigned, shift, PAGE_SHIFT) - PAGE_SHIFT;
+ 	unsigned long allocated = 1UL << (order + PAGE_SHIFT);
+ 	unsigned entries = 1UL << (shift - 3);
+ 	long i;
+ 
+ 	tce_mem = alloc_pages_node(nid, GFP_KERNEL, order);
+ 	if (!tce_mem) {
+ 		pr_err("Failed to allocate a TCE memory, order=%d\n", order);
+ 		return NULL;
+ 	}
+ 	addr = page_address(tce_mem);
+ 	memset(addr, 0, allocated);
+ 
+ 	--levels;
+ 	if (!levels) {
+ 		*current_offset += allocated;
+ 		return addr;
+ 	}
+ 
+ 	for (i = 0; i < entries; ++i) {
+ 		tmp = pnv_pci_ioda2_table_do_alloc_pages(nid, shift,
+ 				levels, limit, current_offset);
+ 		if (!tmp)
+ 			break;
+ 
+ 		addr[i] = cpu_to_be64(__pa(tmp) |
+ 				TCE_PCI_READ | TCE_PCI_WRITE);
+ 
+ 		if (*current_offset >= limit)
+ 			break;
+ 	}
+ 
+ 	return addr;
+ }
+ 
+ static void pnv_pci_ioda2_table_do_free_pages(__be64 *addr,
+ 		unsigned long size, unsigned level);
+ 
+ static long pnv_pci_ioda2_table_alloc_pages(int nid, __u64 bus_offset,
+ 		__u32 page_shift, __u64 window_size, __u32 levels,
+ 		struct iommu_table *tbl)
+ {
+ 	void *addr;
+ 	unsigned long offset = 0, level_shift;
+ 	const unsigned window_shift = ilog2(window_size);
+ 	unsigned entries_shift = window_shift - page_shift;
+ 	unsigned table_shift = max_t(unsigned, entries_shift + 3, PAGE_SHIFT);
+ 	const unsigned long tce_table_size = 1UL << table_shift;
+ 
+ 	if (!levels || (levels > POWERNV_IOMMU_MAX_LEVELS))
+ 		return -EINVAL;
+ 
+ 	if ((window_size > memory_hotplug_max()) || !is_power_of_2(window_size))
+ 		return -EINVAL;
+ 
+ 	/* Adjust direct table size from window_size and levels */
+ 	entries_shift = (entries_shift + levels - 1) / levels;
+ 	level_shift = entries_shift + 3;
+ 	level_shift = max_t(unsigned, level_shift, PAGE_SHIFT);
+ 
+ 	/* Allocate TCE table */
+ 	addr = pnv_pci_ioda2_table_do_alloc_pages(nid, level_shift,
+ 			levels, tce_table_size, &offset);
+ 
+ 	/* addr==NULL means that the first level allocation failed */
+ 	if (!addr)
+ 		return -ENOMEM;
+ 
+ 	/*
+ 	 * First level was allocated but some lower level failed as
+ 	 * we did not allocate as much as we wanted,
+ 	 * release partially allocated table.
+ 	 */
+ 	if (offset < tce_table_size) {
+ 		pnv_pci_ioda2_table_do_free_pages(addr,
+ 				1ULL << (level_shift - 3), levels - 1);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	/* Setup linux iommu table */
+ 	pnv_pci_setup_iommu_table(tbl, addr, tce_table_size, bus_offset,
+ 			page_shift);
+ 	tbl->it_level_size = 1ULL << (level_shift - 3);
+ 	tbl->it_indirect_levels = levels - 1;
+ 
+ 	pr_devel("Created TCE table: ws=%08llx ts=%lx @%08llx\n",
+ 			window_size, tce_table_size, bus_offset);
+ 
+ 	return 0;
+ }
+ 
+ static void pnv_pci_ioda2_table_do_free_pages(__be64 *addr,
+ 		unsigned long size, unsigned level)
+ {
+ 	const unsigned long addr_ul = (unsigned long) addr &
+ 			~(TCE_PCI_READ | TCE_PCI_WRITE);
+ 
+ 	if (level) {
+ 		long i;
+ 		u64 *tmp = (u64 *) addr_ul;
+ 
+ 		for (i = 0; i < size; ++i) {
+ 			unsigned long hpa = be64_to_cpu(tmp[i]);
+ 
+ 			if (!(hpa & (TCE_PCI_READ | TCE_PCI_WRITE)))
+ 				continue;
+ 
+ 			pnv_pci_ioda2_table_do_free_pages(__va(hpa), size,
+ 					level - 1);
+ 		}
+ 	}
+ 
+ 	free_pages(addr_ul, get_order(size << 3));
+ }
+ 
+ static void pnv_pci_ioda2_table_free_pages(struct iommu_table *tbl)
+ {
+ 	const unsigned long size = tbl->it_indirect_levels ?
+ 			tbl->it_level_size : tbl->it_size;
+ 
+ 	if (!tbl->it_size)
+ 		return;
+ 
+ 	pnv_pci_ioda2_table_do_free_pages((__be64 *)tbl->it_base, size,
+ 			tbl->it_indirect_levels);
++>>>>>>> 4793d65d1ac0 (vfio: powerpc/spapr: powerpc/powernv/ioda: Define and implement DMA windows API)
  }
  
  static void pnv_pci_ioda2_setup_dma_pe(struct pnv_phb *phb,
  				       struct pnv_ioda_pe *pe)
  {
++<<<<<<< HEAD
 +	struct page *tce_mem = NULL;
 +	void *addr;
 +	const __be64 *swinvp;
 +	struct iommu_table *tbl;
 +	unsigned int tce_table_size, end;
++=======
+ 	struct iommu_table *tbl = NULL;
++>>>>>>> 4793d65d1ac0 (vfio: powerpc/spapr: powerpc/powernv/ioda: Define and implement DMA windows API)
  	int64_t rc;
  
  	/* We shouldn't already have a 32-bit DMA associated */
  	if (WARN_ON(pe->tce32_seg >= 0))
  		return;
  
++<<<<<<< HEAD
++=======
+ 	/* TVE #1 is selected by PCI address bit 59 */
+ 	pe->tce_bypass_base = 1ull << 59;
+ 
+ 	iommu_register_group(&pe->table_group, phb->hose->global_number,
+ 			pe->pe_number);
+ 
++>>>>>>> 4793d65d1ac0 (vfio: powerpc/spapr: powerpc/powernv/ioda: Define and implement DMA windows API)
  	/* The PE will reserve all possible 32-bits space */
  	pe->tce32_seg = 0;
 +	end = (1 << ilog2(phb->ioda.m32_pci_base));
 +	tce_table_size = (end / 0x1000) * 8;
  	pe_info(pe, "Setting up 32-bit TCE table at 0..%08x\n",
 -		phb->ioda.m32_pci_base);
 +		end);
  
++<<<<<<< HEAD
 +	/* Allocate TCE table */
 +	tce_mem = alloc_pages_node(phb->hose->node, GFP_KERNEL,
 +				   get_order(tce_table_size));
 +	if (!tce_mem) {
 +		pe_err(pe, "Failed to allocate a 32-bit TCE memory\n");
 +		goto fail;
 +	}
 +	addr = page_address(tce_mem);
 +	memset(addr, 0, tce_table_size);
++=======
+ 	/* Setup linux iommu table */
+ 	pe->table_group.tce32_start = 0;
+ 	pe->table_group.tce32_size = phb->ioda.m32_pci_base;
+ 	pe->table_group.max_dynamic_windows_supported =
+ 			IOMMU_TABLE_GROUP_MAX_TABLES;
+ 	pe->table_group.max_levels = POWERNV_IOMMU_MAX_LEVELS;
+ 	pe->table_group.pgsizes = SZ_4K | SZ_64K | SZ_16M;
+ 
+ 	rc = pnv_pci_ioda2_create_table(&pe->table_group, 0,
+ 			IOMMU_PAGE_SHIFT_4K,
+ 			pe->table_group.tce32_size,
+ 			POWERNV_IOMMU_DEFAULT_LEVELS, &tbl);
+ 	if (rc) {
+ 		pe_err(pe, "Failed to create 32-bit TCE table, err %ld", rc);
+ 		goto fail;
+ 	}
+ 	pnv_pci_link_table_and_group(phb->hose->node, 0, tbl, &pe->table_group);
++>>>>>>> 4793d65d1ac0 (vfio: powerpc/spapr: powerpc/powernv/ioda: Define and implement DMA windows API)
  
 -	tbl->it_ops = &pnv_ioda2_iommu_ops;
 -	iommu_init_table(tbl, phb->hose->node);
 -#ifdef CONFIG_IOMMU_API
 -	pe->table_group.ops = &pnv_pci_ioda2_ops;
 -#endif
 -
 -	rc = pnv_pci_ioda2_set_window(&pe->table_group, 0, tbl);
 +	/*
 +	 * Map TCE table through TVT. The TVE index is the PE number
 +	 * shifted by 1 bit for 32-bits DMA space.
 +	 */
 +	rc = opal_pci_map_pe_dma_window(phb->opal_id, pe->pe_number,
 +					pe->pe_number << 1, 1, __pa(addr),
 +					tce_table_size, 0x1000);
  	if (rc) {
  		pe_err(pe, "Failed to configure 32-bit TCE table,"
  		       " err %ld\n", rc);
diff --cc arch/powerpc/platforms/powernv/pci-p5ioc2.c
index 94ce3481490b,f2bdfea3b68d..000000000000
--- a/arch/powerpc/platforms/powernv/pci-p5ioc2.c
+++ b/arch/powerpc/platforms/powernv/pci-p5ioc2.c
@@@ -174,6 -198,15 +176,18 @@@ static void __init pnv_pci_init_p5ioc2_
  	pnv_pci_setup_iommu_table(&phb->p5ioc2.iommu_table,
  				  tce_mem, tce_size, 0,
  				  IOMMU_PAGE_SHIFT_4K);
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * We do not allocate iommu_table as we do not support
+ 	 * hotplug or SRIOV on P5IOC2 and therefore iommu_free_table()
+ 	 * should not be called for phb->p5ioc2.table_group.tables[0] ever.
+ 	 */
+ 	tbl = phb->p5ioc2.table_group.tables[0] = &phb->p5ioc2.iommu_table;
+ 	table_group = &phb->p5ioc2.table_group;
+ 	table_group->tce32_start = tbl->it_offset << tbl->it_page_shift;
+ 	table_group->tce32_size = tbl->it_size << tbl->it_page_shift;
++>>>>>>> 4793d65d1ac0 (vfio: powerpc/spapr: powerpc/powernv/ioda: Define and implement DMA windows API)
  }
  
  void __init pnv_pci_init_p5ioc2_hub(struct device_node *np)
diff --cc drivers/vfio/vfio_iommu_spapr_tce.c
index e65bc73cc8a8,6d919eb4251f..000000000000
--- a/drivers/vfio/vfio_iommu_spapr_tce.c
+++ b/drivers/vfio/vfio_iommu_spapr_tce.c
@@@ -107,9 -135,9 +107,13 @@@ static int tce_iommu_enable(struct tce_
  {
  	int ret = 0;
  	unsigned long locked;
++<<<<<<< HEAD
 +	struct iommu_table *tbl = container->tbl;
++=======
+ 	struct iommu_table_group *table_group;
++>>>>>>> 4793d65d1ac0 (vfio: powerpc/spapr: powerpc/powernv/ioda: Define and implement DMA windows API)
  
 -	if (!container->grp)
 +	if (!container->tbl)
  		return -ENXIO;
  
  	if (!current->mm)
@@@ -142,8 -170,19 +146,23 @@@
  	 * this is that we cannot tell here the amount of RAM used by the guest
  	 * as this information is only available from KVM and VFIO is
  	 * KVM agnostic.
+ 	 *
+ 	 * So we do not allow enabling a container without a group attached
+ 	 * as there is no way to know how much we should increment
+ 	 * the locked_vm counter.
  	 */
++<<<<<<< HEAD
 +	locked = (tbl->it_size << tbl->it_page_shift) >> PAGE_SHIFT;
++=======
+ 	table_group = iommu_group_get_iommudata(container->grp);
+ 	if (!table_group)
+ 		return -ENODEV;
+ 
+ 	if (!table_group->tce32_size)
+ 		return -EPERM;
+ 
+ 	locked = table_group->tce32_size >> PAGE_SHIFT;
++>>>>>>> 4793d65d1ac0 (vfio: powerpc/spapr: powerpc/powernv/ioda: Define and implement DMA windows API)
  	ret = try_increment_locked_vm(locked);
  	if (ret)
  		return ret;
@@@ -311,9 -355,14 +330,20 @@@ static long tce_iommu_ioctl(void *iommu
  
  	case VFIO_IOMMU_SPAPR_TCE_GET_INFO: {
  		struct vfio_iommu_spapr_tce_info info;
++<<<<<<< HEAD
 +		struct iommu_table *tbl = container->tbl;
 +
 +		if (WARN_ON(!tbl))
++=======
+ 		struct iommu_table_group *table_group;
+ 
+ 		if (WARN_ON(!container->grp))
+ 			return -ENXIO;
+ 
+ 		table_group = iommu_group_get_iommudata(container->grp);
+ 
+ 		if (!table_group)
++>>>>>>> 4793d65d1ac0 (vfio: powerpc/spapr: powerpc/powernv/ioda: Define and implement DMA windows API)
  			return -ENXIO;
  
  		minsz = offsetofend(struct vfio_iommu_spapr_tce_info,
* Unmerged path arch/powerpc/include/asm/iommu.h
* Unmerged path arch/powerpc/platforms/powernv/pci-ioda.c
* Unmerged path arch/powerpc/platforms/powernv/pci-p5ioc2.c
* Unmerged path drivers/vfio/vfio_iommu_spapr_tce.c
