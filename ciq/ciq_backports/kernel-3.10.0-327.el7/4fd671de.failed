gue: Call remcsum_adjust

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Tom Herbert <therbert@google.com>
commit 4fd671ded14f92cb8db0bf72747f4df508ba5e3d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/4fd671de.failed

Change remote checksum offload to call remcsum_adjust. This also
eliminates the optimization to skip an IP header as part of the
adjustment (really does not seem to be much of a win).

	Signed-off-by: Tom Herbert <therbert@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4fd671ded14f92cb8db0bf72747f4df508ba5e3d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/fou.c
diff --cc net/ipv4/fou.c
index 606c520ffd5a,b986298a7ba3..000000000000
--- a/net/ipv4/fou.c
+++ b/net/ipv4/fou.c
@@@ -62,8 -58,47 +62,52 @@@ static int fou_udp_recv(struct sock *sk
  	if (!fou)
  		return 1;
  
++<<<<<<< HEAD
 +	return fou_udp_encap_recv_deliver(skb, fou->protocol,
 +					  sizeof(struct udphdr));
++=======
+ 	fou_recv_pull(skb, sizeof(struct udphdr));
+ 
+ 	return -fou->protocol;
+ }
+ 
+ static struct guehdr *gue_remcsum(struct sk_buff *skb, struct guehdr *guehdr,
+ 				  void *data, size_t hdrlen, u8 ipproto)
+ {
+ 	__be16 *pd = data;
+ 	size_t start = ntohs(pd[0]);
+ 	size_t offset = ntohs(pd[1]);
+ 	size_t plen = hdrlen + max_t(size_t, offset + sizeof(u16), start);
+ 	__wsum delta;
+ 
+ 	if (skb->remcsum_offload) {
+ 		/* Already processed in GRO path */
+ 		skb->remcsum_offload = 0;
+ 		return guehdr;
+ 	}
+ 
+ 	if (!pskb_may_pull(skb, plen))
+ 		return NULL;
+ 	guehdr = (struct guehdr *)&udp_hdr(skb)[1];
+ 
+ 	if (unlikely(skb->ip_summed != CHECKSUM_COMPLETE))
+ 		__skb_checksum_complete(skb);
+ 
+ 	delta = remcsum_adjust((void *)guehdr + hdrlen,
+ 			       skb->csum, start, offset);
+ 
+ 	/* Adjust skb->csum since we changed the packet */
+ 	skb->csum = csum_add(skb->csum, delta);
+ 
+ 	return guehdr;
+ }
+ 
+ static int gue_control_message(struct sk_buff *skb, struct guehdr *guehdr)
+ {
+ 	/* No support yet */
+ 	kfree_skb(skb);
+ 	return 0;
++>>>>>>> 4fd671ded14f (gue: Call remcsum_adjust)
  }
  
  static int gue_udp_recv(struct sock *sk, struct sk_buff *skb)
@@@ -87,18 -124,50 +131,57 @@@
  	if (!pskb_may_pull(skb, len))
  		goto drop;
  
 -	/* guehdr may change after pull */
 -	guehdr = (struct guehdr *)&udp_hdr(skb)[1];
 +	uh = udp_hdr(skb);
 +	guehdr = (struct guehdr *)&uh[1];
  
 -	hdrlen = sizeof(struct guehdr) + optlen;
 +	if (guehdr->version != 0)
 +		goto drop;
  
 -	if (guehdr->version != 0 || validate_gue_flags(guehdr, optlen))
++<<<<<<< HEAD
 +	if (guehdr->flags) {
 +		/* No support yet */
  		goto drop;
 +	}
  
 +	return fou_udp_encap_recv_deliver(skb, guehdr->next_hdr, len);
++=======
+ 	hdrlen = sizeof(struct guehdr) + optlen;
+ 
+ 	ip_hdr(skb)->tot_len = htons(ntohs(ip_hdr(skb)->tot_len) - len);
+ 
+ 	/* Pull csum through the guehdr now . This can be used if
+ 	 * there is a remote checksum offload.
+ 	 */
+ 	skb_postpull_rcsum(skb, udp_hdr(skb), len);
+ 
+ 	data = &guehdr[1];
+ 
+ 	if (guehdr->flags & GUE_FLAG_PRIV) {
+ 		__be32 flags = *(__be32 *)(data + doffset);
+ 
+ 		doffset += GUE_LEN_PRIV;
+ 
+ 		if (flags & GUE_PFLAG_REMCSUM) {
+ 			guehdr = gue_remcsum(skb, guehdr, data + doffset,
+ 					     hdrlen, guehdr->proto_ctype);
+ 			if (!guehdr)
+ 				goto drop;
+ 
+ 			data = &guehdr[1];
+ 
+ 			doffset += GUE_PLEN_REMCSUM;
+ 		}
+ 	}
+ 
+ 	if (unlikely(guehdr->control))
+ 		return gue_control_message(skb, guehdr);
+ 
+ 	__skb_pull(skb, sizeof(struct udphdr) + hdrlen);
+ 	skb_reset_transport_header(skb);
+ 
+ 	return -guehdr->proto_ctype;
+ 
++>>>>>>> 4fd671ded14f (gue: Call remcsum_adjust)
  drop:
  	kfree_skb(skb);
  	return 0;
@@@ -149,6 -218,41 +232,44 @@@ out_unlock
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static struct guehdr *gue_gro_remcsum(struct sk_buff *skb, unsigned int off,
+ 				      struct guehdr *guehdr, void *data,
+ 				      size_t hdrlen, u8 ipproto)
+ {
+ 	__be16 *pd = data;
+ 	size_t start = ntohs(pd[0]);
+ 	size_t offset = ntohs(pd[1]);
+ 	size_t plen = hdrlen + max_t(size_t, offset + sizeof(u16), start);
+ 	__wsum delta;
+ 
+ 	if (skb->remcsum_offload)
+ 		return guehdr;
+ 
+ 	if (!NAPI_GRO_CB(skb)->csum_valid)
+ 		return NULL;
+ 
+ 	/* Pull checksum that will be written */
+ 	if (skb_gro_header_hard(skb, off + plen)) {
+ 		guehdr = skb_gro_header_slow(skb, off + plen, off);
+ 		if (!guehdr)
+ 			return NULL;
+ 	}
+ 
+ 	delta = remcsum_adjust((void *)guehdr + hdrlen,
+ 			       NAPI_GRO_CB(skb)->csum, start, offset);
+ 
+ 	/* Adjust skb->csum since we changed the packet */
+ 	skb->csum = csum_add(skb->csum, delta);
+ 	NAPI_GRO_CB(skb)->csum = csum_add(NAPI_GRO_CB(skb)->csum, delta);
+ 
+ 	skb->remcsum_offload = 1;
+ 
+ 	return guehdr;
+ }
+ 
++>>>>>>> 4fd671ded14f (gue: Call remcsum_adjust)
  static struct sk_buff **gue_gro_receive(struct sk_buff **head,
  					struct sk_buff *skb)
  {
* Unmerged path net/ipv4/fou.c
