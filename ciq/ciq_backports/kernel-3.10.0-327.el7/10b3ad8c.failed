net: Do txq_trans_update() in netdev_start_xmit()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] Do txq_trans_update() in netdev_start_xmit() (Alexander Duyck) [1205266]
Rebuild_FUZZ: 94.62%
commit-author David S. Miller <davem@davemloft.net>
commit 10b3ad8c21bb4b135768c30dd4c51a1c744da699
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/10b3ad8c.failed

That way we don't have to audit every call site to make sure it is
doing this properly.

	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 10b3ad8c21bb4b135768c30dd4c51a1c744da699)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wan/dlci.c
#	include/linux/netdevice.h
#	net/core/dev.c
#	net/core/netpoll.c
#	net/core/pktgen.c
#	net/packet/af_packet.c
#	net/sched/sch_teql.c
diff --cc drivers/net/wan/dlci.c
index 6a8a382c5f4c,6427e8283419..000000000000
--- a/drivers/net/wan/dlci.c
+++ b/drivers/net/wan/dlci.c
@@@ -197,8 -192,10 +197,15 @@@ static netdev_tx_t dlci_transmit(struc
  {
  	struct dlci_local *dlp = netdev_priv(dev);
  
++<<<<<<< HEAD
 +	if (skb)
 +		dlp->slave->netdev_ops->ndo_start_xmit(skb, dlp->slave);
++=======
+ 	if (skb) {
+ 		struct netdev_queue *txq = skb_get_tx_queue(dev, skb);
+ 		netdev_start_xmit(skb, dlp->slave, txq);
+ 	}
++>>>>>>> 10b3ad8c21bb (net: Do txq_trans_update() in netdev_start_xmit())
  	return NETDEV_TX_OK;
  }
  
diff --cc include/linux/netdevice.h
index dba59a041ff6,16171802ea7d..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -2979,8 -3430,40 +2979,45 @@@ extern int __init dev_proc_init(void)
  #define dev_proc_init() 0
  #endif
  
++<<<<<<< HEAD
 +extern int netdev_class_create_file(struct class_attribute *class_attr);
 +extern void netdev_class_remove_file(struct class_attribute *class_attr);
++=======
+ static inline netdev_tx_t __netdev_start_xmit(const struct net_device_ops *ops,
+ 					      struct sk_buff *skb, struct net_device *dev)
+ {
+ 	skb->xmit_more = 0;
+ 	return ops->ndo_start_xmit(skb, dev);
+ }
+ 
+ static inline netdev_tx_t netdev_start_xmit(struct sk_buff *skb, struct net_device *dev,
+ 					    struct netdev_queue *txq)
+ {
+ 	const struct net_device_ops *ops = dev->netdev_ops;
+ 	int rc;
+ 
+ 	rc = __netdev_start_xmit(ops, skb, dev);
+ 	if (rc == NETDEV_TX_OK)
+ 		txq_trans_update(txq);
+ 
+ 	return rc;
+ }
+ 
+ int netdev_class_create_file_ns(struct class_attribute *class_attr,
+ 				const void *ns);
+ void netdev_class_remove_file_ns(struct class_attribute *class_attr,
+ 				 const void *ns);
+ 
+ static inline int netdev_class_create_file(struct class_attribute *class_attr)
+ {
+ 	return netdev_class_create_file_ns(class_attr, NULL);
+ }
+ 
+ static inline void netdev_class_remove_file(struct class_attribute *class_attr)
+ {
+ 	netdev_class_remove_file_ns(class_attr, NULL);
+ }
++>>>>>>> 10b3ad8c21bb (net: Do txq_trans_update() in netdev_start_xmit())
  
  extern struct kobj_ns_type_operations net_ns_type_operations;
  
diff --cc net/core/dev.c
index 511d2dc85a3a,6392adaaa22f..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -2567,10 -2665,9 +2567,13 @@@ int dev_hard_start_xmit(struct sk_buff 
  			dev_queue_xmit_nit(skb, dev);
  
  		skb_len = skb->len;
++<<<<<<< HEAD
 +		rc = ops->ndo_start_xmit(skb, dev);
++=======
+ 		trace_net_dev_start_xmit(skb, dev);
+ 		rc = netdev_start_xmit(skb, dev, txq);
++>>>>>>> 10b3ad8c21bb (net: Do txq_trans_update() in netdev_start_xmit())
  		trace_net_dev_xmit(skb, rc, dev, skb_len);
- 		if (rc == NETDEV_TX_OK)
- 			txq_trans_update(txq);
  		return rc;
  	}
  
@@@ -2585,7 -2682,8 +2588,12 @@@ gso
  			dev_queue_xmit_nit(nskb, dev);
  
  		skb_len = nskb->len;
++<<<<<<< HEAD
 +		rc = ops->ndo_start_xmit(nskb, dev);
++=======
+ 		trace_net_dev_start_xmit(nskb, dev);
+ 		rc = netdev_start_xmit(nskb, dev, txq);
++>>>>>>> 10b3ad8c21bb (net: Do txq_trans_update() in netdev_start_xmit())
  		trace_net_dev_xmit(nskb, rc, dev, skb_len);
  		if (unlikely(rc != NETDEV_TX_OK)) {
  			if (rc & ~NETDEV_TX_MASK)
diff --cc net/core/netpoll.c
index 89e339d3631e,05bc57edaa81..000000000000
--- a/net/core/netpoll.c
+++ b/net/core/netpoll.c
@@@ -96,9 -91,7 +96,13 @@@ static int netpoll_start_xmit(struct sk
  		skb->vlan_tci = 0;
  	}
  
++<<<<<<< HEAD
 +	status = ops->ndo_start_xmit(skb, dev);
 +	if (status == NETDEV_TX_OK)
 +		txq_trans_update(txq);
++=======
+ 	status = netdev_start_xmit(skb, dev, txq);
++>>>>>>> 10b3ad8c21bb (net: Do txq_trans_update() in netdev_start_xmit())
  
  out:
  	return status;
diff --cc net/core/pktgen.c
index dc189dd7ca08,34bd2ff9f121..000000000000
--- a/net/core/pktgen.c
+++ b/net/core/pktgen.c
@@@ -3254,7 -3335,7 +3254,11 @@@ static void pktgen_xmit(struct pktgen_d
  		goto unlock;
  	}
  	atomic_inc(&(pkt_dev->skb->users));
++<<<<<<< HEAD
 +	ret = (*xmit)(pkt_dev->skb, odev);
++=======
+ 	ret = netdev_start_xmit(pkt_dev->skb, odev, txq);
++>>>>>>> 10b3ad8c21bb (net: Do txq_trans_update() in netdev_start_xmit())
  
  	switch (ret) {
  	case NETDEV_TX_OK:
diff --cc net/packet/af_packet.c
index 4450cf82adc9,fe305a05a8fc..000000000000
--- a/net/packet/af_packet.c
+++ b/net/packet/af_packet.c
@@@ -237,6 -237,43 +237,46 @@@ struct packet_skb_cb 
  static void __fanout_unlink(struct sock *sk, struct packet_sock *po);
  static void __fanout_link(struct sock *sk, struct packet_sock *po);
  
++<<<<<<< HEAD
++=======
+ static int packet_direct_xmit(struct sk_buff *skb)
+ {
+ 	struct net_device *dev = skb->dev;
+ 	netdev_features_t features;
+ 	struct netdev_queue *txq;
+ 	int ret = NETDEV_TX_BUSY;
+ 
+ 	if (unlikely(!netif_running(dev) ||
+ 		     !netif_carrier_ok(dev)))
+ 		goto drop;
+ 
+ 	features = netif_skb_features(skb);
+ 	if (skb_needs_linearize(skb, features) &&
+ 	    __skb_linearize(skb))
+ 		goto drop;
+ 
+ 	txq = skb_get_tx_queue(dev, skb);
+ 
+ 	local_bh_disable();
+ 
+ 	HARD_TX_LOCK(dev, txq, smp_processor_id());
+ 	if (!netif_xmit_frozen_or_drv_stopped(txq))
+ 		ret = netdev_start_xmit(skb, dev, txq);
+ 	HARD_TX_UNLOCK(dev, txq);
+ 
+ 	local_bh_enable();
+ 
+ 	if (!dev_xmit_complete(ret))
+ 		kfree_skb(skb);
+ 
+ 	return ret;
+ drop:
+ 	atomic_long_inc(&dev->tx_dropped);
+ 	kfree_skb(skb);
+ 	return NET_XMIT_DROP;
+ }
+ 
++>>>>>>> 10b3ad8c21bb (net: Do txq_trans_update() in netdev_start_xmit())
  static struct net_device *packet_cached_dev_get(struct packet_sock *po)
  {
  	struct net_device *dev;
diff --cc net/sched/sch_teql.c
index 474167162947,193dc2cba1ec..000000000000
--- a/net/sched/sch_teql.c
+++ b/net/sched/sch_teql.c
@@@ -317,8 -316,7 +317,12 @@@ restart
  				unsigned int length = qdisc_pkt_len(skb);
  
  				if (!netif_xmit_frozen_or_stopped(slave_txq) &&
++<<<<<<< HEAD
 +				    slave_ops->ndo_start_xmit(skb, slave) == NETDEV_TX_OK) {
 +					txq_trans_update(slave_txq);
++=======
+ 				    netdev_start_xmit(skb, slave, slave_txq) == NETDEV_TX_OK) {
++>>>>>>> 10b3ad8c21bb (net: Do txq_trans_update() in netdev_start_xmit())
  					__netif_tx_unlock(slave_txq);
  					master->slaves = NEXT_SLAVE(q);
  					netif_wake_queue(dev);
* Unmerged path drivers/net/wan/dlci.c
* Unmerged path include/linux/netdevice.h
* Unmerged path net/core/dev.c
* Unmerged path net/core/netpoll.c
* Unmerged path net/core/pktgen.c
* Unmerged path net/packet/af_packet.c
* Unmerged path net/sched/sch_teql.c
