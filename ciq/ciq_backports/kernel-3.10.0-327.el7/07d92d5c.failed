macvlan: allow to enqueue broadcast pkt on virtual device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Nicolas Dichtel <nicolas.dichtel@6wind.com>
commit 07d92d5cc977a7fe1e683e1d4a6f723f7f2778cb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/07d92d5c.failed

Since commit 412ca1550cbe ("macvlan: Move broadcasts into a work queue"), the
driver uses tx_queue_len of the master device as the limit of packets enqueuing.
Problem is that virtual drivers have this value set to 0, thus all broadcast
packets were rejected.
Because tx_queue_len was arbitrarily chosen, I replace it with a static limit
of 1000 (also arbitrarily chosen).

CC: Herbert Xu <herbert@gondor.apana.org.au>
	Reported-by: Thibaut Collet <thibaut.collet@6wind.com>
	Suggested-by: Thibaut Collet <thibaut.collet@6wind.com>
	Tested-by: Thibaut Collet <thibaut.collet@6wind.com>
	Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
	Acked-by: Herbert Xu <herbert@gondor.apana.org.au>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 07d92d5cc977a7fe1e683e1d4a6f723f7f2778cb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/macvlan.c
diff --cc drivers/net/macvlan.c
index 6af48508e014,726edabff26b..000000000000
--- a/drivers/net/macvlan.c
+++ b/drivers/net/macvlan.c
@@@ -30,10 -30,13 +30,11 @@@
  #include <linux/if_link.h>
  #include <linux/if_macvlan.h>
  #include <linux/hash.h>
 -#include <linux/workqueue.h>
  #include <net/rtnetlink.h>
  #include <net/xfrm.h>
 -#include <linux/netpoll.h>
  
  #define MACVLAN_HASH_SIZE	(1 << BITS_PER_BYTE)
+ #define MACVLAN_BC_QUEUE_LEN	1000
  
  struct macvlan_port {
  	struct net_device	*dev;
@@@ -180,6 -194,79 +181,82 @@@ static void macvlan_broadcast(struct sk
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void macvlan_process_broadcast(struct work_struct *w)
+ {
+ 	struct macvlan_port *port = container_of(w, struct macvlan_port,
+ 						 bc_work);
+ 	struct sk_buff *skb;
+ 	struct sk_buff_head list;
+ 
+ 	skb_queue_head_init(&list);
+ 
+ 	spin_lock_bh(&port->bc_queue.lock);
+ 	skb_queue_splice_tail_init(&port->bc_queue, &list);
+ 	spin_unlock_bh(&port->bc_queue.lock);
+ 
+ 	while ((skb = __skb_dequeue(&list))) {
+ 		const struct macvlan_dev *src = MACVLAN_SKB_CB(skb)->src;
+ 
+ 		rcu_read_lock();
+ 
+ 		if (!src)
+ 			/* frame comes from an external address */
+ 			macvlan_broadcast(skb, port, NULL,
+ 					  MACVLAN_MODE_PRIVATE |
+ 					  MACVLAN_MODE_VEPA    |
+ 					  MACVLAN_MODE_PASSTHRU|
+ 					  MACVLAN_MODE_BRIDGE);
+ 		else if (src->mode == MACVLAN_MODE_VEPA)
+ 			/* flood to everyone except source */
+ 			macvlan_broadcast(skb, port, src->dev,
+ 					  MACVLAN_MODE_VEPA |
+ 					  MACVLAN_MODE_BRIDGE);
+ 		else
+ 			/*
+ 			 * flood only to VEPA ports, bridge ports
+ 			 * already saw the frame on the way out.
+ 			 */
+ 			macvlan_broadcast(skb, port, src->dev,
+ 					  MACVLAN_MODE_VEPA);
+ 
+ 		rcu_read_unlock();
+ 
+ 		kfree_skb(skb);
+ 	}
+ }
+ 
+ static void macvlan_broadcast_enqueue(struct macvlan_port *port,
+ 				      struct sk_buff *skb)
+ {
+ 	struct sk_buff *nskb;
+ 	int err = -ENOMEM;
+ 
+ 	nskb = skb_clone(skb, GFP_ATOMIC);
+ 	if (!nskb)
+ 		goto err;
+ 
+ 	spin_lock(&port->bc_queue.lock);
+ 	if (skb_queue_len(&port->bc_queue) < MACVLAN_BC_QUEUE_LEN) {
+ 		__skb_queue_tail(&port->bc_queue, nskb);
+ 		err = 0;
+ 	}
+ 	spin_unlock(&port->bc_queue.lock);
+ 
+ 	if (err)
+ 		goto free_nskb;
+ 
+ 	schedule_work(&port->bc_work);
+ 	return;
+ 
+ free_nskb:
+ 	kfree_skb(nskb);
+ err:
+ 	atomic_long_inc(&skb->dev->rx_dropped);
+ }
+ 
++>>>>>>> 07d92d5cc977 (macvlan: allow to enqueue broadcast pkt on virtual device)
  /* called under rcu_read_lock() from netif_receive_skb */
  static rx_handler_result_t macvlan_handle_frame(struct sk_buff **pskb)
  {
* Unmerged path drivers/net/macvlan.c
