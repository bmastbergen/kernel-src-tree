net: remove inet6_reqsk_alloc

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] remove inet6_reqsk_alloc (Florian Westphal) [1151756]
Rebuild_FUZZ: 90.57%
commit-author Octavian Purdila <octavian.purdila@intel.com>
commit 476eab8251641ea2ae4666ca8a1436ebc2b8e9c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/476eab82.failed

Since pktops is only used for IPv6 only and opts is used for IPv4
only, we can move these fields into a union and this allows us to drop
the inet6_reqsk_alloc function as after this change it becomes
equivalent with inet_reqsk_alloc.

This patch also fixes a kmemcheck issue in the IPv6 stack: the flags
field was not annotated after a request_sock was allocated.

	Signed-off-by: Octavian Purdila <octavian.purdila@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 476eab8251641ea2ae4666ca8a1436ebc2b8e9c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/inet_sock.h
diff --cc include/net/inet_sock.h
index 15335bbe28a4,a829b77523cf..000000000000
--- a/include/net/inet_sock.h
+++ b/include/net/inet_sock.h
@@@ -89,8 -88,11 +89,16 @@@ struct inet_request_sock 
  				acked	   : 1,
  				no_srccheck: 1;
  	kmemcheck_bitfield_end(flags);
++<<<<<<< HEAD
 +	struct ip_options_rcu	*opt;
 +	struct sk_buff		*pktopts;
++=======
+ 	union {
+ 		struct ip_options_rcu	*opt;
+ 		struct sk_buff		*pktopts;
+ 	};
+ 	u32                     ir_mark;
++>>>>>>> 476eab825164 (net: remove inet6_reqsk_alloc)
  };
  
  static inline struct inet_request_sock *inet_rsk(const struct request_sock *sk)
diff --git a/include/linux/ipv6.h b/include/linux/ipv6.h
index fa160038cb46..92e81dcb9706 100644
--- a/include/linux/ipv6.h
+++ b/include/linux/ipv6.h
@@ -253,16 +253,6 @@ static inline struct ipv6_pinfo * inet6_sk(const struct sock *__sk)
 	return inet_sk(__sk)->pinet6;
 }
 
-static inline struct request_sock *inet6_reqsk_alloc(struct request_sock_ops *ops)
-{
-	struct request_sock *req = reqsk_alloc(ops);
-
-	if (req)
-		inet_rsk(req)->pktopts = NULL;
-
-	return req;
-}
-
 static inline struct raw6_sock *raw6_sk(const struct sock *sk)
 {
 	return (struct raw6_sock *)sk;
* Unmerged path include/net/inet_sock.h
diff --git a/net/dccp/ipv6.c b/net/dccp/ipv6.c
index b5ad684c6776..2e41dea3318c 100644
--- a/net/dccp/ipv6.c
+++ b/net/dccp/ipv6.c
@@ -386,7 +386,7 @@ static int dccp_v6_conn_request(struct sock *sk, struct sk_buff *skb)
 	if (sk_acceptq_is_full(sk) && inet_csk_reqsk_queue_young(sk) > 1)
 		goto drop;
 
-	req = inet6_reqsk_alloc(&dccp6_request_sock_ops);
+	req = inet_reqsk_alloc(&dccp6_request_sock_ops);
 	if (req == NULL)
 		goto drop;
 
diff --git a/net/ipv6/syncookies.c b/net/ipv6/syncookies.c
index d04d3f1dd9b7..937027d81347 100644
--- a/net/ipv6/syncookies.c
+++ b/net/ipv6/syncookies.c
@@ -181,7 +181,7 @@ struct sock *cookie_v6_check(struct sock *sk, struct sk_buff *skb)
 		goto out;
 
 	ret = NULL;
-	req = inet6_reqsk_alloc(&tcp6_request_sock_ops);
+	req = inet_reqsk_alloc(&tcp6_request_sock_ops);
 	if (!req)
 		goto out;
 
diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c
index fdc8f8ca98c1..5d539e9cded0 100644
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@ -998,7 +998,7 @@ static int tcp_v6_conn_request(struct sock *sk, struct sk_buff *skb)
 		goto drop;
 	}
 
-	req = inet6_reqsk_alloc(&tcp6_request_sock_ops);
+	req = inet_reqsk_alloc(&tcp6_request_sock_ops);
 	if (req == NULL)
 		goto drop;
 
