cxgb4vf: Fix sparse warnings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Hariprasad Shenai <hariprasad@chelsio.com>
commit 2ff2acf1fb65f1c83c41b67aba990c6d49a2274c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/2ff2acf1.failed

Fixes sparse warnings introduced in commit e85c9a7abfa407ed ("cxgb4/cxgb4vf: Add
code to calculate T5 BAR2 Offsets for SGE Queue Registers") and
df64e4d38c904dd3 ("cxgb4/cxgb4vf: Use new interfaces to calculate BAR2 SGE Queue
Register addresses") and few old ones

sparse warnings:
>> drivers/net/ethernet/chelsio/cxgb4vf/sge.c:1006:48: sparse: cast removes
>> address space of expression
>> drivers/net/ethernet/chelsio/cxgb4vf/sge.c:1006:48: sparse: incorrect type in
>> initializer (different address space)
>> drivers/net/ethernet/chelsio/cxgb4vf/sge.c:1020:40: sparse: incorrect type in
>> argument 1 (different base types)

	Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
	Reported-by: kbuild test robot <fengguang.wu@intel.com>
	Signed-off-by: Hariprasad Shenai <hariprasad@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2ff2acf1fb65f1c83c41b67aba990c6d49a2274c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/chelsio/cxgb4vf/sge.c
#	drivers/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c
diff --cc drivers/net/ethernet/chelsio/cxgb4vf/sge.c
index 4e4e43e07043,e0d711071afb..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4vf/sge.c
+++ b/drivers/net/ethernet/chelsio/cxgb4vf/sge.c
@@@ -948,14 -971,78 +948,85 @@@ static void write_sgl(const struct sk_b
  static inline void ring_tx_db(struct adapter *adapter, struct sge_txq *tq,
  			      int n)
  {
 -	/* Make sure that all writes to the TX Descriptors are committed
 -	 * before we tell the hardware about them.
 +	/*
 +	 * Warn if we write doorbells with the wrong priority and write
 +	 * descriptors before telling HW.
  	 */
 +	WARN_ON((QID(tq->cntxt_id) | PIDX(n)) & DBPRIO(1));
  	wmb();
++<<<<<<< HEAD
 +	t4_write_reg(adapter, T4VF_SGE_BASE_ADDR + SGE_VF_KDOORBELL,
 +		     QID(tq->cntxt_id) | PIDX(n));
++=======
+ 
+ 	/* If we don't have access to the new User Doorbell (T5+), use the old
+ 	 * doorbell mechanism; otherwise use the new BAR2 mechanism.
+ 	 */
+ 	if (unlikely(tq->bar2_addr == NULL)) {
+ 		u32 val = PIDX_V(n);
+ 
+ 		t4_write_reg(adapter, T4VF_SGE_BASE_ADDR + SGE_VF_KDOORBELL,
+ 			     QID_V(tq->cntxt_id) | val);
+ 	} else {
+ 		u32 val = PIDX_T5_V(n);
+ 
+ 		/* T4 and later chips share the same PIDX field offset within
+ 		 * the doorbell, but T5 and later shrank the field in order to
+ 		 * gain a bit for Doorbell Priority.  The field was absurdly
+ 		 * large in the first place (14 bits) so we just use the T5
+ 		 * and later limits and warn if a Queue ID is too large.
+ 		 */
+ 		WARN_ON(val & DBPRIO_F);
+ 
+ 		/* If we're only writing a single Egress Unit and the BAR2
+ 		 * Queue ID is 0, we can use the Write Combining Doorbell
+ 		 * Gather Buffer; otherwise we use the simple doorbell.
+ 		 */
+ 		if (n == 1 && tq->bar2_qid == 0) {
+ 			unsigned int index = (tq->pidx
+ 					      ? (tq->pidx - 1)
+ 					      : (tq->size - 1));
+ 			__be64 *src = (__be64 *)&tq->desc[index];
+ 			__be64 __iomem *dst = (__be64 __iomem *)(tq->bar2_addr +
+ 							 SGE_UDB_WCDOORBELL);
+ 			unsigned int count = EQ_UNIT / sizeof(__be64);
+ 
+ 			/* Copy the TX Descriptor in a tight loop in order to
+ 			 * try to get it to the adapter in a single Write
+ 			 * Combined transfer on the PCI-E Bus.  If the Write
+ 			 * Combine fails (say because of an interrupt, etc.)
+ 			 * the hardware will simply take the last write as a
+ 			 * simple doorbell write with a PIDX Increment of 1
+ 			 * and will fetch the TX Descriptor from memory via
+ 			 * DMA.
+ 			 */
+ 			while (count) {
+ 				/* the (__force u64) is because the compiler
+ 				 * doesn't understand the endian swizzling
+ 				 * going on
+ 				 */
+ 				writeq((__force u64)*src, dst);
+ 				src++;
+ 				dst++;
+ 				count--;
+ 			}
+ 		} else
+ 			writel(val | QID_V(tq->bar2_qid),
+ 			       tq->bar2_addr + SGE_UDB_KDOORBELL);
+ 
+ 		/* This Write Memory Barrier will force the write to the User
+ 		 * Doorbell area to be flushed.  This is needed to prevent
+ 		 * writes on different CPUs for the same queue from hitting
+ 		 * the adapter out of order.  This is required when some Work
+ 		 * Requests take the Write Combine Gather Buffer path (user
+ 		 * doorbell area offset [SGE_UDB_WCDOORBELL..+63]) and some
+ 		 * take the traditional path where we simply increment the
+ 		 * PIDX (User Doorbell area SGE_UDB_KDOORBELL) and have the
+ 		 * hardware DMA read the actual Work Request.
+ 		 */
+ 		wmb();
+ 	}
++>>>>>>> 2ff2acf1fb65 (cxgb4vf: Fix sparse warnings)
  }
  
  /**
diff --cc drivers/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c
index 871625f6cdbf,280b4a215849..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c
+++ b/drivers/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c
@@@ -209,15 -210,15 +209,23 @@@ int t4vf_wr_mbox_core(struct adapter *a
  
  			if (rpl) {
  				/* request bit in high-order BE word */
++<<<<<<< HEAD
 +				WARN_ON((be32_to_cpu(*(const u32 *)cmd)
 +					 & FW_CMD_REQUEST) == 0);
 +				get_mbox_rpl(adapter, rpl, size, mbox_data);
 +				WARN_ON((be32_to_cpu(*(u32 *)rpl)
 +					 & FW_CMD_REQUEST) != 0);
++=======
+ 				WARN_ON((be32_to_cpu(*(const __be32 *)cmd)
+ 					 & FW_CMD_REQUEST_F) == 0);
+ 				get_mbox_rpl(adapter, rpl, size, mbox_data);
+ 				WARN_ON((be32_to_cpu(*(__be32 *)rpl)
+ 					 & FW_CMD_REQUEST_F) != 0);
++>>>>>>> 2ff2acf1fb65 (cxgb4vf: Fix sparse warnings)
  			}
  			t4_write_reg(adapter, mbox_ctl,
 -				     MBOWNER_V(MBOX_OWNER_NONE));
 -			return -FW_CMD_RETVAL_G(v);
 +				     MBOWNER(MBOX_OWNER_NONE));
 +			return -FW_CMD_RETVAL_GET(v);
  		}
  	}
  
* Unmerged path drivers/net/ethernet/chelsio/cxgb4vf/sge.c
* Unmerged path drivers/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c
