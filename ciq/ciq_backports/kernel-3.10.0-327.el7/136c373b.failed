Revert "Bluetooth: Always wait for a connection on RFCOMM open()"

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Peter Hurley <peter@hurleysoftware.com>
commit 136c373bf0e8c445fc028427674817333df602e3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/136c373b.failed

This reverts commit 4a2fb3ecc7467c775b154813861f25a0ddc11aa0.

This is the second of a 3-patch revert, together with
Revert "Bluetooth: Remove rfcomm_carrier_raised()" and
Revert "Bluetooth: Move rfcomm_get_device() before rfcomm_dev_activate()".

Before commit cad348a17e170451ea8688b532a6ca3e98c63b60,
  Bluetooth: Implement .activate, .shutdown and .carrier_raised methods,
tty_port_block_til_ready() was open-coded in rfcomm_tty_install() as
part of the RFCOMM tty open().

Unfortunately, it did not implement non-blocking open nor CLOCAL open,
but rather always blocked for carrier. This is not the expected or
typical behavior for ttys, and prevents several common terminal
programming idioms from working (eg., opening in non-blocking
mode to initialize desired termios settings then re-opening for
connection).

Commit cad348a17e170451ea8688b532a6ca3e98c63b60,
  Bluetooth: Implement .activate, .shutdown and .carrier_raised methods,
added the necessary tty_port methods to use the default tty_port_open().
However, this triggered two important user-space regressions.

The first regression involves the complicated mechanism for reparenting
the rfcomm tty device to the ACL link device which represents an
open link to a specific bluetooth host. This regression causes ModemManager
to conclude the rfcomm tty device does not front a modem so it makes
no attempt to initialize an attached modem. This regression is
caused by the lack of a device_move() if the dlc is already open (and
not specifically related to the open-coded block_til_ready()).

A more appropriate solution is submitted in
"Bluetooth: Fix unsafe RFCOMM device parenting" and
"Bluetooth: Fix RFCOMM parent device for reused dlc"

The second regression involves "rfcomm bind" and wvdial (a ppp dialer).
rfcomm bind creates a device node for a /dev/rfcomm<n>. wvdial opens
that device in non-blocking mode (because it expects the connection
to have already been established). In addition, subsequent writes
to the rfcomm tty device fail (because the link is not yet connected;
rfcomm connection begins with the actual tty open()).

However, restoring the original behavior (in the patch which
this reverts) was undesirable.

Firstly, the original reporter notes that a trivial userspace
"workaround" already exists: rfcomm connect, which creates the
device node and establishes the expected connection.

Secondly, the failed writes occur because the rfcomm tty driver
does not buffer writes to an unconnected device; this contrasts with
the dozen of other tty drivers (in fact, all of them) that do just
that. The submitted patch "Bluetooth: Don't fail RFCOMM tty writes"
corrects this.

Thirdly, it was a long-standing bug to block on non-blocking open,
which is re-fixed by revert.

	Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
Tested-By: Alexander Holler <holler@ahsoftware.de>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 136c373bf0e8c445fc028427674817333df602e3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bluetooth/rfcomm/tty.c
diff --cc net/bluetooth/rfcomm/tty.c
index 62bd75eda078,32ef9f91965c..000000000000
--- a/net/bluetooth/rfcomm/tty.c
+++ b/net/bluetooth/rfcomm/tty.c
@@@ -58,7 -58,6 +58,10 @@@ struct rfcomm_dev 
  	uint			modem_status;
  
  	struct rfcomm_dlc	*dlc;
++<<<<<<< HEAD
 +	wait_queue_head_t       wait;
++=======
++>>>>>>> 136c373bf0e8 (Revert "Bluetooth: Always wait for a connection on RFCOMM open()")
  
  	struct device		*tty_dev;
  
@@@ -104,8 -103,55 +107,60 @@@ static void rfcomm_dev_destruct(struct 
  	module_put(THIS_MODULE);
  }
  
++<<<<<<< HEAD
 +static const struct tty_port_operations rfcomm_port_ops = {
 +	.destruct = rfcomm_dev_destruct,
++=======
+ static struct device *rfcomm_get_device(struct rfcomm_dev *dev)
+ {
+ 	struct hci_dev *hdev;
+ 	struct hci_conn *conn;
+ 
+ 	hdev = hci_get_route(&dev->dst, &dev->src);
+ 	if (!hdev)
+ 		return NULL;
+ 
+ 	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &dev->dst);
+ 
+ 	hci_dev_put(hdev);
+ 
+ 	return conn ? &conn->dev : NULL;
+ }
+ 
+ /* device-specific initialization: open the dlc */
+ static int rfcomm_dev_activate(struct tty_port *port, struct tty_struct *tty)
+ {
+ 	struct rfcomm_dev *dev = container_of(port, struct rfcomm_dev, port);
+ 
+ 	return rfcomm_dlc_open(dev->dlc, &dev->src, &dev->dst, dev->channel);
+ }
+ 
+ /* we block the open until the dlc->state becomes BT_CONNECTED */
+ static int rfcomm_dev_carrier_raised(struct tty_port *port)
+ {
+ 	struct rfcomm_dev *dev = container_of(port, struct rfcomm_dev, port);
+ 
+ 	return (dev->dlc->state == BT_CONNECTED);
+ }
+ 
+ /* device-specific cleanup: close the dlc */
+ static void rfcomm_dev_shutdown(struct tty_port *port)
+ {
+ 	struct rfcomm_dev *dev = container_of(port, struct rfcomm_dev, port);
+ 
+ 	if (dev->tty_dev->parent)
+ 		device_move(dev->tty_dev, NULL, DPM_ORDER_DEV_LAST);
+ 
+ 	/* close the dlc */
+ 	rfcomm_dlc_close(dev->dlc, 0);
+ }
+ 
+ static const struct tty_port_operations rfcomm_port_ops = {
+ 	.destruct = rfcomm_dev_destruct,
+ 	.activate = rfcomm_dev_activate,
+ 	.shutdown = rfcomm_dev_shutdown,
+ 	.carrier_raised = rfcomm_dev_carrier_raised,
++>>>>>>> 136c373bf0e8 (Revert "Bluetooth: Always wait for a connection on RFCOMM open()")
  };
  
  static struct rfcomm_dev *__rfcomm_dev_get(int id)
@@@ -228,7 -258,6 +283,10 @@@ static int rfcomm_dev_add(struct rfcomm
  
  	tty_port_init(&dev->port);
  	dev->port.ops = &rfcomm_port_ops;
++<<<<<<< HEAD
 +	init_waitqueue_head(&dev->wait);
++=======
++>>>>>>> 136c373bf0e8 (Revert "Bluetooth: Always wait for a connection on RFCOMM open()")
  
  	skb_queue_head_init(&dev->pending);
  
@@@ -559,31 -576,13 +617,41 @@@ static void rfcomm_dev_state_change(str
  	BT_DBG("dlc %p dev %p err %d", dlc, dev, err);
  
  	dev->err = err;
++<<<<<<< HEAD
 +	wake_up_interruptible(&dev->wait);
 +
 +	if (dlc->state == BT_CLOSED) {
 +		if (!dev->port.tty) {
 +			if (test_bit(RFCOMM_RELEASE_ONHUP, &dev->flags)) {
 +				/* Drop DLC lock here to avoid deadlock
 +				 * 1. rfcomm_dev_get will take rfcomm_dev_lock
 +				 *    but in rfcomm_dev_add there's lock order:
 +				 *    rfcomm_dev_lock -> dlc lock
 +				 * 2. tty_port_put will deadlock if it's
 +				 *    the last reference
 +				 */
 +				rfcomm_dlc_unlock(dlc);
 +				if (rfcomm_dev_get(dev->id) == NULL) {
 +					rfcomm_dlc_lock(dlc);
 +					return;
 +				}
 +
 +				rfcomm_dev_del(dev);
 +				tty_port_put(&dev->port);
 +				rfcomm_dlc_lock(dlc);
 +			}
 +		} else
 +			tty_hangup(dev->port.tty);
 +	}
++=======
+ 	if (dlc->state == BT_CONNECTED) {
+ 		device_move(dev->tty_dev, rfcomm_get_device(dev),
+ 			    DPM_ORDER_DEV_AFTER_PARENT);
+ 
+ 		wake_up_interruptible(&dev->port.open_wait);
+ 	} else if (dlc->state == BT_CLOSED)
+ 		tty_port_tty_hangup(&dev->port, false);
++>>>>>>> 136c373bf0e8 (Revert "Bluetooth: Always wait for a connection on RFCOMM open()")
  }
  
  static void rfcomm_dev_modem_status(struct rfcomm_dlc *dlc, u8 v24_sig)
* Unmerged path net/bluetooth/rfcomm/tty.c
