qla2xxx: Disable laser for ISP2031 while unloading driver.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Disable laser for ISP2031 while unloading driver (Chad Dupuis) [1187302]
Rebuild_FUZZ: 99.13%
commit-author Himanshu Madhani <himanshu.madhani@qlogic.com>
commit 2d5a4c344ad35eaaab59a5079eb6c62a843fb9d6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/2d5a4c34.failed

Nameserver data on FC switch is not refreshed when
qla2xxx driver is unloaded. Disabling laser for
ISP2031 will force FC switch to rescan ports and
clear fdmi entries from Nameserver.

	Signed-off-by: Himanshu Madhani <himanshu.madhani@qlogic.com>
	Signed-off-by: Saurav Kashyap <saurav.kashyap@qlogic.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 2d5a4c344ad35eaaab59a5079eb6c62a843fb9d6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_os.c
diff --cc drivers/scsi/qla2xxx/qla_os.c
index 86097f475799,e742890d5d1b..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -238,7 -238,9 +238,8 @@@ static int qla2xxx_eh_host_reset(struc
  
  static int qla2x00_change_queue_depth(struct scsi_device *, int, int);
  static int qla2x00_change_queue_type(struct scsi_device *, int);
 -static void qla2x00_clear_drv_active(struct qla_hw_data *);
  static void qla2x00_free_device(scsi_qla_host_t *);
+ static void qla83xx_disable_laser(scsi_qla_host_t *vha);
  
  struct scsi_host_template qla2xxx_driver_template = {
  	.module			= THIS_MODULE,
@@@ -3106,9 -3110,101 +3107,104 @@@ qla2x00_remove_one(struct pci_dev *pdev
  		if (ha->mqiobase)
  			iounmap(ha->mqiobase);
  
 -		if ((IS_QLA83XX(ha) || IS_QLA27XX(ha)) && ha->msixbase)
 +		if (IS_QLA83XX(ha) && ha->msixbase)
  			iounmap(ha->msixbase);
  	}
++<<<<<<< HEAD
++=======
+ }
+ 
+ static void
+ qla2x00_clear_drv_active(struct qla_hw_data *ha)
+ {
+ 	if (IS_QLA8044(ha)) {
+ 		qla8044_idc_lock(ha);
+ 		qla8044_clear_drv_active(ha);
+ 		qla8044_idc_unlock(ha);
+ 	} else if (IS_QLA82XX(ha)) {
+ 		qla82xx_idc_lock(ha);
+ 		qla82xx_clear_drv_active(ha);
+ 		qla82xx_idc_unlock(ha);
+ 	}
+ }
+ 
+ static void
+ qla2x00_remove_one(struct pci_dev *pdev)
+ {
+ 	scsi_qla_host_t *base_vha;
+ 	struct qla_hw_data  *ha;
+ 
+ 	base_vha = pci_get_drvdata(pdev);
+ 	ha = base_vha->hw;
+ 
+ 	/* Indicate device removal to prevent future board_disable and wait
+ 	 * until any pending board_disable has completed. */
+ 	set_bit(PFLG_DRIVER_REMOVING, &base_vha->pci_flags);
+ 	cancel_work_sync(&ha->board_disable);
+ 
+ 	/*
+ 	 * If the PCI device is disabled then there was a PCI-disconnect and
+ 	 * qla2x00_disable_board_on_pci_error has taken care of most of the
+ 	 * resources.
+ 	 */
+ 	if (!atomic_read(&pdev->enable_cnt)) {
+ 		scsi_host_put(base_vha->host);
+ 		kfree(ha);
+ 		pci_set_drvdata(pdev, NULL);
+ 		return;
+ 	}
+ 
+ 	qla2x00_wait_for_hba_ready(base_vha);
+ 
+ 	set_bit(UNLOADING, &base_vha->dpc_flags);
+ 
+ 	if (IS_QLAFX00(ha))
+ 		qlafx00_driver_shutdown(base_vha, 20);
+ 
+ 	qla2x00_delete_all_vps(ha, base_vha);
+ 
+ 	if (IS_QLA8031(ha)) {
+ 		ql_dbg(ql_dbg_p3p, base_vha, 0xb07e,
+ 		    "Clearing fcoe driver presence.\n");
+ 		if (qla83xx_clear_drv_presence(base_vha) != QLA_SUCCESS)
+ 			ql_dbg(ql_dbg_p3p, base_vha, 0xb079,
+ 			    "Error while clearing DRV-Presence.\n");
+ 	}
+ 
+ 	qla2x00_abort_all_cmds(base_vha, DID_NO_CONNECT << 16);
+ 
+ 	qla2x00_dfs_remove(base_vha);
+ 
+ 	qla84xx_put_chip(base_vha);
+ 
+ 	/* Laser should be disabled only for ISP2031 */
+ 	if (IS_QLA2031(ha))
+ 		qla83xx_disable_laser(base_vha);
+ 
+ 	/* Disable timer */
+ 	if (base_vha->timer_active)
+ 		qla2x00_stop_timer(base_vha);
+ 
+ 	base_vha->flags.online = 0;
+ 
+ 	qla2x00_destroy_deferred_work(ha);
+ 
+ 	qlt_remove_target(ha, base_vha);
+ 
+ 	qla2x00_free_sysfs_attr(base_vha, true);
+ 
+ 	fc_remove_host(base_vha->host);
+ 
+ 	scsi_remove_host(base_vha->host);
+ 
+ 	qla2x00_free_device(base_vha);
+ 
+ 	qla2x00_clear_drv_active(ha);
+ 
+ 	scsi_host_put(base_vha->host);
+ 
+ 	qla2x00_unmap_iobases(ha);
++>>>>>>> 2d5a4c344ad3 (qla2xxx: Disable laser for ISP2031 while unloading driver.)
  
  	pci_release_selected_regions(ha->pdev, ha->bars);
  	kfree(ha);
diff --git a/drivers/scsi/qla2xxx/qla_dbg.c b/drivers/scsi/qla2xxx/qla_dbg.c
index e7fa7d02d853..37ba50613b37 100644
--- a/drivers/scsi/qla2xxx/qla_dbg.c
+++ b/drivers/scsi/qla2xxx/qla_dbg.c
@@ -11,7 +11,7 @@
  * ----------------------------------------------------------------------
  * |             Level            |   Last Value Used  |     Holes	|
  * ----------------------------------------------------------------------
- * | Module Init and Probe        |       0x017d       | 0x004b,0x0141	|
+ * | Module Init and Probe        |       0x017d       | 0x0141		|
  * |                              |                    | 0x0144,0x0146	|
  * |                              |                    | 0x015b-0x0160	|
  * |                              |                    | 0x016e-0x0170	|
diff --git a/drivers/scsi/qla2xxx/qla_def.h b/drivers/scsi/qla2xxx/qla_def.h
index 823aec28928b..4f667188d01f 100644
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@ -191,6 +191,11 @@
 					     * reset-recovery completion is
 					     * second
 					     */
+/* ISP2031: Values for laser on/off */
+#define PORT_0_2031	0x00201340
+#define PORT_1_2031	0x00201350
+#define LASER_ON_2031	0x01800100
+#define LASER_OFF_2031	0x01800180
 
 /*
  * The ISP2312 v2 chip cannot access the FLASH/GPIO registers via MMIO in an
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
