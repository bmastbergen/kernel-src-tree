bonding: rework bond_ab_arp_probe() to use bond_for_each_slave()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Veaceslav Falico <vfalico@redhat.com>
commit 4087df87b868cef0dd19a9409b40fb9415503552
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/4087df87.failed

Currently it uses the hard-to-rcuify bond_for_each_slave_from(), and also
it doesn't check every slave for disrepencies between the actual
IS_UP(slave) and the slave->link == BOND_LINK_UP, but only till we find the
next suitable slave.

Fix this by using bond_for_each_slave() and storing the first good slave in
*before till we find the current_arp_slave, after that we store the first good
slave in new_slave. If new_slave is empty - use the slave stored in before,
and if it's also empty - then we didn't find any suitable slave.

Also, in the meanwhile, check for each slave status.

CC: Jay Vosburgh <fubar@us.ibm.com>
CC: Andy Gospodarek <andy@greyhouse.net>
	Signed-off-by: Veaceslav Falico <vfalico@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4087df87b868cef0dd19a9409b40fb9415503552)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
diff --cc drivers/net/bonding/bond_main.c
index 05a57077bb1c,3c96b1b10ba4..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -3010,8 -2761,9 +3010,14 @@@ do_failover
   */
  static void bond_ab_arp_probe(struct bonding *bond)
  {
++<<<<<<< HEAD
 +	struct slave *slave;
 +	int i;
++=======
+ 	struct slave *slave, *before = NULL, *new_slave = NULL;
+ 	struct list_head *iter;
+ 	bool found = false;
++>>>>>>> 4087df87b868 (bonding: rework bond_ab_arp_probe() to use bond_for_each_slave())
  
  	read_lock(&bond->curr_slave_lock);
  
@@@ -3041,17 -2793,12 +3047,25 @@@
  
  	bond_set_slave_inactive_flags(bond->current_arp_slave);
  
++<<<<<<< HEAD
 +	/* search for next candidate */
 +	bond_for_each_slave_from(bond, slave, i, bond->current_arp_slave->next) {
 +		if (IS_UP(slave->dev)) {
 +			slave->link = BOND_LINK_BACK;
 +			bond_set_slave_active_flags(slave);
 +			bond_arp_send_all(bond, slave);
 +			slave->jiffies = jiffies;
 +			bond->current_arp_slave = slave;
 +			break;
 +		}
- 
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
+ 		if (!found && !before && IS_UP(slave->dev))
+ 			before = slave;
++>>>>>>> 4087df87b868 (bonding: rework bond_ab_arp_probe() to use bond_for_each_slave())
+ 
+ 		if (found && !new_slave && IS_UP(slave->dev))
+ 			new_slave = slave;
  		/* if the link state is up at this point, we
  		 * mark it down - this can happen if we have
  		 * simultaneous link failures and
* Unmerged path drivers/net/bonding/bond_main.c
