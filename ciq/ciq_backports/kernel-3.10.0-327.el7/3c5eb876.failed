sfc: create vports for VFs and assign random MAC addresses

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Shradha Shah <sshah@solarflare.com>
commit 3c5eb87605e85146a78de589b5070a37862425db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/3c5eb876.failed

The parent PF creates vports for all its child VFs and adds MAC
addresses to these.  When the VF driver loads, it can make an MCDI
call to get the MAC address that the parent PF assigned it.

The parent PF also assigns a mac address to its own vport because
implicit creation of a vAdaptor will only work on evb ports with
MAC addresses assigned.

The vport MAC address needs to be stored in the PF's nic_data
struct as it can later be changed on the vadaptor (and its net_dev
struct). When removing a vport the original MAC address must be
deleted.

A new flag is needed in the VF data structure to identify whether
a vport has been assigned to the VF.  This is to determine whether
it needs to be un-assigned before freeing the vport.  Also,
attempting to un-assign a vport which is not assigned will result
in an EALREADY error.

	Signed-off-by: Shradha Shah <sshah@solarflare.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3c5eb87605e85146a78de589b5070a37862425db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/sfc/ef10_sriov.c
#	drivers/net/ethernet/sfc/nic.h
diff --cc drivers/net/ethernet/sfc/ef10_sriov.c
index 9e6a3e197e01,b9545bf03798..000000000000
--- a/drivers/net/ethernet/sfc/ef10_sriov.c
+++ b/drivers/net/ethernet/sfc/ef10_sriov.c
@@@ -13,7 -14,300 +13,317 @@@
  #include "nic.h"
  #include "mcdi_pcol.h"
  
++<<<<<<< HEAD
 +#ifdef CONFIG_SFC_SRIOV
++static int efx_ef10_pci_sriov_enable(struct efx_nic *efx, int num_vfs)
++=======
+ static int efx_ef10_evb_port_assign(struct efx_nic *efx, unsigned int port_id,
+ 				    unsigned int vf_fn)
++>>>>>>> 3c5eb87605e8 (sfc: create vports for VFs and assign random MAC addresses)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_EVB_PORT_ASSIGN_IN_LEN);
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 
+ 	MCDI_SET_DWORD(inbuf, EVB_PORT_ASSIGN_IN_PORT_ID, port_id);
+ 	MCDI_POPULATE_DWORD_2(inbuf, EVB_PORT_ASSIGN_IN_FUNCTION,
+ 			      EVB_PORT_ASSIGN_IN_PF, nic_data->pf_index,
+ 			      EVB_PORT_ASSIGN_IN_VF, vf_fn);
+ 
+ 	return efx_mcdi_rpc(efx, MC_CMD_EVB_PORT_ASSIGN, inbuf, sizeof(inbuf),
+ 			    NULL, 0, NULL);
+ }
+ 
+ static int efx_ef10_vport_add_mac(struct efx_nic *efx,
+ 				  unsigned int port_id, u8 *mac)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_ADD_MAC_ADDRESS_IN_LEN);
+ 
+ 	MCDI_SET_DWORD(inbuf, VPORT_ADD_MAC_ADDRESS_IN_VPORT_ID, port_id);
+ 	ether_addr_copy(MCDI_PTR(inbuf, VPORT_ADD_MAC_ADDRESS_IN_MACADDR), mac);
+ 
+ 	return efx_mcdi_rpc(efx, MC_CMD_VPORT_ADD_MAC_ADDRESS, inbuf,
+ 			    sizeof(inbuf), NULL, 0, NULL);
+ }
++#endif
+ 
+ static int efx_ef10_vport_del_mac(struct efx_nic *efx,
+ 				  unsigned int port_id, u8 *mac)
+ {
++<<<<<<< HEAD
++#ifdef CONFIG_SFC_SRIOV
++	if (num_vfs == 0)
++		return efx_ef10_pci_sriov_disable(efx);
++	else
++		return efx_ef10_pci_sriov_enable(efx, num_vfs);
++#else
++	return -EOPNOTSUPP;
++#endif
++=======
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_DEL_MAC_ADDRESS_IN_LEN);
+ 
+ 	MCDI_SET_DWORD(inbuf, VPORT_DEL_MAC_ADDRESS_IN_VPORT_ID, port_id);
+ 	ether_addr_copy(MCDI_PTR(inbuf, VPORT_DEL_MAC_ADDRESS_IN_MACADDR), mac);
+ 
+ 	return efx_mcdi_rpc(efx, MC_CMD_VPORT_DEL_MAC_ADDRESS, inbuf,
+ 			    sizeof(inbuf), NULL, 0, NULL);
+ }
+ 
+ static int efx_ef10_vswitch_alloc(struct efx_nic *efx, unsigned int port_id,
+ 				  unsigned int vswitch_type)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VSWITCH_ALLOC_IN_LEN);
+ 
+ 	MCDI_SET_DWORD(inbuf, VSWITCH_ALLOC_IN_UPSTREAM_PORT_ID, port_id);
+ 	MCDI_SET_DWORD(inbuf, VSWITCH_ALLOC_IN_TYPE, vswitch_type);
+ 	MCDI_SET_DWORD(inbuf, VSWITCH_ALLOC_IN_NUM_VLAN_TAGS, 0);
+ 	MCDI_POPULATE_DWORD_1(inbuf, VSWITCH_ALLOC_IN_FLAGS,
+ 			      VSWITCH_ALLOC_IN_FLAG_AUTO_PORT, 0);
+ 
+ 	return efx_mcdi_rpc(efx, MC_CMD_VSWITCH_ALLOC, inbuf, sizeof(inbuf),
+ 			    NULL, 0, NULL);
+ }
+ 
+ static int efx_ef10_vswitch_free(struct efx_nic *efx, unsigned int port_id)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VSWITCH_FREE_IN_LEN);
+ 
+ 	MCDI_SET_DWORD(inbuf, VSWITCH_FREE_IN_UPSTREAM_PORT_ID, port_id);
+ 
+ 	return efx_mcdi_rpc(efx, MC_CMD_VSWITCH_FREE, inbuf, sizeof(inbuf),
+ 			    NULL, 0, NULL);
+ }
+ 
+ static int efx_ef10_vport_alloc(struct efx_nic *efx,
+ 				unsigned int port_id_in,
+ 				unsigned int vport_type,
+ 				unsigned int *port_id_out)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_ALLOC_IN_LEN);
+ 	MCDI_DECLARE_BUF(outbuf, MC_CMD_VPORT_ALLOC_OUT_LEN);
+ 	size_t outlen;
+ 	int rc;
+ 
+ 	EFX_WARN_ON_PARANOID(!port_id_out);
+ 
+ 	MCDI_SET_DWORD(inbuf, VPORT_ALLOC_IN_UPSTREAM_PORT_ID, port_id_in);
+ 	MCDI_SET_DWORD(inbuf, VPORT_ALLOC_IN_TYPE, vport_type);
+ 	MCDI_SET_DWORD(inbuf, VPORT_ALLOC_IN_NUM_VLAN_TAGS, 0);
+ 	MCDI_POPULATE_DWORD_1(inbuf, VPORT_ALLOC_IN_FLAGS,
+ 			      VPORT_ALLOC_IN_FLAG_AUTO_PORT, 0);
+ 
+ 	rc = efx_mcdi_rpc(efx, MC_CMD_VPORT_ALLOC, inbuf, sizeof(inbuf),
+ 			  outbuf, sizeof(outbuf), &outlen);
+ 	if (rc)
+ 		return rc;
+ 	if (outlen < MC_CMD_VPORT_ALLOC_OUT_LEN)
+ 		return -EIO;
+ 
+ 	*port_id_out = MCDI_DWORD(outbuf, VPORT_ALLOC_OUT_VPORT_ID);
+ 	return 0;
+ }
+ 
+ static int efx_ef10_vport_free(struct efx_nic *efx, unsigned int port_id)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_FREE_IN_LEN);
+ 
+ 	MCDI_SET_DWORD(inbuf, VPORT_FREE_IN_VPORT_ID, port_id);
+ 
+ 	return efx_mcdi_rpc(efx, MC_CMD_VPORT_FREE, inbuf, sizeof(inbuf),
+ 			    NULL, 0, NULL);
+ }
+ 
+ static void efx_ef10_sriov_free_vf_vports(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	int i;
+ 
+ 	if (!nic_data->vf)
+ 		return;
+ 
+ 	for (i = 0; i < efx->vf_count; i++) {
+ 		struct ef10_vf *vf = nic_data->vf + i;
+ 
+ 		if (vf->vport_assigned) {
+ 			efx_ef10_evb_port_assign(efx, EVB_PORT_ID_NULL, i);
+ 			vf->vport_assigned = 0;
+ 		}
+ 
+ 		if (!is_zero_ether_addr(vf->mac)) {
+ 			efx_ef10_vport_del_mac(efx, vf->vport_id, vf->mac);
+ 			eth_zero_addr(vf->mac);
+ 		}
+ 
+ 		if (vf->vport_id) {
+ 			efx_ef10_vport_free(efx, vf->vport_id);
+ 			vf->vport_id = 0;
+ 		}
+ 	}
+ }
+ 
+ static void efx_ef10_sriov_free_vf_vswitching(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 
+ 	efx_ef10_sriov_free_vf_vports(efx);
+ 	kfree(nic_data->vf);
+ 	nic_data->vf = NULL;
+ }
+ 
+ static int efx_ef10_sriov_assign_vf_vport(struct efx_nic *efx,
+ 					  unsigned int vf_i)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	struct ef10_vf *vf = nic_data->vf + vf_i;
+ 	int rc;
+ 
+ 	if (WARN_ON_ONCE(!nic_data->vf))
+ 		return -EOPNOTSUPP;
+ 
+ 	rc = efx_ef10_vport_alloc(efx, EVB_PORT_ID_ASSIGNED,
+ 				  MC_CMD_VPORT_ALLOC_IN_VPORT_TYPE_NORMAL,
+ 				  &vf->vport_id);
+ 	if (rc)
+ 		return rc;
+ 
+ 	rc = efx_ef10_vport_add_mac(efx, vf->vport_id, vf->mac);
+ 	if (rc) {
+ 		eth_zero_addr(vf->mac);
+ 		return rc;
+ 	}
+ 
+ 	rc =  efx_ef10_evb_port_assign(efx, vf->vport_id, vf_i);
+ 	if (rc)
+ 		return rc;
+ 
+ 	vf->vport_assigned = 1;
+ 	return 0;
+ }
+ 
+ static int efx_ef10_sriov_alloc_vf_vswitching(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	unsigned int i;
+ 	int rc;
+ 
+ 	nic_data->vf = kcalloc(efx->vf_count, sizeof(struct ef10_vf),
+ 			       GFP_KERNEL);
+ 	if (!nic_data->vf)
+ 		return -ENOMEM;
+ 
+ 	for (i = 0; i < efx->vf_count; i++) {
+ 		random_ether_addr(nic_data->vf[i].mac);
+ 
+ 		rc = efx_ef10_sriov_assign_vf_vport(efx, i);
+ 		if (rc)
+ 			goto fail;
+ 	}
+ 
+ 	return 0;
+ fail:
+ 	efx_ef10_sriov_free_vf_vports(efx);
+ 	kfree(nic_data->vf);
+ 	nic_data->vf = NULL;
+ 	return rc;
+ }
+ 
+ static int efx_ef10_sriov_restore_vf_vswitching(struct efx_nic *efx)
+ {
+ 	unsigned int i;
+ 	int rc;
+ 
+ 	for (i = 0; i < efx->vf_count; i++) {
+ 		rc = efx_ef10_sriov_assign_vf_vport(efx, i);
+ 		if (rc)
+ 			goto fail;
+ 	}
+ 
+ 	return 0;
+ fail:
+ 	efx_ef10_sriov_free_vf_vswitching(efx);
+ 	return rc;
+ }
+ 
+ /* On top of the default firmware vswitch setup, create a VEB vswitch and
+  * expansion vport for use by this function.
+  */
+ int efx_ef10_vswitching_probe(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	struct net_device *net_dev = efx->net_dev;
+ 	int rc;
+ 
+ 	if (pci_sriov_get_totalvfs(efx->pci_dev) <= 0)
+ 		return 0; /* vswitch not needed as we have no VFs */
+ 
+ 	rc = efx_ef10_vswitch_alloc(efx, EVB_PORT_ID_ASSIGNED,
+ 				    MC_CMD_VSWITCH_ALLOC_IN_VSWITCH_TYPE_VEB);
+ 	if (rc)
+ 		goto fail1;
+ 
+ 	rc = efx_ef10_vport_alloc(efx, EVB_PORT_ID_ASSIGNED,
+ 				  MC_CMD_VPORT_ALLOC_IN_VPORT_TYPE_NORMAL,
+ 				  &nic_data->vport_id);
+ 	if (rc)
+ 		goto fail2;
+ 
+ 	rc = efx_ef10_vport_add_mac(efx, nic_data->vport_id, net_dev->dev_addr);
+ 	if (rc)
+ 		goto fail3;
+ 
+ 	ether_addr_copy(nic_data->vport_mac, net_dev->dev_addr);
+ 
+ 	return 0;
+ fail3:
+ 	efx_ef10_vport_free(efx, nic_data->vport_id);
+ 	nic_data->vport_id = EVB_PORT_ID_ASSIGNED;
+ fail2:
+ 	efx_ef10_vswitch_free(efx, EVB_PORT_ID_ASSIGNED);
+ fail1:
+ 	return rc;
+ }
+ 
+ int efx_ef10_vswitching_restore(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	int rc;
+ 
+ 	if (!nic_data->must_probe_vswitching)
+ 		return 0;
+ 
+ 	rc = efx_ef10_vswitching_probe(efx);
+ 	if (rc)
+ 		goto fail;
+ 
+ 	rc = efx_ef10_sriov_restore_vf_vswitching(efx);
+ 	if (rc)
+ 		goto fail;
+ 
+ 	nic_data->must_probe_vswitching = false;
+ fail:
+ 	return rc;
+ }
+ 
+ void efx_ef10_vswitching_remove(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 
+ 	efx_ef10_sriov_free_vf_vswitching(efx);
+ 
+ 	if (nic_data->vport_id == EVB_PORT_ID_ASSIGNED)
+ 		return; /* No vswitch was ever created */
+ 
+ 	if (!is_zero_ether_addr(nic_data->vport_mac)) {
+ 		efx_ef10_vport_del_mac(efx, nic_data->vport_id,
+ 				       efx->net_dev->dev_addr);
+ 		eth_zero_addr(nic_data->vport_mac);
+ 	}
+ 	efx_ef10_vport_free(efx, nic_data->vport_id);
+ 	nic_data->vport_id = EVB_PORT_ID_ASSIGNED;
+ 
+ 	efx_ef10_vswitch_free(efx, nic_data->vport_id);
++>>>>>>> 3c5eb87605e8 (sfc: create vports for VFs and assign random MAC addresses)
+ }
+ 
  static int efx_ef10_pci_sriov_enable(struct efx_nic *efx, int num_vfs)
  {
  	int rc = 0;
diff --cc drivers/net/ethernet/sfc/nic.h
index ce965cc22a3b,e833e973b79d..000000000000
--- a/drivers/net/ethernet/sfc/nic.h
+++ b/drivers/net/ethernet/sfc/nic.h
@@@ -492,6 -494,11 +492,14 @@@ enum 
   * @rx_dpcpu_fw_id: Firmware ID of the RxDPCPU
   * @tx_dpcpu_fw_id: Firmware ID of the TxDPCPU
   * @vport_id: The function's vport ID, only relevant for PFs
++<<<<<<< HEAD
++=======
+  * @must_probe_vswitching: Flag: vswitching has yet to be setup after MC reboot
+  * @pf_index: The number for this PF, or the parent PF if this is a VF
+ #ifdef CONFIG_SFC_SRIOV
+  * @vf: Pointer to VF data structure
+ #endif
++>>>>>>> 3c5eb87605e8 (sfc: create vports for VFs and assign random MAC addresses)
   */
  struct efx_ef10_nic_data {
  	struct efx_buffer mcdi_buf;
@@@ -513,6 -520,12 +521,15 @@@
  	unsigned int rx_dpcpu_fw_id;
  	unsigned int tx_dpcpu_fw_id;
  	unsigned int vport_id;
++<<<<<<< HEAD
++=======
+ 	bool must_probe_vswitching;
+ 	unsigned int pf_index;
+ #ifdef CONFIG_SFC_SRIOV
+ 	struct ef10_vf *vf;
+ #endif
+ 	u8 vport_mac[ETH_ALEN];
++>>>>>>> 3c5eb87605e8 (sfc: create vports for VFs and assign random MAC addresses)
  };
  
  int efx_init_sriov(void);
* Unmerged path drivers/net/ethernet/sfc/ef10_sriov.c
diff --git a/drivers/net/ethernet/sfc/ef10_sriov.h b/drivers/net/ethernet/sfc/ef10_sriov.h
index 6ea115e3c3f2..1481d1150065 100644
--- a/drivers/net/ethernet/sfc/ef10_sriov.h
+++ b/drivers/net/ethernet/sfc/ef10_sriov.h
@@ -12,6 +12,18 @@
 
 #include "net_driver.h"
 
+/**
+ * struct ef10_vf - PF's store of VF data
+ * @vport_id: vport ID for the VF
+ * @vport_assigned: record whether the vport is currently assigned to the VF
+ * @mac: MAC address for the VF, zero when address is removed from the vport
+ */
+struct ef10_vf {
+	unsigned int vport_id;
+	unsigned int vport_assigned;
+	u8 mac[ETH_ALEN];
+};
+
 static inline bool efx_ef10_sriov_wanted(struct efx_nic *efx)
 {
 	return false;
* Unmerged path drivers/net/ethernet/sfc/nic.h
