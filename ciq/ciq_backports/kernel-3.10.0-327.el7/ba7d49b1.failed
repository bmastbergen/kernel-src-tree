rtnetlink: provide api for getting and setting slave info

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Jiri Pirko <jiri@resnulli.us>
commit ba7d49b1f0f8e5f24294a880ed576964059af5ef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/ba7d49b1.failed

Recent patch
bonding: add netlink attributes to slave link dev (1d3ee88ae0d6)

Introduced yet another device specific way to access slave information
over rtnetlink. There is one already there for bridge.

This patch introduces generic way to do this, for getting and setting
info as well by extending link_ops. Later on, this new interface will
be used for bridge ports as well.

	Signed-off-by: Jiri Pirko <jiri@resnulli.us>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ba7d49b1f0f8e5f24294a880ed576964059af5ef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/rtnetlink.h
#	net/core/rtnetlink.c
diff --cc include/net/rtnetlink.h
index 9ff6beec92ec,661e45d38051..000000000000
--- a/include/net/rtnetlink.h
+++ b/include/net/rtnetlink.h
@@@ -83,36 -80,26 +83,52 @@@ struct rtnl_link_ops 
  	unsigned int		(*get_num_tx_queues)(void);
  	unsigned int		(*get_num_rx_queues)(void);
  
++<<<<<<< HEAD
 +	/* RHEL SPECIFIC
 +	 *
 +	 * The following padding has been inserted before ABI freeze to
 +	 * allow extending the structure while preserve ABI. Feel free
 +	 * to replace reserved slots with required structure field
 +	 * additions of your backport.
 +	 */
 +	RH_KABI_RESERVE_P(1)
 +	RH_KABI_RESERVE_P(2)
 +	RH_KABI_RESERVE_P(3)
 +	RH_KABI_RESERVE_P(4)
 +	RH_KABI_RESERVE_P(5)
 +	RH_KABI_RESERVE_P(6)
 +	RH_KABI_RESERVE_P(7)
 +	RH_KABI_RESERVE_P(8)
 +	RH_KABI_RESERVE_P(9)
 +	RH_KABI_RESERVE_P(10)
 +	RH_KABI_RESERVE_P(11)
 +	RH_KABI_RESERVE_P(12)
 +	RH_KABI_RESERVE_P(13)
 +	RH_KABI_RESERVE_P(14)
 +	RH_KABI_RESERVE_P(15)
 +	RH_KABI_RESERVE_P(16)
++=======
+ 	int			slave_maxtype;
+ 	const struct nla_policy	*slave_policy;
+ 	int			(*slave_validate)(struct nlattr *tb[],
+ 						  struct nlattr *data[]);
+ 	int			(*slave_changelink)(struct net_device *dev,
+ 						    struct net_device *slave_dev,
+ 						    struct nlattr *tb[],
+ 						    struct nlattr *data[]);
+ 	size_t			(*get_slave_size)(const struct net_device *dev,
+ 						  const struct net_device *slave_dev);
+ 	int			(*fill_slave_info)(struct sk_buff *skb,
+ 						   const struct net_device *dev,
+ 						   const struct net_device *slave_dev);
++>>>>>>> ba7d49b1f0f8 (rtnetlink: provide api for getting and setting slave info)
  };
  
 -int __rtnl_link_register(struct rtnl_link_ops *ops);
 -void __rtnl_link_unregister(struct rtnl_link_ops *ops);
 +extern int	__rtnl_link_register(struct rtnl_link_ops *ops);
 +extern void	__rtnl_link_unregister(struct rtnl_link_ops *ops);
  
 -int rtnl_link_register(struct rtnl_link_ops *ops);
 -void rtnl_link_unregister(struct rtnl_link_ops *ops);
 +extern int	rtnl_link_register(struct rtnl_link_ops *ops);
 +extern void	rtnl_link_unregister(struct rtnl_link_ops *ops);
  
  /**
   * 	struct rtnl_af_ops - rtnetlink address family operations
diff --cc net/core/rtnetlink.c
index 46e91a591c6a,a56bccf6629e..000000000000
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@@ -1057,10 -1128,10 +1136,17 @@@ static int rtnl_fill_ifinfo(struct sk_b
  		nla_nest_end(skb, vfinfo);
  	}
  
++<<<<<<< HEAD
 +	if (rtnl_port_fill(skb, dev, ext_filter_mask))
 +		goto nla_put_failure;
 +
 +	if (dev->rtnl_link_ops) {
++=======
+ 	if (rtnl_port_fill(skb, dev))
+ 		goto nla_put_failure;
+ 
+ 	if (dev->rtnl_link_ops || rtnl_have_link_slave_info(dev)) {
++>>>>>>> ba7d49b1f0f8 (rtnetlink: provide api for getting and setting slave info)
  		if (rtnl_link_fill(skb, dev) < 0)
  			goto nla_put_failure;
  	}
@@@ -1881,7 -1961,18 +1998,22 @@@ replay
  				modified = 1;
  			}
  
++<<<<<<< HEAD
 +			return do_setlink(skb, dev, ifm, tb, ifname, modified);
++=======
+ 			if (linkinfo[IFLA_INFO_SLAVE_DATA]) {
+ 				if (!m_ops || !m_ops->slave_changelink)
+ 					return -EOPNOTSUPP;
+ 
+ 				err = m_ops->slave_changelink(master_dev, dev,
+ 							      tb, slave_data);
+ 				if (err < 0)
+ 					return err;
+ 				modified = 1;
+ 			}
+ 
+ 			return do_setlink(dev, ifm, tb, ifname, modified);
++>>>>>>> ba7d49b1f0f8 (rtnetlink: provide api for getting and setting slave info)
  		}
  
  		if (!(nlh->nlmsg_flags & NLM_F_CREATE)) {
* Unmerged path include/net/rtnetlink.h
diff --git a/include/uapi/linux/if_link.h b/include/uapi/linux/if_link.h
index 4efe6bcb6e67..28b1ba26ef9b 100644
--- a/include/uapi/linux/if_link.h
+++ b/include/uapi/linux/if_link.h
@@ -246,6 +246,8 @@ enum {
 	IFLA_INFO_KIND,
 	IFLA_INFO_DATA,
 	IFLA_INFO_XSTATS,
+	IFLA_INFO_SLAVE_KIND,
+	IFLA_INFO_SLAVE_DATA,
 	__IFLA_INFO_MAX,
 };
 
* Unmerged path net/core/rtnetlink.c
