openvswitch: Allow for any level of nesting in flow attributes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Thomas Graf <tgraf@suug.ch>
commit 81bfe3c3cf153441588e50a57f53bc9816f37d37
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/81bfe3c3.failed

nlattr_set() is currently hardcoded to two levels of nesting. This change
introduces struct ovs_len_tbl to define minimal length requirements plus
next level nesting tables to traverse the key attributes to arbitrary depth.

	Signed-off-by: Thomas Graf <tgraf@suug.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 81bfe3c3cf153441588e50a57f53bc9816f37d37)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/openvswitch/flow_netlink.c
diff --cc net/openvswitch/flow_netlink.c
index d35e6f9713da,518941c5bdf1..000000000000
--- a/net/openvswitch/flow_netlink.c
+++ b/net/openvswitch/flow_netlink.c
@@@ -279,28 -296,44 +286,68 @@@ size_t ovs_key_attr_size(void
  		+ nla_total_size(28); /* OVS_KEY_ATTR_ND */
  }
  
+ static const struct ovs_len_tbl ovs_tunnel_key_lens[OVS_TUNNEL_KEY_ATTR_MAX + 1] = {
+ 	[OVS_TUNNEL_KEY_ATTR_ID]	    = { .len = sizeof(u64) },
+ 	[OVS_TUNNEL_KEY_ATTR_IPV4_SRC]	    = { .len = sizeof(u32) },
+ 	[OVS_TUNNEL_KEY_ATTR_IPV4_DST]	    = { .len = sizeof(u32) },
+ 	[OVS_TUNNEL_KEY_ATTR_TOS]	    = { .len = 1 },
+ 	[OVS_TUNNEL_KEY_ATTR_TTL]	    = { .len = 1 },
+ 	[OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT] = { .len = 0 },
+ 	[OVS_TUNNEL_KEY_ATTR_CSUM]	    = { .len = 0 },
+ 	[OVS_TUNNEL_KEY_ATTR_TP_SRC]	    = { .len = sizeof(u16) },
+ 	[OVS_TUNNEL_KEY_ATTR_TP_DST]	    = { .len = sizeof(u16) },
+ 	[OVS_TUNNEL_KEY_ATTR_OAM]	    = { .len = 0 },
+ 	[OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS]   = { .len = OVS_ATTR_NESTED },
+ };
+ 
  /* The size of the argument for each %OVS_KEY_ATTR_* Netlink attribute.  */
++<<<<<<< HEAD
 +static const int ovs_key_lens[OVS_KEY_ATTR_MAX + 1] = {
 +	[OVS_KEY_ATTR_ENCAP] = -1,
 +	[OVS_KEY_ATTR_PRIORITY] = sizeof(u32),
 +	[OVS_KEY_ATTR_IN_PORT] = sizeof(u32),
 +	[OVS_KEY_ATTR_SKB_MARK] = sizeof(u32),
 +	[OVS_KEY_ATTR_ETHERNET] = sizeof(struct ovs_key_ethernet),
 +	[OVS_KEY_ATTR_VLAN] = sizeof(__be16),
 +	[OVS_KEY_ATTR_ETHERTYPE] = sizeof(__be16),
 +	[OVS_KEY_ATTR_IPV4] = sizeof(struct ovs_key_ipv4),
 +	[OVS_KEY_ATTR_IPV6] = sizeof(struct ovs_key_ipv6),
 +	[OVS_KEY_ATTR_TCP] = sizeof(struct ovs_key_tcp),
 +	[OVS_KEY_ATTR_TCP_FLAGS] = sizeof(__be16),
 +	[OVS_KEY_ATTR_UDP] = sizeof(struct ovs_key_udp),
 +	[OVS_KEY_ATTR_SCTP] = sizeof(struct ovs_key_sctp),
 +	[OVS_KEY_ATTR_ICMP] = sizeof(struct ovs_key_icmp),
 +	[OVS_KEY_ATTR_ICMPV6] = sizeof(struct ovs_key_icmpv6),
 +	[OVS_KEY_ATTR_ARP] = sizeof(struct ovs_key_arp),
 +	[OVS_KEY_ATTR_ND] = sizeof(struct ovs_key_nd),
 +	[OVS_KEY_ATTR_RECIRC_ID] = sizeof(u32),
 +	[OVS_KEY_ATTR_DP_HASH] = sizeof(u32),
 +	[OVS_KEY_ATTR_TUNNEL] = -1,
++=======
+ static const struct ovs_len_tbl ovs_key_lens[OVS_KEY_ATTR_MAX + 1] = {
+ 	[OVS_KEY_ATTR_ENCAP]	 = { .len = OVS_ATTR_NESTED },
+ 	[OVS_KEY_ATTR_PRIORITY]	 = { .len = sizeof(u32) },
+ 	[OVS_KEY_ATTR_IN_PORT]	 = { .len = sizeof(u32) },
+ 	[OVS_KEY_ATTR_SKB_MARK]	 = { .len = sizeof(u32) },
+ 	[OVS_KEY_ATTR_ETHERNET]	 = { .len = sizeof(struct ovs_key_ethernet) },
+ 	[OVS_KEY_ATTR_VLAN]	 = { .len = sizeof(__be16) },
+ 	[OVS_KEY_ATTR_ETHERTYPE] = { .len = sizeof(__be16) },
+ 	[OVS_KEY_ATTR_IPV4]	 = { .len = sizeof(struct ovs_key_ipv4) },
+ 	[OVS_KEY_ATTR_IPV6]	 = { .len = sizeof(struct ovs_key_ipv6) },
+ 	[OVS_KEY_ATTR_TCP]	 = { .len = sizeof(struct ovs_key_tcp) },
+ 	[OVS_KEY_ATTR_TCP_FLAGS] = { .len = sizeof(__be16) },
+ 	[OVS_KEY_ATTR_UDP]	 = { .len = sizeof(struct ovs_key_udp) },
+ 	[OVS_KEY_ATTR_SCTP]	 = { .len = sizeof(struct ovs_key_sctp) },
+ 	[OVS_KEY_ATTR_ICMP]	 = { .len = sizeof(struct ovs_key_icmp) },
+ 	[OVS_KEY_ATTR_ICMPV6]	 = { .len = sizeof(struct ovs_key_icmpv6) },
+ 	[OVS_KEY_ATTR_ARP]	 = { .len = sizeof(struct ovs_key_arp) },
+ 	[OVS_KEY_ATTR_ND]	 = { .len = sizeof(struct ovs_key_nd) },
+ 	[OVS_KEY_ATTR_RECIRC_ID] = { .len = sizeof(u32) },
+ 	[OVS_KEY_ATTR_DP_HASH]	 = { .len = sizeof(u32) },
+ 	[OVS_KEY_ATTR_TUNNEL]	 = { .len = OVS_ATTR_NESTED,
+ 				     .next = ovs_tunnel_key_lens, },
+ 	[OVS_KEY_ATTR_MPLS]	 = { .len = sizeof(struct ovs_key_mpls) },
++>>>>>>> 81bfe3c3cf15 (openvswitch: Allow for any level of nesting in flow attributes)
  };
  
  static bool is_all_zero(const u8 *fp, size_t size)
@@@ -341,11 -374,10 +388,18 @@@ static int __parse_flow_nlattrs(const s
  			return -EINVAL;
  		}
  
++<<<<<<< HEAD
 +		expected_len = ovs_key_lens[type];
 +		if (nla_len(nla) != expected_len && expected_len != -1) {
 +			OVS_NLERR("Key attribute has unexpected length (type=%d"
 +				  ", length=%d, expected=%d).\n", type,
 +				  nla_len(nla), expected_len);
++=======
+ 		expected_len = ovs_key_lens[type].len;
+ 		if (nla_len(nla) != expected_len && expected_len != OVS_ATTR_NESTED) {
+ 			OVS_NLERR(log, "Key %d has unexpected len %d expected %d",
+ 				  type, nla_len(nla), expected_len);
++>>>>>>> 81bfe3c3cf15 (openvswitch: Allow for any level of nesting in flow attributes)
  			return -EINVAL;
  		}
  
@@@ -386,31 -471,18 +440,42 @@@ static int ipv4_tun_from_nlattr(const s
  
  	nla_for_each_nested(a, attr, rem) {
  		int type = nla_type(a);
++<<<<<<< HEAD
 +		static const u32 ovs_tunnel_key_lens[OVS_TUNNEL_KEY_ATTR_MAX + 1] = {
 +			[OVS_TUNNEL_KEY_ATTR_ID] = sizeof(u64),
 +			[OVS_TUNNEL_KEY_ATTR_IPV4_SRC] = sizeof(u32),
 +			[OVS_TUNNEL_KEY_ATTR_IPV4_DST] = sizeof(u32),
 +			[OVS_TUNNEL_KEY_ATTR_TOS] = 1,
 +			[OVS_TUNNEL_KEY_ATTR_TTL] = 1,
 +			[OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT] = 0,
 +			[OVS_TUNNEL_KEY_ATTR_CSUM] = 0,
 +			[OVS_TUNNEL_KEY_ATTR_TP_SRC] = sizeof(u16),
 +			[OVS_TUNNEL_KEY_ATTR_TP_DST] = sizeof(u16),
 +			[OVS_TUNNEL_KEY_ATTR_OAM] = 0,
 +			[OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS] = -1,
 +		};
++=======
+ 		int err;
++>>>>>>> 81bfe3c3cf15 (openvswitch: Allow for any level of nesting in flow attributes)
  
  		if (type > OVS_TUNNEL_KEY_ATTR_MAX) {
 -			OVS_NLERR(log, "Tunnel attr %d out of range max %d",
 -				  type, OVS_TUNNEL_KEY_ATTR_MAX);
 +			OVS_NLERR("Unknown IPv4 tunnel attribute (type=%d, max=%d).\n",
 +			type, OVS_TUNNEL_KEY_ATTR_MAX);
  			return -EINVAL;
  		}
  
++<<<<<<< HEAD
 +		if (ovs_tunnel_key_lens[type] != nla_len(a) &&
 +		    ovs_tunnel_key_lens[type] != -1) {
 +			OVS_NLERR("IPv4 tunnel attribute type has unexpected "
 +				  " length (type=%d, length=%d, expected=%d).\n",
 +				  type, nla_len(a), ovs_tunnel_key_lens[type]);
++=======
+ 		if (ovs_tunnel_key_lens[type].len != nla_len(a) &&
+ 		    ovs_tunnel_key_lens[type].len != OVS_ATTR_NESTED) {
+ 			OVS_NLERR(log, "Tunnel attr %d has unexpected len %d expected %d",
+ 				  type, nla_len(a), ovs_tunnel_key_lens[type].len);
++>>>>>>> 81bfe3c3cf15 (openvswitch: Allow for any level of nesting in flow attributes)
  			return -EINVAL;
  		}
  
* Unmerged path net/openvswitch/flow_netlink.c
