md/raid1: Don't use next_resync to determine how far resync has progressed

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [md] raid1: Don't use next_resync to determine how far resync has progressed (Jes Sorensen) [1261114]
Rebuild_FUZZ: 97.93%
commit-author NeilBrown <neilb@suse.de>
commit 235549605eb7f1c5a37cef8b09d12e6d412c5cd6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/23554960.failed

next_resync is (approximately) the location for the next resync request.
However it does *not* reliably determine the earliest location
at which resync might be happening.
This is because resync requests can complete out of order, and
we only limit the number of current requests, not the distance
from the earliest pending request to the latest.

mddev->curr_resync_completed is a reliable indicator of the earliest
position at which resync could be happening.   It is updated less
frequently, but is actually reliable which is more important.

So use it to determine if a write request is before the region
being resynced and so safe from conflict.

This error can allow resync IO to interfere with normal IO which
could lead to data corruption. Hence: stable.

Fixes: 79ef3a8aa1cb1523cc231c9a90a278333c21f761
cc: stable@vger.kernel.org (v3.13+)
	Signed-off-by: NeilBrown <neilb@suse.de>
(cherry picked from commit 235549605eb7f1c5a37cef8b09d12e6d412c5cd6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/raid1.c
diff --cc drivers/md/raid1.c
index bd5c16776ac5,3b14a495c424..000000000000
--- a/drivers/md/raid1.c
+++ b/drivers/md/raid1.c
@@@ -866,12 -875,10 +866,19 @@@ static bool need_to_wait_for_sync(struc
  	if (conf->array_frozen || !bio)
  		wait = true;
  	else if (conf->barrier && bio_data_dir(bio) == WRITE) {
++<<<<<<< HEAD
 +		if (conf->next_resync < RESYNC_WINDOW_SECTORS)
 +			wait = true;
 +		else if ((conf->next_resync - RESYNC_WINDOW_SECTORS
 +				>= bio_end_sector(bio)) ||
 +			 (conf->next_resync + NEXT_NORMALIO_DISTANCE
 +				<= bio->bi_sector))
++=======
+ 		if ((conf->mddev->curr_resync_completed
+ 		     >= bio_end_sector(bio)) ||
+ 		    (conf->next_resync + NEXT_NORMALIO_DISTANCE
+ 		     <= bio->bi_iter.bi_sector))
++>>>>>>> 235549605eb7 (md/raid1: Don't use next_resync to determine how far resync has progressed)
  			wait = false;
  		else
  			wait = true;
@@@ -908,8 -915,8 +915,13 @@@ static sector_t wait_barrier(struct r1c
  	}
  
  	if (bio && bio_data_dir(bio) == WRITE) {
++<<<<<<< HEAD
 +		if (conf->next_resync + NEXT_NORMALIO_DISTANCE
 +		    <= bio->bi_sector) {
++=======
+ 		if (bio->bi_iter.bi_sector >=
+ 		    conf->mddev->curr_resync_completed) {
++>>>>>>> 235549605eb7 (md/raid1: Don't use next_resync to determine how far resync has progressed)
  			if (conf->start_next_window == MaxSector)
  				conf->start_next_window =
  					conf->next_resync +
* Unmerged path drivers/md/raid1.c
