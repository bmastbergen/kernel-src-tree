fib_trie: Rename tnode_child_length to child_length

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Alexander Duyck <alexander.h.duyck@redhat.com>
commit 2e1ac88a48370620429cd9e54c41365531962809
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/2e1ac88a.failed

We are now checking the length of a key_vector instead of a tnode so it
makes sense to probably just rename this to child_length since it would
probably even be applicable to a leaf.

	Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2e1ac88a48370620429cd9e54c41365531962809)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/fib_trie.c
diff --cc net/ipv4/fib_trie.c
index 8be89b1a8b93,b88c0d0f48ed..000000000000
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@@ -91,24 -92,22 +91,34 @@@ typedef unsigned int t_key
  #define IS_TNODE(n) ((n)->bits)
  #define IS_LEAF(n) (!(n)->bits)
  
++<<<<<<< HEAD
 +#define get_index(_key, _kv) (((_key) ^ (_kv)->key) >> (_kv)->pos)
 +
 +struct tnode {
++=======
+ struct key_vector {
+ 	struct rcu_head rcu;
+ 
+ 	t_key empty_children; /* KEYLENGTH bits needed */
+ 	t_key full_children;  /* KEYLENGTH bits needed */
+ 	struct key_vector __rcu *parent;
+ 
++>>>>>>> 2e1ac88a4837 (fib_trie: Rename tnode_child_length to child_length)
  	t_key key;
 -	unsigned char pos;		/* 2log(KEYLENGTH) bits needed */
  	unsigned char bits;		/* 2log(KEYLENGTH) bits needed */
 +	unsigned char pos;		/* 2log(KEYLENGTH) bits needed */
  	unsigned char slen;
 +	struct tnode __rcu *parent;
 +	struct rcu_head rcu;
  	union {
 -		/* This list pointer if valid if (pos | bits) == 0 (LEAF) */
 -		struct hlist_head leaf;
 -		/* This array is valid if (pos | bits) > 0 (TNODE) */
 -		struct key_vector __rcu *tnode[0];
 +		/* The fields in this struct are valid if bits > 0 (TNODE) */
 +		struct {
 +			t_key empty_children; /* KEYLENGTH bits needed */
 +			t_key full_children;  /* KEYLENGTH bits needed */
 +			struct tnode __rcu *child[0];
 +		};
 +		/* This list pointer if valid if bits == 0 (LEAF) */
 +		struct hlist_head list;
  	};
  };
  
@@@ -179,23 -175,23 +189,38 @@@ static inline void node_set_parent(stru
  /* This provides us with the number of children in this node, in the case of a
   * leaf this will return 0 meaning none of the children are accessible.
   */
++<<<<<<< HEAD
 +static inline unsigned long tnode_child_length(const struct tnode *tn)
++=======
+ static inline unsigned long child_length(const struct key_vector *tn)
++>>>>>>> 2e1ac88a4837 (fib_trie: Rename tnode_child_length to child_length)
  {
  	return (1ul << tn->bits) & ~(1ul);
  }
  
++<<<<<<< HEAD
 +/* caller must hold RTNL */
 +static inline struct tnode *tnode_get_child(const struct tnode *tn,
 +					    unsigned long i)
++=======
+ static inline unsigned long get_index(t_key key, struct key_vector *kv)
+ {
+ 	unsigned long index = key ^ kv->key;
+ 
+ 	return index >> kv->pos;
+ }
+ 
+ static inline struct fib_table *trie_get_table(struct trie *t)
++>>>>>>> 2e1ac88a4837 (fib_trie: Rename tnode_child_length to child_length)
  {
 -	unsigned long *tb_data = (unsigned long *)t;
 +	return rtnl_dereference(tn->child[i]);
 +}
  
 -	return container_of(tb_data, struct fib_table, tb_data[0]);
 +/* caller must hold RCU read lock or RTNL */
 +static inline struct tnode *tnode_get_child_rcu(const struct tnode *tn,
 +						unsigned long i)
 +{
 +	return rcu_dereference_rtnl(tn->child[i]);
  }
  
  /* To understand this stuff, an understanding of keys and all their bits is
@@@ -381,12 -373,13 +406,12 @@@ static inline int tnode_full(const stru
  /* Add a child at position i overwriting the old value.
   * Update the value of full_children and empty_children.
   */
 -static void put_child(struct key_vector *tn, unsigned long i,
 -		      struct key_vector *n)
 +static void put_child(struct tnode *tn, unsigned long i, struct tnode *n)
  {
 -	struct key_vector *chi = get_child(tn, i);
 +	struct tnode *chi = tnode_get_child(tn, i);
  	int isfull, wasfull;
  
- 	BUG_ON(i >= tnode_child_length(tn));
+ 	BUG_ON(i >= child_length(tn));
  
  	/* update emptyChildren, overflow into fullChildren */
  	if (n == NULL && chi != NULL)
@@@ -414,8 -407,8 +439,13 @@@ static void update_children(struct tnod
  	unsigned long i;
  
  	/* update all of the child parent pointers */
++<<<<<<< HEAD
 +	for (i = tnode_child_length(tn); i;) {
 +		struct tnode *inode = tnode_get_child(tn, --i);
++=======
+ 	for (i = child_length(tn); i;) {
+ 		struct key_vector *inode = get_child(tn, --i);
++>>>>>>> 2e1ac88a4837 (fib_trie: Rename tnode_child_length to child_length)
  
  		if (!inode)
  			continue;
@@@ -484,9 -481,12 +514,14 @@@ static void replace(struct trie *t, str
  	/* all pointers should be clean so we are done */
  	tnode_free(oldtnode);
  
 -	/* record the pointer that is pointing to this node */
 -	cptr = tp ? tp->tnode : t->tnode;
 -
  	/* resize children now that oldtnode is freed */
++<<<<<<< HEAD
 +	for (i = tnode_child_length(tn); i;) {
 +		struct tnode *inode = tnode_get_child(tn, --i);
++=======
+ 	for (i = child_length(tn); i;) {
+ 		struct key_vector *inode = get_child(tn, --i);
++>>>>>>> 2e1ac88a4837 (fib_trie: Rename tnode_child_length to child_length)
  
  		/* resize child node */
  		if (tnode_full(tn, inode))
@@@ -514,9 -517,9 +549,15 @@@ static int inflate(struct trie *t, stru
  	 * point to existing tnodes and the links between our allocated
  	 * nodes.
  	 */
++<<<<<<< HEAD
 +	for (i = tnode_child_length(oldtnode), m = 1u << tn->pos; i;) {
 +		struct tnode *inode = tnode_get_child(oldtnode, --i);
 +		struct tnode *node0, *node1;
++=======
+ 	for (i = child_length(oldtnode), m = 1u << tn->pos; i;) {
+ 		struct key_vector *inode = get_child(oldtnode, --i);
+ 		struct key_vector *node0, *node1;
++>>>>>>> 2e1ac88a4837 (fib_trie: Rename tnode_child_length to child_length)
  		unsigned long j, k;
  
  		/* An empty child */
@@@ -564,11 -567,11 +605,19 @@@
  		tnode_free_append(tn, node0);
  
  		/* populate child pointers in new nodes */
++<<<<<<< HEAD
 +		for (k = tnode_child_length(inode), j = k / 2; j;) {
 +			put_child(node1, --j, tnode_get_child(inode, --k));
 +			put_child(node0, j, tnode_get_child(inode, j));
 +			put_child(node1, --j, tnode_get_child(inode, --k));
 +			put_child(node0, j, tnode_get_child(inode, j));
++=======
+ 		for (k = child_length(inode), j = k / 2; j;) {
+ 			put_child(node1, --j, get_child(inode, --k));
+ 			put_child(node0, j, get_child(inode, j));
+ 			put_child(node1, --j, get_child(inode, --k));
+ 			put_child(node0, j, get_child(inode, j));
++>>>>>>> 2e1ac88a4837 (fib_trie: Rename tnode_child_length to child_length)
  		}
  
  		/* link new nodes to parent */
@@@ -609,10 -612,10 +658,17 @@@ static int halve(struct trie *t, struc
  	 * point to existing tnodes and the links between our allocated
  	 * nodes.
  	 */
++<<<<<<< HEAD
 +	for (i = tnode_child_length(oldtnode); i;) {
 +		struct tnode *node1 = tnode_get_child(oldtnode, --i);
 +		struct tnode *node0 = tnode_get_child(oldtnode, --i);
 +		struct tnode *inode;
++=======
+ 	for (i = child_length(oldtnode); i;) {
+ 		struct key_vector *node1 = get_child(oldtnode, --i);
+ 		struct key_vector *node0 = get_child(oldtnode, --i);
+ 		struct key_vector *inode;
++>>>>>>> 2e1ac88a4837 (fib_trie: Rename tnode_child_length to child_length)
  
  		/* At least one of the children is empty */
  		if (!node1 || !node0) {
@@@ -649,8 -653,8 +705,13 @@@ static void collapse(struct trie *t, st
  	unsigned long i;
  
  	/* scan the tnode looking for that one child that might still exist */
++<<<<<<< HEAD
 +	for (n = NULL, i = tnode_child_length(oldtnode); !n && i;)
 +		n = tnode_get_child(oldtnode, --i);
++=======
+ 	for (n = NULL, i = child_length(oldtnode); !n && i;)
+ 		n = get_child(oldtnode, --i);
++>>>>>>> 2e1ac88a4837 (fib_trie: Rename tnode_child_length to child_length)
  
  	/* compress one level */
  	tp = node_parent(oldtnode);
@@@ -671,8 -675,8 +732,13 @@@ static unsigned char update_suffix(stru
  	 * why we start with a stride of 2 since a stride of 1 would
  	 * represent the nodes with suffix length equal to tn->pos
  	 */
++<<<<<<< HEAD
 +	for (i = 0, stride = 0x2ul ; i < tnode_child_length(tn); i += stride) {
 +		struct tnode *n = tnode_get_child(tn, i);
++=======
+ 	for (i = 0, stride = 0x2ul ; i < child_length(tn); i += stride) {
+ 		struct key_vector *n = get_child(tn, i);
++>>>>>>> 2e1ac88a4837 (fib_trie: Rename tnode_child_length to child_length)
  
  		if (!n || (n->slen <= slen))
  			continue;
@@@ -743,19 -747,19 +809,19 @@@
   *    tn->full_children) >= inflate_threshold * new_child_length
   *
   * expand new_child_length:
-  * 100 * (tnode_child_length(tn) - tn->empty_children +
+  * 100 * (child_length(tn) - tn->empty_children +
   *    tn->full_children) >=
-  *      inflate_threshold * tnode_child_length(tn) * 2
+  *      inflate_threshold * child_length(tn) * 2
   *
   * shorten again:
-  * 50 * (tn->full_children + tnode_child_length(tn) -
+  * 50 * (tn->full_children + child_length(tn) -
   *    tn->empty_children) >= inflate_threshold *
-  *    tnode_child_length(tn)
+  *    child_length(tn)
   *
   */
 -static inline bool should_inflate(struct key_vector *tp, struct key_vector *tn)
 +static bool should_inflate(const struct tnode *tp, const struct tnode *tn)
  {
- 	unsigned long used = tnode_child_length(tn);
+ 	unsigned long used = child_length(tn);
  	unsigned long threshold = used;
  
  	/* Keep root node larger */
@@@ -768,9 -772,9 +834,9 @@@
  	return (used > 1) && tn->pos && ((50 * used) >= threshold);
  }
  
 -static inline bool should_halve(struct key_vector *tp, struct key_vector *tn)
 +static bool should_halve(const struct tnode *tp, const struct tnode *tn)
  {
- 	unsigned long used = tnode_child_length(tn);
+ 	unsigned long used = child_length(tn);
  	unsigned long threshold = used;
  
  	/* Keep root node larger */
@@@ -782,9 -786,9 +848,9 @@@
  	return (used > 1) && (tn->bits > 1) && ((100 * used) < threshold);
  }
  
 -static inline bool should_collapse(struct key_vector *tn)
 +static bool should_collapse(const struct tnode *tn)
  {
- 	unsigned long used = tnode_child_length(tn);
+ 	unsigned long used = child_length(tn);
  
  	used -= tn->empty_children;
  
@@@ -1886,8 -1879,8 +1952,13 @@@ static struct tnode *fib_trie_get_next(
  	pr_debug("get_next iter={node=%p index=%d depth=%d}\n",
  		 iter->tnode, iter->index, iter->depth);
  rescan:
++<<<<<<< HEAD
 +	while (cindex < tnode_child_length(tn)) {
 +		struct tnode *n = tnode_get_child_rcu(tn, cindex);
++=======
+ 	while (cindex < child_length(tn)) {
+ 		struct key_vector *n = get_child_rcu(tn, cindex);
++>>>>>>> 2e1ac88a4837 (fib_trie: Rename tnode_child_length to child_length)
  
  		if (n) {
  			if (IS_LEAF(n)) {
* Unmerged path net/ipv4/fib_trie.c
