scsi: convert device_busy to atomic_t

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [scsi] convert device_busy to atomic_t (Ewan Milne) [1109348]
Rebuild_FUZZ: 91.18%
commit-author Christoph Hellwig <hch@lst.de>
commit 71e75c97f97a9645d25fbf3d8e4165a558f18747
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/71e75c97.failed

Avoid taking the queue_lock to check the per-device queue limit.  Instead
we do an atomic_inc_return early on to grab our slot in the queue,
and if necessary decrement it after finishing all checks.

Unlike the host and target busy counters this doesn't allow us to avoid the
queue_lock in the request_fn due to the way the interface works, but it'll
allow us to prepare for using the blk-mq code, which doesn't use the
queue_lock at all, and it at least avoids a queue_lock round trip in
scsi_device_unbusy, which is still important given how busy the queue_lock
is.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Reviewed-by: Webb Scales <webbnh@hp.com>
	Acked-by: Jens Axboe <axboe@kernel.dk>
	Tested-by: Bart Van Assche <bvanassche@acm.org>
	Tested-by: Robert Elliott <elliott@hp.com>
(cherry picked from commit 71e75c97f97a9645d25fbf3d8e4165a558f18747)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/scsi_lib.c
diff --cc drivers/scsi/scsi_lib.c
index 3970c9519e29,1ddf0fb43b59..000000000000
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@@ -293,16 -292,17 +293,23 @@@ void scsi_device_unbusy(struct scsi_dev
  	struct scsi_target *starget = scsi_target(sdev);
  	unsigned long flags;
  
 -	atomic_dec(&shost->host_busy);
 +	spin_lock_irqsave(shost->host_lock, flags);
 +	shost->host_busy--;
  	atomic_dec(&starget->target_busy);
 -
  	if (unlikely(scsi_host_in_recovery(shost) &&
 -		     (shost->host_failed || shost->host_eh_scheduled))) {
 -		spin_lock_irqsave(shost->host_lock, flags);
 +		     (shost->host_failed || shost->host_eh_scheduled)))
  		scsi_eh_wakeup(shost);
++<<<<<<< HEAD
 +	spin_unlock(shost->host_lock);
 +	spin_lock(sdev->request_queue->queue_lock);
 +	sdev->device_busy--;
 +	spin_unlock_irqrestore(sdev->request_queue->queue_lock, flags);
++=======
+ 		spin_unlock_irqrestore(shost->host_lock, flags);
+ 	}
+ 
+ 	atomic_dec(&sdev->device_busy);
++>>>>>>> 71e75c97f97a (scsi: convert device_busy to atomic_t)
  }
  
  /*
@@@ -1437,13 -1453,9 +1451,18 @@@ static void scsi_kill_request(struct re
  	 * bump busy counts.  To bump the counters, we need to dance
  	 * with the locks as normal issue path does.
  	 */
++<<<<<<< HEAD
 +	sdev->device_busy++;
 +	spin_unlock(sdev->request_queue->queue_lock);
 +	spin_lock(shost->host_lock);
 +	shost->host_busy++;
++=======
+ 	atomic_inc(&sdev->device_busy);
+ 	atomic_inc(&shost->host_busy);
++>>>>>>> 71e75c97f97a (scsi: convert device_busy to atomic_t)
  	atomic_inc(&starget->target_busy);
 +	spin_unlock(shost->host_lock);
 +	spin_lock(sdev->request_queue->queue_lock);
  
  	blk_complete_request(req);
  }
diff --git a/drivers/message/fusion/mptsas.c b/drivers/message/fusion/mptsas.c
index 236c8e99a610..f95a34f55331 100644
--- a/drivers/message/fusion/mptsas.c
+++ b/drivers/message/fusion/mptsas.c
@@ -3763,7 +3763,7 @@ mptsas_send_link_status_event(struct fw_event_work *fw_event)
 						printk(MYIOC_s_DEBUG_FMT
 						"SDEV OUTSTANDING CMDS"
 						"%d\n", ioc->name,
-						sdev->device_busy));
+						atomic_read(&sdev->device_busy)));
 				}
 
 			}
* Unmerged path drivers/scsi/scsi_lib.c
diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c
index bf9f0637b768..090880068705 100644
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@ -583,13 +583,21 @@ static int scsi_sdev_check_buf_bit(const char *buf)
  * Create the actual show/store functions and data structures.
  */
 sdev_rd_attr (device_blocked, "%d\n");
-sdev_rd_attr (device_busy, "%d\n");
 sdev_rd_attr (type, "%d\n");
 sdev_rd_attr (scsi_level, "%d\n");
 sdev_rd_attr (vendor, "%.8s\n");
 sdev_rd_attr (model, "%.16s\n");
 sdev_rd_attr (rev, "%.4s\n");
 
+static ssize_t
+sdev_show_device_busy(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct scsi_device *sdev = to_scsi_device(dev);
+	return snprintf(buf, 20, "%d\n", atomic_read(&sdev->device_busy));
+}
+static DEVICE_ATTR(device_busy, S_IRUGO, sdev_show_device_busy, NULL);
+
 /*
  * TODO: can we make these symlinks to the block layer ones?
  */
diff --git a/drivers/scsi/sg.c b/drivers/scsi/sg.c
index d99b8913f6b1..26d6a237cdb7 100644
--- a/drivers/scsi/sg.c
+++ b/drivers/scsi/sg.c
@@ -2565,7 +2565,7 @@ static int sg_proc_seq_show_dev(struct seq_file *s, void *v)
 			      scsidp->id, scsidp->lun, (int) scsidp->type,
 			      1,
 			      (int) scsidp->queue_depth,
-			      (int) scsidp->device_busy,
+			      (int) atomic_read(&scsidp->device_busy),
 			      (int) scsi_device_online(scsidp));
 	}
 	read_unlock_irqrestore(&sg_index_lock, iflags);
diff --git a/include/scsi/scsi_device.h b/include/scsi/scsi_device.h
index 6f98072b7c27..5a4e9e9372f5 100644
--- a/include/scsi/scsi_device.h
+++ b/include/scsi/scsi_device.h
@@ -83,9 +83,7 @@ struct scsi_device {
 	struct list_head    siblings;   /* list of all devices on this host */
 	struct list_head    same_target_siblings; /* just the devices sharing same target id */
 
-	/* this is now protected by the request_queue->queue_lock */
-	unsigned int device_busy;	/* commands actually active on
-					 * low-level. protected by queue_lock. */
+	atomic_t device_busy;		/* commands actually active on LLDD */
 	spinlock_t list_lock;
 	struct list_head cmd_list;	/* queue of in use SCSI Command structures */
 	struct list_head starved_entry;
