ACPI / video: Do not register backlight if win8 and native interface exists

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [acpi] video: Do not register backlight if win8 and native interface exists (Benjamin Tissoires) [1218354]
Rebuild_FUZZ: 95.10%
commit-author Aaron Lu <aaron.lu@intel.com>
commit fbc9fe1b4f222a7c575e3bd8e9defe59c6190a04
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/fbc9fe1b.failed

According to Matthew Garrett, "Windows 8 leaves backlight control up
to individual graphics drivers rather than making ACPI calls itself.
There's plenty of evidence to suggest that the Intel driver for
Windows [8] doesn't use the ACPI interface, including the fact that
it's broken on a bunch of machines when the OS claims to support
Windows 8.  The simplest thing to do appears to be to disable the
ACPI backlight interface on these systems".

So for Win8 systems, if there is native backlight control interface
registered by GPU driver, ACPI video does not need to register its own.
Since there are systems that don't work well with this approach, a
parameter for video module named use_native_backlight is introduced and
has the value of false by default. For users who have a broken ACPI
video backlight interface, video.use_native_backlight=1 is needed in
kernel cmdline.

	Signed-off-by: Aaron Lu <aaron.lu@intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit fbc9fe1b4f222a7c575e3bd8e9defe59c6190a04)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/internal.h
#	drivers/acpi/video.c
#	drivers/acpi/video_detect.c
diff --cc drivers/acpi/internal.h
index 1eabf931aaba,e9304dc7ebfa..000000000000
--- a/drivers/acpi/internal.h
+++ b/drivers/acpi/internal.h
@@@ -172,4 -165,11 +172,14 @@@ struct platform_device
  int acpi_create_platform_device(struct acpi_device *adev,
  				const struct acpi_device_id *id);
  
++<<<<<<< HEAD
++=======
+ /*--------------------------------------------------------------------------
+ 					Video
+   -------------------------------------------------------------------------- */
+ #if defined(CONFIG_ACPI_VIDEO) || defined(CONFIG_ACPI_VIDEO_MODULE)
+ bool acpi_osi_is_win8(void);
+ #endif
+ 
++>>>>>>> fbc9fe1b4f22 (ACPI / video: Do not register backlight if win8 and native interface exists)
  #endif /* _ACPI_INTERNAL_H_ */
diff --cc drivers/acpi/video.c
index 63e8923aaa29,d020df5a732a..000000000000
--- a/drivers/acpi/video.c
+++ b/drivers/acpi/video.c
@@@ -86,7 -88,16 +86,20 @@@ module_param(allow_duplicates, bool, 06
  static bool use_bios_initial_backlight = 1;
  module_param(use_bios_initial_backlight, bool, 0644);
  
++<<<<<<< HEAD
 +static int register_count = 0;
++=======
+ /*
+  * For Windows 8 systems: if set ture and the GPU driver has
+  * registered a backlight interface, skip registering ACPI video's.
+  */
+ static bool use_native_backlight = false;
+ module_param(use_native_backlight, bool, 0644);
+ 
+ static int register_count;
+ static struct mutex video_list_lock;
+ static struct list_head video_bus_head;
++>>>>>>> fbc9fe1b4f22 (ACPI / video: Do not register backlight if win8 and native interface exists)
  static int acpi_video_bus_add(struct acpi_device *device);
  static int acpi_video_bus_remove(struct acpi_device *device);
  static void acpi_video_bus_notify(struct acpi_device *device, u32 event);
@@@ -1701,6 -1571,231 +1722,234 @@@ acpi_video_bus_match(acpi_handle handle
  	return AE_OK;
  }
  
++<<<<<<< HEAD
++=======
+ static void acpi_video_dev_register_backlight(struct acpi_video_device *device)
+ {
+ 	if (acpi_video_verify_backlight_support()) {
+ 		struct backlight_properties props;
+ 		struct pci_dev *pdev;
+ 		acpi_handle acpi_parent;
+ 		struct device *parent = NULL;
+ 		int result;
+ 		static int count;
+ 		char *name;
+ 
+ 		result = acpi_video_init_brightness(device);
+ 		if (result)
+ 			return;
+ 		name = kasprintf(GFP_KERNEL, "acpi_video%d", count);
+ 		if (!name)
+ 			return;
+ 		count++;
+ 
+ 		acpi_get_parent(device->dev->handle, &acpi_parent);
+ 
+ 		pdev = acpi_get_pci_dev(acpi_parent);
+ 		if (pdev) {
+ 			parent = &pdev->dev;
+ 			pci_dev_put(pdev);
+ 		}
+ 
+ 		memset(&props, 0, sizeof(struct backlight_properties));
+ 		props.type = BACKLIGHT_FIRMWARE;
+ 		props.max_brightness = device->brightness->count - 3;
+ 		device->backlight = backlight_device_register(name,
+ 							      parent,
+ 							      device,
+ 							      &acpi_backlight_ops,
+ 							      &props);
+ 		kfree(name);
+ 		if (IS_ERR(device->backlight))
+ 			return;
+ 
+ 		/*
+ 		 * Save current brightness level in case we have to restore it
+ 		 * before acpi_video_device_lcd_set_level() is called next time.
+ 		 */
+ 		device->backlight->props.brightness =
+ 				acpi_video_get_brightness(device->backlight);
+ 
+ 		device->cooling_dev = thermal_cooling_device_register("LCD",
+ 					device->dev, &video_cooling_ops);
+ 		if (IS_ERR(device->cooling_dev)) {
+ 			/*
+ 			 * Set cooling_dev to NULL so we don't crash trying to
+ 			 * free it.
+ 			 * Also, why the hell we are returning early and
+ 			 * not attempt to register video output if cooling
+ 			 * device registration failed?
+ 			 * -- dtor
+ 			 */
+ 			device->cooling_dev = NULL;
+ 			return;
+ 		}
+ 
+ 		dev_info(&device->dev->dev, "registered as cooling_device%d\n",
+ 			 device->cooling_dev->id);
+ 		result = sysfs_create_link(&device->dev->dev.kobj,
+ 				&device->cooling_dev->device.kobj,
+ 				"thermal_cooling");
+ 		if (result)
+ 			printk(KERN_ERR PREFIX "Create sysfs link\n");
+ 		result = sysfs_create_link(&device->cooling_dev->device.kobj,
+ 				&device->dev->dev.kobj, "device");
+ 		if (result)
+ 			printk(KERN_ERR PREFIX "Create sysfs link\n");
+ 	}
+ }
+ 
+ static int acpi_video_bus_register_backlight(struct acpi_video_bus *video)
+ {
+ 	struct acpi_video_device *dev;
+ 
+ 	mutex_lock(&video->device_list_lock);
+ 	list_for_each_entry(dev, &video->video_device_list, entry)
+ 		acpi_video_dev_register_backlight(dev);
+ 	mutex_unlock(&video->device_list_lock);
+ 
+ 	video->pm_nb.notifier_call = acpi_video_resume;
+ 	video->pm_nb.priority = 0;
+ 	return register_pm_notifier(&video->pm_nb);
+ }
+ 
+ static void acpi_video_dev_unregister_backlight(struct acpi_video_device *device)
+ {
+ 	if (device->backlight) {
+ 		backlight_device_unregister(device->backlight);
+ 		device->backlight = NULL;
+ 	}
+ 	if (device->brightness) {
+ 		kfree(device->brightness->levels);
+ 		kfree(device->brightness);
+ 		device->brightness = NULL;
+ 	}
+ 	if (device->cooling_dev) {
+ 		sysfs_remove_link(&device->dev->dev.kobj, "thermal_cooling");
+ 		sysfs_remove_link(&device->cooling_dev->device.kobj, "device");
+ 		thermal_cooling_device_unregister(device->cooling_dev);
+ 		device->cooling_dev = NULL;
+ 	}
+ }
+ 
+ static int acpi_video_bus_unregister_backlight(struct acpi_video_bus *video)
+ {
+ 	struct acpi_video_device *dev;
+ 	int error = unregister_pm_notifier(&video->pm_nb);
+ 
+ 	mutex_lock(&video->device_list_lock);
+ 	list_for_each_entry(dev, &video->video_device_list, entry)
+ 		acpi_video_dev_unregister_backlight(dev);
+ 	mutex_unlock(&video->device_list_lock);
+ 
+ 	return error;
+ }
+ 
+ static void acpi_video_dev_add_notify_handler(struct acpi_video_device *device)
+ {
+ 	acpi_status status;
+ 	struct acpi_device *adev = device->dev;
+ 
+ 	status = acpi_install_notify_handler(adev->handle, ACPI_DEVICE_NOTIFY,
+ 					     acpi_video_device_notify, device);
+ 	if (ACPI_FAILURE(status))
+ 		dev_err(&adev->dev, "Error installing notify handler\n");
+ 	else
+ 		device->flags.notify = 1;
+ }
+ 
+ static int acpi_video_bus_add_notify_handler(struct acpi_video_bus *video)
+ {
+ 	struct input_dev *input;
+ 	struct acpi_video_device *dev;
+ 	int error;
+ 
+ 	video->input = input = input_allocate_device();
+ 	if (!input) {
+ 		error = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	error = acpi_video_bus_start_devices(video);
+ 	if (error)
+ 		goto err_free_input;
+ 
+ 	snprintf(video->phys, sizeof(video->phys),
+ 			"%s/video/input0", acpi_device_hid(video->device));
+ 
+ 	input->name = acpi_device_name(video->device);
+ 	input->phys = video->phys;
+ 	input->id.bustype = BUS_HOST;
+ 	input->id.product = 0x06;
+ 	input->dev.parent = &video->device->dev;
+ 	input->evbit[0] = BIT(EV_KEY);
+ 	set_bit(KEY_SWITCHVIDEOMODE, input->keybit);
+ 	set_bit(KEY_VIDEO_NEXT, input->keybit);
+ 	set_bit(KEY_VIDEO_PREV, input->keybit);
+ 	set_bit(KEY_BRIGHTNESS_CYCLE, input->keybit);
+ 	set_bit(KEY_BRIGHTNESSUP, input->keybit);
+ 	set_bit(KEY_BRIGHTNESSDOWN, input->keybit);
+ 	set_bit(KEY_BRIGHTNESS_ZERO, input->keybit);
+ 	set_bit(KEY_DISPLAY_OFF, input->keybit);
+ 
+ 	error = input_register_device(input);
+ 	if (error)
+ 		goto err_stop_dev;
+ 
+ 	mutex_lock(&video->device_list_lock);
+ 	list_for_each_entry(dev, &video->video_device_list, entry)
+ 		acpi_video_dev_add_notify_handler(dev);
+ 	mutex_unlock(&video->device_list_lock);
+ 
+ 	return 0;
+ 
+ err_stop_dev:
+ 	acpi_video_bus_stop_devices(video);
+ err_free_input:
+ 	input_free_device(input);
+ 	video->input = NULL;
+ out:
+ 	return error;
+ }
+ 
+ static void acpi_video_dev_remove_notify_handler(struct acpi_video_device *dev)
+ {
+ 	if (dev->flags.notify) {
+ 		acpi_remove_notify_handler(dev->dev->handle, ACPI_DEVICE_NOTIFY,
+ 					   acpi_video_device_notify);
+ 		dev->flags.notify = 0;
+ 	}
+ }
+ 
+ static void acpi_video_bus_remove_notify_handler(struct acpi_video_bus *video)
+ {
+ 	struct acpi_video_device *dev;
+ 
+ 	mutex_lock(&video->device_list_lock);
+ 	list_for_each_entry(dev, &video->video_device_list, entry)
+ 		acpi_video_dev_remove_notify_handler(dev);
+ 	mutex_unlock(&video->device_list_lock);
+ 
+ 	acpi_video_bus_stop_devices(video);
+ 	input_unregister_device(video->input);
+ 	video->input = NULL;
+ }
+ 
+ static int acpi_video_bus_put_devices(struct acpi_video_bus *video)
+ {
+ 	struct acpi_video_device *dev, *next;
+ 
+ 	mutex_lock(&video->device_list_lock);
+ 	list_for_each_entry_safe(dev, next, &video->video_device_list, entry) {
+ 		list_del(&dev->entry);
+ 		kfree(dev);
+ 	}
+ 	mutex_unlock(&video->device_list_lock);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> fbc9fe1b4f22 (ACPI / video: Do not register backlight if win8 and native interface exists)
  static int instance;
  
  static int acpi_video_bus_add(struct acpi_device *device)
diff --cc drivers/acpi/video_detect.c
index 00bcfb92f3ef,b6399343de51..000000000000
--- a/drivers/acpi/video_detect.c
+++ b/drivers/acpi/video_detect.c
@@@ -231,6 -233,12 +231,15 @@@ static void acpi_video_caps_check(void
  		acpi_video_get_capabilities(NULL);
  }
  
++<<<<<<< HEAD
++=======
+ bool acpi_osi_is_win8(void)
+ {
+ 	return acpi_gbl_osi_data >= ACPI_OSI_WIN_8;
+ }
+ EXPORT_SYMBOL(acpi_osi_is_win8);
+ 
++>>>>>>> fbc9fe1b4f22 (ACPI / video: Do not register backlight if win8 and native interface exists)
  /* Promote the vendor interface instead of the generic video module.
   * This function allow DMI blacklists to be implemented by externals
   * platform drivers instead of putting a big blacklist in video_detect.c
* Unmerged path drivers/acpi/internal.h
* Unmerged path drivers/acpi/video.c
* Unmerged path drivers/acpi/video_detect.c
