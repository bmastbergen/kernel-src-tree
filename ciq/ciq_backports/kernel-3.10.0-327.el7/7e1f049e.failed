mm: hugetlb: cleanup using paeg_huge_active()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [mm] hugetlb: cleanup using paeg_huge_active() (Tomoaki Nishimura) [1226196]
Rebuild_FUZZ: 95.35%
commit-author Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
commit 7e1f049efb86bd86c06b80eeac0ef80cdeb8c0e7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/7e1f049e.failed

Now we have an easy access to hugepages' activeness, so existing helpers to
get the information can be cleaned up.

[akpm@linux-foundation.org: s/PageHugeActive/page_huge_active/]
	Signed-off-by: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
	Cc: Hugh Dickins <hughd@google.com>
	Reviewed-by: Michal Hocko <mhocko@suse.cz>
	Cc: Mel Gorman <mgorman@suse.de>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: David Rientjes <rientjes@google.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 7e1f049efb86bd86c06b80eeac0ef80cdeb8c0e7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/hugetlb.h
#	include/linux/page-flags.h
#	mm/hugetlb.c
#	mm/memory_hotplug.c
diff --cc include/linux/hugetlb.h
index 3a38f8dbb7ef,205026175c42..000000000000
--- a/include/linux/hugetlb.h
+++ b/include/linux/hugetlb.h
@@@ -68,10 -82,15 +68,15 @@@ int hugetlb_reserve_pages(struct inode 
  						vm_flags_t vm_flags);
  void hugetlb_unreserve_pages(struct inode *inode, long offset, long freed);
  int dequeue_hwpoisoned_huge_page(struct page *page);
++<<<<<<< HEAD
++=======
+ bool isolate_huge_page(struct page *page, struct list_head *list);
+ void putback_active_hugepage(struct page *page);
++>>>>>>> 7e1f049efb86 (mm: hugetlb: cleanup using paeg_huge_active())
  void free_huge_page(struct page *page);
  
 -#ifdef CONFIG_ARCH_WANT_HUGE_PMD_SHARE
 -pte_t *huge_pmd_share(struct mm_struct *mm, unsigned long addr, pud_t *pud);
 -#endif
 -
 -extern int hugepages_treat_as_movable;
 +extern unsigned long hugepages_treat_as_movable;
 +extern const unsigned long hugetlb_zero, hugetlb_infinity;
  extern int sysctl_hugetlb_shm_group;
  extern struct list_head huge_boot_pages;
  
@@@ -133,6 -146,12 +138,15 @@@ static inline int dequeue_hwpoisoned_hu
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static inline bool isolate_huge_page(struct page *page, struct list_head *list)
+ {
+ 	return false;
+ }
+ #define putback_active_hugepage(p)	do {} while (0)
+ 
++>>>>>>> 7e1f049efb86 (mm: hugetlb: cleanup using paeg_huge_active())
  static inline unsigned long hugetlb_change_protection(struct vm_area_struct *vma,
  		unsigned long address, unsigned long end, pgprot_t newprot)
  {
diff --cc include/linux/page-flags.h
index b529ed7ba3ac,f34e040b34e9..000000000000
--- a/include/linux/page-flags.h
+++ b/include/linux/page-flags.h
@@@ -412,6 -467,21 +412,24 @@@ static inline void ClearPageCompound(st
  
  #endif /* !PAGEFLAGS_EXTENDED */
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_HUGETLB_PAGE
+ int PageHuge(struct page *page);
+ int PageHeadHuge(struct page *page);
+ bool page_huge_active(struct page *page);
+ #else
+ TESTPAGEFLAG_FALSE(Huge)
+ TESTPAGEFLAG_FALSE(HeadHuge)
+ 
+ static inline bool page_huge_active(struct page *page)
+ {
+ 	return 0;
+ }
+ #endif
+ 
+ 
++>>>>>>> 7e1f049efb86 (mm: hugetlb: cleanup using paeg_huge_active())
  #ifdef CONFIG_TRANSPARENT_HUGEPAGE
  /*
   * PageHuge() only returns true for hugetlbfs pages, but not for
diff --cc mm/hugetlb.c
index 567a4225dad3,271e4432734c..000000000000
--- a/mm/hugetlb.c
+++ b/mm/hugetlb.c
@@@ -3467,3 -3928,30 +3457,33 @@@ int dequeue_hwpoisoned_huge_page(struc
  	return ret;
  }
  #endif
++<<<<<<< HEAD
++=======
+ 
+ bool isolate_huge_page(struct page *page, struct list_head *list)
+ {
+ 	bool ret = true;
+ 
+ 	VM_BUG_ON_PAGE(!PageHead(page), page);
+ 	spin_lock(&hugetlb_lock);
+ 	if (!page_huge_active(page) || !get_page_unless_zero(page)) {
+ 		ret = false;
+ 		goto unlock;
+ 	}
+ 	clear_page_huge_active(page);
+ 	list_move_tail(&page->lru, list);
+ unlock:
+ 	spin_unlock(&hugetlb_lock);
+ 	return ret;
+ }
+ 
+ void putback_active_hugepage(struct page *page)
+ {
+ 	VM_BUG_ON_PAGE(!PageHead(page), page);
+ 	spin_lock(&hugetlb_lock);
+ 	set_page_huge_active(page);
+ 	list_move_tail(&page->lru, &(page_hstate(page))->hugepage_activelist);
+ 	spin_unlock(&hugetlb_lock);
+ 	put_page(page);
+ }
++>>>>>>> 7e1f049efb86 (mm: hugetlb: cleanup using paeg_huge_active())
diff --cc mm/memory_hotplug.c
index 4111c993ccc3,457bde530cbe..000000000000
--- a/mm/memory_hotplug.c
+++ b/mm/memory_hotplug.c
@@@ -1250,6 -1372,13 +1250,16 @@@ static unsigned long scan_lru_pages(uns
  			page = pfn_to_page(pfn);
  			if (PageLRU(page))
  				return pfn;
++<<<<<<< HEAD
++=======
+ 			if (PageHuge(page)) {
+ 				if (page_huge_active(page))
+ 					return pfn;
+ 				else
+ 					pfn = round_up(pfn + 1,
+ 						1 << compound_order(page)) - 1;
+ 			}
++>>>>>>> 7e1f049efb86 (mm: hugetlb: cleanup using paeg_huge_active())
  		}
  	}
  	return 0;
* Unmerged path include/linux/hugetlb.h
* Unmerged path include/linux/page-flags.h
* Unmerged path mm/hugetlb.c
* Unmerged path mm/memory_hotplug.c
