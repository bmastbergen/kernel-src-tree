NVMe: fix freeing of wrong request in abort path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Sam Bradshaw <sbradshaw@micron.com>
commit c87fd5407e1aa1cfc6b393b03bf67010cf643dbe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/c87fd540.failed

We allocate 'abort_req', but free 'req' in case of an error
submitting the IO.

	Signed-off-by: Sam Bradshaw <sbradshaw@micron.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit c87fd5407e1aa1cfc6b393b03bf67010cf643dbe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/nvme-core.c
diff --cc drivers/block/nvme-core.c
index 48e1152870d9,cf9b8a8a24d3..000000000000
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@@ -1228,60 -1030,30 +1228,68 @@@ static void nvme_abort_cmd(int cmdid, s
  	if (!dev->abort_limit)
  		return;
  
 -	abort_req = blk_mq_alloc_request(dev->admin_q, WRITE, GFP_ATOMIC,
 -									false);
 -	if (IS_ERR(abort_req))
 +	adminq = rcu_dereference(dev->queues[0]);
 +	a_cmdid = alloc_cmdid(adminq, CMD_CTX_ABORT, special_completion,
 +								ADMIN_TIMEOUT);
 +	if (a_cmdid < 0)
  		return;
  
 -	abort_cmd = blk_mq_rq_to_pdu(abort_req);
 -	nvme_set_info(abort_cmd, abort_req, abort_completion);
 -
  	memset(&cmd, 0, sizeof(cmd));
  	cmd.abort.opcode = nvme_admin_abort_cmd;
 -	cmd.abort.cid = req->tag;
 -	cmd.abort.sqid = cpu_to_le16(nvmeq->qid);
 -	cmd.abort.command_id = abort_req->tag;
 +	cmd.abort.cid = cmdid;
 +	cmd.abort.sqid = nvmeq->qid;
 +	cmd.abort.command_id = a_cmdid;
  
  	--dev->abort_limit;
 -	cmd_rq->aborted = 1;
 +	info[cmdid].aborted = 1;
 +	info[cmdid].timeout = jiffies + ADMIN_TIMEOUT;
  
 -	dev_warn(nvmeq->q_dmadev, "Aborting I/O %d QID %d\n", req->tag,
 +	dev_warn(nvmeq->q_dmadev, "Aborting I/O %d QID %d\n", cmdid,
  							nvmeq->qid);
++<<<<<<< HEAD
 +	nvme_submit_cmd(adminq, &cmd);
 +}
 +
 +/**
 + * nvme_cancel_ios - Cancel outstanding I/Os
 + * @queue: The queue to cancel I/Os on
 + * @timeout: True to only cancel I/Os which have timed out
 + */
 +static void nvme_cancel_ios(struct nvme_queue *nvmeq, bool timeout)
 +{
 +	int depth = nvmeq->q_depth - 1;
 +	struct nvme_cmd_info *info = nvme_cmd_info(nvmeq);
 +	unsigned long now = jiffies;
 +	int cmdid;
 +
 +	for_each_set_bit(cmdid, nvmeq->cmdid_data, depth) {
 +		void *ctx;
 +		nvme_completion_fn fn;
 +		static struct nvme_completion cqe = {
 +			.status = cpu_to_le16(NVME_SC_ABORT_REQ << 1),
 +		};
 +
 +		if (timeout && !time_after(now, info[cmdid].timeout))
 +			continue;
 +		if (info[cmdid].ctx == CMD_CTX_CANCELLED)
 +			continue;
 +		if (timeout && info[cmdid].ctx == CMD_CTX_ASYNC)
 +			continue;
 +		if (timeout && nvmeq->dev->initialized) {
 +			nvme_abort_cmd(cmdid, nvmeq);
 +			continue;
 +		}
 +		dev_warn(nvmeq->q_dmadev, "Cancelling I/O %d QID %d\n", cmdid,
 +								nvmeq->qid);
 +		ctx = cancel_cmdid(nvmeq, cmdid, &fn);
 +		fn(nvmeq, ctx, &cqe);
++=======
+ 	if (nvme_submit_cmd(dev->queues[0], &cmd) < 0) {
+ 		dev_warn(nvmeq->q_dmadev,
+ 				"Could not abort I/O %d QID %d",
+ 				req->tag, nvmeq->qid);
+ 		blk_mq_free_request(abort_req);
++>>>>>>> c87fd5407e1a (NVMe: fix freeing of wrong request in abort path)
  	}
  }
  
* Unmerged path drivers/block/nvme-core.c
