virtio: allow finalize_features to fail

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [virtio] allow finalize_features to fail (Jason Wang) [1227339]
Rebuild_FUZZ: 88.57%
commit-author Michael S. Tsirkin <mst@redhat.com>
commit 5c609a5ef05d98e26778824ba84581fe5e400db6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/5c609a5e.failed

This will make it easy for transports to validate features and return
failure.

	Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
(cherry picked from commit 5c609a5ef05d98e26778824ba84581fe5e400db6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mic/card/mic_virtio.c
#	drivers/remoteproc/remoteproc_virtio.c
#	drivers/virtio/virtio.c
#	drivers/virtio/virtio_mmio.c
#	drivers/virtio/virtio_pci.c
#	include/linux/virtio_config.h
diff --cc drivers/remoteproc/remoteproc_virtio.c
index a34b50690b4e,e1a10232a943..000000000000
--- a/drivers/remoteproc/remoteproc_virtio.c
+++ b/drivers/remoteproc/remoteproc_virtio.c
@@@ -231,7 -234,9 +231,13 @@@ static int rproc_virtio_finalize_featur
  	 * Remember the finalized features of our vdev, and provide it
  	 * to the remote processor once it is powered on.
  	 */
++<<<<<<< HEAD
 +	rsc->gfeatures = vdev->features[0];
++=======
+ 	rsc->gfeatures = vdev->features;
+ 
+ 	return 0;
++>>>>>>> 5c609a5ef05d (virtio: allow finalize_features to fail)
  }
  
  static void rproc_virtio_get(struct virtio_device *vdev, unsigned offset,
diff --cc drivers/virtio/virtio.c
index 683d7137d7c9,e1673a511d17..000000000000
--- a/drivers/virtio/virtio.c
+++ b/drivers/virtio/virtio.c
@@@ -120,32 -178,70 +120,34 @@@ static int virtio_dev_probe(struct devi
  	/* Figure out what features the device supports. */
  	device_features = dev->config->get_features(dev);
  
 -	/* Figure out what features the driver supports. */
 -	driver_features = 0;
 +	/* Features supported by both device and driver into dev->features. */
 +	memset(dev->features, 0, sizeof(dev->features));
  	for (i = 0; i < drv->feature_table_size; i++) {
  		unsigned int f = drv->feature_table[i];
 -		BUG_ON(f >= 64);
 -		driver_features |= (1ULL << f);
 +		BUG_ON(f >= 32);
 +		if (device_features & (1 << f))
 +			set_bit(f, dev->features);
  	}
  
 -	/* Some drivers have a separate feature table for virtio v1.0 */
 -	if (drv->feature_table_legacy) {
 -		driver_features_legacy = 0;
 -		for (i = 0; i < drv->feature_table_size_legacy; i++) {
 -			unsigned int f = drv->feature_table_legacy[i];
 -			BUG_ON(f >= 64);
 -			driver_features_legacy |= (1ULL << f);
 -		}
 -	} else {
 -		driver_features_legacy = driver_features;
 -	}
 -
 -	/* Detect legacy-only drivers and disable VIRTIO_F_VERSION_1. */
 -	if (drv->legacy_only)
 -		device_features &= ~(1ULL << VIRTIO_F_VERSION_1);
 -
 -	if (device_features & (1ULL << VIRTIO_F_VERSION_1))
 -		dev->features = driver_features & device_features;
 -	else
 -		dev->features = driver_features_legacy & device_features;
 -
  	/* Transport features always preserved to pass to finalize_features. */
  	for (i = VIRTIO_TRANSPORT_F_START; i < VIRTIO_TRANSPORT_F_END; i++)
 -		if (device_features & (1ULL << i))
 -			__virtio_set_bit(dev, i);
 +		if (device_features & (1 << i))
 +			set_bit(i, dev->features);
  
- 	dev->config->finalize_features(dev);
+ 	err = dev->config->finalize_features(dev);
+ 	if (err)
+ 		goto err;
  
 -	if (virtio_has_feature(dev, VIRTIO_F_VERSION_1)) {
 -		add_status(dev, VIRTIO_CONFIG_S_FEATURES_OK);
 -		status = dev->config->get_status(dev);
 -		if (!(status & VIRTIO_CONFIG_S_FEATURES_OK)) {
 -			dev_err(_d, "virtio: device refuses features: %x\n",
 -			       status);
 -			err = -ENODEV;
 -			goto err;
 -		}
 -	}
 -
  	err = drv->probe(dev);
  	if (err)
 -		goto err;
 -
 -	add_status(dev, VIRTIO_CONFIG_S_DRIVER_OK);
 -	if (drv->scan)
 -		drv->scan(dev);
 -
 -	virtio_config_enable(dev);
 +		add_status(dev, VIRTIO_CONFIG_S_FAILED);
 +	else {
 +		add_status(dev, VIRTIO_CONFIG_S_DRIVER_OK);
 +		if (drv->scan)
 +			drv->scan(dev);
 +	}
  
 -	return 0;
 -err:
 -	add_status(dev, VIRTIO_CONFIG_S_FAILED);
  	return err;
 -
  }
  
  static int virtio_dev_remove(struct device *_d)
@@@ -235,6 -337,69 +237,72 @@@ void unregister_virtio_device(struct vi
  }
  EXPORT_SYMBOL_GPL(unregister_virtio_device);
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_PM_SLEEP
+ int virtio_device_freeze(struct virtio_device *dev)
+ {
+ 	struct virtio_driver *drv = drv_to_virtio(dev->dev.driver);
+ 
+ 	virtio_config_disable(dev);
+ 
+ 	dev->failed = dev->config->get_status(dev) & VIRTIO_CONFIG_S_FAILED;
+ 
+ 	if (drv && drv->freeze)
+ 		return drv->freeze(dev);
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(virtio_device_freeze);
+ 
+ int virtio_device_restore(struct virtio_device *dev)
+ {
+ 	struct virtio_driver *drv = drv_to_virtio(dev->dev.driver);
+ 	int ret;
+ 
+ 	/* We always start by resetting the device, in case a previous
+ 	 * driver messed it up. */
+ 	dev->config->reset(dev);
+ 
+ 	/* Acknowledge that we've seen the device. */
+ 	add_status(dev, VIRTIO_CONFIG_S_ACKNOWLEDGE);
+ 
+ 	/* Maybe driver failed before freeze.
+ 	 * Restore the failed status, for debugging. */
+ 	if (dev->failed)
+ 		add_status(dev, VIRTIO_CONFIG_S_FAILED);
+ 
+ 	if (!drv)
+ 		return 0;
+ 
+ 	/* We have a driver! */
+ 	add_status(dev, VIRTIO_CONFIG_S_DRIVER);
+ 
+ 	ret = dev->config->finalize_features(dev);
+ 	if (ret)
+ 		goto err;
+ 
+ 	if (drv->restore) {
+ 		ret = drv->restore(dev);
+ 		if (ret)
+ 			goto err;
+ 	}
+ 
+ 	/* Finally, tell the device we're all set */
+ 	add_status(dev, VIRTIO_CONFIG_S_DRIVER_OK);
+ 
+ 	virtio_config_enable(dev);
+ 
+ 	return 0;
+ 
+ err:
+ 	add_status(dev, VIRTIO_CONFIG_S_FAILED);
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(virtio_device_restore);
+ #endif
+ 
++>>>>>>> 5c609a5ef05d (virtio: allow finalize_features to fail)
  static int virtio_init(void)
  {
  	if (bus_register(&virtio_bus) != 0)
diff --cc drivers/virtio/virtio_mmio.c
index e9fdeb861992,5219210d31ce..000000000000
--- a/drivers/virtio/virtio_mmio.c
+++ b/drivers/virtio/virtio_mmio.c
@@@ -152,19 -152,20 +152,29 @@@ static u32 vm_get_features(struct virti
  	return readl(vm_dev->base + VIRTIO_MMIO_HOST_FEATURES);
  }
  
- static void vm_finalize_features(struct virtio_device *vdev)
+ static int vm_finalize_features(struct virtio_device *vdev)
  {
  	struct virtio_mmio_device *vm_dev = to_virtio_mmio_device(vdev);
 +	int i;
  
  	/* Give virtio_ring a chance to accept features. */
  	vring_transport_features(vdev);
  
++<<<<<<< HEAD
 +	for (i = 0; i < ARRAY_SIZE(vdev->features); i++) {
 +		writel(i, vm_dev->base + VIRTIO_MMIO_GUEST_FEATURES_SEL);
 +		writel(vdev->features[i],
 +				vm_dev->base + VIRTIO_MMIO_GUEST_FEATURES);
 +	}
++=======
+ 	/* Make sure we don't have any features > 32 bits! */
+ 	BUG_ON((u32)vdev->features != vdev->features);
+ 
+ 	writel(0, vm_dev->base + VIRTIO_MMIO_GUEST_FEATURES_SEL);
+ 	writel(vdev->features, vm_dev->base + VIRTIO_MMIO_GUEST_FEATURES);
+ 
+ 	return 0;
++>>>>>>> 5c609a5ef05d (virtio: allow finalize_features to fail)
  }
  
  static void vm_get(struct virtio_device *vdev, unsigned offset,
diff --cc drivers/virtio/virtio_pci.c
index 498787bc62e1,9be59d9f2f19..000000000000
--- a/drivers/virtio/virtio_pci.c
+++ b/drivers/virtio/virtio_pci.c
@@@ -122,9 -119,13 +122,15 @@@ static int vp_finalize_features(struct 
  	/* Give virtio_ring a chance to accept features. */
  	vring_transport_features(vdev);
  
 -	/* Make sure we don't have any features > 32 bits! */
 -	BUG_ON((u32)vdev->features != vdev->features);
 -
  	/* We only support 32 feature bits. */
++<<<<<<< HEAD
 +	BUILD_BUG_ON(ARRAY_SIZE(vdev->features) != 1);
 +	iowrite32(vdev->features[0], vp_dev->ioaddr+VIRTIO_PCI_GUEST_FEATURES);
++=======
+ 	iowrite32(vdev->features, vp_dev->ioaddr + VIRTIO_PCI_GUEST_FEATURES);
+ 
+ 	return 0;
++>>>>>>> 5c609a5ef05d (virtio: allow finalize_features to fail)
  }
  
  /* virtio config->get() implementation */
diff --cc include/linux/virtio_config.h
index b14e4d84c48d,7979f850e7ac..000000000000
--- a/include/linux/virtio_config.h
+++ b/include/linux/virtio_config.h
@@@ -66,8 -68,8 +67,13 @@@ struct virtio_config_ops 
  			vq_callback_t *callbacks[],
  			const char *names[]);
  	void (*del_vqs)(struct virtio_device *);
++<<<<<<< HEAD
 +	u32 (*get_features)(struct virtio_device *vdev);
 +	void (*finalize_features)(struct virtio_device *vdev);
++=======
+ 	u64 (*get_features)(struct virtio_device *vdev);
+ 	int (*finalize_features)(struct virtio_device *vdev);
++>>>>>>> 5c609a5ef05d (virtio: allow finalize_features to fail)
  	const char *(*bus_name)(struct virtio_device *vdev);
  	int (*set_vq_affinity)(struct virtqueue *vq, int cpu);
  };
* Unmerged path drivers/misc/mic/card/mic_virtio.c
diff --git a/drivers/lguest/lguest_device.c b/drivers/lguest/lguest_device.c
index d0a1d8a45c81..58489eb0a0ae 100644
--- a/drivers/lguest/lguest_device.c
+++ b/drivers/lguest/lguest_device.c
@@ -126,7 +126,7 @@ static void status_notify(struct virtio_device *vdev)
  * sorted out, this routine is called so we can tell the Host which features we
  * understand and accept.
  */
-static void lg_finalize_features(struct virtio_device *vdev)
+static int lg_finalize_features(struct virtio_device *vdev)
 {
 	unsigned int i, bits;
 	struct lguest_device_desc *desc = to_lgdev(vdev)->desc;
@@ -150,6 +150,8 @@ static void lg_finalize_features(struct virtio_device *vdev)
 
 	/* Tell Host we've finished with this device's feature negotiation */
 	status_notify(vdev);
+
+	return 0;
 }
 
 /* Once they've found a field, getting a copy of it is easy. */
* Unmerged path drivers/misc/mic/card/mic_virtio.c
* Unmerged path drivers/remoteproc/remoteproc_virtio.c
diff --git a/drivers/s390/kvm/kvm_virtio.c b/drivers/s390/kvm/kvm_virtio.c
index 0b51fa7ede7f..fd1284766ee8 100644
--- a/drivers/s390/kvm/kvm_virtio.c
+++ b/drivers/s390/kvm/kvm_virtio.c
@@ -93,7 +93,7 @@ static u32 kvm_get_features(struct virtio_device *vdev)
 	return features;
 }
 
-static void kvm_finalize_features(struct virtio_device *vdev)
+static int kvm_finalize_features(struct virtio_device *vdev)
 {
 	unsigned int i, bits;
 	struct kvm_device_desc *desc = to_kvmdev(vdev)->desc;
@@ -109,6 +109,8 @@ static void kvm_finalize_features(struct virtio_device *vdev)
 		if (test_bit(i, vdev->features))
 			out_features[i / 8] |= (1 << (i % 8));
 	}
+
+	return 0;
 }
 
 /*
diff --git a/drivers/s390/kvm/virtio_ccw.c b/drivers/s390/kvm/virtio_ccw.c
index a33210b204e6..4e43a2f51148 100644
--- a/drivers/s390/kvm/virtio_ccw.c
+++ b/drivers/s390/kvm/virtio_ccw.c
@@ -739,7 +739,7 @@ out_free:
 	return rc;
 }
 
-static void virtio_ccw_finalize_features(struct virtio_device *vdev)
+static int virtio_ccw_finalize_features(struct virtio_device *vdev)
 {
 	struct virtio_ccw_device *vcdev = to_vc_device(vdev);
 	struct virtio_feature_desc *features;
@@ -748,7 +748,7 @@ static void virtio_ccw_finalize_features(struct virtio_device *vdev)
 
 	ccw = kzalloc(sizeof(*ccw), GFP_DMA | GFP_KERNEL);
 	if (!ccw)
-		return;
+		return 0;
 
 	features = kzalloc(sizeof(*features), GFP_DMA | GFP_KERNEL);
 	if (!features)
@@ -773,6 +773,8 @@ static void virtio_ccw_finalize_features(struct virtio_device *vdev)
 out_free:
 	kfree(features);
 	kfree(ccw);
+
+	return 0;
 }
 
 static void virtio_ccw_get_config(struct virtio_device *vdev,
* Unmerged path drivers/virtio/virtio.c
* Unmerged path drivers/virtio/virtio_mmio.c
* Unmerged path drivers/virtio/virtio_pci.c
* Unmerged path include/linux/virtio_config.h
