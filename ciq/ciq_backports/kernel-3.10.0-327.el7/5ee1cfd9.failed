AHCI: Make few function names more descriptive

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Alexander Gordeev <agordeev@redhat.com>
commit 5ee1cfd975518bc9cdcd79e0b76552b5ae5c8c1e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/5ee1cfd9.failed

	Signed-off-by: Alexander Gordeev <agordeev@redhat.com>
	Signed-off-by: Tejun Heo <tj@kernel.org>
	Cc: linux-ide@vger.kernel.org
(cherry picked from commit 5ee1cfd975518bc9cdcd79e0b76552b5ae5c8c1e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/ata/libahci.c
diff --cc drivers/ata/libahci.c
index 198a9d07a8bc,48175e5bd001..000000000000
--- a/drivers/ata/libahci.c
+++ b/drivers/ata/libahci.c
@@@ -1781,7 -1789,7 +1781,11 @@@ static void ahci_port_intr(struct ata_p
  	ahci_handle_port_interrupt(ap, port_mmio, status);
  }
  
++<<<<<<< HEAD
 +irqreturn_t ahci_thread_fn(int irq, void *dev_instance)
++=======
+ static irqreturn_t ahci_port_thread_fn(int irq, void *dev_instance)
++>>>>>>> 5ee1cfd97551 (AHCI: Make few function names more descriptive)
  {
  	struct ata_port *ap = dev_instance;
  	struct ahci_port_priv *pp = ap->private_data;
@@@ -1801,9 -1809,8 +1805,9 @@@
  
  	return IRQ_HANDLED;
  }
 +EXPORT_SYMBOL_GPL(ahci_thread_fn);
  
- static void ahci_hw_port_interrupt(struct ata_port *ap)
+ static void ahci_update_intr_status(struct ata_port *ap)
  {
  	void __iomem *port_mmio = ahci_port_base(ap);
  	struct ahci_port_priv *pp = ap->private_data;
@@@ -1815,7 -1822,7 +1819,11 @@@
  	pp->intr_status |= status;
  }
  
++<<<<<<< HEAD
 +irqreturn_t ahci_hw_interrupt(int irq, void *dev_instance)
++=======
+ static irqreturn_t ahci_multi_irqs_intr(int irq, void *dev_instance)
++>>>>>>> 5ee1cfd97551 (AHCI: Make few function names more descriptive)
  {
  	struct ata_port *ap_this = dev_instance;
  	struct ahci_port_priv *pp = ap_this->private_data;
@@@ -1869,9 -1876,8 +1877,13 @@@
  
  	return IRQ_WAKE_THREAD;
  }
 +EXPORT_SYMBOL_GPL(ahci_hw_interrupt);
  
++<<<<<<< HEAD
 +irqreturn_t ahci_interrupt(int irq, void *dev_instance)
++=======
+ static irqreturn_t ahci_single_irq_intr(int irq, void *dev_instance)
++>>>>>>> 5ee1cfd97551 (AHCI: Make few function names more descriptive)
  {
  	struct ata_host *host = dev_instance;
  	struct ahci_host_priv *hpriv;
@@@ -2458,6 -2469,81 +2470,84 @@@ void ahci_set_em_messages(struct ahci_h
  }
  EXPORT_SYMBOL_GPL(ahci_set_em_messages);
  
++<<<<<<< HEAD
++=======
+ static int ahci_host_activate_multi_irqs(struct ata_host *host, int irq,
+ 					 struct scsi_host_template *sht)
+ {
+ 	int i, rc;
+ 
+ 	rc = ata_host_start(host);
+ 	if (rc)
+ 		return rc;
+ 
+ 	for (i = 0; i < host->n_ports; i++) {
+ 		struct ahci_port_priv *pp = host->ports[i]->private_data;
+ 
+ 		/* Do not receive interrupts sent by dummy ports */
+ 		if (!pp) {
+ 			disable_irq(irq + i);
+ 			continue;
+ 		}
+ 
+ 		rc = devm_request_threaded_irq(host->dev, irq + i,
+ 					       ahci_multi_irqs_intr,
+ 					       ahci_port_thread_fn, IRQF_SHARED,
+ 					       pp->irq_desc, host->ports[i]);
+ 		if (rc)
+ 			goto out_free_irqs;
+ 	}
+ 
+ 	for (i = 0; i < host->n_ports; i++)
+ 		ata_port_desc(host->ports[i], "irq %d", irq + i);
+ 
+ 	rc = ata_host_register(host, sht);
+ 	if (rc)
+ 		goto out_free_all_irqs;
+ 
+ 	return 0;
+ 
+ out_free_all_irqs:
+ 	i = host->n_ports;
+ out_free_irqs:
+ 	for (i--; i >= 0; i--)
+ 		devm_free_irq(host->dev, irq + i, host->ports[i]);
+ 
+ 	return rc;
+ }
+ 
+ /**
+  *	ahci_host_activate - start AHCI host, request IRQs and register it
+  *	@host: target ATA host
+  *	@irq: base IRQ number to request
+  *	@sht: scsi_host_template to use when registering the host
+  *
+  *	Similar to ata_host_activate, but requests IRQs according to AHCI-1.1
+  *	when multiple MSIs were allocated. That is one MSI per port, starting
+  *	from @irq.
+  *
+  *	LOCKING:
+  *	Inherited from calling layer (may sleep).
+  *
+  *	RETURNS:
+  *	0 on success, -errno otherwise.
+  */
+ int ahci_host_activate(struct ata_host *host, int irq,
+ 		       struct scsi_host_template *sht)
+ {
+ 	struct ahci_host_priv *hpriv = host->private_data;
+ 	int rc;
+ 
+ 	if (hpriv->flags & AHCI_HFLAG_MULTI_MSI)
+ 		rc = ahci_host_activate_multi_irqs(host, irq, sht);
+ 	else
+ 		rc = ata_host_activate(host, irq, ahci_single_irq_intr,
+ 				       IRQF_SHARED, sht);
+ 	return rc;
+ }
+ EXPORT_SYMBOL_GPL(ahci_host_activate);
+ 
++>>>>>>> 5ee1cfd97551 (AHCI: Make few function names more descriptive)
  MODULE_AUTHOR("Jeff Garzik");
  MODULE_DESCRIPTION("Common AHCI SATA low-level routines");
  MODULE_LICENSE("GPL");
* Unmerged path drivers/ata/libahci.c
