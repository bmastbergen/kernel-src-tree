tcp.h: Remove extern from function prototypes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] tcp: Remove extern from function prototypes (Florian Westphal) [1151756]
Rebuild_FUZZ: 97.73%
commit-author Joe Perches <joe@perches.com>
commit 5c9f30236f53f3fbee170e2452dfa0e5dce4727b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/5c9f3023.failed

There are a mix of function prototypes with and without extern
in the kernel sources.  Standardize on not using extern for
function prototypes.

Function prototypes don't need to be written with extern.
extern is assumed by the compiler.  Its use is as unnecessary as
using auto to declare automatic/local variables in a block.

	Signed-off-by: Joe Perches <joe@perches.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5c9f30236f53f3fbee170e2452dfa0e5dce4727b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/tcp.h
diff --cc include/net/tcp.h
index 1930c0ee0979,0e47551e9bdb..000000000000
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@@ -345,37 -348,38 +345,61 @@@ extern struct proto tcp_prot
  #define TCP_ADD_STATS_USER(net, field, val) SNMP_ADD_STATS_USER((net)->mib.tcp_statistics, field, val)
  #define TCP_ADD_STATS(net, field, val)	SNMP_ADD_STATS((net)->mib.tcp_statistics, field, val)
  
- extern void tcp_init_mem(struct net *net);
+ void tcp_init_mem(struct net *net);
  
- extern void tcp_tasklet_init(void);
+ void tcp_tasklet_init(void);
  
- extern void tcp_v4_err(struct sk_buff *skb, u32);
+ void tcp_v4_err(struct sk_buff *skb, u32);
  
- extern void tcp_shutdown (struct sock *sk, int how);
+ void tcp_shutdown(struct sock *sk, int how);
  
- extern void tcp_v4_early_demux(struct sk_buff *skb);
- extern int tcp_v4_rcv(struct sk_buff *skb);
+ void tcp_v4_early_demux(struct sk_buff *skb);
+ int tcp_v4_rcv(struct sk_buff *skb);
  
++<<<<<<< HEAD
 +extern int tcp_v4_tw_remember_stamp(struct inet_timewait_sock *tw);
 +extern int tcp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 +		       size_t size);
 +extern int tcp_sendpage(struct sock *sk, struct page *page, int offset,
 +			size_t size, int flags);
 +extern void tcp_release_cb(struct sock *sk);
 +extern void tcp_wfree(struct sk_buff *skb);
 +extern void tcp_write_timer_handler(struct sock *sk);
 +extern void tcp_delack_timer_handler(struct sock *sk);
 +extern int tcp_ioctl(struct sock *sk, int cmd, unsigned long arg);
 +extern int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
 +				 const struct tcphdr *th, unsigned int len);
 +extern void tcp_rcv_established(struct sock *sk, struct sk_buff *skb,
 +				const struct tcphdr *th, unsigned int len);
 +extern void tcp_rcv_space_adjust(struct sock *sk);
 +extern int tcp_twsk_unique(struct sock *sk, struct sock *sktw, void *twp);
 +extern void tcp_twsk_destructor(struct sock *sk);
 +extern ssize_t tcp_splice_read(struct socket *sk, loff_t *ppos,
 +			       struct pipe_inode_info *pipe, size_t len,
 +			       unsigned int flags);
++=======
+ int tcp_v4_tw_remember_stamp(struct inet_timewait_sock *tw);
+ int tcp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
+ 		size_t size);
+ int tcp_sendpage(struct sock *sk, struct page *page, int offset, size_t size,
+ 		 int flags);
+ void tcp_release_cb(struct sock *sk);
+ void tcp_wfree(struct sk_buff *skb);
+ void tcp_write_timer_handler(struct sock *sk);
+ void tcp_delack_timer_handler(struct sock *sk);
+ int tcp_ioctl(struct sock *sk, int cmd, unsigned long arg);
+ int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
+ 			  const struct tcphdr *th, unsigned int len);
+ void tcp_rcv_established(struct sock *sk, struct sk_buff *skb,
+ 			 const struct tcphdr *th, unsigned int len);
+ void tcp_rcv_space_adjust(struct sock *sk);
+ void tcp_cleanup_rbuf(struct sock *sk, int copied);
+ int tcp_twsk_unique(struct sock *sk, struct sock *sktw, void *twp);
+ void tcp_twsk_destructor(struct sock *sk);
+ ssize_t tcp_splice_read(struct socket *sk, loff_t *ppos,
+ 			struct pipe_inode_info *pipe, size_t len,
+ 			unsigned int flags);
++>>>>>>> 5c9f30236f53 (tcp.h: Remove extern from function prototypes)
  
  static inline void tcp_dec_quickack_mode(struct sock *sk,
  					 const unsigned int pkts)
@@@ -473,33 -476,14 +496,39 @@@ void inet_sk_rx_dst_set(struct sock *sk
  
  /* From syncookies.c */
  extern __u32 syncookie_secret[2][16-4+SHA_DIGEST_WORDS];
- extern int __cookie_v4_check(const struct iphdr *iph, const struct tcphdr *th,
- 			     u32 cookie);
- extern struct sock *cookie_v4_check(struct sock *sk, struct sk_buff *skb, 
- 				    struct ip_options *opt);
+ int __cookie_v4_check(const struct iphdr *iph, const struct tcphdr *th,
+ 		      u32 cookie);
+ struct sock *cookie_v4_check(struct sock *sk, struct sk_buff *skb,
+ 			     struct ip_options *opt);
  #ifdef CONFIG_SYN_COOKIES
++<<<<<<< HEAD
 +#include <linux/ktime.h>
 +/* Syncookies use a monotonic timer which increments every 60 seconds.
 + * This counter is used both as a hash input and partially encoded into
 + * the cookie value.  A cookie is only validated further if the delta
 + * between the current counter value and the encoded one is less than this,
 + * i.e. a sent cookie is valid only at most for 2*60 seconds (or less if
 + * the counter advances immediately after a cookie is generated).
 + */
 +#define MAX_SYNCOOKIE_AGE 2
 +
 +static inline u32 tcp_cookie_time(void)
 +{
 +	u64 val = get_jiffies_64();
 +
 +	do_div(val, 60 * HZ);
 +	return val;
 +}
 +
 +extern u32 __cookie_v4_init_sequence(const struct iphdr *iph,
 +				     const struct tcphdr *th, u16 *mssp);
 +extern __u32 cookie_v4_init_sequence(struct sock *sk, struct sk_buff *skb, 
 +				     __u16 *mss);
++=======
+ u32 __cookie_v4_init_sequence(const struct iphdr *iph, const struct tcphdr *th,
+ 			      u16 *mssp);
+ __u32 cookie_v4_init_sequence(struct sock *sk, struct sk_buff *skb, __u16 *mss);
++>>>>>>> 5c9f30236f53 (tcp.h: Remove extern from function prototypes)
  #else
  static inline __u32 cookie_v4_init_sequence(struct sock *sk,
  					    struct sk_buff *skb,
@@@ -1034,9 -1017,15 +1062,9 @@@ static inline void tcp_prequeue_init(st
  	tp->ucopy.len = 0;
  	tp->ucopy.memory = 0;
  	skb_queue_head_init(&tp->ucopy.prequeue);
 -#ifdef CONFIG_NET_DMA
 -	tp->ucopy.dma_chan = NULL;
 -	tp->ucopy.wakeup = 0;
 -	tp->ucopy.pinned_list = NULL;
 -	tp->ucopy.dma_cookie = 0;
 -#endif
  }
  
- extern bool tcp_prequeue(struct sock *sk, struct sk_buff *skb);
+ bool tcp_prequeue(struct sock *sk, struct sk_buff *skb);
  
  #undef STATE_TRACE
  
@@@ -1103,11 -1091,11 +1130,11 @@@ static inline void tcp_openreq_init(str
  	ireq->wscale_ok = rx_opt->wscale_ok;
  	ireq->acked = 0;
  	ireq->ecn_ok = 0;
 -	ireq->rmt_port = tcp_hdr(skb)->source;
 -	ireq->loc_port = tcp_hdr(skb)->dest;
 +	ireq->ir_rmt_port = tcp_hdr(skb)->source;
 +	ireq->ir_num = ntohs(tcp_hdr(skb)->dest);
  }
  
- extern void tcp_enter_memory_pressure(struct sock *sk);
+ void tcp_enter_memory_pressure(struct sock *sk);
  
  static inline int keepalive_intvl_when(const struct tcp_sock *tp)
  {
@@@ -1542,20 -1529,31 +1567,26 @@@ void tcp_proc_unregister(struct net *ne
  extern struct request_sock_ops tcp_request_sock_ops;
  extern struct request_sock_ops tcp6_request_sock_ops;
  
- extern void tcp_v4_destroy_sock(struct sock *sk);
+ void tcp_v4_destroy_sock(struct sock *sk);
  
++<<<<<<< HEAD
 +struct sk_buff *tcp_gso_segment(struct sk_buff *skb,
 +				netdev_features_t features);
 +extern struct sk_buff **tcp_gro_receive(struct sk_buff **head,
 +					struct sk_buff *skb);
 +extern int tcp_gro_complete(struct sk_buff *skb);
++=======
+ struct sk_buff *tcp_tso_segment(struct sk_buff *skb,
+ 				netdev_features_t features);
+ struct sk_buff **tcp_gro_receive(struct sk_buff **head, struct sk_buff *skb);
+ int tcp_gro_complete(struct sk_buff *skb);
++>>>>>>> 5c9f30236f53 (tcp.h: Remove extern from function prototypes)
  
- extern void __tcp_v4_send_check(struct sk_buff *skb, __be32 saddr,
- 				__be32 daddr);
+ void __tcp_v4_send_check(struct sk_buff *skb, __be32 saddr, __be32 daddr);
  
 -static inline u32 tcp_notsent_lowat(const struct tcp_sock *tp)
 -{
 -	return tp->notsent_lowat ?: sysctl_tcp_notsent_lowat;
 -}
 -
 -static inline bool tcp_stream_memory_free(const struct sock *sk)
 -{
 -	const struct tcp_sock *tp = tcp_sk(sk);
 -	u32 notsent_bytes = tp->write_seq - tp->snd_nxt;
 -
 -	return notsent_bytes < tcp_notsent_lowat(tp);
 -}
 -
  #ifdef CONFIG_PROC_FS
- extern int tcp4_proc_init(void);
- extern void tcp4_proc_exit(void);
+ int tcp4_proc_init(void);
+ void tcp4_proc_exit(void);
  #endif
  
  /* TCP af-specific functions */
* Unmerged path include/net/tcp.h
