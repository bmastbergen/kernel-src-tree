xfrm: Fix crash with ipv6 IPsec tunnel and NAT.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] xfrm: Fix crash with ipv6 IPsec tunnel and NAT (Hannes Frederic Sowa) [1162395]
Rebuild_FUZZ: 98.92%
commit-author Steffen Klassert <steffen.klassert@secunet.com>
commit 5596732fa8c14139018ecda8356eabbfb599d830
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/5596732f.failed

The ipv6 xfrm output path is not aware that packets can be
rerouted by NAT to not use IPsec. We crash in this case
because we expect to have a xfrm state at the dst_entry.
This crash happens if the ipv6 layer does IPsec and NAT
or if we have an interfamily IPsec tunnel with ipv4 NAT.

We fix this by checking for a NAT rerouted packet in each
address family and dst_output() to the new destination
in this case.

	Reported-by: Martin Pelikan <martin.pelikan@gmail.com>
	Tested-by: Martin Pelikan <martin.pelikan@gmail.com>
	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit 5596732fa8c14139018ecda8356eabbfb599d830)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/xfrm4_output.c
diff --cc net/ipv4/xfrm4_output.c
index 4c2cbb6224dc,f3800bf79d86..000000000000
--- a/net/ipv4/xfrm4_output.c
+++ b/net/ipv4/xfrm4_output.c
@@@ -86,14 -80,32 +81,27 @@@ int xfrm4_output_finish(struct sk_buff 
  	return xfrm_output(skb);
  }
  
++<<<<<<< HEAD
 +int xfrm4_output(struct sock *sk, struct sk_buff *skb)
++=======
+ static int __xfrm4_output(struct sk_buff *skb)
  {
- 	struct dst_entry *dst = skb_dst(skb);
- 	struct xfrm_state *x = dst->xfrm;
+ 	struct xfrm_state *x = skb_dst(skb)->xfrm;
+ 
+ #ifdef CONFIG_NETFILTER
+ 	if (!x) {
+ 		IPCB(skb)->flags |= IPSKB_REROUTED;
+ 		return dst_output(skb);
+ 	}
+ #endif
  
+ 	return x->outer_mode->afinfo->output_finish(skb);
+ }
+ 
+ int xfrm4_output(struct sk_buff *skb)
++>>>>>>> 5596732fa8c1 (xfrm: Fix crash with ipv6 IPsec tunnel and NAT.)
+ {
  	return NF_HOOK_COND(NFPROTO_IPV4, NF_INET_POST_ROUTING, skb,
- 			    NULL, dst->dev,
- 			    x->outer_mode->afinfo->output_finish,
+ 			    NULL, skb_dst(skb)->dev, __xfrm4_output,
  			    !(IPCB(skb)->flags & IPSKB_REROUTED));
  }
 -
 -void xfrm4_local_error(struct sk_buff *skb, u32 mtu)
 -{
 -	struct iphdr *hdr;
 -
 -	hdr = skb->encapsulation ? inner_ip_hdr(skb) : ip_hdr(skb);
 -	ip_local_error(skb->sk, EMSGSIZE, hdr->daddr,
 -		       inet_sk(skb->sk)->inet_dport, mtu);
 -}
* Unmerged path net/ipv4/xfrm4_output.c
diff --git a/net/ipv6/xfrm6_output.c b/net/ipv6/xfrm6_output.c
index a6d851e984dd..efe0a49b5789 100644
--- a/net/ipv6/xfrm6_output.c
+++ b/net/ipv6/xfrm6_output.c
@@ -110,12 +110,6 @@ int xfrm6_prepare_output(struct xfrm_state *x, struct sk_buff *skb)
 	if (err)
 		return err;
 
-	memset(IP6CB(skb), 0, sizeof(*IP6CB(skb)));
-#ifdef CONFIG_NETFILTER
-	IP6CB(skb)->flags |= IP6SKB_XFRM_TRANSFORMED;
-#endif
-
-	skb->protocol = htons(ETH_P_IPV6);
 	skb->local_df = 1;
 
 	return x->outer_mode->output2(x, skb);
@@ -124,11 +118,13 @@ EXPORT_SYMBOL(xfrm6_prepare_output);
 
 int xfrm6_output_finish(struct sk_buff *skb)
 {
+	memset(IP6CB(skb), 0, sizeof(*IP6CB(skb)));
+	skb->protocol = htons(ETH_P_IPV6);
+
 #ifdef CONFIG_NETFILTER
 	IP6CB(skb)->flags |= IP6SKB_XFRM_TRANSFORMED;
 #endif
 
-	skb->protocol = htons(ETH_P_IPV6);
 	return xfrm_output(skb);
 }
 
@@ -138,6 +134,13 @@ static int __xfrm6_output(struct sk_buff *skb)
 	struct xfrm_state *x = dst->xfrm;
 	int mtu;
 
+#ifdef CONFIG_NETFILTER
+	if (!x) {
+		IP6CB(skb)->flags |= IP6SKB_REROUTED;
+		return dst_output(skb);
+	}
+#endif
+
 	if (skb->protocol == htons(ETH_P_IPV6))
 		mtu = ip6_skb_dst_mtu(skb);
 	else
@@ -161,6 +164,7 @@ static int __xfrm6_output(struct sk_buff *skb)
 
 int xfrm6_output(struct sock *sk, struct sk_buff *skb)
 {
-	return NF_HOOK(NFPROTO_IPV6, NF_INET_POST_ROUTING, skb, NULL,
-		       skb_dst(skb)->dev, __xfrm6_output);
+	return NF_HOOK_COND(NFPROTO_IPV6, NF_INET_POST_ROUTING, skb,
+			    NULL, skb_dst(skb)->dev, __xfrm6_output,
+			    !(IP6CB(skb)->flags & IP6SKB_REROUTED));
 }
