xfs: rework xfs_buf_bio_endio error handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit 61be9c529a4a715ab8679e9ca82bc3790c7ab66c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/61be9c52.failed

Currently the report of a bio error from completion
immediately marks the buffer with an error. The issue is that this
is racy w.r.t. synchronous IO - the submitter can see b_error being
set before the IO is complete, and hence we cannot differentiate
between submission failures and completion failures.

Add an internal b_io_error field protected by the b_lock to catch IO
completion errors, and only propagate that to the buffer during
final IO completion handling. Hence we can tell in xfs_buf_iorequest
if we've had a submission failure bey checking bp->b_error before
dropping our b_io_remaining reference - that reference will prevent
b_io_error values from being propagated to b_error in the event that
completion races with submission.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit 61be9c529a4a715ab8679e9ca82bc3790c7ab66c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_buf.c
#	fs/xfs/xfs_buf.h
diff --cc fs/xfs/xfs_buf.c
index f83c9cff6fbd,170d6c0afe71..000000000000
--- a/fs/xfs/xfs_buf.c
+++ b/fs/xfs/xfs_buf.c
@@@ -1038,9 -1008,21 +1038,22 @@@ xfs_buf_iodone_work
  
  	bp->b_flags &= ~(XBF_READ | XBF_WRITE | XBF_READ_AHEAD);
  
++<<<<<<< HEAD
 +	/* only validate buffers that were read without errors */
 +	if (read && bp->b_ops && !bp->b_error && (bp->b_flags & XBF_DONE))
++=======
+ 	/*
+ 	 * Pull in IO completion errors now. We are guaranteed to be running
+ 	 * single threaded, so we don't need the lock to read b_io_error.
+ 	 */
+ 	if (!bp->b_error && bp->b_io_error)
+ 		xfs_buf_ioerror(bp, bp->b_io_error);
+ 
+ 	/* Only validate buffers that were read without errors */
+ 	if (read && !bp->b_error && bp->b_ops) {
+ 		ASSERT(!bp->b_iodone);
++>>>>>>> 61be9c529a4a (xfs: rework xfs_buf_bio_endio error handling)
  		bp->b_ops->verify_read(bp);
 -	}
 -
 -	if (!bp->b_error)
 -		bp->b_flags |= XBF_DONE;
  
  	if (bp->b_iodone)
  		(*(bp->b_iodone))(bp);
@@@ -1236,8 -1199,12 +1249,17 @@@ xfs_buf_bio_end_io
  	 * don't overwrite existing errors - otherwise we can lose errors on
  	 * buffers that require multiple bios to complete.
  	 */
++<<<<<<< HEAD
 +	if (!bp->b_error)
 +		xfs_buf_ioerror(bp, -error);
++=======
+ 	if (error) {
+ 		spin_lock(&bp->b_lock);
+ 		if (!bp->b_io_error)
+ 			bp->b_io_error = error;
+ 		spin_unlock(&bp->b_lock);
+ 	}
++>>>>>>> 61be9c529a4a (xfs: rework xfs_buf_bio_endio error handling)
  
  	if (!bp->b_error && xfs_buf_is_vmapped(bp) && (bp->b_flags & XBF_READ))
  		invalidate_kernel_vmap_range(bp->b_addr, xfs_buf_vmap_len(bp));
diff --cc fs/xfs/xfs_buf.h
index 75e98ced9b68,44db8cd67bda..000000000000
--- a/fs/xfs/xfs_buf.h
+++ b/fs/xfs/xfs_buf.h
@@@ -154,7 -156,9 +154,13 @@@ typedef struct xfs_buf 
  	 * bt_lru_lock and not by b_sema
  	 */
  	struct list_head	b_lru;		/* lru list */
++<<<<<<< HEAD
 +	xfs_buf_flags_t		b_lru_flags;	/* internal lru status flags */
++=======
+ 	spinlock_t		b_lock;		/* internal state lock */
+ 	unsigned int		b_state;	/* internal state flags */
+ 	int			b_io_error;	/* internal IO error state */
++>>>>>>> 61be9c529a4a (xfs: rework xfs_buf_bio_endio error handling)
  	wait_queue_head_t	b_waiters;	/* unpin waiters */
  	struct list_head	b_list;
  	struct xfs_perag	*b_pag;		/* contains rbtree root */
* Unmerged path fs/xfs/xfs_buf.c
* Unmerged path fs/xfs/xfs_buf.h
