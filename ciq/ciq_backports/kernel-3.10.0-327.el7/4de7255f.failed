vhost: extend memory regions allocation to vmalloc

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [vhost] extend memory regions allocation to vmalloc (Igor Mammedov) [1152962]
Rebuild_FUZZ: 92.47%
commit-author Igor Mammedov <imammedo@redhat.com>
commit 4de7255f7d2be5e51664c6ac6011ffd6e5463571
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/4de7255f.failed

with large number of memory regions we could end up with
high order allocations and kmalloc could fail if
host is under memory pressure.
Considering that memory regions array is used on hot path
try harder to allocate using kmalloc and if it fails resort
to vmalloc.
It's still better than just failing vhost_set_memory() and
causing guest crash due to it when a new memory hotplugged
to guest.

I'll still look at QEMU side solution to reduce amount of
memory regions it feeds to vhost to make things even better,
but it doesn't hurt for kernel to behave smarter and don't
crash older QEMU's which could use large amount of memory
regions.

	Signed-off-by: Igor Mammedov <imammedo@redhat.com>
	Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
(cherry picked from commit 4de7255f7d2be5e51664c6ac6011ffd6e5463571)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/vhost/vhost.c
diff --cc drivers/vhost/vhost.c
index 5e5c05823ea8,a4ac369f6adb..000000000000
--- a/drivers/vhost/vhost.c
+++ b/drivers/vhost/vhost.c
@@@ -463,10 -545,8 +464,15 @@@ void vhost_dev_cleanup(struct vhost_de
  		fput(dev->log_file);
  	dev->log_file = NULL;
  	/* No one will access memory at this point */
++<<<<<<< HEAD
 +	kfree(rcu_dereference_protected(dev->memory,
 +					locked ==
 +						lockdep_is_held(&dev->mutex)));
 +	RCU_INIT_POINTER(dev->memory, NULL);
++=======
+ 	kvfree(dev->memory);
+ 	dev->memory = NULL;
++>>>>>>> 4de7255f7d2b (vhost: extend memory regions allocation to vmalloc)
  	WARN_ON(!list_empty(&dev->work_list));
  	if (dev->worker) {
  		kthread_stop(dev->worker);
@@@ -627,14 -713,19 +645,27 @@@ static long vhost_set_memory(struct vho
  		vhost_memory_reg_sort_cmp, NULL);
  
  	if (!memory_access_ok(d, newmem, 0)) {
- 		kfree(newmem);
+ 		kvfree(newmem);
  		return -EFAULT;
  	}
++<<<<<<< HEAD
 +	oldmem = rcu_dereference_protected(d->memory,
 +					   lockdep_is_held(&d->mutex));
 +	rcu_assign_pointer(d->memory, newmem);
 +	synchronize_rcu();
 +	kfree(oldmem);
++=======
+ 	oldmem = d->memory;
+ 	d->memory = newmem;
+ 
+ 	/* All memory accesses are done under some VQ mutex. */
+ 	for (i = 0; i < d->nvqs; ++i) {
+ 		mutex_lock(&d->vqs[i]->mutex);
+ 		d->vqs[i]->memory = newmem;
+ 		mutex_unlock(&d->vqs[i]->mutex);
+ 	}
+ 	kvfree(oldmem);
++>>>>>>> 4de7255f7d2b (vhost: extend memory regions allocation to vmalloc)
  	return 0;
  }
  
* Unmerged path drivers/vhost/vhost.c
