PCI: pciehp: Remove struct controller.no_cmd_complete

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [pci] pciehp: Remove struct controller.no_cmd_complete (Myron Stowe) [1223472]
Rebuild_FUZZ: 95.05%
commit-author Rajat Jain <rajatxjain@gmail.com>
commit 6c1a32e06758ba1c997f81a3c41e780cfc77b3c2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/6c1a32e0.failed

"no_cmd_complete" is only used once, and it duplicates read-only
information we already have in the cached Slot Capabilities value.

Remove the field and use the existing macro NO_CMD_CMPL() instead.

[bhelgaas: changelog]
	Signed-off-by: Rajat Jain <rajatxjain@gmail.com>
	Signed-off-by: Rajat Jain <rajatjain@juniper.net>
	Signed-off-by: Guenter Roeck <groeck@juniper.net>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit 6c1a32e06758ba1c997f81a3c41e780cfc77b3c2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/pciehp_hpc.c
diff --cc drivers/pci/hotplug/pciehp_hpc.c
index f253bb808636,f7c370993ab4..000000000000
--- a/drivers/pci/hotplug/pciehp_hpc.c
+++ b/drivers/pci/hotplug/pciehp_hpc.c
@@@ -129,18 -128,52 +129,38 @@@ static int pcie_poll_cmd(struct control
  	return 0;	/* timeout */
  }
  
 -static void pcie_wait_cmd(struct controller *ctrl)
 +static void pcie_wait_cmd(struct controller *ctrl, int poll)
  {
  	unsigned int msecs = pciehp_poll_mode ? 2500 : 1000;
 -	unsigned long duration = msecs_to_jiffies(msecs);
 -	unsigned long cmd_timeout = ctrl->cmd_started + duration;
 -	unsigned long now, timeout;
 +	unsigned long timeout = msecs_to_jiffies(msecs);
  	int rc;
  
++<<<<<<< HEAD
 +	if (poll)
 +		rc = pcie_poll_cmd(ctrl);
++=======
+ 	/*
+ 	 * If the controller does not generate notifications for command
+ 	 * completions, we never need to wait between writes.
+ 	 */
+ 	if (NO_CMD_CMPL(ctrl))
+ 		return;
+ 
+ 	if (!ctrl->cmd_busy)
+ 		return;
+ 
+ 	/*
+ 	 * Even if the command has already timed out, we want to call
+ 	 * pcie_poll_cmd() so it can clear PCI_EXP_SLTSTA_CC.
+ 	 */
+ 	now = jiffies;
+ 	if (time_before_eq(cmd_timeout, now))
+ 		timeout = 1;
++>>>>>>> 6c1a32e06758 (PCI: pciehp: Remove struct controller.no_cmd_complete)
  	else
 -		timeout = cmd_timeout - now;
 -
 -	if (ctrl->slot_ctrl & PCI_EXP_SLTCTL_HPIE &&
 -	    ctrl->slot_ctrl & PCI_EXP_SLTCTL_CCIE)
  		rc = wait_event_timeout(ctrl->queue, !ctrl->cmd_busy, timeout);
 -	else
 -		rc = pcie_poll_cmd(ctrl, timeout);
 -
 -	/*
 -	 * Controllers with errata like Intel CF118 don't generate
 -	 * completion notifications unless the power/indicator/interlock
 -	 * control bits are changed.  On such controllers, we'll emit this
 -	 * timeout message when we wait for completion of commands that
 -	 * don't change those bits, e.g., commands that merely enable
 -	 * interrupts.
 -	 */
  	if (!rc)
 -		ctrl_info(ctrl, "Timeout on hotplug command %#010x (issued %u msec ago)\n",
 -			  ctrl->slot_ctrl,
 -			  jiffies_to_msecs(now - ctrl->cmd_started));
 +		ctrl_dbg(ctrl, "Command not completed in 1000 msec\n");
  }
  
  /**
@@@ -777,22 -771,13 +797,32 @@@ struct controller *pcie_init(struct pci
  	mutex_init(&ctrl->ctrl_lock);
  	init_waitqueue_head(&ctrl->queue);
  	dbg_ctrl(ctrl);
++<<<<<<< HEAD
 +	/*
 +	 * Controller doesn't notify of command completion if the "No
 +	 * Command Completed Support" bit is set in Slot Capability
 +	 * register or the controller supports none of power
 +	 * controller, attention led, power led and EMI.
 +	 */
 +	if (NO_CMD_CMPL(ctrl) ||
 +	    !(POWER_CTRL(ctrl) | ATTN_LED(ctrl) | PWR_LED(ctrl) | EMI(ctrl)))
 +	    ctrl->no_cmd_complete = 1;
 +
 +        /* Check if Data Link Layer Link Active Reporting is implemented */
 +        pcie_capability_read_dword(pdev, PCI_EXP_LNKCAP, &link_cap);
 +        if (link_cap & PCI_EXP_LNKCAP_DLLLARC) {
 +                ctrl_dbg(ctrl, "Link Active Reporting supported\n");
 +                ctrl->link_active_reporting = 1;
 +        }
++=======
+ 
+ 	/* Check if Data Link Layer Link Active Reporting is implemented */
+ 	pcie_capability_read_dword(pdev, PCI_EXP_LNKCAP, &link_cap);
+ 	if (link_cap & PCI_EXP_LNKCAP_DLLLARC) {
+ 		ctrl_dbg(ctrl, "Link Active Reporting supported\n");
+ 		ctrl->link_active_reporting = 1;
+ 	}
++>>>>>>> 6c1a32e06758 (PCI: pciehp: Remove struct controller.no_cmd_complete)
  
  	/* Clear all remaining event bits in Slot Status register */
  	pcie_capability_write_word(pdev, PCI_EXP_SLTSTA,
diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 7bae08bc1a61..d1ae405c2918 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -94,7 +94,6 @@ struct controller {
 	u32 slot_cap;
 	struct timer_list poll_timer;
 	unsigned int cmd_busy:1;
-	unsigned int no_cmd_complete:1;
 	unsigned int link_active_reporting:1;
 	unsigned int notification_enabled:1;
 	unsigned int power_fault_detected;
* Unmerged path drivers/pci/hotplug/pciehp_hpc.c
