KVM: x86/vPMU: Define kvm_pmu_ops to support vPMU function dispatch

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [x86] kvm: Define kvm_pmu_ops to support vPMU function dispatch (Wei Huang) [1076010]
Rebuild_FUZZ: 91.94%
commit-author Wei Huang <wehuang@redhat.com>
commit 25462f7f5295e2d3e9c2b31761ac95f0b3c8562f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/25462f7f.failed

This patch defines a new function pointer struct (kvm_pmu_ops) to
support vPMU for both Intel and AMD. The functions pointers defined in
this new struct will be linked with Intel and AMD functions later. In the
meanwhile the struct that maps from event_sel bits to PERF_TYPE_HARDWARE
events is renamed and moved from Intel specific code to kvm_host.h as a
common struct.

	Reviewed-by: Joerg Roedel <jroedel@suse.de>
	Tested-by: Joerg Roedel <jroedel@suse.de>
	Signed-off-by: Wei Huang <wei@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 25462f7f5295e2d3e9c2b31761ac95f0b3c8562f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/kvm_host.h
#	arch/x86/kvm/pmu.c
#	arch/x86/kvm/pmu.h
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/include/asm/kvm_host.h
index 5e84fe1d6c52,5a2b4508be44..000000000000
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@@ -796,6 -831,33 +798,36 @@@ struct kvm_x86_ops 
  	int (*check_nested_events)(struct kvm_vcpu *vcpu, bool external_intr);
  
  	void (*sched_in)(struct kvm_vcpu *kvm, int cpu);
++<<<<<<< HEAD
++=======
+ 
+ 	/*
+ 	 * Arch-specific dirty logging hooks. These hooks are only supposed to
+ 	 * be valid if the specific arch has hardware-accelerated dirty logging
+ 	 * mechanism. Currently only for PML on VMX.
+ 	 *
+ 	 *  - slot_enable_log_dirty:
+ 	 *	called when enabling log dirty mode for the slot.
+ 	 *  - slot_disable_log_dirty:
+ 	 *	called when disabling log dirty mode for the slot.
+ 	 *	also called when slot is created with log dirty disabled.
+ 	 *  - flush_log_dirty:
+ 	 *	called before reporting dirty_bitmap to userspace.
+ 	 *  - enable_log_dirty_pt_masked:
+ 	 *	called when reenabling log dirty for the GFNs in the mask after
+ 	 *	corresponding bits are cleared in slot->dirty_bitmap.
+ 	 */
+ 	void (*slot_enable_log_dirty)(struct kvm *kvm,
+ 				      struct kvm_memory_slot *slot);
+ 	void (*slot_disable_log_dirty)(struct kvm *kvm,
+ 				       struct kvm_memory_slot *slot);
+ 	void (*flush_log_dirty)(struct kvm *kvm);
+ 	void (*enable_log_dirty_pt_masked)(struct kvm *kvm,
+ 					   struct kvm_memory_slot *slot,
+ 					   gfn_t offset, unsigned long mask);
+ 	/* pmu operations of sub-arch */
+ 	const struct kvm_pmu_ops *pmu_ops;
++>>>>>>> 25462f7f5295 (KVM: x86/vPMU: Define kvm_pmu_ops to support vPMU function dispatch)
  };
  
  struct kvm_arch_async_pf {
diff --cc arch/x86/kvm/pmu.c
index ed5c6727d1e3,31aa2c85dc97..000000000000
--- a/arch/x86/kvm/pmu.c
+++ b/arch/x86/kvm/pmu.c
@@@ -19,81 -20,34 +20,108 @@@
  #include "x86.h"
  #include "cpuid.h"
  #include "lapic.h"
 -#include "pmu.h"
  
++<<<<<<< HEAD
 +static struct kvm_arch_event_perf_mapping {
 +	u8 eventsel;
 +	u8 unit_mask;
 +	unsigned event_type;
 +	bool inexact;
 +} arch_events[] = {
 +	/* Index must match CPUID 0x0A.EBX bit vector */
 +	[0] = { 0x3c, 0x00, PERF_COUNT_HW_CPU_CYCLES },
 +	[1] = { 0xc0, 0x00, PERF_COUNT_HW_INSTRUCTIONS },
 +	[2] = { 0x3c, 0x01, PERF_COUNT_HW_BUS_CYCLES  },
 +	[3] = { 0x2e, 0x4f, PERF_COUNT_HW_CACHE_REFERENCES },
 +	[4] = { 0x2e, 0x41, PERF_COUNT_HW_CACHE_MISSES },
 +	[5] = { 0xc4, 0x00, PERF_COUNT_HW_BRANCH_INSTRUCTIONS },
 +	[6] = { 0xc5, 0x00, PERF_COUNT_HW_BRANCH_MISSES },
 +	[7] = { 0x00, 0x30, PERF_COUNT_HW_REF_CPU_CYCLES },
 +};
 +
 +/* mapping between fixed pmc index and arch_events array */
 +int fixed_pmc_events[] = {1, 0, 7};
 +
 +static bool pmc_is_gp(struct kvm_pmc *pmc)
 +{
 +	return pmc->type == KVM_PMC_GP;
 +}
 +
 +static inline u64 pmc_bitmask(struct kvm_pmc *pmc)
 +{
 +	struct kvm_pmu *pmu = pmc_to_pmu(pmc);
 +
 +	return pmu->counter_bitmask[pmc->type];
 +}
 +
 +static inline bool pmc_enabled(struct kvm_pmc *pmc)
 +{
 +	struct kvm_pmu *pmu = pmc_to_pmu(pmc);
 +	return test_bit(pmc->idx, (unsigned long *)&pmu->global_ctrl);
 +}
 +
 +static inline struct kvm_pmc *get_gp_pmc(struct kvm_pmu *pmu, u32 msr,
 +					 u32 base)
 +{
 +	if (msr >= base && msr < base + pmu->nr_arch_gp_counters)
 +		return &pmu->gp_counters[msr - base];
 +	return NULL;
 +}
 +
 +static inline struct kvm_pmc *get_fixed_pmc(struct kvm_pmu *pmu, u32 msr)
 +{
 +	int base = MSR_CORE_PERF_FIXED_CTR0;
 +	if (msr >= base && msr < base + pmu->nr_arch_fixed_counters)
 +		return &pmu->fixed_counters[msr - base];
 +	return NULL;
 +}
 +
 +static inline struct kvm_pmc *get_fixed_pmc_idx(struct kvm_pmu *pmu, int idx)
 +{
 +	return get_fixed_pmc(pmu, MSR_CORE_PERF_FIXED_CTR0 + idx);
 +}
 +
 +static struct kvm_pmc *global_idx_to_pmc(struct kvm_pmu *pmu, int idx)
 +{
 +	if (idx < INTEL_PMC_IDX_FIXED)
 +		return get_gp_pmc(pmu, MSR_P6_EVNTSEL0 + idx, MSR_P6_EVNTSEL0);
 +	else
 +		return get_fixed_pmc_idx(pmu, idx - INTEL_PMC_IDX_FIXED);
 +}
++=======
+ /* NOTE:
+  * - Each perf counter is defined as "struct kvm_pmc";
+  * - There are two types of perf counters: general purpose (gp) and fixed.
+  *   gp counters are stored in gp_counters[] and fixed counters are stored
+  *   in fixed_counters[] respectively. Both of them are part of "struct
+  *   kvm_pmu";
+  * - pmu.c understands the difference between gp counters and fixed counters.
+  *   However AMD doesn't support fixed-counters;
+  * - There are three types of index to access perf counters (PMC):
+  *     1. MSR (named msr): For example Intel has MSR_IA32_PERFCTRn and AMD
+  *        has MSR_K7_PERFCTRn.
+  *     2. MSR Index (named idx): This normally is used by RDPMC instruction.
+  *        For instance AMD RDPMC instruction uses 0000_0003h in ECX to access
+  *        C001_0007h (MSR_K7_PERCTR3). Intel has a similar mechanism, except
+  *        that it also supports fixed counters. idx can be used to as index to
+  *        gp and fixed counters.
+  *     3. Global PMC Index (named pmc): pmc is an index specific to PMU
+  *        code. Each pmc, stored in kvm_pmc.idx field, is unique across
+  *        all perf counters (both gp and fixed). The mapping relationship
+  *        between pmc and perf counters is as the following:
+  *        * Intel: [0 .. INTEL_PMC_MAX_GENERIC-1] <=> gp counters
+  *                 [INTEL_PMC_IDX_FIXED .. INTEL_PMC_IDX_FIXED + 2] <=> fixed
+  *        * AMD:   [0 .. AMD64_NUM_COUNTERS-1] <=> gp counters
+  */
++>>>>>>> 25462f7f5295 (KVM: x86/vPMU: Define kvm_pmu_ops to support vPMU function dispatch)
  
 -static void kvm_pmi_trigger_fn(struct irq_work *irq_work)
 +void kvm_deliver_pmi(struct kvm_vcpu *vcpu)
 +{
 +	if (vcpu->arch.apic)
 +		kvm_apic_local_deliver(vcpu->arch.apic, APIC_LVTPC);
 +}
 +
 +static void trigger_pmi(struct irq_work *irq_work)
  {
  	struct kvm_pmu *pmu = container_of(irq_work, struct kvm_pmu, irq_work);
  	struct kvm_vcpu *vcpu = pmu_to_vcpu(pmu);
@@@ -136,33 -96,10 +164,40 @@@ static void kvm_perf_overflow_intr(stru
  	}
  }
  
++<<<<<<< HEAD
 +static u64 read_pmc(struct kvm_pmc *pmc)
 +{
 +	u64 counter, enabled, running;
 +
 +	counter = pmc->counter;
 +
 +	if (pmc->perf_event)
 +		counter += perf_event_read_value(pmc->perf_event,
 +						 &enabled, &running);
 +
 +	/* FIXME: Scaling needed? */
 +
 +	return counter & pmc_bitmask(pmc);
 +}
 +
 +static void stop_counter(struct kvm_pmc *pmc)
 +{
 +	if (pmc->perf_event) {
 +		pmc->counter = read_pmc(pmc);
 +		perf_event_release_kernel(pmc->perf_event);
 +		pmc->perf_event = NULL;
 +	}
 +}
 +
 +static void reprogram_counter(struct kvm_pmc *pmc, u32 type,
 +		unsigned config, bool exclude_user, bool exclude_kernel,
 +		bool intr, bool in_tx, bool in_tx_cp)
++=======
+ static void pmc_reprogram_counter(struct kvm_pmc *pmc, u32 type,
+ 				  unsigned config, bool exclude_user,
+ 				  bool exclude_kernel, bool intr,
+ 				  bool in_tx, bool in_tx_cp)
++>>>>>>> 25462f7f5295 (KVM: x86/vPMU: Define kvm_pmu_ops to support vPMU function dispatch)
  {
  	struct perf_event *event;
  	struct perf_event_attr attr = {
@@@ -231,12 -152,13 +249,22 @@@ void reprogram_gp_counter(struct kvm_pm
  	unit_mask = (eventsel & ARCH_PERFMON_EVENTSEL_UMASK) >> 8;
  
  	if (!(eventsel & (ARCH_PERFMON_EVENTSEL_EDGE |
++<<<<<<< HEAD
 +				ARCH_PERFMON_EVENTSEL_INV |
 +				ARCH_PERFMON_EVENTSEL_CMASK |
 +				HSW_IN_TX |
 +				HSW_IN_TX_CHECKPOINTED))) {
 +		config = find_arch_event(pmc_to_pmu(pmc), event_select,
 +				unit_mask);
++=======
+ 			  ARCH_PERFMON_EVENTSEL_INV |
+ 			  ARCH_PERFMON_EVENTSEL_CMASK |
+ 			  HSW_IN_TX |
+ 			  HSW_IN_TX_CHECKPOINTED))) {
+ 		config = kvm_x86_ops->pmu_ops->find_arch_event(pmc_to_pmu(pmc),
+ 						      event_select,
+ 						      unit_mask);
++>>>>>>> 25462f7f5295 (KVM: x86/vPMU: Define kvm_pmu_ops to support vPMU function dispatch)
  		if (config != PERF_COUNT_HW_MAX)
  			type = PERF_TYPE_HARDWARE;
  	}
@@@ -244,56 -166,36 +272,76 @@@
  	if (type == PERF_TYPE_RAW)
  		config = eventsel & X86_RAW_EVENT_MASK;
  
 -	pmc_reprogram_counter(pmc, type, config,
 -			      !(eventsel & ARCH_PERFMON_EVENTSEL_USR),
 -			      !(eventsel & ARCH_PERFMON_EVENTSEL_OS),
 -			      eventsel & ARCH_PERFMON_EVENTSEL_INT,
 -			      (eventsel & HSW_IN_TX),
 -			      (eventsel & HSW_IN_TX_CHECKPOINTED));
 +	reprogram_counter(pmc, type, config,
 +			!(eventsel & ARCH_PERFMON_EVENTSEL_USR),
 +			!(eventsel & ARCH_PERFMON_EVENTSEL_OS),
 +			eventsel & ARCH_PERFMON_EVENTSEL_INT,
 +			(eventsel & HSW_IN_TX),
 +			(eventsel & HSW_IN_TX_CHECKPOINTED));
  }
+ EXPORT_SYMBOL_GPL(reprogram_gp_counter);
  
++<<<<<<< HEAD
 +static void reprogram_fixed_counter(struct kvm_pmc *pmc, u8 en_pmi, int idx)
++=======
+ void reprogram_fixed_counter(struct kvm_pmc *pmc, u8 ctrl, int idx)
++>>>>>>> 25462f7f5295 (KVM: x86/vPMU: Define kvm_pmu_ops to support vPMU function dispatch)
  {
 -	unsigned en_field = ctrl & 0x3;
 -	bool pmi = ctrl & 0x8;
 +	unsigned en = en_pmi & 0x3;
 +	bool pmi = en_pmi & 0x8;
  
 -	pmc_stop_counter(pmc);
 +	stop_counter(pmc);
  
 -	if (!en_field || !pmc_is_enabled(pmc))
 +	if (!en || !pmc_enabled(pmc))
  		return;
  
++<<<<<<< HEAD
 +	reprogram_counter(pmc, PERF_TYPE_HARDWARE,
 +			arch_events[fixed_pmc_events[idx]].event_type,
 +			!(en & 0x2), /* exclude user */
 +			!(en & 0x1), /* exclude kernel */
 +			pmi, false, false);
++=======
+ 	pmc_reprogram_counter(pmc, PERF_TYPE_HARDWARE,
+ 			      kvm_x86_ops->pmu_ops->find_fixed_event(idx),
+ 			      !(en_field & 0x2), /* exclude user */
+ 			      !(en_field & 0x1), /* exclude kernel */
+ 			      pmi, false, false);
++>>>>>>> 25462f7f5295 (KVM: x86/vPMU: Define kvm_pmu_ops to support vPMU function dispatch)
  }
+ EXPORT_SYMBOL_GPL(reprogram_fixed_counter);
  
++<<<<<<< HEAD
 +static inline u8 fixed_en_pmi(u64 ctrl, int idx)
 +{
 +	return (ctrl >> (idx * 4)) & 0xf;
 +}
 +
 +static void reprogram_fixed_counters(struct kvm_pmu *pmu, u64 data)
 +{
 +	int i;
 +
 +	for (i = 0; i < pmu->nr_arch_fixed_counters; i++) {
 +		u8 en_pmi = fixed_en_pmi(data, i);
 +		struct kvm_pmc *pmc = get_fixed_pmc_idx(pmu, i);
 +
 +		if (fixed_en_pmi(pmu->fixed_ctr_ctrl, i) == en_pmi)
 +			continue;
 +
 +		reprogram_fixed_counter(pmc, en_pmi, i);
 +	}
 +
 +	pmu->fixed_ctr_ctrl = data;
 +}
 +
 +static void reprogram_idx(struct kvm_pmu *pmu, int idx)
 +{
 +	struct kvm_pmc *pmc = global_idx_to_pmc(pmu, idx);
++=======
+ void reprogram_counter(struct kvm_pmu *pmu, int pmc_idx)
+ {
+ 	struct kvm_pmc *pmc = kvm_x86_ops->pmu_ops->pmc_idx_to_pmc(pmu, pmc_idx);
++>>>>>>> 25462f7f5295 (KVM: x86/vPMU: Define kvm_pmu_ops to support vPMU function dispatch)
  
  	if (!pmc)
  		return;
@@@ -301,251 -203,104 +349,269 @@@
  	if (pmc_is_gp(pmc))
  		reprogram_gp_counter(pmc, pmc->eventsel);
  	else {
 -		int idx = pmc_idx - INTEL_PMC_IDX_FIXED;
 -		u8 ctrl = fixed_ctrl_field(pmu->fixed_ctr_ctrl, idx);
 -
 -		reprogram_fixed_counter(pmc, ctrl, idx);
 +		int fidx = idx - INTEL_PMC_IDX_FIXED;
 +		reprogram_fixed_counter(pmc,
 +				fixed_en_pmi(pmu->fixed_ctr_ctrl, fidx), fidx);
  	}
  }
++<<<<<<< HEAD
 +
 +static void global_ctrl_changed(struct kvm_pmu *pmu, u64 data)
 +{
 +	int bit;
 +	u64 diff = pmu->global_ctrl ^ data;
 +
 +	pmu->global_ctrl = data;
 +
 +	for_each_set_bit(bit, (unsigned long *)&diff, X86_PMC_IDX_MAX)
 +		reprogram_idx(pmu, bit);
 +}
 +
 +bool kvm_pmu_msr(struct kvm_vcpu *vcpu, u32 msr)
++=======
+ EXPORT_SYMBOL_GPL(reprogram_counter);
+ 
+ void kvm_pmu_handle_event(struct kvm_vcpu *vcpu)
  {
  	struct kvm_pmu *pmu = vcpu_to_pmu(vcpu);
- 	int ret;
+ 	u64 bitmask;
+ 	int bit;
  
- 	switch (msr) {
- 	case MSR_CORE_PERF_FIXED_CTR_CTRL:
- 	case MSR_CORE_PERF_GLOBAL_STATUS:
- 	case MSR_CORE_PERF_GLOBAL_CTRL:
- 	case MSR_CORE_PERF_GLOBAL_OVF_CTRL:
- 		ret = pmu->version > 1;
- 		break;
- 	default:
- 		ret = get_gp_pmc(pmu, msr, MSR_IA32_PERFCTR0)
- 			|| get_gp_pmc(pmu, msr, MSR_P6_EVNTSEL0)
- 			|| get_fixed_pmc(pmu, msr);
- 		break;
+ 	bitmask = pmu->reprogram_pmi;
+ 
+ 	for_each_set_bit(bit, (unsigned long *)&bitmask, X86_PMC_IDX_MAX) {
+ 		struct kvm_pmc *pmc = kvm_x86_ops->pmu_ops->pmc_idx_to_pmc(pmu, bit);
+ 
+ 		if (unlikely(!pmc || !pmc->perf_event)) {
+ 			clear_bit(bit, (unsigned long *)&pmu->reprogram_pmi);
+ 			continue;
+ 		}
+ 
+ 		reprogram_counter(pmu, bit);
  	}
- 	return ret;
  }
  
- int kvm_pmu_get_msr(struct kvm_vcpu *vcpu, u32 index, u64 *data)
+ /* check if idx is a valid index to access PMU */
+ int kvm_pmu_is_valid_msr_idx(struct kvm_vcpu *vcpu, unsigned idx)
+ {
+ 	return kvm_x86_ops->pmu_ops->is_valid_msr_idx(vcpu, idx);
+ }
+ 
+ int kvm_pmu_rdpmc(struct kvm_vcpu *vcpu, unsigned idx, u64 *data)
  {
+ 	bool fast_mode = idx & (1u << 31);
+ 	struct kvm_pmc *pmc;
+ 	u64 ctr_val;
+ 
+ 	pmc = kvm_x86_ops->pmu_ops->msr_idx_to_pmc(vcpu, idx);
+ 	if (!pmc)
+ 		return 1;
+ 
+ 	ctr_val = pmc_read_counter(pmc);
+ 	if (fast_mode)
+ 		ctr_val = (u32)ctr_val;
+ 
+ 	*data = ctr_val;
+ 	return 0;
+ }
+ 
+ void kvm_pmu_deliver_pmi(struct kvm_vcpu *vcpu)
+ {
+ 	if (vcpu->arch.apic)
+ 		kvm_apic_local_deliver(vcpu->arch.apic, APIC_LVTPC);
+ }
+ 
+ bool kvm_pmu_is_valid_msr(struct kvm_vcpu *vcpu, u32 msr)
++>>>>>>> 25462f7f5295 (KVM: x86/vPMU: Define kvm_pmu_ops to support vPMU function dispatch)
+ {
+ 	return kvm_x86_ops->pmu_ops->is_valid_msr(vcpu, msr);
+ }
+ 
+ int kvm_pmu_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *data)
+ {
++<<<<<<< HEAD
 +	struct kvm_pmu *pmu = vcpu_to_pmu(vcpu);
 +	struct kvm_pmc *pmc;
 +
 +	switch (index) {
 +	case MSR_CORE_PERF_FIXED_CTR_CTRL:
 +		*data = pmu->fixed_ctr_ctrl;
 +		return 0;
 +	case MSR_CORE_PERF_GLOBAL_STATUS:
 +		*data = pmu->global_status;
 +		return 0;
 +	case MSR_CORE_PERF_GLOBAL_CTRL:
 +		*data = pmu->global_ctrl;
 +		return 0;
 +	case MSR_CORE_PERF_GLOBAL_OVF_CTRL:
 +		*data = pmu->global_ovf_ctrl;
 +		return 0;
 +	default:
 +		if ((pmc = get_gp_pmc(pmu, index, MSR_IA32_PERFCTR0)) ||
 +				(pmc = get_fixed_pmc(pmu, index))) {
 +			*data = read_pmc(pmc);
 +			return 0;
 +		} else if ((pmc = get_gp_pmc(pmu, index, MSR_P6_EVNTSEL0))) {
 +			*data = pmc->eventsel;
 +			return 0;
 +		}
 +	}
 +	return 1;
++=======
+ 	return kvm_x86_ops->pmu_ops->get_msr(vcpu, msr, data);
++>>>>>>> 25462f7f5295 (KVM: x86/vPMU: Define kvm_pmu_ops to support vPMU function dispatch)
  }
  
  int kvm_pmu_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
  {
++<<<<<<< HEAD
 +	struct kvm_pmu *pmu = vcpu_to_pmu(vcpu);
 +	struct kvm_pmc *pmc;
 +	u32 index = msr_info->index;
 +	u64 data = msr_info->data;
 +
 +	switch (index) {
 +	case MSR_CORE_PERF_FIXED_CTR_CTRL:
 +		if (pmu->fixed_ctr_ctrl == data)
 +			return 0;
 +		if (!(data & 0xfffffffffffff444ull)) {
 +			reprogram_fixed_counters(pmu, data);
 +			return 0;
 +		}
 +		break;
 +	case MSR_CORE_PERF_GLOBAL_STATUS:
 +		if (msr_info->host_initiated) {
 +			pmu->global_status = data;
 +			return 0;
 +		}
 +		break; /* RO MSR */
 +	case MSR_CORE_PERF_GLOBAL_CTRL:
 +		if (pmu->global_ctrl == data)
 +			return 0;
 +		if (!(data & pmu->global_ctrl_mask)) {
 +			global_ctrl_changed(pmu, data);
 +			return 0;
 +		}
 +		break;
 +	case MSR_CORE_PERF_GLOBAL_OVF_CTRL:
 +		if (!(data & (pmu->global_ctrl_mask & ~(3ull<<62)))) {
 +			if (!msr_info->host_initiated)
 +				pmu->global_status &= ~data;
 +			pmu->global_ovf_ctrl = data;
 +			return 0;
 +		}
 +		break;
 +	default:
 +		if ((pmc = get_gp_pmc(pmu, index, MSR_IA32_PERFCTR0)) ||
 +				(pmc = get_fixed_pmc(pmu, index))) {
 +			if (!msr_info->host_initiated)
 +				data = (s64)(s32)data;
 +			pmc->counter += data - read_pmc(pmc);
 +			return 0;
 +		} else if ((pmc = get_gp_pmc(pmu, index, MSR_P6_EVNTSEL0))) {
 +			if (data == pmc->eventsel)
 +				return 0;
 +			if (!(data & pmu->reserved_bits)) {
 +				reprogram_gp_counter(pmc, data);
 +				return 0;
 +			}
 +		}
 +	}
 +	return 1;
++=======
+ 	return kvm_x86_ops->pmu_ops->set_msr(vcpu, msr_info);
++>>>>>>> 25462f7f5295 (KVM: x86/vPMU: Define kvm_pmu_ops to support vPMU function dispatch)
  }
  
 -/* refresh PMU settings. This function generally is called when underlying
 - * settings are changed (such as changes of PMU CPUID by guest VMs), which
 - * should rarely happen.
 - */
 -void kvm_pmu_refresh(struct kvm_vcpu *vcpu)
 +int kvm_pmu_check_pmc(struct kvm_vcpu *vcpu, unsigned pmc)
 +{
 +	struct kvm_pmu *pmu = vcpu_to_pmu(vcpu);
 +	bool fixed = pmc & (1u << 30);
 +	pmc &= ~(3u << 30);
 +	return (!fixed && pmc >= pmu->nr_arch_gp_counters) ||
 +		(fixed && pmc >= pmu->nr_arch_fixed_counters);
 +}
 +
 +int kvm_pmu_read_pmc(struct kvm_vcpu *vcpu, unsigned pmc, u64 *data)
 +{
 +	struct kvm_pmu *pmu = vcpu_to_pmu(vcpu);
 +	bool fast_mode = pmc & (1u << 31);
 +	bool fixed = pmc & (1u << 30);
 +	struct kvm_pmc *counters;
 +	u64 ctr;
 +
 +	pmc &= ~(3u << 30);
 +	if (!fixed && pmc >= pmu->nr_arch_gp_counters)
 +		return 1;
 +	if (fixed && pmc >= pmu->nr_arch_fixed_counters)
 +		return 1;
 +	counters = fixed ? pmu->fixed_counters : pmu->gp_counters;
 +	ctr = read_pmc(&counters[pmc]);
 +	if (fast_mode)
 +		ctr = (u32)ctr;
 +	*data = ctr;
 +
 +	return 0;
 +}
 +
 +void kvm_pmu_cpuid_update(struct kvm_vcpu *vcpu)
  {
- 	struct kvm_pmu *pmu = vcpu_to_pmu(vcpu);
- 	struct kvm_cpuid_entry2 *entry;
- 	union cpuid10_eax eax;
- 	union cpuid10_edx edx;
- 
- 	pmu->nr_arch_gp_counters = 0;
- 	pmu->nr_arch_fixed_counters = 0;
- 	pmu->counter_bitmask[KVM_PMC_GP] = 0;
- 	pmu->counter_bitmask[KVM_PMC_FIXED] = 0;
- 	pmu->version = 0;
- 	pmu->reserved_bits = 0xffffffff00200000ull;
- 
- 	entry = kvm_find_cpuid_entry(vcpu, 0xa, 0);
- 	if (!entry)
- 		return;
- 	eax.full = entry->eax;
- 	edx.full = entry->edx;
- 
- 	pmu->version = eax.split.version_id;
- 	if (!pmu->version)
- 		return;
- 
- 	pmu->nr_arch_gp_counters = min_t(int, eax.split.num_counters,
- 					INTEL_PMC_MAX_GENERIC);
- 	pmu->counter_bitmask[KVM_PMC_GP] = ((u64)1 << eax.split.bit_width) - 1;
- 	pmu->available_event_types = ~entry->ebx &
- 					((1ull << eax.split.mask_length) - 1);
- 
- 	if (pmu->version == 1) {
- 		pmu->nr_arch_fixed_counters = 0;
- 	} else {
- 		pmu->nr_arch_fixed_counters =
- 			min_t(int, edx.split.num_counters_fixed,
- 				INTEL_PMC_MAX_FIXED);
- 		pmu->counter_bitmask[KVM_PMC_FIXED] =
- 			((u64)1 << edx.split.bit_width_fixed) - 1;
- 	}
+ 	kvm_x86_ops->pmu_ops->refresh(vcpu);
+ }
  
- 	pmu->global_ctrl = ((1 << pmu->nr_arch_gp_counters) - 1) |
- 		(((1ull << pmu->nr_arch_fixed_counters) - 1) << INTEL_PMC_IDX_FIXED);
- 	pmu->global_ctrl_mask = ~pmu->global_ctrl;
++<<<<<<< HEAD
++=======
+ void kvm_pmu_reset(struct kvm_vcpu *vcpu)
+ {
+ 	struct kvm_pmu *pmu = vcpu_to_pmu(vcpu);
  
- 	entry = kvm_find_cpuid_entry(vcpu, 7, 0);
- 	if (entry &&
- 	    (boot_cpu_has(X86_FEATURE_HLE) || boot_cpu_has(X86_FEATURE_RTM)) &&
- 	    (entry->ebx & (X86_FEATURE_HLE|X86_FEATURE_RTM)))
- 		pmu->reserved_bits ^= HSW_IN_TX|HSW_IN_TX_CHECKPOINTED;
+ 	irq_work_sync(&pmu->irq_work);
+ 	kvm_x86_ops->pmu_ops->reset(vcpu);
  }
  
++>>>>>>> 25462f7f5295 (KVM: x86/vPMU: Define kvm_pmu_ops to support vPMU function dispatch)
  void kvm_pmu_init(struct kvm_vcpu *vcpu)
  {
- 	int i;
  	struct kvm_pmu *pmu = vcpu_to_pmu(vcpu);
  
  	memset(pmu, 0, sizeof(*pmu));
++<<<<<<< HEAD
 +	for (i = 0; i < INTEL_PMC_MAX_GENERIC; i++) {
 +		pmu->gp_counters[i].type = KVM_PMC_GP;
 +		pmu->gp_counters[i].vcpu = vcpu;
 +		pmu->gp_counters[i].idx = i;
 +	}
 +	for (i = 0; i < INTEL_PMC_MAX_FIXED; i++) {
 +		pmu->fixed_counters[i].type = KVM_PMC_FIXED;
 +		pmu->fixed_counters[i].vcpu = vcpu;
 +		pmu->fixed_counters[i].idx = i + INTEL_PMC_IDX_FIXED;
 +	}
 +	init_irq_work(&pmu->irq_work, trigger_pmi);
 +	kvm_pmu_cpuid_update(vcpu);
 +}
 +
 +void kvm_pmu_reset(struct kvm_vcpu *vcpu)
 +{
 +	struct kvm_pmu *pmu = vcpu_to_pmu(vcpu);
 +	int i;
 +
 +	irq_work_sync(&pmu->irq_work);
 +	for (i = 0; i < INTEL_PMC_MAX_GENERIC; i++) {
 +		struct kvm_pmc *pmc = &pmu->gp_counters[i];
 +		stop_counter(pmc);
 +		pmc->counter = pmc->eventsel = 0;
 +	}
 +
 +	for (i = 0; i < INTEL_PMC_MAX_FIXED; i++)
 +		stop_counter(&pmu->fixed_counters[i]);
 +
 +	pmu->fixed_ctr_ctrl = pmu->global_ctrl = pmu->global_status =
 +		pmu->global_ovf_ctrl = 0;
++=======
+ 	kvm_x86_ops->pmu_ops->init(vcpu);
+ 	init_irq_work(&pmu->irq_work, kvm_pmi_trigger_fn);
+ 	kvm_pmu_refresh(vcpu);
++>>>>>>> 25462f7f5295 (KVM: x86/vPMU: Define kvm_pmu_ops to support vPMU function dispatch)
  }
  
  void kvm_pmu_destroy(struct kvm_vcpu *vcpu)
diff --cc arch/x86/kvm/vmx.c
index 103323e9b775,e5a379f82672..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -45,8 -45,10 +45,9 @@@
  #include <asm/perf_event.h>
  #include <asm/debugreg.h>
  #include <asm/kexec.h>
 -#include <asm/apic.h>
  
  #include "trace.h"
+ #include "pmu.h"
  
  #define __ex(x) __kvm_handle_fault_on_reboot(x)
  #define __ex_clear(x, reg) \
@@@ -9464,6 -10415,13 +9465,16 @@@ static struct kvm_x86_ops vmx_x86_ops 
  	.check_nested_events = vmx_check_nested_events,
  
  	.sched_in = vmx_sched_in,
++<<<<<<< HEAD
++=======
+ 
+ 	.slot_enable_log_dirty = vmx_slot_enable_log_dirty,
+ 	.slot_disable_log_dirty = vmx_slot_disable_log_dirty,
+ 	.flush_log_dirty = vmx_flush_log_dirty,
+ 	.enable_log_dirty_pt_masked = vmx_enable_log_dirty_pt_masked,
+ 
+ 	.pmu_ops = &intel_pmu_ops,
++>>>>>>> 25462f7f5295 (KVM: x86/vPMU: Define kvm_pmu_ops to support vPMU function dispatch)
  };
  
  static int __init vmx_init(void)
* Unmerged path arch/x86/kvm/pmu.h
* Unmerged path arch/x86/include/asm/kvm_host.h
diff --git a/arch/x86/kvm/Makefile b/arch/x86/kvm/Makefile
index 08f790dfadc9..c4aaeb707c8d 100644
--- a/arch/x86/kvm/Makefile
+++ b/arch/x86/kvm/Makefile
@@ -14,8 +14,8 @@ kvm-$(CONFIG_KVM_ASYNC_PF)	+= $(KVM)/async_pf.o
 kvm-y			+= x86.o mmu.o emulate.o i8259.o irq.o lapic.o \
 			   i8254.o ioapic.o irq_comm.o cpuid.o pmu.o
 kvm-$(CONFIG_KVM_DEVICE_ASSIGNMENT)	+= assigned-dev.o iommu.o
-kvm-intel-y		+= vmx.o
-kvm-amd-y		+= svm.o
+kvm-intel-y		+= vmx.o pmu_intel.o
+kvm-amd-y		+= svm.o pmu_amd.o
 
 obj-$(CONFIG_KVM)	+= kvm.o
 obj-$(CONFIG_KVM_INTEL)	+= kvm-intel.o
* Unmerged path arch/x86/kvm/pmu.c
* Unmerged path arch/x86/kvm/pmu.h
diff --git a/arch/x86/kvm/pmu_amd.c b/arch/x86/kvm/pmu_amd.c
new file mode 100644
index 000000000000..48786407fee1
--- /dev/null
+++ b/arch/x86/kvm/pmu_amd.c
@@ -0,0 +1,97 @@
+/*
+ * KVM PMU support for AMD
+ *
+ * Copyright 2015, Red Hat, Inc. and/or its affiliates.
+ *
+ * Author:
+ *   Wei Huang <wei@redhat.com>
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2.  See
+ * the COPYING file in the top-level directory.
+ *
+ * Implementation is based on pmu_intel.c file
+ */
+#include <linux/types.h>
+#include <linux/kvm_host.h>
+#include <linux/perf_event.h>
+#include "x86.h"
+#include "cpuid.h"
+#include "lapic.h"
+#include "pmu.h"
+
+static unsigned amd_find_arch_event(struct kvm_pmu *pmu,
+				    u8 event_select,
+				    u8 unit_mask)
+{
+	return PERF_COUNT_HW_MAX;
+}
+
+/* return PERF_COUNT_HW_MAX as AMD doesn't have fixed events */
+static unsigned amd_find_fixed_event(int idx)
+{
+	return PERF_COUNT_HW_MAX;
+}
+
+static bool amd_pmc_is_enabled(struct kvm_pmc *pmc)
+{
+	return false;
+}
+
+static struct kvm_pmc *amd_pmc_idx_to_pmc(struct kvm_pmu *pmu, int pmc_idx)
+{
+	return NULL;
+}
+
+/* returns 0 if idx's corresponding MSR exists; otherwise returns 1. */
+static int amd_is_valid_msr_idx(struct kvm_vcpu *vcpu, unsigned idx)
+{
+	return 1;
+}
+
+/* idx is the ECX register of RDPMC instruction */
+static struct kvm_pmc *amd_msr_idx_to_pmc(struct kvm_vcpu *vcpu, unsigned idx)
+{
+	return NULL;
+}
+
+static bool amd_is_valid_msr(struct kvm_vcpu *vcpu, u32 msr)
+{
+	return false;
+}
+
+static int amd_pmu_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *data)
+{
+	return 1;
+}
+
+static int amd_pmu_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
+{
+	return 1;
+}
+
+static void amd_pmu_refresh(struct kvm_vcpu *vcpu)
+{
+}
+
+static void amd_pmu_init(struct kvm_vcpu *vcpu)
+{
+}
+
+static void amd_pmu_reset(struct kvm_vcpu *vcpu)
+{
+}
+
+struct kvm_pmu_ops amd_pmu_ops = {
+	.find_arch_event = amd_find_arch_event,
+	.find_fixed_event = amd_find_fixed_event,
+	.pmc_is_enabled = amd_pmc_is_enabled,
+	.pmc_idx_to_pmc = amd_pmc_idx_to_pmc,
+	.msr_idx_to_pmc = amd_msr_idx_to_pmc,
+	.is_valid_msr_idx = amd_is_valid_msr_idx,
+	.is_valid_msr = amd_is_valid_msr,
+	.get_msr = amd_pmu_get_msr,
+	.set_msr = amd_pmu_set_msr,
+	.refresh = amd_pmu_refresh,
+	.init = amd_pmu_init,
+	.reset = amd_pmu_reset,
+};
diff --git a/arch/x86/kvm/pmu_intel.c b/arch/x86/kvm/pmu_intel.c
new file mode 100644
index 000000000000..ab38af4f4947
--- /dev/null
+++ b/arch/x86/kvm/pmu_intel.c
@@ -0,0 +1,358 @@
+/*
+ * KVM PMU support for Intel CPUs
+ *
+ * Copyright 2011 Red Hat, Inc. and/or its affiliates.
+ *
+ * Authors:
+ *   Avi Kivity   <avi@redhat.com>
+ *   Gleb Natapov <gleb@redhat.com>
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2.  See
+ * the COPYING file in the top-level directory.
+ *
+ */
+#include <linux/types.h>
+#include <linux/kvm_host.h>
+#include <linux/perf_event.h>
+#include <asm/perf_event.h>
+#include "x86.h"
+#include "cpuid.h"
+#include "lapic.h"
+#include "pmu.h"
+
+static struct kvm_event_hw_type_mapping intel_arch_events[] = {
+	/* Index must match CPUID 0x0A.EBX bit vector */
+	[0] = { 0x3c, 0x00, PERF_COUNT_HW_CPU_CYCLES },
+	[1] = { 0xc0, 0x00, PERF_COUNT_HW_INSTRUCTIONS },
+	[2] = { 0x3c, 0x01, PERF_COUNT_HW_BUS_CYCLES  },
+	[3] = { 0x2e, 0x4f, PERF_COUNT_HW_CACHE_REFERENCES },
+	[4] = { 0x2e, 0x41, PERF_COUNT_HW_CACHE_MISSES },
+	[5] = { 0xc4, 0x00, PERF_COUNT_HW_BRANCH_INSTRUCTIONS },
+	[6] = { 0xc5, 0x00, PERF_COUNT_HW_BRANCH_MISSES },
+	[7] = { 0x00, 0x30, PERF_COUNT_HW_REF_CPU_CYCLES },
+};
+
+/* mapping between fixed pmc index and intel_arch_events array */
+static int fixed_pmc_events[] = {1, 0, 7};
+
+static void reprogram_fixed_counters(struct kvm_pmu *pmu, u64 data)
+{
+	int i;
+
+	for (i = 0; i < pmu->nr_arch_fixed_counters; i++) {
+		u8 new_ctrl = fixed_ctrl_field(data, i);
+		u8 old_ctrl = fixed_ctrl_field(pmu->fixed_ctr_ctrl, i);
+		struct kvm_pmc *pmc;
+
+		pmc = get_fixed_pmc(pmu, MSR_CORE_PERF_FIXED_CTR0 + i);
+
+		if (old_ctrl == new_ctrl)
+			continue;
+
+		reprogram_fixed_counter(pmc, new_ctrl, i);
+	}
+
+	pmu->fixed_ctr_ctrl = data;
+}
+
+/* function is called when global control register has been updated. */
+static void global_ctrl_changed(struct kvm_pmu *pmu, u64 data)
+{
+	int bit;
+	u64 diff = pmu->global_ctrl ^ data;
+
+	pmu->global_ctrl = data;
+
+	for_each_set_bit(bit, (unsigned long *)&diff, X86_PMC_IDX_MAX)
+		reprogram_counter(pmu, bit);
+}
+
+static unsigned intel_find_arch_event(struct kvm_pmu *pmu,
+				      u8 event_select,
+				      u8 unit_mask)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(intel_arch_events); i++)
+		if (intel_arch_events[i].eventsel == event_select
+		    && intel_arch_events[i].unit_mask == unit_mask
+		    && (pmu->available_event_types & (1 << i)))
+			break;
+
+	if (i == ARRAY_SIZE(intel_arch_events))
+		return PERF_COUNT_HW_MAX;
+
+	return intel_arch_events[i].event_type;
+}
+
+static unsigned intel_find_fixed_event(int idx)
+{
+	if (idx >= ARRAY_SIZE(fixed_pmc_events))
+		return PERF_COUNT_HW_MAX;
+
+	return intel_arch_events[fixed_pmc_events[idx]].event_type;
+}
+
+/* check if a PMC is enabled by comparising it with globl_ctrl bits. */
+static bool intel_pmc_is_enabled(struct kvm_pmc *pmc)
+{
+	struct kvm_pmu *pmu = pmc_to_pmu(pmc);
+
+	return test_bit(pmc->idx, (unsigned long *)&pmu->global_ctrl);
+}
+
+static struct kvm_pmc *intel_pmc_idx_to_pmc(struct kvm_pmu *pmu, int pmc_idx)
+{
+	if (pmc_idx < INTEL_PMC_IDX_FIXED)
+		return get_gp_pmc(pmu, MSR_P6_EVNTSEL0 + pmc_idx,
+				  MSR_P6_EVNTSEL0);
+	else {
+		u32 idx = pmc_idx - INTEL_PMC_IDX_FIXED;
+
+		return get_fixed_pmc(pmu, idx + MSR_CORE_PERF_FIXED_CTR0);
+	}
+}
+
+/* returns 0 if idx's corresponding MSR exists; otherwise returns 1. */
+static int intel_is_valid_msr_idx(struct kvm_vcpu *vcpu, unsigned idx)
+{
+	struct kvm_pmu *pmu = vcpu_to_pmu(vcpu);
+	bool fixed = idx & (1u << 30);
+
+	idx &= ~(3u << 30);
+
+	return (!fixed && idx >= pmu->nr_arch_gp_counters) ||
+		(fixed && idx >= pmu->nr_arch_fixed_counters);
+}
+
+static struct kvm_pmc *intel_msr_idx_to_pmc(struct kvm_vcpu *vcpu,
+					    unsigned idx)
+{
+	struct kvm_pmu *pmu = vcpu_to_pmu(vcpu);
+	bool fixed = idx & (1u << 30);
+	struct kvm_pmc *counters;
+
+	idx &= ~(3u << 30);
+	if (!fixed && idx >= pmu->nr_arch_gp_counters)
+		return NULL;
+	if (fixed && idx >= pmu->nr_arch_fixed_counters)
+		return NULL;
+	counters = fixed ? pmu->fixed_counters : pmu->gp_counters;
+
+	return &counters[idx];
+}
+
+static bool intel_is_valid_msr(struct kvm_vcpu *vcpu, u32 msr)
+{
+	struct kvm_pmu *pmu = vcpu_to_pmu(vcpu);
+	int ret;
+
+	switch (msr) {
+	case MSR_CORE_PERF_FIXED_CTR_CTRL:
+	case MSR_CORE_PERF_GLOBAL_STATUS:
+	case MSR_CORE_PERF_GLOBAL_CTRL:
+	case MSR_CORE_PERF_GLOBAL_OVF_CTRL:
+		ret = pmu->version > 1;
+		break;
+	default:
+		ret = get_gp_pmc(pmu, msr, MSR_IA32_PERFCTR0) ||
+			get_gp_pmc(pmu, msr, MSR_P6_EVNTSEL0) ||
+			get_fixed_pmc(pmu, msr);
+		break;
+	}
+
+	return ret;
+}
+
+static int intel_pmu_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *data)
+{
+	struct kvm_pmu *pmu = vcpu_to_pmu(vcpu);
+	struct kvm_pmc *pmc;
+
+	switch (msr) {
+	case MSR_CORE_PERF_FIXED_CTR_CTRL:
+		*data = pmu->fixed_ctr_ctrl;
+		return 0;
+	case MSR_CORE_PERF_GLOBAL_STATUS:
+		*data = pmu->global_status;
+		return 0;
+	case MSR_CORE_PERF_GLOBAL_CTRL:
+		*data = pmu->global_ctrl;
+		return 0;
+	case MSR_CORE_PERF_GLOBAL_OVF_CTRL:
+		*data = pmu->global_ovf_ctrl;
+		return 0;
+	default:
+		if ((pmc = get_gp_pmc(pmu, msr, MSR_IA32_PERFCTR0)) ||
+		    (pmc = get_fixed_pmc(pmu, msr))) {
+			*data = pmc_read_counter(pmc);
+			return 0;
+		} else if ((pmc = get_gp_pmc(pmu, msr, MSR_P6_EVNTSEL0))) {
+			*data = pmc->eventsel;
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
+static int intel_pmu_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
+{
+	struct kvm_pmu *pmu = vcpu_to_pmu(vcpu);
+	struct kvm_pmc *pmc;
+	u32 msr = msr_info->index;
+	u64 data = msr_info->data;
+
+	switch (msr) {
+	case MSR_CORE_PERF_FIXED_CTR_CTRL:
+		if (pmu->fixed_ctr_ctrl == data)
+			return 0;
+		if (!(data & 0xfffffffffffff444ull)) {
+			reprogram_fixed_counters(pmu, data);
+			return 0;
+		}
+		break;
+	case MSR_CORE_PERF_GLOBAL_STATUS:
+		if (msr_info->host_initiated) {
+			pmu->global_status = data;
+			return 0;
+		}
+		break; /* RO MSR */
+	case MSR_CORE_PERF_GLOBAL_CTRL:
+		if (pmu->global_ctrl == data)
+			return 0;
+		if (!(data & pmu->global_ctrl_mask)) {
+			global_ctrl_changed(pmu, data);
+			return 0;
+		}
+		break;
+	case MSR_CORE_PERF_GLOBAL_OVF_CTRL:
+		if (!(data & (pmu->global_ctrl_mask & ~(3ull<<62)))) {
+			if (!msr_info->host_initiated)
+				pmu->global_status &= ~data;
+			pmu->global_ovf_ctrl = data;
+			return 0;
+		}
+		break;
+	default:
+		if ((pmc = get_gp_pmc(pmu, msr, MSR_IA32_PERFCTR0)) ||
+		    (pmc = get_fixed_pmc(pmu, msr))) {
+			if (!msr_info->host_initiated)
+				data = (s64)(s32)data;
+			pmc->counter += data - pmc_read_counter(pmc);
+			return 0;
+		} else if ((pmc = get_gp_pmc(pmu, msr, MSR_P6_EVNTSEL0))) {
+			if (data == pmc->eventsel)
+				return 0;
+			if (!(data & pmu->reserved_bits)) {
+				reprogram_gp_counter(pmc, data);
+				return 0;
+			}
+		}
+	}
+
+	return 1;
+}
+
+static void intel_pmu_refresh(struct kvm_vcpu *vcpu)
+{
+	struct kvm_pmu *pmu = vcpu_to_pmu(vcpu);
+	struct kvm_cpuid_entry2 *entry;
+	union cpuid10_eax eax;
+	union cpuid10_edx edx;
+
+	pmu->nr_arch_gp_counters = 0;
+	pmu->nr_arch_fixed_counters = 0;
+	pmu->counter_bitmask[KVM_PMC_GP] = 0;
+	pmu->counter_bitmask[KVM_PMC_FIXED] = 0;
+	pmu->version = 0;
+	pmu->reserved_bits = 0xffffffff00200000ull;
+
+	entry = kvm_find_cpuid_entry(vcpu, 0xa, 0);
+	if (!entry)
+		return;
+	eax.full = entry->eax;
+	edx.full = entry->edx;
+
+	pmu->version = eax.split.version_id;
+	if (!pmu->version)
+		return;
+
+	pmu->nr_arch_gp_counters = min_t(int, eax.split.num_counters,
+					INTEL_PMC_MAX_GENERIC);
+	pmu->counter_bitmask[KVM_PMC_GP] = ((u64)1 << eax.split.bit_width) - 1;
+	pmu->available_event_types = ~entry->ebx &
+					((1ull << eax.split.mask_length) - 1);
+
+	if (pmu->version == 1) {
+		pmu->nr_arch_fixed_counters = 0;
+	} else {
+		pmu->nr_arch_fixed_counters =
+			min_t(int, edx.split.num_counters_fixed,
+				INTEL_PMC_MAX_FIXED);
+		pmu->counter_bitmask[KVM_PMC_FIXED] =
+			((u64)1 << edx.split.bit_width_fixed) - 1;
+	}
+
+	pmu->global_ctrl = ((1 << pmu->nr_arch_gp_counters) - 1) |
+		(((1ull << pmu->nr_arch_fixed_counters) - 1) << INTEL_PMC_IDX_FIXED);
+	pmu->global_ctrl_mask = ~pmu->global_ctrl;
+
+	entry = kvm_find_cpuid_entry(vcpu, 7, 0);
+	if (entry &&
+	    (boot_cpu_has(X86_FEATURE_HLE) || boot_cpu_has(X86_FEATURE_RTM)) &&
+	    (entry->ebx & (X86_FEATURE_HLE|X86_FEATURE_RTM)))
+		pmu->reserved_bits ^= HSW_IN_TX|HSW_IN_TX_CHECKPOINTED;
+}
+
+static void intel_pmu_init(struct kvm_vcpu *vcpu)
+{
+	int i;
+	struct kvm_pmu *pmu = vcpu_to_pmu(vcpu);
+
+	for (i = 0; i < INTEL_PMC_MAX_GENERIC; i++) {
+		pmu->gp_counters[i].type = KVM_PMC_GP;
+		pmu->gp_counters[i].vcpu = vcpu;
+		pmu->gp_counters[i].idx = i;
+	}
+
+	for (i = 0; i < INTEL_PMC_MAX_FIXED; i++) {
+		pmu->fixed_counters[i].type = KVM_PMC_FIXED;
+		pmu->fixed_counters[i].vcpu = vcpu;
+		pmu->fixed_counters[i].idx = i + INTEL_PMC_IDX_FIXED;
+	}
+}
+
+static void intel_pmu_reset(struct kvm_vcpu *vcpu)
+{
+	struct kvm_pmu *pmu = vcpu_to_pmu(vcpu);
+	int i;
+
+	for (i = 0; i < INTEL_PMC_MAX_GENERIC; i++) {
+		struct kvm_pmc *pmc = &pmu->gp_counters[i];
+
+		pmc_stop_counter(pmc);
+		pmc->counter = pmc->eventsel = 0;
+	}
+
+	for (i = 0; i < INTEL_PMC_MAX_FIXED; i++)
+		pmc_stop_counter(&pmu->fixed_counters[i]);
+
+	pmu->fixed_ctr_ctrl = pmu->global_ctrl = pmu->global_status =
+		pmu->global_ovf_ctrl = 0;
+}
+
+struct kvm_pmu_ops intel_pmu_ops = {
+	.find_arch_event = intel_find_arch_event,
+	.find_fixed_event = intel_find_fixed_event,
+	.pmc_is_enabled = intel_pmc_is_enabled,
+	.pmc_idx_to_pmc = intel_pmc_idx_to_pmc,
+	.msr_idx_to_pmc = intel_msr_idx_to_pmc,
+	.is_valid_msr_idx = intel_is_valid_msr_idx,
+	.is_valid_msr = intel_is_valid_msr,
+	.get_msr = intel_pmu_get_msr,
+	.set_msr = intel_pmu_set_msr,
+	.refresh = intel_pmu_refresh,
+	.init = intel_pmu_init,
+	.reset = intel_pmu_reset,
+};
diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c
index 04d377296af8..60bc6b8806dc 100644
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@ -21,6 +21,7 @@
 #include "kvm_cache_regs.h"
 #include "x86.h"
 #include "cpuid.h"
+#include "pmu.h"
 
 #include <linux/module.h>
 #include <linux/mod_devicetable.h>
@@ -4432,6 +4433,8 @@ static struct kvm_x86_ops svm_x86_ops = {
 	.handle_external_intr = svm_handle_external_intr,
 
 	.sched_in = svm_sched_in,
+
+	.pmu_ops = &amd_pmu_ops,
 };
 
 static int __init svm_init(void)
* Unmerged path arch/x86/kvm/vmx.c
