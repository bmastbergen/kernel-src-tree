net: Fix remcsum in GRO path to not change packet

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] gro: Fix remcsum in GRO path to not change packet (Marcelo Leitner) [1206570]
Rebuild_FUZZ: 93.88%
commit-author Tom Herbert <therbert@google.com>
commit 26c4f7da3e413da697a7beb22ad496390eda7da0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/26c4f7da.failed

Remote checksum offload processing is currently the same for both
the GRO and non-GRO path. When the remote checksum offload option
is encountered, the checksum field referred to is modified in
the packet. So in the GRO case, the packet is modified in the
GRO path and then the operation is skipped when the packet goes
through the normal path based on skb->remcsum_offload. There is
a problem in that the packet may be modified in the GRO path, but
then forwarded off host still containing the remote checksum option.
A remote host will again perform RCO but now the checksum verification
will fail since GRO RCO already modified the checksum.

To fix this, we ensure that GRO restores a packet to it's original
state before returning. In this model, when GRO processes a remote
checksum option it still changes the checksum per the algorithm
but on return from lower layer processing the checksum is restored
to its original value.

In this patch we add define gro_remcsum structure which is passed
to skb_gro_remcsum_process to save offset and delta for the checksum
being changed. After lower layer processing, skb_gro_remcsum_cleanup
is called to restore the checksum before returning from GRO.

	Signed-off-by: Tom Herbert <therbert@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 26c4f7da3e413da697a7beb22ad496390eda7da0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
#	include/linux/netdevice.h
#	net/ipv4/fou.c
diff --cc drivers/net/vxlan.c
index f6bd9cff732e,30310a63475a..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -549,12 -552,55 +549,62 @@@ static int vxlan_fdb_append(struct vxla
  	return 1;
  }
  
++<<<<<<< HEAD
 +static struct sk_buff **vxlan_gro_receive(struct sk_buff **head, struct sk_buff *skb)
++=======
+ static struct vxlanhdr *vxlan_gro_remcsum(struct sk_buff *skb,
+ 					  unsigned int off,
+ 					  struct vxlanhdr *vh, size_t hdrlen,
+ 					  u32 data, struct gro_remcsum *grc)
+ {
+ 	size_t start, offset, plen;
+ 
+ 	if (skb->remcsum_offload)
+ 		return NULL;
+ 
+ 	if (!NAPI_GRO_CB(skb)->csum_valid)
+ 		return NULL;
+ 
+ 	start = (data & VXLAN_RCO_MASK) << VXLAN_RCO_SHIFT;
+ 	offset = start + ((data & VXLAN_RCO_UDP) ?
+ 			  offsetof(struct udphdr, check) :
+ 			  offsetof(struct tcphdr, check));
+ 
+ 	plen = hdrlen + offset + sizeof(u16);
+ 
+ 	/* Pull checksum that will be written */
+ 	if (skb_gro_header_hard(skb, off + plen)) {
+ 		vh = skb_gro_header_slow(skb, off + plen, off);
+ 		if (!vh)
+ 			return NULL;
+ 	}
+ 
+ 	skb_gro_remcsum_process(skb, (void *)vh + hdrlen,
+ 				start, offset, grc);
+ 
+ 	skb->remcsum_offload = 1;
+ 
+ 	return vh;
+ }
+ 
+ static struct sk_buff **vxlan_gro_receive(struct sk_buff **head,
+ 					  struct sk_buff *skb,
+ 					  struct udp_offload *uoff)
++>>>>>>> 26c4f7da3e41 (net: Fix remcsum in GRO path to not change packet)
  {
  	struct sk_buff *p, **pp = NULL;
  	struct vxlanhdr *vh, *vh2;
  	unsigned int hlen, off_vx;
  	int flush = 1;
++<<<<<<< HEAD
++=======
+ 	struct vxlan_sock *vs = container_of(uoff, struct vxlan_sock,
+ 					     udp_offloads);
+ 	u32 flags;
+ 	struct gro_remcsum grc;
+ 
+ 	skb_gro_remcsum_init(&grc);
++>>>>>>> 26c4f7da3e41 (net: Fix remcsum in GRO path to not change packet)
  
  	off_vx = skb_gro_offset(skb);
  	hlen = off_vx + sizeof(*vh);
@@@ -565,6 -611,19 +615,22 @@@
  			goto out;
  	}
  
++<<<<<<< HEAD
++=======
+ 	skb_gro_pull(skb, sizeof(struct vxlanhdr)); /* pull vxlan header */
+ 	skb_gro_postpull_rcsum(skb, vh, sizeof(struct vxlanhdr));
+ 
+ 	flags = ntohl(vh->vx_flags);
+ 
+ 	if ((flags & VXLAN_HF_RCO) && (vs->flags & VXLAN_F_REMCSUM_RX)) {
+ 		vh = vxlan_gro_remcsum(skb, off_vx, vh, sizeof(struct vxlanhdr),
+ 				       ntohl(vh->vx_vni), &grc);
+ 
+ 		if (!vh)
+ 			goto out;
+ 	}
+ 
++>>>>>>> 26c4f7da3e41 (net: Fix remcsum in GRO path to not change packet)
  	flush = 0;
  
  	for (p = *head; p; p = p->next) {
@@@ -1094,6 -1154,28 +1161,31 @@@ static void vxlan_igmp_leave(struct wor
  	dev_put(vxlan->dev);
  }
  
++<<<<<<< HEAD
++=======
+ static struct vxlanhdr *vxlan_remcsum(struct sk_buff *skb, struct vxlanhdr *vh,
+ 				      size_t hdrlen, u32 data)
+ {
+ 	size_t start, offset, plen;
+ 
+ 	start = (data & VXLAN_RCO_MASK) << VXLAN_RCO_SHIFT;
+ 	offset = start + ((data & VXLAN_RCO_UDP) ?
+ 			  offsetof(struct udphdr, check) :
+ 			  offsetof(struct tcphdr, check));
+ 
+ 	plen = hdrlen + offset + sizeof(u16);
+ 
+ 	if (!pskb_may_pull(skb, plen))
+ 		return NULL;
+ 
+ 	vh = (struct vxlanhdr *)(udp_hdr(skb) + 1);
+ 
+ 	skb_remcsum_process(skb, (void *)vh + hdrlen, start, offset);
+ 
+ 	return vh;
+ }
+ 
++>>>>>>> 26c4f7da3e41 (net: Fix remcsum in GRO path to not change packet)
  /* Callback from net/ipv4/udp.c to receive packets */
  static int vxlan_udp_encap_recv(struct sock *sk, struct sk_buff *skb)
  {
diff --cc include/linux/netdevice.h
index 93c2d6dc113c,3aa02457fe4f..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -2001,6 -2321,42 +2001,45 @@@ do {									
  					   compute_pseudo(skb, proto));	\
  } while (0)
  
++<<<<<<< HEAD
++=======
+ struct gro_remcsum {
+ 	int offset;
+ 	__wsum delta;
+ };
+ 
+ static inline void skb_gro_remcsum_init(struct gro_remcsum *grc)
+ {
+ 	grc->delta = 0;
+ }
+ 
+ static inline void skb_gro_remcsum_process(struct sk_buff *skb, void *ptr,
+ 					   int start, int offset,
+ 					   struct gro_remcsum *grc)
+ {
+ 	__wsum delta;
+ 
+ 	BUG_ON(!NAPI_GRO_CB(skb)->csum_valid);
+ 
+ 	delta = remcsum_adjust(ptr, NAPI_GRO_CB(skb)->csum, start, offset);
+ 
+ 	/* Adjust skb->csum since we changed the packet */
+ 	NAPI_GRO_CB(skb)->csum = csum_add(NAPI_GRO_CB(skb)->csum, delta);
+ 
+ 	grc->offset = (ptr + offset) - (void *)skb->head;
+ 	grc->delta = delta;
+ }
+ 
+ static inline void skb_gro_remcsum_cleanup(struct sk_buff *skb,
+ 					   struct gro_remcsum *grc)
+ {
+ 	if (!grc->delta)
+ 		return;
+ 
+ 	remcsum_unadjust((__sum16 *)(skb->head + grc->offset), grc->delta);
+ }
+ 
++>>>>>>> 26c4f7da3e41 (net: Fix remcsum in GRO path to not change packet)
  static inline int dev_hard_header(struct sk_buff *skb, struct net_device *dev,
  				  unsigned short type,
  				  const void *daddr, const void *saddr,
diff --cc net/ipv4/fou.c
index a87e3c956cb2,7fa8d36e56d4..000000000000
--- a/net/ipv4/fou.c
+++ b/net/ipv4/fou.c
@@@ -62,8 -58,33 +62,38 @@@ static int fou_udp_recv(struct sock *sk
  	if (!fou)
  		return 1;
  
++<<<<<<< HEAD
 +	return fou_udp_encap_recv_deliver(skb, fou->protocol,
 +					  sizeof(struct udphdr));
++=======
+ 	fou_recv_pull(skb, sizeof(struct udphdr));
+ 
+ 	return -fou->protocol;
+ }
+ 
+ static struct guehdr *gue_remcsum(struct sk_buff *skb, struct guehdr *guehdr,
+ 				  void *data, size_t hdrlen, u8 ipproto)
+ {
+ 	__be16 *pd = data;
+ 	size_t start = ntohs(pd[0]);
+ 	size_t offset = ntohs(pd[1]);
+ 	size_t plen = hdrlen + max_t(size_t, offset + sizeof(u16), start);
+ 
+ 	if (!pskb_may_pull(skb, plen))
+ 		return NULL;
+ 	guehdr = (struct guehdr *)&udp_hdr(skb)[1];
+ 
+ 	skb_remcsum_process(skb, (void *)guehdr + hdrlen, start, offset);
+ 
+ 	return guehdr;
+ }
+ 
+ static int gue_control_message(struct sk_buff *skb, struct guehdr *guehdr)
+ {
+ 	/* No support yet */
+ 	kfree_skb(skb);
+ 	return 0;
++>>>>>>> 26c4f7da3e41 (net: Fix remcsum in GRO path to not change packet)
  }
  
  static int gue_udp_recv(struct sock *sk, struct sk_buff *skb)
@@@ -149,45 -206,106 +179,118 @@@ out_unlock
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static struct guehdr *gue_gro_remcsum(struct sk_buff *skb, unsigned int off,
+ 				      struct guehdr *guehdr, void *data,
+ 				      size_t hdrlen, u8 ipproto,
+ 				      struct gro_remcsum *grc)
+ {
+ 	__be16 *pd = data;
+ 	size_t start = ntohs(pd[0]);
+ 	size_t offset = ntohs(pd[1]);
+ 	size_t plen = hdrlen + max_t(size_t, offset + sizeof(u16), start);
+ 
+ 	if (skb->remcsum_offload)
+ 		return NULL;
+ 
+ 	if (!NAPI_GRO_CB(skb)->csum_valid)
+ 		return NULL;
+ 
+ 	/* Pull checksum that will be written */
+ 	if (skb_gro_header_hard(skb, off + plen)) {
+ 		guehdr = skb_gro_header_slow(skb, off + plen, off);
+ 		if (!guehdr)
+ 			return NULL;
+ 	}
+ 
+ 	skb_gro_remcsum_process(skb, (void *)guehdr + hdrlen,
+ 				start, offset, grc);
+ 
+ 	skb->remcsum_offload = 1;
+ 
+ 	return guehdr;
+ }
+ 
++>>>>>>> 26c4f7da3e41 (net: Fix remcsum in GRO path to not change packet)
  static struct sk_buff **gue_gro_receive(struct sk_buff **head,
 -					struct sk_buff *skb,
 -					struct udp_offload *uoff)
 +					struct sk_buff *skb)
  {
  	const struct net_offload **offloads;
  	const struct net_offload *ops;
  	struct sk_buff **pp = NULL;
  	struct sk_buff *p;
 +	u8 proto;
  	struct guehdr *guehdr;
 -	size_t len, optlen, hdrlen, off;
 -	void *data;
 -	u16 doffset = 0;
 +	unsigned int hlen, guehlen;
 +	unsigned int off;
  	int flush = 1;
+ 	struct gro_remcsum grc;
+ 
+ 	skb_gro_remcsum_init(&grc);
  
  	off = skb_gro_offset(skb);
 -	len = off + sizeof(*guehdr);
 -
 +	hlen = off + sizeof(*guehdr);
  	guehdr = skb_gro_header_fast(skb, off);
 -	if (skb_gro_header_hard(skb, len)) {
 -		guehdr = skb_gro_header_slow(skb, len, off);
 +	if (skb_gro_header_hard(skb, hlen)) {
 +		guehdr = skb_gro_header_slow(skb, hlen, off);
  		if (unlikely(!guehdr))
  			goto out;
  	}
  
 -	optlen = guehdr->hlen << 2;
 -	len += optlen;
 +	proto = guehdr->next_hdr;
  
 -	if (skb_gro_header_hard(skb, len)) {
 -		guehdr = skb_gro_header_slow(skb, len, off);
 +	rcu_read_lock();
 +	offloads = NAPI_GRO_CB(skb)->is_ipv6 ? inet6_offloads : inet_offloads;
 +	ops = rcu_dereference(offloads[proto]);
 +	if (WARN_ON(!ops || !ops->callbacks.gro_receive))
 +		goto out_unlock;
 +
 +	guehlen = sizeof(*guehdr) + (guehdr->hlen << 2);
 +
 +	hlen = off + guehlen;
 +	if (skb_gro_header_hard(skb, hlen)) {
 +		guehdr = skb_gro_header_slow(skb, hlen, off);
  		if (unlikely(!guehdr))
 -			goto out;
 +			goto out_unlock;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (unlikely(guehdr->control) || guehdr->version != 0 ||
+ 	    validate_gue_flags(guehdr, optlen))
+ 		goto out;
+ 
+ 	hdrlen = sizeof(*guehdr) + optlen;
+ 
+ 	/* Adjust NAPI_GRO_CB(skb)->csum to account for guehdr,
+ 	 * this is needed if there is a remote checkcsum offload.
+ 	 */
+ 	skb_gro_postpull_rcsum(skb, guehdr, hdrlen);
+ 
+ 	data = &guehdr[1];
+ 
+ 	if (guehdr->flags & GUE_FLAG_PRIV) {
+ 		__be32 flags = *(__be32 *)(data + doffset);
+ 
+ 		doffset += GUE_LEN_PRIV;
+ 
+ 		if (flags & GUE_PFLAG_REMCSUM) {
+ 			guehdr = gue_gro_remcsum(skb, off, guehdr,
+ 						 data + doffset, hdrlen,
+ 						 guehdr->proto_ctype, &grc);
+ 			if (!guehdr)
+ 				goto out;
+ 
+ 			data = &guehdr[1];
+ 
+ 			doffset += GUE_PLEN_REMCSUM;
+ 		}
+ 	}
+ 
+ 	skb_gro_pull(skb, hdrlen);
+ 
++>>>>>>> 26c4f7da3e41 (net: Fix remcsum in GRO path to not change packet)
  	flush = 0;
  
  	for (p = *head; p; p = p->next) {
* Unmerged path drivers/net/vxlan.c
* Unmerged path include/linux/netdevice.h
diff --git a/include/net/checksum.h b/include/net/checksum.h
index 04fd0cf690cf..ea135d881dfe 100644
--- a/include/net/checksum.h
+++ b/include/net/checksum.h
@@ -150,4 +150,9 @@ static inline __wsum remcsum_adjust(void *ptr, __wsum csum,
 	return delta;
 }
 
+static inline void remcsum_unadjust(__sum16 *psum, __wsum delta)
+{
+	*psum = csum_fold(csum_sub(delta, *psum));
+}
+
 #endif
* Unmerged path net/ipv4/fou.c
