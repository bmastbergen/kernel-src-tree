NVMe: Failed controller initialization fixes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Keith Busch <keith.busch@intel.com>
commit de3eff2bad56f0a29d3915105223d368f2bbc94e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/de3eff2b.failed

This fixes an infinite device reset loop that may occur on devices that
fail initialization. If the drive fails to become ready for any reason
that does not involve an admin command timeout, the probe task should
assume the drive is unavailable and remove it from the topology. In
the case an admin command times out during device probing, the driver's
existing reset action will handle removing the drive.

	Signed-off-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit de3eff2bad56f0a29d3915105223d368f2bbc94e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/nvme-core.c
diff --cc drivers/block/nvme-core.c
index 29d2b5fb1975,22761a6c34aa..000000000000
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@@ -2931,19 -2931,37 +2931,44 @@@ static int nvme_dev_resume(struct nvme_
  	return 0;
  }
  
+ static void nvme_dead_ctrl(struct nvme_dev *dev)
+ {
+ 	dev_warn(dev->dev, "Device failed to resume\n");
+ 	kref_get(&dev->kref);
+ 	if (IS_ERR(kthread_run(nvme_remove_dead_ctrl, dev, "nvme%d",
+ 						dev->instance))) {
+ 		dev_err(dev->dev,
+ 			"Failed to start controller remove task\n");
+ 		kref_put(&dev->kref, nvme_free_dev);
+ 	}
+ }
+ 
  static void nvme_dev_reset(struct nvme_dev *dev)
  {
 -	bool in_probe = work_busy(&dev->probe_work);
 -
  	nvme_dev_shutdown(dev);
++<<<<<<< HEAD
 +	if (nvme_dev_resume(dev)) {
 +		dev_err(&dev->pci_dev->dev, "Device failed to resume\n");
 +		kref_get(&dev->kref);
 +		if (IS_ERR(kthread_run(nvme_remove_dead_ctrl, dev, "nvme%d",
 +							dev->instance))) {
 +			dev_err(&dev->pci_dev->dev,
 +				"Failed to start controller remove task\n");
 +			kref_put(&dev->kref, nvme_free_dev);
 +		}
++=======
+ 
+ 	/* Synchronize with device probe so that work will see failure status
+ 	 * and exit gracefully without trying to schedule another reset */
+ 	flush_work(&dev->probe_work);
+ 
+ 	/* Fail this device if reset occured during probe to avoid
+ 	 * infinite initialization loops. */
+ 	if (in_probe) {
+ 		nvme_dead_ctrl(dev);
+ 		return;
++>>>>>>> de3eff2bad56 (NVMe: Failed controller initialization fixes)
  	}
 -	/* Schedule device resume asynchronously so the reset work is available
 -	 * to cleanup errors that may occur during reinitialization */
 -	schedule_work(&dev->probe_work);
  }
  
  static void nvme_reset_failed_dev(struct work_struct *ws)
@@@ -3027,6 -3087,14 +3052,17 @@@ static int nvme_probe(struct pci_dev *p
  	return result;
  }
  
++<<<<<<< HEAD
++=======
+ static void nvme_async_probe(struct work_struct *work)
+ {
+ 	struct nvme_dev *dev = container_of(work, struct nvme_dev, probe_work);
+ 
+ 	if (nvme_dev_resume(dev) && !work_busy(&dev->reset_work))
+ 		nvme_dead_ctrl(dev);
+ }
+ 
++>>>>>>> de3eff2bad56 (NVMe: Failed controller initialization fixes)
  static void nvme_reset_notify(struct pci_dev *pdev, bool prepare)
  {
  	struct nvme_dev *dev = pci_get_drvdata(pdev);
* Unmerged path drivers/block/nvme-core.c
