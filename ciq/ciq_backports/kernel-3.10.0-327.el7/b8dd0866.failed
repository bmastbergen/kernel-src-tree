ALSA: Jack: handle jack embedded kcontrol creating within ctljack

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [alsa] jack: handle jack embedded kcontrol creating within ctljack (Jaroslav Kysela) [1197064]
Rebuild_FUZZ: 95.16%
commit-author Jie Yang <yang.jie@intel.com>
commit b8dd086674cfbfc246a5b9d7d7ff37f62350a878
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/b8dd0866.failed

This patch adds a static method get_available_index() to
allocate the index of new jack kcontrols and also adds
jack_kctl_name_gen() which is used to ensure compatibility
with jack naming by removing " Jack" from some incorrectly
passed names.

	Signed-off-by: Jie Yang <yang.jie@intel.com>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit b8dd086674cfbfc246a5b9d7d7ff37f62350a878)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/core/jack.c
diff --cc sound/core/jack.c
index 8658578eb584,067d37d14e64..000000000000
--- a/sound/core/jack.c
+++ b/sound/core/jack.c
@@@ -100,6 -113,77 +100,80 @@@ static int snd_jack_dev_register(struc
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static void snd_jack_kctl_private_free(struct snd_kcontrol *kctl)
+ {
+ 	struct snd_jack_kctl *jack_kctl;
+ 
+ 	jack_kctl = kctl->private_data;
+ 	if (jack_kctl) {
+ 		list_del(&jack_kctl->list);
+ 		kfree(jack_kctl);
+ 	}
+ }
+ 
+ static void snd_jack_kctl_add(struct snd_jack *jack, struct snd_jack_kctl *jack_kctl)
+ {
+ 	list_add_tail(&jack_kctl->list, &jack->kctl_list);
+ }
+ 
+ static struct snd_jack_kctl * snd_jack_kctl_new(struct snd_card *card, const char *name, unsigned int mask)
+ {
+ 	struct snd_kcontrol *kctl;
+ 	struct snd_jack_kctl *jack_kctl;
+ 	int err;
+ 
+ 	kctl = snd_kctl_jack_new(name, card, card);
+ 	if (!kctl)
+ 		return NULL;
+ 
+ 	err = snd_ctl_add(card, kctl);
+ 	if (err < 0)
+ 		return NULL;
+ 
+ 	jack_kctl = kzalloc(sizeof(*jack_kctl), GFP_KERNEL);
+ 
+ 	if (!jack_kctl)
+ 		goto error;
+ 
+ 	jack_kctl->kctl = kctl;
+ 	jack_kctl->mask_bits = mask;
+ 
+ 	kctl->private_data = jack_kctl;
+ 	kctl->private_free = snd_jack_kctl_private_free;
+ 
+ 	return jack_kctl;
+ error:
+ 	snd_ctl_free_one(kctl);
+ 	return NULL;
+ }
+ 
+ /**
+  * snd_jack_add_new_kctl - Create a new snd_jack_kctl and add it to jack
+  * @jack:  the jack instance which the kctl will attaching to
+  * @name:  the name for the snd_kcontrol object
+  * @mask:  a bitmask of enum snd_jack_type values that can be detected
+  *         by this snd_jack_kctl object.
+  *
+  * Creates a new snd_kcontrol object and adds it to the jack kctl_list.
+  *
+  * Return: Zero if successful, or a negative error code on failure.
+  */
+ int snd_jack_add_new_kctl(struct snd_jack *jack, const char * name, int mask)
+ {
+ 	struct snd_jack_kctl *jack_kctl;
+ 
+ 	jack_kctl = snd_jack_kctl_new(jack->card, name, mask);
+ 	if (!jack_kctl)
+ 		return -ENOMEM;
+ 
+ 	snd_jack_kctl_add(jack, jack_kctl);
+ 	return 0;
+ }
+ EXPORT_SYMBOL(snd_jack_add_new_kctl);
+ 
++>>>>>>> b8dd086674cf (ALSA: Jack: handle jack embedded kcontrol creating within ctljack)
  /**
   * snd_jack_new - Create a new jack
   * @card:  the card instance
diff --git a/include/sound/control.h b/include/sound/control.h
index 75f3054023f7..6c798fcfc37e 100644
--- a/include/sound/control.h
+++ b/include/sound/control.h
@@ -252,7 +252,7 @@ void snd_ctl_sync_vmaster(struct snd_kcontrol *kctl, bool hook_only);
  * Helper functions for jack-detection controls
  */
 struct snd_kcontrol *
-snd_kctl_jack_new(const char *name, int idx, void *private_data);
+snd_kctl_jack_new(const char *name, void *private_data, struct snd_card *card);
 void snd_kctl_jack_report(struct snd_card *card,
 			  struct snd_kcontrol *kctl, bool status);
 
diff --git a/sound/core/ctljack.c b/sound/core/ctljack.c
index e4b38fbe51da..df7c6cd63c4a 100644
--- a/sound/core/ctljack.c
+++ b/sound/core/ctljack.c
@@ -31,15 +31,46 @@ static struct snd_kcontrol_new jack_detect_kctl = {
 	.get = jack_detect_kctl_get,
 };
 
+static int get_available_index(struct snd_card *card, const char *name)
+{
+	struct snd_ctl_elem_id sid;
+
+	memset(&sid, 0, sizeof(sid));
+
+	sid.index = 0;
+	sid.iface = SNDRV_CTL_ELEM_IFACE_CARD;
+	strlcpy(sid.name, name, sizeof(sid.name));
+
+	while (snd_ctl_find_id(card, &sid))
+		sid.index++;
+
+	return sid.index;
+}
+
+static void jack_kctl_name_gen(char *name, const char *src_name, int size)
+{
+	size_t count = strlen(src_name);
+	bool need_cat = true;
+
+	/* remove redundant " Jack" from src_name */
+	if (count >= 5)
+		need_cat = strncmp(&src_name[count - 5], " Jack", 5) ? true : false;
+
+	snprintf(name, size, need_cat ? "%s Jack" : "%s", src_name);
+
+}
+
 struct snd_kcontrol *
-snd_kctl_jack_new(const char *name, int idx, void *private_data)
+snd_kctl_jack_new(const char *name, void *private_data, struct snd_card *card)
 {
 	struct snd_kcontrol *kctl;
+
 	kctl = snd_ctl_new1(&jack_detect_kctl, private_data);
 	if (!kctl)
 		return NULL;
-	snprintf(kctl->id.name, sizeof(kctl->id.name), "%s Jack", name);
-	kctl->id.index = idx;
+
+	jack_kctl_name_gen(kctl->id.name, name, sizeof(kctl->id.name));
+	kctl->id.index = get_available_index(card, name);
 	kctl->private_value = 0;
 	return kctl;
 }
* Unmerged path sound/core/jack.c
diff --git a/sound/pci/hda/hda_jack.c b/sound/pci/hda/hda_jack.c
index d7cfe7b8c32b..05b49aa8af6c 100644
--- a/sound/pci/hda/hda_jack.c
+++ b/sound/pci/hda/hda_jack.c
@@ -402,7 +402,7 @@ static int __snd_hda_jack_add_kctl(struct hda_codec *codec, hda_nid_t nid,
 		return 0;
 	if (jack->kctl)
 		return 0; /* already created */
-	kctl = snd_kctl_jack_new(name, idx, codec);
+	kctl = snd_kctl_jack_new(name, codec, codec->card);
 	if (!kctl)
 		return -ENOMEM;
 	err = snd_hda_ctl_add(codec, nid, kctl);
