random: add and use memzero_explicit() for clearing data

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Daniel Borkmann <dborkman@redhat.com>
commit d4c5efdb97773f59a2b711754ca0953f24516739
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/d4c5efdb.failed

zatimend has reported that in his environment (3.16/gcc4.8.3/corei7)
memset() calls which clear out sensitive data in extract_{buf,entropy,
entropy_user}() in random driver are being optimized away by gcc.

Add a helper memzero_explicit() (similarly as explicit_bzero() variants)
that can be used in such cases where a variable with sensitive data is
being cleared out in the end. Other use cases might also be in crypto
code. [ I have put this into lib/string.c though, as it's always built-in
and doesn't need any dependencies then. ]

Fixes kernel bugzilla: 82041

	Reported-by: zatimend@hotmail.co.uk
	Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
	Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Cc: Alexey Dobriyan <adobriyan@gmail.com>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Cc: stable@vger.kernel.org
(cherry picked from commit d4c5efdb97773f59a2b711754ca0953f24516739)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/random.c
diff --cc drivers/char/random.c
index b1f490f5c30b,8c86a95203a0..000000000000
--- a/drivers/char/random.c
+++ b/drivers/char/random.c
@@@ -1001,16 -1103,10 +1001,20 @@@ static void extract_buf(struct entropy_
  	 * brute-forcing the feedback as hard as brute-forcing the
  	 * hash.
  	 */
 -	__mix_pool_bytes(r, hash.w, sizeof(hash.w));
 +	__mix_pool_bytes(r, hash.w, sizeof(hash.w), extract);
  	spin_unlock_irqrestore(&r->lock, flags);
  
++<<<<<<< HEAD
 +	/*
 +	 * To avoid duplicates, we atomically extract a portion of the
 +	 * pool while mixing, and hash one final time.
 +	 */
 +	sha_transform(hash.w, extract, workspace);
 +	memset(extract, 0, sizeof(extract));
 +	memset(workspace, 0, sizeof(workspace));
++=======
+ 	memzero_explicit(workspace, sizeof(workspace));
++>>>>>>> d4c5efdb9777 (random: add and use memzero_explicit() for clearing data)
  
  	/*
  	 * In case the hash function has some recognizable output
@@@ -1021,21 -1117,19 +1025,21 @@@
  	hash.w[1] ^= hash.w[4];
  	hash.w[2] ^= rol32(hash.w[2], 16);
  
 +	/*
 +	 * If we have a architectural hardware random number
 +	 * generator, mix that in, too.
 +	 */
 +	for (i = 0; i < LONGS(EXTRACT_SIZE); i++) {
 +		unsigned long v;
 +		if (!arch_get_random_long(&v))
 +			break;
 +		hash.l[i] ^= v;
 +	}
 +
  	memcpy(out, &hash, EXTRACT_SIZE);
- 	memset(&hash, 0, sizeof(hash));
+ 	memzero_explicit(&hash, sizeof(hash));
  }
  
 -/*
 - * This function extracts randomness from the "entropy pool", and
 - * returns it in a buffer.
 - *
 - * The min parameter specifies the minimum amount we can pull before
 - * failing to avoid races that defeat catastrophic reseeding while the
 - * reserved parameter indicates how much entropy we must leave in the
 - * pool after each pull to avoid starving other readers.
 - */
  static ssize_t extract_entropy(struct entropy_store *r, void *buf,
  				 size_t nbytes, int min, int reserved)
  {
* Unmerged path drivers/char/random.c
diff --git a/include/linux/string.h b/include/linux/string.h
index ac889c5ea11b..0ed878d0465c 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -129,7 +129,7 @@ int bprintf(u32 *bin_buf, size_t size, const char *fmt, ...) __printf(3, 4);
 #endif
 
 extern ssize_t memory_read_from_buffer(void *to, size_t count, loff_t *ppos,
-			const void *from, size_t available);
+				       const void *from, size_t available);
 
 /**
  * strstarts - does @str start with @prefix?
@@ -141,7 +141,8 @@ static inline bool strstarts(const char *str, const char *prefix)
 	return strncmp(str, prefix, strlen(prefix)) == 0;
 }
 
-extern size_t memweight(const void *ptr, size_t bytes);
+size_t memweight(const void *ptr, size_t bytes);
+void memzero_explicit(void *s, size_t count);
 
 /**
  * kbasename - return the last part of a pathname.
diff --git a/lib/string.c b/lib/string.c
index e5878de4f101..43d0781daf47 100644
--- a/lib/string.c
+++ b/lib/string.c
@@ -586,6 +586,22 @@ void *memset(void *s, int c, size_t count)
 EXPORT_SYMBOL(memset);
 #endif
 
+/**
+ * memzero_explicit - Fill a region of memory (e.g. sensitive
+ *		      keying data) with 0s.
+ * @s: Pointer to the start of the area.
+ * @count: The size of the area.
+ *
+ * memzero_explicit() doesn't need an arch-specific version as
+ * it just invokes the one of memset() implicitly.
+ */
+void memzero_explicit(void *s, size_t count)
+{
+	memset(s, 0, count);
+	OPTIMIZER_HIDE_VAR(s);
+}
+EXPORT_SYMBOL(memzero_explicit);
+
 #ifndef __HAVE_ARCH_MEMCPY
 /**
  * memcpy - Copy one area of memory to another
