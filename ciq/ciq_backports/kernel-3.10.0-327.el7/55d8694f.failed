net: tcp: assign tcp cong_ops when tcp sk is created

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] tcp: assign tcp cong_ops when tcp sk is created (Florian Westphal) [970613]
Rebuild_FUZZ: 94.95%
commit-author Florian Westphal <fw@strlen.de>
commit 55d8694fa82c9b5858ae5a78a210353961f908f9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/55d8694f.failed

Split assignment and initialization from one into two functions.

This is required by followup patches that add Datacenter TCP
(DCTCP) congestion control algorithm - we need to be able to
determine if the connection is moderated by DCTCP before the
3WHS has finished.

As we walk the available congestion control list during the
assignment, we are always guaranteed to have Reno present as
it's fixed compiled-in. Therefore, since we're doing the
early assignment, we don't have a real use for the Reno alias
tcp_init_congestion_ops anymore and can thus remove it.

Actual usage of the congestion control operations are being
made after the 3WHS has finished, in some cases however we
can access get_info() via diag if implemented, therefore we
need to zero out the private area for those modules.

Joint work with Daniel Borkmann and Glenn Judd.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
	Signed-off-by: Glenn Judd <glenn.judd@morganstanley.com>
	Acked-by: Stephen Hemminger <stephen@networkplumber.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 55d8694fa82c9b5858ae5a78a210353961f908f9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/tcp.h
#	net/ipv4/tcp_cong.c
diff --cc include/net/tcp.h
index 81f472949625,f99b0c072ee5..000000000000
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@@ -817,24 -821,23 +817,41 @@@ struct tcp_congestion_ops 
  	struct module 	*owner;
  };
  
 -int tcp_register_congestion_control(struct tcp_congestion_ops *type);
 -void tcp_unregister_congestion_control(struct tcp_congestion_ops *type);
 -
 +extern int tcp_register_congestion_control(struct tcp_congestion_ops *type);
 +extern void tcp_unregister_congestion_control(struct tcp_congestion_ops *type);
 +
++<<<<<<< HEAD
 +extern void tcp_init_congestion_control(struct sock *sk);
 +extern void tcp_cleanup_congestion_control(struct sock *sk);
 +extern int tcp_set_default_congestion_control(const char *name);
 +extern void tcp_get_default_congestion_control(char *name);
 +extern void tcp_get_available_congestion_control(char *buf, size_t len);
 +extern void tcp_get_allowed_congestion_control(char *buf, size_t len);
 +extern int tcp_set_allowed_congestion_control(char *allowed);
 +extern int tcp_set_congestion_control(struct sock *sk, const char *name);
 +extern void tcp_slow_start(struct tcp_sock *tp);
 +extern void tcp_cong_avoid_ai(struct tcp_sock *tp, u32 w);
 +
 +extern struct tcp_congestion_ops tcp_init_congestion_ops;
 +extern u32 tcp_reno_ssthresh(struct sock *sk);
 +extern void tcp_reno_cong_avoid(struct sock *sk, u32 ack, u32 in_flight);
 +extern u32 tcp_reno_min_cwnd(const struct sock *sk);
++=======
+ void tcp_assign_congestion_control(struct sock *sk);
+ void tcp_init_congestion_control(struct sock *sk);
+ void tcp_cleanup_congestion_control(struct sock *sk);
+ int tcp_set_default_congestion_control(const char *name);
+ void tcp_get_default_congestion_control(char *name);
+ void tcp_get_available_congestion_control(char *buf, size_t len);
+ void tcp_get_allowed_congestion_control(char *buf, size_t len);
+ int tcp_set_allowed_congestion_control(char *allowed);
+ int tcp_set_congestion_control(struct sock *sk, const char *name);
+ int tcp_slow_start(struct tcp_sock *tp, u32 acked);
+ void tcp_cong_avoid_ai(struct tcp_sock *tp, u32 w);
+ 
+ u32 tcp_reno_ssthresh(struct sock *sk);
+ void tcp_reno_cong_avoid(struct sock *sk, u32 ack, u32 acked);
++>>>>>>> 55d8694fa82c (net: tcp: assign tcp cong_ops when tcp sk is created)
  extern struct tcp_congestion_ops tcp_reno;
  
  static inline void tcp_set_ca_state(struct sock *sk, const u8 ca_state)
diff --cc net/ipv4/tcp_cong.c
index 31e31ad03cad,a6c8a5775624..000000000000
--- a/net/ipv4/tcp_cong.c
+++ b/net/ipv4/tcp_cong.c
@@@ -388,18 -354,4 +398,21 @@@ struct tcp_congestion_ops tcp_reno = 
  	.owner		= THIS_MODULE,
  	.ssthresh	= tcp_reno_ssthresh,
  	.cong_avoid	= tcp_reno_cong_avoid,
 +	.min_cwnd	= tcp_reno_min_cwnd,
 +};
++<<<<<<< HEAD
 +
 +/* Initial congestion control used (until SYN)
 + * really reno under another name so we can tell difference
 + * during tcp_set_default_congestion_control
 + */
 +struct tcp_congestion_ops tcp_init_congestion_ops  = {
 +	.name		= "",
 +	.owner		= THIS_MODULE,
 +	.ssthresh	= tcp_reno_ssthresh,
 +	.cong_avoid	= tcp_reno_cong_avoid,
 +	.min_cwnd	= tcp_reno_min_cwnd,
  };
 +EXPORT_SYMBOL_GPL(tcp_init_congestion_ops);
++=======
++>>>>>>> 55d8694fa82c (net: tcp: assign tcp cong_ops when tcp sk is created)
* Unmerged path include/net/tcp.h
diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c
index 82001502275d..90c9ef24c5bd 100644
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@ -402,7 +402,7 @@ void tcp_init_sock(struct sock *sk)
 
 	tp->reordering = sysctl_tcp_reordering;
 	tcp_enable_early_retrans(tp);
-	icsk->icsk_ca_ops = &tcp_init_congestion_ops;
+	tcp_assign_congestion_control(sk);
 
 	tp->tsoffset = 0;
 
@@ -3097,8 +3097,6 @@ void __init tcp_init(void)
 		tcp_hashinfo.ehash_mask + 1, tcp_hashinfo.bhash_size);
 
 	tcp_metrics_init();
-
-	tcp_register_congestion_control(&tcp_reno);
-
+	BUG_ON(tcp_register_congestion_control(&tcp_reno) != 0);
 	tcp_tasklet_init();
 }
* Unmerged path net/ipv4/tcp_cong.c
diff --git a/net/ipv4/tcp_minisocks.c b/net/ipv4/tcp_minisocks.c
index 7a436c517e44..cff873e57047 100644
--- a/net/ipv4/tcp_minisocks.c
+++ b/net/ipv4/tcp_minisocks.c
@@ -420,9 +420,8 @@ struct sock *tcp_create_openreq_child(struct sock *sk, struct request_sock *req,
 		newtp->snd_cwnd = TCP_INIT_CWND;
 		newtp->snd_cwnd_cnt = 0;
 
-		if (newicsk->icsk_ca_ops != &tcp_init_congestion_ops &&
-		    !try_module_get(newicsk->icsk_ca_ops->owner))
-			newicsk->icsk_ca_ops = &tcp_init_congestion_ops;
+		if (!try_module_get(newicsk->icsk_ca_ops->owner))
+			tcp_assign_congestion_control(newsk);
 
 		tcp_set_ca_state(newsk, TCP_CA_Open);
 		tcp_init_xmit_timers(newsk);
