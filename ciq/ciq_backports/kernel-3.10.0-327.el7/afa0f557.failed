md: rename ->stop to ->free

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [md] rename ->stop to ->free (Jes Sorensen) [1150149 1173510 1194720]
Rebuild_FUZZ: 92.00%
commit-author NeilBrown <neilb@suse.de>
commit afa0f557cb15176570a18fb2a093e348a793afd4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/afa0f557.failed

Now that the ->stop function only frees the private data,
rename is accordingly.

Also pass in the private pointer as an arg rather than using
mddev->private.  This flexibility will be useful in level_store().

Finally, don't clear ->private.  It doesn't make sense to clear
it seeing that isn't what we free, and it is no longer necessary
to clear ->private (it was some time ago before  ->to_remove was
introduced).

Setting ->to_remove in ->free() is a bit of a wart, but not a
big problem at the moment.

	Signed-off-by: NeilBrown <neilb@suse.de>
(cherry picked from commit afa0f557cb15176570a18fb2a093e348a793afd4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/linear.c
#	drivers/md/md.c
#	drivers/md/multipath.c
#	drivers/md/raid1.c
diff --cc drivers/md/linear.c
index cfa72dcb5f78,fa7d577f3d12..000000000000
--- a/drivers/md/linear.c
+++ b/drivers/md/linear.c
@@@ -255,26 -249,11 +255,27 @@@ static int linear_add(struct mddev *mdd
  	return 0;
  }
  
- static int linear_stop (struct mddev *mddev)
+ static void linear_free(struct mddev *mddev, void *priv)
  {
++<<<<<<< HEAD
 +	struct linear_conf *conf =
 +		rcu_dereference_protected(mddev->private,
 +					  lockdep_is_held(
 +						  &mddev->reconfig_mutex));
++=======
+ 	struct linear_conf *conf = priv;
++>>>>>>> afa0f557cb15 (md: rename ->stop to ->free)
  
 +	/*
 +	 * We do not require rcu protection here since
 +	 * we hold reconfig_mutex for both linear_add and
 +	 * linear_stop, so they cannot race.
 +	 * We should make sure any old 'conf's are properly
 +	 * freed though.
 +	 */
 +	rcu_barrier();
 +	blk_sync_queue(mddev->queue); /* the unplug fn references 'conf'*/
  	kfree(conf);
- 	mddev->private = NULL;
- 
- 	return 0;
  }
  
  static void linear_make_request(struct mddev *mddev, struct bio *bio)
diff --cc drivers/md/md.c
index 0227d221c67b,2920fd004865..000000000000
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@@ -3524,8 -3373,9 +3524,14 @@@ level_store(struct mddev *mddev, const 
  
  	/* Looks like we have a winner */
  	mddev_suspend(mddev);
++<<<<<<< HEAD
 +	mddev->pers->stop(mddev);
 +	
++=======
+ 	mddev_detach(mddev);
+ 	mddev->pers->free(mddev, mddev->private);
+ 
++>>>>>>> afa0f557cb15 (md: rename ->stop to ->free)
  	if (mddev->pers->sync_request == NULL &&
  	    pers->sync_request != NULL) {
  		/* need to add the md_redundancy_group */
@@@ -5091,13 -4934,13 +5097,18 @@@ int md_run(struct mddev *mddev
  	if (err == 0 && mddev->pers->sync_request &&
  	    (mddev->bitmap_info.file || mddev->bitmap_info.offset)) {
  		err = bitmap_create(mddev);
 -		if (err)
 +		if (err) {
  			printk(KERN_ERR "%s: failed to create bitmap (%d)\n",
  			       mdname(mddev), err);
 +			mddev->pers->stop(mddev);
 +		}
  	}
  	if (err) {
++<<<<<<< HEAD
++=======
+ 		mddev_detach(mddev);
+ 		mddev->pers->free(mddev, mddev->private);
++>>>>>>> afa0f557cb15 (md: rename ->stop to ->free)
  		module_put(mddev->pers->owner);
  		mddev->pers = NULL;
  		bitmap_destroy(mddev);
@@@ -5273,7 -5116,28 +5284,12 @@@ EXPORT_SYMBOL_GPL(md_stop_writes)
  static void __md_stop(struct mddev *mddev)
  {
  	mddev->ready = 0;
++<<<<<<< HEAD
 +	mddev->pers->stop(mddev);
++=======
+ 	mddev_detach(mddev);
+ 	mddev->pers->free(mddev, mddev->private);
++>>>>>>> afa0f557cb15 (md: rename ->stop to ->free)
  	if (mddev->pers->sync_request && mddev->to_remove == NULL)
  		mddev->to_remove = &md_redundancy_group;
  	module_put(mddev->pers->owner);
diff --cc drivers/md/multipath.c
index abf0900675af,ac3ede2bd00e..000000000000
--- a/drivers/md/multipath.c
+++ b/drivers/md/multipath.c
@@@ -504,13 -500,10 +504,17 @@@ out
  	return -EIO;
  }
  
++<<<<<<< HEAD
 +
 +static int multipath_stop (struct mddev *mddev)
++=======
+ static void multipath_free(struct mddev *mddev, void *priv)
++>>>>>>> afa0f557cb15 (md: rename ->stop to ->free)
  {
- 	struct mpconf *conf = mddev->private;
+ 	struct mpconf *conf = priv;
  
 +	md_unregister_thread(&mddev->thread);
 +	blk_sync_queue(mddev->queue); /* the unplug fn references 'conf'*/
  	mempool_destroy(conf->pool);
  	kfree(conf->multipaths);
  	kfree(conf);
diff --cc drivers/md/raid1.c
index 4178bb7f9cef,5dd0c2e59ab9..000000000000
--- a/drivers/md/raid1.c
+++ b/drivers/md/raid1.c
@@@ -2953,29 -2954,17 +2953,40 @@@ static int run(struct mddev *mddev
  	}
  
  	ret =  md_integrity_register(mddev);
++<<<<<<< HEAD
 +	if (ret)
 +		stop(mddev);
++=======
+ 	if (ret) {
+ 		md_unregister_thread(&mddev->thread);
+ 		raid1_free(mddev, conf);
+ 	}
++>>>>>>> afa0f557cb15 (md: rename ->stop to ->free)
  	return ret;
  }
  
- static int stop(struct mddev *mddev)
+ static void raid1_free(struct mddev *mddev, void *priv)
  {
++<<<<<<< HEAD
 +	struct r1conf *conf = mddev->private;
 +	struct bitmap *bitmap = mddev->bitmap;
++=======
+ 	struct r1conf *conf = priv;
++>>>>>>> afa0f557cb15 (md: rename ->stop to ->free)
 +
 +	/* wait for behind writes to complete */
 +	if (bitmap && atomic_read(&bitmap->behind_writes) > 0) {
 +		printk(KERN_INFO "md/raid1:%s: behind writes in progress - waiting to stop.\n",
 +		       mdname(mddev));
 +		/* need to kick something here to make sure I/O goes? */
 +		wait_event(bitmap->behind_wait,
 +			   atomic_read(&bitmap->behind_writes) == 0);
 +	}
 +
 +	freeze_array(conf, 0);
 +	unfreeze_array(conf);
  
 +	md_unregister_thread(&mddev->thread);
  	if (conf->r1bio_pool)
  		mempool_destroy(conf->r1bio_pool);
  	kfree(conf->mirrors);
diff --git a/drivers/md/faulty.c b/drivers/md/faulty.c
index 3193aefe982b..5a562da8c6ea 100644
--- a/drivers/md/faulty.c
+++ b/drivers/md/faulty.c
@@ -327,13 +327,11 @@ static int run(struct mddev *mddev)
 	return 0;
 }
 
-static int stop(struct mddev *mddev)
+static void faulty_free(struct mddev *mddev, void *priv)
 {
-	struct faulty_conf *conf = mddev->private;
+	struct faulty_conf *conf = priv;
 
 	kfree(conf);
-	mddev->private = NULL;
-	return 0;
 }
 
 static struct md_personality faulty_personality =
@@ -343,7 +341,7 @@ static struct md_personality faulty_personality =
 	.owner		= THIS_MODULE,
 	.make_request	= make_request,
 	.run		= run,
-	.stop		= stop,
+	.free		= faulty_free,
 	.status		= status,
 	.check_reshape	= reshape,
 	.size		= faulty_size,
* Unmerged path drivers/md/linear.c
* Unmerged path drivers/md/md.c
diff --git a/drivers/md/md.h b/drivers/md/md.h
index 8c92b269b12b..b0128b88ac64 100644
--- a/drivers/md/md.h
+++ b/drivers/md/md.h
@@ -466,7 +466,7 @@ struct md_personality
 	struct module *owner;
 	void (*make_request)(struct mddev *mddev, struct bio *bio);
 	int (*run)(struct mddev *mddev);
-	int (*stop)(struct mddev *mddev);
+	void (*free)(struct mddev *mddev, void *priv);
 	void (*status)(struct seq_file *seq, struct mddev *mddev);
 	/* error_handler must set ->faulty and clear ->in_sync
 	 * if appropriate, and should abort recovery if needed 
* Unmerged path drivers/md/multipath.c
diff --git a/drivers/md/raid0.c b/drivers/md/raid0.c
index 633df3e840a6..835677ac864d 100644
--- a/drivers/md/raid0.c
+++ b/drivers/md/raid0.c
@@ -416,7 +416,7 @@ static sector_t raid0_size(struct mddev *mddev, sector_t sectors, int raid_disks
 	return array_sectors;
 }
 
-static int raid0_stop(struct mddev *mddev);
+static void raid0_free(struct mddev *mddev, void *priv);
 
 static int raid0_run(struct mddev *mddev)
 {
@@ -469,21 +469,19 @@ static int raid0_run(struct mddev *mddev)
 
 	ret = md_integrity_register(mddev);
 	if (ret)
-		raid0_stop(mddev);
+		raid0_free(mddev, conf);
 
 	return ret;
 }
 
-static int raid0_stop(struct mddev *mddev)
+static void raid0_free(struct mddev *mddev, void *priv)
 {
-	struct r0conf *conf = mddev->private;
+	struct r0conf *conf = priv;
 
 	blk_sync_queue(mddev->queue); /* the unplug fn references 'conf'*/
 	kfree(conf->strip_zone);
 	kfree(conf->devlist);
 	kfree(conf);
-	mddev->private = NULL;
-	return 0;
 }
 
 /*
@@ -736,7 +734,7 @@ static struct md_personality raid0_personality=
 	.owner		= THIS_MODULE,
 	.make_request	= raid0_make_request,
 	.run		= raid0_run,
-	.stop		= raid0_stop,
+	.free		= raid0_free,
 	.status		= raid0_status,
 	.size		= raid0_size,
 	.takeover	= raid0_takeover,
* Unmerged path drivers/md/raid1.c
diff --git a/drivers/md/raid10.c b/drivers/md/raid10.c
index 7b666e739d33..f82a4bde5d5b 100644
--- a/drivers/md/raid10.c
+++ b/drivers/md/raid10.c
@@ -3817,9 +3817,9 @@ out:
 	return -EIO;
 }
 
-static int stop(struct mddev *mddev)
+static void raid10_free(struct mddev *mddev, void *priv)
 {
-	struct r10conf *conf = mddev->private;
+	struct r10conf *conf = priv;
 
 	raise_barrier(conf, 0);
 	lower_barrier(conf);
@@ -3836,8 +3836,6 @@ static int stop(struct mddev *mddev)
 	kfree(conf->mirrors_old);
 	kfree(conf->mirrors_new);
 	kfree(conf);
-	mddev->private = NULL;
-	return 0;
 }
 
 static void raid10_quiesce(struct mddev *mddev, int state)
@@ -4719,7 +4717,7 @@ static struct md_personality raid10_personality =
 	.owner		= THIS_MODULE,
 	.make_request	= make_request,
 	.run		= run,
-	.stop		= stop,
+	.free		= raid10_free,
 	.status		= status,
 	.error_handler	= error,
 	.hot_add_disk	= raid10_add_disk,
diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c
index 22a4c2e18c39..213ff921ee39 100644
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@ -6250,15 +6250,13 @@ abort:
 	return -EIO;
 }
 
-static int stop(struct mddev *mddev)
+static void raid5_free(struct mddev *mddev, void *priv)
 {
-	struct r5conf *conf = mddev->private;
+	struct r5conf *conf = priv;
 
 	md_unregister_thread(&mddev->thread);
 	free_conf(conf);
-	mddev->private = NULL;
 	mddev->to_remove = &raid5_attrs_group;
-	return 0;
 }
 
 static void status(struct seq_file *seq, struct mddev *mddev)
@@ -7036,7 +7034,7 @@ static struct md_personality raid6_personality =
 	.owner		= THIS_MODULE,
 	.make_request	= make_request,
 	.run		= run,
-	.stop		= stop,
+	.free		= raid5_free,
 	.status		= status,
 	.error_handler	= error,
 	.hot_add_disk	= raid5_add_disk,
@@ -7060,7 +7058,7 @@ static struct md_personality raid5_personality =
 	.owner		= THIS_MODULE,
 	.make_request	= make_request,
 	.run		= run,
-	.stop		= stop,
+	.free		= raid5_free,
 	.status		= status,
 	.error_handler	= error,
 	.hot_add_disk	= raid5_add_disk,
@@ -7085,7 +7083,7 @@ static struct md_personality raid4_personality =
 	.owner		= THIS_MODULE,
 	.make_request	= make_request,
 	.run		= run,
-	.stop		= stop,
+	.free		= raid5_free,
 	.status		= status,
 	.error_handler	= error,
 	.hot_add_disk	= raid5_add_disk,
