bonding: convert curr_slave_lock to a spinlock and rename it

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Nikolay Aleksandrov <nikolay@redhat.com>
commit b743562819bd97cc7c282e870896bae8016b64b5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/b7435628.failed

curr_slave_lock is now a misleading name, a much better name is
mode_lock as it'll be used for each mode's purposes and it's no longer
necessary to use a rwlock, a simple spinlock is enough.

	Suggested-by: Jay Vosburgh <jay.vosburgh@canonical.com>
	Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b743562819bd97cc7c282e870896bae8016b64b5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_3ad.c
#	drivers/net/bonding/bond_main.c
#	drivers/net/bonding/bonding.h
diff --cc drivers/net/bonding/bond_3ad.c
index 65115ee7b259,1824d1df4d09..000000000000
--- a/drivers/net/bonding/bond_3ad.c
+++ b/drivers/net/bonding/bond_3ad.c
@@@ -2109,24 -2051,30 +2109,32 @@@ void bond_3ad_state_machine_handler(str
  {
  	struct bonding *bond = container_of(work, struct bonding,
  					    ad_work.work);
 -	struct aggregator *aggregator;
 -	struct list_head *iter;
 -	struct slave *slave;
  	struct port *port;
 -	bool should_notify_rtnl = BOND_SLAVE_NOTIFY_LATER;
 +	struct aggregator *aggregator;
  
++<<<<<<< HEAD
 +	if (!rtnl_trylock()) {
 +		queue_delayed_work(bond->wq, &bond->ad_work, ad_delta_in_ticks);
 +		return;
 +	}
 +	//check if there are any slaves
 +	if (bond->slave_cnt == 0)
++=======
+ 	spin_lock_bh(&bond->mode_lock);
+ 	rcu_read_lock();
+ 
+ 	/* check if there are any slaves */
+ 	if (!bond_has_slaves(bond))
++>>>>>>> b743562819bd (bonding: convert curr_slave_lock to a spinlock and rename it)
  		goto re_arm;
  
 -	/* check if agg_select_timer timer after initialize is timed out */
 -	if (BOND_AD_INFO(bond).agg_select_timer &&
 -	    !(--BOND_AD_INFO(bond).agg_select_timer)) {
 -		slave = bond_first_slave_rcu(bond);
 -		port = slave ? &(SLAVE_AD_INFO(slave)->port) : NULL;
 -
 -		/* select the active aggregator for the bond */
 -		if (port) {
 +	// check if agg_select_timer timer after initialize is timed out
 +	if (BOND_AD_INFO(bond).agg_select_timer && !(--BOND_AD_INFO(bond).agg_select_timer)) {
 +		// select the active aggregator for the bond
 +		if ((port = __get_first_port(bond))) {
  			if (!port->slave) {
 -				net_warn_ratelimited("%s: Warning: bond's first port is uninitialized\n",
 -						     bond->dev->name);
 +				pr_warning("%s: Warning: bond's first port is uninitialized\n",
 +					   bond->dev->name);
  				goto re_arm;
  			}
  
@@@ -2164,7 -2113,19 +2172,23 @@@
  	}
  
  re_arm:
++<<<<<<< HEAD
 +	rtnl_unlock();
++=======
+ 	bond_for_each_slave_rcu(bond, slave, iter) {
+ 		if (slave->should_notify) {
+ 			should_notify_rtnl = BOND_SLAVE_NOTIFY_NOW;
+ 			break;
+ 		}
+ 	}
+ 	rcu_read_unlock();
+ 	spin_unlock_bh(&bond->mode_lock);
+ 
+ 	if (should_notify_rtnl && rtnl_trylock()) {
+ 		bond_slave_state_notify(bond);
+ 		rtnl_unlock();
+ 	}
++>>>>>>> b743562819bd (bonding: convert curr_slave_lock to a spinlock and rename it)
  	queue_delayed_work(bond->wq, &bond->ad_work, ad_delta_in_ticks);
  }
  
diff --cc drivers/net/bonding/bond_main.c
index b4cb8784d691,99d21c2fd44f..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -1952,39 -1674,35 +1952,45 @@@ static int __bond_release_one(struct ne
  	 * for this slave anymore.
  	 */
  	netdev_rx_handler_unregister(slave_dev);
 +	write_lock_bh(&bond->lock);
 +
 +	if (!all && !bond->params.fail_over_mac) {
 +		if (ether_addr_equal(bond_dev->dev_addr, slave->perm_hwaddr) &&
 +		    bond->slave_cnt > 1)
 +			pr_warning("%s: Warning: the permanent HWaddr of %s - %pM - is still in use by %s. Set the HWaddr of %s to a different address to avoid conflicts.\n",
 +				   bond_dev->name, slave_dev->name,
 +				   slave->perm_hwaddr,
 +				   bond_dev->name, slave_dev->name);
 +	}
  
 -	if (BOND_MODE(bond) == BOND_MODE_8023AD) {
 -		/* Sync against bond_3ad_rx_indication and
 -		 * bond_3ad_state_machine_handler
 +	/* Inform AD package of unbinding of slave. */
 +	if (bond->params.mode == BOND_MODE_8023AD) {
 +		/* must be called before the slave is
 +		 * detached from the list
  		 */
++<<<<<<< HEAD
 +		bond_3ad_unbind_slave(slave);
++=======
+ 		spin_lock_bh(&bond->mode_lock);
+ 		bond_3ad_unbind_slave(slave);
+ 		spin_unlock_bh(&bond->mode_lock);
++>>>>>>> b743562819bd (bonding: convert curr_slave_lock to a spinlock and rename it)
  	}
  
 -	netdev_info(bond_dev, "Releasing %s interface %s\n",
 -		    bond_is_active_slave(slave) ? "active" : "backup",
 -		    slave_dev->name);
 +	pr_info("%s: releasing %s interface %s\n",
 +		bond_dev->name,
 +		bond_is_active_slave(slave) ? "active" : "backup",
 +		slave_dev->name);
  
 -	oldcurrent = rcu_access_pointer(bond->curr_active_slave);
 +	oldcurrent = bond->curr_active_slave;
  
 -	RCU_INIT_POINTER(bond->current_arp_slave, NULL);
 +	bond->current_arp_slave = NULL;
  
 -	if (!all && (!bond->params.fail_over_mac ||
 -		     BOND_MODE(bond) != BOND_MODE_ACTIVEBACKUP)) {
 -		if (ether_addr_equal_64bits(bond_dev->dev_addr, slave->perm_hwaddr) &&
 -		    bond_has_slaves(bond))
 -			netdev_warn(bond_dev, "the permanent HWaddr of %s - %pM - is still in use by %s - set the HWaddr of %s to a different address to avoid conflicts\n",
 -				    slave_dev->name, slave->perm_hwaddr,
 -				    bond_dev->name, slave_dev->name);
 -	}
 +	/* release the slave from its bond */
 +	bond_detach_slave(bond, slave);
  
 -	if (rtnl_dereference(bond->primary_slave) == slave)
 -		RCU_INIT_POINTER(bond->primary_slave, NULL);
 +	if (bond->primary_slave == slave)
 +		bond->primary_slave = NULL;
  
  	if (oldcurrent == slave)
  		bond_change_active_slave(bond, NULL);
@@@ -4232,10 -3850,7 +4238,14 @@@ void bond_setup(struct net_device *bond
  {
  	struct bonding *bond = netdev_priv(bond_dev);
  
++<<<<<<< HEAD
 +	/* initialize rwlocks */
 +	rwlock_init(&bond->lock);
 +	rwlock_init(&bond->curr_slave_lock);
 +
++=======
+ 	spin_lock_init(&bond->mode_lock);
++>>>>>>> b743562819bd (bonding: convert curr_slave_lock to a spinlock and rename it)
  	bond->params = bonding_defaults;
  
  	/* Initialize pointers */
diff --cc drivers/net/bonding/bonding.h
index 64c0cb81e478,0cda34b827f8..000000000000
--- a/drivers/net/bonding/bonding.h
+++ b/drivers/net/bonding/bonding.h
@@@ -224,8 -195,7 +224,12 @@@ struct bonding 
  	s32      slave_cnt; /* never change this value outside the attach/detach wrappers */
  	int     (*recv_probe)(const struct sk_buff *, struct bonding *,
  			      struct slave *);
++<<<<<<< HEAD
 +	rwlock_t lock;
 +	rwlock_t curr_slave_lock;
++=======
+ 	spinlock_t mode_lock;
++>>>>>>> b743562819bd (bonding: convert curr_slave_lock to a spinlock and rename it)
  	u8	 send_peer_notif;
  	u8       igmp_retrans;
  #ifdef CONFIG_PROC_FS
* Unmerged path drivers/net/bonding/bond_3ad.c
* Unmerged path drivers/net/bonding/bond_main.c
* Unmerged path drivers/net/bonding/bonding.h
