xfs: pass xfs_da_args to xfs_attr_leaf_newentsize

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit c59f0ad23af0f4d7f64d2c2cdd85ceb49f6337fa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/c59f0ad2.failed

As it's only ever called from contexts where the xfs_da_args is
present and contains all the information needed inside the args
structure.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>


(cherry picked from commit c59f0ad23af0f4d7f64d2c2cdd85ceb49f6337fa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_attr.c
#	fs/xfs/xfs_attr_leaf.c
diff --cc fs/xfs/xfs_attr.c
index f3b9670979f5,3d8c03edf657..000000000000
--- a/fs/xfs/xfs_attr.c
+++ b/fs/xfs/xfs_attr.c
@@@ -176,12 -174,10 +176,16 @@@ xfs_attr_calc_size
  	 * Determine space new attribute will use, and if it would be
  	 * "local" or "remote" (note: local != inline).
  	 */
++<<<<<<< HEAD
 +	size = xfs_attr_leaf_newentsize(namelen, valuelen,
 +					mp->m_sb.sb_blocksize, local);
 +
++=======
+ 	size = xfs_attr_leaf_newentsize(args, local);
++>>>>>>> c59f0ad23af0 (xfs: pass xfs_da_args to xfs_attr_leaf_newentsize)
  	nblks = XFS_DAENTER_SPACE_RES(mp, XFS_ATTR_FORK);
  	if (*local) {
 -		if (size > (args->geo->blksize / 2)) {
 +		if (size > (mp->m_sb.sb_blocksize >> 1)) {
  			/* Double split possible */
  			nblks *= 2;
  		}
diff --cc fs/xfs/xfs_attr_leaf.c
index 5be77b3a9bc4,77611032586d..000000000000
--- a/fs/xfs/xfs_attr_leaf.c
+++ b/fs/xfs/xfs_attr_leaf.c
@@@ -1076,8 -1076,7 +1076,12 @@@ xfs_attr3_leaf_add
  	leaf = bp->b_addr;
  	xfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);
  	ASSERT(args->index >= 0 && args->index <= ichdr.count);
++<<<<<<< HEAD
 +	entsize = xfs_attr_leaf_newentsize(args->namelen, args->valuelen,
 +			   args->trans->t_mountp->m_sb.sb_blocksize, NULL);
++=======
+ 	entsize = xfs_attr_leaf_newentsize(args, NULL);
++>>>>>>> c59f0ad23af0 (xfs: pass xfs_da_args to xfs_attr_leaf_newentsize)
  
  	/*
  	 * Search through freemap for first-fit on new name length.
@@@ -1179,14 -1178,11 +1183,22 @@@ xfs_attr3_leaf_add_work
  	ASSERT(ichdr->freemap[mapindex].base < XFS_LBSIZE(mp));
  	ASSERT((ichdr->freemap[mapindex].base & 0x3) == 0);
  	ASSERT(ichdr->freemap[mapindex].size >=
++<<<<<<< HEAD
 +		xfs_attr_leaf_newentsize(args->namelen, args->valuelen,
 +					 mp->m_sb.sb_blocksize, NULL));
 +	ASSERT(ichdr->freemap[mapindex].size < XFS_LBSIZE(mp));
 +	ASSERT((ichdr->freemap[mapindex].size & 0x3) == 0);
 +
 +	ichdr->freemap[mapindex].size -=
 +			xfs_attr_leaf_newentsize(args->namelen, args->valuelen,
 +						 mp->m_sb.sb_blocksize, &tmp);
++=======
+ 		xfs_attr_leaf_newentsize(args, NULL));
+ 	ASSERT(ichdr->freemap[mapindex].size < XFS_LBSIZE(mp));
+ 	ASSERT((ichdr->freemap[mapindex].size & 0x3) == 0);
+ 
+ 	ichdr->freemap[mapindex].size -= xfs_attr_leaf_newentsize(args, &tmp);
++>>>>>>> c59f0ad23af0 (xfs: pass xfs_da_args to xfs_attr_leaf_newentsize)
  
  	entry->nameidx = cpu_to_be16(ichdr->freemap[mapindex].base +
  				     ichdr->freemap[mapindex].size);
* Unmerged path fs/xfs/xfs_attr.c
* Unmerged path fs/xfs/xfs_attr_leaf.c
diff --git a/fs/xfs/xfs_attr_leaf.h b/fs/xfs/xfs_attr_leaf.h
index 3ec5ec0b8678..e2929da7c3ba 100644
--- a/fs/xfs/xfs_attr_leaf.h
+++ b/fs/xfs/xfs_attr_leaf.h
@@ -96,8 +96,7 @@ int	xfs_attr3_root_inactive(struct xfs_trans **trans, struct xfs_inode *dp);
 xfs_dahash_t	xfs_attr_leaf_lasthash(struct xfs_buf *bp, int *count);
 int	xfs_attr_leaf_order(struct xfs_buf *leaf1_bp,
 				   struct xfs_buf *leaf2_bp);
-int	xfs_attr_leaf_newentsize(int namelen, int valuelen, int blocksize,
-					int *local);
+int	xfs_attr_leaf_newentsize(struct xfs_da_args *args, int *local);
 int	xfs_attr3_leaf_read(struct xfs_trans *tp, struct xfs_inode *dp,
 			xfs_dablk_t bno, xfs_daddr_t mappedbno,
 			struct xfs_buf **bpp);
