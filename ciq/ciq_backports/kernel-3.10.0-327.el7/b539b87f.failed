percpu: implmeent pcpu_nr_empty_pop_pages and chunk->nr_populated

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Tejun Heo <tj@kernel.org>
commit b539b87fed37ffc16c89a6bc3beca2d7aed82e1c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/b539b87f.failed

pcpu_nr_empty_pop_pages counts the number of empty populated pages
across all chunks and chunk->nr_populated counts the number of
populated pages in a chunk.  Both will be used to implement pre/async
population for atomic allocations.

pcpu_chunk_[de]populated() are added to update chunk->populated,
chunk->nr_populated and pcpu_nr_empty_pop_pages together.  All
successful chunk [de]populations should be followed by the
corresponding pcpu_chunk_[de]populated() calls.

	Signed-off-by: Tejun Heo <tj@kernel.org>
(cherry picked from commit b539b87fed37ffc16c89a6bc3beca2d7aed82e1c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/percpu.c
diff --cc mm/percpu.c
index 576643473552,4f2d58760c9c..000000000000
--- a/mm/percpu.c
+++ b/mm/percpu.c
@@@ -479,6 -521,8 +518,11 @@@ static void pcpu_split_block(struct pcp
   * @chunk: chunk of interest
   * @size: wanted size in bytes
   * @align: wanted align
++<<<<<<< HEAD
++=======
+  * @pop_only: allocate only from the populated area
+  * @occ_pages_p: out param for the number of pages the area occupies
++>>>>>>> b539b87fed37 (percpu: implmeent pcpu_nr_empty_pop_pages and chunk->nr_populated)
   *
   * Try to allocate @size bytes area aligned at @align from @chunk.
   * Note that this function only allocates the offset.  It doesn't
@@@ -493,7 -537,8 +537,12 @@@
   * Allocated offset in @chunk on success, -1 if no matching area is
   * found.
   */
++<<<<<<< HEAD
 +static int pcpu_alloc_area(struct pcpu_chunk *chunk, int size, int align)
++=======
+ static int pcpu_alloc_area(struct pcpu_chunk *chunk, int size, int align,
+ 			   bool pop_only, int *occ_pages_p)
++>>>>>>> b539b87fed37 (percpu: implmeent pcpu_nr_empty_pop_pages and chunk->nr_populated)
  {
  	int oslot = pcpu_chunk_slot(chunk);
  	int max_contig = 0;
@@@ -570,8 -625,9 +619,9 @@@
  						 max_contig);
  
  		chunk->free_size -= size;
 -		*p |= 1;
 +		chunk->map[i] |= 1;
  
+ 		*occ_pages_p = pcpu_count_occupied_pages(chunk, i);
  		pcpu_chunk_relocate(chunk, oslot);
  		return off;
  	}
@@@ -756,6 -860,8 +854,11 @@@ static void __percpu *pcpu_alloc(size_
  	static int warn_limit = 10;
  	struct pcpu_chunk *chunk;
  	const char *err;
++<<<<<<< HEAD
++=======
+ 	bool is_atomic = !(gfp & GFP_KERNEL);
+ 	int occ_pages = 0;
++>>>>>>> b539b87fed37 (percpu: implmeent pcpu_nr_empty_pop_pages and chunk->nr_populated)
  	int slot, off, new_alloc, cpu, ret;
  	unsigned long flags;
  	void __percpu *ptr;
@@@ -791,7 -902,8 +894,12 @@@
  			spin_lock_irqsave(&pcpu_lock, flags);
  		}
  
++<<<<<<< HEAD
 +		off = pcpu_alloc_area(chunk, size, align);
++=======
+ 		off = pcpu_alloc_area(chunk, size, align, is_atomic,
+ 				      &occ_pages);
++>>>>>>> b539b87fed37 (percpu: implmeent pcpu_nr_empty_pop_pages and chunk->nr_populated)
  		if (off >= 0)
  			goto area_found;
  
@@@ -822,7 -936,8 +930,12 @@@ restart
  				goto restart;
  			}
  
++<<<<<<< HEAD
 +			off = pcpu_alloc_area(chunk, size, align);
++=======
+ 			off = pcpu_alloc_area(chunk, size, align, is_atomic,
+ 					      &occ_pages);
++>>>>>>> b539b87fed37 (percpu: implmeent pcpu_nr_empty_pop_pages and chunk->nr_populated)
  			if (off >= 0)
  				goto area_found;
  		}
diff --git a/mm/percpu-km.c b/mm/percpu-km.c
index e662b4947a65..10e3d0b8a86d 100644
--- a/mm/percpu-km.c
+++ b/mm/percpu-km.c
@@ -69,7 +69,7 @@ static struct pcpu_chunk *pcpu_create_chunk(void)
 	chunk->base_addr = page_address(pages) - pcpu_group_offsets[0];
 
 	spin_lock_irq(&pcpu_lock);
-	bitmap_fill(chunk->populated, nr_pages);
+	pcpu_chunk_populated(chunk, 0, nr_pages);
 	spin_unlock_irq(&pcpu_lock);
 
 	return chunk;
* Unmerged path mm/percpu.c
