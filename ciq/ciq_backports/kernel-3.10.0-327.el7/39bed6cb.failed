perf: Make perf_cgroup_from_task() global

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [perf] Make perf_cgroup_from_task() global (Jiri Olsa) [1222189]
Rebuild_FUZZ: 92.11%
commit-author Matt Fleming <matt.fleming@intel.com>
commit 39bed6cbb842d8edf5a26b01122b391d36775b5e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/39bed6cb.failed

Move perf_cgroup_from_task() from kernel/events/ to include/linux/ along
with the necessary struct definitions, so that it can be used by the PMU
code.

When the upcoming Intel Cache Monitoring PMU driver assigns monitoring
IDs to perf events, it needs to be able to check whether any two
monitoring events overlap (say, a cgroup and task event), which means we
need to be able to lookup the cgroup associated with a task (if any).

	Signed-off-by: Matt Fleming <matt.fleming@intel.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
	Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Kanaka Juvva <kanaka.d.juvva@intel.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Vikas Shivappa <vikas.shivappa@linux.intel.com>
Link: http://lkml.kernel.org/r/1422038748-21397-2-git-send-email-matt@codeblueprint.co.uk
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 39bed6cbb842d8edf5a26b01122b391d36775b5e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/events/core.c
diff --cc kernel/events/core.c
index 9f74e97b5c08,072de3143244..000000000000
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@@ -351,32 -351,6 +351,35 @@@ static void perf_ctx_unlock(struct perf
  
  #ifdef CONFIG_CGROUP_PERF
  
++<<<<<<< HEAD
 +/*
 + * perf_cgroup_info keeps track of time_enabled for a cgroup.
 + * This is a per-cpu dynamically allocated data structure.
 + */
 +struct perf_cgroup_info {
 +	u64				time;
 +	u64				timestamp;
 +};
 +
 +struct perf_cgroup {
 +	struct cgroup_subsys_state	css;
 +	struct perf_cgroup_info	__percpu *info;
 +};
 +
 +/*
 + * Must ensure cgroup is pinned (css_get) before calling
 + * this function. In other words, we cannot call this function
 + * if there is no cgroup event for the current CPU context.
 + */
 +static inline struct perf_cgroup *
 +perf_cgroup_from_task(struct task_struct *task)
 +{
 +	return container_of(task_subsys_state(task, perf_subsys_id),
 +			struct perf_cgroup, css);
 +}
 +
++=======
++>>>>>>> 39bed6cbb842 (perf: Make perf_cgroup_from_task() global)
  static inline bool
  perf_cgroup_match(struct perf_event *event)
  {
diff --git a/include/linux/perf_event.h b/include/linux/perf_event.h
index 68768e324db6..f38f9a72193d 100644
--- a/include/linux/perf_event.h
+++ b/include/linux/perf_event.h
@@ -53,6 +53,7 @@ struct perf_guest_info_callbacks {
 #include <linux/sysfs.h>
 #include <linux/perf_regs.h>
 #include <linux/workqueue.h>
+#include <linux/cgroup.h>
 #include <asm/local.h>
 
 #include <linux/rh_kabi.h>
@@ -560,6 +561,35 @@ struct perf_output_handle {
 	int				page;
 };
 
+#ifdef CONFIG_CGROUP_PERF
+
+/*
+ * perf_cgroup_info keeps track of time_enabled for a cgroup.
+ * This is a per-cpu dynamically allocated data structure.
+ */
+struct perf_cgroup_info {
+	u64				time;
+	u64				timestamp;
+};
+
+struct perf_cgroup {
+	struct cgroup_subsys_state	css;
+	struct perf_cgroup_info	__percpu *info;
+};
+
+/*
+ * Must ensure cgroup is pinned (css_get) before calling
+ * this function. In other words, we cannot call this function
+ * if there is no cgroup event for the current CPU context.
+ */
+static inline struct perf_cgroup *
+perf_cgroup_from_task(struct task_struct *task)
+{
+	return container_of(task_css(task, perf_event_cgrp_id),
+			    struct perf_cgroup, css);
+}
+#endif /* CONFIG_CGROUP_PERF */
+
 #ifdef CONFIG_PERF_EVENTS
 
 extern int perf_pmu_register(struct pmu *pmu, const char *name, int type);
* Unmerged path kernel/events/core.c
