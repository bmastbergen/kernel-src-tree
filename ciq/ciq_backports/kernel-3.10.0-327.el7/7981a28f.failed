amd64_edac: Modify usage of amd64_read_dct_pci_cfg()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Aravind Gopalakrishnan <Aravind.Gopalakrishnan@amd.com>
commit 7981a28f1ab5259754843b65c21879337785cb14
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/7981a28f.failed

Rationale behind this change:
 - F2x1xx addresses were stopped from being mapped explicitly to DCT1
   from F15h (OR) onwards. They use _dct[0:1] mechanism to access the
   registers. So we should move away from using address ranges to select
   DCT for these families.
 - On newer processors, the address ranges used to indicate DCT1 (0x140,
   0x1a0) have different meanings than what is assumed currently.

Changes introduced:
 - amd64_read_dct_pci_cfg() now takes in dct value and uses it for
   'selecting the dct'
 - Update usage of the function. Keep in mind that different families
   have specific handling requirements
 - Remove [k8|f10]_read_dct_pci_cfg() as they don't do much different
   from amd64_read_pci_cfg()
   - Move the k8 specific check to amd64_read_pci_cfg
 - Remove f15_read_dct_pci_cfg() and move logic to amd64_read_dct_pci_cfg()
 - Remove now needless .read_dct_pci_cfg

Testing:
 - Tested on Fam 10h; Fam15h Models: 00h, 30h; Fam16h using 'EDAC_DEBUG'
   and mce_amd_inj
 - driver obtains info from F2x registers and caches it in pvt
   structures correctly
 - ECC decoding works fine

	Signed-off-by: Aravind Gopalakrishnan <aravind.gopalakrishnan@amd.com>
Link: http://lkml.kernel.org/r/1410799058-3149-1-git-send-email-aravind.gopalakrishnan@amd.com
	Signed-off-by: Borislav Petkov <bp@suse.de>
(cherry picked from commit 7981a28f1ab5259754843b65c21879337785cb14)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/edac/amd64_edac.c
diff --cc drivers/edac/amd64_edac.c
index 9d33c8814154,bbd65149cdb2..000000000000
--- a/drivers/edac/amd64_edac.c
+++ b/drivers/edac/amd64_edac.c
@@@ -1796,9 -1820,18 +1812,21 @@@ static struct amd64_family_type family_
  			.early_channel_count	= f1x_early_channel_count,
  			.map_sysaddr_to_csrow	= f1x_map_sysaddr_to_csrow,
  			.dbam_to_cs		= f16_dbam_to_chip_select,
- 			.read_dct_pci_cfg	= f10_read_dct_pci_cfg,
  		}
  	},
++<<<<<<< HEAD
++=======
+ 	[F16_M30H_CPUS] = {
+ 		.ctl_name = "F16h_M30h",
+ 		.f1_id = PCI_DEVICE_ID_AMD_16H_M30H_NB_F1,
+ 		.f3_id = PCI_DEVICE_ID_AMD_16H_M30H_NB_F3,
+ 		.ops = {
+ 			.early_channel_count	= f1x_early_channel_count,
+ 			.map_sysaddr_to_csrow	= f1x_map_sysaddr_to_csrow,
+ 			.dbam_to_cs		= f16_dbam_to_chip_select,
+ 		}
+ 	},
++>>>>>>> 7981a28f1ab5 (amd64_edac: Modify usage of amd64_read_dct_pci_cfg())
  };
  
  /*
* Unmerged path drivers/edac/amd64_edac.c
diff --git a/drivers/edac/amd64_edac.h b/drivers/edac/amd64_edac.h
index 6dc1fcc25afb..a402bf7ad7e5 100644
--- a/drivers/edac/amd64_edac.h
+++ b/drivers/edac/amd64_edac.h
@@ -478,8 +478,6 @@ struct low_ops {
 	void (*map_sysaddr_to_csrow)	(struct mem_ctl_info *mci, u64 sys_addr,
 					 struct err_info *);
 	int (*dbam_to_cs)		(struct amd64_pvt *pvt, u8 dct, unsigned cs_mode);
-	int (*read_dct_pci_cfg)		(struct amd64_pvt *pvt, int offset,
-					 u32 *val, const char *func);
 };
 
 struct amd64_family_type {
@@ -499,9 +497,6 @@ int __amd64_write_pci_cfg_dword(struct pci_dev *pdev, int offset,
 #define amd64_write_pci_cfg(pdev, offset, val)	\
 	__amd64_write_pci_cfg_dword(pdev, offset, val, __func__)
 
-#define amd64_read_dct_pci_cfg(pvt, offset, val) \
-	pvt->ops->read_dct_pci_cfg(pvt, offset, val, __func__)
-
 int amd64_get_dram_hole_info(struct mem_ctl_info *mci, u64 *hole_base,
 			     u64 *hole_offset, u64 *hole_size);
 
