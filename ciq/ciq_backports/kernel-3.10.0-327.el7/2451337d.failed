xfs: global error sign conversion

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit 2451337dd043901b5270b7586942abe564443e3d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/2451337d.failed

Convert all the errors the core XFs code to negative error signs
like the rest of the kernel and remove all the sign conversion we
do in the interface layers.

Errors for conversion (and comparison) found via searches like:

$ git grep " E" fs/xfs
$ git grep "return E" fs/xfs
$ git grep " E[A-Z].*;$" fs/xfs

Negation points found via searches like:

$ git grep "= -[a-z,A-Z]" fs/xfs
$ git grep "return -[a-z,A-D,F-Z]" fs/xfs
$ git grep " -[a-z].*;" fs/xfs

[ with some bits I missed from Brian Foster ]

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit 2451337dd043901b5270b7586942abe564443e3d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_attr.c
#	fs/xfs/libxfs/xfs_attr_leaf.c
#	fs/xfs/libxfs/xfs_attr_remote.c
#	fs/xfs/libxfs/xfs_bmap.c
#	fs/xfs/libxfs/xfs_bmap_btree.c
#	fs/xfs/libxfs/xfs_btree.c
#	fs/xfs/libxfs/xfs_da_btree.c
#	fs/xfs/libxfs/xfs_dir2.c
#	fs/xfs/libxfs/xfs_dir2_block.c
#	fs/xfs/libxfs/xfs_dir2_leaf.c
#	fs/xfs/libxfs/xfs_dir2_node.c
#	fs/xfs/libxfs/xfs_dir2_sf.c
#	fs/xfs/libxfs/xfs_ialloc.c
#	fs/xfs/libxfs/xfs_inode_buf.c
#	fs/xfs/libxfs/xfs_inode_fork.c
#	fs/xfs/libxfs/xfs_sb.c
#	fs/xfs/xfs_aops.c
#	fs/xfs/xfs_attr_inactive.c
#	fs/xfs/xfs_attr_list.c
#	fs/xfs/xfs_bmap_util.c
#	fs/xfs/xfs_dir2_readdir.c
#	fs/xfs/xfs_dquot.c
#	fs/xfs/xfs_error.h
#	fs/xfs/xfs_file.c
#	fs/xfs/xfs_filestream.c
#	fs/xfs/xfs_fsops.c
#	fs/xfs/xfs_inode.c
#	fs/xfs/xfs_ioctl.c
#	fs/xfs/xfs_ioctl32.c
#	fs/xfs/xfs_iomap.c
#	fs/xfs/xfs_iops.c
#	fs/xfs/xfs_itable.c
#	fs/xfs/xfs_log.c
#	fs/xfs/xfs_log_cil.c
#	fs/xfs/xfs_log_recover.c
#	fs/xfs/xfs_mount.c
#	fs/xfs/xfs_mru_cache.c
#	fs/xfs/xfs_qm.c
#	fs/xfs/xfs_qm_bhv.c
#	fs/xfs/xfs_qm_syscalls.c
#	fs/xfs/xfs_rtalloc.c
#	fs/xfs/xfs_super.c
#	fs/xfs/xfs_symlink.c
#	fs/xfs/xfs_trans.c
#	fs/xfs/xfs_trans_buf.c
diff --cc fs/xfs/libxfs/xfs_attr.c
index 5e9fb4c71c0e,353fb425faef..000000000000
--- a/fs/xfs/libxfs/xfs_attr.c
+++ b/fs/xfs/libxfs/xfs_attr.c
@@@ -483,7 -477,7 +483,11 @@@ xfs_attr_remove
  	xfs_trans_ijoin(args.trans, dp, 0);
  
  	if (!xfs_inode_hasattr(dp)) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(ENOATTR);
++=======
+ 		error = -ENOATTR;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	} else if (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {
  		ASSERT(dp->i_afp->if_flags & XFS_IFINLINE);
  		error = xfs_attr_shortform_remove(&args);
@@@ -551,14 -545,14 +555,22 @@@ xfs_attr_shortform_addname(xfs_da_args_
  
  	if (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||
  	    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)
++<<<<<<< HEAD
 +		return XFS_ERROR(ENOSPC);
++=======
+ 		return -ENOSPC;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	newsize = XFS_ATTR_SF_TOTSIZE(args->dp);
  	newsize += XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);
  
  	forkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);
  	if (!forkoff)
++<<<<<<< HEAD
 +		return XFS_ERROR(ENOSPC);
++=======
+ 		return -ENOSPC;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	xfs_attr_shortform_add(args, forkoff);
  	return 0;
diff --cc fs/xfs/libxfs/xfs_attr_leaf.c
index e210c280e72a,b1f73dbbf3d8..000000000000
--- a/fs/xfs/libxfs/xfs_attr_leaf.c
+++ b/fs/xfs/libxfs/xfs_attr_leaf.c
@@@ -546,7 -547,7 +546,11 @@@ xfs_attr_shortform_remove(xfs_da_args_
  		break;
  	}
  	if (i == end)
++<<<<<<< HEAD
 +		return XFS_ERROR(ENOATTR);
++=======
+ 		return -ENOATTR;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	/*
  	 * Fix up the attribute fork data, covering the hole
@@@ -610,9 -611,9 +614,15 @@@ xfs_attr_shortform_lookup(xfs_da_args_
  			continue;
  		if (!xfs_attr_namesp_match(args->flags, sfe->flags))
  			continue;
++<<<<<<< HEAD
 +		return XFS_ERROR(EEXIST);
 +	}
 +	return XFS_ERROR(ENOATTR);
++=======
+ 		return -EEXIST;
+ 	}
+ 	return -ENOATTR;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  }
  
  /*
@@@ -639,18 -640,18 +649,32 @@@ xfs_attr_shortform_getvalue(xfs_da_args
  			continue;
  		if (args->flags & ATTR_KERNOVAL) {
  			args->valuelen = sfe->valuelen;
++<<<<<<< HEAD
 +			return XFS_ERROR(EEXIST);
 +		}
 +		if (args->valuelen < sfe->valuelen) {
 +			args->valuelen = sfe->valuelen;
 +			return XFS_ERROR(ERANGE);
++=======
+ 			return -EEXIST;
+ 		}
+ 		if (args->valuelen < sfe->valuelen) {
+ 			args->valuelen = sfe->valuelen;
+ 			return -ERANGE;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  		args->valuelen = sfe->valuelen;
  		memcpy(args->value, &sfe->nameval[args->namelen],
  						    args->valuelen);
++<<<<<<< HEAD
 +		return XFS_ERROR(EEXIST);
 +	}
 +	return XFS_ERROR(ENOATTR);
++=======
+ 		return -EEXIST;
+ 	}
+ 	return -ENOATTR;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  }
  
  /*
@@@ -806,11 -807,11 +830,11 @@@ xfs_attr3_leaf_to_shortform
  
  	trace_xfs_attr_leaf_to_sf(args);
  
 -	tmpbuffer = kmem_alloc(args->geo->blksize, KM_SLEEP);
 +	tmpbuffer = kmem_alloc(XFS_LBSIZE(dp->i_mount), KM_SLEEP);
  	if (!tmpbuffer)
- 		return ENOMEM;
+ 		return -ENOMEM;
  
 -	memcpy(tmpbuffer, bp->b_addr, args->geo->blksize);
 +	memcpy(tmpbuffer, bp->b_addr, XFS_LBSIZE(dp->i_mount));
  
  	leaf = (xfs_attr_leafblock_t *)tmpbuffer;
  	xfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);
@@@ -1108,7 -1108,7 +1132,11 @@@ xfs_attr3_leaf_add
  	 * no good and we should just give up.
  	 */
  	if (!ichdr.holes && sum < entsize)
++<<<<<<< HEAD
 +		return XFS_ERROR(ENOSPC);
++=======
+ 		return -ENOSPC;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	/*
  	 * Compact the entries to coalesce free space.
@@@ -2130,7 -2123,7 +2158,11 @@@ xfs_attr3_leaf_lookup_int
  	}
  	if (probe == ichdr.count || be32_to_cpu(entry->hashval) != hashval) {
  		args->index = probe;
++<<<<<<< HEAD
 +		return XFS_ERROR(ENOATTR);
++=======
+ 		return -ENOATTR;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	/*
@@@ -2159,7 -2152,7 +2191,11 @@@
  			if (!xfs_attr_namesp_match(args->flags, entry->flags))
  				continue;
  			args->index = probe;
++<<<<<<< HEAD
 +			return XFS_ERROR(EEXIST);
++=======
+ 			return -EEXIST;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		} else {
  			name_rmt = xfs_attr3_leaf_name_remote(leaf, probe);
  			if (name_rmt->namelen != args->namelen)
@@@ -2175,11 -2168,11 +2211,19 @@@
  			args->rmtblkcnt = xfs_attr3_rmt_blocks(
  							args->dp->i_mount,
  							args->rmtvaluelen);
++<<<<<<< HEAD
 +			return XFS_ERROR(EEXIST);
 +		}
 +	}
 +	args->index = probe;
 +	return XFS_ERROR(ENOATTR);
++=======
+ 			return -EEXIST;
+ 		}
+ 	}
+ 	args->index = probe;
+ 	return -ENOATTR;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  }
  
  /*
@@@ -2215,7 -2208,7 +2259,11 @@@ xfs_attr3_leaf_getvalue
  		}
  		if (args->valuelen < valuelen) {
  			args->valuelen = valuelen;
++<<<<<<< HEAD
 +			return XFS_ERROR(ERANGE);
++=======
+ 			return -ERANGE;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  		args->valuelen = valuelen;
  		memcpy(args->value, &name_loc->nameval[args->namelen], valuelen);
@@@ -2233,7 -2226,7 +2281,11 @@@
  		}
  		if (args->valuelen < args->rmtvaluelen) {
  			args->valuelen = args->rmtvaluelen;
++<<<<<<< HEAD
 +			return XFS_ERROR(ERANGE);
++=======
+ 			return -ERANGE;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  		args->valuelen = args->rmtvaluelen;
  	}
diff --cc fs/xfs/libxfs/xfs_attr_remote.c
index e68cdbc46959,7510ab8058a4..000000000000
--- a/fs/xfs/libxfs/xfs_attr_remote.c
+++ b/fs/xfs/libxfs/xfs_attr_remote.c
@@@ -133,21 -134,20 +133,30 @@@ xfs_attr3_rmt_read_verify
  	ptr = bp->b_addr;
  	bno = bp->b_bn;
  	len = BBTOB(bp->b_length);
 -	ASSERT(len >= blksize);
 +	ASSERT(len >= XFS_LBSIZE(mp));
  
  	while (len > 0) {
++<<<<<<< HEAD
 +		if (!xfs_verify_cksum(ptr, XFS_LBSIZE(mp),
 +				      XFS_ATTR3_RMT_CRC_OFF)) {
 +			xfs_buf_ioerror(bp, EFSBADCRC);
 +			break;
 +		}
 +		if (!xfs_attr3_rmt_verify(mp, ptr, XFS_LBSIZE(mp), bno)) {
 +			xfs_buf_ioerror(bp, EFSCORRUPTED);
++=======
+ 		if (!xfs_verify_cksum(ptr, blksize, XFS_ATTR3_RMT_CRC_OFF)) {
+ 			xfs_buf_ioerror(bp, -EFSBADCRC);
+ 			break;
+ 		}
+ 		if (!xfs_attr3_rmt_verify(mp, ptr, blksize, bno)) {
+ 			xfs_buf_ioerror(bp, -EFSCORRUPTED);
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			break;
  		}
 -		len -= blksize;
 -		ptr += blksize;
 -		bno += BTOBB(blksize);
 +		len -= XFS_LBSIZE(mp);
 +		ptr += XFS_LBSIZE(mp);
 +		bno += mp->m_bsize;
  	}
  
  	if (bp->b_error)
@@@ -173,11 -174,11 +182,16 @@@ xfs_attr3_rmt_write_verify
  	ptr = bp->b_addr;
  	bno = bp->b_bn;
  	len = BBTOB(bp->b_length);
 -	ASSERT(len >= blksize);
 +	ASSERT(len >= XFS_LBSIZE(mp));
  
  	while (len > 0) {
++<<<<<<< HEAD
 +		if (!xfs_attr3_rmt_verify(mp, ptr, XFS_LBSIZE(mp), bno)) {
 +			xfs_buf_ioerror(bp, EFSCORRUPTED);
++=======
+ 		if (!xfs_attr3_rmt_verify(mp, ptr, blksize, bno)) {
+ 			xfs_buf_ioerror(bp, -EFSCORRUPTED);
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			xfs_verifier_error(bp);
  			return;
  		}
diff --cc fs/xfs/libxfs/xfs_bmap.c
index b6f15ccf3239,72a110eb1dda..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@@ -1033,7 -1033,7 +1033,11 @@@ xfs_bmap_add_attrfork_btree
  			goto error0;
  		if (stat == 0) {
  			xfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);
++<<<<<<< HEAD
 +			return XFS_ERROR(ENOSPC);
++=======
+ 			return -ENOSPC;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  		*firstblock = cur->bc_private.b.firstblock;
  		cur->bc_private.b.allocated = 0;
@@@ -1191,7 -1192,7 +1195,11 @@@ xfs_bmap_add_attrfork
  		break;
  	default:
  		ASSERT(0);
++<<<<<<< HEAD
 +		error = XFS_ERROR(EINVAL);
++=======
+ 		error = -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto trans_cancel;
  	}
  
@@@ -1398,7 -1399,7 +1406,11 @@@ xfs_bmap_read_extents
  	return 0;
  error0:
  	xfs_trans_brelse(tp, bp);
++<<<<<<< HEAD
 +	return XFS_ERROR(EFSCORRUPTED);
++=======
+ 	return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  }
  
  
@@@ -1575,7 -1576,7 +1587,11 @@@ xfs_bmap_last_before
  	if (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE &&
  	    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&
  	    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_LOCAL)
++<<<<<<< HEAD
 +	       return XFS_ERROR(EIO);
++=======
+ 	       return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	if (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL) {
  		*last_block = 0;
  		return 0;
@@@ -1690,7 -1690,7 +1706,11 @@@ xfs_bmap_last_offset
  
  	if (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE &&
  	    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)
++<<<<<<< HEAD
 +	       return XFS_ERROR(EIO);
++=======
+ 	       return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	error = xfs_bmap_last_extent(NULL, ip, whichfork, &rec, &is_empty);
  	if (error || is_empty)
@@@ -3323,7 -3323,7 +3343,11 @@@ xfs_bmap_extsize_align
  		if (orig_off < align_off ||
  		    orig_end > align_off + align_alen ||
  		    align_alen - temp < orig_alen)
++<<<<<<< HEAD
 +			return XFS_ERROR(EINVAL);
++=======
+ 			return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		/*
  		 * Try to fix it by moving the start up.
  		 */
@@@ -3348,7 -3348,7 +3372,11 @@@
  		 * Result doesn't cover the request, fail it.
  		 */
  		if (orig_off < align_off || orig_end > align_off + align_alen)
++<<<<<<< HEAD
 +			return XFS_ERROR(EINVAL);
++=======
+ 			return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	} else {
  		ASSERT(orig_off >= align_off);
  		ASSERT(orig_end <= align_off + align_alen);
@@@ -4050,11 -4051,11 +4078,19 @@@ xfs_bmapi_read
  	     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),
  	     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {
  		XFS_ERROR_REPORT("xfs_bmapi_read", XFS_ERRLEVEL_LOW, mp);
++<<<<<<< HEAD
 +		return XFS_ERROR(EFSCORRUPTED);
 +	}
 +
 +	if (XFS_FORCED_SHUTDOWN(mp))
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EFSCORRUPTED;
+ 	}
+ 
+ 	if (XFS_FORCED_SHUTDOWN(mp))
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	XFS_STATS_INC(xs_blk_mapr);
  
@@@ -4244,11 -4246,11 +4280,19 @@@ xfs_bmapi_delay
  	     XFS_IFORK_FORMAT(ip, XFS_DATA_FORK) != XFS_DINODE_FMT_BTREE),
  	     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {
  		XFS_ERROR_REPORT("xfs_bmapi_delay", XFS_ERRLEVEL_LOW, mp);
++<<<<<<< HEAD
 +		return XFS_ERROR(EFSCORRUPTED);
 +	}
 +
 +	if (XFS_FORCED_SHUTDOWN(mp))
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EFSCORRUPTED;
+ 	}
+ 
+ 	if (XFS_FORCED_SHUTDOWN(mp))
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	XFS_STATS_INC(xs_blk_mapw);
  
@@@ -4537,11 -4540,11 +4581,19 @@@ xfs_bmapi_write
  	     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),
  	     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {
  		XFS_ERROR_REPORT("xfs_bmapi_write", XFS_ERRLEVEL_LOW, mp);
++<<<<<<< HEAD
 +		return XFS_ERROR(EFSCORRUPTED);
 +	}
 +
 +	if (XFS_FORCED_SHUTDOWN(mp))
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EFSCORRUPTED;
+ 	}
+ 
+ 	if (XFS_FORCED_SHUTDOWN(mp))
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	ifp = XFS_IFORK_PTR(ip, whichfork);
  
@@@ -4955,7 -4961,7 +5007,11 @@@ xfs_bmap_del_extent
  					xfs_bmbt_set_blockcount(ep,
  						got.br_blockcount);
  					flags = 0;
++<<<<<<< HEAD
 +					error = XFS_ERROR(ENOSPC);
++=======
+ 					error = -ENOSPC;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  					goto done;
  				}
  				XFS_WANT_CORRUPTED_GOTO(i == 1, done);
@@@ -5073,12 -5079,13 +5129,20 @@@ xfs_bunmapi
  	    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {
  		XFS_ERROR_REPORT("xfs_bunmapi", XFS_ERRLEVEL_LOW,
  				 ip->i_mount);
++<<<<<<< HEAD
 +		return XFS_ERROR(EFSCORRUPTED);
 +	}
 +	mp = ip->i_mount;
 +	if (XFS_FORCED_SHUTDOWN(mp))
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EFSCORRUPTED;
+ 	}
+ 	mp = ip->i_mount;
+ 	if (XFS_FORCED_SHUTDOWN(mp))
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
 -	ASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));
  	ASSERT(len > 0);
  	ASSERT(nexts >= 0);
  
@@@ -5321,7 -5328,7 +5385,11 @@@
  		    del.br_startoff > got.br_startoff &&
  		    del.br_startoff + del.br_blockcount <
  		    got.br_startoff + got.br_blockcount) {
++<<<<<<< HEAD
 +			error = XFS_ERROR(ENOSPC);
++=======
+ 			error = -ENOSPC;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			goto error0;
  		}
  		error = xfs_bmap_del_extent(ip, tp, &lastx, flist, cur, &del,
@@@ -5402,3 -5409,201 +5470,204 @@@ error0
  	}
  	return error;
  }
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * Shift extent records to the left to cover a hole.
+  *
+  * The maximum number of extents to be shifted in a single operation
+  * is @num_exts, and @current_ext keeps track of the current extent
+  * index we have shifted. @offset_shift_fsb is the length by which each
+  * extent is shifted. If there is no hole to shift the extents
+  * into, this will be considered invalid operation and we abort immediately.
+  */
+ int
+ xfs_bmap_shift_extents(
+ 	struct xfs_trans	*tp,
+ 	struct xfs_inode	*ip,
+ 	int			*done,
+ 	xfs_fileoff_t		start_fsb,
+ 	xfs_fileoff_t		offset_shift_fsb,
+ 	xfs_extnum_t		*current_ext,
+ 	xfs_fsblock_t		*firstblock,
+ 	struct xfs_bmap_free	*flist,
+ 	int			num_exts)
+ {
+ 	struct xfs_btree_cur		*cur;
+ 	struct xfs_bmbt_rec_host	*gotp;
+ 	struct xfs_bmbt_irec            got;
+ 	struct xfs_bmbt_irec		left;
+ 	struct xfs_mount		*mp = ip->i_mount;
+ 	struct xfs_ifork		*ifp;
+ 	xfs_extnum_t			nexts = 0;
+ 	xfs_fileoff_t			startoff;
+ 	int				error = 0;
+ 	int				i;
+ 	int				whichfork = XFS_DATA_FORK;
+ 	int				logflags;
+ 	xfs_filblks_t			blockcount = 0;
+ 	int				total_extents;
+ 
+ 	if (unlikely(XFS_TEST_ERROR(
+ 	    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&
+ 	     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),
+ 	     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {
+ 		XFS_ERROR_REPORT("xfs_bmap_shift_extents",
+ 				 XFS_ERRLEVEL_LOW, mp);
+ 		return -EFSCORRUPTED;
+ 	}
+ 
+ 	if (XFS_FORCED_SHUTDOWN(mp))
+ 		return -EIO;
+ 
+ 	ASSERT(current_ext != NULL);
+ 
+ 	ifp = XFS_IFORK_PTR(ip, whichfork);
+ 	if (!(ifp->if_flags & XFS_IFEXTENTS)) {
+ 		/* Read in all the extents */
+ 		error = xfs_iread_extents(tp, ip, whichfork);
+ 		if (error)
+ 			return error;
+ 	}
+ 
+ 	/*
+ 	 * If *current_ext is 0, we would need to lookup the extent
+ 	 * from where we would start shifting and store it in gotp.
+ 	 */
+ 	if (!*current_ext) {
+ 		gotp = xfs_iext_bno_to_ext(ifp, start_fsb, current_ext);
+ 		/*
+ 		 * gotp can be null in 2 cases: 1) if there are no extents
+ 		 * or 2) start_fsb lies in a hole beyond which there are
+ 		 * no extents. Either way, we are done.
+ 		 */
+ 		if (!gotp) {
+ 			*done = 1;
+ 			return 0;
+ 		}
+ 	}
+ 
+ 	/* We are going to change core inode */
+ 	logflags = XFS_ILOG_CORE;
+ 	if (ifp->if_flags & XFS_IFBROOT) {
+ 		cur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);
+ 		cur->bc_private.b.firstblock = *firstblock;
+ 		cur->bc_private.b.flist = flist;
+ 		cur->bc_private.b.flags = 0;
+ 	} else {
+ 		cur = NULL;
+ 		logflags |= XFS_ILOG_DEXT;
+ 	}
+ 
+ 	/*
+ 	 * There may be delalloc extents in the data fork before the range we
+ 	 * are collapsing out, so we cannot
+ 	 * use the count of real extents here. Instead we have to calculate it
+ 	 * from the incore fork.
+ 	 */
+ 	total_extents = ifp->if_bytes / sizeof(xfs_bmbt_rec_t);
+ 	while (nexts++ < num_exts && *current_ext < total_extents) {
+ 
+ 		gotp = xfs_iext_get_ext(ifp, *current_ext);
+ 		xfs_bmbt_get_all(gotp, &got);
+ 		startoff = got.br_startoff - offset_shift_fsb;
+ 
+ 		/*
+ 		 * Before shifting extent into hole, make sure that the hole
+ 		 * is large enough to accomodate the shift.
+ 		 */
+ 		if (*current_ext) {
+ 			xfs_bmbt_get_all(xfs_iext_get_ext(ifp,
+ 						*current_ext - 1), &left);
+ 
+ 			if (startoff < left.br_startoff + left.br_blockcount)
+ 				error = -EINVAL;
+ 		} else if (offset_shift_fsb > got.br_startoff) {
+ 			/*
+ 			 * When first extent is shifted, offset_shift_fsb
+ 			 * should be less than the stating offset of
+ 			 * the first extent.
+ 			 */
+ 			error = -EINVAL;
+ 		}
+ 
+ 		if (error)
+ 			goto del_cursor;
+ 
+ 		if (cur) {
+ 			error = xfs_bmbt_lookup_eq(cur, got.br_startoff,
+ 						   got.br_startblock,
+ 						   got.br_blockcount,
+ 						   &i);
+ 			if (error)
+ 				goto del_cursor;
+ 			XFS_WANT_CORRUPTED_GOTO(i == 1, del_cursor);
+ 		}
+ 
+ 		/* Check if we can merge 2 adjacent extents */
+ 		if (*current_ext &&
+ 		    left.br_startoff + left.br_blockcount == startoff &&
+ 		    left.br_startblock + left.br_blockcount ==
+ 				got.br_startblock &&
+ 		    left.br_state == got.br_state &&
+ 		    left.br_blockcount + got.br_blockcount <= MAXEXTLEN) {
+ 			blockcount = left.br_blockcount +
+ 				got.br_blockcount;
+ 			xfs_iext_remove(ip, *current_ext, 1, 0);
+ 			if (cur) {
+ 				error = xfs_btree_delete(cur, &i);
+ 				if (error)
+ 					goto del_cursor;
+ 				XFS_WANT_CORRUPTED_GOTO(i == 1, del_cursor);
+ 			}
+ 			XFS_IFORK_NEXT_SET(ip, whichfork,
+ 				XFS_IFORK_NEXTENTS(ip, whichfork) - 1);
+ 			gotp = xfs_iext_get_ext(ifp, --*current_ext);
+ 			xfs_bmbt_get_all(gotp, &got);
+ 
+ 			/* Make cursor point to the extent we will update */
+ 			if (cur) {
+ 				error = xfs_bmbt_lookup_eq(cur, got.br_startoff,
+ 							   got.br_startblock,
+ 							   got.br_blockcount,
+ 							   &i);
+ 				if (error)
+ 					goto del_cursor;
+ 				XFS_WANT_CORRUPTED_GOTO(i == 1, del_cursor);
+ 			}
+ 
+ 			xfs_bmbt_set_blockcount(gotp, blockcount);
+ 			got.br_blockcount = blockcount;
+ 		} else {
+ 			/* We have to update the startoff */
+ 			xfs_bmbt_set_startoff(gotp, startoff);
+ 			got.br_startoff = startoff;
+ 		}
+ 
+ 		if (cur) {
+ 			error = xfs_bmbt_update(cur, got.br_startoff,
+ 						got.br_startblock,
+ 						got.br_blockcount,
+ 						got.br_state);
+ 			if (error)
+ 				goto del_cursor;
+ 		}
+ 
+ 		(*current_ext)++;
+ 		total_extents = ifp->if_bytes / sizeof(xfs_bmbt_rec_t);
+ 	}
+ 
+ 	/* Check if we are done */
+ 	if (*current_ext == total_extents)
+ 		*done = 1;
+ 
+ del_cursor:
+ 	if (cur)
+ 		xfs_btree_del_cursor(cur,
+ 			error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);
+ 
+ 	xfs_trans_log_inode(tp, ip, logflags);
+ 	return error;
+ }
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
diff --cc fs/xfs/libxfs/xfs_bmap_btree.c
index 948836c4fd90,a388de4ceaa1..000000000000
--- a/fs/xfs/libxfs/xfs_bmap_btree.c
+++ b/fs/xfs/libxfs/xfs_bmap_btree.c
@@@ -554,7 -554,7 +554,11 @@@ xfs_bmbt_alloc_block
  	args.minlen = args.maxlen = args.prod = 1;
  	args.wasdel = cur->bc_private.b.flags & XFS_BTCUR_BPRV_WASDEL;
  	if (!args.wasdel && xfs_trans_get_block_res(args.tp) == 0) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(ENOSPC);
++=======
+ 		error = -ENOSPC;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto error0;
  	}
  	error = xfs_alloc_vextent(&args);
diff --cc fs/xfs/libxfs/xfs_btree.c
index cf893bc1e373,0097c42f1f10..000000000000
--- a/fs/xfs/libxfs/xfs_btree.c
+++ b/fs/xfs/libxfs/xfs_btree.c
@@@ -92,7 -91,7 +92,11 @@@ xfs_btree_check_lblock
  		if (bp)
  			trace_xfs_btree_corrupt(bp, _RET_IP_);
  		XFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_LOW, mp);
++<<<<<<< HEAD
 +		return XFS_ERROR(EFSCORRUPTED);
++=======
+ 		return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	return 0;
  }
@@@ -140,7 -139,7 +144,11 @@@ xfs_btree_check_sblock
  		if (bp)
  			trace_xfs_btree_corrupt(bp, _RET_IP_);
  		XFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_LOW, mp);
++<<<<<<< HEAD
 +		return XFS_ERROR(EFSCORRUPTED);
++=======
+ 		return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	return 0;
  }
diff --cc fs/xfs/libxfs/xfs_da_btree.c
index dfe5cf38eaed,8d809873525b..000000000000
--- a/fs/xfs/libxfs/xfs_da_btree.c
+++ b/fs/xfs/libxfs/xfs_da_btree.c
@@@ -1578,9 -1579,9 +1578,13 @@@ xfs_da3_node_lookup_int
  			args->blkno = blk->blkno;
  		} else {
  			ASSERT(0);
++<<<<<<< HEAD
 +			return XFS_ERROR(EFSCORRUPTED);
++=======
+ 			return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
- 		if (((retval == ENOENT) || (retval == ENOATTR)) &&
+ 		if (((retval == -ENOENT) || (retval == -ENOATTR)) &&
  		    (blk->hashval == args->hashval)) {
  			error = xfs_da3_path_shift(state, &state->path, 1, 1,
  							 &retval);
@@@ -1590,7 -1591,7 +1594,11 @@@
  				continue;
  			} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {
  				/* path_shift() gives ENOENT */
++<<<<<<< HEAD
 +				retval = XFS_ERROR(ENOATTR);
++=======
+ 				retval = -ENOATTR;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			}
  		}
  		break;
@@@ -1858,7 -1859,7 +1866,11 @@@ xfs_da3_path_shift
  		}
  	}
  	if (level < 0) {
++<<<<<<< HEAD
 +		*result = XFS_ERROR(ENOENT);	/* we're out of our tree */
++=======
+ 		*result = -ENOENT;	/* we're out of our tree */
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		ASSERT(args->op_flags & XFS_DA_OP_OKNOENT);
  		return 0;
  	}
@@@ -2067,7 -2068,7 +2079,11 @@@ xfs_da_grow_inode_int
  	if (got != count || mapp[0].br_startoff != *bno ||
  	    mapp[mapi - 1].br_startoff + mapp[mapi - 1].br_blockcount !=
  	    *bno + count) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(ENOSPC);
++=======
+ 		error = -ENOSPC;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto out_free_map;
  	}
  
@@@ -2165,7 -2158,7 +2181,11 @@@ xfs_da3_swap_lastblock
  	if (unlikely(lastoff == 0)) {
  		XFS_ERROR_REPORT("xfs_da_swap_lastblock(1)", XFS_ERRLEVEL_LOW,
  				 mp);
++<<<<<<< HEAD
 +		return XFS_ERROR(EFSCORRUPTED);
++=======
+ 		return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	/*
  	 * Read the last block in the btree space.
@@@ -2216,7 -2209,7 +2236,11 @@@
  		    sib_info->magic != dead_info->magic)) {
  			XFS_ERROR_REPORT("xfs_da_swap_lastblock(2)",
  					 XFS_ERRLEVEL_LOW, mp);
++<<<<<<< HEAD
 +			error = XFS_ERROR(EFSCORRUPTED);
++=======
+ 			error = -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			goto done;
  		}
  		sib_info->forw = cpu_to_be32(dead_blkno);
@@@ -2238,7 -2231,7 +2262,11 @@@
  		       sib_info->magic != dead_info->magic)) {
  			XFS_ERROR_REPORT("xfs_da_swap_lastblock(3)",
  					 XFS_ERRLEVEL_LOW, mp);
++<<<<<<< HEAD
 +			error = XFS_ERROR(EFSCORRUPTED);
++=======
+ 			error = -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			goto done;
  		}
  		sib_info->back = cpu_to_be32(dead_blkno);
@@@ -2261,7 -2254,7 +2289,11 @@@
  		if (level >= 0 && level != par_hdr.level + 1) {
  			XFS_ERROR_REPORT("xfs_da_swap_lastblock(4)",
  					 XFS_ERRLEVEL_LOW, mp);
++<<<<<<< HEAD
 +			error = XFS_ERROR(EFSCORRUPTED);
++=======
+ 			error = -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			goto done;
  		}
  		level = par_hdr.level;
@@@ -2274,7 -2267,7 +2306,11 @@@
  		if (entno == par_hdr.count) {
  			XFS_ERROR_REPORT("xfs_da_swap_lastblock(5)",
  					 XFS_ERRLEVEL_LOW, mp);
++<<<<<<< HEAD
 +			error = XFS_ERROR(EFSCORRUPTED);
++=======
+ 			error = -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			goto done;
  		}
  		par_blkno = be32_to_cpu(btree[entno].before);
@@@ -2301,7 -2294,7 +2337,11 @@@
  		if (unlikely(par_blkno == 0)) {
  			XFS_ERROR_REPORT("xfs_da_swap_lastblock(6)",
  					 XFS_ERRLEVEL_LOW, mp);
++<<<<<<< HEAD
 +			error = XFS_ERROR(EFSCORRUPTED);
++=======
+ 			error = -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			goto done;
  		}
  		error = xfs_da3_node_read(tp, dp, par_blkno, -1, &par_buf, w);
@@@ -2312,7 -2305,7 +2352,11 @@@
  		if (par_hdr.level != level) {
  			XFS_ERROR_REPORT("xfs_da_swap_lastblock(7)",
  					 XFS_ERRLEVEL_LOW, mp);
++<<<<<<< HEAD
 +			error = XFS_ERROR(EFSCORRUPTED);
++=======
+ 			error = -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			goto done;
  		}
  		btree = dp->d_ops->node_tree_p(par_node);
@@@ -2507,8 -2500,8 +2551,13 @@@ xfs_dabuf_map
  	}
  
  	if (!xfs_da_map_covers_blocks(nirecs, irecs, bno, nfsb)) {
++<<<<<<< HEAD
 +		error = mappedbno == -2 ? -1 : XFS_ERROR(EFSCORRUPTED);
 +		if (unlikely(error == EFSCORRUPTED)) {
++=======
+ 		error = mappedbno == -2 ? -1 : -EFSCORRUPTED;
+ 		if (unlikely(error == -EFSCORRUPTED)) {
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			if (xfs_error_level >= XFS_ERRLEVEL_LOW) {
  				int i;
  				xfs_alert(mp, "%s: bno %lld dir: inode %lld",
@@@ -2568,7 -2561,7 +2617,11 @@@ xfs_da_get_buf
  
  	bp = xfs_trans_get_buf_map(trans, dp->i_mount->m_ddev_targp,
  				    mapp, nmap, 0);
++<<<<<<< HEAD
 +	error = bp ? bp->b_error : XFS_ERROR(EIO);
++=======
+ 	error = bp ? bp->b_error : -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	if (error) {
  		xfs_trans_brelse(trans, bp);
  		goto out_free;
diff --cc fs/xfs/libxfs/xfs_dir2.c
index 94787d4498db,6cef22152fd6..000000000000
--- a/fs/xfs/libxfs/xfs_dir2.c
+++ b/fs/xfs/libxfs/xfs_dir2.c
@@@ -205,7 -202,7 +205,11 @@@ xfs_dir_ino_validate
  		xfs_warn(mp, "Invalid inode number 0x%Lx",
  				(unsigned long long) ino);
  		XFS_ERROR_REPORT("xfs_dir_ino_validate", XFS_ERRLEVEL_LOW, mp);
++<<<<<<< HEAD
 +		return XFS_ERROR(EFSCORRUPTED);
++=======
+ 		return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	return 0;
  }
diff --cc fs/xfs/libxfs/xfs_dir2_block.c
index 525993902ddb,9628ceccfa02..000000000000
--- a/fs/xfs/libxfs/xfs_dir2_block.c
+++ b/fs/xfs/libxfs/xfs_dir2_block.c
@@@ -393,7 -392,7 +393,11 @@@ xfs_dir2_block_addname
  	if (args->op_flags & XFS_DA_OP_JUSTCHECK) {
  		xfs_trans_brelse(tp, bp);
  		if (!dup)
++<<<<<<< HEAD
 +			return XFS_ERROR(ENOSPC);
++=======
+ 			return -ENOSPC;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		return 0;
  	}
  
@@@ -403,7 -402,7 +407,11 @@@
  	if (!dup) {
  		/* Don't have a space reservation: return no-space.  */
  		if (args->total == 0)
++<<<<<<< HEAD
 +			return XFS_ERROR(ENOSPC);
++=======
+ 			return -ENOSPC;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		/*
  		 * Convert to the next larger format.
  		 * Then add the new entry in that format.
@@@ -703,7 -703,7 +711,11 @@@ xfs_dir2_block_lookup_int
  		if (low > high) {
  			ASSERT(args->op_flags & XFS_DA_OP_OKNOENT);
  			xfs_trans_brelse(tp, bp);
++<<<<<<< HEAD
 +			return XFS_ERROR(ENOENT);
++=======
+ 			return -ENOENT;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  	}
  	/*
@@@ -751,7 -751,7 +763,11 @@@
  	 * No match, release the buffer and return ENOENT.
  	 */
  	xfs_trans_brelse(tp, bp);
++<<<<<<< HEAD
 +	return XFS_ERROR(ENOENT);
++=======
+ 	return -ENOENT;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  }
  
  /*
@@@ -1089,7 -1091,7 +1105,11 @@@ xfs_dir2_sf_to_block
  	 */
  	if (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {
  		ASSERT(XFS_FORCED_SHUTDOWN(mp));
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	oldsfp = (xfs_dir2_sf_hdr_t *)ifp->if_u1.if_data;
diff --cc fs/xfs/libxfs/xfs_dir2_leaf.c
index 4d5097750d39,a19174eb3cb2..000000000000
--- a/fs/xfs/libxfs/xfs_dir2_leaf.c
+++ b/fs/xfs/libxfs/xfs_dir2_leaf.c
@@@ -729,7 -731,7 +729,11 @@@ xfs_dir2_leaf_addname
  		if ((args->op_flags & XFS_DA_OP_JUSTCHECK) ||
  							args->total == 0) {
  			xfs_trans_brelse(tp, lbp);
++<<<<<<< HEAD
 +			return XFS_ERROR(ENOSPC);
++=======
+ 			return -ENOSPC;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  		/*
  		 * Convert to node form.
@@@ -753,7 -755,7 +757,11 @@@
  	 */
  	if (args->op_flags & XFS_DA_OP_JUSTCHECK) {
  		xfs_trans_brelse(tp, lbp);
++<<<<<<< HEAD
 +		return use_block == -1 ? XFS_ERROR(ENOSPC) : 0;
++=======
+ 		return use_block == -1 ? -ENOSPC : 0;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	/*
  	 * If no allocations are allowed, return now before we've
@@@ -761,7 -763,7 +769,11 @@@
  	 */
  	if (args->total == 0 && use_block == -1) {
  		xfs_trans_brelse(tp, lbp);
++<<<<<<< HEAD
 +		return XFS_ERROR(ENOSPC);
++=======
+ 		return -ENOSPC;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	/*
  	 * Need to compact the leaf entries, removing stale ones.
@@@ -1327,7 -1333,7 +1339,11 @@@ xfs_dir2_leaf_lookup_int
  	if (dbp)
  		xfs_trans_brelse(tp, dbp);
  	xfs_trans_brelse(tp, lbp);
++<<<<<<< HEAD
 +	return XFS_ERROR(ENOENT);
++=======
+ 	return -ENOENT;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  }
  
  /*
diff --cc fs/xfs/libxfs/xfs_dir2_node.c
index 697fc13c6486,2ae6ac2c11ae..000000000000
--- a/fs/xfs/libxfs/xfs_dir2_node.c
+++ b/fs/xfs/libxfs/xfs_dir2_node.c
@@@ -406,7 -406,7 +406,11 @@@ xfs_dir2_leafn_add
  	 * into other peoples memory
  	 */
  	if (index < 0)
++<<<<<<< HEAD
 +		return XFS_ERROR(EFSCORRUPTED);
++=======
+ 		return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	/*
  	 * If there are already the maximum number of leaf entries in
@@@ -415,9 -415,9 +419,13 @@@
  	 * a compact.
  	 */
  
 -	if (leafhdr.count == dp->d_ops->leaf_max_ents(args->geo)) {
 +	if (leafhdr.count == dp->d_ops->leaf_max_ents(mp)) {
  		if (!leafhdr.stale)
++<<<<<<< HEAD
 +			return XFS_ERROR(ENOSPC);
++=======
+ 			return -ENOSPC;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		compact = leafhdr.stale > 1;
  	} else
  		compact = 0;
@@@ -626,7 -629,7 +634,11 @@@ xfs_dir2_leafn_lookup_for_addname
  							XFS_ERRLEVEL_LOW, mp);
  				if (curfdb != newfdb)
  					xfs_trans_brelse(tp, curbp);
++<<<<<<< HEAD
 +				return XFS_ERROR(EFSCORRUPTED);
++=======
+ 				return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			}
  			curfdb = newfdb;
  			if (be16_to_cpu(bests[fi]) >= length)
@@@ -657,7 -660,7 +669,11 @@@ out
  	 * Return the index, that will be the insertion point.
  	 */
  	*indexp = index;
++<<<<<<< HEAD
 +	return XFS_ERROR(ENOENT);
++=======
+ 	return -ENOENT;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  }
  
  /*
@@@ -783,7 -789,7 +799,11 @@@ xfs_dir2_leafn_lookup_for_entry
  			curbp->b_ops = &xfs_dir3_data_buf_ops;
  			xfs_trans_buf_set_type(tp, curbp, XFS_BLFT_DIR_DATA_BUF);
  			if (cmp == XFS_CMP_EXACT)
++<<<<<<< HEAD
 +				return XFS_ERROR(EEXIST);
++=======
+ 				return -EEXIST;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  	}
  	ASSERT(index == leafhdr.count || (args->op_flags & XFS_DA_OP_OKNOENT));
@@@ -806,7 -812,7 +826,11 @@@
  		state->extravalid = 0;
  	}
  	*indexp = index;
++<<<<<<< HEAD
 +	return XFS_ERROR(ENOENT);
++=======
+ 	return -ENOENT;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  }
  
  /*
@@@ -1812,7 -1815,7 +1836,11 @@@ xfs_dir2_node_addname_int
  		 * Not allowed to allocate, return failure.
  		 */
  		if ((args->op_flags & XFS_DA_OP_JUSTCHECK) || args->total == 0)
++<<<<<<< HEAD
 +			return XFS_ERROR(ENOSPC);
++=======
+ 			return -ENOSPC;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  		/*
  		 * Allocate and initialize the new data block.
@@@ -1872,7 -1876,7 +1900,11 @@@
  				}
  				XFS_ERROR_REPORT("xfs_dir2_node_addname_int",
  						 XFS_ERRLEVEL_LOW, mp);
++<<<<<<< HEAD
 +				return XFS_ERROR(EFSCORRUPTED);
++=======
+ 				return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			}
  
  			/*
diff --cc fs/xfs/libxfs/xfs_dir2_sf.c
index 7aab8ec117ad,8f4f26af35e1..000000000000
--- a/fs/xfs/libxfs/xfs_dir2_sf.c
+++ b/fs/xfs/libxfs/xfs_dir2_sf.c
@@@ -247,9 -249,9 +247,9 @@@ xfs_dir2_block_to_sf
  
  	/* now we are done with the block, we can shrink the inode */
  	logflags = XFS_ILOG_CORE;
 -	error = xfs_dir2_shrink_inode(args, args->geo->datablk, bp);
 +	error = xfs_dir2_shrink_inode(args, mp->m_dirdatablk, bp);
  	if (error) {
- 		ASSERT(error != ENOSPC);
+ 		ASSERT(error != -ENOSPC);
  		goto out;
  	}
  
@@@ -305,7 -307,7 +305,11 @@@ xfs_dir2_sf_addname
  	 */
  	if (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {
  		ASSERT(XFS_FORCED_SHUTDOWN(dp->i_mount));
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	ASSERT(dp->i_df.if_bytes == dp->i_d.di_size);
  	ASSERT(dp->i_df.if_u1.if_data != NULL);
@@@ -343,7 -345,7 +347,11 @@@
  		 * Just checking or no space reservation, it doesn't fit.
  		 */
  		if ((args->op_flags & XFS_DA_OP_JUSTCHECK) || args->total == 0)
++<<<<<<< HEAD
 +			return XFS_ERROR(ENOSPC);
++=======
+ 			return -ENOSPC;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		/*
  		 * Convert to block form then add the name.
  		 */
@@@ -736,7 -738,7 +744,11 @@@ xfs_dir2_sf_lookup
  	 */
  	if (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {
  		ASSERT(XFS_FORCED_SHUTDOWN(dp->i_mount));
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	ASSERT(dp->i_df.if_bytes == dp->i_d.di_size);
  	ASSERT(dp->i_df.if_u1.if_data != NULL);
@@@ -749,7 -751,7 +761,11 @@@
  		args->inumber = dp->i_ino;
  		args->cmpresult = XFS_CMP_EXACT;
  		args->filetype = XFS_DIR3_FT_DIR;
++<<<<<<< HEAD
 +		return XFS_ERROR(EEXIST);
++=======
+ 		return -EEXIST;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	/*
  	 * Special case for ..
@@@ -759,7 -761,7 +775,11 @@@
  		args->inumber = dp->d_ops->sf_get_parent_ino(sfp);
  		args->cmpresult = XFS_CMP_EXACT;
  		args->filetype = XFS_DIR3_FT_DIR;
++<<<<<<< HEAD
 +		return XFS_ERROR(EEXIST);
++=======
+ 		return -EEXIST;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	/*
  	 * Loop over all the entries trying to match ours.
@@@ -779,20 -781,20 +799,28 @@@
  			args->inumber = dp->d_ops->sf_get_ino(sfp, sfep);
  			args->filetype = dp->d_ops->sf_get_ftype(sfep);
  			if (cmp == XFS_CMP_EXACT)
++<<<<<<< HEAD
 +				return XFS_ERROR(EEXIST);
++=======
+ 				return -EEXIST;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			ci_sfep = sfep;
  		}
  	}
  	ASSERT(args->op_flags & XFS_DA_OP_OKNOENT);
  	/*
  	 * Here, we can only be doing a lookup (not a rename or replace).
- 	 * If a case-insensitive match was not found, return ENOENT.
+ 	 * If a case-insensitive match was not found, return -ENOENT.
  	 */
  	if (!ci_sfep)
++<<<<<<< HEAD
 +		return XFS_ERROR(ENOENT);
++=======
+ 		return -ENOENT;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	/* otherwise process the CI match as required by the caller */
  	error = xfs_dir_cilookup_result(args, ci_sfep->name, ci_sfep->namelen);
 -	return error;
 +	return XFS_ERROR(error);
  }
  
  /*
@@@ -822,7 -824,7 +850,11 @@@ xfs_dir2_sf_removename
  	 */
  	if (oldsize < offsetof(xfs_dir2_sf_hdr_t, parent)) {
  		ASSERT(XFS_FORCED_SHUTDOWN(dp->i_mount));
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	ASSERT(dp->i_df.if_bytes == oldsize);
  	ASSERT(dp->i_df.if_u1.if_data != NULL);
@@@ -845,7 -847,7 +877,11 @@@
  	 * Didn't find it.
  	 */
  	if (i == sfp->count)
++<<<<<<< HEAD
 +		return XFS_ERROR(ENOENT);
++=======
+ 		return -ENOENT;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	/*
  	 * Calculate sizes.
  	 */
@@@ -912,7 -914,7 +948,11 @@@ xfs_dir2_sf_replace
  	 */
  	if (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {
  		ASSERT(XFS_FORCED_SHUTDOWN(dp->i_mount));
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	ASSERT(dp->i_df.if_bytes == dp->i_d.di_size);
  	ASSERT(dp->i_df.if_u1.if_data != NULL);
@@@ -988,7 -990,7 +1028,11 @@@
  			if (i8elevated)
  				xfs_dir2_sf_toino4(args);
  #endif
++<<<<<<< HEAD
 +			return XFS_ERROR(ENOENT);
++=======
+ 			return -ENOENT;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  	}
  #if XFS_BIG_INUMS
diff --cc fs/xfs/libxfs/xfs_ialloc.c
index 0e419f1476a5,b62771f1f4b5..000000000000
--- a/fs/xfs/libxfs/xfs_ialloc.c
+++ b/fs/xfs/libxfs/xfs_ialloc.c
@@@ -382,7 -380,7 +382,11 @@@ xfs_ialloc_ag_alloc
  	newlen = args.mp->m_ialloc_inos;
  	if (args.mp->m_maxicount &&
  	    args.mp->m_sb.sb_icount + newlen > args.mp->m_maxicount)
++<<<<<<< HEAD
 +		return XFS_ERROR(ENOSPC);
++=======
+ 		return -ENOSPC;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	args.minlen = args.maxlen = args.mp->m_ialloc_blks;
  	/*
  	 * First try to allocate inodes contiguous with the last-allocated
@@@ -1684,7 -1682,7 +1688,11 @@@ xfs_difree
  		xfs_warn(mp, "%s: agno >= mp->m_sb.sb_agcount (%d >= %d).",
  			__func__, agno, mp->m_sb.sb_agcount);
  		ASSERT(0);
++<<<<<<< HEAD
 +		return XFS_ERROR(EINVAL);
++=======
+ 		return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	agino = XFS_INO_TO_AGINO(mp, inode);
  	if (inode != XFS_AGINO_TO_INO(mp, agno, agino))  {
@@@ -1692,14 -1690,14 +1700,22 @@@
  			__func__, (unsigned long long)inode,
  			(unsigned long long)XFS_AGINO_TO_INO(mp, agno, agino));
  		ASSERT(0);
++<<<<<<< HEAD
 +		return XFS_ERROR(EINVAL);
++=======
+ 		return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	agbno = XFS_AGINO_TO_AGBNO(mp, agino);
  	if (agbno >= mp->m_sb.sb_agblocks)  {
  		xfs_warn(mp, "%s: agbno >= mp->m_sb.sb_agblocks (%d >= %d).",
  			__func__, agbno, mp->m_sb.sb_agblocks);
  		ASSERT(0);
++<<<<<<< HEAD
 +		return XFS_ERROR(EINVAL);
++=======
+ 		return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	/*
  	 * Get the allocation group header.
@@@ -1831,7 -1829,7 +1847,11 @@@ xfs_imap
  		 * as they can be invalid without implying corruption.
  		 */
  		if (flags & XFS_IGET_UNTRUSTED)
++<<<<<<< HEAD
 +			return XFS_ERROR(EINVAL);
++=======
+ 			return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		if (agno >= mp->m_sb.sb_agcount) {
  			xfs_alert(mp,
  				"%s: agno (%d) >= mp->m_sb.sb_agcount (%d)",
@@@ -1851,7 -1849,7 +1871,11 @@@
  		}
  		xfs_stack_trace();
  #endif /* DEBUG */
++<<<<<<< HEAD
 +		return XFS_ERROR(EINVAL);
++=======
+ 		return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	blks_per_cluster = xfs_icluster_size_fsb(mp);
@@@ -1924,7 -1922,7 +1948,11 @@@ out_map
  			__func__, (unsigned long long) imap->im_blkno,
  			(unsigned long long) imap->im_len,
  			XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks));
++<<<<<<< HEAD
 +		return XFS_ERROR(EINVAL);
++=======
+ 		return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	return 0;
  }
diff --cc fs/xfs/libxfs/xfs_inode_buf.c
index 24e993996bdc,f18fd2da49f7..000000000000
--- a/fs/xfs/libxfs/xfs_inode_buf.c
+++ b/fs/xfs/libxfs/xfs_inode_buf.c
@@@ -179,9 -179,9 +179,13 @@@ xfs_imap_to_bp
  			return error;
  		}
  
- 		if (error == EFSCORRUPTED &&
+ 		if (error == -EFSCORRUPTED &&
  		    (iget_flags & XFS_IGET_UNTRUSTED))
++<<<<<<< HEAD
 +			return XFS_ERROR(EINVAL);
++=======
+ 			return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  		xfs_warn(mp, "%s: xfs_trans_read_buf() returned error %d.",
  			__func__, error);
@@@ -390,7 -390,7 +394,11 @@@ xfs_iread
  				__func__, ip->i_ino);
  
  		XFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp, dip);
++<<<<<<< HEAD
 +		error = XFS_ERROR(EFSCORRUPTED);
++=======
+ 		error = -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto out_brelse;
  	}
  
diff --cc fs/xfs/libxfs/xfs_inode_fork.c
index 4e77a641dc95,8ac9411bcf2a..000000000000
--- a/fs/xfs/libxfs/xfs_inode_fork.c
+++ b/fs/xfs/libxfs/xfs_inode_fork.c
@@@ -102,7 -102,7 +102,11 @@@ xfs_iformat_fork
  				be64_to_cpu(dip->di_nblocks));
  		XFS_CORRUPTION_ERROR("xfs_iformat(1)", XFS_ERRLEVEL_LOW,
  				     ip->i_mount, dip);
++<<<<<<< HEAD
 +		return XFS_ERROR(EFSCORRUPTED);
++=======
+ 		return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	if (unlikely(dip->di_forkoff > ip->i_mount->m_sb.sb_inodesize)) {
@@@ -111,7 -111,7 +115,11 @@@
  			dip->di_forkoff);
  		XFS_CORRUPTION_ERROR("xfs_iformat(2)", XFS_ERRLEVEL_LOW,
  				     ip->i_mount, dip);
++<<<<<<< HEAD
 +		return XFS_ERROR(EFSCORRUPTED);
++=======
+ 		return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	if (unlikely((ip->i_d.di_flags & XFS_DIFLAG_REALTIME) &&
@@@ -121,7 -121,7 +129,11 @@@
  			ip->i_ino);
  		XFS_CORRUPTION_ERROR("xfs_iformat(realtime)",
  				     XFS_ERRLEVEL_LOW, ip->i_mount, dip);
++<<<<<<< HEAD
 +		return XFS_ERROR(EFSCORRUPTED);
++=======
+ 		return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	switch (ip->i_d.di_mode & S_IFMT) {
@@@ -132,7 -132,7 +144,11 @@@
  		if (unlikely(dip->di_format != XFS_DINODE_FMT_DEV)) {
  			XFS_CORRUPTION_ERROR("xfs_iformat(3)", XFS_ERRLEVEL_LOW,
  					      ip->i_mount, dip);
++<<<<<<< HEAD
 +			return XFS_ERROR(EFSCORRUPTED);
++=======
+ 			return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  		ip->i_d.di_size = 0;
  		ip->i_df.if_u2.if_rdev = xfs_dinode_get_rdev(dip);
@@@ -153,7 -153,7 +169,11 @@@
  				XFS_CORRUPTION_ERROR("xfs_iformat(4)",
  						     XFS_ERRLEVEL_LOW,
  						     ip->i_mount, dip);
++<<<<<<< HEAD
 +				return XFS_ERROR(EFSCORRUPTED);
++=======
+ 				return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			}
  
  			di_size = be64_to_cpu(dip->di_size);
@@@ -166,7 -166,7 +186,11 @@@
  				XFS_CORRUPTION_ERROR("xfs_iformat(5)",
  						     XFS_ERRLEVEL_LOW,
  						     ip->i_mount, dip);
++<<<<<<< HEAD
 +				return XFS_ERROR(EFSCORRUPTED);
++=======
+ 				return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			}
  
  			size = (int)di_size;
@@@ -181,13 -181,13 +205,21 @@@
  		default:
  			XFS_ERROR_REPORT("xfs_iformat(6)", XFS_ERRLEVEL_LOW,
  					 ip->i_mount);
++<<<<<<< HEAD
 +			return XFS_ERROR(EFSCORRUPTED);
++=======
+ 			return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  		break;
  
  	default:
  		XFS_ERROR_REPORT("xfs_iformat(7)", XFS_ERRLEVEL_LOW, ip->i_mount);
++<<<<<<< HEAD
 +		return XFS_ERROR(EFSCORRUPTED);
++=======
+ 		return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	if (error) {
  		return error;
@@@ -211,7 -211,7 +243,11 @@@
  			XFS_CORRUPTION_ERROR("xfs_iformat(8)",
  					     XFS_ERRLEVEL_LOW,
  					     ip->i_mount, dip);
++<<<<<<< HEAD
 +			return XFS_ERROR(EFSCORRUPTED);
++=======
+ 			return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  
  		error = xfs_iformat_local(ip, dip, XFS_ATTR_FORK, size);
@@@ -223,7 -223,7 +259,11 @@@
  		error = xfs_iformat_btree(ip, dip, XFS_ATTR_FORK);
  		break;
  	default:
++<<<<<<< HEAD
 +		error = XFS_ERROR(EFSCORRUPTED);
++=======
+ 		error = -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		break;
  	}
  	if (error) {
@@@ -266,7 -266,7 +306,11 @@@ xfs_iformat_local
  			XFS_DFORK_SIZE(dip, ip->i_mount, whichfork));
  		XFS_CORRUPTION_ERROR("xfs_iformat_local", XFS_ERRLEVEL_LOW,
  				     ip->i_mount, dip);
++<<<<<<< HEAD
 +		return XFS_ERROR(EFSCORRUPTED);
++=======
+ 		return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	ifp = XFS_IFORK_PTR(ip, whichfork);
  	real_size = 0;
@@@ -322,7 -322,7 +366,11 @@@ xfs_iformat_extents
  			(unsigned long long) ip->i_ino, nex);
  		XFS_CORRUPTION_ERROR("xfs_iformat_extents(1)", XFS_ERRLEVEL_LOW,
  				     ip->i_mount, dip);
++<<<<<<< HEAD
 +		return XFS_ERROR(EFSCORRUPTED);
++=======
+ 		return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	ifp->if_real_bytes = 0;
@@@ -350,7 -350,7 +398,11 @@@
  					XFS_ERROR_REPORT("xfs_iformat_extents(2)",
  							 XFS_ERRLEVEL_LOW,
  							 ip->i_mount);
++<<<<<<< HEAD
 +					return XFS_ERROR(EFSCORRUPTED);
++=======
+ 					return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  				}
  	}
  	ifp->if_flags |= XFS_IFEXTENTS;
@@@ -399,7 -399,7 +451,11 @@@ xfs_iformat_btree
  					(unsigned long long) ip->i_ino);
  		XFS_CORRUPTION_ERROR("xfs_iformat_btree", XFS_ERRLEVEL_LOW,
  					 mp, dip);
++<<<<<<< HEAD
 +		return XFS_ERROR(EFSCORRUPTED);
++=======
+ 		return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	ifp->if_broot_bytes = size;
@@@ -434,7 -434,9 +490,11 @@@ xfs_iread_extents
  	if (unlikely(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {
  		XFS_ERROR_REPORT("xfs_iread_extents", XFS_ERRLEVEL_LOW,
  				 ip->i_mount);
++<<<<<<< HEAD
 +		return XFS_ERROR(EFSCORRUPTED);
++=======
+ 		return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	nextents = XFS_IFORK_NEXTENTS(ip, whichfork);
  	ifp = XFS_IFORK_PTR(ip, whichfork);
diff --cc fs/xfs/libxfs/xfs_sb.c
index b98c21d8ea4b,f5ca0286a0af..000000000000
--- a/fs/xfs/libxfs/xfs_sb.c
+++ b/fs/xfs/libxfs/xfs_sb.c
@@@ -186,13 -186,13 +186,21 @@@ xfs_mount_validate_sb
  	 */
  	if (sbp->sb_magicnum != XFS_SB_MAGIC) {
  		xfs_warn(mp, "bad magic number");
++<<<<<<< HEAD
 +		return XFS_ERROR(EWRONGFS);
++=======
+ 		return -EWRONGFS;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  
  	if (!xfs_sb_good_version(sbp)) {
  		xfs_warn(mp, "bad version");
++<<<<<<< HEAD
 +		return XFS_ERROR(EWRONGFS);
++=======
+ 		return -EWRONGFS;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	/*
@@@ -220,7 -220,7 +228,11 @@@
  				xfs_warn(mp,
  "Attempted to mount read-only compatible filesystem read-write.\n"
  "Filesystem can only be safely mounted read only.");
++<<<<<<< HEAD
 +				return XFS_ERROR(EINVAL);
++=======
+ 				return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			}
  		}
  		if (xfs_sb_has_incompat_feature(sbp,
@@@ -230,7 -230,7 +242,11 @@@
  "Filesystem can not be safely mounted by this kernel.",
  				(sbp->sb_features_incompat &
  						XFS_SB_FEAT_INCOMPAT_UNKNOWN));
++<<<<<<< HEAD
 +			return XFS_ERROR(EINVAL);
++=======
+ 			return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  	}
  
@@@ -238,13 -238,13 +254,21 @@@
  		if (sbp->sb_qflags & (XFS_OQUOTA_ENFD | XFS_OQUOTA_CHKD)) {
  			xfs_notice(mp,
  			   "Version 5 of Super block has XFS_OQUOTA bits.");
++<<<<<<< HEAD
 +			return XFS_ERROR(EFSCORRUPTED);
++=======
+ 			return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  	} else if (sbp->sb_qflags & (XFS_PQUOTA_ENFD | XFS_GQUOTA_ENFD |
  				XFS_PQUOTA_CHKD | XFS_GQUOTA_CHKD)) {
  			xfs_notice(mp,
  "Superblock earlier than Version 5 has XFS_[PQ]UOTA_{ENFD|CHKD} bits.");
++<<<<<<< HEAD
 +			return XFS_ERROR(EFSCORRUPTED);
++=======
+ 			return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	if (unlikely(
@@@ -252,7 -252,7 +276,11 @@@
  		xfs_warn(mp,
  		"filesystem is marked as having an external log; "
  		"specify logdev on the mount command line.");
++<<<<<<< HEAD
 +		return XFS_ERROR(EINVAL);
++=======
+ 		return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	if (unlikely(
@@@ -260,7 -260,7 +288,11 @@@
  		xfs_warn(mp,
  		"filesystem is marked as having an internal log; "
  		"do not specify logdev on the mount command line.");
++<<<<<<< HEAD
 +		return XFS_ERROR(EINVAL);
++=======
+ 		return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	/*
@@@ -293,9 -291,10 +325,13 @@@
  	    (sbp->sb_imax_pct > 100 /* zero sb_imax_pct is valid */)	||
  	    sbp->sb_dblocks == 0					||
  	    sbp->sb_dblocks > XFS_MAX_DBLOCKS(sbp)			||
 -	    sbp->sb_dblocks < XFS_MIN_DBLOCKS(sbp)			||
 -	    sbp->sb_shared_vn != 0)) {
 +	    sbp->sb_dblocks < XFS_MIN_DBLOCKS(sbp))) {
  		xfs_notice(mp, "SB sanity check failed");
++<<<<<<< HEAD
 +		return XFS_ERROR(EFSCORRUPTED);
++=======
+ 		return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	/*
@@@ -306,7 -305,7 +342,11 @@@
  		"File system with blocksize %d bytes. "
  		"Only pagesize (%ld) or less will currently work.",
  				sbp->sb_blocksize, PAGE_SIZE);
++<<<<<<< HEAD
 +		return XFS_ERROR(ENOSYS);
++=======
+ 		return -ENOSYS;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	/*
@@@ -321,29 -320,20 +361,41 @@@
  	default:
  		xfs_warn(mp, "inode size of %d bytes not supported",
  				sbp->sb_inodesize);
++<<<<<<< HEAD
 +		return XFS_ERROR(ENOSYS);
++=======
+ 		return -ENOSYS;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	if (xfs_sb_validate_fsb_count(sbp, sbp->sb_dblocks) ||
  	    xfs_sb_validate_fsb_count(sbp, sbp->sb_rblocks)) {
  		xfs_warn(mp,
  		"file system too large to be mounted on this system.");
++<<<<<<< HEAD
 +		return XFS_ERROR(EFBIG);
++=======
+ 		return -EFBIG;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	if (check_inprogress && sbp->sb_inprogress) {
  		xfs_warn(mp, "Offline file system operation in progress!");
++<<<<<<< HEAD
 +		return XFS_ERROR(EFSCORRUPTED);
++=======
+ 		return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
 +
 +	/*
 +	 * Version 1 directory format has never worked on Linux.
 +	 */
 +	if (unlikely(!xfs_sb_version_hasdirv2(sbp))) {
 +		xfs_warn(mp, "file system using version 1 directory format");
 +		return XFS_ERROR(ENOSYS);
 +	}
 +
  	return 0;
  }
  
diff --cc fs/xfs/xfs_aops.c
index c85d57d56842,11e9b4caa54f..000000000000
--- a/fs/xfs/xfs_aops.c
+++ b/fs/xfs/xfs_aops.c
@@@ -343,14 -332,14 +343,22 @@@ xfs_map_blocks
  	xfs_iunlock(ip, XFS_ILOCK_SHARED);
  
  	if (error)
++<<<<<<< HEAD
 +		return -XFS_ERROR(error);
++=======
+ 		return error;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	if (type == XFS_IO_DELALLOC &&
  	    (!nimaps || isnullstartblock(imap->br_startblock))) {
  		error = xfs_iomap_write_allocate(ip, offset, imap);
  		if (!error)
  			trace_xfs_map_blocks_alloc(ip, offset, count, type, imap);
++<<<<<<< HEAD
 +		return -XFS_ERROR(error);
++=======
+ 		return error;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  #ifdef DEBUG
diff --cc fs/xfs/xfs_attr_inactive.c
index b39e58823085,aa2a8b1838a2..000000000000
--- a/fs/xfs/xfs_attr_inactive.c
+++ b/fs/xfs/xfs_attr_inactive.c
@@@ -227,7 -227,7 +227,11 @@@ xfs_attr3_node_inactive
  	 */
  	if (level > XFS_DA_NODE_MAXDEPTH) {
  		xfs_trans_brelse(*trans, bp);	/* no locks for later trans */
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	node = bp->b_addr;
@@@ -277,7 -277,7 +281,11 @@@
  							child_bp);
  				break;
  			default:
++<<<<<<< HEAD
 +				error = XFS_ERROR(EIO);
++=======
+ 				error = -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  				xfs_trans_brelse(*trans, child_bp);
  				break;
  			}
@@@ -360,7 -360,7 +368,11 @@@ xfs_attr3_root_inactive
  		error = xfs_attr3_leaf_inactive(trans, dp, bp);
  		break;
  	default:
++<<<<<<< HEAD
 +		error = XFS_ERROR(EIO);
++=======
+ 		error = -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		xfs_trans_brelse(*trans, bp);
  		break;
  	}
diff --cc fs/xfs/xfs_attr_list.c
index 2d5487b6194c,62db83ab6cbc..000000000000
--- a/fs/xfs/xfs_attr_list.c
+++ b/fs/xfs/xfs_attr_list.c
@@@ -150,7 -150,7 +150,11 @@@ xfs_attr_shortform_list(xfs_attr_list_c
  					     XFS_ERRLEVEL_LOW,
  					     context->dp->i_mount, sfe);
  			kmem_free(sbuf);
++<<<<<<< HEAD
 +			return XFS_ERROR(EFSCORRUPTED);
++=======
+ 			return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  
  		sbp->entno = i;
@@@ -308,7 -308,7 +312,11 @@@ xfs_attr_node_list(xfs_attr_list_contex
  						     context->dp->i_mount,
  						     node);
  				xfs_trans_brelse(NULL, bp);
++<<<<<<< HEAD
 +				return XFS_ERROR(EFSCORRUPTED);
++=======
+ 				return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			}
  
  			dp->d_ops->node_hdr_from_disk(&nodehdr, node);
@@@ -616,16 -616,16 +624,27 @@@ xfs_attr_list
  	 * Validate the cursor.
  	 */
  	if (cursor->pad1 || cursor->pad2)
++<<<<<<< HEAD
 +		return XFS_ERROR(EINVAL);
 +	if ((cursor->initted == 0) &&
 +	    (cursor->hashval || cursor->blkno || cursor->offset))
 +		return XFS_ERROR(EINVAL);
++=======
+ 		return -EINVAL;
+ 	if ((cursor->initted == 0) &&
+ 	    (cursor->hashval || cursor->blkno || cursor->offset))
+ 		return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	/*
  	 * Check for a properly aligned buffer.
  	 */
  	if (((long)buffer) & (sizeof(int)-1))
++<<<<<<< HEAD
 +		return XFS_ERROR(EFAULT);
++=======
+ 		return -EFAULT;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	if (flags & ATTR_KERNOVAL)
  		bufsize = 0;
  
diff --cc fs/xfs/xfs_bmap_util.c
index e2ea28ff57bf,56f050efcac8..000000000000
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@@ -365,7 -418,7 +365,11 @@@ xfs_bmap_count_tree
  			xfs_trans_brelse(tp, bp);
  			XFS_ERROR_REPORT("xfs_bmap_count_tree(1)",
  					 XFS_ERRLEVEL_LOW, mp);
++<<<<<<< HEAD
 +			return XFS_ERROR(EFSCORRUPTED);
++=======
+ 			return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  		xfs_trans_brelse(tp, bp);
  	} else {
@@@ -432,7 -485,7 +436,11 @@@ xfs_bmap_count_blocks
  	if (unlikely(xfs_bmap_count_tree(mp, tp, ifp, bno, level, count) < 0)) {
  		XFS_ERROR_REPORT("xfs_bmap_count_blocks(2)", XFS_ERRLEVEL_LOW,
  				 mp);
++<<<<<<< HEAD
 +		return XFS_ERROR(EFSCORRUPTED);
++=======
+ 		return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	return 0;
@@@ -524,13 -577,13 +532,21 @@@ xfs_getbmap
  			if (ip->i_d.di_aformat != XFS_DINODE_FMT_EXTENTS &&
  			    ip->i_d.di_aformat != XFS_DINODE_FMT_BTREE &&
  			    ip->i_d.di_aformat != XFS_DINODE_FMT_LOCAL)
++<<<<<<< HEAD
 +				return XFS_ERROR(EINVAL);
++=======
+ 				return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		} else if (unlikely(
  			   ip->i_d.di_aformat != 0 &&
  			   ip->i_d.di_aformat != XFS_DINODE_FMT_EXTENTS)) {
  			XFS_ERROR_REPORT("xfs_getbmap", XFS_ERRLEVEL_LOW,
  					 ip->i_mount);
++<<<<<<< HEAD
 +			return XFS_ERROR(EFSCORRUPTED);
++=======
+ 			return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  
  		prealloced = 0;
@@@ -539,7 -592,7 +555,11 @@@
  		if (ip->i_d.di_format != XFS_DINODE_FMT_EXTENTS &&
  		    ip->i_d.di_format != XFS_DINODE_FMT_BTREE &&
  		    ip->i_d.di_format != XFS_DINODE_FMT_LOCAL)
++<<<<<<< HEAD
 +			return XFS_ERROR(EINVAL);
++=======
+ 			return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  		if (xfs_get_extsz_hint(ip) ||
  		    ip->i_d.di_flags & (XFS_DIFLAG_PREALLOC|XFS_DIFLAG_APPEND)){
@@@ -559,20 -612,20 +579,35 @@@
  		bmv->bmv_entries = 0;
  		return 0;
  	} else if (bmv->bmv_length < 0) {
++<<<<<<< HEAD
 +		return XFS_ERROR(EINVAL);
++=======
+ 		return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	nex = bmv->bmv_count - 1;
  	if (nex <= 0)
++<<<<<<< HEAD
 +		return XFS_ERROR(EINVAL);
++=======
+ 		return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	bmvend = bmv->bmv_offset + bmv->bmv_length;
  
  
  	if (bmv->bmv_count > ULONG_MAX / sizeof(struct getbmapx))
++<<<<<<< HEAD
 +		return XFS_ERROR(ENOMEM);
 +	out = kmem_zalloc_large(bmv->bmv_count * sizeof(struct getbmapx), 0);
 +	if (!out)
 +		return XFS_ERROR(ENOMEM);
++=======
+ 		return -ENOMEM;
+ 	out = kmem_zalloc_large(bmv->bmv_count * sizeof(struct getbmapx), 0);
+ 	if (!out)
+ 		return -ENOMEM;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	xfs_ilock(ip, XFS_IOLOCK_SHARED);
  	if (whichfork == XFS_DATA_FORK) {
@@@ -955,14 -1008,14 +990,22 @@@ xfs_alloc_file_space
  	trace_xfs_alloc_file_space(ip);
  
  	if (XFS_FORCED_SHUTDOWN(mp))
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	error = xfs_qm_dqattach(ip, 0);
  	if (error)
  		return error;
  
  	if (len <= 0)
++<<<<<<< HEAD
 +		return XFS_ERROR(EINVAL);
++=======
+ 		return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	rt = XFS_IS_REALTIME_INODE(ip);
  	extsz = xfs_get_extsz_hint(ip);
@@@ -1065,7 -1118,7 +1108,11 @@@
  		allocated_fsb = imapp->br_blockcount;
  
  		if (nimaps == 0) {
++<<<<<<< HEAD
 +			error = XFS_ERROR(ENOSPC);
++=======
+ 			error = -ENOSPC;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			break;
  		}
  
@@@ -1126,7 -1179,7 +1173,11 @@@ xfs_zero_remaining_bytes
  					mp->m_rtdev_targp : mp->m_ddev_targp,
  				  BTOBB(mp->m_sb.sb_blocksize), 0);
  	if (!bp)
++<<<<<<< HEAD
 +		return XFS_ERROR(ENOMEM);
++=======
+ 		return -ENOMEM;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	xfs_buf_unlock(bp);
  
@@@ -1158,7 -1211,7 +1209,11 @@@
  		XFS_BUF_SET_ADDR(bp, xfs_fsb_to_db(ip, imap.br_startblock));
  
  		if (XFS_FORCED_SHUTDOWN(mp)) {
++<<<<<<< HEAD
 +			error = XFS_ERROR(EIO);
++=======
+ 			error = -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			break;
  		}
  		xfs_buf_iorequest(bp);
@@@ -1176,7 -1229,7 +1231,11 @@@
  		XFS_BUF_WRITE(bp);
  
  		if (XFS_FORCED_SHUTDOWN(mp)) {
++<<<<<<< HEAD
 +			error = XFS_ERROR(EIO);
++=======
+ 			error = -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			break;
  		}
  		xfs_buf_iorequest(bp);
@@@ -1568,7 -1689,7 +1627,11 @@@ xfs_swap_extents
  
  	tempifp = kmem_alloc(sizeof(xfs_ifork_t), KM_MAYFAIL);
  	if (!tempifp) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(ENOMEM);
++=======
+ 		error = -ENOMEM;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto out;
  	}
  
@@@ -1583,38 -1703,34 +1646,61 @@@
  
  	/* Verify that both files have the same format */
  	if ((ip->i_d.di_mode & S_IFMT) != (tip->i_d.di_mode & S_IFMT)) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(EINVAL);
++=======
+ 		error = -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto out_unlock;
  	}
  
  	/* Verify both files are either real-time or non-realtime */
  	if (XFS_IS_REALTIME_INODE(ip) != XFS_IS_REALTIME_INODE(tip)) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(EINVAL);
 +		goto out_unlock;
 +	}
 +
 +	error = xfs_swap_extent_flush(ip);
 +	if (error)
 +		goto out_unlock;
 +	error = xfs_swap_extent_flush(tip);
++=======
+ 		error = -EINVAL;
+ 		goto out_unlock;
+ 	}
+ 
+ 	error = filemap_write_and_wait(VFS_I(tip)->i_mapping);
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	if (error)
  		goto out_unlock;
 -	truncate_pagecache_range(VFS_I(tip), 0, -1);
  
++<<<<<<< HEAD
 +	tp = xfs_trans_alloc(mp, XFS_TRANS_SWAPEXT);
 +	error = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);
 +	if (error) {
 +		xfs_trans_cancel(tp, 0);
++=======
+ 	/* Verify O_DIRECT for ftmp */
+ 	if (VN_CACHED(VFS_I(tip)) != 0) {
+ 		error = -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto out_unlock;
  	}
 +	xfs_lock_two_inodes(ip, tip, XFS_ILOCK_EXCL);
 +	lock_flags |= XFS_ILOCK_EXCL;
  
  	/* Verify all data are being swapped */
  	if (sxp->sx_offset != 0 ||
  	    sxp->sx_length != ip->i_d.di_size ||
  	    sxp->sx_length != tip->i_d.di_size) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(EFAULT);
 +		goto out_trans_cancel;
++=======
+ 		error = -EFAULT;
+ 		goto out_unlock;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	trace_xfs_swap_extent_before(ip, 0);
@@@ -1640,9 -1756,43 +1726,49 @@@
  	    (sbp->bs_ctime.tv_nsec != VFS_I(ip)->i_ctime.tv_nsec) ||
  	    (sbp->bs_mtime.tv_sec != VFS_I(ip)->i_mtime.tv_sec) ||
  	    (sbp->bs_mtime.tv_nsec != VFS_I(ip)->i_mtime.tv_nsec)) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(EBUSY);
 +		goto out_trans_cancel;
 +	}
++=======
+ 		error = -EBUSY;
+ 		goto out_unlock;
+ 	}
+ 
+ 	/* We need to fail if the file is memory mapped.  Once we have tossed
+ 	 * all existing pages, the page fault will have no option
+ 	 * but to go to the filesystem for pages. By making the page fault call
+ 	 * vop_read (or write in the case of autogrow) they block on the iolock
+ 	 * until we have switched the extents.
+ 	 */
+ 	if (VN_MAPPED(VFS_I(ip))) {
+ 		error = -EBUSY;
+ 		goto out_unlock;
+ 	}
+ 
+ 	xfs_iunlock(ip, XFS_ILOCK_EXCL);
+ 	xfs_iunlock(tip, XFS_ILOCK_EXCL);
+ 
+ 	/*
+ 	 * There is a race condition here since we gave up the
+ 	 * ilock.  However, the data fork will not change since
+ 	 * we have the iolock (locked for truncation too) so we
+ 	 * are safe.  We don't really care if non-io related
+ 	 * fields change.
+ 	 */
+ 	truncate_pagecache_range(VFS_I(ip), 0, -1);
+ 
+ 	tp = xfs_trans_alloc(mp, XFS_TRANS_SWAPEXT);
+ 	error = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);
+ 	if (error) {
+ 		xfs_iunlock(ip,  XFS_IOLOCK_EXCL);
+ 		xfs_iunlock(tip, XFS_IOLOCK_EXCL);
+ 		xfs_trans_cancel(tp, 0);
+ 		goto out;
+ 	}
+ 	xfs_lock_two_inodes(ip, tip, XFS_ILOCK_EXCL);
+ 
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	/*
  	 * Count the number of extended attribute blocks
  	 */
diff --cc fs/xfs/xfs_dir2_readdir.c
index d6645e8c5ecc,f1b69edcdf31..000000000000
--- a/fs/xfs/xfs_dir2_readdir.c
+++ b/fs/xfs/xfs_dir2_readdir.c
@@@ -97,8 -94,8 +97,13 @@@ xfs_dir2_sf_getdents
  	 * Give up if the directory is way too short.
  	 */
  	if (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {
++<<<<<<< HEAD
 +		ASSERT(XFS_FORCED_SHUTDOWN(mp));
 +		return XFS_ERROR(EIO);
++=======
+ 		ASSERT(XFS_FORCED_SHUTDOWN(dp->i_mount));
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	ASSERT(dp->i_df.if_bytes == dp->i_d.di_size);
@@@ -689,7 -677,7 +694,11 @@@ xfs_readdir
  	trace_xfs_readdir(dp);
  
  	if (XFS_FORCED_SHUTDOWN(dp->i_mount))
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	ASSERT(S_ISDIR(dp->i_d.di_mode));
  	XFS_STATS_INC(xs_dir_getdents);
diff --cc fs/xfs/xfs_dquot.c
index b3113d6df117,8a44a79f49af..000000000000
--- a/fs/xfs/xfs_dquot.c
+++ b/fs/xfs/xfs_dquot.c
@@@ -442,7 -442,7 +442,11 @@@ xfs_qm_dqrepair
  		if (error) {
  			/* repair failed, we're screwed */
  			xfs_trans_brelse(tp, *bpp);
++<<<<<<< HEAD
 +			return XFS_ERROR(EIO);
++=======
+ 			return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  	}
  
@@@ -796,7 -796,7 +800,11 @@@ restart
  		} else {
  			/* inode stays locked on return */
  			xfs_qm_dqdestroy(dqp);
++<<<<<<< HEAD
 +			return XFS_ERROR(ESRCH);
++=======
+ 			return -ESRCH;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  	}
  
@@@ -1008,7 -966,7 +1016,11 @@@ xfs_qm_dqflush
  					     SHUTDOWN_CORRUPT_INCORE);
  		else
  			spin_unlock(&mp->m_ail->xa_lock);
++<<<<<<< HEAD
 +		error = XFS_ERROR(EIO);
++=======
+ 		error = -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto out_unlock;
  	}
  
@@@ -1035,7 -992,7 +1047,11 @@@
  		xfs_buf_relse(bp);
  		xfs_dqfunlock(dqp);
  		xfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	/* This is the only portion of data that needs to persist */
@@@ -1088,7 -1045,7 +1104,11 @@@
  
  out_unlock:
  	xfs_dqfunlock(dqp);
++<<<<<<< HEAD
 +	return XFS_ERROR(EIO);
++=======
+ 	return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  }
  
  /*
diff --cc fs/xfs/xfs_error.h
index c1c57d4a4b5d,279a76e52791..000000000000
--- a/fs/xfs/xfs_error.h
+++ b/fs/xfs/xfs_error.h
@@@ -56,7 -47,7 +56,11 @@@ extern void xfs_verifier_error(struct x
  		if (unlikely(!fs_is_ok)) { \
  			XFS_ERROR_REPORT("XFS_WANT_CORRUPTED_GOTO", \
  					 XFS_ERRLEVEL_LOW, NULL); \
++<<<<<<< HEAD
 +			error = XFS_ERROR(EFSCORRUPTED); \
++=======
+ 			error = -EFSCORRUPTED; \
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			goto l; \
  		} \
  	}
@@@ -68,7 -59,7 +72,11 @@@
  		if (unlikely(!fs_is_ok)) { \
  			XFS_ERROR_REPORT("XFS_WANT_CORRUPTED_RETURN", \
  					 XFS_ERRLEVEL_LOW, NULL); \
++<<<<<<< HEAD
 +			return XFS_ERROR(EFSCORRUPTED); \
++=======
+ 			return -EFSCORRUPTED; \
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		} \
  	}
  
diff --cc fs/xfs/xfs_file.c
index 91b548987ce6,181605da08e4..000000000000
--- a/fs/xfs/xfs_file.c
+++ b/fs/xfs/xfs_file.c
@@@ -864,6 -768,28 +864,31 @@@ xfs_file_fallocate
  		error = xfs_free_file_space(ip, offset, len);
  		if (error)
  			goto out_unlock;
++<<<<<<< HEAD
++=======
+ 	} else if (mode & FALLOC_FL_COLLAPSE_RANGE) {
+ 		unsigned blksize_mask = (1 << inode->i_blkbits) - 1;
+ 
+ 		if (offset & blksize_mask || len & blksize_mask) {
+ 			error = -EINVAL;
+ 			goto out_unlock;
+ 		}
+ 
+ 		/*
+ 		 * There is no need to overlap collapse range with EOF,
+ 		 * in which case it is effectively a truncate operation
+ 		 */
+ 		if (offset + len >= i_size_read(inode)) {
+ 			error = -EINVAL;
+ 			goto out_unlock;
+ 		}
+ 
+ 		new_size = i_size_read(inode) - len;
+ 
+ 		error = xfs_collapse_file_space(ip, offset, len);
+ 		if (error)
+ 			goto out_unlock;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	} else {
  		if (!(mode & FALLOC_FL_KEEP_SIZE) &&
  		    offset + len > i_size_read(inode)) {
@@@ -988,10 -916,9 +1013,10 @@@ xfs_file_readdir
  	 */
  	bufsize = (size_t)min_t(loff_t, 32768, ip->i_d.di_size);
  
 -	error = xfs_readdir(ip, ctx, bufsize);
 +	error = xfs_readdir(ip, dirent, bufsize,
 +				(xfs_off_t *)&filp->f_pos, filldir);
  	if (error)
- 		return -error;
+ 		return error;
  	return 0;
  }
  
diff --cc fs/xfs/xfs_filestream.c
index 12b6e7701985,e92730c1d3ca..000000000000
--- a/fs/xfs/xfs_filestream.c
+++ b/fs/xfs/xfs_filestream.c
@@@ -318,145 -253,57 +318,167 @@@ next_ag
  		return 0;
  	}
  
++<<<<<<< HEAD
 +	TRACE_AG_PICK2(mp, startag, *agp, streams, free, nscan, flags);
++=======
+ 	trace_xfs_filestream_pick(ip, *agp, free, nscan);
+ 
+ 	if (*agp == NULLAGNUMBER)
+ 		return 0;
+ 
+ 	err = -ENOMEM;
+ 	item = kmem_alloc(sizeof(*item), KM_MAYFAIL);
+ 	if (!item)
+ 		goto out_put_ag;
+ 
+ 	item->ag = *agp;
+ 	item->ip = ip;
+ 
+ 	err = xfs_mru_cache_insert(mp->m_filestream, ip->i_ino, &item->mru);
+ 	if (err) {
+ 		if (err == -EEXIST)
+ 			err = 0;
+ 		goto out_free_item;
+ 	}
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	return 0;
 +}
  
 -out_free_item:
 -	kmem_free(item);
 -out_put_ag:
 -	xfs_filestream_put_ag(mp, *agp);
 -	return err;
 +/*
 + * Set the allocation group number for a file or a directory, updating inode
 + * references and per-AG references as appropriate.
 + */
 +static int
 +_xfs_filestream_update_ag(
 +	xfs_inode_t	*ip,
 +	xfs_inode_t	*pip,
 +	xfs_agnumber_t	ag)
 +{
 +	int		err = 0;
 +	xfs_mount_t	*mp;
 +	xfs_mru_cache_t	*cache;
 +	fstrm_item_t	*item;
 +	xfs_agnumber_t	old_ag;
 +	xfs_inode_t	*old_pip;
 +
 +	/*
 +	 * Either ip is a regular file and pip is a directory, or ip is a
 +	 * directory and pip is NULL.
 +	 */
 +	ASSERT(ip && ((S_ISREG(ip->i_d.di_mode) && pip &&
 +	               S_ISDIR(pip->i_d.di_mode)) ||
 +	              (S_ISDIR(ip->i_d.di_mode) && !pip)));
 +
 +	mp = ip->i_mount;
 +	cache = mp->m_filestream;
 +
 +	item = xfs_mru_cache_lookup(cache, ip->i_ino);
 +	if (item) {
 +		ASSERT(item->ip == ip);
 +		old_ag = item->ag;
 +		item->ag = ag;
 +		old_pip = item->pip;
 +		item->pip = pip;
 +		xfs_mru_cache_done(cache);
 +
 +		/*
 +		 * If the AG has changed, drop the old ref and take a new one,
 +		 * effectively transferring the reference from old to new AG.
 +		 */
 +		if (ag != old_ag) {
 +			xfs_filestream_put_ag(mp, old_ag);
 +			xfs_filestream_get_ag(mp, ag);
 +		}
 +
 +		/*
 +		 * If ip is a file and its pip has changed, drop the old ref and
 +		 * take a new one.
 +		 */
 +		if (pip && pip != old_pip) {
 +			IRELE(old_pip);
 +			IHOLD(pip);
 +		}
 +
 +		TRACE_UPDATE(mp, ip, old_ag, xfs_filestream_peek_ag(mp, old_ag),
 +				ag, xfs_filestream_peek_ag(mp, ag));
 +		return 0;
 +	}
 +
 +	item = kmem_zone_zalloc(item_zone, KM_MAYFAIL);
 +	if (!item)
 +		return ENOMEM;
 +
 +	item->ag = ag;
 +	item->ip = ip;
 +	item->pip = pip;
 +
 +	err = xfs_mru_cache_insert(cache, ip->i_ino, item);
 +	if (err) {
 +		kmem_zone_free(item_zone, item);
 +		return err;
 +	}
 +
 +	/* Take a reference on the AG. */
 +	xfs_filestream_get_ag(mp, ag);
 +
 +	/*
 +	 * Take a reference on the inode itself regardless of whether it's a
 +	 * regular file or a directory.
 +	 */
 +	IHOLD(ip);
 +
 +	/*
 +	 * In the case of a regular file, take a reference on the parent inode
 +	 * as well to ensure it remains in-core.
 +	 */
 +	if (pip)
 +		IHOLD(pip);
 +
 +	TRACE_UPDATE(mp, ip, ag, xfs_filestream_peek_ag(mp, ag),
 +			ag, xfs_filestream_peek_ag(mp, ag));
 +
 +	return 0;
  }
  
 -static struct xfs_inode *
 -xfs_filestream_get_parent(
 -	struct xfs_inode	*ip)
 +/* xfs_fstrm_free_func(): callback for freeing cached stream items. */
 +STATIC void
 +xfs_fstrm_free_func(
 +	unsigned long	ino,
 +	void		*data)
  {
 -	struct inode		*inode = VFS_I(ip), *dir = NULL;
 -	struct dentry		*dentry, *parent;
 +	fstrm_item_t	*item  = (fstrm_item_t *)data;
 +	xfs_inode_t	*ip = item->ip;
 +
 +	ASSERT(ip->i_ino == ino);
 +
 +	xfs_iflags_clear(ip, XFS_IFILESTREAM);
  
 -	dentry = d_find_alias(inode);
 -	if (!dentry)
 -		goto out;
 +	/* Drop the reference taken on the AG when the item was added. */
 +	xfs_filestream_put_ag(ip->i_mount, item->ag);
  
 -	parent = dget_parent(dentry);
 -	if (!parent)
 -		goto out_dput;
 +	TRACE_FREE(ip->i_mount, ip, item->pip, item->ag,
 +		xfs_filestream_peek_ag(ip->i_mount, item->ag));
  
 -	dir = igrab(parent->d_inode);
 -	dput(parent);
 +	/*
 +	 * _xfs_filestream_update_ag() always takes a reference on the inode
 +	 * itself, whether it's a file or a directory.  Release it here.
 +	 * This can result in the inode being freed and so we must
 +	 * not hold any inode locks when freeing filesstreams objects
 +	 * otherwise we can deadlock here.
 +	 */
 +	IRELE(ip);
 +
 +	/*
 +	 * In the case of a regular file, _xfs_filestream_update_ag() also
 +	 * takes a ref on the parent inode to keep it in-core.  Release that
 +	 * too.
 +	 */
 +	if (item->pip)
 +		IRELE(item->pip);
  
 -out_dput:
 -	dput(dentry);
 -out:
 -	return dir ? XFS_I(dir) : NULL;
 +	/* Finally, free the memory allocated for the item. */
 +	kmem_zone_free(item_zone, item);
  }
  
  /*
diff --cc fs/xfs/xfs_fsops.c
index 3445ead7c1fc,f91de1ef05e1..000000000000
--- a/fs/xfs/xfs_fsops.c
+++ b/fs/xfs/xfs_fsops.c
@@@ -171,7 -168,7 +171,11 @@@ xfs_growfs_data_private
  	nb = in->newblocks;
  	pct = in->imaxpct;
  	if (nb < mp->m_sb.sb_dblocks || pct < 0 || pct > 100)
++<<<<<<< HEAD
 +		return XFS_ERROR(EINVAL);
++=======
+ 		return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	if ((error = xfs_sb_validate_fsb_count(&mp->m_sb, nb)))
  		return error;
  	dpct = pct - mp->m_sb.sb_imax_pct;
@@@ -194,7 -191,7 +198,11 @@@
  		nagcount--;
  		nb = (xfs_rfsblock_t)nagcount * mp->m_sb.sb_agblocks;
  		if (nb < mp->m_sb.sb_dblocks)
++<<<<<<< HEAD
 +			return XFS_ERROR(EINVAL);
++=======
+ 			return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	new = nb - mp->m_sb.sb_dblocks;
  	oagcount = mp->m_sb.sb_agcount;
@@@ -579,17 -576,17 +587,28 @@@ xfs_growfs_log_private
  
  	nb = in->newblocks;
  	if (nb < XFS_MIN_LOG_BLOCKS || nb < XFS_B_TO_FSB(mp, XFS_MIN_LOG_BYTES))
++<<<<<<< HEAD
 +		return XFS_ERROR(EINVAL);
 +	if (nb == mp->m_sb.sb_logblocks &&
 +	    in->isint == (mp->m_sb.sb_logstart != 0))
 +		return XFS_ERROR(EINVAL);
++=======
+ 		return -EINVAL;
+ 	if (nb == mp->m_sb.sb_logblocks &&
+ 	    in->isint == (mp->m_sb.sb_logstart != 0))
+ 		return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	/*
  	 * Moving the log is hard, need new interfaces to sync
  	 * the log first, hold off all activity while moving it.
  	 * Can have shorter or longer log in the same space,
  	 * or transform internal to external log or vice versa.
  	 */
++<<<<<<< HEAD
 +	return XFS_ERROR(ENOSYS);
++=======
+ 	return -ENOSYS;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  }
  
  /*
@@@ -607,9 -604,9 +626,15 @@@ xfs_growfs_data
  	int error;
  
  	if (!capable(CAP_SYS_ADMIN))
++<<<<<<< HEAD
 +		return XFS_ERROR(EPERM);
 +	if (!mutex_trylock(&mp->m_growlock))
 +		return XFS_ERROR(EWOULDBLOCK);
++=======
+ 		return -EPERM;
+ 	if (!mutex_trylock(&mp->m_growlock))
+ 		return -EWOULDBLOCK;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	error = xfs_growfs_data_private(mp, in);
  	mutex_unlock(&mp->m_growlock);
  	return error;
@@@ -623,9 -620,9 +648,15 @@@ xfs_growfs_log
  	int error;
  
  	if (!capable(CAP_SYS_ADMIN))
++<<<<<<< HEAD
 +		return XFS_ERROR(EPERM);
 +	if (!mutex_trylock(&mp->m_growlock))
 +		return XFS_ERROR(EWOULDBLOCK);
++=======
+ 		return -EPERM;
+ 	if (!mutex_trylock(&mp->m_growlock))
+ 		return -EWOULDBLOCK;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	error = xfs_growfs_log_private(mp, in);
  	mutex_unlock(&mp->m_growlock);
  	return error;
@@@ -821,7 -818,7 +852,11 @@@ xfs_fs_goingdown
  				SHUTDOWN_FORCE_UMOUNT | SHUTDOWN_LOG_IO_ERROR);
  		break;
  	default:
++<<<<<<< HEAD
 +		return XFS_ERROR(EINVAL);
++=======
+ 		return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	return 0;
diff --cc fs/xfs/xfs_inode.c
index 4a2cda2c661c,1a5e068bc420..000000000000
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@@ -581,7 -583,7 +581,11 @@@ xfs_lookup
  	trace_xfs_lookup(dp, name);
  
  	if (XFS_FORCED_SHUTDOWN(dp->i_mount))
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	lock_mode = xfs_ilock_data_map_shared(dp);
  	error = xfs_dir_lookup(NULL, dp, name, &inum, ci_name);
@@@ -921,7 -893,7 +925,11 @@@ xfs_dir_ialloc
  	}
  	if (!ialloc_context && !ip) {
  		*ipp = NULL;
++<<<<<<< HEAD
 +		return XFS_ERROR(ENOSPC);
++=======
+ 		return -ENOSPC;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	/*
@@@ -1162,7 -1088,7 +1170,11 @@@ xfs_create
  	trace_xfs_create(dp, name);
  
  	if (XFS_FORCED_SHUTDOWN(mp))
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	prid = xfs_get_initial_prid(dp);
  
@@@ -1330,6 -1255,114 +1342,117 @@@
  }
  
  int
++<<<<<<< HEAD
++=======
+ xfs_create_tmpfile(
+ 	struct xfs_inode	*dp,
+ 	struct dentry		*dentry,
+ 	umode_t			mode,
+ 	struct xfs_inode	**ipp)
+ {
+ 	struct xfs_mount	*mp = dp->i_mount;
+ 	struct xfs_inode	*ip = NULL;
+ 	struct xfs_trans	*tp = NULL;
+ 	int			error;
+ 	uint			cancel_flags = XFS_TRANS_RELEASE_LOG_RES;
+ 	prid_t                  prid;
+ 	struct xfs_dquot	*udqp = NULL;
+ 	struct xfs_dquot	*gdqp = NULL;
+ 	struct xfs_dquot	*pdqp = NULL;
+ 	struct xfs_trans_res	*tres;
+ 	uint			resblks;
+ 
+ 	if (XFS_FORCED_SHUTDOWN(mp))
+ 		return -EIO;
+ 
+ 	prid = xfs_get_initial_prid(dp);
+ 
+ 	/*
+ 	 * Make sure that we have allocated dquot(s) on disk.
+ 	 */
+ 	error = xfs_qm_vop_dqalloc(dp, xfs_kuid_to_uid(current_fsuid()),
+ 				xfs_kgid_to_gid(current_fsgid()), prid,
+ 				XFS_QMOPT_QUOTALL | XFS_QMOPT_INHERIT,
+ 				&udqp, &gdqp, &pdqp);
+ 	if (error)
+ 		return error;
+ 
+ 	resblks = XFS_IALLOC_SPACE_RES(mp);
+ 	tp = xfs_trans_alloc(mp, XFS_TRANS_CREATE_TMPFILE);
+ 
+ 	tres = &M_RES(mp)->tr_create_tmpfile;
+ 	error = xfs_trans_reserve(tp, tres, resblks, 0);
+ 	if (error == -ENOSPC) {
+ 		/* No space at all so try a "no-allocation" reservation */
+ 		resblks = 0;
+ 		error = xfs_trans_reserve(tp, tres, 0, 0);
+ 	}
+ 	if (error) {
+ 		cancel_flags = 0;
+ 		goto out_trans_cancel;
+ 	}
+ 
+ 	error = xfs_trans_reserve_quota(tp, mp, udqp, gdqp,
+ 						pdqp, resblks, 1, 0);
+ 	if (error)
+ 		goto out_trans_cancel;
+ 
+ 	error = xfs_dir_ialloc(&tp, dp, mode, 1, 0,
+ 				prid, resblks > 0, &ip, NULL);
+ 	if (error) {
+ 		if (error == -ENOSPC)
+ 			goto out_trans_cancel;
+ 		goto out_trans_abort;
+ 	}
+ 
+ 	if (mp->m_flags & XFS_MOUNT_WSYNC)
+ 		xfs_trans_set_sync(tp);
+ 
+ 	/*
+ 	 * Attach the dquot(s) to the inodes and modify them incore.
+ 	 * These ids of the inode couldn't have changed since the new
+ 	 * inode has been locked ever since it was created.
+ 	 */
+ 	xfs_qm_vop_create_dqattach(tp, ip, udqp, gdqp, pdqp);
+ 
+ 	ip->i_d.di_nlink--;
+ 	error = xfs_iunlink(tp, ip);
+ 	if (error)
+ 		goto out_trans_abort;
+ 
+ 	error = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);
+ 	if (error)
+ 		goto out_release_inode;
+ 
+ 	xfs_qm_dqrele(udqp);
+ 	xfs_qm_dqrele(gdqp);
+ 	xfs_qm_dqrele(pdqp);
+ 
+ 	*ipp = ip;
+ 	return 0;
+ 
+  out_trans_abort:
+ 	cancel_flags |= XFS_TRANS_ABORT;
+  out_trans_cancel:
+ 	xfs_trans_cancel(tp, cancel_flags);
+  out_release_inode:
+ 	/*
+ 	 * Wait until after the current transaction is aborted to
+ 	 * release the inode.  This prevents recursive transactions
+ 	 * and deadlocks from xfs_inactive.
+ 	 */
+ 	if (ip)
+ 		IRELE(ip);
+ 
+ 	xfs_qm_dqrele(udqp);
+ 	xfs_qm_dqrele(gdqp);
+ 	xfs_qm_dqrele(pdqp);
+ 
+ 	return error;
+ }
+ 
+ int
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  xfs_link(
  	xfs_inode_t		*tdp,
  	xfs_inode_t		*sip,
@@@ -1349,7 -1382,7 +1472,11 @@@
  	ASSERT(!S_ISDIR(sip->i_d.di_mode));
  
  	if (XFS_FORCED_SHUTDOWN(mp))
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	error = xfs_qm_dqattach(sip, 0);
  	if (error)
@@@ -1384,7 -1417,7 +1511,11 @@@
  	 */
  	if (unlikely((tdp->i_d.di_flags & XFS_DIFLAG_PROJINHERIT) &&
  		     (xfs_get_projid(tdp) != xfs_get_projid(sip)))) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(EXDEV);
++=======
+ 		error = -EXDEV;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto error_return;
  	}
  
@@@ -2462,7 -2491,7 +2593,11 @@@ xfs_remove
  	trace_xfs_remove(dp, name);
  
  	if (XFS_FORCED_SHUTDOWN(mp))
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	error = xfs_qm_dqattach(dp, 0);
  	if (error)
@@@ -2514,11 -2543,11 +2649,19 @@@
  	if (is_dir) {
  		ASSERT(ip->i_d.di_nlink >= 2);
  		if (ip->i_d.di_nlink != 2) {
++<<<<<<< HEAD
 +			error = XFS_ERROR(ENOTEMPTY);
 +			goto out_trans_cancel;
 +		}
 +		if (!xfs_dir_isempty(ip)) {
 +			error = XFS_ERROR(ENOTEMPTY);
++=======
+ 			error = -ENOTEMPTY;
+ 			goto out_trans_cancel;
+ 		}
+ 		if (!xfs_dir_isempty(ip)) {
+ 			error = -ENOTEMPTY;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			goto out_trans_cancel;
  		}
  
@@@ -2724,7 -2747,7 +2867,11 @@@ xfs_rename
  	 */
  	if (unlikely((target_dp->i_d.di_flags & XFS_DIFLAG_PROJINHERIT) &&
  		     (xfs_get_projid(target_dp) != xfs_get_projid(src_ip)))) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(EXDEV);
++=======
+ 		error = -EXDEV;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto error_return;
  	}
  
@@@ -2772,7 -2795,7 +2919,11 @@@
  			 */
  			if (!(xfs_dir_isempty(target_ip)) ||
  			    (target_ip->i_d.di_nlink > 2)) {
++<<<<<<< HEAD
 +				error = XFS_ERROR(EEXIST);
++=======
+ 				error = -EEXIST;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  				goto error_return;
  			}
  		}
@@@ -3046,7 -3069,7 +3197,11 @@@ cluster_corrupt_out
  	xfs_iflush_abort(iq, false);
  	kmem_free(ilist);
  	xfs_perag_put(pag);
++<<<<<<< HEAD
 +	return XFS_ERROR(EFSCORRUPTED);
++=======
+ 	return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  }
  
  /*
@@@ -3101,7 -3124,7 +3256,11 @@@ xfs_iflush
  	 * as we wait for an empty AIL as part of the unmount process.
  	 */
  	if (XFS_FORCED_SHUTDOWN(mp)) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(EIO);
++=======
+ 		error = -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto abort_out;
  	}
  
@@@ -3144,7 -3167,7 +3303,11 @@@ corrupt_out
  	xfs_buf_relse(bp);
  	xfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);
  cluster_corrupt_out:
++<<<<<<< HEAD
 +	error = XFS_ERROR(EFSCORRUPTED);
++=======
+ 	error = -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  abort_out:
  	/*
  	 * Unlocks the flush lock
@@@ -3338,5 -3331,5 +3501,9 @@@ xfs_iflush_int
  	return 0;
  
  corrupt_out:
++<<<<<<< HEAD
 +	return XFS_ERROR(EFSCORRUPTED);
++=======
+ 	return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  }
diff --cc fs/xfs/xfs_ioctl.c
index c01d09b8b9c4,30983b8ceaa1..000000000000
--- a/fs/xfs/xfs_ioctl.c
+++ b/fs/xfs/xfs_ioctl.c
@@@ -331,10 -305,10 +331,10 @@@ xfs_readlink_by_handle
  		goto out_dput;
  	}
  
- 	error = -xfs_readlink(XFS_I(dentry->d_inode), link);
+ 	error = xfs_readlink(XFS_I(dentry->d_inode), link);
  	if (error)
  		goto out_kfree;
 -	error = readlink_copy(hreq->ohandle, olen, link);
 +	error = do_readlink(hreq->ohandle, olen, link);
  	if (error)
  		goto out_kfree;
  
@@@ -356,10 -330,10 +356,17 @@@ xfs_set_dmattrs
  	int		error;
  
  	if (!capable(CAP_SYS_ADMIN))
++<<<<<<< HEAD
 +		return XFS_ERROR(EPERM);
 +
 +	if (XFS_FORCED_SHUTDOWN(mp))
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EPERM;
+ 
+ 	if (XFS_FORCED_SHUTDOWN(mp))
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	tp = xfs_trans_alloc(mp, XFS_TRANS_SET_DMATTRS);
  	error = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);
@@@ -619,7 -590,7 +623,11 @@@ xfs_attrmulti_by_handle
  	}
  
  	if (copy_to_user(am_hreq.ops, ops, size))
++<<<<<<< HEAD
 +		error = XFS_ERROR(EFAULT);
++=======
+ 		error = -EFAULT;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	kfree(attr_name);
   out_kfree_ops:
@@@ -678,7 -649,7 +686,11 @@@ xfs_ioc_space
  		bf->l_start += XFS_ISIZE(ip);
  		break;
  	default:
++<<<<<<< HEAD
 +		error = XFS_ERROR(EINVAL);
++=======
+ 		error = -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto out_unlock;
  	}
  
@@@ -695,7 -666,7 +707,11 @@@
  	case XFS_IOC_UNRESVSP:
  	case XFS_IOC_UNRESVSP64:
  		if (bf->l_len <= 0) {
++<<<<<<< HEAD
 +			error = XFS_ERROR(EINVAL);
++=======
+ 			error = -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			goto out_unlock;
  		}
  		break;
@@@ -708,7 -679,7 +724,11 @@@
  	    bf->l_start > mp->m_super->s_maxbytes ||
  	    bf->l_start + bf->l_len < 0 ||
  	    bf->l_start + bf->l_len >= mp->m_super->s_maxbytes) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(EINVAL);
++=======
+ 		error = -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto out_unlock;
  	}
  
@@@ -749,7 -720,7 +769,11 @@@
  		break;
  	default:
  		ASSERT(0);
++<<<<<<< HEAD
 +		error = XFS_ERROR(EINVAL);
++=======
+ 		error = -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	if (error)
@@@ -879,10 -850,10 +903,10 @@@ xfs_ioc_fsgeometry
  
  	error = xfs_fs_geometry(mp, &fsgeo, 4);
  	if (error)
- 		return -error;
+ 		return error;
  
  	if (copy_to_user(arg, &fsgeo, sizeof(fsgeo)))
 -		return -EFAULT;
 +		return -XFS_ERROR(EFAULT);
  	return 0;
  }
  
@@@ -1067,16 -1038,16 +1091,26 @@@ xfs_ioctl_setattr
  	trace_xfs_ioctl_setattr(ip);
  
  	if (mp->m_flags & XFS_MOUNT_RDONLY)
++<<<<<<< HEAD
 +		return XFS_ERROR(EROFS);
 +	if (XFS_FORCED_SHUTDOWN(mp))
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EROFS;
+ 	if (XFS_FORCED_SHUTDOWN(mp))
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	/*
  	 * Disallow 32bit project ids when projid32bit feature is not enabled.
  	 */
  	if ((mask & FSX_PROJID) && (fa->fsx_projid > (__uint16_t)-1) &&
  			!xfs_sb_version_hasprojid32bit(&ip->i_mount->m_sb))
++<<<<<<< HEAD
 +		return XFS_ERROR(EINVAL);
++=======
+ 		return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	/*
  	 * If disk quotas is on, we make sure that the dquots do exist on disk,
@@@ -1114,7 -1085,7 +1148,11 @@@
  	 * CAP_FSETID capability is applicable.
  	 */
  	if (!inode_owner_or_capable(VFS_I(ip))) {
++<<<<<<< HEAD
 +		code = XFS_ERROR(EPERM);
++=======
+ 		code = -EPERM;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto error_return;
  	}
  
@@@ -1125,7 -1096,7 +1163,11 @@@
  	 */
  	if (mask & FSX_PROJID) {
  		if (current_user_ns() != &init_user_ns) {
++<<<<<<< HEAD
 +			code = XFS_ERROR(EINVAL);
++=======
+ 			code = -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			goto error_return;
  		}
  
@@@ -1148,7 -1119,7 +1190,11 @@@
  		if (ip->i_d.di_nextents &&
  		    ((ip->i_d.di_extsize << mp->m_sb.sb_blocklog) !=
  		     fa->fsx_extsize)) {
++<<<<<<< HEAD
 +			code = XFS_ERROR(EINVAL);	/* EFBIG? */
++=======
+ 			code = -EINVAL;	/* EFBIG? */
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			goto error_return;
  		}
  
@@@ -1167,7 -1138,7 +1213,11 @@@
  
  			extsize_fsb = XFS_B_TO_FSB(mp, fa->fsx_extsize);
  			if (extsize_fsb > MAXEXTLEN) {
++<<<<<<< HEAD
 +				code = XFS_ERROR(EINVAL);
++=======
+ 				code = -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  				goto error_return;
  			}
  
@@@ -1179,13 -1150,13 +1229,21 @@@
  			} else {
  				size = mp->m_sb.sb_blocksize;
  				if (extsize_fsb > mp->m_sb.sb_agblocks / 2) {
++<<<<<<< HEAD
 +					code = XFS_ERROR(EINVAL);
++=======
+ 					code = -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  					goto error_return;
  				}
  			}
  
  			if (fa->fsx_extsize % size) {
++<<<<<<< HEAD
 +				code = XFS_ERROR(EINVAL);
++=======
+ 				code = -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  				goto error_return;
  			}
  		}
@@@ -1199,7 -1170,7 +1257,11 @@@
  		if ((ip->i_d.di_nextents || ip->i_delayed_blks) &&
  		    (XFS_IS_REALTIME_INODE(ip)) !=
  		    (fa->fsx_xflags & XFS_XFLAG_REALTIME)) {
++<<<<<<< HEAD
 +			code = XFS_ERROR(EINVAL);	/* EFBIG? */
++=======
+ 			code = -EINVAL;	/* EFBIG? */
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			goto error_return;
  		}
  
@@@ -1210,7 -1181,7 +1272,11 @@@
  			if ((mp->m_sb.sb_rblocks == 0) ||
  			    (mp->m_sb.sb_rextsize == 0) ||
  			    (ip->i_d.di_extsize % mp->m_sb.sb_rextsize)) {
++<<<<<<< HEAD
 +				code = XFS_ERROR(EINVAL);
++=======
+ 				code = -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  				goto error_return;
  			}
  		}
@@@ -1224,7 -1195,7 +1290,11 @@@
  		     (fa->fsx_xflags &
  				(XFS_XFLAG_IMMUTABLE | XFS_XFLAG_APPEND))) &&
  		    !capable(CAP_LINUX_IMMUTABLE)) {
++<<<<<<< HEAD
 +			code = XFS_ERROR(EPERM);
++=======
+ 			code = -EPERM;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			goto error_return;
  		}
  	}
@@@ -1401,7 -1353,7 +1471,11 @@@ xfs_getbmap_format(void **ap, struct ge
  
  	/* copy only getbmap portion (not getbmapx) */
  	if (copy_to_user(base, bmv, sizeof(struct getbmap)))
++<<<<<<< HEAD
 +		return XFS_ERROR(EFAULT);
++=======
+ 		return -EFAULT;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	*ap += sizeof(struct getbmap);
  	return 0;
@@@ -1444,7 -1396,7 +1518,11 @@@ xfs_getbmapx_format(void **ap, struct g
  	struct getbmapx __user	*base = *ap;
  
  	if (copy_to_user(base, bmv, sizeof(struct getbmapx)))
++<<<<<<< HEAD
 +		return XFS_ERROR(EFAULT);
++=======
+ 		return -EFAULT;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	*ap += sizeof(struct getbmapx);
  	return 0;
@@@ -1490,33 -1442,33 +1568,53 @@@ xfs_ioc_swapext
  	/* Pull information for the target fd */
  	f = fdget((int)sxp->sx_fdtarget);
  	if (!f.file) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(EINVAL);
++=======
+ 		error = -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto out;
  	}
  
  	if (!(f.file->f_mode & FMODE_WRITE) ||
  	    !(f.file->f_mode & FMODE_READ) ||
  	    (f.file->f_flags & O_APPEND)) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(EBADF);
++=======
+ 		error = -EBADF;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto out_put_file;
  	}
  
  	tmp = fdget((int)sxp->sx_fdtmp);
  	if (!tmp.file) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(EINVAL);
++=======
+ 		error = -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto out_put_file;
  	}
  
  	if (!(tmp.file->f_mode & FMODE_WRITE) ||
  	    !(tmp.file->f_mode & FMODE_READ) ||
  	    (tmp.file->f_flags & O_APPEND)) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(EBADF);
++=======
+ 		error = -EBADF;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto out_put_tmp_file;
  	}
  
  	if (IS_SWAPFILE(file_inode(f.file)) ||
  	    IS_SWAPFILE(file_inode(tmp.file))) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(EINVAL);
++=======
+ 		error = -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto out_put_tmp_file;
  	}
  
@@@ -1524,17 -1476,17 +1622,29 @@@
  	tip = XFS_I(file_inode(tmp.file));
  
  	if (ip->i_mount != tip->i_mount) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(EINVAL);
++=======
+ 		error = -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto out_put_tmp_file;
  	}
  
  	if (ip->i_ino == tip->i_ino) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(EINVAL);
++=======
+ 		error = -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto out_put_tmp_file;
  	}
  
  	if (XFS_FORCED_SHUTDOWN(ip->i_mount)) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(EIO);
++=======
+ 		error = -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto out_put_tmp_file;
  	}
  
@@@ -1702,10 -1654,10 +1812,10 @@@ xfs_file_ioctl
  
  		error = xfs_fs_counts(mp, &out);
  		if (error)
- 			return -error;
+ 			return error;
  
  		if (copy_to_user(arg, &out, sizeof(out)))
 -			return -EFAULT;
 +			return -XFS_ERROR(EFAULT);
  		return 0;
  	}
  
@@@ -1731,10 -1683,10 +1841,10 @@@
  		error = xfs_reserve_blocks(mp, &in, &inout);
  		mnt_drop_write_file(filp);
  		if (error)
- 			return -error;
+ 			return error;
  
  		if (copy_to_user(arg, &inout, sizeof(inout)))
 -			return -EFAULT;
 +			return -XFS_ERROR(EFAULT);
  		return 0;
  	}
  
@@@ -1746,10 -1698,10 +1856,10 @@@
  
  		error = xfs_reserve_blocks(mp, NULL, &out);
  		if (error)
- 			return -error;
+ 			return error;
  
  		if (copy_to_user(arg, &out, sizeof(out)))
 -			return -EFAULT;
 +			return -XFS_ERROR(EFAULT);
  
  		return 0;
  	}
@@@ -1803,10 -1755,9 +1913,9 @@@
  			return -EPERM;
  
  		if (get_user(in, (__uint32_t __user *)arg))
 -			return -EFAULT;
 +			return -XFS_ERROR(EFAULT);
  
- 		error = xfs_fs_goingdown(mp, in);
- 		return -error;
+ 		return xfs_fs_goingdown(mp, in);
  	}
  
  	case XFS_IOC_ERROR_INJECTION: {
@@@ -1816,10 -1767,9 +1925,9 @@@
  			return -EPERM;
  
  		if (copy_from_user(&in, arg, sizeof(in)))
 -			return -EFAULT;
 +			return -XFS_ERROR(EFAULT);
  
- 		error = xfs_errortag_add(in.errtag, mp);
- 		return -error;
+ 		return xfs_errortag_add(in.errtag, mp);
  	}
  
  	case XFS_IOC_ERROR_CLEARALL:
diff --cc fs/xfs/xfs_ioctl32.c
index 944d5baa710a,e65ea67e3ae3..000000000000
--- a/fs/xfs/xfs_ioctl32.c
+++ b/fs/xfs/xfs_ioctl32.c
@@@ -70,10 -70,10 +70,10 @@@ xfs_compat_ioc_fsgeometry_v1
  
  	error = xfs_fs_geometry(mp, &fsgeo, 3);
  	if (error)
- 		return -error;
+ 		return error;
  	/* The 32-bit variant simply has some padding at the end */
  	if (copy_to_user(arg32, &fsgeo, sizeof(struct compat_xfs_fsop_geom_v1)))
 -		return -EFAULT;
 +		return -XFS_ERROR(EFAULT);
  	return 0;
  }
  
@@@ -195,7 -195,7 +195,11 @@@ xfs_bulkstat_one_fmt_compat
  	compat_xfs_bstat_t	__user *p32 = ubuffer;
  
  	if (ubsize < sizeof(*p32))
++<<<<<<< HEAD
 +		return XFS_ERROR(ENOMEM);
++=======
+ 		return -ENOMEM;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	if (put_user(buffer->bs_ino,	  &p32->bs_ino)		||
  	    put_user(buffer->bs_mode,	  &p32->bs_mode)	||
@@@ -218,7 -218,7 +222,11 @@@
  	    put_user(buffer->bs_dmevmask, &p32->bs_dmevmask)	||
  	    put_user(buffer->bs_dmstate,  &p32->bs_dmstate)	||
  	    put_user(buffer->bs_aextents, &p32->bs_aextents))
++<<<<<<< HEAD
 +		return XFS_ERROR(EFAULT);
++=======
+ 		return -EFAULT;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	if (ubused)
  		*ubused = sizeof(*p32);
  	return 0;
@@@ -294,9 -294,9 +302,13 @@@ xfs_compat_ioc_bulkstat
  			xfs_bulkstat_one_compat, sizeof(compat_xfs_bstat_t),
  			bulkreq.ubuffer, &done);
  	} else
++<<<<<<< HEAD
 +		error = XFS_ERROR(EINVAL);
++=======
+ 		error = -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	if (error)
- 		return -error;
+ 		return error;
  
  	if (bulkreq.ocount != NULL) {
  		if (copy_to_user(bulkreq.lastip, &inlast,
@@@ -475,7 -475,7 +487,11 @@@ xfs_compat_attrmulti_by_handle
  	}
  
  	if (copy_to_user(compat_ptr(am_hreq.ops), ops, size))
++<<<<<<< HEAD
 +		error = XFS_ERROR(EFAULT);
++=======
+ 		error = -EFAULT;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	kfree(attr_name);
   out_kfree_ops:
diff --cc fs/xfs/xfs_iomap.c
index ac46fb8eab93,923c044bd26f..000000000000
--- a/fs/xfs/xfs_iomap.c
+++ b/fs/xfs/xfs_iomap.c
@@@ -225,7 -225,7 +225,11 @@@ xfs_iomap_write_direct
  	 * Copy any maps to caller's array and return any error.
  	 */
  	if (nimaps == 0) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(ENOSPC);
++=======
+ 		error = -ENOSPC;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto out_unlock;
  	}
  
@@@ -604,11 -596,11 +608,11 @@@ retry
  				imap, &nimaps, XFS_BMAPI_ENTIRE);
  	switch (error) {
  	case 0:
- 	case ENOSPC:
- 	case EDQUOT:
+ 	case -ENOSPC:
+ 	case -EDQUOT:
  		break;
  	default:
 -		return error;
 +		return XFS_ERROR(error);
  	}
  
  	/*
@@@ -622,7 -614,7 +626,11 @@@
  			error = 0;
  			goto retry;
  		}
++<<<<<<< HEAD
 +		return XFS_ERROR(error ? error : ENOSPC);
++=======
+ 		return error ? error : -ENOSPC;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	if (!(imap[0].br_startblock || XFS_IS_REALTIME_INODE(ip)))
diff --cc fs/xfs/xfs_iops.c
index 73821413e035,d75621ae3e36..000000000000
--- a/fs/xfs/xfs_iops.c
+++ b/fs/xfs/xfs_iops.c
@@@ -171,22 -171,46 +171,44 @@@ xfs_vn_mknod
  	if (unlikely(error))
  		goto out_cleanup_inode;
  
 -#ifdef CONFIG_XFS_POSIX_ACL
  	if (default_acl) {
++<<<<<<< HEAD
 +		error = -xfs_inherit_acl(inode, default_acl);
 +		default_acl = NULL;
 +		if (unlikely(error))
 +			goto out_cleanup_inode;
 +	}
++=======
+ 		error = xfs_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);
+ 		if (error)
+ 			goto out_cleanup_inode;
+ 	}
+ 	if (acl) {
+ 		error = xfs_set_acl(inode, acl, ACL_TYPE_ACCESS);
+ 		if (error)
+ 			goto out_cleanup_inode;
+ 	}
+ #endif
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
 -	if (tmpfile)
 -		d_tmpfile(dentry, inode);
 -	else
 -		d_instantiate(dentry, inode);
  
++<<<<<<< HEAD
 +	d_instantiate(dentry, inode);
 +	return -error;
++=======
+  out_free_acl:
+ 	if (default_acl)
+ 		posix_acl_release(default_acl);
+ 	if (acl)
+ 		posix_acl_release(acl);
+ 	return error;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
   out_cleanup_inode:
 -	if (!tmpfile)
 -		xfs_cleanup_inode(dir, inode, dentry);
 -	iput(inode);
 -	goto out_free_acl;
 -}
 -
 -STATIC int
 -xfs_vn_mknod(
 -	struct inode	*dir,
 -	struct dentry	*dentry,
 -	umode_t		mode,
 -	dev_t		rdev)
 -{
 -	return xfs_generic_create(dir, dentry, mode, rdev, false);
 +	xfs_cleanup_inode(dir, inode, dentry);
 + out_free_acl:
 +	posix_acl_release(default_acl);
 +	return -error;
  }
  
  STATIC int
@@@ -349,8 -373,9 +371,8 @@@ xfs_vn_symlink
  
   out_cleanup_inode:
  	xfs_cleanup_inode(dir, inode, dentry);
 -	iput(inode);
   out:
- 	return -error;
+ 	return error;
  }
  
  STATIC int
@@@ -533,14 -546,14 +555,21 @@@ xfs_setattr_nonsize
  	/* If acls are being inherited, we already have this checked */
  	if (!(flags & XFS_ATTR_NOACL)) {
  		if (mp->m_flags & XFS_MOUNT_RDONLY)
++<<<<<<< HEAD
 +			return XFS_ERROR(EROFS);
 +
 +		if (XFS_FORCED_SHUTDOWN(mp))
 +			return XFS_ERROR(EIO);
++=======
+ 			return -EROFS;
  
- 		error = -inode_change_ok(inode, iattr);
+ 		if (XFS_FORCED_SHUTDOWN(mp))
+ 			return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
+ 
+ 		error = inode_change_ok(inode, iattr);
  		if (error)
 -			return error;
 +			return XFS_ERROR(error);
  	}
  
  	ASSERT((mask & ATTR_SIZE) == 0);
@@@ -700,9 -713,9 +729,13 @@@
  	 * 	     Posix ACL code seems to care about this issue either.
  	 */
  	if ((mask & ATTR_MODE) && !(flags & XFS_ATTR_NOACL)) {
++<<<<<<< HEAD
 +		error = -xfs_acl_chmod(inode);
++=======
+ 		error = posix_acl_chmod(inode, inode->i_mode);
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		if (error)
 -			return error;
 +			return XFS_ERROR(error);
  	}
  
  	return 0;
@@@ -735,14 -748,14 +768,21 @@@ xfs_setattr_size
  	trace_xfs_setattr(ip);
  
  	if (mp->m_flags & XFS_MOUNT_RDONLY)
++<<<<<<< HEAD
 +		return XFS_ERROR(EROFS);
 +
 +	if (XFS_FORCED_SHUTDOWN(mp))
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EROFS;
  
- 	error = -inode_change_ok(inode, iattr);
+ 	if (XFS_FORCED_SHUTDOWN(mp))
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
+ 
+ 	error = inode_change_ok(inode, iattr);
  	if (error)
 -		return error;
 +		return XFS_ERROR(error);
  
  	ASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));
  	ASSERT(S_ISREG(ip->i_d.di_mode));
diff --cc fs/xfs/xfs_itable.c
index cb64f222d607,7e54992bcae9..000000000000
--- a/fs/xfs/xfs_itable.c
+++ b/fs/xfs/xfs_itable.c
@@@ -67,11 -67,11 +67,19 @@@ xfs_bulkstat_one_int
  	*stat = BULKSTAT_RV_NOTHING;
  
  	if (!buffer || xfs_internal_inum(mp, ino))
++<<<<<<< HEAD
 +		return XFS_ERROR(EINVAL);
 +
 +	buf = kmem_alloc(sizeof(*buf), KM_SLEEP | KM_MAYFAIL);
 +	if (!buf)
 +		return XFS_ERROR(ENOMEM);
++=======
+ 		return -EINVAL;
+ 
+ 	buf = kmem_alloc(sizeof(*buf), KM_SLEEP | KM_MAYFAIL);
+ 	if (!buf)
+ 		return -ENOMEM;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	error = xfs_iget(mp, NULL, ino,
  			 (XFS_IGET_DONTCACHE | XFS_IGET_UNTRUSTED),
@@@ -154,9 -154,9 +162,15 @@@ xfs_bulkstat_one_fmt
  	const xfs_bstat_t	*buffer)
  {
  	if (ubsize < sizeof(*buffer))
++<<<<<<< HEAD
 +		return XFS_ERROR(ENOMEM);
 +	if (copy_to_user(ubuffer, buffer, sizeof(*buffer)))
 +		return XFS_ERROR(EFAULT);
++=======
+ 		return -ENOMEM;
+ 	if (copy_to_user(ubuffer, buffer, sizeof(*buffer)))
+ 		return -EFAULT;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	if (ubused)
  		*ubused = sizeof(*buffer);
  	return 0;
@@@ -551,8 -551,8 +565,13 @@@ xfs_bulkstat_single
  				sizeof(xfs_bstat_t), buffer, done))
  			return error;
  		if (count == 0 || (xfs_ino_t)*lastinop != ino)
++<<<<<<< HEAD
 +			return error == EFSCORRUPTED ?
 +				XFS_ERROR(EINVAL) : error;
++=======
+ 			return error == -EFSCORRUPTED ?
+ 				EINVAL : error;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		else
  			return 0;
  	}
@@@ -661,7 -661,7 +680,11 @@@ xfs_inumbers
  		if (bufidx == bcount) {
  			long written;
  			if (formatter(ubuffer, buffer, bufidx, &written)) {
++<<<<<<< HEAD
 +				error = XFS_ERROR(EFAULT);
++=======
+ 				error = -EFAULT;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  				break;
  			}
  			ubuffer += written;
@@@ -688,7 -688,7 +711,11 @@@
  		if (bufidx) {
  			long written;
  			if (formatter(ubuffer, buffer, bufidx, &written))
++<<<<<<< HEAD
 +				error = XFS_ERROR(EFAULT);
++=======
+ 				error = -EFAULT;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			else
  				*count += bufidx;
  		}
diff --cc fs/xfs/xfs_log.c
index 9aebc448e74e,7647818b8c8a..000000000000
--- a/fs/xfs/xfs_log.c
+++ b/fs/xfs/xfs_log.c
@@@ -283,7 -283,7 +283,11 @@@ xlog_grant_head_wait
  	return 0;
  shutdown:
  	list_del_init(&tic->t_queue);
++<<<<<<< HEAD
 +	return XFS_ERROR(EIO);
++=======
+ 	return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  }
  
  /*
@@@ -377,7 -377,7 +381,11 @@@ xfs_log_regrant
  	int			error = 0;
  
  	if (XLOG_FORCED_SHUTDOWN(log))
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	XFS_STATS_INC(xs_try_logspace);
  
@@@ -446,7 -446,7 +454,11 @@@ xfs_log_reserve
  	ASSERT(client == XFS_TRANSACTION || client == XFS_LOG);
  
  	if (XLOG_FORCED_SHUTDOWN(log))
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	XFS_STATS_INC(xs_try_logspace);
  
@@@ -454,7 -454,7 +466,11 @@@
  	tic = xlog_ticket_alloc(log, unit_bytes, cnt, client, permanent,
  				KM_SLEEP | KM_MAYFAIL);
  	if (!tic)
++<<<<<<< HEAD
 +		return XFS_ERROR(ENOMEM);
++=======
+ 		return -ENOMEM;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	tic->t_trans_type = t_type;
  	*ticp = tic;
@@@ -1369,14 -1369,8 +1385,19 @@@ xlog_alloc_log
  
  	xlog_get_iclog_buffer_size(mp, log);
  
++<<<<<<< HEAD
 +	/*
 +	 * Use a NULL block for the extra log buffer used during splits so that
 +	 * it will trigger errors if we ever try to do IO on it without first
 +	 * having set it up properly.
 +	 */
 +	error = ENOMEM;
 +	bp = xfs_buf_alloc(mp->m_logdev_targp, XFS_BUF_DADDR_NULL,
 +			   BTOBB(log->l_iclog_size), 0);
++=======
+ 	error = -ENOMEM;
+ 	bp = xfs_buf_alloc(mp->m_logdev_targp, 0, BTOBB(log->l_iclog_size), 0);
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	if (!bp)
  		goto out_free_log;
  
@@@ -2366,7 -2360,7 +2387,11 @@@ xlog_write
  
  			ophdr = xlog_write_setup_ophdr(log, ptr, ticket, flags);
  			if (!ophdr)
++<<<<<<< HEAD
 +				return XFS_ERROR(EIO);
++=======
+ 				return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  			xlog_write_adv_cnt(&ptr, &len, &log_offset,
  					   sizeof(struct xlog_op_header));
@@@ -2865,7 -2859,7 +2890,11 @@@ restart
  	spin_lock(&log->l_icloglock);
  	if (XLOG_FORCED_SHUTDOWN(log)) {
  		spin_unlock(&log->l_icloglock);
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	iclog = log->l_iclog;
@@@ -3053,7 -3047,7 +3082,11 @@@ xlog_state_release_iclog
  	int		sync = 0;	/* do we sync? */
  
  	if (iclog->ic_state & XLOG_STATE_IOERROR)
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	ASSERT(atomic_read(&iclog->ic_refcnt) > 0);
  	if (!atomic_dec_and_lock(&iclog->ic_refcnt, &log->l_icloglock))
@@@ -3061,7 -3055,7 +3094,11 @@@
  
  	if (iclog->ic_state & XLOG_STATE_IOERROR) {
  		spin_unlock(&log->l_icloglock);
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	ASSERT(iclog->ic_state == XLOG_STATE_ACTIVE ||
  	       iclog->ic_state == XLOG_STATE_WANT_SYNC);
@@@ -3178,7 -3172,7 +3215,11 @@@ _xfs_log_force
  	iclog = log->l_iclog;
  	if (iclog->ic_state & XLOG_STATE_IOERROR) {
  		spin_unlock(&log->l_icloglock);
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	/* If the head iclog is not active nor dirty, we just attach
@@@ -3216,7 -3210,7 +3257,11 @@@
  				spin_unlock(&log->l_icloglock);
  
  				if (xlog_state_release_iclog(log, iclog))
++<<<<<<< HEAD
 +					return XFS_ERROR(EIO);
++=======
+ 					return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  				if (log_flushed)
  					*log_flushed = 1;
@@@ -3252,7 -3246,7 +3297,11 @@@ maybe_sleep
  		 */
  		if (iclog->ic_state & XLOG_STATE_IOERROR) {
  			spin_unlock(&log->l_icloglock);
++<<<<<<< HEAD
 +			return XFS_ERROR(EIO);
++=======
+ 			return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  		XFS_STATS_INC(xs_log_force_sleep);
  		xlog_wait(&iclog->ic_force_wait, &log->l_icloglock);
@@@ -3262,7 -3256,7 +3311,11 @@@
  		 * and the memory read should be atomic.
  		 */
  		if (iclog->ic_state & XLOG_STATE_IOERROR)
++<<<<<<< HEAD
 +			return XFS_ERROR(EIO);
++=======
+ 			return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		if (log_flushed)
  			*log_flushed = 1;
  	} else {
@@@ -3330,7 -3324,7 +3383,11 @@@ try_again
  	iclog = log->l_iclog;
  	if (iclog->ic_state & XLOG_STATE_IOERROR) {
  		spin_unlock(&log->l_icloglock);
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	do {
@@@ -3381,7 -3375,7 +3438,11 @@@
  			xlog_state_switch_iclogs(log, iclog, 0);
  			spin_unlock(&log->l_icloglock);
  			if (xlog_state_release_iclog(log, iclog))
++<<<<<<< HEAD
 +				return XFS_ERROR(EIO);
++=======
+ 				return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			if (log_flushed)
  				*log_flushed = 1;
  			spin_lock(&log->l_icloglock);
@@@ -3396,7 -3390,7 +3457,11 @@@
  			 */
  			if (iclog->ic_state & XLOG_STATE_IOERROR) {
  				spin_unlock(&log->l_icloglock);
++<<<<<<< HEAD
 +				return XFS_ERROR(EIO);
++=======
+ 				return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			}
  			XFS_STATS_INC(xs_log_force_sleep);
  			xlog_wait(&iclog->ic_force_wait, &log->l_icloglock);
@@@ -3406,7 -3400,7 +3471,11 @@@
  			 * and the memory read should be atomic.
  			 */
  			if (iclog->ic_state & XLOG_STATE_IOERROR)
++<<<<<<< HEAD
 +				return XFS_ERROR(EIO);
++=======
+ 				return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  			if (log_flushed)
  				*log_flushed = 1;
diff --cc fs/xfs/xfs_log_cil.c
index 10ec878c3990,2ee4388dc682..000000000000
--- a/fs/xfs/xfs_log_cil.c
+++ b/fs/xfs/xfs_log_cil.c
@@@ -632,7 -634,7 +632,11 @@@ out_abort_free_ticket
  	xfs_log_ticket_put(tic);
  out_abort:
  	xlog_cil_committed(ctx, XFS_LI_ABORTED);
++<<<<<<< HEAD
 +	return XFS_ERROR(EIO);
++=======
+ 	return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  }
  
  static void
diff --cc fs/xfs/xfs_log_recover.c
index 81ca79be7d35,fbc2362d13e3..000000000000
--- a/fs/xfs/xfs_log_recover.c
+++ b/fs/xfs/xfs_log_recover.c
@@@ -194,7 -194,7 +194,11 @@@ xlog_bread_noalign
  	bp->b_error = 0;
  
  	if (XFS_FORCED_SHUTDOWN(log->l_mp))
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	xfs_buf_iorequest(bp);
  	error = xfs_buf_iowait(bp);
@@@ -330,14 -330,14 +334,22 @@@ xlog_header_check_recover
  		xlog_header_check_dump(mp, head);
  		XFS_ERROR_REPORT("xlog_header_check_recover(1)",
  				 XFS_ERRLEVEL_HIGH, mp);
++<<<<<<< HEAD
 +		return XFS_ERROR(EFSCORRUPTED);
++=======
+ 		return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	} else if (unlikely(!uuid_equal(&mp->m_sb.sb_uuid, &head->h_fs_uuid))) {
  		xfs_warn(mp,
  	"dirty log entry has mismatched uuid - can't recover");
  		xlog_header_check_dump(mp, head);
  		XFS_ERROR_REPORT("xlog_header_check_recover(2)",
  				 XFS_ERRLEVEL_HIGH, mp);
++<<<<<<< HEAD
 +		return XFS_ERROR(EFSCORRUPTED);
++=======
+ 		return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	return 0;
  }
@@@ -364,7 -364,7 +376,11 @@@ xlog_header_check_mount
  		xlog_header_check_dump(mp, head);
  		XFS_ERROR_REPORT("xlog_header_check_mount",
  				 XFS_ERRLEVEL_HIGH, mp);
++<<<<<<< HEAD
 +		return XFS_ERROR(EFSCORRUPTED);
++=======
+ 		return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	return 0;
  }
@@@ -539,7 -539,7 +555,11 @@@ xlog_find_verify_log_record
  			xfs_warn(log->l_mp,
  		"Log inconsistent (didn't find previous header)");
  			ASSERT(0);
++<<<<<<< HEAD
 +			error = XFS_ERROR(EIO);
++=======
+ 			error = -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			goto out;
  		}
  
@@@ -818,11 -820,10 +840,18 @@@ validate_head
  		start_blk = head_blk - num_scan_bblks; /* don't read head_blk */
  
  		/* start ptr at last block ptr before head_blk */
++<<<<<<< HEAD
 +		if ((error = xlog_find_verify_log_record(log, start_blk,
 +							&head_blk, 0)) == -1) {
 +			error = XFS_ERROR(EIO);
 +			goto bp_err;
 +		} else if (error)
++=======
+ 		error = xlog_find_verify_log_record(log, start_blk, &head_blk, 0);
+ 		if (error == 1)
+ 			error = -EIO;
+ 		if (error)
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			goto bp_err;
  	} else {
  		start_blk = 0;
@@@ -835,12 -838,11 +866,20 @@@
  			ASSERT(start_blk <= INT_MAX &&
  				(xfs_daddr_t) log_bbnum-start_blk >= 0);
  			ASSERT(head_blk <= INT_MAX);
++<<<<<<< HEAD
 +			if ((error = xlog_find_verify_log_record(log,
 +							start_blk, &new_blk,
 +							(int)head_blk)) == -1) {
 +				error = XFS_ERROR(EIO);
 +				goto bp_err;
 +			} else if (error)
++=======
+ 			error = xlog_find_verify_log_record(log, start_blk,
+ 							&new_blk, (int)head_blk);
+ 			if (error == 1)
+ 				error = -EIO;
+ 			if (error)
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  				goto bp_err;
  			if (new_blk != log_bbnum)
  				head_blk = new_blk;
@@@ -961,7 -963,7 +1000,11 @@@ xlog_find_tail
  		xfs_warn(log->l_mp, "%s: couldn't find sync record", __func__);
  		xlog_put_bp(bp);
  		ASSERT(0);
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	/* find blk_no of tail of log */
@@@ -1141,7 -1143,7 +1184,11 @@@ xlog_find_zeroed
  		 */
  		xfs_warn(log->l_mp,
  			"Log inconsistent or not a log (last==0, first!=1)");
++<<<<<<< HEAD
 +		error = XFS_ERROR(EINVAL);
++=======
+ 		error = -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto bp_err;
  	}
  
@@@ -1179,12 -1181,11 +1226,20 @@@
  	 * Potentially backup over partial log record write.  We don't need
  	 * to search the end of the log because we know it is zero.
  	 */
++<<<<<<< HEAD
 +	if ((error = xlog_find_verify_log_record(log, start_blk,
 +				&last_blk, 0)) == -1) {
 +	    error = XFS_ERROR(EIO);
 +	    goto bp_err;
 +	} else if (error)
 +	    goto bp_err;
++=======
+ 	error = xlog_find_verify_log_record(log, start_blk, &last_blk, 0);
+ 	if (error == 1)
+ 		error = -EIO;
+ 	if (error)
+ 		goto bp_err;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	*blk_no = last_blk;
  bp_err:
@@@ -1354,7 -1355,7 +1409,11 @@@ xlog_clear_stale_blocks
  		if (unlikely(head_block < tail_block || head_block >= log->l_logBBsize)) {
  			XFS_ERROR_REPORT("xlog_clear_stale_blocks(1)",
  					 XFS_ERRLEVEL_LOW, log->l_mp);
++<<<<<<< HEAD
 +			return XFS_ERROR(EFSCORRUPTED);
++=======
+ 			return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  		tail_distance = tail_block + (log->l_logBBsize - head_block);
  	} else {
@@@ -1366,7 -1367,7 +1425,11 @@@
  		if (unlikely(head_block >= tail_block || head_cycle != (tail_cycle + 1))){
  			XFS_ERROR_REPORT("xlog_clear_stale_blocks(2)",
  					 XFS_ERRLEVEL_LOW, log->l_mp);
++<<<<<<< HEAD
 +			return XFS_ERROR(EFSCORRUPTED);
++=======
+ 			return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  		tail_distance = tail_block - head_block;
  	}
@@@ -1551,7 -1552,7 +1614,11 @@@ xlog_recover_add_to_trans
  			xfs_warn(log->l_mp, "%s: bad header magic number",
  				__func__);
  			ASSERT(0);
++<<<<<<< HEAD
 +			return XFS_ERROR(EIO);
++=======
+ 			return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  		if (len == sizeof(xfs_trans_header_t))
  			xlog_recover_add_item(&trans->r_itemq);
@@@ -1581,7 -1582,7 +1648,11 @@@
  				  in_f->ilf_size);
  			ASSERT(0);
  			kmem_free(ptr);
++<<<<<<< HEAD
 +			return XFS_ERROR(EIO);
++=======
+ 			return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  
  		item->ri_total = in_f->ilf_size;
@@@ -1702,7 -1703,7 +1773,11 @@@ xlog_recover_reorder_trans
  			 */
  			if (!list_empty(&sort_list))
  				list_splice_init(&sort_list, &trans->r_itemq);
++<<<<<<< HEAD
 +			error = XFS_ERROR(EIO);
++=======
+ 			error = -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			goto out;
  		}
  	}
@@@ -1943,7 -1944,7 +2018,11 @@@ xlog_recover_do_inode_buffer
  				item, bp);
  			XFS_ERROR_REPORT("xlog_recover_do_inode_buf",
  					 XFS_ERRLEVEL_LOW, mp);
++<<<<<<< HEAD
 +			return XFS_ERROR(EFSCORRUPTED);
++=======
+ 			return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  
  		buffer_nextp = (xfs_agino_t *)xfs_buf_offset(bp,
@@@ -2493,7 -2497,7 +2572,11 @@@ xlog_recover_buffer_pass2
  	bp = xfs_buf_read(mp->m_ddev_targp, buf_f->blf_blkno, buf_f->blf_len,
  			  buf_flags, NULL);
  	if (!bp)
++<<<<<<< HEAD
 +		return XFS_ERROR(ENOMEM);
++=======
+ 		return -ENOMEM;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	error = bp->b_error;
  	if (error) {
  		xfs_buf_ioerror_alert(bp, "xlog_recover_do..(read#1)");
@@@ -2994,12 -2977,12 +3077,20 @@@ xlog_recover_dquot_pass2
  	recddq = item->ri_buf[1].i_addr;
  	if (recddq == NULL) {
  		xfs_alert(log->l_mp, "NULL dquot in %s.", __func__);
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	if (item->ri_buf[1].i_len < sizeof(xfs_disk_dquot_t)) {
  		xfs_alert(log->l_mp, "dquot too small (%d) in %s.",
  			item->ri_buf[1].i_len, __func__);
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	/*
@@@ -3025,19 -3008,12 +3116,23 @@@
  	error = xfs_dqcheck(mp, recddq, dq_f->qlf_id, 0, XFS_QMOPT_DOWARN,
  			   "xlog_recover_dquot_pass2 (log copy)");
  	if (error)
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	ASSERT(dq_f->qlf_len == 1);
  
 +	/*
 +	 * At this point we are assuming that the dquots have been allocated
 +	 * and hence the buffer has valid dquots stamped in it. It should,
 +	 * therefore, pass verifier validation. If the dquot is bad, then the
 +	 * we'll return an error here, so we don't need to specifically check
 +	 * the dquot in the buffer after the verifier has run.
 +	 */
  	error = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp, dq_f->qlf_blkno,
  				   XFS_FSB_TO_BB(mp, dq_f->qlf_len), 0, &bp,
 -				   NULL);
 +				   &xfs_dquot_buf_ops);
  	if (error)
  		return error;
  
@@@ -3045,6 -3021,18 +3140,21 @@@
  	ddq = (xfs_disk_dquot_t *)xfs_buf_offset(bp, dq_f->qlf_boffset);
  
  	/*
++<<<<<<< HEAD
++=======
+ 	 * At least the magic num portion should be on disk because this
+ 	 * was among a chunk of dquots created earlier, and we did some
+ 	 * minimal initialization then.
+ 	 */
+ 	error = xfs_dqcheck(mp, ddq, dq_f->qlf_id, 0, XFS_QMOPT_DOWARN,
+ 			   "xlog_recover_dquot_pass2");
+ 	if (error) {
+ 		xfs_buf_relse(bp);
+ 		return -EIO;
+ 	}
+ 
+ 	/*
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	 * If the dquot has an LSN in it, recover the dquot only if it's less
  	 * than the lsn of the transaction we are replaying.
  	 */
@@@ -3402,7 -3390,7 +3512,11 @@@ xlog_recover_commit_pass1
  		xfs_warn(log->l_mp, "%s: invalid item type (%d)",
  			__func__, ITEM_TYPE(item));
  		ASSERT(0);
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  }
  
@@@ -3438,7 -3426,7 +3552,11 @@@ xlog_recover_commit_pass2
  		xfs_warn(log->l_mp, "%s: invalid item type (%d)",
  			__func__, ITEM_TYPE(item));
  		ASSERT(0);
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  }
  
@@@ -3573,7 -3561,7 +3691,11 @@@ xlog_recover_process_data
  
  	/* check the log format matches our own - else we can't recover */
  	if (xlog_header_check_recover(log->l_mp, rhead))
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	while ((dp < lp) && num_logops) {
  		ASSERT(dp + sizeof(xlog_op_header_t) <= lp);
@@@ -3584,7 -3572,7 +3706,11 @@@
  			xfs_warn(log->l_mp, "%s: bad clientid 0x%x",
  					__func__, ohead->oh_clientid);
  			ASSERT(0);
++<<<<<<< HEAD
 +			return XFS_ERROR(EIO);
++=======
+ 			return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  		tid = be32_to_cpu(ohead->oh_tid);
  		hash = XLOG_RHASH(tid);
@@@ -3598,7 -3586,7 +3724,11 @@@
  				xfs_warn(log->l_mp, "%s: bad length 0x%x",
  					__func__, be32_to_cpu(ohead->oh_len));
  				WARN_ON(1);
++<<<<<<< HEAD
 +				return XFS_ERROR(EIO);
++=======
+ 				return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			}
  			flags = ohead->oh_flags & ~XLOG_END_TRANS;
  			if (flags & XLOG_WAS_CONT_TRANS)
@@@ -3620,7 -3608,7 +3750,11 @@@
  				xfs_warn(log->l_mp, "%s: bad transaction",
  					__func__);
  				ASSERT(0);
++<<<<<<< HEAD
 +				error = XFS_ERROR(EIO);
++=======
+ 				error = -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  				break;
  			case 0:
  			case XLOG_CONTINUE_TRANS:
@@@ -3631,7 -3619,7 +3765,11 @@@
  				xfs_warn(log->l_mp, "%s: bad flag 0x%x",
  					__func__, flags);
  				ASSERT(0);
++<<<<<<< HEAD
 +				error = XFS_ERROR(EIO);
++=======
+ 				error = -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  				break;
  			}
  			if (error) {
@@@ -3682,7 -3670,7 +3820,11 @@@ xlog_recover_process_efi
  			 */
  			set_bit(XFS_EFI_RECOVERED, &efip->efi_flags);
  			xfs_efi_release(efip, efip->efi_format.efi_nextents);
++<<<<<<< HEAD
 +			return XFS_ERROR(EIO);
++=======
+ 			return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  	}
  
@@@ -4031,14 -4019,14 +4173,22 @@@ xlog_valid_rec_header
  	if (unlikely(rhead->h_magicno != cpu_to_be32(XLOG_HEADER_MAGIC_NUM))) {
  		XFS_ERROR_REPORT("xlog_valid_rec_header(1)",
  				XFS_ERRLEVEL_LOW, log->l_mp);
++<<<<<<< HEAD
 +		return XFS_ERROR(EFSCORRUPTED);
++=======
+ 		return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	if (unlikely(
  	    (!rhead->h_version ||
  	    (be32_to_cpu(rhead->h_version) & (~XLOG_VERSION_OKBITS))))) {
  		xfs_warn(log->l_mp, "%s: unrecognised log version (%d).",
  			__func__, be32_to_cpu(rhead->h_version));
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	/* LR body must have data or it wouldn't have been written */
@@@ -4046,12 -4034,12 +4196,20 @@@
  	if (unlikely( hlen <= 0 || hlen > INT_MAX )) {
  		XFS_ERROR_REPORT("xlog_valid_rec_header(2)",
  				XFS_ERRLEVEL_LOW, log->l_mp);
++<<<<<<< HEAD
 +		return XFS_ERROR(EFSCORRUPTED);
++=======
+ 		return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	if (unlikely( blkno > log->l_logBBsize || blkno > INT_MAX )) {
  		XFS_ERROR_REPORT("xlog_valid_rec_header(3)",
  				XFS_ERRLEVEL_LOW, log->l_mp);
++<<<<<<< HEAD
 +		return XFS_ERROR(EFSCORRUPTED);
++=======
+ 		return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	return 0;
  }
@@@ -4428,7 -4416,7 +4586,11 @@@ xlog_do_recover
  
  	if (XFS_FORCED_SHUTDOWN(log->l_mp)) {
  		xfs_buf_relse(bp);
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	xfs_buf_iorequest(bp);
diff --cc fs/xfs/xfs_mount.c
index fa7129e99c36,d5c44a6bdb5b..000000000000
--- a/fs/xfs/xfs_mount.c
+++ b/fs/xfs/xfs_mount.c
@@@ -76,7 -76,7 +76,11 @@@ xfs_uuid_mount
  
  	if (uuid_is_nil(uuid)) {
  		xfs_warn(mp, "Filesystem has nil UUID - can't mount");
++<<<<<<< HEAD
 +		return XFS_ERROR(EINVAL);
++=======
+ 		return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	mutex_lock(&xfs_uuid_table_mutex);
@@@ -104,7 -104,7 +108,11 @@@
   out_duplicate:
  	mutex_unlock(&xfs_uuid_table_mutex);
  	xfs_warn(mp, "Filesystem has duplicate UUID %pU - can't mount", uuid);
++<<<<<<< HEAD
 +	return XFS_ERROR(EINVAL);
++=======
+ 	return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  }
  
  STATIC void
@@@ -391,7 -392,7 +399,11 @@@ xfs_update_alignment(xfs_mount_t *mp
  			xfs_warn(mp,
  		"alignment check failed: sunit/swidth vs. blocksize(%d)",
  				sbp->sb_blocksize);
++<<<<<<< HEAD
 +			return XFS_ERROR(EINVAL);
++=======
+ 			return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		} else {
  			/*
  			 * Convert the stripe unit and width to FSBs.
@@@ -401,14 -402,14 +413,22 @@@
  				xfs_warn(mp,
  			"alignment check failed: sunit/swidth vs. agsize(%d)",
  					 sbp->sb_agblocks);
++<<<<<<< HEAD
 +				return XFS_ERROR(EINVAL);
++=======
+ 				return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			} else if (mp->m_dalign) {
  				mp->m_swidth = XFS_BB_TO_FSBT(mp, mp->m_swidth);
  			} else {
  				xfs_warn(mp,
  			"alignment check failed: sunit(%d) less than bsize(%d)",
  					 mp->m_dalign, sbp->sb_blocksize);
++<<<<<<< HEAD
 +				return XFS_ERROR(EINVAL);
++=======
+ 				return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			}
  		}
  
@@@ -428,7 -429,7 +448,11 @@@
  		} else {
  			xfs_warn(mp,
  	"cannot change alignment: superblock does not support data alignment");
++<<<<<<< HEAD
 +			return XFS_ERROR(EINVAL);
++=======
+ 			return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  	} else if ((mp->m_flags & XFS_MOUNT_NOALIGN) != XFS_MOUNT_NOALIGN &&
  		    xfs_sb_version_hasdalign(&mp->m_sb)) {
@@@ -555,7 -556,7 +579,11 @@@ xfs_check_sizes(xfs_mount_t *mp
  	d = (xfs_daddr_t)XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks);
  	if (XFS_BB_TO_FSB(mp, d) != mp->m_sb.sb_dblocks) {
  		xfs_warn(mp, "filesystem size mismatch detected");
++<<<<<<< HEAD
 +		return XFS_ERROR(EFBIG);
++=======
+ 		return -EFBIG;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	bp = xfs_buf_read_uncached(mp->m_ddev_targp,
  					d - XFS_FSS_TO_BB(mp, 1),
@@@ -570,7 -571,7 +598,11 @@@
  		d = (xfs_daddr_t)XFS_FSB_TO_BB(mp, mp->m_sb.sb_logblocks);
  		if (XFS_BB_TO_FSB(mp, d) != mp->m_sb.sb_logblocks) {
  			xfs_warn(mp, "log size mismatch detected");
++<<<<<<< HEAD
 +			return XFS_ERROR(EFBIG);
++=======
+ 			return -EFBIG;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  		bp = xfs_buf_read_uncached(mp->m_logdev_targp,
  					d - XFS_FSB_TO_BB(mp, 1),
@@@ -809,7 -816,7 +841,11 @@@ xfs_mountfs
  	if (!sbp->sb_logblocks) {
  		xfs_warn(mp, "no log defined");
  		XFS_ERROR_REPORT("xfs_mountfs", XFS_ERRLEVEL_LOW, mp);
++<<<<<<< HEAD
 +		error = XFS_ERROR(EFSCORRUPTED);
++=======
+ 		error = -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto out_free_perag;
  	}
  
@@@ -869,7 -876,7 +905,11 @@@
  		xfs_iunlock(rip, XFS_ILOCK_EXCL);
  		XFS_ERROR_REPORT("xfs_mountfs_int(2)", XFS_ERRLEVEL_LOW,
  				 mp);
++<<<<<<< HEAD
 +		error = XFS_ERROR(EFSCORRUPTED);
++=======
+ 		error = -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto out_rele_rip;
  	}
  	mp->m_rootip = rip;	/* save it */
@@@ -1145,7 -1152,7 +1185,11 @@@ xfs_mod_incore_sb_unlocked
  		lcounter += delta;
  		if (lcounter < 0) {
  			ASSERT(0);
++<<<<<<< HEAD
 +			return XFS_ERROR(EINVAL);
++=======
+ 			return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  		mp->m_sb.sb_icount = lcounter;
  		return 0;
@@@ -1154,7 -1161,7 +1198,11 @@@
  		lcounter += delta;
  		if (lcounter < 0) {
  			ASSERT(0);
++<<<<<<< HEAD
 +			return XFS_ERROR(EINVAL);
++=======
+ 			return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  		mp->m_sb.sb_ifree = lcounter;
  		return 0;
@@@ -1184,7 -1191,7 +1232,11 @@@
  			 * blocks if were allowed to.
  			 */
  			if (!rsvd)
++<<<<<<< HEAD
 +				return XFS_ERROR(ENOSPC);
++=======
+ 				return -ENOSPC;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  			lcounter = (long long)mp->m_resblks_avail + delta;
  			if (lcounter >= 0) {
@@@ -1195,7 -1202,7 +1247,11 @@@
  				"Filesystem \"%s\": reserve blocks depleted! "
  				"Consider increasing reserve pool size.",
  				mp->m_fsname);
++<<<<<<< HEAD
 +			return XFS_ERROR(ENOSPC);
++=======
+ 			return -ENOSPC;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  
  		mp->m_sb.sb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);
@@@ -1204,7 -1211,7 +1260,11 @@@
  		lcounter = (long long)mp->m_sb.sb_frextents;
  		lcounter += delta;
  		if (lcounter < 0) {
++<<<<<<< HEAD
 +			return XFS_ERROR(ENOSPC);
++=======
+ 			return -ENOSPC;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  		mp->m_sb.sb_frextents = lcounter;
  		return 0;
@@@ -1213,7 -1220,7 +1273,11 @@@
  		lcounter += delta;
  		if (lcounter < 0) {
  			ASSERT(0);
++<<<<<<< HEAD
 +			return XFS_ERROR(EINVAL);
++=======
+ 			return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  		mp->m_sb.sb_dblocks = lcounter;
  		return 0;
@@@ -1222,7 -1229,7 +1286,11 @@@
  		scounter += delta;
  		if (scounter < 0) {
  			ASSERT(0);
++<<<<<<< HEAD
 +			return XFS_ERROR(EINVAL);
++=======
+ 			return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  		mp->m_sb.sb_agcount = scounter;
  		return 0;
@@@ -1231,7 -1238,7 +1299,11 @@@
  		scounter += delta;
  		if (scounter < 0) {
  			ASSERT(0);
++<<<<<<< HEAD
 +			return XFS_ERROR(EINVAL);
++=======
+ 			return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  		mp->m_sb.sb_imax_pct = scounter;
  		return 0;
@@@ -1240,7 -1247,7 +1312,11 @@@
  		scounter += delta;
  		if (scounter < 0) {
  			ASSERT(0);
++<<<<<<< HEAD
 +			return XFS_ERROR(EINVAL);
++=======
+ 			return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  		mp->m_sb.sb_rextsize = scounter;
  		return 0;
@@@ -1249,7 -1256,7 +1325,11 @@@
  		scounter += delta;
  		if (scounter < 0) {
  			ASSERT(0);
++<<<<<<< HEAD
 +			return XFS_ERROR(EINVAL);
++=======
+ 			return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  		mp->m_sb.sb_rbmblocks = scounter;
  		return 0;
@@@ -1258,7 -1265,7 +1338,11 @@@
  		lcounter += delta;
  		if (lcounter < 0) {
  			ASSERT(0);
++<<<<<<< HEAD
 +			return XFS_ERROR(EINVAL);
++=======
+ 			return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  		mp->m_sb.sb_rblocks = lcounter;
  		return 0;
@@@ -1267,7 -1274,7 +1351,11 @@@
  		lcounter += delta;
  		if (lcounter < 0) {
  			ASSERT(0);
++<<<<<<< HEAD
 +			return XFS_ERROR(EINVAL);
++=======
+ 			return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  		mp->m_sb.sb_rextents = lcounter;
  		return 0;
@@@ -1276,13 -1283,13 +1364,21 @@@
  		scounter += delta;
  		if (scounter < 0) {
  			ASSERT(0);
++<<<<<<< HEAD
 +			return XFS_ERROR(EINVAL);
++=======
+ 			return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  		mp->m_sb.sb_rextslog = scounter;
  		return 0;
  	default:
  		ASSERT(0);
++<<<<<<< HEAD
 +		return XFS_ERROR(EINVAL);
++=======
+ 		return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  }
  
diff --cc fs/xfs/xfs_mru_cache.c
index 967b183589be,1eb6f3df698c..000000000000
--- a/fs/xfs/xfs_mru_cache.c
+++ b/fs/xfs/xfs_mru_cache.c
@@@ -448,36 -434,21 +448,45 @@@ xfs_mru_cache_insert
  
  	ASSERT(mru && mru->lists);
  	if (!mru || !mru->lists)
- 		return EINVAL;
+ 		return -EINVAL;
  
++<<<<<<< HEAD
 +	elem = kmem_zone_zalloc(xfs_mru_elem_zone, KM_SLEEP);
 +	if (!elem)
 +		return ENOMEM;
++=======
+ 	if (radix_tree_preload(GFP_KERNEL))
+ 		return -ENOMEM;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
 +
 +	if (radix_tree_preload(GFP_KERNEL)) {
 +		error = ENOMEM;
 +		goto out_free_item;
 +	}
  
  	INIT_LIST_HEAD(&elem->list_node);
  	elem->key = key;
 +	elem->value = value;
  
  	spin_lock(&mru->lock);
++<<<<<<< HEAD
 +
 +	error = -radix_tree_insert(&mru->store, key, elem);
++=======
+ 	error = radix_tree_insert(&mru->store, key, elem);
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	radix_tree_preload_end();
 -	if (!error)
 -		_xfs_mru_cache_list_insert(mru, elem);
 +	if (error) {
 +		spin_unlock(&mru->lock);
 +		goto out_free_item;
 +	}
 +	_xfs_mru_cache_list_insert(mru, elem);
 +
  	spin_unlock(&mru->lock);
  
 +	return 0;
 +out_free_item:
 +	kmem_zone_free(xfs_mru_elem_zone, elem);
  	return error;
  }
  
diff --cc fs/xfs/xfs_qm.c
index 9adbe7ac52c8,ba284f6469db..000000000000
--- a/fs/xfs/xfs_qm.c
+++ b/fs/xfs/xfs_qm.c
@@@ -708,6 -671,10 +708,13 @@@ xfs_qm_init_quotainfo
  
  	qinf = mp->m_quotainfo = kmem_zalloc(sizeof(xfs_quotainfo_t), KM_SLEEP);
  
++<<<<<<< HEAD
++=======
+ 	error = list_lru_init(&qinf->qi_lru);
+ 	if (error)
+ 		goto out_free_qinf;
+ 
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	/*
  	 * See if quotainodes are setup, and if not, allocate them,
  	 * and change the superblock accordingly.
@@@ -1261,7 -1226,7 +1268,11 @@@ xfs_qm_dqusage_adjust
  	 */
  	if (xfs_is_quota_inode(&mp->m_sb, ino)) {
  		*res = BULKSTAT_RV_NOTHING;
++<<<<<<< HEAD
 +		return XFS_ERROR(EINVAL);
++=======
+ 		return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	/*
@@@ -1867,10 -1706,8 +1878,15 @@@ xfs_qm_vop_dqalloc
  						 XFS_QMOPT_DOWARN,
  						 &gq);
  			if (error) {
++<<<<<<< HEAD
 +				if (uq)
 +					xfs_qm_dqrele(uq);
 +				ASSERT(error != ENOENT);
 +				return error;
++=======
+ 				ASSERT(error != -ENOENT);
+ 				goto error_rele;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			}
  			xfs_dqunlock(gq);
  			lockflags = XFS_ILOCK_SHARED;
diff --cc fs/xfs/xfs_qm_bhv.c
index e9be63abd8d2,2c61e61b0205..000000000000
--- a/fs/xfs/xfs_qm_bhv.c
+++ b/fs/xfs/xfs_qm_bhv.c
@@@ -117,7 -117,7 +117,11 @@@ xfs_qm_newmount
  			(uquotaondisk ? " usrquota" : ""),
  			(gquotaondisk ? " grpquota" : ""),
  			(pquotaondisk ? " prjquota" : ""));
++<<<<<<< HEAD
 +		return XFS_ERROR(EPERM);
++=======
+ 		return -EPERM;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	if (XFS_IS_QUOTA_ON(mp) || quotaondisk) {
diff --cc fs/xfs/xfs_qm_syscalls.c
index e6c26d564b17,80f2d77d929a..000000000000
--- a/fs/xfs/xfs_qm_syscalls.c
+++ b/fs/xfs/xfs_qm_syscalls.c
@@@ -64,10 -64,10 +64,14 @@@ xfs_qm_scall_quotaoff
  	/*
  	 * No file system can have quotas enabled on disk but not in core.
  	 * Note that quota utilities (like quotaoff) _expect_
- 	 * errno == EEXIST here.
+ 	 * errno == -EEXIST here.
  	 */
  	if ((mp->m_qflags & flags) == 0)
++<<<<<<< HEAD
 +		return XFS_ERROR(EEXIST);
++=======
+ 		return -EEXIST;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	error = 0;
  
  	flags &= (XFS_ALL_QUOTA_ACCT | XFS_ALL_QUOTA_ENFD);
@@@ -284,7 -284,7 +288,11 @@@ xfs_qm_scall_trunc_qfiles
  	    (flags & ~XFS_DQ_ALLTYPES)) {
  		xfs_debug(mp, "%s: flags=%x m_qflags=%x",
  			__func__, flags, mp->m_qflags);
++<<<<<<< HEAD
 +		return XFS_ERROR(EINVAL);
++=======
+ 		return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	if (flags & XFS_DQ_USER) {
@@@ -328,7 -328,7 +336,11 @@@ xfs_qm_scall_quotaon
  	if (flags == 0) {
  		xfs_debug(mp, "%s: zero flags, m_qflags=%x",
  			__func__, mp->m_qflags);
++<<<<<<< HEAD
 +		return XFS_ERROR(EINVAL);
++=======
+ 		return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	/* No fs can turn on quotas with a delayed effect */
@@@ -351,13 -351,13 +363,21 @@@
  		xfs_debug(mp,
  			"%s: Can't enforce without acct, flags=%x sbflags=%x",
  			__func__, flags, mp->m_sb.sb_qflags);
++<<<<<<< HEAD
 +		return XFS_ERROR(EINVAL);
++=======
+ 		return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	/*
  	 * If everything's up to-date incore, then don't waste time.
  	 */
  	if ((mp->m_qflags & flags) == flags)
++<<<<<<< HEAD
 +		return XFS_ERROR(EEXIST);
++=======
+ 		return -EEXIST;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	/*
  	 * Change sb_qflags on disk but not incore mp->qflags
@@@ -372,7 -372,7 +392,11 @@@
  	 * There's nothing to change if it's the same.
  	 */
  	if ((qf & flags) == flags && sbflags == 0)
++<<<<<<< HEAD
 +		return XFS_ERROR(EEXIST);
++=======
+ 		return -EEXIST;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	sbflags |= XFS_SB_QFLAGS;
  
  	if ((error = xfs_qm_write_sb_changes(mp, sbflags)))
@@@ -390,7 -390,7 +414,11 @@@
  		return 0;
  
  	if (! XFS_IS_QUOTA_RUNNING(mp))
++<<<<<<< HEAD
 +		return XFS_ERROR(ESRCH);
++=======
+ 		return -ESRCH;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	/*
  	 * Switch on quota enforcement in core.
@@@ -850,7 -850,7 +878,11 @@@ xfs_qm_scall_getquota
  	 * our utility programs are concerned.
  	 */
  	if (XFS_IS_DQUOT_UNINITIALIZED(dqp)) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(ENOENT);
++=======
+ 		error = -ENOENT;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto out_put;
  	}
  
diff --cc fs/xfs/xfs_rtalloc.c
index ec5ca65c6211,b741d7286990..000000000000
--- a/fs/xfs/xfs_rtalloc.c
+++ b/fs/xfs/xfs_rtalloc.c
@@@ -863,7 -863,7 +863,11 @@@ xfs_growfs_rt_alloc
  					XFS_BMAPI_METADATA, &firstblock,
  					resblks, &map, &nmap, &flist);
  		if (!error && nmap < 1)
++<<<<<<< HEAD
 +			error = XFS_ERROR(ENOSPC);
++=======
+ 			error = -ENOSPC;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		if (error)
  			goto error_cancel;
  		/*
@@@ -903,7 -903,7 +907,11 @@@
  			bp = xfs_trans_get_buf(tp, mp->m_ddev_targp, d,
  				mp->m_bsize, 0);
  			if (bp == NULL) {
++<<<<<<< HEAD
 +				error = XFS_ERROR(EIO);
++=======
+ 				error = -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  error_cancel:
  				xfs_trans_cancel(tp, cancelflags);
  				goto error;
@@@ -962,11 -962,11 +970,19 @@@ xfs_growfs_rt
  	 * Initial error checking.
  	 */
  	if (!capable(CAP_SYS_ADMIN))
++<<<<<<< HEAD
 +		return XFS_ERROR(EPERM);
 +	if (mp->m_rtdev_targp == NULL || mp->m_rbmip == NULL ||
 +	    (nrblocks = in->newblocks) <= sbp->sb_rblocks ||
 +	    (sbp->sb_rblocks && (in->extsize != sbp->sb_rextsize)))
 +		return XFS_ERROR(EINVAL);
++=======
+ 		return -EPERM;
+ 	if (mp->m_rtdev_targp == NULL || mp->m_rbmip == NULL ||
+ 	    (nrblocks = in->newblocks) <= sbp->sb_rblocks ||
+ 	    (sbp->sb_rblocks && (in->extsize != sbp->sb_rextsize)))
+ 		return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	if ((error = xfs_sb_validate_fsb_count(sbp, nrblocks)))
  		return error;
  	/*
@@@ -1001,7 -1001,7 +1017,11 @@@
  	 * since we'll log basically the whole summary file at once.
  	 */
  	if (nrsumblocks > (mp->m_sb.sb_logblocks >> 1))
++<<<<<<< HEAD
 +		return XFS_ERROR(EINVAL);
++=======
+ 		return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	/*
  	 * Get the old block counts for bitmap and summary inodes.
  	 * These can't change since other growfs callers are locked out.
@@@ -1247,7 -1247,7 +1267,11 @@@ xfs_rtmount_init
  	if (mp->m_rtdev_targp == NULL) {
  		xfs_warn(mp,
  	"Filesystem has a realtime volume, use rtdev=device option");
++<<<<<<< HEAD
 +		return XFS_ERROR(ENODEV);
++=======
+ 		return -ENODEV;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	mp->m_rsumlevels = sbp->sb_rextslog + 1;
  	mp->m_rsumsize =
@@@ -1263,7 -1263,7 +1287,11 @@@
  		xfs_warn(mp, "realtime mount -- %llu != %llu",
  			(unsigned long long) XFS_BB_TO_FSB(mp, d),
  			(unsigned long long) mp->m_sb.sb_rblocks);
++<<<<<<< HEAD
 +		return XFS_ERROR(EFBIG);
++=======
+ 		return -EFBIG;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	bp = xfs_buf_read_uncached(mp->m_rtdev_targp,
  					d - XFS_FSB_TO_BB(mp, 1),
diff --cc fs/xfs/xfs_super.c
index 86f14eb42642,f2e5f8a503d2..000000000000
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@@ -446,7 -446,7 +446,11 @@@ done
  	     mp->m_logbufs > XLOG_MAX_ICLOGS)) {
  		xfs_warn(mp, "invalid logbufs value: %d [not %d-%d]",
  			mp->m_logbufs, XLOG_MIN_ICLOGS, XLOG_MAX_ICLOGS);
++<<<<<<< HEAD
 +		return XFS_ERROR(EINVAL);
++=======
+ 		return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	if (mp->m_logbsize != -1 &&
  	    mp->m_logbsize !=  0 &&
@@@ -456,7 -456,7 +460,11 @@@
  		xfs_warn(mp,
  			"invalid logbufsize: %d [not 16k,32k,64k,128k or 256k]",
  			mp->m_logbsize);
++<<<<<<< HEAD
 +		return XFS_ERROR(EINVAL);
++=======
+ 		return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	if (iosizelog) {
@@@ -465,7 -465,7 +473,11 @@@
  			xfs_warn(mp, "invalid log iosize: %d [not %d-%d]",
  				iosizelog, XFS_MIN_IO_LOG,
  				XFS_MAX_IO_LOG);
++<<<<<<< HEAD
 +			return XFS_ERROR(EINVAL);
++=======
+ 			return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  
  		mp->m_flags |= XFS_MOUNT_DFLT_IOSIZE;
@@@ -1350,14 -1336,14 +1362,22 @@@ xfs_finish_flags
  			   mp->m_logbsize < mp->m_sb.sb_logsunit) {
  			xfs_warn(mp,
  		"logbuf size must be greater than or equal to log stripe size");
++<<<<<<< HEAD
 +			return XFS_ERROR(EINVAL);
++=======
+ 			return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  	} else {
  		/* Fail a mount if the logbuf is larger than 32K */
  		if (mp->m_logbsize > XLOG_BIG_RECORD_BSIZE) {
  			xfs_warn(mp,
  		"logbuf size for version 1 logs must be 16K or 32K");
++<<<<<<< HEAD
 +			return XFS_ERROR(EINVAL);
++=======
+ 			return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  	}
  
@@@ -1369,7 -1355,7 +1389,11 @@@
  		xfs_warn(mp,
  "Cannot mount a V5 filesystem as %s. %s is always enabled for V5 filesystems.",
  			MNTOPT_NOATTR2, MNTOPT_ATTR2);
++<<<<<<< HEAD
 +		return XFS_ERROR(EINVAL);
++=======
+ 		return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	/*
@@@ -1386,7 -1372,7 +1410,11 @@@
  	if ((mp->m_sb.sb_flags & XFS_SBF_READONLY) && !ronly) {
  		xfs_warn(mp,
  			"cannot mount a read-only filesystem as read-write");
++<<<<<<< HEAD
 +		return XFS_ERROR(EROFS);
++=======
+ 		return -EROFS;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	if ((mp->m_qflags & (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE)) &&
@@@ -1394,7 -1380,7 +1422,11 @@@
  	    !xfs_sb_version_has_pquotino(&mp->m_sb)) {
  		xfs_warn(mp,
  		  "Super block does not support project and group quota together");
++<<<<<<< HEAD
 +		return XFS_ERROR(EINVAL);
++=======
+ 		return -EINVAL;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	return 0;
diff --cc fs/xfs/xfs_symlink.c
index 0816b4018dfc,6a944a2cd36f..000000000000
--- a/fs/xfs/xfs_symlink.c
+++ b/fs/xfs/xfs_symlink.c
@@@ -75,7 -76,7 +75,11 @@@ xfs_readlink_bmap
  		bp = xfs_buf_read(mp->m_ddev_targp, d, BTOBB(byte_cnt), 0,
  				  &xfs_symlink_buf_ops);
  		if (!bp)
++<<<<<<< HEAD
 +			return XFS_ERROR(ENOMEM);
++=======
+ 			return -ENOMEM;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		error = bp->b_error;
  		if (error) {
  			xfs_buf_ioerror_alert(bp, __func__);
@@@ -134,7 -135,7 +138,11 @@@ xfs_readlink
  	trace_xfs_readlink(ip);
  
  	if (XFS_FORCED_SHUTDOWN(mp))
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	xfs_ilock(ip, XFS_ILOCK_SHARED);
  
@@@ -147,7 -148,7 +155,11 @@@
  			 __func__, (unsigned long long) ip->i_ino,
  			 (long long) pathlen);
  		ASSERT(0);
++<<<<<<< HEAD
 +		error = XFS_ERROR(EFSCORRUPTED);
++=======
+ 		error = -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto out;
  	}
  
@@@ -202,14 -203,14 +214,22 @@@ xfs_symlink
  	trace_xfs_symlink(dp, link_name);
  
  	if (XFS_FORCED_SHUTDOWN(mp))
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	/*
  	 * Check component lengths of the target path name.
  	 */
  	pathlen = strlen(target_path);
  	if (pathlen >= MAXPATHLEN)      /* total string too long */
++<<<<<<< HEAD
 +		return XFS_ERROR(ENAMETOOLONG);
++=======
+ 		return -ENAMETOOLONG;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	udqp = gdqp = NULL;
  	prid = xfs_get_initial_prid(dp);
@@@ -253,7 -254,7 +273,11 @@@
  	 * Check whether the directory allows new symlinks or not.
  	 */
  	if (dp->i_d.di_flags & XFS_DIFLAG_NOSYMLINKS) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(EPERM);
++=======
+ 		error = -EPERM;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto error_return;
  	}
  
@@@ -561,7 -562,7 +585,11 @@@ xfs_inactive_symlink
  	trace_xfs_inactive_symlink(ip);
  
  	if (XFS_FORCED_SHUTDOWN(mp))
++<<<<<<< HEAD
 +		return XFS_ERROR(EIO);
++=======
+ 		return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  	xfs_ilock(ip, XFS_ILOCK_EXCL);
  
@@@ -579,7 -580,7 +607,11 @@@
  			 __func__, (unsigned long long)ip->i_ino, pathlen);
  		xfs_iunlock(ip, XFS_ILOCK_EXCL);
  		ASSERT(0);
++<<<<<<< HEAD
 +		return XFS_ERROR(EFSCORRUPTED);
++=======
+ 		return -EFSCORRUPTED;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  
  	if (ip->i_df.if_flags & XFS_IFINLINE) {
diff --cc fs/xfs/xfs_trans.c
index e15fe67baa7b,30e8e3410955..000000000000
--- a/fs/xfs/xfs_trans.c
+++ b/fs/xfs/xfs_trans.c
@@@ -190,7 -190,7 +190,11 @@@ xfs_trans_reserve
  					  -((int64_t)blocks), rsvd);
  		if (error != 0) {
  			current_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);
++<<<<<<< HEAD
 +			return XFS_ERROR(ENOSPC);
++=======
+ 			return -ENOSPC;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  		tp->t_blk_res += blocks;
  	}
@@@ -241,7 -241,7 +245,11 @@@
  		error = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,
  					  -((int64_t)rtextents), rsvd);
  		if (error) {
++<<<<<<< HEAD
 +			error = XFS_ERROR(ENOSPC);
++=======
+ 			error = -ENOSPC;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			goto undo_log;
  		}
  		tp->t_rtx_res += rtextents;
@@@ -874,7 -874,7 +882,11 @@@ xfs_trans_commit
  		goto out_unreserve;
  
  	if (XFS_FORCED_SHUTDOWN(mp)) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(EIO);
++=======
+ 		error = -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		goto out_unreserve;
  	}
  
@@@ -917,7 -917,7 +929,11 @@@ out_unreserve
  	if (tp->t_ticket) {
  		commit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);
  		if (commit_lsn == -1 && !error)
++<<<<<<< HEAD
 +			error = XFS_ERROR(EIO);
++=======
+ 			error = -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	current_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);
  	xfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);
diff --cc fs/xfs/xfs_trans_buf.c
index fe41e8efbe96,96c898e7ac9a..000000000000
--- a/fs/xfs/xfs_trans_buf.c
+++ b/fs/xfs/xfs_trans_buf.c
@@@ -266,7 -266,7 +266,11 @@@ xfs_trans_read_buf_map
  		bp = xfs_buf_read_map(target, map, nmaps, flags, ops);
  		if (!bp)
  			return (flags & XBF_TRYLOCK) ?
++<<<<<<< HEAD
 +					EAGAIN : XFS_ERROR(ENOMEM);
++=======
+ 					-EAGAIN : -ENOMEM;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  
  		if (bp->b_error) {
  			error = bp->b_error;
@@@ -286,7 -286,7 +290,11 @@@
  				if (((xfs_req_num++) % xfs_error_mod) == 0) {
  					xfs_buf_relse(bp);
  					xfs_debug(mp, "Returning error!");
++<<<<<<< HEAD
 +					return XFS_ERROR(EIO);
++=======
+ 					return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  				}
  			}
  		}
@@@ -354,7 -354,7 +362,11 @@@
  		if (XFS_FORCED_SHUTDOWN(mp)) {
  			trace_xfs_trans_read_buf_shut(bp, _RET_IP_);
  			*bpp = NULL;
++<<<<<<< HEAD
 +			return XFS_ERROR(EIO);
++=======
+ 			return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  		}
  
  
@@@ -371,7 -371,7 +383,11 @@@
  	if (bp == NULL) {
  		*bpp = NULL;
  		return (flags & XBF_TRYLOCK) ?
++<<<<<<< HEAD
 +					0 : XFS_ERROR(ENOMEM);
++=======
+ 					0 : -ENOMEM;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  	}
  	if (bp->b_error) {
  		error = bp->b_error;
@@@ -395,7 -395,7 +411,11 @@@
  						   SHUTDOWN_META_IO_ERROR);
  				xfs_buf_relse(bp);
  				xfs_debug(mp, "Returning trans error!");
++<<<<<<< HEAD
 +				return XFS_ERROR(EIO);
++=======
+ 				return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  			}
  		}
  	}
@@@ -413,7 -413,7 +433,11 @@@ shutdown_abort
  	trace_xfs_trans_read_buf_shut(bp, _RET_IP_);
  	xfs_buf_relse(bp);
  	*bpp = NULL;
++<<<<<<< HEAD
 +	return XFS_ERROR(EIO);
++=======
+ 	return -EIO;
++>>>>>>> 2451337dd043 (xfs: global error sign conversion)
  }
  
  /*
diff --git a/fs/xfs/libxfs/xfs_alloc.c b/fs/xfs/libxfs/xfs_alloc.c
index a088553e76d7..eff34218f405 100644
--- a/fs/xfs/libxfs/xfs_alloc.c
+++ b/fs/xfs/libxfs/xfs_alloc.c
@@ -483,9 +483,9 @@ xfs_agfl_read_verify(
 		return;
 
 	if (!xfs_buf_verify_cksum(bp, XFS_AGFL_CRC_OFF))
-		xfs_buf_ioerror(bp, EFSBADCRC);
+		xfs_buf_ioerror(bp, -EFSBADCRC);
 	else if (!xfs_agfl_verify(bp))
-		xfs_buf_ioerror(bp, EFSCORRUPTED);
+		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 
 	if (bp->b_error)
 		xfs_verifier_error(bp);
@@ -503,7 +503,7 @@ xfs_agfl_write_verify(
 		return;
 
 	if (!xfs_agfl_verify(bp)) {
-		xfs_buf_ioerror(bp, EFSCORRUPTED);
+		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 		xfs_verifier_error(bp);
 		return;
 	}
@@ -559,7 +559,7 @@ xfs_alloc_update_counters(
 	xfs_trans_agblocks_delta(tp, len);
 	if (unlikely(be32_to_cpu(agf->agf_freeblks) >
 		     be32_to_cpu(agf->agf_length)))
-		return EFSCORRUPTED;
+		return -EFSCORRUPTED;
 
 	xfs_alloc_log_agf(tp, agbp, XFS_AGF_FREEBLKS);
 	return 0;
@@ -2238,11 +2238,11 @@ xfs_agf_read_verify(
 
 	if (xfs_sb_version_hascrc(&mp->m_sb) &&
 	    !xfs_buf_verify_cksum(bp, XFS_AGF_CRC_OFF))
-		xfs_buf_ioerror(bp, EFSBADCRC);
+		xfs_buf_ioerror(bp, -EFSBADCRC);
 	else if (XFS_TEST_ERROR(!xfs_agf_verify(mp, bp), mp,
 				XFS_ERRTAG_ALLOC_READ_AGF,
 				XFS_RANDOM_ALLOC_READ_AGF))
-		xfs_buf_ioerror(bp, EFSCORRUPTED);
+		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 
 	if (bp->b_error)
 		xfs_verifier_error(bp);
@@ -2256,7 +2256,7 @@ xfs_agf_write_verify(
 	struct xfs_buf_log_item	*bip = bp->b_fspriv;
 
 	if (!xfs_agf_verify(mp, bp)) {
-		xfs_buf_ioerror(bp, EFSCORRUPTED);
+		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 		xfs_verifier_error(bp);
 		return;
 	}
@@ -2605,11 +2605,11 @@ xfs_free_extent(
 	 */
 	args.agno = XFS_FSB_TO_AGNO(args.mp, bno);
 	if (args.agno >= args.mp->m_sb.sb_agcount)
-		return EFSCORRUPTED;
+		return -EFSCORRUPTED;
 
 	args.agbno = XFS_FSB_TO_AGBNO(args.mp, bno);
 	if (args.agbno >= args.mp->m_sb.sb_agblocks)
-		return EFSCORRUPTED;
+		return -EFSCORRUPTED;
 
 	args.pag = xfs_perag_get(args.mp, args.agno);
 	ASSERT(args.pag);
@@ -2621,7 +2621,7 @@ xfs_free_extent(
 	/* validate the extent size is legal now we have the agf locked */
 	if (args.agbno + len >
 			be32_to_cpu(XFS_BUF_TO_AGF(args.agbp)->agf_length)) {
-		error = EFSCORRUPTED;
+		error = -EFSCORRUPTED;
 		goto error0;
 	}
 
diff --git a/fs/xfs/libxfs/xfs_alloc_btree.c b/fs/xfs/libxfs/xfs_alloc_btree.c
index 8358f1ded94d..e0e83e24d3ef 100644
--- a/fs/xfs/libxfs/xfs_alloc_btree.c
+++ b/fs/xfs/libxfs/xfs_alloc_btree.c
@@ -355,9 +355,9 @@ xfs_allocbt_read_verify(
 	struct xfs_buf	*bp)
 {
 	if (!xfs_btree_sblock_verify_crc(bp))
-		xfs_buf_ioerror(bp, EFSBADCRC);
+		xfs_buf_ioerror(bp, -EFSBADCRC);
 	else if (!xfs_allocbt_verify(bp))
-		xfs_buf_ioerror(bp, EFSCORRUPTED);
+		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 
 	if (bp->b_error) {
 		trace_xfs_btree_corrupt(bp, _RET_IP_);
@@ -371,7 +371,7 @@ xfs_allocbt_write_verify(
 {
 	if (!xfs_allocbt_verify(bp)) {
 		trace_xfs_btree_corrupt(bp, _RET_IP_);
-		xfs_buf_ioerror(bp, EFSCORRUPTED);
+		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 		xfs_verifier_error(bp);
 		return;
 	}
* Unmerged path fs/xfs/libxfs/xfs_attr.c
* Unmerged path fs/xfs/libxfs/xfs_attr_leaf.c
* Unmerged path fs/xfs/libxfs/xfs_attr_remote.c
* Unmerged path fs/xfs/libxfs/xfs_bmap.c
* Unmerged path fs/xfs/libxfs/xfs_bmap_btree.c
* Unmerged path fs/xfs/libxfs/xfs_btree.c
* Unmerged path fs/xfs/libxfs/xfs_da_btree.c
* Unmerged path fs/xfs/libxfs/xfs_dir2.c
* Unmerged path fs/xfs/libxfs/xfs_dir2_block.c
diff --git a/fs/xfs/libxfs/xfs_dir2_data.c b/fs/xfs/libxfs/xfs_dir2_data.c
index bae8b5b8d1c2..af9b36de3f70 100644
--- a/fs/xfs/libxfs/xfs_dir2_data.c
+++ b/fs/xfs/libxfs/xfs_dir2_data.c
@@ -98,7 +98,7 @@ __xfs_dir3_data_check(
 		break;
 	default:
 		XFS_ERROR_REPORT("Bad Magic", XFS_ERRLEVEL_LOW, mp);
-		return EFSCORRUPTED;
+		return -EFSCORRUPTED;
 	}
 
 	/*
@@ -254,7 +254,7 @@ xfs_dir3_data_reada_verify(
 		xfs_dir3_data_verify(bp);
 		return;
 	default:
-		xfs_buf_ioerror(bp, EFSCORRUPTED);
+		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 		xfs_verifier_error(bp);
 		break;
 	}
@@ -268,9 +268,9 @@ xfs_dir3_data_read_verify(
 
 	if (xfs_sb_version_hascrc(&mp->m_sb) &&
 	     !xfs_buf_verify_cksum(bp, XFS_DIR3_DATA_CRC_OFF))
-		 xfs_buf_ioerror(bp, EFSBADCRC);
+		 xfs_buf_ioerror(bp, -EFSBADCRC);
 	else if (!xfs_dir3_data_verify(bp))
-		xfs_buf_ioerror(bp, EFSCORRUPTED);
+		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 
 	if (bp->b_error)
 		xfs_verifier_error(bp);
@@ -285,7 +285,7 @@ xfs_dir3_data_write_verify(
 	struct xfs_dir3_blk_hdr	*hdr3 = bp->b_addr;
 
 	if (!xfs_dir3_data_verify(bp)) {
-		xfs_buf_ioerror(bp, EFSCORRUPTED);
+		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 		xfs_verifier_error(bp);
 		return;
 	}
* Unmerged path fs/xfs/libxfs/xfs_dir2_leaf.c
* Unmerged path fs/xfs/libxfs/xfs_dir2_node.c
* Unmerged path fs/xfs/libxfs/xfs_dir2_sf.c
diff --git a/fs/xfs/libxfs/xfs_dquot_buf.c b/fs/xfs/libxfs/xfs_dquot_buf.c
index c2ac0c611ad8..bb969337efc8 100644
--- a/fs/xfs/libxfs/xfs_dquot_buf.c
+++ b/fs/xfs/libxfs/xfs_dquot_buf.c
@@ -257,9 +257,9 @@ xfs_dquot_buf_read_verify(
 	struct xfs_mount	*mp = bp->b_target->bt_mount;
 
 	if (!xfs_dquot_buf_verify_crc(mp, bp))
-		xfs_buf_ioerror(bp, EFSBADCRC);
+		xfs_buf_ioerror(bp, -EFSBADCRC);
 	else if (!xfs_dquot_buf_verify(mp, bp))
-		xfs_buf_ioerror(bp, EFSCORRUPTED);
+		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 
 	if (bp->b_error)
 		xfs_verifier_error(bp);
@@ -277,7 +277,7 @@ xfs_dquot_buf_write_verify(
 	struct xfs_mount	*mp = bp->b_target->bt_mount;
 
 	if (!xfs_dquot_buf_verify(mp, bp)) {
-		xfs_buf_ioerror(bp, EFSCORRUPTED);
+		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 		xfs_verifier_error(bp);
 		return;
 	}
* Unmerged path fs/xfs/libxfs/xfs_ialloc.c
diff --git a/fs/xfs/libxfs/xfs_ialloc_btree.c b/fs/xfs/libxfs/xfs_ialloc_btree.c
index 726f83a681a5..c9b06f30fe86 100644
--- a/fs/xfs/libxfs/xfs_ialloc_btree.c
+++ b/fs/xfs/libxfs/xfs_ialloc_btree.c
@@ -272,9 +272,9 @@ xfs_inobt_read_verify(
 	struct xfs_buf	*bp)
 {
 	if (!xfs_btree_sblock_verify_crc(bp))
-		xfs_buf_ioerror(bp, EFSBADCRC);
+		xfs_buf_ioerror(bp, -EFSBADCRC);
 	else if (!xfs_inobt_verify(bp))
-		xfs_buf_ioerror(bp, EFSCORRUPTED);
+		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 
 	if (bp->b_error) {
 		trace_xfs_btree_corrupt(bp, _RET_IP_);
@@ -288,7 +288,7 @@ xfs_inobt_write_verify(
 {
 	if (!xfs_inobt_verify(bp)) {
 		trace_xfs_btree_corrupt(bp, _RET_IP_);
-		xfs_buf_ioerror(bp, EFSCORRUPTED);
+		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 		xfs_verifier_error(bp);
 		return;
 	}
* Unmerged path fs/xfs/libxfs/xfs_inode_buf.c
* Unmerged path fs/xfs/libxfs/xfs_inode_fork.c
* Unmerged path fs/xfs/libxfs/xfs_sb.c
diff --git a/fs/xfs/libxfs/xfs_symlink_remote.c b/fs/xfs/libxfs/xfs_symlink_remote.c
index 23c2f2577c8d..5782f037eab4 100644
--- a/fs/xfs/libxfs/xfs_symlink_remote.c
+++ b/fs/xfs/libxfs/xfs_symlink_remote.c
@@ -133,9 +133,9 @@ xfs_symlink_read_verify(
 		return;
 
 	if (!xfs_buf_verify_cksum(bp, XFS_SYMLINK_CRC_OFF))
-		xfs_buf_ioerror(bp, EFSBADCRC);
+		xfs_buf_ioerror(bp, -EFSBADCRC);
 	else if (!xfs_symlink_verify(bp))
-		xfs_buf_ioerror(bp, EFSCORRUPTED);
+		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 
 	if (bp->b_error)
 		xfs_verifier_error(bp);
@@ -153,7 +153,7 @@ xfs_symlink_write_verify(
 		return;
 
 	if (!xfs_symlink_verify(bp)) {
-		xfs_buf_ioerror(bp, EFSCORRUPTED);
+		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 		xfs_verifier_error(bp);
 		return;
 	}
diff --git a/fs/xfs/xfs_acl.c b/fs/xfs/xfs_acl.c
index fd4e8ffd7012..be16d52d4b09 100644
--- a/fs/xfs/xfs_acl.c
+++ b/fs/xfs/xfs_acl.c
@@ -156,7 +156,7 @@ xfs_get_acl(struct inode *inode, int type)
 	if (!xfs_acl)
 		return ERR_PTR(-ENOMEM);
 
-	error = -xfs_attr_get(ip, ea_name, (unsigned char *)xfs_acl,
+	error = xfs_attr_get(ip, ea_name, (unsigned char *)xfs_acl,
 							&len, ATTR_ROOT);
 	if (error) {
 		/*
@@ -219,7 +219,7 @@ xfs_set_acl(struct inode *inode, int type, struct posix_acl *acl)
 		len -= sizeof(struct xfs_acl_entry) *
 			 (XFS_ACL_MAX_ENTRIES(ip->i_mount) - acl->a_count);
 
-		error = -xfs_attr_set(ip, ea_name, (unsigned char *)xfs_acl,
+		error = xfs_attr_set(ip, ea_name, (unsigned char *)xfs_acl,
 				len, ATTR_ROOT);
 
 		kmem_free(xfs_acl);
@@ -227,7 +227,7 @@ xfs_set_acl(struct inode *inode, int type, struct posix_acl *acl)
 		/*
 		 * A NULL ACL argument means we want to remove the ACL.
 		 */
-		error = -xfs_attr_remove(ip, ea_name, ATTR_ROOT);
+		error = xfs_attr_remove(ip, ea_name, ATTR_ROOT);
 
 		/*
 		 * If the attribute didn't exist to start with that's fine.
@@ -253,7 +253,7 @@ xfs_set_mode(struct inode *inode, umode_t mode)
 		iattr.ia_mode = mode;
 		iattr.ia_ctime = current_fs_time(inode->i_sb);
 
-		error = -xfs_setattr_nonsize(XFS_I(inode), &iattr, XFS_ATTR_NOACL);
+		error = xfs_setattr_nonsize(XFS_I(inode), &iattr, XFS_ATTR_NOACL);
 	}
 
 	return error;
* Unmerged path fs/xfs/xfs_aops.c
* Unmerged path fs/xfs/xfs_attr_inactive.c
* Unmerged path fs/xfs/xfs_attr_list.c
* Unmerged path fs/xfs/xfs_bmap_util.c
diff --git a/fs/xfs/xfs_buf.c b/fs/xfs/xfs_buf.c
index 27f11e5a03ca..2a77a6626df5 100644
--- a/fs/xfs/xfs_buf.c
+++ b/fs/xfs/xfs_buf.c
@@ -182,7 +182,7 @@ xfs_buf_get_maps(
 	bp->b_maps = kmem_zalloc(map_count * sizeof(struct xfs_buf_map),
 				KM_NOFS);
 	if (!bp->b_maps)
-		return ENOMEM;
+		return -ENOMEM;
 	return 0;
 }
 
@@ -395,7 +395,7 @@ retry:
 		if (unlikely(page == NULL)) {
 			if (flags & XBF_READ_AHEAD) {
 				bp->b_page_count = i;
-				error = ENOMEM;
+				error = -ENOMEM;
 				goto out_free_pages;
 			}
 
@@ -516,7 +516,7 @@ _xfs_buf_find(
 	eofs = XFS_FSB_TO_BB(btp->bt_mount, btp->bt_mount->m_sb.sb_dblocks);
 	if (blkno < 0 || blkno >= eofs) {
 		/*
-		 * XXX (dgc): we should really be returning EFSCORRUPTED here,
+		 * XXX (dgc): we should really be returning -EFSCORRUPTED here,
 		 * but none of the higher level infrastructure supports
 		 * returning a specific error on buffer lookup failures.
 		 */
@@ -1083,8 +1083,8 @@ xfs_buf_ioerror(
 	xfs_buf_t		*bp,
 	int			error)
 {
-	ASSERT(error >= 0 && error <= 0xffff);
-	bp->b_error = (unsigned short)error;
+	ASSERT(error <= 0 && error >= -1000);
+	bp->b_error = error;
 	trace_xfs_buf_ioerror(bp, error, _RET_IP_);
 }
 
@@ -1095,7 +1095,7 @@ xfs_buf_ioerror_alert(
 {
 	xfs_alert(bp->b_target->bt_mount,
 "metadata I/O error: block 0x%llx (\"%s\") error %d numblks %d",
-		(__uint64_t)XFS_BUF_ADDR(bp), func, bp->b_error, bp->b_length);
+		(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);
 }
 
 /*
@@ -1114,7 +1114,7 @@ xfs_bioerror(
 	/*
 	 * No need to wait until the buffer is unpinned, we aren't flushing it.
 	 */
-	xfs_buf_ioerror(bp, EIO);
+	xfs_buf_ioerror(bp, -EIO);
 
 	/*
 	 * We're calling xfs_buf_ioend, so delete XBF_DONE flag.
@@ -1125,7 +1125,7 @@ xfs_bioerror(
 
 	xfs_buf_ioend(bp, 0);
 
-	return EIO;
+	return -EIO;
 }
 
 /*
@@ -1158,13 +1158,13 @@ xfs_bioerror_relse(
 		 * There's no reason to mark error for
 		 * ASYNC buffers.
 		 */
-		xfs_buf_ioerror(bp, EIO);
+		xfs_buf_ioerror(bp, -EIO);
 		complete(&bp->b_iowait);
 	} else {
 		xfs_buf_relse(bp);
 	}
 
-	return EIO;
+	return -EIO;
 }
 
 STATIC int
@@ -1230,7 +1230,7 @@ xfs_buf_bio_end_io(
 	 * buffers that require multiple bios to complete.
 	 */
 	if (!bp->b_error)
-		xfs_buf_ioerror(bp, -error);
+		xfs_buf_ioerror(bp, error);
 
 	if (!bp->b_error && xfs_buf_is_vmapped(bp) && (bp->b_flags & XBF_READ))
 		invalidate_kernel_vmap_range(bp->b_addr, xfs_buf_vmap_len(bp));
@@ -1317,7 +1317,7 @@ next_chunk:
 		 * because the caller (xfs_buf_iorequest) holds a count itself.
 		 */
 		atomic_dec(&bp->b_io_remaining);
-		xfs_buf_ioerror(bp, EIO);
+		xfs_buf_ioerror(bp, -EIO);
 		bio_put(bio);
 	}
 
@@ -1634,7 +1634,7 @@ xfs_setsize_buftarg(
 		xfs_warn(btp->bt_mount,
 			"Cannot set_blocksize to %u on device %s",
 			sectorsize, name);
-		return EINVAL;
+		return -EINVAL;
 	}
 
 	/* Set up device logical sector size mask */
diff --git a/fs/xfs/xfs_buf.h b/fs/xfs/xfs_buf.h
index 75e98ced9b68..c75e6c85de5b 100644
--- a/fs/xfs/xfs_buf.h
+++ b/fs/xfs/xfs_buf.h
@@ -175,7 +175,7 @@ typedef struct xfs_buf {
 	atomic_t		b_io_remaining;	/* #outstanding I/O requests */
 	unsigned int		b_page_count;	/* size of page array */
 	unsigned int		b_offset;	/* page offset in first page */
-	unsigned short		b_error;	/* error code on I/O */
+	int			b_error;	/* error code on I/O */
 	const struct xfs_buf_ops	*b_ops;
 
 #ifdef XFS_BUF_LOCK_TRACKING
diff --git a/fs/xfs/xfs_buf_item.c b/fs/xfs/xfs_buf_item.c
index 4654338b03fc..76007deed31f 100644
--- a/fs/xfs/xfs_buf_item.c
+++ b/fs/xfs/xfs_buf_item.c
@@ -488,7 +488,7 @@ xfs_buf_item_unpin(
 		xfs_buf_lock(bp);
 		xfs_buf_hold(bp);
 		bp->b_flags |= XBF_ASYNC;
-		xfs_buf_ioerror(bp, EIO);
+		xfs_buf_ioerror(bp, -EIO);
 		XFS_BUF_UNDONE(bp);
 		xfs_buf_stale(bp);
 		xfs_buf_ioend(bp, 0);
@@ -725,7 +725,7 @@ xfs_buf_item_get_format(
 	bip->bli_formats = kmem_zalloc(count * sizeof(struct xfs_buf_log_format),
 				KM_SLEEP);
 	if (!bip->bli_formats)
-		return ENOMEM;
+		return -ENOMEM;
 	return 0;
 }
 
* Unmerged path fs/xfs/xfs_dir2_readdir.c
diff --git a/fs/xfs/xfs_discard.c b/fs/xfs/xfs_discard.c
index 4f11ef011139..76dee3fa7b63 100644
--- a/fs/xfs/xfs_discard.c
+++ b/fs/xfs/xfs_discard.c
@@ -124,7 +124,7 @@ xfs_trim_extents(
 		}
 
 		trace_xfs_discard_extent(mp, agno, fbno, flen);
-		error = -blkdev_issue_discard(bdev, dbno, dlen, GFP_NOFS, 0);
+		error = blkdev_issue_discard(bdev, dbno, dlen, GFP_NOFS, 0);
 		if (error)
 			goto out_del_cursor;
 		*blocks_trimmed += flen;
@@ -195,7 +195,7 @@ xfs_ioc_trim(
 	end_agno = xfs_daddr_to_agno(mp, end);
 
 	for (agno = start_agno; agno <= end_agno; agno++) {
-		error = -xfs_trim_extents(mp, agno, start, end, minlen,
+		error = xfs_trim_extents(mp, agno, start, end, minlen,
 					  &blocks_trimmed);
 		if (error)
 			last_error = error;
@@ -222,11 +222,11 @@ xfs_discard_extents(
 		trace_xfs_discard_extent(mp, busyp->agno, busyp->bno,
 					 busyp->length);
 
-		error = -blkdev_issue_discard(mp->m_ddev_targp->bt_bdev,
+		error = blkdev_issue_discard(mp->m_ddev_targp->bt_bdev,
 				XFS_AGB_TO_DADDR(mp, busyp->agno, busyp->bno),
 				XFS_FSB_TO_BB(mp, busyp->length),
 				GFP_NOFS, 0);
-		if (error && error != EOPNOTSUPP) {
+		if (error && error != -EOPNOTSUPP) {
 			xfs_info(mp,
 	 "discard failed for extent [0x%llu,%u], error %d",
 				 (unsigned long long)busyp->bno,
* Unmerged path fs/xfs/xfs_dquot.c
diff --git a/fs/xfs/xfs_error.c b/fs/xfs/xfs_error.c
index edac5b057d28..5175f341b702 100644
--- a/fs/xfs/xfs_error.c
+++ b/fs/xfs/xfs_error.c
@@ -190,7 +190,7 @@ xfs_verifier_error(
 	struct xfs_mount *mp = bp->b_target->bt_mount;
 
 	xfs_alert(mp, "Metadata %s detected at %pF, block 0x%llx",
-		  bp->b_error == EFSBADCRC ? "CRC error" : "corruption",
+		  bp->b_error == -EFSBADCRC ? "CRC error" : "corruption",
 		  __return_address, bp->b_bn);
 
 	xfs_alert(mp, "Unmount and run xfs_repair");
* Unmerged path fs/xfs/xfs_error.h
diff --git a/fs/xfs/xfs_export.c b/fs/xfs/xfs_export.c
index 753e467aa1a5..5a6bd5d8779a 100644
--- a/fs/xfs/xfs_export.c
+++ b/fs/xfs/xfs_export.c
@@ -147,9 +147,9 @@ xfs_nfs_get_inode(
 		 * We don't use ESTALE directly down the chain to not
 		 * confuse applications using bulkstat that expect EINVAL.
 		 */
-		if (error == EINVAL || error == ENOENT)
-			error = ESTALE;
-		return ERR_PTR(-error);
+		if (error == -EINVAL || error == -ENOENT)
+			error = -ESTALE;
+		return ERR_PTR(error);
 	}
 
 	if (ip->i_d.di_gen != generation) {
@@ -217,7 +217,7 @@ xfs_fs_get_parent(
 
 	error = xfs_lookup(XFS_I(child->d_inode), &xfs_name_dotdot, &cip, NULL);
 	if (unlikely(error))
-		return ERR_PTR(-error);
+		return ERR_PTR(error);
 
 	return d_obtain_alias(VFS_I(cip));
 }
@@ -237,7 +237,7 @@ xfs_fs_nfs_commit_metadata(
 
 	if (!lsn)
 		return 0;
-	return -_xfs_log_force_lsn(mp, lsn, XFS_LOG_SYNC, NULL);
+	return _xfs_log_force_lsn(mp, lsn, XFS_LOG_SYNC, NULL);
 }
 
 const struct export_operations xfs_export_operations = {
diff --git a/fs/xfs/xfs_extfree_item.c b/fs/xfs/xfs_extfree_item.c
index fb7a4c1ce1c5..c4327419dc5c 100644
--- a/fs/xfs/xfs_extfree_item.c
+++ b/fs/xfs/xfs_extfree_item.c
@@ -298,7 +298,7 @@ xfs_efi_copy_format(xfs_log_iovec_t *buf, xfs_efi_log_format_t *dst_efi_fmt)
 		}
 		return 0;
 	}
-	return EFSCORRUPTED;
+	return -EFSCORRUPTED;
 }
 
 /*
* Unmerged path fs/xfs/xfs_file.c
* Unmerged path fs/xfs/xfs_filestream.c
* Unmerged path fs/xfs/xfs_fsops.c
diff --git a/fs/xfs/xfs_icache.c b/fs/xfs/xfs_icache.c
index 6aaf07794ceb..4d6712181377 100644
--- a/fs/xfs/xfs_icache.c
+++ b/fs/xfs/xfs_icache.c
@@ -161,7 +161,7 @@ xfs_iget_cache_hit(
 	if (ip->i_ino != ino) {
 		trace_xfs_iget_skip(ip);
 		XFS_STATS_INC(xs_ig_frecycle);
-		error = EAGAIN;
+		error = -EAGAIN;
 		goto out_error;
 	}
 
@@ -179,7 +179,7 @@ xfs_iget_cache_hit(
 	if (ip->i_flags & (XFS_INEW|XFS_IRECLAIM)) {
 		trace_xfs_iget_skip(ip);
 		XFS_STATS_INC(xs_ig_frecycle);
-		error = EAGAIN;
+		error = -EAGAIN;
 		goto out_error;
 	}
 
@@ -187,7 +187,7 @@ xfs_iget_cache_hit(
 	 * If lookup is racing with unlink return an error immediately.
 	 */
 	if (ip->i_d.di_mode == 0 && !(flags & XFS_IGET_CREATE)) {
-		error = ENOENT;
+		error = -ENOENT;
 		goto out_error;
 	}
 
@@ -209,7 +209,7 @@ xfs_iget_cache_hit(
 		spin_unlock(&ip->i_flags_lock);
 		rcu_read_unlock();
 
-		error = -inode_init_always(mp->m_super, inode);
+		error = inode_init_always(mp->m_super, inode);
 		if (error) {
 			/*
 			 * Re-initializing the inode failed, and we are in deep
@@ -246,7 +246,7 @@ xfs_iget_cache_hit(
 		/* If the VFS inode is being torn down, pause and try again. */
 		if (!igrab(inode)) {
 			trace_xfs_iget_skip(ip);
-			error = EAGAIN;
+			error = -EAGAIN;
 			goto out_error;
 		}
 
@@ -288,7 +288,7 @@ xfs_iget_cache_miss(
 
 	ip = xfs_inode_alloc(mp, ino);
 	if (!ip)
-		return ENOMEM;
+		return -ENOMEM;
 
 	error = xfs_iread(mp, tp, ip, flags);
 	if (error)
@@ -297,7 +297,7 @@ xfs_iget_cache_miss(
 	trace_xfs_iget_miss(ip);
 
 	if ((ip->i_d.di_mode == 0) && !(flags & XFS_IGET_CREATE)) {
-		error = ENOENT;
+		error = -ENOENT;
 		goto out_destroy;
 	}
 
@@ -308,7 +308,7 @@ xfs_iget_cache_miss(
 	 * recurse into the file system.
 	 */
 	if (radix_tree_preload(GFP_NOFS)) {
-		error = EAGAIN;
+		error = -EAGAIN;
 		goto out_destroy;
 	}
 
@@ -344,7 +344,7 @@ xfs_iget_cache_miss(
 	if (unlikely(error)) {
 		WARN_ON(error != -EEXIST);
 		XFS_STATS_INC(xs_ig_dup);
-		error = EAGAIN;
+		error = -EAGAIN;
 		goto out_preload_end;
 	}
 	spin_unlock(&pag->pag_ici_lock);
@@ -411,7 +411,7 @@ xfs_iget(
 
 	/* reject inode numbers outside existing AGs */
 	if (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)
-		return EINVAL;
+		return -EINVAL;
 
 	/* get the perag structure and ensure that it's inode capable */
 	pag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));
@@ -448,7 +448,7 @@ again:
 	return 0;
 
 out_error_or_again:
-	if (error == EAGAIN) {
+	if (error == -EAGAIN) {
 		delay(1);
 		goto again;
 	}
@@ -492,18 +492,18 @@ xfs_inode_ag_walk_grab(
 
 	/* nothing to sync during shutdown */
 	if (XFS_FORCED_SHUTDOWN(ip->i_mount))
-		return EFSCORRUPTED;
+		return -EFSCORRUPTED;
 
 	/* If we can't grab the inode, it must on it's way to reclaim. */
 	if (!igrab(inode))
-		return ENOENT;
+		return -ENOENT;
 
 	/* inode is valid */
 	return 0;
 
 out_unlock_noent:
 	spin_unlock(&ip->i_flags_lock);
-	return ENOENT;
+	return -ENOENT;
 }
 
 STATIC int
@@ -586,16 +586,16 @@ restart:
 				continue;
 			error = execute(batch[i], flags, args);
 			IRELE(batch[i]);
-			if (error == EAGAIN) {
+			if (error == -EAGAIN) {
 				skipped++;
 				continue;
 			}
-			if (error && last_error != EFSCORRUPTED)
+			if (error && last_error != -EFSCORRUPTED)
 				last_error = error;
 		}
 
 		/* bail out if the filesystem is corrupted.  */
-		if (error == EFSCORRUPTED)
+		if (error == -EFSCORRUPTED)
 			break;
 
 		cond_resched();
@@ -655,7 +655,7 @@ xfs_inode_ag_iterator(
 		xfs_perag_put(pag);
 		if (error) {
 			last_error = error;
-			if (error == EFSCORRUPTED)
+			if (error == -EFSCORRUPTED)
 				break;
 		}
 	}
@@ -683,7 +683,7 @@ xfs_inode_ag_iterator_tag(
 		xfs_perag_put(pag);
 		if (error) {
 			last_error = error;
-			if (error == EFSCORRUPTED)
+			if (error == -EFSCORRUPTED)
 				break;
 		}
 	}
@@ -947,7 +947,7 @@ restart:
 	 * see the stale flag set on the inode.
 	 */
 	error = xfs_iflush(ip, &bp);
-	if (error == EAGAIN) {
+	if (error == -EAGAIN) {
 		xfs_iunlock(ip, XFS_ILOCK_EXCL);
 		/* backoff longer than in xfs_ifree_cluster */
 		delay(2);
@@ -1000,7 +1000,7 @@ out:
 	xfs_iflags_clear(ip, XFS_IRECLAIM);
 	xfs_iunlock(ip, XFS_ILOCK_EXCL);
 	/*
-	 * We could return EAGAIN here to make reclaim rescan the inode tree in
+	 * We could return -EAGAIN here to make reclaim rescan the inode tree in
 	 * a short while. However, this just burns CPU time scanning the tree
 	 * waiting for IO to complete and the reclaim work never goes back to
 	 * the idle state. Instead, return 0 to let the next scheduled
@@ -1103,7 +1103,7 @@ restart:
 				if (!batch[i])
 					continue;
 				error = xfs_reclaim_inode(batch[i], pag, flags);
-				if (error && last_error != EFSCORRUPTED)
+				if (error && last_error != -EFSCORRUPTED)
 					last_error = error;
 			}
 
@@ -1283,7 +1283,7 @@ xfs_inode_free_eofblocks(
 	ret = xfs_free_eofblocks(ip->i_mount, ip, need_iolock);
 
 	/* don't revisit the inode if we're not waiting */
-	if (ret == EAGAIN && !(flags & SYNC_WAIT))
+	if (ret == -EAGAIN && !(flags & SYNC_WAIT))
 		ret = 0;
 
 	return ret;
diff --git a/fs/xfs/xfs_icache.h b/fs/xfs/xfs_icache.h
index 11cfda21e1fe..8b6ac8dae3ae 100644
--- a/fs/xfs/xfs_icache.h
+++ b/fs/xfs/xfs_icache.h
@@ -74,14 +74,14 @@ xfs_fs_eofblocks_from_user(
 	struct xfs_eofblocks		*dst)
 {
 	if (src->eof_version != XFS_EOFBLOCKS_VERSION)
-		return EINVAL;
+		return -EINVAL;
 
 	if (src->eof_flags & ~XFS_EOF_FLAGS_VALID)
-		return EINVAL;
+		return -EINVAL;
 
 	if (memchr_inv(&src->pad32, 0, sizeof(src->pad32)) ||
 	    memchr_inv(src->pad64, 0, sizeof(src->pad64)))
-		return EINVAL;
+		return -EINVAL;
 
 	dst->eof_flags = src->eof_flags;
 	dst->eof_prid = src->eof_prid;
@@ -92,14 +92,14 @@ xfs_fs_eofblocks_from_user(
 	if (src->eof_flags & XFS_EOF_FLAGS_UID) {
 		dst->eof_uid = make_kuid(current_user_ns(), src->eof_uid);
 		if (!uid_valid(dst->eof_uid))
-			return EINVAL;
+			return -EINVAL;
 	}
 
 	dst->eof_gid = INVALID_GID;
 	if (src->eof_flags & XFS_EOF_FLAGS_GID) {
 		dst->eof_gid = make_kgid(current_user_ns(), src->eof_gid);
 		if (!gid_valid(dst->eof_gid))
-			return EINVAL;
+			return -EINVAL;
 	}
 	return 0;
 }
* Unmerged path fs/xfs/xfs_inode.c
diff --git a/fs/xfs/xfs_inode_item.c b/fs/xfs/xfs_inode_item.c
index 686889b4a1e5..1adb4a2929e9 100644
--- a/fs/xfs/xfs_inode_item.c
+++ b/fs/xfs/xfs_inode_item.c
@@ -816,5 +816,5 @@ xfs_inode_item_format_convert(
 		in_f->ilf_boffset = in_f64->ilf_boffset;
 		return 0;
 	}
-	return EFSCORRUPTED;
+	return -EFSCORRUPTED;
 }
* Unmerged path fs/xfs/xfs_ioctl.c
* Unmerged path fs/xfs/xfs_ioctl32.c
* Unmerged path fs/xfs/xfs_iomap.c
* Unmerged path fs/xfs/xfs_iops.c
* Unmerged path fs/xfs/xfs_itable.c
* Unmerged path fs/xfs/xfs_log.c
* Unmerged path fs/xfs/xfs_log_cil.c
* Unmerged path fs/xfs/xfs_log_recover.c
* Unmerged path fs/xfs/xfs_mount.c
* Unmerged path fs/xfs/xfs_mru_cache.c
* Unmerged path fs/xfs/xfs_qm.c
* Unmerged path fs/xfs/xfs_qm_bhv.c
* Unmerged path fs/xfs/xfs_qm_syscalls.c
diff --git a/fs/xfs/xfs_quotaops.c b/fs/xfs/xfs_quotaops.c
index a3d3058c9b30..b238027df987 100644
--- a/fs/xfs/xfs_quotaops.c
+++ b/fs/xfs/xfs_quotaops.c
@@ -51,7 +51,7 @@ xfs_fs_get_xstate(
 
 	if (!XFS_IS_QUOTA_RUNNING(mp))
 		return -ENOSYS;
-	return -xfs_qm_scall_getqstat(mp, fqs);
+	return xfs_qm_scall_getqstat(mp, fqs);
 }
 
 STATIC int
@@ -63,7 +63,7 @@ xfs_fs_get_xstatev(
 
 	if (!XFS_IS_QUOTA_RUNNING(mp))
 		return -ENOSYS;
-	return -xfs_qm_scall_getqstatv(mp, fqs);
+	return xfs_qm_scall_getqstatv(mp, fqs);
 }
 
 STATIC int
@@ -95,11 +95,11 @@ xfs_fs_set_xstate(
 
 	switch (op) {
 	case Q_XQUOTAON:
-		return -xfs_qm_scall_quotaon(mp, flags);
+		return xfs_qm_scall_quotaon(mp, flags);
 	case Q_XQUOTAOFF:
 		if (!XFS_IS_QUOTA_ON(mp))
 			return -EINVAL;
-		return -xfs_qm_scall_quotaoff(mp, flags);
+		return xfs_qm_scall_quotaoff(mp, flags);
 	}
 
 	return -EINVAL;
@@ -112,7 +112,7 @@ xfs_fs_rm_xquota(
 {
 	struct xfs_mount	*mp = XFS_M(sb);
 	unsigned int		flags = 0;
-	
+
 	if (sb->s_flags & MS_RDONLY)
 		return -EROFS;
 
@@ -126,8 +126,8 @@ xfs_fs_rm_xquota(
 	if (uflags & FS_PROJ_QUOTA)
 		flags |= XFS_DQ_PROJ;
 
-	return -xfs_qm_scall_trunc_qfiles(mp, flags);
-}	
+	return xfs_qm_scall_trunc_qfiles(mp, flags);
+}
 
 STATIC int
 xfs_fs_get_dqblk(
@@ -142,7 +142,7 @@ xfs_fs_get_dqblk(
 	if (!XFS_IS_QUOTA_ON(mp))
 		return -ESRCH;
 
-	return -xfs_qm_scall_getquota(mp, from_kqid(&init_user_ns, qid),
+	return xfs_qm_scall_getquota(mp, from_kqid(&init_user_ns, qid),
 				      xfs_quota_type(qid.type), fdq);
 }
 
@@ -161,7 +161,7 @@ xfs_fs_set_dqblk(
 	if (!XFS_IS_QUOTA_ON(mp))
 		return -ESRCH;
 
-	return -xfs_qm_scall_setqlim(mp, from_kqid(&init_user_ns, qid),
+	return xfs_qm_scall_setqlim(mp, from_kqid(&init_user_ns, qid),
 				     xfs_quota_type(qid.type), fdq);
 }
 
* Unmerged path fs/xfs/xfs_rtalloc.c
diff --git a/fs/xfs/xfs_rtalloc.h b/fs/xfs/xfs_rtalloc.h
index 752b63d10300..c642795324af 100644
--- a/fs/xfs/xfs_rtalloc.h
+++ b/fs/xfs/xfs_rtalloc.h
@@ -132,7 +132,7 @@ xfs_rtmount_init(
 		return 0;
 
 	xfs_warn(mp, "Not built with CONFIG_XFS_RT");
-	return ENOSYS;
+	return -ENOSYS;
 }
 # define xfs_rtmount_inodes(m)  (((mp)->m_sb.sb_rblocks == 0)? 0 : (ENOSYS))
 # define xfs_rtunmount_inodes(m)
* Unmerged path fs/xfs/xfs_super.c
* Unmerged path fs/xfs/xfs_symlink.c
* Unmerged path fs/xfs/xfs_trans.c
diff --git a/fs/xfs/xfs_trans_ail.c b/fs/xfs/xfs_trans_ail.c
index cb0f3a84cc68..859482f53b5a 100644
--- a/fs/xfs/xfs_trans_ail.c
+++ b/fs/xfs/xfs_trans_ail.c
@@ -762,7 +762,7 @@ xfs_trans_ail_init(
 
 	ailp = kmem_zalloc(sizeof(struct xfs_ail), KM_MAYFAIL);
 	if (!ailp)
-		return ENOMEM;
+		return -ENOMEM;
 
 	ailp->xa_mount = mp;
 	INIT_LIST_HEAD(&ailp->xa_ail);
@@ -781,7 +781,7 @@ xfs_trans_ail_init(
 
 out_free_ailp:
 	kmem_free(ailp);
-	return ENOMEM;
+	return -ENOMEM;
 }
 
 void
* Unmerged path fs/xfs/xfs_trans_buf.c
diff --git a/fs/xfs/xfs_trans_dquot.c b/fs/xfs/xfs_trans_dquot.c
index 41172861e857..846e061c2e98 100644
--- a/fs/xfs/xfs_trans_dquot.c
+++ b/fs/xfs/xfs_trans_dquot.c
@@ -722,8 +722,8 @@ xfs_trans_dqresv(
 error_return:
 	xfs_dqunlock(dqp);
 	if (flags & XFS_QMOPT_ENOSPC)
-		return ENOSPC;
-	return EDQUOT;
+		return -ENOSPC;
+	return -EDQUOT;
 }
 
 
diff --git a/fs/xfs/xfs_xattr.c b/fs/xfs/xfs_xattr.c
index 9d479073ba41..97f080568233 100644
--- a/fs/xfs/xfs_xattr.c
+++ b/fs/xfs/xfs_xattr.c
@@ -49,7 +49,7 @@ xfs_xattr_get(struct dentry *dentry, const char *name,
 		value = NULL;
 	}
 
-	error = -xfs_attr_get(ip, (unsigned char *)name, value, &asize, xflags);
+	error = xfs_attr_get(ip, (unsigned char *)name, value, &asize, xflags);
 	if (error)
 		return error;
 	return asize;
@@ -71,8 +71,8 @@ xfs_xattr_set(struct dentry *dentry, const char *name, const void *value,
 		xflags |= ATTR_REPLACE;
 
 	if (!value)
-		return -xfs_attr_remove(ip, (unsigned char *)name, xflags);
-	return -xfs_attr_set(ip, (unsigned char *)name,
+		return xfs_attr_remove(ip, (unsigned char *)name, xflags);
+	return xfs_attr_set(ip, (unsigned char *)name,
 				(void *)value, size, xflags);
 }
 
