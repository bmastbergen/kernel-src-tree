netfilter: Pass nf_hook_state through arpt_do_table().

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] netfilter: Pass nf_hook_state through arpt_do_table() (Jiri Benc) [1230935]
Rebuild_FUZZ: 99.07%
commit-author David S. Miller <davem@davemloft.net>
commit b85c3dc9bd5347ad9540ec8d103b7c049c48b7cd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/b85c3dc9.failed

	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b85c3dc9bd5347ad9540ec8d103b7c049c48b7cd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/netfilter/arptable_filter.c
diff --cc net/ipv4/netfilter/arptable_filter.c
index 6d3ae72d317f,93876d03120c..000000000000
--- a/net/ipv4/netfilter/arptable_filter.c
+++ b/net/ipv4/netfilter/arptable_filter.c
@@@ -28,12 -28,11 +28,16 @@@ static const struct xt_table packet_fil
  /* The work comes in here from netfilter.c */
  static unsigned int
  arptable_filter_hook(const struct nf_hook_ops *ops, struct sk_buff *skb,
 -		     const struct nf_hook_state *state)
 +		     const struct net_device *in, const struct net_device *out,
 +		     int (*okfn)(struct sk_buff *))
  {
 -	const struct net *net = dev_net(state->in ? state->in : state->out);
 +	const struct net *net = dev_net((in != NULL) ? in : out);
  
++<<<<<<< HEAD
 +	return arpt_do_table(skb, ops->hooknum, in, out,
++=======
+ 	return arpt_do_table(skb, ops->hooknum, state,
++>>>>>>> b85c3dc9bd53 (netfilter: Pass nf_hook_state through arpt_do_table().)
  			     net->ipv4.arptable_filter);
  }
  
diff --git a/include/linux/netfilter_arp/arp_tables.h b/include/linux/netfilter_arp/arp_tables.h
index cfb7191e6efa..c22a7fb8d0df 100644
--- a/include/linux/netfilter_arp/arp_tables.h
+++ b/include/linux/netfilter_arp/arp_tables.h
@@ -54,8 +54,7 @@ extern struct xt_table *arpt_register_table(struct net *net,
 extern void arpt_unregister_table(struct xt_table *table);
 extern unsigned int arpt_do_table(struct sk_buff *skb,
 				  unsigned int hook,
-				  const struct net_device *in,
-				  const struct net_device *out,
+				  const struct nf_hook_state *state,
 				  struct xt_table *table);
 
 #ifdef CONFIG_COMPAT
diff --git a/net/ipv4/netfilter/arp_tables.c b/net/ipv4/netfilter/arp_tables.c
index c9235e0491fe..aed714f1e58f 100644
--- a/net/ipv4/netfilter/arp_tables.c
+++ b/net/ipv4/netfilter/arp_tables.c
@@ -248,8 +248,7 @@ struct arpt_entry *arpt_next_entry(const struct arpt_entry *entry)
 
 unsigned int arpt_do_table(struct sk_buff *skb,
 			   unsigned int hook,
-			   const struct net_device *in,
-			   const struct net_device *out,
+			   const struct nf_hook_state *state,
 			   struct xt_table *table)
 {
 	static const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));
@@ -265,8 +264,8 @@ unsigned int arpt_do_table(struct sk_buff *skb,
 	if (!pskb_may_pull(skb, arp_hdr_len(skb->dev)))
 		return NF_DROP;
 
-	indev = in ? in->name : nulldevname;
-	outdev = out ? out->name : nulldevname;
+	indev = state->in ? state->in->name : nulldevname;
+	outdev = state->out ? state->out->name : nulldevname;
 
 	local_bh_disable();
 	addend = xt_write_recseq_begin();
@@ -281,8 +280,8 @@ unsigned int arpt_do_table(struct sk_buff *skb,
 	e = get_entry(table_base, private->hook_entry[hook]);
 	back = get_entry(table_base, private->underflow[hook]);
 
-	acpar.in      = in;
-	acpar.out     = out;
+	acpar.in      = state->in;
+	acpar.out     = state->out;
 	acpar.hooknum = hook;
 	acpar.family  = NFPROTO_ARP;
 	acpar.hotdrop = false;
* Unmerged path net/ipv4/netfilter/arptable_filter.c
