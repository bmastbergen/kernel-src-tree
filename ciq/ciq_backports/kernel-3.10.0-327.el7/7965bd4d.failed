net.h/skbuff.h: Remove extern from function prototypes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] net.h, skbuff.h: Remove extern from function prototypes (Ivan Vecera) [1200759]
Rebuild_FUZZ: 97.25%
commit-author Joe Perches <joe@perches.com>
commit 7965bd4d71ef7cf1db00afb9e406ddfc13443c13
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/7965bd4d.failed

There are a mix of function prototypes with and without extern
in the kernel sources.  Standardize on not using extern for
function prototypes.

Function prototypes don't need to be written with extern.
extern is assumed by the compiler.  Its use is as unnecessary as
using auto to declare automatic/local variables in a block.

	Signed-off-by: Joe Perches <joe@perches.com>
(cherry picked from commit 7965bd4d71ef7cf1db00afb9e406ddfc13443c13)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
diff --cc include/linux/skbuff.h
index f5e0b86b84ea,6d56840e561e..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -787,39 -666,28 +787,31 @@@ static inline struct sk_buff *alloc_skb
  	return __alloc_skb_head(priority, -1);
  }
  
- extern struct sk_buff *skb_morph(struct sk_buff *dst, struct sk_buff *src);
- extern int skb_copy_ubufs(struct sk_buff *skb, gfp_t gfp_mask);
- extern struct sk_buff *skb_clone(struct sk_buff *skb,
- 				 gfp_t priority);
- extern struct sk_buff *skb_copy(const struct sk_buff *skb,
- 				gfp_t priority);
- extern struct sk_buff *__pskb_copy(struct sk_buff *skb,
- 				 int headroom, gfp_t gfp_mask);
- 
- extern int	       pskb_expand_head(struct sk_buff *skb,
- 					int nhead, int ntail,
- 					gfp_t gfp_mask);
- extern struct sk_buff *skb_realloc_headroom(struct sk_buff *skb,
- 					    unsigned int headroom);
- extern struct sk_buff *skb_copy_expand(const struct sk_buff *skb,
- 				       int newheadroom, int newtailroom,
- 				       gfp_t priority);
- extern int	       skb_to_sgvec(struct sk_buff *skb,
- 				    struct scatterlist *sg, int offset,
- 				    int len);
- extern int	       skb_cow_data(struct sk_buff *skb, int tailbits,
- 				    struct sk_buff **trailer);
- extern int	       skb_pad(struct sk_buff *skb, int pad);
+ struct sk_buff *skb_morph(struct sk_buff *dst, struct sk_buff *src);
+ int skb_copy_ubufs(struct sk_buff *skb, gfp_t gfp_mask);
+ struct sk_buff *skb_clone(struct sk_buff *skb, gfp_t priority);
+ struct sk_buff *skb_copy(const struct sk_buff *skb, gfp_t priority);
+ struct sk_buff *__pskb_copy(struct sk_buff *skb, int headroom, gfp_t gfp_mask);
+ 
+ int pskb_expand_head(struct sk_buff *skb, int nhead, int ntail, gfp_t gfp_mask);
+ struct sk_buff *skb_realloc_headroom(struct sk_buff *skb,
+ 				     unsigned int headroom);
+ struct sk_buff *skb_copy_expand(const struct sk_buff *skb, int newheadroom,
+ 				int newtailroom, gfp_t priority);
+ int skb_to_sgvec(struct sk_buff *skb, struct scatterlist *sg, int offset,
+ 		 int len);
+ int skb_cow_data(struct sk_buff *skb, int tailbits, struct sk_buff **trailer);
+ int skb_pad(struct sk_buff *skb, int pad);
  #define dev_kfree_skb(a)	consume_skb(a)
  
- extern int skb_append_datato_frags(struct sock *sk, struct sk_buff *skb,
- 			int getfrag(void *from, char *to, int offset,
- 			int len,int odd, struct sk_buff *skb),
- 			void *from, int length);
+ int skb_append_datato_frags(struct sock *sk, struct sk_buff *skb,
+ 			    int getfrag(void *from, char *to, int offset,
+ 					int len, int odd, struct sk_buff *skb),
+ 			    void *from, int length);
  
 +int skb_append_pagefrags(struct sk_buff *skb, struct page *page,
 +			 int offset, size_t size);
 +
  struct skb_seq_state {
  	__u32		lower_offset;
  	__u32		upper_offset;
@@@ -830,62 -698,21 +822,66 @@@
  	__u8		*frag_data;
  };
  
- extern void	      skb_prepare_seq_read(struct sk_buff *skb,
- 					   unsigned int from, unsigned int to,
- 					   struct skb_seq_state *st);
- extern unsigned int   skb_seq_read(unsigned int consumed, const u8 **data,
- 				   struct skb_seq_state *st);
- extern void	      skb_abort_seq_read(struct skb_seq_state *st);
+ void skb_prepare_seq_read(struct sk_buff *skb, unsigned int from,
+ 			  unsigned int to, struct skb_seq_state *st);
+ unsigned int skb_seq_read(unsigned int consumed, const u8 **data,
+ 			  struct skb_seq_state *st);
+ void skb_abort_seq_read(struct skb_seq_state *st);
  
- extern unsigned int   skb_find_text(struct sk_buff *skb, unsigned int from,
- 				    unsigned int to, struct ts_config *config,
- 				    struct ts_state *state);
+ unsigned int skb_find_text(struct sk_buff *skb, unsigned int from,
+ 			   unsigned int to, struct ts_config *config,
+ 			   struct ts_state *state);
  
++<<<<<<< HEAD
 +/*
 + * Packet hash types specify the type of hash in skb_set_hash.
 + *
 + * Hash types refer to the protocol layer addresses which are used to
 + * construct a packet's hash. The hashes are used to differentiate or identify
 + * flows of the protocol layer for the hash type. Hash types are either
 + * layer-2 (L2), layer-3 (L3), or layer-4 (L4).
 + *
 + * Properties of hashes:
 + *
 + * 1) Two packets in different flows have different hash values
 + * 2) Two packets in the same flow should have the same hash value
 + *
 + * A hash at a higher layer is considered to be more specific. A driver should
 + * set the most specific hash possible.
 + *
 + * A driver cannot indicate a more specific hash than the layer at which a hash
 + * was computed. For instance an L3 hash cannot be set as an L4 hash.
 + *
 + * A driver may indicate a hash level which is less specific than the
 + * actual layer the hash was computed on. For instance, a hash computed
 + * at L4 may be considered an L3 hash. This should only be done if the
 + * driver can't unambiguously determine that the HW computed the hash at
 + * the higher layer. Note that the "should" in the second property above
 + * permits this.
 + */
 +enum pkt_hash_types {
 +	PKT_HASH_TYPE_NONE,	/* Undefined type */
 +	PKT_HASH_TYPE_L2,	/* Input: src_MAC, dest_MAC */
 +	PKT_HASH_TYPE_L3,	/* Input: src_IP, dst_IP */
 +	PKT_HASH_TYPE_L4,	/* Input: src_IP, dst_IP, src_port, dst_port */
 +};
 +
 +static inline void
 +skb_set_hash(struct sk_buff *skb, __u32 hash, enum pkt_hash_types type)
 +{
 +	skb->l4_rxhash = (type == PKT_HASH_TYPE_L4);
 +	skb->rxhash = hash;
 +}
 +
 +void __skb_get_hash(struct sk_buff *skb);
 +static inline __u32 skb_get_hash(struct sk_buff *skb)
++=======
+ void __skb_get_rxhash(struct sk_buff *skb);
+ static inline __u32 skb_get_rxhash(struct sk_buff *skb)
++>>>>>>> 7965bd4d71ef (net.h/skbuff.h: Remove extern from function prototypes)
  {
  	if (!skb->l4_rxhash)
 -		__skb_get_rxhash(skb);
 +		__skb_get_hash(skb);
  
  	return skb->rxhash;
  }
@@@ -2541,70 -2333,42 +2537,109 @@@ static inline void skb_frag_add_head(st
  #define skb_walk_frags(skb, iter)	\
  	for (iter = skb_shinfo(skb)->frag_list; iter; iter = iter->next)
  
++<<<<<<< HEAD
 +extern struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned flags,
 +					   int *peeked, int *off, int *err);
 +extern struct sk_buff *skb_recv_datagram(struct sock *sk, unsigned flags,
 +					 int noblock, int *err);
 +extern unsigned int    datagram_poll(struct file *file, struct socket *sock,
 +				     struct poll_table_struct *wait);
 +extern int	       skb_copy_datagram_iovec(const struct sk_buff *from,
 +					       int offset, struct iovec *to,
 +					       int size);
 +extern int	       skb_copy_and_csum_datagram_iovec(struct sk_buff *skb,
 +							int hlen,
 +							struct iovec *iov);
 +extern int	       skb_copy_datagram_from_iovec(struct sk_buff *skb,
 +						    int offset,
 +						    const struct iovec *from,
 +						    int from_offset,
 +						    int len);
 +extern int	       skb_copy_datagram_const_iovec(const struct sk_buff *from,
 +						     int offset,
 +						     const struct iovec *to,
 +						     int to_offset,
 +						     int size);
 +extern void	       skb_free_datagram(struct sock *sk, struct sk_buff *skb);
 +extern void	       skb_free_datagram_locked(struct sock *sk,
 +						struct sk_buff *skb);
 +extern int	       skb_kill_datagram(struct sock *sk, struct sk_buff *skb,
 +					 unsigned int flags);
 +extern __wsum	       skb_checksum(const struct sk_buff *skb, int offset,
 +				    int len, __wsum csum);
 +extern int	       skb_copy_bits(const struct sk_buff *skb, int offset,
 +				     void *to, int len);
 +extern int	       skb_store_bits(struct sk_buff *skb, int offset,
 +				      const void *from, int len);
 +extern __wsum	       skb_copy_and_csum_bits(const struct sk_buff *skb,
 +					      int offset, u8 *to, int len,
 +					      __wsum csum);
 +extern int             skb_splice_bits(struct sk_buff *skb,
 +						unsigned int offset,
 +						struct pipe_inode_info *pipe,
 +						unsigned int len,
 +						unsigned int flags);
 +extern void	       skb_copy_and_csum_dev(const struct sk_buff *skb, u8 *to);
 +unsigned int skb_zerocopy_headlen(const struct sk_buff *from);
 +int skb_zerocopy(struct sk_buff *to, struct sk_buff *from,
 +		 int len, int hlen);
 +
 +extern void	       skb_split(struct sk_buff *skb,
 +				 struct sk_buff *skb1, const u32 len);
 +extern int	       skb_shift(struct sk_buff *tgt, struct sk_buff *skb,
 +				 int shiftlen);
 +extern void	       skb_scrub_packet(struct sk_buff *skb, bool xnet);
 +unsigned int skb_gso_transport_seglen(const struct sk_buff *skb);
 +extern struct sk_buff *skb_segment(struct sk_buff *skb,
 +				   netdev_features_t features);
++=======
+ struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned flags,
+ 				    int *peeked, int *off, int *err);
+ struct sk_buff *skb_recv_datagram(struct sock *sk, unsigned flags, int noblock,
+ 				  int *err);
+ unsigned int datagram_poll(struct file *file, struct socket *sock,
+ 			   struct poll_table_struct *wait);
+ int skb_copy_datagram_iovec(const struct sk_buff *from, int offset,
+ 			    struct iovec *to, int size);
+ int skb_copy_and_csum_datagram_iovec(struct sk_buff *skb, int hlen,
+ 				     struct iovec *iov);
+ int skb_copy_datagram_from_iovec(struct sk_buff *skb, int offset,
+ 				 const struct iovec *from, int from_offset,
+ 				 int len);
+ int zerocopy_sg_from_iovec(struct sk_buff *skb, const struct iovec *frm,
+ 			   int offset, size_t count);
+ int skb_copy_datagram_const_iovec(const struct sk_buff *from, int offset,
+ 				  const struct iovec *to, int to_offset,
+ 				  int size);
+ void skb_free_datagram(struct sock *sk, struct sk_buff *skb);
+ void skb_free_datagram_locked(struct sock *sk, struct sk_buff *skb);
+ int skb_kill_datagram(struct sock *sk, struct sk_buff *skb, unsigned int flags);
+ __wsum skb_checksum(const struct sk_buff *skb, int offset, int len,
+ 		    __wsum csum);
+ int skb_copy_bits(const struct sk_buff *skb, int offset, void *to, int len);
+ int skb_store_bits(struct sk_buff *skb, int offset, const void *from, int len);
+ __wsum skb_copy_and_csum_bits(const struct sk_buff *skb, int offset, u8 *to,
+ 			      int len, __wsum csum);
+ int skb_splice_bits(struct sk_buff *skb, unsigned int offset,
+ 		    struct pipe_inode_info *pipe, unsigned int len,
+ 		    unsigned int flags);
+ void skb_copy_and_csum_dev(const struct sk_buff *skb, u8 *to);
+ void skb_split(struct sk_buff *skb, struct sk_buff *skb1, const u32 len);
+ int skb_shift(struct sk_buff *tgt, struct sk_buff *skb, int shiftlen);
+ void skb_scrub_packet(struct sk_buff *skb, bool xnet);
+ 
+ struct sk_buff *skb_segment(struct sk_buff *skb, netdev_features_t features);
++>>>>>>> 7965bd4d71ef (net.h/skbuff.h: Remove extern from function prototypes)
 +
 +struct skb_checksum_ops {
 +	__wsum (*update)(const void *mem, int len, __wsum wsum);
 +	__wsum (*combine)(__wsum csum, __wsum csum2, int offset, int len);
 +};
 +
 +__wsum __skb_checksum(const struct sk_buff *skb, int offset, int len,
 +		      __wsum csum, const struct skb_checksum_ops *ops);
 +__wsum skb_checksum(const struct sk_buff *skb, int offset, int len,
 +		    __wsum csum);
  
  static inline void *skb_header_pointer(const struct sk_buff *skb, int offset,
  				       int len, void *buffer)
@@@ -2822,165 -2565,8 +2857,165 @@@ static inline __sum16 skb_checksum_comp
  	       0 : __skb_checksum_complete(skb);
  }
  
 +static inline void __skb_decr_checksum_unnecessary(struct sk_buff *skb)
 +{
 +	if (skb->ip_summed == CHECKSUM_UNNECESSARY) {
 +		if (skb->csum_level == 0)
 +			skb->ip_summed = CHECKSUM_NONE;
 +		else
 +			skb->csum_level--;
 +	}
 +}
 +
 +static inline void __skb_incr_checksum_unnecessary(struct sk_buff *skb)
 +{
 +	if (skb->ip_summed == CHECKSUM_UNNECESSARY) {
 +		if (skb->csum_level < SKB_MAX_CSUM_LEVEL)
 +			skb->csum_level++;
 +	} else if (skb->ip_summed == CHECKSUM_NONE) {
 +		skb->ip_summed = CHECKSUM_UNNECESSARY;
 +		skb->csum_level = 0;
 +	}
 +}
 +
 +static inline void __skb_mark_checksum_bad(struct sk_buff *skb)
 +{
 +	/* Mark current checksum as bad (typically called from GRO
 +	 * path). In the case that ip_summed is CHECKSUM_NONE
 +	 * this must be the first checksum encountered in the packet.
 +	 * When ip_summed is CHECKSUM_UNNECESSARY, this is the first
 +	 * checksum after the last one validated. For UDP, a zero
 +	 * checksum can not be marked as bad.
 +	 */
 +
 +	if (skb->ip_summed == CHECKSUM_NONE ||
 +	    skb->ip_summed == CHECKSUM_UNNECESSARY)
 +		skb->csum_bad = 1;
 +}
 +
 +/* Check if we need to perform checksum complete validation.
 + *
 + * Returns true if checksum complete is needed, false otherwise
 + * (either checksum is unnecessary or zero checksum is allowed).
 + */
 +static inline bool __skb_checksum_validate_needed(struct sk_buff *skb,
 +						  bool zero_okay,
 +						  __sum16 check)
 +{
 +	if (skb_csum_unnecessary(skb) || (zero_okay && !check)) {
 +		skb->csum_valid = 1;
 +		__skb_decr_checksum_unnecessary(skb);
 +		return false;
 +	}
 +
 +	return true;
 +}
 +
 +/* For small packets <= CHECKSUM_BREAK peform checksum complete directly
 + * in checksum_init.
 + */
 +#define CHECKSUM_BREAK 76
 +
 +/* Validate (init) checksum based on checksum complete.
 + *
 + * Return values:
 + *   0: checksum is validated or try to in skb_checksum_complete. In the latter
 + *	case the ip_summed will not be CHECKSUM_UNNECESSARY and the pseudo
 + *	checksum is stored in skb->csum for use in __skb_checksum_complete
 + *   non-zero: value of invalid checksum
 + *
 + */
 +static inline __sum16 __skb_checksum_validate_complete(struct sk_buff *skb,
 +						       bool complete,
 +						       __wsum psum)
 +{
 +	if (skb->ip_summed == CHECKSUM_COMPLETE) {
 +		if (!csum_fold(csum_add(psum, skb->csum))) {
 +			skb->csum_valid = 1;
 +			return 0;
 +		}
 +	} else if (skb->csum_bad) {
 +		/* ip_summed == CHECKSUM_NONE in this case */
 +		return 1;
 +	}
 +
 +	skb->csum = psum;
 +
 +	if (complete || skb->len <= CHECKSUM_BREAK) {
 +		__sum16 csum;
 +
 +		csum = __skb_checksum_complete(skb);
 +		skb->csum_valid = !csum;
 +		return csum;
 +	}
 +
 +	return 0;
 +}
 +
 +static inline __wsum null_compute_pseudo(struct sk_buff *skb, int proto)
 +{
 +	return 0;
 +}
 +
 +/* Perform checksum validate (init). Note that this is a macro since we only
 + * want to calculate the pseudo header which is an input function if necessary.
 + * First we try to validate without any computation (checksum unnecessary) and
 + * then calculate based on checksum complete calling the function to compute
 + * pseudo header.
 + *
 + * Return values:
 + *   0: checksum is validated or try to in skb_checksum_complete
 + *   non-zero: value of invalid checksum
 + */
 +#define __skb_checksum_validate(skb, proto, complete,			\
 +				zero_okay, check, compute_pseudo)	\
 +({									\
 +	__sum16 __ret = 0;						\
 +	skb->csum_valid = 0;						\
 +	if (__skb_checksum_validate_needed(skb, zero_okay, check))	\
 +		__ret = __skb_checksum_validate_complete(skb,		\
 +				complete, compute_pseudo(skb, proto));	\
 +	__ret;								\
 +})
 +
 +#define skb_checksum_init(skb, proto, compute_pseudo)			\
 +	__skb_checksum_validate(skb, proto, false, false, 0, compute_pseudo)
 +
 +#define skb_checksum_init_zero_check(skb, proto, check, compute_pseudo)	\
 +	__skb_checksum_validate(skb, proto, false, true, check, compute_pseudo)
 +
 +#define skb_checksum_validate(skb, proto, compute_pseudo)		\
 +	__skb_checksum_validate(skb, proto, true, false, 0, compute_pseudo)
 +
 +#define skb_checksum_validate_zero_check(skb, proto, check,		\
 +					 compute_pseudo)		\
 +	__skb_checksum_validate_(skb, proto, true, true, check, compute_pseudo)
 +
 +#define skb_checksum_simple_validate(skb)				\
 +	__skb_checksum_validate(skb, 0, true, false, 0, null_compute_pseudo)
 +
 +static inline bool __skb_checksum_convert_check(struct sk_buff *skb)
 +{
 +	return (skb->ip_summed == CHECKSUM_NONE &&
 +		skb->csum_valid && !skb->csum_bad);
 +}
 +
 +static inline void __skb_checksum_convert(struct sk_buff *skb,
 +					  __sum16 check, __wsum pseudo)
 +{
 +	skb->csum = ~pseudo;
 +	skb->ip_summed = CHECKSUM_COMPLETE;
 +}
 +
 +#define skb_checksum_try_convert(skb, proto, check, compute_pseudo)	\
 +do {									\
 +	if (__skb_checksum_convert_check(skb))				\
 +		__skb_checksum_convert(skb, check,			\
 +				       compute_pseudo(skb, proto));	\
 +} while (0)
 +
  #if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
- extern void nf_conntrack_destroy(struct nf_conntrack *nfct);
+ void nf_conntrack_destroy(struct nf_conntrack *nfct);
  static inline void nf_conntrack_put(struct nf_conntrack *nfct)
  {
  	if (nfct && atomic_dec_and_test(&nfct->use))
diff --git a/include/linux/net.h b/include/linux/net.h
index d3d63a49a105..ef73758a86a8 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -206,27 +206,23 @@ enum {
 	SOCK_WAKE_URG,
 };
 
-extern int	     sock_wake_async(struct socket *sk, int how, int band);
-extern int	     sock_register(const struct net_proto_family *fam);
-extern void	     sock_unregister(int family);
-extern int	     __sock_create(struct net *net, int family, int type, int proto,
-				 struct socket **res, int kern);
-extern int	     sock_create(int family, int type, int proto,
-				 struct socket **res);
-extern int	     sock_create_kern(int family, int type, int proto,
-				      struct socket **res);
-extern int	     sock_create_lite(int family, int type, int proto,
-				      struct socket **res); 
-extern void	     sock_release(struct socket *sock);
-extern int   	     sock_sendmsg(struct socket *sock, struct msghdr *msg,
-				  size_t len);
-extern int	     sock_recvmsg(struct socket *sock, struct msghdr *msg,
-				  size_t size, int flags);
-extern struct file  *sock_alloc_file(struct socket *sock, int flags, const char *dname);
-extern struct socket *sockfd_lookup(int fd, int *err);
-extern struct socket *sock_from_file(struct file *file, int *err);
+int sock_wake_async(struct socket *sk, int how, int band);
+int sock_register(const struct net_proto_family *fam);
+void sock_unregister(int family);
+int __sock_create(struct net *net, int family, int type, int proto,
+		  struct socket **res, int kern);
+int sock_create(int family, int type, int proto, struct socket **res);
+int sock_create_kern(int family, int type, int proto, struct socket **res);
+int sock_create_lite(int family, int type, int proto, struct socket **res);
+void sock_release(struct socket *sock);
+int sock_sendmsg(struct socket *sock, struct msghdr *msg, size_t len);
+int sock_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,
+		 int flags);
+struct file *sock_alloc_file(struct socket *sock, int flags, const char *dname);
+struct socket *sockfd_lookup(int fd, int *err);
+struct socket *sock_from_file(struct file *file, int *err);
 #define		     sockfd_put(sock) fput(sock->file)
-extern int	     net_ratelimit(void);
+int net_ratelimit(void);
 
 #define net_ratelimited_function(function, ...)			\
 do {								\
@@ -254,32 +250,28 @@ do {								\
 #define net_random()		prandom_u32()
 #define net_srandom(seed)	prandom_seed((__force u32)(seed))
 
-extern int   	     kernel_sendmsg(struct socket *sock, struct msghdr *msg,
-				    struct kvec *vec, size_t num, size_t len);
-extern int   	     kernel_recvmsg(struct socket *sock, struct msghdr *msg,
-				    struct kvec *vec, size_t num,
-				    size_t len, int flags);
+int kernel_sendmsg(struct socket *sock, struct msghdr *msg, struct kvec *vec,
+		   size_t num, size_t len);
+int kernel_recvmsg(struct socket *sock, struct msghdr *msg, struct kvec *vec,
+		   size_t num, size_t len, int flags);
 
-extern int kernel_bind(struct socket *sock, struct sockaddr *addr,
-		       int addrlen);
-extern int kernel_listen(struct socket *sock, int backlog);
-extern int kernel_accept(struct socket *sock, struct socket **newsock,
-			 int flags);
-extern int kernel_connect(struct socket *sock, struct sockaddr *addr,
-			  int addrlen, int flags);
-extern int kernel_getsockname(struct socket *sock, struct sockaddr *addr,
-			      int *addrlen);
-extern int kernel_getpeername(struct socket *sock, struct sockaddr *addr,
-			      int *addrlen);
-extern int kernel_getsockopt(struct socket *sock, int level, int optname,
-			     char *optval, int *optlen);
-extern int kernel_setsockopt(struct socket *sock, int level, int optname,
-			     char *optval, unsigned int optlen);
-extern int kernel_sendpage(struct socket *sock, struct page *page, int offset,
-			   size_t size, int flags);
-extern int kernel_sock_ioctl(struct socket *sock, int cmd, unsigned long arg);
-extern int kernel_sock_shutdown(struct socket *sock,
-				enum sock_shutdown_cmd how);
+int kernel_bind(struct socket *sock, struct sockaddr *addr, int addrlen);
+int kernel_listen(struct socket *sock, int backlog);
+int kernel_accept(struct socket *sock, struct socket **newsock, int flags);
+int kernel_connect(struct socket *sock, struct sockaddr *addr, int addrlen,
+		   int flags);
+int kernel_getsockname(struct socket *sock, struct sockaddr *addr,
+		       int *addrlen);
+int kernel_getpeername(struct socket *sock, struct sockaddr *addr,
+		       int *addrlen);
+int kernel_getsockopt(struct socket *sock, int level, int optname, char *optval,
+		      int *optlen);
+int kernel_setsockopt(struct socket *sock, int level, int optname, char *optval,
+		      unsigned int optlen);
+int kernel_sendpage(struct socket *sock, struct page *page, int offset,
+		    size_t size, int flags);
+int kernel_sock_ioctl(struct socket *sock, int cmd, unsigned long arg);
+int kernel_sock_shutdown(struct socket *sock, enum sock_shutdown_cmd how);
 
 #define MODULE_ALIAS_NETPROTO(proto) \
 	MODULE_ALIAS("net-pf-" __stringify(proto))
* Unmerged path include/linux/skbuff.h
