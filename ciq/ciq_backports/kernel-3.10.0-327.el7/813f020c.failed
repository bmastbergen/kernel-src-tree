rtnetlink: remove check for fill_slave_info in rtnl_have_link_slave_info

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Jiri Pirko <jiri@resnulli.us>
commit 813f020c5d16878486b9a103bd59831846652247
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/813f020c.failed

This check is not needed because the same check is done before
fill_slave_info is used in rtnl_link_slave_info_fill.
Also, by removing this check, kernel will fillup IFLA_INFO_SLAVE_KIND
even for slaves of masters which does not implement fill_slave_info.

	Signed-off-by: Jiri Pirko <jiri@resnulli.us>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 813f020c5d16878486b9a103bd59831846652247)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/rtnetlink.c
diff --cc net/core/rtnetlink.c
index 46e91a591c6a,393b1bc9a618..000000000000
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@@ -513,10 -477,83 +513,87 @@@ static size_t rtnl_link_get_af_size(con
  	return size;
  }
  
++<<<<<<< HEAD
++=======
+ static bool rtnl_have_link_slave_info(const struct net_device *dev)
+ {
+ 	struct net_device *master_dev;
+ 
+ 	master_dev = netdev_master_upper_dev_get((struct net_device *) dev);
+ 	if (master_dev && master_dev->rtnl_link_ops)
+ 		return true;
+ 	return false;
+ }
+ 
+ static int rtnl_link_slave_info_fill(struct sk_buff *skb,
+ 				     const struct net_device *dev)
+ {
+ 	struct net_device *master_dev;
+ 	const struct rtnl_link_ops *ops;
+ 	struct nlattr *slave_data;
+ 	int err;
+ 
+ 	master_dev = netdev_master_upper_dev_get((struct net_device *) dev);
+ 	if (!master_dev)
+ 		return 0;
+ 	ops = master_dev->rtnl_link_ops;
+ 	if (!ops)
+ 		return 0;
+ 	if (nla_put_string(skb, IFLA_INFO_SLAVE_KIND, ops->kind) < 0)
+ 		return -EMSGSIZE;
+ 	if (ops->fill_slave_info) {
+ 		slave_data = nla_nest_start(skb, IFLA_INFO_SLAVE_DATA);
+ 		if (!slave_data)
+ 			return -EMSGSIZE;
+ 		err = ops->fill_slave_info(skb, master_dev, dev);
+ 		if (err < 0)
+ 			goto err_cancel_slave_data;
+ 		nla_nest_end(skb, slave_data);
+ 	}
+ 	return 0;
+ 
+ err_cancel_slave_data:
+ 	nla_nest_cancel(skb, slave_data);
+ 	return err;
+ }
+ 
+ static int rtnl_link_info_fill(struct sk_buff *skb,
+ 			       const struct net_device *dev)
+ {
+ 	const struct rtnl_link_ops *ops = dev->rtnl_link_ops;
+ 	struct nlattr *data;
+ 	int err;
+ 
+ 	if (!ops)
+ 		return 0;
+ 	if (nla_put_string(skb, IFLA_INFO_KIND, ops->kind) < 0)
+ 		return -EMSGSIZE;
+ 	if (ops->fill_xstats) {
+ 		err = ops->fill_xstats(skb, dev);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 	if (ops->fill_info) {
+ 		data = nla_nest_start(skb, IFLA_INFO_DATA);
+ 		if (data == NULL)
+ 			return -EMSGSIZE;
+ 		err = ops->fill_info(skb, dev);
+ 		if (err < 0)
+ 			goto err_cancel_data;
+ 		nla_nest_end(skb, data);
+ 	}
+ 	return 0;
+ 
+ err_cancel_data:
+ 	nla_nest_cancel(skb, data);
+ 	return err;
+ }
+ 
++>>>>>>> 813f020c5d16 (rtnetlink: remove check for fill_slave_info in rtnl_have_link_slave_info)
  static int rtnl_link_fill(struct sk_buff *skb, const struct net_device *dev)
  {
 -	struct nlattr *linkinfo;
 +	const struct rtnl_link_ops *ops = dev->rtnl_link_ops;
 +	struct nlattr *linkinfo, *data;
  	int err = -EMSGSIZE;
  
  	linkinfo = nla_nest_start(skb, IFLA_LINKINFO);
* Unmerged path net/core/rtnetlink.c
