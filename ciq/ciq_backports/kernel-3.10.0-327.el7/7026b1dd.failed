netfilter: Pass socket pointer down through okfn().

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] netfilter: Pass socket pointer down through okfn() (Jiri Benc) [1230935]
Rebuild_FUZZ: 99.01%
commit-author David Miller <davem@davemloft.net>
commit 7026b1ddb6b8d4e6ee33dc2bd06c0ca8746fa7ab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/7026b1dd.failed

On the output paths in particular, we have to sometimes deal with two
socket contexts.  First, and usually skb->sk, is the local socket that
generated the frame.

And second, is potentially the socket used to control a tunneling
socket, such as one the encapsulates using UDP.

We do not want to disassociate skb->sk when encapsulating in order
to fix this, because that would break socket memory accounting.

The most extreme case where this can cause huge problems is an
AF_PACKET socket transmitting over a vxlan device.  We hit code
paths doing checks that assume they are dealing with an ipv4
socket, but are actually operating upon the AF_PACKET one.

	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7026b1ddb6b8d4e6ee33dc2bd06c0ca8746fa7ab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
#	include/linux/netfilter.h
#	include/linux/netfilter_bridge.h
#	include/net/dn_neigh.h
#	include/net/ip.h
#	include/net/ip6_route.h
#	include/net/ipv6.h
#	include/net/xfrm.h
#	net/bridge/br_multicast.c
#	net/bridge/br_netfilter.c
#	net/core/dev.c
#	net/decnet/dn_neigh.c
#	net/ipv4/ip_forward.c
#	net/ipv4/ip_output.c
#	net/ipv4/xfrm4_output.c
#	net/ipv6/ip6_output.c
#	net/ipv6/netfilter/nf_defrag_ipv6_hooks.c
#	net/ipv6/xfrm6_output.c
#	net/netfilter/nf_queue.c
diff --cc include/linux/netdevice.h
index d77c2cff9dff,45823db2efb0..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -1817,34 -2142,39 +1817,58 @@@ static inline struct net_device *first_
  	return lh == &net->dev_base_head ? NULL : net_device_entry(lh);
  }
  
 -int netdev_boot_setup_check(struct net_device *dev);
 -unsigned long netdev_boot_base(const char *prefix, int unit);
 -struct net_device *dev_getbyhwaddr_rcu(struct net *net, unsigned short type,
 -				       const char *hwaddr);
 -struct net_device *dev_getfirstbyhwtype(struct net *net, unsigned short type);
 -struct net_device *__dev_getfirstbyhwtype(struct net *net, unsigned short type);
 -void dev_add_pack(struct packet_type *pt);
 -void dev_remove_pack(struct packet_type *pt);
 -void __dev_remove_pack(struct packet_type *pt);
 -void dev_add_offload(struct packet_offload *po);
 -void dev_remove_offload(struct packet_offload *po);
 -
 +extern int 			netdev_boot_setup_check(struct net_device *dev);
 +extern unsigned long		netdev_boot_base(const char *prefix, int unit);
 +extern struct net_device *dev_getbyhwaddr_rcu(struct net *net, unsigned short type,
 +					      const char *hwaddr);
 +extern struct net_device *dev_getfirstbyhwtype(struct net *net, unsigned short type);
 +extern struct net_device *__dev_getfirstbyhwtype(struct net *net, unsigned short type);
 +extern void		dev_add_pack(struct packet_type *pt);
 +extern void		dev_remove_pack(struct packet_type *pt);
 +extern void		__dev_remove_pack(struct packet_type *pt);
 +extern void		dev_add_offload(struct packet_offload *po);
 +extern void		dev_remove_offload(struct packet_offload *po);
 +extern void		__dev_remove_offload(struct packet_offload *po);
 +
++<<<<<<< HEAD
 +extern struct net_device	*dev_get_by_flags_rcu(struct net *net, unsigned short flags,
 +						      unsigned short mask);
 +extern struct net_device	*dev_get_by_name(struct net *net, const char *name);
 +extern struct net_device	*dev_get_by_name_rcu(struct net *net, const char *name);
 +extern struct net_device	*__dev_get_by_name(struct net *net, const char *name);
 +extern int		dev_alloc_name(struct net_device *dev, const char *name);
 +extern int		dev_open(struct net_device *dev);
 +extern int		dev_close(struct net_device *dev);
 +extern void		dev_disable_lro(struct net_device *dev);
 +extern int		dev_loopback_xmit(struct sk_buff *newskb);
 +extern int		dev_queue_xmit(struct sk_buff *skb);
 +extern int		register_netdevice(struct net_device *dev);
 +extern void		unregister_netdevice_queue(struct net_device *dev,
 +						   struct list_head *head);
 +extern void		unregister_netdevice_many(struct list_head *head);
++=======
+ int dev_get_iflink(const struct net_device *dev);
+ struct net_device *__dev_get_by_flags(struct net *net, unsigned short flags,
+ 				      unsigned short mask);
+ struct net_device *dev_get_by_name(struct net *net, const char *name);
+ struct net_device *dev_get_by_name_rcu(struct net *net, const char *name);
+ struct net_device *__dev_get_by_name(struct net *net, const char *name);
+ int dev_alloc_name(struct net_device *dev, const char *name);
+ int dev_open(struct net_device *dev);
+ int dev_close(struct net_device *dev);
+ int dev_close_many(struct list_head *head, bool unlink);
+ void dev_disable_lro(struct net_device *dev);
+ int dev_loopback_xmit(struct sock *sk, struct sk_buff *newskb);
+ int dev_queue_xmit_sk(struct sock *sk, struct sk_buff *skb);
+ static inline int dev_queue_xmit(struct sk_buff *skb)
+ {
+ 	return dev_queue_xmit_sk(skb->sk, skb);
+ }
+ int dev_queue_xmit_accel(struct sk_buff *skb, void *accel_priv);
+ int register_netdevice(struct net_device *dev);
+ void unregister_netdevice_queue(struct net_device *dev, struct list_head *head);
+ void unregister_netdevice_many(struct list_head *head);
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  static inline void unregister_netdevice(struct net_device *dev)
  {
  	unregister_netdevice_queue(dev, NULL);
@@@ -2430,46 -2867,79 +2454,70 @@@ static inline int netif_set_real_num_rx
  }
  #endif
  
 -#ifdef CONFIG_SYSFS
 -static inline unsigned int get_netdev_rx_queue_index(
 -		struct netdev_rx_queue *queue)
 +static inline int netif_copy_real_num_queues(struct net_device *to_dev,
 +					     const struct net_device *from_dev)
  {
 -	struct net_device *dev = queue->dev;
 -	int index = queue - dev->_rx;
 +	int err;
  
 -	BUG_ON(index >= dev->num_rx_queues);
 -	return index;
 -}
 +	err = netif_set_real_num_tx_queues(to_dev,
 +					   from_dev->real_num_tx_queues);
 +	if (err)
 +		return err;
 +#ifdef CONFIG_RPS
 +	return netif_set_real_num_rx_queues(to_dev,
 +					    from_dev->real_num_rx_queues);
 +#else
 +	return 0;
  #endif
 -
 -#define DEFAULT_MAX_NUM_RSS_QUEUES	(8)
 -int netif_get_num_default_rss_queues(void);
 -
 -enum skb_free_reason {
 -	SKB_REASON_CONSUMED,
 -	SKB_REASON_DROPPED,
 -};
 -
 -void __dev_kfree_skb_irq(struct sk_buff *skb, enum skb_free_reason reason);
 -void __dev_kfree_skb_any(struct sk_buff *skb, enum skb_free_reason reason);
 -
 -/*
 - * It is not allowed to call kfree_skb() or consume_skb() from hardware
 - * interrupt context or with hardware interrupts being disabled.
 - * (in_irq() || irqs_disabled())
 - *
 - * We provide four helpers that can be used in following contexts :
 - *
 - * dev_kfree_skb_irq(skb) when caller drops a packet from irq context,
 - *  replacing kfree_skb(skb)
 - *
 - * dev_consume_skb_irq(skb) when caller consumes a packet from irq context.
 - *  Typically used in place of consume_skb(skb) in TX completion path
 - *
 - * dev_kfree_skb_any(skb) when caller doesn't know its current irq context,
 - *  replacing kfree_skb(skb)
 - *
 - * dev_consume_skb_any(skb) when caller doesn't know its current irq context,
 - *  and consumed a packet. Used in place of consume_skb(skb)
 - */
 -static inline void dev_kfree_skb_irq(struct sk_buff *skb)
 -{
 -	__dev_kfree_skb_irq(skb, SKB_REASON_DROPPED);
 -}
 -
 -static inline void dev_consume_skb_irq(struct sk_buff *skb)
 -{
 -	__dev_kfree_skb_irq(skb, SKB_REASON_CONSUMED);
  }
  
 +#define DEFAULT_MAX_NUM_RSS_QUEUES	(8)
 +extern int netif_get_num_default_rss_queues(void);
 +
 +/* Use this variant when it is known for sure that it
 + * is executing from hardware interrupt context or with hardware interrupts
 + * disabled.
 + */
 +extern void dev_kfree_skb_irq(struct sk_buff *skb);
 +
 +/* Use this variant in places where it could be invoked
 + * from either hardware interrupt or other context, with hardware interrupts
 + * either disabled or enabled.
 + */
 +extern void dev_kfree_skb_any(struct sk_buff *skb);
 +
++<<<<<<< HEAD
 +extern int		netif_rx(struct sk_buff *skb);
 +extern int		netif_rx_ni(struct sk_buff *skb);
 +extern int		netif_receive_skb(struct sk_buff *skb);
 +extern gro_result_t	napi_gro_receive(struct napi_struct *napi,
 +					 struct sk_buff *skb);
 +extern void		napi_gro_flush(struct napi_struct *napi, bool flush_old);
 +extern struct sk_buff *	napi_get_frags(struct napi_struct *napi);
 +extern gro_result_t	napi_gro_frags(struct napi_struct *napi);
++=======
+ static inline void dev_kfree_skb_any(struct sk_buff *skb)
+ {
+ 	__dev_kfree_skb_any(skb, SKB_REASON_DROPPED);
+ }
+ 
+ static inline void dev_consume_skb_any(struct sk_buff *skb)
+ {
+ 	__dev_kfree_skb_any(skb, SKB_REASON_CONSUMED);
+ }
+ 
+ int netif_rx(struct sk_buff *skb);
+ int netif_rx_ni(struct sk_buff *skb);
+ int netif_receive_skb_sk(struct sock *sk, struct sk_buff *skb);
+ static inline int netif_receive_skb(struct sk_buff *skb)
+ {
+ 	return netif_receive_skb_sk(skb->sk, skb);
+ }
+ gro_result_t napi_gro_receive(struct napi_struct *napi, struct sk_buff *skb);
+ void napi_gro_flush(struct napi_struct *napi, bool flush_old);
+ struct sk_buff *napi_get_frags(struct napi_struct *napi);
+ gro_result_t napi_gro_frags(struct napi_struct *napi);
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  struct packet_offload *gro_find_receive_by_type(__be16 type);
  struct packet_offload *gro_find_complete_by_type(__be16 type);
  
diff --cc include/linux/netfilter.h
index 3c0221f8945f,63560d0a8dfe..000000000000
--- a/include/linux/netfilter.h
+++ b/include/linux/netfilter.h
@@@ -43,11 -44,39 +43,44 @@@ int netfilter_init(void)
  struct sk_buff;
  
  struct nf_hook_ops;
++<<<<<<< HEAD
++=======
+ 
+ struct sock;
+ 
+ struct nf_hook_state {
+ 	unsigned int hook;
+ 	int thresh;
+ 	u_int8_t pf;
+ 	struct net_device *in;
+ 	struct net_device *out;
+ 	struct sock *sk;
+ 	int (*okfn)(struct sock *, struct sk_buff *);
+ };
+ 
+ static inline void nf_hook_state_init(struct nf_hook_state *p,
+ 				      unsigned int hook,
+ 				      int thresh, u_int8_t pf,
+ 				      struct net_device *indev,
+ 				      struct net_device *outdev,
+ 				      struct sock *sk,
+ 				      int (*okfn)(struct sock *, struct sk_buff *))
+ {
+ 	p->hook = hook;
+ 	p->thresh = thresh;
+ 	p->pf = pf;
+ 	p->in = indev;
+ 	p->out = outdev;
+ 	p->sk = sk;
+ 	p->okfn = okfn;
+ }
+ 
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  typedef unsigned int nf_hookfn(const struct nf_hook_ops *ops,
  			       struct sk_buff *skb,
 -			       const struct nf_hook_state *state);
 +			       const struct net_device *in,
 +			       const struct net_device *out,
 +			       int (*okfn)(struct sk_buff *));
  
  struct nf_hook_ops {
  	struct list_head list;
@@@ -139,10 -160,16 +173,21 @@@ static inline int nf_hook_thresh(u_int8
  				 struct sk_buff *skb,
  				 struct net_device *indev,
  				 struct net_device *outdev,
- 				 int (*okfn)(struct sk_buff *), int thresh)
+ 				 int (*okfn)(struct sock *, struct sk_buff *),
+ 				 int thresh)
  {
++<<<<<<< HEAD
 +	if (nf_hooks_active(pf, hook))
 +		return nf_hook_slow(pf, hook, skb, indev, outdev, okfn, thresh);
++=======
+ 	if (nf_hooks_active(pf, hook)) {
+ 		struct nf_hook_state state;
+ 
+ 		nf_hook_state_init(&state, hook, thresh, pf,
+ 				   indev, outdev, sk, okfn);
+ 		return nf_hook_slow(skb, &state);
+ 	}
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  	return 1;
  }
  
diff --cc include/linux/netfilter_bridge.h
index 8ab1c278b66d,5fc0a0fe244b..000000000000
--- a/include/linux/netfilter_bridge.h
+++ b/include/linux/netfilter_bridge.h
@@@ -53,34 -30,7 +53,38 @@@ static inline unsigned int nf_bridge_mt
  	return 0;
  }
  
++<<<<<<< HEAD
 +int br_handle_frame_finish(struct sk_buff *skb);
 +/* Only used in br_device.c */
 +static inline int br_nf_pre_routing_finish_bridge_slow(struct sk_buff *skb)
 +{
 +	struct nf_bridge_info *nf_bridge = skb->nf_bridge;
 +
 +	skb_pull(skb, ETH_HLEN);
 +	nf_bridge->mask ^= BRNF_BRIDGED_DNAT;
 +	skb_copy_to_linear_data_offset(skb, -(ETH_HLEN-ETH_ALEN),
 +				       skb->nf_bridge->data, ETH_HLEN-ETH_ALEN);
 +	skb->dev = nf_bridge->physindev;
 +	return br_handle_frame_finish(skb);
 +}
 +
 +/* This is called by the IP fragmenting code and it ensures there is
 + * enough room for the encapsulating header (if there is one). */
 +static inline unsigned int nf_bridge_pad(const struct sk_buff *skb)
 +{
 +	if (skb->nf_bridge)
 +		return nf_bridge_encap_header_len(skb);
 +	return 0;
 +}
 +
 +struct bridge_skb_cb {
 +	union {
 +		__be32 ipv4;
 +	} daddr;
 +};
++=======
+ int br_handle_frame_finish(struct sock *sk, struct sk_buff *skb);
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  
  static inline void br_drop_fake_rtable(struct sk_buff *skb)
  {
diff --cc include/net/dn_neigh.h
index 4cb4ae7fb81f,d0424269313f..000000000000
--- a/include/net/dn_neigh.h
+++ b/include/net/dn_neigh.h
@@@ -16,12 -16,13 +16,22 @@@ struct dn_neigh 
  	__u8 priority;
  };
  
++<<<<<<< HEAD
 +extern void dn_neigh_init(void);
 +extern void dn_neigh_cleanup(void);
 +extern int dn_neigh_router_hello(struct sk_buff *skb);
 +extern int dn_neigh_endnode_hello(struct sk_buff *skb);
 +extern void dn_neigh_pointopoint_hello(struct sk_buff *skb);
 +extern int dn_neigh_elist(struct net_device *dev, unsigned char *ptr, int n);
++=======
+ void dn_neigh_init(void);
+ void dn_neigh_cleanup(void);
+ int dn_neigh_router_hello(struct sock *sk, struct sk_buff *skb);
+ int dn_neigh_endnode_hello(struct sock *sk, struct sk_buff *skb);
+ void dn_neigh_pointopoint_hello(struct sk_buff *skb);
+ int dn_neigh_elist(struct net_device *dev, unsigned char *ptr, int n);
+ int dn_to_neigh_output(struct sock *sk, struct sk_buff *skb);
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  
  extern struct neigh_table dn_neigh_table;
  
diff --cc include/net/ip.h
index 01f9ccf5f537,d14af7edd197..000000000000
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@@ -97,20 -99,21 +97,38 @@@ extern int		igmp_mc_proc_init(void)
   *	Functions provided by ip.c
   */
  
++<<<<<<< HEAD
 +extern int		ip_build_and_send_pkt(struct sk_buff *skb, struct sock *sk,
 +					      __be32 saddr, __be32 daddr,
 +					      struct ip_options_rcu *opt);
 +extern int		ip_rcv(struct sk_buff *skb, struct net_device *dev,
 +			       struct packet_type *pt, struct net_device *orig_dev);
 +extern int		ip_local_deliver(struct sk_buff *skb);
 +extern int		ip_mr_input(struct sk_buff *skb);
 +extern int		ip_output(struct sock *sk, struct sk_buff *skb);
 +extern int		ip_mc_output(struct sock *sk, struct sk_buff *skb);
 +extern int		ip_fragment(struct sk_buff *skb, int (*output)(struct sk_buff *));
 +extern int		ip_do_nat(struct sk_buff *skb);
 +extern void		ip_send_check(struct iphdr *ip);
 +extern int		__ip_local_out(struct sk_buff *skb);
 +extern int		ip_local_out_sk(struct sock *sk, struct sk_buff *skb);
++=======
+ int ip_build_and_send_pkt(struct sk_buff *skb, struct sock *sk,
+ 			  __be32 saddr, __be32 daddr,
+ 			  struct ip_options_rcu *opt);
+ int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt,
+ 	   struct net_device *orig_dev);
+ int ip_local_deliver(struct sk_buff *skb);
+ int ip_mr_input(struct sk_buff *skb);
+ int ip_output(struct sock *sk, struct sk_buff *skb);
+ int ip_mc_output(struct sock *sk, struct sk_buff *skb);
+ int ip_fragment(struct sock *sk, struct sk_buff *skb,
+ 		int (*output)(struct sock *, struct sk_buff *));
+ int ip_do_nat(struct sk_buff *skb);
+ void ip_send_check(struct iphdr *ip);
+ int __ip_local_out(struct sk_buff *skb);
+ int ip_local_out_sk(struct sock *sk, struct sk_buff *skb);
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  static inline int ip_local_out(struct sk_buff *skb)
  {
  	return ip_local_out_sk(skb->sk, skb);
diff --cc include/net/ip6_route.h
index 71256172cd6b,5e192068e6cb..000000000000
--- a/include/net/ip6_route.h
+++ b/include/net/ip6_route.h
@@@ -185,7 -163,15 +185,19 @@@ static inline bool ipv6_unicast_destina
  	return rt->rt6i_flags & RTF_LOCAL;
  }
  
++<<<<<<< HEAD
 +int ip6_fragment(struct sk_buff *skb, int (*output)(struct sk_buff *));
++=======
+ static inline bool ipv6_anycast_destination(const struct sk_buff *skb)
+ {
+ 	struct rt6_info *rt = (struct rt6_info *) skb_dst(skb);
+ 
+ 	return rt->rt6i_flags & RTF_ANYCAST;
+ }
+ 
+ int ip6_fragment(struct sock *sk, struct sk_buff *skb,
+ 		 int (*output)(struct sock *, struct sk_buff *));
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  
  static inline int ip6_skb_dst_mtu(struct sk_buff *skb)
  {
diff --cc include/net/ipv6.h
index a8cae4809670,b6ae959824ff..000000000000
--- a/include/net/ipv6.h
+++ b/include/net/ipv6.h
@@@ -683,12 -766,10 +683,16 @@@ static inline __be32 ip6_flowlabel(cons
   *	rcv function (called from netdevice level)
   */
  
 -int ipv6_rcv(struct sk_buff *skb, struct net_device *dev,
 -	     struct packet_type *pt, struct net_device *orig_dev);
 +extern int			ipv6_rcv(struct sk_buff *skb, 
 +					 struct net_device *dev, 
 +					 struct packet_type *pt,
 +					 struct net_device *orig_dev);
  
++<<<<<<< HEAD
 +extern int			ip6_rcv_finish(struct sk_buff *skb);
++=======
+ int ip6_rcv_finish(struct sock *sk, struct sk_buff *skb);
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  
  /*
   *	upper-layer output functions
diff --cc include/net/xfrm.h
index e5038ec2deec,36ac102c97c7..000000000000
--- a/include/net/xfrm.h
+++ b/include/net/xfrm.h
@@@ -335,9 -331,8 +335,14 @@@ struct xfrm_state_afinfo 
  						const xfrm_address_t *saddr);
  	int			(*tmpl_sort)(struct xfrm_tmpl **dst, struct xfrm_tmpl **src, int n);
  	int			(*state_sort)(struct xfrm_state **dst, struct xfrm_state **src, int n);
++<<<<<<< HEAD
 +	RH_KABI_REPLACE_P(int			(*output)(struct sk_buff *skb),
 +		          int			(*output)(struct sock *sk, struct sk_buff *skb))
 +	int			(*output_finish)(struct sk_buff *skb);
++=======
+ 	int			(*output)(struct sock *sk, struct sk_buff *skb);
+ 	int			(*output_finish)(struct sock *sk, struct sk_buff *skb);
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  	int			(*extract_input)(struct xfrm_state *x,
  						 struct sk_buff *skb);
  	int			(*extract_output)(struct xfrm_state *x,
@@@ -1485,30 -1489,29 +1490,56 @@@ struct xfrmk_spdinfo 
  	u32 spdhmcnt;
  };
  
++<<<<<<< HEAD
 +extern struct xfrm_state *xfrm_find_acq_byseq(struct net *net, u32 mark,
 +					      u32 seq);
 +extern int xfrm_state_delete(struct xfrm_state *x);
 +extern int xfrm_state_flush(struct net *net, u8 proto, struct xfrm_audit *audit_info);
 +extern void xfrm_sad_getinfo(struct net *net, struct xfrmk_sadinfo *si);
 +extern void xfrm_spd_getinfo(struct net *net, struct xfrmk_spdinfo *si);
 +extern u32 xfrm_replay_seqhi(struct xfrm_state *x, __be32 net_seq);
 +extern int xfrm_init_replay(struct xfrm_state *x);
 +extern int xfrm_state_mtu(struct xfrm_state *x, int mtu);
 +extern int __xfrm_init_state(struct xfrm_state *x, bool init_replay);
 +extern int xfrm_init_state(struct xfrm_state *x);
 +extern int xfrm_prepare_input(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm_input(struct sk_buff *skb, int nexthdr, __be32 spi,
 +		      int encap_type);
 +extern int xfrm_input_resume(struct sk_buff *skb, int nexthdr);
 +extern int xfrm_output_resume(struct sk_buff *skb, int err);
 +extern int xfrm_output(struct sk_buff *skb);
 +extern int xfrm_inner_extract_output(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm4_extract_header(struct sk_buff *skb);
 +extern int xfrm4_extract_input(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm4_rcv_encap(struct sk_buff *skb, int nexthdr, __be32 spi,
 +			   int encap_type);
 +extern int xfrm4_transport_finish(struct sk_buff *skb, int async);
 +extern int xfrm4_rcv(struct sk_buff *skb);
++=======
+ struct xfrm_state *xfrm_find_acq_byseq(struct net *net, u32 mark, u32 seq);
+ int xfrm_state_delete(struct xfrm_state *x);
+ int xfrm_state_flush(struct net *net, u8 proto, bool task_valid);
+ void xfrm_sad_getinfo(struct net *net, struct xfrmk_sadinfo *si);
+ void xfrm_spd_getinfo(struct net *net, struct xfrmk_spdinfo *si);
+ u32 xfrm_replay_seqhi(struct xfrm_state *x, __be32 net_seq);
+ int xfrm_init_replay(struct xfrm_state *x);
+ int xfrm_state_mtu(struct xfrm_state *x, int mtu);
+ int __xfrm_init_state(struct xfrm_state *x, bool init_replay);
+ int xfrm_init_state(struct xfrm_state *x);
+ int xfrm_prepare_input(struct xfrm_state *x, struct sk_buff *skb);
+ int xfrm_input(struct sk_buff *skb, int nexthdr, __be32 spi, int encap_type);
+ int xfrm_input_resume(struct sk_buff *skb, int nexthdr);
+ int xfrm_output_resume(struct sk_buff *skb, int err);
+ int xfrm_output(struct sock *sk, struct sk_buff *skb);
+ int xfrm_inner_extract_output(struct xfrm_state *x, struct sk_buff *skb);
+ void xfrm_local_error(struct sk_buff *skb, int mtu);
+ int xfrm4_extract_header(struct sk_buff *skb);
+ int xfrm4_extract_input(struct xfrm_state *x, struct sk_buff *skb);
+ int xfrm4_rcv_encap(struct sk_buff *skb, int nexthdr, __be32 spi,
+ 		    int encap_type);
+ int xfrm4_transport_finish(struct sk_buff *skb, int async);
+ int xfrm4_rcv(struct sk_buff *skb);
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  
  static inline int xfrm4_rcv_spi(struct sk_buff *skb, int nexthdr, __be32 spi)
  {
@@@ -1518,38 -1521,42 +1549,72 @@@
  	return xfrm_input(skb, nexthdr, spi, 0);
  }
  
++<<<<<<< HEAD
 +extern int xfrm4_extract_output(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm4_prepare_output(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm4_output(struct sock *sk, struct sk_buff *skb);
 +extern int xfrm4_output_finish(struct sk_buff *skb);
 +extern int xfrm4_rcv_cb(struct sk_buff *skb, u8 protocol, int err);
 +extern int xfrm4_protocol_register(struct xfrm4_protocol *handler, unsigned char protocol);
 +extern int xfrm4_protocol_deregister(struct xfrm4_protocol *handler, unsigned char protocol);
 +extern int xfrm4_tunnel_register(struct xfrm_tunnel *handler, unsigned short family);
 +extern int xfrm4_tunnel_deregister(struct xfrm_tunnel *handler, unsigned short family);
 +extern int xfrm4_mode_tunnel_input_register(struct xfrm_tunnel_notifier *handler);
 +extern int xfrm4_mode_tunnel_input_deregister(struct xfrm_tunnel_notifier *handler);
 +extern int xfrm6_extract_header(struct sk_buff *skb);
 +extern int xfrm6_extract_input(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm6_rcv_spi(struct sk_buff *skb, int nexthdr, __be32 spi);
 +extern int xfrm6_transport_finish(struct sk_buff *skb, int async);
 +extern int xfrm6_rcv(struct sk_buff *skb);
 +extern int xfrm6_input_addr(struct sk_buff *skb, xfrm_address_t *daddr,
 +			    xfrm_address_t *saddr, u8 proto);
 +extern int xfrm6_tunnel_register(struct xfrm6_tunnel *handler, unsigned short family);
 +extern int xfrm6_tunnel_deregister(struct xfrm6_tunnel *handler, unsigned short family);
 +extern __be32 xfrm6_tunnel_alloc_spi(struct net *net, xfrm_address_t *saddr);
 +extern __be32 xfrm6_tunnel_spi_lookup(struct net *net, const xfrm_address_t *saddr);
 +extern int xfrm6_extract_output(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm6_prepare_output(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm6_output(struct sock *sk, struct sk_buff *skb);
 +extern int xfrm6_output_finish(struct sk_buff *skb);
 +extern int xfrm6_find_1stfragopt(struct xfrm_state *x, struct sk_buff *skb,
 +				 u8 **prevhdr);
++=======
+ int xfrm4_extract_output(struct xfrm_state *x, struct sk_buff *skb);
+ int xfrm4_prepare_output(struct xfrm_state *x, struct sk_buff *skb);
+ int xfrm4_output(struct sock *sk, struct sk_buff *skb);
+ int xfrm4_output_finish(struct sock *sk, struct sk_buff *skb);
+ int xfrm4_rcv_cb(struct sk_buff *skb, u8 protocol, int err);
+ int xfrm4_protocol_register(struct xfrm4_protocol *handler, unsigned char protocol);
+ int xfrm4_protocol_deregister(struct xfrm4_protocol *handler, unsigned char protocol);
+ int xfrm4_tunnel_register(struct xfrm_tunnel *handler, unsigned short family);
+ int xfrm4_tunnel_deregister(struct xfrm_tunnel *handler, unsigned short family);
+ void xfrm4_local_error(struct sk_buff *skb, u32 mtu);
+ int xfrm6_extract_header(struct sk_buff *skb);
+ int xfrm6_extract_input(struct xfrm_state *x, struct sk_buff *skb);
+ int xfrm6_rcv_spi(struct sk_buff *skb, int nexthdr, __be32 spi);
+ int xfrm6_transport_finish(struct sk_buff *skb, int async);
+ int xfrm6_rcv(struct sk_buff *skb);
+ int xfrm6_input_addr(struct sk_buff *skb, xfrm_address_t *daddr,
+ 		     xfrm_address_t *saddr, u8 proto);
+ void xfrm6_local_error(struct sk_buff *skb, u32 mtu);
+ int xfrm6_rcv_cb(struct sk_buff *skb, u8 protocol, int err);
+ int xfrm6_protocol_register(struct xfrm6_protocol *handler, unsigned char protocol);
+ int xfrm6_protocol_deregister(struct xfrm6_protocol *handler, unsigned char protocol);
+ int xfrm6_tunnel_register(struct xfrm6_tunnel *handler, unsigned short family);
+ int xfrm6_tunnel_deregister(struct xfrm6_tunnel *handler, unsigned short family);
+ __be32 xfrm6_tunnel_alloc_spi(struct net *net, xfrm_address_t *saddr);
+ __be32 xfrm6_tunnel_spi_lookup(struct net *net, const xfrm_address_t *saddr);
+ int xfrm6_extract_output(struct xfrm_state *x, struct sk_buff *skb);
+ int xfrm6_prepare_output(struct xfrm_state *x, struct sk_buff *skb);
+ int xfrm6_output(struct sock *sk, struct sk_buff *skb);
+ int xfrm6_output_finish(struct sock *sk, struct sk_buff *skb);
+ int xfrm6_find_1stfragopt(struct xfrm_state *x, struct sk_buff *skb,
+ 			  u8 **prevhdr);
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  
  #ifdef CONFIG_XFRM
 -int xfrm4_udp_encap_rcv(struct sock *sk, struct sk_buff *skb);
 -int xfrm_user_policy(struct sock *sk, int optname,
 -		     u8 __user *optval, int optlen);
 +extern int xfrm4_udp_encap_rcv(struct sock *sk, struct sk_buff *skb);
 +extern int xfrm_user_policy(struct sock *sk, int optname, u8 __user *optval, int optlen);
  #else
  static inline int xfrm_user_policy(struct sock *sk, int optname, u8 __user *optval, int optlen)
  {
diff --cc net/bridge/br_multicast.c
index f8395c842ff9,4b6722f8f179..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -798,12 -813,14 +798,20 @@@ static void __br_multicast_send_query(s
  		return;
  
  	if (port) {
 +		__skb_push(skb, sizeof(struct ethhdr));
  		skb->dev = port->dev;
++<<<<<<< HEAD
 +		NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT, skb, NULL, skb->dev,
 +			dev_queue_xmit);
 +	} else
++=======
+ 		NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT, NULL, skb,
+ 			NULL, skb->dev,
+ 			br_dev_queue_push_xmit);
+ 	} else {
+ 		br_multicast_select_own_querier(br, ip, skb);
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  		netif_rx(skb);
 -	}
  }
  
  static void br_multicast_send_query(struct net_bridge *br,
diff --cc net/bridge/br_netfilter.c
index 878f008afefa,acd31c9f2116..000000000000
--- a/net/bridge/br_netfilter.c
+++ b/net/bridge/br_netfilter.c
@@@ -711,10 -651,11 +714,11 @@@ static unsigned int br_nf_pre_routing(c
  		return NF_DROP;
  	if (!setup_pre_routing(skb))
  		return NF_DROP;
 -
 +	store_orig_dstaddr(skb);
  	skb->protocol = htons(ETH_P_IP);
  
- 	NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, skb, skb->dev, NULL,
+ 	NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, state->sk, skb,
+ 		skb->dev, NULL,
  		br_nf_pre_routing_finish);
  
  	return NF_STOLEN;
@@@ -815,8 -750,9 +819,14 @@@ static unsigned int br_nf_forward_ip(co
  	else
  		skb->protocol = htons(ETH_P_IPV6);
  
++<<<<<<< HEAD
 +	NF_HOOK(pf, NF_INET_FORWARD, skb, brnf_get_logical_dev(skb, in), parent,
 +		br_nf_forward_finish);
++=======
+ 	NF_HOOK(pf, NF_INET_FORWARD, NULL, skb,
+ 		brnf_get_logical_dev(skb, state->in),
+ 		parent,	br_nf_forward_finish);
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  
  	return NF_STOLEN;
  }
@@@ -850,27 -784,63 +860,82 @@@ static unsigned int br_nf_forward_arp(c
  			nf_bridge_push_encap_header(skb);
  		return NF_ACCEPT;
  	}
++<<<<<<< HEAD
 +	*d = (struct net_device *)in;
 +	NF_HOOK(NFPROTO_ARP, NF_ARP_FORWARD, skb, (struct net_device *)in,
 +		(struct net_device *)out, br_nf_forward_finish);
++=======
+ 	*d = state->in;
+ 	NF_HOOK(NFPROTO_ARP, NF_ARP_FORWARD, state->sk, skb,
+ 		state->in, state->out, br_nf_forward_finish);
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  
  	return NF_STOLEN;
  }
  
++<<<<<<< HEAD
 +#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV4)
 +static int br_nf_dev_queue_xmit(struct sk_buff *skb)
++=======
+ #if IS_ENABLED(CONFIG_NF_DEFRAG_IPV4)
+ static bool nf_bridge_copy_header(struct sk_buff *skb)
+ {
+ 	int err;
+ 	unsigned int header_size;
+ 
+ 	nf_bridge_update_protocol(skb);
+ 	header_size = ETH_HLEN + nf_bridge_encap_header_len(skb);
+ 	err = skb_cow_head(skb, header_size);
+ 	if (err)
+ 		return false;
+ 
+ 	skb_copy_to_linear_data_offset(skb, -header_size,
+ 				       skb->nf_bridge->data, header_size);
+ 	__skb_push(skb, nf_bridge_encap_header_len(skb));
+ 	return true;
+ }
+ 
+ static int br_nf_push_frag_xmit(struct sock *sk, struct sk_buff *skb)
+ {
+ 	if (!nf_bridge_copy_header(skb)) {
+ 		kfree_skb(skb);
+ 		return 0;
+ 	}
+ 
+ 	return br_dev_queue_push_xmit(sk, skb);
+ }
+ 
+ static int br_nf_dev_queue_xmit(struct sock *sk, struct sk_buff *skb)
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  {
  	int ret;
 -	int frag_max_size;
 -	unsigned int mtu_reserved;
  
++<<<<<<< HEAD
 +	if (skb->nfct != NULL && skb->protocol == htons(ETH_P_IP) &&
 +	    skb->len + nf_bridge_mtu_reduction(skb) > skb->dev->mtu &&
 +	    !skb_is_gso(skb)) {
 +		if (br_parse_ip_options(skb))
 +			/* Drop invalid packet */
 +			return NF_DROP;
 +		ret = ip_fragment(skb, br_dev_queue_push_xmit);
++=======
+ 	if (skb_is_gso(skb) || skb->protocol != htons(ETH_P_IP))
+ 		return br_dev_queue_push_xmit(sk, skb);
+ 
+ 	mtu_reserved = nf_bridge_mtu_reduction(skb);
+ 	/* This is wrong! We should preserve the original fragment
+ 	 * boundaries by preserving frag_list rather than refragmenting.
+ 	 */
+ 	if (skb->len + mtu_reserved > skb->dev->mtu) {
+ 		frag_max_size = BR_INPUT_SKB_CB(skb)->frag_max_size;
+ 		if (br_parse_ip_options(skb))
+ 			/* Drop invalid packet */
+ 			return NF_DROP;
+ 		IPCB(skb)->frag_max_size = frag_max_size;
+ 		ret = ip_fragment(sk, skb, br_nf_push_frag_xmit);
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  	} else
- 		ret = br_dev_queue_push_xmit(skb);
+ 		ret = br_dev_queue_push_xmit(sk, skb);
  
  	return ret;
  }
@@@ -942,6 -914,46 +1008,49 @@@ static unsigned int ip_sabotage_in(cons
  	return NF_ACCEPT;
  }
  
++<<<<<<< HEAD
++=======
+ /* This is called when br_netfilter has called into iptables/netfilter,
+  * and DNAT has taken place on a bridge-forwarded packet.
+  *
+  * neigh->output has created a new MAC header, with local br0 MAC
+  * as saddr.
+  *
+  * This restores the original MAC saddr of the bridged packet
+  * before invoking bridge forward logic to transmit the packet.
+  */
+ static void br_nf_pre_routing_finish_bridge_slow(struct sk_buff *skb)
+ {
+ 	struct nf_bridge_info *nf_bridge = skb->nf_bridge;
+ 
+ 	skb_pull(skb, ETH_HLEN);
+ 	nf_bridge->mask &= ~BRNF_BRIDGED_DNAT;
+ 
+ 	skb_copy_to_linear_data_offset(skb, -(ETH_HLEN-ETH_ALEN),
+ 				       skb->nf_bridge->data, ETH_HLEN-ETH_ALEN);
+ 	skb->dev = nf_bridge->physindev;
+ 	br_handle_frame_finish(NULL, skb);
+ }
+ 
+ static int br_nf_dev_xmit(struct sk_buff *skb)
+ {
+ 	if (skb->nf_bridge && (skb->nf_bridge->mask & BRNF_BRIDGED_DNAT)) {
+ 		br_nf_pre_routing_finish_bridge_slow(skb);
+ 		return 1;
+ 	}
+ 	return 0;
+ }
+ 
+ static const struct nf_br_ops br_ops = {
+ 	.br_dev_xmit_hook =	br_nf_dev_xmit,
+ };
+ 
+ void br_netfilter_enable(void)
+ {
+ }
+ EXPORT_SYMBOL_GPL(br_netfilter_enable);
+ 
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  /* For br_nf_post_routing, we need (prio = NF_BR_PRI_LAST), because
   * br_dev_queue_push_xmit is called afterwards */
  static struct nf_hook_ops br_nf_ops[] __read_mostly = {
diff --cc net/core/dev.c
index 883bfd5aec6c,b2775f06c710..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -2855,7 -3016,18 +2855,16 @@@ out
  	rcu_read_unlock_bh();
  	return rc;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL(dev_queue_xmit);
++=======
+ 
+ int dev_queue_xmit_sk(struct sock *sk, struct sk_buff *skb)
+ {
+ 	return __dev_queue_xmit(skb, NULL);
+ }
+ EXPORT_SYMBOL(dev_queue_xmit_sk);
 -
 -int dev_queue_xmit_accel(struct sk_buff *skb, void *accel_priv)
 -{
 -	return __dev_queue_xmit(skb, accel_priv);
 -}
 -EXPORT_SYMBOL(dev_queue_xmit_accel);
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  
  
  /*=======================================================================
@@@ -3624,7 -3837,29 +3633,33 @@@ int netif_receive_skb(struct sk_buff *s
  #endif
  	return __netif_receive_skb(skb);
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL(netif_receive_skb);
++=======
+ 
+ /**
+  *	netif_receive_skb - process receive buffer from network
+  *	@skb: buffer to process
+  *
+  *	netif_receive_skb() is the main receive data processing function.
+  *	It always succeeds. The buffer may be dropped during processing
+  *	for congestion control or by the protocol layers.
+  *
+  *	This function may only be called from softirq context and interrupts
+  *	should be enabled.
+  *
+  *	Return values (usually ignored):
+  *	NET_RX_SUCCESS: no congestion
+  *	NET_RX_DROP: packet was dropped
+  */
+ int netif_receive_skb_sk(struct sock *sk, struct sk_buff *skb)
+ {
+ 	trace_netif_receive_skb_entry(skb);
+ 
+ 	return netif_receive_skb_internal(skb);
+ }
+ EXPORT_SYMBOL(netif_receive_skb_sk);
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  
  /* Network device is going away, flush any packets still pending
   * Called with irqs disabled.
diff --cc net/decnet/dn_neigh.c
index c8121ceddb9e,4507b188fc51..000000000000
--- a/net/decnet/dn_neigh.c
+++ b/net/decnet/dn_neigh.c
@@@ -226,7 -194,20 +226,24 @@@ static int dn_neigh_output_packet(struc
  	return err;
  }
  
++<<<<<<< HEAD
 +static int dn_long_output(struct neighbour *neigh, struct sk_buff *skb)
++=======
+ static int dn_neigh_output_packet(struct sock *sk, struct sk_buff *skb)
+ {
+ 	struct dst_entry *dst = skb_dst(skb);
+ 	struct dn_route *rt = (struct dn_route *)dst;
+ 	struct neighbour *neigh = rt->n;
+ 
+ 	return neigh->output(neigh, skb);
+ }
+ 
+ /*
+  * For talking to broadcast devices: Ethernet & PPP
+  */
+ static int dn_long_output(struct neighbour *neigh, struct sock *sk,
+ 			  struct sk_buff *skb)
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  {
  	struct net_device *dev = neigh->dev;
  	int headroom = dev->hard_header_len + sizeof(struct dn_long_packet) + 3;
@@@ -265,11 -246,15 +282,19 @@@
  
  	skb_reset_network_header(skb);
  
- 	return NF_HOOK(NFPROTO_DECNET, NF_DN_POST_ROUTING, skb, NULL,
- 		       neigh->dev, dn_neigh_output_packet);
+ 	return NF_HOOK(NFPROTO_DECNET, NF_DN_POST_ROUTING, sk, skb,
+ 		       NULL, neigh->dev, dn_neigh_output_packet);
  }
  
++<<<<<<< HEAD
 +static int dn_short_output(struct neighbour *neigh, struct sk_buff *skb)
++=======
+ /*
+  * For talking to pointopoint and multidrop devices: DDCMP and X.25
+  */
+ static int dn_short_output(struct neighbour *neigh, struct sock *sk,
+ 			   struct sk_buff *skb)
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  {
  	struct net_device *dev = neigh->dev;
  	int headroom = dev->hard_header_len + sizeof(struct dn_short_packet) + 2;
@@@ -306,10 -291,12 +331,11 @@@
  }
  
  /*
 - * For talking to DECnet phase III nodes
 - * Phase 3 output is the same as short output, execpt that
 + * Phase 3 output is the same is short output, execpt that
   * it clears the area bits before transmission.
   */
- static int dn_phase3_output(struct neighbour *neigh, struct sk_buff *skb)
+ static int dn_phase3_output(struct neighbour *neigh, struct sock *sk,
+ 			    struct sk_buff *skb)
  {
  	struct net_device *dev = neigh->dev;
  	int headroom = dev->hard_header_len + sizeof(struct dn_short_packet) + 2;
@@@ -340,10 -327,36 +366,39 @@@
  
  	skb_reset_network_header(skb);
  
- 	return NF_HOOK(NFPROTO_DECNET, NF_DN_POST_ROUTING, skb, NULL,
- 		       neigh->dev, dn_neigh_output_packet);
+ 	return NF_HOOK(NFPROTO_DECNET, NF_DN_POST_ROUTING, sk, skb,
+ 		       NULL, neigh->dev, dn_neigh_output_packet);
+ }
+ 
++<<<<<<< HEAD
++=======
+ int dn_to_neigh_output(struct sock *sk, struct sk_buff *skb)
+ {
+ 	struct dst_entry *dst = skb_dst(skb);
+ 	struct dn_route *rt = (struct dn_route *) dst;
+ 	struct neighbour *neigh = rt->n;
+ 	struct dn_neigh *dn = (struct dn_neigh *)neigh;
+ 	struct dn_dev *dn_db;
+ 	bool use_long;
+ 
+ 	rcu_read_lock();
+ 	dn_db = rcu_dereference(neigh->dev->dn_ptr);
+ 	if (dn_db == NULL) {
+ 		rcu_read_unlock();
+ 		return -EINVAL;
+ 	}
+ 	use_long = dn_db->use_long;
+ 	rcu_read_unlock();
+ 
+ 	if (dn->flags & DN_NDFLAG_P3)
+ 		return dn_phase3_output(neigh, sk, skb);
+ 	if (use_long)
+ 		return dn_long_output(neigh, sk, skb);
+ 	else
+ 		return dn_short_output(neigh, sk, skb);
  }
  
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  /*
   * Unfortunately, the neighbour code uses the device in its hash
   * function, so we don't get any advantage from it. This function
diff --cc net/ipv4/ip_forward.c
index 2e3056bc1742,939992c456f3..000000000000
--- a/net/ipv4/ip_forward.c
+++ b/net/ipv4/ip_forward.c
@@@ -56,7 -56,8 +56,12 @@@ static bool ip_exceeds_mtu(const struc
  	return true;
  }
  
++<<<<<<< HEAD
 +static int ip_forward_finish(struct sk_buff *skb)
++=======
+ 
+ static int ip_forward_finish(struct sock *sk, struct sk_buff *skb)
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  {
  	struct ip_options *opt	= &(IPCB(skb)->opt);
  
@@@ -66,7 -67,8 +71,12 @@@
  	if (unlikely(opt->optlen))
  		ip_forward_options(skb);
  
++<<<<<<< HEAD
 +	return dst_output(skb);
++=======
+ 	skb_sender_cpu_clear(skb);
+ 	return dst_output_sk(sk, skb);
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  }
  
  int ip_forward(struct sk_buff *skb)
diff --cc net/ipv4/ip_output.c
index 8c66d61254bb,5da4d15262fd..000000000000
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@@ -217,8 -222,10 +222,15 @@@ static int ip_finish_output_gso(struct 
  	struct sk_buff *segs;
  	int ret = 0;
  
++<<<<<<< HEAD
 +	if (skb_gso_network_seglen(skb) <= ip_skb_dst_mtu(skb))
 +		return ip_finish_output2(skb);
++=======
+ 	/* common case: locally created skb or seglen is <= mtu */
+ 	if (((IPCB(skb)->flags & IPSKB_FORWARDED) == 0) ||
+ 	      skb_gso_network_seglen(skb) <= ip_skb_dst_mtu(skb))
+ 		return ip_finish_output2(sk, skb);
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  
  	/* Slowpath -  GSO segment length is exceeding the dst MTU.
  	 *
@@@ -255,9 -262,9 +267,9 @@@ static int ip_finish_output(struct soc
  {
  #if defined(CONFIG_NETFILTER) && defined(CONFIG_XFRM)
  	/* Policy lookup after SNAT yielded a new policy */
 -	if (skb_dst(skb)->xfrm) {
 +	if (skb_dst(skb)->xfrm != NULL) {
  		IPCB(skb)->flags |= IPSKB_REROUTED;
- 		return dst_output(skb);
+ 		return dst_output_sk(sk, skb);
  	}
  #endif
  	if (skb_is_gso(skb))
diff --cc net/ipv4/xfrm4_output.c
index 4c2cbb6224dc,2878dbfffeb7..000000000000
--- a/net/ipv4/xfrm4_output.c
+++ b/net/ipv4/xfrm4_output.c
@@@ -72,28 -69,43 +72,52 @@@ int xfrm4_prepare_output(struct xfrm_st
  }
  EXPORT_SYMBOL(xfrm4_prepare_output);
  
- int xfrm4_output_finish(struct sk_buff *skb)
+ int xfrm4_output_finish(struct sock *sk, struct sk_buff *skb)
  {
 -	memset(IPCB(skb), 0, sizeof(*IPCB(skb)));
 -
  #ifdef CONFIG_NETFILTER
++<<<<<<< HEAD
 +	if (!skb_dst(skb)->xfrm) {
++=======
+ 	IPCB(skb)->flags |= IPSKB_XFRM_TRANSFORMED;
+ #endif
+ 
+ 	return xfrm_output(sk, skb);
+ }
+ 
+ static int __xfrm4_output(struct sock *sk, struct sk_buff *skb)
+ {
+ 	struct xfrm_state *x = skb_dst(skb)->xfrm;
+ 
+ #ifdef CONFIG_NETFILTER
+ 	if (!x) {
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  		IPCB(skb)->flags |= IPSKB_REROUTED;
- 		return dst_output(skb);
+ 		return dst_output_sk(sk, skb);
  	}
 +
 +	IPCB(skb)->flags |= IPSKB_XFRM_TRANSFORMED;
  #endif
  
++<<<<<<< HEAD
 +	skb->protocol = htons(ETH_P_IP);
 +	return xfrm_output(skb);
++=======
+ 	return x->outer_mode->afinfo->output_finish(sk, skb);
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  }
  
  int xfrm4_output(struct sock *sk, struct sk_buff *skb)
  {
++<<<<<<< HEAD
 +	struct dst_entry *dst = skb_dst(skb);
 +	struct xfrm_state *x = dst->xfrm;
 +
 +	return NF_HOOK_COND(NFPROTO_IPV4, NF_INET_POST_ROUTING, skb,
 +			    NULL, dst->dev,
 +			    x->outer_mode->afinfo->output_finish,
++=======
+ 	return NF_HOOK_COND(NFPROTO_IPV4, NF_INET_POST_ROUTING, sk, skb,
+ 			    NULL, skb_dst(skb)->dev, __xfrm4_output,
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  			    !(IPCB(skb)->flags & IPSKB_REROUTED));
  }
 -
 -void xfrm4_local_error(struct sk_buff *skb, u32 mtu)
 -{
 -	struct iphdr *hdr;
 -
 -	hdr = skb->encapsulation ? inner_ip_hdr(skb) : ip_hdr(skb);
 -	ip_local_error(skb->sk, EMSGSIZE, hdr->daddr,
 -		       inet_sk(skb->sk)->inet_dport, mtu);
 -}
diff --cc net/ipv6/ip6_output.c
index 524b4ad02d70,7fde1f265c90..000000000000
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@@ -218,11 -221,11 +219,11 @@@ int ip6_xmit(struct sock *sk, struct sk
  	skb->mark = sk->sk_mark;
  
  	mtu = dst_mtu(dst);
 -	if ((skb->len <= mtu) || skb->ignore_df || skb_is_gso(skb)) {
 +	if ((skb->len <= mtu) || skb->local_df || skb_is_gso(skb)) {
  		IP6_UPD_PO_STATS(net, ip6_dst_idev(skb_dst(skb)),
  			      IPSTATS_MIB_OUT, skb->len);
- 		return NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT, skb, NULL,
- 			       dst->dev, dst_output);
+ 		return NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT, sk, skb,
+ 			       NULL, dst->dev, dst_output_sk);
  	}
  
  	skb->dev = dst->dev;
@@@ -315,9 -317,31 +316,14 @@@ static int ip6_forward_proxy_check(stru
  	return 0;
  }
  
- static inline int ip6_forward_finish(struct sk_buff *skb)
+ static inline int ip6_forward_finish(struct sock *sk, struct sk_buff *skb)
  {
++<<<<<<< HEAD
 +	return dst_output(skb);
++=======
+ 	skb_sender_cpu_clear(skb);
+ 	return dst_output_sk(sk, skb);
 -}
 -
 -static unsigned int ip6_dst_mtu_forward(const struct dst_entry *dst)
 -{
 -	unsigned int mtu;
 -	struct inet6_dev *idev;
 -
 -	if (dst_metric_locked(dst, RTAX_MTU)) {
 -		mtu = dst_metric_raw(dst, RTAX_MTU);
 -		if (mtu)
 -			return mtu;
 -	}
 -
 -	mtu = IPV6_MIN_MTU;
 -	rcu_read_lock();
 -	idev = __in6_dev_get(dst->dev);
 -	if (idev)
 -		mtu = idev->cnf.mtu6;
 -	rcu_read_unlock();
 -
 -	return mtu;
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  }
  
  static bool ip6_pkt_too_big(const struct sk_buff *skb, unsigned int mtu)
@@@ -515,11 -540,13 +522,12 @@@ static void ip6_copy_metadata(struct sk
  	skb_copy_secmark(to, from);
  }
  
- int ip6_fragment(struct sk_buff *skb, int (*output)(struct sk_buff *))
+ int ip6_fragment(struct sock *sk, struct sk_buff *skb,
+ 		 int (*output)(struct sock *, struct sk_buff *))
  {
  	struct sk_buff *frag;
 -	struct rt6_info *rt = (struct rt6_info *)skb_dst(skb);
 -	struct ipv6_pinfo *np = skb->sk && !dev_recursion_level() ?
 -				inet6_sk(skb->sk) : NULL;
 +	struct rt6_info *rt = (struct rt6_info*)skb_dst(skb);
 +	struct ipv6_pinfo *np = skb->sk ? inet6_sk(skb->sk) : NULL;
  	struct ipv6hdr *tmp_hdr;
  	struct frag_hdr *fh;
  	unsigned int mtu, hlen, left, len;
@@@ -643,8 -670,8 +651,13 @@@
  				ip6_copy_metadata(frag, skb);
  			}
  
++<<<<<<< HEAD
 +			err = output(skb);
 +			if(!err)
++=======
+ 			err = output(sk, skb);
+ 			if (!err)
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  				IP6_INC_STATS(net, ip6_dst_idev(&rt->dst),
  					      IPSTATS_MIB_FRAGCREATES);
  
diff --cc net/ipv6/netfilter/nf_defrag_ipv6_hooks.c
index 7b9a748c6bac,a45db0b4785c..000000000000
--- a/net/ipv6/netfilter/nf_defrag_ipv6_hooks.c
+++ b/net/ipv6/netfilter/nf_defrag_ipv6_hooks.c
@@@ -77,9 -75,9 +77,15 @@@ static unsigned int ipv6_defrag(const s
  
  	nf_ct_frag6_consume_orig(reasm);
  
++<<<<<<< HEAD
 +	NF_HOOK_THRESH(NFPROTO_IPV6, ops->hooknum, reasm,
 +		       (struct net_device *) in, (struct net_device *) out,
 +		       okfn, NF_IP6_PRI_CONNTRACK_DEFRAG + 1);
++=======
+ 	NF_HOOK_THRESH(NFPROTO_IPV6, ops->hooknum, state->sk, reasm,
+ 		       state->in, state->out,
+ 		       state->okfn, NF_IP6_PRI_CONNTRACK_DEFRAG + 1);
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  
  	return NF_STOLEN;
  }
diff --cc net/ipv6/xfrm6_output.c
index a6d851e984dd,09c76a7b474d..000000000000
--- a/net/ipv6/xfrm6_output.c
+++ b/net/ipv6/xfrm6_output.c
@@@ -122,22 -120,30 +122,36 @@@ int xfrm6_prepare_output(struct xfrm_st
  }
  EXPORT_SYMBOL(xfrm6_prepare_output);
  
- int xfrm6_output_finish(struct sk_buff *skb)
+ int xfrm6_output_finish(struct sock *sk, struct sk_buff *skb)
  {
 -	memset(IP6CB(skb), 0, sizeof(*IP6CB(skb)));
 -
  #ifdef CONFIG_NETFILTER
  	IP6CB(skb)->flags |= IP6SKB_XFRM_TRANSFORMED;
  #endif
  
++<<<<<<< HEAD
 +	skb->protocol = htons(ETH_P_IPV6);
 +	return xfrm_output(skb);
++=======
+ 	return xfrm_output(sk, skb);
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  }
  
- static int __xfrm6_output(struct sk_buff *skb)
+ static int __xfrm6_output(struct sock *sk, struct sk_buff *skb)
  {
  	struct dst_entry *dst = skb_dst(skb);
  	struct xfrm_state *x = dst->xfrm;
  	int mtu;
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_NETFILTER
+ 	if (!x) {
+ 		IP6CB(skb)->flags |= IP6SKB_REROUTED;
+ 		return dst_output_sk(sk, skb);
+ 	}
+ #endif
+ 
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  	if (skb->protocol == htons(ETH_P_IPV6))
  		mtu = ip6_skb_dst_mtu(skb);
  	else
@@@ -161,6 -168,7 +176,12 @@@
  
  int xfrm6_output(struct sock *sk, struct sk_buff *skb)
  {
++<<<<<<< HEAD
 +	return NF_HOOK(NFPROTO_IPV6, NF_INET_POST_ROUTING, skb, NULL,
 +		       skb_dst(skb)->dev, __xfrm6_output);
++=======
+ 	return NF_HOOK_COND(NFPROTO_IPV6, NF_INET_POST_ROUTING, sk, skb,
+ 			    NULL, skb_dst(skb)->dev, __xfrm6_output,
+ 			    !(IP6CB(skb)->flags & IP6SKB_REROUTED));
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  }
diff --cc net/netfilter/nf_queue.c
index 5d24b1fdb593,3f3ac57b2998..000000000000
--- a/net/netfilter/nf_queue.c
+++ b/net/netfilter/nf_queue.c
@@@ -201,7 -202,7 +201,11 @@@ void nf_reinject(struct nf_queue_entry 
  	case NF_ACCEPT:
  	case NF_STOP:
  		local_bh_disable();
++<<<<<<< HEAD
 +		entry->okfn(skb);
++=======
+ 		entry->state.okfn(entry->state.sk, skb);
++>>>>>>> 7026b1ddb6b8 (netfilter: Pass socket pointer down through okfn().)
  		local_bh_enable();
  		break;
  	case NF_QUEUE:
* Unmerged path include/linux/netdevice.h
* Unmerged path include/linux/netfilter.h
* Unmerged path include/linux/netfilter_bridge.h
* Unmerged path include/net/dn_neigh.h
* Unmerged path include/net/ip.h
* Unmerged path include/net/ip6_route.h
* Unmerged path include/net/ipv6.h
* Unmerged path include/net/xfrm.h
diff --git a/net/bridge/br_forward.c b/net/bridge/br_forward.c
index 4b81b1471789..7040bea232a3 100644
--- a/net/bridge/br_forward.c
+++ b/net/bridge/br_forward.c
@@ -40,7 +40,7 @@ static inline unsigned int packet_length(const struct sk_buff *skb)
 	return skb->len - (skb->protocol == htons(ETH_P_8021Q) ? VLAN_HLEN : 0);
 }
 
-int br_dev_queue_push_xmit(struct sk_buff *skb)
+int br_dev_queue_push_xmit(struct sock *sk, struct sk_buff *skb)
 {
 	/* ip_fragment doesn't copy the MAC header */
 	if (nf_bridge_maybe_copy_header(skb) ||
@@ -55,9 +55,10 @@ int br_dev_queue_push_xmit(struct sk_buff *skb)
 	return 0;
 }
 
-int br_forward_finish(struct sk_buff *skb)
+int br_forward_finish(struct sock *sk, struct sk_buff *skb)
 {
-	return NF_HOOK(NFPROTO_BRIDGE, NF_BR_POST_ROUTING, skb, NULL, skb->dev,
+	return NF_HOOK(NFPROTO_BRIDGE, NF_BR_POST_ROUTING, sk, skb,
+		       NULL, skb->dev,
 		       br_dev_queue_push_xmit);
 
 }
@@ -80,7 +81,8 @@ static void __br_deliver(const struct net_bridge_port *to, struct sk_buff *skb)
 		return;
 	}
 
-	NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT, skb, NULL, skb->dev,
+	NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT, NULL, skb,
+		NULL, skb->dev,
 		br_forward_finish);
 }
 
@@ -101,7 +103,8 @@ static void __br_forward(const struct net_bridge_port *to, struct sk_buff *skb)
 	skb->dev = to->dev;
 	skb_forward_csum(skb);
 
-	NF_HOOK(NFPROTO_BRIDGE, NF_BR_FORWARD, skb, indev, skb->dev,
+	NF_HOOK(NFPROTO_BRIDGE, NF_BR_FORWARD, NULL, skb,
+		indev, skb->dev,
 		br_forward_finish);
 }
 
diff --git a/net/bridge/br_input.c b/net/bridge/br_input.c
index cf29b38b3b0c..0a1c5e4d8dc2 100644
--- a/net/bridge/br_input.c
+++ b/net/bridge/br_input.c
@@ -53,12 +53,13 @@ static int br_pass_frame_up(struct sk_buff *skb)
 	if (!skb)
 		return NET_RX_DROP;
 
-	return NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN, skb, indev, NULL,
-		       netif_receive_skb);
+	return NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN, NULL, skb,
+		       indev, NULL,
+		       netif_receive_skb_sk);
 }
 
 /* note: already called with rcu_read_lock */
-int br_handle_frame_finish(struct sk_buff *skb)
+int br_handle_frame_finish(struct sock *sk, struct sk_buff *skb)
 {
 	const unsigned char *dest = eth_hdr(skb)->h_dest;
 	struct net_bridge_port *p = br_port_get_rcu(skb->dev);
@@ -142,7 +143,7 @@ drop:
 }
 
 /* note: already called with rcu_read_lock */
-static int br_handle_local_finish(struct sk_buff *skb)
+static int br_handle_local_finish(struct sock *sk, struct sk_buff *skb)
 {
 	struct net_bridge_port *p = br_port_get_rcu(skb->dev);
 	u16 vid = 0;
@@ -208,8 +209,8 @@ rx_handler_result_t br_handle_frame(struct sk_buff **pskb)
 		}
 
 		/* Deliver packet to local host only */
-		if (NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN, skb, skb->dev,
-			    NULL, br_handle_local_finish)) {
+		if (NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN, NULL, skb,
+			    skb->dev, NULL, br_handle_local_finish)) {
 			return RX_HANDLER_CONSUMED; /* consumed by filter */
 		} else {
 			*pskb = skb;
@@ -233,7 +234,8 @@ forward:
 		if (ether_addr_equal(p->br->dev->dev_addr, dest))
 			skb->pkt_type = PACKET_HOST;
 
-		NF_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING, skb, skb->dev, NULL,
+		NF_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING, NULL, skb,
+			skb->dev, NULL,
 			br_handle_frame_finish);
 		break;
 	default:
* Unmerged path net/bridge/br_multicast.c
* Unmerged path net/bridge/br_netfilter.c
diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index fe99f0095976..9e1d7bf3bee4 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -424,10 +424,10 @@ void br_fdb_unsync_static(struct net_bridge *br, struct net_bridge_port *p);
 
 /* br_forward.c */
 void br_deliver(const struct net_bridge_port *to, struct sk_buff *skb);
-int br_dev_queue_push_xmit(struct sk_buff *skb);
+int br_dev_queue_push_xmit(struct sock *sk, struct sk_buff *skb);
 void br_forward(const struct net_bridge_port *to,
 		struct sk_buff *skb, struct sk_buff *skb0);
-int br_forward_finish(struct sk_buff *skb);
+int br_forward_finish(struct sock *sk, struct sk_buff *skb);
 void br_flood_deliver(struct net_bridge *br, struct sk_buff *skb, bool unicast);
 void br_flood_forward(struct net_bridge *br, struct sk_buff *skb,
 		      struct sk_buff *skb2, bool unicast);
@@ -446,7 +446,7 @@ void br_port_flags_change(struct net_bridge_port *port, unsigned long mask);
 void br_manage_promisc(struct net_bridge *br);
 
 /* br_input.c */
-int br_handle_frame_finish(struct sk_buff *skb);
+int br_handle_frame_finish(struct sock *sk, struct sk_buff *skb);
 rx_handler_result_t br_handle_frame(struct sk_buff **pskb);
 
 static inline bool br_rx_handler_check_rcu(const struct net_device *dev)
diff --git a/net/bridge/br_stp_bpdu.c b/net/bridge/br_stp_bpdu.c
index bdb459d21ad8..534fc4cd263e 100644
--- a/net/bridge/br_stp_bpdu.c
+++ b/net/bridge/br_stp_bpdu.c
@@ -54,8 +54,9 @@ static void br_send_bpdu(struct net_bridge_port *p,
 
 	skb_reset_mac_header(skb);
 
-	NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT, skb, NULL, skb->dev,
-		dev_queue_xmit);
+	NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT, NULL, skb,
+		NULL, skb->dev,
+		dev_queue_xmit_sk);
 }
 
 static inline void br_set_ticks(unsigned char *dest, int j)
* Unmerged path net/core/dev.c
* Unmerged path net/decnet/dn_neigh.c
diff --git a/net/decnet/dn_nsp_in.c b/net/decnet/dn_nsp_in.c
index c344163e6ac0..867025b4ed66 100644
--- a/net/decnet/dn_nsp_in.c
+++ b/net/decnet/dn_nsp_in.c
@@ -716,7 +716,7 @@ out:
 	return ret;
 }
 
-static int dn_nsp_rx_packet(struct sk_buff *skb)
+static int dn_nsp_rx_packet(struct sock *sk2, struct sk_buff *skb)
 {
 	struct dn_skb_cb *cb = DN_SKB_CB(skb);
 	struct sock *sk = NULL;
@@ -816,7 +816,8 @@ free_out:
 
 int dn_nsp_rx(struct sk_buff *skb)
 {
-	return NF_HOOK(NFPROTO_DECNET, NF_DN_LOCAL_IN, skb, skb->dev, NULL,
+	return NF_HOOK(NFPROTO_DECNET, NF_DN_LOCAL_IN, NULL, skb,
+		       skb->dev, NULL,
 		       dn_nsp_rx_packet);
 }
 
diff --git a/net/decnet/dn_route.c b/net/decnet/dn_route.c
index 4cea10115f2e..5ea74c909267 100644
--- a/net/decnet/dn_route.c
+++ b/net/decnet/dn_route.c
@@ -513,7 +513,7 @@ static int dn_return_long(struct sk_buff *skb)
  *
  * Returns: result of input function if route is found, error code otherwise
  */
-static int dn_route_rx_packet(struct sk_buff *skb)
+static int dn_route_rx_packet(struct sock *sk, struct sk_buff *skb)
 {
 	struct dn_skb_cb *cb;
 	int err;
@@ -574,7 +574,8 @@ static int dn_route_rx_long(struct sk_buff *skb)
 	ptr++;
 	cb->hops = *ptr++; /* Visit Count */
 
-	return NF_HOOK(NFPROTO_DECNET, NF_DN_PRE_ROUTING, skb, skb->dev, NULL,
+	return NF_HOOK(NFPROTO_DECNET, NF_DN_PRE_ROUTING, NULL, skb,
+		       skb->dev, NULL,
 		       dn_route_rx_packet);
 
 drop_it:
@@ -601,7 +602,8 @@ static int dn_route_rx_short(struct sk_buff *skb)
 	ptr += 2;
 	cb->hops = *ptr & 0x3f;
 
-	return NF_HOOK(NFPROTO_DECNET, NF_DN_PRE_ROUTING, skb, skb->dev, NULL,
+	return NF_HOOK(NFPROTO_DECNET, NF_DN_PRE_ROUTING, NULL, skb,
+		       skb->dev, NULL,
 		       dn_route_rx_packet);
 
 drop_it:
@@ -609,7 +611,7 @@ drop_it:
 	return NET_RX_DROP;
 }
 
-static int dn_route_discard(struct sk_buff *skb)
+static int dn_route_discard(struct sock *sk, struct sk_buff *skb)
 {
 	/*
 	 * I know we drop the packet here, but thats considered success in
@@ -619,7 +621,7 @@ static int dn_route_discard(struct sk_buff *skb)
 	return NET_RX_SUCCESS;
 }
 
-static int dn_route_ptp_hello(struct sk_buff *skb)
+static int dn_route_ptp_hello(struct sock *sk, struct sk_buff *skb)
 {
 	dn_dev_hello(skb);
 	dn_neigh_pointopoint_hello(skb);
@@ -705,22 +707,22 @@ int dn_route_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type
 		switch (flags & DN_RT_CNTL_MSK) {
 		case DN_RT_PKT_HELO:
 			return NF_HOOK(NFPROTO_DECNET, NF_DN_HELLO,
-				       skb, skb->dev, NULL,
+				       NULL, skb, skb->dev, NULL,
 				       dn_route_ptp_hello);
 
 		case DN_RT_PKT_L1RT:
 		case DN_RT_PKT_L2RT:
 			return NF_HOOK(NFPROTO_DECNET, NF_DN_ROUTE,
-				       skb, skb->dev, NULL,
+				       NULL, skb, skb->dev, NULL,
 				       dn_route_discard);
 		case DN_RT_PKT_ERTH:
 			return NF_HOOK(NFPROTO_DECNET, NF_DN_HELLO,
-				       skb, skb->dev, NULL,
+				       NULL, skb, skb->dev, NULL,
 				       dn_neigh_router_hello);
 
 		case DN_RT_PKT_EEDH:
 			return NF_HOOK(NFPROTO_DECNET, NF_DN_HELLO,
-				       skb, skb->dev, NULL,
+				       NULL, skb, skb->dev, NULL,
 				       dn_neigh_endnode_hello);
 		}
 	} else {
@@ -778,7 +780,8 @@ static int dn_output(struct sock *sk, struct sk_buff *skb)
 	cb->rt_flags |= DN_RT_F_IE;
 	cb->hops = 0;
 
-	return NF_HOOK(NFPROTO_DECNET, NF_DN_LOCAL_OUT, skb, NULL, dev,
+	return NF_HOOK(NFPROTO_DECNET, NF_DN_LOCAL_OUT, sk, skb,
+		       NULL, dev,
 		       dn_to_neigh_output);
 
 error:
@@ -826,7 +829,8 @@ static int dn_forward(struct sk_buff *skb)
 	if (rt->rt_flags & RTCF_DOREDIRECT)
 		cb->rt_flags |= DN_RT_F_IE;
 
-	return NF_HOOK(NFPROTO_DECNET, NF_DN_FORWARD, skb, dev, skb->dev,
+	return NF_HOOK(NFPROTO_DECNET, NF_DN_FORWARD, NULL, skb,
+		       dev, skb->dev,
 		       dn_to_neigh_output);
 
 drop:
diff --git a/net/ipv4/arp.c b/net/ipv4/arp.c
index d2b96c3354dc..eb2b67ce4b84 100644
--- a/net/ipv4/arp.c
+++ b/net/ipv4/arp.c
@@ -683,7 +683,8 @@ EXPORT_SYMBOL(arp_create);
 void arp_xmit(struct sk_buff *skb)
 {
 	/* Send it off, maybe filter it using firewalling first.  */
-	NF_HOOK(NFPROTO_ARP, NF_ARP_OUT, skb, NULL, skb->dev, dev_queue_xmit);
+	NF_HOOK(NFPROTO_ARP, NF_ARP_OUT, NULL, skb,
+		NULL, skb->dev, dev_queue_xmit_sk);
 }
 EXPORT_SYMBOL(arp_xmit);
 
@@ -717,7 +718,7 @@ EXPORT_SYMBOL(arp_send);
  *	Process an arp request.
  */
 
-static int arp_process(struct sk_buff *skb)
+static int arp_process(struct sock *sk, struct sk_buff *skb)
 {
 	struct net_device *dev = skb->dev;
 	struct in_device *in_dev = __in_dev_get_rcu(dev);
@@ -933,7 +934,7 @@ out:
 
 static void parp_redo(struct sk_buff *skb)
 {
-	arp_process(skb);
+	arp_process(NULL, skb);
 }
 
 
@@ -965,7 +966,8 @@ static int arp_rcv(struct sk_buff *skb, struct net_device *dev,
 
 	memset(NEIGH_CB(skb), 0, sizeof(struct neighbour_cb));
 
-	return NF_HOOK(NFPROTO_ARP, NF_ARP_IN, skb, dev, NULL, arp_process);
+	return NF_HOOK(NFPROTO_ARP, NF_ARP_IN, NULL, skb,
+		       dev, NULL, arp_process);
 
 freeskb:
 	kfree_skb(skb);
* Unmerged path net/ipv4/ip_forward.c
diff --git a/net/ipv4/ip_input.c b/net/ipv4/ip_input.c
index 3d4da2c16b6a..e24340dde310 100644
--- a/net/ipv4/ip_input.c
+++ b/net/ipv4/ip_input.c
@@ -187,7 +187,7 @@ bool ip_call_ra_chain(struct sk_buff *skb)
 	return false;
 }
 
-static int ip_local_deliver_finish(struct sk_buff *skb)
+static int ip_local_deliver_finish(struct sock *sk, struct sk_buff *skb)
 {
 	struct net *net = dev_net(skb->dev);
 
@@ -253,7 +253,8 @@ int ip_local_deliver(struct sk_buff *skb)
 			return 0;
 	}
 
-	return NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_IN, skb, skb->dev, NULL,
+	return NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_IN, NULL, skb,
+		       skb->dev, NULL,
 		       ip_local_deliver_finish);
 }
 
@@ -309,7 +310,7 @@ drop:
 int sysctl_ip_early_demux __read_mostly = 1;
 EXPORT_SYMBOL(sysctl_ip_early_demux);
 
-static int ip_rcv_finish(struct sk_buff *skb)
+static int ip_rcv_finish(struct sock *sk, struct sk_buff *skb)
 {
 	const struct iphdr *iph = ip_hdr(skb);
 	struct rtable *rt;
@@ -450,7 +451,8 @@ int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt,
 	/* Must drop socket now because of tproxy. */
 	skb_orphan(skb);
 
-	return NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, skb, dev, NULL,
+	return NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, NULL, skb,
+		       dev, NULL,
 		       ip_rcv_finish);
 
 csum_error:
* Unmerged path net/ipv4/ip_output.c
diff --git a/net/ipv4/ipmr.c b/net/ipv4/ipmr.c
index ca997b6766ed..6c67594be979 100644
--- a/net/ipv4/ipmr.c
+++ b/net/ipv4/ipmr.c
@@ -1672,7 +1672,7 @@ static void ip_encap(struct sk_buff *skb, __be32 saddr, __be32 daddr)
 	nf_reset(skb);
 }
 
-static inline int ipmr_forward_finish(struct sk_buff *skb)
+static inline int ipmr_forward_finish(struct sock *sk, struct sk_buff *skb)
 {
 	struct ip_options *opt = &(IPCB(skb)->opt);
 
@@ -1682,7 +1682,7 @@ static inline int ipmr_forward_finish(struct sk_buff *skb)
 	if (unlikely(opt->optlen))
 		ip_forward_options(skb);
 
-	return dst_output(skb);
+	return dst_output_sk(sk, skb);
 }
 
 /*
@@ -1781,7 +1781,8 @@ static void ipmr_queue_xmit(struct net *net, struct mr_table *mrt,
 	 * not mrouter) cannot join to more than one interface - it will
 	 * result in receiving multiple packets.
 	 */
-	NF_HOOK(NFPROTO_IPV4, NF_INET_FORWARD, skb, skb->dev, dev,
+	NF_HOOK(NFPROTO_IPV4, NF_INET_FORWARD, NULL, skb,
+		skb->dev, dev,
 		ipmr_forward_finish);
 	return;
 
diff --git a/net/ipv4/raw.c b/net/ipv4/raw.c
index aa890cf77afa..20b9799a4368 100644
--- a/net/ipv4/raw.c
+++ b/net/ipv4/raw.c
@@ -395,8 +395,8 @@ static int raw_send_hdrinc(struct sock *sk, struct flowi4 *fl4,
 		icmp_out_count(net, ((struct icmphdr *)
 			skb_transport_header(skb))->type);
 
-	err = NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_OUT, skb, NULL,
-		      rt->dst.dev, dst_output);
+	err = NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_OUT, sk, skb,
+		      NULL, rt->dst.dev, dst_output_sk);
 	if (err > 0)
 		err = net_xmit_errno(err);
 	if (err)
diff --git a/net/ipv4/xfrm4_input.c b/net/ipv4/xfrm4_input.c
index aac6197b7a71..07235806abf9 100644
--- a/net/ipv4/xfrm4_input.c
+++ b/net/ipv4/xfrm4_input.c
@@ -22,7 +22,7 @@ int xfrm4_extract_input(struct xfrm_state *x, struct sk_buff *skb)
 	return xfrm4_extract_header(skb);
 }
 
-static inline int xfrm4_rcv_encap_finish(struct sk_buff *skb)
+static inline int xfrm4_rcv_encap_finish(struct sock *sk, struct sk_buff *skb)
 {
 	if (skb_dst(skb) == NULL) {
 		const struct iphdr *iph = ip_hdr(skb);
@@ -52,7 +52,8 @@ int xfrm4_transport_finish(struct sk_buff *skb, int async)
 	iph->tot_len = htons(skb->len);
 	ip_send_check(iph);
 
-	NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, skb, skb->dev, NULL,
+	NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, NULL, skb,
+		skb->dev, NULL,
 		xfrm4_rcv_encap_finish);
 	return 0;
 }
* Unmerged path net/ipv4/xfrm4_output.c
diff --git a/net/ipv6/ip6_input.c b/net/ipv6/ip6_input.c
index 51d54dc376f3..0bb54e23a9a2 100644
--- a/net/ipv6/ip6_input.c
+++ b/net/ipv6/ip6_input.c
@@ -46,8 +46,7 @@
 #include <net/xfrm.h>
 #include <net/inet_ecn.h>
 
-
-int ip6_rcv_finish(struct sk_buff *skb)
+int ip6_rcv_finish(struct sock *sk, struct sk_buff *skb)
 {
 	if (sysctl_ip_early_demux && !skb_dst(skb) && skb->sk == NULL) {
 		const struct inet6_protocol *ipprot;
@@ -183,7 +182,8 @@ int ipv6_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt
 	/* Must drop socket now because of tproxy. */
 	skb_orphan(skb);
 
-	return NF_HOOK(NFPROTO_IPV6, NF_INET_PRE_ROUTING, skb, dev, NULL,
+	return NF_HOOK(NFPROTO_IPV6, NF_INET_PRE_ROUTING, NULL, skb,
+		       dev, NULL,
 		       ip6_rcv_finish);
 err:
 	IP6_INC_STATS_BH(net, idev, IPSTATS_MIB_INHDRERRORS);
@@ -198,7 +198,7 @@ drop:
  */
 
 
-static int ip6_input_finish(struct sk_buff *skb)
+static int ip6_input_finish(struct sock *sk, struct sk_buff *skb)
 {
 	struct net *net = dev_net(skb_dst(skb)->dev);
 	const struct inet6_protocol *ipprot;
@@ -276,7 +276,8 @@ discard:
 
 int ip6_input(struct sk_buff *skb)
 {
-	return NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_IN, skb, skb->dev, NULL,
+	return NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_IN, NULL, skb,
+		       skb->dev, NULL,
 		       ip6_input_finish);
 }
 
* Unmerged path net/ipv6/ip6_output.c
diff --git a/net/ipv6/ip6mr.c b/net/ipv6/ip6mr.c
index 4896130c6c59..9f1716d6268e 100644
--- a/net/ipv6/ip6mr.c
+++ b/net/ipv6/ip6mr.c
@@ -1982,13 +1982,13 @@ int ip6mr_compat_ioctl(struct sock *sk, unsigned int cmd, void __user *arg)
 }
 #endif
 
-static inline int ip6mr_forward2_finish(struct sk_buff *skb)
+static inline int ip6mr_forward2_finish(struct sock *sk, struct sk_buff *skb)
 {
 	IP6_INC_STATS_BH(dev_net(skb_dst(skb)->dev), ip6_dst_idev(skb_dst(skb)),
 			 IPSTATS_MIB_OUTFORWDATAGRAMS);
 	IP6_ADD_STATS_BH(dev_net(skb_dst(skb)->dev), ip6_dst_idev(skb_dst(skb)),
 			 IPSTATS_MIB_OUTOCTETS, skb->len);
-	return dst_output(skb);
+	return dst_output_sk(sk, skb);
 }
 
 /*
@@ -2060,7 +2060,8 @@ static int ip6mr_forward2(struct net *net, struct mr6_table *mrt,
 
 	IP6CB(skb)->flags |= IP6SKB_FORWARDED;
 
-	return NF_HOOK(NFPROTO_IPV6, NF_INET_FORWARD, skb, skb->dev, dev,
+	return NF_HOOK(NFPROTO_IPV6, NF_INET_FORWARD, NULL, skb,
+		       skb->dev, dev,
 		       ip6mr_forward2_finish);
 
 out_free:
diff --git a/net/ipv6/mcast.c b/net/ipv6/mcast.c
index 8c315d7cece8..3c950d9647eb 100644
--- a/net/ipv6/mcast.c
+++ b/net/ipv6/mcast.c
@@ -1650,8 +1650,9 @@ static void mld_sendpack(struct sk_buff *skb)
 
 	payload_len = skb->len;
 
-	err = NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT, skb, NULL, skb->dev,
-		      dst_output);
+	err = NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT,
+		      net->ipv6.igmp_sk, skb, NULL, skb->dev,
+		      dst_output_sk);
 out:
 	if (!err) {
 		ICMP6MSGOUT_INC_STATS_BH(net, idev, ICMPV6_MLD2_REPORT);
@@ -2012,8 +2013,8 @@ static void igmp6_send(struct in6_addr *addr, struct net_device *dev, int type)
 	}
 
 	skb_dst_set(skb, dst);
-	err = NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT, skb, NULL, skb->dev,
-		      dst_output);
+	err = NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT, sk, skb,
+		      NULL, skb->dev, dst_output_sk);
 out:
 	if (!err) {
 		ICMP6MSGOUT_INC_STATS(net, idev, type);
diff --git a/net/ipv6/ndisc.c b/net/ipv6/ndisc.c
index 53742a5bf344..fbecde19dbbf 100644
--- a/net/ipv6/ndisc.c
+++ b/net/ipv6/ndisc.c
@@ -456,8 +456,9 @@ static void ndisc_send_skb(struct sk_buff *skb,
 	idev = __in6_dev_get(dst->dev);
 	IP6_UPD_PO_STATS(net, idev, IPSTATS_MIB_OUT, skb->len);
 
-	err = NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT, skb, NULL, dst->dev,
-		      dst_output);
+	err = NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT, sk, skb,
+		      NULL, dst->dev,
+		      dst_output_sk);
 	if (!err) {
 		ICMP6MSGOUT_INC_STATS(net, idev, type);
 		ICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTMSGS);
* Unmerged path net/ipv6/netfilter/nf_defrag_ipv6_hooks.c
diff --git a/net/ipv6/output_core.c b/net/ipv6/output_core.c
index 827f795209cf..74bb0798ecdc 100644
--- a/net/ipv6/output_core.c
+++ b/net/ipv6/output_core.c
@@ -107,8 +107,8 @@ int __ip6_local_out(struct sk_buff *skb)
 		len = 0;
 	ipv6_hdr(skb)->payload_len = htons(len);
 
-	return nf_hook(NFPROTO_IPV6, NF_INET_LOCAL_OUT, skb, NULL,
-		       skb_dst(skb)->dev, dst_output);
+	return nf_hook(NFPROTO_IPV6, NF_INET_LOCAL_OUT, skb->sk, skb,
+		       NULL, skb_dst(skb)->dev, dst_output_sk);
 }
 EXPORT_SYMBOL_GPL(__ip6_local_out);
 
diff --git a/net/ipv6/raw.c b/net/ipv6/raw.c
index 12edbea057ab..d35399e44438 100644
--- a/net/ipv6/raw.c
+++ b/net/ipv6/raw.c
@@ -642,8 +642,8 @@ static int rawv6_send_hdrinc(struct sock *sk, void *from, int length,
 		goto error_fault;
 
 	IP6_UPD_PO_STATS(sock_net(sk), rt->rt6i_idev, IPSTATS_MIB_OUT, skb->len);
-	err = NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT, skb, NULL,
-		      rt->dst.dev, dst_output);
+	err = NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT, sk, skb,
+		      NULL, rt->dst.dev, dst_output_sk);
 	if (err > 0)
 		err = net_xmit_errno(err);
 	if (err)
diff --git a/net/ipv6/xfrm6_input.c b/net/ipv6/xfrm6_input.c
index f8c3cf842f53..36a7ea6a3ef7 100644
--- a/net/ipv6/xfrm6_input.c
+++ b/net/ipv6/xfrm6_input.c
@@ -42,7 +42,8 @@ int xfrm6_transport_finish(struct sk_buff *skb, int async)
 	ipv6_hdr(skb)->payload_len = htons(skb->len);
 	__skb_push(skb, skb->data - skb_network_header(skb));
 
-	NF_HOOK(NFPROTO_IPV6, NF_INET_PRE_ROUTING, skb, skb->dev, NULL,
+	NF_HOOK(NFPROTO_IPV6, NF_INET_PRE_ROUTING, NULL, skb,
+		skb->dev, NULL,
 		ip6_rcv_finish);
 	return -1;
 }
* Unmerged path net/ipv6/xfrm6_output.c
diff --git a/net/netfilter/ipvs/ip_vs_xmit.c b/net/netfilter/ipvs/ip_vs_xmit.c
index c47444e4cf8c..4093a16304cf 100644
--- a/net/netfilter/ipvs/ip_vs_xmit.c
+++ b/net/netfilter/ipvs/ip_vs_xmit.c
@@ -503,8 +503,8 @@ static inline int ip_vs_nat_send_or_cont(int pf, struct sk_buff *skb,
 		ip_vs_update_conntrack(skb, cp, 1);
 	if (!local) {
 		skb_forward_csum(skb);
-		NF_HOOK(pf, NF_INET_LOCAL_OUT, skb, NULL, skb_dst(skb)->dev,
-			dst_output);
+		NF_HOOK(pf, NF_INET_LOCAL_OUT, NULL, skb,
+			NULL, skb_dst(skb)->dev, dst_output_sk);
 	} else
 		ret = NF_ACCEPT;
 	return ret;
@@ -521,8 +521,8 @@ static inline int ip_vs_send_or_cont(int pf, struct sk_buff *skb,
 		ip_vs_notrack(skb);
 	if (!local) {
 		skb_forward_csum(skb);
-		NF_HOOK(pf, NF_INET_LOCAL_OUT, skb, NULL, skb_dst(skb)->dev,
-			dst_output);
+		NF_HOOK(pf, NF_INET_LOCAL_OUT, NULL, skb,
+			NULL, skb_dst(skb)->dev, dst_output_sk);
 	} else
 		ret = NF_ACCEPT;
 	return ret;
* Unmerged path net/netfilter/nf_queue.c
diff --git a/net/xfrm/xfrm_output.c b/net/xfrm/xfrm_output.c
index ffa9a0ba3f1f..69e0343c5147 100644
--- a/net/xfrm/xfrm_output.c
+++ b/net/xfrm/xfrm_output.c
@@ -19,7 +19,7 @@
 #include <net/dst.h>
 #include <net/xfrm.h>
 
-static int xfrm_output2(struct sk_buff *skb);
+static int xfrm_output2(struct sock *sk, struct sk_buff *skb);
 
 static int xfrm_skb_check_space(struct sk_buff *skb)
 {
@@ -131,7 +131,7 @@ int xfrm_output_resume(struct sk_buff *skb, int err)
 			return dst_output(skb);
 
 		err = nf_hook(skb_dst(skb)->ops->family,
-			      NF_INET_POST_ROUTING, skb,
+			      NF_INET_POST_ROUTING, skb->sk, skb,
 			      NULL, skb_dst(skb)->dev, xfrm_output2);
 		if (unlikely(err != 1))
 			goto out;
@@ -145,12 +145,12 @@ out:
 }
 EXPORT_SYMBOL_GPL(xfrm_output_resume);
 
-static int xfrm_output2(struct sk_buff *skb)
+static int xfrm_output2(struct sock *sk, struct sk_buff *skb)
 {
 	return xfrm_output_resume(skb, 1);
 }
 
-static int xfrm_output_gso(struct sk_buff *skb)
+static int xfrm_output_gso(struct sock *sk, struct sk_buff *skb)
 {
 	struct sk_buff *segs;
 
@@ -166,7 +166,7 @@ static int xfrm_output_gso(struct sk_buff *skb)
 		int err;
 
 		segs->next = NULL;
-		err = xfrm_output2(segs);
+		err = xfrm_output2(sk, segs);
 
 		if (unlikely(err)) {
 			while ((segs = nskb)) {
@@ -183,13 +183,13 @@ static int xfrm_output_gso(struct sk_buff *skb)
 	return 0;
 }
 
-int xfrm_output(struct sk_buff *skb)
+int xfrm_output(struct sock *sk, struct sk_buff *skb)
 {
 	struct net *net = dev_net(skb_dst(skb)->dev);
 	int err;
 
 	if (skb_is_gso(skb))
-		return xfrm_output_gso(skb);
+		return xfrm_output_gso(sk, skb);
 
 	if (skb->ip_summed == CHECKSUM_PARTIAL) {
 		err = skb_checksum_help(skb);
@@ -200,7 +200,7 @@ int xfrm_output(struct sk_buff *skb)
 		}
 	}
 
-	return xfrm_output2(skb);
+	return xfrm_output2(sk, skb);
 }
 
 int xfrm_inner_extract_output(struct xfrm_state *x, struct sk_buff *skb)
