bonding: consolidate the two rlb_next_rx_slave functions into one

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Nikolay Aleksandrov <nikolay@redhat.com>
commit 56924c3811ae843527f7a1090ead73a0acf704a4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/56924c38.failed

__rlb_next_rx_slave() is a copy of rlb_next_rx_slave() with the
difference that it uses rcu primitives to walk the slave list. We don't
need the two functions and can make rlb_next_rx_slave() a wrapper for
callers which hold RTNL.
So add a comment and ASSERT_RTNL() to make sure what is intended.

	Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 56924c3811ae843527f7a1090ead73a0acf704a4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_alb.c
diff --cc drivers/net/bonding/bond_alb.c
index 06a8df1ef842,4efdeb67ab7c..000000000000
--- a/drivers/net/bonding/bond_alb.c
+++ b/drivers/net/bonding/bond_alb.c
@@@ -373,34 -334,35 +373,53 @@@ out
  	return RX_HANDLER_ANOTHER;
  }
  
++<<<<<<< HEAD
 +/* Caller must hold bond lock for read */
 +static struct slave *rlb_next_rx_slave(struct bonding *bond)
 +{
 +	struct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));
 +	struct slave *rx_slave, *slave, *start_at;
 +	int i = 0;
 +
 +	if (bond_info->next_rx_slave) {
 +		start_at = bond_info->next_rx_slave;
 +	} else {
 +		start_at = bond->first_slave;
 +	}
 +
 +	rx_slave = NULL;
 +
 +	bond_for_each_slave_from(bond, slave, i, start_at) {
 +		if (SLAVE_IS_OK(slave)) {
 +			if (!rx_slave) {
++=======
+ /* Caller must hold rcu_read_lock() */
+ static struct slave *__rlb_next_rx_slave(struct bonding *bond)
+ {
+ 	struct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));
+ 	struct slave *before = NULL, *rx_slave = NULL, *slave;
+ 	struct list_head *iter;
+ 	bool found = false;
+ 
+ 	bond_for_each_slave_rcu(bond, slave, iter) {
+ 		if (!bond_slave_can_tx(slave))
+ 			continue;
+ 		if (!found) {
+ 			if (!before || before->speed < slave->speed)
+ 				before = slave;
+ 		} else {
+ 			if (!rx_slave || rx_slave->speed < slave->speed)
++>>>>>>> 56924c3811ae (bonding: consolidate the two rlb_next_rx_slave functions into one)
 +				rx_slave = slave;
 +			} else if (slave->speed > rx_slave->speed) {
  				rx_slave = slave;
 +			}
  		}
 -		if (slave == bond_info->rx_slave)
 -			found = true;
  	}
 -	/* we didn't find anything after the current or we have something
 -	 * better before and up to the current slave
 -	 */
 -	if (!rx_slave || (before && rx_slave->speed < before->speed))
 -		rx_slave = before;
  
 -	if (rx_slave)
 -		bond_info->rx_slave = rx_slave;
 +	if (rx_slave) {
 +		bond_info->next_rx_slave = rx_slave->next;
 +	}
  
  	return rx_slave;
  }
* Unmerged path drivers/net/bonding/bond_alb.c
