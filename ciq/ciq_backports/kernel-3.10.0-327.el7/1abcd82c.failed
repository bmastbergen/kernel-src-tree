openvswitch: actions: use skb_postpull_rcsum when possible

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Jiri Pirko <jiri@resnulli.us>
commit 1abcd82c20e7cbfd2b89d834b24ff68feae158ec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/1abcd82c.failed

Replace duplicated code by calling skb_postpull_rcsum

	Suggested-by: Eric Dumazet <eric.dumazet@gmail.com>
	Signed-off-by: Jiri Pirko <jiri@resnulli.us>
	Acked-by: Pravin B Shelar <pshelar@nicira.com>
	Acked-by: Simon Horman <simon.horman@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1abcd82c20e7cbfd2b89d834b24ff68feae158ec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/openvswitch/actions.c
diff --cc net/openvswitch/actions.c
index 5e332feb5508,749a30163071..000000000000
--- a/net/openvswitch/actions.c
+++ b/net/openvswitch/actions.c
@@@ -118,6 -130,93 +118,96 @@@ static int make_writable(struct sk_buf
  	return pskb_expand_head(skb, 0, 0, GFP_ATOMIC);
  }
  
++<<<<<<< HEAD
++=======
+ static int push_mpls(struct sk_buff *skb, struct sw_flow_key *key,
+ 		     const struct ovs_action_push_mpls *mpls)
+ {
+ 	__be32 *new_mpls_lse;
+ 	struct ethhdr *hdr;
+ 
+ 	/* Networking stack do not allow simultaneous Tunnel and MPLS GSO. */
+ 	if (skb->encapsulation)
+ 		return -ENOTSUPP;
+ 
+ 	if (skb_cow_head(skb, MPLS_HLEN) < 0)
+ 		return -ENOMEM;
+ 
+ 	skb_push(skb, MPLS_HLEN);
+ 	memmove(skb_mac_header(skb) - MPLS_HLEN, skb_mac_header(skb),
+ 		skb->mac_len);
+ 	skb_reset_mac_header(skb);
+ 
+ 	new_mpls_lse = (__be32 *)skb_mpls_header(skb);
+ 	*new_mpls_lse = mpls->mpls_lse;
+ 
+ 	if (skb->ip_summed == CHECKSUM_COMPLETE)
+ 		skb->csum = csum_add(skb->csum, csum_partial(new_mpls_lse,
+ 							     MPLS_HLEN, 0));
+ 
+ 	hdr = eth_hdr(skb);
+ 	hdr->h_proto = mpls->mpls_ethertype;
+ 
+ 	skb_set_inner_protocol(skb, skb->protocol);
+ 	skb->protocol = mpls->mpls_ethertype;
+ 
+ 	invalidate_flow_key(key);
+ 	return 0;
+ }
+ 
+ static int pop_mpls(struct sk_buff *skb, struct sw_flow_key *key,
+ 		    const __be16 ethertype)
+ {
+ 	struct ethhdr *hdr;
+ 	int err;
+ 
+ 	err = make_writable(skb, skb->mac_len + MPLS_HLEN);
+ 	if (unlikely(err))
+ 		return err;
+ 
+ 	skb_postpull_rcsum(skb, skb_mpls_header(skb), MPLS_HLEN);
+ 
+ 	memmove(skb_mac_header(skb) + MPLS_HLEN, skb_mac_header(skb),
+ 		skb->mac_len);
+ 
+ 	__skb_pull(skb, MPLS_HLEN);
+ 	skb_reset_mac_header(skb);
+ 
+ 	/* skb_mpls_header() is used to locate the ethertype
+ 	 * field correctly in the presence of VLAN tags.
+ 	 */
+ 	hdr = (struct ethhdr *)(skb_mpls_header(skb) - ETH_HLEN);
+ 	hdr->h_proto = ethertype;
+ 	if (eth_p_mpls(skb->protocol))
+ 		skb->protocol = ethertype;
+ 
+ 	invalidate_flow_key(key);
+ 	return 0;
+ }
+ 
+ static int set_mpls(struct sk_buff *skb, struct sw_flow_key *key,
+ 		    const __be32 *mpls_lse)
+ {
+ 	__be32 *stack;
+ 	int err;
+ 
+ 	err = make_writable(skb, skb->mac_len + MPLS_HLEN);
+ 	if (unlikely(err))
+ 		return err;
+ 
+ 	stack = (__be32 *)skb_mpls_header(skb);
+ 	if (skb->ip_summed == CHECKSUM_COMPLETE) {
+ 		__be32 diff[] = { ~(*stack), *mpls_lse };
+ 		skb->csum = ~csum_partial((char *)diff, sizeof(diff),
+ 					  ~skb->csum);
+ 	}
+ 
+ 	*stack = *mpls_lse;
+ 	key->mpls.top_lse = *mpls_lse;
+ 	return 0;
+ }
+ 
++>>>>>>> 1abcd82c20e7 (openvswitch: actions: use skb_postpull_rcsum when possible)
  /* remove VLAN header from packet and update csum accordingly. */
  static int __pop_vlan_tci(struct sk_buff *skb, __be16 *current_tci)
  {
* Unmerged path net/openvswitch/actions.c
