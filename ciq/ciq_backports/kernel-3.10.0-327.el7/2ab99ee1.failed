fs: track fl_owner for leases

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 2ab99ee12440e66ec1efd2a98599010471de785e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/2ab99ee1.failed

Just like for other lock types we should allow different owners to have
a read lease on a file.  Currently this can't happen, but with the addition
of pNFS layout leases we'll need this feature.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 2ab99ee12440e66ec1efd2a98599010471de785e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/locks.c
#	fs/nfsd/nfs4state.c
diff --cc fs/locks.c
index 539c15f0037d,22ac7694cc84..000000000000
--- a/fs/locks.c
+++ b/fs/locks.c
@@@ -1561,13 -1660,13 +1561,20 @@@ static int generic_add_lease(struct fil
  	 * except for this filp.
  	 */
  	error = -EAGAIN;
++<<<<<<< HEAD
 +	for (before = &inode->i_flock;
 +			((fl = *before) != NULL) && IS_LEASE(fl);
 +			before = &fl->fl_next) {
 +		if (fl->fl_file == filp) {
 +			my_before = before;
++=======
+ 	list_for_each_entry(fl, &ctx->flc_lease, fl_list) {
+ 		if (fl->fl_file == filp &&
+ 		    fl->fl_owner == lease->fl_owner) {
+ 			my_fl = fl;
++>>>>>>> 2ab99ee12440 (fs: track fl_owner for leases)
  			continue;
  		}
 -
  		/*
  		 * No exclusive leases if someone else has a lease on
  		 * this file:
@@@ -1613,22 -1720,35 +1620,35 @@@ out
  	return error;
  }
  
- static int generic_delete_lease(struct file *filp)
+ static int generic_delete_lease(struct file *filp, void *owner)
  {
  	int error = -EAGAIN;
 -	struct file_lock *fl, *victim = NULL;
 +	struct file_lock *fl, **before;
  	struct dentry *dentry = filp->f_path.dentry;
  	struct inode *inode = dentry->d_inode;
 -	struct file_lock_context *ctx = inode->i_flctx;
 -	LIST_HEAD(dispose);
  
++<<<<<<< HEAD
 +	for (before = &inode->i_flock;
 +			((fl = *before) != NULL) && IS_LEASE(fl);
 +			before = &fl->fl_next) {
 +		if (fl->fl_file == filp)
++=======
+ 	if (!ctx) {
+ 		trace_generic_delete_lease(inode, NULL);
+ 		return error;
+ 	}
+ 
+ 	spin_lock(&ctx->flc_lock);
+ 	list_for_each_entry(fl, &ctx->flc_lease, fl_list) {
+ 		if (fl->fl_file == filp &&
+ 		    fl->fl_owner == owner) {
+ 			victim = fl;
++>>>>>>> 2ab99ee12440 (fs: track fl_owner for leases)
  			break;
 -		}
  	}
  	trace_generic_delete_lease(inode, fl);
 -	if (victim)
 -		error = fl->fl_lmops->lm_change(victim, F_UNLCK, &dispose);
 -	spin_unlock(&ctx->flc_lock);
 -	locks_dispose_list(&dispose);
 +	if (fl)
 +		error = fl->fl_lmops->lm_change(before, F_UNLCK);
  	return error;
  }
  
@@@ -1657,11 -1778,9 +1677,11 @@@ int generic_setlease(struct file *filp
  	if (error)
  		return error;
  
 +	time_out_leases(inode);
 +
  	switch (arg) {
  	case F_UNLCK:
- 		return generic_delete_lease(filp);
+ 		return generic_delete_lease(filp, *priv);
  	case F_RDLCK:
  	case F_WRLCK:
  		if (!(*flp)->fl_lmops->lm_break) {
@@@ -1781,7 -1859,7 +1801,11 @@@ out_free_fasync
  int fcntl_setlease(unsigned int fd, struct file *filp, long arg)
  {
  	if (arg == F_UNLCK)
++<<<<<<< HEAD
 +		return vfs_setlease(filp, F_UNLCK, NULL);
++=======
+ 		return vfs_setlease(filp, F_UNLCK, NULL, (void **)&filp);
++>>>>>>> 2ab99ee12440 (fs: track fl_owner for leases)
  	return do_fcntl_add_lease(fd, filp, arg);
  }
  
diff --cc fs/nfsd/nfs4state.c
index 3e7464bc7f87,e6b354a0d89e..000000000000
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@@ -689,7 -683,7 +689,11 @@@ static void nfs4_put_deleg_lease(struc
  	spin_unlock(&fp->fi_lock);
  
  	if (filp) {
++<<<<<<< HEAD
 +		vfs_setlease(filp, F_UNLCK, NULL);
++=======
+ 		vfs_setlease(filp, F_UNLCK, NULL, (void **)&fp);
++>>>>>>> 2ab99ee12440 (fs: track fl_owner for leases)
  		fput(filp);
  	}
  }
* Unmerged path fs/locks.c
* Unmerged path fs/nfsd/nfs4state.c
