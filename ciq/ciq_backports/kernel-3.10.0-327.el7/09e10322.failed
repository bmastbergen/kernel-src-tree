ovl: lookup ENAMETOOLONG on lower means ENOENT

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Miklos Szeredi <mszeredi@suse.cz>
commit 09e10322b71716adf567d453889ef0871cf226b9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/09e10322.failed

"Suppose you have in one of the lower layers a filesystem with
->lookup()-enforced upper limit on name length.  Pretty much every local fs
has one, but... they are not all equal.  255 characters is the common upper
limit, but e.g. jffs2 stops at 254, minixfs upper limit is somewhere from
14 to 60, depending upon version, etc.  You are doing a lookup for
something that is present in upper layer, but happens to be too long for
one of the lower layers.  Too bad - ENAMETOOLONG for you..."

	Reported-by: Al Viro <viro@ZenIV.linux.org.uk>
	Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
(cherry picked from commit 09e10322b71716adf567d453889ef0871cf226b9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/super.c
diff --cc fs/overlayfs/super.c
index e7867fa3c59f,110c968dcb3b..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -320,56 -333,101 +320,114 @@@ struct dentry *ovl_lookup(struct inode 
  			  unsigned int flags)
  {
  	struct ovl_entry *oe;
 -	struct ovl_entry *poe = dentry->d_parent->d_fsdata;
 -	struct path *stack = NULL;
 -	struct dentry *upperdir, *upperdentry = NULL;
 -	unsigned int ctr = 0;
 +	struct dentry *upperdir;
 +	struct dentry *lowerdir;
 +	struct dentry *upperdentry = NULL;
 +	struct dentry *lowerdentry = NULL;
  	struct inode *inode = NULL;
 -	bool upperopaque = false;
 -	struct dentry *this, *prev = NULL;
 -	unsigned int i;
  	int err;
  
 -	upperdir = ovl_upperdentry_dereference(poe);
 -	if (upperdir) {
 -		this = ovl_lookup_real(upperdir, &dentry->d_name);
 -		err = PTR_ERR(this);
 -		if (IS_ERR(this))
 -			goto out;
 +	err = -ENOMEM;
 +	oe = ovl_alloc_entry();
 +	if (!oe)
 +		goto out;
  
 -		if (this) {
 -			if (ovl_is_whiteout(this)) {
 -				dput(this);
 -				this = NULL;
 -				upperopaque = true;
 -			} else if (poe->numlower && ovl_is_opaquedir(this)) {
 -				upperopaque = true;
 +	upperdir = ovl_dentry_upper(dentry->d_parent);
 +	lowerdir = ovl_dentry_lower(dentry->d_parent);
 +
 +	if (upperdir) {
 +		upperdentry = ovl_lookup_real(upperdir, &dentry->d_name);
 +		err = PTR_ERR(upperdentry);
 +		if (IS_ERR(upperdentry))
 +			goto out_put_dir;
 +
 +		if (lowerdir && upperdentry) {
 +			if (ovl_is_whiteout(upperdentry)) {
 +				dput(upperdentry);
 +				upperdentry = NULL;
 +				oe->opaque = true;
 +			} else if (ovl_is_opaquedir(upperdentry)) {
 +				oe->opaque = true;
  			}
  		}
 -		upperdentry = prev = this;
 +	}
 +	if (lowerdir && !oe->opaque) {
 +		lowerdentry = ovl_lookup_real(lowerdir, &dentry->d_name);
 +		err = PTR_ERR(lowerdentry);
 +		if (IS_ERR(lowerdentry))
 +			goto out_dput_upper;
  	}
  
 -	if (!upperopaque && poe->numlower) {
 -		err = -ENOMEM;
 -		stack = kcalloc(poe->numlower, sizeof(struct path), GFP_KERNEL);
 -		if (!stack)
 -			goto out_put_upper;
 +	if (lowerdentry && upperdentry &&
 +	    (!S_ISDIR(upperdentry->d_inode->i_mode) ||
 +	     !S_ISDIR(lowerdentry->d_inode->i_mode))) {
 +		dput(lowerdentry);
 +		lowerdentry = NULL;
 +		oe->opaque = true;
  	}
  
++<<<<<<< HEAD
 +	if (lowerdentry || upperdentry) {
++=======
+ 	for (i = 0; !upperopaque && i < poe->numlower; i++) {
+ 		bool opaque = false;
+ 		struct path lowerpath = poe->lowerstack[i];
+ 
+ 		opaque = false;
+ 		this = ovl_lookup_real(lowerpath.dentry, &dentry->d_name);
+ 		err = PTR_ERR(this);
+ 		if (IS_ERR(this)) {
+ 			/*
+ 			 * If it's positive, then treat ENAMETOOLONG as ENOENT.
+ 			 */
+ 			if (err == -ENAMETOOLONG && (upperdentry || ctr))
+ 				continue;
+ 			goto out_put;
+ 		}
+ 		if (!this)
+ 			continue;
+ 		if (ovl_is_whiteout(this)) {
+ 			dput(this);
+ 			break;
+ 		}
+ 		/*
+ 		 * Only makes sense to check opaque dir if this is not the
+ 		 * lowermost layer.
+ 		 */
+ 		if (i < poe->numlower - 1 && ovl_is_opaquedir(this))
+ 			opaque = true;
+ 		/*
+ 		 * If this is a non-directory then stop here.
+ 		 *
+ 		 * FIXME: check for opaqueness maybe better done in remove code.
+ 		 */
+ 		if (!S_ISDIR(this->d_inode->i_mode)) {
+ 			opaque = true;
+ 		} else if (prev && (!S_ISDIR(prev->d_inode->i_mode) ||
+ 				    !S_ISDIR(this->d_inode->i_mode))) {
+ 			if (prev == upperdentry)
+ 				upperopaque = true;
+ 			dput(this);
+ 			break;
+ 		}
+ 		stack[ctr].dentry = this;
+ 		stack[ctr].mnt = lowerpath.mnt;
+ 		ctr++;
+ 		prev = this;
+ 		if (opaque)
+ 			break;
+ 	}
+ 
+ 	oe = ovl_alloc_entry(ctr);
+ 	err = -ENOMEM;
+ 	if (!oe)
+ 		goto out_put;
+ 
+ 	if (upperdentry || ctr) {
++>>>>>>> 09e10322b717 (ovl: lookup ENAMETOOLONG on lower means ENOENT)
  		struct dentry *realdentry;
  
 -		realdentry = upperdentry ? upperdentry : stack[0].dentry;
 -
 +		realdentry = upperdentry ? upperdentry : lowerdentry;
  		err = -ENOMEM;
  		inode = ovl_new_inode(dentry->d_sb, realdentry->d_inode->i_mode,
  				      oe);
* Unmerged path fs/overlayfs/super.c
