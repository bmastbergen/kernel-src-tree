crypto: nx - prevent nx 842 load if no hw driver

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [crypto] nx - prevent nx 842 load if no hw driver (Gustavo Duarte) [1221925]
Rebuild_FUZZ: 90.91%
commit-author Dan Streetman <ddstreet@ieee.org>
commit 3e648cbeb31be5cb84b9ec19822e2b85417f07c4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/3e648cbe.failed

Change the nx-842 common driver to wait for loading of both platform
drivers, and fail loading if the platform driver pointer is not set.
Add an independent platform driver pointer, that the platform drivers
set if they find they are able to load (i.e. if they find their platform
devicetree node(s)).

The problem is currently, the main nx-842 driver will stay loaded even
if there is no platform driver and thus no possible way it can do any
compression or decompression.  This allows the crypto 842-nx driver
to load even if it won't actually work.  For crypto compression users
(e.g. zswap) that expect an available crypto compression driver to
actually work, this is bad.  This patch fixes that, so the 842-nx crypto
compression driver won't load if it doesn't have the driver and hardware
available to perform the compression.

	Signed-off-by: Dan Streetman <ddstreet@ieee.org>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit 3e648cbeb31be5cb84b9ec19822e2b85417f07c4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/nx/Makefile
#	drivers/crypto/nx/nx-842-powernv.c
#	drivers/crypto/nx/nx-842-pseries.c
#	drivers/crypto/nx/nx-842.c
#	drivers/crypto/nx/nx-842.h
diff --cc drivers/crypto/nx/Makefile
index 8669ffa8dc5c,e1684f5adb11..000000000000
--- a/drivers/crypto/nx/Makefile
+++ b/drivers/crypto/nx/Makefile
@@@ -10,5 -10,12 +10,17 @@@ nx-crypto-objs := nx.o 
  		  nx-sha256.o \
  		  nx-sha512.o
  
++<<<<<<< HEAD
 +obj-$(CONFIG_CRYPTO_DEV_NX_COMPRESS) += nx-compress.o
 +nx-compress-objs := nx-842-pseries.o
++=======
+ obj-$(CONFIG_CRYPTO_DEV_NX_COMPRESS) += nx-compress.o nx-compress-platform.o
+ obj-$(CONFIG_CRYPTO_DEV_NX_COMPRESS_PSERIES) += nx-compress-pseries.o
+ obj-$(CONFIG_CRYPTO_DEV_NX_COMPRESS_POWERNV) += nx-compress-powernv.o
+ obj-$(CONFIG_CRYPTO_DEV_NX_COMPRESS_CRYPTO) += nx-compress-crypto.o
+ nx-compress-objs := nx-842.o
+ nx-compress-platform-objs := nx-842-platform.o
+ nx-compress-pseries-objs := nx-842-pseries.o
+ nx-compress-powernv-objs := nx-842-powernv.o
+ nx-compress-crypto-objs := nx-842-crypto.o
++>>>>>>> 3e648cbeb31b (crypto: nx - prevent nx 842 load if no hw driver)
diff --cc drivers/crypto/nx/nx-842-pseries.c
index 502edf0a2933,17f191777139..000000000000
--- a/drivers/crypto/nx/nx-842-pseries.c
+++ b/drivers/crypto/nx/nx-842-pseries.c
@@@ -21,18 -21,11 +21,21 @@@
   *          Seth Jennings <sjenning@linux.vnet.ibm.com>
   */
  
 +#include <linux/kernel.h>
 +#include <linux/module.h>
 +#include <linux/nx842.h>
 +#include <linux/of.h>
 +#include <linux/slab.h>
 +
 +#include <asm/page.h>
  #include <asm/vio.h>
  
 -#include "nx-842.h"
  #include "nx_csbcpb.h" /* struct nx_csbcpb */
  
++<<<<<<< HEAD
 +#define MODULE_NAME "nx-compress"
++=======
++>>>>>>> 3e648cbeb31b (crypto: nx - prevent nx 842 load if no hw driver)
  MODULE_LICENSE("GPL");
  MODULE_AUTHOR("Robert Jennings <rcj@linux.vnet.ibm.com>");
  MODULE_DESCRIPTION("842 H/W Compression driver for IBM Power processors");
@@@ -1144,6 -963,14 +1147,17 @@@ static struct attribute_group nx842_att
  	.attrs = nx842_sysfs_entries,
  };
  
++<<<<<<< HEAD
++=======
+ static struct nx842_driver nx842_pseries_driver = {
+ 	.name =		KBUILD_MODNAME,
+ 	.owner =	THIS_MODULE,
+ 	.constraints =	&nx842_pseries_constraints,
+ 	.compress =	nx842_pseries_compress,
+ 	.decompress =	nx842_pseries_decompress,
+ };
+ 
++>>>>>>> 3e648cbeb31b (crypto: nx - prevent nx 842 load if no hw driver)
  static int __init nx842_probe(struct vio_dev *viodev,
  				  const struct vio_device_id *id)
  {
@@@ -1236,27 -1063,35 +1250,50 @@@ static int __exit nx842_remove(struct v
  	if (old_devdata)
  		kfree(old_devdata->counters);
  	kfree(old_devdata);
++<<<<<<< HEAD
 +	return 0;
 +}
 +
 +static struct vio_device_id nx842_driver_ids[] = {
++=======
+ 
+ 	return 0;
+ }
+ 
+ static struct vio_device_id nx842_vio_driver_ids[] = {
++>>>>>>> 3e648cbeb31b (crypto: nx - prevent nx 842 load if no hw driver)
  	{"ibm,compression-v1", "ibm,compression"},
  	{"", ""},
  };
  
++<<<<<<< HEAD
 +static struct vio_driver nx842_driver = {
 +	.name = MODULE_NAME,
++=======
+ static struct vio_driver nx842_vio_driver = {
+ 	.name = KBUILD_MODNAME,
++>>>>>>> 3e648cbeb31b (crypto: nx - prevent nx 842 load if no hw driver)
  	.probe = nx842_probe,
 -	.remove = __exit_p(nx842_remove),
 +	.remove = nx842_remove,
  	.get_desired_dma = nx842_get_desired_dma,
 -	.id_table = nx842_vio_driver_ids,
 +	.id_table = nx842_driver_ids,
  };
  
  static int __init nx842_init(void)
  {
  	struct nx842_devdata *new_devdata;
+ 	int ret;
+ 
  	pr_info("Registering IBM Power 842 compression driver\n");
  
++<<<<<<< HEAD
++=======
+ 	BUILD_BUG_ON(sizeof(struct nx842_workmem) > NX842_MEM_COMPRESS);
+ 
+ 	if (!of_find_compatible_node(NULL, NULL, "ibm,compression"))
+ 		return -ENODEV;
+ 
++>>>>>>> 3e648cbeb31b (crypto: nx - prevent nx 842 load if no hw driver)
  	RCU_INIT_POINTER(devdata, NULL);
  	new_devdata = kzalloc(sizeof(*new_devdata), GFP_KERNEL);
  	if (!new_devdata) {
@@@ -1266,7 -1101,21 +1303,25 @@@
  	new_devdata->status = UNAVAILABLE;
  	RCU_INIT_POINTER(devdata, new_devdata);
  
++<<<<<<< HEAD
 +	return vio_register_driver(&nx842_driver);
++=======
+ 	ret = vio_register_driver(&nx842_vio_driver);
+ 	if (ret) {
+ 		pr_err("Could not register VIO driver %d\n", ret);
+ 
+ 		kfree(new_devdata);
+ 		return ret;
+ 	}
+ 
+ 	if (!nx842_platform_driver_set(&nx842_pseries_driver)) {
+ 		vio_unregister_driver(&nx842_vio_driver);
+ 		kfree(new_devdata);
+ 		return -EEXIST;
+ 	}
+ 
+ 	return 0;
++>>>>>>> 3e648cbeb31b (crypto: nx - prevent nx 842 load if no hw driver)
  }
  
  module_init(nx842_init);
@@@ -1283,10 -1133,10 +1339,14 @@@ static void __exit nx842_exit(void
  	RCU_INIT_POINTER(devdata, NULL);
  	spin_unlock_irqrestore(&devdata_mutex, flags);
  	synchronize_rcu();
 -	if (old_devdata && old_devdata->dev)
 +	if (old_devdata)
  		dev_set_drvdata(old_devdata->dev, NULL);
  	kfree(old_devdata);
++<<<<<<< HEAD
 +	vio_unregister_driver(&nx842_driver);
++=======
+ 	vio_unregister_driver(&nx842_vio_driver);
++>>>>>>> 3e648cbeb31b (crypto: nx - prevent nx 842 load if no hw driver)
  }
  
  module_exit(nx842_exit);
* Unmerged path drivers/crypto/nx/nx-842-powernv.c
* Unmerged path drivers/crypto/nx/nx-842.c
* Unmerged path drivers/crypto/nx/nx-842.h
* Unmerged path drivers/crypto/nx/Makefile
diff --git a/drivers/crypto/nx/nx-842-platform.c b/drivers/crypto/nx/nx-842-platform.c
new file mode 100644
index 000000000000..664f13dd06ed
--- /dev/null
+++ b/drivers/crypto/nx/nx-842-platform.c
@@ -0,0 +1,84 @@
+
+#include "nx-842.h"
+
+/* this is needed, separate from the main nx-842.c driver, because that main
+ * driver loads the platform drivers during its init(), and it expects one
+ * (or none) of the platform drivers to set this pointer to its driver.
+ * That means this pointer can't be in the main nx-842 driver, because it
+ * wouldn't be accessible until after the main driver loaded, which wouldn't
+ * be possible as it's waiting for the platform driver to load.  So place it
+ * here.
+ */
+static struct nx842_driver *driver;
+static DEFINE_SPINLOCK(driver_lock);
+
+struct nx842_driver *nx842_platform_driver(void)
+{
+	return driver;
+}
+EXPORT_SYMBOL_GPL(nx842_platform_driver);
+
+bool nx842_platform_driver_set(struct nx842_driver *_driver)
+{
+	bool ret = false;
+
+	spin_lock(&driver_lock);
+
+	if (!driver) {
+		driver = _driver;
+		ret = true;
+	} else
+		WARN(1, "can't set platform driver, already set to %s\n",
+		     driver->name);
+
+	spin_unlock(&driver_lock);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(nx842_platform_driver_set);
+
+/* only call this from the platform driver exit function */
+void nx842_platform_driver_unset(struct nx842_driver *_driver)
+{
+	spin_lock(&driver_lock);
+
+	if (driver == _driver)
+		driver = NULL;
+	else if (driver)
+		WARN(1, "can't unset platform driver %s, currently set to %s\n",
+		     _driver->name, driver->name);
+	else
+		WARN(1, "can't unset platform driver, already unset\n");
+
+	spin_unlock(&driver_lock);
+}
+EXPORT_SYMBOL_GPL(nx842_platform_driver_unset);
+
+bool nx842_platform_driver_get(void)
+{
+	bool ret = false;
+
+	spin_lock(&driver_lock);
+
+	if (driver)
+		ret = try_module_get(driver->owner);
+
+	spin_unlock(&driver_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(nx842_platform_driver_get);
+
+void nx842_platform_driver_put(void)
+{
+	spin_lock(&driver_lock);
+
+	if (driver)
+		module_put(driver->owner);
+
+	spin_unlock(&driver_lock);
+}
+EXPORT_SYMBOL_GPL(nx842_platform_driver_put);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Dan Streetman <ddstreet@ieee.org>");
+MODULE_DESCRIPTION("842 H/W Compression platform driver");
* Unmerged path drivers/crypto/nx/nx-842-powernv.c
* Unmerged path drivers/crypto/nx/nx-842-pseries.c
* Unmerged path drivers/crypto/nx/nx-842.c
* Unmerged path drivers/crypto/nx/nx-842.h
