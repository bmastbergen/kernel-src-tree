openvswitch: Support VXLAN Group Policy extension

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Thomas Graf <tgraf@suug.ch>
commit 1dd144cf5b4b47e12438c2c6883925ce1a9b499f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/1dd144cf.failed

Introduces support for the group policy extension to the VXLAN virtual
port. The extension is disabled by default and only enabled if the user
has provided the respective configuration.

  ovs-vsctl add-port br0 vxlan0 -- \
     set Interface vxlan0 type=vxlan options:exts=gbp

The configuration interface to enable the extension is based on a new
attribute OVS_VXLAN_EXT_GBP nested inside OVS_TUNNEL_ATTR_EXTENSION
which can carry additional extensions as needed in the future.

The group policy metadata is stored as binary blob (struct ovs_vxlan_opts)
internally just like Geneve options but transported as nested Netlink
attributes to user space.

Renames the existing TUNNEL_OPTIONS_PRESENT to TUNNEL_GENEVE_OPT with the
binary value kept intact, a new flag TUNNEL_VXLAN_OPT is introduced.

The attributes OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS and existing
OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS are implemented mutually exclusive.

	Signed-off-by: Thomas Graf <tgraf@suug.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1dd144cf5b4b47e12438c2c6883925ce1a9b499f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/openvswitch/flow_netlink.c
#	net/openvswitch/vport-vxlan.c
diff --cc net/openvswitch/flow_netlink.c
index d35e6f9713da,d210d1be3470..000000000000
--- a/net/openvswitch/flow_netlink.c
+++ b/net/openvswitch/flow_netlink.c
@@@ -46,9 -46,18 +46,10 @@@
  #include <net/ip.h>
  #include <net/ipv6.h>
  #include <net/ndisc.h>
 -#include <net/mpls.h>
  
  #include "flow_netlink.h"
+ #include "vport-vxlan.h"
  
 -struct ovs_len_tbl {
 -	int len;
 -	const struct ovs_len_tbl *next;
 -};
 -
 -#define OVS_ATTR_NESTED -1
 -
  static void update_range(struct sw_flow_match *match,
  			 size_t offset, size_t size, bool is_mask)
  {
@@@ -279,28 -300,45 +283,46 @@@ size_t ovs_key_attr_size(void
  		+ nla_total_size(28); /* OVS_KEY_ATTR_ND */
  }
  
++<<<<<<< HEAD
++=======
+ static const struct ovs_len_tbl ovs_tunnel_key_lens[OVS_TUNNEL_KEY_ATTR_MAX + 1] = {
+ 	[OVS_TUNNEL_KEY_ATTR_ID]	    = { .len = sizeof(u64) },
+ 	[OVS_TUNNEL_KEY_ATTR_IPV4_SRC]	    = { .len = sizeof(u32) },
+ 	[OVS_TUNNEL_KEY_ATTR_IPV4_DST]	    = { .len = sizeof(u32) },
+ 	[OVS_TUNNEL_KEY_ATTR_TOS]	    = { .len = 1 },
+ 	[OVS_TUNNEL_KEY_ATTR_TTL]	    = { .len = 1 },
+ 	[OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT] = { .len = 0 },
+ 	[OVS_TUNNEL_KEY_ATTR_CSUM]	    = { .len = 0 },
+ 	[OVS_TUNNEL_KEY_ATTR_TP_SRC]	    = { .len = sizeof(u16) },
+ 	[OVS_TUNNEL_KEY_ATTR_TP_DST]	    = { .len = sizeof(u16) },
+ 	[OVS_TUNNEL_KEY_ATTR_OAM]	    = { .len = 0 },
+ 	[OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS]   = { .len = OVS_ATTR_NESTED },
+ 	[OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS]    = { .len = OVS_ATTR_NESTED },
+ };
+ 
++>>>>>>> 1dd144cf5b4b (openvswitch: Support VXLAN Group Policy extension)
  /* The size of the argument for each %OVS_KEY_ATTR_* Netlink attribute.  */
 -static const struct ovs_len_tbl ovs_key_lens[OVS_KEY_ATTR_MAX + 1] = {
 -	[OVS_KEY_ATTR_ENCAP]	 = { .len = OVS_ATTR_NESTED },
 -	[OVS_KEY_ATTR_PRIORITY]	 = { .len = sizeof(u32) },
 -	[OVS_KEY_ATTR_IN_PORT]	 = { .len = sizeof(u32) },
 -	[OVS_KEY_ATTR_SKB_MARK]	 = { .len = sizeof(u32) },
 -	[OVS_KEY_ATTR_ETHERNET]	 = { .len = sizeof(struct ovs_key_ethernet) },
 -	[OVS_KEY_ATTR_VLAN]	 = { .len = sizeof(__be16) },
 -	[OVS_KEY_ATTR_ETHERTYPE] = { .len = sizeof(__be16) },
 -	[OVS_KEY_ATTR_IPV4]	 = { .len = sizeof(struct ovs_key_ipv4) },
 -	[OVS_KEY_ATTR_IPV6]	 = { .len = sizeof(struct ovs_key_ipv6) },
 -	[OVS_KEY_ATTR_TCP]	 = { .len = sizeof(struct ovs_key_tcp) },
 -	[OVS_KEY_ATTR_TCP_FLAGS] = { .len = sizeof(__be16) },
 -	[OVS_KEY_ATTR_UDP]	 = { .len = sizeof(struct ovs_key_udp) },
 -	[OVS_KEY_ATTR_SCTP]	 = { .len = sizeof(struct ovs_key_sctp) },
 -	[OVS_KEY_ATTR_ICMP]	 = { .len = sizeof(struct ovs_key_icmp) },
 -	[OVS_KEY_ATTR_ICMPV6]	 = { .len = sizeof(struct ovs_key_icmpv6) },
 -	[OVS_KEY_ATTR_ARP]	 = { .len = sizeof(struct ovs_key_arp) },
 -	[OVS_KEY_ATTR_ND]	 = { .len = sizeof(struct ovs_key_nd) },
 -	[OVS_KEY_ATTR_RECIRC_ID] = { .len = sizeof(u32) },
 -	[OVS_KEY_ATTR_DP_HASH]	 = { .len = sizeof(u32) },
 -	[OVS_KEY_ATTR_TUNNEL]	 = { .len = OVS_ATTR_NESTED,
 -				     .next = ovs_tunnel_key_lens, },
 -	[OVS_KEY_ATTR_MPLS]	 = { .len = sizeof(struct ovs_key_mpls) },
 +static const int ovs_key_lens[OVS_KEY_ATTR_MAX + 1] = {
 +	[OVS_KEY_ATTR_ENCAP] = -1,
 +	[OVS_KEY_ATTR_PRIORITY] = sizeof(u32),
 +	[OVS_KEY_ATTR_IN_PORT] = sizeof(u32),
 +	[OVS_KEY_ATTR_SKB_MARK] = sizeof(u32),
 +	[OVS_KEY_ATTR_ETHERNET] = sizeof(struct ovs_key_ethernet),
 +	[OVS_KEY_ATTR_VLAN] = sizeof(__be16),
 +	[OVS_KEY_ATTR_ETHERTYPE] = sizeof(__be16),
 +	[OVS_KEY_ATTR_IPV4] = sizeof(struct ovs_key_ipv4),
 +	[OVS_KEY_ATTR_IPV6] = sizeof(struct ovs_key_ipv6),
 +	[OVS_KEY_ATTR_TCP] = sizeof(struct ovs_key_tcp),
 +	[OVS_KEY_ATTR_TCP_FLAGS] = sizeof(__be16),
 +	[OVS_KEY_ATTR_UDP] = sizeof(struct ovs_key_udp),
 +	[OVS_KEY_ATTR_SCTP] = sizeof(struct ovs_key_sctp),
 +	[OVS_KEY_ATTR_ICMP] = sizeof(struct ovs_key_icmp),
 +	[OVS_KEY_ATTR_ICMPV6] = sizeof(struct ovs_key_icmpv6),
 +	[OVS_KEY_ATTR_ARP] = sizeof(struct ovs_key_arp),
 +	[OVS_KEY_ATTR_ND] = sizeof(struct ovs_key_nd),
 +	[OVS_KEY_ATTR_RECIRC_ID] = sizeof(u32),
 +	[OVS_KEY_ATTR_DP_HASH] = sizeof(u32),
 +	[OVS_KEY_ATTR_TUNNEL] = -1,
  };
  
  static bool is_all_zero(const u8 *fp, size_t size)
@@@ -370,19 -408,107 +392,58 @@@ static int parse_flow_mask_nlattrs(cons
  }
  
  static int parse_flow_nlattrs(const struct nlattr *attr,
 -			      const struct nlattr *a[], u64 *attrsp,
 -			      bool log)
 -{
 -	return __parse_flow_nlattrs(attr, a, attrsp, log, false);
 -}
 -
 -static int genev_tun_opt_from_nlattr(const struct nlattr *a,
 -				     struct sw_flow_match *match, bool is_mask,
 -				     bool log)
 +			      const struct nlattr *a[], u64 *attrsp)
  {
 -	unsigned long opt_key_offset;
 -
 -	if (nla_len(a) > sizeof(match->key->tun_opts)) {
 -		OVS_NLERR(log, "Geneve option length err (len %d, max %zu).",
 -			  nla_len(a), sizeof(match->key->tun_opts));
 -		return -EINVAL;
 -	}
 -
 -	if (nla_len(a) % 4 != 0) {
 -		OVS_NLERR(log, "Geneve opt len %d is not a multiple of 4.",
 -			  nla_len(a));
 -		return -EINVAL;
 -	}
 -
 -	/* We need to record the length of the options passed
 -	 * down, otherwise packets with the same format but
 -	 * additional options will be silently matched.
 -	 */
 -	if (!is_mask) {
 -		SW_FLOW_KEY_PUT(match, tun_opts_len, nla_len(a),
 -				false);
 -	} else {
 -		/* This is somewhat unusual because it looks at
 -		 * both the key and mask while parsing the
 -		 * attributes (and by extension assumes the key
 -		 * is parsed first). Normally, we would verify
 -		 * that each is the correct length and that the
 -		 * attributes line up in the validate function.
 -		 * However, that is difficult because this is
 -		 * variable length and we won't have the
 -		 * information later.
 -		 */
 -		if (match->key->tun_opts_len != nla_len(a)) {
 -			OVS_NLERR(log, "Geneve option len %d != mask len %d",
 -				  match->key->tun_opts_len, nla_len(a));
 -			return -EINVAL;
 -		}
 -
 -		SW_FLOW_KEY_PUT(match, tun_opts_len, 0xff, true);
 -	}
 -
 -	opt_key_offset = TUN_METADATA_OFFSET(nla_len(a));
 -	SW_FLOW_KEY_MEMCPY_OFFSET(match, opt_key_offset, nla_data(a),
 -				  nla_len(a), is_mask);
 -	return 0;
 +	return __parse_flow_nlattrs(attr, a, attrsp, false);
  }
  
+ static const struct nla_policy vxlan_opt_policy[OVS_VXLAN_EXT_MAX + 1] = {
+ 	[OVS_VXLAN_EXT_GBP]	= { .type = NLA_U32 },
+ };
+ 
+ static int vxlan_tun_opt_from_nlattr(const struct nlattr *a,
+ 				     struct sw_flow_match *match, bool is_mask,
+ 				     bool log)
+ {
+ 	struct nlattr *tb[OVS_VXLAN_EXT_MAX+1];
+ 	unsigned long opt_key_offset;
+ 	struct ovs_vxlan_opts opts;
+ 	int err;
+ 
+ 	BUILD_BUG_ON(sizeof(opts) > sizeof(match->key->tun_opts));
+ 
+ 	err = nla_parse_nested(tb, OVS_VXLAN_EXT_MAX, a, vxlan_opt_policy);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	memset(&opts, 0, sizeof(opts));
+ 
+ 	if (tb[OVS_VXLAN_EXT_GBP])
+ 		opts.gbp = nla_get_u32(tb[OVS_VXLAN_EXT_GBP]);
+ 
+ 	if (!is_mask)
+ 		SW_FLOW_KEY_PUT(match, tun_opts_len, sizeof(opts), false);
+ 	else
+ 		SW_FLOW_KEY_PUT(match, tun_opts_len, 0xff, true);
+ 
+ 	opt_key_offset = TUN_METADATA_OFFSET(sizeof(opts));
+ 	SW_FLOW_KEY_MEMCPY_OFFSET(match, opt_key_offset, &opts, sizeof(opts),
+ 				  is_mask);
+ 	return 0;
+ }
+ 
  static int ipv4_tun_from_nlattr(const struct nlattr *attr,
 -				struct sw_flow_match *match, bool is_mask,
 -				bool log)
 +				struct sw_flow_match *match, bool is_mask)
  {
  	struct nlattr *a;
  	int rem;
  	bool ttl = false;
  	__be16 tun_flags = 0;
++<<<<<<< HEAD
 +	unsigned long opt_key_offset;
++=======
+ 	int opts_type = 0;
++>>>>>>> 1dd144cf5b4b (openvswitch: Support VXLAN Group Policy extension)
  
  	nla_for_each_nested(a, attr, rem) {
  		int type = nla_type(a);
@@@ -455,58 -568,33 +516,85 @@@
  			tun_flags |= TUNNEL_OAM;
  			break;
  		case OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS:
++<<<<<<< HEAD
 +			tun_flags |= TUNNEL_OPTIONS_PRESENT;
 +			if (nla_len(a) > sizeof(match->key->tun_opts)) {
 +				OVS_NLERR("Geneve option length exceeds maximum size (len %d, max %zu).\n",
 +					  nla_len(a),
 +					  sizeof(match->key->tun_opts));
 +				return -EINVAL;
 +			}
 +
 +			if (nla_len(a) % 4 != 0) {
 +				OVS_NLERR("Geneve option length is not a multiple of 4 (len %d).\n",
 +					  nla_len(a));
 +				return -EINVAL;
 +			}
 +
 +			/* We need to record the length of the options passed
 +			 * down, otherwise packets with the same format but
 +			 * additional options will be silently matched.
 +			 */
 +			if (!is_mask) {
 +				SW_FLOW_KEY_PUT(match, tun_opts_len, nla_len(a),
 +						false);
 +			} else {
 +				/* This is somewhat unusual because it looks at
 +				 * both the key and mask while parsing the
 +				 * attributes (and by extension assumes the key
 +				 * is parsed first). Normally, we would verify
 +				 * that each is the correct length and that the
 +				 * attributes line up in the validate function.
 +				 * However, that is difficult because this is
 +				 * variable length and we won't have the
 +				 * information later.
 +				 */
 +				if (match->key->tun_opts_len != nla_len(a)) {
 +					OVS_NLERR("Geneve option key length (%d) is different from mask length (%d).",
 +						  match->key->tun_opts_len,
 +						  nla_len(a));
 +					return -EINVAL;
 +				}
 +
 +				SW_FLOW_KEY_PUT(match, tun_opts_len, 0xff,
 +						true);
 +			}
 +
 +			opt_key_offset = (unsigned long)GENEVE_OPTS(
 +					  (struct sw_flow_key *)0,
 +					  nla_len(a));
 +			SW_FLOW_KEY_MEMCPY_OFFSET(match, opt_key_offset,
 +						  nla_data(a), nla_len(a),
 +						  is_mask);
++=======
+ 			if (opts_type) {
+ 				OVS_NLERR(log, "Multiple metadata blocks provided");
+ 				return -EINVAL;
+ 			}
+ 
+ 			err = genev_tun_opt_from_nlattr(a, match, is_mask, log);
+ 			if (err)
+ 				return err;
+ 
+ 			tun_flags |= TUNNEL_GENEVE_OPT;
+ 			opts_type = type;
+ 			break;
+ 		case OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS:
+ 			if (opts_type) {
+ 				OVS_NLERR(log, "Multiple metadata blocks provided");
+ 				return -EINVAL;
+ 			}
+ 
+ 			err = vxlan_tun_opt_from_nlattr(a, match, is_mask, log);
+ 			if (err)
+ 				return err;
+ 
+ 			tun_flags |= TUNNEL_VXLAN_OPT;
+ 			opts_type = type;
++>>>>>>> 1dd144cf5b4b (openvswitch: Support VXLAN Group Policy extension)
  			break;
  		default:
 -			OVS_NLERR(log, "Unknown IPv4 tunnel attribute %d",
 +			OVS_NLERR("Unknown IPv4 tunnel attribute (%d).\n",
  				  type);
  			return -EINVAL;
  		}
@@@ -652,7 -762,7 +762,11 @@@ static int metadata_from_nlattrs(struc
  	}
  	if (*attrs & (1 << OVS_KEY_ATTR_TUNNEL)) {
  		if (ipv4_tun_from_nlattr(a[OVS_KEY_ATTR_TUNNEL], match,
++<<<<<<< HEAD
 +					 is_mask))
++=======
+ 					 is_mask, log) < 0)
++>>>>>>> 1dd144cf5b4b (openvswitch: Support VXLAN Group Policy extension)
  			return -EINVAL;
  		*attrs &= ~(1 << OVS_KEY_ATTR_TUNNEL);
  	}
@@@ -1490,39 -1660,26 +1604,56 @@@ static int validate_and_copy_set_tun(co
  	struct sw_flow_key key;
  	struct ovs_tunnel_info *tun_info;
  	struct nlattr *a;
- 	int err, start;
+ 	int err, start, opts_type;
  
  	ovs_match_init(&match, &key, NULL);
++<<<<<<< HEAD
 +	err = ipv4_tun_from_nlattr(nla_data(attr), &match, false);
 +	if (err)
 +		return err;
 +
 +	if (key.tun_opts_len) {
 +		struct geneve_opt *option = GENEVE_OPTS(&key,
 +							key.tun_opts_len);
 +		int opts_len = key.tun_opts_len;
 +		bool crit_opt = false;
 +
 +		while (opts_len > 0) {
 +			int len;
 +
 +			if (opts_len < sizeof(*option))
 +				return -EINVAL;
 +
 +			len = sizeof(*option) + option->length * 4;
 +			if (len > opts_len)
 +				return -EINVAL;
 +
 +			crit_opt |= !!(option->type & GENEVE_CRIT_OPT_TYPE);
 +
 +			option = (struct geneve_opt *)((u8 *)option + len);
 +			opts_len -= len;
 +		};
 +
 +		key.tun_key.tun_flags |= crit_opt ? TUNNEL_CRIT_OPT : 0;
++=======
+ 	opts_type = ipv4_tun_from_nlattr(nla_data(attr), &match, false, log);
+ 	if (opts_type < 0)
+ 		return opts_type;
+ 
+ 	if (key.tun_opts_len) {
+ 		switch (opts_type) {
+ 		case OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS:
+ 			err = validate_geneve_opts(&key);
+ 			if (err < 0)
+ 				return err;
+ 			break;
+ 		case OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS:
+ 			break;
+ 		}
++>>>>>>> 1dd144cf5b4b (openvswitch: Support VXLAN Group Policy extension)
  	};
  
 -	start = add_nested_action_start(sfa, OVS_ACTION_ATTR_SET, log);
 +	start = add_nested_action_start(sfa, OVS_ACTION_ATTR_SET);
  	if (start < 0)
  		return start;
  
diff --cc net/openvswitch/vport-vxlan.c
index 4ee1a688c5a7,8a2d54cba9ba..000000000000
--- a/net/openvswitch/vport-vxlan.c
+++ b/net/openvswitch/vport-vxlan.c
@@@ -59,19 -61,30 +61,29 @@@ static inline struct vxlan_port *vxlan_
  }
  
  /* Called with rcu_read_lock and BH disabled. */
 -static void vxlan_rcv(struct vxlan_sock *vs, struct sk_buff *skb,
 -		      struct vxlan_metadata *md)
 +static void vxlan_rcv(struct vxlan_sock *vs, struct sk_buff *skb, __be32 vx_vni)
  {
  	struct ovs_tunnel_info tun_info;
+ 	struct vxlan_port *vxlan_port;
  	struct vport *vport = vs->data;
  	struct iphdr *iph;
+ 	struct ovs_vxlan_opts opts = {
+ 		.gbp = md->gbp,
+ 	};
  	__be64 key;
+ 	__be16 flags;
+ 
+ 	flags = TUNNEL_KEY;
+ 	vxlan_port = vxlan_vport(vport);
+ 	if (vxlan_port->exts & VXLAN_F_GBP)
+ 		flags |= TUNNEL_VXLAN_OPT;
  
  	/* Save outer tunnel values */
  	iph = ip_hdr(skb);
 -	key = cpu_to_be64(ntohl(md->vni) >> 8);
 +	key = cpu_to_be64(ntohl(vx_vni) >> 8);
  	ovs_flow_tun_info_init(&tun_info, iph,
  			       udp_hdr(skb)->source, udp_hdr(skb)->dest,
- 			       key, TUNNEL_KEY, NULL, 0);
+ 			       key, flags, &opts, sizeof(opts));
  
  	ovs_vport_receive(vport, skb, &tun_info);
  }
@@@ -167,11 -246,13 +244,16 @@@ static int vxlan_tnl_send(struct vport 
  	df = tun_key->tun_flags & TUNNEL_DONT_FRAGMENT ?
  		htons(IP_DF) : 0;
  
 -	skb->ignore_df = 1;
 +	skb->local_df = 1;
  
  	src_port = udp_flow_src_port(net, skb, 0, 0, true);
++<<<<<<< HEAD
++=======
+ 	md.vni = htonl(be64_to_cpu(tun_key->tun_id) << 8);
+ 	md.gbp = vxlan_ext_gbp(skb);
++>>>>>>> 1dd144cf5b4b (openvswitch: Support VXLAN Group Policy extension)
  
 -	err = vxlan_xmit_skb(vxlan_port->vs, rt, skb,
 +	err = vxlan_xmit_skb(net, vxlan_port->vs, rt, skb,
  			     fl.saddr, tun_key->ipv4_dst,
  			     tun_key->ipv4_tos, tun_key->ipv4_ttl, df,
  			     src_port, dst_port,
diff --git a/include/net/ip_tunnels.h b/include/net/ip_tunnels.h
index 7b29cafcd58e..33c58c9fe2fb 100644
--- a/include/net/ip_tunnels.h
+++ b/include/net/ip_tunnels.h
@@ -89,7 +89,10 @@ struct ip_tunnel {
 #define TUNNEL_DONT_FRAGMENT    __cpu_to_be16(0x0100)
 #define TUNNEL_OAM		__cpu_to_be16(0x0200)
 #define TUNNEL_CRIT_OPT		__cpu_to_be16(0x0400)
-#define TUNNEL_OPTIONS_PRESENT	__cpu_to_be16(0x0800)
+#define TUNNEL_GENEVE_OPT	__cpu_to_be16(0x0800)
+#define TUNNEL_VXLAN_OPT	__cpu_to_be16(0x1000)
+
+#define TUNNEL_OPTIONS_PRESENT	(TUNNEL_GENEVE_OPT | TUNNEL_VXLAN_OPT)
 
 struct tnl_ptk_info {
 	__be16 flags;
diff --git a/include/uapi/linux/openvswitch.h b/include/uapi/linux/openvswitch.h
index 0d7501a221c7..8af54e22731d 100644
--- a/include/uapi/linux/openvswitch.h
+++ b/include/uapi/linux/openvswitch.h
@@ -248,11 +248,21 @@ enum ovs_vport_attr {
 
 #define OVS_VPORT_ATTR_MAX (__OVS_VPORT_ATTR_MAX - 1)
 
+enum {
+	OVS_VXLAN_EXT_UNSPEC,
+	OVS_VXLAN_EXT_GBP,	/* Flag or __u32 */
+	__OVS_VXLAN_EXT_MAX,
+};
+
+#define OVS_VXLAN_EXT_MAX (__OVS_VXLAN_EXT_MAX - 1)
+
+
 /* OVS_VPORT_ATTR_OPTIONS attributes for tunnels.
  */
 enum {
 	OVS_TUNNEL_ATTR_UNSPEC,
 	OVS_TUNNEL_ATTR_DST_PORT, /* 16-bit UDP port, used by L4 tunnels. */
+	OVS_TUNNEL_ATTR_EXTENSION,
 	__OVS_TUNNEL_ATTR_MAX
 };
 
@@ -321,6 +331,7 @@ enum ovs_tunnel_key_attr {
 	OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS,        /* Array of Geneve options. */
 	OVS_TUNNEL_KEY_ATTR_TP_SRC,		/* be16 src Transport Port. */
 	OVS_TUNNEL_KEY_ATTR_TP_DST,		/* be16 dst Transport Port. */
+	OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS,		/* Nested OVS_VXLAN_EXT_* */
 	__OVS_TUNNEL_KEY_ATTR_MAX
 };
 
* Unmerged path net/openvswitch/flow_netlink.c
diff --git a/net/openvswitch/vport-geneve.c b/net/openvswitch/vport-geneve.c
index 88a010c98c05..7ca3d454ff3b 100644
--- a/net/openvswitch/vport-geneve.c
+++ b/net/openvswitch/vport-geneve.c
@@ -88,7 +88,7 @@ static void geneve_rcv(struct geneve_sock *gs, struct sk_buff *skb)
 
 	opts_len = geneveh->opt_len * 4;
 
-	flags = TUNNEL_KEY | TUNNEL_OPTIONS_PRESENT |
+	flags = TUNNEL_KEY | TUNNEL_GENEVE_OPT |
 		(udp_hdr(skb)->check != 0 ? TUNNEL_CSUM : 0) |
 		(geneveh->oam ? TUNNEL_OAM : 0) |
 		(geneveh->critical ? TUNNEL_CRIT_OPT : 0);
@@ -178,7 +178,7 @@ static int geneve_tnl_send(struct vport *vport, struct sk_buff *skb)
 	__be16 sport;
 	struct rtable *rt;
 	struct flowi4 fl;
-	u8 vni[3];
+	u8 vni[3], opts_len, *opts;
 	__be16 df;
 	int err;
 
@@ -200,11 +200,18 @@ static int geneve_tnl_send(struct vport *vport, struct sk_buff *skb)
 	tunnel_id_to_vni(tun_key->tun_id, vni);
 	skb->ignore_df = 1;
 
+	if (tun_key->tun_flags & TUNNEL_GENEVE_OPT) {
+		opts = (u8 *)tun_info->options;
+		opts_len = tun_info->options_len;
+	} else {
+		opts = NULL;
+		opts_len = 0;
+	}
+
 	err = geneve_xmit_skb(geneve_port->gs, rt, skb, fl.saddr,
 			      tun_key->ipv4_dst, tun_key->ipv4_tos,
 			      tun_key->ipv4_ttl, df, sport, dport,
-			      tun_key->tun_flags, vni,
-			      tun_info->options_len, (u8 *)tun_info->options,
+			      tun_key->tun_flags, vni, opts_len, opts,
 			      false);
 	if (err < 0)
 		ip_rt_put(rt);
* Unmerged path net/openvswitch/vport-vxlan.c
diff --git a/net/openvswitch/vport-vxlan.h b/net/openvswitch/vport-vxlan.h
new file mode 100644
index 000000000000..4b08233e73d5
--- /dev/null
+++ b/net/openvswitch/vport-vxlan.h
@@ -0,0 +1,11 @@
+#ifndef VPORT_VXLAN_H
+#define VPORT_VXLAN_H 1
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+
+struct ovs_vxlan_opts {
+	__u32 gbp;
+};
+
+#endif
