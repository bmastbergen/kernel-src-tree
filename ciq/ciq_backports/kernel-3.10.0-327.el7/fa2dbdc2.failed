net: Pass a "more" indication down into netdev_start_xmit() code paths.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] Pass a "more" indication down into netdev_start_xmit() code paths (Alexander Duyck) [1205266]
Rebuild_FUZZ: 95.59%
commit-author David S. Miller <davem@davemloft.net>
commit fa2dbdc253c2aee2a760c64de454cb62469ec11d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/fa2dbdc2.failed

For now it will always be false.

	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fa2dbdc253c2aee2a760c64de454cb62469ec11d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wan/dlci.c
#	include/linux/netdevice.h
#	net/atm/mpc.c
#	net/core/dev.c
#	net/core/netpoll.c
#	net/core/pktgen.c
#	net/packet/af_packet.c
#	net/sched/sch_teql.c
diff --cc drivers/net/wan/dlci.c
index 6a8a382c5f4c,ae6ecf401189..000000000000
--- a/drivers/net/wan/dlci.c
+++ b/drivers/net/wan/dlci.c
@@@ -197,8 -192,10 +197,15 @@@ static netdev_tx_t dlci_transmit(struc
  {
  	struct dlci_local *dlp = netdev_priv(dev);
  
++<<<<<<< HEAD
 +	if (skb)
 +		dlp->slave->netdev_ops->ndo_start_xmit(skb, dlp->slave);
++=======
+ 	if (skb) {
+ 		struct netdev_queue *txq = skb_get_tx_queue(dev, skb);
+ 		netdev_start_xmit(skb, dlp->slave, txq, false);
+ 	}
++>>>>>>> fa2dbdc253c2 (net: Pass a "more" indication down into netdev_start_xmit() code paths.)
  	return NETDEV_TX_OK;
  }
  
diff --cc include/linux/netdevice.h
index dba59a041ff6,5050218c5b7f..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -2979,8 -3430,41 +2979,46 @@@ extern int __init dev_proc_init(void)
  #define dev_proc_init() 0
  #endif
  
++<<<<<<< HEAD
 +extern int netdev_class_create_file(struct class_attribute *class_attr);
 +extern void netdev_class_remove_file(struct class_attribute *class_attr);
++=======
+ static inline netdev_tx_t __netdev_start_xmit(const struct net_device_ops *ops,
+ 					      struct sk_buff *skb, struct net_device *dev,
+ 					      bool more)
+ {
+ 	skb->xmit_more = more ? 1 : 0;
+ 	return ops->ndo_start_xmit(skb, dev);
+ }
+ 
+ static inline netdev_tx_t netdev_start_xmit(struct sk_buff *skb, struct net_device *dev,
+ 					    struct netdev_queue *txq, bool more)
+ {
+ 	const struct net_device_ops *ops = dev->netdev_ops;
+ 	int rc;
+ 
+ 	rc = __netdev_start_xmit(ops, skb, dev, more);
+ 	if (rc == NETDEV_TX_OK)
+ 		txq_trans_update(txq);
+ 
+ 	return rc;
+ }
+ 
+ int netdev_class_create_file_ns(struct class_attribute *class_attr,
+ 				const void *ns);
+ void netdev_class_remove_file_ns(struct class_attribute *class_attr,
+ 				 const void *ns);
+ 
+ static inline int netdev_class_create_file(struct class_attribute *class_attr)
+ {
+ 	return netdev_class_create_file_ns(class_attr, NULL);
+ }
+ 
+ static inline void netdev_class_remove_file(struct class_attribute *class_attr)
+ {
+ 	netdev_class_remove_file_ns(class_attr, NULL);
+ }
++>>>>>>> fa2dbdc253c2 (net: Pass a "more" indication down into netdev_start_xmit() code paths.)
  
  extern struct kobj_ns_type_operations net_ns_type_operations;
  
diff --cc net/atm/mpc.c
index d4cc1be5c364,0e982222d425..000000000000
--- a/net/atm/mpc.c
+++ b/net/atm/mpc.c
@@@ -599,7 -599,7 +599,11 @@@ static netdev_tx_t mpc_send_packet(stru
  	}
  
  non_ip:
++<<<<<<< HEAD
 +	return mpc->old_ops->ndo_start_xmit(skb, dev);
++=======
+ 	return __netdev_start_xmit(mpc->old_ops, skb, dev, false);
++>>>>>>> fa2dbdc253c2 (net: Pass a "more" indication down into netdev_start_xmit() code paths.)
  }
  
  static int atm_mpoa_vcc_attach(struct atm_vcc *vcc, void __user *arg)
diff --cc net/core/dev.c
index 1924c9647d47,f0ed5a611a97..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -2485,6 -2599,51 +2485,54 @@@ netdev_features_t netif_skb_features(st
  }
  EXPORT_SYMBOL(netif_skb_features);
  
++<<<<<<< HEAD
++=======
+ static int xmit_one(struct sk_buff *skb, struct net_device *dev,
+ 		    struct netdev_queue *txq)
+ {
+ 	unsigned int len;
+ 	int rc;
+ 
+ 	if (!list_empty(&ptype_all))
+ 		dev_queue_xmit_nit(skb, dev);
+ 
+ 	len = skb->len;
+ 	trace_net_dev_start_xmit(skb, dev);
+ 	rc = netdev_start_xmit(skb, dev, txq, false);
+ 	trace_net_dev_xmit(skb, rc, dev, len);
+ 
+ 	return rc;
+ }
+ 
+ static struct sk_buff *xmit_list(struct sk_buff *first, struct net_device *dev,
+ 				 struct netdev_queue *txq, int *ret)
+ {
+ 	struct sk_buff *skb = first;
+ 	int rc = NETDEV_TX_OK;
+ 
+ 	while (skb) {
+ 		struct sk_buff *next = skb->next;
+ 
+ 		skb->next = NULL;
+ 		rc = xmit_one(skb, dev, txq);
+ 		if (unlikely(!dev_xmit_complete(rc))) {
+ 			skb->next = next;
+ 			goto out;
+ 		}
+ 
+ 		skb = next;
+ 		if (netif_xmit_stopped(txq) && skb) {
+ 			rc = NETDEV_TX_BUSY;
+ 			break;
+ 		}
+ 	}
+ 
+ out:
+ 	*ret = rc;
+ 	return skb;
+ }
+ 
++>>>>>>> fa2dbdc253c2 (net: Pass a "more" indication down into netdev_start_xmit() code paths.)
  int dev_hard_start_xmit(struct sk_buff *skb, struct net_device *dev,
  			struct netdev_queue *txq)
  {
diff --cc net/core/netpoll.c
index 89e339d3631e,e6645b4f330a..000000000000
--- a/net/core/netpoll.c
+++ b/net/core/netpoll.c
@@@ -96,9 -91,7 +96,13 @@@ static int netpoll_start_xmit(struct sk
  		skb->vlan_tci = 0;
  	}
  
++<<<<<<< HEAD
 +	status = ops->ndo_start_xmit(skb, dev);
 +	if (status == NETDEV_TX_OK)
 +		txq_trans_update(txq);
++=======
+ 	status = netdev_start_xmit(skb, dev, txq, false);
++>>>>>>> fa2dbdc253c2 (net: Pass a "more" indication down into netdev_start_xmit() code paths.)
  
  out:
  	return status;
diff --cc net/core/pktgen.c
index dc189dd7ca08,5b36a9428c59..000000000000
--- a/net/core/pktgen.c
+++ b/net/core/pktgen.c
@@@ -3254,7 -3335,7 +3254,11 @@@ static void pktgen_xmit(struct pktgen_d
  		goto unlock;
  	}
  	atomic_inc(&(pkt_dev->skb->users));
++<<<<<<< HEAD
 +	ret = (*xmit)(pkt_dev->skb, odev);
++=======
+ 	ret = netdev_start_xmit(pkt_dev->skb, odev, txq, false);
++>>>>>>> fa2dbdc253c2 (net: Pass a "more" indication down into netdev_start_xmit() code paths.)
  
  	switch (ret) {
  	case NETDEV_TX_OK:
diff --cc net/packet/af_packet.c
index 4450cf82adc9,87d20f48ff06..000000000000
--- a/net/packet/af_packet.c
+++ b/net/packet/af_packet.c
@@@ -237,6 -237,43 +237,46 @@@ struct packet_skb_cb 
  static void __fanout_unlink(struct sock *sk, struct packet_sock *po);
  static void __fanout_link(struct sock *sk, struct packet_sock *po);
  
++<<<<<<< HEAD
++=======
+ static int packet_direct_xmit(struct sk_buff *skb)
+ {
+ 	struct net_device *dev = skb->dev;
+ 	netdev_features_t features;
+ 	struct netdev_queue *txq;
+ 	int ret = NETDEV_TX_BUSY;
+ 
+ 	if (unlikely(!netif_running(dev) ||
+ 		     !netif_carrier_ok(dev)))
+ 		goto drop;
+ 
+ 	features = netif_skb_features(skb);
+ 	if (skb_needs_linearize(skb, features) &&
+ 	    __skb_linearize(skb))
+ 		goto drop;
+ 
+ 	txq = skb_get_tx_queue(dev, skb);
+ 
+ 	local_bh_disable();
+ 
+ 	HARD_TX_LOCK(dev, txq, smp_processor_id());
+ 	if (!netif_xmit_frozen_or_drv_stopped(txq))
+ 		ret = netdev_start_xmit(skb, dev, txq, false);
+ 	HARD_TX_UNLOCK(dev, txq);
+ 
+ 	local_bh_enable();
+ 
+ 	if (!dev_xmit_complete(ret))
+ 		kfree_skb(skb);
+ 
+ 	return ret;
+ drop:
+ 	atomic_long_inc(&dev->tx_dropped);
+ 	kfree_skb(skb);
+ 	return NET_XMIT_DROP;
+ }
+ 
++>>>>>>> fa2dbdc253c2 (net: Pass a "more" indication down into netdev_start_xmit() code paths.)
  static struct net_device *packet_cached_dev_get(struct packet_sock *po)
  {
  	struct net_device *dev;
diff --cc net/sched/sch_teql.c
index 474167162947,aaa8d03ed054..000000000000
--- a/net/sched/sch_teql.c
+++ b/net/sched/sch_teql.c
@@@ -317,8 -316,8 +317,13 @@@ restart
  				unsigned int length = qdisc_pkt_len(skb);
  
  				if (!netif_xmit_frozen_or_stopped(slave_txq) &&
++<<<<<<< HEAD
 +				    slave_ops->ndo_start_xmit(skb, slave) == NETDEV_TX_OK) {
 +					txq_trans_update(slave_txq);
++=======
+ 				    netdev_start_xmit(skb, slave, slave_txq, false) ==
+ 				    NETDEV_TX_OK) {
++>>>>>>> fa2dbdc253c2 (net: Pass a "more" indication down into netdev_start_xmit() code paths.)
  					__netif_tx_unlock(slave_txq);
  					master->slaves = NEXT_SLAVE(q);
  					netif_wake_queue(dev);
* Unmerged path drivers/net/wan/dlci.c
* Unmerged path include/linux/netdevice.h
* Unmerged path net/atm/mpc.c
* Unmerged path net/core/dev.c
* Unmerged path net/core/netpoll.c
* Unmerged path net/core/pktgen.c
* Unmerged path net/packet/af_packet.c
* Unmerged path net/sched/sch_teql.c
