perf session: Add option to copy events when queueing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [tools] perf/session: Add option to copy events when queueing (Jiri Olsa) [1169436]
Rebuild_FUZZ: 98.11%
commit-author Alexander Yarygin <yarygin@linux.vnet.ibm.com>
commit 54bf53b1cb9150b894213a705c562d52388376ef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/54bf53b1.failed

When processing events the session code has an ordered samples queue
which is used to time-sort events coming in across multiple mmaps. At a
later point in time samples on the queue are flushed up to some
timestamp at which point the event is actually processed.

When analyzing events live (ie., record/analysis path in the same
command) there is a race that leads to corrupted events and parse errors
which cause perf to terminate. The problem is that when the event is
placed in the ordered samples queue it is only a reference to the event
which is really sitting in the mmap buffer. Even though the event is
queued for later processing the mmap tail pointer is updated which
indicates to the kernel that the event has been processed. The race is
flushing the event from the queue before it gets overwritten by some
other event. For commands trying to process events live (versus just
writing to a file) and processing a high rate of events this leads to
parse failures and perf terminates.

Examples hitting this problem are 'perf kvm stat live', especially with
nested VMs which generate 100,000+ traces per second, and a command
processing scheduling events with a high rate of context switching --
e.g., running 'perf bench sched pipe'.

This patch offers live commands an option to copy the event when it is
placed in the ordered samples queue.

Based on a patch from David Ahern <dsahern@gmail.com>

	Signed-off-by: Alexander Yarygin <yarygin@linux.vnet.ibm.com>
	Acked-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Christian Borntraeger <borntraeger@de.ibm.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Mike Galbraith <efault@gmx.de>
	Cc: Namhyung Kim <namhyung.kim@lge.com>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
	Cc: Stephane Eranian <eranian@google.com>
Link: http://lkml.kernel.org/r/1412347212-28237-2-git-send-email-yarygin@linux.vnet.ibm.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 54bf53b1cb9150b894213a705c562d52388376ef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/ordered-events.c
#	tools/perf/util/ordered-events.h
#	tools/perf/util/session.c
diff --cc tools/perf/util/session.c
index 47139fac1b67,6702ac28754b..000000000000
--- a/tools/perf/util/session.c
+++ b/tools/perf/util/session.c
@@@ -679,33 -520,28 +679,43 @@@ int perf_session_queue_event(struct per
  	if (!timestamp || timestamp == ~0ULL)
  		return -ETIME;
  
 -	if (timestamp < oe->last_flush) {
 -		WARN_ONCE(1, "Timestamp below last timeslice flush\n");
 -
 -		pr_oe_time(timestamp,      "out of order event");
 -		pr_oe_time(oe->last_flush, "last flush, last_flush_type %d\n",
 -			   oe->last_flush_type);
 -
 -		/* We could get out of order messages after forced flush. */
 -		if (oe->last_flush_type != OE_FLUSH__HALF)
 -			return -EINVAL;
 +	if (timestamp < s->ordered_events.last_flush) {
 +		printf("Warning: Timestamp below last timeslice flush\n");
 +		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	if (!list_empty(cache)) {
 +		new = list_entry(cache->next, struct ordered_event, list);
 +		list_del(&new->list);
 +	} else if (oe->buffer) {
 +		new = oe->buffer + oe->buffer_idx;
 +		if (++oe->buffer_idx == MAX_SAMPLE_BUFFER)
 +			oe->buffer = NULL;
 +	} else {
 +		oe->buffer = malloc(MAX_SAMPLE_BUFFER * sizeof(*new));
 +		if (!oe->buffer)
 +			return -ENOMEM;
 +		list_add(&oe->buffer->list, &oe->to_free);
 +		oe->buffer_idx = 2;
 +		new = oe->buffer + 1;
++=======
+ 	new = ordered_events__new(oe, timestamp, event);
+ 	if (!new) {
+ 		ordered_events__flush(s, tool, OE_FLUSH__HALF);
+ 		new = ordered_events__new(oe, timestamp, event);
++>>>>>>> 54bf53b1cb91 (perf session: Add option to copy events when queueing)
  	}
  
 -	if (!new)
 -		return -ENOMEM;
 -
 +	new->timestamp = timestamp;
  	new->file_offset = file_offset;
++<<<<<<< HEAD
 +	new->event = event;
 +
 +	__queue_event(new, s);
 +
++=======
++>>>>>>> 54bf53b1cb91 (perf session: Add option to copy events when queueing)
  	return 0;
  }
  
* Unmerged path tools/perf/util/ordered-events.c
* Unmerged path tools/perf/util/ordered-events.h
* Unmerged path tools/perf/util/ordered-events.c
* Unmerged path tools/perf/util/ordered-events.h
* Unmerged path tools/perf/util/session.c
