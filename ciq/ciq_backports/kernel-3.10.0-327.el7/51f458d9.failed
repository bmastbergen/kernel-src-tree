mac80211: fix locking in update_vlan_tailroom_need_count()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Johannes Berg <johannes.berg@intel.com>
commit 51f458d9612177f69c2e2c437034ae15f93078e7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/51f458d9.failed

Unfortunately, Michal's change to fix AP_VLAN crypto tailroom
caused a locking issue that was reported by lockdep, but only
in a few cases - the issue was a classic ABBA deadlock caused
by taking the mtx after the key_mtx, where normally they're
taken the other way around.

As the key mutex protects the field in question (I'm adding a
few annotations to make that clear) only the iteration needs
to be protected, but we can also iterate the interface list
with just RCU protection while holding the key mutex.

Fixes: f9dca80b98ca ("mac80211: fix AP_VLAN crypto tailroom calculation")
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 51f458d9612177f69c2e2c437034ae15f93078e7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/key.c
diff --cc net/mac80211/key.c
index 16d97f044a20,81e9785f38bc..000000000000
--- a/net/mac80211/key.c
+++ b/net/mac80211/key.c
@@@ -55,6 -58,25 +55,28 @@@ static void assert_key_lock(struct ieee
  	lockdep_assert_held(&local->key_mtx);
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ update_vlan_tailroom_need_count(struct ieee80211_sub_if_data *sdata, int delta)
+ {
+ 	struct ieee80211_sub_if_data *vlan;
+ 
+ 	if (sdata->vif.type != NL80211_IFTYPE_AP)
+ 		return;
+ 
+ 	/* crypto_tx_tailroom_needed_cnt is protected by this */
+ 	assert_key_lock(sdata->local);
+ 
+ 	rcu_read_lock();
+ 
+ 	list_for_each_entry_rcu(vlan, &sdata->u.ap.vlans, u.vlan.list)
+ 		vlan->crypto_tx_tailroom_needed_cnt += delta;
+ 
+ 	rcu_read_unlock();
+ }
+ 
++>>>>>>> 51f458d96121 (mac80211: fix locking in update_vlan_tailroom_need_count())
  static void increment_tailroom_need_count(struct ieee80211_sub_if_data *sdata)
  {
  	/*
@@@ -76,6 -98,10 +98,13 @@@
  	 * http://mid.gmane.org/1308590980.4322.19.camel@jlt3.sipsolutions.net
  	 */
  
++<<<<<<< HEAD
++=======
+ 	assert_key_lock(sdata->local);
+ 
+ 	update_vlan_tailroom_need_count(sdata, 1);
+ 
++>>>>>>> 51f458d96121 (mac80211: fix locking in update_vlan_tailroom_need_count())
  	if (!sdata->crypto_tx_tailroom_needed_cnt++) {
  		/*
  		 * Flush all XMIT packets currently using HW encryption or no
@@@ -85,6 -111,17 +114,20 @@@
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void decrease_tailroom_need_count(struct ieee80211_sub_if_data *sdata,
+ 					 int delta)
+ {
+ 	assert_key_lock(sdata->local);
+ 
+ 	WARN_ON_ONCE(sdata->crypto_tx_tailroom_needed_cnt < delta);
+ 
+ 	update_vlan_tailroom_need_count(sdata, -delta);
+ 	sdata->crypto_tx_tailroom_needed_cnt -= delta;
+ }
+ 
++>>>>>>> 51f458d96121 (mac80211: fix locking in update_vlan_tailroom_need_count())
  static int ieee80211_key_enable_hw_accel(struct ieee80211_key *key)
  {
  	struct ieee80211_sub_if_data *sdata;
* Unmerged path net/mac80211/key.c
