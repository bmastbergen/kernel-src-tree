bonding: create bond_first_slave_rcu()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author dingtianhong <dingtianhong@huawei.com>
commit e001bfad913bf119fb67c1e8dd2d4ec1f5d392fa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/e001bfad.failed

The bond_first_slave_rcu() will be used to instead of bond_first_slave()
in rcu_read_lock().

According to the Jay Vosburgh's suggestion, the struct netdev_adjacent
should hide from users who wanted to use it directly. so I package a
new function to get the first slave of the bond.

	Suggested-by: Nikolay Aleksandrov <nikolay@redhat.com>
	Suggested-by: Jay Vosburgh <fubar@us.ibm.com>
	Suggested-by: Veaceslav Falico <vfalico@redhat.com>
	Signed-off-by: Ding Tianhong <dingtianhong@huawei.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e001bfad913bf119fb67c1e8dd2d4ec1f5d392fa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bonding.h
#	include/linux/netdevice.h
diff --cc drivers/net/bonding/bonding.h
index 743d73f75728,8f0d6d0c383b..000000000000
--- a/drivers/net/bonding/bonding.h
+++ b/drivers/net/bonding/bonding.h
@@@ -71,12 -86,33 +71,37 @@@
  	set_fs(fs);			\
  	res; })
  
++<<<<<<< HEAD
++=======
+ /* slave list primitives */
+ #define bond_slave_list(bond) (&(bond)->dev->adj_list.lower)
+ 
+ #define bond_has_slaves(bond) !list_empty(bond_slave_list(bond))
+ 
+ /* IMPORTANT: bond_first/last_slave can return NULL in case of an empty list */
+ #define bond_first_slave(bond) \
+ 	(bond_has_slaves(bond) ? \
+ 		netdev_adjacent_get_private(bond_slave_list(bond)->next) : \
+ 		NULL)
+ #define bond_last_slave(bond) \
+ 	(bond_has_slaves(bond) ? \
+ 		netdev_adjacent_get_private(bond_slave_list(bond)->prev) : \
+ 		NULL)
+ 
+ /* Caller must have rcu_read_lock */
+ #define bond_first_slave_rcu(bond) \
+ 	netdev_lower_get_first_private_rcu(bond->dev)
+ 
+ #define bond_is_first_slave(bond, pos) (pos == bond_first_slave(bond))
+ #define bond_is_last_slave(bond, pos) (pos == bond_last_slave(bond))
+ 
++>>>>>>> e001bfad913b (bonding: create bond_first_slave_rcu())
  /**
 - * bond_for_each_slave - iterate over all slaves
 - * @bond:	the bond holding this list
 - * @pos:	current slave
 - * @iter:	list_head * iterator
 + * bond_for_each_slave_from - iterate the slaves list from a starting point
 + * @bond:	the bond holding this list.
 + * @pos:	current slave.
 + * @cnt:	counter for max number of moves
 + * @start:	starting point.
   *
   * Caller must hold bond->lock
   */
diff --cc include/linux/netdevice.h
index 975ee94cf706,2c74d20dad34..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -2932,22 -2877,56 +2932,60 @@@ extern int		netdev_tstamp_prequeue
  extern int		weight_p;
  extern int		bpf_jit_enable;
  
++<<<<<<< HEAD
 +extern bool netdev_has_upper_dev(struct net_device *dev,
++=======
+ bool netdev_has_upper_dev(struct net_device *dev, struct net_device *upper_dev);
+ bool netdev_has_any_upper_dev(struct net_device *dev);
+ struct net_device *netdev_all_upper_get_next_dev_rcu(struct net_device *dev,
+ 						     struct list_head **iter);
+ 
+ /* iterate through upper list, must be called under RCU read lock */
+ #define netdev_for_each_all_upper_dev_rcu(dev, updev, iter) \
+ 	for (iter = &(dev)->all_adj_list.upper, \
+ 	     updev = netdev_all_upper_get_next_dev_rcu(dev, &(iter)); \
+ 	     updev; \
+ 	     updev = netdev_all_upper_get_next_dev_rcu(dev, &(iter)))
+ 
+ void *netdev_lower_get_next_private(struct net_device *dev,
+ 				    struct list_head **iter);
+ void *netdev_lower_get_next_private_rcu(struct net_device *dev,
+ 					struct list_head **iter);
+ 
+ #define netdev_for_each_lower_private(dev, priv, iter) \
+ 	for (iter = (dev)->adj_list.lower.next, \
+ 	     priv = netdev_lower_get_next_private(dev, &(iter)); \
+ 	     priv; \
+ 	     priv = netdev_lower_get_next_private(dev, &(iter)))
+ 
+ #define netdev_for_each_lower_private_rcu(dev, priv, iter) \
+ 	for (iter = &(dev)->adj_list.lower, \
+ 	     priv = netdev_lower_get_next_private_rcu(dev, &(iter)); \
+ 	     priv; \
+ 	     priv = netdev_lower_get_next_private_rcu(dev, &(iter)))
+ 
+ void *netdev_adjacent_get_private(struct list_head *adj_list);
+ void *netdev_lower_get_first_private_rcu(struct net_device *dev);
+ struct net_device *netdev_master_upper_dev_get(struct net_device *dev);
+ struct net_device *netdev_master_upper_dev_get_rcu(struct net_device *dev);
+ int netdev_upper_dev_link(struct net_device *dev, struct net_device *upper_dev);
+ int netdev_master_upper_dev_link(struct net_device *dev,
++>>>>>>> e001bfad913b (bonding: create bond_first_slave_rcu())
 +				 struct net_device *upper_dev);
 +extern bool netdev_has_any_upper_dev(struct net_device *dev);
 +extern struct net_device *netdev_master_upper_dev_get(struct net_device *dev);
 +extern struct net_device *netdev_master_upper_dev_get_rcu(struct net_device *dev);
 +extern int netdev_upper_dev_link(struct net_device *dev,
  				 struct net_device *upper_dev);
 -int netdev_master_upper_dev_link_private(struct net_device *dev,
 -					 struct net_device *upper_dev,
 -					 void *private);
 -void netdev_upper_dev_unlink(struct net_device *dev,
 -			     struct net_device *upper_dev);
 -void *netdev_lower_dev_get_private_rcu(struct net_device *dev,
 -				       struct net_device *lower_dev);
 -void *netdev_lower_dev_get_private(struct net_device *dev,
 -				   struct net_device *lower_dev);
 -int skb_checksum_help(struct sk_buff *skb);
 -struct sk_buff *__skb_gso_segment(struct sk_buff *skb,
 -				  netdev_features_t features, bool tx_path);
 -struct sk_buff *skb_mac_gso_segment(struct sk_buff *skb,
 -				    netdev_features_t features);
 +extern int netdev_master_upper_dev_link(struct net_device *dev,
 +					struct net_device *upper_dev);
 +extern void netdev_upper_dev_unlink(struct net_device *dev,
 +				    struct net_device *upper_dev);
 +extern int skb_checksum_help(struct sk_buff *skb);
 +extern struct sk_buff *__skb_gso_segment(struct sk_buff *skb,
 +	netdev_features_t features, bool tx_path);
 +extern struct sk_buff *skb_mac_gso_segment(struct sk_buff *skb,
 +					  netdev_features_t features);
  
  static inline
  struct sk_buff *skb_gso_segment(struct sk_buff *skb, netdev_features_t features)
* Unmerged path drivers/net/bonding/bonding.h
* Unmerged path include/linux/netdevice.h
diff --git a/net/core/dev.c b/net/core/dev.c
index 996c694b33ed..afd0c440788c 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -4476,6 +4476,27 @@ struct net_device *netdev_master_upper_dev_get(struct net_device *dev)
 }
 EXPORT_SYMBOL(netdev_master_upper_dev_get);
 
+/**
+ * netdev_lower_get_first_private_rcu - Get the first ->private from the
+ *				       lower neighbour list, RCU
+ *				       variant
+ * @dev: device
+ *
+ * Gets the first netdev_adjacent->private from the dev's lower neighbour
+ * list. The caller must hold RCU read lock.
+ */
+void *netdev_lower_get_first_private_rcu(struct net_device *dev)
+{
+	struct netdev_adjacent *lower;
+
+	lower = list_first_or_null_rcu(&dev->adj_list.lower,
+			struct netdev_adjacent, list);
+	if (lower)
+		return lower->private;
+	return NULL;
+}
+EXPORT_SYMBOL(netdev_lower_get_first_private_rcu);
+
 /**
  * netdev_master_upper_dev_get_rcu - Get master upper device
  * @dev: device
