vxlan: Eliminate dependency on UDP socket in transmit path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Tom Herbert <therbert@google.com>
commit af33c1adae1e095e90d14fe35501256ebb07aabf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/af33c1ad.failed

In the vxlan transmit path there is no need to reference the socket
for a tunnel which is needed for the receive side. We do, however,
need the vxlan_dev flags. This patch eliminate references
to the socket in the transmit path, and changes VXLAN_F_UNSHAREABLE
to be VXLAN_F_RCV_FLAGS. This mask is used to store the flags
applicable to receive (GBP, CSUM6_RX, and REMCSUM_RX) in the
vxlan_sock flags.

	Signed-off-by: Tom Herbert <therbert@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit af33c1adae1e095e90d14fe35501256ebb07aabf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
#	include/net/vxlan.h
#	net/openvswitch/vport-vxlan.c
diff --cc drivers/net/vxlan.c
index 3440d933b3ec,87736e65cd15..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -273,15 -263,20 +273,25 @@@ static inline struct vxlan_rdst *first_
  	return list_first_entry(&fdb->remotes, struct vxlan_rdst, list);
  }
  
 -/* Find VXLAN socket based on network namespace, address family and UDP port
 - * and enabled unshareable flags.
 - */
 -static struct vxlan_sock *vxlan_find_sock(struct net *net, sa_family_t family,
 -					  __be16 port, u32 flags)
 +/* Find VXLAN socket based on network namespace, address family and UDP port */
 +static struct vxlan_sock *vxlan_find_sock(struct net *net,
 +					  sa_family_t family, __be16 port)
  {
  	struct vxlan_sock *vs;
++<<<<<<< HEAD
 +
 +	hlist_for_each_entry_rcu(vs, vs_head(net, port), hlist) {
 +		if (inet_sk(vs->sock->sk)->inet_sport == port &&
 +		    inet_sk(vs->sock->sk)->sk.sk_family == family)
++=======
+ 
+ 	flags &= VXLAN_F_RCV_FLAGS;
+ 
+ 	hlist_for_each_entry_rcu(vs, vs_head(net, port), hlist) {
+ 		if (inet_sk(vs->sock->sk)->inet_sport == port &&
+ 		    inet_sk(vs->sock->sk)->sk.sk_family == family &&
+ 		    vs->flags == flags)
++>>>>>>> af33c1adae1e (vxlan: Eliminate dependency on UDP socket in transmit path)
  			return vs;
  	}
  	return NULL;
@@@ -1529,29 -1675,57 +1539,69 @@@ static bool route_shortcircuit(struct n
  	return false;
  }
  
++<<<<<<< HEAD
 +static inline struct sk_buff *vxlan_handle_offloads(struct sk_buff *skb,
 +						    bool udp_csum)
++=======
+ static void vxlan_build_gbp_hdr(struct vxlanhdr *vxh, u32 vxflags,
+ 				struct vxlan_metadata *md)
++>>>>>>> af33c1adae1e (vxlan: Eliminate dependency on UDP socket in transmit path)
  {
 -	struct vxlanhdr_gbp *gbp;
 -
 -	gbp = (struct vxlanhdr_gbp *)vxh;
 -	vxh->vx_flags |= htonl(VXLAN_HF_GBP);
 -
 -	if (md->gbp & VXLAN_GBP_DONT_LEARN)
 -		gbp->dont_learn = 1;
 -
 -	if (md->gbp & VXLAN_GBP_POLICY_APPLIED)
 -		gbp->policy_applied = 1;
 -
 -	gbp->policy_id = htons(md->gbp & VXLAN_GBP_ID_MASK);
 +	int type = udp_csum ? SKB_GSO_UDP_TUNNEL_CSUM : SKB_GSO_UDP_TUNNEL;
 +	return iptunnel_handle_offloads(skb, udp_csum, type);
  }
  
  #if IS_ENABLED(CONFIG_IPV6)
++<<<<<<< HEAD
 +static int vxlan6_xmit_skb(struct net *net, struct vxlan_sock *vs,
 +			   struct dst_entry *dst, struct sk_buff *skb,
 +			   struct net_device *dev, struct in6_addr *saddr,
 +			   struct in6_addr *daddr, __u8 prio, __u8 ttl,
 +			   __be16 src_port, __be16 dst_port, __be32 vni)
++=======
+ static int vxlan6_xmit_skb(struct dst_entry *dst, struct sk_buff *skb,
+ 			   struct net_device *dev, struct in6_addr *saddr,
+ 			   struct in6_addr *daddr, __u8 prio, __u8 ttl,
+ 			   __be16 src_port, __be16 dst_port,
+ 			   struct vxlan_metadata *md, bool xnet, u32 vxflags)
++>>>>>>> af33c1adae1e (vxlan: Eliminate dependency on UDP socket in transmit path)
  {
 +	struct ipv6hdr *ip6h;
  	struct vxlanhdr *vxh;
 +	struct udphdr *uh;
  	int min_headroom;
  	int err;
++<<<<<<< HEAD
 +
 +	skb = vxlan_handle_offloads(skb, !udp_get_no_check6_tx(vs->sock->sk));
 +	if (IS_ERR(skb))
 +		return -EINVAL;
++=======
+ 	bool udp_sum = !(vxflags & VXLAN_F_UDP_ZERO_CSUM6_TX);
+ 	int type = udp_sum ? SKB_GSO_UDP_TUNNEL_CSUM : SKB_GSO_UDP_TUNNEL;
+ 	u16 hdrlen = sizeof(struct vxlanhdr);
+ 
+ 	if ((vxflags & VXLAN_F_REMCSUM_TX) &&
+ 	    skb->ip_summed == CHECKSUM_PARTIAL) {
+ 		int csum_start = skb_checksum_start_offset(skb);
+ 
+ 		if (csum_start <= VXLAN_MAX_REMCSUM_START &&
+ 		    !(csum_start & VXLAN_RCO_SHIFT_MASK) &&
+ 		    (skb->csum_offset == offsetof(struct udphdr, check) ||
+ 		     skb->csum_offset == offsetof(struct tcphdr, check))) {
+ 			udp_sum = false;
+ 			type |= SKB_GSO_TUNNEL_REMCSUM;
+ 		}
+ 	}
+ 
+ 	skb = iptunnel_handle_offloads(skb, udp_sum, type);
+ 	if (IS_ERR(skb)) {
+ 		err = -EINVAL;
+ 		goto err;
+ 	}
+ 
+ 	skb_scrub_packet(skb, xnet);
++>>>>>>> af33c1adae1e (vxlan: Eliminate dependency on UDP socket in transmit path)
  
  	min_headroom = LL_RESERVED_SPACE(dst->dev) + dst->header_len
  			+ VXLAN_HLEN + sizeof(struct ipv6hdr)
@@@ -1572,59 -1745,68 +1622,98 @@@
  	}
  
  	vxh = (struct vxlanhdr *) __skb_push(skb, sizeof(*vxh));
 -	vxh->vx_flags = htonl(VXLAN_HF_VNI);
 -	vxh->vx_vni = md->vni;
 +	vxh->vx_flags = htonl(VXLAN_FLAGS);
 +	vxh->vx_vni = vni;
  
 -	if (type & SKB_GSO_TUNNEL_REMCSUM) {
 -		u32 data = (skb_checksum_start_offset(skb) - hdrlen) >>
 -			   VXLAN_RCO_SHIFT;
 +	__skb_push(skb, sizeof(*uh));
 +	skb_reset_transport_header(skb);
 +	uh = udp_hdr(skb);
  
 -		if (skb->csum_offset == offsetof(struct udphdr, check))
 -			data |= VXLAN_RCO_UDP;
 +	uh->dest = dst_port;
 +	uh->source = src_port;
  
 -		vxh->vx_vni |= htonl(data);
 -		vxh->vx_flags |= htonl(VXLAN_HF_RCO);
 +	uh->len = htons(skb->len);
  
 -		if (!skb_is_gso(skb)) {
 -			skb->ip_summed = CHECKSUM_NONE;
 -			skb->encapsulation = 0;
 -		}
 -	}
 +	memset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));
 +	IPCB(skb)->flags &= ~(IPSKB_XFRM_TUNNEL_SIZE | IPSKB_XFRM_TRANSFORMED |
 +			      IPSKB_REROUTED);
 +	skb_dst_drop(skb);
 +	skb_dst_set(skb, dst);
  
++<<<<<<< HEAD
 +	udp6_set_csum(udp_get_no_check6_tx(vs->sock->sk), skb,
 +		      saddr, daddr, skb->len);
++=======
+ 	if (vxflags & VXLAN_F_GBP)
+ 		vxlan_build_gbp_hdr(vxh, vxflags, md);
++>>>>>>> af33c1adae1e (vxlan: Eliminate dependency on UDP socket in transmit path)
  
 -	skb_set_inner_protocol(skb, htons(ETH_P_TEB));
 -
 +	__skb_push(skb, sizeof(*ip6h));
 +	skb_reset_network_header(skb);
 +	ip6h		  = ipv6_hdr(skb);
 +	ip6h->version	  = 6;
 +	ip6h->priority	  = prio;
 +	ip6h->flow_lbl[0] = 0;
 +	ip6h->flow_lbl[1] = 0;
 +	ip6h->flow_lbl[2] = 0;
 +	ip6h->payload_len = htons(skb->len);
 +	ip6h->nexthdr     = IPPROTO_UDP;
 +	ip6h->hop_limit   = ttl;
 +	ip6h->daddr	  = *daddr;
 +	ip6h->saddr	  = *saddr;
 +
++<<<<<<< HEAD
 +	ip6tunnel_xmit(skb, dev);
++=======
+ 	udp_tunnel6_xmit_skb(dst, skb, dev, saddr, daddr, prio,
+ 			     ttl, src_port, dst_port,
+ 			     !!(vxflags & VXLAN_F_UDP_ZERO_CSUM6_TX));
++>>>>>>> af33c1adae1e (vxlan: Eliminate dependency on UDP socket in transmit path)
  	return 0;
 -err:
 -	dst_release(dst);
 -	return err;
  }
  #endif
  
++<<<<<<< HEAD
 +int vxlan_xmit_skb(struct net *net, struct vxlan_sock *vs,
 +		   struct rtable *rt, struct sk_buff *skb,
 +		   __be32 src, __be32 dst, __u8 tos, __u8 ttl, __be16 df,
 +		   __be16 src_port, __be16 dst_port, __be32 vni)
++=======
+ int vxlan_xmit_skb(struct rtable *rt, struct sk_buff *skb,
+ 		   __be32 src, __be32 dst, __u8 tos, __u8 ttl, __be16 df,
+ 		   __be16 src_port, __be16 dst_port,
+ 		   struct vxlan_metadata *md, bool xnet, u32 vxflags)
++>>>>>>> af33c1adae1e (vxlan: Eliminate dependency on UDP socket in transmit path)
  {
  	struct vxlanhdr *vxh;
 +	struct udphdr *uh;
  	int min_headroom;
  	int err;
++<<<<<<< HEAD
 +
 +	skb = vxlan_handle_offloads(skb, !vs->sock->sk->sk_no_check_tx);
++=======
+ 	bool udp_sum = !!(vxflags & VXLAN_F_UDP_CSUM);
+ 	int type = udp_sum ? SKB_GSO_UDP_TUNNEL_CSUM : SKB_GSO_UDP_TUNNEL;
+ 	u16 hdrlen = sizeof(struct vxlanhdr);
+ 
+ 	if ((vxflags & VXLAN_F_REMCSUM_TX) &&
+ 	    skb->ip_summed == CHECKSUM_PARTIAL) {
+ 		int csum_start = skb_checksum_start_offset(skb);
+ 
+ 		if (csum_start <= VXLAN_MAX_REMCSUM_START &&
+ 		    !(csum_start & VXLAN_RCO_SHIFT_MASK) &&
+ 		    (skb->csum_offset == offsetof(struct udphdr, check) ||
+ 		     skb->csum_offset == offsetof(struct tcphdr, check))) {
+ 			udp_sum = false;
+ 			type |= SKB_GSO_TUNNEL_REMCSUM;
+ 		}
+ 	}
+ 
+ 	skb = iptunnel_handle_offloads(skb, udp_sum, type);
++>>>>>>> af33c1adae1e (vxlan: Eliminate dependency on UDP socket in transmit path)
  	if (IS_ERR(skb))
 -		return PTR_ERR(skb);
 +		return -EINVAL;
  
  	min_headroom = LL_RESERVED_SPACE(rt->dst.dev) + rt->dst.header_len
  			+ VXLAN_HLEN + sizeof(struct iphdr)
@@@ -1632,36 -1814,43 +1721,47 @@@
  
  	/* Need space for new headers (invalidates iph ptr) */
  	err = skb_cow_head(skb, min_headroom);
 -	if (unlikely(err)) {
 -		kfree_skb(skb);
 +	if (unlikely(err))
  		return err;
 -	}
  
 -	skb = vlan_hwaccel_push_inside(skb);
 -	if (WARN_ON(!skb))
 -		return -ENOMEM;
 +	if (vlan_tx_tag_present(skb)) {
 +		if (WARN_ON(!__vlan_put_tag(skb,
 +					    skb->vlan_proto,
 +					    vlan_tx_tag_get(skb))))
 +			return -ENOMEM;
 +
 +		skb->vlan_tci = 0;
 +	}
  
  	vxh = (struct vxlanhdr *) __skb_push(skb, sizeof(*vxh));
 -	vxh->vx_flags = htonl(VXLAN_HF_VNI);
 -	vxh->vx_vni = md->vni;
 +	vxh->vx_flags = htonl(VXLAN_FLAGS);
 +	vxh->vx_vni = vni;
  
 -	if (type & SKB_GSO_TUNNEL_REMCSUM) {
 -		u32 data = (skb_checksum_start_offset(skb) - hdrlen) >>
 -			   VXLAN_RCO_SHIFT;
 +	__skb_push(skb, sizeof(*uh));
 +	skb_reset_transport_header(skb);
 +	uh = udp_hdr(skb);
  
 -		if (skb->csum_offset == offsetof(struct udphdr, check))
 -			data |= VXLAN_RCO_UDP;
 +	uh->dest = dst_port;
 +	uh->source = src_port;
  
 -		vxh->vx_vni |= htonl(data);
 -		vxh->vx_flags |= htonl(VXLAN_HF_RCO);
 +	uh->len = htons(skb->len);
  
 -		if (!skb_is_gso(skb)) {
 -			skb->ip_summed = CHECKSUM_NONE;
 -			skb->encapsulation = 0;
 -		}
 -	}
 +	udp_set_csum(vs->sock->sk->sk_no_check_tx, skb,
 +		     src, dst, skb->len);
  
++<<<<<<< HEAD
 +	return iptunnel_xmit(vs->sock->sk, rt, skb, src, dst, IPPROTO_UDP,
 +			     tos, ttl, df);
++=======
+ 	if (vxflags & VXLAN_F_GBP)
+ 		vxlan_build_gbp_hdr(vxh, vxflags, md);
+ 
+ 	skb_set_inner_protocol(skb, htons(ETH_P_TEB));
+ 
+ 	return udp_tunnel_xmit_skb(rt, skb, src, dst, tos,
+ 				   ttl, df, src_port, dst_port, xnet,
+ 				   !(vxflags & VXLAN_F_UDP_CSUM));
++>>>>>>> af33c1adae1e (vxlan: Eliminate dependency on UDP socket in transmit path)
  }
  EXPORT_SYMBOL_GPL(vxlan_xmit_skb);
  
@@@ -1787,14 -1979,20 +1887,27 @@@ static void vxlan_xmit_one(struct sk_bu
  
  		tos = ip_tunnel_ecn_encap(tos, old_iph, skb);
  		ttl = ttl ? : ip4_dst_hoplimit(&rt->dst);
 -		md.vni = htonl(vni << 8);
 -		md.gbp = skb->mark;
  
++<<<<<<< HEAD
 +		err = vxlan_xmit_skb(dev_net(dev), vxlan->vn_sock, rt, skb,
 +				     fl4.saddr, dst->sin.sin_addr.s_addr,
 +				     tos, ttl, df, src_port, dst_port,
 +				     htonl(vni << 8));
++=======
+ 		err = vxlan_xmit_skb(rt, skb, fl4.saddr,
+ 				     dst->sin.sin_addr.s_addr, tos, ttl, df,
+ 				     src_port, dst_port, &md,
+ 				     !net_eq(vxlan->net, dev_net(vxlan->dev)),
+ 				     vxlan->flags);
+ 		if (err < 0) {
+ 			/* skb is already freed. */
+ 			skb = NULL;
+ 			goto rt_tx_error;
+ 		}
++>>>>>>> af33c1adae1e (vxlan: Eliminate dependency on UDP socket in transmit path)
  
 +		if (err < 0)
 +			goto rt_tx_error;
  		iptunnel_xmit_stats(err, &dev->stats, dev->tstats);
  #if IS_ENABLED(CONFIG_IPV6)
  	} else {
@@@ -1840,10 -2039,13 +1953,17 @@@
  		}
  
  		ttl = ttl ? : ip6_dst_hoplimit(ndst);
 -		md.vni = htonl(vni << 8);
 -		md.gbp = skb->mark;
  
++<<<<<<< HEAD
 +		err = vxlan6_xmit_skb(dev_net(dev), vxlan->vn_sock, ndst, skb,
 +				      dev, &fl6.saddr, &fl6.daddr, 0, ttl,
 +				      src_port, dst_port, htonl(vni << 8));
++=======
+ 		err = vxlan6_xmit_skb(ndst, skb, dev, &fl6.saddr, &fl6.daddr,
+ 				      0, ttl, src_port, dst_port, &md,
+ 				      !net_eq(vxlan->net, dev_net(vxlan->dev)),
+ 				      vxlan->flags);
++>>>>>>> af33c1adae1e (vxlan: Eliminate dependency on UDP socket in transmit path)
  #endif
  	}
  
@@@ -2371,7 -2565,7 +2487,11 @@@ static struct vxlan_sock *vxlan_socket_
  	atomic_set(&vs->refcnt, 1);
  	vs->rcv = rcv;
  	vs->data = data;
++<<<<<<< HEAD
 +	rcu_assign_sk_user_data(vs->sock->sk, vs);
++=======
+ 	vs->flags = (flags & VXLAN_F_RCV_FLAGS);
++>>>>>>> af33c1adae1e (vxlan: Eliminate dependency on UDP socket in transmit path)
  
  	/* Initialize the vxlan udp offloads structure */
  	vs->udp_offloads.port = port;
diff --cc include/net/vxlan.h
index 1ddc74769f81,2927d6244481..000000000000
--- a/include/net/vxlan.h
+++ b/include/net/vxlan.h
@@@ -33,6 -125,16 +33,19 @@@ struct vxlan_sock 
  #define VXLAN_F_UDP_CSUM		0x40
  #define VXLAN_F_UDP_ZERO_CSUM6_TX	0x80
  #define VXLAN_F_UDP_ZERO_CSUM6_RX	0x100
++<<<<<<< HEAD
++=======
+ #define VXLAN_F_REMCSUM_TX		0x200
+ #define VXLAN_F_REMCSUM_RX		0x400
+ #define VXLAN_F_GBP			0x800
+ 
+ /* Flags that are used in the receive patch. These flags must match in
+  * order for a socket to be shareable
+  */
+ #define VXLAN_F_RCV_FLAGS		(VXLAN_F_GBP |			\
+ 					 VXLAN_F_UDP_ZERO_CSUM6_RX |	\
+ 					 VXLAN_F_REMCSUM_RX)
++>>>>>>> af33c1adae1e (vxlan: Eliminate dependency on UDP socket in transmit path)
  
  struct vxlan_sock *vxlan_sock_add(struct net *net, __be16 port,
  				  vxlan_rcv_t *rcv, void *data,
@@@ -40,10 -142,39 +53,46 @@@
  
  void vxlan_sock_release(struct vxlan_sock *vs);
  
++<<<<<<< HEAD
 +int vxlan_xmit_skb(struct net *net, struct vxlan_sock *vs,
 +		   struct rtable *rt, struct sk_buff *skb,
 +		   __be32 src, __be32 dst, __u8 tos, __u8 ttl, __be16 df,
 +		   __be16 src_port, __be16 dst_port, __be32 vni);
++=======
+ int vxlan_xmit_skb(struct rtable *rt, struct sk_buff *skb,
+ 		   __be32 src, __be32 dst, __u8 tos, __u8 ttl, __be16 df,
+ 		   __be16 src_port, __be16 dst_port, struct vxlan_metadata *md,
+ 		   bool xnet, u32 vxflags);
+ 
+ static inline netdev_features_t vxlan_features_check(struct sk_buff *skb,
+ 						     netdev_features_t features)
+ {
+ 	u8 l4_hdr = 0;
+ 
+ 	if (!skb->encapsulation)
+ 		return features;
+ 
+ 	switch (vlan_get_protocol(skb)) {
+ 	case htons(ETH_P_IP):
+ 		l4_hdr = ip_hdr(skb)->protocol;
+ 		break;
+ 	case htons(ETH_P_IPV6):
+ 		l4_hdr = ipv6_hdr(skb)->nexthdr;
+ 		break;
+ 	default:
+ 		return features;;
+ 	}
+ 
+ 	if ((l4_hdr == IPPROTO_UDP) &&
+ 	    (skb->inner_protocol_type != ENCAP_TYPE_ETHER ||
+ 	     skb->inner_protocol != htons(ETH_P_TEB) ||
+ 	     (skb_inner_mac_header(skb) - skb_transport_header(skb) !=
+ 	      sizeof(struct udphdr) + sizeof(struct vxlanhdr))))
+ 		return features & ~(NETIF_F_ALL_CSUM | NETIF_F_GSO_MASK);
+ 
+ 	return features;
+ }
++>>>>>>> af33c1adae1e (vxlan: Eliminate dependency on UDP socket in transmit path)
  
  /* IP header + UDP + VXLAN + Ethernet header */
  #define VXLAN_HEADROOM (20 + 8 + 8 + 14)
diff --cc net/openvswitch/vport-vxlan.c
index 64e0d2e57017,3cc983bf444a..000000000000
--- a/net/openvswitch/vport-vxlan.c
+++ b/net/openvswitch/vport-vxlan.c
@@@ -170,18 -246,21 +170,25 @@@ static int vxlan_tnl_send(struct vport 
  	df = tun_key->tun_flags & TUNNEL_DONT_FRAGMENT ?
  		htons(IP_DF) : 0;
  
 -	skb->ignore_df = 1;
 +	skb->local_df = 1;
  
  	src_port = udp_flow_src_port(net, skb, 0, 0, true);
 -	md.vni = htonl(be64_to_cpu(tun_key->tun_id) << 8);
 -	md.gbp = vxlan_ext_gbp(skb);
  
++<<<<<<< HEAD
 +	err = vxlan_xmit_skb(net, vxlan_port->vs, rt, skb,
 +			     fl.saddr, tun_key->ipv4_dst,
 +			     tun_key->ipv4_tos, tun_key->ipv4_ttl, df,
 +			     src_port, dst_port,
 +			     htonl(be64_to_cpu(tun_key->tun_id) << 8));
++=======
+ 	err = vxlan_xmit_skb(rt, skb, fl.saddr, tun_key->ipv4_dst,
+ 			     tun_key->ipv4_tos, tun_key->ipv4_ttl, df,
+ 			     src_port, dst_port,
+ 			     &md, false, vxlan_port->exts);
++>>>>>>> af33c1adae1e (vxlan: Eliminate dependency on UDP socket in transmit path)
  	if (err < 0)
  		ip_rt_put(rt);
 -	return err;
  error:
 -	kfree_skb(skb);
  	return err;
  }
  
* Unmerged path drivers/net/vxlan.c
* Unmerged path include/net/vxlan.h
* Unmerged path net/openvswitch/vport-vxlan.c
