KVM: x86: directly use kvm_make_request again

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [kvm] x86: directly use kvm_make_request again (Bandan Das) [1209995]
Rebuild_FUZZ: 94.12%
commit-author Liang Chen <liangchen.linux@gmail.com>
commit 77c3913b74212a86027d311f5e81625736816620
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/77c3913b.failed

A one-line wrapper around kvm_make_request is not particularly
useful. Replace kvm_mmu_flush_tlb() with kvm_make_request().

	Signed-off-by: Liang Chen <liangchen.linux@gmail.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 77c3913b74212a86027d311f5e81625736816620)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/mmu.c
diff --cc arch/x86/kvm/mmu.c
index 9db8bda172f9,045d592af1dd..000000000000
--- a/arch/x86/kvm/mmu.c
+++ b/arch/x86/kvm/mmu.c
@@@ -3444,13 -3444,6 +3444,16 @@@ static void nonpaging_init_context(stru
  	context->nx = false;
  }
  
++<<<<<<< HEAD
 +void kvm_mmu_flush_tlb(struct kvm_vcpu *vcpu)
 +{
 +	++vcpu->stat.tlb_flush;
 +	kvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);
 +}
 +EXPORT_SYMBOL_GPL(kvm_mmu_flush_tlb);
 +
++=======
++>>>>>>> 77c3913b7421 (KVM: x86: directly use kvm_make_request again)
  void kvm_mmu_new_cr3(struct kvm_vcpu *vcpu)
  {
  	mmu_free_roots(vcpu);
diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 4aa7dcdeeccd..2ede535c3b3a 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -921,7 +921,6 @@ void kvm_inject_nmi(struct kvm_vcpu *vcpu);
 
 int fx_init(struct kvm_vcpu *vcpu);
 
-void kvm_mmu_flush_tlb(struct kvm_vcpu *vcpu);
 void kvm_mmu_pte_write(struct kvm_vcpu *vcpu, gpa_t gpa,
 		       const u8 *new, int bytes);
 int kvm_mmu_unprotect_page(struct kvm *kvm, gfn_t gfn);
* Unmerged path arch/x86/kvm/mmu.c
diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c
index 7150bb3fec4d..78d367081e01 100644
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@ -6722,7 +6722,7 @@ static int handle_invept(struct kvm_vcpu *vcpu)
 	switch (type) {
 	case VMX_EPT_EXTENT_GLOBAL:
 		kvm_mmu_sync_roots(vcpu);
-		kvm_mmu_flush_tlb(vcpu);
+		kvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);
 		nested_vmx_succeed(vcpu);
 		break;
 	default:
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index a1a351c51f69..b6abed7f22fd 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -729,7 +729,7 @@ int kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)
 {
 	if (cr3 == kvm_read_cr3(vcpu) && !pdptrs_changed(vcpu)) {
 		kvm_mmu_sync_roots(vcpu);
-		kvm_mmu_flush_tlb(vcpu);
+		kvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);
 		return 0;
 	}
 
