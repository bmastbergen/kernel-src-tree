vti6: Update the ipv6 side to use its own receive hook.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] vti6: Update the ipv6 side to use its own receive hook (Alexander Duyck) [1129761]
Rebuild_FUZZ: 99.08%
commit-author Steffen Klassert <steffen.klassert@secunet.com>
commit fa9ad96d4905c3e2013bcce18c104108275c4c08
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/fa9ad96d.failed

With this patch, vti6 uses the IPsec protocol multiplexer to
register its own receive side hooks for ESP, AH and IPCOMP.

Vti6 now does the following on receive side:

1. Do an input policy check for the IPsec packet we received.
   This is required because this packet could be already
   prosecces by IPsec, so an inbuond policy check is needed.

2. Mark the packet with the i_key. The policy and the state
   must match this key now. Policy and state belong to the vti
   namespace and policy enforcement is done at the further layers.

3. Call the generic xfrm layer to do decryption and decapsulation.

4. Wait for a callback from the xfrm layer to properly clean the
   skb to not leak informations on namespace transitions and
    update the device statistics.

On transmit side:

1. Mark the packet with the o_key. The policy and the state
   must match this key now.

2. Do a xfrm_lookup on the original packet with the mark applied.

3. Check if we got an IPsec route.

4. Clean the skb to not leak informations on namespace
   transitions.

5. Attach the dst_enty we got from the xfrm_lookup to the skb.

6. Call dst_output to do the IPsec processing.

7. Do the device statistics.

	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit fa9ad96d4905c3e2013bcce18c104108275c4c08)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_vti.c
diff --cc net/ipv6/ip6_vti.c
index fc1f878fa976,226854a3c392..000000000000
--- a/net/ipv6/ip6_vti.c
+++ b/net/ipv6/ip6_vti.c
@@@ -288,11 -287,8 +288,13 @@@ static int vti6_rcv(struct sk_buff *skb
  	const struct ipv6hdr *ipv6h = ipv6_hdr(skb);
  
  	rcu_read_lock();
- 
  	if ((t = vti6_tnl_lookup(dev_net(skb->dev), &ipv6h->saddr,
  				 &ipv6h->daddr)) != NULL) {
++<<<<<<< HEAD
 +		struct pcpu_tstats *tstats;
 +
++=======
++>>>>>>> fa9ad96d4905 (vti6: Update the ipv6 side to use its own receive hook.)
  		if (t->parms.proto != IPPROTO_IPV6 && t->parms.proto != 0) {
  			rcu_read_unlock();
  			goto discard;
* Unmerged path net/ipv6/ip6_vti.c
