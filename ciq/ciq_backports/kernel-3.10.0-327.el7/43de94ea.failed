CIFS: Separate writing from iovec write

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Pavel Shilovsky <pshilovsky@samba.org>
commit 43de94eadf0ceda54509335343bdc1349a2c5ab3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/43de94ea.failed

	Reviewed-by: Shirish Pargaonkar <spargaonkar@suse.com>
	Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
	Signed-off-by: Steve French <smfrench@gmail.com>
(cherry picked from commit 43de94eadf0ceda54509335343bdc1349a2c5ab3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/file.c
diff --cc fs/cifs/file.c
index 6b4ebc406ff2,666069811ab8..000000000000
--- a/fs/cifs/file.c
+++ b/fs/cifs/file.c
@@@ -2427,41 -2423,59 +2427,97 @@@ cifs_uncached_retry_writev(struct cifs_
  	return rc;
  }
  
++<<<<<<< HEAD
 +static ssize_t
 +cifs_iovec_write(struct file *file, const struct iovec *iov,
 +		 unsigned long nr_segs, loff_t *poffset)
 +{
 +	unsigned long nr_pages, i;
 +	size_t bytes, copied, len, cur_len;
 +	ssize_t total_written = 0;
 +	loff_t offset;
 +	struct iov_iter it;
 +	struct cifsFileInfo *open_file;
 +	struct cifs_tcon *tcon;
 +	struct cifs_sb_info *cifs_sb;
 +	struct cifs_writedata *wdata, *tmp;
 +	struct list_head wdata_list;
 +	int rc;
 +	pid_t pid;
 +
 +	len = iov_length(iov, nr_segs);
 +	if (!len)
 +		return 0;
 +
 +	rc = generic_write_checks(file, poffset, &len, 0);
 +	if (rc)
 +		return rc;
 +
 +	INIT_LIST_HEAD(&wdata_list);
 +	cifs_sb = CIFS_SB(file->f_path.dentry->d_sb);
 +	open_file = file->private_data;
 +	tcon = tlink_tcon(open_file->tlink);
 +
 +	if (!tcon->ses->server->ops->async_writev)
 +		return -ENOSYS;
 +
 +	offset = *poffset;
 +
++=======
+ static int
+ wdata_fill_from_iovec(struct cifs_writedata *wdata, struct iov_iter *from,
+ 		      size_t *len, unsigned long *num_pages)
+ {
+ 	size_t save_len, copied, bytes, cur_len = *len;
+ 	unsigned long i, nr_pages = *num_pages;
+ 
+ 	save_len = cur_len;
+ 	for (i = 0; i < nr_pages; i++) {
+ 		bytes = min_t(const size_t, cur_len, PAGE_SIZE);
+ 		copied = copy_page_from_iter(wdata->pages[i], 0, bytes, from);
+ 		cur_len -= copied;
+ 		/*
+ 		 * If we didn't copy as much as we expected, then that
+ 		 * may mean we trod into an unmapped area. Stop copying
+ 		 * at that point. On the next pass through the big
+ 		 * loop, we'll likely end up getting a zero-length
+ 		 * write and bailing out of it.
+ 		 */
+ 		if (copied < bytes)
+ 			break;
+ 	}
+ 	cur_len = save_len - cur_len;
+ 	*len = cur_len;
+ 
+ 	/*
+ 	 * If we have no data to send, then that probably means that
+ 	 * the copy above failed altogether. That's most likely because
+ 	 * the address in the iovec was bogus. Return -EFAULT and let
+ 	 * the caller free anything we allocated and bail out.
+ 	 */
+ 	if (!cur_len)
+ 		return -EFAULT;
+ 
+ 	/*
+ 	 * i + 1 now represents the number of pages we actually used in
+ 	 * the copy phase above.
+ 	 */
+ 	*num_pages = i + 1;
+ 	return 0;
+ }
+ 
+ static int
+ cifs_write_from_iter(loff_t offset, size_t len, struct iov_iter *from,
+ 		     struct cifsFileInfo *open_file,
+ 		     struct cifs_sb_info *cifs_sb, struct list_head *wdata_list)
+ {
+ 	int rc = 0;
+ 	size_t cur_len;
+ 	unsigned long nr_pages, num_pages, i;
+ 	struct cifs_writedata *wdata;
+ 	pid_t pid;
+ 
++>>>>>>> 43de94eadf0c (CIFS: Separate writing from iovec write)
  	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)
  		pid = open_file->pid;
  	else
* Unmerged path fs/cifs/file.c
