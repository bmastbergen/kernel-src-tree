IB/iser: Protect tasks cleanup in case IB device was already released

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [infiniband] iser: Protect tasks cleanup in case IB device was already released (Amir Vadai) [1164539]
Rebuild_FUZZ: 97.78%
commit-author Sagi Grimberg <sagig@mellanox.com>
commit 3a940daf6fa105d28b69cf3b7a3739a3777f4185
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/3a940daf.failed

Bailout in case a task cleanup (iscsi_iser_cleanup_task) is called
after the IB device was removed (DEVICE_REMOVAL CM event).  We also
call iscsi_conn_stop with a lock taken to prevent DEVICE_REMOVAL and
tasks cleanup from racing.

	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Ariel Nahum <arieln@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Roland Dreier <roland@purestorage.com>
(cherry picked from commit 3a940daf6fa105d28b69cf3b7a3739a3777f4185)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/iser/iscsi_iser.c
diff --cc drivers/infiniband/ulp/iser/iscsi_iser.c
index 93ce62fe1594,81d69a30bcca..000000000000
--- a/drivers/infiniband/ulp/iser/iscsi_iser.c
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.c
@@@ -290,9 -290,13 +290,13 @@@ static void iscsi_iser_cleanup_task(str
  {
  	struct iscsi_iser_task *iser_task = task->dd_data;
  	struct iser_tx_desc    *tx_desc   = &iser_task->desc;
 -	struct iser_conn       *iser_conn	  = task->conn->dd_data;
 -	struct iser_device *device = iser_conn->ib_conn.device;
 +	struct iser_conn       *ib_conn	  = task->conn->dd_data;
 +	struct iser_device     *device	  = ib_conn->device;
  
+ 	/* DEVICE_REMOVAL event might have already released the device */
+ 	if (!device)
+ 		return;
+ 
  	ib_dma_unmap_single(device->ib_device,
  		tx_desc->dma_addr, ISER_HEADERS_LEN, DMA_TO_DEVICE);
  
@@@ -404,18 -408,27 +408,38 @@@ static voi
  iscsi_iser_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)
  {
  	struct iscsi_conn *conn = cls_conn->dd_data;
 -	struct iser_conn *iser_conn = conn->dd_data;
 +	struct iser_conn *ib_conn = conn->dd_data;
  
++<<<<<<< HEAD
 +	iser_dbg("stopping iscsi_conn: %p, ib_conn: %p\n", conn, ib_conn);
 +	iscsi_conn_stop(cls_conn, flag);
++=======
+ 	iser_dbg("stopping iscsi_conn: %p, iser_conn: %p\n", conn, iser_conn);
++>>>>>>> 3a940daf6fa1 (IB/iser: Protect tasks cleanup in case IB device was already released)
  
  	/*
  	 * Userspace may have goofed up and not bound the connection or
  	 * might have only partially setup the connection.
  	 */
++<<<<<<< HEAD
 +	if (ib_conn) {
 +		conn->dd_data = NULL;
 +		complete(&ib_conn->stop_completion);
++=======
+ 	if (iser_conn) {
+ 		mutex_lock(&iser_conn->state_mutex);
+ 		iscsi_conn_stop(cls_conn, flag);
+ 		iser_conn_terminate(iser_conn);
+ 
+ 		/* unbind */
+ 		iser_conn->iscsi_conn = NULL;
+ 		conn->dd_data = NULL;
+ 
+ 		complete(&iser_conn->stop_completion);
+ 		mutex_unlock(&iser_conn->state_mutex);
+ 	} else {
+ 		iscsi_conn_stop(cls_conn, flag);
++>>>>>>> 3a940daf6fa1 (IB/iser: Protect tasks cleanup in case IB device was already released)
  	}
  }
  
* Unmerged path drivers/infiniband/ulp/iser/iscsi_iser.c
