dev: introduce dev_get_iflink()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] introduce dev_get_iflink() (Jiri Benc) [1210260]
Rebuild_FUZZ: 91.23%
commit-author Nicolas Dichtel <nicolas.dichtel@6wind.com>
commit a54acb3a6f853e8394c4cb7b6a4d93c88f13eefd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/a54acb3a.failed

The goal of this patch is to prepare the removal of the iflink field. It
introduces a new ndo function, which will be implemented by virtual interfaces.

There is no functional change into this patch. All readers of iflink field
now call dev_get_iflink().

	Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a54acb3a6f853e8394c4cb7b6a4d93c88f13eefd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ipvlan/ipvlan_core.c
#	include/linux/netdevice.h
#	net/batman-adv/hard-interface.c
#	net/core/net-sysfs.c
diff --cc include/linux/netdevice.h
index 80813de117ba,788eb7a622ad..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -963,6 -998,40 +963,43 @@@ struct netdev_phys_port_id 
   *	Called by vxlan to notify the driver about a UDP port and socket
   *	address family that vxlan is not listening to anymore. The operation
   *	is protected by the vxlan_net->sock_lock.
++<<<<<<< HEAD
++=======
+  *
+  * void* (*ndo_dfwd_add_station)(struct net_device *pdev,
+  *				 struct net_device *dev)
+  *	Called by upper layer devices to accelerate switching or other
+  *	station functionality into hardware. 'pdev is the lowerdev
+  *	to use for the offload and 'dev' is the net device that will
+  *	back the offload. Returns a pointer to the private structure
+  *	the upper layer will maintain.
+  * void (*ndo_dfwd_del_station)(struct net_device *pdev, void *priv)
+  *	Called by upper layer device to delete the station created
+  *	by 'ndo_dfwd_add_station'. 'pdev' is the net device backing
+  *	the station and priv is the structure returned by the add
+  *	operation.
+  * netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff *skb,
+  *				      struct net_device *dev,
+  *				      void *priv);
+  *	Callback to use for xmit over the accelerated station. This
+  *	is used in place of ndo_start_xmit on accelerated net
+  *	devices.
+  * netdev_features_t (*ndo_features_check) (struct sk_buff *skb,
+  *					    struct net_device *dev
+  *					    netdev_features_t features);
+  *	Called by core transmit path to determine if device is capable of
+  *	performing offload operations on a given packet. This is to give
+  *	the device an opportunity to implement any restrictions that cannot
+  *	be otherwise expressed by feature flags. The check is called with
+  *	the set of features that the stack has calculated and it returns
+  *	those the driver believes to be appropriate.
+  * int (*ndo_set_tx_maxrate)(struct net_device *dev,
+  *			     int queue_index, u32 maxrate);
+  *	Called when a user wants to set a max-rate limitation of specific
+  *	TX queue.
+  * int (*ndo_get_iflink)(const struct net_device *dev);
+  *	Called to get the iflink value of this device.
++>>>>>>> a54acb3a6f85 (dev: introduce dev_get_iflink())
   */
  struct net_device_ops {
  	int			(*ndo_init)(struct net_device *dev);
@@@ -1100,36 -1178,315 +1137,55 @@@
  						      sa_family_t sa_family,
  						      __be16 port);
  
++<<<<<<< HEAD
 +	/* RHEL SPECIFIC
 +	 *
 +	 * The following padding has been inserted before ABI freeze to
 +	 * allow extending the structure while preserve ABI. Feel free
 +	 * to replace reserved slots with required structure field
 +	 * additions of your backport.
 +	 */
 +	RH_KABI_RESERVE_P(1)
 +	RH_KABI_RESERVE_P(2)
 +	RH_KABI_RESERVE_P(3)
 +	RH_KABI_RESERVE_P(4)
 +	RH_KABI_RESERVE_P(5)
 +	RH_KABI_RESERVE_P(6)
 +	RH_KABI_RESERVE_P(7)
 +	RH_KABI_RESERVE_P(8)
 +	RH_KABI_RESERVE_P(9)
 +	RH_KABI_RESERVE_P(10)
 +	RH_KABI_RESERVE_P(11)
 +	RH_KABI_RESERVE_P(12)
 +	RH_KABI_RESERVE_P(13)
 +	RH_KABI_RESERVE_P(14)
 +	RH_KABI_RESERVE_P(15)
 +	RH_KABI_RESERVE_P(16)
++=======
+ 	void*			(*ndo_dfwd_add_station)(struct net_device *pdev,
+ 							struct net_device *dev);
+ 	void			(*ndo_dfwd_del_station)(struct net_device *pdev,
+ 							void *priv);
+ 
+ 	netdev_tx_t		(*ndo_dfwd_start_xmit) (struct sk_buff *skb,
+ 							struct net_device *dev,
+ 							void *priv);
+ 	int			(*ndo_get_lock_subclass)(struct net_device *dev);
+ 	netdev_features_t	(*ndo_features_check) (struct sk_buff *skb,
+ 						       struct net_device *dev,
+ 						       netdev_features_t features);
+ 	int			(*ndo_set_tx_maxrate)(struct net_device *dev,
+ 						      int queue_index,
+ 						      u32 maxrate);
+ 	int			(*ndo_get_iflink)(const struct net_device *dev);
++>>>>>>> a54acb3a6f85 (dev: introduce dev_get_iflink())
  };
  
 -/**
 - * enum net_device_priv_flags - &struct net_device priv_flags
 - *
 - * These are the &struct net_device, they are only set internally
 - * by drivers and used in the kernel. These flags are invisible to
 - * userspace, this means that the order of these flags can change
 - * during any kernel release.
 - *
 - * You should have a pretty good reason to be extending these flags.
 - *
 - * @IFF_802_1Q_VLAN: 802.1Q VLAN device
 - * @IFF_EBRIDGE: Ethernet bridging device
 - * @IFF_SLAVE_INACTIVE: bonding slave not the curr. active
 - * @IFF_MASTER_8023AD: bonding master, 802.3ad
 - * @IFF_MASTER_ALB: bonding master, balance-alb
 - * @IFF_BONDING: bonding master or slave
 - * @IFF_SLAVE_NEEDARP: need ARPs for validation
 - * @IFF_ISATAP: ISATAP interface (RFC4214)
 - * @IFF_MASTER_ARPMON: bonding master, ARP mon in use
 - * @IFF_WAN_HDLC: WAN HDLC device
 - * @IFF_XMIT_DST_RELEASE: dev_hard_start_xmit() is allowed to
 - *	release skb->dst
 - * @IFF_DONT_BRIDGE: disallow bridging this ether dev
 - * @IFF_DISABLE_NETPOLL: disable netpoll at run-time
 - * @IFF_MACVLAN_PORT: device used as macvlan port
 - * @IFF_BRIDGE_PORT: device used as bridge port
 - * @IFF_OVS_DATAPATH: device used as Open vSwitch datapath port
 - * @IFF_TX_SKB_SHARING: The interface supports sharing skbs on transmit
 - * @IFF_UNICAST_FLT: Supports unicast filtering
 - * @IFF_TEAM_PORT: device used as team port
 - * @IFF_SUPP_NOFCS: device supports sending custom FCS
 - * @IFF_LIVE_ADDR_CHANGE: device supports hardware address
 - *	change when it's running
 - * @IFF_MACVLAN: Macvlan device
 - */
 -enum netdev_priv_flags {
 -	IFF_802_1Q_VLAN			= 1<<0,
 -	IFF_EBRIDGE			= 1<<1,
 -	IFF_SLAVE_INACTIVE		= 1<<2,
 -	IFF_MASTER_8023AD		= 1<<3,
 -	IFF_MASTER_ALB			= 1<<4,
 -	IFF_BONDING			= 1<<5,
 -	IFF_SLAVE_NEEDARP		= 1<<6,
 -	IFF_ISATAP			= 1<<7,
 -	IFF_MASTER_ARPMON		= 1<<8,
 -	IFF_WAN_HDLC			= 1<<9,
 -	IFF_XMIT_DST_RELEASE		= 1<<10,
 -	IFF_DONT_BRIDGE			= 1<<11,
 -	IFF_DISABLE_NETPOLL		= 1<<12,
 -	IFF_MACVLAN_PORT		= 1<<13,
 -	IFF_BRIDGE_PORT			= 1<<14,
 -	IFF_OVS_DATAPATH		= 1<<15,
 -	IFF_TX_SKB_SHARING		= 1<<16,
 -	IFF_UNICAST_FLT			= 1<<17,
 -	IFF_TEAM_PORT			= 1<<18,
 -	IFF_SUPP_NOFCS			= 1<<19,
 -	IFF_LIVE_ADDR_CHANGE		= 1<<20,
 -	IFF_MACVLAN			= 1<<21,
 -	IFF_XMIT_DST_RELEASE_PERM	= 1<<22,
 -	IFF_IPVLAN_MASTER		= 1<<23,
 -	IFF_IPVLAN_SLAVE		= 1<<24,
 -};
 -
 -#define IFF_802_1Q_VLAN			IFF_802_1Q_VLAN
 -#define IFF_EBRIDGE			IFF_EBRIDGE
 -#define IFF_SLAVE_INACTIVE		IFF_SLAVE_INACTIVE
 -#define IFF_MASTER_8023AD		IFF_MASTER_8023AD
 -#define IFF_MASTER_ALB			IFF_MASTER_ALB
 -#define IFF_BONDING			IFF_BONDING
 -#define IFF_SLAVE_NEEDARP		IFF_SLAVE_NEEDARP
 -#define IFF_ISATAP			IFF_ISATAP
 -#define IFF_MASTER_ARPMON		IFF_MASTER_ARPMON
 -#define IFF_WAN_HDLC			IFF_WAN_HDLC
 -#define IFF_XMIT_DST_RELEASE		IFF_XMIT_DST_RELEASE
 -#define IFF_DONT_BRIDGE			IFF_DONT_BRIDGE
 -#define IFF_DISABLE_NETPOLL		IFF_DISABLE_NETPOLL
 -#define IFF_MACVLAN_PORT		IFF_MACVLAN_PORT
 -#define IFF_BRIDGE_PORT			IFF_BRIDGE_PORT
 -#define IFF_OVS_DATAPATH		IFF_OVS_DATAPATH
 -#define IFF_TX_SKB_SHARING		IFF_TX_SKB_SHARING
 -#define IFF_UNICAST_FLT			IFF_UNICAST_FLT
 -#define IFF_TEAM_PORT			IFF_TEAM_PORT
 -#define IFF_SUPP_NOFCS			IFF_SUPP_NOFCS
 -#define IFF_LIVE_ADDR_CHANGE		IFF_LIVE_ADDR_CHANGE
 -#define IFF_MACVLAN			IFF_MACVLAN
 -#define IFF_XMIT_DST_RELEASE_PERM	IFF_XMIT_DST_RELEASE_PERM
 -#define IFF_IPVLAN_MASTER		IFF_IPVLAN_MASTER
 -#define IFF_IPVLAN_SLAVE		IFF_IPVLAN_SLAVE
 -
 -/**
 - *	struct net_device - The DEVICE structure.
 - *		Actually, this whole structure is a big mistake.  It mixes I/O
 - *		data with strictly "high-level" data, and it has to know about
 - *		almost every data structure used in the INET module.
 - *
 - *	@name:	This is the first field of the "visible" part of this structure
 - *		(i.e. as seen by users in the "Space.c" file).  It is the name
 - *	 	of the interface.
 - *
 - *	@name_hlist: 	Device name hash chain, please keep it close to name[]
 - *	@ifalias:	SNMP alias
 - *	@mem_end:	Shared memory end
 - *	@mem_start:	Shared memory start
 - *	@base_addr:	Device I/O address
 - *	@irq:		Device IRQ number
 - *
 - *	@state:		Generic network queuing layer state, see netdev_state_t
 - *	@dev_list:	The global list of network devices
 - *	@napi_list:	List entry, that is used for polling napi devices
 - *	@unreg_list:	List entry, that is used, when we are unregistering the
 - *			device, see the function unregister_netdev
 - *	@close_list:	List entry, that is used, when we are closing the device
 - *
 - *	@adj_list:	Directly linked devices, like slaves for bonding
 - *	@all_adj_list:	All linked devices, *including* neighbours
 - *	@features:	Currently active device features
 - *	@hw_features:	User-changeable features
 - *
 - *	@wanted_features:	User-requested features
 - *	@vlan_features:		Mask of features inheritable by VLAN devices
 - *
 - *	@hw_enc_features:	Mask of features inherited by encapsulating devices
 - *				This field indicates what encapsulation
 - *				offloads the hardware is capable of doing,
 - *				and drivers will need to set them appropriately.
 - *
 - *	@mpls_features:	Mask of features inheritable by MPLS
 - *
 - *	@ifindex:	interface index
 - *	@iflink:	unique device identifier
 - *
 - *	@stats:		Statistics struct, which was left as a legacy, use
 - *			rtnl_link_stats64 instead
 - *
 - *	@rx_dropped:	Dropped packets by core network,
 - *			do not use this in drivers
 - *	@tx_dropped:	Dropped packets by core network,
 - *			do not use this in drivers
 - *
 - *	@carrier_changes:	Stats to monitor carrier on<->off transitions
 - *
 - *	@wireless_handlers:	List of functions to handle Wireless Extensions,
 - *				instead of ioctl,
 - *				see <net/iw_handler.h> for details.
 - *	@wireless_data:	Instance data managed by the core of wireless extensions
 - *
 - *	@netdev_ops:	Includes several pointers to callbacks,
 - *			if one wants to override the ndo_*() functions
 - *	@ethtool_ops:	Management operations
 - *	@header_ops:	Includes callbacks for creating,parsing,caching,etc
 - *			of Layer 2 headers.
 - *
 - *	@flags:		Interface flags (a la BSD)
 - *	@priv_flags:	Like 'flags' but invisible to userspace,
 - *			see if.h for the definitions
 - *	@gflags:	Global flags ( kept as legacy )
 - *	@padded:	How much padding added by alloc_netdev()
 - *	@operstate:	RFC2863 operstate
 - *	@link_mode:	Mapping policy to operstate
 - *	@if_port:	Selectable AUI, TP, ...
 - *	@dma:		DMA channel
 - *	@mtu:		Interface MTU value
 - *	@type:		Interface hardware type
 - *	@hard_header_len: Hardware header length
 - *
 - *	@needed_headroom: Extra headroom the hardware may need, but not in all
 - *			  cases can this be guaranteed
 - *	@needed_tailroom: Extra tailroom the hardware may need, but not in all
 - *			  cases can this be guaranteed. Some cases also use
 - *			  LL_MAX_HEADER instead to allocate the skb
 - *
 - *	interface address info:
 - *
 - * 	@perm_addr:		Permanent hw address
 - * 	@addr_assign_type:	Hw address assignment type
 - * 	@addr_len:		Hardware address length
 - * 	@neigh_priv_len;	Used in neigh_alloc(),
 - * 				initialized only in atm/clip.c
 - * 	@dev_id:		Used to differentiate devices that share
 - * 				the same link layer address
 - * 	@dev_port:		Used to differentiate devices that share
 - * 				the same function
 - *	@addr_list_lock:	XXX: need comments on this one
 - *	@uc:			unicast mac addresses
 - *	@mc:			multicast mac addresses
 - *	@dev_addrs:		list of device hw addresses
 - *	@queues_kset:		Group of all Kobjects in the Tx and RX queues
 - *	@uc_promisc:		Counter, that indicates, that promiscuous mode
 - *				has been enabled due to the need to listen to
 - *				additional unicast addresses in a device that
 - *				does not implement ndo_set_rx_mode()
 - *	@promiscuity:		Number of times, the NIC is told to work in
 - *				Promiscuous mode, if it becomes 0 the NIC will
 - *				exit from working in Promiscuous mode
 - *	@allmulti:		Counter, enables or disables allmulticast mode
 - *
 - *	@vlan_info:	VLAN info
 - *	@dsa_ptr:	dsa specific data
 - *	@tipc_ptr:	TIPC specific data
 - *	@atalk_ptr:	AppleTalk link
 - *	@ip_ptr:	IPv4 specific data
 - *	@dn_ptr:	DECnet specific data
 - *	@ip6_ptr:	IPv6 specific data
 - *	@ax25_ptr:	AX.25 specific data
 - *	@ieee80211_ptr:	IEEE 802.11 specific data, assign before registering
 - *
 - *	@last_rx:	Time of last Rx
 - *	@dev_addr:	Hw address (before bcast,
 - *			because most packets are unicast)
 - *
 - *	@_rx:			Array of RX queues
 - *	@num_rx_queues:		Number of RX queues
 - *				allocated at register_netdev() time
 - *	@real_num_rx_queues: 	Number of RX queues currently active in device
 - *
 - *	@rx_handler:		handler for received packets
 - *	@rx_handler_data: 	XXX: need comments on this one
 - *	@ingress_queue:		XXX: need comments on this one
 - *	@broadcast:		hw bcast address
 - *
 - *	@_tx:			Array of TX queues
 - *	@num_tx_queues:		Number of TX queues allocated at alloc_netdev_mq() time
 - *	@real_num_tx_queues: 	Number of TX queues currently active in device
 - *	@qdisc:			Root qdisc from userspace point of view
 - *	@tx_queue_len:		Max frames per queue allowed
 - *	@tx_global_lock: 	XXX: need comments on this one
 - *
 - *	@xps_maps:	XXX: need comments on this one
 - *
 - *	@rx_cpu_rmap:	CPU reverse-mapping for RX completion interrupts,
 - *			indexed by RX queue number. Assigned by driver.
 - *			This must only be set if the ndo_rx_flow_steer
 - *			operation is defined
 - *
 - *	@trans_start:		Time (in jiffies) of last Tx
 - *	@watchdog_timeo:	Represents the timeout that is used by
 - *				the watchdog ( see dev_watchdog() )
 - *	@watchdog_timer:	List of timers
 - *
 - *	@pcpu_refcnt:		Number of references to this device
 - *	@todo_list:		Delayed register/unregister
 - *	@index_hlist:		Device index hash chain
 - *	@link_watch_list:	XXX: need comments on this one
 - *
 - *	@reg_state:		Register/unregister state machine
 - *	@dismantle:		Device is going to be freed
 - *	@rtnl_link_state:	This enum represents the phases of creating
 - *				a new link
 - *
 - *	@destructor:		Called from unregister,
 - *				can be used to call free_netdev
 - *	@npinfo:		XXX: need comments on this one
 - * 	@nd_net:		Network namespace this network device is inside
 - *
 - * 	@ml_priv:	Mid-layer private
 - * 	@lstats:	Loopback statistics
 - * 	@tstats:	Tunnel statistics
 - * 	@dstats:	Dummy statistics
 - * 	@vstats:	Virtual ethernet statistics
 - *
 - *	@garp_port:	GARP
 - *	@mrp_port:	MRP
 - *
 - *	@dev:		Class/net/name entry
 - *	@sysfs_groups:	Space for optional device, statistics and wireless
 - *			sysfs groups
 - *
 - *	@sysfs_rx_queue_group:	Space for optional per-rx queue attributes
 - *	@rtnl_link_ops:	Rtnl_link_ops
 - *
 - *	@gso_max_size:	Maximum size of generic segmentation offload
 - *	@gso_max_segs:	Maximum number of segments that can be passed to the
 - *			NIC for GSO
 - *	@gso_min_segs:	Minimum number of segments that can be passed to the
 - *			NIC for GSO
 - *
 - *	@dcbnl_ops:	Data Center Bridging netlink ops
 - *	@num_tc:	Number of traffic classes in the net device
 - *	@tc_to_txq:	XXX: need comments on this one
 - *	@prio_tc_map	XXX: need comments on this one
 - *
 - *	@fcoe_ddp_xid:	Max exchange id for FCoE LRO by ddp
 - *
 - *	@priomap:	XXX: need comments on this one
 - *	@phydev:	Physical device may attach itself
 - *			for hardware timestamping
 - *
 - *	@qdisc_tx_busylock:	XXX: need comments on this one
 - *
 - *	@group:		The group, that the device belongs to
 - *	@pm_qos_req:	Power Management QoS object
 +/*
 + *	The DEVICE structure.
 + *	Actually, this whole structure is a big mistake.  It mixes I/O
 + *	data with strictly "high-level" data, and it has to know about
 + *	almost every data structure used in the INET module.
   *
   *	FIXME: cleanup struct net_device such that network protocol info
   *	moves out.
@@@ -1817,34 -2140,35 +1873,54 @@@ static inline struct net_device *first_
  	return lh == &net->dev_base_head ? NULL : net_device_entry(lh);
  }
  
 -int netdev_boot_setup_check(struct net_device *dev);
 -unsigned long netdev_boot_base(const char *prefix, int unit);
 -struct net_device *dev_getbyhwaddr_rcu(struct net *net, unsigned short type,
 -				       const char *hwaddr);
 -struct net_device *dev_getfirstbyhwtype(struct net *net, unsigned short type);
 -struct net_device *__dev_getfirstbyhwtype(struct net *net, unsigned short type);
 -void dev_add_pack(struct packet_type *pt);
 -void dev_remove_pack(struct packet_type *pt);
 -void __dev_remove_pack(struct packet_type *pt);
 -void dev_add_offload(struct packet_offload *po);
 -void dev_remove_offload(struct packet_offload *po);
 -
 +extern int 			netdev_boot_setup_check(struct net_device *dev);
 +extern unsigned long		netdev_boot_base(const char *prefix, int unit);
 +extern struct net_device *dev_getbyhwaddr_rcu(struct net *net, unsigned short type,
 +					      const char *hwaddr);
 +extern struct net_device *dev_getfirstbyhwtype(struct net *net, unsigned short type);
 +extern struct net_device *__dev_getfirstbyhwtype(struct net *net, unsigned short type);
 +extern void		dev_add_pack(struct packet_type *pt);
 +extern void		dev_remove_pack(struct packet_type *pt);
 +extern void		__dev_remove_pack(struct packet_type *pt);
 +extern void		dev_add_offload(struct packet_offload *po);
 +extern void		dev_remove_offload(struct packet_offload *po);
 +extern void		__dev_remove_offload(struct packet_offload *po);
 +
++<<<<<<< HEAD
 +extern struct net_device	*dev_get_by_flags_rcu(struct net *net, unsigned short flags,
 +						      unsigned short mask);
 +extern struct net_device	*dev_get_by_name(struct net *net, const char *name);
 +extern struct net_device	*dev_get_by_name_rcu(struct net *net, const char *name);
 +extern struct net_device	*__dev_get_by_name(struct net *net, const char *name);
 +extern int		dev_alloc_name(struct net_device *dev, const char *name);
 +extern int		dev_open(struct net_device *dev);
 +extern int		dev_close(struct net_device *dev);
 +extern void		dev_disable_lro(struct net_device *dev);
 +extern int		dev_loopback_xmit(struct sk_buff *newskb);
 +extern int		dev_queue_xmit(struct sk_buff *skb);
 +extern int		register_netdevice(struct net_device *dev);
 +extern void		unregister_netdevice_queue(struct net_device *dev,
 +						   struct list_head *head);
 +extern void		unregister_netdevice_many(struct list_head *head);
++=======
+ int dev_get_iflink(const struct net_device *dev);
+ struct net_device *__dev_get_by_flags(struct net *net, unsigned short flags,
+ 				      unsigned short mask);
+ struct net_device *dev_get_by_name(struct net *net, const char *name);
+ struct net_device *dev_get_by_name_rcu(struct net *net, const char *name);
+ struct net_device *__dev_get_by_name(struct net *net, const char *name);
+ int dev_alloc_name(struct net_device *dev, const char *name);
+ int dev_open(struct net_device *dev);
+ int dev_close(struct net_device *dev);
+ int dev_close_many(struct list_head *head, bool unlink);
+ void dev_disable_lro(struct net_device *dev);
+ int dev_loopback_xmit(struct sk_buff *newskb);
+ int dev_queue_xmit(struct sk_buff *skb);
+ int dev_queue_xmit_accel(struct sk_buff *skb, void *accel_priv);
+ int register_netdevice(struct net_device *dev);
+ void unregister_netdevice_queue(struct net_device *dev, struct list_head *head);
+ void unregister_netdevice_many(struct list_head *head);
++>>>>>>> a54acb3a6f85 (dev: introduce dev_get_iflink())
  static inline void unregister_netdevice(struct net_device *dev)
  {
  	unregister_netdevice_queue(dev, NULL);
diff --cc net/batman-adv/hard-interface.c
index 522243aff2f3,baf1f9843f2c..000000000000
--- a/net/batman-adv/hard-interface.c
+++ b/net/batman-adv/hard-interface.c
@@@ -83,11 -83,12 +83,20 @@@ static bool batadv_is_on_batman_iface(c
  		return true;
  
  	/* no more parents..stop recursion */
++<<<<<<< HEAD
 +	if (net_dev->iflink == net_dev->ifindex)
 +		return false;
 +
 +	/* recurse over the parent device */
 +	parent_dev = dev_get_by_index(&init_net, net_dev->iflink);
++=======
+ 	if (dev_get_iflink(net_dev) == 0 ||
+ 	    dev_get_iflink(net_dev) == net_dev->ifindex)
+ 		return false;
+ 
+ 	/* recurse over the parent device */
+ 	parent_dev = __dev_get_by_index(&init_net, dev_get_iflink(net_dev));
++>>>>>>> a54acb3a6f85 (dev: introduce dev_get_iflink())
  	/* if we got a NULL parent_dev there is something broken.. */
  	if (WARN(!parent_dev, "Cannot find parent device"))
  		return false;
diff --cc net/core/net-sysfs.c
index 62086f24a037,4238d6da5c60..000000000000
--- a/net/core/net-sysfs.c
+++ b/net/core/net-sysfs.c
@@@ -112,6 -113,34 +111,37 @@@ NETDEVICE_SHOW_RO(ifindex, fmt_dec)
  NETDEVICE_SHOW_RO(type, fmt_dec);
  NETDEVICE_SHOW_RO(link_mode, fmt_dec);
  
++<<<<<<< HEAD
++=======
+ static ssize_t iflink_show(struct device *dev, struct device_attribute *attr,
+ 			   char *buf)
+ {
+ 	struct net_device *ndev = to_net_dev(dev);
+ 
+ 	return sprintf(buf, fmt_dec, dev_get_iflink(ndev));
+ }
+ static DEVICE_ATTR_RO(iflink);
+ 
+ static ssize_t format_name_assign_type(const struct net_device *dev, char *buf)
+ {
+ 	return sprintf(buf, fmt_dec, dev->name_assign_type);
+ }
+ 
+ static ssize_t name_assign_type_show(struct device *dev,
+ 				     struct device_attribute *attr,
+ 				     char *buf)
+ {
+ 	struct net_device *ndev = to_net_dev(dev);
+ 	ssize_t ret = -EINVAL;
+ 
+ 	if (ndev->name_assign_type != NET_NAME_UNKNOWN)
+ 		ret = netdev_show(dev, attr, buf, format_name_assign_type);
+ 
+ 	return ret;
+ }
+ static DEVICE_ATTR_RO(name_assign_type);
+ 
++>>>>>>> a54acb3a6f85 (dev: introduce dev_get_iflink())
  /* use same locking rules as GIFHWADDR ioctl's */
  static ssize_t address_show(struct device *dev, struct device_attribute *attr,
  			    char *buf)
* Unmerged path drivers/net/ipvlan/ipvlan_core.c
* Unmerged path drivers/net/ipvlan/ipvlan_core.c
* Unmerged path include/linux/netdevice.h
* Unmerged path net/batman-adv/hard-interface.c
diff --git a/net/bridge/br_netlink.c b/net/bridge/br_netlink.c
index 12e6d5e60e99..f29e43154600 100644
--- a/net/bridge/br_netlink.c
+++ b/net/bridge/br_netlink.c
@@ -106,8 +106,8 @@ static int br_fill_ifinfo(struct sk_buff *skb,
 	    nla_put_u8(skb, IFLA_OPERSTATE, operstate) ||
 	    (dev->addr_len &&
 	     nla_put(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr)) ||
-	    (dev->ifindex != dev->iflink &&
-	     nla_put_u32(skb, IFLA_LINK, dev->iflink)))
+	    (dev->ifindex != dev_get_iflink(dev) &&
+	     nla_put_u32(skb, IFLA_LINK, dev_get_iflink(dev))))
 		goto nla_put_failure;
 
 	if (event == RTM_NEWLINK && port) {
diff --git a/net/core/dev.c b/net/core/dev.c
index 1924c9647d47..bcba5f9393f8 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -649,6 +649,23 @@ __setup("netdev=", netdev_boot_setup);
 
 *******************************************************************************/
 
+/**
+ *	dev_get_iflink	- get 'iflink' value of a interface
+ *	@dev: targeted interface
+ *
+ *	Indicates the ifindex the interface is linked to.
+ *	Physical interfaces have the same 'ifindex' and 'iflink' values.
+ */
+
+int dev_get_iflink(const struct net_device *dev)
+{
+	if (dev->netdev_ops && dev->netdev_ops->ndo_get_iflink)
+		return dev->netdev_ops->ndo_get_iflink(dev);
+
+	return dev->iflink;
+}
+EXPORT_SYMBOL(dev_get_iflink);
+
 /**
  *	__dev_get_by_name	- find a device by its name
  *	@net: the applicable net namespace
@@ -5394,7 +5411,7 @@ int register_netdevice(struct net_device *dev)
 	else if (__dev_get_by_index(net, dev->ifindex))
 		goto err_uninit;
 
-	if (dev->iflink == -1)
+	if (dev_get_iflink(dev) == -1)
 		dev->iflink = dev->ifindex;
 
 	/* Transfer changeable features to wanted_features and enable
@@ -6099,7 +6116,7 @@ int dev_change_net_namespace(struct net_device *dev, struct net *net, const char
 
 	/* If there is an ifindex conflict assign a new one */
 	if (__dev_get_by_index(net, dev->ifindex)) {
-		int iflink = (dev->iflink == dev->ifindex);
+		int iflink = (dev_get_iflink(dev) == dev->ifindex);
 		dev->ifindex = dev_new_index(net);
 		if (iflink)
 			dev->iflink = dev->ifindex;
diff --git a/net/core/link_watch.c b/net/core/link_watch.c
index 8f82a5cc3851..43ab4f6c990b 100644
--- a/net/core/link_watch.c
+++ b/net/core/link_watch.c
@@ -40,7 +40,7 @@ static DEFINE_SPINLOCK(lweventlist_lock);
 static unsigned char default_operstate(const struct net_device *dev)
 {
 	if (!netif_carrier_ok(dev))
-		return (dev->ifindex != dev->iflink ?
+		return (dev->ifindex != dev_get_iflink(dev) ?
 			IF_OPER_LOWERLAYERDOWN : IF_OPER_DOWN);
 
 	if (netif_dormant(dev))
@@ -89,7 +89,7 @@ static bool linkwatch_urgent_event(struct net_device *dev)
 	if (!netif_running(dev))
 		return false;
 
-	if (dev->ifindex != dev->iflink)
+	if (dev->ifindex != dev_get_iflink(dev))
 		return true;
 
 	return netif_carrier_ok(dev) &&	qdisc_tx_changing(dev);
* Unmerged path net/core/net-sysfs.c
diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c
index 164916e79775..8eab3d6f293f 100644
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@ -943,8 +943,8 @@ static int rtnl_fill_ifinfo(struct sk_buff *skb, struct net_device *dev,
 #ifdef CONFIG_RPS
 	    nla_put_u32(skb, IFLA_NUM_RX_QUEUES, dev->num_rx_queues) ||
 #endif
-	    (dev->ifindex != dev->iflink &&
-	     nla_put_u32(skb, IFLA_LINK, dev->iflink)) ||
+	    (dev->ifindex != dev_get_iflink(dev) &&
+	     nla_put_u32(skb, IFLA_LINK, dev_get_iflink(dev))) ||
 	    (upper_dev &&
 	     nla_put_u32(skb, IFLA_MASTER, upper_dev->ifindex)) ||
 	    nla_put_u8(skb, IFLA_CARRIER, netif_carrier_ok(dev)) ||
@@ -2431,8 +2431,8 @@ int ndo_dflt_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq,
 	     nla_put_u32(skb, IFLA_MASTER, br_dev->ifindex)) ||
 	    (dev->addr_len &&
 	     nla_put(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr)) ||
-	    (dev->ifindex != dev->iflink &&
-	     nla_put_u32(skb, IFLA_LINK, dev->iflink)))
+	    (dev->ifindex != dev_get_iflink(dev) &&
+	     nla_put_u32(skb, IFLA_LINK, dev_get_iflink(dev))))
 		goto nla_put_failure;
 
 	br_afspec = nla_nest_start(skb, IFLA_AF_SPEC);
diff --git a/net/ipv4/ipmr.c b/net/ipv4/ipmr.c
index ab87d80f58e0..e4c0695921ff 100644
--- a/net/ipv4/ipmr.c
+++ b/net/ipv4/ipmr.c
@@ -800,7 +800,7 @@ static int vif_add(struct net *net, struct mr_table *mrt,
 	v->pkt_out = 0;
 	v->link = dev->ifindex;
 	if (v->flags & (VIFF_TUNNEL | VIFF_REGISTER))
-		v->link = dev->iflink;
+		v->link = dev_get_iflink(dev);
 
 	/* And finish update writing critical data */
 	write_lock_bh(&mrt_lock);
diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c
index f8fc5e2782c1..03af45b9df45 100644
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@ -4481,8 +4481,8 @@ static int inet6_fill_ifinfo(struct sk_buff *skb, struct inet6_dev *idev,
 	    (dev->addr_len &&
 	     nla_put(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr)) ||
 	    nla_put_u32(skb, IFLA_MTU, dev->mtu) ||
-	    (dev->ifindex != dev->iflink &&
-	     nla_put_u32(skb, IFLA_LINK, dev->iflink)))
+	    (dev->ifindex != dev_get_iflink(dev) &&
+	     nla_put_u32(skb, IFLA_LINK, dev_get_iflink(dev))))
 		goto nla_put_failure;
 	protoinfo = nla_nest_start(skb, IFLA_PROTINFO);
 	if (protoinfo == NULL)
diff --git a/net/ipv6/ip6mr.c b/net/ipv6/ip6mr.c
index 4b421249532f..ecd99c4ea05c 100644
--- a/net/ipv6/ip6mr.c
+++ b/net/ipv6/ip6mr.c
@@ -992,7 +992,7 @@ static int mif6_add(struct net *net, struct mr6_table *mrt,
 	v->pkt_out = 0;
 	v->link = dev->ifindex;
 	if (v->flags & MIFF_REGISTER)
-		v->link = dev->iflink;
+		v->link = dev_get_iflink(dev);
 
 	/* And finish update writing critical data */
 	write_lock_bh(&mrt_lock);
