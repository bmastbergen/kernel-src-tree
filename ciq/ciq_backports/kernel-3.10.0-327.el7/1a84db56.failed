treewide: fix errors in printk

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Masanari Iida <standby24x7@gmail.com>
commit 1a84db567aeeb232daad598c7aa2334dda0176b7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/1a84db56.failed

This patch fix spelling typo in printk.

	Signed-off-by: Masanari Iida <standby24x7@gmail.com>
	Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
	Acked-by: Randy Dunlap <rdunlap@infradead.org>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 1a84db567aeeb232daad598c7aa2334dda0176b7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/via/via-velocity.c
#	drivers/scsi/fnic/fnic_debugfs.c
#	drivers/scsi/fnic/fnic_trace.c
diff --cc drivers/net/ethernet/via/via-velocity.c
index fb6248956ee2,d5d547aef4f7..000000000000
--- a/drivers/net/ethernet/via/via-velocity.c
+++ b/drivers/net/ethernet/via/via-velocity.c
@@@ -2037,7 -2056,7 +2037,11 @@@ static int velocity_receive_frame(struc
  	struct sk_buff *skb;
  
  	if (rd->rdesc0.RSR & (RSR_STP | RSR_EDP)) {
++<<<<<<< HEAD
 +		VELOCITY_PRT(MSG_LEVEL_VERBOSE, KERN_ERR " %s : the received frame span multple RDs.\n", vptr->dev->name);
++=======
+ 		VELOCITY_PRT(MSG_LEVEL_VERBOSE, KERN_ERR " %s : the received frame spans multiple RDs.\n", vptr->netdev->name);
++>>>>>>> 1a84db567aee (treewide: fix errors in printk)
  		stats->rx_length_errors++;
  		return -EINVAL;
  	}
diff --cc drivers/scsi/fnic/fnic_debugfs.c
index b6073f875761,5980c10c734d..000000000000
--- a/drivers/scsi/fnic/fnic_debugfs.c
+++ b/drivers/scsi/fnic/fnic_debugfs.c
@@@ -153,7 -203,15 +153,19 @@@ static ssize_t fnic_trace_ctrl_write(st
  	if (ret < 0)
  		return ret;
  
++<<<<<<< HEAD
 +	fnic_tracing_enabled = val;
++=======
+ 	if (*trace_type == fc_trc_flag->fnic_trace)
+ 		fnic_tracing_enabled = val;
+ 	else if (*trace_type == fc_trc_flag->fc_trace)
+ 		fnic_fc_tracing_enabled = val;
+ 	else if (*trace_type == fc_trc_flag->fc_clear)
+ 		fnic_fc_trace_cleared = val;
+ 	else
+ 		pr_err("fnic: cannot write to any debugfs file\n");
+ 
++>>>>>>> 1a84db567aee (treewide: fix errors in printk)
  	(*ppos)++;
  
  	return cnt;
diff --cc drivers/scsi/fnic/fnic_trace.c
index e002e7187dc0,8b1b38751b49..000000000000
--- a/drivers/scsi/fnic/fnic_trace.c
+++ b/drivers/scsi/fnic/fnic_trace.c
@@@ -456,3 -467,314 +456,317 @@@ void fnic_trace_free(void
  	}
  	printk(KERN_INFO PFX "Successfully Freed Trace Buffer\n");
  }
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * fnic_fc_ctlr_trace_buf_init -
+  * Initialize trace buffer to log fnic control frames
+  * Description:
+  * Initialize trace buffer data structure by allocating
+  * required memory for trace data as well as for Indexes.
+  * Frame size is 256 bytes and
+  * memory is allocated for 1024 entries of 256 bytes.
+  * Page_offset(Index) is set to the address of trace entry
+  * and page_offset is initialized by adding frame size
+  * to the previous page_offset entry.
+  */
+ 
+ int fnic_fc_trace_init(void)
+ {
+ 	unsigned long fc_trace_buf_head;
+ 	int err = 0;
+ 	int i;
+ 
+ 	fc_trace_max_entries = (fnic_fc_trace_max_pages * PAGE_SIZE)/
+ 				FC_TRC_SIZE_BYTES;
+ 	fnic_fc_ctlr_trace_buf_p = (unsigned long)vmalloc(
+ 					fnic_fc_trace_max_pages * PAGE_SIZE);
+ 	if (!fnic_fc_ctlr_trace_buf_p) {
+ 		pr_err("fnic: Failed to allocate memory for "
+ 		       "FC Control Trace Buf\n");
+ 		err = -ENOMEM;
+ 		goto err_fnic_fc_ctlr_trace_buf_init;
+ 	}
+ 
+ 	memset((void *)fnic_fc_ctlr_trace_buf_p, 0,
+ 			fnic_fc_trace_max_pages * PAGE_SIZE);
+ 
+ 	/* Allocate memory for page offset */
+ 	fc_trace_entries.page_offset = vmalloc(fc_trace_max_entries *
+ 						sizeof(unsigned long));
+ 	if (!fc_trace_entries.page_offset) {
+ 		pr_err("fnic:Failed to allocate memory for page_offset\n");
+ 		if (fnic_fc_ctlr_trace_buf_p) {
+ 			pr_err("fnic: Freeing FC Control Trace Buf\n");
+ 			vfree((void *)fnic_fc_ctlr_trace_buf_p);
+ 			fnic_fc_ctlr_trace_buf_p = 0;
+ 		}
+ 		err = -ENOMEM;
+ 		goto err_fnic_fc_ctlr_trace_buf_init;
+ 	}
+ 	memset((void *)fc_trace_entries.page_offset, 0,
+ 	       (fc_trace_max_entries * sizeof(unsigned long)));
+ 
+ 	fc_trace_entries.rd_idx = fc_trace_entries.wr_idx = 0;
+ 	fc_trace_buf_head = fnic_fc_ctlr_trace_buf_p;
+ 
+ 	/*
+ 	* Set up fc_trace_entries.page_offset field with memory location
+ 	* for every trace entry
+ 	*/
+ 	for (i = 0; i < fc_trace_max_entries; i++) {
+ 		fc_trace_entries.page_offset[i] = fc_trace_buf_head;
+ 		fc_trace_buf_head += FC_TRC_SIZE_BYTES;
+ 	}
+ 	err = fnic_fc_trace_debugfs_init();
+ 	if (err < 0) {
+ 		pr_err("fnic: Failed to initialize FC_CTLR tracing.\n");
+ 		goto err_fnic_fc_ctlr_trace_debugfs_init;
+ 	}
+ 	pr_info("fnic: Successfully Initialized FC_CTLR Trace Buffer\n");
+ 	return err;
+ 
+ err_fnic_fc_ctlr_trace_debugfs_init:
+ 	fnic_fc_trace_free();
+ err_fnic_fc_ctlr_trace_buf_init:
+ 	return err;
+ }
+ 
+ /*
+  * Fnic_fc_ctlr_trace_free - Free memory of fnic_fc_ctlr trace data structures.
+  */
+ void fnic_fc_trace_free(void)
+ {
+ 	fnic_fc_tracing_enabled = 0;
+ 	fnic_fc_trace_debugfs_terminate();
+ 	if (fc_trace_entries.page_offset) {
+ 		vfree((void *)fc_trace_entries.page_offset);
+ 		fc_trace_entries.page_offset = NULL;
+ 	}
+ 	if (fnic_fc_ctlr_trace_buf_p) {
+ 		vfree((void *)fnic_fc_ctlr_trace_buf_p);
+ 		fnic_fc_ctlr_trace_buf_p = 0;
+ 	}
+ 	pr_info("fnic:Successfully FC_CTLR Freed Trace Buffer\n");
+ }
+ 
+ /*
+  * fnic_fc_ctlr_set_trace_data:
+  *       Maintain rd & wr idx accordingly and set data
+  * Passed parameters:
+  *       host_no: host number accociated with fnic
+  *       frame_type: send_frame, rece_frame or link event
+  *       fc_frame: pointer to fc_frame
+  *       frame_len: Length of the fc_frame
+  * Description:
+  *   This routine will get next available wr_idx and
+  *   copy all passed trace data to the buffer pointed by wr_idx
+  *   and increment wr_idx. It will also make sure that we dont
+  *   overwrite the entry which we are reading and also
+  *   wrap around if we reach the maximum entries.
+  * Returned Value:
+  *   It will return 0 for success or -1 for failure
+  */
+ int fnic_fc_trace_set_data(u32 host_no, u8 frame_type,
+ 				char *frame, u32 fc_trc_frame_len)
+ {
+ 	unsigned long flags;
+ 	struct fc_trace_hdr *fc_buf;
+ 	unsigned long eth_fcoe_hdr_len;
+ 	char *fc_trace;
+ 
+ 	if (fnic_fc_tracing_enabled == 0)
+ 		return 0;
+ 
+ 	spin_lock_irqsave(&fnic_fc_trace_lock, flags);
+ 
+ 	if (fnic_fc_trace_cleared == 1) {
+ 		fc_trace_entries.rd_idx = fc_trace_entries.wr_idx = 0;
+ 		pr_info("fnic: Resetting the read idx\n");
+ 		memset((void *)fnic_fc_ctlr_trace_buf_p, 0,
+ 				fnic_fc_trace_max_pages * PAGE_SIZE);
+ 		fnic_fc_trace_cleared = 0;
+ 	}
+ 
+ 	fc_buf = (struct fc_trace_hdr *)
+ 		fc_trace_entries.page_offset[fc_trace_entries.wr_idx];
+ 
+ 	fc_trace_entries.wr_idx++;
+ 
+ 	if (fc_trace_entries.wr_idx >= fc_trace_max_entries)
+ 		fc_trace_entries.wr_idx = 0;
+ 
+ 	if (fc_trace_entries.wr_idx == fc_trace_entries.rd_idx) {
+ 		fc_trace_entries.rd_idx++;
+ 		if (fc_trace_entries.rd_idx >= fc_trace_max_entries)
+ 			fc_trace_entries.rd_idx = 0;
+ 	}
+ 
+ 	fc_buf->time_stamp = CURRENT_TIME;
+ 	fc_buf->host_no = host_no;
+ 	fc_buf->frame_type = frame_type;
+ 
+ 	fc_trace = (char *)FC_TRACE_ADDRESS(fc_buf);
+ 
+ 	/* During the receive path, we do not have eth hdr as well as fcoe hdr
+ 	 * at trace entry point so we will stuff 0xff just to make it generic.
+ 	 */
+ 	if (frame_type == FNIC_FC_RECV) {
+ 		eth_fcoe_hdr_len = sizeof(struct ethhdr) +
+ 					sizeof(struct fcoe_hdr);
+ 		fc_trc_frame_len = fc_trc_frame_len + eth_fcoe_hdr_len;
+ 		memset((char *)fc_trace, 0xff, eth_fcoe_hdr_len);
+ 		/* Copy the rest of data frame */
+ 		memcpy((char *)(fc_trace + eth_fcoe_hdr_len), (void *)frame,
+ 		min_t(u8, fc_trc_frame_len,
+ 			(u8)(FC_TRC_SIZE_BYTES - FC_TRC_HEADER_SIZE)));
+ 	} else {
+ 		memcpy((char *)fc_trace, (void *)frame,
+ 		min_t(u8, fc_trc_frame_len,
+ 			(u8)(FC_TRC_SIZE_BYTES - FC_TRC_HEADER_SIZE)));
+ 	}
+ 
+ 	/* Store the actual received length */
+ 	fc_buf->frame_len = fc_trc_frame_len;
+ 
+ 	spin_unlock_irqrestore(&fnic_fc_trace_lock, flags);
+ 	return 0;
+ }
+ 
+ /*
+  * fnic_fc_ctlr_get_trace_data: Copy trace buffer to a memory file
+  * Passed parameter:
+  *       @fnic_dbgfs_t: pointer to debugfs trace buffer
+  *       rdata_flag: 1 => Unformated file
+  *                   0 => formated file
+  * Description:
+  *       This routine will copy the trace data to memory file with
+  *       proper formatting and also copy to another memory
+  *       file without formatting for further procesing.
+  * Retrun Value:
+  *       Number of bytes that were dumped into fnic_dbgfs_t
+  */
+ 
+ int fnic_fc_trace_get_data(fnic_dbgfs_t *fnic_dbgfs_prt, u8 rdata_flag)
+ {
+ 	int rd_idx, wr_idx;
+ 	unsigned long flags;
+ 	int len = 0, j;
+ 	struct fc_trace_hdr *tdata;
+ 	char *fc_trace;
+ 
+ 	spin_lock_irqsave(&fnic_fc_trace_lock, flags);
+ 	if (fc_trace_entries.wr_idx == fc_trace_entries.rd_idx) {
+ 		spin_unlock_irqrestore(&fnic_fc_trace_lock, flags);
+ 		pr_info("fnic: Buffer is empty\n");
+ 		return 0;
+ 	}
+ 	rd_idx = fc_trace_entries.rd_idx;
+ 	wr_idx = fc_trace_entries.wr_idx;
+ 	if (rdata_flag == 0) {
+ 		len += snprintf(fnic_dbgfs_prt->buffer + len,
+ 			(fnic_fc_trace_max_pages * PAGE_SIZE * 3) - len,
+ 			"Time Stamp (UTC)\t\t"
+ 			"Host No:   F Type:  len:     FCoE_FRAME:\n");
+ 	}
+ 
+ 	while (rd_idx != wr_idx) {
+ 		tdata = (struct fc_trace_hdr *)
+ 			fc_trace_entries.page_offset[rd_idx];
+ 		if (!tdata) {
+ 			pr_info("fnic: Rd data is NULL\n");
+ 			spin_unlock_irqrestore(&fnic_fc_trace_lock, flags);
+ 			return 0;
+ 		}
+ 		if (rdata_flag == 0) {
+ 			copy_and_format_trace_data(tdata,
+ 				fnic_dbgfs_prt, &len, rdata_flag);
+ 		} else {
+ 			fc_trace = (char *)tdata;
+ 			for (j = 0; j < FC_TRC_SIZE_BYTES; j++) {
+ 				len += snprintf(fnic_dbgfs_prt->buffer + len,
+ 				(fnic_fc_trace_max_pages * PAGE_SIZE * 3)
+ 				- len, "%02x", fc_trace[j] & 0xff);
+ 			} /* for loop */
+ 			len += snprintf(fnic_dbgfs_prt->buffer + len,
+ 				(fnic_fc_trace_max_pages * PAGE_SIZE * 3) - len,
+ 				"\n");
+ 		}
+ 		rd_idx++;
+ 		if (rd_idx > (fc_trace_max_entries - 1))
+ 			rd_idx = 0;
+ 	}
+ 
+ 	spin_unlock_irqrestore(&fnic_fc_trace_lock, flags);
+ 	return len;
+ }
+ 
+ /*
+  * copy_and_format_trace_data: Copy formatted data to char * buffer
+  * Passed Parameter:
+  *      @fc_trace_hdr_t: pointer to trace data
+  *      @fnic_dbgfs_t: pointer to debugfs trace buffer
+  *      @orig_len: pointer to len
+  *      rdata_flag: 0 => Formated file, 1 => Unformated file
+  * Description:
+  *      This routine will format and copy the passed trace data
+  *      for formated file or unformated file accordingly.
+  */
+ 
+ void copy_and_format_trace_data(struct fc_trace_hdr *tdata,
+ 				fnic_dbgfs_t *fnic_dbgfs_prt, int *orig_len,
+ 				u8 rdata_flag)
+ {
+ 	struct tm tm;
+ 	int j, i = 1, len;
+ 	char *fc_trace, *fmt;
+ 	int ethhdr_len = sizeof(struct ethhdr) - 1;
+ 	int fcoehdr_len = sizeof(struct fcoe_hdr);
+ 	int fchdr_len = sizeof(struct fc_frame_header);
+ 	int max_size = fnic_fc_trace_max_pages * PAGE_SIZE * 3;
+ 
+ 	tdata->frame_type = tdata->frame_type & 0x7F;
+ 
+ 	len = *orig_len;
+ 
+ 	time_to_tm(tdata->time_stamp.tv_sec, 0, &tm);
+ 
+ 	fmt = "%02d:%02d:%04ld %02d:%02d:%02d.%09lu ns%8x       %c%8x\t";
+ 	len += snprintf(fnic_dbgfs_prt->buffer + len,
+ 		(fnic_fc_trace_max_pages * PAGE_SIZE * 3) - len,
+ 		fmt,
+ 		tm.tm_mon + 1, tm.tm_mday, tm.tm_year + 1900,
+ 		tm.tm_hour, tm.tm_min, tm.tm_sec,
+ 		tdata->time_stamp.tv_nsec, tdata->host_no,
+ 		tdata->frame_type, tdata->frame_len);
+ 
+ 	fc_trace = (char *)FC_TRACE_ADDRESS(tdata);
+ 
+ 	for (j = 0; j < min_t(u8, tdata->frame_len,
+ 		(u8)(FC_TRC_SIZE_BYTES - FC_TRC_HEADER_SIZE)); j++) {
+ 		if (tdata->frame_type == FNIC_FC_LE) {
+ 			len += snprintf(fnic_dbgfs_prt->buffer + len,
+ 				max_size - len, "%c", fc_trace[j]);
+ 		} else {
+ 			len += snprintf(fnic_dbgfs_prt->buffer + len,
+ 				max_size - len, "%02x", fc_trace[j] & 0xff);
+ 			len += snprintf(fnic_dbgfs_prt->buffer + len,
+ 				max_size - len, " ");
+ 			if (j == ethhdr_len ||
+ 				j == ethhdr_len + fcoehdr_len ||
+ 				j == ethhdr_len + fcoehdr_len + fchdr_len ||
+ 				(i > 3 && j%fchdr_len == 0)) {
+ 				len += snprintf(fnic_dbgfs_prt->buffer
+ 					+ len, (fnic_fc_trace_max_pages
+ 					* PAGE_SIZE * 3) - len,
+ 					"\n\t\t\t\t\t\t\t\t");
+ 				i++;
+ 			}
+ 		} /* end of else*/
+ 	} /* End of for loop*/
+ 	len += snprintf(fnic_dbgfs_prt->buffer + len,
+ 		max_size - len, "\n");
+ 	*orig_len = len;
+ }
++>>>>>>> 1a84db567aee (treewide: fix errors in printk)
diff --git a/arch/m68k/Kconfig.devices b/arch/m68k/Kconfig.devices
index d163991c5717..2a74777667fd 100644
--- a/arch/m68k/Kconfig.devices
+++ b/arch/m68k/Kconfig.devices
@@ -73,7 +73,7 @@ config ATARI_ETHERNEC
 	  ROM port. The driver works by polling instead of interrupts, so it
 	  is quite slow.
 
-	  This driver also suppports the ethernet part of the NetUSBee ROM
+	  This driver also supports the ethernet part of the NetUSBee ROM
 	  port combined Ethernet/USB adapter.
 
 	  To compile the actual ethernet driver, choose Y or M in for the NE2000
diff --git a/arch/mips/lantiq/falcon/sysctrl.c b/arch/mips/lantiq/falcon/sysctrl.c
index ff4894a833ee..ad6caf732a5c 100644
--- a/arch/mips/lantiq/falcon/sysctrl.c
+++ b/arch/mips/lantiq/falcon/sysctrl.c
@@ -219,7 +219,7 @@ void __init ltq_soc_init(void)
 		(request_mem_region(res_sys[2].start,
 				resource_size(&res_sys[2]),
 				res_sys[2].name) < 0))
-		pr_err("Failed to request core reources");
+		pr_err("Failed to request core resources");
 
 	status_membase = ioremap_nocache(res_status.start,
 					resource_size(&res_status));
diff --git a/arch/mips/lantiq/xway/sysctrl.c b/arch/mips/lantiq/xway/sysctrl.c
index c24924fe087d..e946c3627c4a 100644
--- a/arch/mips/lantiq/xway/sysctrl.c
+++ b/arch/mips/lantiq/xway/sysctrl.c
@@ -318,7 +318,7 @@ void __init ltq_soc_init(void)
 				res_cgu.name) < 0) ||
 		(request_mem_region(res_ebu.start, resource_size(&res_ebu),
 				res_ebu.name) < 0))
-		pr_err("Failed to request core reources");
+		pr_err("Failed to request core resources");
 
 	pmu_membase = ioremap_nocache(res_pmu.start, resource_size(&res_pmu));
 	ltq_cgu_membase = ioremap_nocache(res_cgu.start,
diff --git a/arch/mips/pci/pci-lantiq.c b/arch/mips/pci/pci-lantiq.c
index 879077b01155..4a1d046a7b63 100644
--- a/arch/mips/pci/pci-lantiq.c
+++ b/arch/mips/pci/pci-lantiq.c
@@ -218,7 +218,7 @@ static int ltq_pci_probe(struct platform_device *pdev)
 	res_cfg = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	res_bridge = platform_get_resource(pdev, IORESOURCE_MEM, 1);
 	if (!res_cfg || !res_bridge) {
-		dev_err(&pdev->dev, "missing memory reources\n");
+		dev_err(&pdev->dev, "missing memory resources\n");
 		return -EINVAL;
 	}
 
diff --git a/arch/powerpc/platforms/powernv/opal.c b/arch/powerpc/platforms/powernv/opal.c
index 07dee0ce6c2d..60ba123e3bae 100644
--- a/arch/powerpc/platforms/powernv/opal.c
+++ b/arch/powerpc/platforms/powernv/opal.c
@@ -324,7 +324,7 @@ static void opal_handle_message(void)
 
 	/* check for errors. */
 	if (ret) {
-		pr_warning("%s: Failed to retrive opal message, err=%lld\n",
+		pr_warning("%s: Failed to retrieve opal message, err=%lld\n",
 				__func__, ret);
 		return;
 	}
diff --git a/drivers/crypto/qat/qat_common/adf_ctl_drv.c b/drivers/crypto/qat/qat_common/adf_ctl_drv.c
index 6f7816e2c421..244d73378f0e 100644
--- a/drivers/crypto/qat/qat_common/adf_ctl_drv.c
+++ b/drivers/crypto/qat/qat_common/adf_ctl_drv.c
@@ -436,7 +436,7 @@ static long adf_ctl_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)
 		ret = adf_ctl_ioctl_get_status(fp, cmd, arg);
 		break;
 	default:
-		pr_err("QAT: Invalid ioclt\n");
+		pr_err("QAT: Invalid ioctl\n");
 		ret = -EFAULT;
 		break;
 	}
diff --git a/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c b/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c
index d8569ca8b754..b6201356d669 100644
--- a/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c
+++ b/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c
@@ -1872,7 +1872,7 @@ static int ocrdma_build_inline_sges(struct ocrdma_qp *qp,
 		hdr->total_len = ocrdma_sglist_len(wr->sg_list, wr->num_sge);
 		if (unlikely(hdr->total_len > qp->max_inline_data)) {
 			pr_err("%s() supported_len=0x%x,\n"
-			       " unspported len req=0x%x\n", __func__,
+			       " unsupported len req=0x%x\n", __func__,
 				qp->max_inline_data, hdr->total_len);
 			return -EINVAL;
 		}
diff --git a/drivers/net/ethernet/mellanox/mlx4/cmd.c b/drivers/net/ethernet/mellanox/mlx4/cmd.c
index 6f8c47070991..f855508480cf 100644
--- a/drivers/net/ethernet/mellanox/mlx4/cmd.c
+++ b/drivers/net/ethernet/mellanox/mlx4/cmd.c
@@ -1704,7 +1704,7 @@ static int mlx4_master_activate_admin_state(struct mlx4_priv *priv, int slave)
 			if (err) {
 				vp_oper->vlan_idx = NO_INDX;
 				mlx4_warn(&priv->dev,
-					  "No vlan resorces slave %d, port %d\n",
+					  "No vlan resources slave %d, port %d\n",
 					  slave, port);
 				return err;
 			}
@@ -1720,7 +1720,7 @@ static int mlx4_master_activate_admin_state(struct mlx4_priv *priv, int slave)
 				err = vp_oper->mac_idx;
 				vp_oper->mac_idx = NO_INDX;
 				mlx4_warn(&priv->dev,
-					  "No mac resorces slave %d, port %d\n",
+					  "No mac resources slave %d, port %d\n",
 					  slave, port);
 				return err;
 			}
* Unmerged path drivers/net/ethernet/via/via-velocity.c
diff --git a/drivers/net/wireless/libertas/cfg.c b/drivers/net/wireless/libertas/cfg.c
index 116f4aba08d6..c49b4eaf766a 100644
--- a/drivers/net/wireless/libertas/cfg.c
+++ b/drivers/net/wireless/libertas/cfg.c
@@ -1359,7 +1359,7 @@ static int lbs_cfg_connect(struct wiphy *wiphy, struct net_device *dev,
 		wait_event_interruptible_timeout(priv->scan_q,
 						 (priv->scan_req == NULL),
 						 (15 * HZ));
-		lbs_deb_assoc("assoc: scanning competed\n");
+		lbs_deb_assoc("assoc: scanning completed\n");
 	}
 
 	/* Find the BSS we want using available scan results */
* Unmerged path drivers/scsi/fnic/fnic_debugfs.c
* Unmerged path drivers/scsi/fnic/fnic_trace.c
diff --git a/drivers/video/backlight/88pm860x_bl.c b/drivers/video/backlight/88pm860x_bl.c
index 2cd63507ed74..ff8f7b419065 100644
--- a/drivers/video/backlight/88pm860x_bl.c
+++ b/drivers/video/backlight/88pm860x_bl.c
@@ -216,7 +216,7 @@ static int pm860x_backlight_probe(struct platform_device *pdev)
 	data->reg_duty_cycle = res->start;
 	res = platform_get_resource_byname(pdev, IORESOURCE_REG, "always on");
 	if (!res) {
-		dev_err(&pdev->dev, "No REG resorce for always on\n");
+		dev_err(&pdev->dev, "No REG resource for always on\n");
 		return -ENXIO;
 	}
 	data->reg_always_on = res->start;
diff --git a/net/netfilter/ipset/ip_set_core.c b/net/netfilter/ipset/ip_set_core.c
index 98b197a78f1a..b5238769d034 100644
--- a/net/netfilter/ipset/ip_set_core.c
+++ b/net/netfilter/ipset/ip_set_core.c
@@ -406,7 +406,7 @@ ip_set_test(ip_set_id_t index, const struct sk_buff *skb,
 
 	if (ret == -EAGAIN) {
 		/* Type requests element to be completed */
-		pr_debug("element must be competed, ADD is triggered\n");
+		pr_debug("element must be completed, ADD is triggered\n");
 		write_lock_bh(&set->lock);
 		set->variant->kadt(set, skb, par, IPSET_ADD, opt);
 		write_unlock_bh(&set->lock);
diff --git a/scripts/sign-file b/scripts/sign-file
index 2b7c4484d46c..3906ee1e2f76 100755
--- a/scripts/sign-file
+++ b/scripts/sign-file
@@ -398,7 +398,7 @@ if ($verbose) {
     print "Size of signer's name  : ", length($signers_name), "\n";
     print "Size of key identifier : ", length($key_identifier), "\n";
     print "Size of signature      : ", length($signature), "\n";
-    print "Size of informaton     : ", length($info), "\n";
+    print "Size of information    : ", length($info), "\n";
     print "Size of magic number   : ", length($magic_number), "\n";
     print "Signer's name          : '", $signers_name, "'\n";
     print "Digest                 : $dgst\n";
