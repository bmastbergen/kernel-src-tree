ACPI / LPSS: complete PM entries for LPSS power domain

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [acpi] lpss: complete PM entries for LPSS power domain (Prarit Bhargava) [1178891]
Rebuild_FUZZ: 93.07%
commit-author Fu Zhonghui <zhonghui.fu@linux.intel.com>
commit f4168b617ac09986c4333accaff5d8ba5a9db7bf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/f4168b61.failed

PM entries of LPSS power domain were not implemented correctly
in commit c78b0830667a "ACPI / LPSS: custom power domain for LPSS".

This patch fixes and completes these PM entries.

Fixes: c78b0830667a (ACPI / LPSS: custom power domain for LPSS)
	Signed-off-by: Li Aubrey <aubrey.li@linux.intel.com>
	Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Signed-off-by: Fu Zhonghui <zhonghui.fu@linux.intel.com>
	Cc: 3.16+ <stable@vger.kernel.org> # 3.16+
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit f4168b617ac09986c4333accaff5d8ba5a9db7bf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/acpi_lpss.c
diff --cc drivers/acpi/acpi_lpss.c
index ed5dc78f528a,fddc1e86f9d0..000000000000
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@@ -429,6 -547,126 +429,129 @@@ static void acpi_lpss_set_ltr(struct de
  	}
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_PM
+ /**
+  * acpi_lpss_save_ctx() - Save the private registers of LPSS device
+  * @dev: LPSS device
+  *
+  * Most LPSS devices have private registers which may loose their context when
+  * the device is powered down. acpi_lpss_save_ctx() saves those registers into
+  * prv_reg_ctx array.
+  */
+ static void acpi_lpss_save_ctx(struct device *dev)
+ {
+ 	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < LPSS_PRV_REG_COUNT; i++) {
+ 		unsigned long offset = i * sizeof(u32);
+ 
+ 		pdata->prv_reg_ctx[i] = __lpss_reg_read(pdata, offset);
+ 		dev_dbg(dev, "saving 0x%08x from LPSS reg at offset 0x%02lx\n",
+ 			pdata->prv_reg_ctx[i], offset);
+ 	}
+ }
+ 
+ /**
+  * acpi_lpss_restore_ctx() - Restore the private registers of LPSS device
+  * @dev: LPSS device
+  *
+  * Restores the registers that were previously stored with acpi_lpss_save_ctx().
+  */
+ static void acpi_lpss_restore_ctx(struct device *dev)
+ {
+ 	struct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));
+ 	unsigned int i;
+ 
+ 	/*
+ 	 * The following delay is needed or the subsequent write operations may
+ 	 * fail. The LPSS devices are actually PCI devices and the PCI spec
+ 	 * expects 10ms delay before the device can be accessed after D3 to D0
+ 	 * transition.
+ 	 */
+ 	msleep(10);
+ 
+ 	for (i = 0; i < LPSS_PRV_REG_COUNT; i++) {
+ 		unsigned long offset = i * sizeof(u32);
+ 
+ 		__lpss_reg_write(pdata->prv_reg_ctx[i], pdata, offset);
+ 		dev_dbg(dev, "restoring 0x%08x to LPSS reg at offset 0x%02lx\n",
+ 			pdata->prv_reg_ctx[i], offset);
+ 	}
+ }
+ 
+ #ifdef CONFIG_PM_SLEEP
+ static int acpi_lpss_suspend_late(struct device *dev)
+ {
+ 	int ret = pm_generic_suspend_late(dev);
+ 
+ 	if (ret)
+ 		return ret;
+ 
+ 	acpi_lpss_save_ctx(dev);
+ 	return acpi_dev_suspend_late(dev);
+ }
+ 
+ static int acpi_lpss_resume_early(struct device *dev)
+ {
+ 	int ret = acpi_dev_resume_early(dev);
+ 
+ 	if (ret)
+ 		return ret;
+ 
+ 	acpi_lpss_restore_ctx(dev);
+ 	return pm_generic_resume_early(dev);
+ }
+ #endif /* CONFIG_PM_SLEEP */
+ 
+ #ifdef CONFIG_PM_RUNTIME
+ static int acpi_lpss_runtime_suspend(struct device *dev)
+ {
+ 	int ret = pm_generic_runtime_suspend(dev);
+ 
+ 	if (ret)
+ 		return ret;
+ 
+ 	acpi_lpss_save_ctx(dev);
+ 	return acpi_dev_runtime_suspend(dev);
+ }
+ 
+ static int acpi_lpss_runtime_resume(struct device *dev)
+ {
+ 	int ret = acpi_dev_runtime_resume(dev);
+ 
+ 	if (ret)
+ 		return ret;
+ 
+ 	acpi_lpss_restore_ctx(dev);
+ 	return pm_generic_runtime_resume(dev);
+ }
+ #endif /* CONFIG_PM_RUNTIME */
+ #endif /* CONFIG_PM */
+ 
+ static struct dev_pm_domain acpi_lpss_pm_domain = {
+ 	.ops = {
+ #ifdef CONFIG_PM_SLEEP
+ 		.prepare = acpi_subsys_prepare,
+ 		.complete = acpi_subsys_complete,
+ 		.suspend = acpi_subsys_suspend,
+ 		.suspend_late = acpi_lpss_suspend_late,
+ 		.resume_early = acpi_lpss_resume_early,
+ 		.freeze = acpi_subsys_freeze,
+ 		.poweroff = acpi_subsys_suspend,
+ 		.poweroff_late = acpi_lpss_suspend_late,
+ 		.restore_early = acpi_lpss_resume_early,
+ #endif
+ #ifdef CONFIG_PM_RUNTIME
+ 		.runtime_suspend = acpi_lpss_runtime_suspend,
+ 		.runtime_resume = acpi_lpss_runtime_resume,
+ #endif
+ 	},
+ };
+ 
++>>>>>>> f4168b617ac0 (ACPI / LPSS: complete PM entries for LPSS power domain)
  static int acpi_lpss_platform_notify(struct notifier_block *nb,
  				     unsigned long action, void *data)
  {
* Unmerged path drivers/acpi/acpi_lpss.c
