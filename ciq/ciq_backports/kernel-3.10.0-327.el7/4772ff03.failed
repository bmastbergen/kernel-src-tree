drm/dp/mst: Remove port after removing connector.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [drm] dp/mst: Remove port after removing connector (Rob Clark) [1249805]
Rebuild_FUZZ: 94.62%
commit-author Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
commit 4772ff03df8094fd99d28de5fcf5df3a3e9c68bb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/4772ff03.failed

The port is removed synchronously, but the connector delayed.
This causes a use after free which can cause a kernel BUG with
slug_debug=FPZU. This is fixed by freeing the port after the
connector.

This fixes a regression introduced with
6b8eeca65b18ae77e175cc2b6571731f0ee413bf
"drm/dp/mst: close deadlock in connector destruction."

	Cc: stable@vger.kernel.org
	Cc: Dave Airlie <airlied@redhat.com>
	Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
	Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
	Signed-off-by: Jani Nikula <jani.nikula@intel.com>
(cherry picked from commit 4772ff03df8094fd99d28de5fcf5df3a3e9c68bb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/drm_dp_mst_topology.c
#	include/drm/drm_crtc.h
diff --cc drivers/gpu/drm/drm_dp_mst_topology.c
index e79fcfc265fa,1325eecb0510..000000000000
--- a/drivers/gpu/drm/drm_dp_mst_topology.c
+++ b/drivers/gpu/drm/drm_dp_mst_topology.c
@@@ -861,8 -865,19 +861,24 @@@ static void drm_dp_destroy_port(struct 
  	struct drm_dp_mst_topology_mgr *mgr = port->mgr;
  	if (!port->input) {
  		port->vcpi.num_slots = 0;
++<<<<<<< HEAD
 +		if (port->connector)
 +			(*port->mgr->cbs->destroy_connector)(mgr, port->connector);
++=======
+ 
+ 		kfree(port->cached_edid);
+ 
+ 		/* we can't destroy the connector here, as
+ 		   we might be holding the mode_config.mutex
+ 		   from an EDID retrieval */
+ 		if (port->connector) {
+ 			mutex_lock(&mgr->destroy_connector_lock);
+ 			list_add(&port->next, &mgr->destroy_connector_list);
+ 			mutex_unlock(&mgr->destroy_connector_lock);
+ 			schedule_work(&mgr->destroy_connector_work);
+ 			return;
+ 		}
++>>>>>>> 4772ff03df80 (drm/dp/mst: Remove port after removing connector.)
  		drm_dp_port_teardown_pdt(port, port->pdt);
  
  		if (!port->input && port->vcpi.vcpi > 0)
@@@ -2599,6 -2658,36 +2615,39 @@@ static void drm_dp_tx_work(struct work_
  	mutex_unlock(&mgr->qlock);
  }
  
++<<<<<<< HEAD
++=======
+ static void drm_dp_destroy_connector_work(struct work_struct *work)
+ {
+ 	struct drm_dp_mst_topology_mgr *mgr = container_of(work, struct drm_dp_mst_topology_mgr, destroy_connector_work);
+ 	struct drm_dp_mst_port *port;
+ 
+ 	/*
+ 	 * Not a regular list traverse as we have to drop the destroy
+ 	 * connector lock before destroying the connector, to avoid AB->BA
+ 	 * ordering between this lock and the config mutex.
+ 	 */
+ 	for (;;) {
+ 		mutex_lock(&mgr->destroy_connector_lock);
+ 		port = list_first_entry_or_null(&mgr->destroy_connector_list, struct drm_dp_mst_port, next);
+ 		if (!port) {
+ 			mutex_unlock(&mgr->destroy_connector_lock);
+ 			break;
+ 		}
+ 		list_del(&port->next);
+ 		mutex_unlock(&mgr->destroy_connector_lock);
+ 
+ 		mgr->cbs->destroy_connector(mgr, port->connector);
+ 
+ 		drm_dp_port_teardown_pdt(port, port->pdt);
+ 
+ 		if (!port->input && port->vcpi.vcpi > 0)
+ 			drm_dp_mst_put_payload_id(mgr, port->vcpi.vcpi);
+ 		kfree(port);
+ 	}
+ }
+ 
++>>>>>>> 4772ff03df80 (drm/dp/mst: Remove port after removing connector.)
  /**
   * drm_dp_mst_topology_mgr_init - initialise a topology manager
   * @mgr: manager struct to initialise
diff --cc include/drm/drm_crtc.h
index 474b37a199e4,3b4d8a4a23fb..000000000000
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@@ -547,6 -725,24 +547,27 @@@ struct drm_connector 
  	int audio_latency[2];
  	int null_edid_counter; /* needed to workaround some HW bugs where we get all 0s */
  	unsigned bad_edid_counter;
++<<<<<<< HEAD
++=======
+ 
+ 	/* Flag for raw EDID header corruption - used in Displayport
+ 	 * compliance testing - * Displayport Link CTS Core 1.2 rev1.1 4.2.2.6
+ 	 */
+ 	bool edid_corrupt;
+ 
+ 	struct dentry *debugfs_entry;
+ 
+ 	struct drm_connector_state *state;
+ 
+ 	/* DisplayID bits */
+ 	bool has_tile;
+ 	struct drm_tile_group *tile_group;
+ 	bool tile_is_single_monitor;
+ 
+ 	uint8_t num_h_tile, num_v_tile;
+ 	uint8_t tile_h_loc, tile_v_loc;
+ 	uint16_t tile_h_size, tile_v_size;
++>>>>>>> 4772ff03df80 (drm/dp/mst: Remove port after removing connector.)
  };
  
  /**
* Unmerged path drivers/gpu/drm/drm_dp_mst_topology.c
* Unmerged path include/drm/drm_crtc.h
