perf/x86/intel: Disable FREEZE_LBRS_ON_PMI when LBR operates in callstack mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [perf] x86/intel: Disable FREEZE_LBRS_ON_PMI when LBR operates in callstack mode (Jiri Olsa) [1222189]
Rebuild_FUZZ: 96.69%
commit-author Yan, Zheng <zheng.z.yan@intel.com>
commit 2c70d0086e4e9e2440f0f78098090f32bde14277
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/2c70d008.failed

LBR callstack is designed for PEBS, It does not work well with
FREEZE_LBRS_ON_PMI for non PEBS event. If FREEZE_LBRS_ON_PMI is set for
non PEBS event, PMIs near call/return instructions may cause superfluous
increase/decrease of LBR_TOS.

This patch modifies __intel_pmu_lbr_enable() to not enable
FREEZE_LBRS_ON_PMI when LBR operates in callstack mode. We currently
don't use LBR callstack to capture kernel space callchain, so disabling
FREEZE_LBRS_ON_PMI should not be a problem.

	Signed-off-by: Yan, Zheng <zheng.z.yan@intel.com>
	Signed-off-by: Kan Liang <kan.liang@intel.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: eranian@google.com
	Cc: jolsa@redhat.com
Link: http://lkml.kernel.org/r/1415156173-10035-15-git-send-email-kan.liang@intel.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 2c70d0086e4e9e2440f0f78098090f32bde14277)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/perf_event_intel_lbr.c
diff --cc arch/x86/kernel/cpu/perf_event_intel_lbr.c
index 92348471a707,92a44fdbc9d3..000000000000
--- a/arch/x86/kernel/cpu/perf_event_intel_lbr.c
+++ b/arch/x86/kernel/cpu/perf_event_intel_lbr.c
@@@ -131,14 -131,23 +131,28 @@@ static void intel_pmu_lbr_filter(struc
  
  static void __intel_pmu_lbr_enable(void)
  {
++<<<<<<< HEAD
 +	u64 debugctl;
 +	struct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);
- 
- 	if (cpuc->lbr_sel)
- 		wrmsrl(MSR_LBR_SELECT, cpuc->lbr_sel->config);
++=======
+ 	struct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);
+ 	u64 debugctl, lbr_select = 0;
++>>>>>>> 2c70d0086e4e (perf/x86/intel: Disable FREEZE_LBRS_ON_PMI when LBR operates in callstack mode)
+ 
+ 	if (cpuc->lbr_sel) {
+ 		lbr_select = cpuc->lbr_sel->config;
+ 		wrmsrl(MSR_LBR_SELECT, lbr_select);
+ 	}
  
  	rdmsrl(MSR_IA32_DEBUGCTLMSR, debugctl);
- 	debugctl |= (DEBUGCTLMSR_LBR | DEBUGCTLMSR_FREEZE_LBRS_ON_PMI);
+ 	debugctl |= DEBUGCTLMSR_LBR;
+ 	/*
+ 	 * LBR callstack does not work well with FREEZE_LBRS_ON_PMI.
+ 	 * If FREEZE_LBRS_ON_PMI is set, PMI near call/return instructions
+ 	 * may cause superfluous increase/decrease of LBR_TOS.
+ 	 */
+ 	if (!(lbr_select & LBR_CALL_STACK))
+ 		debugctl |= DEBUGCTLMSR_FREEZE_LBRS_ON_PMI;
  	wrmsrl(MSR_IA32_DEBUGCTLMSR, debugctl);
  }
  
* Unmerged path arch/x86/kernel/cpu/perf_event_intel_lbr.c
