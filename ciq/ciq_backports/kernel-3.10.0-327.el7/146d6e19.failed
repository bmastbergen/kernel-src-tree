IB/mlx4: Create mirror flows in port aggregation mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [infiniband] mlx4: Create mirror flows in port aggregation mode (Amir Vadai) [1164527 1164530 1164531 1164536 1164537]
Rebuild_FUZZ: 97.09%
commit-author Moni Shoua <monis@mellanox.com>
commit 146d6e19832a72136089afca51e5229d1fd72dcd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/146d6e19.failed

In port aggregation mode flows for port #1 (the only port) should be mirrored
on port #2. This is because packets can arrive from either physical ports.

	Signed-off-by: Moni Shoua <monis@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 146d6e19832a72136089afca51e5229d1fd72dcd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx4/main.c
diff --cc drivers/infiniband/hw/mlx4/main.c
index 9a1896e58511,ca522382dedc..000000000000
--- a/drivers/infiniband/hw/mlx4/main.c
+++ b/drivers/infiniband/hw/mlx4/main.c
@@@ -1226,10 -1263,12 +1263,16 @@@ static int mlx4_ib_mcg_attach(struct ib
  {
  	int err;
  	struct mlx4_ib_dev *mdev = to_mdev(ibqp->device);
+ 	struct mlx4_dev	*dev = mdev->dev;
  	struct mlx4_ib_qp *mqp = to_mqp(ibqp);
- 	u64 reg_id;
  	struct mlx4_ib_steering *ib_steering = NULL;
++<<<<<<< HEAD
 +	enum mlx4_protocol prot = MLX4_PROT_IB_IPV6;
++=======
+ 	enum mlx4_protocol prot = (gid->raw[1] == 0x0e) ?
+ 		MLX4_PROT_IB_IPV4 : MLX4_PROT_IB_IPV6;
+ 	struct mlx4_flow_reg_id	reg_id;
++>>>>>>> 146d6e19832a (IB/mlx4: Create mirror flows in port aggregation mode)
  
  	if (mdev->dev->caps.steering_mode ==
  	    MLX4_STEERING_MODE_DEVICE_MANAGED) {
@@@ -1241,12 -1280,20 +1284,27 @@@
  	err = mlx4_multicast_attach(mdev->dev, &mqp->mqp, gid->raw, mqp->port,
  				    !!(mqp->flags &
  				       MLX4_IB_QP_BLOCK_MULTICAST_LOOPBACK),
++<<<<<<< HEAD
 +				    prot, &reg_id);
 +	if (err) {
 +		pr_err("multicast attach op failed, err %d\n", err);
++=======
+ 				    prot, &reg_id.id);
+ 	if (err)
++>>>>>>> 146d6e19832a (IB/mlx4: Create mirror flows in port aggregation mode)
  		goto err_malloc;
 +	}
  
+ 	reg_id.mirror = 0;
+ 	if (mlx4_is_bonded(dev)) {
+ 		err = mlx4_multicast_attach(mdev->dev, &mqp->mqp, gid->raw, 2,
+ 					    !!(mqp->flags &
+ 					    MLX4_IB_QP_BLOCK_MULTICAST_LOOPBACK),
+ 					    prot, &reg_id.mirror);
+ 		if (err)
+ 			goto err_add;
+ 	}
+ 
  	err = add_gid_entry(ibqp, gid);
  	if (err)
  		goto err_add;
@@@ -1292,8 -1343,10 +1354,15 @@@ static int mlx4_ib_mcg_detach(struct ib
  	struct mlx4_ib_qp *mqp = to_mqp(ibqp);
  	struct net_device *ndev;
  	struct mlx4_ib_gid_entry *ge;
++<<<<<<< HEAD
 +	u64 reg_id = 0;
 +	enum mlx4_protocol prot =  MLX4_PROT_IB_IPV6;
++=======
+ 	struct mlx4_flow_reg_id reg_id = {0, 0};
+ 
+ 	enum mlx4_protocol prot = (gid->raw[1] == 0x0e) ?
+ 		MLX4_PROT_IB_IPV4 : MLX4_PROT_IB_IPV6;
++>>>>>>> 146d6e19832a (IB/mlx4: Create mirror flows in port aggregation mode)
  
  	if (mdev->dev->caps.steering_mode ==
  	    MLX4_STEERING_MODE_DEVICE_MANAGED) {
* Unmerged path drivers/infiniband/hw/mlx4/main.c
diff --git a/drivers/infiniband/hw/mlx4/mlx4_ib.h b/drivers/infiniband/hw/mlx4/mlx4_ib.h
index 4779c71d2fff..6ebfac575eb7 100644
--- a/drivers/infiniband/hw/mlx4/mlx4_ib.h
+++ b/drivers/infiniband/hw/mlx4/mlx4_ib.h
@@ -134,10 +134,17 @@ struct mlx4_ib_fmr {
 	struct mlx4_fmr         mfmr;
 };
 
+#define MAX_REGS_PER_FLOW 2
+
+struct mlx4_flow_reg_id {
+	u64 id;
+	u64 mirror;
+};
+
 struct mlx4_ib_flow {
 	struct ib_flow ibflow;
 	/* translating DMFS verbs sniffer rule to FW API requires two reg IDs */
-	u64 reg_id[2];
+	struct mlx4_flow_reg_id reg_id[MAX_REGS_PER_FLOW];
 };
 
 struct mlx4_ib_wq {
