net/mlx4_core: Add basic support for QP max-rate limiting

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [netdrv] mlx4_core: Add basic support for QP max-rate limiting (Amir Vadai) [1164527 1164530 1164531 1164536 1164537]
Rebuild_FUZZ: 96.36%
commit-author Or Gerlitz <ogerlitz@mellanox.com>
commit fc31e2560a2443410fe45c27116fae736541a7b5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/fc31e256.failed

Add the low-level device commands and definitions used for QP max-rate limiting.

This is done through the following elements:

  - read rate-limit device caps in QUERY_DEV_CAP: number of different
    rates and the min/max rates in Kbs/Mbs/Gbs units

  - enhance the QP context struct to contain rate limit units and value

  - allow to do run time rate-limit setting to QPs through the
    update-qp firmware command

  - QP rate-limiting is disallowed for VFs

	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fc31e2560a2443410fe45c27116fae736541a7b5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx4/fw.c
#	drivers/net/ethernet/mellanox/mlx4/fw.h
#	drivers/net/ethernet/mellanox/mlx4/main.c
#	include/linux/mlx4/device.h
diff --cc drivers/net/ethernet/mellanox/mlx4/fw.c
index dadc053d0183,4a471f5d1b56..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/fw.c
+++ b/drivers/net/ethernet/mellanox/mlx4/fw.c
@@@ -138,7 -138,14 +138,18 @@@ static void dump_dev_cap_flags2(struct 
  		[13] = "Large cache line (>64B) EQE stride support",
  		[14] = "Ethernet protocol control support",
  		[15] = "Ethernet Backplane autoneg support",
++<<<<<<< HEAD
 +		[16] = "CONFIG DEV support"
++=======
+ 		[16] = "CONFIG DEV support",
+ 		[17] = "Asymmetric EQs support",
+ 		[18] = "More than 80 VFs support",
+ 		[19] = "Performance optimized for limited rule configuration flow steering support",
+ 		[20] = "Recoverable error events support",
+ 		[21] = "Port Remap support",
+ 		[22] = "QCN support",
+ 		[23] = "QP rate limiting support"
++>>>>>>> fc31e2560a24 (net/mlx4_core: Add basic support for QP max-rate limiting)
  	};
  	int i;
  
@@@ -671,6 -696,12 +682,15 @@@ int mlx4_QUERY_DEV_CAP(struct mlx4_dev 
  #define QUERY_DEV_CAP_FW_REASSIGN_MAC		0x9d
  #define QUERY_DEV_CAP_VXLAN			0x9e
  #define QUERY_DEV_CAP_MAD_DEMUX_OFFSET		0xb0
++<<<<<<< HEAD
++=======
+ #define QUERY_DEV_CAP_DMFS_HIGH_RATE_QPN_BASE_OFFSET	0xa8
+ #define QUERY_DEV_CAP_DMFS_HIGH_RATE_QPN_RANGE_OFFSET	0xac
+ #define QUERY_DEV_CAP_QP_RATE_LIMIT_NUM_OFFSET	0xcc
+ #define QUERY_DEV_CAP_QP_RATE_LIMIT_MAX_OFFSET	0xd0
+ #define QUERY_DEV_CAP_QP_RATE_LIMIT_MIN_OFFSET	0xd2
+ 
++>>>>>>> fc31e2560a24 (net/mlx4_core: Add basic support for QP max-rate limiting)
  
  	dev_cap->flags2 = 0;
  	mailbox = mlx4_alloc_cmd_mailbox(dev);
@@@ -865,6 -902,25 +885,28 @@@
  	if (field32 & (1 << 0))
  		dev_cap->flags2 |= MLX4_DEV_CAP_FLAG2_MAD_DEMUX;
  
++<<<<<<< HEAD
++=======
+ 	MLX4_GET(dev_cap->dmfs_high_rate_qpn_base, outbox,
+ 		 QUERY_DEV_CAP_DMFS_HIGH_RATE_QPN_BASE_OFFSET);
+ 	dev_cap->dmfs_high_rate_qpn_base &= MGM_QPN_MASK;
+ 	MLX4_GET(dev_cap->dmfs_high_rate_qpn_range, outbox,
+ 		 QUERY_DEV_CAP_DMFS_HIGH_RATE_QPN_RANGE_OFFSET);
+ 	dev_cap->dmfs_high_rate_qpn_range &= MGM_QPN_MASK;
+ 
+ 	MLX4_GET(size, outbox, QUERY_DEV_CAP_QP_RATE_LIMIT_NUM_OFFSET);
+ 	dev_cap->rl_caps.num_rates = size;
+ 	if (dev_cap->rl_caps.num_rates) {
+ 		dev_cap->flags2 |= MLX4_DEV_CAP_FLAG2_QP_RATE_LIMIT;
+ 		MLX4_GET(size, outbox, QUERY_DEV_CAP_QP_RATE_LIMIT_MAX_OFFSET);
+ 		dev_cap->rl_caps.max_val  = size & 0xfff;
+ 		dev_cap->rl_caps.max_unit = size >> 14;
+ 		MLX4_GET(size, outbox, QUERY_DEV_CAP_QP_RATE_LIMIT_MIN_OFFSET);
+ 		dev_cap->rl_caps.min_val  = size & 0xfff;
+ 		dev_cap->rl_caps.min_unit = size >> 14;
+ 	}
+ 
++>>>>>>> fc31e2560a24 (net/mlx4_core: Add basic support for QP max-rate limiting)
  	MLX4_GET(field32, outbox, QUERY_DEV_CAP_EXT_2_FLAGS_OFFSET);
  	if (field32 & (1 << 16))
  		dev_cap->flags2 |= MLX4_DEV_CAP_FLAG2_UPDATE_QP;
@@@ -918,6 -992,18 +960,21 @@@
  	mlx4_dbg(dev, "Max GSO size: %d\n", dev_cap->max_gso_sz);
  	mlx4_dbg(dev, "Max counters: %d\n", dev_cap->max_counters);
  	mlx4_dbg(dev, "Max RSS Table size: %d\n", dev_cap->max_rss_tbl_sz);
++<<<<<<< HEAD
++=======
+ 	mlx4_dbg(dev, "DMFS high rate steer QPn base: %d\n",
+ 		 dev_cap->dmfs_high_rate_qpn_base);
+ 	mlx4_dbg(dev, "DMFS high rate steer QPn range: %d\n",
+ 		 dev_cap->dmfs_high_rate_qpn_range);
+ 
+ 	if (dev_cap->flags2 & MLX4_DEV_CAP_FLAG2_QP_RATE_LIMIT) {
+ 		struct mlx4_rate_limit_caps *rl_caps = &dev_cap->rl_caps;
+ 
+ 		mlx4_dbg(dev, "QP Rate-Limit: #rates %d, unit/val max %d/%d, min %d/%d\n",
+ 			 rl_caps->num_rates, rl_caps->max_unit, rl_caps->max_val,
+ 			 rl_caps->min_unit, rl_caps->min_val);
+ 	}
++>>>>>>> fc31e2560a24 (net/mlx4_core: Add basic support for QP max-rate limiting)
  
  	dump_dev_cap_flags(dev, dev_cap->flags);
  	dump_dev_cap_flags2(dev, dev_cap->flags2);
@@@ -1095,6 -1180,15 +1153,18 @@@ int mlx4_QUERY_DEV_CAP_wrapper(struct m
  		     DEV_CAP_EXT_2_FLAG_FSM);
  	MLX4_PUT(outbox->buf, field32, QUERY_DEV_CAP_EXT_2_FLAGS_OFFSET);
  
++<<<<<<< HEAD
++=======
+ 	/* turn off QCN for guests */
+ 	MLX4_GET(field, outbox->buf, QUERY_DEV_CAP_ECN_QCN_VER_OFFSET);
+ 	field &= 0xfe;
+ 	MLX4_PUT(outbox->buf, field, QUERY_DEV_CAP_ECN_QCN_VER_OFFSET);
+ 
+ 	/* turn off QP max-rate limiting for guests */
+ 	field16 = 0;
+ 	MLX4_PUT(outbox->buf, field16, QUERY_DEV_CAP_QP_RATE_LIMIT_NUM_OFFSET);
+ 
++>>>>>>> fc31e2560a24 (net/mlx4_core: Add basic support for QP max-rate limiting)
  	return 0;
  }
  
diff --cc drivers/net/ethernet/mellanox/mlx4/fw.h
index d90b81c57c47,863655bd3947..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/fw.h
+++ b/drivers/net/ethernet/mellanox/mlx4/fw.h
@@@ -123,6 -125,9 +123,12 @@@ struct mlx4_dev_cap 
  	int max_gso_sz;
  	int max_rss_tbl_sz;
  	u32 max_counters;
++<<<<<<< HEAD
++=======
+ 	u32 dmfs_high_rate_qpn_base;
+ 	u32 dmfs_high_rate_qpn_range;
+ 	struct mlx4_rate_limit_caps rl_caps;
++>>>>>>> fc31e2560a24 (net/mlx4_core: Add basic support for QP max-rate limiting)
  	struct mlx4_port_cap port_cap[MLX4_MAX_PORTS + 1];
  };
  
diff --cc drivers/net/ethernet/mellanox/mlx4/main.c
index 44c2fab05ece,43aa76775b5f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/main.c
+++ b/drivers/net/ethernet/mellanox/mlx4/main.c
@@@ -438,8 -469,30 +438,33 @@@ static int mlx4_dev_cap(struct mlx4_de
  		(1 << dev->caps.log_num_vlans) *
  		dev->caps.num_ports;
  	dev->caps.reserved_qps_cnt[MLX4_QP_REGION_FC_EXCH] = MLX4_NUM_FEXCH;
++<<<<<<< HEAD
++=======
+ 
+ 	if (dev_cap->dmfs_high_rate_qpn_base > 0 &&
+ 	    dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_FS_EN)
+ 		dev->caps.dmfs_high_rate_qpn_base = dev_cap->dmfs_high_rate_qpn_base;
+ 	else
+ 		dev->caps.dmfs_high_rate_qpn_base =
+ 			dev->caps.reserved_qps_cnt[MLX4_QP_REGION_FW];
+ 
+ 	if (dev_cap->dmfs_high_rate_qpn_range > 0 &&
+ 	    dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_FS_EN) {
+ 		dev->caps.dmfs_high_rate_qpn_range = dev_cap->dmfs_high_rate_qpn_range;
+ 		dev->caps.dmfs_high_steer_mode = MLX4_STEERING_DMFS_A0_DEFAULT;
+ 		dev->caps.flags2 |= MLX4_DEV_CAP_FLAG2_FS_A0;
+ 	} else {
+ 		dev->caps.dmfs_high_steer_mode = MLX4_STEERING_DMFS_A0_NOT_SUPPORTED;
+ 		dev->caps.dmfs_high_rate_qpn_base =
+ 			dev->caps.reserved_qps_cnt[MLX4_QP_REGION_FW];
+ 		dev->caps.dmfs_high_rate_qpn_range = MLX4_A0_STEERING_TABLE_SIZE;
+ 	}
+ 
+ 	dev->caps.rl_caps = dev_cap->rl_caps;
+ 
++>>>>>>> fc31e2560a24 (net/mlx4_core: Add basic support for QP max-rate limiting)
  	dev->caps.reserved_qps_cnt[MLX4_QP_REGION_RSS_RAW_ETH] =
 -		dev->caps.dmfs_high_rate_qpn_range;
 +		MLX4_A0_STEERING_TABLE_SIZE;
  
  	dev->caps.reserved_qps = dev->caps.reserved_qps_cnt[MLX4_QP_REGION_FW] +
  		dev->caps.reserved_qps_cnt[MLX4_QP_REGION_ETH_ADDR] +
diff --cc include/linux/mlx4/device.h
index d69c0aafc158,4550c67b92e4..000000000000
--- a/include/linux/mlx4/device.h
+++ b/include/linux/mlx4/device.h
@@@ -190,7 -198,14 +190,18 @@@ enum 
  	MLX4_DEV_CAP_FLAG2_EQE_STRIDE		= 1LL <<  13,
  	MLX4_DEV_CAP_FLAG2_ETH_PROT_CTRL        = 1LL <<  14,
  	MLX4_DEV_CAP_FLAG2_ETH_BACKPL_AN_REP	= 1LL <<  15,
++<<<<<<< HEAD
 +	MLX4_DEV_CAP_FLAG2_CONFIG_DEV		= 1LL <<  16
++=======
+ 	MLX4_DEV_CAP_FLAG2_CONFIG_DEV		= 1LL <<  16,
+ 	MLX4_DEV_CAP_FLAG2_SYS_EQS		= 1LL <<  17,
+ 	MLX4_DEV_CAP_FLAG2_80_VFS		= 1LL <<  18,
+ 	MLX4_DEV_CAP_FLAG2_FS_A0		= 1LL <<  19,
+ 	MLX4_DEV_CAP_FLAG2_RECOVERABLE_ERROR_EVENT = 1LL << 20,
+ 	MLX4_DEV_CAP_FLAG2_PORT_REMAP		= 1LL <<  21,
+ 	MLX4_DEV_CAP_FLAG2_QCN			= 1LL <<  22,
+ 	MLX4_DEV_CAP_FLAG2_QP_RATE_LIMIT	= 1LL <<  23
++>>>>>>> fc31e2560a24 (net/mlx4_core: Add basic support for QP max-rate limiting)
  };
  
  enum {
@@@ -520,6 -578,10 +546,13 @@@ struct mlx4_caps 
  	int			tunnel_offload_mode;
  	u8			rx_checksum_flags_port[MLX4_MAX_PORTS + 1];
  	u8			alloc_res_qp_mask;
++<<<<<<< HEAD
++=======
+ 	u32			dmfs_high_rate_qpn_base;
+ 	u32			dmfs_high_rate_qpn_range;
+ 	u32			vf_caps;
+ 	struct mlx4_rate_limit_caps rl_caps;
++>>>>>>> fc31e2560a24 (net/mlx4_core: Add basic support for QP max-rate limiting)
  };
  
  struct mlx4_buf_list {
* Unmerged path drivers/net/ethernet/mellanox/mlx4/fw.c
* Unmerged path drivers/net/ethernet/mellanox/mlx4/fw.h
* Unmerged path drivers/net/ethernet/mellanox/mlx4/main.c
diff --git a/drivers/net/ethernet/mellanox/mlx4/qp.c b/drivers/net/ethernet/mellanox/mlx4/qp.c
index 3fe90ced81ce..86b7af4cf2cf 100644
--- a/drivers/net/ethernet/mellanox/mlx4/qp.c
+++ b/drivers/net/ethernet/mellanox/mlx4/qp.c
@@ -443,6 +443,11 @@ int mlx4_update_qp(struct mlx4_dev *dev, u32 qpn,
 			cmd->qp_context.param3 |= cpu_to_be32(MLX4_STRIP_VLAN);
 	}
 
+	if (attr & MLX4_UPDATE_QP_RATE_LIMIT) {
+		qp_mask |= 1ULL << MLX4_UPD_QP_MASK_RATE_LIMIT;
+		cmd->qp_context.rate_limit_params = cpu_to_be16((params->rate_unit << 14) | params->rate_val);
+	}
+
 	cmd->primary_addr_path_mask = cpu_to_be64(pri_addr_path_mask);
 	cmd->qp_mask = cpu_to_be64(qp_mask);
 
diff --git a/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c b/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c
index 1f7fecb33088..198e86909480 100644
--- a/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c
+++ b/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c
@@ -2937,8 +2937,12 @@ static int verify_qp_parameters(struct mlx4_dev *dev,
 	qp_type	= (be32_to_cpu(qp_ctx->flags) >> 16) & 0xff;
 	optpar	= be32_to_cpu(*(__be32 *) inbox->buf);
 
-	if (slave != mlx4_master_func_num(dev))
+	if (slave != mlx4_master_func_num(dev)) {
 		qp_ctx->params2 &= ~MLX4_QP_BIT_FPP;
+		/* setting QP rate-limit is disallowed for VFs */
+		if (qp_ctx->rate_limit_params)
+			return -EPERM;
+	}
 
 	switch (qp_type) {
 	case MLX4_QP_ST_RC:
* Unmerged path include/linux/mlx4/device.h
diff --git a/include/linux/mlx4/qp.h b/include/linux/mlx4/qp.h
index 6ce99be3ebee..3204345b67c6 100644
--- a/include/linux/mlx4/qp.h
+++ b/include/linux/mlx4/qp.h
@@ -204,14 +204,16 @@ struct mlx4_qp_context {
 	__be32			msn;
 	__be16			rq_wqe_counter;
 	__be16			sq_wqe_counter;
-	u32			reserved3[2];
+	u32			reserved3;
+	__be16			rate_limit_params;
+	__be16			reserved4;
 	__be32			param3;
 	__be32			nummmcpeers_basemkey;
 	u8			log_page_size;
-	u8			reserved4[2];
+	u8			reserved5[2];
 	u8			mtt_base_addr_h;
 	__be32			mtt_base_addr_l;
-	u32			reserved5[10];
+	u32			reserved6[10];
 };
 
 struct mlx4_update_qp_context {
@@ -226,6 +228,7 @@ struct mlx4_update_qp_context {
 enum {
 	MLX4_UPD_QP_MASK_PM_STATE	= 32,
 	MLX4_UPD_QP_MASK_VSD		= 33,
+	MLX4_UPD_QP_MASK_RATE_LIMIT	= 35,
 };
 
 enum {
@@ -425,7 +428,8 @@ struct mlx4_wqe_inline_seg {
 enum mlx4_update_qp_attr {
 	MLX4_UPDATE_QP_SMAC		= 1 << 0,
 	MLX4_UPDATE_QP_VSD		= 1 << 1,
-	MLX4_UPDATE_QP_SUPPORTED_ATTRS	= (1 << 2) - 1
+	MLX4_UPDATE_QP_RATE_LIMIT	= 1 << 2,
+	MLX4_UPDATE_QP_SUPPORTED_ATTRS	= (1 << 3) - 1
 };
 
 enum mlx4_update_qp_params_flags {
@@ -435,6 +439,8 @@ enum mlx4_update_qp_params_flags {
 struct mlx4_update_qp_params {
 	u8	smac_index;
 	u32	flags;
+	u16	rate_unit;
+	u16	rate_val;
 };
 
 int mlx4_update_qp(struct mlx4_dev *dev, u32 qpn,
