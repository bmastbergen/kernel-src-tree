IB/iser: Extend iser_free_ib_conn_res()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [infiniband] iser: Extend iser_free_ib_conn_res() (Amir Vadai) [1164539]
Rebuild_FUZZ: 96.00%
commit-author Sagi Grimberg <sagig@mellanox.com>
commit 96f15198c1457df29b51ed151b1e5b2a223d1346
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/96f15198.failed

Put all connection IB related resources release in this routine.  One
exception is the cm_id which cannot be destroyed as the routine is
protected by the state mutex.  Also move its position to avoid forward
declaration.  While at it fix qp NULL assignment.

	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Ariel Nahum <arieln@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Roland Dreier <roland@purestorage.com>
(cherry picked from commit 96f15198c1457df29b51ed151b1e5b2a223d1346)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/iser/iser_verbs.c
diff --cc drivers/infiniband/ulp/iser/iser_verbs.c
index fbf2a1e0f2e2,e4299743c459..000000000000
--- a/drivers/infiniband/ulp/iser/iser_verbs.c
+++ b/drivers/infiniband/ulp/iser/iser_verbs.c
@@@ -501,30 -496,6 +501,33 @@@ out_err
  }
  
  /**
++<<<<<<< HEAD
 + * releases the QP object
 + */
 +static void iser_free_ib_conn_res(struct iser_conn *ib_conn)
 +{
 +	int cq_index;
 +	BUG_ON(ib_conn == NULL);
 +
 +	iser_info("freeing conn %p cma_id %p qp %p\n",
 +		  ib_conn, ib_conn->cma_id,
 +		  ib_conn->qp);
 +
 +	/* qp is created only once both addr & route are resolved */
 +
 +	if (ib_conn->qp != NULL) {
 +		cq_index = ((struct iser_cq_desc *)ib_conn->qp->recv_cq->cq_context)->cq_index;
 +		ib_conn->device->cq_active_qps[cq_index]--;
 +
 +		rdma_destroy_qp(ib_conn->cma_id);
 +	}
 +
 +	ib_conn->qp	  = NULL;
 +}
 +
 +/**
++=======
++>>>>>>> 96f15198c145 (IB/iser: Extend iser_free_ib_conn_res())
   * based on the resolved device node GUID see if there already allocated
   * device for this device. If there's no such, create one.
   */
@@@ -601,41 -574,64 +604,82 @@@ void iser_release_work(struct work_stru
  	WARN_ON(rc == 0);
  
  	/* wait for the qp`s post send and post receive buffers to empty */
 -	rc = wait_for_completion_timeout(&iser_conn->flush_completion, 30 * HZ);
 +	rc = wait_for_completion_timeout(&ib_conn->flush_completion, 30 * HZ);
  	WARN_ON(rc == 0);
  
 -	iser_conn->state = ISER_CONN_DOWN;
 +	ib_conn->state = ISER_CONN_DOWN;
  
 -	mutex_lock(&iser_conn->state_mutex);
 -	iser_conn->state = ISER_CONN_DOWN;
 -	mutex_unlock(&iser_conn->state_mutex);
 +	mutex_lock(&ib_conn->state_mutex);
 +	ib_conn->state = ISER_CONN_DOWN;
 +	mutex_unlock(&ib_conn->state_mutex);
  
 -	iser_conn_release(iser_conn);
 +	iser_conn_release(ib_conn);
  }
  
+ /**
+  * iser_free_ib_conn_res - release IB related resources
+  * @iser_conn: iser connection struct
+  *
+  * This routine is called with the iser state mutex held
+  * so the cm_id removal is out of here. It is Safe to
+  * be invoked multiple times.
+  */
+ static void iser_free_ib_conn_res(struct iser_conn *iser_conn)
+ {
+ 	struct ib_conn *ib_conn = &iser_conn->ib_conn;
+ 	struct iser_device *device = ib_conn->device;
+ 
+ 	iser_info("freeing conn %p cma_id %p qp %p\n",
+ 		  iser_conn, ib_conn->cma_id, ib_conn->qp);
+ 
+ 	iser_free_rx_descriptors(iser_conn);
+ 
+ 	if (ib_conn->qp != NULL) {
+ 		ib_conn->device->cq_active_qps[ib_conn->cq_index]--;
+ 		rdma_destroy_qp(ib_conn->cma_id);
+ 		ib_conn->qp = NULL;
+ 	}
+ 
+ 	if (device != NULL) {
+ 		iser_device_try_release(device);
+ 		ib_conn->device = NULL;
+ 	}
+ }
+ 
  /**
   * Frees all conn objects and deallocs conn descriptor
   */
 -void iser_conn_release(struct iser_conn *iser_conn)
 +void iser_conn_release(struct iser_conn *ib_conn)
  {
++<<<<<<< HEAD
 +	struct iser_device  *device = ib_conn->device;
++=======
+ 	struct ib_conn *ib_conn = &iser_conn->ib_conn;
++>>>>>>> 96f15198c145 (IB/iser: Extend iser_free_ib_conn_res())
  
  	mutex_lock(&ig.connlist_mutex);
 -	list_del(&iser_conn->conn_list);
 +	list_del(&ib_conn->conn_list);
  	mutex_unlock(&ig.connlist_mutex);
  
++<<<<<<< HEAD
 +	mutex_lock(&ib_conn->state_mutex);
 +	BUG_ON(ib_conn->state != ISER_CONN_DOWN);
 +
 +	iser_free_rx_descriptors(ib_conn);
 +	iser_free_ib_conn_res(ib_conn);
 +	ib_conn->device = NULL;
 +	/* on EVENT_ADDR_ERROR there's no device yet for this conn */
 +	if (device != NULL)
 +		iser_device_try_release(device);
 +	mutex_unlock(&ib_conn->state_mutex);
++=======
+ 	mutex_lock(&iser_conn->state_mutex);
+ 	BUG_ON(iser_conn->state != ISER_CONN_DOWN);
+ 	iser_free_ib_conn_res(iser_conn);
+ 	mutex_unlock(&iser_conn->state_mutex);
++>>>>>>> 96f15198c145 (IB/iser: Extend iser_free_ib_conn_res())
  
 +	/* if cma handler context, the caller actually destroy the id */
  	if (ib_conn->cma_id != NULL) {
  		rdma_destroy_id(ib_conn->cma_id);
  		ib_conn->cma_id = NULL;
* Unmerged path drivers/infiniband/ulp/iser/iser_verbs.c
