bonding: Convert memcpy(foo, bar, ETH_ALEN) to ether_addr_copy(foo, bar)

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Joe Perches <joe@perches.com>
commit ada0f8633c5b8dad640e1a2bcb95499ec187ac17
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/ada0f863.failed

ether_addr_copy is smaller and faster for some architectures.

This relies on a stack frame being at least __aligned(2)
for one use of an Ethernet address on the stack.

	Signed-off-by: Joe Perches <joe@perches.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ada0f8633c5b8dad640e1a2bcb95499ec187ac17)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_3ad.c
#	drivers/net/bonding/bond_alb.c
diff --cc drivers/net/bonding/bond_3ad.c
index dc508c87249d,e9edd8473df6..000000000000
--- a/drivers/net/bonding/bond_3ad.c
+++ b/drivers/net/bonding/bond_3ad.c
@@@ -841,13 -768,14 +841,19 @@@ static int ad_lacpdu_send(struct port *
  
  	lacpdu_header = (struct lacpdu_header *)skb_put(skb, length);
  
- 	memcpy(lacpdu_header->hdr.h_dest, lacpdu_mcast_addr, ETH_ALEN);
+ 	ether_addr_copy(lacpdu_header->hdr.h_dest, lacpdu_mcast_addr);
  	/* Note: source address is set to be the member's PERMANENT address,
++<<<<<<< HEAD
 +	   because we use it to identify loopback lacpdus in receive. */
 +	memcpy(lacpdu_header->hdr.h_source, slave->perm_hwaddr, ETH_ALEN);
++=======
+ 	 * because we use it to identify loopback lacpdus in receive.
+ 	 */
+ 	ether_addr_copy(lacpdu_header->hdr.h_source, slave->perm_hwaddr);
++>>>>>>> ada0f8633c5b (bonding: Convert memcpy(foo, bar, ETH_ALEN) to ether_addr_copy(foo, bar))
  	lacpdu_header->hdr.h_proto = PKT_TYPE_LACPDU;
  
 -	lacpdu_header->lacpdu = port->lacpdu;
 +	lacpdu_header->lacpdu = port->lacpdu; // struct copy
  
  	dev_queue_xmit(skb);
  
@@@ -882,13 -810,14 +888,19 @@@ static int ad_marker_send(struct port *
  
  	marker_header = (struct bond_marker_header *)skb_put(skb, length);
  
- 	memcpy(marker_header->hdr.h_dest, lacpdu_mcast_addr, ETH_ALEN);
+ 	ether_addr_copy(marker_header->hdr.h_dest, lacpdu_mcast_addr);
  	/* Note: source address is set to be the member's PERMANENT address,
++<<<<<<< HEAD
 +	   because we use it to identify loopback MARKERs in receive. */
 +	memcpy(marker_header->hdr.h_source, slave->perm_hwaddr, ETH_ALEN);
++=======
+ 	 * because we use it to identify loopback MARKERs in receive.
+ 	 */
+ 	ether_addr_copy(marker_header->hdr.h_source, slave->perm_hwaddr);
++>>>>>>> ada0f8633c5b (bonding: Convert memcpy(foo, bar, ETH_ALEN) to ether_addr_copy(foo, bar))
  	marker_header->hdr.h_proto = PKT_TYPE_LACPDU;
  
 -	marker_header->marker = *marker;
 +	marker_header->marker = *marker; // struct copy
  
  	dev_queue_xmit(skb);
  
diff --cc drivers/net/bonding/bond_alb.c
index c0b6155b648d,538913e62715..000000000000
--- a/drivers/net/bonding/bond_alb.c
+++ b/drivers/net/bonding/bond_alb.c
@@@ -729,9 -762,8 +729,14 @@@ static struct slave *rlb_arp_xmit(struc
  		* rx channel
  		*/
  		tx_slave = rlb_choose_channel(skb, bond);
++<<<<<<< HEAD
 +		if (tx_slave) {
 +			memcpy(arp->mac_src, tx_slave->dev->dev_addr, ETH_ALEN);
 +		}
++=======
+ 		if (tx_slave)
+ 			ether_addr_copy(arp->mac_src, tx_slave->dev->dev_addr);
++>>>>>>> ada0f8633c5b (bonding: Convert memcpy(foo, bar, ETH_ALEN) to ether_addr_copy(foo, bar))
  		pr_debug("Server sent ARP Reply packet\n");
  	} else if (arp->op_code == htons(ARPOP_REQUEST)) {
  		/* Create an entry in the rx_hashtbl for this client as a
@@@ -1242,19 -1272,18 +1247,19 @@@ static int alb_handle_addr_collision_on
   */
  static int alb_set_mac_address(struct bonding *bond, void *addr)
  {
 -	struct slave *slave, *rollback_slave;
 -	struct list_head *iter;
  	struct sockaddr sa;
 +	struct slave *slave, *stop_at;
  	char tmp_addr[ETH_ALEN];
  	int res;
 +	int i;
  
 -	if (bond->alb_info.rlb_enabled)
 +	if (bond->alb_info.rlb_enabled) {
  		return 0;
 +	}
  
 -	bond_for_each_slave(bond, slave, iter) {
 +	bond_for_each_slave(bond, slave, i) {
  		/* save net_device's current hw address */
- 		memcpy(tmp_addr, slave->dev->dev_addr, ETH_ALEN);
+ 		ether_addr_copy(tmp_addr, slave->dev->dev_addr);
  
  		res = dev_set_mac_address(slave->dev, addr);
  
@@@ -1272,11 -1301,12 +1277,20 @@@ unwind
  	sa.sa_family = bond->dev->type;
  
  	/* unwind from head to the slave that failed */
++<<<<<<< HEAD
 +	stop_at = slave;
 +	bond_for_each_slave_from_to(bond, slave, i, bond->first_slave, stop_at) {
 +		memcpy(tmp_addr, slave->dev->dev_addr, ETH_ALEN);
 +		dev_set_mac_address(slave->dev, &sa);
 +		memcpy(slave->dev->dev_addr, tmp_addr, ETH_ALEN);
++=======
+ 	bond_for_each_slave(bond, rollback_slave, iter) {
+ 		if (rollback_slave == slave)
+ 			break;
+ 		ether_addr_copy(tmp_addr, rollback_slave->dev->dev_addr);
+ 		dev_set_mac_address(rollback_slave->dev, &sa);
+ 		ether_addr_copy(rollback_slave->dev->dev_addr, tmp_addr);
++>>>>>>> ada0f8633c5b (bonding: Convert memcpy(foo, bar, ETH_ALEN) to ether_addr_copy(foo, bar))
  	}
  
  	return res;
* Unmerged path drivers/net/bonding/bond_3ad.c
* Unmerged path drivers/net/bonding/bond_alb.c
diff --git a/drivers/net/bonding/bond_main.c b/drivers/net/bonding/bond_main.c
index 4c3b4d213395..0c81ee9291aa 100644
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@ -895,12 +895,12 @@ static void bond_do_fail_over_mac(struct bonding *bond,
 		write_unlock_bh(&bond->curr_slave_lock);
 
 		if (old_active) {
-			memcpy(tmp_mac, new_active->dev->dev_addr, ETH_ALEN);
+			ether_addr_copy(tmp_mac, new_active->dev->dev_addr);
 			memcpy(saddr.sa_data, old_active->dev->dev_addr,
 			       ETH_ALEN);
 			saddr.sa_family = new_active->dev->type;
 		} else {
-			memcpy(saddr.sa_data, bond->dev->dev_addr, ETH_ALEN);
+			ether_addr_copy(saddr.sa_data, bond->dev->dev_addr);
 			saddr.sa_family = bond->dev->type;
 		}
 
@@ -914,7 +914,7 @@ static void bond_do_fail_over_mac(struct bonding *bond,
 		if (!old_active)
 			goto out;
 
-		memcpy(saddr.sa_data, tmp_mac, ETH_ALEN);
+		ether_addr_copy(saddr.sa_data, tmp_mac);
 		saddr.sa_family = old_active->dev->type;
 
 		rv = dev_set_mac_address(old_active->dev, &saddr);
@@ -1606,7 +1606,7 @@ int bond_enslave(struct net_device *bond_dev, struct net_device *slave_dev)
 	 * that need it, and for restoring it upon release, and then
 	 * set it to the master's address
 	 */
-	memcpy(new_slave->perm_hwaddr, slave_dev->dev_addr, ETH_ALEN);
+	ether_addr_copy(new_slave->perm_hwaddr, slave_dev->dev_addr);
 
 	if (!bond->params.fail_over_mac) {
 		/*
@@ -1888,7 +1888,7 @@ err_restore_mac:
 		 * MAC if this slave's MAC is in use by the bond, or at
 		 * least print a warning.
 		 */
-		memcpy(addr.sa_data, new_slave->perm_hwaddr, ETH_ALEN);
+		ether_addr_copy(addr.sa_data, new_slave->perm_hwaddr);
 		addr.sa_family = slave_dev->type;
 		dev_set_mac_address(slave_dev, &addr);
 	}
@@ -2082,7 +2082,7 @@ static int __bond_release_one(struct net_device *bond_dev,
 
 	if (bond->params.fail_over_mac != BOND_FOM_ACTIVE) {
 		/* restore original ("permanent") mac address */
-		memcpy(addr.sa_data, slave->perm_hwaddr, ETH_ALEN);
+		ether_addr_copy(addr.sa_data, slave->perm_hwaddr);
 		addr.sa_family = slave_dev->type;
 		dev_set_mac_address(slave_dev, &addr);
 	}
