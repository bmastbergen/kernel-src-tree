regmap: rbtree: Use range information to allocate nodes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Mark Brown <broonie@opensource.wolfsonmicro.com>
commit 7278af5fb3eb7247449fd4489dacb75b9ba86f73
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/7278af5f.failed

If range information has been provided then when we allocate a rbnode
within a range allocate the entire range. The goal is to minimise the
number of reallocations done when combining or extending blocks. At
present only readability and yes_ranges are taken into account, this is
expected to cover most cases efficiently.

	Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
(cherry picked from commit 7278af5fb3eb7247449fd4489dacb75b9ba86f73)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/regmap/regcache-rbtree.c
diff --cc drivers/base/regmap/regcache-rbtree.c
index bb8c3bbc7812,4e131c5df844..000000000000
--- a/drivers/base/regmap/regcache-rbtree.c
+++ b/drivers/base/regmap/regcache-rbtree.c
@@@ -304,6 -304,48 +304,51 @@@ static int regcache_rbtree_insert_to_bl
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static struct regcache_rbtree_node *
+ regcache_rbtree_node_alloc(struct regmap *map, unsigned int reg)
+ {
+ 	struct regcache_rbtree_node *rbnode;
+ 	const struct regmap_range *range;
+ 	int i;
+ 
+ 	rbnode = kzalloc(sizeof(*rbnode), GFP_KERNEL);
+ 	if (!rbnode)
+ 		return NULL;
+ 
+ 	/* If there is a read table then use it to guess at an allocation */
+ 	if (map->rd_table) {
+ 		for (i = 0; i < map->rd_table->n_yes_ranges; i++) {
+ 			if (regmap_reg_in_range(reg,
+ 						&map->rd_table->yes_ranges[i]))
+ 				break;
+ 		}
+ 
+ 		if (i != map->rd_table->n_yes_ranges) {
+ 			range = &map->rd_table->yes_ranges[i];
+ 			rbnode->blklen = range->range_max - range->range_min
+ 				+ 1;
+ 			rbnode->base_reg = range->range_min;
+ 		}
+ 	}
+ 
+ 	if (!rbnode->blklen) {
+ 		rbnode->blklen = sizeof(*rbnode);
+ 		rbnode->base_reg = reg;
+ 	}
+ 
+ 	rbnode->block = kmalloc(rbnode->blklen * map->cache_word_size,
+ 				GFP_KERNEL);
+ 	if (!rbnode->block) {
+ 		kfree(rbnode);
+ 		return NULL;
+ 	}
+ 
+ 	return rbnode;
+ }
+ 
++>>>>>>> 7278af5fb3eb (regmap: rbtree: Use range information to allocate nodes)
  static int regcache_rbtree_write(struct regmap *map, unsigned int reg,
  				 unsigned int value)
  {
* Unmerged path drivers/base/regmap/regcache-rbtree.c
