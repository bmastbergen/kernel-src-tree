dcache: Handle escaped paths in prepend_path

jira LE-1907
cve CVE-2015-2925
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit cde93be45a8a90d8c264c776fab63487b5038a65
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/cde93be4.failed

A rename can result in a dentry that by walking up d_parent
will never reach it's mnt_root.  For lack of a better term
I call this an escaped path.

prepend_path is called by four different functions __d_path,
d_absolute_path, d_path, and getcwd.

__d_path only wants to see paths are connected to the root it passes
in.  So __d_path needs prepend_path to return an error.

d_absolute_path similarly wants to see paths that are connected to
some root.  Escaped paths are not connected to any mnt_root so
d_absolute_path needs prepend_path to return an error greater
than 1.  So escaped paths will be treated like paths on lazily
unmounted mounts.

getcwd needs to prepend "(unreachable)" so getcwd also needs
prepend_path to return an error.

d_path is the interesting hold out.  d_path just wants to print
something, and does not care about the weird cases.  Which raises
the question what should be printed?

Given that <escaped_path>/<anything> should result in -ENOENT I
believe it is desirable for escaped paths to be printed as empty
paths.  As there are not really any meaninful path components when
considered from the perspective of a mount tree.

So tweak prepend_path to return an empty path with an new error
code of 3 when it encounters an escaped path.

	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit cde93be45a8a90d8c264c776fab63487b5038a65)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dcache.c
diff --cc fs/dcache.c
index 3af919733a87,e3b44ca75a1b..000000000000
--- a/fs/dcache.c
+++ b/fs/dcache.c
@@@ -2782,10 -2925,18 +2782,21 @@@ restart
  		struct dentry * parent;
  
  		if (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {
++<<<<<<< HEAD
++=======
+ 			struct mount *parent = ACCESS_ONCE(mnt->mnt_parent);
+ 			/* Escaped? */
+ 			if (dentry != vfsmnt->mnt_root) {
+ 				bptr = *buffer;
+ 				blen = *buflen;
+ 				error = 3;
+ 				break;
+ 			}
++>>>>>>> cde93be45a8a (dcache: Handle escaped paths in prepend_path)
  			/* Global root? */
 -			if (mnt != parent) {
 -				dentry = ACCESS_ONCE(mnt->mnt_mountpoint);
 -				mnt = parent;
 +			if (mnt_has_parent(mnt)) {
 +				dentry = mnt->mnt_mountpoint;
 +				mnt = mnt->mnt_parent;
  				vfsmnt = &mnt->mnt;
  				continue;
  			}
* Unmerged path fs/dcache.c
