fib_trie: Move fib_find_alias to file where it is used

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Alexander Duyck <alexander.h.duyck@redhat.com>
commit 02525368f48c197bce6e4251ff7bde92fa6f026e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/02525368.failed

The function fib_find_alias is only accessed by functions in fib_trie.c as
such it makes sense to relocate it and cast it as static so that the
compiler can take advantage of optimizations it can do to it as a local
function.

	Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 02525368f48c197bce6e4251ff7bde92fa6f026e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/fib_lookup.h
#	net/ipv4/fib_semantics.c
diff --cc net/ipv4/fib_lookup.h
index af0f14aba169,825981b1049a..000000000000
--- a/net/ipv4/fib_lookup.h
+++ b/net/ipv4/fib_lookup.h
@@@ -24,21 -24,14 +24,32 @@@ static inline void fib_alias_accessed(s
  }
  
  /* Exported by fib_semantics.c */
++<<<<<<< HEAD
 +extern void fib_release_info(struct fib_info *);
 +extern struct fib_info *fib_create_info(struct fib_config *cfg);
 +extern int fib_nh_match(struct fib_config *cfg, struct fib_info *fi);
 +extern int fib_dump_info(struct sk_buff *skb, u32 pid, u32 seq, int event,
 +			 u32 tb_id, u8 type, __be32 dst,
 +			 int dst_len, u8 tos, struct fib_info *fi,
 +			 unsigned int);
 +extern void rtmsg_fib(int event, __be32 key, struct fib_alias *fa,
 +		      int dst_len, u32 tb_id, struct nl_info *info,
 +		      unsigned int nlm_flags);
 +extern struct fib_alias *fib_find_alias(struct list_head *fah,
 +					u8 tos, u32 prio);
 +extern int fib_detect_death(struct fib_info *fi, int order,
 +			    struct fib_info **last_resort,
 +			    int *last_idx, int dflt);
++=======
+ void fib_release_info(struct fib_info *);
+ struct fib_info *fib_create_info(struct fib_config *cfg);
+ int fib_nh_match(struct fib_config *cfg, struct fib_info *fi);
+ int fib_dump_info(struct sk_buff *skb, u32 pid, u32 seq, int event, u32 tb_id,
+ 		  u8 type, __be32 dst, int dst_len, u8 tos, struct fib_info *fi,
+ 		  unsigned int);
+ void rtmsg_fib(int event, __be32 key, struct fib_alias *fa, int dst_len,
+ 	       u32 tb_id, const struct nl_info *info, unsigned int nlm_flags);
++>>>>>>> 02525368f48c (fib_trie: Move fib_find_alias to file where it is used)
  
  static inline void fib_result_assign(struct fib_result *res,
  				     struct fib_info *fi)
diff --cc net/ipv4/fib_semantics.c
index b6c8c98fb7b5,1e2090ea663e..000000000000
--- a/net/ipv4/fib_semantics.c
+++ b/net/ipv4/fib_semantics.c
@@@ -409,26 -411,9 +409,32 @@@ errout
  		rtnl_set_sk_err(info->nl_net, RTNLGRP_IPV4_ROUTE, err);
  }
  
++<<<<<<< HEAD
 +/* Return the first fib alias matching TOS with
 + * priority less than or equal to PRIO.
 + */
 +struct fib_alias *fib_find_alias(struct list_head *fah, u8 tos, u32 prio)
 +{
 +	if (fah) {
 +		struct fib_alias *fa;
 +		list_for_each_entry(fa, fah, fa_list) {
 +			if (fa->fa_tos > tos)
 +				continue;
 +			if (fa->fa_info->fib_priority >= prio ||
 +			    fa->fa_tos < tos)
 +				return fa;
 +		}
 +	}
 +	return NULL;
 +}
 +
 +int fib_detect_death(struct fib_info *fi, int order,
 +		     struct fib_info **last_resort, int *last_idx, int dflt)
++=======
+ static int fib_detect_death(struct fib_info *fi, int order,
+ 			    struct fib_info **last_resort, int *last_idx,
+ 			    int dflt)
++>>>>>>> 02525368f48c (fib_trie: Move fib_find_alias to file where it is used)
  {
  	struct neighbour *n;
  	int state = NUD_NONE;
* Unmerged path net/ipv4/fib_lookup.h
* Unmerged path net/ipv4/fib_semantics.c
diff --git a/net/ipv4/fib_trie.c b/net/ipv4/fib_trie.c
index e2ec97dd788f..277e1b2bea8f 100644
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@ -1009,6 +1009,26 @@ static struct tnode *fib_find_node(struct trie *t, u32 key)
 	return n;
 }
 
+/* Return the first fib alias matching TOS with
+ * priority less than or equal to PRIO.
+ */
+static struct fib_alias *fib_find_alias(struct list_head *fah, u8 tos, u32 prio)
+{
+	struct fib_alias *fa;
+
+	if (!fah)
+		return NULL;
+
+	list_for_each_entry(fa, fah, fa_list) {
+		if (fa->fa_tos > tos)
+			continue;
+		if (fa->fa_info->fib_priority >= prio || fa->fa_tos < tos)
+			return fa;
+	}
+
+	return NULL;
+}
+
 static void trie_rebalance(struct trie *t, struct tnode *tn)
 {
 	struct tnode *tp;
