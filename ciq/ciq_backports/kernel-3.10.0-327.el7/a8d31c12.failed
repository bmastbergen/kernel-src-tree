gue: Receive side of remote checksum offload

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Tom Herbert <therbert@google.com>
commit a8d31c128bf574bed2fa29e0512b24d446018a50
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/a8d31c12.failed

Add processing of the remote checksum offload option in both the normal
path as well as the GRO path. The implements patching the affected
checksum to derive the offloaded checksum.

	Signed-off-by: Tom Herbert <therbert@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a8d31c128bf574bed2fa29e0512b24d446018a50)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/fou.c
diff --cc net/ipv4/fou.c
index 32e78924e246,740ae099a0d9..000000000000
--- a/net/ipv4/fou.c
+++ b/net/ipv4/fou.c
@@@ -62,16 -58,78 +62,87 @@@ static int fou_udp_recv(struct sock *sk
  	if (!fou)
  		return 1;
  
++<<<<<<< HEAD
 +	return fou_udp_encap_recv_deliver(skb, fou->protocol,
 +					  sizeof(struct udphdr));
++=======
+ 	fou_recv_pull(skb, sizeof(struct udphdr));
+ 
+ 	return -fou->protocol;
+ }
+ 
+ static struct guehdr *gue_remcsum(struct sk_buff *skb, struct guehdr *guehdr,
+ 				  void *data, int hdrlen, u8 ipproto)
+ {
+ 	__be16 *pd = data;
+ 	u16 start = ntohs(pd[0]);
+ 	u16 offset = ntohs(pd[1]);
+ 	u16 poffset = 0;
+ 	u16 plen;
+ 	__wsum csum, delta;
+ 	__sum16 *psum;
+ 
+ 	if (skb->remcsum_offload) {
+ 		/* Already processed in GRO path */
+ 		skb->remcsum_offload = 0;
+ 		return guehdr;
+ 	}
+ 
+ 	if (start > skb->len - hdrlen ||
+ 	    offset > skb->len - hdrlen - sizeof(u16))
+ 		return NULL;
+ 
+ 	if (unlikely(skb->ip_summed != CHECKSUM_COMPLETE))
+ 		__skb_checksum_complete(skb);
+ 
+ 	plen = hdrlen + offset + sizeof(u16);
+ 	if (!pskb_may_pull(skb, plen))
+ 		return NULL;
+ 	guehdr = (struct guehdr *)&udp_hdr(skb)[1];
+ 
+ 	if (ipproto == IPPROTO_IP && sizeof(struct iphdr) < plen) {
+ 		struct iphdr *ip = (struct iphdr *)(skb->data + hdrlen);
+ 
+ 		/* If next header happens to be IP we can skip that for the
+ 		 * checksum calculation since the IP header checksum is zero
+ 		 * if correct.
+ 		 */
+ 		poffset = ip->ihl * 4;
+ 	}
+ 
+ 	csum = csum_sub(skb->csum, skb_checksum(skb, poffset + hdrlen,
+ 						start - poffset - hdrlen, 0));
+ 
+ 	/* Set derived checksum in packet */
+ 	psum = (__sum16 *)(skb->data + hdrlen + offset);
+ 	delta = csum_sub(csum_fold(csum), *psum);
+ 	*psum = csum_fold(csum);
+ 
+ 	/* Adjust skb->csum since we changed the packet */
+ 	skb->csum = csum_add(skb->csum, delta);
+ 
+ 	return guehdr;
+ }
+ 
+ static int gue_control_message(struct sk_buff *skb, struct guehdr *guehdr)
+ {
+ 	/* No support yet */
+ 	kfree_skb(skb);
+ 	return 0;
++>>>>>>> a8d31c128bf5 (gue: Receive side of remote checksum offload)
  }
  
  static int gue_udp_recv(struct sock *sk, struct sk_buff *skb)
  {
  	struct fou *fou = fou_from_sock(sk);
 -	size_t len, optlen, hdrlen;
 +	size_t len;
  	struct guehdr *guehdr;
++<<<<<<< HEAD
 +	struct udphdr *uh;
++=======
+ 	void *data;
+ 	u16 doffset = 0;
++>>>>>>> a8d31c128bf5 (gue: Receive side of remote checksum offload)
  
  	if (!fou)
  		return 1;
@@@ -87,18 -146,53 +158,60 @@@
  	if (!pskb_may_pull(skb, len))
  		goto drop;
  
 -	/* guehdr may change after pull */
 -	guehdr = (struct guehdr *)&udp_hdr(skb)[1];
 +	uh = udp_hdr(skb);
 +	guehdr = (struct guehdr *)&uh[1];
  
 -	hdrlen = sizeof(struct guehdr) + optlen;
 +	if (guehdr->version != 0)
 +		goto drop;
  
 -	if (guehdr->version != 0 || validate_gue_flags(guehdr, optlen))
++<<<<<<< HEAD
 +	if (guehdr->flags) {
 +		/* No support yet */
  		goto drop;
 +	}
  
 +	return fou_udp_encap_recv_deliver(skb, guehdr->next_hdr, len);
++=======
+ 	hdrlen = sizeof(struct guehdr) + optlen;
+ 
+ 	ip_hdr(skb)->tot_len = htons(ntohs(ip_hdr(skb)->tot_len) - len);
+ 
+ 	/* Pull UDP header now, skb->data points to guehdr */
+ 	__skb_pull(skb, sizeof(struct udphdr));
+ 
+ 	/* Pull csum through the guehdr now . This can be used if
+ 	 * there is a remote checksum offload.
+ 	 */
+ 	skb_postpull_rcsum(skb, udp_hdr(skb), len);
+ 
+ 	data = &guehdr[1];
+ 
+ 	if (guehdr->flags & GUE_FLAG_PRIV) {
+ 		__be32 flags = *(__be32 *)(data + doffset);
+ 
+ 		doffset += GUE_LEN_PRIV;
+ 
+ 		if (flags & GUE_PFLAG_REMCSUM) {
+ 			guehdr = gue_remcsum(skb, guehdr, data + doffset,
+ 					     hdrlen, guehdr->proto_ctype);
+ 			if (!guehdr)
+ 				goto drop;
+ 
+ 			data = &guehdr[1];
+ 
+ 			doffset += GUE_PLEN_REMCSUM;
+ 		}
+ 	}
+ 
+ 	if (unlikely(guehdr->control))
+ 		return gue_control_message(skb, guehdr);
+ 
+ 	__skb_pull(skb, hdrlen);
+ 	skb_reset_transport_header(skb);
+ 
+ 	return -guehdr->proto_ctype;
+ 
++>>>>>>> a8d31c128bf5 (gue: Receive side of remote checksum offload)
  drop:
  	kfree_skb(skb);
  	return 0;
@@@ -154,10 -308,10 +327,16 @@@ static struct sk_buff **gue_gro_receive
  	const struct net_offload *ops;
  	struct sk_buff **pp = NULL;
  	struct sk_buff *p;
 +	u8 proto;
  	struct guehdr *guehdr;
++<<<<<<< HEAD
 +	unsigned int hlen, guehlen;
 +	unsigned int off;
++=======
+ 	size_t len, optlen, hdrlen, off;
+ 	void *data;
+ 	u16 doffset = 0;
++>>>>>>> a8d31c128bf5 (gue: Receive side of remote checksum offload)
  	int flush = 1;
  
  	off = skb_gro_offset(skb);
@@@ -169,23 -324,48 +348,60 @@@
  			goto out;
  	}
  
 -	optlen = guehdr->hlen << 2;
 -	len += optlen;
 +	proto = guehdr->next_hdr;
  
 -	if (skb_gro_header_hard(skb, len)) {
 -		guehdr = skb_gro_header_slow(skb, len, off);
 +	rcu_read_lock();
 +	offloads = NAPI_GRO_CB(skb)->is_ipv6 ? inet6_offloads : inet_offloads;
 +	ops = rcu_dereference(offloads[proto]);
 +	if (WARN_ON(!ops || !ops->callbacks.gro_receive))
 +		goto out_unlock;
 +
 +	guehlen = sizeof(*guehdr) + (guehdr->hlen << 2);
 +
 +	hlen = off + guehlen;
 +	if (skb_gro_header_hard(skb, hlen)) {
 +		guehdr = skb_gro_header_slow(skb, hlen, off);
  		if (unlikely(!guehdr))
++<<<<<<< HEAD
 +			goto out_unlock;
++=======
+ 			goto out;
+ 	}
+ 
+ 	if (unlikely(guehdr->control) || guehdr->version != 0 ||
+ 	    validate_gue_flags(guehdr, optlen))
+ 		goto out;
+ 
+ 	hdrlen = sizeof(*guehdr) + optlen;
+ 
+ 	/* Adjust NAPI_GRO_CB(skb)->csum to account for guehdr,
+ 	 * this is needed if there is a remote checkcsum offload.
+ 	 */
+ 	skb_gro_postpull_rcsum(skb, guehdr, hdrlen);
+ 
+ 	data = &guehdr[1];
+ 
+ 	if (guehdr->flags & GUE_FLAG_PRIV) {
+ 		__be32 flags = *(__be32 *)(data + doffset);
+ 
+ 		doffset += GUE_LEN_PRIV;
+ 
+ 		if (flags & GUE_PFLAG_REMCSUM) {
+ 			guehdr = gue_gro_remcsum(skb, off, guehdr,
+ 						 data + doffset, hdrlen,
+ 						 guehdr->proto_ctype);
+ 			if (!guehdr)
+ 				goto out;
+ 
+ 			data = &guehdr[1];
+ 
+ 			doffset += GUE_PLEN_REMCSUM;
+ 		}
++>>>>>>> a8d31c128bf5 (gue: Receive side of remote checksum offload)
  	}
  
+ 	skb_gro_pull(skb, hdrlen);
+ 
  	flush = 0;
  
  	for (p = *head; p; p = p->next) {
* Unmerged path net/ipv4/fou.c
