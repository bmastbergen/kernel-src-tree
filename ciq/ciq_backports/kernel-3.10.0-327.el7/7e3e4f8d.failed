powerpc/powernv: Drop PHB operation set_option()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [powerpc] powernv: Drop PHB operation set_option() (Laurent Vivier) [1213675]
Rebuild_FUZZ: 90.91%
commit-author Gavin Shan <gwshan@linux.vnet.ibm.com>
commit 7e3e4f8d5e80d2321cb1ab58a2070fbf28883ec1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/7e3e4f8d.failed

The patch drops PHB EEH operation set_option() and merges its
logic to eeh_ops::set_option().

	Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
	Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
(cherry picked from commit 7e3e4f8d5e80d2321cb1ab58a2070fbf28883ec1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/powernv/eeh-ioda.c
diff --cc arch/powerpc/platforms/powernv/eeh-ioda.c
index 7aafd27de750,349c0830f535..000000000000
--- a/arch/powerpc/platforms/powernv/eeh-ioda.c
+++ b/arch/powerpc/platforms/powernv/eeh-ioda.c
@@@ -35,125 -34,74 +35,129 @@@
  #include "powernv.h"
  #include "pci.h"
  
 -static void ioda_eeh_phb_diag(struct eeh_pe *pe)
++<<<<<<< HEAD
 +/**
 + * ioda_eeh_set_option - Set EEH operation or I/O setting
 + * @pe: EEH PE
 + * @option: options
 + *
 + * Enable or disable EEH option for the indicated PE. The
 + * function also can be used to enable I/O or DMA for the
 + * PE.
 + */
 +static int ioda_eeh_set_option(struct eeh_pe *pe, int option)
  {
 -	struct pnv_phb *phb = pe->phb->private_data;
 -	long rc;
 +	s64 ret;
 +	u32 pe_no;
 +	struct pci_controller *hose = pe->phb;
 +	struct pnv_phb *phb = hose->private_data;
  
 -	rc = opal_pci_get_phb_diag_data2(phb->opal_id, pe->data,
 -					 PNV_PCI_DIAG_BUF_SIZE);
 -	if (rc != OPAL_SUCCESS)
 -		pr_warn("%s: Failed to get diag-data for PHB#%x (%ld)\n",
 -			__func__, pe->phb->global_number, rc);
 -}
 +	/* Check on PE number */
 +	if (pe->addr < 0 || pe->addr >= phb->ioda.total_pe) {
 +		pr_err("%s: PE address %x out of range [0, %x] "
 +		       "on PHB#%x\n",
 +			__func__, pe->addr, phb->ioda.total_pe,
 +			hose->global_number);
 +		return -EINVAL;
 +	}
  
 -static int ioda_eeh_get_phb_state(struct eeh_pe *pe)
 -{
 -	struct pnv_phb *phb = pe->phb->private_data;
 -	u8 fstate;
 -	__be16 pcierr;
 -	s64 rc;
 -	int result = 0;
 -
 -	rc = opal_pci_eeh_freeze_status(phb->opal_id,
 -					pe->addr,
 -					&fstate,
 -					&pcierr,
 -					NULL);
 -	if (rc != OPAL_SUCCESS) {
 -		pr_warn("%s: Failure %lld getting PHB#%x state\n",
 -			__func__, rc, phb->hose->global_number);
 -		return EEH_STATE_NOT_SUPPORT;
 +	pe_no = pe->addr;
 +	switch (option) {
 +	case EEH_OPT_DISABLE:
 +		ret = -EEXIST;
 +		break;
 +	case EEH_OPT_ENABLE:
 +		ret = 0;
 +		break;
 +	case EEH_OPT_THAW_MMIO:
 +		ret = opal_pci_eeh_freeze_clear(phb->opal_id, pe_no,
 +				OPAL_EEH_ACTION_CLEAR_FREEZE_MMIO);
 +		if (ret) {
 +			pr_warning("%s: Failed to enable MMIO for "
 +				   "PHB#%x-PE#%x, err=%lld\n",
 +				__func__, hose->global_number, pe_no, ret);
 +			return -EIO;
 +		}
 +
 +		break;
 +	case EEH_OPT_THAW_DMA:
 +		ret = opal_pci_eeh_freeze_clear(phb->opal_id, pe_no,
 +				OPAL_EEH_ACTION_CLEAR_FREEZE_DMA);
 +		if (ret) {
 +			pr_warning("%s: Failed to enable DMA for "
 +				   "PHB#%x-PE#%x, err=%lld\n",
 +				__func__, hose->global_number, pe_no, ret);
 +			return -EIO;
 +		}
 +
 +		break;
 +	default:
 +		pr_warning("%s: Invalid option %d\n", __func__, option);
 +		return -EINVAL;
  	}
  
 -	/*
 -	 * Check PHB state. If the PHB is frozen for the
 -	 * first time, to dump the PHB diag-data.
 -	 */
 -	if (be16_to_cpu(pcierr) != OPAL_EEH_PHB_ERROR) {
 -		result = (EEH_STATE_MMIO_ACTIVE  |
 -			  EEH_STATE_DMA_ACTIVE   |
 -			  EEH_STATE_MMIO_ENABLED |
 -			  EEH_STATE_DMA_ENABLED);
 -	} else if (!(pe->state & EEH_PE_ISOLATED)) {
 -		eeh_pe_state_mark(pe, EEH_PE_ISOLATED);
 -		ioda_eeh_phb_diag(pe);
 +	return ret;
 +}
 +
 +static void ioda_eeh_phb_diag(struct pci_controller *hose)
++=======
++static void ioda_eeh_phb_diag(struct eeh_pe *pe)
++>>>>>>> 7e3e4f8d5e80 (powerpc/powernv: Drop PHB operation set_option())
 +{
 +	struct pnv_phb *phb = hose->private_data;
 +	long rc;
  
 -		if (eeh_has_flag(EEH_EARLY_DUMP_LOG))
 -			pnv_pci_dump_phb_diag_data(pe->phb, pe->data);
 +	rc = opal_pci_get_phb_diag_data2(phb->opal_id, phb->diag.blob,
 +					 PNV_PCI_DIAG_BUF_SIZE);
 +	if (rc != OPAL_SUCCESS) {
 +		pr_warning("%s: Failed to get diag-data for PHB#%x (%ld)\n",
 +			    __func__, hose->global_number, rc);
 +		return;
  	}
  
 -	return result;
 +	pnv_pci_dump_phb_diag_data(hose, phb->diag.blob);
  }
  
 -static int ioda_eeh_get_pe_state(struct eeh_pe *pe)
 +/**
 + * ioda_eeh_get_state - Retrieve the state of PE
 + * @pe: EEH PE
 + *
 + * The PE's state should be retrieved from the PEEV, PEST
 + * IODA tables. Since the OPAL has exported the function
 + * to do it, it'd better to use that.
 + */
 +static int ioda_eeh_get_state(struct eeh_pe *pe)
  {
 -	struct pnv_phb *phb = pe->phb->private_data;
 +	s64 ret = 0;
  	u8 fstate;
  	__be16 pcierr;
 -	s64 rc;
 +	u32 pe_no;
  	int result;
 +	struct pci_controller *hose = pe->phb;
 +	struct pnv_phb *phb = hose->private_data;
  
  	/*
 -	 * We don't clobber hardware frozen state until PE
 -	 * reset is completed. In order to keep EEH core
 -	 * moving forward, we have to return operational
 -	 * state during PE reset.
 +	 * Sanity check on PE address. The PHB PE address should
 +	 * be zero.
  	 */
 -	if (pe->state & EEH_PE_RESET) {
 -		result = (EEH_STATE_MMIO_ACTIVE  |
 -			  EEH_STATE_DMA_ACTIVE   |
 +	if (pe->addr < 0 || pe->addr >= phb->ioda.total_pe) {
 +		pr_err("%s: PE address %x out of range [0, %x] "
 +		       "on PHB#%x\n",
 +		       __func__, pe->addr, phb->ioda.total_pe,
 +		       hose->global_number);
 +		return EEH_STATE_NOT_SUPPORT;
 +	}
 +
 +	/*
 +	 * If we're in middle of PE reset, return normal
 +	 * state to keep EEH core going. For PHB reset, we
 +	 * still expect to have fenced PHB cleared with
 +	 * PHB reset.
 +	 */
 +	if (!(pe->type & EEH_PE_PHB) &&
 +	    (pe->state & EEH_PE_RESET)) {
 +		result = (EEH_STATE_MMIO_ACTIVE |
 +			  EEH_STATE_DMA_ACTIVE |
  			  EEH_STATE_MMIO_ENABLED |
  			  EEH_STATE_DMA_ENABLED);
  		return result;
* Unmerged path arch/powerpc/platforms/powernv/eeh-ioda.c
diff --git a/arch/powerpc/platforms/powernv/eeh-powernv.c b/arch/powerpc/platforms/powernv/eeh-powernv.c
index 86e8f8e66097..2703a52cbba8 100644
--- a/arch/powerpc/platforms/powernv/eeh-powernv.c
+++ b/arch/powerpc/platforms/powernv/eeh-powernv.c
@@ -344,14 +344,61 @@ static int powernv_eeh_set_option(struct eeh_pe *pe, int option)
 {
 	struct pci_controller *hose = pe->phb;
 	struct pnv_phb *phb = hose->private_data;
-	int ret = -EEXIST;
+	bool freeze_pe = false;
+	int opt, ret = 0;
+	s64 rc;
 
-	/*
-	 * What we need do is pass it down for hardware
-	 * implementation to handle it.
-	 */
-	if (phb->eeh_ops && phb->eeh_ops->set_option)
-		ret = phb->eeh_ops->set_option(pe, option);
+	/* Sanity check on option */
+	switch (option) {
+	case EEH_OPT_DISABLE:
+		return -EPERM;
+	case EEH_OPT_ENABLE:
+		return 0;
+	case EEH_OPT_THAW_MMIO:
+		opt = OPAL_EEH_ACTION_CLEAR_FREEZE_MMIO;
+		break;
+	case EEH_OPT_THAW_DMA:
+		opt = OPAL_EEH_ACTION_CLEAR_FREEZE_DMA;
+		break;
+	case EEH_OPT_FREEZE_PE:
+		freeze_pe = true;
+		opt = OPAL_EEH_ACTION_SET_FREEZE_ALL;
+		break;
+	default:
+		pr_warn("%s: Invalid option %d\n", __func__, option);
+		return -EINVAL;
+	}
+
+	/* If PHB supports compound PE, to handle it */
+	if (freeze_pe) {
+		if (phb->freeze_pe) {
+			phb->freeze_pe(phb, pe->addr);
+		} else {
+			rc = opal_pci_eeh_freeze_set(phb->opal_id,
+						     pe->addr, opt);
+			if (rc != OPAL_SUCCESS) {
+				pr_warn("%s: Failure %lld freezing "
+					"PHB#%x-PE#%x\n",
+					__func__, rc,
+					phb->hose->global_number, pe->addr);
+				ret = -EIO;
+			}
+		}
+	} else {
+		if (phb->unfreeze_pe) {
+			ret = phb->unfreeze_pe(phb, pe->addr, opt);
+		} else {
+			rc = opal_pci_eeh_freeze_clear(phb->opal_id,
+						       pe->addr, opt);
+			if (rc != OPAL_SUCCESS) {
+				pr_warn("%s: Failure %lld enable %d "
+					"for PHB#%x-PE#%x\n",
+					__func__, rc, option,
+					phb->hose->global_number, pe->addr);
+				ret = -EIO;
+			}
+		}
+	}
 
 	return ret;
 }
diff --git a/arch/powerpc/platforms/powernv/pci.h b/arch/powerpc/platforms/powernv/pci.h
index 5732743fe737..10179a8664c0 100644
--- a/arch/powerpc/platforms/powernv/pci.h
+++ b/arch/powerpc/platforms/powernv/pci.h
@@ -71,7 +71,6 @@ struct pnv_ioda_pe {
 /* IOC dependent EEH operations */
 #ifdef CONFIG_EEH
 struct pnv_eeh_ops {
-	int (*set_option)(struct eeh_pe *pe, int option);
 	int (*get_state)(struct eeh_pe *pe);
 	int (*reset)(struct eeh_pe *pe, int option);
 	int (*next_error)(struct eeh_pe **pe);
