syncookies: split cookie_check_timestamp() into two functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Florian Westphal <fw@strlen.de>
commit f1673381b1481a409238d4552a0700d490c5b36c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/f1673381.failed

The function cookie_check_timestamp(), both called from IPv4/6 context,
is being used to decode the echoed timestamp from the SYN/ACK into TCP
options used for follow-up communication with the peer.

We can remove ECN handling from that function, split it into a separate
one, and simply rename the original function into cookie_decode_options().
cookie_decode_options() just fills in tcp_option struct based on the
echoed timestamp received from the peer. Anything that fails in this
function will actually discard the request socket.

While this is the natural place for decoding options such as ECN which
commit 172d69e63c7f ("syncookies: add support for ECN") added, we argue
that in particular for ECN handling, it can be checked at a later point
in time as the request sock would actually not need to be dropped from
this, but just ECN support turned off.

Therefore, we split this functionality into cookie_ecn_ok(), which tells
us if the timestamp indicates ECN support AND the tcp_ecn sysctl is enabled.

This prepares for per-route ECN support: just looking at the tcp_ecn sysctl
won't be enough anymore at that point; if the timestamp indicates ECN
and sysctl tcp_ecn == 0, we will also need to check the ECN dst metric.

This would mean adding a route lookup to cookie_check_timestamp(), which
we definitely want to avoid. As we already do a route lookup at a later
point in cookie_{v4,v6}_check(), we can simply make use of that as well
for the new cookie_ecn_ok() function w/o any additional cost.

Joint work with Daniel Borkmann.

	Acked-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f1673381b1481a409238d4552a0700d490c5b36c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/tcp.h
#	net/ipv4/syncookies.c
diff --cc include/net/tcp.h
index 0373da38f3bc,36c5084964cd..000000000000
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@@ -497,39 -486,24 +497,60 @@@ static inline u32 tcp_cookie_time(void
  	return val;
  }
  
++<<<<<<< HEAD
 +extern u32 __cookie_v4_init_sequence(const struct iphdr *iph,
 +				     const struct tcphdr *th, u16 *mssp);
 +extern __u32 cookie_v4_init_sequence(struct sock *sk, struct sk_buff *skb, 
 +				     __u16 *mss);
 +#else
 +static inline __u32 cookie_v4_init_sequence(struct sock *sk,
 +					    struct sk_buff *skb,
 +					    __u16 *mss)
 +{
 +	return 0;
 +}
 +#endif
 +
 +extern __u32 cookie_init_timestamp(struct request_sock *req);
 +extern bool cookie_check_timestamp(struct tcp_options_received *opt,
 +				struct net *net, bool *ecn_ok);
 +
 +/* From net/ipv6/syncookies.c */
 +extern int __cookie_v6_check(const struct ipv6hdr *iph, const struct tcphdr *th,
 +			     u32 cookie);
 +extern struct sock *cookie_v6_check(struct sock *sk, struct sk_buff *skb);
 +#ifdef CONFIG_SYN_COOKIES
 +extern u32 __cookie_v6_init_sequence(const struct ipv6hdr *iph,
 +				     const struct tcphdr *th, u16 *mssp);
 +extern __u32 cookie_v6_init_sequence(struct sock *sk, const struct sk_buff *skb,
 +				     __u16 *mss);
 +#else
 +static inline __u32 cookie_v6_init_sequence(struct sock *sk,
 +					    struct sk_buff *skb,
 +					    __u16 *mss)
 +{
 +	return 0;
 +}
++=======
+ u32 __cookie_v4_init_sequence(const struct iphdr *iph, const struct tcphdr *th,
+ 			      u16 *mssp);
+ __u32 cookie_v4_init_sequence(struct sock *sk, const struct sk_buff *skb,
+ 			      __u16 *mss);
+ __u32 cookie_init_timestamp(struct request_sock *req);
+ bool cookie_timestamp_decode(struct tcp_options_received *opt);
+ bool cookie_ecn_ok(const struct tcp_options_received *opt,
+ 		   const struct net *net);
+ 
+ /* From net/ipv6/syncookies.c */
+ int __cookie_v6_check(const struct ipv6hdr *iph, const struct tcphdr *th,
+ 		      u32 cookie);
+ struct sock *cookie_v6_check(struct sock *sk, struct sk_buff *skb);
+ 
+ u32 __cookie_v6_init_sequence(const struct ipv6hdr *iph,
+ 			      const struct tcphdr *th, u16 *mssp);
+ __u32 cookie_v6_init_sequence(struct sock *sk, const struct sk_buff *skb,
+ 			      __u16 *mss);
++>>>>>>> f1673381b148 (syncookies: split cookie_check_timestamp() into two functions)
  #endif
  /* tcp_output.c */
  
diff --cc net/ipv4/syncookies.c
index 84b29ed816a8,6de772500ee9..000000000000
--- a/net/ipv4/syncookies.c
+++ b/net/ipv4/syncookies.c
@@@ -277,11 -270,26 +274,26 @@@ bool cookie_timestamp_decode(struct tcp
  
  	return sysctl_tcp_window_scaling != 0;
  }
- EXPORT_SYMBOL(cookie_check_timestamp);
+ EXPORT_SYMBOL(cookie_timestamp_decode);
+ 
+ bool cookie_ecn_ok(const struct tcp_options_received *tcp_opt,
+ 		   const struct net *net)
+ {
+ 	bool ecn_ok = tcp_opt->rcv_tsecr & TS_OPT_ECN;
+ 
+ 	if (!ecn_ok)
+ 		return false;
+ 
+ 	if (net->ipv4.sysctl_tcp_ecn)
+ 		return true;
+ 
+ 	return false;
+ }
+ EXPORT_SYMBOL(cookie_ecn_ok);
  
 -struct sock *cookie_v4_check(struct sock *sk, struct sk_buff *skb)
 +struct sock *cookie_v4_check(struct sock *sk, struct sk_buff *skb,
 +			     struct ip_options *opt)
  {
 -	struct ip_options *opt = &TCP_SKB_CB(skb)->header.h4.opt;
  	struct tcp_options_received tcp_opt;
  	struct inet_request_sock *ireq;
  	struct tcp_request_sock *treq;
@@@ -328,7 -338,7 +339,11 @@@
  	ireq->ir_rmt_port	= th->source;
  	ireq->ir_loc_addr	= ip_hdr(skb)->daddr;
  	ireq->ir_rmt_addr	= ip_hdr(skb)->saddr;
++<<<<<<< HEAD
 +	ireq->ecn_ok		= ecn_ok;
++=======
+ 	ireq->ir_mark		= inet_request_mark(sk, skb);
++>>>>>>> f1673381b148 (syncookies: split cookie_check_timestamp() into two functions)
  	ireq->snd_wscale	= tcp_opt.snd_wscale;
  	ireq->sack_ok		= tcp_opt.sack_ok;
  	ireq->wscale_ok		= tcp_opt.wscale_ok;
* Unmerged path include/net/tcp.h
* Unmerged path net/ipv4/syncookies.c
diff --git a/net/ipv6/syncookies.c b/net/ipv6/syncookies.c
index d04d3f1dd9b7..d3b9be67e0f0 100644
--- a/net/ipv6/syncookies.c
+++ b/net/ipv6/syncookies.c
@@ -160,7 +160,6 @@ struct sock *cookie_v6_check(struct sock *sk, struct sk_buff *skb)
 	int mss;
 	struct dst_entry *dst;
 	__u8 rcv_wscale;
-	bool ecn_ok = false;
 
 	if (!sysctl_tcp_syncookies || !th->ack || th->rst)
 		goto out;
@@ -177,7 +176,7 @@ struct sock *cookie_v6_check(struct sock *sk, struct sk_buff *skb)
 	memset(&tcp_opt, 0, sizeof(tcp_opt));
 	tcp_parse_options(skb, &tcp_opt, 0, NULL);
 
-	if (!cookie_check_timestamp(&tcp_opt, sock_net(sk), &ecn_ok))
+	if (!cookie_timestamp_decode(&tcp_opt))
 		goto out;
 
 	ret = NULL;
@@ -212,7 +211,6 @@ struct sock *cookie_v6_check(struct sock *sk, struct sk_buff *skb)
 
 	req->expires = 0UL;
 	req->num_retrans = 0;
-	ireq->ecn_ok		= ecn_ok;
 	ireq->snd_wscale	= tcp_opt.snd_wscale;
 	ireq->sack_ok		= tcp_opt.sack_ok;
 	ireq->wscale_ok		= tcp_opt.wscale_ok;
@@ -253,6 +251,7 @@ struct sock *cookie_v6_check(struct sock *sk, struct sk_buff *skb)
 				  dst_metric(dst, RTAX_INITRWND));
 
 	ireq->rcv_wscale = rcv_wscale;
+	ireq->ecn_ok = cookie_ecn_ok(&tcp_opt, sock_net(sk));
 
 	ret = get_cookie_sock(sk, skb, req, dst);
 out:
