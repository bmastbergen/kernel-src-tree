bonding: use rcu_access_pointer() in bonding_show_mii_status()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Eric Dumazet <edumazet@google.com>
commit c2646b593eb127adc50e108649e4d34144e14c6c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/c2646b59.failed

curr_active_slave is rcu protected, and bonding_show_mii_status() only
wants to check if pointer is NULL or not.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Acked-by: Veaceslav Falico <vfalico@gmail.com>
	Reviewed-by: Nikolay Aleksandrov <nikolay@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c2646b593eb127adc50e108649e4d34144e14c6c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_sysfs.c
diff --cc drivers/net/bonding/bond_sysfs.c
index c7fd44189961,98db8edd9c75..000000000000
--- a/drivers/net/bonding/bond_sysfs.c
+++ b/drivers/net/bonding/bond_sysfs.c
@@@ -1371,14 -491,10 +1371,19 @@@ static ssize_t bonding_show_mii_status(
  				       struct device_attribute *attr,
  				       char *buf)
  {
 +	struct slave *curr;
  	struct bonding *bond = to_bond(d);
+ 	bool active = !!rcu_access_pointer(bond->curr_active_slave);
  
++<<<<<<< HEAD
 +	read_lock(&bond->curr_slave_lock);
 +	curr = bond->curr_active_slave;
 +	read_unlock(&bond->curr_slave_lock);
 +
 +	return sprintf(buf, "%s\n", curr ? "up" : "down");
++=======
+ 	return sprintf(buf, "%s\n", active ? "up" : "down");
++>>>>>>> c2646b593eb1 (bonding: use rcu_access_pointer() in bonding_show_mii_status())
  }
  static DEVICE_ATTR(mii_status, S_IRUGO, bonding_show_mii_status, NULL);
  
* Unmerged path drivers/net/bonding/bond_sysfs.c
