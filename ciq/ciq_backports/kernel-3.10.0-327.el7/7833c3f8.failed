ALSA: hda - Migrate hdac_stream into legacy driver

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [alsa] hda - Migrate hdac_stream into legacy driver (Jaroslav Kysela) [1197064]
Rebuild_FUZZ: 93.62%
commit-author Takashi Iwai <tiwai@suse.de>
commit 7833c3f85b88561c245a9cb1e42eafec9dca7154
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/7833c3f8.failed

Embed hdac_stream object into azx_dev, and use a few basic helper
functions.  The most of helper codes for hdac_stream aren't still used
yet.

Also this commit disables the tracepoints temporarily due to build
problems.  It'll be enabled again later.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 7833c3f85b88561c245a9cb1e42eafec9dca7154)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/hda_controller.c
#	sound/pci/hda/hda_controller.h
diff --cc sound/pci/hda/hda_controller.c
index 0d7233e1e418,0b85c88c75ac..000000000000
--- a/sound/pci/hda/hda_controller.c
+++ b/sound/pci/hda/hda_controller.c
@@@ -27,27 -27,14 +27,16 @@@
  #include <linux/module.h>
  #include <linux/pm_runtime.h>
  #include <linux/slab.h>
 +#include <linux/reboot.h>
  #include <sound/core.h>
  #include <sound/initval.h>
 +#include "hda_priv.h"
  #include "hda_controller.h"
  
- #define CREATE_TRACE_POINTS
- #include "hda_intel_trace.h"
- 
  /* DSP lock helpers */
- #ifdef CONFIG_SND_HDA_DSP_LOADER
- #define dsp_lock_init(dev)	mutex_init(&(dev)->dsp_mutex)
- #define dsp_lock(dev)		mutex_lock(&(dev)->dsp_mutex)
- #define dsp_unlock(dev)		mutex_unlock(&(dev)->dsp_mutex)
- #define dsp_is_locked(dev)	((dev)->locked)
- #else
- #define dsp_lock_init(dev)	do {} while (0)
- #define dsp_lock(dev)		do {} while (0)
- #define dsp_unlock(dev)		do {} while (0)
- #define dsp_is_locked(dev)	0
- #endif
+ #define dsp_lock(dev)		snd_hdac_dsp_lock(azx_stream(dev))
+ #define dsp_unlock(dev)		snd_hdac_dsp_unlock(azx_stream(dev))
+ #define dsp_is_locked(dev)	snd_hdac_stream_is_locked(azx_stream(dev))
  
  /*
   * AZX stream operations.
@@@ -1382,11 -1287,11 +1276,11 @@@ static int azx_load_dsp_prepare(struct 
  	}
  	azx_dev->prepared = 0;
  	chip->saved_azx_dev = *azx_dev;
- 	azx_dev->locked = 1;
+ 	azx_dev->core.locked = 1;
  	spin_unlock_irq(&chip->reg_lock);
  
 -	err = chip->io_ops->dma_alloc_pages(&bus->core, SNDRV_DMA_TYPE_DEV_SG,
 -					    byte_size, bufp);
 +	err = chip->ops->dma_alloc_pages(chip, SNDRV_DMA_TYPE_DEV_SG,
 +					 byte_size, bufp);
  	if (err < 0)
  		goto err_alloc;
  
@@@ -1408,15 -1313,15 +1302,15 @@@
  
  	azx_setup_controller(chip, azx_dev);
  	dsp_unlock(azx_dev);
- 	return azx_dev->stream_tag;
+ 	return azx_dev->core.stream_tag;
  
   error:
 -	chip->io_ops->dma_free_pages(&bus->core, bufp);
 +	chip->ops->dma_free_pages(chip, bufp);
   err_alloc:
  	spin_lock_irq(&chip->reg_lock);
- 	if (azx_dev->opened)
+ 	if (azx_dev->core.opened)
  		*azx_dev = chip->saved_azx_dev;
- 	azx_dev->locked = 0;
+ 	azx_dev->core.locked = 0;
  	spin_unlock_irq(&chip->reg_lock);
   unlock:
  	dsp_unlock(azx_dev);
@@@ -1449,11 -1353,11 +1342,11 @@@ static void azx_load_dsp_cleanup(struc
  	azx_sd_writel(chip, azx_dev, SD_BDLPL, 0);
  	azx_sd_writel(chip, azx_dev, SD_BDLPU, 0);
  	azx_sd_writel(chip, azx_dev, SD_CTL, 0);
- 	azx_dev->bufsize = 0;
- 	azx_dev->period_bytes = 0;
- 	azx_dev->format_val = 0;
+ 	azx_dev->core.bufsize = 0;
+ 	azx_dev->core.period_bytes = 0;
+ 	azx_dev->core.format_val = 0;
  
 -	chip->io_ops->dma_free_pages(&bus->core, dmab);
 +	chip->ops->dma_free_pages(chip, dmab);
  	dmab->area = NULL;
  
  	spin_lock_irq(&chip->reg_lock);
@@@ -1467,19 -1371,20 +1360,26 @@@
  
  int azx_alloc_stream_pages(struct azx *chip)
  {
- 	int i, err;
+ 	struct hdac_bus *bus = azx_bus(chip);
+ 	struct hdac_stream *s;
+ 	int err;
  
- 	for (i = 0; i < chip->num_streams; i++) {
- 		dsp_lock_init(&chip->azx_dev[i]);
+ 	list_for_each_entry(s, &bus->stream_list, list) {
  		/* allocate memory for the BDL for each stream */
++<<<<<<< HEAD
 +		err = chip->ops->dma_alloc_pages(chip, SNDRV_DMA_TYPE_DEV,
 +						 BDL_SIZE,
 +						 &chip->azx_dev[i].bdl);
++=======
+ 		err = chip->io_ops->dma_alloc_pages(azx_bus(chip), SNDRV_DMA_TYPE_DEV,
+ 						 BDL_SIZE, &s->bdl);
++>>>>>>> 7833c3f85b88 (ALSA: hda - Migrate hdac_stream into legacy driver)
  		if (err < 0)
  			return -ENOMEM;
  	}
+ 
  	/* allocate memory for the position buffer */
 -	err = chip->io_ops->dma_alloc_pages(azx_bus(chip), SNDRV_DMA_TYPE_DEV,
 +	err = chip->ops->dma_alloc_pages(chip, SNDRV_DMA_TYPE_DEV,
  					 chip->num_streams * 8, &chip->posbuf);
  	if (err < 0)
  		return -ENOMEM;
@@@ -1494,17 -1399,19 +1394,28 @@@ EXPORT_SYMBOL_GPL(azx_alloc_stream_page
  
  void azx_free_stream_pages(struct azx *chip)
  {
++<<<<<<< HEAD
 +	int i;
 +	if (chip->azx_dev) {
 +		for (i = 0; i < chip->num_streams; i++)
 +			if (chip->azx_dev[i].bdl.area)
 +				chip->ops->dma_free_pages(
 +					chip, &chip->azx_dev[i].bdl);
++=======
+ 	struct hdac_bus *bus = azx_bus(chip);
+ 	struct hdac_stream *s, *next;
+ 
+ 	list_for_each_entry_safe(s, next, &bus->stream_list, list) {
+ 		if (s->bdl.area)
+ 			chip->io_ops->dma_free_pages(azx_bus(chip), &s->bdl);
+ 		kfree(s);
++>>>>>>> 7833c3f85b88 (ALSA: hda - Migrate hdac_stream into legacy driver)
  	}
+ 
  	if (chip->rb.area)
 -		chip->io_ops->dma_free_pages(azx_bus(chip), &chip->rb);
 +		chip->ops->dma_free_pages(chip, &chip->rb);
  	if (chip->posbuf.area)
 -		chip->io_ops->dma_free_pages(azx_bus(chip), &chip->posbuf);
 +		chip->ops->dma_free_pages(chip, &chip->posbuf);
  }
  EXPORT_SYMBOL_GPL(azx_free_stream_pages);
  
@@@ -1688,13 -1616,11 +1620,11 @@@ static void stream_update(struct hdac_b
  irqreturn_t azx_interrupt(int irq, void *dev_id)
  {
  	struct azx *chip = dev_id;
- 	struct azx_dev *azx_dev;
+ 	struct hdac_bus *bus = azx_bus(chip);
  	u32 status;
- 	u8 sd_status;
- 	int i;
  
 -#ifdef CONFIG_PM
 -	if (azx_has_pm_runtime(chip))
 +#ifdef CONFIG_PM_RUNTIME
 +	if (chip->driver_caps & AZX_DCAPS_PM_RUNTIME)
  		if (!pm_runtime_active(chip->card->dev))
  			return IRQ_NONE;
  #endif
@@@ -1758,15 -1668,17 +1672,20 @@@ static int probe_codec(struct azx *chip
  {
  	unsigned int cmd = (addr << 28) | (AC_NODE_ROOT << 20) |
  		(AC_VERB_PARAMETERS << 8) | AC_PAR_VENDOR_ID;
++<<<<<<< HEAD
++=======
+ 	struct hdac_bus *bus = azx_bus(chip);
+ 	int err;
++>>>>>>> 7833c3f85b88 (ALSA: hda - Migrate hdac_stream into legacy driver)
  	unsigned int res;
  
 -	mutex_lock(&bus->cmd_mutex);
 +	mutex_lock(&chip->bus->cmd_mutex);
  	chip->probing = 1;
 -	azx_send_cmd(bus, cmd);
 -	err = azx_get_response(bus, addr, &res);
 +	azx_send_cmd(chip->bus, cmd);
 +	res = azx_get_response(chip->bus, addr);
  	chip->probing = 0;
 -	mutex_unlock(&bus->cmd_mutex);
 -	if (err < 0 || res == -1)
 +	mutex_unlock(&chip->bus->cmd_mutex);
 +	if (res == -1)
  		return -EIO;
  	dev_dbg(chip->card->dev, "codec #%d probed OK\n", addr);
  	return 0;
diff --cc sound/pci/hda/hda_controller.h
index 2993061145a5,b45568d83860..000000000000
--- a/sound/pci/hda/hda_controller.h
+++ b/sound/pci/hda/hda_controller.h
@@@ -15,10 -15,221 +15,222 @@@
  #ifndef __SOUND_HDA_CONTROLLER_H
  #define __SOUND_HDA_CONTROLLER_H
  
 -#include <linux/timecounter.h>
 -#include <linux/interrupt.h>
  #include <sound/core.h>
 -#include <sound/pcm.h>
  #include <sound/initval.h>
  #include "hda_codec.h"
++<<<<<<< HEAD
 +#include "hda_priv.h"
++=======
+ #include <sound/hda_register.h>
+ 
+ #define AZX_MAX_CODECS		HDA_MAX_CODECS
+ #define AZX_DEFAULT_CODECS	4
+ 
+ /* driver quirks (capabilities) */
+ /* bits 0-7 are used for indicating driver type */
+ #define AZX_DCAPS_NO_TCSEL	(1 << 8)	/* No Intel TCSEL bit */
+ #define AZX_DCAPS_NO_MSI	(1 << 9)	/* No MSI support */
+ #define AZX_DCAPS_SNOOP_MASK	(3 << 10)	/* snoop type mask */
+ #define AZX_DCAPS_SNOOP_OFF	(1 << 12)	/* snoop default off */
+ #define AZX_DCAPS_RIRB_DELAY	(1 << 13)	/* Long delay in read loop */
+ #define AZX_DCAPS_RIRB_PRE_DELAY (1 << 14)	/* Put a delay before read */
+ #define AZX_DCAPS_CTX_WORKAROUND (1 << 15)	/* X-Fi workaround */
+ #define AZX_DCAPS_POSFIX_LPIB	(1 << 16)	/* Use LPIB as default */
+ #define AZX_DCAPS_POSFIX_VIA	(1 << 17)	/* Use VIACOMBO as default */
+ #define AZX_DCAPS_NO_64BIT	(1 << 18)	/* No 64bit address */
+ #define AZX_DCAPS_SYNC_WRITE	(1 << 19)	/* sync each cmd write */
+ #define AZX_DCAPS_OLD_SSYNC	(1 << 20)	/* Old SSYNC reg for ICH */
+ #define AZX_DCAPS_NO_ALIGN_BUFSIZE (1 << 21)	/* no buffer size alignment */
+ /* 22 unused */
+ #define AZX_DCAPS_4K_BDLE_BOUNDARY (1 << 23)	/* BDLE in 4k boundary */
+ #define AZX_DCAPS_REVERSE_ASSIGN (1 << 24)	/* Assign devices in reverse order */
+ #define AZX_DCAPS_COUNT_LPIB_DELAY  (1 << 25)	/* Take LPIB as delay */
+ #define AZX_DCAPS_PM_RUNTIME	(1 << 26)	/* runtime PM support */
+ #define AZX_DCAPS_I915_POWERWELL (1 << 27)	/* HSW i915 powerwell support */
+ #define AZX_DCAPS_CORBRP_SELF_CLEAR (1 << 28)	/* CORBRP clears itself after reset */
+ #define AZX_DCAPS_NO_MSI64      (1 << 29)	/* Stick to 32-bit MSIs */
+ #define AZX_DCAPS_SEPARATE_STREAM_TAG	(1 << 30) /* capture and playback use separate stream tag */
+ 
+ enum {
+ 	AZX_SNOOP_TYPE_NONE,
+ 	AZX_SNOOP_TYPE_SCH,
+ 	AZX_SNOOP_TYPE_ATI,
+ 	AZX_SNOOP_TYPE_NVIDIA,
+ };
+ 
+ struct azx_dev {
+ 	struct hdac_stream core;
+ 
+ 	unsigned int irq_pending:1;
+ 	unsigned int prepared:1;
+ 	/*
+ 	 * For VIA:
+ 	 *  A flag to ensure DMA position is 0
+ 	 *  when link position is not greater than FIFO size
+ 	 */
+ 	unsigned int insufficient:1;
+ 	unsigned int wc_marked:1;
+ };
+ 
+ #define azx_stream(dev)		(&(dev)->core)
+ #define stream_to_azx_dev(s)	container_of(s, struct azx_dev, core)
+ 
+ /* CORB/RIRB */
+ struct azx_rb {
+ 	u32 *buf;		/* CORB/RIRB buffer
+ 				 * Each CORB entry is 4byte, RIRB is 8byte
+ 				 */
+ 	dma_addr_t addr;	/* physical address of CORB/RIRB buffer */
+ 	/* for RIRB */
+ 	unsigned short rp, wp;	/* read/write pointers */
+ 	int cmds[AZX_MAX_CODECS];	/* number of pending requests */
+ 	u32 res[AZX_MAX_CODECS];	/* last read value */
+ };
+ 
+ struct azx;
+ 
+ /* Functions to read/write to hda registers. */
+ struct hda_controller_ops {
+ 	/* Disable msi if supported, PCI only */
+ 	int (*disable_msi_reset_irq)(struct azx *);
+ 	int (*substream_alloc_pages)(struct azx *chip,
+ 				     struct snd_pcm_substream *substream,
+ 				     size_t size);
+ 	int (*substream_free_pages)(struct azx *chip,
+ 				    struct snd_pcm_substream *substream);
+ 	void (*pcm_mmap_prepare)(struct snd_pcm_substream *substream,
+ 				 struct vm_area_struct *area);
+ 	/* Check if current position is acceptable */
+ 	int (*position_check)(struct azx *chip, struct azx_dev *azx_dev);
+ };
+ 
+ struct azx_pcm {
+ 	struct azx *chip;
+ 	struct snd_pcm *pcm;
+ 	struct hda_codec *codec;
+ 	struct hda_pcm *info;
+ 	struct list_head list;
+ };
+ 
+ typedef unsigned int (*azx_get_pos_callback_t)(struct azx *, struct azx_dev *);
+ typedef int (*azx_get_delay_callback_t)(struct azx *, struct azx_dev *, unsigned int pos);
+ 
+ struct azx {
+ 	struct snd_card *card;
+ 	struct pci_dev *pci;
+ 	int dev_index;
+ 
+ 	/* chip type specific */
+ 	int driver_type;
+ 	unsigned int driver_caps;
+ 	int playback_streams;
+ 	int playback_index_offset;
+ 	int capture_streams;
+ 	int capture_index_offset;
+ 	int num_streams;
+ 	const int *jackpoll_ms; /* per-card jack poll interval */
+ 
+ 	/* Register interaction. */
+ 	const struct hda_controller_ops *ops;
+ 	const struct hdac_io_ops *io_ops;
+ 
+ 	/* position adjustment callbacks */
+ 	azx_get_pos_callback_t get_position[2];
+ 	azx_get_delay_callback_t get_delay[2];
+ 
+ 	/* pci resources */
+ 	unsigned long addr;
+ 	void __iomem *remap_addr;
+ 	int irq;
+ 
+ 	/* locks */
+ 	spinlock_t reg_lock;
+ 	struct mutex open_mutex; /* Prevents concurrent open/close operations */
+ 
+ 	/* PCM */
+ 	struct list_head pcm_list; /* azx_pcm list */
+ 
+ 	/* HD codec */
+ 	unsigned short codec_mask;
+ 	int  codec_probe_mask; /* copied from probe_mask option */
+ 	struct hda_bus *bus;
+ 	unsigned int beep_mode;
+ 
+ 	/* CORB/RIRB */
+ 	struct azx_rb corb;
+ 	struct azx_rb rirb;
+ 
+ 	/* CORB/RIRB and position buffers */
+ 	struct snd_dma_buffer rb;
+ 	struct snd_dma_buffer posbuf;
+ 
+ #ifdef CONFIG_SND_HDA_PATCH_LOADER
+ 	const struct firmware *fw;
+ #endif
+ 
+ 	/* flags */
+ 	const int *bdl_pos_adj;
+ 	int poll_count;
+ 	unsigned int running:1;
+ 	unsigned int initialized:1;
+ 	unsigned int single_cmd:1;
+ 	unsigned int polling_mode:1;
+ 	unsigned int msi:1;
+ 	unsigned int probing:1; /* codec probing phase */
+ 	unsigned int snoop:1;
+ 	unsigned int align_buffer_size:1;
+ 	unsigned int region_requested:1;
+ 	unsigned int disabled:1; /* disabled by VGA-switcher */
+ 
+ 	/* for debugging */
+ 	unsigned int last_cmd[AZX_MAX_CODECS];
+ 
+ #ifdef CONFIG_SND_HDA_DSP_LOADER
+ 	struct azx_dev saved_azx_dev;
+ #endif
+ };
+ 
+ #define azx_bus(chip)	(&(chip)->bus->core)
+ 
+ #ifdef CONFIG_X86
+ #define azx_snoop(chip)		((chip)->snoop)
+ #else
+ #define azx_snoop(chip)		true
+ #endif
+ 
+ /*
+  * macros for easy use
+  */
+ 
+ #define azx_writel(chip, reg, value) \
+ 	((chip)->io_ops->reg_writel(value, (chip)->remap_addr + AZX_REG_##reg))
+ #define azx_readl(chip, reg) \
+ 	((chip)->io_ops->reg_readl((chip)->remap_addr + AZX_REG_##reg))
+ #define azx_writew(chip, reg, value) \
+ 	((chip)->io_ops->reg_writew(value, (chip)->remap_addr + AZX_REG_##reg))
+ #define azx_readw(chip, reg) \
+ 	((chip)->io_ops->reg_readw((chip)->remap_addr + AZX_REG_##reg))
+ #define azx_writeb(chip, reg, value) \
+ 	((chip)->io_ops->reg_writeb(value, (chip)->remap_addr + AZX_REG_##reg))
+ #define azx_readb(chip, reg) \
+ 	((chip)->io_ops->reg_readb((chip)->remap_addr + AZX_REG_##reg))
+ 
+ #define azx_sd_writel(chip, dev, reg, value) \
+ 	snd_hdac_stream_writel(&(dev)->core, reg, value)
+ #define azx_sd_readl(chip, dev, reg) \
+ 	snd_hdac_stream_readl(&(dev)->core, reg)
+ #define azx_sd_writew(chip, dev, reg, value) \
+ 	snd_hdac_stream_writew(&(dev)->core, reg, value)
+ #define azx_sd_readw(chip, dev, reg) \
+ 	snd_hdac_stream_readw(&(dev)->core, reg)
+ #define azx_sd_writeb(chip, dev, reg, value) \
+ 	snd_hdac_stream_writeb(&(dev)->core, reg, value)
+ #define azx_sd_readb(chip, dev, reg) \
+ 	snd_hdac_stream_readb(&(dev)->core, reg)
+ 
+ #define azx_has_pm_runtime(chip) \
+ 	(!AZX_DCAPS_PM_RUNTIME || ((chip)->driver_caps & AZX_DCAPS_PM_RUNTIME))
++>>>>>>> 7833c3f85b88 (ALSA: hda - Migrate hdac_stream into legacy driver)
  
  /* PCM setup */
  static inline struct azx_dev *get_azx_dev(struct snd_pcm_substream *substream)
* Unmerged path sound/pci/hda/hda_controller.c
* Unmerged path sound/pci/hda/hda_controller.h
diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c
index 8224bf75d072..91d2af7a36d1 100644
--- a/sound/pci/hda/hda_intel.c
+++ b/sound/pci/hda/hda_intel.c
@@ -497,7 +497,7 @@ static void azx_init_pci(struct azx *chip)
 static int azx_get_delay_from_lpib(struct azx *chip, struct azx_dev *azx_dev,
 				   unsigned int pos)
 {
-	struct snd_pcm_substream *substream = azx_dev->substream;
+	struct snd_pcm_substream *substream = azx_dev->core.substream;
 	int stream = substream->stream;
 	unsigned int lpib_pos = azx_get_pos_lpib(chip, azx_dev);
 	int delay;
@@ -507,16 +507,16 @@ static int azx_get_delay_from_lpib(struct azx *chip, struct azx_dev *azx_dev,
 	else
 		delay = lpib_pos - pos;
 	if (delay < 0) {
-		if (delay >= azx_dev->delay_negative_threshold)
+		if (delay >= azx_dev->core.delay_negative_threshold)
 			delay = 0;
 		else
-			delay += azx_dev->bufsize;
+			delay += azx_dev->core.bufsize;
 	}
 
-	if (delay >= azx_dev->period_bytes) {
+	if (delay >= azx_dev->core.period_bytes) {
 		dev_info(chip->card->dev,
 			 "Unstable LPIB (%d >= %d); disabling LPIB delay counting\n",
-			 delay, azx_dev->period_bytes);
+			 delay, azx_dev->core.period_bytes);
 		delay = 0;
 		chip->driver_caps &= ~AZX_DCAPS_COUNT_LPIB_DELAY;
 		chip->get_delay[stream] = NULL;
@@ -556,13 +556,13 @@ static int azx_position_check(struct azx *chip, struct azx_dev *azx_dev)
  */
 static int azx_position_ok(struct azx *chip, struct azx_dev *azx_dev)
 {
-	struct snd_pcm_substream *substream = azx_dev->substream;
+	struct snd_pcm_substream *substream = azx_dev->core.substream;
 	int stream = substream->stream;
 	u32 wallclk;
 	unsigned int pos;
 
-	wallclk = azx_readl(chip, WALLCLK) - azx_dev->start_wallclk;
-	if (wallclk < (azx_dev->period_wallclk * 2) / 3)
+	wallclk = azx_readl(chip, WALLCLK) - azx_dev->core.start_wallclk;
+	if (wallclk < (azx_dev->core.period_wallclk * 2) / 3)
 		return -1;	/* bogus (too early) interrupt */
 
 	if (chip->get_position[stream])
@@ -582,17 +582,17 @@ static int azx_position_ok(struct azx *chip, struct azx_dev *azx_dev)
 		}
 	}
 
-	if (pos >= azx_dev->bufsize)
+	if (pos >= azx_dev->core.bufsize)
 		pos = 0;
 
-	if (WARN_ONCE(!azx_dev->period_bytes,
+	if (WARN_ONCE(!azx_dev->core.period_bytes,
 		      "hda-intel: zero azx_dev->period_bytes"))
 		return -1; /* this shouldn't happen! */
-	if (wallclk < (azx_dev->period_wallclk * 5) / 4 &&
-	    pos % azx_dev->period_bytes > azx_dev->period_bytes / 2)
+	if (wallclk < (azx_dev->core.period_wallclk * 5) / 4 &&
+	    pos % azx_dev->core.period_bytes > azx_dev->core.period_bytes / 2)
 		/* NG - it's below the first next period boundary */
 		return chip->bdl_pos_adj[chip->dev_index] ? 0 : -1;
-	azx_dev->start_wallclk += wallclk;
+	azx_dev->core.start_wallclk += wallclk;
 	return 1; /* OK, it's fine */
 }
 
@@ -603,7 +603,9 @@ static void azx_irq_pending_work(struct work_struct *work)
 {
 	struct hda_intel *hda = container_of(work, struct hda_intel, irq_pending_work);
 	struct azx *chip = &hda->chip;
-	int i, pending, ok;
+	struct hdac_bus *bus = azx_bus(chip);
+	struct hdac_stream *s;
+	int pending, ok;
 
 	if (!hda->irq_pending_warned) {
 		dev_info(chip->card->dev,
@@ -615,17 +617,17 @@ static void azx_irq_pending_work(struct work_struct *work)
 	for (;;) {
 		pending = 0;
 		spin_lock_irq(&chip->reg_lock);
-		for (i = 0; i < chip->num_streams; i++) {
-			struct azx_dev *azx_dev = &chip->azx_dev[i];
+		list_for_each_entry(s, &bus->stream_list, list) {
+			struct azx_dev *azx_dev = stream_to_azx_dev(s);
 			if (!azx_dev->irq_pending ||
-			    !azx_dev->substream ||
-			    !azx_dev->running)
+			    !s->substream ||
+			    !s->running)
 				continue;
 			ok = azx_position_ok(chip, azx_dev);
 			if (ok > 0) {
 				azx_dev->irq_pending = 0;
 				spin_unlock(&chip->reg_lock);
-				snd_pcm_period_elapsed(azx_dev->substream);
+				snd_pcm_period_elapsed(s->substream);
 				spin_lock(&chip->reg_lock);
 			} else if (ok < 0) {
 				pending = 0;	/* too early */
@@ -642,11 +644,14 @@ static void azx_irq_pending_work(struct work_struct *work)
 /* clear irq_pending flags and assure no on-going workq */
 static void azx_clear_irq_pending(struct azx *chip)
 {
-	int i;
+	struct hdac_bus *bus = azx_bus(chip);
+	struct hdac_stream *s;
 
 	spin_lock_irq(&chip->reg_lock);
-	for (i = 0; i < chip->num_streams; i++)
-		chip->azx_dev[i].irq_pending = 0;
+	list_for_each_entry(s, &bus->stream_list, list) {
+		struct azx_dev *azx_dev = stream_to_azx_dev(s);
+		azx_dev->irq_pending = 0;
+	}
 	spin_unlock_irq(&chip->reg_lock);
 }
 
@@ -676,7 +681,7 @@ static unsigned int azx_via_get_position(struct azx *chip,
 	unsigned int fifo_size;
 
 	link_pos = azx_sd_readl(chip, azx_dev, SD_LPIB);
-	if (azx_dev->substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+	if (azx_dev->core.substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		/* Playback, no problem using link position */
 		return link_pos;
 	}
@@ -685,8 +690,8 @@ static unsigned int azx_via_get_position(struct azx *chip,
 	/* For new chipset,
 	 * use mod to get the DMA position just like old chipset
 	 */
-	mod_dma_pos = le32_to_cpu(*azx_dev->posbuf);
-	mod_dma_pos %= azx_dev->period_bytes;
+	mod_dma_pos = le32_to_cpu(*azx_dev->core.posbuf);
+	mod_dma_pos %= azx_dev->core.period_bytes;
 
 	/* azx_dev->fifo_size can't get FIFO size of in stream.
 	 * Get from base address + offset.
@@ -702,20 +707,20 @@ static unsigned int azx_via_get_position(struct azx *chip,
 	}
 
 	if (link_pos <= fifo_size)
-		mini_pos = azx_dev->bufsize + link_pos - fifo_size;
+		mini_pos = azx_dev->core.bufsize + link_pos - fifo_size;
 	else
 		mini_pos = link_pos - fifo_size;
 
 	/* Find nearest previous boudary */
-	mod_mini_pos = mini_pos % azx_dev->period_bytes;
-	mod_link_pos = link_pos % azx_dev->period_bytes;
+	mod_mini_pos = mini_pos % azx_dev->core.period_bytes;
+	mod_link_pos = link_pos % azx_dev->core.period_bytes;
 	if (mod_link_pos >= fifo_size)
 		bound_pos = link_pos - mod_link_pos;
 	else if (mod_dma_pos >= mod_mini_pos)
 		bound_pos = mini_pos - mod_mini_pos;
 	else {
-		bound_pos = mini_pos - mod_mini_pos + azx_dev->period_bytes;
-		if (bound_pos >= azx_dev->bufsize)
+		bound_pos = mini_pos - mod_mini_pos + azx_dev->core.period_bytes;
+		if (bound_pos >= azx_dev->core.bufsize)
 			bound_pos = 0;
 	}
 
@@ -1073,7 +1078,6 @@ static int azx_free(struct azx *chip)
 {
 	struct pci_dev *pci = chip->pci;
 	struct hda_intel *hda = container_of(chip, struct hda_intel, chip);
-	int i;
 
 	if ((chip->driver_caps & AZX_DCAPS_PM_RUNTIME)
 			&& chip->running)
@@ -1095,8 +1099,7 @@ static int azx_free(struct azx *chip)
 
 	if (chip->initialized) {
 		azx_clear_irq_pending(chip);
-		for (i = 0; i < chip->num_streams; i++)
-			azx_stream_stop(chip, &chip->azx_dev[i]);
+		azx_stop_all_streams(chip);
 		azx_stop_chip(chip);
 	}
 
@@ -1111,7 +1114,6 @@ static int azx_free(struct azx *chip)
 	if (chip->region_requested)
 		pci_release_regions(chip->pci);
 	pci_disable_device(chip->pci);
-	kfree(chip->azx_dev);
 #ifdef CONFIG_SND_HDA_PATCH_LOADER
 	release_firmware(chip->fw);
 #endif
@@ -1577,10 +1579,6 @@ static int azx_first_init(struct azx *chip)
 	chip->capture_index_offset = 0;
 	chip->playback_index_offset = chip->capture_streams;
 	chip->num_streams = chip->playback_streams + chip->capture_streams;
-	chip->azx_dev = kcalloc(chip->num_streams, sizeof(*chip->azx_dev),
-				GFP_KERNEL);
-	if (!chip->azx_dev)
-		return -ENOMEM;
 
 	err = azx_alloc_stream_pages(chip);
 	if (err < 0)
@@ -1738,9 +1736,9 @@ static int substream_alloc_pages(struct azx *chip,
 	int ret;
 
 	mark_runtime_wc(chip, azx_dev, substream, false);
-	azx_dev->bufsize = 0;
-	azx_dev->period_bytes = 0;
-	azx_dev->format_val = 0;
+	azx_dev->core.bufsize = 0;
+	azx_dev->core.period_bytes = 0;
+	azx_dev->core.format_val = 0;
 	ret = snd_pcm_lib_malloc_pages(substream, size);
 	if (ret < 0)
 		return ret;
diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 6c19abff991c..aadeabc30466 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -105,9 +105,9 @@ static int substream_alloc_pages(struct azx *chip,
 {
 	struct azx_dev *azx_dev = get_azx_dev(substream);
 
-	azx_dev->bufsize = 0;
-	azx_dev->period_bytes = 0;
-	azx_dev->format_val = 0;
+	azx_dev->core.bufsize = 0;
+	azx_dev->core.period_bytes = 0;
+	azx_dev->core.format_val = 0;
 	return snd_pcm_lib_malloc_pages(substream, size);
 }
 
@@ -288,14 +288,12 @@ static const struct dev_pm_ops hda_tegra_pm = {
  */
 static int hda_tegra_dev_free(struct snd_device *device)
 {
-	int i;
 	struct azx *chip = device->device_data;
 
 	azx_notifier_unregister(chip);
 
 	if (chip->initialized) {
-		for (i = 0; i < chip->num_streams; i++)
-			azx_stream_stop(chip, &chip->azx_dev[i]);
+		azx_stop_all_streams(chip);
 		azx_stop_chip(chip);
 	}
 
@@ -388,10 +386,6 @@ static int hda_tegra_first_init(struct azx *chip, struct platform_device *pdev)
 	chip->capture_index_offset = 0;
 	chip->playback_index_offset = chip->capture_streams;
 	chip->num_streams = chip->playback_streams + chip->capture_streams;
-	chip->azx_dev = devm_kcalloc(card->dev, chip->num_streams,
-				     sizeof(*chip->azx_dev), GFP_KERNEL);
-	if (!chip->azx_dev)
-		return -ENOMEM;
 
 	err = azx_alloc_stream_pages(chip);
 	if (err < 0)
