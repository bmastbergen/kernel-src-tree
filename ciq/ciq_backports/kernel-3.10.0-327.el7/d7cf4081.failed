netfilter: Pass nf_hook_state through nf_nat_ipv4_{in,out,fn,local_fn}().

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] netfilter: Pass nf_hook_state through nf_nat_ipv4_{in, out, fn, local_fn}() (Jiri Benc) [1230935]
Rebuild_FUZZ: 97.30%
commit-author David S. Miller <davem@davemloft.net>
commit d7cf4081ed454dba02cb632e492ecf5e29d1ee44
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/d7cf4081.failed

	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d7cf4081ed454dba02cb632e492ecf5e29d1ee44)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/netfilter/iptable_nat.c
#	net/ipv4/netfilter/nft_chain_nat_ipv4.c
diff --cc net/ipv4/netfilter/iptable_nat.c
index 2b6df3a92f3e,086e2311438e..000000000000
--- a/net/ipv4/netfilter/iptable_nat.c
+++ b/net/ipv4/netfilter/iptable_nat.c
@@@ -41,38 -41,30 +41,54 @@@ static unsigned int iptable_nat_do_chai
  
  static unsigned int iptable_nat_ipv4_fn(const struct nf_hook_ops *ops,
  					struct sk_buff *skb,
 -					const struct nf_hook_state *state)
 +					const struct net_device *in,
 +					const struct net_device *out,
 +					int (*okfn)(struct sk_buff *))
  {
++<<<<<<< HEAD
 +	return nf_nat_ipv4_fn(ops, skb, in, out, iptable_nat_do_chain);
++=======
+ 	return nf_nat_ipv4_fn(ops, skb, state, iptable_nat_do_chain);
++>>>>>>> d7cf4081ed45 (netfilter: Pass nf_hook_state through nf_nat_ipv4_{in,out,fn,local_fn}().)
  }
  
  static unsigned int iptable_nat_ipv4_in(const struct nf_hook_ops *ops,
  					struct sk_buff *skb,
 -					const struct nf_hook_state *state)
 +					const struct net_device *in,
 +					const struct net_device *out,
 +					int (*okfn)(struct sk_buff *))
  {
++<<<<<<< HEAD
 +	return nf_nat_ipv4_in(ops, skb, in, out, iptable_nat_do_chain);
++=======
+ 	return nf_nat_ipv4_in(ops, skb, state, iptable_nat_do_chain);
++>>>>>>> d7cf4081ed45 (netfilter: Pass nf_hook_state through nf_nat_ipv4_{in,out,fn,local_fn}().)
  }
  
  static unsigned int iptable_nat_ipv4_out(const struct nf_hook_ops *ops,
  					 struct sk_buff *skb,
 -					 const struct nf_hook_state *state)
 +					 const struct net_device *in,
 +					 const struct net_device *out,
 +					 int (*okfn)(struct sk_buff *))
  {
++<<<<<<< HEAD
 +	return nf_nat_ipv4_out(ops, skb, in, out, iptable_nat_do_chain);
++=======
+ 	return nf_nat_ipv4_out(ops, skb, state, iptable_nat_do_chain);
++>>>>>>> d7cf4081ed45 (netfilter: Pass nf_hook_state through nf_nat_ipv4_{in,out,fn,local_fn}().)
  }
  
  static unsigned int iptable_nat_ipv4_local_fn(const struct nf_hook_ops *ops,
  					      struct sk_buff *skb,
 -					      const struct nf_hook_state *state)
 +					      const struct net_device *in,
 +					      const struct net_device *out,
 +					      int (*okfn)(struct sk_buff *))
  {
++<<<<<<< HEAD
 +	return nf_nat_ipv4_local_fn(ops, skb, in, out, iptable_nat_do_chain);
++=======
+ 	return nf_nat_ipv4_local_fn(ops, skb, state, iptable_nat_do_chain);
++>>>>>>> d7cf4081ed45 (netfilter: Pass nf_hook_state through nf_nat_ipv4_{in,out,fn,local_fn}().)
  }
  
  static struct nf_hook_ops nf_nat_ipv4_ops[] __read_mostly = {
diff --cc net/ipv4/netfilter/nft_chain_nat_ipv4.c
index df547bf50078,f56bbb1ab1a0..000000000000
--- a/net/ipv4/netfilter/nft_chain_nat_ipv4.c
+++ b/net/ipv4/netfilter/nft_chain_nat_ipv4.c
@@@ -41,38 -40,30 +40,54 @@@ static unsigned int nft_nat_do_chain(co
  
  static unsigned int nft_nat_ipv4_fn(const struct nf_hook_ops *ops,
  				    struct sk_buff *skb,
 -				    const struct nf_hook_state *state)
 +				    const struct net_device *in,
 +				    const struct net_device *out,
 +				    int (*okfn)(struct sk_buff *))
  {
++<<<<<<< HEAD
 +	return nf_nat_ipv4_fn(ops, skb, in, out, nft_nat_do_chain);
++=======
+ 	return nf_nat_ipv4_fn(ops, skb, state, nft_nat_do_chain);
++>>>>>>> d7cf4081ed45 (netfilter: Pass nf_hook_state through nf_nat_ipv4_{in,out,fn,local_fn}().)
  }
  
  static unsigned int nft_nat_ipv4_in(const struct nf_hook_ops *ops,
  				    struct sk_buff *skb,
 -				    const struct nf_hook_state *state)
 +				    const struct net_device *in,
 +				    const struct net_device *out,
 +				    int (*okfn)(struct sk_buff *))
  {
++<<<<<<< HEAD
 +	return nf_nat_ipv4_in(ops, skb, in, out, nft_nat_do_chain);
++=======
+ 	return nf_nat_ipv4_in(ops, skb, state, nft_nat_do_chain);
++>>>>>>> d7cf4081ed45 (netfilter: Pass nf_hook_state through nf_nat_ipv4_{in,out,fn,local_fn}().)
  }
  
  static unsigned int nft_nat_ipv4_out(const struct nf_hook_ops *ops,
  				     struct sk_buff *skb,
 -				     const struct nf_hook_state *state)
 +				     const struct net_device *in,
 +				     const struct net_device *out,
 +				     int (*okfn)(struct sk_buff *))
  {
++<<<<<<< HEAD
 +	return nf_nat_ipv4_out(ops, skb, in, out, nft_nat_do_chain);
++=======
+ 	return nf_nat_ipv4_out(ops, skb, state, nft_nat_do_chain);
++>>>>>>> d7cf4081ed45 (netfilter: Pass nf_hook_state through nf_nat_ipv4_{in,out,fn,local_fn}().)
  }
  
  static unsigned int nft_nat_ipv4_local_fn(const struct nf_hook_ops *ops,
  					  struct sk_buff *skb,
 -					  const struct nf_hook_state *state)
 +					  const struct net_device *in,
 +					  const struct net_device *out,
 +					  int (*okfn)(struct sk_buff *))
  {
++<<<<<<< HEAD
 +	return nf_nat_ipv4_local_fn(ops, skb, in, out, nft_nat_do_chain);
++=======
+ 	return nf_nat_ipv4_local_fn(ops, skb, state, nft_nat_do_chain);
++>>>>>>> d7cf4081ed45 (netfilter: Pass nf_hook_state through nf_nat_ipv4_{in,out,fn,local_fn}().)
  }
  
  static const struct nf_chain_type nft_chain_nat_ipv4 = {
diff --git a/include/net/netfilter/nf_nat_l3proto.h b/include/net/netfilter/nf_nat_l3proto.h
index 340c013795a4..e596f35f14c9 100644
--- a/include/net/netfilter/nf_nat_l3proto.h
+++ b/include/net/netfilter/nf_nat_l3proto.h
@@ -44,40 +44,32 @@ int nf_nat_icmp_reply_translation(struct sk_buff *skb, struct nf_conn *ct,
 				  unsigned int hooknum);
 
 unsigned int nf_nat_ipv4_in(const struct nf_hook_ops *ops, struct sk_buff *skb,
-			    const struct net_device *in,
-			    const struct net_device *out,
+			    const struct nf_hook_state *state,
 			    unsigned int (*do_chain)(const struct nf_hook_ops *ops,
 						     struct sk_buff *skb,
-						     const struct net_device *in,
-						     const struct net_device *out,
+						     const struct nf_hook_state *state,
 						     struct nf_conn *ct));
 
 unsigned int nf_nat_ipv4_out(const struct nf_hook_ops *ops, struct sk_buff *skb,
-			     const struct net_device *in,
-			     const struct net_device *out,
+			     const struct nf_hook_state *state,
 			     unsigned int (*do_chain)(const struct nf_hook_ops *ops,
 						      struct sk_buff *skb,
-						      const struct net_device *in,
-						      const struct net_device *out,
+						      const struct nf_hook_state *state,
 						      struct nf_conn *ct));
 
 unsigned int nf_nat_ipv4_local_fn(const struct nf_hook_ops *ops,
 				  struct sk_buff *skb,
-				  const struct net_device *in,
-				  const struct net_device *out,
+				  const struct nf_hook_state *state,
 				  unsigned int (*do_chain)(const struct nf_hook_ops *ops,
 							   struct sk_buff *skb,
-							   const struct net_device *in,
-							   const struct net_device *out,
+							   const struct nf_hook_state *state,
 							   struct nf_conn *ct));
 
 unsigned int nf_nat_ipv4_fn(const struct nf_hook_ops *ops, struct sk_buff *skb,
-			    const struct net_device *in,
-			    const struct net_device *out,
+			    const struct nf_hook_state *state,
 			    unsigned int (*do_chain)(const struct nf_hook_ops *ops,
 						     struct sk_buff *skb,
-						     const struct net_device *in,
-						     const struct net_device *out,
+						     const struct nf_hook_state *state,
 						     struct nf_conn *ct));
 
 int nf_nat_icmpv6_reply_translation(struct sk_buff *skb, struct nf_conn *ct,
* Unmerged path net/ipv4/netfilter/iptable_nat.c
diff --git a/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c b/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
index 70fa17ce6eac..b550885b5986 100644
--- a/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
+++ b/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
@@ -252,11 +252,10 @@ EXPORT_SYMBOL_GPL(nf_nat_icmp_reply_translation);
 
 unsigned int
 nf_nat_ipv4_fn(const struct nf_hook_ops *ops, struct sk_buff *skb,
-	       const struct net_device *in, const struct net_device *out,
+	       const struct nf_hook_state *state,
 	       unsigned int (*do_chain)(const struct nf_hook_ops *ops,
 					struct sk_buff *skb,
-					const struct net_device *in,
-					const struct net_device *out,
+					const struct nf_hook_state *state,
 					struct nf_conn *ct))
 {
 	struct nf_conn *ct;
@@ -305,7 +304,7 @@ nf_nat_ipv4_fn(const struct nf_hook_ops *ops, struct sk_buff *skb,
 		if (!nf_nat_initialized(ct, maniptype)) {
 			unsigned int ret;
 
-			ret = do_chain(ops, skb, in, out, ct);
+			ret = do_chain(ops, skb, state, ct);
 			if (ret != NF_ACCEPT)
 				return ret;
 
@@ -319,7 +318,8 @@ nf_nat_ipv4_fn(const struct nf_hook_ops *ops, struct sk_buff *skb,
 			pr_debug("Already setup manip %s for ct %p\n",
 				 maniptype == NF_NAT_MANIP_SRC ? "SRC" : "DST",
 				 ct);
-			if (nf_nat_oif_changed(ops->hooknum, ctinfo, nat, out))
+			if (nf_nat_oif_changed(ops->hooknum, ctinfo, nat,
+					       state->out))
 				goto oif_changed;
 		}
 		break;
@@ -328,7 +328,7 @@ nf_nat_ipv4_fn(const struct nf_hook_ops *ops, struct sk_buff *skb,
 		/* ESTABLISHED */
 		NF_CT_ASSERT(ctinfo == IP_CT_ESTABLISHED ||
 			     ctinfo == IP_CT_ESTABLISHED_REPLY);
-		if (nf_nat_oif_changed(ops->hooknum, ctinfo, nat, out))
+		if (nf_nat_oif_changed(ops->hooknum, ctinfo, nat, state->out))
 			goto oif_changed;
 	}
 
@@ -342,17 +342,16 @@ EXPORT_SYMBOL_GPL(nf_nat_ipv4_fn);
 
 unsigned int
 nf_nat_ipv4_in(const struct nf_hook_ops *ops, struct sk_buff *skb,
-	       const struct net_device *in, const struct net_device *out,
+	       const struct nf_hook_state *state,
 	       unsigned int (*do_chain)(const struct nf_hook_ops *ops,
 					 struct sk_buff *skb,
-					 const struct net_device *in,
-					 const struct net_device *out,
+					 const struct nf_hook_state *state,
 					 struct nf_conn *ct))
 {
 	unsigned int ret;
 	__be32 daddr = ip_hdr(skb)->daddr;
 
-	ret = nf_nat_ipv4_fn(ops, skb, in, out, do_chain);
+	ret = nf_nat_ipv4_fn(ops, skb, state, do_chain);
 	if (ret != NF_DROP && ret != NF_STOLEN &&
 	    daddr != ip_hdr(skb)->daddr)
 		skb_dst_drop(skb);
@@ -363,11 +362,10 @@ EXPORT_SYMBOL_GPL(nf_nat_ipv4_in);
 
 unsigned int
 nf_nat_ipv4_out(const struct nf_hook_ops *ops, struct sk_buff *skb,
-		const struct net_device *in, const struct net_device *out,
+		const struct nf_hook_state *state,
 		unsigned int (*do_chain)(const struct nf_hook_ops *ops,
 					  struct sk_buff *skb,
-					  const struct net_device *in,
-					  const struct net_device *out,
+					  const struct nf_hook_state *state,
 					  struct nf_conn *ct))
 {
 #ifdef CONFIG_XFRM
@@ -382,7 +380,7 @@ nf_nat_ipv4_out(const struct nf_hook_ops *ops, struct sk_buff *skb,
 	    ip_hdrlen(skb) < sizeof(struct iphdr))
 		return NF_ACCEPT;
 
-	ret = nf_nat_ipv4_fn(ops, skb, in, out, do_chain);
+	ret = nf_nat_ipv4_fn(ops, skb, state, do_chain);
 #ifdef CONFIG_XFRM
 	if (ret != NF_DROP && ret != NF_STOLEN &&
 	    !(IPCB(skb)->flags & IPSKB_XFRM_TRANSFORMED) &&
@@ -406,11 +404,10 @@ EXPORT_SYMBOL_GPL(nf_nat_ipv4_out);
 
 unsigned int
 nf_nat_ipv4_local_fn(const struct nf_hook_ops *ops, struct sk_buff *skb,
-		     const struct net_device *in, const struct net_device *out,
+		     const struct nf_hook_state *state,
 		     unsigned int (*do_chain)(const struct nf_hook_ops *ops,
 					       struct sk_buff *skb,
-					       const struct net_device *in,
-					       const struct net_device *out,
+					       const struct nf_hook_state *state,
 					       struct nf_conn *ct))
 {
 	const struct nf_conn *ct;
@@ -423,7 +420,7 @@ nf_nat_ipv4_local_fn(const struct nf_hook_ops *ops, struct sk_buff *skb,
 	    ip_hdrlen(skb) < sizeof(struct iphdr))
 		return NF_ACCEPT;
 
-	ret = nf_nat_ipv4_fn(ops, skb, in, out, do_chain);
+	ret = nf_nat_ipv4_fn(ops, skb, state, do_chain);
 	if (ret != NF_DROP && ret != NF_STOLEN &&
 	    (ct = nf_ct_get(skb, &ctinfo)) != NULL) {
 		enum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);
* Unmerged path net/ipv4/netfilter/nft_chain_nat_ipv4.c
