xfs: xfs_bioerror can die.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [fs] xfs: xfs_bioerror can die (Brian Foster) [1184177]
Rebuild_FUZZ: 98.04%
commit-author Dave Chinner <dchinner@redhat.com>
commit 2718775469a521c8b35442db5d665ac0c8c3c8ac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/27187754.failed

Internal buffer write error handling is a mess due to the unnatural
split between xfs_bioerror and xfs_bioerror_relse().

xfs_bwrite() only does sync IO and determines the handler to
call based on b_iodone, so for this caller the only difference
between xfs_bioerror() and xfs_bioerror_release() is the XBF_DONE
flag. We don't care what the XBF_DONE flag state is because we stale
the buffer in both paths - the next buffer lookup will clear
XBF_DONE because XBF_STALE is set. Hence we can use common
error handling for xfs_bwrite().

__xfs_buf_delwri_submit() is a similar - it's only ever called
on writes - all sync or async - and again there's no reason to
handle them any differently at all.

Clean up the nasty error handling and remove xfs_bioerror().

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit 2718775469a521c8b35442db5d665ac0c8c3c8ac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_buf.c
diff --cc fs/xfs/xfs_buf.c
index 84e0417dc6f7,409a8a06642a..000000000000
--- a/fs/xfs/xfs_buf.c
+++ b/fs/xfs/xfs_buf.c
@@@ -1099,43 -1071,10 +1099,46 @@@ xfs_buf_ioerror_alert
  {
  	xfs_alert(bp->b_target->bt_mount,
  "metadata I/O error: block 0x%llx (\"%s\") error %d numblks %d",
 -		(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);
 +		(__uint64_t)XFS_BUF_ADDR(bp), func, bp->b_error, bp->b_length);
 +}
 +
 +/*
++<<<<<<< HEAD
 + * Called when we want to stop a buffer from getting written or read.
 + * We attach the EIO error, muck with its flags, and call xfs_buf_ioend
 + * so that the proper iodone callbacks get called.
 + */
 +STATIC int
 +xfs_bioerror(
 +	xfs_buf_t *bp)
 +{
 +#ifdef XFSERRORDEBUG
 +	ASSERT(XFS_BUF_ISREAD(bp) || bp->b_iodone);
 +#endif
 +
 +	/*
 +	 * No need to wait until the buffer is unpinned, we aren't flushing it.
 +	 */
 +	xfs_buf_ioerror(bp, EIO);
 +
 +	/*
 +	 * We're calling xfs_buf_ioend, so delete XBF_DONE flag. For
 +	 * sync IO, xfs_buf_ioend is going to remove a ref here.
 +	 */
 +	if (!(bp->b_flags & XBF_ASYNC))
 +		xfs_buf_hold(bp);
 +	XFS_BUF_UNREAD(bp);
 +	XFS_BUF_UNDONE(bp);
 +	xfs_buf_stale(bp);
 +
 +	xfs_buf_ioend(bp, 0);
 +
 +	return EIO;
  }
  
  /*
++=======
++>>>>>>> 2718775469a5 (xfs: xfs_bioerror can die.)
   * Same as xfs_bioerror, except that we are releasing the buffer
   * here ourselves, and avoiding the xfs_buf_ioend call.
   * This is meant for userdata errors; metadata bufs come with
* Unmerged path fs/xfs/xfs_buf.c
