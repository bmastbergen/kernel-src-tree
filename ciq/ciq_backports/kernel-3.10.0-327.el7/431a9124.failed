tcp: timestamp SYN+DATA messages

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Eric Dumazet <edumazet@google.com>
commit 431a91242d8d7876d33ab91b1f3ccdcd56b14f66
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/431a9124.failed

All skb in socket write queue should be properly timestamped.

In case of FastOpen, we special case the SYN+DATA 'message' as we
queue in socket wrote queue the two fallback skbs:

1) SYN message by itself.
2) DATA segment by itself.

We should make sure these skbs have proper timestamps.

Add a WARN_ON_ONCE() to eventually catch future violations.

Fixes: 740b0f1841f6 ("tcp: switch rtt estimations to usec resolution")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Cc: Neal Cardwell <ncardwell@google.com>
	Cc: Yuchung Cheng <ycheng@google.com>
	Acked-by: Neal Cardwell <ncardwell@google.com>
	Acked-by: Yuchung Cheng <ycheng@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 431a91242d8d7876d33ab91b1f3ccdcd56b14f66)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_input.c
diff --cc net/ipv4/tcp_input.c
index 5c9d537a2d7a,e1661f46fd19..000000000000
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@@ -3044,11 -3066,11 +3044,19 @@@ static int tcp_clean_rtx_queue(struct s
  				tp->retrans_out -= acked_pcount;
  			flag |= FLAG_RETRANS_DATA_ACKED;
  		} else {
++<<<<<<< HEAD
 +			ca_seq_rtt = now - scb->when;
 +			last_ackt = skb->tstamp;
 +			if (seq_rtt < 0) {
 +				seq_rtt = ca_seq_rtt;
 +			}
++=======
+ 			last_ackt = skb->skb_mstamp;
+ 			WARN_ON_ONCE(last_ackt.v64 == 0);
+ 			if (!first_ackt.v64)
+ 				first_ackt = last_ackt;
+ 
++>>>>>>> 431a91242d8d (tcp: timestamp SYN+DATA messages)
  			if (!(sacked & TCPCB_SACKED_ACKED))
  				reord = min(pkts_acked, reord);
  			if (!after(scb->end_seq, tp->high_seq))
* Unmerged path net/ipv4/tcp_input.c
diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c
index 59de9bc982c9..156460d328af 100644
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@ -2975,6 +2975,12 @@ static int tcp_send_syn_data(struct sock *sk, struct sk_buff *syn)
 	tcp_connect_queue_skb(sk, data);
 	fo->copied = data->len;
 
+	/* syn_data is about to be sent, we need to take current time stamps
+	 * for the packets that are in write queue : SYN packet and DATA
+	 */
+	skb_mstamp_get(&syn->skb_mstamp);
+	data->skb_mstamp = syn->skb_mstamp;
+
 	if (tcp_transmit_skb(sk, syn_data, 0, sk->sk_allocation) == 0) {
 		tp->syn_data = (fo->copied > 0);
 		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPORIGDATASENT);
