xfs: refactor xlog_recover_process_data()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit eeb1168810d8a140f6834f8c4975f7bb3277d790
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/eeb11688.failed

Clean up xlog_recover_process_data() structure in preparation for
fixing the allocation and freeing context of the transaction being
recovered.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit eeb1168810d8a140f6834f8c4975f7bb3277d790)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_log_recover.c
diff --cc fs/xfs/xfs_log_recover.c
index da155de2b4de,8105b8571979..000000000000
--- a/fs/xfs/xfs_log_recover.c
+++ b/fs/xfs/xfs_log_recover.c
@@@ -3573,72 -3682,20 +3681,87 @@@ xlog_recover_process_data
  
  	/* check the log format matches our own - else we can't recover */
  	if (xlog_header_check_recover(log->l_mp, rhead))
 -		return -EIO;
 -
 +		return XFS_ERROR(EIO);
 +
++<<<<<<< HEAD
 +	while ((dp < lp) && num_logops) {
 +		ASSERT(dp + sizeof(xlog_op_header_t) <= lp);
 +		ohead = (xlog_op_header_t *)dp;
 +		dp += sizeof(xlog_op_header_t);
 +		if (ohead->oh_clientid != XFS_TRANSACTION &&
 +		    ohead->oh_clientid != XFS_LOG) {
 +			xfs_warn(log->l_mp, "%s: bad clientid 0x%x",
 +					__func__, ohead->oh_clientid);
 +			ASSERT(0);
 +			return XFS_ERROR(EIO);
 +		}
 +		tid = be32_to_cpu(ohead->oh_tid);
 +		hash = XLOG_RHASH(tid);
 +		trans = xlog_recover_find_tid(&rhash[hash], tid);
 +		if (trans == NULL) {		   /* not found; add new tid */
 +			if (ohead->oh_flags & XLOG_START_TRANS)
 +				xlog_recover_new_tid(&rhash[hash], tid,
 +					be64_to_cpu(rhead->h_lsn));
 +		} else {
 +			if (dp + be32_to_cpu(ohead->oh_len) > lp) {
 +				xfs_warn(log->l_mp, "%s: bad length 0x%x",
 +					__func__, be32_to_cpu(ohead->oh_len));
 +				WARN_ON(1);
 +				return XFS_ERROR(EIO);
 +			}
 +			flags = ohead->oh_flags & ~XLOG_END_TRANS;
 +			if (flags & XLOG_WAS_CONT_TRANS)
 +				flags &= ~XLOG_CONTINUE_TRANS;
 +			switch (flags) {
 +			case XLOG_COMMIT_TRANS:
 +				error = xlog_recover_commit_trans(log,
 +								trans, pass);
 +				break;
 +			case XLOG_UNMOUNT_TRANS:
 +				error = xlog_recover_unmount_trans(log);
 +				break;
 +			case XLOG_WAS_CONT_TRANS:
 +				error = xlog_recover_add_to_cont_trans(log,
 +						trans, dp,
 +						be32_to_cpu(ohead->oh_len));
 +				break;
 +			case XLOG_START_TRANS:
 +				xfs_warn(log->l_mp, "%s: bad transaction",
 +					__func__);
 +				ASSERT(0);
 +				error = XFS_ERROR(EIO);
 +				break;
 +			case 0:
 +			case XLOG_CONTINUE_TRANS:
 +				error = xlog_recover_add_to_trans(log, trans,
 +						dp, be32_to_cpu(ohead->oh_len));
 +				break;
 +			default:
 +				xfs_warn(log->l_mp, "%s: bad flag 0x%x",
 +					__func__, flags);
 +				ASSERT(0);
 +				error = XFS_ERROR(EIO);
 +				break;
 +			}
 +			if (error) {
 +				xlog_recover_free_trans(trans);
 +				return error;
 +			}
 +		}
++=======
+ 	while ((dp < end) && num_logops) {
+ 
+ 		ohead = (struct xlog_op_header *)dp;
+ 		dp += sizeof(*ohead);
+ 		ASSERT(dp <= end);
+ 
+ 		/* errors will abort recovery */
+ 		error = xlog_recover_process_ophdr(log, rhash, rhead, ohead,
+ 						    dp, end, pass);
+ 		if (error)
+ 			return error;
+ 
++>>>>>>> eeb1168810d8 (xfs: refactor xlog_recover_process_data())
  		dp += be32_to_cpu(ohead->oh_len);
  		num_logops--;
  	}
* Unmerged path fs/xfs/xfs_log_recover.c
