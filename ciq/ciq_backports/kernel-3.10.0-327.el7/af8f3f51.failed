ACPI / processor: Convert apic_id to phys_id to make it arch agnostic

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [acpi] processor: Convert apic_id to phys_id to make it arch agnostic (Prarit Bhargava) [1201167]
Rebuild_FUZZ: 94.66%
commit-author Hanjun Guo <hanjun.guo@linaro.com>
commit af8f3f514d193eb353f9b6cea503c55d074e6153
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/af8f3f51.failed

apic_id in MADT table is the CPU hardware id which identify
it self in the system for x86 and ia64, OSPM will use it for
SMP init to map APIC ID to logical cpu number in the early
boot, when the DSDT/SSDT (ACPI namespace) is scanned later, the
ACPI processor driver is probed and the driver will use acpi_id
in DSDT to get the apic_id, then map to the logical cpu number
which is needed by the processor driver.

Before ACPI 5.0, only x86 and ia64 were supported in ACPI spec,
so apic_id is used both in arch code and ACPI core which is
pretty fine. Since ACPI 5.0, ARM is supported by ACPI and
APIC is not available on ARM, this will confuse people when
apic_id is both used by x86 and ARM in one function.

So convert apic_id to phys_id (which is the original meaning)
in ACPI processor dirver to make it arch agnostic, but leave the
arch dependent code unchanged, no functional change.

	Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit af8f3f514d193eb353f9b6cea503c55d074e6153)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/acpi_processor.c
#	drivers/acpi/processor_core.c
#	include/acpi/processor.h
diff --cc drivers/acpi/acpi_processor.c
index d7c489f22298,f02b29eb0fda..000000000000
--- a/drivers/acpi/acpi_processor.c
+++ b/drivers/acpi/acpi_processor.c
@@@ -174,13 -170,19 +174,26 @@@ static int acpi_processor_hotadd_init(s
  	acpi_status status;
  	int ret;
  
++<<<<<<< HEAD
++=======
+ 	if (pr->phys_id == -1)
+ 		return -ENODEV;
+ 
++>>>>>>> af8f3f514d19 (ACPI / processor: Convert apic_id to phys_id to make it arch agnostic)
  	status = acpi_evaluate_integer(pr->handle, "_STA", NULL, &sta);
  	if (ACPI_FAILURE(status) || !(sta & ACPI_STA_DEVICE_PRESENT))
  		return -ENODEV;
  
++<<<<<<< HEAD
 +	ret = acpi_map_lsapic(pr->handle, &pr->id);
++=======
+ 	cpu_maps_update_begin();
+ 	cpu_hotplug_begin();
+ 
+ 	ret = acpi_map_lsapic(pr->handle, pr->phys_id, &pr->id);
++>>>>>>> af8f3f514d19 (ACPI / processor: Convert apic_id to phys_id to make it arch agnostic)
  	if (ret)
 -		goto out;
 +		return ret;
  
  	ret = arch_register_cpu(pr->id);
  	if (ret) {
@@@ -209,14 -215,12 +222,14 @@@ static int acpi_processor_get_info(stru
  	union acpi_object object = { 0 };
  	struct acpi_buffer buffer = { sizeof(union acpi_object), &object };
  	struct acpi_processor *pr = acpi_driver_data(device);
- 	int apic_id, cpu_index, device_declaration = 0;
+ 	int phys_id, cpu_index, device_declaration = 0;
  	acpi_status status = AE_OK;
  	static int cpu0_initialized;
 -	unsigned long long value;
  
 -	acpi_processor_errata();
 +	if (num_online_cpus() > 1)
 +		errata.smp = TRUE;
 +
 +	acpi_processor_errata(pr);
  
  	/*
  	 * Check to see if we have bus mastering arbitration control.  This
@@@ -264,17 -262,18 +277,30 @@@
  		pr->acpi_id = value;
  	}
  
++<<<<<<< HEAD
 +	apic_id = acpi_get_apicid(pr->handle, device_declaration, pr->acpi_id);
 +	if (apic_id < 0) {
 +		acpi_handle_err(pr->handle, "failed to get CPU APIC ID.\n");
 +		return -ENODEV;
 +	}
 +	pr->apic_id = apic_id;
 +
 +	cpu_index = acpi_map_cpuid(pr->apic_id, pr->acpi_id);
 +	if (!cpu0_initialized) {
++=======
+ 	phys_id = acpi_get_phys_id(pr->handle, device_declaration, pr->acpi_id);
+ 	if (phys_id < 0)
+ 		acpi_handle_debug(pr->handle, "failed to get CPU physical ID.\n");
+ 	pr->phys_id = phys_id;
+ 
+ 	cpu_index = acpi_map_cpuid(pr->phys_id, pr->acpi_id);
+ 	if (!cpu0_initialized && !acpi_has_cpu_in_madt()) {
++>>>>>>> af8f3f514d19 (ACPI / processor: Convert apic_id to phys_id to make it arch agnostic)
  		cpu0_initialized = 1;
- 		/* Handle UP system running SMP kernel, with no LAPIC in MADT */
+ 		/*
+ 		 * Handle UP system running SMP kernel, with no CPU
+ 		 * entry in MADT
+ 		 */
  		if ((cpu_index == -1) && (num_online_cpus() == 1))
  			cpu_index = 0;
  	}
diff --cc drivers/acpi/processor_core.c
index 99405b286b4c,02e48394276c..000000000000
--- a/drivers/acpi/processor_core.c
+++ b/drivers/acpi/processor_core.c
@@@ -116,13 -91,13 +116,23 @@@ static int map_madt_entry(int type, u3
  		struct acpi_subtable_header *header =
  			(struct acpi_subtable_header *)entry;
  		if (header->type == ACPI_MADT_TYPE_LOCAL_APIC) {
++<<<<<<< HEAD
 +			if (map_lapic_id(header, acpi_id, &apic_id))
 +				break;
 +		} else if (header->type == ACPI_MADT_TYPE_LOCAL_X2APIC) {
 +			if (map_x2apic_id(header, type, acpi_id, &apic_id))
 +				break;
 +		} else if (header->type == ACPI_MADT_TYPE_LOCAL_SAPIC) {
 +			if (map_lsapic_id(header, type, acpi_id, &apic_id))
++=======
+ 			if (!map_lapic_id(header, acpi_id, &phys_id))
+ 				break;
+ 		} else if (header->type == ACPI_MADT_TYPE_LOCAL_X2APIC) {
+ 			if (!map_x2apic_id(header, type, acpi_id, &phys_id))
+ 				break;
+ 		} else if (header->type == ACPI_MADT_TYPE_LOCAL_SAPIC) {
+ 			if (!map_lsapic_id(header, type, acpi_id, &phys_id))
++>>>>>>> af8f3f514d19 (ACPI / processor: Convert apic_id to phys_id to make it arch agnostic)
  				break;
  		}
  		entry += header->length;
@@@ -150,13 -125,12 +160,22 @@@ static int map_mat_entry(acpi_handle ha
  	}
  
  	header = (struct acpi_subtable_header *)obj->buffer.pointer;
++<<<<<<< HEAD
 +	if (header->type == ACPI_MADT_TYPE_LOCAL_APIC) {
 +		map_lapic_id(header, acpi_id, &apic_id);
 +	} else if (header->type == ACPI_MADT_TYPE_LOCAL_SAPIC) {
 +		map_lsapic_id(header, type, acpi_id, &apic_id);
 +	} else if (header->type == ACPI_MADT_TYPE_LOCAL_X2APIC) {
 +		map_x2apic_id(header, type, acpi_id, &apic_id);
 +	}
++=======
+ 	if (header->type == ACPI_MADT_TYPE_LOCAL_APIC)
+ 		map_lapic_id(header, acpi_id, &phys_id);
+ 	else if (header->type == ACPI_MADT_TYPE_LOCAL_SAPIC)
+ 		map_lsapic_id(header, type, acpi_id, &phys_id);
+ 	else if (header->type == ACPI_MADT_TYPE_LOCAL_X2APIC)
+ 		map_x2apic_id(header, type, acpi_id, &phys_id);
++>>>>>>> af8f3f514d19 (ACPI / processor: Convert apic_id to phys_id to make it arch agnostic)
  
  exit:
  	kfree(buffer.pointer);
@@@ -222,175 -196,10 +241,175 @@@ int acpi_map_cpuid(int phys_id, u32 acp
  
  int acpi_get_cpuid(acpi_handle handle, int type, u32 acpi_id)
  {
- 	int apic_id;
+ 	int phys_id;
  
- 	apic_id = acpi_get_apicid(handle, type, acpi_id);
+ 	phys_id = acpi_get_phys_id(handle, type, acpi_id);
  
- 	return acpi_map_cpuid(apic_id, acpi_id);
+ 	return acpi_map_cpuid(phys_id, acpi_id);
  }
  EXPORT_SYMBOL_GPL(acpi_get_cpuid);
 +
 +static bool __init processor_physically_present(acpi_handle handle)
 +{
 +	int cpuid, type;
 +	u32 acpi_id;
 +	acpi_status status;
 +	acpi_object_type acpi_type;
 +	unsigned long long tmp;
 +	union acpi_object object = { 0 };
 +	struct acpi_buffer buffer = { sizeof(union acpi_object), &object };
 +
 +	status = acpi_get_type(handle, &acpi_type);
 +	if (ACPI_FAILURE(status))
 +		return false;
 +
 +	switch (acpi_type) {
 +	case ACPI_TYPE_PROCESSOR:
 +		status = acpi_evaluate_object(handle, NULL, NULL, &buffer);
 +		if (ACPI_FAILURE(status))
 +			return false;
 +		acpi_id = object.processor.proc_id;
 +		break;
 +	case ACPI_TYPE_DEVICE:
 +		status = acpi_evaluate_integer(handle, "_UID", NULL, &tmp);
 +		if (ACPI_FAILURE(status))
 +			return false;
 +		acpi_id = tmp;
 +		break;
 +	default:
 +		return false;
 +	}
 +
 +	type = (acpi_type == ACPI_TYPE_DEVICE) ? 1 : 0;
 +	cpuid = acpi_get_cpuid(handle, type, acpi_id);
 +
 +	if (cpuid == -1)
 +		return false;
 +
 +	return true;
 +}
 +
 +static void acpi_set_pdc_bits(u32 *buf)
 +{
 +	buf[0] = ACPI_PDC_REVISION_ID;
 +	buf[1] = 1;
 +
 +	/* Enable coordination with firmware's _TSD info */
 +	buf[2] = ACPI_PDC_SMP_T_SWCOORD;
 +
 +	/* Twiddle arch-specific bits needed for _PDC */
 +	arch_acpi_set_pdc_bits(buf);
 +}
 +
 +static struct acpi_object_list *acpi_processor_alloc_pdc(void)
 +{
 +	struct acpi_object_list *obj_list;
 +	union acpi_object *obj;
 +	u32 *buf;
 +
 +	/* allocate and initialize pdc. It will be used later. */
 +	obj_list = kmalloc(sizeof(struct acpi_object_list), GFP_KERNEL);
 +	if (!obj_list) {
 +		printk(KERN_ERR "Memory allocation error\n");
 +		return NULL;
 +	}
 +
 +	obj = kmalloc(sizeof(union acpi_object), GFP_KERNEL);
 +	if (!obj) {
 +		printk(KERN_ERR "Memory allocation error\n");
 +		kfree(obj_list);
 +		return NULL;
 +	}
 +
 +	buf = kmalloc(12, GFP_KERNEL);
 +	if (!buf) {
 +		printk(KERN_ERR "Memory allocation error\n");
 +		kfree(obj);
 +		kfree(obj_list);
 +		return NULL;
 +	}
 +
 +	acpi_set_pdc_bits(buf);
 +
 +	obj->type = ACPI_TYPE_BUFFER;
 +	obj->buffer.length = 12;
 +	obj->buffer.pointer = (u8 *) buf;
 +	obj_list->count = 1;
 +	obj_list->pointer = obj;
 +
 +	return obj_list;
 +}
 +
 +/*
 + * _PDC is required for a BIOS-OS handshake for most of the newer
 + * ACPI processor features.
 + */
 +static int
 +acpi_processor_eval_pdc(acpi_handle handle, struct acpi_object_list *pdc_in)
 +{
 +	acpi_status status = AE_OK;
 +
 +	if (boot_option_idle_override == IDLE_NOMWAIT) {
 +		/*
 +		 * If mwait is disabled for CPU C-states, the C2C3_FFH access
 +		 * mode will be disabled in the parameter of _PDC object.
 +		 * Of course C1_FFH access mode will also be disabled.
 +		 */
 +		union acpi_object *obj;
 +		u32 *buffer = NULL;
 +
 +		obj = pdc_in->pointer;
 +		buffer = (u32 *)(obj->buffer.pointer);
 +		buffer[2] &= ~(ACPI_PDC_C_C2C3_FFH | ACPI_PDC_C_C1_FFH);
 +
 +	}
 +	status = acpi_evaluate_object(handle, "_PDC", pdc_in, NULL);
 +
 +	if (ACPI_FAILURE(status))
 +		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 +		    "Could not evaluate _PDC, using legacy perf. control.\n"));
 +
 +	return status;
 +}
 +
 +void acpi_processor_set_pdc(acpi_handle handle)
 +{
 +	struct acpi_object_list *obj_list;
 +
 +	if (arch_has_acpi_pdc() == false)
 +		return;
 +
 +	obj_list = acpi_processor_alloc_pdc();
 +	if (!obj_list)
 +		return;
 +
 +	acpi_processor_eval_pdc(handle, obj_list);
 +
 +	kfree(obj_list->pointer->buffer.pointer);
 +	kfree(obj_list->pointer);
 +	kfree(obj_list);
 +}
 +
 +static acpi_status __init
 +early_init_pdc(acpi_handle handle, u32 lvl, void *context, void **rv)
 +{
 +	if (processor_physically_present(handle) == false)
 +		return AE_OK;
 +
 +	acpi_processor_set_pdc(handle);
 +	return AE_OK;
 +}
 +
 +void __init acpi_early_processor_set_pdc(void)
 +{
 +	/*
 +	 * Check whether the system is DMI table. If yes, OSPM
 +	 * should not use mwait for CPU-states.
 +	 */
 +	dmi_check_system(processor_idle_dmi_table);
 +
 +	acpi_walk_namespace(ACPI_TYPE_PROCESSOR, ACPI_ROOT_OBJECT,
 +			    ACPI_UINT32_MAX,
 +			    early_init_pdc, NULL, NULL, NULL);
 +	acpi_get_devices("ACPI0007", early_init_pdc, NULL, NULL);
 +}
diff --cc include/acpi/processor.h
index 7816e45f5d5a,b95dc32a6e6b..000000000000
--- a/include/acpi/processor.h
+++ b/include/acpi/processor.h
@@@ -314,11 -310,13 +314,16 @@@ static inline int acpi_processor_get_bi
  #endif				/* CONFIG_CPU_FREQ */
  
  /* in processor_core.c */
++<<<<<<< HEAD
 +void acpi_processor_set_pdc(acpi_handle handle);
 +int acpi_get_apicid(acpi_handle, int type, u32 acpi_id);
 +int acpi_map_cpuid(int apic_id, u32 acpi_id);
++=======
+ int acpi_get_phys_id(acpi_handle, int type, u32 acpi_id);
+ int acpi_map_cpuid(int phys_id, u32 acpi_id);
++>>>>>>> af8f3f514d19 (ACPI / processor: Convert apic_id to phys_id to make it arch agnostic)
  int acpi_get_cpuid(acpi_handle, int type, u32 acpi_id);
  
 -/* in processor_pdc.c */
 -void acpi_processor_set_pdc(acpi_handle handle);
 -
  /* in processor_throttling.c */
  int acpi_processor_tstate_has_changed(struct acpi_processor *pr);
  int acpi_processor_get_throttling_info(struct acpi_processor *pr);
* Unmerged path drivers/acpi/acpi_processor.c
* Unmerged path drivers/acpi/processor_core.c
* Unmerged path include/acpi/processor.h
