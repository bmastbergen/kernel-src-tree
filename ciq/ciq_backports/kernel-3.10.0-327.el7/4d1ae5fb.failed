bonding: add rtnl lock and remove read lock for bond sysfs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author dingtianhong <dingtianhong@huawei.com>
commit 4d1ae5fb752b2504cf2c3d79abdfb410a09ad928
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/4d1ae5fb.failed

The bond_for_each_slave() will not be protected by read_lock(),
only protected by rtnl_lock(), so need to replace read_lock()
with rtnl_lock().

	Signed-off-by: Ding Tianhong <dingtianhong@huawei.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4d1ae5fb752b2504cf2c3d79abdfb410a09ad928)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_sysfs.c
diff --cc drivers/net/bonding/bond_sysfs.c
index 739d4dbe8629,03bed0ca935e..000000000000
--- a/drivers/net/bonding/bond_sysfs.c
+++ b/drivers/net/bonding/bond_sysfs.c
@@@ -209,12 -174,15 +209,19 @@@ void bond_destroy_slave_symlinks(struc
  static ssize_t bonding_show_slaves(struct device *d,
  				   struct device_attribute *attr, char *buf)
  {
 -	struct bonding *bond = to_bond(d);
 -	struct list_head *iter;
  	struct slave *slave;
 -	int res = 0;
 +	int i, res = 0;
 +	struct bonding *bond = to_bond(d);
  
++<<<<<<< HEAD
 +	read_lock(&bond->lock);
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	if (!rtnl_trylock())
+ 		return restart_syscall();
+ 
+ 	bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 4d1ae5fb752b (bonding: add rtnl lock and remove read lock for bond sysfs)
  		if (res > (PAGE_SIZE - IFNAMSIZ)) {
  			/* not enough space for another interface name */
  			if ((PAGE_SIZE - res) > 10)
@@@ -224,9 -192,12 +231,11 @@@
  		}
  		res += sprintf(buf + res, "%s ", slave->dev->name);
  	}
- 	read_unlock(&bond->lock);
+ 
+ 	rtnl_unlock();
+ 
  	if (res)
  		buf[res-1] = '\n'; /* eat the leftover space */
 -
  	return res;
  }
  
@@@ -1508,8 -1475,7 +1521,12 @@@ static ssize_t bonding_show_queue_id(st
  	if (!rtnl_trylock())
  		return restart_syscall();
  
++<<<<<<< HEAD
 +	read_lock(&bond->lock);
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 4d1ae5fb752b (bonding: add rtnl lock and remove read lock for bond sysfs)
  		if (res > (PAGE_SIZE - IFNAMSIZ - 6)) {
  			/* not enough space for another interface_name:queue_id pair */
  			if ((PAGE_SIZE - res) > 10)
@@@ -1520,10 -1486,11 +1537,10 @@@
  		res += sprintf(buf + res, "%s:%d ",
  			       slave->dev->name, slave->queue_id);
  	}
- 	read_unlock(&bond->lock);
  	if (res)
  		buf[res-1] = '\n'; /* eat the leftover space */
+ 
  	rtnl_unlock();
 -
  	return res;
  }
  
@@@ -1569,11 -1537,9 +1586,9 @@@ static ssize_t bonding_store_queue_id(s
  	if (!sdev)
  		goto err_no_cmd;
  
- 	read_lock(&bond->lock);
- 
  	/* Search for thes slave and check for duplicate qids */
  	update_slave = NULL;
 -	bond_for_each_slave(bond, slave, iter) {
 +	bond_for_each_slave(bond, slave, i) {
  		if (sdev == slave->dev)
  			/*
  			 * We don't need to check the matching
@@@ -1625,10 -1588,14 +1637,13 @@@ static ssize_t bonding_store_slaves_act
  					   struct device_attribute *attr,
  					   const char *buf, size_t count)
  {
 +	int i, new_value, ret = count;
  	struct bonding *bond = to_bond(d);
 -	int new_value, ret = count;
 -	struct list_head *iter;
  	struct slave *slave;
  
+ 	if (!rtnl_trylock())
+ 		return restart_syscall();
+ 
  	if (sscanf(buf, "%d", &new_value) != 1) {
  		pr_err("%s: no all_slaves_active value specified.\n",
  		       bond->dev->name);
@@@ -1648,8 -1615,7 +1663,12 @@@
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	read_lock(&bond->lock);
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
++>>>>>>> 4d1ae5fb752b (bonding: add rtnl lock and remove read lock for bond sysfs)
  		if (!bond_is_active_slave(slave)) {
  			if (new_value)
  				slave->inactive = 0;
* Unmerged path drivers/net/bonding/bond_sysfs.c
