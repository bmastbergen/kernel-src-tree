rtnl: allow to create device with IFLA_LINK_NETNSID set

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Nicolas Dichtel <nicolas.dichtel@6wind.com>
commit 317f4810e45eebe65d4f8897670df8b779de1467
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/317f4810.failed

This patch adds the ability to create a netdevice in a specified netns and
then move it into the final netns. In fact, it allows to have a symetry between
get and set rtnl messages.

	Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 317f4810e45eebe65d4f8897670df8b779de1467)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/rtnetlink.c
diff --cc net/core/rtnetlink.c
index 187818c8949a,a12eecc0f976..000000000000
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@@ -1127,7 -1245,10 +1127,14 @@@ static const struct nla_policy ifla_pol
  	[IFLA_PROMISCUITY]	= { .type = NLA_U32 },
  	[IFLA_NUM_TX_QUEUES]	= { .type = NLA_U32 },
  	[IFLA_NUM_RX_QUEUES]	= { .type = NLA_U32 },
++<<<<<<< HEAD
 +	[IFLA_PHYS_PORT_ID]	= { .type = NLA_BINARY, .len = MAX_PHYS_PORT_ID_LEN },
++=======
+ 	[IFLA_PHYS_PORT_ID]	= { .type = NLA_BINARY, .len = MAX_PHYS_ITEM_ID_LEN },
+ 	[IFLA_CARRIER_CHANGES]	= { .type = NLA_U32 },  /* ignored */
+ 	[IFLA_PHYS_SWITCH_ID]	= { .type = NLA_BINARY, .len = MAX_PHYS_ITEM_ID_LEN },
+ 	[IFLA_LINK_NETNSID]	= { .type = NLA_S32 },
++>>>>>>> 317f4810e45e (rtnl: allow to create device with IFLA_LINK_NETNSID set)
  };
  
  static const struct nla_policy ifla_info_policy[IFLA_INFO_MAX+1] = {
@@@ -1835,8 -2018,11 +1842,16 @@@ replay
  	}
  
  	if (1) {
++<<<<<<< HEAD
 +		struct nlattr *attr[ops ? ops->maxtype + 1 : 0], **data = NULL;
 +		struct net *dest_net;
++=======
+ 		struct nlattr *attr[ops ? ops->maxtype + 1 : 0];
+ 		struct nlattr *slave_attr[m_ops ? m_ops->slave_maxtype + 1 : 0];
+ 		struct nlattr **data = NULL;
+ 		struct nlattr **slave_data = NULL;
+ 		struct net *dest_net, *link_net = NULL;
++>>>>>>> 317f4810e45e (rtnl: allow to create device with IFLA_LINK_NETNSID set)
  
  		if (ops) {
  			if (ops->maxtype && linkinfo[IFLA_INFO_DATA]) {
@@@ -1911,7 -2128,18 +1926,22 @@@
  		if (IS_ERR(dest_net))
  			return PTR_ERR(dest_net);
  
++<<<<<<< HEAD
 +		dev = rtnl_create_link(dest_net, ifname, ops, tb);
++=======
+ 		if (tb[IFLA_LINK_NETNSID]) {
+ 			int id = nla_get_s32(tb[IFLA_LINK_NETNSID]);
+ 
+ 			link_net = get_net_ns_by_id(dest_net, id);
+ 			if (!link_net) {
+ 				err =  -EINVAL;
+ 				goto out;
+ 			}
+ 		}
+ 
+ 		dev = rtnl_create_link(link_net ? : dest_net, ifname,
+ 				       name_assign_type, ops, tb);
++>>>>>>> 317f4810e45e (rtnl: allow to create device with IFLA_LINK_NETNSID set)
  		if (IS_ERR(dev)) {
  			err = PTR_ERR(dev);
  			goto out;
@@@ -1919,20 -2147,36 +1949,27 @@@
  
  		dev->ifindex = ifm->ifi_index;
  
 -		if (ops->newlink) {
 +		if (ops->newlink)
  			err = ops->newlink(net, dev, tb, data);
 -			/* Drivers should call free_netdev() in ->destructor
 -			 * and unregister it on failure after registration
 -			 * so that device could be finally freed in rtnl_unlock.
 -			 */
 -			if (err < 0) {
 -				/* If device is not registered at all, free it now */
 -				if (dev->reg_state == NETREG_UNINITIALIZED)
 -					free_netdev(dev);
 -				goto out;
 -			}
 -		} else {
 +		else
  			err = register_netdevice(dev);
 -			if (err < 0) {
 -				free_netdev(dev);
 -				goto out;
 -			}
 -		}
 +
 +		if (err < 0 && !IS_ERR(dev))
 +			free_netdev(dev);
 +		if (err < 0)
 +			goto out;
 +
  		err = rtnl_configure_link(dev, ifm);
- 		if (err < 0)
+ 		if (err < 0) {
  			unregister_netdevice(dev);
+ 			goto out;
+ 		}
+ 
+ 		if (link_net)
+ 			err = dev_change_net_namespace(dev, dest_net, ifname);
  out:
+ 		if (link_net)
+ 			put_net(link_net);
  		put_net(dest_net);
  		return err;
  	}
* Unmerged path net/core/rtnetlink.c
