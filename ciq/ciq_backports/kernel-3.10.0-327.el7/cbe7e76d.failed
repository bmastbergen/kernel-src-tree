openvswitch: Fix GSO with multiple MPLS label.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] openvswitch: Fix GSO with multiple MPLS label (Jiri Benc) [1156461 1211348]
Rebuild_FUZZ: 98.90%
commit-author Pravin B Shelar <pshelar@nicira.com>
commit cbe7e76d94f59e89302bd514e4b685e03d1ebbe4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/cbe7e76d.failed

MPLS GSO needs to know inner most protocol to process GSO packets.

Fixes: 25cd9ba0abc ("openvswitch: Add basic MPLS support to
kernel").

	Signed-off-by: Pravin B Shelar <pshelar@nicira.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit cbe7e76d94f59e89302bd514e4b685e03d1ebbe4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/openvswitch/actions.c
diff --cc net/openvswitch/actions.c
index 5e332feb5508,770064c83711..000000000000
--- a/net/openvswitch/actions.c
+++ b/net/openvswitch/actions.c
@@@ -107,43 -109,49 +107,49 @@@ static struct deferred_action *add_defe
  	return da;
  }
  
 -static void invalidate_flow_key(struct sw_flow_key *key)
 +static int make_writable(struct sk_buff *skb, int write_len)
  {
 -	key->eth.type = htons(0);
 -}
 +	if (!pskb_may_pull(skb, write_len))
 +		return -ENOMEM;
  
 -static bool is_flow_key_valid(const struct sw_flow_key *key)
 -{
 -	return !!key->eth.type;
 +	if (!skb_cloned(skb) || skb_clone_writable(skb, write_len))
 +		return 0;
 +
 +	return pskb_expand_head(skb, 0, 0, GFP_ATOMIC);
  }
  
 -static int push_mpls(struct sk_buff *skb, struct sw_flow_key *key,
 -		     const struct ovs_action_push_mpls *mpls)
 +/* remove VLAN header from packet and update csum accordingly. */
 +static int __pop_vlan_tci(struct sk_buff *skb, __be16 *current_tci)
  {
 -	__be32 *new_mpls_lse;
 -	struct ethhdr *hdr;
 -
 -	/* Networking stack do not allow simultaneous Tunnel and MPLS GSO. */
 -	if (skb->encapsulation)
 -		return -ENOTSUPP;
 -
 -	if (skb_cow_head(skb, MPLS_HLEN) < 0)
 -		return -ENOMEM;
 -
 -	skb_push(skb, MPLS_HLEN);
 -	memmove(skb_mac_header(skb) - MPLS_HLEN, skb_mac_header(skb),
 -		skb->mac_len);
 -	skb_reset_mac_header(skb);
 +	struct vlan_hdr *vhdr;
 +	int err;
  
 -	new_mpls_lse = (__be32 *)skb_mpls_header(skb);
 -	*new_mpls_lse = mpls->mpls_lse;
 +	err = make_writable(skb, VLAN_ETH_HLEN);
 +	if (unlikely(err))
 +		return err;
  
  	if (skb->ip_summed == CHECKSUM_COMPLETE)
 -		skb->csum = csum_add(skb->csum, csum_partial(new_mpls_lse,
 -							     MPLS_HLEN, 0));
 -
 -	hdr = eth_hdr(skb);
 -	hdr->h_proto = mpls->mpls_ethertype;
 -
 +		skb->csum = csum_sub(skb->csum, csum_partial(skb->data
 +					+ (2 * ETH_ALEN), VLAN_HLEN, 0));
 +
 +	vhdr = (struct vlan_hdr *)(skb->data + ETH_HLEN);
 +	*current_tci = vhdr->h_vlan_TCI;
 +
++<<<<<<< HEAD
 +	memmove(skb->data + VLAN_HLEN, skb->data, 2 * ETH_ALEN);
 +	__skb_pull(skb, VLAN_HLEN);
 +
 +	vlan_set_encap_proto(skb, vhdr);
 +	skb->mac_header += VLAN_HLEN;
 +	if (skb_network_offset(skb) < ETH_HLEN)
 +		skb_set_network_header(skb, ETH_HLEN);
 +	skb_reset_mac_len(skb);
++=======
+ 	if (!skb->inner_protocol)
+ 		skb_set_inner_protocol(skb, skb->protocol);
+ 	skb->protocol = mpls->mpls_ethertype;
++>>>>>>> cbe7e76d94f5 (openvswitch: Fix GSO with multiple MPLS label.)
  
 -	invalidate_flow_key(key);
  	return 0;
  }
  
* Unmerged path net/openvswitch/actions.c
