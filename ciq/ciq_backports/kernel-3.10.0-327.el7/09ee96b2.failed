dm snapshot: suspend merging snapshot when doing exception handover

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [md] dm-snapshot: suspend merging snapshot when doing exception handover (Mike Snitzer) [1205955]
Rebuild_FUZZ: 98.51%
commit-author Mikulas Patocka <mpatocka@redhat.com>
commit 09ee96b21456883e108c3b00597bb37ec512151b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/09ee96b2.failed

The "dm snapshot: suspend origin when doing exception handover" commit
fixed a exception store handover bug associated with pending exceptions
to the "snapshot-origin" target.

However, a similar problem exists in snapshot merging.  When snapshot
merging is in progress, we use the target "snapshot-merge" instead of
"snapshot-origin".  Consequently, during exception store handover, we
must find the snapshot-merge target and suspend its associated
mapped_device.

To avoid lockdep warnings, the target must be suspended and resumed
without holding _origins_lock.

Introduce a dm_hold() function that grabs a reference on a
mapped_device, but unlike dm_get(), it doesn't crash if the device has
the DMF_FREEING flag set, it returns an error in this case.

In snapshot_resume() we grab the reference to the origin device using
dm_hold() while holding _origins_lock (_origins_lock guarantees that the
device won't disappear).  Then we release _origins_lock, suspend the
device and grab _origins_lock again.

NOTE to stable@ people:
When backporting to kernels 3.18 and older, use dm_internal_suspend and
dm_internal_resume instead of dm_internal_suspend_fast and
dm_internal_resume_fast.

	Signed-off-by: Mikulas Patocka <mpatocka@redhat.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
	Cc: stable@vger.kernel.org
(cherry picked from commit 09ee96b21456883e108c3b00597bb37ec512151b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-snap.c
diff --cc drivers/md/dm-snap.c
index 4b4bf607855a,f83a0f3fc365..000000000000
--- a/drivers/md/dm-snap.c
+++ b/drivers/md/dm-snap.c
@@@ -1847,9 -1888,40 +1847,46 @@@ static int snapshot_preresume(struct dm
  static void snapshot_resume(struct dm_target *ti)
  {
  	struct dm_snapshot *s = ti->private;
++<<<<<<< HEAD
 +	struct dm_snapshot *snap_src = NULL, *snap_dest = NULL;
 +
 +	down_read(&_origins_lock);
++=======
+ 	struct dm_snapshot *snap_src = NULL, *snap_dest = NULL, *snap_merging = NULL;
+ 	struct dm_origin *o;
+ 	struct mapped_device *origin_md = NULL;
+ 	bool must_restart_merging = false;
+ 
+ 	down_read(&_origins_lock);
+ 
+ 	o = __lookup_dm_origin(s->origin->bdev);
+ 	if (o)
+ 		origin_md = dm_table_get_md(o->ti->table);
+ 	if (!origin_md) {
+ 		(void) __find_snapshots_sharing_cow(s, NULL, NULL, &snap_merging);
+ 		if (snap_merging)
+ 			origin_md = dm_table_get_md(snap_merging->ti->table);
+ 	}
+ 	if (origin_md == dm_table_get_md(ti->table))
+ 		origin_md = NULL;
+ 	if (origin_md) {
+ 		if (dm_hold(origin_md))
+ 			origin_md = NULL;
+ 	}
+ 
+ 	up_read(&_origins_lock);
+ 
+ 	if (origin_md) {
+ 		dm_internal_suspend_fast(origin_md);
+ 		if (snap_merging && test_bit(RUNNING_MERGE, &snap_merging->state_bits)) {
+ 			must_restart_merging = true;
+ 			stop_merge(snap_merging);
+ 		}
+ 	}
+ 
+ 	down_read(&_origins_lock);
+ 
++>>>>>>> 09ee96b21456 (dm snapshot: suspend merging snapshot when doing exception handover)
  	(void) __find_snapshots_sharing_cow(s, &snap_src, &snap_dest, NULL);
  	if (snap_src && snap_dest) {
  		down_write(&snap_src->lock);
@@@ -1858,8 -1930,16 +1895,19 @@@
  		up_write(&snap_dest->lock);
  		up_write(&snap_src->lock);
  	}
++<<<<<<< HEAD
++=======
+ 
++>>>>>>> 09ee96b21456 (dm snapshot: suspend merging snapshot when doing exception handover)
  	up_read(&_origins_lock);
  
+ 	if (origin_md) {
+ 		if (must_restart_merging)
+ 			start_merge(snap_merging);
+ 		dm_internal_resume_fast(origin_md);
+ 		dm_put(origin_md);
+ 	}
+ 
  	/* Now we have correct chunk size, reregister */
  	reregister_snapshot(s);
  
* Unmerged path drivers/md/dm-snap.c
diff --git a/drivers/md/dm.c b/drivers/md/dm.c
index a7c19b8d2242..4585b4c323d2 100644
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@ -2724,6 +2724,19 @@ void dm_get(struct mapped_device *md)
 	BUG_ON(test_bit(DMF_FREEING, &md->flags));
 }
 
+int dm_hold(struct mapped_device *md)
+{
+	spin_lock(&_minor_lock);
+	if (test_bit(DMF_FREEING, &md->flags)) {
+		spin_unlock(&_minor_lock);
+		return -EBUSY;
+	}
+	dm_get(md);
+	spin_unlock(&_minor_lock);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(dm_hold);
+
 const char *dm_device_name(struct mapped_device *md)
 {
 	return md->name;
diff --git a/include/linux/device-mapper.h b/include/linux/device-mapper.h
index 2f0bd0e3937b..10098bdbc7f7 100644
--- a/include/linux/device-mapper.h
+++ b/include/linux/device-mapper.h
@@ -374,6 +374,7 @@ int dm_create(int minor, struct mapped_device **md);
  */
 struct mapped_device *dm_get_md(dev_t dev);
 void dm_get(struct mapped_device *md);
+int dm_hold(struct mapped_device *md);
 void dm_put(struct mapped_device *md);
 
 /*
