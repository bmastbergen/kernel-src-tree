Drivers: hv: vmbus: Implement the protocol for tearing down vmbus state

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [hv] vmbus: Implement the protocol for tearing down vmbus state (Vitaly Kuznetsov) [1248352]
Rebuild_FUZZ: 89.92%
commit-author K. Y. Srinivasan <kys@microsoft.com>
commit 2db84eff127e3f4b3635edc589cd6a56db8755a3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/2db84eff.failed

Implement the protocol for tearing down the monitor state established with
the host.

	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Tested-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 2db84eff127e3f4b3635edc589cd6a56db8755a3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/channel_mgmt.c
#	drivers/hv/connection.c
#	drivers/hv/vmbus_drv.c
#	include/linux/hyperv.h
diff --cc drivers/hv/channel_mgmt.c
index 6052b9503b13,4b9d89ab44d3..000000000000
--- a/drivers/hv/channel_mgmt.c
+++ b/drivers/hv/channel_mgmt.c
@@@ -717,25 -722,26 +741,46 @@@ static void vmbus_onversion_response
  }
  
  /* Channel message dispatch table */
 -struct vmbus_channel_message_table_entry
 +static struct vmbus_channel_message_table_entry
  	channel_message_table[CHANNELMSG_COUNT] = {
++<<<<<<< HEAD
 +	{CHANNELMSG_INVALID,			NULL},
 +	{CHANNELMSG_OFFERCHANNEL,		vmbus_onoffer},
 +	{CHANNELMSG_RESCIND_CHANNELOFFER,	vmbus_onoffer_rescind},
 +	{CHANNELMSG_REQUESTOFFERS,		NULL},
 +	{CHANNELMSG_ALLOFFERS_DELIVERED,	vmbus_onoffers_delivered},
 +	{CHANNELMSG_OPENCHANNEL,		NULL},
 +	{CHANNELMSG_OPENCHANNEL_RESULT,	vmbus_onopen_result},
 +	{CHANNELMSG_CLOSECHANNEL,		NULL},
 +	{CHANNELMSG_GPADL_HEADER,		NULL},
 +	{CHANNELMSG_GPADL_BODY,		NULL},
 +	{CHANNELMSG_GPADL_CREATED,		vmbus_ongpadl_created},
 +	{CHANNELMSG_GPADL_TEARDOWN,		NULL},
 +	{CHANNELMSG_GPADL_TORNDOWN,		vmbus_ongpadl_torndown},
 +	{CHANNELMSG_RELID_RELEASED,		NULL},
 +	{CHANNELMSG_INITIATE_CONTACT,		NULL},
 +	{CHANNELMSG_VERSION_RESPONSE,		vmbus_onversion_response},
 +	{CHANNELMSG_UNLOAD,			NULL},
++=======
+ 	{CHANNELMSG_INVALID,			0, NULL},
+ 	{CHANNELMSG_OFFERCHANNEL,		0, vmbus_onoffer},
+ 	{CHANNELMSG_RESCIND_CHANNELOFFER,	0, vmbus_onoffer_rescind},
+ 	{CHANNELMSG_REQUESTOFFERS,		0, NULL},
+ 	{CHANNELMSG_ALLOFFERS_DELIVERED,	1, vmbus_onoffers_delivered},
+ 	{CHANNELMSG_OPENCHANNEL,		0, NULL},
+ 	{CHANNELMSG_OPENCHANNEL_RESULT,		1, vmbus_onopen_result},
+ 	{CHANNELMSG_CLOSECHANNEL,		0, NULL},
+ 	{CHANNELMSG_GPADL_HEADER,		0, NULL},
+ 	{CHANNELMSG_GPADL_BODY,			0, NULL},
+ 	{CHANNELMSG_GPADL_CREATED,		1, vmbus_ongpadl_created},
+ 	{CHANNELMSG_GPADL_TEARDOWN,		0, NULL},
+ 	{CHANNELMSG_GPADL_TORNDOWN,		1, vmbus_ongpadl_torndown},
+ 	{CHANNELMSG_RELID_RELEASED,		0, NULL},
+ 	{CHANNELMSG_INITIATE_CONTACT,		0, NULL},
+ 	{CHANNELMSG_VERSION_RESPONSE,		1, vmbus_onversion_response},
+ 	{CHANNELMSG_UNLOAD,			0, NULL},
+ 	{CHANNELMSG_UNLOAD_RESPONSE,		1, vmbus_unload_response},
++>>>>>>> 2db84eff127e (Drivers: hv: vmbus: Implement the protocol for tearing down vmbus state)
  };
  
  /*
diff --cc drivers/hv/connection.c
index cad8295c2bdf,acd50e9d666a..000000000000
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@@ -215,10 -216,26 +215,27 @@@ int vmbus_connect(void
  
  cleanup:
  	pr_err("Unable to connect to host\n");
 -
  	vmbus_connection.conn_state = DISCONNECTED;
 -	vmbus_disconnect();
  
++<<<<<<< HEAD
 +	if (vmbus_connection.work_queue)
++=======
+ 	kfree(msginfo);
+ 
+ 	return ret;
+ }
+ 
+ void vmbus_disconnect(void)
+ {
+ 	/*
+ 	 * First send the unload request to the host.
+ 	 */
+ 	vmbus_initiate_unload();
+ 
+ 	if (vmbus_connection.work_queue) {
+ 		drain_workqueue(vmbus_connection.work_queue);
++>>>>>>> 2db84eff127e (Drivers: hv: vmbus: Implement the protocol for tearing down vmbus state)
  		destroy_workqueue(vmbus_connection.work_queue);
 -	}
  
  	if (vmbus_connection.int_page) {
  		free_pages((unsigned long)vmbus_connection.int_page, 0);
diff --cc drivers/hv/vmbus_drv.c
index ca849c308e2e,2b56260b0eb4..000000000000
--- a/drivers/hv/vmbus_drv.c
+++ b/drivers/hv/vmbus_drv.c
@@@ -832,6 -1102,11 +832,14 @@@ cleanup
  
  static void __exit vmbus_exit(void)
  {
++<<<<<<< HEAD
++=======
+ 	int cpu;
+ 
+ 	vmbus_connection.conn_state = DISCONNECTED;
+ 	hv_synic_clockevents_cleanup();
+ 	vmbus_disconnect();
++>>>>>>> 2db84eff127e (Drivers: hv: vmbus: Implement the protocol for tearing down vmbus state)
  	hv_remove_vmbus_irq();
  	vmbus_free_channels();
  	if (ms_hyperv.features & HV_FEATURE_GUEST_CRASH_MSR_AVAILABLE) {
@@@ -840,7 -1115,10 +848,11 @@@
  	}
  	bus_unregister(&hv_bus);
  	hv_cleanup();
 -	for_each_online_cpu(cpu)
 -		smp_call_function_single(cpu, hv_synic_cleanup, NULL, 1);
  	acpi_bus_unregister_driver(&vmbus_acpi_driver);
++<<<<<<< HEAD
++=======
+ 	hv_cpu_hotplug_quirk(false);
++>>>>>>> 2db84eff127e (Drivers: hv: vmbus: Implement the protocol for tearing down vmbus state)
  }
  
  
diff --cc include/linux/hyperv.h
index 55d525dc7600,ea934864293d..000000000000
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@@ -386,10 -389,7 +386,14 @@@ enum vmbus_channel_message_type 
  	CHANNELMSG_INITIATE_CONTACT		= 14,
  	CHANNELMSG_VERSION_RESPONSE		= 15,
  	CHANNELMSG_UNLOAD			= 16,
++<<<<<<< HEAD
 +#ifdef VMBUS_FEATURE_PARENT_OR_PEER_MEMORY_MAPPED_INTO_A_CHILD
 +	CHANNELMSG_VIEWRANGE_ADD		= 17,
 +	CHANNELMSG_VIEWRANGE_REMOVE		= 18,
 +#endif
++=======
+ 	CHANNELMSG_UNLOAD_RESPONSE		= 17,
++>>>>>>> 2db84eff127e (Drivers: hv: vmbus: Implement the protocol for tearing down vmbus state)
  	CHANNELMSG_COUNT
  };
  
* Unmerged path drivers/hv/channel_mgmt.c
* Unmerged path drivers/hv/connection.c
diff --git a/drivers/hv/hyperv_vmbus.h b/drivers/hv/hyperv_vmbus.h
index b5e790856f6e..2d963bf0d479 100644
--- a/drivers/hv/hyperv_vmbus.h
+++ b/drivers/hv/hyperv_vmbus.h
@@ -602,6 +602,7 @@ struct vmbus_connection {
 
 	atomic_t next_gpadl_handle;
 
+	struct completion  unload_event;
 	/*
 	 * Represents channel interrupts. Each bit position represents a
 	 * channel.  When a channel sends an interrupt via VMBUS, it finds its
@@ -670,6 +671,7 @@ void vmbus_on_event(unsigned long data);
 int hv_fcopy_init(struct hv_util_service *);
 void hv_fcopy_deinit(void);
 void hv_fcopy_onchannelcallback(void *);
+void vmbus_initiate_unload(void);
 
 
 #endif /* _HYPERV_VMBUS_H */
* Unmerged path drivers/hv/vmbus_drv.c
* Unmerged path include/linux/hyperv.h
