IB/iser: Move fastreg descriptor pool get/put to helper functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [infiniband] iser: Move fastreg descriptor pool get/put to helper functions (Amir Vadai) [1164539]
Rebuild_FUZZ: 97.64%
commit-author Sagi Grimberg <sagig@mellanox.com>
commit bd8b944eeeb06f5dac705d2357af3800395174eb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/bd8b944e.failed

Instead of open-coding connection fastreg pool get/put,
we introduce iser_reg_desc[get|put] helpers.

We aren't setting these static as this will be a per-device
routine later on. Also, cleanup iser_unreg_rdma_mem_fastreg
a bit.

This patch does not change any functionality.

	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Adir Lev <adirl@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit bd8b944eeeb06f5dac705d2357af3800395174eb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/iser/iser_memory.c
diff --cc drivers/infiniband/ulp/iser/iser_memory.c
index f40132fc970c,17a5d70dcc8a..000000000000
--- a/drivers/infiniband/ulp/iser/iser_memory.c
+++ b/drivers/infiniband/ulp/iser/iser_memory.c
@@@ -366,6 -363,88 +392,91 @@@ static int fall_to_bounce_buf(struct is
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * iser_reg_page_vec - Register physical memory
+  *
+  * returns: 0 on success, errno code on failure
+  */
+ static
+ int iser_reg_page_vec(struct iscsi_iser_task *iser_task,
+ 		      struct iser_data_buf *mem,
+ 		      struct iser_page_vec *page_vec,
+ 		      struct iser_mem_reg *mem_reg)
+ {
+ 	struct ib_conn *ib_conn = &iser_task->iser_conn->ib_conn;
+ 	struct iser_device *device = ib_conn->device;
+ 	struct ib_pool_fmr *fmr;
+ 	int ret, plen;
+ 
+ 	plen = iser_sg_to_page_vec(mem, device->ib_device,
+ 				   page_vec->pages,
+ 				   &page_vec->offset,
+ 				   &page_vec->data_size);
+ 	page_vec->length = plen;
+ 	if (plen * SIZE_4K < page_vec->data_size) {
+ 		iser_err("page vec too short to hold this SG\n");
+ 		iser_data_buf_dump(mem, device->ib_device);
+ 		iser_dump_page_vec(page_vec);
+ 		return -EINVAL;
+ 	}
+ 
+ 	fmr  = ib_fmr_pool_map_phys(ib_conn->fmr.pool,
+ 				    page_vec->pages,
+ 				    page_vec->length,
+ 				    page_vec->pages[0]);
+ 	if (IS_ERR(fmr)) {
+ 		ret = PTR_ERR(fmr);
+ 		iser_err("ib_fmr_pool_map_phys failed: %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	mem_reg->lkey = fmr->fmr->lkey;
+ 	mem_reg->rkey = fmr->fmr->rkey;
+ 	mem_reg->va = page_vec->pages[0] + page_vec->offset;
+ 	mem_reg->len = page_vec->data_size;
+ 	mem_reg->mem_h = fmr;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * Unregister (previosuly registered using FMR) memory.
+  * If memory is non-FMR does nothing.
+  */
+ void iser_unreg_mem_fmr(struct iscsi_iser_task *iser_task,
+ 			enum iser_data_dir cmd_dir)
+ {
+ 	struct iser_mem_reg *reg = &iser_task->rdma_reg[cmd_dir];
+ 	int ret;
+ 
+ 	if (!reg->mem_h)
+ 		return;
+ 
+ 	iser_dbg("PHYSICAL Mem.Unregister mem_h %p\n", reg->mem_h);
+ 
+ 	ret = ib_fmr_pool_unmap((struct ib_pool_fmr *)reg->mem_h);
+ 	if (ret)
+ 		iser_err("ib_fmr_pool_unmap failed %d\n", ret);
+ 
+ 	reg->mem_h = NULL;
+ }
+ 
+ void iser_unreg_mem_fastreg(struct iscsi_iser_task *iser_task,
+ 			    enum iser_data_dir cmd_dir)
+ {
+ 	struct iser_mem_reg *reg = &iser_task->rdma_reg[cmd_dir];
+ 
+ 	if (!reg->mem_h)
+ 		return;
+ 
+ 	iser_reg_desc_put(&iser_task->iser_conn->ib_conn,
+ 			  reg->mem_h);
+ 	reg->mem_h = NULL;
+ }
+ 
+ /**
++>>>>>>> bd8b944eeeb0 (IB/iser: Move fastreg descriptor pool get/put to helper functions)
   * iser_reg_rdma_mem_fmr - Registers memory intended for RDMA,
   * using FMR (if possible) obtaining rkey and va
   *
@@@ -721,15 -760,11 +831,20 @@@ int iser_reg_rdma_mem_fastreg(struct is
  
  	if (mem->dma_nents != 1 ||
  	    scsi_get_prot_op(iser_task->sc) != SCSI_PROT_NORMAL) {
++<<<<<<< HEAD
 +		spin_lock_irqsave(&ib_conn->lock, flags);
 +		desc = list_first_entry(&ib_conn->fastreg.pool,
 +					struct fast_reg_descriptor, list);
 +		list_del(&desc->list);
 +		spin_unlock_irqrestore(&ib_conn->lock, flags);
 +		regd_buf->reg.mem_h = desc;
++=======
+ 		desc = iser_reg_desc_get(ib_conn);
+ 		mem_reg->mem_h = desc;
++>>>>>>> bd8b944eeeb0 (IB/iser: Move fastreg descriptor pool get/put to helper functions)
  	}
  
 -	err = iser_fast_reg_mr(iser_task, mem_reg, mem,
 +	err = iser_fast_reg_mr(iser_task, regd_buf, mem,
  			       ISER_DATA_KEY_VALID, &data_sge);
  	if (err)
  		goto err_reg;
diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.h b/drivers/infiniband/ulp/iser/iscsi_iser.h
index e160d7ee63dc..12f256f22700 100644
--- a/drivers/infiniband/ulp/iser/iscsi_iser.h
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.h
@@ -480,4 +480,9 @@ int iser_create_fastreg_pool(struct iser_conn *ib_conn, unsigned cmds_max);
 void iser_free_fastreg_pool(struct iser_conn *ib_conn);
 u8 iser_check_task_pi_status(struct iscsi_iser_task *iser_task,
 			     enum iser_data_dir cmd_dir, sector_t *sector);
+struct fast_reg_descriptor *
+iser_reg_desc_get(struct ib_conn *ib_conn);
+void
+iser_reg_desc_put(struct ib_conn *ib_conn,
+		  struct fast_reg_descriptor *desc);
 #endif
* Unmerged path drivers/infiniband/ulp/iser/iser_memory.c
