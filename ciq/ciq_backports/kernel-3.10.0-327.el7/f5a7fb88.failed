vlan: Introduce helper functions to check if skb is tagged

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
commit f5a7fb88e1f82542ca14ba93a1d4fa35471c60ca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/f5a7fb88.failed

Separate the two checks for single vlan and multiple vlans in
netif_skb_features().  This allows us to move the check for multiple
vlans to another function later.

	Signed-off-by: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f5a7fb88e1f82542ca14ba93a1d4fa35471c60ca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/if_vlan.h
#	net/core/dev.c
diff --cc include/linux/if_vlan.h
index 978291b95d4e,4265d440ec4d..000000000000
--- a/include/linux/if_vlan.h
+++ b/include/linux/if_vlan.h
@@@ -477,4 -560,50 +477,53 @@@ static inline void vlan_set_encap_proto
  		 */
  		skb->protocol = htons(ETH_P_802_2);
  }
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * skb_vlan_tagged - check if skb is vlan tagged.
+  * @skb: skbuff to query
+  *
+  * Returns true if the skb is tagged, regardless of whether it is hardware
+  * accelerated or not.
+  */
+ static inline bool skb_vlan_tagged(const struct sk_buff *skb)
+ {
+ 	if (!skb_vlan_tag_present(skb) &&
+ 	    likely(skb->protocol != htons(ETH_P_8021Q) &&
+ 		   skb->protocol != htons(ETH_P_8021AD)))
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ /**
+  * skb_vlan_tagged_multi - check if skb is vlan tagged with multiple headers.
+  * @skb: skbuff to query
+  *
+  * Returns true if the skb is tagged with multiple vlan headers, regardless
+  * of whether it is hardware accelerated or not.
+  */
+ static inline bool skb_vlan_tagged_multi(const struct sk_buff *skb)
+ {
+ 	__be16 protocol = skb->protocol;
+ 
+ 	if (!skb_vlan_tag_present(skb)) {
+ 		struct vlan_ethhdr *veh;
+ 
+ 		if (likely(protocol != htons(ETH_P_8021Q) &&
+ 			   protocol != htons(ETH_P_8021AD)))
+ 			return false;
+ 
+ 		veh = (struct vlan_ethhdr *)skb->data;
+ 		protocol = veh->h_vlan_encapsulated_proto;
+ 	}
+ 
+ 	if (protocol != htons(ETH_P_8021Q) && protocol != htons(ETH_P_8021AD))
+ 		return false;
+ 
+ 	return true;
+ }
+ 
++>>>>>>> f5a7fb88e1f8 (vlan: Introduce helper functions to check if skb is tagged)
  #endif /* !(_LINUX_IF_VLAN_H_) */
diff --cc net/core/dev.c
index 9a2bea4eeeee,04bffcd4a48d..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -2460,28 -2564,29 +2460,53 @@@ static netdev_features_t harmonize_feat
  
  netdev_features_t netif_skb_features(struct sk_buff *skb)
  {
++<<<<<<< HEAD
 +	__be16 protocol = skb->protocol;
 +	netdev_features_t features = skb->dev->features;
++=======
+ 	struct net_device *dev = skb->dev;
+ 	netdev_features_t features = dev->features;
+ 	u16 gso_segs = skb_shinfo(skb)->gso_segs;
++>>>>>>> f5a7fb88e1f8 (vlan: Introduce helper functions to check if skb is tagged)
  
 -	if (gso_segs > dev->gso_max_segs || gso_segs < dev->gso_min_segs)
 +	if (skb_shinfo(skb)->gso_segs > skb->dev->gso_max_segs)
  		features &= ~NETIF_F_GSO_MASK;
  
++<<<<<<< HEAD
 +	if (!vlan_tx_tag_present(skb)) {
 +		if (unlikely(protocol == htons(ETH_P_8021Q) ||
 +			     protocol == htons(ETH_P_8021AD))) {
 +			struct vlan_ethhdr *veh = (struct vlan_ethhdr *)skb->data;
 +			protocol = veh->h_vlan_encapsulated_proto;
 +		} else {
 +			return harmonize_features(skb, features);
 +		}
 +	}
 +
 +	features = netdev_intersect_features(features,
 +					     skb->dev->vlan_features |
 +					     NETIF_F_HW_VLAN_CTAG_TX |
 +					     NETIF_F_HW_VLAN_STAG_TX);
 +
 +	if (protocol == htons(ETH_P_8021Q) || protocol == htons(ETH_P_8021AD))
++=======
+ 	/* If encapsulation offload request, verify we are testing
+ 	 * hardware encapsulation features instead of standard
+ 	 * features for the netdev
+ 	 */
+ 	if (skb->encapsulation)
+ 		features &= dev->hw_enc_features;
+ 
+ 	if (skb_vlan_tagged(skb))
+ 		features = netdev_intersect_features(features,
+ 						     dev->vlan_features |
+ 						     NETIF_F_HW_VLAN_CTAG_TX |
+ 						     NETIF_F_HW_VLAN_STAG_TX);
+ 	else
+ 		goto finalize;
+ 
+ 	if (skb_vlan_tagged_multi(skb))
++>>>>>>> f5a7fb88e1f8 (vlan: Introduce helper functions to check if skb is tagged)
  		features = netdev_intersect_features(features,
  						     NETIF_F_SG |
  						     NETIF_F_HIGHDMA |
* Unmerged path include/linux/if_vlan.h
* Unmerged path net/core/dev.c
