GHES: Make NMI handler have a single reader

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Jiri Kosina <jkosina@suse.cz>
commit 6fe9e7c26a97105645fd24f264f1b94e21aade3e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/6fe9e7c2.failed

Since GHES sources are global, we theoretically need only a single CPU
reading them per NMI instead of a thundering herd of CPUs waiting on a
spinlock in NMI context for no reason at all.

Do that.

	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
	Signed-off-by: Borislav Petkov <bp@suse.de>
(cherry picked from commit 6fe9e7c26a97105645fd24f264f1b94e21aade3e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/apei/ghes.c
diff --cc drivers/acpi/apei/ghes.c
index ce3683d93a13,2bfd53cbfe80..000000000000
--- a/drivers/acpi/apei/ghes.c
+++ b/drivers/acpi/apei/ghes.c
@@@ -731,19 -712,31 +731,31 @@@ static int ghes_notify_sci(struct notif
  	return ret;
  }
  
 -static struct notifier_block ghes_notifier_sci = {
 -	.notifier_call = ghes_notify_sci,
 -};
 +static struct llist_node *llist_nodes_reverse(struct llist_node *llnode)
 +{
 +	struct llist_node *next, *tail = NULL;
  
 -#ifdef CONFIG_HAVE_ACPI_APEI_NMI
 -/*
 - * printk is not safe in NMI context.  So in NMI handler, we allocate
 - * required memory from lock-less memory allocator
 - * (ghes_estatus_pool), save estatus into it, put them into lock-less
 - * list (ghes_estatus_llist), then delay printk into IRQ context via
 - * irq_work (ghes_proc_irq_work).  ghes_estatus_size_request record
 - * required pool size by all NMI error source.
 - */
 -static struct llist_head ghes_estatus_llist;
 -static struct irq_work ghes_proc_irq_work;
 +	while (llnode) {
 +		next = llnode->next;
 +		llnode->next = tail;
 +		tail = llnode;
 +		llnode = next;
 +	}
  
++<<<<<<< HEAD
 +	return tail;
 +}
++=======
+ /*
+  * NMI may be triggered on any CPU, so ghes_in_nmi is used for
+  * having only one concurrent reader.
+  */
+ static atomic_t ghes_in_nmi = ATOMIC_INIT(0);
+ 
+ static LIST_HEAD(ghes_nmi);
+ 
+ static int ghes_panic_timeout	__read_mostly = 30;
++>>>>>>> 6fe9e7c26a97 (GHES: Make NMI handler have a single reader)
  
  static void ghes_proc_in_irq(struct irq_work *irq_work)
  {
@@@ -804,13 -797,52 +816,15 @@@ static void ghes_print_queued_estatus(v
  	}
  }
  
 -/* Save estatus for further processing in IRQ context */
 -static void __process_error(struct ghes *ghes)
 -{
 -#ifdef CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG
 -	u32 len, node_len;
 -	struct ghes_estatus_node *estatus_node;
 -	struct acpi_hest_generic_status *estatus;
 -
 -	if (ghes_estatus_cached(ghes->estatus))
 -		return;
 -
 -	len = cper_estatus_len(ghes->estatus);
 -	node_len = GHES_ESTATUS_NODE_LEN(len);
 -
 -	estatus_node = (void *)gen_pool_alloc(ghes_estatus_pool, node_len);
 -	if (!estatus_node)
 -		return;
 -
 -	estatus_node->ghes = ghes;
 -	estatus_node->generic = ghes->generic;
 -	estatus = GHES_ESTATUS_FROM_NODE(estatus_node);
 -	memcpy(estatus, ghes->estatus, len);
 -	llist_add(&estatus_node->llnode, &ghes_estatus_llist);
 -#endif
 -}
 -
 -static void __ghes_panic(struct ghes *ghes)
 -{
 -	oops_begin();
 -	ghes_print_queued_estatus();
 -	__ghes_print_estatus(KERN_EMERG, ghes->generic, ghes->estatus);
 -
 -	/* reboot to log the error! */
 -	if (panic_timeout == 0)
 -		panic_timeout = ghes_panic_timeout;
 -	panic("Fatal hardware error!");
 -}
 -
  static int ghes_notify_nmi(unsigned int cmd, struct pt_regs *regs)
  {
 -	struct ghes *ghes;
 -	int sev, ret = NMI_DONE;
 +	struct ghes *ghes, *ghes_global = NULL;
 +	int sev, sev_global = -1;
 +	int ret = NMI_DONE;
  
- 	raw_spin_lock(&ghes_nmi_lock);
+ 	if (!atomic_add_unless(&ghes_in_nmi, 1, 1))
+ 		return ret;
+ 
  	list_for_each_entry_rcu(ghes, &ghes_nmi, list) {
  		if (ghes_read_estatus(ghes, 1)) {
  			ghes_clear_estatus(ghes);
@@@ -868,9 -864,8 +882,13 @@@ next
  #ifdef CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG
  	irq_work_queue(&ghes_proc_irq_work);
  #endif
++<<<<<<< HEAD
 +
 +out:
 +	raw_spin_unlock(&ghes_nmi_lock);
++=======
+ 	atomic_dec(&ghes_in_nmi);
++>>>>>>> 6fe9e7c26a97 (GHES: Make NMI handler have a single reader)
  	return ret;
  }
  
* Unmerged path drivers/acpi/apei/ghes.c
