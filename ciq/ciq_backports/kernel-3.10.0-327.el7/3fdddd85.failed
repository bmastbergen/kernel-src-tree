bonding: alloc the structure ad_info dynamically in per slave

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author dingtianhong <dingtianhong@huawei.com>
commit 3fdddd859af235119bdfb09ccc886fe48b97fc72
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/3fdddd85.failed

The struct ad_slave_info is very huge, and only be used for 802.3ad mode,
so alloc the structure dynamically could save 356 Bits for every slave in
non 802.3ad mode.

	Cc: Jay Vosburgh <j.vosburgh@gmail.com>
	Cc: Veaceslav Falico <vfalico@gmail.com>
	Cc: Andy Gospodarek <andy@greyhouse.net>
	Signed-off-by: Ding Tianhong <dingtianhong@huawei.com>
	Acked-by: Veaceslav Falico <vfalico@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3fdddd859af235119bdfb09ccc886fe48b97fc72)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_3ad.c
#	drivers/net/bonding/bond_main.c
#	drivers/net/bonding/bond_netlink.c
#	drivers/net/bonding/bond_sysfs_slave.c
diff --cc drivers/net/bonding/bond_3ad.c
index dc508c87249d,24faddddf11e..000000000000
--- a/drivers/net/bonding/bond_3ad.c
+++ b/drivers/net/bonding/bond_3ad.c
@@@ -179,12 -148,19 +179,21 @@@ static inline struct port *__get_next_p
  static inline struct aggregator *__get_first_agg(struct port *port)
  {
  	struct bonding *bond = __get_bond_by_port(port);
 -	struct slave *first_slave;
 -	struct aggregator *agg;
  
 -	/* If there's no bond for this port, or bond has no slaves */
 -	if (bond == NULL)
 +	// If there's no bond for this port, or bond has no slaves
 +	if ((bond == NULL) || (bond->slave_cnt == 0))
  		return NULL;
  
++<<<<<<< HEAD
 +	return &(SLAVE_AD_INFO(bond->first_slave).aggregator);
++=======
+ 	rcu_read_lock();
+ 	first_slave = bond_first_slave_rcu(bond);
+ 	agg = first_slave ? &(SLAVE_AD_INFO(first_slave)->aggregator) : NULL;
+ 	rcu_read_unlock();
+ 
+ 	return agg;
++>>>>>>> 3fdddd859af2 (bonding: alloc the structure ad_info dynamically in per slave)
  }
  
  /**
@@@ -395,11 -349,11 +404,16 @@@ static u8 __get_duplex(struct port *por
   */
  static inline void __initialize_port_locks(struct slave *slave)
  {
++<<<<<<< HEAD
 +	// make sure it isn't called twice
 +	spin_lock_init(&(SLAVE_AD_INFO(slave).state_machine_lock));
++=======
+ 	/* make sure it isn't called twice */
+ 	spin_lock_init(&(SLAVE_AD_INFO(slave)->state_machine_lock));
++>>>>>>> 3fdddd859af2 (bonding: alloc the structure ad_info dynamically in per slave)
  }
  
 -/* Conversions */
 +//conversions
  
  /**
   * __ad_timer_to_ticks - convert a given timer type to AD module ticks
@@@ -757,9 -687,9 +771,15 @@@ static struct aggregator *__get_active_
  	struct list_head *iter;
  	struct slave *slave;
  
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, iter)
 +		if (SLAVE_AD_INFO(slave).aggregator.is_active)
 +			return &(SLAVE_AD_INFO(slave).aggregator);
++=======
+ 	bond_for_each_slave_rcu(bond, slave, iter)
+ 		if (SLAVE_AD_INFO(slave)->aggregator.is_active)
+ 			return &(SLAVE_AD_INFO(slave)->aggregator);
++>>>>>>> 3fdddd859af2 (bonding: alloc the structure ad_info dynamically in per slave)
  
  	return NULL;
  }
@@@ -1312,19 -1280,22 +1332,19 @@@ static void ad_port_selection_logic(str
  				break;
  			}
  		}
 -		if (!curr_port) {
 -			/* meaning: the port was related to an aggregator
 -			 * but was not on the aggregator port list
 -			 */
 -			pr_warn_ratelimited("%s: Warning: Port %d (on %s) was related to aggregator %d but was not on its port list\n",
 -					    port->slave->bond->dev->name,
 -					    port->actor_port_number,
 -					    port->slave->dev->name,
 -					    port->aggregator->aggregator_identifier);
 +		if (!curr_port) { // meaning: the port was related to an aggregator but was not on the aggregator port list
 +			pr_warning("%s: Warning: Port %d (on %s) was related to aggregator %d but was not on its port list\n",
 +				   port->slave->bond->dev->name,
 +				   port->actor_port_number,
 +				   port->slave->dev->name,
 +				   port->aggregator->aggregator_identifier);
  		}
  	}
 -	/* search on all aggregators for a suitable aggregator for this port */
 +	// search on all aggregators for a suitable aggregator for this port
  	bond_for_each_slave(bond, slave, iter) {
- 		aggregator = &(SLAVE_AD_INFO(slave).aggregator);
+ 		aggregator = &(SLAVE_AD_INFO(slave)->aggregator);
  
 -		/* keep a free aggregator for later use(if needed) */
 +		// keep a free aggregator for later use(if needed)
  		if (!aggregator->lag_ports) {
  			if (!free_aggregator)
  				free_aggregator = aggregator;
@@@ -1525,8 -1503,8 +1545,13 @@@ static void ad_agg_selection_logic(stru
  	active = __get_active_agg(agg);
  	best = (active && agg_device_up(active)) ? active : NULL;
  
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, iter) {
 +		agg = &(SLAVE_AD_INFO(slave).aggregator);
++=======
+ 	bond_for_each_slave_rcu(bond, slave, iter) {
+ 		agg = &(SLAVE_AD_INFO(slave)->aggregator);
++>>>>>>> 3fdddd859af2 (bonding: alloc the structure ad_info dynamically in per slave)
  
  		agg->is_active = 0;
  
@@@ -1570,8 -1548,8 +1595,13 @@@
  			 best->lag_ports, best->slave,
  			 best->slave ? best->slave->dev->name : "NULL");
  
++<<<<<<< HEAD
 +		bond_for_each_slave(bond, slave, iter) {
 +			agg = &(SLAVE_AD_INFO(slave).aggregator);
++=======
+ 		bond_for_each_slave_rcu(bond, slave, iter) {
+ 			agg = &(SLAVE_AD_INFO(slave)->aggregator);
++>>>>>>> 3fdddd859af2 (bonding: alloc the structure ad_info dynamically in per slave)
  
  			pr_debug("Agg=%d; P=%d; a k=%d; p k=%d; Ind=%d; Act=%d\n",
  				 agg->aggregator_identifier, agg->num_of_ports,
@@@ -1912,15 -1849,11 +1942,15 @@@ void bond_3ad_bind_slave(struct slave *
  
  		__initialize_port_locks(slave);
  		port->slave = slave;
- 		port->actor_port_number = SLAVE_AD_INFO(slave).id;
+ 		port->actor_port_number = SLAVE_AD_INFO(slave)->id;
  		/* key is determined according to the link speed, duplex and user key(which
  		 * is yet not supported)
 +		 *              ------------------------------------------------------------
 +		 * Port key :   | User key                       |      Speed       |Duplex|
 +		 *              ------------------------------------------------------------
 +		 *              16                               6               1 0
  		 */
 -		port->actor_admin_port_key = 0;
 +		port->actor_admin_port_key = 0;	/* initialize this parameter */
  		port->actor_admin_port_key |= __get_duplex(port);
  		port->actor_admin_port_key |= (__get_link_speed(port) << 1);
  		port->actor_oper_port_key = port->actor_admin_port_key;
@@@ -1966,16 -1903,13 +1996,21 @@@ void bond_3ad_unbind_slave(struct slav
  	struct slave *slave_iter;
  	struct list_head *iter;
  
++<<<<<<< HEAD
 +	// find the aggregator related to this slave
 +	aggregator = &(SLAVE_AD_INFO(slave).aggregator);
 +
 +	// find the port related to this slave
 +	port = &(SLAVE_AD_INFO(slave).port);
++=======
+ 	aggregator = &(SLAVE_AD_INFO(slave)->aggregator);
+ 	port = &(SLAVE_AD_INFO(slave)->port);
++>>>>>>> 3fdddd859af2 (bonding: alloc the structure ad_info dynamically in per slave)
  
 -	/* if slave is null, the whole port is not initialized */
 +	// if slave is null, the whole port is not initialized
  	if (!port->slave) {
 -		pr_warn("Warning: %s: Trying to unbind an uninitialized port on %s\n",
 -			slave->bond->dev->name, slave->dev->name);
 +		pr_warning("Warning: %s: Trying to unbind an uninitialized port on %s\n",
 +			   slave->bond->dev->name, slave->dev->name);
  		return;
  	}
  
@@@ -1987,19 -1921,24 +2022,29 @@@
  	__update_lacpdu_from_port(port);
  	ad_lacpdu_send(port);
  
 -	/* check if this aggregator is occupied */
 +	// check if this aggregator is occupied
  	if (aggregator->lag_ports) {
 -		/* check if there are other ports related to this aggregator
 -		 * except the port related to this slave(thats ensure us that
 -		 * there is a reason to search for new aggregator, and that we
 -		 * will find one
 -		 */
 -		if ((aggregator->lag_ports != port) ||
 -		    (aggregator->lag_ports->next_port_in_aggregator)) {
 -			/* find new aggregator for the related port(s) */
 +		// check if there are other ports related to this aggregator except
 +		// the port related to this slave(thats ensure us that there is a
 +		// reason to search for new aggregator, and that we will find one
 +		if ((aggregator->lag_ports != port) || (aggregator->lag_ports->next_port_in_aggregator)) {
 +			// find new aggregator for the related port(s)
  			bond_for_each_slave(bond, slave_iter, iter) {
++<<<<<<< HEAD
 +				new_aggregator = &(SLAVE_AD_INFO(slave_iter).aggregator);
 +				// if the new aggregator is empty, or it is connected to our port only
 +				if (!new_aggregator->lag_ports
 +				    || ((new_aggregator->lag_ports == port)
 +					&& !new_aggregator->lag_ports->next_port_in_aggregator))
++=======
+ 				new_aggregator = &(SLAVE_AD_INFO(slave_iter)->aggregator);
+ 				/* if the new aggregator is empty, or it is
+ 				 * connected to our port only
+ 				 */
+ 				if (!new_aggregator->lag_ports ||
+ 				    ((new_aggregator->lag_ports == port) &&
+ 				     !new_aggregator->lag_ports->next_port_in_aggregator))
++>>>>>>> 3fdddd859af2 (bonding: alloc the structure ad_info dynamically in per slave)
  					break;
  			}
  			if (!slave_iter)
@@@ -2062,15 -2007,19 +2107,15 @@@
  	}
  
  	pr_debug("Unbinding port %d\n", port->actor_port_number);
 -
 -	/* find the aggregator that this port is connected to */
 +	// find the aggregator that this port is connected to
  	bond_for_each_slave(bond, slave_iter, iter) {
- 		temp_aggregator = &(SLAVE_AD_INFO(slave_iter).aggregator);
+ 		temp_aggregator = &(SLAVE_AD_INFO(slave_iter)->aggregator);
  		prev_port = NULL;
 -		/* search the port in the aggregator's related ports */
 +		// search the port in the aggregator's related ports
  		for (temp_port = temp_aggregator->lag_ports; temp_port;
  		     prev_port = temp_port,
 -		     temp_port = temp_port->next_port_in_aggregator) {
 -			if (temp_port == port) {
 -				/* the aggregator found - detach the port from
 -				 * this aggregator
 -				 */
 +			     temp_port = temp_port->next_port_in_aggregator) {
 +			if (temp_port == port) { // the aggregator found - detach the port from this aggregator
  				if (prev_port)
  					prev_port->next_port_in_aggregator = temp_port->next_port_in_aggregator;
  				else
@@@ -2111,24 -2059,30 +2156,35 @@@ void bond_3ad_state_machine_handler(str
  {
  	struct bonding *bond = container_of(work, struct bonding,
  					    ad_work.work);
 -	struct aggregator *aggregator;
 -	struct list_head *iter;
 -	struct slave *slave;
  	struct port *port;
 -	bool should_notify_rtnl = BOND_SLAVE_NOTIFY_LATER;
 -
 -	read_lock(&bond->lock);
 -	rcu_read_lock();
 +	struct aggregator *aggregator;
  
 -	/* check if there are any slaves */
 -	if (!bond_has_slaves(bond))
 +	if (!rtnl_trylock()) {
 +		queue_delayed_work(bond->wq, &bond->ad_work, ad_delta_in_ticks);
 +		return;
 +	}
 +	//check if there are any slaves
 +	if (bond->slave_cnt == 0)
  		goto re_arm;
  
++<<<<<<< HEAD
 +	// check if agg_select_timer timer after initialize is timed out
 +	if (BOND_AD_INFO(bond).agg_select_timer && !(--BOND_AD_INFO(bond).agg_select_timer)) {
 +		// select the active aggregator for the bond
 +		if ((port = __get_first_port(bond))) {
++=======
+ 	/* check if agg_select_timer timer after initialize is timed out */
+ 	if (BOND_AD_INFO(bond).agg_select_timer &&
+ 	    !(--BOND_AD_INFO(bond).agg_select_timer)) {
+ 		slave = bond_first_slave_rcu(bond);
+ 		port = slave ? &(SLAVE_AD_INFO(slave)->port) : NULL;
+ 
+ 		/* select the active aggregator for the bond */
+ 		if (port) {
++>>>>>>> 3fdddd859af2 (bonding: alloc the structure ad_info dynamically in per slave)
  			if (!port->slave) {
 -				pr_warn_ratelimited("%s: Warning: bond's first port is uninitialized\n",
 -						    bond->dev->name);
 +				pr_warning("%s: Warning: bond's first port is uninitialized\n",
 +					   bond->dev->name);
  				goto re_arm;
  			}
  
@@@ -2138,11 -2092,12 +2194,17 @@@
  		bond_3ad_set_carrier(bond);
  	}
  
++<<<<<<< HEAD
 +	// for each port run the state machines
 +	for (port = __get_first_port(bond); port; port = __get_next_port(port)) {
++=======
+ 	/* for each port run the state machines */
+ 	bond_for_each_slave_rcu(bond, slave, iter) {
+ 		port = &(SLAVE_AD_INFO(slave)->port);
++>>>>>>> 3fdddd859af2 (bonding: alloc the structure ad_info dynamically in per slave)
  		if (!port->slave) {
 -			pr_warn_ratelimited("%s: Warning: Found an uninitialized port\n",
 -					    bond->dev->name);
 +			pr_warning("%s: Warning: Found an uninitialized port\n",
 +				   bond->dev->name);
  			goto re_arm;
  		}
  
@@@ -2187,11 -2155,11 +2249,11 @@@ static int bond_3ad_rx_indication(struc
  
  	if (length >= sizeof(struct lacpdu)) {
  
- 		port = &(SLAVE_AD_INFO(slave).port);
+ 		port = &(SLAVE_AD_INFO(slave)->port);
  
  		if (!port->slave) {
 -			pr_warn_ratelimited("%s: Warning: port of slave %s is uninitialized\n",
 -					    slave->dev->name, slave->bond->dev->name);
 +			pr_warning("%s: Warning: port of slave %s is uninitialized\n",
 +				   slave->dev->name, slave->bond->dev->name);
  			return ret;
  		}
  
@@@ -2365,8 -2338,16 +2427,18 @@@ void bond_3ad_handle_link_change(struc
  int bond_3ad_set_carrier(struct bonding *bond)
  {
  	struct aggregator *active;
 -	struct slave *first_slave;
 -	int ret = 1;
  
++<<<<<<< HEAD
 +	active = __get_active_agg(&(SLAVE_AD_INFO(bond->first_slave).aggregator));
++=======
+ 	rcu_read_lock();
+ 	first_slave = bond_first_slave_rcu(bond);
+ 	if (!first_slave) {
+ 		ret = 0;
+ 		goto out;
+ 	}
+ 	active = __get_active_agg(&(SLAVE_AD_INFO(first_slave)->aggregator));
++>>>>>>> 3fdddd859af2 (bonding: alloc the structure ad_info dynamically in per slave)
  	if (active) {
  		/* are enough slaves available to consider link up? */
  		if (active->num_of_ports < bond->params.min_links) {
@@@ -2400,9 -2379,12 +2472,14 @@@ int __bond_3ad_get_active_agg_info(stru
  				   struct ad_info *ad_info)
  {
  	struct aggregator *aggregator = NULL;
 -	struct list_head *iter;
 -	struct slave *slave;
  	struct port *port;
  
++<<<<<<< HEAD
 +	for (port = __get_first_port(bond); port; port = __get_next_port(port)) {
++=======
+ 	bond_for_each_slave_rcu(bond, slave, iter) {
+ 		port = &(SLAVE_AD_INFO(slave)->port);
++>>>>>>> 3fdddd859af2 (bonding: alloc the structure ad_info dynamically in per slave)
  		if (port->aggregator && port->aggregator->is_active) {
  			aggregator = port->aggregator;
  			break;
@@@ -2454,20 -2436,28 +2531,27 @@@ int bond_3ad_xmit_xor(struct sk_buff *s
  	agg_id = ad_info.aggregator_id;
  
  	if (slaves_in_agg == 0) {
 +		/*the aggregator is empty*/
  		pr_debug("%s: Error: active aggregator is empty\n", dev->name);
 -		goto err_free;
 +		goto out;
  	}
  
 -	slave_agg_no = bond_xmit_hash(bond, skb) % slaves_in_agg;
 -	first_ok_slave = NULL;
 +	slave_agg_no = bond->xmit_hash_policy(skb, slaves_in_agg);
  
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
 +		struct aggregator *agg = SLAVE_AD_INFO(slave).port.aggregator;
++=======
+ 	bond_for_each_slave_rcu(bond, slave, iter) {
+ 		agg = SLAVE_AD_INFO(slave)->port.aggregator;
+ 		if (!agg || agg->aggregator_identifier != agg_id)
+ 			continue;
++>>>>>>> 3fdddd859af2 (bonding: alloc the structure ad_info dynamically in per slave)
  
 -		if (slave_agg_no >= 0) {
 -			if (!first_ok_slave && SLAVE_IS_OK(slave))
 -				first_ok_slave = slave;
 +		if (agg && (agg->aggregator_identifier == agg_id)) {
  			slave_agg_no--;
 -			continue;
 -		}
 -
 -		if (SLAVE_IS_OK(slave)) {
 -			bond_dev_queue_xmit(bond, skb, slave->dev);
 -			goto out;
 +			if (slave_agg_no < 0)
 +				break;
  		}
  	}
  
@@@ -2530,18 -2515,14 +2614,23 @@@ int bond_3ad_lacpdu_recv(const struct s
   */
  void bond_3ad_update_lacp_rate(struct bonding *bond)
  {
 -	struct port *port = NULL;
 -	struct list_head *iter;
 +	int i;
  	struct slave *slave;
 +	struct port *port = NULL;
  	int lacp_fast;
  
 +	write_lock_bh(&bond->lock);
  	lacp_fast = bond->params.lacp_fast;
++<<<<<<< HEAD
 +
 +	bond_for_each_slave(bond, slave, i) {
 +		port = &(SLAVE_AD_INFO(slave).port);
 +		if (port->slave == NULL)
 +			continue;
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
+ 		port = &(SLAVE_AD_INFO(slave)->port);
++>>>>>>> 3fdddd859af2 (bonding: alloc the structure ad_info dynamically in per slave)
  		__get_state_machine_lock(port);
  		if (lacp_fast)
  			port->actor_oper_port_state |= AD_STATE_LACP_TIMEOUT;
diff --cc drivers/net/bonding/bond_main.c
index d0eec7c786f0,90ebed6b3df6..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -1572,10 -1315,11 +1601,10 @@@ int bond_enslave(struct net_device *bon
  
  	/* If this is the first slave, then we need to set the master's hardware
  	 * address to be the same as the slave's. */
 -	if (!bond_has_slaves(bond) &&
 -	    bond->dev->addr_assign_type == NET_ADDR_RANDOM)
 +	if (!bond->slave_cnt && bond->dev->addr_assign_type == NET_ADDR_RANDOM)
  		bond_set_dev_addr(bond->dev, slave_dev);
  
- 	new_slave = kzalloc(sizeof(struct slave), GFP_KERNEL);
+ 	new_slave = bond_alloc_slave(bond);
  	if (!new_slave) {
  		res = -ENOMEM;
  		goto err_undo_flags;
@@@ -1759,17 -1498,17 +1788,27 @@@
  		 * will activate the slaves in the selected
  		 * aggregator
  		 */
 -		bond_set_slave_inactive_flags(new_slave, BOND_SLAVE_NOTIFY_NOW);
 +		bond_set_slave_inactive_flags(new_slave);
  		/* if this is the first slave */
++<<<<<<< HEAD
 +		if (bond->slave_cnt == 1) {
 +			SLAVE_AD_INFO(new_slave).id = 1;
++=======
+ 		if (!prev_slave) {
+ 			SLAVE_AD_INFO(new_slave)->id = 1;
++>>>>>>> 3fdddd859af2 (bonding: alloc the structure ad_info dynamically in per slave)
  			/* Initialize AD with the number of times that the AD timer is called in 1 second
  			 * can be called only after the mac address of the bond is set
  			 */
  			bond_3ad_initialize(bond, 1000/AD_TIMER_INTERVAL);
  		} else {
++<<<<<<< HEAD
 +			SLAVE_AD_INFO(new_slave).id =
 +				SLAVE_AD_INFO(new_slave->prev).id + 1;
++=======
+ 			SLAVE_AD_INFO(new_slave)->id =
+ 				SLAVE_AD_INFO(prev_slave)->id + 1;
++>>>>>>> 3fdddd859af2 (bonding: alloc the structure ad_info dynamically in per slave)
  		}
  
  		bond_3ad_bind_slave(new_slave);
@@@ -1891,13 -1629,12 +1930,13 @@@ err_restore_mtu
  	dev_set_mtu(slave_dev, new_slave->original_mtu);
  
  err_free:
- 	kfree(new_slave);
+ 	bond_free_slave(new_slave);
  
  err_undo_flags:
 +	bond_compute_features(bond);
  	/* Enslave of first slave has failed and we need to fix master's mac */
 -	if (!bond_has_slaves(bond) &&
 -	    ether_addr_equal_64bits(bond_dev->dev_addr, slave_dev->dev_addr))
 +	if (bond->slave_cnt == 0 &&
 +	    ether_addr_equal(bond_dev->dev_addr, slave_dev->dev_addr))
  		eth_hw_addr_random(bond_dev);
  
  	return res;
diff --cc drivers/net/bonding/bond_netlink.c
index 40e7b1cb4aea,0d06e751dff2..000000000000
--- a/drivers/net/bonding/bond_netlink.c
+++ b/drivers/net/bonding/bond_netlink.c
@@@ -20,6 -21,57 +20,60 @@@
  #include <net/rtnetlink.h>
  #include "bonding.h"
  
++<<<<<<< HEAD
++=======
+ static size_t bond_get_slave_size(const struct net_device *bond_dev,
+ 				  const struct net_device *slave_dev)
+ {
+ 	return nla_total_size(sizeof(u8)) +	/* IFLA_BOND_SLAVE_STATE */
+ 		nla_total_size(sizeof(u8)) +	/* IFLA_BOND_SLAVE_MII_STATUS */
+ 		nla_total_size(sizeof(u32)) +	/* IFLA_BOND_SLAVE_LINK_FAILURE_COUNT */
+ 		nla_total_size(MAX_ADDR_LEN) +	/* IFLA_BOND_SLAVE_PERM_HWADDR */
+ 		nla_total_size(sizeof(u16)) +	/* IFLA_BOND_SLAVE_QUEUE_ID */
+ 		nla_total_size(sizeof(u16)) +	/* IFLA_BOND_SLAVE_AD_AGGREGATOR_ID */
+ 		0;
+ }
+ 
+ static int bond_fill_slave_info(struct sk_buff *skb,
+ 				const struct net_device *bond_dev,
+ 				const struct net_device *slave_dev)
+ {
+ 	struct slave *slave = bond_slave_get_rtnl(slave_dev);
+ 
+ 	if (nla_put_u8(skb, IFLA_BOND_SLAVE_STATE, bond_slave_state(slave)))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u8(skb, IFLA_BOND_SLAVE_MII_STATUS, slave->link))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u32(skb, IFLA_BOND_SLAVE_LINK_FAILURE_COUNT,
+ 			slave->link_failure_count))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put(skb, IFLA_BOND_SLAVE_PERM_HWADDR,
+ 		    slave_dev->addr_len, slave->perm_hwaddr))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u16(skb, IFLA_BOND_SLAVE_QUEUE_ID, slave->queue_id))
+ 		goto nla_put_failure;
+ 
+ 	if (slave->bond->params.mode == BOND_MODE_8023AD) {
+ 		const struct aggregator *agg;
+ 
+ 		agg = SLAVE_AD_INFO(slave)->port.aggregator;
+ 		if (agg)
+ 			if (nla_put_u16(skb, IFLA_BOND_SLAVE_AD_AGGREGATOR_ID,
+ 					agg->aggregator_identifier))
+ 				goto nla_put_failure;
+ 	}
+ 
+ 	return 0;
+ 
+ nla_put_failure:
+ 	return -EMSGSIZE;
+ }
+ 
++>>>>>>> 3fdddd859af2 (bonding: alloc the structure ad_info dynamically in per slave)
  static const struct nla_policy bond_policy[IFLA_BOND_MAX + 1] = {
  	[IFLA_BOND_MODE]		= { .type = NLA_U8 },
  	[IFLA_BOND_ACTIVE_SLAVE]	= { .type = NLA_U32 },
* Unmerged path drivers/net/bonding/bond_sysfs_slave.c
* Unmerged path drivers/net/bonding/bond_3ad.c
* Unmerged path drivers/net/bonding/bond_main.c
* Unmerged path drivers/net/bonding/bond_netlink.c
diff --git a/drivers/net/bonding/bond_procfs.c b/drivers/net/bonding/bond_procfs.c
index 96f629d77b41..ce3f16c84e21 100644
--- a/drivers/net/bonding/bond_procfs.c
+++ b/drivers/net/bonding/bond_procfs.c
@@ -184,7 +184,7 @@ static void bond_info_show_slave(struct seq_file *seq,
 
 	if (bond->params.mode == BOND_MODE_8023AD) {
 		const struct aggregator *agg
-			= SLAVE_AD_INFO(slave).port.aggregator;
+			= SLAVE_AD_INFO(slave)->port.aggregator;
 
 		if (agg)
 			seq_printf(seq, "Aggregator ID: %d\n",
* Unmerged path drivers/net/bonding/bond_sysfs_slave.c
diff --git a/drivers/net/bonding/bonding.h b/drivers/net/bonding/bonding.h
index e1ca02f0b074..6eafed74cdd7 100644
--- a/drivers/net/bonding/bonding.h
+++ b/drivers/net/bonding/bonding.h
@@ -193,7 +193,7 @@ struct slave {
 	u32    speed;
 	u16    queue_id;
 	u8     perm_hwaddr[ETH_ALEN];
-	struct ad_slave_info ad_info; /* HUGE - better to dynamically alloc */
+	struct ad_slave_info *ad_info;
 	struct tlb_slave_info tlb_info;
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	struct netpoll *np;
