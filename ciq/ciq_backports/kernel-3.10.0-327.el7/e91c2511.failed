powerpc/iommu: Cleanup setting of DMA base/offset

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [powerpc] iommu: Cleanup setting of DMA base/offset (Gustavo Duarte) [1246880]
Rebuild_FUZZ: 91.11%
commit-author Benjamin Herrenschmidt <benh@kernel.crashing.org>
commit e91c25111aa373af7439d97ab0e606bcffd599ef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/e91c2511.failed

Now that the table and the offset can co-exist, we no longer need
to flip/flop, we can just establish both once at boot time.

	Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit e91c25111aa373af7439d97ab0e606bcffd599ef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/powernv/pci-ioda.c
diff --cc arch/powerpc/platforms/powernv/pci-ioda.c
index 2f4bac41fe49,2c286b57e520..000000000000
--- a/arch/powerpc/platforms/powernv/pci-ioda.c
+++ b/arch/powerpc/platforms/powernv/pci-ioda.c
@@@ -563,9 -1623,8 +563,11 @@@ static int pnv_pci_ioda_dma_set_mask(st
  	} else {
  		dev_info(&pdev->dev, "Using 32-bit DMA via iommu\n");
  		set_dma_ops(&pdev->dev, &dma_iommu_ops);
++<<<<<<< HEAD
 +		set_iommu_table_base(&pdev->dev, &pe->tce32_table);
++=======
++>>>>>>> e91c25111aa3 (powerpc/iommu: Cleanup setting of DMA base/offset)
  	}
 -	*pdev->dev.dma_mask = dma_mask;
  	return 0;
  }
  
@@@ -576,15 -1656,12 +578,21 @@@ static void pnv_ioda_setup_bus_dma(stru
  	struct pci_dev *dev;
  
  	list_for_each_entry(dev, &bus->devices, bus_list) {
++<<<<<<< HEAD
 +		if (add_to_iommu_group)
 +			set_iommu_table_base_and_group(&dev->dev,
 +						       &pe->tce32_table);
 +		else
 +			set_iommu_table_base(&dev->dev, &pe->tce32_table);
++=======
+ 		set_iommu_table_base(&dev->dev, pe->table_group.tables[0]);
+ 		set_dma_offset(&dev->dev, pe->tce_bypass_base);
+ 		iommu_add_device(&dev->dev);
++>>>>>>> e91c25111aa3 (powerpc/iommu: Cleanup setting of DMA base/offset)
  
 -		if ((pe->flags & PNV_IODA_PE_BUS_ALL) && dev->subordinate)
 -			pnv_ioda_setup_bus_dma(pe, dev->subordinate);
 +		if (dev->subordinate)
 +			pnv_ioda_setup_bus_dma(pe, dev->subordinate,
 +					       add_to_iommu_group);
  	}
  }
  
* Unmerged path arch/powerpc/platforms/powernv/pci-ioda.c
diff --git a/arch/powerpc/platforms/pseries/iommu.c b/arch/powerpc/platforms/pseries/iommu.c
index 1edda98be625..4cef11370d10 100644
--- a/arch/powerpc/platforms/pseries/iommu.c
+++ b/arch/powerpc/platforms/pseries/iommu.c
@@ -1157,11 +1157,10 @@ static int dma_set_mask_pSeriesLP(struct device *dev, u64 dma_mask)
 		}
 	}
 
-	/* fall back on iommu ops, restore table pointer with ops */
+	/* fall back on iommu ops */
 	if (!ddw_enabled && get_dma_ops(dev) != &dma_iommu_ops) {
 		dev_info(dev, "Restoring 32-bit DMA via iommu\n");
 		set_dma_ops(dev, &dma_iommu_ops);
-		pci_dma_dev_setup_pSeriesLP(pdev);
 	}
 
 check_mask:
diff --git a/arch/powerpc/sysdev/dart_iommu.c b/arch/powerpc/sysdev/dart_iommu.c
index bd968a43a48b..1f3cd24945d9 100644
--- a/arch/powerpc/sysdev/dart_iommu.c
+++ b/arch/powerpc/sysdev/dart_iommu.c
@@ -305,20 +305,11 @@ static void iommu_table_dart_setup(void)
 	set_bit(iommu_table_dart.it_size - 1, iommu_table_dart.it_map);
 }
 
-static void dma_dev_setup_dart(struct device *dev)
-{
-	/* We only have one iommu table on the mac for now, which makes
-	 * things simple. Setup all PCI devices to point to this table
-	 */
-	if (get_dma_ops(dev) == &dma_direct_ops)
-		set_dma_offset(dev, DART_U4_BYPASS_BASE);
-	else
-		set_iommu_table_base(dev, &iommu_table_dart);
-}
-
 static void pci_dma_dev_setup_dart(struct pci_dev *dev)
 {
-	dma_dev_setup_dart(&dev->dev);
+	if (dart_is_u4)
+		set_dma_offset(&dev->dev, DART_U4_BYPASS_BASE);
+	set_iommu_table_base(&dev->dev, &iommu_table_dart);
 }
 
 static void pci_dma_bus_setup_dart(struct pci_bus *bus)
@@ -362,7 +353,6 @@ static int dart_dma_set_mask(struct device *dev, u64 dma_mask)
 		dev_info(dev, "Using 32-bit DMA via iommu\n");
 		set_dma_ops(dev, &dma_iommu_ops);
 	}
-	dma_dev_setup_dart(dev);
 
 	*dev->dma_mask = dma_mask;
 	return 0;
