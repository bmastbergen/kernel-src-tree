net/mlx4_en: Protect access to the statistics bitmap

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [netdrv] mlx4_en: Protect access to the statistics bitmap (Amir Vadai) [1164527 1164530 1164531 1164536 1164537]
Rebuild_FUZZ: 96.00%
commit-author Eran Ben Elisha <eranbe@mellanox.com>
commit 3da8a36cc5c2a172bb42f8dc89638f5b41d7d7a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/3da8a36c.failed

This will allow parallel access to the statistics bitmap.
A pre-step for adding PFC counters, where the statistics bitmap
can be dynamically changed when modifying the PFC setting.

	Signed-off-by: Eran Ben Elisha <eranbe@mellanox.com>
	Signed-off-by: Hadar Hen Zion <hadarh@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3da8a36cc5c2a172bb42f8dc89638f5b41d7d7a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
#	drivers/net/ethernet/mellanox/mlx4/en_netdev.c
#	drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
diff --cc drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
index ecc91038e731,3e7ed39e8e76..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
@@@ -225,7 -227,43 +225,13 @@@ static int mlx4_en_set_wol(struct net_d
  static int mlx4_en_get_sset_count(struct net_device *dev, int sset)
  {
  	struct mlx4_en_priv *priv = netdev_priv(dev);
++<<<<<<< HEAD
 +	int bit_count = hweight64(priv->stats_bitmap);
++=======
+ 	struct bitmap_iterator it;
+ 
+ 	bitmap_iterator_init(&it, priv->stats_bitmap.bitmap, NUM_ALL_STATS);
++>>>>>>> 3da8a36cc5c2 (net/mlx4_en: Protect access to the statistics bitmap)
  
  	switch (sset) {
  	case ETH_SS_STATS:
@@@ -251,7 -289,10 +257,14 @@@ static void mlx4_en_get_ethtool_stats(s
  {
  	struct mlx4_en_priv *priv = netdev_priv(dev);
  	int index = 0;
++<<<<<<< HEAD
 +	int i, j = 0;
++=======
+ 	int i;
+ 	struct bitmap_iterator it;
+ 
+ 	bitmap_iterator_init(&it, priv->stats_bitmap.bitmap, NUM_ALL_STATS);
++>>>>>>> 3da8a36cc5c2 (net/mlx4_en: Protect access to the statistics bitmap)
  
  	spin_lock_bh(&priv->stats_lock);
  
@@@ -307,7 -336,10 +320,14 @@@ static void mlx4_en_get_strings(struct 
  {
  	struct mlx4_en_priv *priv = netdev_priv(dev);
  	int index = 0;
++<<<<<<< HEAD
 +	int i;
++=======
+ 	int i, strings = 0;
+ 	struct bitmap_iterator it;
+ 
+ 	bitmap_iterator_init(&it, priv->stats_bitmap.bitmap, NUM_ALL_STATS);
++>>>>>>> 3da8a36cc5c2 (net/mlx4_en: Protect access to the statistics bitmap)
  
  	switch (stringset) {
  	case ETH_SS_TEST:
diff --cc drivers/net/ethernet/mellanox/mlx4/en_netdev.c
index 496c65027ae1,4542bab9494b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
@@@ -2433,9 -2469,218 +2433,219 @@@ static const struct net_device_ops mlx4
  #ifdef CONFIG_MLX4_EN_VXLAN
  	.ndo_add_vxlan_port	= mlx4_en_add_vxlan_port,
  	.ndo_del_vxlan_port	= mlx4_en_del_vxlan_port,
 -	.ndo_features_check	= mlx4_en_features_check,
  #endif
 -	.ndo_set_tx_maxrate	= mlx4_en_set_tx_maxrate,
  };
  
++<<<<<<< HEAD
++=======
+ struct mlx4_en_bond {
+ 	struct work_struct work;
+ 	struct mlx4_en_priv *priv;
+ 	int is_bonded;
+ 	struct mlx4_port_map port_map;
+ };
+ 
+ static void mlx4_en_bond_work(struct work_struct *work)
+ {
+ 	struct mlx4_en_bond *bond = container_of(work,
+ 						     struct mlx4_en_bond,
+ 						     work);
+ 	int err = 0;
+ 	struct mlx4_dev *dev = bond->priv->mdev->dev;
+ 
+ 	if (bond->is_bonded) {
+ 		if (!mlx4_is_bonded(dev)) {
+ 			err = mlx4_bond(dev);
+ 			if (err)
+ 				en_err(bond->priv, "Fail to bond device\n");
+ 		}
+ 		if (!err) {
+ 			err = mlx4_port_map_set(dev, &bond->port_map);
+ 			if (err)
+ 				en_err(bond->priv, "Fail to set port map [%d][%d]: %d\n",
+ 				       bond->port_map.port1,
+ 				       bond->port_map.port2,
+ 				       err);
+ 		}
+ 	} else if (mlx4_is_bonded(dev)) {
+ 		err = mlx4_unbond(dev);
+ 		if (err)
+ 			en_err(bond->priv, "Fail to unbond device\n");
+ 	}
+ 	dev_put(bond->priv->dev);
+ 	kfree(bond);
+ }
+ 
+ static int mlx4_en_queue_bond_work(struct mlx4_en_priv *priv, int is_bonded,
+ 				   u8 v2p_p1, u8 v2p_p2)
+ {
+ 	struct mlx4_en_bond *bond = NULL;
+ 
+ 	bond = kzalloc(sizeof(*bond), GFP_ATOMIC);
+ 	if (!bond)
+ 		return -ENOMEM;
+ 
+ 	INIT_WORK(&bond->work, mlx4_en_bond_work);
+ 	bond->priv = priv;
+ 	bond->is_bonded = is_bonded;
+ 	bond->port_map.port1 = v2p_p1;
+ 	bond->port_map.port2 = v2p_p2;
+ 	dev_hold(priv->dev);
+ 	queue_work(priv->mdev->workqueue, &bond->work);
+ 	return 0;
+ }
+ 
+ int mlx4_en_netdev_event(struct notifier_block *this,
+ 			 unsigned long event, void *ptr)
+ {
+ 	struct net_device *ndev = netdev_notifier_info_to_dev(ptr);
+ 	u8 port = 0;
+ 	struct mlx4_en_dev *mdev;
+ 	struct mlx4_dev *dev;
+ 	int i, num_eth_ports = 0;
+ 	bool do_bond = true;
+ 	struct mlx4_en_priv *priv;
+ 	u8 v2p_port1 = 0;
+ 	u8 v2p_port2 = 0;
+ 
+ 	if (!net_eq(dev_net(ndev), &init_net))
+ 		return NOTIFY_DONE;
+ 
+ 	mdev = container_of(this, struct mlx4_en_dev, nb);
+ 	dev = mdev->dev;
+ 
+ 	/* Go into this mode only when two network devices set on two ports
+ 	 * of the same mlx4 device are slaves of the same bonding master
+ 	 */
+ 	mlx4_foreach_port(i, dev, MLX4_PORT_TYPE_ETH) {
+ 		++num_eth_ports;
+ 		if (!port && (mdev->pndev[i] == ndev))
+ 			port = i;
+ 		mdev->upper[i] = mdev->pndev[i] ?
+ 			netdev_master_upper_dev_get(mdev->pndev[i]) : NULL;
+ 		/* condition not met: network device is a slave */
+ 		if (!mdev->upper[i])
+ 			do_bond = false;
+ 		if (num_eth_ports < 2)
+ 			continue;
+ 		/* condition not met: same master */
+ 		if (mdev->upper[i] != mdev->upper[i-1])
+ 			do_bond = false;
+ 	}
+ 	/* condition not met: 2 salves */
+ 	do_bond = (num_eth_ports ==  2) ? do_bond : false;
+ 
+ 	/* handle only events that come with enough info */
+ 	if ((do_bond && (event != NETDEV_BONDING_INFO)) || !port)
+ 		return NOTIFY_DONE;
+ 
+ 	priv = netdev_priv(ndev);
+ 	if (do_bond) {
+ 		struct netdev_notifier_bonding_info *notifier_info = ptr;
+ 		struct netdev_bonding_info *bonding_info =
+ 			&notifier_info->bonding_info;
+ 
+ 		/* required mode 1, 2 or 4 */
+ 		if ((bonding_info->master.bond_mode != BOND_MODE_ACTIVEBACKUP) &&
+ 		    (bonding_info->master.bond_mode != BOND_MODE_XOR) &&
+ 		    (bonding_info->master.bond_mode != BOND_MODE_8023AD))
+ 			do_bond = false;
+ 
+ 		/* require exactly 2 slaves */
+ 		if (bonding_info->master.num_slaves != 2)
+ 			do_bond = false;
+ 
+ 		/* calc v2p */
+ 		if (do_bond) {
+ 			if (bonding_info->master.bond_mode ==
+ 			    BOND_MODE_ACTIVEBACKUP) {
+ 				/* in active-backup mode virtual ports are
+ 				 * mapped to the physical port of the active
+ 				 * slave */
+ 				if (bonding_info->slave.state ==
+ 				    BOND_STATE_BACKUP) {
+ 					if (port == 1) {
+ 						v2p_port1 = 2;
+ 						v2p_port2 = 2;
+ 					} else {
+ 						v2p_port1 = 1;
+ 						v2p_port2 = 1;
+ 					}
+ 				} else { /* BOND_STATE_ACTIVE */
+ 					if (port == 1) {
+ 						v2p_port1 = 1;
+ 						v2p_port2 = 1;
+ 					} else {
+ 						v2p_port1 = 2;
+ 						v2p_port2 = 2;
+ 					}
+ 				}
+ 			} else { /* Active-Active */
+ 				/* in active-active mode a virtual port is
+ 				 * mapped to the native physical port if and only
+ 				 * if the physical port is up */
+ 				__s8 link = bonding_info->slave.link;
+ 
+ 				if (port == 1)
+ 					v2p_port2 = 2;
+ 				else
+ 					v2p_port1 = 1;
+ 				if ((link == BOND_LINK_UP) ||
+ 				    (link == BOND_LINK_FAIL)) {
+ 					if (port == 1)
+ 						v2p_port1 = 1;
+ 					else
+ 						v2p_port2 = 2;
+ 				} else { /* BOND_LINK_DOWN || BOND_LINK_BACK */
+ 					if (port == 1)
+ 						v2p_port1 = 2;
+ 					else
+ 						v2p_port2 = 1;
+ 				}
+ 			}
+ 		}
+ 	}
+ 
+ 	mlx4_en_queue_bond_work(priv, do_bond,
+ 				v2p_port1, v2p_port2);
+ 
+ 	return NOTIFY_DONE;
+ }
+ 
+ void mlx4_en_set_stats_bitmap(struct mlx4_dev *dev,
+ 			      struct mlx4_en_stats_bitmap *stats_bitmap)
+ {
+ 	int last_i = 0;
+ 
+ 	mutex_init(&stats_bitmap->mutex);
+ 	bitmap_zero(stats_bitmap->bitmap, NUM_ALL_STATS);
+ 
+ 	if (mlx4_is_slave(dev)) {
+ 		bitmap_set(stats_bitmap->bitmap, last_i +
+ 					 MLX4_FIND_NETDEV_STAT(rx_packets), 1);
+ 		bitmap_set(stats_bitmap->bitmap, last_i +
+ 					 MLX4_FIND_NETDEV_STAT(tx_packets), 1);
+ 		bitmap_set(stats_bitmap->bitmap, last_i +
+ 					 MLX4_FIND_NETDEV_STAT(rx_bytes), 1);
+ 		bitmap_set(stats_bitmap->bitmap, last_i +
+ 					 MLX4_FIND_NETDEV_STAT(tx_bytes), 1);
+ 		bitmap_set(stats_bitmap->bitmap, last_i +
+ 					 MLX4_FIND_NETDEV_STAT(rx_dropped), 1);
+ 		bitmap_set(stats_bitmap->bitmap, last_i +
+ 					 MLX4_FIND_NETDEV_STAT(tx_dropped), 1);
+ 	} else {
+ 		bitmap_set(stats_bitmap->bitmap, last_i, NUM_MAIN_STATS);
+ 	}
+ 	last_i += NUM_MAIN_STATS;
+ 
+ 	bitmap_set(stats_bitmap->bitmap, last_i, NUM_PORT_STATS);
+ 	last_i += NUM_PORT_STATS;
+ 
+ 	if (!mlx4_is_slave(dev))
+ 		bitmap_set(stats_bitmap->bitmap, last_i, NUM_PKT_STATS);
+ }
+ 
++>>>>>>> 3da8a36cc5c2 (net/mlx4_en: Protect access to the statistics bitmap)
  int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,
  			struct mlx4_en_port_profile *prof)
  {
@@@ -2648,15 -2914,7 +2858,19 @@@
  		queue_delayed_work(mdev->workqueue, &priv->service_task,
  				   SERVICE_TASK_DELAY);
  
++<<<<<<< HEAD
 +	mlx4_set_stats_bitmap(mdev->dev, &priv->stats_bitmap);
 +
 +	err = register_netdev(dev);
 +	if (err) {
 +		en_err(priv, "Netdev registration failed for port %d\n", port);
 +		goto out;
 +	}
 +
 +	priv->registered = 1;
++=======
+ 	mlx4_en_set_stats_bitmap(mdev->dev, &priv->stats_bitmap);
++>>>>>>> 3da8a36cc5c2 (net/mlx4_en: Protect access to the statistics bitmap)
  
  	return 0;
  
diff --cc drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
index 29a881cbb841,d5d971a408f2..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
+++ b/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
@@@ -561,7 -566,7 +566,11 @@@ struct mlx4_en_priv 
  	struct mlx4_en_perf_stats pstats;
  	struct mlx4_en_pkt_stats pkstats;
  	struct mlx4_en_port_stats port_stats;
++<<<<<<< HEAD
 +	u64 stats_bitmap;
++=======
+ 	struct mlx4_en_stats_bitmap stats_bitmap;
++>>>>>>> 3da8a36cc5c2 (net/mlx4_en: Protect access to the statistics bitmap)
  	struct list_head mc_list;
  	struct list_head curr_list;
  	u64 broadcast_id;
@@@ -727,6 -735,9 +736,12 @@@ int mlx4_en_init_netdev(struct mlx4_en_
  int mlx4_en_start_port(struct net_device *dev);
  void mlx4_en_stop_port(struct net_device *dev, int detach);
  
++<<<<<<< HEAD
++=======
+ void mlx4_en_set_stats_bitmap(struct mlx4_dev *dev,
+ 			      struct mlx4_en_stats_bitmap *stats_bitmap);
+ 
++>>>>>>> 3da8a36cc5c2 (net/mlx4_en: Protect access to the statistics bitmap)
  void mlx4_en_free_resources(struct mlx4_en_priv *priv);
  int mlx4_en_alloc_resources(struct mlx4_en_priv *priv);
  
* Unmerged path drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
* Unmerged path drivers/net/ethernet/mellanox/mlx4/en_netdev.c
* Unmerged path drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
