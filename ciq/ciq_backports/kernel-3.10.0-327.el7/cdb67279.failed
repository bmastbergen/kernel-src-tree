ovl: lookup whiteouts outside iterate_dir()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Miklos Szeredi <mszeredi@suse.cz>
commit cdb672795876d7bc1870aed9a2d7cb59f43d1d96
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/cdb67279.failed

If jffs2 can deadlock on overlayfs readdir because it takes the same lock
on ->iterate() as in ->lookup().

Fix by moving whiteout checking outside iterate_dir().  Optimized by
collecting potential whiteouts (DT_CHR) in a temporary list and if
non-empty iterating throug these and checking for a 0/0 chardev.

	Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
Fixes: 49c21e1cacd7 ("ovl: check whiteout while reading directory")
	Reported-by: Roman Yeryomin <leroi.lists@gmail.com> 
(cherry picked from commit cdb672795876d7bc1870aed9a2d7cb59f43d1d96)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/readdir.c
diff --cc fs/overlayfs/readdir.c
index f4eb1dbe8305,70e9af551600..000000000000
--- a/fs/overlayfs/readdir.c
+++ b/fs/overlayfs/readdir.c
@@@ -23,8 -23,8 +23,9 @@@ struct ovl_cache_entry 
  	u64 ino;
  	struct list_head l_node;
  	struct rb_node node;
+ 	struct ovl_cache_entry *next_maybe_whiteout;
  	bool is_whiteout;
 +	bool is_cursor;
  	char name[];
  };
  
@@@ -85,23 -80,28 +86,44 @@@ static struct ovl_cache_entry *ovl_cach
  	return NULL;
  }
  
++<<<<<<< HEAD
 +static struct ovl_cache_entry *ovl_cache_entry_new(const char *name, int len,
++=======
+ static struct ovl_cache_entry *ovl_cache_entry_new(struct ovl_readdir_data *rdd,
+ 						   const char *name, int len,
++>>>>>>> cdb672795876 (ovl: lookup whiteouts outside iterate_dir())
  						   u64 ino, unsigned int d_type)
  {
  	struct ovl_cache_entry *p;
  	size_t size = offsetof(struct ovl_cache_entry, name[len + 1]);
  
  	p = kmalloc(size, GFP_KERNEL);
++<<<<<<< HEAD
 +	if (p) {
 +		memcpy(p->name, name, len);
 +		p->name[len] = '\0';
 +		p->len = len;
 +		p->type = d_type;
 +		p->ino = ino;
 +		p->is_whiteout = false;
 +		p->is_cursor = false;
++=======
+ 	if (!p)
+ 		return NULL;
+ 
+ 	memcpy(p->name, name, len);
+ 	p->name[len] = '\0';
+ 	p->len = len;
+ 	p->type = d_type;
+ 	p->ino = ino;
+ 	p->is_whiteout = false;
+ 
+ 	if (d_type == DT_CHR) {
+ 		p->next_maybe_whiteout = rdd->first_maybe_whiteout;
+ 		rdd->first_maybe_whiteout = p;
++>>>>>>> cdb672795876 (ovl: lookup whiteouts outside iterate_dir())
  	}
 +
  	return p;
  }
  
@@@ -128,7 -128,7 +150,11 @@@ static int ovl_cache_entry_add_rb(struc
  			return 0;
  	}
  
++<<<<<<< HEAD
 +	p = ovl_cache_entry_new(name, len, ino, d_type);
++=======
+ 	p = ovl_cache_entry_new(rdd, name, len, ino, d_type);
++>>>>>>> cdb672795876 (ovl: lookup whiteouts outside iterate_dir())
  	if (p == NULL)
  		return -ENOMEM;
  
@@@ -175,7 -149,7 +201,11 @@@ static int ovl_fill_lower(struct ovl_re
  	if (p) {
  		list_move_tail(&p->l_node, &rdd->middle);
  	} else {
++<<<<<<< HEAD
 +		p = ovl_cache_entry_new(name, namelen, ino, d_type);
++=======
+ 		p = ovl_cache_entry_new(rdd, name, namelen, ino, d_type);
++>>>>>>> cdb672795876 (ovl: lookup whiteouts outside iterate_dir())
  		if (p == NULL)
  			rdd->err = -ENOMEM;
  		else
@@@ -236,7 -246,8 +303,12 @@@ static inline int ovl_dir_read(struct p
  	if (IS_ERR(realfile))
  		return PTR_ERR(realfile);
  
++<<<<<<< HEAD
 +	//rdd->ctx.pos = 0;
++=======
+ 	rdd->first_maybe_whiteout = NULL;
+ 	rdd->ctx.pos = 0;
++>>>>>>> cdb672795876 (ovl: lookup whiteouts outside iterate_dir())
  	do {
  		rdd->count = 0;
  		rdd->err = 0;
* Unmerged path fs/overlayfs/readdir.c
