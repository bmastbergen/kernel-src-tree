xfs: fix compile error when libxfs header used in C++ code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Roger Willcocks <roger@filmlight.ltd.uk>
commit 376c2f3a5f0706868b08ccf043bf3532936a03b1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/376c2f3a.failed

xfs_ialloc.h:102: error: expected ',' or '...' before 'delete'

Simple parameter rename, no changes to behaviour.

	Signed-off-by: Roger Willcocks <roger@filmlight.ltd.uk>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>


(cherry picked from commit 376c2f3a5f0706868b08ccf043bf3532936a03b1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_ialloc.c
diff --cc fs/xfs/xfs_ialloc.c
index fedaf58e322a,b819263b7f2e..000000000000
--- a/fs/xfs/xfs_ialloc.c
+++ b/fs/xfs/xfs_ialloc.c
@@@ -1430,30 -1098,74 +1430,46 @@@ out_error
  	return XFS_ERROR(error);
  }
  
++<<<<<<< HEAD
 +STATIC int
 +xfs_difree_inobt(
 +	struct xfs_mount		*mp,
 +	struct xfs_trans		*tp,
 +	struct xfs_buf			*agbp,
 +	xfs_agino_t			agino,
 +	struct xfs_bmap_free		*flist,
 +	int				*delete,
 +	xfs_ino_t			*first_ino,
 +	struct xfs_inobt_rec_incore	*orec)
++=======
+ /*
+  * Free disk inode.  Carefully avoids touching the incore inode, all
+  * manipulations incore are the caller's responsibility.
+  * The on-disk inode is not changed by this operation, only the
+  * btree (free inode mask) is changed.
+  */
+ int
+ xfs_difree(
+ 	xfs_trans_t	*tp,		/* transaction pointer */
+ 	xfs_ino_t	inode,		/* inode to be freed */
+ 	xfs_bmap_free_t	*flist,		/* extents to free */
+ 	int		*deleted,	/* set if inode cluster was deleted */
+ 	xfs_ino_t	*first_ino)	/* first inode in deleted cluster */
++>>>>>>> 376c2f3a5f07 (xfs: fix compile error when libxfs header used in C++ code)
  {
 -	/* REFERENCED */
 -	xfs_agblock_t	agbno;	/* block number containing inode */
 -	xfs_buf_t	*agbp;	/* buffer containing allocation group header */
 -	xfs_agino_t	agino;	/* inode number relative to allocation group */
 -	xfs_agnumber_t	agno;	/* allocation group number */
 -	xfs_agi_t	*agi;	/* allocation group header */
 -	xfs_btree_cur_t	*cur;	/* inode btree cursor */
 -	int		error;	/* error return value */
 -	int		i;	/* result code */
 -	int		ilen;	/* inodes in an inode cluster */
 -	xfs_mount_t	*mp;	/* mount structure for filesystem */
 -	int		off;	/* offset of inode in inode chunk */
 -	xfs_inobt_rec_incore_t rec;	/* btree record */
 -	struct xfs_perag *pag;
 -
 -	mp = tp->t_mountp;
 +	struct xfs_agi			*agi = XFS_BUF_TO_AGI(agbp);
 +	xfs_agnumber_t			agno = be32_to_cpu(agi->agi_seqno);
 +	struct xfs_perag		*pag;
 +	struct xfs_btree_cur		*cur;
 +	struct xfs_inobt_rec_incore	rec;
 +	int				ilen;
 +	int				error;
 +	int				i;
 +	int				off;
  
 -	/*
 -	 * Break up inode number into its components.
 -	 */
 -	agno = XFS_INO_TO_AGNO(mp, inode);
 -	if (agno >= mp->m_sb.sb_agcount)  {
 -		xfs_warn(mp, "%s: agno >= mp->m_sb.sb_agcount (%d >= %d).",
 -			__func__, agno, mp->m_sb.sb_agcount);
 -		ASSERT(0);
 -		return XFS_ERROR(EINVAL);
 -	}
 -	agino = XFS_INO_TO_AGINO(mp, inode);
 -	if (inode != XFS_AGINO_TO_INO(mp, agno, agino))  {
 -		xfs_warn(mp, "%s: inode != XFS_AGINO_TO_INO() (%llu != %llu).",
 -			__func__, (unsigned long long)inode,
 -			(unsigned long long)XFS_AGINO_TO_INO(mp, agno, agino));
 -		ASSERT(0);
 -		return XFS_ERROR(EINVAL);
 -	}
 -	agbno = XFS_AGINO_TO_AGBNO(mp, agino);
 -	if (agbno >= mp->m_sb.sb_agblocks)  {
 -		xfs_warn(mp, "%s: agbno >= mp->m_sb.sb_agblocks (%d >= %d).",
 -			__func__, agbno, mp->m_sb.sb_agblocks);
 -		ASSERT(0);
 -		return XFS_ERROR(EINVAL);
 -	}
 -	/*
 -	 * Get the allocation group header.
 -	 */
 -	error = xfs_ialloc_read_agi(mp, tp, agno, &agbp);
 -	if (error) {
 -		xfs_warn(mp, "%s: xfs_ialloc_read_agi() returned error %d.",
 -			__func__, error);
 -		return error;
 -	}
 -	agi = XFS_BUF_TO_AGI(agbp);
  	ASSERT(agi->agi_magicnum == cpu_to_be32(XFS_AGI_MAGIC));
 -	ASSERT(agbno < be32_to_cpu(agi->agi_length));
 +	ASSERT(XFS_AGINO_TO_AGBNO(mp, agino) < be32_to_cpu(agi->agi_length));
 +
  	/*
  	 * Initialize the cursor.
  	 */
* Unmerged path fs/xfs/xfs_ialloc.c
diff --git a/fs/xfs/xfs_ialloc.h b/fs/xfs/xfs_ialloc.h
index 812365d17e67..95ad1c002d60 100644
--- a/fs/xfs/xfs_ialloc.h
+++ b/fs/xfs/xfs_ialloc.h
@@ -90,7 +90,7 @@ xfs_difree(
 	struct xfs_trans *tp,		/* transaction pointer */
 	xfs_ino_t	inode,		/* inode to be freed */
 	struct xfs_bmap_free *flist,	/* extents to free */
-	int		*delete,	/* set if inode cluster was deleted */
+	int		*deleted,	/* set if inode cluster was deleted */
 	xfs_ino_t	*first_ino);	/* first inode in deleted cluster */
 
 /*
