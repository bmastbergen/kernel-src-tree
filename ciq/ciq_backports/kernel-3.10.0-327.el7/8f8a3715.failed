netfilter: Pass nf_hook_state through ip6t_do_table().

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] netfilter: Pass nf_hook_state through ip6t_do_table() (Jiri Benc) [1230935]
Rebuild_FUZZ: 99.07%
commit-author David S. Miller <davem@davemloft.net>
commit 8f8a37152df49d541c43f010543f2b0176fcfb8e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/8f8a3715.failed

	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8f8a37152df49d541c43f010543f2b0176fcfb8e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/netfilter/ip6table_filter.c
#	net/ipv6/netfilter/ip6table_mangle.c
#	net/ipv6/netfilter/ip6table_nat.c
#	net/ipv6/netfilter/ip6table_raw.c
#	net/ipv6/netfilter/ip6table_security.c
diff --cc net/ipv6/netfilter/ip6table_filter.c
index 5b01a0323261,5c33d8abc077..000000000000
--- a/net/ipv6/netfilter/ip6table_filter.c
+++ b/net/ipv6/netfilter/ip6table_filter.c
@@@ -33,13 -33,11 +33,17 @@@ static const struct xt_table packet_fil
  /* The work comes in here from netfilter.c. */
  static unsigned int
  ip6table_filter_hook(const struct nf_hook_ops *ops, struct sk_buff *skb,
 -		     const struct nf_hook_state *state)
 +		     const struct net_device *in, const struct net_device *out,
 +		     int (*okfn)(struct sk_buff *))
  {
 -	const struct net *net = dev_net(state->in ? state->in : state->out);
 +	const struct net *net = dev_net((in != NULL) ? in : out);
  
++<<<<<<< HEAD
 +	return ip6t_do_table(skb, ops->hooknum, in, out,
 +			     net->ipv6.ip6table_filter);
++=======
+ 	return ip6t_do_table(skb, ops->hooknum, state, net->ipv6.ip6table_filter);
++>>>>>>> 8f8a37152df4 (netfilter: Pass nf_hook_state through ip6t_do_table().)
  }
  
  static struct nf_hook_ops *filter_ops __read_mostly;
diff --cc net/ipv6/netfilter/ip6table_mangle.c
index 69f4c438db26,b551f5b79fe2..000000000000
--- a/net/ipv6/netfilter/ip6table_mangle.c
+++ b/net/ipv6/netfilter/ip6table_mangle.c
@@@ -77,17 -77,16 +77,27 @@@ ip6t_mangle_out(struct sk_buff *skb, co
  /* The work comes in here from netfilter.c. */
  static unsigned int
  ip6table_mangle_hook(const struct nf_hook_ops *ops, struct sk_buff *skb,
 -		     const struct nf_hook_state *state)
 +		     const struct net_device *in, const struct net_device *out,
 +		     int (*okfn)(struct sk_buff *))
  {
  	if (ops->hooknum == NF_INET_LOCAL_OUT)
++<<<<<<< HEAD
 +		return ip6t_mangle_out(skb, out);
 +	if (ops->hooknum == NF_INET_POST_ROUTING)
 +		return ip6t_do_table(skb, ops->hooknum, in, out,
 +				     dev_net(out)->ipv6.ip6table_mangle);
 +	/* INPUT/FORWARD */
 +	return ip6t_do_table(skb, ops->hooknum, in, out,
 +			     dev_net(in)->ipv6.ip6table_mangle);
++=======
+ 		return ip6t_mangle_out(skb, state);
+ 	if (ops->hooknum == NF_INET_POST_ROUTING)
+ 		return ip6t_do_table(skb, ops->hooknum, state,
+ 				     dev_net(state->out)->ipv6.ip6table_mangle);
+ 	/* INPUT/FORWARD */
+ 	return ip6t_do_table(skb, ops->hooknum, state,
+ 			     dev_net(state->in)->ipv6.ip6table_mangle);
++>>>>>>> 8f8a37152df4 (netfilter: Pass nf_hook_state through ip6t_do_table().)
  }
  
  static struct nf_hook_ops *mangle_ops __read_mostly;
diff --cc net/ipv6/netfilter/ip6table_nat.c
index e85882144e52,c3a7f7af0ed4..000000000000
--- a/net/ipv6/netfilter/ip6table_nat.c
+++ b/net/ipv6/netfilter/ip6table_nat.c
@@@ -38,7 -37,7 +38,11 @@@ static unsigned int ip6table_nat_do_cha
  {
  	struct net *net = nf_ct_net(ct);
  
++<<<<<<< HEAD
 +	return ip6t_do_table(skb, ops->hooknum, in, out, net->ipv6.ip6table_nat);
++=======
+ 	return ip6t_do_table(skb, ops->hooknum, state, net->ipv6.ip6table_nat);
++>>>>>>> 8f8a37152df4 (netfilter: Pass nf_hook_state through ip6t_do_table().)
  }
  
  static unsigned int ip6table_nat_fn(const struct nf_hook_ops *ops,
diff --cc net/ipv6/netfilter/ip6table_raw.c
index 23c204b47df4,0b33caad2b69..000000000000
--- a/net/ipv6/netfilter/ip6table_raw.c
+++ b/net/ipv6/netfilter/ip6table_raw.c
@@@ -20,13 -20,11 +20,17 @@@ static const struct xt_table packet_ra
  /* The work comes in here from netfilter.c. */
  static unsigned int
  ip6table_raw_hook(const struct nf_hook_ops *ops, struct sk_buff *skb,
 -		  const struct nf_hook_state *state)
 +		  const struct net_device *in, const struct net_device *out,
 +		  int (*okfn)(struct sk_buff *))
  {
 -	const struct net *net = dev_net(state->in ? state->in : state->out);
 +	const struct net *net = dev_net((in != NULL) ? in : out);
  
++<<<<<<< HEAD
 +	return ip6t_do_table(skb, ops->hooknum, in, out,
 +			     net->ipv6.ip6table_raw);
++=======
+ 	return ip6t_do_table(skb, ops->hooknum, state, net->ipv6.ip6table_raw);
++>>>>>>> 8f8a37152df4 (netfilter: Pass nf_hook_state through ip6t_do_table().)
  }
  
  static struct nf_hook_ops *rawtable_ops __read_mostly;
diff --cc net/ipv6/netfilter/ip6table_security.c
index 15b8a0faac12,fcef83c25f7b..000000000000
--- a/net/ipv6/netfilter/ip6table_security.c
+++ b/net/ipv6/netfilter/ip6table_security.c
@@@ -37,13 -37,11 +37,17 @@@ static const struct xt_table security_t
  
  static unsigned int
  ip6table_security_hook(const struct nf_hook_ops *ops, struct sk_buff *skb,
 -		       const struct nf_hook_state *state)
 +		       const struct net_device *in,
 +		       const struct net_device *out,
 +		       int (*okfn)(struct sk_buff *))
  {
 -	const struct net *net = dev_net(state->in ? state->in : state->out);
 +	const struct net *net = dev_net((in != NULL) ? in : out);
  
++<<<<<<< HEAD
 +	return ip6t_do_table(skb, ops->hooknum, in, out,
++=======
+ 	return ip6t_do_table(skb, ops->hooknum, state,
++>>>>>>> 8f8a37152df4 (netfilter: Pass nf_hook_state through ip6t_do_table().)
  			     net->ipv6.ip6table_security);
  }
  
diff --git a/include/linux/netfilter_ipv6/ip6_tables.h b/include/linux/netfilter_ipv6/ip6_tables.h
index 610208b18c05..b40d2b635778 100644
--- a/include/linux/netfilter_ipv6/ip6_tables.h
+++ b/include/linux/netfilter_ipv6/ip6_tables.h
@@ -31,8 +31,7 @@ extern struct xt_table *ip6t_register_table(struct net *net,
 extern void ip6t_unregister_table(struct net *net, struct xt_table *table);
 extern unsigned int ip6t_do_table(struct sk_buff *skb,
 				  unsigned int hook,
-				  const struct net_device *in,
-				  const struct net_device *out,
+				  const struct nf_hook_state *state,
 				  struct xt_table *table);
 
 /* Check for an extension */
diff --git a/net/ipv6/netfilter/ip6_tables.c b/net/ipv6/netfilter/ip6_tables.c
index 61593358710e..4e3940038e99 100644
--- a/net/ipv6/netfilter/ip6_tables.c
+++ b/net/ipv6/netfilter/ip6_tables.c
@@ -312,8 +312,7 @@ ip6t_next_entry(const struct ip6t_entry *entry)
 unsigned int
 ip6t_do_table(struct sk_buff *skb,
 	      unsigned int hook,
-	      const struct net_device *in,
-	      const struct net_device *out,
+	      const struct nf_hook_state *state,
 	      struct xt_table *table)
 {
 	static const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));
@@ -328,8 +327,8 @@ ip6t_do_table(struct sk_buff *skb,
 	unsigned int addend;
 
 	/* Initialization */
-	indev = in ? in->name : nulldevname;
-	outdev = out ? out->name : nulldevname;
+	indev = state->in ? state->in->name : nulldevname;
+	outdev = state->out ? state->out->name : nulldevname;
 	/* We handle fragments by dealing with the first fragment as
 	 * if it was a normal packet.  All other fragments are treated
 	 * normally, except that they will NEVER match rules that ask
@@ -337,8 +336,8 @@ ip6t_do_table(struct sk_buff *skb,
 	 * rule is also a fragment-specific rule, non-fragments won't
 	 * match it. */
 	acpar.hotdrop = false;
-	acpar.in      = in;
-	acpar.out     = out;
+	acpar.in      = state->in;
+	acpar.out     = state->out;
 	acpar.family  = NFPROTO_IPV6;
 	acpar.hooknum = hook;
 
@@ -390,7 +389,7 @@ ip6t_do_table(struct sk_buff *skb,
 #if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)
 		/* The packet is traced: log it */
 		if (unlikely(skb->nf_trace))
-			trace_packet(skb, hook, in, out,
+			trace_packet(skb, hook, state->in, state->out,
 				     table->name, private, e);
 #endif
 		/* Standard target? */
* Unmerged path net/ipv6/netfilter/ip6table_filter.c
* Unmerged path net/ipv6/netfilter/ip6table_mangle.c
* Unmerged path net/ipv6/netfilter/ip6table_nat.c
* Unmerged path net/ipv6/netfilter/ip6table_raw.c
* Unmerged path net/ipv6/netfilter/ip6table_security.c
