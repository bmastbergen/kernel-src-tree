net: unify the pcpu_tstats and br_cpu_netstats as one

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] unify the pcpu_tstats and br_cpu_netstats as one (Marcelo Leitner) [1206570]
Rebuild_FUZZ: 95.05%
commit-author Li RongQing <roy.qing.li@gmail.com>
commit 8f84985fec10de64a6b4cdfea45f2b0ab8f07c78
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/8f84985f.failed

They are same, so unify them as one, pcpu_sw_netstats.

Define pcpu_sw_netstat in netdevice.h, remove pcpu_tstats
from if_tunnel and remove br_cpu_netstats from br_private.h

	Cc: Cong Wang <xiyou.wangcong@gmail.com>
	Cc: Stephen Hemminger <stephen@networkplumber.org>
	Signed-off-by: Li RongQing <roy.qing.li@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8f84985fec10de64a6b4cdfea45f2b0ab8f07c78)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
#	include/linux/netdevice.h
#	net/bridge/br_device.c
#	net/bridge/br_input.c
#	net/ipv4/ip_tunnel.c
#	net/ipv4/ip_vti.c
#	net/ipv6/ip6_gre.c
#	net/ipv6/ip6_tunnel.c
#	net/ipv6/ip6_vti.c
#	net/ipv6/sit.c
#	net/openvswitch/vport.c
diff --cc drivers/net/vxlan.c
index 1f7710467383,474a99ed0222..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1669,13 -1587,12 +1669,14 @@@ EXPORT_SYMBOL_GPL(vxlan_xmit_skb)
  static void vxlan_encap_bypass(struct sk_buff *skb, struct vxlan_dev *src_vxlan,
  			       struct vxlan_dev *dst_vxlan)
  {
- 	struct pcpu_tstats *tx_stats = this_cpu_ptr(src_vxlan->dev->tstats);
- 	struct pcpu_tstats *rx_stats = this_cpu_ptr(dst_vxlan->dev->tstats);
+ 	struct pcpu_sw_netstats *tx_stats, *rx_stats;
  	union vxlan_addr loopback;
  	union vxlan_addr *remote_ip = &dst_vxlan->default_dst.remote_ip;
 +	struct net_device *dev = skb->dev;
 +	int len = skb->len;
  
+ 	tx_stats = this_cpu_ptr(src_vxlan->dev->tstats);
+ 	rx_stats = this_cpu_ptr(dst_vxlan->dev->tstats);
  	skb->pkt_type = PACKET_HOST;
  	skb->encapsulation = 0;
  	skb->dev = dst_vxlan->dev;
@@@ -1991,17 -1896,24 +1992,27 @@@ static int vxlan_init(struct net_devic
  	struct vxlan_dev *vxlan = netdev_priv(dev);
  	struct vxlan_net *vn = net_generic(dev_net(dev), vxlan_net_id);
  	struct vxlan_sock *vs;
 -	int i;
 +	bool ipv6 = vxlan->flags & VXLAN_F_IPV6;
  
- 	dev->tstats = alloc_percpu(struct pcpu_tstats);
+ 	dev->tstats = alloc_percpu(struct pcpu_sw_netstats);
  	if (!dev->tstats)
  		return -ENOMEM;
  
++<<<<<<< HEAD
++=======
+ 	for_each_possible_cpu(i) {
+ 		struct pcpu_sw_netstats *vxlan_stats;
+ 		vxlan_stats = per_cpu_ptr(dev->tstats, i);
+ 		u64_stats_init(&vxlan_stats->syncp);
+ 	}
+ 
+ 
++>>>>>>> 8f84985fec10 (net: unify the pcpu_tstats and br_cpu_netstats as one)
  	spin_lock(&vn->sock_lock);
 -	vs = vxlan_find_sock(dev_net(dev), vxlan->dst_port);
 -	if (vs) {
 +	vs = vxlan_find_sock(dev_net(dev), ipv6 ? AF_INET6 : AF_INET,
 +			     vxlan->dst_port);
 +	if (vs && atomic_add_unless(&vs->refcnt, 1, 0)) {
  		/* If we have a socket with same port already, reuse it */
 -		atomic_inc(&vs->refcnt);
  		vxlan_vs_add_dev(vs, vxlan);
  	} else {
  		/* otherwise make new socket outside of RTNL */
diff --cc include/linux/netdevice.h
index d77c2cff9dff,51c0fe258163..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -1706,26 -1685,15 +1706,38 @@@ struct packet_offload 
  	struct list_head	 list;
  };
  
++<<<<<<< HEAD
 +struct udp_offload {
 +	__be16			 port;
 +	u8			 ipproto;
 +	struct offload_callbacks callbacks;
 +};
 +
 +#define netdev_alloc_pcpu_stats(type)				\
 +({								\
 +	typeof(type) *pcpu_stats = alloc_percpu(type);		\
 +	if (pcpu_stats)	{					\
 +		int i;						\
 +		for_each_possible_cpu(i) {			\
 +			typeof(type) *stat;			\
 +			stat = per_cpu_ptr(pcpu_stats, i);	\
 +			u64_stats_init(&stat->syncp);		\
 +		}						\
 +	}							\
 +	pcpu_stats;						\
 +})
 +
++=======
+ /* often modified stats are per cpu, other are shared (netdev->stats) */
+ struct pcpu_sw_netstats {
+ 	u64     rx_packets;
+ 	u64     rx_bytes;
+ 	u64     tx_packets;
+ 	u64     tx_bytes;
+ 	struct u64_stats_sync   syncp;
+ };
+ 
++>>>>>>> 8f84985fec10 (net: unify the pcpu_tstats and br_cpu_netstats as one)
  #include <linux/notifier.h>
  
  /* netdevice notifier chain. Please remember to update the rtnetlink
diff --cc net/bridge/br_device.c
index 52d8aa4dd781,e4401a531afb..000000000000
--- a/net/bridge/br_device.c
+++ b/net/bridge/br_device.c
@@@ -88,17 -88,19 +88,25 @@@ out
  static int br_dev_init(struct net_device *dev)
  {
  	struct net_bridge *br = netdev_priv(dev);
 -	int i;
 +	int err;
  
- 	br->stats = alloc_percpu(struct br_cpu_netstats);
+ 	br->stats = alloc_percpu(struct pcpu_sw_netstats);
  	if (!br->stats)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	err = br_vlan_init(br);
 +	if (err)
 +		free_percpu(br->stats);
++=======
+ 	for_each_possible_cpu(i) {
+ 		struct pcpu_sw_netstats *br_dev_stats;
+ 		br_dev_stats = per_cpu_ptr(br->stats, i);
+ 		u64_stats_init(&br_dev_stats->syncp);
+ 	}
++>>>>>>> 8f84985fec10 (net: unify the pcpu_tstats and br_cpu_netstats as one)
  
 -	return 0;
 +	return err;
  }
  
  static int br_dev_open(struct net_device *dev)
diff --cc net/bridge/br_input.c
index cf29b38b3b0c,bf8dc7d308d6..000000000000
--- a/net/bridge/br_input.c
+++ b/net/bridge/br_input.c
@@@ -28,8 -28,7 +28,12 @@@ static int br_pass_frame_up(struct sk_b
  {
  	struct net_device *indev, *brdev = BR_INPUT_SKB_CB(skb)->brdev;
  	struct net_bridge *br = netdev_priv(brdev);
++<<<<<<< HEAD
 +	struct br_cpu_netstats *brstats = this_cpu_ptr(br->stats);
 +	struct net_port_vlans *pv;
++=======
+ 	struct pcpu_sw_netstats *brstats = this_cpu_ptr(br->stats);
++>>>>>>> 8f84985fec10 (net: unify the pcpu_tstats and br_cpu_netstats as one)
  
  	u64_stats_update_begin(&brstats->syncp);
  	brstats->rx_packets++;
diff --cc net/ipv4/ip_tunnel.c
index 1129aec53c2c,07a5ed374262..000000000000
--- a/net/ipv4/ip_tunnel.c
+++ b/net/ipv4/ip_tunnel.c
@@@ -1000,15 -1047,34 +1001,36 @@@ int ip_tunnel_init(struct net_device *d
  {
  	struct ip_tunnel *tunnel = netdev_priv(dev);
  	struct iphdr *iph = &tunnel->parms.iph;
 -	int i, err;
 +	int err;
  
  	dev->destructor	= ip_tunnel_dev_free;
- 	dev->tstats = alloc_percpu(struct pcpu_tstats);
+ 	dev->tstats = alloc_percpu(struct pcpu_sw_netstats);
  	if (!dev->tstats)
  		return -ENOMEM;
  
++<<<<<<< HEAD
++=======
+ 	for_each_possible_cpu(i) {
+ 		struct pcpu_sw_netstats *ipt_stats;
+ 		ipt_stats = per_cpu_ptr(dev->tstats, i);
+ 		u64_stats_init(&ipt_stats->syncp);
+ 	}
+ 
+ 	tunnel->dst_cache = alloc_percpu(struct ip_tunnel_dst);
+ 	if (!tunnel->dst_cache) {
+ 		free_percpu(dev->tstats);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	for_each_possible_cpu(i) {
+ 		struct ip_tunnel_dst *idst = per_cpu_ptr(tunnel->dst_cache, i);
+ 		idst-> dst = NULL;
+ 		spin_lock_init(&idst->lock);
+ 	}
+ 
++>>>>>>> 8f84985fec10 (net: unify the pcpu_tstats and br_cpu_netstats as one)
  	err = gro_cells_init(&tunnel->gro_cells, dev);
  	if (err) {
 -		free_percpu(tunnel->dst_cache);
  		free_percpu(dev->tstats);
  		return err;
  	}
diff --cc net/ipv4/ip_vti.c
index b9997c5dcf18,0783200ad8d2..000000000000
--- a/net/ipv4/ip_vti.c
+++ b/net/ipv4/ip_vti.c
@@@ -61,106 -60,63 +61,112 @@@ static int vti_input(struct sk_buff *sk
  	tunnel = ip_tunnel_lookup(itn, skb->dev->ifindex, TUNNEL_NO_KEY,
  				  iph->saddr, iph->daddr, 0);
  	if (tunnel != NULL) {
++<<<<<<< HEAD
 +		if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))
 +			goto drop;
++=======
+ 		struct pcpu_sw_netstats *tstats;
+ 		u32 oldmark = skb->mark;
+ 		int ret;
++>>>>>>> 8f84985fec10 (net: unify the pcpu_tstats and br_cpu_netstats as one)
  
 +		XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4 = tunnel;
 +		skb->mark = be32_to_cpu(tunnel->parms.i_key);
  
 -		/* temporarily mark the skb with the tunnel o_key, to
 -		 * only match policies with this mark.
 -		 */
 -		skb->mark = be32_to_cpu(tunnel->parms.o_key);
 -		ret = xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb);
 -		skb->mark = oldmark;
 -		if (!ret)
 -			return -1;
 +		return xfrm_input(skb, nexthdr, spi, encap_type);
 +	}
  
 -		tstats = this_cpu_ptr(tunnel->dev->tstats);
 -		u64_stats_update_begin(&tstats->syncp);
 -		tstats->rx_packets++;
 -		tstats->rx_bytes += skb->len;
 -		u64_stats_update_end(&tstats->syncp);
 +	return -EINVAL;
 +drop:
 +	kfree_skb(skb);
 +	return 0;
 +}
 +
 +static int vti_rcv(struct sk_buff *skb)
 +{
 +	XFRM_SPI_SKB_CB(skb)->family = AF_INET;
 +	XFRM_SPI_SKB_CB(skb)->daddroff = offsetof(struct iphdr, daddr);
  
 -		secpath_reset(skb);
 -		skb->dev = tunnel->dev;
 +	return vti_input(skb, ip_hdr(skb)->protocol, 0, 0);
 +}
 +
 +static int vti_rcv_cb(struct sk_buff *skb, int err)
 +{
 +	unsigned short family;
 +	struct net_device *dev;
 +	struct pcpu_tstats *tstats;
 +	struct xfrm_state *x;
 +	struct ip_tunnel *tunnel = XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4;
 +
 +	if (!tunnel)
  		return 1;
 +
 +	dev = tunnel->dev;
 +
 +	if (err) {
 +		dev->stats.rx_errors++;
 +		dev->stats.rx_dropped++;
 +
 +		return 0;
  	}
  
 -	return -1;
 +	x = xfrm_input_state(skb);
 +	family = x->inner_mode->afinfo->family;
 +
 +	if (!xfrm_policy_check(NULL, XFRM_POLICY_IN, skb, family))
 +		return -EPERM;
 +
 +	skb_scrub_packet(skb, !net_eq(tunnel->net, dev_net(skb->dev)));
 +	skb->dev = dev;
 +
 +	tstats = this_cpu_ptr(dev->tstats);
 +
 +	u64_stats_update_begin(&tstats->syncp);
 +	tstats->rx_packets++;
 +	tstats->rx_bytes += skb->len;
 +	u64_stats_update_end(&tstats->syncp);
 +
 +	return 0;
  }
  
 -/* This function assumes it is being called from dev_queue_xmit()
 - * and that skb is filled properly by that function.
 - */
 +static bool vti_state_check(const struct xfrm_state *x, __be32 dst, __be32 src)
 +{
 +	xfrm_address_t *daddr = (xfrm_address_t *)&dst;
 +	xfrm_address_t *saddr = (xfrm_address_t *)&src;
  
 -static netdev_tx_t vti_tunnel_xmit(struct sk_buff *skb, struct net_device *dev)
 +	/* if there is no transform then this tunnel is not functional.
 +	 * Or if the xfrm is not mode tunnel.
 +	 */
 +	if (!x || x->props.mode != XFRM_MODE_TUNNEL ||
 +	    x->props.family != AF_INET)
 +		return false;
 +
 +	if (!dst)
 +		return xfrm_addr_equal(saddr, &x->props.saddr, AF_INET);
 +
 +	if (!xfrm_state_addr_check(x, daddr, saddr, AF_INET))
 +		return false;
 +
 +	return true;
 +}
 +
 +static netdev_tx_t vti_xmit(struct sk_buff *skb, struct net_device *dev,
 +			    struct flowi *fl)
  {
  	struct ip_tunnel *tunnel = netdev_priv(dev);
 -	struct iphdr  *tiph = &tunnel->parms.iph;
 -	u8     tos;
 -	struct rtable *rt;		/* Route to the other host */
 +	struct ip_tunnel_parm *parms = &tunnel->parms;
 +	struct dst_entry *dst = skb_dst(skb);
  	struct net_device *tdev;	/* Device to other host */
 -	struct iphdr  *old_iph = ip_hdr(skb);
 -	__be32 dst = tiph->daddr;
 -	struct flowi4 fl4;
  	int err;
  
 -	if (skb->protocol != htons(ETH_P_IP))
 -		goto tx_error;
 -
 -	tos = old_iph->tos;
 +	if (!dst) {
 +		dev->stats.tx_carrier_errors++;
 +		goto tx_error_icmp;
 +	}
  
 -	memset(&fl4, 0, sizeof(fl4));
 -	flowi4_init_output(&fl4, tunnel->parms.link,
 -			   be32_to_cpu(tunnel->parms.o_key), RT_TOS(tos),
 -			   RT_SCOPE_UNIVERSE,
 -			   IPPROTO_IPIP, 0,
 -			   dst, tiph->saddr, 0, 0);
 -	rt = ip_route_output_key(dev_net(dev), &fl4);
 -	if (IS_ERR(rt)) {
 +	dst_hold(dst);
 +	dst = xfrm_lookup(tunnel->net, dst, fl, NULL, 0);
 +	if (IS_ERR(dst)) {
  		dev->stats.tx_carrier_errors++;
  		goto tx_error_icmp;
  	}
diff --cc net/ipv6/ip6_gre.c
index 06aadf812d65,e7a440dd5c0d..000000000000
--- a/net/ipv6/ip6_gre.c
+++ b/net/ipv6/ip6_gre.c
@@@ -1267,6 -1269,13 +1267,16 @@@ static int ip6gre_tunnel_init(struct ne
  	if (!dev->tstats)
  		return -ENOMEM;
  
++<<<<<<< HEAD
++=======
+ 	for_each_possible_cpu(i) {
+ 		struct pcpu_sw_netstats *ip6gre_tunnel_stats;
+ 		ip6gre_tunnel_stats = per_cpu_ptr(dev->tstats, i);
+ 		u64_stats_init(&ip6gre_tunnel_stats->syncp);
+ 	}
+ 
+ 
++>>>>>>> 8f84985fec10 (net: unify the pcpu_tstats and br_cpu_netstats as one)
  	return 0;
  }
  
@@@ -1474,6 -1470,12 +1484,15 @@@ static int ip6gre_tap_init(struct net_d
  	if (!dev->tstats)
  		return -ENOMEM;
  
++<<<<<<< HEAD
++=======
+ 	for_each_possible_cpu(i) {
+ 		struct pcpu_sw_netstats *ip6gre_tap_stats;
+ 		ip6gre_tap_stats = per_cpu_ptr(dev->tstats, i);
+ 		u64_stats_init(&ip6gre_tap_stats->syncp);
+ 	}
+ 
++>>>>>>> 8f84985fec10 (net: unify the pcpu_tstats and br_cpu_netstats as one)
  	return 0;
  }
  
diff --cc net/ipv6/ip6_tunnel.c
index 3e2a790fd5f7,02894216a46d..000000000000
--- a/net/ipv6/ip6_tunnel.c
+++ b/net/ipv6/ip6_tunnel.c
@@@ -102,25 -101,17 +101,34 @@@ struct ip6_tnl_net 
  
  static struct net_device_stats *ip6_get_stats(struct net_device *dev)
  {
++<<<<<<< HEAD
 +	struct pcpu_tstats tmp, sum = { 0 };
 +	int i;
 +
 +	for_each_possible_cpu(i) {
 +		unsigned int start;
 +		const struct pcpu_tstats *tstats = per_cpu_ptr(dev->tstats, i);
++=======
+ 	struct pcpu_sw_netstats sum = { 0 };
+ 	int i;
+ 
+ 	for_each_possible_cpu(i) {
+ 		const struct pcpu_sw_netstats *tstats =
+ 						   per_cpu_ptr(dev->tstats, i);
 -
 -		sum.rx_packets += tstats->rx_packets;
 -		sum.rx_bytes   += tstats->rx_bytes;
 -		sum.tx_packets += tstats->tx_packets;
 -		sum.tx_bytes   += tstats->tx_bytes;
++>>>>>>> 8f84985fec10 (net: unify the pcpu_tstats and br_cpu_netstats as one)
 +
 +		do {
 +			start = u64_stats_fetch_begin_bh(&tstats->syncp);
 +			tmp.rx_packets = tstats->rx_packets;
 +			tmp.rx_bytes = tstats->rx_bytes;
 +			tmp.tx_packets = tstats->tx_packets;
 +			tmp.tx_bytes =  tstats->tx_bytes;
 +		} while (u64_stats_fetch_retry_bh(&tstats->syncp, start));
 +
 +		sum.rx_packets += tmp.rx_packets;
 +		sum.rx_bytes   += tmp.rx_bytes;
 +		sum.tx_packets += tmp.tx_packets;
 +		sum.tx_bytes   += tmp.tx_bytes;
  	}
  	dev->stats.rx_packets = sum.rx_packets;
  	dev->stats.rx_bytes   = sum.rx_bytes;
@@@ -814,10 -784,9 +822,10 @@@ static int ip6_tnl_rcv(struct sk_buff *
  
  	if ((t = ip6_tnl_lookup(dev_net(skb->dev), &ipv6h->saddr,
  					&ipv6h->daddr)) != NULL) {
- 		struct pcpu_tstats *tstats;
+ 		struct pcpu_sw_netstats *tstats;
  
 -		if (t->parms.proto != ipproto && t->parms.proto != 0) {
 +		tproto = ACCESS_ONCE(t->parms.proto);
 +		if (tproto != ipproto && tproto != 0) {
  			rcu_read_unlock();
  			goto discard;
  		}
@@@ -1574,9 -1496,16 +1582,18 @@@ ip6_tnl_dev_init_gen(struct net_device 
  
  	t->dev = dev;
  	t->net = dev_net(dev);
- 	dev->tstats = alloc_percpu(struct pcpu_tstats);
+ 	dev->tstats = alloc_percpu(struct pcpu_sw_netstats);
  	if (!dev->tstats)
  		return -ENOMEM;
++<<<<<<< HEAD
++=======
+ 
+ 	for_each_possible_cpu(i) {
+ 		struct pcpu_sw_netstats *ip6_tnl_stats;
+ 		ip6_tnl_stats = per_cpu_ptr(dev->tstats, i);
+ 		u64_stats_init(&ip6_tnl_stats->syncp);
+ 	}
++>>>>>>> 8f84985fec10 (net: unify the pcpu_tstats and br_cpu_netstats as one)
  	return 0;
  }
  
diff --cc net/ipv6/ip6_vti.c
index a4564b05c47b,da1d9e4d62ca..000000000000
--- a/net/ipv6/ip6_vti.c
+++ b/net/ipv6/ip6_vti.c
@@@ -75,6 -74,27 +74,30 @@@ struct vti6_net 
  	struct ip6_tnl __rcu **tnls[2];
  };
  
++<<<<<<< HEAD
++=======
+ static struct net_device_stats *vti6_get_stats(struct net_device *dev)
+ {
+ 	struct pcpu_sw_netstats sum = { 0 };
+ 	int i;
+ 
+ 	for_each_possible_cpu(i) {
+ 		const struct pcpu_sw_netstats *tstats =
+ 						   per_cpu_ptr(dev->tstats, i);
+ 
+ 		sum.rx_packets += tstats->rx_packets;
+ 		sum.rx_bytes   += tstats->rx_bytes;
+ 		sum.tx_packets += tstats->tx_packets;
+ 		sum.tx_bytes   += tstats->tx_bytes;
+ 	}
+ 	dev->stats.rx_packets = sum.rx_packets;
+ 	dev->stats.rx_bytes   = sum.rx_bytes;
+ 	dev->stats.tx_packets = sum.tx_packets;
+ 	dev->stats.tx_bytes   = sum.tx_bytes;
+ 	return &dev->stats;
+ }
+ 
++>>>>>>> 8f84985fec10 (net: unify the pcpu_tstats and br_cpu_netstats as one)
  #define for_each_vti6_tunnel_rcu(start) \
  	for (t = rcu_dereference(start); t; t = rcu_dereference(t->next))
  
diff --cc net/ipv6/sit.c
index 0bf8881a52b0,9937b2616713..000000000000
--- a/net/ipv6/sit.c
+++ b/net/ipv6/sit.c
@@@ -1291,6 -1365,12 +1291,15 @@@ static int ipip6_tunnel_init(struct net
  	if (!dev->tstats)
  		return -ENOMEM;
  
++<<<<<<< HEAD
++=======
+ 	for_each_possible_cpu(i) {
+ 		struct pcpu_sw_netstats *ipip6_tunnel_stats;
+ 		ipip6_tunnel_stats = per_cpu_ptr(dev->tstats, i);
+ 		u64_stats_init(&ipip6_tunnel_stats->syncp);
+ 	}
+ 
++>>>>>>> 8f84985fec10 (net: unify the pcpu_tstats and br_cpu_netstats as one)
  	return 0;
  }
  
@@@ -1310,9 -1391,16 +1319,19 @@@ static int __net_init ipip6_fb_tunnel_i
  	iph->ihl		= 5;
  	iph->ttl		= 64;
  
- 	dev->tstats = alloc_percpu(struct pcpu_tstats);
+ 	dev->tstats = alloc_percpu(struct pcpu_sw_netstats);
  	if (!dev->tstats)
  		return -ENOMEM;
++<<<<<<< HEAD
++=======
+ 
+ 	for_each_possible_cpu(i) {
+ 		struct pcpu_sw_netstats *ipip6_fb_stats;
+ 		ipip6_fb_stats = per_cpu_ptr(dev->tstats, i);
+ 		u64_stats_init(&ipip6_fb_stats->syncp);
+ 	}
+ 
++>>>>>>> 8f84985fec10 (net: unify the pcpu_tstats and br_cpu_netstats as one)
  	dev_hold(dev);
  	rcu_assign_pointer(sitn->tunnels_wc[0], tunnel);
  	return 0;
diff --cc net/openvswitch/vport.c
index 3dc860858021,f5275dd29cd9..000000000000
--- a/net/openvswitch/vport.c
+++ b/net/openvswitch/vport.c
@@@ -137,17 -135,22 +137,33 @@@ struct vport *ovs_vport_alloc(int priv_
  	vport->ops = ops;
  	INIT_HLIST_NODE(&vport->dp_hash_node);
  
++<<<<<<< HEAD
 +	if (ovs_vport_set_upcall_portids(vport, parms->upcall_portids)) {
 +		kfree(vport);
 +		return ERR_PTR(-EINVAL);
 +	}
 +
 +	vport->percpu_stats = alloc_percpu(struct pcpu_tstats);
++=======
+ 	vport->percpu_stats = alloc_percpu(struct pcpu_sw_netstats);
++>>>>>>> 8f84985fec10 (net: unify the pcpu_tstats and br_cpu_netstats as one)
  	if (!vport->percpu_stats) {
  		kfree(vport);
  		return ERR_PTR(-ENOMEM);
  	}
  
++<<<<<<< HEAD
++=======
+ 	for_each_possible_cpu(i) {
+ 		struct pcpu_sw_netstats *vport_stats;
+ 		vport_stats = per_cpu_ptr(vport->percpu_stats, i);
+ 		u64_stats_init(&vport_stats->syncp);
+ 	}
+ 
+ 
+ 	spin_lock_init(&vport->stats_lock);
+ 
++>>>>>>> 8f84985fec10 (net: unify the pcpu_tstats and br_cpu_netstats as one)
  	return vport;
  }
  
@@@ -266,14 -265,18 +282,14 @@@ void ovs_vport_get_stats(struct vport *
  	 * netdev-stats can be directly read over netlink-ioctl.
  	 */
  
 -	spin_lock_bh(&vport->stats_lock);
 -
 -	stats->rx_errors	= vport->err_stats.rx_errors;
 -	stats->tx_errors	= vport->err_stats.tx_errors;
 -	stats->tx_dropped	= vport->err_stats.tx_dropped;
 -	stats->rx_dropped	= vport->err_stats.rx_dropped;
 -
 -	spin_unlock_bh(&vport->stats_lock);
 +	stats->rx_errors  = atomic_long_read(&vport->err_stats.rx_errors);
 +	stats->tx_errors  = atomic_long_read(&vport->err_stats.tx_errors);
 +	stats->tx_dropped = atomic_long_read(&vport->err_stats.tx_dropped);
 +	stats->rx_dropped = atomic_long_read(&vport->err_stats.rx_dropped);
  
  	for_each_possible_cpu(i) {
- 		const struct pcpu_tstats *percpu_stats;
- 		struct pcpu_tstats local_stats;
+ 		const struct pcpu_sw_netstats *percpu_stats;
+ 		struct pcpu_sw_netstats local_stats;
  		unsigned int start;
  
  		percpu_stats = per_cpu_ptr(vport->percpu_stats, i);
@@@ -434,9 -344,7 +450,13 @@@ u32 ovs_vport_find_upcall_portid(const 
  void ovs_vport_receive(struct vport *vport, struct sk_buff *skb,
  		       struct ovs_key_ipv4_tunnel *tun_key)
  {
++<<<<<<< HEAD
 +	struct pcpu_tstats *stats;
 +	struct sw_flow_key key;
 +	int error;
++=======
+ 	struct pcpu_sw_netstats *stats;
++>>>>>>> 8f84985fec10 (net: unify the pcpu_tstats and br_cpu_netstats as one)
  
  	stats = this_cpu_ptr(vport->percpu_stats);
  	u64_stats_update_begin(&stats->syncp);
* Unmerged path drivers/net/vxlan.c
diff --git a/include/linux/if_tunnel.h b/include/linux/if_tunnel.h
index f4e56ecd0b1a..712710bc0580 100644
--- a/include/linux/if_tunnel.h
+++ b/include/linux/if_tunnel.h
@@ -13,13 +13,4 @@
 #define for_each_ip_tunnel_rcu(pos, start) \
 	for (pos = rcu_dereference(start); pos; pos = rcu_dereference(pos->next))
 
-/* often modified stats are per cpu, other are shared (netdev->stats) */
-struct pcpu_tstats {
-	u64	rx_packets;
-	u64	rx_bytes;
-	u64	tx_packets;
-	u64	tx_bytes;
-	struct u64_stats_sync	syncp;
-};
-
 #endif /* _IF_TUNNEL_H_ */
* Unmerged path include/linux/netdevice.h
diff --git a/include/net/ip6_tunnel.h b/include/net/ip6_tunnel.h
index 2265b0bf97e5..1a7957396276 100644
--- a/include/net/ip6_tunnel.h
+++ b/include/net/ip6_tunnel.h
@@ -80,7 +80,7 @@ static inline void ip6tunnel_xmit(struct sk_buff *skb, struct net_device *dev)
 	err = ip6_local_out(skb);
 
 	if (net_xmit_eval(err) == 0) {
-		struct pcpu_tstats *tstats = this_cpu_ptr(dev->tstats);
+		struct pcpu_sw_netstats *tstats = this_cpu_ptr(dev->tstats);
 		u64_stats_update_begin(&tstats->syncp);
 		tstats->tx_bytes += pkt_len;
 		tstats->tx_packets++;
diff --git a/include/net/ip_tunnels.h b/include/net/ip_tunnels.h
index 8d95b01ba42b..74330cde4ae2 100644
--- a/include/net/ip_tunnels.h
+++ b/include/net/ip_tunnels.h
@@ -167,10 +167,10 @@ struct sk_buff *iptunnel_handle_offloads(struct sk_buff *skb, bool gre_csum,
 
 static inline void iptunnel_xmit_stats(int err,
 				       struct net_device_stats *err_stats,
-				       struct pcpu_tstats __percpu *stats)
+				       struct pcpu_sw_netstats __percpu *stats)
 {
 	if (err > 0) {
-		struct pcpu_tstats *tstats = this_cpu_ptr(stats);
+		struct pcpu_sw_netstats *tstats = this_cpu_ptr(stats);
 
 		u64_stats_update_begin(&tstats->syncp);
 		tstats->tx_bytes += err;
* Unmerged path net/bridge/br_device.c
* Unmerged path net/bridge/br_input.c
diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index fe99f0095976..205af04b0c10 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -216,21 +216,13 @@ static inline struct net_bridge_port *br_port_get_rtnl(const struct net_device *
 		rtnl_dereference(dev->rx_handler_data) : NULL;
 }
 
-struct br_cpu_netstats {
-	u64			rx_packets;
-	u64			rx_bytes;
-	u64			tx_packets;
-	u64			tx_bytes;
-	struct u64_stats_sync	syncp;
-};
-
 struct net_bridge
 {
 	spinlock_t			lock;
 	struct list_head		port_list;
 	struct net_device		*dev;
 
-	struct br_cpu_netstats __percpu *stats;
+	struct pcpu_sw_netstats		__percpu *stats;
 	spinlock_t			hash_lock;
 	struct hlist_head		hash[BR_HASH_SIZE];
 #ifdef CONFIG_BRIDGE_NETFILTER
* Unmerged path net/ipv4/ip_tunnel.c
* Unmerged path net/ipv4/ip_vti.c
* Unmerged path net/ipv6/ip6_gre.c
* Unmerged path net/ipv6/ip6_tunnel.c
* Unmerged path net/ipv6/ip6_vti.c
* Unmerged path net/ipv6/sit.c
* Unmerged path net/openvswitch/vport.c
diff --git a/net/openvswitch/vport.h b/net/openvswitch/vport.h
index 278161514a44..4d453f0692d4 100644
--- a/net/openvswitch/vport.h
+++ b/net/openvswitch/vport.h
@@ -105,7 +105,7 @@ struct vport {
 	struct hlist_node dp_hash_node;
 	const struct vport_ops *ops;
 
-	struct pcpu_tstats __percpu *percpu_stats;
+	struct pcpu_sw_netstats __percpu *percpu_stats;
 
 	struct vport_err_stats err_stats;
 	struct list_head detach_list;
