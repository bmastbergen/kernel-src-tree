powerpc/eeh: Dump PHB diag-data early

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [powerpc] eeh: Dump PHB diag-data early (Laurent Vivier) [1213675]
Rebuild_FUZZ: 87.88%
commit-author Gavin Shan <gwshan@linux.vnet.ibm.com>
commit a450e8f55a57d049ac3afe218f06567e12d6b4f5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/a450e8f5.failed

On PowerNV platform, PHB diag-data is dumped after stopping device
drivers. In case of recursive EEH errors, the kernel is usually
crashed before dumping PHB diag-data for the second EEH error. It's
hard to locate the root cause of the second EEH error without PHB
diag-data.

The patch adds one more EEH option "eeh=early_log", which helps
dumping PHB diag-data immediately once frozen PE is detected, in
order to get the PHB diag-data for the second EEH error.

	Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
	Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
(cherry picked from commit a450e8f55a57d049ac3afe218f06567e12d6b4f5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/eeh.h
#	arch/powerpc/kernel/eeh.c
#	arch/powerpc/platforms/powernv/eeh-ioda.c
diff --cc arch/powerpc/include/asm/eeh.h
index 52bd2259c082,0652ebe117af..000000000000
--- a/arch/powerpc/include/asm/eeh.h
+++ b/arch/powerpc/include/asm/eeh.h
@@@ -36,10 -34,12 +36,19 @@@ struct device_node
  #ifdef CONFIG_EEH
  
  /* EEH subsystem flags */
++<<<<<<< HEAD
 +#define EEH_ENABLED		0x1	/* EEH enabled		*/
 +#define EEH_FORCE_DISABLED	0x2	/* EEH disabled		*/
 +#define EEH_PROBE_MODE_DEV	0x4	/* From PCI device	*/
 +#define EEH_PROBE_MODE_DEVTREE	0x8	/* From device tree	*/
++=======
+ #define EEH_ENABLED		0x01	/* EEH enabled		*/
+ #define EEH_FORCE_DISABLED	0x02	/* EEH disabled		*/
+ #define EEH_PROBE_MODE_DEV	0x04	/* From PCI device	*/
+ #define EEH_PROBE_MODE_DEVTREE	0x08	/* From device tree	*/
+ #define EEH_ENABLE_IO_FOR_LOG	0x10	/* Enable IO for log	*/
+ #define EEH_EARLY_DUMP_LOG	0x20	/* Dump log immediately	*/
++>>>>>>> a450e8f55a57 (powerpc/eeh: Dump PHB diag-data early)
  
  /*
   * Delay for PE reset, all in ms
diff --cc arch/powerpc/kernel/eeh.c
index b7697ea6a6ff,05be77d9ea0e..000000000000
--- a/arch/powerpc/kernel/eeh.c
+++ b/arch/powerpc/kernel/eeh.c
@@@ -141,7 -142,9 +141,13 @@@ static struct eeh_stats eeh_stats
  static int __init eeh_setup(char *str)
  {
  	if (!strcmp(str, "off"))
++<<<<<<< HEAD
 +		eeh_subsystem_flags |= EEH_FORCE_DISABLED;
++=======
+ 		eeh_add_flag(EEH_FORCE_DISABLED);
+ 	else if (!strcmp(str, "early_log"))
+ 		eeh_add_flag(EEH_EARLY_DUMP_LOG);
++>>>>>>> a450e8f55a57 (powerpc/eeh: Dump PHB diag-data early)
  
  	return 1;
  }
diff --cc arch/powerpc/platforms/powernv/eeh-ioda.c
index 47d55b12a81e,2809c9895288..000000000000
--- a/arch/powerpc/platforms/powernv/eeh-ioda.c
+++ b/arch/powerpc/platforms/powernv/eeh-ioda.c
@@@ -291,20 -277,189 +291,142 @@@ static int ioda_eeh_set_option(struct e
  	return ret;
  }
  
 -static void ioda_eeh_phb_diag(struct eeh_pe *pe)
 +static void ioda_eeh_phb_diag(struct pci_controller *hose)
  {
 -	struct pnv_phb *phb = pe->phb->private_data;
 +	struct pnv_phb *phb = hose->private_data;
  	long rc;
  
 -	rc = opal_pci_get_phb_diag_data2(phb->opal_id, pe->data,
 +	rc = opal_pci_get_phb_diag_data2(phb->opal_id, phb->diag.blob,
  					 PNV_PCI_DIAG_BUF_SIZE);
 -	if (rc != OPAL_SUCCESS)
 -		pr_warn("%s: Failed to get diag-data for PHB#%x (%ld)\n",
 -			__func__, pe->phb->global_number, rc);
 -}
 -
 -static int ioda_eeh_get_phb_state(struct eeh_pe *pe)
 -{
 -	struct pnv_phb *phb = pe->phb->private_data;
 -	u8 fstate;
 -	__be16 pcierr;
 -	s64 rc;
 -	int result = 0;
 -
 -	rc = opal_pci_eeh_freeze_status(phb->opal_id,
 -					pe->addr,
 -					&fstate,
 -					&pcierr,
 -					NULL);
  	if (rc != OPAL_SUCCESS) {
 -		pr_warn("%s: Failure %lld getting PHB#%x state\n",
 -			__func__, rc, phb->hose->global_number);
 -		return EEH_STATE_NOT_SUPPORT;
 +		pr_warning("%s: Failed to get diag-data for PHB#%x (%ld)\n",
 +			    __func__, hose->global_number, rc);
 +		return;
  	}
  
++<<<<<<< HEAD
 +	pnv_pci_dump_phb_diag_data(hose, phb->diag.blob);
++=======
+ 	/*
+ 	 * Check PHB state. If the PHB is frozen for the
+ 	 * first time, to dump the PHB diag-data.
+ 	 */
+ 	if (be16_to_cpu(pcierr) != OPAL_EEH_PHB_ERROR) {
+ 		result = (EEH_STATE_MMIO_ACTIVE  |
+ 			  EEH_STATE_DMA_ACTIVE   |
+ 			  EEH_STATE_MMIO_ENABLED |
+ 			  EEH_STATE_DMA_ENABLED);
+ 	} else if (!(pe->state & EEH_PE_ISOLATED)) {
+ 		eeh_pe_state_mark(pe, EEH_PE_ISOLATED);
+ 		ioda_eeh_phb_diag(pe);
+ 
+ 		if (eeh_has_flag(EEH_EARLY_DUMP_LOG))
+ 			pnv_pci_dump_phb_diag_data(pe->phb, pe->data);
+ 	}
+ 
+ 	return result;
+ }
+ 
+ static int ioda_eeh_get_pe_state(struct eeh_pe *pe)
+ {
+ 	struct pnv_phb *phb = pe->phb->private_data;
+ 	u8 fstate;
+ 	__be16 pcierr;
+ 	s64 rc;
+ 	int result;
+ 
+ 	/*
+ 	 * We don't clobber hardware frozen state until PE
+ 	 * reset is completed. In order to keep EEH core
+ 	 * moving forward, we have to return operational
+ 	 * state during PE reset.
+ 	 */
+ 	if (pe->state & EEH_PE_RESET) {
+ 		result = (EEH_STATE_MMIO_ACTIVE  |
+ 			  EEH_STATE_DMA_ACTIVE   |
+ 			  EEH_STATE_MMIO_ENABLED |
+ 			  EEH_STATE_DMA_ENABLED);
+ 		return result;
+ 	}
+ 
+ 	/*
+ 	 * Fetch PE state from hardware. If the PHB
+ 	 * supports compound PE, let it handle that.
+ 	 */
+ 	if (phb->get_pe_state) {
+ 		fstate = phb->get_pe_state(phb, pe->addr);
+ 	} else {
+ 		rc = opal_pci_eeh_freeze_status(phb->opal_id,
+ 						pe->addr,
+ 						&fstate,
+ 						&pcierr,
+ 						NULL);
+ 		if (rc != OPAL_SUCCESS) {
+ 			pr_warn("%s: Failure %lld getting PHB#%x-PE%x state\n",
+ 				__func__, rc, phb->hose->global_number, pe->addr);
+ 			return EEH_STATE_NOT_SUPPORT;
+ 		}
+ 	}
+ 
+ 	/* Figure out state */
+ 	switch (fstate) {
+ 	case OPAL_EEH_STOPPED_NOT_FROZEN:
+ 		result = (EEH_STATE_MMIO_ACTIVE  |
+ 			  EEH_STATE_DMA_ACTIVE   |
+ 			  EEH_STATE_MMIO_ENABLED |
+ 			  EEH_STATE_DMA_ENABLED);
+ 		break;
+ 	case OPAL_EEH_STOPPED_MMIO_FREEZE:
+ 		result = (EEH_STATE_DMA_ACTIVE |
+ 			  EEH_STATE_DMA_ENABLED);
+ 		break;
+ 	case OPAL_EEH_STOPPED_DMA_FREEZE:
+ 		result = (EEH_STATE_MMIO_ACTIVE |
+ 			  EEH_STATE_MMIO_ENABLED);
+ 		break;
+ 	case OPAL_EEH_STOPPED_MMIO_DMA_FREEZE:
+ 		result = 0;
+ 		break;
+ 	case OPAL_EEH_STOPPED_RESET:
+ 		result = EEH_STATE_RESET_ACTIVE;
+ 		break;
+ 	case OPAL_EEH_STOPPED_TEMP_UNAVAIL:
+ 		result = EEH_STATE_UNAVAILABLE;
+ 		break;
+ 	case OPAL_EEH_STOPPED_PERM_UNAVAIL:
+ 		result = EEH_STATE_NOT_SUPPORT;
+ 		break;
+ 	default:
+ 		result = EEH_STATE_NOT_SUPPORT;
+ 		pr_warn("%s: Invalid PHB#%x-PE#%x state %x\n",
+ 			__func__, phb->hose->global_number,
+ 			pe->addr, fstate);
+ 	}
+ 
+ 	/*
+ 	 * If PHB supports compound PE, to freeze all
+ 	 * slave PEs for consistency.
+ 	 *
+ 	 * If the PE is switching to frozen state for the
+ 	 * first time, to dump the PHB diag-data.
+ 	 */
+ 	if (!(result & EEH_STATE_NOT_SUPPORT) &&
+ 	    !(result & EEH_STATE_UNAVAILABLE) &&
+ 	    !(result & EEH_STATE_MMIO_ACTIVE) &&
+ 	    !(result & EEH_STATE_DMA_ACTIVE)  &&
+ 	    !(pe->state & EEH_PE_ISOLATED)) {
+ 		if (phb->freeze_pe)
+ 			phb->freeze_pe(phb, pe->addr);
+ 
+ 		eeh_pe_state_mark(pe, EEH_PE_ISOLATED);
+ 		ioda_eeh_phb_diag(pe);
+ 
+ 		if (eeh_has_flag(EEH_EARLY_DUMP_LOG))
+ 			pnv_pci_dump_phb_diag_data(pe->phb, pe->data);
+ 	}
+ 
+ 	return result;
++>>>>>>> a450e8f55a57 (powerpc/eeh: Dump PHB diag-data early)
  }
  
  /**
@@@ -666,6 -724,25 +788,28 @@@ static int ioda_eeh_reset(struct eeh_p
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * ioda_eeh_get_log - Retrieve error log
+  * @pe: frozen PE
+  * @severity: permanent or temporary error
+  * @drv_log: device driver log
+  * @len: length of device driver log
+  *
+  * Retrieve error log, which contains log from device driver
+  * and firmware.
+  */
+ static int ioda_eeh_get_log(struct eeh_pe *pe, int severity,
+ 			    char *drv_log, unsigned long len)
+ {
+ 	if (!eeh_has_flag(EEH_EARLY_DUMP_LOG))
+ 		pnv_pci_dump_phb_diag_data(pe->phb, pe->data);
+ 
+ 	return 0;
+ }
+ 
+ /**
++>>>>>>> a450e8f55a57 (powerpc/eeh: Dump PHB diag-data early)
   * ioda_eeh_configure_bridge - Configure the PCI bridges for the indicated PE
   * @pe: EEH PE
   *
@@@ -973,7 -1092,11 +1117,15 @@@ static int ioda_eeh_next_error(struct e
  		    ret == EEH_NEXT_ERR_FENCED_PHB) &&
  		    !((*pe)->state & EEH_PE_ISOLATED)) {
  			eeh_pe_state_mark(*pe, EEH_PE_ISOLATED);
++<<<<<<< HEAD
 +			ioda_eeh_phb_diag(hose);
++=======
+ 			ioda_eeh_phb_diag(*pe);
+ 
+ 			if (eeh_has_flag(EEH_EARLY_DUMP_LOG))
+ 				pnv_pci_dump_phb_diag_data((*pe)->phb,
+ 							   (*pe)->data);
++>>>>>>> a450e8f55a57 (powerpc/eeh: Dump PHB diag-data early)
  		}
  
  		/*
* Unmerged path arch/powerpc/include/asm/eeh.h
* Unmerged path arch/powerpc/kernel/eeh.c
* Unmerged path arch/powerpc/platforms/powernv/eeh-ioda.c
