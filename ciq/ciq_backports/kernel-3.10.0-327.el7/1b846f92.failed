bridge: simplify br_getlink() a bit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Dan Carpenter <dan.carpenter@oracle.com>
commit 1b846f9282c0781f8ecf90e355008d94a0b973dd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/1b846f92.failed

Static checkers complain that we should maybe set "ret" before we do the
"goto out;".  They interpret the NULL return from br_port_get_rtnl() as
a failure and forgetting to set the error code is a common bug in this
situation.

The code is confusing but it's actually correct.  We are returning zero
deliberately.  Let's re-write it a bit to be more clear.

	Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
	Acked-by: Stephen Hemminger <stephen@networkplumber.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1b846f9282c0781f8ecf90e355008d94a0b973dd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_netlink.c
diff --cc net/bridge/br_netlink.c
index f813332a82b3,3875ea51f6fe..000000000000
--- a/net/bridge/br_netlink.c
+++ b/net/bridge/br_netlink.c
@@@ -206,25 -311,49 +206,28 @@@ errout
  int br_getlink(struct sk_buff *skb, u32 pid, u32 seq,
  	       struct net_device *dev, u32 filter_mask)
  {
- 	int err = 0;
  	struct net_bridge_port *port = br_port_get_rtnl(dev);
  
++<<<<<<< HEAD
 +	/* not a bridge port and  */
 +	if (!port && !(filter_mask & RTEXT_FILTER_BRVLAN))
 +		goto out;
- 
- 	err = br_fill_ifinfo(skb, port, pid, seq, RTM_NEWLINK, NLM_F_MULTI,
- 			     filter_mask, dev);
- out:
- 	return err;
++=======
+ 	if (!port && !(filter_mask & RTEXT_FILTER_BRVLAN) &&
+ 	    !(filter_mask & RTEXT_FILTER_BRVLAN_COMPRESSED))
+ 		return 0;
++>>>>>>> 1b846f9282c0 (bridge: simplify br_getlink() a bit)
+ 
+ 	return br_fill_ifinfo(skb, port, pid, seq, RTM_NEWLINK, NLM_F_MULTI,
+ 			      filter_mask, dev);
  }
  
 -static int br_vlan_info(struct net_bridge *br, struct net_bridge_port *p,
 -			int cmd, struct bridge_vlan_info *vinfo)
 -{
 -	int err = 0;
 -
 -	switch (cmd) {
 -	case RTM_SETLINK:
 -		if (p) {
 -			err = nbp_vlan_add(p, vinfo->vid, vinfo->flags);
 -			if (err)
 -				break;
 -
 -			if (vinfo->flags & BRIDGE_VLAN_INFO_MASTER)
 -				err = br_vlan_add(p->br, vinfo->vid,
 -						  vinfo->flags);
 -		} else {
 -			err = br_vlan_add(br, vinfo->vid, vinfo->flags);
 -		}
 -		break;
 -
 -	case RTM_DELLINK:
 -		if (p) {
 -			nbp_vlan_delete(p, vinfo->vid);
 -			if (vinfo->flags & BRIDGE_VLAN_INFO_MASTER)
 -				br_vlan_delete(p->br, vinfo->vid);
 -		} else {
 -			br_vlan_delete(br, vinfo->vid);
 -		}
 -		break;
 -	}
 -
 -	return err;
 -}
 +static const struct nla_policy ifla_br_policy[IFLA_MAX+1] = {
 +	[IFLA_BRIDGE_FLAGS]	= { .type = NLA_U16 },
 +	[IFLA_BRIDGE_MODE]	= { .type = NLA_U16 },
 +	[IFLA_BRIDGE_VLAN_INFO]	= { .type = NLA_BINARY,
 +				    .len = sizeof(struct bridge_vlan_info), },
 +};
  
  static int br_afspec(struct net_bridge *br,
  		     struct net_bridge_port *p,
* Unmerged path net/bridge/br_netlink.c
