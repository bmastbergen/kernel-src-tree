bonding: remove bond read lock for bond_activebackup_arp_mon()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author dingtianhong <dingtianhong@huawei.com>
commit 80b9d236ec56ecc18da4a43bd79e8ec9ac5036ff
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/80b9d236.failed

The bond slave list may change when the monitor is running, the slave list is no longer
protected by bond->lock, only protected by rtnl lock(), so we have 3 ways to modify it:
1.add bond_master_upper_dev_link() and bond_upper_dev_unlink() in bond->lock, but it is unsafe
to call call_netdevice_notifiers() in write lock.
2.remove unused bond->lock for monitor function, only use the existing rtnl lock().
3.use rcu_read_lock() to protect it, of course, it will transform bond_for_each_slave to
bond_for_each_slave_rcu() and performance is better, but in slow path, it is ignored.
so I remove the bond->lock and move the rtnl lock to protect the whole monitor function.

	Signed-off-by: Ding Tianhong <dingtianhong@huawei.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 80b9d236ec56ecc18da4a43bd79e8ec9ac5036ff)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
diff --cc drivers/net/bonding/bond_main.c
index f2744db511b6,535570ea8bbc..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -3022,36 -2726,19 +3022,44 @@@ void bond_activebackup_arp_mon(struct w
  	struct bonding *bond = container_of(work, struct bonding,
  					    arp_work.work);
  	bool should_notify_peers = false;
- 	int delta_in_ticks;
  
++<<<<<<< HEAD
 +	read_lock(&bond->lock);
 +
 +	delta_in_ticks = msecs_to_jiffies(bond->params.arp_interval);
 +
 +	if (bond->slave_cnt == 0)
++=======
+ 	if (!rtnl_trylock())
++>>>>>>> 80b9d236ec56 (bonding: remove bond read lock for bond_activebackup_arp_mon())
  		goto re_arm;
  
+ 	if (!bond_has_slaves(bond)) {
+ 		rtnl_unlock();
+ 		goto re_arm;
+ 	}
+ 
  	should_notify_peers = bond_should_notify_peers(bond);
  
++<<<<<<< HEAD
 +	if (bond_ab_arp_inspect(bond, delta_in_ticks)) {
 +		read_unlock(&bond->lock);
 +
 +		/* Race avoidance with bond_close flush of workqueue */
 +		if (!rtnl_trylock()) {
 +			read_lock(&bond->lock);
 +			delta_in_ticks = 1;
 +			should_notify_peers = false;
 +			goto re_arm;
 +		}
 +
 +		read_lock(&bond->lock);
 +
 +		bond_ab_arp_commit(bond, delta_in_ticks);
- 
- 		read_unlock(&bond->lock);
- 		rtnl_unlock();
- 		read_lock(&bond->lock);
- 	}
++=======
+ 	if (bond_ab_arp_inspect(bond))
+ 		bond_ab_arp_commit(bond);
++>>>>>>> 80b9d236ec56 (bonding: remove bond read lock for bond_activebackup_arp_mon())
  
  	bond_ab_arp_probe(bond);
  
* Unmerged path drivers/net/bonding/bond_main.c
