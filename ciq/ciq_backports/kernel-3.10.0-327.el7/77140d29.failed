bonding: rework bond_find_best_slave() to use bond_for_each_slave()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Veaceslav Falico <vfalico@redhat.com>
commit 77140d2951432487d012dbcdcf124168eafc49ca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/77140d29.failed

bond_find_best_slave() does not have to be balanced - i.e. return the slave
that is *after* some other slave, but rather return the best slave that
suits, except of bond->primary_slave - in which case we just return it if
it's suitable.

After that we just look through all the slaves and return either first up
slave or the slave whose link came back earliest.

We also don't care about curr_active_slave lock cause we use it in
bond_should_change_active() only and there we take it right away - i.e. it
won't go away.

CC: Jay Vosburgh <fubar@us.ibm.com>
CC: Andy Gospodarek <andy@greyhouse.net>
	Signed-off-by: Veaceslav Falico <vfalico@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 77140d2951432487d012dbcdcf124168eafc49ca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
diff --cc drivers/net/bonding/bond_main.c
index 05a57077bb1c,6abbfaca0b93..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -977,41 -788,21 +977,50 @@@ static bool bond_should_change_active(s
   */
  static struct slave *bond_find_best_slave(struct bonding *bond)
  {
- 	struct slave *new_active, *old_active;
- 	struct slave *bestslave = NULL;
+ 	struct slave *slave, *bestslave = NULL;
+ 	struct list_head *iter;
  	int mintime = bond->params.updelay;
- 	int i;
  
- 	new_active = bond->curr_active_slave;
+ 	if (bond->primary_slave && bond->primary_slave->link == BOND_LINK_UP &&
+ 	    bond_should_change_active(bond))
+ 		return bond->primary_slave;
  
++<<<<<<< HEAD
 +	if (!new_active) { /* there were no active slaves left */
 +		if (bond->slave_cnt > 0)   /* found one slave */
 +			new_active = bond->first_slave;
 +		else
 +			return NULL; /* still no slave, return NULL */
 +	}
 +
 +	if ((bond->primary_slave) &&
 +	    bond->primary_slave->link == BOND_LINK_UP &&
 +	    bond_should_change_active(bond)) {
 +		new_active = bond->primary_slave;
 +	}
 +
 +	/* remember where to stop iterating over the slaves */
 +	old_active = new_active;
 +
 +	bond_for_each_slave_from(bond, new_active, i, old_active) {
 +		if (new_active->link == BOND_LINK_UP) {
 +			return new_active;
 +		} else if (new_active->link == BOND_LINK_BACK &&
 +			   IS_UP(new_active->dev)) {
 +			/* link up, but waiting for stabilization */
 +			if (new_active->delay < mintime) {
 +				mintime = new_active->delay;
 +				bestslave = new_active;
 +			}
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
+ 		if (slave->link == BOND_LINK_UP)
+ 			return slave;
+ 		if (slave->link == BOND_LINK_BACK && IS_UP(slave->dev) &&
+ 		    slave->delay < mintime) {
+ 			mintime = slave->delay;
+ 			bestslave = slave;
++>>>>>>> 77140d295143 (bonding: rework bond_find_best_slave() to use bond_for_each_slave())
  		}
  	}
  
* Unmerged path drivers/net/bonding/bond_main.c
