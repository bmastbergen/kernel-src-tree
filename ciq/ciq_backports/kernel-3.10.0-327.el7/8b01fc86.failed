fs: take i_mutex during prepare_binprm for set[ug]id executables

jira LE-1907
cve CVE-2015-3339
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [fs] exec: take i_mutex during prepare_binprm for set[ug]id executables (Mateusz Guzik) [1216270] {CVE-2015-3339}
Rebuild_FUZZ: 95.38%
commit-author Jann Horn <jann@thejh.net>
commit 8b01fc86b9f425899f8a3a8fc1c47d73c2c20543
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/8b01fc86.failed

This prevents a race between chown() and execve(), where chowning a
setuid-user binary to root would momentarily make the binary setuid
root.

This patch was mostly written by Linus Torvalds.

	Signed-off-by: Jann Horn <jann@thejh.net>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 8b01fc86b9f425899f8a3a8fc1c47d73c2c20543)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/exec.c
diff --cc fs/exec.c
index d5973c813868,49a1c61433b7..000000000000
--- a/fs/exec.c
+++ b/fs/exec.c
@@@ -1251,61 -1268,71 +1251,119 @@@ static int check_unsafe_exec(struct lin
  	}
  	rcu_read_unlock();
  
 -	if (p->fs->users > n_fs)
 +	if (p->fs->users > n_fs) {
  		bprm->unsafe |= LSM_UNSAFE_SHARE;
 -	else
 -		p->fs->in_exec = 1;
 +	} else {
 +		res = -EAGAIN;
 +		if (!p->fs->in_exec) {
 +			p->fs->in_exec = 1;
 +			res = 1;
 +		}
 +	}
  	spin_unlock(&p->fs->lock);
 +
 +	return res;
  }
  
++<<<<<<< HEAD
 +/* 
 + * Fill the binprm structure from the inode. 
++=======
+ static void bprm_fill_uid(struct linux_binprm *bprm)
+ {
+ 	struct inode *inode;
+ 	unsigned int mode;
+ 	kuid_t uid;
+ 	kgid_t gid;
+ 
+ 	/* clear any previous set[ug]id data from a previous binary */
+ 	bprm->cred->euid = current_euid();
+ 	bprm->cred->egid = current_egid();
+ 
+ 	if (bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID)
+ 		return;
+ 
+ 	if (task_no_new_privs(current))
+ 		return;
+ 
+ 	inode = file_inode(bprm->file);
+ 	mode = READ_ONCE(inode->i_mode);
+ 	if (!(mode & (S_ISUID|S_ISGID)))
+ 		return;
+ 
+ 	/* Be careful if suid/sgid is set */
+ 	mutex_lock(&inode->i_mutex);
+ 
+ 	/* reload atomically mode/uid/gid now that lock held */
+ 	mode = inode->i_mode;
+ 	uid = inode->i_uid;
+ 	gid = inode->i_gid;
+ 	mutex_unlock(&inode->i_mutex);
+ 
+ 	/* We ignore suid/sgid if there are no mappings for them in the ns */
+ 	if (!kuid_has_mapping(bprm->cred->user_ns, uid) ||
+ 		 !kgid_has_mapping(bprm->cred->user_ns, gid))
+ 		return;
+ 
+ 	if (mode & S_ISUID) {
+ 		bprm->per_clear |= PER_CLEAR_ON_SETID;
+ 		bprm->cred->euid = uid;
+ 	}
+ 
+ 	if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {
+ 		bprm->per_clear |= PER_CLEAR_ON_SETID;
+ 		bprm->cred->egid = gid;
+ 	}
+ }
+ 
+ /*
+  * Fill the binprm structure from the inode.
++>>>>>>> 8b01fc86b9f4 (fs: take i_mutex during prepare_binprm for set[ug]id executables)
   * Check permissions, then read the first 128 (BINPRM_BUF_SIZE) bytes
   *
   * This may be called multiple times for binary chains (scripts for example).
   */
  int prepare_binprm(struct linux_binprm *bprm)
  {
++<<<<<<< HEAD
 +	umode_t mode;
 +	struct inode * inode = file_inode(bprm->file);
 +	int retval;
 +
 +	mode = inode->i_mode;
 +	if (bprm->file->f_op == NULL)
 +		return -EACCES;
 +
 +	/* clear any previous set[ug]id data from a previous binary */
 +	bprm->cred->euid = current_euid();
 +	bprm->cred->egid = current_egid();
 +
 +	if (!(bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID) &&
 +	    !current->no_new_privs &&
 +	    kuid_has_mapping(bprm->cred->user_ns, inode->i_uid) &&
 +	    kgid_has_mapping(bprm->cred->user_ns, inode->i_gid)) {
 +		/* Set-uid? */
 +		if (mode & S_ISUID) {
 +			bprm->per_clear |= PER_CLEAR_ON_SETID;
 +			bprm->cred->euid = inode->i_uid;
 +		}
 +
 +		/* Set-gid? */
 +		/*
 +		 * If setgid is set but no group execute bit then this
 +		 * is a candidate for mandatory locking, not a setgid
 +		 * executable.
 +		 */
 +		if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {
 +			bprm->per_clear |= PER_CLEAR_ON_SETID;
 +			bprm->cred->egid = inode->i_gid;
 +		}
 +	}
++=======
+ 	int retval;
+ 
+ 	bprm_fill_uid(bprm);
++>>>>>>> 8b01fc86b9f4 (fs: take i_mutex during prepare_binprm for set[ug]id executables)
  
  	/* fill in binprm security blob */
  	retval = security_bprm_set_creds(bprm);
* Unmerged path fs/exec.c
