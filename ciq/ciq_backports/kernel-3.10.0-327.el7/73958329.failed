bonding: extend round-robin mode with packets_per_slave

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Nikolay Aleksandrov <nikolay@redhat.com>
commit 73958329ea1fe0dc149b51e5d8703015f65a03e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/73958329.failed

This patch aims to extend round-robin mode with a new option called
packets_per_slave which can have the following values and effects:
0 - choose a random slave
1 (default) - standard round-robin, 1 packet per slave
 >1 - round-robin when >1 packets have been transmitted per slave
The allowed values are between 0 and 65535.
This patch also fixes the comment style in bond_xmit_roundrobin().

	Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
	Acked-by: Veaceslav Falico <vfalico@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 73958329ea1fe0dc149b51e5d8703015f65a03e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
#	drivers/net/bonding/bonding.h
diff --cc drivers/net/bonding/bond_main.c
index f2744db511b6,4dd5ee2a34cc..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -77,6 -77,9 +77,12 @@@
  #include <net/net_namespace.h>
  #include <net/netns/generic.h>
  #include <net/pkt_sched.h>
++<<<<<<< HEAD
++=======
+ #include <linux/rculist.h>
+ #include <net/flow_keys.h>
+ #include <linux/reciprocal_div.h>
++>>>>>>> 73958329ea1f (bonding: extend round-robin mode with packets_per_slave)
  #include "bonding.h"
  #include "bond_3ad.h"
  #include "bond_alb.h"
@@@ -3848,54 -3540,98 +3859,136 @@@ unwind
  	return res;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * bond_xmit_slave_id - transmit skb through slave with slave_id
+  * @bond: bonding device that is transmitting
+  * @skb: buffer to transmit
+  * @slave_id: slave id up to slave_cnt-1 through which to transmit
+  *
+  * This function tries to transmit through slave with slave_id but in case
+  * it fails, it tries to find the first available slave for transmission.
+  * The skb is consumed in all cases, thus the function is void.
+  */
+ void bond_xmit_slave_id(struct bonding *bond, struct sk_buff *skb, int slave_id)
+ {
+ 	struct list_head *iter;
+ 	struct slave *slave;
+ 	int i = slave_id;
+ 
+ 	/* Here we start from the slave with slave_id */
+ 	bond_for_each_slave_rcu(bond, slave, iter) {
+ 		if (--i < 0) {
+ 			if (slave_can_tx(slave)) {
+ 				bond_dev_queue_xmit(bond, skb, slave->dev);
+ 				return;
+ 			}
+ 		}
+ 	}
+ 
+ 	/* Here we start from the first slave up to slave_id */
+ 	i = slave_id;
+ 	bond_for_each_slave_rcu(bond, slave, iter) {
+ 		if (--i < 0)
+ 			break;
+ 		if (slave_can_tx(slave)) {
+ 			bond_dev_queue_xmit(bond, skb, slave->dev);
+ 			return;
+ 		}
+ 	}
+ 	/* no slave that can tx has been found */
+ 	kfree_skb(skb);
+ }
+ 
+ /**
+  * bond_rr_gen_slave_id - generate slave id based on packets_per_slave
+  * @bond: bonding device to use
+  *
+  * Based on the value of the bonding device's packets_per_slave parameter
+  * this function generates a slave id, which is usually used as the next
+  * slave to transmit through.
+  */
+ static u32 bond_rr_gen_slave_id(struct bonding *bond)
+ {
+ 	int packets_per_slave = bond->params.packets_per_slave;
+ 	u32 slave_id;
+ 
+ 	switch (packets_per_slave) {
+ 	case 0:
+ 		slave_id = prandom_u32();
+ 		break;
+ 	case 1:
+ 		slave_id = bond->rr_tx_counter;
+ 		break;
+ 	default:
+ 		slave_id = reciprocal_divide(bond->rr_tx_counter,
+ 					     packets_per_slave);
+ 		break;
+ 	}
+ 	bond->rr_tx_counter++;
+ 
+ 	return slave_id;
+ }
+ 
++>>>>>>> 73958329ea1f (bonding: extend round-robin mode with packets_per_slave)
  static int bond_xmit_roundrobin(struct sk_buff *skb, struct net_device *bond_dev)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
 +	struct slave *slave, *start_at;
 +	int i, slave_no, res = 1;
  	struct iphdr *iph = ip_hdr(skb);
++<<<<<<< HEAD
++=======
+ 	struct slave *slave;
+ 	u32 slave_id;
++>>>>>>> 73958329ea1f (bonding: extend round-robin mode with packets_per_slave)
  
- 	/*
- 	 * Start with the curr_active_slave that joined the bond as the
+ 	/* Start with the curr_active_slave that joined the bond as the
  	 * default for sending IGMP traffic.  For failover purposes one
  	 * needs to maintain some consistency for the interface that will
  	 * send the join/membership reports.  The curr_active_slave found
  	 * will send all of this type of traffic.
  	 */
 -	if (iph->protocol == IPPROTO_IGMP && skb->protocol == htons(ETH_P_IP)) {
 -		slave = rcu_dereference(bond->curr_active_slave);
 -		if (slave && slave_can_tx(slave))
 -			bond_dev_queue_xmit(bond, skb, slave->dev);
 -		else
 -			bond_xmit_slave_id(bond, skb, 0);
 +	if ((iph->protocol == IPPROTO_IGMP) &&
 +	    (skb->protocol == htons(ETH_P_IP))) {
 +		slave = bond->curr_active_slave;
 +		if (!slave)
 +			goto out;
  	} else {
++<<<<<<< HEAD
 +		/*
 +		 * Concurrent TX may collide on rr_tx_counter; we accept
 +		 * that as being rare enough not to justify using an
 +		 * atomic op here.
 +		 */
 +		slave_no = bond->rr_tx_counter++ % bond->slave_cnt;
 +
 +		bond_for_each_slave(bond, slave, i) {
 +			slave_no--;
 +			if (slave_no < 0)
 +				break;
 +		}
 +	}
 +
 +	start_at = slave;
 +	bond_for_each_slave_from(bond, slave, i, start_at) {
 +		if (IS_UP(slave->dev) &&
 +		    (slave->link == BOND_LINK_UP) &&
 +		    bond_is_active_slave(slave)) {
 +			res = bond_dev_queue_xmit(bond, skb, slave->dev);
 +			break;
 +		}
 +	}
 +
 +out:
 +	if (res) {
 +		/* no suitable interface, frame not sent */
 +		kfree_skb(skb);
++=======
+ 		slave_id = bond_rr_gen_slave_id(bond);
+ 		bond_xmit_slave_id(bond, skb, slave_id % bond->slave_cnt);
++>>>>>>> 73958329ea1f (bonding: extend round-robin mode with packets_per_slave)
  	}
  
  	return NETDEV_TX_OK;
diff --cc drivers/net/bonding/bonding.h
index 743d73f75728,77a07a12e77f..000000000000
--- a/drivers/net/bonding/bonding.h
+++ b/drivers/net/bonding/bonding.h
@@@ -233,9 -223,7 +234,13 @@@ struct bonding 
  	char     proc_file_name[IFNAMSIZ];
  #endif /* CONFIG_PROC_FS */
  	struct   list_head bond_list;
++<<<<<<< HEAD
 +	struct   netdev_hw_addr_list mc_list;
 +	int      (*xmit_hash_policy)(struct sk_buff *, int);
 +	u16      rr_tx_counter;
++=======
+ 	u32      rr_tx_counter;
++>>>>>>> 73958329ea1f (bonding: extend round-robin mode with packets_per_slave)
  	struct   ad_bond_info ad_info;
  	struct   alb_bond_info alb_info;
  	struct   bond_params params;
* Unmerged path drivers/net/bonding/bond_main.c
diff --git a/drivers/net/bonding/bond_sysfs.c b/drivers/net/bonding/bond_sysfs.c
index 739d4dbe8629..c658e383738f 100644
--- a/drivers/net/bonding/bond_sysfs.c
+++ b/drivers/net/bonding/bond_sysfs.c
@@ -40,6 +40,7 @@
 #include <net/net_namespace.h>
 #include <net/netns/generic.h>
 #include <linux/nsproxy.h>
+#include <linux/reciprocal_div.h>
 
 #include "bonding.h"
 
@@ -1745,6 +1746,53 @@ out:
 static DEVICE_ATTR(lp_interval, S_IRUGO | S_IWUSR,
 		   bonding_show_lp_interval, bonding_store_lp_interval);
 
+static ssize_t bonding_show_packets_per_slave(struct device *d,
+					      struct device_attribute *attr,
+					      char *buf)
+{
+	struct bonding *bond = to_bond(d);
+	int packets_per_slave = bond->params.packets_per_slave;
+
+	if (packets_per_slave > 1)
+		packets_per_slave = reciprocal_value(packets_per_slave);
+
+	return sprintf(buf, "%d\n", packets_per_slave);
+}
+
+static ssize_t bonding_store_packets_per_slave(struct device *d,
+					       struct device_attribute *attr,
+					       const char *buf, size_t count)
+{
+	struct bonding *bond = to_bond(d);
+	int new_value, ret = count;
+
+	if (sscanf(buf, "%d", &new_value) != 1) {
+		pr_err("%s: no packets_per_slave value specified.\n",
+		       bond->dev->name);
+		ret = -EINVAL;
+		goto out;
+	}
+	if (new_value < 0 || new_value > USHRT_MAX) {
+		pr_err("%s: packets_per_slave must be between 0 and %u\n",
+		       bond->dev->name, USHRT_MAX);
+		ret = -EINVAL;
+		goto out;
+	}
+	if (bond->params.mode != BOND_MODE_ROUNDROBIN)
+		pr_warn("%s: Warning: packets_per_slave has effect only in balance-rr mode\n",
+			bond->dev->name);
+	if (new_value > 1)
+		bond->params.packets_per_slave = reciprocal_value(new_value);
+	else
+		bond->params.packets_per_slave = new_value;
+out:
+	return ret;
+}
+
+static DEVICE_ATTR(packets_per_slave, S_IRUGO | S_IWUSR,
+		   bonding_show_packets_per_slave,
+		   bonding_store_packets_per_slave);
+
 static struct attribute *per_bond_attrs[] = {
 	&dev_attr_slaves.attr,
 	&dev_attr_mode.attr,
@@ -1776,6 +1824,7 @@ static struct attribute *per_bond_attrs[] = {
 	&dev_attr_resend_igmp.attr,
 	&dev_attr_min_links.attr,
 	&dev_attr_lp_interval.attr,
+	&dev_attr_packets_per_slave.attr,
 	NULL,
 };
 
* Unmerged path drivers/net/bonding/bonding.h
