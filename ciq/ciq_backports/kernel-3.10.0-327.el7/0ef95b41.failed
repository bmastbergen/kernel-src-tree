powerpc/powernv: Invoke opal call to handle hmi.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [powerpc] powernv: Invoke opal call to handle hmi (Gustavo Duarte) [1221091]
Rebuild_FUZZ: 89.66%
commit-author Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
commit 0ef95b411e73d8789100d017c02c1329c5055802
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/0ef95b41.failed

When we hit the HMI in Linux, invoke opal call to handle/recover from HMI
errors in real mode and then in virtual mode during check_irq_replay()
invoke opal_poll_events()/opal_do_notifier() to retrieve HMI event from
OPAL and act accordingly.

Now that we are ready to handle HMI interrupt directly in linux, remove
the HMI interrupt registration with firmware.

	Signed-off-by: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
	Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
(cherry picked from commit 0ef95b411e73d8789100d017c02c1329c5055802)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/opal.h
#	arch/powerpc/platforms/powernv/opal-wrappers.S
#	arch/powerpc/platforms/powernv/opal.c
diff --cc arch/powerpc/include/asm/opal.h
index 5683e9a3a478,b2f8ce1fd0d7..000000000000
--- a/arch/powerpc/include/asm/opal.h
+++ b/arch/powerpc/include/asm/opal.h
@@@ -148,8 -147,8 +148,13 @@@ struct opal_sg_list 
  #define OPAL_SET_PARAM				90
  #define OPAL_DUMP_RESEND			91
  #define OPAL_DUMP_INFO2				94
++<<<<<<< HEAD
 +#define OPAL_REGISTER_DUMP_REGION		101
 +#define OPAL_UNREGISTER_DUMP_REGION		102
++=======
+ #define OPAL_PCI_EEH_FREEZE_SET			97
+ #define OPAL_HANDLE_HMI				98
++>>>>>>> 0ef95b411e73 (powerpc/powernv: Invoke opal call to handle hmi.)
  
  #ifndef __ASSEMBLY__
  
@@@ -864,8 -919,7 +914,12 @@@ int64_t opal_get_param(uint64_t token, 
  int64_t opal_set_param(uint64_t token, uint32_t param_id, uint64_t buffer,
  		uint64_t length);
  int64_t opal_sensor_read(uint32_t sensor_hndl, int token, __be32 *sensor_data);
++<<<<<<< HEAD
 +int64_t opal_register_dump_region(uint32_t id, uint64_t start, uint64_t end);
 +int64_t opal_unregister_dump_region(uint32_t id);
++=======
+ int64_t opal_handle_hmi(void);
++>>>>>>> 0ef95b411e73 (powerpc/powernv: Invoke opal call to handle hmi.)
  
  /* Internal functions */
  extern int early_init_dt_scan_opal(unsigned long node, const char *uname,
diff --cc arch/powerpc/platforms/powernv/opal-wrappers.S
index af5726c0359f,a328be44880f..000000000000
--- a/arch/powerpc/platforms/powernv/opal-wrappers.S
+++ b/arch/powerpc/platforms/powernv/opal-wrappers.S
@@@ -147,5 -244,4 +147,9 @@@ OPAL_CALL(opal_sync_host_reboot,		OPAL_
  OPAL_CALL(opal_sensor_read,			OPAL_SENSOR_READ);
  OPAL_CALL(opal_get_param,			OPAL_GET_PARAM);
  OPAL_CALL(opal_set_param,			OPAL_SET_PARAM);
++<<<<<<< HEAD
 +OPAL_CALL(opal_register_dump_region,		OPAL_REGISTER_DUMP_REGION);
 +OPAL_CALL(opal_unregister_dump_region,		OPAL_UNREGISTER_DUMP_REGION);
++=======
+ OPAL_CALL(opal_handle_hmi,			OPAL_HANDLE_HMI);
++>>>>>>> 0ef95b411e73 (powerpc/powernv: Invoke opal call to handle hmi.)
diff --cc arch/powerpc/platforms/powernv/opal.c
index 2542700371c7,f0a01a46a57d..000000000000
--- a/arch/powerpc/platforms/powernv/opal.c
+++ b/arch/powerpc/platforms/powernv/opal.c
@@@ -517,6 -511,46 +514,49 @@@ int opal_machine_check(struct pt_regs *
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /* Early hmi handler called in real mode. */
+ int opal_hmi_exception_early(struct pt_regs *regs)
+ {
+ 	s64 rc;
+ 
+ 	/*
+ 	 * call opal hmi handler. Pass paca address as token.
+ 	 * The return value OPAL_SUCCESS is an indication that there is
+ 	 * an HMI event generated waiting to pull by Linux.
+ 	 */
+ 	rc = opal_handle_hmi();
+ 	if (rc == OPAL_SUCCESS) {
+ 		local_paca->hmi_event_available = 1;
+ 		return 1;
+ 	}
+ 	return 0;
+ }
+ 
+ /* HMI exception handler called in virtual mode during check_irq_replay. */
+ int opal_handle_hmi_exception(struct pt_regs *regs)
+ {
+ 	s64 rc;
+ 	__be64 evt = 0;
+ 
+ 	/*
+ 	 * Check if HMI event is available.
+ 	 * if Yes, then call opal_poll_events to pull opal messages and
+ 	 * process them.
+ 	 */
+ 	if (!local_paca->hmi_event_available)
+ 		return 0;
+ 
+ 	local_paca->hmi_event_available = 0;
+ 	rc = opal_poll_events(&evt);
+ 	if (rc == OPAL_SUCCESS && evt)
+ 		opal_do_notifier(be64_to_cpu(evt));
+ 
+ 	return 1;
+ }
+ 
++>>>>>>> 0ef95b411e73 (powerpc/powernv: Invoke opal call to handle hmi.)
  static uint64_t find_recovery_address(uint64_t nip)
  {
  	int i;
* Unmerged path arch/powerpc/include/asm/opal.h
diff --git a/arch/powerpc/include/asm/paca.h b/arch/powerpc/include/asm/paca.h
index 82270c09d005..3073e522b04e 100644
--- a/arch/powerpc/include/asm/paca.h
+++ b/arch/powerpc/include/asm/paca.h
@@ -162,6 +162,7 @@ struct paca_struct {
 	 * and already using emergency stack.
 	 */
 	u16 in_mce;
+	u8 hmi_event_available;		 /* HMI event is available */
 #endif
 
 	/* Stuff for accurate time accounting */
diff --git a/arch/powerpc/platforms/powernv/Makefile b/arch/powerpc/platforms/powernv/Makefile
index 4ad227d04c1a..495fed0e3b90 100644
--- a/arch/powerpc/platforms/powernv/Makefile
+++ b/arch/powerpc/platforms/powernv/Makefile
@@ -1,7 +1,7 @@
 obj-y			+= setup.o opal-wrappers.o opal.o opal-async.o
 obj-y			+= opal-rtc.o opal-nvram.o opal-lpc.o opal-flash.o
 obj-y			+= rng.o opal-elog.o opal-dump.o opal-sysparam.o opal-sensor.o
-obj-y			+= opal-msglog.o
+obj-y			+= opal-msglog.o opal-hmi.o
 
 obj-$(CONFIG_SMP)	+= smp.o subcore.o subcore-asm.o
 obj-$(CONFIG_PCI)	+= pci.o pci-p5ioc2.o pci-ioda.o
diff --git a/arch/powerpc/platforms/powernv/opal-hmi.c b/arch/powerpc/platforms/powernv/opal-hmi.c
new file mode 100644
index 000000000000..97ac8dc33667
--- /dev/null
+++ b/arch/powerpc/platforms/powernv/opal-hmi.c
@@ -0,0 +1,188 @@
+/*
+ * OPAL hypervisor Maintenance interrupt handling support in PowreNV.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Copyright 2014 IBM Corporation
+ * Author: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
+ */
+
+#undef DEBUG
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/of.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+
+#include <asm/opal.h>
+#include <asm/cputable.h>
+
+static int opal_hmi_handler_nb_init;
+struct OpalHmiEvtNode {
+	struct list_head list;
+	struct OpalHMIEvent hmi_evt;
+};
+static LIST_HEAD(opal_hmi_evt_list);
+static DEFINE_SPINLOCK(opal_hmi_evt_lock);
+
+static void print_hmi_event_info(struct OpalHMIEvent *hmi_evt)
+{
+	const char *level, *sevstr, *error_info;
+	static const char *hmi_error_types[] = {
+		"Malfunction Alert",
+		"Processor Recovery done",
+		"Processor recovery occurred again",
+		"Processor recovery occurred for masked error",
+		"Timer facility experienced an error",
+		"TFMR SPR is corrupted",
+		"UPS (Uniterrupted Power System) Overflow indication",
+		"An XSCOM operation failure",
+		"An XSCOM operation completed",
+		"SCOM has set a reserved FIR bit to cause recovery",
+		"Debug trigger has set a reserved FIR bit to cause recovery",
+		"A hypervisor resource error occurred"
+	};
+
+	/* Print things out */
+	if (hmi_evt->version != OpalHMIEvt_V1) {
+		pr_err("HMI Interrupt, Unknown event version %d !\n",
+			hmi_evt->version);
+		return;
+	}
+	switch (hmi_evt->severity) {
+	case OpalHMI_SEV_NO_ERROR:
+		level = KERN_INFO;
+		sevstr = "Harmless";
+		break;
+	case OpalHMI_SEV_WARNING:
+		level = KERN_WARNING;
+		sevstr = "";
+		break;
+	case OpalHMI_SEV_ERROR_SYNC:
+		level = KERN_ERR;
+		sevstr = "Severe";
+		break;
+	case OpalHMI_SEV_FATAL:
+	default:
+		level = KERN_ERR;
+		sevstr = "Fatal";
+		break;
+	}
+
+	printk("%s%s Hypervisor Maintenance interrupt [%s]\n",
+		level, sevstr,
+		hmi_evt->disposition == OpalHMI_DISPOSITION_RECOVERED ?
+		"Recovered" : "Not recovered");
+	error_info = hmi_evt->type < ARRAY_SIZE(hmi_error_types) ?
+			hmi_error_types[hmi_evt->type]
+			: "Unknown";
+	printk("%s Error detail: %s\n", level, error_info);
+	printk("%s	HMER: %016llx\n", level, be64_to_cpu(hmi_evt->hmer));
+	if ((hmi_evt->type == OpalHMI_ERROR_TFAC) ||
+		(hmi_evt->type == OpalHMI_ERROR_TFMR_PARITY))
+		printk("%s	TFMR: %016llx\n", level,
+						be64_to_cpu(hmi_evt->tfmr));
+}
+
+static void hmi_event_handler(struct work_struct *work)
+{
+	unsigned long flags;
+	struct OpalHMIEvent *hmi_evt;
+	struct OpalHmiEvtNode *msg_node;
+	uint8_t disposition;
+
+	spin_lock_irqsave(&opal_hmi_evt_lock, flags);
+	while (!list_empty(&opal_hmi_evt_list)) {
+		msg_node = list_entry(opal_hmi_evt_list.next,
+					   struct OpalHmiEvtNode, list);
+		list_del(&msg_node->list);
+		spin_unlock_irqrestore(&opal_hmi_evt_lock, flags);
+
+		hmi_evt = (struct OpalHMIEvent *) &msg_node->hmi_evt;
+		print_hmi_event_info(hmi_evt);
+		disposition = hmi_evt->disposition;
+		kfree(msg_node);
+
+		/*
+		 * Check if HMI event has been recovered or not. If not
+		 * then we can't continue, invoke panic.
+		 */
+		if (disposition != OpalHMI_DISPOSITION_RECOVERED)
+			panic("Unrecoverable HMI exception");
+
+		spin_lock_irqsave(&opal_hmi_evt_lock, flags);
+	}
+	spin_unlock_irqrestore(&opal_hmi_evt_lock, flags);
+}
+
+static DECLARE_WORK(hmi_event_work, hmi_event_handler);
+/*
+ * opal_handle_hmi_event - notifier handler that queues up HMI events
+ * to be preocessed later.
+ */
+static int opal_handle_hmi_event(struct notifier_block *nb,
+			  unsigned long msg_type, void *msg)
+{
+	unsigned long flags;
+	struct OpalHMIEvent *hmi_evt;
+	struct opal_msg *hmi_msg = msg;
+	struct OpalHmiEvtNode *msg_node;
+
+	/* Sanity Checks */
+	if (msg_type != OPAL_MSG_HMI_EVT)
+		return 0;
+
+	/* HMI event info starts from param[0] */
+	hmi_evt = (struct OpalHMIEvent *)&hmi_msg->params[0];
+
+	/* Delay the logging of HMI events to workqueue. */
+	msg_node = kzalloc(sizeof(*msg_node), GFP_ATOMIC);
+	if (!msg_node) {
+		pr_err("HMI: out of memory, Opal message event not handled\n");
+		return -ENOMEM;
+	}
+	memcpy(&msg_node->hmi_evt, hmi_evt, sizeof(struct OpalHMIEvent));
+
+	spin_lock_irqsave(&opal_hmi_evt_lock, flags);
+	list_add(&msg_node->list, &opal_hmi_evt_list);
+	spin_unlock_irqrestore(&opal_hmi_evt_lock, flags);
+
+	schedule_work(&hmi_event_work);
+	return 0;
+}
+
+static struct notifier_block opal_hmi_handler_nb = {
+	.notifier_call	= opal_handle_hmi_event,
+	.next		= NULL,
+	.priority	= 0,
+};
+
+static int __init opal_hmi_handler_init(void)
+{
+	int ret;
+
+	if (!opal_hmi_handler_nb_init) {
+		ret = opal_message_notifier_register(
+				OPAL_MSG_HMI_EVT, &opal_hmi_handler_nb);
+		if (ret) {
+			pr_err("%s: Can't register OPAL event notifier (%d)\n",
+			       __func__, ret);
+			return ret;
+		}
+		opal_hmi_handler_nb_init = 1;
+	}
+	return 0;
+}
+subsys_initcall(opal_hmi_handler_init);
* Unmerged path arch/powerpc/platforms/powernv/opal-wrappers.S
* Unmerged path arch/powerpc/platforms/powernv/opal.c
