bonding: convert queue_id to use the new option API

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Nikolay Aleksandrov <nikolay@redhat.com>
commit 24089ba1026a684d64bc0eeb6af634e26c9501c4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/24089ba1.failed

This patch adds the necessary changes so queue_id would use
the new bonding option API. Also move it to its own set function in
bond_options.c and fix some style errors.

	Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 24089ba1026a684d64bc0eeb6af634e26c9501c4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_options.c
#	drivers/net/bonding/bond_options.h
#	drivers/net/bonding/bond_sysfs.c
diff --cc drivers/net/bonding/bond_sysfs.c
index 9519d678a368,a9cd3f514c8c..000000000000
--- a/drivers/net/bonding/bond_sysfs.c
+++ b/drivers/net/bonding/bond_sysfs.c
@@@ -1531,76 -985,15 +1531,83 @@@ static ssize_t bonding_store_queue_id(s
  				      struct device_attribute *attr,
  				      const char *buffer, size_t count)
  {
- 	struct slave *slave, *update_slave;
  	struct bonding *bond = to_bond(d);
++<<<<<<< HEAD
 +	u16 qid;
 +	int i, ret = count;
 +	char *delim;
 +	struct net_device *sdev = NULL;
++=======
+ 	int ret;
++>>>>>>> 24089ba1026a (bonding: convert queue_id to use the new option API)
  
- 	if (!rtnl_trylock())
- 		return restart_syscall();
+ 	ret = bond_opt_tryset_rtnl(bond, BOND_OPT_QUEUE_ID, (char *)buffer);
+ 	if (!ret)
+ 		ret = count;
  
++<<<<<<< HEAD
 +	/* delim will point to queue id if successful */
 +	delim = strchr(buffer, ':');
 +	if (!delim)
 +		goto err_no_cmd;
 +
 +	/*
 +	 * Terminate string that points to device name and bump it
 +	 * up one, so we can read the queue id there.
 +	 */
 +	*delim = '\0';
 +	if (sscanf(++delim, "%hd\n", &qid) != 1)
 +		goto err_no_cmd;
 +
 +	/* Check buffer length, valid ifname and queue id */
 +	if (strlen(buffer) > IFNAMSIZ ||
 +	    !dev_valid_name(buffer) ||
 +	    qid > bond->dev->real_num_tx_queues)
 +		goto err_no_cmd;
 +
 +	/* Get the pointer to that interface if it exists */
 +	sdev = __dev_get_by_name(dev_net(bond->dev), buffer);
 +	if (!sdev)
 +		goto err_no_cmd;
 +
 +	read_lock(&bond->lock);
 +
 +	/* Search for thes slave and check for duplicate qids */
 +	update_slave = NULL;
 +	bond_for_each_slave(bond, slave, i) {
 +		if (sdev == slave->dev)
 +			/*
 +			 * We don't need to check the matching
 +			 * slave for dups, since we're overwriting it
 +			 */
 +			update_slave = slave;
 +		else if (qid && qid == slave->queue_id) {
 +			goto err_no_cmd_unlock;
 +		}
 +	}
 +
 +	if (!update_slave)
 +		goto err_no_cmd_unlock;
 +
 +	/* Actually set the qids for the slave */
 +	update_slave->queue_id = qid;
 +
 +	read_unlock(&bond->lock);
 +out:
 +	rtnl_unlock();
 +	return ret;
 +
 +err_no_cmd_unlock:
 +	read_unlock(&bond->lock);
 +err_no_cmd:
 +	pr_info("invalid input for queue_id set for %s.\n",
 +		bond->dev->name);
 +	ret = -EPERM;
 +	goto out;
++=======
+ 	return ret;
++>>>>>>> 24089ba1026a (bonding: convert queue_id to use the new option API)
  }
- 
  static DEVICE_ATTR(queue_id, S_IRUGO | S_IWUSR, bonding_show_queue_id,
  		   bonding_store_queue_id);
  
* Unmerged path drivers/net/bonding/bond_options.c
* Unmerged path drivers/net/bonding/bond_options.h
* Unmerged path drivers/net/bonding/bond_options.c
* Unmerged path drivers/net/bonding/bond_options.h
* Unmerged path drivers/net/bonding/bond_sysfs.c
