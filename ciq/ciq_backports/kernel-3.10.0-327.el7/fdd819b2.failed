virtio_net: v1.0 endianness

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [virtio] virtio-net: v1.0 endianness (Jason Wang) [1227339]
Rebuild_FUZZ: 96.30%
commit-author Michael S. Tsirkin <mst@redhat.com>
commit fdd819b21576c361bf0dcdd9522df4ccabf7aaa8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/fdd819b2.failed

Based on patches by Rusty Russell, Cornelia Huck.
Note: more code changes are needed for 1.0 support
(due to different header size).
So we don't advertize support for 1.0 yet.

	Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
	Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
	Signed-off-by: Michael S. Tsirkin <mst@redhat.com>




(cherry picked from commit fdd819b21576c361bf0dcdd9522df4ccabf7aaa8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/virtio_net.c
diff --cc drivers/net/virtio_net.c
index 376e2c75ee06,c07e0302438e..000000000000
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@@ -326,30 -347,32 +326,49 @@@ err
  }
  
  static struct sk_buff *receive_mergeable(struct net_device *dev,
+ 					 struct virtnet_info *vi,
  					 struct receive_queue *rq,
 -					 unsigned long ctx,
 +					 void *buf,
  					 unsigned int len)
  {
++<<<<<<< HEAD
 +	struct skb_vnet_hdr *hdr = page_address(buf);
 +	int num_buf = hdr->mhdr.num_buffers;
 +	struct page *page = buf;
 +	struct sk_buff *skb = page_to_skb(rq, page, len);
 +	int i;
++=======
+ 	void *buf = mergeable_ctx_to_buf_address(ctx);
+ 	struct skb_vnet_hdr *hdr = buf;
+ 	u16 num_buf = virtio16_to_cpu(rq->vq->vdev, hdr->mhdr.num_buffers);
+ 	struct page *page = virt_to_head_page(buf);
+ 	int offset = buf - page_address(page);
+ 	unsigned int truesize = max(len, mergeable_ctx_to_buf_truesize(ctx));
++>>>>>>> fdd819b21576 (virtio_net: v1.0 endianness)
  
 -	struct sk_buff *head_skb = page_to_skb(rq, page, offset, len, truesize);
 -	struct sk_buff *curr_skb = head_skb;
 -
 -	if (unlikely(!curr_skb))
 +	if (unlikely(!skb))
  		goto err_skb;
 -	while (--num_buf) {
 -		int num_skb_frags;
  
++<<<<<<< HEAD
 +	while (--num_buf) {
 +		i = skb_shinfo(skb)->nr_frags;
 +		if (i >= MAX_SKB_FRAGS) {
 +			pr_debug("%s: packet too long\n", skb->dev->name);
 +			skb->dev->stats.rx_length_errors++;
 +			return NULL;
 +		}
 +		page = virtqueue_get_buf(rq->vq, &len);
 +		if (!page) {
 +			pr_debug("%s: rx error: %d buffers %d missing\n",
 +				 dev->name, hdr->mhdr.num_buffers, num_buf);
++=======
+ 		ctx = (unsigned long)virtqueue_get_buf(rq->vq, &len);
+ 		if (unlikely(!ctx)) {
+ 			pr_debug("%s: rx error: %d buffers out of %d missing\n",
+ 				 dev->name, num_buf,
+ 				 virtio16_to_cpu(rq->vq->vdev,
+ 						 hdr->mhdr.num_buffers));
++>>>>>>> fdd819b21576 (virtio_net: v1.0 endianness)
  			dev->stats.rx_length_errors++;
  			goto err_buf;
  		}
@@@ -393,14 -444,20 +412,18 @@@ static void receive_buf(struct receive_
  	if (unlikely(len < sizeof(struct virtio_net_hdr) + ETH_HLEN)) {
  		pr_debug("%s: short packet %i\n", dev->name, len);
  		dev->stats.rx_length_errors++;
 -		if (vi->mergeable_rx_bufs) {
 -			unsigned long ctx = (unsigned long)buf;
 -			void *base = mergeable_ctx_to_buf_address(ctx);
 -			put_page(virt_to_head_page(base));
 -		} else if (vi->big_packets) {
 +		if (vi->mergeable_rx_bufs || vi->big_packets)
  			give_pages(rq, buf);
 -		} else {
 +		else
  			dev_kfree_skb(buf);
 -		}
  		return;
  	}
 -
  	if (vi->mergeable_rx_bufs)
++<<<<<<< HEAD
 +		skb = receive_mergeable(dev, rq, buf, len);
++=======
+ 		skb = receive_mergeable(dev, vi, rq, (unsigned long)buf, len);
++>>>>>>> fdd819b21576 (virtio_net: v1.0 endianness)
  	else if (vi->big_packets)
  		skb = receive_big(dev, rq, buf, len);
  	else
* Unmerged path drivers/net/virtio_net.c
diff --git a/include/uapi/linux/virtio_net.h b/include/uapi/linux/virtio_net.h
index 227d4ce84e79..3fc51ef9861c 100644
--- a/include/uapi/linux/virtio_net.h
+++ b/include/uapi/linux/virtio_net.h
@@ -28,6 +28,7 @@
 #include <linux/types.h>
 #include <linux/virtio_ids.h>
 #include <linux/virtio_config.h>
+#include <linux/virtio_types.h>
 #include <linux/if_ether.h>
 
 /* The feature bitmap for virtio net */
@@ -84,17 +85,17 @@ struct virtio_net_hdr {
 #define VIRTIO_NET_HDR_GSO_TCPV6	4	// GSO frame, IPv6 TCP
 #define VIRTIO_NET_HDR_GSO_ECN		0x80	// TCP has ECN set
 	__u8 gso_type;
-	__u16 hdr_len;		/* Ethernet + IP + tcp/udp hdrs */
-	__u16 gso_size;		/* Bytes to append to hdr_len per frame */
-	__u16 csum_start;	/* Position to start checksumming from */
-	__u16 csum_offset;	/* Offset after that to place checksum */
+	__virtio16 hdr_len;		/* Ethernet + IP + tcp/udp hdrs */
+	__virtio16 gso_size;		/* Bytes to append to hdr_len per frame */
+	__virtio16 csum_start;	/* Position to start checksumming from */
+	__virtio16 csum_offset;	/* Offset after that to place checksum */
 };
 
 /* This is the version of the header to use when the MRG_RXBUF
  * feature has been negotiated. */
 struct virtio_net_hdr_mrg_rxbuf {
 	struct virtio_net_hdr hdr;
-	__u16 num_buffers;	/* Number of merged rx buffers */
+	__virtio16 num_buffers;	/* Number of merged rx buffers */
 };
 
 /*
@@ -149,7 +150,7 @@ typedef __u8 virtio_net_ctrl_ack;
  * VIRTIO_NET_F_CTRL_MAC_ADDR feature is available.
  */
 struct virtio_net_ctrl_mac {
-	__u32 entries;
+	__virtio32 entries;
 	__u8 macs[][ETH_ALEN];
 } __attribute__((packed));
 
@@ -193,7 +194,7 @@ struct virtio_net_ctrl_mac {
  * specified.
  */
 struct virtio_net_ctrl_mq {
-	__u16 virtqueue_pairs;
+	__virtio16 virtqueue_pairs;
 };
 
 #define VIRTIO_NET_CTRL_MQ   4
