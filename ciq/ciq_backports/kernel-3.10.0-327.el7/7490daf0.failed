s390/ptrace: always include vector registers in core files

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [s390] ptrace: always include vector registers in core files (Hendrik Brueckner) [1102206]
Rebuild_FUZZ: 95.50%
commit-author Martin Schwidefsky <schwidefsky@de.ibm.com>
commit 7490daf01f11b5b692f69963eaee9be4adc135c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/7490daf0.failed

On machines with support for vector registers the signal frame includes
an area for the vector registers and the ptrace regset interface allow
read and write. This is true even if the task never used any vector
instruction. Only elf core dumps do not include the vector registers,
to make things consistent always include the vector register note in
core dumps create on a machine with vector register support.

	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 7490daf01f11b5b692f69963eaee9be4adc135c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/kernel/ptrace.c
diff --cc arch/s390/kernel/ptrace.c
index b3e4e83cd940,eabfb4594517..000000000000
--- a/arch/s390/kernel/ptrace.c
+++ b/arch/s390/kernel/ptrace.c
@@@ -1030,6 -1091,97 +1030,100 @@@ static int s390_tdb_set(struct task_str
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int s390_vxrs_low_get(struct task_struct *target,
+ 			     const struct user_regset *regset,
+ 			     unsigned int pos, unsigned int count,
+ 			     void *kbuf, void __user *ubuf)
+ {
+ 	__u64 vxrs[__NUM_VXRS_LOW];
+ 	int i;
+ 
+ 	if (!MACHINE_HAS_VX)
+ 		return -ENODEV;
+ 	if (target->thread.vxrs) {
+ 		if (target == current)
+ 			save_vx_regs(target->thread.vxrs);
+ 		for (i = 0; i < __NUM_VXRS_LOW; i++)
+ 			vxrs[i] = *((__u64 *)(target->thread.vxrs + i) + 1);
+ 	} else
+ 		memset(vxrs, 0, sizeof(vxrs));
+ 	return user_regset_copyout(&pos, &count, &kbuf, &ubuf, vxrs, 0, -1);
+ }
+ 
+ static int s390_vxrs_low_set(struct task_struct *target,
+ 			     const struct user_regset *regset,
+ 			     unsigned int pos, unsigned int count,
+ 			     const void *kbuf, const void __user *ubuf)
+ {
+ 	__u64 vxrs[__NUM_VXRS_LOW];
+ 	int i, rc;
+ 
+ 	if (!MACHINE_HAS_VX)
+ 		return -ENODEV;
+ 	if (!target->thread.vxrs) {
+ 		rc = alloc_vector_registers(target);
+ 		if (rc)
+ 			return rc;
+ 	} else if (target == current)
+ 		save_vx_regs(target->thread.vxrs);
+ 
+ 	rc = user_regset_copyin(&pos, &count, &kbuf, &ubuf, vxrs, 0, -1);
+ 	if (rc == 0) {
+ 		for (i = 0; i < __NUM_VXRS_LOW; i++)
+ 			*((__u64 *)(target->thread.vxrs + i) + 1) = vxrs[i];
+ 		if (target == current)
+ 			restore_vx_regs(target->thread.vxrs);
+ 	}
+ 
+ 	return rc;
+ }
+ 
+ static int s390_vxrs_high_get(struct task_struct *target,
+ 			      const struct user_regset *regset,
+ 			      unsigned int pos, unsigned int count,
+ 			      void *kbuf, void __user *ubuf)
+ {
+ 	__vector128 vxrs[__NUM_VXRS_HIGH];
+ 
+ 	if (!MACHINE_HAS_VX)
+ 		return -ENODEV;
+ 	if (target->thread.vxrs) {
+ 		if (target == current)
+ 			save_vx_regs(target->thread.vxrs);
+ 		memcpy(vxrs, target->thread.vxrs + __NUM_VXRS_LOW,
+ 		       sizeof(vxrs));
+ 	} else
+ 		memset(vxrs, 0, sizeof(vxrs));
+ 	return user_regset_copyout(&pos, &count, &kbuf, &ubuf, vxrs, 0, -1);
+ }
+ 
+ static int s390_vxrs_high_set(struct task_struct *target,
+ 			      const struct user_regset *regset,
+ 			      unsigned int pos, unsigned int count,
+ 			      const void *kbuf, const void __user *ubuf)
+ {
+ 	int rc;
+ 
+ 	if (!MACHINE_HAS_VX)
+ 		return -ENODEV;
+ 	if (!target->thread.vxrs) {
+ 		rc = alloc_vector_registers(target);
+ 		if (rc)
+ 			return rc;
+ 	} else if (target == current)
+ 		save_vx_regs(target->thread.vxrs);
+ 
+ 	rc = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
+ 				target->thread.vxrs + __NUM_VXRS_LOW, 0, -1);
+ 	if (rc == 0 && target == current)
+ 		restore_vx_regs(target->thread.vxrs);
+ 
+ 	return rc;
+ }
+ 
++>>>>>>> 7490daf01f11 (s390/ptrace: always include vector registers in core files)
  #endif
  
  static int s390_system_call_get(struct task_struct *target,
@@@ -1086,15 -1246,23 +1180,34 @@@ static const struct user_regset s390_re
  		.get = s390_tdb_get,
  		.set = s390_tdb_set,
  	},
++<<<<<<< HEAD
++=======
+ 	{
+ 		.core_note_type = NT_S390_VXRS_LOW,
+ 		.n = __NUM_VXRS_LOW,
+ 		.size = sizeof(__u64),
+ 		.align = sizeof(__u64),
+ 		.get = s390_vxrs_low_get,
+ 		.set = s390_vxrs_low_set,
+ 	},
+ 	{
+ 		.core_note_type = NT_S390_VXRS_HIGH,
+ 		.n = __NUM_VXRS_HIGH,
+ 		.size = sizeof(__vector128),
+ 		.align = sizeof(__vector128),
+ 		.get = s390_vxrs_high_get,
+ 		.set = s390_vxrs_high_set,
+ 	},
++>>>>>>> 7490daf01f11 (s390/ptrace: always include vector registers in core files)
  #endif
 +	[REGSET_SYSTEM_CALL] = {
 +		.core_note_type = NT_S390_SYSTEM_CALL,
 +		.n = 1,
 +		.size = sizeof(unsigned int),
 +		.align = sizeof(unsigned int),
 +		.get = s390_system_call_get,
 +		.set = s390_system_call_set,
 +	},
  };
  
  static const struct user_regset_view user_s390_view = {
@@@ -1291,15 -1467,23 +1404,35 @@@ static const struct user_regset s390_co
  		.get = s390_tdb_get,
  		.set = s390_tdb_set,
  	},
++<<<<<<< HEAD
 +	[REGSET_SYSTEM_CALL] = {
 +		.core_note_type = NT_S390_SYSTEM_CALL,
 +		.n = 1,
 +		.size = sizeof(compat_uint_t),
 +		.align = sizeof(compat_uint_t),
 +		.get = s390_system_call_get,
 +		.set = s390_system_call_set,
 +	},
 +	[REGSET_GENERAL_EXTENDED] = {
++=======
+ 	{
+ 		.core_note_type = NT_S390_VXRS_LOW,
+ 		.n = __NUM_VXRS_LOW,
+ 		.size = sizeof(__u64),
+ 		.align = sizeof(__u64),
+ 		.get = s390_vxrs_low_get,
+ 		.set = s390_vxrs_low_set,
+ 	},
+ 	{
+ 		.core_note_type = NT_S390_VXRS_HIGH,
+ 		.n = __NUM_VXRS_HIGH,
+ 		.size = sizeof(__vector128),
+ 		.align = sizeof(__vector128),
+ 		.get = s390_vxrs_high_get,
+ 		.set = s390_vxrs_high_set,
+ 	},
+ 	{
++>>>>>>> 7490daf01f11 (s390/ptrace: always include vector registers in core files)
  		.core_note_type = NT_S390_HIGH_GPRS,
  		.n = sizeof(s390_compat_regs_high) / sizeof(compat_long_t),
  		.size = sizeof(compat_long_t),
* Unmerged path arch/s390/kernel/ptrace.c
