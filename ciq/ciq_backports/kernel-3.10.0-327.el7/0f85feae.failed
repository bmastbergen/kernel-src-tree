tcp: fix more NULL deref after prequeue changes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Eric Dumazet <edumazet@google.com>
commit 0f85feae6b710ced3abad5b2b47d31dfcb956b62
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/0f85feae.failed

When I cooked commit c3658e8d0f1 ("tcp: fix possible NULL dereference in
tcp_vX_send_reset()") I missed other spots we could deref a NULL
skb_dst(skb)

Again, if a socket is provided, we do not need skb_dst() to get a
pointer to network namespace : sock_net(sk) is good enough.

	Reported-by: Dann Frazier <dann.frazier@canonical.com>
Bisected-by: Dann Frazier <dann.frazier@canonical.com>
	Tested-by: Dann Frazier <dann.frazier@canonical.com>
	Signed-off-by: Eric Dumazet <edumazet@google.com>
Fixes: ca777eff51f7 ("tcp: remove dst refcount false sharing for prequeue mode")
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0f85feae6b710ced3abad5b2b47d31dfcb956b62)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/tcp_ipv6.c
diff --cc net/ipv6/tcp_ipv6.c
index 715cc96a3475,c277951d783b..000000000000
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@@ -726,20 -767,30 +726,20 @@@ struct request_sock_ops tcp6_request_so
  	.send_ack	=	tcp_v6_reqsk_send_ack,
  	.destructor	=	tcp_v6_reqsk_destructor,
  	.send_reset	=	tcp_v6_send_reset,
 -	.syn_ack_timeout =	tcp_syn_ack_timeout,
 +	.syn_ack_timeout = 	tcp_syn_ack_timeout,
  };
  
 -static const struct tcp_request_sock_ops tcp_request_sock_ipv6_ops = {
 -	.mss_clamp	=	IPV6_MIN_MTU - sizeof(struct tcphdr) -
 -				sizeof(struct ipv6hdr),
  #ifdef CONFIG_TCP_MD5SIG
 +static const struct tcp_request_sock_ops tcp_request_sock_ipv6_ops = {
  	.md5_lookup	=	tcp_v6_reqsk_md5_lookup,
  	.calc_md5_hash	=	tcp_v6_md5_hash_skb,
 -#endif
 -	.init_req	=	tcp_v6_init_req,
 -#ifdef CONFIG_SYN_COOKIES
 -	.cookie_init_seq =	cookie_v6_init_sequence,
 -#endif
 -	.route_req	=	tcp_v6_route_req,
 -	.init_seq	=	tcp_v6_init_sequence,
 -	.send_synack	=	tcp_v6_send_synack,
 -	.queue_hash_add =	inet6_csk_reqsk_queue_hash_add,
  };
 +#endif
  
- static void tcp_v6_send_response(struct sk_buff *skb, u32 seq, u32 ack, u32 win,
- 				 u32 tsval, u32 tsecr, int oif,
- 				 struct tcp_md5sig_key *key, int rst, u8 tclass,
- 				 u32 label)
+ static void tcp_v6_send_response(struct sock *sk, struct sk_buff *skb, u32 seq,
+ 				 u32 ack, u32 win, u32 tsval, u32 tsecr,
+ 				 int oif, struct tcp_md5sig_key *key, int rst,
+ 				 u8 tclass, u32 label)
  {
  	const struct tcphdr *th = tcp_hdr(skb);
  	struct tcphdr *t1;
@@@ -931,8 -983,13 +931,18 @@@ static void tcp_v6_timewait_ack(struct 
  static void tcp_v6_reqsk_send_ack(struct sock *sk, struct sk_buff *skb,
  				  struct request_sock *req)
  {
++<<<<<<< HEAD
 +	tcp_v6_send_ack(skb, tcp_rsk(req)->snt_isn + 1, tcp_rsk(req)->rcv_isn + 1,
 +			req->rcv_wnd, tcp_time_stamp, req->ts_recent, sk->sk_bound_dev_if,
++=======
+ 	/* sk->sk_state == TCP_LISTEN -> for regular TCP_SYN_RECV
+ 	 * sk->sk_state == TCP_SYN_RECV -> for Fast Open.
+ 	 */
+ 	tcp_v6_send_ack(sk, skb, (sk->sk_state == TCP_LISTEN) ?
+ 			tcp_rsk(req)->snt_isn + 1 : tcp_sk(sk)->snd_nxt,
+ 			tcp_rsk(req)->rcv_nxt, req->rcv_wnd,
+ 			tcp_time_stamp, req->ts_recent, sk->sk_bound_dev_if,
++>>>>>>> 0f85feae6b71 (tcp: fix more NULL deref after prequeue changes)
  			tcp_v6_md5_do_lookup(sk, &ipv6_hdr(skb)->daddr),
  			0, 0);
  }
diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c
index 10efd403b538..5b8664894cd9 100644
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@ -625,6 +625,7 @@ static void tcp_v4_send_reset(struct sock *sk, struct sk_buff *skb)
 	arg.iov[0].iov_base = (unsigned char *)&rep;
 	arg.iov[0].iov_len  = sizeof(rep.th);
 
+	net = sk ? sock_net(sk) : dev_net(skb_dst(skb)->dev);
 #ifdef CONFIG_TCP_MD5SIG
 	hash_location = tcp_parse_md5sig_option(th);
 	if (!sk && hash_location) {
@@ -635,7 +636,7 @@ static void tcp_v4_send_reset(struct sock *sk, struct sk_buff *skb)
 		 * Incoming packet is checked with md5 hash with finding key,
 		 * no RST generated if md5 hash doesn't match.
 		 */
-		sk1 = __inet_lookup_listener(dev_net(skb_dst(skb)->dev),
+		sk1 = __inet_lookup_listener(net,
 					     &tcp_hashinfo, ip_hdr(skb)->saddr,
 					     th->source, ip_hdr(skb)->daddr,
 					     ntohs(th->source), inet_iif(skb));
@@ -683,7 +684,6 @@ static void tcp_v4_send_reset(struct sock *sk, struct sk_buff *skb)
 	if (sk)
 		arg.bound_dev_if = sk->sk_bound_dev_if;
 
-	net = dev_net(skb_dst(skb)->dev);
 	arg.tos = ip_hdr(skb)->tos;
 	ip_send_unicast_reply(net, skb, ip_hdr(skb)->saddr,
 			      ip_hdr(skb)->daddr, &arg, arg.iov[0].iov_len);
* Unmerged path net/ipv6/tcp_ipv6.c
