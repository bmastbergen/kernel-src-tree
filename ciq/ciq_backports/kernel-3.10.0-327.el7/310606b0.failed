xfs: factor out xfs_finish_rename()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit 310606b0c7e385e9dd3533d168413ad2c579d961
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/310606b0.failed

Rather than use a jump label for the final transaction commit in
the rename, factor it into a simple helper function and call it
appropriately. This slightly reduces the spaghetti nature of
xfs_rename.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Eric Sandeen <sandeen@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit 310606b0c7e385e9dd3533d168413ad2c579d961)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_inode.c
diff --cc fs/xfs/xfs_inode.c
index 0a9e226dbdb3,c3fe00cb19e4..000000000000
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@@ -2742,6 -2650,149 +2742,31 @@@ xfs_sort_for_rename
  	}
  }
  
+ static int
+ xfs_finish_rename(
+ 	struct xfs_trans	*tp,
+ 	struct xfs_bmap_free	*free_list)
+ {
+ 	int			committed = 0;
+ 	int			error;
+ 
+ 	/*
+ 	 * If this is a synchronous mount, make sure that the rename transaction
+ 	 * goes to disk before returning to the user.
+ 	 */
+ 	if (tp->t_mountp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC))
+ 		xfs_trans_set_sync(tp);
+ 
+ 	error = xfs_bmap_finish(&tp, free_list, &committed);
+ 	if (error) {
+ 		xfs_bmap_cancel(free_list);
+ 		xfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);
+ 		return error;
+ 	}
+ 
+ 	return xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);
+ }
+ 
 -/*
 - * xfs_cross_rename()
 - *
 - * responsible for handling RENAME_EXCHANGE flag in renameat2() sytemcall
 - */
 -STATIC int
 -xfs_cross_rename(
 -	struct xfs_trans	*tp,
 -	struct xfs_inode	*dp1,
 -	struct xfs_name		*name1,
 -	struct xfs_inode	*ip1,
 -	struct xfs_inode	*dp2,
 -	struct xfs_name		*name2,
 -	struct xfs_inode	*ip2,
 -	struct xfs_bmap_free	*free_list,
 -	xfs_fsblock_t		*first_block,
 -	int			spaceres)
 -{
 -	int		error = 0;
 -	int		ip1_flags = 0;
 -	int		ip2_flags = 0;
 -	int		dp2_flags = 0;
 -
 -	/* Swap inode number for dirent in first parent */
 -	error = xfs_dir_replace(tp, dp1, name1,
 -				ip2->i_ino,
 -				first_block, free_list, spaceres);
 -	if (error)
 -		goto out;
 -
 -	/* Swap inode number for dirent in second parent */
 -	error = xfs_dir_replace(tp, dp2, name2,
 -				ip1->i_ino,
 -				first_block, free_list, spaceres);
 -	if (error)
 -		goto out;
 -
 -	/*
 -	 * If we're renaming one or more directories across different parents,
 -	 * update the respective ".." entries (and link counts) to match the new
 -	 * parents.
 -	 */
 -	if (dp1 != dp2) {
 -		dp2_flags = XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG;
 -
 -		if (S_ISDIR(ip2->i_d.di_mode)) {
 -			error = xfs_dir_replace(tp, ip2, &xfs_name_dotdot,
 -						dp1->i_ino, first_block,
 -						free_list, spaceres);
 -			if (error)
 -				goto out;
 -
 -			/* transfer ip2 ".." reference to dp1 */
 -			if (!S_ISDIR(ip1->i_d.di_mode)) {
 -				error = xfs_droplink(tp, dp2);
 -				if (error)
 -					goto out;
 -				error = xfs_bumplink(tp, dp1);
 -				if (error)
 -					goto out;
 -			}
 -
 -			/*
 -			 * Although ip1 isn't changed here, userspace needs
 -			 * to be warned about the change, so that applications
 -			 * relying on it (like backup ones), will properly
 -			 * notify the change
 -			 */
 -			ip1_flags |= XFS_ICHGTIME_CHG;
 -			ip2_flags |= XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG;
 -		}
 -
 -		if (S_ISDIR(ip1->i_d.di_mode)) {
 -			error = xfs_dir_replace(tp, ip1, &xfs_name_dotdot,
 -						dp2->i_ino, first_block,
 -						free_list, spaceres);
 -			if (error)
 -				goto out;
 -
 -			/* transfer ip1 ".." reference to dp2 */
 -			if (!S_ISDIR(ip2->i_d.di_mode)) {
 -				error = xfs_droplink(tp, dp1);
 -				if (error)
 -					goto out;
 -				error = xfs_bumplink(tp, dp2);
 -				if (error)
 -					goto out;
 -			}
 -
 -			/*
 -			 * Although ip2 isn't changed here, userspace needs
 -			 * to be warned about the change, so that applications
 -			 * relying on it (like backup ones), will properly
 -			 * notify the change
 -			 */
 -			ip1_flags |= XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG;
 -			ip2_flags |= XFS_ICHGTIME_CHG;
 -		}
 -	}
 -
 -	if (ip1_flags) {
 -		xfs_trans_ichgtime(tp, ip1, ip1_flags);
 -		xfs_trans_log_inode(tp, ip1, XFS_ILOG_CORE);
 -	}
 -	if (ip2_flags) {
 -		xfs_trans_ichgtime(tp, ip2, ip2_flags);
 -		xfs_trans_log_inode(tp, ip2, XFS_ILOG_CORE);
 -	}
 -	if (dp2_flags) {
 -		xfs_trans_ichgtime(tp, dp2, dp2_flags);
 -		xfs_trans_log_inode(tp, dp2, XFS_ILOG_CORE);
 -	}
 -	xfs_trans_ichgtime(tp, dp1, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);
 -	xfs_trans_log_inode(tp, dp1, XFS_ILOG_CORE);
 -out:
 -	return error;
 -}
 -
  /*
   * xfs_rename
   */
@@@ -2761,8 -2813,7 +2786,12 @@@ xfs_rename
  	int		error;
  	xfs_bmap_free_t free_list;
  	xfs_fsblock_t   first_block;
++<<<<<<< HEAD
 +	int		cancel_flags;
 +	int		committed;
++=======
+ 	int		cancel_flags = 0;
++>>>>>>> 310606b0c7e3 (xfs: factor out xfs_finish_rename())
  	xfs_inode_t	*inodes[__XFS_SORT_INODES];
  	int		num_inodes = __XFS_SORT_INODES;
  	int		spaceres;
@@@ -2825,8 -2871,22 +2854,27 @@@
  	 */
  	if (unlikely((target_dp->i_d.di_flags & XFS_DIFLAG_PROJINHERIT) &&
  		     (xfs_get_projid(target_dp) != xfs_get_projid(src_ip)))) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(EXDEV);
 +		goto error_return;
++=======
+ 		error = -EXDEV;
+ 		goto out_trans_cancel;
+ 	}
+ 
+ 	xfs_bmap_init(&free_list, &first_block);
+ 
+ 	/*
+ 	 * Handle RENAME_EXCHANGE flags
+ 	 */
+ 	if (flags & RENAME_EXCHANGE) {
+ 		error = xfs_cross_rename(tp, src_dp, src_name, src_ip,
+ 					 target_dp, target_name, target_ip,
+ 					 &free_list, &first_block, spaceres);
+ 		if (error)
+ 			goto out_trans_abort;
+ 		return xfs_finish_rename(tp, &free_list);
++>>>>>>> 310606b0c7e3 (xfs: factor out xfs_finish_rename())
  	}
  
  	/*
@@@ -2968,35 -3028,14 +3016,39 @@@
  	if (new_parent)
  		xfs_trans_log_inode(tp, target_dp, XFS_ILOG_CORE);
  
++<<<<<<< HEAD
 +	/*
 +	 * If this is a synchronous mount, make sure that the
 +	 * rename transaction goes to disk before returning to
 +	 * the user.
 +	 */
 +	if (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC)) {
 +		xfs_trans_set_sync(tp);
 +	}
 +
 +	error = xfs_bmap_finish(&tp, &free_list, &committed);
 +	if (error) {
 +		xfs_bmap_cancel(&free_list);
 +		xfs_trans_cancel(tp, (XFS_TRANS_RELEASE_LOG_RES |
 +				 XFS_TRANS_ABORT));
 +		goto std_return;
 +	}
 +
 +	/*
 +	 * trans_commit will unlock src_ip, target_ip & decrement
 +	 * the vnode references.
 +	 */
 +	return xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);
++=======
+ 	return xfs_finish_rename(tp, &free_list);
++>>>>>>> 310606b0c7e3 (xfs: factor out xfs_finish_rename())
  
 -out_trans_abort:
 + abort_return:
  	cancel_flags |= XFS_TRANS_ABORT;
 -out_bmap_cancel:
 + error_return:
  	xfs_bmap_cancel(&free_list);
 -out_trans_cancel:
  	xfs_trans_cancel(tp, cancel_flags);
 + std_return:
  	return error;
  }
  
* Unmerged path fs/xfs/xfs_inode.c
