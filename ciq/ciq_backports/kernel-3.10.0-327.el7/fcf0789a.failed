ACPI / LPSS: provide con_id for the clkdev

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [acpi] lpss: provide con_id for the clkdev (Prarit Bhargava) [1178891]
Rebuild_FUZZ: 90.91%
commit-author Heikki Krogerus <heikki.krogerus@linux.intel.com>
commit fcf0789a96777d79d20290e08bf43943a5619387
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/fcf0789a.failed

Commit 7d78cbefaa (serial: 8250_dw: add ability to handle
the peripheral clock) introduces handling for a second clk
to 8250_dw.c which is the driver also for LPSS UART. The
second clk forces us to provide identifier (con_id) for the
clkdev we create.

This fixes an issue where 8250_dw.c is getting the same
handler for both clocks.

Fixes: 7d78cbefaa (serial: 8250_dw: add ability to handle the peripheral clock)
	Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
	Cc: 3.17+ <stable@vger.kernel.org> # 3.17+
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit fcf0789a96777d79d20290e08bf43943a5619387)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/acpi_lpss.c
diff --cc drivers/acpi/acpi_lpss.c
index f0e53f4c0453,37fb19047603..000000000000
--- a/drivers/acpi/acpi_lpss.c
+++ b/drivers/acpi/acpi_lpss.c
@@@ -52,13 -64,10 +52,18 @@@ struct lpss_shared_clock 
  struct lpss_private_data;
  
  struct lpss_device_desc {
++<<<<<<< HEAD
 +	bool clk_required;
 +	const char *clkdev_name;
 +	bool ltr_required;
++=======
+ 	unsigned int flags;
+ 	const char *clk_con_id;
++>>>>>>> fcf0789a9677 (ACPI / LPSS: provide con_id for the clkdev)
  	unsigned int prv_offset;
  	size_t prv_size_override;
 +	bool clk_gate;
 +	struct lpss_shared_clock *shared_clock;
  	void (*setup)(struct lpss_private_data *pdata);
  };
  
@@@ -104,10 -140,9 +109,15 @@@ static struct lpss_device_desc lpt_dev_
  };
  
  static struct lpss_device_desc lpt_uart_dev_desc = {
++<<<<<<< HEAD
 +	.clk_required = true,
++=======
+ 	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_LTR,
+ 	.clk_con_id = "baudclk",
++>>>>>>> fcf0789a9677 (ACPI / LPSS: provide con_id for the clkdev)
  	.prv_offset = 0x800,
 +	.ltr_required = true,
 +	.clk_gate = true,
  	.setup = lpss_uart_setup,
  };
  
@@@ -123,10 -157,9 +133,15 @@@ static struct lpss_shared_clock uart_cl
  };
  
  static struct lpss_device_desc byt_uart_dev_desc = {
++<<<<<<< HEAD
 +	.clk_required = true,
++=======
+ 	.flags = LPSS_CLK | LPSS_CLK_GATE | LPSS_CLK_DIVIDER | LPSS_SAVE_CTX,
+ 	.clk_con_id = "baudclk",
++>>>>>>> fcf0789a9677 (ACPI / LPSS: provide con_id for the clkdev)
  	.prv_offset = 0x800,
 +	.clk_gate = true,
 +	.shared_clock = &uart_clock,
  	.setup = lpss_uart_setup,
  };
  
@@@ -244,7 -290,33 +259,12 @@@ static int register_device_clock(struc
  	if (IS_ERR(clk))
  		return PTR_ERR(clk);
  
++<<<<<<< HEAD
 +	clk_register_clkdev(clk, NULL, dev_name(&adev->dev));
++=======
+ 	pdata->clk = clk;
+ 	clk_register_clkdev(clk, dev_desc->clk_con_id, devname);
++>>>>>>> fcf0789a9677 (ACPI / LPSS: provide con_id for the clkdev)
  	return 0;
  }
  
* Unmerged path drivers/acpi/acpi_lpss.c
