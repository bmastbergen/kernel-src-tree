fib_trie: Move parent from key_vector to tnode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Alexander Duyck <alexander.h.duyck@redhat.com>
commit f23e59fbd77054d9e555ef398bb918320f9319e2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/f23e59fb.failed

This change pulls the parent pointer from the key_vector and places it in
the tnode structure.

	Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f23e59fbd77054d9e555ef398bb918320f9319e2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/fib_trie.c
diff --cc net/ipv4/fib_trie.c
index 8be89b1a8b93,b5fed2f5ef9e..000000000000
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@@ -91,35 -92,31 +91,47 @@@ typedef unsigned int t_key
  #define IS_TNODE(n) ((n)->bits)
  #define IS_LEAF(n) (!(n)->bits)
  
++<<<<<<< HEAD
 +#define get_index(_key, _kv) (((_key) ^ (_kv)->key) >> (_kv)->pos)
 +
 +struct tnode {
++=======
+ struct key_vector {
++>>>>>>> f23e59fbd770 (fib_trie: Move parent from key_vector to tnode)
  	t_key key;
 -	unsigned char pos;		/* 2log(KEYLENGTH) bits needed */
  	unsigned char bits;		/* 2log(KEYLENGTH) bits needed */
 +	unsigned char pos;		/* 2log(KEYLENGTH) bits needed */
  	unsigned char slen;
 +	struct tnode __rcu *parent;
 +	struct rcu_head rcu;
  	union {
 -		/* This list pointer if valid if (pos | bits) == 0 (LEAF) */
 -		struct hlist_head leaf;
 -		/* This array is valid if (pos | bits) > 0 (TNODE) */
 -		struct key_vector __rcu *tnode[0];
 +		/* The fields in this struct are valid if bits > 0 (TNODE) */
 +		struct {
 +			t_key empty_children; /* KEYLENGTH bits needed */
 +			t_key full_children;  /* KEYLENGTH bits needed */
 +			struct tnode __rcu *child[0];
 +		};
 +		/* This list pointer if valid if bits == 0 (LEAF) */
 +		struct hlist_head list;
  	};
  };
  
 -struct tnode {
 +struct leaf_info {
 +	struct hlist_node hlist;
 +	int plen;
 +	u32 mask_plen; /* ntohl(inet_make_mask(plen)) */
 +	struct list_head falh;
  	struct rcu_head rcu;
++<<<<<<< HEAD
++=======
+ 	t_key empty_children;		/* KEYLENGTH bits needed */
+ 	t_key full_children;		/* KEYLENGTH bits needed */
+ 	struct key_vector __rcu *parent;
+ 	struct key_vector kv[1];
+ #define tn_bits kv[0].bits
++>>>>>>> f23e59fbd770 (fib_trie: Move parent from key_vector to tnode)
  };
  
 -#define TNODE_SIZE(n)	offsetof(struct tnode, kv[0].tnode[n])
 -#define LEAF_SIZE	TNODE_SIZE(1)
 -
  #ifdef CONFIG_IP_FIB_TRIE_STATS
  struct trie_use_stats {
  	unsigned int gets;
@@@ -161,20 -158,27 +173,29 @@@ static const int sync_pages = 128
  static struct kmem_cache *fn_alias_kmem __read_mostly;
  static struct kmem_cache *trie_leaf_kmem __read_mostly;
  
 -static inline struct tnode *tn_info(struct key_vector *kv)
 -{
 -	return container_of(kv, struct tnode, kv[0]);
 -}
 -
  /* caller must hold RTNL */
++<<<<<<< HEAD
 +#define node_parent(n) rtnl_dereference((n)->parent)
 +
 +/* caller must hold RCU read lock or RTNL */
 +#define node_parent_rcu(n) rcu_dereference_rtnl((n)->parent)
++=======
+ #define node_parent(tn) rtnl_dereference(tn_info(tn)->parent)
+ #define get_child(tn, i) rtnl_dereference((tn)->tnode[i])
+ 
+ /* caller must hold RCU read lock or RTNL */
+ #define node_parent_rcu(tn) rcu_dereference_rtnl(tn_info(tn)->parent)
+ #define get_child_rcu(tn, i) rcu_dereference_rtnl((tn)->tnode[i])
++>>>>>>> f23e59fbd770 (fib_trie: Move parent from key_vector to tnode)
  
  /* wrapper for rcu_assign_pointer */
 -static inline void node_set_parent(struct key_vector *n, struct key_vector *tp)
 +static inline void node_set_parent(struct tnode *n, struct tnode *tp)
  {
  	if (n)
- 		rcu_assign_pointer(n->parent, tp);
+ 		rcu_assign_pointer(tn_info(n)->parent, tp);
  }
  
- #define NODE_INIT_PARENT(n, p) RCU_INIT_POINTER((n)->parent, p)
+ #define NODE_INIT_PARENT(n, p) RCU_INIT_POINTER(tn_info(n)->parent, p)
  
  /* This provides us with the number of children in this node, in the case of a
   * leaf this will return 0 meaning none of the children are accessible.
* Unmerged path net/ipv4/fib_trie.c
