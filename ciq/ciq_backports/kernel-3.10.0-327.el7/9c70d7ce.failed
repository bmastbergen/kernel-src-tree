i40e: fix 32 bit build warnings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Jesse Brandeburg <jesse.brandeburg@intel.com>
commit 9c70d7cebfec558e07a2ab0f2d5f5a80a821ecf5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/9c70d7ce.failed

Sparse found some issues with 32 bit compilation, which probably should
at least work without warning.  Not only that, but the code was wrong.
Thanks sparse!!

And thanks to the kbuild robot zero day testing for finding this issue.

$ make ARCH=i386 M=drivers/net/ethernet/intel/i40e C=2 CF="-D__CHECK_ENDIAN__"
  CHECK   drivers/net/ethernet/intel/i40e/i40e_main.c
  include/linux/etherdevice.h:79:32: warning: restricted __be16 degrades to integer
  drivers/net/ethernet/intel/i40e/i40e_main.c:7565:17: warning: shift too big (32) for type unsigned long
  drivers/net/ethernet/intel/i40e/i40e_main.c:7565:17: warning: shift too big (42) for type unsigned long
  drivers/net/ethernet/intel/i40e/i40e_main.c:7565:17: warning: shift too big (39) for type unsigned long
  drivers/net/ethernet/intel/i40e/i40e_main.c:7565:17: warning: shift too big (40) for type unsigned long

CC: kbuild-all@01.org
	Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
	Reported-by: kbuild test robot <fengguang.wu@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 9c70d7cebfec558e07a2ab0f2d5f5a80a821ecf5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_common.c
#	drivers/net/ethernet/intel/i40e/i40e_txrx.h
diff --cc drivers/net/ethernet/intel/i40e/i40e_common.c
index 022386632694,683371763293..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_common.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_common.c
@@@ -187,6 -393,164 +187,167 @@@ i40e_status i40e_aq_queue_shutdown(stru
  	return status;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * i40e_aq_get_set_rss_lut
+  * @hw: pointer to the hardware structure
+  * @vsi_id: vsi fw index
+  * @pf_lut: for PF table set true, for VSI table set false
+  * @lut: pointer to the lut buffer provided by the caller
+  * @lut_size: size of the lut buffer
+  * @set: set true to set the table, false to get the table
+  *
+  * Internal function to get or set RSS look up table
+  **/
+ static i40e_status i40e_aq_get_set_rss_lut(struct i40e_hw *hw,
+ 					   u16 vsi_id, bool pf_lut,
+ 					   u8 *lut, u16 lut_size,
+ 					   bool set)
+ {
+ 	i40e_status status;
+ 	struct i40e_aq_desc desc;
+ 	struct i40e_aqc_get_set_rss_lut *cmd_resp =
+ 		   (struct i40e_aqc_get_set_rss_lut *)&desc.params.raw;
+ 
+ 	if (set)
+ 		i40e_fill_default_direct_cmd_desc(&desc,
+ 						  i40e_aqc_opc_set_rss_lut);
+ 	else
+ 		i40e_fill_default_direct_cmd_desc(&desc,
+ 						  i40e_aqc_opc_get_rss_lut);
+ 
+ 	/* Indirect command */
+ 	desc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_BUF);
+ 	desc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_RD);
+ 
+ 	cmd_resp->vsi_id =
+ 			cpu_to_le16((u16)((vsi_id <<
+ 					  I40E_AQC_SET_RSS_LUT_VSI_ID_SHIFT) &
+ 					  I40E_AQC_SET_RSS_LUT_VSI_ID_MASK));
+ 	cmd_resp->vsi_id |= cpu_to_le16((u16)I40E_AQC_SET_RSS_LUT_VSI_VALID);
+ 
+ 	if (pf_lut)
+ 		cmd_resp->flags |= cpu_to_le16((u16)
+ 					((I40E_AQC_SET_RSS_LUT_TABLE_TYPE_PF <<
+ 					I40E_AQC_SET_RSS_LUT_TABLE_TYPE_SHIFT) &
+ 					I40E_AQC_SET_RSS_LUT_TABLE_TYPE_MASK));
+ 	else
+ 		cmd_resp->flags |= cpu_to_le16((u16)
+ 					((I40E_AQC_SET_RSS_LUT_TABLE_TYPE_VSI <<
+ 					I40E_AQC_SET_RSS_LUT_TABLE_TYPE_SHIFT) &
+ 					I40E_AQC_SET_RSS_LUT_TABLE_TYPE_MASK));
+ 
+ 	status = i40e_asq_send_command(hw, &desc, lut, lut_size, NULL);
+ 
+ 	return status;
+ }
+ 
+ /**
+  * i40e_aq_get_rss_lut
+  * @hw: pointer to the hardware structure
+  * @vsi_id: vsi fw index
+  * @pf_lut: for PF table set true, for VSI table set false
+  * @lut: pointer to the lut buffer provided by the caller
+  * @lut_size: size of the lut buffer
+  *
+  * get the RSS lookup table, PF or VSI type
+  **/
+ i40e_status i40e_aq_get_rss_lut(struct i40e_hw *hw, u16 vsi_id,
+ 				bool pf_lut, u8 *lut, u16 lut_size)
+ {
+ 	return i40e_aq_get_set_rss_lut(hw, vsi_id, pf_lut, lut, lut_size,
+ 				       false);
+ }
+ 
+ /**
+  * i40e_aq_set_rss_lut
+  * @hw: pointer to the hardware structure
+  * @vsi_id: vsi fw index
+  * @pf_lut: for PF table set true, for VSI table set false
+  * @lut: pointer to the lut buffer provided by the caller
+  * @lut_size: size of the lut buffer
+  *
+  * set the RSS lookup table, PF or VSI type
+  **/
+ i40e_status i40e_aq_set_rss_lut(struct i40e_hw *hw, u16 vsi_id,
+ 				bool pf_lut, u8 *lut, u16 lut_size)
+ {
+ 	return i40e_aq_get_set_rss_lut(hw, vsi_id, pf_lut, lut, lut_size, true);
+ }
+ 
+ /**
+  * i40e_aq_get_set_rss_key
+  * @hw: pointer to the hw struct
+  * @vsi_id: vsi fw index
+  * @key: pointer to key info struct
+  * @set: set true to set the key, false to get the key
+  *
+  * get the RSS key per VSI
+  **/
+ static i40e_status i40e_aq_get_set_rss_key(struct i40e_hw *hw,
+ 				      u16 vsi_id,
+ 				      struct i40e_aqc_get_set_rss_key_data *key,
+ 				      bool set)
+ {
+ 	i40e_status status;
+ 	struct i40e_aq_desc desc;
+ 	struct i40e_aqc_get_set_rss_key *cmd_resp =
+ 			(struct i40e_aqc_get_set_rss_key *)&desc.params.raw;
+ 	u16 key_size = sizeof(struct i40e_aqc_get_set_rss_key_data);
+ 
+ 	if (set)
+ 		i40e_fill_default_direct_cmd_desc(&desc,
+ 						  i40e_aqc_opc_set_rss_key);
+ 	else
+ 		i40e_fill_default_direct_cmd_desc(&desc,
+ 						  i40e_aqc_opc_get_rss_key);
+ 
+ 	/* Indirect command */
+ 	desc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_BUF);
+ 	desc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_RD);
+ 
+ 	cmd_resp->vsi_id =
+ 			cpu_to_le16((u16)((vsi_id <<
+ 					  I40E_AQC_SET_RSS_KEY_VSI_ID_SHIFT) &
+ 					  I40E_AQC_SET_RSS_KEY_VSI_ID_MASK));
+ 	cmd_resp->vsi_id |= cpu_to_le16((u16)I40E_AQC_SET_RSS_KEY_VSI_VALID);
+ 
+ 	status = i40e_asq_send_command(hw, &desc, key, key_size, NULL);
+ 
+ 	return status;
+ }
+ 
+ /**
+  * i40e_aq_get_rss_key
+  * @hw: pointer to the hw struct
+  * @vsi_id: vsi fw index
+  * @key: pointer to key info struct
+  *
+  **/
+ i40e_status i40e_aq_get_rss_key(struct i40e_hw *hw,
+ 				u16 vsi_id,
+ 				struct i40e_aqc_get_set_rss_key_data *key)
+ {
+ 	return i40e_aq_get_set_rss_key(hw, vsi_id, key, false);
+ }
+ 
+ /**
+  * i40e_aq_set_rss_key
+  * @hw: pointer to the hw struct
+  * @vsi_id: vsi fw index
+  * @key: pointer to key info struct
+  *
+  * set the RSS key per VSI
+  **/
+ i40e_status i40e_aq_set_rss_key(struct i40e_hw *hw,
+ 				u16 vsi_id,
+ 				struct i40e_aqc_get_set_rss_key_data *key)
+ {
+ 	return i40e_aq_get_set_rss_key(hw, vsi_id, key, true);
+ }
+ 
++>>>>>>> 9c70d7cebfec (i40e: fix 32 bit build warnings)
  /* The i40e_ptype_lookup table is used to convert from the 8-bit ptype in the
   * hardware to a bit-field that can be used by SW to more easily determine the
   * packet type.
diff --cc drivers/net/ethernet/intel/i40e/i40e_txrx.h
index dc8d49cc8926,7c9975c983d9..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.h
+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.h
@@@ -66,17 -66,29 +66,43 @@@ enum i40e_dyn_idx_t 
  
  /* Supported RSS offloads */
  #define I40E_DEFAULT_RSS_HENA ( \
++<<<<<<< HEAD
 +	((u64)1 << I40E_FILTER_PCTYPE_NONF_IPV4_UDP) | \
 +	((u64)1 << I40E_FILTER_PCTYPE_NONF_IPV4_SCTP) | \
 +	((u64)1 << I40E_FILTER_PCTYPE_NONF_IPV4_TCP) | \
 +	((u64)1 << I40E_FILTER_PCTYPE_NONF_IPV4_OTHER) | \
 +	((u64)1 << I40E_FILTER_PCTYPE_FRAG_IPV4) | \
 +	((u64)1 << I40E_FILTER_PCTYPE_NONF_IPV6_UDP) | \
 +	((u64)1 << I40E_FILTER_PCTYPE_NONF_IPV6_TCP) | \
 +	((u64)1 << I40E_FILTER_PCTYPE_NONF_IPV6_SCTP) | \
 +	((u64)1 << I40E_FILTER_PCTYPE_NONF_IPV6_OTHER) | \
 +	((u64)1 << I40E_FILTER_PCTYPE_FRAG_IPV6) | \
 +	((u64)1 << I40E_FILTER_PCTYPE_L2_PAYLOAD))
++=======
+ 	BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV4_UDP) | \
+ 	BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV4_SCTP) | \
+ 	BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV4_TCP) | \
+ 	BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV4_OTHER) | \
+ 	BIT_ULL(I40E_FILTER_PCTYPE_FRAG_IPV4) | \
+ 	BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV6_UDP) | \
+ 	BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV6_TCP) | \
+ 	BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV6_SCTP) | \
+ 	BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV6_OTHER) | \
+ 	BIT_ULL(I40E_FILTER_PCTYPE_FRAG_IPV6) | \
+ 	BIT_ULL(I40E_FILTER_PCTYPE_L2_PAYLOAD))
+ 
+ #define I40E_DEFAULT_RSS_HENA_EXPANDED (I40E_DEFAULT_RSS_HENA | \
+ 	BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV4_TCP_SYN_NO_ACK) | \
+ 	BIT_ULL(I40E_FILTER_PCTYPE_NONF_UNICAST_IPV4_UDP) | \
+ 	BIT_ULL(I40E_FILTER_PCTYPE_NONF_MULTICAST_IPV4_UDP) | \
+ 	BIT_ULL(I40E_FILTER_PCTYPE_NONF_IPV6_TCP_SYN_NO_ACK) | \
+ 	BIT_ULL(I40E_FILTER_PCTYPE_NONF_UNICAST_IPV6_UDP) | \
+ 	BIT_ULL(I40E_FILTER_PCTYPE_NONF_MULTICAST_IPV6_UDP))
+ 
+ #define i40e_pf_get_default_rss_hena(pf) \
+ 	(((pf)->flags & I40E_FLAG_MULTIPLE_TCP_UDP_RSS_PCTYPE) ? \
+ 	  I40E_DEFAULT_RSS_HENA_EXPANDED : I40E_DEFAULT_RSS_HENA)
++>>>>>>> 9c70d7cebfec (i40e: fix 32 bit build warnings)
  
  /* Supported Rx Buffer Sizes */
  #define I40E_RXBUFFER_512   512    /* Used for packet split */
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_common.c
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_txrx.h
