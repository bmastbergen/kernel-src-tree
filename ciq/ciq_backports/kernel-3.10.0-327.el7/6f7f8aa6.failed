sfc: Bind the sfc driver to any available VF's

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Shradha Shah <sshah@solarflare.com>
commit 6f7f8aa69acb391ba98f5186ca09434d9d0f52ee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/6f7f8aa6.failed

Add the device ID of the VF to the PCI device ID table.

Added a boolean flag is_vf in efx_nic_type to differentiate
between a VF and PF at probe time. This flag is useful in later
patches while setting MAC address specially in the
PCI-passthrough case.

	Signed-off-by: Shradha Shah <sshah@solarflare.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6f7f8aa69acb391ba98f5186ca09434d9d0f52ee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/sfc/ef10.c
#	drivers/net/ethernet/sfc/efx.c
#	drivers/net/ethernet/sfc/falcon.c
#	drivers/net/ethernet/sfc/net_driver.h
#	drivers/net/ethernet/sfc/siena.c
diff --cc drivers/net/ethernet/sfc/ef10.c
index cd683661ffb0,882117a43c3a..000000000000
--- a/drivers/net/ethernet/sfc/ef10.c
+++ b/drivers/net/ethernet/sfc/ef10.c
@@@ -3633,9 -3809,109 +3633,113 @@@ static int efx_ef10_ptp_set_ts_config(s
  	}
  }
  
++<<<<<<< HEAD
 +const struct efx_nic_type efx_hunt_a0_nic_type = {
++=======
+ const struct efx_nic_type efx_hunt_a0_vf_nic_type = {
+ 	.is_vf = true,
+ 	.mem_bar = EFX_MEM_VF_BAR,
+ 	.mem_map_size = efx_ef10_mem_map_size,
+ 	.probe = efx_ef10_probe_vf,
+ 	.remove = efx_ef10_remove,
+ 	.dimension_resources = efx_ef10_dimension_resources,
+ 	.init = efx_ef10_init_nic,
+ 	.fini = efx_port_dummy_op_void,
+ 	.map_reset_reason = efx_mcdi_map_reset_reason,
+ 	.map_reset_flags = efx_ef10_map_reset_flags,
+ 	.reset = efx_ef10_reset,
+ 	.probe_port = efx_mcdi_port_probe,
+ 	.remove_port = efx_mcdi_port_remove,
+ 	.fini_dmaq = efx_ef10_fini_dmaq,
+ 	.prepare_flr = efx_ef10_prepare_flr,
+ 	.finish_flr = efx_port_dummy_op_void,
+ 	.describe_stats = efx_ef10_describe_stats,
+ 	.update_stats = efx_ef10_update_stats,
+ 	.start_stats = efx_port_dummy_op_void,
+ 	.pull_stats = efx_port_dummy_op_void,
+ 	.stop_stats = efx_port_dummy_op_void,
+ 	.set_id_led = efx_mcdi_set_id_led,
+ 	.push_irq_moderation = efx_ef10_push_irq_moderation,
+ 	.reconfigure_mac = efx_ef10_mac_reconfigure,
+ 	.check_mac_fault = efx_mcdi_mac_check_fault,
+ 	.reconfigure_port = efx_mcdi_port_reconfigure,
+ 	.get_wol = efx_ef10_get_wol_vf,
+ 	.set_wol = efx_ef10_set_wol_vf,
+ 	.resume_wol = efx_port_dummy_op_void,
+ 	.mcdi_request = efx_ef10_mcdi_request,
+ 	.mcdi_poll_response = efx_ef10_mcdi_poll_response,
+ 	.mcdi_read_response = efx_ef10_mcdi_read_response,
+ 	.mcdi_poll_reboot = efx_ef10_mcdi_poll_reboot,
+ 	.irq_enable_master = efx_port_dummy_op_void,
+ 	.irq_test_generate = efx_ef10_irq_test_generate,
+ 	.irq_disable_non_ev = efx_port_dummy_op_void,
+ 	.irq_handle_msi = efx_ef10_msi_interrupt,
+ 	.irq_handle_legacy = efx_ef10_legacy_interrupt,
+ 	.tx_probe = efx_ef10_tx_probe,
+ 	.tx_init = efx_ef10_tx_init,
+ 	.tx_remove = efx_ef10_tx_remove,
+ 	.tx_write = efx_ef10_tx_write,
+ 	.rx_push_rss_config = efx_ef10_vf_rx_push_rss_config,
+ 	.rx_probe = efx_ef10_rx_probe,
+ 	.rx_init = efx_ef10_rx_init,
+ 	.rx_remove = efx_ef10_rx_remove,
+ 	.rx_write = efx_ef10_rx_write,
+ 	.rx_defer_refill = efx_ef10_rx_defer_refill,
+ 	.ev_probe = efx_ef10_ev_probe,
+ 	.ev_init = efx_ef10_ev_init,
+ 	.ev_fini = efx_ef10_ev_fini,
+ 	.ev_remove = efx_ef10_ev_remove,
+ 	.ev_process = efx_ef10_ev_process,
+ 	.ev_read_ack = efx_ef10_ev_read_ack,
+ 	.ev_test_generate = efx_ef10_ev_test_generate,
+ 	.filter_table_probe = efx_ef10_filter_table_probe,
+ 	.filter_table_restore = efx_ef10_filter_table_restore,
+ 	.filter_table_remove = efx_ef10_filter_table_remove,
+ 	.filter_update_rx_scatter = efx_ef10_filter_update_rx_scatter,
+ 	.filter_insert = efx_ef10_filter_insert,
+ 	.filter_remove_safe = efx_ef10_filter_remove_safe,
+ 	.filter_get_safe = efx_ef10_filter_get_safe,
+ 	.filter_clear_rx = efx_ef10_filter_clear_rx,
+ 	.filter_count_rx_used = efx_ef10_filter_count_rx_used,
+ 	.filter_get_rx_id_limit = efx_ef10_filter_get_rx_id_limit,
+ 	.filter_get_rx_ids = efx_ef10_filter_get_rx_ids,
+ #ifdef CONFIG_RFS_ACCEL
+ 	.filter_rfs_insert = efx_ef10_filter_rfs_insert,
+ 	.filter_rfs_expire_one = efx_ef10_filter_rfs_expire_one,
+ #endif
+ #ifdef CONFIG_SFC_MTD
+ 	.mtd_probe = efx_port_dummy_op_int,
+ #endif
+ 	.ptp_write_host_time = efx_ef10_ptp_write_host_time_vf,
+ 	.ptp_set_ts_config = efx_ef10_ptp_set_ts_config_vf,
+ #ifdef CONFIG_SFC_SRIOV
+ 	.vswitching_probe = efx_ef10_vswitching_probe_vf,
+ 	.vswitching_restore = efx_ef10_vswitching_restore_vf,
+ 	.vswitching_remove = efx_ef10_vswitching_remove_vf,
+ #endif
+ 	.revision = EFX_REV_HUNT_A0,
+ 	.max_dma_mask = DMA_BIT_MASK(ESF_DZ_TX_KER_BUF_ADDR_WIDTH),
+ 	.rx_prefix_size = ES_DZ_RX_PREFIX_SIZE,
+ 	.rx_hash_offset = ES_DZ_RX_PREFIX_HASH_OFST,
+ 	.rx_ts_offset = ES_DZ_RX_PREFIX_TSTAMP_OFST,
+ 	.can_rx_scatter = true,
+ 	.always_rx_scatter = true,
+ 	.max_interrupt_mode = EFX_INT_MODE_MSIX,
+ 	.timer_period_max = 1 << ERF_DD_EVQ_IND_TIMER_VAL_WIDTH,
+ 	.offload_features = (NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
+ 			     NETIF_F_RXHASH | NETIF_F_NTUPLE),
+ 	.mcdi_max_ver = 2,
+ 	.max_rx_ip_filters = HUNT_FILTER_TBL_ROWS,
+ 	.hwtstamp_filters = 1 << HWTSTAMP_FILTER_NONE |
+ 			    1 << HWTSTAMP_FILTER_ALL,
+ };
+ 
+ const struct efx_nic_type efx_hunt_a0_nic_type = {
+ 	.is_vf = false,
+ 	.mem_bar = EFX_MEM_BAR,
++>>>>>>> 6f7f8aa69acb (sfc: Bind the sfc driver to any available VF's)
  	.mem_map_size = efx_ef10_mem_map_size,
 -	.probe = efx_ef10_probe_pf,
 +	.probe = efx_ef10_probe,
  	.remove = efx_ef10_remove,
  	.dimension_resources = efx_ef10_dimension_resources,
  	.init = efx_ef10_init_nic,
diff --cc drivers/net/ethernet/sfc/efx.c
index 9557690dd00f,0f127a01b5e8..000000000000
--- a/drivers/net/ethernet/sfc/efx.c
+++ b/drivers/net/ethernet/sfc/efx.c
@@@ -1436,8 -1450,10 +1436,12 @@@ static int efx_probe_interrupts(struct 
  		efx->rss_spread = ((efx->n_rx_channels > 1 ||
  				    !efx->type->sriov_wanted(efx)) ?
  				   efx->n_rx_channels : efx_vf_size(efx));
 -		return 0;
  	}
  #endif
++<<<<<<< HEAD
++=======
+ 	efx->rss_spread = efx->n_rx_channels;
++>>>>>>> 6f7f8aa69acb (sfc: Bind the sfc driver to any available VF's)
  
  	return 0;
  }
diff --cc drivers/net/ethernet/sfc/falcon.c
index 157037546d30,80e69af21642..000000000000
--- a/drivers/net/ethernet/sfc/falcon.c
+++ b/drivers/net/ethernet/sfc/falcon.c
@@@ -2687,6 -2700,8 +2687,11 @@@ static int falcon_set_wol(struct efx_ni
   */
  
  const struct efx_nic_type falcon_a1_nic_type = {
++<<<<<<< HEAD
++=======
+ 	.is_vf = false,
+ 	.mem_bar = EFX_MEM_BAR,
++>>>>>>> 6f7f8aa69acb (sfc: Bind the sfc driver to any available VF's)
  	.mem_map_size = falcon_a1_mem_map_size,
  	.probe = falcon_probe_nic,
  	.remove = falcon_remove_nic,
@@@ -2783,6 -2798,8 +2788,11 @@@
  };
  
  const struct efx_nic_type falcon_b0_nic_type = {
++<<<<<<< HEAD
++=======
+ 	.is_vf = false,
+ 	.mem_bar = EFX_MEM_BAR,
++>>>>>>> 6f7f8aa69acb (sfc: Bind the sfc driver to any available VF's)
  	.mem_map_size = falcon_b0_mem_map_size,
  	.probe = falcon_probe_nic,
  	.remove = falcon_remove_nic,
diff --cc drivers/net/ethernet/sfc/net_driver.h
index a6f4d9aadd40,031a3385ad4b..000000000000
--- a/drivers/net/ethernet/sfc/net_driver.h
+++ b/drivers/net/ethernet/sfc/net_driver.h
@@@ -1226,6 -1224,8 +1226,11 @@@ struct efx_mtd_partition 
   * @hwtstamp_filters: Mask of hardware timestamp filter types supported
   */
  struct efx_nic_type {
++<<<<<<< HEAD
++=======
+ 	bool is_vf;
+ 	unsigned int mem_bar;
++>>>>>>> 6f7f8aa69acb (sfc: Bind the sfc driver to any available VF's)
  	unsigned int (*mem_map_size)(struct efx_nic *efx);
  	int (*probe)(struct efx_nic *efx);
  	void (*remove)(struct efx_nic *efx);
diff --cc drivers/net/ethernet/sfc/siena.c
index 49792287dd67,8b4130abad66..000000000000
--- a/drivers/net/ethernet/sfc/siena.c
+++ b/drivers/net/ethernet/sfc/siena.c
@@@ -911,6 -917,8 +911,11 @@@ fail
   */
  
  const struct efx_nic_type siena_a0_nic_type = {
++<<<<<<< HEAD
++=======
+ 	.is_vf = false,
+ 	.mem_bar = EFX_MEM_BAR,
++>>>>>>> 6f7f8aa69acb (sfc: Bind the sfc driver to any available VF's)
  	.mem_map_size = siena_mem_map_size,
  	.probe = siena_probe_nic,
  	.remove = siena_remove_nic,
* Unmerged path drivers/net/ethernet/sfc/ef10.c
* Unmerged path drivers/net/ethernet/sfc/efx.c
* Unmerged path drivers/net/ethernet/sfc/falcon.c
diff --git a/drivers/net/ethernet/sfc/mcdi.c b/drivers/net/ethernet/sfc/mcdi.c
index 1ffe289313f1..b44ee31f1a7a 100644
--- a/drivers/net/ethernet/sfc/mcdi.c
+++ b/drivers/net/ethernet/sfc/mcdi.c
@@ -1186,16 +1186,6 @@ static int efx_mcdi_drv_attach(struct efx_nic *efx, bool driver_operating,
 	 * and are completely trusted by firmware.  Abort probing
 	 * if that's not true for this function.
 	 */
-	if (driver_operating &&
-	    (efx->mcdi->fn_flags &
-	     (1 << MC_CMD_DRV_ATTACH_EXT_OUT_FLAG_LINKCTRL |
-	      1 << MC_CMD_DRV_ATTACH_EXT_OUT_FLAG_TRUSTED)) !=
-	    (1 << MC_CMD_DRV_ATTACH_EXT_OUT_FLAG_LINKCTRL |
-	     1 << MC_CMD_DRV_ATTACH_EXT_OUT_FLAG_TRUSTED)) {
-		netif_err(efx, probe, efx->net_dev,
-			  "This driver version only supports one function per port\n");
-		return -ENODEV;
-	}
 
 	if (was_attached != NULL)
 		*was_attached = MCDI_DWORD(outbuf, DRV_ATTACH_OUT_OLD_STATE);
* Unmerged path drivers/net/ethernet/sfc/net_driver.h
* Unmerged path drivers/net/ethernet/sfc/siena.c
