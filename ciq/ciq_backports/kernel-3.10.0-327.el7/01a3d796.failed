if_link: Add an additional parameter to ifla_vf_info for RSS querying

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Vlad Zolotarov <vladz@cloudius-systems.com>
commit 01a3d796813d6302af9f828f34b73d21a4b96c9a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/01a3d796.failed

Add configuration setting for drivers to allow/block an RSS Redirection
Table and a Hash Key querying for discrete VFs.

On some devices VF share the mentioned above information with PF and
querying it may adduce a theoretical security risk. We want to let a
system administrator to decide if he/she wants to take this risk or not.

	Signed-off-by: Vlad Zolotarov <vladz@cloudius-systems.com>
	Tested-by: Phil Schmitt <phillip.j.schmitt@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 01a3d796813d6302af9f828f34b73d21a4b96c9a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/if_link.h
#	include/uapi/linux/if_link.h
#	net/core/rtnetlink.c
diff --cc include/linux/if_link.h
index a86784dec3d3,da4929927f69..000000000000
--- a/include/linux/if_link.h
+++ b/include/linux/if_link.h
@@@ -10,8 -10,10 +10,14 @@@ struct ifla_vf_info 
  	__u8 mac[32];
  	__u32 vlan;
  	__u32 qos;
 +	__u32 tx_rate;
  	__u32 spoofchk;
  	__u32 linkstate;
++<<<<<<< HEAD
++=======
+ 	__u32 min_tx_rate;
+ 	__u32 max_tx_rate;
+ 	__u32 rss_query_en;
++>>>>>>> 01a3d796813d (if_link: Add an additional parameter to ifla_vf_info for RSS querying)
  };
  #endif /* _LINUX_IF_LINK_H */
diff --cc include/uapi/linux/if_link.h
index 4efe6bcb6e67,d9cd19214b98..000000000000
--- a/include/uapi/linux/if_link.h
+++ b/include/uapi/linux/if_link.h
@@@ -359,9 -461,13 +359,16 @@@ enum 
  	IFLA_VF_UNSPEC,
  	IFLA_VF_MAC,		/* Hardware queue specific attributes */
  	IFLA_VF_VLAN,
 -	IFLA_VF_TX_RATE,	/* Max TX Bandwidth Allocation */
 +	IFLA_VF_TX_RATE,	/* TX Bandwidth Allocation */
  	IFLA_VF_SPOOFCHK,	/* Spoof Checking on/off switch */
  	IFLA_VF_LINK_STATE,	/* link state enable/disable/auto switch */
++<<<<<<< HEAD
++=======
+ 	IFLA_VF_RATE,		/* Min and Max TX Bandwidth Allocation */
+ 	IFLA_VF_RSS_QUERY_EN,	/* RSS Redirection Table and Hash Key query
+ 				 * on/off switch
+ 				 */
++>>>>>>> 01a3d796813d (if_link: Add an additional parameter to ifla_vf_info for RSS querying)
  	__IFLA_VF_MAX,
  };
  
diff --cc net/core/rtnetlink.c
index 84ac04f7b576,358d52a38533..000000000000
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@@ -743,9 -816,10 +743,15 @@@ static inline int rtnl_vfinfo_size(cons
  		size += num_vfs *
  			(nla_total_size(sizeof(struct ifla_vf_mac)) +
  			 nla_total_size(sizeof(struct ifla_vf_vlan)) +
 +			 nla_total_size(sizeof(struct ifla_vf_tx_rate)) +
  			 nla_total_size(sizeof(struct ifla_vf_spoofchk)) +
++<<<<<<< HEAD
 +			 nla_total_size(sizeof(struct ifla_vf_link_state)));
++=======
+ 			 nla_total_size(sizeof(struct ifla_vf_rate)) +
+ 			 nla_total_size(sizeof(struct ifla_vf_link_state)) +
+ 			 nla_total_size(sizeof(struct ifla_vf_rss_query_en)));
++>>>>>>> 01a3d796813d (if_link: Add an additional parameter to ifla_vf_info for RSS querying)
  		return size;
  	} else
  		return 0;
@@@ -1028,16 -1152,21 +1036,18 @@@ static int rtnl_fill_ifinfo(struct sk_b
  				break;
  			vf_mac.vf =
  				vf_vlan.vf =
 -				vf_rate.vf =
  				vf_tx_rate.vf =
  				vf_spoofchk.vf =
- 				vf_linkstate.vf = ivi.vf;
+ 				vf_linkstate.vf =
+ 				vf_rss_query_en.vf = ivi.vf;
  
  			memcpy(vf_mac.mac, ivi.mac, sizeof(ivi.mac));
  			vf_vlan.vlan = ivi.vlan;
  			vf_vlan.qos = ivi.qos;
 -			vf_tx_rate.rate = ivi.max_tx_rate;
 -			vf_rate.min_tx_rate = ivi.min_tx_rate;
 -			vf_rate.max_tx_rate = ivi.max_tx_rate;
 +			vf_tx_rate.rate = ivi.tx_rate;
  			vf_spoofchk.setting = ivi.spoofchk;
  			vf_linkstate.link_state = ivi.linkstate;
+ 			vf_rss_query_en.setting = ivi.rss_query_en;
  			vf = nla_nest_start(skb, IFLA_VF_INFO);
  			if (!vf) {
  				nla_nest_cancel(skb, vfinfo);
@@@ -1140,16 -1292,13 +1153,26 @@@ static const struct nla_policy ifla_vfi
  };
  
  static const struct nla_policy ifla_vf_policy[IFLA_VF_MAX+1] = {
++<<<<<<< HEAD
 +	[IFLA_VF_MAC]		= { .type = NLA_BINARY,
 +				    .len = sizeof(struct ifla_vf_mac) },
 +	[IFLA_VF_VLAN]		= { .type = NLA_BINARY,
 +				    .len = sizeof(struct ifla_vf_vlan) },
 +	[IFLA_VF_TX_RATE]	= { .type = NLA_BINARY,
 +				    .len = sizeof(struct ifla_vf_tx_rate) },
 +	[IFLA_VF_SPOOFCHK]	= { .type = NLA_BINARY,
 +				    .len = sizeof(struct ifla_vf_spoofchk) },
 +	[IFLA_VF_LINK_STATE]	= { .type = NLA_BINARY,
 +				    .len = sizeof(struct ifla_vf_link_state) },
++=======
+ 	[IFLA_VF_MAC]		= { .len = sizeof(struct ifla_vf_mac) },
+ 	[IFLA_VF_VLAN]		= { .len = sizeof(struct ifla_vf_vlan) },
+ 	[IFLA_VF_TX_RATE]	= { .len = sizeof(struct ifla_vf_tx_rate) },
+ 	[IFLA_VF_SPOOFCHK]	= { .len = sizeof(struct ifla_vf_spoofchk) },
+ 	[IFLA_VF_RATE]		= { .len = sizeof(struct ifla_vf_rate) },
+ 	[IFLA_VF_LINK_STATE]	= { .len = sizeof(struct ifla_vf_link_state) },
+ 	[IFLA_VF_RSS_QUERY_EN]	= { .len = sizeof(struct ifla_vf_rss_query_en) },
++>>>>>>> 01a3d796813d (if_link: Add an additional parameter to ifla_vf_info for RSS querying)
  };
  
  static const struct nla_policy ifla_port_policy[IFLA_PORT_MAX+1] = {
* Unmerged path include/linux/if_link.h
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index 3cf462ffc113..3601b5bcb1cb 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -844,6 +844,11 @@ struct netdev_phys_port_id {
  * int (*ndo_set_vf_link_state)(struct net_device *dev, int vf, int link_state);
  * int (*ndo_set_vf_port)(struct net_device *dev, int vf,
  *			  struct nlattr *port[]);
+ *
+ *      Enable or disable the VF ability to query its RSS Redirection Table and
+ *      Hash Key. This is needed since on some devices VF share this information
+ *      with PF and querying it may adduce a theoretical security risk.
+ * int (*ndo_set_vf_rss_query_en)(struct net_device *dev, int vf, bool setting);
  * int (*ndo_get_vf_port)(struct net_device *dev, int vf, struct sk_buff *skb);
  * int (*ndo_setup_tc)(struct net_device *dev, u8 tc)
  * 	Called to setup 'tc' number of traffic classes in the net device. This
@@ -1025,6 +1030,9 @@ struct net_device_ops {
 						   struct nlattr *port[]);
 	int			(*ndo_get_vf_port)(struct net_device *dev,
 						   int vf, struct sk_buff *skb);
+	int			(*ndo_set_vf_rss_query_en)(
+						   struct net_device *dev,
+						   int vf, bool setting);
 	int			(*ndo_setup_tc)(struct net_device *dev, u8 tc);
 #if IS_ENABLED(CONFIG_FCOE)
 	int			(*ndo_fcoe_enable)(struct net_device *dev);
* Unmerged path include/uapi/linux/if_link.h
* Unmerged path net/core/rtnetlink.c
