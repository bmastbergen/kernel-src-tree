cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Hariprasad Shenai <hariprasad@chelsio.com>
commit f404f80c707e373af7423c56ce40099021d86ecd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/f404f80c.failed

replace ntoh{s,l} and hton{s,l} calls with the generic byteorder in
cxgb4/t4_hw.c file

	Signed-off-by: Hariprasad Shenai <hariprasad@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f404f80c707e373af7423c56ce40099021d86ecd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
diff --cc drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
index 4234b8c917e7,cd23db54f544..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
@@@ -1305,19 -1997,22 +1305,29 @@@ int t4_link_start(struct adapter *adap
  		fc |= FW_PORT_CAP_FC_TX;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_portid = htonl(FW_CMD_OP(FW_PORT_CMD) | FW_CMD_REQUEST |
 +			       FW_CMD_EXEC | FW_PORT_CMD_PORTID(port));
 +	c.action_to_len16 = htonl(FW_PORT_CMD_ACTION(FW_PORT_ACTION_L1_CFG) |
 +				  FW_LEN16(c));
++=======
+ 	c.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PORT_CMD) |
+ 				     FW_CMD_REQUEST_F | FW_CMD_EXEC_F |
+ 				     FW_PORT_CMD_PORTID_V(port));
+ 	c.action_to_len16 =
+ 		cpu_to_be32(FW_PORT_CMD_ACTION_V(FW_PORT_ACTION_L1_CFG) |
+ 			    FW_LEN16(c));
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  
  	if (!(lc->supported & FW_PORT_CAP_ANEG)) {
- 		c.u.l1cfg.rcap = htonl((lc->supported & ADVERT_MASK) | fc);
+ 		c.u.l1cfg.rcap = cpu_to_be32((lc->supported & ADVERT_MASK) |
+ 					     fc);
  		lc->fc = lc->requested_fc & (PAUSE_RX | PAUSE_TX);
  	} else if (lc->autoneg == AUTONEG_DISABLE) {
- 		c.u.l1cfg.rcap = htonl(lc->requested_speed | fc | mdi);
+ 		c.u.l1cfg.rcap = cpu_to_be32(lc->requested_speed | fc | mdi);
  		lc->fc = lc->requested_fc & (PAUSE_RX | PAUSE_TX);
  	} else
- 		c.u.l1cfg.rcap = htonl(lc->advertising | fc | mdi);
+ 		c.u.l1cfg.rcap = cpu_to_be32(lc->advertising | fc | mdi);
  
  	return t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);
  }
@@@ -1335,11 -2030,13 +1345,21 @@@ int t4_restart_aneg(struct adapter *ada
  	struct fw_port_cmd c;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_portid = htonl(FW_CMD_OP(FW_PORT_CMD) | FW_CMD_REQUEST |
 +			       FW_CMD_EXEC | FW_PORT_CMD_PORTID(port));
 +	c.action_to_len16 = htonl(FW_PORT_CMD_ACTION(FW_PORT_ACTION_L1_CFG) |
 +				  FW_LEN16(c));
 +	c.u.l1cfg.rcap = htonl(FW_PORT_CAP_ANEG);
++=======
+ 	c.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PORT_CMD) |
+ 				     FW_CMD_REQUEST_F | FW_CMD_EXEC_F |
+ 				     FW_PORT_CMD_PORTID_V(port));
+ 	c.action_to_len16 =
+ 		cpu_to_be32(FW_PORT_CMD_ACTION_V(FW_PORT_ACTION_L1_CFG) |
+ 			    FW_LEN16(c));
+ 	c.u.l1cfg.rcap = cpu_to_be32(FW_PORT_CAP_ANEG);
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  	return t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);
  }
  
@@@ -2135,10 -2840,10 +2155,17 @@@ int t4_config_rss_range(struct adapter 
  	struct fw_rss_ind_tbl_cmd cmd;
  
  	memset(&cmd, 0, sizeof(cmd));
++<<<<<<< HEAD
 +	cmd.op_to_viid = htonl(FW_CMD_OP(FW_RSS_IND_TBL_CMD) |
 +			       FW_CMD_REQUEST | FW_CMD_WRITE |
 +			       FW_RSS_IND_TBL_CMD_VIID(viid));
 +	cmd.retval_len16 = htonl(FW_LEN16(cmd));
++=======
+ 	cmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_RSS_IND_TBL_CMD) |
+ 			       FW_CMD_REQUEST_F | FW_CMD_WRITE_F |
+ 			       FW_RSS_IND_TBL_CMD_VIID_V(viid));
+ 	cmd.retval_len16 = cpu_to_be32(FW_LEN16(cmd));
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  
  	/* each fw_rss_ind_tbl_cmd takes up to 32 entries */
  	while (n > 0) {
@@@ -2190,15 -2895,16 +2217,28 @@@ int t4_config_glbl_rss(struct adapter *
  	struct fw_rss_glb_config_cmd c;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_write = htonl(FW_CMD_OP(FW_RSS_GLB_CONFIG_CMD) |
 +			      FW_CMD_REQUEST | FW_CMD_WRITE);
 +	c.retval_len16 = htonl(FW_LEN16(c));
 +	if (mode == FW_RSS_GLB_CONFIG_CMD_MODE_MANUAL) {
 +		c.u.manual.mode_pkd = htonl(FW_RSS_GLB_CONFIG_CMD_MODE(mode));
 +	} else if (mode == FW_RSS_GLB_CONFIG_CMD_MODE_BASICVIRTUAL) {
 +		c.u.basicvirtual.mode_pkd =
 +			htonl(FW_RSS_GLB_CONFIG_CMD_MODE(mode));
 +		c.u.basicvirtual.synmapen_to_hashtoeplitz = htonl(flags);
++=======
+ 	c.op_to_write = cpu_to_be32(FW_CMD_OP_V(FW_RSS_GLB_CONFIG_CMD) |
+ 				    FW_CMD_REQUEST_F | FW_CMD_WRITE_F);
+ 	c.retval_len16 = cpu_to_be32(FW_LEN16(c));
+ 	if (mode == FW_RSS_GLB_CONFIG_CMD_MODE_MANUAL) {
+ 		c.u.manual.mode_pkd =
+ 			cpu_to_be32(FW_RSS_GLB_CONFIG_CMD_MODE_V(mode));
+ 	} else if (mode == FW_RSS_GLB_CONFIG_CMD_MODE_BASICVIRTUAL) {
+ 		c.u.basicvirtual.mode_pkd =
+ 			cpu_to_be32(FW_RSS_GLB_CONFIG_CMD_MODE_V(mode));
+ 		c.u.basicvirtual.synmapen_to_hashtoeplitz = cpu_to_be32(flags);
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  	} else
  		return -EINVAL;
  	return t4_wr_mbox(adapter, mbox, &c, sizeof(c), NULL);
@@@ -2617,19 -3565,21 +2657,37 @@@ int t4_wol_pat_enable(struct adapter *a
  void t4_mk_filtdelwr(unsigned int ftid, struct fw_filter_wr *wr, int qid)
  {
  	memset(wr, 0, sizeof(*wr));
++<<<<<<< HEAD
 +	wr->op_pkd = htonl(FW_WR_OP(FW_FILTER_WR));
 +	wr->len16_pkd = htonl(FW_WR_LEN16(sizeof(*wr) / 16));
 +	wr->tid_to_iq = htonl(V_FW_FILTER_WR_TID(ftid) |
 +			V_FW_FILTER_WR_NOREPLY(qid < 0));
 +	wr->del_filter_to_l2tix = htonl(F_FW_FILTER_WR_DEL_FILTER);
 +	if (qid >= 0)
 +		wr->rx_chan_rx_rpl_iq = htons(V_FW_FILTER_WR_RX_RPL_IQ(qid));
 +}
 +
 +#define INIT_CMD(var, cmd, rd_wr) do { \
 +	(var).op_to_write = htonl(FW_CMD_OP(FW_##cmd##_CMD) | \
 +				  FW_CMD_REQUEST | FW_CMD_##rd_wr); \
 +	(var).retval_len16 = htonl(FW_LEN16(var)); \
++=======
+ 	wr->op_pkd = cpu_to_be32(FW_WR_OP_V(FW_FILTER_WR));
+ 	wr->len16_pkd = cpu_to_be32(FW_WR_LEN16_V(sizeof(*wr) / 16));
+ 	wr->tid_to_iq = cpu_to_be32(FW_FILTER_WR_TID_V(ftid) |
+ 				    FW_FILTER_WR_NOREPLY_V(qid < 0));
+ 	wr->del_filter_to_l2tix = cpu_to_be32(FW_FILTER_WR_DEL_FILTER_F);
+ 	if (qid >= 0)
+ 		wr->rx_chan_rx_rpl_iq =
+ 			cpu_to_be16(FW_FILTER_WR_RX_RPL_IQ_V(qid));
+ }
+ 
+ #define INIT_CMD(var, cmd, rd_wr) do { \
+ 	(var).op_to_write = cpu_to_be32(FW_CMD_OP_V(FW_##cmd##_CMD) | \
+ 					FW_CMD_REQUEST_F | \
+ 					FW_CMD_##rd_wr##_F); \
+ 	(var).retval_len16 = cpu_to_be32(FW_LEN16(var)); \
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  } while (0)
  
  int t4_fwaddrspace_write(struct adapter *adap, unsigned int mbox,
@@@ -2638,12 -3589,14 +2697,23 @@@
  	struct fw_ldst_cmd c;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_addrspace = htonl(FW_CMD_OP(FW_LDST_CMD) | FW_CMD_REQUEST |
 +			    FW_CMD_WRITE |
 +			    FW_LDST_CMD_ADDRSPACE(FW_LDST_ADDRSPC_FIRMWARE));
 +	c.cycles_to_len16 = htonl(FW_LEN16(c));
 +	c.u.addrval.addr = htonl(addr);
 +	c.u.addrval.val = htonl(val);
++=======
+ 	ldst_addrspace = FW_LDST_CMD_ADDRSPACE_V(FW_LDST_ADDRSPC_FIRMWARE);
+ 	c.op_to_addrspace = cpu_to_be32(FW_CMD_OP_V(FW_LDST_CMD) |
+ 					FW_CMD_REQUEST_F |
+ 					FW_CMD_WRITE_F |
+ 					ldst_addrspace);
+ 	c.cycles_to_len16 = cpu_to_be32(FW_LEN16(c));
+ 	c.u.addrval.addr = cpu_to_be32(addr);
+ 	c.u.addrval.val = cpu_to_be32(val);
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  
  	return t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);
  }
@@@ -2666,12 -3620,14 +2737,23 @@@ int t4_mdio_rd(struct adapter *adap, un
  	struct fw_ldst_cmd c;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_addrspace = htonl(FW_CMD_OP(FW_LDST_CMD) | FW_CMD_REQUEST |
 +		FW_CMD_READ | FW_LDST_CMD_ADDRSPACE(FW_LDST_ADDRSPC_MDIO));
 +	c.cycles_to_len16 = htonl(FW_LEN16(c));
 +	c.u.mdio.paddr_mmd = htons(FW_LDST_CMD_PADDR(phy_addr) |
 +				   FW_LDST_CMD_MMD(mmd));
 +	c.u.mdio.raddr = htons(reg);
++=======
+ 	ldst_addrspace = FW_LDST_CMD_ADDRSPACE_V(FW_LDST_ADDRSPC_MDIO);
+ 	c.op_to_addrspace = cpu_to_be32(FW_CMD_OP_V(FW_LDST_CMD) |
+ 					FW_CMD_REQUEST_F | FW_CMD_READ_F |
+ 					ldst_addrspace);
+ 	c.cycles_to_len16 = cpu_to_be32(FW_LEN16(c));
+ 	c.u.mdio.paddr_mmd = cpu_to_be16(FW_LDST_CMD_PADDR_V(phy_addr) |
+ 					 FW_LDST_CMD_MMD_V(mmd));
+ 	c.u.mdio.raddr = cpu_to_be16(reg);
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  
  	ret = t4_wr_mbox(adap, mbox, &c, sizeof(c), &c);
  	if (ret == 0)
@@@ -2696,13 -3653,15 +2779,25 @@@ int t4_mdio_wr(struct adapter *adap, un
  	struct fw_ldst_cmd c;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_addrspace = htonl(FW_CMD_OP(FW_LDST_CMD) | FW_CMD_REQUEST |
 +		FW_CMD_WRITE | FW_LDST_CMD_ADDRSPACE(FW_LDST_ADDRSPC_MDIO));
 +	c.cycles_to_len16 = htonl(FW_LEN16(c));
 +	c.u.mdio.paddr_mmd = htons(FW_LDST_CMD_PADDR(phy_addr) |
 +				   FW_LDST_CMD_MMD(mmd));
 +	c.u.mdio.raddr = htons(reg);
 +	c.u.mdio.rval = htons(val);
++=======
+ 	ldst_addrspace = FW_LDST_CMD_ADDRSPACE_V(FW_LDST_ADDRSPC_MDIO);
+ 	c.op_to_addrspace = cpu_to_be32(FW_CMD_OP_V(FW_LDST_CMD) |
+ 					FW_CMD_REQUEST_F | FW_CMD_WRITE_F |
+ 					ldst_addrspace);
+ 	c.cycles_to_len16 = cpu_to_be32(FW_LEN16(c));
+ 	c.u.mdio.paddr_mmd = cpu_to_be16(FW_LDST_CMD_PADDR_V(phy_addr) |
+ 					 FW_LDST_CMD_MMD_V(mmd));
+ 	c.u.mdio.raddr = cpu_to_be16(reg);
+ 	c.u.mdio.rval = cpu_to_be16(val);
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  
  	return t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);
  }
@@@ -2836,14 -3795,14 +2931,25 @@@ int t4_fw_hello(struct adapter *adap, u
  retry:
  	memset(&c, 0, sizeof(c));
  	INIT_CMD(c, HELLO, WRITE);
++<<<<<<< HEAD
 +	c.err_to_clearinit = htonl(
 +		FW_HELLO_CMD_MASTERDIS(master == MASTER_CANT) |
 +		FW_HELLO_CMD_MASTERFORCE(master == MASTER_MUST) |
 +		FW_HELLO_CMD_MBMASTER(master == MASTER_MUST ? mbox :
 +				      FW_HELLO_CMD_MBMASTER_MASK) |
 +		FW_HELLO_CMD_MBASYNCNOT(evt_mbox) |
 +		FW_HELLO_CMD_STAGE(fw_hello_cmd_stage_os) |
 +		FW_HELLO_CMD_CLEARINIT);
++=======
+ 	c.err_to_clearinit = cpu_to_be32(
+ 		FW_HELLO_CMD_MASTERDIS_V(master == MASTER_CANT) |
+ 		FW_HELLO_CMD_MASTERFORCE_V(master == MASTER_MUST) |
+ 		FW_HELLO_CMD_MBMASTER_V(master == MASTER_MUST ?
+ 					mbox : FW_HELLO_CMD_MBMASTER_M) |
+ 		FW_HELLO_CMD_MBASYNCNOT_V(evt_mbox) |
+ 		FW_HELLO_CMD_STAGE_V(fw_hello_cmd_stage_os) |
+ 		FW_HELLO_CMD_CLEARINIT_F);
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  
  	/*
  	 * Issue the HELLO command to the firmware.  If it's not successful
@@@ -2861,12 -3820,12 +2967,17 @@@
  		return ret;
  	}
  
++<<<<<<< HEAD
 +	v = ntohl(c.err_to_clearinit);
 +	master_mbox = FW_HELLO_CMD_MBMASTER_GET(v);
++=======
+ 	v = be32_to_cpu(c.err_to_clearinit);
+ 	master_mbox = FW_HELLO_CMD_MBMASTER_G(v);
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  	if (state) {
 -		if (v & FW_HELLO_CMD_ERR_F)
 +		if (v & FW_HELLO_CMD_ERR)
  			*state = DEV_STATE_ERR;
 -		else if (v & FW_HELLO_CMD_INIT_F)
 +		else if (v & FW_HELLO_CMD_INIT)
  			*state = DEV_STATE_INIT;
  		else
  			*state = DEV_STATE_UNINIT;
@@@ -3023,8 -3982,8 +3134,13 @@@ static int t4_fw_halt(struct adapter *a
  
  		memset(&c, 0, sizeof(c));
  		INIT_CMD(c, RESET, WRITE);
++<<<<<<< HEAD
 +		c.val = htonl(PIORST | PIORSTMODE);
 +		c.halt_pkd = htonl(FW_RESET_CMD_HALT(1U));
++=======
+ 		c.val = cpu_to_be32(PIORST_F | PIORSTMODE_F);
+ 		c.halt_pkd = cpu_to_be32(FW_RESET_CMD_HALT_F);
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  		ret = t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);
  	}
  
@@@ -3317,12 -4277,14 +3433,21 @@@ int t4_query_params(struct adapter *ada
  		return -EINVAL;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_vfn = htonl(FW_CMD_OP(FW_PARAMS_CMD) | FW_CMD_REQUEST |
 +			    FW_CMD_READ | FW_PARAMS_CMD_PFN(pf) |
 +			    FW_PARAMS_CMD_VFN(vf));
 +	c.retval_len16 = htonl(FW_LEN16(c));
++=======
+ 	c.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_PARAMS_CMD) |
+ 				  FW_CMD_REQUEST_F | FW_CMD_READ_F |
+ 				  FW_PARAMS_CMD_PFN_V(pf) |
+ 				  FW_PARAMS_CMD_VFN_V(vf));
+ 	c.retval_len16 = cpu_to_be32(FW_LEN16(c));
+ 
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  	for (i = 0; i < nparams; i++, p += 2)
- 		*p = htonl(*params++);
+ 		*p = cpu_to_be32(*params++);
  
  	ret = t4_wr_mbox(adap, mbox, &c, sizeof(c), &c);
  	if (ret == 0)
@@@ -3355,13 -4357,14 +3480,21 @@@ int t4_set_params(struct adapter *adap
  		return -EINVAL;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_vfn = htonl(FW_CMD_OP(FW_PARAMS_CMD) | FW_CMD_REQUEST |
 +			    FW_CMD_WRITE | FW_PARAMS_CMD_PFN(pf) |
 +			    FW_PARAMS_CMD_VFN(vf));
 +	c.retval_len16 = htonl(FW_LEN16(c));
++=======
+ 	c.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_PARAMS_CMD) |
+ 				  FW_CMD_REQUEST_F | FW_CMD_WRITE_F |
+ 				  FW_PARAMS_CMD_PFN_V(pf) |
+ 				  FW_PARAMS_CMD_VFN_V(vf));
+ 	c.retval_len16 = cpu_to_be32(FW_LEN16(c));
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  	while (nparams--) {
- 		*p++ = htonl(*params++);
- 		*p++ = htonl(*val++);
+ 		*p++ = cpu_to_be32(*params++);
+ 		*p++ = cpu_to_be32(*val++);
  	}
  
  	return t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);
@@@ -3397,20 -4400,21 +3530,38 @@@ int t4_cfg_pfvf(struct adapter *adap, u
  	struct fw_pfvf_cmd c;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_vfn = htonl(FW_CMD_OP(FW_PFVF_CMD) | FW_CMD_REQUEST |
 +			    FW_CMD_WRITE | FW_PFVF_CMD_PFN(pf) |
 +			    FW_PFVF_CMD_VFN(vf));
 +	c.retval_len16 = htonl(FW_LEN16(c));
 +	c.niqflint_niq = htonl(FW_PFVF_CMD_NIQFLINT(rxqi) |
 +			       FW_PFVF_CMD_NIQ(rxq));
 +	c.type_to_neq = htonl(FW_PFVF_CMD_CMASK(cmask) |
 +			       FW_PFVF_CMD_PMASK(pmask) |
 +			       FW_PFVF_CMD_NEQ(txq));
 +	c.tc_to_nexactf = htonl(FW_PFVF_CMD_TC(tc) | FW_PFVF_CMD_NVI(vi) |
 +				FW_PFVF_CMD_NEXACTF(nexact));
 +	c.r_caps_to_nethctrl = htonl(FW_PFVF_CMD_R_CAPS(rcaps) |
 +				     FW_PFVF_CMD_WX_CAPS(wxcaps) |
 +				     FW_PFVF_CMD_NETHCTRL(txq_eth_ctrl));
++=======
+ 	c.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_PFVF_CMD) | FW_CMD_REQUEST_F |
+ 				  FW_CMD_WRITE_F | FW_PFVF_CMD_PFN_V(pf) |
+ 				  FW_PFVF_CMD_VFN_V(vf));
+ 	c.retval_len16 = cpu_to_be32(FW_LEN16(c));
+ 	c.niqflint_niq = cpu_to_be32(FW_PFVF_CMD_NIQFLINT_V(rxqi) |
+ 				     FW_PFVF_CMD_NIQ_V(rxq));
+ 	c.type_to_neq = cpu_to_be32(FW_PFVF_CMD_CMASK_V(cmask) |
+ 				    FW_PFVF_CMD_PMASK_V(pmask) |
+ 				    FW_PFVF_CMD_NEQ_V(txq));
+ 	c.tc_to_nexactf = cpu_to_be32(FW_PFVF_CMD_TC_V(tc) |
+ 				      FW_PFVF_CMD_NVI_V(vi) |
+ 				      FW_PFVF_CMD_NEXACTF_V(nexact));
+ 	c.r_caps_to_nethctrl = cpu_to_be32(FW_PFVF_CMD_R_CAPS_V(rcaps) |
+ 					FW_PFVF_CMD_WX_CAPS_V(wxcaps) |
+ 					FW_PFVF_CMD_NETHCTRL_V(txq_eth_ctrl));
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  	return t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);
  }
  
@@@ -3439,11 -4443,11 +3590,19 @@@ int t4_alloc_vi(struct adapter *adap, u
  	struct fw_vi_cmd c;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_vfn = htonl(FW_CMD_OP(FW_VI_CMD) | FW_CMD_REQUEST |
 +			    FW_CMD_WRITE | FW_CMD_EXEC |
 +			    FW_VI_CMD_PFN(pf) | FW_VI_CMD_VFN(vf));
 +	c.alloc_to_len16 = htonl(FW_VI_CMD_ALLOC | FW_LEN16(c));
 +	c.portid_pkd = FW_VI_CMD_PORTID(port);
++=======
+ 	c.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_VI_CMD) | FW_CMD_REQUEST_F |
+ 				  FW_CMD_WRITE_F | FW_CMD_EXEC_F |
+ 				  FW_VI_CMD_PFN_V(pf) | FW_VI_CMD_VFN_V(vf));
+ 	c.alloc_to_len16 = cpu_to_be32(FW_VI_CMD_ALLOC_F | FW_LEN16(c));
+ 	c.portid_pkd = FW_VI_CMD_PORTID_V(port);
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  	c.nmac = nmac - 1;
  
  	ret = t4_wr_mbox(adap, mbox, &c, sizeof(c), &c);
@@@ -3464,8 -4468,8 +3623,13 @@@
  		}
  	}
  	if (rss_size)
++<<<<<<< HEAD
 +		*rss_size = FW_VI_CMD_RSSSIZE_GET(ntohs(c.rsssize_pkd));
 +	return FW_VI_CMD_VIID_GET(ntohs(c.type_viid));
++=======
+ 		*rss_size = FW_VI_CMD_RSSSIZE_G(be16_to_cpu(c.rsssize_pkd));
+ 	return FW_VI_CMD_VIID_G(be16_to_cpu(c.type_viid));
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  }
  
  /**
@@@ -3492,23 -4496,25 +3656,36 @@@ int t4_set_rxmode(struct adapter *adap
  	if (mtu < 0)
  		mtu = FW_RXMODE_MTU_NO_CHG;
  	if (promisc < 0)
 -		promisc = FW_VI_RXMODE_CMD_PROMISCEN_M;
 +		promisc = FW_VI_RXMODE_CMD_PROMISCEN_MASK;
  	if (all_multi < 0)
 -		all_multi = FW_VI_RXMODE_CMD_ALLMULTIEN_M;
 +		all_multi = FW_VI_RXMODE_CMD_ALLMULTIEN_MASK;
  	if (bcast < 0)
 -		bcast = FW_VI_RXMODE_CMD_BROADCASTEN_M;
 +		bcast = FW_VI_RXMODE_CMD_BROADCASTEN_MASK;
  	if (vlanex < 0)
 -		vlanex = FW_VI_RXMODE_CMD_VLANEXEN_M;
 +		vlanex = FW_VI_RXMODE_CMD_VLANEXEN_MASK;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_viid = htonl(FW_CMD_OP(FW_VI_RXMODE_CMD) | FW_CMD_REQUEST |
 +			     FW_CMD_WRITE | FW_VI_RXMODE_CMD_VIID(viid));
 +	c.retval_len16 = htonl(FW_LEN16(c));
 +	c.mtu_to_vlanexen = htonl(FW_VI_RXMODE_CMD_MTU(mtu) |
 +				  FW_VI_RXMODE_CMD_PROMISCEN(promisc) |
 +				  FW_VI_RXMODE_CMD_ALLMULTIEN(all_multi) |
 +				  FW_VI_RXMODE_CMD_BROADCASTEN(bcast) |
 +				  FW_VI_RXMODE_CMD_VLANEXEN(vlanex));
++=======
+ 	c.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_RXMODE_CMD) |
+ 				   FW_CMD_REQUEST_F | FW_CMD_WRITE_F |
+ 				   FW_VI_RXMODE_CMD_VIID_V(viid));
+ 	c.retval_len16 = cpu_to_be32(FW_LEN16(c));
+ 	c.mtu_to_vlanexen =
+ 		cpu_to_be32(FW_VI_RXMODE_CMD_MTU_V(mtu) |
+ 			    FW_VI_RXMODE_CMD_PROMISCEN_V(promisc) |
+ 			    FW_VI_RXMODE_CMD_ALLMULTIEN_V(all_multi) |
+ 			    FW_VI_RXMODE_CMD_BROADCASTEN_V(bcast) |
+ 			    FW_VI_RXMODE_CMD_VLANEXEN_V(vlanex));
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  	return t4_wr_mbox_meat(adap, mbox, &c, sizeof(c), NULL, sleep_ok);
  }
  
@@@ -3549,15 -4555,17 +3726,29 @@@ int t4_alloc_mac_filt(struct adapter *a
  		return -EINVAL;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_viid = htonl(FW_CMD_OP(FW_VI_MAC_CMD) | FW_CMD_REQUEST |
 +			     FW_CMD_WRITE | (free ? FW_CMD_EXEC : 0) |
 +			     FW_VI_MAC_CMD_VIID(viid));
 +	c.freemacs_to_len16 = htonl(FW_VI_MAC_CMD_FREEMACS(free) |
 +				    FW_CMD_LEN16((naddr + 2) / 2));
 +
 +	for (i = 0, p = c.u.exact; i < naddr; i++, p++) {
 +		p->valid_to_idx = htons(FW_VI_MAC_CMD_VALID |
 +				      FW_VI_MAC_CMD_IDX(FW_VI_MAC_ADD_MAC));
++=======
+ 	c.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_MAC_CMD) |
+ 				   FW_CMD_REQUEST_F | FW_CMD_WRITE_F |
+ 				   (free ? FW_CMD_EXEC_F : 0) |
+ 				   FW_VI_MAC_CMD_VIID_V(viid));
+ 	c.freemacs_to_len16 = cpu_to_be32(FW_VI_MAC_CMD_FREEMACS_V(free) |
+ 					  FW_CMD_LEN16_V((naddr + 2) / 2));
+ 
+ 	for (i = 0, p = c.u.exact; i < naddr; i++, p++) {
+ 		p->valid_to_idx =
+ 			cpu_to_be16(FW_VI_MAC_CMD_VALID_F |
+ 				    FW_VI_MAC_CMD_IDX_V(FW_VI_MAC_ADD_MAC));
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  		memcpy(p->macaddr, addr[i], sizeof(p->macaddr));
  	}
  
@@@ -3566,7 -4574,7 +3757,11 @@@
  		return ret;
  
  	for (i = 0, p = c.u.exact; i < naddr; i++, p++) {
++<<<<<<< HEAD
 +		u16 index = FW_VI_MAC_CMD_IDX_GET(ntohs(p->valid_to_idx));
++=======
+ 		u16 index = FW_VI_MAC_CMD_IDX_G(be16_to_cpu(p->valid_to_idx));
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  
  		if (idx)
  			idx[i] = index >= max_naddr ? 0xffff : index;
@@@ -3612,17 -4620,18 +3807,31 @@@ int t4_change_mac(struct adapter *adap
  	mode = add_smt ? FW_VI_MAC_SMT_AND_MPSTCAM : FW_VI_MAC_MPS_TCAM_ENTRY;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_viid = htonl(FW_CMD_OP(FW_VI_MAC_CMD) | FW_CMD_REQUEST |
 +			     FW_CMD_WRITE | FW_VI_MAC_CMD_VIID(viid));
 +	c.freemacs_to_len16 = htonl(FW_CMD_LEN16(1));
 +	p->valid_to_idx = htons(FW_VI_MAC_CMD_VALID |
 +				FW_VI_MAC_CMD_SMAC_RESULT(mode) |
 +				FW_VI_MAC_CMD_IDX(idx));
++=======
+ 	c.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_MAC_CMD) |
+ 				   FW_CMD_REQUEST_F | FW_CMD_WRITE_F |
+ 				   FW_VI_MAC_CMD_VIID_V(viid));
+ 	c.freemacs_to_len16 = cpu_to_be32(FW_CMD_LEN16_V(1));
+ 	p->valid_to_idx = cpu_to_be16(FW_VI_MAC_CMD_VALID_F |
+ 				      FW_VI_MAC_CMD_SMAC_RESULT_V(mode) |
+ 				      FW_VI_MAC_CMD_IDX_V(idx));
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  	memcpy(p->macaddr, addr, sizeof(p->macaddr));
  
  	ret = t4_wr_mbox(adap, mbox, &c, sizeof(c), &c);
  	if (ret == 0) {
++<<<<<<< HEAD
 +		ret = FW_VI_MAC_CMD_IDX_GET(ntohs(p->valid_to_idx));
++=======
+ 		ret = FW_VI_MAC_CMD_IDX_G(be16_to_cpu(p->valid_to_idx));
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  		if (ret >= max_mac_addr)
  			ret = -ENOMEM;
  	}
@@@ -3646,16 -4655,45 +3855,56 @@@ int t4_set_addr_hash(struct adapter *ad
  	struct fw_vi_mac_cmd c;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_viid = htonl(FW_CMD_OP(FW_VI_MAC_CMD) | FW_CMD_REQUEST |
 +			     FW_CMD_WRITE | FW_VI_ENABLE_CMD_VIID(viid));
 +	c.freemacs_to_len16 = htonl(FW_VI_MAC_CMD_HASHVECEN |
 +				    FW_VI_MAC_CMD_HASHUNIEN(ucast) |
 +				    FW_CMD_LEN16(1));
++=======
+ 	c.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_MAC_CMD) |
+ 				   FW_CMD_REQUEST_F | FW_CMD_WRITE_F |
+ 				   FW_VI_ENABLE_CMD_VIID_V(viid));
+ 	c.freemacs_to_len16 = cpu_to_be32(FW_VI_MAC_CMD_HASHVECEN_F |
+ 					  FW_VI_MAC_CMD_HASHUNIEN_V(ucast) |
+ 					  FW_CMD_LEN16_V(1));
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  	c.u.hash.hashvec = cpu_to_be64(vec);
  	return t4_wr_mbox_meat(adap, mbox, &c, sizeof(c), NULL, sleep_ok);
  }
  
  /**
++<<<<<<< HEAD
++=======
+  *      t4_enable_vi_params - enable/disable a virtual interface
+  *      @adap: the adapter
+  *      @mbox: mailbox to use for the FW command
+  *      @viid: the VI id
+  *      @rx_en: 1=enable Rx, 0=disable Rx
+  *      @tx_en: 1=enable Tx, 0=disable Tx
+  *      @dcb_en: 1=enable delivery of Data Center Bridging messages.
+  *
+  *      Enables/disables a virtual interface.  Note that setting DCB Enable
+  *      only makes sense when enabling a Virtual Interface ...
+  */
+ int t4_enable_vi_params(struct adapter *adap, unsigned int mbox,
+ 			unsigned int viid, bool rx_en, bool tx_en, bool dcb_en)
+ {
+ 	struct fw_vi_enable_cmd c;
+ 
+ 	memset(&c, 0, sizeof(c));
+ 	c.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_ENABLE_CMD) |
+ 				   FW_CMD_REQUEST_F | FW_CMD_EXEC_F |
+ 				   FW_VI_ENABLE_CMD_VIID_V(viid));
+ 	c.ien_to_len16 = cpu_to_be32(FW_VI_ENABLE_CMD_IEN_V(rx_en) |
+ 				     FW_VI_ENABLE_CMD_EEN_V(tx_en) |
+ 				     FW_VI_ENABLE_CMD_DCB_INFO_V(dcb_en) |
+ 				     FW_LEN16(c));
+ 	return t4_wr_mbox_ns(adap, mbox, &c, sizeof(c), NULL);
+ }
+ 
+ /**
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
   *	t4_enable_vi - enable/disable a virtual interface
   *	@adap: the adapter
   *	@mbox: mailbox to use for the FW command
@@@ -3693,10 -4724,11 +3942,18 @@@ int t4_identify_port(struct adapter *ad
  	struct fw_vi_enable_cmd c;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_viid = htonl(FW_CMD_OP(FW_VI_ENABLE_CMD) | FW_CMD_REQUEST |
 +			     FW_CMD_EXEC | FW_VI_ENABLE_CMD_VIID(viid));
 +	c.ien_to_len16 = htonl(FW_VI_ENABLE_CMD_LED | FW_LEN16(c));
 +	c.blinkdur = htons(nblinks);
++=======
+ 	c.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_ENABLE_CMD) |
+ 				   FW_CMD_REQUEST_F | FW_CMD_EXEC_F |
+ 				   FW_VI_ENABLE_CMD_VIID_V(viid));
+ 	c.ien_to_len16 = cpu_to_be32(FW_VI_ENABLE_CMD_LED_F | FW_LEN16(c));
+ 	c.blinkdur = cpu_to_be16(nblinks);
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  	return t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);
  }
  
@@@ -3720,14 -4752,14 +3977,25 @@@ int t4_iq_free(struct adapter *adap, un
  	struct fw_iq_cmd c;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_vfn = htonl(FW_CMD_OP(FW_IQ_CMD) | FW_CMD_REQUEST |
 +			    FW_CMD_EXEC | FW_IQ_CMD_PFN(pf) |
 +			    FW_IQ_CMD_VFN(vf));
 +	c.alloc_to_len16 = htonl(FW_IQ_CMD_FREE | FW_LEN16(c));
 +	c.type_to_iqandstindex = htonl(FW_IQ_CMD_TYPE(iqtype));
 +	c.iqid = htons(iqid);
 +	c.fl0id = htons(fl0id);
 +	c.fl1id = htons(fl1id);
++=======
+ 	c.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_IQ_CMD) | FW_CMD_REQUEST_F |
+ 				  FW_CMD_EXEC_F | FW_IQ_CMD_PFN_V(pf) |
+ 				  FW_IQ_CMD_VFN_V(vf));
+ 	c.alloc_to_len16 = cpu_to_be32(FW_IQ_CMD_FREE_F | FW_LEN16(c));
+ 	c.type_to_iqandstindex = cpu_to_be32(FW_IQ_CMD_TYPE_V(iqtype));
+ 	c.iqid = cpu_to_be16(iqid);
+ 	c.fl0id = cpu_to_be16(fl0id);
+ 	c.fl1id = cpu_to_be16(fl1id);
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  	return t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);
  }
  
@@@ -3747,11 -4779,12 +4015,20 @@@ int t4_eth_eq_free(struct adapter *adap
  	struct fw_eq_eth_cmd c;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_vfn = htonl(FW_CMD_OP(FW_EQ_ETH_CMD) | FW_CMD_REQUEST |
 +			    FW_CMD_EXEC | FW_EQ_ETH_CMD_PFN(pf) |
 +			    FW_EQ_ETH_CMD_VFN(vf));
 +	c.alloc_to_len16 = htonl(FW_EQ_ETH_CMD_FREE | FW_LEN16(c));
 +	c.eqid_pkd = htonl(FW_EQ_ETH_CMD_EQID(eqid));
++=======
+ 	c.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_EQ_ETH_CMD) |
+ 				  FW_CMD_REQUEST_F | FW_CMD_EXEC_F |
+ 				  FW_EQ_ETH_CMD_PFN_V(pf) |
+ 				  FW_EQ_ETH_CMD_VFN_V(vf));
+ 	c.alloc_to_len16 = cpu_to_be32(FW_EQ_ETH_CMD_FREE_F | FW_LEN16(c));
+ 	c.eqid_pkd = cpu_to_be32(FW_EQ_ETH_CMD_EQID_V(eqid));
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  	return t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);
  }
  
@@@ -3771,11 -4804,12 +4048,20 @@@ int t4_ctrl_eq_free(struct adapter *ada
  	struct fw_eq_ctrl_cmd c;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_vfn = htonl(FW_CMD_OP(FW_EQ_CTRL_CMD) | FW_CMD_REQUEST |
 +			    FW_CMD_EXEC | FW_EQ_CTRL_CMD_PFN(pf) |
 +			    FW_EQ_CTRL_CMD_VFN(vf));
 +	c.alloc_to_len16 = htonl(FW_EQ_CTRL_CMD_FREE | FW_LEN16(c));
 +	c.cmpliqid_eqid = htonl(FW_EQ_CTRL_CMD_EQID(eqid));
++=======
+ 	c.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_EQ_CTRL_CMD) |
+ 				  FW_CMD_REQUEST_F | FW_CMD_EXEC_F |
+ 				  FW_EQ_CTRL_CMD_PFN_V(pf) |
+ 				  FW_EQ_CTRL_CMD_VFN_V(vf));
+ 	c.alloc_to_len16 = cpu_to_be32(FW_EQ_CTRL_CMD_FREE_F | FW_LEN16(c));
+ 	c.cmpliqid_eqid = cpu_to_be32(FW_EQ_CTRL_CMD_EQID_V(eqid));
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  	return t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);
  }
  
@@@ -3795,11 -4829,12 +4081,20 @@@ int t4_ofld_eq_free(struct adapter *ada
  	struct fw_eq_ofld_cmd c;
  
  	memset(&c, 0, sizeof(c));
++<<<<<<< HEAD
 +	c.op_to_vfn = htonl(FW_CMD_OP(FW_EQ_OFLD_CMD) | FW_CMD_REQUEST |
 +			    FW_CMD_EXEC | FW_EQ_OFLD_CMD_PFN(pf) |
 +			    FW_EQ_OFLD_CMD_VFN(vf));
 +	c.alloc_to_len16 = htonl(FW_EQ_OFLD_CMD_FREE | FW_LEN16(c));
 +	c.eqid_pkd = htonl(FW_EQ_OFLD_CMD_EQID(eqid));
++=======
+ 	c.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_EQ_OFLD_CMD) |
+ 				  FW_CMD_REQUEST_F | FW_CMD_EXEC_F |
+ 				  FW_EQ_OFLD_CMD_PFN_V(pf) |
+ 				  FW_EQ_OFLD_CMD_VFN_V(vf));
+ 	c.alloc_to_len16 = cpu_to_be32(FW_EQ_OFLD_CMD_FREE_F | FW_LEN16(c));
+ 	c.eqid_pkd = cpu_to_be32(FW_EQ_OFLD_CMD_EQID_V(eqid));
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  	return t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);
  }
  
@@@ -3817,25 -4852,25 +4112,35 @@@ int t4_handle_fw_rpl(struct adapter *ad
  	if (opcode == FW_PORT_CMD) {    /* link/module state change message */
  		int speed = 0, fc = 0;
  		const struct fw_port_cmd *p = (void *)rpl;
++<<<<<<< HEAD
 +		int chan = FW_PORT_CMD_PORTID_GET(ntohl(p->op_to_portid));
 +		int port = adap->chan_map[chan];
 +		struct port_info *pi = adap2pinfo(adap, port);
 +		struct link_config *lc = &pi->link_cfg;
 +		u32 stat = ntohl(p->u.info.lstatus_to_modtype);
 +		int link_ok = (stat & FW_PORT_CMD_LSTATUS) != 0;
 +		u32 mod = FW_PORT_CMD_MODTYPE_GET(stat);
++=======
+ 		int chan = FW_PORT_CMD_PORTID_G(be32_to_cpu(p->op_to_portid));
+ 		int port = adap->chan_map[chan];
+ 		struct port_info *pi = adap2pinfo(adap, port);
+ 		struct link_config *lc = &pi->link_cfg;
+ 		u32 stat = be32_to_cpu(p->u.info.lstatus_to_modtype);
+ 		int link_ok = (stat & FW_PORT_CMD_LSTATUS_F) != 0;
+ 		u32 mod = FW_PORT_CMD_MODTYPE_G(stat);
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  
 -		if (stat & FW_PORT_CMD_RXPAUSE_F)
 +		if (stat & FW_PORT_CMD_RXPAUSE)
  			fc |= PAUSE_RX;
 -		if (stat & FW_PORT_CMD_TXPAUSE_F)
 +		if (stat & FW_PORT_CMD_TXPAUSE)
  			fc |= PAUSE_TX;
 -		if (stat & FW_PORT_CMD_LSPEED_V(FW_PORT_CAP_SPEED_100M))
 +		if (stat & FW_PORT_CMD_LSPEED(FW_PORT_CAP_SPEED_100M))
  			speed = 100;
 -		else if (stat & FW_PORT_CMD_LSPEED_V(FW_PORT_CAP_SPEED_1G))
 +		else if (stat & FW_PORT_CMD_LSPEED(FW_PORT_CAP_SPEED_1G))
  			speed = 1000;
 -		else if (stat & FW_PORT_CMD_LSPEED_V(FW_PORT_CAP_SPEED_10G))
 +		else if (stat & FW_PORT_CMD_LSPEED(FW_PORT_CAP_SPEED_10G))
  			speed = 10000;
 -		else if (stat & FW_PORT_CMD_LSPEED_V(FW_PORT_CAP_SPEED_40G))
 +		else if (stat & FW_PORT_CMD_LSPEED(FW_PORT_CAP_SPEED_40G))
  			speed = 40000;
  
  		if (link_ok != lc->link_ok || speed != lc->speed ||
@@@ -4098,6 -5134,60 +4403,63 @@@ int t4_bar2_sge_qregs(struct adapter *a
  }
  
  /**
++<<<<<<< HEAD
++=======
+  *	t4_init_devlog_params - initialize adapter->params.devlog
+  *	@adap: the adapter
+  *
+  *	Initialize various fields of the adapter's Firmware Device Log
+  *	Parameters structure.
+  */
+ int t4_init_devlog_params(struct adapter *adap)
+ {
+ 	struct devlog_params *dparams = &adap->params.devlog;
+ 	u32 pf_dparams;
+ 	unsigned int devlog_meminfo;
+ 	struct fw_devlog_cmd devlog_cmd;
+ 	int ret;
+ 
+ 	/* If we're dealing with newer firmware, the Device Log Paramerters
+ 	 * are stored in a designated register which allows us to access the
+ 	 * Device Log even if we can't talk to the firmware.
+ 	 */
+ 	pf_dparams =
+ 		t4_read_reg(adap, PCIE_FW_REG(PCIE_FW_PF_A, PCIE_FW_PF_DEVLOG));
+ 	if (pf_dparams) {
+ 		unsigned int nentries, nentries128;
+ 
+ 		dparams->memtype = PCIE_FW_PF_DEVLOG_MEMTYPE_G(pf_dparams);
+ 		dparams->start = PCIE_FW_PF_DEVLOG_ADDR16_G(pf_dparams) << 4;
+ 
+ 		nentries128 = PCIE_FW_PF_DEVLOG_NENTRIES128_G(pf_dparams);
+ 		nentries = (nentries128 + 1) * 128;
+ 		dparams->size = nentries * sizeof(struct fw_devlog_e);
+ 
+ 		return 0;
+ 	}
+ 
+ 	/* Otherwise, ask the firmware for it's Device Log Parameters.
+ 	 */
+ 	memset(&devlog_cmd, 0, sizeof(devlog_cmd));
+ 	devlog_cmd.op_to_write = cpu_to_be32(FW_CMD_OP_V(FW_DEVLOG_CMD) |
+ 					     FW_CMD_REQUEST_F | FW_CMD_READ_F);
+ 	devlog_cmd.retval_len16 = cpu_to_be32(FW_LEN16(devlog_cmd));
+ 	ret = t4_wr_mbox(adap, adap->mbox, &devlog_cmd, sizeof(devlog_cmd),
+ 			 &devlog_cmd);
+ 	if (ret)
+ 		return ret;
+ 
+ 	devlog_meminfo =
+ 		be32_to_cpu(devlog_cmd.memtype_devlog_memaddr16_devlog);
+ 	dparams->memtype = FW_DEVLOG_CMD_MEMTYPE_DEVLOG_G(devlog_meminfo);
+ 	dparams->start = FW_DEVLOG_CMD_MEMADDR16_DEVLOG_G(devlog_meminfo) << 4;
+ 	dparams->size = be32_to_cpu(devlog_cmd.memsize_devlog);
+ 
+ 	return 0;
+ }
+ 
+ /**
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
   *	t4_init_sge_params - initialize adap->params.sge
   *	@adapter: the adapter
   *
@@@ -4231,6 -5321,29 +4593,32 @@@ int t4_filter_field_shift(const struct 
  	return field_shift;
  }
  
++<<<<<<< HEAD
++=======
+ int t4_init_rss_mode(struct adapter *adap, int mbox)
+ {
+ 	int i, ret;
+ 	struct fw_rss_vi_config_cmd rvc;
+ 
+ 	memset(&rvc, 0, sizeof(rvc));
+ 
+ 	for_each_port(adap, i) {
+ 		struct port_info *p = adap2pinfo(adap, i);
+ 
+ 		rvc.op_to_viid =
+ 			cpu_to_be32(FW_CMD_OP_V(FW_RSS_VI_CONFIG_CMD) |
+ 				    FW_CMD_REQUEST_F | FW_CMD_READ_F |
+ 				    FW_RSS_VI_CONFIG_CMD_VIID_V(p->viid));
+ 		rvc.retval_len16 = cpu_to_be32(FW_LEN16(rvc));
+ 		ret = t4_wr_mbox(adap, mbox, &rvc, sizeof(rvc), &rvc);
+ 		if (ret)
+ 			return ret;
+ 		p->rss_mode = be32_to_cpu(rvc.u.basicvirtual.defaultq_to_udpen);
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  int t4_port_init(struct adapter *adap, int mbox, int pf, int vf)
  {
  	u8 addr[6];
@@@ -4248,11 -5361,11 +4636,19 @@@
  		while ((adap->params.portvec & (1 << j)) == 0)
  			j++;
  
++<<<<<<< HEAD
 +		c.op_to_portid = htonl(FW_CMD_OP(FW_PORT_CMD) |
 +				       FW_CMD_REQUEST | FW_CMD_READ |
 +				       FW_PORT_CMD_PORTID(j));
 +		c.action_to_len16 = htonl(
 +			FW_PORT_CMD_ACTION(FW_PORT_ACTION_GET_PORT_INFO) |
++=======
+ 		c.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PORT_CMD) |
+ 					     FW_CMD_REQUEST_F | FW_CMD_READ_F |
+ 					     FW_PORT_CMD_PORTID_V(j));
+ 		c.action_to_len16 = cpu_to_be32(
+ 			FW_PORT_CMD_ACTION_V(FW_PORT_ACTION_GET_PORT_INFO) |
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  			FW_LEN16(c));
  		ret = t4_wr_mbox(adap, mbox, &c, sizeof(c), &c);
  		if (ret)
@@@ -4269,16 -5382,17 +4665,30 @@@
  		memcpy(adap->port[i]->dev_addr, addr, ETH_ALEN);
  		adap->port[i]->dev_port = j;
  
++<<<<<<< HEAD
 +		ret = ntohl(c.u.info.lstatus_to_modtype);
 +		p->mdio_addr = (ret & FW_PORT_CMD_MDIOCAP) ?
 +			FW_PORT_CMD_MDIOADDR_GET(ret) : -1;
 +		p->port_type = FW_PORT_CMD_PTYPE_GET(ret);
 +		p->mod_type = FW_PORT_MOD_TYPE_NA;
 +
 +		rvc.op_to_viid = htonl(FW_CMD_OP(FW_RSS_VI_CONFIG_CMD) |
 +				       FW_CMD_REQUEST | FW_CMD_READ |
 +				       FW_RSS_VI_CONFIG_CMD_VIID(p->viid));
 +		rvc.retval_len16 = htonl(FW_LEN16(rvc));
++=======
+ 		ret = be32_to_cpu(c.u.info.lstatus_to_modtype);
+ 		p->mdio_addr = (ret & FW_PORT_CMD_MDIOCAP_F) ?
+ 			FW_PORT_CMD_MDIOADDR_G(ret) : -1;
+ 		p->port_type = FW_PORT_CMD_PTYPE_G(ret);
+ 		p->mod_type = FW_PORT_MOD_TYPE_NA;
+ 
+ 		rvc.op_to_viid =
+ 			cpu_to_be32(FW_CMD_OP_V(FW_RSS_VI_CONFIG_CMD) |
+ 				    FW_CMD_REQUEST_F | FW_CMD_READ_F |
+ 				    FW_RSS_VI_CONFIG_CMD_VIID(p->viid));
+ 		rvc.retval_len16 = cpu_to_be32(FW_LEN16(rvc));
++>>>>>>> f404f80c707e (cxgb4: replace ntoh{s, l} and hton{s, l} calls with the generic byteorder)
  		ret = t4_wr_mbox(adap, mbox, &rvc, sizeof(rvc), &rvc);
  		if (ret)
  			return ret;
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
