xfs: remove redundant geometry information from xfs_da_state

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit b2a21e7a6bfa6aa1b712fb6167d37a96f332d3d5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/b2a21e7a.failed

It's carried in state->args->geo, so there's no need to duplicate it
and use more stack space than necessary.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>


(cherry picked from commit b2a21e7a6bfa6aa1b712fb6167d37a96f332d3d5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_attr.c
#	fs/xfs/xfs_dir2_node.c
diff --cc fs/xfs/xfs_attr.c
index f3b9670979f5,bfe36fc2cdc2..000000000000
--- a/fs/xfs/xfs_attr.c
+++ b/fs/xfs/xfs_attr.c
@@@ -902,8 -896,6 +902,11 @@@ restart
  	state = xfs_da_state_alloc();
  	state->args = args;
  	state->mp = mp;
++<<<<<<< HEAD
 +	state->blocksize = state->mp->m_sb.sb_blocksize;
 +	state->node_ents = state->mp->m_attr_node_ents;
++=======
++>>>>>>> b2a21e7a6bfa (xfs: remove redundant geometry information from xfs_da_state)
  
  	/*
  	 * Search to see if name already exists, and get back a pointer
@@@ -1081,8 -1073,6 +1084,11 @@@
  		state = xfs_da_state_alloc();
  		state->args = args;
  		state->mp = mp;
++<<<<<<< HEAD
 +		state->blocksize = state->mp->m_sb.sb_blocksize;
 +		state->node_ents = state->mp->m_attr_node_ents;
++=======
++>>>>>>> b2a21e7a6bfa (xfs: remove redundant geometry information from xfs_da_state)
  		state->inleaf = 0;
  		error = xfs_da3_node_lookup_int(state, &retval);
  		if (error)
@@@ -1173,8 -1163,6 +1179,11 @@@ xfs_attr_node_removename(xfs_da_args_t 
  	state = xfs_da_state_alloc();
  	state->args = args;
  	state->mp = dp->i_mount;
++<<<<<<< HEAD
 +	state->blocksize = state->mp->m_sb.sb_blocksize;
 +	state->node_ents = state->mp->m_attr_node_ents;
++=======
++>>>>>>> b2a21e7a6bfa (xfs: remove redundant geometry information from xfs_da_state)
  
  	/*
  	 * Search to see if name exists, and get back a pointer to it.
@@@ -1436,8 -1424,6 +1445,11 @@@ xfs_attr_node_get(xfs_da_args_t *args
  	state = xfs_da_state_alloc();
  	state->args = args;
  	state->mp = args->dp->i_mount;
++<<<<<<< HEAD
 +	state->blocksize = state->mp->m_sb.sb_blocksize;
 +	state->node_ents = state->mp->m_attr_node_ents;
++=======
++>>>>>>> b2a21e7a6bfa (xfs: remove redundant geometry information from xfs_da_state)
  
  	/*
  	 * Search to see if name exists, and get back a pointer to it.
diff --cc fs/xfs/xfs_dir2_node.c
index 697fc13c6486,da43d304fca2..000000000000
--- a/fs/xfs/xfs_dir2_node.c
+++ b/fs/xfs/xfs_dir2_node.c
@@@ -1587,8 -1592,6 +1588,11 @@@ xfs_dir2_node_addname
  	state = xfs_da_state_alloc();
  	state->args = args;
  	state->mp = args->dp->i_mount;
++<<<<<<< HEAD
 +	state->blocksize = state->mp->m_dirblksize;
 +	state->node_ents = state->mp->m_dir_node_ents;
++=======
++>>>>>>> b2a21e7a6bfa (xfs: remove redundant geometry information from xfs_da_state)
  	/*
  	 * Look up the name.  We're not supposed to find it, but
  	 * this gives us the insertion point.
@@@ -2031,8 -2036,6 +2035,11 @@@ xfs_dir2_node_lookup
  	state = xfs_da_state_alloc();
  	state->args = args;
  	state->mp = args->dp->i_mount;
++<<<<<<< HEAD
 +	state->blocksize = state->mp->m_dirblksize;
 +	state->node_ents = state->mp->m_dir_node_ents;
++=======
++>>>>>>> b2a21e7a6bfa (xfs: remove redundant geometry information from xfs_da_state)
  	/*
  	 * Fill in the path to the entry in the cursor.
  	 */
@@@ -2086,8 -2089,6 +2093,11 @@@ xfs_dir2_node_removename
  	state = xfs_da_state_alloc();
  	state->args = args;
  	state->mp = args->dp->i_mount;
++<<<<<<< HEAD
 +	state->blocksize = state->mp->m_dirblksize;
 +	state->node_ents = state->mp->m_dir_node_ents;
++=======
++>>>>>>> b2a21e7a6bfa (xfs: remove redundant geometry information from xfs_da_state)
  
  	/* Look up the entry we're deleting, set up the cursor. */
  	error = xfs_da3_node_lookup_int(state, &rval);
@@@ -2156,8 -2157,6 +2166,11 @@@ xfs_dir2_node_replace
  	state = xfs_da_state_alloc();
  	state->args = args;
  	state->mp = args->dp->i_mount;
++<<<<<<< HEAD
 +	state->blocksize = state->mp->m_dirblksize;
 +	state->node_ents = state->mp->m_dir_node_ents;
++=======
++>>>>>>> b2a21e7a6bfa (xfs: remove redundant geometry information from xfs_da_state)
  	inum = args->inumber;
  	/*
  	 * Lookup the entry to change in the btree.
* Unmerged path fs/xfs/xfs_attr.c
diff --git a/fs/xfs/xfs_attr_leaf.c b/fs/xfs/xfs_attr_leaf.c
index 5be77b3a9bc4..1ccbb3e6632e 100644
--- a/fs/xfs/xfs_attr_leaf.c
+++ b/fs/xfs/xfs_attr_leaf.c
@@ -1498,8 +1498,8 @@ xfs_attr3_leaf_rebalance(
 
 	xfs_attr3_leaf_hdr_to_disk(leaf1, &ichdr1);
 	xfs_attr3_leaf_hdr_to_disk(leaf2, &ichdr2);
-	xfs_trans_log_buf(args->trans, blk1->bp, 0, state->blocksize-1);
-	xfs_trans_log_buf(args->trans, blk2->bp, 0, state->blocksize-1);
+	xfs_trans_log_buf(args->trans, blk1->bp, 0, args->geo->blksize - 1);
+	xfs_trans_log_buf(args->trans, blk2->bp, 0, args->geo->blksize - 1);
 
 	/*
 	 * Copy out last hashval in each block for B-tree code.
@@ -1598,7 +1598,7 @@ xfs_attr3_leaf_figure_balance(
 						 state->args->valuelen,
 						 state->blocksize, NULL);
 	half /= 2;
-	lastdelta = state->blocksize;
+	lastdelta = state->args->geo->blksize;
 	entry = xfs_attr3_leaf_entryp(leaf1);
 	for (count = index = 0; count < max; entry++, index++, count++) {
 
@@ -1702,7 +1702,7 @@ xfs_attr3_leaf_toosmall(
 	bytes = xfs_attr3_leaf_hdr_size(leaf) +
 		ichdr.count * sizeof(xfs_attr_leaf_entry_t) +
 		ichdr.usedbytes;
-	if (bytes > (state->blocksize >> 1)) {
+	if (bytes > (state->args->geo->blksize >> 1)) {
 		*action = 0;	/* blk over 50%, don't try to join */
 		return(0);
 	}
@@ -1756,7 +1756,8 @@ xfs_attr3_leaf_toosmall(
 
 		xfs_attr3_leaf_hdr_from_disk(&ichdr2, bp->b_addr);
 
-		bytes = state->blocksize - (state->blocksize >> 2) -
+		bytes = state->args->geo->blksize -
+			(state->args->geo->blksize >> 2) -
 			ichdr.usedbytes - ichdr2.usedbytes -
 			((ichdr.count + ichdr2.count) *
 					sizeof(xfs_attr_leaf_entry_t)) -
@@ -2009,7 +2010,7 @@ xfs_attr3_leaf_unbalance(
 		struct xfs_attr_leafblock *tmp_leaf;
 		struct xfs_attr3_icleaf_hdr tmphdr;
 
-		tmp_leaf = kmem_zalloc(state->blocksize, KM_SLEEP);
+		tmp_leaf = kmem_zalloc(state->args->geo->blksize, KM_SLEEP);
 
 		/*
 		 * Copy the header into the temp leaf so that all the stuff
@@ -2022,7 +2023,7 @@ xfs_attr3_leaf_unbalance(
 		tmphdr.magic = savehdr.magic;
 		tmphdr.forw = savehdr.forw;
 		tmphdr.back = savehdr.back;
-		tmphdr.firstused = state->blocksize;
+		tmphdr.firstused = state->args->geo->blksize;
 
 		/* write the header to the temp buffer to initialise it */
 		xfs_attr3_leaf_hdr_to_disk(tmp_leaf, &tmphdr);
@@ -2043,14 +2044,14 @@ xfs_attr3_leaf_unbalance(
 						tmp_leaf, &tmphdr, tmphdr.count,
 						drophdr.count, mp);
 		}
-		memcpy(save_leaf, tmp_leaf, state->blocksize);
+		memcpy(save_leaf, tmp_leaf, state->args->geo->blksize);
 		savehdr = tmphdr; /* struct copy */
 		kmem_free(tmp_leaf);
 	}
 
 	xfs_attr3_leaf_hdr_to_disk(save_leaf, &savehdr);
 	xfs_trans_log_buf(state->args->trans, save_blk->bp, 0,
-					   state->blocksize - 1);
+					   state->args->geo->blksize - 1);
 
 	/*
 	 * Copy out last hashval in each block for B-tree code.
diff --git a/fs/xfs/xfs_da_btree.c b/fs/xfs/xfs_da_btree.c
index 4db5102d403a..d50987a7497b 100644
--- a/fs/xfs/xfs_da_btree.c
+++ b/fs/xfs/xfs_da_btree.c
@@ -663,7 +663,7 @@ xfs_da3_node_split(
 	/*
 	 * Do we have to split the node?
 	 */
-	if (nodehdr.count + newcount > state->node_ents) {
+	if (nodehdr.count + newcount > state->args->geo->node_ents) {
 		/*
 		 * Allocate a new node, add to the doubly linked chain of
 		 * nodes, then move some of our excess entries into it.
@@ -1089,14 +1089,15 @@ xfs_da3_root_join(
 	 * that could occur. For dir3 blocks we also need to update the block
 	 * number in the buffer header.
 	 */
-	memcpy(root_blk->bp->b_addr, bp->b_addr, state->blocksize);
+	memcpy(root_blk->bp->b_addr, bp->b_addr, args->geo->blksize);
 	root_blk->bp->b_ops = bp->b_ops;
 	xfs_trans_buf_copy_type(root_blk->bp, bp);
 	if (oldroothdr.magic == XFS_DA3_NODE_MAGIC) {
 		struct xfs_da3_blkinfo *da3 = root_blk->bp->b_addr;
 		da3->blkno = cpu_to_be64(root_blk->bp->b_bn);
 	}
-	xfs_trans_log_buf(args->trans, root_blk->bp, 0, state->blocksize - 1);
+	xfs_trans_log_buf(args->trans, root_blk->bp, 0,
+			  args->geo->blksize - 1);
 	error = xfs_da_shrink_inode(args, child, bp);
 	return(error);
 }
@@ -1139,7 +1140,7 @@ xfs_da3_node_toosmall(
 	info = blk->bp->b_addr;
 	node = (xfs_da_intnode_t *)info;
 	dp->d_ops->node_hdr_from_disk(&nodehdr, node);
-	if (nodehdr.count > (state->node_ents >> 1)) {
+	if (nodehdr.count > (state->args->geo->node_ents >> 1)) {
 		*action = 0;	/* blk over 50%, don't try to join */
 		return(0);	/* blk over 50%, don't try to join */
 	}
@@ -1176,8 +1177,8 @@ xfs_da3_node_toosmall(
 	 * We prefer coalescing with the lower numbered sibling so as
 	 * to shrink a directory over time.
 	 */
-	count  = state->node_ents;
-	count -= state->node_ents >> 2;
+	count  = state->args->geo->node_ents;
+	count -= state->args->geo->node_ents >> 2;
 	count -= nodehdr.count;
 
 	/* start with smaller blk num */
diff --git a/fs/xfs/xfs_da_btree.h b/fs/xfs/xfs_da_btree.h
index 0ac63adca705..6e153e399a77 100644
--- a/fs/xfs/xfs_da_btree.h
+++ b/fs/xfs/xfs_da_btree.h
@@ -128,8 +128,6 @@ typedef struct xfs_da_state_path {
 typedef struct xfs_da_state {
 	xfs_da_args_t		*args;		/* filename arguments */
 	struct xfs_mount	*mp;		/* filesystem mount point */
-	unsigned int		blocksize;	/* logical block size */
-	unsigned int		node_ents;	/* how many entries in danode */
 	xfs_da_state_path_t	path;		/* search/split paths */
 	xfs_da_state_path_t	altpath;	/* alternate path for join */
 	unsigned char		inleaf;		/* insert into 1->lf, 0->splf */
* Unmerged path fs/xfs/xfs_dir2_node.c
