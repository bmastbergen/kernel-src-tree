bonding: convert mode setting to use the new option API

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Nikolay Aleksandrov <nikolay@redhat.com>
commit 2b3798d5e1377ce6c67993bb271754c9c5ab4833
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/2b3798d5.failed

This patch makes the bond's mode setting use the new option API and
adds support for dependency printing which relies on having an entry for
the mode option in the bond_opts[] array.
Also add the ability to print the mode name when mode dependency fails
and fix some trivial/style errors.

	Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2b3798d5e1377ce6c67993bb271754c9c5ab4833)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_netlink.c
#	drivers/net/bonding/bond_options.c
#	drivers/net/bonding/bond_options.h
#	drivers/net/bonding/bond_sysfs.c
#	drivers/net/bonding/bonding.h
diff --cc drivers/net/bonding/bond_netlink.c
index 40e7b1cb4aea,db3f672a5e2a..000000000000
--- a/drivers/net/bonding/bond_netlink.c
+++ b/drivers/net/bonding/bond_netlink.c
@@@ -40,12 -98,18 +40,18 @@@ static int bond_changelink(struct net_d
  			   struct nlattr *tb[], struct nlattr *data[])
  {
  	struct bonding *bond = netdev_priv(bond_dev);
++<<<<<<< HEAD
++=======
+ 	struct bond_opt_value newval;
+ 	int miimon = 0;
++>>>>>>> 2b3798d5e137 (bonding: convert mode setting to use the new option API)
  	int err;
  
 -	if (!data)
 -		return 0;
 -
 -	if (data[IFLA_BOND_MODE]) {
 +	if (data && data[IFLA_BOND_MODE]) {
  		int mode = nla_get_u8(data[IFLA_BOND_MODE]);
  
- 		err = bond_option_mode_set(bond, mode);
+ 		bond_opt_initval(&newval, mode);
+ 		err = __bond_opt_set(bond, BOND_OPT_MODE, &newval);
  		if (err)
  			return err;
  	}
diff --cc drivers/net/bonding/bond_sysfs.c
index 9519d678a368,3e537e7b66a5..000000000000
--- a/drivers/net/bonding/bond_sysfs.c
+++ b/drivers/net/bonding/bond_sysfs.c
@@@ -312,51 -274,13 +313,62 @@@ static ssize_t bonding_store_mode(struc
  				  struct device_attribute *attr,
  				  const char *buf, size_t count)
  {
++<<<<<<< HEAD
 +	int new_value, ret = count;
++=======
++>>>>>>> 2b3798d5e137 (bonding: convert mode setting to use the new option API)
  	struct bonding *bond = to_bond(d);
+ 	int ret;
  
++<<<<<<< HEAD
 +	if (!rtnl_trylock())
 +		return restart_syscall();
 +
 +	if (bond->dev->flags & IFF_UP) {
 +		pr_err("unable to update mode of %s because interface is up.\n",
 +		       bond->dev->name);
 +		ret = -EPERM;
 +		goto out;
 +	}
 +
 +	if (bond->slave_cnt > 0) {
 +		pr_err("unable to update mode of %s because it has slaves.\n",
 +			bond->dev->name);
 +		ret = -EPERM;
 +		goto out;
 +	}
 +
 +	new_value = bond_parse_parm(buf, bond_mode_tbl);
 +	if (new_value < 0)  {
 +		pr_err("%s: Ignoring invalid mode value %.*s.\n",
 +		       bond->dev->name, (int)strlen(buf) - 1, buf);
 +		ret = -EINVAL;
 +		goto out;
 +	}
 +	if ((new_value == BOND_MODE_ALB ||
 +	     new_value == BOND_MODE_TLB) &&
 +	    bond->params.arp_interval) {
 +		pr_err("%s: %s mode is incompatible with arp monitoring.\n",
 +		       bond->dev->name, bond_mode_tbl[new_value].modename);
 +		ret = -EINVAL;
 +		goto out;
 +	}
 +
 +	/* don't cache arp_validate between modes */
 +	bond->params.arp_validate = BOND_ARP_VALIDATE_NONE;
 +	bond->params.mode = new_value;
 +	bond_set_mode_ops(bond, bond->params.mode);
 +	pr_info("%s: setting mode to %s (%d).\n",
 +		bond->dev->name, bond_mode_tbl[new_value].modename,
 +		new_value);
 +out:
 +	rtnl_unlock();
++=======
+ 	ret = bond_opt_tryset_rtnl(bond, BOND_OPT_MODE, (char *)buf);
+ 	if (!ret)
+ 		ret = count;
+ 
++>>>>>>> 2b3798d5e137 (bonding: convert mode setting to use the new option API)
  	return ret;
  }
  static DEVICE_ATTR(mode, S_IRUGO | S_IWUSR,
diff --cc drivers/net/bonding/bonding.h
index 6097f0c04b95,f8e2cab90020..000000000000
--- a/drivers/net/bonding/bonding.h
+++ b/drivers/net/bonding/bonding.h
@@@ -442,6 -452,37 +442,40 @@@ void bond_setup(struct net_device *bond
  unsigned int bond_get_num_tx_queues(void);
  int bond_netlink_init(void);
  void bond_netlink_fini(void);
++<<<<<<< HEAD
++=======
+ int bond_option_active_slave_set(struct bonding *bond, struct net_device *slave_dev);
+ int bond_option_miimon_set(struct bonding *bond, int miimon);
+ int bond_option_updelay_set(struct bonding *bond, int updelay);
+ int bond_option_downdelay_set(struct bonding *bond, int downdelay);
+ int bond_option_use_carrier_set(struct bonding *bond, int use_carrier);
+ int bond_option_arp_interval_set(struct bonding *bond, int arp_interval);
+ int bond_option_arp_ip_targets_set(struct bonding *bond, __be32 *targets,
+ 				   int count);
+ int bond_option_arp_ip_target_add(struct bonding *bond, __be32 target);
+ int bond_option_arp_ip_target_rem(struct bonding *bond, __be32 target);
+ int bond_option_arp_validate_set(struct bonding *bond, int arp_validate);
+ int bond_option_arp_all_targets_set(struct bonding *bond, int arp_all_targets);
+ int bond_option_primary_set(struct bonding *bond, const char *primary);
+ int bond_option_primary_reselect_set(struct bonding *bond,
+ 				     int primary_reselect);
+ int bond_option_fail_over_mac_set(struct bonding *bond, int fail_over_mac);
+ int bond_option_xmit_hash_policy_set(struct bonding *bond,
+ 				     int xmit_hash_policy);
+ int bond_option_resend_igmp_set(struct bonding *bond, int resend_igmp);
+ int bond_option_num_peer_notif_set(struct bonding *bond, int num_peer_notif);
+ int bond_option_all_slaves_active_set(struct bonding *bond,
+ 				      int all_slaves_active);
+ int bond_option_min_links_set(struct bonding *bond, int min_links);
+ int bond_option_lp_interval_set(struct bonding *bond, int min_links);
+ int bond_option_packets_per_slave_set(struct bonding *bond,
+ 				      int packets_per_slave);
+ int bond_option_lacp_rate_set(struct bonding *bond, int lacp_rate);
+ int bond_option_ad_select_set(struct bonding *bond, int ad_select);
+ struct net_device *bond_option_active_slave_get_rcu(struct bonding *bond);
+ struct net_device *bond_option_active_slave_get(struct bonding *bond);
+ const char *bond_slave_link_status(s8 link);
++>>>>>>> 2b3798d5e137 (bonding: convert mode setting to use the new option API)
  
  struct bond_net {
  	struct net *		net;	/* Associated network namespace */
* Unmerged path drivers/net/bonding/bond_options.c
* Unmerged path drivers/net/bonding/bond_options.h
diff --git a/drivers/net/bonding/bond_main.c b/drivers/net/bonding/bond_main.c
index 38a1c7877edd..eb184dec8777 100644
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@ -201,17 +201,6 @@ const struct bond_parm_tbl bond_lacp_tbl[] = {
 {	NULL,		-1},
 };
 
-const struct bond_parm_tbl bond_mode_tbl[] = {
-{	"balance-rr",		BOND_MODE_ROUNDROBIN},
-{	"active-backup",	BOND_MODE_ACTIVEBACKUP},
-{	"balance-xor",		BOND_MODE_XOR},
-{	"broadcast",		BOND_MODE_BROADCAST},
-{	"802.3ad",		BOND_MODE_8023AD},
-{	"balance-tlb",		BOND_MODE_TLB},
-{	"balance-alb",		BOND_MODE_ALB},
-{	NULL,			-1},
-};
-
 const struct bond_parm_tbl xmit_hashtype_tbl[] = {
 {	"layer2",		BOND_XMIT_POLICY_LAYER2},
 {	"layer3+4",		BOND_XMIT_POLICY_LAYER34},
@@ -4346,18 +4335,20 @@ int bond_parse_parm(const char *buf, const struct bond_parm_tbl *tbl)
 static int bond_check_params(struct bond_params *params)
 {
 	int arp_validate_value, fail_over_mac_value, primary_reselect_value, i;
+	struct bond_opt_value newval, *valptr;
 	int arp_all_targets_value;
 
 	/*
 	 * Convert string parameters.
 	 */
 	if (mode) {
-		bond_mode = bond_parse_parm(mode, bond_mode_tbl);
-		if (bond_mode == -1) {
-			pr_err("Error: Invalid bonding mode \"%s\"\n",
-			       mode == NULL ? "NULL" : mode);
+		bond_opt_initstr(&newval, mode);
+		valptr = bond_opt_parse(bond_opt_get(BOND_OPT_MODE), &newval);
+		if (!valptr) {
+			pr_err("Error: Invalid bonding mode \"%s\"\n", mode);
 			return -EINVAL;
 		}
+		bond_mode = valptr->value;
 	}
 
 	if (xmit_hash_policy) {
* Unmerged path drivers/net/bonding/bond_netlink.c
* Unmerged path drivers/net/bonding/bond_options.c
* Unmerged path drivers/net/bonding/bond_options.h
* Unmerged path drivers/net/bonding/bond_sysfs.c
* Unmerged path drivers/net/bonding/bonding.h
