bonding: rebuild the lock use for bond_alb_monitor()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author dingtianhong <dingtianhong@huawei.com>
commit 733ab63935beab905b03a329cdc544e8c171b6b9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/733ab639.failed

The bond_alb_monitor use bond lock to protect the bond slave list,
it is no effect here, we need to use RTNL or RCU to replace bond lock,
the bond_alb_monitor will called 10 times one second, RTNL may loss
performance here, so I replace bond lock with RCU to protect the
bond slave list, also the RTNL is preserved, the logic of the monitor
did not changed.

	Suggested-by: Nikolay Aleksandrov <nikolay@redhat.com>
	Suggested-by: Jay Vosburgh <fubar@us.ibm.com>
	Suggested-by: Veaceslav Falico <vfalico@redhat.com>
	Signed-off-by: Ding Tianhong <dingtianhong@huawei.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 733ab63935beab905b03a329cdc544e8c171b6b9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_alb.c
diff --cc drivers/net/bonding/bond_alb.c
index 40b221bb4e23,759ddeebe390..000000000000
--- a/drivers/net/bonding/bond_alb.c
+++ b/drivers/net/bonding/bond_alb.c
@@@ -1461,16 -1491,12 +1461,20 @@@ void bond_alb_monitor(struct work_struc
  	struct bonding *bond = container_of(work, struct bonding,
  					    alb_work.work);
  	struct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));
 -	struct list_head *iter;
  	struct slave *slave;
 +	int i;
 +
++<<<<<<< HEAD
 +	if (!rtnl_trylock())
 +		goto re_arm;
  
 +	if (bond->slave_cnt == 0) {
++=======
+ 	if (!bond_has_slaves(bond)) {
++>>>>>>> 733ab63935be (bonding: rebuild the lock use for bond_alb_monitor())
  		bond_info->tx_rebalance_counter = 0;
  		bond_info->lp_counter = 0;
 +		rtnl_unlock();
  		goto re_arm;
  	}
  
@@@ -1486,9 -1514,8 +1492,13 @@@
  		 */
  		read_lock(&bond->curr_slave_lock);
  
++<<<<<<< HEAD
 +		bond_for_each_slave(bond, slave, i) {
++=======
+ 		bond_for_each_slave_rcu(bond, slave, iter)
++>>>>>>> 733ab63935be (bonding: rebuild the lock use for bond_alb_monitor())
  			alb_send_learning_packets(slave, slave->dev->dev_addr);
 +		}
  
  		read_unlock(&bond->curr_slave_lock);
  
@@@ -1500,7 -1527,7 +1510,11 @@@
  
  		read_lock(&bond->curr_slave_lock);
  
++<<<<<<< HEAD
 +		bond_for_each_slave(bond, slave, i) {
++=======
+ 		bond_for_each_slave_rcu(bond, slave, iter) {
++>>>>>>> 733ab63935be (bonding: rebuild the lock use for bond_alb_monitor())
  			tlb_clear_slave(bond, slave, 1);
  			if (slave == bond->curr_active_slave) {
  				SLAVE_TLB_INFO(slave).load =
@@@ -1520,6 -1547,14 +1534,17 @@@
  		if (bond_info->primary_is_promisc &&
  		    (++bond_info->rlb_promisc_timeout_counter >= RLB_PROMISC_TIMEOUT)) {
  
++<<<<<<< HEAD
++=======
+ 			/*
+ 			 * dev_set_promiscuity requires rtnl and
+ 			 * nothing else.  Avoid race with bond_close.
+ 			 */
+ 			rcu_read_unlock();
+ 			if (!rtnl_trylock())
+ 				goto re_arm;
+ 
++>>>>>>> 733ab63935be (bonding: rebuild the lock use for bond_alb_monitor())
  			bond_info->rlb_promisc_timeout_counter = 0;
  
  			/* If the primary was set to promiscuous mode
@@@ -1528,6 -1563,9 +1553,12 @@@
  			 */
  			dev_set_promiscuity(bond->curr_active_slave->dev, -1);
  			bond_info->primary_is_promisc = 0;
++<<<<<<< HEAD
++=======
+ 
+ 			rtnl_unlock();
+ 			rcu_read_lock();
++>>>>>>> 733ab63935be (bonding: rebuild the lock use for bond_alb_monitor())
  		}
  
  		if (bond_info->rlb_rebalance) {
@@@ -1549,8 -1587,7 +1580,12 @@@
  			}
  		}
  	}
++<<<<<<< HEAD
 +
 +	rtnl_unlock();
++=======
+ 	rcu_read_unlock();
++>>>>>>> 733ab63935be (bonding: rebuild the lock use for bond_alb_monitor())
  re_arm:
  	queue_delayed_work(bond->wq, &bond->alb_work, alb_delta_in_ticks);
  }
* Unmerged path drivers/net/bonding/bond_alb.c
