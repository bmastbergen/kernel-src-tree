xfs: rewrite the filestream allocator using the dentry cache

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 2cd2ef6a300b1ac912bb515b75451585c3d33ea9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/2cd2ef6a.failed

In Linux we will always be able to find a parent inode for file that are
undergoing I/O.  Use this to simply the file stream allocator by only
keeping track of parent inodes.

	Signed-off-by: Christoph Hellwig <hch@lst.de>

(cherry picked from commit 2cd2ef6a300b1ac912bb515b75451585c3d33ea9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_filestream.c
#	fs/xfs/xfs_inode.c
diff --cc fs/xfs/xfs_filestream.c
index 12b6e7701985,ff6f90215c8a..000000000000
--- a/fs/xfs/xfs_filestream.c
+++ b/fs/xfs/xfs_filestream.c
@@@ -106,22 -41,16 +41,31 @@@
  
  static kmem_zone_t *item_zone;
  
++<<<<<<< HEAD
 +/*
 + * Structure for associating a file or a directory with an allocation group.
 + * The parent directory pointer is only needed for files, but since there will
 + * generally be vastly more files than directories in the cache, using the same
 + * data structure simplifies the code with very little memory overhead.
 + */
 +typedef struct fstrm_item
 +{
 +	xfs_agnumber_t	ag;	/* AG currently in use for the file/directory. */
 +	xfs_inode_t	*ip;	/* inode self-pointer. */
 +	xfs_inode_t	*pip;	/* Parent directory inode pointer. */
 +} fstrm_item_t;
++=======
+ struct xfs_fstrm_item {
+ 	struct xfs_mru_cache_elem	mru;
+ 	struct xfs_inode		*ip;
+ 	xfs_agnumber_t			ag; /* AG in use for this directory */
+ };
+ 
+ enum xfs_fstrm_alloc {
+ 	XFS_PICK_USERDATA = 1,
+ 	XFS_PICK_LOWSPACE = 2,
+ };
++>>>>>>> 2cd2ef6a300b (xfs: rewrite the filestream allocator using the dentry cache)
  
  /*
   * Allocation group filestream associations are tracked with per-ag atomic
@@@ -320,208 -268,55 +283,158 @@@ next_ag
  
  	TRACE_AG_PICK2(mp, startag, *agp, streams, free, nscan, flags);
  
++<<<<<<< HEAD
 +	return 0;
 +}
 +
 +/*
 + * Set the allocation group number for a file or a directory, updating inode
 + * references and per-AG references as appropriate.
 + */
 +static int
 +_xfs_filestream_update_ag(
 +	xfs_inode_t	*ip,
 +	xfs_inode_t	*pip,
 +	xfs_agnumber_t	ag)
 +{
 +	int		err = 0;
 +	xfs_mount_t	*mp;
 +	xfs_mru_cache_t	*cache;
 +	fstrm_item_t	*item;
 +	xfs_agnumber_t	old_ag;
 +	xfs_inode_t	*old_pip;
 +
 +	/*
 +	 * Either ip is a regular file and pip is a directory, or ip is a
 +	 * directory and pip is NULL.
 +	 */
 +	ASSERT(ip && ((S_ISREG(ip->i_d.di_mode) && pip &&
 +	               S_ISDIR(pip->i_d.di_mode)) ||
 +	              (S_ISDIR(ip->i_d.di_mode) && !pip)));
 +
 +	mp = ip->i_mount;
 +	cache = mp->m_filestream;
 +
 +	item = xfs_mru_cache_lookup(cache, ip->i_ino);
 +	if (item) {
 +		ASSERT(item->ip == ip);
 +		old_ag = item->ag;
 +		item->ag = ag;
 +		old_pip = item->pip;
 +		item->pip = pip;
 +		xfs_mru_cache_done(cache);
 +
 +		/*
 +		 * If the AG has changed, drop the old ref and take a new one,
 +		 * effectively transferring the reference from old to new AG.
 +		 */
 +		if (ag != old_ag) {
 +			xfs_filestream_put_ag(mp, old_ag);
 +			xfs_filestream_get_ag(mp, ag);
 +		}
 +
 +		/*
 +		 * If ip is a file and its pip has changed, drop the old ref and
 +		 * take a new one.
 +		 */
 +		if (pip && pip != old_pip) {
 +			IRELE(old_pip);
 +			IHOLD(pip);
 +		}
 +
 +		TRACE_UPDATE(mp, ip, old_ag, xfs_filestream_peek_ag(mp, old_ag),
 +				ag, xfs_filestream_peek_ag(mp, ag));
++=======
+ 	if (*agp == NULLAGNUMBER)
++>>>>>>> 2cd2ef6a300b (xfs: rewrite the filestream allocator using the dentry cache)
  		return 0;
- 	}
  
+ 	err = ENOMEM;
  	item = kmem_zone_zalloc(item_zone, KM_MAYFAIL);
  	if (!item)
- 		return ENOMEM;
+ 		goto out_put_ag;
  
- 	item->ag = ag;
+ 	item->ag = *agp;
  	item->ip = ip;
- 	item->pip = pip;
  
 -	err = xfs_mru_cache_insert(mp->m_filestream, ip->i_ino, &item->mru);
 +	err = xfs_mru_cache_insert(cache, ip->i_ino, item);
  	if (err) {
- 		kmem_zone_free(item_zone, item);
- 		return err;
+ 		if (err == EEXIST)
+ 			err = 0;
+ 		goto out_free_item;
  	}
  
- 	/* Take a reference on the AG. */
- 	xfs_filestream_get_ag(mp, ag);
- 
- 	/*
- 	 * Take a reference on the inode itself regardless of whether it's a
- 	 * regular file or a directory.
- 	 */
- 	IHOLD(ip);
- 
- 	/*
- 	 * In the case of a regular file, take a reference on the parent inode
- 	 * as well to ensure it remains in-core.
- 	 */
- 	if (pip)
- 		IHOLD(pip);
- 
- 	TRACE_UPDATE(mp, ip, ag, xfs_filestream_peek_ag(mp, ag),
- 			ag, xfs_filestream_peek_ag(mp, ag));
- 
  	return 0;
- }
  
++<<<<<<< HEAD
 +/* xfs_fstrm_free_func(): callback for freeing cached stream items. */
 +STATIC void
 +xfs_fstrm_free_func(
 +	unsigned long	ino,
 +	void		*data)
 +{
 +	fstrm_item_t	*item  = (fstrm_item_t *)data;
 +	xfs_inode_t	*ip = item->ip;
 +
 +	ASSERT(ip->i_ino == ino);
 +
 +	xfs_iflags_clear(ip, XFS_IFILESTREAM);
 +
 +	/* Drop the reference taken on the AG when the item was added. */
 +	xfs_filestream_put_ag(ip->i_mount, item->ag);
 +
 +	TRACE_FREE(ip->i_mount, ip, item->pip, item->ag,
 +		xfs_filestream_peek_ag(ip->i_mount, item->ag));
 +
 +	/*
 +	 * _xfs_filestream_update_ag() always takes a reference on the inode
 +	 * itself, whether it's a file or a directory.  Release it here.
 +	 * This can result in the inode being freed and so we must
 +	 * not hold any inode locks when freeing filesstreams objects
 +	 * otherwise we can deadlock here.
 +	 */
 +	IRELE(ip);
 +
 +	/*
 +	 * In the case of a regular file, _xfs_filestream_update_ag() also
 +	 * takes a ref on the parent inode to keep it in-core.  Release that
 +	 * too.
 +	 */
 +	if (item->pip)
 +		IRELE(item->pip);
 +
 +	/* Finally, free the memory allocated for the item. */
++=======
+ out_free_item:
++>>>>>>> 2cd2ef6a300b (xfs: rewrite the filestream allocator using the dentry cache)
  	kmem_zone_free(item_zone, item);
+ out_put_ag:
+ 	xfs_filestream_put_ag(mp, *agp);
+ 	return err;
  }
  
- /*
-  * xfs_filestream_init() is called at xfs initialisation time to set up the
-  * memory zone that will be used for filestream data structure allocation.
-  */
- int
- xfs_filestream_init(void)
- {
- 	item_zone = kmem_zone_init(sizeof(fstrm_item_t), "fstrm_item");
- 	if (!item_zone)
- 		return -ENOMEM;
- 
- 	return 0;
- }
- 
- /*
-  * xfs_filestream_uninit() is called at xfs termination time to destroy the
-  * memory zone that was used for filestream data structure allocation.
-  */
- void
- xfs_filestream_uninit(void)
+ static struct xfs_inode *
+ xfs_filestream_get_parent(
+ 	struct xfs_inode	*ip)
  {
- 	kmem_zone_destroy(item_zone);
- }
+ 	struct inode		*inode = VFS_I(ip), *dir = NULL;
+ 	struct dentry		*dentry, *parent;
  
- /*
-  * xfs_filestream_mount() is called when a file system is mounted with the
-  * filestream option.  It is responsible for allocating the data structures
-  * needed to track the new file system's file streams.
-  */
- int
- xfs_filestream_mount(
- 	xfs_mount_t	*mp)
- {
- 	int		err;
- 	unsigned int	lifetime, grp_count;
+ 	dentry = d_find_alias(inode);
+ 	if (!dentry)
+ 		goto out;
  
- 	/*
- 	 * The filestream timer tunable is currently fixed within the range of
- 	 * one second to four minutes, with five seconds being the default.  The
- 	 * group count is somewhat arbitrary, but it'd be nice to adhere to the
- 	 * timer tunable to within about 10 percent.  This requires at least 10
- 	 * groups.
- 	 */
- 	lifetime  = xfs_fstrm_centisecs * 10;
- 	grp_count = 10;
- 
- 	err = xfs_mru_cache_create(&mp->m_filestream, lifetime, grp_count,
- 	                     xfs_fstrm_free_func);
+ 	parent = dget_parent(dentry);
+ 	if (!parent)
+ 		goto out_dput;
  
- 	return err;
- }
+ 	dir = igrab(parent->d_inode);
+ 	dput(parent);
  
- /*
-  * xfs_filestream_unmount() is called when a file system that was mounted with
-  * the filestream option is unmounted.  It drains the data structures created
-  * to track the file system's file streams and frees all the memory that was
-  * allocated.
-  */
- void
- xfs_filestream_unmount(
- 	xfs_mount_t	*mp)
- {
- 	xfs_mru_cache_destroy(mp->m_filestream);
+ out_dput:
+ 	dput(dentry);
+ out:
+ 	return dir ? XFS_I(dir) : NULL;
  }
  
  /*
@@@ -530,31 -325,34 +443,55 @@@
   */
  xfs_agnumber_t
  xfs_filestream_lookup_ag(
- 	xfs_inode_t	*ip)
+ 	struct xfs_inode	*ip)
  {
++<<<<<<< HEAD
 +	xfs_mru_cache_t	*cache;
 +	fstrm_item_t	*item;
 +	xfs_agnumber_t	ag;
 +	int		ref;
++=======
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct xfs_fstrm_item	*item;
+ 	struct xfs_inode	*pip = NULL;
+ 	xfs_agnumber_t		ag = NULLAGNUMBER;
+ 	int			ref = 0;
+ 	struct xfs_mru_cache_elem *mru;
++>>>>>>> 2cd2ef6a300b (xfs: rewrite the filestream allocator using the dentry cache)
  
- 	if (!S_ISREG(ip->i_d.di_mode) && !S_ISDIR(ip->i_d.di_mode)) {
- 		ASSERT(0);
- 		return NULLAGNUMBER;
- 	}
+ 	ASSERT(S_ISREG(ip->i_d.di_mode));
  
++<<<<<<< HEAD
 +	cache = ip->i_mount->m_filestream;
 +	item = xfs_mru_cache_lookup(cache, ip->i_ino);
 +	if (!item) {
 +		TRACE_LOOKUP(ip->i_mount, ip, NULL, NULLAGNUMBER, 0);
 +		return NULLAGNUMBER;
 +	}
 +
 +	ASSERT(ip == item->ip);
 +	ag = item->ag;
 +	ref = xfs_filestream_peek_ag(ip->i_mount, ag);
 +	xfs_mru_cache_done(cache);
++=======
+ 	pip = xfs_filestream_get_parent(ip);
+ 	if (!pip)
+ 		goto out;
+ 
+ 	mru = xfs_mru_cache_lookup(mp->m_filestream, pip->i_ino);
+ 	if (!mru)
+ 		goto out;
+ 
+ 	item = container_of(mru, struct xfs_fstrm_item, mru);
+ 
+ 	ag = item->ag;
+ 	xfs_mru_cache_done(mp->m_filestream);
++>>>>>>> 2cd2ef6a300b (xfs: rewrite the filestream allocator using the dentry cache)
  
- 	TRACE_LOOKUP(ip->i_mount, ip, item->pip, ag, ref);
+ 	ref = xfs_filestream_peek_ag(ip->i_mount, ag);
+ out:
+ 	TRACE_LOOKUP(mp, ip, pip, ag, ref);
+ 	IRELE(pip);
  	return ag;
  }
  
@@@ -570,52 -365,21 +504,54 @@@
   */
  int
  xfs_filestream_associate(
- 	xfs_inode_t	*pip,
- 	xfs_inode_t	*ip)
+ 	struct xfs_inode	*pip)
  {
++<<<<<<< HEAD
 +	xfs_mount_t	*mp;
 +	xfs_mru_cache_t	*cache;
 +	fstrm_item_t	*item;
 +	xfs_agnumber_t	ag, rotorstep, startag;
 +	int		err = 0;
 +
 +	ASSERT(S_ISDIR(pip->i_d.di_mode));
 +	ASSERT(S_ISREG(ip->i_d.di_mode));
 +	if (!S_ISDIR(pip->i_d.di_mode) || !S_ISREG(ip->i_d.di_mode))
 +		return -EINVAL;
 +
 +	mp = pip->i_mount;
 +	cache = mp->m_filestream;
++=======
+ 	struct xfs_mount	*mp = pip->i_mount;
+ 	struct xfs_mru_cache_elem *mru;
+ 	xfs_agnumber_t		startag, ag;
+ 
+ 	ASSERT(S_ISDIR(pip->i_d.di_mode));
++>>>>>>> 2cd2ef6a300b (xfs: rewrite the filestream allocator using the dentry cache)
  
  	/*
- 	 * We have a problem, Houston.
- 	 *
- 	 * Taking the iolock here violates inode locking order - we already
- 	 * hold the ilock. Hence if we block getting this lock we may never
- 	 * wake. Unfortunately, that means if we can't get the lock, we're
- 	 * screwed in terms of getting a stream association - we can't spin
- 	 * waiting for the lock because someone else is waiting on the lock we
- 	 * hold and we cannot drop that as we are in a transaction here.
- 	 *
- 	 * Lucky for us, this inversion is not a problem because it's a
- 	 * directory inode that we are trying to lock here.
- 	 *
- 	 * So, if we can't get the iolock without sleeping then just give up
+ 	 * If the directory already has a file stream associated we're done.
  	 */
++<<<<<<< HEAD
 +	if (!xfs_ilock_nowait(pip, XFS_IOLOCK_EXCL))
 +		return 1;
 +
 +	/* If the parent directory is already in the cache, use its AG. */
 +	item = xfs_mru_cache_lookup(cache, pip->i_ino);
 +	if (item) {
 +		ASSERT(item->ip == pip);
 +		ag = item->ag;
 +		xfs_mru_cache_done(cache);
 +
 +		TRACE_LOOKUP(mp, pip, pip, ag, xfs_filestream_peek_ag(mp, ag));
 +		err = _xfs_filestream_update_ag(ip, pip, ag);
 +
 +		goto exit;
++=======
+ 	mru = xfs_mru_cache_lookup(mp->m_filestream, pip->i_ino);
+ 	if (mru) {
+ 		xfs_mru_cache_done(mp->m_filestream);
+ 		return 0;
++>>>>>>> 2cd2ef6a300b (xfs: rewrite the filestream allocator using the dentry cache)
  	}
  
  	/*
@@@ -671,154 -408,86 +580,158 @@@ xfs_filestream_new_ag
  	struct xfs_bmalloca	*ap,
  	xfs_agnumber_t		*agp)
  {
++<<<<<<< HEAD
 +	int		flags, err;
 +	xfs_inode_t	*ip, *pip = NULL;
 +	xfs_mount_t	*mp;
 +	xfs_mru_cache_t	*cache;
 +	xfs_extlen_t	minlen;
 +	fstrm_item_t	*dir, *file;
 +	xfs_agnumber_t	ag = NULLAGNUMBER;
 +
 +	ip = ap->ip;
 +	mp = ip->i_mount;
 +	cache = mp->m_filestream;
 +	minlen = ap->length;
 +	*agp = NULLAGNUMBER;
 +
 +	/*
 +	 * Look for the file in the cache, removing it if it's found.  Doing
 +	 * this allows it to be held across the dir lookup that follows.
 +	 */
 +	file = xfs_mru_cache_remove(cache, ip->i_ino);
 +	if (file) {
 +		ASSERT(ip == file->ip);
 +
 +		/* Save the file's parent inode and old AG number for later. */
 +		pip = file->pip;
 +		ag = file->ag;
 +
 +		/* Look for the file's directory in the cache. */
 +		dir = xfs_mru_cache_lookup(cache, pip->i_ino);
 +		if (dir) {
 +			ASSERT(pip == dir->ip);
 +
 +			/*
 +			 * If the directory has already moved on to a new AG,
 +			 * use that AG as the new AG for the file. Don't
 +			 * forget to twiddle the AG refcounts to match the
 +			 * movement.
 +			 */
 +			if (dir->ag != file->ag) {
 +				xfs_filestream_put_ag(mp, file->ag);
 +				xfs_filestream_get_ag(mp, dir->ag);
 +				*agp = file->ag = dir->ag;
 +			}
 +
 +			xfs_mru_cache_done(cache);
 +		}
 +
 +		/*
 +		 * Put the file back in the cache.  If this fails, the free
 +		 * function needs to be called to tidy up in the same way as if
 +		 * the item had simply expired from the cache.
 +		 */
 +		err = xfs_mru_cache_insert(cache, ip->i_ino, file);
 +		if (err) {
 +			xfs_fstrm_free_func(ip->i_ino, file);
 +			return err;
 +		}
 +
 +		/*
 +		 * If the file's AG was moved to the directory's new AG, there's
 +		 * nothing more to be done.
 +		 */
 +		if (*agp != NULLAGNUMBER) {
 +			TRACE_MOVEAG(mp, ip, pip,
 +					ag, xfs_filestream_peek_ag(mp, ag),
 +					*agp, xfs_filestream_peek_ag(mp, *agp));
 +			return 0;
 +		}
- 	}
- 
- 	/*
- 	 * If the file's parent directory is known, take its iolock in exclusive
- 	 * mode to prevent two sibling files from racing each other to migrate
- 	 * themselves and their parent to different AGs.
- 	 *
- 	 * Note that we lock the parent directory iolock inside the child
- 	 * iolock here.  That's fine as we never hold both parent and child
- 	 * iolock in any other place.  This is different from the ilock,
- 	 * which requires locking of the child after the parent for namespace
- 	 * operations.
- 	 */
- 	if (pip)
- 		xfs_ilock(pip, XFS_IOLOCK_EXCL | XFS_IOLOCK_PARENT);
++=======
+ 	struct xfs_inode	*ip = ap->ip, *pip;
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	xfs_extlen_t		minlen = ap->length;
+ 	xfs_agnumber_t		startag = 0;
+ 	int			flags, err = 0;
+ 	struct xfs_mru_cache_elem *mru;
  
- 	/*
- 	 * A new AG needs to be found for the file.  If the file's parent
- 	 * directory is also known, it will be moved to the new AG as well to
- 	 * ensure that files created inside it in future use the new AG.
- 	 */
- 	ag = (ag == NULLAGNUMBER) ? 0 : (ag + 1) % mp->m_sb.sb_agcount;
- 	flags = (ap->userdata ? XFS_PICK_USERDATA : 0) |
- 	        (ap->flist->xbf_low ? XFS_PICK_LOWSPACE : 0);
+ 	*agp = NULLAGNUMBER;
  
- 	err = _xfs_filestream_pick_ag(mp, ag, agp, flags, minlen);
- 	if (err || *agp == NULLAGNUMBER)
+ 	pip = xfs_filestream_get_parent(ip);
+ 	if (!pip)
  		goto exit;
  
- 	/*
- 	 * If the file wasn't found in the file cache, then its parent directory
- 	 * inode isn't known.  For this to have happened, the file must either
- 	 * be pre-existing, or it was created long enough ago that its cache
- 	 * entry has expired.  This isn't the sort of usage that the filestreams
- 	 * allocator is trying to optimise, so there's no point trying to track
- 	 * its new AG somehow in the filestream data structures.
- 	 */
- 	if (!pip) {
- 		TRACE_ORPHAN(mp, ip, *agp);
- 		goto exit;
+ 	mru = xfs_mru_cache_remove(mp->m_filestream, pip->i_ino);
+ 	if (mru) {
+ 		struct xfs_fstrm_item *item =
+ 			container_of(mru, struct xfs_fstrm_item, mru);
+ 		startag = (item->ag + 1) % mp->m_sb.sb_agcount;
++>>>>>>> 2cd2ef6a300b (xfs: rewrite the filestream allocator using the dentry cache)
  	}
  
- 	/* Associate the parent inode with the AG. */
- 	err = _xfs_filestream_update_ag(pip, NULL, *agp);
- 	if (err)
- 		goto exit;
- 
- 	/* Associate the file inode with the AG. */
- 	err = _xfs_filestream_update_ag(ip, pip, *agp);
- 	if (err)
- 		goto exit;
+ 	flags = (ap->userdata ? XFS_PICK_USERDATA : 0) |
+ 	        (ap->flist->xbf_low ? XFS_PICK_LOWSPACE : 0);
  
- 	TRACE_MOVEAG(mp, ip, pip, NULLAGNUMBER, 0,
- 			*agp, xfs_filestream_peek_ag(mp, *agp));
+ 	err = xfs_filestream_pick_ag(pip, startag, agp, flags, minlen);
  
- exit:
  	/*
- 	 * If _xfs_filestream_pick_ag() returned a valid AG, remove the
- 	 * reference it took on it, since the file and directory will have taken
- 	 * their own now if they were successfully cached.
+ 	 * Only free the item here so we skip over the old AG earlier.
  	 */
- 	if (*agp != NULLAGNUMBER)
- 		xfs_filestream_put_ag(mp, *agp);
- 	else
- 		*agp = 0;
- 
- 	if (pip)
- 		xfs_iunlock(pip, XFS_IOLOCK_EXCL);
+ 	if (mru)
+ 		xfs_fstrm_free_func(mru);
  
+ 	IRELE(pip);
+ exit:
+ 	if (*agp == NULLAGNUMBER)
+ 		*agp = 0;
  	return err;
  }
  
- /*
-  * Remove an association between an inode and a filestream object.
-  * Typically this is done on last close of an unlinked file.
-  */
  void
  xfs_filestream_deassociate(
- 	xfs_inode_t	*ip)
+ 	struct xfs_inode	*ip)
  {
 -	xfs_mru_cache_delete(ip->i_mount->m_filestream, ip->i_ino);
 +	xfs_mru_cache_t	*cache = ip->i_mount->m_filestream;
 +
 +	xfs_mru_cache_delete(cache, ip->i_ino);
  }
+ 
+ int
+ xfs_filestream_mount(
+ 	xfs_mount_t	*mp)
+ {
+ 	/*
+ 	 * The filestream timer tunable is currently fixed within the range of
+ 	 * one second to four minutes, with five seconds being the default.  The
+ 	 * group count is somewhat arbitrary, but it'd be nice to adhere to the
+ 	 * timer tunable to within about 10 percent.  This requires at least 10
+ 	 * groups.
+ 	 */
+ 	return xfs_mru_cache_create(&mp->m_filestream, xfs_fstrm_centisecs * 10,
+ 				    10, xfs_fstrm_free_func);
+ }
+ 
+ void
+ xfs_filestream_unmount(
+ 	xfs_mount_t	*mp)
+ {
+ 	xfs_mru_cache_destroy(mp->m_filestream);
+ }
+ 
+ 
+ /* needs to return a positive errno for the init path */
+ int
+ xfs_filestream_init(void)
+ {
+ 	item_zone = kmem_zone_init(sizeof(struct xfs_fstrm_item), "fstrm_item");
+ 	if (!item_zone)
+ 		return -ENOMEM;
+ 	return 0;
+ }
+ 
+ void
+ xfs_filestream_uninit(void)
+ {
+ 	kmem_zone_destroy(item_zone);
+ }
diff --cc fs/xfs/xfs_inode.c
index 5be5ff7bf7b6,b9b531f7fa3d..000000000000
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@@ -844,11 -846,9 +844,17 @@@ xfs_ialloc
  
  	/* now we have set up the vfs inode we can associate the filestream */
  	if (filestreams) {
++<<<<<<< HEAD
 +		error = xfs_filestream_associate(pip, ip);
 +		if (error < 0)
 +			return -error;
 +		if (!error)
 +			xfs_iflags_set(ip, XFS_IFILESTREAM);
++=======
+ 		error = xfs_filestream_associate(pip);
+ 		if (error)
+ 			return error;
++>>>>>>> 2cd2ef6a300b (xfs: rewrite the filestream allocator using the dentry cache)
  	}
  
  	*ipp = ip;
* Unmerged path fs/xfs/xfs_filestream.c
diff --git a/fs/xfs/xfs_filestream.h b/fs/xfs/xfs_filestream.h
index 6d61dbee8564..bd272b76333e 100644
--- a/fs/xfs/xfs_filestream.h
+++ b/fs/xfs/xfs_filestream.h
@@ -20,44 +20,17 @@
 
 struct xfs_mount;
 struct xfs_inode;
-struct xfs_perag;
 struct xfs_bmalloca;
 
-#ifdef XFS_FILESTREAMS_TRACE
-#define XFS_FSTRM_KTRACE_INFO		1
-#define XFS_FSTRM_KTRACE_AGSCAN		2
-#define XFS_FSTRM_KTRACE_AGPICK1	3
-#define XFS_FSTRM_KTRACE_AGPICK2	4
-#define XFS_FSTRM_KTRACE_UPDATE		5
-#define XFS_FSTRM_KTRACE_FREE		6
-#define	XFS_FSTRM_KTRACE_ITEM_LOOKUP	7
-#define	XFS_FSTRM_KTRACE_ASSOCIATE	8
-#define	XFS_FSTRM_KTRACE_MOVEAG		9
-#define	XFS_FSTRM_KTRACE_ORPHAN		10
-
-#define XFS_FSTRM_KTRACE_SIZE	16384
-extern ktrace_t *xfs_filestreams_trace_buf;
-
-#endif
-
-/* allocation selection flags */
-typedef enum xfs_fstrm_alloc {
-	XFS_PICK_USERDATA = 1,
-	XFS_PICK_LOWSPACE = 2,
-} xfs_fstrm_alloc_t;
-
-/* prototypes for filestream.c */
 int xfs_filestream_init(void);
 void xfs_filestream_uninit(void);
 int xfs_filestream_mount(struct xfs_mount *mp);
 void xfs_filestream_unmount(struct xfs_mount *mp);
-xfs_agnumber_t xfs_filestream_lookup_ag(struct xfs_inode *ip);
-int xfs_filestream_associate(struct xfs_inode *dip, struct xfs_inode *ip);
 void xfs_filestream_deassociate(struct xfs_inode *ip);
+xfs_agnumber_t xfs_filestream_lookup_ag(struct xfs_inode *ip);
+int xfs_filestream_associate(struct xfs_inode *dip);
 int xfs_filestream_new_ag(struct xfs_bmalloca *ap, xfs_agnumber_t *agp);
 
-
-/* filestreams for the inode? */
 static inline int
 xfs_inode_is_filestream(
 	struct xfs_inode	*ip)
* Unmerged path fs/xfs/xfs_inode.c
