net/mlx4_core: Activate reset flow upon fatal command cases

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [netdrv] mlx4_core: Activate reset flow upon fatal command cases (Amir Vadai) [1164527 1164530 1164531 1164536 1164537]
Rebuild_FUZZ: 96.49%
commit-author Yishai Hadas <yishaih@mellanox.com>
commit f5aef5aa35063f2b45c3605871cd525d0cb7fb7a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/f5aef5aa.failed

We activate reset flow upon command fatal errors, when the device enters an
erroneous state, and must be reset.

The cases below are assumed to be fatal: FW command timed-out, an error from FW
on closing commands, pci is offline when posting/pending a command.

In those cases we place the device into an error state: chip is reset, pending
commands are awakened and completed immediately. Subsequent commands will
return immediately.

The return code in the above cases will depend on the command. Commands which
free and close resources will return success (because the chip was reset, so
callers may safely free their kernel resources). Other commands will return -EIO.

Since the device's state was marked as error, the catas poller will
detect this and restart the device's software stack (as is done when a FW
internal error is directly detected). The device state is protected by a
persistent mutex lives on its mlx4_dev, as such no need any more for the
hcr_mutex which is removed.

	Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f5aef5aa35063f2b45c3605871cd525d0cb7fb7a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx4/catas.c
#	drivers/net/ethernet/mellanox/mlx4/cmd.c
diff --cc drivers/net/ethernet/mellanox/mlx4/catas.c
index 9c656fe4983d,63f14ffcc906..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/catas.c
+++ b/drivers/net/ethernet/mellanox/mlx4/catas.c
@@@ -40,17 -40,92 +40,98 @@@ enum 
  	MLX4_CATAS_POLL_INTERVAL	= 5 * HZ,
  };
  
 +static DEFINE_SPINLOCK(catas_lock);
  
 +static LIST_HEAD(catas_list);
 +static struct work_struct catas_work;
  
- static int internal_err_reset = 1;
- module_param(internal_err_reset, int, 0644);
+ int mlx4_internal_err_reset = 1;
+ module_param_named(internal_err_reset, mlx4_internal_err_reset,  int, 0644);
  MODULE_PARM_DESC(internal_err_reset,
  		 "Reset device on internal errors if non-zero"
  		 " (default 1, in SRIOV mode default is 0)");
  
++<<<<<<< HEAD
++=======
+ static int read_vendor_id(struct mlx4_dev *dev)
+ {
+ 	u16 vendor_id = 0;
+ 	int ret;
+ 
+ 	ret = pci_read_config_word(dev->persist->pdev, 0, &vendor_id);
+ 	if (ret) {
+ 		mlx4_err(dev, "Failed to read vendor ID, ret=%d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	if (vendor_id == 0xffff) {
+ 		mlx4_err(dev, "PCI can't be accessed to read vendor id\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int mlx4_reset_master(struct mlx4_dev *dev)
+ {
+ 	int err = 0;
+ 
+ 	if (!pci_channel_offline(dev->persist->pdev)) {
+ 		err = read_vendor_id(dev);
+ 		/* If PCI can't be accessed to read vendor ID we assume that its
+ 		 * link was disabled and chip was already reset.
+ 		 */
+ 		if (err)
+ 			return 0;
+ 
+ 		err = mlx4_reset(dev);
+ 		if (err)
+ 			mlx4_err(dev, "Fail to reset HCA\n");
+ 	}
+ 
+ 	return err;
+ }
+ 
+ void mlx4_enter_error_state(struct mlx4_dev_persistent *persist)
+ {
+ 	int err;
+ 	struct mlx4_dev *dev;
+ 
+ 	if (!mlx4_internal_err_reset)
+ 		return;
+ 
+ 	mutex_lock(&persist->device_state_mutex);
+ 	if (persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR)
+ 		goto out;
+ 
+ 	dev = persist->dev;
+ 	mlx4_err(dev, "device is going to be reset\n");
+ 	err = mlx4_reset_master(dev);
+ 	BUG_ON(err != 0);
+ 
+ 	dev->persist->state |= MLX4_DEVICE_STATE_INTERNAL_ERROR;
+ 	mlx4_err(dev, "device was reset successfully\n");
+ 	mutex_unlock(&persist->device_state_mutex);
+ 
+ 	/* At that step HW was already reset, now notify clients */
+ 	mlx4_dispatch_event(dev, MLX4_DEV_EVENT_CATASTROPHIC_ERROR, 0);
+ 	mlx4_cmd_wake_completions(dev);
+ 	return;
+ 
+ out:
+ 	mutex_unlock(&persist->device_state_mutex);
+ }
+ 
+ static void mlx4_handle_error_state(struct mlx4_dev_persistent *persist)
+ {
+ 	int err = 0;
+ 
+ 	mlx4_enter_error_state(persist);
+ 	err = mlx4_restart_one(persist->pdev);
+ 	mlx4_info(persist->dev, "mlx4_restart_one was ended, ret=%d\n", err);
+ }
+ 
++>>>>>>> f5aef5aa3506 (net/mlx4_core: Activate reset flow upon fatal command cases)
  static void dump_err_buf(struct mlx4_dev *dev)
  {
  	struct mlx4_priv *priv = mlx4_priv(dev);
@@@ -69,25 -144,22 +150,35 @@@ static void poll_catas(unsigned long de
  	struct mlx4_priv *priv = mlx4_priv(dev);
  
  	if (readl(priv->catas_err.map)) {
 -		dump_err_buf(dev);
 -		goto internal_err;
 -	}
 -
 -	if (dev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR) {
 -		mlx4_warn(dev, "Internal error mark was detected on device\n");
 -		goto internal_err;
 -	}
 -
 +		/* If the device is off-line, we cannot try to recover it */
 +		if (pci_channel_offline(dev->pdev))
 +			mod_timer(&priv->catas_err.timer,
 +				  round_jiffies(jiffies + MLX4_CATAS_POLL_INTERVAL));
 +		else {
 +			dump_err_buf(dev);
 +			mlx4_dispatch_event(dev, MLX4_DEV_EVENT_CATASTROPHIC_ERROR, 0);
 +
 +			if (internal_err_reset) {
 +				spin_lock(&catas_lock);
 +				list_add(&priv->catas_err.list, &catas_list);
 +				spin_unlock(&catas_lock);
 +
++<<<<<<< HEAD
 +				queue_work(mlx4_wq, &catas_work);
 +			}
 +		}
 +	} else
 +		mod_timer(&priv->catas_err.timer,
 +			  round_jiffies(jiffies + MLX4_CATAS_POLL_INTERVAL));
++=======
+ 	mod_timer(&priv->catas_err.timer,
+ 		  round_jiffies(jiffies + MLX4_CATAS_POLL_INTERVAL));
+ 	return;
+ 
+ internal_err:
+ 	if (mlx4_internal_err_reset)
+ 		queue_work(dev->persist->catas_wq, &dev->persist->catas_work);
++>>>>>>> f5aef5aa3506 (net/mlx4_core: Activate reset flow upon fatal command cases)
  }
  
  static void catas_reset(struct work_struct *work)
diff --cc drivers/net/ethernet/mellanox/mlx4/cmd.c
index b07100e60e38,3895b2b5fc92..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/cmd.c
+++ b/drivers/net/ethernet/mellanox/mlx4/cmd.c
@@@ -323,12 -389,17 +389,23 @@@ static int mlx4_cmd_post(struct mlx4_de
  {
  	struct mlx4_cmd *cmd = &mlx4_priv(dev)->cmd;
  	u32 __iomem *hcr = cmd->hcr;
- 	int ret = -EAGAIN;
+ 	int ret = -EIO;
  	unsigned long end;
  
++<<<<<<< HEAD
 +	mutex_lock(&cmd->hcr_mutex);
 +
 +	if (pci_channel_offline(dev->pdev)) {
++=======
+ 	mutex_lock(&dev->persist->device_state_mutex);
+ 	/* To avoid writing to unknown addresses after the device state was
+ 	  * changed to internal error and the chip was reset,
+ 	  * check the INTERNAL_ERROR flag which is updated under
+ 	  * device_state_mutex lock.
+ 	  */
+ 	if (pci_channel_offline(dev->persist->pdev) ||
+ 	    (dev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR)) {
++>>>>>>> f5aef5aa3506 (net/mlx4_core: Activate reset flow upon fatal command cases)
  		/*
  		 * Device is going through error recovery
  		 * and cannot accept commands.
@@@ -464,7 -537,7 +543,11 @@@ static int mlx4_cmd_poll(struct mlx4_de
  
  	down(&priv->cmd.poll_sem);
  
++<<<<<<< HEAD
 +	if (pci_channel_offline(dev->pdev)) {
++=======
+ 	if (dev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR) {
++>>>>>>> f5aef5aa3506 (net/mlx4_core: Activate reset flow upon fatal command cases)
  		/*
  		 * Device is going through error recovery
  		 * and cannot accept commands.
@@@ -612,10 -707,13 +717,18 @@@ int __mlx4_cmd(struct mlx4_dev *dev, u6
  	       int out_is_imm, u32 in_modifier, u8 op_modifier,
  	       u16 op, unsigned long timeout, int native)
  {
++<<<<<<< HEAD
 +	if (pci_channel_offline(dev->pdev))
 +		return -EIO;
++=======
+ 	if (pci_channel_offline(dev->persist->pdev))
+ 		return mlx4_cmd_reset_flow(dev, op, op_modifier, -EIO);
++>>>>>>> f5aef5aa3506 (net/mlx4_core: Activate reset flow upon fatal command cases)
  
  	if (!mlx4_is_mfunc(dev) || (native && mlx4_is_master(dev))) {
+ 		if (dev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR)
+ 			return mlx4_internal_err_ret_value(dev, op,
+ 							  op_modifier);
  		if (mlx4_priv(dev)->cmd.use_events)
  			return mlx4_cmd_wait(dev, in_param, out_param,
  					     out_is_imm, in_modifier,
* Unmerged path drivers/net/ethernet/mellanox/mlx4/catas.c
* Unmerged path drivers/net/ethernet/mellanox/mlx4/cmd.c
diff --git a/drivers/net/ethernet/mellanox/mlx4/mcg.c b/drivers/net/ethernet/mellanox/mlx4/mcg.c
index a3867e7ef885..d22d9283d2cd 100644
--- a/drivers/net/ethernet/mellanox/mlx4/mcg.c
+++ b/drivers/net/ethernet/mellanox/mlx4/mcg.c
@@ -1318,6 +1318,9 @@ out:
 	mutex_unlock(&priv->mcg_table.mutex);
 
 	mlx4_free_cmd_mailbox(dev, mailbox);
+	if (err && dev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR)
+		/* In case device is under an error, return success as a closing command */
+		err = 0;
 	return err;
 }
 
diff --git a/drivers/net/ethernet/mellanox/mlx4/mlx4.h b/drivers/net/ethernet/mellanox/mlx4/mlx4.h
index cebd1180702b..aff82a0de619 100644
--- a/drivers/net/ethernet/mellanox/mlx4/mlx4.h
+++ b/drivers/net/ethernet/mellanox/mlx4/mlx4.h
@@ -234,6 +234,7 @@ do {									\
 
 extern int mlx4_log_num_mgm_entry_size;
 extern int log_mtts_per_seg;
+extern int mlx4_internal_err_reset;
 
 #define MLX4_MAX_NUM_SLAVES	(MLX4_MAX_NUM_PF + MLX4_MAX_NUM_VF)
 #define ALL_SLAVES 0xff
@@ -606,7 +607,6 @@ struct mlx4_mgm {
 struct mlx4_cmd {
 	struct pci_pool	       *pool;
 	void __iomem	       *hcr;
-	struct mutex		hcr_mutex;
 	struct mutex		slave_cmd_mutex;
 	struct semaphore	poll_sem;
 	struct semaphore	event_sem;
diff --git a/include/linux/mlx4/cmd.h b/include/linux/mlx4/cmd.h
index 64d25941b329..e7543844cc7a 100644
--- a/include/linux/mlx4/cmd.h
+++ b/include/linux/mlx4/cmd.h
@@ -279,6 +279,7 @@ int mlx4_get_vf_config(struct mlx4_dev *dev, int port, int vf, struct ifla_vf_in
 int mlx4_set_vf_link_state(struct mlx4_dev *dev, int port, int vf, int link_state);
 int mlx4_config_dev_retrieval(struct mlx4_dev *dev,
 			      struct mlx4_config_dev_params *params);
+void mlx4_cmd_wake_completions(struct mlx4_dev *dev);
 /*
  * mlx4_get_slave_default_vlan -
  * return true if VST ( default vlan)
