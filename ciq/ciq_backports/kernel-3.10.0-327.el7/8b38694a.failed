vhost/net: virtio 1.0 byte swap

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [vhost] net: virtio 1.0 byte swap (Thomas Huth) [1231879]
Rebuild_FUZZ: 89.29%
commit-author Michael S. Tsirkin <mst@redhat.com>
commit 8b38694a2dc8b18374310df50174f1e4376d6824
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/8b38694a.failed

I had to add an explicit tag to suppress compiler warning:
gcc isn't smart enough to notice that
len is always initialized since function is called with size > 0.

	Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
	Reviewed-by: Cornelia Huck <cornelia.huck@de.ibm.com>




(cherry picked from commit 8b38694a2dc8b18374310df50174f1e4376d6824)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/vhost/net.c
diff --cc drivers/vhost/net.c
index 51ea9ae5fb91,c218188c8880..000000000000
--- a/drivers/vhost/net.c
+++ b/drivers/vhost/net.c
@@@ -409,32 -413,23 +409,47 @@@ static void handle_tx(struct vhost_net 
  
  		/* use msg_control to pass vhost zerocopy ubuf info to skb */
  		if (zcopy_used) {
++<<<<<<< HEAD
 +			vq->heads[nvq->upend_idx].id = head;
 +			if (!vhost_net_tx_select_zcopy(net) ||
 +			    len < VHOST_GOODCOPY_LEN) {
 +				/* copy don't need to wait for DMA done */
 +				vq->heads[nvq->upend_idx].len =
 +							VHOST_DMA_DONE_LEN;
 +				msg.msg_control = NULL;
 +				msg.msg_controllen = 0;
 +				ubufs = NULL;
 +			} else {
 +				struct ubuf_info *ubuf;
 +				ubuf = nvq->ubuf_info + nvq->upend_idx;
 +
 +				vq->heads[nvq->upend_idx].len =
 +					VHOST_DMA_IN_PROGRESS;
 +				ubuf->callback = vhost_zerocopy_callback;
 +				ubuf->ctx = nvq->ubufs;
 +				ubuf->desc = nvq->upend_idx;
 +				msg.msg_control = ubuf;
 +				msg.msg_controllen = sizeof(ubuf);
 +				ubufs = nvq->ubufs;
 +				atomic_inc(&ubufs->refcount);
 +			}
++=======
+ 			struct ubuf_info *ubuf;
+ 			ubuf = nvq->ubuf_info + nvq->upend_idx;
+ 
+ 			vq->heads[nvq->upend_idx].id = cpu_to_vhost32(vq, head);
+ 			vq->heads[nvq->upend_idx].len = VHOST_DMA_IN_PROGRESS;
+ 			ubuf->callback = vhost_zerocopy_callback;
+ 			ubuf->ctx = nvq->ubufs;
+ 			ubuf->desc = nvq->upend_idx;
+ 			msg.msg_control = ubuf;
+ 			msg.msg_controllen = sizeof(ubuf);
+ 			ubufs = nvq->ubufs;
+ 			atomic_inc(&ubufs->refcount);
++>>>>>>> 8b38694a2dc8 (vhost/net: virtio 1.0 byte swap)
  			nvq->upend_idx = (nvq->upend_idx + 1) % UIO_MAXIOV;
 -		} else {
 +		} else
  			msg.msg_control = NULL;
 -			ubufs = NULL;
 -		}
  		/* TODO: Check specific error and bomb out unless ENOBUFS? */
  		err = sock->ops->sendmsg(NULL, sock, &msg, len);
  		if (unlikely(err < 0)) {
* Unmerged path drivers/vhost/net.c
