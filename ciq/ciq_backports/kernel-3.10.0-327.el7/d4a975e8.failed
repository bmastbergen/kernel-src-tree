fib_trie: Fib find node should return parent

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Alexander Duyck <alexander.h.duyck@redhat.com>
commit d4a975e83f4de2e454d7f937b36ce13b010c65ce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/d4a975e8.failed

This change makes it so that the parent pointer is returned by reference in
fib_find_node.  By doing this I can use it to find the parent node when I
am performing an insertion and I don't have to look for it again in
fib_insert_node.

	Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d4a975e83f4de2e454d7f937b36ce13b010c65ce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/fib_trie.c
diff --cc net/ipv4/fib_trie.c
index 3fe26090641a,5d0f145dbafe..000000000000
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@@ -1119,43 -1080,34 +1128,49 @@@ static struct list_head *fib_insert_nod
   */
  int fib_table_insert(struct fib_table *tb, struct fib_config *cfg)
  {
- 	struct trie *t = (struct trie *) tb->tb_data;
+ 	struct trie *t = (struct trie *)tb->tb_data;
  	struct fib_alias *fa, *new_fa;
++<<<<<<< HEAD
 +	struct list_head *fa_head = NULL;
++=======
+ 	struct tnode *l, *tp;
++>>>>>>> d4a975e83f4d (fib_trie: Fib find node should return parent)
  	struct fib_info *fi;
 -	u8 plen = cfg->fc_dst_len;
 -	u8 slen = KEYLENGTH - plen;
 +	int plen = cfg->fc_dst_len;
  	u8 tos = cfg->fc_tos;
- 	u32 key, mask;
+ 	u32 key;
  	int err;
- 	struct tnode *l;
  
 -	if (plen > KEYLENGTH)
 +	if (plen > 32)
  		return -EINVAL;
  
  	key = ntohl(cfg->fc_dst);
  
  	pr_debug("Insert table=%u %08x/%d\n", tb->tb_id, key, plen);
  
- 	mask = ntohl(inet_make_mask(plen));
- 
- 	if (key & ~mask)
+ 	if ((plen < KEYLENGTH) && (key << plen))
  		return -EINVAL;
  
 +	key = key & mask;
 +
  	fi = fib_create_info(cfg);
  	if (IS_ERR(fi)) {
  		err = PTR_ERR(fi);
  		goto err;
  	}
  
++<<<<<<< HEAD
 +	l = fib_find_node(t, key);
 +	fa = NULL;
 +
 +	if (l) {
 +		fa_head = get_fa_head(l, plen);
 +		fa = fib_find_alias(fa_head, tos, fi->fib_priority);
 +	}
++=======
+ 	l = fib_find_node(t, &tp, key);
+ 	fa = l ? fib_find_alias(&l->leaf, slen, tos, fi->fib_priority) : NULL;
++>>>>>>> d4a975e83f4d (fib_trie: Fib find node should return parent)
  
  	/* Now fa, if non-NULL, points to the first fib alias
  	 * with the same keys [prefix,tos,priority], if such key already
@@@ -1488,26 -1412,22 +1503,38 @@@ static void trie_leaf_remove(struct tri
  int fib_table_delete(struct fib_table *tb, struct fib_config *cfg)
  {
  	struct trie *t = (struct trie *) tb->tb_data;
++<<<<<<< HEAD
 +	u32 key, mask;
 +	int plen = cfg->fc_dst_len;
 +	u8 tos = cfg->fc_tos;
 +	struct fib_alias *fa, *fa_to_delete;
 +	struct list_head *fa_head;
 +	struct tnode *l;
 +	struct leaf_info *li;
++=======
+ 	struct fib_alias *fa, *fa_to_delete;
+ 	struct tnode *l, *tp;
+ 	u8 plen = cfg->fc_dst_len;
+ 	u8 slen = KEYLENGTH - plen;
+ 	u8 tos = cfg->fc_tos;
+ 	u32 key;
++>>>>>>> d4a975e83f4d (fib_trie: Fib find node should return parent)
  
 -	if (plen > KEYLENGTH)
 +	if (plen > 32)
  		return -EINVAL;
  
  	key = ntohl(cfg->fc_dst);
- 	mask = ntohl(inet_make_mask(plen));
  
- 	if (key & ~mask)
+ 	if ((plen < KEYLENGTH) && (key << plen))
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	key = key & mask;
 +	l = fib_find_node(t, key);
 +
++=======
+ 	l = fib_find_node(t, &tp, key);
++>>>>>>> d4a975e83f4d (fib_trie: Fib find node should return parent)
  	if (!l)
  		return -ESRCH;
  
* Unmerged path net/ipv4/fib_trie.c
