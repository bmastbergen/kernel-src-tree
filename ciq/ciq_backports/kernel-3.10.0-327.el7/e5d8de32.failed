dm: fix false warning in free_rq_clone() for unmapped requests

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Mike Snitzer <snitzer@redhat.com>
commit e5d8de32cc02a259e1a237ab57cba00f2930fa6a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/e5d8de32.failed

When stacking request-based dm device on non blk-mq device and
device-mapper target could not map the request (error target is used,
multipath target with all paths down, etc), the WARN_ON_ONCE() in
free_rq_clone() will trigger when it shouldn't.

The warning was added by commit aa6df8d ("dm: fix free_rq_clone() NULL
pointer when requeueing unmapped request").  But free_rq_clone() with
clone->q == NULL is valid usage for the case where
dm_kill_unmapped_request() initiates request cleanup.

Fix this false warning by just removing the WARN_ON -- it only generated
false positives and was never useful in catching the intended case
(completing clone request not being mapped e.g. clone->q being NULL).

Fixes: aa6df8d ("dm: fix free_rq_clone() NULL pointer when requeueing unmapped request")
	Reported-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Reported-by: Jun'ichi Nomura <j-nomura@ce.jp.nec.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit e5d8de32cc02a259e1a237ab57cba00f2930fa6a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm.c
diff --cc drivers/md/dm.c
index 7270805de04c,e24069aaeb18..000000000000
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@@ -1065,13 -1085,24 +1065,17 @@@ static void rq_completed(struct mapped_
  static void free_rq_clone(struct request *clone)
  {
  	struct dm_rq_target_io *tio = clone->end_io_data;
++<<<<<<< HEAD
++=======
+ 	struct mapped_device *md = tio->md;
++>>>>>>> e5d8de32cc02 (dm: fix false warning in free_rq_clone() for unmapped requests)
  
  	blk_rq_unprep_clone(clone);
 -
 -	if (md->type == DM_TYPE_MQ_REQUEST_BASED)
 -		/* stacked on blk-mq queue(s) */
 +	if (clone->q && clone->q->mq_ops)
  		tio->ti->type->release_clone_rq(clone);
 -	else if (!md->queue->mq_ops)
 -		/* request_fn queue stacked on request_fn queue(s) */
 -		free_clone_request(md, clone);
 -	/*
 -	 * NOTE: for the blk-mq queue stacked on request_fn queue(s) case:
 -	 * no need to call free_clone_request() because we leverage blk-mq by
 -	 * allocating the clone at the end of the blk-mq pdu (see: clone_rq)
 -	 */
 -
 -	if (!md->queue->mq_ops)
 -		free_rq_tio(tio);
 +	else
 +		free_clone_request(tio->md, clone);
 +	free_rq_tio(tio);
  }
  
  /*
@@@ -1100,7 -1131,10 +1104,14 @@@ static void dm_end_request(struct reque
  	}
  
  	free_rq_clone(clone);
++<<<<<<< HEAD
 +	blk_end_request_all(rq, error);
++=======
+ 	if (!rq->q->mq_ops)
+ 		blk_end_request_all(rq, error);
+ 	else
+ 		blk_mq_end_request(rq, error);
++>>>>>>> e5d8de32cc02 (dm: fix false warning in free_rq_clone() for unmapped requests)
  	rq_completed(md, rw, true);
  }
  
* Unmerged path drivers/md/dm.c
