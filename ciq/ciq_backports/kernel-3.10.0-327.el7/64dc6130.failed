net: add sk_stream_is_writeable() helper

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] add sk_stream_is_writeable() helper (Florian Westphal) [1151756]
Rebuild_FUZZ: 93.33%
commit-author Eric Dumazet <edumazet@google.com>
commit 64dc61306ce7da370833289739e2f52dfc6b37ba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/64dc6130.failed

Several call sites use the hardcoded following condition :

sk_stream_wspace(sk) >= sk_stream_min_wspace(sk)

Lets use a helper because TCP_NOTSENT_LOWAT support will change this
condition for TCP sockets.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Cc: Neal Cardwell <ncardwell@google.com>
	Cc: Yuchung Cheng <ycheng@google.com>
	Acked-by: Neal Cardwell <ncardwell@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 64dc61306ce7da370833289739e2f52dfc6b37ba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/svcsock.c
diff --cc net/sunrpc/svcsock.c
index 78a9cd1c6b59,0da6785ec15a..000000000000
--- a/net/sunrpc/svcsock.c
+++ b/net/sunrpc/svcsock.c
@@@ -439,31 -438,11 +439,35 @@@ static void svc_write_space(struct soc
  	}
  }
  
 +static int svc_tcp_has_wspace(struct svc_xprt *xprt)
 +{
 +	struct svc_sock *svsk =	container_of(xprt, struct svc_sock, sk_xprt);
 +	struct svc_serv *serv = svsk->sk_xprt.xpt_server;
 +	int required;
 +
 +	if (test_bit(XPT_LISTENER, &xprt->xpt_flags))
 +		return 1;
 +	required = atomic_read(&xprt->xpt_reserved) + serv->sv_max_mesg;
 +	if (sk_stream_wspace(svsk->sk_sk) >= required ||
 +	    (sk_stream_min_wspace(svsk->sk_sk) == 0 &&
 +	     atomic_read(&xprt->xpt_reserved) == 0))
 +		return 1;
 +	set_bit(SOCK_NOSPACE, &svsk->sk_sock->flags);
 +	return 0;
 +}
 +
  static void svc_tcp_write_space(struct sock *sk)
  {
 +	struct svc_sock *svsk = (struct svc_sock *)(sk->sk_user_data);
  	struct socket *sock = sk->sk_socket;
  
++<<<<<<< HEAD
 +	if (!(sk_stream_wspace(sk) >= sk_stream_min_wspace(sk)) || !sock)
 +		return;
 +	if (!svsk || svc_tcp_has_wspace(&svsk->sk_xprt))
++=======
+ 	if (sk_stream_is_writeable(sk) && sock)
++>>>>>>> 64dc61306ce7 (net: add sk_stream_is_writeable() helper)
  		clear_bit(SOCK_NOSPACE, &sock->flags);
  	svc_write_space(sk);
  }
diff --git a/include/net/sock.h b/include/net/sock.h
index c2e48e3f4319..9b12f5364d5c 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -1133,6 +1133,10 @@ static inline struct cg_proto *parent_cg_proto(struct proto *proto,
 }
 #endif
 
+static inline bool sk_stream_is_writeable(const struct sock *sk)
+{
+	return sk_stream_wspace(sk) >= sk_stream_min_wspace(sk);
+}
 
 static inline bool sk_has_memory_pressure(const struct sock *sk)
 {
diff --git a/net/ceph/messenger.c b/net/ceph/messenger.c
index ccc54158a220..92f6515a0ac2 100644
--- a/net/ceph/messenger.c
+++ b/net/ceph/messenger.c
@@ -412,7 +412,7 @@ static void ceph_sock_write_space(struct sock *sk)
 	 * and net/core/stream.c:sk_stream_write_space().
 	 */
 	if (con_flag_test(con, CON_FLAG_WRITE_PENDING)) {
-		if (sk_stream_wspace(sk) >= sk_stream_min_wspace(sk)) {
+		if (sk_stream_is_writeable(sk)) {
 			dout("%s %p queueing write work\n", __func__, con);
 			clear_bit(SOCK_NOSPACE, &sk->sk_socket->flags);
 			queue_con(con);
diff --git a/net/core/stream.c b/net/core/stream.c
index f5df85dcd20b..512f0a24269b 100644
--- a/net/core/stream.c
+++ b/net/core/stream.c
@@ -30,7 +30,7 @@ void sk_stream_write_space(struct sock *sk)
 	struct socket *sock = sk->sk_socket;
 	struct socket_wq *wq;
 
-	if (sk_stream_wspace(sk) >= sk_stream_min_wspace(sk) && sock) {
+	if (sk_stream_is_writeable(sk) && sock) {
 		clear_bit(SOCK_NOSPACE, &sock->flags);
 
 		rcu_read_lock();
diff --git a/net/dccp/proto.c b/net/dccp/proto.c
index e8407f2f600f..f9076f295b13 100644
--- a/net/dccp/proto.c
+++ b/net/dccp/proto.c
@@ -336,7 +336,7 @@ unsigned int dccp_poll(struct file *file, struct socket *sock,
 			mask |= POLLIN | POLLRDNORM;
 
 		if (!(sk->sk_shutdown & SEND_SHUTDOWN)) {
-			if (sk_stream_wspace(sk) >= sk_stream_min_wspace(sk)) {
+			if (sk_stream_is_writeable(sk)) {
 				mask |= POLLOUT | POLLWRNORM;
 			} else {  /* send SIGIO later */
 				set_bit(SOCK_ASYNC_NOSPACE,
@@ -347,7 +347,7 @@ unsigned int dccp_poll(struct file *file, struct socket *sock,
 				 * wspace test but before the flags are set,
 				 * IO signal will be lost.
 				 */
-				if (sk_stream_wspace(sk) >= sk_stream_min_wspace(sk))
+				if (sk_stream_is_writeable(sk))
 					mask |= POLLOUT | POLLWRNORM;
 			}
 		}
diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c
index 9a3f7124a897..3cbe25fbfd88 100644
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@ -500,7 +500,7 @@ unsigned int tcp_poll(struct file *file, struct socket *sock, poll_table *wait)
 			mask |= POLLIN | POLLRDNORM;
 
 		if (!(sk->sk_shutdown & SEND_SHUTDOWN)) {
-			if (sk_stream_wspace(sk) >= sk_stream_min_wspace(sk)) {
+			if (sk_stream_is_writeable(sk)) {
 				mask |= POLLOUT | POLLWRNORM;
 			} else {  /* send SIGIO later */
 				set_bit(SOCK_ASYNC_NOSPACE,
@@ -511,7 +511,7 @@ unsigned int tcp_poll(struct file *file, struct socket *sock, poll_table *wait)
 				 * wspace test but before the flags are set,
 				 * IO signal will be lost.
 				 */
-				if (sk_stream_wspace(sk) >= sk_stream_min_wspace(sk))
+				if (sk_stream_is_writeable(sk))
 					mask |= POLLOUT | POLLWRNORM;
 			}
 		} else
* Unmerged path net/sunrpc/svcsock.c
diff --git a/net/sunrpc/xprtsock.c b/net/sunrpc/xprtsock.c
index d6c816543368..e6abf5a8c54d 100644
--- a/net/sunrpc/xprtsock.c
+++ b/net/sunrpc/xprtsock.c
@@ -1655,7 +1655,7 @@ static void xs_tcp_write_space(struct sock *sk)
 	read_lock_bh(&sk->sk_callback_lock);
 
 	/* from net/core/stream.c:sk_stream_write_space */
-	if (sk_stream_wspace(sk) >= sk_stream_min_wspace(sk))
+	if (sk_stream_is_writeable(sk))
 		xs_write_space(sk);
 
 	read_unlock_bh(&sk->sk_callback_lock);
