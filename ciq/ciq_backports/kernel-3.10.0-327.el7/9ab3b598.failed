mm: hwpoison: drop lru_add_drain_all() in __soft_offline_page()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [mm] hwpoison: drop lru_add_drain_all() in __soft_offline_page() (Tomoaki Nishimura) [1226196]
Rebuild_FUZZ: 96.72%
commit-author Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
commit 9ab3b598d2dfbdb0153ffa7e4b1456bbff59a25d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/9ab3b598.failed

A race condition starts to be visible in recent mmotm, where a PG_hwpoison
flag is set on a migration source page *before* it's back in buddy page
poo= l.

This is problematic because no page flag is supposed to be set when
freeing (see __free_one_page().) So the user-visible effect of this race
is that it could trigger the BUG_ON() when soft-offlining is called.

The root cause is that we call lru_add_drain_all() to make sure that the
page is in buddy, but that doesn't work because this function just
schedule= s a work item and doesn't wait its completion.
drain_all_pages() does drainin= g directly, so simply dropping
lru_add_drain_all() solves this problem.

Fixes: f15bdfa802bf ("mm/memory-failure.c: fix memory leak in successful soft offlining")
	Signed-off-by: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
	Cc: Andi Kleen <andi@firstfloor.org>
	Cc: Tony Luck <tony.luck@intel.com>
	Cc: Chen Gong <gong.chen@linux.intel.com>
	Cc: <stable@vger.kernel.org>	[3.11+]
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 9ab3b598d2dfbdb0153ffa7e4b1456bbff59a25d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memory-failure.c
diff --cc mm/memory-failure.c
index 3b1faba1a963,d487f8dc6d39..000000000000
--- a/mm/memory-failure.c
+++ b/mm/memory-failure.c
@@@ -1725,9 -1647,7 +1725,13 @@@ static int __soft_offline_page(struct p
  			 * setting PG_hwpoison.
  			 */
  			if (!is_free_buddy_page(page))
++<<<<<<< HEAD
 +				lru_add_drain_all();
 +			if (!is_free_buddy_page(page))
 +				drain_all_pages();
++=======
+ 				drain_all_pages(page_zone(page));
++>>>>>>> 9ab3b598d2df (mm: hwpoison: drop lru_add_drain_all() in __soft_offline_page())
  			SetPageHWPoison(page);
  			if (!is_free_buddy_page(page))
  				pr_info("soft offline: %#lx: page leaked\n",
* Unmerged path mm/memory-failure.c
