x86: Add support for Intel Cache QoS Monitoring (CQM) detection

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [x86] Add support for Intel Cache QoS Monitoring (CQM) detection (Don Dugger) [1036948]
Rebuild_FUZZ: 95.87%
commit-author Peter P Waskiewicz Jr <peter.p.waskiewicz.jr@intel.com>
commit cbc82b17263877ea5d21e84c58ce03f0292458a1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/cbc82b17.failed

This patch adds support for the new Cache QoS Monitoring (CQM)
feature found in future Intel Xeon processors.  It includes the
new values to track CQM resources to the cpuinfo_x86 structure,
plus the CPUID detection routines for CQM.

CQM allows a process, or set of processes, to be tracked by the CPU
to determine the cache usage of that task group.  Using this data
from the CPU, software can be written to extract this data and
report cache usage and occupancy for a particular process, or
group of processes.

More information about Cache QoS Monitoring can be found in the
Intel (R) x86 Architecture Software Developer Manual, section 17.14.

	Signed-off-by: Peter P Waskiewicz Jr <peter.p.waskiewicz.jr@intel.com>
	Signed-off-by: Matt Fleming <matt.fleming@intel.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
	Cc: Borislav Petkov <bp@suse.de>
	Cc: Chris Webb <chris@arachsys.com>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: Fenghua Yu <fenghua.yu@intel.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Igor Mammedov <imammedo@redhat.com>
	Cc: Jacob Shin <jacob.w.shin@gmail.com>
	Cc: Jan Beulich <JBeulich@suse.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Kanaka Juvva <kanaka.d.juvva@intel.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Steven Honeyman <stevenhoneyman@gmail.com>
	Cc: Steven Rostedt <srostedt@redhat.com>
	Cc: Vikas Shivappa <vikas.shivappa@linux.intel.com>
Link: http://lkml.kernel.org/r/1422038748-21397-5-git-send-email-matt@codeblueprint.co.uk
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit cbc82b17263877ea5d21e84c58ce03f0292458a1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/cpufeature.h
#	arch/x86/kernel/cpu/common.c
diff --cc arch/x86/include/asm/cpufeature.h
index ba9a53d71585,361922dcc9b1..000000000000
--- a/arch/x86/include/asm/cpufeature.h
+++ b/arch/x86/include/asm/cpufeature.h
@@@ -8,8 -8,12 +8,17 @@@
  #include <asm/required-features.h>
  #endif
  
++<<<<<<< HEAD
 +#define NCAPINTS	20	/* N 32-bit words worth of info */
 +#define NBUGINTS	10	/* N 32-bit bug flags */
++=======
+ #ifndef _ASM_X86_DISABLED_FEATURES_H
+ #include <asm/disabled-features.h>
+ #endif
+ 
+ #define NCAPINTS	13	/* N 32-bit words worth of info */
+ #define NBUGINTS	1	/* N 32-bit bug flags */
++>>>>>>> cbc82b172638 (x86: Add support for Intel Cache QoS Monitoring (CQM) detection)
  
  /*
   * Note: If the comment begins with a quoted string, that string is used
@@@ -206,25 -216,38 +215,60 @@@
  
  
  /* Intel-defined CPU features, CPUID level 0x00000007:0 (ebx), word 9 */
++<<<<<<< HEAD
 +#define X86_FEATURE_FSGSBASE	(9*32+ 0) /* {RD/WR}{FS/GS}BASE instructions*/
 +#define X86_FEATURE_TSC_ADJUST	(9*32+ 1) /* TSC adjustment MSR 0x3b */
 +#define X86_FEATURE_BMI1	(9*32+ 3) /* 1st group bit manipulation extensions */
 +#define X86_FEATURE_HLE		(9*32+ 4) /* Hardware Lock Elision */
 +#define X86_FEATURE_AVX2	(9*32+ 5) /* AVX2 instructions */
 +#define X86_FEATURE_SMEP	(9*32+ 7) /* Supervisor Mode Execution Protection */
 +#define X86_FEATURE_BMI2	(9*32+ 8) /* 2nd group bit manipulation extensions */
 +#define X86_FEATURE_ERMS	(9*32+ 9) /* Enhanced REP MOVSB/STOSB */
 +#define X86_FEATURE_INVPCID	(9*32+10) /* Invalidate Processor Context ID */
 +#define X86_FEATURE_RTM		(9*32+11) /* Restricted Transactional Memory */
 +#define X86_FEATURE_AVX512F	(9*32+16) /* AVX-512 Foundation */
 +#define X86_FEATURE_MPX		(9*32+14) /* Memory Protection Extension */
 +#define X86_FEATURE_RDSEED	(9*32+18) /* The RDSEED instruction */
 +#define X86_FEATURE_ADX		(9*32+19) /* The ADCX and ADOX instructions */
 +#define X86_FEATURE_SMAP	(9*32+20) /* Supervisor Mode Access Prevention */
 +#define X86_FEATURE_CLFLUSHOPT	(9*32+23) /* CLFLUSHOPT instruction */
 +#define X86_FEATURE_AVX512PF	(9*32+26) /* AVX-512 Prefetch */
 +#define X86_FEATURE_AVX512ER	(9*32+27) /* AVX-512 Exponential and Reciprocal */
 +#define X86_FEATURE_AVX512CD	(9*32+28) /* AVX-512 Conflict Detection */
++=======
+ #define X86_FEATURE_FSGSBASE	( 9*32+ 0) /* {RD/WR}{FS/GS}BASE instructions*/
+ #define X86_FEATURE_TSC_ADJUST	( 9*32+ 1) /* TSC adjustment MSR 0x3b */
+ #define X86_FEATURE_BMI1	( 9*32+ 3) /* 1st group bit manipulation extensions */
+ #define X86_FEATURE_HLE		( 9*32+ 4) /* Hardware Lock Elision */
+ #define X86_FEATURE_AVX2	( 9*32+ 5) /* AVX2 instructions */
+ #define X86_FEATURE_SMEP	( 9*32+ 7) /* Supervisor Mode Execution Protection */
+ #define X86_FEATURE_BMI2	( 9*32+ 8) /* 2nd group bit manipulation extensions */
+ #define X86_FEATURE_ERMS	( 9*32+ 9) /* Enhanced REP MOVSB/STOSB */
+ #define X86_FEATURE_INVPCID	( 9*32+10) /* Invalidate Processor Context ID */
+ #define X86_FEATURE_RTM		( 9*32+11) /* Restricted Transactional Memory */
+ #define X86_FEATURE_CQM		( 9*32+12) /* Cache QoS Monitoring */
+ #define X86_FEATURE_MPX		( 9*32+14) /* Memory Protection Extension */
+ #define X86_FEATURE_AVX512F	( 9*32+16) /* AVX-512 Foundation */
+ #define X86_FEATURE_RDSEED	( 9*32+18) /* The RDSEED instruction */
+ #define X86_FEATURE_ADX		( 9*32+19) /* The ADCX and ADOX instructions */
+ #define X86_FEATURE_SMAP	( 9*32+20) /* Supervisor Mode Access Prevention */
+ #define X86_FEATURE_CLFLUSHOPT	( 9*32+23) /* CLFLUSHOPT instruction */
+ #define X86_FEATURE_AVX512PF	( 9*32+26) /* AVX-512 Prefetch */
+ #define X86_FEATURE_AVX512ER	( 9*32+27) /* AVX-512 Exponential and Reciprocal */
+ #define X86_FEATURE_AVX512CD	( 9*32+28) /* AVX-512 Conflict Detection */
+ 
+ /* Extended state features, CPUID level 0x0000000d:1 (eax), word 10 */
+ #define X86_FEATURE_XSAVEOPT	(10*32+ 0) /* XSAVEOPT */
+ #define X86_FEATURE_XSAVEC	(10*32+ 1) /* XSAVEC */
+ #define X86_FEATURE_XGETBV1	(10*32+ 2) /* XGETBV with ECX = 1 */
+ #define X86_FEATURE_XSAVES	(10*32+ 3) /* XSAVES/XRSTORS */
++>>>>>>> cbc82b172638 (x86: Add support for Intel Cache QoS Monitoring (CQM) detection)
+ 
+ /* Intel-defined CPU QoS Sub-leaf, CPUID level 0x0000000F:0 (edx), word 11 */
+ #define X86_FEATURE_CQM_LLC	(11*32+ 1) /* LLC QoS if 1 */
+ 
+ /* Intel-defined CPU QoS Sub-leaf, CPUID level 0x0000000F:1 (edx), word 12 */
+ #define X86_FEATURE_CQM_OCCUP_LLC (12*32+ 0) /* LLC occupancy monitoring if 1 */
  
  /*
   * BUG word(s)
diff --cc arch/x86/kernel/cpu/common.c
index a968de0cc209,9fa00b2ea0ee..000000000000
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@@ -624,6 -636,39 +624,42 @@@ void get_cpu_cap(struct cpuinfo_x86 *c
  		c->x86_capability[9] = ebx;
  	}
  
++<<<<<<< HEAD
++=======
+ 	/* Extended state features: level 0x0000000d */
+ 	if (c->cpuid_level >= 0x0000000d) {
+ 		u32 eax, ebx, ecx, edx;
+ 
+ 		cpuid_count(0x0000000d, 1, &eax, &ebx, &ecx, &edx);
+ 
+ 		c->x86_capability[10] = eax;
+ 	}
+ 
+ 	/* Additional Intel-defined flags: level 0x0000000F */
+ 	if (c->cpuid_level >= 0x0000000F) {
+ 		u32 eax, ebx, ecx, edx;
+ 
+ 		/* QoS sub-leaf, EAX=0Fh, ECX=0 */
+ 		cpuid_count(0x0000000F, 0, &eax, &ebx, &ecx, &edx);
+ 		c->x86_capability[11] = edx;
+ 		if (cpu_has(c, X86_FEATURE_CQM_LLC)) {
+ 			/* will be overridden if occupancy monitoring exists */
+ 			c->x86_cache_max_rmid = ebx;
+ 
+ 			/* QoS sub-leaf, EAX=0Fh, ECX=1 */
+ 			cpuid_count(0x0000000F, 1, &eax, &ebx, &ecx, &edx);
+ 			c->x86_capability[12] = edx;
+ 			if (cpu_has(c, X86_FEATURE_CQM_OCCUP_LLC)) {
+ 				c->x86_cache_max_rmid = ecx;
+ 				c->x86_cache_occ_scale = ebx;
+ 			}
+ 		} else {
+ 			c->x86_cache_max_rmid = -1;
+ 			c->x86_cache_occ_scale = -1;
+ 		}
+ 	}
+ 
++>>>>>>> cbc82b172638 (x86: Add support for Intel Cache QoS Monitoring (CQM) detection)
  	/* AMD-defined flags: level 0x80000001 */
  	xlvl = cpuid_eax(0x80000000);
  	c->extended_cpuid_level = xlvl;
* Unmerged path arch/x86/include/asm/cpufeature.h
diff --git a/arch/x86/include/asm/processor.h b/arch/x86/include/asm/processor.h
index 37db43ed240b..90c79a4d2a9e 100644
--- a/arch/x86/include/asm/processor.h
+++ b/arch/x86/include/asm/processor.h
@@ -116,6 +116,9 @@ struct cpuinfo_x86 {
 	/* in KB - valid for CPUS which support this call: */
 	int			x86_cache_size;
 	int			x86_cache_alignment;	/* In bytes */
+	/* Cache QoS architectural values: */
+	int			x86_cache_max_rmid;	/* max index */
+	int			x86_cache_occ_scale;	/* scale to bytes */
 	int			x86_power;
 	unsigned long		loops_per_jiffy;
 	/* cpuid returned max cores value: */
* Unmerged path arch/x86/kernel/cpu/common.c
