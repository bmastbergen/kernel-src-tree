IB/iser: Fix race between iser connection teardown and scsi TMFs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [infiniband] iser: Fix race between iser connection teardown and scsi TMFs (Amir Vadai) [1164539]
Rebuild_FUZZ: 97.60%
commit-author Sagi Grimberg <sagig@mellanox.com>
commit 7414dde0a6c3a958e26141991bf5c75dc58d28b2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/7414dde0.failed

In certain scenarios (target kill with live IO) scsi TMFs may race
with iser RDMA teardown, which might cause NULL dereference on iser IB
device handle (which might have been freed). In this case we take a
conditional lock for TMFs and check the connection state (avoid
introducing lock contention in the IO path). This is indeed best
effort approach, but sufficient to survive multi targets sudden death
while heavy IO is inflight.

While we are on it, add a nice kernel-doc style documentation.

	Reported-by: Ariel Nahum <arieln@mellanox.com>
	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Roland Dreier <roland@purestorage.com>
(cherry picked from commit 7414dde0a6c3a958e26141991bf5c75dc58d28b2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/iser/iscsi_iser.c
diff --cc drivers/infiniband/ulp/iser/iscsi_iser.c
index 9e53334ea7c7,bca97dcf0b4e..000000000000
--- a/drivers/infiniband/ulp/iser/iscsi_iser.c
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.c
@@@ -164,13 -164,35 +164,40 @@@ iscsi_iser_pdu_alloc(struct iscsi_task 
  	return 0;
  }
  
- int iser_initialize_task_headers(struct iscsi_task *task,
- 						struct iser_tx_desc *tx_desc)
+ /**
+  * iser_initialize_task_headers() - Initialize task headers
+  * @task:       iscsi task
+  * @tx_desc:    iser tx descriptor
+  *
+  * Notes:
+  * This routine may race with iser teardown flow for scsi
+  * error handling TMFs. So for TMF we should acquire the
+  * state mutex to avoid dereferencing the IB device which
+  * may have already been terminated.
+  */
+ int
+ iser_initialize_task_headers(struct iscsi_task *task,
+ 			     struct iser_tx_desc *tx_desc)
  {
++<<<<<<< HEAD
 +	struct iser_conn       *ib_conn   = task->conn->dd_data;
 +	struct iser_device     *device    = ib_conn->device;
++=======
+ 	struct iser_conn *iser_conn = task->conn->dd_data;
+ 	struct iser_device *device = iser_conn->ib_conn.device;
++>>>>>>> 7414dde0a6c3 (IB/iser: Fix race between iser connection teardown and scsi TMFs)
  	struct iscsi_iser_task *iser_task = task->dd_data;
  	u64 dma_addr;
+ 	const bool mgmt_task = !task->sc && !in_interrupt();
+ 	int ret = 0;
+ 
+ 	if (unlikely(mgmt_task))
+ 		mutex_lock(&iser_conn->state_mutex);
+ 
+ 	if (unlikely(iser_conn->state != ISER_CONN_UP)) {
+ 		ret = -ENODEV;
+ 		goto out;
+ 	}
  
  	dma_addr = ib_dma_map_single(device->ib_device, (void *)tx_desc,
  				ISER_HEADERS_LEN, DMA_TO_DEVICE);
@@@ -182,8 -206,12 +211,17 @@@
  	tx_desc->tx_sg[0].length = ISER_HEADERS_LEN;
  	tx_desc->tx_sg[0].lkey   = device->mr->lkey;
  
++<<<<<<< HEAD
 +	iser_task->ib_conn = ib_conn;
 +	return 0;
++=======
+ 	iser_task->iser_conn = iser_conn;
+ out:
+ 	if (unlikely(mgmt_task))
+ 		mutex_unlock(&iser_conn->state_mutex);
+ 
+ 	return ret;
++>>>>>>> 7414dde0a6c3 (IB/iser: Fix race between iser connection teardown and scsi TMFs)
  }
  
  /**
* Unmerged path drivers/infiniband/ulp/iser/iscsi_iser.c
