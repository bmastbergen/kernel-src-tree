xfs: use generic percpu counters for free inode counter

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit e88b64ea1f3da64dbb52636377be295c90367377
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/e88b64ea.failed

XFS has hand-rolled per-cpu counters for the superblock since before
there was any generic implementation. The free inode counter is not
used for any limit enforcement - the per-AG free inode counters are
used during allocation to determine if there are inode available for
allocation.

Hence we don't need any of the complexity of the hand-rolled
counters and we can simply replace them with generic per-cpu
counters similar to the inode counter.

This version introduces a xfs_mod_ifree() helper function from
Christoph Hellwig.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit e88b64ea1f3da64dbb52636377be295c90367377)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_sb.c
#	fs/xfs/xfs_fsops.c
#	fs/xfs/xfs_mount.c
#	fs/xfs/xfs_mount.h
#	fs/xfs/xfs_super.c
diff --cc fs/xfs/libxfs/xfs_sb.c
index 07f47e5690d3,b66aeab99cfb..000000000000
--- a/fs/xfs/libxfs/xfs_sb.c
+++ b/fs/xfs/libxfs/xfs_sb.c
@@@ -826,42 -759,54 +826,47 @@@ xfs_initialize_perag_data
  }
  
  /*
 - * xfs_log_sb() can be used to copy arbitrary changes to the in-core superblock
 - * into the superblock buffer to be logged.  It does not provide the higher
 - * level of locking that is needed to protect the in-core superblock from
 - * concurrent access.
 + * xfs_mod_sb() can be used to copy arbitrary changes to the
 + * in-core superblock into the superblock buffer to be logged.
 + * It does not provide the higher level of locking that is
 + * needed to protect the in-core superblock from concurrent
 + * access.
   */
  void
 -xfs_log_sb(
 -	struct xfs_trans	*tp)
 +xfs_mod_sb(xfs_trans_t *tp, __int64_t fields)
  {
 -	struct xfs_mount	*mp = tp->t_mountp;
 -	struct xfs_buf		*bp = xfs_trans_getsb(tp, mp, 0);
 +	xfs_buf_t	*bp;
 +	int		first;
 +	int		last;
 +	xfs_mount_t	*mp;
 +	xfs_sb_field_t	f;
 +
++<<<<<<< HEAD
 +	ASSERT(fields);
 +	if (!fields)
 +		return;
 +	mp = tp->t_mountp;
 +	bp = xfs_trans_getsb(tp, mp, 0);
 +	first = sizeof(xfs_sb_t);
 +	last = 0;
  
 -	mp->m_sb.sb_icount = percpu_counter_sum(&mp->m_icount);
 -	mp->m_sb.sb_ifree = percpu_counter_sum(&mp->m_ifree);
 +	/* translate/copy */
  
 -	xfs_sb_to_disk(XFS_BUF_TO_SBP(bp), &mp->m_sb);
 -	xfs_trans_buf_set_type(tp, bp, XFS_BLFT_SB_BUF);
 -	xfs_trans_log_buf(tp, bp, 0, sizeof(struct xfs_dsb));
 -}
 +	xfs_sb_to_disk(XFS_BUF_TO_SBP(bp), &mp->m_sb, fields);
  
 -/*
 - * xfs_sync_sb
 - *
 - * Sync the superblock to disk.
 - *
 - * Note that the caller is responsible for checking the frozen state of the
 - * filesystem. This procedure uses the non-blocking transaction allocator and
 - * thus will allow modifications to a frozen fs. This is required because this
 - * code can be called during the process of freezing where use of the high-level
 - * allocator would deadlock.
 - */
 -int
 -xfs_sync_sb(
 -	struct xfs_mount	*mp,
 -	bool			wait)
 -{
 -	struct xfs_trans	*tp;
 -	int			error;
 +	/* find modified range */
 +	f = (xfs_sb_field_t)xfs_highbit64((__uint64_t)fields);
 +	ASSERT((1LL << f) & XFS_SB_MOD_BITS);
 +	last = xfs_sb_info[f + 1].offset - 1;
  
 -	tp = _xfs_trans_alloc(mp, XFS_TRANS_SB_CHANGE, KM_SLEEP);
 -	error = xfs_trans_reserve(tp, &M_RES(mp)->tr_sb, 0, 0);
 -	if (error) {
 -		xfs_trans_cancel(tp, 0);
 -		return error;
 -	}
 +	f = (xfs_sb_field_t)xfs_lowbit64((__uint64_t)fields);
 +	ASSERT((1LL << f) & XFS_SB_MOD_BITS);
 +	first = xfs_sb_info[f].offset;
++=======
++	mp->m_sb.sb_icount = percpu_counter_sum(&mp->m_icount);
++	mp->m_sb.sb_ifree = percpu_counter_sum(&mp->m_ifree);
++>>>>>>> e88b64ea1f3d (xfs: use generic percpu counters for free inode counter)
  
 -	xfs_log_sb(tp);
 -	if (wait)
 -		xfs_trans_set_sync(tp);
 -	return xfs_trans_commit(tp, 0);
 +	xfs_trans_buf_set_type(tp, bp, XFS_BLFT_SB_BUF);
 +	xfs_trans_log_buf(tp, bp, first, last);
  }
diff --cc fs/xfs/xfs_fsops.c
index 5f4d1f6b208b,a1ca9c2b8c00..000000000000
--- a/fs/xfs/xfs_fsops.c
+++ b/fs/xfs/xfs_fsops.c
@@@ -648,11 -638,12 +648,20 @@@ xfs_fs_counts
  	xfs_fsop_counts_t	*cnt)
  {
  	xfs_icsb_sync_counters(mp, XFS_ICSB_LAZY_COUNT);
++<<<<<<< HEAD
 +	spin_lock(&mp->m_sb_lock);
 +	cnt->freedata = mp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);
 +	cnt->freertx = mp->m_sb.sb_frextents;
 +	cnt->freeino = mp->m_sb.sb_ifree;
 +	cnt->allocino = mp->m_sb.sb_icount;
++=======
+ 	cnt->allocino = percpu_counter_read_positive(&mp->m_icount);
+ 	cnt->freeino = percpu_counter_read_positive(&mp->m_ifree);
+ 
+ 	spin_lock(&mp->m_sb_lock);
+ 	cnt->freedata = mp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);
+ 	cnt->freertx = mp->m_sb.sb_frextents;
++>>>>>>> e88b64ea1f3d (xfs: use generic percpu counters for free inode counter)
  	spin_unlock(&mp->m_sb_lock);
  	return 0;
  }
diff --cc fs/xfs/xfs_mount.c
index 1f0460bd27b8,650e8f18cd2a..000000000000
--- a/fs/xfs/xfs_mount.c
+++ b/fs/xfs/xfs_mount.c
@@@ -1123,19 -1096,38 +1123,33 @@@ xfs_log_sbcount(xfs_mount_t *mp
  	if (!xfs_sb_version_haslazysbcount(&mp->m_sb))
  		return 0;
  
 -	return xfs_sync_sb(mp, true);
 -}
 -
 -int
 -xfs_mod_icount(
 -	struct xfs_mount	*mp,
 -	int64_t			delta)
 -{
 -	/* deltas are +/-64, hence the large batch size of 128. */
 -	__percpu_counter_add(&mp->m_icount, delta, 128);
 -	if (percpu_counter_compare(&mp->m_icount, 0) < 0) {
 -		ASSERT(0);
 -		percpu_counter_add(&mp->m_icount, -delta);
 -		return -EINVAL;
 +	tp = _xfs_trans_alloc(mp, XFS_TRANS_SB_COUNT, KM_SLEEP);
 +	error = xfs_trans_reserve(tp, &M_RES(mp)->tr_sb, 0, 0);
 +	if (error) {
 +		xfs_trans_cancel(tp, 0);
 +		return error;
  	}
 -	return 0;
 +
 +	xfs_mod_sb(tp, XFS_SB_IFREE | XFS_SB_ICOUNT | XFS_SB_FDBLOCKS);
 +	xfs_trans_set_sync(tp);
 +	error = xfs_trans_commit(tp, 0);
 +	return error;
  }
  
+ 
+ int
+ xfs_mod_ifree(
+ 	struct xfs_mount	*mp,
+ 	int64_t			delta)
+ {
+ 	percpu_counter_add(&mp->m_ifree, delta);
+ 	if (percpu_counter_compare(&mp->m_ifree, 0) < 0) {
+ 		ASSERT(0);
+ 		percpu_counter_add(&mp->m_ifree, -delta);
+ 		return -EINVAL;
+ 	}
+ 	return 0;
+ }
  /*
   * xfs_mod_incore_sb_unlocked() is a utility routine commonly used to apply
   * a delta to a specified field in the in-core superblock.  Simply
@@@ -1164,23 -1156,9 +1178,29 @@@ xfs_mod_incore_sb_unlocked
  	 */
  	switch (field) {
  	case XFS_SBS_ICOUNT:
++<<<<<<< HEAD
 +		lcounter = (long long)mp->m_sb.sb_icount;
 +		lcounter += delta;
 +		if (lcounter < 0) {
 +			ASSERT(0);
 +			return XFS_ERROR(EINVAL);
 +		}
 +		mp->m_sb.sb_icount = lcounter;
 +		return 0;
 +	case XFS_SBS_IFREE:
 +		lcounter = (long long)mp->m_sb.sb_ifree;
 +		lcounter += delta;
 +		if (lcounter < 0) {
 +			ASSERT(0);
 +			return XFS_ERROR(EINVAL);
 +		}
 +		mp->m_sb.sb_ifree = lcounter;
 +		return 0;
++=======
+ 	case XFS_SBS_IFREE:
+ 		ASSERT(0);
+ 		return -EINVAL;
++>>>>>>> e88b64ea1f3d (xfs: use generic percpu counters for free inode counter)
  	case XFS_SBS_FDBLOCKS:
  		lcounter = (long long)
  			mp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);
@@@ -1557,8 -1508,6 +1577,11 @@@ xfs_icsb_cpu_notify
  	case CPU_ONLINE:
  	case CPU_ONLINE_FROZEN:
  		xfs_icsb_lock(mp);
++<<<<<<< HEAD
 +		xfs_icsb_balance_counter(mp, XFS_SBS_ICOUNT, 0);
 +		xfs_icsb_balance_counter(mp, XFS_SBS_IFREE, 0);
++=======
++>>>>>>> e88b64ea1f3d (xfs: use generic percpu counters for free inode counter)
  		xfs_icsb_balance_counter(mp, XFS_SBS_FDBLOCKS, 0);
  		xfs_icsb_unlock(mp);
  		break;
@@@ -1569,18 -1518,12 +1592,26 @@@
  		 * re-enable the counters. */
  		xfs_icsb_lock(mp);
  		spin_lock(&mp->m_sb_lock);
++<<<<<<< HEAD
 +		xfs_icsb_disable_counter(mp, XFS_SBS_ICOUNT);
 +		xfs_icsb_disable_counter(mp, XFS_SBS_IFREE);
  		xfs_icsb_disable_counter(mp, XFS_SBS_FDBLOCKS);
  
 +		mp->m_sb.sb_icount += cntp->icsb_icount;
 +		mp->m_sb.sb_ifree += cntp->icsb_ifree;
++=======
++		xfs_icsb_disable_counter(mp, XFS_SBS_FDBLOCKS);
++
++>>>>>>> e88b64ea1f3d (xfs: use generic percpu counters for free inode counter)
  		mp->m_sb.sb_fdblocks += cntp->icsb_fdblocks;
  
  		memset(cntp, 0, sizeof(xfs_icsb_cnts_t));
  
++<<<<<<< HEAD
 +		xfs_icsb_balance_counter_locked(mp, XFS_SBS_ICOUNT, 0);
 +		xfs_icsb_balance_counter_locked(mp, XFS_SBS_IFREE, 0);
++=======
++>>>>>>> e88b64ea1f3d (xfs: use generic percpu counters for free inode counter)
  		xfs_icsb_balance_counter_locked(mp, XFS_SBS_FDBLOCKS, 0);
  		spin_unlock(&mp->m_sb_lock);
  		xfs_icsb_unlock(mp);
@@@ -1596,11 -1539,22 +1627,27 @@@ xfs_icsb_init_counters
  	xfs_mount_t	*mp)
  {
  	xfs_icsb_cnts_t *cntp;
 -	int		error;
  	int		i;
  
++<<<<<<< HEAD
 +	mp->m_sb_cnts = alloc_percpu(xfs_icsb_cnts_t);
 +	if (mp->m_sb_cnts == NULL)
 +		return -ENOMEM;
++=======
+ 	error = percpu_counter_init(&mp->m_icount, 0, GFP_KERNEL);
+ 	if (error)
+ 		return error;
+ 
+ 	error = percpu_counter_init(&mp->m_ifree, 0, GFP_KERNEL);
+ 	if (error)
+ 		goto free_icount;
+ 
+ 	mp->m_sb_cnts = alloc_percpu(xfs_icsb_cnts_t);
+ 	if (!mp->m_sb_cnts) {
+ 		error = -ENOMEM;
+ 		goto free_ifree;
+ 	}
++>>>>>>> e88b64ea1f3d (xfs: use generic percpu counters for free inode counter)
  
  	for_each_online_cpu(i) {
  		cntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);
@@@ -1628,14 -1588,15 +1681,23 @@@ voi
  xfs_icsb_reinit_counters(
  	xfs_mount_t	*mp)
  {
++<<<<<<< HEAD
++=======
+ 	percpu_counter_set(&mp->m_icount, mp->m_sb.sb_icount);
+ 	percpu_counter_set(&mp->m_ifree, mp->m_sb.sb_ifree);
+ 
++>>>>>>> e88b64ea1f3d (xfs: use generic percpu counters for free inode counter)
  	xfs_icsb_lock(mp);
  	/*
  	 * start with all counters disabled so that the
  	 * initial balance kicks us off correctly
  	 */
  	mp->m_icsb_counters = -1;
++<<<<<<< HEAD
 +	xfs_icsb_balance_counter(mp, XFS_SBS_ICOUNT, 0);
 +	xfs_icsb_balance_counter(mp, XFS_SBS_IFREE, 0);
++=======
++>>>>>>> e88b64ea1f3d (xfs: use generic percpu counters for free inode counter)
  	xfs_icsb_balance_counter(mp, XFS_SBS_FDBLOCKS, 0);
  	xfs_icsb_unlock(mp);
  }
@@@ -1648,6 -1609,10 +1710,13 @@@ xfs_icsb_destroy_counters
  		unregister_hotcpu_notifier(&mp->m_icsb_notifier);
  		free_percpu(mp->m_sb_cnts);
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	percpu_counter_destroy(&mp->m_icount);
+ 	percpu_counter_destroy(&mp->m_ifree);
+ 
++>>>>>>> e88b64ea1f3d (xfs: use generic percpu counters for free inode counter)
  	mutex_destroy(&mp->m_icsb_mutex);
  }
  
@@@ -1710,8 -1675,6 +1779,11 @@@ xfs_icsb_count
  
  	for_each_online_cpu(i) {
  		cntp = (xfs_icsb_cnts_t *)per_cpu_ptr(mp->m_sb_cnts, i);
++<<<<<<< HEAD
 +		cnt->icsb_icount += cntp->icsb_icount;
 +		cnt->icsb_ifree += cntp->icsb_ifree;
++=======
++>>>>>>> e88b64ea1f3d (xfs: use generic percpu counters for free inode counter)
  		cnt->icsb_fdblocks += cntp->icsb_fdblocks;
  	}
  
@@@ -1724,7 -1687,7 +1796,11 @@@ xfs_icsb_counter_disabled
  	xfs_mount_t	*mp,
  	xfs_sb_field_t	field)
  {
++<<<<<<< HEAD
 +	ASSERT((field >= XFS_SBS_ICOUNT) && (field <= XFS_SBS_FDBLOCKS));
++=======
+ 	ASSERT(field == XFS_SBS_FDBLOCKS);
++>>>>>>> e88b64ea1f3d (xfs: use generic percpu counters for free inode counter)
  	return test_bit(field, &mp->m_icsb_counters);
  }
  
@@@ -1735,7 -1698,7 +1811,11 @@@ xfs_icsb_disable_counter
  {
  	xfs_icsb_cnts_t	cnt;
  
++<<<<<<< HEAD
 +	ASSERT((field >= XFS_SBS_ICOUNT) && (field <= XFS_SBS_FDBLOCKS));
++=======
+ 	ASSERT(field == XFS_SBS_FDBLOCKS);
++>>>>>>> e88b64ea1f3d (xfs: use generic percpu counters for free inode counter)
  
  	/*
  	 * If we are already disabled, then there is nothing to do
@@@ -1754,12 -1717,6 +1834,15 @@@
  
  		xfs_icsb_count(mp, &cnt, XFS_ICSB_LAZY_COUNT);
  		switch(field) {
++<<<<<<< HEAD
 +		case XFS_SBS_ICOUNT:
 +			mp->m_sb.sb_icount = cnt.icsb_icount;
 +			break;
 +		case XFS_SBS_IFREE:
 +			mp->m_sb.sb_ifree = cnt.icsb_ifree;
 +			break;
++=======
++>>>>>>> e88b64ea1f3d (xfs: use generic percpu counters for free inode counter)
  		case XFS_SBS_FDBLOCKS:
  			mp->m_sb.sb_fdblocks = cnt.icsb_fdblocks;
  			break;
@@@ -1781,18 -1738,12 +1864,25 @@@ xfs_icsb_enable_counter
  	xfs_icsb_cnts_t	*cntp;
  	int		i;
  
++<<<<<<< HEAD
 +	ASSERT((field >= XFS_SBS_ICOUNT) && (field <= XFS_SBS_FDBLOCKS));
++=======
+ 	ASSERT(field == XFS_SBS_FDBLOCKS);
++>>>>>>> e88b64ea1f3d (xfs: use generic percpu counters for free inode counter)
  
  	xfs_icsb_lock_all_counters(mp);
  	for_each_online_cpu(i) {
  		cntp = per_cpu_ptr(mp->m_sb_cnts, i);
  		switch (field) {
++<<<<<<< HEAD
 +		case XFS_SBS_ICOUNT:
 +			cntp->icsb_icount = count + resid;
 +			break;
 +		case XFS_SBS_IFREE:
 +			cntp->icsb_ifree = count + resid;
 +			break;
++=======
++>>>>>>> e88b64ea1f3d (xfs: use generic percpu counters for free inode counter)
  		case XFS_SBS_FDBLOCKS:
  			cntp->icsb_fdblocks = count + resid;
  			break;
@@@ -1815,10 -1766,6 +1905,13 @@@ xfs_icsb_sync_counters_locked
  
  	xfs_icsb_count(mp, &cnt, flags);
  
++<<<<<<< HEAD
 +	if (!xfs_icsb_counter_disabled(mp, XFS_SBS_ICOUNT))
 +		mp->m_sb.sb_icount = cnt.icsb_icount;
 +	if (!xfs_icsb_counter_disabled(mp, XFS_SBS_IFREE))
 +		mp->m_sb.sb_ifree = cnt.icsb_ifree;
++=======
++>>>>>>> e88b64ea1f3d (xfs: use generic percpu counters for free inode counter)
  	if (!xfs_icsb_counter_disabled(mp, XFS_SBS_FDBLOCKS))
  		mp->m_sb.sb_fdblocks = cnt.icsb_fdblocks;
  }
@@@ -1870,18 -1817,6 +1963,21 @@@ xfs_icsb_balance_counter_locked
  
  	/* update counters  - first CPU gets residual*/
  	switch (field) {
++<<<<<<< HEAD
 +	case XFS_SBS_ICOUNT:
 +		count = mp->m_sb.sb_icount;
 +		resid = do_div(count, weight);
 +		if (count < max(min, XFS_ICSB_INO_CNTR_REENABLE))
 +			return;
 +		break;
 +	case XFS_SBS_IFREE:
 +		count = mp->m_sb.sb_ifree;
 +		resid = do_div(count, weight);
 +		if (count < max(min, XFS_ICSB_INO_CNTR_REENABLE))
 +			return;
 +		break;
++=======
++>>>>>>> e88b64ea1f3d (xfs: use generic percpu counters for free inode counter)
  	case XFS_SBS_FDBLOCKS:
  		count = mp->m_sb.sb_fdblocks;
  		resid = do_div(count, weight);
@@@ -1936,22 -1871,6 +2032,25 @@@ again
  	}
  
  	switch (field) {
++<<<<<<< HEAD
 +	case XFS_SBS_ICOUNT:
 +		lcounter = icsbp->icsb_icount;
 +		lcounter += delta;
 +		if (unlikely(lcounter < 0))
 +			goto balance_counter;
 +		icsbp->icsb_icount = lcounter;
 +		break;
 +
 +	case XFS_SBS_IFREE:
 +		lcounter = icsbp->icsb_ifree;
 +		lcounter += delta;
 +		if (unlikely(lcounter < 0))
 +			goto balance_counter;
 +		icsbp->icsb_ifree = lcounter;
 +		break;
 +
++=======
++>>>>>>> e88b64ea1f3d (xfs: use generic percpu counters for free inode counter)
  	case XFS_SBS_FDBLOCKS:
  		BUG_ON((mp->m_resblks - mp->m_resblks_avail) != 0);
  
diff --cc fs/xfs/xfs_mount.h
index 77ab2563aabb,7ce997d43d81..000000000000
--- a/fs/xfs/xfs_mount.h
+++ b/fs/xfs/xfs_mount.h
@@@ -81,8 -80,12 +81,14 @@@ typedef struct xfs_mount 
  	struct super_block	*m_super;
  	xfs_tid_t		m_tid;		/* next unused tid for fs */
  	struct xfs_ail		*m_ail;		/* fs active log item list */
 -
 -	struct xfs_sb		m_sb;		/* copy of fs superblock */
 +	xfs_sb_t		m_sb;		/* copy of fs superblock */
  	spinlock_t		m_sb_lock;	/* sb counter lock */
++<<<<<<< HEAD
++=======
+ 	struct percpu_counter	m_icount;	/* allocated inodes counter */
+ 	struct percpu_counter	m_ifree;	/* free inodes counter */
+ 
++>>>>>>> e88b64ea1f3d (xfs: use generic percpu counters for free inode counter)
  	struct xfs_buf		*m_sb_bp;	/* buffer for superblock */
  	char			*m_fsname;	/* filesystem name */
  	int			m_fsname_len;	/* strlen of fs name */
@@@ -399,7 -391,9 +405,13 @@@ extern void	xfs_unmountfs(xfs_mount_t *
  extern int	xfs_mod_incore_sb(xfs_mount_t *, xfs_sb_field_t, int64_t, int);
  extern int	xfs_mod_incore_sb_batch(xfs_mount_t *, xfs_mod_sb_t *,
  			uint, int);
++<<<<<<< HEAD
 +extern int	xfs_mount_log_sb(xfs_mount_t *, __int64_t);
++=======
+ extern int	xfs_mod_icount(struct xfs_mount *mp, int64_t delta);
+ extern int	xfs_mod_ifree(struct xfs_mount *mp, int64_t delta);
+ extern int	xfs_mount_log_sb(xfs_mount_t *);
++>>>>>>> e88b64ea1f3d (xfs: use generic percpu counters for free inode counter)
  extern struct xfs_buf *xfs_getsb(xfs_mount_t *, int);
  extern int	xfs_readsb(xfs_mount_t *, int);
  extern void	xfs_freesb(xfs_mount_t *);
diff --cc fs/xfs/xfs_super.c
index a9ec2c211f1a,049147776ee1..000000000000
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@@ -1097,6 -1085,8 +1097,11 @@@ xfs_fs_statfs
  	xfs_sb_t		*sbp = &mp->m_sb;
  	struct xfs_inode	*ip = XFS_I(dentry->d_inode);
  	__uint64_t		fakeinos, id;
++<<<<<<< HEAD
++=======
+ 	__uint64_t		icount;
+ 	__uint64_t		ifree;
++>>>>>>> e88b64ea1f3d (xfs: use generic percpu counters for free inode counter)
  	xfs_extlen_t		lsize;
  	__int64_t		ffree;
  
@@@ -1108,6 -1098,8 +1113,11 @@@
  	statp->f_fsid.val[1] = (u32)(id >> 32);
  
  	xfs_icsb_sync_counters(mp, XFS_ICSB_LAZY_COUNT);
++<<<<<<< HEAD
++=======
+ 	icount = percpu_counter_sum(&mp->m_icount);
+ 	ifree = percpu_counter_sum(&mp->m_ifree);
++>>>>>>> e88b64ea1f3d (xfs: use generic percpu counters for free inode counter)
  
  	spin_lock(&mp->m_sb_lock);
  	statp->f_bsize = sbp->sb_blocksize;
@@@ -1129,7 -1120,7 +1139,11 @@@
  					sbp->sb_icount);
  
  	/* make sure statp->f_ffree does not underflow */
++<<<<<<< HEAD
 +	ffree = statp->f_files - (sbp->sb_icount - sbp->sb_ifree);
++=======
+ 	ffree = statp->f_files - (icount - ifree);
++>>>>>>> e88b64ea1f3d (xfs: use generic percpu counters for free inode counter)
  	statp->f_ffree = max_t(__int64_t, ffree, 0);
  
  	spin_unlock(&mp->m_sb_lock);
* Unmerged path fs/xfs/libxfs/xfs_sb.c
* Unmerged path fs/xfs/xfs_fsops.c
* Unmerged path fs/xfs/xfs_mount.c
* Unmerged path fs/xfs/xfs_mount.h
* Unmerged path fs/xfs/xfs_super.c
diff --git a/fs/xfs/xfs_trans.c b/fs/xfs/xfs_trans.c
index ddcabad67a51..8cc78c08515b 100644
--- a/fs/xfs/xfs_trans.c
+++ b/fs/xfs/xfs_trans.c
@@ -563,8 +563,7 @@ xfs_trans_unreserve_and_mod_sb(
 	}
 
 	if (ifreedelta) {
-		error = xfs_icsb_modify_counters(mp, XFS_SBS_IFREE,
-						 ifreedelta, rsvd);
+		error = xfs_mod_ifree(mp, ifreedelta);
 		if (error)
 			goto out_undo_icount;
 	}
@@ -633,7 +632,7 @@ xfs_trans_unreserve_and_mod_sb(
 
 out_undo_ifreecount:
 	if (ifreedelta)
-		xfs_icsb_modify_counters(mp, XFS_SBS_IFREE, -ifreedelta, rsvd);
+		xfs_mod_ifree(mp, -ifreedelta);
 out_undo_icount:
 	if (idelta)
 		xfs_icsb_modify_counters(mp, XFS_SBS_ICOUNT, -idelta, rsvd);
