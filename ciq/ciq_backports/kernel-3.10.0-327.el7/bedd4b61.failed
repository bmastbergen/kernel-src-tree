nfsd: convert the lru list into a per-bucket thing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit bedd4b61a46d0398192a08fbe6821d1ac65aba84
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/bedd4b61.failed

	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit bedd4b61a46d0398192a08fbe6821d1ac65aba84)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfscache.c
diff --cc fs/nfsd/nfscache.c
index dfe380798466,c01f44eb7fe4..000000000000
--- a/fs/nfsd/nfscache.c
+++ b/fs/nfsd/nfscache.c
@@@ -231,16 -243,13 +240,21 @@@ hash_refile(struct nfsd_drc_bucket *b, 
  	hlist_add_head(&rp->c_hash, &b->cache_hash);
  }
  
++<<<<<<< HEAD
 +/*
 + * Walk the LRU list and prune off entries that are older than RC_EXPIRE.
 + * Also prune the oldest ones when the total exceeds the max number of entries.
 + */
 +static void
 +prune_cache_entries(void)
++=======
+ static long
+ prune_bucket(struct nfsd_drc_bucket *b)
++>>>>>>> bedd4b61a46d (nfsd: convert the lru list into a per-bucket thing)
  {
  	struct svc_cacherep *rp, *tmp;
 -	long freed = 0;
  
- 	list_for_each_entry_safe(rp, tmp, &lru_head, c_lru) {
+ 	list_for_each_entry_safe(rp, tmp, &b->lru_head, c_lru) {
  		/*
  		 * Don't free entries attached to calls that are still
  		 * in-progress, but do keep scanning the list.
@@@ -251,18 -260,37 +265,35 @@@
  		    time_before(jiffies, rp->c_timestamp + RC_EXPIRE))
  			break;
  		nfsd_reply_cache_free_locked(rp);
 -		freed++;
  	}
+ 	return freed;
+ }
+ 
+ /*
+  * Walk the LRU list and prune off entries that are older than RC_EXPIRE.
+  * Also prune the oldest ones when the total exceeds the max number of entries.
+  */
+ static long
+ prune_cache_entries(void)
+ {
+ 	unsigned int i;
+ 	long freed = 0;
+ 	bool cancel = true;
+ 
+ 	for (i = 0; i < drc_hashsize; i++) {
+ 		struct nfsd_drc_bucket *b = &drc_hashtbl[i];
+ 
+ 		freed += prune_bucket(b);
+ 		if (!list_empty(&b->lru_head))
+ 			cancel = false;
+ 	}
  
  	/*
- 	 * Conditionally rearm the job. If we cleaned out the list, then
- 	 * cancel any pending run (since there won't be any work to do).
- 	 * Otherwise, we rearm the job or modify the existing one to run in
- 	 * RC_EXPIRE since we just ran the pruner.
+ 	 * Conditionally rearm the job to run in RC_EXPIRE since we just
+ 	 * ran the pruner.
  	 */
- 	if (list_empty(&lru_head))
- 		cancel_delayed_work(&cache_cleaner);
- 	else
+ 	if (!cancel)
  		mod_delayed_work(system_wq, &cache_cleaner, RC_EXPIRE);
 -	return freed;
  }
  
  static void
* Unmerged path fs/nfsd/nfscache.c
