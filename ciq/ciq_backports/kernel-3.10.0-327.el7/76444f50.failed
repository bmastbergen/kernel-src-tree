bonding: convert bond_main.c to use netdev_printk instead of pr_

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Veaceslav Falico <vfalico@gmail.com>
commit 76444f5052edf6683a735c3bc307e11c121654c5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/76444f50.failed

Converted only the parts where we've had a valid net_device, skipping the
init/deinit and options verification.

CC: Jay Vosburgh <j.vosburgh@gmail.com>
CC: Andy Gospodarek <andy@greyhouse.net>
	Signed-off-by: Veaceslav Falico <vfalico@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 76444f5052edf6683a735c3bc307e11c121654c5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
diff --cc drivers/net/bonding/bond_main.c
index aa34e1bea1e8,3b96867e99de..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -1001,10 -759,14 +1001,10 @@@ static struct slave *bond_find_best_sla
  
  static bool bond_should_notify_peers(struct bonding *bond)
  {
 -	struct slave *slave;
 -
 -	rcu_read_lock();
 -	slave = rcu_dereference(bond->curr_active_slave);
 -	rcu_read_unlock();
 +	struct slave *slave = bond->curr_active_slave;
  
- 	pr_debug("bond_should_notify_peers: bond %s slave %s\n",
- 		 bond->dev->name, slave ? slave->dev->name : "NULL");
+ 	netdev_dbg(bond->dev, "bond_should_notify_peers: slave %s\n",
+ 		   slave ? slave->dev->name : "NULL");
  
  	if (!slave || !bond->send_peer_notif ||
  	    test_bit(__LINK_STATE_LINKWATCH_PENDING, &slave->dev->state))
@@@ -1036,13 -802,13 +1036,20 @@@ void bond_change_active_slave(struct bo
  		return;
  
  	if (new_active) {
 -		new_active->last_link_up = jiffies;
 +		new_active->jiffies = jiffies;
  
  		if (new_active->link == BOND_LINK_BACK) {
++<<<<<<< HEAD
 +			if (USES_PRIMARY(bond->params.mode)) {
 +				pr_info("%s: making interface %s the new active one %d ms earlier.\n",
 +					bond->dev->name, new_active->dev->name,
 +					(bond->params.updelay - new_active->delay) * bond->params.miimon);
++=======
+ 			if (bond_uses_primary(bond)) {
+ 				netdev_info(bond->dev, "making interface %s the new active one %d ms earlier\n",
+ 					    new_active->dev->name,
+ 					    (bond->params.updelay - new_active->delay) * bond->params.miimon);
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  			}
  
  			new_active->delay = 0;
@@@ -1054,9 -820,9 +1061,15 @@@
  			if (bond_is_lb(bond))
  				bond_alb_handle_link_change(bond, new_active, BOND_LINK_UP);
  		} else {
++<<<<<<< HEAD
 +			if (USES_PRIMARY(bond->params.mode)) {
 +				pr_info("%s: making interface %s the new active one.\n",
 +					bond->dev->name, new_active->dev->name);
++=======
+ 			if (bond_uses_primary(bond)) {
+ 				netdev_info(bond->dev, "making interface %s the new active one\n",
+ 					    new_active->dev->name);
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  			}
  		}
  	}
@@@ -1141,11 -911,9 +1154,14 @@@ void bond_select_active_slave(struct bo
  			return;
  
  		if (netif_carrier_ok(bond->dev)) {
- 			pr_info("%s: first active interface up!\n",
- 				bond->dev->name);
+ 			netdev_info(bond->dev, "first active interface up!\n");
  		} else {
++<<<<<<< HEAD
 +			pr_info("%s: now running without any active interface !\n",
 +				bond->dev->name);
++=======
+ 			netdev_info(bond->dev, "now running without any active interface!\n");
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  		}
  	}
  }
@@@ -1466,13 -1210,13 +1482,22 @@@ int bond_enslave(struct net_device *bon
  	if (!bond->params.use_carrier &&
  	    slave_dev->ethtool_ops->get_link == NULL &&
  	    slave_ops->ndo_do_ioctl == NULL) {
++<<<<<<< HEAD
 +		pr_warning("%s: Warning: no link monitoring support for %s\n",
 +			   bond_dev->name, slave_dev->name);
++=======
+ 		netdev_warn(bond_dev, "no link monitoring support for %s\n",
+ 			    slave_dev->name);
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  	}
  
  	/* already enslaved */
  	if (slave_dev->flags & IFF_SLAVE) {
++<<<<<<< HEAD
 +		pr_debug("Error, Device was already enslaved\n");
++=======
+ 		netdev_dbg(bond_dev, "Error: Device was already enslaved\n");
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  		return -EBUSY;
  	}
  
@@@ -1484,18 -1228,20 +1509,26 @@@
  	/* vlan challenged mutual exclusion */
  	/* no need to lock since we're protected by rtnl_lock */
  	if (slave_dev->features & NETIF_F_VLAN_CHALLENGED) {
- 		pr_debug("%s: NETIF_F_VLAN_CHALLENGED\n", slave_dev->name);
+ 		netdev_dbg(bond_dev, "%s is NETIF_F_VLAN_CHALLENGED\n",
+ 			   slave_dev->name);
  		if (vlan_uses_dev(bond_dev)) {
- 			pr_err("%s: Error: cannot enslave VLAN challenged slave %s on VLAN enabled bond %s\n",
- 			       bond_dev->name, slave_dev->name, bond_dev->name);
+ 			netdev_err(bond_dev, "Error: cannot enslave VLAN challenged slave %s on VLAN enabled bond %s\n",
+ 				   slave_dev->name, bond_dev->name);
  			return -EPERM;
  		} else {
++<<<<<<< HEAD
 +			pr_warning("%s: Warning: enslaved VLAN challenged slave %s. Adding VLANs will be blocked as long as %s is part of bond %s\n",
 +				   bond_dev->name, slave_dev->name,
 +				   slave_dev->name, bond_dev->name);
++=======
+ 			netdev_warn(bond_dev, "enslaved VLAN challenged slave %s. Adding VLANs will be blocked as long as %s is part of bond %s\n",
+ 				    slave_dev->name, slave_dev->name,
+ 				    bond_dev->name);
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  		}
  	} else {
- 		pr_debug("%s: ! NETIF_F_VLAN_CHALLENGED\n", slave_dev->name);
+ 		netdev_dbg(bond_dev, "%s is !NETIF_F_VLAN_CHALLENGED\n",
+ 			   slave_dev->name);
  	}
  
  	/*
@@@ -1505,8 -1251,8 +1538,13 @@@
  	 * enslaving it; the old ifenslave will not.
  	 */
  	if ((slave_dev->flags & IFF_UP)) {
++<<<<<<< HEAD
 +		pr_err("%s is up. This may be due to an out of date ifenslave.\n",
 +		       slave_dev->name);
++=======
+ 		netdev_err(bond_dev, "%s is up - this may be due to an out of date ifenslave\n",
+ 			   slave_dev->name);
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  		res = -EPERM;
  		goto err_undo_flags;
  	}
@@@ -1518,11 -1264,10 +1556,10 @@@
  	 * bond ether type mutual exclusion - don't allow slaves of dissimilar
  	 * ether type (eg ARPHRD_ETHER and ARPHRD_INFINIBAND) share the same bond
  	 */
 -	if (!bond_has_slaves(bond)) {
 +	if (bond->slave_cnt == 0) {
  		if (bond_dev->type != slave_dev->type) {
- 			pr_debug("%s: change device type from %d to %d\n",
- 				 bond_dev->name,
- 				 bond_dev->type, slave_dev->type);
+ 			netdev_dbg(bond_dev, "change device type from %d to %d\n",
+ 				   bond_dev->type, slave_dev->type);
  
  			res = call_netdevice_notifiers(NETDEV_PRE_TYPE_CHANGE,
  						       bond_dev);
@@@ -1549,23 -1293,24 +1585,42 @@@
  						 bond_dev);
  		}
  	} else if (bond_dev->type != slave_dev->type) {
++<<<<<<< HEAD
 +		pr_err("%s ether type (%d) is different from other slaves (%d), can not enslave it.\n",
 +		       slave_dev->name,
 +		       slave_dev->type, bond_dev->type);
++=======
+ 		netdev_err(bond_dev, "%s ether type (%d) is different from other slaves (%d), can not enslave it\n",
+ 			   slave_dev->name, slave_dev->type, bond_dev->type);
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  		res = -EINVAL;
  		goto err_undo_flags;
  	}
  
  	if (slave_ops->ndo_set_mac_address == NULL) {
++<<<<<<< HEAD
 +		if (bond->slave_cnt == 0) {
 +			pr_warning("%s: Warning: The first slave device specified does not support setting the MAC address. Setting fail_over_mac to active.",
 +				   bond_dev->name);
 +			bond->params.fail_over_mac = BOND_FOM_ACTIVE;
 +		} else if (bond->params.fail_over_mac != BOND_FOM_ACTIVE) {
 +			pr_err("%s: Error: The slave device specified does not support setting the MAC address, but fail_over_mac is not set to active.\n",
 +			       bond_dev->name);
 +			res = -EOPNOTSUPP;
 +			goto err_undo_flags;
++=======
+ 		netdev_warn(bond_dev, "The slave device specified does not support setting the MAC address\n");
+ 		if (BOND_MODE(bond) == BOND_MODE_ACTIVEBACKUP &&
+ 		    bond->params.fail_over_mac != BOND_FOM_ACTIVE) {
+ 			if (!bond_has_slaves(bond)) {
+ 				bond->params.fail_over_mac = BOND_FOM_ACTIVE;
+ 				netdev_warn(bond_dev, "Setting fail_over_mac to active for active-backup mode\n");
+ 			} else {
+ 				netdev_err(bond_dev, "The slave device specified does not support setting the MAC address, but fail_over_mac is not set to active\n");
+ 				res = -EOPNOTSUPP;
+ 				goto err_undo_flags;
+ 			}
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  		}
  	}
  
@@@ -1671,11 -1417,14 +1726,20 @@@
  		dev_mc_add(slave_dev, lacpdu_multicast);
  	}
  
++<<<<<<< HEAD
 +	bond_add_vlans_on_slave(bond, slave_dev);
++=======
+ 	res = vlan_vids_add_by_dev(slave_dev, bond_dev);
+ 	if (res) {
+ 		netdev_err(bond_dev, "Couldn't add bond vlan ids to %s\n",
+ 			   slave_dev->name);
+ 		goto err_close;
+ 	}
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  
 -	prev_slave = bond_last_slave(bond);
 +	write_lock_bh(&bond->lock);
 +
 +	bond_attach_slave(bond, new_slave);
  
  	new_slave->delay = 0;
  	new_slave->link_failure_count = 0;
@@@ -1706,12 -1449,12 +1770,21 @@@
  			 * supported); thus, we don't need to change
  			 * the messages for netif_carrier.
  			 */
++<<<<<<< HEAD
 +			pr_warning("%s: Warning: MII and ETHTOOL support not available for interface %s, and arp_interval/arp_ip_target module parameters not specified, thus bonding will not detect link failures! see bonding.txt for details.\n",
 +			       bond_dev->name, slave_dev->name);
 +		} else if (link_reporting == -1) {
 +			/* unable get link status using mii/ethtool */
 +			pr_warning("%s: Warning: can't get link status from interface %s; the network driver associated with this interface does not support MII or ETHTOOL link status reporting, thus miimon has no effect on this interface.\n",
 +				   bond_dev->name, slave_dev->name);
++=======
+ 			netdev_warn(bond_dev, "MII and ETHTOOL support not available for interface %s, and arp_interval/arp_ip_target module parameters not specified, thus bonding will not detect link failures! see bonding.txt for details\n",
+ 				    slave_dev->name);
+ 		} else if (link_reporting == -1) {
+ 			/* unable get link status using mii/ethtool */
+ 			netdev_warn(bond_dev, "can't get link status from interface %s; the network driver associated with this interface does not support MII or ETHTOOL link status reporting, thus miimon has no effect on this interface\n",
+ 				    slave_dev->name);
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  		}
  	}
  
@@@ -1735,12 -1478,12 +1808,19 @@@
  	}
  
  	if (new_slave->link != BOND_LINK_DOWN)
++<<<<<<< HEAD
 +		new_slave->jiffies = jiffies;
 +	pr_debug("Initial state of slave_dev is BOND_LINK_%s\n",
 +		new_slave->link == BOND_LINK_DOWN ? "DOWN" :
 +			(new_slave->link == BOND_LINK_UP ? "UP" : "BACK"));
++=======
+ 		new_slave->last_link_up = jiffies;
+ 	netdev_dbg(bond_dev, "Initial state of slave_dev is BOND_LINK_%s\n",
+ 		   new_slave->link == BOND_LINK_DOWN ? "DOWN" :
+ 		   (new_slave->link == BOND_LINK_UP ? "UP" : "BACK"));
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  
 -	if (bond_uses_primary(bond) && bond->params.primary[0]) {
 +	if (USES_PRIMARY(bond->params.mode) && bond->params.primary[0]) {
  		/* if there is a primary slave, remember it */
  		if (strcmp(bond->params.primary, new_slave->dev->name) == 0) {
  			bond->primary_slave = new_slave;
@@@ -1778,11 -1519,10 +1858,11 @@@
  	case BOND_MODE_TLB:
  	case BOND_MODE_ALB:
  		bond_set_active_slave(new_slave);
 -		bond_set_slave_inactive_flags(new_slave, BOND_SLAVE_NOTIFY_NOW);
 +		bond_set_slave_inactive_flags(new_slave);
 +		bond_select_active_slave(bond);
  		break;
  	default:
- 		pr_debug("This slave is always active in trunk mode\n");
+ 		netdev_dbg(bond_dev, "This slave is always active in trunk mode\n");
  
  		/* always active in trunk mode */
  		bond_set_active_slave(new_slave);
@@@ -1805,9 -1542,7 +1885,13 @@@
  	slave_dev->npinfo = bond->dev->npinfo;
  	if (slave_dev->npinfo) {
  		if (slave_enable_netpoll(new_slave)) {
++<<<<<<< HEAD
 +			pr_info("Error, %s: master_dev is using netpoll, "
 +				 "but new slave device does not support netpoll.\n",
 +				 bond_dev->name);
++=======
+ 			netdev_info(bond_dev, "master_dev is using netpoll, but new slave device does not support netpoll\n");
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  			res = -EBUSY;
  			goto err_detach;
  		}
@@@ -1823,8 -1552,8 +1907,13 @@@
  	res = netdev_rx_handler_register(slave_dev, bond_handle_frame,
  					 new_slave);
  	if (res) {
++<<<<<<< HEAD
 +		pr_debug("Error %d calling netdev_rx_handler_register\n", res);
 +		goto err_dest_symlinks;
++=======
+ 		netdev_dbg(bond_dev, "Error %d calling netdev_rx_handler_register\n", res);
+ 		goto err_detach;
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  	}
  
  	res = bond_master_upper_dev_link(bond_dev, slave_dev, new_slave);
@@@ -1833,11 -1562,28 +1922,36 @@@
  		goto err_unregister;
  	}
  
++<<<<<<< HEAD
 +
 +	pr_info("%s: enslaving %s as a%s interface with a%s link.\n",
 +		bond_dev->name, slave_dev->name,
 +		bond_is_active_slave(new_slave) ? "n active" : " backup",
 +		new_slave->link != BOND_LINK_DOWN ? "n up" : " down");
++=======
+ 	res = bond_sysfs_slave_add(new_slave);
+ 	if (res) {
+ 		netdev_dbg(bond_dev, "Error %d calling bond_sysfs_slave_add\n", res);
+ 		goto err_upper_unlink;
+ 	}
+ 
+ 	bond->slave_cnt++;
+ 	bond_compute_features(bond);
+ 	bond_set_carrier(bond);
+ 
+ 	if (bond_uses_primary(bond)) {
+ 		block_netpoll_tx();
+ 		write_lock_bh(&bond->curr_slave_lock);
+ 		bond_select_active_slave(bond);
+ 		write_unlock_bh(&bond->curr_slave_lock);
+ 		unblock_netpoll_tx();
+ 	}
+ 
+ 	netdev_info(bond_dev, "Enslaving %s as %s interface with %s link\n",
+ 		    slave_dev->name,
+ 		    bond_is_active_slave(new_slave) ? "an active" : "a backup",
+ 		    new_slave->link != BOND_LINK_DOWN ? "an up" : "a down");
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  
  	/* enslave is successful */
  	return 0;
@@@ -1929,8 -1668,8 +2043,13 @@@ static int __bond_release_one(struct ne
  	/* slave is not a slave or master is not master of this slave */
  	if (!(slave_dev->flags & IFF_SLAVE) ||
  	    !netdev_has_upper_dev(slave_dev, bond_dev)) {
++<<<<<<< HEAD
 +		pr_err("%s: Error: cannot release %s.\n",
 +		       bond_dev->name, slave_dev->name);
++=======
+ 		netdev_err(bond_dev, "cannot release %s\n",
+ 			   slave_dev->name);
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  		return -EINVAL;
  	}
  
@@@ -1940,9 -1678,8 +2059,14 @@@
  	slave = bond_get_slave_by_dev(bond, slave_dev);
  	if (!slave) {
  		/* not a slave of this bond */
++<<<<<<< HEAD
 +		pr_info("%s: %s not enslaved\n",
 +			bond_dev->name, slave_dev->name);
 +		write_unlock_bh(&bond->lock);
++=======
+ 		netdev_info(bond_dev, "%s not enslaved\n",
+ 			    slave_dev->name);
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  		unblock_netpoll_tx();
  		return -EINVAL;
  	}
@@@ -1956,34 -1693,28 +2080,53 @@@
  	netdev_rx_handler_unregister(slave_dev);
  	write_lock_bh(&bond->lock);
  
 +	if (!all && !bond->params.fail_over_mac) {
 +		if (ether_addr_equal(bond_dev->dev_addr, slave->perm_hwaddr) &&
 +		    bond->slave_cnt > 1)
 +			pr_warning("%s: Warning: the permanent HWaddr of %s - %pM - is still in use by %s. Set the HWaddr of %s to a different address to avoid conflicts.\n",
 +				   bond_dev->name, slave_dev->name,
 +				   slave->perm_hwaddr,
 +				   bond_dev->name, slave_dev->name);
 +	}
 +
  	/* Inform AD package of unbinding of slave. */
 -	if (BOND_MODE(bond) == BOND_MODE_8023AD)
 +	if (bond->params.mode == BOND_MODE_8023AD) {
 +		/* must be called before the slave is
 +		 * detached from the list
 +		 */
  		bond_3ad_unbind_slave(slave);
 +	}
  
++<<<<<<< HEAD
 +	pr_info("%s: releasing %s interface %s\n",
 +		bond_dev->name,
 +		bond_is_active_slave(slave) ? "active" : "backup",
 +		slave_dev->name);
++=======
+ 	write_unlock_bh(&bond->lock);
+ 
+ 	netdev_info(bond_dev, "Releasing %s interface %s\n",
+ 		    bond_is_active_slave(slave) ? "active" : "backup",
+ 		    slave_dev->name);
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  
 -	oldcurrent = rcu_access_pointer(bond->curr_active_slave);
 +	oldcurrent = bond->curr_active_slave;
  
 -	RCU_INIT_POINTER(bond->current_arp_slave, NULL);
 +	bond->current_arp_slave = NULL;
  
++<<<<<<< HEAD
 +	/* release the slave from its bond */
 +	bond_detach_slave(bond, slave);
++=======
+ 	if (!all && (!bond->params.fail_over_mac ||
+ 		     BOND_MODE(bond) != BOND_MODE_ACTIVEBACKUP)) {
+ 		if (ether_addr_equal_64bits(bond_dev->dev_addr, slave->perm_hwaddr) &&
+ 		    bond_has_slaves(bond))
+ 			netdev_warn(bond_dev, "the permanent HWaddr of %s - %pM - is still in use by %s - set the HWaddr of %s to a different address to avoid conflicts\n",
+ 				    slave_dev->name, slave->perm_hwaddr,
+ 				    bond_dev->name, slave_dev->name);
+ 	}
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  
  	if (bond->primary_slave == slave)
  		bond->primary_slave = NULL;
@@@ -2037,19 -1766,16 +2180,24 @@@
  	bond_compute_features(bond);
  	if (!(bond_dev->features & NETIF_F_VLAN_CHALLENGED) &&
  	    (old_features & NETIF_F_VLAN_CHALLENGED))
++<<<<<<< HEAD
 +		pr_info("%s: last VLAN challenged slave %s left bond %s. VLAN blocking is removed\n",
 +			bond_dev->name, slave_dev->name, bond_dev->name);
++=======
+ 		netdev_info(bond_dev, "last VLAN challenged slave %s left bond %s - VLAN blocking is removed\n",
+ 			    slave_dev->name, bond_dev->name);
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  
  	/* must do this from outside any spinlocks */
 -	vlan_vids_del_by_dev(slave_dev, bond_dev);
 +	bond_destroy_slave_symlinks(bond_dev, slave_dev);
  
 -	/* If the mode uses primary, then this cases was handled above by
 -	 * bond_change_active_slave(..., NULL)
 +	bond_del_vlans_from_slave(bond, slave_dev);
 +
 +	/* If the mode USES_PRIMARY, then we should only remove its
 +	 * promisc and mc settings if it was the curr_active_slave, but that was
 +	 * already taken care of above when we detached the slave
  	 */
 -	if (!bond_uses_primary(bond)) {
 +	if (!USES_PRIMARY(bond->params.mode)) {
  		/* unset promiscuity level from slave
  		 * NOTE: The NETDEV_CHANGEADDR call above may change the value
  		 * of the IFF_PROMISC flag in the bond_dev, but we need the
@@@ -2108,10 -1832,10 +2256,15 @@@ static int  bond_release_and_destroy(st
  	int ret;
  
  	ret = bond_release(bond_dev, slave_dev);
 -	if (ret == 0 && !bond_has_slaves(bond)) {
 +	if ((ret == 0) && (bond->slave_cnt == 0)) {
  		bond_dev->priv_flags |= IFF_DISABLE_NETPOLL;
++<<<<<<< HEAD
 +		pr_info("%s: destroying bond %s.\n",
 +			bond_dev->name, bond_dev->name);
++=======
+ 		netdev_info(bond_dev, "Destroying bond %s\n",
+ 			    bond_dev->name);
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  		unregister_netdevice(bond_dev);
  	}
  	return ret;
@@@ -2179,14 -1899,13 +2332,24 @@@ static int bond_miimon_inspect(struct b
  			slave->link = BOND_LINK_FAIL;
  			slave->delay = bond->params.downdelay;
  			if (slave->delay) {
++<<<<<<< HEAD
 +				pr_info("%s: link status down for %sinterface %s, disabling it in %d ms.\n",
 +					bond->dev->name,
 +					(bond->params.mode ==
 +					 BOND_MODE_ACTIVEBACKUP) ?
 +					(bond_is_active_slave(slave) ?
 +					 "active " : "backup ") : "",
 +					slave->dev->name,
 +					bond->params.downdelay * bond->params.miimon);
++=======
+ 				netdev_info(bond->dev, "link status down for %sinterface %s, disabling it in %d ms\n",
+ 					    (BOND_MODE(bond) ==
+ 					     BOND_MODE_ACTIVEBACKUP) ?
+ 					     (bond_is_active_slave(slave) ?
+ 					      "active " : "backup ") : "",
+ 					    slave->dev->name,
+ 					    bond->params.downdelay * bond->params.miimon);
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  			}
  			/*FALLTHRU*/
  		case BOND_LINK_FAIL:
@@@ -2195,12 -1914,11 +2358,20 @@@
  				 * recovered before downdelay expired
  				 */
  				slave->link = BOND_LINK_UP;
++<<<<<<< HEAD
 +				slave->jiffies = jiffies;
 +				pr_info("%s: link status up again after %d ms for interface %s.\n",
 +					bond->dev->name,
 +					(bond->params.downdelay - slave->delay) *
 +					bond->params.miimon,
 +					slave->dev->name);
++=======
+ 				slave->last_link_up = jiffies;
+ 				netdev_info(bond->dev, "link status up again after %d ms for interface %s\n",
+ 					    (bond->params.downdelay - slave->delay) *
+ 					    bond->params.miimon,
+ 					    slave->dev->name);
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  				continue;
  			}
  
@@@ -2221,21 -1939,20 +2392,36 @@@
  			slave->delay = bond->params.updelay;
  
  			if (slave->delay) {
++<<<<<<< HEAD
 +				pr_info("%s: link status up for interface %s, enabling it in %d ms.\n",
 +					bond->dev->name, slave->dev->name,
 +					ignore_updelay ? 0 :
 +					bond->params.updelay *
 +					bond->params.miimon);
++=======
+ 				netdev_info(bond->dev, "link status up for interface %s, enabling it in %d ms\n",
+ 					    slave->dev->name,
+ 					    ignore_updelay ? 0 :
+ 					    bond->params.updelay *
+ 					    bond->params.miimon);
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  			}
  			/*FALLTHRU*/
  		case BOND_LINK_BACK:
  			if (!link_state) {
  				slave->link = BOND_LINK_DOWN;
++<<<<<<< HEAD
 +				pr_info("%s: link status down again after %d ms for interface %s.\n",
 +					bond->dev->name,
 +					(bond->params.updelay - slave->delay) *
 +					bond->params.miimon,
 +					slave->dev->name);
++=======
+ 				netdev_info(bond->dev, "link status down again after %d ms for interface %s\n",
+ 					    (bond->params.updelay - slave->delay) *
+ 					    bond->params.miimon,
+ 					    slave->dev->name);
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  
  				continue;
  			}
@@@ -2283,13 -2000,13 +2469,20 @@@ static void bond_miimon_commit(struct b
  				bond_set_backup_slave(slave);
  			}
  
++<<<<<<< HEAD
 +			pr_info("%s: link status definitely up for interface %s, %u Mbps %s duplex.\n",
 +				bond->dev->name, slave->dev->name,
 +				slave->speed == SPEED_UNKNOWN ? 0 : slave->speed,
 +				slave->duplex ? "full" : "half");
++=======
+ 			netdev_info(bond->dev, "link status definitely up for interface %s, %u Mbps %s duplex\n",
+ 				    slave->dev->name,
+ 				    slave->speed == SPEED_UNKNOWN ? 0 : slave->speed,
+ 				    slave->duplex ? "full" : "half");
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  
  			/* notify ad that the link status has changed */
 -			if (BOND_MODE(bond) == BOND_MODE_8023AD)
 +			if (bond->params.mode == BOND_MODE_8023AD)
  				bond_3ad_handle_link_change(slave, BOND_LINK_UP);
  
  			if (bond_is_lb(bond))
@@@ -2308,14 -2025,15 +2501,14 @@@
  
  			slave->link = BOND_LINK_DOWN;
  
 -			if (BOND_MODE(bond) == BOND_MODE_ACTIVEBACKUP ||
 -			    BOND_MODE(bond) == BOND_MODE_8023AD)
 -				bond_set_slave_inactive_flags(slave,
 -							      BOND_SLAVE_NOTIFY_NOW);
 +			if (bond->params.mode == BOND_MODE_ACTIVEBACKUP ||
 +			    bond->params.mode == BOND_MODE_8023AD)
 +				bond_set_slave_inactive_flags(slave);
  
- 			pr_info("%s: link status definitely down for interface %s, disabling it\n",
- 				bond->dev->name, slave->dev->name);
+ 			netdev_info(bond->dev, "link status definitely down for interface %s, disabling it\n",
+ 				    slave->dev->name);
  
 -			if (BOND_MODE(bond) == BOND_MODE_8023AD)
 +			if (bond->params.mode == BOND_MODE_8023AD)
  				bond_3ad_handle_link_change(slave,
  							    BOND_LINK_DOWN);
  
@@@ -2433,24 -2144,45 +2625,54 @@@ static bool bond_has_this_ip(struct bon
   * switches in VLAN mode (especially if ports are configured as
   * "native" to a VLAN) might not pass non-tagged frames.
   */
 -static void bond_arp_send(struct net_device *slave_dev, int arp_op,
 -			  __be32 dest_ip, __be32 src_ip,
 -			  struct bond_vlan_tag *tags)
 +static void bond_arp_send(struct net_device *slave_dev, int arp_op, __be32 dest_ip, __be32 src_ip, unsigned short vlan_id)
  {
  	struct sk_buff *skb;
 -	int i;
  
++<<<<<<< HEAD
 +	pr_debug("arp %d on slave %s: dst %pI4 src %pI4 vid %d\n", arp_op,
 +		 slave_dev->name, &dest_ip, &src_ip, vlan_id);
++=======
+ 	netdev_dbg(slave_dev, "arp %d on slave %s: dst %pI4 src %pI4\n",
+ 		   arp_op, slave_dev->name, &dest_ip, &src_ip);
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  
  	skb = arp_create(arp_op, ETH_P_ARP, dest_ip, slave_dev, src_ip,
  			 NULL, slave_dev->dev_addr, NULL);
  
  	if (!skb) {
 -		net_err_ratelimited("ARP packet allocation failed\n");
 +		pr_err("ARP packet allocation failed\n");
  		return;
  	}
++<<<<<<< HEAD
 +	if (vlan_id) {
 +		skb = vlan_put_tag(skb, htons(ETH_P_8021Q), vlan_id);
 +		if (!skb) {
 +			pr_err("failed to insert VLAN tag\n");
++=======
+ 
+ 	/* Go through all the tags backwards and add them to the packet */
+ 	for (i = BOND_MAX_VLAN_ENCAP - 1; i > 0; i--) {
+ 		if (!tags[i].vlan_id)
+ 			continue;
+ 
+ 		netdev_dbg(slave_dev, "inner tag: proto %X vid %X\n",
+ 			   ntohs(tags[i].vlan_proto), tags[i].vlan_id);
+ 		skb = __vlan_put_tag(skb, tags[i].vlan_proto,
+ 				     tags[i].vlan_id);
+ 		if (!skb) {
+ 			net_err_ratelimited("failed to insert inner VLAN tag\n");
+ 			return;
+ 		}
+ 	}
+ 	/* Set the outer tag */
+ 	if (tags[0].vlan_id) {
+ 		netdev_dbg(slave_dev, "outer tag: proto %X vid %X\n",
+ 			   ntohs(tags[0].vlan_proto), tags[0].vlan_id);
+ 		skb = vlan_put_tag(skb, tags[0].vlan_proto, tags[0].vlan_id);
+ 		if (!skb) {
+ 			net_err_ratelimited("failed to insert outer VLAN tag\n");
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  			return;
  		}
  	}
@@@ -2460,14 -2192,49 +2682,19 @@@
  
  static void bond_arp_send_all(struct bonding *bond, struct slave *slave)
  {
 +	struct net_device *upper, *vlan_upper;
 +	struct list_head *iter, *vlan_iter;
  	struct rtable *rt;
 -	struct bond_vlan_tag tags[BOND_MAX_VLAN_ENCAP];
  	__be32 *targets = bond->params.arp_targets, addr;
 -	int i;
 -	bool ret;
 +	int i, vlan_id;
  
  	for (i = 0; i < BOND_MAX_ARP_TARGETS && targets[i]; i++) {
++<<<<<<< HEAD
 +		pr_debug("basa: target %pI4\n", &targets[i]);
++=======
+ 		netdev_dbg(bond->dev, "basa: target %pI4\n", &targets[i]);
+ 		memset(tags, 0, sizeof(tags));
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  
  		/* Find out through which dev should the packet go */
  		rt = ip_route_output(dev_net(bond->dev), targets[i], 0,
@@@ -2490,45 -2257,15 +2717,44 @@@
  			goto found;
  
  		rcu_read_lock();
 -		ret = bond_verify_device_path(bond->dev, rt->dst.dev, tags);
 -		rcu_read_unlock();
 +		/* first we search only for vlan devices. for every vlan
 +		 * found we verify its upper dev list, searching for the
 +		 * rt->dst.dev. If found we save the tag of the vlan and
 +		 * proceed to send the packet.
 +		 *
 +		 * TODO: QinQ?
 +		 */
 +		netdev_for_each_upper_dev_rcu(bond->dev, vlan_upper, vlan_iter) {
 +			if (!is_vlan_dev(vlan_upper))
 +				continue;
 +			netdev_for_each_upper_dev_rcu(vlan_upper, upper, iter) {
 +				if (upper == rt->dst.dev) {
 +					vlan_id = vlan_dev_vlan_id(vlan_upper);
 +					rcu_read_unlock();
 +					goto found;
 +				}
 +			}
 +		}
  
 -		if (ret)
 -			goto found;
 +		/* if the device we're looking for is not on top of any of
 +		 * our upper vlans, then just search for any dev that
 +		 * matches, and in case it's a vlan - save the id
 +		 */
 +		netdev_for_each_upper_dev_rcu(bond->dev, upper, iter) {
 +			if (upper == rt->dst.dev) {
 +				/* if it's a vlan - get its VID */
 +				if (is_vlan_dev(upper))
 +					vlan_id = vlan_dev_vlan_id(upper);
 +
 +				rcu_read_unlock();
 +				goto found;
 +			}
 +		}
 +		rcu_read_unlock();
  
  		/* Not our device - skip */
- 		pr_debug("%s: no path to arp_ip_target %pI4 via rt.dev %s\n",
- 			 bond->dev->name, &targets[i],
- 			 rt->dst.dev ? rt->dst.dev->name : "NULL");
+ 		netdev_dbg(bond->dev, "no path to arp_ip_target %pI4 via rt.dev %s\n",
+ 			   &targets[i], rt->dst.dev ? rt->dst.dev->name : "NULL");
  
  		ip_rt_put(rt);
  		continue;
@@@ -2552,10 -2290,11 +2779,11 @@@ static void bond_validate_arp(struct bo
  
  	i = bond_get_targets_ip(bond->params.arp_targets, sip);
  	if (i == -1) {
- 		pr_debug("bva: sip %pI4 not found in targets\n", &sip);
+ 		netdev_dbg(bond->dev, "bva: sip %pI4 not found in targets\n",
+ 			   &sip);
  		return;
  	}
 -	slave->last_rx = jiffies;
 +	slave->last_arp_rx = jiffies;
  	slave->target_last_arp_rx[i] = jiffies;
  }
  
@@@ -2603,11 -2343,13 +2831,11 @@@ int bond_arp_rcv(const struct sk_buff *
  	arp_ptr += 4 + bond->dev->addr_len;
  	memcpy(&tip, arp_ptr, 4);
  
- 	pr_debug("bond_arp_rcv: %s %s/%d av %d sv %d sip %pI4 tip %pI4\n",
- 		 bond->dev->name, slave->dev->name, bond_slave_state(slave),
- 		 bond->params.arp_validate, slave_do_arp_validate(bond, slave),
- 		 &sip, &tip);
+ 	netdev_dbg(bond->dev, "bond_arp_rcv: %s/%d av %d sv %d sip %pI4 tip %pI4\n",
+ 		   slave->dev->name, bond_slave_state(slave),
+ 		     bond->params.arp_validate, slave_do_arp_validate(bond, slave),
+ 		     &sip, &tip);
  
 -	curr_active_slave = rcu_dereference(bond->curr_active_slave);
 -
  	/*
  	 * Backup slaves won't see the ARP reply, but do come through
  	 * here for each ARP probe (so we swap the sip/tip to validate
@@@ -2687,14 -2436,12 +2915,18 @@@ void bond_loadbalance_arp_mon(struct wo
  				 * is closed.
  				 */
  				if (!oldcurrent) {
++<<<<<<< HEAD
 +					pr_info("%s: link status definitely up for interface %s, ",
 +						bond->dev->name,
 +						slave->dev->name);
++=======
+ 					netdev_info(bond->dev, "link status definitely up for interface %s\n",
+ 						    slave->dev->name);
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  					do_failover = 1;
  				} else {
- 					pr_info("%s: interface %s is now up\n",
- 						bond->dev->name,
- 						slave->dev->name);
+ 					netdev_info(bond->dev, "interface %s is now up\n",
+ 						    slave->dev->name);
  				}
  			}
  		} else {
@@@ -2717,9 -2460,8 +2949,14 @@@
  				if (slave->link_failure_count < UINT_MAX)
  					slave->link_failure_count++;
  
++<<<<<<< HEAD
 +				pr_info("%s: interface %s is now down.\n",
 +					bond->dev->name,
 +					slave->dev->name);
++=======
+ 				netdev_info(bond->dev, "interface %s is now down\n",
+ 					    slave->dev->name);
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  
  				if (slave == oldcurrent)
  					do_failover = 1;
@@@ -2866,22 -2600,24 +3103,27 @@@ static void bond_ab_arp_commit(struct b
  
  		case BOND_LINK_UP:
  			trans_start = dev_trans_start(slave->dev);
 -			if (rtnl_dereference(bond->curr_active_slave) != slave ||
 -			    (!rtnl_dereference(bond->curr_active_slave) &&
 -			     bond_time_in_interval(bond, trans_start, 1))) {
 -				struct slave *current_arp_slave;
 -
 -				current_arp_slave = rtnl_dereference(bond->current_arp_slave);
 +			if ((!bond->curr_active_slave &&
 +			     time_in_range(jiffies,
 +					   trans_start - delta_in_ticks,
 +					   trans_start + delta_in_ticks + delta_in_ticks / 2)) ||
 +			    bond->curr_active_slave != slave) {
  				slave->link = BOND_LINK_UP;
 -				if (current_arp_slave) {
 +				if (bond->current_arp_slave) {
  					bond_set_slave_inactive_flags(
 -						current_arp_slave,
 -						BOND_SLAVE_NOTIFY_NOW);
 -					RCU_INIT_POINTER(bond->current_arp_slave, NULL);
 +						bond->current_arp_slave);
 +					bond->current_arp_slave = NULL;
  				}
  
++<<<<<<< HEAD
 +				pr_info("%s: link status definitely up for interface %s.\n",
 +					bond->dev->name, slave->dev->name);
++=======
+ 				netdev_info(bond->dev, "link status definitely up for interface %s\n",
+ 					    slave->dev->name);
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  
 -				if (!rtnl_dereference(bond->curr_active_slave) ||
 +				if (!bond->curr_active_slave ||
  				    (slave == bond->primary_slave))
  					goto do_failover;
  
@@@ -2894,13 -2630,14 +3136,13 @@@
  				slave->link_failure_count++;
  
  			slave->link = BOND_LINK_DOWN;
 -			bond_set_slave_inactive_flags(slave,
 -						      BOND_SLAVE_NOTIFY_NOW);
 +			bond_set_slave_inactive_flags(slave);
  
- 			pr_info("%s: link status definitely down for interface %s, disabling it\n",
- 				bond->dev->name, slave->dev->name);
+ 			netdev_info(bond->dev, "link status definitely down for interface %s, disabling it\n",
+ 				    slave->dev->name);
  
 -			if (slave == rtnl_dereference(bond->curr_active_slave)) {
 -				RCU_INIT_POINTER(bond->current_arp_slave, NULL);
 +			if (slave == bond->curr_active_slave) {
 +				bond->current_arp_slave = NULL;
  				goto do_failover;
  			}
  
@@@ -2928,28 -2664,27 +3169,35 @@@ do_failover
  /*
   * Send ARP probes for active-backup mode ARP monitor.
   *
 - * Called with rcu_read_lock hold.
 + * Called with bond->lock held for read.
   */
 -static bool bond_ab_arp_probe(struct bonding *bond)
 +static void bond_ab_arp_probe(struct bonding *bond)
  {
 -	struct slave *slave, *before = NULL, *new_slave = NULL,
 -		     *curr_arp_slave = rcu_dereference(bond->current_arp_slave),
 -		     *curr_active_slave = rcu_dereference(bond->curr_active_slave);
 -	struct list_head *iter;
 -	bool found = false;
 -	bool should_notify_rtnl = BOND_SLAVE_NOTIFY_LATER;
 +	struct slave *slave;
 +	int i;
 +
++<<<<<<< HEAD
 +	read_lock(&bond->curr_slave_lock);
  
 +	if (bond->current_arp_slave && bond->curr_active_slave)
 +		pr_info("PROBE: c_arp %s && cas %s BAD\n",
 +			bond->current_arp_slave->dev->name,
 +			bond->curr_active_slave->dev->name);
++=======
+ 	if (curr_arp_slave && curr_active_slave)
+ 		netdev_info(bond->dev, "PROBE: c_arp %s && cas %s BAD\n",
+ 			    curr_arp_slave->dev->name,
+ 			    curr_active_slave->dev->name);
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  
 -	if (curr_active_slave) {
 -		bond_arp_send_all(bond, curr_active_slave);
 -		return should_notify_rtnl;
 +	if (bond->curr_active_slave) {
 +		bond_arp_send_all(bond, bond->curr_active_slave);
 +		read_unlock(&bond->curr_slave_lock);
 +		return;
  	}
  
 +	read_unlock(&bond->curr_slave_lock);
 +
  	/* if we don't have a curr_active_slave, search for the next available
  	 * backup slave from the current_arp_slave and make it the candidate
  	 * for becoming the curr_active_slave
@@@ -2986,15 -2716,39 +3234,20 @@@
  			if (slave->link_failure_count < UINT_MAX)
  				slave->link_failure_count++;
  
 -			bond_set_slave_inactive_flags(slave,
 -						      BOND_SLAVE_NOTIFY_LATER);
 +			bond_set_slave_inactive_flags(slave);
  
++<<<<<<< HEAD
 +			pr_info("%s: backup interface %s is now down.\n",
 +				bond->dev->name, slave->dev->name);
++=======
+ 			netdev_info(bond->dev, "backup interface %s is now down\n",
+ 				    slave->dev->name);
 -		}
 -		if (slave == curr_arp_slave)
 -			found = true;
 -	}
 -
 -	if (!new_slave && before)
 -		new_slave = before;
 -
 -	if (!new_slave)
 -		goto check_state;
 -
 -	new_slave->link = BOND_LINK_BACK;
 -	bond_set_slave_active_flags(new_slave, BOND_SLAVE_NOTIFY_LATER);
 -	bond_arp_send_all(bond, new_slave);
 -	new_slave->last_link_up = jiffies;
 -	rcu_assign_pointer(bond->current_arp_slave, new_slave);
 -
 -check_state:
 -	bond_for_each_slave_rcu(bond, slave, iter) {
 -		if (slave->should_notify) {
 -			should_notify_rtnl = BOND_SLAVE_NOTIFY_NOW;
 -			break;
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  		}
  	}
 -	return should_notify_rtnl;
  }
  
 -static void bond_activebackup_arp_mon(struct work_struct *work)
 +void bond_activebackup_arp_mon(struct work_struct *work)
  {
  	struct bonding *bond = container_of(work, struct bonding,
  					    arp_work.work);
@@@ -3160,9 -2916,10 +3413,16 @@@ static int bond_slave_netdev_event(unsi
  			break;
  		}
  
++<<<<<<< HEAD
 +		pr_info("%s: Primary slave changed to %s, reselecting active slave.\n",
 +			bond->dev->name, bond->primary_slave ? slave_dev->name :
 +							       "none");
++=======
+ 		netdev_info(bond->dev, "Primary slave changed to %s, reselecting active slave\n",
+ 			    bond->primary_slave ? slave_dev->name : "none");
+ 
+ 		block_netpoll_tx();
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  		write_lock_bh(&bond->curr_slave_lock);
  		bond_select_active_slave(bond);
  		write_unlock_bh(&bond->curr_slave_lock);
@@@ -3192,11 -2950,9 +3452,15 @@@
  static int bond_netdev_event(struct notifier_block *this,
  			     unsigned long event, void *ptr)
  {
 -	struct net_device *event_dev = netdev_notifier_info_to_dev(ptr);
 +	struct net_device *event_dev = (struct net_device *)ptr;
  
++<<<<<<< HEAD
 +	pr_debug("event_dev: %s, event: %lx\n",
 +		 event_dev ? event_dev->name : "None",
 +		 event);
++=======
+ 	netdev_dbg(event_dev, "event: %lx\n", event);
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  
  	if (!(event_dev->priv_flags & IFF_BONDING))
  		return NOTIFY_DONE;
@@@ -3684,12 -3403,11 +3948,16 @@@ static int bond_neigh_setup(struct net_
  static int bond_change_mtu(struct net_device *bond_dev, int new_mtu)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
 -	struct slave *slave, *rollback_slave;
 -	struct list_head *iter;
 +	struct slave *slave, *stop_at;
  	int res = 0;
 +	int i;
  
++<<<<<<< HEAD
 +	pr_debug("bond=%p, name=%s, new_mtu=%d\n", bond,
 +		 (bond_dev ? bond_dev->name : "None"), new_mtu);
++=======
+ 	netdev_dbg(bond_dev, "bond=%p, new_mtu=%d\n", bond, new_mtu);
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  
  	/* Can't hold bond->lock with bh disabled here since
  	 * some base drivers panic. On the other hand we can't
@@@ -3706,11 -3424,9 +3974,17 @@@
  	 * call to the base driver.
  	 */
  
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
 +		pr_debug("s %p s->p %p c_m %p\n",
 +			 slave,
 +			 slave->prev,
 +			 slave->dev->netdev_ops->ndo_change_mtu);
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
+ 		netdev_dbg(bond_dev, "s %p c_m %p\n",
+ 			   slave, slave->dev->netdev_ops->ndo_change_mtu);
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  
  		res = dev_set_mtu(slave->dev, new_mtu);
  
@@@ -3734,14 -3451,16 +4009,19 @@@
  
  unwind:
  	/* unwind from head to the slave that failed */
 -	bond_for_each_slave(bond, rollback_slave, iter) {
 +	stop_at = slave;
 +	bond_for_each_slave_from_to(bond, slave, i, bond->first_slave, stop_at) {
  		int tmp_res;
  
 -		if (rollback_slave == slave)
 -			break;
 -
 -		tmp_res = dev_set_mtu(rollback_slave->dev, bond_dev->mtu);
 +		tmp_res = dev_set_mtu(slave->dev, bond_dev->mtu);
  		if (tmp_res) {
++<<<<<<< HEAD
 +			pr_debug("unwind err %d dev %s\n",
 +				 tmp_res, slave->dev->name);
++=======
+ 			netdev_dbg(bond_dev, "unwind err %d dev %s\n",
+ 				   tmp_res, rollback_slave->dev->name);
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  		}
  	}
  
@@@ -3795,16 -3513,8 +4074,21 @@@ static int bond_set_mac_address(struct 
  	 * call to the base driver.
  	 */
  
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
 +		const struct net_device_ops *slave_ops = slave->dev->netdev_ops;
 +		pr_debug("slave %p %s\n", slave, slave->dev->name);
 +
 +		if (slave_ops->ndo_set_mac_address == NULL) {
 +			res = -EOPNOTSUPP;
 +			pr_debug("EOPNOTSUPP %s\n", slave->dev->name);
 +			goto unwind;
 +		}
 +
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
+ 		netdev_dbg(bond_dev, "slave %p %s\n", slave, slave->dev->name);
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  		res = dev_set_mac_address(slave->dev, addr);
  		if (res) {
  			/* TODO: consider downing the slave
@@@ -3827,14 -3537,16 +4111,19 @@@ unwind
  	tmp_sa.sa_family = bond_dev->type;
  
  	/* unwind from head to the slave that failed */
 -	bond_for_each_slave(bond, rollback_slave, iter) {
 +	stop_at = slave;
 +	bond_for_each_slave_from_to(bond, slave, i, bond->first_slave, stop_at) {
  		int tmp_res;
  
 -		if (rollback_slave == slave)
 -			break;
 -
 -		tmp_res = dev_set_mac_address(rollback_slave->dev, &tmp_sa);
 +		tmp_res = dev_set_mac_address(slave->dev, &tmp_sa);
  		if (tmp_res) {
++<<<<<<< HEAD
 +			pr_debug("unwind err %d dev %s\n",
 +				 tmp_res, slave->dev->name);
++=======
+ 			netdev_dbg(bond_dev, "unwind err %d dev %s\n",
+ 				   tmp_res, rollback_slave->dev->name);
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  		}
  	}
  
@@@ -4078,14 -3788,14 +4367,18 @@@ static netdev_tx_t __bond_start_xmit(st
  	case BOND_MODE_8023AD:
  		return bond_3ad_xmit_xor(skb, dev);
  	case BOND_MODE_ALB:
 -		return bond_alb_xmit(skb, dev);
  	case BOND_MODE_TLB:
 -		return bond_tlb_xmit(skb, dev);
 +		return bond_alb_xmit(skb, dev);
  	default:
  		/* Should never happen, mode already checked */
++<<<<<<< HEAD
 +		pr_err("%s: Error: Unknown bonding mode %d\n",
 +		       dev->name, bond->params.mode);
++=======
+ 		netdev_err(dev, "Unknown bonding mode %d\n", BOND_MODE(bond));
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  		WARN_ON_ONCE(1);
 -		dev_kfree_skb_any(skb);
 +		kfree_skb(skb);
  		return NETDEV_TX_OK;
  	}
  }
@@@ -4295,9 -3971,9 +4588,15 @@@ static void bond_uninit(struct net_devi
  	bond_netpoll_cleanup(bond_dev);
  
  	/* Release the bonded slaves */
++<<<<<<< HEAD
 +	while (bond->first_slave != NULL)
 +		__bond_release_one(bond_dev, bond->first_slave->dev, true);
 +	pr_info("%s: released all slaves\n", bond_dev->name);
++=======
+ 	bond_for_each_slave(bond, slave, iter)
+ 		__bond_release_one(bond_dev, slave->dev, true);
+ 	netdev_info(bond_dev, "Released all slaves\n");
++>>>>>>> 76444f5052ed (bonding: convert bond_main.c to use netdev_printk instead of pr_)
  
  	list_del(&bond->bond_list);
  
* Unmerged path drivers/net/bonding/bond_main.c
