hpsa: Use local workqueues instead of system workqueues

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Don Brace <don.brace@pmcs.com>
commit 6636e7f455b33b957c5ee016daa6de46148026ab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/6636e7f4.failed

	Suggested-by: Tomas Henzl <thenzl@redhat.com>
	Reviewed-by: Webb Scales <webbnh@hp.com>
	Reviewed-by: Kevin Barnett <Kevin.Barnett@pmcs.com>
	Signed-off-by: Don Brace <don.brace@pmcs.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 6636e7f455b33b957c5ee016daa6de46148026ab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/hpsa.c
#	drivers/scsi/hpsa.h
diff --cc drivers/scsi/hpsa.c
index e7cbec068bde,95d581c45413..000000000000
--- a/drivers/scsi/hpsa.c
+++ b/drivers/scsi/hpsa.c
@@@ -6714,8 -6881,20 +6741,23 @@@ reinit_after_soft_reset
  	spin_lock_init(&h->lock);
  	spin_lock_init(&h->offline_device_lock);
  	spin_lock_init(&h->scan_lock);
 -	atomic_set(&h->passthru_cmds_avail, HPSA_MAX_CONCURRENT_PASSTHRUS);
 +	spin_lock_init(&h->passthru_count_lock);
  
++<<<<<<< HEAD
++=======
+ 	h->rescan_ctlr_wq = hpsa_create_controller_wq(h, "rescan");
+ 	if (!h->rescan_ctlr_wq) {
+ 		rc = -ENOMEM;
+ 		goto clean1;
+ 	}
+ 
+ 	h->resubmit_wq = hpsa_create_controller_wq(h, "resubmit");
+ 	if (!h->resubmit_wq) {
+ 		rc = -ENOMEM;
+ 		goto clean1;
+ 	}
+ 
++>>>>>>> 6636e7f455b3 (hpsa: Use local workqueues instead of system workqueues)
  	/* Allocate and clear per-cpu variable lockup_detected */
  	h->lockup_detected = alloc_percpu(u32);
  	if (!h->lockup_detected) {
@@@ -6848,6 -7030,10 +6893,13 @@@ clean2_and_free_irqs
  	hpsa_free_irqs(h);
  clean2:
  clean1:
++<<<<<<< HEAD
++=======
+ 	if (h->resubmit_wq)
+ 		destroy_workqueue(h->resubmit_wq);
+ 	if (h->rescan_ctlr_wq)
+ 		destroy_workqueue(h->rescan_ctlr_wq);
++>>>>>>> 6636e7f455b3 (hpsa: Use local workqueues instead of system workqueues)
  	if (h->lockup_detected)
  		free_percpu(h->lockup_detected);
  	kfree(h);
@@@ -6921,9 -7107,11 +6973,15 @@@ static void hpsa_remove_one(struct pci_
  	/* Get rid of any controller monitoring work items */
  	spin_lock_irqsave(&h->lock, flags);
  	h->remove_in_progress = 1;
- 	cancel_delayed_work(&h->monitor_ctlr_work);
  	spin_unlock_irqrestore(&h->lock, flags);
- 
++<<<<<<< HEAD
++
++=======
+ 	cancel_delayed_work_sync(&h->monitor_ctlr_work);
+ 	cancel_delayed_work_sync(&h->rescan_ctlr_work);
+ 	destroy_workqueue(h->rescan_ctlr_wq);
+ 	destroy_workqueue(h->resubmit_wq);
++>>>>>>> 6636e7f455b3 (hpsa: Use local workqueues instead of system workqueues)
  	hpsa_unregister_scsi(h);	/* unhook from SCSI subsystem */
  	hpsa_shutdown(pdev);
  	iounmap(h->vaddr);
diff --cc drivers/scsi/hpsa.h
index bb1c5c5da1f2,657713050349..000000000000
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@@ -236,6 -251,8 +237,11 @@@ struct ctlr_info 
  	struct list_head offline_device_list;
  	int	acciopath_status;
  	int	raid_offload_debug;
++<<<<<<< HEAD
++=======
+ 	struct workqueue_struct *resubmit_wq;
+ 	struct workqueue_struct *rescan_ctlr_wq;
++>>>>>>> 6636e7f455b3 (hpsa: Use local workqueues instead of system workqueues)
  };
  
  struct offline_device_entry {
* Unmerged path drivers/scsi/hpsa.c
* Unmerged path drivers/scsi/hpsa.h
