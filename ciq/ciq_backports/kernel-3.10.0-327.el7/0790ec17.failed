KVM: nVMX: mask unrestricted_guest if disabled on L0

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [kvm] nvmx: mask unrestricted_guest if disabled on L0 (Bandan Das) [1209995]
Rebuild_FUZZ: 94.95%
commit-author Radim Krčmář <rkrcmar@redhat.com>
commit 0790ec172de1bd2e23f1dbd4925426b6cc3c1b72
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/0790ec17.failed

If EPT was enabled, unrestricted_guest was allowed in L1 regardless of
L0.  L1 triple faulted when running L2 guest that required emulation.

Another side effect was 'WARN_ON_ONCE(vmx->nested.nested_run_pending)'
in L0's dmesg:
  WARNING: CPU: 0 PID: 0 at arch/x86/kvm/vmx.c:9190 nested_vmx_vmexit+0x96e/0xb00 [kvm_intel] ()

Prevent this scenario by masking SECONDARY_EXEC_UNRESTRICTED_GUEST when
the host doesn't have it enabled.

Fixes: 78051e3b7e35 ("KVM: nVMX: Disable unrestricted mode if ept=0")
	Cc: stable@vger.kernel.org
Tested-By: Kashyap Chamarthy <kchamart@redhat.com>
	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
	Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
(cherry picked from commit 0790ec172de1bd2e23f1dbd4925426b6cc3c1b72)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index a4fa771e3adf,ae4f6d35d19c..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -2386,26 -2478,34 +2386,36 @@@ static __init void nested_vmx_setup_ctl
  
  	if (enable_ept) {
  		/* nested EPT: emulate EPT also to L1 */
++<<<<<<< HEAD
 +		nested_vmx_secondary_ctls_high |= SECONDARY_EXEC_ENABLE_EPT;
 +		nested_vmx_ept_caps = VMX_EPT_PAGE_WALK_4_BIT |
++=======
+ 		vmx->nested.nested_vmx_secondary_ctls_high |=
+ 			SECONDARY_EXEC_ENABLE_EPT;
+ 		vmx->nested.nested_vmx_ept_caps = VMX_EPT_PAGE_WALK_4_BIT |
++>>>>>>> 0790ec172de1 (KVM: nVMX: mask unrestricted_guest if disabled on L0)
  			 VMX_EPTP_WB_BIT | VMX_EPT_2MB_PAGE_BIT |
  			 VMX_EPT_INVEPT_BIT;
 -		vmx->nested.nested_vmx_ept_caps &= vmx_capability.ept;
 +		nested_vmx_ept_caps &= vmx_capability.ept;
  		/*
  		 * For nested guests, we don't do anything specific
  		 * for single context invalidation. Hence, only advertise
  		 * support for global context invalidation.
  		 */
 -		vmx->nested.nested_vmx_ept_caps |= VMX_EPT_EXTENT_GLOBAL_BIT;
 +		nested_vmx_ept_caps |= VMX_EPT_EXTENT_GLOBAL_BIT;
  	} else
 -		vmx->nested.nested_vmx_ept_caps = 0;
 +		nested_vmx_ept_caps = 0;
  
+ 	if (enable_unrestricted_guest)
+ 		vmx->nested.nested_vmx_secondary_ctls_high |=
+ 			SECONDARY_EXEC_UNRESTRICTED_GUEST;
+ 
  	/* miscellaneous data */
 -	rdmsr(MSR_IA32_VMX_MISC,
 -		vmx->nested.nested_vmx_misc_low,
 -		vmx->nested.nested_vmx_misc_high);
 -	vmx->nested.nested_vmx_misc_low &= VMX_MISC_SAVE_EFER_LMA;
 -	vmx->nested.nested_vmx_misc_low |=
 -		VMX_MISC_EMULATED_PREEMPTION_TIMER_RATE |
 +	rdmsr(MSR_IA32_VMX_MISC, nested_vmx_misc_low, nested_vmx_misc_high);
 +	nested_vmx_misc_low &= VMX_MISC_SAVE_EFER_LMA;
 +	nested_vmx_misc_low |= VMX_MISC_EMULATED_PREEMPTION_TIMER_RATE |
  		VMX_MISC_ACTIVITY_HLT;
 -	vmx->nested.nested_vmx_misc_high = 0;
 +	nested_vmx_misc_high = 0;
  }
  
  static inline bool vmx_control_verify(u32 control, u32 low, u32 high)
* Unmerged path arch/x86/kvm/vmx.c
