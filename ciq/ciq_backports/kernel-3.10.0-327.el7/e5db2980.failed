dm io: deal with wandering queue limits when handling REQ_DISCARD and REQ_WRITE_SAME

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [md] dm-io: deal with wandering queue limits when handling REQ_DISCARD and REQ_WRITE_SAME (Mike Snitzer) [1205955]
Rebuild_FUZZ: 98.81%
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit e5db29806b99ce2b2640d2e4d4fcb983cea115c5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/e5db2980.failed

Since it's possible for the discard and write same queue limits to
change while the upper level command is being sliced and diced, fix up
both of them (a) to reject IO if the special command is unsupported at
the start of the function and (b) read the limits once and let the
commands error out on their own if the status happens to change.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Mikulas Patocka <mpatocka@redhat.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
	Cc: stable@vger.kernel.org
(cherry picked from commit e5db29806b99ce2b2640d2e4d4fcb983cea115c5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-io.c
diff --cc drivers/md/dm-io.c
index c65cf58fa727,74adcd2c967e..000000000000
--- a/drivers/md/dm-io.c
+++ b/drivers/md/dm-io.c
@@@ -315,8 -324,8 +322,13 @@@ static void do_region(int rw, unsigned 
  		store_io_and_region_in_bio(bio, io, region);
  
  		if (rw & REQ_DISCARD) {
++<<<<<<< HEAD
 +			num_sectors = min_t(sector_t, q->limits.max_discard_sectors, remaining);
 +			bio->bi_size = num_sectors << SECTOR_SHIFT;
++=======
+ 			num_sectors = min_t(sector_t, special_cmd_max_sectors, remaining);
+ 			bio->bi_iter.bi_size = num_sectors << SECTOR_SHIFT;
++>>>>>>> e5db29806b99 (dm io: deal with wandering queue limits when handling REQ_DISCARD and REQ_WRITE_SAME)
  			remaining -= num_sectors;
  		} else if (rw & REQ_WRITE_SAME) {
  			/*
@@@ -324,8 -333,8 +336,13 @@@
  			 */
  			dp->get_page(dp, &page, &len, &offset);
  			bio_add_page(bio, page, logical_block_size, offset);
++<<<<<<< HEAD
 +			num_sectors = min_t(sector_t, q->limits.max_write_same_sectors, remaining);
 +			bio->bi_size = num_sectors << SECTOR_SHIFT;
++=======
+ 			num_sectors = min_t(sector_t, special_cmd_max_sectors, remaining);
+ 			bio->bi_iter.bi_size = num_sectors << SECTOR_SHIFT;
++>>>>>>> e5db29806b99 (dm io: deal with wandering queue limits when handling REQ_DISCARD and REQ_WRITE_SAME)
  
  			offset = 0;
  			remaining -= num_sectors;
* Unmerged path drivers/md/dm-io.c
