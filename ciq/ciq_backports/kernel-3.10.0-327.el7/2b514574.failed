net: af_unix: implement splice for stream af_unix sockets

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] af_unix: implement splice for stream af_unix sockets (Hannes Frederic Sowa) [1226230]
Rebuild_FUZZ: 95.41%
commit-author Hannes Frederic Sowa <hannes@stressinduktion.org>
commit 2b514574f7e88c8498027ee366fd6e7aae5aa4b5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/2b514574.failed

unix_stream_recvmsg is refactored to unix_stream_read_generic in this
patch and enhanced to deal with pipe splicing. The refactoring is
inneglible, we mostly have to deal with a non-existing struct msghdr
argument.

	Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2b514574f7e88c8498027ee366fd6e7aae5aa4b5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/unix/af_unix.c
diff --cc net/unix/af_unix.c
index 1c6b80b0a837,b8c44076c776..000000000000
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@@ -514,20 -516,20 +514,32 @@@ static unsigned int unix_dgram_poll(str
  				    poll_table *);
  static int unix_ioctl(struct socket *, unsigned int, unsigned long);
  static int unix_shutdown(struct socket *, int);
++<<<<<<< HEAD
 +static int unix_stream_sendmsg(struct kiocb *, struct socket *,
 +			       struct msghdr *, size_t);
 +static int unix_stream_recvmsg(struct kiocb *, struct socket *,
 +			       struct msghdr *, size_t, int);
 +static int unix_dgram_sendmsg(struct kiocb *, struct socket *,
 +			      struct msghdr *, size_t);
 +static int unix_dgram_recvmsg(struct kiocb *, struct socket *,
 +			      struct msghdr *, size_t, int);
++=======
+ static int unix_stream_sendmsg(struct socket *, struct msghdr *, size_t);
+ static int unix_stream_recvmsg(struct socket *, struct msghdr *, size_t, int);
+ static ssize_t unix_stream_sendpage(struct socket *, struct page *, int offset,
+ 				    size_t size, int flags);
+ static ssize_t unix_stream_splice_read(struct socket *,  loff_t *ppos,
+ 				       struct pipe_inode_info *, size_t size,
+ 				       unsigned int flags);
+ static int unix_dgram_sendmsg(struct socket *, struct msghdr *, size_t);
+ static int unix_dgram_recvmsg(struct socket *, struct msghdr *, size_t, int);
++>>>>>>> 2b514574f7e8 (net: af_unix: implement splice for stream af_unix sockets)
  static int unix_dgram_connect(struct socket *, struct sockaddr *,
  			      int, int);
 -static int unix_seqpacket_sendmsg(struct socket *, struct msghdr *, size_t);
 -static int unix_seqpacket_recvmsg(struct socket *, struct msghdr *, size_t,
 -				  int);
 +static int unix_seqpacket_sendmsg(struct kiocb *, struct socket *,
 +				  struct msghdr *, size_t);
 +static int unix_seqpacket_recvmsg(struct kiocb *, struct socket *,
 +				  struct msghdr *, size_t, int);
  
  static int unix_set_peek_off(struct sock *sk, int val)
  {
@@@ -561,7 -563,8 +573,12 @@@ static const struct proto_ops unix_stre
  	.sendmsg =	unix_stream_sendmsg,
  	.recvmsg =	unix_stream_recvmsg,
  	.mmap =		sock_no_mmap,
++<<<<<<< HEAD
 +	.sendpage =	sock_no_sendpage,
++=======
+ 	.sendpage =	unix_stream_sendpage,
+ 	.splice_read =	unix_stream_splice_read,
++>>>>>>> 2b514574f7e8 (net: af_unix: implement splice for stream af_unix sockets)
  	.set_peek_off =	unix_set_peek_off,
  };
  
@@@ -1910,18 -1997,27 +1930,39 @@@ static unsigned int unix_skb_len(const 
  	return skb->len - UNIXCB(skb).consumed;
  }
  
++<<<<<<< HEAD
 +static int unix_stream_recvmsg(struct kiocb *iocb, struct socket *sock,
 +			       struct msghdr *msg, size_t size,
 +			       int flags)
 +{
 +	struct sock_iocb *siocb = kiocb_to_siocb(iocb);
 +	struct scm_cookie tmp_scm;
 +	struct sock *sk = sock->sk;
 +	struct unix_sock *u = unix_sk(sk);
 +	struct sockaddr_un *sunaddr = msg->msg_name;
++=======
+ struct unix_stream_read_state {
+ 	int (*recv_actor)(struct sk_buff *, int, int,
+ 			  struct unix_stream_read_state *);
+ 	struct socket *socket;
+ 	struct msghdr *msg;
+ 	struct pipe_inode_info *pipe;
+ 	size_t size;
+ 	int flags;
+ 	unsigned int splice_flags;
+ };
+ 
+ static int unix_stream_read_generic(struct unix_stream_read_state *state)
+ {
+ 	struct scm_cookie scm;
+ 	struct socket *sock = state->socket;
+ 	struct sock *sk = sock->sk;
+ 	struct unix_sock *u = unix_sk(sk);
++>>>>>>> 2b514574f7e8 (net: af_unix: implement splice for stream af_unix sockets)
  	int copied = 0;
+ 	int flags = state->flags;
  	int noblock = flags & MSG_DONTWAIT;
- 	int check_creds = 0;
+ 	bool check_creds = false;
  	int target;
  	int err = 0;
  	long timeo;
@@@ -1941,12 -2041,6 +1986,15 @@@
  	/* Lock the socket to prevent queue disordering
  	 * while sleeps in memcpy_tomsg
  	 */
++<<<<<<< HEAD
 +
 +	if (!siocb->scm) {
 +		siocb->scm = &tmp_scm;
 +		memset(&tmp_scm, 0, sizeof(tmp_scm));
 +	}
 +
++=======
++>>>>>>> 2b514574f7e8 (net: af_unix: implement splice for stream af_unix sockets)
  	err = mutex_lock_interruptible(&u->readlock);
  	if (unlikely(err)) {
  		/* recvmsg() in non blocking mode is supposed to return -EAGAIN
@@@ -2017,8 -2114,8 +2068,13 @@@ unlock
  				break;
  		} else if (test_bit(SOCK_PASSCRED, &sock->flags)) {
  			/* Copy credentials */
++<<<<<<< HEAD
 +			scm_set_cred(siocb->scm, UNIXCB(skb).pid, UNIXCB(skb).uid, UNIXCB(skb).gid);
 +			check_creds = 1;
++=======
+ 			scm_set_cred(&scm, UNIXCB(skb).pid, UNIXCB(skb).uid, UNIXCB(skb).gid);
+ 			check_creds = true;
++>>>>>>> 2b514574f7e8 (net: af_unix: implement splice for stream af_unix sockets)
  		}
  
  		/* Copy address just once */
@@@ -2028,8 -2127,8 +2086,13 @@@
  		}
  
  		chunk = min_t(unsigned int, unix_skb_len(skb) - skip, size);
++<<<<<<< HEAD
 +		if (skb_copy_datagram_iovec(skb, UNIXCB(skb).consumed + skip,
 +					    msg->msg_iov, chunk)) {
++=======
+ 		chunk = state->recv_actor(skb, skip, chunk, state);
+ 		if (chunk < 0) {
++>>>>>>> 2b514574f7e8 (net: af_unix: implement splice for stream af_unix sockets)
  			if (copied == 0)
  				copied = -EFAULT;
  			break;
@@@ -2067,7 -2166,10 +2130,14 @@@
  	} while (size);
  
  	mutex_unlock(&u->readlock);
++<<<<<<< HEAD
 +	scm_recv(sock, msg, siocb->scm, flags);
++=======
+ 	if (state->msg)
+ 		scm_recv(sock, state->msg, &scm, flags);
+ 	else
+ 		scm_destroy(&scm);
++>>>>>>> 2b514574f7e8 (net: af_unix: implement splice for stream af_unix sockets)
  out:
  	return copied ? : err;
  }
diff --git a/fs/splice.c b/fs/splice.c
index e186d80944b5..aedfc77487db 100644
--- a/fs/splice.c
+++ b/fs/splice.c
@@ -265,6 +265,7 @@ ssize_t splice_to_pipe(struct pipe_inode_info *pipe,
 
 	return ret;
 }
+EXPORT_SYMBOL_GPL(splice_to_pipe);
 
 void spd_release_page(struct splice_pipe_desc *spd, unsigned int i)
 {
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index 13e8ed896c2a..631711ea8ee0 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -1842,6 +1842,7 @@ done:
 
 	return ret;
 }
+EXPORT_SYMBOL_GPL(skb_splice_bits);
 
 /**
  *	skb_store_bits - store bits from kernel buffer to skb
* Unmerged path net/unix/af_unix.c
