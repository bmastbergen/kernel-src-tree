pnfs: Refactor the *_layout_mark_request_commit to use pnfs_layout_mark_request_commit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Tom Haynes <thomas.haynes@primarydata.com>
commit 338d00cfef07d74a072f96821c64b20f98517d72
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/338d00cf.failed

The File Layout's filelayout_mark_request_commit() is almost the
Flex File Layout's ff_layout_mark_request_commit(). And that can
be reduced by calling into nfs_request_add_commit_list().

	Signed-off-by: Tom Haynes <loghyr@primarydata.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 338d00cfef07d74a072f96821c64b20f98517d72)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/filelayout/filelayout.c
#	fs/nfs/flexfilelayout/flexfilelayout.c
#	fs/nfs/pnfs.h
#	fs/nfs/pnfs_nfs.c
diff --cc fs/nfs/filelayout/filelayout.c
index a2f92d4c1128,91e88a7ecef0..000000000000
--- a/fs/nfs/filelayout/filelayout.c
+++ b/fs/nfs/filelayout/filelayout.c
@@@ -1042,53 -960,20 +1042,66 @@@ filelayout_mark_request_commit(struct n
  {
  	struct nfs4_filelayout_segment *fl = FILELAYOUT_LSEG(lseg);
  	u32 i, j;
- 	struct list_head *list;
- 	struct pnfs_commit_bucket *buckets;
  
  	if (fl->commit_through_mds) {
++<<<<<<< HEAD
 +		list = &cinfo->mds->list;
 +		spin_lock(cinfo->lock);
 +		goto mds_commit;
 +	}
 +
 +	/* Note that we are calling nfs4_fl_calc_j_index on each page
 +	 * that ends up being committed to a data server.  An attractive
 +	 * alternative is to add a field to nfs_write_data and nfs_page
 +	 * to store the value calculated in filelayout_write_pagelist
 +	 * and just use that here.
 +	 */
 +	j = nfs4_fl_calc_j_index(lseg, req_offset(req));
 +	i = select_bucket_index(fl, j);
 +	spin_lock(cinfo->lock);
 +	buckets = cinfo->ds->buckets;
 +	list = &buckets[i].written;
 +	if (list_empty(list)) {
 +		/* Non-empty buckets hold a reference on the lseg.  That ref
 +		 * is normally transferred to the COMMIT call and released
 +		 * there.  It could also be released if the last req is pulled
 +		 * off due to a rewrite, in which case it will be done in
 +		 * filelayout_clear_request_commit
++=======
+ 		nfs_request_add_commit_list(req, &cinfo->mds->list, cinfo);
+ 	} else {
+ 		/* Note that we are calling nfs4_fl_calc_j_index on each page
+ 		 * that ends up being committed to a data server.  An attractive
+ 		 * alternative is to add a field to nfs_write_data and nfs_page
+ 		 * to store the value calculated in filelayout_write_pagelist
+ 		 * and just use that here.
++>>>>>>> 338d00cfef07 (pnfs: Refactor the *_layout_mark_request_commit to use pnfs_layout_mark_request_commit)
  		 */
- 		buckets[i].wlseg = pnfs_get_lseg(lseg);
+ 		j = nfs4_fl_calc_j_index(lseg, req_offset(req));
+ 		i = select_bucket_index(fl, j);
+ 		pnfs_layout_mark_request_commit(req, lseg, cinfo, i);
  	}
++<<<<<<< HEAD
 +	set_bit(PG_COMMIT_TO_DS, &req->wb_flags);
 +	cinfo->ds->nwritten++;
 +
 +mds_commit:
 +	/* nfs_request_add_commit_list(). We need to add req to list without
 +	 * dropping cinfo lock.
 +	 */
 +	set_bit(PG_CLEAN, &(req)->wb_flags);
 +	nfs_list_add_request(req, list);
 +	cinfo->mds->ncommit++;
 +	spin_unlock(cinfo->lock);
 +	if (!cinfo->dreq) {
 +		inc_zone_page_state(req->wb_page, NR_UNSTABLE_NFS);
 +		inc_bdi_stat(page_file_mapping(req->wb_page)->backing_dev_info,
 +			     BDI_RECLAIMABLE);
 +		__mark_inode_dirty(req->wb_context->dentry->d_inode,
 +				   I_DIRTY_DATASYNC);
 +	}
++=======
++>>>>>>> 338d00cfef07 (pnfs: Refactor the *_layout_mark_request_commit to use pnfs_layout_mark_request_commit)
  }
  
  static u32 calc_ds_index_from_commit(struct pnfs_layout_segment *lseg, u32 i)
diff --cc fs/nfs/flexfilelayout/flexfilelayout.c
index f29fb7d7e8f8,315cc68945b9..000000000000
--- a/fs/nfs/flexfilelayout/flexfilelayout.c
+++ b/fs/nfs/flexfilelayout/flexfilelayout.c
@@@ -1332,47 -1332,6 +1332,50 @@@ ff_layout_write_pagelist(struct nfs_pgi
  	return PNFS_ATTEMPTED;
  }
  
++<<<<<<< HEAD
 +static void
 +ff_layout_mark_request_commit(struct nfs_page *req,
 +			      struct pnfs_layout_segment *lseg,
 +			      struct nfs_commit_info *cinfo,
 +			      u32 ds_commit_idx)
 +{
 +	struct list_head *list;
 +	struct pnfs_commit_bucket *buckets;
 +
 +	spin_lock(cinfo->lock);
 +	buckets = cinfo->ds->buckets;
 +	list = &buckets[ds_commit_idx].written;
 +	if (list_empty(list)) {
 +		/* Non-empty buckets hold a reference on the lseg.  That ref
 +		 * is normally transferred to the COMMIT call and released
 +		 * there.  It could also be released if the last req is pulled
 +		 * off due to a rewrite, in which case it will be done in
 +		 * pnfs_common_clear_request_commit
 +		 */
 +		WARN_ON_ONCE(buckets[ds_commit_idx].wlseg != NULL);
 +		buckets[ds_commit_idx].wlseg = pnfs_get_lseg(lseg);
 +	}
 +	set_bit(PG_COMMIT_TO_DS, &req->wb_flags);
 +	cinfo->ds->nwritten++;
 +
 +	/* nfs_request_add_commit_list(). We need to add req to list without
 +	 * dropping cinfo lock.
 +	 */
 +	set_bit(PG_CLEAN, &(req)->wb_flags);
 +	nfs_list_add_request(req, list);
 +	cinfo->mds->ncommit++;
 +	spin_unlock(cinfo->lock);
 +	if (!cinfo->dreq) {
 +		inc_zone_page_state(req->wb_page, NR_UNSTABLE_NFS);
 +		inc_bdi_stat(page_file_mapping(req->wb_page)->backing_dev_info,
 +			     BDI_RECLAIMABLE);
 +		__mark_inode_dirty(req->wb_context->dentry->d_inode,
 +				   I_DIRTY_DATASYNC);
 +	}
 +}
 +
++=======
++>>>>>>> 338d00cfef07 (pnfs: Refactor the *_layout_mark_request_commit to use pnfs_layout_mark_request_commit)
  static u32 calc_ds_index_from_commit(struct pnfs_layout_segment *lseg, u32 i)
  {
  	return i;
diff --cc fs/nfs/pnfs.h
index 82cc80eaff30,635f0865671c..000000000000
--- a/fs/nfs/pnfs.h
+++ b/fs/nfs/pnfs.h
@@@ -300,8 -316,43 +300,48 @@@ bool nfs4_put_deviceid_node(struct nfs4
  void nfs4_mark_deviceid_unavailable(struct nfs4_deviceid_node *node);
  bool nfs4_test_deviceid_unavailable(struct nfs4_deviceid_node *node);
  void nfs4_deviceid_purge_client(const struct nfs_client *);
++<<<<<<< HEAD
 +int nfs4_deviceid_getdevicelist(struct nfs_server *server,
 +		const struct nfs_fh *fh);
++=======
+ 
+ /* pnfs_nfs.c */
+ void pnfs_generic_clear_request_commit(struct nfs_page *req,
+ 				       struct nfs_commit_info *cinfo);
+ void pnfs_generic_commit_release(void *calldata);
+ void pnfs_generic_prepare_to_resend_writes(struct nfs_commit_data *data);
+ void pnfs_generic_rw_release(void *data);
+ void pnfs_generic_recover_commit_reqs(struct list_head *dst,
+ 				      struct nfs_commit_info *cinfo);
+ int pnfs_generic_commit_pagelist(struct inode *inode,
+ 				 struct list_head *mds_pages,
+ 				 int how,
+ 				 struct nfs_commit_info *cinfo,
+ 				 int (*initiate_commit)(struct nfs_commit_data *data,
+ 							int how));
+ int pnfs_generic_scan_commit_lists(struct nfs_commit_info *cinfo, int max);
+ void pnfs_generic_write_commit_done(struct rpc_task *task, void *data);
+ void nfs4_pnfs_ds_put(struct nfs4_pnfs_ds *ds);
+ struct nfs4_pnfs_ds *nfs4_pnfs_ds_add(struct list_head *dsaddrs,
+ 				      gfp_t gfp_flags);
+ void nfs4_pnfs_v3_ds_connect_unload(void);
+ void nfs4_pnfs_ds_connect(struct nfs_server *mds_srv, struct nfs4_pnfs_ds *ds,
+ 			  struct nfs4_deviceid_node *devid, unsigned int timeo,
+ 			  unsigned int retrans, u32 version, u32 minor_version,
+ 			  rpc_authflavor_t au_flavor);
+ struct nfs4_pnfs_ds_addr *nfs4_decode_mp_ds_addr(struct net *net,
+ 						 struct xdr_stream *xdr,
+ 						 gfp_t gfp_flags);
+ void pnfs_layout_mark_request_commit(struct nfs_page *req,
+ 				     struct pnfs_layout_segment *lseg,
+ 				     struct nfs_commit_info *cinfo,
+ 				     u32 ds_commit_idx);
+ 
+ static inline bool nfs_have_layout(struct inode *inode)
+ {
+ 	return NFS_I(inode)->layout != NULL;
+ }
++>>>>>>> 338d00cfef07 (pnfs: Refactor the *_layout_mark_request_commit to use pnfs_layout_mark_request_commit)
  
  static inline struct nfs4_deviceid_node *
  nfs4_get_deviceid(struct nfs4_deviceid_node *d)
* Unmerged path fs/nfs/pnfs_nfs.c
* Unmerged path fs/nfs/filelayout/filelayout.c
* Unmerged path fs/nfs/flexfilelayout/flexfilelayout.c
* Unmerged path fs/nfs/pnfs.h
* Unmerged path fs/nfs/pnfs_nfs.c
