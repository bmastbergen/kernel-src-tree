xfs: factor out xfs_ioctl_setattr transaciton preamble

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit 8f3d17ab060ec21cead88b81c65050a6ff77e9be
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/8f3d17ab.failed

The setup of the transaction is done after a random smattering of
checks and before another bunch of ioperations specific
validity checks. Pull all the preamble out into a helper function
that returns a transaction or error.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit 8f3d17ab060ec21cead88b81c65050a6ff77e9be)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_ioctl.c
diff --cc fs/xfs/xfs_ioctl.c
index ff7a7ccc1aa5,0f62f5b3e221..000000000000
--- a/fs/xfs/xfs_ioctl.c
+++ b/fs/xfs/xfs_ioctl.c
@@@ -1045,6 -1013,91 +1045,94 @@@ xfs_diflags_to_linux
  		inode->i_flags &= ~S_NOATIME;
  }
  
++<<<<<<< HEAD
++=======
+ static int
+ xfs_ioctl_setattr_xflags(
+ 	struct xfs_trans	*tp,
+ 	struct xfs_inode	*ip,
+ 	struct fsxattr		*fa)
+ {
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 
+ 	/* Can't change realtime flag if any extents are allocated. */
+ 	if ((ip->i_d.di_nextents || ip->i_delayed_blks) &&
+ 	    XFS_IS_REALTIME_INODE(ip) != (fa->fsx_xflags & XFS_XFLAG_REALTIME))
+ 		return -EINVAL;
+ 
+ 	/* If realtime flag is set then must have realtime device */
+ 	if (fa->fsx_xflags & XFS_XFLAG_REALTIME) {
+ 		if (mp->m_sb.sb_rblocks == 0 || mp->m_sb.sb_rextsize == 0 ||
+ 		    (ip->i_d.di_extsize % mp->m_sb.sb_rextsize))
+ 			return -EINVAL;
+ 	}
+ 
+ 	/*
+ 	 * Can't modify an immutable/append-only file unless
+ 	 * we have appropriate permission.
+ 	 */
+ 	if (((ip->i_d.di_flags & (XFS_DIFLAG_IMMUTABLE | XFS_DIFLAG_APPEND)) ||
+ 	     (fa->fsx_xflags & (XFS_XFLAG_IMMUTABLE | XFS_XFLAG_APPEND))) &&
+ 	    !capable(CAP_LINUX_IMMUTABLE))
+ 		return -EPERM;
+ 
+ 	xfs_set_diflags(ip, fa->fsx_xflags);
+ 	xfs_diflags_to_linux(ip);
+ 	xfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);
+ 	xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
+ 	XFS_STATS_INC(xs_ig_attrchg);
+ 	return 0;
+ }
+ 
+ /*
+  * Set up the transaction structure for the setattr operation, checking that we
+  * have permission to do so. On success, return a clean transaction and the
+  * inode locked exclusively ready for further operation specific checks. On
+  * failure, return an error without modifying or locking the inode.
+  */
+ static struct xfs_trans *
+ xfs_ioctl_setattr_get_trans(
+ 	struct xfs_inode	*ip)
+ {
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct xfs_trans	*tp;
+ 	int			error;
+ 
+ 	if (mp->m_flags & XFS_MOUNT_RDONLY)
+ 		return ERR_PTR(-EROFS);
+ 	if (XFS_FORCED_SHUTDOWN(mp))
+ 		return ERR_PTR(-EIO);
+ 
+ 	tp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_NOT_SIZE);
+ 	error = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);
+ 	if (error)
+ 		goto out_cancel;
+ 
+ 	xfs_ilock(ip, XFS_ILOCK_EXCL);
+ 	xfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);
+ 
+ 	/*
+ 	 * CAP_FOWNER overrides the following restrictions:
+ 	 *
+ 	 * The user ID of the calling process must be equal to the file owner
+ 	 * ID, except in cases where the CAP_FSETID capability is applicable.
+ 	 */
+ 	if (!inode_owner_or_capable(VFS_I(ip))) {
+ 		error = -EPERM;
+ 		goto out_cancel;
+ 	}
+ 
+ 	if (mp->m_flags & XFS_MOUNT_WSYNC)
+ 		xfs_trans_set_sync(tp);
+ 
+ 	return tp;
+ 
+ out_cancel:
+ 	xfs_trans_cancel(tp, 0);
+ 	return ERR_PTR(error);
+ }
+ 
++>>>>>>> 8f3d17ab060e (xfs: factor out xfs_ioctl_setattr transaciton preamble)
  #define FSX_PROJID	1
  #define FSX_EXTSIZE	2
  #define FSX_XFLAGS	4
@@@ -1065,11 -1117,6 +1152,14 @@@ xfs_ioctl_setattr
  
  	trace_xfs_ioctl_setattr(ip);
  
++<<<<<<< HEAD
 +	if (mp->m_flags & XFS_MOUNT_RDONLY)
 +		return XFS_ERROR(EROFS);
 +	if (XFS_FORCED_SHUTDOWN(mp))
 +		return XFS_ERROR(EIO);
 +
++=======
++>>>>>>> 8f3d17ab060e (xfs: factor out xfs_ioctl_setattr transaciton preamble)
  	/*
  	 * Disallow 32bit project ids when projid32bit feature is not enabled.
  	 */
@@@ -1093,28 -1140,10 +1183,35 @@@
  			return code;
  	}
  
++<<<<<<< HEAD
 +	/*
 +	 * For the other attributes, we acquire the inode lock and
 +	 * first do an error checking pass.
 +	 */
 +	tp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_NOT_SIZE);
 +	code = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);
 +	if (code)
 +		goto error_return;
 +
 +	lock_flags = XFS_ILOCK_EXCL;
 +	xfs_ilock(ip, lock_flags);
 +
 +	/*
 +	 * CAP_FOWNER overrides the following restrictions:
 +	 *
 +	 * The user ID of the calling process must be equal
 +	 * to the file owner ID, except in cases where the
 +	 * CAP_FSETID capability is applicable.
 +	 */
 +	if (!inode_owner_or_capable(VFS_I(ip))) {
 +		code = XFS_ERROR(EPERM);
 +		goto error_return;
++=======
+ 	tp = xfs_ioctl_setattr_get_trans(ip);
+ 	if (IS_ERR(tp)) {
+ 		code = PTR_ERR(tp);
+ 		goto error_free_dquots;
++>>>>>>> 8f3d17ab060e (xfs: factor out xfs_ioctl_setattr transaciton preamble)
  	}
  
  	/*
@@@ -1285,25 -1267,7 +1382,27 @@@
  		ip->i_d.di_extsize = extsize;
  	}
  
++<<<<<<< HEAD
 +	xfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);
 +	xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
 +
 +	XFS_STATS_INC(xs_ig_attrchg);
 +
 +	/*
 +	 * If this is a synchronous mount, make sure that the
 +	 * transaction goes to disk before returning to the user.
 +	 * This is slightly sub-optimal in that truncates require
 +	 * two sync transactions instead of one for wsync filesystems.
 +	 * One for the truncate and one for the timestamps since we
 +	 * don't want to change the timestamps unless we're sure the
 +	 * truncate worked.  Truncates are less than 1% of the laddis
 +	 * mix so this probably isn't worth the trouble to optimize.
 +	 */
 +	if (mp->m_flags & XFS_MOUNT_WSYNC)
 +		xfs_trans_set_sync(tp);
++=======
++>>>>>>> 8f3d17ab060e (xfs: factor out xfs_ioctl_setattr transaciton preamble)
  	code = xfs_trans_commit(tp, 0);
- 	xfs_iunlock(ip, lock_flags);
  
  	/*
  	 * Release any dquot(s) the inode had kept before chown.
* Unmerged path fs/xfs/xfs_ioctl.c
