xfs: kill VN_MAPPED

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit dd8c38bab0d88615e0bdf013e6de3d4345f8cda2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/dd8c38ba.failed

Only one user, no longer needed.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit dd8c38bab0d88615e0bdf013e6de3d4345f8cda2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_bmap_util.c
#	fs/xfs/xfs_vnode.h
diff --cc fs/xfs/xfs_bmap_util.c
index e2ea28ff57bf,bf7e6159cfe2..000000000000
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@@ -1640,9 -1756,43 +1640,46 @@@ xfs_swap_extents
  	    (sbp->bs_ctime.tv_nsec != VFS_I(ip)->i_ctime.tv_nsec) ||
  	    (sbp->bs_mtime.tv_sec != VFS_I(ip)->i_mtime.tv_sec) ||
  	    (sbp->bs_mtime.tv_nsec != VFS_I(ip)->i_mtime.tv_nsec)) {
 -		error = -EBUSY;
 -		goto out_unlock;
 +		error = XFS_ERROR(EBUSY);
 +		goto out_trans_cancel;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	/* We need to fail if the file is memory mapped.  Once we have tossed
+ 	 * all existing pages, the page fault will have no option
+ 	 * but to go to the filesystem for pages. By making the page fault call
+ 	 * vop_read (or write in the case of autogrow) they block on the iolock
+ 	 * until we have switched the extents.
+ 	 */
+ 	if (mapping_mapped(VFS_I(ip)->i_mapping)) {
+ 		error = -EBUSY;
+ 		goto out_unlock;
+ 	}
+ 
+ 	xfs_iunlock(ip, XFS_ILOCK_EXCL);
+ 	xfs_iunlock(tip, XFS_ILOCK_EXCL);
+ 
+ 	/*
+ 	 * There is a race condition here since we gave up the
+ 	 * ilock.  However, the data fork will not change since
+ 	 * we have the iolock (locked for truncation too) so we
+ 	 * are safe.  We don't really care if non-io related
+ 	 * fields change.
+ 	 */
+ 	truncate_pagecache_range(VFS_I(ip), 0, -1);
+ 
+ 	tp = xfs_trans_alloc(mp, XFS_TRANS_SWAPEXT);
+ 	error = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);
+ 	if (error) {
+ 		xfs_iunlock(ip,  XFS_IOLOCK_EXCL);
+ 		xfs_iunlock(tip, XFS_IOLOCK_EXCL);
+ 		xfs_trans_cancel(tp, 0);
+ 		goto out;
+ 	}
+ 	xfs_lock_two_inodes(ip, tip, XFS_ILOCK_EXCL);
+ 
++>>>>>>> dd8c38bab0d8 (xfs: kill VN_MAPPED)
  	/*
  	 * Count the number of extended attribute blocks
  	 */
diff --cc fs/xfs/xfs_vnode.h
index e8a77383c0d5,300725dc3626..000000000000
--- a/fs/xfs/xfs_vnode.h
+++ b/fs/xfs/xfs_vnode.h
@@@ -34,13 -34,4 +34,16 @@@ struct attrlist_cursor_kern
  	{ IO_ISDIRECT,	"DIRECT" }, \
  	{ IO_INVIS,	"INVIS"}
  
++<<<<<<< HEAD
 +/*
 + * Some useful predicates.
 + */
 +#define VN_MAPPED(vp)	mapping_mapped(vp->i_mapping)
 +#define VN_CACHED(vp)	(vp->i_mapping->nrpages)
 +#define VN_DIRTY(vp)	mapping_tagged(vp->i_mapping, \
 +					PAGECACHE_TAG_DIRTY)
 +
 +
++=======
++>>>>>>> dd8c38bab0d8 (xfs: kill VN_MAPPED)
  #endif	/* __XFS_VNODE_H__ */
* Unmerged path fs/xfs/xfs_bmap_util.c
* Unmerged path fs/xfs/xfs_vnode.h
