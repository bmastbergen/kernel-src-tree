cpuidle: powernv: Read target_residency value of idle states from DT if available

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [cpuidle] powernv: Read target_residency value of idle states from DT if available (Gustavo Duarte) [1199939]
Rebuild_FUZZ: 94.12%
commit-author Preeti U Murthy <preeti@linux.vnet.ibm.com>
commit 92c83ff5b42b109c94fdeee53cb31f674f776d75
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/92c83ff5.failed

The device tree now exposes the residency values for different idle states. Read
these values instead of calculating residency from the latency values. The values
exposed in the DT are validated for optimal power efficiency. However to maintain
compatibility with the older firmware code which does not expose residency
values, use default values as a fallback mechanism. While at it, use better
APIs to parse the powermgmt device tree node.

	Signed-off-by: Preeti U Murthy <preeti@linux.vnet.ibm.com>
	Acked-by: Stewart Smith <stewart@linux.vnet.ibm.com>
	Acked-by: Michael Ellerman <mpe@ellerman.id.au>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 92c83ff5b42b109c94fdeee53cb31f674f776d75)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpuidle/cpuidle-powernv.c
diff --cc drivers/cpuidle/cpuidle-powernv.c
index 7d3a3497dd4c,30d42298a69f..000000000000
--- a/drivers/cpuidle/cpuidle-powernv.c
+++ b/drivers/cpuidle/cpuidle-powernv.c
@@@ -194,38 -197,42 +201,69 @@@ static int powernv_add_idle_states(void
  
  		flags = be32_to_cpu(idle_state_flags[i]);
  
- 		/* Cpuidle accepts exit_latency in us and we estimate
- 		 * target residency to be 10x exit_latency
+ 		/*
+ 		 * Cpuidle accepts exit_latency and target_residency in us.
+ 		 * Use default target_residency values if f/w does not expose it.
  		 */
++<<<<<<< HEAD
 +		latency_ns = be32_to_cpu(idle_state_latency[i]);
 +		if (flags & IDLE_USE_INST_NAP) {
 +			/* Add NAP state */
 +			strcpy(powernv_states[nr_idle_states].name, "Nap");
 +			strcpy(powernv_states[nr_idle_states].desc, "Nap");
 +			powernv_states[nr_idle_states].flags = CPUIDLE_FLAG_TIME_VALID;
 +			powernv_states[nr_idle_states].exit_latency =
 +					((unsigned int)latency_ns) / 1000;
 +			powernv_states[nr_idle_states].target_residency =
 +					((unsigned int)latency_ns / 100);
 +			powernv_states[nr_idle_states].enter = &nap_loop;
 +			nr_idle_states++;
 +		}
 +
 +		if (flags & IDLE_USE_INST_SLEEP) {
 +			/* Add FASTSLEEP state */
 +			strcpy(powernv_states[nr_idle_states].name, "FastSleep");
 +			strcpy(powernv_states[nr_idle_states].desc, "FastSleep");
 +			powernv_states[nr_idle_states].flags =
 +				CPUIDLE_FLAG_TIME_VALID | CPUIDLE_FLAG_TIMER_STOP;
 +			powernv_states[nr_idle_states].exit_latency =
 +					((unsigned int)latency_ns) / 1000;
 +			powernv_states[nr_idle_states].target_residency =
 +					((unsigned int)latency_ns / 100);
++=======
+ 		if (flags & OPAL_PM_NAP_ENABLED) {
+ 			/* Add NAP state */
+ 			strcpy(powernv_states[nr_idle_states].name, "Nap");
+ 			strcpy(powernv_states[nr_idle_states].desc, "Nap");
+ 			powernv_states[nr_idle_states].flags = 0;
+ 			powernv_states[nr_idle_states].target_residency = 100;
+ 			powernv_states[nr_idle_states].enter = &nap_loop;
+ 		} else if (flags & OPAL_PM_SLEEP_ENABLED ||
+ 			flags & OPAL_PM_SLEEP_ENABLED_ER1) {
+ 			/* Add FASTSLEEP state */
+ 			strcpy(powernv_states[nr_idle_states].name, "FastSleep");
+ 			strcpy(powernv_states[nr_idle_states].desc, "FastSleep");
+ 			powernv_states[nr_idle_states].flags = CPUIDLE_FLAG_TIMER_STOP;
+ 			powernv_states[nr_idle_states].target_residency = 300000;
++>>>>>>> 92c83ff5b42b (cpuidle: powernv: Read target_residency value of idle states from DT if available)
  			powernv_states[nr_idle_states].enter = &fastsleep_loop;
- 			nr_idle_states++;
  		}
+ 
+ 		powernv_states[nr_idle_states].exit_latency =
+ 				((unsigned int)latency_ns[i]) / 1000;
+ 
+ 		if (!rc) {
+ 			powernv_states[nr_idle_states].target_residency =
+ 				((unsigned int)residency_ns[i]) / 1000;
+ 		}
+ 
+ 		nr_idle_states++;
  	}
  
+ 	kfree(residency_ns);
+ out_free_latency:
+ 	kfree(latency_ns);
+ out:
  	return nr_idle_states;
  }
  
* Unmerged path drivers/cpuidle/cpuidle-powernv.c
