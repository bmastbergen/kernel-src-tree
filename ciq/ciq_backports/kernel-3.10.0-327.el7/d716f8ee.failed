xfs: remove xfs_bulkstat_single

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Christoph Hellwig <hch@lst.de>
commit d716f8eedb143387afd35d337327090b8348159e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/d716f8ee.failed

From: Christoph Hellwig <hch@lst.de>

xfs_bukstat_one doesn't have any failure case that would go away when
called through xfs_bulkstat, so remove the fallback and the now unessecary
xfs_bulkstat_single function.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Jie Liu <jeff.liu@oracle.com>
	Signed-off-by: Jie Liu <jeff.liu@oracle.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit d716f8eedb143387afd35d337327090b8348159e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_itable.c
diff --cc fs/xfs/xfs_itable.c
index 2e7b3970ae2e,e15df1f70d79..000000000000
--- a/fs/xfs/xfs_itable.c
+++ b/fs/xfs/xfs_itable.c
@@@ -509,54 -509,6 +509,57 @@@ xfs_bulkstat
  	return rval;
  }
  
++<<<<<<< HEAD
 +/*
 + * Return stat information in bulk (by-inode) for the filesystem.
 + * Special case for non-sequential one inode bulkstat.
 + */
 +int					/* error status */
 +xfs_bulkstat_single(
 +	xfs_mount_t		*mp,	/* mount point for filesystem */
 +	xfs_ino_t		*lastinop, /* inode to return */
 +	char			__user *buffer, /* buffer with inode stats */
 +	int			*done)	/* 1 if there are more stats to get */
 +{
 +	int			count;	/* count value for bulkstat call */
 +	int			error;	/* return value */
 +	xfs_ino_t		ino;	/* filesystem inode number */
 +	int			res;	/* result from bs1 */
 +
 +	/*
 +	 * note that requesting valid inode numbers which are not allocated
 +	 * to inodes will most likely cause xfs_imap_to_bp to generate warning
 +	 * messages about bad magic numbers. This is ok. The fact that
 +	 * the inode isn't actually an inode is handled by the
 +	 * error check below. Done this way to make the usual case faster
 +	 * at the expense of the error case.
 +	 */
 +
 +	ino = *lastinop;
 +	error = xfs_bulkstat_one(mp, ino, buffer, sizeof(xfs_bstat_t),
 +				 NULL, &res);
 +	if (error) {
 +		/*
 +		 * Special case way failed, do it the "long" way
 +		 * to see if that works.
 +		 */
 +		(*lastinop)--;
 +		count = 1;
 +		if (xfs_bulkstat(mp, lastinop, &count, xfs_bulkstat_one,
 +				sizeof(xfs_bstat_t), buffer, done))
 +			return error;
 +		if (count == 0 || (xfs_ino_t)*lastinop != ino)
 +			return error == EFSCORRUPTED ?
 +				XFS_ERROR(EINVAL) : error;
 +		else
 +			return 0;
 +	}
 +	*done = 0;
 +	return 0;
 +}
 +
++=======
++>>>>>>> d716f8eedb14 (xfs: remove xfs_bulkstat_single)
  int
  xfs_inumbers_fmt(
  	void			__user *ubuffer, /* buffer to write to */
diff --git a/fs/xfs/xfs_ioctl.c b/fs/xfs/xfs_ioctl.c
index c01d09b8b9c4..332cae8b6736 100644
--- a/fs/xfs/xfs_ioctl.c
+++ b/fs/xfs/xfs_ioctl.c
@@ -825,8 +825,8 @@ xfs_ioc_bulkstat(
 		error = xfs_inumbers(mp, &inlast, &count,
 					bulkreq.ubuffer, xfs_inumbers_fmt);
 	else if (cmd == XFS_IOC_FSBULKSTAT_SINGLE)
-		error = xfs_bulkstat_single(mp, &inlast,
-						bulkreq.ubuffer, &done);
+		error = xfs_bulkstat_one(mp, inlast, bulkreq.ubuffer,
+					sizeof(xfs_bstat_t), NULL, &done);
 	else	/* XFS_IOC_FSBULKSTAT */
 		error = xfs_bulkstat(mp, &inlast, &count, xfs_bulkstat_one,
 				     sizeof(xfs_bstat_t), bulkreq.ubuffer,
* Unmerged path fs/xfs/xfs_itable.c
diff --git a/fs/xfs/xfs_itable.h b/fs/xfs/xfs_itable.h
index 97295d91d170..6ea8b3912fa4 100644
--- a/fs/xfs/xfs_itable.h
+++ b/fs/xfs/xfs_itable.h
@@ -50,13 +50,6 @@ xfs_bulkstat(
 	char		__user *ubuffer,/* buffer with inode stats */
 	int		*done);		/* 1 if there are more stats to get */
 
-int
-xfs_bulkstat_single(
-	xfs_mount_t		*mp,
-	xfs_ino_t		*lastinop,
-	char			__user *buffer,
-	int			*done);
-
 typedef int (*bulkstat_one_fmt_pf)(  /* used size in bytes or negative error */
 	void			__user *ubuffer, /* buffer to write to */
 	int			ubsize,		 /* remaining user buffer sz */
