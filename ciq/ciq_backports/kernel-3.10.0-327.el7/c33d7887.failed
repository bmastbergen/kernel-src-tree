bonding: rework bond_3ad_xmit_xor() to use bond_for_each_slave() only

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Veaceslav Falico <vfalico@redhat.com>
commit c33d78874eeb6c28909158719043fa2a5fd18f0a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/c33d7887.failed

Currently, there are two loops - first we find the first slave in an
aggregator after the xmit_hash_policy() returned number, and after that we
loop from that slave, over bonding head, and till that slave to find any
suitable slave to send the packet through.

Replace it by just one bond_for_each_slave() loop, which first loops
through the requested number of slaves, saving the first suitable one, and
after that we've hit the requested number of slaves to skip - search for
any up slave to send the packet through. If we don't find such kind of
slave - then just send the packet through the first suitable slave found.

Logic remains unchainged, and we skip two loops. Also, refactor it a bit
for readability.

CC: Jay Vosburgh <fubar@us.ibm.com>
CC: Andy Gospodarek <andy@greyhouse.net>
	Signed-off-by: Veaceslav Falico <vfalico@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c33d78874eeb6c28909158719043fa2a5fd18f0a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_3ad.c
diff --cc drivers/net/bonding/bond_3ad.c
index 390061d09693,c861ee7e65ff..000000000000
--- a/drivers/net/bonding/bond_3ad.c
+++ b/drivers/net/bonding/bond_3ad.c
@@@ -2406,15 -2417,17 +2406,23 @@@ int bond_3ad_get_active_agg_info(struc
  
  int bond_3ad_xmit_xor(struct sk_buff *skb, struct net_device *dev)
  {
- 	struct slave *slave, *start_at;
  	struct bonding *bond = netdev_priv(dev);
++<<<<<<< HEAD
 +	int slave_agg_no;
 +	int slaves_in_agg;
 +	int agg_id;
 +	int i;
++=======
+ 	struct slave *slave, *first_ok_slave;
+ 	struct aggregator *agg;
++>>>>>>> c33d78874eeb (bonding: rework bond_3ad_xmit_xor() to use bond_for_each_slave() only)
  	struct ad_info ad_info;
+ 	struct list_head *iter;
+ 	int slaves_in_agg;
+ 	int slave_agg_no;
  	int res = 1;
+ 	int agg_id;
  
 -	read_lock(&bond->lock);
  	if (__bond_3ad_get_active_agg_info(bond, &ad_info)) {
  		pr_debug("%s: Error: __bond_3ad_get_active_agg_info failed\n",
  			 dev->name);
@@@ -2431,14 -2443,23 +2438,28 @@@
  	}
  
  	slave_agg_no = bond->xmit_hash_policy(skb, slaves_in_agg);
+ 	first_ok_slave = NULL;
  
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
 +		struct aggregator *agg = SLAVE_AD_INFO(slave).port.aggregator;
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
+ 		agg = SLAVE_AD_INFO(slave).port.aggregator;
+ 		if (!agg || agg->aggregator_identifier != agg_id)
+ 			continue;
++>>>>>>> c33d78874eeb (bonding: rework bond_3ad_xmit_xor() to use bond_for_each_slave() only)
  
- 		if (agg && (agg->aggregator_identifier == agg_id)) {
+ 		if (slave_agg_no >= 0) {
+ 			if (!first_ok_slave && SLAVE_IS_OK(slave))
+ 				first_ok_slave = slave;
  			slave_agg_no--;
- 			if (slave_agg_no < 0)
- 				break;
+ 			continue;
+ 		}
+ 
+ 		if (SLAVE_IS_OK(slave)) {
+ 			res = bond_dev_queue_xmit(bond, skb, slave->dev);
+ 			goto out;
  		}
  	}
  
@@@ -2448,22 -2469,13 +2469,12 @@@
  		goto out;
  	}
  
- 	start_at = slave;
- 
- 	bond_for_each_slave_from(bond, slave, i, start_at) {
- 		int slave_agg_id = 0;
- 		struct aggregator *agg = SLAVE_AD_INFO(slave).port.aggregator;
- 
- 		if (agg)
- 			slave_agg_id = agg->aggregator_identifier;
- 
- 		if (SLAVE_IS_OK(slave) && agg && (slave_agg_id == agg_id)) {
- 			res = bond_dev_queue_xmit(bond, skb, slave->dev);
- 			break;
- 		}
- 	}
+ 	/* we couldn't find any suitable slave after the agg_no, so use the
+ 	 * first suitable found, if found. */
+ 	if (first_ok_slave)
+ 		res = bond_dev_queue_xmit(bond, skb, first_ok_slave->dev);
  
  out:
 -	read_unlock(&bond->lock);
  	if (res) {
  		/* no suitable interface, frame not sent */
  		kfree_skb(skb);
* Unmerged path drivers/net/bonding/bond_3ad.c
