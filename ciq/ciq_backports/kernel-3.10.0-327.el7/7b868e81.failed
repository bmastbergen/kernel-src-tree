powerpc/mm: Return NULL for not present hugetlb page

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [powerpc] mm: Return NULL for not present hugetlb page (Gustavo Duarte) [1233071]
Rebuild_FUZZ: 91.67%
commit-author Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
commit 7b868e81be38d5ad4f4aa4be819a5fa543cc5ee8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/7b868e81.failed

We need to check whether pte is present in follow_huge_addr() and
properly return NULL if mapping is not present. Also use READ_ONCE
when dereferencing pte_t address.

Without this patch, we may wrongly return a zero pfn page in
follow_huge_addr().

	Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
	Signed-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 7b868e81be38d5ad4f4aa4be819a5fa543cc5ee8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/mm/hugetlbpage.c
diff --cc arch/powerpc/mm/hugetlbpage.c
index 2b186fc7d583,3385e3d0506e..000000000000
--- a/arch/powerpc/mm/hugetlbpage.c
+++ b/arch/powerpc/mm/hugetlbpage.c
@@@ -678,25 -685,39 +678,51 @@@ void hugetlb_free_pgd_range(struct mmu_
  struct page *
  follow_huge_addr(struct mm_struct *mm, unsigned long address, int write)
  {
- 	pte_t *ptep;
- 	struct page *page;
+ 	pte_t *ptep, pte;
  	unsigned shift;
++<<<<<<< HEAD
 +	unsigned long mask;
++=======
+ 	unsigned long mask, flags;
+ 	struct page *page = ERR_PTR(-EINVAL);
+ 
+ 	local_irq_save(flags);
+ 	ptep = find_linux_pte_or_hugepte(mm->pgd, address, &shift);
+ 	if (!ptep)
+ 		goto no_page;
+ 	pte = READ_ONCE(*ptep);
++>>>>>>> 7b868e81be38 (powerpc/mm: Return NULL for not present hugetlb page)
  	/*
+ 	 * Verify it is a huge page else bail.
  	 * Transparent hugepages are handled by generic code. We can skip them
  	 * here.
  	 */
++<<<<<<< HEAD
 +	ptep = find_linux_pte_or_hugepte(mm->pgd, address, &shift);
 +
 +	/* Verify it is a huge page else bail. */
 +	if (!ptep || !shift || pmd_trans_huge(*(pmd_t *)ptep))
 +		return ERR_PTR(-EINVAL);
 +
++=======
+ 	if (!shift || pmd_trans_huge(__pmd(pte_val(pte))))
+ 		goto no_page;
+ 
+ 	if (!pte_present(pte)) {
+ 		page = NULL;
+ 		goto no_page;
+ 	}
++>>>>>>> 7b868e81be38 (powerpc/mm: Return NULL for not present hugetlb page)
  	mask = (1UL << shift) - 1;
- 	page = pte_page(*ptep);
+ 	page = pte_page(pte);
  	if (page)
  		page += (address & mask) / PAGE_SIZE;
  
++<<<<<<< HEAD
++=======
+ no_page:
+ 	local_irq_restore(flags);
++>>>>>>> 7b868e81be38 (powerpc/mm: Return NULL for not present hugetlb page)
  	return page;
  }
  
* Unmerged path arch/powerpc/mm/hugetlbpage.c
