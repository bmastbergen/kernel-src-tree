ovl: allow distributed fs as lower layer

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Miklos Szeredi <mszeredi@suse.cz>
commit 7c03b5d45b8eebf0111125053d8fe887cc262ba6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/7c03b5d4.failed

Allow filesystems with .d_revalidate as lower layer(s), but not as upper
layer.

For local filesystems the rule was that modifications on the layers
directly while being part of the overlay results in undefined behavior.

This can easily be extended to distributed filesystems: we assume the tree
used as lower layer is static, which means ->d_revalidate() should always
return "1".  If that is not the case, return -ESTALE, don't try to work
around the modification.

	Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
(cherry picked from commit 7c03b5d45b8eebf0111125053d8fe887cc262ba6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/super.c
diff --cc fs/overlayfs/super.c
index 82e26523dd5b,8a08c582bc22..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -270,11 -318,37 +311,35 @@@ static const struct dentry_operations o
  	.d_release = ovl_dentry_release,
  };
  
++<<<<<<< HEAD
 +static struct ovl_entry *ovl_alloc_entry(void)
++=======
+ static const struct dentry_operations ovl_reval_dentry_operations = {
+ 	.d_release = ovl_dentry_release,
+ 	.d_revalidate = ovl_dentry_revalidate,
+ 	.d_weak_revalidate = ovl_dentry_weak_revalidate,
+ };
+ 
+ static struct ovl_entry *ovl_alloc_entry(unsigned int numlower)
++>>>>>>> 7c03b5d45b8e (ovl: allow distributed fs as lower layer)
  {
 -	size_t size = offsetof(struct ovl_entry, lowerstack[numlower]);
 -	struct ovl_entry *oe = kzalloc(size, GFP_KERNEL);
 -
 -	if (oe)
 -		oe->numlower = numlower;
 -
 -	return oe;
 +	return kzalloc(sizeof(struct ovl_entry), GFP_KERNEL);
  }
  
+ static bool ovl_dentry_remote(struct dentry *dentry)
+ {
+ 	return dentry->d_flags &
+ 		(DCACHE_OP_REVALIDATE | DCACHE_OP_WEAK_REVALIDATE);
+ }
+ 
+ static bool ovl_dentry_weird(struct dentry *dentry)
+ {
+ 	return dentry->d_flags & (DCACHE_NEED_AUTOMOUNT |
+ 				  DCACHE_MANAGE_TRANSIT |
+ 				  DCACHE_OP_HASH |
+ 				  DCACHE_OP_COMPARE);
+ }
+ 
  static inline struct dentry *ovl_lookup_real(struct dentry *dir,
  					     struct qstr *name)
  {
@@@ -323,56 -397,109 +388,71 @@@ struct dentry *ovl_lookup(struct inode 
  			  unsigned int flags)
  {
  	struct ovl_entry *oe;
 -	struct ovl_entry *poe = dentry->d_parent->d_fsdata;
 -	struct path *stack = NULL;
 -	struct dentry *upperdir, *upperdentry = NULL;
 -	unsigned int ctr = 0;
 +	struct dentry *upperdir;
 +	struct dentry *lowerdir;
 +	struct dentry *upperdentry = NULL;
 +	struct dentry *lowerdentry = NULL;
  	struct inode *inode = NULL;
 -	bool upperopaque = false;
 -	struct dentry *this, *prev = NULL;
 -	unsigned int i;
  	int err;
  
 -	upperdir = ovl_upperdentry_dereference(poe);
 -	if (upperdir) {
 -		this = ovl_lookup_real(upperdir, &dentry->d_name);
 -		err = PTR_ERR(this);
 -		if (IS_ERR(this))
 -			goto out;
 +	err = -ENOMEM;
 +	oe = ovl_alloc_entry();
 +	if (!oe)
 +		goto out;
  
++<<<<<<< HEAD
 +	upperdir = ovl_dentry_upper(dentry->d_parent);
 +	lowerdir = ovl_dentry_lower(dentry->d_parent);
 +
 +	if (upperdir) {
 +		upperdentry = ovl_lookup_real(upperdir, &dentry->d_name);
 +		err = PTR_ERR(upperdentry);
 +		if (IS_ERR(upperdentry))
 +			goto out_put_dir;
 +
 +		if (lowerdir && upperdentry) {
 +			if (ovl_is_whiteout(upperdentry)) {
 +				dput(upperdentry);
 +				upperdentry = NULL;
 +				oe->opaque = true;
 +			} else if (ovl_is_opaquedir(upperdentry)) {
 +				oe->opaque = true;
++=======
+ 		if (this) {
+ 			if (unlikely(ovl_dentry_remote(this))) {
+ 				dput(this);
+ 				err = -EREMOTE;
+ 				goto out;
+ 			}
+ 			if (ovl_is_whiteout(this)) {
+ 				dput(this);
+ 				this = NULL;
+ 				upperopaque = true;
+ 			} else if (poe->numlower && ovl_is_opaquedir(this)) {
+ 				upperopaque = true;
++>>>>>>> 7c03b5d45b8e (ovl: allow distributed fs as lower layer)
  			}
  		}
 -		upperdentry = prev = this;
  	}
 -
 -	if (!upperopaque && poe->numlower) {
 -		err = -ENOMEM;
 -		stack = kcalloc(poe->numlower, sizeof(struct path), GFP_KERNEL);
 -		if (!stack)
 -			goto out_put_upper;
 +	if (lowerdir && !oe->opaque) {
 +		lowerdentry = ovl_lookup_real(lowerdir, &dentry->d_name);
 +		err = PTR_ERR(lowerdentry);
 +		if (IS_ERR(lowerdentry))
 +			goto out_dput_upper;
  	}
  
 -	for (i = 0; !upperopaque && i < poe->numlower; i++) {
 -		bool opaque = false;
 -		struct path lowerpath = poe->lowerstack[i];
 -
 -		this = ovl_lookup_real(lowerpath.dentry, &dentry->d_name);
 -		err = PTR_ERR(this);
 -		if (IS_ERR(this)) {
 -			/*
 -			 * If it's positive, then treat ENAMETOOLONG as ENOENT.
 -			 */
 -			if (err == -ENAMETOOLONG && (upperdentry || ctr))
 -				continue;
 -			goto out_put;
 -		}
 -		if (!this)
 -			continue;
 -		if (ovl_is_whiteout(this)) {
 -			dput(this);
 -			break;
 -		}
 -		/*
 -		 * Only makes sense to check opaque dir if this is not the
 -		 * lowermost layer.
 -		 */
 -		if (i < poe->numlower - 1 && ovl_is_opaquedir(this))
 -			opaque = true;
 -
 -		if (prev && (!S_ISDIR(prev->d_inode->i_mode) ||
 -			     !S_ISDIR(this->d_inode->i_mode))) {
 -			/*
 -			 * FIXME: check for upper-opaqueness maybe better done
 -			 * in remove code.
 -			 */
 -			if (prev == upperdentry)
 -				upperopaque = true;
 -			dput(this);
 -			break;
 -		}
 -		/*
 -		 * If this is a non-directory then stop here.
 -		 */
 -		if (!S_ISDIR(this->d_inode->i_mode))
 -			opaque = true;
 -
 -		stack[ctr].dentry = this;
 -		stack[ctr].mnt = lowerpath.mnt;
 -		ctr++;
 -		prev = this;
 -		if (opaque)
 -			break;
 +	if (lowerdentry && upperdentry &&
 +	    (!S_ISDIR(upperdentry->d_inode->i_mode) ||
 +	     !S_ISDIR(lowerdentry->d_inode->i_mode))) {
 +		dput(lowerdentry);
 +		lowerdentry = NULL;
 +		oe->opaque = true;
  	}
  
 -	oe = ovl_alloc_entry(ctr);
 -	err = -ENOMEM;
 -	if (!oe)
 -		goto out_put;
 -
 -	if (upperdentry || ctr) {
 +	if (lowerdentry || upperdentry) {
  		struct dentry *realdentry;
  
 -		realdentry = upperdentry ? upperdentry : stack[0].dentry;
 -
 +		realdentry = upperdentry ? upperdentry : lowerdentry;
  		err = -ENOMEM;
  		inode = ovl_new_inode(dentry->d_sb, realdentry->d_inode->i_mode,
  				      oe);
@@@ -622,41 -764,84 +702,122 @@@ static void ovl_unescape(char *s
  	}
  }
  
++<<<<<<< HEAD
 +static int ovl_mount_dir(const char *name, struct path *path)
 +{
 +	int err;
 +	char *tmp = kstrdup(name, GFP_KERNEL);
 +
 +	if (!tmp)
 +		return -ENOMEM;
 +
 +	ovl_unescape(tmp);
 +	err = kern_path(tmp, LOOKUP_FOLLOW, path);
 +	if (err) {
 +		pr_err("overlayfs: failed to resolve '%s': %i\n", tmp, err);
 +		err = -EINVAL;
 +	}
 +	kfree(tmp);
 +	return err;
 +}
 +
 +static bool ovl_is_allowed_fs_type(struct dentry *root)
 +{
 +	const struct dentry_operations *dop = root->d_op;
 +
 +	/*
 +	 * We don't support:
 +	 *  - autofs
 +	 *  - filesystems with revalidate (FIXME for lower layer)
 +	 *  - filesystems with case insensitive names
 +	 */
 +	if (dop &&
 +	    (dop->d_manage ||
 +	     dop->d_revalidate || dop->d_weak_revalidate ||
 +	     dop->d_compare || dop->d_hash)) {
 +		return false;
 +	}
 +	return true;
++=======
+ static int ovl_mount_dir_noesc(const char *name, struct path *path)
+ {
+ 	int err = -EINVAL;
+ 
+ 	if (!*name) {
+ 		pr_err("overlayfs: empty lowerdir\n");
+ 		goto out;
+ 	}
+ 	err = kern_path(name, LOOKUP_FOLLOW, path);
+ 	if (err) {
+ 		pr_err("overlayfs: failed to resolve '%s': %i\n", name, err);
+ 		goto out;
+ 	}
+ 	err = -EINVAL;
+ 	if (ovl_dentry_weird(path->dentry)) {
+ 		pr_err("overlayfs: filesystem on '%s' not supported\n", name);
+ 		goto out_put;
+ 	}
+ 	if (!S_ISDIR(path->dentry->d_inode->i_mode)) {
+ 		pr_err("overlayfs: '%s' not a directory\n", name);
+ 		goto out_put;
+ 	}
+ 	return 0;
+ 
+ out_put:
+ 	path_put(path);
+ out:
+ 	return err;
+ }
+ 
+ static int ovl_mount_dir(const char *name, struct path *path)
+ {
+ 	int err = -ENOMEM;
+ 	char *tmp = kstrdup(name, GFP_KERNEL);
+ 
+ 	if (tmp) {
+ 		ovl_unescape(tmp);
+ 		err = ovl_mount_dir_noesc(tmp, path);
+ 
+ 		if (!err)
+ 			if (ovl_dentry_remote(path->dentry)) {
+ 				pr_err("overlayfs: filesystem on '%s' not supported as upperdir\n",
+ 				       tmp);
+ 				path_put(path);
+ 				err = -EINVAL;
+ 			}
+ 		kfree(tmp);
+ 	}
+ 	return err;
+ }
+ 
+ static int ovl_lower_dir(const char *name, struct path *path, long *namelen,
+ 			 int *stack_depth, bool *remote)
+ {
+ 	int err;
+ 	struct kstatfs statfs;
+ 
+ 	err = ovl_mount_dir_noesc(name, path);
+ 	if (err)
+ 		goto out;
+ 
+ 	err = vfs_statfs(path, &statfs);
+ 	if (err) {
+ 		pr_err("overlayfs: statfs failed on '%s'\n", name);
+ 		goto out_put;
+ 	}
+ 	*namelen = max(*namelen, statfs.f_namelen);
+ 	*stack_depth = max(*stack_depth, path->mnt->mnt_sb->s_stack_depth);
+ 
+ 	if (ovl_dentry_remote(path->dentry))
+ 		*remote = true;
+ 
+ 	return 0;
+ 
+ out_put:
+ 	path_put(path);
+ out:
+ 	return err;
++>>>>>>> 7c03b5d45b8e (ovl: allow distributed fs as lower layer)
  }
  
  /* Workdir should not be subdir of upperdir and vice versa */
@@@ -680,9 -883,13 +841,19 @@@ static int ovl_fill_super(struct super_
  	struct dentry *root_dentry;
  	struct ovl_entry *oe;
  	struct ovl_fs *ufs;
++<<<<<<< HEAD
 +	struct kstatfs statfs;
 +	const int *upper_stack_depth, *lower_stack_depth;
 +	int *overlay_stack_depth;
++=======
+ 	struct path *stack = NULL;
+ 	char *lowertmp;
+ 	char *lower;
+ 	unsigned int numlower;
+ 	unsigned int stacklen = 0;
+ 	unsigned int i;
+ 	bool remote = false;
++>>>>>>> 7c03b5d45b8e (ovl: allow distributed fs as lower layer)
  	int err;
  
  	err = -ENOMEM;
@@@ -702,123 -907,146 +873,144 @@@
  		goto out_free_config;
  	}
  
 -	sb->s_stack_depth = 0;
 -	if (ufs->config.upperdir) {
 -		if (!ufs->config.workdir) {
 -			pr_err("overlayfs: missing 'workdir'\n");
 -			goto out_free_config;
 -		}
 -
 -		err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
 -		if (err)
 -			goto out_free_config;
 -
 -		/* Upper fs should not be r/o */
 -		if (upperpath.mnt->mnt_sb->s_flags & MS_RDONLY) {
 -			pr_err("overlayfs: upper fs is r/o, try multi-lower layers mount\n");
 -			err = -EINVAL;
 -			goto out_put_upperpath;
 -		}
 -
 -		err = ovl_mount_dir(ufs->config.workdir, &workpath);
 -		if (err)
 -			goto out_put_upperpath;
 -
 -		err = -EINVAL;
 -		if (upperpath.mnt != workpath.mnt) {
 -			pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
 -			goto out_put_workpath;
 -		}
 -		if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
 -			pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
 -			goto out_put_workpath;
 -		}
 -		sb->s_stack_depth = upperpath.mnt->mnt_sb->s_stack_depth;
 -	}
  	err = -ENOMEM;
 -	lowertmp = kstrdup(ufs->config.lowerdir, GFP_KERNEL);
 -	if (!lowertmp)
 -		goto out_put_workpath;
 +	oe = ovl_alloc_entry();
 +	if (oe == NULL)
 +		goto out_free_config;
  
 -	err = -EINVAL;
 -	stacklen = ovl_split_lowerdirs(lowertmp);
 -	if (stacklen > OVL_MAX_STACK) {
 -		pr_err("overlayfs: too many lower directries, limit is %d\n",
 -		       OVL_MAX_STACK);
 -		goto out_free_lowertmp;
 -	} else if (!ufs->config.upperdir && stacklen == 1) {
 -		pr_err("overlayfs: at least 2 lowerdir are needed while upperdir nonexistent\n");
 -		goto out_free_lowertmp;
 -	}
 +	err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
 +	if (err)
 +		goto out_free_oe;
  
 -	stack = kcalloc(stacklen, sizeof(struct path), GFP_KERNEL);
 -	if (!stack)
 -		goto out_free_lowertmp;
 +	err = ovl_mount_dir(ufs->config.lowerdir, &lowerpath);
 +	if (err)
 +		goto out_put_upperpath;
  
++<<<<<<< HEAD
 +	err = ovl_mount_dir(ufs->config.workdir, &workpath);
 +	if (err)
++=======
+ 	lower = lowertmp;
+ 	for (numlower = 0; numlower < stacklen; numlower++) {
+ 		err = ovl_lower_dir(lower, &stack[numlower],
+ 				    &ufs->lower_namelen, &sb->s_stack_depth,
+ 				    &remote);
+ 		if (err)
+ 			goto out_put_lowerpath;
+ 
+ 		lower = strchr(lower, '\0') + 1;
+ 	}
+ 
+ 	err = -EINVAL;
+ 	sb->s_stack_depth++;
+ 	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
+ 		pr_err("overlayfs: maximum fs stacking depth exceeded\n");
++>>>>>>> 7c03b5d45b8e (ovl: allow distributed fs as lower layer)
  		goto out_put_lowerpath;
 +
 +	err = -EINVAL;
 +	if (!S_ISDIR(upperpath.dentry->d_inode->i_mode) ||
 +	    !S_ISDIR(lowerpath.dentry->d_inode->i_mode) ||
 +	    !S_ISDIR(workpath.dentry->d_inode->i_mode)) {
 +		pr_err("overlayfs: upperdir or lowerdir or workdir not a directory\n");
 +		goto out_put_workpath;
  	}
  
 -	if (ufs->config.upperdir) {
 -		ufs->upper_mnt = clone_private_mount(&upperpath);
 -		err = PTR_ERR(ufs->upper_mnt);
 -		if (IS_ERR(ufs->upper_mnt)) {
 -			pr_err("overlayfs: failed to clone upperpath\n");
 -			goto out_put_lowerpath;
 -		}
 +	if (upperpath.mnt != workpath.mnt) {
 +		pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
 +		goto out_put_workpath;
 +	}
 +	if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
 +		pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
 +		goto out_put_workpath;
 +	}
  
 -		ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
 -		err = PTR_ERR(ufs->workdir);
 -		if (IS_ERR(ufs->workdir)) {
 -			pr_warn("overlayfs: failed to create directory %s/%s (errno: %i); mounting read-only\n",
 -				ufs->config.workdir, OVL_WORKDIR_NAME, -err);
 -			sb->s_flags |= MS_RDONLY;
 -			ufs->workdir = NULL;
 -		}
 +	if (!ovl_is_allowed_fs_type(upperpath.dentry)) {
 +		pr_err("overlayfs: filesystem of upperdir is not supported\n");
 +		goto out_put_workpath;
  	}
  
 -	err = -ENOMEM;
 -	ufs->lower_mnt = kcalloc(numlower, sizeof(struct vfsmount *), GFP_KERNEL);
 -	if (ufs->lower_mnt == NULL)
 -		goto out_put_workdir;
 -	for (i = 0; i < numlower; i++) {
 -		struct vfsmount *mnt = clone_private_mount(&stack[i]);
 +	if (!ovl_is_allowed_fs_type(lowerpath.dentry)) {
 +		pr_err("overlayfs: filesystem of lowerdir is not supported\n");
 +		goto out_put_workpath;
 +	}
  
 -		err = PTR_ERR(mnt);
 -		if (IS_ERR(mnt)) {
 -			pr_err("overlayfs: failed to clone lowerpath\n");
 -			goto out_put_lower_mnt;
 -		}
 -		/*
 -		 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
 -		 * will fail instead of modifying lower fs.
 -		 */
 -		mnt->mnt_flags |= MNT_READONLY;
 -
 -		ufs->lower_mnt[ufs->numlower] = mnt;
 -		ufs->numlower++;
 +	err = vfs_statfs(&lowerpath, &statfs);
 +	if (err) {
 +		pr_err("overlayfs: statfs failed on lowerpath\n");
 +		goto out_put_workpath;
  	}
 +	ufs->lower_namelen = statfs.f_namelen;
 +
 +	upper_stack_depth = get_s_stack_depth(upperpath.mnt->mnt_sb);
 +	lower_stack_depth = get_s_stack_depth(lowerpath.mnt->mnt_sb);
 +	overlay_stack_depth = get_s_stack_depth(sb);
 +	err = -EOPNOTSUPP;
 +	if (!upper_stack_depth || !lower_stack_depth || !overlay_stack_depth) {
 +		pr_err("overlayfs: superblock missing extension wrapper (old kernel?)\n");
 +		goto out_put_workpath;
 +	}
 +
 +	*overlay_stack_depth = max(*upper_stack_depth, *lower_stack_depth) + 1;
 +
 +	err = -EINVAL;
 +	if (*overlay_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
 +		pr_err("overlayfs: maximum fs stacking depth exceeded\n");
 +		goto out_put_workpath;
 +	}
 +
 +	ufs->upper_mnt = clone_private_mount(&upperpath);
 +	err = PTR_ERR(ufs->upper_mnt);
 +	if (IS_ERR(ufs->upper_mnt)) {
 +		pr_err("overlayfs: failed to clone upperpath\n");
 +		goto out_put_workpath;
 +	}
 +
 +	ufs->lower_mnt = clone_private_mount(&lowerpath);
 +	err = PTR_ERR(ufs->lower_mnt);
 +	if (IS_ERR(ufs->lower_mnt)) {
 +		pr_err("overlayfs: failed to clone lowerpath\n");
 +		goto out_put_upper_mnt;
 +	}
 +
 +	ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
 +	err = PTR_ERR(ufs->workdir);
 +	if (IS_ERR(ufs->workdir)) {
 +		pr_err("overlayfs: failed to create directory %s/%s\n",
 +		       ufs->config.workdir, OVL_WORKDIR_NAME);
 +		goto out_put_lower_mnt;
 +	}
 +
 +	/*
 +	 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
 +	 * will fail instead of modifying lower fs.
 +	 */
 +	ufs->lower_mnt->mnt_flags |= MNT_READONLY;
  
 -	/* If the upper fs is nonexistent, we mark overlayfs r/o too */
 -	if (!ufs->upper_mnt)
 +	/* If the upper fs is r/o, we mark overlayfs r/o too */
 +	if (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)
  		sb->s_flags |= MS_RDONLY;
  
- 	sb->s_d_op = &ovl_dentry_operations;
+ 	if (remote)
+ 		sb->s_d_op = &ovl_reval_dentry_operations;
+ 	else
+ 		sb->s_d_op = &ovl_dentry_operations;
  
  	err = -ENOMEM;
 -	oe = ovl_alloc_entry(numlower);
 -	if (!oe)
 -		goto out_put_lower_mnt;
 +	root_inode = ovl_new_inode(sb, S_IFDIR, oe);
 +	if (!root_inode)
 +		goto out_put_workdir;
  
 -	root_dentry = d_make_root(ovl_new_inode(sb, S_IFDIR, oe));
 +	root_dentry = d_make_root(root_inode);
  	if (!root_dentry)
 -		goto out_free_oe;
 +		goto out_put_workdir;
  
  	mntput(upperpath.mnt);
 -	for (i = 0; i < numlower; i++)
 -		mntput(stack[i].mnt);
 +	mntput(lowerpath.mnt);
  	path_put(&workpath);
 -	kfree(lowertmp);
  
  	oe->__upperdentry = upperpath.dentry;
 -	for (i = 0; i < numlower; i++) {
 -		oe->lowerstack[i].dentry = stack[i].dentry;
 -		oe->lowerstack[i].mnt = ufs->lower_mnt[i];
 -	}
 +	oe->lowerdentry = lowerpath.dentry;
  
  	root_dentry->d_fsdata = oe;
  
* Unmerged path fs/overlayfs/super.c
