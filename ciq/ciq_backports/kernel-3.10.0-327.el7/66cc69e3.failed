Fix: module signature vs tracepoints: add new TAINT_UNSIGNED_MODULE

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [kernel] fix module signature vs tracepoints add new TAINT_UNSIGNED_MODULE (Jiri Olsa) [1179759]
Rebuild_FUZZ: 98.48%
commit-author Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
commit 66cc69e34e86a231fbe68d8918c6119e3b7549a3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/66cc69e3.failed

Users have reported being unable to trace non-signed modules loaded
within a kernel supporting module signature.

This is caused by tracepoint.c:tracepoint_module_coming() refusing to
take into account tracepoints sitting within force-loaded modules
(TAINT_FORCED_MODULE). The reason for this check, in the first place, is
that a force-loaded module may have a struct module incompatible with
the layout expected by the kernel, and can thus cause a kernel crash
upon forced load of that module on a kernel with CONFIG_TRACEPOINTS=y.

Tracepoints, however, specifically accept TAINT_OOT_MODULE and
TAINT_CRAP, since those modules do not lead to the "very likely system
crash" issue cited above for force-loaded modules.

With kernels having CONFIG_MODULE_SIG=y (signed modules), a non-signed
module is tainted re-using the TAINT_FORCED_MODULE taint flag.
Unfortunately, this means that Tracepoints treat that module as a
force-loaded module, and thus silently refuse to consider any tracepoint
within this module.

Since an unsigned module does not fit within the "very likely system
crash" category of tainting, add a new TAINT_UNSIGNED_MODULE taint flag
to specifically address this taint behavior, and accept those modules
within Tracepoints. We use the letter 'X' as a taint flag character for
a module being loaded that doesn't know how to sign its name (proposed
by Steven Rostedt).

Also add the missing 'O' entry to trace event show_module_flags() list
for the sake of completeness.

	Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
	Acked-by: Steven Rostedt <rostedt@goodmis.org>
NAKed-by: Ingo Molnar <mingo@redhat.com>
CC: Thomas Gleixner <tglx@linutronix.de>
CC: David Howells <dhowells@redhat.com>
CC: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
(cherry picked from commit 66cc69e34e86a231fbe68d8918c6119e3b7549a3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/module-signing.txt
#	include/linux/kernel.h
#	kernel/module.c
#	kernel/panic.c
#	kernel/tracepoint.c
diff --cc Documentation/module-signing.txt
index 2fecf1324005,b6af42e4d790..000000000000
--- a/Documentation/module-signing.txt
+++ b/Documentation/module-signing.txt
@@@ -2,69 -2,212 +2,76 @@@
  			KERNEL MODULE SIGNING FACILITY
  			==============================
  
 -CONTENTS
 +The module signing facility applies cryptographic signature checking to modules
 +on module load, checking the signature against a ring of public keys compiled
 +into the kernel. Currently only RSA keys encoded as X.509 certificates are
 +supported by the module signature code.
  
 - - Overview.
 - - Configuring module signing.
 - - Generating signing keys.
 - - Public keys in the kernel.
 - - Manually signing modules.
 - - Signed modules and stripping.
 - - Loading signed modules.
 - - Non-valid signatures and unsigned modules.
 - - Administering/protecting the private key.
 +This facility is enabled through CONFIG_MODULE_SIG. Turning on signature
 +checking will also force the module's ELF metadata to be verified before the
 +signature is checked.
  
 +=====================
 +SUPPLYING PUBLIC KEYS
 +=====================
  
 -========
 -OVERVIEW
 -========
 +A set of public keys must be supplied at main kernel compile time. A file,
 +x509.genkey must be provided which is used to generate the X.509 keys. If
 +not provided, a default configuration will be provided. The Makefile target
 +"x509.genkey" will generate the example configuration which can be modified
 +in the top level of the kernel build.
  
 -The kernel module signing facility cryptographically signs modules during
 -installation and then checks the signature upon loading the module.  This
 -allows increased kernel security by disallowing the loading of unsigned modules
 -or modules signed with an invalid key.  Module signing increases security by
 -making it harder to load a malicious module into the kernel.  The module
 -signature checking is done by the kernel so that it is not necessary to have
 -trusted userspace bits.
 +From this, the private and public keys will be generated as ./signing_key.priv
 +and ./signing_key.x509 respectively during the kernel build process.
  
 -This facility uses X.509 ITU-T standard certificates to encode the public keys
 -involved.  The signatures are not themselves encoded in any industrial standard
 -type.  The facility currently only supports the RSA public key encryption
 -standard (though it is pluggable and permits others to be used).  The possible
 -hash algorithms that can be used are SHA-1, SHA-224, SHA-256, SHA-384, and
 -SHA-512 (the algorithm is selected by data in the signature).
 +The above generates fresh keys using /dev/random.  If there's insufficient data
 +in /dev/random, more can be provided more by running:
  
 +	rngd -r /dev/urandom
  
 -==========================
 -CONFIGURING MODULE SIGNING
 -==========================
 +in the background.
  
 -The module signing facility is enabled by going to the "Enable Loadable Module
 -Support" section of the kernel configuration and turning on
 +==============
 +MODULE SIGNING
 +==============
  
 -	CONFIG_MODULE_SIG	"Module signature verification"
 +If CONFIG_MODULE_SIG_ALL is set, all modules will be signed automatically. If
 +not, they can be signed manually using scripts/sign-file:
  
 -This has a number of options available:
 +	scripts/sign-file <hash algo> $(MODSECKEY) $(MODPUBKEY) module.ko
  
 - (1) "Require modules to be validly signed" (CONFIG_MODULE_SIG_FORCE)
 + (*) The hash algorithm must be one of sha1, sha224, sha256, sha384, sha512.
 +     The corresponding crypto algorithm must be enabled in the kernel.
 +     CONFIG_MODULE_SIG_HASH selects the default algorithm used by sign-file as
 +     part of the kernel build process.
  
 -     This specifies how the kernel should deal with a module that has a
 -     signature for which the key is not known or a module that is unsigned.
 + (*) MODSECKEY=<secret-key-ring-path>
  
++<<<<<<< HEAD
 +     This indicates the whereabouts of the keyring that is the source of
 +     the secret key to be used.  The default is "./signing_key.priv".
++=======
+      If this is off (ie. "permissive"), then modules for which the key is not
+      available and modules that are unsigned are permitted, but the kernel will
+      be marked as being tainted, and the concerned modules will be marked as
+      tainted, shown with the character 'X'.
++>>>>>>> 66cc69e34e86 (Fix: module signature vs tracepoints: add new TAINT_UNSIGNED_MODULE)
  
 -     If this is on (ie. "restrictive"), only modules that have a valid
 -     signature that can be verified by a public key in the kernel's possession
 -     will be loaded.  All other modules will generate an error.
 + (*) MODPUBKEY=<public-key-ring-path>
  
 -     Irrespective of the setting here, if the module has a signature block that
 -     cannot be parsed, it will be rejected out of hand.
 +     This indicates the whereabouts of the keyring that is the source of
 +     the public key to be used.  The default is "./signing_key.x509".
  
 +The resulting module.ko file will be the signed module.
  
 - (2) "Automatically sign all modules" (CONFIG_MODULE_SIG_ALL)
 -
 -     If this is on then modules will be automatically signed during the
 -     modules_install phase of a build.  If this is off, then the modules must
 -     be signed manually using:
 -
 -	scripts/sign-file
 -
 -
 - (3) "Which hash algorithm should modules be signed with?"
 -
 -     This presents a choice of which hash algorithm the installation phase will
 -     sign the modules with:
 -
 -	CONFIG_SIG_SHA1		"Sign modules with SHA-1"
 -	CONFIG_SIG_SHA224	"Sign modules with SHA-224"
 -	CONFIG_SIG_SHA256	"Sign modules with SHA-256"
 -	CONFIG_SIG_SHA384	"Sign modules with SHA-384"
 -	CONFIG_SIG_SHA512	"Sign modules with SHA-512"
 -
 -     The algorithm selected here will also be built into the kernel (rather
 -     than being a module) so that modules signed with that algorithm can have
 -     their signatures checked without causing a dependency loop.
 -
 -
 -=======================
 -GENERATING SIGNING KEYS
 -=======================
 -
 -Cryptographic keypairs are required to generate and check signatures.  A
 -private key is used to generate a signature and the corresponding public key is
 -used to check it.  The private key is only needed during the build, after which
 -it can be deleted or stored securely.  The public key gets built into the
 -kernel so that it can be used to check the signatures as the modules are
 -loaded.
 -
 -Under normal conditions, the kernel build will automatically generate a new
 -keypair using openssl if one does not exist in the files:
 -
 -	signing_key.priv
 -	signing_key.x509
 -
 -during the building of vmlinux (the public part of the key needs to be built
 -into vmlinux) using parameters in the:
 -
 -	x509.genkey
 -
 -file (which is also generated if it does not already exist).
 -
 -It is strongly recommended that you provide your own x509.genkey file.
 -
 -Most notably, in the x509.genkey file, the req_distinguished_name section
 -should be altered from the default:
 -
 -	[ req_distinguished_name ]
 -	O = Magrathea
 -	CN = Glacier signing key
 -	emailAddress = slartibartfast@magrathea.h2g2
 -
 -The generated RSA key size can also be set with:
 -
 -	[ req ]
 -	default_bits = 4096
 -
 -
 -It is also possible to manually generate the key private/public files using the
 -x509.genkey key generation configuration file in the root node of the Linux
 -kernel sources tree and the openssl command.  The following is an example to
 -generate the public/private key files:
 -
 -	openssl req -new -nodes -utf8 -sha256 -days 36500 -batch -x509 \
 -	   -config x509.genkey -outform DER -out signing_key.x509 \
 -	   -keyout signing_key.priv
 -
 -
 -=========================
 -PUBLIC KEYS IN THE KERNEL
 -=========================
 -
 -The kernel contains a ring of public keys that can be viewed by root.  They're
 -in a keyring called ".system_keyring" that can be seen by:
 -
 -	[root@deneb ~]# cat /proc/keys
 -	...
 -	223c7853 I------     1 perm 1f030000     0     0 keyring   .system_keyring: 1
 -	302d2d52 I------     1 perm 1f010000     0     0 asymmetri Fedora kernel signing key: d69a84e6bce3d216b979e9505b3e3ef9a7118079: X509.RSA a7118079 []
 -	...
 -
 -Beyond the public key generated specifically for module signing, any file
 -placed in the kernel source root directory or the kernel build root directory
 -whose name is suffixed with ".x509" will be assumed to be an X.509 public key
 -and will be added to the keyring.
 -
 -Further, the architecture code may take public keys from a hardware store and
 -add those in also (e.g. from the UEFI key database).
 -
 -Finally, it is possible to add additional public keys by doing:
 -
 -	keyctl padd asymmetric "" [.system_keyring-ID] <[key-file]
 -
 -e.g.:
 -
 -	keyctl padd asymmetric "" 0x223c7853 <my_public_key.x509
 -
 -Note, however, that the kernel will only permit keys to be added to
 -.system_keyring _if_ the new key's X.509 wrapper is validly signed by a key
 -that is already resident in the .system_keyring at the time the key was added.
 -
 -
 -=========================
 -MANUALLY SIGNING MODULES
 -=========================
 -
 -To manually sign a module, use the scripts/sign-file tool available in
 -the Linux kernel source tree.  The script requires 4 arguments:
 -
 -	1.  The hash algorithm (e.g., sha256)
 -	2.  The private key filename
 -	3.  The public key filename
 -	4.  The kernel module to be signed
 -
 -The following is an example to sign a kernel module:
 -
 -	scripts/sign-file sha512 kernel-signkey.priv \
 -		kernel-signkey.x509 module.ko
 -
 -The hash algorithm used does not have to match the one configured, but if it
 -doesn't, you should make sure that hash algorithm is either built into the
 -kernel or can be loaded without requiring itself.
 -
 -
 -============================
 -SIGNED MODULES AND STRIPPING
 -============================
 -
 -A signed module has a digital signature simply appended at the end.  The string
 -"~Module signature appended~." at the end of the module's file confirms that a
 -signature is present but it does not confirm that the signature is valid!
 -
 -Signed modules are BRITTLE as the signature is outside of the defined ELF
 -container.  Thus they MAY NOT be stripped once the signature is computed and
 -attached.  Note the entire module is the signed payload, including any and all
 -debug information present at the time of signing.
 +========================
 +STRIPPING SIGNED MODULES
 +========================
  
 +Kernel modules must be stripped before they are signed, as stripping a signed
 +module will remove the appended signature. As a result, care must be taken
 +when packaging kernel modules for distribution that initrd generation avoids
 +stripping modules which have signatures.
  
  ======================
  LOADING SIGNED MODULES
diff --cc include/linux/kernel.h
index 69701437f09a,471090093c67..000000000000
--- a/include/linux/kernel.h
+++ b/include/linux/kernel.h
@@@ -469,29 -469,7 +469,33 @@@ extern enum system_states 
  #define TAINT_CRAP			10
  #define TAINT_FIRMWARE_WORKAROUND	11
  #define TAINT_OOT_MODULE		12
++<<<<<<< HEAD
 +#define TAINT_13			13
 +#define TAINT_14			14
 +#define TAINT_15			15
 +#define TAINT_16			16
 +#define TAINT_17			17
 +#define TAINT_18			18
 +#define TAINT_19			19
 +#define TAINT_20			20
 +#define TAINT_21			21
 +#define TAINT_22			22
 +#define TAINT_23			23
 +#define TAINT_24			24
 +#define TAINT_25			25
 +#define TAINT_26			26
 +#define TAINT_27			27
 +/* Reserving bits for vendor specific uses */
 +#define TAINT_HARDWARE_UNSUPPORTED	28
 +#define TAINT_TECH_PREVIEW		29
 +/* Bits 30 - 31 are reserved for Red Hat use only */
 +#define TAINT_RESERVED30		30
 +#define TAINT_RESERVED31		31
 +
 +
++=======
+ #define TAINT_UNSIGNED_MODULE		13
++>>>>>>> 66cc69e34e86 (Fix: module signature vs tracepoints: add new TAINT_UNSIGNED_MODULE)
  
  extern const char hex_asc[];
  #define hex_asc_lo(x)	hex_asc[((x) & 0x0f)]
diff --cc kernel/module.c
index 1960a3030875,c1acb0c5b637..000000000000
--- a/kernel/module.c
+++ b/kernel/module.c
@@@ -3332,11 -3213,10 +3334,18 @@@ static int load_module(struct load_inf
  #ifdef CONFIG_MODULE_SIG
  	mod->sig_ok = info->sig_ok;
  	if (!mod->sig_ok) {
++<<<<<<< HEAD
 +		printk_once(KERN_NOTICE
 +			    "%s: module verification failed: signature and/or"
 +			    " required key missing - tainting kernel\n",
 +			    mod->name);
 +		add_taint_module(mod, TAINT_FORCED_MODULE, LOCKDEP_STILL_OK);
++=======
+ 		pr_notice_once("%s: module verification failed: signature "
+ 			       "and/or  required key missing - tainting "
+ 			       "kernel\n", mod->name);
+ 		add_taint_module(mod, TAINT_UNSIGNED_MODULE, LOCKDEP_STILL_OK);
++>>>>>>> 66cc69e34e86 (Fix: module signature vs tracepoints: add new TAINT_UNSIGNED_MODULE)
  	}
  #endif
  
diff --cc kernel/panic.c
index 68447f710f29,0e25fe10871e..000000000000
--- a/kernel/panic.c
+++ b/kernel/panic.c
@@@ -206,23 -210,7 +206,27 @@@ static const struct tnt tnts[] = 
  	{ TAINT_CRAP,			'C', ' ' },
  	{ TAINT_FIRMWARE_WORKAROUND,	'I', ' ' },
  	{ TAINT_OOT_MODULE,		'O', ' ' },
++<<<<<<< HEAD
 +	{ TAINT_14,			'?', '-' },
 +	{ TAINT_15,			'?', '-' },
 +	{ TAINT_16,			'?', '-' },
 +	{ TAINT_17,			'?', '-' },
 +	{ TAINT_18,			'?', '-' },
 +	{ TAINT_19,			'?', '-' },
 +	{ TAINT_20,			'?', '-' },
 +	{ TAINT_21,			'?', '-' },
 +	{ TAINT_22,			'?', '-' },
 +	{ TAINT_23,			'?', '-' },
 +	{ TAINT_24,			'?', '-' },
 +	{ TAINT_25,			'?', '-' },
 +	{ TAINT_26,			'?', '-' },
 +	{ TAINT_27,			'?', '-' },
 +	{ TAINT_HARDWARE_UNSUPPORTED,	'H', ' ' },
 +	{ TAINT_TECH_PREVIEW,		'T', ' ' },
 +
++=======
+ 	{ TAINT_UNSIGNED_MODULE,	'X', ' ' },
++>>>>>>> 66cc69e34e86 (Fix: module signature vs tracepoints: add new TAINT_UNSIGNED_MODULE)
  };
  
  /**
diff --cc kernel/tracepoint.c
index 29f26540e9c9,3cdbed1fbdc7..000000000000
--- a/kernel/tracepoint.c
+++ b/kernel/tracepoint.c
@@@ -631,6 -631,12 +631,15 @@@ void tracepoint_iter_reset(struct trace
  EXPORT_SYMBOL_GPL(tracepoint_iter_reset);
  
  #ifdef CONFIG_MODULES
++<<<<<<< HEAD
++=======
+ bool trace_module_has_bad_taint(struct module *mod)
+ {
+ 	return mod->taints & ~((1 << TAINT_OOT_MODULE) | (1 << TAINT_CRAP) |
+ 			       (1 << TAINT_UNSIGNED_MODULE));
+ }
+ 
++>>>>>>> 66cc69e34e86 (Fix: module signature vs tracepoints: add new TAINT_UNSIGNED_MODULE)
  static int tracepoint_module_coming(struct module *mod)
  {
  	struct tp_module *tp_mod, *iter;
@@@ -639,9 -645,9 +648,9 @@@
  	/*
  	 * We skip modules that taint the kernel, especially those with different
  	 * module headers (for forced load), to make sure we don't cause a crash.
- 	 * Staging and out-of-tree GPL modules are fine.
+ 	 * Staging, out-of-tree, and unsigned GPL modules are fine.
  	 */
 -	if (trace_module_has_bad_taint(mod))
 +	if (mod->taints & ~((1 << TAINT_OOT_MODULE) | (1 << TAINT_CRAP)))
  		return 0;
  	mutex_lock(&tracepoints_mutex);
  	tp_mod = kmalloc(sizeof(struct tp_module), GFP_KERNEL);
diff --git a/Documentation/ABI/testing/sysfs-module b/Documentation/ABI/testing/sysfs-module
index 47064c2b1f79..b9a29cdbaccb 100644
--- a/Documentation/ABI/testing/sysfs-module
+++ b/Documentation/ABI/testing/sysfs-module
@@ -49,3 +49,4 @@ Description:	Module taint flags:
 			O - out-of-tree module
 			F - force-loaded module
 			C - staging driver module
+			X - unsigned module
* Unmerged path Documentation/module-signing.txt
diff --git a/Documentation/oops-tracing.txt b/Documentation/oops-tracing.txt
index 13032c0140d4..879abe289523 100644
--- a/Documentation/oops-tracing.txt
+++ b/Documentation/oops-tracing.txt
@@ -265,6 +265,9 @@ characters, each representing a particular tainted value.
 
  13: 'O' if an externally-built ("out-of-tree") module has been loaded.
 
+ 14: 'X' if an unsigned module has been loaded in a kernel supporting
+     module signature.
+
 The primary reason for the 'Tainted: ' string is to tell kernel
 debuggers if this is a clean kernel or if anything unusual has
 occurred.  Tainting is permanent: even if an offending module is
diff --git a/Documentation/sysctl/kernel.txt b/Documentation/sysctl/kernel.txt
index 04a405ea32da..e40a8a9ad5e5 100644
--- a/Documentation/sysctl/kernel.txt
+++ b/Documentation/sysctl/kernel.txt
@@ -768,6 +768,8 @@ can be ORed together:
 1024 - A module from drivers/staging was loaded.
 2048 - The system is working around a severe firmware bug.
 4096 - An out-of-tree module has been loaded.
+8192 - An unsigned module has been loaded in a kernel supporting module
+       signature.
 
 ==============================================================
 
* Unmerged path include/linux/kernel.h
diff --git a/include/trace/events/module.h b/include/trace/events/module.h
index 161932737416..11fd51b413de 100644
--- a/include/trace/events/module.h
+++ b/include/trace/events/module.h
@@ -22,8 +22,10 @@ struct module;
 
 #define show_module_flags(flags) __print_flags(flags, "",	\
 	{ (1UL << TAINT_PROPRIETARY_MODULE),	"P" },		\
+	{ (1UL << TAINT_OOT_MODULE),		"O" },		\
 	{ (1UL << TAINT_FORCED_MODULE),		"F" },		\
-	{ (1UL << TAINT_CRAP),			"C" })
+	{ (1UL << TAINT_CRAP),			"C" },		\
+	{ (1UL << TAINT_UNSIGNED_MODULE),	"X" })
 
 TRACE_EVENT(module_load,
 
* Unmerged path kernel/module.c
* Unmerged path kernel/panic.c
* Unmerged path kernel/tracepoint.c
