ovl: multi-layer lookup

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Miklos Szeredi <mszeredi@suse.cz>
commit 3d3c6b89399a1b5e8a59ffbb8cb2a7797a9ef154
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/3d3c6b89.failed

Look up dentry in all relevant layers.

	Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
(cherry picked from commit 3d3c6b89399a1b5e8a59ffbb8cb2a7797a9ef154)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/super.c
diff --cc fs/overlayfs/super.c
index e7867fa3c59f,f72b82fdc1e6..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -320,56 -333,102 +320,138 @@@ struct dentry *ovl_lookup(struct inode 
  			  unsigned int flags)
  {
  	struct ovl_entry *oe;
++<<<<<<< HEAD
 +	struct dentry *upperdir;
 +	struct dentry *lowerdir;
 +	struct dentry *upperdentry = NULL;
 +	struct dentry *lowerdentry = NULL;
++=======
+ 	struct ovl_entry *poe = dentry->d_parent->d_fsdata;
+ 	struct path *stack = NULL;
+ 	struct dentry *upperdir, *upperdentry = NULL;
+ 	unsigned int ctr = 0;
++>>>>>>> 3d3c6b89399a (ovl: multi-layer lookup)
  	struct inode *inode = NULL;
+ 	bool upperopaque = false;
+ 	struct dentry *this, *prev = NULL;
+ 	unsigned int i;
  	int err;
  
++<<<<<<< HEAD
 +	err = -ENOMEM;
 +	oe = ovl_alloc_entry();
 +	if (!oe)
 +		goto out;
 +
 +	upperdir = ovl_dentry_upper(dentry->d_parent);
 +	lowerdir = ovl_dentry_lower(dentry->d_parent);
 +
++=======
+ 	upperdir = ovl_upperdentry_dereference(poe);
++>>>>>>> 3d3c6b89399a (ovl: multi-layer lookup)
  	if (upperdir) {
- 		upperdentry = ovl_lookup_real(upperdir, &dentry->d_name);
- 		err = PTR_ERR(upperdentry);
- 		if (IS_ERR(upperdentry))
- 			goto out_put_dir;
+ 		this = ovl_lookup_real(upperdir, &dentry->d_name);
+ 		err = PTR_ERR(this);
+ 		if (IS_ERR(this))
+ 			goto out;
  
++<<<<<<< HEAD
 +		if (lowerdir && upperdentry) {
 +			if (ovl_is_whiteout(upperdentry)) {
 +				dput(upperdentry);
 +				upperdentry = NULL;
 +				oe->opaque = true;
 +			} else if (ovl_is_opaquedir(upperdentry)) {
 +				oe->opaque = true;
 +			}
 +		}
 +	}
 +	if (lowerdir && !oe->opaque) {
 +		lowerdentry = ovl_lookup_real(lowerdir, &dentry->d_name);
 +		err = PTR_ERR(lowerdentry);
 +		if (IS_ERR(lowerdentry))
 +			goto out_dput_upper;
++=======
+ 		/*
+ 		 * If this is not the lowermost layer, check whiteout and opaque
+ 		 * directory.
+ 		 */
+ 		if (poe->numlower && this) {
+ 			if (ovl_is_whiteout(this)) {
+ 				dput(this);
+ 				this = NULL;
+ 				upperopaque = true;
+ 			} else if (ovl_is_opaquedir(this)) {
+ 				upperopaque = true;
+ 			}
+ 		}
+ 		upperdentry = prev = this;
++>>>>>>> 3d3c6b89399a (ovl: multi-layer lookup)
  	}
  
- 	if (lowerdentry && upperdentry &&
- 	    (!S_ISDIR(upperdentry->d_inode->i_mode) ||
- 	     !S_ISDIR(lowerdentry->d_inode->i_mode))) {
- 		dput(lowerdentry);
- 		lowerdentry = NULL;
- 		oe->opaque = true;
+ 	if (!upperopaque && poe->numlower) {
+ 		err = -ENOMEM;
+ 		stack = kcalloc(poe->numlower, sizeof(struct path), GFP_KERNEL);
+ 		if (!stack)
+ 			goto out_put_upper;
+ 	}
+ 
+ 	for (i = 0; !upperopaque && i < poe->numlower; i++) {
+ 		bool opaque = false;
+ 		struct path lowerpath = poe->lowerstack[i];
+ 
+ 		opaque = false;
+ 		this = ovl_lookup_real(lowerpath.dentry, &dentry->d_name);
+ 		err = PTR_ERR(this);
+ 		if (IS_ERR(this))
+ 			goto out_put;
+ 		if (!this)
+ 			continue;
+ 
+ 		/*
+ 		 * If this is not the lowermost layer, check whiteout and opaque
+ 		 * directory.
+ 		 */
+ 		if (i < poe->numlower - 1) {
+ 			if (ovl_is_whiteout(this)) {
+ 				dput(this);
+ 				break;
+ 			} else if (ovl_is_opaquedir(this)) {
+ 				opaque = true;
+ 			}
+ 		}
+ 		/*
+ 		 * If this is a non-directory then stop here.
+ 		 *
+ 		 * FIXME: check for opaqueness maybe better done in remove code.
+ 		 */
+ 		if (!S_ISDIR(this->d_inode->i_mode)) {
+ 			opaque = true;
+ 		} else if (prev && (!S_ISDIR(prev->d_inode->i_mode) ||
+ 				    !S_ISDIR(this->d_inode->i_mode))) {
+ 			if (prev == upperdentry)
+ 				upperopaque = true;
+ 			dput(this);
+ 			break;
+ 		}
+ 		stack[ctr].dentry = this;
+ 		stack[ctr].mnt = lowerpath.mnt;
+ 		ctr++;
+ 		prev = this;
+ 		if (opaque)
+ 			break;
  	}
  
- 	if (lowerdentry || upperdentry) {
+ 	oe = ovl_alloc_entry(ctr);
+ 	err = -ENOMEM;
+ 	if (!oe)
+ 		goto out_put;
+ 
+ 	if (upperdentry || ctr) {
  		struct dentry *realdentry;
  
- 		realdentry = upperdentry ? upperdentry : lowerdentry;
+ 		realdentry = upperdentry ? upperdentry : stack[0].dentry;
+ 
  		err = -ENOMEM;
  		inode = ovl_new_inode(dentry->d_sb, realdentry->d_inode->i_mode,
  				      oe);
@@@ -378,9 -437,10 +460,15 @@@
  		ovl_copyattr(realdentry->d_inode, inode);
  	}
  
+ 	oe->opaque = upperopaque;
  	oe->__upperdentry = upperdentry;
++<<<<<<< HEAD
 +	oe->lowerdentry = lowerdentry;
 +
++=======
+ 	memcpy(oe->lowerstack, stack, sizeof(struct path) * ctr);
+ 	kfree(stack);
++>>>>>>> 3d3c6b89399a (ovl: multi-layer lookup)
  	dentry->d_fsdata = oe;
  	d_add(dentry, inode);
  
* Unmerged path fs/overlayfs/super.c
