ipv6: introduce ipv6_make_skb

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Vlad Yasevich <vyasevich@gmail.com>
commit 6422398c2ab09268a55112f98cbf96bbf0184328
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/6422398c.failed

This commit is very similar to
commit 1c32c5ad6fac8cee1a77449f5abf211e911ff830
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Tue Mar 1 02:36:47 2011 +0000

    inet: Add ip_make_skb and ip_finish_skb

It adds IPv6 version of the helpers ip6_make_skb and ip6_finish_skb.

The job of ip6_make_skb is to collect messages into an ipv6 packet
and poplulate ipv6 eader.  The job of ip6_finish_skb is to transmit
the generated skb.  Together they replicated the job of
ip6_push_pending_frames() while also provide the capability to be
called independently.  This will be needed to add lockless UDP sendmsg
support.

	Signed-off-by: Vladislav Yasevich <vyasevic@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6422398c2ab09268a55112f98cbf96bbf0184328)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ipv6.h
#	net/ipv6/ip6_output.c
diff --cc include/net/ipv6.h
index 36716e7121cb,8027ca53e31f..000000000000
--- a/include/net/ipv6.h
+++ b/include/net/ipv6.h
@@@ -687,44 -772,48 +687,73 @@@ extern int			ip6_rcv_finish(struct sk_b
  /*
   *	upper-layer output functions
   */
 -int ip6_xmit(struct sock *sk, struct sk_buff *skb, struct flowi6 *fl6,
 -	     struct ipv6_txoptions *opt, int tclass);
 -
 -int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr);
 -
 -int ip6_append_data(struct sock *sk,
 -		    int getfrag(void *from, char *to, int offset, int len,
 -				int odd, struct sk_buff *skb),
 -		    void *from, int length, int transhdrlen, int hlimit,
 -		    int tclass, struct ipv6_txoptions *opt, struct flowi6 *fl6,
 -		    struct rt6_info *rt, unsigned int flags, int dontfrag);
 -
 -int ip6_push_pending_frames(struct sock *sk);
 -
 -void ip6_flush_pending_frames(struct sock *sk);
 -
 +extern int			ip6_xmit(struct sock *sk,
 +					 struct sk_buff *skb,
 +					 struct flowi6 *fl6,
 +					 struct ipv6_txoptions *opt,
 +					 int tclass);
 +
 +extern int			ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr);
 +
 +extern int			ip6_append_data(struct sock *sk,
 +						int getfrag(void *from, char *to, int offset, int len, int odd, struct sk_buff *skb),
 +		    				void *from,
 +						int length,
 +						int transhdrlen,
 +		      				int hlimit,
 +		      				int tclass,
 +						struct ipv6_txoptions *opt,
 +						struct flowi6 *fl6,
 +						struct rt6_info *rt,
 +						unsigned int flags,
 +						int dontfrag);
 +
 +extern int			ip6_push_pending_frames(struct sock *sk);
 +
 +extern void			ip6_flush_pending_frames(struct sock *sk);
 +
++<<<<<<< HEAD
 +extern int			ip6_dst_lookup(struct sock *sk,
 +					       struct dst_entry **dst,
 +					       struct flowi6 *fl6);
 +extern struct dst_entry *	ip6_dst_lookup_flow(struct sock *sk,
 +						    struct flowi6 *fl6,
 +						    const struct in6_addr *final_dst,
 +						    bool can_sleep);
 +extern struct dst_entry *	ip6_sk_dst_lookup_flow(struct sock *sk,
 +						       struct flowi6 *fl6,
 +						       const struct in6_addr *final_dst,
 +						       bool can_sleep);
 +extern struct dst_entry *	ip6_blackhole_route(struct net *net,
 +						    struct dst_entry *orig_dst);
++=======
+ int ip6_send_skb(struct sk_buff *skb);
+ 
+ struct sk_buff *__ip6_make_skb(struct sock *sk, struct sk_buff_head *queue,
+ 			       struct inet_cork_full *cork,
+ 			       struct inet6_cork *v6_cork);
+ struct sk_buff *ip6_make_skb(struct sock *sk,
+ 			     int getfrag(void *from, char *to, int offset,
+ 					 int len, int odd, struct sk_buff *skb),
+ 			     void *from, int length, int transhdrlen,
+ 			     int hlimit, int tclass, struct ipv6_txoptions *opt,
+ 			     struct flowi6 *fl6, struct rt6_info *rt,
+ 			     unsigned int flags, int dontfrag);
+ 
+ static inline struct sk_buff *ip6_finish_skb(struct sock *sk)
+ {
+ 	return __ip6_make_skb(sk, &sk->sk_write_queue, &inet_sk(sk)->cork,
+ 			      &inet6_sk(sk)->cork);
+ }
+ 
+ int ip6_dst_lookup(struct sock *sk, struct dst_entry **dst, struct flowi6 *fl6);
+ struct dst_entry *ip6_dst_lookup_flow(struct sock *sk, struct flowi6 *fl6,
+ 				      const struct in6_addr *final_dst);
+ struct dst_entry *ip6_sk_dst_lookup_flow(struct sock *sk, struct flowi6 *fl6,
+ 					 const struct in6_addr *final_dst);
+ struct dst_entry *ip6_blackhole_route(struct net *net,
+ 				      struct dst_entry *orig_dst);
++>>>>>>> 6422398c2ab0 (ipv6: introduce ipv6_make_skb)
  
  /*
   *	skb processing functions
diff --cc net/ipv6/ip6_output.c
index 524b4ad02d70,b89d3c27dac7..000000000000
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@@ -1522,14 -1575,13 +1525,17 @@@ struct sk_buff *__ip6_make_skb(struct s
  	struct ipv6_pinfo *np = inet6_sk(sk);
  	struct net *net = sock_net(sk);
  	struct ipv6hdr *hdr;
- 	struct ipv6_txoptions *opt = np->cork.opt;
- 	struct rt6_info *rt = (struct rt6_info *)inet->cork.base.dst;
- 	struct flowi6 *fl6 = &inet->cork.fl.u.ip6;
+ 	struct ipv6_txoptions *opt = v6_cork->opt;
+ 	struct rt6_info *rt = (struct rt6_info *)cork->base.dst;
+ 	struct flowi6 *fl6 = &cork->fl.u.ip6;
  	unsigned char proto = fl6->flowi6_proto;
- 	int err = 0;
  
++<<<<<<< HEAD
 +	if ((skb = __skb_dequeue(&sk->sk_write_queue)) == NULL)
++=======
+ 	skb = __skb_dequeue(queue);
+ 	if (skb == NULL)
++>>>>>>> 6422398c2ab0 (ipv6: introduce ipv6_make_skb)
  		goto out;
  	tail_skb = &(skb_shinfo(skb)->frag_list);
  
@@@ -1561,8 -1613,10 +1567,15 @@@
  	skb_reset_network_header(skb);
  	hdr = ipv6_hdr(skb);
  
++<<<<<<< HEAD
 +	ip6_flow_hdr(hdr, np->cork.tclass, fl6->flowlabel);
 +	hdr->hop_limit = np->cork.hop_limit;
++=======
+ 	ip6_flow_hdr(hdr, v6_cork->tclass,
+ 		     ip6_make_flowlabel(net, skb, fl6->flowlabel,
+ 					np->autoflowlabel));
+ 	hdr->hop_limit = v6_cork->hop_limit;
++>>>>>>> 6422398c2ab0 (ipv6: introduce ipv6_make_skb)
  	hdr->nexthdr = proto;
  	hdr->saddr = fl6->saddr;
  	hdr->daddr = *final_dst;
@@@ -1575,10 -1629,21 +1588,21 @@@
  	if (proto == IPPROTO_ICMPV6) {
  		struct inet6_dev *idev = ip6_dst_idev(skb_dst(skb));
  
 -		ICMP6MSGOUT_INC_STATS(net, idev, icmp6_hdr(skb)->icmp6_type);
 -		ICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTMSGS);
 +		ICMP6MSGOUT_INC_STATS_BH(net, idev, icmp6_hdr(skb)->icmp6_type);
 +		ICMP6_INC_STATS_BH(net, idev, ICMP6_MIB_OUTMSGS);
  	}
  
+ 	ip6_cork_release(cork, v6_cork);
+ out:
+ 	return skb;
+ }
+ 
+ int ip6_send_skb(struct sk_buff *skb)
+ {
+ 	struct net *net = sock_net(skb->sk);
+ 	struct rt6_info *rt = (struct rt6_info *)skb_dst(skb);
+ 	int err;
+ 
  	err = ip6_local_out(skb);
  	if (err) {
  		if (err > 0)
@@@ -1596,7 -1668,10 +1627,14 @@@ int ip6_push_pending_frames(struct soc
  }
  EXPORT_SYMBOL_GPL(ip6_push_pending_frames);
  
++<<<<<<< HEAD
 +void ip6_flush_pending_frames(struct sock *sk)
++=======
+ static void __ip6_flush_pending_frames(struct sock *sk,
+ 				       struct sk_buff_head *queue,
+ 				       struct inet_cork_full *cork,
+ 				       struct inet6_cork *v6_cork)
++>>>>>>> 6422398c2ab0 (ipv6: introduce ipv6_make_skb)
  {
  	struct sk_buff *skb;
  
@@@ -1607,6 -1682,55 +1645,58 @@@
  		kfree_skb(skb);
  	}
  
- 	ip6_cork_release(&inet_sk(sk)->cork, &inet6_sk(sk)->cork);
+ 	ip6_cork_release(cork, v6_cork);
  }
++<<<<<<< HEAD
++=======
+ 
+ void ip6_flush_pending_frames(struct sock *sk)
+ {
+ 	__ip6_flush_pending_frames(sk, &sk->sk_write_queue,
+ 				   &inet_sk(sk)->cork, &inet6_sk(sk)->cork);
+ }
++>>>>>>> 6422398c2ab0 (ipv6: introduce ipv6_make_skb)
  EXPORT_SYMBOL_GPL(ip6_flush_pending_frames);
+ 
+ struct sk_buff *ip6_make_skb(struct sock *sk,
+ 			     int getfrag(void *from, char *to, int offset,
+ 					 int len, int odd, struct sk_buff *skb),
+ 			     void *from, int length, int transhdrlen,
+ 			     int hlimit, int tclass,
+ 			     struct ipv6_txoptions *opt, struct flowi6 *fl6,
+ 			     struct rt6_info *rt, unsigned int flags,
+ 			     int dontfrag)
+ {
+ 	struct inet_cork_full cork;
+ 	struct inet6_cork v6_cork;
+ 	struct sk_buff_head queue;
+ 	int exthdrlen = (opt ? opt->opt_flen : 0);
+ 	int err;
+ 
+ 	if (flags & MSG_PROBE)
+ 		return NULL;
+ 
+ 	__skb_queue_head_init(&queue);
+ 
+ 	cork.base.flags = 0;
+ 	cork.base.addr = 0;
+ 	cork.base.opt = NULL;
+ 	v6_cork.opt = NULL;
+ 	err = ip6_setup_cork(sk, &cork, &v6_cork, hlimit, tclass, opt, rt, fl6);
+ 	if (err)
+ 		return ERR_PTR(err);
+ 
+ 	if (dontfrag < 0)
+ 		dontfrag = inet6_sk(sk)->dontfrag;
+ 
+ 	err = __ip6_append_data(sk, fl6, &queue, &cork.base, &v6_cork,
+ 				&current->task_frag, getfrag, from,
+ 				length + exthdrlen, transhdrlen + exthdrlen,
+ 				flags, dontfrag);
+ 	if (err) {
+ 		__ip6_flush_pending_frames(sk, &queue, &cork, &v6_cork);
+ 		return ERR_PTR(err);
+ 	}
+ 
+ 	return __ip6_make_skb(sk, &queue, &cork, &v6_cork);
+ }
* Unmerged path include/net/ipv6.h
* Unmerged path net/ipv6/ip6_output.c
