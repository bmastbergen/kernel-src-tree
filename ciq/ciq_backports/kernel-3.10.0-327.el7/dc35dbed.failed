fib_trie: Add tnode struct as a container for fields not needed in key_vector

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Alexander Duyck <alexander.h.duyck@redhat.com>
commit dc35dbeda3e00a05723784078a233c2531d34810
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/dc35dbed.failed

This change pulls the fields not explicitly needed in the key_vector and
placed them in the new tnode structure.  By doing this we will eventually
be able to reduce the key_vector down to 16 bytes on 64 bit systems, and
12 bytes on 32 bit systems.

	Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit dc35dbeda3e00a05723784078a233c2531d34810)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/fib_trie.c
diff --cc net/ipv4/fib_trie.c
index 8be89b1a8b93,3a062370fc32..000000000000
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@@ -112,13 -111,12 +112,22 @@@ struct tnode 
  	};
  };
  
++<<<<<<< HEAD
 +struct leaf_info {
 +	struct hlist_node hlist;
 +	int plen;
 +	u32 mask_plen; /* ntohl(inet_make_mask(plen)) */
 +	struct list_head falh;
 +	struct rcu_head rcu;
 +};
++=======
+ struct tnode {
+ 	struct key_vector kv[1];
+ };
+ 
+ #define TNODE_SIZE(n)	offsetof(struct tnode, kv[0].tnode[n])
+ #define LEAF_SIZE	TNODE_SIZE(1)
++>>>>>>> dc35dbeda3e0 (fib_trie: Add tnode struct as a container for fields not needed in key_vector)
  
  #ifdef CONFIG_IP_FIB_TRIE_STATS
  struct trie_use_stats {
@@@ -290,13 -292,17 +299,17 @@@ static void __node_free_rcu(struct rcu_
  
  #define node_free(n) call_rcu(&n->rcu, __node_free_rcu)
  
++<<<<<<< HEAD
 +static inline void free_leaf_info(struct leaf_info *leaf)
++=======
+ static struct tnode *tnode_alloc(int bits)
++>>>>>>> dc35dbeda3e0 (fib_trie: Add tnode struct as a container for fields not needed in key_vector)
  {
 -	size_t size;
 -
 -	/* verify bits is within bounds */
 -	if (bits > TNODE_VMALLOC_MAX)
 -		return NULL;
 -
 -	/* determine size and verify it is non-zero and didn't overflow */
 -	size = TNODE_SIZE(1ul << bits);
 +	kfree_rcu(leaf, rcu);
 +}
  
 +static struct tnode *tnode_alloc(size_t size)
 +{
  	if (size <= PAGE_SIZE)
  		return kzalloc(size, GFP_KERNEL);
  	else
@@@ -313,60 -319,52 +326,103 @@@ static inline void empty_child_dec(stru
  	n->empty_children-- ? : n->full_children--;
  }
  
 -static struct key_vector *leaf_new(t_key key, struct fib_alias *fa)
 +static struct tnode *leaf_new(t_key key)
  {
++<<<<<<< HEAD
 +	struct tnode *l = kmem_cache_alloc(trie_leaf_kmem, GFP_KERNEL);
 +	if (l) {
 +		l->parent = NULL;
 +		/* set key and pos to reflect full key value
 +		 * any trailing zeros in the key should be ignored
 +		 * as the nodes are searched
 +		 */
 +		l->key = key;
 +		l->slen = 0;
 +		l->pos = 0;
 +		/* set bits to 0 indicating we are not a tnode */
 +		l->bits = 0;
 +
 +		INIT_HLIST_HEAD(&l->list);
 +	}
++=======
+ 	struct tnode *kv = kmem_cache_alloc(trie_leaf_kmem, GFP_KERNEL);
+ 	struct key_vector *l = kv->kv;
+ 
+ 	if (!kv)
+ 		return NULL;
+ 
+ 	/* initialize key vector */
+ 	l->key = key;
+ 	l->pos = 0;
+ 	l->bits = 0;
+ 	l->slen = fa->fa_slen;
+ 
+ 	/* link leaf to fib alias */
+ 	INIT_HLIST_HEAD(&l->leaf);
+ 	hlist_add_head(&fa->fa_list, &l->leaf);
+ 
++>>>>>>> dc35dbeda3e0 (fib_trie: Add tnode struct as a container for fields not needed in key_vector)
  	return l;
  }
  
 -static struct key_vector *tnode_new(t_key key, int pos, int bits)
 +static struct leaf_info *leaf_info_new(int plen)
 +{
++<<<<<<< HEAD
 +	struct leaf_info *li = kmalloc(sizeof(struct leaf_info),  GFP_KERNEL);
 +	if (li) {
 +		li->plen = plen;
 +		li->mask_plen = ntohl(inet_make_mask(plen));
 +		INIT_LIST_HEAD(&li->falh);
 +	}
 +	return li;
 +}
 +
 +static struct tnode *tnode_new(t_key key, int pos, int bits)
  {
 +	size_t sz = offsetof(struct tnode, child[1ul << bits]);
 +	struct tnode *tn = tnode_alloc(sz);
++=======
+ 	struct tnode *tnode = tnode_alloc(bits);
++>>>>>>> dc35dbeda3e0 (fib_trie: Add tnode struct as a container for fields not needed in key_vector)
  	unsigned int shift = pos + bits;
+ 	struct key_vector *tn = tnode->kv;
  
  	/* verify bits and pos their msb bits clear and values are valid */
  	BUG_ON(!bits || (shift > KEYLENGTH));
  
++<<<<<<< HEAD
 +	if (tn) {
 +		tn->parent = NULL;
 +		tn->slen = pos;
 +		tn->pos = pos;
 +		tn->bits = bits;
 +		tn->key = (shift < KEYLENGTH) ? (key >> shift) << shift : 0;
 +		if (bits == KEYLENGTH)
 +			tn->full_children = 1;
 +		else
 +			tn->empty_children = 1ul << bits;
 +	}
 +
 +	pr_debug("AT %p s=%zu %zu\n", tn, sizeof(struct tnode),
 +		 sizeof(struct tnode *) << bits);
++=======
+ 	pr_debug("AT %p s=%zu %zu\n", tnode, TNODE_SIZE(0),
+ 		 sizeof(struct key_vector *) << bits);
+ 
+ 	if (!tnode)
+ 		return NULL;
+ 
+ 	if (bits == KEYLENGTH)
+ 		tn->full_children = 1;
+ 	else
+ 		tn->empty_children = 1ul << bits;
+ 
+ 	tn->key = (shift < KEYLENGTH) ? (key >> shift) << shift : 0;
+ 	tn->pos = pos;
+ 	tn->bits = bits;
+ 	tn->slen = pos;
+ 
++>>>>>>> dc35dbeda3e0 (fib_trie: Add tnode struct as a container for fields not needed in key_vector)
  	return tn;
  }
  
* Unmerged path net/ipv4/fib_trie.c
