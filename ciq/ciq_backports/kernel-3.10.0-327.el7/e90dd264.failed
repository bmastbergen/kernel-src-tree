ixgbe: Make return values more direct

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Mark Rustad <mark.d.rustad@intel.com>
commit e90dd264566405e2f1bbb8595a4b5612281f6315
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/e90dd264.failed

Make return values more direct, eliminating some gotos and
otherwise unneeded conditionals. This also eliminates some
local variables. Also a few minor cleanups in affected code
so checkpatch won't complain.

	Signed-off-by: Mark Rustad <mark.d.rustad@intel.com>
	Tested-by: Phil Schmitt <phillip.j.schmitt@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit e90dd264566405e2f1bbb8595a4b5612281f6315)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c
#	drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c
#	drivers/net/ethernet/intel/ixgbe/ixgbe_common.c
#	drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c
#	drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c
#	drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c
index 7481c33b25ed,c5c97b483d7c..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c
@@@ -156,12 -154,10 +154,19 @@@ static s32 ixgbe_init_phy_ops_82598(str
  
  		/* Check to see if SFP+ module is supported */
  		ret_val = ixgbe_get_sfp_init_sequence_offsets(hw,
++<<<<<<< HEAD
 +		                                            &list_offset,
 +		                                            &data_offset);
 +		if (ret_val != 0) {
 +			ret_val = IXGBE_ERR_SFP_NOT_SUPPORTED;
 +			goto out;
 +		}
++=======
+ 							    &list_offset,
+ 							    &data_offset);
+ 		if (ret_val)
+ 			return IXGBE_ERR_SFP_NOT_SUPPORTED;
++>>>>>>> e90dd2645664 (ixgbe: Make return values more direct)
  		break;
  	default:
  		break;
@@@ -219,10 -216,9 +225,9 @@@ static s32 ixgbe_start_hw_82598(struct 
   *  Determines the link capabilities by reading the AUTOC register.
   **/
  static s32 ixgbe_get_link_capabilities_82598(struct ixgbe_hw *hw,
 -					     ixgbe_link_speed *speed,
 -					     bool *autoneg)
 +                                             ixgbe_link_speed *speed,
 +                                             bool *autoneg)
  {
- 	s32 status = 0;
  	u32 autoc = 0;
  
  	/*
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c
index 5420e5d32a9e,cf55a0df877b..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c
@@@ -132,17 -132,15 +132,29 @@@ static s32 ixgbe_setup_sfp_modules_8259
  		hw->phy.ops.reset = NULL;
  
  		ret_val = ixgbe_get_sfp_init_sequence_offsets(hw, &list_offset,
++<<<<<<< HEAD
 +		                                              &data_offset);
 +		if (ret_val != 0)
 +			goto setup_sfp_out;
 +
 +		/* PHY config will finish before releasing the semaphore */
 +		ret_val = hw->mac.ops.acquire_swfw_sync(hw,
 +		                                        IXGBE_GSSR_MAC_CSR_SM);
 +		if (ret_val != 0) {
 +			ret_val = IXGBE_ERR_SWFW_SYNC;
 +			goto setup_sfp_out;
 +		}
++=======
+ 							      &data_offset);
+ 		if (ret_val)
+ 			return ret_val;
+ 
+ 		/* PHY config will finish before releasing the semaphore */
+ 		ret_val = hw->mac.ops.acquire_swfw_sync(hw,
+ 							IXGBE_GSSR_MAC_CSR_SM);
+ 		if (ret_val)
+ 			return IXGBE_ERR_SWFW_SYNC;
++>>>>>>> e90dd2645664 (ixgbe: Make return values more direct)
  
  		if (hw->eeprom.ops.read(hw, ++data_offset, &data_value))
  			goto setup_sfp_err;
@@@ -352,10 -348,9 +362,9 @@@ static s32 ixgbe_init_phy_ops_82599(str
   *  Determines the link capabilities by reading the AUTOC register.
   **/
  static s32 ixgbe_get_link_capabilities_82599(struct ixgbe_hw *hw,
 -					     ixgbe_link_speed *speed,
 +                                             ixgbe_link_speed *speed,
  					     bool *autoneg)
  {
- 	s32 status = 0;
  	u32 autoc = 0;
  
  	/* Determine 1G link capabilities off of SFP+ type */
@@@ -1256,9 -1240,8 +1254,8 @@@ mac_reset_top
  
  	/* Store the alternative WWNN/WWPN prefix */
  	hw->mac.ops.get_wwn_prefix(hw, &hw->mac.wwnn_prefix,
 -				       &hw->mac.wwpn_prefix);
 +	                               &hw->mac.wwpn_prefix);
  
- reset_hw_out:
  	return status;
  }
  
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_common.c
index 20d2e748678d,b5f484bf3fda..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c
@@@ -1391,10 -1336,8 +1337,15 @@@ static s32 ixgbe_get_eeprom_semaphore(s
  	}
  
  	if (i == timeout) {
++<<<<<<< HEAD
 +		hw_dbg(hw, "Driver can't access the Eeprom - SMBI Semaphore "
 +		       "not granted.\n");
 +		/*
 +		 * this release is particularly important because our attempts
++=======
+ 		hw_dbg(hw, "Driver can't access the Eeprom - SMBI Semaphore not granted.\n");
+ 		/* this release is particularly important because our attempts
++>>>>>>> e90dd2645664 (ixgbe: Make return values more direct)
  		 * above to get the semaphore may have succeeded, and if there
  		 * was a timeout, we should unconditionally clear the semaphore
  		 * bits to free the driver to make progress
@@@ -1413,41 -1357,33 +1365,45 @@@
  	}
  
  	/* Now get the semaphore between SW/FW through the SWESMBI bit */
- 	if (status == 0) {
- 		for (i = 0; i < timeout; i++) {
- 			swsm = IXGBE_READ_REG(hw, IXGBE_SWSM);
- 
- 			/* Set the SW EEPROM semaphore bit to request access */
- 			swsm |= IXGBE_SWSM_SWESMBI;
- 			IXGBE_WRITE_REG(hw, IXGBE_SWSM, swsm);
- 
- 			/*
- 			 * If we set the bit successfully then we got the
- 			 * semaphore.
- 			 */
- 			swsm = IXGBE_READ_REG(hw, IXGBE_SWSM);
- 			if (swsm & IXGBE_SWSM_SWESMBI)
- 				break;
+ 	for (i = 0; i < timeout; i++) {
+ 		swsm = IXGBE_READ_REG(hw, IXGBE_SWSM);
  
- 			usleep_range(50, 100);
- 		}
+ 		/* Set the SW EEPROM semaphore bit to request access */
+ 		swsm |= IXGBE_SWSM_SWESMBI;
+ 		IXGBE_WRITE_REG(hw, IXGBE_SWSM, swsm);
  
- 		/*
- 		 * Release semaphores and return error if SW EEPROM semaphore
- 		 * was not granted because we don't have access to the EEPROM
+ 		/* If we set the bit successfully then we got the
+ 		 * semaphore.
  		 */
++<<<<<<< HEAD
 +		if (i >= timeout) {
 +			hw_dbg(hw, "SWESMBI Software EEPROM semaphore "
 +			       "not granted.\n");
 +			ixgbe_release_eeprom_semaphore(hw);
 +			status = IXGBE_ERR_EEPROM;
 +		}
 +	} else {
 +		hw_dbg(hw, "Software semaphore SMBI between device drivers "
 +		       "not granted.\n");
++=======
+ 		swsm = IXGBE_READ_REG(hw, IXGBE_SWSM);
+ 		if (swsm & IXGBE_SWSM_SWESMBI)
+ 			break;
+ 
+ 		usleep_range(50, 100);
++>>>>>>> e90dd2645664 (ixgbe: Make return values more direct)
  	}
  
- 	return status;
+ 	/* Release semaphores and return error if SW EEPROM semaphore
+ 	 * was not granted because we don't have access to the EEPROM
+ 	 */
+ 	if (i >= timeout) {
+ 		hw_dbg(hw, "SWESMBI Software EEPROM semaphore not granted.\n");
+ 		ixgbe_release_eeprom_semaphore(hw);
+ 		return IXGBE_ERR_EEPROM;
+ 	}
+ 
+ 	return 0;
  }
  
  /**
@@@ -3561,17 -3438,16 +3500,25 @@@ static u8 ixgbe_calculate_checksum(u8 *
   *  Communicates with the manageability block.  On success return 0
   *  else return IXGBE_ERR_HOST_INTERFACE_COMMAND.
   **/
 -static s32 ixgbe_host_interface_command(struct ixgbe_hw *hw, u32 *buffer,
 -					u32 length)
 +s32 ixgbe_host_interface_command(struct ixgbe_hw *hw, u32 *buffer,
 +				 u32 length, u32 timeout,
 +				 bool return_data)
  {
 -	u32 hicr, i, bi;
 +	u32 hicr, i, bi, fwsts;
  	u32 hdr_size = sizeof(struct ixgbe_hic_hdr);
++<<<<<<< HEAD
 +	u16 buf_len, dword_len;
 +	s32 ret_val = 0;
 +
 +	if (length == 0 || length > IXGBE_HI_MAX_BLOCK_BYTE_LENGTH) {
 +		hw_dbg(hw, "Buffer length failure buffersize-%d.\n", length);
++=======
+ 	u8 buf_len, dword_len;
+ 
+ 	if (length == 0 || length & 0x3 ||
+ 	    length > IXGBE_HI_MAX_BLOCK_BYTE_LENGTH) {
+ 		hw_dbg(hw, "Buffer length failure.\n");
++>>>>>>> e90dd2645664 (ixgbe: Make return values more direct)
  		return IXGBE_ERR_HOST_INTERFACE_COMMAND;
  	}
  
@@@ -3583,16 -3455,10 +3530,15 @@@
  	hicr = IXGBE_READ_REG(hw, IXGBE_HICR);
  	if ((hicr & IXGBE_HICR_EN) == 0) {
  		hw_dbg(hw, "IXGBE_HOST_EN bit disabled.\n");
- 		ret_val = IXGBE_ERR_HOST_INTERFACE_COMMAND;
- 		goto out;
+ 		return IXGBE_ERR_HOST_INTERFACE_COMMAND;
  	}
  
 -	/* Calculate length in DWORDs */
 +	/* Calculate length in DWORDs. We must be DWORD aligned */
 +	if ((length % (sizeof(u32))) != 0) {
 +		hw_dbg(hw, "Buffer length failure, not aligned to dword");
 +		return IXGBE_ERR_INVALID_ARGUMENT;
 +	}
 +
  	dword_len = length >> 2;
  
  	/*
@@@ -3614,16 -3480,12 +3560,15 @@@
  	}
  
  	/* Check command successful completion. */
 -	if (i == IXGBE_HI_COMMAND_TIMEOUT ||
 +	if ((timeout != 0 && i == timeout) ||
  	    (!(IXGBE_READ_REG(hw, IXGBE_HICR) & IXGBE_HICR_SV))) {
  		hw_dbg(hw, "Command has failed with no status valid.\n");
- 		ret_val = IXGBE_ERR_HOST_INTERFACE_COMMAND;
- 		goto out;
+ 		return IXGBE_ERR_HOST_INTERFACE_COMMAND;
  	}
  
 +	if (!return_data)
 +		return 0;
 +
  	/* Calculate length in DWORDs */
  	dword_len = hdr_size >> 2;
  
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c
index fb7c7d72dd34,48f35fc963f8..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c
@@@ -267,9 -263,8 +263,8 @@@ void ixgbe_dcb_unpack_map(struct ixgbe_
   * Configure dcb settings and enable dcb mode.
   */
  s32 ixgbe_dcb_hw_config(struct ixgbe_hw *hw,
 -			struct ixgbe_dcb_config *dcb_config)
 +                        struct ixgbe_dcb_config *dcb_config)
  {
- 	s32 ret = 0;
  	u8 pfc_en;
  	u8 ptype[MAX_TRAFFIC_CLASS];
  	u8 bwgid[MAX_TRAFFIC_CLASS];
@@@ -287,13 -282,10 +282,15 @@@
  
  	switch (hw->mac.type) {
  	case ixgbe_mac_82598EB:
- 		ret = ixgbe_dcb_hw_config_82598(hw, pfc_en, refill, max,
- 						bwgid, ptype);
- 		break;
+ 		return ixgbe_dcb_hw_config_82598(hw, pfc_en, refill, max,
+ 						 bwgid, ptype);
  	case ixgbe_mac_82599EB:
  	case ixgbe_mac_X540:
++<<<<<<< HEAD
 +	case ixgbe_mac_X550:
 +	case ixgbe_mac_X550EM_x:
++=======
++>>>>>>> e90dd2645664 (ixgbe: Make return values more direct)
  		return ixgbe_dcb_hw_config_82599(hw, pfc_en, refill, max,
  						 bwgid, ptype, prio_tc);
  	default:
@@@ -305,16 -297,11 +302,16 @@@
  /* Helper routines to abstract HW specifics from DCB netlink ops */
  s32 ixgbe_dcb_hw_pfc_config(struct ixgbe_hw *hw, u8 pfc_en, u8 *prio_tc)
  {
- 	int ret = -EINVAL;
- 
  	switch (hw->mac.type) {
  	case ixgbe_mac_82598EB:
- 		ret = ixgbe_dcb_config_pfc_82598(hw, pfc_en);
- 		break;
+ 		return ixgbe_dcb_config_pfc_82598(hw, pfc_en);
  	case ixgbe_mac_82599EB:
  	case ixgbe_mac_X540:
++<<<<<<< HEAD
 +	case ixgbe_mac_X550:
 +	case ixgbe_mac_X550EM_x:
++=======
++>>>>>>> e90dd2645664 (ixgbe: Make return values more direct)
  		return ixgbe_dcb_config_pfc_82599(hw, pfc_en, prio_tc);
  	default:
  		break;
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c
index 3a249fcfaf0e,cc8f0128286c..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c
@@@ -222,10 -215,10 +215,10 @@@ static s32 ixgbe_read_posted_mbx(struc
   *  received an ack to that message within delay * timeout period
   **/
  static s32 ixgbe_write_posted_mbx(struct ixgbe_hw *hw, u32 *msg, u16 size,
 -			   u16 mbx_id)
 +                           u16 mbx_id)
  {
  	struct ixgbe_mbx_info *mbx = &hw->mbx;
- 	s32 ret_val = IXGBE_ERR_MBX;
+ 	s32 ret_val;
  
  	/* exit if either we can't write or there isn't a defined timeout */
  	if (!mbx->ops.write || !mbx->timeout)
@@@ -268,12 -258,12 +258,17 @@@ static s32 ixgbe_check_for_msg_pf(struc
  	u32 vf_bit = vf_number % 16;
  
  	if (!ixgbe_check_for_bit_pf(hw, IXGBE_MBVFICR_VFREQ_VF1 << vf_bit,
++<<<<<<< HEAD
 +	                            index)) {
 +		ret_val = 0;
++=======
+ 				    index)) {
++>>>>>>> e90dd2645664 (ixgbe: Make return values more direct)
  		hw->mbx.stats.reqs++;
+ 		return 0;
  	}
  
- 	return ret_val;
+ 	return IXGBE_ERR_MBX;
  }
  
  /**
@@@ -290,12 -279,12 +284,17 @@@ static s32 ixgbe_check_for_ack_pf(struc
  	u32 vf_bit = vf_number % 16;
  
  	if (!ixgbe_check_for_bit_pf(hw, IXGBE_MBVFICR_VFACK_VF1 << vf_bit,
++<<<<<<< HEAD
 +	                            index)) {
 +		ret_val = 0;
++=======
+ 				    index)) {
++>>>>>>> e90dd2645664 (ixgbe: Make return values more direct)
  		hw->mbx.stats.acks++;
+ 		return 0;
  	}
  
- 	return ret_val;
+ 	return IXGBE_ERR_MBX;
  }
  
  /**
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c
index 32455da40d21,11f02ea78c4a..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c
@@@ -767,10 -576,10 +761,10 @@@ s32 ixgbe_setup_phy_link_speed_generic(
   * Determines the link capabilities by reading the AUTOC register.
   */
  s32 ixgbe_get_copper_link_capabilities_generic(struct ixgbe_hw *hw,
 -					       ixgbe_link_speed *speed,
 -					       bool *autoneg)
 +                                               ixgbe_link_speed *speed,
 +                                               bool *autoneg)
  {
- 	s32 status = IXGBE_ERR_LINK_SETUP;
+ 	s32 status;
  	u16 speed_ability;
  
  	*speed = 0;
@@@ -1016,9 -817,9 +1009,15 @@@ s32 ixgbe_reset_phy_nl(struct ixgbe_hw 
  
  	/* Get init offsets */
  	ret_val = ixgbe_get_sfp_init_sequence_offsets(hw, &list_offset,
++<<<<<<< HEAD
 +	                                              &data_offset);
 +	if (ret_val != 0)
 +		goto out;
++=======
+ 						      &data_offset);
+ 	if (ret_val)
+ 		return ret_val;
++>>>>>>> e90dd2645664 (ixgbe: Make return values more direct)
  
  	ret_val = hw->eeprom.ops.read(hw, data_offset, &block_crc);
  	data_offset++;
@@@ -1151,234 -943,109 +1141,286 @@@ s32 ixgbe_identify_sfp_module_generic(s
  
  	if (identifier != IXGBE_SFF_IDENTIFIER_SFP) {
  		hw->phy.type = ixgbe_phy_sfp_unsupported;
- 		status = IXGBE_ERR_SFP_NOT_SUPPORTED;
- 	} else {
- 		status = hw->phy.ops.read_i2c_eeprom(hw,
- 						     IXGBE_SFF_1GBE_COMP_CODES,
- 						     &comp_codes_1g);
+ 		return IXGBE_ERR_SFP_NOT_SUPPORTED;
+ 	}
+ 	status = hw->phy.ops.read_i2c_eeprom(hw,
+ 					     IXGBE_SFF_1GBE_COMP_CODES,
+ 					     &comp_codes_1g);
  
- 		if (status != 0)
- 			goto err_read_i2c_eeprom;
+ 	if (status)
+ 		goto err_read_i2c_eeprom;
  
- 		status = hw->phy.ops.read_i2c_eeprom(hw,
- 						     IXGBE_SFF_10GBE_COMP_CODES,
- 						     &comp_codes_10g);
+ 	status = hw->phy.ops.read_i2c_eeprom(hw,
+ 					     IXGBE_SFF_10GBE_COMP_CODES,
+ 					     &comp_codes_10g);
  
- 		if (status != 0)
- 			goto err_read_i2c_eeprom;
- 		status = hw->phy.ops.read_i2c_eeprom(hw,
- 						     IXGBE_SFF_CABLE_TECHNOLOGY,
- 						     &cable_tech);
+ 	if (status)
+ 		goto err_read_i2c_eeprom;
+ 	status = hw->phy.ops.read_i2c_eeprom(hw,
+ 					     IXGBE_SFF_CABLE_TECHNOLOGY,
+ 					     &cable_tech);
  
- 		if (status != 0)
- 			goto err_read_i2c_eeprom;
+ 	if (status)
+ 		goto err_read_i2c_eeprom;
  
- 		 /* ID Module
- 		  * =========
- 		  * 0   SFP_DA_CU
- 		  * 1   SFP_SR
- 		  * 2   SFP_LR
- 		  * 3   SFP_DA_CORE0 - 82599-specific
- 		  * 4   SFP_DA_CORE1 - 82599-specific
- 		  * 5   SFP_SR/LR_CORE0 - 82599-specific
- 		  * 6   SFP_SR/LR_CORE1 - 82599-specific
- 		  * 7   SFP_act_lmt_DA_CORE0 - 82599-specific
- 		  * 8   SFP_act_lmt_DA_CORE1 - 82599-specific
- 		  * 9   SFP_1g_cu_CORE0 - 82599-specific
- 		  * 10  SFP_1g_cu_CORE1 - 82599-specific
- 		  * 11  SFP_1g_sx_CORE0 - 82599-specific
- 		  * 12  SFP_1g_sx_CORE1 - 82599-specific
- 		  */
- 		if (hw->mac.type == ixgbe_mac_82598EB) {
- 			if (cable_tech & IXGBE_SFF_DA_PASSIVE_CABLE)
- 				hw->phy.sfp_type = ixgbe_sfp_type_da_cu;
- 			else if (comp_codes_10g & IXGBE_SFF_10GBASESR_CAPABLE)
- 				hw->phy.sfp_type = ixgbe_sfp_type_sr;
- 			else if (comp_codes_10g & IXGBE_SFF_10GBASELR_CAPABLE)
- 				hw->phy.sfp_type = ixgbe_sfp_type_lr;
+ 	 /* ID Module
+ 	  * =========
+ 	  * 0   SFP_DA_CU
+ 	  * 1   SFP_SR
+ 	  * 2   SFP_LR
+ 	  * 3   SFP_DA_CORE0 - 82599-specific
+ 	  * 4   SFP_DA_CORE1 - 82599-specific
+ 	  * 5   SFP_SR/LR_CORE0 - 82599-specific
+ 	  * 6   SFP_SR/LR_CORE1 - 82599-specific
+ 	  * 7   SFP_act_lmt_DA_CORE0 - 82599-specific
+ 	  * 8   SFP_act_lmt_DA_CORE1 - 82599-specific
+ 	  * 9   SFP_1g_cu_CORE0 - 82599-specific
+ 	  * 10  SFP_1g_cu_CORE1 - 82599-specific
+ 	  * 11  SFP_1g_sx_CORE0 - 82599-specific
+ 	  * 12  SFP_1g_sx_CORE1 - 82599-specific
+ 	  */
+ 	if (hw->mac.type == ixgbe_mac_82598EB) {
+ 		if (cable_tech & IXGBE_SFF_DA_PASSIVE_CABLE)
+ 			hw->phy.sfp_type = ixgbe_sfp_type_da_cu;
+ 		else if (comp_codes_10g & IXGBE_SFF_10GBASESR_CAPABLE)
+ 			hw->phy.sfp_type = ixgbe_sfp_type_sr;
+ 		else if (comp_codes_10g & IXGBE_SFF_10GBASELR_CAPABLE)
+ 			hw->phy.sfp_type = ixgbe_sfp_type_lr;
+ 		else
+ 			hw->phy.sfp_type = ixgbe_sfp_type_unknown;
+ 	} else if (hw->mac.type == ixgbe_mac_82599EB) {
+ 		if (cable_tech & IXGBE_SFF_DA_PASSIVE_CABLE) {
+ 			if (hw->bus.lan_id == 0)
+ 				hw->phy.sfp_type =
+ 					     ixgbe_sfp_type_da_cu_core0;
  			else
- 				hw->phy.sfp_type = ixgbe_sfp_type_unknown;
- 		} else if (hw->mac.type == ixgbe_mac_82599EB) {
- 			if (cable_tech & IXGBE_SFF_DA_PASSIVE_CABLE) {
+ 				hw->phy.sfp_type =
+ 					     ixgbe_sfp_type_da_cu_core1;
+ 		} else if (cable_tech & IXGBE_SFF_DA_ACTIVE_CABLE) {
+ 			hw->phy.ops.read_i2c_eeprom(
+ 					hw, IXGBE_SFF_CABLE_SPEC_COMP,
+ 					&cable_spec);
+ 			if (cable_spec &
+ 			    IXGBE_SFF_DA_SPEC_ACTIVE_LIMITING) {
  				if (hw->bus.lan_id == 0)
  					hw->phy.sfp_type =
++<<<<<<< HEAD
 +					             ixgbe_sfp_type_da_cu_core0;
 +				else
 +					hw->phy.sfp_type =
 +					             ixgbe_sfp_type_da_cu_core1;
 +			} else if (cable_tech & IXGBE_SFF_DA_ACTIVE_CABLE) {
 +				hw->phy.ops.read_i2c_eeprom(
 +						hw, IXGBE_SFF_CABLE_SPEC_COMP,
 +						&cable_spec);
 +				if (cable_spec &
 +				    IXGBE_SFF_DA_SPEC_ACTIVE_LIMITING) {
 +					if (hw->bus.lan_id == 0)
 +						hw->phy.sfp_type =
 +						ixgbe_sfp_type_da_act_lmt_core0;
 +					else
 +						hw->phy.sfp_type =
 +						ixgbe_sfp_type_da_act_lmt_core1;
 +				} else {
 +					hw->phy.sfp_type =
 +							ixgbe_sfp_type_unknown;
 +				}
 +			} else if (comp_codes_10g &
 +				   (IXGBE_SFF_10GBASESR_CAPABLE |
 +				    IXGBE_SFF_10GBASELR_CAPABLE)) {
 +				if (hw->bus.lan_id == 0)
 +					hw->phy.sfp_type =
 +					              ixgbe_sfp_type_srlr_core0;
 +				else
 +					hw->phy.sfp_type =
 +					              ixgbe_sfp_type_srlr_core1;
 +			} else if (comp_codes_1g & IXGBE_SFF_1GBASET_CAPABLE) {
 +				if (hw->bus.lan_id == 0)
 +					hw->phy.sfp_type =
 +						ixgbe_sfp_type_1g_cu_core0;
 +				else
 +					hw->phy.sfp_type =
 +						ixgbe_sfp_type_1g_cu_core1;
 +			} else if (comp_codes_1g & IXGBE_SFF_1GBASESX_CAPABLE) {
 +				if (hw->bus.lan_id == 0)
 +					hw->phy.sfp_type =
 +						ixgbe_sfp_type_1g_sx_core0;
 +				else
 +					hw->phy.sfp_type =
 +						ixgbe_sfp_type_1g_sx_core1;
 +			} else if (comp_codes_1g & IXGBE_SFF_1GBASELX_CAPABLE) {
 +				if (hw->bus.lan_id == 0)
 +					hw->phy.sfp_type =
 +						ixgbe_sfp_type_1g_lx_core0;
 +				else
 +					hw->phy.sfp_type =
 +						ixgbe_sfp_type_1g_lx_core1;
 +			} else {
 +				hw->phy.sfp_type = ixgbe_sfp_type_unknown;
 +			}
 +		}
 +
 +		if (hw->phy.sfp_type != stored_sfp_type)
 +			hw->phy.sfp_setup_needed = true;
 +
 +		/* Determine if the SFP+ PHY is dual speed or not. */
 +		hw->phy.multispeed_fiber = false;
 +		if (((comp_codes_1g & IXGBE_SFF_1GBASESX_CAPABLE) &&
 +		   (comp_codes_10g & IXGBE_SFF_10GBASESR_CAPABLE)) ||
 +		   ((comp_codes_1g & IXGBE_SFF_1GBASELX_CAPABLE) &&
 +		   (comp_codes_10g & IXGBE_SFF_10GBASELR_CAPABLE)))
 +			hw->phy.multispeed_fiber = true;
 +
 +		/* Determine PHY vendor */
 +		if (hw->phy.type != ixgbe_phy_nl) {
 +			hw->phy.id = identifier;
 +			status = hw->phy.ops.read_i2c_eeprom(hw,
 +						    IXGBE_SFF_VENDOR_OUI_BYTE0,
 +						    &oui_bytes[0]);
 +
 +			if (status != 0)
 +				goto err_read_i2c_eeprom;
 +
 +			status = hw->phy.ops.read_i2c_eeprom(hw,
 +			                            IXGBE_SFF_VENDOR_OUI_BYTE1,
 +			                            &oui_bytes[1]);
 +
 +			if (status != 0)
 +				goto err_read_i2c_eeprom;
 +
 +			status = hw->phy.ops.read_i2c_eeprom(hw,
 +			                            IXGBE_SFF_VENDOR_OUI_BYTE2,
 +			                            &oui_bytes[2]);
 +
 +			if (status != 0)
 +				goto err_read_i2c_eeprom;
 +
 +			vendor_oui =
 +			  ((oui_bytes[0] << IXGBE_SFF_VENDOR_OUI_BYTE0_SHIFT) |
 +			   (oui_bytes[1] << IXGBE_SFF_VENDOR_OUI_BYTE1_SHIFT) |
 +			   (oui_bytes[2] << IXGBE_SFF_VENDOR_OUI_BYTE2_SHIFT));
 +
 +			switch (vendor_oui) {
 +			case IXGBE_SFF_VENDOR_OUI_TYCO:
 +				if (cable_tech & IXGBE_SFF_DA_PASSIVE_CABLE)
 +					hw->phy.type =
 +						    ixgbe_phy_sfp_passive_tyco;
 +				break;
 +			case IXGBE_SFF_VENDOR_OUI_FTL:
 +				if (cable_tech & IXGBE_SFF_DA_ACTIVE_CABLE)
 +					hw->phy.type = ixgbe_phy_sfp_ftl_active;
 +				else
 +					hw->phy.type = ixgbe_phy_sfp_ftl;
 +				break;
 +			case IXGBE_SFF_VENDOR_OUI_AVAGO:
 +				hw->phy.type = ixgbe_phy_sfp_avago;
 +				break;
 +			case IXGBE_SFF_VENDOR_OUI_INTEL:
 +				hw->phy.type = ixgbe_phy_sfp_intel;
 +				break;
 +			default:
 +				if (cable_tech & IXGBE_SFF_DA_PASSIVE_CABLE)
 +					hw->phy.type =
 +						 ixgbe_phy_sfp_passive_unknown;
 +				else if (cable_tech & IXGBE_SFF_DA_ACTIVE_CABLE)
 +					hw->phy.type =
 +						ixgbe_phy_sfp_active_unknown;
 +				else
 +					hw->phy.type = ixgbe_phy_sfp_unknown;
 +				break;
 +			}
 +		}
 +
 +		/* Allow any DA cable vendor */
 +		if (cable_tech & (IXGBE_SFF_DA_PASSIVE_CABLE |
 +		    IXGBE_SFF_DA_ACTIVE_CABLE)) {
 +			status = 0;
 +			goto out;
 +		}
 +
 +		/* Verify supported 1G SFP modules */
 +		if (comp_codes_10g == 0 &&
 +		    !(hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core1 ||
 +		      hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core0 ||
 +		      hw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core0 ||
 +		      hw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core1 ||
 +		      hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core0 ||
 +		      hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core1)) {
 +			hw->phy.type = ixgbe_phy_sfp_unsupported;
 +			status = IXGBE_ERR_SFP_NOT_SUPPORTED;
 +			goto out;
 +		}
 +
 +		/* Anything else 82598-based is supported */
 +		if (hw->mac.type == ixgbe_mac_82598EB) {
 +			status = 0;
 +			goto out;
 +		}
 +
 +		hw->mac.ops.get_device_caps(hw, &enforce_sfp);
 +		if (!(enforce_sfp & IXGBE_DEVICE_CAPS_ALLOW_ANY_SFP) &&
 +		    !(hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core0 ||
 +		      hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core1 ||
 +		      hw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core0 ||
 +		      hw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core1 ||
 +		      hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core0 ||
 +		      hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core1)) {
 +			/* Make sure we're a supported PHY type */
 +			if (hw->phy.type == ixgbe_phy_sfp_intel) {
 +				status = 0;
 +			} else {
 +				if (hw->allow_unsupported_sfp) {
 +					e_warn(drv, "WARNING: Intel (R) Network Connections are quality tested using Intel (R) Ethernet Optics.  Using untested modules is not supported and may cause unstable operation or damage to the module or the adapter.  Intel Corporation is not responsible for any harm caused by using untested modules.\n");
 +					status = 0;
 +				} else {
 +					hw_dbg(hw,
 +					       "SFP+ module not supported\n");
 +					hw->phy.type =
 +						ixgbe_phy_sfp_unsupported;
 +					status = IXGBE_ERR_SFP_NOT_SUPPORTED;
 +				}
++=======
+ 					ixgbe_sfp_type_da_act_lmt_core0;
+ 				else
+ 					hw->phy.sfp_type =
+ 					ixgbe_sfp_type_da_act_lmt_core1;
+ 			} else {
+ 				hw->phy.sfp_type =
+ 						ixgbe_sfp_type_unknown;
++>>>>>>> e90dd2645664 (ixgbe: Make return values more direct)
  			}
+ 		} else if (comp_codes_10g &
+ 			   (IXGBE_SFF_10GBASESR_CAPABLE |
+ 			    IXGBE_SFF_10GBASELR_CAPABLE)) {
+ 			if (hw->bus.lan_id == 0)
+ 				hw->phy.sfp_type =
+ 					      ixgbe_sfp_type_srlr_core0;
+ 			else
+ 				hw->phy.sfp_type =
+ 					      ixgbe_sfp_type_srlr_core1;
+ 		} else if (comp_codes_1g & IXGBE_SFF_1GBASET_CAPABLE) {
+ 			if (hw->bus.lan_id == 0)
+ 				hw->phy.sfp_type =
+ 					ixgbe_sfp_type_1g_cu_core0;
+ 			else
+ 				hw->phy.sfp_type =
+ 					ixgbe_sfp_type_1g_cu_core1;
+ 		} else if (comp_codes_1g & IXGBE_SFF_1GBASESX_CAPABLE) {
+ 			if (hw->bus.lan_id == 0)
+ 				hw->phy.sfp_type =
+ 					ixgbe_sfp_type_1g_sx_core0;
+ 			else
+ 				hw->phy.sfp_type =
+ 					ixgbe_sfp_type_1g_sx_core1;
+ 		} else if (comp_codes_1g & IXGBE_SFF_1GBASELX_CAPABLE) {
+ 			if (hw->bus.lan_id == 0)
+ 				hw->phy.sfp_type =
+ 					ixgbe_sfp_type_1g_lx_core0;
+ 			else
+ 				hw->phy.sfp_type =
+ 					ixgbe_sfp_type_1g_lx_core1;
  		} else {
- 			status = 0;
+ 			hw->phy.sfp_type = ixgbe_sfp_type_unknown;
  		}
  	}
  
@@@ -1400,10 -1177,10 +1552,10 @@@ err_read_i2c_eeprom
   *
   * Searches for and identifies the QSFP module and assigns appropriate PHY type
   **/
 -static s32 ixgbe_identify_qsfp_module_generic(struct ixgbe_hw *hw)
 +s32 ixgbe_identify_qsfp_module_generic(struct ixgbe_hw *hw)
  {
  	struct ixgbe_adapter *adapter = hw->back;
- 	s32 status = IXGBE_ERR_PHY_ADDR_INVALID;
+ 	s32 status;
  	u32 vendor_oui = 0;
  	enum ixgbe_sfp_type stored_sfp_type = hw->phy.sfp_type;
  	u8 identifier = 0;
@@@ -1734,20 -1500,23 +1875,18 @@@ s32 ixgbe_write_i2c_eeprom_generic(stru
   *  a specified device address.
   **/
  s32 ixgbe_read_i2c_byte_generic(struct ixgbe_hw *hw, u8 byte_offset,
 -				u8 dev_addr, u8 *data)
 +                                u8 dev_addr, u8 *data)
  {
- 	s32 status = 0;
+ 	s32 status;
  	u32 max_retry = 10;
  	u32 retry = 0;
 -	u16 swfw_mask = 0;
 +	u32 swfw_mask = hw->phy.phy_semaphore_mask;
  	bool nack = true;
  	*data = 0;
  
 -	if (IXGBE_READ_REG(hw, IXGBE_STATUS) & IXGBE_STATUS_LAN_ID_1)
 -		swfw_mask = IXGBE_GSSR_PHY1_SM;
 -	else
 -		swfw_mask = IXGBE_GSSR_PHY0_SM;
 -
  	do {
- 		if (hw->mac.ops.acquire_swfw_sync(hw, swfw_mask) != 0) {
- 			status = IXGBE_ERR_SWFW_SYNC;
- 			goto read_byte_out;
- 		}
+ 		if (hw->mac.ops.acquire_swfw_sync(hw, swfw_mask))
+ 			return IXGBE_ERR_SWFW_SYNC;
  
  		ixgbe_i2c_start(hw);
  
@@@ -1818,17 -1586,20 +1956,15 @@@ fail
   *  a specified device address.
   **/
  s32 ixgbe_write_i2c_byte_generic(struct ixgbe_hw *hw, u8 byte_offset,
 -				 u8 dev_addr, u8 data)
 +                                 u8 dev_addr, u8 data)
  {
- 	s32 status = 0;
+ 	s32 status;
  	u32 max_retry = 1;
  	u32 retry = 0;
 -	u16 swfw_mask = 0;
 -
 -	if (IXGBE_READ_REG(hw, IXGBE_STATUS) & IXGBE_STATUS_LAN_ID_1)
 -		swfw_mask = IXGBE_GSSR_PHY1_SM;
 -	else
 -		swfw_mask = IXGBE_GSSR_PHY0_SM;
 +	u32 swfw_mask = hw->phy.phy_semaphore_mask;
  
- 	if (hw->mac.ops.acquire_swfw_sync(hw, swfw_mask) != 0) {
- 		status = IXGBE_ERR_SWFW_SYNC;
- 		goto write_byte_out;
- 	}
+ 	if (hw->mac.ops.acquire_swfw_sync(hw, swfw_mask))
+ 		return IXGBE_ERR_SWFW_SYNC;
  
  	do {
  		ixgbe_i2c_start(hw);
@@@ -2148,8 -1918,8 +2283,13 @@@ static s32 ixgbe_set_i2c_data(struct ix
  	udelay(IXGBE_I2C_T_RISE + IXGBE_I2C_T_FALL + IXGBE_I2C_T_SU_DATA);
  
  	/* Verify data was set correctly */
++<<<<<<< HEAD
 +	*i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL_BY_MAC(hw));
 +	if (data != ixgbe_get_i2c_data(hw, i2cctl)) {
++=======
+ 	*i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL);
+ 	if (data != ixgbe_get_i2c_data(i2cctl)) {
++>>>>>>> e90dd2645664 (ixgbe: Make return values more direct)
  		hw_dbg(hw, "Error - I2C data was not set to %X.\n", data);
  		return IXGBE_ERR_I2C;
  	}
@@@ -2164,9 -1934,9 +2304,13 @@@
   *
   *  Returns the I2C data bit value
   **/
 -static bool ixgbe_get_i2c_data(u32 *i2cctl)
 +static bool ixgbe_get_i2c_data(struct ixgbe_hw *hw, u32 *i2cctl)
  {
++<<<<<<< HEAD
 +	if (*i2cctl & IXGBE_I2C_DATA_IN_BY_MAC(hw))
++=======
+ 	if (*i2cctl & IXGBE_I2C_DATA_IN)
++>>>>>>> e90dd2645664 (ixgbe: Make return values more direct)
  		return true;
  	return false;
  }
@@@ -2221,12 -1990,10 +2364,10 @@@ s32 ixgbe_tn_check_overtemp(struct ixgb
  
  	/* Check that the LASI temp alarm status was triggered */
  	hw->phy.ops.read_reg(hw, IXGBE_TN_LASI_STATUS_REG,
 -			     MDIO_MMD_PMAPMD, &phy_data);
 +	                     MDIO_MMD_PMAPMD, &phy_data);
  
  	if (!(phy_data & IXGBE_TN_LASI_STATUS_TEMP_ALARM))
- 		goto out;
+ 		return 0;
  
- 	status = IXGBE_ERR_OVERTEMP;
- out:
- 	return status;
+ 	return IXGBE_ERR_OVERTEMP;
  }
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_common.c
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c
index 80fd128681f9..c475e4ef7cde 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 
   Intel 10 Gigabit PCI Express Linux driver
-  Copyright(c) 1999 - 2013 Intel Corporation.
+  Copyright(c) 1999 - 2014 Intel Corporation.
 
   This program is free software; you can redistribute it and/or modify it
   under the terms and conditions of the GNU General Public License,
@@ -153,7 +153,6 @@ static u8 ixgbe_dcbnl_get_state(struct net_device *netdev)
 static u8 ixgbe_dcbnl_set_state(struct net_device *netdev, u8 state)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
-	int err = 0;
 
 	/* Fail command if not in CEE mode */
 	if (!(adapter->dcbx_cap & DCB_CAP_DCBX_VER_CEE))
@@ -161,12 +160,10 @@ static u8 ixgbe_dcbnl_set_state(struct net_device *netdev, u8 state)
 
 	/* verify there is something to do, if not then exit */
 	if (!state == !(adapter->flags & IXGBE_FLAG_DCB_ENABLED))
-		goto out;
+		return 0;
 
-	err = ixgbe_setup_tc(netdev,
-			     state ? adapter->dcb_cfg.num_tcs.pg_tcs : 0);
-out:
-	return !!err;
+	return !!ixgbe_setup_tc(netdev,
+				state ? adapter->dcb_cfg.num_tcs.pg_tcs : 0);
 }
 
 static void ixgbe_dcbnl_get_perm_hw_addr(struct net_device *netdev,
@@ -332,12 +329,12 @@ static u8 ixgbe_dcbnl_set_all(struct net_device *netdev)
 
 	/* Fail command if not in CEE mode */
 	if (!(adapter->dcbx_cap & DCB_CAP_DCBX_VER_CEE))
-		return ret;
+		return DCB_NO_HW_CHG;
 
 	adapter->dcb_set_bitmap |= ixgbe_copy_dcb_cfg(adapter,
 						      MAX_TRAFFIC_CLASS);
 	if (!adapter->dcb_set_bitmap)
-		return ret;
+		return DCB_NO_HW_CHG;
 
 	if (adapter->dcb_set_bitmap & (BIT_PG_TX|BIT_PG_RX)) {
 		u16 refill[MAX_TRAFFIC_CLASS], max[MAX_TRAFFIC_CLASS];
@@ -537,7 +534,7 @@ static int ixgbe_dcbnl_ieee_setets(struct net_device *dev,
 {
 	struct ixgbe_adapter *adapter = netdev_priv(dev);
 	int max_frame = dev->mtu + ETH_HLEN + ETH_FCS_LEN;
-	int i, err = 0;
+	int i, err;
 	__u8 max_tc = 0;
 	__u8 map_chg = 0;
 
@@ -574,17 +571,15 @@ static int ixgbe_dcbnl_ieee_setets(struct net_device *dev,
 	if (max_tc > adapter->dcb_cfg.num_tcs.pg_tcs)
 		return -EINVAL;
 
-	if (max_tc != netdev_get_num_tc(dev))
+	if (max_tc != netdev_get_num_tc(dev)) {
 		err = ixgbe_setup_tc(dev, max_tc);
-	else if (map_chg)
+		if (err)
+			return err;
+	} else if (map_chg) {
 		ixgbe_dcbnl_devreset(dev);
+	}
 
-	if (err)
-		goto err_out;
-
-	err = ixgbe_dcb_hw_ets(&adapter->hw, ets, max_frame);
-err_out:
-	return err;
+	return ixgbe_dcb_hw_ets(&adapter->hw, ets, max_frame);
 }
 
 static int ixgbe_dcbnl_ieee_getpfc(struct net_device *dev,
@@ -648,10 +643,10 @@ static int ixgbe_dcbnl_ieee_setapp(struct net_device *dev,
 				   struct dcb_app *app)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(dev);
-	int err = -EINVAL;
+	int err;
 
 	if (!(adapter->dcbx_cap & DCB_CAP_DCBX_VER_IEEE))
-		return err;
+		return -EINVAL;
 
 	err = dcb_ieee_setapp(dev, app);
 	if (err)
@@ -663,7 +658,7 @@ static int ixgbe_dcbnl_ieee_setapp(struct net_device *dev,
 		u8 app_mask = dcb_ieee_getapp_mask(dev, app);
 
 		if (app_mask & (1 << adapter->fcoe.up))
-			return err;
+			return 0;
 
 		adapter->fcoe.up = app->priority;
 		ixgbe_dcbnl_devreset(dev);
@@ -706,7 +701,7 @@ static int ixgbe_dcbnl_ieee_delapp(struct net_device *dev,
 		u8 app_mask = dcb_ieee_getapp_mask(dev, app);
 
 		if (app_mask & (1 << adapter->fcoe.up))
-			return err;
+			return 0;
 
 		adapter->fcoe.up = app_mask ?
 				   ffs(app_mask) - 1 : IXGBE_FCOE_DEFTC;
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c
index 25a3dfef33e8..2ad91cb04dab 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 
   Intel 10 Gigabit PCI Express Linux driver
-  Copyright(c) 1999 - 2013 Intel Corporation.
+  Copyright(c) 1999 - 2014 Intel Corporation.
 
   This program is free software; you can redistribute it and/or modify it
   under the terms and conditions of the GNU General Public License,
@@ -67,23 +67,23 @@ static inline void ixgbe_fcoe_clear_ddp(struct ixgbe_fcoe_ddp *ddp)
  */
 int ixgbe_fcoe_ddp_put(struct net_device *netdev, u16 xid)
 {
-	int len = 0;
+	int len;
 	struct ixgbe_fcoe *fcoe;
 	struct ixgbe_adapter *adapter;
 	struct ixgbe_fcoe_ddp *ddp;
 	u32 fcbuff;
 
 	if (!netdev)
-		goto out_ddp_put;
+		return 0;
 
 	if (xid >= IXGBE_FCOE_DDP_MAX)
-		goto out_ddp_put;
+		return 0;
 
 	adapter = netdev_priv(netdev);
 	fcoe = &adapter->fcoe;
 	ddp = &fcoe->ddp[xid];
 	if (!ddp->udl)
-		goto out_ddp_put;
+		return 0;
 
 	len = ddp->len;
 	/* if there an error, force to invalidate ddp context */
@@ -114,7 +114,6 @@ int ixgbe_fcoe_ddp_put(struct net_device *netdev, u16 xid)
 
 	ixgbe_fcoe_clear_ddp(ddp);
 
-out_ddp_put:
 	return len;
 }
 
@@ -394,17 +393,17 @@ int ixgbe_fcoe_ddp(struct ixgbe_adapter *adapter,
 		xid =  be16_to_cpu(fh->fh_rx_id);
 
 	if (xid >= IXGBE_FCOE_DDP_MAX)
-		goto ddp_out;
+		return -EINVAL;
 
 	fcoe = &adapter->fcoe;
 	ddp = &fcoe->ddp[xid];
 	if (!ddp->udl)
-		goto ddp_out;
+		return -EINVAL;
 
 	ddp_err = ixgbe_test_staterr(rx_desc, IXGBE_RXDADV_ERR_FCEOFE |
 					      IXGBE_RXDADV_ERR_FCERR);
 	if (ddp_err)
-		goto ddp_out;
+		return -EINVAL;
 
 	switch (ixgbe_test_staterr(rx_desc, IXGBE_RXDADV_STAT_FCSTAT)) {
 	/* return 0 to bypass going to ULD for DDPed data */
@@ -447,7 +446,7 @@ int ixgbe_fcoe_ddp(struct ixgbe_adapter *adapter,
 		crc = (struct fcoe_crc_eof *)skb_put(skb, sizeof(*crc));
 		crc->fcoe_eof = FC_EOF_T;
 	}
-ddp_out:
+
 	return rc;
 }
 
@@ -878,7 +877,6 @@ int ixgbe_fcoe_disable(struct net_device *netdev)
  */
 int ixgbe_fcoe_get_wwn(struct net_device *netdev, u64 *wwn, int type)
 {
-	int rc = -EINVAL;
 	u16 prefix = 0xffff;
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 	struct ixgbe_mac_info *mac = &adapter->hw.mac;
@@ -903,9 +901,9 @@ int ixgbe_fcoe_get_wwn(struct net_device *netdev, u64 *wwn, int type)
 		       ((u64) mac->san_addr[3] << 16) |
 		       ((u64) mac->san_addr[4] << 8)  |
 		       ((u64) mac->san_addr[5]);
-		rc = 0;
+		return 0;
 	}
-	return rc;
+	return -EINVAL;
 }
 
 /**
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index 4d23bcbc6b43..1c4bdf56d658 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@ -576,7 +576,7 @@ static void ixgbe_dump(struct ixgbe_adapter *adapter)
 
 	/* Print TX Ring Summary */
 	if (!netdev || !netif_running(netdev))
-		goto exit;
+		return;
 
 	dev_info(&adapter->pdev->dev, "TX Rings Summary\n");
 	pr_info(" %s     %s              %s        %s\n",
@@ -691,7 +691,7 @@ rx_ring_summary:
 
 	/* Print RX Rings */
 	if (!netif_msg_rx_status(adapter))
-		goto exit;
+		return;
 
 	dev_info(&adapter->pdev->dev, "RX Rings Dump\n");
 
@@ -793,9 +793,6 @@ rx_ring_summary:
 
 		}
 	}
-
-exit:
-	return;
 }
 
 static void ixgbe_release_hw_control(struct ixgbe_adapter *adapter)
@@ -1014,7 +1011,6 @@ static inline bool ixgbe_check_tx_hang(struct ixgbe_ring *tx_ring)
 	u32 tx_done = ixgbe_get_tx_completed(tx_ring);
 	u32 tx_done_old = tx_ring->tx_stats.tx_done_old;
 	u32 tx_pending = ixgbe_get_tx_pending(tx_ring);
-	bool ret = false;
 
 	clear_check_for_tx_hang(tx_ring);
 
@@ -1030,18 +1026,16 @@ static inline bool ixgbe_check_tx_hang(struct ixgbe_ring *tx_ring)
 	 * run the check_tx_hang logic with a transmit completion
 	 * pending but without time to complete it yet.
 	 */
-	if ((tx_done_old == tx_done) && tx_pending) {
+	if (tx_done_old == tx_done && tx_pending)
 		/* make sure it is true for two checks in a row */
-		ret = test_and_set_bit(__IXGBE_HANG_CHECK_ARMED,
-				       &tx_ring->state);
-	} else {
-		/* update completed stats and continue */
-		tx_ring->tx_stats.tx_done_old = tx_done;
-		/* reset the countdown */
-		clear_bit(__IXGBE_HANG_CHECK_ARMED, &tx_ring->state);
-	}
+		return test_and_set_bit(__IXGBE_HANG_CHECK_ARMED,
+					&tx_ring->state);
+	/* update completed stats and continue */
+	tx_ring->tx_stats.tx_done_old = tx_done;
+	/* reset the countdown */
+	clear_bit(__IXGBE_HANG_CHECK_ARMED, &tx_ring->state);
 
-	return ret;
+	return false;
 }
 
 /**
@@ -4375,18 +4369,18 @@ static int ixgbe_non_sfp_link_config(struct ixgbe_hw *hw)
 		ret = hw->mac.ops.check_link(hw, &speed, &link_up, false);
 
 	if (ret)
-		goto link_cfg_out;
+		return ret;
 
 	speed = hw->phy.autoneg_advertised;
 	if ((!speed) && (hw->mac.ops.get_link_capabilities))
 		ret = hw->mac.ops.get_link_capabilities(hw, &speed,
 							&autoneg);
 	if (ret)
-		goto link_cfg_out;
+		return ret;
 
 	if (hw->mac.ops.setup_link)
 		ret = hw->mac.ops.setup_link(hw, speed, link_up);
-link_cfg_out:
+
 	return ret;
 }
 
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c
index ac6f5c6e917f..3f0b41f56134 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 
   Intel 10 Gigabit PCI Express Linux driver
-  Copyright(c) 1999 - 2013 Intel Corporation.
+  Copyright(c) 1999 - 2014 Intel Corporation.
 
   This program is free software; you can redistribute it and/or modify it
   under the terms and conditions of the GNU General Public License,
@@ -249,10 +249,10 @@ static int ixgbe_pci_sriov_enable(struct pci_dev *dev, int num_vfs)
 	if (pre_existing_vfs && pre_existing_vfs != num_vfs)
 		err = ixgbe_disable_sriov(adapter);
 	else if (pre_existing_vfs && pre_existing_vfs == num_vfs)
-		goto out;
+		return num_vfs;
 
 	if (err)
-		goto err_out;
+		return err;
 
 	/* While the SR-IOV capability structure reports total VFs to be
 	 * 64 we limit the actual number that can be allocated to 63 so
@@ -260,16 +260,14 @@ static int ixgbe_pci_sriov_enable(struct pci_dev *dev, int num_vfs)
 	 * PF.  The PCI bus driver already checks for other values out of
 	 * range.
 	 */
-	if (num_vfs > IXGBE_MAX_VFS_DRV_LIMIT) {
-		err = -EPERM;
-		goto err_out;
-	}
+	if (num_vfs > IXGBE_MAX_VFS_DRV_LIMIT)
+		return -EPERM;
 
 	adapter->num_vfs = num_vfs;
 
 	err = __ixgbe_enable_sriov(adapter);
 	if (err)
-		goto err_out;
+		return  err;
 
 	for (i = 0; i < adapter->num_vfs; i++)
 		ixgbe_vf_configuration(dev, (i | 0x10000000));
@@ -277,17 +275,14 @@ static int ixgbe_pci_sriov_enable(struct pci_dev *dev, int num_vfs)
 	err = pci_enable_sriov(dev, num_vfs);
 	if (err) {
 		e_dev_warn("Failed to enable PCI sriov: %d\n", err);
-		goto err_out;
+		return err;
 	}
 	ixgbe_sriov_reinit(adapter);
 
-out:
 	return num_vfs;
-
-err_out:
-	return err;
-#endif
+#else
 	return 0;
+#endif
 }
 
 static int ixgbe_pci_sriov_disable(struct pci_dev *dev)
@@ -833,7 +828,7 @@ static int ixgbe_set_vf_vlan_msg(struct ixgbe_adapter *adapter,
 	if (!add && adapter->netdev->flags & IFF_PROMISC) {
 		reg_ndx = ixgbe_find_vlvf_entry(hw, vid);
 		if (reg_ndx < 0)
-			goto out;
+			return err;
 		vlvf = IXGBE_READ_REG(hw, IXGBE_VLVF(reg_ndx));
 		/* See if any other pools are set for this VLAN filter
 		 * entry other than the PF.
@@ -859,8 +854,6 @@ static int ixgbe_set_vf_vlan_msg(struct ixgbe_adapter *adapter,
 			ixgbe_set_vf_vlan(adapter, add, vid, VMDQ_P(0));
 	}
 
-out:
-
 	return err;
 }
 
@@ -977,7 +970,7 @@ static int ixgbe_rcv_msg_from_vf(struct ixgbe_adapter *adapter, u32 vf)
 
 	/* this is a message we already processed, do nothing */
 	if (msgbuf[0] & (IXGBE_VT_MSGTYPE_ACK | IXGBE_VT_MSGTYPE_NACK))
-		return retval;
+		return 0;
 
 	/* flush the ack before we write any messages back */
 	IXGBE_WRITE_FLUSH(hw);
@@ -992,7 +985,7 @@ static int ixgbe_rcv_msg_from_vf(struct ixgbe_adapter *adapter, u32 vf)
 	if (!adapter->vfinfo[vf].clear_to_send) {
 		msgbuf[0] |= IXGBE_VT_MSGTYPE_NACK;
 		ixgbe_write_mbx(hw, msgbuf, 1, vf);
-		return retval;
+		return 0;
 	}
 
 	switch ((msgbuf[0] & 0xFFFF)) {
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c
index 202411a49822..1797d7873e71 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c
@@ -94,8 +94,8 @@ s32 ixgbe_reset_hw_X540(struct ixgbe_hw *hw)
 
 	/* Call adapter stop to disable tx/rx and clear interrupts */
 	status = hw->mac.ops.stop_adapter(hw);
-	if (status != 0)
-		goto reset_hw_out;
+	if (status)
+		return status;
 
 	/* flush pending Tx transactions */
 	ixgbe_clear_tx_pending(hw);
@@ -163,7 +163,6 @@ mac_reset_top:
 	hw->mac.ops.get_wwn_prefix(hw, &hw->mac.wwnn_prefix,
 	                           &hw->mac.wwpn_prefix);
 
-reset_hw_out:
 	return status;
 }
 
@@ -177,15 +176,13 @@ reset_hw_out:
  **/
 s32 ixgbe_start_hw_X540(struct ixgbe_hw *hw)
 {
-	s32 ret_val = 0;
+	s32 ret_val;
 
 	ret_val = ixgbe_start_hw_generic(hw);
-	if (ret_val != 0)
-		goto out;
+	if (ret_val)
+		return ret_val;
 
-	ret_val = ixgbe_start_hw_gen2(hw);
-out:
-	return ret_val;
+	return ixgbe_start_hw_gen2(hw);
 }
 
 /**
@@ -524,12 +521,12 @@ out:
 static s32 ixgbe_update_flash_X540(struct ixgbe_hw *hw)
 {
 	u32 flup;
-	s32 status = IXGBE_ERR_EEPROM;
+	s32 status;
 
 	status = ixgbe_poll_flash_update_done_X540(hw);
 	if (status == IXGBE_ERR_EEPROM) {
 		hw_dbg(hw, "Flash update time out\n");
-		goto out;
+		return status;
 	}
 
 	flup = IXGBE_READ_REG(hw, IXGBE_EEC) | IXGBE_EEC_FLUP;
@@ -555,7 +552,7 @@ static s32 ixgbe_update_flash_X540(struct ixgbe_hw *hw)
 		else
 			hw_dbg(hw, "Flash update time out\n");
 	}
-out:
+
 	return status;
 }
 
@@ -570,17 +567,14 @@ static s32 ixgbe_poll_flash_update_done_X540(struct ixgbe_hw *hw)
 {
 	u32 i;
 	u32 reg;
-	s32 status = IXGBE_ERR_EEPROM;
 
 	for (i = 0; i < IXGBE_FLUDONE_ATTEMPTS; i++) {
 		reg = IXGBE_READ_REG(hw, IXGBE_EEC);
-		if (reg & IXGBE_EEC_FLUDONE) {
-			status = 0;
-			break;
-		}
+		if (reg & IXGBE_EEC_FLUDONE)
+			return 0;
 		udelay(5);
 	}
-	return status;
+	return IXGBE_ERR_EEPROM;
 }
 
 /**
