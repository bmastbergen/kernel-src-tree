i40e: notify VFs of link state

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Mitch Williams <mitch.a.williams@intel.com>
commit 055b295d99adb246b2b9284e1d1e602630c119e3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/055b295d.failed

Gratuitously notify VFs of link state when they activate their queues.
In general, this is the last thing that a VF driver will do as it opens
its interface, so this is a good time to notify the VF.

Currently, VF devices assume link is up unless told otherwise, which
means that VFs instantiated on a PF with no link will report the wrong
state. This change corrects that issue.

Change-ID: Iea53622904ecc681ac3f8938d81c30033ef9a0a6
	Signed-off-by: Mitch Williams <mitch.a.williams@intel.com>
	Tested-by: Jim Young <james.m.young@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 055b295d99adb246b2b9284e1d1e602630c119e3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
index 59846b397b9b,8df2b529289b..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
@@@ -1869,35 -1877,45 +1871,49 @@@ static void i40e_vc_vf_broadcast(struc
  
  /**
   * i40e_vc_notify_link_state
++<<<<<<< HEAD
 + * @pf: pointer to the pf structure
++=======
+  * @vf: pointer to the VF structure
   *
-  * send a link status message to all VFs on a given PF
+  * send a link status message to a single VF
   **/
- void i40e_vc_notify_link_state(struct i40e_pf *pf)
+ static void i40e_vc_notify_vf_link_state(struct i40e_vf *vf)
  {
  	struct i40e_virtchnl_pf_event pfe;
+ 	struct i40e_pf *pf = vf->pf;
  	struct i40e_hw *hw = &pf->hw;
- 	struct i40e_vf *vf = pf->vf;
  	struct i40e_link_status *ls = &pf->hw.phy.link_info;
- 	int i;
+ 	int abs_vf_id = vf->vf_id + hw->func_caps.vf_base_id;
  
  	pfe.event = I40E_VIRTCHNL_EVENT_LINK_CHANGE;
  	pfe.severity = I40E_PF_EVENT_SEVERITY_INFO;
- 	for (i = 0; i < pf->num_alloc_vfs; i++, vf++) {
- 		int abs_vf_id = vf->vf_id + hw->func_caps.vf_base_id;
- 		if (vf->link_forced) {
- 			pfe.event_data.link_event.link_status = vf->link_up;
- 			pfe.event_data.link_event.link_speed =
- 				(vf->link_up ? I40E_LINK_SPEED_40GB : 0);
- 		} else {
- 			pfe.event_data.link_event.link_status =
- 				ls->link_info & I40E_AQ_LINK_UP;
- 			pfe.event_data.link_event.link_speed = ls->link_speed;
- 		}
- 		i40e_aq_send_msg_to_vf(hw, abs_vf_id, I40E_VIRTCHNL_OP_EVENT,
- 				       0, (u8 *)&pfe, sizeof(pfe),
- 				       NULL);
+ 	if (vf->link_forced) {
+ 		pfe.event_data.link_event.link_status = vf->link_up;
+ 		pfe.event_data.link_event.link_speed =
+ 			(vf->link_up ? I40E_LINK_SPEED_40GB : 0);
+ 	} else {
+ 		pfe.event_data.link_event.link_status =
+ 			ls->link_info & I40E_AQ_LINK_UP;
+ 		pfe.event_data.link_event.link_speed = ls->link_speed;
  	}
+ 	i40e_aq_send_msg_to_vf(hw, abs_vf_id, I40E_VIRTCHNL_OP_EVENT,
+ 			       0, (u8 *)&pfe, sizeof(pfe), NULL);
+ }
+ 
+ /**
+  * i40e_vc_notify_link_state
+  * @pf: pointer to the PF structure
++>>>>>>> 055b295d99ad (i40e: notify VFs of link state)
+  *
+  * send a link status message to all VFs on a given PF
+  **/
+ void i40e_vc_notify_link_state(struct i40e_pf *pf)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < pf->num_alloc_vfs; i++)
+ 		i40e_vc_notify_vf_link_state(&pf->vf[i]);
  }
  
  /**
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
