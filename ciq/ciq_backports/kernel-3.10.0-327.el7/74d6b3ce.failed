tpm: fix suspend/resume paths for TPM 2.0

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
commit 74d6b3ceaa17d111220c3f09f50f901bf955d7c8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/74d6b3ce.failed

Fixed suspend/resume paths for TPM 2.0 and consolidated all the
associated code to the tpm_pm_suspend() and tpm_pm_resume()
functions. Resume path should be handled by the firmware, i.e.
Startup(CLEAR) for hibernate and Startup(STATE) for suspend.

There might be some non-PC embedded devices in the future where
Startup() is not the handled by the FW but fixing the code for
those IMHO should be postponed until there is hardware available
to test the fixes although extra Startup in the driver code is
essentially a NOP.

Added Shutdown(CLEAR) to the remove paths of TIS and CRB drivers.
Changed tpm2_shutdown() to a void function because there isn't
much you can do except print an error message if this fails with
a system error.

Fixes: aec04cbdf723 ("tpm: TPM 2.0 FIFO Interface")
Fixes: 30fc8d138e91 ("tpm: TPM 2.0 CRB Interface")
[phuewe: both did send TPM_Shutdown on resume which 'disables' the TPM
and did not send TPM2_Shutdown on teardown which leads some TPM2.0 to
believe there was an attack (no TPM2_Shutdown = no orderly shutdown =
attack)]

	Reported-by: Peter HÃ¼we <PeterHuewe@gmx.de>
	Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Tested-by: Scot Doyle <lkml14@scotdoyle.com>
	Reviewed-by: Peter Huewe <peterhuewe@gmx.de>
	Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
(cherry picked from commit 74d6b3ceaa17d111220c3f09f50f901bf955d7c8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/tpm/tpm.h
#	drivers/char/tpm/tpm2-cmd.c
#	drivers/char/tpm/tpm_tis.c
diff --cc drivers/char/tpm/tpm.h
index e638eb016b90,a2ce3797e3e0..000000000000
--- a/drivers/char/tpm/tpm.h
+++ b/drivers/char/tpm/tpm.h
@@@ -351,3 -424,15 +351,18 @@@ static inline void tpm_remove_ppi(struc
  {
  }
  #endif
++<<<<<<< HEAD
++=======
+ 
+ int tpm2_pcr_read(struct tpm_chip *chip, int pcr_idx, u8 *res_buf);
+ int tpm2_pcr_extend(struct tpm_chip *chip, int pcr_idx, const u8 *hash);
+ int tpm2_get_random(struct tpm_chip *chip, u8 *out, size_t max);
+ ssize_t tpm2_get_tpm_pt(struct tpm_chip *chip, u32 property_id,
+ 			u32 *value, const char *desc);
+ 
+ extern int tpm2_startup(struct tpm_chip *chip, u16 startup_type);
+ extern void tpm2_shutdown(struct tpm_chip *chip, u16 shutdown_type);
+ extern unsigned long tpm2_calc_ordinal_duration(struct tpm_chip *, u32);
+ extern int tpm2_do_selftest(struct tpm_chip *chip);
+ extern int tpm2_gen_interrupt(struct tpm_chip *chip, bool quiet);
++>>>>>>> 74d6b3ceaa17 (tpm: fix suspend/resume paths for TPM 2.0)
diff --cc drivers/char/tpm/tpm_tis.c
index 51350cd0847e,e12b3ab215cf..000000000000
--- a/drivers/char/tpm/tpm_tis.c
+++ b/drivers/char/tpm/tpm_tis.c
@@@ -572,8 -586,23 +572,28 @@@ static bool interrupts = true
  module_param(interrupts, bool, 0444);
  MODULE_PARM_DESC(interrupts, "Enable interrupts");
  
++<<<<<<< HEAD
 +static int tpm_tis_init(struct device *dev, resource_size_t start,
 +			resource_size_t len, unsigned int irq)
++=======
+ static void tpm_tis_remove(struct tpm_chip *chip)
+ {
+ 	if (chip->flags & TPM_CHIP_FLAG_TPM2)
+ 		tpm2_shutdown(chip, TPM2_SU_CLEAR);
+ 
+ 	iowrite32(~TPM_GLOBAL_INT_ENABLE &
+ 		  ioread32(chip->vendor.iobase +
+ 			   TPM_INT_ENABLE(chip->vendor.
+ 					  locality)),
+ 		  chip->vendor.iobase +
+ 		  TPM_INT_ENABLE(chip->vendor.locality));
+ 	release_locality(chip, chip->vendor.locality, 1);
+ }
+ 
+ static int tpm_tis_init(struct device *dev, acpi_handle acpi_dev_handle,
+ 			resource_size_t start, resource_size_t len,
+ 			unsigned int irq)
++>>>>>>> 74d6b3ceaa17 (tpm: fix suspend/resume paths for TPM 2.0)
  {
  	u32 vendor, intfcaps, intmask;
  	int rc, i, irq_s, irq_e, probe;
@@@ -812,10 -874,16 +832,20 @@@ static int tpm_tis_resume(struct devic
  		tpm_tis_reenable_interrupts(chip);
  
  	ret = tpm_pm_resume(dev);
++<<<<<<< HEAD
 +	if (!ret)
++=======
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* TPM 1.2 requires self-test on resume. This function actually returns
+ 	 * an error code but for unknown reason it isn't handled.
+ 	 */
+ 	if (!(chip->flags & TPM_CHIP_FLAG_TPM2))
++>>>>>>> 74d6b3ceaa17 (tpm: fix suspend/resume paths for TPM 2.0)
  		tpm_do_selftest(chip);
  
- 	return ret;
+ 	return 0;
  }
  #endif
  
* Unmerged path drivers/char/tpm/tpm2-cmd.c
diff --git a/drivers/char/tpm/tpm-interface.c b/drivers/char/tpm/tpm-interface.c
index 02fe4a7c04c5..c03392eedeb6 100644
--- a/drivers/char/tpm/tpm-interface.c
+++ b/drivers/char/tpm/tpm-interface.c
@@ -935,8 +935,10 @@ int tpm_pm_suspend(struct device *dev)
 	if (chip == NULL)
 		return -ENODEV;
 
-	if (chip->flags & TPM_CHIP_FLAG_TPM2)
-		return tpm2_shutdown(chip, TPM2_SU_CLEAR);
+	if (chip->flags & TPM_CHIP_FLAG_TPM2) {
+		tpm2_shutdown(chip, TPM2_SU_STATE);
+		return 0;
+	}
 
 	/* for buggy tpm, flush pcrs with extend to selected dummy */
 	if (tpm_suspend_pcr) {
* Unmerged path drivers/char/tpm/tpm.h
* Unmerged path drivers/char/tpm/tpm2-cmd.c
diff --git a/drivers/char/tpm/tpm_crb.c b/drivers/char/tpm/tpm_crb.c
index 3dd23cfae4fe..b26ceee3585e 100644
--- a/drivers/char/tpm/tpm_crb.c
+++ b/drivers/char/tpm/tpm_crb.c
@@ -95,21 +95,7 @@ struct crb_priv {
 	u8 __iomem *rsp;
 };
 
-#ifdef CONFIG_PM_SLEEP
-static int crb_resume(struct device *dev)
-{
-	int rc;
-	struct tpm_chip *chip = dev_get_drvdata(dev);
-
-	rc = tpm2_shutdown(chip, TPM2_SU_STATE);
-	if (!rc)
-		rc = tpm2_do_selftest(chip);
-
-	return rc;
-}
-#endif
-
-static SIMPLE_DEV_PM_OPS(crb_pm, tpm_pm_suspend, crb_resume);
+static SIMPLE_DEV_PM_OPS(crb_pm, tpm_pm_suspend, tpm_pm_resume);
 
 static u8 crb_status(struct tpm_chip *chip)
 {
@@ -326,6 +312,10 @@ static int crb_acpi_remove(struct acpi_device *device)
 	struct tpm_chip *chip = dev_get_drvdata(dev);
 
 	tpm_chip_unregister(chip);
+
+	if (chip->flags & TPM_CHIP_FLAG_TPM2)
+		tpm2_shutdown(chip, TPM2_SU_CLEAR);
+
 	return 0;
 }
 
* Unmerged path drivers/char/tpm/tpm_tis.c
