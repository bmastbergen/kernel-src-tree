IB/iser: Remove code duplication for a single DMA entry

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [infiniband] iser: Remove code duplication for a single DMA entry (Amir Vadai) [1164539]
Rebuild_FUZZ: 97.20%
commit-author Sagi Grimberg <sagig@mellanox.com>
commit ad1e5672429eadd5a7f9613bf2e59546a2eeef13
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/ad1e5672.failed

In singleton scatterlists, DMA memory registration code
is taken both for Fastreg and FMR code paths. Move it to
a function.

This patch does not change any functionality.

	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Adir Lev <adirl@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit ad1e5672429eadd5a7f9613bf2e59546a2eeef13)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/iser/iser_memory.c
diff --cc drivers/infiniband/ulp/iser/iser_memory.c
index f40132fc970c,abc979e62ae1..000000000000
--- a/drivers/infiniband/ulp/iser/iser_memory.c
+++ b/drivers/infiniband/ulp/iser/iser_memory.c
@@@ -334,14 -330,30 +334,32 @@@ void iser_dma_unmap_task_data(struct is
  {
  	struct ib_device *dev;
  
 -	dev = iser_task->iser_conn->ib_conn.device->ib_device;
 -	ib_dma_unmap_sg(dev, data->sg, data->size, dir);
 +	dev = iser_task->ib_conn->device->ib_device;
 +	ib_dma_unmap_sg(dev, data->buf, data->size, DMA_FROM_DEVICE);
  }
  
+ static int
+ iser_reg_dma(struct iser_device *device, struct iser_data_buf *mem,
+ 	     struct iser_mem_reg *reg)
+ {
+ 	struct scatterlist *sg = mem->sg;
+ 
+ 	reg->sge.lkey = device->mr->lkey;
+ 	reg->rkey = device->mr->rkey;
+ 	reg->sge.addr = ib_sg_dma_address(device->ib_device, &sg[0]);
+ 	reg->sge.length = ib_sg_dma_len(device->ib_device, &sg[0]);
+ 
+ 	iser_dbg("Single DMA entry: lkey=0x%x, rkey=0x%x, addr=0x%llx,"
+ 		 " length=0x%x\n", reg->sge.lkey, reg->rkey,
+ 		 reg->sge.addr, reg->sge.length);
+ 
+ 	return 0;
+ }
+ 
  static int fall_to_bounce_buf(struct iscsi_iser_task *iser_task,
 +			      struct ib_device *ibdev,
  			      struct iser_data_buf *mem,
 +			      struct iser_data_buf *mem_copy,
  			      enum iser_data_dir cmd_dir,
  			      int aligned_len)
  {
@@@ -382,9 -479,8 +400,8 @@@ int iser_reg_rdma_mem_fmr(struct iscsi_
  	int aligned_len;
  	int err;
  	int i;
- 	struct scatterlist *sg;
  
 -	mem_reg = &iser_task->rdma_reg[cmd_dir];
 +	regd_buf = &iser_task->rdma_regd[cmd_dir];
  
  	aligned_len = iser_data_buf_aligned_len(mem, ibdev);
  	if (aligned_len != mem->dma_nents) {
@@@ -400,24 -494,10 +417,28 @@@
  
  	/* if there a single dma entry, FMR is not needed */
  	if (mem->dma_nents == 1) {
++<<<<<<< HEAD
 +		sg = (struct scatterlist *)mem->buf;
 +
 +		regd_buf->reg.lkey = device->mr->lkey;
 +		regd_buf->reg.rkey = device->mr->rkey;
 +		regd_buf->reg.len  = ib_sg_dma_len(ibdev, &sg[0]);
 +		regd_buf->reg.va   = ib_sg_dma_address(ibdev, &sg[0]);
 +		regd_buf->reg.is_mr = 0;
 +
 +		iser_dbg("PHYSICAL Mem.register: lkey: 0x%08X rkey: 0x%08X  "
 +			 "va: 0x%08lX sz: %ld]\n",
 +			 (unsigned int)regd_buf->reg.lkey,
 +			 (unsigned int)regd_buf->reg.rkey,
 +			 (unsigned long)regd_buf->reg.va,
 +			 (unsigned long)regd_buf->reg.len);
++=======
+ 		return iser_reg_dma(device, mem, mem_reg);
++>>>>>>> ad1e5672429e (IB/iser: Remove code duplication for a single DMA entry)
  	} else { /* use FMR for multiple dma entries */
 -		err = iser_reg_page_vec(iser_task, mem, ib_conn->fmr.page_vec,
 -					mem_reg);
 +		iser_page_vec_build(mem, ib_conn->fmr.page_vec, ibdev);
 +		err = iser_reg_page_vec(ib_conn, ib_conn->fmr.page_vec,
 +					&regd_buf->reg);
  		if (err && err != -EAGAIN) {
  			iser_data_buf_dump(mem, ibdev);
  			iser_err("mem->dma_nents = %d (dlength = 0x%x)\n",
@@@ -607,15 -657,13 +628,14 @@@ err
  }
  
  static int iser_fast_reg_mr(struct iscsi_iser_task *iser_task,
 +			    struct iser_regd_buf *regd_buf,
  			    struct iser_data_buf *mem,
 -			    struct fast_reg_descriptor *desc,
  			    enum iser_reg_indicator ind,
 -			    struct iser_mem_reg *reg)
 +			    struct ib_sge *sge)
  {
 -	struct ib_conn *ib_conn = &iser_task->iser_conn->ib_conn;
 +	struct fast_reg_descriptor *desc = regd_buf->reg.mem_h;
 +	struct iser_conn *ib_conn = iser_task->ib_conn;
  	struct iser_device *device = ib_conn->device;
- 	struct ib_device *ibdev = device->ib_device;
  	struct ib_mr *mr;
  	struct ib_fast_reg_page_list *frpl;
  	struct ib_send_wr fastreg_wr, inv_wr;
@@@ -623,17 -671,8 +643,22 @@@
  	int ret, offset, size, plen;
  
  	/* if there a single dma entry, dma mr suffices */
++<<<<<<< HEAD
 +	if (mem->dma_nents == 1) {
 +		struct scatterlist *sg = (struct scatterlist *)mem->buf;
 +
 +		sge->lkey = device->mr->lkey;
 +		sge->addr   = ib_sg_dma_address(ibdev, &sg[0]);
 +		sge->length  = ib_sg_dma_len(ibdev, &sg[0]);
 +
 +		iser_dbg("Single DMA entry: lkey=0x%x, addr=0x%llx, length=0x%x\n",
 +			 sge->lkey, sge->addr, sge->length);
 +		return 0;
 +	}
++=======
+ 	if (mem->dma_nents == 1)
+ 		return iser_reg_dma(device, mem, reg);
++>>>>>>> ad1e5672429e (IB/iser: Remove code duplication for a single DMA entry)
  
  	if (ind == ISER_DATA_KEY_VALID) {
  		mr = desc->data_mr;
* Unmerged path drivers/infiniband/ulp/iser/iser_memory.c
