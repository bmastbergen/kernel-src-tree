openvswitch: Optimize recirc action.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] openvswitch: Optimize recirc action (Jiri Benc) [1156461 1211348]
Rebuild_FUZZ: 98.59%
commit-author Pravin B Shelar <pshelar@nicira.com>
commit fff06c36a2563214073707f6e6aea152713274d1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/fff06c36.failed

OVS need to flow key for flow lookup in recic action. OVS
does key extract in recic action. Most of cases we could
use OVS_CB packet key directly and can avoid packet flow key
extract. SET action we can update flow-key along with packet
to keep it consistent. But there are some action like MPLS
pop which forces OVS to do flow-extract. In such cases we
can mark flow key as invalid so that subsequent recirc
action can do full flow extract.

	Signed-off-by: Pravin B Shelar <pshelar@nicira.com>
	Acked-by: Jarno Rajahalme <jrajahalme@nicira.com>
	Acked-by: Andy Zhou <azhou@nicira.com>
(cherry picked from commit fff06c36a2563214073707f6e6aea152713274d1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/openvswitch/actions.c
diff --cc net/openvswitch/actions.c
index ffaa84305d76,d4c2f735d999..000000000000
--- a/net/openvswitch/actions.c
+++ b/net/openvswitch/actions.c
@@@ -118,6 -130,96 +128,99 @@@ static int make_writable(struct sk_buf
  	return pskb_expand_head(skb, 0, 0, GFP_ATOMIC);
  }
  
++<<<<<<< HEAD
++=======
+ static int push_mpls(struct sk_buff *skb, struct sw_flow_key *key,
+ 		     const struct ovs_action_push_mpls *mpls)
+ {
+ 	__be32 *new_mpls_lse;
+ 	struct ethhdr *hdr;
+ 
+ 	/* Networking stack do not allow simultaneous Tunnel and MPLS GSO. */
+ 	if (skb->encapsulation)
+ 		return -ENOTSUPP;
+ 
+ 	if (skb_cow_head(skb, MPLS_HLEN) < 0)
+ 		return -ENOMEM;
+ 
+ 	skb_push(skb, MPLS_HLEN);
+ 	memmove(skb_mac_header(skb) - MPLS_HLEN, skb_mac_header(skb),
+ 		skb->mac_len);
+ 	skb_reset_mac_header(skb);
+ 
+ 	new_mpls_lse = (__be32 *)skb_mpls_header(skb);
+ 	*new_mpls_lse = mpls->mpls_lse;
+ 
+ 	if (skb->ip_summed == CHECKSUM_COMPLETE)
+ 		skb->csum = csum_add(skb->csum, csum_partial(new_mpls_lse,
+ 							     MPLS_HLEN, 0));
+ 
+ 	hdr = eth_hdr(skb);
+ 	hdr->h_proto = mpls->mpls_ethertype;
+ 
+ 	skb_set_inner_protocol(skb, skb->protocol);
+ 	skb->protocol = mpls->mpls_ethertype;
+ 
+ 	invalidate_flow_key(key);
+ 	return 0;
+ }
+ 
+ static int pop_mpls(struct sk_buff *skb, struct sw_flow_key *key,
+ 		    const __be16 ethertype)
+ {
+ 	struct ethhdr *hdr;
+ 	int err;
+ 
+ 	err = make_writable(skb, skb->mac_len + MPLS_HLEN);
+ 	if (unlikely(err))
+ 		return err;
+ 
+ 	if (skb->ip_summed == CHECKSUM_COMPLETE)
+ 		skb->csum = csum_sub(skb->csum,
+ 				     csum_partial(skb_mpls_header(skb),
+ 						  MPLS_HLEN, 0));
+ 
+ 	memmove(skb_mac_header(skb) + MPLS_HLEN, skb_mac_header(skb),
+ 		skb->mac_len);
+ 
+ 	__skb_pull(skb, MPLS_HLEN);
+ 	skb_reset_mac_header(skb);
+ 
+ 	/* skb_mpls_header() is used to locate the ethertype
+ 	 * field correctly in the presence of VLAN tags.
+ 	 */
+ 	hdr = (struct ethhdr *)(skb_mpls_header(skb) - ETH_HLEN);
+ 	hdr->h_proto = ethertype;
+ 	if (eth_p_mpls(skb->protocol))
+ 		skb->protocol = ethertype;
+ 
+ 	invalidate_flow_key(key);
+ 	return 0;
+ }
+ 
+ static int set_mpls(struct sk_buff *skb, struct sw_flow_key *key,
+ 		    const __be32 *mpls_lse)
+ {
+ 	__be32 *stack;
+ 	int err;
+ 
+ 	err = make_writable(skb, skb->mac_len + MPLS_HLEN);
+ 	if (unlikely(err))
+ 		return err;
+ 
+ 	stack = (__be32 *)skb_mpls_header(skb);
+ 	if (skb->ip_summed == CHECKSUM_COMPLETE) {
+ 		__be32 diff[] = { ~(*stack), *mpls_lse };
+ 		skb->csum = ~csum_partial((char *)diff, sizeof(diff),
+ 					  ~skb->csum);
+ 	}
+ 
+ 	*stack = *mpls_lse;
+ 	key->mpls.top_lse = *mpls_lse;
+ 	return 0;
+ }
+ 
++>>>>>>> fff06c36a256 (openvswitch: Optimize recirc action.)
  /* remove VLAN header from packet and update csum accordingly. */
  static int __pop_vlan_tci(struct sk_buff *skb, __be16 *current_tci)
  {
@@@ -622,8 -770,12 +767,15 @@@ static int execute_set_action(struct sk
  		break;
  
  	case OVS_KEY_ATTR_SCTP:
- 		err = set_sctp(skb, nla_data(nested_attr));
+ 		err = set_sctp(skb, key, nla_data(nested_attr));
  		break;
++<<<<<<< HEAD
++=======
+ 
+ 	case OVS_KEY_ATTR_MPLS:
+ 		err = set_mpls(skb, key, nla_data(nested_attr));
+ 		break;
++>>>>>>> fff06c36a256 (openvswitch: Optimize recirc action.)
  	}
  
  	return err;
@@@ -706,8 -863,16 +863,19 @@@ static int do_execute_actions(struct da
  			execute_hash(skb, key, a);
  			break;
  
++<<<<<<< HEAD
++=======
+ 		case OVS_ACTION_ATTR_PUSH_MPLS:
+ 			err = push_mpls(skb, key, nla_data(a));
+ 			break;
+ 
+ 		case OVS_ACTION_ATTR_POP_MPLS:
+ 			err = pop_mpls(skb, key, nla_get_be16(a));
+ 			break;
+ 
++>>>>>>> fff06c36a256 (openvswitch: Optimize recirc action.)
  		case OVS_ACTION_ATTR_PUSH_VLAN:
- 			err = push_vlan(skb, nla_data(a));
+ 			err = push_vlan(skb, key, nla_data(a));
  			if (unlikely(err)) /* skb already freed. */
  				return err;
  			break;
* Unmerged path net/openvswitch/actions.c
