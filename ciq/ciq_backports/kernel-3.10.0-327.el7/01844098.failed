bonding: create a macro for bond mode and use it

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Veaceslav Falico <vfalico@gmail.com>
commit 01844098ecd9564cd5f903e3ff6c1ea96355772d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/01844098.failed

CC: Jay Vosburgh <j.vosburgh@gmail.com>
CC: Andy Gospodarek <andy@greyhouse.net>
	Signed-off-by: Veaceslav Falico <vfalico@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 01844098ecd9564cd5f903e3ff6c1ea96355772d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
#	drivers/net/bonding/bond_netlink.c
#	drivers/net/bonding/bond_procfs.c
#	drivers/net/bonding/bond_sysfs.c
#	drivers/net/bonding/bond_sysfs_slave.c
#	drivers/net/bonding/bonding.h
diff --cc drivers/net/bonding/bond_main.c
index d0eec7c786f0,744c47111045..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -529,16 -337,16 +529,16 @@@ static void bond_del_vlans_from_slave(s
   */
  static int bond_set_carrier(struct bonding *bond)
  {
 -	struct list_head *iter;
  	struct slave *slave;
 +	int i;
  
 -	if (!bond_has_slaves(bond))
 +	if (bond->slave_cnt == 0)
  		goto down;
  
- 	if (bond->params.mode == BOND_MODE_8023AD)
+ 	if (BOND_MODE(bond) == BOND_MODE_8023AD)
  		return bond_3ad_set_carrier(bond);
  
 -	bond_for_each_slave(bond, slave, iter) {
 +	bond_for_each_slave(bond, slave, i) {
  		if (slave->link == BOND_LINK_UP) {
  			if (!netif_carrier_ok(bond->dev)) {
  				netif_carrier_on(bond->dev);
@@@ -782,12 -570,11 +782,12 @@@ static void bond_mc_list_flush(struct n
  			       struct net_device *slave_dev)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
 +	struct netdev_hw_addr *ha;
  
 -	dev_uc_unsync(slave_dev, bond_dev);
 -	dev_mc_unsync(slave_dev, bond_dev);
 +	netdev_for_each_mc_addr(ha, bond_dev)
 +		dev_mc_del(slave_dev, ha->addr);
  
- 	if (bond->params.mode == BOND_MODE_8023AD) {
+ 	if (BOND_MODE(bond) == BOND_MODE_8023AD) {
  		/* del lacpdu mc addr from mc list */
  		u8 lacpdu_multicast[ETH_ALEN] = MULTICAST_LACPDU_ADDR;
  
@@@ -1067,16 -829,19 +1067,16 @@@ void bond_change_active_slave(struct bo
  	if (bond_is_lb(bond)) {
  		bond_alb_handle_active_change(bond, new_active);
  		if (old_active)
 -			bond_set_slave_inactive_flags(old_active,
 -						      BOND_SLAVE_NOTIFY_NOW);
 +			bond_set_slave_inactive_flags(old_active);
  		if (new_active)
 -			bond_set_slave_active_flags(new_active,
 -						    BOND_SLAVE_NOTIFY_NOW);
 +			bond_set_slave_active_flags(new_active);
  	} else {
 -		rcu_assign_pointer(bond->curr_active_slave, new_active);
 +		bond->curr_active_slave = new_active;
  	}
  
- 	if (bond->params.mode == BOND_MODE_ACTIVEBACKUP) {
+ 	if (BOND_MODE(bond) == BOND_MODE_ACTIVEBACKUP) {
  		if (old_active)
 -			bond_set_slave_inactive_flags(old_active,
 -						      BOND_SLAVE_NOTIFY_NOW);
 +			bond_set_slave_inactive_flags(old_active);
  
  		if (new_active) {
  			bool should_notify_peers = false;
@@@ -1110,8 -876,8 +1110,13 @@@
  	 * resend only if bond is brought up with the affected
  	 * bonding modes and the retransmission is enabled */
  	if (netif_running(bond->dev) && (bond->params.resend_igmp > 0) &&
++<<<<<<< HEAD
 +	    ((USES_PRIMARY(bond->params.mode) && new_active) ||
 +	     bond->params.mode == BOND_MODE_ROUNDROBIN)) {
++=======
+ 	    ((bond_uses_primary(bond) && new_active) ||
+ 	     BOND_MODE(bond) == BOND_MODE_ROUNDROBIN)) {
++>>>>>>> 01844098ecd9 (bonding: create a macro for bond mode and use it)
  		bond->igmp_retrans = bond->params.resend_igmp;
  		queue_delayed_work(bond->wq, &bond->mcast_work, 1);
  	}
@@@ -1451,6 -1163,35 +1456,38 @@@ static void bond_upper_dev_unlink(struc
  	rtmsg_ifinfo(RTM_NEWLINK, slave_dev, IFF_SLAVE, GFP_KERNEL);
  }
  
++<<<<<<< HEAD
++=======
+ static struct slave *bond_alloc_slave(struct bonding *bond)
+ {
+ 	struct slave *slave = NULL;
+ 
+ 	slave = kzalloc(sizeof(struct slave), GFP_KERNEL);
+ 	if (!slave)
+ 		return NULL;
+ 
+ 	if (BOND_MODE(bond) == BOND_MODE_8023AD) {
+ 		SLAVE_AD_INFO(slave) = kzalloc(sizeof(struct ad_slave_info),
+ 					       GFP_KERNEL);
+ 		if (!SLAVE_AD_INFO(slave)) {
+ 			kfree(slave);
+ 			return NULL;
+ 		}
+ 	}
+ 	return slave;
+ }
+ 
+ static void bond_free_slave(struct slave *slave)
+ {
+ 	struct bonding *bond = bond_get_bond_by_slave(slave);
+ 
+ 	if (BOND_MODE(bond) == BOND_MODE_8023AD)
+ 		kfree(SLAVE_AD_INFO(slave));
+ 
+ 	kfree(slave);
+ }
+ 
++>>>>>>> 01844098ecd9 (bonding: create a macro for bond mode and use it)
  /* enslave device <slave> to bond device <master> */
  int bond_enslave(struct net_device *bond_dev, struct net_device *slave_dev)
  {
@@@ -1556,12 -1295,16 +1593,23 @@@
  	}
  
  	if (slave_ops->ndo_set_mac_address == NULL) {
++<<<<<<< HEAD
 +		if (bond->slave_cnt == 0) {
 +			pr_warning("%s: Warning: The first slave device specified does not support setting the MAC address. Setting fail_over_mac to active.",
 +				   bond_dev->name);
 +			bond->params.fail_over_mac = BOND_FOM_ACTIVE;
++=======
+ 		if (!bond_has_slaves(bond)) {
+ 			pr_warn("%s: Warning: The first slave device specified does not support setting the MAC address\n",
+ 				bond_dev->name);
+ 			if (BOND_MODE(bond) == BOND_MODE_ACTIVEBACKUP) {
+ 				bond->params.fail_over_mac = BOND_FOM_ACTIVE;
+ 				pr_warn("%s: Setting fail_over_mac to active for active-backup mode\n",
+ 					bond_dev->name);
+ 			}
++>>>>>>> 01844098ecd9 (bonding: create a macro for bond mode and use it)
  		} else if (bond->params.fail_over_mac != BOND_FOM_ACTIVE) {
 -			pr_err("%s: Error: The slave device specified does not support setting the MAC address, but fail_over_mac is not set to active\n",
 +			pr_err("%s: Error: The slave device specified does not support setting the MAC address, but fail_over_mac is not set to active.\n",
  			       bond_dev->name);
  			res = -EOPNOTSUPP;
  			goto err_undo_flags;
@@@ -1600,9 -1344,10 +1648,14 @@@
  	 * that need it, and for restoring it upon release, and then
  	 * set it to the master's address
  	 */
 -	ether_addr_copy(new_slave->perm_hwaddr, slave_dev->dev_addr);
 +	memcpy(new_slave->perm_hwaddr, slave_dev->dev_addr, ETH_ALEN);
  
++<<<<<<< HEAD
 +	if (!bond->params.fail_over_mac) {
++=======
+ 	if (!bond->params.fail_over_mac ||
+ 	    BOND_MODE(bond) != BOND_MODE_ACTIVEBACKUP) {
++>>>>>>> 01844098ecd9 (bonding: create a macro for bond mode and use it)
  		/*
  		 * Set slave to master's mac address.  The application already
  		 * set the master's mac address to that of the first slave
@@@ -1747,12 -1488,10 +1800,16 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	write_lock_bh(&bond->curr_slave_lock);
 +
 +	switch (bond->params.mode) {
++=======
+ 	switch (BOND_MODE(bond)) {
++>>>>>>> 01844098ecd9 (bonding: create a macro for bond mode and use it)
  	case BOND_MODE_ACTIVEBACKUP:
 -		bond_set_slave_inactive_flags(new_slave,
 -					      BOND_SLAVE_NOTIFY_NOW);
 +		bond_set_slave_inactive_flags(new_slave);
 +		bond_select_active_slave(bond);
  		break;
  	case BOND_MODE_8023AD:
  		/* in 802.3ad mode, the internal mechanism
@@@ -1877,7 -1614,8 +1934,12 @@@ err_close
  	dev_close(slave_dev);
  
  err_restore_mac:
++<<<<<<< HEAD
 +	if (!bond->params.fail_over_mac) {
++=======
+ 	if (!bond->params.fail_over_mac ||
+ 	    BOND_MODE(bond) != BOND_MODE_ACTIVEBACKUP) {
++>>>>>>> 01844098ecd9 (bonding: create a macro for bond mode and use it)
  		/* XXX TODO - fom follow mode needs to change master's
  		 * MAC if this slave's MAC is in use by the bond, or at
  		 * least print a warning.
@@@ -1955,24 -1690,13 +2017,28 @@@ static int __bond_release_one(struct ne
  	netdev_rx_handler_unregister(slave_dev);
  	write_lock_bh(&bond->lock);
  
 +	if (!all && !bond->params.fail_over_mac) {
 +		if (ether_addr_equal(bond_dev->dev_addr, slave->perm_hwaddr) &&
 +		    bond->slave_cnt > 1)
 +			pr_warning("%s: Warning: the permanent HWaddr of %s - %pM - is still in use by %s. Set the HWaddr of %s to a different address to avoid conflicts.\n",
 +				   bond_dev->name, slave_dev->name,
 +				   slave->perm_hwaddr,
 +				   bond_dev->name, slave_dev->name);
 +	}
 +
  	/* Inform AD package of unbinding of slave. */
++<<<<<<< HEAD
 +	if (bond->params.mode == BOND_MODE_8023AD) {
 +		/* must be called before the slave is
 +		 * detached from the list
 +		 */
++=======
+ 	if (BOND_MODE(bond) == BOND_MODE_8023AD)
++>>>>>>> 01844098ecd9 (bonding: create a macro for bond mode and use it)
  		bond_3ad_unbind_slave(slave);
 +	}
  
 -	write_unlock_bh(&bond->lock);
 -
 -	pr_info("%s: Releasing %s interface %s\n",
 +	pr_info("%s: releasing %s interface %s\n",
  		bond_dev->name,
  		bond_is_active_slave(slave) ? "active" : "backup",
  		slave_dev->name);
@@@ -1981,8 -1705,15 +2047,20 @@@
  
  	bond->current_arp_slave = NULL;
  
++<<<<<<< HEAD
 +	/* release the slave from its bond */
 +	bond_detach_slave(bond, slave);
++=======
+ 	if (!all && (!bond->params.fail_over_mac ||
+ 		     BOND_MODE(bond) != BOND_MODE_ACTIVEBACKUP)) {
+ 		if (ether_addr_equal_64bits(bond_dev->dev_addr, slave->perm_hwaddr) &&
+ 		    bond_has_slaves(bond))
+ 			pr_warn("%s: Warning: the permanent HWaddr of %s - %pM - is still in use by %s - set the HWaddr of %s to a different address to avoid conflicts\n",
+ 				bond_dev->name, slave_dev->name,
+ 				slave->perm_hwaddr,
+ 				bond_dev->name, slave_dev->name);
+ 	}
++>>>>>>> 01844098ecd9 (bonding: create a macro for bond mode and use it)
  
  	if (bond->primary_slave == slave)
  		bond->primary_slave = NULL;
@@@ -2074,9 -1804,10 +2152,14 @@@
  	/* close slave before restoring its mac address */
  	dev_close(slave_dev);
  
++<<<<<<< HEAD
 +	if (bond->params.fail_over_mac != BOND_FOM_ACTIVE) {
++=======
+ 	if (bond->params.fail_over_mac != BOND_FOM_ACTIVE ||
+ 	    BOND_MODE(bond) != BOND_MODE_ACTIVEBACKUP) {
++>>>>>>> 01844098ecd9 (bonding: create a macro for bond mode and use it)
  		/* restore original ("permanent") mac address */
 -		ether_addr_copy(addr.sa_data, slave->perm_hwaddr);
 +		memcpy(addr.sa_data, slave->perm_hwaddr, ETH_ALEN);
  		addr.sa_family = slave_dev->type;
  		dev_set_mac_address(slave_dev, &addr);
  	}
@@@ -2120,12 -1851,10 +2203,12 @@@ static int bond_info_query(struct net_d
  {
  	struct bonding *bond = netdev_priv(bond_dev);
  
- 	info->bond_mode = bond->params.mode;
+ 	info->bond_mode = BOND_MODE(bond);
  	info->miimon = bond->params.miimon;
  
 +	read_lock(&bond->lock);
  	info->num_slaves = bond->slave_cnt;
 +	read_unlock(&bond->lock);
  
  	return 0;
  }
@@@ -2178,9 -1905,9 +2261,9 @@@ static int bond_miimon_inspect(struct b
  			slave->link = BOND_LINK_FAIL;
  			slave->delay = bond->params.downdelay;
  			if (slave->delay) {
 -				pr_info("%s: link status down for %sinterface %s, disabling it in %d ms\n",
 +				pr_info("%s: link status down for %sinterface %s, disabling it in %d ms.\n",
  					bond->dev->name,
- 					(bond->params.mode ==
+ 					(BOND_MODE(bond) ==
  					 BOND_MODE_ACTIVEBACKUP) ?
  					(bond_is_active_slave(slave) ?
  					 "active " : "backup ") : "",
@@@ -2269,12 -1996,12 +2352,12 @@@ static void bond_miimon_commit(struct b
  
  		case BOND_LINK_UP:
  			slave->link = BOND_LINK_UP;
 -			slave->last_link_up = jiffies;
 +			slave->jiffies = jiffies;
  
- 			if (bond->params.mode == BOND_MODE_8023AD) {
+ 			if (BOND_MODE(bond) == BOND_MODE_8023AD) {
  				/* prevent it from being the active one */
  				bond_set_backup_slave(slave);
- 			} else if (bond->params.mode != BOND_MODE_ACTIVEBACKUP) {
+ 			} else if (BOND_MODE(bond) != BOND_MODE_ACTIVEBACKUP) {
  				/* make it immediately active */
  				bond_set_active_slave(slave);
  			} else if (slave != bond->primary_slave) {
@@@ -2307,9 -2034,10 +2390,16 @@@
  
  			slave->link = BOND_LINK_DOWN;
  
++<<<<<<< HEAD
 +			if (bond->params.mode == BOND_MODE_ACTIVEBACKUP ||
 +			    bond->params.mode == BOND_MODE_8023AD)
 +				bond_set_slave_inactive_flags(slave);
++=======
+ 			if (BOND_MODE(bond) == BOND_MODE_ACTIVEBACKUP ||
+ 			    BOND_MODE(bond) == BOND_MODE_8023AD)
+ 				bond_set_slave_inactive_flags(slave,
+ 							      BOND_SLAVE_NOTIFY_NOW);
++>>>>>>> 01844098ecd9 (bonding: create a macro for bond mode and use it)
  
  			pr_info("%s: link status definitely down for interface %s, disabling it\n",
  				bond->dev->name, slave->dev->name);
@@@ -3366,9 -3124,10 +3456,9 @@@ static int bond_open(struct net_device 
  		/* bond_alb_initialize must be called before the timer
  		 * is started.
  		 */
- 		if (bond_alb_initialize(bond, (bond->params.mode == BOND_MODE_ALB)))
+ 		if (bond_alb_initialize(bond, (BOND_MODE(bond) == BOND_MODE_ALB)))
  			return -ENOMEM;
 -		if (bond->params.tlb_dynamic_lb)
 -			queue_delayed_work(bond->wq, &bond->alb_work, 0);
 +		queue_delayed_work(bond->wq, &bond->alb_work, 0);
  	}
  
  	if (bond->params.miimon)  /* link check interval, in milliseconds. */
@@@ -3376,11 -3135,10 +3466,11 @@@
  
  	if (bond->params.arp_interval) {  /* arp interval, in milliseconds. */
  		queue_delayed_work(bond->wq, &bond->arp_work, 0);
 -		bond->recv_probe = bond_arp_rcv;
 +		if (bond->params.arp_validate)
 +			bond->recv_probe = bond_arp_rcv;
  	}
  
- 	if (bond->params.mode == BOND_MODE_8023AD) {
+ 	if (BOND_MODE(bond) == BOND_MODE_8023AD) {
  		queue_delayed_work(bond->wq, &bond->ad_work, 0);
  		/* register to receive LACPDUs */
  		bond->recv_probe = bond_3ad_lacpdu_recv;
@@@ -3757,12 -3492,12 +3847,12 @@@ unwind
  static int bond_set_mac_address(struct net_device *bond_dev, void *addr)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
 -	struct slave *slave, *rollback_slave;
  	struct sockaddr *sa = addr, tmp_sa;
 -	struct list_head *iter;
 +	struct slave *slave, *stop_at;
  	int res = 0;
 +	int i;
  
- 	if (bond->params.mode == BOND_MODE_ALB)
+ 	if (BOND_MODE(bond) == BOND_MODE_ALB)
  		return bond_alb_set_mac_address(bond_dev, addr);
  
  
@@@ -4060,12 -3788,11 +4150,12 @@@ static netdev_tx_t __bond_start_xmit(st
  {
  	struct bonding *bond = netdev_priv(dev);
  
 -	if (bond_should_override_tx_queue(bond) &&
 -	    !bond_slave_override(bond, skb))
 -		return NETDEV_TX_OK;
 +	if (TX_QUEUE_OVERRIDE(bond->params.mode)) {
 +		if (!bond_slave_override(bond, skb))
 +			return NETDEV_TX_OK;
 +	}
  
- 	switch (bond->params.mode) {
+ 	switch (BOND_MODE(bond)) {
  	case BOND_MODE_ROUNDROBIN:
  		return bond_xmit_roundrobin(skb, dev);
  	case BOND_MODE_ACTIVEBACKUP:
@@@ -4082,9 -3810,9 +4172,9 @@@
  	default:
  		/* Should never happen, mode already checked */
  		pr_err("%s: Error: Unknown bonding mode %d\n",
- 		       dev->name, bond->params.mode);
+ 		       dev->name, BOND_MODE(bond));
  		WARN_ON_ONCE(1);
 -		dev_kfree_skb_any(skb);
 +		kfree_skb(skb);
  		return NETDEV_TX_OK;
  	}
  }
diff --cc drivers/net/bonding/bond_netlink.c
index 40e7b1cb4aea,5ab3c1847e67..000000000000
--- a/drivers/net/bonding/bond_netlink.c
+++ b/drivers/net/bonding/bond_netlink.c
@@@ -20,6 -21,57 +20,60 @@@
  #include <net/rtnetlink.h>
  #include "bonding.h"
  
++<<<<<<< HEAD
++=======
+ static size_t bond_get_slave_size(const struct net_device *bond_dev,
+ 				  const struct net_device *slave_dev)
+ {
+ 	return nla_total_size(sizeof(u8)) +	/* IFLA_BOND_SLAVE_STATE */
+ 		nla_total_size(sizeof(u8)) +	/* IFLA_BOND_SLAVE_MII_STATUS */
+ 		nla_total_size(sizeof(u32)) +	/* IFLA_BOND_SLAVE_LINK_FAILURE_COUNT */
+ 		nla_total_size(MAX_ADDR_LEN) +	/* IFLA_BOND_SLAVE_PERM_HWADDR */
+ 		nla_total_size(sizeof(u16)) +	/* IFLA_BOND_SLAVE_QUEUE_ID */
+ 		nla_total_size(sizeof(u16)) +	/* IFLA_BOND_SLAVE_AD_AGGREGATOR_ID */
+ 		0;
+ }
+ 
+ static int bond_fill_slave_info(struct sk_buff *skb,
+ 				const struct net_device *bond_dev,
+ 				const struct net_device *slave_dev)
+ {
+ 	struct slave *slave = bond_slave_get_rtnl(slave_dev);
+ 
+ 	if (nla_put_u8(skb, IFLA_BOND_SLAVE_STATE, bond_slave_state(slave)))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u8(skb, IFLA_BOND_SLAVE_MII_STATUS, slave->link))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u32(skb, IFLA_BOND_SLAVE_LINK_FAILURE_COUNT,
+ 			slave->link_failure_count))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put(skb, IFLA_BOND_SLAVE_PERM_HWADDR,
+ 		    slave_dev->addr_len, slave->perm_hwaddr))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u16(skb, IFLA_BOND_SLAVE_QUEUE_ID, slave->queue_id))
+ 		goto nla_put_failure;
+ 
+ 	if (BOND_MODE(slave->bond) == BOND_MODE_8023AD) {
+ 		const struct aggregator *agg;
+ 
+ 		agg = SLAVE_AD_INFO(slave)->port.aggregator;
+ 		if (agg)
+ 			if (nla_put_u16(skb, IFLA_BOND_SLAVE_AD_AGGREGATOR_ID,
+ 					agg->aggregator_identifier))
+ 				goto nla_put_failure;
+ 	}
+ 
+ 	return 0;
+ 
+ nla_put_failure:
+ 	return -EMSGSIZE;
+ }
+ 
++>>>>>>> 01844098ecd9 (bonding: create a macro for bond mode and use it)
  static const struct nla_policy bond_policy[IFLA_BOND_MAX + 1] = {
  	[IFLA_BOND_MODE]		= { .type = NLA_U8 },
  	[IFLA_BOND_ACTIVE_SLAVE]	= { .type = NLA_U32 },
@@@ -91,11 -403,139 +145,143 @@@ static int bond_fill_info(struct sk_buf
  {
  	struct bonding *bond = netdev_priv(bond_dev);
  	struct net_device *slave_dev = bond_option_active_slave_get(bond);
 -	struct nlattr *targets;
 -	unsigned int packets_per_slave;
 -	int i, targets_added;
  
++<<<<<<< HEAD
 +	if (nla_put_u8(skb, IFLA_BOND_MODE, bond->params.mode) ||
 +	    (slave_dev &&
 +	     nla_put_u32(skb, IFLA_BOND_ACTIVE_SLAVE, slave_dev->ifindex)))
 +		goto nla_put_failure;
++=======
+ 	if (nla_put_u8(skb, IFLA_BOND_MODE, BOND_MODE(bond)))
+ 		goto nla_put_failure;
+ 
+ 	if (slave_dev &&
+ 	    nla_put_u32(skb, IFLA_BOND_ACTIVE_SLAVE, slave_dev->ifindex))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u32(skb, IFLA_BOND_MIIMON, bond->params.miimon))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u32(skb, IFLA_BOND_UPDELAY,
+ 			bond->params.updelay * bond->params.miimon))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u32(skb, IFLA_BOND_DOWNDELAY,
+ 			bond->params.downdelay * bond->params.miimon))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u8(skb, IFLA_BOND_USE_CARRIER, bond->params.use_carrier))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u32(skb, IFLA_BOND_ARP_INTERVAL, bond->params.arp_interval))
+ 		goto nla_put_failure;
+ 
+ 	targets = nla_nest_start(skb, IFLA_BOND_ARP_IP_TARGET);
+ 	if (!targets)
+ 		goto nla_put_failure;
+ 
+ 	targets_added = 0;
+ 	for (i = 0; i < BOND_MAX_ARP_TARGETS; i++) {
+ 		if (bond->params.arp_targets[i]) {
+ 			nla_put_be32(skb, i, bond->params.arp_targets[i]);
+ 			targets_added = 1;
+ 		}
+ 	}
+ 
+ 	if (targets_added)
+ 		nla_nest_end(skb, targets);
+ 	else
+ 		nla_nest_cancel(skb, targets);
+ 
+ 	if (nla_put_u32(skb, IFLA_BOND_ARP_VALIDATE, bond->params.arp_validate))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u32(skb, IFLA_BOND_ARP_ALL_TARGETS,
+ 			bond->params.arp_all_targets))
+ 		goto nla_put_failure;
+ 
+ 	if (bond->primary_slave &&
+ 	    nla_put_u32(skb, IFLA_BOND_PRIMARY,
+ 			bond->primary_slave->dev->ifindex))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u8(skb, IFLA_BOND_PRIMARY_RESELECT,
+ 		       bond->params.primary_reselect))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u8(skb, IFLA_BOND_FAIL_OVER_MAC,
+ 		       bond->params.fail_over_mac))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u8(skb, IFLA_BOND_XMIT_HASH_POLICY,
+ 		       bond->params.xmit_policy))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u32(skb, IFLA_BOND_RESEND_IGMP,
+ 		        bond->params.resend_igmp))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u8(skb, IFLA_BOND_NUM_PEER_NOTIF,
+ 		       bond->params.num_peer_notif))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u8(skb, IFLA_BOND_ALL_SLAVES_ACTIVE,
+ 		       bond->params.all_slaves_active))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u32(skb, IFLA_BOND_MIN_LINKS,
+ 			bond->params.min_links))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u32(skb, IFLA_BOND_LP_INTERVAL,
+ 			bond->params.lp_interval))
+ 		goto nla_put_failure;
+ 
+ 	packets_per_slave = bond->params.packets_per_slave;
+ 	if (nla_put_u32(skb, IFLA_BOND_PACKETS_PER_SLAVE,
+ 			packets_per_slave))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u8(skb, IFLA_BOND_AD_LACP_RATE,
+ 		       bond->params.lacp_fast))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u8(skb, IFLA_BOND_AD_SELECT,
+ 		       bond->params.ad_select))
+ 		goto nla_put_failure;
+ 
+ 	if (BOND_MODE(bond) == BOND_MODE_8023AD) {
+ 		struct ad_info info;
+ 
+ 		if (!bond_3ad_get_active_agg_info(bond, &info)) {
+ 			struct nlattr *nest;
+ 
+ 			nest = nla_nest_start(skb, IFLA_BOND_AD_INFO);
+ 			if (!nest)
+ 				goto nla_put_failure;
+ 
+ 			if (nla_put_u16(skb, IFLA_BOND_AD_INFO_AGGREGATOR,
+ 					info.aggregator_id))
+ 				goto nla_put_failure;
+ 			if (nla_put_u16(skb, IFLA_BOND_AD_INFO_NUM_PORTS,
+ 					info.ports))
+ 				goto nla_put_failure;
+ 			if (nla_put_u16(skb, IFLA_BOND_AD_INFO_ACTOR_KEY,
+ 					info.actor_key))
+ 				goto nla_put_failure;
+ 			if (nla_put_u16(skb, IFLA_BOND_AD_INFO_PARTNER_KEY,
+ 					info.partner_key))
+ 				goto nla_put_failure;
+ 			if (nla_put(skb, IFLA_BOND_AD_INFO_PARTNER_MAC,
+ 				    sizeof(info.partner_system),
+ 				    &info.partner_system))
+ 				goto nla_put_failure;
+ 
+ 			nla_nest_end(skb, nest);
+ 		}
+ 	}
+ 
++>>>>>>> 01844098ecd9 (bonding: create a macro for bond mode and use it)
  	return 0;
  
  nla_put_failure:
diff --cc drivers/net/bonding/bond_procfs.c
index 96f629d77b41,b215b479bb3a..000000000000
--- a/drivers/net/bonding/bond_procfs.c
+++ b/drivers/net/bonding/bond_procfs.c
@@@ -62,23 -72,26 +62,39 @@@ static void bond_info_show_master(struc
  	curr = rcu_dereference(bond->curr_active_slave);
  
  	seq_printf(seq, "Bonding Mode: %s",
- 		   bond_mode_name(bond->params.mode));
+ 		   bond_mode_name(BOND_MODE(bond)));
  
++<<<<<<< HEAD
 +	if (bond->params.mode == BOND_MODE_ACTIVEBACKUP &&
 +	    bond->params.fail_over_mac)
 +		seq_printf(seq, " (fail_over_mac %s)",
 +		   fail_over_mac_tbl[bond->params.fail_over_mac].modename);
 +
 +	seq_printf(seq, "\n");
 +
 +	if (bond->params.mode == BOND_MODE_XOR ||
 +		bond->params.mode == BOND_MODE_8023AD) {
++=======
+ 	if (BOND_MODE(bond) == BOND_MODE_ACTIVEBACKUP &&
+ 	    bond->params.fail_over_mac) {
+ 		optval = bond_opt_get_val(BOND_OPT_FAIL_OVER_MAC,
+ 					  bond->params.fail_over_mac);
+ 		seq_printf(seq, " (fail_over_mac %s)", optval->string);
+ 	}
+ 
+ 	seq_printf(seq, "\n");
+ 
+ 	if (BOND_MODE(bond) == BOND_MODE_XOR ||
+ 		BOND_MODE(bond) == BOND_MODE_8023AD) {
+ 		optval = bond_opt_get_val(BOND_OPT_XMIT_HASH,
+ 					  bond->params.xmit_policy);
++>>>>>>> 01844098ecd9 (bonding: create a macro for bond mode and use it)
  		seq_printf(seq, "Transmit Hash Policy: %s (%d)\n",
 -			   optval->string, bond->params.xmit_policy);
 +			xmit_hashtype_tbl[bond->params.xmit_policy].modename,
 +			bond->params.xmit_policy);
  	}
  
 -	if (bond_uses_primary(bond)) {
 +	if (USES_PRIMARY(bond->params.mode)) {
  		seq_printf(seq, "Primary Slave: %s",
  			   (bond->primary_slave) ?
  			   bond->primary_slave->dev->name : "None");
@@@ -182,9 -188,9 +198,9 @@@ static void bond_info_show_slave(struc
  
  	seq_printf(seq, "Permanent HW addr: %pM\n", slave->perm_hwaddr);
  
- 	if (bond->params.mode == BOND_MODE_8023AD) {
+ 	if (BOND_MODE(bond) == BOND_MODE_8023AD) {
  		const struct aggregator *agg
 -			= SLAVE_AD_INFO(slave)->port.aggregator;
 +			= SLAVE_AD_INFO(slave).port.aggregator;
  
  		if (agg)
  			seq_printf(seq, "Aggregator ID: %d\n",
diff --cc drivers/net/bonding/bond_sysfs.c
index c7fd44189961,daed52f68ce1..000000000000
--- a/drivers/net/bonding/bond_sysfs.c
+++ b/drivers/net/bonding/bond_sysfs.c
@@@ -302,69 -212,16 +302,75 @@@ static ssize_t bonding_show_mode(struc
  				 struct device_attribute *attr, char *buf)
  {
  	struct bonding *bond = to_bond(d);
 -	const struct bond_opt_value *val;
  
++<<<<<<< HEAD
 +	return sprintf(buf, "%s %d\n",
 +			bond_mode_tbl[bond->params.mode].modename,
 +			bond->params.mode);
 +}
 +
 +static ssize_t bonding_store_mode(struct device *d,
 +				  struct device_attribute *attr,
 +				  const char *buf, size_t count)
 +{
 +	int new_value, ret = count;
 +	struct bonding *bond = to_bond(d);
 +
 +	if (!rtnl_trylock())
 +		return restart_syscall();
 +
 +	if (bond->dev->flags & IFF_UP) {
 +		pr_err("unable to update mode of %s because interface is up.\n",
 +		       bond->dev->name);
 +		ret = -EPERM;
 +		goto out;
 +	}
 +
 +	if (bond->slave_cnt > 0) {
 +		pr_err("unable to update mode of %s because it has slaves.\n",
 +			bond->dev->name);
 +		ret = -EPERM;
 +		goto out;
 +	}
 +
 +	new_value = bond_parse_parm(buf, bond_mode_tbl);
 +	if (new_value < 0)  {
 +		pr_err("%s: Ignoring invalid mode value %.*s.\n",
 +		       bond->dev->name, (int)strlen(buf) - 1, buf);
 +		ret = -EINVAL;
 +		goto out;
 +	}
 +	if ((new_value == BOND_MODE_ALB ||
 +	     new_value == BOND_MODE_TLB) &&
 +	    bond->params.arp_interval) {
 +		pr_err("%s: %s mode is incompatible with arp monitoring.\n",
 +		       bond->dev->name, bond_mode_tbl[new_value].modename);
 +		ret = -EINVAL;
 +		goto out;
 +	}
 +
 +	/* don't cache arp_validate between modes */
 +	bond->params.arp_validate = BOND_ARP_VALIDATE_NONE;
 +	bond->params.mode = new_value;
 +	bond_set_mode_ops(bond, bond->params.mode);
 +	pr_info("%s: setting mode to %s (%d).\n",
 +		bond->dev->name, bond_mode_tbl[new_value].modename,
 +		new_value);
 +out:
 +	rtnl_unlock();
 +	return ret;
++=======
+ 	val = bond_opt_get_val(BOND_OPT_MODE, BOND_MODE(bond));
+ 
+ 	return sprintf(buf, "%s %d\n", val->string, BOND_MODE(bond));
++>>>>>>> 01844098ecd9 (bonding: create a macro for bond mode and use it)
  }
  static DEVICE_ATTR(mode, S_IRUGO | S_IWUSR,
 -		   bonding_show_mode, bonding_sysfs_store_option);
 +		   bonding_show_mode, bonding_store_mode);
  
 -/* Show the bonding transmit hash method. */
 +/*
 + * Show and set the bonding transmit hash method.
 + */
  static ssize_t bonding_show_xmit_hash(struct device *d,
  				      struct device_attribute *attr,
  				      char *buf)
diff --cc drivers/net/bonding/bonding.h
index e1ca02f0b074,bb663a4db137..000000000000
--- a/drivers/net/bonding/bonding.h
+++ b/drivers/net/bonding/bonding.h
@@@ -71,12 -70,35 +71,39 @@@
  	set_fs(fs);			\
  	res; })
  
++<<<<<<< HEAD
++=======
+ #define BOND_MODE(bond) ((bond)->params.mode)
+ 
+ /* slave list primitives */
+ #define bond_slave_list(bond) (&(bond)->dev->adj_list.lower)
+ 
+ #define bond_has_slaves(bond) !list_empty(bond_slave_list(bond))
+ 
+ /* IMPORTANT: bond_first/last_slave can return NULL in case of an empty list */
+ #define bond_first_slave(bond) \
+ 	(bond_has_slaves(bond) ? \
+ 		netdev_adjacent_get_private(bond_slave_list(bond)->next) : \
+ 		NULL)
+ #define bond_last_slave(bond) \
+ 	(bond_has_slaves(bond) ? \
+ 		netdev_adjacent_get_private(bond_slave_list(bond)->prev) : \
+ 		NULL)
+ 
+ /* Caller must have rcu_read_lock */
+ #define bond_first_slave_rcu(bond) \
+ 	netdev_lower_get_first_private_rcu(bond->dev)
+ 
+ #define bond_is_first_slave(bond, pos) (pos == bond_first_slave(bond))
+ #define bond_is_last_slave(bond, pos) (pos == bond_last_slave(bond))
+ 
++>>>>>>> 01844098ecd9 (bonding: create a macro for bond mode and use it)
  /**
 - * bond_for_each_slave - iterate over all slaves
 - * @bond:	the bond holding this list
 - * @pos:	current slave
 - * @iter:	list_head * iterator
 + * bond_for_each_slave_from - iterate the slaves list from a starting point
 + * @bond:	the bond holding this list.
 + * @pos:	current slave.
 + * @cnt:	counter for max number of moves
 + * @start:	starting point.
   *
   * Caller must hold bond->lock
   */
@@@ -285,10 -271,33 +312,40 @@@ static inline struct bonding *bond_get_
  	return slave->bond;
  }
  
++<<<<<<< HEAD
 +static inline bool bond_is_lb(const struct bonding *bond)
 +{
 +	return (bond->params.mode == BOND_MODE_TLB ||
 +		bond->params.mode == BOND_MODE_ALB);
++=======
+ static inline bool bond_should_override_tx_queue(struct bonding *bond)
+ {
+ 	return BOND_MODE(bond) == BOND_MODE_ACTIVEBACKUP ||
+ 	       BOND_MODE(bond) == BOND_MODE_ROUNDROBIN;
+ }
+ 
+ static inline bool bond_is_lb(const struct bonding *bond)
+ {
+ 	return BOND_MODE(bond) == BOND_MODE_TLB ||
+ 	       BOND_MODE(bond) == BOND_MODE_ALB;
+ }
+ 
+ static inline bool bond_mode_uses_arp(int mode)
+ {
+ 	return mode != BOND_MODE_8023AD && mode != BOND_MODE_TLB &&
+ 	       mode != BOND_MODE_ALB;
+ }
+ 
+ static inline bool bond_mode_uses_primary(int mode)
+ {
+ 	return mode == BOND_MODE_ACTIVEBACKUP || mode == BOND_MODE_TLB ||
+ 	       mode == BOND_MODE_ALB;
+ }
+ 
+ static inline bool bond_uses_primary(struct bonding *bond)
+ {
+ 	return bond_mode_uses_primary(BOND_MODE(bond));
++>>>>>>> 01844098ecd9 (bonding: create a macro for bond mode and use it)
  }
  
  static inline void bond_set_active_slave(struct slave *slave)
* Unmerged path drivers/net/bonding/bond_sysfs_slave.c
diff --git a/drivers/net/bonding/bond_alb.c b/drivers/net/bonding/bond_alb.c
index d3256b311be3..09a34c271c8f 100644
--- a/drivers/net/bonding/bond_alb.c
+++ b/drivers/net/bonding/bond_alb.c
@@ -1027,7 +1027,7 @@ static int alb_set_slave_mac_addr(struct slave *slave, u8 addr[])
 	struct net_device *dev = slave->dev;
 	struct sockaddr s_addr;
 
-	if (slave->bond->params.mode == BOND_MODE_TLB) {
+	if (BOND_MODE(slave->bond) == BOND_MODE_TLB) {
 		memcpy(dev->dev_addr, addr, dev->addr_len);
 		return 0;
 	}
@@ -1682,7 +1682,7 @@ void bond_alb_handle_active_change(struct bonding *bond, struct slave *new_slave
 	/* in TLB mode, the slave might flip down/up with the old dev_addr,
 	 * and thus filter bond->dev_addr's packets, so force bond's mac
 	 */
-	if (bond->params.mode == BOND_MODE_TLB) {
+	if (BOND_MODE(bond) == BOND_MODE_TLB) {
 		struct sockaddr sa;
 		u8 tmp_addr[ETH_ALEN];
 
diff --git a/drivers/net/bonding/bond_debugfs.c b/drivers/net/bonding/bond_debugfs.c
index 5fc4c2351478..717275fb9e7c 100644
--- a/drivers/net/bonding/bond_debugfs.c
+++ b/drivers/net/bonding/bond_debugfs.c
@@ -23,7 +23,7 @@ static int bond_debug_rlb_hash_show(struct seq_file *m, void *v)
 	struct rlb_client_info *client_info;
 	u32 hash_index;
 
-	if (bond->params.mode != BOND_MODE_ALB)
+	if (BOND_MODE(bond) != BOND_MODE_ALB)
 		return 0;
 
 	seq_printf(m, "SourceIP        DestinationIP   "
* Unmerged path drivers/net/bonding/bond_main.c
* Unmerged path drivers/net/bonding/bond_netlink.c
* Unmerged path drivers/net/bonding/bond_procfs.c
* Unmerged path drivers/net/bonding/bond_sysfs.c
* Unmerged path drivers/net/bonding/bond_sysfs_slave.c
* Unmerged path drivers/net/bonding/bonding.h
