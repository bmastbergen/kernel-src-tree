rtnetlink: pass link_net to the newlink handler

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Nicolas Dichtel <nicolas.dichtel@6wind.com>
commit 7b4ce694b2030e7bb41f938cba6a0be4947a5aa5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/7b4ce694.failed

When IFLA_LINK_NETNSID is used, the netdevice should be built in this link netns
and moved at the end to another netns (pointed by the socket netns or
IFLA_NET_NS_[PID|FD]).

Existing user of the newlink handler will use the netns argument (src_net) to
find a link netdevice or to check some other information into the link netns.
For example, to find a netdevice, two information are required: an ifindex
(usually from IFLA_LINK) and a netns (this link netns).

Note: when using IFLA_LINK_NETNSID and IFLA_NET_NS_[PID|FD], a user may create a
netdevice that stands in netnsX and with its link part in netnsY, by sending a
rtnl message from netnsZ.

	Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7b4ce694b2030e7bb41f938cba6a0be4947a5aa5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/rtnetlink.c
diff --cc net/core/rtnetlink.c
index 187818c8949a,fedd7ab4085a..000000000000
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@@ -1919,20 -2147,39 +1919,36 @@@ replay
  
  		dev->ifindex = ifm->ifi_index;
  
++<<<<<<< HEAD
 +		if (ops->newlink)
 +			err = ops->newlink(net, dev, tb, data);
 +		else
++=======
+ 		if (ops->newlink) {
+ 			err = ops->newlink(link_net ? : net, dev, tb, data);
+ 			/* Drivers should call free_netdev() in ->destructor
+ 			 * and unregister it on failure after registration
+ 			 * so that device could be finally freed in rtnl_unlock.
+ 			 */
+ 			if (err < 0) {
+ 				/* If device is not registered at all, free it now */
+ 				if (dev->reg_state == NETREG_UNINITIALIZED)
+ 					free_netdev(dev);
+ 				goto out;
+ 			}
+ 		} else {
++>>>>>>> 7b4ce694b203 (rtnetlink: pass link_net to the newlink handler)
  			err = register_netdevice(dev);
 -			if (err < 0) {
 -				free_netdev(dev);
 -				goto out;
 -			}
 -		}
 -		err = rtnl_configure_link(dev, ifm);
 -		if (err < 0) {
 -			unregister_netdevice(dev);
 +
 +		if (err < 0 && !IS_ERR(dev))
 +			free_netdev(dev);
 +		if (err < 0)
  			goto out;
 -		}
  
 -		if (link_net) {
 -			err = dev_change_net_namespace(dev, dest_net, ifname);
 -			if (err < 0)
 -				unregister_netdevice(dev);
 -		}
 +		err = rtnl_configure_link(dev, ifm);
 +		if (err < 0)
 +			unregister_netdevice(dev);
  out:
 -		if (link_net)
 -			put_net(link_net);
  		put_net(dest_net);
  		return err;
  	}
* Unmerged path net/core/rtnetlink.c
