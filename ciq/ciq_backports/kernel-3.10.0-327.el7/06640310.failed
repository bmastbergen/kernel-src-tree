cxgb4: Ripping out old hard-wired initialization code in driver

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Hariprasad Shenai <hariprasad@chelsio.com>
commit 06640310b43c9b3185629e2b919c0800486b0d8e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/06640310.failed

Removing old hard-wired initialization code in the driver, which is no longer
used. Also deprecating few module parameters.

	Signed-off-by: Hariprasad Shenai <hariprasad@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 06640310b43c9b3185629e2b919c0800486b0d8e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
#	drivers/net/ethernet/chelsio/cxgb4/sge.c
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
index eacea363ec4e,082a596a4264..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@@ -77,99 -79,6 +77,102 @@@
  #define DRV_VERSION "2.0.0-ko"
  #define DRV_DESC "Chelsio T4/T5 Network Driver"
  
++<<<<<<< HEAD
 +/*
 + * Max interrupt hold-off timer value in us.  Queues fall back to this value
 + * under extreme memory pressure so it's largish to give the system time to
 + * recover.
 + */
 +#define MAX_SGE_TIMERVAL 200U
 +
 +enum {
 +	/*
 +	 * Physical Function provisioning constants.
 +	 */
 +	PFRES_NVI = 4,			/* # of Virtual Interfaces */
 +	PFRES_NETHCTRL = 128,		/* # of EQs used for ETH or CTRL Qs */
 +	PFRES_NIQFLINT = 128,		/* # of ingress Qs/w Free List(s)/intr
 +					 */
 +	PFRES_NEQ = 256,		/* # of egress queues */
 +	PFRES_NIQ = 0,			/* # of ingress queues */
 +	PFRES_TC = 0,			/* PCI-E traffic class */
 +	PFRES_NEXACTF = 128,		/* # of exact MPS filters */
 +
 +	PFRES_R_CAPS = FW_CMD_CAP_PF,
 +	PFRES_WX_CAPS = FW_CMD_CAP_PF,
 +
 +#ifdef CONFIG_PCI_IOV
 +	/*
 +	 * Virtual Function provisioning constants.  We need two extra Ingress
 +	 * Queues with Interrupt capability to serve as the VF's Firmware
 +	 * Event Queue and Forwarded Interrupt Queue (when using MSI mode) --
 +	 * neither will have Free Lists associated with them).  For each
 +	 * Ethernet/Control Egress Queue and for each Free List, we need an
 +	 * Egress Context.
 +	 */
 +	VFRES_NPORTS = 1,		/* # of "ports" per VF */
 +	VFRES_NQSETS = 2,		/* # of "Queue Sets" per VF */
 +
 +	VFRES_NVI = VFRES_NPORTS,	/* # of Virtual Interfaces */
 +	VFRES_NETHCTRL = VFRES_NQSETS,	/* # of EQs used for ETH or CTRL Qs */
 +	VFRES_NIQFLINT = VFRES_NQSETS+2,/* # of ingress Qs/w Free List(s)/intr */
 +	VFRES_NEQ = VFRES_NQSETS*2,	/* # of egress queues */
 +	VFRES_NIQ = 0,			/* # of non-fl/int ingress queues */
 +	VFRES_TC = 0,			/* PCI-E traffic class */
 +	VFRES_NEXACTF = 16,		/* # of exact MPS filters */
 +
 +	VFRES_R_CAPS = FW_CMD_CAP_DMAQ|FW_CMD_CAP_VF|FW_CMD_CAP_PORT,
 +	VFRES_WX_CAPS = FW_CMD_CAP_DMAQ|FW_CMD_CAP_VF,
 +#endif
 +};
 +
 +/*
 + * Provide a Port Access Rights Mask for the specified PF/VF.  This is very
 + * static and likely not to be useful in the long run.  We really need to
 + * implement some form of persistent configuration which the firmware
 + * controls.
 + */
 +static unsigned int pfvfres_pmask(struct adapter *adapter,
 +				  unsigned int pf, unsigned int vf)
 +{
 +	unsigned int portn, portvec;
 +
 +	/*
 +	 * Give PF's access to all of the ports.
 +	 */
 +	if (vf == 0)
 +		return FW_PFVF_CMD_PMASK_MASK;
 +
 +	/*
 +	 * For VFs, we'll assign them access to the ports based purely on the
 +	 * PF.  We assign active ports in order, wrapping around if there are
 +	 * fewer active ports than PFs: e.g. active port[pf % nports].
 +	 * Unfortunately the adapter's port_info structs haven't been
 +	 * initialized yet so we have to compute this.
 +	 */
 +	if (adapter->params.nports == 0)
 +		return 0;
 +
 +	portn = pf % adapter->params.nports;
 +	portvec = adapter->params.portvec;
 +	for (;;) {
 +		/*
 +		 * Isolate the lowest set bit in the port vector.  If we're at
 +		 * the port number that we want, return that as the pmask.
 +		 * otherwise mask that bit out of the port vector and
 +		 * decrement our port number ...
 +		 */
 +		unsigned int pmask = portvec ^ (portvec & (portvec-1));
 +		if (portn == 0)
 +			return pmask;
 +		portn--;
 +		portvec &= ~pmask;
 +	}
 +	/*NOTREACHED*/
 +}
 +
++=======
++>>>>>>> 06640310b43c (cxgb4: Ripping out old hard-wired initialization code in driver)
  enum {
  	MAX_TXQ_ENTRIES      = 16384,
  	MAX_CTRL_TXQ_ENTRIES = 1024,
@@@ -417,32 -240,22 +423,48 @@@ module_param_array(num_vf, uint, NULL, 
  MODULE_PARM_DESC(num_vf, "number of VFs for each of PFs 0-3");
  #endif
  
++<<<<<<< HEAD
 +/*
 + * The filter TCAM has a fixed portion and a variable portion.  The fixed
 + * portion can match on source/destination IP IPv4/IPv6 addresses and TCP/UDP
 + * ports.  The variable portion is 36 bits which can include things like Exact
 + * Match MAC Index (9 bits), Ether Type (16 bits), IP Protocol (8 bits),
 + * [Inner] VLAN Tag (17 bits), etc. which, if all were somehow selected, would
 + * far exceed the 36-bit budget for this "compressed" header portion of the
 + * filter.  Thus, we have a scarce resource which must be carefully managed.
 + *
 + * By default we set this up to mostly match the set of filter matching
 + * capabilities of T3 but with accommodations for some of T4's more
 + * interesting features:
 + *
 + *   { IP Fragment (1), MPS Match Type (3), IP Protocol (8),
 + *     [Inner] VLAN (17), Port (3), FCoE (1) }
 + */
 +enum {
 +	TP_VLAN_PRI_MAP_DEFAULT = HW_TPL_FR_MT_PR_IV_P_FC,
 +	TP_VLAN_PRI_MAP_FIRST = FCOE_S,
 +	TP_VLAN_PRI_MAP_LAST = FRAGMENTATION_S,
 +};
 +
 +static unsigned int tp_vlan_pri_map = TP_VLAN_PRI_MAP_DEFAULT;
++=======
+ /* TX Queue select used to determine what algorithm to use for selecting TX
+  * queue. Select between the kernel provided function (select_queue=0) or user
+  * cxgb_select_queue function (select_queue=1)
+  *
+  * Default: select_queue=0
+  */
+ static int select_queue;
+ module_param(select_queue, int, 0644);
+ MODULE_PARM_DESC(select_queue,
+ 		 "Select between kernel provided method of selecting or driver method of selecting TX queue. Default is kernel method.");
+ 
+ static unsigned int tp_vlan_pri_map = HW_TPL_FR_MT_PR_IV_P_FC;
++>>>>>>> 06640310b43c (cxgb4: Ripping out old hard-wired initialization code in driver)
  
  module_param(tp_vlan_pri_map, uint, 0644);
- MODULE_PARM_DESC(tp_vlan_pri_map, "global compressed filter configuration");
+ MODULE_PARM_DESC(tp_vlan_pri_map, "global compressed filter configuration, "
+ 		 "deprecated parameter");
  
  static struct dentry *cxgb4_debugfs_root;
  
@@@ -5236,249 -5134,6 +5255,252 @@@ bye
  	return ret;
  }
  
++<<<<<<< HEAD
 +/*
 + * Attempt to initialize the adapter via hard-coded, driver supplied
 + * parameters ...
 + */
 +static int adap_init0_no_config(struct adapter *adapter, int reset)
 +{
 +	struct sge *s = &adapter->sge;
 +	struct fw_caps_config_cmd caps_cmd;
 +	u32 v;
 +	int i, ret;
 +
 +	/*
 +	 * Reset device if necessary
 +	 */
 +	if (reset) {
 +		ret = t4_fw_reset(adapter, adapter->mbox,
 +				  PIORSTMODE | PIORST);
 +		if (ret < 0)
 +			goto bye;
 +	}
 +
 +	/*
 +	 * Get device capabilities and select which we'll be using.
 +	 */
 +	memset(&caps_cmd, 0, sizeof(caps_cmd));
 +	caps_cmd.op_to_write = htonl(FW_CMD_OP(FW_CAPS_CONFIG_CMD) |
 +				     FW_CMD_REQUEST | FW_CMD_READ);
 +	caps_cmd.cfvalid_to_len16 = htonl(FW_LEN16(caps_cmd));
 +	ret = t4_wr_mbox(adapter, adapter->mbox, &caps_cmd, sizeof(caps_cmd),
 +			 &caps_cmd);
 +	if (ret < 0)
 +		goto bye;
 +
 +	if (caps_cmd.niccaps & htons(FW_CAPS_CONFIG_NIC_VM)) {
 +		if (!vf_acls)
 +			caps_cmd.niccaps ^= htons(FW_CAPS_CONFIG_NIC_VM);
 +		else
 +			caps_cmd.niccaps = htons(FW_CAPS_CONFIG_NIC_VM);
 +	} else if (vf_acls) {
 +		dev_err(adapter->pdev_dev, "virtualization ACLs not supported");
 +		goto bye;
 +	}
 +	caps_cmd.op_to_write = htonl(FW_CMD_OP(FW_CAPS_CONFIG_CMD) |
 +			      FW_CMD_REQUEST | FW_CMD_WRITE);
 +	ret = t4_wr_mbox(adapter, adapter->mbox, &caps_cmd, sizeof(caps_cmd),
 +			 NULL);
 +	if (ret < 0)
 +		goto bye;
 +
 +	/*
 +	 * Tweak configuration based on system architecture, module
 +	 * parameters, etc.
 +	 */
 +	ret = adap_init0_tweaks(adapter);
 +	if (ret < 0)
 +		goto bye;
 +
 +	/*
 +	 * Select RSS Global Mode we want to use.  We use "Basic Virtual"
 +	 * mode which maps each Virtual Interface to its own section of
 +	 * the RSS Table and we turn on all map and hash enables ...
 +	 */
 +	adapter->flags |= RSS_TNLALLLOOKUP;
 +	ret = t4_config_glbl_rss(adapter, adapter->mbox,
 +				 FW_RSS_GLB_CONFIG_CMD_MODE_BASICVIRTUAL,
 +				 FW_RSS_GLB_CONFIG_CMD_TNLMAPEN |
 +				 FW_RSS_GLB_CONFIG_CMD_HASHTOEPLITZ |
 +				 ((adapter->flags & RSS_TNLALLLOOKUP) ?
 +					FW_RSS_GLB_CONFIG_CMD_TNLALLLKP : 0));
 +	if (ret < 0)
 +		goto bye;
 +
 +	/*
 +	 * Set up our own fundamental resource provisioning ...
 +	 */
 +	ret = t4_cfg_pfvf(adapter, adapter->mbox, adapter->fn, 0,
 +			  PFRES_NEQ, PFRES_NETHCTRL,
 +			  PFRES_NIQFLINT, PFRES_NIQ,
 +			  PFRES_TC, PFRES_NVI,
 +			  FW_PFVF_CMD_CMASK_MASK,
 +			  pfvfres_pmask(adapter, adapter->fn, 0),
 +			  PFRES_NEXACTF,
 +			  PFRES_R_CAPS, PFRES_WX_CAPS);
 +	if (ret < 0)
 +		goto bye;
 +
 +	/*
 +	 * Perform low level SGE initialization.  We need to do this before we
 +	 * send the firmware the INITIALIZE command because that will cause
 +	 * any other PF Drivers which are waiting for the Master
 +	 * Initialization to proceed forward.
 +	 */
 +	for (i = 0; i < SGE_NTIMERS - 1; i++)
 +		s->timer_val[i] = min(intr_holdoff[i], MAX_SGE_TIMERVAL);
 +	s->timer_val[SGE_NTIMERS - 1] = MAX_SGE_TIMERVAL;
 +	s->counter_val[0] = 1;
 +	for (i = 1; i < SGE_NCOUNTERS; i++)
 +		s->counter_val[i] = min(intr_cnt[i - 1],
 +					THRESHOLD_0_GET(THRESHOLD_0_MASK));
 +	t4_sge_init(adapter);
 +
 +#ifdef CONFIG_PCI_IOV
 +	/*
 +	 * Provision resource limits for Virtual Functions.  We currently
 +	 * grant them all the same static resource limits except for the Port
 +	 * Access Rights Mask which we're assigning based on the PF.  All of
 +	 * the static provisioning stuff for both the PF and VF really needs
 +	 * to be managed in a persistent manner for each device which the
 +	 * firmware controls.
 +	 */
 +	{
 +		int pf, vf;
 +
 +		for (pf = 0; pf < ARRAY_SIZE(num_vf); pf++) {
 +			if (num_vf[pf] <= 0)
 +				continue;
 +
 +			/* VF numbering starts at 1! */
 +			for (vf = 1; vf <= num_vf[pf]; vf++) {
 +				ret = t4_cfg_pfvf(adapter, adapter->mbox,
 +						  pf, vf,
 +						  VFRES_NEQ, VFRES_NETHCTRL,
 +						  VFRES_NIQFLINT, VFRES_NIQ,
 +						  VFRES_TC, VFRES_NVI,
 +						  FW_PFVF_CMD_CMASK_MASK,
 +						  pfvfres_pmask(
 +						  adapter, pf, vf),
 +						  VFRES_NEXACTF,
 +						  VFRES_R_CAPS, VFRES_WX_CAPS);
 +				if (ret < 0)
 +					dev_warn(adapter->pdev_dev,
 +						 "failed to "\
 +						 "provision pf/vf=%d/%d; "
 +						 "err=%d\n", pf, vf, ret);
 +			}
 +		}
 +	}
 +#endif
 +
 +	/*
 +	 * Set up the default filter mode.  Later we'll want to implement this
 +	 * via a firmware command, etc. ...  This needs to be done before the
 +	 * firmare initialization command ...  If the selected set of fields
 +	 * isn't equal to the default value, we'll need to make sure that the
 +	 * field selections will fit in the 36-bit budget.
 +	 */
 +	if (tp_vlan_pri_map != TP_VLAN_PRI_MAP_DEFAULT) {
 +		int j, bits = 0;
 +
 +		for (j = TP_VLAN_PRI_MAP_FIRST; j <= TP_VLAN_PRI_MAP_LAST; j++)
 +			switch (tp_vlan_pri_map & (1 << j)) {
 +			case 0:
 +				/* compressed filter field not enabled */
 +				break;
 +			case FCOE_F:
 +				bits +=  1;
 +				break;
 +			case PORT_F:
 +				bits +=  3;
 +				break;
 +			case VNIC_F:
 +				bits += 17;
 +				break;
 +			case VLAN_F:
 +				bits += 17;
 +				break;
 +			case TOS_F:
 +				bits +=  8;
 +				break;
 +			case PROTOCOL_F:
 +				bits +=  8;
 +				break;
 +			case ETHERTYPE_F:
 +				bits += 16;
 +				break;
 +			case MACMATCH_F:
 +				bits +=  9;
 +				break;
 +			case MPSHITTYPE_F:
 +				bits +=  3;
 +				break;
 +			case FRAGMENTATION_F:
 +				bits +=  1;
 +				break;
 +			}
 +
 +		if (bits > 36) {
 +			dev_err(adapter->pdev_dev,
 +				"tp_vlan_pri_map=%#x needs %d bits > 36;"\
 +				" using %#x\n", tp_vlan_pri_map, bits,
 +				TP_VLAN_PRI_MAP_DEFAULT);
 +			tp_vlan_pri_map = TP_VLAN_PRI_MAP_DEFAULT;
 +		}
 +	}
 +	v = tp_vlan_pri_map;
 +	t4_write_indirect(adapter, TP_PIO_ADDR_A, TP_PIO_DATA_A,
 +			  &v, 1, TP_VLAN_PRI_MAP_A);
 +
 +	/*
 +	 * We need Five Tuple Lookup mode to be set in TP_GLOBAL_CONFIG order
 +	 * to support any of the compressed filter fields above.  Newer
 +	 * versions of the firmware do this automatically but it doesn't hurt
 +	 * to set it here.  Meanwhile, we do _not_ need to set Lookup Every
 +	 * Packet in TP_INGRESS_CONFIG to support matching non-TCP packets
 +	 * since the firmware automatically turns this on and off when we have
 +	 * a non-zero number of filters active (since it does have a
 +	 * performance impact).
 +	 */
 +	if (tp_vlan_pri_map)
 +		t4_set_reg_field(adapter, TP_GLOBAL_CONFIG_A,
 +				 FIVETUPLELOOKUP_V(FIVETUPLELOOKUP_M),
 +				 FIVETUPLELOOKUP_V(FIVETUPLELOOKUP_M));
 +
 +	/*
 +	 * Tweak some settings.
 +	 */
 +	t4_write_reg(adapter, TP_SHIFT_CNT_A, SYNSHIFTMAX_V(6) |
 +		     RXTSHIFTMAXR1_V(4) | RXTSHIFTMAXR2_V(15) |
 +		     PERSHIFTBACKOFFMAX_V(8) | PERSHIFTMAX_V(8) |
 +		     KEEPALIVEMAXR1_V(4) | KEEPALIVEMAXR2_V(9));
 +
 +	/*
 +	 * Get basic stuff going by issuing the Firmware Initialize command.
 +	 * Note that this _must_ be after all PFVF commands ...
 +	 */
 +	ret = t4_fw_initialize(adapter, adapter->mbox);
 +	if (ret < 0)
 +		goto bye;
 +
 +	/*
 +	 * Return successfully!
 +	 */
 +	dev_info(adapter->pdev_dev, "Successfully configured using built-in "\
 +		 "driver parameters\n");
 +	return 0;
 +
 +	/*
 +	 * Something bad happened.  Return the error ...
 +	 */
 +bye:
 +	return ret;
 +}
 +
++=======
++>>>>>>> 06640310b43c (cxgb4: Ripping out old hard-wired initialization code in driver)
  static struct fw_info fw_info_array[] = {
  	{
  		.chip = CHELSIO_T4,
@@@ -5640,57 -5317,36 +5658,57 @@@ static int adap_init0(struct adapter *a
  		dev_info(adap->pdev_dev, "Coming up as MASTER: "\
  			 "Initializing adapter\n");
  
++<<<<<<< HEAD
 +		/*
 +		 * If the firmware doesn't support Configuration
 +		 * Files warn user and exit,
 +		 */
 +		if (ret < 0)
 +			dev_warn(adap->pdev_dev, "Firmware doesn't support "
 +				 "configuration file.\n");
 +		if (force_old_init)
 +			ret = adap_init0_no_config(adap, reset);
 +		else {
 +			/*
 +			 * Find out whether we're dealing with a version of
 +			 * the firmware which has configuration file support.
 +			 */
 +			params[0] = (FW_PARAMS_MNEM(FW_PARAMS_MNEM_DEV) |
 +				     FW_PARAMS_PARAM_X(FW_PARAMS_PARAM_DEV_CF));
 +			ret = t4_query_params(adap, adap->mbox, adap->fn, 0, 1,
 +					      params, val);
++=======
+ 		/* Find out whether we're dealing with a version of the
+ 		 * firmware which has configuration file support.
+ 		 */
+ 		params[0] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |
+ 			     FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_CF));
+ 		ret = t4_query_params(adap, adap->mbox, adap->fn, 0, 1,
+ 				      params, val);
++>>>>>>> 06640310b43c (cxgb4: Ripping out old hard-wired initialization code in driver)
+ 
+ 		/* If the firmware doesn't support Configuration Files,
+ 		 * return an error.
+ 		 */
+ 		if (ret < 0) {
+ 			dev_err(adap->pdev_dev, "firmware doesn't support "
+ 				"Firmware Configuration Files\n");
+ 			goto bye;
+ 		}
  
- 			/*
- 			 * If the firmware doesn't support Configuration
- 			 * Files, use the old Driver-based, hard-wired
- 			 * initialization.  Otherwise, try using the
- 			 * Configuration File support and fall back to the
- 			 * Driver-based initialization if there's no
- 			 * Configuration File found.
- 			 */
- 			if (ret < 0)
- 				ret = adap_init0_no_config(adap, reset);
- 			else {
- 				/*
- 				 * The firmware provides us with a memory
- 				 * buffer where we can load a Configuration
- 				 * File from the host if we want to override
- 				 * the Configuration File in flash.
- 				 */
- 
- 				ret = adap_init0_config(adap, reset);
- 				if (ret == -ENOENT) {
- 					dev_info(adap->pdev_dev,
- 					    "No Configuration File present "
- 					    "on adapter. Using hard-wired "
- 					    "configuration parameters.\n");
- 					ret = adap_init0_no_config(adap, reset);
- 				}
- 			}
+ 		/* The firmware provides us with a memory buffer where we can
+ 		 * load a Configuration File from the host if we want to
+ 		 * override the Configuration File in flash.
+ 		 */
+ 		ret = adap_init0_config(adap, reset);
+ 		if (ret == -ENOENT) {
+ 			dev_err(adap->pdev_dev, "no Configuration File "
+ 				"present on adapter.\n");
+ 			goto bye;
  		}
  		if (ret < 0) {
- 			dev_err(adap->pdev_dev,
- 				"could not initialize adapter, error %d\n",
- 				-ret);
+ 			dev_err(adap->pdev_dev, "could not initialize "
+ 				"adapter, error %d\n", -ret);
  			goto bye;
  		}
  	}
diff --cc drivers/net/ethernet/chelsio/cxgb4/sge.c
index b5afc3f0dd91,ca42e2e9dec9..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/sge.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/sge.c
@@@ -2818,99 -2814,38 +2805,109 @@@ static int t4_sge_init_soft(struct adap
  	 * Retrieve our RX interrupt holdoff timer values and counter
  	 * threshold values from the SGE parameters.
  	 */
 -	timer_value_0_and_1 = t4_read_reg(adap, SGE_TIMER_VALUE_0_AND_1_A);
 -	timer_value_2_and_3 = t4_read_reg(adap, SGE_TIMER_VALUE_2_AND_3_A);
 -	timer_value_4_and_5 = t4_read_reg(adap, SGE_TIMER_VALUE_4_AND_5_A);
 +	timer_value_0_and_1 = t4_read_reg(adap, SGE_TIMER_VALUE_0_AND_1);
 +	timer_value_2_and_3 = t4_read_reg(adap, SGE_TIMER_VALUE_2_AND_3);
 +	timer_value_4_and_5 = t4_read_reg(adap, SGE_TIMER_VALUE_4_AND_5);
  	s->timer_val[0] = core_ticks_to_us(adap,
 -		TIMERVALUE0_G(timer_value_0_and_1));
 +		TIMERVALUE0_GET(timer_value_0_and_1));
  	s->timer_val[1] = core_ticks_to_us(adap,
 -		TIMERVALUE1_G(timer_value_0_and_1));
 +		TIMERVALUE1_GET(timer_value_0_and_1));
  	s->timer_val[2] = core_ticks_to_us(adap,
 -		TIMERVALUE2_G(timer_value_2_and_3));
 +		TIMERVALUE2_GET(timer_value_2_and_3));
  	s->timer_val[3] = core_ticks_to_us(adap,
 -		TIMERVALUE3_G(timer_value_2_and_3));
 +		TIMERVALUE3_GET(timer_value_2_and_3));
  	s->timer_val[4] = core_ticks_to_us(adap,
 -		TIMERVALUE4_G(timer_value_4_and_5));
 +		TIMERVALUE4_GET(timer_value_4_and_5));
  	s->timer_val[5] = core_ticks_to_us(adap,
 -		TIMERVALUE5_G(timer_value_4_and_5));
 +		TIMERVALUE5_GET(timer_value_4_and_5));
 +
 +	ingress_rx_threshold = t4_read_reg(adap, SGE_INGRESS_RX_THRESHOLD);
 +	s->counter_val[0] = THRESHOLD_0_GET(ingress_rx_threshold);
 +	s->counter_val[1] = THRESHOLD_1_GET(ingress_rx_threshold);
 +	s->counter_val[2] = THRESHOLD_2_GET(ingress_rx_threshold);
 +	s->counter_val[3] = THRESHOLD_3_GET(ingress_rx_threshold);
 +
 +	return 0;
 +}
 +
++<<<<<<< HEAD
 +static int t4_sge_init_hard(struct adapter *adap)
 +{
 +	struct sge *s = &adap->sge;
 +
 +	/*
 +	 * Set up our basic SGE mode to deliver CPL messages to our Ingress
 +	 * Queue and Packet Date to the Free List.
 +	 */
 +	t4_set_reg_field(adap, SGE_CONTROL, RXPKTCPLMODE_MASK,
 +			 RXPKTCPLMODE_MASK);
  
 -	ingress_rx_threshold = t4_read_reg(adap, SGE_INGRESS_RX_THRESHOLD_A);
 -	s->counter_val[0] = THRESHOLD_0_G(ingress_rx_threshold);
 -	s->counter_val[1] = THRESHOLD_1_G(ingress_rx_threshold);
 -	s->counter_val[2] = THRESHOLD_2_G(ingress_rx_threshold);
 -	s->counter_val[3] = THRESHOLD_3_G(ingress_rx_threshold);
 +	/*
 +	 * Set up to drop DOORBELL writes when the DOORBELL FIFO overflows
 +	 * and generate an interrupt when this occurs so we can recover.
 +	 */
 +	if (is_t4(adap->params.chip)) {
 +		t4_set_reg_field(adap, A_SGE_DBFIFO_STATUS,
 +				 V_HP_INT_THRESH(M_HP_INT_THRESH) |
 +				 V_LP_INT_THRESH(M_LP_INT_THRESH),
 +				 V_HP_INT_THRESH(dbfifo_int_thresh) |
 +				 V_LP_INT_THRESH(dbfifo_int_thresh));
 +	} else {
 +		t4_set_reg_field(adap, A_SGE_DBFIFO_STATUS,
 +				 V_LP_INT_THRESH_T5(M_LP_INT_THRESH_T5),
 +				 V_LP_INT_THRESH_T5(dbfifo_int_thresh));
 +		t4_set_reg_field(adap, SGE_DBFIFO_STATUS2,
 +				 V_HP_INT_THRESH_T5(M_HP_INT_THRESH_T5),
 +				 V_HP_INT_THRESH_T5(dbfifo_int_thresh));
 +	}
 +	t4_set_reg_field(adap, A_SGE_DOORBELL_CONTROL, F_ENABLE_DROP,
 +			F_ENABLE_DROP);
 +
 +	/*
 +	 * SGE_FL_BUFFER_SIZE0 (RX_SMALL_PG_BUF) is set up by
 +	 * t4_fixup_host_params().
 +	 */
 +	s->fl_pg_order = FL_PG_ORDER;
 +	if (s->fl_pg_order)
 +		t4_write_reg(adap,
 +			     SGE_FL_BUFFER_SIZE0+RX_LARGE_PG_BUF*sizeof(u32),
 +			     PAGE_SIZE << FL_PG_ORDER);
 +	t4_write_reg(adap, SGE_FL_BUFFER_SIZE0+RX_SMALL_MTU_BUF*sizeof(u32),
 +		     FL_MTU_SMALL_BUFSIZE(adap));
 +	t4_write_reg(adap, SGE_FL_BUFFER_SIZE0+RX_LARGE_MTU_BUF*sizeof(u32),
 +		     FL_MTU_LARGE_BUFSIZE(adap));
 +
 +	/*
 +	 * Note that the SGE Ingress Packet Count Interrupt Threshold and
 +	 * Timer Holdoff values must be supplied by our caller.
 +	 */
 +	t4_write_reg(adap, SGE_INGRESS_RX_THRESHOLD,
 +		     THRESHOLD_0(s->counter_val[0]) |
 +		     THRESHOLD_1(s->counter_val[1]) |
 +		     THRESHOLD_2(s->counter_val[2]) |
 +		     THRESHOLD_3(s->counter_val[3]));
 +	t4_write_reg(adap, SGE_TIMER_VALUE_0_AND_1,
 +		     TIMERVALUE0(us_to_core_ticks(adap, s->timer_val[0])) |
 +		     TIMERVALUE1(us_to_core_ticks(adap, s->timer_val[1])));
 +	t4_write_reg(adap, SGE_TIMER_VALUE_2_AND_3,
 +		     TIMERVALUE2(us_to_core_ticks(adap, s->timer_val[2])) |
 +		     TIMERVALUE3(us_to_core_ticks(adap, s->timer_val[3])));
 +	t4_write_reg(adap, SGE_TIMER_VALUE_4_AND_5,
 +		     TIMERVALUE4(us_to_core_ticks(adap, s->timer_val[4])) |
 +		     TIMERVALUE5(us_to_core_ticks(adap, s->timer_val[5])));
  
  	return 0;
  }
  
++=======
+ /**
+  *     t4_sge_init - initialize SGE
+  *     @adap: the adapter
+  *
+  *     Perform low-level SGE code initialization needed every time after a
+  *     chip reset.
+  */
++>>>>>>> 06640310b43c (cxgb4: Ripping out old hard-wired initialization code in driver)
  int t4_sge_init(struct adapter *adap)
  {
  	struct sge *s = &adap->sge;
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/sge.c
