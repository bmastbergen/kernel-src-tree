hpsa: do not check cmd_alloc return value - it cannnot return NULL

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Robert Elliott <elliott@hp.com>
commit bf43caf316926fced73cfddad9f1b3f4251717e5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/bf43caf3.failed

cmd_alloc can no longer return NULL, so don't check for NULL any more
(which is unreachable code).

	Reviewed-by: Scott Teel <scott.teel@pmcs.com>
	Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
	Reviewed-by: Tomas Henzl <thenzl@redhat.com>
	Reviewed-by: Hannes Reinecke <hare@Suse.de>
	Signed-off-by: Robert Elliott <elliott@hp.com>
	Signed-off-by: Don Brace <don.brace@pmcs.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: James Bottomley <JBottomley@Odin.com>
(cherry picked from commit bf43caf316926fced73cfddad9f1b3f4251717e5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/hpsa.c
diff --cc drivers/scsi/hpsa.c
index 713a62ac835d,d91308993f14..000000000000
--- a/drivers/scsi/hpsa.c
+++ b/drivers/scsi/hpsa.c
@@@ -2088,13 -2466,8 +2088,16 @@@ static int hpsa_scsi_do_inquiry(struct 
  	struct CommandList *c;
  	struct ErrorInfo *ei;
  
 -	c = cmd_alloc(h);
 +	c = cmd_special_alloc(h);
 +
++<<<<<<< HEAD
 +	if (c == NULL) {			/* trouble... */
 +		dev_warn(&h->pdev->dev, "cmd_special_alloc returned NULL!\n");
 +		return -ENOMEM;
 +	}
  
++=======
++>>>>>>> bf43caf31692 (hpsa: do not check cmd_alloc return value - it cannnot return NULL)
  	if (fill_cmd(c, HPSA_INQUIRY, h, buf, bufsize,
  			page, scsi3addr, TYPE_CMD)) {
  		rc = -1;
@@@ -2119,13 -2495,7 +2122,17 @@@ static int hpsa_bmic_ctrl_mode_sense(st
  	struct CommandList *c;
  	struct ErrorInfo *ei;
  
++<<<<<<< HEAD
 +	c = cmd_special_alloc(h);
 +
 +	if (c == NULL) {			/* trouble... */
 +		dev_warn(&h->pdev->dev, "cmd_special_alloc returned NULL!\n");
 +		return -ENOMEM;
 +	}
 +
++=======
+ 	c = cmd_alloc(h);
++>>>>>>> bf43caf31692 (hpsa: do not check cmd_alloc return value - it cannnot return NULL)
  	if (fill_cmd(c, BMIC_SENSE_CONTROLLER_PARAMETERS, h, buf, bufsize,
  			page, scsi3addr, TYPE_CMD)) {
  		rc = -1;
@@@ -2138,23 -2511,19 +2145,26 @@@
  		rc = -1;
  	}
  out:
 -	cmd_free(h, c);
 +	cmd_special_free(h, c);
  	return rc;
- 	}
+ }
  
  static int hpsa_send_reset(struct ctlr_info *h, unsigned char *scsi3addr,
 -	u8 reset_type, int reply_queue)
 +	u8 reset_type)
  {
  	int rc = IO_OK;
  	struct CommandList *c;
  	struct ErrorInfo *ei;
  
 -	c = cmd_alloc(h);
 +	c = cmd_special_alloc(h);
  
++<<<<<<< HEAD
 +	if (c == NULL) {			/* trouble... */
 +		dev_warn(&h->pdev->dev, "cmd_special_alloc returned NULL!\n");
 +		return -ENOMEM;
 +	}
++=======
++>>>>>>> bf43caf31692 (hpsa: do not check cmd_alloc return value - it cannnot return NULL)
  
  	/* fill_cmd can't fail here, no data buffer to map. */
  	(void) fill_cmd(c, HPSA_DEVICE_RESET_MSG, h, NULL, 0, 0,
@@@ -2276,11 -2650,8 +2286,16 @@@ static int hpsa_get_raid_map(struct ctl
  	struct CommandList *c;
  	struct ErrorInfo *ei;
  
++<<<<<<< HEAD
 +	c = cmd_special_alloc(h);
 +	if (c == NULL) {
 +		dev_warn(&h->pdev->dev, "cmd_special_alloc returned NULL!\n");
 +		return -ENOMEM;
 +	}
++=======
+ 	c = cmd_alloc(h);
+ 
++>>>>>>> bf43caf31692 (hpsa: do not check cmd_alloc return value - it cannnot return NULL)
  	if (fill_cmd(c, HPSA_GET_RAID_MAP, h, &this_device->raid_map,
  			sizeof(this_device->raid_map), 0,
  			scsi3addr, TYPE_CMD)) {
@@@ -2415,11 -2823,8 +2430,16 @@@ static int hpsa_scsi_do_report_luns(str
  	unsigned char scsi3addr[8];
  	struct ErrorInfo *ei;
  
++<<<<<<< HEAD
 +	c = cmd_special_alloc(h);
 +	if (c == NULL) {			/* trouble... */
 +		dev_err(&h->pdev->dev, "cmd_special_alloc returned NULL!\n");
 +		return -1;
 +	}
++=======
+ 	c = cmd_alloc(h);
+ 
++>>>>>>> bf43caf31692 (hpsa: do not check cmd_alloc return value - it cannnot return NULL)
  	/* address the controller */
  	memset(scsi3addr, 0, sizeof(scsi3addr));
  	if (fill_cmd(c, logical ? HPSA_REPORT_LOG : HPSA_REPORT_PHYS, h,
@@@ -2528,14 -2940,19 +2548,13 @@@ static int hpsa_volume_offline(struct c
  #define ASCQ_LUN_NOT_READY_INITIALIZING_CMD_REQ 0x02
  
  	c = cmd_alloc(h);
- 	if (!c)
- 		return 0;
+ 
  	(void) fill_cmd(c, TEST_UNIT_READY, h, NULL, 0, 0, scsi3addr, TYPE_CMD);
 -	rc = hpsa_scsi_do_simple_cmd(h, c, DEFAULT_REPLY_QUEUE, NO_TIMEOUT);
 -	if (rc) {
 -		cmd_free(h, c);
 -		return 0;
 -	}
 +	hpsa_scsi_do_simple_cmd_core(h, c);
  	sense = c->err_info->SenseInfo;
 -	if (c->err_info->SenseLen > sizeof(c->err_info->SenseInfo))
 -		sense_len = sizeof(c->err_info->SenseInfo);
 -	else
 -		sense_len = c->err_info->SenseLen;
 -	decode_sense_data(sense, sense_len, &sense_key, &asc, &ascq);
 +	sense_key = sense[2];
 +	asc = sense[12];
 +	ascq = sense[13];
  	cmd_status = c->err_info->CommandStatus;
  	scsi_status = c->err_info->ScsiStatus;
  	cmd_free(h, c);
@@@ -2575,6 -2992,52 +2594,55 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Find out if a logical device supports aborts by simply trying one.
+  * Smart Array may claim not to support aborts on logical drives, but
+  * if a MSA2000 * is connected, the drives on that will be presented
+  * by the Smart Array as logical drives, and aborts may be sent to
+  * those devices successfully.  So the simplest way to find out is
+  * to simply try an abort and see how the device responds.
+  */
+ static int hpsa_device_supports_aborts(struct ctlr_info *h,
+ 					unsigned char *scsi3addr)
+ {
+ 	struct CommandList *c;
+ 	struct ErrorInfo *ei;
+ 	int rc = 0;
+ 
+ 	u64 tag = (u64) -1; /* bogus tag */
+ 
+ 	/* Assume that physical devices support aborts */
+ 	if (!is_logical_dev_addr_mode(scsi3addr))
+ 		return 1;
+ 
+ 	c = cmd_alloc(h);
+ 
+ 	(void) fill_cmd(c, HPSA_ABORT_MSG, h, &tag, 0, 0, scsi3addr, TYPE_MSG);
+ 	(void) hpsa_scsi_do_simple_cmd(h, c, DEFAULT_REPLY_QUEUE, NO_TIMEOUT);
+ 	/* no unmap needed here because no data xfer. */
+ 	ei = c->err_info;
+ 	switch (ei->CommandStatus) {
+ 	case CMD_INVALID:
+ 		rc = 0;
+ 		break;
+ 	case CMD_UNABORTABLE:
+ 	case CMD_ABORT_FAILED:
+ 		rc = 1;
+ 		break;
+ 	case CMD_TMF_STATUS:
+ 		rc = hpsa_evaluate_tmf_status(h, c);
+ 		break;
+ 	default:
+ 		rc = 0;
+ 		break;
+ 	}
+ 	cmd_free(h, c);
+ 	return rc;
+ }
+ 
++>>>>>>> bf43caf31692 (hpsa: do not check cmd_alloc return value - it cannnot return NULL)
  static int hpsa_update_device_info(struct ctlr_info *h,
  	unsigned char scsi3addr[], struct hpsa_scsi_dev_t *this_device,
  	unsigned char *is_OBDR_device)
@@@ -3987,7 -4434,186 +4055,190 @@@ static int hpsa_scsi_queue_command(stru
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int do_not_scan_if_controller_locked_up(struct ctlr_info *h)
++=======
+ static void hpsa_cmd_init(struct ctlr_info *h, int index,
+ 				struct CommandList *c)
+ {
+ 	dma_addr_t cmd_dma_handle, err_dma_handle;
+ 
+ 	/* Zero out all of commandlist except the last field, refcount */
+ 	memset(c, 0, offsetof(struct CommandList, refcount));
+ 	c->Header.tag = cpu_to_le64((u64) (index << DIRECT_LOOKUP_SHIFT));
+ 	cmd_dma_handle = h->cmd_pool_dhandle + index * sizeof(*c);
+ 	c->err_info = h->errinfo_pool + index;
+ 	memset(c->err_info, 0, sizeof(*c->err_info));
+ 	err_dma_handle = h->errinfo_pool_dhandle
+ 	    + index * sizeof(*c->err_info);
+ 	c->cmdindex = index;
+ 	c->busaddr = (u32) cmd_dma_handle;
+ 	c->ErrDesc.Addr = cpu_to_le64((u64) err_dma_handle);
+ 	c->ErrDesc.Len = cpu_to_le32((u32) sizeof(*c->err_info));
+ 	c->h = h;
+ }
+ 
+ static void hpsa_preinitialize_commands(struct ctlr_info *h)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < h->nr_cmds; i++) {
+ 		struct CommandList *c = h->cmd_pool + i;
+ 
+ 		hpsa_cmd_init(h, i, c);
+ 		atomic_set(&c->refcount, 0);
+ 	}
+ }
+ 
+ static inline void hpsa_cmd_partial_init(struct ctlr_info *h, int index,
+ 				struct CommandList *c)
+ {
+ 	dma_addr_t cmd_dma_handle = h->cmd_pool_dhandle + index * sizeof(*c);
+ 
+ 	memset(c->Request.CDB, 0, sizeof(c->Request.CDB));
+ 	memset(c->err_info, 0, sizeof(*c->err_info));
+ 	c->busaddr = (u32) cmd_dma_handle;
+ }
+ 
+ static int hpsa_ioaccel_submit(struct ctlr_info *h,
+ 		struct CommandList *c, struct scsi_cmnd *cmd,
+ 		unsigned char *scsi3addr)
+ {
+ 	struct hpsa_scsi_dev_t *dev = cmd->device->hostdata;
+ 	int rc = IO_ACCEL_INELIGIBLE;
+ 
+ 	cmd->host_scribble = (unsigned char *) c;
+ 
+ 	if (dev->offload_enabled) {
+ 		hpsa_cmd_init(h, c->cmdindex, c);
+ 		c->cmd_type = CMD_SCSI;
+ 		c->scsi_cmd = cmd;
+ 		rc = hpsa_scsi_ioaccel_raid_map(h, c);
+ 		if (rc < 0)     /* scsi_dma_map failed. */
+ 			rc = SCSI_MLQUEUE_HOST_BUSY;
+ 	} else if (dev->hba_ioaccel_enabled) {
+ 		hpsa_cmd_init(h, c->cmdindex, c);
+ 		c->cmd_type = CMD_SCSI;
+ 		c->scsi_cmd = cmd;
+ 		rc = hpsa_scsi_ioaccel_direct_map(h, c);
+ 		if (rc < 0)     /* scsi_dma_map failed. */
+ 			rc = SCSI_MLQUEUE_HOST_BUSY;
+ 	}
+ 	return rc;
+ }
+ 
+ static void hpsa_command_resubmit_worker(struct work_struct *work)
+ {
+ 	struct scsi_cmnd *cmd;
+ 	struct hpsa_scsi_dev_t *dev;
+ 	struct CommandList *c =
+ 			container_of(work, struct CommandList, work);
+ 
+ 	cmd = c->scsi_cmd;
+ 	dev = cmd->device->hostdata;
+ 	if (!dev) {
+ 		cmd->result = DID_NO_CONNECT << 16;
+ 		cmd_free(c->h, c);
+ 		cmd->scsi_done(cmd);
+ 		return;
+ 	}
+ 	if (c->cmd_type == CMD_IOACCEL2) {
+ 		struct ctlr_info *h = c->h;
+ 		struct io_accel2_cmd *c2 = &h->ioaccel2_cmd_pool[c->cmdindex];
+ 		int rc;
+ 
+ 		if (c2->error_data.serv_response ==
+ 				IOACCEL2_STATUS_SR_TASK_COMP_SET_FULL) {
+ 			rc = hpsa_ioaccel_submit(h, c, cmd, dev->scsi3addr);
+ 			if (rc == 0)
+ 				return;
+ 			if (rc == SCSI_MLQUEUE_HOST_BUSY) {
+ 				/*
+ 				 * If we get here, it means dma mapping failed.
+ 				 * Try again via scsi mid layer, which will
+ 				 * then get SCSI_MLQUEUE_HOST_BUSY.
+ 				 */
+ 				cmd->result = DID_IMM_RETRY << 16;
+ 				cmd->scsi_done(cmd);
+ 				cmd_free(h, c);	/* FIX-ME:  on merge, change
+ 						 * to cmd_tagged_free() and
+ 						 * ultimately to
+ 						 * hpsa_cmd_free_and_done(). */
+ 				return;
+ 			}
+ 			/* else, fall thru and resubmit down CISS path */
+ 		}
+ 	}
+ 	hpsa_cmd_partial_init(c->h, c->cmdindex, c);
+ 	if (hpsa_ciss_submit(c->h, c, cmd, dev->scsi3addr)) {
+ 		/*
+ 		 * If we get here, it means dma mapping failed. Try
+ 		 * again via scsi mid layer, which will then get
+ 		 * SCSI_MLQUEUE_HOST_BUSY.
+ 		 *
+ 		 * hpsa_ciss_submit will have already freed c
+ 		 * if it encountered a dma mapping failure.
+ 		 */
+ 		cmd->result = DID_IMM_RETRY << 16;
+ 		cmd->scsi_done(cmd);
+ 	}
+ }
+ 
+ /* Running in struct Scsi_Host->host_lock less mode */
+ static int hpsa_scsi_queue_command(struct Scsi_Host *sh, struct scsi_cmnd *cmd)
+ {
+ 	struct ctlr_info *h;
+ 	struct hpsa_scsi_dev_t *dev;
+ 	unsigned char scsi3addr[8];
+ 	struct CommandList *c;
+ 	int rc = 0;
+ 
+ 	/* Get the ptr to our adapter structure out of cmd->host. */
+ 	h = sdev_to_hba(cmd->device);
+ 	dev = cmd->device->hostdata;
+ 	if (!dev) {
+ 		cmd->result = DID_NO_CONNECT << 16;
+ 		cmd->scsi_done(cmd);
+ 		return 0;
+ 	}
+ 	memcpy(scsi3addr, dev->scsi3addr, sizeof(scsi3addr));
+ 
+ 	if (unlikely(lockup_detected(h))) {
+ 		cmd->result = DID_NO_CONNECT << 16;
+ 		cmd->scsi_done(cmd);
+ 		return 0;
+ 	}
+ 	c = cmd_alloc(h);
+ 
+ 	if (unlikely(lockup_detected(h))) {
+ 		cmd->result = DID_NO_CONNECT << 16;
+ 		cmd_free(h, c);
+ 		cmd->scsi_done(cmd);
+ 		return 0;
+ 	}
+ 
+ 	/*
+ 	 * Call alternate submit routine for I/O accelerated commands.
+ 	 * Retries always go down the normal I/O path.
+ 	 */
+ 	if (likely(cmd->retries == 0 &&
+ 		cmd->request->cmd_type == REQ_TYPE_FS &&
+ 		h->acciopath_status)) {
+ 		rc = hpsa_ioaccel_submit(h, c, cmd, scsi3addr);
+ 		if (rc == 0)
+ 			return 0;
+ 		if (rc == SCSI_MLQUEUE_HOST_BUSY) {
+ 			cmd_free(h, c);	/* FIX-ME:  on merge, change to
+ 					 * cmd_tagged_free(), and ultimately
+ 					 * to hpsa_cmd_resolve_and_free(). */
+ 			return SCSI_MLQUEUE_HOST_BUSY;
+ 		}
+ 	}
+ 	return hpsa_ciss_submit(h, c, cmd, scsi3addr);
+ }
+ 
+ static void hpsa_scan_complete(struct ctlr_info *h)
++>>>>>>> bf43caf31692 (hpsa: do not check cmd_alloc return value - it cannnot return NULL)
  {
  	unsigned long flags;
  
@@@ -4135,12 -4745,7 +4386,16 @@@ static int wait_for_device_to_become_re
  	int waittime = 1; /* seconds */
  	struct CommandList *c;
  
++<<<<<<< HEAD
 +	c = cmd_special_alloc(h);
 +	if (!c) {
 +		dev_warn(&h->pdev->dev, "out of memory in "
 +			"wait_for_device_to_become_ready.\n");
 +		return IO_ERROR;
 +	}
++=======
+ 	c = cmd_alloc(h);
++>>>>>>> bf43caf31692 (hpsa: do not check cmd_alloc return value - it cannnot return NULL)
  
  	/* Send test unit ready until device ready, or give up. */
  	while (count < HPSA_TUR_RETRY_LIMIT) {
@@@ -4267,20 -4897,16 +4522,24 @@@ static int hpsa_send_abort(struct ctlr_
  	struct ErrorInfo *ei;
  	__le32 tagupper, taglower;
  
++<<<<<<< HEAD
 +	c = cmd_special_alloc(h);
 +	if (c == NULL) {	/* trouble... */
 +		dev_warn(&h->pdev->dev, "cmd_special_alloc returned NULL!\n");
 +		return -ENOMEM;
 +	}
++=======
+ 	c = cmd_alloc(h);
++>>>>>>> bf43caf31692 (hpsa: do not check cmd_alloc return value - it cannnot return NULL)
  
  	/* fill_cmd can't fail here, no buffer to map */
 -	(void) fill_cmd(c, HPSA_ABORT_MSG, h, &abort->Header.tag,
 +	(void) fill_cmd(c, HPSA_ABORT_MSG, h, abort,
  		0, 0, scsi3addr, TYPE_MSG);
 -	if (h->needs_abort_tags_swizzled)
 +	if (swizzle)
  		swizzle_abort_tag(&c->Request.CDB[4]);
 -	(void) hpsa_scsi_do_simple_cmd(h, c, reply_queue, NO_TIMEOUT);
 +	hpsa_scsi_do_simple_cmd_core(h, c);
  	hpsa_get_tag(h, abort, &taglower, &tagupper);
 -	dev_dbg(&h->pdev->dev, "%s: Tag:0x%08x:%08x: do_simple_cmd(abort) completed.\n",
 +	dev_dbg(&h->pdev->dev, "%s: Tag:0x%08x:%08x: do_simple_cmd_core completed.\n",
  		__func__, tagupper, taglower);
  	/* no unmap needed here because no data xfer. */
  
@@@ -4501,7 -5183,10 +4760,9 @@@ static int hpsa_eh_abort_handler(struc
   * and managed by cmd_alloc() and cmd_free() using a simple bitmap to track
   * which ones are free or in use.  Lock must be held when calling this.
   * cmd_free() is the complement.
+  * This function never gives up and returns NULL.  If it hangs,
+  * another thread must call cmd_free() to free some tags.
   */
 -
  static struct CommandList *cmd_alloc(struct ctlr_info *h)
  {
  	struct CommandList *c;
@@@ -4787,11 -5417,8 +5048,16 @@@ static int hpsa_passthru_ioctl(struct c
  			memset(buff, 0, iocommand.buf_size);
  		}
  	}
++<<<<<<< HEAD
 +	c = cmd_special_alloc(h);
 +	if (c == NULL) {
 +		rc = -ENOMEM;
 +		goto out_kfree;
 +	}
++=======
+ 	c = cmd_alloc(h);
+ 
++>>>>>>> bf43caf31692 (hpsa: do not check cmd_alloc return value - it cannnot return NULL)
  	/* Fill in the command type */
  	c->cmd_type = CMD_IOCTL_PEND;
  	/* Fill in Command Header */
@@@ -4922,11 -5553,8 +5188,16 @@@ static int hpsa_big_passthru_ioctl(stru
  		data_ptr += sz;
  		sg_used++;
  	}
++<<<<<<< HEAD
 +	c = cmd_special_alloc(h);
 +	if (c == NULL) {
 +		status = -ENOMEM;
 +		goto cleanup1;
 +	}
++=======
+ 	c = cmd_alloc(h);
+ 
++>>>>>>> bf43caf31692 (hpsa: do not check cmd_alloc return value - it cannnot return NULL)
  	c->cmd_type = CMD_IOCTL_PEND;
  	c->Header.ReplyQueue = 0;
  	c->Header.SGList = (u8) sg_used;
@@@ -6925,11 -7592,8 +7191,16 @@@ static void hpsa_flush_cache(struct ctl
  	if (!flush_buf)
  		return;
  
++<<<<<<< HEAD
 +	c = cmd_special_alloc(h);
 +	if (!c) {
 +		dev_warn(&h->pdev->dev, "cmd_special_alloc returned NULL!\n");
 +		goto out_of_memory;
 +	}
++=======
+ 	c = cmd_alloc(h);
+ 
++>>>>>>> bf43caf31692 (hpsa: do not check cmd_alloc return value - it cannnot return NULL)
  	if (fill_cmd(c, HPSA_CACHE_FLUSH, h, flush_buf, 4, 0,
  		RAID_CTLR_LUNID, TYPE_CMD)) {
  		goto out;
@@@ -6939,8 -7606,7 +7210,12 @@@
  out:
  		dev_warn(&h->pdev->dev,
  			"error flushing cache on controller\n");
++<<<<<<< HEAD
 +	cmd_special_free(h, c);
 +out_of_memory:
++=======
+ 	cmd_free(h, c);
++>>>>>>> bf43caf31692 (hpsa: do not check cmd_alloc return value - it cannnot return NULL)
  	kfree(flush_buf);
  }
  
* Unmerged path drivers/scsi/hpsa.c
