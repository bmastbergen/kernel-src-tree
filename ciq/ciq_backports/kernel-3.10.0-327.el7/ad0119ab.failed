ALSA: line6: Rearrange PCM structure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [alsa] line6: Rearrange PCM structure (Jaroslav Kysela) [1197064]
Rebuild_FUZZ: 90.91%
commit-author Takashi Iwai <tiwai@suse.de>
commit ad0119abe29fe3d506486a789de4c4619fa7602c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/ad0119ab.failed

Introduce a new line6_pcm_stream structure and group individual
fields of snd_line6_pcm struct to playback and capture groups.

This patch itself just does rename and nothing else.  More
meaningful cleanups based on these fields shuffling will follow.

	Tested-by: Chris Rorvick <chris@rorvick.com>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit ad0119abe29fe3d506486a789de4c4619fa7602c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/line6/capture.c
#	drivers/staging/line6/pcm.c
#	drivers/staging/line6/pcm.h
#	drivers/staging/line6/playback.c
diff --cc drivers/staging/line6/capture.c
index 7ed8560f3c0a,439f1941eb56..000000000000
--- a/drivers/staging/line6/capture.c
+++ b/drivers/staging/line6/capture.c
@@@ -93,10 -91,11 +93,18 @@@ void line6_unlink_audio_in_urbs(struct 
  {
  	unsigned int i;
  
++<<<<<<< HEAD:drivers/staging/line6/capture.c
 +	for (i = LINE6_ISO_BUFFERS; i--;) {
 +		if (test_bit(i, &line6pcm->active_urb_in)) {
 +			if (!test_and_set_bit(i, &line6pcm->unlink_urb_in)) {
 +				struct urb *u = line6pcm->urb_audio_in[i];
++=======
+ 	for (i = 0; i < LINE6_ISO_BUFFERS; i++) {
+ 		if (test_bit(i, &line6pcm->in.active_urbs)) {
+ 			if (!test_and_set_bit(i, &line6pcm->in.unlink_urbs)) {
+ 				struct urb *u = line6pcm->in.urbs[i];
+ 
++>>>>>>> ad0119abe29f (ALSA: line6: Rearrange PCM structure):sound/usb/line6/capture.c
  				usb_unlink_urb(u);
  			}
  		}
@@@ -115,8 -114,8 +123,13 @@@ void line6_wait_clear_audio_in_urbs(str
  
  	do {
  		alive = 0;
++<<<<<<< HEAD:drivers/staging/line6/capture.c
 +		for (i = LINE6_ISO_BUFFERS; i--;) {
 +			if (test_bit(i, &line6pcm->active_urb_in))
++=======
+ 		for (i = 0; i < LINE6_ISO_BUFFERS; i++) {
+ 			if (test_bit(i, &line6pcm->in.active_urbs))
++>>>>>>> ad0119abe29f (ALSA: line6: Rearrange PCM structure):sound/usb/line6/capture.c
  				alive++;
  		}
  		if (!alive)
@@@ -157,7 -156,8 +170,12 @@@ void line6_capture_copy(struct snd_line
  		   copy two separate chunks.
  		 */
  		int len;
++<<<<<<< HEAD:drivers/staging/line6/capture.c
 +		len = runtime->buffer_size - line6pcm->pos_in_done;
++=======
+ 
+ 		len = runtime->buffer_size - line6pcm->in.pos_done;
++>>>>>>> ad0119abe29f (ALSA: line6: Rearrange PCM structure):sound/usb/line6/capture.c
  
  		if (len > 0) {
  			memcpy(runtime->dma_area +
@@@ -363,7 -360,8 +381,12 @@@ static snd_pcm_uframes_
  snd_line6_capture_pointer(struct snd_pcm_substream *substream)
  {
  	struct snd_line6_pcm *line6pcm = snd_pcm_substream_chip(substream);
++<<<<<<< HEAD:drivers/staging/line6/capture.c
 +	return line6pcm->pos_in_done;
++=======
+ 
+ 	return line6pcm->in.pos_done;
++>>>>>>> ad0119abe29f (ALSA: line6: Rearrange PCM structure):sound/usb/line6/capture.c
  }
  
  /* capture operators */
@@@ -387,18 -386,16 +410,18 @@@ int line6_create_audio_in_urbs(struct s
  		struct urb *urb;
  
  		/* URB for audio in: */
- 		urb = line6pcm->urb_audio_in[i] =
+ 		urb = line6pcm->in.urbs[i] =
  		    usb_alloc_urb(LINE6_ISO_PACKETS, GFP_KERNEL);
  
 -		if (urb == NULL)
 +		if (urb == NULL) {
 +			dev_err(line6pcm->line6->ifcdev, "Out of memory\n");
  			return -ENOMEM;
 +		}
  
 -		urb->dev = line6->usbdev;
 +		urb->dev = line6pcm->line6->usbdev;
  		urb->pipe =
 -		    usb_rcvisocpipe(line6->usbdev,
 -				    line6->properties->ep_audio_r &
 +		    usb_rcvisocpipe(line6pcm->line6->usbdev,
 +				    line6pcm->ep_audio_read &
  				    USB_ENDPOINT_NUMBER_MASK);
  		urb->transfer_flags = URB_ISO_ASAP;
  		urb->start_frame = -1;
diff --cc drivers/staging/line6/pcm.c
index cfc50624f3e2,738bfd82cecd..000000000000
--- a/drivers/staging/line6/pcm.c
+++ b/drivers/staging/line6/pcm.c
@@@ -326,21 -330,17 +326,28 @@@ static void line6_cleanup_pcm(struct sn
  	int i;
  	struct snd_line6_pcm *line6pcm = snd_pcm_chip(pcm);
  
++<<<<<<< HEAD:drivers/staging/line6/pcm.c
 +#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
 +	device_remove_file(line6pcm->line6->ifcdev, &dev_attr_impulse_volume);
 +	device_remove_file(line6pcm->line6->ifcdev, &dev_attr_impulse_period);
 +#endif
 +
 +	for (i = LINE6_ISO_BUFFERS; i--;) {
 +		if (line6pcm->urb_audio_out[i]) {
 +			usb_kill_urb(line6pcm->urb_audio_out[i]);
 +			usb_free_urb(line6pcm->urb_audio_out[i]);
++=======
+ 	for (i = 0; i < LINE6_ISO_BUFFERS; i++) {
+ 		if (line6pcm->out.urbs[i]) {
+ 			usb_kill_urb(line6pcm->out.urbs[i]);
+ 			usb_free_urb(line6pcm->out.urbs[i]);
++>>>>>>> ad0119abe29f (ALSA: line6: Rearrange PCM structure):sound/usb/line6/pcm.c
  		}
- 		if (line6pcm->urb_audio_in[i]) {
- 			usb_kill_urb(line6pcm->urb_audio_in[i]);
- 			usb_free_urb(line6pcm->urb_audio_in[i]);
+ 		if (line6pcm->in.urbs[i]) {
+ 			usb_kill_urb(line6pcm->in.urbs[i]);
+ 			usb_free_urb(line6pcm->in.urbs[i]);
  		}
  	}
 -	kfree(line6pcm);
  }
  
  /* create a PCM device */
@@@ -488,23 -415,14 +495,30 @@@ int line6_init_pcm(struct usb_line6 *li
  			usb_maxpacket(line6->usbdev,
  				usb_sndisocpipe(line6->usbdev, ep_write), 1));
  
++<<<<<<< HEAD:drivers/staging/line6/pcm.c
 +	line6pcm->properties = properties;
++=======
+ 	spin_lock_init(&line6pcm->out.lock);
+ 	spin_lock_init(&line6pcm->in.lock);
+ 	line6pcm->impulse_period = LINE6_IMPULSE_DEFAULT_PERIOD;
+ 
++>>>>>>> ad0119abe29f (ALSA: line6: Rearrange PCM structure):sound/usb/line6/pcm.c
  	line6->line6pcm = line6pcm;
  
 -	pcm->private_data = line6pcm;
 -	pcm->private_free = line6_cleanup_pcm;
 +	/* PCM device: */
 +	err = snd_device_new(line6->card, SNDRV_DEV_PCM, line6, &pcm_ops);
 +	if (err < 0)
 +		return err;
 +
 +	snd_card_set_dev(line6->card, line6->ifcdev);
 +
 +	err = snd_line6_new_pcm(line6pcm);
 +	if (err < 0)
 +		return err;
 +
 +	spin_lock_init(&line6pcm->lock_audio_out);
 +	spin_lock_init(&line6pcm->lock_audio_in);
 +	spin_lock_init(&line6pcm->lock_trigger);
  
  	err = line6_create_audio_out_urbs(line6pcm);
  	if (err < 0)
diff --cc drivers/staging/line6/pcm.h
index 6aa0d46a2890,4c74f4e85074..000000000000
--- a/drivers/staging/line6/pcm.h
+++ b/drivers/staging/line6/pcm.h
@@@ -179,115 -165,78 +179,78 @@@ struct line6_pcm_properties 
  	int bytes_per_frame;
  };
  
- struct snd_line6_pcm {
- 	/**
- 		 Pointer back to the Line6 driver data structure.
- 	*/
- 	struct usb_line6 *line6;
+ struct line6_pcm_stream {
+ 	/* allocated URBs */
+ 	struct urb *urbs[LINE6_ISO_BUFFERS];
  
- 	/**
- 		 Properties.
- 	*/
- 	struct line6_pcm_properties *properties;
+ 	/* Temporary buffer;
+ 	 * Since the packet size is not known in advance, this buffer is
+ 	 * large enough to store maximum size packets.
+ 	 */
+ 	unsigned char *buffer;
  
- 	/**
- 		 ALSA pcm stream
- 	*/
- 	struct snd_pcm *pcm;
+ 	/* Free frame position in the buffer. */
+ 	snd_pcm_uframes_t pos;
  
- 	/**
- 		 URBs for audio playback.
- 	*/
- 	struct urb *urb_audio_out[LINE6_ISO_BUFFERS];
+ 	/* Count processed bytes;
+ 	 * This is modulo period size (to determine when a period is finished).
+ 	 */
+ 	unsigned bytes;
  
- 	/**
- 		 URBs for audio capture.
- 	*/
- 	struct urb *urb_audio_in[LINE6_ISO_BUFFERS];
+ 	/* Counter to create desired sample rate */
+ 	unsigned count;
  
- 	/**
- 		 Temporary buffer for playback.
- 		 Since the packet size is not known in advance, this buffer is
- 		 large enough to store maximum size packets.
- 	*/
- 	unsigned char *buffer_out;
- 
- 	/**
- 		 Temporary buffer for capture.
- 		 Since the packet size is not known in advance, this buffer is
- 		 large enough to store maximum size packets.
- 	*/
- 	unsigned char *buffer_in;
- 
- 	/**
- 		 Previously captured frame (for software monitoring).
- 	*/
- 	unsigned char *prev_fbuf;
+ 	/* period size in bytes */
+ 	unsigned period;
  
- 	/**
- 		 Size of previously captured frame (for software monitoring).
- 	*/
- 	int prev_fsize;
+ 	/* Processed frame position in the buffer;
+ 	 * The contents of the ring buffer have been consumed by the USB
+ 	 * subsystem (i.e., sent to the USB device) up to this position.
+ 	 */
+ 	snd_pcm_uframes_t pos_done;
  
- 	/**
- 		 Free frame position in the playback buffer.
- 	*/
- 	snd_pcm_uframes_t pos_out;
+ 	/* Bit mask of active URBs */
+ 	unsigned long active_urbs;
  
- 	/**
- 		 Count processed bytes for playback.
- 		 This is modulo period size (to determine when a period is
- 		 finished).
- 	*/
- 	unsigned bytes_out;
+ 	/* Bit mask of URBs currently being unlinked */
+ 	unsigned long unlink_urbs;
  
- 	/**
- 		 Counter to create desired playback sample rate.
- 	*/
- 	unsigned count_out;
+ 	/* Spin lock to protect updates of the buffer positions (not contents)
+ 	 */
+ 	spinlock_t lock;
  
- 	/**
- 		 Playback period size in bytes
- 	*/
- 	unsigned period_out;
+ 	int last_frame;
+ };
  
+ struct snd_line6_pcm {
  	/**
- 		 Processed frame position in the playback buffer.
- 		 The contents of the output ring buffer have been consumed by
- 		 the USB subsystem (i.e., sent to the USB device) up to this
- 		 position.
 -		 Pointer back to the Line 6 driver data structure.
++		 Pointer back to the Line6 driver data structure.
  	*/
- 	snd_pcm_uframes_t pos_out_done;
+ 	struct usb_line6 *line6;
  
  	/**
- 		 Count processed bytes for capture.
- 		 This is modulo period size (to determine when a period is
- 		 finished).
+ 		 Properties.
  	*/
- 	unsigned bytes_in;
+ 	struct line6_pcm_properties *properties;
  
  	/**
- 		 Counter to create desired capture sample rate.
+ 		 ALSA pcm stream
  	*/
- 	unsigned count_in;
+ 	struct snd_pcm *pcm;
  
- 	/**
- 		 Capture period size in bytes
- 	*/
- 	unsigned period_in;
+ 	/* Capture and playback streams */
+ 	struct line6_pcm_stream in;
+ 	struct line6_pcm_stream out;
  
  	/**
- 		 Processed frame position in the capture buffer.
- 		 The contents of the output ring buffer have been consumed by
- 		 the USB subsystem (i.e., sent to the USB device) up to this
- 		 position.
+ 		 Previously captured frame (for software monitoring).
  	*/
- 	snd_pcm_uframes_t pos_in_done;
+ 	unsigned char *prev_fbuf;
  
  	/**
- 		 Bit mask of active playback URBs.
+ 		 Size of previously captured frame (for software monitoring).
  	*/
- 	unsigned long active_urb_out;
+ 	int prev_fsize;
  
  	/**
  		 Maximum size of USB packet.
@@@ -295,48 -244,6 +258,51 @@@
  	int max_packet_size;
  
  	/**
++<<<<<<< HEAD:drivers/staging/line6/pcm.h
 +		 USB endpoint for listening to audio data.
 +	*/
 +	int ep_audio_read;
 +
 +	/**
 +		 USB endpoint for writing audio data.
 +	*/
 +	int ep_audio_write;
 +
 +	/**
 +		 Bit mask of active capture URBs.
 +	*/
 +	unsigned long active_urb_in;
 +
 +	/**
 +		 Bit mask of playback URBs currently being unlinked.
 +	*/
 +	unsigned long unlink_urb_out;
 +
 +	/**
 +		 Bit mask of capture URBs currently being unlinked.
 +	*/
 +	unsigned long unlink_urb_in;
 +
 +	/**
 +		 Spin lock to protect updates of the playback buffer positions (not
 +		 contents!)
 +	*/
 +	spinlock_t lock_audio_out;
 +
 +	/**
 +		 Spin lock to protect updates of the capture buffer positions (not
 +		 contents!)
 +	*/
 +	spinlock_t lock_audio_in;
 +
 +	/**
 +		 Spin lock to protect trigger.
 +	*/
 +	spinlock_t lock_trigger;
 +
 +	/**
++=======
++>>>>>>> ad0119abe29f (ALSA: line6: Rearrange PCM structure):sound/usb/line6/pcm.h
  		 PCM playback volume (left and right).
  	*/
  	int volume_playback[2];
diff --cc drivers/staging/line6/playback.c
index d11db09086cb,d619c1718306..000000000000
--- a/drivers/staging/line6/playback.c
+++ b/drivers/staging/line6/playback.c
@@@ -171,9 -169,10 +171,16 @@@ static int submit_audio_out_urb(struct 
  
  		if (fsize == 0) {
  			int n;
++<<<<<<< HEAD:drivers/staging/line6/playback.c
 +			line6pcm->count_out += frame_increment;
 +			n = line6pcm->count_out / frame_factor;
 +			line6pcm->count_out -= n * frame_factor;
++=======
+ 
+ 			line6pcm->out.count += frame_increment;
+ 			n = line6pcm->out.count / frame_factor;
+ 			line6pcm->out.count -= n * frame_factor;
++>>>>>>> ad0119abe29f (ALSA: line6: Rearrange PCM structure):sound/usb/line6/playback.c
  			fsize = n * bytes_per_frame;
  		}
  
@@@ -207,7 -206,8 +214,12 @@@
  			   copy the data to the temp buffer.
  			 */
  			int len;
++<<<<<<< HEAD:drivers/staging/line6/playback.c
 +			len = runtime->buffer_size - line6pcm->pos_out;
++=======
+ 
+ 			len = runtime->buffer_size - line6pcm->out.pos;
++>>>>>>> ad0119abe29f (ALSA: line6: Rearrange PCM structure):sound/usb/line6/playback.c
  
  			if (len > 0) {
  				memcpy(urb_out->transfer_buffer,
@@@ -300,10 -297,11 +312,18 @@@ void line6_unlink_audio_out_urbs(struc
  {
  	unsigned int i;
  
++<<<<<<< HEAD:drivers/staging/line6/playback.c
 +	for (i = LINE6_ISO_BUFFERS; i--;) {
 +		if (test_bit(i, &line6pcm->active_urb_out)) {
 +			if (!test_and_set_bit(i, &line6pcm->unlink_urb_out)) {
 +				struct urb *u = line6pcm->urb_audio_out[i];
++=======
+ 	for (i = 0; i < LINE6_ISO_BUFFERS; i++) {
+ 		if (test_bit(i, &line6pcm->out.active_urbs)) {
+ 			if (!test_and_set_bit(i, &line6pcm->out.unlink_urbs)) {
+ 				struct urb *u = line6pcm->out.urbs[i];
+ 
++>>>>>>> ad0119abe29f (ALSA: line6: Rearrange PCM structure):sound/usb/line6/playback.c
  				usb_unlink_urb(u);
  			}
  		}
@@@ -322,8 -320,8 +342,13 @@@ void line6_wait_clear_audio_out_urbs(st
  
  	do {
  		alive = 0;
++<<<<<<< HEAD:drivers/staging/line6/playback.c
 +		for (i = LINE6_ISO_BUFFERS; i--;) {
 +			if (test_bit(i, &line6pcm->active_urb_out))
++=======
+ 		for (i = 0; i < LINE6_ISO_BUFFERS; i++) {
+ 			if (test_bit(i, &line6pcm->out.active_urbs))
++>>>>>>> ad0119abe29f (ALSA: line6: Rearrange PCM structure):sound/usb/line6/playback.c
  				alive++;
  		}
  		if (!alive)
@@@ -366,33 -363,34 +391,43 @@@ static void audio_out_callback(struct u
  	memset(urb->transfer_buffer, 0, urb->transfer_buffer_length);
  #endif
  
- 	line6pcm->last_frame_out = urb->start_frame;
+ 	line6pcm->out.last_frame = urb->start_frame;
  
  	/* find index of URB */
++<<<<<<< HEAD:drivers/staging/line6/playback.c
 +	for (index = LINE6_ISO_BUFFERS; index--;)
 +		if (urb == line6pcm->urb_audio_out[index])
++=======
+ 	for (index = 0; index < LINE6_ISO_BUFFERS; index++)
+ 		if (urb == line6pcm->out.urbs[index])
++>>>>>>> ad0119abe29f (ALSA: line6: Rearrange PCM structure):sound/usb/line6/playback.c
  			break;
  
 -	if (index >= LINE6_ISO_BUFFERS)
 +	if (index < 0)
  		return;		/* URB has been unlinked asynchronously */
  
 -	for (i = 0; i < LINE6_ISO_PACKETS; i++)
 +	for (i = LINE6_ISO_PACKETS; i--;)
  		length += urb->iso_frame_desc[i].length;
  
- 	spin_lock_irqsave(&line6pcm->lock_audio_out, flags);
+ 	spin_lock_irqsave(&line6pcm->out.lock, flags);
  
  	if (test_bit(LINE6_INDEX_PCM_ALSA_PLAYBACK_STREAM, &line6pcm->flags)) {
  		struct snd_pcm_runtime *runtime = substream->runtime;
++<<<<<<< HEAD:drivers/staging/line6/playback.c
 +		line6pcm->pos_out_done +=
++=======
+ 
+ 		line6pcm->out.pos_done +=
++>>>>>>> ad0119abe29f (ALSA: line6: Rearrange PCM structure):sound/usb/line6/playback.c
  		    length / line6pcm->properties->bytes_per_frame;
  
- 		if (line6pcm->pos_out_done >= runtime->buffer_size)
- 			line6pcm->pos_out_done -= runtime->buffer_size;
+ 		if (line6pcm->out.pos_done >= runtime->buffer_size)
+ 			line6pcm->out.pos_done -= runtime->buffer_size;
  	}
  
- 	clear_bit(index, &line6pcm->active_urb_out);
+ 	clear_bit(index, &line6pcm->out.active_urbs);
  
 -	for (i = 0; i < LINE6_ISO_PACKETS; i++)
 +	for (i = LINE6_ISO_PACKETS; i--;)
  		if (urb->iso_frame_desc[i].status == -EXDEV) {
  			shutdown = 1;
  			break;
@@@ -517,7 -516,8 +552,12 @@@ static snd_pcm_uframes_
  snd_line6_playback_pointer(struct snd_pcm_substream *substream)
  {
  	struct snd_line6_pcm *line6pcm = snd_pcm_substream_chip(substream);
++<<<<<<< HEAD:drivers/staging/line6/playback.c
 +	return line6pcm->pos_out_done;
++=======
+ 
+ 	return line6pcm->out.pos_done;
++>>>>>>> ad0119abe29f (ALSA: line6: Rearrange PCM structure):sound/usb/line6/playback.c
  }
  
  /* playback operators */
@@@ -541,18 -542,16 +581,18 @@@ int line6_create_audio_out_urbs(struct 
  		struct urb *urb;
  
  		/* URB for audio out: */
- 		urb = line6pcm->urb_audio_out[i] =
+ 		urb = line6pcm->out.urbs[i] =
  		    usb_alloc_urb(LINE6_ISO_PACKETS, GFP_KERNEL);
  
 -		if (urb == NULL)
 +		if (urb == NULL) {
 +			dev_err(line6pcm->line6->ifcdev, "Out of memory\n");
  			return -ENOMEM;
 +		}
  
 -		urb->dev = line6->usbdev;
 +		urb->dev = line6pcm->line6->usbdev;
  		urb->pipe =
 -		    usb_sndisocpipe(line6->usbdev,
 -				    line6->properties->ep_audio_w &
 +		    usb_sndisocpipe(line6pcm->line6->usbdev,
 +				    line6pcm->ep_audio_write &
  				    USB_ENDPOINT_NUMBER_MASK);
  		urb->transfer_flags = URB_ISO_ASAP;
  		urb->start_frame = -1;
* Unmerged path drivers/staging/line6/capture.c
* Unmerged path drivers/staging/line6/pcm.c
* Unmerged path drivers/staging/line6/pcm.h
* Unmerged path drivers/staging/line6/playback.c
