perf session: Do not fail on processing out of order event

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [perf] session: Do not fail on processing out of order event (Jiri Olsa) [1209607]
Rebuild_FUZZ: 95.50%
commit-author Jiri Olsa <jolsa@kernel.org>
commit f61ff6c06dc8f32c7036013ad802c899ec590607
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/f61ff6c0.failed

Linus reported perf report command being interrupted due to processing
of 'out of order' event, with following error:

  Timestamp below last timeslice flush
  0x5733a8 [0x28]: failed to process type: 3

I could reproduce the issue and in my case it was caused by one CPU
(mmap) being behind during record and userspace mmap reader seeing the
data after other CPUs data were already stored.

This is expected under some circumstances because we need to limit the
number of events that we queue for reordering when we receive a
PERF_RECORD_FINISHED_ROUND or when we force flush due to memory
pressure.

	Reported-by: Linus Torvalds <torvalds@linux-foundation.org>
	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Acked-by: Ingo Molnar <mingo@kernel.org>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: Corey Ashford <cjashfor@linux.vnet.ibm.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Matt Fleming <matt.fleming@intel.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
	Cc: Stephane Eranian <eranian@google.com>
Link: http://lkml.kernel.org/r/1417016371-30249-1-git-send-email-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit f61ff6c06dc8f32c7036013ad802c899ec590607)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/session.c
diff --cc tools/perf/util/session.c
index 9b53c44172ed,80dbba095f30..000000000000
--- a/tools/perf/util/session.c
+++ b/tools/perf/util/session.c
@@@ -691,33 -520,24 +691,42 @@@ int perf_session_queue_event(struct per
  	if (!timestamp || timestamp == ~0ULL)
  		return -ETIME;
  
++<<<<<<< HEAD
 +	if (timestamp < s->ordered_events.last_flush) {
 +		printf("Warning: Timestamp below last timeslice flush\n");
 +		return -EINVAL;
++=======
+ 	if (timestamp < oe->last_flush) {
+ 		pr_oe_time(timestamp,      "out of order event\n");
+ 		pr_oe_time(oe->last_flush, "last flush, last_flush_type %d\n",
+ 			   oe->last_flush_type);
+ 
+ 		s->stats.nr_unordered_events++;
++>>>>>>> f61ff6c06dc8 (perf session: Do not fail on processing out of order event)
  	}
  
 -	new = ordered_events__new(oe, timestamp, event);
 -	if (!new) {
 -		ordered_events__flush(s, tool, OE_FLUSH__HALF);
 -		new = ordered_events__new(oe, timestamp, event);
 +	if (!list_empty(cache)) {
 +		new = list_entry(cache->next, struct ordered_event, list);
 +		list_del(&new->list);
 +	} else if (oe->buffer) {
 +		new = oe->buffer + oe->buffer_idx;
 +		if (++oe->buffer_idx == MAX_SAMPLE_BUFFER)
 +			oe->buffer = NULL;
 +	} else {
 +		oe->buffer = malloc(MAX_SAMPLE_BUFFER * sizeof(*new));
 +		if (!oe->buffer)
 +			return -ENOMEM;
 +		list_add(&oe->buffer->list, &oe->to_free);
 +		oe->buffer_idx = 2;
 +		new = oe->buffer + 1;
  	}
  
 -	if (!new)
 -		return -ENOMEM;
 -
 +	new->timestamp = timestamp;
  	new->file_offset = file_offset;
 +	new->event = event;
 +
 +	__queue_event(new, s);
 +
  	return 0;
  }
  
diff --git a/tools/perf/util/event.h b/tools/perf/util/event.h
index 09b9e8d3fcf7..c4ffe2bd0738 100644
--- a/tools/perf/util/event.h
+++ b/tools/perf/util/event.h
@@ -242,6 +242,7 @@ struct events_stats {
 	u32 nr_invalid_chains;
 	u32 nr_unknown_id;
 	u32 nr_unprocessable_samples;
+	u32 nr_unordered_events;
 };
 
 struct attr_event {
* Unmerged path tools/perf/util/session.c
