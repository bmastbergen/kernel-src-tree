ipv6: drop some rcu_read_lock in mcast

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author WANG Cong <xiyou.wangcong@gmail.com>
commit 414b6c943fe25c5c576b6f0ce9077c29a150d826
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/414b6c94.failed

Similarly the code is already protected by rtnl lock.

	Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 414b6c943fe25c5c576b6f0ce9077c29a150d826)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/mcast.c
diff --cc net/ipv6/mcast.c
index 8c315d7cece8,4fb761d4002d..000000000000
--- a/net/ipv6/mcast.c
+++ b/net/ipv6/mcast.c
@@@ -173,7 -161,7 +173,11 @@@ int ipv6_sock_mc_join(struct sock *sk, 
  	mc_lst->next = NULL;
  	mc_lst->addr = *addr;
  
++<<<<<<< HEAD
 +	rcu_read_lock();
++=======
+ 	rtnl_lock();
++>>>>>>> 414b6c943fe2 (ipv6: drop some rcu_read_lock in mcast)
  	if (ifindex == 0) {
  		struct rt6_info *rt;
  		rt = rt6_lookup(net, addr, NULL, 0, 0);
@@@ -182,10 -170,10 +186,14 @@@
  			ip6_rt_put(rt);
  		}
  	} else
- 		dev = dev_get_by_index_rcu(net, ifindex);
+ 		dev = __dev_get_by_index(net, ifindex);
  
  	if (dev == NULL) {
++<<<<<<< HEAD
 +		rcu_read_unlock();
++=======
+ 		rtnl_unlock();
++>>>>>>> 414b6c943fe2 (ipv6: drop some rcu_read_lock in mcast)
  		sock_kfree_s(sk, mc_lst, sizeof(*mc_lst));
  		return -ENODEV;
  	}
@@@ -202,17 -190,15 +210,25 @@@
  	err = ipv6_dev_mc_inc(dev, addr);
  
  	if (err) {
++<<<<<<< HEAD
 +		rcu_read_unlock();
++=======
+ 		rtnl_unlock();
++>>>>>>> 414b6c943fe2 (ipv6: drop some rcu_read_lock in mcast)
  		sock_kfree_s(sk, mc_lst, sizeof(*mc_lst));
  		return err;
  	}
  
 +	spin_lock(&ipv6_sk_mc_lock);
  	mc_lst->next = np->ipv6_mc_list;
  	rcu_assign_pointer(np->ipv6_mc_list, mc_lst);
 +	spin_unlock(&ipv6_sk_mc_lock);
  
++<<<<<<< HEAD
 +	rcu_read_unlock();
++=======
+ 	rtnl_unlock();
++>>>>>>> 414b6c943fe2 (ipv6: drop some rcu_read_lock in mcast)
  
  	return 0;
  }
@@@ -240,10 -225,8 +256,9 @@@ int ipv6_sock_mc_drop(struct sock *sk, 
  			struct net_device *dev;
  
  			*lnk = mc_lst->next;
 +			spin_unlock(&ipv6_sk_mc_lock);
  
- 			rcu_read_lock();
- 			dev = dev_get_by_index_rcu(net, mc_lst->ifindex);
+ 			dev = __dev_get_by_index(net, mc_lst->ifindex);
  			if (dev != NULL) {
  				struct inet6_dev *idev = __in6_dev_get(dev);
  
@@@ -252,7 -235,8 +267,12 @@@
  					__ipv6_dev_mc_dec(idev, &mc_lst->addr);
  			} else
  				(void) ip6_mc_leave_src(sk, mc_lst, NULL);
++<<<<<<< HEAD
 +			rcu_read_unlock();
++=======
+ 			rtnl_unlock();
+ 
++>>>>>>> 414b6c943fe2 (ipv6: drop some rcu_read_lock in mcast)
  			atomic_sub(sizeof(*mc_lst), &sk->sk_omem_alloc);
  			kfree_rcu(mc_lst, rcu);
  			return 0;
@@@ -309,10 -292,8 +329,9 @@@ void ipv6_sock_mc_close(struct sock *sk
  		struct net_device *dev;
  
  		np->ipv6_mc_list = mc_lst->next;
 +		spin_unlock(&ipv6_sk_mc_lock);
  
- 		rcu_read_lock();
- 		dev = dev_get_by_index_rcu(net, mc_lst->ifindex);
+ 		dev = __dev_get_by_index(net, mc_lst->ifindex);
  		if (dev) {
  			struct inet6_dev *idev = __in6_dev_get(dev);
  
* Unmerged path net/ipv6/mcast.c
