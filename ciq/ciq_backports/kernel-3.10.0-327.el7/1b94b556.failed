Btrfs, raid56: use a variant to record the operation type

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Miao Xie <miaox@cn.fujitsu.com>
commit 1b94b5567e9c70ad3b24bd5e576a422246875c2a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/1b94b556.failed

We will introduce new operation type later, if we still use integer
variant as bool variant to record the operation type, we would add new
variant and increase the size of raid bio structure. It is not good,
by this patch, we define different number for different operation,
and we can just use a variant to record the operation type.

	Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
(cherry picked from commit 1b94b5567e9c70ad3b24bd5e576a422246875c2a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/raid56.c
diff --cc fs/btrfs/raid56.c
index 6c2905ba2744,0600bf69199e..000000000000
--- a/fs/btrfs/raid56.c
+++ b/fs/btrfs/raid56.c
@@@ -58,8 -58,22 +58,13 @@@
   */
  #define RBIO_CACHE_READY_BIT	3
  
 -/*
 - * bbio and raid_map is managed by the caller, so we shouldn't free
 - * them here. And besides that, all rbios with this flag should not
 - * be cached, because we need raid_map to check the rbios' stripe
 - * is the same or not, but it is very likely that the caller has
 - * free raid_map, so don't cache those rbios.
 - */
 -#define RBIO_HOLD_BBIO_MAP_BIT	4
 -
  #define RBIO_CACHE_SIZE 1024
  
+ enum btrfs_rbio_ops {
+ 	BTRFS_RBIO_WRITE	= 0,
+ 	BTRFS_RBIO_READ_REBUILD	= 1,
+ };
+ 
  struct btrfs_raid_bio {
  	struct btrfs_fs_info *fs_info;
  	struct btrfs_bio *bbio;
@@@ -1692,10 -1717,13 +1695,15 @@@ int raid56_parity_write(struct btrfs_ro
  	struct blk_plug_cb *cb;
  
  	rbio = alloc_rbio(root, bbio, raid_map, stripe_len);
 -	if (IS_ERR(rbio)) {
 -		__free_bbio_and_raid_map(bbio, raid_map, 1);
 +	if (IS_ERR(rbio))
  		return PTR_ERR(rbio);
 -	}
  	bio_list_add(&rbio->bio_list, bio);
++<<<<<<< HEAD
 +	rbio->bio_list_bytes = bio->bi_size;
++=======
+ 	rbio->bio_list_bytes = bio->bi_iter.bi_size;
+ 	rbio->operation = BTRFS_RBIO_WRITE;
++>>>>>>> 1b94b5567e9c (Btrfs, raid56: use a variant to record the operation type)
  
  	/*
  	 * don't plug on full rbios, just get them out the door
@@@ -1886,9 -1914,9 +1894,15 @@@ cleanup
  	kfree(pointers);
  
  cleanup_io:
++<<<<<<< HEAD
 +
 +	if (rbio->read_rebuild) {
 +		if (err == 0)
++=======
+ 	if (rbio->operation == BTRFS_RBIO_READ_REBUILD) {
+ 		if (err == 0 &&
+ 		    !test_bit(RBIO_HOLD_BBIO_MAP_BIT, &rbio->flags))
++>>>>>>> 1b94b5567e9c (Btrfs, raid56: use a variant to record the operation type)
  			cache_rbio_pages(rbio);
  		else
  			clear_bit(RBIO_CACHE_READY_BIT, &rbio->flags);
@@@ -2044,12 -2072,16 +2058,18 @@@ int raid56_parity_recover(struct btrfs_
  	int ret;
  
  	rbio = alloc_rbio(root, bbio, raid_map, stripe_len);
 -	if (IS_ERR(rbio)) {
 -		__free_bbio_and_raid_map(bbio, raid_map, !hold_bbio);
 +	if (IS_ERR(rbio))
  		return PTR_ERR(rbio);
 -	}
  
++<<<<<<< HEAD
 +	rbio->read_rebuild = 1;
++=======
+ 	if (hold_bbio)
+ 		set_bit(RBIO_HOLD_BBIO_MAP_BIT, &rbio->flags);
+ 	rbio->operation = BTRFS_RBIO_READ_REBUILD;
++>>>>>>> 1b94b5567e9c (Btrfs, raid56: use a variant to record the operation type)
  	bio_list_add(&rbio->bio_list, bio);
 -	rbio->bio_list_bytes = bio->bi_iter.bi_size;
 +	rbio->bio_list_bytes = bio->bi_size;
  
  	rbio->faila = find_logical_bio_stripe(rbio, bio);
  	if (rbio->faila == -1) {
* Unmerged path fs/btrfs/raid56.c
