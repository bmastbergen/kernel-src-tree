arch/x86/mm/numa.c: fix boot failure when all nodes are hotpluggable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [x86] mm: numa: fix boot failure when all nodes are hotpluggable (Dave Young) [1188542]
Rebuild_FUZZ: 88.89%
commit-author Xishi Qiu <qiuxishi@huawei.com>
commit bd5cfb8977fbb49d9350f7c81cf1516142e35a6a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/bd5cfb89.failed

If all the nodes are marked hotpluggable, alloc node data will fail.
Because __next_mem_range_rev() will skip the hotpluggable memory
regions.  numa_clear_kernel_node_hotplug() is called after alloc node
data.

numa_init()
    ...
    ret = init_func();  // this will mark hotpluggable flag from SRAT
    ...
    memblock_set_bottom_up(false);
    ...
    ret = numa_register_memblks(&numa_meminfo);  // this will alloc node data(pglist_data)
    ...
    numa_clear_kernel_node_hotplug();  // in case all the nodes are hotpluggable
    ...

numa_register_memblks()
    setup_node_data()
        memblock_find_in_range_node()
            __memblock_find_range_top_down()
                for_each_mem_range_rev()
                    __next_mem_range_rev()

This patch moves numa_clear_kernel_node_hotplug() into
numa_register_memblks(), clear kernel node hotpluggable flag before
alloc node data, then alloc node data won't fail even all the nodes
are hotpluggable.

[akpm@linux-foundation.org: coding-style fixes]
	Signed-off-by: Xishi Qiu <qiuxishi@huawei.com>
	Cc: Dave Jones <davej@redhat.com>
	Cc: Tang Chen <tangchen@cn.fujitsu.com>
	Cc: Gu Zheng <guz.fnst@cn.fujitsu.com>
	Cc: Ingo Molnar <mingo@elte.hu>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit bd5cfb8977fbb49d9350f7c81cf1516142e35a6a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/mm/numa.c
diff --cc arch/x86/mm/numa.c
index 9e0f45ec0cf5,4e1e5709fe17..000000000000
--- a/arch/x86/mm/numa.c
+++ b/arch/x86/mm/numa.c
@@@ -549,41 -599,6 +594,44 @@@ static void __init numa_init_array(void
  	}
  }
  
++<<<<<<< HEAD
 +static void __init numa_clear_kernel_node_hotplug(void)
 +{
 +	int i, nid;
 +	nodemask_t numa_kernel_nodes = NODE_MASK_NONE;
 +	unsigned long start, end;
 +	struct memblock_type *type = &memblock.reserved;
 +
 +	/*
 +	 * At this time, all memory regions reserved by memblock are
 +	 * used by the kernel. Set the nid in memblock.reserved will
 +	 * mark out all the nodes the kernel resides in.
 +	 */
 +	for (i = 0; i < numa_meminfo.nr_blks; i++) {
 +		struct numa_memblk *mb = &numa_meminfo.blk[i];
 +		memblock_set_node(mb->start, mb->end - mb->start,
 +				  &memblock.reserved, mb->nid);
 +	}
 +
 +	/* Mark all kernel nodes. */
 +	for (i = 0; i < type->cnt; i++)
 +		node_set(type->regions[i].nid, numa_kernel_nodes);
 +
 +	/* Clear MEMBLOCK_HOTPLUG flag for memory in kernel nodes. */
 +	for (i = 0; i < numa_meminfo.nr_blks; i++) {
 +		nid = numa_meminfo.blk[i].nid;
 +		if (!node_isset(nid, numa_kernel_nodes))
 +			continue;
 +
 +		start = numa_meminfo.blk[i].start;
 +		end = numa_meminfo.blk[i].end;
 +
 +		memblock_clear_hotplug(start, end - start);
 +	}
 +}
 +
++=======
++>>>>>>> bd5cfb8977fb (arch/x86/mm/numa.c: fix boot failure when all nodes are hotpluggable)
  static int __init numa_init(int (*init_func)(void))
  {
  	int i;
* Unmerged path arch/x86/mm/numa.c
