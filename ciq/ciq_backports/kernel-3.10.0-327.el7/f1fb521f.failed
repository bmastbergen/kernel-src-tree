ip_tunnel: Add missing validation of encap type to ip_tunnel_encap_setup()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Thomas Graf <tgraf@suug.ch>
commit f1fb521f7d94c35e278d76a9198f078223f26799
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/f1fb521f.failed

The encap->type comes straight from Netlink. Validate it against
max supported encap types just like ip_encap_hlen() already does.

Fixes: a8c5f9 ("ip_tunnel: Ops registration for secondary encap (fou, gue)")
	Signed-off-by: Thomas Graf <tgraf@suug.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f1fb521f7d94c35e278d76a9198f078223f26799)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/ip_tunnel.c
diff --cc net/ipv4/ip_tunnel.c
index 1129aec53c2c,d3e447936720..000000000000
--- a/net/ipv4/ip_tunnel.c
+++ b/net/ipv4/ip_tunnel.c
@@@ -479,6 -488,104 +479,107 @@@ drop
  }
  EXPORT_SYMBOL_GPL(ip_tunnel_rcv);
  
++<<<<<<< HEAD
++=======
+ static int ip_encap_hlen(struct ip_tunnel_encap *e)
+ {
+ 	const struct ip_tunnel_encap_ops *ops;
+ 	int hlen = -EINVAL;
+ 
+ 	if (e->type == TUNNEL_ENCAP_NONE)
+ 		return 0;
+ 
+ 	if (e->type >= MAX_IPTUN_ENCAP_OPS)
+ 		return -EINVAL;
+ 
+ 	rcu_read_lock();
+ 	ops = rcu_dereference(iptun_encaps[e->type]);
+ 	if (likely(ops && ops->encap_hlen))
+ 		hlen = ops->encap_hlen(e);
+ 	rcu_read_unlock();
+ 
+ 	return hlen;
+ }
+ 
+ const struct ip_tunnel_encap_ops __rcu *
+ 		iptun_encaps[MAX_IPTUN_ENCAP_OPS] __read_mostly;
+ 
+ int ip_tunnel_encap_add_ops(const struct ip_tunnel_encap_ops *ops,
+ 			    unsigned int num)
+ {
+ 	if (num >= MAX_IPTUN_ENCAP_OPS)
+ 		return -ERANGE;
+ 
+ 	return !cmpxchg((const struct ip_tunnel_encap_ops **)
+ 			&iptun_encaps[num],
+ 			NULL, ops) ? 0 : -1;
+ }
+ EXPORT_SYMBOL(ip_tunnel_encap_add_ops);
+ 
+ int ip_tunnel_encap_del_ops(const struct ip_tunnel_encap_ops *ops,
+ 			    unsigned int num)
+ {
+ 	int ret;
+ 
+ 	if (num >= MAX_IPTUN_ENCAP_OPS)
+ 		return -ERANGE;
+ 
+ 	ret = (cmpxchg((const struct ip_tunnel_encap_ops **)
+ 		       &iptun_encaps[num],
+ 		       ops, NULL) == ops) ? 0 : -1;
+ 
+ 	synchronize_net();
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL(ip_tunnel_encap_del_ops);
+ 
+ int ip_tunnel_encap_setup(struct ip_tunnel *t,
+ 			  struct ip_tunnel_encap *ipencap)
+ {
+ 	int hlen;
+ 
+ 	memset(&t->encap, 0, sizeof(t->encap));
+ 
+ 	hlen = ip_encap_hlen(ipencap);
+ 	if (hlen < 0)
+ 		return hlen;
+ 
+ 	t->encap.type = ipencap->type;
+ 	t->encap.sport = ipencap->sport;
+ 	t->encap.dport = ipencap->dport;
+ 	t->encap.flags = ipencap->flags;
+ 
+ 	t->encap_hlen = hlen;
+ 	t->hlen = t->encap_hlen + t->tun_hlen;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(ip_tunnel_encap_setup);
+ 
+ int ip_tunnel_encap(struct sk_buff *skb, struct ip_tunnel *t,
+ 		    u8 *protocol, struct flowi4 *fl4)
+ {
+ 	const struct ip_tunnel_encap_ops *ops;
+ 	int ret = -EINVAL;
+ 
+ 	if (t->encap.type == TUNNEL_ENCAP_NONE)
+ 		return 0;
+ 
+ 	if (t->encap.type >= MAX_IPTUN_ENCAP_OPS)
+ 		return -EINVAL;
+ 
+ 	rcu_read_lock();
+ 	ops = rcu_dereference(iptun_encaps[t->encap.type]);
+ 	if (likely(ops && ops->build_header))
+ 		ret = ops->build_header(skb, &t->encap, protocol, fl4);
+ 	rcu_read_unlock();
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL(ip_tunnel_encap);
+ 
++>>>>>>> f1fb521f7d94 (ip_tunnel: Add missing validation of encap type to ip_tunnel_encap_setup())
  static int tnl_update_pmtu(struct net_device *dev, struct sk_buff *skb,
  			    struct rtable *rt, __be16 df)
  {
* Unmerged path net/ipv4/ip_tunnel.c
