x86: irq: Fix placement of mp_should_keep_irq()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [x86] irq: Fix placement of mp_should_keep_irq() (Steve Best) [1231358 1238216]
Rebuild_FUZZ: 94.38%
commit-author Jan Beulich <JBeulich@suse.com>
commit e10679825924580845c4825deaaddf5331ff627c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/e1067982.failed

While f3761db164 ("x86, irq: Fix build error caused by
9eabc99a635a77cbf09") addressed the original build problem,
declaration, inline stub, and definition still seem misplaced: It isn't
really IO-APIC related, and it's being used solely in arch/x86/pci/.
This also means stubbing it out when !CONFIG_X86_IO_APIC was at least
questionable.

	Signed-off-by: Jan Beulich <jbeulich@suse.com>
	Cc: Jiang Liu <jiang.liu@linux.intel.com>
Link: http://lkml.kernel.org/r/545747BE020000780004436E@mail.emea.novell.com
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit e10679825924580845c4825deaaddf5331ff627c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/io_apic.h
#	arch/x86/kernel/apic/io_apic.c
#	arch/x86/pci/irq.c
diff --cc arch/x86/include/asm/io_apic.h
index 7eb3755fee9a,0aeed5ca356e..000000000000
--- a/arch/x86/include/asm/io_apic.h
+++ b/arch/x86/include/asm/io_apic.h
@@@ -219,10 -235,8 +219,15 @@@ static inline void ioapic_insert_resour
  #define gsi_top (NR_IRQS_LEGACY)
  static inline int mp_find_ioapic(u32 gsi) { return 0; }
  static inline u32 mp_pin_to_gsi(int ioapic, int pin) { return UINT_MAX; }
++<<<<<<< HEAD
 +
 +struct io_apic_irq_attr;
 +static inline int io_apic_set_pci_routing(struct device *dev, int irq,
 +		 struct io_apic_irq_attr *irq_attr) { return 0; }
++=======
+ static inline int mp_map_gsi_to_irq(u32 gsi, unsigned int flags) { return gsi; }
+ static inline void mp_unmap_irq(int irq) { }
++>>>>>>> e10679825924 (x86: irq: Fix placement of mp_should_keep_irq())
  
  static inline int save_ioapic_entries(void)
  {
diff --cc arch/x86/kernel/apic/io_apic.c
index 07a33b81b46c,a157b666ac36..000000000000
--- a/arch/x86/kernel/apic/io_apic.c
+++ b/arch/x86/kernel/apic/io_apic.c
@@@ -3863,6 -3885,85 +3863,88 @@@ void __init mp_register_ioapic(int id, 
  	nr_ioapics++;
  }
  
++<<<<<<< HEAD
++=======
+ int mp_irqdomain_map(struct irq_domain *domain, unsigned int virq,
+ 		     irq_hw_number_t hwirq)
+ {
+ 	int ioapic = (int)(long)domain->host_data;
+ 	struct mp_pin_info *info = mp_pin_info(ioapic, hwirq);
+ 	struct io_apic_irq_attr attr;
+ 
+ 	/* Get default attribute if not set by caller yet */
+ 	if (!info->set) {
+ 		u32 gsi = mp_pin_to_gsi(ioapic, hwirq);
+ 
+ 		if (acpi_get_override_irq(gsi, &info->trigger,
+ 					  &info->polarity) < 0) {
+ 			/*
+ 			 * PCI interrupts are always polarity one level
+ 			 * triggered.
+ 			 */
+ 			info->trigger = 1;
+ 			info->polarity = 1;
+ 		}
+ 		info->node = NUMA_NO_NODE;
+ 
+ 		/*
+ 		 * setup_IO_APIC_irqs() programs all legacy IRQs with default
+ 		 * trigger and polarity attributes. Don't set the flag for that
+ 		 * case so the first legacy IRQ user could reprogram the pin
+ 		 * with real trigger and polarity attributes.
+ 		 */
+ 		if (virq >= nr_legacy_irqs() || info->count)
+ 			info->set = 1;
+ 	}
+ 	set_io_apic_irq_attr(&attr, ioapic, hwirq, info->trigger,
+ 			     info->polarity);
+ 
+ 	return io_apic_setup_irq_pin(virq, info->node, &attr);
+ }
+ 
+ void mp_irqdomain_unmap(struct irq_domain *domain, unsigned int virq)
+ {
+ 	struct irq_data *data = irq_get_irq_data(virq);
+ 	struct irq_cfg *cfg = irq_cfg(virq);
+ 	int ioapic = (int)(long)domain->host_data;
+ 	int pin = (int)data->hwirq;
+ 
+ 	ioapic_mask_entry(ioapic, pin);
+ 	__remove_pin_from_irq(cfg, ioapic, pin);
+ 	WARN_ON(cfg->irq_2_pin != NULL);
+ 	arch_teardown_hwirq(virq);
+ }
+ 
+ int mp_set_gsi_attr(u32 gsi, int trigger, int polarity, int node)
+ {
+ 	int ret = 0;
+ 	int ioapic, pin;
+ 	struct mp_pin_info *info;
+ 
+ 	ioapic = mp_find_ioapic(gsi);
+ 	if (ioapic < 0)
+ 		return -ENODEV;
+ 
+ 	pin = mp_find_ioapic_pin(ioapic, gsi);
+ 	info = mp_pin_info(ioapic, pin);
+ 	trigger = trigger ? 1 : 0;
+ 	polarity = polarity ? 1 : 0;
+ 
+ 	mutex_lock(&ioapic_mutex);
+ 	if (!info->set) {
+ 		info->trigger = trigger;
+ 		info->polarity = polarity;
+ 		info->node = node;
+ 		info->set = 1;
+ 	} else if (info->trigger != trigger || info->polarity != polarity) {
+ 		ret = -EBUSY;
+ 	}
+ 	mutex_unlock(&ioapic_mutex);
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> e10679825924 (x86: irq: Fix placement of mp_should_keep_irq())
  /* Enable IOAPIC early just for system timer */
  void __init pre_init_apic_IRQ0(void)
  {
diff --cc arch/x86/pci/irq.c
index 84112f55dd7a,cb50e281d838..000000000000
--- a/arch/x86/pci/irq.c
+++ b/arch/x86/pci/irq.c
@@@ -1254,3 -1253,24 +1254,27 @@@ static int pirq_enable_irq(struct pci_d
  	}
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ 
+ bool mp_should_keep_irq(struct device *dev)
+ {
+ 	if (dev->power.is_prepared)
+ 		return true;
+ #ifdef CONFIG_PM_RUNTIME
+ 	if (dev->power.runtime_status == RPM_SUSPENDING)
+ 		return true;
+ #endif
+ 
+ 	return false;
+ }
+ 
+ static void pirq_disable_irq(struct pci_dev *dev)
+ {
+ 	if (io_apic_assign_pci_irqs && !mp_should_keep_irq(&dev->dev) &&
+ 	    dev->irq) {
+ 		mp_unmap_irq(dev->irq);
+ 		dev->irq = 0;
+ 	}
+ }
++>>>>>>> e10679825924 (x86: irq: Fix placement of mp_should_keep_irq())
* Unmerged path arch/x86/include/asm/io_apic.h
diff --git a/arch/x86/include/asm/pci_x86.h b/arch/x86/include/asm/pci_x86.h
index fa1195dae425..164e3f8d3c3d 100644
--- a/arch/x86/include/asm/pci_x86.h
+++ b/arch/x86/include/asm/pci_x86.h
@@ -93,6 +93,8 @@ extern raw_spinlock_t pci_config_lock;
 extern int (*pcibios_enable_irq)(struct pci_dev *dev);
 extern void (*pcibios_disable_irq)(struct pci_dev *dev);
 
+extern bool mp_should_keep_irq(struct device *dev);
+
 struct pci_raw_ops {
 	int (*read)(unsigned int domain, unsigned int bus, unsigned int devfn,
 						int reg, int len, u32 *val);
* Unmerged path arch/x86/kernel/apic/io_apic.c
* Unmerged path arch/x86/pci/irq.c
